{
  "module_name": "twl6040-vibra.c",
  "hash_id": "a17c678c168431beac6f06fd06f57c8486ab0f4b222d491c4800143ea52c3bb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/twl6040-vibra.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/workqueue.h>\n#include <linux/input.h>\n#include <linux/mfd/twl6040.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n\n#define EFFECT_DIR_180_DEG\t0x8000\n\n \n#define TWL6040_VIBRA_MOD\t85\n\n#define TWL6040_NUM_SUPPLIES 2\n\nstruct vibra_info {\n\tstruct device *dev;\n\tstruct input_dev *input_dev;\n\tstruct work_struct play_work;\n\n\tint irq;\n\n\tbool enabled;\n\tint weak_speed;\n\tint strong_speed;\n\tint direction;\n\n\tunsigned int vibldrv_res;\n\tunsigned int vibrdrv_res;\n\tunsigned int viblmotor_res;\n\tunsigned int vibrmotor_res;\n\n\tstruct regulator_bulk_data supplies[TWL6040_NUM_SUPPLIES];\n\n\tstruct twl6040 *twl6040;\n};\n\nstatic irqreturn_t twl6040_vib_irq_handler(int irq, void *data)\n{\n\tstruct vibra_info *info = data;\n\tstruct twl6040 *twl6040 = info->twl6040;\n\tu8 status;\n\n\tstatus = twl6040_reg_read(twl6040, TWL6040_REG_STATUS);\n\tif (status & TWL6040_VIBLOCDET) {\n\t\tdev_warn(info->dev, \"Left Vibrator overcurrent detected\\n\");\n\t\ttwl6040_clear_bits(twl6040, TWL6040_REG_VIBCTLL,\n\t\t\t\t   TWL6040_VIBENA);\n\t}\n\tif (status & TWL6040_VIBROCDET) {\n\t\tdev_warn(info->dev, \"Right Vibrator overcurrent detected\\n\");\n\t\ttwl6040_clear_bits(twl6040, TWL6040_REG_VIBCTLR,\n\t\t\t\t   TWL6040_VIBENA);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void twl6040_vibra_enable(struct vibra_info *info)\n{\n\tstruct twl6040 *twl6040 = info->twl6040;\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(info->supplies), info->supplies);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to enable regulators %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ttwl6040_power(info->twl6040, 1);\n\tif (twl6040_get_revid(twl6040) <= TWL6040_REV_ES1_1) {\n\t\t \n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLL,\n\t\t\t\t  TWL6040_VIBENA | TWL6040_VIBCTRL);\n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLR,\n\t\t\t\t  TWL6040_VIBENA | TWL6040_VIBCTRL);\n\t\tusleep_range(3000, 3500);\n\t}\n\n\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLL,\n\t\t\t  TWL6040_VIBENA);\n\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLR,\n\t\t\t  TWL6040_VIBENA);\n\n\tinfo->enabled = true;\n}\n\nstatic void twl6040_vibra_disable(struct vibra_info *info)\n{\n\tstruct twl6040 *twl6040 = info->twl6040;\n\n\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLL, 0x00);\n\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLR, 0x00);\n\ttwl6040_power(info->twl6040, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(info->supplies), info->supplies);\n\n\tinfo->enabled = false;\n}\n\nstatic u8 twl6040_vibra_code(int vddvib, int vibdrv_res, int motor_res,\n\t\t\t     int speed, int direction)\n{\n\tint vpk, max_code;\n\tu8 vibdat;\n\n\t \n\tvpk = (vddvib * motor_res * TWL6040_VIBRA_MOD) /\n\t\t(100 * (vibdrv_res + motor_res));\n\n\t \n\tmax_code = vpk / 50;\n\tif (max_code > TWL6040_VIBDAT_MAX)\n\t\tmax_code = TWL6040_VIBDAT_MAX;\n\n\t \n\tvibdat = (u8)((speed * max_code) / USHRT_MAX);\n\n\t \n\tvibdat *= direction;\n\n\treturn vibdat;\n}\n\nstatic void twl6040_vibra_set_effect(struct vibra_info *info)\n{\n\tstruct twl6040 *twl6040 = info->twl6040;\n\tu8 vibdatl, vibdatr;\n\tint volt;\n\n\t \n\tvolt = regulator_get_voltage(info->supplies[0].consumer) / 1000;\n\tvibdatl = twl6040_vibra_code(volt, info->vibldrv_res,\n\t\t\t\t     info->viblmotor_res,\n\t\t\t\t     info->weak_speed, info->direction);\n\n\t \n\tvolt = regulator_get_voltage(info->supplies[1].consumer) / 1000;\n\tvibdatr = twl6040_vibra_code(volt, info->vibrdrv_res,\n\t\t\t\t     info->vibrmotor_res,\n\t\t\t\t     info->strong_speed, info->direction);\n\n\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBDATL, vibdatl);\n\ttwl6040_reg_write(twl6040, TWL6040_REG_VIBDATR, vibdatr);\n}\n\nstatic void vibra_play_work(struct work_struct *work)\n{\n\tstruct vibra_info *info = container_of(work,\n\t\t\t\tstruct vibra_info, play_work);\n\tint ret;\n\n\t \n\tret = twl6040_get_vibralr_status(info->twl6040);\n\tif (ret & TWL6040_VIBSEL) {\n\t\tdev_info(info->dev, \"Vibra is configured for audio\\n\");\n\t\treturn;\n\t}\n\n\tif (info->weak_speed || info->strong_speed) {\n\t\tif (!info->enabled)\n\t\t\ttwl6040_vibra_enable(info);\n\n\t\ttwl6040_vibra_set_effect(info);\n\t} else if (info->enabled)\n\t\ttwl6040_vibra_disable(info);\n\n}\n\nstatic int vibra_play(struct input_dev *input, void *data,\n\t\t      struct ff_effect *effect)\n{\n\tstruct vibra_info *info = input_get_drvdata(input);\n\n\tinfo->weak_speed = effect->u.rumble.weak_magnitude;\n\tinfo->strong_speed = effect->u.rumble.strong_magnitude;\n\tinfo->direction = effect->direction < EFFECT_DIR_180_DEG ? 1 : -1;\n\n\tschedule_work(&info->play_work);\n\n\treturn 0;\n}\n\nstatic void twl6040_vibra_close(struct input_dev *input)\n{\n\tstruct vibra_info *info = input_get_drvdata(input);\n\n\tcancel_work_sync(&info->play_work);\n\n\tif (info->enabled)\n\t\ttwl6040_vibra_disable(info);\n}\n\nstatic int twl6040_vibra_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct vibra_info *info = platform_get_drvdata(pdev);\n\n\tcancel_work_sync(&info->play_work);\n\n\tif (info->enabled)\n\t\ttwl6040_vibra_disable(info);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(twl6040_vibra_pm_ops,\n\t\t\t\ttwl6040_vibra_suspend, NULL);\n\nstatic int twl6040_vibra_probe(struct platform_device *pdev)\n{\n\tstruct device *twl6040_core_dev = pdev->dev.parent;\n\tstruct device_node *twl6040_core_node;\n\tstruct vibra_info *info;\n\tint vddvibl_uV = 0;\n\tint vddvibr_uV = 0;\n\tint error;\n\n\ttwl6040_core_node = of_get_child_by_name(twl6040_core_dev->of_node,\n\t\t\t\t\t\t \"vibra\");\n\tif (!twl6040_core_node) {\n\t\tdev_err(&pdev->dev, \"parent of node is missing?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tof_node_put(twl6040_core_node);\n\t\tdev_err(&pdev->dev, \"couldn't allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->dev = &pdev->dev;\n\n\tinfo->twl6040 = dev_get_drvdata(pdev->dev.parent);\n\n\tof_property_read_u32(twl6040_core_node, \"ti,vibldrv-res\",\n\t\t\t     &info->vibldrv_res);\n\tof_property_read_u32(twl6040_core_node, \"ti,vibrdrv-res\",\n\t\t\t     &info->vibrdrv_res);\n\tof_property_read_u32(twl6040_core_node, \"ti,viblmotor-res\",\n\t\t\t     &info->viblmotor_res);\n\tof_property_read_u32(twl6040_core_node, \"ti,vibrmotor-res\",\n\t\t\t     &info->vibrmotor_res);\n\tof_property_read_u32(twl6040_core_node, \"ti,vddvibl-uV\", &vddvibl_uV);\n\tof_property_read_u32(twl6040_core_node, \"ti,vddvibr-uV\", &vddvibr_uV);\n\n\tof_node_put(twl6040_core_node);\n\n\tif ((!info->vibldrv_res && !info->viblmotor_res) ||\n\t    (!info->vibrdrv_res && !info->vibrmotor_res)) {\n\t\tdev_err(info->dev, \"invalid vibra driver/motor resistance\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->irq = platform_get_irq(pdev, 0);\n\tif (info->irq < 0)\n\t\treturn -EINVAL;\n\n\terror = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\n\t\t\t\t\t  twl6040_vib_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"twl6040_irq_vib\", info);\n\tif (error) {\n\t\tdev_err(info->dev, \"VIB IRQ request failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinfo->supplies[0].supply = \"vddvibl\";\n\tinfo->supplies[1].supply = \"vddvibr\";\n\t \n\terror = devm_regulator_bulk_get(twl6040_core_dev,\n\t\t\t\t\tARRAY_SIZE(info->supplies),\n\t\t\t\t\tinfo->supplies);\n\tif (error) {\n\t\tdev_err(info->dev, \"couldn't get regulators %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (vddvibl_uV) {\n\t\terror = regulator_set_voltage(info->supplies[0].consumer,\n\t\t\t\t\t      vddvibl_uV, vddvibl_uV);\n\t\tif (error) {\n\t\t\tdev_err(info->dev, \"failed to set VDDVIBL volt %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (vddvibr_uV) {\n\t\terror = regulator_set_voltage(info->supplies[1].consumer,\n\t\t\t\t\t      vddvibr_uV, vddvibr_uV);\n\t\tif (error) {\n\t\t\tdev_err(info->dev, \"failed to set VDDVIBR volt %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tINIT_WORK(&info->play_work, vibra_play_work);\n\n\tinfo->input_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!info->input_dev) {\n\t\tdev_err(info->dev, \"couldn't allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(info->input_dev, info);\n\n\tinfo->input_dev->name = \"twl6040:vibrator\";\n\tinfo->input_dev->id.version = 1;\n\tinfo->input_dev->close = twl6040_vibra_close;\n\t__set_bit(FF_RUMBLE, info->input_dev->ffbit);\n\n\terror = input_ff_create_memless(info->input_dev, NULL, vibra_play);\n\tif (error) {\n\t\tdev_err(info->dev, \"couldn't register vibrator to FF\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(info->input_dev);\n\tif (error) {\n\t\tdev_err(info->dev, \"couldn't register input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\n\treturn 0;\n}\n\nstatic struct platform_driver twl6040_vibra_driver = {\n\t.probe\t\t= twl6040_vibra_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"twl6040-vibra\",\n\t\t.pm\t= pm_sleep_ptr(&twl6040_vibra_pm_ops),\n\t},\n};\nmodule_platform_driver(twl6040_vibra_driver);\n\nMODULE_ALIAS(\"platform:twl6040-vibra\");\nMODULE_DESCRIPTION(\"TWL6040 Vibra driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jorge Eduardo Candelaria <jorge.candelaria@ti.com>\");\nMODULE_AUTHOR(\"Misael Lopez Cruz <misael.lopez@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}