{
  "module_name": "ibm-panel.c",
  "hash_id": "9357a790a8aca2834363013cce7c2790214c3a5fd99c7a595dd001d600035abb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/ibm-panel.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spinlock.h>\n\n#define DEVICE_NAME\t\t\"ibm-panel\"\n#define PANEL_KEYCODES_COUNT\t3\n\nstruct ibm_panel {\n\tu8 idx;\n\tu8 command[11];\n\tu32 keycodes[PANEL_KEYCODES_COUNT];\n\tspinlock_t lock;\t \n\tstruct input_dev *input;\n};\n\nstatic u8 ibm_panel_calculate_checksum(struct ibm_panel *panel)\n{\n\tu8 chksum;\n\tu16 sum = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < sizeof(panel->command) - 1; ++i) {\n\t\tsum += panel->command[i];\n\t\tif (sum & 0xff00) {\n\t\t\tsum &= 0xff;\n\t\t\tsum++;\n\t\t}\n\t}\n\n\tchksum = sum & 0xff;\n\tchksum = ~chksum;\n\tchksum++;\n\n\treturn chksum;\n}\n\nstatic void ibm_panel_process_command(struct ibm_panel *panel)\n{\n\tu8 button;\n\tu8 chksum;\n\n\tif (panel->command[0] != 0xff && panel->command[1] != 0xf0) {\n\t\tdev_dbg(&panel->input->dev, \"command invalid: %02x %02x\\n\",\n\t\t\tpanel->command[0], panel->command[1]);\n\t\treturn;\n\t}\n\n\tchksum = ibm_panel_calculate_checksum(panel);\n\tif (chksum != panel->command[sizeof(panel->command) - 1]) {\n\t\tdev_dbg(&panel->input->dev,\n\t\t\t\"command failed checksum: %u != %u\\n\", chksum,\n\t\t\tpanel->command[sizeof(panel->command) - 1]);\n\t\treturn;\n\t}\n\n\tbutton = panel->command[2] & 0xf;\n\tif (button < PANEL_KEYCODES_COUNT) {\n\t\tinput_report_key(panel->input, panel->keycodes[button],\n\t\t\t\t !(panel->command[2] & 0x80));\n\t\tinput_sync(panel->input);\n\t} else {\n\t\tdev_dbg(&panel->input->dev, \"unknown button %u\\n\",\n\t\t\tbutton);\n\t}\n}\n\nstatic int ibm_panel_i2c_slave_cb(struct i2c_client *client,\n\t\t\t\t  enum i2c_slave_event event, u8 *val)\n{\n\tunsigned long flags;\n\tstruct ibm_panel *panel = i2c_get_clientdata(client);\n\n\tdev_dbg(&panel->input->dev, \"event: %u data: %02x\\n\", event, *val);\n\n\tspin_lock_irqsave(&panel->lock, flags);\n\n\tswitch (event) {\n\tcase I2C_SLAVE_STOP:\n\t\tif (panel->idx == sizeof(panel->command))\n\t\t\tibm_panel_process_command(panel);\n\t\telse\n\t\t\tdev_dbg(&panel->input->dev,\n\t\t\t\t\"command incorrect size %u\\n\", panel->idx);\n\t\tfallthrough;\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\tpanel->idx = 0;\n\t\tbreak;\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\tif (panel->idx < sizeof(panel->command))\n\t\t\tpanel->command[panel->idx++] = *val;\n\t\telse\n\t\t\t \n\t\t\tpanel->idx = U8_MAX;\n\t\tbreak;\n\tcase I2C_SLAVE_READ_REQUESTED:\n\tcase I2C_SLAVE_READ_PROCESSED:\n\t\t*val = 0xff;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&panel->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ibm_panel_probe(struct i2c_client *client)\n{\n\tstruct ibm_panel *panel;\n\tint i;\n\tint error;\n\n\tpanel = devm_kzalloc(&client->dev, sizeof(*panel), GFP_KERNEL);\n\tif (!panel)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&panel->lock);\n\n\tpanel->input = devm_input_allocate_device(&client->dev);\n\tif (!panel->input)\n\t\treturn -ENOMEM;\n\n\tpanel->input->name = client->name;\n\tpanel->input->id.bustype = BUS_I2C;\n\n\terror = device_property_read_u32_array(&client->dev,\n\t\t\t\t\t       \"linux,keycodes\",\n\t\t\t\t\t       panel->keycodes,\n\t\t\t\t\t       PANEL_KEYCODES_COUNT);\n\tif (error) {\n\t\t \n\t\tpanel->keycodes[0] = BTN_NORTH;\n\t\tpanel->keycodes[1] = BTN_SOUTH;\n\t\tpanel->keycodes[2] = BTN_SELECT;\n\t}\n\n\tfor (i = 0; i < PANEL_KEYCODES_COUNT; ++i)\n\t\tinput_set_capability(panel->input, EV_KEY, panel->keycodes[i]);\n\n\terror = input_register_device(panel->input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, panel);\n\terror = i2c_slave_register(client, ibm_panel_i2c_slave_cb);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register as i2c slave: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void ibm_panel_remove(struct i2c_client *client)\n{\n\ti2c_slave_unregister(client);\n}\n\nstatic const struct of_device_id ibm_panel_match[] = {\n\t{ .compatible = \"ibm,op-panel\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ibm_panel_match);\n\nstatic struct i2c_driver ibm_panel_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.of_match_table = ibm_panel_match,\n\t},\n\t.probe = ibm_panel_probe,\n\t.remove = ibm_panel_remove,\n};\nmodule_i2c_driver(ibm_panel_driver);\n\nMODULE_AUTHOR(\"Eddie James <eajames@linux.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM Operation Panel Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}