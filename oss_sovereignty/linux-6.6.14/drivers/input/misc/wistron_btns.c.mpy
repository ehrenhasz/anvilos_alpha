{
  "module_name": "wistron_btns.c",
  "hash_id": "61aa402dedf0a8b521feaac513dd285d71a20b6b13e34120ee5128ac1635726e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/wistron_btns.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mc146818rtc.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/leds.h>\n\n \n#define POLL_INTERVAL_DEFAULT\t500  \n#define POLL_INTERVAL_BURST\t100  \n\n \n#define WIFI\t\t0x35\n#define BLUETOOTH\t0x34\n#define MAIL_LED\t0x31\n\nMODULE_AUTHOR(\"Miloslav Trmac <mitr@volny.cz>\");\nMODULE_DESCRIPTION(\"Wistron laptop button driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic bool force;  \nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Load even if computer is not in database\");\n\nstatic char *keymap_name;  \nmodule_param_named(keymap, keymap_name, charp, 0);\nMODULE_PARM_DESC(keymap, \"Keymap name, if it can't be autodetected [generic, 1557/MS2141]\");\n\nstatic struct platform_device *wistron_device;\n\n  \n\nstatic void __iomem *bios_entry_point;  \nstatic void __iomem *bios_code_map_base;\nstatic void __iomem *bios_data_map_base;\n\nstatic u8 cmos_address;\n\nstruct regs {\n\tu32 eax, ebx, ecx;\n};\n\nstatic void call_bios(struct regs *regs)\n{\n\tunsigned long flags;\n\n\tpreempt_disable();\n\tlocal_irq_save(flags);\n\tasm volatile (\"pushl %%ebp;\"\n\t\t      \"movl %7, %%ebp;\"\n\t\t      \"call *%6;\"\n\t\t      \"popl %%ebp\"\n\t\t      : \"=a\" (regs->eax), \"=b\" (regs->ebx), \"=c\" (regs->ecx)\n\t\t      : \"0\" (regs->eax), \"1\" (regs->ebx), \"2\" (regs->ecx),\n\t\t\t\"m\" (bios_entry_point), \"m\" (bios_data_map_base)\n\t\t      : \"edx\", \"edi\", \"esi\", \"memory\");\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}\n\nstatic ssize_t __init locate_wistron_bios(void __iomem *base)\n{\n\tstatic unsigned char __initdata signature[] =\n\t\t{ 0x42, 0x21, 0x55, 0x30 };\n\tssize_t offset;\n\n\tfor (offset = 0; offset < 0x10000; offset += 0x10) {\n\t\tif (check_signature(base + offset, signature,\n\t\t\t\t    sizeof(signature)) != 0)\n\t\t\treturn offset;\n\t}\n\treturn -1;\n}\n\nstatic int __init map_bios(void)\n{\n\tvoid __iomem *base;\n\tssize_t offset;\n\tu32 entry_point;\n\n\tbase = ioremap(0xF0000, 0x10000);  \n\toffset = locate_wistron_bios(base);\n\tif (offset < 0) {\n\t\tprintk(KERN_ERR \"wistron_btns: BIOS entry point not found\\n\");\n\t\tiounmap(base);\n\t\treturn -ENODEV;\n\t}\n\n\tentry_point = readl(base + offset + 5);\n\tprintk(KERN_DEBUG\n\t\t\"wistron_btns: BIOS signature found at %p, entry point %08X\\n\",\n\t\tbase + offset, entry_point);\n\n\tif (entry_point >= 0xF0000) {\n\t\tbios_code_map_base = base;\n\t\tbios_entry_point = bios_code_map_base + (entry_point & 0xFFFF);\n\t} else {\n\t\tiounmap(base);\n\t\tbios_code_map_base = ioremap(entry_point & ~0x3FFF, 0x4000);\n\t\tif (bios_code_map_base == NULL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"wistron_btns: Can't map BIOS code at %08X\\n\",\n\t\t\t\tentry_point & ~0x3FFF);\n\t\t\tgoto err;\n\t\t}\n\t\tbios_entry_point = bios_code_map_base + (entry_point & 0x3FFF);\n\t}\n\t \n\tbios_data_map_base = ioremap(0x400, 0xc00);\n\tif (bios_data_map_base == NULL) {\n\t\tprintk(KERN_ERR \"wistron_btns: Can't map BIOS data\\n\");\n\t\tgoto err_code;\n\t}\n\treturn 0;\n\nerr_code:\n\tiounmap(bios_code_map_base);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic inline void unmap_bios(void)\n{\n\tiounmap(bios_code_map_base);\n\tiounmap(bios_data_map_base);\n}\n\n  \n\nstatic u16 bios_pop_queue(void)\n{\n\tstruct regs regs;\n\n\tmemset(&regs, 0, sizeof (regs));\n\tregs.eax = 0x9610;\n\tregs.ebx = 0x061C;\n\tregs.ecx = 0x0000;\n\tcall_bios(&regs);\n\n\treturn regs.eax;\n}\n\nstatic void bios_attach(void)\n{\n\tstruct regs regs;\n\n\tmemset(&regs, 0, sizeof (regs));\n\tregs.eax = 0x9610;\n\tregs.ebx = 0x012E;\n\tcall_bios(&regs);\n}\n\nstatic void bios_detach(void)\n{\n\tstruct regs regs;\n\n\tmemset(&regs, 0, sizeof (regs));\n\tregs.eax = 0x9610;\n\tregs.ebx = 0x002E;\n\tcall_bios(&regs);\n}\n\nstatic u8 bios_get_cmos_address(void)\n{\n\tstruct regs regs;\n\n\tmemset(&regs, 0, sizeof (regs));\n\tregs.eax = 0x9610;\n\tregs.ebx = 0x051C;\n\tcall_bios(&regs);\n\n\treturn regs.ecx;\n}\n\nstatic u16 bios_get_default_setting(u8 subsys)\n{\n\tstruct regs regs;\n\n\tmemset(&regs, 0, sizeof (regs));\n\tregs.eax = 0x9610;\n\tregs.ebx = 0x0200 | subsys;\n\tcall_bios(&regs);\n\n\treturn regs.eax;\n}\n\nstatic void bios_set_state(u8 subsys, int enable)\n{\n\tstruct regs regs;\n\n\tmemset(&regs, 0, sizeof (regs));\n\tregs.eax = 0x9610;\n\tregs.ebx = (enable ? 0x0100 : 0x0000) | subsys;\n\tcall_bios(&regs);\n}\n\n \n\n#define KE_WIFI\t\t(KE_LAST + 1)\n#define KE_BLUETOOTH\t(KE_LAST + 2)\n\n#define FE_MAIL_LED 0x01\n#define FE_WIFI_LED 0x02\n#define FE_UNTESTED 0x80\n\nstatic struct key_entry *keymap;  \nstatic bool have_wifi;\nstatic bool have_bluetooth;\nstatic int leds_present;\t \n\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\n{\n\tconst struct key_entry *key;\n\n\tkeymap = dmi->driver_data;\n\tfor (key = keymap; key->type != KE_END; key++) {\n\t\tif (key->type == KE_WIFI)\n\t\t\thave_wifi = true;\n\t\telse if (key->type == KE_BLUETOOTH)\n\t\t\thave_bluetooth = true;\n\t}\n\tleds_present = key->code & (FE_MAIL_LED | FE_WIFI_LED);\n\n\treturn 1;\n}\n\nstatic struct key_entry keymap_empty[] __initdata = {\n\t{ KE_END, 0 }\n};\n\nstatic struct key_entry keymap_fs_amilo_pro_v2000[] __initdata = {\n\t{ KE_KEY,  0x01, {KEY_HELP} },\n\t{ KE_KEY,  0x11, {KEY_PROG1} },\n\t{ KE_KEY,  0x12, {KEY_PROG2} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_KEY,  0x31, {KEY_MAIL} },\n\t{ KE_KEY,  0x36, {KEY_WWW} },\n\t{ KE_END,  0 }\n};\n\nstatic struct key_entry keymap_fs_amilo_pro_v3505[] __initdata = {\n\t{ KE_KEY,       0x01, {KEY_HELP} },           \n\t{ KE_KEY,       0x06, {KEY_DISPLAYTOGGLE} },  \n\t{ KE_BLUETOOTH, 0x30 },                       \n\t{ KE_KEY,       0x31, {KEY_MAIL} },           \n\t{ KE_KEY,       0x36, {KEY_WWW} },            \n\t{ KE_WIFI,      0x78 },                       \n\t{ KE_END,       0 }\n};\n\nstatic struct key_entry keymap_fs_amilo_pro_v8210[] __initdata = {\n\t{ KE_KEY,       0x01, {KEY_HELP} },           \n\t{ KE_KEY,       0x06, {KEY_DISPLAYTOGGLE} },  \n\t{ KE_BLUETOOTH, 0x30 },                       \n\t{ KE_KEY,       0x31, {KEY_MAIL} },           \n\t{ KE_KEY,       0x36, {KEY_WWW} },            \n\t{ KE_WIFI,      0x78 },                       \n\t{ KE_END,       FE_WIFI_LED }\n};\n\nstatic struct key_entry keymap_fujitsu_n3510[] __initdata = {\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x71, {KEY_STOPCD} },\n\t{ KE_KEY, 0x72, {KEY_PLAYPAUSE} },\n\t{ KE_KEY, 0x74, {KEY_REWIND} },\n\t{ KE_KEY, 0x78, {KEY_FORWARD} },\n\t{ KE_END, 0 }\n};\n\nstatic struct key_entry keymap_wistron_ms2111[] __initdata = {\n\t{ KE_KEY,  0x11, {KEY_PROG1} },\n\t{ KE_KEY,  0x12, {KEY_PROG2} },\n\t{ KE_KEY,  0x13, {KEY_PROG3} },\n\t{ KE_KEY,  0x31, {KEY_MAIL} },\n\t{ KE_KEY,  0x36, {KEY_WWW} },\n\t{ KE_END, FE_MAIL_LED }\n};\n\nstatic struct key_entry keymap_wistron_md40100[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x37, {KEY_DISPLAYTOGGLE} },  \n\t{ KE_END, FE_MAIL_LED | FE_WIFI_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_wistron_ms2141[] __initdata = {\n\t{ KE_KEY,  0x11, {KEY_PROG1} },\n\t{ KE_KEY,  0x12, {KEY_PROG2} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_KEY,  0x22, {KEY_REWIND} },\n\t{ KE_KEY,  0x23, {KEY_FORWARD} },\n\t{ KE_KEY,  0x24, {KEY_PLAYPAUSE} },\n\t{ KE_KEY,  0x25, {KEY_STOPCD} },\n\t{ KE_KEY,  0x31, {KEY_MAIL} },\n\t{ KE_KEY,  0x36, {KEY_WWW} },\n\t{ KE_END,  0 }\n};\n\nstatic struct key_entry keymap_acer_aspire_1500[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x49, {KEY_CONFIG} },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_aspire_1600[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_PROG3} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x49, {KEY_CONFIG} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\n \nstatic struct key_entry keymap_acer_aspire_5020[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x05, {KEY_SWITCHVIDEOMODE} },  \n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x6a, {KEY_CONFIG} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_2410[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x6d, {KEY_POWER} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x6a, {KEY_CONFIG} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_110[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x20, {KEY_VOLUMEUP} },\n\t{ KE_KEY, 0x21, {KEY_VOLUMEDOWN} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_SW, 0x4a, {.sw = {SW_LID, 1}} },  \n\t{ KE_SW, 0x4b, {.sw = {SW_LID, 0}} },  \n\t{ KE_WIFI, 0x30 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_300[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x20, {KEY_VOLUMEUP} },\n\t{ KE_KEY, 0x21, {KEY_VOLUMEDOWN} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_380[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },  \n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_PROG3} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\n \nstatic struct key_entry keymap_acer_travelmate_220[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x11, {KEY_MAIL} },\n\t{ KE_KEY, 0x12, {KEY_WWW} },\n\t{ KE_KEY, 0x13, {KEY_PROG2} },\n\t{ KE_KEY, 0x31, {KEY_PROG1} },\n\t{ KE_END, FE_WIFI_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_230[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_END, FE_WIFI_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_240[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_END, FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_350[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_MAIL} },\n\t{ KE_KEY, 0x14, {KEY_PROG3} },\n\t{ KE_KEY, 0x15, {KEY_WWW} },\n\t{ KE_END, FE_MAIL_LED | FE_WIFI_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_360[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_MAIL} },\n\t{ KE_KEY, 0x14, {KEY_PROG3} },\n\t{ KE_KEY, 0x15, {KEY_WWW} },\n\t{ KE_KEY, 0x40, {KEY_WLAN} },\n\t{ KE_END, FE_WIFI_LED | FE_UNTESTED }  \n};\n\n \nstatic struct key_entry keymap_acer_travelmate_610[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_PROG3} },\n\t{ KE_KEY, 0x14, {KEY_MAIL} },\n\t{ KE_KEY, 0x15, {KEY_WWW} },\n\t{ KE_KEY, 0x40, {KEY_WLAN} },\n\t{ KE_END, FE_MAIL_LED | FE_WIFI_LED }\n};\n\nstatic struct key_entry keymap_acer_travelmate_630[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x08, {KEY_MUTE} },  \n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_PROG3} },\n\t{ KE_KEY, 0x20, {KEY_VOLUMEUP} },\n\t{ KE_KEY, 0x21, {KEY_VOLUMEDOWN} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_aopen_1559as[] __initdata = {\n\t{ KE_KEY,  0x01, {KEY_HELP} },\n\t{ KE_KEY,  0x06, {KEY_PROG3} },\n\t{ KE_KEY,  0x11, {KEY_PROG1} },\n\t{ KE_KEY,  0x12, {KEY_PROG2} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_KEY,  0x31, {KEY_MAIL} },\n\t{ KE_KEY,  0x36, {KEY_WWW} },\n\t{ KE_END,  0 },\n};\n\nstatic struct key_entry keymap_fs_amilo_d88x0[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_PROG3} },\n\t{ KE_END, FE_MAIL_LED | FE_WIFI_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_wistron_md2900[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_END, FE_MAIL_LED | FE_UNTESTED }\n};\n\nstatic struct key_entry keymap_wistron_md96500[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x05, {KEY_SWITCHVIDEOMODE} },  \n\t{ KE_KEY, 0x06, {KEY_DISPLAYTOGGLE} },  \n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x20, {KEY_VOLUMEUP} },\n\t{ KE_KEY, 0x21, {KEY_VOLUMEDOWN} },\n\t{ KE_KEY, 0x22, {KEY_REWIND} },\n\t{ KE_KEY, 0x23, {KEY_FORWARD} },\n\t{ KE_KEY, 0x24, {KEY_PLAYPAUSE} },\n\t{ KE_KEY, 0x25, {KEY_STOPCD} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, 0 }\n};\n\nstatic struct key_entry keymap_wistron_generic[] __initdata = {\n\t{ KE_KEY, 0x01, {KEY_HELP} },\n\t{ KE_KEY, 0x02, {KEY_CONFIG} },\n\t{ KE_KEY, 0x03, {KEY_POWER} },\n\t{ KE_KEY, 0x05, {KEY_SWITCHVIDEOMODE} },  \n\t{ KE_KEY, 0x06, {KEY_DISPLAYTOGGLE} },  \n\t{ KE_KEY, 0x08, {KEY_MUTE} },\n\t{ KE_KEY, 0x11, {KEY_PROG1} },\n\t{ KE_KEY, 0x12, {KEY_PROG2} },\n\t{ KE_KEY, 0x13, {KEY_PROG3} },\n\t{ KE_KEY, 0x14, {KEY_MAIL} },\n\t{ KE_KEY, 0x15, {KEY_WWW} },\n\t{ KE_KEY, 0x20, {KEY_VOLUMEUP} },\n\t{ KE_KEY, 0x21, {KEY_VOLUMEDOWN} },\n\t{ KE_KEY, 0x22, {KEY_REWIND} },\n\t{ KE_KEY, 0x23, {KEY_FORWARD} },\n\t{ KE_KEY, 0x24, {KEY_PLAYPAUSE} },\n\t{ KE_KEY, 0x25, {KEY_STOPCD} },\n\t{ KE_KEY, 0x31, {KEY_MAIL} },\n\t{ KE_KEY, 0x36, {KEY_WWW} },\n\t{ KE_KEY, 0x37, {KEY_DISPLAYTOGGLE} },  \n\t{ KE_KEY, 0x40, {KEY_WLAN} },\n\t{ KE_KEY, 0x49, {KEY_CONFIG} },\n\t{ KE_SW, 0x4a, {.sw = {SW_LID, 1}} },  \n\t{ KE_SW, 0x4b, {.sw = {SW_LID, 0}} },  \n\t{ KE_KEY, 0x6a, {KEY_CONFIG} },\n\t{ KE_KEY, 0x6d, {KEY_POWER} },\n\t{ KE_KEY, 0x71, {KEY_STOPCD} },\n\t{ KE_KEY, 0x72, {KEY_PLAYPAUSE} },\n\t{ KE_KEY, 0x74, {KEY_REWIND} },\n\t{ KE_KEY, 0x78, {KEY_FORWARD} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_BLUETOOTH, 0x44 },\n\t{ KE_END, 0 }\n};\n\nstatic struct key_entry keymap_aopen_1557[] __initdata = {\n\t{ KE_KEY,  0x01, {KEY_HELP} },\n\t{ KE_KEY,  0x11, {KEY_PROG1} },\n\t{ KE_KEY,  0x12, {KEY_PROG2} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_KEY,  0x22, {KEY_REWIND} },\n\t{ KE_KEY,  0x23, {KEY_FORWARD} },\n\t{ KE_KEY,  0x24, {KEY_PLAYPAUSE} },\n\t{ KE_KEY,  0x25, {KEY_STOPCD} },\n\t{ KE_KEY,  0x31, {KEY_MAIL} },\n\t{ KE_KEY,  0x36, {KEY_WWW} },\n\t{ KE_END,  0 }\n};\n\nstatic struct key_entry keymap_prestigio[] __initdata = {\n\t{ KE_KEY,  0x11, {KEY_PROG1} },\n\t{ KE_KEY,  0x12, {KEY_PROG2} },\n\t{ KE_WIFI, 0x30 },\n\t{ KE_KEY,  0x22, {KEY_REWIND} },\n\t{ KE_KEY,  0x23, {KEY_FORWARD} },\n\t{ KE_KEY,  0x24, {KEY_PLAYPAUSE} },\n\t{ KE_KEY,  0x25, {KEY_STOPCD} },\n\t{ KE_KEY,  0x31, {KEY_MAIL} },\n\t{ KE_KEY,  0x36, {KEY_WWW} },\n\t{ KE_END,  0 }\n};\n\n\n \nstatic const struct dmi_system_id dmi_ids[] __initconst = {\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Pro V2000\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_pro_v2000\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Pro Edition V3505\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_pro_v3505\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Pro Series V8210\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_pro_v8210\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO M        \"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_pro_v2000\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MAXDATA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Pro 7000\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_pro_v2000\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"N3510\"),\n\t\t},\n\t\t.driver_data = keymap_fujitsu_n3510\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 1500\"),\n\t\t},\n\t\t.driver_data = keymap_acer_aspire_1500\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 1600\"),\n\t\t},\n\t\t.driver_data = keymap_acer_aspire_1600\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 3020\"),\n\t\t},\n\t\t.driver_data = keymap_acer_aspire_5020\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5020\"),\n\t\t},\n\t\t.driver_data = keymap_acer_aspire_5020\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 2100\"),\n\t\t},\n\t\t.driver_data = keymap_acer_aspire_5020\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 2410\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_2410\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate C300\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_300\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate C100\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_300\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate C110\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_110\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 380\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_380\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 370\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_380  \n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 220\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_220\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 260\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_220\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 230\"),\n\t\t\t \n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_230\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 280\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_230\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 240\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_240\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 250\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_240\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 2420\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_240\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 350\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_350\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 360\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_360\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ACER\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 610\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_610\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 620\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_630\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 630\"),\n\t\t},\n\t\t.driver_data = keymap_acer_travelmate_630\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"E2U\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"E2U\"),\n\t\t},\n\t\t.driver_data = keymap_aopen_1559as\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDIONNB\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MD 9783\"),\n\t\t},\n\t\t.driver_data = keymap_wistron_ms2111\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDIONNB\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"WID2000\"),\n\t\t},\n\t\t.driver_data = keymap_wistron_md40100\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDIONNB\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"WIM 2000\"),\n\t\t},\n\t\t.driver_data = keymap_wistron_md2900\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Medion\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"WIM 2030\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_pro_v2000\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDIONPC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"WIM 2040\"),\n\t\t},\n\t\t.driver_data = keymap_wistron_md96500\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDIONPC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"WIM 2050\"),\n\t\t},\n\t\t.driver_data = keymap_wistron_md96500\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),  \n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Amilo D\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_d88x0\n\t},\n\t{\n\t\t \n\t\t.callback = dmi_matched,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO D\"),\n\t\t},\n\t\t.driver_data = keymap_fs_amilo_d88x0\n\t},\n\t{ NULL, }\n};\nMODULE_DEVICE_TABLE(dmi, dmi_ids);\n\n \nstatic int __init copy_keymap(void)\n{\n\tconst struct key_entry *key;\n\tstruct key_entry *new_keymap;\n\tunsigned int length = 1;\n\n\tfor (key = keymap; key->type != KE_END; key++)\n\t\tlength++;\n\n\tnew_keymap = kmemdup(keymap, length * sizeof(struct key_entry),\n\t\t\t     GFP_KERNEL);\n\tif (!new_keymap)\n\t\treturn -ENOMEM;\n\n\tkeymap = new_keymap;\n\n\treturn 0;\n}\n\nstatic int __init select_keymap(void)\n{\n\tdmi_check_system(dmi_ids);\n\tif (keymap_name != NULL) {\n\t\tif (strcmp (keymap_name, \"1557/MS2141\") == 0)\n\t\t\tkeymap = keymap_wistron_ms2141;\n\t\telse if (strcmp (keymap_name, \"aopen1557\") == 0)\n\t\t\tkeymap = keymap_aopen_1557;\n\t\telse if (strcmp (keymap_name, \"prestigio\") == 0)\n\t\t\tkeymap = keymap_prestigio;\n\t\telse if (strcmp (keymap_name, \"generic\") == 0)\n\t\t\tkeymap = keymap_wistron_generic;\n\t\telse {\n\t\t\tprintk(KERN_ERR \"wistron_btns: Keymap unknown\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (keymap == NULL) {\n\t\tif (!force) {\n\t\t\tprintk(KERN_ERR \"wistron_btns: System unknown\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tkeymap = keymap_empty;\n\t}\n\n\treturn copy_keymap();\n}\n\n  \n\nstatic struct input_dev *wistron_idev;\nstatic unsigned long jiffies_last_press;\nstatic bool wifi_enabled;\nstatic bool bluetooth_enabled;\n\n  \nstatic void wistron_mail_led_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness value)\n{\n\tbios_set_state(MAIL_LED, (value != LED_OFF) ? 1 : 0);\n}\n\n \nstatic void wistron_wifi_led_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness value)\n{\n\tbios_set_state(WIFI, (value != LED_OFF) ? 1 : 0);\n}\n\nstatic struct led_classdev wistron_mail_led = {\n\t.name\t\t\t= \"wistron:green:mail\",\n\t.brightness_set\t\t= wistron_mail_led_set,\n};\n\nstatic struct led_classdev wistron_wifi_led = {\n\t.name\t\t\t= \"wistron:red:wifi\",\n\t.brightness_set\t\t= wistron_wifi_led_set,\n};\n\nstatic void wistron_led_init(struct device *parent)\n{\n\tif (leds_present & FE_WIFI_LED) {\n\t\tu16 wifi = bios_get_default_setting(WIFI);\n\t\tif (wifi & 1) {\n\t\t\twistron_wifi_led.brightness = (wifi & 2) ? LED_FULL : LED_OFF;\n\t\t\tif (led_classdev_register(parent, &wistron_wifi_led))\n\t\t\t\tleds_present &= ~FE_WIFI_LED;\n\t\t\telse\n\t\t\t\tbios_set_state(WIFI, wistron_wifi_led.brightness);\n\n\t\t} else\n\t\t\tleds_present &= ~FE_WIFI_LED;\n\t}\n\n\tif (leds_present & FE_MAIL_LED) {\n\t\t \n\t\twistron_mail_led.brightness = LED_OFF;\n\t\tif (led_classdev_register(parent, &wistron_mail_led))\n\t\t\tleds_present &= ~FE_MAIL_LED;\n\t\telse\n\t\t\tbios_set_state(MAIL_LED, wistron_mail_led.brightness);\n\t}\n}\n\nstatic void wistron_led_remove(void)\n{\n\tif (leds_present & FE_MAIL_LED)\n\t\tled_classdev_unregister(&wistron_mail_led);\n\n\tif (leds_present & FE_WIFI_LED)\n\t\tled_classdev_unregister(&wistron_wifi_led);\n}\n\nstatic inline void wistron_led_suspend(void)\n{\n\tif (leds_present & FE_MAIL_LED)\n\t\tled_classdev_suspend(&wistron_mail_led);\n\n\tif (leds_present & FE_WIFI_LED)\n\t\tled_classdev_suspend(&wistron_wifi_led);\n}\n\nstatic inline void wistron_led_resume(void)\n{\n\tif (leds_present & FE_MAIL_LED)\n\t\tled_classdev_resume(&wistron_mail_led);\n\n\tif (leds_present & FE_WIFI_LED)\n\t\tled_classdev_resume(&wistron_wifi_led);\n}\n\nstatic void handle_key(u8 code)\n{\n\tconst struct key_entry *key =\n\t\tsparse_keymap_entry_from_scancode(wistron_idev, code);\n\n\tif (key) {\n\t\tswitch (key->type) {\n\t\tcase KE_WIFI:\n\t\t\tif (have_wifi) {\n\t\t\t\twifi_enabled = !wifi_enabled;\n\t\t\t\tbios_set_state(WIFI, wifi_enabled);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KE_BLUETOOTH:\n\t\t\tif (have_bluetooth) {\n\t\t\t\tbluetooth_enabled = !bluetooth_enabled;\n\t\t\t\tbios_set_state(BLUETOOTH, bluetooth_enabled);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsparse_keymap_report_entry(wistron_idev, key, 1, true);\n\t\t\tbreak;\n\t\t}\n\t\tjiffies_last_press = jiffies;\n\t} else {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"wistron_btns: Unknown key code %02X\\n\", code);\n\t}\n}\n\nstatic void poll_bios(bool discard)\n{\n\tu8 qlen;\n\tu16 val;\n\n\tfor (;;) {\n\t\tqlen = CMOS_READ(cmos_address);\n\t\tif (qlen == 0)\n\t\t\tbreak;\n\t\tval = bios_pop_queue();\n\t\tif (val != 0 && !discard)\n\t\t\thandle_key((u8)val);\n\t}\n}\n\nstatic int wistron_flush(struct input_dev *dev)\n{\n\t \n\tpoll_bios(true);\n\n\treturn 0;\n}\n\nstatic void wistron_poll(struct input_dev *dev)\n{\n\tpoll_bios(false);\n\n\t \n\tif (time_before(jiffies, jiffies_last_press + 2 * HZ))\n\t\tinput_set_poll_interval(dev, POLL_INTERVAL_BURST);\n\telse\n\t\tinput_set_poll_interval(dev, POLL_INTERVAL_DEFAULT);\n}\n\nstatic int wistron_setup_keymap(struct input_dev *dev,\n\t\t\t\t\t  struct key_entry *entry)\n{\n\tswitch (entry->type) {\n\n\t \n\tcase KE_WIFI:\n\t\tif (!have_wifi) {\n\t\t\tentry->type = KE_KEY;\n\t\t\tentry->keycode = KEY_WLAN;\n\t\t}\n\t\tbreak;\n\n\tcase KE_BLUETOOTH:\n\t\tif (!have_bluetooth) {\n\t\t\tentry->type = KE_KEY;\n\t\t\tentry->keycode = KEY_BLUETOOTH;\n\t\t}\n\t\tbreak;\n\n\tcase KE_END:\n\t\tif (entry->code & FE_UNTESTED)\n\t\t\tprintk(KERN_WARNING \"Untested laptop multimedia keys, \"\n\t\t\t\t\"please report success or failure to \"\n\t\t\t\t\"eric.piel@tremplin-utc.net\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_input_dev(void)\n{\n\tint error;\n\n\twistron_idev = input_allocate_device();\n\tif (!wistron_idev)\n\t\treturn -ENOMEM;\n\n\twistron_idev->name = \"Wistron laptop buttons\";\n\twistron_idev->phys = \"wistron/input0\";\n\twistron_idev->id.bustype = BUS_HOST;\n\twistron_idev->dev.parent = &wistron_device->dev;\n\n\twistron_idev->open = wistron_flush;\n\n\terror = sparse_keymap_setup(wistron_idev, keymap, wistron_setup_keymap);\n\tif (error)\n\t\tgoto err_free_dev;\n\n\terror = input_setup_polling(wistron_idev, wistron_poll);\n\tif (error)\n\t\tgoto err_free_dev;\n\n\tinput_set_poll_interval(wistron_idev, POLL_INTERVAL_DEFAULT);\n\n\terror = input_register_device(wistron_idev);\n\tif (error)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(wistron_idev);\n\treturn error;\n}\n\n \n\nstatic int wistron_probe(struct platform_device *dev)\n{\n\tint err;\n\n\tbios_attach();\n\tcmos_address = bios_get_cmos_address();\n\n\tif (have_wifi) {\n\t\tu16 wifi = bios_get_default_setting(WIFI);\n\t\tif (wifi & 1)\n\t\t\twifi_enabled = wifi & 2;\n\t\telse\n\t\t\thave_wifi = 0;\n\n\t\tif (have_wifi)\n\t\t\tbios_set_state(WIFI, wifi_enabled);\n\t}\n\n\tif (have_bluetooth) {\n\t\tu16 bt = bios_get_default_setting(BLUETOOTH);\n\t\tif (bt & 1)\n\t\t\tbluetooth_enabled = bt & 2;\n\t\telse\n\t\t\thave_bluetooth = false;\n\n\t\tif (have_bluetooth)\n\t\t\tbios_set_state(BLUETOOTH, bluetooth_enabled);\n\t}\n\n\twistron_led_init(&dev->dev);\n\n\terr = setup_input_dev();\n\tif (err) {\n\t\tbios_detach();\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int wistron_remove(struct platform_device *dev)\n{\n\twistron_led_remove();\n\tinput_unregister_device(wistron_idev);\n\tbios_detach();\n\n\treturn 0;\n}\n\nstatic int wistron_suspend(struct device *dev)\n{\n\tif (have_wifi)\n\t\tbios_set_state(WIFI, 0);\n\n\tif (have_bluetooth)\n\t\tbios_set_state(BLUETOOTH, 0);\n\n\twistron_led_suspend();\n\n\treturn 0;\n}\n\nstatic int wistron_resume(struct device *dev)\n{\n\tif (have_wifi)\n\t\tbios_set_state(WIFI, wifi_enabled);\n\n\tif (have_bluetooth)\n\t\tbios_set_state(BLUETOOTH, bluetooth_enabled);\n\n\twistron_led_resume();\n\n\tpoll_bios(true);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wistron_pm_ops = {\n\t.suspend\t= wistron_suspend,\n\t.resume\t\t= wistron_resume,\n\t.poweroff\t= wistron_suspend,\n\t.restore\t= wistron_resume,\n};\n\nstatic struct platform_driver wistron_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"wistron-bios\",\n\t\t.pm\t= pm_sleep_ptr(&wistron_pm_ops),\n\t},\n\t.probe\t\t= wistron_probe,\n\t.remove\t\t= wistron_remove,\n};\n\nstatic int __init wb_module_init(void)\n{\n\tint err;\n\n\terr = select_keymap();\n\tif (err)\n\t\treturn err;\n\n\terr = map_bios();\n\tif (err)\n\t\tgoto err_free_keymap;\n\n\terr = platform_driver_register(&wistron_driver);\n\tif (err)\n\t\tgoto err_unmap_bios;\n\n\twistron_device = platform_device_alloc(\"wistron-bios\", -1);\n\tif (!wistron_device) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unregister_driver;\n\t}\n\n\terr = platform_device_add(wistron_device);\n\tif (err)\n\t\tgoto err_free_device;\n\n\treturn 0;\n\n err_free_device:\n\tplatform_device_put(wistron_device);\n err_unregister_driver:\n\tplatform_driver_unregister(&wistron_driver);\n err_unmap_bios:\n\tunmap_bios();\n err_free_keymap:\n\tkfree(keymap);\n\n\treturn err;\n}\n\nstatic void __exit wb_module_exit(void)\n{\n\tplatform_device_unregister(wistron_device);\n\tplatform_driver_unregister(&wistron_driver);\n\tunmap_bios();\n\tkfree(keymap);\n}\n\nmodule_init(wb_module_init);\nmodule_exit(wb_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}