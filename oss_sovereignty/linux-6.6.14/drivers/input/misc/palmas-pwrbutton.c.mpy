{
  "module_name": "palmas-pwrbutton.c",
  "hash_id": "b3a2e75fc131c56af871c650279f8ffdbf3973a3c05d7aab3eb9fea719b78dd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/palmas-pwrbutton.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/palmas.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define PALMAS_LPK_TIME_MASK\t\t0x0c\n#define PALMAS_PWRON_DEBOUNCE_MASK\t0x03\n#define PALMAS_PWR_KEY_Q_TIME_MS\t20\n\n \nstruct palmas_pwron {\n\tstruct palmas *palmas;\n\tstruct input_dev *input_dev;\n\tstruct delayed_work input_work;\n\tint irq;\n};\n\n \nstruct palmas_pwron_config {\n\tu8 long_press_time_val;\n\tu8 pwron_debounce_val;\n};\n\n \nstatic void palmas_power_button_work(struct work_struct *work)\n{\n\tstruct palmas_pwron *pwron = container_of(work,\n\t\t\t\t\t\t  struct palmas_pwron,\n\t\t\t\t\t\t  input_work.work);\n\tstruct input_dev *input_dev = pwron->input_dev;\n\tunsigned int reg;\n\tint error;\n\n\terror = palmas_read(pwron->palmas, PALMAS_INTERRUPT_BASE,\n\t\t\t    PALMAS_INT1_LINE_STATE, &reg);\n\tif (error) {\n\t\tdev_err(input_dev->dev.parent,\n\t\t\t\"Cannot read palmas PWRON status: %d\\n\", error);\n\t} else if (reg & BIT(1)) {\n\t\t \n\t\tinput_report_key(input_dev, KEY_POWER, 0);\n\t\tinput_sync(input_dev);\n\t} else {\n\t\t \n\t\tschedule_delayed_work(&pwron->input_work,\n\t\t\t\tmsecs_to_jiffies(PALMAS_PWR_KEY_Q_TIME_MS));\n\t}\n}\n\n \nstatic irqreturn_t pwron_irq(int irq, void *palmas_pwron)\n{\n\tstruct palmas_pwron *pwron = palmas_pwron;\n\tstruct input_dev *input_dev = pwron->input_dev;\n\n\tinput_report_key(input_dev, KEY_POWER, 1);\n\tpm_wakeup_event(input_dev->dev.parent, 0);\n\tinput_sync(input_dev);\n\n\tmod_delayed_work(system_wq, &pwron->input_work,\n\t\t\t msecs_to_jiffies(PALMAS_PWR_KEY_Q_TIME_MS));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void palmas_pwron_params_ofinit(struct device *dev,\n\t\t\t\t       struct palmas_pwron_config *config)\n{\n\tstruct device_node *np;\n\tu32 val;\n\tint i, error;\n\tstatic const u8 lpk_times[] = { 6, 8, 10, 12 };\n\tstatic const int pwr_on_deb_ms[] = { 15, 100, 500, 1000 };\n\n\tmemset(config, 0, sizeof(*config));\n\n\t \n\tconfig->long_press_time_val = ARRAY_SIZE(lpk_times) - 1;\n\n\tnp = dev->of_node;\n\tif (!np)\n\t\treturn;\n\n\terror = of_property_read_u32(np, \"ti,palmas-long-press-seconds\", &val);\n\tif (!error) {\n\t\tfor (i = 0; i < ARRAY_SIZE(lpk_times); i++) {\n\t\t\tif (val <= lpk_times[i]) {\n\t\t\t\tconfig->long_press_time_val = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\terror = of_property_read_u32(np,\n\t\t\t\t     \"ti,palmas-pwron-debounce-milli-seconds\",\n\t\t\t\t     &val);\n\tif (!error) {\n\t\tfor (i = 0; i < ARRAY_SIZE(pwr_on_deb_ms); i++) {\n\t\t\tif (val <= pwr_on_deb_ms[i]) {\n\t\t\t\tconfig->pwron_debounce_val = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_info(dev, \"h/w controlled shutdown duration=%d seconds\\n\",\n\t\t lpk_times[config->long_press_time_val]);\n}\n\n \nstatic int palmas_pwron_probe(struct platform_device *pdev)\n{\n\tstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct input_dev *input_dev;\n\tstruct palmas_pwron *pwron;\n\tstruct palmas_pwron_config config;\n\tint val;\n\tint error;\n\n\tpalmas_pwron_params_ofinit(dev, &config);\n\n\tpwron = kzalloc(sizeof(*pwron), GFP_KERNEL);\n\tif (!pwron)\n\t\treturn -ENOMEM;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev) {\n\t\tdev_err(dev, \"Can't allocate power button\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tinput_dev->name = \"palmas_pwron\";\n\tinput_dev->phys = \"palmas_pwron/input0\";\n\tinput_dev->dev.parent = dev;\n\n\tinput_set_capability(input_dev, EV_KEY, KEY_POWER);\n\n\t \n\tval = FIELD_PREP(PALMAS_LPK_TIME_MASK, config.long_press_time_val) |\n\t      FIELD_PREP(PALMAS_PWRON_DEBOUNCE_MASK, config.pwron_debounce_val);\n\terror = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,\n\t\t\t\t   PALMAS_LONG_PRESS_KEY,\n\t\t\t\t   PALMAS_LPK_TIME_MASK |\n\t\t\t\t\tPALMAS_PWRON_DEBOUNCE_MASK,\n\t\t\t\t   val);\n\tif (error) {\n\t\tdev_err(dev, \"LONG_PRESS_KEY_UPDATE failed: %d\\n\", error);\n\t\tgoto err_free_input;\n\t}\n\n\tpwron->palmas = palmas;\n\tpwron->input_dev = input_dev;\n\n\tINIT_DELAYED_WORK(&pwron->input_work, palmas_power_button_work);\n\n\tpwron->irq = platform_get_irq(pdev, 0);\n\tif (pwron->irq < 0) {\n\t\terror = pwron->irq;\n\t\tgoto err_free_input;\n\t}\n\n\terror = request_threaded_irq(pwron->irq, NULL, pwron_irq,\n\t\t\t\t     IRQF_TRIGGER_HIGH |\n\t\t\t\t\tIRQF_TRIGGER_LOW |\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t     dev_name(dev), pwron);\n\tif (error) {\n\t\tdev_err(dev, \"Can't get IRQ for pwron: %d\\n\", error);\n\t\tgoto err_free_input;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"Can't register power button: %d\\n\", error);\n\t\tgoto err_free_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, pwron);\n\tdevice_init_wakeup(dev, true);\n\n\treturn 0;\n\nerr_free_irq:\n\tcancel_delayed_work_sync(&pwron->input_work);\n\tfree_irq(pwron->irq, pwron);\nerr_free_input:\n\tinput_free_device(input_dev);\nerr_free_mem:\n\tkfree(pwron);\n\treturn error;\n}\n\n \nstatic int palmas_pwron_remove(struct platform_device *pdev)\n{\n\tstruct palmas_pwron *pwron = platform_get_drvdata(pdev);\n\n\tfree_irq(pwron->irq, pwron);\n\tcancel_delayed_work_sync(&pwron->input_work);\n\n\tinput_unregister_device(pwron->input_dev);\n\tkfree(pwron);\n\n\treturn 0;\n}\n\n \nstatic int palmas_pwron_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct palmas_pwron *pwron = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&pwron->input_work);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(pwron->irq);\n\n\treturn 0;\n}\n\n \nstatic int palmas_pwron_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct palmas_pwron *pwron = platform_get_drvdata(pdev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(pwron->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(palmas_pwron_pm,\n\t\t\t\tpalmas_pwron_suspend, palmas_pwron_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_palmas_pwr_match[] = {\n\t{ .compatible = \"ti,palmas-pwrbutton\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, of_palmas_pwr_match);\n#endif\n\nstatic struct platform_driver palmas_pwron_driver = {\n\t.probe\t= palmas_pwron_probe,\n\t.remove\t= palmas_pwron_remove,\n\t.driver\t= {\n\t\t.name\t= \"palmas_pwrbutton\",\n\t\t.of_match_table = of_match_ptr(of_palmas_pwr_match),\n\t\t.pm\t= pm_sleep_ptr(&palmas_pwron_pm),\n\t},\n};\nmodule_platform_driver(palmas_pwron_driver);\n\nMODULE_ALIAS(\"platform:palmas-pwrbutton\");\nMODULE_DESCRIPTION(\"Palmas Power Button\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}