{
  "module_name": "pcspkr.c",
  "hash_id": "1159062bcad0567ae6a6a52f9dbad72a23c14da8740346875b15d54a02eefa93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/pcspkr.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i8253.h>\n#include <linux/input.h>\n#include <linux/platform_device.h>\n#include <linux/timex.h>\n#include <linux/io.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"PC Speaker beeper driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pcspkr\");\n\nstatic int pcspkr_event(struct input_dev *dev, unsigned int type,\n\t\t\tunsigned int code, int value)\n{\n\tunsigned int count = 0;\n\tunsigned long flags;\n\n\tif (type != EV_SND)\n\t\treturn -EINVAL;\n\n\tswitch (code) {\n\tcase SND_BELL:\n\t\tif (value)\n\t\t\tvalue = 1000;\n\t\tbreak;\n\tcase SND_TONE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (value > 20 && value < 32767)\n\t\tcount = PIT_TICK_RATE / value;\n\n\traw_spin_lock_irqsave(&i8253_lock, flags);\n\n\tif (count) {\n\t\t \n\t\toutb_p(0xB6, 0x43);\n\t\t \n\t\toutb_p(count & 0xff, 0x42);\n\t\toutb((count >> 8) & 0xff, 0x42);\n\t\t \n\t\toutb_p(inb_p(0x61) | 3, 0x61);\n\t} else {\n\t\t \n\t\toutb(inb_p(0x61) & 0xFC, 0x61);\n\t}\n\n\traw_spin_unlock_irqrestore(&i8253_lock, flags);\n\n\treturn 0;\n}\n\nstatic int pcspkr_probe(struct platform_device *dev)\n{\n\tstruct input_dev *pcspkr_dev;\n\tint err;\n\n\tpcspkr_dev = input_allocate_device();\n\tif (!pcspkr_dev)\n\t\treturn -ENOMEM;\n\n\tpcspkr_dev->name = \"PC Speaker\";\n\tpcspkr_dev->phys = \"isa0061/input0\";\n\tpcspkr_dev->id.bustype = BUS_ISA;\n\tpcspkr_dev->id.vendor = 0x001f;\n\tpcspkr_dev->id.product = 0x0001;\n\tpcspkr_dev->id.version = 0x0100;\n\tpcspkr_dev->dev.parent = &dev->dev;\n\n\tpcspkr_dev->evbit[0] = BIT_MASK(EV_SND);\n\tpcspkr_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\tpcspkr_dev->event = pcspkr_event;\n\n\terr = input_register_device(pcspkr_dev);\n\tif (err) {\n\t\tinput_free_device(pcspkr_dev);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(dev, pcspkr_dev);\n\n\treturn 0;\n}\n\nstatic int pcspkr_remove(struct platform_device *dev)\n{\n\tstruct input_dev *pcspkr_dev = platform_get_drvdata(dev);\n\n\tinput_unregister_device(pcspkr_dev);\n\t \n\tpcspkr_event(NULL, EV_SND, SND_BELL, 0);\n\n\treturn 0;\n}\n\nstatic int pcspkr_suspend(struct device *dev)\n{\n\tpcspkr_event(NULL, EV_SND, SND_BELL, 0);\n\n\treturn 0;\n}\n\nstatic void pcspkr_shutdown(struct platform_device *dev)\n{\n\t \n\tpcspkr_event(NULL, EV_SND, SND_BELL, 0);\n}\n\nstatic const struct dev_pm_ops pcspkr_pm_ops = {\n\t.suspend = pcspkr_suspend,\n};\n\nstatic struct platform_driver pcspkr_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pcspkr\",\n\t\t.pm\t= &pcspkr_pm_ops,\n\t},\n\t.probe\t\t= pcspkr_probe,\n\t.remove\t\t= pcspkr_remove,\n\t.shutdown\t= pcspkr_shutdown,\n};\nmodule_platform_driver(pcspkr_platform_driver);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}