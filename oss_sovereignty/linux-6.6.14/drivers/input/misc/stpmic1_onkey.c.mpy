{
  "module_name": "stpmic1_onkey.c",
  "hash_id": "09b68ec17d71172f0ac35f6a9e67e488c1606d321bbf345c2dd86921b8af7851",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/stpmic1_onkey.c",
  "human_readable_source": "\n\n\n\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/stpmic1.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n \nstruct stpmic1_onkey {\n\tstruct input_dev *input_dev;\n\tint irq_falling;\n\tint irq_rising;\n};\n\nstatic irqreturn_t onkey_falling_irq(int irq, void *ponkey)\n{\n\tstruct stpmic1_onkey *onkey = ponkey;\n\tstruct input_dev *input_dev = onkey->input_dev;\n\n\tinput_report_key(input_dev, KEY_POWER, 1);\n\tpm_wakeup_event(input_dev->dev.parent, 0);\n\tinput_sync(input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t onkey_rising_irq(int irq, void *ponkey)\n{\n\tstruct stpmic1_onkey *onkey = ponkey;\n\tstruct input_dev *input_dev = onkey->input_dev;\n\n\tinput_report_key(input_dev, KEY_POWER, 0);\n\tpm_wakeup_event(input_dev->dev.parent, 0);\n\tinput_sync(input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stpmic1_onkey_probe(struct platform_device *pdev)\n{\n\tstruct stpmic1 *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct input_dev *input_dev;\n\tstruct stpmic1_onkey *onkey;\n\tunsigned int val, reg = 0;\n\tint error;\n\n\tonkey = devm_kzalloc(dev, sizeof(*onkey), GFP_KERNEL);\n\tif (!onkey)\n\t\treturn -ENOMEM;\n\n\tonkey->irq_falling = platform_get_irq_byname(pdev, \"onkey-falling\");\n\tif (onkey->irq_falling < 0)\n\t\treturn onkey->irq_falling;\n\n\tonkey->irq_rising = platform_get_irq_byname(pdev, \"onkey-rising\");\n\tif (onkey->irq_rising < 0)\n\t\treturn onkey->irq_rising;\n\n\tif (!device_property_read_u32(dev, \"power-off-time-sec\", &val)) {\n\t\tif (val > 0 && val <= 16) {\n\t\t\tdev_dbg(dev, \"power-off-time=%d seconds\\n\", val);\n\t\t\treg |= PONKEY_PWR_OFF;\n\t\t\treg |= ((16 - val) & PONKEY_TURNOFF_TIMER_MASK);\n\t\t} else {\n\t\t\tdev_err(dev, \"power-off-time-sec out of range\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (device_property_present(dev, \"st,onkey-clear-cc-flag\"))\n\t\treg |= PONKEY_CC_FLAG_CLEAR;\n\n\terror = regmap_update_bits(pmic->regmap, PKEY_TURNOFF_CR,\n\t\t\t\t   PONKEY_TURNOFF_MASK, reg);\n\tif (error) {\n\t\tdev_err(dev, \"PKEY_TURNOFF_CR write failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (device_property_present(dev, \"st,onkey-pu-inactive\")) {\n\t\terror = regmap_update_bits(pmic->regmap, PADS_PULL_CR,\n\t\t\t\t\t   PONKEY_PU_INACTIVE,\n\t\t\t\t\t   PONKEY_PU_INACTIVE);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"ONKEY Pads configuration failed: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev) {\n\t\tdev_err(dev, \"Can't allocate Pwr Onkey Input Device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name = \"pmic_onkey\";\n\tinput_dev->phys = \"pmic_onkey/input0\";\n\n\tinput_set_capability(input_dev, EV_KEY, KEY_POWER);\n\n\tonkey->input_dev = input_dev;\n\n\t \n\terror = devm_request_threaded_irq(dev, onkey->irq_falling, NULL,\n\t\t\t\t\t  onkey_falling_irq, IRQF_ONESHOT,\n\t\t\t\t\t  dev_name(dev), onkey);\n\tif (error) {\n\t\tdev_err(dev, \"Can't get IRQ Onkey Falling: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, onkey->irq_rising, NULL,\n\t\t\t\t\t  onkey_rising_irq, IRQF_ONESHOT,\n\t\t\t\t\t  dev_name(dev), onkey);\n\tif (error) {\n\t\tdev_err(dev, \"Can't get IRQ Onkey Rising: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"Can't register power button: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, onkey);\n\tdevice_init_wakeup(dev, true);\n\n\treturn 0;\n}\n\nstatic int stpmic1_onkey_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct stpmic1_onkey *onkey = platform_get_drvdata(pdev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tenable_irq_wake(onkey->irq_falling);\n\t\tenable_irq_wake(onkey->irq_rising);\n\t}\n\treturn 0;\n}\n\nstatic int stpmic1_onkey_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct stpmic1_onkey *onkey = platform_get_drvdata(pdev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tdisable_irq_wake(onkey->irq_falling);\n\t\tdisable_irq_wake(onkey->irq_rising);\n\t}\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stpmic1_onkey_pm,\n\t\t\t\tstpmic1_onkey_suspend,\n\t\t\t\tstpmic1_onkey_resume);\n\nstatic const struct of_device_id of_stpmic1_onkey_match[] = {\n\t{ .compatible = \"st,stpmic1-onkey\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, of_stpmic1_onkey_match);\n\nstatic struct platform_driver stpmic1_onkey_driver = {\n\t.probe\t= stpmic1_onkey_probe,\n\t.driver\t= {\n\t\t.name\t= \"stpmic1_onkey\",\n\t\t.of_match_table = of_match_ptr(of_stpmic1_onkey_match),\n\t\t.pm\t= pm_sleep_ptr(&stpmic1_onkey_pm),\n\t},\n};\nmodule_platform_driver(stpmic1_onkey_driver);\n\nMODULE_DESCRIPTION(\"Onkey driver for STPMIC1\");\nMODULE_AUTHOR(\"Pascal Paillet <p.paillet@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}