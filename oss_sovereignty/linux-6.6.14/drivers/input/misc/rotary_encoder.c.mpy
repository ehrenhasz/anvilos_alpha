{
  "module_name": "rotary_encoder.c",
  "hash_id": "23b27df70661f43e97c63c967ed649232892443d45bf676323a743d33511a7e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/rotary_encoder.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n\n#define DRV_NAME \"rotary-encoder\"\n\nenum rotary_encoder_encoding {\n\tROTENC_GRAY,\n\tROTENC_BINARY,\n};\n\nstruct rotary_encoder {\n\tstruct input_dev *input;\n\n\tstruct mutex access_mutex;\n\n\tu32 steps;\n\tu32 axis;\n\tbool relative_axis;\n\tbool rollover;\n\tenum rotary_encoder_encoding encoding;\n\n\tunsigned int pos;\n\n\tstruct gpio_descs *gpios;\n\n\tunsigned int *irq;\n\n\tbool armed;\n\tsigned char dir;\t \n\n\tunsigned int last_stable;\n};\n\nstatic unsigned int rotary_encoder_get_state(struct rotary_encoder *encoder)\n{\n\tint i;\n\tunsigned int ret = 0;\n\n\tfor (i = 0; i < encoder->gpios->ndescs; ++i) {\n\t\tint val = gpiod_get_value_cansleep(encoder->gpios->desc[i]);\n\n\t\t \n\t\tif (encoder->encoding == ROTENC_GRAY && ret & 1)\n\t\t\tval = !val;\n\n\t\tret = ret << 1 | val;\n\t}\n\n\treturn ret & 3;\n}\n\nstatic void rotary_encoder_report_event(struct rotary_encoder *encoder)\n{\n\tif (encoder->relative_axis) {\n\t\tinput_report_rel(encoder->input,\n\t\t\t\t encoder->axis, encoder->dir);\n\t} else {\n\t\tunsigned int pos = encoder->pos;\n\n\t\tif (encoder->dir < 0) {\n\t\t\t \n\t\t\tif (encoder->rollover)\n\t\t\t\tpos += encoder->steps;\n\t\t\tif (pos)\n\t\t\t\tpos--;\n\t\t} else {\n\t\t\t \n\t\t\tif (encoder->rollover || pos < encoder->steps)\n\t\t\t\tpos++;\n\t\t}\n\n\t\tif (encoder->rollover)\n\t\t\tpos %= encoder->steps;\n\n\t\tencoder->pos = pos;\n\t\tinput_report_abs(encoder->input, encoder->axis, encoder->pos);\n\t}\n\n\tinput_sync(encoder->input);\n}\n\nstatic irqreturn_t rotary_encoder_irq(int irq, void *dev_id)\n{\n\tstruct rotary_encoder *encoder = dev_id;\n\tunsigned int state;\n\n\tmutex_lock(&encoder->access_mutex);\n\n\tstate = rotary_encoder_get_state(encoder);\n\n\tswitch (state) {\n\tcase 0x0:\n\t\tif (encoder->armed) {\n\t\t\trotary_encoder_report_event(encoder);\n\t\t\tencoder->armed = false;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1:\n\tcase 0x3:\n\t\tif (encoder->armed)\n\t\t\tencoder->dir = 2 - state;\n\t\tbreak;\n\n\tcase 0x2:\n\t\tencoder->armed = true;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&encoder->access_mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rotary_encoder_half_period_irq(int irq, void *dev_id)\n{\n\tstruct rotary_encoder *encoder = dev_id;\n\tunsigned int state;\n\n\tmutex_lock(&encoder->access_mutex);\n\n\tstate = rotary_encoder_get_state(encoder);\n\n\tif (state & 1) {\n\t\tencoder->dir = ((encoder->last_stable - state + 1) % 4) - 1;\n\t} else {\n\t\tif (state != encoder->last_stable) {\n\t\t\trotary_encoder_report_event(encoder);\n\t\t\tencoder->last_stable = state;\n\t\t}\n\t}\n\n\tmutex_unlock(&encoder->access_mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rotary_encoder_quarter_period_irq(int irq, void *dev_id)\n{\n\tstruct rotary_encoder *encoder = dev_id;\n\tunsigned int state;\n\n\tmutex_lock(&encoder->access_mutex);\n\n\tstate = rotary_encoder_get_state(encoder);\n\n\tif ((encoder->last_stable + 1) % 4 == state)\n\t\tencoder->dir = 1;\n\telse if (encoder->last_stable == (state + 1) % 4)\n\t\tencoder->dir = -1;\n\telse\n\t\tgoto out;\n\n\trotary_encoder_report_event(encoder);\n\nout:\n\tencoder->last_stable = state;\n\tmutex_unlock(&encoder->access_mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rotary_encoder_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rotary_encoder *encoder;\n\tstruct input_dev *input;\n\tirq_handler_t handler;\n\tu32 steps_per_period;\n\tunsigned int i;\n\tint err;\n\n\tencoder = devm_kzalloc(dev, sizeof(struct rotary_encoder), GFP_KERNEL);\n\tif (!encoder)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&encoder->access_mutex);\n\n\tdevice_property_read_u32(dev, \"rotary-encoder,steps\", &encoder->steps);\n\n\terr = device_property_read_u32(dev, \"rotary-encoder,steps-per-period\",\n\t\t\t\t       &steps_per_period);\n\tif (err) {\n\t\t \n\t\tsteps_per_period = device_property_read_bool(dev,\n\t\t\t\t\t\"rotary-encoder,half-period\") ? 2 : 1;\n\t}\n\n\tencoder->rollover =\n\t\tdevice_property_read_bool(dev, \"rotary-encoder,rollover\");\n\n\tif (!device_property_present(dev, \"rotary-encoder,encoding\") ||\n\t    !device_property_match_string(dev, \"rotary-encoder,encoding\",\n\t\t\t\t\t  \"gray\")) {\n\t\tdev_info(dev, \"gray\");\n\t\tencoder->encoding = ROTENC_GRAY;\n\t} else if (!device_property_match_string(dev, \"rotary-encoder,encoding\",\n\t\t\t\t\t\t \"binary\")) {\n\t\tdev_info(dev, \"binary\");\n\t\tencoder->encoding = ROTENC_BINARY;\n\t} else {\n\t\tdev_err(dev, \"unknown encoding setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_property_read_u32(dev, \"linux,axis\", &encoder->axis);\n\tencoder->relative_axis =\n\t\tdevice_property_read_bool(dev, \"rotary-encoder,relative-axis\");\n\n\tencoder->gpios = devm_gpiod_get_array(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(encoder->gpios))\n\t\treturn dev_err_probe(dev, PTR_ERR(encoder->gpios), \"unable to get gpios\\n\");\n\tif (encoder->gpios->ndescs < 2) {\n\t\tdev_err(dev, \"not enough gpios found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tencoder->input = input;\n\n\tinput->name = pdev->name;\n\tinput->id.bustype = BUS_HOST;\n\n\tif (encoder->relative_axis)\n\t\tinput_set_capability(input, EV_REL, encoder->axis);\n\telse\n\t\tinput_set_abs_params(input,\n\t\t\t\t     encoder->axis, 0, encoder->steps, 0, 1);\n\n\tswitch (steps_per_period >> (encoder->gpios->ndescs - 2)) {\n\tcase 4:\n\t\thandler = &rotary_encoder_quarter_period_irq;\n\t\tencoder->last_stable = rotary_encoder_get_state(encoder);\n\t\tbreak;\n\tcase 2:\n\t\thandler = &rotary_encoder_half_period_irq;\n\t\tencoder->last_stable = rotary_encoder_get_state(encoder);\n\t\tbreak;\n\tcase 1:\n\t\thandler = &rotary_encoder_irq;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"'%d' is not a valid steps-per-period value\\n\",\n\t\t\tsteps_per_period);\n\t\treturn -EINVAL;\n\t}\n\n\tencoder->irq =\n\t\tdevm_kcalloc(dev,\n\t\t\t     encoder->gpios->ndescs, sizeof(*encoder->irq),\n\t\t\t     GFP_KERNEL);\n\tif (!encoder->irq)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < encoder->gpios->ndescs; ++i) {\n\t\tencoder->irq[i] = gpiod_to_irq(encoder->gpios->desc[i]);\n\n\t\terr = devm_request_threaded_irq(dev, encoder->irq[i],\n\t\t\t\tNULL, handler,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\tDRV_NAME, encoder);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to request IRQ %d (gpio#%d)\\n\",\n\t\t\t\tencoder->irq[i], i);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = input_register_device(input);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register input device\\n\");\n\t\treturn err;\n\t}\n\n\tdevice_init_wakeup(dev,\n\t\t\t   device_property_read_bool(dev, \"wakeup-source\"));\n\n\tplatform_set_drvdata(pdev, encoder);\n\n\treturn 0;\n}\n\nstatic int rotary_encoder_suspend(struct device *dev)\n{\n\tstruct rotary_encoder *encoder = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tif (device_may_wakeup(dev)) {\n\t\tfor (i = 0; i < encoder->gpios->ndescs; ++i)\n\t\t\tenable_irq_wake(encoder->irq[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int rotary_encoder_resume(struct device *dev)\n{\n\tstruct rotary_encoder *encoder = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tif (device_may_wakeup(dev)) {\n\t\tfor (i = 0; i < encoder->gpios->ndescs; ++i)\n\t\t\tdisable_irq_wake(encoder->irq[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(rotary_encoder_pm_ops,\n\t\t\t\trotary_encoder_suspend, rotary_encoder_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id rotary_encoder_of_match[] = {\n\t{ .compatible = \"rotary-encoder\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rotary_encoder_of_match);\n#endif\n\nstatic struct platform_driver rotary_encoder_driver = {\n\t.probe\t\t= rotary_encoder_probe,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&rotary_encoder_pm_ops),\n\t\t.of_match_table = of_match_ptr(rotary_encoder_of_match),\n\t}\n};\nmodule_platform_driver(rotary_encoder_driver);\n\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_DESCRIPTION(\"GPIO rotary encoder driver\");\nMODULE_AUTHOR(\"Daniel Mack <daniel@caiaq.de>, Johan Hovold\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}