{
  "module_name": "sparcspkr.c",
  "hash_id": "b5bb1aacadd7922dec53ad61ac94dfbe788e6197add73a67fe7dcac0d78b4cdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/sparcspkr.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_DESCRIPTION(\"Sparc Speaker beeper driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct grover_beep_info {\n\tvoid __iomem\t*freq_regs;\n\tvoid __iomem\t*enable_reg;\n};\n\nstruct bbc_beep_info {\n\tu32\t\tclock_freq;\n\tvoid __iomem\t*regs;\n};\n\nstruct sparcspkr_state {\n\tconst char\t\t*name;\n\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\n\tspinlock_t\t\tlock;\n\tstruct input_dev\t*input_dev;\n\tunion {\n\t\tstruct grover_beep_info grover;\n\t\tstruct bbc_beep_info bbc;\n\t} u;\n};\n\nstatic u32 bbc_count_to_reg(struct bbc_beep_info *info, unsigned int count)\n{\n\tu32 val, clock_freq = info->clock_freq;\n\tint i;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count <= clock_freq >> 20)\n\t\treturn 1 << 18;\n\n\tif (count >= clock_freq >> 12)\n\t\treturn 1 << 10;\n\n\tval = 1 << 18;\n\tfor (i = 19; i >= 11; i--) {\n\t\tval >>= 1;\n\t\tif (count <= clock_freq >> i)\n\t\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic int bbc_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)\n{\n\tstruct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);\n\tstruct bbc_beep_info *info = &state->u.bbc;\n\tunsigned int count = 0;\n\tunsigned long flags;\n\n\tif (type != EV_SND)\n\t\treturn -1;\n\n\tswitch (code) {\n\t\tcase SND_BELL: if (value) value = 1000;\n\t\tcase SND_TONE: break;\n\t\tdefault: return -1;\n\t}\n\n\tif (value > 20 && value < 32767)\n\t\tcount = 1193182 / value;\n\n\tcount = bbc_count_to_reg(info, count);\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tif (count) {\n\t\tsbus_writeb(0x01,                 info->regs + 0);\n\t\tsbus_writeb(0x00,                 info->regs + 2);\n\t\tsbus_writeb((count >> 16) & 0xff, info->regs + 3);\n\t\tsbus_writeb((count >>  8) & 0xff, info->regs + 4);\n\t\tsbus_writeb(0x00,                 info->regs + 5);\n\t} else {\n\t\tsbus_writeb(0x00,                 info->regs + 0);\n\t}\n\n\tspin_unlock_irqrestore(&state->lock, flags);\n\n\treturn 0;\n}\n\nstatic int grover_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)\n{\n\tstruct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);\n\tstruct grover_beep_info *info = &state->u.grover;\n\tunsigned int count = 0;\n\tunsigned long flags;\n\n\tif (type != EV_SND)\n\t\treturn -1;\n\n\tswitch (code) {\n\t\tcase SND_BELL: if (value) value = 1000;\n\t\tcase SND_TONE: break;\n\t\tdefault: return -1;\n\t}\n\n\tif (value > 20 && value < 32767)\n\t\tcount = 1193182 / value;\n\n\tspin_lock_irqsave(&state->lock, flags);\n\n\tif (count) {\n\t\t \n\t\tsbus_writeb(sbus_readb(info->enable_reg) | 3, info->enable_reg);\n\t\t \n\t\tsbus_writeb(0xB6, info->freq_regs + 1);\n\t\t \n\t\tsbus_writeb(count & 0xff, info->freq_regs + 0);\n\t\tsbus_writeb((count >> 8) & 0xff, info->freq_regs + 0);\n\t} else {\n\t\t \n\t\tsbus_writeb(sbus_readb(info->enable_reg) & 0xFC, info->enable_reg);\n\t}\n\n\tspin_unlock_irqrestore(&state->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sparcspkr_probe(struct device *dev)\n{\n\tstruct sparcspkr_state *state = dev_get_drvdata(dev);\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = state->name;\n\tinput_dev->phys = \"sparc/input0\";\n\tinput_dev->id.bustype = BUS_ISA;\n\tinput_dev->id.vendor = 0x001f;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_SND);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\n\tinput_dev->event = state->event;\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tinput_free_device(input_dev);\n\t\treturn error;\n\t}\n\n\tstate->input_dev = input_dev;\n\n\treturn 0;\n}\n\nstatic void sparcspkr_shutdown(struct platform_device *dev)\n{\n\tstruct sparcspkr_state *state = platform_get_drvdata(dev);\n\tstruct input_dev *input_dev = state->input_dev;\n\n\t \n\tstate->event(input_dev, EV_SND, SND_BELL, 0);\n}\n\nstatic int bbc_beep_probe(struct platform_device *op)\n{\n\tstruct sparcspkr_state *state;\n\tstruct bbc_beep_info *info;\n\tstruct device_node *dp;\n\tint err = -ENOMEM;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\tgoto out_err;\n\n\tstate->name = \"Sparc BBC Speaker\";\n\tstate->event = bbc_spkr_event;\n\tspin_lock_init(&state->lock);\n\n\tdp = of_find_node_by_path(\"/\");\n\terr = -ENODEV;\n\tif (!dp)\n\t\tgoto out_free;\n\n\tinfo = &state->u.bbc;\n\tinfo->clock_freq = of_getintprop_default(dp, \"clock-frequency\", 0);\n\tof_node_put(dp);\n\tif (!info->clock_freq)\n\t\tgoto out_free;\n\n\tinfo->regs = of_ioremap(&op->resource[0], 0, 6, \"bbc beep\");\n\tif (!info->regs)\n\t\tgoto out_free;\n\n\tplatform_set_drvdata(op, state);\n\n\terr = sparcspkr_probe(&op->dev);\n\tif (err)\n\t\tgoto out_clear_drvdata;\n\n\treturn 0;\n\nout_clear_drvdata:\n\tof_iounmap(&op->resource[0], info->regs, 6);\n\nout_free:\n\tkfree(state);\nout_err:\n\treturn err;\n}\n\nstatic int bbc_remove(struct platform_device *op)\n{\n\tstruct sparcspkr_state *state = platform_get_drvdata(op);\n\tstruct input_dev *input_dev = state->input_dev;\n\tstruct bbc_beep_info *info = &state->u.bbc;\n\n\t \n\tstate->event(input_dev, EV_SND, SND_BELL, 0);\n\n\tinput_unregister_device(input_dev);\n\n\tof_iounmap(&op->resource[0], info->regs, 6);\n\n\tkfree(state);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bbc_beep_match[] = {\n\t{\n\t\t.name = \"beep\",\n\t\t.compatible = \"SUNW,bbc-beep\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bbc_beep_match);\n\nstatic struct platform_driver bbc_beep_driver = {\n\t.driver = {\n\t\t.name = \"bbcbeep\",\n\t\t.of_match_table = bbc_beep_match,\n\t},\n\t.probe\t\t= bbc_beep_probe,\n\t.remove\t\t= bbc_remove,\n\t.shutdown\t= sparcspkr_shutdown,\n};\n\nstatic int grover_beep_probe(struct platform_device *op)\n{\n\tstruct sparcspkr_state *state;\n\tstruct grover_beep_info *info;\n\tint err = -ENOMEM;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\tgoto out_err;\n\n\tstate->name = \"Sparc Grover Speaker\";\n\tstate->event = grover_spkr_event;\n\tspin_lock_init(&state->lock);\n\n\tinfo = &state->u.grover;\n\tinfo->freq_regs = of_ioremap(&op->resource[2], 0, 2, \"grover beep freq\");\n\tif (!info->freq_regs)\n\t\tgoto out_free;\n\n\tinfo->enable_reg = of_ioremap(&op->resource[3], 0, 1, \"grover beep enable\");\n\tif (!info->enable_reg)\n\t\tgoto out_unmap_freq_regs;\n\n\tplatform_set_drvdata(op, state);\n\n\terr = sparcspkr_probe(&op->dev);\n\tif (err)\n\t\tgoto out_clear_drvdata;\n\n\treturn 0;\n\nout_clear_drvdata:\n\tof_iounmap(&op->resource[3], info->enable_reg, 1);\n\nout_unmap_freq_regs:\n\tof_iounmap(&op->resource[2], info->freq_regs, 2);\nout_free:\n\tkfree(state);\nout_err:\n\treturn err;\n}\n\nstatic int grover_remove(struct platform_device *op)\n{\n\tstruct sparcspkr_state *state = platform_get_drvdata(op);\n\tstruct grover_beep_info *info = &state->u.grover;\n\tstruct input_dev *input_dev = state->input_dev;\n\n\t \n\tstate->event(input_dev, EV_SND, SND_BELL, 0);\n\n\tinput_unregister_device(input_dev);\n\n\tof_iounmap(&op->resource[3], info->enable_reg, 1);\n\tof_iounmap(&op->resource[2], info->freq_regs, 2);\n\n\tkfree(state);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id grover_beep_match[] = {\n\t{\n\t\t.name = \"beep\",\n\t\t.compatible = \"SUNW,smbus-beep\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, grover_beep_match);\n\nstatic struct platform_driver grover_beep_driver = {\n\t.driver = {\n\t\t.name = \"groverbeep\",\n\t\t.of_match_table = grover_beep_match,\n\t},\n\t.probe\t\t= grover_beep_probe,\n\t.remove\t\t= grover_remove,\n\t.shutdown\t= sparcspkr_shutdown,\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&bbc_beep_driver,\n\t&grover_beep_driver,\n};\n\nstatic int __init sparcspkr_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\nstatic void __exit sparcspkr_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\nmodule_init(sparcspkr_init);\nmodule_exit(sparcspkr_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}