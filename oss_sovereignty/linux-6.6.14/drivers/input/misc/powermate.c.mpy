{
  "module_name": "powermate.c",
  "hash_id": "0c23aa118cfdcf2ca5b213a53cd6e87f21d539f7a326309ed699e4fcbe8fedf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/powermate.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/usb/input.h>\n\n#define POWERMATE_VENDOR\t0x077d\t \n#define POWERMATE_PRODUCT_NEW\t0x0410\t \n#define POWERMATE_PRODUCT_OLD\t0x04AA\t \n\n#define CONTOUR_VENDOR\t\t0x05f3\t \n#define CONTOUR_JOG\t\t0x0240\t \n\n \n#define SET_STATIC_BRIGHTNESS  0x01\n#define SET_PULSE_ASLEEP       0x02\n#define SET_PULSE_AWAKE        0x03\n#define SET_PULSE_MODE         0x04\n\n \n#define UPDATE_STATIC_BRIGHTNESS (1<<0)\n#define UPDATE_PULSE_ASLEEP      (1<<1)\n#define UPDATE_PULSE_AWAKE       (1<<2)\n#define UPDATE_PULSE_MODE        (1<<3)\n\n \n#define POWERMATE_PAYLOAD_SIZE_MAX 6\n#define POWERMATE_PAYLOAD_SIZE_MIN 3\nstruct powermate_device {\n\tsigned char *data;\n\tdma_addr_t data_dma;\n\tstruct urb *irq, *config;\n\tstruct usb_ctrlrequest *configcr;\n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\tstruct input_dev *input;\n\tspinlock_t lock;\n\tint static_brightness;\n\tint pulse_speed;\n\tint pulse_table;\n\tint pulse_asleep;\n\tint pulse_awake;\n\tint requires_update; \n\tchar phys[64];\n};\n\nstatic char pm_name_powermate[] = \"Griffin PowerMate\";\nstatic char pm_name_soundknob[] = \"Griffin SoundKnob\";\n\nstatic void powermate_config_complete(struct urb *urb);\n\n \nstatic void powermate_irq(struct urb *urb)\n{\n\tstruct powermate_device *pm = urb->context;\n\tstruct device *dev = &pm->intf->dev;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\t \n\tinput_report_key(pm->input, BTN_0, pm->data[0] & 0x01);\n\tinput_report_rel(pm->input, REL_DIAL, pm->data[1]);\n\tinput_sync(pm->input);\n\nexit:\n\tretval = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result: %d\\n\",\n\t\t\t__func__, retval);\n}\n\n \nstatic void powermate_sync_state(struct powermate_device *pm)\n{\n\tif (pm->requires_update == 0)\n\t\treturn;  \n\tif (pm->config->status == -EINPROGRESS)\n\t\treturn;  \n\n\tif (pm->requires_update & UPDATE_PULSE_ASLEEP){\n\t\tpm->configcr->wValue = cpu_to_le16( SET_PULSE_ASLEEP );\n\t\tpm->configcr->wIndex = cpu_to_le16( pm->pulse_asleep ? 1 : 0 );\n\t\tpm->requires_update &= ~UPDATE_PULSE_ASLEEP;\n\t}else if (pm->requires_update & UPDATE_PULSE_AWAKE){\n\t\tpm->configcr->wValue = cpu_to_le16( SET_PULSE_AWAKE );\n\t\tpm->configcr->wIndex = cpu_to_le16( pm->pulse_awake ? 1 : 0 );\n\t\tpm->requires_update &= ~UPDATE_PULSE_AWAKE;\n\t}else if (pm->requires_update & UPDATE_PULSE_MODE){\n\t\tint op, arg;\n\t\t \n\t\tif (pm->pulse_speed < 255) {\n\t\t\top = 0;                    \n\t\t\targ = 255 - pm->pulse_speed;\n\t\t} else if (pm->pulse_speed > 255) {\n\t\t\top = 2;                    \n\t\t\targ = pm->pulse_speed - 255;\n\t\t} else {\n\t\t\top = 1;                    \n\t\t\targ = 0;                   \n\t\t}\n\t\tpm->configcr->wValue = cpu_to_le16( (pm->pulse_table << 8) | SET_PULSE_MODE );\n\t\tpm->configcr->wIndex = cpu_to_le16( (arg << 8) | op );\n\t\tpm->requires_update &= ~UPDATE_PULSE_MODE;\n\t} else if (pm->requires_update & UPDATE_STATIC_BRIGHTNESS) {\n\t\tpm->configcr->wValue = cpu_to_le16( SET_STATIC_BRIGHTNESS );\n\t\tpm->configcr->wIndex = cpu_to_le16( pm->static_brightness );\n\t\tpm->requires_update &= ~UPDATE_STATIC_BRIGHTNESS;\n\t} else {\n\t\tprintk(KERN_ERR \"powermate: unknown update required\");\n\t\tpm->requires_update = 0;  \n\t\treturn;\n\t}\n\n \n\n\tpm->configcr->bRequestType = 0x41;  \n\tpm->configcr->bRequest = 0x01;\n\tpm->configcr->wLength = 0;\n\n\tusb_fill_control_urb(pm->config, pm->udev, usb_sndctrlpipe(pm->udev, 0),\n\t\t\t     (void *) pm->configcr, NULL, 0,\n\t\t\t     powermate_config_complete, pm);\n\n\tif (usb_submit_urb(pm->config, GFP_ATOMIC))\n\t\tprintk(KERN_ERR \"powermate: usb_submit_urb(config) failed\");\n}\n\n \nstatic void powermate_config_complete(struct urb *urb)\n{\n\tstruct powermate_device *pm = urb->context;\n\tunsigned long flags;\n\n\tif (urb->status)\n\t\tprintk(KERN_ERR \"powermate: config urb returned %d\\n\", urb->status);\n\n\tspin_lock_irqsave(&pm->lock, flags);\n\tpowermate_sync_state(pm);\n\tspin_unlock_irqrestore(&pm->lock, flags);\n}\n\n \nstatic void powermate_pulse_led(struct powermate_device *pm, int static_brightness, int pulse_speed,\n\t\t\t\tint pulse_table, int pulse_asleep, int pulse_awake)\n{\n\tunsigned long flags;\n\n\tif (pulse_speed < 0)\n\t\tpulse_speed = 0;\n\tif (pulse_table < 0)\n\t\tpulse_table = 0;\n\tif (pulse_speed > 510)\n\t\tpulse_speed = 510;\n\tif (pulse_table > 2)\n\t\tpulse_table = 2;\n\n\tpulse_asleep = !!pulse_asleep;\n\tpulse_awake = !!pulse_awake;\n\n\n\tspin_lock_irqsave(&pm->lock, flags);\n\n\t \n\tif (static_brightness != pm->static_brightness) {\n\t\tpm->static_brightness = static_brightness;\n\t\tpm->requires_update |= UPDATE_STATIC_BRIGHTNESS;\n\t}\n\tif (pulse_asleep != pm->pulse_asleep) {\n\t\tpm->pulse_asleep = pulse_asleep;\n\t\tpm->requires_update |= (UPDATE_PULSE_ASLEEP | UPDATE_STATIC_BRIGHTNESS);\n\t}\n\tif (pulse_awake != pm->pulse_awake) {\n\t\tpm->pulse_awake = pulse_awake;\n\t\tpm->requires_update |= (UPDATE_PULSE_AWAKE | UPDATE_STATIC_BRIGHTNESS);\n\t}\n\tif (pulse_speed != pm->pulse_speed || pulse_table != pm->pulse_table) {\n\t\tpm->pulse_speed = pulse_speed;\n\t\tpm->pulse_table = pulse_table;\n\t\tpm->requires_update |= UPDATE_PULSE_MODE;\n\t}\n\n\tpowermate_sync_state(pm);\n\n\tspin_unlock_irqrestore(&pm->lock, flags);\n}\n\n \nstatic int powermate_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int _value)\n{\n\tunsigned int command = (unsigned int)_value;\n\tstruct powermate_device *pm = input_get_drvdata(dev);\n\n\tif (type == EV_MSC && code == MSC_PULSELED){\n\t\t \n\t\tint static_brightness = command & 0xFF;    \n\t\tint pulse_speed = (command >> 8) & 0x1FF;  \n\t\tint pulse_table = (command >> 17) & 0x3;   \n\t\tint pulse_asleep = (command >> 19) & 0x1;  \n\t\tint pulse_awake  = (command >> 20) & 0x1;  \n\n\t\tpowermate_pulse_led(pm, static_brightness, pulse_speed, pulse_table, pulse_asleep, pulse_awake);\n\t}\n\n\treturn 0;\n}\n\nstatic int powermate_alloc_buffers(struct usb_device *udev, struct powermate_device *pm)\n{\n\tpm->data = usb_alloc_coherent(udev, POWERMATE_PAYLOAD_SIZE_MAX,\n\t\t\t\t      GFP_KERNEL, &pm->data_dma);\n\tif (!pm->data)\n\t\treturn -1;\n\n\tpm->configcr = kmalloc(sizeof(*(pm->configcr)), GFP_KERNEL);\n\tif (!pm->configcr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void powermate_free_buffers(struct usb_device *udev, struct powermate_device *pm)\n{\n\tusb_free_coherent(udev, POWERMATE_PAYLOAD_SIZE_MAX,\n\t\t\t  pm->data, pm->data_dma);\n\tkfree(pm->configcr);\n}\n\n \nstatic int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev (intf);\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct powermate_device *pm;\n\tstruct input_dev *input_dev;\n\tint pipe, maxp;\n\tint error = -ENOMEM;\n\n\tinterface = intf->cur_altsetting;\n\tif (interface->desc.bNumEndpoints < 1)\n\t\treturn -EINVAL;\n\n\tendpoint = &interface->endpoint[0].desc;\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -EIO;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t0, interface->desc.bInterfaceNumber, NULL, 0,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\tpm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!pm || !input_dev)\n\t\tgoto fail1;\n\n\tif (powermate_alloc_buffers(udev, pm))\n\t\tgoto fail2;\n\n\tpm->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pm->irq)\n\t\tgoto fail2;\n\n\tpm->config = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pm->config)\n\t\tgoto fail3;\n\n\tpm->udev = udev;\n\tpm->intf = intf;\n\tpm->input = input_dev;\n\n\tusb_make_path(udev, pm->phys, sizeof(pm->phys));\n\tstrlcat(pm->phys, \"/input0\", sizeof(pm->phys));\n\n\tspin_lock_init(&pm->lock);\n\n\tswitch (le16_to_cpu(udev->descriptor.idProduct)) {\n\tcase POWERMATE_PRODUCT_NEW:\n\t\tinput_dev->name = pm_name_powermate;\n\t\tbreak;\n\tcase POWERMATE_PRODUCT_OLD:\n\t\tinput_dev->name = pm_name_soundknob;\n\t\tbreak;\n\tdefault:\n\t\tinput_dev->name = pm_name_soundknob;\n\t\tprintk(KERN_WARNING \"powermate: unknown product id %04x\\n\",\n\t\t       le16_to_cpu(udev->descriptor.idProduct));\n\t}\n\n\tinput_dev->phys = pm->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, pm);\n\n\tinput_dev->event = powermate_input_event;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |\n\t\tBIT_MASK(EV_MSC);\n\tinput_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);\n\tinput_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL);\n\tinput_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED);\n\n\t \n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe);\n\n\tif (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) {\n\t\tprintk(KERN_WARNING \"powermate: Expected payload of %d--%d bytes, found %d bytes!\\n\",\n\t\t\tPOWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp);\n\t\tmaxp = POWERMATE_PAYLOAD_SIZE_MAX;\n\t}\n\n\tusb_fill_int_urb(pm->irq, udev, pipe, pm->data,\n\t\t\t maxp, powermate_irq,\n\t\t\t pm, endpoint->bInterval);\n\tpm->irq->transfer_dma = pm->data_dma;\n\tpm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\tif (usb_submit_urb(pm->irq, GFP_KERNEL)) {\n\t\terror = -EIO;\n\t\tgoto fail4;\n\t}\n\n\terror = input_register_device(pm->input);\n\tif (error)\n\t\tgoto fail5;\n\n\n\t \n\tpm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS;\n\tpowermate_pulse_led(pm, 0x80, 255, 0, 1, 0);  \n\n\tusb_set_intfdata(intf, pm);\n\treturn 0;\n\n fail5:\tusb_kill_urb(pm->irq);\n fail4:\tusb_free_urb(pm->config);\n fail3:\tusb_free_urb(pm->irq);\n fail2:\tpowermate_free_buffers(udev, pm);\n fail1:\tinput_free_device(input_dev);\n\tkfree(pm);\n\treturn error;\n}\n\n \nstatic void powermate_disconnect(struct usb_interface *intf)\n{\n\tstruct powermate_device *pm = usb_get_intfdata (intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (pm) {\n\t\tpm->requires_update = 0;\n\t\tusb_kill_urb(pm->irq);\n\t\tinput_unregister_device(pm->input);\n\t\tusb_kill_urb(pm->config);\n\t\tusb_free_urb(pm->irq);\n\t\tusb_free_urb(pm->config);\n\t\tpowermate_free_buffers(interface_to_usbdev(intf), pm);\n\n\t\tkfree(pm);\n\t}\n}\n\nstatic const struct usb_device_id powermate_devices[] = {\n\t{ USB_DEVICE(POWERMATE_VENDOR, POWERMATE_PRODUCT_NEW) },\n\t{ USB_DEVICE(POWERMATE_VENDOR, POWERMATE_PRODUCT_OLD) },\n\t{ USB_DEVICE(CONTOUR_VENDOR, CONTOUR_JOG) },\n\t{ }  \n};\n\nMODULE_DEVICE_TABLE (usb, powermate_devices);\n\nstatic struct usb_driver powermate_driver = {\n        .name =         \"powermate\",\n        .probe =        powermate_probe,\n        .disconnect =   powermate_disconnect,\n        .id_table =     powermate_devices,\n};\n\nmodule_usb_driver(powermate_driver);\n\nMODULE_AUTHOR( \"William R Sowerbutts\" );\nMODULE_DESCRIPTION( \"Griffin Technology, Inc PowerMate driver\" );\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}