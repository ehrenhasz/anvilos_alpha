{
  "module_name": "Kconfig",
  "hash_id": "10b36777bbafd8bf1f69bb3b8060d4e1cbc3aceca1510f752c494940bd9dd71e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Input misc drivers configuration\n#\nmenuconfig INPUT_MISC\n\tbool \"Miscellaneous devices\"\n\thelp\n\t  Say Y here, and a list of miscellaneous input drivers will be displayed.\n\t  Everything that didn't fit into the other categories is here. This option\n\t  doesn't affect the kernel.\n\n\t  If unsure, say Y.\n\nif INPUT_MISC\n\nconfig INPUT_88PM860X_ONKEY\n\ttristate \"88PM860x ONKEY support\"\n\tdepends on MFD_88PM860X\n\thelp\n\t  Support the ONKEY of Marvell 88PM860x PMICs as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called 88pm860x_onkey.\n\nconfig INPUT_88PM80X_ONKEY\n\ttristate \"88PM80x ONKEY support\"\n\tdepends on MFD_88PM800\n\thelp\n\t  Support the ONKEY of Marvell 88PM80x PMICs as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called 88pm80x_onkey.\n\nconfig INPUT_AB8500_PONKEY\n\ttristate \"AB8500 Pon (PowerOn) Key\"\n\tdepends on AB8500_CORE\n\thelp\n\t  Say Y here to use the PowerOn Key for ST-Ericsson's AB8500\n\t  Mix-Sig PMIC.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called ab8500-ponkey.\n\nconfig INPUT_AD714X\n\ttristate \"Analog Devices AD714x Capacitance Touch Sensor\"\n\thelp\n\t  Say Y here if you want to support an AD7142/3/7/8/7A touch sensor.\n\n\t  You should select a bus connection too.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called ad714x.\n\nconfig INPUT_AD714X_I2C\n\ttristate \"support I2C bus connection\"\n\tdepends on INPUT_AD714X && I2C\n\tdefault y\n\thelp\n\t  Say Y here if you have AD7142/AD7147 hooked to an I2C bus.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called ad714x-i2c.\n\nconfig INPUT_AD714X_SPI\n\ttristate \"support SPI bus connection\"\n\tdepends on INPUT_AD714X && SPI\n\tdefault y\n\thelp\n\t  Say Y here if you have AD7142/AD7147 hooked to a SPI bus.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called ad714x-spi.\n\nconfig INPUT_ARIEL_PWRBUTTON\n\ttristate \"Dell Wyse 3020 Power Button Driver\"\n\tdepends on SPI\n\tdepends on MACH_MMP3_DT || COMPILE_TEST\n\thelp\n\t  Say Y to enable support for reporting power button status on\n\t  on Dell Wyse 3020 (\"Ariel\") thin client.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called ariel-pwrbutton.\n\nconfig INPUT_ARIZONA_HAPTICS\n\ttristate \"Arizona haptics support\"\n\tdepends on MFD_ARIZONA && SND_SOC\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  Say Y to enable support for the haptics module in Arizona CODECs.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called arizona-haptics.\n\nconfig INPUT_ATC260X_ONKEY\n\ttristate \"Actions Semi ATC260x PMIC ONKEY\"\n\tdepends on MFD_ATC260X\n\thelp\n\t  Support the ONKEY of ATC260x PMICs as an input device reporting\n\t  power button status. ONKEY can be used to wakeup from low power\n\t  modes and force a reset on long press.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called atc260x-onkey.\n\nconfig INPUT_ATMEL_CAPTOUCH\n\ttristate \"Atmel Capacitive Touch Button Driver\"\n\tdepends on OF\n\tdepends on I2C\n\thelp\n\t  Say Y here if an Atmel Capacitive Touch Button device which\n\t  implements \"captouch\" protocol is connected to I2C bus. Typically\n\t  this device consists of Atmel Touch sensor controlled by AtMegaXX\n\t  MCU running firmware based on Qtouch library.\n\t  One should find \"atmel,captouch\" node in the board specific DTS.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called atmel_captouch.\n\nconfig INPUT_BBNSM_PWRKEY\n\ttristate \"NXP BBNSM Power Key Driver\"\n\tdepends on ARCH_MXC || COMPILE_TEST\n\tdepends on OF\n\thelp\n\t  This is the bbnsm powerkey driver for the NXP i.MX application\n\t  processors.\n\n\t  To compile this driver as a module, choose M here; the\n\t  module will be called bbnsm_pwrkey.\n\nconfig INPUT_BMA150\n\ttristate \"BMA150/SMB380 acceleration sensor support\"\n\tdepends on I2C\n\thelp\n\t  Say Y here if you have Bosch Sensortec's BMA150 or SMB380\n\t  acceleration sensor hooked to an I2C bus.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called bma150.\n\nconfig INPUT_E3X0_BUTTON\n\ttristate \"NI Ettus Research USRP E3xx Button support.\"\n\tdefault n\n\thelp\n\t  Say Y here to enable support for the NI Ettus Research\n\t  USRP E3xx Button.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called e3x0_button.\n\nconfig INPUT_PCSPKR\n\ttristate \"PC Speaker support\"\n\tdepends on PCSPKR_PLATFORM\n\thelp\n\t  Say Y here if you want the standard PC Speaker to be used for\n\t  bells and whistles.\n\n\t  If unsure, say Y.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called pcspkr.\n\nconfig INPUT_PM8941_PWRKEY\n\ttristate \"Qualcomm PM8941 power key support\"\n\tdepends on MFD_SPMI_PMIC\n\thelp\n\t  Say Y here if you want support for the power key usually found\n\t  on boards using a Qualcomm PM8941 compatible PMIC.\n\n\t  If unsure, say Y.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called pm8941-pwrkey.\n\nconfig INPUT_PM8XXX_VIBRATOR\n\ttristate \"Qualcomm PM8XXX vibrator support\"\n\tdepends on MFD_PM8XXX || MFD_SPMI_PMIC\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables device driver support for the vibrator\n\t  on Qualcomm PM8xxx chip. This driver supports ff-memless interface\n\t  from input framework.\n\n\t  To compile this driver as module, choose M here: the\n\t  module will be called pm8xxx-vibrator.\n\nconfig INPUT_PMIC8XXX_PWRKEY\n\ttristate \"PMIC8XXX power key support\"\n\tdepends on MFD_PM8XXX\n\thelp\n\t  Say Y here if you want support for the PMIC8XXX power key.\n\n\t  If unsure, say N.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called pmic8xxx-pwrkey.\n\nconfig INPUT_SPARCSPKR\n\ttristate \"SPARC Speaker support\"\n\tdepends on PCI && SPARC64\n\thelp\n\t  Say Y here if you want the standard Speaker on Sparc PCI systems\n\t  to be used for bells and whistles.\n\n\t  If unsure, say Y.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called sparcspkr.\n\nconfig INPUT_M68K_BEEP\n\ttristate \"M68k Beeper support\"\n\tdepends on M68K\n\nconfig INPUT_MAX77650_ONKEY\n\ttristate \"Maxim MAX77650 ONKEY support\"\n\tdepends on MFD_MAX77650\n\thelp\n\t  Support the ONKEY of the MAX77650 PMIC as an input device.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called max77650-onkey.\n\nconfig INPUT_MAX77693_HAPTIC\n\ttristate \"MAXIM MAX77693/MAX77843 haptic controller support\"\n\tdepends on (MFD_MAX77693 || MFD_MAX77843) && PWM\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables support for the haptic controller on\n\t  MAXIM MAX77693 and MAX77843 chips.\n\n\t  To compile this driver as module, choose M here: the\n\t  module will be called max77693-haptic.\n\nconfig INPUT_MAX8925_ONKEY\n\ttristate \"MAX8925 ONKEY support\"\n\tdepends on MFD_MAX8925\n\thelp\n\t  Support the ONKEY of MAX8925 PMICs as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called max8925_onkey.\n\nconfig INPUT_MAX8997_HAPTIC\n\ttristate \"MAXIM MAX8997 haptic controller support\"\n\tdepends on PWM && MFD_MAX8997\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables device driver support for the haptic controller\n\t  on MAXIM MAX8997 chip. This driver supports ff-memless interface\n\t  from input framework.\n\n\t  To compile this driver as module, choose M here: the\n\t  module will be called max8997-haptic.\n\nconfig INPUT_MC13783_PWRBUTTON\n\ttristate \"MC13783 ON buttons\"\n\tdepends on MFD_MC13XXX\n\thelp\n\t  Support the ON buttons of MC13783 PMIC as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called mc13783-pwrbutton.\n\nconfig INPUT_MMA8450\n\ttristate \"MMA8450 - Freescale's 3-Axis, 8/12-bit Digital Accelerometer\"\n\tdepends on I2C\n\thelp\n\t  Say Y here if you want to support Freescale's MMA8450 Accelerometer\n\t  through I2C interface.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called mma8450.\n\nconfig INPUT_APANEL\n\ttristate \"Fujitsu Lifebook Application Panel buttons\"\n\tdepends on X86 && I2C && LEDS_CLASS\n\tselect CHECK_SIGNATURE\n\thelp\n\t Say Y here for support of the Application Panel buttons, used on\n\t Fujitsu Lifebook. These are attached to the mainboard through\n\t an SMBus interface managed by the I2C Intel ICH (i801) driver,\n\t which you should also build for this kernel.\n\n\t To compile this driver as a module, choose M here: the module will\n\t be called apanel.\n\nconfig INPUT_GPIO_BEEPER\n\ttristate \"Generic GPIO Beeper support\"\n\tdepends on GPIOLIB || COMPILE_TEST\n\thelp\n\t  Say Y here if you have a beeper connected to a GPIO pin.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called gpio-beeper.\n\nconfig INPUT_GPIO_DECODER\n\ttristate \"Polled GPIO Decoder Input driver\"\n\tdepends on GPIOLIB || COMPILE_TEST\n\thelp\n\t Say Y here if you want driver to read status of multiple GPIO\n\t lines and report the encoded value as an absolute integer to\n\t input subsystem.\n\n\t To compile this driver as a module, choose M here: the module\n\t will be called gpio_decoder.\n\nconfig INPUT_GPIO_VIBRA\n\ttristate \"GPIO vibrator support\"\n\tdepends on GPIOLIB || COMPILE_TEST\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  Say Y here to get support for GPIO based vibrator devices.\n\n\t  If unsure, say N.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called gpio-vibra.\n\nconfig INPUT_COBALT_BTNS\n\ttristate \"Cobalt button interface\"\n\tdepends on MIPS_COBALT\n\thelp\n\t  Say Y here if you want to support MIPS Cobalt button interface.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cobalt_btns.\n\nconfig INPUT_CPCAP_PWRBUTTON\n\ttristate \"CPCAP OnKey\"\n\tdepends on MFD_CPCAP\n\thelp\n\t  Say Y here if you want to enable power key reporting via the\n\t  Motorola CPCAP chip.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called cpcap-pwrbutton.\n\nconfig INPUT_WISTRON_BTNS\n\ttristate \"x86 Wistron laptop button interface\"\n\tdepends on X86_32 && !UML\n\tselect INPUT_SPARSEKMAP\n\tselect NEW_LEDS\n\tselect LEDS_CLASS\n\tselect CHECK_SIGNATURE\n\thelp\n\t  Say Y here for support of Wistron laptop button interfaces, used on\n\t  laptops of various brands, including Acer and Fujitsu-Siemens. If\n\t  available, mail and wifi LEDs will be controllable via /sys/class/leds.\n\n\t  To compile this driver as a module, choose M here: the module will\n\t  be called wistron_btns.\n\nconfig INPUT_ATLAS_BTNS\n\ttristate \"x86 Atlas button interface\"\n\tdepends on X86 && ACPI\n\thelp\n\t  Say Y here for support of Atlas wallmount touchscreen buttons.\n\t  The events will show up as scancodes F1 through F9 via evdev.\n\n\t  To compile this driver as a module, choose M here: the module will\n\t  be called atlas_btns.\n\nconfig INPUT_ATI_REMOTE2\n\ttristate \"ATI / Philips USB RF remote control\"\n\tdepends on USB_ARCH_HAS_HCD\n\tselect USB\n\thelp\n\t  Say Y here if you want to use an ATI or Philips USB RF remote control.\n\t  These are RF remotes with USB receivers.\n\t  ATI Remote Wonder II comes with some ATI's All-In-Wonder video cards\n\t  and is also available as a separate product.\n\t  This driver provides mouse pointer, left and right mouse buttons,\n\t  and maps all the other remote buttons to keypress events.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called ati_remote2.\n\nconfig INPUT_KEYSPAN_REMOTE\n\ttristate \"Keyspan DMR USB remote control\"\n\tdepends on USB_ARCH_HAS_HCD\n\tselect USB\n\thelp\n\t  Say Y here if you want to use a Keyspan DMR USB remote control.\n\t  Currently only the UIA-11 type of receiver has been tested.  The tag\n\t  on the receiver that connects to the USB port should have a P/N that\n\t  will tell you what type of DMR you have.  The UIA-10 type is not\n\t  supported at this time.  This driver maps all buttons to keypress\n\t  events.\n\n\t  To compile this driver as a module, choose M here: the module will\n\t  be called keyspan_remote.\n\nconfig INPUT_KXTJ9\n\ttristate \"Kionix KXTJ9 tri-axis digital accelerometer\"\n\tdepends on I2C\n\thelp\n\t  Say Y here to enable support for the Kionix KXTJ9 digital tri-axis\n\t  accelerometer.\n\n\t  To compile this driver as a module, choose M here: the module will\n\t  be called kxtj9.\n\nconfig INPUT_POWERMATE\n\ttristate \"Griffin PowerMate and Contour Jog support\"\n\tdepends on USB_ARCH_HAS_HCD\n\tselect USB\n\thelp\n\t  Say Y here if you want to use Griffin PowerMate or Contour Jog devices.\n\t  These are aluminum dials which can measure clockwise and anticlockwise\n\t  rotation.  The dial also acts as a pushbutton.  The base contains an LED\n\t  which can be instructed to pulse or to switch to a particular intensity.\n\n\t  You can download userspace tools from\n\t  <http://sowerbutts.com/powermate/>.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called powermate.\n\nconfig INPUT_YEALINK\n\ttristate \"Yealink usb-p1k voip phone\"\n\tdepends on USB_ARCH_HAS_HCD\n\tselect USB\n\thelp\n\t  Say Y here if you want to enable keyboard and LCD functions of the\n\t  Yealink usb-p1k usb phones. The audio part is enabled by the generic\n\t  usb sound driver, so you might want to enable that as well.\n\n\t  For information about how to use these additional functions, see\n\t  <file:Documentation/input/devices/yealink.rst>.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called yealink.\n\nconfig INPUT_CM109\n\ttristate \"C-Media CM109 USB I/O Controller\"\n\tdepends on USB_ARCH_HAS_HCD\n\tselect USB\n\thelp\n\t  Say Y here if you want to enable keyboard and buzzer functions of the\n\t  C-Media CM109 usb phones. The audio part is enabled by the generic\n\t  usb sound driver, so you might want to enable that as well.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called cm109.\n\nconfig INPUT_REGULATOR_HAPTIC\n\ttristate \"Regulator haptics support\"\n\tdepends on REGULATOR\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables device driver support for the haptic controlled\n\t  by a regulator. This driver supports ff-memless interface\n\t  from input framework.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called regulator-haptic.\n\nconfig INPUT_RETU_PWRBUTTON\n\ttristate \"Retu Power button Driver\"\n\tdepends on MFD_RETU\n\thelp\n\t  Say Y here if you want to enable power key reporting via the\n\t  Retu chips found in Nokia Internet Tablets (770, N800, N810).\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called retu-pwrbutton.\n\nconfig INPUT_TPS65218_PWRBUTTON\n\ttristate \"TPS65218 Power button driver\"\n\tdepends on (MFD_TPS65217 || MFD_TPS65218)\n\thelp\n\t  Say Y here if you want to enable power button reporting for\n\t  TPS65217 and TPS65218 Power Management IC devices.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called tps65218-pwrbutton.\n\nconfig INPUT_TPS65219_PWRBUTTON\n\ttristate \"TPS65219 Power button driver\"\n\tdepends on MFD_TPS65219\n\thelp\n\t  Say Y here if you want to enable power button reporting for\n\t  TPS65219 Power Management IC devices.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called tps65219-pwrbutton.\n\nconfig INPUT_AXP20X_PEK\n\ttristate \"X-Powers AXP20X power button driver\"\n\tdepends on MFD_AXP20X\n\thelp\n\t  Say Y here if you want to enable power key reporting via the\n\t  AXP20X PMIC.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called axp20x-pek.\n\n\nconfig INPUT_TWL4030_PWRBUTTON\n\ttristate \"TWL4030 Power button Driver\"\n\tdepends on TWL4030_CORE\n\thelp\n\t  Say Y here if you want to enable power key reporting via the\n\t  TWL4030 family of chips.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called twl4030_pwrbutton.\n\nconfig INPUT_TWL4030_VIBRA\n\ttristate \"Support for TWL4030 Vibrator\"\n\tdepends on TWL4030_CORE\n\tselect MFD_TWL4030_AUDIO\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables support for TWL4030 Vibrator Driver.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called twl4030_vibra.\n\nconfig INPUT_TWL6040_VIBRA\n\ttristate \"Support for TWL6040 Vibrator\"\n\tdepends on TWL6040_CORE\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables support for TWL6040 Vibrator Driver.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called twl6040_vibra.\n\nconfig INPUT_UINPUT\n\ttristate \"User level driver support\"\n\thelp\n\t  Say Y here if you want to support user level drivers for input\n\t  subsystem accessible under char device 10:223 - /dev/input/uinput.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called uinput.\n\nconfig INPUT_SGI_BTNS\n\ttristate \"SGI Indy/O2 volume button interface\"\n\tdepends on SGI_IP22 || SGI_IP32\n\thelp\n\t  Say Y here if you want to support SGI Indy/O2 volume button interface.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called sgi_btns.\n\nconfig HP_SDC_RTC\n\ttristate \"HP SDC Real Time Clock\"\n\tdepends on (GSC || HP300) && SERIO\n\tselect HP_SDC\n\thelp\n\t  Say Y here if you want to support the built-in real time clock\n\t  of the HP SDC controller.\n\nconfig INPUT_PALMAS_PWRBUTTON\n\ttristate \"Palmas Power button Driver\"\n\tdepends on MFD_PALMAS\n\thelp\n\t  Say Y here if you want to enable power key reporting via the\n\t  Palmas family of PMICs.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called palmas_pwrbutton.\n\nconfig INPUT_PCF50633_PMU\n\ttristate \"PCF50633 PMU events\"\n\tdepends on MFD_PCF50633\n\thelp\n\t Say Y to include support for delivering  PMU events via  input\n\t layer on NXP PCF50633.\n\nconfig INPUT_PCF8574\n\ttristate \"PCF8574 Keypad input device\"\n\tdepends on I2C\n\thelp\n\t  Say Y here if you want to support a keypad connected via I2C\n\t  with a PCF8574.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called pcf8574_keypad.\n\nconfig INPUT_PWM_BEEPER\n\ttristate \"PWM beeper support\"\n\tdepends on PWM\n\thelp\n\t  Say Y here to get support for PWM based beeper devices.\n\n\t  If unsure, say N.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called pwm-beeper.\n\nconfig INPUT_PWM_VIBRA\n\ttristate \"PWM vibrator support\"\n\tdepends on PWM\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  Say Y here to get support for PWM based vibrator devices.\n\n\t  If unsure, say N.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called pwm-vibra.\n\nconfig INPUT_RK805_PWRKEY\n\ttristate \"Rockchip RK805 PMIC power key support\"\n\tdepends on MFD_RK8XX\n\thelp\n\t  Select this option to enable power key driver for RK805.\n\n\t  If unsure, say N.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called rk805_pwrkey.\n\nconfig INPUT_GPIO_ROTARY_ENCODER\n\ttristate \"Rotary encoders connected to GPIO pins\"\n\tdepends on GPIOLIB || COMPILE_TEST\n\thelp\n\t  Say Y here to add support for rotary encoders connected to GPIO lines.\n\t  Check file:Documentation/input/devices/rotary-encoder.rst for more\n\t  information.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rotary_encoder.\n\nconfig INPUT_RB532_BUTTON\n\ttristate \"Mikrotik Routerboard 532 button interface\"\n\tdepends on MIKROTIK_RB532\n\tdepends on GPIOLIB\n\thelp\n\t  Say Y here if you want support for the S1 button built into\n\t  Mikrotik's Routerboard 532.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rb532_button.\n\nconfig INPUT_DA7280_HAPTICS\n\ttristate \"Dialog Semiconductor DA7280 haptics support\"\n\tdepends on INPUT && I2C\n\tselect REGMAP_I2C\n\thelp\n\t  Say Y to enable support for the Dialog DA7280 haptics driver.\n\t  The haptics can be controlled by PWM or GPIO\n\t  with I2C communication.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called da7280.\n\nconfig INPUT_DA9052_ONKEY\n\ttristate \"Dialog DA9052/DA9053 Onkey\"\n\tdepends on PMIC_DA9052\n\thelp\n\t  Support the ONKEY of Dialog DA9052 PMICs as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called da9052_onkey.\n\nconfig INPUT_DA9055_ONKEY\n\ttristate \"Dialog Semiconductor DA9055 ONKEY\"\n\tdepends on MFD_DA9055\n\thelp\n\t  Support the ONKEY of DA9055 PMICs as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called da9055_onkey.\n\nconfig INPUT_DA9063_ONKEY\n\ttristate \"Dialog DA9063/62/61 OnKey\"\n\tdepends on MFD_DA9063 || MFD_DA9062\n\thelp\n\t  Support the ONKEY of Dialog DA9063, DA9062 and DA9061 Power\n\t  Management ICs as an input device capable of reporting the\n\t  power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called da9063_onkey.\n\nconfig INPUT_WM831X_ON\n\ttristate \"WM831X ON pin\"\n\tdepends on MFD_WM831X\n\thelp\n\t  Support the ON pin of WM831X PMICs as an input device\n\t  reporting power button status.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called wm831x_on.\n\nconfig INPUT_PCAP\n\ttristate \"Motorola EZX PCAP misc input events\"\n\tdepends on EZX_PCAP\n\thelp\n\t  Say Y here if you want to use Power key and Headphone button\n\t  on Motorola EZX phones.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called pcap_keys.\n\nconfig INPUT_ADXL34X\n\ttristate \"Analog Devices ADXL34x Three-Axis Digital Accelerometer\"\n\tdefault n\n\thelp\n\t  Say Y here if you have a Accelerometer interface using the\n\t  ADXL345/6 controller, and your board-specific initialization\n\t  code includes that in its table of devices.\n\n\t  This driver can use either I2C or SPI communication to the\n\t  ADXL345/6 controller.  Select the appropriate method for\n\t  your system.\n\n\t  If unsure, say N (but it's safe to say \"Y\").\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called adxl34x.\n\nconfig INPUT_ADXL34X_I2C\n\ttristate \"support I2C bus connection\"\n\tdepends on INPUT_ADXL34X && I2C\n\tdefault y\n\thelp\n\t  Say Y here if you have ADXL345/6 hooked to an I2C bus.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called adxl34x-i2c.\n\nconfig INPUT_ADXL34X_SPI\n\ttristate \"support SPI bus connection\"\n\tdepends on INPUT_ADXL34X && SPI\n\tdefault y\n\thelp\n\t  Say Y here if you have ADXL345/6 hooked to a SPI bus.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called adxl34x-spi.\n\nconfig INPUT_IBM_PANEL\n\ttristate \"IBM Operation Panel driver\"\n\tdepends on I2C && I2C_SLAVE\n\thelp\n\t  Say Y here if you have an IBM Operation Panel connected to your system\n\t  over I2C. The panel is typically connected only to a system's service\n\t  processor (BMC).\n\n\t  If unsure, say N.\n\n\t  The Operation Panel is a controller with some buttons and an LCD\n\t  display that allows someone with physical access to the system to\n\t  perform various administrative tasks. This driver only supports the part\n\t  of the controller that sends commands to the system.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called ibm-panel.\n\nconfig INPUT_IMS_PCU\n\ttristate \"IMS Passenger Control Unit driver\"\n\tdepends on USB\n\tdepends on LEDS_CLASS\n\thelp\n\t  Say Y here if you have system with IMS Rave Passenger Control Unit.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called ims_pcu.\n\nconfig INPUT_IQS269A\n\ttristate \"Azoteq IQS269A capacitive touch controller\"\n\tdepends on I2C\n\tselect REGMAP_I2C\n\thelp\n\t  Say Y to enable support for the Azoteq IQS269A capacitive\n\t  touch controller.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called iqs269a.\n\nconfig INPUT_IQS626A\n\ttristate \"Azoteq IQS626A capacitive touch controller\"\n\tdepends on I2C\n\tselect REGMAP_I2C\n\thelp\n\t  Say Y to enable support for the Azoteq IQS626A capacitive\n\t  touch controller.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called iqs626a.\n\nconfig INPUT_IQS7222\n\ttristate \"Azoteq IQS7222A/B/C/D capacitive touch controller\"\n\tdepends on I2C\n\thelp\n\t  Say Y to enable support for the Azoteq IQS7222A/B/C/D family\n\t  of capacitive touch controllers.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called iqs7222.\n\nconfig INPUT_CMA3000\n\ttristate \"VTI CMA3000 Tri-axis accelerometer\"\n\thelp\n\t  Say Y here if you want to use VTI CMA3000_D0x Accelerometer\n\t  driver\n\n\t  This driver currently only supports I2C interface to the\n\t  controller. Also select the I2C method.\n\n\t  If unsure, say N\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cma3000_d0x.\n\nconfig INPUT_CMA3000_I2C\n\ttristate \"Support I2C bus connection\"\n\tdepends on INPUT_CMA3000 && I2C\n\thelp\n\t  Say Y here if you want to use VTI CMA3000_D0x Accelerometer\n\t  through I2C interface.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cma3000_d0x_i2c.\n\nconfig INPUT_XEN_KBDDEV_FRONTEND\n\ttristate \"Xen virtual keyboard and mouse support\"\n\tdepends on XEN\n\tdefault y\n\tselect XEN_XENBUS_FRONTEND\n\thelp\n\t  This driver implements the front-end of the Xen virtual\n\t  keyboard and mouse device driver.  It communicates with a back-end\n\t  in another domain.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called xen-kbdfront.\n\nconfig INPUT_IDEAPAD_SLIDEBAR\n\ttristate \"IdeaPad Laptop Slidebar\"\n\tdepends on INPUT\n\tdepends on SERIO_I8042\n\thelp\n\t  Say Y here if you have an IdeaPad laptop with a slidebar.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called ideapad_slidebar.\n\nconfig INPUT_SOC_BUTTON_ARRAY\n\ttristate \"Windows-compatible SoC Button Array\"\n\tdepends on KEYBOARD_GPIO && ACPI\n\thelp\n\t  Say Y here if you have a SoC-based tablet that originally runs\n\t  Windows 8 or a Microsoft Surface Book 2, Pro 5, Laptop 1 or later.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called soc_button_array.\n\nconfig INPUT_DRV260X_HAPTICS\n\ttristate \"TI DRV260X haptics support\"\n\tdepends on INPUT && I2C\n\tdepends on GPIOLIB || COMPILE_TEST\n\tselect INPUT_FF_MEMLESS\n\tselect REGMAP_I2C\n\thelp\n\t  Say Y to enable support for the TI DRV260X haptics driver.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called drv260x-haptics.\n\nconfig INPUT_DRV2665_HAPTICS\n\ttristate \"TI DRV2665 haptics support\"\n\tdepends on INPUT && I2C\n\tselect INPUT_FF_MEMLESS\n\tselect REGMAP_I2C\n\thelp\n\t  Say Y to enable support for the TI DRV2665 haptics driver.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called drv2665-haptics.\n\nconfig INPUT_DRV2667_HAPTICS\n\ttristate \"TI DRV2667 haptics support\"\n\tdepends on INPUT && I2C\n\tselect INPUT_FF_MEMLESS\n\tselect REGMAP_I2C\n\thelp\n\t  Say Y to enable support for the TI DRV2667 haptics driver.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called drv2667-haptics.\n\nconfig INPUT_HISI_POWERKEY\n\ttristate \"Hisilicon PMIC ONKEY support\"\n\tdepends on ARCH_HISI || COMPILE_TEST\n\thelp\n\t  Say Y to enable support for PMIC ONKEY.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called hisi_powerkey.\n\nconfig INPUT_RAVE_SP_PWRBUTTON\n\ttristate \"RAVE SP Power button Driver\"\n\tdepends on RAVE_SP_CORE\n\thelp\n\t  Say Y here if you want to enable power key reporting from RAVE SP\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called rave-sp-pwrbutton.\n\nconfig INPUT_SC27XX_VIBRA\n\ttristate \"Spreadtrum sc27xx vibrator support\"\n\tdepends on MFD_SC27XX_PMIC || COMPILE_TEST\n\tselect INPUT_FF_MEMLESS\n\thelp\n\t  This option enables support for Spreadtrum sc27xx vibrator driver.\n\n\t  To compile this driver as a module, choose M here. The module will\n\t  be called sc27xx_vibra.\n\nconfig INPUT_RT5120_PWRKEY\n\ttristate \"RT5120 PMIC power key support\"\n\tdepends on MFD_RT5120 || COMPILE_TEST\n\thelp\n\t  This enables support for RT5120 PMIC power key driver.\n\n\t  To compile this driver as a module, choose M here. the module will\n\t  be called rt5120-pwrkey.\n\nconfig INPUT_STPMIC1_ONKEY\n\ttristate \"STPMIC1 PMIC Onkey support\"\n\tdepends on MFD_STPMIC1\n\thelp\n\t  Say Y to enable support of onkey embedded into STPMIC1 PMIC. onkey\n\t  can be used to wakeup from low power modes and force a shut-down on\n\t  long press.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called stpmic1_onkey.\n\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}