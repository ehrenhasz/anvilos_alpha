{
  "module_name": "wm831x-on.c",
  "hash_id": "bc030020925d9290444765d79e2f76c62bbcf675c81212b59cc9fec8d5a8a974",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/wm831x-on.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/mfd/wm831x/core.h>\n\nstruct wm831x_on {\n\tstruct input_dev *dev;\n\tstruct delayed_work work;\n\tstruct wm831x *wm831x;\n};\n\n \nstatic void wm831x_poll_on(struct work_struct *work)\n{\n\tstruct wm831x_on *wm831x_on = container_of(work, struct wm831x_on,\n\t\t\t\t\t\t   work.work);\n\tstruct wm831x *wm831x = wm831x_on->wm831x;\n\tint poll, ret;\n\n\tret = wm831x_reg_read(wm831x, WM831X_ON_PIN_CONTROL);\n\tif (ret >= 0) {\n\t\tpoll = !(ret & WM831X_ON_PIN_STS);\n\n\t\tinput_report_key(wm831x_on->dev, KEY_POWER, poll);\n\t\tinput_sync(wm831x_on->dev);\n\t} else {\n\t\tdev_err(wm831x->dev, \"Failed to read ON status: %d\\n\", ret);\n\t\tpoll = 1;\n\t}\n\n\tif (poll)\n\t\tschedule_delayed_work(&wm831x_on->work, 100);\n}\n\nstatic irqreturn_t wm831x_on_irq(int irq, void *data)\n{\n\tstruct wm831x_on *wm831x_on = data;\n\n\tschedule_delayed_work(&wm831x_on->work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wm831x_on_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_on *wm831x_on;\n\tint irq = wm831x_irq(wm831x, platform_get_irq(pdev, 0));\n\tint ret;\n\n\twm831x_on = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_on),\n\t\t\t\t GFP_KERNEL);\n\tif (!wm831x_on) {\n\t\tdev_err(&pdev->dev, \"Can't allocate data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twm831x_on->wm831x = wm831x;\n\tINIT_DELAYED_WORK(&wm831x_on->work, wm831x_poll_on);\n\n\twm831x_on->dev = devm_input_allocate_device(&pdev->dev);\n\tif (!wm831x_on->dev) {\n\t\tdev_err(&pdev->dev, \"Can't allocate input dev\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twm831x_on->dev->evbit[0] = BIT_MASK(EV_KEY);\n\twm831x_on->dev->keybit[BIT_WORD(KEY_POWER)] = BIT_MASK(KEY_POWER);\n\twm831x_on->dev->name = \"wm831x_on\";\n\twm831x_on->dev->phys = \"wm831x_on/input0\";\n\twm831x_on->dev->dev.parent = &pdev->dev;\n\n\tret = request_threaded_irq(irq, NULL, wm831x_on_irq,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t   \"wm831x_on\",\n\t\t\t\t   wm831x_on);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to request IRQ: %d\\n\", ret);\n\t\tgoto err_input_dev;\n\t}\n\tret = input_register_device(wm831x_on->dev);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"Can't register input device: %d\\n\", ret);\n\t\tgoto err_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, wm831x_on);\n\n\treturn 0;\n\nerr_irq:\n\tfree_irq(irq, wm831x_on);\nerr_input_dev:\nerr:\n\treturn ret;\n}\n\nstatic int wm831x_on_remove(struct platform_device *pdev)\n{\n\tstruct wm831x_on *wm831x_on = platform_get_drvdata(pdev);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tfree_irq(irq, wm831x_on);\n\tcancel_delayed_work_sync(&wm831x_on->work);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wm831x_on_driver = {\n\t.probe\t\t= wm831x_on_probe,\n\t.remove\t\t= wm831x_on_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-on\",\n\t},\n};\nmodule_platform_driver(wm831x_on_driver);\n\nMODULE_ALIAS(\"platform:wm831x-on\");\nMODULE_DESCRIPTION(\"WM831x ON pin\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}