{
  "module_name": "da9052_onkey.c",
  "hash_id": "aa70df915cd47c42cc66c480abba19dcd509777063ea95310078da936ebff3df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/da9052_onkey.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/reg.h>\n\nstruct da9052_onkey {\n\tstruct da9052 *da9052;\n\tstruct input_dev *input;\n\tstruct delayed_work work;\n};\n\nstatic void da9052_onkey_query(struct da9052_onkey *onkey)\n{\n\tint ret;\n\n\tret = da9052_reg_read(onkey->da9052, DA9052_STATUS_A_REG);\n\tif (ret < 0) {\n\t\tdev_err(onkey->da9052->dev,\n\t\t\t\"Failed to read onkey event err=%d\\n\", ret);\n\t} else {\n\t\t \n\t\tbool pressed = !(ret & DA9052_STATUSA_NONKEY);\n\n\t\tinput_report_key(onkey->input, KEY_POWER, pressed);\n\t\tinput_sync(onkey->input);\n\n\t\t \n\t\tif (pressed)\n\t\t\tschedule_delayed_work(&onkey->work,\n\t\t\t\t\t\tmsecs_to_jiffies(50));\n\t}\n}\n\nstatic void da9052_onkey_work(struct work_struct *work)\n{\n\tstruct da9052_onkey *onkey = container_of(work, struct da9052_onkey,\n\t\t\t\t\t\t  work.work);\n\n\tda9052_onkey_query(onkey);\n}\n\nstatic irqreturn_t da9052_onkey_irq(int irq, void *data)\n{\n\tstruct da9052_onkey *onkey = data;\n\n\tda9052_onkey_query(onkey);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da9052_onkey_probe(struct platform_device *pdev)\n{\n\tstruct da9052 *da9052 = dev_get_drvdata(pdev->dev.parent);\n\tstruct da9052_onkey *onkey;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tif (!da9052) {\n\t\tdev_err(&pdev->dev, \"Failed to get the driver's data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tonkey = kzalloc(sizeof(*onkey), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!onkey || !input_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tonkey->input = input_dev;\n\tonkey->da9052 = da9052;\n\tINIT_DELAYED_WORK(&onkey->work, da9052_onkey_work);\n\n\tinput_dev->name = \"da9052-onkey\";\n\tinput_dev->phys = \"da9052-onkey/input0\";\n\tinput_dev->dev.parent = &pdev->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\t__set_bit(KEY_POWER, input_dev->keybit);\n\n\terror = da9052_request_irq(onkey->da9052, DA9052_IRQ_NONKEY, \"ONKEY\",\n\t\t\t    da9052_onkey_irq, onkey);\n\tif (error < 0) {\n\t\tdev_err(onkey->da9052->dev,\n\t\t\t\"Failed to register ONKEY IRQ: %d\\n\", error);\n\t\tgoto err_free_mem;\n\t}\n\n\terror = input_register_device(onkey->input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Unable to register input device, %d\\n\",\n\t\t\terror);\n\t\tgoto err_free_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, onkey);\n\treturn 0;\n\nerr_free_irq:\n\tda9052_free_irq(onkey->da9052, DA9052_IRQ_NONKEY, onkey);\n\tcancel_delayed_work_sync(&onkey->work);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(onkey);\n\n\treturn error;\n}\n\nstatic int da9052_onkey_remove(struct platform_device *pdev)\n{\n\tstruct da9052_onkey *onkey = platform_get_drvdata(pdev);\n\n\tda9052_free_irq(onkey->da9052, DA9052_IRQ_NONKEY, onkey);\n\tcancel_delayed_work_sync(&onkey->work);\n\n\tinput_unregister_device(onkey->input);\n\tkfree(onkey);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9052_onkey_driver = {\n\t.probe\t= da9052_onkey_probe,\n\t.remove\t= da9052_onkey_remove,\n\t.driver = {\n\t\t.name\t= \"da9052-onkey\",\n\t},\n};\nmodule_platform_driver(da9052_onkey_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"Onkey driver for DA9052\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-onkey\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}