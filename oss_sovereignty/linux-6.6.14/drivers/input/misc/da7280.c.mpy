{
  "module_name": "da7280.c",
  "hash_id": "4290ec06f6fd7c7f12a1b0b4e90b52c87d37bc10e50c72db0c0b31d76310e189",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/da7280.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/workqueue.h>\n#include <linux/uaccess.h>\n\n \n#define DA7280_IRQ_EVENT1\t\t\t0x03\n#define DA7280_IRQ_EVENT_WARNING_DIAG\t\t0x04\n#define DA7280_IRQ_EVENT_SEQ_DIAG\t\t0x05\n#define DA7280_IRQ_STATUS1\t\t\t0x06\n#define DA7280_IRQ_MASK1\t\t\t0x07\n#define DA7280_FRQ_LRA_PER_H\t\t\t0x0A\n#define DA7280_FRQ_LRA_PER_L\t\t\t0x0B\n#define DA7280_ACTUATOR1\t\t\t0x0C\n#define DA7280_ACTUATOR2\t\t\t0x0D\n#define DA7280_ACTUATOR3\t\t\t0x0E\n#define DA7280_CALIB_V2I_H\t\t\t0x0F\n#define DA7280_CALIB_V2I_L\t\t\t0x10\n#define DA7280_TOP_CFG1\t\t\t\t0x13\n#define DA7280_TOP_CFG2\t\t\t\t0x14\n#define DA7280_TOP_CFG4\t\t\t\t0x16\n#define DA7280_TOP_INT_CFG1\t\t\t0x17\n#define DA7280_TOP_CTL1\t\t\t\t0x22\n#define DA7280_TOP_CTL2\t\t\t\t0x23\n#define DA7280_SEQ_CTL2\t\t\t\t0x28\n#define DA7280_GPI_0_CTL\t\t\t0x29\n#define DA7280_GPI_1_CTL\t\t\t0x2A\n#define DA7280_GPI_2_CTL\t\t\t0x2B\n#define DA7280_MEM_CTL1\t\t\t\t0x2C\n#define DA7280_MEM_CTL2\t\t\t\t0x2D\n#define DA7280_TOP_CFG5\t\t\t\t0x6E\n#define DA7280_IRQ_MASK2\t\t\t0x83\n#define DA7280_SNP_MEM_99\t\t\t0xE7\n\n \n\n \n#define DA7280_E_SEQ_CONTINUE_MASK\t\tBIT(0)\n#define DA7280_E_UVLO_MASK\t\t\tBIT(1)\n#define DA7280_E_SEQ_DONE_MASK\t\t\tBIT(2)\n#define DA7280_E_OVERTEMP_CRIT_MASK\t\tBIT(3)\n#define DA7280_E_SEQ_FAULT_MASK\t\t\tBIT(4)\n#define DA7280_E_WARNING_MASK\t\t\tBIT(5)\n#define DA7280_E_ACTUATOR_FAULT_MASK\t\tBIT(6)\n#define DA7280_E_OC_FAULT_MASK\t\t\tBIT(7)\n\n \n#define DA7280_E_OVERTEMP_WARN_MASK             BIT(3)\n#define DA7280_E_MEM_TYPE_MASK                  BIT(4)\n#define DA7280_E_LIM_DRIVE_ACC_MASK             BIT(6)\n#define DA7280_E_LIM_DRIVE_MASK                 BIT(7)\n\n \n#define DA7280_E_PWM_FAULT_MASK\t\t\tBIT(5)\n#define DA7280_E_MEM_FAULT_MASK\t\t\tBIT(6)\n#define DA7280_E_SEQ_ID_FAULT_MASK\t\tBIT(7)\n\n \n#define DA7280_STA_SEQ_CONTINUE_MASK\t\tBIT(0)\n#define DA7280_STA_UVLO_VBAT_OK_MASK\t\tBIT(1)\n#define DA7280_STA_SEQ_DONE_MASK\t\tBIT(2)\n#define DA7280_STA_OVERTEMP_CRIT_MASK\t\tBIT(3)\n#define DA7280_STA_SEQ_FAULT_MASK\t\tBIT(4)\n#define DA7280_STA_WARNING_MASK\t\t\tBIT(5)\n#define DA7280_STA_ACTUATOR_MASK\t\tBIT(6)\n#define DA7280_STA_OC_MASK\t\t\tBIT(7)\n\n \n#define DA7280_SEQ_CONTINUE_M_MASK\t\tBIT(0)\n#define DA7280_E_UVLO_M_MASK\t\t\tBIT(1)\n#define DA7280_SEQ_DONE_M_MASK\t\t\tBIT(2)\n#define DA7280_OVERTEMP_CRIT_M_MASK\t\tBIT(3)\n#define DA7280_SEQ_FAULT_M_MASK\t\t\tBIT(4)\n#define DA7280_WARNING_M_MASK\t\t\tBIT(5)\n#define DA7280_ACTUATOR_M_MASK\t\t\tBIT(6)\n#define DA7280_OC_M_MASK\t\t\tBIT(7)\n\n \n#define DA7280_IMAX_MASK\t\t\tGENMASK(4, 0)\n\n \n#define DA7280_AMP_PID_EN_MASK\t\t\tBIT(0)\n#define DA7280_RAPID_STOP_EN_MASK\t\tBIT(1)\n#define DA7280_ACCELERATION_EN_MASK\t\tBIT(2)\n#define DA7280_FREQ_TRACK_EN_MASK\t\tBIT(3)\n#define DA7280_BEMF_SENSE_EN_MASK\t\tBIT(4)\n#define DA7280_ACTUATOR_TYPE_MASK\t\tBIT(5)\n\n \n#define DA7280_FULL_BRAKE_THR_MASK\t\tGENMASK(3, 0)\n#define DA7280_MEM_DATA_SIGNED_MASK\t\tBIT(4)\n\n \n#define DA7280_TST_CALIB_IMPEDANCE_DIS_MASK\tBIT(6)\n#define DA7280_V2I_FACTOR_FREEZE_MASK\t\tBIT(7)\n\n \n#define DA7280_BEMF_FAULT_LIM_MASK\t\tGENMASK(1, 0)\n\n \n#define DA7280_OPERATION_MODE_MASK\t\tGENMASK(2, 0)\n#define DA7280_STANDBY_EN_MASK\t\t\tBIT(3)\n#define DA7280_SEQ_START_MASK\t\t\tBIT(4)\n\n \n#define DA7280_PS_SEQ_ID_MASK\t\t\tGENMASK(3, 0)\n#define DA7280_PS_SEQ_LOOP_MASK\t\t\tGENMASK(7, 4)\n\n \n#define DA7280_GPI0_POLARITY_MASK\t\tGENMASK(1, 0)\n#define DA7280_GPI0_MODE_MASK\t\t\tBIT(2)\n#define DA7280_GPI0_SEQUENCE_ID_MASK\t\tGENMASK(6, 3)\n\n \n#define DA7280_GPI1_POLARITY_MASK\t\tGENMASK(1, 0)\n#define DA7280_GPI1_MODE_MASK\t\t\tBIT(2)\n#define DA7280_GPI1_SEQUENCE_ID_MASK\t\tGENMASK(6, 3)\n\n \n#define DA7280_GPI2_POLARITY_MASK\t\tGENMASK(1, 0)\n#define DA7280_GPI2_MODE_MASK\t\t\tBIT(2)\n#define DA7280_GPI2_SEQUENCE_ID_MASK\t\tGENMASK(6, 3)\n\n \n#define DA7280_WAV_MEM_LOCK_MASK\t\tBIT(7)\n\n \n#define DA7280_V2I_FACTOR_OFFSET_EN_MASK\tBIT(0)\n\n \n#define DA7280_ADC_SAT_M_MASK\t\t\tBIT(7)\n\n \n\n#define DA7280_VOLTAGE_RATE_MAX\t\t\t6000000\n#define DA7280_VOLTAGE_RATE_STEP\t\t23400\n#define DA7280_NOMMAX_DFT\t\t\t0x6B\n#define DA7280_ABSMAX_DFT\t\t\t0x78\n\n#define DA7280_IMPD_MAX\t\t\t\t1500000000\n#define DA7280_IMPD_DEFAULT\t\t\t22000000\n\n#define DA7280_IMAX_DEFAULT\t\t\t0x0E\n#define DA7280_IMAX_STEP\t\t\t7200\n#define DA7280_IMAX_LIMIT\t\t\t252000\n\n#define DA7280_RESONT_FREQH_DFT\t\t\t0x39\n#define DA7280_RESONT_FREQL_DFT\t\t\t0x32\n#define DA7280_MIN_RESONAT_FREQ_HZ\t\t50\n#define DA7280_MAX_RESONAT_FREQ_HZ\t\t300\n\n#define DA7280_SEQ_ID_MAX\t\t\t15\n#define DA7280_SEQ_LOOP_MAX\t\t\t15\n#define DA7280_GPI_SEQ_ID_DFT\t\t\t0\n#define DA7280_GPI_SEQ_ID_MAX\t\t\t2\n\n#define DA7280_SNP_MEM_SIZE\t\t\t100\n#define DA7280_SNP_MEM_MAX\t\t\tDA7280_SNP_MEM_99\n\n#define DA7280_IRQ_NUM\t\t\t\t3\n\n#define DA7280_SKIP_INIT\t\t\t0x100\n\n#define DA7280_FF_EFFECT_COUNT_MAX\t\t15\n\n \n#define DA7280_MAX_MAGNITUDE_SHIFT\t\t15\n\nenum da7280_haptic_dev_t {\n\tDA7280_LRA\t= 0,\n\tDA7280_ERM_BAR\t= 1,\n\tDA7280_ERM_COIN\t= 2,\n\tDA7280_DEV_MAX,\n};\n\nenum da7280_op_mode {\n\tDA7280_INACTIVE\t\t= 0,\n\tDA7280_DRO_MODE\t\t= 1,\n\tDA7280_PWM_MODE\t\t= 2,\n\tDA7280_RTWM_MODE\t= 3,\n\tDA7280_ETWM_MODE\t= 4,\n\tDA7280_OPMODE_MAX,\n};\n\n#define DA7280_FF_CONSTANT_DRO\t\t\t1\n#define DA7280_FF_PERIODIC_PWM\t\t\t2\n#define DA7280_FF_PERIODIC_RTWM\t\t\t1\n#define DA7280_FF_PERIODIC_ETWM\t\t\t2\n\n#define DA7280_FF_PERIODIC_MODE\t\t\tDA7280_RTWM_MODE\n#define DA7280_FF_CONSTANT_MODE\t\t\tDA7280_DRO_MODE\n\nenum da7280_custom_effect_param {\n\tDA7280_CUSTOM_SEQ_ID_IDX\t= 0,\n\tDA7280_CUSTOM_SEQ_LOOP_IDX\t= 1,\n\tDA7280_CUSTOM_DATA_LEN\t\t= 2,\n};\n\nenum da7280_custom_gpi_effect_param {\n\tDA7280_CUSTOM_GPI_SEQ_ID_IDX\t= 0,\n\tDA7280_CUSTOM_GPI_NUM_IDX\t= 2,\n\tDA7280_CUSTOM_GP_DATA_LEN\t= 3,\n};\n\nstruct da7280_gpi_ctl {\n\tu8 seq_id;\n\tu8 mode;\n\tu8 polarity;\n};\n\nstruct da7280_haptic {\n\tstruct regmap *regmap;\n\tstruct input_dev *input_dev;\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tstruct pwm_device *pwm_dev;\n\n\tbool legacy;\n\tstruct work_struct work;\n\tint val;\n\tu16 gain;\n\ts16 level;\n\n\tu8 dev_type;\n\tu8 op_mode;\n\tu8 const_op_mode;\n\tu8 periodic_op_mode;\n\tu16 nommax;\n\tu16 absmax;\n\tu32 imax;\n\tu32 impd;\n\tu32 resonant_freq_h;\n\tu32 resonant_freq_l;\n\tbool bemf_sense_en;\n\tbool freq_track_en;\n\tbool acc_en;\n\tbool rapid_stop_en;\n\tbool amp_pid_en;\n\tu8 ps_seq_id;\n\tu8 ps_seq_loop;\n\tstruct da7280_gpi_ctl gpi_ctl[3];\n\tbool mem_update;\n\tu8 snp_mem[DA7280_SNP_MEM_SIZE];\n\tbool active;\n\tbool suspended;\n};\n\nstatic bool da7280_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DA7280_IRQ_EVENT1:\n\tcase DA7280_IRQ_EVENT_WARNING_DIAG:\n\tcase DA7280_IRQ_EVENT_SEQ_DIAG:\n\tcase DA7280_IRQ_STATUS1:\n\tcase DA7280_TOP_CTL1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config da7280_haptic_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = DA7280_SNP_MEM_MAX,\n\t.volatile_reg = da7280_volatile_register,\n};\n\nstatic int da7280_haptic_mem_update(struct da7280_haptic *haptics)\n{\n\tunsigned int val;\n\tint error;\n\n\t \n\terror = regmap_read(haptics->regmap, DA7280_IRQ_STATUS1, &val);\n\tif (error)\n\t\treturn error;\n\tif (val & DA7280_STA_WARNING_MASK) {\n\t\tdev_warn(haptics->dev,\n\t\t\t \"Warning! Please check HAPTIC status.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tval = 0;\n\terror = regmap_read(haptics->regmap, DA7280_MEM_CTL2, &val);\n\tif (error)\n\t\treturn error;\n\tif (~val & DA7280_WAV_MEM_LOCK_MASK) {\n\t\tdev_warn(haptics->dev, \"Please unlock the bit first\\n\");\n\t\treturn -EACCES;\n\t}\n\n\t \n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t   DA7280_OPERATION_MODE_MASK,\n\t\t\t\t   0);\n\tif (error)\n\t\treturn error;\n\n\terror = regmap_read(haptics->regmap, DA7280_MEM_CTL1, &val);\n\tif (error)\n\t\treturn error;\n\n\treturn regmap_bulk_write(haptics->regmap, val, haptics->snp_mem,\n\t\t\t\t DA7280_SNP_MEM_MAX - val + 1);\n}\n\nstatic int da7280_haptic_set_pwm(struct da7280_haptic *haptics, bool enabled)\n{\n\tstruct pwm_state state;\n\tu64 period_mag_multi;\n\tint error;\n\n\tif (!haptics->gain && enabled) {\n\t\tdev_err(haptics->dev, \"Unable to enable pwm with 0 gain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpwm_get_state(haptics->pwm_dev, &state);\n\tstate.enabled = enabled;\n\tif (enabled) {\n\t\tperiod_mag_multi = (u64)state.period * haptics->gain;\n\t\tperiod_mag_multi >>= DA7280_MAX_MAGNITUDE_SHIFT;\n\n\t\t \n\t\tif (!haptics->acc_en) {\n\t\t\tperiod_mag_multi += state.period;\n\t\t\tperiod_mag_multi /= 2;\n\t\t}\n\n\t\tstate.duty_cycle = period_mag_multi;\n\t}\n\n\terror = pwm_apply_state(haptics->pwm_dev, &state);\n\tif (error)\n\t\tdev_err(haptics->dev, \"Failed to apply pwm state: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic void da7280_haptic_activate(struct da7280_haptic *haptics)\n{\n\tint error;\n\n\tif (haptics->active)\n\t\treturn;\n\n\tswitch (haptics->op_mode) {\n\tcase DA7280_DRO_MODE:\n\t\t \n\t\tif (haptics->acc_en && haptics->level > 0x7F)\n\t\t\thaptics->level = 0x7F;\n\t\telse if (haptics->level > 0xFF)\n\t\t\thaptics->level = 0xFF;\n\n\t\t \n\t\terror = regmap_write(haptics->regmap, DA7280_TOP_CTL2,\n\t\t\t\t     haptics->level);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to set level to %d: %d\\n\",\n\t\t\t\thaptics->level, error);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase DA7280_PWM_MODE:\n\t\tif (da7280_haptic_set_pwm(haptics, true))\n\t\t\treturn;\n\t\tbreak;\n\n\tcase DA7280_RTWM_MODE:\n\t\t \n\t\tbreak;\n\n\tcase DA7280_ETWM_MODE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(haptics->dev, \"Invalid op mode %d\\n\", haptics->op_mode);\n\t\treturn;\n\t}\n\n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t   DA7280_OPERATION_MODE_MASK,\n\t\t\t\t   haptics->op_mode);\n\tif (error) {\n\t\tdev_err(haptics->dev,\n\t\t\t\"Failed to set operation mode: %d\", error);\n\t\treturn;\n\t}\n\n\tif (haptics->op_mode == DA7280_PWM_MODE ||\n\t    haptics->op_mode == DA7280_RTWM_MODE) {\n\t\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t\t   DA7280_SEQ_START_MASK,\n\t\t\t\t\t   DA7280_SEQ_START_MASK);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to start sequence: %d\\n\", error);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thaptics->active = true;\n}\n\nstatic void da7280_haptic_deactivate(struct da7280_haptic *haptics)\n{\n\tint error;\n\n\tif (!haptics->active)\n\t\treturn;\n\n\t \n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t   DA7280_OPERATION_MODE_MASK, 0);\n\tif (error) {\n\t\tdev_err(haptics->dev,\n\t\t\t\"Failed to clear operation mode: %d\", error);\n\t\treturn;\n\t}\n\n\tswitch (haptics->op_mode) {\n\tcase DA7280_DRO_MODE:\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\t     DA7280_TOP_CTL2, 0);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to disable DRO mode: %d\\n\", error);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase DA7280_PWM_MODE:\n\t\tif (da7280_haptic_set_pwm(haptics, false))\n\t\t\treturn;\n\t\tbreak;\n\n\tcase DA7280_RTWM_MODE:\n\tcase DA7280_ETWM_MODE:\n\t\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t\t   DA7280_SEQ_START_MASK, 0);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to disable RTWM/ETWM mode: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(haptics->dev, \"Invalid op mode %d\\n\", haptics->op_mode);\n\t\treturn;\n\t}\n\n\thaptics->active = false;\n}\n\nstatic void da7280_haptic_work(struct work_struct *work)\n{\n\tstruct da7280_haptic *haptics =\n\t\tcontainer_of(work, struct da7280_haptic, work);\n\tint val = haptics->val;\n\n\tif (val)\n\t\tda7280_haptic_activate(haptics);\n\telse\n\t\tda7280_haptic_deactivate(haptics);\n}\n\nstatic int da7280_haptics_upload_effect(struct input_dev *dev,\n\t\t\t\t\tstruct ff_effect *effect,\n\t\t\t\t\tstruct ff_effect *old)\n{\n\tstruct da7280_haptic *haptics = input_get_drvdata(dev);\n\ts16 data[DA7280_SNP_MEM_SIZE] = { 0 };\n\tunsigned int val;\n\tint tmp, i, num;\n\tint error;\n\n\t \n\tif (haptics->active)\n\t\treturn -EBUSY;\n\n\tswitch (effect->type) {\n\t \n\tcase FF_CONSTANT:\n\t\thaptics->op_mode = haptics->const_op_mode;\n\t\tif (haptics->op_mode == DA7280_DRO_MODE) {\n\t\t\ttmp = effect->u.constant.level * 254;\n\t\t\thaptics->level = tmp / 0x7FFF;\n\t\t\tbreak;\n\t\t}\n\n\t\thaptics->gain =\teffect->u.constant.level <= 0 ?\n\t\t\t\t\t0 : effect->u.constant.level;\n\t\tbreak;\n\n\t \n\tcase FF_PERIODIC:\n\t\tif (effect->u.periodic.waveform != FF_CUSTOM) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Device can only accept FF_CUSTOM waveform\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (effect->u.periodic.custom_len == DA7280_CUSTOM_DATA_LEN)\n\t\t\tgoto set_seq_id_loop;\n\n\t\tif (effect->u.periodic.custom_len == DA7280_CUSTOM_GP_DATA_LEN)\n\t\t\tgoto set_gpix_seq_id;\n\n\t\tif (effect->u.periodic.custom_len < DA7280_CUSTOM_DATA_LEN ||\n\t\t    effect->u.periodic.custom_len > DA7280_SNP_MEM_SIZE) {\n\t\t\tdev_err(haptics->dev, \"Invalid waveform data size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (copy_from_user(data, effect->u.periodic.custom_data,\n\t\t\t\t   sizeof(s16) *\n\t\t\t\t   effect->u.periodic.custom_len))\n\t\t\treturn -EFAULT;\n\n\t\tmemset(haptics->snp_mem, 0, DA7280_SNP_MEM_SIZE);\n\n\t\tfor (i = 0; i < effect->u.periodic.custom_len; i++) {\n\t\t\tif (data[i] < 0 || data[i] > 0xff) {\n\t\t\t\tdev_err(haptics->dev,\n\t\t\t\t\t\"Invalid waveform data %d at offset %d\\n\",\n\t\t\t\t\tdata[i], i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\thaptics->snp_mem[i] = (u8)data[i];\n\t\t}\n\n\t\terror = da7280_haptic_mem_update(haptics);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to upload waveform: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t\tbreak;\n\nset_seq_id_loop:\n\t\tif (copy_from_user(data, effect->u.periodic.custom_data,\n\t\t\t\t   sizeof(s16) * DA7280_CUSTOM_DATA_LEN))\n\t\t\treturn -EFAULT;\n\n\t\tif (data[DA7280_CUSTOM_SEQ_ID_IDX] < 0 ||\n\t\t    data[DA7280_CUSTOM_SEQ_ID_IDX] > DA7280_SEQ_ID_MAX ||\n\t\t    data[DA7280_CUSTOM_SEQ_LOOP_IDX] < 0 ||\n\t\t    data[DA7280_CUSTOM_SEQ_LOOP_IDX] > DA7280_SEQ_LOOP_MAX) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Invalid custom id (%d) or loop (%d)\\n\",\n\t\t\t\tdata[DA7280_CUSTOM_SEQ_ID_IDX],\n\t\t\t\tdata[DA7280_CUSTOM_SEQ_LOOP_IDX]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thaptics->ps_seq_id = data[DA7280_CUSTOM_SEQ_ID_IDX] & 0x0f;\n\t\thaptics->ps_seq_loop = data[DA7280_CUSTOM_SEQ_LOOP_IDX] & 0x0f;\n\t\thaptics->op_mode = haptics->periodic_op_mode;\n\n\t\tval = FIELD_PREP(DA7280_PS_SEQ_ID_MASK, haptics->ps_seq_id) |\n\t\t\tFIELD_PREP(DA7280_PS_SEQ_LOOP_MASK,\n\t\t\t\t   haptics->ps_seq_loop);\n\t\terror = regmap_write(haptics->regmap, DA7280_SEQ_CTL2, val);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to update PS sequence: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t\tbreak;\n\nset_gpix_seq_id:\n\t\tif (copy_from_user(data, effect->u.periodic.custom_data,\n\t\t\t\t   sizeof(s16) * DA7280_CUSTOM_GP_DATA_LEN))\n\t\t\treturn -EFAULT;\n\n\t\tif (data[DA7280_CUSTOM_GPI_SEQ_ID_IDX] < 0 ||\n\t\t    data[DA7280_CUSTOM_GPI_SEQ_ID_IDX] > DA7280_SEQ_ID_MAX ||\n\t\t    data[DA7280_CUSTOM_GPI_NUM_IDX] < 0 ||\n\t\t    data[DA7280_CUSTOM_GPI_NUM_IDX] > DA7280_GPI_SEQ_ID_MAX) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Invalid custom GPI id (%d) or num (%d)\\n\",\n\t\t\t\tdata[DA7280_CUSTOM_GPI_SEQ_ID_IDX],\n\t\t\t\tdata[DA7280_CUSTOM_GPI_NUM_IDX]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum = data[DA7280_CUSTOM_GPI_NUM_IDX] & 0x0f;\n\t\thaptics->gpi_ctl[num].seq_id =\n\t\t\tdata[DA7280_CUSTOM_GPI_SEQ_ID_IDX] & 0x0f;\n\t\thaptics->op_mode = haptics->periodic_op_mode;\n\n\t\tval = FIELD_PREP(DA7280_GPI0_SEQUENCE_ID_MASK,\n\t\t\t\t haptics->gpi_ctl[num].seq_id);\n\t\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t\t   DA7280_GPI_0_CTL + num,\n\t\t\t\t\t   DA7280_GPI0_SEQUENCE_ID_MASK,\n\t\t\t\t\t   val);\n\t\tif (error) {\n\t\t\tdev_err(haptics->dev,\n\t\t\t\t\"Failed to update GPI sequence: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(haptics->dev, \"Unsupported effect type: %d\\n\",\n\t\t\teffect->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int da7280_haptics_playback(struct input_dev *dev,\n\t\t\t\t   int effect_id, int val)\n{\n\tstruct da7280_haptic *haptics = input_get_drvdata(dev);\n\n\tif (!haptics->op_mode) {\n\t\tdev_warn(haptics->dev, \"No effects have been uploaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (likely(!haptics->suspended)) {\n\t\thaptics->val = val;\n\t\tschedule_work(&haptics->work);\n\t}\n\n\treturn 0;\n}\n\nstatic int da7280_haptic_start(struct da7280_haptic *haptics)\n{\n\tint error;\n\n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t   DA7280_STANDBY_EN_MASK,\n\t\t\t\t   DA7280_STANDBY_EN_MASK);\n\tif (error) {\n\t\tdev_err(haptics->dev, \"Unable to enable device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void da7280_haptic_stop(struct da7280_haptic *haptics)\n{\n\tint error;\n\n\tcancel_work_sync(&haptics->work);\n\n\n\tda7280_haptic_deactivate(haptics);\n\n\terror = regmap_update_bits(haptics->regmap, DA7280_TOP_CTL1,\n\t\t\t\t   DA7280_STANDBY_EN_MASK, 0);\n\tif (error)\n\t\tdev_err(haptics->dev, \"Failed to disable device: %d\\n\", error);\n}\n\nstatic int da7280_haptic_open(struct input_dev *dev)\n{\n\tstruct da7280_haptic *haptics = input_get_drvdata(dev);\n\n\treturn da7280_haptic_start(haptics);\n}\n\nstatic void da7280_haptic_close(struct input_dev *dev)\n{\n\tstruct da7280_haptic *haptics = input_get_drvdata(dev);\n\n\tda7280_haptic_stop(haptics);\n}\n\nstatic u8 da7280_haptic_of_mode_str(struct device *dev,\n\t\t\t\t    const char *str)\n{\n\tif (!strcmp(str, \"LRA\")) {\n\t\treturn DA7280_LRA;\n\t} else if (!strcmp(str, \"ERM-bar\")) {\n\t\treturn DA7280_ERM_BAR;\n\t} else if (!strcmp(str, \"ERM-coin\")) {\n\t\treturn DA7280_ERM_COIN;\n\t} else {\n\t\tdev_warn(dev, \"Invalid string - set to LRA\\n\");\n\t\treturn DA7280_LRA;\n\t}\n}\n\nstatic u8 da7280_haptic_of_gpi_mode_str(struct device *dev,\n\t\t\t\t\tconst char *str)\n{\n\tif (!strcmp(str, \"Single-pattern\")) {\n\t\treturn 0;\n\t} else if (!strcmp(str, \"Multi-pattern\")) {\n\t\treturn 1;\n\t} else {\n\t\tdev_warn(dev, \"Invalid string - set to Single-pattern\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic u8 da7280_haptic_of_gpi_pol_str(struct device *dev,\n\t\t\t\t       const char *str)\n{\n\tif (!strcmp(str, \"Rising-edge\")) {\n\t\treturn 0;\n\t} else if (!strcmp(str, \"Falling-edge\")) {\n\t\treturn 1;\n\t} else if (!strcmp(str, \"Both-edge\")) {\n\t\treturn 2;\n\t} else {\n\t\tdev_warn(dev, \"Invalid string - set to Rising-edge\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic u8 da7280_haptic_of_volt_rating_set(u32 val)\n{\n\tu32 voltage = val / DA7280_VOLTAGE_RATE_STEP + 1;\n\n\treturn min_t(u32, voltage, 0xff);\n}\n\nstatic void da7280_parse_properties(struct device *dev,\n\t\t\t\t    struct da7280_haptic *haptics)\n{\n\tunsigned int i, mem[DA7280_SNP_MEM_SIZE];\n\tchar gpi_str1[] = \"dlg,gpi0-seq-id\";\n\tchar gpi_str2[] = \"dlg,gpi0-mode\";\n\tchar gpi_str3[] = \"dlg,gpi0-polarity\";\n\tconst char *str;\n\tu32 val;\n\tint error;\n\n\t \n\thaptics->dev_type = DA7280_DEV_MAX;\n\terror = device_property_read_string(dev, \"dlg,actuator-type\", &str);\n\tif (!error)\n\t\thaptics->dev_type = da7280_haptic_of_mode_str(dev, str);\n\n\thaptics->const_op_mode = DA7280_DRO_MODE;\n\terror = device_property_read_u32(dev, \"dlg,const-op-mode\", &val);\n\tif (!error && val == DA7280_FF_PERIODIC_PWM)\n\t\thaptics->const_op_mode = DA7280_PWM_MODE;\n\n\thaptics->periodic_op_mode = DA7280_RTWM_MODE;\n\terror = device_property_read_u32(dev, \"dlg,periodic-op-mode\", &val);\n\tif (!error && val == DA7280_FF_PERIODIC_ETWM)\n\t\thaptics->periodic_op_mode = DA7280_ETWM_MODE;\n\n\thaptics->nommax = DA7280_SKIP_INIT;\n\terror = device_property_read_u32(dev, \"dlg,nom-microvolt\", &val);\n\tif (!error && val < DA7280_VOLTAGE_RATE_MAX)\n\t\thaptics->nommax = da7280_haptic_of_volt_rating_set(val);\n\n\thaptics->absmax = DA7280_SKIP_INIT;\n\terror = device_property_read_u32(dev, \"dlg,abs-max-microvolt\", &val);\n\tif (!error && val < DA7280_VOLTAGE_RATE_MAX)\n\t\thaptics->absmax = da7280_haptic_of_volt_rating_set(val);\n\n\thaptics->imax = DA7280_IMAX_DEFAULT;\n\terror = device_property_read_u32(dev, \"dlg,imax-microamp\", &val);\n\tif (!error && val < DA7280_IMAX_LIMIT)\n\t\thaptics->imax = (val - 28600) / DA7280_IMAX_STEP + 1;\n\n\thaptics->impd = DA7280_IMPD_DEFAULT;\n\terror = device_property_read_u32(dev, \"dlg,impd-micro-ohms\", &val);\n\tif (!error && val <= DA7280_IMPD_MAX)\n\t\thaptics->impd = val;\n\n\thaptics->resonant_freq_h = DA7280_SKIP_INIT;\n\thaptics->resonant_freq_l = DA7280_SKIP_INIT;\n\terror = device_property_read_u32(dev, \"dlg,resonant-freq-hz\", &val);\n\tif (!error) {\n\t\tif (val < DA7280_MAX_RESONAT_FREQ_HZ &&\n\t\t    val > DA7280_MIN_RESONAT_FREQ_HZ) {\n\t\t\thaptics->resonant_freq_h =\n\t\t\t\t((1000000000 / (val * 1333)) >> 7) & 0xFF;\n\t\t\thaptics->resonant_freq_l =\n\t\t\t\t(1000000000 / (val * 1333)) & 0x7F;\n\t\t} else {\n\t\t\thaptics->resonant_freq_h = DA7280_RESONT_FREQH_DFT;\n\t\t\thaptics->resonant_freq_l = DA7280_RESONT_FREQL_DFT;\n\t\t}\n\t}\n\n\t \n\thaptics->ps_seq_id = 0;\n\terror = device_property_read_u32(dev, \"dlg,ps-seq-id\", &val);\n\tif (!error && val <= DA7280_SEQ_ID_MAX)\n\t\thaptics->ps_seq_id = val;\n\n\thaptics->ps_seq_loop = 0;\n\terror = device_property_read_u32(dev, \"dlg,ps-seq-loop\", &val);\n\tif (!error && val <= DA7280_SEQ_LOOP_MAX)\n\t\thaptics->ps_seq_loop = val;\n\n\t \n\tfor (i = 0; i <= DA7280_GPI_SEQ_ID_MAX; i++) {\n\t\tgpi_str1[7] = '0' + i;\n\t\thaptics->gpi_ctl[i].seq_id = DA7280_GPI_SEQ_ID_DFT + i;\n\t\terror = device_property_read_u32 (dev, gpi_str1, &val);\n\t\tif (!error && val <= DA7280_SEQ_ID_MAX)\n\t\t\thaptics->gpi_ctl[i].seq_id = val;\n\n\t\tgpi_str2[7] = '0' + i;\n\t\thaptics->gpi_ctl[i].mode = 0;\n\t\terror = device_property_read_string(dev, gpi_str2, &str);\n\t\tif (!error)\n\t\t\thaptics->gpi_ctl[i].mode =\n\t\t\t\tda7280_haptic_of_gpi_mode_str(dev, str);\n\n\t\tgpi_str3[7] = '0' + i;\n\t\thaptics->gpi_ctl[i].polarity = 0;\n\t\terror = device_property_read_string(dev, gpi_str3, &str);\n\t\tif (!error)\n\t\t\thaptics->gpi_ctl[i].polarity =\n\t\t\t\tda7280_haptic_of_gpi_pol_str(dev, str);\n\t}\n\n\thaptics->bemf_sense_en =\n\t\tdevice_property_read_bool(dev, \"dlg,bemf-sens-enable\");\n\thaptics->freq_track_en =\n\t\tdevice_property_read_bool(dev, \"dlg,freq-track-enable\");\n\thaptics->acc_en =\n\t\tdevice_property_read_bool(dev, \"dlg,acc-enable\");\n\thaptics->rapid_stop_en =\n\t\tdevice_property_read_bool(dev, \"dlg,rapid-stop-enable\");\n\thaptics->amp_pid_en =\n\t\tdevice_property_read_bool(dev, \"dlg,amp-pid-enable\");\n\n\thaptics->mem_update = false;\n\terror = device_property_read_u32_array(dev, \"dlg,mem-array\",\n\t\t\t\t\t       &mem[0], DA7280_SNP_MEM_SIZE);\n\tif (!error) {\n\t\thaptics->mem_update = true;\n\t\tmemset(haptics->snp_mem, 0, DA7280_SNP_MEM_SIZE);\n\t\tfor (i = 0; i < DA7280_SNP_MEM_SIZE; i++) {\n\t\t\tif (mem[i] <= 0xff) {\n\t\t\t\thaptics->snp_mem[i] = (u8)mem[i];\n\t\t\t} else {\n\t\t\t\tdev_err(haptics->dev,\n\t\t\t\t\t\"Invalid data in mem-array at %d: %x\\n\",\n\t\t\t\t\ti, mem[i]);\n\t\t\t\thaptics->mem_update = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic irqreturn_t da7280_irq_handler(int irq, void *data)\n{\n\tstruct da7280_haptic *haptics = data;\n\tstruct device *dev = haptics->dev;\n\tu8 events[DA7280_IRQ_NUM];\n\tint error;\n\n\t \n\terror = regmap_bulk_read(haptics->regmap, DA7280_IRQ_EVENT1,\n\t\t\t\t events, sizeof(events));\n\tif (error) {\n\t\tdev_err(dev, \"failed to read interrupt data: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\t \n\terror = regmap_write(haptics->regmap, DA7280_IRQ_EVENT1, events[0]);\n\tif (error) {\n\t\tdev_err(dev, \"failed to clear interrupts: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tif (events[0] & DA7280_E_SEQ_FAULT_MASK) {\n\t\t \n\t\terror = regmap_update_bits(haptics->regmap, DA7280_TOP_CTL1,\n\t\t\t\t\t   DA7280_OPERATION_MODE_MASK, 0);\n\t\tif (error)\n\t\t\tdev_err(dev, \"failed to clear op mode on fault: %d\\n\",\n\t\t\t\terror);\n\t}\n\n\tif (events[0] & DA7280_E_SEQ_DONE_MASK)\n\t\thaptics->active = false;\n\n\tif (events[0] & DA7280_E_WARNING_MASK) {\n\t\tif (events[1] & DA7280_E_LIM_DRIVE_MASK ||\n\t\t    events[1] & DA7280_E_LIM_DRIVE_ACC_MASK)\n\t\t\tdev_warn(dev, \"Please reduce the driver level\\n\");\n\t\tif (events[1] & DA7280_E_MEM_TYPE_MASK)\n\t\t\tdev_warn(dev, \"Please check the mem data format\\n\");\n\t\tif (events[1] & DA7280_E_OVERTEMP_WARN_MASK)\n\t\t\tdev_warn(dev, \"Over-temperature warning\\n\");\n\t}\n\n\tif (events[0] & DA7280_E_SEQ_FAULT_MASK) {\n\t\tif (events[2] & DA7280_E_SEQ_ID_FAULT_MASK)\n\t\t\tdev_info(dev, \"Please reload PS_SEQ_ID & mem data\\n\");\n\t\tif (events[2] & DA7280_E_MEM_FAULT_MASK)\n\t\t\tdev_info(dev, \"Please reload the mem data\\n\");\n\t\tif (events[2] & DA7280_E_PWM_FAULT_MASK)\n\t\t\tdev_info(dev, \"Please restart PWM interface\\n\");\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int da7280_init(struct da7280_haptic *haptics)\n{\n\tunsigned int val = 0;\n\tu32 v2i_factor;\n\tint error, i;\n\tu8 mask = 0;\n\n\t \n\tif (haptics->dev_type == DA7280_DEV_MAX) {\n\t\terror = regmap_read(haptics->regmap, DA7280_TOP_CFG1, &val);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\thaptics->dev_type = val & DA7280_ACTUATOR_TYPE_MASK ?\n\t\t\t\t\tDA7280_ERM_COIN : DA7280_LRA;\n\t}\n\n\t \n\tif (haptics->dev_type == DA7280_LRA &&\n\t    haptics->resonant_freq_l != DA7280_SKIP_INIT) {\n\t\terror = regmap_write(haptics->regmap, DA7280_FRQ_LRA_PER_H,\n\t\t\t\t     haptics->resonant_freq_h);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\terror = regmap_write(haptics->regmap, DA7280_FRQ_LRA_PER_L,\n\t\t\t\t     haptics->resonant_freq_l);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t} else if (haptics->dev_type == DA7280_ERM_COIN) {\n\t\terror = regmap_update_bits(haptics->regmap, DA7280_TOP_INT_CFG1,\n\t\t\t\t\t   DA7280_BEMF_FAULT_LIM_MASK, 0);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\tmask = DA7280_TST_CALIB_IMPEDANCE_DIS_MASK |\n\t\t\tDA7280_V2I_FACTOR_FREEZE_MASK;\n\t\tval = DA7280_TST_CALIB_IMPEDANCE_DIS_MASK |\n\t\t\tDA7280_V2I_FACTOR_FREEZE_MASK;\n\t\terror = regmap_update_bits(haptics->regmap, DA7280_TOP_CFG4,\n\t\t\t\t\t   mask, val);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\thaptics->acc_en = false;\n\t\thaptics->rapid_stop_en = false;\n\t\thaptics->amp_pid_en = false;\n\t}\n\n\tmask = DA7280_ACTUATOR_TYPE_MASK |\n\t\t\tDA7280_BEMF_SENSE_EN_MASK |\n\t\t\tDA7280_FREQ_TRACK_EN_MASK |\n\t\t\tDA7280_ACCELERATION_EN_MASK |\n\t\t\tDA7280_RAPID_STOP_EN_MASK |\n\t\t\tDA7280_AMP_PID_EN_MASK;\n\tval = FIELD_PREP(DA7280_ACTUATOR_TYPE_MASK,\n\t\t\t (haptics->dev_type ? 1 : 0)) |\n\t\tFIELD_PREP(DA7280_BEMF_SENSE_EN_MASK,\n\t\t\t   (haptics->bemf_sense_en ? 1 : 0)) |\n\t\tFIELD_PREP(DA7280_FREQ_TRACK_EN_MASK,\n\t\t\t   (haptics->freq_track_en ? 1 : 0)) |\n\t\tFIELD_PREP(DA7280_ACCELERATION_EN_MASK,\n\t\t\t   (haptics->acc_en ? 1 : 0)) |\n\t\tFIELD_PREP(DA7280_RAPID_STOP_EN_MASK,\n\t\t\t   (haptics->rapid_stop_en ? 1 : 0)) |\n\t\tFIELD_PREP(DA7280_AMP_PID_EN_MASK,\n\t\t\t   (haptics->amp_pid_en ? 1 : 0));\n\n\terror = regmap_update_bits(haptics->regmap, DA7280_TOP_CFG1, mask, val);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(haptics->regmap, DA7280_TOP_CFG5,\n\t\t\t\t   DA7280_V2I_FACTOR_OFFSET_EN_MASK,\n\t\t\t\t   haptics->acc_en ?\n\t\t\t\t\tDA7280_V2I_FACTOR_OFFSET_EN_MASK : 0);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_TOP_CFG2,\n\t\t\t\t   DA7280_MEM_DATA_SIGNED_MASK,\n\t\t\t\t   haptics->acc_en ?\n\t\t\t\t\t0 : DA7280_MEM_DATA_SIGNED_MASK);\n\tif (error)\n\t\tgoto out_err;\n\n\tif (haptics->nommax != DA7280_SKIP_INIT) {\n\t\terror = regmap_write(haptics->regmap, DA7280_ACTUATOR1,\n\t\t\t\t     haptics->nommax);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t}\n\n\tif (haptics->absmax != DA7280_SKIP_INIT) {\n\t\terror = regmap_write(haptics->regmap, DA7280_ACTUATOR2,\n\t\t\t\t     haptics->absmax);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t}\n\n\terror = regmap_update_bits(haptics->regmap, DA7280_ACTUATOR3,\n\t\t\t\t   DA7280_IMAX_MASK, haptics->imax);\n\tif (error)\n\t\tgoto out_err;\n\n\tv2i_factor = haptics->impd * (haptics->imax + 4) / 1610400;\n\terror = regmap_write(haptics->regmap, DA7280_CALIB_V2I_L,\n\t\t\t     v2i_factor & 0xff);\n\tif (error)\n\t\tgoto out_err;\n\terror = regmap_write(haptics->regmap, DA7280_CALIB_V2I_H,\n\t\t\t     v2i_factor >> 8);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_TOP_CTL1,\n\t\t\t\t   DA7280_STANDBY_EN_MASK,\n\t\t\t\t   DA7280_STANDBY_EN_MASK);\n\tif (error)\n\t\tgoto out_err;\n\n\tif (haptics->mem_update) {\n\t\terror = da7280_haptic_mem_update(haptics);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\tval = FIELD_PREP(DA7280_PS_SEQ_ID_MASK, haptics->ps_seq_id) |\n\t\tFIELD_PREP(DA7280_PS_SEQ_LOOP_MASK, haptics->ps_seq_loop);\n\terror = regmap_write(haptics->regmap, DA7280_SEQ_CTL2, val);\n\tif (error)\n\t\tgoto out_err;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tval = FIELD_PREP(DA7280_GPI0_SEQUENCE_ID_MASK,\n\t\t\t\t haptics->gpi_ctl[i].seq_id) |\n\t\t\tFIELD_PREP(DA7280_GPI0_MODE_MASK,\n\t\t\t\t   haptics->gpi_ctl[i].mode) |\n\t\t\tFIELD_PREP(DA7280_GPI0_POLARITY_MASK,\n\t\t\t\t   haptics->gpi_ctl[i].polarity);\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\t     DA7280_GPI_0_CTL + i, val);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_IRQ_MASK2,\n\t\t\t\t   DA7280_ADC_SAT_M_MASK,\n\t\t\t\t   DA7280_ADC_SAT_M_MASK);\n\tif (error)\n\t\tgoto out_err;\n\n\t \n\terror = regmap_write(haptics->regmap, DA7280_IRQ_EVENT1, 0xff);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(haptics->regmap,\n\t\t\t\t   DA7280_IRQ_MASK1,\n\t\t\t\t   DA7280_SEQ_FAULT_M_MASK |\n\t\t\t\t\tDA7280_SEQ_DONE_M_MASK,\n\t\t\t\t   0);\n\tif (error)\n\t\tgoto out_err;\n\n\thaptics->active = false;\n\treturn 0;\n\nout_err:\n\tdev_err(haptics->dev, \"chip initialization error: %d\\n\", error);\n\treturn error;\n}\n\nstatic int da7280_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct da7280_haptic *haptics;\n\tstruct input_dev *input_dev;\n\tstruct pwm_state state;\n\tstruct ff_device *ff;\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"No IRQ configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thaptics = devm_kzalloc(dev, sizeof(*haptics), GFP_KERNEL);\n\tif (!haptics)\n\t\treturn -ENOMEM;\n\n\thaptics->dev = dev;\n\n\tda7280_parse_properties(dev, haptics);\n\n\tif (haptics->const_op_mode == DA7280_PWM_MODE) {\n\t\thaptics->pwm_dev = devm_pwm_get(dev, NULL);\n\t\terror = PTR_ERR_OR_ZERO(haptics->pwm_dev);\n\t\tif (error) {\n\t\t\tif (error != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Unable to request PWM: %d\\n\",\n\t\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tpwm_init_state(haptics->pwm_dev, &state);\n\t\tstate.enabled = false;\n\t\terror = pwm_apply_state(haptics->pwm_dev, &state);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Failed to apply PWM state: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tif (state.period > 100000 || state.period < 4000) {\n\t\t\tdev_err(dev, \"Unsupported PWM period: %lld\\n\",\n\t\t\t\tstate.period);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tINIT_WORK(&haptics->work, da7280_haptic_work);\n\n\thaptics->client = client;\n\ti2c_set_clientdata(client, haptics);\n\n\thaptics->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t       &da7280_haptic_regmap_config);\n\terror = PTR_ERR_OR_ZERO(haptics->regmap);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = da7280_init(haptics);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to initialize device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev) {\n\t\tdev_err(dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name = \"da7280-haptic\";\n\tinput_dev->dev.parent = client->dev.parent;\n\tinput_dev->open = da7280_haptic_open;\n\tinput_dev->close = da7280_haptic_close;\n\tinput_set_drvdata(input_dev, haptics);\n\thaptics->input_dev = input_dev;\n\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_PERIODIC);\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_CUSTOM);\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_CONSTANT);\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_GAIN);\n\n\terror = input_ff_create(haptics->input_dev,\n\t\t\t\tDA7280_FF_EFFECT_COUNT_MAX);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to create FF input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tff = input_dev->ff;\n\tff->upload = da7280_haptics_upload_effect;\n\tff->playback = da7280_haptics_playback;\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, da7280_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"da7280-haptics\", haptics);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int da7280_suspend(struct device *dev)\n{\n\tstruct da7280_haptic *haptics = dev_get_drvdata(dev);\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\t \n\tspin_lock_irq(&haptics->input_dev->event_lock);\n\thaptics->suspended = true;\n\tspin_unlock_irq(&haptics->input_dev->event_lock);\n\n\tda7280_haptic_stop(haptics);\n\n\tmutex_unlock(&haptics->input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int da7280_resume(struct device *dev)\n{\n\tstruct da7280_haptic *haptics = dev_get_drvdata(dev);\n\tint retval;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tretval = da7280_haptic_start(haptics);\n\tif (!retval) {\n\t\tspin_lock_irq(&haptics->input_dev->event_lock);\n\t\thaptics->suspended = false;\n\t\tspin_unlock_irq(&haptics->input_dev->event_lock);\n\t}\n\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn retval;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id da7280_of_match[] = {\n\t{ .compatible = \"dlg,da7280\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da7280_of_match);\n#endif\n\nstatic const struct i2c_device_id da7280_i2c_id[] = {\n\t{ \"da7280\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, da7280_i2c_id);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(da7280_pm_ops, da7280_suspend, da7280_resume);\n\nstatic struct i2c_driver da7280_driver = {\n\t.driver = {\n\t\t.name = \"da7280\",\n\t\t.of_match_table = of_match_ptr(da7280_of_match),\n\t\t.pm = pm_sleep_ptr(&da7280_pm_ops),\n\t},\n\t.probe = da7280_probe,\n\t.id_table = da7280_i2c_id,\n};\nmodule_i2c_driver(da7280_driver);\n\nMODULE_DESCRIPTION(\"DA7280 haptics driver\");\nMODULE_AUTHOR(\"Roy Im <Roy.Im.Opensource@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}