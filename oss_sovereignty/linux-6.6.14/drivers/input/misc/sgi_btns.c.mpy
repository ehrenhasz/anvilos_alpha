{
  "module_name": "sgi_btns.c",
  "hash_id": "5e53fdffb5f68fec9bdef49818020cd2ef112267af9b74ff0d26057a58a2ce62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/sgi_btns.c",
  "human_readable_source": "\n \n#include <linux/input.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_SGI_IP22\n#include <asm/sgi/ioc.h>\n\nstatic inline u8 button_status(void)\n{\n\tu8 status;\n\n\tstatus = readb(&sgioc->panel) ^ 0xa0;\n\treturn ((status & 0x80) >> 6) | ((status & 0x20) >> 5);\n}\n#endif\n\n#ifdef CONFIG_SGI_IP32\n#include <asm/ip32/mace.h>\n\nstatic inline u8 button_status(void)\n{\n\tu64 status;\n\n\tstatus = readq(&mace->perif.audio.control);\n\twriteq(status & ~(3U << 23), &mace->perif.audio.control);\n\n\treturn (status >> 23) & 3;\n}\n#endif\n\n#define BUTTONS_POLL_INTERVAL\t30\t \n#define BUTTONS_COUNT_THRESHOLD\t3\n\nstatic const unsigned short sgi_map[] = {\n\tKEY_VOLUMEDOWN,\n\tKEY_VOLUMEUP\n};\n\nstruct buttons_dev {\n\tunsigned short keymap[ARRAY_SIZE(sgi_map)];\n\tint count[ARRAY_SIZE(sgi_map)];\n};\n\nstatic void handle_buttons(struct input_dev *input)\n{\n\tstruct buttons_dev *bdev = input_get_drvdata(input);\n\tu8 status;\n\tint i;\n\n\tstatus = button_status();\n\n\tfor (i = 0; i < ARRAY_SIZE(bdev->keymap); i++) {\n\t\tif (status & (1U << i)) {\n\t\t\tif (++bdev->count[i] == BUTTONS_COUNT_THRESHOLD) {\n\t\t\t\tinput_event(input, EV_MSC, MSC_SCAN, i);\n\t\t\t\tinput_report_key(input, bdev->keymap[i], 1);\n\t\t\t\tinput_sync(input);\n\t\t\t}\n\t\t} else {\n\t\t\tif (bdev->count[i] >= BUTTONS_COUNT_THRESHOLD) {\n\t\t\t\tinput_event(input, EV_MSC, MSC_SCAN, i);\n\t\t\t\tinput_report_key(input, bdev->keymap[i], 0);\n\t\t\t\tinput_sync(input);\n\t\t\t}\n\t\t\tbdev->count[i] = 0;\n\t\t}\n\t}\n}\n\nstatic int sgi_buttons_probe(struct platform_device *pdev)\n{\n\tstruct buttons_dev *bdev;\n\tstruct input_dev *input;\n\tint error, i;\n\n\tbdev = devm_kzalloc(&pdev->dev, sizeof(*bdev), GFP_KERNEL);\n\tif (!bdev)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tmemcpy(bdev->keymap, sgi_map, sizeof(bdev->keymap));\n\n\tinput_set_drvdata(input, bdev);\n\n\tinput->name = \"SGI buttons\";\n\tinput->phys = \"sgi/input0\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput->keycode = bdev->keymap;\n\tinput->keycodemax = ARRAY_SIZE(bdev->keymap);\n\tinput->keycodesize = sizeof(unsigned short);\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\t__set_bit(EV_KEY, input->evbit);\n\tfor (i = 0; i < ARRAY_SIZE(sgi_map); i++)\n\t\t__set_bit(bdev->keymap[i], input->keybit);\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\terror = input_setup_polling(input, handle_buttons);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_poll_interval(input, BUTTONS_POLL_INTERVAL);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic struct platform_driver sgi_buttons_driver = {\n\t.probe\t= sgi_buttons_probe,\n\t.driver\t= {\n\t\t.name\t= \"sgibtns\",\n\t},\n};\nmodule_platform_driver(sgi_buttons_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}