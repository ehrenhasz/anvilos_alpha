{
  "module_name": "atlas_btns.c",
  "hash_id": "3ebd0f17c36b558f3cd0b2fd2360dd7d0ad71e01f3b7e1aed05d9dfb91aa34db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/atlas_btns.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n\n#define ACPI_ATLAS_NAME\t\t\"Atlas ACPI\"\n#define ACPI_ATLAS_CLASS\t\"Atlas\"\n\nstatic unsigned short atlas_keymap[16];\nstatic struct input_dev *input_dev;\n\n \nstatic acpi_status acpi_atlas_button_setup(acpi_handle region_handle,\n\t\t    u32 function, void *handler_context, void **return_context)\n{\n\t*return_context =\n\t\t(function != ACPI_REGION_DEACTIVATE) ? handler_context : NULL;\n\n\treturn AE_OK;\n}\n\nstatic acpi_status acpi_atlas_button_handler(u32 function,\n\t\t      acpi_physical_address address,\n\t\t      u32 bit_width, u64 *value,\n\t\t      void *handler_context, void *region_context)\n{\n\tacpi_status status;\n\n\tif (function == ACPI_WRITE) {\n\t\tint code = address & 0x0f;\n\t\tint key_down = !(address & 0x10);\n\n\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(input_dev, atlas_keymap[code], key_down);\n\t\tinput_sync(input_dev);\n\n\t\tstatus = AE_OK;\n\t} else {\n\t\tpr_warn(\"shrugged on unexpected function: function=%x,address=%lx,value=%x\\n\",\n\t\t\tfunction, (unsigned long)address, (u32)*value);\n\t\tstatus = AE_BAD_PARAMETER;\n\t}\n\n\treturn status;\n}\n\nstatic int atlas_acpi_button_add(struct acpi_device *device)\n{\n\tacpi_status status;\n\tint i;\n\tint err;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev) {\n\t\tpr_err(\"unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name = \"Atlas ACPI button driver\";\n\tinput_dev->phys = \"ASIM0000/atlas/input0\";\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->keycode = atlas_keymap;\n\tinput_dev->keycodesize = sizeof(unsigned short);\n\tinput_dev->keycodemax = ARRAY_SIZE(atlas_keymap);\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\tfor (i = 0; i < ARRAY_SIZE(atlas_keymap); i++) {\n\t\tif (i < 9) {\n\t\t\tatlas_keymap[i] = KEY_F1 + i;\n\t\t\t__set_bit(KEY_F1 + i, input_dev->keybit);\n\t\t} else\n\t\t\tatlas_keymap[i] = KEY_RESERVED;\n\t}\n\n\terr = input_register_device(input_dev);\n\tif (err) {\n\t\tpr_err(\"couldn't register input device\\n\");\n\t\tinput_free_device(input_dev);\n\t\treturn err;\n\t}\n\n\t \n\tstatus = acpi_install_address_space_handler(device->handle,\n\t\t\t\t0x81, &acpi_atlas_button_handler,\n\t\t\t\t&acpi_atlas_button_setup, device);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"error installing addr spc handler\\n\");\n\t\tinput_unregister_device(input_dev);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void atlas_acpi_button_remove(struct acpi_device *device)\n{\n\tacpi_status status;\n\n\tstatus = acpi_remove_address_space_handler(device->handle,\n\t\t\t\t0x81, &acpi_atlas_button_handler);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"error removing addr spc handler\\n\");\n\n\tinput_unregister_device(input_dev);\n}\n\nstatic const struct acpi_device_id atlas_device_ids[] = {\n\t{\"ASIM0000\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, atlas_device_ids);\n\nstatic struct acpi_driver atlas_acpi_driver = {\n\t.name\t= ACPI_ATLAS_NAME,\n\t.class\t= ACPI_ATLAS_CLASS,\n\t.owner\t= THIS_MODULE,\n\t.ids\t= atlas_device_ids,\n\t.ops\t= {\n\t\t.add\t= atlas_acpi_button_add,\n\t\t.remove\t= atlas_acpi_button_remove,\n\t},\n};\nmodule_acpi_driver(atlas_acpi_driver);\n\nMODULE_AUTHOR(\"Jaya Kumar\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Atlas button driver\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}