{
  "module_name": "atc260x-onkey.c",
  "hash_id": "9afed8c18795417f3c2030af861205368464735344240987c6ee19ff2dd50853",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/atc260x-onkey.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/atc260x/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define KEY_PRESS_TIME_SEC\t2\n\n \nenum atc260x_onkey_reset_status {\n\tKEY_RESET_HW_DEFAULT,\n\tKEY_RESET_DISABLED,\n\tKEY_RESET_USER_SEL,\n};\n\nstruct atc260x_onkey_params {\n\tu32 reg_int_ctl;\n\tu32 kdwn_state_bm;\n\tu32 long_int_pnd_bm;\n\tu32 short_int_pnd_bm;\n\tu32 kdwn_int_pnd_bm;\n\tu32 press_int_en_bm;\n\tu32 kdwn_int_en_bm;\n\tu32 press_time_bm;\n\tu32 reset_en_bm;\n\tu32 reset_time_bm;\n};\n\nstruct atc260x_onkey {\n\tstruct atc260x *atc260x;\n\tconst struct atc260x_onkey_params *params;\n\tstruct input_dev *input_dev;\n\tstruct delayed_work work;\n\tint irq;\n};\n\nstatic const struct atc260x_onkey_params atc2603c_onkey_params = {\n\t.reg_int_ctl\t\t= ATC2603C_PMU_SYS_CTL2,\n\t.long_int_pnd_bm\t= ATC2603C_PMU_SYS_CTL2_ONOFF_LONG_PRESS,\n\t.short_int_pnd_bm\t= ATC2603C_PMU_SYS_CTL2_ONOFF_SHORT_PRESS,\n\t.kdwn_int_pnd_bm\t= ATC2603C_PMU_SYS_CTL2_ONOFF_PRESS_PD,\n\t.press_int_en_bm\t= ATC2603C_PMU_SYS_CTL2_ONOFF_INT_EN,\n\t.kdwn_int_en_bm\t\t= ATC2603C_PMU_SYS_CTL2_ONOFF_PRESS_INT_EN,\n\t.kdwn_state_bm\t\t= ATC2603C_PMU_SYS_CTL2_ONOFF_PRESS,\n\t.press_time_bm\t\t= ATC2603C_PMU_SYS_CTL2_ONOFF_PRESS_TIME,\n\t.reset_en_bm\t\t= ATC2603C_PMU_SYS_CTL2_ONOFF_PRESS_RESET_EN,\n\t.reset_time_bm\t\t= ATC2603C_PMU_SYS_CTL2_ONOFF_RESET_TIME_SEL,\n};\n\nstatic const struct atc260x_onkey_params atc2609a_onkey_params = {\n\t.reg_int_ctl\t\t= ATC2609A_PMU_SYS_CTL2,\n\t.long_int_pnd_bm\t= ATC2609A_PMU_SYS_CTL2_ONOFF_LONG_PRESS,\n\t.short_int_pnd_bm\t= ATC2609A_PMU_SYS_CTL2_ONOFF_SHORT_PRESS,\n\t.kdwn_int_pnd_bm\t= ATC2609A_PMU_SYS_CTL2_ONOFF_PRESS_PD,\n\t.press_int_en_bm\t= ATC2609A_PMU_SYS_CTL2_ONOFF_LSP_INT_EN,\n\t.kdwn_int_en_bm\t\t= ATC2609A_PMU_SYS_CTL2_ONOFF_PRESS_INT_EN,\n\t.kdwn_state_bm\t\t= ATC2609A_PMU_SYS_CTL2_ONOFF_PRESS,\n\t.press_time_bm\t\t= ATC2609A_PMU_SYS_CTL2_ONOFF_PRESS_TIME,\n\t.reset_en_bm\t\t= ATC2609A_PMU_SYS_CTL2_ONOFF_RESET_EN,\n\t.reset_time_bm\t\t= ATC2609A_PMU_SYS_CTL2_ONOFF_RESET_TIME_SEL,\n};\n\nstatic int atc2603x_onkey_hw_init(struct atc260x_onkey *onkey,\n\t\t\t\t  enum atc260x_onkey_reset_status reset_status,\n\t\t\t\t  u32 reset_time, u32 press_time)\n{\n\tu32 reg_bm, reg_val;\n\n\treg_bm = onkey->params->long_int_pnd_bm |\n\t\t onkey->params->short_int_pnd_bm |\n\t\t onkey->params->kdwn_int_pnd_bm |\n\t\t onkey->params->press_int_en_bm |\n\t\t onkey->params->kdwn_int_en_bm;\n\n\treg_val = reg_bm | press_time;\n\treg_bm |= onkey->params->press_time_bm;\n\n\tif (reset_status == KEY_RESET_DISABLED) {\n\t\treg_bm |= onkey->params->reset_en_bm;\n\t} else if (reset_status == KEY_RESET_USER_SEL) {\n\t\treg_bm |= onkey->params->reset_en_bm |\n\t\t\t  onkey->params->reset_time_bm;\n\t\treg_val |= onkey->params->reset_en_bm | reset_time;\n\t}\n\n\treturn regmap_update_bits(onkey->atc260x->regmap,\n\t\t\t\t  onkey->params->reg_int_ctl, reg_bm, reg_val);\n}\n\nstatic void atc260x_onkey_query(struct atc260x_onkey *onkey)\n{\n\tu32 reg_bits;\n\tint ret, key_down;\n\n\tret = regmap_read(onkey->atc260x->regmap,\n\t\t\t  onkey->params->reg_int_ctl, &key_down);\n\tif (ret) {\n\t\tkey_down = 1;\n\t\tdev_err(onkey->atc260x->dev,\n\t\t\t\"Failed to read onkey status: %d\\n\", ret);\n\t} else {\n\t\tkey_down &= onkey->params->kdwn_state_bm;\n\t}\n\n\t \n\tif (key_down) {\n\t\tschedule_delayed_work(&onkey->work, msecs_to_jiffies(200));\n\t\treturn;\n\t}\n\n\t \n\tinput_report_key(onkey->input_dev, KEY_POWER, 0);\n\tinput_sync(onkey->input_dev);\n\n\treg_bits = onkey->params->long_int_pnd_bm |\n\t\t   onkey->params->short_int_pnd_bm |\n\t\t   onkey->params->kdwn_int_pnd_bm |\n\t\t   onkey->params->press_int_en_bm |\n\t\t   onkey->params->kdwn_int_en_bm;\n\n\t \n\tregmap_update_bits(onkey->atc260x->regmap, onkey->params->reg_int_ctl,\n\t\t\t   reg_bits, reg_bits);\n}\n\nstatic void atc260x_onkey_work(struct work_struct *work)\n{\n\tstruct atc260x_onkey *onkey = container_of(work, struct atc260x_onkey,\n\t\t\t\t\t\t   work.work);\n\tatc260x_onkey_query(onkey);\n}\n\nstatic irqreturn_t atc260x_onkey_irq(int irq, void *data)\n{\n\tstruct atc260x_onkey *onkey = data;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(onkey->atc260x->regmap,\n\t\t\t\t onkey->params->reg_int_ctl,\n\t\t\t\t onkey->params->press_int_en_bm |\n\t\t\t\t onkey->params->kdwn_int_en_bm, 0);\n\tif (ret)\n\t\tdev_err(onkey->atc260x->dev,\n\t\t\t\"Failed to disable interrupts: %d\\n\", ret);\n\n\tinput_report_key(onkey->input_dev, KEY_POWER, 1);\n\tinput_sync(onkey->input_dev);\n\n\tatc260x_onkey_query(onkey);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int atc260x_onkey_open(struct input_dev *dev)\n{\n\tstruct atc260x_onkey *onkey = input_get_drvdata(dev);\n\n\tenable_irq(onkey->irq);\n\n\treturn 0;\n}\n\nstatic void atc260x_onkey_close(struct input_dev *dev)\n{\n\tstruct atc260x_onkey *onkey = input_get_drvdata(dev);\n\n\tdisable_irq(onkey->irq);\n\tcancel_delayed_work_sync(&onkey->work);\n}\n\nstatic int atc260x_onkey_probe(struct platform_device *pdev)\n{\n\tstruct atc260x *atc260x = dev_get_drvdata(pdev->dev.parent);\n\tstruct atc260x_onkey *onkey;\n\tstruct input_dev *input_dev;\n\tenum atc260x_onkey_reset_status reset_status;\n\tu32 press_time = KEY_PRESS_TIME_SEC, reset_time = 0;\n\tint val, error;\n\n\tonkey = devm_kzalloc(&pdev->dev, sizeof(*onkey), GFP_KERNEL);\n\tif (!onkey)\n\t\treturn -ENOMEM;\n\n\terror = device_property_read_u32(pdev->dev.parent,\n\t\t\t\t\t \"reset-time-sec\", &val);\n\tif (error) {\n\t\treset_status = KEY_RESET_HW_DEFAULT;\n\t} else if (val) {\n\t\tif (val < 6 || val > 12) {\n\t\t\tdev_err(&pdev->dev, \"reset-time-sec out of range\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treset_status = KEY_RESET_USER_SEL;\n\t\treset_time = (val - 6) / 2;\n\t} else {\n\t\treset_status = KEY_RESET_DISABLED;\n\t\tdev_dbg(&pdev->dev, \"Disabled reset on long-press\\n\");\n\t}\n\n\tswitch (atc260x->ic_type) {\n\tcase ATC2603C:\n\t\tonkey->params = &atc2603c_onkey_params;\n\t\tpress_time = FIELD_PREP(ATC2603C_PMU_SYS_CTL2_ONOFF_PRESS_TIME,\n\t\t\t\t\tpress_time);\n\t\treset_time = FIELD_PREP(ATC2603C_PMU_SYS_CTL2_ONOFF_RESET_TIME_SEL,\n\t\t\t\t\treset_time);\n\t\tbreak;\n\tcase ATC2609A:\n\t\tonkey->params = &atc2609a_onkey_params;\n\t\tpress_time = FIELD_PREP(ATC2609A_PMU_SYS_CTL2_ONOFF_PRESS_TIME,\n\t\t\t\t\tpress_time);\n\t\treset_time = FIELD_PREP(ATC2609A_PMU_SYS_CTL2_ONOFF_RESET_TIME_SEL,\n\t\t\t\t\treset_time);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"OnKey not supported for ATC260x PMIC type: %u\\n\",\n\t\t\tatc260x->ic_type);\n\t\treturn -EINVAL;\n\t}\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tonkey->input_dev = input_dev;\n\tonkey->atc260x = atc260x;\n\n\tinput_dev->name = \"atc260x-onkey\";\n\tinput_dev->phys = \"atc260x-onkey/input0\";\n\tinput_dev->open = atc260x_onkey_open;\n\tinput_dev->close = atc260x_onkey_close;\n\n\tinput_set_capability(input_dev, EV_KEY, KEY_POWER);\n\tinput_set_drvdata(input_dev, onkey);\n\n\tINIT_DELAYED_WORK(&onkey->work, atc260x_onkey_work);\n\n\tonkey->irq = platform_get_irq(pdev, 0);\n\tif (onkey->irq < 0)\n\t\treturn onkey->irq;\n\n\terror = devm_request_threaded_irq(&pdev->dev, onkey->irq, NULL,\n\t\t\t\t\t  atc260x_onkey_irq, IRQF_ONESHOT,\n\t\t\t\t\t  dev_name(&pdev->dev), onkey);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register IRQ %d: %d\\n\", onkey->irq, error);\n\t\treturn error;\n\t}\n\n\t \n\tdisable_irq(onkey->irq);\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = atc2603x_onkey_hw_init(onkey, reset_status,\n\t\t\t\t       reset_time, press_time);\n\tif (error)\n\t\treturn error;\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\treturn 0;\n}\n\nstatic struct platform_driver atc260x_onkey_driver = {\n\t.probe\t= atc260x_onkey_probe,\n\t.driver\t= {\n\t\t.name = \"atc260x-onkey\",\n\t},\n};\n\nmodule_platform_driver(atc260x_onkey_driver);\n\nMODULE_DESCRIPTION(\"Onkey driver for ATC260x PMICs\");\nMODULE_AUTHOR(\"Cristian Ciocaltea <cristian.ciocaltea@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}