{
  "module_name": "nxp-bbnsm-pwrkey.c",
  "hash_id": "082d4881f0a14360ab47fab3081931f480d50a49759f06fd56577168ea7acc2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/nxp-bbnsm-pwrkey.c",
  "human_readable_source": "\n\n\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n\n#define BBNSM_CTRL\t\t0x8\n#define BBNSM_INT_EN\t\t0x10\n#define BBNSM_EVENTS\t\t0x14\n#define BBNSM_PAD_CTRL\t\t0x24\n\n#define BBNSM_BTN_PRESSED\tBIT(7)\n#define BBNSM_PWR_ON\t\tBIT(6)\n#define BBNSM_BTN_OFF\t\tBIT(5)\n#define BBNSM_EMG_OFF\t\tBIT(4)\n#define BBNSM_PWRKEY_EVENTS\t(BBNSM_PWR_ON | BBNSM_BTN_OFF | BBNSM_EMG_OFF)\n#define BBNSM_DP_EN\t\tBIT(24)\n\n#define DEBOUNCE_TIME\t\t30\n#define REPEAT_INTERVAL\t\t60\n\nstruct bbnsm_pwrkey {\n\tstruct regmap *regmap;\n\tint irq;\n\tint keycode;\n\tint keystate;   \n\tstruct timer_list check_timer;\n\tstruct input_dev *input;\n};\n\nstatic void bbnsm_pwrkey_check_for_events(struct timer_list *t)\n{\n\tstruct bbnsm_pwrkey *bbnsm = from_timer(bbnsm, t, check_timer);\n\tstruct input_dev *input = bbnsm->input;\n\tu32 state;\n\n\tregmap_read(bbnsm->regmap, BBNSM_EVENTS, &state);\n\n\tstate = state & BBNSM_BTN_PRESSED ? 1 : 0;\n\n\t \n\tif (state ^ bbnsm->keystate) {\n\t\tbbnsm->keystate = state;\n\t\tinput_event(input, EV_KEY, bbnsm->keycode, state);\n\t\tinput_sync(input);\n\t\tpm_relax(bbnsm->input->dev.parent);\n\t}\n\n\t \n\tif (state)\n\t\tmod_timer(&bbnsm->check_timer,\n\t\t\t  jiffies + msecs_to_jiffies(REPEAT_INTERVAL));\n}\n\nstatic irqreturn_t bbnsm_pwrkey_interrupt(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct bbnsm_pwrkey *bbnsm = platform_get_drvdata(pdev);\n\tu32 event;\n\n\tregmap_read(bbnsm->regmap, BBNSM_EVENTS, &event);\n\tif (!(event & BBNSM_BTN_OFF))\n\t\treturn IRQ_NONE;\n\n\tpm_wakeup_event(bbnsm->input->dev.parent, 0);\n\n\tmod_timer(&bbnsm->check_timer,\n\t\t   jiffies + msecs_to_jiffies(DEBOUNCE_TIME));\n\n\t \n\tregmap_write(bbnsm->regmap, BBNSM_EVENTS, BBNSM_BTN_OFF);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bbnsm_pwrkey_act(void *pdata)\n{\n\tstruct bbnsm_pwrkey *bbnsm = pdata;\n\n\ttimer_shutdown_sync(&bbnsm->check_timer);\n}\n\nstatic int bbnsm_pwrkey_probe(struct platform_device *pdev)\n{\n\tstruct bbnsm_pwrkey *bbnsm;\n\tstruct input_dev *input;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint error;\n\n\tbbnsm = devm_kzalloc(&pdev->dev, sizeof(*bbnsm), GFP_KERNEL);\n\tif (!bbnsm)\n\t\treturn -ENOMEM;\n\n\tbbnsm->regmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(bbnsm->regmap)) {\n\t\tdev_err(&pdev->dev, \"bbnsm pwerkey get regmap failed\\n\");\n\t\treturn PTR_ERR(bbnsm->regmap);\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"linux,code\",\n\t\t\t\t     &bbnsm->keycode)) {\n\t\tbbnsm->keycode = KEY_POWER;\n\t\tdev_warn(&pdev->dev, \"key code is not specified, using default KEY_POWER\\n\");\n\t}\n\n\tbbnsm->irq = platform_get_irq(pdev, 0);\n\tif (bbnsm->irq < 0)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_update_bits(bbnsm->regmap, BBNSM_CTRL, BBNSM_DP_EN, BBNSM_DP_EN);\n\n\t \n\tregmap_write_bits(bbnsm->regmap, BBNSM_EVENTS, BBNSM_PWRKEY_EVENTS,\n\t\t\t  BBNSM_PWRKEY_EVENTS);\n\n\ttimer_setup(&bbnsm->check_timer, bbnsm_pwrkey_check_for_events, 0);\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate the input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = pdev->name;\n\tinput->phys = \"bbnsm-pwrkey/input0\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput_set_capability(input, EV_KEY, bbnsm->keycode);\n\n\t \n\terror = devm_add_action(&pdev->dev, bbnsm_pwrkey_act, bbnsm);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register remove action\\n\");\n\t\treturn error;\n\t}\n\n\tbbnsm->input = input;\n\tplatform_set_drvdata(pdev, bbnsm);\n\n\terror = devm_request_irq(&pdev->dev, bbnsm->irq, bbnsm_pwrkey_interrupt,\n\t\t\t\t IRQF_SHARED, pdev->name, pdev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"interrupt not available.\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\terror = dev_pm_set_wake_irq(&pdev->dev, bbnsm->irq);\n\tif (error)\n\t\tdev_warn(&pdev->dev, \"irq wake enable failed.\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bbnsm_pwrkey_ids[] = {\n\t{ .compatible = \"nxp,imx93-bbnsm-pwrkey\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bbnsm_pwrkey_ids);\n\nstatic struct platform_driver bbnsm_pwrkey_driver = {\n\t.driver = {\n\t\t.name = \"bbnsm_pwrkey\",\n\t\t.of_match_table = bbnsm_pwrkey_ids,\n\t},\n\t.probe = bbnsm_pwrkey_probe,\n};\nmodule_platform_driver(bbnsm_pwrkey_driver);\n\nMODULE_AUTHOR(\"Jacky Bai <ping.bai@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP bbnsm power key Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}