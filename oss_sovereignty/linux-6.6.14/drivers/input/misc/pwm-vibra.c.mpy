{
  "module_name": "pwm-vibra.c",
  "hash_id": "ecbfb85de54644b3f41aace61f7a0320a4b44f94f8e01bfe355e3068dacfd081",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/pwm-vibra.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/pwm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\nstruct pwm_vibrator {\n\tstruct input_dev *input;\n\tstruct gpio_desc *enable_gpio;\n\tstruct pwm_device *pwm;\n\tstruct pwm_device *pwm_dir;\n\tstruct regulator *vcc;\n\n\tstruct work_struct play_work;\n\tu16 level;\n\tu32 direction_duty_cycle;\n\tbool vcc_on;\n};\n\nstatic int pwm_vibrator_start(struct pwm_vibrator *vibrator)\n{\n\tstruct device *pdev = vibrator->input->dev.parent;\n\tstruct pwm_state state;\n\tint err;\n\n\tif (!vibrator->vcc_on) {\n\t\terr = regulator_enable(vibrator->vcc);\n\t\tif (err) {\n\t\t\tdev_err(pdev, \"failed to enable regulator: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tvibrator->vcc_on = true;\n\t}\n\n\tgpiod_set_value_cansleep(vibrator->enable_gpio, 1);\n\n\tpwm_get_state(vibrator->pwm, &state);\n\tpwm_set_relative_duty_cycle(&state, vibrator->level, 0xffff);\n\tstate.enabled = true;\n\n\terr = pwm_apply_state(vibrator->pwm, &state);\n\tif (err) {\n\t\tdev_err(pdev, \"failed to apply pwm state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (vibrator->pwm_dir) {\n\t\tpwm_get_state(vibrator->pwm_dir, &state);\n\t\tstate.duty_cycle = vibrator->direction_duty_cycle;\n\t\tstate.enabled = true;\n\n\t\terr = pwm_apply_state(vibrator->pwm_dir, &state);\n\t\tif (err) {\n\t\t\tdev_err(pdev, \"failed to apply dir-pwm state: %d\\n\", err);\n\t\t\tpwm_disable(vibrator->pwm);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pwm_vibrator_stop(struct pwm_vibrator *vibrator)\n{\n\tif (vibrator->pwm_dir)\n\t\tpwm_disable(vibrator->pwm_dir);\n\tpwm_disable(vibrator->pwm);\n\n\tgpiod_set_value_cansleep(vibrator->enable_gpio, 0);\n\n\tif (vibrator->vcc_on) {\n\t\tregulator_disable(vibrator->vcc);\n\t\tvibrator->vcc_on = false;\n\t}\n}\n\nstatic void pwm_vibrator_play_work(struct work_struct *work)\n{\n\tstruct pwm_vibrator *vibrator = container_of(work,\n\t\t\t\t\tstruct pwm_vibrator, play_work);\n\n\tif (vibrator->level)\n\t\tpwm_vibrator_start(vibrator);\n\telse\n\t\tpwm_vibrator_stop(vibrator);\n}\n\nstatic int pwm_vibrator_play_effect(struct input_dev *dev, void *data,\n\t\t\t\t    struct ff_effect *effect)\n{\n\tstruct pwm_vibrator *vibrator = input_get_drvdata(dev);\n\n\tvibrator->level = effect->u.rumble.strong_magnitude;\n\tif (!vibrator->level)\n\t\tvibrator->level = effect->u.rumble.weak_magnitude;\n\n\tschedule_work(&vibrator->play_work);\n\n\treturn 0;\n}\n\nstatic void pwm_vibrator_close(struct input_dev *input)\n{\n\tstruct pwm_vibrator *vibrator = input_get_drvdata(input);\n\n\tcancel_work_sync(&vibrator->play_work);\n\tpwm_vibrator_stop(vibrator);\n}\n\nstatic int pwm_vibrator_probe(struct platform_device *pdev)\n{\n\tstruct pwm_vibrator *vibrator;\n\tstruct pwm_state state;\n\tint err;\n\n\tvibrator = devm_kzalloc(&pdev->dev, sizeof(*vibrator), GFP_KERNEL);\n\tif (!vibrator)\n\t\treturn -ENOMEM;\n\n\tvibrator->input = devm_input_allocate_device(&pdev->dev);\n\tif (!vibrator->input)\n\t\treturn -ENOMEM;\n\n\tvibrator->vcc = devm_regulator_get(&pdev->dev, \"vcc\");\n\tif (IS_ERR(vibrator->vcc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vibrator->vcc),\n\t\t\t\t     \"Failed to request regulator\\n\");\n\n\tvibrator->enable_gpio = devm_gpiod_get_optional(&pdev->dev, \"enable\",\n\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(vibrator->enable_gpio))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vibrator->enable_gpio),\n\t\t\t\t     \"Failed to request enable gpio\\n\");\n\n\tvibrator->pwm = devm_pwm_get(&pdev->dev, \"enable\");\n\tif (IS_ERR(vibrator->pwm))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vibrator->pwm),\n\t\t\t\t     \"Failed to request main pwm\\n\");\n\n\tINIT_WORK(&vibrator->play_work, pwm_vibrator_play_work);\n\n\t \n\tpwm_init_state(vibrator->pwm, &state);\n\tstate.enabled = false;\n\terr = pwm_apply_state(vibrator->pwm, &state);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to apply initial PWM state: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tvibrator->pwm_dir = devm_pwm_get(&pdev->dev, \"direction\");\n\terr = PTR_ERR_OR_ZERO(vibrator->pwm_dir);\n\tswitch (err) {\n\tcase 0:\n\t\t \n\t\tpwm_init_state(vibrator->pwm_dir, &state);\n\t\tstate.enabled = false;\n\t\terr = pwm_apply_state(vibrator->pwm_dir, &state);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"failed to apply initial PWM state: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\tvibrator->direction_duty_cycle =\n\t\t\tpwm_get_period(vibrator->pwm_dir) / 2;\n\t\tdevice_property_read_u32(&pdev->dev, \"direction-duty-cycle-ns\",\n\t\t\t\t\t &vibrator->direction_duty_cycle);\n\t\tbreak;\n\n\tcase -ENODATA:\n\t\t \n\t\tvibrator->pwm_dir = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Failed to request direction pwm: %d\\n\", err);\n\t\tfallthrough;\n\n\tcase -EPROBE_DEFER:\n\t\treturn err;\n\t}\n\n\tvibrator->input->name = \"pwm-vibrator\";\n\tvibrator->input->id.bustype = BUS_HOST;\n\tvibrator->input->dev.parent = &pdev->dev;\n\tvibrator->input->close = pwm_vibrator_close;\n\n\tinput_set_drvdata(vibrator->input, vibrator);\n\tinput_set_capability(vibrator->input, EV_FF, FF_RUMBLE);\n\n\terr = input_ff_create_memless(vibrator->input, NULL,\n\t\t\t\t      pwm_vibrator_play_effect);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Couldn't create FF dev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = input_register_device(vibrator->input);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Couldn't register input dev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, vibrator);\n\n\treturn 0;\n}\n\nstatic int pwm_vibrator_suspend(struct device *dev)\n{\n\tstruct pwm_vibrator *vibrator = dev_get_drvdata(dev);\n\n\tcancel_work_sync(&vibrator->play_work);\n\tif (vibrator->level)\n\t\tpwm_vibrator_stop(vibrator);\n\n\treturn 0;\n}\n\nstatic int pwm_vibrator_resume(struct device *dev)\n{\n\tstruct pwm_vibrator *vibrator = dev_get_drvdata(dev);\n\n\tif (vibrator->level)\n\t\tpwm_vibrator_start(vibrator);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pwm_vibrator_pm_ops,\n\t\t\t\tpwm_vibrator_suspend, pwm_vibrator_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pwm_vibra_dt_match_table[] = {\n\t{ .compatible = \"pwm-vibrator\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pwm_vibra_dt_match_table);\n#endif\n\nstatic struct platform_driver pwm_vibrator_driver = {\n\t.probe\t= pwm_vibrator_probe,\n\t.driver\t= {\n\t\t.name\t= \"pwm-vibrator\",\n\t\t.pm\t= pm_sleep_ptr(&pwm_vibrator_pm_ops),\n\t\t.of_match_table = of_match_ptr(pwm_vibra_dt_match_table),\n\t},\n};\nmodule_platform_driver(pwm_vibrator_driver);\n\nMODULE_AUTHOR(\"Sebastian Reichel <sre@kernel.org>\");\nMODULE_DESCRIPTION(\"PWM vibrator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pwm-vibrator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}