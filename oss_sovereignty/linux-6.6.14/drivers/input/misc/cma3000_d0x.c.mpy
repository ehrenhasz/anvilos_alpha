{
  "module_name": "cma3000_d0x.c",
  "hash_id": "a676c4e28f1f66b24d2081d18b72065654a743885dd670ab8a54b1e8634966bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/cma3000_d0x.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/input/cma3000.h>\n#include <linux/module.h>\n\n#include \"cma3000_d0x.h\"\n\n#define CMA3000_WHOAMI      0x00\n#define CMA3000_REVID       0x01\n#define CMA3000_CTRL        0x02\n#define CMA3000_STATUS      0x03\n#define CMA3000_RSTR        0x04\n#define CMA3000_INTSTATUS   0x05\n#define CMA3000_DOUTX       0x06\n#define CMA3000_DOUTY       0x07\n#define CMA3000_DOUTZ       0x08\n#define CMA3000_MDTHR       0x09\n#define CMA3000_MDFFTMR     0x0A\n#define CMA3000_FFTHR       0x0B\n\n#define CMA3000_RANGE2G    (1 << 7)\n#define CMA3000_RANGE8G    (0 << 7)\n#define CMA3000_BUSI2C     (0 << 4)\n#define CMA3000_MODEMASK   (7 << 1)\n#define CMA3000_GRANGEMASK (1 << 7)\n\n#define CMA3000_STATUS_PERR    1\n#define CMA3000_INTSTATUS_FFDET (1 << 2)\n\n \n#define CMA3000_SETDELAY    30\n\n \n#define CMA3000_INTDELAY    44\n\n\n \n#define BIT_TO_2G  18\n#define BIT_TO_8G  71\n\nstruct cma3000_accl_data {\n\tconst struct cma3000_bus_ops *bus_ops;\n\tconst struct cma3000_platform_data *pdata;\n\n\tstruct device *dev;\n\tstruct input_dev *input_dev;\n\n\tint bit_to_mg;\n\tint irq;\n\n\tint g_range;\n\tu8 mode;\n\n\tstruct mutex mutex;\n\tbool opened;\n\tbool suspended;\n};\n\n#define CMA3000_READ(data, reg, msg) \\\n\t(data->bus_ops->read(data->dev, reg, msg))\n#define CMA3000_SET(data, reg, val, msg) \\\n\t((data)->bus_ops->write(data->dev, reg, val, msg))\n\n \n\nstatic int mode_to_mg[8][2] = {\n\t{ 0, 0 },\n\t{ BIT_TO_8G, BIT_TO_2G },\n\t{ BIT_TO_8G, BIT_TO_2G },\n\t{ BIT_TO_8G, BIT_TO_8G },\n\t{ BIT_TO_8G, BIT_TO_8G },\n\t{ BIT_TO_8G, BIT_TO_2G },\n\t{ BIT_TO_8G, BIT_TO_2G },\n\t{ 0, 0},\n};\n\nstatic void decode_mg(struct cma3000_accl_data *data, int *datax,\n\t\t\t\tint *datay, int *dataz)\n{\n\t \n\t*datax = ((s8)*datax) * data->bit_to_mg;\n\t*datay = ((s8)*datay) * data->bit_to_mg;\n\t*dataz = ((s8)*dataz) * data->bit_to_mg;\n}\n\nstatic irqreturn_t cma3000_thread_irq(int irq, void *dev_id)\n{\n\tstruct cma3000_accl_data *data = dev_id;\n\tint datax, datay, dataz, intr_status;\n\tu8 ctrl, mode, range;\n\n\tintr_status = CMA3000_READ(data, CMA3000_INTSTATUS, \"interrupt status\");\n\tif (intr_status < 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (intr_status & CMA3000_INTSTATUS_FFDET) {\n\t\tinput_report_abs(data->input_dev, ABS_MISC, 1);\n\t\tinput_sync(data->input_dev);\n\t} else {\n\t\tinput_report_abs(data->input_dev, ABS_MISC, 0);\n\t}\n\n\tdatax = CMA3000_READ(data, CMA3000_DOUTX, \"X\");\n\tdatay = CMA3000_READ(data, CMA3000_DOUTY, \"Y\");\n\tdataz = CMA3000_READ(data, CMA3000_DOUTZ, \"Z\");\n\n\tctrl = CMA3000_READ(data, CMA3000_CTRL, \"ctrl\");\n\tmode = (ctrl & CMA3000_MODEMASK) >> 1;\n\trange = (ctrl & CMA3000_GRANGEMASK) >> 7;\n\n\tdata->bit_to_mg = mode_to_mg[mode][range];\n\n\t \n\tif (data->bit_to_mg == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tdecode_mg(data, &datax, &datay, &dataz);\n\n\tinput_report_abs(data->input_dev, ABS_X, datax);\n\tinput_report_abs(data->input_dev, ABS_Y, datay);\n\tinput_report_abs(data->input_dev, ABS_Z, dataz);\n\tinput_sync(data->input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cma3000_reset(struct cma3000_accl_data *data)\n{\n\tint val;\n\n\t \n\tCMA3000_SET(data, CMA3000_RSTR, 0x02, \"Reset\");\n\tCMA3000_SET(data, CMA3000_RSTR, 0x0A, \"Reset\");\n\tCMA3000_SET(data, CMA3000_RSTR, 0x04, \"Reset\");\n\n\t \n\tmdelay(10);\n\n\tval = CMA3000_READ(data, CMA3000_STATUS, \"Status\");\n\tif (val < 0) {\n\t\tdev_err(data->dev, \"Reset failed\\n\");\n\t\treturn val;\n\t}\n\n\tif (val & CMA3000_STATUS_PERR) {\n\t\tdev_err(data->dev, \"Parity Error\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cma3000_poweron(struct cma3000_accl_data *data)\n{\n\tconst struct cma3000_platform_data *pdata = data->pdata;\n\tu8 ctrl = 0;\n\tint ret;\n\n\tif (data->g_range == CMARANGE_2G) {\n\t\tctrl = (data->mode << 1) | CMA3000_RANGE2G;\n\t} else if (data->g_range == CMARANGE_8G) {\n\t\tctrl = (data->mode << 1) | CMA3000_RANGE8G;\n\t} else {\n\t\tdev_info(data->dev,\n\t\t\t \"Invalid G range specified, assuming 8G\\n\");\n\t\tctrl = (data->mode << 1) | CMA3000_RANGE8G;\n\t}\n\n\tctrl |= data->bus_ops->ctrl_mod;\n\n\tCMA3000_SET(data, CMA3000_MDTHR, pdata->mdthr,\n\t\t    \"Motion Detect Threshold\");\n\tCMA3000_SET(data, CMA3000_MDFFTMR, pdata->mdfftmr,\n\t\t    \"Time register\");\n\tCMA3000_SET(data, CMA3000_FFTHR, pdata->ffthr,\n\t\t    \"Free fall threshold\");\n\tret = CMA3000_SET(data, CMA3000_CTRL, ctrl, \"Mode setting\");\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\tmsleep(CMA3000_SETDELAY);\n\n\treturn 0;\n}\n\nstatic int cma3000_poweroff(struct cma3000_accl_data *data)\n{\n\tint ret;\n\n\tret = CMA3000_SET(data, CMA3000_CTRL, CMAMODE_POFF, \"Mode setting\");\n\tmsleep(CMA3000_SETDELAY);\n\n\treturn ret;\n}\n\nstatic int cma3000_open(struct input_dev *input_dev)\n{\n\tstruct cma3000_accl_data *data = input_get_drvdata(input_dev);\n\n\tmutex_lock(&data->mutex);\n\n\tif (!data->suspended)\n\t\tcma3000_poweron(data);\n\n\tdata->opened = true;\n\n\tmutex_unlock(&data->mutex);\n\n\treturn 0;\n}\n\nstatic void cma3000_close(struct input_dev *input_dev)\n{\n\tstruct cma3000_accl_data *data = input_get_drvdata(input_dev);\n\n\tmutex_lock(&data->mutex);\n\n\tif (!data->suspended)\n\t\tcma3000_poweroff(data);\n\n\tdata->opened = false;\n\n\tmutex_unlock(&data->mutex);\n}\n\nvoid cma3000_suspend(struct cma3000_accl_data *data)\n{\n\tmutex_lock(&data->mutex);\n\n\tif (!data->suspended && data->opened)\n\t\tcma3000_poweroff(data);\n\n\tdata->suspended = true;\n\n\tmutex_unlock(&data->mutex);\n}\nEXPORT_SYMBOL(cma3000_suspend);\n\n\nvoid cma3000_resume(struct cma3000_accl_data *data)\n{\n\tmutex_lock(&data->mutex);\n\n\tif (data->suspended && data->opened)\n\t\tcma3000_poweron(data);\n\n\tdata->suspended = false;\n\n\tmutex_unlock(&data->mutex);\n}\nEXPORT_SYMBOL(cma3000_resume);\n\nstruct cma3000_accl_data *cma3000_init(struct device *dev, int irq,\n\t\t\t\t       const struct cma3000_bus_ops *bops)\n{\n\tconst struct cma3000_platform_data *pdata = dev_get_platdata(dev);\n\tstruct cma3000_accl_data *data;\n\tstruct input_dev *input_dev;\n\tint rev;\n\tint error;\n\n\tif (!pdata) {\n\t\tdev_err(dev, \"platform data not found\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\n\t \n\tif (irq == 0) {\n\t\terror = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tdata = kzalloc(sizeof(struct cma3000_accl_data), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!data || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tdata->dev = dev;\n\tdata->input_dev = input_dev;\n\tdata->bus_ops = bops;\n\tdata->pdata = pdata;\n\tdata->irq = irq;\n\tmutex_init(&data->mutex);\n\n\tdata->mode = pdata->mode;\n\tif (data->mode > CMAMODE_POFF) {\n\t\tdata->mode = CMAMODE_MOTDET;\n\t\tdev_warn(dev,\n\t\t\t \"Invalid mode specified, assuming Motion Detect\\n\");\n\t}\n\n\tdata->g_range = pdata->g_range;\n\tif (data->g_range != CMARANGE_2G && data->g_range != CMARANGE_8G) {\n\t\tdev_info(dev,\n\t\t\t \"Invalid G range specified, assuming 8G\\n\");\n\t\tdata->g_range = CMARANGE_8G;\n\t}\n\n\tinput_dev->name = \"cma3000-accelerometer\";\n\tinput_dev->id.bustype = bops->bustype;\n\tinput_dev->open = cma3000_open;\n\tinput_dev->close = cma3000_close;\n\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\t-data->g_range, data->g_range, pdata->fuzz_x, 0);\n\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\t-data->g_range, data->g_range, pdata->fuzz_y, 0);\n\tinput_set_abs_params(input_dev, ABS_Z,\n\t\t\t-data->g_range, data->g_range, pdata->fuzz_z, 0);\n\tinput_set_abs_params(input_dev, ABS_MISC, 0, 1, 0, 0);\n\n\tinput_set_drvdata(input_dev, data);\n\n\terror = cma3000_reset(data);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\trev = CMA3000_READ(data, CMA3000_REVID, \"Revid\");\n\tif (rev < 0) {\n\t\terror = rev;\n\t\tgoto err_free_mem;\n\t}\n\n\tpr_info(\"CMA3000 Accelerometer: Revision %x\\n\", rev);\n\n\terror = request_threaded_irq(irq, NULL, cma3000_thread_irq,\n\t\t\t\t     pdata->irqflags | IRQF_ONESHOT,\n\t\t\t\t     \"cma3000_d0x\", data);\n\tif (error) {\n\t\tdev_err(dev, \"request_threaded_irq failed\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\terror = input_register_device(data->input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to register input device\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\treturn data;\n\nerr_free_irq:\n\tfree_irq(irq, data);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(data);\nerr_out:\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL(cma3000_init);\n\nvoid cma3000_exit(struct cma3000_accl_data *data)\n{\n\tfree_irq(data->irq, data);\n\tinput_unregister_device(data->input_dev);\n\tkfree(data);\n}\nEXPORT_SYMBOL(cma3000_exit);\n\nMODULE_DESCRIPTION(\"CMA3000-D0x Accelerometer Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Hemanth V <hemanthv@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}