{
  "module_name": "gpio-vibra.c",
  "hash_id": "9359c1b88edd7d68777d845ee1170f0ded754eeeff9b36408c006e37baddc0da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/gpio-vibra.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\nstruct gpio_vibrator {\n\tstruct input_dev *input;\n\tstruct gpio_desc *gpio;\n\tstruct regulator *vcc;\n\n\tstruct work_struct play_work;\n\tbool running;\n\tbool vcc_on;\n};\n\nstatic int gpio_vibrator_start(struct gpio_vibrator *vibrator)\n{\n\tstruct device *pdev = vibrator->input->dev.parent;\n\tint err;\n\n\tif (!vibrator->vcc_on) {\n\t\terr = regulator_enable(vibrator->vcc);\n\t\tif (err) {\n\t\t\tdev_err(pdev, \"failed to enable regulator: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tvibrator->vcc_on = true;\n\t}\n\n\tgpiod_set_value_cansleep(vibrator->gpio, 1);\n\n\treturn 0;\n}\n\nstatic void gpio_vibrator_stop(struct gpio_vibrator *vibrator)\n{\n\tgpiod_set_value_cansleep(vibrator->gpio, 0);\n\n\tif (vibrator->vcc_on) {\n\t\tregulator_disable(vibrator->vcc);\n\t\tvibrator->vcc_on = false;\n\t}\n}\n\nstatic void gpio_vibrator_play_work(struct work_struct *work)\n{\n\tstruct gpio_vibrator *vibrator =\n\t\tcontainer_of(work, struct gpio_vibrator, play_work);\n\n\tif (vibrator->running)\n\t\tgpio_vibrator_start(vibrator);\n\telse\n\t\tgpio_vibrator_stop(vibrator);\n}\n\nstatic int gpio_vibrator_play_effect(struct input_dev *dev, void *data,\n\t\t\t\t     struct ff_effect *effect)\n{\n\tstruct gpio_vibrator *vibrator = input_get_drvdata(dev);\n\tint level;\n\n\tlevel = effect->u.rumble.strong_magnitude;\n\tif (!level)\n\t\tlevel = effect->u.rumble.weak_magnitude;\n\n\tvibrator->running = level;\n\tschedule_work(&vibrator->play_work);\n\n\treturn 0;\n}\n\nstatic void gpio_vibrator_close(struct input_dev *input)\n{\n\tstruct gpio_vibrator *vibrator = input_get_drvdata(input);\n\n\tcancel_work_sync(&vibrator->play_work);\n\tgpio_vibrator_stop(vibrator);\n\tvibrator->running = false;\n}\n\nstatic int gpio_vibrator_probe(struct platform_device *pdev)\n{\n\tstruct gpio_vibrator *vibrator;\n\tint err;\n\n\tvibrator = devm_kzalloc(&pdev->dev, sizeof(*vibrator), GFP_KERNEL);\n\tif (!vibrator)\n\t\treturn -ENOMEM;\n\n\tvibrator->input = devm_input_allocate_device(&pdev->dev);\n\tif (!vibrator->input)\n\t\treturn -ENOMEM;\n\n\tvibrator->vcc = devm_regulator_get(&pdev->dev, \"vcc\");\n\tif (IS_ERR(vibrator->vcc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vibrator->vcc),\n\t\t\t\t     \"Failed to request regulator\\n\");\n\n\tvibrator->gpio = devm_gpiod_get(&pdev->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(vibrator->gpio))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(vibrator->gpio),\n\t\t\t\t     \"Failed to request main gpio\\n\");\n\n\tINIT_WORK(&vibrator->play_work, gpio_vibrator_play_work);\n\n\tvibrator->input->name = \"gpio-vibrator\";\n\tvibrator->input->id.bustype = BUS_HOST;\n\tvibrator->input->close = gpio_vibrator_close;\n\n\tinput_set_drvdata(vibrator->input, vibrator);\n\tinput_set_capability(vibrator->input, EV_FF, FF_RUMBLE);\n\n\terr = input_ff_create_memless(vibrator->input, NULL,\n\t\t\t\t      gpio_vibrator_play_effect);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Couldn't create FF dev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = input_register_device(vibrator->input);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Couldn't register input dev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, vibrator);\n\n\treturn 0;\n}\n\nstatic int gpio_vibrator_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct gpio_vibrator *vibrator = platform_get_drvdata(pdev);\n\n\tcancel_work_sync(&vibrator->play_work);\n\tif (vibrator->running)\n\t\tgpio_vibrator_stop(vibrator);\n\n\treturn 0;\n}\n\nstatic int gpio_vibrator_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct gpio_vibrator *vibrator = platform_get_drvdata(pdev);\n\n\tif (vibrator->running)\n\t\tgpio_vibrator_start(vibrator);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(gpio_vibrator_pm_ops,\n\t\t\t\tgpio_vibrator_suspend, gpio_vibrator_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id gpio_vibra_dt_match_table[] = {\n\t{ .compatible = \"gpio-vibrator\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, gpio_vibra_dt_match_table);\n#endif\n\nstatic struct platform_driver gpio_vibrator_driver = {\n\t.probe\t= gpio_vibrator_probe,\n\t.driver\t= {\n\t\t.name\t= \"gpio-vibrator\",\n\t\t.pm\t= pm_sleep_ptr(&gpio_vibrator_pm_ops),\n\t\t.of_match_table = of_match_ptr(gpio_vibra_dt_match_table),\n\t},\n};\nmodule_platform_driver(gpio_vibrator_driver);\n\nMODULE_AUTHOR(\"Luca Weiss <luca@z3ntu.xy>\");\nMODULE_DESCRIPTION(\"GPIO vibrator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gpio-vibrator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}