{
  "module_name": "soc_button_array.c",
  "hash_id": "cc3ffc6e57fcaa521d8c7ee8951eafa6f793fb29c3c23fd691340c10654e2918",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/soc_button_array.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio_keys.h>\n#include <linux/gpio.h>\n#include <linux/platform_device.h>\n\nstatic bool use_low_level_irq;\nmodule_param(use_low_level_irq, bool, 0444);\nMODULE_PARM_DESC(use_low_level_irq, \"Use low-level triggered IRQ instead of edge triggered\");\n\nstruct soc_button_info {\n\tconst char *name;\n\tint acpi_index;\n\tunsigned int event_type;\n\tunsigned int event_code;\n\tbool autorepeat;\n\tbool wakeup;\n\tbool active_low;\n};\n\nstruct soc_device_data {\n\tconst struct soc_button_info *button_info;\n\tint (*check)(struct device *dev);\n};\n\n \n#define BUTTON_TYPES\t2\n\nstruct soc_button_data {\n\tstruct platform_device *children[BUTTON_TYPES];\n};\n\n \nstatic const struct dmi_system_id dmi_use_low_level_irq[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire SW5-012\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SW5-017\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"One S1003\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"60073\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"1051\"),\n\t\t},\n\t},\n\t{}  \n};\n\n \nstatic const struct dmi_system_id dmi_invalid_acpi_index[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"CHERRYVIEW D1 PLATFORM\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_VERSION, \"YETI-11\"),\n\t\t},\n\t\t.driver_data = (void *)1l,\n\t},\n\t{}  \n};\n\n \nstatic int soc_button_lookup_gpio(struct device *dev, int acpi_index,\n\t\t\t\t  int *gpio_ret, int *irq_ret)\n{\n\tstruct gpio_desc *desc;\n\n\tdesc = gpiod_get_index(dev, NULL, acpi_index, GPIOD_ASIS);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\t*gpio_ret = desc_to_gpio(desc);\n\t*irq_ret = gpiod_to_irq(desc);\n\n\tgpiod_put(desc);\n\n\treturn 0;\n}\n\nstatic struct platform_device *\nsoc_button_device_create(struct platform_device *pdev,\n\t\t\t const struct soc_button_info *button_info,\n\t\t\t bool autorepeat)\n{\n\tconst struct soc_button_info *info;\n\tstruct platform_device *pd;\n\tstruct gpio_keys_button *gpio_keys;\n\tstruct gpio_keys_platform_data *gpio_keys_pdata;\n\tconst struct dmi_system_id *dmi_id;\n\tint invalid_acpi_index = -1;\n\tint error, gpio, irq;\n\tint n_buttons = 0;\n\n\tfor (info = button_info; info->name; info++)\n\t\tif (info->autorepeat == autorepeat)\n\t\t\tn_buttons++;\n\n\tgpio_keys_pdata = devm_kzalloc(&pdev->dev,\n\t\t\t\t       sizeof(*gpio_keys_pdata) +\n\t\t\t\t\tsizeof(*gpio_keys) * n_buttons,\n\t\t\t\t       GFP_KERNEL);\n\tif (!gpio_keys_pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgpio_keys = (void *)(gpio_keys_pdata + 1);\n\tn_buttons = 0;\n\n\tdmi_id = dmi_first_match(dmi_invalid_acpi_index);\n\tif (dmi_id)\n\t\tinvalid_acpi_index = (long)dmi_id->driver_data;\n\n\tfor (info = button_info; info->name; info++) {\n\t\tif (info->autorepeat != autorepeat)\n\t\t\tcontinue;\n\n\t\tif (info->acpi_index == invalid_acpi_index)\n\t\t\tcontinue;\n\n\t\terror = soc_button_lookup_gpio(&pdev->dev, info->acpi_index, &gpio, &irq);\n\t\tif (error || irq < 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!autorepeat && (use_low_level_irq ||\n\t\t\t\t    dmi_check_system(dmi_use_low_level_irq))) {\n\t\t\tirq_set_irq_type(irq, IRQ_TYPE_LEVEL_LOW);\n\t\t\tgpio_keys[n_buttons].irq = irq;\n\t\t\tgpio_keys[n_buttons].gpio = -ENOENT;\n\t\t} else {\n\t\t\tgpio_keys[n_buttons].gpio = gpio;\n\t\t}\n\n\t\tgpio_keys[n_buttons].type = info->event_type;\n\t\tgpio_keys[n_buttons].code = info->event_code;\n\t\tgpio_keys[n_buttons].active_low = info->active_low;\n\t\tgpio_keys[n_buttons].desc = info->name;\n\t\tgpio_keys[n_buttons].wakeup = info->wakeup;\n\t\t \n\t\tgpio_keys[n_buttons].debounce_interval = 50;\n\t\tn_buttons++;\n\t}\n\n\tif (n_buttons == 0) {\n\t\terror = -ENODEV;\n\t\tgoto err_free_mem;\n\t}\n\n\tgpio_keys_pdata->buttons = gpio_keys;\n\tgpio_keys_pdata->nbuttons = n_buttons;\n\tgpio_keys_pdata->rep = autorepeat;\n\n\tpd = platform_device_register_resndata(&pdev->dev, \"gpio-keys\",\n\t\t\t\t\t       PLATFORM_DEVID_AUTO, NULL, 0,\n\t\t\t\t\t       gpio_keys_pdata,\n\t\t\t\t\t       sizeof(*gpio_keys_pdata));\n\terror = PTR_ERR_OR_ZERO(pd);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed registering gpio-keys: %d\\n\", error);\n\t\tgoto err_free_mem;\n\t}\n\n\treturn pd;\n\nerr_free_mem:\n\tdevm_kfree(&pdev->dev, gpio_keys_pdata);\n\treturn ERR_PTR(error);\n}\n\nstatic int soc_button_get_acpi_object_int(const union acpi_object *obj)\n{\n\tif (obj->type != ACPI_TYPE_INTEGER)\n\t\treturn -1;\n\n\treturn obj->integer.value;\n}\n\n \nstatic int soc_button_parse_btn_desc(struct device *dev,\n\t\t\t\t     const union acpi_object *desc,\n\t\t\t\t     int collection_uid,\n\t\t\t\t     struct soc_button_info *info)\n{\n\tint upage, usage;\n\n\tif (desc->type != ACPI_TYPE_PACKAGE ||\n\t    desc->package.count != 5 ||\n\t     \n\t    soc_button_get_acpi_object_int(&desc->package.elements[0]) != 1 ||\n\t     \n\t    soc_button_get_acpi_object_int(&desc->package.elements[2]) !=\n\t\t\t\t\t\t\t    collection_uid) {\n\t\tdev_err(dev, \"Invalid ACPI Button Descriptor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->event_type = EV_KEY;\n\tinfo->active_low = true;\n\tinfo->acpi_index =\n\t\tsoc_button_get_acpi_object_int(&desc->package.elements[1]);\n\tupage = soc_button_get_acpi_object_int(&desc->package.elements[3]);\n\tusage = soc_button_get_acpi_object_int(&desc->package.elements[4]);\n\n\t \n\tif (upage == 0x01 && usage == 0x81) {\n\t\tinfo->name = \"power\";\n\t\tinfo->event_code = KEY_POWER;\n\t\tinfo->wakeup = true;\n\t} else if (upage == 0x01 && usage == 0xc6) {\n\t\tinfo->name = \"airplane mode switch\";\n\t\tinfo->event_type = EV_SW;\n\t\tinfo->event_code = SW_RFKILL_ALL;\n\t\tinfo->active_low = false;\n\t} else if (upage == 0x01 && usage == 0xca) {\n\t\tinfo->name = \"rotation lock switch\";\n\t\tinfo->event_type = EV_SW;\n\t\tinfo->event_code = SW_ROTATE_LOCK;\n\t} else if (upage == 0x07 && usage == 0xe3) {\n\t\tinfo->name = \"home\";\n\t\tinfo->event_code = KEY_LEFTMETA;\n\t\tinfo->wakeup = true;\n\t} else if (upage == 0x0c && usage == 0xe9) {\n\t\tinfo->name = \"volume_up\";\n\t\tinfo->event_code = KEY_VOLUMEUP;\n\t\tinfo->autorepeat = true;\n\t} else if (upage == 0x0c && usage == 0xea) {\n\t\tinfo->name = \"volume_down\";\n\t\tinfo->event_code = KEY_VOLUMEDOWN;\n\t\tinfo->autorepeat = true;\n\t} else {\n\t\tdev_warn(dev, \"Unknown button index %d upage %02x usage %02x, ignoring\\n\",\n\t\t\t info->acpi_index, upage, usage);\n\t\tinfo->name = \"unknown\";\n\t\tinfo->event_code = KEY_RESERVED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const u8 btns_desc_uuid[16] = {\n\t0x25, 0xd6, 0x6b, 0xfa, 0xe8, 0x9c, 0x0d, 0x47,\n\t0xa2, 0xc7, 0xb3, 0xca, 0x36, 0xc4, 0x28, 0x2e\n};\n\n \nstatic struct soc_button_info *soc_button_get_button_info(struct device *dev)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\n\tconst union acpi_object *desc, *el0, *uuid, *btns_desc = NULL;\n\tstruct soc_button_info *button_info;\n\tacpi_status status;\n\tint i, btn, collection_uid = -1;\n\n\tstatus = acpi_evaluate_object_typed(ACPI_HANDLE(dev), \"_DSD\", NULL,\n\t\t\t\t\t    &buf, ACPI_TYPE_PACKAGE);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"ACPI _DSD object not found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tdesc = buf.pointer;\n\tfor (i = 0; (i + 1) < desc->package.count; i += 2) {\n\t\tuuid = &desc->package.elements[i];\n\n\t\tif (uuid->type != ACPI_TYPE_BUFFER ||\n\t\t    uuid->buffer.length != 16 ||\n\t\t    desc->package.elements[i + 1].type != ACPI_TYPE_PACKAGE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memcmp(uuid->buffer.pointer, btns_desc_uuid, 16) == 0) {\n\t\t\tbtns_desc = &desc->package.elements[i + 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!btns_desc) {\n\t\tdev_err(dev, \"ACPI Button Descriptors not found\\n\");\n\t\tbutton_info = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t}\n\n\t \n\tel0 = &btns_desc->package.elements[0];\n\tif (el0->type == ACPI_TYPE_PACKAGE &&\n\t    el0->package.count == 5 &&\n\t     \n\t    soc_button_get_acpi_object_int(&el0->package.elements[0]) == 0 &&\n\t     \n\t    soc_button_get_acpi_object_int(&el0->package.elements[2]) == 0) {\n\t\tcollection_uid = soc_button_get_acpi_object_int(\n\t\t\t\t\t\t&el0->package.elements[1]);\n\t}\n\tif (collection_uid == -1) {\n\t\tdev_err(dev, \"Invalid Button Collection Descriptor\\n\");\n\t\tbutton_info = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t}\n\n\t \n\tbutton_info = devm_kcalloc(dev, btns_desc->package.count,\n\t\t\t\t   sizeof(*button_info), GFP_KERNEL);\n\tif (!button_info) {\n\t\tbutton_info = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 1, btn = 0; i < btns_desc->package.count; i++, btn++) {\n\t\tif (soc_button_parse_btn_desc(dev,\n\t\t\t\t\t      &btns_desc->package.elements[i],\n\t\t\t\t\t      collection_uid,\n\t\t\t\t\t      &button_info[btn])) {\n\t\t\tbutton_info = ERR_PTR(-ENODEV);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tkfree(buf.pointer);\n\treturn button_info;\n}\n\nstatic int soc_button_remove(struct platform_device *pdev)\n{\n\tstruct soc_button_data *priv = platform_get_drvdata(pdev);\n\n\tint i;\n\n\tfor (i = 0; i < BUTTON_TYPES; i++)\n\t\tif (priv->children[i])\n\t\t\tplatform_device_unregister(priv->children[i]);\n\n\treturn 0;\n}\n\nstatic int soc_button_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct soc_device_data *device_data;\n\tconst struct soc_button_info *button_info;\n\tstruct soc_button_data *priv;\n\tstruct platform_device *pd;\n\tint i;\n\tint error;\n\n\tdevice_data = acpi_device_get_match_data(dev);\n\tif (device_data && device_data->check) {\n\t\terror = device_data->check(dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (device_data && device_data->button_info) {\n\t\tbutton_info = device_data->button_info;\n\t} else {\n\t\tbutton_info = soc_button_get_button_info(dev);\n\t\tif (IS_ERR(button_info))\n\t\t\treturn PTR_ERR(button_info);\n\t}\n\n\terror = gpiod_count(dev, NULL);\n\tif (error < 0) {\n\t\tdev_dbg(dev, \"no GPIO attached, ignoring...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tfor (i = 0; i < BUTTON_TYPES; i++) {\n\t\tpd = soc_button_device_create(pdev, button_info, i == 0);\n\t\tif (IS_ERR(pd)) {\n\t\t\terror = PTR_ERR(pd);\n\t\t\tif (error != -ENODEV) {\n\t\t\t\tsoc_button_remove(pdev);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv->children[i] = pd;\n\t}\n\n\tif (!priv->children[0] && !priv->children[1])\n\t\treturn -ENODEV;\n\n\tif (!device_data || !device_data->button_info)\n\t\tdevm_kfree(dev, button_info);\n\n\treturn 0;\n}\n\n \nstatic const struct soc_button_info soc_button_PNP0C40[] = {\n\t{ \"power\", 0, EV_KEY, KEY_POWER, false, true, true },\n\t{ \"home\", 1, EV_KEY, KEY_LEFTMETA, false, true, true },\n\t{ \"volume_up\", 2, EV_KEY, KEY_VOLUMEUP, true, false, true },\n\t{ \"volume_down\", 3, EV_KEY, KEY_VOLUMEDOWN, true, false, true },\n\t{ \"rotation_lock\", 4, EV_KEY, KEY_ROTATE_LOCK_TOGGLE, false, false, true },\n\t{ }\n};\n\nstatic const struct soc_device_data soc_device_PNP0C40 = {\n\t.button_info = soc_button_PNP0C40,\n};\n\nstatic const struct soc_button_info soc_button_INT33D3[] = {\n\t{ \"tablet_mode\", 0, EV_SW, SW_TABLET_MODE, false, false, false },\n\t{ }\n};\n\nstatic const struct soc_device_data soc_device_INT33D3 = {\n\t.button_info = soc_button_INT33D3,\n};\n\n \nstatic const struct soc_button_info soc_button_MSHW0028[] = {\n\t{ \"power\", 0, EV_KEY, KEY_POWER, false, true, true },\n\t{ \"home\", 1, EV_KEY, KEY_LEFTMETA, false, true, false },\n\t{ \"volume_up\", 2, EV_KEY, KEY_VOLUMEUP, true, false, true },\n\t{ \"volume_down\", 3, EV_KEY, KEY_VOLUMEDOWN, true, false, true },\n\t{ }\n};\n\nstatic const struct soc_device_data soc_device_MSHW0028 = {\n\t.button_info = soc_button_MSHW0028,\n};\n\n \n#define MSHW0040_DSM_REVISION\t\t0x01\n#define MSHW0040_DSM_GET_OMPR\t\t0x02\t\nstatic const guid_t MSHW0040_DSM_UUID =\n\tGUID_INIT(0x6fd05c69, 0xcde3, 0x49f4, 0x95, 0xed, 0xab, 0x16, 0x65,\n\t\t  0x49, 0x80, 0x35);\n\nstatic int soc_device_check_MSHW0040(struct device *dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object *result;\n\tu64 oem_platform_rev = 0;\t\n\n\t\n\tresult = acpi_evaluate_dsm_typed(handle, &MSHW0040_DSM_UUID,\n\t\t\t\t\t MSHW0040_DSM_REVISION,\n\t\t\t\t\t MSHW0040_DSM_GET_OMPR, NULL,\n\t\t\t\t\t ACPI_TYPE_INTEGER);\n\n\tif (result) {\n\t\toem_platform_rev = result->integer.value;\n\t\tACPI_FREE(result);\n\t}\n\n\t \n\tif (oem_platform_rev == 0)\n\t\treturn -ENODEV;\n\n\tdev_dbg(dev, \"OEM Platform Revision %llu\\n\", oem_platform_rev);\n\n\treturn 0;\n}\n\n \nstatic const struct soc_button_info soc_button_MSHW0040[] = {\n\t{ \"power\", 0, EV_KEY, KEY_POWER, false, true, true },\n\t{ \"volume_up\", 2, EV_KEY, KEY_VOLUMEUP, true, false, true },\n\t{ \"volume_down\", 4, EV_KEY, KEY_VOLUMEDOWN, true, false, true },\n\t{ }\n};\n\nstatic const struct soc_device_data soc_device_MSHW0040 = {\n\t.button_info = soc_button_MSHW0040,\n\t.check = soc_device_check_MSHW0040,\n};\n\nstatic const struct acpi_device_id soc_button_acpi_match[] = {\n\t{ \"PNP0C40\", (unsigned long)&soc_device_PNP0C40 },\n\t{ \"INT33D3\", (unsigned long)&soc_device_INT33D3 },\n\t{ \"ID9001\", (unsigned long)&soc_device_INT33D3 },\n\t{ \"ACPI0011\", 0 },\n\n\t \n\t{ \"MSHW0028\", (unsigned long)&soc_device_MSHW0028 },\n\t{ \"MSHW0040\", (unsigned long)&soc_device_MSHW0040 },\n\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(acpi, soc_button_acpi_match);\n\nstatic struct platform_driver soc_button_driver = {\n\t.probe          = soc_button_probe,\n\t.remove\t\t= soc_button_remove,\n\t.driver\t\t= {\n\t\t.name = KBUILD_MODNAME,\n\t\t.acpi_match_table = ACPI_PTR(soc_button_acpi_match),\n\t},\n};\nmodule_platform_driver(soc_button_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}