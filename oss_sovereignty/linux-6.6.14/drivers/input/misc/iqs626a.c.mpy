{
  "module_name": "iqs626a.c",
  "hash_id": "4e5b27999cedf1ae65db12a5b5a3442e63d3bceb71408cc33c249cfd0cfb24f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/iqs626a.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define IQS626_VER_INFO\t\t\t\t0x00\n#define IQS626_VER_INFO_PROD_NUM\t\t0x51\n\n#define IQS626_SYS_FLAGS\t\t\t0x02\n#define IQS626_SYS_FLAGS_SHOW_RESET\t\tBIT(15)\n#define IQS626_SYS_FLAGS_IN_ATI\t\t\tBIT(12)\n#define IQS626_SYS_FLAGS_PWR_MODE_MASK\t\tGENMASK(9, 8)\n#define IQS626_SYS_FLAGS_PWR_MODE_SHIFT\t\t8\n\n#define IQS626_HALL_OUTPUT\t\t\t0x23\n\n#define IQS626_SYS_SETTINGS\t\t\t0x80\n#define IQS626_SYS_SETTINGS_CLK_DIV\t\tBIT(15)\n#define IQS626_SYS_SETTINGS_ULP_AUTO\t\tBIT(14)\n#define IQS626_SYS_SETTINGS_DIS_AUTO\t\tBIT(13)\n#define IQS626_SYS_SETTINGS_PWR_MODE_MASK\tGENMASK(12, 11)\n#define IQS626_SYS_SETTINGS_PWR_MODE_SHIFT\t11\n#define IQS626_SYS_SETTINGS_PWR_MODE_MAX\t3\n#define IQS626_SYS_SETTINGS_ULP_UPDATE_MASK\tGENMASK(10, 8)\n#define IQS626_SYS_SETTINGS_ULP_UPDATE_SHIFT\t8\n#define IQS626_SYS_SETTINGS_ULP_UPDATE_MAX\t7\n#define IQS626_SYS_SETTINGS_EVENT_MODE\t\tBIT(5)\n#define IQS626_SYS_SETTINGS_EVENT_MODE_LP\tBIT(4)\n#define IQS626_SYS_SETTINGS_REDO_ATI\t\tBIT(2)\n#define IQS626_SYS_SETTINGS_ACK_RESET\t\tBIT(0)\n\n#define IQS626_MISC_A_ATI_BAND_DISABLE\t\tBIT(7)\n#define IQS626_MISC_A_TPx_LTA_UPDATE_MASK\tGENMASK(6, 4)\n#define IQS626_MISC_A_TPx_LTA_UPDATE_SHIFT\t4\n#define IQS626_MISC_A_TPx_LTA_UPDATE_MAX\t7\n#define IQS626_MISC_A_ATI_LP_ONLY\t\tBIT(3)\n#define IQS626_MISC_A_GPIO3_SELECT_MASK\t\tGENMASK(2, 0)\n#define IQS626_MISC_A_GPIO3_SELECT_MAX\t\t7\n\n#define IQS626_EVENT_MASK_SYS\t\t\tBIT(6)\n#define IQS626_EVENT_MASK_GESTURE\t\tBIT(3)\n#define IQS626_EVENT_MASK_DEEP\t\t\tBIT(2)\n#define IQS626_EVENT_MASK_TOUCH\t\t\tBIT(1)\n#define IQS626_EVENT_MASK_PROX\t\t\tBIT(0)\n\n#define IQS626_RATE_NP_MS_MAX\t\t\t255\n#define IQS626_RATE_LP_MS_MAX\t\t\t255\n#define IQS626_RATE_ULP_MS_MAX\t\t\t4080\n#define IQS626_TIMEOUT_PWR_MS_MAX\t\t130560\n#define IQS626_TIMEOUT_LTA_MS_MAX\t\t130560\n\n#define IQS626_MISC_B_RESEED_UI_SEL_MASK\tGENMASK(7, 6)\n#define IQS626_MISC_B_RESEED_UI_SEL_SHIFT\t6\n#define IQS626_MISC_B_RESEED_UI_SEL_MAX\t\t3\n#define IQS626_MISC_B_THRESH_EXTEND\t\tBIT(5)\n#define IQS626_MISC_B_TRACKING_UI_ENABLE\tBIT(4)\n#define IQS626_MISC_B_TPx_SWIPE\t\t\tBIT(3)\n#define IQS626_MISC_B_RESEED_OFFSET\t\tBIT(2)\n#define IQS626_MISC_B_FILT_STR_TPx\t\tGENMASK(1, 0)\n\n#define IQS626_THRESH_SWIPE_MAX\t\t\t255\n#define IQS626_TIMEOUT_TAP_MS_MAX\t\t4080\n#define IQS626_TIMEOUT_SWIPE_MS_MAX\t\t4080\n\n#define IQS626_CHx_ENG_0_MEAS_CAP_SIZE\t\tBIT(7)\n#define IQS626_CHx_ENG_0_RX_TERM_VSS\t\tBIT(5)\n#define IQS626_CHx_ENG_0_LINEARIZE\t\tBIT(4)\n#define IQS626_CHx_ENG_0_DUAL_DIR\t\tBIT(3)\n#define IQS626_CHx_ENG_0_FILT_DISABLE\t\tBIT(2)\n#define IQS626_CHx_ENG_0_ATI_MODE_MASK\t\tGENMASK(1, 0)\n#define IQS626_CHx_ENG_0_ATI_MODE_MAX\t\t3\n\n#define IQS626_CHx_ENG_1_CCT_HIGH_1\t\tBIT(7)\n#define IQS626_CHx_ENG_1_CCT_HIGH_0\t\tBIT(6)\n#define IQS626_CHx_ENG_1_PROJ_BIAS_MASK\t\tGENMASK(5, 4)\n#define IQS626_CHx_ENG_1_PROJ_BIAS_SHIFT\t4\n#define IQS626_CHx_ENG_1_PROJ_BIAS_MAX\t\t3\n#define IQS626_CHx_ENG_1_CCT_ENABLE\t\tBIT(3)\n#define IQS626_CHx_ENG_1_SENSE_FREQ_MASK\tGENMASK(2, 1)\n#define IQS626_CHx_ENG_1_SENSE_FREQ_SHIFT\t1\n#define IQS626_CHx_ENG_1_SENSE_FREQ_MAX\t\t3\n#define IQS626_CHx_ENG_1_ATI_BAND_TIGHTEN\tBIT(0)\n\n#define IQS626_CHx_ENG_2_LOCAL_CAP_MASK\t\tGENMASK(7, 6)\n#define IQS626_CHx_ENG_2_LOCAL_CAP_SHIFT\t6\n#define IQS626_CHx_ENG_2_LOCAL_CAP_MAX\t\t3\n#define IQS626_CHx_ENG_2_LOCAL_CAP_ENABLE\tBIT(5)\n#define IQS626_CHx_ENG_2_SENSE_MODE_MASK\tGENMASK(3, 0)\n#define IQS626_CHx_ENG_2_SENSE_MODE_MAX\t\t15\n\n#define IQS626_CHx_ENG_3_TX_FREQ_MASK\t\tGENMASK(5, 4)\n#define IQS626_CHx_ENG_3_TX_FREQ_SHIFT\t\t4\n#define IQS626_CHx_ENG_3_TX_FREQ_MAX\t\t3\n#define IQS626_CHx_ENG_3_INV_LOGIC\t\tBIT(0)\n\n#define IQS626_CHx_ENG_4_RX_TERM_VREG\t\tBIT(6)\n#define IQS626_CHx_ENG_4_CCT_LOW_1\t\tBIT(5)\n#define IQS626_CHx_ENG_4_CCT_LOW_0\t\tBIT(4)\n#define IQS626_CHx_ENG_4_COMP_DISABLE\t\tBIT(1)\n#define IQS626_CHx_ENG_4_STATIC_ENABLE\t\tBIT(0)\n\n#define IQS626_TPx_ATI_BASE_MIN\t\t\t45\n#define IQS626_TPx_ATI_BASE_MAX\t\t\t300\n#define IQS626_CHx_ATI_BASE_MASK\t\tGENMASK(7, 6)\n#define IQS626_CHx_ATI_BASE_75\t\t\t0x00\n#define IQS626_CHx_ATI_BASE_100\t\t\t0x40\n#define IQS626_CHx_ATI_BASE_150\t\t\t0x80\n#define IQS626_CHx_ATI_BASE_200\t\t\t0xC0\n#define IQS626_CHx_ATI_TARGET_MASK\t\tGENMASK(5, 0)\n#define IQS626_CHx_ATI_TARGET_MAX\t\t2016\n\n#define IQS626_CHx_THRESH_MAX\t\t\t255\n#define IQS626_CHx_HYST_DEEP_MASK\t\tGENMASK(7, 4)\n#define IQS626_CHx_HYST_DEEP_SHIFT\t\t4\n#define IQS626_CHx_HYST_TOUCH_MASK\t\tGENMASK(3, 0)\n#define IQS626_CHx_HYST_MAX\t\t\t15\n\n#define IQS626_FILT_STR_NP_TPx_MASK\t\tGENMASK(7, 6)\n#define IQS626_FILT_STR_NP_TPx_SHIFT\t\t6\n#define IQS626_FILT_STR_LP_TPx_MASK\t\tGENMASK(5, 4)\n#define IQS626_FILT_STR_LP_TPx_SHIFT\t\t4\n\n#define IQS626_FILT_STR_NP_CNT_MASK\t\tGENMASK(7, 6)\n#define IQS626_FILT_STR_NP_CNT_SHIFT\t\t6\n#define IQS626_FILT_STR_LP_CNT_MASK\t\tGENMASK(5, 4)\n#define IQS626_FILT_STR_LP_CNT_SHIFT\t\t4\n#define IQS626_FILT_STR_NP_LTA_MASK\t\tGENMASK(3, 2)\n#define IQS626_FILT_STR_NP_LTA_SHIFT\t\t2\n#define IQS626_FILT_STR_LP_LTA_MASK\t\tGENMASK(1, 0)\n#define IQS626_FILT_STR_MAX\t\t\t3\n\n#define IQS626_ULP_PROJ_ENABLE\t\t\tBIT(4)\n#define IQS626_GEN_WEIGHT_MAX\t\t\t255\n\n#define IQS626_MAX_REG\t\t\t\t0xFF\n\n#define IQS626_NUM_CH_TP_3\t\t\t9\n#define IQS626_NUM_CH_TP_2\t\t\t6\n#define IQS626_NUM_CH_GEN\t\t\t3\n#define IQS626_NUM_CRx_TX\t\t\t8\n\n#define IQS626_PWR_MODE_POLL_SLEEP_US\t\t50000\n#define IQS626_PWR_MODE_POLL_TIMEOUT_US\t\t500000\n\n#define iqs626_irq_wait()\t\t\tusleep_range(350, 400)\n\nenum iqs626_ch_id {\n\tIQS626_CH_ULP_0,\n\tIQS626_CH_TP_2,\n\tIQS626_CH_TP_3,\n\tIQS626_CH_GEN_0,\n\tIQS626_CH_GEN_1,\n\tIQS626_CH_GEN_2,\n\tIQS626_CH_HALL,\n};\n\nenum iqs626_rx_inactive {\n\tIQS626_RX_INACTIVE_VSS,\n\tIQS626_RX_INACTIVE_FLOAT,\n\tIQS626_RX_INACTIVE_VREG,\n};\n\nenum iqs626_st_offs {\n\tIQS626_ST_OFFS_PROX,\n\tIQS626_ST_OFFS_DIR,\n\tIQS626_ST_OFFS_TOUCH,\n\tIQS626_ST_OFFS_DEEP,\n};\n\nenum iqs626_th_offs {\n\tIQS626_TH_OFFS_PROX,\n\tIQS626_TH_OFFS_TOUCH,\n\tIQS626_TH_OFFS_DEEP,\n};\n\nenum iqs626_event_id {\n\tIQS626_EVENT_PROX_DN,\n\tIQS626_EVENT_PROX_UP,\n\tIQS626_EVENT_TOUCH_DN,\n\tIQS626_EVENT_TOUCH_UP,\n\tIQS626_EVENT_DEEP_DN,\n\tIQS626_EVENT_DEEP_UP,\n};\n\nenum iqs626_gesture_id {\n\tIQS626_GESTURE_FLICK_X_POS,\n\tIQS626_GESTURE_FLICK_X_NEG,\n\tIQS626_GESTURE_FLICK_Y_POS,\n\tIQS626_GESTURE_FLICK_Y_NEG,\n\tIQS626_GESTURE_TAP,\n\tIQS626_GESTURE_HOLD,\n\tIQS626_NUM_GESTURES,\n};\n\nstruct iqs626_event_desc {\n\tconst char *name;\n\tenum iqs626_st_offs st_offs;\n\tenum iqs626_th_offs th_offs;\n\tbool dir_up;\n\tu8 mask;\n};\n\nstatic const struct iqs626_event_desc iqs626_events[] = {\n\t[IQS626_EVENT_PROX_DN] = {\n\t\t.name = \"event-prox\",\n\t\t.st_offs = IQS626_ST_OFFS_PROX,\n\t\t.th_offs = IQS626_TH_OFFS_PROX,\n\t\t.mask = IQS626_EVENT_MASK_PROX,\n\t},\n\t[IQS626_EVENT_PROX_UP] = {\n\t\t.name = \"event-prox-alt\",\n\t\t.st_offs = IQS626_ST_OFFS_PROX,\n\t\t.th_offs = IQS626_TH_OFFS_PROX,\n\t\t.dir_up = true,\n\t\t.mask = IQS626_EVENT_MASK_PROX,\n\t},\n\t[IQS626_EVENT_TOUCH_DN] = {\n\t\t.name = \"event-touch\",\n\t\t.st_offs = IQS626_ST_OFFS_TOUCH,\n\t\t.th_offs = IQS626_TH_OFFS_TOUCH,\n\t\t.mask = IQS626_EVENT_MASK_TOUCH,\n\t},\n\t[IQS626_EVENT_TOUCH_UP] = {\n\t\t.name = \"event-touch-alt\",\n\t\t.st_offs = IQS626_ST_OFFS_TOUCH,\n\t\t.th_offs = IQS626_TH_OFFS_TOUCH,\n\t\t.dir_up = true,\n\t\t.mask = IQS626_EVENT_MASK_TOUCH,\n\t},\n\t[IQS626_EVENT_DEEP_DN] = {\n\t\t.name = \"event-deep\",\n\t\t.st_offs = IQS626_ST_OFFS_DEEP,\n\t\t.th_offs = IQS626_TH_OFFS_DEEP,\n\t\t.mask = IQS626_EVENT_MASK_DEEP,\n\t},\n\t[IQS626_EVENT_DEEP_UP] = {\n\t\t.name = \"event-deep-alt\",\n\t\t.st_offs = IQS626_ST_OFFS_DEEP,\n\t\t.th_offs = IQS626_TH_OFFS_DEEP,\n\t\t.dir_up = true,\n\t\t.mask = IQS626_EVENT_MASK_DEEP,\n\t},\n};\n\nstruct iqs626_ver_info {\n\tu8 prod_num;\n\tu8 sw_num;\n\tu8 hw_num;\n\tu8 padding;\n} __packed;\n\nstruct iqs626_flags {\n\t__be16 system;\n\tu8 gesture;\n\tu8 padding_a;\n\tu8 states[4];\n\tu8 ref_active;\n\tu8 padding_b;\n\tu8 comp_min;\n\tu8 comp_max;\n\tu8 trackpad_x;\n\tu8 trackpad_y;\n} __packed;\n\nstruct iqs626_ch_reg_ulp {\n\tu8 thresh[2];\n\tu8 hyst;\n\tu8 filter;\n\tu8 engine[2];\n\tu8 ati_target;\n\tu8 padding;\n\t__be16 ati_comp;\n\tu8 rx_enable;\n\tu8 tx_enable;\n} __packed;\n\nstruct iqs626_ch_reg_tp {\n\tu8 thresh;\n\tu8 ati_base;\n\t__be16 ati_comp;\n} __packed;\n\nstruct iqs626_tp_grp_reg {\n\tu8 hyst;\n\tu8 ati_target;\n\tu8 engine[2];\n\tstruct iqs626_ch_reg_tp ch_reg_tp[IQS626_NUM_CH_TP_3];\n} __packed;\n\nstruct iqs626_ch_reg_gen {\n\tu8 thresh[3];\n\tu8 padding;\n\tu8 hyst;\n\tu8 ati_target;\n\t__be16 ati_comp;\n\tu8 engine[5];\n\tu8 filter;\n\tu8 rx_enable;\n\tu8 tx_enable;\n\tu8 assoc_select;\n\tu8 assoc_weight;\n} __packed;\n\nstruct iqs626_ch_reg_hall {\n\tu8 engine;\n\tu8 thresh;\n\tu8 hyst;\n\tu8 ati_target;\n\t__be16 ati_comp;\n} __packed;\n\nstruct iqs626_sys_reg {\n\t__be16 general;\n\tu8 misc_a;\n\tu8 event_mask;\n\tu8 active;\n\tu8 reseed;\n\tu8 rate_np;\n\tu8 rate_lp;\n\tu8 rate_ulp;\n\tu8 timeout_pwr;\n\tu8 timeout_rdy;\n\tu8 timeout_lta;\n\tu8 misc_b;\n\tu8 thresh_swipe;\n\tu8 timeout_tap;\n\tu8 timeout_swipe;\n\tu8 redo_ati;\n\tu8 padding;\n\tstruct iqs626_ch_reg_ulp ch_reg_ulp;\n\tstruct iqs626_tp_grp_reg tp_grp_reg;\n\tstruct iqs626_ch_reg_gen ch_reg_gen[IQS626_NUM_CH_GEN];\n\tstruct iqs626_ch_reg_hall ch_reg_hall;\n} __packed;\n\nstruct iqs626_channel_desc {\n\tconst char *name;\n\tint num_ch;\n\tu8 active;\n\tbool events[ARRAY_SIZE(iqs626_events)];\n};\n\nstatic const struct iqs626_channel_desc iqs626_channels[] = {\n\t[IQS626_CH_ULP_0] = {\n\t\t.name = \"ulp-0\",\n\t\t.num_ch = 1,\n\t\t.active = BIT(0),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_PROX_DN] = true,\n\t\t\t[IQS626_EVENT_PROX_UP] = true,\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t\t[IQS626_EVENT_TOUCH_UP] = true,\n\t\t},\n\t},\n\t[IQS626_CH_TP_2] = {\n\t\t.name = \"trackpad-3x2\",\n\t\t.num_ch = IQS626_NUM_CH_TP_2,\n\t\t.active = BIT(1),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t},\n\t},\n\t[IQS626_CH_TP_3] = {\n\t\t.name = \"trackpad-3x3\",\n\t\t.num_ch = IQS626_NUM_CH_TP_3,\n\t\t.active = BIT(2) | BIT(1),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t},\n\t},\n\t[IQS626_CH_GEN_0] = {\n\t\t.name = \"generic-0\",\n\t\t.num_ch = 1,\n\t\t.active = BIT(4),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_PROX_DN] = true,\n\t\t\t[IQS626_EVENT_PROX_UP] = true,\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t\t[IQS626_EVENT_TOUCH_UP] = true,\n\t\t\t[IQS626_EVENT_DEEP_DN] = true,\n\t\t\t[IQS626_EVENT_DEEP_UP] = true,\n\t\t},\n\t},\n\t[IQS626_CH_GEN_1] = {\n\t\t.name = \"generic-1\",\n\t\t.num_ch = 1,\n\t\t.active = BIT(5),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_PROX_DN] = true,\n\t\t\t[IQS626_EVENT_PROX_UP] = true,\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t\t[IQS626_EVENT_TOUCH_UP] = true,\n\t\t\t[IQS626_EVENT_DEEP_DN] = true,\n\t\t\t[IQS626_EVENT_DEEP_UP] = true,\n\t\t},\n\t},\n\t[IQS626_CH_GEN_2] = {\n\t\t.name = \"generic-2\",\n\t\t.num_ch = 1,\n\t\t.active = BIT(6),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_PROX_DN] = true,\n\t\t\t[IQS626_EVENT_PROX_UP] = true,\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t\t[IQS626_EVENT_TOUCH_UP] = true,\n\t\t\t[IQS626_EVENT_DEEP_DN] = true,\n\t\t\t[IQS626_EVENT_DEEP_UP] = true,\n\t\t},\n\t},\n\t[IQS626_CH_HALL] = {\n\t\t.name = \"hall\",\n\t\t.num_ch = 1,\n\t\t.active = BIT(7),\n\t\t.events = {\n\t\t\t[IQS626_EVENT_TOUCH_DN] = true,\n\t\t\t[IQS626_EVENT_TOUCH_UP] = true,\n\t\t},\n\t},\n};\n\nstruct iqs626_private {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct iqs626_sys_reg sys_reg;\n\tstruct completion ati_done;\n\tstruct input_dev *keypad;\n\tstruct input_dev *trackpad;\n\tstruct touchscreen_properties prop;\n\tunsigned int kp_type[ARRAY_SIZE(iqs626_channels)]\n\t\t\t    [ARRAY_SIZE(iqs626_events)];\n\tunsigned int kp_code[ARRAY_SIZE(iqs626_channels)]\n\t\t\t    [ARRAY_SIZE(iqs626_events)];\n\tunsigned int tp_code[IQS626_NUM_GESTURES];\n\tunsigned int suspend_mode;\n};\n\nstatic noinline_for_stack int\niqs626_parse_events(struct iqs626_private *iqs626,\n\t\t    struct fwnode_handle *ch_node, enum iqs626_ch_id ch_id)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tstruct fwnode_handle *ev_node;\n\tconst char *ev_name;\n\tu8 *thresh, *hyst;\n\tunsigned int val;\n\tint i;\n\n\tswitch (ch_id) {\n\tcase IQS626_CH_ULP_0:\n\t\tthresh = sys_reg->ch_reg_ulp.thresh;\n\t\thyst = &sys_reg->ch_reg_ulp.hyst;\n\t\tbreak;\n\n\tcase IQS626_CH_TP_2:\n\tcase IQS626_CH_TP_3:\n\t\tthresh = &sys_reg->tp_grp_reg.ch_reg_tp[0].thresh;\n\t\thyst = &sys_reg->tp_grp_reg.hyst;\n\t\tbreak;\n\n\tcase IQS626_CH_GEN_0:\n\tcase IQS626_CH_GEN_1:\n\tcase IQS626_CH_GEN_2:\n\t\ti = ch_id - IQS626_CH_GEN_0;\n\t\tthresh = sys_reg->ch_reg_gen[i].thresh;\n\t\thyst = &sys_reg->ch_reg_gen[i].hyst;\n\t\tbreak;\n\n\tcase IQS626_CH_HALL:\n\t\tthresh = &sys_reg->ch_reg_hall.thresh;\n\t\thyst = &sys_reg->ch_reg_hall.hyst;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs626_events); i++) {\n\t\tif (!iqs626_channels[ch_id].events[i])\n\t\t\tcontinue;\n\n\t\tif (ch_id == IQS626_CH_TP_2 || ch_id == IQS626_CH_TP_3) {\n\t\t\t \n\t\t\tev_node = fwnode_handle_get(ch_node);\n\t\t} else {\n\t\t\tev_name = iqs626_events[i].name;\n\t\t\tev_node = fwnode_get_named_child_node(ch_node, ev_name);\n\t\t\tif (!ev_node)\n\t\t\t\tcontinue;\n\n\t\t\tif (!fwnode_property_read_u32(ev_node, \"linux,code\",\n\t\t\t\t\t\t      &val)) {\n\t\t\t\tiqs626->kp_code[ch_id][i] = val;\n\n\t\t\t\tif (fwnode_property_read_u32(ev_node,\n\t\t\t\t\t\t\t     \"linux,input-type\",\n\t\t\t\t\t\t\t     &val)) {\n\t\t\t\t\tif (ch_id == IQS626_CH_HALL)\n\t\t\t\t\t\tval = EV_SW;\n\t\t\t\t\telse\n\t\t\t\t\t\tval = EV_KEY;\n\t\t\t\t}\n\n\t\t\t\tif (val != EV_KEY && val != EV_SW) {\n\t\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\t\"Invalid input type: %u\\n\",\n\t\t\t\t\t\tval);\n\t\t\t\t\tfwnode_handle_put(ev_node);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tiqs626->kp_type[ch_id][i] = val;\n\n\t\t\t\tsys_reg->event_mask &= ~iqs626_events[i].mask;\n\t\t\t}\n\t\t}\n\n\t\tif (!fwnode_property_read_u32(ev_node, \"azoteq,hyst\", &val)) {\n\t\t\tif (val > IQS626_CHx_HYST_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s channel hysteresis: %u\\n\",\n\t\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\t\tfwnode_handle_put(ev_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (i == IQS626_EVENT_DEEP_DN ||\n\t\t\t    i == IQS626_EVENT_DEEP_UP) {\n\t\t\t\t*hyst &= ~IQS626_CHx_HYST_DEEP_MASK;\n\t\t\t\t*hyst |= (val << IQS626_CHx_HYST_DEEP_SHIFT);\n\t\t\t} else if (i == IQS626_EVENT_TOUCH_DN ||\n\t\t\t\t   i == IQS626_EVENT_TOUCH_UP) {\n\t\t\t\t*hyst &= ~IQS626_CHx_HYST_TOUCH_MASK;\n\t\t\t\t*hyst |= val;\n\t\t\t}\n\t\t}\n\n\t\tif (ch_id != IQS626_CH_TP_2 && ch_id != IQS626_CH_TP_3 &&\n\t\t    !fwnode_property_read_u32(ev_node, \"azoteq,thresh\", &val)) {\n\t\t\tif (val > IQS626_CHx_THRESH_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s channel threshold: %u\\n\",\n\t\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\t\tfwnode_handle_put(ev_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (ch_id == IQS626_CH_HALL)\n\t\t\t\t*thresh = val;\n\t\t\telse\n\t\t\t\t*(thresh + iqs626_events[i].th_offs) = val;\n\t\t}\n\n\t\tfwnode_handle_put(ev_node);\n\t}\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int\niqs626_parse_ati_target(struct iqs626_private *iqs626,\n\t\t\tstruct fwnode_handle *ch_node, enum iqs626_ch_id ch_id)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tunsigned int val;\n\tu8 *ati_target;\n\tint i;\n\n\tswitch (ch_id) {\n\tcase IQS626_CH_ULP_0:\n\t\tati_target = &sys_reg->ch_reg_ulp.ati_target;\n\t\tbreak;\n\n\tcase IQS626_CH_TP_2:\n\tcase IQS626_CH_TP_3:\n\t\tati_target = &sys_reg->tp_grp_reg.ati_target;\n\t\tbreak;\n\n\tcase IQS626_CH_GEN_0:\n\tcase IQS626_CH_GEN_1:\n\tcase IQS626_CH_GEN_2:\n\t\ti = ch_id - IQS626_CH_GEN_0;\n\t\tati_target = &sys_reg->ch_reg_gen[i].ati_target;\n\t\tbreak;\n\n\tcase IQS626_CH_HALL:\n\t\tati_target = &sys_reg->ch_reg_hall.ati_target;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,ati-target\", &val)) {\n\t\tif (val > IQS626_CHx_ATI_TARGET_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel ATI target: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*ati_target &= ~IQS626_CHx_ATI_TARGET_MASK;\n\t\t*ati_target |= (val / 32);\n\t}\n\n\tif (ch_id != IQS626_CH_TP_2 && ch_id != IQS626_CH_TP_3 &&\n\t    !fwnode_property_read_u32(ch_node, \"azoteq,ati-base\", &val)) {\n\t\tswitch (val) {\n\t\tcase 75:\n\t\t\tval = IQS626_CHx_ATI_BASE_75;\n\t\t\tbreak;\n\n\t\tcase 100:\n\t\t\tval = IQS626_CHx_ATI_BASE_100;\n\t\t\tbreak;\n\n\t\tcase 150:\n\t\t\tval = IQS626_CHx_ATI_BASE_150;\n\t\t\tbreak;\n\n\t\tcase 200:\n\t\t\tval = IQS626_CHx_ATI_BASE_200;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel ATI base: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*ati_target &= ~IQS626_CHx_ATI_BASE_MASK;\n\t\t*ati_target |= val;\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs626_parse_pins(struct iqs626_private *iqs626,\n\t\t\t     struct fwnode_handle *ch_node,\n\t\t\t     const char *propname, u8 *enable)\n{\n\tstruct i2c_client *client = iqs626->client;\n\tunsigned int val[IQS626_NUM_CRx_TX];\n\tint error, count, i;\n\n\tif (!fwnode_property_present(ch_node, propname))\n\t\treturn 0;\n\n\tcount = fwnode_property_count_u32(ch_node, propname);\n\tif (count > IQS626_NUM_CRx_TX) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Too many %s channel CRX/TX pins present\\n\",\n\t\t\tfwnode_get_name(ch_node));\n\t\treturn -EINVAL;\n\t} else if (count < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to count %s channel CRX/TX pins: %d\\n\",\n\t\t\tfwnode_get_name(ch_node), count);\n\t\treturn count;\n\t}\n\n\terror = fwnode_property_read_u32_array(ch_node, propname, val, count);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read %s channel CRX/TX pins: %d\\n\",\n\t\t\tfwnode_get_name(ch_node), error);\n\t\treturn error;\n\t}\n\n\t*enable = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (val[i] >= IQS626_NUM_CRx_TX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel CRX/TX pin: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*enable |= BIT(val[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs626_parse_trackpad(struct iqs626_private *iqs626,\n\t\t\t\t struct fwnode_handle *ch_node,\n\t\t\t\t enum iqs626_ch_id ch_id)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tu8 *hyst = &sys_reg->tp_grp_reg.hyst;\n\tint error, count, i;\n\tunsigned int val;\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,lta-update\", &val)) {\n\t\tif (val > IQS626_MISC_A_TPx_LTA_UPDATE_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel update rate: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->misc_a &= ~IQS626_MISC_A_TPx_LTA_UPDATE_MASK;\n\t\tsys_reg->misc_a |= (val << IQS626_MISC_A_TPx_LTA_UPDATE_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-trackpad\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->misc_b &= ~IQS626_MISC_B_FILT_STR_TPx;\n\t\tsys_reg->misc_b |= val;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-np-cnt\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*hyst &= ~IQS626_FILT_STR_NP_TPx_MASK;\n\t\t*hyst |= (val << IQS626_FILT_STR_NP_TPx_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-lp-cnt\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*hyst &= ~IQS626_FILT_STR_LP_TPx_MASK;\n\t\t*hyst |= (val << IQS626_FILT_STR_LP_TPx_SHIFT);\n\t}\n\n\tfor (i = 0; i < iqs626_channels[ch_id].num_ch; i++) {\n\t\tu8 *ati_base = &sys_reg->tp_grp_reg.ch_reg_tp[i].ati_base;\n\t\tu8 *thresh = &sys_reg->tp_grp_reg.ch_reg_tp[i].thresh;\n\t\tstruct fwnode_handle *tc_node;\n\t\tchar tc_name[10];\n\n\t\tsnprintf(tc_name, sizeof(tc_name), \"channel-%d\", i);\n\n\t\ttc_node = fwnode_get_named_child_node(ch_node, tc_name);\n\t\tif (!tc_node)\n\t\t\tcontinue;\n\n\t\tif (!fwnode_property_read_u32(tc_node, \"azoteq,ati-base\",\n\t\t\t\t\t      &val)) {\n\t\t\tif (val < IQS626_TPx_ATI_BASE_MIN ||\n\t\t\t    val > IQS626_TPx_ATI_BASE_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s %s ATI base: %u\\n\",\n\t\t\t\t\tfwnode_get_name(ch_node), tc_name, val);\n\t\t\t\tfwnode_handle_put(tc_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*ati_base = val - IQS626_TPx_ATI_BASE_MIN;\n\t\t}\n\n\t\tif (!fwnode_property_read_u32(tc_node, \"azoteq,thresh\",\n\t\t\t\t\t      &val)) {\n\t\t\tif (val > IQS626_CHx_THRESH_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s %s threshold: %u\\n\",\n\t\t\t\t\tfwnode_get_name(ch_node), tc_name, val);\n\t\t\t\tfwnode_handle_put(tc_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*thresh = val;\n\t\t}\n\n\t\tfwnode_handle_put(tc_node);\n\t}\n\n\tif (!fwnode_property_present(ch_node, \"linux,keycodes\"))\n\t\treturn 0;\n\n\tcount = fwnode_property_count_u32(ch_node, \"linux,keycodes\");\n\tif (count > IQS626_NUM_GESTURES) {\n\t\tdev_err(&client->dev, \"Too many keycodes present\\n\");\n\t\treturn -EINVAL;\n\t} else if (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count keycodes: %d\\n\", count);\n\t\treturn count;\n\t}\n\n\terror = fwnode_property_read_u32_array(ch_node, \"linux,keycodes\",\n\t\t\t\t\t       iqs626->tp_code, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read keycodes: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsys_reg->misc_b &= ~IQS626_MISC_B_TPx_SWIPE;\n\tif (fwnode_property_present(ch_node, \"azoteq,gesture-swipe\"))\n\t\tsys_reg->misc_b |= IQS626_MISC_B_TPx_SWIPE;\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,timeout-tap-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_TIMEOUT_TAP_MS_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel timeout: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->timeout_tap = val / 16;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,timeout-swipe-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_TIMEOUT_SWIPE_MS_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel timeout: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->timeout_swipe = val / 16;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,thresh-swipe\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_THRESH_SWIPE_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel threshold: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->thresh_swipe = val;\n\t}\n\n\tsys_reg->event_mask &= ~IQS626_EVENT_MASK_GESTURE;\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int\niqs626_parse_channel(struct iqs626_private *iqs626,\n\t\t     struct fwnode_handle *ch_node, enum iqs626_ch_id ch_id)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tu8 *engine, *filter, *rx_enable, *tx_enable;\n\tu8 *assoc_select, *assoc_weight;\n\tunsigned int val;\n\tint error, i;\n\n\tswitch (ch_id) {\n\tcase IQS626_CH_ULP_0:\n\t\tengine = sys_reg->ch_reg_ulp.engine;\n\t\tbreak;\n\n\tcase IQS626_CH_TP_2:\n\tcase IQS626_CH_TP_3:\n\t\tengine = sys_reg->tp_grp_reg.engine;\n\t\tbreak;\n\n\tcase IQS626_CH_GEN_0:\n\tcase IQS626_CH_GEN_1:\n\tcase IQS626_CH_GEN_2:\n\t\ti = ch_id - IQS626_CH_GEN_0;\n\t\tengine = sys_reg->ch_reg_gen[i].engine;\n\t\tbreak;\n\n\tcase IQS626_CH_HALL:\n\t\tengine = &sys_reg->ch_reg_hall.engine;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terror = iqs626_parse_ati_target(iqs626, ch_node, ch_id);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs626_parse_events(iqs626, ch_node, ch_id);\n\tif (error)\n\t\treturn error;\n\n\tif (!fwnode_property_present(ch_node, \"azoteq,ati-exclude\"))\n\t\tsys_reg->redo_ati |= iqs626_channels[ch_id].active;\n\n\tif (!fwnode_property_present(ch_node, \"azoteq,reseed-disable\"))\n\t\tsys_reg->reseed |= iqs626_channels[ch_id].active;\n\n\t*engine |= IQS626_CHx_ENG_0_MEAS_CAP_SIZE;\n\tif (fwnode_property_present(ch_node, \"azoteq,meas-cap-decrease\"))\n\t\t*engine &= ~IQS626_CHx_ENG_0_MEAS_CAP_SIZE;\n\n\t*engine |= IQS626_CHx_ENG_0_RX_TERM_VSS;\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,rx-inactive\", &val)) {\n\t\tswitch (val) {\n\t\tcase IQS626_RX_INACTIVE_VSS:\n\t\t\tbreak;\n\n\t\tcase IQS626_RX_INACTIVE_FLOAT:\n\t\t\t*engine &= ~IQS626_CHx_ENG_0_RX_TERM_VSS;\n\t\t\tif (ch_id == IQS626_CH_GEN_0 ||\n\t\t\t    ch_id == IQS626_CH_GEN_1 ||\n\t\t\t    ch_id == IQS626_CH_GEN_2)\n\t\t\t\t*(engine + 4) &= ~IQS626_CHx_ENG_4_RX_TERM_VREG;\n\t\t\tbreak;\n\n\t\tcase IQS626_RX_INACTIVE_VREG:\n\t\t\tif (ch_id == IQS626_CH_GEN_0 ||\n\t\t\t    ch_id == IQS626_CH_GEN_1 ||\n\t\t\t    ch_id == IQS626_CH_GEN_2) {\n\t\t\t\t*engine &= ~IQS626_CHx_ENG_0_RX_TERM_VSS;\n\t\t\t\t*(engine + 4) |= IQS626_CHx_ENG_4_RX_TERM_VREG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tdefault:\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel CRX pin termination: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t*engine &= ~IQS626_CHx_ENG_0_LINEARIZE;\n\tif (fwnode_property_present(ch_node, \"azoteq,linearize\"))\n\t\t*engine |= IQS626_CHx_ENG_0_LINEARIZE;\n\n\t*engine &= ~IQS626_CHx_ENG_0_DUAL_DIR;\n\tif (fwnode_property_present(ch_node, \"azoteq,dual-direction\"))\n\t\t*engine |= IQS626_CHx_ENG_0_DUAL_DIR;\n\n\t*engine &= ~IQS626_CHx_ENG_0_FILT_DISABLE;\n\tif (fwnode_property_present(ch_node, \"azoteq,filt-disable\"))\n\t\t*engine |= IQS626_CHx_ENG_0_FILT_DISABLE;\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,ati-mode\", &val)) {\n\t\tif (val > IQS626_CHx_ENG_0_ATI_MODE_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel ATI mode: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*engine &= ~IQS626_CHx_ENG_0_ATI_MODE_MASK;\n\t\t*engine |= val;\n\t}\n\n\tif (ch_id == IQS626_CH_HALL)\n\t\treturn 0;\n\n\t*(engine + 1) &= ~IQS626_CHx_ENG_1_CCT_ENABLE;\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,cct-increase\",\n\t\t\t\t      &val) && val) {\n\t\tunsigned int orig_val = val--;\n\n\t\t \n\t\tif (ch_id == IQS626_CH_GEN_0 ||\n\t\t    ch_id == IQS626_CH_GEN_1 ||\n\t\t    ch_id == IQS626_CH_GEN_2) {\n\t\t\t*(engine + 4) &= ~IQS626_CHx_ENG_4_CCT_LOW_1;\n\t\t\tif (val & BIT(1))\n\t\t\t\t*(engine + 4) |= IQS626_CHx_ENG_4_CCT_LOW_1;\n\n\t\t\t*(engine + 4) &= ~IQS626_CHx_ENG_4_CCT_LOW_0;\n\t\t\tif (val & BIT(0))\n\t\t\t\t*(engine + 4) |= IQS626_CHx_ENG_4_CCT_LOW_0;\n\n\t\t\tval >>= 2;\n\t\t}\n\n\t\tif (val & ~GENMASK(1, 0)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel charge cycle time: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), orig_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*(engine + 1) &= ~IQS626_CHx_ENG_1_CCT_HIGH_1;\n\t\tif (val & BIT(1))\n\t\t\t*(engine + 1) |= IQS626_CHx_ENG_1_CCT_HIGH_1;\n\n\t\t*(engine + 1) &= ~IQS626_CHx_ENG_1_CCT_HIGH_0;\n\t\tif (val & BIT(0))\n\t\t\t*(engine + 1) |= IQS626_CHx_ENG_1_CCT_HIGH_0;\n\n\t\t*(engine + 1) |= IQS626_CHx_ENG_1_CCT_ENABLE;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,proj-bias\", &val)) {\n\t\tif (val > IQS626_CHx_ENG_1_PROJ_BIAS_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel bias current: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*(engine + 1) &= ~IQS626_CHx_ENG_1_PROJ_BIAS_MASK;\n\t\t*(engine + 1) |= (val << IQS626_CHx_ENG_1_PROJ_BIAS_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,sense-freq\", &val)) {\n\t\tif (val > IQS626_CHx_ENG_1_SENSE_FREQ_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel sensing frequency: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*(engine + 1) &= ~IQS626_CHx_ENG_1_SENSE_FREQ_MASK;\n\t\t*(engine + 1) |= (val << IQS626_CHx_ENG_1_SENSE_FREQ_SHIFT);\n\t}\n\n\t*(engine + 1) &= ~IQS626_CHx_ENG_1_ATI_BAND_TIGHTEN;\n\tif (fwnode_property_present(ch_node, \"azoteq,ati-band-tighten\"))\n\t\t*(engine + 1) |= IQS626_CHx_ENG_1_ATI_BAND_TIGHTEN;\n\n\tif (ch_id == IQS626_CH_TP_2 || ch_id == IQS626_CH_TP_3)\n\t\treturn iqs626_parse_trackpad(iqs626, ch_node, ch_id);\n\n\tif (ch_id == IQS626_CH_ULP_0) {\n\t\tsys_reg->ch_reg_ulp.hyst &= ~IQS626_ULP_PROJ_ENABLE;\n\t\tif (fwnode_property_present(ch_node, \"azoteq,proj-enable\"))\n\t\t\tsys_reg->ch_reg_ulp.hyst |= IQS626_ULP_PROJ_ENABLE;\n\n\t\tfilter = &sys_reg->ch_reg_ulp.filter;\n\n\t\trx_enable = &sys_reg->ch_reg_ulp.rx_enable;\n\t\ttx_enable = &sys_reg->ch_reg_ulp.tx_enable;\n\t} else {\n\t\ti = ch_id - IQS626_CH_GEN_0;\n\t\tfilter = &sys_reg->ch_reg_gen[i].filter;\n\n\t\trx_enable = &sys_reg->ch_reg_gen[i].rx_enable;\n\t\ttx_enable = &sys_reg->ch_reg_gen[i].tx_enable;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-np-cnt\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*filter &= ~IQS626_FILT_STR_NP_CNT_MASK;\n\t\t*filter |= (val << IQS626_FILT_STR_NP_CNT_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-lp-cnt\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*filter &= ~IQS626_FILT_STR_LP_CNT_MASK;\n\t\t*filter |= (val << IQS626_FILT_STR_LP_CNT_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-np-lta\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*filter &= ~IQS626_FILT_STR_NP_LTA_MASK;\n\t\t*filter |= (val << IQS626_FILT_STR_NP_LTA_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,filt-str-lp-lta\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel filter strength: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*filter &= ~IQS626_FILT_STR_LP_LTA_MASK;\n\t\t*filter |= val;\n\t}\n\n\terror = iqs626_parse_pins(iqs626, ch_node, \"azoteq,rx-enable\",\n\t\t\t\t  rx_enable);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs626_parse_pins(iqs626, ch_node, \"azoteq,tx-enable\",\n\t\t\t\t  tx_enable);\n\tif (error)\n\t\treturn error;\n\n\tif (ch_id == IQS626_CH_ULP_0)\n\t\treturn 0;\n\n\t*(engine + 2) &= ~IQS626_CHx_ENG_2_LOCAL_CAP_ENABLE;\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,local-cap-size\",\n\t\t\t\t      &val) && val) {\n\t\tunsigned int orig_val = val--;\n\n\t\tif (val > IQS626_CHx_ENG_2_LOCAL_CAP_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel local cap. size: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), orig_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*(engine + 2) &= ~IQS626_CHx_ENG_2_LOCAL_CAP_MASK;\n\t\t*(engine + 2) |= (val << IQS626_CHx_ENG_2_LOCAL_CAP_SHIFT);\n\n\t\t*(engine + 2) |= IQS626_CHx_ENG_2_LOCAL_CAP_ENABLE;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,sense-mode\", &val)) {\n\t\tif (val > IQS626_CHx_ENG_2_SENSE_MODE_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel sensing mode: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*(engine + 2) &= ~IQS626_CHx_ENG_2_SENSE_MODE_MASK;\n\t\t*(engine + 2) |= val;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,tx-freq\", &val)) {\n\t\tif (val > IQS626_CHx_ENG_3_TX_FREQ_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid %s channel excitation frequency: %u\\n\",\n\t\t\t\tfwnode_get_name(ch_node), val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*(engine + 3) &= ~IQS626_CHx_ENG_3_TX_FREQ_MASK;\n\t\t*(engine + 3) |= (val << IQS626_CHx_ENG_3_TX_FREQ_SHIFT);\n\t}\n\n\t*(engine + 3) &= ~IQS626_CHx_ENG_3_INV_LOGIC;\n\tif (fwnode_property_present(ch_node, \"azoteq,invert-enable\"))\n\t\t*(engine + 3) |= IQS626_CHx_ENG_3_INV_LOGIC;\n\n\t*(engine + 4) &= ~IQS626_CHx_ENG_4_COMP_DISABLE;\n\tif (fwnode_property_present(ch_node, \"azoteq,comp-disable\"))\n\t\t*(engine + 4) |= IQS626_CHx_ENG_4_COMP_DISABLE;\n\n\t*(engine + 4) &= ~IQS626_CHx_ENG_4_STATIC_ENABLE;\n\tif (fwnode_property_present(ch_node, \"azoteq,static-enable\"))\n\t\t*(engine + 4) |= IQS626_CHx_ENG_4_STATIC_ENABLE;\n\n\ti = ch_id - IQS626_CH_GEN_0;\n\tassoc_select = &sys_reg->ch_reg_gen[i].assoc_select;\n\tassoc_weight = &sys_reg->ch_reg_gen[i].assoc_weight;\n\n\t*assoc_select = 0;\n\tif (!fwnode_property_present(ch_node, \"azoteq,assoc-select\"))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs626_channels); i++) {\n\t\tif (fwnode_property_match_string(ch_node, \"azoteq,assoc-select\",\n\t\t\t\t\t\t iqs626_channels[i].name) < 0)\n\t\t\tcontinue;\n\n\t\t*assoc_select |= iqs626_channels[i].active;\n\t}\n\n\tif (fwnode_property_read_u32(ch_node, \"azoteq,assoc-weight\", &val))\n\t\treturn 0;\n\n\tif (val > IQS626_GEN_WEIGHT_MAX) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Invalid %s channel associated weight: %u\\n\",\n\t\t\tfwnode_get_name(ch_node), val);\n\t\treturn -EINVAL;\n\t}\n\n\t*assoc_weight = val;\n\n\treturn 0;\n}\n\nstatic int iqs626_parse_prop(struct iqs626_private *iqs626)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tstruct fwnode_handle *ch_node;\n\tunsigned int val;\n\tint error, i;\n\tu16 general;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,suspend-mode\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_SYS_SETTINGS_PWR_MODE_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid suspend mode: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiqs626->suspend_mode = val;\n\t}\n\n\terror = regmap_raw_read(iqs626->regmap, IQS626_SYS_SETTINGS, sys_reg,\n\t\t\t\tsizeof(*sys_reg));\n\tif (error)\n\t\treturn error;\n\n\tgeneral = be16_to_cpu(sys_reg->general);\n\tgeneral &= IQS626_SYS_SETTINGS_ULP_UPDATE_MASK;\n\n\tif (device_property_present(&client->dev, \"azoteq,clk-div\"))\n\t\tgeneral |= IQS626_SYS_SETTINGS_CLK_DIV;\n\n\tif (device_property_present(&client->dev, \"azoteq,ulp-enable\"))\n\t\tgeneral |= IQS626_SYS_SETTINGS_ULP_AUTO;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,ulp-update\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_SYS_SETTINGS_ULP_UPDATE_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid update rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgeneral &= ~IQS626_SYS_SETTINGS_ULP_UPDATE_MASK;\n\t\tgeneral |= (val << IQS626_SYS_SETTINGS_ULP_UPDATE_SHIFT);\n\t}\n\n\tsys_reg->misc_a &= ~IQS626_MISC_A_ATI_BAND_DISABLE;\n\tif (device_property_present(&client->dev, \"azoteq,ati-band-disable\"))\n\t\tsys_reg->misc_a |= IQS626_MISC_A_ATI_BAND_DISABLE;\n\n\tsys_reg->misc_a &= ~IQS626_MISC_A_ATI_LP_ONLY;\n\tif (device_property_present(&client->dev, \"azoteq,ati-lp-only\"))\n\t\tsys_reg->misc_a |= IQS626_MISC_A_ATI_LP_ONLY;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,gpio3-select\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_MISC_A_GPIO3_SELECT_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid GPIO3 selection: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->misc_a &= ~IQS626_MISC_A_GPIO3_SELECT_MASK;\n\t\tsys_reg->misc_a |= val;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,reseed-select\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_MISC_B_RESEED_UI_SEL_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid reseed selection: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->misc_b &= ~IQS626_MISC_B_RESEED_UI_SEL_MASK;\n\t\tsys_reg->misc_b |= (val << IQS626_MISC_B_RESEED_UI_SEL_SHIFT);\n\t}\n\n\tsys_reg->misc_b &= ~IQS626_MISC_B_THRESH_EXTEND;\n\tif (device_property_present(&client->dev, \"azoteq,thresh-extend\"))\n\t\tsys_reg->misc_b |= IQS626_MISC_B_THRESH_EXTEND;\n\n\tsys_reg->misc_b &= ~IQS626_MISC_B_TRACKING_UI_ENABLE;\n\tif (device_property_present(&client->dev, \"azoteq,tracking-enable\"))\n\t\tsys_reg->misc_b |= IQS626_MISC_B_TRACKING_UI_ENABLE;\n\n\tsys_reg->misc_b &= ~IQS626_MISC_B_RESEED_OFFSET;\n\tif (device_property_present(&client->dev, \"azoteq,reseed-offset\"))\n\t\tsys_reg->misc_b |= IQS626_MISC_B_RESEED_OFFSET;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,rate-np-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_RATE_NP_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid report rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->rate_np = val;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,rate-lp-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_RATE_LP_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid report rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->rate_lp = val;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,rate-ulp-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_RATE_ULP_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid report rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->rate_ulp = val / 16;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,timeout-pwr-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_TIMEOUT_PWR_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid timeout: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->timeout_pwr = val / 512;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,timeout-lta-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS626_TIMEOUT_LTA_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid timeout: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->timeout_lta = val / 512;\n\t}\n\n\tsys_reg->event_mask = ~((u8)IQS626_EVENT_MASK_SYS);\n\tsys_reg->redo_ati = 0;\n\n\tsys_reg->reseed = 0;\n\tsys_reg->active = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs626_channels); i++) {\n\t\tch_node = device_get_named_child_node(&client->dev,\n\t\t\t\t\t\t      iqs626_channels[i].name);\n\t\tif (!ch_node)\n\t\t\tcontinue;\n\n\t\terror = iqs626_parse_channel(iqs626, ch_node, i);\n\t\tfwnode_handle_put(ch_node);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsys_reg->active |= iqs626_channels[i].active;\n\t}\n\n\tgeneral |= IQS626_SYS_SETTINGS_EVENT_MODE;\n\n\t \n\tif (sys_reg->active & iqs626_channels[IQS626_CH_TP_2].active &&\n\t    sys_reg->event_mask & IQS626_EVENT_MASK_GESTURE)\n\t\tgeneral |= IQS626_SYS_SETTINGS_EVENT_MODE_LP;\n\n\tgeneral |= IQS626_SYS_SETTINGS_REDO_ATI;\n\tgeneral |= IQS626_SYS_SETTINGS_ACK_RESET;\n\n\tsys_reg->general = cpu_to_be16(general);\n\n\terror = regmap_raw_write(iqs626->regmap, IQS626_SYS_SETTINGS,\n\t\t\t\t &iqs626->sys_reg, sizeof(iqs626->sys_reg));\n\tif (error)\n\t\treturn error;\n\n\tiqs626_irq_wait();\n\n\treturn 0;\n}\n\nstatic int iqs626_input_init(struct iqs626_private *iqs626)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tint error, i, j;\n\n\tiqs626->keypad = devm_input_allocate_device(&client->dev);\n\tif (!iqs626->keypad)\n\t\treturn -ENOMEM;\n\n\tiqs626->keypad->keycodemax = ARRAY_SIZE(iqs626->kp_code);\n\tiqs626->keypad->keycode = iqs626->kp_code;\n\tiqs626->keypad->keycodesize = sizeof(**iqs626->kp_code);\n\n\tiqs626->keypad->name = \"iqs626a_keypad\";\n\tiqs626->keypad->id.bustype = BUS_I2C;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs626_channels); i++) {\n\t\tif (!(sys_reg->active & iqs626_channels[i].active))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(iqs626_events); j++) {\n\t\t\tif (!iqs626->kp_type[i][j])\n\t\t\t\tcontinue;\n\n\t\t\tinput_set_capability(iqs626->keypad,\n\t\t\t\t\t     iqs626->kp_type[i][j],\n\t\t\t\t\t     iqs626->kp_code[i][j]);\n\t\t}\n\t}\n\n\tif (!(sys_reg->active & iqs626_channels[IQS626_CH_TP_2].active))\n\t\treturn 0;\n\n\tiqs626->trackpad = devm_input_allocate_device(&client->dev);\n\tif (!iqs626->trackpad)\n\t\treturn -ENOMEM;\n\n\tiqs626->trackpad->keycodemax = ARRAY_SIZE(iqs626->tp_code);\n\tiqs626->trackpad->keycode = iqs626->tp_code;\n\tiqs626->trackpad->keycodesize = sizeof(*iqs626->tp_code);\n\n\tiqs626->trackpad->name = \"iqs626a_trackpad\";\n\tiqs626->trackpad->id.bustype = BUS_I2C;\n\n\t \n\tif (sys_reg->event_mask & IQS626_EVENT_MASK_GESTURE) {\n\t\tu8 tp_mask = iqs626_channels[IQS626_CH_TP_3].active;\n\n\t\tinput_set_capability(iqs626->trackpad, EV_KEY, BTN_TOUCH);\n\t\tinput_set_abs_params(iqs626->trackpad, ABS_Y, 0, 255, 0, 0);\n\n\t\tif ((sys_reg->active & tp_mask) == tp_mask)\n\t\t\tinput_set_abs_params(iqs626->trackpad,\n\t\t\t\t\t     ABS_X, 0, 255, 0, 0);\n\t\telse\n\t\t\tinput_set_abs_params(iqs626->trackpad,\n\t\t\t\t\t     ABS_X, 0, 128, 0, 0);\n\n\t\ttouchscreen_parse_properties(iqs626->trackpad, false,\n\t\t\t\t\t     &iqs626->prop);\n\t} else {\n\t\tfor (i = 0; i < IQS626_NUM_GESTURES; i++)\n\t\t\tif (iqs626->tp_code[i] != KEY_RESERVED)\n\t\t\t\tinput_set_capability(iqs626->trackpad, EV_KEY,\n\t\t\t\t\t\t     iqs626->tp_code[i]);\n\t}\n\n\terror = input_register_device(iqs626->trackpad);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to register trackpad: %d\\n\",\n\t\t\terror);\n\n\treturn error;\n}\n\nstatic int iqs626_report(struct iqs626_private *iqs626)\n{\n\tstruct iqs626_sys_reg *sys_reg = &iqs626->sys_reg;\n\tstruct i2c_client *client = iqs626->client;\n\tstruct iqs626_flags flags;\n\t__le16 hall_output;\n\tint error, i, j;\n\tu8 state;\n\tu8 *dir_mask = &flags.states[IQS626_ST_OFFS_DIR];\n\n\terror = regmap_raw_read(iqs626->regmap, IQS626_SYS_FLAGS, &flags,\n\t\t\t\tsizeof(flags));\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read device status: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tif (be16_to_cpu(flags.system) & IQS626_SYS_FLAGS_SHOW_RESET) {\n\t\tdev_err(&client->dev, \"Unexpected device reset\\n\");\n\n\t\terror = regmap_raw_write(iqs626->regmap, IQS626_SYS_SETTINGS,\n\t\t\t\t\t sys_reg, sizeof(*sys_reg));\n\t\tif (error)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to re-initialize device: %d\\n\", error);\n\n\t\treturn error;\n\t}\n\n\tif (be16_to_cpu(flags.system) & IQS626_SYS_FLAGS_IN_ATI)\n\t\treturn 0;\n\n\t \n\tif (sys_reg->active & iqs626_channels[IQS626_CH_HALL].active) {\n\t\terror = regmap_raw_read(iqs626->regmap, IQS626_HALL_OUTPUT,\n\t\t\t\t\t&hall_output, sizeof(hall_output));\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read Hall output: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\t*dir_mask &= ~iqs626_channels[IQS626_CH_HALL].active;\n\t\tif (le16_to_cpu(hall_output) < 0x8000)\n\t\t\t*dir_mask |= iqs626_channels[IQS626_CH_HALL].active;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs626_channels); i++) {\n\t\tif (!(sys_reg->active & iqs626_channels[i].active))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(iqs626_events); j++) {\n\t\t\tif (!iqs626->kp_type[i][j])\n\t\t\t\tcontinue;\n\n\t\t\tstate = flags.states[iqs626_events[j].st_offs];\n\t\t\tstate &= iqs626_events[j].dir_up ? *dir_mask\n\t\t\t\t\t\t\t : ~(*dir_mask);\n\t\t\tstate &= iqs626_channels[i].active;\n\n\t\t\tinput_event(iqs626->keypad, iqs626->kp_type[i][j],\n\t\t\t\t    iqs626->kp_code[i][j], !!state);\n\t\t}\n\t}\n\n\tinput_sync(iqs626->keypad);\n\n\t \n\tcomplete_all(&iqs626->ati_done);\n\n\tif (!(sys_reg->active & iqs626_channels[IQS626_CH_TP_2].active))\n\t\treturn 0;\n\n\tif (sys_reg->event_mask & IQS626_EVENT_MASK_GESTURE) {\n\t\tstate = flags.states[IQS626_ST_OFFS_TOUCH];\n\t\tstate &= iqs626_channels[IQS626_CH_TP_2].active;\n\n\t\tinput_report_key(iqs626->trackpad, BTN_TOUCH, state);\n\n\t\tif (state)\n\t\t\ttouchscreen_report_pos(iqs626->trackpad, &iqs626->prop,\n\t\t\t\t\t       flags.trackpad_x,\n\t\t\t\t\t       flags.trackpad_y, false);\n\t} else {\n\t\tfor (i = 0; i < IQS626_NUM_GESTURES; i++)\n\t\t\tinput_report_key(iqs626->trackpad, iqs626->tp_code[i],\n\t\t\t\t\t flags.gesture & BIT(i));\n\n\t\tif (flags.gesture & GENMASK(IQS626_GESTURE_TAP, 0)) {\n\t\t\tinput_sync(iqs626->trackpad);\n\n\t\t\t \n\t\t\tfor (i = 0; i < IQS626_GESTURE_HOLD; i++)\n\t\t\t\tinput_report_key(iqs626->trackpad,\n\t\t\t\t\t\t iqs626->tp_code[i], 0);\n\t\t}\n\t}\n\n\tinput_sync(iqs626->trackpad);\n\n\treturn 0;\n}\n\nstatic irqreturn_t iqs626_irq(int irq, void *context)\n{\n\tstruct iqs626_private *iqs626 = context;\n\n\tif (iqs626_report(iqs626))\n\t\treturn IRQ_NONE;\n\n\t \n\tiqs626_irq_wait();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct regmap_config iqs626_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = IQS626_MAX_REG,\n};\n\nstatic int iqs626_probe(struct i2c_client *client)\n{\n\tstruct iqs626_ver_info ver_info;\n\tstruct iqs626_private *iqs626;\n\tint error;\n\n\tiqs626 = devm_kzalloc(&client->dev, sizeof(*iqs626), GFP_KERNEL);\n\tif (!iqs626)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, iqs626);\n\tiqs626->client = client;\n\n\tiqs626->regmap = devm_regmap_init_i2c(client, &iqs626_regmap_config);\n\tif (IS_ERR(iqs626->regmap)) {\n\t\terror = PTR_ERR(iqs626->regmap);\n\t\tdev_err(&client->dev, \"Failed to initialize register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tinit_completion(&iqs626->ati_done);\n\n\terror = regmap_raw_read(iqs626->regmap, IQS626_VER_INFO, &ver_info,\n\t\t\t\tsizeof(ver_info));\n\tif (error)\n\t\treturn error;\n\n\tif (ver_info.prod_num != IQS626_VER_INFO_PROD_NUM) {\n\t\tdev_err(&client->dev, \"Unrecognized product number: 0x%02X\\n\",\n\t\t\tver_info.prod_num);\n\t\treturn -EINVAL;\n\t}\n\n\terror = iqs626_parse_prop(iqs626);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs626_input_init(iqs626);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, iqs626_irq, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, iqs626);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (!wait_for_completion_timeout(&iqs626->ati_done,\n\t\t\t\t\t msecs_to_jiffies(2000))) {\n\t\tdev_err(&client->dev, \"Failed to complete ATI\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\terror = input_register_device(iqs626->keypad);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to register keypad: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic int iqs626_suspend(struct device *dev)\n{\n\tstruct iqs626_private *iqs626 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs626->client;\n\tunsigned int val;\n\tint error;\n\n\tif (!iqs626->suspend_mode)\n\t\treturn 0;\n\n\tdisable_irq(client->irq);\n\n\t \n\terror = regmap_update_bits(iqs626->regmap, IQS626_SYS_SETTINGS,\n\t\t\t\t   IQS626_SYS_SETTINGS_DIS_AUTO, ~0);\n\tif (error)\n\t\tgoto err_irq;\n\n\t \n\terror = regmap_read_poll_timeout(iqs626->regmap, IQS626_SYS_FLAGS, val,\n\t\t\t\t\t!(val & IQS626_SYS_FLAGS_PWR_MODE_MASK),\n\t\t\t\t\t IQS626_PWR_MODE_POLL_SLEEP_US,\n\t\t\t\t\t IQS626_PWR_MODE_POLL_TIMEOUT_US);\n\tif (error)\n\t\tgoto err_irq;\n\n\terror = regmap_update_bits(iqs626->regmap, IQS626_SYS_SETTINGS,\n\t\t\t\t   IQS626_SYS_SETTINGS_PWR_MODE_MASK,\n\t\t\t\t   iqs626->suspend_mode <<\n\t\t\t\t   IQS626_SYS_SETTINGS_PWR_MODE_SHIFT);\n\tif (error)\n\t\tgoto err_irq;\n\n\t \n\terror = regmap_read_poll_timeout(iqs626->regmap, IQS626_SYS_FLAGS, val,\n\t\t\t\t\t (val & IQS626_SYS_FLAGS_PWR_MODE_MASK)\n\t\t\t\t\t == (iqs626->suspend_mode <<\n\t\t\t\t\t     IQS626_SYS_FLAGS_PWR_MODE_SHIFT),\n\t\t\t\t\t IQS626_PWR_MODE_POLL_SLEEP_US,\n\t\t\t\t\t IQS626_PWR_MODE_POLL_TIMEOUT_US);\n\nerr_irq:\n\tiqs626_irq_wait();\n\tenable_irq(client->irq);\n\n\treturn error;\n}\n\nstatic int iqs626_resume(struct device *dev)\n{\n\tstruct iqs626_private *iqs626 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs626->client;\n\tunsigned int val;\n\tint error;\n\n\tif (!iqs626->suspend_mode)\n\t\treturn 0;\n\n\tdisable_irq(client->irq);\n\n\terror = regmap_update_bits(iqs626->regmap, IQS626_SYS_SETTINGS,\n\t\t\t\t   IQS626_SYS_SETTINGS_PWR_MODE_MASK, 0);\n\tif (error)\n\t\tgoto err_irq;\n\n\t \n\terror = regmap_read_poll_timeout(iqs626->regmap, IQS626_SYS_FLAGS, val,\n\t\t\t\t\t!(val & IQS626_SYS_FLAGS_PWR_MODE_MASK),\n\t\t\t\t\t IQS626_PWR_MODE_POLL_SLEEP_US,\n\t\t\t\t\t IQS626_PWR_MODE_POLL_TIMEOUT_US);\n\tif (error)\n\t\tgoto err_irq;\n\n\terror = regmap_update_bits(iqs626->regmap, IQS626_SYS_SETTINGS,\n\t\t\t\t   IQS626_SYS_SETTINGS_DIS_AUTO, 0);\n\tif (error)\n\t\tgoto err_irq;\n\n\t \n\terror = iqs626_report(iqs626);\n\nerr_irq:\n\tiqs626_irq_wait();\n\tenable_irq(client->irq);\n\n\treturn error;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(iqs626_pm, iqs626_suspend, iqs626_resume);\n\nstatic const struct of_device_id iqs626_of_match[] = {\n\t{ .compatible = \"azoteq,iqs626a\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, iqs626_of_match);\n\nstatic struct i2c_driver iqs626_i2c_driver = {\n\t.driver = {\n\t\t.name = \"iqs626a\",\n\t\t.of_match_table = iqs626_of_match,\n\t\t.pm = pm_sleep_ptr(&iqs626_pm),\n\t},\n\t.probe = iqs626_probe,\n};\nmodule_i2c_driver(iqs626_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS626A Capacitive Touch Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}