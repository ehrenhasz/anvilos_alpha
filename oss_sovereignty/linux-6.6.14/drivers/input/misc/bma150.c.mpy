{
  "module_name": "bma150.c",
  "hash_id": "26e1a3456a862aeedec23dc099e7f19977fd66933a3a38f4fd39bd5fe5b3c428",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/bma150.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/bma150.h>\n\n#define ABSMAX_ACC_VAL\t\t0x01FF\n#define ABSMIN_ACC_VAL\t\t-(ABSMAX_ACC_VAL)\n\n \n#define BMA150_XYZ_DATA_SIZE\t6\n\n \n#define BMA150_POLL_INTERVAL\t10\n#define BMA150_POLL_MAX\t\t200\n#define BMA150_POLL_MIN\t\t0\n\n#define BMA150_MODE_NORMAL\t0\n#define BMA150_MODE_SLEEP\t2\n#define BMA150_MODE_WAKE_UP\t3\n\n \n#define BMA150_DATA_0_REG\t0x00\n#define BMA150_DATA_1_REG\t0x01\n#define BMA150_DATA_2_REG\t0x02\n\n \n#define BMA150_CTRL_0_REG\t0x0A\n#define BMA150_CTRL_1_REG\t0x0B\n#define BMA150_CTRL_2_REG\t0x14\n#define BMA150_CTRL_3_REG\t0x15\n\n \n#define BMA150_CFG_0_REG\t0x0C\n#define BMA150_CFG_1_REG\t0x0D\n#define BMA150_CFG_2_REG\t0x0E\n#define BMA150_CFG_3_REG\t0x0F\n#define BMA150_CFG_4_REG\t0x10\n#define BMA150_CFG_5_REG\t0x11\n\n#define BMA150_CHIP_ID\t\t2\n#define BMA150_CHIP_ID_REG\tBMA150_DATA_0_REG\n\n#define BMA150_ACC_X_LSB_REG\tBMA150_DATA_2_REG\n\n#define BMA150_SLEEP_POS\t0\n#define BMA150_SLEEP_MSK\t0x01\n#define BMA150_SLEEP_REG\tBMA150_CTRL_0_REG\n\n#define BMA150_BANDWIDTH_POS\t0\n#define BMA150_BANDWIDTH_MSK\t0x07\n#define BMA150_BANDWIDTH_REG\tBMA150_CTRL_2_REG\n\n#define BMA150_RANGE_POS\t3\n#define BMA150_RANGE_MSK\t0x18\n#define BMA150_RANGE_REG\tBMA150_CTRL_2_REG\n\n#define BMA150_WAKE_UP_POS\t0\n#define BMA150_WAKE_UP_MSK\t0x01\n#define BMA150_WAKE_UP_REG\tBMA150_CTRL_3_REG\n\n#define BMA150_SW_RES_POS\t1\n#define BMA150_SW_RES_MSK\t0x02\n#define BMA150_SW_RES_REG\tBMA150_CTRL_0_REG\n\n \n#define BMA150_ANY_MOTION_EN_POS\t6\n#define BMA150_ANY_MOTION_EN_MSK\t0x40\n#define BMA150_ANY_MOTION_EN_REG\tBMA150_CTRL_1_REG\n\n#define BMA150_ANY_MOTION_DUR_POS\t6\n#define BMA150_ANY_MOTION_DUR_MSK\t0xC0\n#define BMA150_ANY_MOTION_DUR_REG\tBMA150_CFG_5_REG\n\n#define BMA150_ANY_MOTION_THRES_REG\tBMA150_CFG_4_REG\n\n \n#define BMA150_ADV_INT_EN_POS\t\t6\n#define BMA150_ADV_INT_EN_MSK\t\t0x40\n#define BMA150_ADV_INT_EN_REG\t\tBMA150_CTRL_3_REG\n\n \n#define BMA150_HIGH_G_EN_POS\t\t1\n#define BMA150_HIGH_G_EN_MSK\t\t0x02\n#define BMA150_HIGH_G_EN_REG\t\tBMA150_CTRL_1_REG\n\n#define BMA150_HIGH_G_HYST_POS\t\t3\n#define BMA150_HIGH_G_HYST_MSK\t\t0x38\n#define BMA150_HIGH_G_HYST_REG\t\tBMA150_CFG_5_REG\n\n#define BMA150_HIGH_G_DUR_REG\t\tBMA150_CFG_3_REG\n#define BMA150_HIGH_G_THRES_REG\t\tBMA150_CFG_2_REG\n\n \n#define BMA150_LOW_G_EN_POS\t\t0\n#define BMA150_LOW_G_EN_MSK\t\t0x01\n#define BMA150_LOW_G_EN_REG\t\tBMA150_CTRL_1_REG\n\n#define BMA150_LOW_G_HYST_POS\t\t0\n#define BMA150_LOW_G_HYST_MSK\t\t0x07\n#define BMA150_LOW_G_HYST_REG\t\tBMA150_CFG_5_REG\n\n#define BMA150_LOW_G_DUR_REG\t\tBMA150_CFG_1_REG\n#define BMA150_LOW_G_THRES_REG\t\tBMA150_CFG_0_REG\n\nstruct bma150_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tu8 mode;\n};\n\n \nstatic const struct bma150_cfg default_cfg = {\n\t.any_motion_int = 1,\n\t.hg_int = 1,\n\t.lg_int = 1,\n\t.any_motion_dur = 0,\n\t.any_motion_thres = 0,\n\t.hg_hyst = 0,\n\t.hg_dur = 150,\n\t.hg_thres = 160,\n\t.lg_hyst = 0,\n\t.lg_dur = 150,\n\t.lg_thres = 20,\n\t.range = BMA150_RANGE_2G,\n\t.bandwidth = BMA150_BW_50HZ\n};\n\nstatic int bma150_write_byte(struct i2c_client *client, u8 reg, u8 val)\n{\n\ts32 ret;\n\n\t \n\tif (client->irq)\n\t\tdisable_irq_nosync(client->irq);\n\n\tret = i2c_smbus_write_byte_data(client, reg, val);\n\n\tif (client->irq)\n\t\tenable_irq(client->irq);\n\n\treturn ret;\n}\n\nstatic int bma150_set_reg_bits(struct i2c_client *client,\n\t\t\t\t\tint val, int shift, u8 mask, u8 reg)\n{\n\tint data;\n\n\tdata = i2c_smbus_read_byte_data(client, reg);\n\tif (data < 0)\n\t\treturn data;\n\n\tdata = (data & ~mask) | ((val << shift) & mask);\n\treturn bma150_write_byte(client, reg, data);\n}\n\nstatic int bma150_set_mode(struct bma150_data *bma150, u8 mode)\n{\n\tint error;\n\n\terror = bma150_set_reg_bits(bma150->client, mode, BMA150_WAKE_UP_POS,\n\t\t\t\tBMA150_WAKE_UP_MSK, BMA150_WAKE_UP_REG);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_set_reg_bits(bma150->client, mode, BMA150_SLEEP_POS,\n\t\t\t\tBMA150_SLEEP_MSK, BMA150_SLEEP_REG);\n\tif (error)\n\t\treturn error;\n\n\tif (mode == BMA150_MODE_NORMAL)\n\t\tusleep_range(2000, 2100);\n\n\tbma150->mode = mode;\n\treturn 0;\n}\n\nstatic int bma150_soft_reset(struct bma150_data *bma150)\n{\n\tint error;\n\n\terror = bma150_set_reg_bits(bma150->client, 1, BMA150_SW_RES_POS,\n\t\t\t\tBMA150_SW_RES_MSK, BMA150_SW_RES_REG);\n\tif (error)\n\t\treturn error;\n\n\tusleep_range(2000, 2100);\n\treturn 0;\n}\n\nstatic int bma150_set_range(struct bma150_data *bma150, u8 range)\n{\n\treturn bma150_set_reg_bits(bma150->client, range, BMA150_RANGE_POS,\n\t\t\t\tBMA150_RANGE_MSK, BMA150_RANGE_REG);\n}\n\nstatic int bma150_set_bandwidth(struct bma150_data *bma150, u8 bw)\n{\n\treturn bma150_set_reg_bits(bma150->client, bw, BMA150_BANDWIDTH_POS,\n\t\t\t\tBMA150_BANDWIDTH_MSK, BMA150_BANDWIDTH_REG);\n}\n\nstatic int bma150_set_low_g_interrupt(struct bma150_data *bma150,\n\t\t\t\t\tu8 enable, u8 hyst, u8 dur, u8 thres)\n{\n\tint error;\n\n\terror = bma150_set_reg_bits(bma150->client, hyst,\n\t\t\t\tBMA150_LOW_G_HYST_POS, BMA150_LOW_G_HYST_MSK,\n\t\t\t\tBMA150_LOW_G_HYST_REG);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_write_byte(bma150->client, BMA150_LOW_G_DUR_REG, dur);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_write_byte(bma150->client, BMA150_LOW_G_THRES_REG, thres);\n\tif (error)\n\t\treturn error;\n\n\treturn bma150_set_reg_bits(bma150->client, !!enable,\n\t\t\t\tBMA150_LOW_G_EN_POS, BMA150_LOW_G_EN_MSK,\n\t\t\t\tBMA150_LOW_G_EN_REG);\n}\n\nstatic int bma150_set_high_g_interrupt(struct bma150_data *bma150,\n\t\t\t\t\tu8 enable, u8 hyst, u8 dur, u8 thres)\n{\n\tint error;\n\n\terror = bma150_set_reg_bits(bma150->client, hyst,\n\t\t\t\tBMA150_HIGH_G_HYST_POS, BMA150_HIGH_G_HYST_MSK,\n\t\t\t\tBMA150_HIGH_G_HYST_REG);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_write_byte(bma150->client,\n\t\t\t\tBMA150_HIGH_G_DUR_REG, dur);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_write_byte(bma150->client,\n\t\t\t\tBMA150_HIGH_G_THRES_REG, thres);\n\tif (error)\n\t\treturn error;\n\n\treturn bma150_set_reg_bits(bma150->client, !!enable,\n\t\t\t\tBMA150_HIGH_G_EN_POS, BMA150_HIGH_G_EN_MSK,\n\t\t\t\tBMA150_HIGH_G_EN_REG);\n}\n\n\nstatic int bma150_set_any_motion_interrupt(struct bma150_data *bma150,\n\t\t\t\t\t\tu8 enable, u8 dur, u8 thres)\n{\n\tint error;\n\n\terror = bma150_set_reg_bits(bma150->client, dur,\n\t\t\t\tBMA150_ANY_MOTION_DUR_POS,\n\t\t\t\tBMA150_ANY_MOTION_DUR_MSK,\n\t\t\t\tBMA150_ANY_MOTION_DUR_REG);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_write_byte(bma150->client,\n\t\t\t\tBMA150_ANY_MOTION_THRES_REG, thres);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_set_reg_bits(bma150->client, !!enable,\n\t\t\t\tBMA150_ADV_INT_EN_POS, BMA150_ADV_INT_EN_MSK,\n\t\t\t\tBMA150_ADV_INT_EN_REG);\n\tif (error)\n\t\treturn error;\n\n\treturn bma150_set_reg_bits(bma150->client, !!enable,\n\t\t\t\tBMA150_ANY_MOTION_EN_POS,\n\t\t\t\tBMA150_ANY_MOTION_EN_MSK,\n\t\t\t\tBMA150_ANY_MOTION_EN_REG);\n}\n\nstatic void bma150_report_xyz(struct bma150_data *bma150)\n{\n\tu8 data[BMA150_XYZ_DATA_SIZE];\n\ts16 x, y, z;\n\ts32 ret;\n\n\tret = i2c_smbus_read_i2c_block_data(bma150->client,\n\t\t\tBMA150_ACC_X_LSB_REG, BMA150_XYZ_DATA_SIZE, data);\n\tif (ret != BMA150_XYZ_DATA_SIZE)\n\t\treturn;\n\n\tx = ((0xc0 & data[0]) >> 6) | (data[1] << 2);\n\ty = ((0xc0 & data[2]) >> 6) | (data[3] << 2);\n\tz = ((0xc0 & data[4]) >> 6) | (data[5] << 2);\n\n\tx = sign_extend32(x, 9);\n\ty = sign_extend32(y, 9);\n\tz = sign_extend32(z, 9);\n\n\tinput_report_abs(bma150->input, ABS_X, x);\n\tinput_report_abs(bma150->input, ABS_Y, y);\n\tinput_report_abs(bma150->input, ABS_Z, z);\n\tinput_sync(bma150->input);\n}\n\nstatic irqreturn_t bma150_irq_thread(int irq, void *dev)\n{\n\tbma150_report_xyz(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bma150_poll(struct input_dev *input)\n{\n\tstruct bma150_data *bma150 = input_get_drvdata(input);\n\n\tbma150_report_xyz(bma150);\n}\n\nstatic int bma150_open(struct input_dev *input)\n{\n\tstruct bma150_data *bma150 = input_get_drvdata(input);\n\tint error;\n\n\terror = pm_runtime_get_sync(&bma150->client->dev);\n\tif (error < 0 && error != -ENOSYS)\n\t\treturn error;\n\n\t \n\tif (bma150->mode != BMA150_MODE_NORMAL) {\n\t\terror = bma150_set_mode(bma150, BMA150_MODE_NORMAL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void bma150_close(struct input_dev *input)\n{\n\tstruct bma150_data *bma150 = input_get_drvdata(input);\n\n\tpm_runtime_put_sync(&bma150->client->dev);\n\n\tif (bma150->mode != BMA150_MODE_SLEEP)\n\t\tbma150_set_mode(bma150, BMA150_MODE_SLEEP);\n}\n\nstatic int bma150_initialize(struct bma150_data *bma150,\n\t\t\t     const struct bma150_cfg *cfg)\n{\n\tint error;\n\n\terror = bma150_soft_reset(bma150);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_set_bandwidth(bma150, cfg->bandwidth);\n\tif (error)\n\t\treturn error;\n\n\terror = bma150_set_range(bma150, cfg->range);\n\tif (error)\n\t\treturn error;\n\n\tif (bma150->client->irq) {\n\t\terror = bma150_set_any_motion_interrupt(bma150,\n\t\t\t\t\tcfg->any_motion_int,\n\t\t\t\t\tcfg->any_motion_dur,\n\t\t\t\t\tcfg->any_motion_thres);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = bma150_set_high_g_interrupt(bma150,\n\t\t\t\t\tcfg->hg_int, cfg->hg_hyst,\n\t\t\t\t\tcfg->hg_dur, cfg->hg_thres);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = bma150_set_low_g_interrupt(bma150,\n\t\t\t\t\tcfg->lg_int, cfg->lg_hyst,\n\t\t\t\t\tcfg->lg_dur, cfg->lg_thres);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn bma150_set_mode(bma150, BMA150_MODE_SLEEP);\n}\n\nstatic int bma150_probe(struct i2c_client *client)\n{\n\tconst struct bma150_platform_data *pdata =\n\t\t\tdev_get_platdata(&client->dev);\n\tconst struct bma150_cfg *cfg;\n\tstruct bma150_data *bma150;\n\tstruct input_dev *idev;\n\tint chip_id;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c_check_functionality error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tchip_id = i2c_smbus_read_byte_data(client, BMA150_CHIP_ID_REG);\n\tif (chip_id != BMA150_CHIP_ID) {\n\t\tdev_err(&client->dev, \"BMA150 chip id error: %d\\n\", chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tbma150 = devm_kzalloc(&client->dev, sizeof(*bma150), GFP_KERNEL);\n\tif (!bma150)\n\t\treturn -ENOMEM;\n\n\tbma150->client = client;\n\n\tif (pdata) {\n\t\tif (pdata->irq_gpio_cfg) {\n\t\t\terror = pdata->irq_gpio_cfg();\n\t\t\tif (error) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"IRQ GPIO conf. error %d, error %d\\n\",\n\t\t\t\t\tclient->irq, error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tcfg = &pdata->cfg;\n\t} else {\n\t\tcfg = &default_cfg;\n\t}\n\n\terror = bma150_initialize(bma150, cfg);\n\tif (error)\n\t\treturn error;\n\n\tidev = devm_input_allocate_device(&bma150->client->dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(idev, bma150);\n\tbma150->input = idev;\n\n\tidev->name = BMA150_DRIVER;\n\tidev->phys = BMA150_DRIVER \"/input0\";\n\tidev->id.bustype = BUS_I2C;\n\n\tidev->open = bma150_open;\n\tidev->close = bma150_close;\n\n\tinput_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL, ABSMAX_ACC_VAL, 0, 0);\n\tinput_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL, ABSMAX_ACC_VAL, 0, 0);\n\tinput_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL, ABSMAX_ACC_VAL, 0, 0);\n\n\tif (client->irq <= 0) {\n\t\terror = input_setup_polling(idev, bma150_poll);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tinput_set_poll_interval(idev, BMA150_POLL_INTERVAL);\n\t\tinput_set_min_poll_interval(idev, BMA150_POLL_MIN);\n\t\tinput_set_max_poll_interval(idev, BMA150_POLL_MAX);\n\t}\n\n\terror = input_register_device(idev);\n\tif (error)\n\t\treturn error;\n\n\tif (client->irq > 0) {\n\t\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, bma150_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tBMA150_DRIVER, bma150);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"irq request failed %d, error %d\\n\",\n\t\t\t\tclient->irq, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, bma150);\n\n\tpm_runtime_enable(&client->dev);\n\n\treturn 0;\n}\n\nstatic void bma150_remove(struct i2c_client *client)\n{\n\tpm_runtime_disable(&client->dev);\n}\n\nstatic int __maybe_unused bma150_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bma150_data *bma150 = i2c_get_clientdata(client);\n\n\treturn bma150_set_mode(bma150, BMA150_MODE_SLEEP);\n}\n\nstatic int __maybe_unused bma150_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bma150_data *bma150 = i2c_get_clientdata(client);\n\n\treturn bma150_set_mode(bma150, BMA150_MODE_NORMAL);\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(bma150_pm, bma150_suspend, bma150_resume, NULL);\n\nstatic const struct i2c_device_id bma150_id[] = {\n\t{ \"bma150\", 0 },\n\t{ \"smb380\", 0 },\n\t{ \"bma023\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, bma150_id);\n\nstatic struct i2c_driver bma150_driver = {\n\t.driver = {\n\t\t.name\t= BMA150_DRIVER,\n\t\t.pm\t= &bma150_pm,\n\t},\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.id_table\t= bma150_id,\n\t.probe\t\t= bma150_probe,\n\t.remove\t\t= bma150_remove,\n};\n\nmodule_i2c_driver(bma150_driver);\n\nMODULE_AUTHOR(\"Albert Zhang <xu.zhang@bosch-sensortec.com>\");\nMODULE_DESCRIPTION(\"BMA150 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}