{
  "module_name": "sc27xx-vibra.c",
  "hash_id": "a7686140e17c5546922ab15e34f8e8e1bc7d5ce5d2c0bf344ccf201569e528b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/sc27xx-vibra.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/workqueue.h>\n\n#define CUR_DRV_CAL_SEL\t\t\tGENMASK(13, 12)\n#define SLP_LDOVIBR_PD_EN\t\tBIT(9)\n#define LDO_VIBR_PD\t\t\tBIT(8)\n#define SC2730_CUR_DRV_CAL_SEL\t\t0\n#define SC2730_SLP_LDOVIBR_PD_EN\tBIT(14)\n#define SC2730_LDO_VIBR_PD\t\tBIT(13)\n\nstruct sc27xx_vibra_data {\n\tu32 cur_drv_cal_sel;\n\tu32 slp_pd_en;\n\tu32 ldo_pd;\n};\n\nstruct vibra_info {\n\tstruct input_dev\t*input_dev;\n\tstruct work_struct\tplay_work;\n\tstruct regmap\t\t*regmap;\n\tconst struct sc27xx_vibra_data *data;\n\tu32\t\t\tbase;\n\tu32\t\t\tstrength;\n\tbool\t\t\tenabled;\n};\n\nstatic const struct sc27xx_vibra_data sc2731_data = {\n\t.cur_drv_cal_sel = CUR_DRV_CAL_SEL,\n\t.slp_pd_en = SLP_LDOVIBR_PD_EN,\n\t.ldo_pd = LDO_VIBR_PD,\n};\n\nstatic const struct sc27xx_vibra_data sc2730_data = {\n\t.cur_drv_cal_sel = SC2730_CUR_DRV_CAL_SEL,\n\t.slp_pd_en = SC2730_SLP_LDOVIBR_PD_EN,\n\t.ldo_pd = SC2730_LDO_VIBR_PD,\n};\n\nstatic const struct sc27xx_vibra_data sc2721_data = {\n\t.cur_drv_cal_sel = CUR_DRV_CAL_SEL,\n\t.slp_pd_en = SLP_LDOVIBR_PD_EN,\n\t.ldo_pd = LDO_VIBR_PD,\n};\n\nstatic void sc27xx_vibra_set(struct vibra_info *info, bool on)\n{\n\tconst struct sc27xx_vibra_data *data = info->data;\n\tif (on) {\n\t\tregmap_update_bits(info->regmap, info->base, data->ldo_pd, 0);\n\t\tregmap_update_bits(info->regmap, info->base,\n\t\t\t\t   data->slp_pd_en, 0);\n\t\tinfo->enabled = true;\n\t} else {\n\t\tregmap_update_bits(info->regmap, info->base, data->ldo_pd,\n\t\t\t\t   data->ldo_pd);\n\t\tregmap_update_bits(info->regmap, info->base,\n\t\t\t\t   data->slp_pd_en, data->slp_pd_en);\n\t\tinfo->enabled = false;\n\t}\n}\n\nstatic int sc27xx_vibra_hw_init(struct vibra_info *info)\n{\n\tconst struct sc27xx_vibra_data *data = info->data;\n\n\tif (!data->cur_drv_cal_sel)\n\t\treturn 0;\n\n\treturn regmap_update_bits(info->regmap, info->base,\n\t\t\t\t  data->cur_drv_cal_sel, 0);\n}\n\nstatic void sc27xx_vibra_play_work(struct work_struct *work)\n{\n\tstruct vibra_info *info = container_of(work, struct vibra_info,\n\t\t\t\t\t       play_work);\n\n\tif (info->strength && !info->enabled)\n\t\tsc27xx_vibra_set(info, true);\n\telse if (info->strength == 0 && info->enabled)\n\t\tsc27xx_vibra_set(info, false);\n}\n\nstatic int sc27xx_vibra_play(struct input_dev *input, void *data,\n\t\t\t     struct ff_effect *effect)\n{\n\tstruct vibra_info *info = input_get_drvdata(input);\n\n\tinfo->strength = effect->u.rumble.weak_magnitude;\n\tschedule_work(&info->play_work);\n\n\treturn 0;\n}\n\nstatic void sc27xx_vibra_close(struct input_dev *input)\n{\n\tstruct vibra_info *info = input_get_drvdata(input);\n\n\tcancel_work_sync(&info->play_work);\n\tif (info->enabled)\n\t\tsc27xx_vibra_set(info, false);\n}\n\nstatic int sc27xx_vibra_probe(struct platform_device *pdev)\n{\n\tstruct vibra_info *info;\n\tconst struct sc27xx_vibra_data *data;\n\tint error;\n\n\tdata = device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"no matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!info->regmap) {\n\t\tdev_err(&pdev->dev, \"failed to get vibrator regmap.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terror = device_property_read_u32(&pdev->dev, \"reg\", &info->base);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to get vibrator base address.\\n\");\n\t\treturn error;\n\t}\n\n\tinfo->input_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!info->input_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->input_dev->name = \"sc27xx:vibrator\";\n\tinfo->input_dev->id.version = 0;\n\tinfo->input_dev->close = sc27xx_vibra_close;\n\tinfo->data = data;\n\n\tinput_set_drvdata(info->input_dev, info);\n\tinput_set_capability(info->input_dev, EV_FF, FF_RUMBLE);\n\tINIT_WORK(&info->play_work, sc27xx_vibra_play_work);\n\tinfo->enabled = false;\n\n\terror = sc27xx_vibra_hw_init(info);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to initialize the vibrator.\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_ff_create_memless(info->input_dev, NULL,\n\t\t\t\t\tsc27xx_vibra_play);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register vibrator to FF.\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(info->input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device.\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sc27xx_vibra_of_match[] = {\n\t{ .compatible = \"sprd,sc2721-vibrator\", .data = &sc2721_data },\n\t{ .compatible = \"sprd,sc2730-vibrator\", .data = &sc2730_data },\n\t{ .compatible = \"sprd,sc2731-vibrator\", .data = &sc2731_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sc27xx_vibra_of_match);\n\nstatic struct platform_driver sc27xx_vibra_driver = {\n\t.driver = {\n\t\t.name = \"sc27xx-vibrator\",\n\t\t.of_match_table = sc27xx_vibra_of_match,\n\t},\n\t.probe = sc27xx_vibra_probe,\n};\n\nmodule_platform_driver(sc27xx_vibra_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum SC27xx Vibrator Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Xiaotong Lu <xiaotong.lu@spreadtrum.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}