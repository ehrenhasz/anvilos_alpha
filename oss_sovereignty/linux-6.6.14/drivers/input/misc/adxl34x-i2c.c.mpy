{
  "module_name": "adxl34x-i2c.c",
  "hash_id": "27f523e737b7e63ef565a8f51425ac146d8caa45f8590a47ac686a05766b1d7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/adxl34x-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\t \n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/types.h>\n#include <linux/pm.h>\n#include \"adxl34x.h\"\n\nstatic int adxl34x_smbus_read(struct device *dev, unsigned char reg)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn i2c_smbus_read_byte_data(client, reg);\n}\n\nstatic int adxl34x_smbus_write(struct device *dev,\n\t\t\t       unsigned char reg, unsigned char val)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic int adxl34x_smbus_read_block(struct device *dev,\n\t\t\t\t    unsigned char reg, int count,\n\t\t\t\t    void *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn i2c_smbus_read_i2c_block_data(client, reg, count, buf);\n}\n\nstatic int adxl34x_i2c_read_block(struct device *dev,\n\t\t\t\t  unsigned char reg, int count,\n\t\t\t\t  void *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tret = i2c_master_send(client, &reg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_master_recv(client, buf, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != count)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic const struct adxl34x_bus_ops adxl34x_smbus_bops = {\n\t.bustype\t= BUS_I2C,\n\t.write\t\t= adxl34x_smbus_write,\n\t.read\t\t= adxl34x_smbus_read,\n\t.read_block\t= adxl34x_smbus_read_block,\n};\n\nstatic const struct adxl34x_bus_ops adxl34x_i2c_bops = {\n\t.bustype\t= BUS_I2C,\n\t.write\t\t= adxl34x_smbus_write,\n\t.read\t\t= adxl34x_smbus_read,\n\t.read_block\t= adxl34x_i2c_read_block,\n};\n\nstatic int adxl34x_i2c_probe(struct i2c_client *client)\n{\n\tstruct adxl34x *ac;\n\tint error;\n\n\terror = i2c_check_functionality(client->adapter,\n\t\t\tI2C_FUNC_SMBUS_BYTE_DATA);\n\tif (!error) {\n\t\tdev_err(&client->dev, \"SMBUS Byte Data not Supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tac = adxl34x_probe(&client->dev, client->irq, false,\n\t\t\t   i2c_check_functionality(client->adapter,\n\t\t\t\t\t\t   I2C_FUNC_SMBUS_READ_I2C_BLOCK) ?\n\t\t\t\t&adxl34x_smbus_bops : &adxl34x_i2c_bops);\n\tif (IS_ERR(ac))\n\t\treturn PTR_ERR(ac);\n\n\ti2c_set_clientdata(client, ac);\n\n\treturn 0;\n}\n\nstatic void adxl34x_i2c_remove(struct i2c_client *client)\n{\n\tstruct adxl34x *ac = i2c_get_clientdata(client);\n\n\tadxl34x_remove(ac);\n}\n\nstatic const struct i2c_device_id adxl34x_id[] = {\n\t{ \"adxl34x\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, adxl34x_id);\n\nstatic const struct of_device_id adxl34x_of_id[] = {\n\t \n\t{ .compatible = \"adi,adxl345\", },\n\t \n\t{ .compatible = \"adi,adxl34x\", },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, adxl34x_of_id);\n\nstatic struct i2c_driver adxl34x_driver = {\n\t.driver = {\n\t\t.name = \"adxl34x\",\n\t\t.pm = pm_sleep_ptr(&adxl34x_pm),\n\t\t.of_match_table = adxl34x_of_id,\n\t},\n\t.probe    = adxl34x_i2c_probe,\n\t.remove   = adxl34x_i2c_remove,\n\t.id_table = adxl34x_id,\n};\n\nmodule_i2c_driver(adxl34x_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"ADXL345/346 Three-Axis Digital Accelerometer I2C Bus Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}