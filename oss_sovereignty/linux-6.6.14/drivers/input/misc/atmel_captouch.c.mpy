{
  "module_name": "atmel_captouch.c",
  "hash_id": "aadfb3cb28428a5122aa0daf83ceb7c04d73fa667f458f5134f102ed69b22e13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/atmel_captouch.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n \n#define MAX_NUM_OF_BUTTONS\t\t8\n\n \n#define REG_KEY1_THRESHOLD\t\t0x02\n#define REG_KEY2_THRESHOLD\t\t0x03\n#define REG_KEY3_THRESHOLD\t\t0x04\n#define REG_KEY4_THRESHOLD\t\t0x05\n\n#define REG_KEY1_REF_H\t\t\t0x20\n#define REG_KEY1_REF_L\t\t\t0x21\n#define REG_KEY2_REF_H\t\t\t0x22\n#define REG_KEY2_REF_L\t\t\t0x23\n#define REG_KEY3_REF_H\t\t\t0x24\n#define REG_KEY3_REF_L\t\t\t0x25\n#define REG_KEY4_REF_H\t\t\t0x26\n#define REG_KEY4_REF_L\t\t\t0x27\n\n#define REG_KEY1_DLT_H\t\t\t0x30\n#define REG_KEY1_DLT_L\t\t\t0x31\n#define REG_KEY2_DLT_H\t\t\t0x32\n#define REG_KEY2_DLT_L\t\t\t0x33\n#define REG_KEY3_DLT_H\t\t\t0x34\n#define REG_KEY3_DLT_L\t\t\t0x35\n#define REG_KEY4_DLT_H\t\t\t0x36\n#define REG_KEY4_DLT_L\t\t\t0x37\n\n#define REG_KEY_STATE\t\t\t0x3C\n\n \nstruct atmel_captouch_device {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tu32 num_btn;\n\tu32 keycodes[MAX_NUM_OF_BUTTONS];\n\tu8 prev_btn;\n\tu8 xfer_buf[8] ____cacheline_aligned;\n};\n\n \nstatic int atmel_read(struct atmel_captouch_device *capdev,\n\t\t\t u8 reg, u8 *data, size_t len)\n{\n\tstruct i2c_client *client = capdev->client;\n\tstruct device *dev = &client->dev;\n\tstruct i2c_msg msg[2];\n\tint err;\n\n\tif (len > sizeof(capdev->xfer_buf) - 2)\n\t\treturn -EINVAL;\n\n\tcapdev->xfer_buf[0] = reg;\n\tcapdev->xfer_buf[1] = len;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = capdev->xfer_buf;\n\tmsg[0].len = 2;\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = capdev->xfer_buf;\n\tmsg[1].len = len + 2;\n\n\terr = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (err != ARRAY_SIZE(msg))\n\t\treturn err < 0 ? err : -EIO;\n\n\tif (capdev->xfer_buf[0] != reg) {\n\t\tdev_err(dev,\n\t\t\t\"I2C read error: register address does not match (%#02x vs %02x)\\n\",\n\t\t\tcapdev->xfer_buf[0], reg);\n\t\treturn -ECOMM;\n\t}\n\n\tmemcpy(data, &capdev->xfer_buf[2], len);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t atmel_captouch_isr(int irq, void *data)\n{\n\tstruct atmel_captouch_device *capdev = data;\n\tstruct device *dev = &capdev->client->dev;\n\tint error;\n\tint i;\n\tu8 new_btn;\n\tu8 changed_btn;\n\n\terror = atmel_read(capdev, REG_KEY_STATE, &new_btn, 1);\n\tif (error) {\n\t\tdev_err(dev, \"failed to read button state: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s: button state %#02x\\n\", __func__, new_btn);\n\n\tchanged_btn = new_btn ^ capdev->prev_btn;\n\tcapdev->prev_btn = new_btn;\n\n\tfor (i = 0; i < capdev->num_btn; i++) {\n\t\tif (changed_btn & BIT(i))\n\t\t\tinput_report_key(capdev->input,\n\t\t\t\t\t capdev->keycodes[i],\n\t\t\t\t\t new_btn & BIT(i));\n\t}\n\n\tinput_sync(capdev->input);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int atmel_captouch_probe(struct i2c_client *client)\n{\n\tstruct atmel_captouch_device *capdev;\n\tstruct device *dev = &client->dev;\n\tstruct device_node *node;\n\tint i;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(dev, \"needed i2c functionality is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcapdev = devm_kzalloc(dev, sizeof(*capdev), GFP_KERNEL);\n\tif (!capdev)\n\t\treturn -ENOMEM;\n\n\tcapdev->client = client;\n\n\terr = atmel_read(capdev, REG_KEY_STATE,\n\t\t\t    &capdev->prev_btn, sizeof(capdev->prev_btn));\n\tif (err) {\n\t\tdev_err(dev, \"failed to read initial button state: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tcapdev->input = devm_input_allocate_device(dev);\n\tif (!capdev->input) {\n\t\tdev_err(dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcapdev->input->id.bustype = BUS_I2C;\n\tcapdev->input->id.product = 0x880A;\n\tcapdev->input->id.version = 0;\n\tcapdev->input->name = \"ATMegaXX Capacitive Button Controller\";\n\t__set_bit(EV_KEY, capdev->input->evbit);\n\n\tnode = dev->of_node;\n\tif (!node) {\n\t\tdev_err(dev, \"failed to find matching node in device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(node, \"autorepeat\"))\n\t\t__set_bit(EV_REP, capdev->input->evbit);\n\n\tcapdev->num_btn = of_property_count_u32_elems(node, \"linux,keymap\");\n\tif (capdev->num_btn > MAX_NUM_OF_BUTTONS)\n\t\tcapdev->num_btn = MAX_NUM_OF_BUTTONS;\n\n\terr = of_property_read_u32_array(node, \"linux,keycodes\",\n\t\t\t\t\t capdev->keycodes,\n\t\t\t\t\t capdev->num_btn);\n\tif (err) {\n\t\tdev_err(dev,\n\t\t\t\"failed to read linux,keycode property: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < capdev->num_btn; i++)\n\t\t__set_bit(capdev->keycodes[i], capdev->input->keybit);\n\n\tcapdev->input->keycode = capdev->keycodes;\n\tcapdev->input->keycodesize = sizeof(capdev->keycodes[0]);\n\tcapdev->input->keycodemax = capdev->num_btn;\n\n\terr = input_register_device(capdev->input);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\tNULL, atmel_captouch_isr,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"atmel_captouch\", capdev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request irq %d: %d\\n\",\n\t\t\tclient->irq, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id atmel_captouch_of_id[] = {\n\t{\n\t\t.compatible = \"atmel,captouch\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atmel_captouch_of_id);\n\nstatic const struct i2c_device_id atmel_captouch_id[] = {\n\t{ \"atmel_captouch\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, atmel_captouch_id);\n\nstatic struct i2c_driver atmel_captouch_driver = {\n\t.probe\t\t= atmel_captouch_probe,\n\t.id_table\t= atmel_captouch_id,\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_captouch\",\n\t\t.of_match_table = atmel_captouch_of_id,\n\t},\n};\nmodule_i2c_driver(atmel_captouch_driver);\n\n \nMODULE_AUTHOR(\"Hung-yu Wu <hywu@google.com>\");\nMODULE_DESCRIPTION(\"Atmel ATmegaXX Capacitance Touch Sensor I2C Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}