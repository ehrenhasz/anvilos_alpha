{
  "module_name": "pm8xxx-vibrator.c",
  "hash_id": "8efa50078382ef2dc9508abb6256072e5eb204db7f573a6c27082a3cc0306a97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/pm8xxx-vibrator.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define VIB_MAX_LEVEL_mV\t(3100)\n#define VIB_MIN_LEVEL_mV\t(1200)\n#define VIB_MAX_LEVELS\t\t(VIB_MAX_LEVEL_mV - VIB_MIN_LEVEL_mV)\n\n#define MAX_FF_SPEED\t\t0xff\n\nstruct pm8xxx_regs {\n\tunsigned int enable_addr;\n\tunsigned int enable_mask;\n\n\tunsigned int drv_addr;\n\tunsigned int drv_mask;\n\tunsigned int drv_shift;\n\tunsigned int drv_en_manual_mask;\n};\n\nstatic const struct pm8xxx_regs pm8058_regs = {\n\t.drv_addr = 0x4A,\n\t.drv_mask = 0xf8,\n\t.drv_shift = 3,\n\t.drv_en_manual_mask = 0xfc,\n};\n\nstatic struct pm8xxx_regs pm8916_regs = {\n\t.enable_addr = 0xc046,\n\t.enable_mask = BIT(7),\n\t.drv_addr = 0xc041,\n\t.drv_mask = 0x1F,\n\t.drv_shift = 0,\n\t.drv_en_manual_mask = 0,\n};\n\n \nstruct pm8xxx_vib {\n\tstruct input_dev *vib_input_dev;\n\tstruct work_struct work;\n\tstruct regmap *regmap;\n\tconst struct pm8xxx_regs *regs;\n\tint speed;\n\tint level;\n\tbool active;\n\tu8  reg_vib_drv;\n};\n\n \nstatic int pm8xxx_vib_set(struct pm8xxx_vib *vib, bool on)\n{\n\tint rc;\n\tunsigned int val = vib->reg_vib_drv;\n\tconst struct pm8xxx_regs *regs = vib->regs;\n\n\tif (on)\n\t\tval |= (vib->level << regs->drv_shift) & regs->drv_mask;\n\telse\n\t\tval &= ~regs->drv_mask;\n\n\trc = regmap_write(vib->regmap, regs->drv_addr, val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tvib->reg_vib_drv = val;\n\n\tif (regs->enable_mask)\n\t\trc = regmap_update_bits(vib->regmap, regs->enable_addr,\n\t\t\t\t\tregs->enable_mask, on ? ~0 : 0);\n\n\treturn rc;\n}\n\n \nstatic void pm8xxx_work_handler(struct work_struct *work)\n{\n\tstruct pm8xxx_vib *vib = container_of(work, struct pm8xxx_vib, work);\n\tconst struct pm8xxx_regs *regs = vib->regs;\n\tint rc;\n\tunsigned int val;\n\n\trc = regmap_read(vib->regmap, regs->drv_addr, &val);\n\tif (rc < 0)\n\t\treturn;\n\n\t \n\tif (vib->speed) {\n\t\tvib->active = true;\n\t\tvib->level = ((VIB_MAX_LEVELS * vib->speed) / MAX_FF_SPEED) +\n\t\t\t\t\t\tVIB_MIN_LEVEL_mV;\n\t\tvib->level /= 100;\n\t} else {\n\t\tvib->active = false;\n\t\tvib->level = VIB_MIN_LEVEL_mV / 100;\n\t}\n\n\tpm8xxx_vib_set(vib, vib->active);\n}\n\n \nstatic void pm8xxx_vib_close(struct input_dev *dev)\n{\n\tstruct pm8xxx_vib *vib = input_get_drvdata(dev);\n\n\tcancel_work_sync(&vib->work);\n\tif (vib->active)\n\t\tpm8xxx_vib_set(vib, false);\n}\n\n \nstatic int pm8xxx_vib_play_effect(struct input_dev *dev, void *data,\n\t\t\t\t  struct ff_effect *effect)\n{\n\tstruct pm8xxx_vib *vib = input_get_drvdata(dev);\n\n\tvib->speed = effect->u.rumble.strong_magnitude >> 8;\n\tif (!vib->speed)\n\t\tvib->speed = effect->u.rumble.weak_magnitude >> 9;\n\n\tschedule_work(&vib->work);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_vib_probe(struct platform_device *pdev)\n{\n\tstruct pm8xxx_vib *vib;\n\tstruct input_dev *input_dev;\n\tint error;\n\tunsigned int val;\n\tconst struct pm8xxx_regs *regs;\n\n\tvib = devm_kzalloc(&pdev->dev, sizeof(*vib), GFP_KERNEL);\n\tif (!vib)\n\t\treturn -ENOMEM;\n\n\tvib->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!vib->regmap)\n\t\treturn -ENODEV;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&vib->work, pm8xxx_work_handler);\n\tvib->vib_input_dev = input_dev;\n\n\tregs = of_device_get_match_data(&pdev->dev);\n\n\t \n\terror = regmap_read(vib->regmap, regs->drv_addr, &val);\n\tif (error < 0)\n\t\treturn error;\n\n\tval &= regs->drv_en_manual_mask;\n\terror = regmap_write(vib->regmap, regs->drv_addr, val);\n\tif (error < 0)\n\t\treturn error;\n\n\tvib->regs = regs;\n\tvib->reg_vib_drv = val;\n\n\tinput_dev->name = \"pm8xxx_vib_ffmemless\";\n\tinput_dev->id.version = 1;\n\tinput_dev->close = pm8xxx_vib_close;\n\tinput_set_drvdata(input_dev, vib);\n\tinput_set_capability(vib->vib_input_dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(input_dev, NULL,\n\t\t\t\t\tpm8xxx_vib_play_effect);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"couldn't register vibrator as FF device\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"couldn't register input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, vib);\n\treturn 0;\n}\n\nstatic int pm8xxx_vib_suspend(struct device *dev)\n{\n\tstruct pm8xxx_vib *vib = dev_get_drvdata(dev);\n\n\t \n\tpm8xxx_vib_set(vib, false);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pm8xxx_vib_pm_ops, pm8xxx_vib_suspend, NULL);\n\nstatic const struct of_device_id pm8xxx_vib_id_table[] = {\n\t{ .compatible = \"qcom,pm8058-vib\", .data = &pm8058_regs },\n\t{ .compatible = \"qcom,pm8921-vib\", .data = &pm8058_regs },\n\t{ .compatible = \"qcom,pm8916-vib\", .data = &pm8916_regs },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_vib_id_table);\n\nstatic struct platform_driver pm8xxx_vib_driver = {\n\t.probe\t\t= pm8xxx_vib_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pm8xxx-vib\",\n\t\t.pm\t= pm_sleep_ptr(&pm8xxx_vib_pm_ops),\n\t\t.of_match_table = pm8xxx_vib_id_table,\n\t},\n};\nmodule_platform_driver(pm8xxx_vib_driver);\n\nMODULE_ALIAS(\"platform:pm8xxx_vib\");\nMODULE_DESCRIPTION(\"PMIC8xxx vibrator driver based on ff-memless framework\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Amy Maloche <amaloche@codeaurora.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}