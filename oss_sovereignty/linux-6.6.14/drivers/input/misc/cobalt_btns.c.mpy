{
  "module_name": "cobalt_btns.c",
  "hash_id": "b39a9bbd1374f2ece37f8a88d2fc8d6af1fb79c9f9088cf06dcb079c038843ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/cobalt_btns.c",
  "human_readable_source": "\n \n#include <linux/input.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define BUTTONS_POLL_INTERVAL\t30\t \n#define BUTTONS_COUNT_THRESHOLD\t3\n#define BUTTONS_STATUS_MASK\t0xfe000000\n\nstatic const unsigned short cobalt_map[] = {\n\tKEY_RESERVED,\n\tKEY_RESTART,\n\tKEY_LEFT,\n\tKEY_UP,\n\tKEY_DOWN,\n\tKEY_RIGHT,\n\tKEY_ENTER,\n\tKEY_SELECT\n};\n\nstruct buttons_dev {\n\tunsigned short keymap[ARRAY_SIZE(cobalt_map)];\n\tint count[ARRAY_SIZE(cobalt_map)];\n\tvoid __iomem *reg;\n};\n\nstatic void handle_buttons(struct input_dev *input)\n{\n\tstruct buttons_dev *bdev = input_get_drvdata(input);\n\tuint32_t status;\n\tint i;\n\n\tstatus = ~readl(bdev->reg) >> 24;\n\n\tfor (i = 0; i < ARRAY_SIZE(bdev->keymap); i++) {\n\t\tif (status & (1U << i)) {\n\t\t\tif (++bdev->count[i] == BUTTONS_COUNT_THRESHOLD) {\n\t\t\t\tinput_event(input, EV_MSC, MSC_SCAN, i);\n\t\t\t\tinput_report_key(input, bdev->keymap[i], 1);\n\t\t\t\tinput_sync(input);\n\t\t\t}\n\t\t} else {\n\t\t\tif (bdev->count[i] >= BUTTONS_COUNT_THRESHOLD) {\n\t\t\t\tinput_event(input, EV_MSC, MSC_SCAN, i);\n\t\t\t\tinput_report_key(input, bdev->keymap[i], 0);\n\t\t\t\tinput_sync(input);\n\t\t\t}\n\t\t\tbdev->count[i] = 0;\n\t\t}\n\t}\n}\n\nstatic int cobalt_buttons_probe(struct platform_device *pdev)\n{\n\tstruct buttons_dev *bdev;\n\tstruct input_dev *input;\n\tstruct resource *res;\n\tint error, i;\n\n\tbdev = devm_kzalloc(&pdev->dev, sizeof(*bdev), GFP_KERNEL);\n\tif (!bdev)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EBUSY;\n\n\tbdev->reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!bdev->reg)\n\t\treturn -ENOMEM;\n\n\tmemcpy(bdev->keymap, cobalt_map, sizeof(bdev->keymap));\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(input, bdev);\n\n\tinput->name = \"Cobalt buttons\";\n\tinput->phys = \"cobalt/input0\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput->keycode = bdev->keymap;\n\tinput->keycodemax = ARRAY_SIZE(bdev->keymap);\n\tinput->keycodesize = sizeof(unsigned short);\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\t__set_bit(EV_KEY, input->evbit);\n\tfor (i = 0; i < ARRAY_SIZE(cobalt_map); i++)\n\t\t__set_bit(bdev->keymap[i], input->keybit);\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\n\terror = input_setup_polling(input, handle_buttons);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_poll_interval(input, BUTTONS_POLL_INTERVAL);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nMODULE_AUTHOR(\"Yoichi Yuasa <yuasa@linux-mips.org>\");\nMODULE_DESCRIPTION(\"Cobalt button interface driver\");\nMODULE_LICENSE(\"GPL\");\n \nMODULE_ALIAS(\"platform:Cobalt buttons\");\n\nstatic struct platform_driver cobalt_buttons_driver = {\n\t.probe\t= cobalt_buttons_probe,\n\t.driver\t= {\n\t\t.name\t= \"Cobalt buttons\",\n\t},\n};\nmodule_platform_driver(cobalt_buttons_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}