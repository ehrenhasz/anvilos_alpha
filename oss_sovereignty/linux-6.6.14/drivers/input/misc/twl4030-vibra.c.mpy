{
  "module_name": "twl4030-vibra.c",
  "hash_id": "ec078d21f4c856215d15f9732d1392a1b5594e7bfb3fdf5d520cdd85bd553da1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/twl4030-vibra.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/workqueue.h>\n#include <linux/mfd/twl.h>\n#include <linux/mfd/twl4030-audio.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n\n \n#define LEDEN\t\t0x00\n\n \n#define EFFECT_DIR_180_DEG\t0x8000  \n\nstruct vibra_info {\n\tstruct device\t\t*dev;\n\tstruct input_dev\t*input_dev;\n\n\tstruct work_struct\tplay_work;\n\n\tbool\t\t\tenabled;\n\tint\t\t\tspeed;\n\tint\t\t\tdirection;\n\n\tbool\t\t\tcoexist;\n};\n\nstatic void vibra_disable_leds(void)\n{\n\tu8 reg;\n\n\t \n\ttwl_i2c_read_u8(TWL4030_MODULE_LED, &reg, LEDEN);\n\treg &= ~0x03;\n\ttwl_i2c_write_u8(TWL4030_MODULE_LED, LEDEN, reg);\n}\n\n \nstatic void vibra_enable(struct vibra_info *info)\n{\n\tu8 reg;\n\n\ttwl4030_audio_enable_resource(TWL4030_AUDIO_RES_POWER);\n\n\t \n\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t&reg, TWL4030_REG_VIBRA_CTL);\n\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t (reg | TWL4030_VIBRA_EN), TWL4030_REG_VIBRA_CTL);\n\n\ttwl4030_audio_enable_resource(TWL4030_AUDIO_RES_APLL);\n\n\tinfo->enabled = true;\n}\n\nstatic void vibra_disable(struct vibra_info *info)\n{\n\tu8 reg;\n\n\t \n\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t&reg, TWL4030_REG_VIBRA_CTL);\n\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t (reg & ~TWL4030_VIBRA_EN), TWL4030_REG_VIBRA_CTL);\n\n\ttwl4030_audio_disable_resource(TWL4030_AUDIO_RES_APLL);\n\ttwl4030_audio_disable_resource(TWL4030_AUDIO_RES_POWER);\n\n\tinfo->enabled = false;\n}\n\nstatic void vibra_play_work(struct work_struct *work)\n{\n\tstruct vibra_info *info = container_of(work,\n\t\t\tstruct vibra_info, play_work);\n\tint dir;\n\tint pwm;\n\tu8 reg;\n\n\tdir = info->direction;\n\tpwm = info->speed;\n\n\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t&reg, TWL4030_REG_VIBRA_CTL);\n\tif (pwm && (!info->coexist || !(reg & TWL4030_VIBRA_SEL))) {\n\n\t\tif (!info->enabled)\n\t\t\tvibra_enable(info);\n\n\t\t \n\t\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t\t&reg, TWL4030_REG_VIBRA_CTL);\n\t\treg = (dir) ? (reg | TWL4030_VIBRA_DIR) :\n\t\t\t(reg & ~TWL4030_VIBRA_DIR);\n\t\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t\t reg, TWL4030_REG_VIBRA_CTL);\n\n\t\t \n\t\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t\t 256 - pwm, TWL4030_REG_VIBRA_SET);\n\t} else {\n\t\tif (info->enabled)\n\t\t\tvibra_disable(info);\n\t}\n}\n\n \n\nstatic int vibra_play(struct input_dev *input, void *data,\n\t\t      struct ff_effect *effect)\n{\n\tstruct vibra_info *info = input_get_drvdata(input);\n\n\tinfo->speed = effect->u.rumble.strong_magnitude >> 8;\n\tif (!info->speed)\n\t\tinfo->speed = effect->u.rumble.weak_magnitude >> 9;\n\tinfo->direction = effect->direction < EFFECT_DIR_180_DEG ? 0 : 1;\n\tschedule_work(&info->play_work);\n\treturn 0;\n}\n\nstatic void twl4030_vibra_close(struct input_dev *input)\n{\n\tstruct vibra_info *info = input_get_drvdata(input);\n\n\tcancel_work_sync(&info->play_work);\n\n\tif (info->enabled)\n\t\tvibra_disable(info);\n}\n\n \nstatic int twl4030_vibra_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct vibra_info *info = platform_get_drvdata(pdev);\n\n\tif (info->enabled)\n\t\tvibra_disable(info);\n\n\treturn 0;\n}\n\nstatic int twl4030_vibra_resume(struct device *dev)\n{\n\tvibra_disable_leds();\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(twl4030_vibra_pm_ops,\n\t\t\t\ttwl4030_vibra_suspend, twl4030_vibra_resume);\n\nstatic bool twl4030_vibra_check_coexist(struct device_node *parent)\n{\n\tstruct device_node *node;\n\n\tnode = of_get_child_by_name(parent, \"codec\");\n\tif (node) {\n\t\tof_node_put(node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int twl4030_vibra_probe(struct platform_device *pdev)\n{\n\tstruct device_node *twl4030_core_node = pdev->dev.parent->of_node;\n\tstruct vibra_info *info;\n\tint ret;\n\n\tif (!twl4030_core_node) {\n\t\tdev_dbg(&pdev->dev, \"twl4030 OF node is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = &pdev->dev;\n\tinfo->coexist = twl4030_vibra_check_coexist(twl4030_core_node);\n\tINIT_WORK(&info->play_work, vibra_play_work);\n\n\tinfo->input_dev = devm_input_allocate_device(&pdev->dev);\n\tif (info->input_dev == NULL) {\n\t\tdev_err(&pdev->dev, \"couldn't allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(info->input_dev, info);\n\n\tinfo->input_dev->name = \"twl4030:vibrator\";\n\tinfo->input_dev->id.version = 1;\n\tinfo->input_dev->close = twl4030_vibra_close;\n\t__set_bit(FF_RUMBLE, info->input_dev->ffbit);\n\n\tret = input_ff_create_memless(info->input_dev, NULL, vibra_play);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"couldn't register vibrator to FF\\n\");\n\t\treturn ret;\n\t}\n\n\tret = input_register_device(info->input_dev);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"couldn't register input device\\n\");\n\t\tgoto err_iff;\n\t}\n\n\tvibra_disable_leds();\n\n\tplatform_set_drvdata(pdev, info);\n\treturn 0;\n\nerr_iff:\n\tinput_ff_destroy(info->input_dev);\n\treturn ret;\n}\n\nstatic struct platform_driver twl4030_vibra_driver = {\n\t.probe\t\t= twl4030_vibra_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"twl4030-vibra\",\n\t\t.pm\t= pm_sleep_ptr(&twl4030_vibra_pm_ops),\n\t},\n};\nmodule_platform_driver(twl4030_vibra_driver);\n\nMODULE_ALIAS(\"platform:twl4030-vibra\");\nMODULE_DESCRIPTION(\"TWL4030 Vibra driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Nokia Corporation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}