{
  "module_name": "gpio_decoder.c",
  "hash_id": "aa5b17455c7f0fd486e3b277a19f982837c654e10027cb79eaff447b8d9b1de4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/gpio_decoder.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\nstruct gpio_decoder {\n\tstruct gpio_descs *input_gpios;\n\tstruct device *dev;\n\tu32 axis;\n\tu32 last_stable;\n};\n\nstatic int gpio_decoder_get_gpios_state(struct gpio_decoder *decoder)\n{\n\tstruct gpio_descs *gpios = decoder->input_gpios;\n\tunsigned int ret = 0;\n\tint i, val;\n\n\tfor (i = 0; i < gpios->ndescs; i++) {\n\t\tval = gpiod_get_value_cansleep(gpios->desc[i]);\n\t\tif (val < 0) {\n\t\t\tdev_err(decoder->dev,\n\t\t\t\t\"Error reading gpio %d: %d\\n\",\n\t\t\t\tdesc_to_gpio(gpios->desc[i]), val);\n\t\t\treturn val;\n\t\t}\n\n\t\tval = !!val;\n\t\tret = (ret << 1) | val;\n\t}\n\n\treturn ret;\n}\n\nstatic void gpio_decoder_poll_gpios(struct input_dev *input)\n{\n\tstruct gpio_decoder *decoder = input_get_drvdata(input);\n\tint state;\n\n\tstate = gpio_decoder_get_gpios_state(decoder);\n\tif (state >= 0 && state != decoder->last_stable) {\n\t\tinput_report_abs(input, decoder->axis, state);\n\t\tinput_sync(input);\n\t\tdecoder->last_stable = state;\n\t}\n}\n\nstatic int gpio_decoder_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_decoder *decoder;\n\tstruct input_dev *input;\n\tu32  max;\n\tint err;\n\n\tdecoder = devm_kzalloc(dev, sizeof(*decoder), GFP_KERNEL);\n\tif (!decoder)\n\t\treturn -ENOMEM;\n\n\tdecoder->dev = dev;\n\tdevice_property_read_u32(dev, \"linux,axis\", &decoder->axis);\n\n\tdecoder->input_gpios = devm_gpiod_get_array(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(decoder->input_gpios)) {\n\t\tdev_err(dev, \"unable to acquire input gpios\\n\");\n\t\treturn PTR_ERR(decoder->input_gpios);\n\t}\n\n\tif (decoder->input_gpios->ndescs < 2) {\n\t\tdev_err(dev, \"not enough gpios found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(dev, \"decoder-max-value\", &max))\n\t\tmax = (1U << decoder->input_gpios->ndescs) - 1;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(input, decoder);\n\n\tinput->name = pdev->name;\n\tinput->id.bustype = BUS_HOST;\n\tinput_set_abs_params(input, decoder->axis, 0, max, 0, 0);\n\n\terr = input_setup_polling(input, gpio_decoder_poll_gpios);\n\tif (err) {\n\t\tdev_err(dev, \"failed to set up polling\\n\");\n\t\treturn err;\n\t}\n\n\terr = input_register_device(input);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register input device\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id gpio_decoder_of_match[] = {\n\t{ .compatible = \"gpio-decoder\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gpio_decoder_of_match);\n#endif\n\nstatic struct platform_driver gpio_decoder_driver = {\n\t.probe\t\t= gpio_decoder_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-decoder\",\n\t\t.of_match_table = of_match_ptr(gpio_decoder_of_match),\n\t}\n};\nmodule_platform_driver(gpio_decoder_driver);\n\nMODULE_DESCRIPTION(\"GPIO decoder input driver\");\nMODULE_AUTHOR(\"Vignesh R <vigneshr@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}