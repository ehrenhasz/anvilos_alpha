{
  "module_name": "max8997_haptic.c",
  "hash_id": "b464dcef43de08037790ae1e227696bd00c3a193437940b0e6f6ab11b4828d97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/max8997_haptic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/pwm.h>\n#include <linux/input.h>\n#include <linux/mfd/max8997-private.h>\n#include <linux/mfd/max8997.h>\n#include <linux/regulator/consumer.h>\n\n \n#define MAX8997_MOTOR_TYPE_SHIFT\t7\n#define MAX8997_ENABLE_SHIFT\t\t6\n#define MAX8997_MODE_SHIFT\t\t5\n\n \n#define MAX8997_CYCLE_SHIFT\t\t6\n#define MAX8997_SIG_PERIOD_SHIFT\t4\n#define MAX8997_SIG_DUTY_SHIFT\t\t2\n#define MAX8997_PWM_DUTY_SHIFT\t\t0\n\nstruct max8997_haptic {\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct regulator *regulator;\n\n\tstruct work_struct work;\n\tstruct mutex mutex;\n\n\tbool enabled;\n\tunsigned int level;\n\n\tstruct pwm_device *pwm;\n\tunsigned int pwm_period;\n\tenum max8997_haptic_pwm_divisor pwm_divisor;\n\n\tenum max8997_haptic_motor_type type;\n\tenum max8997_haptic_pulse_mode mode;\n\n\tunsigned int internal_mode_pattern;\n\tunsigned int pattern_cycle;\n\tunsigned int pattern_signal_period;\n};\n\nstatic int max8997_haptic_set_duty_cycle(struct max8997_haptic *chip)\n{\n\tint ret = 0;\n\n\tif (chip->mode == MAX8997_EXTERNAL_MODE) {\n\t\tunsigned int duty = chip->pwm_period * chip->level / 100;\n\t\tret = pwm_config(chip->pwm, duty, chip->pwm_period);\n\t} else {\n\t\tu8 duty_index = 0;\n\n\t\tduty_index = DIV_ROUND_UP(chip->level * 64, 100);\n\n\t\tswitch (chip->internal_mode_pattern) {\n\t\tcase 0:\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGPWMDC1, duty_index);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGPWMDC2, duty_index);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGPWMDC3, duty_index);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGPWMDC4, duty_index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void max8997_haptic_configure(struct max8997_haptic *chip)\n{\n\tu8 value;\n\n\tvalue = chip->type << MAX8997_MOTOR_TYPE_SHIFT |\n\t\tchip->enabled << MAX8997_ENABLE_SHIFT |\n\t\tchip->mode << MAX8997_MODE_SHIFT | chip->pwm_divisor;\n\tmax8997_write_reg(chip->client, MAX8997_HAPTIC_REG_CONF2, value);\n\n\tif (chip->mode == MAX8997_INTERNAL_MODE && chip->enabled) {\n\t\tvalue = chip->internal_mode_pattern << MAX8997_CYCLE_SHIFT |\n\t\t\tchip->internal_mode_pattern << MAX8997_SIG_PERIOD_SHIFT |\n\t\t\tchip->internal_mode_pattern << MAX8997_SIG_DUTY_SHIFT |\n\t\t\tchip->internal_mode_pattern << MAX8997_PWM_DUTY_SHIFT;\n\t\tmax8997_write_reg(chip->client,\n\t\t\tMAX8997_HAPTIC_REG_DRVCONF, value);\n\n\t\tswitch (chip->internal_mode_pattern) {\n\t\tcase 0:\n\t\t\tvalue = chip->pattern_cycle << 4;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_CYCLECONF1, value);\n\t\t\tvalue = chip->pattern_signal_period;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGCONF1, value);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tvalue = chip->pattern_cycle;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_CYCLECONF1, value);\n\t\t\tvalue = chip->pattern_signal_period;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGCONF2, value);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tvalue = chip->pattern_cycle << 4;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_CYCLECONF2, value);\n\t\t\tvalue = chip->pattern_signal_period;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGCONF3, value);\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tvalue = chip->pattern_cycle;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_CYCLECONF2, value);\n\t\t\tvalue = chip->pattern_signal_period;\n\t\t\tmax8997_write_reg(chip->client,\n\t\t\t\tMAX8997_HAPTIC_REG_SIGCONF4, value);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void max8997_haptic_enable(struct max8997_haptic *chip)\n{\n\tint error;\n\n\tmutex_lock(&chip->mutex);\n\n\terror = max8997_haptic_set_duty_cycle(chip);\n\tif (error) {\n\t\tdev_err(chip->dev, \"set_pwm_cycle failed, error: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tif (!chip->enabled) {\n\t\terror = regulator_enable(chip->regulator);\n\t\tif (error) {\n\t\t\tdev_err(chip->dev, \"Failed to enable regulator\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tmax8997_haptic_configure(chip);\n\t\tif (chip->mode == MAX8997_EXTERNAL_MODE) {\n\t\t\terror = pwm_enable(chip->pwm);\n\t\t\tif (error) {\n\t\t\t\tdev_err(chip->dev, \"Failed to enable PWM\\n\");\n\t\t\t\tregulator_disable(chip->regulator);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tchip->enabled = true;\n\t}\n\nout:\n\tmutex_unlock(&chip->mutex);\n}\n\nstatic void max8997_haptic_disable(struct max8997_haptic *chip)\n{\n\tmutex_lock(&chip->mutex);\n\n\tif (chip->enabled) {\n\t\tchip->enabled = false;\n\t\tmax8997_haptic_configure(chip);\n\t\tif (chip->mode == MAX8997_EXTERNAL_MODE)\n\t\t\tpwm_disable(chip->pwm);\n\t\tregulator_disable(chip->regulator);\n\t}\n\n\tmutex_unlock(&chip->mutex);\n}\n\nstatic void max8997_haptic_play_effect_work(struct work_struct *work)\n{\n\tstruct max8997_haptic *chip =\n\t\t\tcontainer_of(work, struct max8997_haptic, work);\n\n\tif (chip->level)\n\t\tmax8997_haptic_enable(chip);\n\telse\n\t\tmax8997_haptic_disable(chip);\n}\n\nstatic int max8997_haptic_play_effect(struct input_dev *dev, void *data,\n\t\t\t\t  struct ff_effect *effect)\n{\n\tstruct max8997_haptic *chip = input_get_drvdata(dev);\n\n\tchip->level = effect->u.rumble.strong_magnitude;\n\tif (!chip->level)\n\t\tchip->level = effect->u.rumble.weak_magnitude;\n\n\tschedule_work(&chip->work);\n\n\treturn 0;\n}\n\nstatic void max8997_haptic_close(struct input_dev *dev)\n{\n\tstruct max8997_haptic *chip = input_get_drvdata(dev);\n\n\tcancel_work_sync(&chip->work);\n\tmax8997_haptic_disable(chip);\n}\n\nstatic int max8997_haptic_probe(struct platform_device *pdev)\n{\n\tstruct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tconst struct max8997_platform_data *pdata =\n\t\t\t\t\tdev_get_platdata(iodev->dev);\n\tconst struct max8997_haptic_platform_data *haptic_pdata = NULL;\n\tstruct max8997_haptic *chip;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tif (pdata)\n\t\thaptic_pdata = pdata->haptic_pdata;\n\n\tif (!haptic_pdata) {\n\t\tdev_err(&pdev->dev, \"no haptic platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip = kzalloc(sizeof(struct max8997_haptic), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!chip || !input_dev) {\n\t\tdev_err(&pdev->dev, \"unable to allocate memory\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tINIT_WORK(&chip->work, max8997_haptic_play_effect_work);\n\tmutex_init(&chip->mutex);\n\n\tchip->client = iodev->haptic;\n\tchip->dev = &pdev->dev;\n\tchip->input_dev = input_dev;\n\tchip->pwm_period = haptic_pdata->pwm_period;\n\tchip->type = haptic_pdata->type;\n\tchip->mode = haptic_pdata->mode;\n\tchip->pwm_divisor = haptic_pdata->pwm_divisor;\n\n\tswitch (chip->mode) {\n\tcase MAX8997_INTERNAL_MODE:\n\t\tchip->internal_mode_pattern =\n\t\t\t\thaptic_pdata->internal_mode_pattern;\n\t\tchip->pattern_cycle = haptic_pdata->pattern_cycle;\n\t\tchip->pattern_signal_period =\n\t\t\t\thaptic_pdata->pattern_signal_period;\n\t\tbreak;\n\n\tcase MAX8997_EXTERNAL_MODE:\n\t\tchip->pwm = pwm_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(chip->pwm)) {\n\t\t\terror = PTR_ERR(chip->pwm);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"unable to request PWM for haptic, error: %d\\n\",\n\t\t\t\terror);\n\t\t\tgoto err_free_mem;\n\t\t}\n\n\t\t \n\t\tpwm_apply_args(chip->pwm);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Invalid chip mode specified (%d)\\n\", chip->mode);\n\t\terror = -EINVAL;\n\t\tgoto err_free_mem;\n\t}\n\n\tchip->regulator = regulator_get(&pdev->dev, \"inmotor\");\n\tif (IS_ERR(chip->regulator)) {\n\t\terror = PTR_ERR(chip->regulator);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to get regulator, error: %d\\n\",\n\t\t\terror);\n\t\tgoto err_free_pwm;\n\t}\n\n\tinput_dev->name = \"max8997-haptic\";\n\tinput_dev->id.version = 1;\n\tinput_dev->dev.parent = &pdev->dev;\n\tinput_dev->close = max8997_haptic_close;\n\tinput_set_drvdata(input_dev, chip);\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(input_dev, NULL,\n\t\t\t\tmax8997_haptic_play_effect);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to create FF device, error: %d\\n\",\n\t\t\terror);\n\t\tgoto err_put_regulator;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to register input device, error: %d\\n\",\n\t\t\terror);\n\t\tgoto err_destroy_ff;\n\t}\n\n\tplatform_set_drvdata(pdev, chip);\n\treturn 0;\n\nerr_destroy_ff:\n\tinput_ff_destroy(input_dev);\nerr_put_regulator:\n\tregulator_put(chip->regulator);\nerr_free_pwm:\n\tif (chip->mode == MAX8997_EXTERNAL_MODE)\n\t\tpwm_put(chip->pwm);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(chip);\n\n\treturn error;\n}\n\nstatic int max8997_haptic_remove(struct platform_device *pdev)\n{\n\tstruct max8997_haptic *chip = platform_get_drvdata(pdev);\n\n\tinput_unregister_device(chip->input_dev);\n\tregulator_put(chip->regulator);\n\n\tif (chip->mode == MAX8997_EXTERNAL_MODE)\n\t\tpwm_put(chip->pwm);\n\n\tkfree(chip);\n\n\treturn 0;\n}\n\nstatic int max8997_haptic_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct max8997_haptic *chip = platform_get_drvdata(pdev);\n\n\tmax8997_haptic_disable(chip);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max8997_haptic_pm_ops,\n\t\t\t\tmax8997_haptic_suspend, NULL);\n\nstatic const struct platform_device_id max8997_haptic_id[] = {\n\t{ \"max8997-haptic\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, max8997_haptic_id);\n\nstatic struct platform_driver max8997_haptic_driver = {\n\t.driver\t= {\n\t\t.name\t= \"max8997-haptic\",\n\t\t.pm\t= pm_sleep_ptr(&max8997_haptic_pm_ops),\n\t},\n\t.probe\t\t= max8997_haptic_probe,\n\t.remove\t\t= max8997_haptic_remove,\n\t.id_table\t= max8997_haptic_id,\n};\nmodule_platform_driver(max8997_haptic_driver);\n\nMODULE_AUTHOR(\"Donggeun Kim <dg77.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"max8997_haptic driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}