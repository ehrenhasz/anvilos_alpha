{
  "module_name": "yealink.c",
  "hash_id": "f64993c74c9328efbc8c21d774e627fd57929565b0be3fa69c8da904b7a7eb98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/yealink.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/rwsem.h>\n#include <linux/usb/input.h>\n#include <linux/map_to_7segment.h>\n\n#include \"yealink.h\"\n\n#define DRIVER_VERSION \"yld-20051230\"\n\n#define YEALINK_POLLING_FREQUENCY\t10\t \n\nstruct yld_status {\n\tu8\tlcd[24];\n\tu8\tled;\n\tu8\tdialtone;\n\tu8\tringtone;\n\tu8\tkeynum;\n} __attribute__ ((packed));\n\n \n#define _LOC(k,l)\t{ .a = (k), .m = (l) }\n#define _SEG(t, a, am, b, bm, c, cm, d, dm, e, em, f, fm, g, gm)\t\\\n\t{ .type\t= (t),\t\t\t\t\t\t\t\\\n\t  .u = { .s = {\t_LOC(a, am), _LOC(b, bm), _LOC(c, cm),\t\t\\\n\t\t        _LOC(d, dm), _LOC(e, em), _LOC(g, gm),\t\t\\\n\t\t\t_LOC(f, fm) } } }\n#define _PIC(t, h, hm, n)\t\t\t\t\t\t\\\n\t{ .type\t= (t),\t\t\t\t\t\t\t\\\n \t  .u = { .p = { .name = (n), .a = (h), .m = (hm) } } }\n\nstatic const struct lcd_segment_map {\n\tchar\ttype;\n\tunion {\n\t\tstruct pictogram_map {\n\t\t\tu8\ta,m;\n\t\t\tchar\tname[10];\n\t\t}\tp;\n\t\tstruct segment_map {\n\t\t\tu8\ta,m;\n\t\t} s[7];\n\t} u;\n} lcdMap[] = {\n#include \"yealink.h\"\n};\n\nstruct yealink_dev {\n\tstruct input_dev *idev;\t\t \n\tstruct usb_device *udev;\t \n\tstruct usb_interface *intf;\t \n\n\t \n\tstruct yld_ctl_packet\t*irq_data;\n\tdma_addr_t\t\tirq_dma;\n\tstruct urb\t\t*urb_irq;\n\n\t \n\tstruct yld_ctl_packet\t*ctl_data;\n\tdma_addr_t\t\tctl_dma;\n\tstruct usb_ctrlrequest\t*ctl_req;\n\tstruct urb\t\t*urb_ctl;\n\n\tchar phys[64];\t\t\t \n\n\tu8 lcdMap[ARRAY_SIZE(lcdMap)];\t \n\tint key_code;\t\t\t \n\n\tunsigned int shutdown:1;\n\n\tint\tstat_ix;\n\tunion {\n\t\tstruct yld_status s;\n\t\tu8\t\t  b[sizeof(struct yld_status)];\n\t} master, copy;\n};\n\n\n \n\n \nstatic SEG7_DEFAULT_MAP(map_seg7);\n\n  \nstatic int setChar(struct yealink_dev *yld, int el, int chr)\n{\n\tint i, a, m, val;\n\n\tif (el >= ARRAY_SIZE(lcdMap))\n\t\treturn -EINVAL;\n\n\tif (chr == '\\t' || chr == '\\n')\n\t    return 0;\n\n\tyld->lcdMap[el] = chr;\n\n\tif (lcdMap[el].type == '.') {\n\t\ta = lcdMap[el].u.p.a;\n\t\tm = lcdMap[el].u.p.m;\n\t\tif (chr != ' ')\n\t\t\tyld->master.b[a] |= m;\n\t\telse\n\t\t\tyld->master.b[a] &= ~m;\n\t\treturn 0;\n\t}\n\n\tval = map_to_seg7(&map_seg7, chr);\n\tfor (i = 0; i < ARRAY_SIZE(lcdMap[0].u.s); i++) {\n\t\tm = lcdMap[el].u.s[i].m;\n\n\t\tif (m == 0)\n\t\t\tcontinue;\n\n\t\ta = lcdMap[el].u.s[i].a;\n\t\tif (val & 1)\n\t\t\tyld->master.b[a] |= m;\n\t\telse\n\t\t\tyld->master.b[a] &= ~m;\n\t\tval = val >> 1;\n\t}\n\treturn 0;\n};\n\n \n\n \nstatic int map_p1k_to_key(int scancode)\n{\n\tswitch(scancode) {\t\t \n\tcase 0x23: return KEY_LEFT;\t \n\tcase 0x33: return KEY_UP;\t \n\tcase 0x04: return KEY_RIGHT;\t \n\tcase 0x24: return KEY_DOWN;\t \n\tcase 0x03: return KEY_ENTER;\t \n\tcase 0x14: return KEY_BACKSPACE;  \n\tcase 0x13: return KEY_ESC;\t \n\tcase 0x00: return KEY_1;\t \n\tcase 0x01: return KEY_2;\t \n\tcase 0x02: return KEY_3;\t \n\tcase 0x10: return KEY_4;\t \n\tcase 0x11: return KEY_5;\t \n\tcase 0x12: return KEY_6;\t \n\tcase 0x20: return KEY_7;\t \n\tcase 0x21: return KEY_8;\t \n\tcase 0x22: return KEY_9;\t \n\tcase 0x30: return KEY_KPASTERISK;  \n\tcase 0x31: return KEY_0;\t \n\tcase 0x32: return KEY_LEFTSHIFT |\n\t\t\t  KEY_3 << 8;\t \n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void report_key(struct yealink_dev *yld, int key)\n{\n\tstruct input_dev *idev = yld->idev;\n\n\tif (yld->key_code >= 0) {\n\t\t \n\t\tinput_report_key(idev, yld->key_code & 0xff, 0);\n\t\tif (yld->key_code >> 8)\n\t\t\tinput_report_key(idev, yld->key_code >> 8, 0);\n\t}\n\n\tyld->key_code = key;\n\tif (key >= 0) {\n\t\t \n\t\tinput_report_key(idev, key & 0xff, 1);\n\t\tif (key >> 8)\n\t\t\tinput_report_key(idev, key >> 8, 1);\n\t}\n\tinput_sync(idev);\n}\n\n \n\nstatic int yealink_cmd(struct yealink_dev *yld, struct yld_ctl_packet *p)\n{\n\tu8\t*buf = (u8 *)p;\n\tint\ti;\n\tu8\tsum = 0;\n\n\tfor(i=0; i<USB_PKT_LEN-1; i++)\n\t\tsum -= buf[i];\n\tp->sum = sum;\n\treturn usb_control_msg(yld->udev,\n\t\t\tusb_sndctrlpipe(yld->udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t0x200, 3,\n\t\t\tp, sizeof(*p),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\nstatic u8 default_ringtone[] = {\n\t0xEF,\t\t\t \n\t0xFB, 0x1E, 0x00, 0x0C,\t \n\t0xFC, 0x18, 0x00, 0x0C,\t \n\t0xFB, 0x1E, 0x00, 0x0C,\n\t0xFC, 0x18, 0x00, 0x0C,\n\t0xFB, 0x1E, 0x00, 0x0C,\n\t0xFC, 0x18, 0x00, 0x0C,\n\t0xFB, 0x1E, 0x00, 0x0C,\n\t0xFC, 0x18, 0x00, 0x0C,\n\t0xFF, 0xFF, 0x01, 0x90,\t \n\t0x00, 0x00\t\t \n};\n\nstatic int yealink_set_ringtone(struct yealink_dev *yld, u8 *buf, size_t size)\n{\n\tstruct yld_ctl_packet *p = yld->ctl_data;\n\tint\tix, len;\n\n\tif (size <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tmemset(yld->ctl_data, 0, sizeof(*(yld->ctl_data)));\n\tyld->ctl_data->cmd\t= CMD_RING_VOLUME;\n\tyld->ctl_data->size\t= 1;\n\tyld->ctl_data->data[0]\t= buf[0];\n\tyealink_cmd(yld, p);\n\n\tbuf++;\n\tsize--;\n\n\tp->cmd = CMD_RING_NOTE;\n\tix = 0;\n\twhile (size != ix) {\n\t\tlen = size - ix;\n\t\tif (len > sizeof(p->data))\n\t\t\tlen = sizeof(p->data);\n\t\tp->size\t  = len;\n\t\tp->offset = cpu_to_be16(ix);\n\t\tmemcpy(p->data, &buf[ix], len);\n\t\tyealink_cmd(yld, p);\n\t\tix += len;\n\t}\n\treturn 0;\n}\n\n \nstatic int yealink_do_idle_tasks(struct yealink_dev *yld)\n{\n\tu8 val;\n\tint i, ix, len;\n\n\tix = yld->stat_ix;\n\n\tmemset(yld->ctl_data, 0, sizeof(*(yld->ctl_data)));\n\tyld->ctl_data->cmd  = CMD_KEYPRESS;\n\tyld->ctl_data->size = 1;\n\tyld->ctl_data->sum  = 0xff - CMD_KEYPRESS;\n\n\t \n\tif (ix >= sizeof(yld->master)) {\n\t\tyld->stat_ix = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tdo {\n\t\tval = yld->master.b[ix];\n\t\tif (val != yld->copy.b[ix])\n\t\t\tgoto send_update;\n\t} while (++ix < sizeof(yld->master));\n\n\t \n\tyld->stat_ix = 0;\n\t \n\treturn 0;\n\nsend_update:\n\n\t \n\tyld->copy.b[ix] = val;\n\tyld->ctl_data->data[0] = val;\n\n\tswitch(ix) {\n\tcase offsetof(struct yld_status, led):\n\t\tyld->ctl_data->cmd\t= CMD_LED;\n\t\tyld->ctl_data->sum\t= -1 - CMD_LED - val;\n\t\tbreak;\n\tcase offsetof(struct yld_status, dialtone):\n\t\tyld->ctl_data->cmd\t= CMD_DIALTONE;\n\t\tyld->ctl_data->sum\t= -1 - CMD_DIALTONE - val;\n\t\tbreak;\n\tcase offsetof(struct yld_status, ringtone):\n\t\tyld->ctl_data->cmd\t= CMD_RINGTONE;\n\t\tyld->ctl_data->sum\t= -1 - CMD_RINGTONE - val;\n\t\tbreak;\n\tcase offsetof(struct yld_status, keynum):\n\t\tval--;\n\t\tval &= 0x1f;\n\t\tyld->ctl_data->cmd\t= CMD_SCANCODE;\n\t\tyld->ctl_data->offset\t= cpu_to_be16(val);\n\t\tyld->ctl_data->data[0]\t= 0;\n\t\tyld->ctl_data->sum\t= -1 - CMD_SCANCODE - val;\n\t\tbreak;\n\tdefault:\n\t\tlen = sizeof(yld->master.s.lcd) - ix;\n\t\tif (len > sizeof(yld->ctl_data->data))\n\t\t\tlen = sizeof(yld->ctl_data->data);\n\n\t\t \n\t\tyld->ctl_data->cmd\t= CMD_LCD;\n\t\tyld->ctl_data->offset\t= cpu_to_be16(ix);\n\t\tyld->ctl_data->size\t= len;\n\t\tyld->ctl_data->sum\t= -CMD_LCD - ix - val - len;\n\t\tfor(i=1; i<len; i++) {\n\t\t\tix++;\n\t\t\tval = yld->master.b[ix];\n\t\t\tyld->copy.b[ix]\t\t= val;\n\t\t\tyld->ctl_data->data[i]\t= val;\n\t\t\tyld->ctl_data->sum     -= val;\n\t\t}\n\t}\n\tyld->stat_ix = ix + 1;\n\treturn 1;\n}\n\n \nstatic void urb_irq_callback(struct urb *urb)\n{\n\tstruct yealink_dev *yld = urb->context;\n\tint ret, status = urb->status;\n\n\tif (status)\n\t\tdev_err(&yld->intf->dev, \"%s - urb status %d\\n\",\n\t\t\t__func__, status);\n\n\tswitch (yld->irq_data->cmd) {\n\tcase CMD_KEYPRESS:\n\n\t\tyld->master.s.keynum = yld->irq_data->data[0];\n\t\tbreak;\n\n\tcase CMD_SCANCODE:\n\t\tdev_dbg(&yld->intf->dev, \"get scancode %x\\n\",\n\t\t\tyld->irq_data->data[0]);\n\n\t\treport_key(yld, map_p1k_to_key(yld->irq_data->data[0]));\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&yld->intf->dev, \"unexpected response %x\\n\",\n\t\t\tyld->irq_data->cmd);\n\t}\n\n\tyealink_do_idle_tasks(yld);\n\n\tif (!yld->shutdown) {\n\t\tret = usb_submit_urb(yld->urb_ctl, GFP_ATOMIC);\n\t\tif (ret && ret != -EPERM)\n\t\t\tdev_err(&yld->intf->dev,\n\t\t\t\t\"%s - usb_submit_urb failed %d\\n\",\n\t\t\t\t__func__, ret);\n\t}\n}\n\nstatic void urb_ctl_callback(struct urb *urb)\n{\n\tstruct yealink_dev *yld = urb->context;\n\tint ret = 0, status = urb->status;\n\n\tif (status)\n\t\tdev_err(&yld->intf->dev, \"%s - urb status %d\\n\",\n\t\t\t__func__, status);\n\n\tswitch (yld->ctl_data->cmd) {\n\tcase CMD_KEYPRESS:\n\tcase CMD_SCANCODE:\n\t\t \n\t\tif (!yld->shutdown)\n\t\t\tret = usb_submit_urb(yld->urb_irq, GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tyealink_do_idle_tasks(yld);\n\t\tif (!yld->shutdown)\n\t\t\tret = usb_submit_urb(yld->urb_ctl, GFP_ATOMIC);\n\t\tbreak;\n\t}\n\n\tif (ret && ret != -EPERM)\n\t\tdev_err(&yld->intf->dev, \"%s - usb_submit_urb failed %d\\n\",\n\t\t\t__func__, ret);\n}\n\n \n\n \n\nstatic int input_open(struct input_dev *dev)\n{\n\tstruct yealink_dev *yld = input_get_drvdata(dev);\n\tint i, ret;\n\n\tdev_dbg(&yld->intf->dev, \"%s\\n\", __func__);\n\n\t \n\tfor (i = 0; i<sizeof(yld->master); i++)\n\t\tyld->copy.b[i] = ~yld->master.b[i];\n\tyld->key_code = -1;\t \n\n        yealink_set_ringtone(yld, default_ringtone, sizeof(default_ringtone));\n\n\t \n\tmemset(yld->ctl_data, 0, sizeof(*(yld->ctl_data)));\n\tyld->ctl_data->cmd\t= CMD_INIT;\n\tyld->ctl_data->size\t= 10;\n\tyld->ctl_data->sum\t= 0x100-CMD_INIT-10;\n\tif ((ret = usb_submit_urb(yld->urb_ctl, GFP_KERNEL)) != 0) {\n\t\tdev_dbg(&yld->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void input_close(struct input_dev *dev)\n{\n\tstruct yealink_dev *yld = input_get_drvdata(dev);\n\n\tyld->shutdown = 1;\n\t \n\tsmp_wmb();\n\n\tusb_kill_urb(yld->urb_ctl);\n\tusb_kill_urb(yld->urb_irq);\n\n\tyld->shutdown = 0;\n\tsmp_wmb();\n}\n\n \n\nstatic DECLARE_RWSEM(sysfs_rwsema);\n\n \nstatic ssize_t show_map(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tmemcpy(buf, &map_seg7, sizeof(map_seg7));\n\treturn sizeof(map_seg7);\n}\n\nstatic ssize_t store_map(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t cnt)\n{\n\tif (cnt != sizeof(map_seg7))\n\t\treturn -EINVAL;\n\tmemcpy(&map_seg7, buf, sizeof(map_seg7));\n\treturn sizeof(map_seg7);\n}\n\n \n\n \nstatic ssize_t show_line(struct device *dev, char *buf, int a, int b)\n{\n\tstruct yealink_dev *yld;\n\tint i;\n\n\tdown_read(&sysfs_rwsema);\n\tyld = dev_get_drvdata(dev);\n\tif (yld == NULL) {\n\t\tup_read(&sysfs_rwsema);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = a; i < b; i++)\n\t\t*buf++ = lcdMap[i].type;\n\t*buf++ = '\\n';\n\tfor (i = a; i < b; i++)\n\t\t*buf++ = yld->lcdMap[i];\n\t*buf++ = '\\n';\n\t*buf = 0;\n\n\tup_read(&sysfs_rwsema);\n\treturn 3 + ((b - a) << 1);\n}\n\nstatic ssize_t show_line1(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn show_line(dev, buf, LCD_LINE1_OFFSET, LCD_LINE2_OFFSET);\n}\n\nstatic ssize_t show_line2(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn show_line(dev, buf, LCD_LINE2_OFFSET, LCD_LINE3_OFFSET);\n}\n\nstatic ssize_t show_line3(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\treturn show_line(dev, buf, LCD_LINE3_OFFSET, LCD_LINE4_OFFSET);\n}\n\n \nstatic ssize_t store_line(struct device *dev, const char *buf, size_t count,\n\t\tint el, size_t len)\n{\n\tstruct yealink_dev *yld;\n\tint i;\n\n\tdown_write(&sysfs_rwsema);\n\tyld = dev_get_drvdata(dev);\n\tif (yld == NULL) {\n\t\tup_write(&sysfs_rwsema);\n\t\treturn -ENODEV;\n\t}\n\n\tif (len > count)\n\t\tlen = count;\n\tfor (i = 0; i < len; i++)\n\t\tsetChar(yld, el++, buf[i]);\n\n\tup_write(&sysfs_rwsema);\n\treturn count;\n}\n\nstatic ssize_t store_line1(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn store_line(dev, buf, count, LCD_LINE1_OFFSET, LCD_LINE1_SIZE);\n}\n\nstatic ssize_t store_line2(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn store_line(dev, buf, count, LCD_LINE2_OFFSET, LCD_LINE2_SIZE);\n}\n\nstatic ssize_t store_line3(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn store_line(dev, buf, count, LCD_LINE3_OFFSET, LCD_LINE3_SIZE);\n}\n\n \n\n \nstatic ssize_t get_icons(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct yealink_dev *yld;\n\tint i, ret = 1;\n\n\tdown_read(&sysfs_rwsema);\n\tyld = dev_get_drvdata(dev);\n\tif (yld == NULL) {\n\t\tup_read(&sysfs_rwsema);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(lcdMap); i++) {\n\t\tif (lcdMap[i].type != '.')\n\t\t\tcontinue;\n\t\tret += sprintf(&buf[ret], \"%s %s\\n\",\n\t\t\t\tyld->lcdMap[i] == ' ' ? \"  \" : \"on\",\n\t\t\t\tlcdMap[i].u.p.name);\n\t}\n\tup_read(&sysfs_rwsema);\n\treturn ret;\n}\n\n \nstatic ssize_t set_icon(struct device *dev, const char *buf, size_t count,\n\t\t\tint chr)\n{\n\tstruct yealink_dev *yld;\n\tint i;\n\n\tdown_write(&sysfs_rwsema);\n\tyld = dev_get_drvdata(dev);\n\tif (yld == NULL) {\n\t\tup_write(&sysfs_rwsema);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(lcdMap); i++) {\n\t\tif (lcdMap[i].type != '.')\n\t\t\tcontinue;\n\t\tif (strncmp(buf, lcdMap[i].u.p.name, count) == 0) {\n\t\t\tsetChar(yld, i, chr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_write(&sysfs_rwsema);\n\treturn count;\n}\n\nstatic ssize_t show_icon(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\treturn set_icon(dev, buf, count, buf[0]);\n}\n\nstatic ssize_t hide_icon(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\treturn set_icon(dev, buf, count, ' ');\n}\n\n \n\n \nstatic ssize_t store_ringtone(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct yealink_dev *yld;\n\n\tdown_write(&sysfs_rwsema);\n\tyld = dev_get_drvdata(dev);\n\tif (yld == NULL) {\n\t\tup_write(&sysfs_rwsema);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tyealink_set_ringtone(yld, (char *)buf, count);\n\tup_write(&sysfs_rwsema);\n\treturn count;\n}\n\n#define _M444\tS_IRUGO\n#define _M664\tS_IRUGO|S_IWUSR|S_IWGRP\n#define _M220\tS_IWUSR|S_IWGRP\n\nstatic DEVICE_ATTR(map_seg7\t, _M664, show_map\t, store_map\t);\nstatic DEVICE_ATTR(line1\t, _M664, show_line1\t, store_line1\t);\nstatic DEVICE_ATTR(line2\t, _M664, show_line2\t, store_line2\t);\nstatic DEVICE_ATTR(line3\t, _M664, show_line3\t, store_line3\t);\nstatic DEVICE_ATTR(get_icons\t, _M444, get_icons\t, NULL\t\t);\nstatic DEVICE_ATTR(show_icon\t, _M220, NULL\t\t, show_icon\t);\nstatic DEVICE_ATTR(hide_icon\t, _M220, NULL\t\t, hide_icon\t);\nstatic DEVICE_ATTR(ringtone\t, _M220, NULL\t\t, store_ringtone);\n\nstatic struct attribute *yld_attributes[] = {\n\t&dev_attr_line1.attr,\n\t&dev_attr_line2.attr,\n\t&dev_attr_line3.attr,\n\t&dev_attr_get_icons.attr,\n\t&dev_attr_show_icon.attr,\n\t&dev_attr_hide_icon.attr,\n\t&dev_attr_map_seg7.attr,\n\t&dev_attr_ringtone.attr,\n\tNULL\n};\n\nstatic const struct attribute_group yld_attr_group = {\n\t.attrs = yld_attributes\n};\n\n \n\nstruct driver_info {\n\tchar *name;\n};\n\nstatic const struct driver_info info_P1K = {\n\t.name\t= \"Yealink usb-p1k\",\n};\n\nstatic const struct usb_device_id usb_table [] = {\n\t{\n\t\t.match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE |\n\t\t\t\t\t\tUSB_DEVICE_ID_MATCH_INT_INFO,\n\t\t.idVendor\t\t= 0x6993,\n\t\t.idProduct\t\t= 0xb001,\n\t\t.bInterfaceClass\t= USB_CLASS_HID,\n\t\t.bInterfaceSubClass\t= 0,\n\t\t.bInterfaceProtocol\t= 0,\n\t\t.driver_info\t\t= (kernel_ulong_t)&info_P1K\n\t},\n\t{ }\n};\n\nstatic int usb_cleanup(struct yealink_dev *yld, int err)\n{\n\tif (yld == NULL)\n\t\treturn err;\n\n        if (yld->idev) {\n\t\tif (err)\n\t\t\tinput_free_device(yld->idev);\n\t\telse\n\t\t\tinput_unregister_device(yld->idev);\n\t}\n\n\tusb_free_urb(yld->urb_irq);\n\tusb_free_urb(yld->urb_ctl);\n\n\tkfree(yld->ctl_req);\n\tusb_free_coherent(yld->udev, USB_PKT_LEN, yld->ctl_data, yld->ctl_dma);\n\tusb_free_coherent(yld->udev, USB_PKT_LEN, yld->irq_data, yld->irq_dma);\n\n\tkfree(yld);\n\treturn err;\n}\n\nstatic void usb_disconnect(struct usb_interface *intf)\n{\n\tstruct yealink_dev *yld;\n\n\tdown_write(&sysfs_rwsema);\n\tyld = usb_get_intfdata(intf);\n\tsysfs_remove_group(&intf->dev.kobj, &yld_attr_group);\n\tusb_set_intfdata(intf, NULL);\n\tup_write(&sysfs_rwsema);\n\n\tusb_cleanup(yld, 0);\n}\n\nstatic int usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev (intf);\n\tstruct driver_info *nfo = (struct driver_info *)id->driver_info;\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct yealink_dev *yld;\n\tstruct input_dev *input_dev;\n\tint ret, pipe, i;\n\n\tinterface = intf->cur_altsetting;\n\n\tif (interface->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tendpoint = &interface->endpoint[0].desc;\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -ENODEV;\n\n\tyld = kzalloc(sizeof(struct yealink_dev), GFP_KERNEL);\n\tif (!yld)\n\t\treturn -ENOMEM;\n\n\tyld->udev = udev;\n\tyld->intf = intf;\n\n\tyld->idev = input_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn usb_cleanup(yld, -ENOMEM);\n\n\t \n\tyld->irq_data = usb_alloc_coherent(udev, USB_PKT_LEN,\n\t\t\t\t\t   GFP_KERNEL, &yld->irq_dma);\n\tif (yld->irq_data == NULL)\n\t\treturn usb_cleanup(yld, -ENOMEM);\n\n\tyld->ctl_data = usb_alloc_coherent(udev, USB_PKT_LEN,\n\t\t\t\t\t   GFP_KERNEL, &yld->ctl_dma);\n\tif (!yld->ctl_data)\n\t\treturn usb_cleanup(yld, -ENOMEM);\n\n\tyld->ctl_req = kmalloc(sizeof(*(yld->ctl_req)), GFP_KERNEL);\n\tif (yld->ctl_req == NULL)\n\t\treturn usb_cleanup(yld, -ENOMEM);\n\n\t \n\tyld->urb_irq = usb_alloc_urb(0, GFP_KERNEL);\n        if (yld->urb_irq == NULL)\n\t\treturn usb_cleanup(yld, -ENOMEM);\n\n\tyld->urb_ctl = usb_alloc_urb(0, GFP_KERNEL);\n        if (yld->urb_ctl == NULL)\n\t\treturn usb_cleanup(yld, -ENOMEM);\n\n\t \n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\tret = usb_maxpacket(udev, pipe);\n\tif (ret != USB_PKT_LEN)\n\t\tdev_err(&intf->dev, \"invalid payload size %d, expected %zd\\n\",\n\t\t\tret, USB_PKT_LEN);\n\n\t \n\tusb_fill_int_urb(yld->urb_irq, udev, pipe, yld->irq_data,\n\t\t\tUSB_PKT_LEN,\n\t\t\turb_irq_callback,\n\t\t\tyld, endpoint->bInterval);\n\tyld->urb_irq->transfer_dma = yld->irq_dma;\n\tyld->urb_irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tyld->urb_irq->dev = udev;\n\n\t \n\tyld->ctl_req->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE |\n\t\t\t\t      USB_DIR_OUT;\n\tyld->ctl_req->bRequest\t= USB_REQ_SET_CONFIGURATION;\n\tyld->ctl_req->wValue\t= cpu_to_le16(0x200);\n\tyld->ctl_req->wIndex\t= cpu_to_le16(interface->desc.bInterfaceNumber);\n\tyld->ctl_req->wLength\t= cpu_to_le16(USB_PKT_LEN);\n\n\tusb_fill_control_urb(yld->urb_ctl, udev, usb_sndctrlpipe(udev, 0),\n\t\t\t(void *)yld->ctl_req, yld->ctl_data, USB_PKT_LEN,\n\t\t\turb_ctl_callback, yld);\n\tyld->urb_ctl->transfer_dma\t= yld->ctl_dma;\n\tyld->urb_ctl->transfer_flags\t|= URB_NO_TRANSFER_DMA_MAP;\n\tyld->urb_ctl->dev = udev;\n\n\t \n\tusb_make_path(udev, yld->phys, sizeof(yld->phys));\n\tstrlcat(yld->phys,  \"/input0\", sizeof(yld->phys));\n\n\t \n\tinput_dev->name = nfo->name;\n\tinput_dev->phys = yld->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, yld);\n\n\tinput_dev->open = input_open;\n\tinput_dev->close = input_close;\n\t \n\n\t \n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\tfor (i = 0; i < 256; i++) {\n\t\tint k = map_p1k_to_key(i);\n\t\tif (k >= 0) {\n\t\t\tset_bit(k & 0xff, input_dev->keybit);\n\t\t\tif (k >> 8)\n\t\t\t\tset_bit(k >> 8, input_dev->keybit);\n\t\t}\n\t}\n\n\tret = input_register_device(yld->idev);\n\tif (ret)\n\t\treturn usb_cleanup(yld, ret);\n\n\tusb_set_intfdata(intf, yld);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lcdMap); i++)\n\t\tsetChar(yld, i, ' ');\n\n\t \n\tstore_line3(&intf->dev, NULL,\n\t\t\tDRIVER_VERSION, sizeof(DRIVER_VERSION));\n\n\t \n\tret = sysfs_create_group(&intf->dev.kobj, &yld_attr_group);\n\treturn 0;\n}\n\nstatic struct usb_driver yealink_driver = {\n\t.name\t\t= \"yealink\",\n\t.probe\t\t= usb_probe,\n\t.disconnect\t= usb_disconnect,\n\t.id_table\t= usb_table,\n};\n\nmodule_usb_driver(yealink_driver);\n\nMODULE_DEVICE_TABLE (usb, usb_table);\n\nMODULE_AUTHOR(\"Henk Vergonet\");\nMODULE_DESCRIPTION(\"Yealink phone driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}