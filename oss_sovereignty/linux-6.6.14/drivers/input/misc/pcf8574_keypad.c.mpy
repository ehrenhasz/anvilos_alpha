{
  "module_name": "pcf8574_keypad.c",
  "hash_id": "e014a5a834526e57b029c6d365ffdd2e305f1c5a7ffa8ef9cf83314bdf742a1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/pcf8574_keypad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#define DRV_NAME \"pcf8574_keypad\"\n\nstatic const unsigned char pcf8574_kp_btncode[] = {\n\t[0] = KEY_RESERVED,\n\t[1] = KEY_ENTER,\n\t[2] = KEY_BACKSLASH,\n\t[3] = KEY_0,\n\t[4] = KEY_RIGHTBRACE,\n\t[5] = KEY_C,\n\t[6] = KEY_9,\n\t[7] = KEY_8,\n\t[8] = KEY_7,\n\t[9] = KEY_B,\n\t[10] = KEY_6,\n\t[11] = KEY_5,\n\t[12] = KEY_4,\n\t[13] = KEY_A,\n\t[14] = KEY_3,\n\t[15] = KEY_2,\n\t[16] = KEY_1\n};\n\nstruct kp_data {\n\tunsigned short btncode[ARRAY_SIZE(pcf8574_kp_btncode)];\n\tstruct input_dev *idev;\n\tstruct i2c_client *client;\n\tchar name[64];\n\tchar phys[32];\n\tunsigned char laststate;\n};\n\nstatic short read_state(struct kp_data *lp)\n{\n\tunsigned char x, y, a, b;\n\n\ti2c_smbus_write_byte(lp->client, 240);\n\tx = 0xF & (~(i2c_smbus_read_byte(lp->client) >> 4));\n\n\ti2c_smbus_write_byte(lp->client, 15);\n\ty = 0xF & (~i2c_smbus_read_byte(lp->client));\n\n\tfor (a = 0; x > 0; a++)\n\t\tx = x >> 1;\n\tfor (b = 0; y > 0; b++)\n\t\ty = y >> 1;\n\n\treturn ((a - 1) * 4) + b;\n}\n\nstatic irqreturn_t pcf8574_kp_irq_handler(int irq, void *dev_id)\n{\n\tstruct kp_data *lp = dev_id;\n\tunsigned char nextstate = read_state(lp);\n\n\tif (lp->laststate != nextstate) {\n\t\tint key_down = nextstate < ARRAY_SIZE(lp->btncode);\n\t\tunsigned short keycode = key_down ?\n\t\t\tlp->btncode[nextstate] : lp->btncode[lp->laststate];\n\n\t\tinput_report_key(lp->idev, keycode, key_down);\n\t\tinput_sync(lp->idev);\n\n\t\tlp->laststate = nextstate;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pcf8574_kp_probe(struct i2c_client *client)\n{\n\tint i, ret;\n\tstruct input_dev *idev;\n\tstruct kp_data *lp;\n\n\tif (i2c_smbus_write_byte(client, 240) < 0) {\n\t\tdev_err(&client->dev, \"probe: write fail\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlp = kzalloc(sizeof(*lp), GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\n\tidev = input_allocate_device();\n\tif (!idev) {\n\t\tdev_err(&client->dev, \"Can't allocate input device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_allocate;\n\t}\n\n\tlp->idev = idev;\n\tlp->client = client;\n\n\tidev->evbit[0] = BIT_MASK(EV_KEY);\n\tidev->keycode = lp->btncode;\n\tidev->keycodesize = sizeof(lp->btncode[0]);\n\tidev->keycodemax = ARRAY_SIZE(lp->btncode);\n\n\tfor (i = 0; i < ARRAY_SIZE(pcf8574_kp_btncode); i++) {\n\t\tif (lp->btncode[i] <= KEY_MAX) {\n\t\t\tlp->btncode[i] = pcf8574_kp_btncode[i];\n\t\t\t__set_bit(lp->btncode[i], idev->keybit);\n\t\t}\n\t}\n\t__clear_bit(KEY_RESERVED, idev->keybit);\n\n\tsprintf(lp->name, DRV_NAME);\n\tsprintf(lp->phys, \"kp_data/input0\");\n\n\tidev->name = lp->name;\n\tidev->phys = lp->phys;\n\tidev->id.bustype = BUS_I2C;\n\tidev->id.vendor = 0x0001;\n\tidev->id.product = 0x0001;\n\tidev->id.version = 0x0100;\n\n\tlp->laststate = read_state(lp);\n\n\tret = request_threaded_irq(client->irq, NULL, pcf8574_kp_irq_handler,\n\t\t\t\t   IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t   DRV_NAME, lp);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"IRQ %d is not free\\n\", client->irq);\n\t\tgoto fail_free_device;\n\t}\n\n\tret = input_register_device(idev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"input_register_device() failed\\n\");\n\t\tgoto fail_free_irq;\n\t}\n\n\ti2c_set_clientdata(client, lp);\n\treturn 0;\n\n fail_free_irq:\n\tfree_irq(client->irq, lp);\n fail_free_device:\n\tinput_free_device(idev);\n fail_allocate:\n\tkfree(lp);\n\n\treturn ret;\n}\n\nstatic void pcf8574_kp_remove(struct i2c_client *client)\n{\n\tstruct kp_data *lp = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, lp);\n\n\tinput_unregister_device(lp->idev);\n\tkfree(lp);\n}\n\nstatic int pcf8574_kp_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int pcf8574_kp_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pcf8574_kp_pm_ops,\n\t\t\t\tpcf8574_kp_suspend, pcf8574_kp_resume);\n\nstatic const struct i2c_device_id pcf8574_kp_id[] = {\n\t{ DRV_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf8574_kp_id);\n\nstatic struct i2c_driver pcf8574_kp_driver = {\n\t.driver = {\n\t\t.name  = DRV_NAME,\n\t\t.pm = pm_sleep_ptr(&pcf8574_kp_pm_ops),\n\t},\n\t.probe    = pcf8574_kp_probe,\n\t.remove   = pcf8574_kp_remove,\n\t.id_table = pcf8574_kp_id,\n};\n\nmodule_i2c_driver(pcf8574_kp_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich\");\nMODULE_DESCRIPTION(\"Keypad input driver for 16 keys connected to PCF8574\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}