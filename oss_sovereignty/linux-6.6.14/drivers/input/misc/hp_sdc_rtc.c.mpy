{
  "module_name": "hp_sdc_rtc.c",
  "hash_id": "b2489256fd7bc28214ea63d36a137e7c66a6b76762d2d350bb7fb2122e14489b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/hp_sdc_rtc.c",
  "human_readable_source": " \n\n#include <linux/hp_sdc.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/miscdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/rtc.h>\n#include <linux/mutex.h>\n#include <linux/semaphore.h>\n\nMODULE_AUTHOR(\"Brian S. Julin <bri@calyx.com>\");\nMODULE_DESCRIPTION(\"HP i8042 SDC + MSM-58321 RTC Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n#define RTC_VERSION \"1.10d\"\n\nstatic unsigned long epoch = 2000;\n\nstatic struct semaphore i8042tregs;\n\nstatic void hp_sdc_rtc_isr (int irq, void *dev_id, \n\t\t\t    uint8_t status, uint8_t data) \n{\n\treturn;\n}\n\nstatic int hp_sdc_rtc_do_read_bbrtc (struct rtc_time *rtctm)\n{\n\tstruct semaphore tsem;\n\thp_sdc_transaction t;\n\tuint8_t tseq[91];\n\tint i;\n\t\n\ti = 0;\n\twhile (i < 91) {\n\t\ttseq[i++] = HP_SDC_ACT_DATAREG |\n\t\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN;\n\t\ttseq[i++] = 0x01;\t\t\t \n\t  \ttseq[i]   = i / 7;\t\t\t \n\t\ti++;\n\t\ttseq[i++] = HP_SDC_CMD_DO_RTCR;\t\t \n\t\ttseq[i++] = 2;\t\t \n\t\ti++; i++;                \n\t}\n\ttseq[84] |= HP_SDC_ACT_SEMAPHORE;\n\tt.endidx =\t\t91;\n\tt.seq =\t\t\ttseq;\n\tt.act.semaphore =\t&tsem;\n\tsema_init(&tsem, 0);\n\t\n\tif (hp_sdc_enqueue_transaction(&t)) return -1;\n\t\n\t \n\tif (WARN_ON(down_interruptible(&tsem)))\n\t\treturn -1;\n\t\n\t \n\tif (!((tseq[83] | tseq[90] | tseq[69] | tseq[76] |\n\t       tseq[55] | tseq[62] | tseq[34] | tseq[41] |\n\t       tseq[20] | tseq[27] | tseq[6]  | tseq[13]) & 0x0f))\n\t\treturn -1;\n\n\tmemset(rtctm, 0, sizeof(struct rtc_time));\n\trtctm->tm_year = (tseq[83] & 0x0f) + (tseq[90] & 0x0f) * 10;\n\trtctm->tm_mon  = (tseq[69] & 0x0f) + (tseq[76] & 0x0f) * 10;\n\trtctm->tm_mday = (tseq[55] & 0x0f) + (tseq[62] & 0x0f) * 10;\n\trtctm->tm_wday = (tseq[48] & 0x0f);\n\trtctm->tm_hour = (tseq[34] & 0x0f) + (tseq[41] & 0x0f) * 10;\n\trtctm->tm_min  = (tseq[20] & 0x0f) + (tseq[27] & 0x0f) * 10;\n\trtctm->tm_sec  = (tseq[6]  & 0x0f) + (tseq[13] & 0x0f) * 10;\n\t\n\treturn 0;\n}\n\nstatic int hp_sdc_rtc_read_bbrtc (struct rtc_time *rtctm)\n{\n\tstruct rtc_time tm, tm_last;\n\tint i = 0;\n\n\t \n\n\tif (hp_sdc_rtc_do_read_bbrtc(&tm_last)) return -1;\n\tif (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;\n\n\twhile (memcmp(&tm, &tm_last, sizeof(struct rtc_time))) {\n\t\tif (i++ > 4) return -1;\n\t\tmemcpy(&tm_last, &tm, sizeof(struct rtc_time));\n\t\tif (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;\n\t}\n\n\tmemcpy(rtctm, &tm, sizeof(struct rtc_time));\n\n\treturn 0;\n}\n\n\nstatic int64_t hp_sdc_rtc_read_i8042timer (uint8_t loadcmd, int numreg)\n{\n\thp_sdc_transaction t;\n\tuint8_t tseq[26] = {\n\t\tHP_SDC_ACT_PRECMD | HP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN,\n\t\t0,\n\t\tHP_SDC_CMD_READ_T1, 2, 0, 0,\n\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN, \n\t\tHP_SDC_CMD_READ_T2, 2, 0, 0,\n\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN, \n\t\tHP_SDC_CMD_READ_T3, 2, 0, 0,\n\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN, \n\t\tHP_SDC_CMD_READ_T4, 2, 0, 0,\n\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN, \n\t\tHP_SDC_CMD_READ_T5, 2, 0, 0\n\t};\n\n\tt.endidx = numreg * 5;\n\n\ttseq[1] = loadcmd;\n\ttseq[t.endidx - 4] |= HP_SDC_ACT_SEMAPHORE;  \n\n\tt.seq =\t\t\ttseq;\n\tt.act.semaphore =\t&i8042tregs;\n\n\t \n\tif (WARN_ON(down_interruptible(&i8042tregs)))\n\t\treturn -1;\n\n\tif (hp_sdc_enqueue_transaction(&t)) {\n\t\tup(&i8042tregs);\n\t\treturn -1;\n\t}\n\t\n\t \n\tif (WARN_ON(down_interruptible(&i8042tregs)))\n\t\treturn -1;\n\n\tup(&i8042tregs);\n\n\treturn (tseq[5] | \n\t\t((uint64_t)(tseq[10]) << 8)  | ((uint64_t)(tseq[15]) << 16) |\n\t\t((uint64_t)(tseq[20]) << 24) | ((uint64_t)(tseq[25]) << 32));\n}\n\n\n \nstatic inline int hp_sdc_rtc_read_rt(struct timespec64 *res) {\n\tint64_t raw;\n\tuint32_t tenms; \n\tunsigned int days;\n\n\traw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_RT, 5);\n\tif (raw < 0) return -1;\n\n\ttenms = (uint32_t)raw & 0xffffff;\n\tdays  = (unsigned int)(raw >> 24) & 0xffff;\n\n\tres->tv_nsec = (long)(tenms % 100) * 10000 * 1000;\n\tres->tv_sec =  (tenms / 100) + (time64_t)days * 86400;\n\n\treturn 0;\n}\n\n\n \nstatic inline int hp_sdc_rtc_read_fhs(struct timespec64 *res) {\n\tint64_t raw;\n\tunsigned int tenms;\n\n\traw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_FHS, 2);\n\tif (raw < 0) return -1;\n\n\ttenms = (unsigned int)raw & 0xffff;\n\n\tres->tv_nsec = (long)(tenms % 100) * 10000 * 1000;\n\tres->tv_sec  = (time64_t)(tenms / 100);\n\n\treturn 0;\n}\n\n\n \nstatic inline int hp_sdc_rtc_read_mt(struct timespec64 *res) {\n\tint64_t raw;\t\n\tuint32_t tenms; \n\n\traw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_MT, 3);\n\tif (raw < 0) return -1;\n\n\ttenms = (uint32_t)raw & 0xffffff;\n\n\tres->tv_nsec = (long)(tenms % 100) * 10000 * 1000;\n\tres->tv_sec  = (time64_t)(tenms / 100);\n\n\treturn 0;\n}\n\n\n \nstatic inline int hp_sdc_rtc_read_dt(struct timespec64 *res) {\n\tint64_t raw;\n\tuint32_t tenms;\n\n\traw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_DT, 3);\n\tif (raw < 0) return -1;\n\n\ttenms = (uint32_t)raw & 0xffffff;\n\n\tres->tv_nsec = (long)(tenms % 100) * 10000 * 1000;\n\tres->tv_sec  = (time64_t)(tenms / 100);\n\n\treturn 0;\n}\n\n\n \nstatic inline int hp_sdc_rtc_read_ct(struct timespec64 *res) {\n\tint64_t raw;\n\tuint32_t tenms;\n\n\traw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_CT, 3);\n\tif (raw < 0) return -1;\n\n\ttenms = (uint32_t)raw & 0xffffff;\n\n\tres->tv_nsec = (long)(tenms % 100) * 10000 * 1000;\n\tres->tv_sec  = (time64_t)(tenms / 100);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hp_sdc_rtc_proc_show(struct seq_file *m, void *v)\n{\n#define YN(bit) (\"no\")\n#define NY(bit) (\"yes\")\n        struct rtc_time tm;\n\tstruct timespec64 tv;\n\n\tmemset(&tm, 0, sizeof(struct rtc_time));\n\n\tif (hp_sdc_rtc_read_bbrtc(&tm)) {\n\t\tseq_puts(m, \"BBRTC\\t\\t: READ FAILED!\\n\");\n\t} else {\n\t\tseq_printf(m,\n\t\t\t     \"rtc_time\\t: %ptRt\\n\"\n\t\t\t     \"rtc_date\\t: %ptRd\\n\"\n\t\t\t     \"rtc_epoch\\t: %04lu\\n\",\n\t\t\t     &tm, &tm, epoch);\n\t}\n\n\tif (hp_sdc_rtc_read_rt(&tv)) {\n\t\tseq_puts(m, \"i8042 rtc\\t: READ FAILED!\\n\");\n\t} else {\n\t\tseq_printf(m, \"i8042 rtc\\t: %lld.%02ld seconds\\n\",\n\t\t\t     (s64)tv.tv_sec, (long)tv.tv_nsec/1000000L);\n\t}\n\n\tif (hp_sdc_rtc_read_fhs(&tv)) {\n\t\tseq_puts(m, \"handshake\\t: READ FAILED!\\n\");\n\t} else {\n\t\tseq_printf(m, \"handshake\\t: %lld.%02ld seconds\\n\",\n\t\t\t     (s64)tv.tv_sec, (long)tv.tv_nsec/1000000L);\n\t}\n\n\tif (hp_sdc_rtc_read_mt(&tv)) {\n\t\tseq_puts(m, \"alarm\\t\\t: READ FAILED!\\n\");\n\t} else {\n\t\tseq_printf(m, \"alarm\\t\\t: %lld.%02ld seconds\\n\",\n\t\t\t     (s64)tv.tv_sec, (long)tv.tv_nsec/1000000L);\n\t}\n\n\tif (hp_sdc_rtc_read_dt(&tv)) {\n\t\tseq_puts(m, \"delay\\t\\t: READ FAILED!\\n\");\n\t} else {\n\t\tseq_printf(m, \"delay\\t\\t: %lld.%02ld seconds\\n\",\n\t\t\t     (s64)tv.tv_sec, (long)tv.tv_nsec/1000000L);\n\t}\n\n\tif (hp_sdc_rtc_read_ct(&tv)) {\n\t\tseq_puts(m, \"periodic\\t: READ FAILED!\\n\");\n\t} else {\n\t\tseq_printf(m, \"periodic\\t: %lld.%02ld seconds\\n\",\n\t\t\t     (s64)tv.tv_sec, (long)tv.tv_nsec/1000000L);\n\t}\n\n        seq_printf(m,\n                     \"DST_enable\\t: %s\\n\"\n                     \"BCD\\t\\t: %s\\n\"\n                     \"24hr\\t\\t: %s\\n\"\n                     \"square_wave\\t: %s\\n\"\n                     \"alarm_IRQ\\t: %s\\n\"\n                     \"update_IRQ\\t: %s\\n\"\n                     \"periodic_IRQ\\t: %s\\n\"\n\t\t     \"periodic_freq\\t: %ld\\n\"\n                     \"batt_status\\t: %s\\n\",\n                     YN(RTC_DST_EN),\n                     NY(RTC_DM_BINARY),\n                     YN(RTC_24H),\n                     YN(RTC_SQWE),\n                     YN(RTC_AIE),\n                     YN(RTC_UIE),\n                     YN(RTC_PIE),\n                     1UL,\n                     1 ? \"okay\" : \"dead\");\n\n        return 0;\n#undef YN\n#undef NY\n}\n\nstatic int __init hp_sdc_rtc_init(void)\n{\n\tint ret;\n\n#ifdef __mc68000__\n\tif (!MACH_IS_HP300)\n\t\treturn -ENODEV;\n#endif\n\n\tsema_init(&i8042tregs, 1);\n\n\tif ((ret = hp_sdc_request_timer_irq(&hp_sdc_rtc_isr)))\n\t\treturn ret;\n\n        proc_create_single(\"driver/rtc\", 0, NULL, hp_sdc_rtc_proc_show);\n\n\tprintk(KERN_INFO \"HP i8042 SDC + MSM-58321 RTC support loaded \"\n\t\t\t \"(RTC v \" RTC_VERSION \")\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit hp_sdc_rtc_exit(void)\n{\n\tremove_proc_entry (\"driver/rtc\", NULL);\n\thp_sdc_release_timer_irq(hp_sdc_rtc_isr);\n        printk(KERN_INFO \"HP i8042 SDC + MSM-58321 RTC support unloaded\\n\");\n}\n\nmodule_init(hp_sdc_rtc_init);\nmodule_exit(hp_sdc_rtc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}