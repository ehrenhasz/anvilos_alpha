{
  "module_name": "mc13783-pwrbutton.c",
  "hash_id": "6f67a73139a9efdfb61437e3eeeaf7eef3d3217bf279164f7efe11234a047a6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/mc13783-pwrbutton.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/mc13783.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstruct mc13783_pwrb {\n\tstruct input_dev *pwr;\n\tstruct mc13xxx *mc13783;\n#define MC13783_PWRB_B1_POL_INVERT\t(1 << 0)\n#define MC13783_PWRB_B2_POL_INVERT\t(1 << 1)\n#define MC13783_PWRB_B3_POL_INVERT\t(1 << 2)\n\tint flags;\n\tunsigned short keymap[3];\n};\n\n#define MC13783_REG_INTERRUPT_SENSE_1\t\t5\n#define MC13783_IRQSENSE1_ONOFD1S\t\t(1 << 3)\n#define MC13783_IRQSENSE1_ONOFD2S\t\t(1 << 4)\n#define MC13783_IRQSENSE1_ONOFD3S\t\t(1 << 5)\n\n#define MC13783_REG_POWER_CONTROL_2\t\t15\n#define MC13783_POWER_CONTROL_2_ON1BDBNC\t4\n#define MC13783_POWER_CONTROL_2_ON2BDBNC\t6\n#define MC13783_POWER_CONTROL_2_ON3BDBNC\t8\n#define MC13783_POWER_CONTROL_2_ON1BRSTEN\t(1 << 1)\n#define MC13783_POWER_CONTROL_2_ON2BRSTEN\t(1 << 2)\n#define MC13783_POWER_CONTROL_2_ON3BRSTEN\t(1 << 3)\n\nstatic irqreturn_t button_irq(int irq, void *_priv)\n{\n\tstruct mc13783_pwrb *priv = _priv;\n\tint val;\n\n\tmc13xxx_irq_ack(priv->mc13783, irq);\n\tmc13xxx_reg_read(priv->mc13783, MC13783_REG_INTERRUPT_SENSE_1, &val);\n\n\tswitch (irq) {\n\tcase MC13783_IRQ_ONOFD1:\n\t\tval = val & MC13783_IRQSENSE1_ONOFD1S ? 1 : 0;\n\t\tif (priv->flags & MC13783_PWRB_B1_POL_INVERT)\n\t\t\tval ^= 1;\n\t\tinput_report_key(priv->pwr, priv->keymap[0], val);\n\t\tbreak;\n\n\tcase MC13783_IRQ_ONOFD2:\n\t\tval = val & MC13783_IRQSENSE1_ONOFD2S ? 1 : 0;\n\t\tif (priv->flags & MC13783_PWRB_B2_POL_INVERT)\n\t\t\tval ^= 1;\n\t\tinput_report_key(priv->pwr, priv->keymap[1], val);\n\t\tbreak;\n\n\tcase MC13783_IRQ_ONOFD3:\n\t\tval = val & MC13783_IRQSENSE1_ONOFD3S ? 1 : 0;\n\t\tif (priv->flags & MC13783_PWRB_B3_POL_INVERT)\n\t\t\tval ^= 1;\n\t\tinput_report_key(priv->pwr, priv->keymap[2], val);\n\t\tbreak;\n\t}\n\n\tinput_sync(priv->pwr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mc13783_pwrbutton_probe(struct platform_device *pdev)\n{\n\tconst struct mc13xxx_buttons_platform_data *pdata;\n\tstruct mc13xxx *mc13783 = dev_get_drvdata(pdev->dev.parent);\n\tstruct input_dev *pwr;\n\tstruct mc13783_pwrb *priv;\n\tint err = 0;\n\tint reg = 0;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpwr = input_allocate_device();\n\tif (!pwr) {\n\t\tdev_dbg(&pdev->dev, \"Can't allocate power button\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\terr = -ENOMEM;\n\t\tdev_dbg(&pdev->dev, \"Can't allocate power button\\n\");\n\t\tgoto free_input_dev;\n\t}\n\n\treg |= (pdata->b1on_flags & 0x3) << MC13783_POWER_CONTROL_2_ON1BDBNC;\n\treg |= (pdata->b2on_flags & 0x3) << MC13783_POWER_CONTROL_2_ON2BDBNC;\n\treg |= (pdata->b3on_flags & 0x3) << MC13783_POWER_CONTROL_2_ON3BDBNC;\n\n\tpriv->pwr = pwr;\n\tpriv->mc13783 = mc13783;\n\n\tmc13xxx_lock(mc13783);\n\n\tif (pdata->b1on_flags & MC13783_BUTTON_ENABLE) {\n\t\tpriv->keymap[0] = pdata->b1on_key;\n\t\tif (pdata->b1on_key != KEY_RESERVED)\n\t\t\t__set_bit(pdata->b1on_key, pwr->keybit);\n\n\t\tif (pdata->b1on_flags & MC13783_BUTTON_POL_INVERT)\n\t\t\tpriv->flags |= MC13783_PWRB_B1_POL_INVERT;\n\n\t\tif (pdata->b1on_flags & MC13783_BUTTON_RESET_EN)\n\t\t\treg |= MC13783_POWER_CONTROL_2_ON1BRSTEN;\n\n\t\terr = mc13xxx_irq_request(mc13783, MC13783_IRQ_ONOFD1,\n\t\t\t\t\t  button_irq, \"b1on\", priv);\n\t\tif (err) {\n\t\t\tdev_dbg(&pdev->dev, \"Can't request irq\\n\");\n\t\t\tgoto free_priv;\n\t\t}\n\t}\n\n\tif (pdata->b2on_flags & MC13783_BUTTON_ENABLE) {\n\t\tpriv->keymap[1] = pdata->b2on_key;\n\t\tif (pdata->b2on_key != KEY_RESERVED)\n\t\t\t__set_bit(pdata->b2on_key, pwr->keybit);\n\n\t\tif (pdata->b2on_flags & MC13783_BUTTON_POL_INVERT)\n\t\t\tpriv->flags |= MC13783_PWRB_B2_POL_INVERT;\n\n\t\tif (pdata->b2on_flags & MC13783_BUTTON_RESET_EN)\n\t\t\treg |= MC13783_POWER_CONTROL_2_ON2BRSTEN;\n\n\t\terr = mc13xxx_irq_request(mc13783, MC13783_IRQ_ONOFD2,\n\t\t\t\t\t  button_irq, \"b2on\", priv);\n\t\tif (err) {\n\t\t\tdev_dbg(&pdev->dev, \"Can't request irq\\n\");\n\t\t\tgoto free_irq_b1;\n\t\t}\n\t}\n\n\tif (pdata->b3on_flags & MC13783_BUTTON_ENABLE) {\n\t\tpriv->keymap[2] = pdata->b3on_key;\n\t\tif (pdata->b3on_key != KEY_RESERVED)\n\t\t\t__set_bit(pdata->b3on_key, pwr->keybit);\n\n\t\tif (pdata->b3on_flags & MC13783_BUTTON_POL_INVERT)\n\t\t\tpriv->flags |= MC13783_PWRB_B3_POL_INVERT;\n\n\t\tif (pdata->b3on_flags & MC13783_BUTTON_RESET_EN)\n\t\t\treg |= MC13783_POWER_CONTROL_2_ON3BRSTEN;\n\n\t\terr = mc13xxx_irq_request(mc13783, MC13783_IRQ_ONOFD3,\n\t\t\t\t\t  button_irq, \"b3on\", priv);\n\t\tif (err) {\n\t\t\tdev_dbg(&pdev->dev, \"Can't request irq: %d\\n\", err);\n\t\t\tgoto free_irq_b2;\n\t\t}\n\t}\n\n\tmc13xxx_reg_rmw(mc13783, MC13783_REG_POWER_CONTROL_2, 0x3FE, reg);\n\n\tmc13xxx_unlock(mc13783);\n\n\tpwr->name = \"mc13783_pwrbutton\";\n\tpwr->phys = \"mc13783_pwrbutton/input0\";\n\tpwr->dev.parent = &pdev->dev;\n\n\tpwr->keycode = priv->keymap;\n\tpwr->keycodemax = ARRAY_SIZE(priv->keymap);\n\tpwr->keycodesize = sizeof(priv->keymap[0]);\n\t__set_bit(EV_KEY, pwr->evbit);\n\n\terr = input_register_device(pwr);\n\tif (err) {\n\t\tdev_dbg(&pdev->dev, \"Can't register power button: %d\\n\", err);\n\t\tgoto free_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n\nfree_irq:\n\tmc13xxx_lock(mc13783);\n\n\tif (pdata->b3on_flags & MC13783_BUTTON_ENABLE)\n\t\tmc13xxx_irq_free(mc13783, MC13783_IRQ_ONOFD3, priv);\n\nfree_irq_b2:\n\tif (pdata->b2on_flags & MC13783_BUTTON_ENABLE)\n\t\tmc13xxx_irq_free(mc13783, MC13783_IRQ_ONOFD2, priv);\n\nfree_irq_b1:\n\tif (pdata->b1on_flags & MC13783_BUTTON_ENABLE)\n\t\tmc13xxx_irq_free(mc13783, MC13783_IRQ_ONOFD1, priv);\n\nfree_priv:\n\tmc13xxx_unlock(mc13783);\n\tkfree(priv);\n\nfree_input_dev:\n\tinput_free_device(pwr);\n\n\treturn err;\n}\n\nstatic int mc13783_pwrbutton_remove(struct platform_device *pdev)\n{\n\tstruct mc13783_pwrb *priv = platform_get_drvdata(pdev);\n\tconst struct mc13xxx_buttons_platform_data *pdata;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\tmc13xxx_lock(priv->mc13783);\n\n\tif (pdata->b3on_flags & MC13783_BUTTON_ENABLE)\n\t\tmc13xxx_irq_free(priv->mc13783, MC13783_IRQ_ONOFD3, priv);\n\tif (pdata->b2on_flags & MC13783_BUTTON_ENABLE)\n\t\tmc13xxx_irq_free(priv->mc13783, MC13783_IRQ_ONOFD2, priv);\n\tif (pdata->b1on_flags & MC13783_BUTTON_ENABLE)\n\t\tmc13xxx_irq_free(priv->mc13783, MC13783_IRQ_ONOFD1, priv);\n\n\tmc13xxx_unlock(priv->mc13783);\n\n\tinput_unregister_device(priv->pwr);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mc13783_pwrbutton_driver = {\n\t.probe\t\t= mc13783_pwrbutton_probe,\n\t.remove\t\t= mc13783_pwrbutton_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mc13783-pwrbutton\",\n\t},\n};\n\nmodule_platform_driver(mc13783_pwrbutton_driver);\n\nMODULE_ALIAS(\"platform:mc13783-pwrbutton\");\nMODULE_DESCRIPTION(\"MC13783 Power Button\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Philippe Retornaz\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}