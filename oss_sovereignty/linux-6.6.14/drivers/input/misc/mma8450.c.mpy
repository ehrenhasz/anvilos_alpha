{
  "module_name": "mma8450.c",
  "hash_id": "8b401d1f5e92328d032b38a1b8ce9ca542e039b6b7aafd470b4aa10282db181e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/mma8450.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/mod_devicetable.h>\n\n#define MMA8450_DRV_NAME\t\"mma8450\"\n\n#define MODE_CHANGE_DELAY_MS\t100\n#define POLL_INTERVAL\t\t100\n#define POLL_INTERVAL_MAX\t500\n\n \n#define MMA8450_STATUS\t\t0x00\n#define MMA8450_STATUS_ZXYDR\t0x08\n\n#define MMA8450_OUT_X8\t\t0x01\n#define MMA8450_OUT_Y8\t\t0x02\n#define MMA8450_OUT_Z8\t\t0x03\n\n#define MMA8450_OUT_X_LSB\t0x05\n#define MMA8450_OUT_X_MSB\t0x06\n#define MMA8450_OUT_Y_LSB\t0x07\n#define MMA8450_OUT_Y_MSB\t0x08\n#define MMA8450_OUT_Z_LSB\t0x09\n#define MMA8450_OUT_Z_MSB\t0x0a\n\n#define MMA8450_XYZ_DATA_CFG\t0x16\n\n#define MMA8450_CTRL_REG1\t0x38\n#define MMA8450_CTRL_REG2\t0x39\n\nstatic int mma8450_read(struct i2c_client *c, unsigned int off)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(c, off);\n\tif (ret < 0)\n\t\tdev_err(&c->dev,\n\t\t\t\"failed to read register 0x%02x, error %d\\n\",\n\t\t\toff, ret);\n\n\treturn ret;\n}\n\nstatic int mma8450_write(struct i2c_client *c, unsigned int off, u8 v)\n{\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(c, off, v);\n\tif (error < 0) {\n\t\tdev_err(&c->dev,\n\t\t\t\"failed to write to register 0x%02x, error %d\\n\",\n\t\t\toff, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int mma8450_read_block(struct i2c_client *c, unsigned int off,\n\t\t\t      u8 *buf, size_t size)\n{\n\tint err;\n\n\terr = i2c_smbus_read_i2c_block_data(c, off, size, buf);\n\tif (err < 0) {\n\t\tdev_err(&c->dev,\n\t\t\t\"failed to read block data at 0x%02x, error %d\\n\",\n\t\t\tMMA8450_OUT_X_LSB, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mma8450_poll(struct input_dev *input)\n{\n\tstruct i2c_client *c = input_get_drvdata(input);\n\tint x, y, z;\n\tint ret;\n\tu8 buf[6];\n\n\tret = mma8450_read(c, MMA8450_STATUS);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (!(ret & MMA8450_STATUS_ZXYDR))\n\t\treturn;\n\n\tret = mma8450_read_block(c, MMA8450_OUT_X_LSB, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn;\n\n\tx = ((int)(s8)buf[1] << 4) | (buf[0] & 0xf);\n\ty = ((int)(s8)buf[3] << 4) | (buf[2] & 0xf);\n\tz = ((int)(s8)buf[5] << 4) | (buf[4] & 0xf);\n\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\tinput_report_abs(input, ABS_Z, z);\n\tinput_sync(input);\n}\n\n \nstatic int mma8450_open(struct input_dev *input)\n{\n\tstruct i2c_client *c = input_get_drvdata(input);\n\tint err;\n\n\t \n\terr = mma8450_write(c, MMA8450_XYZ_DATA_CFG, 0x07);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mma8450_write(c, MMA8450_CTRL_REG1, 0x01);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(MODE_CHANGE_DELAY_MS);\n\treturn 0;\n}\n\nstatic void mma8450_close(struct input_dev *input)\n{\n\tstruct i2c_client *c = input_get_drvdata(input);\n\n\tmma8450_write(c, MMA8450_CTRL_REG1, 0x00);\n\tmma8450_write(c, MMA8450_CTRL_REG2, 0x01);\n}\n\n \nstatic int mma8450_probe(struct i2c_client *c)\n{\n\tstruct input_dev *input;\n\tint err;\n\n\tinput = devm_input_allocate_device(&c->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(input, c);\n\n\tinput->name = MMA8450_DRV_NAME;\n\tinput->id.bustype = BUS_I2C;\n\n\tinput->open = mma8450_open;\n\tinput->close = mma8450_close;\n\n\tinput_set_abs_params(input, ABS_X, -2048, 2047, 32, 32);\n\tinput_set_abs_params(input, ABS_Y, -2048, 2047, 32, 32);\n\tinput_set_abs_params(input, ABS_Z, -2048, 2047, 32, 32);\n\n\terr = input_setup_polling(input, mma8450_poll);\n\tif (err) {\n\t\tdev_err(&c->dev, \"failed to set up polling\\n\");\n\t\treturn err;\n\t}\n\n\tinput_set_poll_interval(input, POLL_INTERVAL);\n\tinput_set_max_poll_interval(input, POLL_INTERVAL_MAX);\n\n\terr = input_register_device(input);\n\tif (err) {\n\t\tdev_err(&c->dev, \"failed to register input device\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id mma8450_id[] = {\n\t{ MMA8450_DRV_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, mma8450_id);\n\nstatic const struct of_device_id mma8450_dt_ids[] = {\n\t{ .compatible = \"fsl,mma8450\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mma8450_dt_ids);\n\nstatic struct i2c_driver mma8450_driver = {\n\t.driver = {\n\t\t.name\t= MMA8450_DRV_NAME,\n\t\t.of_match_table = mma8450_dt_ids,\n\t},\n\t.probe\t\t= mma8450_probe,\n\t.id_table\t= mma8450_id,\n};\n\nmodule_i2c_driver(mma8450_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"MMA8450 3-Axis Accelerometer Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}