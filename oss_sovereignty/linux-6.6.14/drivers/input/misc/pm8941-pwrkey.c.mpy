{
  "module_name": "pm8941-pwrkey.c",
  "hash_id": "e82bd28e23ddadd8af35352ba55d0c26f8a2803d64906908d0d882e832b95609",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/pm8941-pwrkey.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\n#define PON_REV2\t\t\t0x01\n\n#define PON_SUBTYPE\t\t\t0x05\n\n#define PON_SUBTYPE_PRIMARY\t\t0x01\n#define PON_SUBTYPE_SECONDARY\t\t0x02\n#define PON_SUBTYPE_1REG\t\t0x03\n#define PON_SUBTYPE_GEN2_PRIMARY\t0x04\n#define PON_SUBTYPE_GEN2_SECONDARY\t0x05\n#define PON_SUBTYPE_GEN3_PBS\t\t0x08\n#define PON_SUBTYPE_GEN3_HLOS\t\t0x09\n\n#define PON_RT_STS\t\t\t0x10\n#define  PON_KPDPWR_N_SET\t\tBIT(0)\n#define  PON_RESIN_N_SET\t\tBIT(1)\n#define  PON_GEN3_RESIN_N_SET\t\tBIT(6)\n#define  PON_GEN3_KPDPWR_N_SET\t\tBIT(7)\n\n#define PON_PS_HOLD_RST_CTL\t\t0x5a\n#define PON_PS_HOLD_RST_CTL2\t\t0x5b\n#define  PON_PS_HOLD_ENABLE\t\tBIT(7)\n#define  PON_PS_HOLD_TYPE_MASK\t\t0x0f\n#define  PON_PS_HOLD_TYPE_WARM_RESET\t1\n#define  PON_PS_HOLD_TYPE_SHUTDOWN\t4\n#define  PON_PS_HOLD_TYPE_HARD_RESET\t7\n\n#define PON_PULL_CTL\t\t\t0x70\n#define  PON_KPDPWR_PULL_UP\t\tBIT(1)\n#define  PON_RESIN_PULL_UP\t\tBIT(0)\n\n#define PON_DBC_CTL\t\t\t0x71\n#define  PON_DBC_DELAY_MASK_GEN1\t0x7\n#define  PON_DBC_DELAY_MASK_GEN2\t0xf\n#define  PON_DBC_SHIFT_GEN1\t\t6\n#define  PON_DBC_SHIFT_GEN2\t\t14\n\nstruct pm8941_data {\n\tunsigned int\tpull_up_bit;\n\tunsigned int\tstatus_bit;\n\tbool\t\tsupports_ps_hold_poff_config;\n\tbool\t\tsupports_debounce_config;\n\tbool\t\thas_pon_pbs;\n\tconst char\t*name;\n\tconst char\t*phys;\n};\n\nstruct pm8941_pwrkey {\n\tstruct device *dev;\n\tint irq;\n\tu32 baseaddr;\n\tu32 pon_pbs_baseaddr;\n\tstruct regmap *regmap;\n\tstruct input_dev *input;\n\n\tunsigned int revision;\n\tunsigned int subtype;\n\tstruct notifier_block reboot_notifier;\n\n\tu32 code;\n\tu32 sw_debounce_time_us;\n\tktime_t sw_debounce_end_time;\n\tbool last_status;\n\tconst struct pm8941_data *data;\n};\n\nstatic int pm8941_reboot_notify(struct notifier_block *nb,\n\t\t\t\tunsigned long code, void *unused)\n{\n\tstruct pm8941_pwrkey *pwrkey = container_of(nb, struct pm8941_pwrkey,\n\t\t\t\t\t\t    reboot_notifier);\n\tunsigned int enable_reg;\n\tunsigned int reset_type;\n\tint error;\n\n\t \n\tif (pwrkey->revision == 0)\n\t\tenable_reg = PON_PS_HOLD_RST_CTL;\n\telse\n\t\tenable_reg = PON_PS_HOLD_RST_CTL2;\n\n\terror = regmap_update_bits(pwrkey->regmap,\n\t\t\t\t   pwrkey->baseaddr + enable_reg,\n\t\t\t\t   PON_PS_HOLD_ENABLE,\n\t\t\t\t   0);\n\tif (error)\n\t\tdev_err(pwrkey->dev,\n\t\t\t\"unable to clear ps hold reset enable: %d\\n\",\n\t\t\terror);\n\n\t \n\tusleep_range(100, 1000);\n\n\tswitch (code) {\n\tcase SYS_HALT:\n\tcase SYS_POWER_OFF:\n\t\treset_type = PON_PS_HOLD_TYPE_SHUTDOWN;\n\t\tbreak;\n\tcase SYS_RESTART:\n\tdefault:\n\t\tif (reboot_mode == REBOOT_WARM)\n\t\t\treset_type = PON_PS_HOLD_TYPE_WARM_RESET;\n\t\telse\n\t\t\treset_type = PON_PS_HOLD_TYPE_HARD_RESET;\n\t\tbreak;\n\t}\n\n\terror = regmap_update_bits(pwrkey->regmap,\n\t\t\t\t   pwrkey->baseaddr + PON_PS_HOLD_RST_CTL,\n\t\t\t\t   PON_PS_HOLD_TYPE_MASK,\n\t\t\t\t   reset_type);\n\tif (error)\n\t\tdev_err(pwrkey->dev, \"unable to set ps hold reset type: %d\\n\",\n\t\t\terror);\n\n\terror = regmap_update_bits(pwrkey->regmap,\n\t\t\t\t   pwrkey->baseaddr + enable_reg,\n\t\t\t\t   PON_PS_HOLD_ENABLE,\n\t\t\t\t   PON_PS_HOLD_ENABLE);\n\tif (error)\n\t\tdev_err(pwrkey->dev, \"unable to re-set enable: %d\\n\", error);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic irqreturn_t pm8941_pwrkey_irq(int irq, void *_data)\n{\n\tstruct pm8941_pwrkey *pwrkey = _data;\n\tunsigned int sts;\n\tint err;\n\n\tif (pwrkey->sw_debounce_time_us) {\n\t\tif (ktime_before(ktime_get(), pwrkey->sw_debounce_end_time)) {\n\t\t\tdev_dbg(pwrkey->dev,\n\t\t\t\t\"ignoring key event received before debounce end %llu us\\n\",\n\t\t\t\tpwrkey->sw_debounce_end_time);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\terr = regmap_read(pwrkey->regmap, pwrkey->baseaddr + PON_RT_STS, &sts);\n\tif (err)\n\t\treturn IRQ_HANDLED;\n\n\tsts &= pwrkey->data->status_bit;\n\n\tif (pwrkey->sw_debounce_time_us && !sts)\n\t\tpwrkey->sw_debounce_end_time = ktime_add_us(ktime_get(),\n\t\t\t\t\t\tpwrkey->sw_debounce_time_us);\n\n\t \n\tif (!pwrkey->last_status && !sts) {\n\t\tinput_report_key(pwrkey->input, pwrkey->code, 1);\n\t\tinput_sync(pwrkey->input);\n\t}\n\tpwrkey->last_status = sts;\n\n\tinput_report_key(pwrkey->input, pwrkey->code, sts);\n\tinput_sync(pwrkey->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pm8941_pwrkey_sw_debounce_init(struct pm8941_pwrkey *pwrkey)\n{\n\tunsigned int val, addr, mask;\n\tint error;\n\n\tif (pwrkey->data->has_pon_pbs && !pwrkey->pon_pbs_baseaddr) {\n\t\tdev_err(pwrkey->dev,\n\t\t\t\"PON_PBS address missing, can't read HW debounce time\\n\");\n\t\treturn 0;\n\t}\n\n\tif (pwrkey->pon_pbs_baseaddr)\n\t\taddr = pwrkey->pon_pbs_baseaddr + PON_DBC_CTL;\n\telse\n\t\taddr = pwrkey->baseaddr + PON_DBC_CTL;\n\terror = regmap_read(pwrkey->regmap, addr, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (pwrkey->subtype >= PON_SUBTYPE_GEN2_PRIMARY)\n\t\tmask = 0xf;\n\telse\n\t\tmask = 0x7;\n\n\tpwrkey->sw_debounce_time_us =\n\t\t2 * USEC_PER_SEC / (1 << (mask - (val & mask)));\n\n\tdev_dbg(pwrkey->dev, \"SW debounce time = %u us\\n\",\n\t\tpwrkey->sw_debounce_time_us);\n\n\treturn 0;\n}\n\nstatic int pm8941_pwrkey_suspend(struct device *dev)\n{\n\tstruct pm8941_pwrkey *pwrkey = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(pwrkey->irq);\n\n\treturn 0;\n}\n\nstatic int pm8941_pwrkey_resume(struct device *dev)\n{\n\tstruct pm8941_pwrkey *pwrkey = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(pwrkey->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pm8941_pwr_key_pm_ops,\n\t\t\t\tpm8941_pwrkey_suspend, pm8941_pwrkey_resume);\n\nstatic int pm8941_pwrkey_probe(struct platform_device *pdev)\n{\n\tstruct pm8941_pwrkey *pwrkey;\n\tbool pull_up;\n\tstruct device *parent;\n\tstruct device_node *regmap_node;\n\tconst __be32 *addr;\n\tu32 req_delay, mask, delay_shift;\n\tint error;\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"debounce\", &req_delay))\n\t\treq_delay = 15625;\n\n\tif (req_delay > 2000000 || req_delay == 0) {\n\t\tdev_err(&pdev->dev, \"invalid debounce time: %u\\n\", req_delay);\n\t\treturn -EINVAL;\n\t}\n\n\tpull_up = of_property_read_bool(pdev->dev.of_node, \"bias-pull-up\");\n\n\tpwrkey = devm_kzalloc(&pdev->dev, sizeof(*pwrkey), GFP_KERNEL);\n\tif (!pwrkey)\n\t\treturn -ENOMEM;\n\n\tpwrkey->dev = &pdev->dev;\n\tpwrkey->data = of_device_get_match_data(&pdev->dev);\n\n\tparent = pdev->dev.parent;\n\tregmap_node = pdev->dev.of_node;\n\tpwrkey->regmap = dev_get_regmap(parent, NULL);\n\tif (!pwrkey->regmap) {\n\t\tregmap_node = parent->of_node;\n\t\t \n\t\tpwrkey->regmap = dev_get_regmap(parent->parent, NULL);\n\t\tif (!pwrkey->regmap) {\n\t\t\tdev_err(&pdev->dev, \"failed to locate regmap\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\taddr = of_get_address(regmap_node, 0, NULL, NULL);\n\tif (!addr) {\n\t\tdev_err(&pdev->dev, \"reg property missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpwrkey->baseaddr = be32_to_cpup(addr);\n\n\tif (pwrkey->data->has_pon_pbs) {\n\t\t \n\t\taddr = of_get_address(regmap_node, 1, NULL, NULL);\n\t\tif (addr)\n\t\t\tpwrkey->pon_pbs_baseaddr = be32_to_cpup(addr);\n\t}\n\n\tpwrkey->irq = platform_get_irq(pdev, 0);\n\tif (pwrkey->irq < 0)\n\t\treturn pwrkey->irq;\n\n\terror = regmap_read(pwrkey->regmap, pwrkey->baseaddr + PON_REV2,\n\t\t\t    &pwrkey->revision);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to read revision: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regmap_read(pwrkey->regmap, pwrkey->baseaddr + PON_SUBTYPE,\n\t\t\t    &pwrkey->subtype);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to read subtype: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(pdev->dev.of_node, \"linux,code\",\n\t\t\t\t     &pwrkey->code);\n\tif (error) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"no linux,code assuming power (%d)\\n\", error);\n\t\tpwrkey->code = KEY_POWER;\n\t}\n\n\tpwrkey->input = devm_input_allocate_device(&pdev->dev);\n\tif (!pwrkey->input) {\n\t\tdev_dbg(&pdev->dev, \"unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_capability(pwrkey->input, EV_KEY, pwrkey->code);\n\n\tpwrkey->input->name = pwrkey->data->name;\n\tpwrkey->input->phys = pwrkey->data->phys;\n\n\tif (pwrkey->data->supports_debounce_config) {\n\t\tif (pwrkey->subtype >= PON_SUBTYPE_GEN2_PRIMARY) {\n\t\t\tmask = PON_DBC_DELAY_MASK_GEN2;\n\t\t\tdelay_shift = PON_DBC_SHIFT_GEN2;\n\t\t} else {\n\t\t\tmask = PON_DBC_DELAY_MASK_GEN1;\n\t\t\tdelay_shift = PON_DBC_SHIFT_GEN1;\n\t\t}\n\n\t\treq_delay = (req_delay << delay_shift) / USEC_PER_SEC;\n\t\treq_delay = ilog2(req_delay);\n\n\t\terror = regmap_update_bits(pwrkey->regmap,\n\t\t\t\t\t   pwrkey->baseaddr + PON_DBC_CTL,\n\t\t\t\t\t   mask,\n\t\t\t\t\t   req_delay);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"failed to set debounce: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = pm8941_pwrkey_sw_debounce_init(pwrkey);\n\tif (error)\n\t\treturn error;\n\n\tif (pwrkey->data->pull_up_bit) {\n\t\terror = regmap_update_bits(pwrkey->regmap,\n\t\t\t\t\t   pwrkey->baseaddr + PON_PULL_CTL,\n\t\t\t\t\t   pwrkey->data->pull_up_bit,\n\t\t\t\t\t   pull_up ? pwrkey->data->pull_up_bit :\n\t\t\t\t\t\t     0);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"failed to set pull: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = devm_request_threaded_irq(&pdev->dev, pwrkey->irq,\n\t\t\t\t\t  NULL, pm8941_pwrkey_irq,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  pwrkey->data->name, pwrkey);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed requesting IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(pwrkey->input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (pwrkey->data->supports_ps_hold_poff_config) {\n\t\tpwrkey->reboot_notifier.notifier_call = pm8941_reboot_notify;\n\t\terror = register_reboot_notifier(&pwrkey->reboot_notifier);\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"failed to register reboot notifier: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, pwrkey);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n}\n\nstatic int pm8941_pwrkey_remove(struct platform_device *pdev)\n{\n\tstruct pm8941_pwrkey *pwrkey = platform_get_drvdata(pdev);\n\n\tif (pwrkey->data->supports_ps_hold_poff_config)\n\t\tunregister_reboot_notifier(&pwrkey->reboot_notifier);\n\n\treturn 0;\n}\n\nstatic const struct pm8941_data pwrkey_data = {\n\t.pull_up_bit = PON_KPDPWR_PULL_UP,\n\t.status_bit = PON_KPDPWR_N_SET,\n\t.name = \"pm8941_pwrkey\",\n\t.phys = \"pm8941_pwrkey/input0\",\n\t.supports_ps_hold_poff_config = true,\n\t.supports_debounce_config = true,\n\t.has_pon_pbs = false,\n};\n\nstatic const struct pm8941_data resin_data = {\n\t.pull_up_bit = PON_RESIN_PULL_UP,\n\t.status_bit = PON_RESIN_N_SET,\n\t.name = \"pm8941_resin\",\n\t.phys = \"pm8941_resin/input0\",\n\t.supports_ps_hold_poff_config = true,\n\t.supports_debounce_config = true,\n\t.has_pon_pbs = false,\n};\n\nstatic const struct pm8941_data pon_gen3_pwrkey_data = {\n\t.status_bit = PON_GEN3_KPDPWR_N_SET,\n\t.name = \"pmic_pwrkey\",\n\t.phys = \"pmic_pwrkey/input0\",\n\t.supports_ps_hold_poff_config = false,\n\t.supports_debounce_config = false,\n\t.has_pon_pbs = true,\n};\n\nstatic const struct pm8941_data pon_gen3_resin_data = {\n\t.status_bit = PON_GEN3_RESIN_N_SET,\n\t.name = \"pmic_resin\",\n\t.phys = \"pmic_resin/input0\",\n\t.supports_ps_hold_poff_config = false,\n\t.supports_debounce_config = false,\n\t.has_pon_pbs = true,\n};\n\nstatic const struct of_device_id pm8941_pwr_key_id_table[] = {\n\t{ .compatible = \"qcom,pm8941-pwrkey\", .data = &pwrkey_data },\n\t{ .compatible = \"qcom,pm8941-resin\", .data = &resin_data },\n\t{ .compatible = \"qcom,pmk8350-pwrkey\", .data = &pon_gen3_pwrkey_data },\n\t{ .compatible = \"qcom,pmk8350-resin\", .data = &pon_gen3_resin_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pm8941_pwr_key_id_table);\n\nstatic struct platform_driver pm8941_pwrkey_driver = {\n\t.probe = pm8941_pwrkey_probe,\n\t.remove = pm8941_pwrkey_remove,\n\t.driver = {\n\t\t.name = \"pm8941-pwrkey\",\n\t\t.pm = pm_sleep_ptr(&pm8941_pwr_key_pm_ops),\n\t\t.of_match_table = of_match_ptr(pm8941_pwr_key_id_table),\n\t},\n};\nmodule_platform_driver(pm8941_pwrkey_driver);\n\nMODULE_DESCRIPTION(\"PM8941 Power Key driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}