{
  "module_name": "ad714x.c",
  "hash_id": "28b55de9172cc1517a990a7f73460270b587cdbc6d92d30fe782f569ac3141a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/ad714x.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/input/ad714x.h>\n#include <linux/module.h>\n#include \"ad714x.h\"\n\n#define AD714X_PWR_CTRL           0x0\n#define AD714X_STG_CAL_EN_REG     0x1\n#define AD714X_AMB_COMP_CTRL0_REG 0x2\n#define AD714X_PARTID_REG         0x17\n#define AD7142_PARTID             0xE620\n#define AD7143_PARTID             0xE630\n#define AD7147_PARTID             0x1470\n#define AD7148_PARTID             0x1480\n#define AD714X_STAGECFG_REG       0x80\n#define AD714X_SYSCFG_REG         0x0\n\n#define STG_LOW_INT_EN_REG     0x5\n#define STG_HIGH_INT_EN_REG    0x6\n#define STG_COM_INT_EN_REG     0x7\n#define STG_LOW_INT_STA_REG    0x8\n#define STG_HIGH_INT_STA_REG   0x9\n#define STG_COM_INT_STA_REG    0xA\n\n#define CDC_RESULT_S0          0xB\n#define CDC_RESULT_S1          0xC\n#define CDC_RESULT_S2          0xD\n#define CDC_RESULT_S3          0xE\n#define CDC_RESULT_S4          0xF\n#define CDC_RESULT_S5          0x10\n#define CDC_RESULT_S6          0x11\n#define CDC_RESULT_S7          0x12\n#define CDC_RESULT_S8          0x13\n#define CDC_RESULT_S9          0x14\n#define CDC_RESULT_S10         0x15\n#define CDC_RESULT_S11         0x16\n\n#define STAGE0_AMBIENT\t\t0xF1\n#define STAGE1_AMBIENT\t\t0x115\n#define STAGE2_AMBIENT\t\t0x139\n#define STAGE3_AMBIENT\t\t0x15D\n#define STAGE4_AMBIENT\t\t0x181\n#define STAGE5_AMBIENT\t\t0x1A5\n#define STAGE6_AMBIENT\t\t0x1C9\n#define STAGE7_AMBIENT\t\t0x1ED\n#define STAGE8_AMBIENT\t\t0x211\n#define STAGE9_AMBIENT\t\t0x234\n#define STAGE10_AMBIENT\t\t0x259\n#define STAGE11_AMBIENT\t\t0x27D\n\n#define PER_STAGE_REG_NUM      36\n#define STAGE_CFGREG_NUM       8\n#define SYS_CFGREG_NUM         8\n\n \nenum ad714x_device_state { IDLE, JITTER, ACTIVE, SPACE };\n\nstruct ad714x_slider_drv {\n\tint highest_stage;\n\tint abs_pos;\n\tint flt_pos;\n\tenum ad714x_device_state state;\n\tstruct input_dev *input;\n};\n\nstruct ad714x_wheel_drv {\n\tint abs_pos;\n\tint flt_pos;\n\tint pre_highest_stage;\n\tint highest_stage;\n\tenum ad714x_device_state state;\n\tstruct input_dev *input;\n};\n\nstruct ad714x_touchpad_drv {\n\tint x_highest_stage;\n\tint x_flt_pos;\n\tint x_abs_pos;\n\tint y_highest_stage;\n\tint y_flt_pos;\n\tint y_abs_pos;\n\tint left_ep;\n\tint left_ep_val;\n\tint right_ep;\n\tint right_ep_val;\n\tint top_ep;\n\tint top_ep_val;\n\tint bottom_ep;\n\tint bottom_ep_val;\n\tenum ad714x_device_state state;\n\tstruct input_dev *input;\n};\n\nstruct ad714x_button_drv {\n\tenum ad714x_device_state state;\n\t \n\tstruct input_dev *input;\n};\n\nstruct ad714x_driver_data {\n\tstruct ad714x_slider_drv *slider;\n\tstruct ad714x_wheel_drv *wheel;\n\tstruct ad714x_touchpad_drv *touchpad;\n\tstruct ad714x_button_drv *button;\n};\n\n \n\nstatic void ad714x_use_com_int(struct ad714x_chip *ad714x,\n\t\t\t\tint start_stage, int end_stage)\n{\n\tunsigned short data;\n\tunsigned short mask;\n\n\tmask = ((1 << (end_stage + 1)) - 1) - ((1 << start_stage) - 1);\n\n\tad714x->read(ad714x, STG_COM_INT_EN_REG, &data, 1);\n\tdata |= 1 << end_stage;\n\tad714x->write(ad714x, STG_COM_INT_EN_REG, data);\n\n\tad714x->read(ad714x, STG_HIGH_INT_EN_REG, &data, 1);\n\tdata &= ~mask;\n\tad714x->write(ad714x, STG_HIGH_INT_EN_REG, data);\n}\n\nstatic void ad714x_use_thr_int(struct ad714x_chip *ad714x,\n\t\t\t\tint start_stage, int end_stage)\n{\n\tunsigned short data;\n\tunsigned short mask;\n\n\tmask = ((1 << (end_stage + 1)) - 1) - ((1 << start_stage) - 1);\n\n\tad714x->read(ad714x, STG_COM_INT_EN_REG, &data, 1);\n\tdata &= ~(1 << end_stage);\n\tad714x->write(ad714x, STG_COM_INT_EN_REG, data);\n\n\tad714x->read(ad714x, STG_HIGH_INT_EN_REG, &data, 1);\n\tdata |= mask;\n\tad714x->write(ad714x, STG_HIGH_INT_EN_REG, data);\n}\n\nstatic int ad714x_cal_highest_stage(struct ad714x_chip *ad714x,\n\t\t\t\t\tint start_stage, int end_stage)\n{\n\tint max_res = 0;\n\tint max_idx = 0;\n\tint i;\n\n\tfor (i = start_stage; i <= end_stage; i++) {\n\t\tif (ad714x->sensor_val[i] > max_res) {\n\t\t\tmax_res = ad714x->sensor_val[i];\n\t\t\tmax_idx = i;\n\t\t}\n\t}\n\n\treturn max_idx;\n}\n\nstatic int ad714x_cal_abs_pos(struct ad714x_chip *ad714x,\n\t\t\t\tint start_stage, int end_stage,\n\t\t\t\tint highest_stage, int max_coord)\n{\n\tint a_param, b_param;\n\n\tif (highest_stage == start_stage) {\n\t\ta_param = ad714x->sensor_val[start_stage + 1];\n\t\tb_param = ad714x->sensor_val[start_stage] +\n\t\t\tad714x->sensor_val[start_stage + 1];\n\t} else if (highest_stage == end_stage) {\n\t\ta_param = ad714x->sensor_val[end_stage] *\n\t\t\t(end_stage - start_stage) +\n\t\t\tad714x->sensor_val[end_stage - 1] *\n\t\t\t(end_stage - start_stage - 1);\n\t\tb_param = ad714x->sensor_val[end_stage] +\n\t\t\tad714x->sensor_val[end_stage - 1];\n\t} else {\n\t\ta_param = ad714x->sensor_val[highest_stage] *\n\t\t\t(highest_stage - start_stage) +\n\t\t\tad714x->sensor_val[highest_stage - 1] *\n\t\t\t(highest_stage - start_stage - 1) +\n\t\t\tad714x->sensor_val[highest_stage + 1] *\n\t\t\t(highest_stage - start_stage + 1);\n\t\tb_param = ad714x->sensor_val[highest_stage] +\n\t\t\tad714x->sensor_val[highest_stage - 1] +\n\t\t\tad714x->sensor_val[highest_stage + 1];\n\t}\n\n\treturn (max_coord / (end_stage - start_stage)) * a_param / b_param;\n}\n\n \nstatic void ad714x_button_state_machine(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_button_plat *hw = &ad714x->hw->button[idx];\n\tstruct ad714x_button_drv *sw = &ad714x->sw->button[idx];\n\n\tswitch (sw->state) {\n\tcase IDLE:\n\t\tif (((ad714x->h_state & hw->h_mask) == hw->h_mask) &&\n\t\t    ((ad714x->l_state & hw->l_mask) == hw->l_mask)) {\n\t\t\tdev_dbg(ad714x->dev, \"button %d touched\\n\", idx);\n\t\t\tinput_report_key(sw->input, hw->keycode, 1);\n\t\t\tinput_sync(sw->input);\n\t\t\tsw->state = ACTIVE;\n\t\t}\n\t\tbreak;\n\n\tcase ACTIVE:\n\t\tif (((ad714x->h_state & hw->h_mask) != hw->h_mask) ||\n\t\t    ((ad714x->l_state & hw->l_mask) != hw->l_mask)) {\n\t\t\tdev_dbg(ad714x->dev, \"button %d released\\n\", idx);\n\t\t\tinput_report_key(sw->input, hw->keycode, 0);\n\t\t\tinput_sync(sw->input);\n\t\t\tsw->state = IDLE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void ad714x_slider_cal_sensor_val(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\n\tint i;\n\n\tad714x->read(ad714x, CDC_RESULT_S0 + hw->start_stage,\n\t\t\t&ad714x->adc_reg[hw->start_stage],\n\t\t\thw->end_stage - hw->start_stage + 1);\n\n\tfor (i = hw->start_stage; i <= hw->end_stage; i++) {\n\t\tad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,\n\t\t\t\t&ad714x->amb_reg[i], 1);\n\n\t\tad714x->sensor_val[i] =\n\t\t\tabs(ad714x->adc_reg[i] - ad714x->amb_reg[i]);\n\t}\n}\n\nstatic void ad714x_slider_cal_highest_stage(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\n\tstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\n\n\tsw->highest_stage = ad714x_cal_highest_stage(ad714x, hw->start_stage,\n\t\t\thw->end_stage);\n\n\tdev_dbg(ad714x->dev, \"slider %d highest_stage:%d\\n\", idx,\n\t\tsw->highest_stage);\n}\n\n \nstatic void ad714x_slider_cal_abs_pos(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\n\tstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\n\n\tsw->abs_pos = ad714x_cal_abs_pos(ad714x, hw->start_stage, hw->end_stage,\n\t\tsw->highest_stage, hw->max_coord);\n\n\tdev_dbg(ad714x->dev, \"slider %d absolute position:%d\\n\", idx,\n\t\tsw->abs_pos);\n}\n\n \nstatic void ad714x_slider_cal_flt_pos(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\n\n\tsw->flt_pos = (sw->flt_pos * (10 - 4) +\n\t\t\tsw->abs_pos * 4)/10;\n\n\tdev_dbg(ad714x->dev, \"slider %d filter position:%d\\n\", idx,\n\t\tsw->flt_pos);\n}\n\nstatic void ad714x_slider_use_com_int(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\n\n\tad714x_use_com_int(ad714x, hw->start_stage, hw->end_stage);\n}\n\nstatic void ad714x_slider_use_thr_int(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\n\n\tad714x_use_thr_int(ad714x, hw->start_stage, hw->end_stage);\n}\n\nstatic void ad714x_slider_state_machine(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\n\tstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\n\tunsigned short h_state, c_state;\n\tunsigned short mask;\n\n\tmask = ((1 << (hw->end_stage + 1)) - 1) - ((1 << hw->start_stage) - 1);\n\n\th_state = ad714x->h_state & mask;\n\tc_state = ad714x->c_state & mask;\n\n\tswitch (sw->state) {\n\tcase IDLE:\n\t\tif (h_state) {\n\t\t\tsw->state = JITTER;\n\t\t\t \n\t\t\tad714x_slider_use_com_int(ad714x, idx);\n\t\t\tdev_dbg(ad714x->dev, \"slider %d touched\\n\", idx);\n\t\t}\n\t\tbreak;\n\n\tcase JITTER:\n\t\tif (c_state == mask) {\n\t\t\tad714x_slider_cal_sensor_val(ad714x, idx);\n\t\t\tad714x_slider_cal_highest_stage(ad714x, idx);\n\t\t\tad714x_slider_cal_abs_pos(ad714x, idx);\n\t\t\tsw->flt_pos = sw->abs_pos;\n\t\t\tsw->state = ACTIVE;\n\t\t}\n\t\tbreak;\n\n\tcase ACTIVE:\n\t\tif (c_state == mask) {\n\t\t\tif (h_state) {\n\t\t\t\tad714x_slider_cal_sensor_val(ad714x, idx);\n\t\t\t\tad714x_slider_cal_highest_stage(ad714x, idx);\n\t\t\t\tad714x_slider_cal_abs_pos(ad714x, idx);\n\t\t\t\tad714x_slider_cal_flt_pos(ad714x, idx);\n\t\t\t\tinput_report_abs(sw->input, ABS_X, sw->flt_pos);\n\t\t\t\tinput_report_key(sw->input, BTN_TOUCH, 1);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tad714x_slider_use_thr_int(ad714x, idx);\n\t\t\t\tsw->state = IDLE;\n\t\t\t\tinput_report_key(sw->input, BTN_TOUCH, 0);\n\t\t\t\tdev_dbg(ad714x->dev, \"slider %d released\\n\",\n\t\t\t\t\tidx);\n\t\t\t}\n\t\t\tinput_sync(sw->input);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void ad714x_wheel_cal_highest_stage(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\tstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\n\n\tsw->pre_highest_stage = sw->highest_stage;\n\tsw->highest_stage = ad714x_cal_highest_stage(ad714x, hw->start_stage,\n\t\t\thw->end_stage);\n\n\tdev_dbg(ad714x->dev, \"wheel %d highest_stage:%d\\n\", idx,\n\t\tsw->highest_stage);\n}\n\nstatic void ad714x_wheel_cal_sensor_val(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\tint i;\n\n\tad714x->read(ad714x, CDC_RESULT_S0 + hw->start_stage,\n\t\t\t&ad714x->adc_reg[hw->start_stage],\n\t\t\thw->end_stage - hw->start_stage + 1);\n\n\tfor (i = hw->start_stage; i <= hw->end_stage; i++) {\n\t\tad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,\n\t\t\t\t&ad714x->amb_reg[i], 1);\n\t\tif (ad714x->adc_reg[i] > ad714x->amb_reg[i])\n\t\t\tad714x->sensor_val[i] =\n\t\t\t\tad714x->adc_reg[i] - ad714x->amb_reg[i];\n\t\telse\n\t\t\tad714x->sensor_val[i] = 0;\n\t}\n}\n\n \n\nstatic void ad714x_wheel_cal_abs_pos(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\tstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\n\tint stage_num = hw->end_stage - hw->start_stage + 1;\n\tint first_before, highest, first_after;\n\tint a_param, b_param;\n\n\tfirst_before = (sw->highest_stage + stage_num - 1) % stage_num;\n\thighest = sw->highest_stage;\n\tfirst_after = (sw->highest_stage + stage_num + 1) % stage_num;\n\n\ta_param = ad714x->sensor_val[highest] *\n\t\t(highest - hw->start_stage) +\n\t\tad714x->sensor_val[first_before] *\n\t\t(highest - hw->start_stage - 1) +\n\t\tad714x->sensor_val[first_after] *\n\t\t(highest - hw->start_stage + 1);\n\tb_param = ad714x->sensor_val[highest] +\n\t\tad714x->sensor_val[first_before] +\n\t\tad714x->sensor_val[first_after];\n\n\tsw->abs_pos = ((hw->max_coord / (hw->end_stage - hw->start_stage)) *\n\t\t\ta_param) / b_param;\n\n\tif (sw->abs_pos > hw->max_coord)\n\t\tsw->abs_pos = hw->max_coord;\n\telse if (sw->abs_pos < 0)\n\t\tsw->abs_pos = 0;\n}\n\nstatic void ad714x_wheel_cal_flt_pos(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\tstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\n\tif (((sw->pre_highest_stage == hw->end_stage) &&\n\t\t\t(sw->highest_stage == hw->start_stage)) ||\n\t    ((sw->pre_highest_stage == hw->start_stage) &&\n\t\t\t(sw->highest_stage == hw->end_stage)))\n\t\tsw->flt_pos = sw->abs_pos;\n\telse\n\t\tsw->flt_pos = ((sw->flt_pos * 30) + (sw->abs_pos * 71)) / 100;\n\n\tif (sw->flt_pos > hw->max_coord)\n\t\tsw->flt_pos = hw->max_coord;\n}\n\nstatic void ad714x_wheel_use_com_int(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\n\tad714x_use_com_int(ad714x, hw->start_stage, hw->end_stage);\n}\n\nstatic void ad714x_wheel_use_thr_int(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\n\tad714x_use_thr_int(ad714x, hw->start_stage, hw->end_stage);\n}\n\nstatic void ad714x_wheel_state_machine(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\n\tstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\n\tunsigned short h_state, c_state;\n\tunsigned short mask;\n\n\tmask = ((1 << (hw->end_stage + 1)) - 1) - ((1 << hw->start_stage) - 1);\n\n\th_state = ad714x->h_state & mask;\n\tc_state = ad714x->c_state & mask;\n\n\tswitch (sw->state) {\n\tcase IDLE:\n\t\tif (h_state) {\n\t\t\tsw->state = JITTER;\n\t\t\t \n\t\t\tad714x_wheel_use_com_int(ad714x, idx);\n\t\t\tdev_dbg(ad714x->dev, \"wheel %d touched\\n\", idx);\n\t\t}\n\t\tbreak;\n\n\tcase JITTER:\n\t\tif (c_state == mask)\t{\n\t\t\tad714x_wheel_cal_sensor_val(ad714x, idx);\n\t\t\tad714x_wheel_cal_highest_stage(ad714x, idx);\n\t\t\tad714x_wheel_cal_abs_pos(ad714x, idx);\n\t\t\tsw->flt_pos = sw->abs_pos;\n\t\t\tsw->state = ACTIVE;\n\t\t}\n\t\tbreak;\n\n\tcase ACTIVE:\n\t\tif (c_state == mask) {\n\t\t\tif (h_state) {\n\t\t\t\tad714x_wheel_cal_sensor_val(ad714x, idx);\n\t\t\t\tad714x_wheel_cal_highest_stage(ad714x, idx);\n\t\t\t\tad714x_wheel_cal_abs_pos(ad714x, idx);\n\t\t\t\tad714x_wheel_cal_flt_pos(ad714x, idx);\n\t\t\t\tinput_report_abs(sw->input, ABS_WHEEL,\n\t\t\t\t\tsw->flt_pos);\n\t\t\t\tinput_report_key(sw->input, BTN_TOUCH, 1);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tad714x_wheel_use_thr_int(ad714x, idx);\n\t\t\t\tsw->state = IDLE;\n\t\t\t\tinput_report_key(sw->input, BTN_TOUCH, 0);\n\n\t\t\t\tdev_dbg(ad714x->dev, \"wheel %d released\\n\",\n\t\t\t\t\tidx);\n\t\t\t}\n\t\t\tinput_sync(sw->input);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void touchpad_cal_sensor_val(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\tint i;\n\n\tad714x->read(ad714x, CDC_RESULT_S0 + hw->x_start_stage,\n\t\t\t&ad714x->adc_reg[hw->x_start_stage],\n\t\t\thw->x_end_stage - hw->x_start_stage + 1);\n\n\tfor (i = hw->x_start_stage; i <= hw->x_end_stage; i++) {\n\t\tad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,\n\t\t\t\t&ad714x->amb_reg[i], 1);\n\t\tif (ad714x->adc_reg[i] > ad714x->amb_reg[i])\n\t\t\tad714x->sensor_val[i] =\n\t\t\t\tad714x->adc_reg[i] - ad714x->amb_reg[i];\n\t\telse\n\t\t\tad714x->sensor_val[i] = 0;\n\t}\n}\n\nstatic void touchpad_cal_highest_stage(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\tstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\n\n\tsw->x_highest_stage = ad714x_cal_highest_stage(ad714x,\n\t\thw->x_start_stage, hw->x_end_stage);\n\tsw->y_highest_stage = ad714x_cal_highest_stage(ad714x,\n\t\thw->y_start_stage, hw->y_end_stage);\n\n\tdev_dbg(ad714x->dev,\n\t\t\"touchpad %d x_highest_stage:%d, y_highest_stage:%d\\n\",\n\t\tidx, sw->x_highest_stage, sw->y_highest_stage);\n}\n\n \nstatic int touchpad_check_second_peak(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\tstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\n\tint i;\n\n\tfor (i = hw->x_start_stage; i < sw->x_highest_stage; i++) {\n\t\tif ((ad714x->sensor_val[i] - ad714x->sensor_val[i + 1])\n\t\t\t> (ad714x->sensor_val[i + 1] / 10))\n\t\t\treturn 1;\n\t}\n\n\tfor (i = sw->x_highest_stage; i < hw->x_end_stage; i++) {\n\t\tif ((ad714x->sensor_val[i + 1] - ad714x->sensor_val[i])\n\t\t\t> (ad714x->sensor_val[i] / 10))\n\t\t\treturn 1;\n\t}\n\n\tfor (i = hw->y_start_stage; i < sw->y_highest_stage; i++) {\n\t\tif ((ad714x->sensor_val[i] - ad714x->sensor_val[i + 1])\n\t\t\t> (ad714x->sensor_val[i + 1] / 10))\n\t\t\treturn 1;\n\t}\n\n\tfor (i = sw->y_highest_stage; i < hw->y_end_stage; i++) {\n\t\tif ((ad714x->sensor_val[i + 1] - ad714x->sensor_val[i])\n\t\t\t> (ad714x->sensor_val[i] / 10))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void touchpad_cal_abs_pos(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\tstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\n\n\tsw->x_abs_pos = ad714x_cal_abs_pos(ad714x, hw->x_start_stage,\n\t\t\thw->x_end_stage, sw->x_highest_stage, hw->x_max_coord);\n\tsw->y_abs_pos = ad714x_cal_abs_pos(ad714x, hw->y_start_stage,\n\t\t\thw->y_end_stage, sw->y_highest_stage, hw->y_max_coord);\n\n\tdev_dbg(ad714x->dev, \"touchpad %d absolute position:(%d, %d)\\n\", idx,\n\t\t\tsw->x_abs_pos, sw->y_abs_pos);\n}\n\nstatic void touchpad_cal_flt_pos(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\n\n\tsw->x_flt_pos = (sw->x_flt_pos * (10 - 4) +\n\t\t\tsw->x_abs_pos * 4)/10;\n\tsw->y_flt_pos = (sw->y_flt_pos * (10 - 4) +\n\t\t\tsw->y_abs_pos * 4)/10;\n\n\tdev_dbg(ad714x->dev, \"touchpad %d filter position:(%d, %d)\\n\",\n\t\t\tidx, sw->x_flt_pos, sw->y_flt_pos);\n}\n\n \n\n#define LEFT_END_POINT_DETECTION_LEVEL                  550\n#define RIGHT_END_POINT_DETECTION_LEVEL                 750\n#define LEFT_RIGHT_END_POINT_DEAVTIVALION_LEVEL         850\n#define TOP_END_POINT_DETECTION_LEVEL                   550\n#define BOTTOM_END_POINT_DETECTION_LEVEL                950\n#define TOP_BOTTOM_END_POINT_DEAVTIVALION_LEVEL         700\nstatic int touchpad_check_endpoint(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\tstruct ad714x_touchpad_drv *sw  = &ad714x->sw->touchpad[idx];\n\tint percent_sensor_diff;\n\n\t \n\tpercent_sensor_diff = (ad714x->sensor_val[hw->x_start_stage] -\n\t\t\tad714x->sensor_val[hw->x_start_stage + 1]) * 100 /\n\t\t\tad714x->sensor_val[hw->x_start_stage + 1];\n\tif (!sw->left_ep) {\n\t\tif (percent_sensor_diff >= LEFT_END_POINT_DETECTION_LEVEL)  {\n\t\t\tsw->left_ep = 1;\n\t\t\tsw->left_ep_val =\n\t\t\t\tad714x->sensor_val[hw->x_start_stage + 1];\n\t\t}\n\t} else {\n\t\tif ((percent_sensor_diff < LEFT_END_POINT_DETECTION_LEVEL) &&\n\t\t    (ad714x->sensor_val[hw->x_start_stage + 1] >\n\t\t     LEFT_RIGHT_END_POINT_DEAVTIVALION_LEVEL + sw->left_ep_val))\n\t\t\tsw->left_ep = 0;\n\t}\n\n\t \n\tpercent_sensor_diff = (ad714x->sensor_val[hw->x_end_stage] -\n\t\t\tad714x->sensor_val[hw->x_end_stage - 1]) * 100 /\n\t\t\tad714x->sensor_val[hw->x_end_stage - 1];\n\tif (!sw->right_ep) {\n\t\tif (percent_sensor_diff >= RIGHT_END_POINT_DETECTION_LEVEL)  {\n\t\t\tsw->right_ep = 1;\n\t\t\tsw->right_ep_val =\n\t\t\t\tad714x->sensor_val[hw->x_end_stage - 1];\n\t\t}\n\t} else {\n\t\tif ((percent_sensor_diff < RIGHT_END_POINT_DETECTION_LEVEL) &&\n\t\t(ad714x->sensor_val[hw->x_end_stage - 1] >\n\t\tLEFT_RIGHT_END_POINT_DEAVTIVALION_LEVEL + sw->right_ep_val))\n\t\t\tsw->right_ep = 0;\n\t}\n\n\t \n\tpercent_sensor_diff = (ad714x->sensor_val[hw->y_start_stage] -\n\t\t\tad714x->sensor_val[hw->y_start_stage + 1]) * 100 /\n\t\t\tad714x->sensor_val[hw->y_start_stage + 1];\n\tif (!sw->top_ep) {\n\t\tif (percent_sensor_diff >= TOP_END_POINT_DETECTION_LEVEL)  {\n\t\t\tsw->top_ep = 1;\n\t\t\tsw->top_ep_val =\n\t\t\t\tad714x->sensor_val[hw->y_start_stage + 1];\n\t\t}\n\t} else {\n\t\tif ((percent_sensor_diff < TOP_END_POINT_DETECTION_LEVEL) &&\n\t\t(ad714x->sensor_val[hw->y_start_stage + 1] >\n\t\tTOP_BOTTOM_END_POINT_DEAVTIVALION_LEVEL + sw->top_ep_val))\n\t\t\tsw->top_ep = 0;\n\t}\n\n\t \n\tpercent_sensor_diff = (ad714x->sensor_val[hw->y_end_stage] -\n\t\tad714x->sensor_val[hw->y_end_stage - 1]) * 100 /\n\t\tad714x->sensor_val[hw->y_end_stage - 1];\n\tif (!sw->bottom_ep) {\n\t\tif (percent_sensor_diff >= BOTTOM_END_POINT_DETECTION_LEVEL)  {\n\t\t\tsw->bottom_ep = 1;\n\t\t\tsw->bottom_ep_val =\n\t\t\t\tad714x->sensor_val[hw->y_end_stage - 1];\n\t\t}\n\t} else {\n\t\tif ((percent_sensor_diff < BOTTOM_END_POINT_DETECTION_LEVEL) &&\n\t\t(ad714x->sensor_val[hw->y_end_stage - 1] >\n\t\t TOP_BOTTOM_END_POINT_DEAVTIVALION_LEVEL + sw->bottom_ep_val))\n\t\t\tsw->bottom_ep = 0;\n\t}\n\n\treturn sw->left_ep || sw->right_ep || sw->top_ep || sw->bottom_ep;\n}\n\nstatic void touchpad_use_com_int(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\n\tad714x_use_com_int(ad714x, hw->x_start_stage, hw->x_end_stage);\n}\n\nstatic void touchpad_use_thr_int(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\n\tad714x_use_thr_int(ad714x, hw->x_start_stage, hw->x_end_stage);\n\tad714x_use_thr_int(ad714x, hw->y_start_stage, hw->y_end_stage);\n}\n\nstatic void ad714x_touchpad_state_machine(struct ad714x_chip *ad714x, int idx)\n{\n\tstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\n\tstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\n\tunsigned short h_state, c_state;\n\tunsigned short mask;\n\n\tmask = (((1 << (hw->x_end_stage + 1)) - 1) -\n\t\t((1 << hw->x_start_stage) - 1)) +\n\t\t(((1 << (hw->y_end_stage + 1)) - 1) -\n\t\t((1 << hw->y_start_stage) - 1));\n\n\th_state = ad714x->h_state & mask;\n\tc_state = ad714x->c_state & mask;\n\n\tswitch (sw->state) {\n\tcase IDLE:\n\t\tif (h_state) {\n\t\t\tsw->state = JITTER;\n\t\t\t \n\t\t\ttouchpad_use_com_int(ad714x, idx);\n\t\t\tdev_dbg(ad714x->dev, \"touchpad %d touched\\n\", idx);\n\t\t}\n\t\tbreak;\n\n\tcase JITTER:\n\t\tif (c_state == mask) {\n\t\t\ttouchpad_cal_sensor_val(ad714x, idx);\n\t\t\ttouchpad_cal_highest_stage(ad714x, idx);\n\t\t\tif ((!touchpad_check_second_peak(ad714x, idx)) &&\n\t\t\t\t(!touchpad_check_endpoint(ad714x, idx))) {\n\t\t\t\tdev_dbg(ad714x->dev,\n\t\t\t\t\t\"touchpad%d, 2 fingers or endpoint\\n\",\n\t\t\t\t\tidx);\n\t\t\t\ttouchpad_cal_abs_pos(ad714x, idx);\n\t\t\t\tsw->x_flt_pos = sw->x_abs_pos;\n\t\t\t\tsw->y_flt_pos = sw->y_abs_pos;\n\t\t\t\tsw->state = ACTIVE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACTIVE:\n\t\tif (c_state == mask) {\n\t\t\tif (h_state) {\n\t\t\t\ttouchpad_cal_sensor_val(ad714x, idx);\n\t\t\t\ttouchpad_cal_highest_stage(ad714x, idx);\n\t\t\t\tif ((!touchpad_check_second_peak(ad714x, idx))\n\t\t\t\t  && (!touchpad_check_endpoint(ad714x, idx))) {\n\t\t\t\t\ttouchpad_cal_abs_pos(ad714x, idx);\n\t\t\t\t\ttouchpad_cal_flt_pos(ad714x, idx);\n\t\t\t\t\tinput_report_abs(sw->input, ABS_X,\n\t\t\t\t\t\tsw->x_flt_pos);\n\t\t\t\t\tinput_report_abs(sw->input, ABS_Y,\n\t\t\t\t\t\tsw->y_flt_pos);\n\t\t\t\t\tinput_report_key(sw->input, BTN_TOUCH,\n\t\t\t\t\t\t1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttouchpad_use_thr_int(ad714x, idx);\n\t\t\t\tsw->state = IDLE;\n\t\t\t\tinput_report_key(sw->input, BTN_TOUCH, 0);\n\t\t\t\tdev_dbg(ad714x->dev, \"touchpad %d released\\n\",\n\t\t\t\t\tidx);\n\t\t\t}\n\t\t\tinput_sync(sw->input);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int ad714x_hw_detect(struct ad714x_chip *ad714x)\n{\n\tunsigned short data;\n\n\tad714x->read(ad714x, AD714X_PARTID_REG, &data, 1);\n\tswitch (data & 0xFFF0) {\n\tcase AD7142_PARTID:\n\t\tad714x->product = 0x7142;\n\t\tad714x->version = data & 0xF;\n\t\tdev_info(ad714x->dev, \"found AD7142 captouch, rev:%d\\n\",\n\t\t\t\tad714x->version);\n\t\treturn 0;\n\n\tcase AD7143_PARTID:\n\t\tad714x->product = 0x7143;\n\t\tad714x->version = data & 0xF;\n\t\tdev_info(ad714x->dev, \"found AD7143 captouch, rev:%d\\n\",\n\t\t\t\tad714x->version);\n\t\treturn 0;\n\n\tcase AD7147_PARTID:\n\t\tad714x->product = 0x7147;\n\t\tad714x->version = data & 0xF;\n\t\tdev_info(ad714x->dev, \"found AD7147(A) captouch, rev:%d\\n\",\n\t\t\t\tad714x->version);\n\t\treturn 0;\n\n\tcase AD7148_PARTID:\n\t\tad714x->product = 0x7148;\n\t\tad714x->version = data & 0xF;\n\t\tdev_info(ad714x->dev, \"found AD7148 captouch, rev:%d\\n\",\n\t\t\t\tad714x->version);\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_err(ad714x->dev,\n\t\t\t\"fail to detect AD714X captouch, read ID is %04x\\n\",\n\t\t\tdata);\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic void ad714x_hw_init(struct ad714x_chip *ad714x)\n{\n\tint i, j;\n\tunsigned short reg_base;\n\tunsigned short data;\n\n\t \n\n\tfor (i = 0; i < STAGE_NUM; i++) {\n\t\treg_base = AD714X_STAGECFG_REG + i * STAGE_CFGREG_NUM;\n\t\tfor (j = 0; j < STAGE_CFGREG_NUM; j++)\n\t\t\tad714x->write(ad714x, reg_base + j,\n\t\t\t\t\tad714x->hw->stage_cfg_reg[i][j]);\n\t}\n\n\tfor (i = 0; i < SYS_CFGREG_NUM; i++)\n\t\tad714x->write(ad714x, AD714X_SYSCFG_REG + i,\n\t\t\tad714x->hw->sys_cfg_reg[i]);\n\tfor (i = 0; i < SYS_CFGREG_NUM; i++)\n\t\tad714x->read(ad714x, AD714X_SYSCFG_REG + i, &data, 1);\n\n\tad714x->write(ad714x, AD714X_STG_CAL_EN_REG, 0xFFF);\n\n\t \n\tad714x->read(ad714x, STG_LOW_INT_STA_REG, &ad714x->l_state, 3);\n}\n\nstatic irqreturn_t ad714x_interrupt_thread(int irq, void *data)\n{\n\tstruct ad714x_chip *ad714x = data;\n\tint i;\n\n\tmutex_lock(&ad714x->mutex);\n\n\tad714x->read(ad714x, STG_LOW_INT_STA_REG, &ad714x->l_state, 3);\n\n\tfor (i = 0; i < ad714x->hw->button_num; i++)\n\t\tad714x_button_state_machine(ad714x, i);\n\tfor (i = 0; i < ad714x->hw->slider_num; i++)\n\t\tad714x_slider_state_machine(ad714x, i);\n\tfor (i = 0; i < ad714x->hw->wheel_num; i++)\n\t\tad714x_wheel_state_machine(ad714x, i);\n\tfor (i = 0; i < ad714x->hw->touchpad_num; i++)\n\t\tad714x_touchpad_state_machine(ad714x, i);\n\n\tmutex_unlock(&ad714x->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstruct ad714x_chip *ad714x_probe(struct device *dev, u16 bus_type, int irq,\n\t\t\t\t ad714x_read_t read, ad714x_write_t write)\n{\n\tint i;\n\tint error;\n\tstruct input_dev *input;\n\n\tstruct ad714x_platform_data *plat_data = dev_get_platdata(dev);\n\tstruct ad714x_chip *ad714x;\n\tvoid *drv_mem;\n\tunsigned long irqflags;\n\n\tstruct ad714x_button_drv *bt_drv;\n\tstruct ad714x_slider_drv *sd_drv;\n\tstruct ad714x_wheel_drv *wl_drv;\n\tstruct ad714x_touchpad_drv *tp_drv;\n\n\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"IRQ not configured!\\n\");\n\t\terror = -EINVAL;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (dev_get_platdata(dev) == NULL) {\n\t\tdev_err(dev, \"platform data for ad714x doesn't exist\\n\");\n\t\terror = -EINVAL;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tad714x = devm_kzalloc(dev, sizeof(*ad714x) + sizeof(*ad714x->sw) +\n\t\t\t\t   sizeof(*sd_drv) * plat_data->slider_num +\n\t\t\t\t   sizeof(*wl_drv) * plat_data->wheel_num +\n\t\t\t\t   sizeof(*tp_drv) * plat_data->touchpad_num +\n\t\t\t\t   sizeof(*bt_drv) * plat_data->button_num,\n\t\t\t      GFP_KERNEL);\n\tif (!ad714x) {\n\t\terror = -ENOMEM;\n\t\treturn ERR_PTR(error);\n\t}\n\tad714x->hw = plat_data;\n\n\tdrv_mem = ad714x + 1;\n\tad714x->sw = drv_mem;\n\tdrv_mem += sizeof(*ad714x->sw);\n\tad714x->sw->slider = sd_drv = drv_mem;\n\tdrv_mem += sizeof(*sd_drv) * ad714x->hw->slider_num;\n\tad714x->sw->wheel = wl_drv = drv_mem;\n\tdrv_mem += sizeof(*wl_drv) * ad714x->hw->wheel_num;\n\tad714x->sw->touchpad = tp_drv = drv_mem;\n\tdrv_mem += sizeof(*tp_drv) * ad714x->hw->touchpad_num;\n\tad714x->sw->button = bt_drv = drv_mem;\n\tdrv_mem += sizeof(*bt_drv) * ad714x->hw->button_num;\n\n\tad714x->read = read;\n\tad714x->write = write;\n\tad714x->irq = irq;\n\tad714x->dev = dev;\n\n\terror = ad714x_hw_detect(ad714x);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t \n\n\tad714x_hw_init(ad714x);\n\tmutex_init(&ad714x->mutex);\n\n\t \n\tif (ad714x->hw->slider_num > 0) {\n\t\tstruct ad714x_slider_plat *sd_plat = ad714x->hw->slider;\n\n\t\tfor (i = 0; i < ad714x->hw->slider_num; i++) {\n\t\t\tinput = devm_input_allocate_device(dev);\n\t\t\tif (!input)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t\t__set_bit(EV_ABS, input->evbit);\n\t\t\t__set_bit(EV_KEY, input->evbit);\n\t\t\t__set_bit(ABS_X, input->absbit);\n\t\t\t__set_bit(BTN_TOUCH, input->keybit);\n\t\t\tinput_set_abs_params(input,\n\t\t\t\tABS_X, 0, sd_plat->max_coord, 0, 0);\n\n\t\t\tinput->id.bustype = bus_type;\n\t\t\tinput->id.product = ad714x->product;\n\t\t\tinput->id.version = ad714x->version;\n\t\t\tinput->name = \"ad714x_captouch_slider\";\n\t\t\tinput->dev.parent = dev;\n\n\t\t\terror = input_register_device(input);\n\t\t\tif (error)\n\t\t\t\treturn ERR_PTR(error);\n\n\t\t\tsd_drv[i].input = input;\n\t\t}\n\t}\n\n\t \n\tif (ad714x->hw->wheel_num > 0) {\n\t\tstruct ad714x_wheel_plat *wl_plat = ad714x->hw->wheel;\n\n\t\tfor (i = 0; i < ad714x->hw->wheel_num; i++) {\n\t\t\tinput = devm_input_allocate_device(dev);\n\t\t\tif (!input)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t\t__set_bit(EV_KEY, input->evbit);\n\t\t\t__set_bit(EV_ABS, input->evbit);\n\t\t\t__set_bit(ABS_WHEEL, input->absbit);\n\t\t\t__set_bit(BTN_TOUCH, input->keybit);\n\t\t\tinput_set_abs_params(input,\n\t\t\t\tABS_WHEEL, 0, wl_plat->max_coord, 0, 0);\n\n\t\t\tinput->id.bustype = bus_type;\n\t\t\tinput->id.product = ad714x->product;\n\t\t\tinput->id.version = ad714x->version;\n\t\t\tinput->name = \"ad714x_captouch_wheel\";\n\t\t\tinput->dev.parent = dev;\n\n\t\t\terror = input_register_device(input);\n\t\t\tif (error)\n\t\t\t\treturn ERR_PTR(error);\n\n\t\t\twl_drv[i].input = input;\n\t\t}\n\t}\n\n\t \n\tif (ad714x->hw->touchpad_num > 0) {\n\t\tstruct ad714x_touchpad_plat *tp_plat = ad714x->hw->touchpad;\n\n\t\tfor (i = 0; i < ad714x->hw->touchpad_num; i++) {\n\t\t\tinput = devm_input_allocate_device(dev);\n\t\t\tif (!input)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t\t__set_bit(EV_ABS, input->evbit);\n\t\t\t__set_bit(EV_KEY, input->evbit);\n\t\t\t__set_bit(ABS_X, input->absbit);\n\t\t\t__set_bit(ABS_Y, input->absbit);\n\t\t\t__set_bit(BTN_TOUCH, input->keybit);\n\t\t\tinput_set_abs_params(input,\n\t\t\t\tABS_X, 0, tp_plat->x_max_coord, 0, 0);\n\t\t\tinput_set_abs_params(input,\n\t\t\t\tABS_Y, 0, tp_plat->y_max_coord, 0, 0);\n\n\t\t\tinput->id.bustype = bus_type;\n\t\t\tinput->id.product = ad714x->product;\n\t\t\tinput->id.version = ad714x->version;\n\t\t\tinput->name = \"ad714x_captouch_pad\";\n\t\t\tinput->dev.parent = dev;\n\n\t\t\terror = input_register_device(input);\n\t\t\tif (error)\n\t\t\t\treturn ERR_PTR(error);\n\n\t\t\ttp_drv[i].input = input;\n\t\t}\n\t}\n\n\t \n\tif (ad714x->hw->button_num > 0) {\n\t\tstruct ad714x_button_plat *bt_plat = ad714x->hw->button;\n\n\t\tinput = devm_input_allocate_device(dev);\n\t\tif (!input) {\n\t\t\terror = -ENOMEM;\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\n\t\t__set_bit(EV_KEY, input->evbit);\n\t\tfor (i = 0; i < ad714x->hw->button_num; i++) {\n\t\t\tbt_drv[i].input = input;\n\t\t\t__set_bit(bt_plat[i].keycode, input->keybit);\n\t\t}\n\n\t\tinput->id.bustype = bus_type;\n\t\tinput->id.product = ad714x->product;\n\t\tinput->id.version = ad714x->version;\n\t\tinput->name = \"ad714x_captouch_button\";\n\t\tinput->dev.parent = dev;\n\n\t\terror = input_register_device(input);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tirqflags = plat_data->irqflags ?: IRQF_TRIGGER_FALLING;\n\tirqflags |= IRQF_ONESHOT;\n\n\terror = devm_request_threaded_irq(dev, ad714x->irq, NULL,\n\t\t\t\t\t  ad714x_interrupt_thread,\n\t\t\t\t\t  irqflags, \"ad714x_captouch\", ad714x);\n\tif (error) {\n\t\tdev_err(dev, \"can't allocate irq %d\\n\", ad714x->irq);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn ad714x;\n}\nEXPORT_SYMBOL(ad714x_probe);\n\nstatic int ad714x_suspend(struct device *dev)\n{\n\tstruct ad714x_chip *ad714x = dev_get_drvdata(dev);\n\tunsigned short data;\n\n\tdev_dbg(ad714x->dev, \"%s enter\\n\", __func__);\n\n\tmutex_lock(&ad714x->mutex);\n\n\tdata = ad714x->hw->sys_cfg_reg[AD714X_PWR_CTRL] | 0x3;\n\tad714x->write(ad714x, AD714X_PWR_CTRL, data);\n\n\tmutex_unlock(&ad714x->mutex);\n\n\treturn 0;\n}\n\nstatic int ad714x_resume(struct device *dev)\n{\n\tstruct ad714x_chip *ad714x = dev_get_drvdata(dev);\n\tdev_dbg(ad714x->dev, \"%s enter\\n\", __func__);\n\n\tmutex_lock(&ad714x->mutex);\n\n\t \n\n\tad714x->write(ad714x, AD714X_PWR_CTRL,\n\t\t\tad714x->hw->sys_cfg_reg[AD714X_PWR_CTRL]);\n\n\t \n\n\tad714x->read(ad714x, STG_LOW_INT_STA_REG, &ad714x->l_state, 3);\n\n\tmutex_unlock(&ad714x->mutex);\n\n\treturn 0;\n}\n\nEXPORT_SIMPLE_DEV_PM_OPS(ad714x_pm, ad714x_suspend, ad714x_resume);\n\nMODULE_DESCRIPTION(\"Analog Devices AD714X Capacitance Touch Sensor Driver\");\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}