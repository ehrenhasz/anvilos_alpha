{
  "module_name": "kxtj9.c",
  "hash_id": "57e4fb8a6c4547e0e281f7f388cd340dff5d942cbcde0e8ce6a3dd4b07fe2cc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/kxtj9.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input/kxtj9.h>\n\n#define NAME\t\t\t\"kxtj9\"\n#define G_MAX\t\t\t8000\n \n#define XOUT_L\t\t\t0x06\n#define WHO_AM_I\t\t0x0F\n \n#define INT_REL\t\t\t0x1A\n#define CTRL_REG1\t\t0x1B\n#define INT_CTRL1\t\t0x1E\n#define DATA_CTRL\t\t0x21\n \n#define PC1_OFF\t\t\t0x7F\n#define PC1_ON\t\t\t(1 << 7)\n \n#define DRDYE\t\t\t(1 << 5)\n \n#define ODR12_5F\t\t0\n#define ODR25F\t\t\t1\n#define ODR50F\t\t\t2\n#define ODR100F\t\t3\n#define ODR200F\t\t4\n#define ODR400F\t\t5\n#define ODR800F\t\t6\n \n \n#define KXTJ9_IEL\t\t(1 << 3)\n#define KXTJ9_IEA\t\t(1 << 4)\n#define KXTJ9_IEN\t\t(1 << 5)\n \n#define FUZZ\t\t\t3\n#define FLAT\t\t\t3\n \n#define RES_DATA_CTRL\t\t0\n#define RES_CTRL_REG1\t\t1\n#define RES_INT_CTRL1\t\t2\n#define RESUME_ENTRIES\t\t3\n\n \nstatic const struct {\n\tunsigned int cutoff;\n\tu8 mask;\n} kxtj9_odr_table[] = {\n\t{ 3,\tODR800F },\n\t{ 5,\tODR400F },\n\t{ 10,\tODR200F },\n\t{ 20,\tODR100F },\n\t{ 40,\tODR50F  },\n\t{ 80,\tODR25F  },\n\t{ 0,\tODR12_5F},\n};\n\nstruct kxtj9_data {\n\tstruct i2c_client *client;\n\tstruct kxtj9_platform_data pdata;\n\tstruct input_dev *input_dev;\n\tunsigned int last_poll_interval;\n\tu8 shift;\n\tu8 ctrl_reg1;\n\tu8 data_ctrl;\n\tu8 int_ctrl;\n};\n\nstatic int kxtj9_i2c_read(struct kxtj9_data *tj9, u8 addr, u8 *data, int len)\n{\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = tj9->client->addr,\n\t\t\t.flags = tj9->client->flags,\n\t\t\t.len = 1,\n\t\t\t.buf = &addr,\n\t\t},\n\t\t{\n\t\t\t.addr = tj9->client->addr,\n\t\t\t.flags = tj9->client->flags | I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = data,\n\t\t},\n\t};\n\n\treturn i2c_transfer(tj9->client->adapter, msgs, 2);\n}\n\nstatic void kxtj9_report_acceleration_data(struct kxtj9_data *tj9)\n{\n\ts16 acc_data[3];  \n\ts16 x, y, z;\n\tint err;\n\n\terr = kxtj9_i2c_read(tj9, XOUT_L, (u8 *)acc_data, 6);\n\tif (err < 0)\n\t\tdev_err(&tj9->client->dev, \"accelerometer data read failed\\n\");\n\n\tx = le16_to_cpu(acc_data[tj9->pdata.axis_map_x]);\n\ty = le16_to_cpu(acc_data[tj9->pdata.axis_map_y]);\n\tz = le16_to_cpu(acc_data[tj9->pdata.axis_map_z]);\n\n\tx >>= tj9->shift;\n\ty >>= tj9->shift;\n\tz >>= tj9->shift;\n\n\tinput_report_abs(tj9->input_dev, ABS_X, tj9->pdata.negate_x ? -x : x);\n\tinput_report_abs(tj9->input_dev, ABS_Y, tj9->pdata.negate_y ? -y : y);\n\tinput_report_abs(tj9->input_dev, ABS_Z, tj9->pdata.negate_z ? -z : z);\n\tinput_sync(tj9->input_dev);\n}\n\nstatic irqreturn_t kxtj9_isr(int irq, void *dev)\n{\n\tstruct kxtj9_data *tj9 = dev;\n\tint err;\n\n\t \n\tkxtj9_report_acceleration_data(tj9);\n\n\terr = i2c_smbus_read_byte_data(tj9->client, INT_REL);\n\tif (err < 0)\n\t\tdev_err(&tj9->client->dev,\n\t\t\t\"error clearing interrupt status: %d\\n\", err);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int kxtj9_update_g_range(struct kxtj9_data *tj9, u8 new_g_range)\n{\n\tswitch (new_g_range) {\n\tcase KXTJ9_G_2G:\n\t\ttj9->shift = 4;\n\t\tbreak;\n\tcase KXTJ9_G_4G:\n\t\ttj9->shift = 3;\n\t\tbreak;\n\tcase KXTJ9_G_8G:\n\t\ttj9->shift = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttj9->ctrl_reg1 &= 0xe7;\n\ttj9->ctrl_reg1 |= new_g_range;\n\n\treturn 0;\n}\n\nstatic int kxtj9_update_odr(struct kxtj9_data *tj9, unsigned int poll_interval)\n{\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(kxtj9_odr_table); i++) {\n\t\ttj9->data_ctrl = kxtj9_odr_table[i].mask;\n\t\tif (poll_interval < kxtj9_odr_table[i].cutoff)\n\t\t\tbreak;\n\t}\n\n\terr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = i2c_smbus_write_byte_data(tj9->client, DATA_CTRL, tj9->data_ctrl);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, tj9->ctrl_reg1);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int kxtj9_device_power_on(struct kxtj9_data *tj9)\n{\n\tif (tj9->pdata.power_on)\n\t\treturn tj9->pdata.power_on();\n\n\treturn 0;\n}\n\nstatic void kxtj9_device_power_off(struct kxtj9_data *tj9)\n{\n\tint err;\n\n\ttj9->ctrl_reg1 &= PC1_OFF;\n\terr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, tj9->ctrl_reg1);\n\tif (err < 0)\n\t\tdev_err(&tj9->client->dev, \"soft power off failed\\n\");\n\n\tif (tj9->pdata.power_off)\n\t\ttj9->pdata.power_off();\n}\n\nstatic int kxtj9_enable(struct kxtj9_data *tj9)\n{\n\tint err;\n\n\terr = kxtj9_device_power_on(tj9);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (tj9->client->irq) {\n\t\terr = i2c_smbus_write_byte_data(tj9->client,\n\t\t\t\t\t\tINT_CTRL1, tj9->int_ctrl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = kxtj9_update_g_range(tj9, tj9->pdata.g_range);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\ttj9->ctrl_reg1 |= PC1_ON;\n\terr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, tj9->ctrl_reg1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = kxtj9_update_odr(tj9, tj9->last_poll_interval);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (tj9->client->irq) {\n\t\terr = i2c_smbus_read_byte_data(tj9->client, INT_REL);\n\t\tif (err < 0) {\n\t\t\tdev_err(&tj9->client->dev,\n\t\t\t\t\"error clearing interrupt: %d\\n\", err);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\tkxtj9_device_power_off(tj9);\n\treturn err;\n}\n\nstatic void kxtj9_disable(struct kxtj9_data *tj9)\n{\n\tkxtj9_device_power_off(tj9);\n}\n\nstatic int kxtj9_input_open(struct input_dev *input)\n{\n\tstruct kxtj9_data *tj9 = input_get_drvdata(input);\n\n\treturn kxtj9_enable(tj9);\n}\n\nstatic void kxtj9_input_close(struct input_dev *dev)\n{\n\tstruct kxtj9_data *tj9 = input_get_drvdata(dev);\n\n\tkxtj9_disable(tj9);\n}\n\n \n\n \nstatic ssize_t kxtj9_get_poll(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d\\n\", tj9->last_poll_interval);\n}\n\n \nstatic ssize_t kxtj9_set_poll(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = tj9->input_dev;\n\tunsigned int interval;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &interval);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tmutex_lock(&input_dev->mutex);\n\n\tdisable_irq(client->irq);\n\n\t \n\ttj9->last_poll_interval = max(interval, tj9->pdata.min_interval);\n\n\tkxtj9_update_odr(tj9, tj9->last_poll_interval);\n\n\tenable_irq(client->irq);\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(poll, S_IRUGO|S_IWUSR, kxtj9_get_poll, kxtj9_set_poll);\n\nstatic struct attribute *kxtj9_attributes[] = {\n\t&dev_attr_poll.attr,\n\tNULL\n};\n\nstatic struct attribute_group kxtj9_attribute_group = {\n\t.attrs = kxtj9_attributes\n};\n\nstatic void kxtj9_poll(struct input_dev *input)\n{\n\tstruct kxtj9_data *tj9 = input_get_drvdata(input);\n\tunsigned int poll_interval = input_get_poll_interval(input);\n\n\tkxtj9_report_acceleration_data(tj9);\n\n\tif (poll_interval != tj9->last_poll_interval) {\n\t\tkxtj9_update_odr(tj9, poll_interval);\n\t\ttj9->last_poll_interval = poll_interval;\n\t}\n}\n\nstatic void kxtj9_platform_exit(void *data)\n{\n\tstruct kxtj9_data *tj9 = data;\n\n\tif (tj9->pdata.exit)\n\t\ttj9->pdata.exit();\n}\n\nstatic int kxtj9_verify(struct kxtj9_data *tj9)\n{\n\tint retval;\n\n\tretval = kxtj9_device_power_on(tj9);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = i2c_smbus_read_byte_data(tj9->client, WHO_AM_I);\n\tif (retval < 0) {\n\t\tdev_err(&tj9->client->dev, \"read err int source\\n\");\n\t\tgoto out;\n\t}\n\n\tretval = (retval != 0x07 && retval != 0x08) ? -EIO : 0;\n\nout:\n\tkxtj9_device_power_off(tj9);\n\treturn retval;\n}\n\nstatic int kxtj9_probe(struct i2c_client *client)\n{\n\tconst struct kxtj9_platform_data *pdata =\n\t\t\tdev_get_platdata(&client->dev);\n\tstruct kxtj9_data *tj9;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\tI2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"client is not i2c capable\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"platform data is NULL; exiting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttj9 = devm_kzalloc(&client->dev, sizeof(*tj9), GFP_KERNEL);\n\tif (!tj9) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to allocate memory for module data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttj9->client = client;\n\ttj9->pdata = *pdata;\n\n\tif (pdata->init) {\n\t\terr = pdata->init();\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(&client->dev, kxtj9_platform_exit, tj9);\n\tif (err)\n\t\treturn err;\n\n\terr = kxtj9_verify(tj9);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"device not recognized\\n\");\n\t\treturn err;\n\t}\n\n\ti2c_set_clientdata(client, tj9);\n\n\ttj9->ctrl_reg1 = tj9->pdata.res_12bit | tj9->pdata.g_range;\n\ttj9->last_poll_interval = tj9->pdata.init_interval;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"input device allocate failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(input_dev, tj9);\n\ttj9->input_dev = input_dev;\n\n\tinput_dev->name = \"kxtj9_accel\";\n\tinput_dev->id.bustype = BUS_I2C;\n\n\tinput_dev->open = kxtj9_input_open;\n\tinput_dev->close = kxtj9_input_close;\n\n\tinput_set_abs_params(input_dev, ABS_X, -G_MAX, G_MAX, FUZZ, FLAT);\n\tinput_set_abs_params(input_dev, ABS_Y, -G_MAX, G_MAX, FUZZ, FLAT);\n\tinput_set_abs_params(input_dev, ABS_Z, -G_MAX, G_MAX, FUZZ, FLAT);\n\n\tif (client->irq <= 0) {\n\t\terr = input_setup_polling(input_dev, kxtj9_poll);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = input_register_device(input_dev);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"unable to register input polled device %s: %d\\n\",\n\t\t\tinput_dev->name, err);\n\t\treturn err;\n\t}\n\n\tif (client->irq) {\n\t\t \n\t\ttj9->int_ctrl |= KXTJ9_IEN | KXTJ9_IEA | KXTJ9_IEL;\n\t\ttj9->ctrl_reg1 |= DRDYE;\n\n\t\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\tNULL, kxtj9_isr,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"kxtj9-irq\", tj9);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"request irq failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = devm_device_add_group(&client->dev,\n\t\t\t\t\t    &kxtj9_attribute_group);\n\t\tif (err) {\n\t\t\tdev_err(&client->dev, \"sysfs create failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int kxtj9_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = tj9->input_dev;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tkxtj9_disable(tj9);\n\n\tmutex_unlock(&input_dev->mutex);\n\treturn 0;\n}\n\nstatic int kxtj9_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = tj9->input_dev;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tkxtj9_enable(tj9);\n\n\tmutex_unlock(&input_dev->mutex);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(kxtj9_pm_ops, kxtj9_suspend, kxtj9_resume);\n\nstatic const struct i2c_device_id kxtj9_id[] = {\n\t{ NAME, 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, kxtj9_id);\n\nstatic struct i2c_driver kxtj9_driver = {\n\t.driver = {\n\t\t.name\t= NAME,\n\t\t.pm\t= pm_sleep_ptr(&kxtj9_pm_ops),\n\t},\n\t.probe\t\t= kxtj9_probe,\n\t.id_table\t= kxtj9_id,\n};\n\nmodule_i2c_driver(kxtj9_driver);\n\nMODULE_DESCRIPTION(\"KXTJ9 accelerometer driver\");\nMODULE_AUTHOR(\"Chris Hudson <chudson@kionix.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}