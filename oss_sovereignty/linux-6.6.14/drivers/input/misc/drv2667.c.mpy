{
  "module_name": "drv2667.c",
  "hash_id": "1dd85e5b5766c521afaa26ddc38b1d86371168745ff4cba94636465d8585e300",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/drv2667.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n\n \n#define DRV2667_STATUS\t0x00\n#define DRV2667_CTRL_1\t0x01\n#define DRV2667_CTRL_2\t0x02\n \n#define DRV2667_WV_SEQ_0\t0x03\n#define DRV2667_WV_SEQ_1\t0x04\n#define DRV2667_WV_SEQ_2\t0x05\n#define DRV2667_WV_SEQ_3\t0x06\n#define DRV2667_WV_SEQ_4\t0x07\n#define DRV2667_WV_SEQ_5\t0x08\n#define DRV2667_WV_SEQ_6\t0x09\n#define DRV2667_WV_SEQ_7\t0x0A\n#define DRV2667_FIFO\t\t0x0B\n#define DRV2667_PAGE\t\t0xFF\n#define DRV2667_MAX_REG\t\tDRV2667_PAGE\n\n#define DRV2667_PAGE_0\t\t0x00\n#define DRV2667_PAGE_1\t\t0x01\n#define DRV2667_PAGE_2\t\t0x02\n#define DRV2667_PAGE_3\t\t0x03\n#define DRV2667_PAGE_4\t\t0x04\n#define DRV2667_PAGE_5\t\t0x05\n#define DRV2667_PAGE_6\t\t0x06\n#define DRV2667_PAGE_7\t\t0x07\n#define DRV2667_PAGE_8\t\t0x08\n\n \n#define DRV2667_RAM_HDR_SZ\t0x0\n \n#define DRV2667_RAM_START_HI\t0x01\n#define DRV2667_RAM_START_LO\t0x02\n#define DRV2667_RAM_STOP_HI\t\t0x03\n#define DRV2667_RAM_STOP_LO\t\t0x04\n#define DRV2667_RAM_REPEAT_CT\t0x05\n \n#define DRV2667_RAM_AMP\t\t0x06\n#define DRV2667_RAM_FREQ\t0x07\n#define DRV2667_RAM_DURATION\t0x08\n#define DRV2667_RAM_ENVELOPE\t0x09\n\n \n#define DRV2667_25_VPP_GAIN\t\t0x00\n#define DRV2667_50_VPP_GAIN\t\t0x01\n#define DRV2667_75_VPP_GAIN\t\t0x02\n#define DRV2667_100_VPP_GAIN\t0x03\n#define DRV2667_DIGITAL_IN\t\t0xfc\n#define DRV2667_ANALOG_IN\t\t(1 << 2)\n\n \n#define DRV2667_GO\t\t\t(1 << 0)\n#define DRV2667_STANDBY\t\t(1 << 6)\n#define DRV2667_DEV_RST\t\t(1 << 7)\n\n \n#define DRV2667_NO_ENV\t\t\t0x00\n#define DRV2667_32_MS_ENV\t\t0x01\n#define DRV2667_64_MS_ENV\t\t0x02\n#define DRV2667_96_MS_ENV\t\t0x03\n#define DRV2667_128_MS_ENV\t\t0x04\n#define DRV2667_160_MS_ENV\t\t0x05\n#define DRV2667_192_MS_ENV\t\t0x06\n#define DRV2667_224_MS_ENV\t\t0x07\n#define DRV2667_256_MS_ENV\t\t0x08\n#define DRV2667_512_MS_ENV\t\t0x09\n#define DRV2667_768_MS_ENV\t\t0x0a\n#define DRV2667_1024_MS_ENV\t\t0x0b\n#define DRV2667_1280_MS_ENV\t\t0x0c\n#define DRV2667_1536_MS_ENV\t\t0x0d\n#define DRV2667_1792_MS_ENV\t\t0x0e\n#define DRV2667_2048_MS_ENV\t\t0x0f\n\n \nstruct drv2667_data {\n\tstruct input_dev *input_dev;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct work_struct work;\n\tstruct regulator *regulator;\n\tu32 page;\n\tu32 magnitude;\n\tu32 frequency;\n};\n\nstatic const struct reg_default drv2667_reg_defs[] = {\n\t{ DRV2667_STATUS, 0x02 },\n\t{ DRV2667_CTRL_1, 0x28 },\n\t{ DRV2667_CTRL_2, 0x40 },\n\t{ DRV2667_WV_SEQ_0, 0x00 },\n\t{ DRV2667_WV_SEQ_1, 0x00 },\n\t{ DRV2667_WV_SEQ_2, 0x00 },\n\t{ DRV2667_WV_SEQ_3, 0x00 },\n\t{ DRV2667_WV_SEQ_4, 0x00 },\n\t{ DRV2667_WV_SEQ_5, 0x00 },\n\t{ DRV2667_WV_SEQ_6, 0x00 },\n\t{ DRV2667_WV_SEQ_7, 0x00 },\n\t{ DRV2667_FIFO, 0x00 },\n\t{ DRV2667_PAGE, 0x00 },\n};\n\nstatic int drv2667_set_waveform_freq(struct drv2667_data *haptics)\n{\n\tunsigned int read_buf;\n\tint freq;\n\tint error;\n\n\t \n\tfreq = (haptics->frequency * 1000) / 78125;\n\tif (freq <= 0) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"ERROR: Frequency calculated to %i\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\terror = regmap_read(haptics->regmap, DRV2667_PAGE, &read_buf);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to read the page number: %d\\n\", error);\n\t\treturn -EIO;\n\t}\n\n\tif (read_buf == DRV2667_PAGE_0 ||\n\t\thaptics->page != read_buf) {\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\tDRV2667_PAGE, haptics->page);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the page: %d\\n\", error);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\terror = regmap_write(haptics->regmap, DRV2667_RAM_FREQ,\tfreq);\n\tif (error)\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the frequency: %d\\n\", error);\n\n\t \n\tif (read_buf == DRV2667_PAGE_0 ||\n\t\thaptics->page != read_buf) {\n\t\terror = regmap_write(haptics->regmap, DRV2667_PAGE, read_buf);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the page: %d\\n\", error);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn error;\n}\n\nstatic void drv2667_worker(struct work_struct *work)\n{\n\tstruct drv2667_data *haptics = container_of(work, struct drv2667_data, work);\n\tint error;\n\n\tif (haptics->magnitude) {\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\tDRV2667_PAGE, haptics->page);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the page: %d\\n\", error);\n\t\t\treturn;\n\t\t}\n\n\t\terror = regmap_write(haptics->regmap, DRV2667_RAM_AMP,\n\t\t\t\thaptics->magnitude);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the amplitude: %d\\n\", error);\n\t\t\treturn;\n\t\t}\n\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\tDRV2667_PAGE, DRV2667_PAGE_0);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the page: %d\\n\", error);\n\t\t\treturn;\n\t\t}\n\n\t\terror = regmap_write(haptics->regmap,\n\t\t\t\tDRV2667_CTRL_2, DRV2667_GO);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to set the GO bit: %d\\n\", error);\n\t\t}\n\t} else {\n\t\terror = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\n\t\t\t\tDRV2667_GO, 0);\n\t\tif (error) {\n\t\t\tdev_err(&haptics->client->dev,\n\t\t\t\t\"Failed to unset the GO bit: %d\\n\", error);\n\t\t}\n\t}\n}\n\nstatic int drv2667_haptics_play(struct input_dev *input, void *data,\n\t\t\t\tstruct ff_effect *effect)\n{\n\tstruct drv2667_data *haptics = input_get_drvdata(input);\n\n\tif (effect->u.rumble.strong_magnitude > 0)\n\t\thaptics->magnitude = effect->u.rumble.strong_magnitude;\n\telse if (effect->u.rumble.weak_magnitude > 0)\n\t\thaptics->magnitude = effect->u.rumble.weak_magnitude;\n\telse\n\t\thaptics->magnitude = 0;\n\n\tschedule_work(&haptics->work);\n\n\treturn 0;\n}\n\nstatic void drv2667_close(struct input_dev *input)\n{\n\tstruct drv2667_data *haptics = input_get_drvdata(input);\n\tint error;\n\n\tcancel_work_sync(&haptics->work);\n\n\terror = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\n\t\t\t\t   DRV2667_STANDBY, DRV2667_STANDBY);\n\tif (error)\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to enter standby mode: %d\\n\", error);\n}\n\nstatic const struct reg_sequence drv2667_init_regs[] = {\n\t{ DRV2667_CTRL_2, 0 },\n\t{ DRV2667_CTRL_1, DRV2667_25_VPP_GAIN },\n\t{ DRV2667_WV_SEQ_0, 1 },\n\t{ DRV2667_WV_SEQ_1, 0 }\n};\n\nstatic const struct reg_sequence drv2667_page1_init[] = {\n\t{ DRV2667_RAM_HDR_SZ, 0x05 },\n\t{ DRV2667_RAM_START_HI, 0x80 },\n\t{ DRV2667_RAM_START_LO, 0x06 },\n\t{ DRV2667_RAM_STOP_HI, 0x00 },\n\t{ DRV2667_RAM_STOP_LO, 0x09 },\n\t{ DRV2667_RAM_REPEAT_CT, 0 },\n\t{ DRV2667_RAM_DURATION, 0x05 },\n\t{ DRV2667_RAM_ENVELOPE, DRV2667_NO_ENV },\n\t{ DRV2667_RAM_AMP, 0x60 },\n};\n\nstatic int drv2667_init(struct drv2667_data *haptics)\n{\n\tint error;\n\n\t \n\thaptics->frequency = 195;\n\thaptics->page = DRV2667_PAGE_1;\n\n\terror = regmap_register_patch(haptics->regmap,\n\t\t\t\t      drv2667_init_regs,\n\t\t\t\t      ARRAY_SIZE(drv2667_init_regs));\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write init registers: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = regmap_write(haptics->regmap, DRV2667_PAGE, haptics->page);\n\tif (error) {\n\t\tdev_err(&haptics->client->dev, \"Failed to set page: %d\\n\",\n\t\t\terror);\n\t\tgoto error_out;\n\t}\n\n\terror = drv2667_set_waveform_freq(haptics);\n\tif (error)\n\t\tgoto error_page;\n\n\terror = regmap_register_patch(haptics->regmap,\n\t\t\t\t      drv2667_page1_init,\n\t\t\t\t      ARRAY_SIZE(drv2667_page1_init));\n\tif (error) {\n\t\tdev_err(&haptics->client->dev,\n\t\t\t\"Failed to write page registers: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = regmap_write(haptics->regmap, DRV2667_PAGE, DRV2667_PAGE_0);\n\treturn error;\n\nerror_page:\n\tregmap_write(haptics->regmap, DRV2667_PAGE, DRV2667_PAGE_0);\nerror_out:\n\treturn error;\n}\n\nstatic const struct regmap_config drv2667_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = DRV2667_MAX_REG,\n\t.reg_defaults = drv2667_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(drv2667_reg_defs),\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int drv2667_probe(struct i2c_client *client)\n{\n\tstruct drv2667_data *haptics;\n\tint error;\n\n\thaptics = devm_kzalloc(&client->dev, sizeof(*haptics), GFP_KERNEL);\n\tif (!haptics)\n\t\treturn -ENOMEM;\n\n\thaptics->regulator = devm_regulator_get(&client->dev, \"vbat\");\n\tif (IS_ERR(haptics->regulator)) {\n\t\terror = PTR_ERR(haptics->regulator);\n\t\tdev_err(&client->dev,\n\t\t\t\"unable to get regulator, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\thaptics->input_dev = devm_input_allocate_device(&client->dev);\n\tif (!haptics->input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thaptics->input_dev->name = \"drv2667:haptics\";\n\thaptics->input_dev->dev.parent = client->dev.parent;\n\thaptics->input_dev->close = drv2667_close;\n\tinput_set_drvdata(haptics->input_dev, haptics);\n\tinput_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(haptics->input_dev, NULL,\n\t\t\t\t\tdrv2667_haptics_play);\n\tif (error) {\n\t\tdev_err(&client->dev, \"input_ff_create() failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tINIT_WORK(&haptics->work, drv2667_worker);\n\n\thaptics->client = client;\n\ti2c_set_clientdata(client, haptics);\n\n\thaptics->regmap = devm_regmap_init_i2c(client, &drv2667_regmap_config);\n\tif (IS_ERR(haptics->regmap)) {\n\t\terror = PTR_ERR(haptics->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = drv2667_init(haptics);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Device init failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(haptics->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"couldn't register input device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int drv2667_suspend(struct device *dev)\n{\n\tstruct drv2667_data *haptics = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tif (input_device_enabled(haptics->input_dev)) {\n\t\tret = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\n\t\t\t\t\t DRV2667_STANDBY, DRV2667_STANDBY);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set standby mode\\n\");\n\t\t\tregulator_disable(haptics->regulator);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regulator_disable(haptics->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to disable regulator\\n\");\n\t\t\tregmap_update_bits(haptics->regmap,\n\t\t\t\t\t   DRV2667_CTRL_2,\n\t\t\t\t\t   DRV2667_STANDBY, 0);\n\t\t}\n\t}\nout:\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn ret;\n}\n\nstatic int drv2667_resume(struct device *dev)\n{\n\tstruct drv2667_data *haptics = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&haptics->input_dev->mutex);\n\n\tif (input_device_enabled(haptics->input_dev)) {\n\t\tret = regulator_enable(haptics->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\n\t\t\t\t\t DRV2667_STANDBY, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to unset standby mode\\n\");\n\t\t\tregulator_disable(haptics->regulator);\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\nout:\n\tmutex_unlock(&haptics->input_dev->mutex);\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(drv2667_pm_ops, drv2667_suspend, drv2667_resume);\n\nstatic const struct i2c_device_id drv2667_id[] = {\n\t{ \"drv2667\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, drv2667_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id drv2667_of_match[] = {\n\t{ .compatible = \"ti,drv2667\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, drv2667_of_match);\n#endif\n\nstatic struct i2c_driver drv2667_driver = {\n\t.probe\t\t= drv2667_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"drv2667-haptics\",\n\t\t.of_match_table = of_match_ptr(drv2667_of_match),\n\t\t.pm\t= pm_sleep_ptr(&drv2667_pm_ops),\n\t},\n\t.id_table = drv2667_id,\n};\nmodule_i2c_driver(drv2667_driver);\n\nMODULE_DESCRIPTION(\"TI DRV2667 haptics driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}