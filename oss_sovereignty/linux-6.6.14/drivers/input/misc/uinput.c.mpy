{
  "module_name": "uinput.c",
  "hash_id": "7cec34fa1679bcc5a8c1e71205194391b5b7c4240cb18f74dd65c2c87a7504b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/uinput.c",
  "human_readable_source": "\n \n#include <uapi/linux/uinput.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/overflow.h>\n#include <linux/input/mt.h>\n#include \"../input-compat.h\"\n\n#define UINPUT_NAME\t\t\"uinput\"\n#define UINPUT_BUFFER_SIZE\t16\n#define UINPUT_NUM_REQUESTS\t16\n#define UINPUT_TIMESTAMP_ALLOWED_OFFSET_SECS 10\n\nenum uinput_state { UIST_NEW_DEVICE, UIST_SETUP_COMPLETE, UIST_CREATED };\n\nstruct uinput_request {\n\tunsigned int\t\tid;\n\tunsigned int\t\tcode;\t \n\n\tint\t\t\tretval;\n\tstruct completion\tdone;\n\n\tunion {\n\t\tunsigned int\teffect_id;\n\t\tstruct {\n\t\t\tstruct ff_effect *effect;\n\t\t\tstruct ff_effect *old;\n\t\t} upload;\n\t} u;\n};\n\nstruct uinput_device {\n\tstruct input_dev\t*dev;\n\tstruct mutex\t\tmutex;\n\tenum uinput_state\tstate;\n\twait_queue_head_t\twaitq;\n\tunsigned char\t\tready;\n\tunsigned char\t\thead;\n\tunsigned char\t\ttail;\n\tstruct input_event\tbuff[UINPUT_BUFFER_SIZE];\n\tunsigned int\t\tff_effects_max;\n\n\tstruct uinput_request\t*requests[UINPUT_NUM_REQUESTS];\n\twait_queue_head_t\trequests_waitq;\n\tspinlock_t\t\trequests_lock;\n};\n\nstatic int uinput_dev_event(struct input_dev *dev,\n\t\t\t    unsigned int type, unsigned int code, int value)\n{\n\tstruct uinput_device\t*udev = input_get_drvdata(dev);\n\tstruct timespec64\tts;\n\n\tktime_get_ts64(&ts);\n\n\tudev->buff[udev->head] = (struct input_event) {\n\t\t.input_event_sec = ts.tv_sec,\n\t\t.input_event_usec = ts.tv_nsec / NSEC_PER_USEC,\n\t\t.type = type,\n\t\t.code = code,\n\t\t.value = value,\n\t};\n\n\tudev->head = (udev->head + 1) % UINPUT_BUFFER_SIZE;\n\n\twake_up_interruptible(&udev->waitq);\n\n\treturn 0;\n}\n\n \nstatic bool uinput_request_alloc_id(struct uinput_device *udev,\n\t\t\t\t    struct uinput_request *request)\n{\n\tunsigned int id;\n\tbool reserved = false;\n\n\tspin_lock(&udev->requests_lock);\n\n\tfor (id = 0; id < UINPUT_NUM_REQUESTS; id++) {\n\t\tif (!udev->requests[id]) {\n\t\t\trequest->id = id;\n\t\t\tudev->requests[id] = request;\n\t\t\treserved = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&udev->requests_lock);\n\treturn reserved;\n}\n\nstatic struct uinput_request *uinput_request_find(struct uinput_device *udev,\n\t\t\t\t\t\t  unsigned int id)\n{\n\t \n\tif (id >= UINPUT_NUM_REQUESTS)\n\t\treturn NULL;\n\n\treturn udev->requests[id];\n}\n\nstatic int uinput_request_reserve_slot(struct uinput_device *udev,\n\t\t\t\t       struct uinput_request *request)\n{\n\t \n\treturn wait_event_interruptible(udev->requests_waitq,\n\t\t\t\t\tuinput_request_alloc_id(udev, request));\n}\n\nstatic void uinput_request_release_slot(struct uinput_device *udev,\n\t\t\t\t\tunsigned int id)\n{\n\t \n\tspin_lock(&udev->requests_lock);\n\tudev->requests[id] = NULL;\n\tspin_unlock(&udev->requests_lock);\n\n\twake_up(&udev->requests_waitq);\n}\n\nstatic int uinput_request_send(struct uinput_device *udev,\n\t\t\t       struct uinput_request *request)\n{\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&udev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (udev->state != UIST_CREATED) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tinit_completion(&request->done);\n\n\t \n\tuinput_dev_event(udev->dev, EV_UINPUT, request->code, request->id);\n\n out:\n\tmutex_unlock(&udev->mutex);\n\treturn retval;\n}\n\nstatic int uinput_request_submit(struct uinput_device *udev,\n\t\t\t\t struct uinput_request *request)\n{\n\tint retval;\n\n\tretval = uinput_request_reserve_slot(udev, request);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = uinput_request_send(udev, request);\n\tif (retval)\n\t\tgoto out;\n\n\tif (!wait_for_completion_timeout(&request->done, 30 * HZ)) {\n\t\tretval = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tretval = request->retval;\n\n out:\n\tuinput_request_release_slot(udev, request->id);\n\treturn retval;\n}\n\n \nstatic void uinput_flush_requests(struct uinput_device *udev)\n{\n\tstruct uinput_request *request;\n\tint i;\n\n\tspin_lock(&udev->requests_lock);\n\n\tfor (i = 0; i < UINPUT_NUM_REQUESTS; i++) {\n\t\trequest = udev->requests[i];\n\t\tif (request) {\n\t\t\trequest->retval = -ENODEV;\n\t\t\tcomplete(&request->done);\n\t\t}\n\t}\n\n\tspin_unlock(&udev->requests_lock);\n}\n\nstatic void uinput_dev_set_gain(struct input_dev *dev, u16 gain)\n{\n\tuinput_dev_event(dev, EV_FF, FF_GAIN, gain);\n}\n\nstatic void uinput_dev_set_autocenter(struct input_dev *dev, u16 magnitude)\n{\n\tuinput_dev_event(dev, EV_FF, FF_AUTOCENTER, magnitude);\n}\n\nstatic int uinput_dev_playback(struct input_dev *dev, int effect_id, int value)\n{\n\treturn uinput_dev_event(dev, EV_FF, effect_id, value);\n}\n\nstatic int uinput_dev_upload_effect(struct input_dev *dev,\n\t\t\t\t    struct ff_effect *effect,\n\t\t\t\t    struct ff_effect *old)\n{\n\tstruct uinput_device *udev = input_get_drvdata(dev);\n\tstruct uinput_request request;\n\n\t \n\tif (effect->type == FF_PERIODIC &&\n\t\t\teffect->u.periodic.waveform == FF_CUSTOM)\n\t\treturn -EINVAL;\n\n\trequest.code = UI_FF_UPLOAD;\n\trequest.u.upload.effect = effect;\n\trequest.u.upload.old = old;\n\n\treturn uinput_request_submit(udev, &request);\n}\n\nstatic int uinput_dev_erase_effect(struct input_dev *dev, int effect_id)\n{\n\tstruct uinput_device *udev = input_get_drvdata(dev);\n\tstruct uinput_request request;\n\n\tif (!test_bit(EV_FF, dev->evbit))\n\t\treturn -ENOSYS;\n\n\trequest.code = UI_FF_ERASE;\n\trequest.u.effect_id = effect_id;\n\n\treturn uinput_request_submit(udev, &request);\n}\n\nstatic int uinput_dev_flush(struct input_dev *dev, struct file *file)\n{\n\t \n\treturn file ? input_ff_flush(dev, file) : 0;\n}\n\nstatic void uinput_destroy_device(struct uinput_device *udev)\n{\n\tconst char *name, *phys;\n\tstruct input_dev *dev = udev->dev;\n\tenum uinput_state old_state = udev->state;\n\n\tudev->state = UIST_NEW_DEVICE;\n\n\tif (dev) {\n\t\tname = dev->name;\n\t\tphys = dev->phys;\n\t\tif (old_state == UIST_CREATED) {\n\t\t\tuinput_flush_requests(udev);\n\t\t\tinput_unregister_device(dev);\n\t\t} else {\n\t\t\tinput_free_device(dev);\n\t\t}\n\t\tkfree(name);\n\t\tkfree(phys);\n\t\tudev->dev = NULL;\n\t}\n}\n\nstatic int uinput_create_device(struct uinput_device *udev)\n{\n\tstruct input_dev *dev = udev->dev;\n\tint error, nslot;\n\n\tif (udev->state != UIST_SETUP_COMPLETE) {\n\t\tprintk(KERN_DEBUG \"%s: write device info first\\n\", UINPUT_NAME);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_bit(EV_ABS, dev->evbit)) {\n\t\tinput_alloc_absinfo(dev);\n\t\tif (!dev->absinfo) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tif (test_bit(ABS_MT_SLOT, dev->absbit)) {\n\t\t\tnslot = input_abs_get_max(dev, ABS_MT_SLOT) + 1;\n\t\t\terror = input_mt_init_slots(dev, nslot, 0);\n\t\t\tif (error)\n\t\t\t\tgoto fail1;\n\t\t} else if (test_bit(ABS_MT_POSITION_X, dev->absbit)) {\n\t\t\tinput_set_events_per_packet(dev, 60);\n\t\t}\n\t}\n\n\tif (test_bit(EV_FF, dev->evbit) && !udev->ff_effects_max) {\n\t\tprintk(KERN_DEBUG \"%s: ff_effects_max should be non-zero when FF_BIT is set\\n\",\n\t\t\tUINPUT_NAME);\n\t\terror = -EINVAL;\n\t\tgoto fail1;\n\t}\n\n\tif (udev->ff_effects_max) {\n\t\terror = input_ff_create(dev, udev->ff_effects_max);\n\t\tif (error)\n\t\t\tgoto fail1;\n\n\t\tdev->ff->upload = uinput_dev_upload_effect;\n\t\tdev->ff->erase = uinput_dev_erase_effect;\n\t\tdev->ff->playback = uinput_dev_playback;\n\t\tdev->ff->set_gain = uinput_dev_set_gain;\n\t\tdev->ff->set_autocenter = uinput_dev_set_autocenter;\n\t\t \n\t\tdev->flush = uinput_dev_flush;\n\t}\n\n\tdev->event = uinput_dev_event;\n\n\tinput_set_drvdata(udev->dev, udev);\n\n\terror = input_register_device(udev->dev);\n\tif (error)\n\t\tgoto fail2;\n\n\tudev->state = UIST_CREATED;\n\n\treturn 0;\n\n fail2:\tinput_ff_destroy(dev);\n fail1: uinput_destroy_device(udev);\n\treturn error;\n}\n\nstatic int uinput_open(struct inode *inode, struct file *file)\n{\n\tstruct uinput_device *newdev;\n\n\tnewdev = kzalloc(sizeof(struct uinput_device), GFP_KERNEL);\n\tif (!newdev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&newdev->mutex);\n\tspin_lock_init(&newdev->requests_lock);\n\tinit_waitqueue_head(&newdev->requests_waitq);\n\tinit_waitqueue_head(&newdev->waitq);\n\tnewdev->state = UIST_NEW_DEVICE;\n\n\tfile->private_data = newdev;\n\tstream_open(inode, file);\n\n\treturn 0;\n}\n\nstatic int uinput_validate_absinfo(struct input_dev *dev, unsigned int code,\n\t\t\t\t   const struct input_absinfo *abs)\n{\n\tint min, max, range;\n\n\tmin = abs->minimum;\n\tmax = abs->maximum;\n\n\tif ((min != 0 || max != 0) && max < min) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: invalid abs[%02x] min:%d max:%d\\n\",\n\t\t       UINPUT_NAME, code, min, max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!check_sub_overflow(max, min, &range) && abs->flat > range) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: abs_flat #%02x out of range: %d (min:%d/max:%d)\\n\",\n\t\t       UINPUT_NAME, code, abs->flat, min, max);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int uinput_validate_absbits(struct input_dev *dev)\n{\n\tunsigned int cnt;\n\tint error;\n\n\tif (!test_bit(EV_ABS, dev->evbit))\n\t\treturn 0;\n\n\t \n\n\tfor_each_set_bit(cnt, dev->absbit, ABS_CNT) {\n\t\tif (!dev->absinfo)\n\t\t\treturn -EINVAL;\n\n\t\terror = uinput_validate_absinfo(dev, cnt, &dev->absinfo[cnt]);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int uinput_dev_setup(struct uinput_device *udev,\n\t\t\t    struct uinput_setup __user *arg)\n{\n\tstruct uinput_setup setup;\n\tstruct input_dev *dev;\n\n\tif (udev->state == UIST_CREATED)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&setup, arg, sizeof(setup)))\n\t\treturn -EFAULT;\n\n\tif (!setup.name[0])\n\t\treturn -EINVAL;\n\n\tdev = udev->dev;\n\tdev->id = setup.id;\n\tudev->ff_effects_max = setup.ff_effects_max;\n\n\tkfree(dev->name);\n\tdev->name = kstrndup(setup.name, UINPUT_MAX_NAME_SIZE, GFP_KERNEL);\n\tif (!dev->name)\n\t\treturn -ENOMEM;\n\n\tudev->state = UIST_SETUP_COMPLETE;\n\treturn 0;\n}\n\nstatic int uinput_abs_setup(struct uinput_device *udev,\n\t\t\t    struct uinput_setup __user *arg, size_t size)\n{\n\tstruct uinput_abs_setup setup = {};\n\tstruct input_dev *dev;\n\tint error;\n\n\tif (size > sizeof(setup))\n\t\treturn -E2BIG;\n\n\tif (udev->state == UIST_CREATED)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&setup, arg, size))\n\t\treturn -EFAULT;\n\n\tif (setup.code > ABS_MAX)\n\t\treturn -ERANGE;\n\n\tdev = udev->dev;\n\n\terror = uinput_validate_absinfo(dev, setup.code, &setup.absinfo);\n\tif (error)\n\t\treturn error;\n\n\tinput_alloc_absinfo(dev);\n\tif (!dev->absinfo)\n\t\treturn -ENOMEM;\n\n\tset_bit(setup.code, dev->absbit);\n\tdev->absinfo[setup.code] = setup.absinfo;\n\treturn 0;\n}\n\n \nstatic int uinput_setup_device_legacy(struct uinput_device *udev,\n\t\t\t\t      const char __user *buffer, size_t count)\n{\n\tstruct uinput_user_dev\t*user_dev;\n\tstruct input_dev\t*dev;\n\tint\t\t\ti;\n\tint\t\t\tretval;\n\n\tif (count != sizeof(struct uinput_user_dev))\n\t\treturn -EINVAL;\n\n\tif (!udev->dev) {\n\t\tudev->dev = input_allocate_device();\n\t\tif (!udev->dev)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdev = udev->dev;\n\n\tuser_dev = memdup_user(buffer, sizeof(struct uinput_user_dev));\n\tif (IS_ERR(user_dev))\n\t\treturn PTR_ERR(user_dev);\n\n\tudev->ff_effects_max = user_dev->ff_effects_max;\n\n\t \n\tif (!user_dev->name[0]) {\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tkfree(dev->name);\n\tdev->name = kstrndup(user_dev->name, UINPUT_MAX_NAME_SIZE,\n\t\t\t     GFP_KERNEL);\n\tif (!dev->name) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdev->id.bustype\t= user_dev->id.bustype;\n\tdev->id.vendor\t= user_dev->id.vendor;\n\tdev->id.product\t= user_dev->id.product;\n\tdev->id.version\t= user_dev->id.version;\n\n\tfor (i = 0; i < ABS_CNT; i++) {\n\t\tinput_abs_set_max(dev, i, user_dev->absmax[i]);\n\t\tinput_abs_set_min(dev, i, user_dev->absmin[i]);\n\t\tinput_abs_set_fuzz(dev, i, user_dev->absfuzz[i]);\n\t\tinput_abs_set_flat(dev, i, user_dev->absflat[i]);\n\t}\n\n\tretval = uinput_validate_absbits(dev);\n\tif (retval < 0)\n\t\tgoto exit;\n\n\tudev->state = UIST_SETUP_COMPLETE;\n\tretval = count;\n\n exit:\n\tkfree(user_dev);\n\treturn retval;\n}\n\n \nstatic bool is_valid_timestamp(const ktime_t timestamp)\n{\n\tktime_t zero_time;\n\tktime_t current_time;\n\tktime_t min_time;\n\tktime_t offset;\n\n\tzero_time = ktime_set(0, 0);\n\tif (ktime_compare(zero_time, timestamp) >= 0)\n\t\treturn false;\n\n\tcurrent_time = ktime_get();\n\toffset = ktime_set(UINPUT_TIMESTAMP_ALLOWED_OFFSET_SECS, 0);\n\tmin_time = ktime_sub(current_time, offset);\n\n\tif (ktime_after(min_time, timestamp) || ktime_after(timestamp, current_time))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic ssize_t uinput_inject_events(struct uinput_device *udev,\n\t\t\t\t    const char __user *buffer, size_t count)\n{\n\tstruct input_event ev;\n\tsize_t bytes = 0;\n\tktime_t timestamp;\n\n\tif (count != 0 && count < input_event_size())\n\t\treturn -EINVAL;\n\n\twhile (bytes + input_event_size() <= count) {\n\t\t \n\t\tif (input_event_from_user(buffer + bytes, &ev))\n\t\t\treturn -EFAULT;\n\n\t\ttimestamp = ktime_set(ev.input_event_sec, ev.input_event_usec * NSEC_PER_USEC);\n\t\tif (is_valid_timestamp(timestamp))\n\t\t\tinput_set_timestamp(udev->dev, timestamp);\n\n\t\tinput_event(udev->dev, ev.type, ev.code, ev.value);\n\t\tbytes += input_event_size();\n\t\tcond_resched();\n\t}\n\n\treturn bytes;\n}\n\nstatic ssize_t uinput_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct uinput_device *udev = file->private_data;\n\tint retval;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tretval = mutex_lock_interruptible(&udev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = udev->state == UIST_CREATED ?\n\t\t\tuinput_inject_events(udev, buffer, count) :\n\t\t\tuinput_setup_device_legacy(udev, buffer, count);\n\n\tmutex_unlock(&udev->mutex);\n\n\treturn retval;\n}\n\nstatic bool uinput_fetch_next_event(struct uinput_device *udev,\n\t\t\t\t    struct input_event *event)\n{\n\tbool have_event;\n\n\tspin_lock_irq(&udev->dev->event_lock);\n\n\thave_event = udev->head != udev->tail;\n\tif (have_event) {\n\t\t*event = udev->buff[udev->tail];\n\t\tudev->tail = (udev->tail + 1) % UINPUT_BUFFER_SIZE;\n\t}\n\n\tspin_unlock_irq(&udev->dev->event_lock);\n\n\treturn have_event;\n}\n\nstatic ssize_t uinput_events_to_user(struct uinput_device *udev,\n\t\t\t\t     char __user *buffer, size_t count)\n{\n\tstruct input_event event;\n\tsize_t read = 0;\n\n\twhile (read + input_event_size() <= count &&\n\t       uinput_fetch_next_event(udev, &event)) {\n\n\t\tif (input_event_to_user(buffer + read, &event))\n\t\t\treturn -EFAULT;\n\n\t\tread += input_event_size();\n\t}\n\n\treturn read;\n}\n\nstatic ssize_t uinput_read(struct file *file, char __user *buffer,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct uinput_device *udev = file->private_data;\n\tssize_t retval;\n\n\tif (count != 0 && count < input_event_size())\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tretval = mutex_lock_interruptible(&udev->mutex);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (udev->state != UIST_CREATED)\n\t\t\tretval = -ENODEV;\n\t\telse if (udev->head == udev->tail &&\n\t\t\t (file->f_flags & O_NONBLOCK))\n\t\t\tretval = -EAGAIN;\n\t\telse\n\t\t\tretval = uinput_events_to_user(udev, buffer, count);\n\n\t\tmutex_unlock(&udev->mutex);\n\n\t\tif (retval || count == 0)\n\t\t\tbreak;\n\n\t\tif (!(file->f_flags & O_NONBLOCK))\n\t\t\tretval = wait_event_interruptible(udev->waitq,\n\t\t\t\t\t\t  udev->head != udev->tail ||\n\t\t\t\t\t\t  udev->state != UIST_CREATED);\n\t} while (retval == 0);\n\n\treturn retval;\n}\n\nstatic __poll_t uinput_poll(struct file *file, poll_table *wait)\n{\n\tstruct uinput_device *udev = file->private_data;\n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;  \n\n\tpoll_wait(file, &udev->waitq, wait);\n\n\tif (udev->head != udev->tail)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic int uinput_release(struct inode *inode, struct file *file)\n{\n\tstruct uinput_device *udev = file->private_data;\n\n\tuinput_destroy_device(udev);\n\tkfree(udev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nstruct uinput_ff_upload_compat {\n\t__u32\t\t\trequest_id;\n\t__s32\t\t\tretval;\n\tstruct ff_effect_compat\teffect;\n\tstruct ff_effect_compat\told;\n};\n\nstatic int uinput_ff_upload_to_user(char __user *buffer,\n\t\t\t\t    const struct uinput_ff_upload *ff_up)\n{\n\tif (in_compat_syscall()) {\n\t\tstruct uinput_ff_upload_compat ff_up_compat;\n\n\t\tff_up_compat.request_id = ff_up->request_id;\n\t\tff_up_compat.retval = ff_up->retval;\n\t\t \n\t\tmemcpy(&ff_up_compat.effect, &ff_up->effect,\n\t\t\tsizeof(struct ff_effect_compat));\n\t\tmemcpy(&ff_up_compat.old, &ff_up->old,\n\t\t\tsizeof(struct ff_effect_compat));\n\n\t\tif (copy_to_user(buffer, &ff_up_compat,\n\t\t\t\t sizeof(struct uinput_ff_upload_compat)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(buffer, ff_up,\n\t\t\t\t sizeof(struct uinput_ff_upload)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int uinput_ff_upload_from_user(const char __user *buffer,\n\t\t\t\t      struct uinput_ff_upload *ff_up)\n{\n\tif (in_compat_syscall()) {\n\t\tstruct uinput_ff_upload_compat ff_up_compat;\n\n\t\tif (copy_from_user(&ff_up_compat, buffer,\n\t\t\t\t   sizeof(struct uinput_ff_upload_compat)))\n\t\t\treturn -EFAULT;\n\n\t\tff_up->request_id = ff_up_compat.request_id;\n\t\tff_up->retval = ff_up_compat.retval;\n\t\tmemcpy(&ff_up->effect, &ff_up_compat.effect,\n\t\t\tsizeof(struct ff_effect_compat));\n\t\tmemcpy(&ff_up->old, &ff_up_compat.old,\n\t\t\tsizeof(struct ff_effect_compat));\n\n\t} else {\n\t\tif (copy_from_user(ff_up, buffer,\n\t\t\t\t   sizeof(struct uinput_ff_upload)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#else\n\nstatic int uinput_ff_upload_to_user(char __user *buffer,\n\t\t\t\t    const struct uinput_ff_upload *ff_up)\n{\n\tif (copy_to_user(buffer, ff_up, sizeof(struct uinput_ff_upload)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int uinput_ff_upload_from_user(const char __user *buffer,\n\t\t\t\t      struct uinput_ff_upload *ff_up)\n{\n\tif (copy_from_user(ff_up, buffer, sizeof(struct uinput_ff_upload)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#endif\n\n#define uinput_set_bit(_arg, _bit, _max)\t\t\\\n({\t\t\t\t\t\t\t\\\n\tint __ret = 0;\t\t\t\t\t\\\n\tif (udev->state == UIST_CREATED)\t\t\\\n\t\t__ret =  -EINVAL;\t\t\t\\\n\telse if ((_arg) > (_max))\t\t\t\\\n\t\t__ret = -EINVAL;\t\t\t\\\n\telse set_bit((_arg), udev->dev->_bit);\t\t\\\n\t__ret;\t\t\t\t\t\t\\\n})\n\nstatic int uinput_str_to_user(void __user *dest, const char *str,\n\t\t\t      unsigned int maxlen)\n{\n\tchar __user *p = dest;\n\tint len, ret;\n\n\tif (!str)\n\t\treturn -ENOENT;\n\n\tif (maxlen == 0)\n\t\treturn -EINVAL;\n\n\tlen = strlen(str) + 1;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\tret = copy_to_user(p, str, len);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t \n\tret = put_user(0, p + len - 1);\n\treturn ret ? -EFAULT : len;\n}\n\nstatic long uinput_ioctl_handler(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg, void __user *p)\n{\n\tint\t\t\tretval;\n\tstruct uinput_device\t*udev = file->private_data;\n\tstruct uinput_ff_upload ff_up;\n\tstruct uinput_ff_erase  ff_erase;\n\tstruct uinput_request   *req;\n\tchar\t\t\t*phys;\n\tconst char\t\t*name;\n\tunsigned int\t\tsize;\n\n\tretval = mutex_lock_interruptible(&udev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!udev->dev) {\n\t\tudev->dev = input_allocate_device();\n\t\tif (!udev->dev) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase UI_GET_VERSION:\n\t\tif (put_user(UINPUT_VERSION, (unsigned int __user *)p))\n\t\t\tretval = -EFAULT;\n\t\tgoto out;\n\n\tcase UI_DEV_CREATE:\n\t\tretval = uinput_create_device(udev);\n\t\tgoto out;\n\n\tcase UI_DEV_DESTROY:\n\t\tuinput_destroy_device(udev);\n\t\tgoto out;\n\n\tcase UI_DEV_SETUP:\n\t\tretval = uinput_dev_setup(udev, p);\n\t\tgoto out;\n\n\t \n\n\tcase UI_SET_EVBIT:\n\t\tretval = uinput_set_bit(arg, evbit, EV_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_KEYBIT:\n\t\tretval = uinput_set_bit(arg, keybit, KEY_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_RELBIT:\n\t\tretval = uinput_set_bit(arg, relbit, REL_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_ABSBIT:\n\t\tretval = uinput_set_bit(arg, absbit, ABS_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_MSCBIT:\n\t\tretval = uinput_set_bit(arg, mscbit, MSC_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_LEDBIT:\n\t\tretval = uinput_set_bit(arg, ledbit, LED_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_SNDBIT:\n\t\tretval = uinput_set_bit(arg, sndbit, SND_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_FFBIT:\n\t\tretval = uinput_set_bit(arg, ffbit, FF_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_SWBIT:\n\t\tretval = uinput_set_bit(arg, swbit, SW_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_PROPBIT:\n\t\tretval = uinput_set_bit(arg, propbit, INPUT_PROP_MAX);\n\t\tgoto out;\n\n\tcase UI_SET_PHYS:\n\t\tif (udev->state == UIST_CREATED) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tphys = strndup_user(p, 1024);\n\t\tif (IS_ERR(phys)) {\n\t\t\tretval = PTR_ERR(phys);\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree(udev->dev->phys);\n\t\tudev->dev->phys = phys;\n\t\tgoto out;\n\n\tcase UI_BEGIN_FF_UPLOAD:\n\t\tretval = uinput_ff_upload_from_user(p, &ff_up);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\treq = uinput_request_find(udev, ff_up.request_id);\n\t\tif (!req || req->code != UI_FF_UPLOAD ||\n\t\t    !req->u.upload.effect) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tff_up.retval = 0;\n\t\tff_up.effect = *req->u.upload.effect;\n\t\tif (req->u.upload.old)\n\t\t\tff_up.old = *req->u.upload.old;\n\t\telse\n\t\t\tmemset(&ff_up.old, 0, sizeof(struct ff_effect));\n\n\t\tretval = uinput_ff_upload_to_user(p, &ff_up);\n\t\tgoto out;\n\n\tcase UI_BEGIN_FF_ERASE:\n\t\tif (copy_from_user(&ff_erase, p, sizeof(ff_erase))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq = uinput_request_find(udev, ff_erase.request_id);\n\t\tif (!req || req->code != UI_FF_ERASE) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tff_erase.retval = 0;\n\t\tff_erase.effect_id = req->u.effect_id;\n\t\tif (copy_to_user(p, &ff_erase, sizeof(ff_erase))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out;\n\n\tcase UI_END_FF_UPLOAD:\n\t\tretval = uinput_ff_upload_from_user(p, &ff_up);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\treq = uinput_request_find(udev, ff_up.request_id);\n\t\tif (!req || req->code != UI_FF_UPLOAD ||\n\t\t    !req->u.upload.effect) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq->retval = ff_up.retval;\n\t\tcomplete(&req->done);\n\t\tgoto out;\n\n\tcase UI_END_FF_ERASE:\n\t\tif (copy_from_user(&ff_erase, p, sizeof(ff_erase))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq = uinput_request_find(udev, ff_erase.request_id);\n\t\tif (!req || req->code != UI_FF_ERASE) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq->retval = ff_erase.retval;\n\t\tcomplete(&req->done);\n\t\tgoto out;\n\t}\n\n\tsize = _IOC_SIZE(cmd);\n\n\t \n\tswitch (cmd & ~IOCSIZE_MASK) {\n\tcase UI_GET_SYSNAME(0):\n\t\tif (udev->state != UIST_CREATED) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tname = dev_name(&udev->dev->dev);\n\t\tretval = uinput_str_to_user(p, name, size);\n\t\tgoto out;\n\n\tcase UI_ABS_SETUP & ~IOCSIZE_MASK:\n\t\tretval = uinput_abs_setup(udev, p, size);\n\t\tgoto out;\n\t}\n\n\tretval = -EINVAL;\n out:\n\tmutex_unlock(&udev->mutex);\n\treturn retval;\n}\n\nstatic long uinput_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn uinput_ioctl_handler(file, cmd, arg, (void __user *)arg);\n}\n\n#ifdef CONFIG_COMPAT\n\n \n#define UI_SET_PHYS_COMPAT\t\t\\\n\t_IOW(UINPUT_IOCTL_BASE, 108, compat_uptr_t)\n#define UI_BEGIN_FF_UPLOAD_COMPAT\t\\\n\t_IOWR(UINPUT_IOCTL_BASE, 200, struct uinput_ff_upload_compat)\n#define UI_END_FF_UPLOAD_COMPAT\t\t\\\n\t_IOW(UINPUT_IOCTL_BASE, 201, struct uinput_ff_upload_compat)\n\nstatic long uinput_compat_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase UI_SET_PHYS_COMPAT:\n\t\tcmd = UI_SET_PHYS;\n\t\tbreak;\n\tcase UI_BEGIN_FF_UPLOAD_COMPAT:\n\t\tcmd = UI_BEGIN_FF_UPLOAD;\n\t\tbreak;\n\tcase UI_END_FF_UPLOAD_COMPAT:\n\t\tcmd = UI_END_FF_UPLOAD;\n\t\tbreak;\n\t}\n\n\treturn uinput_ioctl_handler(file, cmd, arg, compat_ptr(arg));\n}\n#endif\n\nstatic const struct file_operations uinput_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uinput_open,\n\t.release\t= uinput_release,\n\t.read\t\t= uinput_read,\n\t.write\t\t= uinput_write,\n\t.poll\t\t= uinput_poll,\n\t.unlocked_ioctl\t= uinput_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= uinput_compat_ioctl,\n#endif\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice uinput_misc = {\n\t.fops\t\t= &uinput_fops,\n\t.minor\t\t= UINPUT_MINOR,\n\t.name\t\t= UINPUT_NAME,\n};\nmodule_misc_device(uinput_misc);\n\nMODULE_ALIAS_MISCDEV(UINPUT_MINOR);\nMODULE_ALIAS(\"devname:\" UINPUT_NAME);\n\nMODULE_AUTHOR(\"Aristeu Sergio Rozanski Filho\");\nMODULE_DESCRIPTION(\"User level driver support for input subsystem\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}