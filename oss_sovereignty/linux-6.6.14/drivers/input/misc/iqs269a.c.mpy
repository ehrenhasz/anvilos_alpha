{
  "module_name": "iqs269a.c",
  "hash_id": "a2544e7d669e4da6c379f9c04ab28962a4c2f9b3b2628857ef3a2ef533760677",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/iqs269a.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define IQS269_VER_INFO\t\t\t\t0x00\n#define IQS269_VER_INFO_PROD_NUM\t\t0x4F\n\n#define IQS269_SYS_FLAGS\t\t\t0x02\n#define IQS269_SYS_FLAGS_SHOW_RESET\t\tBIT(15)\n#define IQS269_SYS_FLAGS_PWR_MODE_MASK\t\tGENMASK(12, 11)\n#define IQS269_SYS_FLAGS_PWR_MODE_SHIFT\t\t11\n#define IQS269_SYS_FLAGS_IN_ATI\t\t\tBIT(10)\n\n#define IQS269_CHx_COUNTS\t\t\t0x08\n\n#define IQS269_SLIDER_X\t\t\t\t0x30\n\n#define IQS269_CAL_DATA_A\t\t\t0x35\n#define IQS269_CAL_DATA_A_HALL_BIN_L_MASK\tGENMASK(15, 12)\n#define IQS269_CAL_DATA_A_HALL_BIN_L_SHIFT\t12\n#define IQS269_CAL_DATA_A_HALL_BIN_R_MASK\tGENMASK(11, 8)\n#define IQS269_CAL_DATA_A_HALL_BIN_R_SHIFT\t8\n\n#define IQS269_SYS_SETTINGS\t\t\t0x80\n#define IQS269_SYS_SETTINGS_CLK_DIV\t\tBIT(15)\n#define IQS269_SYS_SETTINGS_ULP_AUTO\t\tBIT(14)\n#define IQS269_SYS_SETTINGS_DIS_AUTO\t\tBIT(13)\n#define IQS269_SYS_SETTINGS_PWR_MODE_MASK\tGENMASK(12, 11)\n#define IQS269_SYS_SETTINGS_PWR_MODE_SHIFT\t11\n#define IQS269_SYS_SETTINGS_PWR_MODE_MAX\t3\n#define IQS269_SYS_SETTINGS_ULP_UPDATE_MASK\tGENMASK(10, 8)\n#define IQS269_SYS_SETTINGS_ULP_UPDATE_SHIFT\t8\n#define IQS269_SYS_SETTINGS_ULP_UPDATE_MAX\t7\n#define IQS269_SYS_SETTINGS_RESEED_OFFSET\tBIT(6)\n#define IQS269_SYS_SETTINGS_EVENT_MODE\t\tBIT(5)\n#define IQS269_SYS_SETTINGS_EVENT_MODE_LP\tBIT(4)\n#define IQS269_SYS_SETTINGS_REDO_ATI\t\tBIT(2)\n#define IQS269_SYS_SETTINGS_ACK_RESET\t\tBIT(0)\n\n#define IQS269_FILT_STR_LP_LTA_MASK\t\tGENMASK(7, 6)\n#define IQS269_FILT_STR_LP_LTA_SHIFT\t\t6\n#define IQS269_FILT_STR_LP_CNT_MASK\t\tGENMASK(5, 4)\n#define IQS269_FILT_STR_LP_CNT_SHIFT\t\t4\n#define IQS269_FILT_STR_NP_LTA_MASK\t\tGENMASK(3, 2)\n#define IQS269_FILT_STR_NP_LTA_SHIFT\t\t2\n#define IQS269_FILT_STR_NP_CNT_MASK\t\tGENMASK(1, 0)\n#define IQS269_FILT_STR_MAX\t\t\t3\n\n#define IQS269_EVENT_MASK_SYS\t\t\tBIT(6)\n#define IQS269_EVENT_MASK_DEEP\t\t\tBIT(2)\n#define IQS269_EVENT_MASK_TOUCH\t\t\tBIT(1)\n#define IQS269_EVENT_MASK_PROX\t\t\tBIT(0)\n\n#define IQS269_RATE_NP_MS_MAX\t\t\t255\n#define IQS269_RATE_LP_MS_MAX\t\t\t255\n#define IQS269_RATE_ULP_MS_MAX\t\t\t4080\n#define IQS269_TIMEOUT_PWR_MS_MAX\t\t130560\n#define IQS269_TIMEOUT_LTA_MS_MAX\t\t130560\n\n#define IQS269_MISC_A_ATI_BAND_DISABLE\t\tBIT(15)\n#define IQS269_MISC_A_ATI_LP_ONLY\t\tBIT(14)\n#define IQS269_MISC_A_ATI_BAND_TIGHTEN\t\tBIT(13)\n#define IQS269_MISC_A_FILT_DISABLE\t\tBIT(12)\n#define IQS269_MISC_A_GPIO3_SELECT_MASK\t\tGENMASK(10, 8)\n#define IQS269_MISC_A_GPIO3_SELECT_SHIFT\t8\n#define IQS269_MISC_A_DUAL_DIR\t\t\tBIT(6)\n#define IQS269_MISC_A_TX_FREQ_MASK\t\tGENMASK(5, 4)\n#define IQS269_MISC_A_TX_FREQ_SHIFT\t\t4\n#define IQS269_MISC_A_TX_FREQ_MAX\t\t3\n#define IQS269_MISC_A_GLOBAL_CAP_SIZE\t\tBIT(0)\n\n#define IQS269_MISC_B_RESEED_UI_SEL_MASK\tGENMASK(7, 6)\n#define IQS269_MISC_B_RESEED_UI_SEL_SHIFT\t6\n#define IQS269_MISC_B_RESEED_UI_SEL_MAX\t\t3\n#define IQS269_MISC_B_TRACKING_UI_ENABLE\tBIT(4)\n#define IQS269_MISC_B_FILT_STR_SLIDER\t\tGENMASK(1, 0)\n\n#define IQS269_CHx_ENG_A_MEAS_CAP_SIZE\t\tBIT(15)\n#define IQS269_CHx_ENG_A_RX_GND_INACTIVE\tBIT(13)\n#define IQS269_CHx_ENG_A_LOCAL_CAP_SIZE\t\tBIT(12)\n#define IQS269_CHx_ENG_A_ATI_MODE_MASK\t\tGENMASK(9, 8)\n#define IQS269_CHx_ENG_A_ATI_MODE_SHIFT\t\t8\n#define IQS269_CHx_ENG_A_ATI_MODE_MAX\t\t3\n#define IQS269_CHx_ENG_A_INV_LOGIC\t\tBIT(7)\n#define IQS269_CHx_ENG_A_PROJ_BIAS_MASK\t\tGENMASK(6, 5)\n#define IQS269_CHx_ENG_A_PROJ_BIAS_SHIFT\t5\n#define IQS269_CHx_ENG_A_PROJ_BIAS_MAX\t\t3\n#define IQS269_CHx_ENG_A_SENSE_MODE_MASK\tGENMASK(3, 0)\n#define IQS269_CHx_ENG_A_SENSE_MODE_MAX\t\t15\n\n#define IQS269_CHx_ENG_B_LOCAL_CAP_ENABLE\tBIT(13)\n#define IQS269_CHx_ENG_B_SENSE_FREQ_MASK\tGENMASK(10, 9)\n#define IQS269_CHx_ENG_B_SENSE_FREQ_SHIFT\t9\n#define IQS269_CHx_ENG_B_SENSE_FREQ_MAX\t\t3\n#define IQS269_CHx_ENG_B_STATIC_ENABLE\t\tBIT(8)\n#define IQS269_CHx_ENG_B_ATI_BASE_MASK\t\tGENMASK(7, 6)\n#define IQS269_CHx_ENG_B_ATI_BASE_75\t\t0x00\n#define IQS269_CHx_ENG_B_ATI_BASE_100\t\t0x40\n#define IQS269_CHx_ENG_B_ATI_BASE_150\t\t0x80\n#define IQS269_CHx_ENG_B_ATI_BASE_200\t\t0xC0\n#define IQS269_CHx_ENG_B_ATI_TARGET_MASK\tGENMASK(5, 0)\n#define IQS269_CHx_ENG_B_ATI_TARGET_MAX\t\t2016\n\n#define IQS269_CHx_WEIGHT_MAX\t\t\t255\n#define IQS269_CHx_THRESH_MAX\t\t\t255\n#define IQS269_CHx_HYST_DEEP_MASK\t\tGENMASK(7, 4)\n#define IQS269_CHx_HYST_DEEP_SHIFT\t\t4\n#define IQS269_CHx_HYST_TOUCH_MASK\t\tGENMASK(3, 0)\n#define IQS269_CHx_HYST_MAX\t\t\t15\n\n#define IQS269_CHx_HALL_INACTIVE\t\t6\n#define IQS269_CHx_HALL_ACTIVE\t\t\t7\n\n#define IQS269_HALL_PAD_R\t\t\tBIT(0)\n#define IQS269_HALL_PAD_L\t\t\tBIT(1)\n#define IQS269_HALL_PAD_INV\t\t\tBIT(6)\n\n#define IQS269_HALL_UI\t\t\t\t0xF5\n#define IQS269_HALL_UI_ENABLE\t\t\tBIT(15)\n\n#define IQS269_MAX_REG\t\t\t\t0xFF\n\n#define IQS269_NUM_CH\t\t\t\t8\n#define IQS269_NUM_SL\t\t\t\t2\n\n#define iqs269_irq_wait()\t\t\tusleep_range(200, 250)\n\nenum iqs269_local_cap_size {\n\tIQS269_LOCAL_CAP_SIZE_0,\n\tIQS269_LOCAL_CAP_SIZE_GLOBAL_ONLY,\n\tIQS269_LOCAL_CAP_SIZE_GLOBAL_0pF5,\n};\n\nenum iqs269_st_offs {\n\tIQS269_ST_OFFS_PROX,\n\tIQS269_ST_OFFS_DIR,\n\tIQS269_ST_OFFS_TOUCH,\n\tIQS269_ST_OFFS_DEEP,\n};\n\nenum iqs269_th_offs {\n\tIQS269_TH_OFFS_PROX,\n\tIQS269_TH_OFFS_TOUCH,\n\tIQS269_TH_OFFS_DEEP,\n};\n\nenum iqs269_event_id {\n\tIQS269_EVENT_PROX_DN,\n\tIQS269_EVENT_PROX_UP,\n\tIQS269_EVENT_TOUCH_DN,\n\tIQS269_EVENT_TOUCH_UP,\n\tIQS269_EVENT_DEEP_DN,\n\tIQS269_EVENT_DEEP_UP,\n};\n\nstruct iqs269_switch_desc {\n\tunsigned int code;\n\tbool enabled;\n};\n\nstruct iqs269_event_desc {\n\tconst char *name;\n\tenum iqs269_st_offs st_offs;\n\tenum iqs269_th_offs th_offs;\n\tbool dir_up;\n\tu8 mask;\n};\n\nstatic const struct iqs269_event_desc iqs269_events[] = {\n\t[IQS269_EVENT_PROX_DN] = {\n\t\t.name = \"event-prox\",\n\t\t.st_offs = IQS269_ST_OFFS_PROX,\n\t\t.th_offs = IQS269_TH_OFFS_PROX,\n\t\t.mask = IQS269_EVENT_MASK_PROX,\n\t},\n\t[IQS269_EVENT_PROX_UP] = {\n\t\t.name = \"event-prox-alt\",\n\t\t.st_offs = IQS269_ST_OFFS_PROX,\n\t\t.th_offs = IQS269_TH_OFFS_PROX,\n\t\t.dir_up = true,\n\t\t.mask = IQS269_EVENT_MASK_PROX,\n\t},\n\t[IQS269_EVENT_TOUCH_DN] = {\n\t\t.name = \"event-touch\",\n\t\t.st_offs = IQS269_ST_OFFS_TOUCH,\n\t\t.th_offs = IQS269_TH_OFFS_TOUCH,\n\t\t.mask = IQS269_EVENT_MASK_TOUCH,\n\t},\n\t[IQS269_EVENT_TOUCH_UP] = {\n\t\t.name = \"event-touch-alt\",\n\t\t.st_offs = IQS269_ST_OFFS_TOUCH,\n\t\t.th_offs = IQS269_TH_OFFS_TOUCH,\n\t\t.dir_up = true,\n\t\t.mask = IQS269_EVENT_MASK_TOUCH,\n\t},\n\t[IQS269_EVENT_DEEP_DN] = {\n\t\t.name = \"event-deep\",\n\t\t.st_offs = IQS269_ST_OFFS_DEEP,\n\t\t.th_offs = IQS269_TH_OFFS_DEEP,\n\t\t.mask = IQS269_EVENT_MASK_DEEP,\n\t},\n\t[IQS269_EVENT_DEEP_UP] = {\n\t\t.name = \"event-deep-alt\",\n\t\t.st_offs = IQS269_ST_OFFS_DEEP,\n\t\t.th_offs = IQS269_TH_OFFS_DEEP,\n\t\t.dir_up = true,\n\t\t.mask = IQS269_EVENT_MASK_DEEP,\n\t},\n};\n\nstruct iqs269_ver_info {\n\tu8 prod_num;\n\tu8 sw_num;\n\tu8 hw_num;\n\tu8 padding;\n} __packed;\n\nstruct iqs269_ch_reg {\n\tu8 rx_enable;\n\tu8 tx_enable;\n\t__be16 engine_a;\n\t__be16 engine_b;\n\t__be16 ati_comp;\n\tu8 thresh[3];\n\tu8 hyst;\n\tu8 assoc_select;\n\tu8 assoc_weight;\n} __packed;\n\nstruct iqs269_sys_reg {\n\t__be16 general;\n\tu8 active;\n\tu8 filter;\n\tu8 reseed;\n\tu8 event_mask;\n\tu8 rate_np;\n\tu8 rate_lp;\n\tu8 rate_ulp;\n\tu8 timeout_pwr;\n\tu8 timeout_rdy;\n\tu8 timeout_lta;\n\t__be16 misc_a;\n\t__be16 misc_b;\n\tu8 blocking;\n\tu8 padding;\n\tu8 slider_select[IQS269_NUM_SL];\n\tu8 timeout_tap;\n\tu8 timeout_swipe;\n\tu8 thresh_swipe;\n\tu8 redo_ati;\n\tstruct iqs269_ch_reg ch_reg[IQS269_NUM_CH];\n} __packed;\n\nstruct iqs269_flags {\n\t__be16 system;\n\tu8 gesture;\n\tu8 padding;\n\tu8 states[4];\n} __packed;\n\nstruct iqs269_private {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\tstruct iqs269_switch_desc switches[ARRAY_SIZE(iqs269_events)];\n\tstruct iqs269_sys_reg sys_reg;\n\tstruct completion ati_done;\n\tstruct input_dev *keypad;\n\tstruct input_dev *slider[IQS269_NUM_SL];\n\tunsigned int keycode[ARRAY_SIZE(iqs269_events) * IQS269_NUM_CH];\n\tunsigned int ch_num;\n\tbool hall_enable;\n\tbool ati_current;\n};\n\nstatic int iqs269_ati_mode_set(struct iqs269_private *iqs269,\n\t\t\t       unsigned int ch_num, unsigned int mode)\n{\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tu16 engine_a;\n\n\tif (ch_num >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tif (mode > IQS269_CHx_ENG_A_ATI_MODE_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iqs269->lock);\n\n\tengine_a = be16_to_cpu(ch_reg[ch_num].engine_a);\n\n\tengine_a &= ~IQS269_CHx_ENG_A_ATI_MODE_MASK;\n\tengine_a |= (mode << IQS269_CHx_ENG_A_ATI_MODE_SHIFT);\n\n\tch_reg[ch_num].engine_a = cpu_to_be16(engine_a);\n\tiqs269->ati_current = false;\n\n\tmutex_unlock(&iqs269->lock);\n\n\treturn 0;\n}\n\nstatic int iqs269_ati_mode_get(struct iqs269_private *iqs269,\n\t\t\t       unsigned int ch_num, unsigned int *mode)\n{\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tu16 engine_a;\n\n\tif (ch_num >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iqs269->lock);\n\tengine_a = be16_to_cpu(ch_reg[ch_num].engine_a);\n\tmutex_unlock(&iqs269->lock);\n\n\tengine_a &= IQS269_CHx_ENG_A_ATI_MODE_MASK;\n\t*mode = (engine_a >> IQS269_CHx_ENG_A_ATI_MODE_SHIFT);\n\n\treturn 0;\n}\n\nstatic int iqs269_ati_base_set(struct iqs269_private *iqs269,\n\t\t\t       unsigned int ch_num, unsigned int base)\n{\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tu16 engine_b;\n\n\tif (ch_num >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tswitch (base) {\n\tcase 75:\n\t\tbase = IQS269_CHx_ENG_B_ATI_BASE_75;\n\t\tbreak;\n\n\tcase 100:\n\t\tbase = IQS269_CHx_ENG_B_ATI_BASE_100;\n\t\tbreak;\n\n\tcase 150:\n\t\tbase = IQS269_CHx_ENG_B_ATI_BASE_150;\n\t\tbreak;\n\n\tcase 200:\n\t\tbase = IQS269_CHx_ENG_B_ATI_BASE_200;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&iqs269->lock);\n\n\tengine_b = be16_to_cpu(ch_reg[ch_num].engine_b);\n\n\tengine_b &= ~IQS269_CHx_ENG_B_ATI_BASE_MASK;\n\tengine_b |= base;\n\n\tch_reg[ch_num].engine_b = cpu_to_be16(engine_b);\n\tiqs269->ati_current = false;\n\n\tmutex_unlock(&iqs269->lock);\n\n\treturn 0;\n}\n\nstatic int iqs269_ati_base_get(struct iqs269_private *iqs269,\n\t\t\t       unsigned int ch_num, unsigned int *base)\n{\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tu16 engine_b;\n\n\tif (ch_num >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iqs269->lock);\n\tengine_b = be16_to_cpu(ch_reg[ch_num].engine_b);\n\tmutex_unlock(&iqs269->lock);\n\n\tswitch (engine_b & IQS269_CHx_ENG_B_ATI_BASE_MASK) {\n\tcase IQS269_CHx_ENG_B_ATI_BASE_75:\n\t\t*base = 75;\n\t\treturn 0;\n\n\tcase IQS269_CHx_ENG_B_ATI_BASE_100:\n\t\t*base = 100;\n\t\treturn 0;\n\n\tcase IQS269_CHx_ENG_B_ATI_BASE_150:\n\t\t*base = 150;\n\t\treturn 0;\n\n\tcase IQS269_CHx_ENG_B_ATI_BASE_200:\n\t\t*base = 200;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int iqs269_ati_target_set(struct iqs269_private *iqs269,\n\t\t\t\t unsigned int ch_num, unsigned int target)\n{\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tu16 engine_b;\n\n\tif (ch_num >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tif (target > IQS269_CHx_ENG_B_ATI_TARGET_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iqs269->lock);\n\n\tengine_b = be16_to_cpu(ch_reg[ch_num].engine_b);\n\n\tengine_b &= ~IQS269_CHx_ENG_B_ATI_TARGET_MASK;\n\tengine_b |= target / 32;\n\n\tch_reg[ch_num].engine_b = cpu_to_be16(engine_b);\n\tiqs269->ati_current = false;\n\n\tmutex_unlock(&iqs269->lock);\n\n\treturn 0;\n}\n\nstatic int iqs269_ati_target_get(struct iqs269_private *iqs269,\n\t\t\t\t unsigned int ch_num, unsigned int *target)\n{\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tu16 engine_b;\n\n\tif (ch_num >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iqs269->lock);\n\tengine_b = be16_to_cpu(ch_reg[ch_num].engine_b);\n\tmutex_unlock(&iqs269->lock);\n\n\t*target = (engine_b & IQS269_CHx_ENG_B_ATI_TARGET_MASK) * 32;\n\n\treturn 0;\n}\n\nstatic int iqs269_parse_mask(const struct fwnode_handle *fwnode,\n\t\t\t     const char *propname, u8 *mask)\n{\n\tunsigned int val[IQS269_NUM_CH];\n\tint count, error, i;\n\n\tcount = fwnode_property_count_u32(fwnode, propname);\n\tif (count < 0)\n\t\treturn 0;\n\n\tif (count > IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\terror = fwnode_property_read_u32_array(fwnode, propname, val, count);\n\tif (error)\n\t\treturn error;\n\n\t*mask = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (val[i] >= IQS269_NUM_CH)\n\t\t\treturn -EINVAL;\n\n\t\t*mask |= BIT(val[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs269_parse_chan(struct iqs269_private *iqs269,\n\t\t\t     const struct fwnode_handle *ch_node)\n{\n\tstruct i2c_client *client = iqs269->client;\n\tstruct fwnode_handle *ev_node;\n\tstruct iqs269_ch_reg *ch_reg;\n\tu16 engine_a, engine_b;\n\tunsigned int reg, val;\n\tint error, i;\n\n\terror = fwnode_property_read_u32(ch_node, \"reg\", &reg);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read channel number: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t} else if (reg >= IQS269_NUM_CH) {\n\t\tdev_err(&client->dev, \"Invalid channel number: %u\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\n\tiqs269->sys_reg.active |= BIT(reg);\n\tif (!fwnode_property_present(ch_node, \"azoteq,reseed-disable\"))\n\t\tiqs269->sys_reg.reseed |= BIT(reg);\n\n\tif (fwnode_property_present(ch_node, \"azoteq,blocking-enable\"))\n\t\tiqs269->sys_reg.blocking |= BIT(reg);\n\n\tif (fwnode_property_present(ch_node, \"azoteq,slider0-select\"))\n\t\tiqs269->sys_reg.slider_select[0] |= BIT(reg);\n\n\tif (fwnode_property_present(ch_node, \"azoteq,slider1-select\"))\n\t\tiqs269->sys_reg.slider_select[1] |= BIT(reg);\n\n\tch_reg = &iqs269->sys_reg.ch_reg[reg];\n\n\terror = iqs269_parse_mask(ch_node, \"azoteq,rx-enable\",\n\t\t\t\t  &ch_reg->rx_enable);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Invalid channel %u RX enable mask: %d\\n\",\n\t\t\treg, error);\n\t\treturn error;\n\t}\n\n\terror = iqs269_parse_mask(ch_node, \"azoteq,tx-enable\",\n\t\t\t\t  &ch_reg->tx_enable);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Invalid channel %u TX enable mask: %d\\n\",\n\t\t\treg, error);\n\t\treturn error;\n\t}\n\n\tengine_a = be16_to_cpu(ch_reg->engine_a);\n\tengine_b = be16_to_cpu(ch_reg->engine_b);\n\n\tengine_a |= IQS269_CHx_ENG_A_MEAS_CAP_SIZE;\n\tif (fwnode_property_present(ch_node, \"azoteq,meas-cap-decrease\"))\n\t\tengine_a &= ~IQS269_CHx_ENG_A_MEAS_CAP_SIZE;\n\n\tengine_a |= IQS269_CHx_ENG_A_RX_GND_INACTIVE;\n\tif (fwnode_property_present(ch_node, \"azoteq,rx-float-inactive\"))\n\t\tengine_a &= ~IQS269_CHx_ENG_A_RX_GND_INACTIVE;\n\n\tengine_a &= ~IQS269_CHx_ENG_A_LOCAL_CAP_SIZE;\n\tengine_b &= ~IQS269_CHx_ENG_B_LOCAL_CAP_ENABLE;\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,local-cap-size\", &val)) {\n\t\tswitch (val) {\n\t\tcase IQS269_LOCAL_CAP_SIZE_0:\n\t\t\tbreak;\n\n\t\tcase IQS269_LOCAL_CAP_SIZE_GLOBAL_0pF5:\n\t\t\tengine_a |= IQS269_CHx_ENG_A_LOCAL_CAP_SIZE;\n\t\t\tfallthrough;\n\n\t\tcase IQS269_LOCAL_CAP_SIZE_GLOBAL_ONLY:\n\t\t\tengine_b |= IQS269_CHx_ENG_B_LOCAL_CAP_ENABLE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u local cap. size: %u\\n\", reg,\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tengine_a &= ~IQS269_CHx_ENG_A_INV_LOGIC;\n\tif (fwnode_property_present(ch_node, \"azoteq,invert-enable\"))\n\t\tengine_a |= IQS269_CHx_ENG_A_INV_LOGIC;\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,proj-bias\", &val)) {\n\t\tif (val > IQS269_CHx_ENG_A_PROJ_BIAS_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u bias current: %u\\n\", reg,\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tengine_a &= ~IQS269_CHx_ENG_A_PROJ_BIAS_MASK;\n\t\tengine_a |= (val << IQS269_CHx_ENG_A_PROJ_BIAS_SHIFT);\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,sense-mode\", &val)) {\n\t\tif (val > IQS269_CHx_ENG_A_SENSE_MODE_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u sensing mode: %u\\n\", reg,\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tengine_a &= ~IQS269_CHx_ENG_A_SENSE_MODE_MASK;\n\t\tengine_a |= val;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,sense-freq\", &val)) {\n\t\tif (val > IQS269_CHx_ENG_B_SENSE_FREQ_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u sensing frequency: %u\\n\",\n\t\t\t\treg, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tengine_b &= ~IQS269_CHx_ENG_B_SENSE_FREQ_MASK;\n\t\tengine_b |= (val << IQS269_CHx_ENG_B_SENSE_FREQ_SHIFT);\n\t}\n\n\tengine_b &= ~IQS269_CHx_ENG_B_STATIC_ENABLE;\n\tif (fwnode_property_present(ch_node, \"azoteq,static-enable\"))\n\t\tengine_b |= IQS269_CHx_ENG_B_STATIC_ENABLE;\n\n\tch_reg->engine_a = cpu_to_be16(engine_a);\n\tch_reg->engine_b = cpu_to_be16(engine_b);\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,ati-mode\", &val)) {\n\t\terror = iqs269_ati_mode_set(iqs269, reg, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u ATI mode: %u\\n\", reg, val);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,ati-base\", &val)) {\n\t\terror = iqs269_ati_base_set(iqs269, reg, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u ATI base: %u\\n\", reg, val);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,ati-target\", &val)) {\n\t\terror = iqs269_ati_target_set(iqs269, reg, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u ATI target: %u\\n\", reg,\n\t\t\t\tval);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = iqs269_parse_mask(ch_node, \"azoteq,assoc-select\",\n\t\t\t\t  &ch_reg->assoc_select);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Invalid channel %u association: %d\\n\",\n\t\t\treg, error);\n\t\treturn error;\n\t}\n\n\tif (!fwnode_property_read_u32(ch_node, \"azoteq,assoc-weight\", &val)) {\n\t\tif (val > IQS269_CHx_WEIGHT_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid channel %u associated weight: %u\\n\",\n\t\t\t\treg, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tch_reg->assoc_weight = val;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs269_events); i++) {\n\t\tev_node = fwnode_get_named_child_node(ch_node,\n\t\t\t\t\t\t      iqs269_events[i].name);\n\t\tif (!ev_node)\n\t\t\tcontinue;\n\n\t\tif (!fwnode_property_read_u32(ev_node, \"azoteq,thresh\", &val)) {\n\t\t\tif (val > IQS269_CHx_THRESH_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid channel %u threshold: %u\\n\",\n\t\t\t\t\treg, val);\n\t\t\t\tfwnode_handle_put(ev_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tch_reg->thresh[iqs269_events[i].th_offs] = val;\n\t\t}\n\n\t\tif (!fwnode_property_read_u32(ev_node, \"azoteq,hyst\", &val)) {\n\t\t\tu8 *hyst = &ch_reg->hyst;\n\n\t\t\tif (val > IQS269_CHx_HYST_MAX) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid channel %u hysteresis: %u\\n\",\n\t\t\t\t\treg, val);\n\t\t\t\tfwnode_handle_put(ev_node);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (i == IQS269_EVENT_DEEP_DN ||\n\t\t\t    i == IQS269_EVENT_DEEP_UP) {\n\t\t\t\t*hyst &= ~IQS269_CHx_HYST_DEEP_MASK;\n\t\t\t\t*hyst |= (val << IQS269_CHx_HYST_DEEP_SHIFT);\n\t\t\t} else if (i == IQS269_EVENT_TOUCH_DN ||\n\t\t\t\t   i == IQS269_EVENT_TOUCH_UP) {\n\t\t\t\t*hyst &= ~IQS269_CHx_HYST_TOUCH_MASK;\n\t\t\t\t*hyst |= val;\n\t\t\t}\n\t\t}\n\n\t\terror = fwnode_property_read_u32(ev_node, \"linux,code\", &val);\n\t\tfwnode_handle_put(ev_node);\n\t\tif (error == -EINVAL) {\n\t\t\tcontinue;\n\t\t} else if (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read channel %u code: %d\\n\", reg,\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tswitch (reg) {\n\t\tcase IQS269_CHx_HALL_ACTIVE:\n\t\t\tif (iqs269->hall_enable) {\n\t\t\t\tiqs269->switches[i].code = val;\n\t\t\t\tiqs269->switches[i].enabled = true;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tcase IQS269_CHx_HALL_INACTIVE:\n\t\t\tif (iqs269->hall_enable)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\n\t\tdefault:\n\t\t\tiqs269->keycode[i * IQS269_NUM_CH + reg] = val;\n\t\t}\n\n\t\tiqs269->sys_reg.event_mask &= ~iqs269_events[i].mask;\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs269_parse_prop(struct iqs269_private *iqs269)\n{\n\tstruct iqs269_sys_reg *sys_reg = &iqs269->sys_reg;\n\tstruct i2c_client *client = iqs269->client;\n\tstruct fwnode_handle *ch_node;\n\tu16 general, misc_a, misc_b;\n\tunsigned int val;\n\tint error;\n\n\tiqs269->hall_enable = device_property_present(&client->dev,\n\t\t\t\t\t\t      \"azoteq,hall-enable\");\n\n\terror = regmap_raw_read(iqs269->regmap, IQS269_SYS_SETTINGS, sys_reg,\n\t\t\t\tsizeof(*sys_reg));\n\tif (error)\n\t\treturn error;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,filt-str-lp-lta\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid filter strength: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->filter &= ~IQS269_FILT_STR_LP_LTA_MASK;\n\t\tsys_reg->filter |= (val << IQS269_FILT_STR_LP_LTA_SHIFT);\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,filt-str-lp-cnt\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid filter strength: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->filter &= ~IQS269_FILT_STR_LP_CNT_MASK;\n\t\tsys_reg->filter |= (val << IQS269_FILT_STR_LP_CNT_SHIFT);\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,filt-str-np-lta\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid filter strength: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->filter &= ~IQS269_FILT_STR_NP_LTA_MASK;\n\t\tsys_reg->filter |= (val << IQS269_FILT_STR_NP_LTA_SHIFT);\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,filt-str-np-cnt\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid filter strength: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->filter &= ~IQS269_FILT_STR_NP_CNT_MASK;\n\t\tsys_reg->filter |= val;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,rate-np-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_RATE_NP_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid report rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->rate_np = val;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,rate-lp-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_RATE_LP_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid report rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->rate_lp = val;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,rate-ulp-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_RATE_ULP_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid report rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->rate_ulp = val / 16;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,timeout-pwr-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_TIMEOUT_PWR_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid timeout: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->timeout_pwr = val / 512;\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,timeout-lta-ms\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_TIMEOUT_LTA_MS_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid timeout: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsys_reg->timeout_lta = val / 512;\n\t}\n\n\tmisc_a = be16_to_cpu(sys_reg->misc_a);\n\tmisc_b = be16_to_cpu(sys_reg->misc_b);\n\n\tmisc_a &= ~IQS269_MISC_A_ATI_BAND_DISABLE;\n\tif (device_property_present(&client->dev, \"azoteq,ati-band-disable\"))\n\t\tmisc_a |= IQS269_MISC_A_ATI_BAND_DISABLE;\n\n\tmisc_a &= ~IQS269_MISC_A_ATI_LP_ONLY;\n\tif (device_property_present(&client->dev, \"azoteq,ati-lp-only\"))\n\t\tmisc_a |= IQS269_MISC_A_ATI_LP_ONLY;\n\n\tmisc_a &= ~IQS269_MISC_A_ATI_BAND_TIGHTEN;\n\tif (device_property_present(&client->dev, \"azoteq,ati-band-tighten\"))\n\t\tmisc_a |= IQS269_MISC_A_ATI_BAND_TIGHTEN;\n\n\tmisc_a &= ~IQS269_MISC_A_FILT_DISABLE;\n\tif (device_property_present(&client->dev, \"azoteq,filt-disable\"))\n\t\tmisc_a |= IQS269_MISC_A_FILT_DISABLE;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,gpio3-select\",\n\t\t\t\t      &val)) {\n\t\tif (val >= IQS269_NUM_CH) {\n\t\t\tdev_err(&client->dev, \"Invalid GPIO3 selection: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmisc_a &= ~IQS269_MISC_A_GPIO3_SELECT_MASK;\n\t\tmisc_a |= (val << IQS269_MISC_A_GPIO3_SELECT_SHIFT);\n\t}\n\n\tmisc_a &= ~IQS269_MISC_A_DUAL_DIR;\n\tif (device_property_present(&client->dev, \"azoteq,dual-direction\"))\n\t\tmisc_a |= IQS269_MISC_A_DUAL_DIR;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,tx-freq\", &val)) {\n\t\tif (val > IQS269_MISC_A_TX_FREQ_MAX) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Invalid excitation frequency: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmisc_a &= ~IQS269_MISC_A_TX_FREQ_MASK;\n\t\tmisc_a |= (val << IQS269_MISC_A_TX_FREQ_SHIFT);\n\t}\n\n\tmisc_a &= ~IQS269_MISC_A_GLOBAL_CAP_SIZE;\n\tif (device_property_present(&client->dev, \"azoteq,global-cap-increase\"))\n\t\tmisc_a |= IQS269_MISC_A_GLOBAL_CAP_SIZE;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,reseed-select\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_MISC_B_RESEED_UI_SEL_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid reseed selection: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmisc_b &= ~IQS269_MISC_B_RESEED_UI_SEL_MASK;\n\t\tmisc_b |= (val << IQS269_MISC_B_RESEED_UI_SEL_SHIFT);\n\t}\n\n\tmisc_b &= ~IQS269_MISC_B_TRACKING_UI_ENABLE;\n\tif (device_property_present(&client->dev, \"azoteq,tracking-enable\"))\n\t\tmisc_b |= IQS269_MISC_B_TRACKING_UI_ENABLE;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,filt-str-slider\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_FILT_STR_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid filter strength: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmisc_b &= ~IQS269_MISC_B_FILT_STR_SLIDER;\n\t\tmisc_b |= val;\n\t}\n\n\tsys_reg->misc_a = cpu_to_be16(misc_a);\n\tsys_reg->misc_b = cpu_to_be16(misc_b);\n\n\tsys_reg->active = 0;\n\tsys_reg->reseed = 0;\n\n\tsys_reg->blocking = 0;\n\n\tsys_reg->slider_select[0] = 0;\n\tsys_reg->slider_select[1] = 0;\n\n\tsys_reg->event_mask = ~((u8)IQS269_EVENT_MASK_SYS);\n\n\tdevice_for_each_child_node(&client->dev, ch_node) {\n\t\terror = iqs269_parse_chan(iqs269, ch_node);\n\t\tif (error) {\n\t\t\tfwnode_handle_put(ch_node);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tsys_reg->redo_ati = sys_reg->active;\n\n\tgeneral = be16_to_cpu(sys_reg->general);\n\n\tif (device_property_present(&client->dev, \"azoteq,clk-div\"))\n\t\tgeneral |= IQS269_SYS_SETTINGS_CLK_DIV;\n\n\t \n\tgeneral &= ~IQS269_SYS_SETTINGS_ULP_AUTO;\n\tgeneral &= ~IQS269_SYS_SETTINGS_DIS_AUTO;\n\tgeneral &= ~IQS269_SYS_SETTINGS_PWR_MODE_MASK;\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,suspend-mode\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_SYS_SETTINGS_PWR_MODE_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid suspend mode: %u\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgeneral |= (val << IQS269_SYS_SETTINGS_PWR_MODE_SHIFT);\n\t}\n\n\tif (!device_property_read_u32(&client->dev, \"azoteq,ulp-update\",\n\t\t\t\t      &val)) {\n\t\tif (val > IQS269_SYS_SETTINGS_ULP_UPDATE_MAX) {\n\t\t\tdev_err(&client->dev, \"Invalid update rate: %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgeneral &= ~IQS269_SYS_SETTINGS_ULP_UPDATE_MASK;\n\t\tgeneral |= (val << IQS269_SYS_SETTINGS_ULP_UPDATE_SHIFT);\n\t}\n\n\tgeneral &= ~IQS269_SYS_SETTINGS_RESEED_OFFSET;\n\tif (device_property_present(&client->dev, \"azoteq,reseed-offset\"))\n\t\tgeneral |= IQS269_SYS_SETTINGS_RESEED_OFFSET;\n\n\tgeneral |= IQS269_SYS_SETTINGS_EVENT_MODE;\n\n\t \n\tif (sys_reg->slider_select[0] || sys_reg->slider_select[1])\n\t\tgeneral |= IQS269_SYS_SETTINGS_EVENT_MODE_LP;\n\n\tgeneral |= IQS269_SYS_SETTINGS_REDO_ATI;\n\tgeneral |= IQS269_SYS_SETTINGS_ACK_RESET;\n\n\tsys_reg->general = cpu_to_be16(general);\n\n\treturn 0;\n}\n\nstatic int iqs269_dev_init(struct iqs269_private *iqs269)\n{\n\tint error;\n\n\tmutex_lock(&iqs269->lock);\n\n\terror = regmap_update_bits(iqs269->regmap, IQS269_HALL_UI,\n\t\t\t\t   IQS269_HALL_UI_ENABLE,\n\t\t\t\t   iqs269->hall_enable ? ~0 : 0);\n\tif (error)\n\t\tgoto err_mutex;\n\n\terror = regmap_raw_write(iqs269->regmap, IQS269_SYS_SETTINGS,\n\t\t\t\t &iqs269->sys_reg, sizeof(iqs269->sys_reg));\n\tif (error)\n\t\tgoto err_mutex;\n\n\t \n\tusleep_range(2000, 2100);\n\n\tiqs269->ati_current = true;\n\nerr_mutex:\n\tmutex_unlock(&iqs269->lock);\n\n\treturn error;\n}\n\nstatic int iqs269_input_init(struct iqs269_private *iqs269)\n{\n\tstruct i2c_client *client = iqs269->client;\n\tunsigned int sw_code, keycode;\n\tint error, i, j;\n\n\tiqs269->keypad = devm_input_allocate_device(&client->dev);\n\tif (!iqs269->keypad)\n\t\treturn -ENOMEM;\n\n\tiqs269->keypad->keycodemax = ARRAY_SIZE(iqs269->keycode);\n\tiqs269->keypad->keycode = iqs269->keycode;\n\tiqs269->keypad->keycodesize = sizeof(*iqs269->keycode);\n\n\tiqs269->keypad->name = \"iqs269a_keypad\";\n\tiqs269->keypad->id.bustype = BUS_I2C;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs269_events); i++) {\n\t\tsw_code = iqs269->switches[i].code;\n\n\t\tfor (j = 0; j < IQS269_NUM_CH; j++) {\n\t\t\tkeycode = iqs269->keycode[i * IQS269_NUM_CH + j];\n\n\t\t\t \n\t\t\tswitch (j) {\n\t\t\tcase IQS269_CHx_HALL_ACTIVE:\n\t\t\t\tif (iqs269->hall_enable &&\n\t\t\t\t    iqs269->switches[i].enabled)\n\t\t\t\t\tinput_set_capability(iqs269->keypad,\n\t\t\t\t\t\t\t     EV_SW, sw_code);\n\t\t\t\tfallthrough;\n\n\t\t\tcase IQS269_CHx_HALL_INACTIVE:\n\t\t\t\tif (iqs269->hall_enable)\n\t\t\t\t\tcontinue;\n\t\t\t\tfallthrough;\n\n\t\t\tdefault:\n\t\t\t\tif (keycode != KEY_RESERVED)\n\t\t\t\t\tinput_set_capability(iqs269->keypad,\n\t\t\t\t\t\t\t     EV_KEY, keycode);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < IQS269_NUM_SL; i++) {\n\t\tif (!iqs269->sys_reg.slider_select[i])\n\t\t\tcontinue;\n\n\t\tiqs269->slider[i] = devm_input_allocate_device(&client->dev);\n\t\tif (!iqs269->slider[i])\n\t\t\treturn -ENOMEM;\n\n\t\tiqs269->slider[i]->name = i ? \"iqs269a_slider_1\"\n\t\t\t\t\t    : \"iqs269a_slider_0\";\n\t\tiqs269->slider[i]->id.bustype = BUS_I2C;\n\n\t\tinput_set_capability(iqs269->slider[i], EV_KEY, BTN_TOUCH);\n\t\tinput_set_abs_params(iqs269->slider[i], ABS_X, 0, 255, 0, 0);\n\n\t\terror = input_register_device(iqs269->slider[i]);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to register slider %d: %d\\n\", i, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs269_report(struct iqs269_private *iqs269)\n{\n\tstruct i2c_client *client = iqs269->client;\n\tstruct iqs269_flags flags;\n\tunsigned int sw_code, keycode;\n\tint error, i, j;\n\tu8 slider_x[IQS269_NUM_SL];\n\tu8 dir_mask, state;\n\n\terror = regmap_raw_read(iqs269->regmap, IQS269_SYS_FLAGS, &flags,\n\t\t\t\tsizeof(flags));\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read device status: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tif (be16_to_cpu(flags.system) & IQS269_SYS_FLAGS_SHOW_RESET) {\n\t\tdev_err(&client->dev, \"Unexpected device reset\\n\");\n\n\t\terror = iqs269_dev_init(iqs269);\n\t\tif (error)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to re-initialize device: %d\\n\", error);\n\n\t\treturn error;\n\t}\n\n\tif (be16_to_cpu(flags.system) & IQS269_SYS_FLAGS_IN_ATI)\n\t\treturn 0;\n\n\terror = regmap_raw_read(iqs269->regmap, IQS269_SLIDER_X, slider_x,\n\t\t\t\tsizeof(slider_x));\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read slider position: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i < IQS269_NUM_SL; i++) {\n\t\tif (!iqs269->sys_reg.slider_select[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (flags.states[IQS269_ST_OFFS_TOUCH] &\n\t\t    iqs269->sys_reg.slider_select[i]) {\n\t\t\tinput_report_key(iqs269->slider[i], BTN_TOUCH, 1);\n\t\t\tinput_report_abs(iqs269->slider[i], ABS_X, slider_x[i]);\n\t\t} else {\n\t\t\tinput_report_key(iqs269->slider[i], BTN_TOUCH, 0);\n\t\t}\n\n\t\tinput_sync(iqs269->slider[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs269_events); i++) {\n\t\tdir_mask = flags.states[IQS269_ST_OFFS_DIR];\n\t\tif (!iqs269_events[i].dir_up)\n\t\t\tdir_mask = ~dir_mask;\n\n\t\tstate = flags.states[iqs269_events[i].st_offs] & dir_mask;\n\n\t\tsw_code = iqs269->switches[i].code;\n\n\t\tfor (j = 0; j < IQS269_NUM_CH; j++) {\n\t\t\tkeycode = iqs269->keycode[i * IQS269_NUM_CH + j];\n\n\t\t\tswitch (j) {\n\t\t\tcase IQS269_CHx_HALL_ACTIVE:\n\t\t\t\tif (iqs269->hall_enable &&\n\t\t\t\t    iqs269->switches[i].enabled)\n\t\t\t\t\tinput_report_switch(iqs269->keypad,\n\t\t\t\t\t\t\t    sw_code,\n\t\t\t\t\t\t\t    state & BIT(j));\n\t\t\t\tfallthrough;\n\n\t\t\tcase IQS269_CHx_HALL_INACTIVE:\n\t\t\t\tif (iqs269->hall_enable)\n\t\t\t\t\tcontinue;\n\t\t\t\tfallthrough;\n\n\t\t\tdefault:\n\t\t\t\tinput_report_key(iqs269->keypad, keycode,\n\t\t\t\t\t\t state & BIT(j));\n\t\t\t}\n\t\t}\n\t}\n\n\tinput_sync(iqs269->keypad);\n\n\t \n\tcomplete_all(&iqs269->ati_done);\n\n\treturn 0;\n}\n\nstatic irqreturn_t iqs269_irq(int irq, void *context)\n{\n\tstruct iqs269_private *iqs269 = context;\n\n\tif (iqs269_report(iqs269))\n\t\treturn IRQ_NONE;\n\n\t \n\tiqs269_irq_wait();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t counts_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs269->client;\n\t__le16 counts;\n\tint error;\n\n\tif (!iqs269->ati_current || iqs269->hall_enable)\n\t\treturn -EPERM;\n\n\tif (!completion_done(&iqs269->ati_done))\n\t\treturn -EBUSY;\n\n\t \n\tdisable_irq(client->irq);\n\n\terror = regmap_raw_read(iqs269->regmap,\n\t\t\t\tIQS269_CHx_COUNTS + iqs269->ch_num * 2,\n\t\t\t\t&counts, sizeof(counts));\n\n\tiqs269_irq_wait();\n\tenable_irq(client->irq);\n\n\tif (error)\n\t\treturn error;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", le16_to_cpu(counts));\n}\n\nstatic ssize_t hall_bin_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tstruct i2c_client *client = iqs269->client;\n\tunsigned int val;\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\terror = regmap_read(iqs269->regmap, IQS269_CAL_DATA_A, &val);\n\n\tiqs269_irq_wait();\n\tenable_irq(client->irq);\n\n\tif (error)\n\t\treturn error;\n\n\tswitch (ch_reg[IQS269_CHx_HALL_ACTIVE].rx_enable &\n\t\tch_reg[IQS269_CHx_HALL_INACTIVE].rx_enable) {\n\tcase IQS269_HALL_PAD_R:\n\t\tval &= IQS269_CAL_DATA_A_HALL_BIN_R_MASK;\n\t\tval >>= IQS269_CAL_DATA_A_HALL_BIN_R_SHIFT;\n\t\tbreak;\n\n\tcase IQS269_HALL_PAD_L:\n\t\tval &= IQS269_CAL_DATA_A_HALL_BIN_L_MASK;\n\t\tval >>= IQS269_CAL_DATA_A_HALL_BIN_L_SHIFT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t hall_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", iqs269->hall_enable);\n}\n\nstatic ssize_t hall_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&iqs269->lock);\n\n\tiqs269->hall_enable = val;\n\tiqs269->ati_current = false;\n\n\tmutex_unlock(&iqs269->lock);\n\n\treturn count;\n}\n\nstatic ssize_t ch_number_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", iqs269->ch_num);\n}\n\nstatic ssize_t ch_number_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val >= IQS269_NUM_CH)\n\t\treturn -EINVAL;\n\n\tiqs269->ch_num = val;\n\n\treturn count;\n}\n\nstatic ssize_t rx_enable_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t ch_reg[iqs269->ch_num].rx_enable);\n}\n\nstatic ssize_t rx_enable_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct iqs269_ch_reg *ch_reg = iqs269->sys_reg.ch_reg;\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val > 0xFF)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iqs269->lock);\n\n\tch_reg[iqs269->ch_num].rx_enable = val;\n\tiqs269->ati_current = false;\n\n\tmutex_unlock(&iqs269->lock);\n\n\treturn count;\n}\n\nstatic ssize_t ati_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = iqs269_ati_mode_get(iqs269, iqs269->ch_num, &val);\n\tif (error)\n\t\treturn error;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t ati_mode_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs269_ati_mode_set(iqs269, iqs269->ch_num, val);\n\tif (error)\n\t\treturn error;\n\n\treturn count;\n}\n\nstatic ssize_t ati_base_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = iqs269_ati_base_get(iqs269, iqs269->ch_num, &val);\n\tif (error)\n\t\treturn error;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t ati_base_store(struct device *dev,\n\t\t\t      struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs269_ati_base_set(iqs269, iqs269->ch_num, val);\n\tif (error)\n\t\treturn error;\n\n\treturn count;\n}\n\nstatic ssize_t ati_target_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = iqs269_ati_target_get(iqs269, iqs269->ch_num, &val);\n\tif (error)\n\t\treturn error;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t ati_target_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs269_ati_target_set(iqs269, iqs269->ch_num, val);\n\tif (error)\n\t\treturn error;\n\n\treturn count;\n}\n\nstatic ssize_t ati_trigger_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t iqs269->ati_current &&\n\t\t\t completion_done(&iqs269->ati_done));\n}\n\nstatic ssize_t ati_trigger_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs269->client;\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (!val)\n\t\treturn count;\n\n\tdisable_irq(client->irq);\n\treinit_completion(&iqs269->ati_done);\n\n\terror = iqs269_dev_init(iqs269);\n\n\tiqs269_irq_wait();\n\tenable_irq(client->irq);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!wait_for_completion_timeout(&iqs269->ati_done,\n\t\t\t\t\t msecs_to_jiffies(2000)))\n\t\treturn -ETIMEDOUT;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(counts);\nstatic DEVICE_ATTR_RO(hall_bin);\nstatic DEVICE_ATTR_RW(hall_enable);\nstatic DEVICE_ATTR_RW(ch_number);\nstatic DEVICE_ATTR_RW(rx_enable);\nstatic DEVICE_ATTR_RW(ati_mode);\nstatic DEVICE_ATTR_RW(ati_base);\nstatic DEVICE_ATTR_RW(ati_target);\nstatic DEVICE_ATTR_RW(ati_trigger);\n\nstatic struct attribute *iqs269_attrs[] = {\n\t&dev_attr_counts.attr,\n\t&dev_attr_hall_bin.attr,\n\t&dev_attr_hall_enable.attr,\n\t&dev_attr_ch_number.attr,\n\t&dev_attr_rx_enable.attr,\n\t&dev_attr_ati_mode.attr,\n\t&dev_attr_ati_base.attr,\n\t&dev_attr_ati_target.attr,\n\t&dev_attr_ati_trigger.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group iqs269_attr_group = {\n\t.attrs = iqs269_attrs,\n};\n\nstatic const struct regmap_config iqs269_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = IQS269_MAX_REG,\n};\n\nstatic int iqs269_probe(struct i2c_client *client)\n{\n\tstruct iqs269_ver_info ver_info;\n\tstruct iqs269_private *iqs269;\n\tint error;\n\n\tiqs269 = devm_kzalloc(&client->dev, sizeof(*iqs269), GFP_KERNEL);\n\tif (!iqs269)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, iqs269);\n\tiqs269->client = client;\n\n\tiqs269->regmap = devm_regmap_init_i2c(client, &iqs269_regmap_config);\n\tif (IS_ERR(iqs269->regmap)) {\n\t\terror = PTR_ERR(iqs269->regmap);\n\t\tdev_err(&client->dev, \"Failed to initialize register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tmutex_init(&iqs269->lock);\n\tinit_completion(&iqs269->ati_done);\n\n\terror = regmap_raw_read(iqs269->regmap, IQS269_VER_INFO, &ver_info,\n\t\t\t\tsizeof(ver_info));\n\tif (error)\n\t\treturn error;\n\n\tif (ver_info.prod_num != IQS269_VER_INFO_PROD_NUM) {\n\t\tdev_err(&client->dev, \"Unrecognized product number: 0x%02X\\n\",\n\t\t\tver_info.prod_num);\n\t\treturn -EINVAL;\n\t}\n\n\terror = iqs269_parse_prop(iqs269);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs269_dev_init(iqs269);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to initialize device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = iqs269_input_init(iqs269);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, iqs269_irq, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, iqs269);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (!wait_for_completion_timeout(&iqs269->ati_done,\n\t\t\t\t\t msecs_to_jiffies(2000))) {\n\t\tdev_err(&client->dev, \"Failed to complete ATI\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\terror = input_register_device(iqs269->keypad);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register keypad: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &iqs269_attr_group);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to add attributes: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic u16 iqs269_general_get(struct iqs269_private *iqs269)\n{\n\tu16 general = be16_to_cpu(iqs269->sys_reg.general);\n\n\tgeneral &= ~IQS269_SYS_SETTINGS_REDO_ATI;\n\tgeneral &= ~IQS269_SYS_SETTINGS_ACK_RESET;\n\n\treturn general | IQS269_SYS_SETTINGS_DIS_AUTO;\n}\n\nstatic int iqs269_suspend(struct device *dev)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs269->client;\n\tint error;\n\tu16 general = iqs269_general_get(iqs269);\n\n\tif (!(general & IQS269_SYS_SETTINGS_PWR_MODE_MASK))\n\t\treturn 0;\n\n\tdisable_irq(client->irq);\n\n\terror = regmap_write(iqs269->regmap, IQS269_SYS_SETTINGS, general);\n\n\tiqs269_irq_wait();\n\tenable_irq(client->irq);\n\n\treturn error;\n}\n\nstatic int iqs269_resume(struct device *dev)\n{\n\tstruct iqs269_private *iqs269 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs269->client;\n\tint error;\n\tu16 general = iqs269_general_get(iqs269);\n\n\tif (!(general & IQS269_SYS_SETTINGS_PWR_MODE_MASK))\n\t\treturn 0;\n\n\tdisable_irq(client->irq);\n\n\terror = regmap_write(iqs269->regmap, IQS269_SYS_SETTINGS,\n\t\t\t     general & ~IQS269_SYS_SETTINGS_PWR_MODE_MASK);\n\tif (!error)\n\t\terror = regmap_write(iqs269->regmap, IQS269_SYS_SETTINGS,\n\t\t\t\t     general & ~IQS269_SYS_SETTINGS_DIS_AUTO);\n\n\tiqs269_irq_wait();\n\tenable_irq(client->irq);\n\n\treturn error;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(iqs269_pm, iqs269_suspend, iqs269_resume);\n\nstatic const struct of_device_id iqs269_of_match[] = {\n\t{ .compatible = \"azoteq,iqs269a\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, iqs269_of_match);\n\nstatic struct i2c_driver iqs269_i2c_driver = {\n\t.driver = {\n\t\t.name = \"iqs269a\",\n\t\t.of_match_table = iqs269_of_match,\n\t\t.pm = pm_sleep_ptr(&iqs269_pm),\n\t},\n\t.probe = iqs269_probe,\n};\nmodule_i2c_driver(iqs269_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS269A Capacitive Touch Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}