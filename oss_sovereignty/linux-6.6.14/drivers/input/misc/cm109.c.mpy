{
  "module_name": "cm109.c",
  "hash_id": "35afe6a3dbe1633deaebccaec2315dcc898104f3457a1e4d918f448f676aa77e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/cm109.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/rwsem.h>\n#include <linux/usb/input.h>\n\n#define DRIVER_VERSION \"20080805\"\n#define DRIVER_AUTHOR  \"Alfred E. Heggestad\"\n#define DRIVER_DESC    \"CM109 phone driver\"\n\nstatic char *phone = \"kip1000\";\nmodule_param(phone, charp, S_IRUSR);\nMODULE_PARM_DESC(phone, \"Phone name {kip1000, gtalk, usbph01, atcom}\");\n\nenum {\n\t \n\tHID_IR0 = 0x00,  \n\tHID_IR1 = 0x01,  \n\tHID_IR2 = 0x02,  \n\tHID_IR3 = 0x03,  \n\tHID_OR0 = 0x00,  \n\tHID_OR1 = 0x01,  \n\tHID_OR2 = 0x02,  \n\tHID_OR3 = 0x03,  \n\n\t \n\tRECORD_MUTE   = 1 << 3,\n\tPLAYBACK_MUTE = 1 << 2,\n\tVOLUME_DOWN   = 1 << 1,\n\tVOLUME_UP     = 1 << 0,\n\n\t \n\t \n\tHID_OR_GPO_BUZ_SPDIF   = 0 << 6,\n\tHID_OR_GENERIC_HID_REG = 1 << 6,\n\tHID_OR_MAP_MCU_EEPROM  = 2 << 6,\n\n\tBUZZER_ON = 1 << 5,\n\n\t \n\tKEYMAP_SIZE = 256 + 15,\n};\n\n \nstruct cm109_ctl_packet {\n\tu8 byte[4];\n} __attribute__ ((packed));\n\nenum { USB_PKT_LEN = sizeof(struct cm109_ctl_packet) };\n\n \nstruct cm109_dev {\n\tstruct input_dev *idev;\t  \n\tstruct usb_device *udev;  \n\tstruct usb_interface *intf;\n\n\t \n\tstruct cm109_ctl_packet *irq_data;\n\tdma_addr_t irq_dma;\n\tstruct urb *urb_irq;\n\n\t \n\tstruct cm109_ctl_packet *ctl_data;\n\tdma_addr_t ctl_dma;\n\tstruct usb_ctrlrequest *ctl_req;\n\tstruct urb *urb_ctl;\n\t \n\tunsigned irq_urb_pending:1;\t \n\tunsigned ctl_urb_pending:1;\t \n\tunsigned buzzer_pending:1;\t \n\tspinlock_t ctl_submit_lock;\n\n\tunsigned char buzzer_state;\t \n\n\t \n\tunsigned open:1;\n\tunsigned resetting:1;\n\tunsigned shutdown:1;\n\n\t \n\tstruct mutex pm_mutex;\n\n\tunsigned short keymap[KEYMAP_SIZE];\n\n\tchar phys[64];\t\t \n\tint key_code;\t\t \n\tint keybit;\t\t \n\tu8 gpi;\t\t\t \n};\n\n \n\nstatic unsigned short special_keymap(int code)\n{\n\tif (code > 0xff) {\n\t\tswitch (code - 0xff) {\n\t\tcase RECORD_MUTE:\treturn KEY_MICMUTE;\n\t\tcase PLAYBACK_MUTE:\treturn KEY_MUTE;\n\t\tcase VOLUME_DOWN:\treturn KEY_VOLUMEDOWN;\n\t\tcase VOLUME_UP:\t\treturn KEY_VOLUMEUP;\n\t\t}\n\t}\n\treturn KEY_RESERVED;\n}\n\n \nstatic unsigned short keymap_kip1000(int scancode)\n{\n\tswitch (scancode) {\t\t\t\t \n\tcase 0x82: return KEY_NUMERIC_0;\t\t \n\tcase 0x14: return KEY_NUMERIC_1;\t\t \n\tcase 0x12: return KEY_NUMERIC_2;\t\t \n\tcase 0x11: return KEY_NUMERIC_3;\t\t \n\tcase 0x24: return KEY_NUMERIC_4;\t\t \n\tcase 0x22: return KEY_NUMERIC_5;\t\t \n\tcase 0x21: return KEY_NUMERIC_6;\t\t \n\tcase 0x44: return KEY_NUMERIC_7;\t\t \n\tcase 0x42: return KEY_NUMERIC_8;\t\t \n\tcase 0x41: return KEY_NUMERIC_9;\t\t \n\tcase 0x81: return KEY_NUMERIC_POUND;\t\t \n\tcase 0x84: return KEY_NUMERIC_STAR;\t\t \n\tcase 0x88: return KEY_ENTER;\t\t\t \n\tcase 0x48: return KEY_ESC;\t\t\t \n\tcase 0x28: return KEY_LEFT;\t\t\t \n\tcase 0x18: return KEY_RIGHT;\t\t\t \n\tdefault:   return special_keymap(scancode);\n\t}\n}\n\n \nstatic unsigned short keymap_gtalk(int scancode)\n{\n\tswitch (scancode) {\n\tcase 0x11: return KEY_NUMERIC_0;\n\tcase 0x21: return KEY_NUMERIC_1;\n\tcase 0x41: return KEY_NUMERIC_2;\n\tcase 0x81: return KEY_NUMERIC_3;\n\tcase 0x12: return KEY_NUMERIC_4;\n\tcase 0x22: return KEY_NUMERIC_5;\n\tcase 0x42: return KEY_NUMERIC_6;\n\tcase 0x82: return KEY_NUMERIC_7;\n\tcase 0x14: return KEY_NUMERIC_8;\n\tcase 0x24: return KEY_NUMERIC_9;\n\tcase 0x44: return KEY_NUMERIC_POUND;\t \n\tcase 0x84: return KEY_NUMERIC_STAR;\t \n\tcase 0x18: return KEY_ENTER;\t\t \n\tcase 0x28: return KEY_ESC;\t\t \n\tcase 0x48: return KEY_UP;\t\t \n\tcase 0x88: return KEY_DOWN;\t\t \n\tdefault:   return special_keymap(scancode);\n\t}\n}\n\n \nstatic unsigned short keymap_usbph01(int scancode)\n{\n\tswitch (scancode) {\n\tcase 0x11: return KEY_NUMERIC_0;\t\t \n\tcase 0x21: return KEY_NUMERIC_1;\t\t \n\tcase 0x41: return KEY_NUMERIC_2;\t\t \n\tcase 0x81: return KEY_NUMERIC_3;\t\t \n\tcase 0x12: return KEY_NUMERIC_4;\t\t \n\tcase 0x22: return KEY_NUMERIC_5;\t\t \n\tcase 0x42: return KEY_NUMERIC_6;\t\t \n\tcase 0x82: return KEY_NUMERIC_7;\t\t \n\tcase 0x14: return KEY_NUMERIC_8;\t\t \n\tcase 0x24: return KEY_NUMERIC_9;\t\t \n\tcase 0x44: return KEY_NUMERIC_POUND;\t\t \n\tcase 0x84: return KEY_NUMERIC_STAR;\t\t \n\tcase 0x18: return KEY_ENTER;\t\t\t \n\tcase 0x28: return KEY_ESC;\t\t\t \n\tcase 0x48: return KEY_LEFT;\t\t\t \n\tcase 0x88: return KEY_RIGHT;\t\t\t \n\tdefault:   return special_keymap(scancode);\n\t}\n}\n\n \nstatic unsigned short keymap_atcom(int scancode)\n{\n\tswitch (scancode) {\t\t\t\t \n\tcase 0x82: return KEY_NUMERIC_0;\t\t \n\tcase 0x11: return KEY_NUMERIC_1;\t\t \n\tcase 0x12: return KEY_NUMERIC_2;\t\t \n\tcase 0x14: return KEY_NUMERIC_3;\t\t \n\tcase 0x21: return KEY_NUMERIC_4;\t\t \n\tcase 0x22: return KEY_NUMERIC_5;\t\t \n\tcase 0x24: return KEY_NUMERIC_6;\t\t \n\tcase 0x41: return KEY_NUMERIC_7;\t\t \n\tcase 0x42: return KEY_NUMERIC_8;\t\t \n\tcase 0x44: return KEY_NUMERIC_9;\t\t \n\tcase 0x84: return KEY_NUMERIC_POUND;\t\t \n\tcase 0x81: return KEY_NUMERIC_STAR;\t\t \n\tcase 0x18: return KEY_ENTER;\t\t\t \n\tcase 0x28: return KEY_ESC;\t\t\t \n\tcase 0x48: return KEY_LEFT;\t\t\t \n\tcase 0x88: return KEY_RIGHT;\t\t\t \n\tdefault:   return special_keymap(scancode);\n\t}\n}\n\nstatic unsigned short (*keymap)(int) = keymap_kip1000;\n\n \nstatic void report_key(struct cm109_dev *dev, int key)\n{\n\tstruct input_dev *idev = dev->idev;\n\n\tif (dev->key_code >= 0) {\n\t\t \n\t\tinput_report_key(idev, dev->key_code, 0);\n\t}\n\n\tdev->key_code = key;\n\tif (key >= 0) {\n\t\t \n\t\tinput_report_key(idev, key, 1);\n\t}\n\n\tinput_sync(idev);\n}\n\n \nstatic void cm109_report_special(struct cm109_dev *dev)\n{\n\tstatic const u8 autorelease = RECORD_MUTE | PLAYBACK_MUTE;\n\tstruct input_dev *idev = dev->idev;\n\tu8 data = dev->irq_data->byte[HID_IR0];\n\tunsigned short keycode;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tkeycode = dev->keymap[0xff + BIT(i)];\n\t\tif (keycode == KEY_RESERVED)\n\t\t\tcontinue;\n\n\t\tinput_report_key(idev, keycode, data & BIT(i));\n\t\tif (data & autorelease & BIT(i)) {\n\t\t\tinput_sync(idev);\n\t\t\tinput_report_key(idev, keycode, 0);\n\t\t}\n\t}\n\tinput_sync(idev);\n}\n\n \n\nstatic void cm109_submit_buzz_toggle(struct cm109_dev *dev)\n{\n\tint error;\n\n\tif (dev->buzzer_state)\n\t\tdev->ctl_data->byte[HID_OR0] |= BUZZER_ON;\n\telse\n\t\tdev->ctl_data->byte[HID_OR0] &= ~BUZZER_ON;\n\n\terror = usb_submit_urb(dev->urb_ctl, GFP_ATOMIC);\n\tif (error)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: usb_submit_urb (urb_ctl) failed %d\\n\",\n\t\t\t__func__, error);\n}\n\n \nstatic void cm109_urb_irq_callback(struct urb *urb)\n{\n\tstruct cm109_dev *dev = urb->context;\n\tconst int status = urb->status;\n\tint error;\n\tunsigned long flags;\n\n\tdev_dbg(&dev->intf->dev, \"### URB IRQ: [0x%02x 0x%02x 0x%02x 0x%02x] keybit=0x%02x\\n\",\n\t     dev->irq_data->byte[0],\n\t     dev->irq_data->byte[1],\n\t     dev->irq_data->byte[2],\n\t     dev->irq_data->byte[3],\n\t     dev->keybit);\n\n\tif (status) {\n\t\tif (status == -ESHUTDOWN)\n\t\t\treturn;\n\t\tdev_err_ratelimited(&dev->intf->dev, \"%s: urb status %d\\n\",\n\t\t\t\t    __func__, status);\n\t\tgoto out;\n\t}\n\n\t \n\tcm109_report_special(dev);\n\n\t \n\tif (dev->keybit == 0xf) {\n\n\t\t \n\t\tif ((dev->gpi & 0xf0) == (dev->irq_data->byte[HID_IR1] & 0xf0))\n\t\t\tgoto out;\n\n\t\tdev->gpi = dev->irq_data->byte[HID_IR1] & 0xf0;\n\t\tdev->keybit = 0x1;\n\t} else {\n\t\treport_key(dev, dev->keymap[dev->irq_data->byte[HID_IR1]]);\n\n\t\tdev->keybit <<= 1;\n\t\tif (dev->keybit > 0x8)\n\t\t\tdev->keybit = 0xf;\n\t}\n\n out:\n\n\tspin_lock_irqsave(&dev->ctl_submit_lock, flags);\n\n\tdev->irq_urb_pending = 0;\n\n\tif (likely(!dev->shutdown)) {\n\n\t\tif (dev->buzzer_state)\n\t\t\tdev->ctl_data->byte[HID_OR0] |= BUZZER_ON;\n\t\telse\n\t\t\tdev->ctl_data->byte[HID_OR0] &= ~BUZZER_ON;\n\n\t\tdev->ctl_data->byte[HID_OR1] = dev->keybit;\n\t\tdev->ctl_data->byte[HID_OR2] = dev->keybit;\n\n\t\tdev->buzzer_pending = 0;\n\t\tdev->ctl_urb_pending = 1;\n\n\t\terror = usb_submit_urb(dev->urb_ctl, GFP_ATOMIC);\n\t\tif (error)\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"%s: usb_submit_urb (urb_ctl) failed %d\\n\",\n\t\t\t\t__func__, error);\n\t}\n\n\tspin_unlock_irqrestore(&dev->ctl_submit_lock, flags);\n}\n\nstatic void cm109_urb_ctl_callback(struct urb *urb)\n{\n\tstruct cm109_dev *dev = urb->context;\n\tconst int status = urb->status;\n\tint error;\n\tunsigned long flags;\n\n\tdev_dbg(&dev->intf->dev, \"### URB CTL: [0x%02x 0x%02x 0x%02x 0x%02x]\\n\",\n\t     dev->ctl_data->byte[0],\n\t     dev->ctl_data->byte[1],\n\t     dev->ctl_data->byte[2],\n\t     dev->ctl_data->byte[3]);\n\n\tif (status) {\n\t\tif (status == -ESHUTDOWN)\n\t\t\treturn;\n\t\tdev_err_ratelimited(&dev->intf->dev, \"%s: urb status %d\\n\",\n\t\t\t\t    __func__, status);\n\t}\n\n\tspin_lock_irqsave(&dev->ctl_submit_lock, flags);\n\n\tdev->ctl_urb_pending = 0;\n\n\tif (likely(!dev->shutdown)) {\n\n\t\tif (dev->buzzer_pending || status) {\n\t\t\tdev->buzzer_pending = 0;\n\t\t\tdev->ctl_urb_pending = 1;\n\t\t\tcm109_submit_buzz_toggle(dev);\n\t\t} else if (likely(!dev->irq_urb_pending)) {\n\t\t\t \n\t\t\tdev->irq_urb_pending = 1;\n\t\t\terror = usb_submit_urb(dev->urb_irq, GFP_ATOMIC);\n\t\t\tif (error)\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"%s: usb_submit_urb (urb_irq) failed %d\\n\",\n\t\t\t\t\t__func__, error);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->ctl_submit_lock, flags);\n}\n\nstatic void cm109_toggle_buzzer_async(struct cm109_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->ctl_submit_lock, flags);\n\n\tif (dev->ctl_urb_pending) {\n\t\t \n\t\tdev->buzzer_pending = 1;\n\t} else {\n\t\tdev->ctl_urb_pending = 1;\n\t\tcm109_submit_buzz_toggle(dev);\n\t}\n\n\tspin_unlock_irqrestore(&dev->ctl_submit_lock, flags);\n}\n\nstatic void cm109_toggle_buzzer_sync(struct cm109_dev *dev, int on)\n{\n\tint error;\n\n\tif (on)\n\t\tdev->ctl_data->byte[HID_OR0] |= BUZZER_ON;\n\telse\n\t\tdev->ctl_data->byte[HID_OR0] &= ~BUZZER_ON;\n\n\terror = usb_control_msg(dev->udev,\n\t\t\t\tusb_sndctrlpipe(dev->udev, 0),\n\t\t\t\tdev->ctl_req->bRequest,\n\t\t\t\tdev->ctl_req->bRequestType,\n\t\t\t\tle16_to_cpu(dev->ctl_req->wValue),\n\t\t\t\tle16_to_cpu(dev->ctl_req->wIndex),\n\t\t\t\tdev->ctl_data,\n\t\t\t\tUSB_PKT_LEN, USB_CTRL_SET_TIMEOUT);\n\tif (error < 0 && error != -EINTR)\n\t\tdev_err(&dev->intf->dev, \"%s: usb_control_msg() failed %d\\n\",\n\t\t\t__func__, error);\n}\n\nstatic void cm109_stop_traffic(struct cm109_dev *dev)\n{\n\tdev->shutdown = 1;\n\t \n\tsmp_wmb();\n\n\tusb_kill_urb(dev->urb_ctl);\n\tusb_kill_urb(dev->urb_irq);\n\n\tcm109_toggle_buzzer_sync(dev, 0);\n\n\tdev->shutdown = 0;\n\tsmp_wmb();\n}\n\nstatic void cm109_restore_state(struct cm109_dev *dev)\n{\n\tif (dev->open) {\n\t\t \n\t\tcm109_toggle_buzzer_async(dev);\n\t}\n}\n\n \n\nstatic int cm109_input_open(struct input_dev *idev)\n{\n\tstruct cm109_dev *dev = input_get_drvdata(idev);\n\tint error;\n\n\terror = usb_autopm_get_interface(dev->intf);\n\tif (error < 0) {\n\t\tdev_err(&idev->dev, \"%s - cannot autoresume, result %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\tmutex_lock(&dev->pm_mutex);\n\n\tdev->buzzer_state = 0;\n\tdev->key_code = -1;\t \n\tdev->keybit = 0xf;\n\n\t \n\tdev->ctl_data->byte[HID_OR0] = HID_OR_GPO_BUZ_SPDIF;\n\tdev->ctl_data->byte[HID_OR1] = dev->keybit;\n\tdev->ctl_data->byte[HID_OR2] = dev->keybit;\n\tdev->ctl_data->byte[HID_OR3] = 0x00;\n\n\tdev->ctl_urb_pending = 1;\n\terror = usb_submit_urb(dev->urb_ctl, GFP_KERNEL);\n\tif (error) {\n\t\tdev->ctl_urb_pending = 0;\n\t\tdev_err(&dev->intf->dev, \"%s: usb_submit_urb (urb_ctl) failed %d\\n\",\n\t\t\t__func__, error);\n\t} else {\n\t\tdev->open = 1;\n\t}\n\n\tmutex_unlock(&dev->pm_mutex);\n\n\tif (error)\n\t\tusb_autopm_put_interface(dev->intf);\n\n\treturn error;\n}\n\nstatic void cm109_input_close(struct input_dev *idev)\n{\n\tstruct cm109_dev *dev = input_get_drvdata(idev);\n\n\tmutex_lock(&dev->pm_mutex);\n\n\t \n\tcm109_stop_traffic(dev);\n\tdev->open = 0;\n\n\tmutex_unlock(&dev->pm_mutex);\n\n\tusb_autopm_put_interface(dev->intf);\n}\n\nstatic int cm109_input_ev(struct input_dev *idev, unsigned int type,\n\t\t\t  unsigned int code, int value)\n{\n\tstruct cm109_dev *dev = input_get_drvdata(idev);\n\n\tdev_dbg(&dev->intf->dev,\n\t\t\"input_ev: type=%u code=%u value=%d\\n\", type, code, value);\n\n\tif (type != EV_SND)\n\t\treturn -EINVAL;\n\n\tswitch (code) {\n\tcase SND_TONE:\n\tcase SND_BELL:\n\t\tdev->buzzer_state = !!value;\n\t\tif (!dev->resetting)\n\t\t\tcm109_toggle_buzzer_async(dev);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n\n \n\nstruct driver_info {\n\tchar *name;\n};\n\nstatic const struct driver_info info_cm109 = {\n\t.name = \"CM109 USB driver\",\n};\n\nenum {\n\tVENDOR_ID        = 0x0d8c,  \n\tPRODUCT_ID_CM109 = 0x000e,  \n};\n\n \nstatic const struct usb_device_id cm109_usb_table[] = {\n\t{\n\t\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE |\n\t\t\t\tUSB_DEVICE_ID_MATCH_INT_INFO,\n\t\t.idVendor = VENDOR_ID,\n\t\t.idProduct = PRODUCT_ID_CM109,\n\t\t.bInterfaceClass = USB_CLASS_HID,\n\t\t.bInterfaceSubClass = 0,\n\t\t.bInterfaceProtocol = 0,\n\t\t.driver_info = (kernel_ulong_t) &info_cm109\n\t},\n\t \n\t{ }\n};\n\nstatic void cm109_usb_cleanup(struct cm109_dev *dev)\n{\n\tkfree(dev->ctl_req);\n\tusb_free_coherent(dev->udev, USB_PKT_LEN, dev->ctl_data, dev->ctl_dma);\n\tusb_free_coherent(dev->udev, USB_PKT_LEN, dev->irq_data, dev->irq_dma);\n\n\tusb_free_urb(dev->urb_irq);\t \n\tusb_free_urb(dev->urb_ctl);\t \n\tkfree(dev);\n}\n\nstatic void cm109_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct cm109_dev *dev = usb_get_intfdata(interface);\n\n\tusb_set_intfdata(interface, NULL);\n\tinput_unregister_device(dev->idev);\n\tcm109_usb_cleanup(dev);\n}\n\nstatic int cm109_usb_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct driver_info *nfo = (struct driver_info *)id->driver_info;\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct cm109_dev *dev;\n\tstruct input_dev *input_dev = NULL;\n\tint ret, pipe, i;\n\tint error = -ENOMEM;\n\n\tinterface = intf->cur_altsetting;\n\n\tif (interface->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tendpoint = &interface->endpoint[0].desc;\n\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -ENODEV;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->ctl_submit_lock);\n\tmutex_init(&dev->pm_mutex);\n\n\tdev->udev = udev;\n\tdev->intf = intf;\n\n\tdev->idev = input_dev = input_allocate_device();\n\tif (!input_dev)\n\t\tgoto err_out;\n\n\t \n\tdev->irq_data = usb_alloc_coherent(udev, USB_PKT_LEN,\n\t\t\t\t\t   GFP_KERNEL, &dev->irq_dma);\n\tif (!dev->irq_data)\n\t\tgoto err_out;\n\n\tdev->ctl_data = usb_alloc_coherent(udev, USB_PKT_LEN,\n\t\t\t\t\t   GFP_KERNEL, &dev->ctl_dma);\n\tif (!dev->ctl_data)\n\t\tgoto err_out;\n\n\tdev->ctl_req = kmalloc(sizeof(*(dev->ctl_req)), GFP_KERNEL);\n\tif (!dev->ctl_req)\n\t\tgoto err_out;\n\n\t \n\tdev->urb_irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb_irq)\n\t\tgoto err_out;\n\n\tdev->urb_ctl = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb_ctl)\n\t\tgoto err_out;\n\n\t \n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\tret = usb_maxpacket(udev, pipe);\n\tif (ret != USB_PKT_LEN)\n\t\tdev_err(&intf->dev, \"invalid payload size %d, expected %d\\n\",\n\t\t\tret, USB_PKT_LEN);\n\n\t \n\tusb_fill_int_urb(dev->urb_irq, udev, pipe, dev->irq_data,\n\t\t\t USB_PKT_LEN,\n\t\t\t cm109_urb_irq_callback, dev, endpoint->bInterval);\n\tdev->urb_irq->transfer_dma = dev->irq_dma;\n\tdev->urb_irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tdev->urb_irq->dev = udev;\n\n\t \n\tdev->ctl_req->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE |\n\t\t\t\t\tUSB_DIR_OUT;\n\tdev->ctl_req->bRequest = USB_REQ_SET_CONFIGURATION;\n\tdev->ctl_req->wValue = cpu_to_le16(0x200);\n\tdev->ctl_req->wIndex = cpu_to_le16(interface->desc.bInterfaceNumber);\n\tdev->ctl_req->wLength = cpu_to_le16(USB_PKT_LEN);\n\n\tusb_fill_control_urb(dev->urb_ctl, udev, usb_sndctrlpipe(udev, 0),\n\t\t\t     (void *)dev->ctl_req, dev->ctl_data, USB_PKT_LEN,\n\t\t\t     cm109_urb_ctl_callback, dev);\n\tdev->urb_ctl->transfer_dma = dev->ctl_dma;\n\tdev->urb_ctl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tdev->urb_ctl->dev = udev;\n\n\t \n\tusb_make_path(udev, dev->phys, sizeof(dev->phys));\n\tstrlcat(dev->phys, \"/input0\", sizeof(dev->phys));\n\n\t \n\tinput_dev->name = nfo->name;\n\tinput_dev->phys = dev->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, dev);\n\tinput_dev->open = cm109_input_open;\n\tinput_dev->close = cm109_input_close;\n\tinput_dev->event = cm109_input_ev;\n\n\tinput_dev->keycode = dev->keymap;\n\tinput_dev->keycodesize = sizeof(unsigned char);\n\tinput_dev->keycodemax = ARRAY_SIZE(dev->keymap);\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_SND);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\n\t \n\tfor (i = 0; i < KEYMAP_SIZE; i++) {\n\t\tunsigned short k = keymap(i);\n\t\tdev->keymap[i] = k;\n\t\t__set_bit(k, input_dev->keybit);\n\t}\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\terror = input_register_device(dev->idev);\n\tif (error)\n\t\tgoto err_out;\n\n\tusb_set_intfdata(intf, dev);\n\n\treturn 0;\n\n err_out:\n\tinput_free_device(input_dev);\n\tcm109_usb_cleanup(dev);\n\treturn error;\n}\n\nstatic int cm109_usb_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct cm109_dev *dev = usb_get_intfdata(intf);\n\n\tdev_info(&intf->dev, \"cm109: usb_suspend (event=%d)\\n\", message.event);\n\n\tmutex_lock(&dev->pm_mutex);\n\tcm109_stop_traffic(dev);\n\tmutex_unlock(&dev->pm_mutex);\n\n\treturn 0;\n}\n\nstatic int cm109_usb_resume(struct usb_interface *intf)\n{\n\tstruct cm109_dev *dev = usb_get_intfdata(intf);\n\n\tdev_info(&intf->dev, \"cm109: usb_resume\\n\");\n\n\tmutex_lock(&dev->pm_mutex);\n\tcm109_restore_state(dev);\n\tmutex_unlock(&dev->pm_mutex);\n\n\treturn 0;\n}\n\nstatic int cm109_usb_pre_reset(struct usb_interface *intf)\n{\n\tstruct cm109_dev *dev = usb_get_intfdata(intf);\n\n\tmutex_lock(&dev->pm_mutex);\n\n\t \n\tdev->resetting = 1;\n\tsmp_wmb();\n\n\tcm109_stop_traffic(dev);\n\n\treturn 0;\n}\n\nstatic int cm109_usb_post_reset(struct usb_interface *intf)\n{\n\tstruct cm109_dev *dev = usb_get_intfdata(intf);\n\n\tdev->resetting = 0;\n\tsmp_wmb();\n\n\tcm109_restore_state(dev);\n\n\tmutex_unlock(&dev->pm_mutex);\n\n\treturn 0;\n}\n\nstatic struct usb_driver cm109_driver = {\n\t.name\t\t= \"cm109\",\n\t.probe\t\t= cm109_usb_probe,\n\t.disconnect\t= cm109_usb_disconnect,\n\t.suspend\t= cm109_usb_suspend,\n\t.resume\t\t= cm109_usb_resume,\n\t.reset_resume\t= cm109_usb_resume,\n\t.pre_reset\t= cm109_usb_pre_reset,\n\t.post_reset\t= cm109_usb_post_reset,\n\t.id_table\t= cm109_usb_table,\n\t.supports_autosuspend = 1,\n};\n\nstatic int __init cm109_select_keymap(void)\n{\n\t \n\tif (!strcasecmp(phone, \"kip1000\")) {\n\t\tkeymap = keymap_kip1000;\n\t\tprintk(KERN_INFO KBUILD_MODNAME \": \"\n\t\t\t\"Keymap for Komunikate KIP1000 phone loaded\\n\");\n\t} else if (!strcasecmp(phone, \"gtalk\")) {\n\t\tkeymap = keymap_gtalk;\n\t\tprintk(KERN_INFO KBUILD_MODNAME \": \"\n\t\t\t\"Keymap for Genius G-talk phone loaded\\n\");\n\t} else if (!strcasecmp(phone, \"usbph01\")) {\n\t\tkeymap = keymap_usbph01;\n\t\tprintk(KERN_INFO KBUILD_MODNAME \": \"\n\t\t\t\"Keymap for Allied-Telesis Corega USBPH01 phone loaded\\n\");\n\t} else if (!strcasecmp(phone, \"atcom\")) {\n\t\tkeymap = keymap_atcom;\n\t\tprintk(KERN_INFO KBUILD_MODNAME \": \"\n\t\t\t\"Keymap for ATCom AU-100 phone loaded\\n\");\n\t} else {\n\t\tprintk(KERN_ERR KBUILD_MODNAME \": \"\n\t\t\t\"Unsupported phone: %s\\n\", phone);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init cm109_init(void)\n{\n\tint err;\n\n\terr = cm109_select_keymap();\n\tif (err)\n\t\treturn err;\n\n\terr = usb_register(&cm109_driver);\n\tif (err)\n\t\treturn err;\n\n\tprintk(KERN_INFO KBUILD_MODNAME \": \"\n\t\tDRIVER_DESC \": \" DRIVER_VERSION \" (C) \" DRIVER_AUTHOR \"\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit cm109_exit(void)\n{\n\tusb_deregister(&cm109_driver);\n}\n\nmodule_init(cm109_init);\nmodule_exit(cm109_exit);\n\nMODULE_DEVICE_TABLE(usb, cm109_usb_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}