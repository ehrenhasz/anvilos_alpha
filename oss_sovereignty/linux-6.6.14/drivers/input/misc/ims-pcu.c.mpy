{
  "module_name": "ims-pcu.c",
  "hash_id": "8098c0f08a45aa9d6d2a22362fb152e9fc0713fbc1ad1d4189dab9ea97637095",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/ims-pcu.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/ihex.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/usb/input.h>\n#include <linux/usb/cdc.h>\n#include <asm/unaligned.h>\n\n#define IMS_PCU_KEYMAP_LEN\t\t32\n\nstruct ims_pcu_buttons {\n\tstruct input_dev *input;\n\tchar name[32];\n\tchar phys[32];\n\tunsigned short keymap[IMS_PCU_KEYMAP_LEN];\n};\n\nstruct ims_pcu_gamepad {\n\tstruct input_dev *input;\n\tchar name[32];\n\tchar phys[32];\n};\n\nstruct ims_pcu_backlight {\n\tstruct led_classdev cdev;\n\tchar name[32];\n};\n\n#define IMS_PCU_PART_NUMBER_LEN\t\t15\n#define IMS_PCU_SERIAL_NUMBER_LEN\t8\n#define IMS_PCU_DOM_LEN\t\t\t8\n#define IMS_PCU_FW_VERSION_LEN\t\t(9 + 1)\n#define IMS_PCU_BL_VERSION_LEN\t\t(9 + 1)\n#define IMS_PCU_BL_RESET_REASON_LEN\t(2 + 1)\n\n#define IMS_PCU_PCU_B_DEVICE_ID\t\t5\n\n#define IMS_PCU_BUF_SIZE\t\t128\n\nstruct ims_pcu {\n\tstruct usb_device *udev;\n\tstruct device *dev;  \n\n\tunsigned int device_no;\n\n\tbool bootloader_mode;\n\n\tchar part_number[IMS_PCU_PART_NUMBER_LEN];\n\tchar serial_number[IMS_PCU_SERIAL_NUMBER_LEN];\n\tchar date_of_manufacturing[IMS_PCU_DOM_LEN];\n\tchar fw_version[IMS_PCU_FW_VERSION_LEN];\n\tchar bl_version[IMS_PCU_BL_VERSION_LEN];\n\tchar reset_reason[IMS_PCU_BL_RESET_REASON_LEN];\n\tint update_firmware_status;\n\tu8 device_id;\n\n\tu8 ofn_reg_addr;\n\n\tstruct usb_interface *ctrl_intf;\n\n\tstruct usb_endpoint_descriptor *ep_ctrl;\n\tstruct urb *urb_ctrl;\n\tu8 *urb_ctrl_buf;\n\tdma_addr_t ctrl_dma;\n\tsize_t max_ctrl_size;\n\n\tstruct usb_interface *data_intf;\n\n\tstruct usb_endpoint_descriptor *ep_in;\n\tstruct urb *urb_in;\n\tu8 *urb_in_buf;\n\tdma_addr_t read_dma;\n\tsize_t max_in_size;\n\n\tstruct usb_endpoint_descriptor *ep_out;\n\tu8 *urb_out_buf;\n\tsize_t max_out_size;\n\n\tu8 read_buf[IMS_PCU_BUF_SIZE];\n\tu8 read_pos;\n\tu8 check_sum;\n\tbool have_stx;\n\tbool have_dle;\n\n\tu8 cmd_buf[IMS_PCU_BUF_SIZE];\n\tu8 ack_id;\n\tu8 expected_response;\n\tu8 cmd_buf_len;\n\tstruct completion cmd_done;\n\tstruct mutex cmd_mutex;\n\n\tu32 fw_start_addr;\n\tu32 fw_end_addr;\n\tstruct completion async_firmware_done;\n\n\tstruct ims_pcu_buttons buttons;\n\tstruct ims_pcu_gamepad *gamepad;\n\tstruct ims_pcu_backlight backlight;\n\n\tbool setup_complete;  \n};\n\n\n \n\nstatic const unsigned short ims_pcu_keymap_1[] = {\n\t[1] = KEY_ATTENDANT_OFF,\n\t[2] = KEY_ATTENDANT_ON,\n\t[3] = KEY_LIGHTS_TOGGLE,\n\t[4] = KEY_VOLUMEUP,\n\t[5] = KEY_VOLUMEDOWN,\n\t[6] = KEY_INFO,\n};\n\nstatic const unsigned short ims_pcu_keymap_2[] = {\n\t[4] = KEY_VOLUMEUP,\n\t[5] = KEY_VOLUMEDOWN,\n\t[6] = KEY_INFO,\n};\n\nstatic const unsigned short ims_pcu_keymap_3[] = {\n\t[1] = KEY_HOMEPAGE,\n\t[2] = KEY_ATTENDANT_TOGGLE,\n\t[3] = KEY_LIGHTS_TOGGLE,\n\t[4] = KEY_VOLUMEUP,\n\t[5] = KEY_VOLUMEDOWN,\n\t[6] = KEY_DISPLAYTOGGLE,\n\t[18] = KEY_PLAYPAUSE,\n};\n\nstatic const unsigned short ims_pcu_keymap_4[] = {\n\t[1] = KEY_ATTENDANT_OFF,\n\t[2] = KEY_ATTENDANT_ON,\n\t[3] = KEY_LIGHTS_TOGGLE,\n\t[4] = KEY_VOLUMEUP,\n\t[5] = KEY_VOLUMEDOWN,\n\t[6] = KEY_INFO,\n\t[18] = KEY_PLAYPAUSE,\n};\n\nstatic const unsigned short ims_pcu_keymap_5[] = {\n\t[1] = KEY_ATTENDANT_OFF,\n\t[2] = KEY_ATTENDANT_ON,\n\t[3] = KEY_LIGHTS_TOGGLE,\n};\n\nstruct ims_pcu_device_info {\n\tconst unsigned short *keymap;\n\tsize_t keymap_len;\n\tbool has_gamepad;\n};\n\n#define IMS_PCU_DEVINFO(_n, _gamepad)\t\t\t\t\\\n\t[_n] = {\t\t\t\t\t\t\\\n\t\t.keymap = ims_pcu_keymap_##_n,\t\t\t\\\n\t\t.keymap_len = ARRAY_SIZE(ims_pcu_keymap_##_n),\t\\\n\t\t.has_gamepad = _gamepad,\t\t\t\\\n\t}\n\nstatic const struct ims_pcu_device_info ims_pcu_device_info[] = {\n\tIMS_PCU_DEVINFO(1, true),\n\tIMS_PCU_DEVINFO(2, true),\n\tIMS_PCU_DEVINFO(3, true),\n\tIMS_PCU_DEVINFO(4, true),\n\tIMS_PCU_DEVINFO(5, false),\n};\n\nstatic void ims_pcu_buttons_report(struct ims_pcu *pcu, u32 data)\n{\n\tstruct ims_pcu_buttons *buttons = &pcu->buttons;\n\tstruct input_dev *input = buttons->input;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tunsigned short keycode = buttons->keymap[i];\n\n\t\tif (keycode != KEY_RESERVED)\n\t\t\tinput_report_key(input, keycode, data & (1UL << i));\n\t}\n\n\tinput_sync(input);\n}\n\nstatic int ims_pcu_setup_buttons(struct ims_pcu *pcu,\n\t\t\t\t const unsigned short *keymap,\n\t\t\t\t size_t keymap_len)\n{\n\tstruct ims_pcu_buttons *buttons = &pcu->buttons;\n\tstruct input_dev *input;\n\tint i;\n\tint error;\n\n\tinput = input_allocate_device();\n\tif (!input) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Not enough memory for input input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(buttons->name, sizeof(buttons->name),\n\t\t \"IMS PCU#%d Button Interface\", pcu->device_no);\n\n\tusb_make_path(pcu->udev, buttons->phys, sizeof(buttons->phys));\n\tstrlcat(buttons->phys, \"/input0\", sizeof(buttons->phys));\n\n\tmemcpy(buttons->keymap, keymap, sizeof(*keymap) * keymap_len);\n\n\tinput->name = buttons->name;\n\tinput->phys = buttons->phys;\n\tusb_to_input_id(pcu->udev, &input->id);\n\tinput->dev.parent = &pcu->ctrl_intf->dev;\n\n\tinput->keycode = buttons->keymap;\n\tinput->keycodemax = ARRAY_SIZE(buttons->keymap);\n\tinput->keycodesize = sizeof(buttons->keymap[0]);\n\n\t__set_bit(EV_KEY, input->evbit);\n\tfor (i = 0; i < IMS_PCU_KEYMAP_LEN; i++)\n\t\t__set_bit(buttons->keymap[i], input->keybit);\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to register buttons input device: %d\\n\",\n\t\t\terror);\n\t\tinput_free_device(input);\n\t\treturn error;\n\t}\n\n\tbuttons->input = input;\n\treturn 0;\n}\n\nstatic void ims_pcu_destroy_buttons(struct ims_pcu *pcu)\n{\n\tstruct ims_pcu_buttons *buttons = &pcu->buttons;\n\n\tinput_unregister_device(buttons->input);\n}\n\n\n \n\nstatic void ims_pcu_gamepad_report(struct ims_pcu *pcu, u32 data)\n{\n\tstruct ims_pcu_gamepad *gamepad = pcu->gamepad;\n\tstruct input_dev *input = gamepad->input;\n\tint x, y;\n\n\tx = !!(data & (1 << 14)) - !!(data & (1 << 13));\n\ty = !!(data & (1 << 12)) - !!(data & (1 << 11));\n\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\n\tinput_report_key(input, BTN_A, data & (1 << 7));\n\tinput_report_key(input, BTN_B, data & (1 << 8));\n\tinput_report_key(input, BTN_X, data & (1 << 9));\n\tinput_report_key(input, BTN_Y, data & (1 << 10));\n\tinput_report_key(input, BTN_START, data & (1 << 15));\n\tinput_report_key(input, BTN_SELECT, data & (1 << 16));\n\n\tinput_sync(input);\n}\n\nstatic int ims_pcu_setup_gamepad(struct ims_pcu *pcu)\n{\n\tstruct ims_pcu_gamepad *gamepad;\n\tstruct input_dev *input;\n\tint error;\n\n\tgamepad = kzalloc(sizeof(struct ims_pcu_gamepad), GFP_KERNEL);\n\tinput = input_allocate_device();\n\tif (!gamepad || !input) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Not enough memory for gamepad device\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tgamepad->input = input;\n\n\tsnprintf(gamepad->name, sizeof(gamepad->name),\n\t\t \"IMS PCU#%d Gamepad Interface\", pcu->device_no);\n\n\tusb_make_path(pcu->udev, gamepad->phys, sizeof(gamepad->phys));\n\tstrlcat(gamepad->phys, \"/input1\", sizeof(gamepad->phys));\n\n\tinput->name = gamepad->name;\n\tinput->phys = gamepad->phys;\n\tusb_to_input_id(pcu->udev, &input->id);\n\tinput->dev.parent = &pcu->ctrl_intf->dev;\n\n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(BTN_A, input->keybit);\n\t__set_bit(BTN_B, input->keybit);\n\t__set_bit(BTN_X, input->keybit);\n\t__set_bit(BTN_Y, input->keybit);\n\t__set_bit(BTN_START, input->keybit);\n\t__set_bit(BTN_SELECT, input->keybit);\n\n\t__set_bit(EV_ABS, input->evbit);\n\tinput_set_abs_params(input, ABS_X, -1, 1, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, -1, 1, 0, 0);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to register gamepad input device: %d\\n\",\n\t\t\terror);\n\t\tgoto err_free_mem;\n\t}\n\n\tpcu->gamepad = gamepad;\n\treturn 0;\n\nerr_free_mem:\n\tinput_free_device(input);\n\tkfree(gamepad);\n\treturn error;\n}\n\nstatic void ims_pcu_destroy_gamepad(struct ims_pcu *pcu)\n{\n\tstruct ims_pcu_gamepad *gamepad = pcu->gamepad;\n\n\tinput_unregister_device(gamepad->input);\n\tkfree(gamepad);\n}\n\n\n \n\n#define IMS_PCU_PROTOCOL_STX\t\t0x02\n#define IMS_PCU_PROTOCOL_ETX\t\t0x03\n#define IMS_PCU_PROTOCOL_DLE\t\t0x10\n\n \n#define IMS_PCU_CMD_STATUS\t\t0xa0\n#define IMS_PCU_CMD_PCU_RESET\t\t0xa1\n#define IMS_PCU_CMD_RESET_REASON\t0xa2\n#define IMS_PCU_CMD_SEND_BUTTONS\t0xa3\n#define IMS_PCU_CMD_JUMP_TO_BTLDR\t0xa4\n#define IMS_PCU_CMD_GET_INFO\t\t0xa5\n#define IMS_PCU_CMD_SET_BRIGHTNESS\t0xa6\n#define IMS_PCU_CMD_EEPROM\t\t0xa7\n#define IMS_PCU_CMD_GET_FW_VERSION\t0xa8\n#define IMS_PCU_CMD_GET_BL_VERSION\t0xa9\n#define IMS_PCU_CMD_SET_INFO\t\t0xab\n#define IMS_PCU_CMD_GET_BRIGHTNESS\t0xac\n#define IMS_PCU_CMD_GET_DEVICE_ID\t0xae\n#define IMS_PCU_CMD_SPECIAL_INFO\t0xb0\n#define IMS_PCU_CMD_BOOTLOADER\t\t0xb1\t \n#define IMS_PCU_CMD_OFN_SET_CONFIG\t0xb3\n#define IMS_PCU_CMD_OFN_GET_CONFIG\t0xb4\n\n \n#define IMS_PCU_RSP_STATUS\t\t0xc0\n#define IMS_PCU_RSP_PCU_RESET\t\t0\t \n#define IMS_PCU_RSP_RESET_REASON\t0xc2\n#define IMS_PCU_RSP_SEND_BUTTONS\t0xc3\n#define IMS_PCU_RSP_JUMP_TO_BTLDR\t0\t \n#define IMS_PCU_RSP_GET_INFO\t\t0xc5\n#define IMS_PCU_RSP_SET_BRIGHTNESS\t0xc6\n#define IMS_PCU_RSP_EEPROM\t\t0xc7\n#define IMS_PCU_RSP_GET_FW_VERSION\t0xc8\n#define IMS_PCU_RSP_GET_BL_VERSION\t0xc9\n#define IMS_PCU_RSP_SET_INFO\t\t0xcb\n#define IMS_PCU_RSP_GET_BRIGHTNESS\t0xcc\n#define IMS_PCU_RSP_CMD_INVALID\t\t0xcd\n#define IMS_PCU_RSP_GET_DEVICE_ID\t0xce\n#define IMS_PCU_RSP_SPECIAL_INFO\t0xd0\n#define IMS_PCU_RSP_BOOTLOADER\t\t0xd1\t \n#define IMS_PCU_RSP_OFN_SET_CONFIG\t0xd2\n#define IMS_PCU_RSP_OFN_GET_CONFIG\t0xd3\n\n\n#define IMS_PCU_RSP_EVNT_BUTTONS\t0xe0\t \n#define IMS_PCU_GAMEPAD_MASK\t\t0x0001ff80UL\t \n\n\n#define IMS_PCU_MIN_PACKET_LEN\t\t3\n#define IMS_PCU_DATA_OFFSET\t\t2\n\n#define IMS_PCU_CMD_WRITE_TIMEOUT\t100  \n#define IMS_PCU_CMD_RESPONSE_TIMEOUT\t500  \n\nstatic void ims_pcu_report_events(struct ims_pcu *pcu)\n{\n\tu32 data = get_unaligned_be32(&pcu->read_buf[3]);\n\n\tims_pcu_buttons_report(pcu, data & ~IMS_PCU_GAMEPAD_MASK);\n\tif (pcu->gamepad)\n\t\tims_pcu_gamepad_report(pcu, data);\n}\n\nstatic void ims_pcu_handle_response(struct ims_pcu *pcu)\n{\n\tswitch (pcu->read_buf[0]) {\n\tcase IMS_PCU_RSP_EVNT_BUTTONS:\n\t\tif (likely(pcu->setup_complete))\n\t\t\tims_pcu_report_events(pcu);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (pcu->read_buf[0] == pcu->expected_response &&\n\t\t    pcu->read_buf[1] == pcu->ack_id - 1) {\n\n\t\t\tmemcpy(pcu->cmd_buf, pcu->read_buf, pcu->read_pos);\n\t\t\tpcu->cmd_buf_len = pcu->read_pos;\n\t\t\tcomplete(&pcu->cmd_done);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void ims_pcu_process_data(struct ims_pcu *pcu, struct urb *urb)\n{\n\tint i;\n\n\tfor (i = 0; i < urb->actual_length; i++) {\n\t\tu8 data = pcu->urb_in_buf[i];\n\n\t\t \n\t\tif (!pcu->have_stx && data != IMS_PCU_PROTOCOL_STX)\n\t\t\tcontinue;\n\n\t\tif (pcu->have_dle) {\n\t\t\tpcu->have_dle = false;\n\t\t\tpcu->read_buf[pcu->read_pos++] = data;\n\t\t\tpcu->check_sum += data;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (data) {\n\t\tcase IMS_PCU_PROTOCOL_STX:\n\t\t\tif (pcu->have_stx)\n\t\t\t\tdev_warn(pcu->dev,\n\t\t\t\t\t \"Unexpected STX at byte %d, discarding old data\\n\",\n\t\t\t\t\t pcu->read_pos);\n\t\t\tpcu->have_stx = true;\n\t\t\tpcu->have_dle = false;\n\t\t\tpcu->read_pos = 0;\n\t\t\tpcu->check_sum = 0;\n\t\t\tbreak;\n\n\t\tcase IMS_PCU_PROTOCOL_DLE:\n\t\t\tpcu->have_dle = true;\n\t\t\tbreak;\n\n\t\tcase IMS_PCU_PROTOCOL_ETX:\n\t\t\tif (pcu->read_pos < IMS_PCU_MIN_PACKET_LEN) {\n\t\t\t\tdev_warn(pcu->dev,\n\t\t\t\t\t \"Short packet received (%d bytes), ignoring\\n\",\n\t\t\t\t\t pcu->read_pos);\n\t\t\t} else if (pcu->check_sum != 0) {\n\t\t\t\tdev_warn(pcu->dev,\n\t\t\t\t\t \"Invalid checksum in packet (%d bytes), ignoring\\n\",\n\t\t\t\t\t pcu->read_pos);\n\t\t\t} else {\n\t\t\t\tims_pcu_handle_response(pcu);\n\t\t\t}\n\n\t\t\tpcu->have_stx = false;\n\t\t\tpcu->have_dle = false;\n\t\t\tpcu->read_pos = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpcu->read_buf[pcu->read_pos++] = data;\n\t\t\tpcu->check_sum += data;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool ims_pcu_byte_needs_escape(u8 byte)\n{\n\treturn byte == IMS_PCU_PROTOCOL_STX ||\n\t       byte == IMS_PCU_PROTOCOL_ETX ||\n\t       byte == IMS_PCU_PROTOCOL_DLE;\n}\n\nstatic int ims_pcu_send_cmd_chunk(struct ims_pcu *pcu,\n\t\t\t\t  u8 command, int chunk, int len)\n{\n\tint error;\n\n\terror = usb_bulk_msg(pcu->udev,\n\t\t\t     usb_sndbulkpipe(pcu->udev,\n\t\t\t\t\t     pcu->ep_out->bEndpointAddress),\n\t\t\t     pcu->urb_out_buf, len,\n\t\t\t     NULL, IMS_PCU_CMD_WRITE_TIMEOUT);\n\tif (error < 0) {\n\t\tdev_dbg(pcu->dev,\n\t\t\t\"Sending 0x%02x command failed at chunk %d: %d\\n\",\n\t\t\tcommand, chunk, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ims_pcu_send_command(struct ims_pcu *pcu,\n\t\t\t\tu8 command, const u8 *data, int len)\n{\n\tint count = 0;\n\tint chunk = 0;\n\tint delta;\n\tint i;\n\tint error;\n\tu8 csum = 0;\n\tu8 ack_id;\n\n\tpcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_STX;\n\n\t \n\tpcu->urb_out_buf[count++] = command;\n\tcsum += command;\n\n\tack_id = pcu->ack_id++;\n\tif (ack_id == 0xff)\n\t\tack_id = pcu->ack_id++;\n\n\tif (ims_pcu_byte_needs_escape(ack_id))\n\t\tpcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_DLE;\n\n\tpcu->urb_out_buf[count++] = ack_id;\n\tcsum += ack_id;\n\n\tfor (i = 0; i < len; i++) {\n\n\t\tdelta = ims_pcu_byte_needs_escape(data[i]) ? 2 : 1;\n\t\tif (count + delta >= pcu->max_out_size) {\n\t\t\terror = ims_pcu_send_cmd_chunk(pcu, command,\n\t\t\t\t\t\t       ++chunk, count);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tcount = 0;\n\t\t}\n\n\t\tif (delta == 2)\n\t\t\tpcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_DLE;\n\n\t\tpcu->urb_out_buf[count++] = data[i];\n\t\tcsum += data[i];\n\t}\n\n\tcsum = 1 + ~csum;\n\n\tdelta = ims_pcu_byte_needs_escape(csum) ? 3 : 2;\n\tif (count + delta >= pcu->max_out_size) {\n\t\terror = ims_pcu_send_cmd_chunk(pcu, command, ++chunk, count);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tcount = 0;\n\t}\n\n\tif (delta == 3)\n\t\tpcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_DLE;\n\n\tpcu->urb_out_buf[count++] = csum;\n\tpcu->urb_out_buf[count++] = IMS_PCU_PROTOCOL_ETX;\n\n\treturn ims_pcu_send_cmd_chunk(pcu, command, ++chunk, count);\n}\n\nstatic int __ims_pcu_execute_command(struct ims_pcu *pcu,\n\t\t\t\t     u8 command, const void *data, size_t len,\n\t\t\t\t     u8 expected_response, int response_time)\n{\n\tint error;\n\n\tpcu->expected_response = expected_response;\n\tinit_completion(&pcu->cmd_done);\n\n\terror = ims_pcu_send_command(pcu, command, data, len);\n\tif (error)\n\t\treturn error;\n\n\tif (expected_response &&\n\t    !wait_for_completion_timeout(&pcu->cmd_done,\n\t\t\t\t\t msecs_to_jiffies(response_time))) {\n\t\tdev_dbg(pcu->dev, \"Command 0x%02x timed out\\n\", command);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n#define ims_pcu_execute_command(pcu, code, data, len)\t\t\t\\\n\t__ims_pcu_execute_command(pcu,\t\t\t\t\t\\\n\t\t\t\t  IMS_PCU_CMD_##code, data, len,\t\\\n\t\t\t\t  IMS_PCU_RSP_##code,\t\t\t\\\n\t\t\t\t  IMS_PCU_CMD_RESPONSE_TIMEOUT)\n\n#define ims_pcu_execute_query(pcu, code)\t\t\t\t\\\n\tims_pcu_execute_command(pcu, code, NULL, 0)\n\n \n#define IMS_PCU_BL_CMD_QUERY_DEVICE\t0xa1\n#define IMS_PCU_BL_CMD_UNLOCK_CONFIG\t0xa2\n#define IMS_PCU_BL_CMD_ERASE_APP\t0xa3\n#define IMS_PCU_BL_CMD_PROGRAM_DEVICE\t0xa4\n#define IMS_PCU_BL_CMD_PROGRAM_COMPLETE\t0xa5\n#define IMS_PCU_BL_CMD_READ_APP\t\t0xa6\n#define IMS_PCU_BL_CMD_RESET_DEVICE\t0xa7\n#define IMS_PCU_BL_CMD_LAUNCH_APP\t0xa8\n\n \n#define IMS_PCU_BL_RSP_QUERY_DEVICE\t0xc1\n#define IMS_PCU_BL_RSP_UNLOCK_CONFIG\t0xc2\n#define IMS_PCU_BL_RSP_ERASE_APP\t0xc3\n#define IMS_PCU_BL_RSP_PROGRAM_DEVICE\t0xc4\n#define IMS_PCU_BL_RSP_PROGRAM_COMPLETE\t0xc5\n#define IMS_PCU_BL_RSP_READ_APP\t\t0xc6\n#define IMS_PCU_BL_RSP_RESET_DEVICE\t0\t \n#define IMS_PCU_BL_RSP_LAUNCH_APP\t0\t \n\n#define IMS_PCU_BL_DATA_OFFSET\t\t3\n\nstatic int __ims_pcu_execute_bl_command(struct ims_pcu *pcu,\n\t\t\t\t\tu8 command, const void *data, size_t len,\n\t\t\t\t\tu8 expected_response, int response_time)\n{\n\tint error;\n\n\tpcu->cmd_buf[0] = command;\n\tif (data)\n\t\tmemcpy(&pcu->cmd_buf[1], data, len);\n\n\terror = __ims_pcu_execute_command(pcu,\n\t\t\t\tIMS_PCU_CMD_BOOTLOADER, pcu->cmd_buf, len + 1,\n\t\t\t\texpected_response ? IMS_PCU_RSP_BOOTLOADER : 0,\n\t\t\t\tresponse_time);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failure when sending 0x%02x command to bootloader, error: %d\\n\",\n\t\t\tpcu->cmd_buf[0], error);\n\t\treturn error;\n\t}\n\n\tif (expected_response && pcu->cmd_buf[2] != expected_response) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Unexpected response from bootloader: 0x%02x, wanted 0x%02x\\n\",\n\t\t\tpcu->cmd_buf[2], expected_response);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define ims_pcu_execute_bl_command(pcu, code, data, len, timeout)\t\\\n\t__ims_pcu_execute_bl_command(pcu,\t\t\t\t\\\n\t\t\t\t     IMS_PCU_BL_CMD_##code, data, len,\t\\\n\t\t\t\t     IMS_PCU_BL_RSP_##code, timeout)\t\\\n\n#define IMS_PCU_INFO_PART_OFFSET\t2\n#define IMS_PCU_INFO_DOM_OFFSET\t\t17\n#define IMS_PCU_INFO_SERIAL_OFFSET\t25\n\n#define IMS_PCU_SET_INFO_SIZE\t\t31\n\nstatic int ims_pcu_get_info(struct ims_pcu *pcu)\n{\n\tint error;\n\n\terror = ims_pcu_execute_query(pcu, GET_INFO);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"GET_INFO command failed, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmemcpy(pcu->part_number,\n\t       &pcu->cmd_buf[IMS_PCU_INFO_PART_OFFSET],\n\t       sizeof(pcu->part_number));\n\tmemcpy(pcu->date_of_manufacturing,\n\t       &pcu->cmd_buf[IMS_PCU_INFO_DOM_OFFSET],\n\t       sizeof(pcu->date_of_manufacturing));\n\tmemcpy(pcu->serial_number,\n\t       &pcu->cmd_buf[IMS_PCU_INFO_SERIAL_OFFSET],\n\t       sizeof(pcu->serial_number));\n\n\treturn 0;\n}\n\nstatic int ims_pcu_set_info(struct ims_pcu *pcu)\n{\n\tint error;\n\n\tmemcpy(&pcu->cmd_buf[IMS_PCU_INFO_PART_OFFSET],\n\t       pcu->part_number, sizeof(pcu->part_number));\n\tmemcpy(&pcu->cmd_buf[IMS_PCU_INFO_DOM_OFFSET],\n\t       pcu->date_of_manufacturing, sizeof(pcu->date_of_manufacturing));\n\tmemcpy(&pcu->cmd_buf[IMS_PCU_INFO_SERIAL_OFFSET],\n\t       pcu->serial_number, sizeof(pcu->serial_number));\n\n\terror = ims_pcu_execute_command(pcu, SET_INFO,\n\t\t\t\t\t&pcu->cmd_buf[IMS_PCU_DATA_OFFSET],\n\t\t\t\t\tIMS_PCU_SET_INFO_SIZE);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to update device information, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ims_pcu_switch_to_bootloader(struct ims_pcu *pcu)\n{\n\tint error;\n\n\t \n\terror = ims_pcu_execute_command(pcu, JUMP_TO_BTLDR, NULL, 0);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failure when sending JUMP TO BOOTLOADER command, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define IMS_PCU_FIRMWARE_NAME\t\"imspcu.fw\"\n\nstruct ims_pcu_flash_fmt {\n\t__le32 addr;\n\tu8 len;\n\tu8 data[];\n};\n\nstatic unsigned int ims_pcu_count_fw_records(const struct firmware *fw)\n{\n\tconst struct ihex_binrec *rec = (const struct ihex_binrec *)fw->data;\n\tunsigned int count = 0;\n\n\twhile (rec) {\n\t\tcount++;\n\t\trec = ihex_next_binrec(rec);\n\t}\n\n\treturn count;\n}\n\nstatic int ims_pcu_verify_block(struct ims_pcu *pcu,\n\t\t\t\tu32 addr, u8 len, const u8 *data)\n{\n\tstruct ims_pcu_flash_fmt *fragment;\n\tint error;\n\n\tfragment = (void *)&pcu->cmd_buf[1];\n\tput_unaligned_le32(addr, &fragment->addr);\n\tfragment->len = len;\n\n\terror = ims_pcu_execute_bl_command(pcu, READ_APP, NULL, 5,\n\t\t\t\t\tIMS_PCU_CMD_RESPONSE_TIMEOUT);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to retrieve block at 0x%08x, len %d, error: %d\\n\",\n\t\t\taddr, len, error);\n\t\treturn error;\n\t}\n\n\tfragment = (void *)&pcu->cmd_buf[IMS_PCU_BL_DATA_OFFSET];\n\tif (get_unaligned_le32(&fragment->addr) != addr ||\n\t    fragment->len != len) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Wrong block when retrieving 0x%08x (0x%08x), len %d (%d)\\n\",\n\t\t\taddr, get_unaligned_le32(&fragment->addr),\n\t\t\tlen, fragment->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(fragment->data, data, len)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Mismatch in block at 0x%08x, len %d\\n\",\n\t\t\taddr, len);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ims_pcu_flash_firmware(struct ims_pcu *pcu,\n\t\t\t\t  const struct firmware *fw,\n\t\t\t\t  unsigned int n_fw_records)\n{\n\tconst struct ihex_binrec *rec = (const struct ihex_binrec *)fw->data;\n\tstruct ims_pcu_flash_fmt *fragment;\n\tunsigned int count = 0;\n\tu32 addr;\n\tu8 len;\n\tint error;\n\n\terror = ims_pcu_execute_bl_command(pcu, ERASE_APP, NULL, 0, 2000);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to erase application image, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\twhile (rec) {\n\t\t \n\t\taddr = be32_to_cpu(rec->addr) / 2;\n\t\tlen = be16_to_cpu(rec->len);\n\n\t\tfragment = (void *)&pcu->cmd_buf[1];\n\t\tput_unaligned_le32(addr, &fragment->addr);\n\t\tfragment->len = len;\n\t\tmemcpy(fragment->data, rec->data, len);\n\n\t\terror = ims_pcu_execute_bl_command(pcu, PROGRAM_DEVICE,\n\t\t\t\t\t\tNULL, len + 5,\n\t\t\t\t\t\tIMS_PCU_CMD_RESPONSE_TIMEOUT);\n\t\tif (error) {\n\t\t\tdev_err(pcu->dev,\n\t\t\t\t\"Failed to write block at 0x%08x, len %d, error: %d\\n\",\n\t\t\t\taddr, len, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (addr >= pcu->fw_start_addr && addr < pcu->fw_end_addr) {\n\t\t\terror = ims_pcu_verify_block(pcu, addr, len, rec->data);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tcount++;\n\t\tpcu->update_firmware_status = (count * 100) / n_fw_records;\n\n\t\trec = ihex_next_binrec(rec);\n\t}\n\n\terror = ims_pcu_execute_bl_command(pcu, PROGRAM_COMPLETE,\n\t\t\t\t\t    NULL, 0, 2000);\n\tif (error)\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to send PROGRAM_COMPLETE, error: %d\\n\",\n\t\t\terror);\n\n\treturn 0;\n}\n\nstatic int ims_pcu_handle_firmware_update(struct ims_pcu *pcu,\n\t\t\t\t\t  const struct firmware *fw)\n{\n\tunsigned int n_fw_records;\n\tint retval;\n\n\tdev_info(pcu->dev, \"Updating firmware %s, size: %zu\\n\",\n\t\t IMS_PCU_FIRMWARE_NAME, fw->size);\n\n\tn_fw_records = ims_pcu_count_fw_records(fw);\n\n\tretval = ims_pcu_flash_firmware(pcu, fw, n_fw_records);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = ims_pcu_execute_bl_command(pcu, LAUNCH_APP, NULL, 0, 0);\n\tif (retval)\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to start application image, error: %d\\n\",\n\t\t\tretval);\n\nout:\n\tpcu->update_firmware_status = retval;\n\tsysfs_notify(&pcu->dev->kobj, NULL, \"update_firmware_status\");\n\treturn retval;\n}\n\nstatic void ims_pcu_process_async_firmware(const struct firmware *fw,\n\t\t\t\t\t   void *context)\n{\n\tstruct ims_pcu *pcu = context;\n\tint error;\n\n\tif (!fw) {\n\t\tdev_err(pcu->dev, \"Failed to get firmware %s\\n\",\n\t\t\tIMS_PCU_FIRMWARE_NAME);\n\t\tgoto out;\n\t}\n\n\terror = ihex_validate_fw(fw);\n\tif (error) {\n\t\tdev_err(pcu->dev, \"Firmware %s is invalid\\n\",\n\t\t\tIMS_PCU_FIRMWARE_NAME);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&pcu->cmd_mutex);\n\tims_pcu_handle_firmware_update(pcu, fw);\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\trelease_firmware(fw);\n\nout:\n\tcomplete(&pcu->async_firmware_done);\n}\n\n \n\n#define IMS_PCU_MAX_BRIGHTNESS\t\t31998\n\nstatic int ims_pcu_backlight_set_brightness(struct led_classdev *cdev,\n\t\t\t\t\t    enum led_brightness value)\n{\n\tstruct ims_pcu_backlight *backlight =\n\t\t\tcontainer_of(cdev, struct ims_pcu_backlight, cdev);\n\tstruct ims_pcu *pcu =\n\t\t\tcontainer_of(backlight, struct ims_pcu, backlight);\n\t__le16 br_val = cpu_to_le16(value);\n\tint error;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\n\terror = ims_pcu_execute_command(pcu, SET_BRIGHTNESS,\n\t\t\t\t\t&br_val, sizeof(br_val));\n\tif (error && error != -ENODEV)\n\t\tdev_warn(pcu->dev,\n\t\t\t \"Failed to set desired brightness %u, error: %d\\n\",\n\t\t\t value, error);\n\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn error;\n}\n\nstatic enum led_brightness\nims_pcu_backlight_get_brightness(struct led_classdev *cdev)\n{\n\tstruct ims_pcu_backlight *backlight =\n\t\t\tcontainer_of(cdev, struct ims_pcu_backlight, cdev);\n\tstruct ims_pcu *pcu =\n\t\t\tcontainer_of(backlight, struct ims_pcu, backlight);\n\tint brightness;\n\tint error;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\n\terror = ims_pcu_execute_query(pcu, GET_BRIGHTNESS);\n\tif (error) {\n\t\tdev_warn(pcu->dev,\n\t\t\t \"Failed to get current brightness, error: %d\\n\",\n\t\t\t error);\n\t\t \n\t\tbrightness = LED_OFF;\n\t} else {\n\t\tbrightness =\n\t\t\tget_unaligned_le16(&pcu->cmd_buf[IMS_PCU_DATA_OFFSET]);\n\t}\n\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn brightness;\n}\n\nstatic int ims_pcu_setup_backlight(struct ims_pcu *pcu)\n{\n\tstruct ims_pcu_backlight *backlight = &pcu->backlight;\n\tint error;\n\n\tsnprintf(backlight->name, sizeof(backlight->name),\n\t\t \"pcu%d::kbd_backlight\", pcu->device_no);\n\n\tbacklight->cdev.name = backlight->name;\n\tbacklight->cdev.max_brightness = IMS_PCU_MAX_BRIGHTNESS;\n\tbacklight->cdev.brightness_get = ims_pcu_backlight_get_brightness;\n\tbacklight->cdev.brightness_set_blocking =\n\t\t\t\t\t ims_pcu_backlight_set_brightness;\n\n\terror = led_classdev_register(pcu->dev, &backlight->cdev);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to register backlight LED device, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void ims_pcu_destroy_backlight(struct ims_pcu *pcu)\n{\n\tstruct ims_pcu_backlight *backlight = &pcu->backlight;\n\n\tled_classdev_unregister(&backlight->cdev);\n}\n\n\n \n\nstruct ims_pcu_attribute {\n\tstruct device_attribute dattr;\n\tsize_t field_offset;\n\tint field_length;\n};\n\nstatic ssize_t ims_pcu_attribute_show(struct device *dev,\n\t\t\t\t      struct device_attribute *dattr,\n\t\t\t\t      char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct ims_pcu_attribute *attr =\n\t\t\tcontainer_of(dattr, struct ims_pcu_attribute, dattr);\n\tchar *field = (char *)pcu + attr->field_offset;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%.*s\\n\", attr->field_length, field);\n}\n\nstatic ssize_t ims_pcu_attribute_store(struct device *dev,\n\t\t\t\t       struct device_attribute *dattr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct ims_pcu_attribute *attr =\n\t\t\tcontainer_of(dattr, struct ims_pcu_attribute, dattr);\n\tchar *field = (char *)pcu + attr->field_offset;\n\tsize_t data_len;\n\tint error;\n\n\tif (count > attr->field_length)\n\t\treturn -EINVAL;\n\n\tdata_len = strnlen(buf, attr->field_length);\n\tif (data_len > attr->field_length)\n\t\treturn -EINVAL;\n\n\terror = mutex_lock_interruptible(&pcu->cmd_mutex);\n\tif (error)\n\t\treturn error;\n\n\tmemset(field, 0, attr->field_length);\n\tmemcpy(field, buf, data_len);\n\n\terror = ims_pcu_set_info(pcu);\n\n\t \n\tims_pcu_get_info(pcu);\n\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn error < 0 ? error : count;\n}\n\n#define IMS_PCU_ATTR(_field, _mode)\t\t\t\t\t\\\nstruct ims_pcu_attribute ims_pcu_attr_##_field = {\t\t\t\\\n\t.dattr = __ATTR(_field, _mode,\t\t\t\t\t\\\n\t\t\tims_pcu_attribute_show,\t\t\t\t\\\n\t\t\tims_pcu_attribute_store),\t\t\t\\\n\t.field_offset = offsetof(struct ims_pcu, _field),\t\t\\\n\t.field_length = sizeof(((struct ims_pcu *)NULL)->_field),\t\\\n}\n\n#define IMS_PCU_RO_ATTR(_field)\t\t\t\t\t\t\\\n\t\tIMS_PCU_ATTR(_field, S_IRUGO)\n#define IMS_PCU_RW_ATTR(_field)\t\t\t\t\t\t\\\n\t\tIMS_PCU_ATTR(_field, S_IRUGO | S_IWUSR)\n\nstatic IMS_PCU_RW_ATTR(part_number);\nstatic IMS_PCU_RW_ATTR(serial_number);\nstatic IMS_PCU_RW_ATTR(date_of_manufacturing);\n\nstatic IMS_PCU_RO_ATTR(fw_version);\nstatic IMS_PCU_RO_ATTR(bl_version);\nstatic IMS_PCU_RO_ATTR(reset_reason);\n\nstatic ssize_t ims_pcu_reset_device(struct device *dev,\n\t\t\t\t    struct device_attribute *dattr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstatic const u8 reset_byte = 1;\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tint value;\n\tint error;\n\n\terror = kstrtoint(buf, 0, &value);\n\tif (error)\n\t\treturn error;\n\n\tif (value != 1)\n\t\treturn -EINVAL;\n\n\tdev_info(pcu->dev, \"Attempting to reset device\\n\");\n\n\terror = ims_pcu_execute_command(pcu, PCU_RESET, &reset_byte, 1);\n\tif (error) {\n\t\tdev_info(pcu->dev,\n\t\t\t \"Failed to reset device, error: %d\\n\",\n\t\t\t error);\n\t\treturn error;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(reset_device, S_IWUSR, NULL, ims_pcu_reset_device);\n\nstatic ssize_t ims_pcu_update_firmware_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *dattr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tconst struct firmware *fw = NULL;\n\tint value;\n\tint error;\n\n\terror = kstrtoint(buf, 0, &value);\n\tif (error)\n\t\treturn error;\n\n\tif (value != 1)\n\t\treturn -EINVAL;\n\n\terror = mutex_lock_interruptible(&pcu->cmd_mutex);\n\tif (error)\n\t\treturn error;\n\n\terror = request_ihex_firmware(&fw, IMS_PCU_FIRMWARE_NAME, pcu->dev);\n\tif (error) {\n\t\tdev_err(pcu->dev, \"Failed to request firmware %s, error: %d\\n\",\n\t\t\tIMS_PCU_FIRMWARE_NAME, error);\n\t\tgoto out;\n\t}\n\n\t \n\tif (pcu->bootloader_mode)\n\t\terror = ims_pcu_handle_firmware_update(pcu, fw);\n\telse\n\t\terror = ims_pcu_switch_to_bootloader(pcu);\n\n\trelease_firmware(fw);\n\nout:\n\tmutex_unlock(&pcu->cmd_mutex);\n\treturn error ?: count;\n}\n\nstatic DEVICE_ATTR(update_firmware, S_IWUSR,\n\t\t   NULL, ims_pcu_update_firmware_store);\n\nstatic ssize_t\nims_pcu_update_firmware_status_show(struct device *dev,\n\t\t\t\t    struct device_attribute *dattr,\n\t\t\t\t    char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", pcu->update_firmware_status);\n}\n\nstatic DEVICE_ATTR(update_firmware_status, S_IRUGO,\n\t\t   ims_pcu_update_firmware_status_show, NULL);\n\nstatic struct attribute *ims_pcu_attrs[] = {\n\t&ims_pcu_attr_part_number.dattr.attr,\n\t&ims_pcu_attr_serial_number.dattr.attr,\n\t&ims_pcu_attr_date_of_manufacturing.dattr.attr,\n\t&ims_pcu_attr_fw_version.dattr.attr,\n\t&ims_pcu_attr_bl_version.dattr.attr,\n\t&ims_pcu_attr_reset_reason.dattr.attr,\n\t&dev_attr_reset_device.attr,\n\t&dev_attr_update_firmware.attr,\n\t&dev_attr_update_firmware_status.attr,\n\tNULL\n};\n\nstatic umode_t ims_pcu_is_attr_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tumode_t mode = attr->mode;\n\n\tif (pcu->bootloader_mode) {\n\t\tif (attr != &dev_attr_update_firmware_status.attr &&\n\t\t    attr != &dev_attr_update_firmware.attr &&\n\t\t    attr != &dev_attr_reset_device.attr) {\n\t\t\tmode = 0;\n\t\t}\n\t} else {\n\t\tif (attr == &dev_attr_update_firmware_status.attr)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct attribute_group ims_pcu_attr_group = {\n\t.is_visible\t= ims_pcu_is_attr_visible,\n\t.attrs\t\t= ims_pcu_attrs,\n};\n\n \n\n#define OFN_REG_RESULT_OFFSET\t2\n\nstatic int ims_pcu_read_ofn_config(struct ims_pcu *pcu, u8 addr, u8 *data)\n{\n\tint error;\n\ts16 result;\n\n\terror = ims_pcu_execute_command(pcu, OFN_GET_CONFIG,\n\t\t\t\t\t&addr, sizeof(addr));\n\tif (error)\n\t\treturn error;\n\n\tresult = (s16)get_unaligned_le16(pcu->cmd_buf + OFN_REG_RESULT_OFFSET);\n\tif (result < 0)\n\t\treturn -EIO;\n\n\t \n\t*data = pcu->cmd_buf[OFN_REG_RESULT_OFFSET];\n\treturn 0;\n}\n\nstatic int ims_pcu_write_ofn_config(struct ims_pcu *pcu, u8 addr, u8 data)\n{\n\tu8 buffer[] = { addr, data };\n\tint error;\n\ts16 result;\n\n\terror = ims_pcu_execute_command(pcu, OFN_SET_CONFIG,\n\t\t\t\t\t&buffer, sizeof(buffer));\n\tif (error)\n\t\treturn error;\n\n\tresult = (s16)get_unaligned_le16(pcu->cmd_buf + OFN_REG_RESULT_OFFSET);\n\tif (result < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic ssize_t ims_pcu_ofn_reg_data_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *dattr,\n\t\t\t\t\t char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tint error;\n\tu8 data;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\terror = ims_pcu_read_ofn_config(pcu, pcu->ofn_reg_addr, &data);\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\tif (error)\n\t\treturn error;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%x\\n\", data);\n}\n\nstatic ssize_t ims_pcu_ofn_reg_data_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *dattr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tint error;\n\tu8 value;\n\n\terror = kstrtou8(buf, 0, &value);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\terror = ims_pcu_write_ofn_config(pcu, pcu->ofn_reg_addr, value);\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn error ?: count;\n}\n\nstatic DEVICE_ATTR(reg_data, S_IRUGO | S_IWUSR,\n\t\t   ims_pcu_ofn_reg_data_show, ims_pcu_ofn_reg_data_store);\n\nstatic ssize_t ims_pcu_ofn_reg_addr_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *dattr,\n\t\t\t\t\t char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tint error;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\terror = scnprintf(buf, PAGE_SIZE, \"%x\\n\", pcu->ofn_reg_addr);\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn error;\n}\n\nstatic ssize_t ims_pcu_ofn_reg_addr_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *dattr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tint error;\n\tu8 value;\n\n\terror = kstrtou8(buf, 0, &value);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\tpcu->ofn_reg_addr = value;\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(reg_addr, S_IRUGO | S_IWUSR,\n\t\t   ims_pcu_ofn_reg_addr_show, ims_pcu_ofn_reg_addr_store);\n\nstruct ims_pcu_ofn_bit_attribute {\n\tstruct device_attribute dattr;\n\tu8 addr;\n\tu8 nr;\n};\n\nstatic ssize_t ims_pcu_ofn_bit_show(struct device *dev,\n\t\t\t\t    struct device_attribute *dattr,\n\t\t\t\t    char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct ims_pcu_ofn_bit_attribute *attr =\n\t\tcontainer_of(dattr, struct ims_pcu_ofn_bit_attribute, dattr);\n\tint error;\n\tu8 data;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\terror = ims_pcu_read_ofn_config(pcu, attr->addr, &data);\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\tif (error)\n\t\treturn error;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", !!(data & (1 << attr->nr)));\n}\n\nstatic ssize_t ims_pcu_ofn_bit_store(struct device *dev,\n\t\t\t\t     struct device_attribute *dattr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct ims_pcu_ofn_bit_attribute *attr =\n\t\tcontainer_of(dattr, struct ims_pcu_ofn_bit_attribute, dattr);\n\tint error;\n\tint value;\n\tu8 data;\n\n\terror = kstrtoint(buf, 0, &value);\n\tif (error)\n\t\treturn error;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pcu->cmd_mutex);\n\n\terror = ims_pcu_read_ofn_config(pcu, attr->addr, &data);\n\tif (!error) {\n\t\tif (value)\n\t\t\tdata |= 1U << attr->nr;\n\t\telse\n\t\t\tdata &= ~(1U << attr->nr);\n\n\t\terror = ims_pcu_write_ofn_config(pcu, attr->addr, data);\n\t}\n\n\tmutex_unlock(&pcu->cmd_mutex);\n\n\treturn error ?: count;\n}\n\n#define IMS_PCU_OFN_BIT_ATTR(_field, _addr, _nr)\t\t\t\\\nstruct ims_pcu_ofn_bit_attribute ims_pcu_ofn_attr_##_field = {\t\t\\\n\t.dattr = __ATTR(_field, S_IWUSR | S_IRUGO,\t\t\t\\\n\t\t\tims_pcu_ofn_bit_show, ims_pcu_ofn_bit_store),\t\\\n\t.addr = _addr,\t\t\t\t\t\t\t\\\n\t.nr = _nr,\t\t\t\t\t\t\t\\\n}\n\nstatic IMS_PCU_OFN_BIT_ATTR(engine_enable,   0x60, 7);\nstatic IMS_PCU_OFN_BIT_ATTR(speed_enable,    0x60, 6);\nstatic IMS_PCU_OFN_BIT_ATTR(assert_enable,   0x60, 5);\nstatic IMS_PCU_OFN_BIT_ATTR(xyquant_enable,  0x60, 4);\nstatic IMS_PCU_OFN_BIT_ATTR(xyscale_enable,  0x60, 1);\n\nstatic IMS_PCU_OFN_BIT_ATTR(scale_x2,        0x63, 6);\nstatic IMS_PCU_OFN_BIT_ATTR(scale_y2,        0x63, 7);\n\nstatic struct attribute *ims_pcu_ofn_attrs[] = {\n\t&dev_attr_reg_data.attr,\n\t&dev_attr_reg_addr.attr,\n\t&ims_pcu_ofn_attr_engine_enable.dattr.attr,\n\t&ims_pcu_ofn_attr_speed_enable.dattr.attr,\n\t&ims_pcu_ofn_attr_assert_enable.dattr.attr,\n\t&ims_pcu_ofn_attr_xyquant_enable.dattr.attr,\n\t&ims_pcu_ofn_attr_xyscale_enable.dattr.attr,\n\t&ims_pcu_ofn_attr_scale_x2.dattr.attr,\n\t&ims_pcu_ofn_attr_scale_y2.dattr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ims_pcu_ofn_attr_group = {\n\t.name\t= \"ofn\",\n\t.attrs\t= ims_pcu_ofn_attrs,\n};\n\nstatic void ims_pcu_irq(struct urb *urb)\n{\n\tstruct ims_pcu *pcu = urb->context;\n\tint retval, status;\n\n\tstatus = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(pcu->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(pcu->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(pcu->dev, \"%s: received %d: %*ph\\n\", __func__,\n\t\turb->actual_length, urb->actual_length, pcu->urb_in_buf);\n\n\tif (urb == pcu->urb_in)\n\t\tims_pcu_process_data(pcu, urb);\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval && retval != -ENODEV)\n\t\tdev_err(pcu->dev, \"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic int ims_pcu_buffers_alloc(struct ims_pcu *pcu)\n{\n\tint error;\n\n\tpcu->urb_in_buf = usb_alloc_coherent(pcu->udev, pcu->max_in_size,\n\t\t\t\t\t     GFP_KERNEL, &pcu->read_dma);\n\tif (!pcu->urb_in_buf) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to allocate memory for read buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpcu->urb_in = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pcu->urb_in) {\n\t\tdev_err(pcu->dev, \"Failed to allocate input URB\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb_in_buf;\n\t}\n\n\tpcu->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tpcu->urb_in->transfer_dma = pcu->read_dma;\n\n\tusb_fill_bulk_urb(pcu->urb_in, pcu->udev,\n\t\t\t  usb_rcvbulkpipe(pcu->udev,\n\t\t\t\t\t  pcu->ep_in->bEndpointAddress),\n\t\t\t  pcu->urb_in_buf, pcu->max_in_size,\n\t\t\t  ims_pcu_irq, pcu);\n\n\t \n\tpcu->urb_out_buf = kmalloc(pcu->max_out_size, GFP_KERNEL);\n\tif (!pcu->urb_out_buf) {\n\t\tdev_err(pcu->dev, \"Failed to allocate memory for write buffer\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_in_urb;\n\t}\n\n\tpcu->urb_ctrl_buf = usb_alloc_coherent(pcu->udev, pcu->max_ctrl_size,\n\t\t\t\t\t       GFP_KERNEL, &pcu->ctrl_dma);\n\tif (!pcu->urb_ctrl_buf) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to allocate memory for read buffer\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb_out_buf;\n\t}\n\n\tpcu->urb_ctrl = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pcu->urb_ctrl) {\n\t\tdev_err(pcu->dev, \"Failed to allocate input URB\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb_ctrl_buf;\n\t}\n\n\tpcu->urb_ctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tpcu->urb_ctrl->transfer_dma = pcu->ctrl_dma;\n\n\tusb_fill_int_urb(pcu->urb_ctrl, pcu->udev,\n\t\t\t  usb_rcvintpipe(pcu->udev,\n\t\t\t\t\t pcu->ep_ctrl->bEndpointAddress),\n\t\t\t  pcu->urb_ctrl_buf, pcu->max_ctrl_size,\n\t\t\t  ims_pcu_irq, pcu, pcu->ep_ctrl->bInterval);\n\n\treturn 0;\n\nerr_free_urb_ctrl_buf:\n\tusb_free_coherent(pcu->udev, pcu->max_ctrl_size,\n\t\t\t  pcu->urb_ctrl_buf, pcu->ctrl_dma);\nerr_free_urb_out_buf:\n\tkfree(pcu->urb_out_buf);\nerr_free_in_urb:\n\tusb_free_urb(pcu->urb_in);\nerr_free_urb_in_buf:\n\tusb_free_coherent(pcu->udev, pcu->max_in_size,\n\t\t\t  pcu->urb_in_buf, pcu->read_dma);\n\treturn error;\n}\n\nstatic void ims_pcu_buffers_free(struct ims_pcu *pcu)\n{\n\tusb_kill_urb(pcu->urb_in);\n\tusb_free_urb(pcu->urb_in);\n\n\tusb_free_coherent(pcu->udev, pcu->max_out_size,\n\t\t\t  pcu->urb_in_buf, pcu->read_dma);\n\n\tkfree(pcu->urb_out_buf);\n\n\tusb_kill_urb(pcu->urb_ctrl);\n\tusb_free_urb(pcu->urb_ctrl);\n\n\tusb_free_coherent(pcu->udev, pcu->max_ctrl_size,\n\t\t\t  pcu->urb_ctrl_buf, pcu->ctrl_dma);\n}\n\nstatic const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\n\twhile (buflen >= sizeof(*union_desc)) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\n\t\tif (union_desc->bLength > buflen) {\n\t\t\tdev_err(&intf->dev, \"Too large descriptor\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\n\t\t\tif (union_desc->bLength >= sizeof(*union_desc))\n\t\t\t\treturn union_desc;\n\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Union descriptor too short (%d vs %zd)\\n\",\n\t\t\t\tunion_desc->bLength, sizeof(*union_desc));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;\n}\n\nstatic int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\n\talt = pcu->ctrl_intf->cur_altsetting;\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ims_pcu_start_io(struct ims_pcu *pcu)\n{\n\tint error;\n\n\terror = usb_submit_urb(pcu->urb_ctrl, GFP_KERNEL);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to start control IO - usb_submit_urb failed with result: %d\\n\",\n\t\t\terror);\n\t\treturn -EIO;\n\t}\n\n\terror = usb_submit_urb(pcu->urb_in, GFP_KERNEL);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to start IO - usb_submit_urb failed with result: %d\\n\",\n\t\t\terror);\n\t\tusb_kill_urb(pcu->urb_ctrl);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void ims_pcu_stop_io(struct ims_pcu *pcu)\n{\n\tusb_kill_urb(pcu->urb_in);\n\tusb_kill_urb(pcu->urb_ctrl);\n}\n\nstatic int ims_pcu_line_setup(struct ims_pcu *pcu)\n{\n\tstruct usb_host_interface *interface = pcu->ctrl_intf->cur_altsetting;\n\tstruct usb_cdc_line_coding *line = (void *)pcu->cmd_buf;\n\tint error;\n\n\tmemset(line, 0, sizeof(*line));\n\tline->dwDTERate = cpu_to_le32(57600);\n\tline->bDataBits = 8;\n\n\terror = usb_control_msg(pcu->udev, usb_sndctrlpipe(pcu->udev, 0),\n\t\t\t\tUSB_CDC_REQ_SET_LINE_CODING,\n\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\t0, interface->desc.bInterfaceNumber,\n\t\t\t\tline, sizeof(struct usb_cdc_line_coding),\n\t\t\t\t5000);\n\tif (error < 0) {\n\t\tdev_err(pcu->dev, \"Failed to set line coding, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = usb_control_msg(pcu->udev, usb_sndctrlpipe(pcu->udev, 0),\n\t\t\t\tUSB_CDC_REQ_SET_CONTROL_LINE_STATE,\n\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\t0x03, interface->desc.bInterfaceNumber,\n\t\t\t\tNULL, 0, 5000);\n\tif (error < 0) {\n\t\tdev_err(pcu->dev, \"Failed to set line state, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ims_pcu_get_device_info(struct ims_pcu *pcu)\n{\n\tint error;\n\n\terror = ims_pcu_get_info(pcu);\n\tif (error)\n\t\treturn error;\n\n\terror = ims_pcu_execute_query(pcu, GET_FW_VERSION);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"GET_FW_VERSION command failed, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsnprintf(pcu->fw_version, sizeof(pcu->fw_version),\n\t\t \"%02d%02d%02d%02d.%c%c\",\n\t\t pcu->cmd_buf[2], pcu->cmd_buf[3], pcu->cmd_buf[4], pcu->cmd_buf[5],\n\t\t pcu->cmd_buf[6], pcu->cmd_buf[7]);\n\n\terror = ims_pcu_execute_query(pcu, GET_BL_VERSION);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"GET_BL_VERSION command failed, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsnprintf(pcu->bl_version, sizeof(pcu->bl_version),\n\t\t \"%02d%02d%02d%02d.%c%c\",\n\t\t pcu->cmd_buf[2], pcu->cmd_buf[3], pcu->cmd_buf[4], pcu->cmd_buf[5],\n\t\t pcu->cmd_buf[6], pcu->cmd_buf[7]);\n\n\terror = ims_pcu_execute_query(pcu, RESET_REASON);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"RESET_REASON command failed, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tsnprintf(pcu->reset_reason, sizeof(pcu->reset_reason),\n\t\t \"%02x\", pcu->cmd_buf[IMS_PCU_DATA_OFFSET]);\n\n\tdev_dbg(pcu->dev,\n\t\t\"P/N: %s, MD: %s, S/N: %s, FW: %s, BL: %s, RR: %s\\n\",\n\t\tpcu->part_number,\n\t\tpcu->date_of_manufacturing,\n\t\tpcu->serial_number,\n\t\tpcu->fw_version,\n\t\tpcu->bl_version,\n\t\tpcu->reset_reason);\n\n\treturn 0;\n}\n\nstatic int ims_pcu_identify_type(struct ims_pcu *pcu, u8 *device_id)\n{\n\tint error;\n\n\terror = ims_pcu_execute_query(pcu, GET_DEVICE_ID);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"GET_DEVICE_ID command failed, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*device_id = pcu->cmd_buf[IMS_PCU_DATA_OFFSET];\n\tdev_dbg(pcu->dev, \"Detected device ID: %d\\n\", *device_id);\n\n\treturn 0;\n}\n\nstatic int ims_pcu_init_application_mode(struct ims_pcu *pcu)\n{\n\tstatic atomic_t device_no = ATOMIC_INIT(-1);\n\n\tconst struct ims_pcu_device_info *info;\n\tint error;\n\n\terror = ims_pcu_get_device_info(pcu);\n\tif (error) {\n\t\t \n\t\treturn error;\n\t}\n\n\terror = ims_pcu_identify_type(pcu, &pcu->device_id);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to identify device, error: %d\\n\", error);\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (pcu->device_id >= ARRAY_SIZE(ims_pcu_device_info) ||\n\t    !ims_pcu_device_info[pcu->device_id].keymap) {\n\t\tdev_err(pcu->dev, \"Device ID %d is not valid\\n\", pcu->device_id);\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tpcu->device_no = atomic_inc_return(&device_no);\n\n\t \n\tif (pcu->device_id != IMS_PCU_PCU_B_DEVICE_ID) {\n\t\terror = sysfs_create_group(&pcu->dev->kobj,\n\t\t\t\t\t   &ims_pcu_ofn_attr_group);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = ims_pcu_setup_backlight(pcu);\n\tif (error)\n\t\treturn error;\n\n\tinfo = &ims_pcu_device_info[pcu->device_id];\n\terror = ims_pcu_setup_buttons(pcu, info->keymap, info->keymap_len);\n\tif (error)\n\t\tgoto err_destroy_backlight;\n\n\tif (info->has_gamepad) {\n\t\terror = ims_pcu_setup_gamepad(pcu);\n\t\tif (error)\n\t\t\tgoto err_destroy_buttons;\n\t}\n\n\tpcu->setup_complete = true;\n\n\treturn 0;\n\nerr_destroy_buttons:\n\tims_pcu_destroy_buttons(pcu);\nerr_destroy_backlight:\n\tims_pcu_destroy_backlight(pcu);\n\treturn error;\n}\n\nstatic void ims_pcu_destroy_application_mode(struct ims_pcu *pcu)\n{\n\tif (pcu->setup_complete) {\n\t\tpcu->setup_complete = false;\n\t\tmb();  \n\n\t\tif (pcu->gamepad)\n\t\t\tims_pcu_destroy_gamepad(pcu);\n\t\tims_pcu_destroy_buttons(pcu);\n\t\tims_pcu_destroy_backlight(pcu);\n\n\t\tif (pcu->device_id != IMS_PCU_PCU_B_DEVICE_ID)\n\t\t\tsysfs_remove_group(&pcu->dev->kobj,\n\t\t\t\t\t   &ims_pcu_ofn_attr_group);\n\t}\n}\n\nstatic int ims_pcu_init_bootloader_mode(struct ims_pcu *pcu)\n{\n\tint error;\n\n\terror = ims_pcu_execute_bl_command(pcu, QUERY_DEVICE, NULL, 0,\n\t\t\t\t\t   IMS_PCU_CMD_RESPONSE_TIMEOUT);\n\tif (error) {\n\t\tdev_err(pcu->dev, \"Bootloader does not respond, aborting\\n\");\n\t\treturn error;\n\t}\n\n\tpcu->fw_start_addr =\n\t\tget_unaligned_le32(&pcu->cmd_buf[IMS_PCU_DATA_OFFSET + 11]);\n\tpcu->fw_end_addr =\n\t\tget_unaligned_le32(&pcu->cmd_buf[IMS_PCU_DATA_OFFSET + 15]);\n\n\tdev_info(pcu->dev,\n\t\t \"Device is in bootloader mode (addr 0x%08x-0x%08x), requesting firmware\\n\",\n\t\t pcu->fw_start_addr, pcu->fw_end_addr);\n\n\terror = request_firmware_nowait(THIS_MODULE, true,\n\t\t\t\t\tIMS_PCU_FIRMWARE_NAME,\n\t\t\t\t\tpcu->dev, GFP_KERNEL, pcu,\n\t\t\t\t\tims_pcu_process_async_firmware);\n\tif (error) {\n\t\t \n\t\tcomplete(&pcu->async_firmware_done);\n\t}\n\n\treturn 0;\n}\n\nstatic void ims_pcu_destroy_bootloader_mode(struct ims_pcu *pcu)\n{\n\t \n\twait_for_completion(&pcu->async_firmware_done);\n}\n\n#define IMS_PCU_APPLICATION_MODE\t0\n#define IMS_PCU_BOOTLOADER_MODE\t\t1\n\nstatic struct usb_driver ims_pcu_driver;\n\nstatic int ims_pcu_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct ims_pcu *pcu;\n\tint error;\n\n\tpcu = kzalloc(sizeof(struct ims_pcu), GFP_KERNEL);\n\tif (!pcu)\n\t\treturn -ENOMEM;\n\n\tpcu->dev = &intf->dev;\n\tpcu->udev = udev;\n\tpcu->bootloader_mode = id->driver_info == IMS_PCU_BOOTLOADER_MODE;\n\tmutex_init(&pcu->cmd_mutex);\n\tinit_completion(&pcu->cmd_done);\n\tinit_completion(&pcu->async_firmware_done);\n\n\terror = ims_pcu_parse_cdc_data(intf, pcu);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\terror = usb_driver_claim_interface(&ims_pcu_driver,\n\t\t\t\t\t   pcu->data_intf, pcu);\n\tif (error) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Unable to claim corresponding data interface: %d\\n\",\n\t\t\terror);\n\t\tgoto err_free_mem;\n\t}\n\n\tusb_set_intfdata(pcu->ctrl_intf, pcu);\n\n\terror = ims_pcu_buffers_alloc(pcu);\n\tif (error)\n\t\tgoto err_unclaim_intf;\n\n\terror = ims_pcu_start_io(pcu);\n\tif (error)\n\t\tgoto err_free_buffers;\n\n\terror = ims_pcu_line_setup(pcu);\n\tif (error)\n\t\tgoto err_stop_io;\n\n\terror = sysfs_create_group(&intf->dev.kobj, &ims_pcu_attr_group);\n\tif (error)\n\t\tgoto err_stop_io;\n\n\terror = pcu->bootloader_mode ?\n\t\t\tims_pcu_init_bootloader_mode(pcu) :\n\t\t\tims_pcu_init_application_mode(pcu);\n\tif (error)\n\t\tgoto err_remove_sysfs;\n\n\treturn 0;\n\nerr_remove_sysfs:\n\tsysfs_remove_group(&intf->dev.kobj, &ims_pcu_attr_group);\nerr_stop_io:\n\tims_pcu_stop_io(pcu);\nerr_free_buffers:\n\tims_pcu_buffers_free(pcu);\nerr_unclaim_intf:\n\tusb_driver_release_interface(&ims_pcu_driver, pcu->data_intf);\nerr_free_mem:\n\tkfree(pcu);\n\treturn error;\n}\n\nstatic void ims_pcu_disconnect(struct usb_interface *intf)\n{\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\n\tusb_set_intfdata(intf, NULL);\n\n\t \n\tif (alt->desc.bInterfaceClass != USB_CLASS_COMM)\n\t\treturn;\n\n\tsysfs_remove_group(&intf->dev.kobj, &ims_pcu_attr_group);\n\n\tims_pcu_stop_io(pcu);\n\n\tif (pcu->bootloader_mode)\n\t\tims_pcu_destroy_bootloader_mode(pcu);\n\telse\n\t\tims_pcu_destroy_application_mode(pcu);\n\n\tims_pcu_buffers_free(pcu);\n\tkfree(pcu);\n}\n\n#ifdef CONFIG_PM\nstatic int ims_pcu_suspend(struct usb_interface *intf,\n\t\t\t   pm_message_t message)\n{\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\n\tif (alt->desc.bInterfaceClass == USB_CLASS_COMM)\n\t\tims_pcu_stop_io(pcu);\n\n\treturn 0;\n}\n\nstatic int ims_pcu_resume(struct usb_interface *intf)\n{\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint retval = 0;\n\n\tif (alt->desc.bInterfaceClass == USB_CLASS_COMM) {\n\t\tretval = ims_pcu_start_io(pcu);\n\t\tif (retval == 0)\n\t\t\tretval = ims_pcu_line_setup(pcu);\n\t}\n\n\treturn retval;\n}\n#endif\n\nstatic const struct usb_device_id ims_pcu_id_table[] = {\n\t{\n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x04d8, 0x0082,\n\t\t\t\t\tUSB_CLASS_COMM,\n\t\t\t\t\tUSB_CDC_SUBCLASS_ACM,\n\t\t\t\t\tUSB_CDC_ACM_PROTO_AT_V25TER),\n\t\t.driver_info = IMS_PCU_APPLICATION_MODE,\n\t},\n\t{\n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x04d8, 0x0083,\n\t\t\t\t\tUSB_CLASS_COMM,\n\t\t\t\t\tUSB_CDC_SUBCLASS_ACM,\n\t\t\t\t\tUSB_CDC_ACM_PROTO_AT_V25TER),\n\t\t.driver_info = IMS_PCU_BOOTLOADER_MODE,\n\t},\n\t{ }\n};\n\nstatic struct usb_driver ims_pcu_driver = {\n\t.name\t\t\t= \"ims_pcu\",\n\t.id_table\t\t= ims_pcu_id_table,\n\t.probe\t\t\t= ims_pcu_probe,\n\t.disconnect\t\t= ims_pcu_disconnect,\n#ifdef CONFIG_PM\n\t.suspend\t\t= ims_pcu_suspend,\n\t.resume\t\t\t= ims_pcu_resume,\n\t.reset_resume\t\t= ims_pcu_resume,\n#endif\n};\n\nmodule_usb_driver(ims_pcu_driver);\n\nMODULE_DESCRIPTION(\"IMS Passenger Control Unit driver\");\nMODULE_AUTHOR(\"Dmitry Torokhov <dmitry.torokhov@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}