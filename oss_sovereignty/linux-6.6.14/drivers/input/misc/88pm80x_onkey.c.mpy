{
  "module_name": "88pm80x_onkey.c",
  "hash_id": "eadcefcbf9e8aeb43721ea53ea8af35ae1ba60fb5655cc9b05ac41c783875e96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/misc/88pm80x_onkey.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/mfd/88pm80x.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define PM800_LONG_ONKEY_EN\t\t(1 << 0)\n#define PM800_LONG_KEY_DELAY\t\t(8)\t \n#define PM800_LONKEY_PRESS_TIME\t\t((PM800_LONG_KEY_DELAY-1) << 4)\n#define PM800_LONKEY_PRESS_TIME_MASK\t(0xF0)\n#define PM800_SW_PDOWN\t\t\t(1 << 5)\n\nstruct pm80x_onkey_info {\n\tstruct input_dev *idev;\n\tstruct pm80x_chip *pm80x;\n\tstruct regmap *map;\n\tint irq;\n};\n\n \nstatic irqreturn_t pm80x_onkey_handler(int irq, void *data)\n{\n\tstruct pm80x_onkey_info *info = data;\n\tint ret = 0;\n\tunsigned int val;\n\n\tret = regmap_read(info->map, PM800_STATUS_1, &val);\n\tif (ret < 0) {\n\t\tdev_err(info->idev->dev.parent, \"failed to read status: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\tval &= PM800_ONKEY_STS1;\n\n\tinput_report_key(info->idev, KEY_POWER, val);\n\tinput_sync(info->idev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pm80x_onkey_pm_ops, pm80x_dev_suspend,\n\t\t\t pm80x_dev_resume);\n\nstatic int pm80x_onkey_probe(struct platform_device *pdev)\n{\n\n\tstruct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct pm80x_onkey_info *info;\n\tint err;\n\n\tinfo = kzalloc(sizeof(struct pm80x_onkey_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->pm80x = chip;\n\n\tinfo->irq = platform_get_irq(pdev, 0);\n\tif (info->irq < 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo->map = info->pm80x->regmap;\n\tif (!info->map) {\n\t\tdev_err(&pdev->dev, \"no regmap!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinfo->idev = input_allocate_device();\n\tif (!info->idev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate input dev\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinfo->idev->name = \"88pm80x_on\";\n\tinfo->idev->phys = \"88pm80x_on/input0\";\n\tinfo->idev->id.bustype = BUS_I2C;\n\tinfo->idev->dev.parent = &pdev->dev;\n\tinfo->idev->evbit[0] = BIT_MASK(EV_KEY);\n\t__set_bit(KEY_POWER, info->idev->keybit);\n\n\terr = pm80x_request_irq(info->pm80x, info->irq, pm80x_onkey_handler,\n\t\t\t\t\t    IRQF_ONESHOT, \"onkey\", info);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ: #%d: %d\\n\",\n\t\t\tinfo->irq, err);\n\t\tgoto out_reg;\n\t}\n\n\terr = input_register_device(info->idev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't register input device: %d\\n\", err);\n\t\tgoto out_irq;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\n\t \n\tregmap_update_bits(info->map, PM800_RTC_MISC4, PM800_LONG_ONKEY_EN,\n\t\t\t   PM800_LONG_ONKEY_EN);\n\t \n\tregmap_update_bits(info->map, PM800_RTC_MISC3,\n\t\t\t   PM800_LONKEY_PRESS_TIME_MASK,\n\t\t\t   PM800_LONKEY_PRESS_TIME);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\treturn 0;\n\nout_irq:\n\tpm80x_free_irq(info->pm80x, info->irq, info);\nout_reg:\n\tinput_free_device(info->idev);\nout:\n\tkfree(info);\n\treturn err;\n}\n\nstatic int pm80x_onkey_remove(struct platform_device *pdev)\n{\n\tstruct pm80x_onkey_info *info = platform_get_drvdata(pdev);\n\n\tpm80x_free_irq(info->pm80x, info->irq, info);\n\tinput_unregister_device(info->idev);\n\tkfree(info);\n\treturn 0;\n}\n\nstatic struct platform_driver pm80x_onkey_driver = {\n\t.driver = {\n\t\t   .name = \"88pm80x-onkey\",\n\t\t   .pm = &pm80x_onkey_pm_ops,\n\t\t   },\n\t.probe = pm80x_onkey_probe,\n\t.remove = pm80x_onkey_remove,\n};\n\nmodule_platform_driver(pm80x_onkey_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Marvell 88PM80x ONKEY driver\");\nMODULE_AUTHOR(\"Qiao Zhou <zhouqiao@marvell.com>\");\nMODULE_ALIAS(\"platform:88pm80x-onkey\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}