{
  "module_name": "touchscreen.c",
  "hash_id": "f9e90ccd411b4134d01042ce19471675cf9fcfba53d69901b884d09fe7edfbc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen.c",
  "human_readable_source": "\n \n\n#include <linux/property.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/module.h>\n\nstatic bool touchscreen_get_prop_u32(struct device *dev,\n\t\t\t\t     const char *property,\n\t\t\t\t     unsigned int default_value,\n\t\t\t\t     unsigned int *value)\n{\n\tu32 val;\n\tint error;\n\n\terror = device_property_read_u32(dev, property, &val);\n\tif (error) {\n\t\t*value = default_value;\n\t\treturn false;\n\t}\n\n\t*value = val;\n\treturn true;\n}\n\nstatic void touchscreen_set_params(struct input_dev *dev,\n\t\t\t\t   unsigned long axis,\n\t\t\t\t   int min, int max, int fuzz)\n{\n\tstruct input_absinfo *absinfo;\n\n\tif (!test_bit(axis, dev->absbit)) {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"Parameters are specified but the axis %lu is not set up\\n\",\n\t\t\t axis);\n\t\treturn;\n\t}\n\n\tabsinfo = &dev->absinfo[axis];\n\tabsinfo->minimum = min;\n\tabsinfo->maximum = max;\n\tabsinfo->fuzz = fuzz;\n}\n\n \nvoid touchscreen_parse_properties(struct input_dev *input, bool multitouch,\n\t\t\t\t  struct touchscreen_properties *prop)\n{\n\tstruct device *dev = input->dev.parent;\n\tstruct input_absinfo *absinfo;\n\tunsigned int axis, axis_x, axis_y;\n\tunsigned int minimum, maximum, fuzz;\n\tbool data_present;\n\n\tinput_alloc_absinfo(input);\n\tif (!input->absinfo)\n\t\treturn;\n\n\taxis_x = multitouch ? ABS_MT_POSITION_X : ABS_X;\n\taxis_y = multitouch ? ABS_MT_POSITION_Y : ABS_Y;\n\n\tdata_present = touchscreen_get_prop_u32(dev, \"touchscreen-min-x\",\n\t\t\t\t\t\tinput_abs_get_min(input, axis_x),\n\t\t\t\t\t\t&minimum);\n\tdata_present |= touchscreen_get_prop_u32(dev, \"touchscreen-size-x\",\n\t\t\t\t\t\t input_abs_get_max(input,\n\t\t\t\t\t\t\t\t   axis_x) + 1,\n\t\t\t\t\t\t &maximum);\n\tdata_present |= touchscreen_get_prop_u32(dev, \"touchscreen-fuzz-x\",\n\t\t\t\t\t\t input_abs_get_fuzz(input, axis_x),\n\t\t\t\t\t\t &fuzz);\n\tif (data_present)\n\t\ttouchscreen_set_params(input, axis_x, minimum, maximum - 1, fuzz);\n\n\tdata_present = touchscreen_get_prop_u32(dev, \"touchscreen-min-y\",\n\t\t\t\t\t\tinput_abs_get_min(input, axis_y),\n\t\t\t\t\t\t&minimum);\n\tdata_present |= touchscreen_get_prop_u32(dev, \"touchscreen-size-y\",\n\t\t\t\t\t\t input_abs_get_max(input,\n\t\t\t\t\t\t\t\t   axis_y) + 1,\n\t\t\t\t\t\t &maximum);\n\tdata_present |= touchscreen_get_prop_u32(dev, \"touchscreen-fuzz-y\",\n\t\t\t\t\t\t input_abs_get_fuzz(input, axis_y),\n\t\t\t\t\t\t &fuzz);\n\tif (data_present)\n\t\ttouchscreen_set_params(input, axis_y, minimum, maximum - 1, fuzz);\n\n\taxis = multitouch ? ABS_MT_PRESSURE : ABS_PRESSURE;\n\tdata_present = touchscreen_get_prop_u32(dev,\n\t\t\t\t\t\t\"touchscreen-max-pressure\",\n\t\t\t\t\t\tinput_abs_get_max(input, axis),\n\t\t\t\t\t\t&maximum);\n\tdata_present |= touchscreen_get_prop_u32(dev,\n\t\t\t\t\t\t \"touchscreen-fuzz-pressure\",\n\t\t\t\t\t\t input_abs_get_fuzz(input, axis),\n\t\t\t\t\t\t &fuzz);\n\tif (data_present)\n\t\ttouchscreen_set_params(input, axis, 0, maximum, fuzz);\n\n\tif (!prop)\n\t\treturn;\n\n\tprop->max_x = input_abs_get_max(input, axis_x);\n\tprop->max_y = input_abs_get_max(input, axis_y);\n\n\tprop->invert_x =\n\t\tdevice_property_read_bool(dev, \"touchscreen-inverted-x\");\n\tif (prop->invert_x) {\n\t\tabsinfo = &input->absinfo[axis_x];\n\t\tabsinfo->maximum -= absinfo->minimum;\n\t\tabsinfo->minimum = 0;\n\t}\n\n\tprop->invert_y =\n\t\tdevice_property_read_bool(dev, \"touchscreen-inverted-y\");\n\tif (prop->invert_y) {\n\t\tabsinfo = &input->absinfo[axis_y];\n\t\tabsinfo->maximum -= absinfo->minimum;\n\t\tabsinfo->minimum = 0;\n\t}\n\n\tprop->swap_x_y =\n\t\tdevice_property_read_bool(dev, \"touchscreen-swapped-x-y\");\n\tif (prop->swap_x_y)\n\t\tswap(input->absinfo[axis_x], input->absinfo[axis_y]);\n}\nEXPORT_SYMBOL(touchscreen_parse_properties);\n\nstatic void\ntouchscreen_apply_prop_to_x_y(const struct touchscreen_properties *prop,\n\t\t\t      unsigned int *x, unsigned int *y)\n{\n\tif (prop->invert_x)\n\t\t*x = prop->max_x - *x;\n\n\tif (prop->invert_y)\n\t\t*y = prop->max_y - *y;\n\n\tif (prop->swap_x_y)\n\t\tswap(*x, *y);\n}\n\n \nvoid touchscreen_set_mt_pos(struct input_mt_pos *pos,\n\t\t\t    const struct touchscreen_properties *prop,\n\t\t\t    unsigned int x, unsigned int y)\n{\n\ttouchscreen_apply_prop_to_x_y(prop, &x, &y);\n\tpos->x = x;\n\tpos->y = y;\n}\nEXPORT_SYMBOL(touchscreen_set_mt_pos);\n\n \nvoid touchscreen_report_pos(struct input_dev *input,\n\t\t\t    const struct touchscreen_properties *prop,\n\t\t\t    unsigned int x, unsigned int y,\n\t\t\t    bool multitouch)\n{\n\ttouchscreen_apply_prop_to_x_y(prop, &x, &y);\n\tinput_report_abs(input, multitouch ? ABS_MT_POSITION_X : ABS_X, x);\n\tinput_report_abs(input, multitouch ? ABS_MT_POSITION_Y : ABS_Y, y);\n}\nEXPORT_SYMBOL(touchscreen_report_pos);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Helper functions for touchscreens and other devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}