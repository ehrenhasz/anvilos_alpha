{
  "module_name": "elantech.c",
  "hash_id": "38d35ae4cf58670bfd1d39de07cfba513796a00a98a338e892153df66dad10f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/elantech.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/platform_device.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <asm/unaligned.h>\n#include \"psmouse.h\"\n#include \"elantech.h\"\n#include \"elan_i2c.h\"\n\n#define elantech_debug(fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (etd->info.debug)\t\t\t\t\t\\\n\t\t\tpsmouse_printk(KERN_DEBUG, psmouse,\t\t\\\n\t\t\t\t\tfmt, ##__VA_ARGS__);\t\t\\\n\t} while (0)\n\n \nstatic int synaptics_send_cmd(struct psmouse *psmouse, unsigned char c,\n\t\t\t\tunsigned char *param)\n{\n\tif (ps2_sliced_command(&psmouse->ps2dev, c) ||\n\t    ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {\n\t\tpsmouse_err(psmouse, \"%s query 0x%02x failed.\\n\", __func__, c);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int elantech_send_cmd(struct psmouse *psmouse, unsigned char c,\n\t\t\t\tunsigned char *param)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\tif (ps2_command(ps2dev, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    ps2_command(ps2dev, NULL, c) ||\n\t    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\n\t\tpsmouse_err(psmouse, \"%s query 0x%02x failed.\\n\", __func__, c);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int elantech_ps2_command(struct psmouse *psmouse,\n\t\t\t\tunsigned char *param, int command)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tint rc;\n\tint tries = ETP_PS2_COMMAND_TRIES;\n\n\tdo {\n\t\trc = ps2_command(ps2dev, param, command);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t\ttries--;\n\t\telantech_debug(\"retrying ps2 command 0x%02x (%d).\\n\",\n\t\t\t\tcommand, tries);\n\t\tmsleep(ETP_PS2_COMMAND_DELAY);\n\t} while (tries > 0);\n\n\tif (rc)\n\t\tpsmouse_err(psmouse, \"ps2 command 0x%02x failed.\\n\", command);\n\n\treturn rc;\n}\n\n \nstatic int elantech_read_reg_params(struct psmouse *psmouse, u8 reg, u8 *param)\n{\n\tif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\n\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    elantech_ps2_command(psmouse, NULL, reg) ||\n\t    elantech_ps2_command(psmouse, param, PSMOUSE_CMD_GETINFO)) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to read register %#02x\\n\", reg);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int elantech_write_reg_params(struct psmouse *psmouse, u8 reg, u8 *param)\n{\n\tif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\n\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    elantech_ps2_command(psmouse, NULL, reg) ||\n\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    elantech_ps2_command(psmouse, NULL, param[0]) ||\n\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t    elantech_ps2_command(psmouse, NULL, param[1]) ||\n\t    elantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to write register %#02x with value %#02x%#02x\\n\",\n\t\t\t    reg, param[0], param[1]);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int elantech_read_reg(struct psmouse *psmouse, unsigned char reg,\n\t\t\t\tunsigned char *val)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char param[3];\n\tint rc = 0;\n\n\tif (reg < 0x07 || reg > 0x26)\n\t\treturn -1;\n\n\tif (reg > 0x11 && reg < 0x20)\n\t\treturn -1;\n\n\tswitch (etd->info.hw_version) {\n\tcase 1:\n\t\tif (ps2_sliced_command(&psmouse->ps2dev, ETP_REGISTER_READ) ||\n\t\t    ps2_sliced_command(&psmouse->ps2dev, reg) ||\n\t\t    ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tif (elantech_ps2_command(psmouse,  NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse,  NULL, ETP_REGISTER_READ) ||\n\t\t    elantech_ps2_command(psmouse,  NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse,  NULL, reg) ||\n\t\t    elantech_ps2_command(psmouse, param, PSMOUSE_CMD_GETINFO)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 3 ... 4:\n\t\tif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, reg) ||\n\t\t    elantech_ps2_command(psmouse, param, PSMOUSE_CMD_GETINFO)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tpsmouse_err(psmouse, \"failed to read register 0x%02x.\\n\", reg);\n\telse if (etd->info.hw_version != 4)\n\t\t*val = param[0];\n\telse\n\t\t*val = param[1];\n\n\treturn rc;\n}\n\n \nstatic int elantech_write_reg(struct psmouse *psmouse, unsigned char reg,\n\t\t\t\tunsigned char val)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tint rc = 0;\n\n\tif (reg < 0x07 || reg > 0x26)\n\t\treturn -1;\n\n\tif (reg > 0x11 && reg < 0x20)\n\t\treturn -1;\n\n\tswitch (etd->info.hw_version) {\n\tcase 1:\n\t\tif (ps2_sliced_command(&psmouse->ps2dev, ETP_REGISTER_WRITE) ||\n\t\t    ps2_sliced_command(&psmouse->ps2dev, reg) ||\n\t\t    ps2_sliced_command(&psmouse->ps2dev, val) ||\n\t\t    ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_WRITE) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, reg) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, val) ||\n\t\t    elantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, reg) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, val) ||\n\t\t    elantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tif (elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, reg) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_REGISTER_READWRITE) ||\n\t\t    elantech_ps2_command(psmouse, NULL, ETP_PS2_CUSTOM_COMMAND) ||\n\t\t    elantech_ps2_command(psmouse, NULL, val) ||\n\t\t    elantech_ps2_command(psmouse, NULL, PSMOUSE_CMD_SETSCALE11)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to write register 0x%02x with value 0x%02x.\\n\",\n\t\t\t    reg, val);\n\n\treturn rc;\n}\n\n \nstatic void elantech_packet_dump(struct psmouse *psmouse)\n{\n\tpsmouse_printk(KERN_DEBUG, psmouse, \"PS/2 packet [%*ph]\\n\",\n\t\t       psmouse->pktsize, psmouse->packet);\n}\n\n \nstatic inline int elantech_is_buttonpad(struct elantech_device_info *info)\n{\n\treturn info->fw_version & 0x001000;\n}\n\n \nstatic void elantech_report_absolute_v1(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tint fingers;\n\n\tif (etd->info.fw_version < 0x020000) {\n\t\t \n\t\tfingers = ((packet[1] & 0x80) >> 7) +\n\t\t\t\t((packet[1] & 0x30) >> 4);\n\t} else {\n\t\t \n\t\tfingers = (packet[0] & 0xc0) >> 6;\n\t}\n\n\tif (etd->info.jumpy_cursor) {\n\t\tif (fingers != 1) {\n\t\t\tetd->single_finger_reports = 0;\n\t\t} else if (etd->single_finger_reports < 2) {\n\t\t\t \n\t\t\tetd->single_finger_reports++;\n\t\t\telantech_debug(\"discarding packet\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tinput_report_key(dev, BTN_TOUCH, fingers != 0);\n\n\t \n\tif (fingers) {\n\t\tinput_report_abs(dev, ABS_X,\n\t\t\t((packet[1] & 0x0c) << 6) | packet[2]);\n\t\tinput_report_abs(dev, ABS_Y,\n\t\t\tetd->y_max - (((packet[1] & 0x03) << 8) | packet[3]));\n\t}\n\n\tinput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\n\tinput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\n\tinput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\n\n\tpsmouse_report_standard_buttons(dev, packet[0]);\n\n\tif (etd->info.fw_version < 0x020000 &&\n\t    (etd->info.capabilities[0] & ETP_CAP_HAS_ROCKER)) {\n\t\t \n\t\tinput_report_key(dev, BTN_FORWARD, packet[0] & 0x40);\n\t\t \n\t\tinput_report_key(dev, BTN_BACK, packet[0] & 0x80);\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic void elantech_set_slot(struct input_dev *dev, int slot, bool active,\n\t\t\t      unsigned int x, unsigned int y)\n{\n\tinput_mt_slot(dev, slot);\n\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\n\tif (active) {\n\t\tinput_report_abs(dev, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_Y, y);\n\t}\n}\n\n \nstatic void elantech_report_semi_mt_data(struct input_dev *dev,\n\t\t\t\t\t unsigned int num_fingers,\n\t\t\t\t\t unsigned int x1, unsigned int y1,\n\t\t\t\t\t unsigned int x2, unsigned int y2)\n{\n\telantech_set_slot(dev, 0, num_fingers != 0, x1, y1);\n\telantech_set_slot(dev, 1, num_fingers >= 2, x2, y2);\n}\n\n \nstatic void elantech_report_absolute_v2(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tstruct input_dev *dev = psmouse->dev;\n\tunsigned char *packet = psmouse->packet;\n\tunsigned int fingers, x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n\tunsigned int width = 0, pres = 0;\n\n\t \n\tfingers = (packet[0] & 0xc0) >> 6;\n\n\tswitch (fingers) {\n\tcase 3:\n\t\t \n\t\tif (packet[3] & 0x80)\n\t\t\tfingers = 4;\n\t\tfallthrough;\n\tcase 1:\n\t\t \n\t\tx1 = ((packet[1] & 0x0f) << 8) | packet[2];\n\t\t \n\t\ty1 = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\n\n\t\tpres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\n\t\twidth = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tx1 = (((packet[0] & 0x10) << 4) | packet[1]) << 2;\n\t\t \n\t\ty1 = etd->y_max -\n\t\t\t((((packet[0] & 0x20) << 3) | packet[2]) << 2);\n\t\t \n\t\tx2 = (((packet[3] & 0x10) << 4) | packet[4]) << 2;\n\t\t \n\t\ty2 = etd->y_max -\n\t\t\t((((packet[3] & 0x20) << 3) | packet[5]) << 2);\n\n\t\t \n\t\tpres = 127;\n\t\twidth = 7;\n\t\tbreak;\n\t}\n\n\tinput_report_key(dev, BTN_TOUCH, fingers != 0);\n\tif (fingers != 0) {\n\t\tinput_report_abs(dev, ABS_X, x1);\n\t\tinput_report_abs(dev, ABS_Y, y1);\n\t}\n\telantech_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\n\tinput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\n\tinput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\n\tinput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\n\tinput_report_key(dev, BTN_TOOL_QUADTAP, fingers == 4);\n\tpsmouse_report_standard_buttons(dev, packet[0]);\n\tif (etd->info.reports_pressure) {\n\t\tinput_report_abs(dev, ABS_PRESSURE, pres);\n\t\tinput_report_abs(dev, ABS_TOOL_WIDTH, width);\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic void elantech_report_trackpoint(struct psmouse *psmouse,\n\t\t\t\t       int packet_type)\n{\n\t \n\n\tstruct elantech_data *etd = psmouse->private;\n\tstruct input_dev *tp_dev = etd->tp_dev;\n\tunsigned char *packet = psmouse->packet;\n\tint x, y;\n\tu32 t;\n\n\tt = get_unaligned_le32(&packet[0]);\n\n\tswitch (t & ~7U) {\n\tcase 0x06000030U:\n\tcase 0x16008020U:\n\tcase 0x26800010U:\n\tcase 0x36808000U:\n\n\t\t \n\t\tif (packet[4] == 0x80 || packet[5] == 0x80 ||\n\t\t    packet[1] >> 7 == packet[4] >> 7 ||\n\t\t    packet[2] >> 7 == packet[5] >> 7) {\n\t\t\telantech_debug(\"discarding packet [%6ph]\\n\", packet);\n\t\t\tbreak;\n\n\t\t}\n\t\tx = packet[4] - (int)((packet[1]^0x80) << 1);\n\t\ty = (int)((packet[2]^0x80) << 1) - packet[5];\n\n\t\tpsmouse_report_standard_buttons(tp_dev, packet[0]);\n\n\t\tinput_report_rel(tp_dev, REL_X, x);\n\t\tinput_report_rel(tp_dev, REL_Y, y);\n\n\t\tinput_sync(tp_dev);\n\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (etd->info.debug == 1)\n\t\t\telantech_packet_dump(psmouse);\n\n\t\tbreak;\n\t}\n}\n\n \nstatic void elantech_report_absolute_v3(struct psmouse *psmouse,\n\t\t\t\t\tint packet_type)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tunsigned int fingers = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0;\n\tunsigned int width = 0, pres = 0;\n\n\t \n\tfingers = (packet[0] & 0xc0) >> 6;\n\n\tswitch (fingers) {\n\tcase 3:\n\tcase 1:\n\t\t \n\t\tx1 = ((packet[1] & 0x0f) << 8) | packet[2];\n\t\t \n\t\ty1 = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\n\t\tbreak;\n\n\tcase 2:\n\t\tif (packet_type == PACKET_V3_HEAD) {\n\t\t\t \n\t\t\tetd->mt[0].x = ((packet[1] & 0x0f) << 8) | packet[2];\n\t\t\t \n\t\t\tetd->mt[0].y = etd->y_max -\n\t\t\t\t(((packet[4] & 0x0f) << 8) | packet[5]);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tx1 = etd->mt[0].x;\n\t\ty1 = etd->mt[0].y;\n\t\tx2 = ((packet[1] & 0x0f) << 8) | packet[2];\n\t\ty2 = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\n\t\tbreak;\n\t}\n\n\tpres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\n\twidth = ((packet[0] & 0x30) >> 2) | ((packet[3] & 0x30) >> 4);\n\n\tinput_report_key(dev, BTN_TOUCH, fingers != 0);\n\tif (fingers != 0) {\n\t\tinput_report_abs(dev, ABS_X, x1);\n\t\tinput_report_abs(dev, ABS_Y, y1);\n\t}\n\telantech_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\n\tinput_report_key(dev, BTN_TOOL_FINGER, fingers == 1);\n\tinput_report_key(dev, BTN_TOOL_DOUBLETAP, fingers == 2);\n\tinput_report_key(dev, BTN_TOOL_TRIPLETAP, fingers == 3);\n\n\t \n\tif (elantech_is_buttonpad(&etd->info))\n\t\tinput_report_key(dev, BTN_LEFT, packet[0] & 0x03);\n\telse\n\t\tpsmouse_report_standard_buttons(dev, packet[0]);\n\n\tinput_report_abs(dev, ABS_PRESSURE, pres);\n\tinput_report_abs(dev, ABS_TOOL_WIDTH, width);\n\n\tinput_sync(dev);\n}\n\nstatic void elantech_input_sync_v4(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\n\t \n\tif (elantech_is_buttonpad(&etd->info))\n\t\tinput_report_key(dev, BTN_LEFT, packet[0] & 0x03);\n\telse\n\t\tpsmouse_report_standard_buttons(dev, packet[0]);\n\n\tinput_mt_report_pointer_emulation(dev, true);\n\tinput_sync(dev);\n}\n\nstatic void process_packet_status_v4(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tunsigned char *packet = psmouse->packet;\n\tunsigned fingers;\n\tint i;\n\n\t \n\tfingers = packet[1] & 0x1f;\n\tfor (i = 0; i < ETP_MAX_FINGERS; i++) {\n\t\tif ((fingers & (1 << i)) == 0) {\n\t\t\tinput_mt_slot(dev, i);\n\t\t\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, false);\n\t\t}\n\t}\n\n\telantech_input_sync_v4(psmouse);\n}\n\nstatic void process_packet_head_v4(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tint id;\n\tint pres, traces;\n\n\tid = ((packet[3] & 0xe0) >> 5) - 1;\n\tif (id < 0 || id >= ETP_MAX_FINGERS)\n\t\treturn;\n\n\tetd->mt[id].x = ((packet[1] & 0x0f) << 8) | packet[2];\n\tetd->mt[id].y = etd->y_max - (((packet[4] & 0x0f) << 8) | packet[5]);\n\tpres = (packet[1] & 0xf0) | ((packet[4] & 0xf0) >> 4);\n\ttraces = (packet[0] & 0xf0) >> 4;\n\n\tinput_mt_slot(dev, id);\n\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, true);\n\n\tinput_report_abs(dev, ABS_MT_POSITION_X, etd->mt[id].x);\n\tinput_report_abs(dev, ABS_MT_POSITION_Y, etd->mt[id].y);\n\tinput_report_abs(dev, ABS_MT_PRESSURE, pres);\n\tinput_report_abs(dev, ABS_MT_TOUCH_MAJOR, traces * etd->width);\n\t \n\tinput_report_abs(dev, ABS_TOOL_WIDTH, traces);\n\n\telantech_input_sync_v4(psmouse);\n}\n\nstatic void process_packet_motion_v4(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tint weight, delta_x1 = 0, delta_y1 = 0, delta_x2 = 0, delta_y2 = 0;\n\tint id, sid;\n\n\tid = ((packet[0] & 0xe0) >> 5) - 1;\n\tif (id < 0 || id >= ETP_MAX_FINGERS)\n\t\treturn;\n\n\tsid = ((packet[3] & 0xe0) >> 5) - 1;\n\tweight = (packet[0] & 0x10) ? ETP_WEIGHT_VALUE : 1;\n\t \n\tdelta_x1 = (signed char)packet[1];\n\tdelta_y1 = (signed char)packet[2];\n\tdelta_x2 = (signed char)packet[4];\n\tdelta_y2 = (signed char)packet[5];\n\n\tetd->mt[id].x += delta_x1 * weight;\n\tetd->mt[id].y -= delta_y1 * weight;\n\tinput_mt_slot(dev, id);\n\tinput_report_abs(dev, ABS_MT_POSITION_X, etd->mt[id].x);\n\tinput_report_abs(dev, ABS_MT_POSITION_Y, etd->mt[id].y);\n\n\tif (sid >= 0 && sid < ETP_MAX_FINGERS) {\n\t\tetd->mt[sid].x += delta_x2 * weight;\n\t\tetd->mt[sid].y -= delta_y2 * weight;\n\t\tinput_mt_slot(dev, sid);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_X, etd->mt[sid].x);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_Y, etd->mt[sid].y);\n\t}\n\n\telantech_input_sync_v4(psmouse);\n}\n\nstatic void elantech_report_absolute_v4(struct psmouse *psmouse,\n\t\t\t\t\tint packet_type)\n{\n\tswitch (packet_type) {\n\tcase PACKET_V4_STATUS:\n\t\tprocess_packet_status_v4(psmouse);\n\t\tbreak;\n\n\tcase PACKET_V4_HEAD:\n\t\tprocess_packet_head_v4(psmouse);\n\t\tbreak;\n\n\tcase PACKET_V4_MOTION:\n\t\tprocess_packet_motion_v4(psmouse);\n\t\tbreak;\n\n\tcase PACKET_UNKNOWN:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic int elantech_packet_check_v1(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tunsigned char p1, p2, p3;\n\n\t \n\tif (etd->info.fw_version < 0x020000) {\n\t\t \n\t\tp1 = (packet[0] & 0x20) >> 5;\n\t\tp2 = (packet[0] & 0x10) >> 4;\n\t} else {\n\t\t \n\t\tp1 = (packet[0] & 0x10) >> 4;\n\t\tp2 = (packet[0] & 0x20) >> 5;\n\t}\n\n\tp3 = (packet[0] & 0x04) >> 2;\n\n\treturn etd->parity[packet[1]] == p1 &&\n\t       etd->parity[packet[2]] == p2 &&\n\t       etd->parity[packet[3]] == p3;\n}\n\nstatic int elantech_debounce_check_v2(struct psmouse *psmouse)\n{\n         \n\tstatic const u8 debounce_packet[] = {\n\t\t0x84, 0xff, 0xff, 0x02, 0xff, 0xff\n\t};\n        unsigned char *packet = psmouse->packet;\n\n        return !memcmp(packet, debounce_packet, sizeof(debounce_packet));\n}\n\nstatic int elantech_packet_check_v2(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\n\t \n\tif (etd->info.reports_pressure)\n\t\treturn (packet[0] & 0x0c) == 0x04 &&\n\t\t       (packet[3] & 0x0f) == 0x02;\n\n\tif ((packet[0] & 0xc0) == 0x80)\n\t\treturn (packet[0] & 0x0c) == 0x0c &&\n\t\t       (packet[3] & 0x0e) == 0x08;\n\n\treturn (packet[0] & 0x3c) == 0x3c &&\n\t       (packet[1] & 0xf0) == 0x00 &&\n\t       (packet[3] & 0x3e) == 0x38 &&\n\t       (packet[4] & 0xf0) == 0x00;\n}\n\n \nstatic int elantech_packet_check_v3(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tstatic const u8 debounce_packet[] = {\n\t\t0xc4, 0xff, 0xff, 0x02, 0xff, 0xff\n\t};\n\tunsigned char *packet = psmouse->packet;\n\n\t \n\tif (!memcmp(packet, debounce_packet, sizeof(debounce_packet)))\n\t\treturn PACKET_DEBOUNCE;\n\n\t \n\tif (etd->info.crc_enabled) {\n\t\tif ((packet[3] & 0x09) == 0x08)\n\t\t\treturn PACKET_V3_HEAD;\n\n\t\tif ((packet[3] & 0x09) == 0x09)\n\t\t\treturn PACKET_V3_TAIL;\n\t} else {\n\t\tif ((packet[0] & 0x0c) == 0x04 && (packet[3] & 0xcf) == 0x02)\n\t\t\treturn PACKET_V3_HEAD;\n\n\t\tif ((packet[0] & 0x0c) == 0x0c && (packet[3] & 0xce) == 0x0c)\n\t\t\treturn PACKET_V3_TAIL;\n\t\tif ((packet[3] & 0x0f) == 0x06)\n\t\t\treturn PACKET_TRACKPOINT;\n\t}\n\n\treturn PACKET_UNKNOWN;\n}\n\nstatic int elantech_packet_check_v4(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tunsigned char packet_type = packet[3] & 0x03;\n\tunsigned int ic_version;\n\tbool sanity_check;\n\n\tif (etd->tp_dev && (packet[3] & 0x0f) == 0x06)\n\t\treturn PACKET_TRACKPOINT;\n\n\t \n\tic_version = (etd->info.fw_version & 0x0f0000) >> 16;\n\n\t \n\tif (etd->info.crc_enabled)\n\t\tsanity_check = ((packet[3] & 0x08) == 0x00);\n\telse if (ic_version == 7 && etd->info.samples[1] == 0x2A)\n\t\tsanity_check = ((packet[3] & 0x1c) == 0x10);\n\telse\n\t\tsanity_check = ((packet[0] & 0x08) == 0x00 &&\n\t\t\t\t(packet[3] & 0x1c) == 0x10);\n\n\tif (!sanity_check)\n\t\treturn PACKET_UNKNOWN;\n\n\tswitch (packet_type) {\n\tcase 0:\n\t\treturn PACKET_V4_STATUS;\n\n\tcase 1:\n\t\treturn PACKET_V4_HEAD;\n\n\tcase 2:\n\t\treturn PACKET_V4_MOTION;\n\t}\n\n\treturn PACKET_UNKNOWN;\n}\n\n \nstatic psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tint packet_type;\n\n\tif (psmouse->pktcnt < psmouse->pktsize)\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\tif (etd->info.debug > 1)\n\t\telantech_packet_dump(psmouse);\n\n\tswitch (etd->info.hw_version) {\n\tcase 1:\n\t\tif (etd->info.paritycheck && !elantech_packet_check_v1(psmouse))\n\t\t\treturn PSMOUSE_BAD_DATA;\n\n\t\telantech_report_absolute_v1(psmouse);\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tif (elantech_debounce_check_v2(psmouse))\n\t\t\treturn PSMOUSE_FULL_PACKET;\n\n\t\tif (etd->info.paritycheck && !elantech_packet_check_v2(psmouse))\n\t\t\treturn PSMOUSE_BAD_DATA;\n\n\t\telantech_report_absolute_v2(psmouse);\n\t\tbreak;\n\n\tcase 3:\n\t\tpacket_type = elantech_packet_check_v3(psmouse);\n\t\tswitch (packet_type) {\n\t\tcase PACKET_UNKNOWN:\n\t\t\treturn PSMOUSE_BAD_DATA;\n\n\t\tcase PACKET_DEBOUNCE:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase PACKET_TRACKPOINT:\n\t\t\telantech_report_trackpoint(psmouse, packet_type);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telantech_report_absolute_v3(psmouse, packet_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase 4:\n\t\tpacket_type = elantech_packet_check_v4(psmouse);\n\t\tswitch (packet_type) {\n\t\tcase PACKET_UNKNOWN:\n\t\t\treturn PSMOUSE_BAD_DATA;\n\n\t\tcase PACKET_TRACKPOINT:\n\t\t\telantech_report_trackpoint(psmouse, packet_type);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telantech_report_absolute_v4(psmouse, packet_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn PSMOUSE_FULL_PACKET;\n}\n\n \nstatic void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,\n\t\tunsigned int rate)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\n\tetd->original_set_rate(psmouse, rate);\n\tif (elantech_write_reg(psmouse, 0x07, etd->reg_07))\n\t\tpsmouse_err(psmouse, \"restoring reg_07 failed\\n\");\n}\n\n \nstatic int elantech_set_absolute_mode(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tunsigned char val;\n\tint tries = ETP_READ_BACK_TRIES;\n\tint rc = 0;\n\n\tswitch (etd->info.hw_version) {\n\tcase 1:\n\t\tetd->reg_10 = 0x16;\n\t\tetd->reg_11 = 0x8f;\n\t\tif (elantech_write_reg(psmouse, 0x10, etd->reg_10) ||\n\t\t    elantech_write_reg(psmouse, 0x11, etd->reg_11)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\t\t\t\t \n\t\tetd->reg_10 = 0x54;\n\t\tetd->reg_11 = 0x88;\t \n\t\tetd->reg_21 = 0x60;\t \n\t\tif (elantech_write_reg(psmouse, 0x10, etd->reg_10) ||\n\t\t    elantech_write_reg(psmouse, 0x11, etd->reg_11) ||\n\t\t    elantech_write_reg(psmouse, 0x21, etd->reg_21)) {\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (etd->info.set_hw_resolution)\n\t\t\tetd->reg_10 = 0x0b;\n\t\telse\n\t\t\tetd->reg_10 = 0x01;\n\n\t\tif (elantech_write_reg(psmouse, 0x10, etd->reg_10))\n\t\t\trc = -1;\n\n\t\tbreak;\n\n\tcase 4:\n\t\tetd->reg_07 = 0x01;\n\t\tif (elantech_write_reg(psmouse, 0x07, etd->reg_07))\n\t\t\trc = -1;\n\n\t\tgoto skip_readback_reg_10;  \n\t}\n\n\tif (rc == 0) {\n\t\t \n\t\tdo {\n\t\t\trc = elantech_read_reg(psmouse, 0x10, &val);\n\t\t\tif (rc == 0)\n\t\t\t\tbreak;\n\t\t\ttries--;\n\t\t\telantech_debug(\"retrying read (%d).\\n\", tries);\n\t\t\tmsleep(ETP_READ_BACK_DELAY);\n\t\t} while (tries > 0);\n\n\t\tif (rc) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"failed to read back register 0x10.\\n\");\n\t\t} else if (etd->info.hw_version == 1 &&\n\t\t\t   !(val & ETP_R10_ABSOLUTE_MODE)) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"touchpad refuses to switch to absolute mode.\\n\");\n\t\t\trc = -1;\n\t\t}\n\t}\n\n skip_readback_reg_10:\n\tif (rc)\n\t\tpsmouse_err(psmouse, \"failed to initialise registers.\\n\");\n\n\treturn rc;\n}\n\n \nstatic unsigned int elantech_convert_res(unsigned int val)\n{\n\treturn (val * 10 + 790) * 10 / 254;\n}\n\nstatic int elantech_get_resolution_v4(struct psmouse *psmouse,\n\t\t\t\t      unsigned int *x_res,\n\t\t\t\t      unsigned int *y_res,\n\t\t\t\t      unsigned int *bus)\n{\n\tunsigned char param[3];\n\n\tif (elantech_send_cmd(psmouse, ETP_RESOLUTION_QUERY, param))\n\t\treturn -1;\n\n\t*x_res = elantech_convert_res(param[1] & 0x0f);\n\t*y_res = elantech_convert_res((param[1] & 0xf0) >> 4);\n\t*bus = param[2];\n\n\treturn 0;\n}\n\nstatic void elantech_set_buttonpad_prop(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\n\tif (elantech_is_buttonpad(&etd->info)) {\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, dev->propbit);\n\t\t__clear_bit(BTN_RIGHT, dev->keybit);\n\t}\n}\n\n \nstatic const struct dmi_system_id elantech_dmi_has_middle_button[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CELSIUS H730\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CELSIUS H760\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CELSIUS H780\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\n \nstatic int elantech_set_input_params(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct elantech_data *etd = psmouse->private;\n\tstruct elantech_device_info *info = &etd->info;\n\tunsigned int x_min = info->x_min, y_min = info->y_min,\n\t\t     x_max = info->x_max, y_max = info->y_max,\n\t\t     width = info->width;\n\n\t__set_bit(INPUT_PROP_POINTER, dev->propbit);\n\t__set_bit(EV_KEY, dev->evbit);\n\t__set_bit(EV_ABS, dev->evbit);\n\t__clear_bit(EV_REL, dev->evbit);\n\n\t__set_bit(BTN_LEFT, dev->keybit);\n\tif (info->has_middle_button)\n\t\t__set_bit(BTN_MIDDLE, dev->keybit);\n\t__set_bit(BTN_RIGHT, dev->keybit);\n\n\t__set_bit(BTN_TOUCH, dev->keybit);\n\t__set_bit(BTN_TOOL_FINGER, dev->keybit);\n\t__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\n\t__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);\n\n\tswitch (info->hw_version) {\n\tcase 1:\n\t\t \n\t\tif (info->fw_version < 0x020000 &&\n\t\t    (info->capabilities[0] & ETP_CAP_HAS_ROCKER)) {\n\t\t\t__set_bit(BTN_FORWARD, dev->keybit);\n\t\t\t__set_bit(BTN_BACK, dev->keybit);\n\t\t}\n\t\tinput_set_abs_params(dev, ABS_X, x_min, x_max, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_Y, y_min, y_max, 0, 0);\n\t\tbreak;\n\n\tcase 2:\n\t\t__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\n\t\t__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\n\t\tfallthrough;\n\tcase 3:\n\t\tif (info->hw_version == 3)\n\t\t\telantech_set_buttonpad_prop(psmouse);\n\t\tinput_set_abs_params(dev, ABS_X, x_min, x_max, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_Y, y_min, y_max, 0, 0);\n\t\tif (info->reports_pressure) {\n\t\t\tinput_set_abs_params(dev, ABS_PRESSURE, ETP_PMIN_V2,\n\t\t\t\t\t     ETP_PMAX_V2, 0, 0);\n\t\t\tinput_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,\n\t\t\t\t\t     ETP_WMAX_V2, 0, 0);\n\t\t}\n\t\tinput_mt_init_slots(dev, 2, INPUT_MT_SEMI_MT);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);\n\t\tbreak;\n\n\tcase 4:\n\t\telantech_set_buttonpad_prop(psmouse);\n\t\t__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\n\t\t \n\t\tinput_set_abs_params(dev, ABS_X, x_min, x_max, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_Y, y_min, y_max, 0, 0);\n\t\t \n\t\tinput_set_abs_params(dev, ABS_PRESSURE, ETP_PMIN_V2,\n\t\t\t\t     ETP_PMAX_V2, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,\n\t\t\t\t     ETP_WMAX_V2, 0, 0);\n\t\t \n\t\tinput_mt_init_slots(dev, ETP_MAX_FINGERS, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_PRESSURE, ETP_PMIN_V2,\n\t\t\t\t     ETP_PMAX_V2, 0, 0);\n\t\t \n\t\tinput_set_abs_params(dev, ABS_MT_TOUCH_MAJOR, 0,\n\t\t\t\t     ETP_WMAX_V2 * width, 0, 0);\n\t\tbreak;\n\t}\n\n\tinput_abs_set_res(dev, ABS_X, info->x_res);\n\tinput_abs_set_res(dev, ABS_Y, info->y_res);\n\tif (info->hw_version > 1) {\n\t\tinput_abs_set_res(dev, ABS_MT_POSITION_X, info->x_res);\n\t\tinput_abs_set_res(dev, ABS_MT_POSITION_Y, info->y_res);\n\t}\n\n\tetd->y_max = y_max;\n\tetd->width = width;\n\n\treturn 0;\n}\n\nstruct elantech_attr_data {\n\tsize_t\t\tfield_offset;\n\tunsigned char\treg;\n};\n\n \nstatic ssize_t elantech_show_int_attr(struct psmouse *psmouse, void *data,\n\t\t\t\t\tchar *buf)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tstruct elantech_attr_data *attr = data;\n\tunsigned char *reg = (unsigned char *) etd + attr->field_offset;\n\tint rc = 0;\n\n\tif (attr->reg)\n\t\trc = elantech_read_reg(psmouse, attr->reg, reg);\n\n\treturn sprintf(buf, \"0x%02x\\n\", (attr->reg && rc) ? -1 : *reg);\n}\n\n \nstatic ssize_t elantech_set_int_attr(struct psmouse *psmouse,\n\t\t\t\t     void *data, const char *buf, size_t count)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\tstruct elantech_attr_data *attr = data;\n\tunsigned char *reg = (unsigned char *) etd + attr->field_offset;\n\tunsigned char value;\n\tint err;\n\n\terr = kstrtou8(buf, 16, &value);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (etd->info.hw_version == 1) {\n\t\tif (attr->reg == 0x10)\n\t\t\t \n\t\t\tvalue |= ETP_R10_ABSOLUTE_MODE;\n\t\telse if (attr->reg == 0x11)\n\t\t\t \n\t\t\tvalue |= ETP_R11_4_BYTE_MODE;\n\t}\n\n\tif (!attr->reg || elantech_write_reg(psmouse, attr->reg, value) == 0)\n\t\t*reg = value;\n\n\treturn count;\n}\n\n#define ELANTECH_INT_ATTR(_name, _register)\t\t\t\t\\\n\tstatic struct elantech_attr_data elantech_attr_##_name = {\t\\\n\t\t.field_offset = offsetof(struct elantech_data, _name),\t\\\n\t\t.reg = _register,\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tPSMOUSE_DEFINE_ATTR(_name, 0644,\t\t\t\t\\\n\t\t\t    &elantech_attr_##_name,\t\t\t\\\n\t\t\t    elantech_show_int_attr,\t\t\t\\\n\t\t\t    elantech_set_int_attr)\n\n#define ELANTECH_INFO_ATTR(_name)\t\t\t\t\t       \\\n\tstatic struct elantech_attr_data elantech_attr_##_name = {\t       \\\n\t\t.field_offset = offsetof(struct elantech_data, info) +\t       \\\n\t\t\t\toffsetof(struct elantech_device_info, _name),  \\\n\t\t.reg = 0,\t\t\t\t\t\t       \\\n\t};\t\t\t\t\t\t\t\t       \\\n\tPSMOUSE_DEFINE_ATTR(_name, 0644,\t\t\t\t       \\\n\t\t\t    &elantech_attr_##_name,\t\t\t       \\\n\t\t\t    elantech_show_int_attr,\t\t\t       \\\n\t\t\t    elantech_set_int_attr)\n\nELANTECH_INT_ATTR(reg_07, 0x07);\nELANTECH_INT_ATTR(reg_10, 0x10);\nELANTECH_INT_ATTR(reg_11, 0x11);\nELANTECH_INT_ATTR(reg_20, 0x20);\nELANTECH_INT_ATTR(reg_21, 0x21);\nELANTECH_INT_ATTR(reg_22, 0x22);\nELANTECH_INT_ATTR(reg_23, 0x23);\nELANTECH_INT_ATTR(reg_24, 0x24);\nELANTECH_INT_ATTR(reg_25, 0x25);\nELANTECH_INT_ATTR(reg_26, 0x26);\nELANTECH_INFO_ATTR(debug);\nELANTECH_INFO_ATTR(paritycheck);\nELANTECH_INFO_ATTR(crc_enabled);\n\nstatic struct attribute *elantech_attrs[] = {\n\t&psmouse_attr_reg_07.dattr.attr,\n\t&psmouse_attr_reg_10.dattr.attr,\n\t&psmouse_attr_reg_11.dattr.attr,\n\t&psmouse_attr_reg_20.dattr.attr,\n\t&psmouse_attr_reg_21.dattr.attr,\n\t&psmouse_attr_reg_22.dattr.attr,\n\t&psmouse_attr_reg_23.dattr.attr,\n\t&psmouse_attr_reg_24.dattr.attr,\n\t&psmouse_attr_reg_25.dattr.attr,\n\t&psmouse_attr_reg_26.dattr.attr,\n\t&psmouse_attr_debug.dattr.attr,\n\t&psmouse_attr_paritycheck.dattr.attr,\n\t&psmouse_attr_crc_enabled.dattr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group elantech_attr_group = {\n\t.attrs = elantech_attrs,\n};\n\nstatic bool elantech_is_signature_valid(const unsigned char *param)\n{\n\tstatic const unsigned char rates[] = { 200, 100, 80, 60, 40, 20, 10 };\n\tint i;\n\n\tif (param[0] == 0)\n\t\treturn false;\n\n\tif (param[1] == 0)\n\t\treturn true;\n\n\t \n\tif ((param[0] & 0x0f) >= 0x06 && (param[1] & 0xaf) == 0x0f &&\n\t    param[2] < 40)\n\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(rates); i++)\n\t\tif (param[2] == rates[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\n \nint elantech_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[3];\n\n\tps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\n\n\tif (ps2_command(ps2dev,  NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\n\t\tpsmouse_dbg(psmouse, \"sending Elantech magic knock failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (param[0] != 0x3c || param[1] != 0x03 ||\n\t    (param[2] != 0xc8 && param[2] != 0x00)) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"unexpected magic knock result 0x%02x, 0x%02x, 0x%02x.\\n\",\n\t\t\t    param[0], param[1], param[2]);\n\t\treturn -1;\n\t}\n\n\t \n\tif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {\n\t\tpsmouse_dbg(psmouse, \"failed to query firmware version.\\n\");\n\t\treturn -1;\n\t}\n\n\tpsmouse_dbg(psmouse,\n\t\t    \"Elantech version query result 0x%02x, 0x%02x, 0x%02x.\\n\",\n\t\t    param[0], param[1], param[2]);\n\n\tif (!elantech_is_signature_valid(param)) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"Probably not a real Elantech touchpad. Aborting.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"Elantech\";\n\t\tpsmouse->name = \"Touchpad\";\n\t}\n\n\treturn 0;\n}\n\n \nstatic void elantech_disconnect(struct psmouse *psmouse)\n{\n\tstruct elantech_data *etd = psmouse->private;\n\n\t \n\tpsmouse_smbus_cleanup(psmouse);\n\n\tif (etd->tp_dev)\n\t\tinput_unregister_device(etd->tp_dev);\n\tsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\n\t\t\t   &elantech_attr_group);\n\tkfree(psmouse->private);\n\tpsmouse->private = NULL;\n}\n\n \nstatic int elantech_reconnect(struct psmouse *psmouse)\n{\n\tpsmouse_reset(psmouse);\n\n\tif (elantech_detect(psmouse, 0))\n\t\treturn -1;\n\n\tif (elantech_set_absolute_mode(psmouse)) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to put touchpad back into absolute mode.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CELSIUS H730\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CELSIUS H760\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK E544\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK E546\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK E547\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK E554\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK E556\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK E557\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK U745\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\n \nstatic const struct dmi_system_id no_hw_res_dmi_table[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GIGABYTE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"U2442\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\n \nstatic int elantech_change_report_id(struct psmouse *psmouse)\n{\n\t \n\tunsigned char param[3] = { 0x10, 0x03 };\n\n\tif (elantech_write_reg_params(psmouse, 0x7, param) ||\n\t    elantech_read_reg_params(psmouse, 0x7, param) ||\n\t    param[0] != 0x10 || param[1] != 0x03) {\n\t\tpsmouse_err(psmouse, \"Unable to change report ID to 0x5f.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n \nstatic int elantech_set_properties(struct elantech_device_info *info)\n{\n\t \n\tinfo->ic_version = (info->fw_version & 0x0f0000) >> 16;\n\n\t \n\tif (info->fw_version < 0x020030 || info->fw_version == 0x020600)\n\t\tinfo->hw_version = 1;\n\telse {\n\t\tswitch (info->ic_version) {\n\t\tcase 2:\n\t\tcase 4:\n\t\t\tinfo->hw_version = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tinfo->hw_version = 3;\n\t\t\tbreak;\n\t\tcase 6 ... 15:\n\t\t\tinfo->hw_version = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tinfo->pattern = 0x00;\n\tif (info->ic_version == 0x0f && (info->fw_version & 0xff) <= 0x02)\n\t\tinfo->pattern = info->fw_version & 0xff;\n\n\t \n\tinfo->send_cmd = info->hw_version >= 3 ? elantech_send_cmd :\n\t\t\t\t\t\t synaptics_send_cmd;\n\n\t \n\tinfo->paritycheck = 1;\n\n\t \n\tinfo->jumpy_cursor =\n\t\t(info->fw_version == 0x020022 || info->fw_version == 0x020600);\n\n\tif (info->hw_version > 1) {\n\t\t \n\t\tinfo->debug = 1;\n\n\t\tif (info->fw_version >= 0x020800)\n\t\t\tinfo->reports_pressure = true;\n\t}\n\n\t \n\tinfo->crc_enabled = (info->fw_version & 0x4000) == 0x4000 ||\n\t\t\t     dmi_check_system(elantech_dmi_force_crc_enabled);\n\n\t \n\tinfo->set_hw_resolution = !dmi_check_system(no_hw_res_dmi_table);\n\n\treturn 0;\n}\n\nstatic int elantech_query_info(struct psmouse *psmouse,\n\t\t\t       struct elantech_device_info *info)\n{\n\tunsigned char param[3];\n\tunsigned char traces;\n\tunsigned char ic_body[3];\n\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\tif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {\n\t\tpsmouse_err(psmouse, \"failed to query firmware version.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tinfo->fw_version = (param[0] << 16) | (param[1] << 8) | param[2];\n\n\tif (elantech_set_properties(info)) {\n\t\tpsmouse_err(psmouse, \"unknown hardware version, aborting...\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpsmouse_info(psmouse,\n\t\t     \"assuming hardware version %d (with firmware version 0x%02x%02x%02x)\\n\",\n\t\t     info->hw_version, param[0], param[1], param[2]);\n\n\tif (info->send_cmd(psmouse, ETP_CAPABILITIES_QUERY,\n\t    info->capabilities)) {\n\t\tpsmouse_err(psmouse, \"failed to query capabilities.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpsmouse_info(psmouse,\n\t\t     \"Synaptics capabilities query result 0x%02x, 0x%02x, 0x%02x.\\n\",\n\t\t     info->capabilities[0], info->capabilities[1],\n\t\t     info->capabilities[2]);\n\n\tif (info->hw_version != 1) {\n\t\tif (info->send_cmd(psmouse, ETP_SAMPLE_QUERY, info->samples)) {\n\t\t\tpsmouse_err(psmouse, \"failed to query sample data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpsmouse_info(psmouse,\n\t\t\t     \"Elan sample query result %02x, %02x, %02x\\n\",\n\t\t\t     info->samples[0],\n\t\t\t     info->samples[1],\n\t\t\t     info->samples[2]);\n\t}\n\n\tif (info->pattern > 0x00 && info->ic_version == 0xf) {\n\t\tif (info->send_cmd(psmouse, ETP_ICBODY_QUERY, ic_body)) {\n\t\t\tpsmouse_err(psmouse, \"failed to query ic body\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->ic_version = be16_to_cpup((__be16 *)ic_body);\n\t\tpsmouse_info(psmouse,\n\t\t\t     \"Elan ic body: %#04x, current fw version: %#02x\\n\",\n\t\t\t     info->ic_version, ic_body[2]);\n\t}\n\n\tinfo->product_id = be16_to_cpup((__be16 *)info->samples);\n\tif (info->pattern == 0x00)\n\t\tinfo->product_id &= 0xff;\n\n\tif (info->samples[1] == 0x74 && info->hw_version == 0x03) {\n\t\t \n\t\tpsmouse_info(psmouse,\n\t\t\t     \"absolute mode broken, forcing standard PS/2 protocol\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tinfo->has_trackpoint = (info->capabilities[0] & 0x80) == 0x80;\n\n\tif (info->has_trackpoint && info->ic_version == 0x0011 &&\n\t    (info->product_id == 0x08 || info->product_id == 0x09 ||\n\t     info->product_id == 0x0d || info->product_id == 0x0e)) {\n\t\t \n\t\tif (elantech_change_report_id(psmouse)) {\n\t\t\tpsmouse_info(psmouse,\n\t\t\t\t     \"Trackpoint report is broken, forcing standard PS/2 protocol\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tinfo->x_res = 31;\n\tinfo->y_res = 31;\n\tif (info->hw_version == 4) {\n\t\tif (elantech_get_resolution_v4(psmouse,\n\t\t\t\t\t       &info->x_res,\n\t\t\t\t\t       &info->y_res,\n\t\t\t\t\t       &info->bus)) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"failed to query resolution data.\\n\");\n\t\t}\n\t}\n\n\t \n\tswitch (info->hw_version) {\n\tcase 1:\n\t\tinfo->x_min = ETP_XMIN_V1;\n\t\tinfo->y_min = ETP_YMIN_V1;\n\t\tinfo->x_max = ETP_XMAX_V1;\n\t\tinfo->y_max = ETP_YMAX_V1;\n\t\tbreak;\n\n\tcase 2:\n\t\tif (info->fw_version == 0x020800 ||\n\t\t    info->fw_version == 0x020b00 ||\n\t\t    info->fw_version == 0x020030) {\n\t\t\tinfo->x_min = ETP_XMIN_V2;\n\t\t\tinfo->y_min = ETP_YMIN_V2;\n\t\t\tinfo->x_max = ETP_XMAX_V2;\n\t\t\tinfo->y_max = ETP_YMAX_V2;\n\t\t} else {\n\t\t\tint i;\n\t\t\tint fixed_dpi;\n\n\t\t\ti = (info->fw_version > 0x020800 &&\n\t\t\t     info->fw_version < 0x020900) ? 1 : 2;\n\n\t\t\tif (info->send_cmd(psmouse, ETP_FW_ID_QUERY, param))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfixed_dpi = param[1] & 0x10;\n\n\t\t\tif (((info->fw_version >> 16) == 0x14) && fixed_dpi) {\n\t\t\t\tif (info->send_cmd(psmouse, ETP_SAMPLE_QUERY, param))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tinfo->x_max = (info->capabilities[1] - i) * param[1] / 2;\n\t\t\t\tinfo->y_max = (info->capabilities[2] - i) * param[2] / 2;\n\t\t\t} else if (info->fw_version == 0x040216) {\n\t\t\t\tinfo->x_max = 819;\n\t\t\t\tinfo->y_max = 405;\n\t\t\t} else if (info->fw_version == 0x040219 || info->fw_version == 0x040215) {\n\t\t\t\tinfo->x_max = 900;\n\t\t\t\tinfo->y_max = 500;\n\t\t\t} else {\n\t\t\t\tinfo->x_max = (info->capabilities[1] - i) * 64;\n\t\t\t\tinfo->y_max = (info->capabilities[2] - i) * 64;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (info->send_cmd(psmouse, ETP_FW_ID_QUERY, param))\n\t\t\treturn -EINVAL;\n\n\t\tinfo->x_max = (0x0f & param[0]) << 8 | param[1];\n\t\tinfo->y_max = (0xf0 & param[0]) << 4 | param[2];\n\t\tbreak;\n\n\tcase 4:\n\t\tif (info->send_cmd(psmouse, ETP_FW_ID_QUERY, param))\n\t\t\treturn -EINVAL;\n\n\t\tinfo->x_max = (0x0f & param[0]) << 8 | param[1];\n\t\tinfo->y_max = (0xf0 & param[0]) << 4 | param[2];\n\t\ttraces = info->capabilities[1];\n\t\tif ((traces < 2) || (traces > info->x_max))\n\t\t\treturn -EINVAL;\n\n\t\tinfo->width = info->x_max / (traces - 1);\n\n\t\t \n\t\tinfo->x_traces = traces;\n\n\t\t \n\t\ttraces = info->capabilities[2];\n\t\tif ((traces >= 2) && (traces <= info->y_max))\n\t\t\tinfo->y_traces = traces;\n\n\t\tbreak;\n\t}\n\n\t \n\tinfo->has_middle_button = dmi_check_system(elantech_dmi_has_middle_button) ||\n\t\t\t\t  (ETP_NEW_IC_SMBUS_HOST_NOTIFY(info->fw_version) &&\n\t\t\t\t   !elantech_is_buttonpad(info));\n\n\treturn 0;\n}\n\n#if defined(CONFIG_MOUSE_PS2_ELANTECH_SMBUS)\n\n \nenum {\n\tELANTECH_SMBUS_NOT_SET = -1,\n\tELANTECH_SMBUS_OFF,\n\tELANTECH_SMBUS_ON,\n};\n\nstatic int elantech_smbus = IS_ENABLED(CONFIG_MOUSE_ELAN_I2C_SMBUS) ?\n\t\tELANTECH_SMBUS_NOT_SET : ELANTECH_SMBUS_OFF;\nmodule_param_named(elantech_smbus, elantech_smbus, int, 0644);\nMODULE_PARM_DESC(elantech_smbus, \"Use a secondary bus for the Elantech device.\");\n\nstatic const char * const i2c_blacklist_pnp_ids[] = {\n\t \n\tNULL\n};\n\nstatic int elantech_create_smbus(struct psmouse *psmouse,\n\t\t\t\t struct elantech_device_info *info,\n\t\t\t\t bool leave_breadcrumbs)\n{\n\tstruct property_entry i2c_props[11] = {};\n\tstruct i2c_board_info smbus_board = {\n\t\tI2C_BOARD_INFO(\"elan_i2c\", 0x15),\n\t\t.flags = I2C_CLIENT_HOST_NOTIFY,\n\t};\n\tunsigned int idx = 0;\n\n\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"touchscreen-size-x\",\n\t\t\t\t\t\t   info->x_max + 1);\n\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"touchscreen-size-y\",\n\t\t\t\t\t\t   info->y_max + 1);\n\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"touchscreen-min-x\",\n\t\t\t\t\t\t   info->x_min);\n\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"touchscreen-min-y\",\n\t\t\t\t\t\t   info->y_min);\n\tif (info->x_res)\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"touchscreen-x-mm\",\n\t\t\t\t\t\t      (info->x_max + 1) / info->x_res);\n\tif (info->y_res)\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"touchscreen-y-mm\",\n\t\t\t\t\t\t      (info->y_max + 1) / info->y_res);\n\n\tif (info->has_trackpoint)\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_BOOL(\"elan,trackpoint\");\n\n\tif (info->has_middle_button)\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_BOOL(\"elan,middle-button\");\n\n\tif (info->x_traces)\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"elan,x_traces\",\n\t\t\t\t\t\t      info->x_traces);\n\tif (info->y_traces)\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_U32(\"elan,y_traces\",\n\t\t\t\t\t\t      info->y_traces);\n\n\tif (elantech_is_buttonpad(info))\n\t\ti2c_props[idx++] = PROPERTY_ENTRY_BOOL(\"elan,clickpad\");\n\n\tsmbus_board.fwnode = fwnode_create_software_node(i2c_props, NULL);\n\tif (IS_ERR(smbus_board.fwnode))\n\t\treturn PTR_ERR(smbus_board.fwnode);\n\n\treturn psmouse_smbus_init(psmouse, &smbus_board, NULL, 0, false,\n\t\t\t\t  leave_breadcrumbs);\n}\n\n \nstatic int elantech_setup_smbus(struct psmouse *psmouse,\n\t\t\t\tstruct elantech_device_info *info,\n\t\t\t\tbool leave_breadcrumbs)\n{\n\tint error;\n\n\tif (elantech_smbus == ELANTECH_SMBUS_OFF)\n\t\treturn -ENXIO;\n\n\tif (elantech_smbus == ELANTECH_SMBUS_NOT_SET) {\n\t\t \n\t\tif (!ETP_NEW_IC_SMBUS_HOST_NOTIFY(info->fw_version) ||\n\t\t    psmouse_matches_pnp_id(psmouse, i2c_blacklist_pnp_ids))\n\t\t\treturn -ENXIO;\n\t}\n\n\tpsmouse_info(psmouse, \"Trying to set up SMBus access\\n\");\n\n\terror = elantech_create_smbus(psmouse, info, leave_breadcrumbs);\n\tif (error) {\n\t\tif (error == -EAGAIN)\n\t\t\tpsmouse_info(psmouse, \"SMbus companion is not ready yet\\n\");\n\t\telse\n\t\t\tpsmouse_err(psmouse, \"unable to create intertouch device\\n\");\n\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic bool elantech_use_host_notify(struct psmouse *psmouse,\n\t\t\t\t     struct elantech_device_info *info)\n{\n\tif (ETP_NEW_IC_SMBUS_HOST_NOTIFY(info->fw_version))\n\t\treturn true;\n\n\tswitch (info->bus) {\n\tcase ETP_BUS_PS2_ONLY:\n\t\t \n\t\tbreak;\n\tcase ETP_BUS_SMB_ALERT_ONLY:\n\tcase ETP_BUS_PS2_SMB_ALERT:\n\t\tpsmouse_dbg(psmouse, \"Ignoring SMBus provider through alert protocol.\\n\");\n\t\tbreak;\n\tcase ETP_BUS_SMB_HST_NTFY_ONLY:\n\tcase ETP_BUS_PS2_SMB_HST_NTFY:\n\t\treturn true;\n\tdefault:\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"Ignoring SMBus bus provider %d.\\n\",\n\t\t\t    info->bus);\n\t}\n\n\treturn false;\n}\n\nint elantech_init_smbus(struct psmouse *psmouse)\n{\n\tstruct elantech_device_info info;\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\n\terror = elantech_query_info(psmouse, &info);\n\tif (error)\n\t\tgoto init_fail;\n\n\tif (info.hw_version < 4) {\n\t\terror = -ENXIO;\n\t\tgoto init_fail;\n\t}\n\n\treturn elantech_create_smbus(psmouse, &info, false);\n init_fail:\n\tpsmouse_reset(psmouse);\n\treturn error;\n}\n#endif  \n\n \nstatic int elantech_setup_ps2(struct psmouse *psmouse,\n\t\t\t      struct elantech_device_info *info)\n{\n\tstruct elantech_data *etd;\n\tint i;\n\tint error = -EINVAL;\n\tstruct input_dev *tp_dev;\n\n\tpsmouse->private = etd = kzalloc(sizeof(*etd), GFP_KERNEL);\n\tif (!etd)\n\t\treturn -ENOMEM;\n\n\tetd->info = *info;\n\n\tetd->parity[0] = 1;\n\tfor (i = 1; i < 256; i++)\n\t\tetd->parity[i] = etd->parity[i & (i - 1)] ^ 1;\n\n\tif (elantech_set_absolute_mode(psmouse)) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to put touchpad into absolute mode.\\n\");\n\t\tgoto init_fail;\n\t}\n\n\tif (info->fw_version == 0x381f17) {\n\t\tetd->original_set_rate = psmouse->set_rate;\n\t\tpsmouse->set_rate = elantech_set_rate_restore_reg_07;\n\t}\n\n\tif (elantech_set_input_params(psmouse)) {\n\t\tpsmouse_err(psmouse, \"failed to query touchpad range.\\n\");\n\t\tgoto init_fail;\n\t}\n\n\terror = sysfs_create_group(&psmouse->ps2dev.serio->dev.kobj,\n\t\t\t\t   &elantech_attr_group);\n\tif (error) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to create sysfs attributes, error: %d.\\n\",\n\t\t\t    error);\n\t\tgoto init_fail;\n\t}\n\n\tif (info->has_trackpoint) {\n\t\ttp_dev = input_allocate_device();\n\n\t\tif (!tp_dev) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto init_fail_tp_alloc;\n\t\t}\n\n\t\tetd->tp_dev = tp_dev;\n\t\tsnprintf(etd->tp_phys, sizeof(etd->tp_phys), \"%s/input1\",\n\t\t\tpsmouse->ps2dev.serio->phys);\n\t\ttp_dev->phys = etd->tp_phys;\n\t\ttp_dev->name = \"ETPS/2 Elantech TrackPoint\";\n\t\ttp_dev->id.bustype = BUS_I8042;\n\t\ttp_dev->id.vendor  = 0x0002;\n\t\ttp_dev->id.product = PSMOUSE_ELANTECH;\n\t\ttp_dev->id.version = 0x0000;\n\t\ttp_dev->dev.parent = &psmouse->ps2dev.serio->dev;\n\t\ttp_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\t\ttp_dev->relbit[BIT_WORD(REL_X)] =\n\t\t\tBIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\t\ttp_dev->keybit[BIT_WORD(BTN_LEFT)] =\n\t\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) |\n\t\t\tBIT_MASK(BTN_RIGHT);\n\n\t\t__set_bit(INPUT_PROP_POINTER, tp_dev->propbit);\n\t\t__set_bit(INPUT_PROP_POINTING_STICK, tp_dev->propbit);\n\n\t\terror = input_register_device(etd->tp_dev);\n\t\tif (error < 0)\n\t\t\tgoto init_fail_tp_reg;\n\t}\n\n\tpsmouse->protocol_handler = elantech_process_byte;\n\tpsmouse->disconnect = elantech_disconnect;\n\tpsmouse->reconnect = elantech_reconnect;\n\tpsmouse->fast_reconnect = NULL;\n\tpsmouse->pktsize = info->hw_version > 1 ? 6 : 4;\n\n\treturn 0;\n init_fail_tp_reg:\n\tinput_free_device(tp_dev);\n init_fail_tp_alloc:\n\tsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\n\t\t\t   &elantech_attr_group);\n init_fail:\n\tkfree(etd);\n\treturn error;\n}\n\nint elantech_init_ps2(struct psmouse *psmouse)\n{\n\tstruct elantech_device_info info;\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\n\terror = elantech_query_info(psmouse, &info);\n\tif (error)\n\t\tgoto init_fail;\n\n\terror = elantech_setup_ps2(psmouse, &info);\n\tif (error)\n\t\tgoto init_fail;\n\n\treturn 0;\n init_fail:\n\tpsmouse_reset(psmouse);\n\treturn error;\n}\n\nint elantech_init(struct psmouse *psmouse)\n{\n\tstruct elantech_device_info info;\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\n\terror = elantech_query_info(psmouse, &info);\n\tif (error)\n\t\tgoto init_fail;\n\n#if defined(CONFIG_MOUSE_PS2_ELANTECH_SMBUS)\n\n\tif (elantech_use_host_notify(psmouse, &info)) {\n\t\tif (!IS_ENABLED(CONFIG_MOUSE_ELAN_I2C_SMBUS) ||\n\t\t    !IS_ENABLED(CONFIG_MOUSE_PS2_ELANTECH_SMBUS)) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"The touchpad can support a better bus than the too old PS/2 protocol. \"\n\t\t\t\t     \"Make sure MOUSE_PS2_ELANTECH_SMBUS and MOUSE_ELAN_I2C_SMBUS are enabled to get a better touchpad experience.\\n\");\n\t\t}\n\t\terror = elantech_setup_smbus(psmouse, &info, true);\n\t\tif (!error)\n\t\t\treturn PSMOUSE_ELANTECH_SMBUS;\n\t}\n\n#endif  \n\n\terror = elantech_setup_ps2(psmouse, &info);\n\tif (error < 0) {\n\t\t \n\t\tpsmouse_smbus_cleanup(psmouse);\n\t\tgoto init_fail;\n\t}\n\n\treturn PSMOUSE_ELANTECH;\n init_fail:\n\tpsmouse_reset(psmouse);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}