{
  "module_name": "cyapa_gen5.c",
  "hash_id": "f0eafe5ff7f1a74ec2151e3fc42da1748ffd58af62edaac9a5e2f4fcef0505a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/cyapa_gen5.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/crc-itu-t.h>\n#include <linux/pm_runtime.h>\n#include \"cyapa.h\"\n\n\n \n#define CYAPA_TSG_FLASH_MAP_BLOCK_SIZE      0x80\n#define CYAPA_TSG_IMG_FW_HDR_SIZE           13\n#define CYAPA_TSG_FW_ROW_SIZE               (CYAPA_TSG_FLASH_MAP_BLOCK_SIZE)\n#define CYAPA_TSG_IMG_START_ROW_NUM         0x002e\n#define CYAPA_TSG_IMG_END_ROW_NUM           0x01fe\n#define CYAPA_TSG_IMG_APP_INTEGRITY_ROW_NUM 0x01ff\n#define CYAPA_TSG_IMG_MAX_RECORDS           (CYAPA_TSG_IMG_END_ROW_NUM - \\\n\t\t\t\tCYAPA_TSG_IMG_START_ROW_NUM + 1 + 1)\n#define CYAPA_TSG_IMG_READ_SIZE             (CYAPA_TSG_FLASH_MAP_BLOCK_SIZE / 2)\n#define CYAPA_TSG_START_OF_APPLICATION      0x1700\n#define CYAPA_TSG_APP_INTEGRITY_SIZE        60\n#define CYAPA_TSG_FLASH_MAP_METADATA_SIZE   60\n#define CYAPA_TSG_BL_KEY_SIZE               8\n\n#define CYAPA_TSG_MAX_CMD_SIZE              256\n\n \n#define PIP_BL_INITIATE_RESP_LEN            11\n#define PIP_BL_FAIL_EXIT_RESP_LEN           11\n#define PIP_BL_FAIL_EXIT_STATUS_CODE        0x0c\n#define PIP_BL_VERIFY_INTEGRITY_RESP_LEN    12\n#define PIP_BL_INTEGRITY_CHEKC_PASS         0x00\n#define PIP_BL_BLOCK_WRITE_RESP_LEN         11\n\n#define PIP_TOUCH_REPORT_ID         0x01\n#define PIP_BTN_REPORT_ID           0x03\n#define PIP_WAKEUP_EVENT_REPORT_ID  0x04\n#define PIP_PUSH_BTN_REPORT_ID      0x06\n#define GEN5_OLD_PUSH_BTN_REPORT_ID 0x05   \n#define PIP_PROXIMITY_REPORT_ID     0x07\n\n#define PIP_PROXIMITY_REPORT_SIZE\t6\n#define PIP_PROXIMITY_DISTANCE_OFFSET\t0x05\n#define PIP_PROXIMITY_DISTANCE_MASK\t0x01\n\n#define PIP_TOUCH_REPORT_HEAD_SIZE     7\n#define PIP_TOUCH_REPORT_MAX_SIZE      127\n#define PIP_BTN_REPORT_HEAD_SIZE       6\n#define PIP_BTN_REPORT_MAX_SIZE        14\n#define PIP_WAKEUP_EVENT_SIZE          4\n\n#define PIP_NUMBER_OF_TOUCH_OFFSET  5\n#define PIP_NUMBER_OF_TOUCH_MASK    0x1f\n#define PIP_BUTTONS_OFFSET          5\n#define PIP_BUTTONS_MASK            0x0f\n#define PIP_GET_EVENT_ID(reg)       (((reg) >> 5) & 0x03)\n#define PIP_GET_TOUCH_ID(reg)       ((reg) & 0x1f)\n#define PIP_TOUCH_TYPE_FINGER\t    0x00\n#define PIP_TOUCH_TYPE_PROXIMITY    0x01\n#define PIP_TOUCH_TYPE_HOVER\t    0x02\n#define PIP_GET_TOUCH_TYPE(reg)     ((reg) & 0x07)\n\n#define RECORD_EVENT_NONE        0\n#define RECORD_EVENT_TOUCHDOWN\t 1\n#define RECORD_EVENT_DISPLACE    2\n#define RECORD_EVENT_LIFTOFF     3\n\n#define PIP_SENSING_MODE_MUTUAL_CAP_FINE   0x00\n#define PIP_SENSING_MODE_SELF_CAP          0x02\n\n#define PIP_SET_PROXIMITY\t0x49\n\n \n#define GEN5_BL_MAX_OUTPUT_LENGTH     0x0100\n#define GEN5_APP_MAX_OUTPUT_LENGTH    0x00fe\n\n#define GEN5_POWER_STATE_ACTIVE              0x01\n#define GEN5_POWER_STATE_LOOK_FOR_TOUCH      0x02\n#define GEN5_POWER_STATE_READY               0x03\n#define GEN5_POWER_STATE_IDLE                0x04\n#define GEN5_POWER_STATE_BTN_ONLY            0x05\n#define GEN5_POWER_STATE_OFF                 0x06\n\n#define GEN5_POWER_READY_MAX_INTRVL_TIME  50    \n#define GEN5_POWER_IDLE_MAX_INTRVL_TIME   250   \n\n#define GEN5_CMD_GET_PARAMETER\t\t     0x05\n#define GEN5_CMD_SET_PARAMETER\t\t     0x06\n#define GEN5_PARAMETER_ACT_INTERVL_ID        0x4d\n#define GEN5_PARAMETER_ACT_INTERVL_SIZE      1\n#define GEN5_PARAMETER_ACT_LFT_INTERVL_ID    0x4f\n#define GEN5_PARAMETER_ACT_LFT_INTERVL_SIZE  2\n#define GEN5_PARAMETER_LP_INTRVL_ID          0x4c\n#define GEN5_PARAMETER_LP_INTRVL_SIZE        2\n\n#define GEN5_PARAMETER_DISABLE_PIP_REPORT    0x08\n\n#define GEN5_BL_REPORT_DESCRIPTOR_SIZE            0x1d\n#define GEN5_BL_REPORT_DESCRIPTOR_ID              0xfe\n#define GEN5_APP_REPORT_DESCRIPTOR_SIZE           0xee\n#define GEN5_APP_CONTRACT_REPORT_DESCRIPTOR_SIZE  0xfa\n#define GEN5_APP_REPORT_DESCRIPTOR_ID             0xf6\n\n#define GEN5_RETRIEVE_MUTUAL_PWC_DATA        0x00\n#define GEN5_RETRIEVE_SELF_CAP_PWC_DATA      0x01\n\n#define GEN5_RETRIEVE_DATA_ELEMENT_SIZE_MASK 0x07\n\n#define GEN5_CMD_EXECUTE_PANEL_SCAN          0x2a\n#define GEN5_CMD_RETRIEVE_PANEL_SCAN         0x2b\n#define GEN5_PANEL_SCAN_MUTUAL_RAW_DATA      0x00\n#define GEN5_PANEL_SCAN_MUTUAL_BASELINE      0x01\n#define GEN5_PANEL_SCAN_MUTUAL_DIFFCOUNT     0x02\n#define GEN5_PANEL_SCAN_SELF_RAW_DATA        0x03\n#define GEN5_PANEL_SCAN_SELF_BASELINE        0x04\n#define GEN5_PANEL_SCAN_SELF_DIFFCOUNT       0x05\n\n \n#define GEN5_RESP_DATA_STRUCTURE_OFFSET      10\n#define GEN5_PWC_DATA_ELEMENT_SIZE_MASK      0x07\n\n\nstruct cyapa_pip_touch_record {\n\t \n\tu8 touch_type;\n\n\t \n\tu8 touch_tip_event_id;\n\n\t \n\tu8 x_lo;\n\n\t \n\tu8 x_hi;\n\n\t \n\tu8 y_lo;\n\n\t \n\tu8 y_hi;\n\n\t \n\tu8 z;\n\n\t \n\tu8 major_axis_len;\n\n\t \n\tu8 minor_axis_len;\n\n\t \n\tu8 major_tool_len;\n\n\t \n\tu8 minor_tool_len;\n\n\t \n\tu8 orientation;\n} __packed;\n\nstruct cyapa_pip_report_data {\n\tu8 report_head[PIP_TOUCH_REPORT_HEAD_SIZE];\n\tstruct cyapa_pip_touch_record touch_records[10];\n} __packed;\n\nstruct cyapa_tsg_bin_image_head {\n\tu8 head_size;   \n\tu8 ttda_driver_major_version;   \n\tu8 ttda_driver_minor_version;   \n\tu8 fw_major_version;\n\tu8 fw_minor_version;\n\tu8 fw_revision_control_number[8];\n\tu8 silicon_id_hi;\n\tu8 silicon_id_lo;\n\tu8 chip_revision;\n\tu8 family_id;\n\tu8 bl_ver_maj;\n\tu8 bl_ver_min;\n} __packed;\n\nstruct cyapa_tsg_bin_image_data_record {\n\tu8 flash_array_id;\n\t__be16 row_number;\n\t \n\t__be16 record_len;\n\t \n\tu8 record_data[CYAPA_TSG_FW_ROW_SIZE];\n} __packed;\n\nstruct cyapa_tsg_bin_image {\n\tstruct cyapa_tsg_bin_image_head image_head;\n\tstruct cyapa_tsg_bin_image_data_record records[];\n} __packed;\n\nstruct pip_bl_packet_start {\n\tu8 sop;   \n\tu8 cmd_code;\n\t__le16 data_length;   \n} __packed;\n\nstruct pip_bl_packet_end {\n\t__le16 crc;\n\tu8 eop;   \n} __packed;\n\nstruct pip_bl_cmd_head {\n\t__le16 addr;    \n\t \n\t__le16 length;\n\tu8 report_id;   \n\tu8 rsvd;   \n\tstruct pip_bl_packet_start packet_start;\n\tu8 data[];   \n} __packed;\n\n \nstruct pip_bl_initiate_cmd_data {\n\t \n\tu8 key[CYAPA_TSG_BL_KEY_SIZE];\n\tu8 metadata_raw_parameter[CYAPA_TSG_FLASH_MAP_METADATA_SIZE];\n\t__le16 metadata_crc;\n} __packed;\n\nstruct tsg_bl_metadata_row_params {\n\t__le16 size;\n\t__le16 maximum_size;\n\t__le32 app_start;\n\t__le16 app_len;\n\t__le16 app_crc;\n\t__le32 app_entry;\n\t__le32 upgrade_start;\n\t__le16 upgrade_len;\n\t__le16 entry_row_crc;\n\tu8 padding[36];   \n\t__le16 metadata_crc;   \n} __packed;\n\n \nstruct tsg_bl_flash_row_head {\n\tu8 flash_array_id;\n\t__le16 flash_row_id;\n\tu8 flash_data[];\n} __packed;\n\nstruct pip_app_cmd_head {\n\t__le16 addr;    \n\t \n\t__le16 length;\n\tu8 report_id;   \n\tu8 rsvd;   \n\t \n\tu8 cmd_code;\n\tu8 parameter_data[];   \n} __packed;\n\n \nstruct gen5_app_set_parameter_data {\n\tu8 parameter_id;\n\tu8 parameter_size;\n\t__le32 value;\n} __packed;\n\nstruct gen5_app_get_parameter_data {\n\tu8 parameter_id;\n} __packed;\n\nstruct gen5_retrieve_panel_scan_data {\n\t__le16 read_offset;\n\t__le16 read_elements;\n\tu8 data_id;\n} __packed;\n\nu8 pip_read_sys_info[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x02 };\nu8 pip_bl_read_app_info[] = { 0x04, 0x00, 0x0b, 0x00, 0x40, 0x00,\n\t\t0x01, 0x3c, 0x00, 0x00, 0xb0, 0x42, 0x17\n\t};\n\nstatic u8 cyapa_pip_bl_cmd_key[] = { 0xa5, 0x01, 0x02, 0x03,\n\t0xff, 0xfe, 0xfd, 0x5a };\n\nstatic int cyapa_pip_event_process(struct cyapa *cyapa,\n\t\t\t\t   struct cyapa_pip_report_data *report_data);\n\nint cyapa_pip_cmd_state_initialize(struct cyapa *cyapa)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\n\tinit_completion(&pip->cmd_ready);\n\tatomic_set(&pip->cmd_issued, 0);\n\tmutex_init(&pip->cmd_lock);\n\n\tmutex_init(&pip->pm_stage_lock);\n\tpip->pm_stage = CYAPA_PM_DEACTIVE;\n\n\tpip->resp_sort_func = NULL;\n\tpip->in_progress_cmd = PIP_INVALID_CMD;\n\tpip->resp_data = NULL;\n\tpip->resp_len = NULL;\n\n\tcyapa->dev_pwr_mode = UNINIT_PWR_MODE;\n\tcyapa->dev_sleep_time = UNINIT_SLEEP_TIME;\n\n\treturn 0;\n}\n\n \nssize_t cyapa_i2c_pip_read(struct cyapa *cyapa, u8 *buf, size_t size)\n{\n\tint ret;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tif (!buf || size > CYAPA_REG_MAP_SIZE)\n\t\treturn -EINVAL;\n\n\tret = i2c_master_recv(cyapa->client, buf, size);\n\n\tif (ret != size)\n\t\treturn (ret < 0) ? ret : -EIO;\n\treturn size;\n}\n\n \nssize_t cyapa_i2c_pip_write(struct cyapa *cyapa, u8 *buf, size_t size)\n{\n\tint ret;\n\n\tif (!buf || !size)\n\t\treturn -EINVAL;\n\n\tret = i2c_master_send(cyapa->client, buf, size);\n\n\tif (ret != size)\n\t\treturn (ret < 0) ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic void cyapa_set_pip_pm_state(struct cyapa *cyapa,\n\t\t\t\t   enum cyapa_pm_stage pm_stage)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\n\tmutex_lock(&pip->pm_stage_lock);\n\tpip->pm_stage = pm_stage;\n\tmutex_unlock(&pip->pm_stage_lock);\n}\n\nstatic void cyapa_reset_pip_pm_state(struct cyapa *cyapa)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\n\t \n\tmutex_lock(&pip->pm_stage_lock);\n\tpip->pm_stage = CYAPA_PM_DEACTIVE;\n\tmutex_unlock(&pip->pm_stage_lock);\n}\n\nstatic enum cyapa_pm_stage cyapa_get_pip_pm_state(struct cyapa *cyapa)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tenum cyapa_pm_stage pm_stage;\n\n\tmutex_lock(&pip->pm_stage_lock);\n\tpm_stage = pip->pm_stage;\n\tmutex_unlock(&pip->pm_stage_lock);\n\n\treturn pm_stage;\n}\n\n \nint cyapa_empty_pip_output_data(struct cyapa *cyapa,\n\t\tu8 *buf, int *len, cb_sort func)\n{\n\tstruct input_dev *input = cyapa->input;\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tenum cyapa_pm_stage pm_stage = cyapa_get_pip_pm_state(cyapa);\n\tint length;\n\tint report_count;\n\tint empty_count;\n\tint buf_len;\n\tint error;\n\n\tbuf_len = 0;\n\tif (len) {\n\t\tbuf_len = (*len < CYAPA_REG_MAP_SIZE) ?\n\t\t\t\t*len : CYAPA_REG_MAP_SIZE;\n\t\t*len = 0;\n\t}\n\n\treport_count = 8;   \n\tempty_count = 0;\n\tdo {\n\t\t \n\t\tif (empty_count > 5)\n\t\t\treturn 0;\n\n\t\terror = cyapa_i2c_pip_read(cyapa, pip->empty_buf,\n\t\t\t\tPIP_RESP_LENGTH_SIZE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tlength = get_unaligned_le16(pip->empty_buf);\n\t\tif (length == PIP_RESP_LENGTH_SIZE) {\n\t\t\tempty_count++;\n\t\t\tcontinue;\n\t\t} else if (length > CYAPA_REG_MAP_SIZE) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t} else if (length == 0) {\n\t\t\t \n\t\t\tlength = PIP_RESP_LENGTH_SIZE;\n\t\t\tif (buf && buf_len && func &&\n\t\t\t\tfunc(cyapa, pip->empty_buf, length)) {\n\t\t\t\tlength = min(buf_len, length);\n\t\t\t\tmemcpy(buf, pip->empty_buf, length);\n\t\t\t\t*len = length;\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = cyapa_i2c_pip_read(cyapa, pip->empty_buf, length);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\treport_count--;\n\t\tempty_count = 0;\n\t\tlength = get_unaligned_le16(pip->empty_buf);\n\t\tif (length <= PIP_RESP_LENGTH_SIZE) {\n\t\t\tempty_count++;\n\t\t} else if (buf && buf_len && func &&\n\t\t\tfunc(cyapa, pip->empty_buf, length)) {\n\t\t\tlength = min(buf_len, length);\n\t\t\tmemcpy(buf, pip->empty_buf, length);\n\t\t\t*len = length;\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if (cyapa->operational &&\n\t\t\t   input && input_device_enabled(input) &&\n\t\t\t   (pm_stage == CYAPA_PM_RUNTIME_RESUME ||\n\t\t\t    pm_stage == CYAPA_PM_RUNTIME_SUSPEND)) {\n\t\t\t \n\t\t\tcyapa_pip_event_process(cyapa,\n\t\t\t       (struct cyapa_pip_report_data *)pip->empty_buf);\n\t\t}\n\n\t\terror = -EINVAL;\n\t} while (report_count);\n\n\treturn error;\n}\n\nstatic int cyapa_do_i2c_pip_cmd_irq_sync(\n\t\tstruct cyapa *cyapa,\n\t\tu8 *cmd, size_t cmd_len,\n\t\tunsigned long timeout)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tint error;\n\n\t \n\tinit_completion(&pip->cmd_ready);\n\n\tatomic_inc(&pip->cmd_issued);\n\terror = cyapa_i2c_pip_write(cyapa, cmd, cmd_len);\n\tif (error) {\n\t\tatomic_dec(&pip->cmd_issued);\n\t\treturn (error < 0) ? error : -EIO;\n\t}\n\n\t \n\ttimeout = wait_for_completion_timeout(&pip->cmd_ready,\n\t\t\t\tmsecs_to_jiffies(timeout));\n\tif (timeout == 0) {\n\t\tatomic_dec(&pip->cmd_issued);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_do_i2c_pip_cmd_polling(\n\t\tstruct cyapa *cyapa,\n\t\tu8 *cmd, size_t cmd_len,\n\t\tu8 *resp_data, int *resp_len,\n\t\tunsigned long timeout,\n\t\tcb_sort func)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tint tries;\n\tint length;\n\tint error;\n\n\tatomic_inc(&pip->cmd_issued);\n\terror = cyapa_i2c_pip_write(cyapa, cmd, cmd_len);\n\tif (error) {\n\t\tatomic_dec(&pip->cmd_issued);\n\t\treturn error < 0 ? error : -EIO;\n\t}\n\n\tlength = resp_len ? *resp_len : 0;\n\tif (resp_data && resp_len && length != 0 && func) {\n\t\ttries = timeout / 5;\n\t\tdo {\n\t\t\tusleep_range(3000, 5000);\n\t\t\t*resp_len = length;\n\t\t\terror = cyapa_empty_pip_output_data(cyapa,\n\t\t\t\t\tresp_data, resp_len, func);\n\t\t\tif (error || *resp_len == 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t} while (--tries > 0);\n\t\tif ((error || *resp_len == 0) || tries <= 0)\n\t\t\terror = error ? error : -ETIMEDOUT;\n\t}\n\n\tatomic_dec(&pip->cmd_issued);\n\treturn error;\n}\n\nint cyapa_i2c_pip_cmd_irq_sync(\n\t\tstruct cyapa *cyapa,\n\t\tu8 *cmd, int cmd_len,\n\t\tu8 *resp_data, int *resp_len,\n\t\tunsigned long timeout,\n\t\tcb_sort func,\n\t\tbool irq_mode)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tint error;\n\n\tif (!cmd || !cmd_len)\n\t\treturn -EINVAL;\n\n\t \n\terror = mutex_lock_interruptible(&pip->cmd_lock);\n\tif (error)\n\t\treturn error;\n\n\tpip->resp_sort_func = func;\n\tpip->resp_data = resp_data;\n\tpip->resp_len = resp_len;\n\n\tif (cmd_len >= PIP_MIN_APP_CMD_LENGTH &&\n\t\t\tcmd[4] == PIP_APP_CMD_REPORT_ID) {\n\t\t \n\t\tpip->in_progress_cmd = cmd[6] & 0x7f;\n\t} else if (cmd_len >= PIP_MIN_BL_CMD_LENGTH &&\n\t\t\tcmd[4] == PIP_BL_CMD_REPORT_ID) {\n\t\t \n\t\tpip->in_progress_cmd = cmd[7];\n\t}\n\n\t \n\tif (irq_mode) {\n\t\tpip->is_irq_mode = true;\n\t\terror = cyapa_do_i2c_pip_cmd_irq_sync(cyapa, cmd, cmd_len,\n\t\t\t\t\t\t\ttimeout);\n\t\tif (error == -ETIMEDOUT && resp_data &&\n\t\t\t\tresp_len && *resp_len != 0 && func) {\n\t\t\t \n\t\t\terror = cyapa_empty_pip_output_data(cyapa,\n\t\t\t\t\tresp_data, resp_len, func);\n\t\t\tif (error || *resp_len == 0)\n\t\t\t\terror = error ? error : -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tpip->is_irq_mode = false;\n\t\terror = cyapa_do_i2c_pip_cmd_polling(cyapa, cmd, cmd_len,\n\t\t\t\tresp_data, resp_len, timeout, func);\n\t}\n\n\tpip->resp_sort_func = NULL;\n\tpip->resp_data = NULL;\n\tpip->resp_len = NULL;\n\tpip->in_progress_cmd = PIP_INVALID_CMD;\n\n\tmutex_unlock(&pip->cmd_lock);\n\treturn error;\n}\n\nbool cyapa_sort_tsg_pip_bl_resp_data(struct cyapa *cyapa,\n\t\tu8 *data, int len)\n{\n\tif (!data || len < PIP_MIN_BL_RESP_LENGTH)\n\t\treturn false;\n\n\t \n\tif (data[PIP_RESP_REPORT_ID_OFFSET] == PIP_BL_RESP_REPORT_ID &&\n\t\t\tdata[PIP_RESP_RSVD_OFFSET] == PIP_RESP_RSVD_KEY &&\n\t\t\tdata[PIP_RESP_BL_SOP_OFFSET] == PIP_SOP_KEY)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool cyapa_sort_tsg_pip_app_resp_data(struct cyapa *cyapa,\n\t\tu8 *data, int len)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tint resp_len;\n\n\tif (!data || len < PIP_MIN_APP_RESP_LENGTH)\n\t\treturn false;\n\n\tif (data[PIP_RESP_REPORT_ID_OFFSET] == PIP_APP_RESP_REPORT_ID &&\n\t\t\tdata[PIP_RESP_RSVD_OFFSET] == PIP_RESP_RSVD_KEY) {\n\t\tresp_len = get_unaligned_le16(&data[PIP_RESP_LENGTH_OFFSET]);\n\t\tif (GET_PIP_CMD_CODE(data[PIP_RESP_APP_CMD_OFFSET]) == 0x00 &&\n\t\t\tresp_len == PIP_UNSUPPORTED_CMD_RESP_LENGTH &&\n\t\t\tdata[5] == pip->in_progress_cmd) {\n\t\t\t \n\t\t\treturn false;\n\t\t} else if (GET_PIP_CMD_CODE(data[PIP_RESP_APP_CMD_OFFSET]) ==\n\t\t\t\tpip->in_progress_cmd) {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool cyapa_sort_pip_application_launch_data(struct cyapa *cyapa,\n\t\tu8 *buf, int len)\n{\n\tif (buf == NULL || len < PIP_RESP_LENGTH_SIZE)\n\t\treturn false;\n\n\t \n\tif (buf[0] == 0 && buf[1] == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool cyapa_sort_gen5_hid_descriptor_data(struct cyapa *cyapa,\n\t\tu8 *buf, int len)\n{\n\tint resp_len;\n\tint max_output_len;\n\n\t \n\tif (len != PIP_HID_DESCRIPTOR_SIZE)\n\t\treturn false;\n\n\tresp_len = get_unaligned_le16(&buf[PIP_RESP_LENGTH_OFFSET]);\n\tmax_output_len = get_unaligned_le16(&buf[16]);\n\tif (resp_len == PIP_HID_DESCRIPTOR_SIZE) {\n\t\tif (buf[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_BL_REPORT_ID &&\n\t\t\t\tmax_output_len == GEN5_BL_MAX_OUTPUT_LENGTH) {\n\t\t\t \n\t\t\treturn true;\n\t\t} else if ((buf[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_HID_APP_REPORT_ID) &&\n\t\t\t\tmax_output_len == GEN5_APP_MAX_OUTPUT_LENGTH) {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool cyapa_sort_pip_deep_sleep_data(struct cyapa *cyapa,\n\t\tu8 *buf, int len)\n{\n\tif (len == PIP_DEEP_SLEEP_RESP_LENGTH &&\n\t\tbuf[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\tPIP_APP_DEEP_SLEEP_REPORT_ID &&\n\t\t(buf[4] & PIP_DEEP_SLEEP_OPCODE_MASK) ==\n\t\t\tPIP_DEEP_SLEEP_OPCODE)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int gen5_idle_state_parse(struct cyapa *cyapa)\n{\n\tu8 resp_data[PIP_HID_DESCRIPTOR_SIZE];\n\tint max_output_len;\n\tint length;\n\tu8 cmd[2];\n\tint ret;\n\tint error;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\tmemset(resp_data, 0, sizeof(resp_data));\n\tret = cyapa_i2c_pip_read(cyapa, resp_data, 3);\n\tif (ret != 3)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tlength = get_unaligned_le16(&resp_data[PIP_RESP_LENGTH_OFFSET]);\n\tif (length == PIP_RESP_LENGTH_SIZE) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\n\t\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\t\t \n\t\tcmd[0] = 0x01;\n\t\tcmd[1] = 0x00;\n\t\tlength = PIP_HID_DESCRIPTOR_SIZE;\n\t\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\t\tcmd, PIP_RESP_LENGTH_SIZE,\n\t\t\t\tresp_data, &length,\n\t\t\t\t300,\n\t\t\t\tcyapa_sort_gen5_hid_descriptor_data,\n\t\t\t\tfalse);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tlength = get_unaligned_le16(\n\t\t\t\t&resp_data[PIP_RESP_LENGTH_OFFSET]);\n\t\tmax_output_len = get_unaligned_le16(&resp_data[16]);\n\t\tif ((length == PIP_HID_DESCRIPTOR_SIZE ||\n\t\t\t\tlength == PIP_RESP_LENGTH_SIZE) &&\n\t\t\t(resp_data[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_HID_BL_REPORT_ID) &&\n\t\t\tmax_output_len == GEN5_BL_MAX_OUTPUT_LENGTH) {\n\t\t\t \n\t\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\t\t} else if ((length == PIP_HID_DESCRIPTOR_SIZE ||\n\t\t\t\tlength == PIP_RESP_LENGTH_SIZE) &&\n\t\t\t(resp_data[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_HID_APP_REPORT_ID) &&\n\t\t\tmax_output_len == GEN5_APP_MAX_OUTPUT_LENGTH) {\n\t\t\t \n\t\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t\t} else {\n\t\t\t \n\t\t\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gen5_hid_description_header_parse(struct cyapa *cyapa, u8 *reg_data)\n{\n\tint length;\n\tu8 resp_data[32];\n\tint max_output_len;\n\tint ret;\n\n\t \n\tret = cyapa_i2c_pip_read(cyapa, resp_data,\n\t\t\tPIP_HID_DESCRIPTOR_SIZE);\n\tif (ret != PIP_HID_DESCRIPTOR_SIZE)\n\t\treturn ret < 0 ? ret : -EIO;\n\tlength = get_unaligned_le16(&resp_data[PIP_RESP_LENGTH_OFFSET]);\n\tmax_output_len = get_unaligned_le16(&resp_data[16]);\n\tif (length == PIP_RESP_LENGTH_SIZE) {\n\t\tif (reg_data[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_HID_BL_REPORT_ID) {\n\t\t\t \n\t\t\tcyapa->gen = CYAPA_GEN5;\n\t\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\t\t} else {\n\t\t\t \n\t\t\tcyapa->gen = CYAPA_GEN5;\n\t\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t\t}\n\t} else if (length == PIP_HID_DESCRIPTOR_SIZE &&\n\t\t\tresp_data[2] == PIP_HID_BL_REPORT_ID &&\n\t\t\tmax_output_len == GEN5_BL_MAX_OUTPUT_LENGTH) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\t} else if (length == PIP_HID_DESCRIPTOR_SIZE &&\n\t\t\t(resp_data[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_HID_APP_REPORT_ID) &&\n\t\t\tmax_output_len == GEN5_APP_MAX_OUTPUT_LENGTH) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t} else {\n\t\t \n\t\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\t}\n\n\treturn 0;\n}\n\nstatic int gen5_report_data_header_parse(struct cyapa *cyapa, u8 *reg_data)\n{\n\tint length;\n\n\tlength = get_unaligned_le16(&reg_data[PIP_RESP_LENGTH_OFFSET]);\n\tswitch (reg_data[PIP_RESP_REPORT_ID_OFFSET]) {\n\tcase PIP_TOUCH_REPORT_ID:\n\t\tif (length < PIP_TOUCH_REPORT_HEAD_SIZE ||\n\t\t\tlength > PIP_TOUCH_REPORT_MAX_SIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIP_BTN_REPORT_ID:\n\tcase GEN5_OLD_PUSH_BTN_REPORT_ID:\n\tcase PIP_PUSH_BTN_REPORT_ID:\n\t\tif (length < PIP_BTN_REPORT_HEAD_SIZE ||\n\t\t\tlength > PIP_BTN_REPORT_MAX_SIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIP_WAKEUP_EVENT_REPORT_ID:\n\t\tif (length != PIP_WAKEUP_EVENT_SIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcyapa->gen = CYAPA_GEN5;\n\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\treturn 0;\n}\n\nstatic int gen5_cmd_resp_header_parse(struct cyapa *cyapa, u8 *reg_data)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tint length;\n\tint ret;\n\n\t \n\tlength = get_unaligned_le16(&reg_data[PIP_RESP_LENGTH_OFFSET]);\n\tret = cyapa_i2c_pip_read(cyapa, pip->empty_buf, length);\n\tif (ret != length)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tif (length == PIP_RESP_LENGTH_SIZE) {\n\t\t \n\t\tif (reg_data[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_BL_RESP_REPORT_ID) {\n\t\t\t \n\t\t\tcyapa->gen = CYAPA_GEN5;\n\t\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\t\t} else {\n\t\t\t \n\t\t\tcyapa->gen = CYAPA_GEN5;\n\t\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t\t}\n\t} else if ((pip->empty_buf[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_BL_RESP_REPORT_ID) &&\n\t\t\t(pip->empty_buf[PIP_RESP_RSVD_OFFSET] ==\n\t\t\t\tPIP_RESP_RSVD_KEY) &&\n\t\t\t(pip->empty_buf[PIP_RESP_BL_SOP_OFFSET] ==\n\t\t\t\tPIP_SOP_KEY) &&\n\t\t\t(pip->empty_buf[length - 1] ==\n\t\t\t\tPIP_EOP_KEY)) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\t} else if (pip->empty_buf[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_APP_RESP_REPORT_ID &&\n\t\t\tpip->empty_buf[PIP_RESP_RSVD_OFFSET] ==\n\t\t\t\tPIP_RESP_RSVD_KEY) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t} else {\n\t\t \n\t\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_state_parse(struct cyapa *cyapa, u8 *reg_data, int len)\n{\n\tint length;\n\n\tif (!reg_data || len < 3)\n\t\treturn -EINVAL;\n\n\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\n\t \n\tlength = get_unaligned_le16(&reg_data[PIP_RESP_LENGTH_OFFSET]);\n\tif (length == 0 || length == PIP_RESP_LENGTH_SIZE) {\n\t\tgen5_idle_state_parse(cyapa);\n\t} else if (length == PIP_HID_DESCRIPTOR_SIZE &&\n\t\t\t(reg_data[2] == PIP_HID_BL_REPORT_ID ||\n\t\t\t\treg_data[2] == PIP_HID_APP_REPORT_ID)) {\n\t\tgen5_hid_description_header_parse(cyapa, reg_data);\n\t} else if ((length == GEN5_APP_REPORT_DESCRIPTOR_SIZE ||\n\t\t\tlength == GEN5_APP_CONTRACT_REPORT_DESCRIPTOR_SIZE) &&\n\t\t\treg_data[2] == GEN5_APP_REPORT_DESCRIPTOR_ID) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t} else if (length == GEN5_BL_REPORT_DESCRIPTOR_SIZE &&\n\t\t\treg_data[2] == GEN5_BL_REPORT_DESCRIPTOR_ID) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\t} else if (reg_data[2] == PIP_TOUCH_REPORT_ID ||\n\t\t\treg_data[2] == PIP_BTN_REPORT_ID ||\n\t\t\treg_data[2] == GEN5_OLD_PUSH_BTN_REPORT_ID ||\n\t\t\treg_data[2] == PIP_PUSH_BTN_REPORT_ID ||\n\t\t\treg_data[2] == PIP_WAKEUP_EVENT_REPORT_ID) {\n\t\tgen5_report_data_header_parse(cyapa, reg_data);\n\t} else if (reg_data[2] == PIP_BL_RESP_REPORT_ID ||\n\t\t\treg_data[2] == PIP_APP_RESP_REPORT_ID) {\n\t\tgen5_cmd_resp_header_parse(cyapa, reg_data);\n\t}\n\n\tif (cyapa->gen == CYAPA_GEN5) {\n\t\t \n\t\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\t\tif (cyapa->state == CYAPA_STATE_GEN5_APP ||\n\t\t\tcyapa->state == CYAPA_STATE_GEN5_BL)\n\t\t\treturn 0;\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic struct cyapa_tsg_bin_image_data_record *\ncyapa_get_image_record_data_num(const struct firmware *fw,\n\t\tint *record_num)\n{\n\tint head_size;\n\n\thead_size = fw->data[0] + 1;\n\t*record_num = (fw->size - head_size) /\n\t\t\tsizeof(struct cyapa_tsg_bin_image_data_record);\n\treturn (struct cyapa_tsg_bin_image_data_record *)&fw->data[head_size];\n}\n\nint cyapa_pip_bl_initiate(struct cyapa *cyapa, const struct firmware *fw)\n{\n\tstruct cyapa_tsg_bin_image_data_record *image_records;\n\tstruct pip_bl_cmd_head *bl_cmd_head;\n\tstruct pip_bl_packet_start *bl_packet_start;\n\tstruct pip_bl_initiate_cmd_data *cmd_data;\n\tstruct pip_bl_packet_end *bl_packet_end;\n\tu8 cmd[CYAPA_TSG_MAX_CMD_SIZE];\n\tint cmd_len;\n\tu16 cmd_data_len;\n\tu16 cmd_crc = 0;\n\tu16 meta_data_crc = 0;\n\tu8 resp_data[11];\n\tint resp_len;\n\tint records_num;\n\tu8 *data;\n\tint error;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\tmemset(cmd, 0, CYAPA_TSG_MAX_CMD_SIZE);\n\tbl_cmd_head = (struct pip_bl_cmd_head *)cmd;\n\tcmd_data_len = CYAPA_TSG_BL_KEY_SIZE + CYAPA_TSG_FLASH_MAP_BLOCK_SIZE;\n\tcmd_len = sizeof(struct pip_bl_cmd_head) + cmd_data_len +\n\t\t  sizeof(struct pip_bl_packet_end);\n\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &bl_cmd_head->addr);\n\tput_unaligned_le16(cmd_len - 2, &bl_cmd_head->length);\n\tbl_cmd_head->report_id = PIP_BL_CMD_REPORT_ID;\n\n\tbl_packet_start = &bl_cmd_head->packet_start;\n\tbl_packet_start->sop = PIP_SOP_KEY;\n\tbl_packet_start->cmd_code = PIP_BL_CMD_INITIATE_BL;\n\t \n\tput_unaligned_le16(cmd_data_len, &bl_packet_start->data_length);\n\n\tcmd_data = (struct pip_bl_initiate_cmd_data *)bl_cmd_head->data;\n\tmemcpy(cmd_data->key, cyapa_pip_bl_cmd_key, CYAPA_TSG_BL_KEY_SIZE);\n\n\timage_records = cyapa_get_image_record_data_num(fw, &records_num);\n\n\t \n\tdata = image_records[records_num - 1].record_data;\n\tmemcpy(cmd_data->metadata_raw_parameter, data,\n\t\tCYAPA_TSG_FLASH_MAP_METADATA_SIZE);\n\n\tmeta_data_crc = crc_itu_t(0xffff, cmd_data->metadata_raw_parameter,\n\t\t\t\tCYAPA_TSG_FLASH_MAP_METADATA_SIZE);\n\tput_unaligned_le16(meta_data_crc, &cmd_data->metadata_crc);\n\n\tbl_packet_end = (struct pip_bl_packet_end *)(bl_cmd_head->data +\n\t\t\t\tcmd_data_len);\n\tcmd_crc = crc_itu_t(0xffff, (u8 *)bl_packet_start,\n\t\tsizeof(struct pip_bl_packet_start) + cmd_data_len);\n\tput_unaligned_le16(cmd_crc, &bl_packet_end->crc);\n\tbl_packet_end->eop = PIP_EOP_KEY;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, cmd_len,\n\t\t\tresp_data, &resp_len, 12000,\n\t\t\tcyapa_sort_tsg_pip_bl_resp_data, true);\n\tif (error || resp_len != PIP_BL_INITIATE_RESP_LEN ||\n\t\t\tresp_data[2] != PIP_BL_RESP_REPORT_ID ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error ? error : -EAGAIN;\n\n\treturn 0;\n}\n\nstatic bool cyapa_sort_pip_bl_exit_data(struct cyapa *cyapa, u8 *buf, int len)\n{\n\tif (buf == NULL || len < PIP_RESP_LENGTH_SIZE)\n\t\treturn false;\n\n\tif (buf[0] == 0 && buf[1] == 0)\n\t\treturn true;\n\n\t \n\tif (len == PIP_BL_FAIL_EXIT_RESP_LEN &&\n\t\t\tbuf[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_BL_RESP_REPORT_ID &&\n\t\t\tbuf[PIP_RESP_RSVD_OFFSET] == PIP_RESP_RSVD_KEY &&\n\t\t\tbuf[PIP_RESP_BL_SOP_OFFSET] == PIP_SOP_KEY &&\n\t\t\tbuf[10] == PIP_EOP_KEY)\n\t\treturn true;\n\n\treturn false;\n}\n\nint cyapa_pip_bl_exit(struct cyapa *cyapa)\n{\n\n\tu8 bl_gen5_bl_exit[] = { 0x04, 0x00,\n\t\t0x0B, 0x00, 0x40, 0x00, 0x01, 0x3b, 0x00, 0x00,\n\t\t0x20, 0xc7, 0x17\n\t};\n\tu8 resp_data[11];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tbl_gen5_bl_exit, sizeof(bl_gen5_bl_exit),\n\t\t\tresp_data, &resp_len,\n\t\t\t5000, cyapa_sort_pip_bl_exit_data, false);\n\tif (error)\n\t\treturn error;\n\n\tif (resp_len == PIP_BL_FAIL_EXIT_RESP_LEN ||\n\t\t\tresp_data[PIP_RESP_REPORT_ID_OFFSET] ==\n\t\t\t\tPIP_BL_RESP_REPORT_ID)\n\t\treturn -EAGAIN;\n\n\tif (resp_data[0] == 0x00 && resp_data[1] == 0x00)\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\nint cyapa_pip_bl_enter(struct cyapa *cyapa)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2F, 0x00, 0x01 };\n\tu8 resp_data[2];\n\tint resp_len;\n\tint error;\n\n\terror = cyapa_poll_state(cyapa, 500);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tif (cyapa_is_pip_bl_mode(cyapa))\n\t\treturn 0;\n\telse if (!cyapa_is_pip_app_mode(cyapa))\n\t\treturn -EINVAL;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\t \n\tresp_len = sizeof(resp_data);\n\tmemset(resp_data, 0, resp_len);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t5000, cyapa_sort_pip_application_launch_data,\n\t\t\ttrue);\n\tif (error || resp_data[0] != 0x00 || resp_data[1] != 0x00)\n\t\treturn error < 0 ? error : -EAGAIN;\n\n\tcyapa->operational = false;\n\tif (cyapa->gen == CYAPA_GEN5)\n\t\tcyapa->state = CYAPA_STATE_GEN5_BL;\n\telse if (cyapa->gen == CYAPA_GEN6)\n\t\tcyapa->state = CYAPA_STATE_GEN6_BL;\n\treturn 0;\n}\n\nstatic int cyapa_pip_fw_head_check(struct cyapa *cyapa,\n\t\tstruct cyapa_tsg_bin_image_head *image_head)\n{\n\tif (image_head->head_size != 0x0C && image_head->head_size != 0x12)\n\t\treturn -EINVAL;\n\n\tswitch (cyapa->gen) {\n\tcase CYAPA_GEN6:\n\t\tif (image_head->family_id != 0x9B ||\n\t\t    image_head->silicon_id_hi != 0x0B)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CYAPA_GEN5:\n\t\t \n\t\tif (cyapa->platform_ver < 2) {\n\t\t\tif (image_head->head_size == 0x0C)\n\t\t\t\tbreak;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (image_head->family_id != 0x91 ||\n\t\t    image_head->silicon_id_hi != 0x02)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint cyapa_pip_check_fw(struct cyapa *cyapa, const struct firmware *fw)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct cyapa_tsg_bin_image_data_record *image_records;\n\tconst struct cyapa_tsg_bin_image_data_record *app_integrity;\n\tconst struct tsg_bl_metadata_row_params *metadata;\n\tint flash_records_count;\n\tu32 fw_app_start, fw_upgrade_start;\n\tu16 fw_app_len, fw_upgrade_len;\n\tu16 app_crc;\n\tu16 app_integrity_crc;\n\tint i;\n\n\t \n\tif (cyapa_pip_fw_head_check(cyapa,\n\t\t(struct cyapa_tsg_bin_image_head *)fw->data)) {\n\t\tdev_err(dev, \"%s: firmware image not match TP device.\\n\",\n\t\t\t     __func__);\n\t\treturn -EINVAL;\n\t}\n\n\timage_records =\n\t\tcyapa_get_image_record_data_num(fw, &flash_records_count);\n\n\t \n\tapp_integrity = &image_records[flash_records_count - 1];\n\n\tif (app_integrity->flash_array_id != 0x00 ||\n\t    get_unaligned_be16(&app_integrity->row_number) != 0x01ff) {\n\t\tdev_err(dev, \"%s: invalid app_integrity data.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmetadata = (const void *)app_integrity->record_data;\n\n\t \n\tapp_integrity_crc = crc_itu_t(0xffff, app_integrity->record_data,\n\t\t\t\t      CYAPA_TSG_APP_INTEGRITY_SIZE);\n\tif (app_integrity_crc != get_unaligned_le16(&metadata->metadata_crc)) {\n\t\tdev_err(dev, \"%s: invalid app_integrity crc.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_app_start = get_unaligned_le32(&metadata->app_start);\n\tfw_app_len = get_unaligned_le16(&metadata->app_len);\n\tfw_upgrade_start = get_unaligned_le32(&metadata->upgrade_start);\n\tfw_upgrade_len = get_unaligned_le16(&metadata->upgrade_len);\n\n\tif (fw_app_start % CYAPA_TSG_FW_ROW_SIZE ||\n\t    fw_app_len % CYAPA_TSG_FW_ROW_SIZE ||\n\t    fw_upgrade_start % CYAPA_TSG_FW_ROW_SIZE ||\n\t    fw_upgrade_len % CYAPA_TSG_FW_ROW_SIZE) {\n\t\tdev_err(dev, \"%s: invalid image alignment.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tapp_crc = 0xffffU;\n\tfor (i = 0; i < fw_app_len / CYAPA_TSG_FW_ROW_SIZE; i++) {\n\t\tconst u8 *data = image_records[i].record_data;\n\n\t\tapp_crc = crc_itu_t(app_crc, data, CYAPA_TSG_FW_ROW_SIZE);\n\t}\n\n\tif (app_crc != get_unaligned_le16(&metadata->app_crc)) {\n\t\tdev_err(dev, \"%s: invalid firmware app crc check.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_pip_write_fw_block(struct cyapa *cyapa,\n\t\tstruct cyapa_tsg_bin_image_data_record *flash_record)\n{\n\tstruct pip_bl_cmd_head *bl_cmd_head;\n\tstruct pip_bl_packet_start *bl_packet_start;\n\tstruct tsg_bl_flash_row_head *flash_row_head;\n\tstruct pip_bl_packet_end *bl_packet_end;\n\tu8 cmd[CYAPA_TSG_MAX_CMD_SIZE];\n\tu16 cmd_len;\n\tu8 flash_array_id;\n\tu16 flash_row_id;\n\tu16 record_len;\n\tu8 *record_data;\n\tu16 data_len;\n\tu16 crc;\n\tu8 resp_data[11];\n\tint resp_len;\n\tint error;\n\n\tflash_array_id = flash_record->flash_array_id;\n\tflash_row_id = get_unaligned_be16(&flash_record->row_number);\n\trecord_len = get_unaligned_be16(&flash_record->record_len);\n\trecord_data = flash_record->record_data;\n\n\tmemset(cmd, 0, CYAPA_TSG_MAX_CMD_SIZE);\n\tbl_cmd_head = (struct pip_bl_cmd_head *)cmd;\n\tbl_packet_start = &bl_cmd_head->packet_start;\n\tcmd_len = sizeof(struct pip_bl_cmd_head) +\n\t\t  sizeof(struct tsg_bl_flash_row_head) +\n\t\t  CYAPA_TSG_FLASH_MAP_BLOCK_SIZE +\n\t\t  sizeof(struct pip_bl_packet_end);\n\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &bl_cmd_head->addr);\n\t \n\tput_unaligned_le16(cmd_len - 2, &bl_cmd_head->length);\n\tbl_cmd_head->report_id = PIP_BL_CMD_REPORT_ID;\n\tbl_packet_start->sop = PIP_SOP_KEY;\n\tbl_packet_start->cmd_code = PIP_BL_CMD_PROGRAM_VERIFY_ROW;\n\n\t \n\tdata_len = sizeof(struct tsg_bl_flash_row_head) + record_len;\n\tput_unaligned_le16(data_len, &bl_packet_start->data_length);\n\n\tflash_row_head = (struct tsg_bl_flash_row_head *)bl_cmd_head->data;\n\tflash_row_head->flash_array_id = flash_array_id;\n\tput_unaligned_le16(flash_row_id, &flash_row_head->flash_row_id);\n\tmemcpy(flash_row_head->flash_data, record_data, record_len);\n\n\tbl_packet_end = (struct pip_bl_packet_end *)(bl_cmd_head->data +\n\t\t\t\t\t\t      data_len);\n\tcrc = crc_itu_t(0xffff, (u8 *)bl_packet_start,\n\t\tsizeof(struct pip_bl_packet_start) + data_len);\n\tput_unaligned_le16(crc, &bl_packet_end->crc);\n\tbl_packet_end->eop = PIP_EOP_KEY;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, cmd_len,\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_bl_resp_data, true);\n\tif (error || resp_len != PIP_BL_BLOCK_WRITE_RESP_LEN ||\n\t\t\tresp_data[2] != PIP_BL_RESP_REPORT_ID ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error < 0 ? error : -EAGAIN;\n\n\treturn 0;\n}\n\nint cyapa_pip_do_fw_update(struct cyapa *cyapa,\n\t\tconst struct firmware *fw)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct cyapa_tsg_bin_image_data_record *image_records;\n\tint flash_records_count;\n\tint i;\n\tint error;\n\n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\timage_records =\n\t\tcyapa_get_image_record_data_num(fw, &flash_records_count);\n\n\t \n\tfor (i = 0; i < (flash_records_count - 1); i++) {\n\t\terror = cyapa_pip_write_fw_block(cyapa, &image_records[i]);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"%s: Gen5 FW update aborted: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_change_power_state(struct cyapa *cyapa, u8 power_state)\n{\n\tu8 cmd[8] = { 0x04, 0x00, 0x06, 0x00, 0x2f, 0x00, 0x08, 0x01 };\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\tcmd[7] = power_state;\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, 0x08) ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error < 0 ? error : -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_set_interval_time(struct cyapa *cyapa,\n\t\tu8 parameter_id, u16 interval_time)\n{\n\tstruct pip_app_cmd_head *app_cmd_head;\n\tstruct gen5_app_set_parameter_data *parameter_data;\n\tu8 cmd[CYAPA_TSG_MAX_CMD_SIZE];\n\tint cmd_len;\n\tu8 resp_data[7];\n\tint resp_len;\n\tu8 parameter_size;\n\tint error;\n\n\tmemset(cmd, 0, CYAPA_TSG_MAX_CMD_SIZE);\n\tapp_cmd_head = (struct pip_app_cmd_head *)cmd;\n\tparameter_data = (struct gen5_app_set_parameter_data *)\n\t\t\t app_cmd_head->parameter_data;\n\tcmd_len = sizeof(struct pip_app_cmd_head) +\n\t\t  sizeof(struct gen5_app_set_parameter_data);\n\n\tswitch (parameter_id) {\n\tcase GEN5_PARAMETER_ACT_INTERVL_ID:\n\t\tparameter_size = GEN5_PARAMETER_ACT_INTERVL_SIZE;\n\t\tbreak;\n\tcase GEN5_PARAMETER_ACT_LFT_INTERVL_ID:\n\t\tparameter_size = GEN5_PARAMETER_ACT_LFT_INTERVL_SIZE;\n\t\tbreak;\n\tcase GEN5_PARAMETER_LP_INTRVL_ID:\n\t\tparameter_size = GEN5_PARAMETER_LP_INTRVL_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &app_cmd_head->addr);\n\t \n\tput_unaligned_le16(cmd_len - (4 - parameter_size) - 2,\n\t\t\t   &app_cmd_head->length);\n\tapp_cmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tapp_cmd_head->cmd_code = GEN5_CMD_SET_PARAMETER;\n\tparameter_data->parameter_id = parameter_id;\n\tparameter_data->parameter_size = parameter_size;\n\tput_unaligned_le32((u32)interval_time, &parameter_data->value);\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, cmd_len,\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || resp_data[5] != parameter_id ||\n\t\tresp_data[6] != parameter_size ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, GEN5_CMD_SET_PARAMETER))\n\t\treturn error < 0 ? error : -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_get_interval_time(struct cyapa *cyapa,\n\t\tu8 parameter_id, u16 *interval_time)\n{\n\tstruct pip_app_cmd_head *app_cmd_head;\n\tstruct gen5_app_get_parameter_data *parameter_data;\n\tu8 cmd[CYAPA_TSG_MAX_CMD_SIZE];\n\tint cmd_len;\n\tu8 resp_data[11];\n\tint resp_len;\n\tu8 parameter_size;\n\tu16 mask, i;\n\tint error;\n\n\tmemset(cmd, 0, CYAPA_TSG_MAX_CMD_SIZE);\n\tapp_cmd_head = (struct pip_app_cmd_head *)cmd;\n\tparameter_data = (struct gen5_app_get_parameter_data *)\n\t\t\t app_cmd_head->parameter_data;\n\tcmd_len = sizeof(struct pip_app_cmd_head) +\n\t\t  sizeof(struct gen5_app_get_parameter_data);\n\n\t*interval_time = 0;\n\tswitch (parameter_id) {\n\tcase GEN5_PARAMETER_ACT_INTERVL_ID:\n\t\tparameter_size = GEN5_PARAMETER_ACT_INTERVL_SIZE;\n\t\tbreak;\n\tcase GEN5_PARAMETER_ACT_LFT_INTERVL_ID:\n\t\tparameter_size = GEN5_PARAMETER_ACT_LFT_INTERVL_SIZE;\n\t\tbreak;\n\tcase GEN5_PARAMETER_LP_INTRVL_ID:\n\t\tparameter_size = GEN5_PARAMETER_LP_INTRVL_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &app_cmd_head->addr);\n\t \n\tput_unaligned_le16(cmd_len - 2, &app_cmd_head->length);\n\tapp_cmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tapp_cmd_head->cmd_code = GEN5_CMD_GET_PARAMETER;\n\tparameter_data->parameter_id = parameter_id;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, cmd_len,\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || resp_data[5] != parameter_id || resp_data[6] == 0 ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, GEN5_CMD_GET_PARAMETER))\n\t\treturn error < 0 ? error : -EINVAL;\n\n\tmask = 0;\n\tfor (i = 0; i < parameter_size; i++)\n\t\tmask |= (0xff << (i * 8));\n\t*interval_time = get_unaligned_le16(&resp_data[7]) & mask;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_disable_pip_report(struct cyapa *cyapa)\n{\n\tstruct pip_app_cmd_head *app_cmd_head;\n\tu8 cmd[10];\n\tu8 resp_data[7];\n\tint resp_len;\n\tint error;\n\n\tmemset(cmd, 0, sizeof(cmd));\n\tapp_cmd_head = (struct pip_app_cmd_head *)cmd;\n\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &app_cmd_head->addr);\n\tput_unaligned_le16(sizeof(cmd) - 2, &app_cmd_head->length);\n\tapp_cmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tapp_cmd_head->cmd_code = GEN5_CMD_SET_PARAMETER;\n\tapp_cmd_head->parameter_data[0] = GEN5_PARAMETER_DISABLE_PIP_REPORT;\n\tapp_cmd_head->parameter_data[1] = 0x01;\n\tapp_cmd_head->parameter_data[2] = 0x01;\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || resp_data[5] != GEN5_PARAMETER_DISABLE_PIP_REPORT ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, GEN5_CMD_SET_PARAMETER) ||\n\t\tresp_data[6] != 0x01)\n\t\treturn error < 0 ? error : -EINVAL;\n\n\treturn 0;\n}\n\nint cyapa_pip_set_proximity(struct cyapa *cyapa, bool enable)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x06, 0x00, 0x2f, 0x00, PIP_SET_PROXIMITY,\n\t\t     (u8)!!enable\n\t};\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, PIP_SET_PROXIMITY) ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data)) {\n\t\terror = (error == -ETIMEDOUT) ? -EOPNOTSUPP : error;\n\t\treturn error < 0 ? error : -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint cyapa_pip_deep_sleep(struct cyapa *cyapa, u8 state)\n{\n\tu8 cmd[] = { 0x05, 0x00, 0x00, 0x08};\n\tu8 resp_data[5];\n\tint resp_len;\n\tint error;\n\n\tcmd[2] = state & PIP_DEEP_SLEEP_STATE_MASK;\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_pip_deep_sleep_data, false);\n\tif (error || ((resp_data[3] & PIP_DEEP_SLEEP_STATE_MASK) != state))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_set_power_mode(struct cyapa *cyapa,\n\t\tu8 power_mode, u16 sleep_time, enum cyapa_pm_stage pm_stage)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tu8 power_state;\n\tint error = 0;\n\n\tif (cyapa->state != CYAPA_STATE_GEN5_APP)\n\t\treturn 0;\n\n\tcyapa_set_pip_pm_state(cyapa, pm_stage);\n\n\tif (PIP_DEV_GET_PWR_STATE(cyapa) == UNINIT_PWR_MODE) {\n\t\t \n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_OFF);\n\t}\n\n\tif (PIP_DEV_UNINIT_SLEEP_TIME(cyapa) &&\n\t\t\tPIP_DEV_GET_PWR_STATE(cyapa) != PWR_MODE_OFF)\n\t\tif (cyapa_gen5_get_interval_time(cyapa,\n\t\t\t\tGEN5_PARAMETER_LP_INTRVL_ID,\n\t\t\t\t&cyapa->dev_sleep_time) != 0)\n\t\t\tPIP_DEV_SET_SLEEP_TIME(cyapa, UNINIT_SLEEP_TIME);\n\n\tif (PIP_DEV_GET_PWR_STATE(cyapa) == power_mode) {\n\t\tif (power_mode == PWR_MODE_OFF ||\n\t\t\tpower_mode == PWR_MODE_FULL_ACTIVE ||\n\t\t\tpower_mode == PWR_MODE_BTN_ONLY ||\n\t\t\tPIP_DEV_GET_SLEEP_TIME(cyapa) == sleep_time) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (power_mode == PWR_MODE_OFF) {\n\t\terror = cyapa_pip_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_OFF);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"enter deep sleep fail: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_OFF);\n\t\tgoto out;\n\t}\n\n\t \n\tif (PIP_DEV_GET_PWR_STATE(cyapa) == PWR_MODE_OFF) {\n\t\terror = cyapa_pip_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_ON);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"deep sleep wake fail: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (power_mode == PWR_MODE_FULL_ACTIVE) {\n\t\terror = cyapa_gen5_change_power_state(cyapa,\n\t\t\t\tGEN5_POWER_STATE_ACTIVE);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"change to active fail: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_FULL_ACTIVE);\n\t} else if (power_mode == PWR_MODE_BTN_ONLY) {\n\t\terror = cyapa_gen5_change_power_state(cyapa,\n\t\t\t\tGEN5_POWER_STATE_BTN_ONLY);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"fail to button only mode: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_BTN_ONLY);\n\t} else {\n\t\t \n\t\tif (PIP_DEV_UNINIT_SLEEP_TIME(cyapa) ||\n\t\t\t\tsleep_time != PIP_DEV_GET_SLEEP_TIME(cyapa))\n\t\t\tif (cyapa_gen5_set_interval_time(cyapa,\n\t\t\t\t\tGEN5_PARAMETER_LP_INTRVL_ID,\n\t\t\t\t\tsleep_time) == 0)\n\t\t\t\tPIP_DEV_SET_SLEEP_TIME(cyapa, sleep_time);\n\n\t\tif (sleep_time <= GEN5_POWER_READY_MAX_INTRVL_TIME)\n\t\t\tpower_state = GEN5_POWER_STATE_READY;\n\t\telse\n\t\t\tpower_state = GEN5_POWER_STATE_IDLE;\n\t\terror = cyapa_gen5_change_power_state(cyapa, power_state);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"set power state to 0x%02x failed: %d\\n\",\n\t\t\t\tpower_state, error);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (pm_stage == CYAPA_PM_SUSPEND)\n\t\t\tcyapa_gen5_disable_pip_report(cyapa);\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa,\n\t\t\tcyapa_sleep_time_to_pwr_cmd(sleep_time));\n\t}\n\nout:\n\tcyapa_reset_pip_pm_state(cyapa);\n\treturn error;\n}\n\nint cyapa_pip_resume_scanning(struct cyapa *cyapa)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x04 };\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, true);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, 0x04))\n\t\treturn -EINVAL;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\treturn 0;\n}\n\nint cyapa_pip_suspend_scanning(struct cyapa *cyapa)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x03 };\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, true);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, 0x03))\n\t\treturn -EINVAL;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic int cyapa_pip_calibrate_pwcs(struct cyapa *cyapa,\n\t\tu8 calibrate_sensing_mode_type)\n{\n\tstruct pip_app_cmd_head *app_cmd_head;\n\tu8 cmd[8];\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\tmemset(cmd, 0, sizeof(cmd));\n\tapp_cmd_head = (struct pip_app_cmd_head *)cmd;\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &app_cmd_head->addr);\n\tput_unaligned_le16(sizeof(cmd) - 2, &app_cmd_head->length);\n\tapp_cmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tapp_cmd_head->cmd_code = PIP_CMD_CALIBRATE;\n\tapp_cmd_head->parameter_data[0] = calibrate_sensing_mode_type;\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t5000, cyapa_sort_tsg_pip_app_resp_data, true);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, PIP_CMD_CALIBRATE) ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error < 0 ? error : -EAGAIN;\n\n\treturn 0;\n}\n\nssize_t cyapa_pip_do_calibrate(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint error, calibrate_error;\n\n\t \n\terror = cyapa_pip_suspend_scanning(cyapa);\n\tif (error)\n\t\treturn error;\n\n\t \n\tcalibrate_error = cyapa_pip_calibrate_pwcs(cyapa,\n\t\t\t\tPIP_SENSING_MODE_MUTUAL_CAP_FINE);\n\tif (calibrate_error)\n\t\tgoto resume_scanning;\n\n\t \n\tcalibrate_error = cyapa_pip_calibrate_pwcs(cyapa,\n\t\t\t\tPIP_SENSING_MODE_SELF_CAP);\n\tif (calibrate_error)\n\t\tgoto resume_scanning;\n\nresume_scanning:\n\t \n\terror = cyapa_pip_resume_scanning(cyapa);\n\tif (error || calibrate_error)\n\t\treturn error ? error : calibrate_error;\n\n\treturn count;\n}\n\nstatic s32 twos_complement_to_s32(s32 value, int num_bits)\n{\n\tif (value >> (num_bits - 1))\n\t\tvalue |=  -1 << num_bits;\n\treturn value;\n}\n\nstatic s32 cyapa_parse_structure_data(u8 data_format, u8 *buf, int buf_len)\n{\n\tint data_size;\n\tbool big_endian;\n\tbool unsigned_type;\n\ts32 value;\n\n\tdata_size = (data_format & 0x07);\n\tbig_endian = ((data_format & 0x10) == 0x00);\n\tunsigned_type = ((data_format & 0x20) == 0x00);\n\n\tif (buf_len < data_size)\n\t\treturn 0;\n\n\tswitch (data_size) {\n\tcase 1:\n\t\tvalue  = buf[0];\n\t\tbreak;\n\tcase 2:\n\t\tif (big_endian)\n\t\t\tvalue = get_unaligned_be16(buf);\n\t\telse\n\t\t\tvalue = get_unaligned_le16(buf);\n\t\tbreak;\n\tcase 4:\n\t\tif (big_endian)\n\t\t\tvalue = get_unaligned_be32(buf);\n\t\telse\n\t\t\tvalue = get_unaligned_le32(buf);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tvalue = 0;\n\t\tbreak;\n\t}\n\n\tif (!unsigned_type)\n\t\tvalue = twos_complement_to_s32(value, data_size * 8);\n\n\treturn value;\n}\n\nstatic void cyapa_gen5_guess_electrodes(struct cyapa *cyapa,\n\t\tint *electrodes_rx, int *electrodes_tx)\n{\n\tif (cyapa->electrodes_rx != 0) {\n\t\t*electrodes_rx = cyapa->electrodes_rx;\n\t\t*electrodes_tx = (cyapa->electrodes_x == *electrodes_rx) ?\n\t\t\t\tcyapa->electrodes_y : cyapa->electrodes_x;\n\t} else {\n\t\t*electrodes_tx = min(cyapa->electrodes_x, cyapa->electrodes_y);\n\t\t*electrodes_rx = max(cyapa->electrodes_x, cyapa->electrodes_y);\n\t}\n}\n\n \nstatic int cyapa_gen5_read_idac_data(struct cyapa *cyapa,\n\t\tu8 cmd_code, u8 idac_data_type, int *data_size,\n\t\tint *idac_max, int *idac_min, int *idac_ave)\n{\n\tstruct pip_app_cmd_head *cmd_head;\n\tu8 cmd[12];\n\tu8 resp_data[256];\n\tint resp_len;\n\tint read_len;\n\tint value;\n\tu16 offset;\n\tint read_elements;\n\tbool read_global_idac;\n\tint sum, count, max_element_cnt;\n\tint tmp_max, tmp_min, tmp_ave, tmp_sum, tmp_count;\n\tint electrodes_rx, electrodes_tx;\n\tint i;\n\tint error;\n\n\tif (cmd_code != PIP_RETRIEVE_DATA_STRUCTURE ||\n\t\t(idac_data_type != GEN5_RETRIEVE_MUTUAL_PWC_DATA &&\n\t\tidac_data_type != GEN5_RETRIEVE_SELF_CAP_PWC_DATA) ||\n\t\t!data_size || !idac_max || !idac_min || !idac_ave)\n\t\treturn -EINVAL;\n\n\t*idac_max = INT_MIN;\n\t*idac_min = INT_MAX;\n\tsum = count = tmp_count = 0;\n\telectrodes_rx = electrodes_tx = 0;\n\tif (*data_size == 0) {\n\t\t \n\t\tread_global_idac = true;\n\t\toffset = 0;\n\t\t*data_size = 4;\n\t\ttmp_max = INT_MIN;\n\t\ttmp_min = INT_MAX;\n\t\ttmp_ave = tmp_sum = tmp_count = 0;\n\n\t\tif (idac_data_type == GEN5_RETRIEVE_MUTUAL_PWC_DATA) {\n\t\t\tif (cyapa->aligned_electrodes_rx == 0) {\n\t\t\t\tcyapa_gen5_guess_electrodes(cyapa,\n\t\t\t\t\t&electrodes_rx, &electrodes_tx);\n\t\t\t\tcyapa->aligned_electrodes_rx =\n\t\t\t\t\t(electrodes_rx + 3) & ~3u;\n\t\t\t}\n\t\t\tmax_element_cnt =\n\t\t\t\t(cyapa->aligned_electrodes_rx + 7) & ~7u;\n\t\t} else {\n\t\t\tmax_element_cnt = 2;\n\t\t}\n\t} else {\n\t\tread_global_idac = false;\n\t\tif (*data_size > 4)\n\t\t\t*data_size = 4;\n\t\t \n\t\tif (idac_data_type == GEN5_RETRIEVE_MUTUAL_PWC_DATA) {\n\t\t\toffset = cyapa->aligned_electrodes_rx * (*data_size);\n\t\t\tif (cyapa->electrodes_rx == cyapa->electrodes_x)\n\t\t\t\telectrodes_tx = cyapa->electrodes_y;\n\t\t\telse\n\t\t\t\telectrodes_tx = cyapa->electrodes_x;\n\t\t\tmax_element_cnt = ((cyapa->aligned_electrodes_rx + 7) &\n\t\t\t\t\t\t~7u) * electrodes_tx;\n\t\t} else {\n\t\t\toffset = 2;\n\t\t\tmax_element_cnt = cyapa->electrodes_x +\n\t\t\t\t\t\tcyapa->electrodes_y;\n\t\t\tmax_element_cnt = (max_element_cnt + 3) & ~3u;\n\t\t}\n\t}\n\n\tmemset(cmd, 0, sizeof(cmd));\n\tcmd_head = (struct pip_app_cmd_head *)cmd;\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &cmd_head->addr);\n\tput_unaligned_le16(sizeof(cmd) - 2, &cmd_head->length);\n\tcmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tcmd_head->cmd_code = cmd_code;\n\tdo {\n\t\tread_elements = (256 - GEN5_RESP_DATA_STRUCTURE_OFFSET) /\n\t\t\t\t(*data_size);\n\t\tread_elements = min(read_elements, max_element_cnt - count);\n\t\tread_len = read_elements * (*data_size);\n\n\t\tput_unaligned_le16(offset, &cmd_head->parameter_data[0]);\n\t\tput_unaligned_le16(read_len, &cmd_head->parameter_data[2]);\n\t\tcmd_head->parameter_data[4] = idac_data_type;\n\t\tresp_len = GEN5_RESP_DATA_STRUCTURE_OFFSET + read_len;\n\t\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\t\tcmd, sizeof(cmd),\n\t\t\t\tresp_data, &resp_len,\n\t\t\t\t500, cyapa_sort_tsg_pip_app_resp_data,\n\t\t\t\ttrue);\n\t\tif (error || resp_len < GEN5_RESP_DATA_STRUCTURE_OFFSET ||\n\t\t\t\t!VALID_CMD_RESP_HEADER(resp_data, cmd_code) ||\n\t\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data) ||\n\t\t\t\tresp_data[6] != idac_data_type)\n\t\t\treturn (error < 0) ? error : -EAGAIN;\n\t\tread_len = get_unaligned_le16(&resp_data[7]);\n\t\tif (read_len == 0)\n\t\t\tbreak;\n\n\t\t*data_size = (resp_data[9] & GEN5_PWC_DATA_ELEMENT_SIZE_MASK);\n\t\tif (read_len < *data_size)\n\t\t\treturn -EINVAL;\n\n\t\tif (read_global_idac &&\n\t\t\tidac_data_type == GEN5_RETRIEVE_SELF_CAP_PWC_DATA) {\n\t\t\t \n\t\t\t*idac_max = cyapa_parse_structure_data(\n\t\t\t\tresp_data[9],\n\t\t\t\t&resp_data[GEN5_RESP_DATA_STRUCTURE_OFFSET],\n\t\t\t\t*data_size);\n\t\t\t \n\t\t\t*idac_min = cyapa_parse_structure_data(\n\t\t\t\tresp_data[9],\n\t\t\t\t&resp_data[GEN5_RESP_DATA_STRUCTURE_OFFSET +\n\t\t\t\t\t   *data_size],\n\t\t\t\t*data_size);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\toffset += read_len;\n\t\tfor (i = 10; i < (read_len + GEN5_RESP_DATA_STRUCTURE_OFFSET);\n\t\t\t\ti += *data_size) {\n\t\t\tvalue = cyapa_parse_structure_data(resp_data[9],\n\t\t\t\t\t&resp_data[i], *data_size);\n\t\t\t*idac_min = min(value, *idac_min);\n\t\t\t*idac_max = max(value, *idac_max);\n\n\t\t\tif (idac_data_type == GEN5_RETRIEVE_MUTUAL_PWC_DATA &&\n\t\t\t\ttmp_count < cyapa->aligned_electrodes_rx &&\n\t\t\t\tread_global_idac) {\n\t\t\t\t \n\t\t\t\tif (!tmp_ave || value > tmp_ave / 2) {\n\t\t\t\t\ttmp_min = min(value, tmp_min);\n\t\t\t\t\ttmp_max = max(value, tmp_max);\n\t\t\t\t\ttmp_sum += value;\n\t\t\t\t\ttmp_count++;\n\n\t\t\t\t\ttmp_ave = tmp_sum / tmp_count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum += value;\n\t\t\tcount++;\n\n\t\t\tif (count >= max_element_cnt)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (true);\n\nout:\n\t*idac_ave = count ? (sum / count) : 0;\n\n\tif (read_global_idac &&\n\t\tidac_data_type == GEN5_RETRIEVE_MUTUAL_PWC_DATA) {\n\t\tif (tmp_count == 0)\n\t\t\treturn 0;\n\n\t\tif (tmp_count == cyapa->aligned_electrodes_rx) {\n\t\t\tcyapa->electrodes_rx = cyapa->electrodes_rx ?\n\t\t\t\tcyapa->electrodes_rx : electrodes_rx;\n\t\t} else if (tmp_count == electrodes_rx) {\n\t\t\tcyapa->electrodes_rx = cyapa->electrodes_rx ?\n\t\t\t\tcyapa->electrodes_rx : electrodes_rx;\n\t\t\tcyapa->aligned_electrodes_rx = electrodes_rx;\n\t\t} else {\n\t\t\tcyapa->electrodes_rx = cyapa->electrodes_rx ?\n\t\t\t\tcyapa->electrodes_rx : electrodes_tx;\n\t\t\tcyapa->aligned_electrodes_rx = tmp_count;\n\t\t}\n\n\t\t*idac_min = tmp_min;\n\t\t*idac_max = tmp_max;\n\t\t*idac_ave = tmp_ave;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_read_mutual_idac_data(struct cyapa *cyapa,\n\tint *gidac_mutual_max, int *gidac_mutual_min, int *gidac_mutual_ave,\n\tint *lidac_mutual_max, int *lidac_mutual_min, int *lidac_mutual_ave)\n{\n\tint data_size;\n\tint error;\n\n\t*gidac_mutual_max = *gidac_mutual_min = *gidac_mutual_ave = 0;\n\t*lidac_mutual_max = *lidac_mutual_min = *lidac_mutual_ave = 0;\n\n\tdata_size = 0;\n\terror = cyapa_gen5_read_idac_data(cyapa,\n\t\tPIP_RETRIEVE_DATA_STRUCTURE,\n\t\tGEN5_RETRIEVE_MUTUAL_PWC_DATA,\n\t\t&data_size,\n\t\tgidac_mutual_max, gidac_mutual_min, gidac_mutual_ave);\n\tif (error)\n\t\treturn error;\n\n\terror = cyapa_gen5_read_idac_data(cyapa,\n\t\tPIP_RETRIEVE_DATA_STRUCTURE,\n\t\tGEN5_RETRIEVE_MUTUAL_PWC_DATA,\n\t\t&data_size,\n\t\tlidac_mutual_max, lidac_mutual_min, lidac_mutual_ave);\n\treturn error;\n}\n\nstatic int cyapa_gen5_read_self_idac_data(struct cyapa *cyapa,\n\t\tint *gidac_self_rx, int *gidac_self_tx,\n\t\tint *lidac_self_max, int *lidac_self_min, int *lidac_self_ave)\n{\n\tint data_size;\n\tint error;\n\n\t*gidac_self_rx = *gidac_self_tx = 0;\n\t*lidac_self_max = *lidac_self_min = *lidac_self_ave = 0;\n\n\tdata_size = 0;\n\terror = cyapa_gen5_read_idac_data(cyapa,\n\t\tPIP_RETRIEVE_DATA_STRUCTURE,\n\t\tGEN5_RETRIEVE_SELF_CAP_PWC_DATA,\n\t\t&data_size,\n\t\tlidac_self_max, lidac_self_min, lidac_self_ave);\n\tif (error)\n\t\treturn error;\n\t*gidac_self_rx = *lidac_self_max;\n\t*gidac_self_tx = *lidac_self_min;\n\n\terror = cyapa_gen5_read_idac_data(cyapa,\n\t\tPIP_RETRIEVE_DATA_STRUCTURE,\n\t\tGEN5_RETRIEVE_SELF_CAP_PWC_DATA,\n\t\t&data_size,\n\t\tlidac_self_max, lidac_self_min, lidac_self_ave);\n\treturn error;\n}\n\nstatic ssize_t cyapa_gen5_execute_panel_scan(struct cyapa *cyapa)\n{\n\tstruct pip_app_cmd_head *app_cmd_head;\n\tu8 cmd[7];\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\tmemset(cmd, 0, sizeof(cmd));\n\tapp_cmd_head = (struct pip_app_cmd_head *)cmd;\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &app_cmd_head->addr);\n\tput_unaligned_le16(sizeof(cmd) - 2, &app_cmd_head->length);\n\tapp_cmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tapp_cmd_head->cmd_code = GEN5_CMD_EXECUTE_PANEL_SCAN;\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, true);\n\tif (error || resp_len != sizeof(resp_data) ||\n\t\t\t!VALID_CMD_RESP_HEADER(resp_data,\n\t\t\t\tGEN5_CMD_EXECUTE_PANEL_SCAN) ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error ? error : -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_read_panel_scan_raw_data(struct cyapa *cyapa,\n\t\tu8 cmd_code, u8 raw_data_type, int raw_data_max_num,\n\t\tint *raw_data_max, int *raw_data_min, int *raw_data_ave,\n\t\tu8 *buffer)\n{\n\tstruct pip_app_cmd_head *app_cmd_head;\n\tstruct gen5_retrieve_panel_scan_data *panel_sacn_data;\n\tu8 cmd[12];\n\tu8 resp_data[256];   \n\tint resp_len;\n\tint read_elements;\n\tint read_len;\n\tu16 offset;\n\ts32 value;\n\tint sum, count;\n\tint data_size;\n\ts32 *intp;\n\tint i;\n\tint error;\n\n\tif (cmd_code != GEN5_CMD_RETRIEVE_PANEL_SCAN ||\n\t\t(raw_data_type > GEN5_PANEL_SCAN_SELF_DIFFCOUNT) ||\n\t\t!raw_data_max || !raw_data_min || !raw_data_ave)\n\t\treturn -EINVAL;\n\n\tintp = (s32 *)buffer;\n\t*raw_data_max = INT_MIN;\n\t*raw_data_min = INT_MAX;\n\tsum = count = 0;\n\toffset = 0;\n\t \n\tread_elements = (256 - GEN5_RESP_DATA_STRUCTURE_OFFSET) / 4;\n\tread_len = read_elements * 4;\n\tapp_cmd_head = (struct pip_app_cmd_head *)cmd;\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &app_cmd_head->addr);\n\tput_unaligned_le16(sizeof(cmd) - 2, &app_cmd_head->length);\n\tapp_cmd_head->report_id = PIP_APP_CMD_REPORT_ID;\n\tapp_cmd_head->cmd_code = cmd_code;\n\tpanel_sacn_data = (struct gen5_retrieve_panel_scan_data *)\n\t\t\tapp_cmd_head->parameter_data;\n\tdo {\n\t\tput_unaligned_le16(offset, &panel_sacn_data->read_offset);\n\t\tput_unaligned_le16(read_elements,\n\t\t\t&panel_sacn_data->read_elements);\n\t\tpanel_sacn_data->data_id = raw_data_type;\n\n\t\tresp_len = GEN5_RESP_DATA_STRUCTURE_OFFSET + read_len;\n\t\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, true);\n\t\tif (error || resp_len < GEN5_RESP_DATA_STRUCTURE_OFFSET ||\n\t\t\t\t!VALID_CMD_RESP_HEADER(resp_data, cmd_code) ||\n\t\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data) ||\n\t\t\t\tresp_data[6] != raw_data_type)\n\t\t\treturn error ? error : -EAGAIN;\n\n\t\tread_elements = get_unaligned_le16(&resp_data[7]);\n\t\tif (read_elements == 0)\n\t\t\tbreak;\n\n\t\tdata_size = (resp_data[9] & GEN5_PWC_DATA_ELEMENT_SIZE_MASK);\n\t\toffset += read_elements;\n\t\tif (read_elements) {\n\t\t\tfor (i = GEN5_RESP_DATA_STRUCTURE_OFFSET;\n\t\t\t     i < (read_elements * data_size +\n\t\t\t\t\tGEN5_RESP_DATA_STRUCTURE_OFFSET);\n\t\t\t     i += data_size) {\n\t\t\t\tvalue = cyapa_parse_structure_data(resp_data[9],\n\t\t\t\t\t\t&resp_data[i], data_size);\n\t\t\t\t*raw_data_min = min(value, *raw_data_min);\n\t\t\t\t*raw_data_max = max(value, *raw_data_max);\n\n\t\t\t\tif (intp)\n\t\t\t\t\tput_unaligned_le32(value, &intp[count]);\n\n\t\t\t\tsum += value;\n\t\t\t\tcount++;\n\n\t\t\t}\n\t\t}\n\n\t\tif (count >= raw_data_max_num)\n\t\t\tbreak;\n\n\t\tread_elements = (sizeof(resp_data) -\n\t\t\t\tGEN5_RESP_DATA_STRUCTURE_OFFSET) / data_size;\n\t\tread_len = read_elements * data_size;\n\t} while (true);\n\n\t*raw_data_ave = count ? (sum / count) : 0;\n\n\treturn 0;\n}\n\nstatic ssize_t cyapa_gen5_show_baseline(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint gidac_mutual_max, gidac_mutual_min, gidac_mutual_ave;\n\tint lidac_mutual_max, lidac_mutual_min, lidac_mutual_ave;\n\tint gidac_self_rx, gidac_self_tx;\n\tint lidac_self_max, lidac_self_min, lidac_self_ave;\n\tint raw_cap_mutual_max, raw_cap_mutual_min, raw_cap_mutual_ave;\n\tint raw_cap_self_max, raw_cap_self_min, raw_cap_self_ave;\n\tint mutual_diffdata_max, mutual_diffdata_min, mutual_diffdata_ave;\n\tint self_diffdata_max, self_diffdata_min, self_diffdata_ave;\n\tint mutual_baseline_max, mutual_baseline_min, mutual_baseline_ave;\n\tint self_baseline_max, self_baseline_min, self_baseline_ave;\n\tint error, resume_error;\n\tint size;\n\n\tif (!cyapa_is_pip_app_mode(cyapa))\n\t\treturn -EBUSY;\n\n\t \n\terror = cyapa_pip_suspend_scanning(cyapa);\n\tif (error)\n\t\treturn error;\n\n\t \n\tgidac_self_rx = gidac_self_tx = 0;\n\terror = cyapa_gen5_read_mutual_idac_data(cyapa,\n\t\t\t\t&gidac_mutual_max, &gidac_mutual_min,\n\t\t\t\t&gidac_mutual_ave, &lidac_mutual_max,\n\t\t\t\t&lidac_mutual_min, &lidac_mutual_ave);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_self_idac_data(cyapa,\n\t\t\t\t&gidac_self_rx, &gidac_self_tx,\n\t\t\t\t&lidac_self_max, &lidac_self_min,\n\t\t\t\t&lidac_self_ave);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_execute_panel_scan(cyapa);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_panel_scan_raw_data(cyapa,\n\t\t\t\tGEN5_CMD_RETRIEVE_PANEL_SCAN,\n\t\t\t\tGEN5_PANEL_SCAN_MUTUAL_RAW_DATA,\n\t\t\t\tcyapa->electrodes_x * cyapa->electrodes_y,\n\t\t\t\t&raw_cap_mutual_max, &raw_cap_mutual_min,\n\t\t\t\t&raw_cap_mutual_ave,\n\t\t\t\tNULL);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_panel_scan_raw_data(cyapa,\n\t\t\t\tGEN5_CMD_RETRIEVE_PANEL_SCAN,\n\t\t\t\tGEN5_PANEL_SCAN_SELF_RAW_DATA,\n\t\t\t\tcyapa->electrodes_x + cyapa->electrodes_y,\n\t\t\t\t&raw_cap_self_max, &raw_cap_self_min,\n\t\t\t\t&raw_cap_self_ave,\n\t\t\t\tNULL);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_panel_scan_raw_data(cyapa,\n\t\t\t\tGEN5_CMD_RETRIEVE_PANEL_SCAN,\n\t\t\t\tGEN5_PANEL_SCAN_MUTUAL_DIFFCOUNT,\n\t\t\t\tcyapa->electrodes_x * cyapa->electrodes_y,\n\t\t\t\t&mutual_diffdata_max, &mutual_diffdata_min,\n\t\t\t\t&mutual_diffdata_ave,\n\t\t\t\tNULL);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_panel_scan_raw_data(cyapa,\n\t\t\t\tGEN5_CMD_RETRIEVE_PANEL_SCAN,\n\t\t\t\tGEN5_PANEL_SCAN_SELF_DIFFCOUNT,\n\t\t\t\tcyapa->electrodes_x + cyapa->electrodes_y,\n\t\t\t\t&self_diffdata_max, &self_diffdata_min,\n\t\t\t\t&self_diffdata_ave,\n\t\t\t\tNULL);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_panel_scan_raw_data(cyapa,\n\t\t\t\tGEN5_CMD_RETRIEVE_PANEL_SCAN,\n\t\t\t\tGEN5_PANEL_SCAN_MUTUAL_BASELINE,\n\t\t\t\tcyapa->electrodes_x * cyapa->electrodes_y,\n\t\t\t\t&mutual_baseline_max, &mutual_baseline_min,\n\t\t\t\t&mutual_baseline_ave,\n\t\t\t\tNULL);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\terror = cyapa_gen5_read_panel_scan_raw_data(cyapa,\n\t\t\t\tGEN5_CMD_RETRIEVE_PANEL_SCAN,\n\t\t\t\tGEN5_PANEL_SCAN_SELF_BASELINE,\n\t\t\t\tcyapa->electrodes_x + cyapa->electrodes_y,\n\t\t\t\t&self_baseline_max, &self_baseline_min,\n\t\t\t\t&self_baseline_ave,\n\t\t\t\tNULL);\n\tif (error)\n\t\tgoto resume_scanning;\n\nresume_scanning:\n\t \n\tresume_error = cyapa_pip_resume_scanning(cyapa);\n\tif (resume_error || error)\n\t\treturn resume_error ? resume_error : error;\n\n\t \n\tsize = scnprintf(buf, PAGE_SIZE, \"%d %d %d %d %d %d %d %d %d %d %d \",\n\t\tgidac_mutual_min, gidac_mutual_max, gidac_mutual_ave,\n\t\tlidac_mutual_min, lidac_mutual_max, lidac_mutual_ave,\n\t\tgidac_self_rx, gidac_self_tx,\n\t\tlidac_self_min, lidac_self_max, lidac_self_ave);\n\tsize += scnprintf(buf + size, PAGE_SIZE - size,\n\t\t\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\\n\",\n\t\traw_cap_mutual_min, raw_cap_mutual_max, raw_cap_mutual_ave,\n\t\traw_cap_self_min, raw_cap_self_max, raw_cap_self_ave,\n\t\tmutual_diffdata_min, mutual_diffdata_max, mutual_diffdata_ave,\n\t\tself_diffdata_min, self_diffdata_max, self_diffdata_ave,\n\t\tmutual_baseline_min, mutual_baseline_max, mutual_baseline_ave,\n\t\tself_baseline_min, self_baseline_max, self_baseline_ave);\n\treturn size;\n}\n\nbool cyapa_pip_sort_system_info_data(struct cyapa *cyapa,\n\t\tu8 *buf, int len)\n{\n\t \n\tif (VALID_CMD_RESP_HEADER(buf, 0x02))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int cyapa_gen5_bl_query_data(struct cyapa *cyapa)\n{\n\tu8 resp_data[PIP_BL_APP_INFO_RESP_LENGTH];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_bl_read_app_info, PIP_BL_READ_APP_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_bl_resp_data, false);\n\tif (error || resp_len < PIP_BL_APP_INFO_RESP_LENGTH ||\n\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error ? error : -EIO;\n\n\tmemcpy(&cyapa->product_id[0], &resp_data[8], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &resp_data[13], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &resp_data[19], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\tcyapa->fw_maj_ver = resp_data[22];\n\tcyapa->fw_min_ver = resp_data[23];\n\n\tcyapa->platform_ver = (resp_data[26] >> PIP_BL_PLATFORM_VER_SHIFT) &\n\t\t\t      PIP_BL_PLATFORM_VER_MASK;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_get_query_data(struct cyapa *cyapa)\n{\n\tu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\n\tint resp_len;\n\tu16 product_family;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t2000, cyapa_pip_sort_system_info_data, false);\n\tif (error || resp_len < sizeof(resp_data))\n\t\treturn error ? error : -EIO;\n\n\tproduct_family = get_unaligned_le16(&resp_data[7]);\n\tif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\n\t\tPIP_PRODUCT_FAMILY_TRACKPAD)\n\t\treturn -EINVAL;\n\n\tcyapa->platform_ver = (resp_data[49] >> PIP_BL_PLATFORM_VER_SHIFT) &\n\t\t\t      PIP_BL_PLATFORM_VER_MASK;\n\tif (cyapa->gen == CYAPA_GEN5 && cyapa->platform_ver < 2) {\n\t\t \n\t\tcyapa->fw_maj_ver = resp_data[15];\n\t\tcyapa->fw_min_ver = resp_data[16];\n\t} else {\n\t\tcyapa->fw_maj_ver = resp_data[9];\n\t\tcyapa->fw_min_ver = resp_data[10];\n\t}\n\n\tcyapa->electrodes_x = resp_data[52];\n\tcyapa->electrodes_y = resp_data[53];\n\n\tcyapa->physical_size_x =  get_unaligned_le16(&resp_data[54]) / 100;\n\tcyapa->physical_size_y = get_unaligned_le16(&resp_data[56]) / 100;\n\n\tcyapa->max_abs_x = get_unaligned_le16(&resp_data[58]);\n\tcyapa->max_abs_y = get_unaligned_le16(&resp_data[60]);\n\n\tcyapa->max_z = get_unaligned_le16(&resp_data[62]);\n\n\tcyapa->x_origin = resp_data[64] & 0x01;\n\tcyapa->y_origin = resp_data[65] & 0x01;\n\n\tcyapa->btn_capability = (resp_data[70] << 3) & CAPABILITY_BTN_MASK;\n\n\tmemcpy(&cyapa->product_id[0], &resp_data[33], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &resp_data[38], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &resp_data[44], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\tif (!cyapa->electrodes_x || !cyapa->electrodes_y ||\n\t\t!cyapa->physical_size_x || !cyapa->physical_size_y ||\n\t\t!cyapa->max_abs_x || !cyapa->max_abs_y || !cyapa->max_z)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen5_do_operational_check(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\tif (cyapa->gen != CYAPA_GEN5)\n\t\treturn -ENODEV;\n\n\tswitch (cyapa->state) {\n\tcase CYAPA_STATE_GEN5_BL:\n\t\terror = cyapa_pip_bl_exit(cyapa);\n\t\tif (error) {\n\t\t\t \n\t\t\tcyapa_gen5_bl_query_data(cyapa);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcyapa->state = CYAPA_STATE_GEN5_APP;\n\t\tfallthrough;\n\n\tcase CYAPA_STATE_GEN5_APP:\n\t\t \n\t\terror = cyapa_gen5_set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"%s: failed to set power active mode.\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\tif (cyapa->platform_ver >= 2) {\n\t\t\terror = cyapa_pip_set_proximity(cyapa, true);\n\t\t\tif (error)\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\"%s: failed to enable proximity.\\n\",\n\t\t\t\t\t__func__);\n\t\t}\n\n\t\t \n\t\terror = cyapa_gen5_get_query_data(cyapa);\n\t\tif (error)\n\t\t\tgoto out;\n\t\t \n\t\tif (memcmp(cyapa->product_id, product_id,\n\t\t\t\tstrlen(product_id)) != 0) {\n\t\t\tdev_err(dev, \"%s: unknown product ID (%s)\\n\",\n\t\t\t\t__func__, cyapa->product_id);\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\nout:\n\treturn error;\n}\n\n \nbool cyapa_pip_irq_cmd_handler(struct cyapa *cyapa)\n{\n\tstruct cyapa_pip_cmd_states *pip = &cyapa->cmd_states.pip;\n\tint length;\n\n\tif (atomic_read(&pip->cmd_issued)) {\n\t\t \n\t\tif (pip->is_irq_mode == false)\n\t\t\treturn false;\n\n\t\t \n\t\tcyapa_i2c_pip_read(cyapa, pip->irq_cmd_buf,\n\t\t\tPIP_RESP_LENGTH_SIZE);\n\t\tlength = get_unaligned_le16(pip->irq_cmd_buf);\n\t\tlength = (length <= PIP_RESP_LENGTH_SIZE) ?\n\t\t\t\tPIP_RESP_LENGTH_SIZE : length;\n\t\tif (length > PIP_RESP_LENGTH_SIZE)\n\t\t\tcyapa_i2c_pip_read(cyapa,\n\t\t\t\tpip->irq_cmd_buf, length);\n\t\tif (!(pip->resp_sort_func &&\n\t\t\tpip->resp_sort_func(cyapa,\n\t\t\t\tpip->irq_cmd_buf, length))) {\n\t\t\t \n\t\t\tlength = 0;\n\t\t\tif (pip->resp_len)\n\t\t\t\tlength = *pip->resp_len;\n\t\t\tcyapa_empty_pip_output_data(cyapa,\n\t\t\t\t\tpip->resp_data,\n\t\t\t\t\t&length,\n\t\t\t\t\tpip->resp_sort_func);\n\t\t\tif (pip->resp_len && length != 0) {\n\t\t\t\t*pip->resp_len = length;\n\t\t\t\tatomic_dec(&pip->cmd_issued);\n\t\t\t\tcomplete(&pip->cmd_ready);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pip->resp_data && pip->resp_len) {\n\t\t\t*pip->resp_len = (*pip->resp_len < length) ?\n\t\t\t\t*pip->resp_len : length;\n\t\t\tmemcpy(pip->resp_data, pip->irq_cmd_buf,\n\t\t\t\t*pip->resp_len);\n\t\t}\n\t\tatomic_dec(&pip->cmd_issued);\n\t\tcomplete(&pip->cmd_ready);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void cyapa_pip_report_buttons(struct cyapa *cyapa,\n\t\tconst struct cyapa_pip_report_data *report_data)\n{\n\tstruct input_dev *input = cyapa->input;\n\tu8 buttons = report_data->report_head[PIP_BUTTONS_OFFSET];\n\n\tbuttons = (buttons << CAPABILITY_BTN_SHIFT) & CAPABILITY_BTN_MASK;\n\n\tif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK) {\n\t\tinput_report_key(input, BTN_LEFT,\n\t\t\t!!(buttons & CAPABILITY_LEFT_BTN_MASK));\n\t}\n\tif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK) {\n\t\tinput_report_key(input, BTN_MIDDLE,\n\t\t\t!!(buttons & CAPABILITY_MIDDLE_BTN_MASK));\n\t}\n\tif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK) {\n\t\tinput_report_key(input, BTN_RIGHT,\n\t\t\t!!(buttons & CAPABILITY_RIGHT_BTN_MASK));\n\t}\n\n\tinput_sync(input);\n}\n\nstatic void cyapa_pip_report_proximity(struct cyapa *cyapa,\n\t\tconst struct cyapa_pip_report_data *report_data)\n{\n\tstruct input_dev *input = cyapa->input;\n\tu8 distance = report_data->report_head[PIP_PROXIMITY_DISTANCE_OFFSET] &\n\t\t\tPIP_PROXIMITY_DISTANCE_MASK;\n\n\tinput_report_abs(input, ABS_DISTANCE, distance);\n\tinput_sync(input);\n}\n\nstatic void cyapa_pip_report_slot_data(struct cyapa *cyapa,\n\t\tconst struct cyapa_pip_touch_record *touch)\n{\n\tstruct input_dev *input = cyapa->input;\n\tu8 event_id = PIP_GET_EVENT_ID(touch->touch_tip_event_id);\n\tint slot = PIP_GET_TOUCH_ID(touch->touch_tip_event_id);\n\tint x, y;\n\n\tif (event_id == RECORD_EVENT_LIFTOFF)\n\t\treturn;\n\n\tinput_mt_slot(input, slot);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\tx = (touch->x_hi << 8) | touch->x_lo;\n\tif (cyapa->x_origin)\n\t\tx = cyapa->max_abs_x - x;\n\ty = (touch->y_hi << 8) | touch->y_lo;\n\tif (cyapa->y_origin)\n\t\ty = cyapa->max_abs_y - y;\n\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\tinput_report_abs(input, ABS_DISTANCE, 0);\n\tinput_report_abs(input, ABS_MT_PRESSURE,\n\t\ttouch->z);\n\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR,\n\t\ttouch->major_axis_len);\n\tinput_report_abs(input, ABS_MT_TOUCH_MINOR,\n\t\ttouch->minor_axis_len);\n\n\tinput_report_abs(input, ABS_MT_WIDTH_MAJOR,\n\t\ttouch->major_tool_len);\n\tinput_report_abs(input, ABS_MT_WIDTH_MINOR,\n\t\ttouch->minor_tool_len);\n\n\tinput_report_abs(input, ABS_MT_ORIENTATION,\n\t\ttouch->orientation);\n}\n\nstatic void cyapa_pip_report_touches(struct cyapa *cyapa,\n\t\tconst struct cyapa_pip_report_data *report_data)\n{\n\tstruct input_dev *input = cyapa->input;\n\tunsigned int touch_num;\n\tint i;\n\n\ttouch_num = report_data->report_head[PIP_NUMBER_OF_TOUCH_OFFSET] &\n\t\t\tPIP_NUMBER_OF_TOUCH_MASK;\n\n\tfor (i = 0; i < touch_num; i++)\n\t\tcyapa_pip_report_slot_data(cyapa,\n\t\t\t&report_data->touch_records[i]);\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n}\n\nint cyapa_pip_irq_handler(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct cyapa_pip_report_data report_data;\n\tunsigned int report_len;\n\tint ret;\n\n\tif (!cyapa_is_pip_app_mode(cyapa)) {\n\t\tdev_err(dev, \"invalid device state, gen=%d, state=0x%02x\\n\",\n\t\t\tcyapa->gen, cyapa->state);\n\t\treturn -EINVAL;\n\t}\n\n\tret = cyapa_i2c_pip_read(cyapa, (u8 *)&report_data,\n\t\t\tPIP_RESP_LENGTH_SIZE);\n\tif (ret != PIP_RESP_LENGTH_SIZE) {\n\t\tdev_err(dev, \"failed to read length bytes, (%d)\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\treport_len = get_unaligned_le16(\n\t\t\t&report_data.report_head[PIP_RESP_LENGTH_OFFSET]);\n\tif (report_len < PIP_RESP_LENGTH_SIZE) {\n\t\t \n\t\tdev_err(dev, \"invalid report_len=%d. bytes: %02x %02x\\n\",\n\t\t\treport_len, report_data.report_head[0],\n\t\t\treport_data.report_head[1]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (report_len == PIP_RESP_LENGTH_SIZE)\n\t\treturn 0;\n\n\tret = cyapa_i2c_pip_read(cyapa, (u8 *)&report_data, report_len);\n\tif (ret != report_len) {\n\t\tdev_err(dev, \"failed to read %d bytes report data, (%d)\\n\",\n\t\t\treport_len, ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn cyapa_pip_event_process(cyapa, &report_data);\n}\n\nstatic int cyapa_pip_event_process(struct cyapa *cyapa,\n\t\t\t\t   struct cyapa_pip_report_data *report_data)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tunsigned int report_len;\n\tu8 report_id;\n\n\treport_len = get_unaligned_le16(\n\t\t\t&report_data->report_head[PIP_RESP_LENGTH_OFFSET]);\n\t \n\tif (report_len == PIP_RESP_LENGTH_SIZE)\n\t\treturn 0;\n\n\treport_id = report_data->report_head[PIP_RESP_REPORT_ID_OFFSET];\n\tif (report_id == PIP_WAKEUP_EVENT_REPORT_ID &&\n\t\t\treport_len == PIP_WAKEUP_EVENT_SIZE) {\n\t\t \n\t\tpm_runtime_get_sync(dev);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_sync_autosuspend(dev);\n\t\treturn 0;\n\t} else if (report_id != PIP_TOUCH_REPORT_ID &&\n\t\t\treport_id != PIP_BTN_REPORT_ID &&\n\t\t\treport_id != GEN5_OLD_PUSH_BTN_REPORT_ID &&\n\t\t\treport_id != PIP_PUSH_BTN_REPORT_ID &&\n\t\t\treport_id != PIP_PROXIMITY_REPORT_ID) {\n\t\t \n\t\tdev_err(dev, \"invalid report_id=0x%02x\\n\", report_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (report_id == PIP_TOUCH_REPORT_ID &&\n\t\t(report_len < PIP_TOUCH_REPORT_HEAD_SIZE ||\n\t\t\treport_len > PIP_TOUCH_REPORT_MAX_SIZE)) {\n\t\t \n\t\tdev_err(dev, \"invalid touch packet length=%d\\n\", report_len);\n\t\treturn 0;\n\t}\n\n\tif ((report_id == PIP_BTN_REPORT_ID ||\n\t\t\treport_id == GEN5_OLD_PUSH_BTN_REPORT_ID ||\n\t\t\treport_id == PIP_PUSH_BTN_REPORT_ID) &&\n\t\t(report_len < PIP_BTN_REPORT_HEAD_SIZE ||\n\t\t\treport_len > PIP_BTN_REPORT_MAX_SIZE)) {\n\t\t \n\t\tdev_err(dev, \"invalid button packet length=%d\\n\", report_len);\n\t\treturn 0;\n\t}\n\n\tif (report_id == PIP_PROXIMITY_REPORT_ID &&\n\t\t\treport_len != PIP_PROXIMITY_REPORT_SIZE) {\n\t\t \n\t\tdev_err(dev, \"invalid proximity data, length=%d\\n\", report_len);\n\t\treturn 0;\n\t}\n\n\tif (report_id == PIP_TOUCH_REPORT_ID)\n\t\tcyapa_pip_report_touches(cyapa, report_data);\n\telse if (report_id == PIP_PROXIMITY_REPORT_ID)\n\t\tcyapa_pip_report_proximity(cyapa, report_data);\n\telse\n\t\tcyapa_pip_report_buttons(cyapa, report_data);\n\n\treturn 0;\n}\n\nint cyapa_pip_bl_activate(struct cyapa *cyapa) { return 0; }\nint cyapa_pip_bl_deactivate(struct cyapa *cyapa) { return 0; }\n\n\nconst struct cyapa_dev_ops cyapa_gen5_ops = {\n\t.check_fw = cyapa_pip_check_fw,\n\t.bl_enter = cyapa_pip_bl_enter,\n\t.bl_initiate = cyapa_pip_bl_initiate,\n\t.update_fw = cyapa_pip_do_fw_update,\n\t.bl_activate = cyapa_pip_bl_activate,\n\t.bl_deactivate = cyapa_pip_bl_deactivate,\n\n\t.show_baseline = cyapa_gen5_show_baseline,\n\t.calibrate_store = cyapa_pip_do_calibrate,\n\n\t.initialize = cyapa_pip_cmd_state_initialize,\n\n\t.state_parse = cyapa_gen5_state_parse,\n\t.operational_check = cyapa_gen5_do_operational_check,\n\n\t.irq_handler = cyapa_pip_irq_handler,\n\t.irq_cmd_handler = cyapa_pip_irq_cmd_handler,\n\t.sort_empty_output_data = cyapa_empty_pip_output_data,\n\t.set_power_mode = cyapa_gen5_set_power_mode,\n\n\t.set_proximity = cyapa_pip_set_proximity,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}