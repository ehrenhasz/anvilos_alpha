{
  "module_name": "inport.c",
  "hash_id": "34f2b2a055f9f9c54adf8a3bc33a3601f171c9ea152e3eb02c345684c2161b75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/inport.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Inport (ATI XL and Microsoft) busmouse driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define INPORT_BASE\t\t0x23c\n#define INPORT_EXTENT\t\t4\n\n#define INPORT_CONTROL_PORT\tINPORT_BASE + 0\n#define INPORT_DATA_PORT\tINPORT_BASE + 1\n#define INPORT_SIGNATURE_PORT\tINPORT_BASE + 2\n\n#define INPORT_REG_BTNS\t0x00\n#define INPORT_REG_X\t\t0x01\n#define INPORT_REG_Y\t\t0x02\n#define INPORT_REG_MODE\t\t0x07\n#define INPORT_RESET\t\t0x80\n\n#ifdef CONFIG_MOUSE_ATIXL\n#define INPORT_NAME\t\t\"ATI XL Mouse\"\n#define INPORT_VENDOR\t\t0x0002\n#define INPORT_SPEED_30HZ\t0x01\n#define INPORT_SPEED_50HZ\t0x02\n#define INPORT_SPEED_100HZ\t0x03\n#define INPORT_SPEED_200HZ\t0x04\n#define INPORT_MODE_BASE\tINPORT_SPEED_100HZ\n#define INPORT_MODE_IRQ\t\t0x08\n#else\n#define INPORT_NAME\t\t\"Microsoft InPort Mouse\"\n#define INPORT_VENDOR\t\t0x0001\n#define INPORT_MODE_BASE\t0x10\n#define INPORT_MODE_IRQ\t\t0x01\n#endif\n#define INPORT_MODE_HOLD\t0x20\n\n#define INPORT_IRQ\t\t5\n\nstatic int inport_irq = INPORT_IRQ;\nmodule_param_hw_named(irq, inport_irq, uint, irq, 0);\nMODULE_PARM_DESC(irq, \"IRQ number (5=default)\");\n\nstatic struct input_dev *inport_dev;\n\nstatic irqreturn_t inport_interrupt(int irq, void *dev_id)\n{\n\tunsigned char buttons;\n\n\toutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\n\toutb(INPORT_MODE_HOLD | INPORT_MODE_IRQ | INPORT_MODE_BASE, INPORT_DATA_PORT);\n\n\toutb(INPORT_REG_X, INPORT_CONTROL_PORT);\n\tinput_report_rel(inport_dev, REL_X, inb(INPORT_DATA_PORT));\n\n\toutb(INPORT_REG_Y, INPORT_CONTROL_PORT);\n\tinput_report_rel(inport_dev, REL_Y, inb(INPORT_DATA_PORT));\n\n\toutb(INPORT_REG_BTNS, INPORT_CONTROL_PORT);\n\tbuttons = inb(INPORT_DATA_PORT);\n\n\tinput_report_key(inport_dev, BTN_MIDDLE, buttons & 1);\n\tinput_report_key(inport_dev, BTN_LEFT,   buttons & 2);\n\tinput_report_key(inport_dev, BTN_RIGHT,  buttons & 4);\n\n\toutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\n\toutb(INPORT_MODE_IRQ | INPORT_MODE_BASE, INPORT_DATA_PORT);\n\n\tinput_sync(inport_dev);\n\treturn IRQ_HANDLED;\n}\n\nstatic int inport_open(struct input_dev *dev)\n{\n\tif (request_irq(inport_irq, inport_interrupt, 0, \"inport\", NULL))\n\t\treturn -EBUSY;\n\toutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\n\toutb(INPORT_MODE_IRQ | INPORT_MODE_BASE, INPORT_DATA_PORT);\n\n\treturn 0;\n}\n\nstatic void inport_close(struct input_dev *dev)\n{\n\toutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\n\toutb(INPORT_MODE_BASE, INPORT_DATA_PORT);\n\tfree_irq(inport_irq, NULL);\n}\n\nstatic int __init inport_init(void)\n{\n\tunsigned char a, b, c;\n\tint err;\n\n\tif (!request_region(INPORT_BASE, INPORT_EXTENT, \"inport\")) {\n\t\tprintk(KERN_ERR \"inport.c: Can't allocate ports at %#x\\n\", INPORT_BASE);\n\t\treturn -EBUSY;\n\t}\n\n\ta = inb(INPORT_SIGNATURE_PORT);\n\tb = inb(INPORT_SIGNATURE_PORT);\n\tc = inb(INPORT_SIGNATURE_PORT);\n\tif (a == b || a != c) {\n\t\tprintk(KERN_INFO \"inport.c: Didn't find InPort mouse at %#x\\n\", INPORT_BASE);\n\t\terr = -ENODEV;\n\t\tgoto err_release_region;\n\t}\n\n\tinport_dev = input_allocate_device();\n\tif (!inport_dev) {\n\t\tprintk(KERN_ERR \"inport.c: Not enough memory for input device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_region;\n\t}\n\n\tinport_dev->name = INPORT_NAME;\n\tinport_dev->phys = \"isa023c/input0\";\n\tinport_dev->id.bustype = BUS_ISA;\n\tinport_dev->id.vendor  = INPORT_VENDOR;\n\tinport_dev->id.product = 0x0001;\n\tinport_dev->id.version = 0x0100;\n\n\tinport_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\tinport_dev->keybit[BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) |\n\t\tBIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\n\tinport_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\n\tinport_dev->open  = inport_open;\n\tinport_dev->close = inport_close;\n\n\toutb(INPORT_RESET, INPORT_CONTROL_PORT);\n\toutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\n\toutb(INPORT_MODE_BASE, INPORT_DATA_PORT);\n\n\terr = input_register_device(inport_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(inport_dev);\n err_release_region:\n\trelease_region(INPORT_BASE, INPORT_EXTENT);\n\n\treturn err;\n}\n\nstatic void __exit inport_exit(void)\n{\n\tinput_unregister_device(inport_dev);\n\trelease_region(INPORT_BASE, INPORT_EXTENT);\n}\n\nmodule_init(inport_init);\nmodule_exit(inport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}