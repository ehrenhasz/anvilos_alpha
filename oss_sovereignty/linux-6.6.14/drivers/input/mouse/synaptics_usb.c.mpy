{
  "module_name": "synaptics_usb.c",
  "hash_id": "a27b68335d1f038799f4f24523384f8f9f92f6bf59b0f4f47665da64a70c2fa2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/synaptics_usb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/usb.h>\n#include <linux/input.h>\n#include <linux/usb/input.h>\n\n#define USB_VENDOR_ID_SYNAPTICS\t0x06cb\n#define USB_DEVICE_ID_SYNAPTICS_TP\t0x0001\t \n#define USB_DEVICE_ID_SYNAPTICS_INT_TP\t0x0002\t \n#define USB_DEVICE_ID_SYNAPTICS_CPAD\t0x0003\t \n#define USB_DEVICE_ID_SYNAPTICS_TS\t0x0006\t \n#define USB_DEVICE_ID_SYNAPTICS_STICK\t0x0007\t \n#define USB_DEVICE_ID_SYNAPTICS_WP\t0x0008\t \n#define USB_DEVICE_ID_SYNAPTICS_COMP_TP\t0x0009\t \n#define USB_DEVICE_ID_SYNAPTICS_WTP\t0x0010\t \n#define USB_DEVICE_ID_SYNAPTICS_DPAD\t0x0013\t \n\n#define SYNUSB_TOUCHPAD\t\t\t(1 << 0)\n#define SYNUSB_STICK\t\t\t(1 << 1)\n#define SYNUSB_TOUCHSCREEN\t\t(1 << 2)\n#define SYNUSB_AUXDISPLAY\t\t(1 << 3)  \n#define SYNUSB_COMBO\t\t\t(1 << 4)  \n#define SYNUSB_IO_ALWAYS\t\t(1 << 5)\n\n#define USB_DEVICE_SYNAPTICS(prod, kind)\t\t\\\n\tUSB_DEVICE(USB_VENDOR_ID_SYNAPTICS,\t\t\\\n\t\t   USB_DEVICE_ID_SYNAPTICS_##prod),\t\\\n\t.driver_info = (kind),\n\n#define SYNUSB_RECV_SIZE\t8\n\n#define XMIN_NOMINAL\t\t1472\n#define XMAX_NOMINAL\t\t5472\n#define YMIN_NOMINAL\t\t1408\n#define YMAX_NOMINAL\t\t4448\n\nstruct synusb {\n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\tstruct urb *urb;\n\tunsigned char *data;\n\n\t \n\tstruct mutex pm_mutex;\n\tbool is_open;\n\n\t \n\tstruct input_dev *input;\n\tchar name[128];\n\tchar phys[64];\n\n\t \n\tunsigned long flags;\n};\n\nstatic void synusb_report_buttons(struct synusb *synusb)\n{\n\tstruct input_dev *input_dev = synusb->input;\n\n\tinput_report_key(input_dev, BTN_LEFT, synusb->data[1] & 0x04);\n\tinput_report_key(input_dev, BTN_RIGHT, synusb->data[1] & 0x01);\n\tinput_report_key(input_dev, BTN_MIDDLE, synusb->data[1] & 0x02);\n}\n\nstatic void synusb_report_stick(struct synusb *synusb)\n{\n\tstruct input_dev *input_dev = synusb->input;\n\tint x, y;\n\tunsigned int pressure;\n\n\tpressure = synusb->data[6];\n\tx = (s16)(be16_to_cpup((__be16 *)&synusb->data[2]) << 3) >> 7;\n\ty = (s16)(be16_to_cpup((__be16 *)&synusb->data[4]) << 3) >> 7;\n\n\tif (pressure > 0) {\n\t\tinput_report_rel(input_dev, REL_X, x);\n\t\tinput_report_rel(input_dev, REL_Y, -y);\n\t}\n\n\tinput_report_abs(input_dev, ABS_PRESSURE, pressure);\n\n\tsynusb_report_buttons(synusb);\n\n\tinput_sync(input_dev);\n}\n\nstatic void synusb_report_touchpad(struct synusb *synusb)\n{\n\tstruct input_dev *input_dev = synusb->input;\n\tunsigned int num_fingers, tool_width;\n\tunsigned int x, y;\n\tunsigned int pressure, w;\n\n\tpressure = synusb->data[6];\n\tx = be16_to_cpup((__be16 *)&synusb->data[2]);\n\ty = be16_to_cpup((__be16 *)&synusb->data[4]);\n\tw = synusb->data[0] & 0x0f;\n\n\tif (pressure > 0) {\n\t\tnum_fingers = 1;\n\t\ttool_width = 5;\n\t\tswitch (w) {\n\t\tcase 0 ... 1:\n\t\t\tnum_fingers = 2 + w;\n\t\t\tbreak;\n\n\t\tcase 2:\t                 \n\t\t\tbreak;\n\n\t\tcase 4 ... 15:\n\t\t\ttool_width = w;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnum_fingers = 0;\n\t\ttool_width = 0;\n\t}\n\n\t \n\n\tif (pressure > 30)\n\t\tinput_report_key(input_dev, BTN_TOUCH, 1);\n\tif (pressure < 25)\n\t\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\n\tif (num_fingers > 0) {\n\t\tinput_report_abs(input_dev, ABS_X, x);\n\t\tinput_report_abs(input_dev, ABS_Y,\n\t\t\t\t YMAX_NOMINAL + YMIN_NOMINAL - y);\n\t}\n\n\tinput_report_abs(input_dev, ABS_PRESSURE, pressure);\n\tinput_report_abs(input_dev, ABS_TOOL_WIDTH, tool_width);\n\n\tinput_report_key(input_dev, BTN_TOOL_FINGER, num_fingers == 1);\n\tinput_report_key(input_dev, BTN_TOOL_DOUBLETAP, num_fingers == 2);\n\tinput_report_key(input_dev, BTN_TOOL_TRIPLETAP, num_fingers == 3);\n\n\tsynusb_report_buttons(synusb);\n\tif (synusb->flags & SYNUSB_AUXDISPLAY)\n\t\tinput_report_key(input_dev, BTN_MIDDLE, synusb->data[1] & 0x08);\n\n\tinput_sync(input_dev);\n}\n\nstatic void synusb_irq(struct urb *urb)\n{\n\tstruct synusb *synusb = urb->context;\n\tint error;\n\n\t \n\tswitch (urb->status) {\n\tcase 0:\n\t\tusb_mark_last_busy(synusb->udev);\n\t\tbreak;\n\n\t \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tgoto resubmit;\n\t\tbreak;\n\t}\n\n\tif (synusb->flags & SYNUSB_STICK)\n\t\tsynusb_report_stick(synusb);\n\telse\n\t\tsynusb_report_touchpad(synusb);\n\nresubmit:\n\terror = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (error && error != -EPERM)\n\t\tdev_err(&synusb->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result: %d\",\n\t\t\t__func__, error);\n}\n\nstatic struct usb_endpoint_descriptor *\nsynusb_get_in_endpoint(struct usb_host_interface *iface)\n{\n\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\n\tfor (i = 0; i < iface->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_int_in(endpoint)) {\n\t\t\t \n\t\t\treturn endpoint;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int synusb_open(struct input_dev *dev)\n{\n\tstruct synusb *synusb = input_get_drvdata(dev);\n\tint retval;\n\n\tretval = usb_autopm_get_interface(synusb->intf);\n\tif (retval) {\n\t\tdev_err(&synusb->intf->dev,\n\t\t\t\"%s - usb_autopm_get_interface failed, error: %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn retval;\n\t}\n\n\tmutex_lock(&synusb->pm_mutex);\n\tretval = usb_submit_urb(synusb->urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&synusb->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed, error: %d\\n\",\n\t\t\t__func__, retval);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tsynusb->intf->needs_remote_wakeup = 1;\n\tsynusb->is_open = true;\n\nout:\n\tmutex_unlock(&synusb->pm_mutex);\n\tusb_autopm_put_interface(synusb->intf);\n\treturn retval;\n}\n\nstatic void synusb_close(struct input_dev *dev)\n{\n\tstruct synusb *synusb = input_get_drvdata(dev);\n\tint autopm_error;\n\n\tautopm_error = usb_autopm_get_interface(synusb->intf);\n\n\tmutex_lock(&synusb->pm_mutex);\n\tusb_kill_urb(synusb->urb);\n\tsynusb->intf->needs_remote_wakeup = 0;\n\tsynusb->is_open = false;\n\tmutex_unlock(&synusb->pm_mutex);\n\n\tif (!autopm_error)\n\t\tusb_autopm_put_interface(synusb->intf);\n}\n\nstatic int synusb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct synusb *synusb;\n\tstruct input_dev *input_dev;\n\tunsigned int intf_num = intf->cur_altsetting->desc.bInterfaceNumber;\n\tunsigned int altsetting = min(intf->num_altsetting, 1U);\n\tint error;\n\n\terror = usb_set_interface(udev, intf_num, altsetting);\n\tif (error) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"Can not set alternate setting to %i, error: %i\",\n\t\t\taltsetting, error);\n\t\treturn error;\n\t}\n\n\tep = synusb_get_in_endpoint(intf->cur_altsetting);\n\tif (!ep)\n\t\treturn -ENODEV;\n\n\tsynusb = kzalloc(sizeof(*synusb), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!synusb || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tsynusb->udev = udev;\n\tsynusb->intf = intf;\n\tsynusb->input = input_dev;\n\tmutex_init(&synusb->pm_mutex);\n\n\tsynusb->flags = id->driver_info;\n\tif (synusb->flags & SYNUSB_COMBO) {\n\t\t \n\t\tsynusb->flags |= intf_num == 1 ?\n\t\t\t\t\tSYNUSB_STICK : SYNUSB_TOUCHPAD;\n\t}\n\n\tsynusb->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!synusb->urb) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tsynusb->data = usb_alloc_coherent(udev, SYNUSB_RECV_SIZE, GFP_KERNEL,\n\t\t\t\t\t  &synusb->urb->transfer_dma);\n\tif (!synusb->data) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb;\n\t}\n\n\tusb_fill_int_urb(synusb->urb, udev,\n\t\t\t usb_rcvintpipe(udev, ep->bEndpointAddress),\n\t\t\t synusb->data, SYNUSB_RECV_SIZE,\n\t\t\t synusb_irq, synusb,\n\t\t\t ep->bInterval);\n\tsynusb->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tif (udev->manufacturer)\n\t\tstrscpy(synusb->name, udev->manufacturer,\n\t\t\tsizeof(synusb->name));\n\n\tif (udev->product) {\n\t\tif (udev->manufacturer)\n\t\t\tstrlcat(synusb->name, \" \", sizeof(synusb->name));\n\t\tstrlcat(synusb->name, udev->product, sizeof(synusb->name));\n\t}\n\n\tif (!strlen(synusb->name))\n\t\tsnprintf(synusb->name, sizeof(synusb->name),\n\t\t\t \"USB Synaptics Device %04x:%04x\",\n\t\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t\t le16_to_cpu(udev->descriptor.idProduct));\n\n\tif (synusb->flags & SYNUSB_STICK)\n\t\tstrlcat(synusb->name, \" (Stick)\", sizeof(synusb->name));\n\n\tusb_make_path(udev, synusb->phys, sizeof(synusb->phys));\n\tstrlcat(synusb->phys, \"/input0\", sizeof(synusb->phys));\n\n\tinput_dev->name = synusb->name;\n\tinput_dev->phys = synusb->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &synusb->intf->dev;\n\n\tif (!(synusb->flags & SYNUSB_IO_ALWAYS)) {\n\t\tinput_dev->open = synusb_open;\n\t\tinput_dev->close = synusb_close;\n\t}\n\n\tinput_set_drvdata(input_dev, synusb);\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\n\tif (synusb->flags & SYNUSB_STICK) {\n\t\t__set_bit(EV_REL, input_dev->evbit);\n\t\t__set_bit(REL_X, input_dev->relbit);\n\t\t__set_bit(REL_Y, input_dev->relbit);\n\t\t__set_bit(INPUT_PROP_POINTING_STICK, input_dev->propbit);\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 127, 0, 0);\n\t} else {\n\t\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\t\t     XMIN_NOMINAL, XMAX_NOMINAL, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\t\t     YMIN_NOMINAL, YMAX_NOMINAL, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);\n\t\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_FINGER, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_TRIPLETAP, input_dev->keybit);\n\t}\n\n\tif (synusb->flags & SYNUSB_TOUCHSCREEN)\n\t\t__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\n\telse\n\t\t__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t__set_bit(BTN_MIDDLE, input_dev->keybit);\n\n\tusb_set_intfdata(intf, synusb);\n\n\tif (synusb->flags & SYNUSB_IO_ALWAYS) {\n\t\terror = synusb_open(input_dev);\n\t\tif (error)\n\t\t\tgoto err_free_dma;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"Failed to register input device, error %d\\n\",\n\t\t\terror);\n\t\tgoto err_stop_io;\n\t}\n\n\treturn 0;\n\nerr_stop_io:\n\tif (synusb->flags & SYNUSB_IO_ALWAYS)\n\t\tsynusb_close(synusb->input);\nerr_free_dma:\n\tusb_free_coherent(udev, SYNUSB_RECV_SIZE, synusb->data,\n\t\t\t  synusb->urb->transfer_dma);\nerr_free_urb:\n\tusb_free_urb(synusb->urb);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(synusb);\n\tusb_set_intfdata(intf, NULL);\n\n\treturn error;\n}\n\nstatic void synusb_disconnect(struct usb_interface *intf)\n{\n\tstruct synusb *synusb = usb_get_intfdata(intf);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\n\tif (synusb->flags & SYNUSB_IO_ALWAYS)\n\t\tsynusb_close(synusb->input);\n\n\tinput_unregister_device(synusb->input);\n\n\tusb_free_coherent(udev, SYNUSB_RECV_SIZE, synusb->data,\n\t\t\t  synusb->urb->transfer_dma);\n\tusb_free_urb(synusb->urb);\n\tkfree(synusb);\n\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic int synusb_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct synusb *synusb = usb_get_intfdata(intf);\n\n\tmutex_lock(&synusb->pm_mutex);\n\tusb_kill_urb(synusb->urb);\n\tmutex_unlock(&synusb->pm_mutex);\n\n\treturn 0;\n}\n\nstatic int synusb_resume(struct usb_interface *intf)\n{\n\tstruct synusb *synusb = usb_get_intfdata(intf);\n\tint retval = 0;\n\n\tmutex_lock(&synusb->pm_mutex);\n\n\tif ((synusb->is_open || (synusb->flags & SYNUSB_IO_ALWAYS)) &&\n\t    usb_submit_urb(synusb->urb, GFP_NOIO) < 0) {\n\t\tretval = -EIO;\n\t}\n\n\tmutex_unlock(&synusb->pm_mutex);\n\n\treturn retval;\n}\n\nstatic int synusb_pre_reset(struct usb_interface *intf)\n{\n\tstruct synusb *synusb = usb_get_intfdata(intf);\n\n\tmutex_lock(&synusb->pm_mutex);\n\tusb_kill_urb(synusb->urb);\n\n\treturn 0;\n}\n\nstatic int synusb_post_reset(struct usb_interface *intf)\n{\n\tstruct synusb *synusb = usb_get_intfdata(intf);\n\tint retval = 0;\n\n\tif ((synusb->is_open || (synusb->flags & SYNUSB_IO_ALWAYS)) &&\n\t    usb_submit_urb(synusb->urb, GFP_NOIO) < 0) {\n\t\tretval = -EIO;\n\t}\n\n\tmutex_unlock(&synusb->pm_mutex);\n\n\treturn retval;\n}\n\nstatic int synusb_reset_resume(struct usb_interface *intf)\n{\n\treturn synusb_resume(intf);\n}\n\nstatic const struct usb_device_id synusb_idtable[] = {\n\t{ USB_DEVICE_SYNAPTICS(TP, SYNUSB_TOUCHPAD) },\n\t{ USB_DEVICE_SYNAPTICS(INT_TP, SYNUSB_TOUCHPAD) },\n\t{ USB_DEVICE_SYNAPTICS(CPAD,\n\t\tSYNUSB_TOUCHPAD | SYNUSB_AUXDISPLAY | SYNUSB_IO_ALWAYS) },\n\t{ USB_DEVICE_SYNAPTICS(TS, SYNUSB_TOUCHSCREEN) },\n\t{ USB_DEVICE_SYNAPTICS(STICK, SYNUSB_STICK) },\n\t{ USB_DEVICE_SYNAPTICS(WP, SYNUSB_TOUCHPAD) },\n\t{ USB_DEVICE_SYNAPTICS(COMP_TP, SYNUSB_COMBO) },\n\t{ USB_DEVICE_SYNAPTICS(WTP, SYNUSB_TOUCHPAD) },\n\t{ USB_DEVICE_SYNAPTICS(DPAD, SYNUSB_TOUCHPAD) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, synusb_idtable);\n\nstatic struct usb_driver synusb_driver = {\n\t.name\t\t= \"synaptics_usb\",\n\t.probe\t\t= synusb_probe,\n\t.disconnect\t= synusb_disconnect,\n\t.id_table\t= synusb_idtable,\n\t.suspend\t= synusb_suspend,\n\t.resume\t\t= synusb_resume,\n\t.pre_reset\t= synusb_pre_reset,\n\t.post_reset\t= synusb_post_reset,\n\t.reset_resume\t= synusb_reset_resume,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(synusb_driver);\n\nMODULE_AUTHOR(\"Rob Miller <rob@inpharmatica.co.uk>, \"\n              \"Ron Lee <ron@debian.org>, \"\n              \"Jan Steinhoff <cpad@jan-steinhoff.de>\");\nMODULE_DESCRIPTION(\"Synaptics USB device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}