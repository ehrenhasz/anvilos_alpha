{
  "module_name": "cyapa.c",
  "hash_id": "ce7fd6004a4c6adaea89355aad413b2b3e13994aefcb4edd65cde3669bf35d97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/cyapa.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include \"cyapa.h\"\n\n\n#define CYAPA_ADAPTER_FUNC_NONE   0\n#define CYAPA_ADAPTER_FUNC_I2C    1\n#define CYAPA_ADAPTER_FUNC_SMBUS  2\n#define CYAPA_ADAPTER_FUNC_BOTH   3\n\n#define CYAPA_FW_NAME\t\t\"cyapa.bin\"\n\nconst char product_id[] = \"CYTRA\";\n\nstatic int cyapa_reinitialize(struct cyapa *cyapa);\n\nbool cyapa_is_pip_bl_mode(struct cyapa *cyapa)\n{\n\tif (cyapa->gen == CYAPA_GEN6 && cyapa->state == CYAPA_STATE_GEN6_BL)\n\t\treturn true;\n\n\tif (cyapa->gen == CYAPA_GEN5 && cyapa->state == CYAPA_STATE_GEN5_BL)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool cyapa_is_pip_app_mode(struct cyapa *cyapa)\n{\n\tif (cyapa->gen == CYAPA_GEN6 && cyapa->state == CYAPA_STATE_GEN6_APP)\n\t\treturn true;\n\n\tif (cyapa->gen == CYAPA_GEN5 && cyapa->state == CYAPA_STATE_GEN5_APP)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool cyapa_is_bootloader_mode(struct cyapa *cyapa)\n{\n\tif (cyapa_is_pip_bl_mode(cyapa))\n\t\treturn true;\n\n\tif (cyapa->gen == CYAPA_GEN3 &&\n\t\tcyapa->state >= CYAPA_STATE_BL_BUSY &&\n\t\tcyapa->state <= CYAPA_STATE_BL_ACTIVE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool cyapa_is_operational_mode(struct cyapa *cyapa)\n{\n\tif (cyapa_is_pip_app_mode(cyapa))\n\t\treturn true;\n\n\tif (cyapa->gen == CYAPA_GEN3 && cyapa->state == CYAPA_STATE_OP)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic ssize_t cyapa_i2c_read(struct cyapa *cyapa, u8 reg, size_t len,\n\t\t\t\t\tu8 *values)\n{\n\tstruct i2c_client *client = cyapa->client;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = values,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\n \nstatic int cyapa_i2c_write(struct cyapa *cyapa, u8 reg,\n\t\t\t\t\t size_t len, const void *values)\n{\n\tstruct i2c_client *client = cyapa->client;\n\tchar buf[32];\n\tint ret;\n\n\tif (len > sizeof(buf) - 1)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = reg;\n\tmemcpy(&buf[1], values, len);\n\n\tret = i2c_master_send(client, buf, len + 1);\n\tif (ret != len + 1)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic u8 cyapa_check_adapter_functionality(struct i2c_client *client)\n{\n\tu8 ret = CYAPA_ADAPTER_FUNC_NONE;\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\tret |= CYAPA_ADAPTER_FUNC_I2C;\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_BLOCK_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\tret |= CYAPA_ADAPTER_FUNC_SMBUS;\n\treturn ret;\n}\n\n \nstatic int cyapa_get_state(struct cyapa *cyapa)\n{\n\tu8 status[BL_STATUS_SIZE];\n\tu8 cmd[32];\n\t \n\tbool even_addr = ((cyapa->client->addr & 0x0001) == 0);\n\tbool smbus = false;\n\tint retries = 2;\n\tint error;\n\n\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\n\t \n\terror = cyapa_i2c_reg_read_block(cyapa, BL_HEAD_OFFSET, BL_STATUS_SIZE,\n\t\t\t\t       status);\n\n\t \n\tif (cyapa->smbus && (error == -ETIMEDOUT || error == -ENXIO)) {\n\t\tif (!even_addr)\n\t\t\terror = cyapa_read_block(cyapa,\n\t\t\t\t\tCYAPA_CMD_BL_STATUS, status);\n\t\tsmbus = true;\n\t}\n\n\tif (error != BL_STATUS_SIZE)\n\t\tgoto error;\n\n\t \n\tdo {\n\t\tcyapa->status[REG_OP_STATUS] = status[REG_OP_STATUS];\n\t\tcyapa->status[REG_BL_STATUS] = status[REG_BL_STATUS];\n\t\tcyapa->status[REG_BL_ERROR] = status[REG_BL_ERROR];\n\n\t\tif (cyapa->gen == CYAPA_GEN_UNKNOWN ||\n\t\t\t\tcyapa->gen == CYAPA_GEN3) {\n\t\t\terror = cyapa_gen3_ops.state_parse(cyapa,\n\t\t\t\t\tstatus, BL_STATUS_SIZE);\n\t\t\tif (!error)\n\t\t\t\tgoto out_detected;\n\t\t}\n\t\tif (cyapa->gen == CYAPA_GEN_UNKNOWN ||\n\t\t\t\tcyapa->gen == CYAPA_GEN6 ||\n\t\t\t\tcyapa->gen == CYAPA_GEN5) {\n\t\t\terror = cyapa_pip_state_parse(cyapa,\n\t\t\t\t\tstatus, BL_STATUS_SIZE);\n\t\t\tif (!error)\n\t\t\t\tgoto out_detected;\n\t\t}\n\t\t \n\t\tif ((cyapa->gen == CYAPA_GEN_UNKNOWN ||\n\t\t\t\tcyapa->gen == CYAPA_GEN5) &&\n\t\t\t!smbus && even_addr) {\n\t\t\terror = cyapa_gen5_ops.state_parse(cyapa,\n\t\t\t\t\tstatus, BL_STATUS_SIZE);\n\t\t\tif (!error)\n\t\t\t\tgoto out_detected;\n\t\t}\n\n\t\t \n\t\tif (!smbus) {\n\t\t\tcmd[0] = 0x00;\n\t\t\tcmd[1] = 0x00;\n\t\t\terror = cyapa_i2c_write(cyapa, 0, 2, cmd);\n\t\t\tif (error)\n\t\t\t\tgoto error;\n\n\t\t\tmsleep(50);\n\n\t\t\terror = cyapa_i2c_read(cyapa, BL_HEAD_OFFSET,\n\t\t\t\t\tBL_STATUS_SIZE, status);\n\t\t\tif (error)\n\t\t\t\tgoto error;\n\t\t}\n\t} while (--retries > 0 && !smbus);\n\n\tgoto error;\n\nout_detected:\n\tif (cyapa->state <= CYAPA_STATE_BL_BUSY)\n\t\treturn -EAGAIN;\n\treturn 0;\n\nerror:\n\treturn (error < 0) ? error : -EAGAIN;\n}\n\n \nint cyapa_poll_state(struct cyapa *cyapa, unsigned int timeout)\n{\n\tint error;\n\tint tries = timeout / 100;\n\n\tdo {\n\t\terror = cyapa_get_state(cyapa);\n\t\tif (!error && cyapa->state > CYAPA_STATE_BL_BUSY)\n\t\t\treturn 0;\n\n\t\tmsleep(100);\n\t} while (tries--);\n\n\treturn (error == -EAGAIN || error == -ETIMEDOUT) ? -ETIMEDOUT : error;\n}\n\n \nstatic int cyapa_check_is_operational(struct cyapa *cyapa)\n{\n\tint error;\n\n\terror = cyapa_poll_state(cyapa, 4000);\n\tif (error)\n\t\treturn error;\n\n\tswitch (cyapa->gen) {\n\tcase CYAPA_GEN6:\n\t\tcyapa->ops = &cyapa_gen6_ops;\n\t\tbreak;\n\tcase CYAPA_GEN5:\n\t\tcyapa->ops = &cyapa_gen5_ops;\n\t\tbreak;\n\tcase CYAPA_GEN3:\n\t\tcyapa->ops = &cyapa_gen3_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\terror = cyapa->ops->operational_check(cyapa);\n\tif (!error && cyapa_is_operational_mode(cyapa))\n\t\tcyapa->operational = true;\n\telse\n\t\tcyapa->operational = false;\n\n\treturn error;\n}\n\n\n \nstatic int cyapa_detect(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\terror = cyapa_check_is_operational(cyapa);\n\tif (error) {\n\t\tif (error != -ETIMEDOUT && error != -ENODEV &&\n\t\t\tcyapa_is_bootloader_mode(cyapa)) {\n\t\t\tdev_warn(dev, \"device detected but not operational\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(dev, \"no device detected: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_open(struct input_dev *input)\n{\n\tstruct cyapa *cyapa = input_get_drvdata(input);\n\tstruct i2c_client *client = cyapa->client;\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tif (cyapa->operational) {\n\t\t \n\t\terror = cyapa->ops->set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\n\t\tif (error) {\n\t\t\tdev_warn(dev, \"set active power failed: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terror = cyapa_reinitialize(cyapa);\n\t\tif (error || !cyapa->operational) {\n\t\t\terror = error ? error : -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tenable_irq(client->irq);\n\tif (!pm_runtime_enabled(dev)) {\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_sync_autosuspend(dev);\nout:\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn error;\n}\n\nstatic void cyapa_close(struct input_dev *input)\n{\n\tstruct cyapa *cyapa = input_get_drvdata(input);\n\tstruct i2c_client *client = cyapa->client;\n\tstruct device *dev = &cyapa->client->dev;\n\n\tmutex_lock(&cyapa->state_sync_lock);\n\n\tdisable_irq(client->irq);\n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\tif (cyapa->operational)\n\t\tcyapa->ops->set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_OFF, 0, CYAPA_PM_DEACTIVE);\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n}\n\nstatic int cyapa_create_input_dev(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!cyapa->physical_size_x || !cyapa->physical_size_y)\n\t\treturn -EINVAL;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"failed to allocate memory for input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = CYAPA_NAME;\n\tinput->phys = cyapa->phys;\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.version = 1;\n\tinput->id.product = 0;   \n\tinput->dev.parent = &cyapa->client->dev;\n\n\tinput->open = cyapa_open;\n\tinput->close = cyapa_close;\n\n\tinput_set_drvdata(input, cyapa);\n\n\t__set_bit(EV_ABS, input->evbit);\n\n\t \n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, cyapa->max_abs_x, 0,\n\t\t\t     0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, cyapa->max_abs_y, 0,\n\t\t\t     0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, cyapa->max_z, 0, 0);\n\tif (cyapa->gen > CYAPA_GEN3) {\n\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);\n\t\t \n\t\tinput_set_abs_params(input, ABS_MT_ORIENTATION,\n\t\t\t\t-127, 127, 0, 0);\n\t}\n\tif (cyapa->gen >= CYAPA_GEN5) {\n\t\tinput_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_WIDTH_MINOR, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input, ABS_DISTANCE, 0, 1, 0, 0);\n\t}\n\n\tinput_abs_set_res(input, ABS_MT_POSITION_X,\n\t\t\t  cyapa->max_abs_x / cyapa->physical_size_x);\n\tinput_abs_set_res(input, ABS_MT_POSITION_Y,\n\t\t\t  cyapa->max_abs_y / cyapa->physical_size_y);\n\n\tif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK)\n\t\t__set_bit(BTN_LEFT, input->keybit);\n\tif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK)\n\t\t__set_bit(BTN_MIDDLE, input->keybit);\n\tif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK)\n\t\t__set_bit(BTN_RIGHT, input->keybit);\n\n\tif (cyapa->btn_capability == CAPABILITY_LEFT_BTN_MASK)\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\t \n\terror = input_mt_init_slots(input, CYAPA_MAX_MT_SLOTS,\n\t\t\t\t    INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tcyapa->input = input;\n\treturn 0;\n}\n\nstatic void cyapa_enable_irq_for_cmd(struct cyapa *cyapa)\n{\n\tstruct input_dev *input = cyapa->input;\n\n\tif (!input || !input_device_enabled(input)) {\n\t\t \n\t\tif (!input || cyapa->operational)\n\t\t\tcyapa->ops->set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\n\t\t \n\t\tif (cyapa->gen >= CYAPA_GEN5)\n\t\t\tenable_irq(cyapa->client->irq);\n\t}\n}\n\nstatic void cyapa_disable_irq_for_cmd(struct cyapa *cyapa)\n{\n\tstruct input_dev *input = cyapa->input;\n\n\tif (!input || !input_device_enabled(input)) {\n\t\tif (cyapa->gen >= CYAPA_GEN5)\n\t\t\tdisable_irq(cyapa->client->irq);\n\t\tif (!input || cyapa->operational)\n\t\t\tcyapa->ops->set_power_mode(cyapa,\n\t\t\t\t\tPWR_MODE_OFF, 0, CYAPA_PM_ACTIVE);\n\t}\n}\n\n \nu8 cyapa_sleep_time_to_pwr_cmd(u16 sleep_time)\n{\n\tu16 encoded_time;\n\n\tsleep_time = clamp_val(sleep_time, 20, 1000);\n\tencoded_time = sleep_time < 100 ? sleep_time / 10 : sleep_time / 20 + 5;\n\treturn (encoded_time << 2) & PWR_MODE_MASK;\n}\n\nu16 cyapa_pwr_cmd_to_sleep_time(u8 pwr_mode)\n{\n\tu8 encoded_time = pwr_mode >> 2;\n\n\treturn (encoded_time < 10) ? encoded_time * 10\n\t\t\t\t   : (encoded_time - 5) * 20;\n}\n\n \nstatic int cyapa_initialize(struct cyapa *cyapa)\n{\n\tint error = 0;\n\n\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\tcyapa->gen = CYAPA_GEN_UNKNOWN;\n\tmutex_init(&cyapa->state_sync_lock);\n\n\t \n\tcyapa->suspend_power_mode = PWR_MODE_SLEEP;\n\tcyapa->suspend_sleep_time =\n\t\tcyapa_pwr_cmd_to_sleep_time(cyapa->suspend_power_mode);\n\n\t \n\terror = cyapa_gen3_ops.initialize(cyapa);\n\tif (!error)\n\t\terror = cyapa_gen5_ops.initialize(cyapa);\n\tif (!error)\n\t\terror = cyapa_gen6_ops.initialize(cyapa);\n\tif (error)\n\t\treturn error;\n\n\terror = cyapa_detect(cyapa);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (cyapa->operational)\n\t\tcyapa->ops->set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_OFF, 0, CYAPA_PM_ACTIVE);\n\n\treturn 0;\n}\n\nstatic int cyapa_reinitialize(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct input_dev *input = cyapa->input;\n\tint error;\n\n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\n\t \n\tif (cyapa->operational)\n\t\tcyapa->ops->set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\n\n\terror = cyapa_detect(cyapa);\n\tif (error)\n\t\tgoto out;\n\n\tif (!input && cyapa->operational) {\n\t\terror = cyapa_create_input_dev(cyapa);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"create input_dev instance failed: %d\\n\",\n\t\t\t\t\terror);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (!input || !input_device_enabled(input)) {\n\t\t \n\t\tif (cyapa->operational)\n\t\t\tcyapa->ops->set_power_mode(cyapa,\n\t\t\t\t\tPWR_MODE_OFF, 0, CYAPA_PM_DEACTIVE);\n\t} else if (!error && cyapa->operational) {\n\t\t \n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\n\t\tpm_runtime_get_sync(dev);\n\t\tpm_runtime_mark_last_busy(dev);\n\t\tpm_runtime_put_sync_autosuspend(dev);\n\t}\n\n\treturn error;\n}\n\nstatic irqreturn_t cyapa_irq(int irq, void *dev_id)\n{\n\tstruct cyapa *cyapa = dev_id;\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\tif (device_may_wakeup(dev))\n\t\tpm_wakeup_event(dev, 0);\n\n\t \n\tif (cyapa->ops->irq_cmd_handler(cyapa)) {\n\t\t \n\t\tif (!cyapa->input) {\n\t\t\t \n\t\t\tcyapa->ops->sort_empty_output_data(cyapa,\n\t\t\t\t\tNULL, NULL, NULL);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cyapa->operational) {\n\t\t\terror = cyapa->ops->irq_handler(cyapa);\n\n\t\t\t \n\t\t\tpm_runtime_get_sync(dev);\n\t\t\tpm_runtime_mark_last_busy(dev);\n\t\t\tpm_runtime_put_sync_autosuspend(dev);\n\t\t}\n\n\t\tif (!cyapa->operational || error) {\n\t\t\tif (!mutex_trylock(&cyapa->state_sync_lock)) {\n\t\t\t\tcyapa->ops->sort_empty_output_data(cyapa,\n\t\t\t\t\tNULL, NULL, NULL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcyapa_reinitialize(cyapa);\n\t\t\tmutex_unlock(&cyapa->state_sync_lock);\n\t\t}\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\n \n#ifdef CONFIG_PM_SLEEP\nstatic ssize_t cyapa_show_suspend_scanrate(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tu8 pwr_cmd;\n\tu16 sleep_time;\n\tint len;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tpwr_cmd = cyapa->suspend_power_mode;\n\tsleep_time = cyapa->suspend_sleep_time;\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\n\tswitch (pwr_cmd) {\n\tcase PWR_MODE_BTN_ONLY:\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%s\\n\", BTN_ONLY_MODE_NAME);\n\t\tbreak;\n\n\tcase PWR_MODE_OFF:\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%s\\n\", OFF_MODE_NAME);\n\t\tbreak;\n\n\tdefault:\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t\tcyapa->gen == CYAPA_GEN3 ?\n\t\t\t\t\tcyapa_pwr_cmd_to_sleep_time(pwr_cmd) :\n\t\t\t\t\tsleep_time);\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t cyapa_update_suspend_scanrate(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tu16 sleep_time;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tif (sysfs_streq(buf, BTN_ONLY_MODE_NAME)) {\n\t\tcyapa->suspend_power_mode = PWR_MODE_BTN_ONLY;\n\t} else if (sysfs_streq(buf, OFF_MODE_NAME)) {\n\t\tcyapa->suspend_power_mode = PWR_MODE_OFF;\n\t} else if (!kstrtou16(buf, 10, &sleep_time)) {\n\t\tcyapa->suspend_sleep_time = min_t(u16, sleep_time, 1000);\n\t\tcyapa->suspend_power_mode =\n\t\t\tcyapa_sleep_time_to_pwr_cmd(cyapa->suspend_sleep_time);\n\t} else {\n\t\tcount = -EINVAL;\n\t}\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(suspend_scanrate_ms, S_IRUGO|S_IWUSR,\n\t\t   cyapa_show_suspend_scanrate,\n\t\t   cyapa_update_suspend_scanrate);\n\nstatic struct attribute *cyapa_power_wakeup_entries[] = {\n\t&dev_attr_suspend_scanrate_ms.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cyapa_power_wakeup_group = {\n\t.name = power_group_name,\n\t.attrs = cyapa_power_wakeup_entries,\n};\n\nstatic void cyapa_remove_power_wakeup_group(void *data)\n{\n\tstruct cyapa *cyapa = data;\n\n\tsysfs_unmerge_group(&cyapa->client->dev.kobj,\n\t\t\t\t&cyapa_power_wakeup_group);\n}\n\nstatic int cyapa_prepare_wakeup_controls(struct cyapa *cyapa)\n{\n\tstruct i2c_client *client = cyapa->client;\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\tif (device_can_wakeup(dev)) {\n\t\terror = sysfs_merge_group(&dev->kobj,\n\t\t\t\t\t  &cyapa_power_wakeup_group);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to add power wakeup group: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = devm_add_action_or_reset(dev,\n\t\t\t\tcyapa_remove_power_wakeup_group, cyapa);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to add power cleanup action: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int cyapa_prepare_wakeup_controls(struct cyapa *cyapa)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic ssize_t cyapa_show_rt_suspend_scanrate(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tu8 pwr_cmd;\n\tu16 sleep_time;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tpwr_cmd = cyapa->runtime_suspend_power_mode;\n\tsleep_time = cyapa->runtime_suspend_sleep_time;\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t cyapa->gen == CYAPA_GEN3 ?\n\t\t\t\tcyapa_pwr_cmd_to_sleep_time(pwr_cmd) :\n\t\t\t\tsleep_time);\n}\n\nstatic ssize_t cyapa_update_rt_suspend_scanrate(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tu16 time;\n\tint error;\n\n\tif (buf == NULL || count == 0 || kstrtou16(buf, 10, &time)) {\n\t\tdev_err(dev, \"invalid runtime suspend scanrate ms parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpm_runtime_get_sync(dev);\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tcyapa->runtime_suspend_sleep_time = min_t(u16, time, 1000);\n\tcyapa->runtime_suspend_power_mode =\n\t\tcyapa_sleep_time_to_pwr_cmd(cyapa->runtime_suspend_sleep_time);\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\n\tpm_runtime_put_sync_autosuspend(dev);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(runtime_suspend_scanrate_ms, S_IRUGO|S_IWUSR,\n\t\t   cyapa_show_rt_suspend_scanrate,\n\t\t   cyapa_update_rt_suspend_scanrate);\n\nstatic struct attribute *cyapa_power_runtime_entries[] = {\n\t&dev_attr_runtime_suspend_scanrate_ms.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cyapa_power_runtime_group = {\n\t.name = power_group_name,\n\t.attrs = cyapa_power_runtime_entries,\n};\n\nstatic void cyapa_remove_power_runtime_group(void *data)\n{\n\tstruct cyapa *cyapa = data;\n\n\tsysfs_unmerge_group(&cyapa->client->dev.kobj,\n\t\t\t\t&cyapa_power_runtime_group);\n}\n\nstatic int cyapa_start_runtime(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\tcyapa->runtime_suspend_power_mode = PWR_MODE_IDLE;\n\tcyapa->runtime_suspend_sleep_time =\n\t\tcyapa_pwr_cmd_to_sleep_time(cyapa->runtime_suspend_power_mode);\n\n\terror = sysfs_merge_group(&dev->kobj, &cyapa_power_runtime_group);\n\tif (error) {\n\t\tdev_err(dev,\n\t\t\t\"failed to create power runtime group: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, cyapa_remove_power_runtime_group,\n\t\t\t\t\t cyapa);\n\tif (error) {\n\t\tdev_err(dev,\n\t\t\t\"failed to add power runtime cleanup action: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_DELAY);\n\n\treturn 0;\n}\n#else\nstatic inline int cyapa_start_runtime(struct cyapa *cyapa)\n{\n\treturn 0;\n}\n#endif  \n\nstatic ssize_t cyapa_show_fm_ver(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tint error;\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\terror = scnprintf(buf, PAGE_SIZE, \"%d.%d\\n\", cyapa->fw_maj_ver,\n\t\t\t cyapa->fw_min_ver);\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn error;\n}\n\nstatic ssize_t cyapa_show_product_id(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint size;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\tsize = scnprintf(buf, PAGE_SIZE, \"%s\\n\", cyapa->product_id);\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn size;\n}\n\nstatic int cyapa_firmware(struct cyapa *cyapa, const char *fw_name)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tconst struct firmware *fw;\n\tint error;\n\n\terror = request_firmware(&fw, fw_name, dev);\n\tif (error) {\n\t\tdev_err(dev, \"Could not load firmware from %s: %d\\n\",\n\t\t\tfw_name, error);\n\t\treturn error;\n\t}\n\n\terror = cyapa->ops->check_fw(cyapa, fw);\n\tif (error) {\n\t\tdev_err(dev, \"Invalid CYAPA firmware image: %s\\n\",\n\t\t\t\tfw_name);\n\t\tgoto done;\n\t}\n\n\t \n\tpm_runtime_get_sync(dev);\n\n\t \n\tcyapa_enable_irq_for_cmd(cyapa);\n\n\terror = cyapa->ops->bl_enter(cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"bl_enter failed, %d\\n\", error);\n\t\tgoto err_detect;\n\t}\n\n\terror = cyapa->ops->bl_activate(cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"bl_activate failed, %d\\n\", error);\n\t\tgoto err_detect;\n\t}\n\n\terror = cyapa->ops->bl_initiate(cyapa, fw);\n\tif (error) {\n\t\tdev_err(dev, \"bl_initiate failed, %d\\n\", error);\n\t\tgoto err_detect;\n\t}\n\n\terror = cyapa->ops->update_fw(cyapa, fw);\n\tif (error) {\n\t\tdev_err(dev, \"update_fw failed, %d\\n\", error);\n\t\tgoto err_detect;\n\t}\n\nerr_detect:\n\tcyapa_disable_irq_for_cmd(cyapa);\n\tpm_runtime_put_noidle(dev);\n\ndone:\n\trelease_firmware(fw);\n\treturn error;\n}\n\nstatic ssize_t cyapa_update_fw_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tchar fw_name[NAME_MAX];\n\tint ret, error;\n\n\tif (count >= NAME_MAX) {\n\t\tdev_err(dev, \"File name too long\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(fw_name, buf, count);\n\tif (fw_name[count - 1] == '\\n')\n\t\tfw_name[count - 1] = '\\0';\n\telse\n\t\tfw_name[count] = '\\0';\n\n\tif (cyapa->input) {\n\t\t \n\t\tinput_unregister_device(cyapa->input);\n\t\tcyapa->input = NULL;\n\t}\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error) {\n\t\t \n\t\tcyapa_reinitialize(cyapa);\n\t\treturn error;\n\t}\n\n\terror = cyapa_firmware(cyapa, fw_name);\n\tif (error)\n\t\tdev_err(dev, \"firmware update failed: %d\\n\", error);\n\telse\n\t\tdev_dbg(dev, \"firmware update successfully done.\\n\");\n\n\t \n\tret = cyapa_reinitialize(cyapa);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to re-detect after updated: %d\\n\", ret);\n\t\terror = error ? error : ret;\n\t}\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\n\treturn error ? error : count;\n}\n\nstatic ssize_t cyapa_calibrate_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tif (cyapa->operational) {\n\t\tcyapa_enable_irq_for_cmd(cyapa);\n\t\terror = cyapa->ops->calibrate_store(dev, attr, buf, count);\n\t\tcyapa_disable_irq_for_cmd(cyapa);\n\t} else {\n\t\terror = -EBUSY;   \n\t}\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn error < 0 ? error : count;\n}\n\nstatic ssize_t cyapa_show_baseline(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tssize_t error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tif (cyapa->operational) {\n\t\tcyapa_enable_irq_for_cmd(cyapa);\n\t\terror = cyapa->ops->show_baseline(dev, attr, buf);\n\t\tcyapa_disable_irq_for_cmd(cyapa);\n\t} else {\n\t\terror = -EBUSY;   \n\t}\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn error;\n}\n\nstatic char *cyapa_state_to_string(struct cyapa *cyapa)\n{\n\tswitch (cyapa->state) {\n\tcase CYAPA_STATE_BL_BUSY:\n\t\treturn \"bootloader busy\";\n\tcase CYAPA_STATE_BL_IDLE:\n\t\treturn \"bootloader idle\";\n\tcase CYAPA_STATE_BL_ACTIVE:\n\t\treturn \"bootloader active\";\n\tcase CYAPA_STATE_GEN5_BL:\n\tcase CYAPA_STATE_GEN6_BL:\n\t\treturn \"bootloader\";\n\tcase CYAPA_STATE_OP:\n\tcase CYAPA_STATE_GEN5_APP:\n\tcase CYAPA_STATE_GEN6_APP:\n\t\treturn \"operational\";   \n\tdefault:\n\t\treturn \"invalid mode\";\n\t}\n}\n\nstatic ssize_t cyapa_show_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint size;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\tsize = scnprintf(buf, PAGE_SIZE, \"gen%d %s\\n\",\n\t\t\tcyapa->gen, cyapa_state_to_string(cyapa));\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn size;\n}\n\nstatic DEVICE_ATTR(firmware_version, S_IRUGO, cyapa_show_fm_ver, NULL);\nstatic DEVICE_ATTR(product_id, S_IRUGO, cyapa_show_product_id, NULL);\nstatic DEVICE_ATTR(update_fw, S_IWUSR, NULL, cyapa_update_fw_store);\nstatic DEVICE_ATTR(baseline, S_IRUGO, cyapa_show_baseline, NULL);\nstatic DEVICE_ATTR(calibrate, S_IWUSR, NULL, cyapa_calibrate_store);\nstatic DEVICE_ATTR(mode, S_IRUGO, cyapa_show_mode, NULL);\n\nstatic struct attribute *cyapa_sysfs_entries[] = {\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_update_fw.attr,\n\t&dev_attr_baseline.attr,\n\t&dev_attr_calibrate.attr,\n\t&dev_attr_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cyapa_sysfs_group = {\n\t.attrs = cyapa_sysfs_entries,\n};\n\nstatic void cyapa_disable_regulator(void *data)\n{\n\tstruct cyapa *cyapa = data;\n\n\tregulator_disable(cyapa->vcc);\n}\n\nstatic int cyapa_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct cyapa *cyapa;\n\tu8 adapter_func;\n\tunion i2c_smbus_data dummy;\n\tint error;\n\n\tadapter_func = cyapa_check_adapter_functionality(client);\n\tif (adapter_func == CYAPA_ADAPTER_FUNC_NONE) {\n\t\tdev_err(dev, \"not a supported I2C/SMBus adapter\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (i2c_smbus_xfer(client->adapter, client->addr, 0,\n\t\t\tI2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0)\n\t\treturn -ENODEV;\n\n\tcyapa = devm_kzalloc(dev, sizeof(struct cyapa), GFP_KERNEL);\n\tif (!cyapa)\n\t\treturn -ENOMEM;\n\n\t \n\tif (adapter_func == CYAPA_ADAPTER_FUNC_SMBUS)\n\t\tcyapa->smbus = true;\n\n\tcyapa->client = client;\n\ti2c_set_clientdata(client, cyapa);\n\tsprintf(cyapa->phys, \"i2c-%d-%04x/input0\", client->adapter->nr,\n\t\tclient->addr);\n\n\tcyapa->vcc = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(cyapa->vcc)) {\n\t\terror = PTR_ERR(cyapa->vcc);\n\t\tdev_err(dev, \"failed to get vcc regulator: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(cyapa->vcc);\n\tif (error) {\n\t\tdev_err(dev, \"failed to enable regulator: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, cyapa_disable_regulator, cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"failed to add disable regulator action: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = cyapa_initialize(cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"failed to detect and initialize tp device.\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(dev, &cyapa_sysfs_group);\n\tif (error) {\n\t\tdev_err(dev, \"failed to create sysfs entries: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = cyapa_prepare_wakeup_controls(cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"failed to prepare wakeup controls: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = cyapa_start_runtime(cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"failed to start pm_runtime: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, cyapa_irq,\n\t\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t  \"cyapa\", cyapa);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request threaded irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tdisable_irq(client->irq);\n\n\t \n\tif (cyapa->operational) {\n\t\terror = cyapa_create_input_dev(cyapa);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"create input_dev instance failed: %d\\n\",\n\t\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cyapa *cyapa = i2c_get_clientdata(client);\n\tu8 power_mode;\n\tint error;\n\n\terror = mutex_lock_interruptible(&cyapa->state_sync_lock);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\tdisable_irq(client->irq);\n\n\t \n\tif (cyapa->operational) {\n\t\tpower_mode = device_may_wakeup(dev) ? cyapa->suspend_power_mode\n\t\t\t\t\t\t    : PWR_MODE_OFF;\n\t\terror = cyapa->ops->set_power_mode(cyapa, power_mode,\n\t\t\t\tcyapa->suspend_sleep_time, CYAPA_PM_SUSPEND);\n\t\tif (error)\n\t\t\tdev_err(dev, \"suspend set power mode failed: %d\\n\",\n\t\t\t\t\terror);\n\t}\n\n\t \n\tif (cyapa->dev_pwr_mode != PWR_MODE_OFF)\n\t\tcyapa->ops->set_proximity(cyapa, false);\n\n\tif (device_may_wakeup(dev))\n\t\tcyapa->irq_wake = (enable_irq_wake(client->irq) == 0);\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn 0;\n}\n\nstatic int cyapa_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cyapa *cyapa = i2c_get_clientdata(client);\n\tint error;\n\n\tmutex_lock(&cyapa->state_sync_lock);\n\n\tif (device_may_wakeup(dev) && cyapa->irq_wake) {\n\t\tdisable_irq_wake(client->irq);\n\t\tcyapa->irq_wake = false;\n\t}\n\n\t \n\terror = cyapa_reinitialize(cyapa);\n\tif (error)\n\t\tdev_warn(dev, \"failed to reinitialize TP device: %d\\n\", error);\n\n\tenable_irq(client->irq);\n\n\tmutex_unlock(&cyapa->state_sync_lock);\n\treturn 0;\n}\n\nstatic int cyapa_runtime_suspend(struct device *dev)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint error;\n\n\terror = cyapa->ops->set_power_mode(cyapa,\n\t\t\tcyapa->runtime_suspend_power_mode,\n\t\t\tcyapa->runtime_suspend_sleep_time,\n\t\t\tCYAPA_PM_RUNTIME_SUSPEND);\n\tif (error)\n\t\tdev_warn(dev, \"runtime suspend failed: %d\\n\", error);\n\n\treturn 0;\n}\n\nstatic int cyapa_runtime_resume(struct device *dev)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint error;\n\n\terror = cyapa->ops->set_power_mode(cyapa,\n\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_RUNTIME_RESUME);\n\tif (error)\n\t\tdev_warn(dev, \"runtime resume failed: %d\\n\", error);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cyapa_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(cyapa_suspend, cyapa_resume)\n\tRUNTIME_PM_OPS(cyapa_runtime_suspend, cyapa_runtime_resume, NULL)\n};\n\nstatic const struct i2c_device_id cyapa_id_table[] = {\n\t{ \"cyapa\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, cyapa_id_table);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cyapa_acpi_id[] = {\n\t{ \"CYAP0000\", 0 },   \n\t{ \"CYAP0001\", 0 },   \n\t{ \"CYAP0002\", 0 },   \n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cyapa_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cyapa_of_match[] = {\n\t{ .compatible = \"cypress,cyapa\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cyapa_of_match);\n#endif\n\nstatic struct i2c_driver cyapa_driver = {\n\t.driver = {\n\t\t.name = \"cyapa\",\n\t\t.pm = pm_ptr(&cyapa_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(cyapa_acpi_id),\n\t\t.of_match_table = of_match_ptr(cyapa_of_match),\n\t},\n\n\t.probe = cyapa_probe,\n\t.id_table = cyapa_id_table,\n};\n\nmodule_i2c_driver(cyapa_driver);\n\nMODULE_DESCRIPTION(\"Cypress APA I2C Trackpad Driver\");\nMODULE_AUTHOR(\"Dudley Du <dudl@cypress.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}