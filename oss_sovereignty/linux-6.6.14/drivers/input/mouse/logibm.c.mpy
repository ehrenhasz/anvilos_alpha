{
  "module_name": "logibm.c",
  "hash_id": "ac85c0ac348f1b219e42a5b0ecd30619b714d88dd925fcbaac47a92ac76862f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/logibm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Logitech busmouse driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define\tLOGIBM_BASE\t\t0x23c\n#define\tLOGIBM_EXTENT\t\t4\n\n#define\tLOGIBM_DATA_PORT\tLOGIBM_BASE + 0\n#define\tLOGIBM_SIGNATURE_PORT\tLOGIBM_BASE + 1\n#define\tLOGIBM_CONTROL_PORT\tLOGIBM_BASE + 2\n#define\tLOGIBM_CONFIG_PORT\tLOGIBM_BASE + 3\n\n#define\tLOGIBM_ENABLE_IRQ\t0x00\n#define\tLOGIBM_DISABLE_IRQ\t0x10\n#define\tLOGIBM_READ_X_LOW\t0x80\n#define\tLOGIBM_READ_X_HIGH\t0xa0\n#define\tLOGIBM_READ_Y_LOW\t0xc0\n#define\tLOGIBM_READ_Y_HIGH\t0xe0\n\n#define LOGIBM_DEFAULT_MODE\t0x90\n#define LOGIBM_CONFIG_BYTE\t0x91\n#define LOGIBM_SIGNATURE_BYTE\t0xa5\n\n#define LOGIBM_IRQ\t\t5\n\nstatic int logibm_irq = LOGIBM_IRQ;\nmodule_param_hw_named(irq, logibm_irq, uint, irq, 0);\nMODULE_PARM_DESC(irq, \"IRQ number (5=default)\");\n\nstatic struct input_dev *logibm_dev;\n\nstatic irqreturn_t logibm_interrupt(int irq, void *dev_id)\n{\n\tchar dx, dy;\n\tunsigned char buttons;\n\n\toutb(LOGIBM_READ_X_LOW, LOGIBM_CONTROL_PORT);\n\tdx = (inb(LOGIBM_DATA_PORT) & 0xf);\n\toutb(LOGIBM_READ_X_HIGH, LOGIBM_CONTROL_PORT);\n\tdx |= (inb(LOGIBM_DATA_PORT) & 0xf) << 4;\n\toutb(LOGIBM_READ_Y_LOW, LOGIBM_CONTROL_PORT);\n\tdy = (inb(LOGIBM_DATA_PORT) & 0xf);\n\toutb(LOGIBM_READ_Y_HIGH, LOGIBM_CONTROL_PORT);\n\tbuttons = inb(LOGIBM_DATA_PORT);\n\tdy |= (buttons & 0xf) << 4;\n\tbuttons = ~buttons >> 5;\n\n\tinput_report_rel(logibm_dev, REL_X, dx);\n\tinput_report_rel(logibm_dev, REL_Y, dy);\n\tinput_report_key(logibm_dev, BTN_RIGHT,  buttons & 1);\n\tinput_report_key(logibm_dev, BTN_MIDDLE, buttons & 2);\n\tinput_report_key(logibm_dev, BTN_LEFT,   buttons & 4);\n\tinput_sync(logibm_dev);\n\n\toutb(LOGIBM_ENABLE_IRQ, LOGIBM_CONTROL_PORT);\n\treturn IRQ_HANDLED;\n}\n\nstatic int logibm_open(struct input_dev *dev)\n{\n\tif (request_irq(logibm_irq, logibm_interrupt, 0, \"logibm\", NULL)) {\n\t\tprintk(KERN_ERR \"logibm.c: Can't allocate irq %d\\n\", logibm_irq);\n\t\treturn -EBUSY;\n\t}\n\toutb(LOGIBM_ENABLE_IRQ, LOGIBM_CONTROL_PORT);\n\treturn 0;\n}\n\nstatic void logibm_close(struct input_dev *dev)\n{\n\toutb(LOGIBM_DISABLE_IRQ, LOGIBM_CONTROL_PORT);\n\tfree_irq(logibm_irq, NULL);\n}\n\nstatic int __init logibm_init(void)\n{\n\tint err;\n\n\tif (!request_region(LOGIBM_BASE, LOGIBM_EXTENT, \"logibm\")) {\n\t\tprintk(KERN_ERR \"logibm.c: Can't allocate ports at %#x\\n\", LOGIBM_BASE);\n\t\treturn -EBUSY;\n\t}\n\n\toutb(LOGIBM_CONFIG_BYTE, LOGIBM_CONFIG_PORT);\n\toutb(LOGIBM_SIGNATURE_BYTE, LOGIBM_SIGNATURE_PORT);\n\tudelay(100);\n\n\tif (inb(LOGIBM_SIGNATURE_PORT) != LOGIBM_SIGNATURE_BYTE) {\n\t\tprintk(KERN_INFO \"logibm.c: Didn't find Logitech busmouse at %#x\\n\", LOGIBM_BASE);\n\t\terr = -ENODEV;\n\t\tgoto err_release_region;\n\t}\n\n\toutb(LOGIBM_DEFAULT_MODE, LOGIBM_CONFIG_PORT);\n\toutb(LOGIBM_DISABLE_IRQ, LOGIBM_CONTROL_PORT);\n\n\tlogibm_dev = input_allocate_device();\n\tif (!logibm_dev) {\n\t\tprintk(KERN_ERR \"logibm.c: Not enough memory for input device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_region;\n\t}\n\n\tlogibm_dev->name = \"Logitech bus mouse\";\n\tlogibm_dev->phys = \"isa023c/input0\";\n\tlogibm_dev->id.bustype = BUS_ISA;\n\tlogibm_dev->id.vendor  = 0x0003;\n\tlogibm_dev->id.product = 0x0001;\n\tlogibm_dev->id.version = 0x0100;\n\n\tlogibm_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\tlogibm_dev->keybit[BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) |\n\t\tBIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\n\tlogibm_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\n\tlogibm_dev->open  = logibm_open;\n\tlogibm_dev->close = logibm_close;\n\n\terr = input_register_device(logibm_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(logibm_dev);\n err_release_region:\n\trelease_region(LOGIBM_BASE, LOGIBM_EXTENT);\n\n\treturn err;\n}\n\nstatic void __exit logibm_exit(void)\n{\n\tinput_unregister_device(logibm_dev);\n\trelease_region(LOGIBM_BASE, LOGIBM_EXTENT);\n}\n\nmodule_init(logibm_init);\nmodule_exit(logibm_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}