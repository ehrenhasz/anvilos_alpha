{
  "module_name": "elan_i2c_core.c",
  "hash_id": "1a7a567c16630dc5fa3033d618d33a8e2f7a5866e4f8686a305fafe7599dd192",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/elan_i2c_core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/input.h>\n#include <linux/uaccess.h>\n#include <linux/jiffies.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <asm/unaligned.h>\n\n#include \"elan_i2c.h\"\n\n#define DRIVER_NAME\t\t\"elan_i2c\"\n#define ELAN_VENDOR_ID\t\t0x04f3\n#define ETP_MAX_PRESSURE\t255\n#define ETP_FWIDTH_REDUCE\t90\n#define ETP_FINGER_WIDTH\t15\n#define ETP_RETRY_COUNT\t\t3\n\n \n#define ETP_QUIRK_QUICK_WAKEUP\tBIT(0)\n\n \nstruct elan_tp_data {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input;\n\tstruct input_dev\t*tp_input;  \n\tstruct regulator\t*vcc;\n\n\tconst struct elan_transport_ops *ops;\n\n\t \n\tstruct completion\tfw_completion;\n\tbool\t\t\tin_fw_update;\n\n\tstruct mutex\t\tsysfs_mutex;\n\n\tunsigned int\t\tmax_x;\n\tunsigned int\t\tmax_y;\n\tunsigned int\t\twidth_x;\n\tunsigned int\t\twidth_y;\n\tunsigned int\t\tx_res;\n\tunsigned int\t\ty_res;\n\n\tu8\t\t\tpattern;\n\tu16\t\t\tproduct_id;\n\tu8\t\t\tfw_version;\n\tu8\t\t\tsm_version;\n\tu8\t\t\tiap_version;\n\tu16\t\t\tfw_checksum;\n\tunsigned int\t\treport_features;\n\tunsigned int\t\treport_len;\n\tint\t\t\tpressure_adjustment;\n\tu8\t\t\tmode;\n\tu16\t\t\tic_type;\n\tu16\t\t\tfw_validpage_count;\n\tu16\t\t\tfw_page_size;\n\tu32\t\t\tfw_signature_address;\n\n\tu8\t\t\tmin_baseline;\n\tu8\t\t\tmax_baseline;\n\tbool\t\t\tbaseline_ready;\n\tu8\t\t\tclickpad;\n\tbool\t\t\tmiddle_button;\n\n\tu32\t\t\tquirks;\t\t \n};\n\nstatic u32 elan_i2c_lookup_quirks(u16 ic_type, u16 product_id)\n{\n\tstatic const struct {\n\t\tu16 ic_type;\n\t\tu16 product_id;\n\t\tu32 quirks;\n\t} elan_i2c_quirks[] = {\n\t\t{ 0x0D, ETP_PRODUCT_ID_DELBIN, ETP_QUIRK_QUICK_WAKEUP },\n\t\t{ 0x0D, ETP_PRODUCT_ID_WHITEBOX, ETP_QUIRK_QUICK_WAKEUP },\n\t\t{ 0x10, ETP_PRODUCT_ID_VOXEL, ETP_QUIRK_QUICK_WAKEUP },\n\t\t{ 0x14, ETP_PRODUCT_ID_MAGPIE, ETP_QUIRK_QUICK_WAKEUP },\n\t\t{ 0x14, ETP_PRODUCT_ID_BOBBA, ETP_QUIRK_QUICK_WAKEUP },\n\t};\n\tu32 quirks = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(elan_i2c_quirks); i++) {\n\t\tif (elan_i2c_quirks[i].ic_type == ic_type &&\n\t\t    elan_i2c_quirks[i].product_id == product_id) {\n\t\t\tquirks = elan_i2c_quirks[i].quirks;\n\t\t}\n\t}\n\n\tif (ic_type >= 0x0D && product_id >= 0x123)\n\t\tquirks |= ETP_QUIRK_QUICK_WAKEUP;\n\n\treturn quirks;\n}\n\nstatic int elan_get_fwinfo(u16 ic_type, u8 iap_version, u16 *validpage_count,\n\t\t\t   u32 *signature_address, u16 *page_size)\n{\n\tswitch (ic_type) {\n\tcase 0x00:\n\tcase 0x06:\n\tcase 0x08:\n\t\t*validpage_count = 512;\n\t\tbreak;\n\tcase 0x03:\n\tcase 0x07:\n\tcase 0x09:\n\tcase 0x0A:\n\tcase 0x0B:\n\tcase 0x0C:\n\t\t*validpage_count = 768;\n\t\tbreak;\n\tcase 0x0D:\n\t\t*validpage_count = 896;\n\t\tbreak;\n\tcase 0x0E:\n\t\t*validpage_count = 640;\n\t\tbreak;\n\tcase 0x10:\n\t\t*validpage_count = 1024;\n\t\tbreak;\n\tcase 0x11:\n\t\t*validpage_count = 1280;\n\t\tbreak;\n\tcase 0x13:\n\t\t*validpage_count = 2048;\n\t\tbreak;\n\tcase 0x14:\n\tcase 0x15:\n\t\t*validpage_count = 1024;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t*validpage_count = 0;\n\t\t*signature_address = 0;\n\t\t*page_size = 0;\n\t\treturn -ENXIO;\n\t}\n\n\t*signature_address =\n\t\t(*validpage_count * ETP_FW_PAGE_SIZE) - ETP_FW_SIGNATURE_SIZE;\n\n\tif ((ic_type == 0x14 || ic_type == 0x15) && iap_version >= 2) {\n\t\t*validpage_count /= 8;\n\t\t*page_size = ETP_FW_PAGE_SIZE_512;\n\t} else if (ic_type >= 0x0D && iap_version >= 1) {\n\t\t*validpage_count /= 2;\n\t\t*page_size = ETP_FW_PAGE_SIZE_128;\n\t} else {\n\t\t*page_size = ETP_FW_PAGE_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_set_power(struct elan_tp_data *data, bool on)\n{\n\tint repeat = ETP_RETRY_COUNT;\n\tint error;\n\n\tdo {\n\t\terror = data->ops->power_control(data->client, on);\n\t\tif (error >= 0)\n\t\t\treturn 0;\n\n\t\tmsleep(30);\n\t} while (--repeat > 0);\n\n\tdev_err(&data->client->dev, \"failed to set power %s: %d\\n\",\n\t\ton ? \"on\" : \"off\", error);\n\treturn error;\n}\n\nstatic int elan_sleep(struct elan_tp_data *data)\n{\n\tint repeat = ETP_RETRY_COUNT;\n\tint error;\n\n\tdo {\n\t\terror = data->ops->sleep_control(data->client, true);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\tmsleep(30);\n\t} while (--repeat > 0);\n\n\treturn error;\n}\n\nstatic int elan_query_product(struct elan_tp_data *data)\n{\n\tint error;\n\n\terror = data->ops->get_product_id(data->client, &data->product_id);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_pattern(data->client, &data->pattern);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_sm_version(data->client, data->pattern,\n\t\t\t\t\t  &data->ic_type, &data->sm_version,\n\t\t\t\t\t  &data->clickpad);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int elan_check_ASUS_special_fw(struct elan_tp_data *data)\n{\n\tif (data->ic_type == 0x0E) {\n\t\tswitch (data->product_id) {\n\t\tcase 0x05 ... 0x07:\n\t\tcase 0x09:\n\t\tcase 0x13:\n\t\t\treturn true;\n\t\t}\n\t} else if (data->ic_type == 0x08 && data->product_id == 0x26) {\n\t\t \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int __elan_initialize(struct elan_tp_data *data, bool skip_reset)\n{\n\tstruct i2c_client *client = data->client;\n\tbool woken_up = false;\n\tint error;\n\n\tif (!skip_reset) {\n\t\terror = data->ops->initialize(client);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"device initialize failed: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = elan_query_product(data);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (elan_check_ASUS_special_fw(data)) {\n\t\terror = data->ops->sleep_control(client, false);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to wake device up: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tmsleep(200);\n\t\twoken_up = true;\n\t}\n\n\tdata->mode |= ETP_ENABLE_ABS;\n\terror = data->ops->set_mode(client, data->mode);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to switch to absolute mode: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (!woken_up) {\n\t\terror = data->ops->sleep_control(client, false);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to wake device up: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_initialize(struct elan_tp_data *data, bool skip_reset)\n{\n\tint repeat = ETP_RETRY_COUNT;\n\tint error;\n\n\tdo {\n\t\terror = __elan_initialize(data, skip_reset);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\tskip_reset = false;\n\t\tmsleep(30);\n\t} while (--repeat > 0);\n\n\treturn error;\n}\n\nstatic int elan_query_device_info(struct elan_tp_data *data)\n{\n\tint error;\n\n\terror = data->ops->get_version(data->client, data->pattern, false,\n\t\t\t\t       &data->fw_version);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_checksum(data->client, false,\n\t\t\t\t\t&data->fw_checksum);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_version(data->client, data->pattern,\n\t\t\t\t       true, &data->iap_version);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_pressure_adjustment(data->client,\n\t\t\t\t\t\t   &data->pressure_adjustment);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_report_features(data->client, data->pattern,\n\t\t\t\t\t       &data->report_features,\n\t\t\t\t\t       &data->report_len);\n\tif (error)\n\t\treturn error;\n\n\tdata->quirks = elan_i2c_lookup_quirks(data->ic_type, data->product_id);\n\n\terror = elan_get_fwinfo(data->ic_type, data->iap_version,\n\t\t\t\t&data->fw_validpage_count,\n\t\t\t\t&data->fw_signature_address,\n\t\t\t\t&data->fw_page_size);\n\tif (error)\n\t\tdev_warn(&data->client->dev,\n\t\t\t \"unexpected iap version %#04x (ic type: %#04x), firmware update will not work\\n\",\n\t\t\t data->iap_version, data->ic_type);\n\n\treturn 0;\n}\n\nstatic unsigned int elan_convert_resolution(u8 val, u8 pattern)\n{\n\t \n\tint res = pattern <= 0x01 ?\n\t\t(int)(char)val * 10 + 790 : ((int)(char)val + 3) * 100;\n\t \n\treturn res * 10 / 254;\n}\n\nstatic int elan_query_device_parameters(struct elan_tp_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tunsigned int x_traces, y_traces;\n\tu32 x_mm, y_mm;\n\tu8 hw_x_res, hw_y_res;\n\tint error;\n\n\tif (device_property_read_u32(&client->dev,\n\t\t\t\t     \"touchscreen-size-x\", &data->max_x) ||\n\t    device_property_read_u32(&client->dev,\n\t\t\t\t     \"touchscreen-size-y\", &data->max_y)) {\n\t\terror = data->ops->get_max(data->client,\n\t\t\t\t\t   &data->max_x,\n\t\t\t\t\t   &data->max_y);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\t \n\t\t--data->max_x;\n\t\t--data->max_y;\n\t}\n\n\tif (device_property_read_u32(&client->dev,\n\t\t\t\t     \"elan,x_traces\",\n\t\t\t\t     &x_traces) ||\n\t    device_property_read_u32(&client->dev,\n\t\t\t\t     \"elan,y_traces\",\n\t\t\t\t     &y_traces)) {\n\t\terror = data->ops->get_num_traces(data->client,\n\t\t\t\t\t\t  &x_traces, &y_traces);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tdata->width_x = data->max_x / x_traces;\n\tdata->width_y = data->max_y / y_traces;\n\n\tif (device_property_read_u32(&client->dev,\n\t\t\t\t     \"touchscreen-x-mm\", &x_mm) ||\n\t    device_property_read_u32(&client->dev,\n\t\t\t\t     \"touchscreen-y-mm\", &y_mm)) {\n\t\terror = data->ops->get_resolution(data->client,\n\t\t\t\t\t\t  &hw_x_res, &hw_y_res);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdata->x_res = elan_convert_resolution(hw_x_res, data->pattern);\n\t\tdata->y_res = elan_convert_resolution(hw_y_res, data->pattern);\n\t} else {\n\t\tdata->x_res = (data->max_x + 1) / x_mm;\n\t\tdata->y_res = (data->max_y + 1) / y_mm;\n\t}\n\n\tif (device_property_read_bool(&client->dev, \"elan,clickpad\"))\n\t\tdata->clickpad = 1;\n\n\tif (device_property_read_bool(&client->dev, \"elan,middle-button\"))\n\t\tdata->middle_button = true;\n\n\treturn 0;\n}\n\n \nstatic int elan_write_fw_block(struct elan_tp_data *data, u16 page_size,\n\t\t\t       const u8 *page, u16 checksum, int idx)\n{\n\tint retry = ETP_RETRY_COUNT;\n\tint error;\n\n\tdo {\n\t\terror = data->ops->write_fw_block(data->client, page_size,\n\t\t\t\t\t\t  page, checksum, idx);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\tdev_dbg(&data->client->dev,\n\t\t\t\"IAP retrying page %d (error: %d)\\n\", idx, error);\n\t} while (--retry > 0);\n\n\treturn error;\n}\n\nstatic int __elan_update_firmware(struct elan_tp_data *data,\n\t\t\t\t  const struct firmware *fw)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct device *dev = &client->dev;\n\tint i, j;\n\tint error;\n\tu16 iap_start_addr;\n\tu16 boot_page_count;\n\tu16 sw_checksum = 0, fw_checksum = 0;\n\n\terror = data->ops->prepare_fw_update(client, data->ic_type,\n\t\t\t\t\t     data->iap_version,\n\t\t\t\t\t     data->fw_page_size);\n\tif (error)\n\t\treturn error;\n\n\tiap_start_addr = get_unaligned_le16(&fw->data[ETP_IAP_START_ADDR * 2]);\n\n\tboot_page_count = (iap_start_addr * 2) / data->fw_page_size;\n\tfor (i = boot_page_count; i < data->fw_validpage_count; i++) {\n\t\tu16 checksum = 0;\n\t\tconst u8 *page = &fw->data[i * data->fw_page_size];\n\n\t\tfor (j = 0; j < data->fw_page_size; j += 2)\n\t\t\tchecksum += ((page[j + 1] << 8) | page[j]);\n\n\t\terror = elan_write_fw_block(data, data->fw_page_size,\n\t\t\t\t\t    page, checksum, i);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"write page %d fail: %d\\n\", i, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tsw_checksum += checksum;\n\t}\n\n\t \n\tmsleep(600);\n\n\terror = data->ops->finish_fw_update(client, &data->fw_completion);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->get_checksum(client, true, &fw_checksum);\n\tif (error)\n\t\treturn error;\n\n\tif (sw_checksum != fw_checksum) {\n\t\tdev_err(dev, \"checksum diff sw=[%04X], fw=[%04X]\\n\",\n\t\t\tsw_checksum, fw_checksum);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_update_firmware(struct elan_tp_data *data,\n\t\t\t\tconst struct firmware *fw)\n{\n\tstruct i2c_client *client = data->client;\n\tint retval;\n\n\tdev_dbg(&client->dev, \"Starting firmware update....\\n\");\n\n\tdisable_irq(client->irq);\n\tdata->in_fw_update = true;\n\n\tretval = __elan_update_firmware(data, fw);\n\tif (retval) {\n\t\tdev_err(&client->dev, \"firmware update failed: %d\\n\", retval);\n\t\tdata->ops->iap_reset(client);\n\t} else {\n\t\t \n\t\telan_initialize(data, false);\n\t\telan_query_device_info(data);\n\t}\n\n\tdata->in_fw_update = false;\n\tenable_irq(client->irq);\n\n\treturn retval;\n}\n\n \nstatic ssize_t elan_sysfs_read_fw_checksum(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"0x%04x\\n\", data->fw_checksum);\n}\n\nstatic ssize_t elan_sysfs_read_product_id(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, ETP_PRODUCT_ID_FORMAT_STRING \"\\n\",\n\t\t       data->product_id);\n}\n\nstatic ssize_t elan_sysfs_read_fw_ver(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d.0\\n\", data->fw_version);\n}\n\nstatic ssize_t elan_sysfs_read_sm_ver(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d.0\\n\", data->sm_version);\n}\n\nstatic ssize_t elan_sysfs_read_iap_ver(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d.0\\n\", data->iap_version);\n}\n\nstatic ssize_t elan_sysfs_update_fw(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct elan_tp_data *data = dev_get_drvdata(dev);\n\tconst struct firmware *fw;\n\tchar *fw_name;\n\tint error;\n\tconst u8 *fw_signature;\n\tstatic const u8 signature[] = {0xAA, 0x55, 0xCC, 0x33, 0xFF, 0xFF};\n\n\tif (data->fw_validpage_count == 0)\n\t\treturn -EINVAL;\n\n\t \n\tfw_name = kasprintf(GFP_KERNEL, ETP_FW_NAME, data->product_id);\n\tif (!fw_name) {\n\t\tdev_err(dev, \"failed to allocate memory for firmware name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_info(dev, \"requesting fw '%s'\\n\", fw_name);\n\terror = request_firmware(&fw, fw_name, dev);\n\tkfree(fw_name);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request firmware: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tfw_signature = &fw->data[data->fw_signature_address];\n\tif (memcmp(fw_signature, signature, sizeof(signature)) != 0) {\n\t\tdev_err(dev, \"signature mismatch (expected %*ph, got %*ph)\\n\",\n\t\t\t(int)sizeof(signature), signature,\n\t\t\t(int)sizeof(signature), fw_signature);\n\t\terror = -EBADF;\n\t\tgoto out_release_fw;\n\t}\n\n\terror = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (error)\n\t\tgoto out_release_fw;\n\n\terror = elan_update_firmware(data, fw);\n\n\tmutex_unlock(&data->sysfs_mutex);\n\nout_release_fw:\n\trelease_firmware(fw);\n\treturn error ?: count;\n}\n\nstatic ssize_t calibrate_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint tries = 20;\n\tint retval;\n\tint error;\n\tu8 val[ETP_CALIBRATE_MAX_LEN];\n\n\tretval = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tdisable_irq(client->irq);\n\n\tdata->mode |= ETP_ENABLE_CALIBRATE;\n\tretval = data->ops->set_mode(client, data->mode);\n\tif (retval) {\n\t\tdev_err(dev, \"failed to enable calibration mode: %d\\n\",\n\t\t\tretval);\n\t\tgoto out;\n\t}\n\n\tretval = data->ops->calibrate(client);\n\tif (retval) {\n\t\tdev_err(dev, \"failed to start calibration: %d\\n\",\n\t\t\tretval);\n\t\tgoto out_disable_calibrate;\n\t}\n\n\tval[0] = 0xff;\n\tdo {\n\t\t \n\t\tmsleep(250);\n\n\t\tretval = data->ops->calibrate_result(client, val);\n\t\tif (retval)\n\t\t\tdev_err(dev, \"failed to check calibration result: %d\\n\",\n\t\t\t\tretval);\n\t\telse if (val[0] == 0)\n\t\t\tbreak;  \n\n\t} while (--tries);\n\n\tif (tries == 0) {\n\t\tdev_err(dev, \"failed to calibrate. Timeout.\\n\");\n\t\tretval = -ETIMEDOUT;\n\t}\n\nout_disable_calibrate:\n\tdata->mode &= ~ETP_ENABLE_CALIBRATE;\n\terror = data->ops->set_mode(data->client, data->mode);\n\tif (error) {\n\t\tdev_err(dev, \"failed to disable calibration mode: %d\\n\",\n\t\t\terror);\n\t\tif (!retval)\n\t\t\tretval = error;\n\t}\nout:\n\tenable_irq(client->irq);\n\tmutex_unlock(&data->sysfs_mutex);\n\treturn retval ?: count;\n}\n\nstatic ssize_t elan_sysfs_read_mode(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint error;\n\tenum tp_mode mode;\n\n\terror = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (error)\n\t\treturn error;\n\n\terror = data->ops->iap_get_mode(data->client, &mode);\n\n\tmutex_unlock(&data->sysfs_mutex);\n\n\tif (error)\n\t\treturn error;\n\n\treturn sprintf(buf, \"%d\\n\", (int)mode);\n}\n\nstatic DEVICE_ATTR(product_id, S_IRUGO, elan_sysfs_read_product_id, NULL);\nstatic DEVICE_ATTR(firmware_version, S_IRUGO, elan_sysfs_read_fw_ver, NULL);\nstatic DEVICE_ATTR(sample_version, S_IRUGO, elan_sysfs_read_sm_ver, NULL);\nstatic DEVICE_ATTR(iap_version, S_IRUGO, elan_sysfs_read_iap_ver, NULL);\nstatic DEVICE_ATTR(fw_checksum, S_IRUGO, elan_sysfs_read_fw_checksum, NULL);\nstatic DEVICE_ATTR(mode, S_IRUGO, elan_sysfs_read_mode, NULL);\nstatic DEVICE_ATTR(update_fw, S_IWUSR, NULL, elan_sysfs_update_fw);\n\nstatic DEVICE_ATTR_WO(calibrate);\n\nstatic struct attribute *elan_sysfs_entries[] = {\n\t&dev_attr_product_id.attr,\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_sample_version.attr,\n\t&dev_attr_iap_version.attr,\n\t&dev_attr_fw_checksum.attr,\n\t&dev_attr_calibrate.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_update_fw.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group elan_sysfs_group = {\n\t.attrs = elan_sysfs_entries,\n};\n\nstatic ssize_t acquire_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint error;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tdisable_irq(client->irq);\n\n\tdata->baseline_ready = false;\n\n\tdata->mode |= ETP_ENABLE_CALIBRATE;\n\tretval = data->ops->set_mode(data->client, data->mode);\n\tif (retval) {\n\t\tdev_err(dev, \"Failed to enable calibration mode to get baseline: %d\\n\",\n\t\t\tretval);\n\t\tgoto out;\n\t}\n\n\tmsleep(250);\n\n\tretval = data->ops->get_baseline_data(data->client, true,\n\t\t\t\t\t      &data->max_baseline);\n\tif (retval) {\n\t\tdev_err(dev, \"Failed to read max baseline form device: %d\\n\",\n\t\t\tretval);\n\t\tgoto out_disable_calibrate;\n\t}\n\n\tretval = data->ops->get_baseline_data(data->client, false,\n\t\t\t\t\t      &data->min_baseline);\n\tif (retval) {\n\t\tdev_err(dev, \"Failed to read min baseline form device: %d\\n\",\n\t\t\tretval);\n\t\tgoto out_disable_calibrate;\n\t}\n\n\tdata->baseline_ready = true;\n\nout_disable_calibrate:\n\tdata->mode &= ~ETP_ENABLE_CALIBRATE;\n\terror = data->ops->set_mode(data->client, data->mode);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to disable calibration mode after acquiring baseline: %d\\n\",\n\t\t\terror);\n\t\tif (!retval)\n\t\t\tretval = error;\n\t}\nout:\n\tenable_irq(client->irq);\n\tmutex_unlock(&data->sysfs_mutex);\n\treturn retval ?: count;\n}\n\nstatic ssize_t min_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!data->baseline_ready) {\n\t\tretval = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tretval = snprintf(buf, PAGE_SIZE, \"%d\", data->min_baseline);\n\nout:\n\tmutex_unlock(&data->sysfs_mutex);\n\treturn retval;\n}\n\nstatic ssize_t max_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!data->baseline_ready) {\n\t\tretval = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tretval = snprintf(buf, PAGE_SIZE, \"%d\", data->max_baseline);\n\nout:\n\tmutex_unlock(&data->sysfs_mutex);\n\treturn retval;\n}\n\n\nstatic DEVICE_ATTR_WO(acquire);\nstatic DEVICE_ATTR_RO(min);\nstatic DEVICE_ATTR_RO(max);\n\nstatic struct attribute *elan_baseline_sysfs_entries[] = {\n\t&dev_attr_acquire.attr,\n\t&dev_attr_min.attr,\n\t&dev_attr_max.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group elan_baseline_sysfs_group = {\n\t.name = \"baseline\",\n\t.attrs = elan_baseline_sysfs_entries,\n};\n\nstatic const struct attribute_group *elan_sysfs_groups[] = {\n\t&elan_sysfs_group,\n\t&elan_baseline_sysfs_group,\n\tNULL\n};\n\n \nstatic void elan_report_contact(struct elan_tp_data *data, int contact_num,\n\t\t\t\tbool contact_valid, bool high_precision,\n\t\t\t\tu8 *packet, u8 *finger_data)\n{\n\tstruct input_dev *input = data->input;\n\tunsigned int pos_x, pos_y;\n\tunsigned int pressure, scaled_pressure;\n\n\tif (contact_valid) {\n\t\tif (high_precision) {\n\t\t\tpos_x = get_unaligned_be16(&finger_data[0]);\n\t\t\tpos_y = get_unaligned_be16(&finger_data[2]);\n\t\t} else {\n\t\t\tpos_x = ((finger_data[0] & 0xf0) << 4) | finger_data[1];\n\t\t\tpos_y = ((finger_data[0] & 0x0f) << 8) | finger_data[2];\n\t\t}\n\n\t\tif (pos_x > data->max_x || pos_y > data->max_y) {\n\t\t\tdev_dbg(input->dev.parent,\n\t\t\t\t\"[%d] x=%d y=%d over max (%d, %d)\",\n\t\t\t\tcontact_num, pos_x, pos_y,\n\t\t\t\tdata->max_x, data->max_y);\n\t\t\treturn;\n\t\t}\n\n\t\tpressure = finger_data[4];\n\t\tscaled_pressure = pressure + data->pressure_adjustment;\n\t\tif (scaled_pressure > ETP_MAX_PRESSURE)\n\t\t\tscaled_pressure = ETP_MAX_PRESSURE;\n\n\t\tinput_mt_slot(input, contact_num);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, pos_x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, data->max_y - pos_y);\n\t\tinput_report_abs(input, ABS_MT_PRESSURE, scaled_pressure);\n\n\t\tif (data->report_features & ETP_FEATURE_REPORT_MK) {\n\t\t\tunsigned int mk_x, mk_y, area_x, area_y;\n\t\t\tu8 mk_data = high_precision ?\n\t\t\t\tpacket[ETP_MK_DATA_OFFSET + contact_num] :\n\t\t\t\tfinger_data[3];\n\n\t\t\tmk_x = mk_data & 0x0f;\n\t\t\tmk_y = mk_data >> 4;\n\n\t\t\t \n\t\t\tarea_x = mk_x * (data->width_x - ETP_FWIDTH_REDUCE);\n\t\t\tarea_y = mk_y * (data->width_y - ETP_FWIDTH_REDUCE);\n\n\t\t\tinput_report_abs(input, ABS_TOOL_WIDTH, mk_x);\n\t\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t\t max(area_x, area_y));\n\t\t\tinput_report_abs(input, ABS_MT_TOUCH_MINOR,\n\t\t\t\t\t min(area_x, area_y));\n\t\t}\n\t} else {\n\t\tinput_mt_slot(input, contact_num);\n\t\tinput_mt_report_slot_inactive(input);\n\t}\n}\n\nstatic void elan_report_absolute(struct elan_tp_data *data, u8 *packet,\n\t\t\t\t bool high_precision)\n{\n\tstruct input_dev *input = data->input;\n\tu8 *finger_data = &packet[ETP_FINGER_DATA_OFFSET];\n\tint i;\n\tu8 tp_info = packet[ETP_TOUCH_INFO_OFFSET];\n\tu8 hover_info = packet[ETP_HOVER_INFO_OFFSET];\n\tbool contact_valid, hover_event;\n\n\tpm_wakeup_event(&data->client->dev, 0);\n\n\thover_event = hover_info & BIT(6);\n\n\tfor (i = 0; i < ETP_MAX_FINGERS; i++) {\n\t\tcontact_valid = tp_info & BIT(3 + i);\n\t\telan_report_contact(data, i, contact_valid, high_precision,\n\t\t\t\t    packet, finger_data);\n\t\tif (contact_valid)\n\t\t\tfinger_data += ETP_FINGER_DATA_LEN;\n\t}\n\n\tinput_report_key(input, BTN_LEFT,   tp_info & BIT(0));\n\tinput_report_key(input, BTN_MIDDLE, tp_info & BIT(2));\n\tinput_report_key(input, BTN_RIGHT,  tp_info & BIT(1));\n\tinput_report_abs(input, ABS_DISTANCE, hover_event != 0);\n\tinput_mt_report_pointer_emulation(input, true);\n\tinput_sync(input);\n}\n\nstatic void elan_report_trackpoint(struct elan_tp_data *data, u8 *report)\n{\n\tstruct input_dev *input = data->tp_input;\n\tu8 *packet = &report[ETP_REPORT_ID_OFFSET + 1];\n\tint x, y;\n\n\tpm_wakeup_event(&data->client->dev, 0);\n\n\tif (!data->tp_input) {\n\t\tdev_warn_once(&data->client->dev,\n\t\t\t      \"received a trackpoint report while no trackpoint device has been created. Please report upstream.\\n\");\n\t\treturn;\n\t}\n\n\tinput_report_key(input, BTN_LEFT, packet[0] & 0x01);\n\tinput_report_key(input, BTN_RIGHT, packet[0] & 0x02);\n\tinput_report_key(input, BTN_MIDDLE, packet[0] & 0x04);\n\n\tif ((packet[3] & 0x0F) == 0x06) {\n\t\tx = packet[4] - (int)((packet[1] ^ 0x80) << 1);\n\t\ty = (int)((packet[2] ^ 0x80) << 1) - packet[5];\n\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t}\n\n\tinput_sync(input);\n}\n\nstatic irqreturn_t elan_isr(int irq, void *dev_id)\n{\n\tstruct elan_tp_data *data = dev_id;\n\tint error;\n\tu8 report[ETP_MAX_REPORT_LEN];\n\n\t \n\tif (data->in_fw_update) {\n\t\tcomplete(&data->fw_completion);\n\t\tgoto out;\n\t}\n\n\terror = data->ops->get_report(data->client, report, data->report_len);\n\tif (error)\n\t\tgoto out;\n\n\tswitch (report[ETP_REPORT_ID_OFFSET]) {\n\tcase ETP_REPORT_ID:\n\t\telan_report_absolute(data, report, false);\n\t\tbreak;\n\tcase ETP_REPORT_ID2:\n\t\telan_report_absolute(data, report, true);\n\t\tbreak;\n\tcase ETP_TP_REPORT_ID:\n\tcase ETP_TP_REPORT_ID2:\n\t\telan_report_trackpoint(data, report);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&data->client->dev, \"invalid report id data (%x)\\n\",\n\t\t\treport[ETP_REPORT_ID_OFFSET]);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int elan_setup_trackpoint_input_device(struct elan_tp_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Elan TrackPoint\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = ELAN_VENDOR_ID;\n\tinput->id.product = data->product_id;\n\tinput_set_drvdata(input, data);\n\n\tinput_set_capability(input, EV_REL, REL_X);\n\tinput_set_capability(input, EV_REL, REL_Y);\n\tinput_set_capability(input, EV_KEY, BTN_LEFT);\n\tinput_set_capability(input, EV_KEY, BTN_RIGHT);\n\tinput_set_capability(input, EV_KEY, BTN_MIDDLE);\n\n\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\t__set_bit(INPUT_PROP_POINTING_STICK, input->propbit);\n\n\tdata->tp_input = input;\n\n\treturn 0;\n}\n\nstatic int elan_setup_input_device(struct elan_tp_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct input_dev *input;\n\tunsigned int max_width = max(data->width_x, data->width_y);\n\tunsigned int min_width = min(data->width_x, data->width_y);\n\tint error;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Elan Touchpad\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = ELAN_VENDOR_ID;\n\tinput->id.product = data->product_id;\n\tinput_set_drvdata(input, data);\n\n\terror = input_mt_init_slots(input, ETP_MAX_FINGERS,\n\t\t\t\t    INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t__set_bit(EV_ABS, input->evbit);\n\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\tif (data->clickpad) {\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\t} else {\n\t\t__set_bit(BTN_RIGHT, input->keybit);\n\t\tif (data->middle_button)\n\t\t\t__set_bit(BTN_MIDDLE, input->keybit);\n\t}\n\t__set_bit(BTN_LEFT, input->keybit);\n\n\t \n\tinput_set_abs_params(input, ABS_X, 0, data->max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, data->max_y, 0, 0);\n\tinput_abs_set_res(input, ABS_X, data->x_res);\n\tinput_abs_set_res(input, ABS_Y, data->y_res);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, ETP_MAX_PRESSURE, 0, 0);\n\tif (data->report_features & ETP_FEATURE_REPORT_MK)\n\t\tinput_set_abs_params(input, ABS_TOOL_WIDTH,\n\t\t\t\t     0, ETP_FINGER_WIDTH, 0, 0);\n\tinput_set_abs_params(input, ABS_DISTANCE, 0, 1, 0, 0);\n\n\t \n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, data->max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, data->max_y, 0, 0);\n\tinput_abs_set_res(input, ABS_MT_POSITION_X, data->x_res);\n\tinput_abs_set_res(input, ABS_MT_POSITION_Y, data->y_res);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0,\n\t\t\t     ETP_MAX_PRESSURE, 0, 0);\n\tif (data->report_features & ETP_FEATURE_REPORT_MK) {\n\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t     0, ETP_FINGER_WIDTH * max_width, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MINOR,\n\t\t\t\t     0, ETP_FINGER_WIDTH * min_width, 0, 0);\n\t}\n\n\tdata->input = input;\n\n\treturn 0;\n}\n\nstatic void elan_disable_regulator(void *_data)\n{\n\tstruct elan_tp_data *data = _data;\n\n\tregulator_disable(data->vcc);\n}\n\nstatic int elan_probe(struct i2c_client *client)\n{\n\tconst struct elan_transport_ops *transport_ops;\n\tstruct device *dev = &client->dev;\n\tstruct elan_tp_data *data;\n\tunsigned long irqflags;\n\tint error;\n\n\tif (IS_ENABLED(CONFIG_MOUSE_ELAN_I2C_I2C) &&\n\t    i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\ttransport_ops = &elan_i2c_ops;\n\t} else if (IS_ENABLED(CONFIG_MOUSE_ELAN_I2C_SMBUS) &&\n\t\t   i2c_check_functionality(client->adapter,\n\t\t\t\t\t   I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\t\tI2C_FUNC_SMBUS_BLOCK_DATA |\n\t\t\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\ttransport_ops = &elan_smbus_ops;\n\t} else {\n\t\tdev_err(dev, \"not a supported I2C/SMBus adapter\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(struct elan_tp_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\n\tdata->ops = transport_ops;\n\tdata->client = client;\n\tinit_completion(&data->fw_completion);\n\tmutex_init(&data->sysfs_mutex);\n\n\tdata->vcc = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(data->vcc))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->vcc), \"Failed to get 'vcc' regulator\\n\");\n\n\terror = regulator_enable(data->vcc);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to enable regulator: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, elan_disable_regulator, data);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to add disable regulator action: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\terror = i2c_smbus_read_byte(client);\n\tif (error < 0) {\n\t\tdev_dbg(&client->dev, \"nothing at this address: %d\\n\", error);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\terror = elan_initialize(data, false);\n\tif (error)\n\t\treturn error;\n\n\terror = elan_query_device_info(data);\n\tif (error)\n\t\treturn error;\n\n\terror = elan_query_device_parameters(data);\n\tif (error)\n\t\treturn error;\n\n\tdev_info(dev,\n\t\t \"Elan Touchpad: Module ID: 0x%04x, Firmware: 0x%04x, Sample: 0x%04x, IAP: 0x%04x\\n\",\n\t\t data->product_id,\n\t\t data->fw_version,\n\t\t data->sm_version,\n\t\t data->iap_version);\n\n\tdev_dbg(dev,\n\t\t\"Elan Touchpad Extra Information:\\n\"\n\t\t\"    Max ABS X,Y:   %d,%d\\n\"\n\t\t\"    Width X,Y:   %d,%d\\n\"\n\t\t\"    Resolution X,Y:   %d,%d (dots/mm)\\n\"\n\t\t\"    ic type: 0x%x\\n\"\n\t\t\"    info pattern: 0x%x\\n\",\n\t\tdata->max_x, data->max_y,\n\t\tdata->width_x, data->width_y,\n\t\tdata->x_res, data->y_res,\n\t\tdata->ic_type, data->pattern);\n\n\t \n\terror = elan_setup_input_device(data);\n\tif (error)\n\t\treturn error;\n\n\tif (device_property_read_bool(&client->dev, \"elan,trackpoint\")) {\n\t\terror = elan_setup_trackpoint_input_device(data);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tirqflags = irq_get_trigger_type(client->irq);\n\tif (!irqflags)\n\t\tirqflags = IRQF_TRIGGER_FALLING;\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, elan_isr,\n\t\t\t\t\t  irqflags | IRQF_ONESHOT,\n\t\t\t\t\t  client->name, data);\n\tif (error) {\n\t\tdev_err(dev, \"cannot register irq=%d\\n\", client->irq);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(data->input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (data->tp_input) {\n\t\terror = input_register_device(data->tp_input);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to register TrackPoint input device: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint ret;\n\n\t \n\tret = mutex_lock_interruptible(&data->sysfs_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tdisable_irq(client->irq);\n\n\tif (device_may_wakeup(dev)) {\n\t\tret = elan_sleep(data);\n\t} else {\n\t\tret = elan_set_power(data, false);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regulator_disable(data->vcc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error %d disabling regulator\\n\", ret);\n\t\t\t \n\t\t\telan_set_power(data, true);\n\t\t}\n\t}\n\nerr:\n\tmutex_unlock(&data->sysfs_mutex);\n\treturn ret;\n}\n\nstatic int elan_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elan_tp_data *data = i2c_get_clientdata(client);\n\tint error;\n\n\tif (!device_may_wakeup(dev)) {\n\t\terror = regulator_enable(data->vcc);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"error %d enabling regulator\\n\", error);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\terror = elan_set_power(data, true);\n\tif (error) {\n\t\tdev_err(dev, \"power up when resuming failed: %d\\n\", error);\n\t\tgoto err;\n\t}\n\n\terror = elan_initialize(data, data->quirks & ETP_QUIRK_QUICK_WAKEUP);\n\tif (error)\n\t\tdev_err(dev, \"initialize when resuming failed: %d\\n\", error);\n\nerr:\n\tenable_irq(data->client->irq);\n\treturn error;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(elan_pm_ops, elan_suspend, elan_resume);\n\nstatic const struct i2c_device_id elan_id[] = {\n\t{ DRIVER_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, elan_id);\n\n#ifdef CONFIG_ACPI\n#include <linux/input/elan-i2c-ids.h>\nMODULE_DEVICE_TABLE(acpi, elan_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id elan_of_match[] = {\n\t{ .compatible = \"elan,ekth3000\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, elan_of_match);\n#endif\n\nstatic struct i2c_driver elan_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= pm_sleep_ptr(&elan_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(elan_acpi_id),\n\t\t.of_match_table = of_match_ptr(elan_of_match),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.dev_groups = elan_sysfs_groups,\n\t},\n\t.probe\t\t= elan_probe,\n\t.id_table\t= elan_id,\n};\n\nmodule_i2c_driver(elan_driver);\n\nMODULE_AUTHOR(\"Duson Lin <dusonlin@emc.com.tw>\");\nMODULE_DESCRIPTION(\"Elan I2C/SMBus Touchpad driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}