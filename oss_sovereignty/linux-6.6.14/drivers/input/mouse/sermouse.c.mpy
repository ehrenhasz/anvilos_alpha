{
  "module_name": "sermouse.c",
  "hash_id": "8f77daaa201c6e35584b4970688cb3938fdcbabba27d4ef26dda3fe816de236f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/sermouse.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"Serial mouse driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char *sermouse_protocols[] = { \"None\", \"Mouse Systems Mouse\", \"Sun Mouse\", \"Microsoft Mouse\",\n\t\t\t\t\t\"Logitech M+ Mouse\", \"Microsoft MZ Mouse\", \"Logitech MZ+ Mouse\",\n\t\t\t\t\t\"Logitech MZ++ Mouse\"};\n\nstruct sermouse {\n\tstruct input_dev *dev;\n\tsigned char buf[8];\n\tunsigned char count;\n\tunsigned char type;\n\tunsigned long last;\n\tchar phys[32];\n};\n\n \n\nstatic void sermouse_process_msc(struct sermouse *sermouse, signed char data)\n{\n\tstruct input_dev *dev = sermouse->dev;\n\tsigned char *buf = sermouse->buf;\n\n\tswitch (sermouse->count) {\n\n\t\tcase 0:\n\t\t\tif ((data & 0xf8) != 0x80)\n\t\t\t\treturn;\n\t\t\tinput_report_key(dev, BTN_LEFT,   !(data & 4));\n\t\t\tinput_report_key(dev, BTN_RIGHT,  !(data & 1));\n\t\t\tinput_report_key(dev, BTN_MIDDLE, !(data & 2));\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\tcase 3:\n\t\t\tinput_report_rel(dev, REL_X, data / 2);\n\t\t\tinput_report_rel(dev, REL_Y, -buf[1]);\n\t\t\tbuf[0] = data - data / 2;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\tcase 4:\n\t\t\tinput_report_rel(dev, REL_X, buf[0]);\n\t\t\tinput_report_rel(dev, REL_Y, buf[1] - data);\n\t\t\tbuf[1] = data / 2;\n\t\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n\n\tif (++sermouse->count == 5)\n\t\tsermouse->count = 0;\n}\n\n \n\nstatic void sermouse_process_ms(struct sermouse *sermouse, signed char data)\n{\n\tstruct input_dev *dev = sermouse->dev;\n\tsigned char *buf = sermouse->buf;\n\n\tif (data & 0x40)\n\t\tsermouse->count = 0;\n\telse if (sermouse->count == 0)\n\t\treturn;\n\n\tswitch (sermouse->count) {\n\n\t\tcase 0:\n\t\t\tbuf[1] = data;\n\t\t\tinput_report_key(dev, BTN_LEFT,   (data >> 5) & 1);\n\t\t\tinput_report_key(dev, BTN_RIGHT,  (data >> 4) & 1);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tbuf[2] = data;\n\t\t\tdata = (signed char) (((buf[1] << 6) & 0xc0) | (data & 0x3f));\n\t\t\tinput_report_rel(dev, REL_X, data / 2);\n\t\t\tinput_report_rel(dev, REL_Y, buf[4]);\n\t\t\tbuf[3] = data - data / 2;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t \n\t\t\tif ((sermouse->type == SERIO_MS) && !data && !buf[2] && !((buf[0] & 0xf0) ^ buf[1]))\n\t\t\t\tinput_report_key(dev, BTN_MIDDLE, !test_bit(BTN_MIDDLE, dev->key));\n\t\t\tbuf[0] = buf[1];\n\n\t\t\tdata = (signed char) (((buf[1] << 4) & 0xc0) | (data & 0x3f));\n\t\t\tinput_report_rel(dev, REL_X, buf[3]);\n\t\t\tinput_report_rel(dev, REL_Y, data - buf[4]);\n\t\t\tbuf[4] = data / 2;\n\t\t\tbreak;\n\n\t\tcase 3:\n\n\t\t\tswitch (sermouse->type) {\n\n\t\t\t\tcase SERIO_MS:\n\t\t\t\t\tsermouse->type = SERIO_MP;\n\t\t\t\t\tfallthrough;\n\n\t\t\t\tcase SERIO_MP:\n\t\t\t\t\tif ((data >> 2) & 3) break;\t \n\t\t\t\t\tinput_report_key(dev, BTN_MIDDLE, (data >> 5) & 1);\n\t\t\t\t\tinput_report_key(dev, BTN_SIDE,   (data >> 4) & 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SERIO_MZP:\n\t\t\t\tcase SERIO_MZPP:\n\t\t\t\t\tinput_report_key(dev, BTN_SIDE,   (data >> 5) & 1);\n\t\t\t\t\tfallthrough;\n\n\t\t\t\tcase SERIO_MZ:\n\t\t\t\t\tinput_report_key(dev, BTN_MIDDLE, (data >> 4) & 1);\n\t\t\t\t\tinput_report_rel(dev, REL_WHEEL,  (data & 8) - (data & 7));\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\tcase 6:\t \n\t\t\tbuf[1] = (data >> 2) & 0x0f;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\tcase 7:  \n\t\t\tif (sermouse->type != SERIO_MZPP)\n\t\t\t\tbreak;\n\n\t\t\tswitch (buf[1]) {\n\n\t\t\t\tcase 1:  \n\n\t\t\t\t\tinput_report_key(dev, BTN_SIDE, (data >> 4) & 1);\n\t\t\t\t\tinput_report_key(dev, BTN_EXTRA, (data >> 5) & 1);\n\t\t\t\t\tinput_report_rel(dev, data & 0x80 ? REL_HWHEEL : REL_WHEEL, (data & 7) - (data & 8));\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:  \n\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\t\"sermouse.c: Received MZ++ packet %x, don't know how to handle.\\n\", buf[1]);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n\n\tsermouse->count++;\n}\n\n \n\nstatic irqreturn_t sermouse_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sermouse *sermouse = serio_get_drvdata(serio);\n\n\tif (time_after(jiffies, sermouse->last + HZ/10))\n\t\tsermouse->count = 0;\n\n\tsermouse->last = jiffies;\n\n\tif (sermouse->type > SERIO_SUN)\n\t\tsermouse_process_ms(sermouse, data);\n\telse\n\t\tsermouse_process_msc(sermouse, data);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void sermouse_disconnect(struct serio *serio)\n{\n\tstruct sermouse *sermouse = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(sermouse->dev);\n\tkfree(sermouse);\n}\n\n \n\nstatic int sermouse_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct sermouse *sermouse;\n\tstruct input_dev *input_dev;\n\tunsigned char c = serio->id.extra;\n\tint err = -ENOMEM;\n\n\tsermouse = kzalloc(sizeof(struct sermouse), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!sermouse || !input_dev)\n\t\tgoto fail1;\n\n\tsermouse->dev = input_dev;\n\tsnprintf(sermouse->phys, sizeof(sermouse->phys), \"%s/input0\", serio->phys);\n\tsermouse->type = serio->id.proto;\n\n\tinput_dev->name = sermouse_protocols[sermouse->type];\n\tinput_dev->phys = sermouse->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor  = sermouse->type;\n\tinput_dev->id.product = c;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\tinput_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n\t\tBIT_MASK(BTN_RIGHT);\n\tinput_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\n\tif (c & 0x01) set_bit(BTN_MIDDLE, input_dev->keybit);\n\tif (c & 0x02) set_bit(BTN_SIDE, input_dev->keybit);\n\tif (c & 0x04) set_bit(BTN_EXTRA, input_dev->keybit);\n\tif (c & 0x10) set_bit(REL_WHEEL, input_dev->relbit);\n\tif (c & 0x20) set_bit(REL_HWHEEL, input_dev->relbit);\n\n\tserio_set_drvdata(serio, sermouse);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(sermouse->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(sermouse);\n\treturn err;\n}\n\nstatic struct serio_device_id sermouse_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MSC,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_SUN,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MS,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MP,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MZ,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MZP,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MZPP,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, sermouse_serio_ids);\n\nstatic struct serio_driver sermouse_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"sermouse\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= sermouse_serio_ids,\n\t.interrupt\t= sermouse_interrupt,\n\t.connect\t= sermouse_connect,\n\t.disconnect\t= sermouse_disconnect,\n};\n\nmodule_serio_driver(sermouse_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}