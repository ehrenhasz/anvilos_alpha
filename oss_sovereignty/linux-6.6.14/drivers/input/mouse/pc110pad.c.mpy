{
  "module_name": "pc110pad.c",
  "hash_id": "06507484533f00cfd1d0ed148b17289c5015abcc9638043af00cb0ba992bffd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/pc110pad.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/input.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"IBM PC110 touchpad driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define PC110PAD_OFF\t0x30\n#define PC110PAD_ON\t0x38\n\nstatic int pc110pad_irq = 10;\nstatic int pc110pad_io = 0x15e0;\n\nstatic struct input_dev *pc110pad_dev;\nstatic int pc110pad_data[3];\nstatic int pc110pad_count;\n\nstatic irqreturn_t pc110pad_interrupt(int irq, void *ptr)\n{\n\tint value     = inb_p(pc110pad_io);\n\tint handshake = inb_p(pc110pad_io + 2);\n\n\toutb(handshake |  1, pc110pad_io + 2);\n\tudelay(2);\n\toutb(handshake & ~1, pc110pad_io + 2);\n\tudelay(2);\n\tinb_p(0x64);\n\n\tpc110pad_data[pc110pad_count++] = value;\n\n\tif (pc110pad_count < 3)\n\t\treturn IRQ_HANDLED;\n\n\tinput_report_key(pc110pad_dev, BTN_TOUCH,\n\t\tpc110pad_data[0] & 0x01);\n\tinput_report_abs(pc110pad_dev, ABS_X,\n\t\tpc110pad_data[1] | ((pc110pad_data[0] << 3) & 0x80) | ((pc110pad_data[0] << 1) & 0x100));\n\tinput_report_abs(pc110pad_dev, ABS_Y,\n\t\tpc110pad_data[2] | ((pc110pad_data[0] << 4) & 0x80));\n\tinput_sync(pc110pad_dev);\n\n\tpc110pad_count = 0;\n\treturn IRQ_HANDLED;\n}\n\nstatic void pc110pad_close(struct input_dev *dev)\n{\n\toutb(PC110PAD_OFF, pc110pad_io + 2);\n}\n\nstatic int pc110pad_open(struct input_dev *dev)\n{\n\tpc110pad_interrupt(0, NULL);\n\tpc110pad_interrupt(0, NULL);\n\tpc110pad_interrupt(0, NULL);\n\toutb(PC110PAD_ON, pc110pad_io + 2);\n\tpc110pad_count = 0;\n\n\treturn 0;\n}\n\n \nstatic int __init pc110pad_init(void)\n{\n\tint err;\n\n\tif (!no_pci_devices())\n\t\treturn -ENODEV;\n\n\tif (!request_region(pc110pad_io, 4, \"pc110pad\")) {\n\t\tprintk(KERN_ERR \"pc110pad: I/O area %#x-%#x in use.\\n\",\n\t\t\t\tpc110pad_io, pc110pad_io + 4);\n\t\treturn -EBUSY;\n\t}\n\n\toutb(PC110PAD_OFF, pc110pad_io + 2);\n\n\tif (request_irq(pc110pad_irq, pc110pad_interrupt, 0, \"pc110pad\", NULL)) {\n\t\tprintk(KERN_ERR \"pc110pad: Unable to get irq %d.\\n\", pc110pad_irq);\n\t\terr = -EBUSY;\n\t\tgoto err_release_region;\n\t}\n\n\tpc110pad_dev = input_allocate_device();\n\tif (!pc110pad_dev) {\n\t\tprintk(KERN_ERR \"pc110pad: Not enough memory.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tpc110pad_dev->name = \"IBM PC110 TouchPad\";\n\tpc110pad_dev->phys = \"isa15e0/input0\";\n\tpc110pad_dev->id.bustype = BUS_ISA;\n\tpc110pad_dev->id.vendor = 0x0003;\n\tpc110pad_dev->id.product = 0x0001;\n\tpc110pad_dev->id.version = 0x0100;\n\n\tpc110pad_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tpc110pad_dev->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y);\n\tpc110pad_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tinput_abs_set_max(pc110pad_dev, ABS_X, 0x1ff);\n\tinput_abs_set_max(pc110pad_dev, ABS_Y, 0x0ff);\n\n\tpc110pad_dev->open = pc110pad_open;\n\tpc110pad_dev->close = pc110pad_close;\n\n\terr = input_register_device(pc110pad_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(pc110pad_dev);\n err_free_irq:\n\tfree_irq(pc110pad_irq, NULL);\n err_release_region:\n\trelease_region(pc110pad_io, 4);\n\n\treturn err;\n}\n\nstatic void __exit pc110pad_exit(void)\n{\n\toutb(PC110PAD_OFF, pc110pad_io + 2);\n\tfree_irq(pc110pad_irq, NULL);\n\tinput_unregister_device(pc110pad_dev);\n\trelease_region(pc110pad_io, 4);\n}\n\nmodule_init(pc110pad_init);\nmodule_exit(pc110pad_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}