{
  "module_name": "hgpk.c",
  "hash_id": "ce0864de4e884c74766fe88f2def4fc8996e3ac24a01dd3c79dc265c48c84441",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/hgpk.c",
  "human_readable_source": "\n \n\n \n\n#define DEBUG\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <linux/delay.h>\n#include <asm/olpc.h>\n\n#include \"psmouse.h\"\n#include \"hgpk.h\"\n\n#define ILLEGAL_XY 999999\n\nstatic bool tpdebug;\nmodule_param(tpdebug, bool, 0644);\nMODULE_PARM_DESC(tpdebug, \"enable debugging, dumping packets to KERN_DEBUG.\");\n\nstatic int recalib_delta = 100;\nmodule_param(recalib_delta, int, 0644);\nMODULE_PARM_DESC(recalib_delta,\n\t\"packets containing a delta this large will be discarded, and a \"\n\t\"recalibration may be scheduled.\");\n\nstatic int jumpy_delay = 20;\nmodule_param(jumpy_delay, int, 0644);\nMODULE_PARM_DESC(jumpy_delay,\n\t\"delay (ms) before recal after jumpiness detected\");\n\nstatic int spew_delay = 1;\nmodule_param(spew_delay, int, 0644);\nMODULE_PARM_DESC(spew_delay,\n\t\"delay (ms) before recal after packet spew detected\");\n\nstatic int recal_guard_time;\nmodule_param(recal_guard_time, int, 0644);\nMODULE_PARM_DESC(recal_guard_time,\n\t\"interval (ms) during which recal will be restarted if packet received\");\n\nstatic int post_interrupt_delay = 40;\nmodule_param(post_interrupt_delay, int, 0644);\nMODULE_PARM_DESC(post_interrupt_delay,\n\t\"delay (ms) before recal after recal interrupt detected\");\n\nstatic bool autorecal = true;\nmodule_param(autorecal, bool, 0644);\nMODULE_PARM_DESC(autorecal, \"enable recalibration in the driver\");\n\nstatic char hgpk_mode_name[16];\nmodule_param_string(hgpk_mode, hgpk_mode_name, sizeof(hgpk_mode_name), 0644);\nMODULE_PARM_DESC(hgpk_mode,\n\t\"default hgpk mode: mouse, glidesensor or pentablet\");\n\nstatic int hgpk_default_mode = HGPK_MODE_MOUSE;\n\nstatic const char * const hgpk_mode_names[] = {\n\t[HGPK_MODE_MOUSE] = \"Mouse\",\n\t[HGPK_MODE_GLIDESENSOR] = \"GlideSensor\",\n\t[HGPK_MODE_PENTABLET] = \"PenTablet\",\n};\n\nstatic int hgpk_mode_from_name(const char *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hgpk_mode_names); i++) {\n\t\tconst char *name = hgpk_mode_names[i];\n\t\tif (strlen(name) == len && !strncasecmp(name, buf, len))\n\t\t\treturn i;\n\t}\n\n\treturn HGPK_MODE_INVALID;\n}\n\n \nstatic int approx_half(int curr, int prev)\n{\n\tint belowhalf, abovehalf;\n\n\tif (curr < 5 || prev < 5)\n\t\treturn 0;\n\n\tbelowhalf = (prev * 8) / 20;\n\tabovehalf = (prev * 12) / 20;\n\n\treturn belowhalf < curr && curr <= abovehalf;\n}\n\n \nstatic int hgpk_discard_decay_hack(struct psmouse *psmouse, int x, int y)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tint avx, avy;\n\tbool do_recal = false;\n\n\tavx = abs(x);\n\tavy = abs(y);\n\n\t \n\tif (avx > recalib_delta ||\n\t\t(avx > recalib_delta / 2 && ((avx / 4) > priv->xlast))) {\n\t\tpsmouse_warn(psmouse, \"detected %dpx jump in x\\n\", x);\n\t\tpriv->xbigj = avx;\n\t} else if (approx_half(avx, priv->xbigj)) {\n\t\tpsmouse_warn(psmouse, \"detected secondary %dpx jump in x\\n\", x);\n\t\tpriv->xbigj = avx;\n\t\tpriv->xsaw_secondary++;\n\t} else {\n\t\tif (priv->xbigj && priv->xsaw_secondary > 1)\n\t\t\tdo_recal = true;\n\t\tpriv->xbigj = 0;\n\t\tpriv->xsaw_secondary = 0;\n\t}\n\n\tif (avy > recalib_delta ||\n\t\t(avy > recalib_delta / 2 && ((avy / 4) > priv->ylast))) {\n\t\tpsmouse_warn(psmouse, \"detected %dpx jump in y\\n\", y);\n\t\tpriv->ybigj = avy;\n\t} else if (approx_half(avy, priv->ybigj)) {\n\t\tpsmouse_warn(psmouse, \"detected secondary %dpx jump in y\\n\", y);\n\t\tpriv->ybigj = avy;\n\t\tpriv->ysaw_secondary++;\n\t} else {\n\t\tif (priv->ybigj && priv->ysaw_secondary > 1)\n\t\t\tdo_recal = true;\n\t\tpriv->ybigj = 0;\n\t\tpriv->ysaw_secondary = 0;\n\t}\n\n\tpriv->xlast = avx;\n\tpriv->ylast = avy;\n\n\tif (do_recal && jumpy_delay) {\n\t\tpsmouse_warn(psmouse, \"scheduling recalibration\\n\");\n\t\tpsmouse_queue_work(psmouse, &priv->recalib_wq,\n\t\t\t\tmsecs_to_jiffies(jumpy_delay));\n\t}\n\n\treturn priv->xbigj || priv->ybigj;\n}\n\nstatic void hgpk_reset_spew_detection(struct hgpk_data *priv)\n{\n\tpriv->spew_count = 0;\n\tpriv->dupe_count = 0;\n\tpriv->x_tally = 0;\n\tpriv->y_tally = 0;\n\tpriv->spew_flag = NO_SPEW;\n}\n\nstatic void hgpk_reset_hack_state(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\tpriv->abs_x = priv->abs_y = -1;\n\tpriv->xlast = priv->ylast = ILLEGAL_XY;\n\tpriv->xbigj = priv->ybigj = 0;\n\tpriv->xsaw_secondary = priv->ysaw_secondary = 0;\n\thgpk_reset_spew_detection(priv);\n}\n\n \nstatic void hgpk_spewing_hack(struct psmouse *psmouse,\n\t\t\t      int l, int r, int x, int y)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\t \n\tif (l || r)\n\t\treturn;\n\n\t \n\tif (!spew_delay)\n\t\treturn;\n\n\tif (abs(x) > 3 || abs(y) > 3) {\n\t\t \n\t\thgpk_reset_spew_detection(priv);\n\t\treturn;\n\t}\n\n\t \n\tpriv->x_tally += x;\n\tpriv->y_tally += y;\n\n\tswitch (priv->spew_flag) {\n\tcase NO_SPEW:\n\t\t \n\t\tpriv->spew_flag = MAYBE_SPEWING;\n\n\t\tfallthrough;\n\n\tcase MAYBE_SPEWING:\n\t\tpriv->spew_count++;\n\n\t\tif (priv->spew_count < SPEW_WATCH_COUNT)\n\t\t\tbreak;\n\n\t\t \n\t\tpriv->spew_flag = SPEW_DETECTED;\n\n\t\tfallthrough;\n\n\tcase SPEW_DETECTED:\n\t\t \n\t\tif (abs(priv->x_tally) < 3 && abs(priv->y_tally) < 3) {\n\t\t\tpsmouse_warn(psmouse, \"packet spew detected (%d,%d)\\n\",\n\t\t\t\t     priv->x_tally, priv->y_tally);\n\t\t\tpriv->spew_flag = RECALIBRATING;\n\t\t\tpsmouse_queue_work(psmouse, &priv->recalib_wq,\n\t\t\t\t\t   msecs_to_jiffies(spew_delay));\n\t\t}\n\n\t\tbreak;\n\tcase RECALIBRATING:\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic bool hgpk_is_byte_valid(struct psmouse *psmouse, unsigned char *packet)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tint pktcnt = psmouse->pktcnt;\n\tbool valid;\n\n\tswitch (priv->mode) {\n\tcase HGPK_MODE_MOUSE:\n\t\tvalid = (packet[0] & 0x0C) == 0x08;\n\t\tbreak;\n\n\tcase HGPK_MODE_GLIDESENSOR:\n\t\tvalid = pktcnt == 1 ?\n\t\t\tpacket[0] == HGPK_GS : !(packet[pktcnt - 1] & 0x80);\n\t\tbreak;\n\n\tcase HGPK_MODE_PENTABLET:\n\t\tvalid = pktcnt == 1 ?\n\t\t\tpacket[0] == HGPK_PT : !(packet[pktcnt - 1] & 0x80);\n\t\tbreak;\n\n\tdefault:\n\t\tvalid = false;\n\t\tbreak;\n\t}\n\n\tif (!valid)\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"bad data, mode %d (%d) %*ph\\n\",\n\t\t\t    priv->mode, pktcnt, 6, psmouse->packet);\n\n\treturn valid;\n}\n\nstatic void hgpk_process_advanced_packet(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tstruct input_dev *idev = psmouse->dev;\n\tunsigned char *packet = psmouse->packet;\n\tint down = !!(packet[2] & 2);\n\tint left = !!(packet[3] & 1);\n\tint right = !!(packet[3] & 2);\n\tint x = packet[1] | ((packet[2] & 0x78) << 4);\n\tint y = packet[4] | ((packet[3] & 0x70) << 3);\n\n\tif (priv->mode == HGPK_MODE_GLIDESENSOR) {\n\t\tint pt_down = !!(packet[2] & 1);\n\t\tint finger_down = !!(packet[2] & 2);\n\t\tint z = packet[5];\n\n\t\tinput_report_abs(idev, ABS_PRESSURE, z);\n\t\tif (tpdebug)\n\t\t\tpsmouse_dbg(psmouse, \"pd=%d fd=%d z=%d\",\n\t\t\t\t    pt_down, finger_down, z);\n\t} else {\n\t\t \n\t\tif (tpdebug)\n\t\t\tpsmouse_dbg(psmouse, \"pd=%d \", down);\n\t}\n\n\tif (tpdebug)\n\t\tpsmouse_dbg(psmouse, \"l=%d r=%d x=%d y=%d\\n\",\n\t\t\t    left, right, x, y);\n\n\tinput_report_key(idev, BTN_TOUCH, down);\n\tinput_report_key(idev, BTN_LEFT, left);\n\tinput_report_key(idev, BTN_RIGHT, right);\n\n\t \n\tif (!down) {\n\t\thgpk_reset_hack_state(psmouse);\n\t\tgoto done;\n\t}\n\n\t \n\tif (x == priv->abs_x && y == priv->abs_y) {\n\t\tif (++priv->dupe_count > SPEW_WATCH_COUNT) {\n\t\t\tif (tpdebug)\n\t\t\t\tpsmouse_dbg(psmouse, \"hard spew detected\\n\");\n\t\t\tpriv->spew_flag = RECALIBRATING;\n\t\t\tpsmouse_queue_work(psmouse, &priv->recalib_wq,\n\t\t\t\t\t   msecs_to_jiffies(spew_delay));\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tpriv->dupe_count = 0;\n\n\t \n\tif (priv->mode != HGPK_MODE_PENTABLET && priv->abs_x != -1) {\n\t\tint x_diff = priv->abs_x - x;\n\t\tint y_diff = priv->abs_y - y;\n\t\tif (hgpk_discard_decay_hack(psmouse, x_diff, y_diff)) {\n\t\t\tif (tpdebug)\n\t\t\t\tpsmouse_dbg(psmouse, \"discarding\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\thgpk_spewing_hack(psmouse, left, right, x_diff, y_diff);\n\t}\n\n\tinput_report_abs(idev, ABS_X, x);\n\tinput_report_abs(idev, ABS_Y, y);\n\tpriv->abs_x = x;\n\tpriv->abs_y = y;\n\ndone:\n\tinput_sync(idev);\n}\n\nstatic void hgpk_process_simple_packet(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tunsigned char *packet = psmouse->packet;\n\tint left = packet[0] & 1;\n\tint right = (packet[0] >> 1) & 1;\n\tint x = packet[1] - ((packet[0] << 4) & 0x100);\n\tint y = ((packet[0] << 3) & 0x100) - packet[2];\n\n\tif (packet[0] & 0xc0)\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"overflow -- 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\t    packet[0], packet[1], packet[2]);\n\n\tif (hgpk_discard_decay_hack(psmouse, x, y)) {\n\t\tif (tpdebug)\n\t\t\tpsmouse_dbg(psmouse, \"discarding\\n\");\n\t\treturn;\n\t}\n\n\thgpk_spewing_hack(psmouse, left, right, x, y);\n\n\tif (tpdebug)\n\t\tpsmouse_dbg(psmouse, \"l=%d r=%d x=%d y=%d\\n\",\n\t\t\t    left, right, x, y);\n\n\tinput_report_key(dev, BTN_LEFT, left);\n\tinput_report_key(dev, BTN_RIGHT, right);\n\n\tinput_report_rel(dev, REL_X, x);\n\tinput_report_rel(dev, REL_Y, y);\n\n\tinput_sync(dev);\n}\n\nstatic psmouse_ret_t hgpk_process_byte(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\tif (!hgpk_is_byte_valid(psmouse, psmouse->packet))\n\t\treturn PSMOUSE_BAD_DATA;\n\n\tif (psmouse->pktcnt >= psmouse->pktsize) {\n\t\tif (priv->mode == HGPK_MODE_MOUSE)\n\t\t\thgpk_process_simple_packet(psmouse);\n\t\telse\n\t\t\thgpk_process_advanced_packet(psmouse);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\tif (priv->recalib_window) {\n\t\tif (time_before(jiffies, priv->recalib_window)) {\n\t\t\t \n\t\t\tpsmouse_dbg(psmouse,\n\t\t\t\t    \"packet inside calibration window, queueing another recalibration\\n\");\n\t\t\tpsmouse_queue_work(psmouse, &priv->recalib_wq,\n\t\t\t\t\tmsecs_to_jiffies(post_interrupt_delay));\n\t\t}\n\t\tpriv->recalib_window = 0;\n\t}\n\n\treturn PSMOUSE_GOOD_DATA;\n}\n\nstatic int hgpk_select_mode(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tstruct hgpk_data *priv = psmouse->private;\n\tint i;\n\tint cmd;\n\n\t \n\tconst int advanced_init[] = {\n\t\tPSMOUSE_CMD_DISABLE, PSMOUSE_CMD_DISABLE,\n\t\tPSMOUSE_CMD_DISABLE, PSMOUSE_CMD_DISABLE,\n\t\t0xf2, 0xf2, 0xf2,\n\t};\n\n\tswitch (priv->mode) {\n\tcase HGPK_MODE_MOUSE:\n\t\tpsmouse->pktsize = 3;\n\t\tbreak;\n\n\tcase HGPK_MODE_GLIDESENSOR:\n\tcase HGPK_MODE_PENTABLET:\n\t\tpsmouse->pktsize = 6;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(advanced_init); i++)\n\t\t\tif (ps2_command(ps2dev, NULL, advanced_init[i]))\n\t\t\t\treturn -EIO;\n\n\t\t \n\t\tcmd = priv->mode == HGPK_MODE_GLIDESENSOR ?\n\t\t\tPSMOUSE_CMD_SETSCALE11 : PSMOUSE_CMD_SETSCALE21;\n\n\t\tif (ps2_command(ps2dev, NULL, cmd))\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hgpk_setup_input_device(struct input_dev *input,\n\t\t\t\t    struct input_dev *old_input,\n\t\t\t\t    enum hgpk_mode mode)\n{\n\tif (old_input) {\n\t\tinput->name = old_input->name;\n\t\tinput->phys = old_input->phys;\n\t\tinput->id = old_input->id;\n\t\tinput->dev.parent = old_input->dev.parent;\n\t}\n\n\tmemset(input->evbit, 0, sizeof(input->evbit));\n\tmemset(input->relbit, 0, sizeof(input->relbit));\n\tmemset(input->keybit, 0, sizeof(input->keybit));\n\n\t \n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(BTN_LEFT, input->keybit);\n\t__set_bit(BTN_RIGHT, input->keybit);\n\n\tswitch (mode) {\n\tcase HGPK_MODE_MOUSE:\n\t\t__set_bit(EV_REL, input->evbit);\n\t\t__set_bit(REL_X, input->relbit);\n\t\t__set_bit(REL_Y, input->relbit);\n\t\tbreak;\n\n\tcase HGPK_MODE_GLIDESENSOR:\n\t\t__set_bit(BTN_TOUCH, input->keybit);\n\t\t__set_bit(BTN_TOOL_FINGER, input->keybit);\n\n\t\t__set_bit(EV_ABS, input->evbit);\n\n\t\t \n\t\tinput_set_abs_params(input, ABS_PRESSURE, 0, 15, 0, 0);\n\n\t\t \n\t\tinput_set_abs_params(input, ABS_X, 0, 399, 0, 0);\n\t\tinput_set_abs_params(input, ABS_Y, 0, 290, 0, 0);\n\n\t\t \n\t\tinput_abs_set_res(input, ABS_X, 8);\n\t\tinput_abs_set_res(input, ABS_Y, 8);\n\t\tbreak;\n\n\tcase HGPK_MODE_PENTABLET:\n\t\t__set_bit(BTN_TOUCH, input->keybit);\n\t\t__set_bit(BTN_TOOL_FINGER, input->keybit);\n\n\t\t__set_bit(EV_ABS, input->evbit);\n\n\t\t \n\t\tinput_set_abs_params(input, ABS_X, 0, 999, 0, 0);\n\t\tinput_set_abs_params(input, ABS_Y, 5, 239, 0, 0);\n\n\t\t \n\t\tinput_abs_set_res(input, ABS_X, 6);\n\t\tinput_abs_set_res(input, ABS_Y, 8);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int hgpk_reset_device(struct psmouse *psmouse, bool recalibrate)\n{\n\tint err;\n\n\tpsmouse_reset(psmouse);\n\n\tif (recalibrate) {\n\t\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\t\t \n\t\tif (ps2_command(ps2dev, NULL, 0xf5) ||\n\t\t    ps2_command(ps2dev, NULL, 0xf5) ||\n\t\t    ps2_command(ps2dev, NULL, 0xe6) ||\n\t\t    ps2_command(ps2dev, NULL, 0xf5)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tmsleep(150);\n\t}\n\n\terr = hgpk_select_mode(psmouse);\n\tif (err) {\n\t\tpsmouse_err(psmouse, \"failed to select mode\\n\");\n\t\treturn err;\n\t}\n\n\thgpk_reset_hack_state(psmouse);\n\n\treturn 0;\n}\n\nstatic int hgpk_force_recalibrate(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tint err;\n\n\t \n\tif (psmouse->model < HGPK_MODEL_C)\n\t\treturn 0;\n\n\tif (!autorecal) {\n\t\tpsmouse_dbg(psmouse, \"recalibration disabled, ignoring\\n\");\n\t\treturn 0;\n\t}\n\n\tpsmouse_dbg(psmouse, \"recalibrating touchpad..\\n\");\n\n\t \n\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\t \n\terr = hgpk_reset_device(psmouse, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (psmouse_activate(psmouse))\n\t\treturn -1;\n\n\tif (tpdebug)\n\t\tpsmouse_dbg(psmouse, \"touchpad reactivated\\n\");\n\n\t \n\tif (recal_guard_time)\n\t\tpriv->recalib_window = jiffies +\n\t\t\tmsecs_to_jiffies(recal_guard_time);\n\n\treturn 0;\n}\n\n \nstatic int hgpk_toggle_powersave(struct psmouse *psmouse, int enable)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint timeo;\n\tint err;\n\n\t \n\tif (psmouse->model < HGPK_MODEL_D)\n\t\treturn 0;\n\n\tif (enable) {\n\t\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\t\t \n\t\tfor (timeo = 20; timeo > 0; timeo--) {\n\t\t\tif (!ps2_sendbyte(ps2dev, PSMOUSE_CMD_DISABLE, 20))\n\t\t\t\tbreak;\n\t\t\tmsleep(25);\n\t\t}\n\n\t\terr = hgpk_reset_device(psmouse, false);\n\t\tif (err) {\n\t\t\tpsmouse_err(psmouse, \"Failed to reset device!\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tpsmouse_activate(psmouse);\n\t\tpsmouse_dbg(psmouse, \"Touchpad powered up.\\n\");\n\t} else {\n\t\tpsmouse_dbg(psmouse, \"Powering off touchpad.\\n\");\n\n\t\tif (ps2_command(ps2dev, NULL, 0xec) ||\n\t\t    ps2_command(ps2dev, NULL, 0xec) ||\n\t\t    ps2_command(ps2dev, NULL, 0xea)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tpsmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\n\t\t \n\t\tps2_sendbyte(ps2dev, 0xec, 20);\n\t}\n\n\treturn 0;\n}\n\nstatic int hgpk_poll(struct psmouse *psmouse)\n{\n\t \n\treturn -1;\n}\n\nstatic int hgpk_reconnect(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\t \n\tif (olpc_board_at_least(olpc_board(0xb2)))\n\t\tif (psmouse->ps2dev.serio->dev.power.power_state.event !=\n\t\t\t\tPM_EVENT_ON)\n\t\t\treturn 0;\n\n\tpriv->powered = 1;\n\treturn hgpk_reset_device(psmouse, false);\n}\n\nstatic ssize_t hgpk_show_powered(struct psmouse *psmouse, void *data, char *buf)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\treturn sprintf(buf, \"%d\\n\", priv->powered);\n}\n\nstatic ssize_t hgpk_set_powered(struct psmouse *psmouse, void *data,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value != priv->powered) {\n\t\t \n\t\terr = hgpk_toggle_powersave(psmouse, value);\n\t\tif (!err)\n\t\t\tpriv->powered = value;\n\t}\n\n\treturn err ? err : count;\n}\n\n__PSMOUSE_DEFINE_ATTR(powered, S_IWUSR | S_IRUGO, NULL,\n\t\t      hgpk_show_powered, hgpk_set_powered, false);\n\nstatic ssize_t attr_show_mode(struct psmouse *psmouse, void *data, char *buf)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\treturn sprintf(buf, \"%s\\n\", hgpk_mode_names[priv->mode]);\n}\n\nstatic ssize_t attr_set_mode(struct psmouse *psmouse, void *data,\n\t\t\t     const char *buf, size_t len)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tenum hgpk_mode old_mode = priv->mode;\n\tenum hgpk_mode new_mode = hgpk_mode_from_name(buf, len);\n\tstruct input_dev *old_dev = psmouse->dev;\n\tstruct input_dev *new_dev;\n\tint err;\n\n\tif (new_mode == HGPK_MODE_INVALID)\n\t\treturn -EINVAL;\n\n\tif (old_mode == new_mode)\n\t\treturn len;\n\n\tnew_dev = input_allocate_device();\n\tif (!new_dev)\n\t\treturn -ENOMEM;\n\n\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\t \n\tpriv->mode = new_mode;\n\terr = hgpk_reset_device(psmouse, false);\n\tif (err)\n\t\tgoto err_try_restore;\n\n\thgpk_setup_input_device(new_dev, old_dev, new_mode);\n\n\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\n\terr = input_register_device(new_dev);\n\tif (err)\n\t\tgoto err_try_restore;\n\n\tpsmouse->dev = new_dev;\n\tinput_unregister_device(old_dev);\n\n\treturn len;\n\nerr_try_restore:\n\tinput_free_device(new_dev);\n\tpriv->mode = old_mode;\n\thgpk_reset_device(psmouse, false);\n\n\treturn err;\n}\n\nPSMOUSE_DEFINE_ATTR(hgpk_mode, S_IWUSR | S_IRUGO, NULL,\n\t\t    attr_show_mode, attr_set_mode);\n\nstatic ssize_t hgpk_trigger_recal_show(struct psmouse *psmouse,\n\t\tvoid *data, char *buf)\n{\n\treturn -EINVAL;\n}\n\nstatic ssize_t hgpk_trigger_recal(struct psmouse *psmouse, void *data,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value != 1)\n\t\treturn -EINVAL;\n\n\t \n\tpsmouse_queue_work(psmouse, &priv->recalib_wq, 0);\n\treturn count;\n}\n\n__PSMOUSE_DEFINE_ATTR(recalibrate, S_IWUSR | S_IRUGO, NULL,\n\t\t      hgpk_trigger_recal_show, hgpk_trigger_recal, false);\n\nstatic void hgpk_disconnect(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\n\tdevice_remove_file(&psmouse->ps2dev.serio->dev,\n\t\t\t   &psmouse_attr_powered.dattr);\n\tdevice_remove_file(&psmouse->ps2dev.serio->dev,\n\t\t\t   &psmouse_attr_hgpk_mode.dattr);\n\n\tif (psmouse->model >= HGPK_MODEL_C)\n\t\tdevice_remove_file(&psmouse->ps2dev.serio->dev,\n\t\t\t\t   &psmouse_attr_recalibrate.dattr);\n\n\tpsmouse_reset(psmouse);\n\tkfree(priv);\n}\n\nstatic void hgpk_recalib_work(struct work_struct *work)\n{\n\tstruct delayed_work *w = to_delayed_work(work);\n\tstruct hgpk_data *priv = container_of(w, struct hgpk_data, recalib_wq);\n\tstruct psmouse *psmouse = priv->psmouse;\n\n\tif (hgpk_force_recalibrate(psmouse))\n\t\tpsmouse_err(psmouse, \"recalibration failed!\\n\");\n}\n\nstatic int hgpk_register(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv = psmouse->private;\n\tint err;\n\n\t \n\tpsmouse->protocol_handler = hgpk_process_byte;\n\tpsmouse->poll = hgpk_poll;\n\tpsmouse->disconnect = hgpk_disconnect;\n\tpsmouse->reconnect = hgpk_reconnect;\n\n\t \n\tpsmouse->resync_time = 0;\n\t \n\tpsmouse->resetafter = 1024;\n\n\thgpk_setup_input_device(psmouse->dev, NULL, priv->mode);\n\n\terr = device_create_file(&psmouse->ps2dev.serio->dev,\n\t\t\t\t &psmouse_attr_powered.dattr);\n\tif (err) {\n\t\tpsmouse_err(psmouse, \"Failed creating 'powered' sysfs node\\n\");\n\t\treturn err;\n\t}\n\n\terr = device_create_file(&psmouse->ps2dev.serio->dev,\n\t\t\t\t &psmouse_attr_hgpk_mode.dattr);\n\tif (err) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"Failed creating 'hgpk_mode' sysfs node\\n\");\n\t\tgoto err_remove_powered;\n\t}\n\n\t \n\tif (psmouse->model >= HGPK_MODEL_C) {\n\t\terr = device_create_file(&psmouse->ps2dev.serio->dev,\n\t\t\t\t\t &psmouse_attr_recalibrate.dattr);\n\t\tif (err) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Failed creating 'recalibrate' sysfs node\\n\");\n\t\t\tgoto err_remove_mode;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_remove_mode:\n\tdevice_remove_file(&psmouse->ps2dev.serio->dev,\n\t\t\t   &psmouse_attr_hgpk_mode.dattr);\nerr_remove_powered:\n\tdevice_remove_file(&psmouse->ps2dev.serio->dev,\n\t\t\t   &psmouse_attr_powered.dattr);\n\treturn err;\n}\n\nint hgpk_init(struct psmouse *psmouse)\n{\n\tstruct hgpk_data *priv;\n\tint err;\n\n\tpriv = kzalloc(sizeof(struct hgpk_data), GFP_KERNEL);\n\tif (!priv) {\n\t\terr = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\tpsmouse->private = priv;\n\n\tpriv->psmouse = psmouse;\n\tpriv->powered = true;\n\tpriv->mode = hgpk_default_mode;\n\tINIT_DELAYED_WORK(&priv->recalib_wq, hgpk_recalib_work);\n\n\terr = hgpk_reset_device(psmouse, false);\n\tif (err)\n\t\tgoto init_fail;\n\n\terr = hgpk_register(psmouse);\n\tif (err)\n\t\tgoto init_fail;\n\n\treturn 0;\n\ninit_fail:\n\tkfree(priv);\nalloc_fail:\n\treturn err;\n}\n\nstatic enum hgpk_model_t hgpk_get_model(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[3];\n\n\t \n\tif (ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||\n\t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||\n\t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||\n\t    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\n\t\treturn -EIO;\n\t}\n\n\tpsmouse_dbg(psmouse, \"ID: %*ph\\n\", 3, param);\n\n\t \n\tif (param[0] != 0x67 || param[1] != 0x00)\n\t\treturn -ENODEV;\n\n\tpsmouse_info(psmouse, \"OLPC touchpad revision 0x%x\\n\", param[2]);\n\n\treturn param[2];\n}\n\nint hgpk_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tint version;\n\n\tversion = hgpk_get_model(psmouse);\n\tif (version < 0)\n\t\treturn version;\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"ALPS\";\n\t\tpsmouse->name = \"HGPK\";\n\t\tpsmouse->model = version;\n\t}\n\n\treturn 0;\n}\n\nvoid hgpk_module_init(void)\n{\n\thgpk_default_mode = hgpk_mode_from_name(hgpk_mode_name,\n\t\t\t\t\t\tstrlen(hgpk_mode_name));\n\tif (hgpk_default_mode == HGPK_MODE_INVALID) {\n\t\thgpk_default_mode = HGPK_MODE_MOUSE;\n\t\tstrscpy(hgpk_mode_name, hgpk_mode_names[HGPK_MODE_MOUSE],\n\t\t\tsizeof(hgpk_mode_name));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}