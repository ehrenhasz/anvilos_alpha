{
  "module_name": "elan_i2c_smbus.c",
  "hash_id": "3ab3f8f08206b156a7994b3cd48cdf8955bcef2291e8e02c9a24a8d33c6eea5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/elan_i2c_smbus.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#include \"elan_i2c.h\"\n\n \n#define ETP_SMBUS_IAP_CMD\t\t0x00\n#define ETP_SMBUS_ENABLE_TP\t\t0x20\n#define ETP_SMBUS_SLEEP_CMD\t\t0x21\n#define ETP_SMBUS_IAP_PASSWORD_WRITE\t0x29\n#define ETP_SMBUS_IAP_PASSWORD_READ\t0x80\n#define ETP_SMBUS_WRITE_FW_BLOCK\t0x2A\n#define ETP_SMBUS_IAP_RESET_CMD\t\t0x2B\n#define ETP_SMBUS_RANGE_CMD\t\t0xA0\n#define ETP_SMBUS_FW_VERSION_CMD\t0xA1\n#define ETP_SMBUS_XY_TRACENUM_CMD\t0xA2\n#define ETP_SMBUS_SM_VERSION_CMD\t0xA3\n#define ETP_SMBUS_UNIQUEID_CMD\t\t0xA3\n#define ETP_SMBUS_RESOLUTION_CMD\t0xA4\n#define ETP_SMBUS_HELLOPACKET_CMD\t0xA7\n#define ETP_SMBUS_PACKET_QUERY\t\t0xA8\n#define ETP_SMBUS_IAP_VERSION_CMD\t0xAC\n#define ETP_SMBUS_IAP_CTRL_CMD\t\t0xAD\n#define ETP_SMBUS_IAP_CHECKSUM_CMD\t0xAE\n#define ETP_SMBUS_FW_CHECKSUM_CMD\t0xAF\n#define ETP_SMBUS_MAX_BASELINE_CMD\t0xC3\n#define ETP_SMBUS_MIN_BASELINE_CMD\t0xC4\n#define ETP_SMBUS_CALIBRATE_QUERY\t0xC5\n\n#define ETP_SMBUS_REPORT_LEN\t\t32\n#define ETP_SMBUS_REPORT_LEN2\t\t7\n#define ETP_SMBUS_REPORT_OFFSET\t\t2\n#define ETP_SMBUS_HELLOPACKET_LEN\t5\n#define ETP_SMBUS_IAP_PASSWORD\t\t0x1234\n#define ETP_SMBUS_IAP_MODE_ON\t\t(1 << 6)\n\nstatic int elan_smbus_initialize(struct i2c_client *client)\n{\n\tu8 check[ETP_SMBUS_HELLOPACKET_LEN] = { 0x55, 0x55, 0x55, 0x55, 0x55 };\n\tu8 values[I2C_SMBUS_BLOCK_MAX] = {0};\n\tint len, error;\n\n\t \n\tlen = i2c_smbus_read_block_data(client,\n\t\t\t\t\tETP_SMBUS_HELLOPACKET_CMD, values);\n\tif (len != ETP_SMBUS_HELLOPACKET_LEN) {\n\t\tdev_err(&client->dev, \"hello packet length fail: %d\\n\", len);\n\t\terror = len < 0 ? len : -EIO;\n\t\treturn error;\n\t}\n\n\t \n\tif (memcmp(values, check, ETP_SMBUS_HELLOPACKET_LEN)) {\n\t\tdev_err(&client->dev, \"hello packet fail [%*ph]\\n\",\n\t\t\tETP_SMBUS_HELLOPACKET_LEN, values);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\terror = i2c_smbus_write_byte(client, ETP_SMBUS_ENABLE_TP);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to enable touchpad: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_smbus_set_mode(struct i2c_client *client, u8 mode)\n{\n\tu8 cmd[4] = { 0x00, 0x07, 0x00, mode };\n\n\treturn i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\n\t\t\t\t\t  sizeof(cmd), cmd);\n}\n\nstatic int elan_smbus_sleep_control(struct i2c_client *client, bool sleep)\n{\n\tif (sleep)\n\t\treturn i2c_smbus_write_byte(client, ETP_SMBUS_SLEEP_CMD);\n\telse\n\t\treturn 0;  \n}\n\nstatic int elan_smbus_power_control(struct i2c_client *client, bool enable)\n{\n\treturn 0;  \n}\n\nstatic int elan_smbus_calibrate(struct i2c_client *client)\n{\n\tu8 cmd[4] = { 0x00, 0x08, 0x00, 0x01 };\n\n\treturn i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\n\t\t\t\t\t  sizeof(cmd), cmd);\n}\n\nstatic int elan_smbus_calibrate_result(struct i2c_client *client, u8 *val)\n{\n\tint error;\n\tu8 buf[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\tBUILD_BUG_ON(ETP_CALIBRATE_MAX_LEN > sizeof(buf));\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  ETP_SMBUS_CALIBRATE_QUERY, buf);\n\tif (error < 0)\n\t\treturn error;\n\n\tmemcpy(val, buf, ETP_CALIBRATE_MAX_LEN);\n\treturn 0;\n}\n\nstatic int elan_smbus_get_baseline_data(struct i2c_client *client,\n\t\t\t\t\tbool max_baseline, u8 *value)\n{\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  max_baseline ?\n\t\t\t\t\t\tETP_SMBUS_MAX_BASELINE_CMD :\n\t\t\t\t\t\tETP_SMBUS_MIN_BASELINE_CMD,\n\t\t\t\t\t  val);\n\tif (error < 0)\n\t\treturn error;\n\n\t*value = be16_to_cpup((__be16 *)val);\n\n\treturn 0;\n}\n\nstatic int elan_smbus_get_version(struct i2c_client *client,\n\t\t\t\t  u8 pattern, bool iap, u8 *version)\n{\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  iap ? ETP_SMBUS_IAP_VERSION_CMD :\n\t\t\t\t\t\tETP_SMBUS_FW_VERSION_CMD,\n\t\t\t\t\t  val);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to get %s version: %d\\n\",\n\t\t\tiap ? \"IAP\" : \"FW\", error);\n\t\treturn error;\n\t}\n\n\t*version = val[2];\n\treturn 0;\n}\n\nstatic int elan_smbus_get_sm_version(struct i2c_client *client, u8 pattern,\n\t\t\t\t     u16 *ic_type, u8 *version, u8 *clickpad)\n{\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  ETP_SMBUS_SM_VERSION_CMD, val);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to get SM version: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*version = val[0];\n\t*ic_type = val[1];\n\t*clickpad = val[0] & 0x10;\n\treturn 0;\n}\n\nstatic int elan_smbus_get_product_id(struct i2c_client *client, u16 *id)\n{\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  ETP_SMBUS_UNIQUEID_CMD, val);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to get product ID: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*id = be16_to_cpup((__be16 *)val);\n\treturn 0;\n}\n\nstatic int elan_smbus_get_checksum(struct i2c_client *client,\n\t\t\t\t   bool iap, u16 *csum)\n{\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  iap ? ETP_SMBUS_FW_CHECKSUM_CMD :\n\t\t\t\t\t\tETP_SMBUS_IAP_CHECKSUM_CMD,\n\t\t\t\t\t  val);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to get %s checksum: %d\\n\",\n\t\t\tiap ? \"IAP\" : \"FW\", error);\n\t\treturn error;\n\t}\n\n\t*csum = be16_to_cpup((__be16 *)val);\n\treturn 0;\n}\n\nstatic int elan_smbus_get_max(struct i2c_client *client,\n\t\t\t      unsigned int *max_x, unsigned int *max_y)\n{\n\tint ret;\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\tret = i2c_smbus_read_block_data(client, ETP_SMBUS_RANGE_CMD, val);\n\tif (ret != 3) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&client->dev, \"failed to get dimensions: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*max_x = (0x0f & val[0]) << 8 | val[1];\n\t*max_y = (0xf0 & val[0]) << 4 | val[2];\n\n\treturn 0;\n}\n\nstatic int elan_smbus_get_resolution(struct i2c_client *client,\n\t\t\t\t     u8 *hw_res_x, u8 *hw_res_y)\n{\n\tint ret;\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\tret = i2c_smbus_read_block_data(client, ETP_SMBUS_RESOLUTION_CMD, val);\n\tif (ret != 3) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&client->dev, \"failed to get resolution: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*hw_res_x = val[1] & 0x0F;\n\t*hw_res_y = (val[1] & 0xF0) >> 4;\n\n\treturn 0;\n}\n\nstatic int elan_smbus_get_num_traces(struct i2c_client *client,\n\t\t\t\t     unsigned int *x_traces,\n\t\t\t\t     unsigned int *y_traces)\n{\n\tint ret;\n\tint error;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\tret = i2c_smbus_read_block_data(client, ETP_SMBUS_XY_TRACENUM_CMD, val);\n\tif (ret != 3) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&client->dev, \"failed to get trace info: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*x_traces = val[1];\n\t*y_traces = val[2];\n\n\treturn 0;\n}\n\nstatic int elan_smbus_get_pressure_adjustment(struct i2c_client *client,\n\t\t\t\t\t      int *adjustment)\n{\n\t*adjustment = ETP_PRESSURE_OFFSET;\n\treturn 0;\n}\n\nstatic int elan_smbus_iap_get_mode(struct i2c_client *client,\n\t\t\t\t   enum tp_mode *mode)\n{\n\tint error;\n\tu16 constant;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\terror = i2c_smbus_read_block_data(client, ETP_SMBUS_IAP_CTRL_CMD, val);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to read iap ctrol register: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tconstant = be16_to_cpup((__be16 *)val);\n\tdev_dbg(&client->dev, \"iap control reg: 0x%04x.\\n\", constant);\n\n\t*mode = (constant & ETP_SMBUS_IAP_MODE_ON) ? IAP_MODE : MAIN_MODE;\n\n\treturn 0;\n}\n\nstatic int elan_smbus_iap_reset(struct i2c_client *client)\n{\n\tint error;\n\n\terror = i2c_smbus_write_byte(client, ETP_SMBUS_IAP_RESET_CMD);\n\tif (error) {\n\t\tdev_err(&client->dev, \"cannot reset IC: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_smbus_set_flash_key(struct i2c_client *client)\n{\n\tint error;\n\tu8 cmd[4] = { 0x00, 0x0B, 0x00, 0x5A };\n\n\terror = i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\n\t\t\t\t\t   sizeof(cmd), cmd);\n\tif (error) {\n\t\tdev_err(&client->dev, \"cannot set flash key: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_smbus_prepare_fw_update(struct i2c_client *client, u16 ic_type,\n\t\t\t\t\tu8 iap_version, u16 fw_page_size)\n{\n\tstruct device *dev = &client->dev;\n\tint len;\n\tint error;\n\tenum tp_mode mode;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\tu8 cmd[4] = {0x0F, 0x78, 0x00, 0x06};\n\tu16 password;\n\n\t \n\terror = elan_smbus_iap_get_mode(client, &mode);\n\tif (error)\n\t\treturn error;\n\n\tif (mode == MAIN_MODE) {\n\n\t\t \n\t\terror = elan_smbus_set_flash_key(client);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (i2c_smbus_write_byte(client,\n\t\t\t\t\t ETP_SMBUS_IAP_PASSWORD_WRITE) < 0) {\n\t\t\tdev_err(dev, \"cannot write iap password\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\terror = i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\n\t\t\t\t\t\t   sizeof(cmd), cmd);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to write iap password: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tlen = i2c_smbus_read_block_data(client,\n\t\t\t\t\t\tETP_SMBUS_IAP_PASSWORD_READ,\n\t\t\t\t\t\tval);\n\t\tif (len < (int)sizeof(u16)) {\n\t\t\terror = len < 0 ? len : -EIO;\n\t\t\tdev_err(dev, \"failed to read iap password: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tpassword = be16_to_cpup((__be16 *)val);\n\t\tif (password != ETP_SMBUS_IAP_PASSWORD) {\n\t\t\tdev_err(dev, \"wrong iap password = 0x%X\\n\", password);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmsleep(30);\n\t}\n\n\terror = elan_smbus_set_flash_key(client);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = elan_smbus_iap_reset(client);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\n\nstatic int elan_smbus_write_fw_block(struct i2c_client *client, u16 fw_page_size,\n\t\t\t\t     const u8 *page, u16 checksum, int idx)\n{\n\tstruct device *dev = &client->dev;\n\tint error;\n\tu16 result;\n\tu8 val[I2C_SMBUS_BLOCK_MAX] = {0};\n\n\t \n\terror = i2c_smbus_write_block_data(client,\n\t\t\t\t\t   ETP_SMBUS_WRITE_FW_BLOCK,\n\t\t\t\t\t   fw_page_size / 2,\n\t\t\t\t\t   page);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to write page %d (part %d): %d\\n\",\n\t\t\tidx, 1, error);\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_block_data(client,\n\t\t\t\t\t   ETP_SMBUS_WRITE_FW_BLOCK,\n\t\t\t\t\t   fw_page_size / 2,\n\t\t\t\t\t   page + fw_page_size / 2);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to write page %d (part %d): %d\\n\",\n\t\t\tidx, 2, error);\n\t\treturn error;\n\t}\n\n\n\t \n\tusleep_range(8000, 10000);\n\n\terror = i2c_smbus_read_block_data(client,\n\t\t\t\t\t  ETP_SMBUS_IAP_CTRL_CMD, val);\n\tif (error < 0) {\n\t\tdev_err(dev, \"Failed to read IAP write result: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tresult = be16_to_cpup((__be16 *)val);\n\tif (result & (ETP_FW_IAP_PAGE_ERR | ETP_FW_IAP_INTF_ERR)) {\n\t\tdev_err(dev, \"IAP reports failed write: %04hx\\n\",\n\t\t\tresult);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_smbus_get_report_features(struct i2c_client *client, u8 pattern,\n\t\t\t\t\t  unsigned int *features,\n\t\t\t\t\t  unsigned int *report_len)\n{\n\t \n\t*features = pattern <= 0x01 ? ETP_FEATURE_REPORT_MK : 0;\n\t*report_len = ETP_SMBUS_REPORT_LEN;\n\treturn 0;\n}\n\nstatic int elan_smbus_get_report(struct i2c_client *client,\n\t\t\t\t u8 *report, unsigned int report_len)\n{\n\tint len;\n\n\tBUILD_BUG_ON(I2C_SMBUS_BLOCK_MAX > ETP_SMBUS_REPORT_LEN);\n\n\tlen = i2c_smbus_read_block_data(client,\n\t\t\t\t\tETP_SMBUS_PACKET_QUERY,\n\t\t\t\t\t&report[ETP_SMBUS_REPORT_OFFSET]);\n\tif (len < 0) {\n\t\tdev_err(&client->dev, \"failed to read report data: %d\\n\", len);\n\t\treturn len;\n\t}\n\n\tif (report[ETP_REPORT_ID_OFFSET] == ETP_TP_REPORT_ID2)\n\t\treport_len = ETP_SMBUS_REPORT_LEN2;\n\n\tif (len != report_len) {\n\t\tdev_err(&client->dev,\n\t\t\t\"wrong report length (%d vs %d expected)\\n\",\n\t\t\tlen, report_len);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_smbus_finish_fw_update(struct i2c_client *client,\n\t\t\t\t       struct completion *fw_completion)\n{\n\t \n\treturn 0;\n}\n\nstatic int elan_smbus_get_pattern(struct i2c_client *client, u8 *pattern)\n{\n\t*pattern = 0;\n\treturn 0;\n}\n\nconst struct elan_transport_ops elan_smbus_ops = {\n\t.initialize\t\t= elan_smbus_initialize,\n\t.sleep_control\t\t= elan_smbus_sleep_control,\n\t.power_control\t\t= elan_smbus_power_control,\n\t.set_mode\t\t= elan_smbus_set_mode,\n\n\t.calibrate\t\t= elan_smbus_calibrate,\n\t.calibrate_result\t= elan_smbus_calibrate_result,\n\n\t.get_baseline_data\t= elan_smbus_get_baseline_data,\n\n\t.get_version\t\t= elan_smbus_get_version,\n\t.get_sm_version\t\t= elan_smbus_get_sm_version,\n\t.get_product_id\t\t= elan_smbus_get_product_id,\n\t.get_checksum\t\t= elan_smbus_get_checksum,\n\t.get_pressure_adjustment = elan_smbus_get_pressure_adjustment,\n\n\t.get_max\t\t= elan_smbus_get_max,\n\t.get_resolution\t\t= elan_smbus_get_resolution,\n\t.get_num_traces\t\t= elan_smbus_get_num_traces,\n\n\t.iap_get_mode\t\t= elan_smbus_iap_get_mode,\n\t.iap_reset\t\t= elan_smbus_iap_reset,\n\n\t.prepare_fw_update\t= elan_smbus_prepare_fw_update,\n\t.write_fw_block\t\t= elan_smbus_write_fw_block,\n\t.finish_fw_update\t= elan_smbus_finish_fw_update,\n\n\t.get_report_features\t= elan_smbus_get_report_features,\n\t.get_report\t\t= elan_smbus_get_report,\n\t.get_pattern\t\t= elan_smbus_get_pattern,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}