{
  "module_name": "appletouch.c",
  "hash_id": "661f90ced9ed6454c2d7c2e476867c4a5dbea6fe5899d41845be31bf63bbc49b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/appletouch.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n\n \nstruct atp_info {\n\tint xsensors;\t\t\t\t \n\tint xsensors_17;\t\t\t \n\tint ysensors;\t\t\t\t \n\tint xfact;\t\t\t\t \n\tint yfact;\t\t\t\t \n\tint datalen;\t\t\t\t \n\tvoid (*callback)(struct urb *);\t\t \n\tint fuzz;\t\t\t\t \n};\n\nstatic void atp_complete_geyser_1_2(struct urb *urb);\nstatic void atp_complete_geyser_3_4(struct urb *urb);\n\nstatic const struct atp_info fountain_info = {\n\t.xsensors\t= 16,\n\t.xsensors_17\t= 26,\n\t.ysensors\t= 16,\n\t.xfact\t\t= 64,\n\t.yfact\t\t= 43,\n\t.datalen\t= 81,\n\t.callback\t= atp_complete_geyser_1_2,\n\t.fuzz\t\t= 16,\n};\n\nstatic const struct atp_info geyser1_info = {\n\t.xsensors\t= 16,\n\t.xsensors_17\t= 26,\n\t.ysensors\t= 16,\n\t.xfact\t\t= 64,\n\t.yfact\t\t= 43,\n\t.datalen\t= 81,\n\t.callback\t= atp_complete_geyser_1_2,\n\t.fuzz\t\t= 16,\n};\n\nstatic const struct atp_info geyser2_info = {\n\t.xsensors\t= 15,\n\t.xsensors_17\t= 20,\n\t.ysensors\t= 9,\n\t.xfact\t\t= 64,\n\t.yfact\t\t= 43,\n\t.datalen\t= 64,\n\t.callback\t= atp_complete_geyser_1_2,\n\t.fuzz\t\t= 0,\n};\n\nstatic const struct atp_info geyser3_info = {\n\t.xsensors\t= 20,\n\t.ysensors\t= 10,\n\t.xfact\t\t= 64,\n\t.yfact\t\t= 64,\n\t.datalen\t= 64,\n\t.callback\t= atp_complete_geyser_3_4,\n\t.fuzz\t\t= 0,\n};\n\nstatic const struct atp_info geyser4_info = {\n\t.xsensors\t= 20,\n\t.ysensors\t= 10,\n\t.xfact\t\t= 64,\n\t.yfact\t\t= 64,\n\t.datalen\t= 64,\n\t.callback\t= atp_complete_geyser_3_4,\n\t.fuzz\t\t= 0,\n};\n\n#define ATP_DEVICE(prod, info)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE |\t\t\\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS |\t\t\\\n\t\t       USB_DEVICE_ID_MATCH_INT_PROTOCOL,\t\\\n\t.idVendor = 0x05ac,  \t\t\t\t\\\n\t.idProduct = (prod),\t\t\t\t\t\\\n\t.bInterfaceClass = 0x03,\t\t\t\t\\\n\t.bInterfaceProtocol = 0x02,\t\t\t\t\\\n\t.driver_info = (unsigned long) &info,\t\t\t\\\n}\n\n \n\nstatic const struct usb_device_id atp_table[] = {\n\t \n\tATP_DEVICE(0x020e, fountain_info),\t \n\tATP_DEVICE(0x020f, fountain_info),\t \n\tATP_DEVICE(0x030a, fountain_info),\t \n\tATP_DEVICE(0x030b, geyser1_info),\t \n\n\t \n\tATP_DEVICE(0x0214, geyser2_info),\t \n\tATP_DEVICE(0x0215, geyser2_info),\t \n\tATP_DEVICE(0x0216, geyser2_info),\t \n\n\t \n\tATP_DEVICE(0x0217, geyser3_info),\t \n\tATP_DEVICE(0x0218, geyser3_info),\t \n\tATP_DEVICE(0x0219, geyser3_info),\t \n\n\t \n\tATP_DEVICE(0x021a, geyser4_info),\t \n\tATP_DEVICE(0x021b, geyser4_info),\t \n\tATP_DEVICE(0x021c, geyser4_info),\t \n\n\t \n\tATP_DEVICE(0x0229, geyser4_info),\t \n\tATP_DEVICE(0x022a, geyser4_info),\t \n\tATP_DEVICE(0x022b, geyser4_info),\t \n\n\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, atp_table);\n\n \n#define ATP_XSENSORS\t26\n#define ATP_YSENSORS\t16\n\n \n#define ATP_SMOOTHSIZE\t34\n\n \n#define ATP_PRESSURE\t300\n\n \n#define ATP_THRESHOLD\t5\n\n \n#define ATP_SCALE\t12\n\n \n#define ATP_GEYSER_MODE_READ_REQUEST_ID\t\t1\n#define ATP_GEYSER_MODE_WRITE_REQUEST_ID\t9\n#define ATP_GEYSER_MODE_REQUEST_VALUE\t\t0x300\n#define ATP_GEYSER_MODE_REQUEST_INDEX\t\t0\n#define ATP_GEYSER_MODE_VENDOR_VALUE\t\t0x04\n\n \nenum atp_status_bits {\n\tATP_STATUS_BUTTON\t= BIT(0),\n\tATP_STATUS_BASE_UPDATE\t= BIT(2),\n\tATP_STATUS_FROM_RESET\t= BIT(4),\n};\n\n \nstruct atp {\n\tchar\t\t\tphys[64];\n\tstruct usb_device\t*udev;\t\t \n\tstruct usb_interface\t*intf;\t\t \n\tstruct urb\t\t*urb;\t\t \n\tu8\t\t\t*data;\t\t \n\tstruct input_dev\t*input;\t\t \n\tconst struct atp_info\t*info;\t\t \n\tbool\t\t\topen;\n\tbool\t\t\tvalid;\t\t \n\tbool\t\t\tsize_detect_done;\n\tbool\t\t\toverflow_warned;\n\tint\t\t\tfingers_old;\t \n\tint\t\t\tx_old;\t\t \n\tint\t\t\ty_old;\t\t \n\tsigned char\t\txy_cur[ATP_XSENSORS + ATP_YSENSORS];\n\tsigned char\t\txy_old[ATP_XSENSORS + ATP_YSENSORS];\n\tint\t\t\txy_acc[ATP_XSENSORS + ATP_YSENSORS];\n\tint\t\t\tsmooth[ATP_SMOOTHSIZE];\n\tint\t\t\tsmooth_tmp[ATP_SMOOTHSIZE];\n\tint\t\t\tidlecount;\t \n\tstruct work_struct\twork;\n};\n\n#define dbg_dump(msg, tab) \\\n\tif (debug > 1) {\t\t\t\t\t\t\\\n\t\tint __i;\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"appletouch: %s\", msg);\t\t\\\n\t\tfor (__i = 0; __i < ATP_XSENSORS + ATP_YSENSORS; __i++)\t\\\n\t\t\tprintk(\" %02x\", tab[__i]);\t\t\t\\\n\t\tprintk(\"\\n\");\t\t\t\t\t\t\\\n\t}\n\n#define dprintk(format, a...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (debug)\t\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG format, ##a);\t\t\t\\\n\t} while (0)\n\nMODULE_AUTHOR(\"Johannes Berg\");\nMODULE_AUTHOR(\"Stelian Pop\");\nMODULE_AUTHOR(\"Frank Arnold\");\nMODULE_AUTHOR(\"Michael Hanselmann\");\nMODULE_AUTHOR(\"Sven Anders\");\nMODULE_DESCRIPTION(\"Apple PowerBook and MacBook USB touchpad driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int threshold = ATP_THRESHOLD;\nmodule_param(threshold, int, 0644);\nMODULE_PARM_DESC(threshold, \"Discard any change in data from a sensor\"\n\t\t\t    \" (the trackpad has many of these sensors)\"\n\t\t\t    \" less than this value.\");\n\nstatic int debug;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Activate debugging output\");\n\n \nstatic int atp_geyser_init(struct atp *dev)\n{\n\tstruct usb_device *udev = dev->udev;\n\tchar *data;\n\tint size;\n\tint i;\n\tint ret;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data) {\n\t\tdev_err(&dev->intf->dev, \"Out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsize = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\tATP_GEYSER_MODE_READ_REQUEST_ID,\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tATP_GEYSER_MODE_REQUEST_VALUE,\n\t\t\tATP_GEYSER_MODE_REQUEST_INDEX, data, 8, 5000);\n\n\tif (size != 8) {\n\t\tdprintk(\"atp_geyser_init: read error\\n\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tdprintk(\"appletouch[%d]: %d\\n\", i, data[i]);\n\n\t\tdev_err(&dev->intf->dev, \"Failed to read mode from device.\\n\");\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\t \n\tdata[0] = ATP_GEYSER_MODE_VENDOR_VALUE;\n\n\tsize = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tATP_GEYSER_MODE_WRITE_REQUEST_ID,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tATP_GEYSER_MODE_REQUEST_VALUE,\n\t\t\tATP_GEYSER_MODE_REQUEST_INDEX, data, 8, 5000);\n\n\tif (size != 8) {\n\t\tdprintk(\"atp_geyser_init: write error\\n\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tdprintk(\"appletouch[%d]: %d\\n\", i, data[i]);\n\n\t\tdev_err(&dev->intf->dev, \"Failed to request geyser raw mode\\n\");\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tret = 0;\nout_free:\n\tkfree(data);\n\treturn ret;\n}\n\n \nstatic void atp_reinit(struct work_struct *work)\n{\n\tstruct atp *dev = container_of(work, struct atp, work);\n\tint retval;\n\n\tdprintk(\"appletouch: putting appletouch to sleep (reinit)\\n\");\n\tatp_geyser_init(dev);\n\n\tretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"atp_reinit: usb_submit_urb failed with error %d\\n\",\n\t\t\tretval);\n}\n\nstatic int atp_calculate_abs(struct atp *dev, int offset, int nb_sensors,\n\t\t\t     int fact, int *z, int *fingers)\n{\n\tint i, pass;\n\n\t \n\tint *xy_sensors = dev->xy_acc + offset;\n\n\t \n\tint pcum = 0, psum = 0;\n\tint is_increasing = 0;\n\n\t*fingers = 0;\n\n\tfor (i = 0; i < nb_sensors; i++) {\n\t\tif (xy_sensors[i] < threshold) {\n\t\t\tif (is_increasing)\n\t\t\t\tis_increasing = 0;\n\n\t\t \n\n\t\t} else if (i < 1 ||\n\t\t    (!is_increasing && xy_sensors[i - 1] < xy_sensors[i])) {\n\t\t\t(*fingers)++;\n\t\t\tis_increasing = 1;\n\t\t} else if (i > 0 && (xy_sensors[i - 1] - xy_sensors[i] > threshold)) {\n\t\t\tis_increasing = 0;\n\t\t}\n\t}\n\n\tif (*fingers < 1)      \n\t\treturn 0;\n\n\t \n\n\tmemset(dev->smooth, 0, 4 * sizeof(dev->smooth[0]));\n\t \n\tfor (i = 0; i < nb_sensors; i++)\n\t\tdev->smooth[i + 4] = xy_sensors[i] << ATP_SCALE;\n\tmemset(&dev->smooth[nb_sensors + 4], 0, 4 * sizeof(dev->smooth[0]));\n\n\tfor (pass = 0; pass < 4; pass++) {\n\t\t \n\t\tdev->smooth_tmp[0] = (dev->smooth[0] + dev->smooth[1]) / 2;\n\n\t\t \n\t\tfor (i = 1; i < nb_sensors + 7; i++)\n\t\t\tdev->smooth_tmp[i] = (dev->smooth[i - 1] +\n\t\t\t\t\t      dev->smooth[i] * 2 +\n\t\t\t\t\t      dev->smooth[i + 1]) / 4;\n\n\t\t \n\t\tdev->smooth_tmp[i] = (dev->smooth[i - 1] + dev->smooth[i]) / 2;\n\n\t\tmemcpy(dev->smooth, dev->smooth_tmp, sizeof(dev->smooth));\n\t}\n\n\tfor (i = 0; i < nb_sensors + 8; i++) {\n\t\t \n\t\tif ((dev->smooth[i] >> ATP_SCALE) > 0) {\n\t\t\tpcum += dev->smooth[i] * i;\n\t\t\tpsum += dev->smooth[i];\n\t\t}\n\t}\n\n\tif (psum > 0) {\n\t\t*z = psum >> ATP_SCALE;         \n\t\treturn pcum * fact / psum;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void atp_report_fingers(struct input_dev *input, int fingers)\n{\n\tinput_report_key(input, BTN_TOOL_FINGER, fingers == 1);\n\tinput_report_key(input, BTN_TOOL_DOUBLETAP, fingers == 2);\n\tinput_report_key(input, BTN_TOOL_TRIPLETAP, fingers > 2);\n}\n\n \n\n#define ATP_URB_STATUS_SUCCESS\t\t0\n#define ATP_URB_STATUS_ERROR\t\t1\n#define ATP_URB_STATUS_ERROR_FATAL\t2\n\nstatic int atp_status_check(struct urb *urb)\n{\n\tstruct atp *dev = urb->context;\n\tstruct usb_interface *intf = dev->intf;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\tif (!dev->overflow_warned) {\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t\"appletouch: OVERFLOW with data length %d, actual length is %d\\n\",\n\t\t\t\tdev->info->datalen, dev->urb->actual_length);\n\t\t\tdev->overflow_warned = true;\n\t\t}\n\t\tfallthrough;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&intf->dev,\n\t\t\t\"atp_complete: urb shutting down with status: %d\\n\",\n\t\t\turb->status);\n\t\treturn ATP_URB_STATUS_ERROR_FATAL;\n\n\tdefault:\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"atp_complete: nonzero urb status received: %d\\n\",\n\t\t\turb->status);\n\t\treturn ATP_URB_STATUS_ERROR;\n\t}\n\n\t \n\tif (dev->urb->actual_length != dev->info->datalen) {\n\t\tdprintk(\"appletouch: incomplete data package\"\n\t\t\t\" (first byte: %d, length: %d).\\n\",\n\t\t\tdev->data[0], dev->urb->actual_length);\n\t\treturn ATP_URB_STATUS_ERROR;\n\t}\n\n\treturn ATP_URB_STATUS_SUCCESS;\n}\n\nstatic void atp_detect_size(struct atp *dev)\n{\n\tint i;\n\n\t \n\tfor (i = dev->info->xsensors; i < ATP_XSENSORS; i++) {\n\t\tif (dev->xy_cur[i]) {\n\n\t\t\tdev_info(&dev->intf->dev,\n\t\t\t\t\"appletouch: 17\\\" model detected.\\n\");\n\n\t\t\tinput_set_abs_params(dev->input, ABS_X, 0,\n\t\t\t\t\t     (dev->info->xsensors_17 - 1) *\n\t\t\t\t\t\t\tdev->info->xfact - 1,\n\t\t\t\t\t     dev->info->fuzz, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\n \n\nstatic void atp_complete_geyser_1_2(struct urb *urb)\n{\n\tint x, y, x_z, y_z, x_f, y_f;\n\tint retval, i, j;\n\tint key, fingers;\n\tstruct atp *dev = urb->context;\n\tint status = atp_status_check(urb);\n\n\tif (status == ATP_URB_STATUS_ERROR_FATAL)\n\t\treturn;\n\telse if (status == ATP_URB_STATUS_ERROR)\n\t\tgoto exit;\n\n\t \n\tif (dev->info == &geyser2_info) {\n\t\tmemset(dev->xy_cur, 0, sizeof(dev->xy_cur));\n\n\t\t \n\n\t\t \n\t\tfor (i = 0, j = 19; i < 20; i += 2, j += 3) {\n\t\t\tdev->xy_cur[i] = dev->data[j];\n\t\t\tdev->xy_cur[i + 1] = dev->data[j + 1];\n\t\t}\n\n\t\t \n\t\tfor (i = 0, j = 1; i < 9; i += 2, j += 3) {\n\t\t\tdev->xy_cur[ATP_XSENSORS + i] = dev->data[j];\n\t\t\tdev->xy_cur[ATP_XSENSORS + i + 1] = dev->data[j + 1];\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\t \n\t\t\tdev->xy_cur[i +  0] = dev->data[5 * i +  2];\n\t\t\tdev->xy_cur[i +  8] = dev->data[5 * i +  4];\n\t\t\tdev->xy_cur[i + 16] = dev->data[5 * i + 42];\n\t\t\tif (i < 2)\n\t\t\t\tdev->xy_cur[i + 24] = dev->data[5 * i + 44];\n\n\t\t\t \n\t\t\tdev->xy_cur[ATP_XSENSORS + i] = dev->data[5 * i +  1];\n\t\t\tdev->xy_cur[ATP_XSENSORS + i + 8] = dev->data[5 * i + 3];\n\t\t}\n\t}\n\n\tdbg_dump(\"sample\", dev->xy_cur);\n\n\tif (!dev->valid) {\n\t\t \n\t\tdev->valid = true;\n\t\tdev->x_old = dev->y_old = -1;\n\n\t\t \n\t\tmemcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));\n\n\t\t \n\t\tif (unlikely(!dev->size_detect_done)) {\n\t\t\tatp_detect_size(dev);\n\t\t\tdev->size_detect_done = true;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ATP_XSENSORS + ATP_YSENSORS; i++) {\n\t\t \n\t\tsigned char change = dev->xy_old[i] - dev->xy_cur[i];\n\t\tdev->xy_acc[i] -= change;\n\n\t\t \n\t\tif (dev->xy_acc[i] < 0)\n\t\t\tdev->xy_acc[i] = 0;\n\t}\n\n\tmemcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));\n\n\tdbg_dump(\"accumulator\", dev->xy_acc);\n\n\tx = atp_calculate_abs(dev, 0, ATP_XSENSORS,\n\t\t\t      dev->info->xfact, &x_z, &x_f);\n\ty = atp_calculate_abs(dev, ATP_XSENSORS, ATP_YSENSORS,\n\t\t\t      dev->info->yfact, &y_z, &y_f);\n\tkey = dev->data[dev->info->datalen - 1] & ATP_STATUS_BUTTON;\n\n\tfingers = max(x_f, y_f);\n\n\tif (x && y && fingers == dev->fingers_old) {\n\t\tif (dev->x_old != -1) {\n\t\t\tx = (dev->x_old * 7 + x) >> 3;\n\t\t\ty = (dev->y_old * 7 + y) >> 3;\n\t\t\tdev->x_old = x;\n\t\t\tdev->y_old = y;\n\n\t\t\tif (debug > 1)\n\t\t\t\tprintk(KERN_DEBUG \"appletouch: \"\n\t\t\t\t\t\"X: %3d Y: %3d Xz: %3d Yz: %3d\\n\",\n\t\t\t\t\tx, y, x_z, y_z);\n\n\t\t\tinput_report_key(dev->input, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(dev->input, ABS_X, x);\n\t\t\tinput_report_abs(dev->input, ABS_Y, y);\n\t\t\tinput_report_abs(dev->input, ABS_PRESSURE,\n\t\t\t\t\t min(ATP_PRESSURE, x_z + y_z));\n\t\t\tatp_report_fingers(dev->input, fingers);\n\t\t}\n\t\tdev->x_old = x;\n\t\tdev->y_old = y;\n\n\t} else if (!x && !y) {\n\n\t\tdev->x_old = dev->y_old = -1;\n\t\tdev->fingers_old = 0;\n\t\tinput_report_key(dev->input, BTN_TOUCH, 0);\n\t\tinput_report_abs(dev->input, ABS_PRESSURE, 0);\n\t\tatp_report_fingers(dev->input, 0);\n\n\t\t \n\t\tmemset(dev->xy_acc, 0, sizeof(dev->xy_acc));\n\t}\n\n\tif (fingers != dev->fingers_old)\n\t\tdev->x_old = dev->y_old = -1;\n\tdev->fingers_old = fingers;\n\n\tinput_report_key(dev->input, BTN_LEFT, key);\n\tinput_sync(dev->input);\n\n exit:\n\tretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"atp_complete: usb_submit_urb failed with result %d\\n\",\n\t\t\tretval);\n}\n\n \n\nstatic void atp_complete_geyser_3_4(struct urb *urb)\n{\n\tint x, y, x_z, y_z, x_f, y_f;\n\tint retval, i, j;\n\tint key, fingers;\n\tstruct atp *dev = urb->context;\n\tint status = atp_status_check(urb);\n\n\tif (status == ATP_URB_STATUS_ERROR_FATAL)\n\t\treturn;\n\telse if (status == ATP_URB_STATUS_ERROR)\n\t\tgoto exit;\n\n\t \n\n\t \n\tfor (i = 0, j = 19; i < 20; i += 2, j += 3) {\n\t\tdev->xy_cur[i] = dev->data[j + 1];\n\t\tdev->xy_cur[i + 1] = dev->data[j + 2];\n\t}\n\t \n\tfor (i = 0, j = 1; i < 9; i += 2, j += 3) {\n\t\tdev->xy_cur[ATP_XSENSORS + i] = dev->data[j + 1];\n\t\tdev->xy_cur[ATP_XSENSORS + i + 1] = dev->data[j + 2];\n\t}\n\n\tdbg_dump(\"sample\", dev->xy_cur);\n\n\t \n\tif (dev->data[dev->info->datalen - 1] & ATP_STATUS_BASE_UPDATE) {\n\n\t\tdprintk(\"appletouch: updated base values\\n\");\n\n\t\tmemcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < ATP_XSENSORS + ATP_YSENSORS; i++) {\n\t\t \n\t\tdev->xy_acc[i] = dev->xy_cur[i] - dev->xy_old[i];\n\n\t\t \n\t\tif (dev->xy_acc[i] > 127)\n\t\t\tdev->xy_acc[i] -= 256;\n\n\t\tif (dev->xy_acc[i] < -127)\n\t\t\tdev->xy_acc[i] += 256;\n\n\t\t \n\t\tif (dev->xy_acc[i] < 0)\n\t\t\tdev->xy_acc[i] = 0;\n\t}\n\n\tdbg_dump(\"accumulator\", dev->xy_acc);\n\n\tx = atp_calculate_abs(dev, 0, ATP_XSENSORS,\n\t\t\t      dev->info->xfact, &x_z, &x_f);\n\ty = atp_calculate_abs(dev, ATP_XSENSORS, ATP_YSENSORS,\n\t\t\t      dev->info->yfact, &y_z, &y_f);\n\n\tkey = dev->data[dev->info->datalen - 1] & ATP_STATUS_BUTTON;\n\n\tfingers = max(x_f, y_f);\n\n\tif (x && y && fingers == dev->fingers_old) {\n\t\tif (dev->x_old != -1) {\n\t\t\tx = (dev->x_old * 7 + x) >> 3;\n\t\t\ty = (dev->y_old * 7 + y) >> 3;\n\t\t\tdev->x_old = x;\n\t\t\tdev->y_old = y;\n\n\t\t\tif (debug > 1)\n\t\t\t\tprintk(KERN_DEBUG \"appletouch: X: %3d Y: %3d \"\n\t\t\t\t       \"Xz: %3d Yz: %3d\\n\",\n\t\t\t\t       x, y, x_z, y_z);\n\n\t\t\tinput_report_key(dev->input, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(dev->input, ABS_X, x);\n\t\t\tinput_report_abs(dev->input, ABS_Y, y);\n\t\t\tinput_report_abs(dev->input, ABS_PRESSURE,\n\t\t\t\t\t min(ATP_PRESSURE, x_z + y_z));\n\t\t\tatp_report_fingers(dev->input, fingers);\n\t\t}\n\t\tdev->x_old = x;\n\t\tdev->y_old = y;\n\n\t} else if (!x && !y) {\n\n\t\tdev->x_old = dev->y_old = -1;\n\t\tdev->fingers_old = 0;\n\t\tinput_report_key(dev->input, BTN_TOUCH, 0);\n\t\tinput_report_abs(dev->input, ABS_PRESSURE, 0);\n\t\tatp_report_fingers(dev->input, 0);\n\n\t\t \n\t\tmemset(dev->xy_acc, 0, sizeof(dev->xy_acc));\n\t}\n\n\tif (fingers != dev->fingers_old)\n\t\tdev->x_old = dev->y_old = -1;\n\tdev->fingers_old = fingers;\n\n\tinput_report_key(dev->input, BTN_LEFT, key);\n\tinput_sync(dev->input);\n\n\t \n\n\t \n\tif (!x && !y && !key) {\n\t\tdev->idlecount++;\n\t\tif (dev->idlecount == 10) {\n\t\t\tdev->x_old = dev->y_old = -1;\n\t\t\tdev->idlecount = 0;\n\t\t\tschedule_work(&dev->work);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t} else\n\t\tdev->idlecount = 0;\n\n exit:\n\tretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"atp_complete: usb_submit_urb failed with result %d\\n\",\n\t\t\tretval);\n}\n\nstatic int atp_open(struct input_dev *input)\n{\n\tstruct atp *dev = input_get_drvdata(input);\n\n\tif (usb_submit_urb(dev->urb, GFP_KERNEL))\n\t\treturn -EIO;\n\n\tdev->open = true;\n\treturn 0;\n}\n\nstatic void atp_close(struct input_dev *input)\n{\n\tstruct atp *dev = input_get_drvdata(input);\n\n\tusb_kill_urb(dev->urb);\n\tcancel_work_sync(&dev->work);\n\tdev->open = false;\n}\n\nstatic int atp_handle_geyser(struct atp *dev)\n{\n\tif (dev->info != &fountain_info) {\n\t\t \n\t\tif (atp_geyser_init(dev))\n\t\t\treturn -EIO;\n\n\t\tdev_info(&dev->intf->dev, \"Geyser mode initialized.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int atp_probe(struct usb_interface *iface,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct atp *dev;\n\tstruct input_dev *input_dev;\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint int_in_endpointAddr = 0;\n\tint i, error = -ENOMEM;\n\tconst struct atp_info *info = (const struct atp_info *)id->driver_info;\n\n\t \n\t \n\tiface_desc = iface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (!int_in_endpointAddr && usb_endpoint_is_int_in(endpoint)) {\n\t\t\t \n\t\t\tint_in_endpointAddr = endpoint->bEndpointAddress;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!int_in_endpointAddr) {\n\t\tdev_err(&iface->dev, \"Could not find int-in endpoint\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tdev = kzalloc(sizeof(struct atp), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!dev || !input_dev) {\n\t\tdev_err(&iface->dev, \"Out of memory\\n\");\n\t\tgoto err_free_devs;\n\t}\n\n\tdev->udev = udev;\n\tdev->intf = iface;\n\tdev->input = input_dev;\n\tdev->info = info;\n\tdev->overflow_warned = false;\n\n\tdev->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb)\n\t\tgoto err_free_devs;\n\n\tdev->data = usb_alloc_coherent(dev->udev, dev->info->datalen, GFP_KERNEL,\n\t\t\t\t       &dev->urb->transfer_dma);\n\tif (!dev->data)\n\t\tgoto err_free_urb;\n\n\tusb_fill_int_urb(dev->urb, udev,\n\t\t\t usb_rcvintpipe(udev, int_in_endpointAddr),\n\t\t\t dev->data, dev->info->datalen,\n\t\t\t dev->info->callback, dev, 1);\n\n\terror = atp_handle_geyser(dev);\n\tif (error)\n\t\tgoto err_free_buffer;\n\n\tusb_make_path(udev, dev->phys, sizeof(dev->phys));\n\tstrlcat(dev->phys, \"/input0\", sizeof(dev->phys));\n\n\tinput_dev->name = \"appletouch\";\n\tinput_dev->phys = dev->phys;\n\tusb_to_input_id(dev->udev, &input_dev->id);\n\tinput_dev->dev.parent = &iface->dev;\n\n\tinput_set_drvdata(input_dev, dev);\n\n\tinput_dev->open = atp_open;\n\tinput_dev->close = atp_close;\n\n\tset_bit(EV_ABS, input_dev->evbit);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0,\n\t\t\t     (dev->info->xsensors - 1) * dev->info->xfact - 1,\n\t\t\t     dev->info->fuzz, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0,\n\t\t\t     (dev->info->ysensors - 1) * dev->info->yfact - 1,\n\t\t\t     dev->info->fuzz, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, ATP_PRESSURE, 0, 0);\n\n\tset_bit(EV_KEY, input_dev->evbit);\n\tset_bit(BTN_TOUCH, input_dev->keybit);\n\tset_bit(BTN_TOOL_FINGER, input_dev->keybit);\n\tset_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\n\tset_bit(BTN_TOOL_TRIPLETAP, input_dev->keybit);\n\tset_bit(BTN_LEFT, input_dev->keybit);\n\n\tINIT_WORK(&dev->work, atp_reinit);\n\n\terror = input_register_device(dev->input);\n\tif (error)\n\t\tgoto err_free_buffer;\n\n\t \n\tusb_set_intfdata(iface, dev);\n\n\treturn 0;\n\n err_free_buffer:\n\tusb_free_coherent(dev->udev, dev->info->datalen,\n\t\t\t  dev->data, dev->urb->transfer_dma);\n err_free_urb:\n\tusb_free_urb(dev->urb);\n err_free_devs:\n\tusb_set_intfdata(iface, NULL);\n\tkfree(dev);\n\tinput_free_device(input_dev);\n\treturn error;\n}\n\nstatic void atp_disconnect(struct usb_interface *iface)\n{\n\tstruct atp *dev = usb_get_intfdata(iface);\n\n\tusb_set_intfdata(iface, NULL);\n\tif (dev) {\n\t\tusb_kill_urb(dev->urb);\n\t\tinput_unregister_device(dev->input);\n\t\tusb_free_coherent(dev->udev, dev->info->datalen,\n\t\t\t\t  dev->data, dev->urb->transfer_dma);\n\t\tusb_free_urb(dev->urb);\n\t\tkfree(dev);\n\t}\n\tdev_info(&iface->dev, \"input: appletouch disconnected\\n\");\n}\n\nstatic int atp_recover(struct atp *dev)\n{\n\tint error;\n\n\terror = atp_handle_geyser(dev);\n\tif (error)\n\t\treturn error;\n\n\tif (dev->open && usb_submit_urb(dev->urb, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int atp_suspend(struct usb_interface *iface, pm_message_t message)\n{\n\tstruct atp *dev = usb_get_intfdata(iface);\n\n\tusb_kill_urb(dev->urb);\n\treturn 0;\n}\n\nstatic int atp_resume(struct usb_interface *iface)\n{\n\tstruct atp *dev = usb_get_intfdata(iface);\n\n\tif (dev->open && usb_submit_urb(dev->urb, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int atp_reset_resume(struct usb_interface *iface)\n{\n\tstruct atp *dev = usb_get_intfdata(iface);\n\n\treturn atp_recover(dev);\n}\n\nstatic struct usb_driver atp_driver = {\n\t.name\t\t= \"appletouch\",\n\t.probe\t\t= atp_probe,\n\t.disconnect\t= atp_disconnect,\n\t.suspend\t= atp_suspend,\n\t.resume\t\t= atp_resume,\n\t.reset_resume\t= atp_reset_resume,\n\t.id_table\t= atp_table,\n};\n\nmodule_usb_driver(atp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}