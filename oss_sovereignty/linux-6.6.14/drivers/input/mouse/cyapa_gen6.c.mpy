{
  "module_name": "cyapa_gen6.c",
  "hash_id": "0ebce10e458ed7d66361d0d9f54529d225febbbf77983ebcd5d0e932a7fb7a1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/cyapa_gen6.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/crc-itu-t.h>\n#include \"cyapa.h\"\n\n\n#define GEN6_ENABLE_CMD_IRQ\t0x41\n#define GEN6_DISABLE_CMD_IRQ\t0x42\n#define GEN6_ENABLE_DEV_IRQ\t0x43\n#define GEN6_DISABLE_DEV_IRQ\t0x44\n\n#define GEN6_POWER_MODE_ACTIVE\t\t0x01\n#define GEN6_POWER_MODE_LP_MODE1\t0x02\n#define GEN6_POWER_MODE_LP_MODE2\t0x03\n#define GEN6_POWER_MODE_BTN_ONLY\t0x04\n\n#define GEN6_SET_POWER_MODE_INTERVAL\t0x47\n#define GEN6_GET_POWER_MODE_INTERVAL\t0x48\n\n#define GEN6_MAX_RX_NUM 14\n#define GEN6_RETRIEVE_DATA_ID_RX_ATTENURATOR_IDAC\t0x00\n#define GEN6_RETRIEVE_DATA_ID_ATTENURATOR_TRIM\t\t0x12\n\n\nstruct pip_app_cmd_head {\n\t__le16 addr;\n\t__le16 length;\n\tu8 report_id;\n\tu8 resv;   \n\tu8 cmd_code;   \n} __packed;\n\nstruct pip_app_resp_head {\n\t__le16 length;\n\tu8 report_id;\n\tu8 resv;   \n\tu8 cmd_code;   \n\t \n\tu8 data_status;\n} __packed;\n\nstruct pip_fixed_info {\n\tu8 silicon_id_high;\n\tu8 silicon_id_low;\n\tu8 family_id;\n};\n\nstatic u8 pip_get_bl_info[] = {\n\t0x04, 0x00, 0x0B, 0x00, 0x40, 0x00, 0x01, 0x38,\n\t0x00, 0x00, 0x70, 0x9E, 0x17\n};\n\nstatic bool cyapa_sort_pip_hid_descriptor_data(struct cyapa *cyapa,\n\t\tu8 *buf, int len)\n{\n\tif (len != PIP_HID_DESCRIPTOR_SIZE)\n\t\treturn false;\n\n\tif (buf[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_APP_REPORT_ID ||\n\t\tbuf[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_BL_REPORT_ID)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int cyapa_get_pip_fixed_info(struct cyapa *cyapa,\n\t\tstruct pip_fixed_info *pip_info, bool is_bootloader)\n{\n\tu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\n\tint resp_len;\n\tu16 product_family;\n\tint error;\n\n\tif (is_bootloader) {\n\t\t \n\t\tresp_len = sizeof(resp_data);\n\t\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\t\tpip_get_bl_info, sizeof(pip_get_bl_info),\n\t\t\t\tresp_data, &resp_len,\n\t\t\t\t2000, cyapa_sort_tsg_pip_bl_resp_data,\n\t\t\t\tfalse);\n\t\tif (error || resp_len < PIP_BL_GET_INFO_RESP_LENGTH)\n\t\t\treturn error ? error : -EIO;\n\n\t\tpip_info->family_id = resp_data[8];\n\t\tpip_info->silicon_id_low = resp_data[10];\n\t\tpip_info->silicon_id_high = resp_data[11];\n\n\t\treturn 0;\n\t}\n\n\t \n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t2000, cyapa_pip_sort_system_info_data, false);\n\tif (error || resp_len < PIP_READ_SYS_INFO_RESP_LENGTH)\n\t\treturn error ? error : -EIO;\n\n\tproduct_family = get_unaligned_le16(&resp_data[7]);\n\tif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\n\t\tPIP_PRODUCT_FAMILY_TRACKPAD)\n\t\treturn -EINVAL;\n\n\tpip_info->family_id = resp_data[19];\n\tpip_info->silicon_id_low = resp_data[21];\n\tpip_info->silicon_id_high = resp_data[22];\n\n\treturn 0;\n\n}\n\nint cyapa_pip_state_parse(struct cyapa *cyapa, u8 *reg_data, int len)\n{\n\tu8 cmd[] = { 0x01, 0x00};\n\tstruct pip_fixed_info pip_info;\n\tu8 resp_data[PIP_HID_DESCRIPTOR_SIZE];\n\tint resp_len;\n\tbool is_bootloader;\n\tint error;\n\n\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\n\t \n\tcyapa_pip_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_ON);\n\n\t \n\tcyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\n\n\t \n\tresp_len = PIP_HID_DESCRIPTOR_SIZE;\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tcmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t300,\n\t\t\tcyapa_sort_pip_hid_descriptor_data,\n\t\t\tfalse);\n\tif (error)\n\t\treturn error;\n\n\tif (resp_data[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_BL_REPORT_ID)\n\t\tis_bootloader = true;\n\telse if (resp_data[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_APP_REPORT_ID)\n\t\tis_bootloader = false;\n\telse\n\t\treturn -EAGAIN;\n\n\t \n\tmemset(&pip_info, 0, sizeof(struct pip_fixed_info));\n\terror = cyapa_get_pip_fixed_info(cyapa, &pip_info, is_bootloader);\n\tif (error)\n\t\treturn error;\n\n\tif (pip_info.family_id == 0x9B && pip_info.silicon_id_high == 0x0B) {\n\t\tcyapa->gen = CYAPA_GEN6;\n\t\tcyapa->state = is_bootloader ? CYAPA_STATE_GEN6_BL\n\t\t\t\t\t     : CYAPA_STATE_GEN6_APP;\n\t} else if (pip_info.family_id == 0x91 &&\n\t\t   pip_info.silicon_id_high == 0x02) {\n\t\tcyapa->gen = CYAPA_GEN5;\n\t\tcyapa->state = is_bootloader ? CYAPA_STATE_GEN5_BL\n\t\t\t\t\t     : CYAPA_STATE_GEN5_APP;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyapa_gen6_read_sys_info(struct cyapa *cyapa)\n{\n\tu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\n\tint resp_len;\n\tu16 product_family;\n\tu8 rotat_align;\n\tint error;\n\n\t \n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t2000, cyapa_pip_sort_system_info_data, false);\n\tif (error || resp_len < sizeof(resp_data))\n\t\treturn error ? error : -EIO;\n\n\tproduct_family = get_unaligned_le16(&resp_data[7]);\n\tif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\n\t\tPIP_PRODUCT_FAMILY_TRACKPAD)\n\t\treturn -EINVAL;\n\n\tcyapa->platform_ver = (resp_data[67] >> PIP_BL_PLATFORM_VER_SHIFT) &\n\t\t\t      PIP_BL_PLATFORM_VER_MASK;\n\tcyapa->fw_maj_ver = resp_data[9];\n\tcyapa->fw_min_ver = resp_data[10];\n\n\tcyapa->electrodes_x = resp_data[33];\n\tcyapa->electrodes_y = resp_data[34];\n\n\tcyapa->physical_size_x =  get_unaligned_le16(&resp_data[35]) / 100;\n\tcyapa->physical_size_y = get_unaligned_le16(&resp_data[37]) / 100;\n\n\tcyapa->max_abs_x = get_unaligned_le16(&resp_data[39]);\n\tcyapa->max_abs_y = get_unaligned_le16(&resp_data[41]);\n\n\tcyapa->max_z = get_unaligned_le16(&resp_data[43]);\n\n\tcyapa->x_origin = resp_data[45] & 0x01;\n\tcyapa->y_origin = resp_data[46] & 0x01;\n\n\tcyapa->btn_capability = (resp_data[70] << 3) & CAPABILITY_BTN_MASK;\n\n\tmemcpy(&cyapa->product_id[0], &resp_data[51], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &resp_data[56], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &resp_data[62], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\t \n\trotat_align = resp_data[68];\n\tcyapa->electrodes_rx =\n\t\trotat_align ? cyapa->electrodes_y : cyapa->electrodes_x;\n\tcyapa->aligned_electrodes_rx = (cyapa->electrodes_rx + 3) & ~3u;\n\n\tif (!cyapa->electrodes_x || !cyapa->electrodes_y ||\n\t\t!cyapa->physical_size_x || !cyapa->physical_size_y ||\n\t\t!cyapa->max_abs_x || !cyapa->max_abs_y || !cyapa->max_z)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen6_bl_read_app_info(struct cyapa *cyapa)\n{\n\tu8 resp_data[PIP_BL_APP_INFO_RESP_LENGTH];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\tpip_bl_read_app_info, PIP_BL_READ_APP_INFO_CMD_LENGTH,\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_bl_resp_data, false);\n\tif (error || resp_len < PIP_BL_APP_INFO_RESP_LENGTH ||\n\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data))\n\t\treturn error ? error : -EIO;\n\n\tcyapa->fw_maj_ver = resp_data[8];\n\tcyapa->fw_min_ver = resp_data[9];\n\n\tcyapa->platform_ver = (resp_data[12] >> PIP_BL_PLATFORM_VER_SHIFT) &\n\t\t\t      PIP_BL_PLATFORM_VER_MASK;\n\n\tmemcpy(&cyapa->product_id[0], &resp_data[13], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &resp_data[18], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &resp_data[24], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\treturn 0;\n\n}\n\nstatic int cyapa_gen6_config_dev_irq(struct cyapa *cyapa, u8 cmd_code)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, cmd_code };\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, cmd_code) ||\n\t\t\t!PIP_CMD_COMPLETE_SUCCESS(resp_data)\n\t\t\t)\n\t\treturn error < 0 ? error : -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen6_set_proximity(struct cyapa *cyapa, bool enable)\n{\n\tint error;\n\n\tcyapa_gen6_config_dev_irq(cyapa, GEN6_DISABLE_CMD_IRQ);\n\terror = cyapa_pip_set_proximity(cyapa, enable);\n\tcyapa_gen6_config_dev_irq(cyapa, GEN6_ENABLE_CMD_IRQ);\n\n\treturn error;\n}\n\nstatic int cyapa_gen6_change_power_state(struct cyapa *cyapa, u8 power_mode)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x06, 0x00, 0x2f, 0x00, 0x46, power_mode };\n\tu8 resp_data[6];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error || !VALID_CMD_RESP_HEADER(resp_data, 0x46))\n\t\treturn error < 0 ? error : -EINVAL;\n\n\t \n\tif (resp_data[5] != power_mode)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen6_set_interval_setting(struct cyapa *cyapa,\n\t\tstruct gen6_interval_setting *interval_setting)\n{\n\tstruct gen6_set_interval_cmd {\n\t\t__le16 addr;\n\t\t__le16 length;\n\t\tu8 report_id;\n\t\tu8 rsvd;   \n\t\tu8 cmd_code;\n\t\t__le16 active_interval;\n\t\t__le16 lp1_interval;\n\t\t__le16 lp2_interval;\n\t} __packed set_interval_cmd;\n\tu8 resp_data[11];\n\tint resp_len;\n\tint error;\n\n\tmemset(&set_interval_cmd, 0, sizeof(set_interval_cmd));\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &set_interval_cmd.addr);\n\tput_unaligned_le16(sizeof(set_interval_cmd) - 2,\n\t\t\t   &set_interval_cmd.length);\n\tset_interval_cmd.report_id = PIP_APP_CMD_REPORT_ID;\n\tset_interval_cmd.cmd_code = GEN6_SET_POWER_MODE_INTERVAL;\n\tput_unaligned_le16(interval_setting->active_interval,\n\t\t\t   &set_interval_cmd.active_interval);\n\tput_unaligned_le16(interval_setting->lp1_interval,\n\t\t\t   &set_interval_cmd.lp1_interval);\n\tput_unaligned_le16(interval_setting->lp2_interval,\n\t\t\t   &set_interval_cmd.lp2_interval);\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\t(u8 *)&set_interval_cmd, sizeof(set_interval_cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, GEN6_SET_POWER_MODE_INTERVAL))\n\t\treturn error < 0 ? error : -EINVAL;\n\n\t \n\tinterval_setting->active_interval = get_unaligned_le16(&resp_data[5]);\n\tinterval_setting->lp1_interval = get_unaligned_le16(&resp_data[7]);\n\tinterval_setting->lp2_interval = get_unaligned_le16(&resp_data[9]);\n\n\treturn 0;\n}\n\nstatic int cyapa_gen6_get_interval_setting(struct cyapa *cyapa,\n\t\tstruct gen6_interval_setting *interval_setting)\n{\n\tu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00,\n\t\t     GEN6_GET_POWER_MODE_INTERVAL };\n\tu8 resp_data[11];\n\tint resp_len;\n\tint error;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\n\t\t\tresp_data, &resp_len,\n\t\t\t500, cyapa_sort_tsg_pip_app_resp_data, false);\n\tif (error ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, GEN6_GET_POWER_MODE_INTERVAL))\n\t\treturn error < 0 ? error : -EINVAL;\n\n\tinterval_setting->active_interval = get_unaligned_le16(&resp_data[5]);\n\tinterval_setting->lp1_interval = get_unaligned_le16(&resp_data[7]);\n\tinterval_setting->lp2_interval = get_unaligned_le16(&resp_data[9]);\n\n\treturn 0;\n}\n\nstatic int cyapa_gen6_deep_sleep(struct cyapa *cyapa, u8 state)\n{\n\tu8 ping[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x00 };\n\n\tif (state == PIP_DEEP_SLEEP_STATE_ON)\n\t\t \n\t\tcyapa_i2c_pip_write(cyapa, ping, sizeof(ping));\n\n\treturn cyapa_pip_deep_sleep(cyapa, state);\n}\n\nstatic int cyapa_gen6_set_power_mode(struct cyapa *cyapa,\n\t\tu8 power_mode, u16 sleep_time, enum cyapa_pm_stage pm_stage)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct gen6_interval_setting *interval_setting =\n\t\t\t&cyapa->gen6_interval_setting;\n\tu8 lp_mode;\n\tint error;\n\n\tif (cyapa->state != CYAPA_STATE_GEN6_APP)\n\t\treturn 0;\n\n\tif (PIP_DEV_GET_PWR_STATE(cyapa) == UNINIT_PWR_MODE) {\n\t\t \n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_OFF);\n\t}\n\n\tif (PIP_DEV_UNINIT_SLEEP_TIME(cyapa) &&\n\t\tPIP_DEV_GET_PWR_STATE(cyapa) != PWR_MODE_OFF)\n\t\tPIP_DEV_SET_SLEEP_TIME(cyapa, UNINIT_SLEEP_TIME);\n\n\tif (PIP_DEV_GET_PWR_STATE(cyapa) == power_mode) {\n\t\tif (power_mode == PWR_MODE_OFF ||\n\t\t\tpower_mode == PWR_MODE_FULL_ACTIVE ||\n\t\t\tpower_mode == PWR_MODE_BTN_ONLY ||\n\t\t\tPIP_DEV_GET_SLEEP_TIME(cyapa) == sleep_time) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (power_mode == PWR_MODE_OFF) {\n\t\tcyapa_gen6_config_dev_irq(cyapa, GEN6_DISABLE_CMD_IRQ);\n\n\t\terror = cyapa_gen6_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_OFF);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"enter deep sleep fail: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_OFF);\n\t\treturn 0;\n\t}\n\n\t \n\tif (PIP_DEV_GET_PWR_STATE(cyapa) == PWR_MODE_OFF) {\n\t\terror = cyapa_gen6_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_ON);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"deep sleep wake fail: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tcyapa_gen6_config_dev_irq(cyapa, GEN6_DISABLE_CMD_IRQ);\n\n\tif (power_mode == PWR_MODE_FULL_ACTIVE) {\n\t\terror = cyapa_gen6_change_power_state(cyapa,\n\t\t\t\tGEN6_POWER_MODE_ACTIVE);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"change to active fail: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_FULL_ACTIVE);\n\n\t\t \n\t\tcyapa_gen6_get_interval_setting(cyapa, interval_setting);\n\n\t} else if (power_mode == PWR_MODE_BTN_ONLY) {\n\t\terror = cyapa_gen6_change_power_state(cyapa,\n\t\t\t\tGEN6_POWER_MODE_BTN_ONLY);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"fail to button only mode: %d\\n\", error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_BTN_ONLY);\n\t} else {\n\t\t \n\t\tif (interval_setting->lp1_interval == sleep_time) {\n\t\t\tlp_mode = GEN6_POWER_MODE_LP_MODE1;\n\t\t} else if (interval_setting->lp2_interval == sleep_time) {\n\t\t\tlp_mode = GEN6_POWER_MODE_LP_MODE2;\n\t\t} else {\n\t\t\tif (interval_setting->lp1_interval == 0) {\n\t\t\t\tinterval_setting->lp1_interval = sleep_time;\n\t\t\t\tlp_mode = GEN6_POWER_MODE_LP_MODE1;\n\t\t\t} else {\n\t\t\t\tinterval_setting->lp2_interval = sleep_time;\n\t\t\t\tlp_mode = GEN6_POWER_MODE_LP_MODE2;\n\t\t\t}\n\t\t\tcyapa_gen6_set_interval_setting(cyapa,\n\t\t\t\t\t\t\tinterval_setting);\n\t\t}\n\n\t\terror = cyapa_gen6_change_power_state(cyapa, lp_mode);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"set power state to 0x%02x failed: %d\\n\",\n\t\t\t\tlp_mode, error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tPIP_DEV_SET_SLEEP_TIME(cyapa, sleep_time);\n\t\tPIP_DEV_SET_PWR_STATE(cyapa,\n\t\t\tcyapa_sleep_time_to_pwr_cmd(sleep_time));\n\t}\n\nout:\n\tcyapa_gen6_config_dev_irq(cyapa, GEN6_ENABLE_CMD_IRQ);\n\treturn error;\n}\n\nstatic int cyapa_gen6_initialize(struct cyapa *cyapa)\n{\n\treturn 0;\n}\n\nstatic int cyapa_pip_retrieve_data_structure(struct cyapa *cyapa,\n\t\tu16 read_offset, u16 read_len, u8 data_id,\n\t\tu8 *data, int *data_buf_lens)\n{\n\tstruct retrieve_data_struct_cmd {\n\t\tstruct pip_app_cmd_head head;\n\t\t__le16 read_offset;\n\t\t__le16 read_length;\n\t\tu8 data_id;\n\t} __packed cmd;\n\tu8 resp_data[GEN6_MAX_RX_NUM + 10];\n\tint resp_len;\n\tint error;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &cmd.head.addr);\n\tput_unaligned_le16(sizeof(cmd) - 2, &cmd.head.length);\n\tcmd.head.report_id = PIP_APP_CMD_REPORT_ID;\n\tcmd.head.cmd_code = PIP_RETRIEVE_DATA_STRUCTURE;\n\tput_unaligned_le16(read_offset, &cmd.read_offset);\n\tput_unaligned_le16(read_len, &cmd.read_length);\n\tcmd.data_id = data_id;\n\n\tresp_len = sizeof(resp_data);\n\terror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\n\t\t\t\t(u8 *)&cmd, sizeof(cmd),\n\t\t\t\tresp_data, &resp_len,\n\t\t\t\t500, cyapa_sort_tsg_pip_app_resp_data,\n\t\t\t\ttrue);\n\tif (error || !PIP_CMD_COMPLETE_SUCCESS(resp_data) ||\n\t\tresp_data[6] != data_id ||\n\t\t!VALID_CMD_RESP_HEADER(resp_data, PIP_RETRIEVE_DATA_STRUCTURE))\n\t\treturn (error < 0) ? error : -EAGAIN;\n\n\tread_len = get_unaligned_le16(&resp_data[7]);\n\tif (*data_buf_lens < read_len) {\n\t\t*data_buf_lens = read_len;\n\t\treturn -ENOBUFS;\n\t}\n\n\tmemcpy(data, &resp_data[10], read_len);\n\t*data_buf_lens = read_len;\n\treturn 0;\n}\n\nstatic ssize_t cyapa_gen6_show_baseline(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tu8 data[GEN6_MAX_RX_NUM];\n\tint data_len;\n\tint size = 0;\n\tint i;\n\tint error;\n\tint resume_error;\n\n\tif (!cyapa_is_pip_app_mode(cyapa))\n\t\treturn -EBUSY;\n\n\t \n\terror = cyapa_pip_suspend_scanning(cyapa);\n\tif (error)\n\t\treturn error;\n\n\t \n\tdata_len = sizeof(data);\n\terror = cyapa_pip_retrieve_data_structure(cyapa, 0, data_len,\n\t\t\tGEN6_RETRIEVE_DATA_ID_RX_ATTENURATOR_IDAC,\n\t\t\tdata, &data_len);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\tsize = scnprintf(buf, PAGE_SIZE, \"%d %d %d %d %d %d \",\n\t\t\tdata[0],   \n\t\t\tdata[1],   \n\t\t\tdata[2],   \n\t\t\tdata[3],   \n\t\t\tdata[4],   \n\t\t\tdata[5]\t   \n\t\t\t);\n\n\t \n\tdata_len = sizeof(data);\n\terror = cyapa_pip_retrieve_data_structure(cyapa, 0, data_len,\n\t\t\tGEN6_RETRIEVE_DATA_ID_ATTENURATOR_TRIM,\n\t\t\tdata, &data_len);\n\tif (error)\n\t\tgoto resume_scanning;\n\n\t \n\tfor (i = 0; i < data_len; i++)\n\t\tsize += scnprintf(buf + size, PAGE_SIZE - size,\t\"%d \", data[i]);\n\tsize += scnprintf(buf + size, PAGE_SIZE - size, \"\\n\");\n\nresume_scanning:\n\t \n\tresume_error = cyapa_pip_resume_scanning(cyapa);\n\tif (resume_error || error) {\n\t\tmemset(buf, 0, PAGE_SIZE);\n\t\treturn resume_error ? resume_error : error;\n\t}\n\n\treturn size;\n}\n\nstatic int cyapa_gen6_operational_check(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\tif (cyapa->gen != CYAPA_GEN6)\n\t\treturn -ENODEV;\n\n\tswitch (cyapa->state) {\n\tcase CYAPA_STATE_GEN6_BL:\n\t\terror = cyapa_pip_bl_exit(cyapa);\n\t\tif (error) {\n\t\t\t \n\t\t\tcyapa_gen6_bl_read_app_info(cyapa);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcyapa->state = CYAPA_STATE_GEN6_APP;\n\t\tfallthrough;\n\n\tcase CYAPA_STATE_GEN6_APP:\n\t\t \n\t\terror = cyapa_gen6_set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"%s: failed to set power active mode.\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\terror = cyapa_pip_set_proximity(cyapa, true);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"%s: failed to enable proximity.\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\terror = cyapa_gen6_read_sys_info(cyapa);\n\t\tif (error)\n\t\t\tgoto out;\n\t\t \n\t\tif (memcmp(cyapa->product_id, product_id,\n\t\t\t\tstrlen(product_id)) != 0) {\n\t\t\tdev_err(dev, \"%s: unknown product ID (%s)\\n\",\n\t\t\t\t__func__, cyapa->product_id);\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\nout:\n\treturn error;\n}\n\nconst struct cyapa_dev_ops cyapa_gen6_ops = {\n\t.check_fw = cyapa_pip_check_fw,\n\t.bl_enter = cyapa_pip_bl_enter,\n\t.bl_initiate = cyapa_pip_bl_initiate,\n\t.update_fw = cyapa_pip_do_fw_update,\n\t.bl_activate = cyapa_pip_bl_activate,\n\t.bl_deactivate = cyapa_pip_bl_deactivate,\n\n\t.show_baseline = cyapa_gen6_show_baseline,\n\t.calibrate_store = cyapa_pip_do_calibrate,\n\n\t.initialize = cyapa_gen6_initialize,\n\n\t.state_parse = cyapa_pip_state_parse,\n\t.operational_check = cyapa_gen6_operational_check,\n\n\t.irq_handler = cyapa_pip_irq_handler,\n\t.irq_cmd_handler = cyapa_pip_irq_cmd_handler,\n\t.sort_empty_output_data = cyapa_empty_pip_output_data,\n\t.set_power_mode = cyapa_gen6_set_power_mode,\n\n\t.set_proximity = cyapa_gen6_set_proximity,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}