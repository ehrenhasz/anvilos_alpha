{
  "module_name": "elan_i2c_i2c.c",
  "hash_id": "c2557833dab3cb4cec372390ec3733bacd3ba40c33a763df01687a21feac3ffb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/elan_i2c_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <asm/unaligned.h>\n\n#include \"elan_i2c.h\"\n\n \n#define ETP_I2C_RESET\t\t\t0x0100\n#define ETP_I2C_WAKE_UP\t\t\t0x0800\n#define ETP_I2C_SLEEP\t\t\t0x0801\n#define ETP_I2C_DESC_CMD\t\t0x0001\n#define ETP_I2C_REPORT_DESC_CMD\t\t0x0002\n#define ETP_I2C_STAND_CMD\t\t0x0005\n#define ETP_I2C_PATTERN_CMD\t\t0x0100\n#define ETP_I2C_UNIQUEID_CMD\t\t0x0101\n#define ETP_I2C_FW_VERSION_CMD\t\t0x0102\n#define ETP_I2C_IC_TYPE_CMD\t\t0x0103\n#define ETP_I2C_OSM_VERSION_CMD\t\t0x0103\n#define ETP_I2C_NSM_VERSION_CMD\t\t0x0104\n#define ETP_I2C_XY_TRACENUM_CMD\t\t0x0105\n#define ETP_I2C_MAX_X_AXIS_CMD\t\t0x0106\n#define ETP_I2C_MAX_Y_AXIS_CMD\t\t0x0107\n#define ETP_I2C_RESOLUTION_CMD\t\t0x0108\n#define ETP_I2C_PRESSURE_CMD\t\t0x010A\n#define ETP_I2C_IAP_VERSION_CMD\t\t0x0110\n#define ETP_I2C_IC_TYPE_P0_CMD\t\t0x0110\n#define ETP_I2C_IAP_VERSION_P0_CMD\t0x0111\n#define ETP_I2C_SET_CMD\t\t\t0x0300\n#define ETP_I2C_POWER_CMD\t\t0x0307\n#define ETP_I2C_FW_CHECKSUM_CMD\t\t0x030F\n#define ETP_I2C_IAP_CTRL_CMD\t\t0x0310\n#define ETP_I2C_IAP_CMD\t\t\t0x0311\n#define ETP_I2C_IAP_RESET_CMD\t\t0x0314\n#define ETP_I2C_IAP_CHECKSUM_CMD\t0x0315\n#define ETP_I2C_CALIBRATE_CMD\t\t0x0316\n#define ETP_I2C_MAX_BASELINE_CMD\t0x0317\n#define ETP_I2C_MIN_BASELINE_CMD\t0x0318\n#define ETP_I2C_IAP_TYPE_REG\t\t0x0040\n#define ETP_I2C_IAP_TYPE_CMD\t\t0x0304\n\n#define ETP_I2C_REPORT_LEN\t\t34\n#define ETP_I2C_REPORT_LEN_ID2\t\t39\n#define ETP_I2C_REPORT_MAX_LEN\t\t39\n#define ETP_I2C_DESC_LENGTH\t\t30\n#define ETP_I2C_REPORT_DESC_LENGTH\t158\n#define ETP_I2C_INF_LENGTH\t\t2\n#define ETP_I2C_IAP_PASSWORD\t\t0x1EA5\n#define ETP_I2C_IAP_RESET\t\t0xF0F0\n#define ETP_I2C_MAIN_MODE_ON\t\t(1 << 9)\n#define ETP_I2C_IAP_REG_L\t\t0x01\n#define ETP_I2C_IAP_REG_H\t\t0x06\n\nstatic int elan_i2c_read_block(struct i2c_client *client,\n\t\t\t       u16 reg, u8 *val, u16 len)\n{\n\t__le16 buf[] = {\n\t\tcpu_to_le16(reg),\n\t};\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = client->flags & I2C_M_TEN,\n\t\t\t.len = sizeof(buf),\n\t\t\t.buf = (u8 *)buf,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = (client->flags & I2C_M_TEN) | I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = val,\n\t\t}\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\treturn ret == ARRAY_SIZE(msgs) ? 0 : (ret < 0 ? ret : -EIO);\n}\n\nstatic int elan_i2c_read_cmd(struct i2c_client *client, u16 reg, u8 *val)\n{\n\tint retval;\n\n\tretval = elan_i2c_read_block(client, reg, val, ETP_I2C_INF_LENGTH);\n\tif (retval < 0) {\n\t\tdev_err(&client->dev, \"reading cmd (0x%04x) fail.\\n\", reg);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_write_cmd(struct i2c_client *client, u16 reg, u16 cmd)\n{\n\t__le16 buf[] = {\n\t\tcpu_to_le16(reg),\n\t\tcpu_to_le16(cmd),\n\t};\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.flags = client->flags & I2C_M_TEN,\n\t\t.len = sizeof(buf),\n\t\t.buf = (u8 *)buf,\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tdev_err(&client->dev, \"writing cmd (0x%04x) failed: %d\\n\",\n\t\t\treg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_initialize(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tint error;\n\tu8 val[256];\n\n\terror = elan_i2c_write_cmd(client, ETP_I2C_STAND_CMD, ETP_I2C_RESET);\n\tif (error) {\n\t\tdev_err(dev, \"device reset failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tmsleep(100);\n\n\t \n\terror = i2c_master_recv(client, val, ETP_I2C_INF_LENGTH);\n\tif (error < 0) {\n\t\tdev_err(dev, \"failed to read reset response: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = elan_i2c_read_block(client, ETP_I2C_DESC_CMD,\n\t\t\t\t    val, ETP_I2C_DESC_LENGTH);\n\tif (error) {\n\t\tdev_err(dev, \"cannot get device descriptor: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = elan_i2c_read_block(client, ETP_I2C_REPORT_DESC_CMD,\n\t\t\t\t    val, ETP_I2C_REPORT_DESC_LENGTH);\n\tif (error) {\n\t\tdev_err(dev, \"fetching report descriptor failed.: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_sleep_control(struct i2c_client *client, bool sleep)\n{\n\treturn elan_i2c_write_cmd(client, ETP_I2C_STAND_CMD,\n\t\t\t\t  sleep ? ETP_I2C_SLEEP : ETP_I2C_WAKE_UP);\n}\n\nstatic int elan_i2c_power_control(struct i2c_client *client, bool enable)\n{\n\tu8 val[2];\n\tu16 reg;\n\tint error;\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_POWER_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to read current power state: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treg = le16_to_cpup((__le16 *)val);\n\tif (enable)\n\t\treg &= ~ETP_DISABLE_POWER;\n\telse\n\t\treg |= ETP_DISABLE_POWER;\n\n\terror = elan_i2c_write_cmd(client, ETP_I2C_POWER_CMD, reg);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to write current power state: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_set_mode(struct i2c_client *client, u8 mode)\n{\n\treturn elan_i2c_write_cmd(client, ETP_I2C_SET_CMD, mode);\n}\n\n\nstatic int elan_i2c_calibrate(struct i2c_client *client)\n{\n\treturn elan_i2c_write_cmd(client, ETP_I2C_CALIBRATE_CMD, 1);\n}\n\nstatic int elan_i2c_calibrate_result(struct i2c_client *client, u8 *val)\n{\n\treturn elan_i2c_read_block(client, ETP_I2C_CALIBRATE_CMD, val, 1);\n}\n\nstatic int elan_i2c_get_baseline_data(struct i2c_client *client,\n\t\t\t\t      bool max_baseline, u8 *value)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client,\n\t\t\t\t  max_baseline ? ETP_I2C_MAX_BASELINE_CMD :\n\t\t\t\t\t\t ETP_I2C_MIN_BASELINE_CMD,\n\t\t\t\t  val);\n\tif (error)\n\t\treturn error;\n\n\t*value = le16_to_cpup((__le16 *)val);\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_pattern(struct i2c_client *client, u8 *pattern)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_PATTERN_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get pattern: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\t*pattern = val[0] == 0xFF && val[1] == 0xFF ? 0 : val[1];\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_version(struct i2c_client *client,\n\t\t\t\tu8 pattern, bool iap, u8 *version)\n{\n\tint error;\n\tu16 cmd;\n\tu8 val[3];\n\n\tif (!iap)\n\t\tcmd = ETP_I2C_FW_VERSION_CMD;\n\telse if (pattern == 0)\n\t\tcmd = ETP_I2C_IAP_VERSION_P0_CMD;\n\telse\n\t\tcmd = ETP_I2C_IAP_VERSION_CMD;\n\n\terror = elan_i2c_read_cmd(client, cmd, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get %s version: %d\\n\",\n\t\t\tiap ? \"IAP\" : \"FW\", error);\n\t\treturn error;\n\t}\n\n\tif (pattern >= 0x01)\n\t\t*version = iap ? val[1] : val[0];\n\telse\n\t\t*version = val[0];\n\treturn 0;\n}\n\nstatic int elan_i2c_get_sm_version(struct i2c_client *client, u8 pattern,\n\t\t\t\t   u16 *ic_type, u8 *version, u8 *clickpad)\n{\n\tint error;\n\tu8 val[3];\n\n\tif (pattern >= 0x01) {\n\t\terror = elan_i2c_read_cmd(client, ETP_I2C_IC_TYPE_CMD, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to get ic type: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t\t*ic_type = be16_to_cpup((__be16 *)val);\n\n\t\terror = elan_i2c_read_cmd(client, ETP_I2C_NSM_VERSION_CMD,\n\t\t\t\t\t  val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to get SM version: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t\t*version = val[1];\n\t\t*clickpad = val[0] & 0x10;\n\t} else {\n\t\terror = elan_i2c_read_cmd(client, ETP_I2C_OSM_VERSION_CMD, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to get SM version: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t\t*version = val[0];\n\n\t\terror = elan_i2c_read_cmd(client, ETP_I2C_IC_TYPE_P0_CMD, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to get ic type: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t\t*ic_type = val[0];\n\n\t\terror = elan_i2c_read_cmd(client, ETP_I2C_NSM_VERSION_CMD,\n\t\t\t\t\t  val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to get SM version: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t\t*clickpad = val[0] & 0x10;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_product_id(struct i2c_client *client, u16 *id)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_UNIQUEID_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get product ID: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*id = le16_to_cpup((__le16 *)val);\n\treturn 0;\n}\n\nstatic int elan_i2c_get_checksum(struct i2c_client *client,\n\t\t\t\t bool iap, u16 *csum)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client,\n\t\t\t\t  iap ? ETP_I2C_IAP_CHECKSUM_CMD :\n\t\t\t\t\tETP_I2C_FW_CHECKSUM_CMD,\n\t\t\t\t  val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get %s checksum: %d\\n\",\n\t\t\tiap ? \"IAP\" : \"FW\", error);\n\t\treturn error;\n\t}\n\n\t*csum = le16_to_cpup((__le16 *)val);\n\treturn 0;\n}\n\nstatic int elan_i2c_get_max(struct i2c_client *client,\n\t\t\t    unsigned int *max_x, unsigned int *max_y)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_MAX_X_AXIS_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get X dimension: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*max_x = le16_to_cpup((__le16 *)val);\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_MAX_Y_AXIS_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get Y dimension: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*max_y = le16_to_cpup((__le16 *)val);\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_resolution(struct i2c_client *client,\n\t\t\t\t   u8 *hw_res_x, u8 *hw_res_y)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_RESOLUTION_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get resolution: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*hw_res_x = val[0];\n\t*hw_res_y = val[1];\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_num_traces(struct i2c_client *client,\n\t\t\t\t   unsigned int *x_traces,\n\t\t\t\t   unsigned int *y_traces)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_XY_TRACENUM_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get trace info: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t*x_traces = val[0];\n\t*y_traces = val[1];\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_pressure_adjustment(struct i2c_client *client,\n\t\t\t\t\t    int *adjustment)\n{\n\tint error;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_PRESSURE_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get pressure format: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif ((val[0] >> 4) & 0x1)\n\t\t*adjustment = 0;\n\telse\n\t\t*adjustment = ETP_PRESSURE_OFFSET;\n\n\treturn 0;\n}\n\nstatic int elan_i2c_iap_get_mode(struct i2c_client *client, enum tp_mode *mode)\n{\n\tint error;\n\tu16 constant;\n\tu8 val[3];\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_IAP_CTRL_CMD, val);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to read iap control register: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tconstant = le16_to_cpup((__le16 *)val);\n\tdev_dbg(&client->dev, \"iap control reg: 0x%04x.\\n\", constant);\n\n\t*mode = (constant & ETP_I2C_MAIN_MODE_ON) ? MAIN_MODE : IAP_MODE;\n\n\treturn 0;\n}\n\nstatic int elan_i2c_iap_reset(struct i2c_client *client)\n{\n\tint error;\n\n\terror = elan_i2c_write_cmd(client, ETP_I2C_IAP_RESET_CMD,\n\t\t\t\t   ETP_I2C_IAP_RESET);\n\tif (error) {\n\t\tdev_err(&client->dev, \"cannot reset IC: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_set_flash_key(struct i2c_client *client)\n{\n\tint error;\n\n\terror = elan_i2c_write_cmd(client, ETP_I2C_IAP_CMD,\n\t\t\t\t   ETP_I2C_IAP_PASSWORD);\n\tif (error) {\n\t\tdev_err(&client->dev, \"cannot set flash key: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_read_write_iap_type(struct i2c_client *client, u16 fw_page_size)\n{\n\tint error;\n\tu16 constant;\n\tu8 val[3];\n\tint retry = 3;\n\n\tdo {\n\t\terror = elan_i2c_write_cmd(client, ETP_I2C_IAP_TYPE_CMD,\n\t\t\t\t\t   fw_page_size / 2);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"cannot write iap type: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = elan_i2c_read_cmd(client, ETP_I2C_IAP_TYPE_CMD, val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to read iap type register: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t\tconstant = le16_to_cpup((__le16 *)val);\n\t\tdev_dbg(&client->dev, \"iap type reg: 0x%04x\\n\", constant);\n\n\t\tif (constant == fw_page_size / 2)\n\t\t\treturn 0;\n\n\t} while (--retry > 0);\n\n\tdev_err(&client->dev, \"cannot set iap type\\n\");\n\treturn -EIO;\n}\n\nstatic int elan_i2c_prepare_fw_update(struct i2c_client *client, u16 ic_type,\n\t\t\t\t      u8 iap_version, u16 fw_page_size)\n{\n\tstruct device *dev = &client->dev;\n\tint error;\n\tenum tp_mode mode;\n\tu8 val[3];\n\tu16 password;\n\n\t \n\terror = elan_i2c_iap_get_mode(client, &mode);\n\tif (error)\n\t\treturn error;\n\n\tif (mode == IAP_MODE) {\n\t\t \n\t\terror = elan_i2c_iap_reset(client);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmsleep(30);\n\t}\n\n\t \n\terror = elan_i2c_set_flash_key(client);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(mode == MAIN_MODE ? 100 : 30);\n\n\t \n\terror = elan_i2c_iap_get_mode(client, &mode);\n\tif (error)\n\t\treturn error;\n\n\tif (mode == MAIN_MODE) {\n\t\tdev_err(dev, \"wrong mode: %d\\n\", mode);\n\t\treturn -EIO;\n\t}\n\n\tif (ic_type >= 0x0D && iap_version >= 1) {\n\t\terror = elan_read_write_iap_type(client, fw_page_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\terror = elan_i2c_set_flash_key(client);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(30);\n\n\t \n\terror = elan_i2c_read_cmd(client, ETP_I2C_IAP_CMD, val);\n\tif (error) {\n\t\tdev_err(dev, \"cannot read iap password: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tpassword = le16_to_cpup((__le16 *)val);\n\tif (password != ETP_I2C_IAP_PASSWORD) {\n\t\tdev_err(dev, \"wrong iap password: 0x%X\\n\", password);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_write_fw_block(struct i2c_client *client, u16 fw_page_size,\n\t\t\t\t   const u8 *page, u16 checksum, int idx)\n{\n\tstruct device *dev = &client->dev;\n\tu8 *page_store;\n\tu8 val[3];\n\tu16 result;\n\tint ret, error;\n\n\tpage_store = kmalloc(fw_page_size + 4, GFP_KERNEL);\n\tif (!page_store)\n\t\treturn -ENOMEM;\n\n\tpage_store[0] = ETP_I2C_IAP_REG_L;\n\tpage_store[1] = ETP_I2C_IAP_REG_H;\n\tmemcpy(&page_store[2], page, fw_page_size);\n\t \n\tput_unaligned_le16(checksum, &page_store[fw_page_size + 2]);\n\n\tret = i2c_master_send(client, page_store, fw_page_size + 4);\n\tif (ret != fw_page_size + 4) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(dev, \"Failed to write page %d: %d\\n\", idx, error);\n\t\tgoto exit;\n\t}\n\n\t \n\tmsleep(fw_page_size == ETP_FW_PAGE_SIZE_512 ? 50 : 35);\n\n\terror = elan_i2c_read_cmd(client, ETP_I2C_IAP_CTRL_CMD, val);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to read IAP write result: %d\\n\", error);\n\t\tgoto exit;\n\t}\n\n\tresult = le16_to_cpup((__le16 *)val);\n\tif (result & (ETP_FW_IAP_PAGE_ERR | ETP_FW_IAP_INTF_ERR)) {\n\t\tdev_err(dev, \"IAP reports failed write: %04hx\\n\",\n\t\t\tresult);\n\t\terror = -EIO;\n\t\tgoto exit;\n\t}\n\nexit:\n\tkfree(page_store);\n\treturn error;\n}\n\nstatic int elan_i2c_finish_fw_update(struct i2c_client *client,\n\t\t\t\t     struct completion *completion)\n{\n\tstruct device *dev = &client->dev;\n\tint error = 0;\n\tint len;\n\tu8 buffer[ETP_I2C_REPORT_MAX_LEN];\n\n\tlen = i2c_master_recv(client, buffer, ETP_I2C_REPORT_MAX_LEN);\n\tif (len <= 0) {\n\t\terror = len < 0 ? len : -EIO;\n\t\tdev_warn(dev, \"failed to read I2C data after FW WDT reset: %d (%d)\\n\",\n\t\t\terror, len);\n\t}\n\n\treinit_completion(completion);\n\tenable_irq(client->irq);\n\n\terror = elan_i2c_write_cmd(client, ETP_I2C_STAND_CMD, ETP_I2C_RESET);\n\tif (error) {\n\t\tdev_err(dev, \"device reset failed: %d\\n\", error);\n\t} else if (!wait_for_completion_timeout(completion,\n\t\t\t\t\t\tmsecs_to_jiffies(300))) {\n\t\tdev_err(dev, \"timeout waiting for device reset\\n\");\n\t\terror = -ETIMEDOUT;\n\t}\n\n\tdisable_irq(client->irq);\n\n\tif (error)\n\t\treturn error;\n\n\tlen = i2c_master_recv(client, buffer, ETP_I2C_INF_LENGTH);\n\tif (len != ETP_I2C_INF_LENGTH) {\n\t\terror = len < 0 ? len : -EIO;\n\t\tdev_err(dev, \"failed to read INT signal: %d (%d)\\n\",\n\t\t\terror, len);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_i2c_get_report_features(struct i2c_client *client, u8 pattern,\n\t\t\t\t\tunsigned int *features,\n\t\t\t\t\tunsigned int *report_len)\n{\n\t*features = ETP_FEATURE_REPORT_MK;\n\t*report_len = pattern <= 0x01 ?\n\t\t\tETP_I2C_REPORT_LEN : ETP_I2C_REPORT_LEN_ID2;\n\treturn 0;\n}\n\nstatic int elan_i2c_get_report(struct i2c_client *client,\n\t\t\t       u8 *report, unsigned int report_len)\n{\n\tint len;\n\n\tlen = i2c_master_recv(client, report, report_len);\n\tif (len < 0) {\n\t\tdev_err(&client->dev, \"failed to read report data: %d\\n\", len);\n\t\treturn len;\n\t}\n\n\tif (len != report_len) {\n\t\tdev_err(&client->dev,\n\t\t\t\"wrong report length (%d vs %d expected)\\n\",\n\t\t\tlen, report_len);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nconst struct elan_transport_ops elan_i2c_ops = {\n\t.initialize\t\t= elan_i2c_initialize,\n\t.sleep_control\t\t= elan_i2c_sleep_control,\n\t.power_control\t\t= elan_i2c_power_control,\n\t.set_mode\t\t= elan_i2c_set_mode,\n\n\t.calibrate\t\t= elan_i2c_calibrate,\n\t.calibrate_result\t= elan_i2c_calibrate_result,\n\n\t.get_baseline_data\t= elan_i2c_get_baseline_data,\n\n\t.get_version\t\t= elan_i2c_get_version,\n\t.get_sm_version\t\t= elan_i2c_get_sm_version,\n\t.get_product_id\t\t= elan_i2c_get_product_id,\n\t.get_checksum\t\t= elan_i2c_get_checksum,\n\t.get_pressure_adjustment = elan_i2c_get_pressure_adjustment,\n\n\t.get_max\t\t= elan_i2c_get_max,\n\t.get_resolution\t\t= elan_i2c_get_resolution,\n\t.get_num_traces\t\t= elan_i2c_get_num_traces,\n\n\t.iap_get_mode\t\t= elan_i2c_iap_get_mode,\n\t.iap_reset\t\t= elan_i2c_iap_reset,\n\n\t.prepare_fw_update\t= elan_i2c_prepare_fw_update,\n\t.write_fw_block\t\t= elan_i2c_write_fw_block,\n\t.finish_fw_update\t= elan_i2c_finish_fw_update,\n\n\t.get_pattern\t\t= elan_i2c_get_pattern,\n\n\t.get_report_features\t= elan_i2c_get_report_features,\n\t.get_report\t\t= elan_i2c_get_report,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}