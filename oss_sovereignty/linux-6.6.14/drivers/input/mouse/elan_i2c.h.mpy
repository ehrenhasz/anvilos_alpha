{
  "module_name": "elan_i2c.h",
  "hash_id": "fbc04d01dd6b0b69b6a02b042fc4dfa3309e04b6cba05c1ab0fe65fb7d1ad9ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/elan_i2c.h",
  "human_readable_source": " \n \n\n#ifndef _ELAN_I2C_H\n#define _ELAN_I2C_H\n\n#include <linux/types.h>\n\n#define ETP_ENABLE_ABS\t\t0x0001\n#define ETP_ENABLE_CALIBRATE\t0x0002\n#define ETP_DISABLE_CALIBRATE\t0x0000\n#define ETP_DISABLE_POWER\t0x0001\n#define ETP_PRESSURE_OFFSET\t25\n\n#define ETP_CALIBRATE_MAX_LEN\t3\n\n#define ETP_FEATURE_REPORT_MK\tBIT(0)\n\n#define ETP_REPORT_ID\t\t0x5D\n#define ETP_TP_REPORT_ID\t0x5E\n#define ETP_TP_REPORT_ID2\t0x5F\n#define ETP_REPORT_ID2\t\t0x60\t \n\n#define ETP_REPORT_ID_OFFSET\t2\n#define ETP_TOUCH_INFO_OFFSET\t3\n#define ETP_FINGER_DATA_OFFSET\t4\n#define ETP_HOVER_INFO_OFFSET\t30\n#define ETP_MK_DATA_OFFSET\t33\t \n\n#define ETP_MAX_REPORT_LEN\t39\n\n#define ETP_MAX_FINGERS\t\t5\n#define ETP_FINGER_DATA_LEN\t5\n\n \n#define ETP_PRODUCT_ID_FORMAT_STRING\t\"%d.0\"\n#define ETP_FW_NAME\t\t\"elan_i2c_\" ETP_PRODUCT_ID_FORMAT_STRING \".bin\"\n#define ETP_IAP_START_ADDR\t0x0083\n#define ETP_FW_IAP_PAGE_ERR\t(1 << 5)\n#define ETP_FW_IAP_INTF_ERR\t(1 << 4)\n#define ETP_FW_PAGE_SIZE\t64\n#define ETP_FW_PAGE_SIZE_128\t128\n#define ETP_FW_PAGE_SIZE_512\t512\n#define ETP_FW_SIGNATURE_SIZE\t6\n\n#define ETP_PRODUCT_ID_WHITEBOX\t0x00B8\n#define ETP_PRODUCT_ID_VOXEL\t0x00BF\n#define ETP_PRODUCT_ID_DELBIN\t0x00C2\n#define ETP_PRODUCT_ID_MAGPIE\t0x0120\n#define ETP_PRODUCT_ID_BOBBA\t0x0121\n\nstruct i2c_client;\nstruct completion;\n\nenum tp_mode {\n\tIAP_MODE = 1,\n\tMAIN_MODE\n};\n\nstruct elan_transport_ops {\n\tint (*initialize)(struct i2c_client *client);\n\tint (*sleep_control)(struct i2c_client *, bool sleep);\n\tint (*power_control)(struct i2c_client *, bool enable);\n\tint (*set_mode)(struct i2c_client *client, u8 mode);\n\n\tint (*calibrate)(struct i2c_client *client);\n\tint (*calibrate_result)(struct i2c_client *client, u8 *val);\n\n\tint (*get_baseline_data)(struct i2c_client *client,\n\t\t\t\t bool max_baseline, u8 *value);\n\n\tint (*get_version)(struct i2c_client *client, u8 pattern, bool iap,\n\t\t\t   u8 *version);\n\tint (*get_sm_version)(struct i2c_client *client, u8 pattern,\n\t\t\t      u16 *ic_type, u8 *version, u8 *clickpad);\n\tint (*get_checksum)(struct i2c_client *client, bool iap, u16 *csum);\n\tint (*get_product_id)(struct i2c_client *client, u16 *id);\n\n\tint (*get_max)(struct i2c_client *client,\n\t\t       unsigned int *max_x, unsigned int *max_y);\n\tint (*get_resolution)(struct i2c_client *client,\n\t\t\t      u8 *hw_res_x, u8 *hw_res_y);\n\tint (*get_num_traces)(struct i2c_client *client,\n\t\t\t      unsigned int *x_tracenum,\n\t\t\t      unsigned int *y_tracenum);\n\n\tint (*iap_get_mode)(struct i2c_client *client, enum tp_mode *mode);\n\tint (*iap_reset)(struct i2c_client *client);\n\n\tint (*prepare_fw_update)(struct i2c_client *client, u16 ic_type,\n\t\t\t\t u8 iap_version, u16 fw_page_size);\n\tint (*write_fw_block)(struct i2c_client *client, u16 fw_page_size,\n\t\t\t      const u8 *page, u16 checksum, int idx);\n\tint (*finish_fw_update)(struct i2c_client *client,\n\t\t\t\tstruct completion *reset_done);\n\n\tint (*get_report_features)(struct i2c_client *client, u8 pattern,\n\t\t\t\t   unsigned int *features,\n\t\t\t\t   unsigned int *report_len);\n\tint (*get_report)(struct i2c_client *client, u8 *report,\n\t\t\t  unsigned int report_len);\n\tint (*get_pressure_adjustment)(struct i2c_client *client,\n\t\t\t\t       int *adjustment);\n\tint (*get_pattern)(struct i2c_client *client, u8 *pattern);\n};\n\nextern const struct elan_transport_ops elan_smbus_ops, elan_i2c_ops;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}