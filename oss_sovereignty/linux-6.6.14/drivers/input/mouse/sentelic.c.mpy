{
  "module_name": "sentelic.c",
  "hash_id": "773504196a8c70b73f78ec3cf3d9566fd892149edd8bfb95c6bd385e0dd3c68c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/sentelic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/ctype.h>\n#include <linux/libps2.h>\n#include <linux/serio.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n\n#include \"psmouse.h\"\n#include \"sentelic.h\"\n\n \n#define\tFSP_CMD_TIMEOUT\t\t200\n#define\tFSP_CMD_TIMEOUT2\t30\n\n#define\tGET_ABS_X(packet)\t((packet[1] << 2) | ((packet[3] >> 2) & 0x03))\n#define\tGET_ABS_Y(packet)\t((packet[2] << 2) | (packet[3] & 0x03))\n\n \nstatic const char fsp_drv_ver[] = \"1.1.0-K\";\n\n \nstatic unsigned char fsp_test_swap_cmd(unsigned char reg_val)\n{\n\tswitch (reg_val) {\n\tcase 10: case 20: case 40: case 60: case 80: case 100: case 200:\n\t\t \n\t\treturn (reg_val >> 4) | (reg_val << 4);\n\tdefault:\n\t\treturn reg_val;\t \n\t}\n}\n\n \nstatic unsigned char fsp_test_invert_cmd(unsigned char reg_val)\n{\n\tswitch (reg_val) {\n\tcase 0xe9: case 0xee: case 0xf2: case 0xff:\n\t\t \n\t\treturn ~reg_val;\n\tdefault:\n\t\treturn reg_val;\t \n\t}\n}\n\nstatic int fsp_reg_read(struct psmouse *psmouse, int reg_addr, int *reg_val)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[3];\n\tunsigned char addr;\n\tint rc = -1;\n\n\t \n\tpsmouse_deactivate(psmouse);\n\n\tps2_begin_command(ps2dev);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\t \n\tps2_sendbyte(ps2dev, 0x66, FSP_CMD_TIMEOUT2);\n\t \n\tps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tif ((addr = fsp_test_invert_cmd(reg_addr)) != reg_addr) {\n\t\tps2_sendbyte(ps2dev, 0x68, FSP_CMD_TIMEOUT2);\n\t} else if ((addr = fsp_test_swap_cmd(reg_addr)) != reg_addr) {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0xcc, FSP_CMD_TIMEOUT2);\n\t\t \n\t} else {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x66, FSP_CMD_TIMEOUT2);\n\t\t \n\t}\n\t \n\tps2_sendbyte(ps2dev, addr, FSP_CMD_TIMEOUT);\n\n\tif (__ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) < 0)\n\t\tgoto out;\n\n\t*reg_val = param[2];\n\trc = 0;\n\n out:\n\tps2_end_command(ps2dev);\n\tpsmouse_activate(psmouse);\n\tpsmouse_dbg(psmouse,\n\t\t    \"READ REG: 0x%02x is 0x%02x (rc = %d)\\n\",\n\t\t    reg_addr, *reg_val, rc);\n\treturn rc;\n}\n\nstatic int fsp_reg_write(struct psmouse *psmouse, int reg_addr, int reg_val)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char v;\n\tint rc = -1;\n\n\tps2_begin_command(ps2dev);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tif ((v = fsp_test_invert_cmd(reg_addr)) != reg_addr) {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x74, FSP_CMD_TIMEOUT2);\n\t} else {\n\t\tif ((v = fsp_test_swap_cmd(reg_addr)) != reg_addr) {\n\t\t\t \n\t\t\tps2_sendbyte(ps2dev, 0x77, FSP_CMD_TIMEOUT2);\n\t\t} else {\n\t\t\t \n\t\t\tps2_sendbyte(ps2dev, 0x55, FSP_CMD_TIMEOUT2);\n\t\t}\n\t}\n\t \n\tps2_sendbyte(ps2dev, v, FSP_CMD_TIMEOUT2);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tif ((v = fsp_test_invert_cmd(reg_val)) != reg_val) {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x47, FSP_CMD_TIMEOUT2);\n\t} else if ((v = fsp_test_swap_cmd(reg_val)) != reg_val) {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x44, FSP_CMD_TIMEOUT2);\n\t} else {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x33, FSP_CMD_TIMEOUT2);\n\t}\n\n\t \n\tps2_sendbyte(ps2dev, v, FSP_CMD_TIMEOUT2);\n\trc = 0;\n\n out:\n\tps2_end_command(ps2dev);\n\tpsmouse_dbg(psmouse,\n\t\t    \"WRITE REG: 0x%02x to 0x%02x (rc = %d)\\n\",\n\t\t    reg_addr, reg_val, rc);\n\treturn rc;\n}\n\n \nstatic int fsp_reg_write_enable(struct psmouse *psmouse, bool enable)\n{\n\tint v, nv;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_SYSCTL1, &v) == -1)\n\t\treturn -1;\n\n\tif (enable)\n\t\tnv = v | FSP_BIT_EN_REG_CLK;\n\telse\n\t\tnv = v & ~FSP_BIT_EN_REG_CLK;\n\n\t \n\tif (nv != v)\n\t\tif (fsp_reg_write(psmouse, FSP_REG_SYSCTL1, nv) == -1)\n\t\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int fsp_page_reg_read(struct psmouse *psmouse, int *reg_val)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[3];\n\tint rc = -1;\n\n\tpsmouse_deactivate(psmouse);\n\n\tps2_begin_command(ps2dev);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tps2_sendbyte(ps2dev, 0x66, FSP_CMD_TIMEOUT2);\n\tps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tps2_sendbyte(ps2dev, 0x83, FSP_CMD_TIMEOUT2);\n\tps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\n\n\t \n\tif (__ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\n\t\tgoto out;\n\n\t*reg_val = param[2];\n\trc = 0;\n\n out:\n\tps2_end_command(ps2dev);\n\tpsmouse_activate(psmouse);\n\tpsmouse_dbg(psmouse,\n\t\t    \"READ PAGE REG: 0x%02x (rc = %d)\\n\",\n\t\t    *reg_val, rc);\n\treturn rc;\n}\n\nstatic int fsp_page_reg_write(struct psmouse *psmouse, int reg_val)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char v;\n\tint rc = -1;\n\n\tps2_begin_command(ps2dev);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tps2_sendbyte(ps2dev, 0x38, FSP_CMD_TIMEOUT2);\n\tps2_sendbyte(ps2dev, 0x88, FSP_CMD_TIMEOUT2);\n\n\tif (ps2_sendbyte(ps2dev, 0xf3, FSP_CMD_TIMEOUT) < 0)\n\t\tgoto out;\n\n\tif ((v = fsp_test_invert_cmd(reg_val)) != reg_val) {\n\t\tps2_sendbyte(ps2dev, 0x47, FSP_CMD_TIMEOUT2);\n\t} else if ((v = fsp_test_swap_cmd(reg_val)) != reg_val) {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x44, FSP_CMD_TIMEOUT2);\n\t} else {\n\t\t \n\t\tps2_sendbyte(ps2dev, 0x33, FSP_CMD_TIMEOUT2);\n\t}\n\n\tps2_sendbyte(ps2dev, v, FSP_CMD_TIMEOUT2);\n\trc = 0;\n\n out:\n\tps2_end_command(ps2dev);\n\tpsmouse_dbg(psmouse,\n\t\t    \"WRITE PAGE REG: to 0x%02x (rc = %d)\\n\",\n\t\t    reg_val, rc);\n\treturn rc;\n}\n\nstatic int fsp_get_version(struct psmouse *psmouse, int *version)\n{\n\tif (fsp_reg_read(psmouse, FSP_REG_VERSION, version))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int fsp_get_revision(struct psmouse *psmouse, int *rev)\n{\n\tif (fsp_reg_read(psmouse, FSP_REG_REVISION, rev))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int fsp_get_sn(struct psmouse *psmouse, int *sn)\n{\n\tint v0, v1, v2;\n\tint rc = -EIO;\n\n\t \n\tif (fsp_page_reg_write(psmouse, FSP_PAGE_0B))\n\t\tgoto out;\n\tif (fsp_reg_read(psmouse, FSP_REG_SN0, &v0))\n\t\tgoto out;\n\tif (fsp_reg_read(psmouse, FSP_REG_SN1, &v1))\n\t\tgoto out;\n\tif (fsp_reg_read(psmouse, FSP_REG_SN2, &v2))\n\t\tgoto out;\n\t*sn = (v0 << 16) | (v1 << 8) | v2;\n\trc = 0;\nout:\n\tfsp_page_reg_write(psmouse, FSP_PAGE_DEFAULT);\n\treturn rc;\n}\n\nstatic int fsp_get_buttons(struct psmouse *psmouse, int *btn)\n{\n\tstatic const int buttons[] = {\n\t\t0x16,  \n\t\t0x06,  \n\t\t0x04,  \n\t\t0x02,  \n\t};\n\tint val;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_TMOD_STATUS, &val) == -1)\n\t\treturn -EIO;\n\n\t*btn = buttons[(val & 0x30) >> 4];\n\treturn 0;\n}\n\n \nstatic int fsp_opc_tag_enable(struct psmouse *psmouse, bool enable)\n{\n\tint v, nv;\n\tint res = 0;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_OPC_QDOWN, &v) == -1) {\n\t\tpsmouse_err(psmouse, \"Unable get OPC state.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (enable)\n\t\tnv = v | FSP_BIT_EN_OPC_TAG;\n\telse\n\t\tnv = v & ~FSP_BIT_EN_OPC_TAG;\n\n\t \n\tif (nv != v) {\n\t\tfsp_reg_write_enable(psmouse, true);\n\t\tres = fsp_reg_write(psmouse, FSP_REG_OPC_QDOWN, nv);\n\t\tfsp_reg_write_enable(psmouse, false);\n\t}\n\n\tif (res != 0) {\n\t\tpsmouse_err(psmouse, \"Unable to enable OPC tag.\\n\");\n\t\tres = -EIO;\n\t}\n\n\treturn res;\n}\n\nstatic int fsp_onpad_vscr(struct psmouse *psmouse, bool enable)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\tint val;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_ONPAD_CTL, &val))\n\t\treturn -EIO;\n\n\tpad->vscroll = enable;\n\n\tif (enable)\n\t\tval |= (FSP_BIT_FIX_VSCR | FSP_BIT_ONPAD_ENABLE);\n\telse\n\t\tval &= ~FSP_BIT_FIX_VSCR;\n\n\tif (fsp_reg_write(psmouse, FSP_REG_ONPAD_CTL, val))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int fsp_onpad_hscr(struct psmouse *psmouse, bool enable)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\tint val, v2;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_ONPAD_CTL, &val))\n\t\treturn -EIO;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_SYSCTL5, &v2))\n\t\treturn -EIO;\n\n\tpad->hscroll = enable;\n\n\tif (enable) {\n\t\tval |= (FSP_BIT_FIX_HSCR | FSP_BIT_ONPAD_ENABLE);\n\t\tv2 |= FSP_BIT_EN_MSID6;\n\t} else {\n\t\tval &= ~FSP_BIT_FIX_HSCR;\n\t\tv2 &= ~(FSP_BIT_EN_MSID6 | FSP_BIT_EN_MSID7 | FSP_BIT_EN_MSID8);\n\t}\n\n\tif (fsp_reg_write(psmouse, FSP_REG_ONPAD_CTL, val))\n\t\treturn -EIO;\n\n\t \n\tif (fsp_reg_write(psmouse, FSP_REG_SYSCTL5, v2))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic ssize_t fsp_attr_set_setreg(struct psmouse *psmouse, void *data,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned int reg, val;\n\tchar *rest;\n\tssize_t retval;\n\n\treg = simple_strtoul(buf, &rest, 16);\n\tif (rest == buf || *rest != ' ' || reg > 0xff)\n\t\treturn -EINVAL;\n\n\tretval = kstrtouint(rest + 1, 16, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tif (val > 0xff)\n\t\treturn -EINVAL;\n\n\tif (fsp_reg_write_enable(psmouse, true))\n\t\treturn -EIO;\n\n\tretval = fsp_reg_write(psmouse, reg, val) < 0 ? -EIO : count;\n\n\tfsp_reg_write_enable(psmouse, false);\n\n\treturn retval;\n}\n\nPSMOUSE_DEFINE_WO_ATTR(setreg, S_IWUSR, NULL, fsp_attr_set_setreg);\n\nstatic ssize_t fsp_attr_show_getreg(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\n\treturn sprintf(buf, \"%02x%02x\\n\", pad->last_reg, pad->last_val);\n}\n\n \nstatic ssize_t fsp_attr_set_getreg(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\tunsigned int reg, val;\n\tint err;\n\n\terr = kstrtouint(buf, 16, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (reg > 0xff)\n\t\treturn -EINVAL;\n\n\tif (fsp_reg_read(psmouse, reg, &val))\n\t\treturn -EIO;\n\n\tpad->last_reg = reg;\n\tpad->last_val = val;\n\n\treturn count;\n}\n\nPSMOUSE_DEFINE_ATTR(getreg, S_IWUSR | S_IRUGO, NULL,\n\t\t\tfsp_attr_show_getreg, fsp_attr_set_getreg);\n\nstatic ssize_t fsp_attr_show_pagereg(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\tint val = 0;\n\n\tif (fsp_page_reg_read(psmouse, &val))\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%02x\\n\", val);\n}\n\nstatic ssize_t fsp_attr_set_pagereg(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = kstrtouint(buf, 16, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 0xff)\n\t\treturn -EINVAL;\n\n\tif (fsp_page_reg_write(psmouse, val))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nPSMOUSE_DEFINE_ATTR(page, S_IWUSR | S_IRUGO, NULL,\n\t\t\tfsp_attr_show_pagereg, fsp_attr_set_pagereg);\n\nstatic ssize_t fsp_attr_show_vscroll(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\n\treturn sprintf(buf, \"%d\\n\", pad->vscroll);\n}\n\nstatic ssize_t fsp_attr_set_vscroll(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tfsp_onpad_vscr(psmouse, val);\n\n\treturn count;\n}\n\nPSMOUSE_DEFINE_ATTR(vscroll, S_IWUSR | S_IRUGO, NULL,\n\t\t\tfsp_attr_show_vscroll, fsp_attr_set_vscroll);\n\nstatic ssize_t fsp_attr_show_hscroll(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\n\treturn sprintf(buf, \"%d\\n\", pad->hscroll);\n}\n\nstatic ssize_t fsp_attr_set_hscroll(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tfsp_onpad_hscr(psmouse, val);\n\n\treturn count;\n}\n\nPSMOUSE_DEFINE_ATTR(hscroll, S_IWUSR | S_IRUGO, NULL,\n\t\t\tfsp_attr_show_hscroll, fsp_attr_set_hscroll);\n\nstatic ssize_t fsp_attr_show_flags(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\n\treturn sprintf(buf, \"%c\\n\",\n\t\t\tpad->flags & FSPDRV_FLAG_EN_OPC ? 'C' : 'c');\n}\n\nstatic ssize_t fsp_attr_set_flags(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\tsize_t i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tswitch (buf[i]) {\n\t\tcase 'C':\n\t\t\tpad->flags |= FSPDRV_FLAG_EN_OPC;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tpad->flags &= ~FSPDRV_FLAG_EN_OPC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn count;\n}\n\nPSMOUSE_DEFINE_ATTR(flags, S_IWUSR | S_IRUGO, NULL,\n\t\t\tfsp_attr_show_flags, fsp_attr_set_flags);\n\nstatic ssize_t fsp_attr_show_ver(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\treturn sprintf(buf, \"Sentelic FSP kernel module %s\\n\", fsp_drv_ver);\n}\n\nPSMOUSE_DEFINE_RO_ATTR(ver, S_IRUGO, NULL, fsp_attr_show_ver);\n\nstatic struct attribute *fsp_attributes[] = {\n\t&psmouse_attr_setreg.dattr.attr,\n\t&psmouse_attr_getreg.dattr.attr,\n\t&psmouse_attr_page.dattr.attr,\n\t&psmouse_attr_vscroll.dattr.attr,\n\t&psmouse_attr_hscroll.dattr.attr,\n\t&psmouse_attr_flags.dattr.attr,\n\t&psmouse_attr_ver.dattr.attr,\n\tNULL\n};\n\nstatic struct attribute_group fsp_attribute_group = {\n\t.attrs = fsp_attributes,\n};\n\n#ifdef\tFSP_DEBUG\nstatic void fsp_packet_debug(struct psmouse *psmouse, unsigned char packet[])\n{\n\tstatic unsigned int ps2_packet_cnt;\n\tstatic unsigned int ps2_last_second;\n\tunsigned int jiffies_msec;\n\tconst char *packet_type = \"UNKNOWN\";\n\tunsigned short abs_x = 0, abs_y = 0;\n\n\t \n\tswitch (packet[0] >> FSP_PKT_TYPE_SHIFT) {\n\tcase FSP_PKT_TYPE_ABS:\n\t\tpacket_type = \"Absolute\";\n\t\tabs_x = GET_ABS_X(packet);\n\t\tabs_y = GET_ABS_Y(packet);\n\t\tbreak;\n\tcase FSP_PKT_TYPE_NORMAL:\n\t\tpacket_type = \"Normal\";\n\t\tbreak;\n\tcase FSP_PKT_TYPE_NOTIFY:\n\t\tpacket_type = \"Notify\";\n\t\tbreak;\n\tcase FSP_PKT_TYPE_NORMAL_OPC:\n\t\tpacket_type = \"Normal-OPC\";\n\t\tbreak;\n\t}\n\n\tps2_packet_cnt++;\n\tjiffies_msec = jiffies_to_msecs(jiffies);\n\tpsmouse_dbg(psmouse,\n\t\t    \"%08dms %s packets: %02x, %02x, %02x, %02x; \"\n\t\t    \"abs_x: %d, abs_y: %d\\n\",\n\t\t    jiffies_msec, packet_type,\n\t\t    packet[0], packet[1], packet[2], packet[3], abs_x, abs_y);\n\n\tif (jiffies_msec - ps2_last_second > 1000) {\n\t\tpsmouse_dbg(psmouse, \"PS/2 packets/sec = %d\\n\", ps2_packet_cnt);\n\t\tps2_packet_cnt = 0;\n\t\tps2_last_second = jiffies_msec;\n\t}\n}\n#else\nstatic void fsp_packet_debug(struct psmouse *psmouse, unsigned char packet[])\n{\n}\n#endif\n\nstatic void fsp_set_slot(struct input_dev *dev, int slot, bool active,\n\t\t\t unsigned int x, unsigned int y)\n{\n\tinput_mt_slot(dev, slot);\n\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\n\tif (active) {\n\t\tinput_report_abs(dev, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_Y, y);\n\t}\n}\n\nstatic psmouse_ret_t fsp_process_byte(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct fsp_data *ad = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tunsigned char button_status = 0, lscroll = 0, rscroll = 0;\n\tunsigned short abs_x, abs_y, fgrs = 0;\n\n\tif (psmouse->pktcnt < 4)\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\t \n\n\tfsp_packet_debug(psmouse, packet);\n\n\tswitch (psmouse->packet[0] >> FSP_PKT_TYPE_SHIFT) {\n\tcase FSP_PKT_TYPE_ABS:\n\n\t\tif ((packet[0] == 0x48 || packet[0] == 0x49) &&\n\t\t    packet[1] == 0 && packet[2] == 0) {\n\t\t\t \n\t\t\tpacket[3] &= 0xf0;\n\t\t}\n\n\t\tabs_x = GET_ABS_X(packet);\n\t\tabs_y = GET_ABS_Y(packet);\n\n\t\tif (packet[0] & FSP_PB0_MFMC) {\n\t\t\t \n\t\t\tfgrs = 2;\n\n\t\t\t \n\t\t\tif (packet[0] & FSP_PB0_MFMC_FGR2) {\n\t\t\t\t \n\t\t\t\tif (ad->last_mt_fgr == 2) {\n\t\t\t\t\t \n\t\t\t\t\tfgrs = 1;\n\t\t\t\t\tfsp_set_slot(dev, 0, false, 0, 0);\n\t\t\t\t}\n\t\t\t\tad->last_mt_fgr = 2;\n\n\t\t\t\tfsp_set_slot(dev, 1, fgrs == 2, abs_x, abs_y);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (ad->last_mt_fgr == 1) {\n\t\t\t\t\t \n\t\t\t\t\tfgrs = 1;\n\t\t\t\t\tfsp_set_slot(dev, 1, false, 0, 0);\n\t\t\t\t}\n\t\t\t\tad->last_mt_fgr = 1;\n\t\t\t\tfsp_set_slot(dev, 0, fgrs != 0, abs_x, abs_y);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((packet[0] & (FSP_PB0_LBTN|FSP_PB0_PHY_BTN)) ==\n\t\t\t\tFSP_PB0_LBTN) {\n\t\t\t\t \n\t\t\t\tpacket[0] &= ~FSP_PB0_LBTN;\n\t\t\t}\n\n\t\t\t \n\t\t\tad->last_mt_fgr = 0;\n\n\t\t\tif (abs_x != 0 && abs_y != 0)\n\t\t\t\tfgrs = 1;\n\n\t\t\tfsp_set_slot(dev, 0, fgrs > 0, abs_x, abs_y);\n\t\t\tfsp_set_slot(dev, 1, false, 0, 0);\n\t\t}\n\t\tif (fgrs == 1 || (fgrs == 2 && !(packet[0] & FSP_PB0_MFMC_FGR2))) {\n\t\t\tinput_report_abs(dev, ABS_X, abs_x);\n\t\t\tinput_report_abs(dev, ABS_Y, abs_y);\n\t\t}\n\t\tinput_report_key(dev, BTN_LEFT, packet[0] & 0x01);\n\t\tinput_report_key(dev, BTN_RIGHT, packet[0] & 0x02);\n\t\tinput_report_key(dev, BTN_TOUCH, fgrs);\n\t\tinput_report_key(dev, BTN_TOOL_FINGER, fgrs == 1);\n\t\tinput_report_key(dev, BTN_TOOL_DOUBLETAP, fgrs == 2);\n\t\tbreak;\n\n\tcase FSP_PKT_TYPE_NORMAL_OPC:\n\t\t \n\t\tif ((ad->flags & FSPDRV_FLAG_EN_OPC) != FSPDRV_FLAG_EN_OPC)\n\t\t\tpacket[0] &= ~FSP_PB0_LBTN;\n\t\tfallthrough;\n\n\tcase FSP_PKT_TYPE_NORMAL:\n\t\t \n\t\t \n\t\tif (packet[3] != 0) {\n\t\t\tif (packet[3] & BIT(0))\n\t\t\t\tbutton_status |= 0x01;\t \n\t\t\tif (packet[3] & BIT(1))\n\t\t\t\tbutton_status |= 0x0f;\t \n\t\t\tif (packet[3] & BIT(2))\n\t\t\t\tbutton_status |= BIT(4); \n\t\t\tif (packet[3] & BIT(3))\n\t\t\t\tbutton_status |= BIT(5); \n\t\t\t \n\t\t\tif (button_status != 0)\n\t\t\t\tpacket[3] = button_status;\n\t\t\trscroll = (packet[3] >> 4) & 1;\n\t\t\tlscroll = (packet[3] >> 5) & 1;\n\t\t}\n\t\t \n\t\tinput_report_rel(dev, REL_WHEEL,\n\t\t\t\t (int)(packet[3] & 8) - (int)(packet[3] & 7));\n\t\tinput_report_rel(dev, REL_HWHEEL, lscroll - rscroll);\n\t\tinput_report_key(dev, BTN_BACK, lscroll);\n\t\tinput_report_key(dev, BTN_FORWARD, rscroll);\n\n\t\t \n\t\tpsmouse_report_standard_packet(dev, packet);\n\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n\n\treturn PSMOUSE_FULL_PACKET;\n}\n\nstatic int fsp_activate_protocol(struct psmouse *psmouse)\n{\n\tstruct fsp_data *pad = psmouse->private;\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[2];\n\tint val;\n\n\t \n\tparam[0] = 200;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] = 200;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] =  80;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\n\tps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\n\tif (param[0] != 0x04) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"Unable to enable 4 bytes packet format.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (pad->ver < FSP_VER_STL3888_C0) {\n\t\t \n\t\tif (fsp_reg_read(psmouse, FSP_REG_SYSCTL5, &val)) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Unable to read SYSCTL5 register.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (fsp_get_buttons(psmouse, &pad->buttons)) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Unable to retrieve number of buttons.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tval &= ~(FSP_BIT_EN_MSID7 | FSP_BIT_EN_MSID8 | FSP_BIT_EN_AUTO_MSID8);\n\t\t \n\t\tval &= ~FSP_BIT_EN_PKT_G0;\n\t\tif (pad->buttons == 0x06) {\n\t\t\t \n\t\t\tval |= FSP_BIT_EN_MSID6;\n\t\t}\n\n\t\tif (fsp_reg_write(psmouse, FSP_REG_SYSCTL5, val)) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Unable to set up required mode bits.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (fsp_opc_tag_enable(psmouse, true))\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"Failed to enable OPC tag mode.\\n\");\n\t\t \n\t\tpad->flags |= FSPDRV_FLAG_EN_OPC;\n\n\t\t \n\t\tfsp_onpad_vscr(psmouse, true);\n\t\tfsp_onpad_hscr(psmouse, true);\n\t} else {\n\t\t \n\t\tif (fsp_reg_write(psmouse, FSP_REG_SWC1,\n\t\t\t\t  FSP_BIT_SWC1_EN_ABS_1F |\n\t\t\t\t  FSP_BIT_SWC1_EN_ABS_2F |\n\t\t\t\t  FSP_BIT_SWC1_EN_FUP_OUT |\n\t\t\t\t  FSP_BIT_SWC1_EN_ABS_CON)) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Unable to enable absolute coordinates output.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsp_set_input_params(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct fsp_data *pad = psmouse->private;\n\n\tif (pad->ver < FSP_VER_STL3888_C0) {\n\t\t__set_bit(BTN_MIDDLE, dev->keybit);\n\t\t__set_bit(BTN_BACK, dev->keybit);\n\t\t__set_bit(BTN_FORWARD, dev->keybit);\n\t\t__set_bit(REL_WHEEL, dev->relbit);\n\t\t__set_bit(REL_HWHEEL, dev->relbit);\n\t} else {\n\t\t \n\t\tint abs_x = 967, abs_y = 711;\n\n\t\t__set_bit(EV_ABS, dev->evbit);\n\t\t__clear_bit(EV_REL, dev->evbit);\n\t\t__set_bit(BTN_TOUCH, dev->keybit);\n\t\t__set_bit(BTN_TOOL_FINGER, dev->keybit);\n\t\t__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\n\t\t__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\n\n\t\tinput_set_abs_params(dev, ABS_X, 0, abs_x, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_Y, 0, abs_y, 0, 0);\n\t\tinput_mt_init_slots(dev, 2, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_X, 0, abs_x, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_Y, 0, abs_y, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nint fsp_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tint id;\n\n\tif (fsp_reg_read(psmouse, FSP_REG_DEVICE_ID, &id))\n\t\treturn -EIO;\n\n\tif (id != 0x01)\n\t\treturn -ENODEV;\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"Sentelic\";\n\t\tpsmouse->name = \"FingerSensingPad\";\n\t}\n\n\treturn 0;\n}\n\nstatic void fsp_reset(struct psmouse *psmouse)\n{\n\tfsp_opc_tag_enable(psmouse, false);\n\tfsp_onpad_vscr(psmouse, false);\n\tfsp_onpad_hscr(psmouse, false);\n}\n\nstatic void fsp_disconnect(struct psmouse *psmouse)\n{\n\tsysfs_remove_group(&psmouse->ps2dev.serio->dev.kobj,\n\t\t\t   &fsp_attribute_group);\n\n\tfsp_reset(psmouse);\n\tkfree(psmouse->private);\n}\n\nstatic int fsp_reconnect(struct psmouse *psmouse)\n{\n\tint version;\n\n\tif (fsp_detect(psmouse, 0))\n\t\treturn -ENODEV;\n\n\tif (fsp_get_version(psmouse, &version))\n\t\treturn -ENODEV;\n\n\tif (fsp_activate_protocol(psmouse))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint fsp_init(struct psmouse *psmouse)\n{\n\tstruct fsp_data *priv;\n\tint ver, rev, sn = 0;\n\tint error;\n\n\tif (fsp_get_version(psmouse, &ver) ||\n\t    fsp_get_revision(psmouse, &rev)) {\n\t\treturn -ENODEV;\n\t}\n\tif (ver >= FSP_VER_STL3888_C0) {\n\t\t \n\t\tfsp_get_sn(psmouse, &sn);\n\t}\n\n\tpsmouse_info(psmouse,\n\t\t     \"Finger Sensing Pad, hw: %d.%d.%d, sn: %x, sw: %s\\n\",\n\t\t     ver >> 4, ver & 0x0F, rev, sn, fsp_drv_ver);\n\n\tpsmouse->private = priv = kzalloc(sizeof(struct fsp_data), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ver = ver;\n\tpriv->rev = rev;\n\n\tpsmouse->protocol_handler = fsp_process_byte;\n\tpsmouse->disconnect = fsp_disconnect;\n\tpsmouse->reconnect = fsp_reconnect;\n\tpsmouse->cleanup = fsp_reset;\n\tpsmouse->pktsize = 4;\n\n\terror = fsp_activate_protocol(psmouse);\n\tif (error)\n\t\tgoto err_out;\n\n\t \n\terror = fsp_set_input_params(psmouse);\n\tif (error)\n\t\tgoto err_out;\n\n\terror = sysfs_create_group(&psmouse->ps2dev.serio->dev.kobj,\n\t\t\t\t   &fsp_attribute_group);\n\tif (error) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"Failed to create sysfs attributes (%d)\", error);\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\n err_out:\n\tkfree(psmouse->private);\n\tpsmouse->private = NULL;\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}