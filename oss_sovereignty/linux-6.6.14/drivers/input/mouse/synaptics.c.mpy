{
  "module_name": "synaptics.c",
  "hash_id": "9287d14b79ebe40e3a15f0cae769514a427625d22a09b66f093318f07cf4cb56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/synaptics.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/input/mt.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <linux/rmi.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include \"psmouse.h\"\n#include \"synaptics.h\"\n\n \n#define XMIN 0\n#define XMAX 6143\n#define YMIN 0\n#define YMAX 6143\n#define XMIN_NOMINAL 1472\n#define XMAX_NOMINAL 5472\n#define YMIN_NOMINAL 1408\n#define YMAX_NOMINAL 4448\n\n \n#define ABS_POS_BITS 13\n\n \n#define X_MAX_POSITIVE 8176\n#define Y_MAX_POSITIVE 8176\n\n \n#define DMAX 10\n\n \n\n \nstatic int synaptics_mode_cmd(struct psmouse *psmouse, u8 mode)\n{\n\tu8 param[1];\n\tint error;\n\n\terror = ps2_sliced_command(&psmouse->ps2dev, mode);\n\tif (error)\n\t\treturn error;\n\n\tparam[0] = SYN_PS_SET_MODE2;\n\terror = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nint synaptics_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param[4] = { 0 };\n\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO);\n\n\tif (param[1] != 0x47)\n\t\treturn -ENODEV;\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"Synaptics\";\n\t\tpsmouse->name = \"TouchPad\";\n\t}\n\n\treturn 0;\n}\n\nvoid synaptics_reset(struct psmouse *psmouse)\n{\n\t \n\tsynaptics_mode_cmd(psmouse, 0);\n}\n\n#if defined(CONFIG_MOUSE_PS2_SYNAPTICS) || \\\n    defined(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)\n\n \nstatic const char * const topbuttonpad_pnp_ids[] = {\n\t\"LEN0017\",\n\t\"LEN0018\",\n\t\"LEN0019\",\n\t\"LEN0023\",\n\t\"LEN002A\",\n\t\"LEN002B\",\n\t\"LEN002C\",\n\t\"LEN002D\",\n\t\"LEN002E\",\n\t\"LEN0033\",  \n\t\"LEN0034\",  \n\t\"LEN0035\",  \n\t\"LEN0036\",  \n\t\"LEN0037\",  \n\t\"LEN0038\",\n\t\"LEN0039\",  \n\t\"LEN0041\",\n\t\"LEN0042\",  \n\t\"LEN0045\",\n\t\"LEN0047\",\n\t\"LEN2000\",  \n\t\"LEN2001\",  \n\t\"LEN2002\",  \n\t\"LEN2003\",\n\t\"LEN2004\",  \n\t\"LEN2005\",\n\t\"LEN2006\",  \n\t\"LEN2007\",\n\t\"LEN2008\",\n\t\"LEN2009\",\n\t\"LEN200A\",\n\t\"LEN200B\",\n\tNULL\n};\n\nstatic const char * const smbus_pnp_ids[] = {\n\t \n\t\"LEN0048\",  \n\t\"LEN0046\",  \n\t\"LEN0049\",  \n\t\"LEN004a\",  \n\t\"LEN005b\",  \n\t\"LEN005e\",  \n\t\"LEN006c\",  \n\t\"LEN007a\",  \n\t\"LEN0071\",  \n\t\"LEN0072\",  \n\t\"LEN0073\",  \n\t\"LEN0091\",  \n\t\"LEN0092\",  \n\t\"LEN0093\",  \n\t\"LEN0096\",  \n\t\"LEN0097\",  \n\t\"LEN0099\",  \n\t\"LEN009b\",  \n\t\"LEN0402\",  \n\t\"LEN040f\",  \n\t\"LEN0411\",  \n\t\"LEN200f\",  \n\t\"LEN2044\",  \n\t\"LEN2054\",  \n\t\"LEN2055\",  \n\t\"LEN2068\",  \n\t\"SYN3052\",  \n\t\"SYN3221\",  \n\t\"SYN323d\",  \n\t\"SYN3257\",  \n\tNULL\n};\n\nstatic const char * const forcepad_pnp_ids[] = {\n\t\"SYN300D\",\n\t\"SYN3014\",\n\tNULL\n};\n\n \nstatic int synaptics_send_cmd(struct psmouse *psmouse, u8 cmd, u8 *param)\n{\n\tint error;\n\n\terror = ps2_sliced_command(&psmouse->ps2dev, cmd);\n\tif (error)\n\t\treturn error;\n\n\terror = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int synaptics_query_int(struct psmouse *psmouse, u8 query_cmd, u32 *val)\n{\n\tint error;\n\tunion {\n\t\t__be32 be_val;\n\t\tchar buf[4];\n\t} resp = { 0 };\n\n\terror = synaptics_send_cmd(psmouse, query_cmd, resp.buf + 1);\n\tif (error)\n\t\treturn error;\n\n\t*val = be32_to_cpu(resp.be_val);\n\treturn 0;\n}\n\n \nstatic int synaptics_identify(struct psmouse *psmouse,\n\t\t\t      struct synaptics_device_info *info)\n{\n\tint error;\n\n\terror = synaptics_query_int(psmouse, SYN_QUE_IDENTIFY, &info->identity);\n\tif (error)\n\t\treturn error;\n\n\treturn SYN_ID_IS_SYNAPTICS(info->identity) ? 0 : -ENXIO;\n}\n\n \nstatic int synaptics_model_id(struct psmouse *psmouse,\n\t\t\t      struct synaptics_device_info *info)\n{\n\treturn synaptics_query_int(psmouse, SYN_QUE_MODEL, &info->model_id);\n}\n\n \nstatic int synaptics_firmware_id(struct psmouse *psmouse,\n\t\t\t\t struct synaptics_device_info *info)\n{\n\treturn synaptics_query_int(psmouse, SYN_QUE_FIRMWARE_ID,\n\t\t\t\t   &info->firmware_id);\n}\n\n \nstatic int synaptics_query_modes(struct psmouse *psmouse,\n\t\t\t\t struct synaptics_device_info *info)\n{\n\tu8 bid[3];\n\tint error;\n\n\t \n\tif (SYN_ID_FULL(info->identity) < 0x705)\n\t\treturn 0;\n\n\terror = synaptics_send_cmd(psmouse, SYN_QUE_MODES, bid);\n\tif (error)\n\t\treturn error;\n\n\tinfo->board_id = ((bid[0] & 0xfc) << 6) | bid[1];\n\n\tif (SYN_MEXT_CAP_BIT(bid[0]))\n\t\treturn synaptics_query_int(psmouse, SYN_QUE_MEXT_CAPAB_10,\n\t\t\t\t\t   &info->ext_cap_10);\n\n\treturn 0;\n}\n\n \nstatic int synaptics_capability(struct psmouse *psmouse,\n\t\t\t\tstruct synaptics_device_info *info)\n{\n\tint error;\n\n\terror = synaptics_query_int(psmouse, SYN_QUE_CAPABILITIES,\n\t\t\t\t    &info->capabilities);\n\tif (error)\n\t\treturn error;\n\n\tinfo->ext_cap = info->ext_cap_0c = 0;\n\n\t \n\tif (SYN_ID_FULL(info->identity) < 0x705 &&\n\t    SYN_CAP_SUBMODEL_ID(info->capabilities) != 0x47) {\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (!SYN_CAP_EXTENDED(info->capabilities))\n\t\tinfo->capabilities = 0;\n\n\tif (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 1) {\n\t\terror = synaptics_query_int(psmouse, SYN_QUE_EXT_CAPAB,\n\t\t\t\t\t    &info->ext_cap);\n\t\tif (error) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"device claims to have extended capabilities, but I'm not able to read them.\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tif (SYN_CAP_MULTI_BUTTON_NO(info->ext_cap) > 8)\n\t\t\t\tinfo->ext_cap &= ~SYN_CAP_MB_MASK;\n\t\t}\n\t}\n\n\tif (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 4) {\n\t\terror = synaptics_query_int(psmouse, SYN_QUE_EXT_CAPAB_0C,\n\t\t\t\t\t    &info->ext_cap_0c);\n\t\tif (error)\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"device claims to have extended capability 0x0c, but I'm not able to read it.\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int synaptics_resolution(struct psmouse *psmouse,\n\t\t\t\tstruct synaptics_device_info *info)\n{\n\tu8 resp[3];\n\tint error;\n\n\tif (SYN_ID_MAJOR(info->identity) < 4)\n\t\treturn 0;\n\n\terror = synaptics_send_cmd(psmouse, SYN_QUE_RESOLUTION, resp);\n\tif (!error) {\n\t\tif (resp[0] != 0 && (resp[1] & 0x80) && resp[2] != 0) {\n\t\t\tinfo->x_res = resp[0];  \n\t\t\tinfo->y_res = resp[2];  \n\t\t}\n\t}\n\n\tif (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 5 &&\n\t    SYN_CAP_MAX_DIMENSIONS(info->ext_cap_0c)) {\n\t\terror = synaptics_send_cmd(psmouse,\n\t\t\t\t\t   SYN_QUE_EXT_MAX_COORDS, resp);\n\t\tif (error) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"device claims to have max coordinates query, but I'm not able to read it.\\n\");\n\t\t} else {\n\t\t\tinfo->x_max = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);\n\t\t\tinfo->y_max = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);\n\t\t\tpsmouse_info(psmouse,\n\t\t\t\t     \"queried max coordinates: x [..%d], y [..%d]\\n\",\n\t\t\t\t     info->x_max, info->y_max);\n\t\t}\n\t}\n\n\tif (SYN_CAP_MIN_DIMENSIONS(info->ext_cap_0c) &&\n\t    (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 7 ||\n\t      \n\t     SYN_ID_FULL(info->identity) == 0x801)) {\n\t\terror = synaptics_send_cmd(psmouse,\n\t\t\t\t\t   SYN_QUE_EXT_MIN_COORDS, resp);\n\t\tif (error) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"device claims to have min coordinates query, but I'm not able to read it.\\n\");\n\t\t} else {\n\t\t\tinfo->x_min = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);\n\t\t\tinfo->y_min = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);\n\t\t\tpsmouse_info(psmouse,\n\t\t\t\t     \"queried min coordinates: x [%d..], y [%d..]\\n\",\n\t\t\t\t     info->x_min, info->y_min);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int synaptics_query_hardware(struct psmouse *psmouse,\n\t\t\t\t    struct synaptics_device_info *info)\n{\n\tint error;\n\n\tmemset(info, 0, sizeof(*info));\n\n\terror = synaptics_identify(psmouse, info);\n\tif (error)\n\t\treturn error;\n\n\terror = synaptics_model_id(psmouse, info);\n\tif (error)\n\t\treturn error;\n\n\terror = synaptics_firmware_id(psmouse, info);\n\tif (error)\n\t\treturn error;\n\n\terror = synaptics_query_modes(psmouse, info);\n\tif (error)\n\t\treturn error;\n\n\terror = synaptics_capability(psmouse, info);\n\tif (error)\n\t\treturn error;\n\n\terror = synaptics_resolution(psmouse, info);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_MOUSE_PS2_SYNAPTICS\n\nstatic bool cr48_profile_sensor;\n\n#define ANY_BOARD_ID 0\nstruct min_max_quirk {\n\tconst char * const *pnp_ids;\n\tstruct {\n\t\tu32 min, max;\n\t} board_id;\n\tu32 x_min, x_max, y_min, y_max;\n};\n\nstatic const struct min_max_quirk min_max_pnpid_table[] = {\n\t{\n\t\t(const char * const []){\"LEN0033\", NULL},\n\t\t{ANY_BOARD_ID, ANY_BOARD_ID},\n\t\t1024, 5052, 2258, 4832\n\t},\n\t{\n\t\t(const char * const []){\"LEN0042\", NULL},\n\t\t{ANY_BOARD_ID, ANY_BOARD_ID},\n\t\t1232, 5710, 1156, 4696\n\t},\n\t{\n\t\t(const char * const []){\"LEN0034\", \"LEN0036\", \"LEN0037\",\n\t\t\t\t\t\"LEN0039\", \"LEN2002\", \"LEN2004\",\n\t\t\t\t\tNULL},\n\t\t{ANY_BOARD_ID, 2961},\n\t\t1024, 5112, 2024, 4832\n\t},\n\t{\n\t\t(const char * const []){\"LEN2000\", NULL},\n\t\t{ANY_BOARD_ID, ANY_BOARD_ID},\n\t\t1024, 5113, 2021, 4832\n\t},\n\t{\n\t\t(const char * const []){\"LEN2001\", NULL},\n\t\t{ANY_BOARD_ID, ANY_BOARD_ID},\n\t\t1024, 5022, 2508, 4832\n\t},\n\t{\n\t\t(const char * const []){\"LEN2006\", NULL},\n\t\t{2691, 2691},\n\t\t1024, 5045, 2457, 4832\n\t},\n\t{\n\t\t(const char * const []){\"LEN2006\", NULL},\n\t\t{ANY_BOARD_ID, ANY_BOARD_ID},\n\t\t1264, 5675, 1171, 4688\n\t},\n\t{ }\n};\n\n \n\n \nstatic int synaptics_invert_y(int y)\n{\n\treturn YMAX_NOMINAL + YMIN_NOMINAL - y;\n}\n\n \nstatic void synaptics_apply_quirks(struct psmouse *psmouse,\n\t\t\t\t   struct synaptics_device_info *info)\n{\n\tint i;\n\n\tfor (i = 0; min_max_pnpid_table[i].pnp_ids; i++) {\n\t\tif (!psmouse_matches_pnp_id(psmouse,\n\t\t\t\t\t    min_max_pnpid_table[i].pnp_ids))\n\t\t\tcontinue;\n\n\t\tif (min_max_pnpid_table[i].board_id.min != ANY_BOARD_ID &&\n\t\t    info->board_id < min_max_pnpid_table[i].board_id.min)\n\t\t\tcontinue;\n\n\t\tif (min_max_pnpid_table[i].board_id.max != ANY_BOARD_ID &&\n\t\t    info->board_id > min_max_pnpid_table[i].board_id.max)\n\t\t\tcontinue;\n\n\t\tinfo->x_min = min_max_pnpid_table[i].x_min;\n\t\tinfo->x_max = min_max_pnpid_table[i].x_max;\n\t\tinfo->y_min = min_max_pnpid_table[i].y_min;\n\t\tinfo->y_max = min_max_pnpid_table[i].y_max;\n\t\tpsmouse_info(psmouse,\n\t\t\t     \"quirked min/max coordinates: x [%d..%d], y [%d..%d]\\n\",\n\t\t\t     info->x_min, info->x_max,\n\t\t\t     info->y_min, info->y_max);\n\t\tbreak;\n\t}\n}\n\nstatic bool synaptics_has_agm(struct synaptics_data *priv)\n{\n\treturn (SYN_CAP_ADV_GESTURE(priv->info.ext_cap_0c) ||\n\t\tSYN_CAP_IMAGE_SENSOR(priv->info.ext_cap_0c));\n}\n\nstatic int synaptics_set_advanced_gesture_mode(struct psmouse *psmouse)\n{\n\tstatic u8 param = 0xc8;\n\tint error;\n\n\terror = ps2_sliced_command(&psmouse->ps2dev, SYN_QUE_MODEL);\n\tif (error)\n\t\treturn error;\n\n\terror = ps2_command(&psmouse->ps2dev, &param, PSMOUSE_CMD_SETRATE);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int synaptics_set_mode(struct psmouse *psmouse)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\tint error;\n\n\tpriv->mode = 0;\n\tif (priv->absolute_mode)\n\t\tpriv->mode |= SYN_BIT_ABSOLUTE_MODE;\n\tif (priv->disable_gesture)\n\t\tpriv->mode |= SYN_BIT_DISABLE_GESTURE;\n\tif (psmouse->rate >= 80)\n\t\tpriv->mode |= SYN_BIT_HIGH_RATE;\n\tif (SYN_CAP_EXTENDED(priv->info.capabilities))\n\t\tpriv->mode |= SYN_BIT_W_MODE;\n\n\terror = synaptics_mode_cmd(psmouse, priv->mode);\n\tif (error)\n\t\treturn error;\n\n\tif (priv->absolute_mode && synaptics_has_agm(priv)) {\n\t\terror = synaptics_set_advanced_gesture_mode(psmouse);\n\t\tif (error) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Advanced gesture mode init failed: %d\\n\",\n\t\t\t\t    error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void synaptics_set_rate(struct psmouse *psmouse, unsigned int rate)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\n\tif (rate >= 80) {\n\t\tpriv->mode |= SYN_BIT_HIGH_RATE;\n\t\tpsmouse->rate = 80;\n\t} else {\n\t\tpriv->mode &= ~SYN_BIT_HIGH_RATE;\n\t\tpsmouse->rate = 40;\n\t}\n\n\tsynaptics_mode_cmd(psmouse, priv->mode);\n}\n\n \nstatic int synaptics_pt_write(struct serio *serio, u8 c)\n{\n\tstruct psmouse *parent = psmouse_from_serio(serio->parent);\n\tu8 rate_param = SYN_PS_CLIENT_CMD;  \n\tint error;\n\n\terror = ps2_sliced_command(&parent->ps2dev, c);\n\tif (error)\n\t\treturn error;\n\n\terror = ps2_command(&parent->ps2dev, &rate_param, PSMOUSE_CMD_SETRATE);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int synaptics_pt_start(struct serio *serio)\n{\n\tstruct psmouse *parent = psmouse_from_serio(serio->parent);\n\tstruct synaptics_data *priv = parent->private;\n\n\tserio_pause_rx(parent->ps2dev.serio);\n\tpriv->pt_port = serio;\n\tserio_continue_rx(parent->ps2dev.serio);\n\n\treturn 0;\n}\n\nstatic void synaptics_pt_stop(struct serio *serio)\n{\n\tstruct psmouse *parent = psmouse_from_serio(serio->parent);\n\tstruct synaptics_data *priv = parent->private;\n\n\tserio_pause_rx(parent->ps2dev.serio);\n\tpriv->pt_port = NULL;\n\tserio_continue_rx(parent->ps2dev.serio);\n}\n\nstatic int synaptics_is_pt_packet(u8 *buf)\n{\n\treturn (buf[0] & 0xFC) == 0x84 && (buf[3] & 0xCC) == 0xC4;\n}\n\nstatic void synaptics_pass_pt_packet(struct serio *ptport, u8 *packet)\n{\n\tstruct psmouse *child = psmouse_from_serio(ptport);\n\n\tif (child && child->state == PSMOUSE_ACTIVATED) {\n\t\tserio_interrupt(ptport, packet[1], 0);\n\t\tserio_interrupt(ptport, packet[4], 0);\n\t\tserio_interrupt(ptport, packet[5], 0);\n\t\tif (child->pktsize == 4)\n\t\t\tserio_interrupt(ptport, packet[2], 0);\n\t} else {\n\t\tserio_interrupt(ptport, packet[1], 0);\n\t}\n}\n\nstatic void synaptics_pt_activate(struct psmouse *psmouse)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\tstruct psmouse *child = psmouse_from_serio(priv->pt_port);\n\n\t \n\tif (child) {\n\t\tif (child->pktsize == 4)\n\t\t\tpriv->mode |= SYN_BIT_FOUR_BYTE_CLIENT;\n\t\telse\n\t\t\tpriv->mode &= ~SYN_BIT_FOUR_BYTE_CLIENT;\n\n\t\tif (synaptics_mode_cmd(psmouse, priv->mode))\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"failed to switch guest protocol\\n\");\n\t}\n}\n\nstatic void synaptics_pt_create(struct psmouse *psmouse)\n{\n\tstruct serio *serio;\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"not enough memory for pass-through port\\n\");\n\t\treturn;\n\t}\n\n\tserio->id.type = SERIO_PS_PSTHRU;\n\tstrscpy(serio->name, \"Synaptics pass-through\", sizeof(serio->name));\n\tstrscpy(serio->phys, \"synaptics-pt/serio0\", sizeof(serio->phys));\n\tserio->write = synaptics_pt_write;\n\tserio->start = synaptics_pt_start;\n\tserio->stop = synaptics_pt_stop;\n\tserio->parent = psmouse->ps2dev.serio;\n\n\tpsmouse->pt_activate = synaptics_pt_activate;\n\n\tpsmouse_info(psmouse, \"serio: %s port at %s\\n\",\n\t\t     serio->name, psmouse->phys);\n\tserio_register_port(serio);\n}\n\n \n\nstatic void synaptics_parse_agm(const u8 buf[],\n\t\t\t\tstruct synaptics_data *priv,\n\t\t\t\tstruct synaptics_hw_state *hw)\n{\n\tstruct synaptics_hw_state *agm = &priv->agm;\n\tint agm_packet_type;\n\n\tagm_packet_type = (buf[5] & 0x30) >> 4;\n\tswitch (agm_packet_type) {\n\tcase 1:\n\t\t \n\t\tagm->w = hw->w;\n\t\tagm->x = (((buf[4] & 0x0f) << 8) | buf[1]) << 1;\n\t\tagm->y = (((buf[4] & 0xf0) << 4) | buf[2]) << 1;\n\t\tagm->z = ((buf[3] & 0x30) | (buf[5] & 0x0f)) << 1;\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tpriv->agm_count = buf[1];\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void synaptics_parse_ext_buttons(const u8 buf[],\n\t\t\t\t\tstruct synaptics_data *priv,\n\t\t\t\t\tstruct synaptics_hw_state *hw)\n{\n\tunsigned int ext_bits =\n\t\t(SYN_CAP_MULTI_BUTTON_NO(priv->info.ext_cap) + 1) >> 1;\n\tunsigned int ext_mask = GENMASK(ext_bits - 1, 0);\n\n\thw->ext_buttons = buf[4] & ext_mask;\n\thw->ext_buttons |= (buf[5] & ext_mask) << ext_bits;\n}\n\nstatic int synaptics_parse_hw_state(const u8 buf[],\n\t\t\t\t    struct synaptics_data *priv,\n\t\t\t\t    struct synaptics_hw_state *hw)\n{\n\tmemset(hw, 0, sizeof(struct synaptics_hw_state));\n\n\tif (SYN_MODEL_NEWABS(priv->info.model_id)) {\n\t\thw->w = (((buf[0] & 0x30) >> 2) |\n\t\t\t ((buf[0] & 0x04) >> 1) |\n\t\t\t ((buf[3] & 0x04) >> 2));\n\n\t\tif (synaptics_has_agm(priv) && hw->w == 2) {\n\t\t\tsynaptics_parse_agm(buf, priv, hw);\n\t\t\treturn 1;\n\t\t}\n\n\t\thw->x = (((buf[3] & 0x10) << 8) |\n\t\t\t ((buf[1] & 0x0f) << 8) |\n\t\t\t buf[4]);\n\t\thw->y = (((buf[3] & 0x20) << 7) |\n\t\t\t ((buf[1] & 0xf0) << 4) |\n\t\t\t buf[5]);\n\t\thw->z = buf[2];\n\n\t\thw->left  = (buf[0] & 0x01) ? 1 : 0;\n\t\thw->right = (buf[0] & 0x02) ? 1 : 0;\n\n\t\tif (priv->is_forcepad) {\n\t\t\t \n\t\t\tif (hw->z == 0) {\n\t\t\t\t \n\t\t\t\tpriv->press = priv->report_press = false;\n\t\t\t} else if (hw->w >= 4 && ((buf[0] ^ buf[3]) & 0x01)) {\n\t\t\t\t \n\t\t\t\tif  (!priv->press) {\n\t\t\t\t\tpriv->press_start = jiffies;\n\t\t\t\t\tpriv->press = true;\n\t\t\t\t} else if (time_after(jiffies,\n\t\t\t\t\t\tpriv->press_start +\n\t\t\t\t\t\t\tmsecs_to_jiffies(50))) {\n\t\t\t\t\tpriv->report_press = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpriv->press = false;\n\t\t\t}\n\n\t\t\thw->left = priv->report_press;\n\n\t\t} else if (SYN_CAP_CLICKPAD(priv->info.ext_cap_0c)) {\n\t\t\t \n\t\t\thw->left = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;\n\n\t\t} else if (SYN_CAP_MIDDLE_BUTTON(priv->info.capabilities)) {\n\t\t\thw->middle = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;\n\t\t\tif (hw->w == 2)\n\t\t\t\thw->scroll = (s8)buf[1];\n\t\t}\n\n\t\tif (SYN_CAP_FOUR_BUTTON(priv->info.capabilities)) {\n\t\t\thw->up   = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;\n\t\t\thw->down = ((buf[0] ^ buf[3]) & 0x02) ? 1 : 0;\n\t\t}\n\n\t\tif (SYN_CAP_MULTI_BUTTON_NO(priv->info.ext_cap) > 0 &&\n\t\t    ((buf[0] ^ buf[3]) & 0x02)) {\n\t\t\tsynaptics_parse_ext_buttons(buf, priv, hw);\n\t\t}\n\t} else {\n\t\thw->x = (((buf[1] & 0x1f) << 8) | buf[2]);\n\t\thw->y = (((buf[4] & 0x1f) << 8) | buf[5]);\n\n\t\thw->z = (((buf[0] & 0x30) << 2) | (buf[3] & 0x3F));\n\t\thw->w = (((buf[1] & 0x80) >> 4) | ((buf[0] & 0x04) >> 1));\n\n\t\thw->left  = (buf[0] & 0x01) ? 1 : 0;\n\t\thw->right = (buf[0] & 0x02) ? 1 : 0;\n\t}\n\n\t \n\tif (hw->x > X_MAX_POSITIVE)\n\t\thw->x -= 1 << ABS_POS_BITS;\n\telse if (hw->x == X_MAX_POSITIVE)\n\t\thw->x = XMAX;\n\n\tif (hw->y > Y_MAX_POSITIVE)\n\t\thw->y -= 1 << ABS_POS_BITS;\n\telse if (hw->y == Y_MAX_POSITIVE)\n\t\thw->y = YMAX;\n\n\treturn 0;\n}\n\nstatic void synaptics_report_semi_mt_slot(struct input_dev *dev, int slot,\n\t\t\t\t\t  bool active, int x, int y)\n{\n\tinput_mt_slot(dev, slot);\n\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\n\tif (active) {\n\t\tinput_report_abs(dev, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_Y, synaptics_invert_y(y));\n\t}\n}\n\nstatic void synaptics_report_semi_mt_data(struct input_dev *dev,\n\t\t\t\t\t  const struct synaptics_hw_state *a,\n\t\t\t\t\t  const struct synaptics_hw_state *b,\n\t\t\t\t\t  int num_fingers)\n{\n\tif (num_fingers >= 2) {\n\t\tsynaptics_report_semi_mt_slot(dev, 0, true, min(a->x, b->x),\n\t\t\t\t\t      min(a->y, b->y));\n\t\tsynaptics_report_semi_mt_slot(dev, 1, true, max(a->x, b->x),\n\t\t\t\t\t      max(a->y, b->y));\n\t} else if (num_fingers == 1) {\n\t\tsynaptics_report_semi_mt_slot(dev, 0, true, a->x, a->y);\n\t\tsynaptics_report_semi_mt_slot(dev, 1, false, 0, 0);\n\t} else {\n\t\tsynaptics_report_semi_mt_slot(dev, 0, false, 0, 0);\n\t\tsynaptics_report_semi_mt_slot(dev, 1, false, 0, 0);\n\t}\n}\n\nstatic void synaptics_report_ext_buttons(struct psmouse *psmouse,\n\t\t\t\t\t const struct synaptics_hw_state *hw)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct synaptics_data *priv = psmouse->private;\n\tint ext_bits = (SYN_CAP_MULTI_BUTTON_NO(priv->info.ext_cap) + 1) >> 1;\n\tint i;\n\n\tif (!SYN_CAP_MULTI_BUTTON_NO(priv->info.ext_cap))\n\t\treturn;\n\n\t \n\tif ((SYN_ID_FULL(priv->info.identity) == 0x801 ||\n\t     SYN_ID_FULL(priv->info.identity) == 0x802) &&\n\t    !((psmouse->packet[0] ^ psmouse->packet[3]) & 0x02))\n\t\treturn;\n\n\tif (!SYN_CAP_EXT_BUTTONS_STICK(priv->info.ext_cap_10)) {\n\t\tfor (i = 0; i < ext_bits; i++) {\n\t\t\tinput_report_key(dev, BTN_0 + 2 * i,\n\t\t\t\thw->ext_buttons & BIT(i));\n\t\t\tinput_report_key(dev, BTN_1 + 2 * i,\n\t\t\t\thw->ext_buttons & BIT(i + ext_bits));\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (priv->pt_port) {\n\t\tu8 pt_buttons;\n\n\t\t \n\t\tpt_buttons = SYN_EXT_BUTTON_STICK_L(hw->ext_buttons)      |\n\t\t\t     SYN_EXT_BUTTON_STICK_R(hw->ext_buttons) << 1 |\n\t\t\t     SYN_EXT_BUTTON_STICK_M(hw->ext_buttons) << 2;\n\n\t\tserio_interrupt(priv->pt_port,\n\t\t\t\tPSMOUSE_OOB_EXTRA_BTNS, SERIO_OOB_DATA);\n\t\tserio_interrupt(priv->pt_port, pt_buttons, SERIO_OOB_DATA);\n\t}\n}\n\nstatic void synaptics_report_buttons(struct psmouse *psmouse,\n\t\t\t\t     const struct synaptics_hw_state *hw)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct synaptics_data *priv = psmouse->private;\n\n\tinput_report_key(dev, BTN_LEFT, hw->left);\n\tinput_report_key(dev, BTN_RIGHT, hw->right);\n\n\tif (SYN_CAP_MIDDLE_BUTTON(priv->info.capabilities))\n\t\tinput_report_key(dev, BTN_MIDDLE, hw->middle);\n\n\tif (SYN_CAP_FOUR_BUTTON(priv->info.capabilities)) {\n\t\tinput_report_key(dev, BTN_FORWARD, hw->up);\n\t\tinput_report_key(dev, BTN_BACK, hw->down);\n\t}\n\n\tsynaptics_report_ext_buttons(psmouse, hw);\n}\n\nstatic void synaptics_report_mt_data(struct psmouse *psmouse,\n\t\t\t\t     const struct synaptics_hw_state *sgm,\n\t\t\t\t     int num_fingers)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct synaptics_data *priv = psmouse->private;\n\tconst struct synaptics_hw_state *hw[2] = { sgm, &priv->agm };\n\tstruct input_mt_pos pos[2];\n\tint slot[2], nsemi, i;\n\n\tnsemi = clamp_val(num_fingers, 0, 2);\n\n\tfor (i = 0; i < nsemi; i++) {\n\t\tpos[i].x = hw[i]->x;\n\t\tpos[i].y = synaptics_invert_y(hw[i]->y);\n\t}\n\n\tinput_mt_assign_slots(dev, slot, pos, nsemi, DMAX * priv->info.x_res);\n\n\tfor (i = 0; i < nsemi; i++) {\n\t\tinput_mt_slot(dev, slot[i]);\n\t\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_X, pos[i].x);\n\t\tinput_report_abs(dev, ABS_MT_POSITION_Y, pos[i].y);\n\t\tinput_report_abs(dev, ABS_MT_PRESSURE, hw[i]->z);\n\t}\n\n\tinput_mt_drop_unused(dev);\n\n\t \n\tinput_mt_report_pointer_emulation(dev, false);\n\n\t \n\tinput_mt_report_finger_count(dev, num_fingers);\n\n\tsynaptics_report_buttons(psmouse, sgm);\n\n\tinput_sync(dev);\n}\n\nstatic void synaptics_image_sensor_process(struct psmouse *psmouse,\n\t\t\t\t\t   struct synaptics_hw_state *sgm)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\tint num_fingers;\n\n\t \n\tif (sgm->z == 0)\n\t\tnum_fingers = 0;\n\telse if (sgm->w >= 4)\n\t\tnum_fingers = 1;\n\telse if (sgm->w == 0)\n\t\tnum_fingers = 2;\n\telse if (sgm->w == 1)\n\t\tnum_fingers = priv->agm_count ? priv->agm_count : 3;\n\telse\n\t\tnum_fingers = 4;\n\n\t \n\tsynaptics_report_mt_data(psmouse, sgm, num_fingers);\n}\n\nstatic bool synaptics_has_multifinger(struct synaptics_data *priv)\n{\n\tif (SYN_CAP_MULTIFINGER(priv->info.capabilities))\n\t\treturn true;\n\n\t \n\treturn synaptics_has_agm(priv);\n}\n\n \nstatic void synaptics_process_packet(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct synaptics_data *priv = psmouse->private;\n\tstruct synaptics_device_info *info = &priv->info;\n\tstruct synaptics_hw_state hw;\n\tint num_fingers;\n\tint finger_width;\n\n\tif (synaptics_parse_hw_state(psmouse->packet, priv, &hw))\n\t\treturn;\n\n\tif (SYN_CAP_IMAGE_SENSOR(info->ext_cap_0c)) {\n\t\tsynaptics_image_sensor_process(psmouse, &hw);\n\t\treturn;\n\t}\n\n\tif (hw.scroll) {\n\t\tpriv->scroll += hw.scroll;\n\n\t\twhile (priv->scroll >= 4) {\n\t\t\tinput_report_key(dev, BTN_BACK, !hw.down);\n\t\t\tinput_sync(dev);\n\t\t\tinput_report_key(dev, BTN_BACK, hw.down);\n\t\t\tinput_sync(dev);\n\t\t\tpriv->scroll -= 4;\n\t\t}\n\t\twhile (priv->scroll <= -4) {\n\t\t\tinput_report_key(dev, BTN_FORWARD, !hw.up);\n\t\t\tinput_sync(dev);\n\t\t\tinput_report_key(dev, BTN_FORWARD, hw.up);\n\t\t\tinput_sync(dev);\n\t\t\tpriv->scroll += 4;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (hw.z > 0 && hw.x > 1) {\n\t\tnum_fingers = 1;\n\t\tfinger_width = 5;\n\t\tif (SYN_CAP_EXTENDED(info->capabilities)) {\n\t\t\tswitch (hw.w) {\n\t\t\tcase 0 ... 1:\n\t\t\t\tif (synaptics_has_multifinger(priv))\n\t\t\t\t\tnum_fingers = hw.w + 2;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase 4 ... 15:\n\t\t\t\tif (SYN_CAP_PALMDETECT(info->capabilities))\n\t\t\t\t\tfinger_width = hw.w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnum_fingers = 0;\n\t\tfinger_width = 0;\n\t}\n\n\tif (cr48_profile_sensor) {\n\t\tsynaptics_report_mt_data(psmouse, &hw, num_fingers);\n\t\treturn;\n\t}\n\n\tif (SYN_CAP_ADV_GESTURE(info->ext_cap_0c))\n\t\tsynaptics_report_semi_mt_data(dev, &hw, &priv->agm,\n\t\t\t\t\t      num_fingers);\n\n\t \n\tif (hw.z > 30) input_report_key(dev, BTN_TOUCH, 1);\n\tif (hw.z < 25) input_report_key(dev, BTN_TOUCH, 0);\n\n\tif (num_fingers > 0) {\n\t\tinput_report_abs(dev, ABS_X, hw.x);\n\t\tinput_report_abs(dev, ABS_Y, synaptics_invert_y(hw.y));\n\t}\n\tinput_report_abs(dev, ABS_PRESSURE, hw.z);\n\n\tif (SYN_CAP_PALMDETECT(info->capabilities))\n\t\tinput_report_abs(dev, ABS_TOOL_WIDTH, finger_width);\n\n\tinput_report_key(dev, BTN_TOOL_FINGER, num_fingers == 1);\n\tif (synaptics_has_multifinger(priv)) {\n\t\tinput_report_key(dev, BTN_TOOL_DOUBLETAP, num_fingers == 2);\n\t\tinput_report_key(dev, BTN_TOOL_TRIPLETAP, num_fingers == 3);\n\t}\n\n\tsynaptics_report_buttons(psmouse, &hw);\n\n\tinput_sync(dev);\n}\n\nstatic bool synaptics_validate_byte(struct psmouse *psmouse,\n\t\t\t\t    int idx, enum synaptics_pkt_type pkt_type)\n{\n\tstatic const u8 newabs_mask[]\t  = { 0xC8, 0x00, 0x00, 0xC8, 0x00 };\n\tstatic const u8 newabs_rel_mask[] = { 0xC0, 0x00, 0x00, 0xC0, 0x00 };\n\tstatic const u8 newabs_rslt[]\t  = { 0x80, 0x00, 0x00, 0xC0, 0x00 };\n\tstatic const u8 oldabs_mask[]\t  = { 0xC0, 0x60, 0x00, 0xC0, 0x60 };\n\tstatic const u8 oldabs_rslt[]\t  = { 0xC0, 0x00, 0x00, 0x80, 0x00 };\n\tconst u8 *packet = psmouse->packet;\n\n\tif (idx < 0 || idx > 4)\n\t\treturn false;\n\n\tswitch (pkt_type) {\n\n\tcase SYN_NEWABS:\n\tcase SYN_NEWABS_RELAXED:\n\t\treturn (packet[idx] & newabs_rel_mask[idx]) == newabs_rslt[idx];\n\n\tcase SYN_NEWABS_STRICT:\n\t\treturn (packet[idx] & newabs_mask[idx]) == newabs_rslt[idx];\n\n\tcase SYN_OLDABS:\n\t\treturn (packet[idx] & oldabs_mask[idx]) == oldabs_rslt[idx];\n\n\tdefault:\n\t\tpsmouse_err(psmouse, \"unknown packet type %d\\n\", pkt_type);\n\t\treturn false;\n\t}\n}\n\nstatic enum synaptics_pkt_type\nsynaptics_detect_pkt_type(struct psmouse *psmouse)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (!synaptics_validate_byte(psmouse, i, SYN_NEWABS_STRICT)) {\n\t\t\tpsmouse_info(psmouse, \"using relaxed packet validation\\n\");\n\t\t\treturn SYN_NEWABS_RELAXED;\n\t\t}\n\t}\n\n\treturn SYN_NEWABS_STRICT;\n}\n\nstatic psmouse_ret_t synaptics_process_byte(struct psmouse *psmouse)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\n\tif (psmouse->pktcnt >= 6) {  \n\t\tif (unlikely(priv->pkt_type == SYN_NEWABS))\n\t\t\tpriv->pkt_type = synaptics_detect_pkt_type(psmouse);\n\n\t\tif (SYN_CAP_PASS_THROUGH(priv->info.capabilities) &&\n\t\t    synaptics_is_pt_packet(psmouse->packet)) {\n\t\t\tif (priv->pt_port)\n\t\t\t\tsynaptics_pass_pt_packet(priv->pt_port,\n\t\t\t\t\t\t\t psmouse->packet);\n\t\t} else\n\t\t\tsynaptics_process_packet(psmouse);\n\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\treturn synaptics_validate_byte(psmouse, psmouse->pktcnt - 1, priv->pkt_type) ?\n\t\tPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\n}\n\n \nstatic void set_abs_position_params(struct input_dev *dev,\n\t\t\t\t    struct synaptics_device_info *info,\n\t\t\t\t    int x_code, int y_code)\n{\n\tint x_min = info->x_min ?: XMIN_NOMINAL;\n\tint x_max = info->x_max ?: XMAX_NOMINAL;\n\tint y_min = info->y_min ?: YMIN_NOMINAL;\n\tint y_max = info->y_max ?: YMAX_NOMINAL;\n\tint fuzz = SYN_CAP_REDUCED_FILTERING(info->ext_cap_0c) ?\n\t\t\tSYN_REDUCED_FILTER_FUZZ : 0;\n\n\tinput_set_abs_params(dev, x_code, x_min, x_max, fuzz, 0);\n\tinput_set_abs_params(dev, y_code, y_min, y_max, fuzz, 0);\n\tinput_abs_set_res(dev, x_code, info->x_res);\n\tinput_abs_set_res(dev, y_code, info->y_res);\n}\n\nstatic int set_input_params(struct psmouse *psmouse,\n\t\t\t    struct synaptics_data *priv)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct synaptics_device_info *info = &priv->info;\n\tint i;\n\tint error;\n\n\t \n\t__clear_bit(EV_REL, dev->evbit);\n\tbitmap_zero(dev->relbit, REL_CNT);\n\tbitmap_zero(dev->keybit, KEY_CNT);\n\n\t \n\t__set_bit(INPUT_PROP_POINTER, dev->propbit);\n\n\tinput_set_capability(dev, EV_KEY, BTN_LEFT);\n\n\t \n\tif (!SYN_CAP_CLICKPAD(info->ext_cap_0c)) {\n\t\tinput_set_capability(dev, EV_KEY, BTN_RIGHT);\n\t\tif (SYN_CAP_MIDDLE_BUTTON(info->capabilities))\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_MIDDLE);\n\t}\n\n\tif (!priv->absolute_mode) {\n\t\t \n\t\tinput_set_capability(dev, EV_REL, REL_X);\n\t\tinput_set_capability(dev, EV_REL, REL_Y);\n\t\treturn 0;\n\t}\n\n\t \n\tset_abs_position_params(dev, &priv->info, ABS_X, ABS_Y);\n\tinput_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);\n\n\tif (cr48_profile_sensor)\n\t\tinput_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\n\tif (SYN_CAP_IMAGE_SENSOR(info->ext_cap_0c)) {\n\t\tset_abs_position_params(dev, info,\n\t\t\t\t\tABS_MT_POSITION_X, ABS_MT_POSITION_Y);\n\t\t \n\t\tinput_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\n\t\terror = input_mt_init_slots(dev, 2,\n\t\t\t\t\t    INPUT_MT_POINTER | INPUT_MT_TRACK);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tinput_set_capability(dev, EV_KEY, BTN_TOOL_QUADTAP);\n\t\tinput_set_capability(dev, EV_KEY, BTN_TOOL_QUINTTAP);\n\t} else if (SYN_CAP_ADV_GESTURE(info->ext_cap_0c)) {\n\t\tset_abs_position_params(dev, info,\n\t\t\t\t\tABS_MT_POSITION_X, ABS_MT_POSITION_Y);\n\t\t \n\t\terror = input_mt_init_slots(dev, 2,\n\t\t\t\t\t    INPUT_MT_POINTER |\n\t\t\t\t\t     (cr48_profile_sensor ?\n\t\t\t\t\t      INPUT_MT_TRACK :\n\t\t\t\t\t      INPUT_MT_SEMI_MT));\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tif (!cr48_profile_sensor)\n\t\t\tset_abs_position_params(dev, &priv->info, ABS_X, ABS_Y);\n\t}\n\n\tif (SYN_CAP_PALMDETECT(info->capabilities))\n\t\tinput_set_abs_params(dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);\n\n\tinput_set_capability(dev, EV_KEY, BTN_TOUCH);\n\tinput_set_capability(dev, EV_KEY, BTN_TOOL_FINGER);\n\n\tif (synaptics_has_multifinger(priv)) {\n\t\tinput_set_capability(dev, EV_KEY, BTN_TOOL_DOUBLETAP);\n\t\tinput_set_capability(dev, EV_KEY, BTN_TOOL_TRIPLETAP);\n\t}\n\n\tif (SYN_CAP_FOUR_BUTTON(info->capabilities) ||\n\t    SYN_CAP_MIDDLE_BUTTON(info->capabilities)) {\n\t\tinput_set_capability(dev, EV_KEY, BTN_FORWARD);\n\t\tinput_set_capability(dev, EV_KEY, BTN_BACK);\n\t}\n\n\tif (!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10))\n\t\tfor (i = 0; i < SYN_CAP_MULTI_BUTTON_NO(info->ext_cap); i++)\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_0 + i);\n\n\tif (SYN_CAP_CLICKPAD(info->ext_cap_0c)) {\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, dev->propbit);\n\t\tif (psmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&\n\t\t    !SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10))\n\t\t\t__set_bit(INPUT_PROP_TOPBUTTONPAD, dev->propbit);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t synaptics_show_disable_gesture(struct psmouse *psmouse,\n\t\t\t\t\t      void *data, char *buf)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\n\treturn sprintf(buf, \"%c\\n\", priv->disable_gesture ? '1' : '0');\n}\n\nstatic ssize_t synaptics_set_disable_gesture(struct psmouse *psmouse,\n\t\t\t\t\t     void *data, const char *buf,\n\t\t\t\t\t     size_t len)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value == priv->disable_gesture)\n\t\treturn len;\n\n\tpriv->disable_gesture = value;\n\tif (value)\n\t\tpriv->mode |= SYN_BIT_DISABLE_GESTURE;\n\telse\n\t\tpriv->mode &= ~SYN_BIT_DISABLE_GESTURE;\n\n\tif (synaptics_mode_cmd(psmouse, priv->mode))\n\t\treturn -EIO;\n\n\treturn len;\n}\n\nPSMOUSE_DEFINE_ATTR(disable_gesture, S_IWUSR | S_IRUGO, NULL,\n\t\t    synaptics_show_disable_gesture,\n\t\t    synaptics_set_disable_gesture);\n\nstatic void synaptics_disconnect(struct psmouse *psmouse)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\n\t \n\tpsmouse_smbus_cleanup(psmouse);\n\n\tif (!priv->absolute_mode &&\n\t\t\tSYN_ID_DISGEST_SUPPORTED(priv->info.identity))\n\t\tdevice_remove_file(&psmouse->ps2dev.serio->dev,\n\t\t\t\t   &psmouse_attr_disable_gesture.dattr);\n\n\tsynaptics_reset(psmouse);\n\tkfree(priv);\n\tpsmouse->private = NULL;\n}\n\nstatic int synaptics_reconnect(struct psmouse *psmouse)\n{\n\tstruct synaptics_data *priv = psmouse->private;\n\tstruct synaptics_device_info info;\n\tu8 param[2];\n\tint retry = 0;\n\tint error;\n\n\tdo {\n\t\tpsmouse_reset(psmouse);\n\t\tif (retry) {\n\t\t\t \n\t\t\tssleep(1);\n\t\t}\n\t\tps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETID);\n\t\terror = synaptics_detect(psmouse, 0);\n\t} while (error && ++retry < 3);\n\n\tif (error)\n\t\treturn error;\n\n\tif (retry > 1)\n\t\tpsmouse_dbg(psmouse, \"reconnected after %d tries\\n\", retry);\n\n\terror = synaptics_query_hardware(psmouse, &info);\n\tif (error) {\n\t\tpsmouse_err(psmouse, \"Unable to query device.\\n\");\n\t\treturn error;\n\t}\n\n\terror = synaptics_set_mode(psmouse);\n\tif (error) {\n\t\tpsmouse_err(psmouse, \"Unable to initialize device.\\n\");\n\t\treturn error;\n\t}\n\n\tif (info.identity != priv->info.identity ||\n\t    info.model_id != priv->info.model_id ||\n\t    info.capabilities != priv->info.capabilities ||\n\t    info.ext_cap != priv->info.ext_cap) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"hardware appears to be different: id(%u-%u), model(%u-%u), caps(%x-%x), ext(%x-%x).\\n\",\n\t\t\t    priv->info.identity, info.identity,\n\t\t\t    priv->info.model_id, info.model_id,\n\t\t\t    priv->info.capabilities, info.capabilities,\n\t\t\t    priv->info.ext_cap, info.ext_cap);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool impaired_toshiba_kbc;\n\nstatic const struct dmi_system_id toshiba_dmi_table[] __initconst = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"dynabook\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PORTEGE M300\"),\n\t\t},\n\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Portable PC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Version 1.0\"),\n\t\t},\n\n\t},\n#endif\n\t{ }\n};\n\nstatic bool broken_olpc_ec;\n\nstatic const struct dmi_system_id olpc_dmi_table[] __initconst = {\n#if defined(CONFIG_DMI) && defined(CONFIG_OLPC)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"OLPC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"XO\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\nstatic const struct dmi_system_id __initconst cr48_dmi_table[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IEC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Mario\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\nvoid __init synaptics_module_init(void)\n{\n\timpaired_toshiba_kbc = dmi_check_system(toshiba_dmi_table);\n\tbroken_olpc_ec = dmi_check_system(olpc_dmi_table);\n\tcr48_profile_sensor = dmi_check_system(cr48_dmi_table);\n}\n\nstatic int synaptics_init_ps2(struct psmouse *psmouse,\n\t\t\t      struct synaptics_device_info *info,\n\t\t\t      bool absolute_mode)\n{\n\tstruct synaptics_data *priv;\n\tint err;\n\n\tsynaptics_apply_quirks(psmouse, info);\n\n\tpsmouse->private = priv = kzalloc(sizeof(struct synaptics_data), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->info = *info;\n\tpriv->absolute_mode = absolute_mode;\n\tif (SYN_ID_DISGEST_SUPPORTED(info->identity))\n\t\tpriv->disable_gesture = true;\n\n\t \n\tpriv->is_forcepad = psmouse_matches_pnp_id(psmouse, forcepad_pnp_ids);\n\n\terr = synaptics_set_mode(psmouse);\n\tif (err) {\n\t\tpsmouse_err(psmouse, \"Unable to initialize device.\\n\");\n\t\tgoto init_fail;\n\t}\n\n\tpriv->pkt_type = SYN_MODEL_NEWABS(info->model_id) ?\n\t\t\t\t\tSYN_NEWABS : SYN_OLDABS;\n\n\tpsmouse_info(psmouse,\n\t\t     \"Touchpad model: %lu, fw: %lu.%lu, id: %#x, caps: %#x/%#x/%#x/%#x, board id: %u, fw id: %u\\n\",\n\t\t     SYN_ID_MODEL(info->identity),\n\t\t     SYN_ID_MAJOR(info->identity), SYN_ID_MINOR(info->identity),\n\t\t     info->model_id,\n\t\t     info->capabilities, info->ext_cap, info->ext_cap_0c,\n\t\t     info->ext_cap_10, info->board_id, info->firmware_id);\n\n\terr = set_input_params(psmouse, priv);\n\tif (err) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to set up capabilities: %d\\n\", err);\n\t\tgoto init_fail;\n\t}\n\n\t \n\tpsmouse->model = ((info->model_id & 0x00ff0000) >> 8) |\n\t\t\t  (info->model_id & 0x000000ff);\n\n\tif (absolute_mode) {\n\t\tpsmouse->protocol_handler = synaptics_process_byte;\n\t\tpsmouse->pktsize = 6;\n\t} else {\n\t\t \n\t\tpsmouse->protocol_handler = psmouse_process_byte;\n\t\tpsmouse->pktsize = 3;\n\t}\n\n\tpsmouse->set_rate = synaptics_set_rate;\n\tpsmouse->disconnect = synaptics_disconnect;\n\tpsmouse->reconnect = synaptics_reconnect;\n\tpsmouse->fast_reconnect = NULL;\n\tpsmouse->cleanup = synaptics_reset;\n\t \n\tpsmouse->resync_time = 0;\n\n\tif (SYN_CAP_PASS_THROUGH(info->capabilities))\n\t\tsynaptics_pt_create(psmouse);\n\n\t \n\tif (psmouse->rate >= 80 && impaired_toshiba_kbc) {\n\t\tpsmouse_info(psmouse,\n\t\t\t     \"Toshiba %s detected, limiting rate to 40pps.\\n\",\n\t\t\t     dmi_get_system_info(DMI_PRODUCT_NAME));\n\t\tpsmouse->rate = 40;\n\t}\n\n\tif (!priv->absolute_mode && SYN_ID_DISGEST_SUPPORTED(info->identity)) {\n\t\terr = device_create_file(&psmouse->ps2dev.serio->dev,\n\t\t\t\t\t &psmouse_attr_disable_gesture.dattr);\n\t\tif (err) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"Failed to create disable_gesture attribute (%d)\",\n\t\t\t\t    err);\n\t\t\tgoto init_fail;\n\t\t}\n\t}\n\n\treturn 0;\n\n init_fail:\n\tkfree(priv);\n\treturn err;\n}\n\nstatic int __synaptics_init(struct psmouse *psmouse, bool absolute_mode)\n{\n\tstruct synaptics_device_info info;\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\n\terror = synaptics_query_hardware(psmouse, &info);\n\tif (error) {\n\t\tpsmouse_err(psmouse, \"Unable to query device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn synaptics_init_ps2(psmouse, &info, absolute_mode);\n}\n\nint synaptics_init_absolute(struct psmouse *psmouse)\n{\n\treturn __synaptics_init(psmouse, true);\n}\n\nint synaptics_init_relative(struct psmouse *psmouse)\n{\n\treturn __synaptics_init(psmouse, false);\n}\n\nstatic int synaptics_setup_ps2(struct psmouse *psmouse,\n\t\t\t       struct synaptics_device_info *info)\n{\n\tbool absolute_mode = true;\n\tint error;\n\n\t \n\tif (broken_olpc_ec) {\n\t\tpsmouse_info(psmouse,\n\t\t\t     \"OLPC XO detected, forcing relative protocol.\\n\");\n\t\tabsolute_mode = false;\n\t}\n\n\terror = synaptics_init_ps2(psmouse, info, absolute_mode);\n\tif (error)\n\t\treturn error;\n\n\treturn absolute_mode ? PSMOUSE_SYNAPTICS : PSMOUSE_SYNAPTICS_RELATIVE;\n}\n\n#else  \n\nvoid __init synaptics_module_init(void)\n{\n}\n\nstatic int __maybe_unused\nsynaptics_setup_ps2(struct psmouse *psmouse,\n\t\t    struct synaptics_device_info *info)\n{\n\treturn -ENOSYS;\n}\n\n#endif  \n\n#ifdef CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS\n\n \nenum {\n\tSYNAPTICS_INTERTOUCH_NOT_SET = -1,\n\tSYNAPTICS_INTERTOUCH_OFF,\n\tSYNAPTICS_INTERTOUCH_ON,\n};\n\nstatic int synaptics_intertouch = IS_ENABLED(CONFIG_RMI4_SMB) ?\n\t\tSYNAPTICS_INTERTOUCH_NOT_SET : SYNAPTICS_INTERTOUCH_OFF;\nmodule_param_named(synaptics_intertouch, synaptics_intertouch, int, 0644);\nMODULE_PARM_DESC(synaptics_intertouch, \"Use a secondary bus for the Synaptics device.\");\n\nstatic int synaptics_create_intertouch(struct psmouse *psmouse,\n\t\t\t\t       struct synaptics_device_info *info,\n\t\t\t\t       bool leave_breadcrumbs)\n{\n\tbool topbuttonpad =\n\t\tpsmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&\n\t\t!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10);\n\tconst struct rmi_device_platform_data pdata = {\n\t\t.reset_delay_ms = 30,\n\t\t.sensor_pdata = {\n\t\t\t.sensor_type = rmi_sensor_touchpad,\n\t\t\t.axis_align.flip_y = true,\n\t\t\t.kernel_tracking = false,\n\t\t\t.topbuttonpad = topbuttonpad,\n\t\t},\n\t\t.gpio_data = {\n\t\t\t.buttonpad = SYN_CAP_CLICKPAD(info->ext_cap_0c),\n\t\t\t.trackstick_buttons =\n\t\t\t\t!!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10),\n\t\t},\n\t};\n\tconst struct i2c_board_info intertouch_board = {\n\t\tI2C_BOARD_INFO(\"rmi4_smbus\", 0x2c),\n\t\t.flags = I2C_CLIENT_HOST_NOTIFY,\n\t};\n\n\treturn psmouse_smbus_init(psmouse, &intertouch_board,\n\t\t\t\t  &pdata, sizeof(pdata), true,\n\t\t\t\t  leave_breadcrumbs);\n}\n\n \nstatic int synaptics_setup_intertouch(struct psmouse *psmouse,\n\t\t\t\t      struct synaptics_device_info *info,\n\t\t\t\t      bool leave_breadcrumbs)\n{\n\tint error;\n\n\tif (synaptics_intertouch == SYNAPTICS_INTERTOUCH_OFF)\n\t\treturn -ENXIO;\n\n\tif (synaptics_intertouch == SYNAPTICS_INTERTOUCH_NOT_SET) {\n\t\tif (!psmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&\n\t\t    !psmouse_matches_pnp_id(psmouse, smbus_pnp_ids)) {\n\n\t\t\tif (!psmouse_matches_pnp_id(psmouse, forcepad_pnp_ids))\n\t\t\t\tpsmouse_info(psmouse,\n\t\t\t\t\t     \"Your touchpad (%s) says it can support a different bus. \"\n\t\t\t\t\t     \"If i2c-hid and hid-rmi are not used, you might want to try setting psmouse.synaptics_intertouch to 1 and report this to linux-input@vger.kernel.org.\\n\",\n\t\t\t\t\t     psmouse->ps2dev.serio->firmware_id);\n\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tpsmouse_info(psmouse, \"Trying to set up SMBus access\\n\");\n\n\terror = synaptics_create_intertouch(psmouse, info, leave_breadcrumbs);\n\tif (error) {\n\t\tif (error == -EAGAIN)\n\t\t\tpsmouse_info(psmouse, \"SMbus companion is not ready yet\\n\");\n\t\telse\n\t\t\tpsmouse_err(psmouse, \"unable to create intertouch device\\n\");\n\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nint synaptics_init_smbus(struct psmouse *psmouse)\n{\n\tstruct synaptics_device_info info;\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\n\terror = synaptics_query_hardware(psmouse, &info);\n\tif (error) {\n\t\tpsmouse_err(psmouse, \"Unable to query device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (!SYN_CAP_INTERTOUCH(info.ext_cap_0c))\n\t\treturn -ENXIO;\n\n\treturn synaptics_create_intertouch(psmouse, &info, false);\n}\n\n#else  \n\nstatic int __maybe_unused\nsynaptics_setup_intertouch(struct psmouse *psmouse,\n\t\t\t   struct synaptics_device_info *info,\n\t\t\t   bool leave_breadcrumbs)\n{\n\treturn -ENOSYS;\n}\n\nint synaptics_init_smbus(struct psmouse *psmouse)\n{\n\treturn -ENOSYS;\n}\n\n#endif  \n\n#if defined(CONFIG_MOUSE_PS2_SYNAPTICS) || \\\n    defined(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)\n\nint synaptics_init(struct psmouse *psmouse)\n{\n\tstruct synaptics_device_info info;\n\tint error;\n\tint retval;\n\n\tpsmouse_reset(psmouse);\n\n\terror = synaptics_query_hardware(psmouse, &info);\n\tif (error) {\n\t\tpsmouse_err(psmouse, \"Unable to query device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (SYN_CAP_INTERTOUCH(info.ext_cap_0c)) {\n\t\tif ((!IS_ENABLED(CONFIG_RMI4_SMB) ||\n\t\t     !IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)) &&\n\t\t     \n\t\t    !psmouse_matches_pnp_id(psmouse, forcepad_pnp_ids)) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"The touchpad can support a better bus than the too old PS/2 protocol. \"\n\t\t\t\t     \"Make sure MOUSE_PS2_SYNAPTICS_SMBUS and RMI4_SMB are enabled to get a better touchpad experience.\\n\");\n\t\t}\n\n\t\terror = synaptics_setup_intertouch(psmouse, &info, true);\n\t\tif (!error)\n\t\t\treturn PSMOUSE_SYNAPTICS_SMBUS;\n\t}\n\n\tretval = synaptics_setup_ps2(psmouse, &info);\n\tif (retval < 0) {\n\t\t \n\t\tpsmouse_smbus_cleanup(psmouse);\n\t}\n\n\treturn retval;\n}\n\n#else  \n\nint synaptics_init(struct psmouse *psmouse)\n{\n\treturn -ENOSYS;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}