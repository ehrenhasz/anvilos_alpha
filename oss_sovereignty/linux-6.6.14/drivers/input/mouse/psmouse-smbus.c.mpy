{
  "module_name": "psmouse-smbus.c",
  "hash_id": "008866f3fe5cf7b1457c4786a3bd788cb422668ef2302b7e95026637d7bafa4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/psmouse-smbus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/libps2.h>\n#include <linux/i2c.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include \"psmouse.h\"\n\nstruct psmouse_smbus_dev {\n\tstruct i2c_board_info board;\n\tstruct psmouse *psmouse;\n\tstruct i2c_client *client;\n\tstruct list_head node;\n\tbool dead;\n\tbool need_deactivate;\n};\n\nstatic LIST_HEAD(psmouse_smbus_list);\nstatic DEFINE_MUTEX(psmouse_smbus_mutex);\n\nstatic struct workqueue_struct *psmouse_smbus_wq;\n\nstatic void psmouse_smbus_check_adapter(struct i2c_adapter *adapter)\n{\n\tstruct psmouse_smbus_dev *smbdev;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_HOST_NOTIFY))\n\t\treturn;\n\n\tmutex_lock(&psmouse_smbus_mutex);\n\n\tlist_for_each_entry(smbdev, &psmouse_smbus_list, node) {\n\t\tif (smbdev->dead)\n\t\t\tcontinue;\n\n\t\tif (smbdev->client)\n\t\t\tcontinue;\n\n\t\t \n\t\tpsmouse_dbg(smbdev->psmouse,\n\t\t\t    \"SMBus candidate adapter appeared, triggering rescan\\n\");\n\t\tserio_rescan(smbdev->psmouse->ps2dev.serio);\n\t}\n\n\tmutex_unlock(&psmouse_smbus_mutex);\n}\n\nstatic void psmouse_smbus_detach_i2c_client(struct i2c_client *client)\n{\n\tstruct psmouse_smbus_dev *smbdev, *tmp;\n\n\tmutex_lock(&psmouse_smbus_mutex);\n\n\tlist_for_each_entry_safe(smbdev, tmp, &psmouse_smbus_list, node) {\n\t\tif (smbdev->client != client)\n\t\t\tcontinue;\n\n\t\tkfree(client->dev.platform_data);\n\t\tclient->dev.platform_data = NULL;\n\n\t\tif (!smbdev->dead) {\n\t\t\tpsmouse_dbg(smbdev->psmouse,\n\t\t\t\t    \"Marking SMBus companion %s as gone\\n\",\n\t\t\t\t    dev_name(&smbdev->client->dev));\n\t\t\tsmbdev->dead = true;\n\t\t\tdevice_link_remove(&smbdev->client->dev,\n\t\t\t\t\t   &smbdev->psmouse->ps2dev.serio->dev);\n\t\t\tserio_rescan(smbdev->psmouse->ps2dev.serio);\n\t\t} else {\n\t\t\tlist_del(&smbdev->node);\n\t\t\tkfree(smbdev);\n\t\t}\n\t}\n\n\tmutex_unlock(&psmouse_smbus_mutex);\n}\n\nstatic int psmouse_smbus_notifier_call(struct notifier_block *nb,\n\t\t\t\t       unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tif (dev->type == &i2c_adapter_type)\n\t\t\tpsmouse_smbus_check_adapter(to_i2c_adapter(dev));\n\t\tbreak;\n\n\tcase BUS_NOTIFY_REMOVED_DEVICE:\n\t\tif (dev->type == &i2c_client_type)\n\t\t\tpsmouse_smbus_detach_i2c_client(to_i2c_client(dev));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block psmouse_smbus_notifier = {\n\t.notifier_call = psmouse_smbus_notifier_call,\n};\n\nstatic psmouse_ret_t psmouse_smbus_process_byte(struct psmouse *psmouse)\n{\n\treturn PSMOUSE_FULL_PACKET;\n}\n\nstatic int psmouse_smbus_reconnect(struct psmouse *psmouse)\n{\n\tstruct psmouse_smbus_dev *smbdev = psmouse->private;\n\n\tif (smbdev->need_deactivate)\n\t\tpsmouse_deactivate(psmouse);\n\n\treturn 0;\n}\n\nstruct psmouse_smbus_removal_work {\n\tstruct work_struct work;\n\tstruct i2c_client *client;\n};\n\nstatic void psmouse_smbus_remove_i2c_device(struct work_struct *work)\n{\n\tstruct psmouse_smbus_removal_work *rwork =\n\t\tcontainer_of(work, struct psmouse_smbus_removal_work, work);\n\n\tdev_dbg(&rwork->client->dev, \"destroying SMBus companion device\\n\");\n\ti2c_unregister_device(rwork->client);\n\n\tkfree(rwork);\n}\n\n \nstatic void psmouse_smbus_schedule_remove(struct i2c_client *client)\n{\n\tstruct psmouse_smbus_removal_work *rwork;\n\n\trwork = kzalloc(sizeof(*rwork), GFP_KERNEL);\n\tif (rwork) {\n\t\tINIT_WORK(&rwork->work, psmouse_smbus_remove_i2c_device);\n\t\trwork->client = client;\n\n\t\tqueue_work(psmouse_smbus_wq, &rwork->work);\n\t}\n}\n\nstatic void psmouse_smbus_disconnect(struct psmouse *psmouse)\n{\n\tstruct psmouse_smbus_dev *smbdev = psmouse->private;\n\n\tmutex_lock(&psmouse_smbus_mutex);\n\n\tif (smbdev->dead) {\n\t\tlist_del(&smbdev->node);\n\t\tkfree(smbdev);\n\t} else {\n\t\tsmbdev->dead = true;\n\t\tdevice_link_remove(&smbdev->client->dev,\n\t\t\t\t   &psmouse->ps2dev.serio->dev);\n\t\tpsmouse_dbg(smbdev->psmouse,\n\t\t\t    \"posting removal request for SMBus companion %s\\n\",\n\t\t\t    dev_name(&smbdev->client->dev));\n\t\tpsmouse_smbus_schedule_remove(smbdev->client);\n\t}\n\n\tmutex_unlock(&psmouse_smbus_mutex);\n\n\tpsmouse->private = NULL;\n}\n\nstatic int psmouse_smbus_create_companion(struct device *dev, void *data)\n{\n\tstruct psmouse_smbus_dev *smbdev = data;\n\tunsigned short addr_list[] = { smbdev->board.addr, I2C_CLIENT_END };\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_client *client;\n\n\tadapter = i2c_verify_adapter(dev);\n\tif (!adapter)\n\t\treturn 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_HOST_NOTIFY))\n\t\treturn 0;\n\n\tclient = i2c_new_scanned_device(adapter, &smbdev->board,\n\t\t\t\t\taddr_list, NULL);\n\tif (IS_ERR(client))\n\t\treturn 0;\n\n\t \n\tsmbdev->client = client;\n\treturn 1;\n}\n\nvoid psmouse_smbus_cleanup(struct psmouse *psmouse)\n{\n\tstruct psmouse_smbus_dev *smbdev, *tmp;\n\n\tmutex_lock(&psmouse_smbus_mutex);\n\n\tlist_for_each_entry_safe(smbdev, tmp, &psmouse_smbus_list, node) {\n\t\tif (psmouse == smbdev->psmouse) {\n\t\t\tlist_del(&smbdev->node);\n\t\t\tkfree(smbdev);\n\t\t}\n\t}\n\n\tmutex_unlock(&psmouse_smbus_mutex);\n}\n\nint psmouse_smbus_init(struct psmouse *psmouse,\n\t\t       const struct i2c_board_info *board,\n\t\t       const void *pdata, size_t pdata_size,\n\t\t       bool need_deactivate,\n\t\t       bool leave_breadcrumbs)\n{\n\tstruct psmouse_smbus_dev *smbdev;\n\tint error;\n\n\tsmbdev = kzalloc(sizeof(*smbdev), GFP_KERNEL);\n\tif (!smbdev)\n\t\treturn -ENOMEM;\n\n\tsmbdev->psmouse = psmouse;\n\tsmbdev->board = *board;\n\tsmbdev->need_deactivate = need_deactivate;\n\n\tif (pdata) {\n\t\tsmbdev->board.platform_data = kmemdup(pdata, pdata_size,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!smbdev->board.platform_data) {\n\t\t\tkfree(smbdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (need_deactivate)\n\t\tpsmouse_deactivate(psmouse);\n\n\tpsmouse->private = smbdev;\n\tpsmouse->protocol_handler = psmouse_smbus_process_byte;\n\tpsmouse->reconnect = psmouse_smbus_reconnect;\n\tpsmouse->fast_reconnect = psmouse_smbus_reconnect;\n\tpsmouse->disconnect = psmouse_smbus_disconnect;\n\tpsmouse->resync_time = 0;\n\n\tmutex_lock(&psmouse_smbus_mutex);\n\tlist_add_tail(&smbdev->node, &psmouse_smbus_list);\n\tmutex_unlock(&psmouse_smbus_mutex);\n\n\t \n\terror = i2c_for_each_dev(smbdev, psmouse_smbus_create_companion);\n\n\tif (smbdev->client) {\n\t\t \n\t\tif (!device_link_add(&smbdev->client->dev,\n\t\t\t\t     &psmouse->ps2dev.serio->dev,\n\t\t\t\t     DL_FLAG_STATELESS))\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"failed to set up link with iSMBus companion %s\\n\",\n\t\t\t\t     dev_name(&smbdev->client->dev));\n\t\treturn 0;\n\t}\n\n\t \n\tkfree(smbdev->board.platform_data);\n\tsmbdev->board.platform_data = NULL;\n\n\tif (error < 0 || !leave_breadcrumbs) {\n\t\tmutex_lock(&psmouse_smbus_mutex);\n\t\tlist_del(&smbdev->node);\n\t\tmutex_unlock(&psmouse_smbus_mutex);\n\n\t\tkfree(smbdev);\n\t}\n\n\treturn error < 0 ? error : -EAGAIN;\n}\n\nint __init psmouse_smbus_module_init(void)\n{\n\tint error;\n\n\tpsmouse_smbus_wq = alloc_workqueue(\"psmouse-smbus\", 0, 0);\n\tif (!psmouse_smbus_wq)\n\t\treturn -ENOMEM;\n\n\terror = bus_register_notifier(&i2c_bus_type, &psmouse_smbus_notifier);\n\tif (error) {\n\t\tpr_err(\"failed to register i2c bus notifier: %d\\n\", error);\n\t\tdestroy_workqueue(psmouse_smbus_wq);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nvoid psmouse_smbus_module_exit(void)\n{\n\tbus_unregister_notifier(&i2c_bus_type, &psmouse_smbus_notifier);\n\tdestroy_workqueue(psmouse_smbus_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}