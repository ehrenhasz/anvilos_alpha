{
  "module_name": "synaptics_i2c.c",
  "hash_id": "6f63e303a0b312abb21e83d4f20d61684985e2b2e3e7c8c2385d5e30b5c2287a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/synaptics_i2c.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n\n#define DRIVER_NAME\t\t\"synaptics_i2c\"\n \n#define PRODUCT_ID_LENGTH\t15\n#define REGISTER_LENGTH\t\t8\n\n \n#define SOFT_RESET_DELAY_US\t3000\n \n#define HARD_RESET_DELAY_MS\t500\n\n \n#define PAGE_SEL_REG\t\t0xff\n#define DEVICE_STATUS_REG\t0x09\n\n \n#define DEV_CONTROL_REG\t\t0x0000\n#define INTERRUPT_EN_REG\t0x0001\n#define ERR_STAT_REG\t\t0x0002\n#define INT_REQ_STAT_REG\t0x0003\n#define DEV_COMMAND_REG\t\t0x0004\n\n#define RMI_PROT_VER_REG\t0x0200\n#define MANUFACT_ID_REG\t\t0x0201\n#define PHYS_INT_VER_REG\t0x0202\n#define PROD_PROPERTY_REG\t0x0203\n#define INFO_QUERY_REG0\t\t0x0204\n#define INFO_QUERY_REG1\t\t(INFO_QUERY_REG0 + 1)\n#define INFO_QUERY_REG2\t\t(INFO_QUERY_REG0 + 2)\n#define INFO_QUERY_REG3\t\t(INFO_QUERY_REG0 + 3)\n\n#define PRODUCT_ID_REG0\t\t0x0210\n#define PRODUCT_ID_REG1\t\t(PRODUCT_ID_REG0 + 1)\n#define PRODUCT_ID_REG2\t\t(PRODUCT_ID_REG0 + 2)\n#define PRODUCT_ID_REG3\t\t(PRODUCT_ID_REG0 + 3)\n#define PRODUCT_ID_REG4\t\t(PRODUCT_ID_REG0 + 4)\n#define PRODUCT_ID_REG5\t\t(PRODUCT_ID_REG0 + 5)\n#define PRODUCT_ID_REG6\t\t(PRODUCT_ID_REG0 + 6)\n#define PRODUCT_ID_REG7\t\t(PRODUCT_ID_REG0 + 7)\n#define PRODUCT_ID_REG8\t\t(PRODUCT_ID_REG0 + 8)\n#define PRODUCT_ID_REG9\t\t(PRODUCT_ID_REG0 + 9)\n#define PRODUCT_ID_REG10\t(PRODUCT_ID_REG0 + 10)\n#define PRODUCT_ID_REG11\t(PRODUCT_ID_REG0 + 11)\n#define PRODUCT_ID_REG12\t(PRODUCT_ID_REG0 + 12)\n#define PRODUCT_ID_REG13\t(PRODUCT_ID_REG0 + 13)\n#define PRODUCT_ID_REG14\t(PRODUCT_ID_REG0 + 14)\n#define PRODUCT_ID_REG15\t(PRODUCT_ID_REG0 + 15)\n\n#define DATA_REG0\t\t0x0400\n#define ABS_PRESSURE_REG\t0x0401\n#define ABS_MSB_X_REG\t\t0x0402\n#define ABS_LSB_X_REG\t\t(ABS_MSB_X_REG + 1)\n#define ABS_MSB_Y_REG\t\t0x0404\n#define ABS_LSB_Y_REG\t\t(ABS_MSB_Y_REG + 1)\n#define REL_X_REG\t\t0x0406\n#define REL_Y_REG\t\t0x0407\n\n#define DEV_QUERY_REG0\t\t0x1000\n#define DEV_QUERY_REG1\t\t(DEV_QUERY_REG0 + 1)\n#define DEV_QUERY_REG2\t\t(DEV_QUERY_REG0 + 2)\n#define DEV_QUERY_REG3\t\t(DEV_QUERY_REG0 + 3)\n#define DEV_QUERY_REG4\t\t(DEV_QUERY_REG0 + 4)\n#define DEV_QUERY_REG5\t\t(DEV_QUERY_REG0 + 5)\n#define DEV_QUERY_REG6\t\t(DEV_QUERY_REG0 + 6)\n#define DEV_QUERY_REG7\t\t(DEV_QUERY_REG0 + 7)\n#define DEV_QUERY_REG8\t\t(DEV_QUERY_REG0 + 8)\n\n#define GENERAL_2D_CONTROL_REG\t0x1041\n#define SENSOR_SENSITIVITY_REG\t0x1044\n#define SENS_MAX_POS_MSB_REG\t0x1046\n#define SENS_MAX_POS_LSB_REG\t(SENS_MAX_POS_UPPER_REG + 1)\n\n \n \n#define REPORT_RATE_1ST_BIT\t6\n\n \n#define F10_ABS_INT_ENA\t\t0\n#define F10_REL_INT_ENA\t\t1\n#define F20_INT_ENA\t\t2\n\n \n#define F10_ABS_INT_REQ\t\t0\n#define F10_REL_INT_REQ\t\t1\n#define F20_INT_REQ\t\t2\n \n#define STAT_CONFIGURED\t\t6\n#define STAT_ERROR\t\t7\n\n \n#define RESET_COMMAND\t\t0x01\n#define REZERO_COMMAND\t\t0x02\n\n \n#define GESTURE\t\t\t3\n\n \n \n#define HAS_PALM_DETECT\t\t1\n#define HAS_MULTI_FING\t\t2\n#define HAS_SCROLLER\t\t4\n#define HAS_2D_SCROLL\t\t5\n\n \n#define NO_DECELERATION\t\t1\n#define REDUCE_REPORTING\t3\n#define NO_FILTER\t\t5\n\n \n \n#define REPORT_RATE_MSK\t\t0xc0\n#define SLEEP_MODE_MSK\t\t0x07\n\n \n#define FULL_AWAKE\t\t0x0\n#define NORMAL_OP\t\t0x1\n#define LOW_PWR_OP\t\t0x2\n#define VERY_LOW_PWR_OP\t\t0x3\n#define SENS_SLEEP\t\t0x4\n#define SLEEP_MOD\t\t0x5\n#define DEEP_SLEEP\t\t0x6\n#define HIBERNATE\t\t0x7\n\n \n \n#define INT_ENA_REQ_MSK\t\t0x07\n#define INT_ENA_ABS_MSK\t\t0x01\n#define INT_ENA_REL_MSK\t\t0x02\n#define INT_ENA_F20_MSK\t\t0x04\n\n \n#define CONFIGURED_MSK\t\t0x40\n#define ERROR_MSK\t\t0x80\n\n \n#define FINGER_WIDTH_MSK\t0xf0\n#define GESTURE_MSK\t\t0x08\n#define SENSOR_STATUS_MSK\t0x07\n\n \n#define MSB_POSITION_MSK\t0x1f\n\n \n\n \n#define NUM_EXTRA_POS_MSK\t0x07\n\n \n#define THREAD_IRQ_SLEEP_SECS\t2\n#define THREAD_IRQ_SLEEP_MSECS\t(THREAD_IRQ_SLEEP_SECS * MSEC_PER_SEC)\n\n \n#define NO_DATA_THRES\t\t(MSEC_PER_SEC)\n#define NO_DATA_SLEEP_MSECS\t(MSEC_PER_SEC / 4)\n\n \nstatic bool no_decel = true;\nmodule_param(no_decel, bool, 0644);\nMODULE_PARM_DESC(no_decel, \"No Deceleration. Default = 1 (on)\");\n\n \nstatic bool reduce_report;\nmodule_param(reduce_report, bool, 0644);\nMODULE_PARM_DESC(reduce_report, \"Reduced Reporting. Default = 0 (off)\");\n\n \nstatic bool no_filter;\nmodule_param(no_filter, bool, 0644);\nMODULE_PARM_DESC(no_filter, \"No Filter. Default = 0 (off)\");\n\n \n \nstatic bool polling_req;\nmodule_param(polling_req, bool, 0444);\nMODULE_PARM_DESC(polling_req, \"Request Polling. Default = 0 (use irq)\");\n\n \nstatic int scan_rate = 80;\nmodule_param(scan_rate, int, 0644);\nMODULE_PARM_DESC(scan_rate, \"Polling rate in times/sec. Default = 80\");\n\n \nstruct synaptics_i2c {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input;\n\tstruct delayed_work\tdwork;\n\tint\t\t\tno_data_count;\n\tint\t\t\tno_decel_param;\n\tint\t\t\treduce_report_param;\n\tint\t\t\tno_filter_param;\n\tint\t\t\tscan_rate_param;\n\tint\t\t\tscan_ms;\n};\n\nstatic inline void set_scan_rate(struct synaptics_i2c *touch, int scan_rate)\n{\n\ttouch->scan_ms = MSEC_PER_SEC / scan_rate;\n\ttouch->scan_rate_param = scan_rate;\n}\n\n \nstatic s32 synaptics_i2c_reg_get(struct i2c_client *client, u16 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PAGE_SEL_REG, reg >> 8);\n\tif (ret == 0)\n\t\tret = i2c_smbus_read_byte_data(client, reg & 0xff);\n\n\treturn ret;\n}\n\nstatic s32 synaptics_i2c_reg_set(struct i2c_client *client, u16 reg, u8 val)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PAGE_SEL_REG, reg >> 8);\n\tif (ret == 0)\n\t\tret = i2c_smbus_write_byte_data(client, reg & 0xff, val);\n\n\treturn ret;\n}\n\nstatic s32 synaptics_i2c_word_get(struct i2c_client *client, u16 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, PAGE_SEL_REG, reg >> 8);\n\tif (ret == 0)\n\t\tret = i2c_smbus_read_word_data(client, reg & 0xff);\n\n\treturn ret;\n}\n\nstatic int synaptics_i2c_config(struct i2c_client *client)\n{\n\tint ret, control;\n\tu8 int_en;\n\n\t \n\tret = synaptics_i2c_reg_set(client, DEV_CONTROL_REG, 0xc1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tint_en = (polling_req) ? 0 : INT_ENA_ABS_MSK | INT_ENA_REL_MSK;\n\tret = synaptics_i2c_reg_set(client, INTERRUPT_EN_REG, int_en);\n\tif (ret)\n\t\treturn ret;\n\n\tcontrol = synaptics_i2c_reg_get(client, GENERAL_2D_CONTROL_REG);\n\t \n\tcontrol |= no_decel ? 1 << NO_DECELERATION : 0;\n\t \n\tcontrol |= reduce_report ? 1 << REDUCE_REPORTING : 0;\n\t \n\tcontrol |= no_filter ? 1 << NO_FILTER : 0;\n\tret = synaptics_i2c_reg_set(client, GENERAL_2D_CONTROL_REG, control);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int synaptics_i2c_reset_config(struct i2c_client *client)\n{\n\tint ret;\n\n\t \n\tret = synaptics_i2c_reg_set(client, DEV_COMMAND_REG, RESET_COMMAND);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to reset device\\n\");\n\t} else {\n\t\tusleep_range(SOFT_RESET_DELAY_US, SOFT_RESET_DELAY_US + 100);\n\t\tret = synaptics_i2c_config(client);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"Unable to config device\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int synaptics_i2c_check_error(struct i2c_client *client)\n{\n\tint status, ret = 0;\n\n\tstatus = i2c_smbus_read_byte_data(client, DEVICE_STATUS_REG) &\n\t\t(CONFIGURED_MSK | ERROR_MSK);\n\n\tif (status != CONFIGURED_MSK)\n\t\tret = synaptics_i2c_reset_config(client);\n\n\treturn ret;\n}\n\nstatic bool synaptics_i2c_get_input(struct synaptics_i2c *touch)\n{\n\tstruct input_dev *input = touch->input;\n\tint xy_delta, gesture;\n\ts32 data;\n\ts8 x_delta, y_delta;\n\n\t \n\tif (synaptics_i2c_check_error(touch->client))\n\t\treturn false;\n\n\t \n\tdata = synaptics_i2c_reg_get(touch->client, DATA_REG0);\n\tgesture = (data >> GESTURE) & 0x1;\n\n\t \n\txy_delta = synaptics_i2c_word_get(touch->client, REL_X_REG) & 0xffff;\n\n\t \n\tx_delta = xy_delta & 0xff;\n\ty_delta = (xy_delta >> REGISTER_LENGTH) & 0xff;\n\n\t \n\tinput_report_key(input, BTN_LEFT, gesture);\n\n\t \n\tinput_report_rel(input, REL_X, x_delta);\n\tinput_report_rel(input, REL_Y, -y_delta);\n\tinput_sync(input);\n\n\treturn xy_delta || gesture;\n}\n\nstatic irqreturn_t synaptics_i2c_irq(int irq, void *dev_id)\n{\n\tstruct synaptics_i2c *touch = dev_id;\n\n\tmod_delayed_work(system_wq, &touch->dwork, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void synaptics_i2c_check_params(struct synaptics_i2c *touch)\n{\n\tbool reset = false;\n\n\tif (scan_rate != touch->scan_rate_param)\n\t\tset_scan_rate(touch, scan_rate);\n\n\tif (no_decel != touch->no_decel_param) {\n\t\ttouch->no_decel_param = no_decel;\n\t\treset = true;\n\t}\n\n\tif (no_filter != touch->no_filter_param) {\n\t\ttouch->no_filter_param = no_filter;\n\t\treset = true;\n\t}\n\n\tif (reduce_report != touch->reduce_report_param) {\n\t\ttouch->reduce_report_param = reduce_report;\n\t\treset = true;\n\t}\n\n\tif (reset)\n\t\tsynaptics_i2c_reset_config(touch->client);\n}\n\n \nstatic unsigned long synaptics_i2c_adjust_delay(struct synaptics_i2c *touch,\n\t\t\t\t\t\tbool have_data)\n{\n\tunsigned long delay, nodata_count_thres;\n\n\tif (polling_req) {\n\t\tdelay = touch->scan_ms;\n\t\tif (have_data) {\n\t\t\ttouch->no_data_count = 0;\n\t\t} else {\n\t\t\tnodata_count_thres = NO_DATA_THRES / touch->scan_ms;\n\t\t\tif (touch->no_data_count < nodata_count_thres)\n\t\t\t\ttouch->no_data_count++;\n\t\t\telse\n\t\t\t\tdelay = NO_DATA_SLEEP_MSECS;\n\t\t}\n\t\treturn msecs_to_jiffies(delay);\n\t} else {\n\t\tdelay = msecs_to_jiffies(THREAD_IRQ_SLEEP_MSECS);\n\t\treturn round_jiffies_relative(delay);\n\t}\n}\n\n \nstatic void synaptics_i2c_work_handler(struct work_struct *work)\n{\n\tbool have_data;\n\tstruct synaptics_i2c *touch =\n\t\t\tcontainer_of(work, struct synaptics_i2c, dwork.work);\n\tunsigned long delay;\n\n\tsynaptics_i2c_check_params(touch);\n\n\thave_data = synaptics_i2c_get_input(touch);\n\tdelay = synaptics_i2c_adjust_delay(touch, have_data);\n\n\t \n\tmod_delayed_work(system_wq, &touch->dwork, delay);\n}\n\nstatic int synaptics_i2c_open(struct input_dev *input)\n{\n\tstruct synaptics_i2c *touch = input_get_drvdata(input);\n\tint ret;\n\n\tret = synaptics_i2c_reset_config(touch->client);\n\tif (ret)\n\t\treturn ret;\n\n\tif (polling_req)\n\t\tmod_delayed_work(system_wq, &touch->dwork,\n\t\t\t\tmsecs_to_jiffies(NO_DATA_SLEEP_MSECS));\n\n\treturn 0;\n}\n\nstatic void synaptics_i2c_close(struct input_dev *input)\n{\n\tstruct synaptics_i2c *touch = input_get_drvdata(input);\n\n\tif (!polling_req)\n\t\tsynaptics_i2c_reg_set(touch->client, INTERRUPT_EN_REG, 0);\n\n\tcancel_delayed_work_sync(&touch->dwork);\n\n\t \n\tsynaptics_i2c_reg_set(touch->client, DEV_CONTROL_REG, DEEP_SLEEP);\n}\n\nstatic void synaptics_i2c_set_input_params(struct synaptics_i2c *touch)\n{\n\tstruct input_dev *input = touch->input;\n\n\tinput->name = touch->client->name;\n\tinput->phys = touch->client->adapter->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.version = synaptics_i2c_word_get(touch->client,\n\t\t\t\t\t\t   INFO_QUERY_REG0);\n\tinput->dev.parent = &touch->client->dev;\n\tinput->open = synaptics_i2c_open;\n\tinput->close = synaptics_i2c_close;\n\tinput_set_drvdata(input, touch);\n\n\t \n\t__set_bit(EV_REL, input->evbit);\n\t__set_bit(REL_X, input->relbit);\n\t__set_bit(REL_Y, input->relbit);\n\n\t \n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(BTN_LEFT, input->keybit);\n}\n\nstatic struct synaptics_i2c *synaptics_i2c_touch_create(struct i2c_client *client)\n{\n\tstruct synaptics_i2c *touch;\n\n\ttouch = kzalloc(sizeof(struct synaptics_i2c), GFP_KERNEL);\n\tif (!touch)\n\t\treturn NULL;\n\n\ttouch->client = client;\n\ttouch->no_decel_param = no_decel;\n\ttouch->scan_rate_param = scan_rate;\n\tset_scan_rate(touch, scan_rate);\n\tINIT_DELAYED_WORK(&touch->dwork, synaptics_i2c_work_handler);\n\n\treturn touch;\n}\n\nstatic int synaptics_i2c_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct synaptics_i2c *touch;\n\n\ttouch = synaptics_i2c_touch_create(client);\n\tif (!touch)\n\t\treturn -ENOMEM;\n\n\tret = synaptics_i2c_reset_config(client);\n\tif (ret)\n\t\tgoto err_mem_free;\n\n\tif (client->irq < 1)\n\t\tpolling_req = true;\n\n\ttouch->input = input_allocate_device();\n\tif (!touch->input) {\n\t\tret = -ENOMEM;\n\t\tgoto err_mem_free;\n\t}\n\n\tsynaptics_i2c_set_input_params(touch);\n\n\tif (!polling_req) {\n\t\tdev_dbg(&touch->client->dev,\n\t\t\t \"Requesting IRQ: %d\\n\", touch->client->irq);\n\n\t\tret = request_irq(touch->client->irq, synaptics_i2c_irq,\n\t\t\t\t  IRQ_TYPE_EDGE_FALLING,\n\t\t\t\t  DRIVER_NAME, touch);\n\t\tif (ret) {\n\t\t\tdev_warn(&touch->client->dev,\n\t\t\t\t  \"IRQ request failed: %d, \"\n\t\t\t\t  \"falling back to polling\\n\", ret);\n\t\t\tpolling_req = true;\n\t\t\tsynaptics_i2c_reg_set(touch->client,\n\t\t\t\t\t      INTERRUPT_EN_REG, 0);\n\t\t}\n\t}\n\n\tif (polling_req)\n\t\tdev_dbg(&touch->client->dev,\n\t\t\t \"Using polling at rate: %d times/sec\\n\", scan_rate);\n\n\t \n\tret = input_register_device(touch->input);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t \"Input device register failed: %d\\n\", ret);\n\t\tgoto err_input_free;\n\t}\n\n\ti2c_set_clientdata(client, touch);\n\n\treturn 0;\n\nerr_input_free:\n\tinput_free_device(touch->input);\nerr_mem_free:\n\tkfree(touch);\n\n\treturn ret;\n}\n\nstatic void synaptics_i2c_remove(struct i2c_client *client)\n{\n\tstruct synaptics_i2c *touch = i2c_get_clientdata(client);\n\n\tif (!polling_req)\n\t\tfree_irq(client->irq, touch);\n\n\tinput_unregister_device(touch->input);\n\tkfree(touch);\n}\n\nstatic int synaptics_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct synaptics_i2c *touch = i2c_get_clientdata(client);\n\n\tcancel_delayed_work_sync(&touch->dwork);\n\n\t \n\tsynaptics_i2c_reg_set(touch->client, DEV_CONTROL_REG, DEEP_SLEEP);\n\n\treturn 0;\n}\n\nstatic int synaptics_i2c_resume(struct device *dev)\n{\n\tint ret;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct synaptics_i2c *touch = i2c_get_clientdata(client);\n\n\tret = synaptics_i2c_reset_config(client);\n\tif (ret)\n\t\treturn ret;\n\n\tmod_delayed_work(system_wq, &touch->dwork,\n\t\t\t\tmsecs_to_jiffies(NO_DATA_SLEEP_MSECS));\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(synaptics_i2c_pm, synaptics_i2c_suspend,\n\t\t\t\tsynaptics_i2c_resume);\n\nstatic const struct i2c_device_id synaptics_i2c_id_table[] = {\n\t{ \"synaptics_i2c\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, synaptics_i2c_id_table);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id synaptics_i2c_of_match[] = {\n\t{ .compatible = \"synaptics,synaptics_i2c\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, synaptics_i2c_of_match);\n#endif\n\nstatic struct i2c_driver synaptics_i2c_driver = {\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(synaptics_i2c_of_match),\n\t\t.pm\t= pm_sleep_ptr(&synaptics_i2c_pm),\n\t},\n\n\t.probe\t\t= synaptics_i2c_probe,\n\t.remove\t\t= synaptics_i2c_remove,\n\n\t.id_table\t= synaptics_i2c_id_table,\n};\n\nmodule_i2c_driver(synaptics_i2c_driver);\n\nMODULE_DESCRIPTION(\"Synaptics I2C touchpad driver\");\nMODULE_AUTHOR(\"Mike Rapoport, Igor Grinberg, Compulab\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}