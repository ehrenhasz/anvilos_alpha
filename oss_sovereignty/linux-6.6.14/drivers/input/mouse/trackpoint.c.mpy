{
  "module_name": "trackpoint.c",
  "hash_id": "d7570cbf0c427177316b5edede0cb0f7ef394b6b7781440cbed61b10b9e2a334",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/trackpoint.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/serio.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/libps2.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include \"psmouse.h\"\n#include \"trackpoint.h\"\n\nstatic const char * const trackpoint_variants[] = {\n\t[TP_VARIANT_IBM]\t\t= \"IBM\",\n\t[TP_VARIANT_ALPS]\t\t= \"ALPS\",\n\t[TP_VARIANT_ELAN]\t\t= \"Elan\",\n\t[TP_VARIANT_NXP]\t\t= \"NXP\",\n\t[TP_VARIANT_JYT_SYNAPTICS]\t= \"JYT_Synaptics\",\n\t[TP_VARIANT_SYNAPTICS]\t\t= \"Synaptics\",\n};\n\n \nstatic int trackpoint_power_on_reset(struct ps2dev *ps2dev)\n{\n\tu8 param[2] = { TP_POR };\n\tint err;\n\n\terr = ps2_command(ps2dev, param, MAKE_PS2_CMD(1, 2, TP_COMMAND));\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (param[0] != 0xAA || param[1] != 0x00)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int trackpoint_read(struct ps2dev *ps2dev, u8 loc, u8 *results)\n{\n\tresults[0] = loc;\n\n\treturn ps2_command(ps2dev, results, MAKE_PS2_CMD(1, 1, TP_COMMAND));\n}\n\nstatic int trackpoint_write(struct ps2dev *ps2dev, u8 loc, u8 val)\n{\n\tu8 param[3] = { TP_WRITE_MEM, loc, val };\n\n\treturn ps2_command(ps2dev, param, MAKE_PS2_CMD(3, 0, TP_COMMAND));\n}\n\nstatic int trackpoint_toggle_bit(struct ps2dev *ps2dev, u8 loc, u8 mask)\n{\n\tu8 param[3] = { TP_TOGGLE, loc, mask };\n\n\t \n\tif (loc < 0x20 || loc >= 0x2F)\n\t\treturn -EINVAL;\n\n\treturn ps2_command(ps2dev, param, MAKE_PS2_CMD(3, 0, TP_COMMAND));\n}\n\nstatic int trackpoint_update_bit(struct ps2dev *ps2dev,\n\t\t\t\t u8 loc, u8 mask, u8 value)\n{\n\tint retval;\n\tu8 data;\n\n\tretval = trackpoint_read(ps2dev, loc, &data);\n\tif (retval)\n\t\treturn retval;\n\n\tif (((data & mask) == mask) != !!value)\n\t\tretval = trackpoint_toggle_bit(ps2dev, loc, mask);\n\n\treturn retval;\n}\n\n \nstruct trackpoint_attr_data {\n\tsize_t field_offset;\n\tu8 command;\n\tu8 mask;\n\tbool inverted;\n\tu8 power_on_default;\n};\n\nstatic ssize_t trackpoint_show_int_attr(struct psmouse *psmouse,\n\t\t\t\t\tvoid *data, char *buf)\n{\n\tstruct trackpoint_data *tp = psmouse->private;\n\tstruct trackpoint_attr_data *attr = data;\n\tu8 value = *(u8 *)((void *)tp + attr->field_offset);\n\n\tif (attr->inverted)\n\t\tvalue = !value;\n\n\treturn sprintf(buf, \"%u\\n\", value);\n}\n\nstatic ssize_t trackpoint_set_int_attr(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct trackpoint_data *tp = psmouse->private;\n\tstruct trackpoint_attr_data *attr = data;\n\tu8 *field = (void *)tp + attr->field_offset;\n\tu8 value;\n\tint err;\n\n\terr = kstrtou8(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\t*field = value;\n\terr = trackpoint_write(&psmouse->ps2dev, attr->command, value);\n\n\treturn err ?: count;\n}\n\n#define TRACKPOINT_INT_ATTR(_name, _command, _default)\t\t\t\t\\\n\tstatic struct trackpoint_attr_data trackpoint_attr_##_name = {\t\t\\\n\t\t.field_offset = offsetof(struct trackpoint_data, _name),\t\\\n\t\t.command = _command,\t\t\t\t\t\t\\\n\t\t.power_on_default = _default,\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\t\\\n\tPSMOUSE_DEFINE_ATTR(_name, S_IWUSR | S_IRUGO,\t\t\t\t\\\n\t\t\t    &trackpoint_attr_##_name,\t\t\t\t\\\n\t\t\t    trackpoint_show_int_attr, trackpoint_set_int_attr)\n\nstatic ssize_t trackpoint_set_bit_attr(struct psmouse *psmouse, void *data,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct trackpoint_data *tp = psmouse->private;\n\tstruct trackpoint_attr_data *attr = data;\n\tbool *field = (void *)tp + attr->field_offset;\n\tbool value;\n\tint err;\n\n\terr = kstrtobool(buf, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->inverted)\n\t\tvalue = !value;\n\n\tif (*field != value) {\n\t\t*field = value;\n\t\terr = trackpoint_toggle_bit(&psmouse->ps2dev,\n\t\t\t\t\t    attr->command, attr->mask);\n\t}\n\n\treturn err ?: count;\n}\n\n\n#define TRACKPOINT_BIT_ATTR(_name, _command, _mask, _inv, _default)\t\\\nstatic struct trackpoint_attr_data trackpoint_attr_##_name = {\t\t\\\n\t.field_offset\t\t= offsetof(struct trackpoint_data,\t\\\n\t\t\t\t\t   _name),\t\t\t\\\n\t.command\t\t= _command,\t\t\t\t\\\n\t.mask\t\t\t= _mask,\t\t\t\t\\\n\t.inverted\t\t= _inv,\t\t\t\t\t\\\n\t.power_on_default\t= _default,\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\nPSMOUSE_DEFINE_ATTR(_name, S_IWUSR | S_IRUGO,\t\t\t\t\\\n\t\t    &trackpoint_attr_##_name,\t\t\t\t\\\n\t\t    trackpoint_show_int_attr, trackpoint_set_bit_attr)\n\nTRACKPOINT_INT_ATTR(sensitivity, TP_SENS, TP_DEF_SENS);\nTRACKPOINT_INT_ATTR(speed, TP_SPEED, TP_DEF_SPEED);\nTRACKPOINT_INT_ATTR(inertia, TP_INERTIA, TP_DEF_INERTIA);\nTRACKPOINT_INT_ATTR(reach, TP_REACH, TP_DEF_REACH);\nTRACKPOINT_INT_ATTR(draghys, TP_DRAGHYS, TP_DEF_DRAGHYS);\nTRACKPOINT_INT_ATTR(mindrag, TP_MINDRAG, TP_DEF_MINDRAG);\nTRACKPOINT_INT_ATTR(thresh, TP_THRESH, TP_DEF_THRESH);\nTRACKPOINT_INT_ATTR(upthresh, TP_UP_THRESH, TP_DEF_UP_THRESH);\nTRACKPOINT_INT_ATTR(ztime, TP_Z_TIME, TP_DEF_Z_TIME);\nTRACKPOINT_INT_ATTR(jenks, TP_JENKS_CURV, TP_DEF_JENKS_CURV);\nTRACKPOINT_INT_ATTR(drift_time, TP_DRIFT_TIME, TP_DEF_DRIFT_TIME);\n\nTRACKPOINT_BIT_ATTR(press_to_select, TP_TOGGLE_PTSON, TP_MASK_PTSON, false,\n\t\t    TP_DEF_PTSON);\nTRACKPOINT_BIT_ATTR(skipback, TP_TOGGLE_SKIPBACK, TP_MASK_SKIPBACK, false,\n\t\t    TP_DEF_SKIPBACK);\nTRACKPOINT_BIT_ATTR(ext_dev, TP_TOGGLE_EXT_DEV, TP_MASK_EXT_DEV, true,\n\t\t    TP_DEF_EXT_DEV);\n\nstatic bool trackpoint_is_attr_available(struct psmouse *psmouse,\n\t\t\t\t\t struct attribute *attr)\n{\n\tstruct trackpoint_data *tp = psmouse->private;\n\n\treturn tp->variant_id == TP_VARIANT_IBM ||\n\t\tattr == &psmouse_attr_sensitivity.dattr.attr ||\n\t\tattr == &psmouse_attr_press_to_select.dattr.attr;\n}\n\nstatic umode_t trackpoint_is_attr_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct psmouse *psmouse = psmouse_from_serio(serio);\n\n\treturn trackpoint_is_attr_available(psmouse, attr) ? attr->mode : 0;\n}\n\nstatic struct attribute *trackpoint_attrs[] = {\n\t&psmouse_attr_sensitivity.dattr.attr,\n\t&psmouse_attr_speed.dattr.attr,\n\t&psmouse_attr_inertia.dattr.attr,\n\t&psmouse_attr_reach.dattr.attr,\n\t&psmouse_attr_draghys.dattr.attr,\n\t&psmouse_attr_mindrag.dattr.attr,\n\t&psmouse_attr_thresh.dattr.attr,\n\t&psmouse_attr_upthresh.dattr.attr,\n\t&psmouse_attr_ztime.dattr.attr,\n\t&psmouse_attr_jenks.dattr.attr,\n\t&psmouse_attr_drift_time.dattr.attr,\n\t&psmouse_attr_press_to_select.dattr.attr,\n\t&psmouse_attr_skipback.dattr.attr,\n\t&psmouse_attr_ext_dev.dattr.attr,\n\tNULL\n};\n\nstatic struct attribute_group trackpoint_attr_group = {\n\t.is_visible\t= trackpoint_is_attr_visible,\n\t.attrs\t\t= trackpoint_attrs,\n};\n\n#define TRACKPOINT_UPDATE(_power_on, _psmouse, _tp, _name)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstruct trackpoint_attr_data *_attr = &trackpoint_attr_##_name;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif ((!_power_on || _tp->_name != _attr->power_on_default) &&\t\\\n\t    trackpoint_is_attr_available(_psmouse,\t\t\t\\\n\t\t\t\t&psmouse_attr_##_name.dattr.attr)) {\t\\\n\t\tif (!_attr->mask)\t\t\t\t\t\\\n\t\t\ttrackpoint_write(&_psmouse->ps2dev,\t\t\\\n\t\t\t\t\t _attr->command, _tp->_name);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\ttrackpoint_update_bit(&_psmouse->ps2dev,\t\\\n\t\t\t\t\t_attr->command, _attr->mask,\t\\\n\t\t\t\t\t_tp->_name);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define TRACKPOINT_SET_POWER_ON_DEFAULT(_tp, _name)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t_tp->_name = trackpoint_attr_##_name.power_on_default;\t\t\\\n} while (0)\n\nstatic int trackpoint_start_protocol(struct psmouse *psmouse,\n\t\t\t\t     u8 *variant_id, u8 *firmware_id)\n{\n\tu8 param[2] = { 0 };\n\tint error;\n\n\terror = ps2_command(&psmouse->ps2dev,\n\t\t\t    param, MAKE_PS2_CMD(0, 2, TP_READ_ID));\n\tif (error)\n\t\treturn error;\n\n\tswitch (param[0]) {\n\tcase TP_VARIANT_IBM:\n\tcase TP_VARIANT_ALPS:\n\tcase TP_VARIANT_ELAN:\n\tcase TP_VARIANT_NXP:\n\tcase TP_VARIANT_JYT_SYNAPTICS:\n\tcase TP_VARIANT_SYNAPTICS:\n\t\tif (variant_id)\n\t\t\t*variant_id = param[0];\n\t\tif (firmware_id)\n\t\t\t*firmware_id = param[1];\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int trackpoint_sync(struct psmouse *psmouse, bool in_power_on_state)\n{\n\tstruct trackpoint_data *tp = psmouse->private;\n\n\tif (!in_power_on_state && tp->variant_id == TP_VARIANT_IBM) {\n\t\t \n\t\ttrackpoint_update_bit(&psmouse->ps2dev, TP_TOGGLE_TWOHAND,\n\t\t\t\t      TP_MASK_TWOHAND, TP_DEF_TWOHAND);\n\n\t\ttrackpoint_update_bit(&psmouse->ps2dev, TP_TOGGLE_SOURCE_TAG,\n\t\t\t\t      TP_MASK_SOURCE_TAG, TP_DEF_SOURCE_TAG);\n\n\t\ttrackpoint_update_bit(&psmouse->ps2dev, TP_TOGGLE_MB,\n\t\t\t\t      TP_MASK_MB, TP_DEF_MB);\n\t}\n\n\t \n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, sensitivity);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, inertia);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, speed);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, reach);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, draghys);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, mindrag);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, thresh);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, upthresh);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, ztime);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, jenks);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, drift_time);\n\n\t \n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, press_to_select);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, skipback);\n\tTRACKPOINT_UPDATE(in_power_on_state, psmouse, tp, ext_dev);\n\n\treturn 0;\n}\n\nstatic void trackpoint_defaults(struct trackpoint_data *tp)\n{\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, sensitivity);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, speed);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, reach);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, draghys);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, mindrag);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, thresh);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, upthresh);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, ztime);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, jenks);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, drift_time);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, inertia);\n\n\t \n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, press_to_select);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, skipback);\n\tTRACKPOINT_SET_POWER_ON_DEFAULT(tp, ext_dev);\n}\n\nstatic void trackpoint_disconnect(struct psmouse *psmouse)\n{\n\tdevice_remove_group(&psmouse->ps2dev.serio->dev,\n\t\t\t    &trackpoint_attr_group);\n\n\tkfree(psmouse->private);\n\tpsmouse->private = NULL;\n}\n\nstatic int trackpoint_reconnect(struct psmouse *psmouse)\n{\n\tstruct trackpoint_data *tp = psmouse->private;\n\tint error;\n\tbool was_reset;\n\n\terror = trackpoint_start_protocol(psmouse, NULL, NULL);\n\tif (error)\n\t\treturn error;\n\n\twas_reset = tp->variant_id == TP_VARIANT_IBM &&\n\t\t    trackpoint_power_on_reset(&psmouse->ps2dev) == 0;\n\n\terror = trackpoint_sync(psmouse, was_reset);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nint trackpoint_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tstruct trackpoint_data *tp;\n\tu8 variant_id;\n\tu8 firmware_id;\n\tu8 button_info;\n\tint error;\n\n\terror = trackpoint_start_protocol(psmouse, &variant_id, &firmware_id);\n\tif (error)\n\t\treturn error;\n\n\tif (!set_properties)\n\t\treturn 0;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttrackpoint_defaults(tp);\n\ttp->variant_id = variant_id;\n\ttp->firmware_id = firmware_id;\n\n\tpsmouse->private = tp;\n\n\tpsmouse->vendor = trackpoint_variants[variant_id];\n\tpsmouse->name = \"TrackPoint\";\n\n\tpsmouse->reconnect = trackpoint_reconnect;\n\tpsmouse->disconnect = trackpoint_disconnect;\n\n\tif (variant_id != TP_VARIANT_IBM) {\n\t\t \n\t\tbutton_info = 0x33;\n\t} else {\n\t\terror = trackpoint_read(ps2dev, TP_EXT_BTN, &button_info);\n\t\tif (error) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"failed to get extended button data, assuming 3 buttons\\n\");\n\t\t\tbutton_info = 0x33;\n\t\t} else if (!button_info) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"got 0 in extended button data, assuming 3 buttons\\n\");\n\t\t\tbutton_info = 0x33;\n\t\t}\n\t}\n\n\tif ((button_info & 0x0f) >= 3)\n\t\tinput_set_capability(psmouse->dev, EV_KEY, BTN_MIDDLE);\n\n\t__set_bit(INPUT_PROP_POINTER, psmouse->dev->propbit);\n\t__set_bit(INPUT_PROP_POINTING_STICK, psmouse->dev->propbit);\n\n\tif (variant_id != TP_VARIANT_IBM ||\n\t    trackpoint_power_on_reset(ps2dev) != 0) {\n\t\t \n\t\ttrackpoint_sync(psmouse, false);\n\t}\n\n\terror = device_add_group(&ps2dev->serio->dev, &trackpoint_attr_group);\n\tif (error) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to create sysfs attributes, error: %d\\n\",\n\t\t\t    error);\n\t\tkfree(psmouse->private);\n\t\tpsmouse->private = NULL;\n\t\treturn -1;\n\t}\n\n\tpsmouse_info(psmouse,\n\t\t     \"%s TrackPoint firmware: 0x%02x, buttons: %d/%d\\n\",\n\t\t     psmouse->vendor, firmware_id,\n\t\t     (button_info & 0xf0) >> 4, button_info & 0x0f);\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}