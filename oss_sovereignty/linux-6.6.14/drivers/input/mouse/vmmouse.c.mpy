{
  "module_name": "vmmouse.c",
  "hash_id": "fbe626ad7555c02f55b02e067363417610da80d3be623aa4c3b28dad52ea1ecc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/vmmouse.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <asm/hypervisor.h>\n#include <asm/vmware.h>\n\n#include \"psmouse.h\"\n#include \"vmmouse.h\"\n\n#define VMMOUSE_PROTO_MAGIC\t\t\t0x564D5868U\n\n \n#define VMMOUSE_PROTO_CMD_GETVERSION\t\t10\n#define VMMOUSE_PROTO_CMD_ABSPOINTER_DATA\t39\n#define VMMOUSE_PROTO_CMD_ABSPOINTER_STATUS\t40\n#define VMMOUSE_PROTO_CMD_ABSPOINTER_COMMAND\t41\n#define VMMOUSE_PROTO_CMD_ABSPOINTER_RESTRICT   86\n\n \n#define VMMOUSE_CMD_ENABLE\t\t\t0x45414552U\n#define VMMOUSE_CMD_DISABLE\t\t\t0x000000f5U\n#define VMMOUSE_CMD_REQUEST_RELATIVE\t\t0x4c455252U\n#define VMMOUSE_CMD_REQUEST_ABSOLUTE\t\t0x53424152U\n\n#define VMMOUSE_ERROR\t\t\t\t0xffff0000U\n\n#define VMMOUSE_VERSION_ID\t\t\t0x3442554aU\n\n#define VMMOUSE_RELATIVE_PACKET\t\t\t0x00010000U\n\n#define VMMOUSE_LEFT_BUTTON\t\t\t0x20\n#define VMMOUSE_RIGHT_BUTTON\t\t\t0x10\n#define VMMOUSE_MIDDLE_BUTTON\t\t\t0x08\n\n \n#define VMMOUSE_RESTRICT_ANY                    0x00\n#define VMMOUSE_RESTRICT_CPL0                   0x01\n#define VMMOUSE_RESTRICT_IOPL                   0x02\n\n#define VMMOUSE_MAX_X                           0xFFFF\n#define VMMOUSE_MAX_Y                           0xFFFF\n\n#define VMMOUSE_VENDOR \"VMware\"\n#define VMMOUSE_NAME   \"VMMouse\"\n\n \nstruct vmmouse_data {\n\tstruct input_dev *abs_dev;\n\tchar phys[32];\n\tchar dev_name[128];\n};\n\n \n#define VMMOUSE_CMD(cmd, in1, out1, out2, out3, out4)\t\\\n({\t\t\t\t\t\t\t\\\n\tunsigned long __dummy1, __dummy2;\t\t\\\n\t__asm__ __volatile__ (VMWARE_HYPERCALL :\t\\\n\t\t\"=a\"(out1),\t\t\t\t\\\n\t\t\"=b\"(out2),\t\t\t\t\\\n\t\t\"=c\"(out3),\t\t\t\t\\\n\t\t\"=d\"(out4),\t\t\t\t\\\n\t\t\"=S\"(__dummy1),\t\t\t\t\\\n\t\t\"=D\"(__dummy2) :\t\t\t\\\n\t\t\"a\"(VMMOUSE_PROTO_MAGIC),\t\t\\\n\t\t\"b\"(in1),\t\t\t\t\\\n\t\t\"c\"(VMMOUSE_PROTO_CMD_##cmd),\t\t\\\n\t\t\"d\"(0) :\t\t\t        \\\n\t\t\"memory\");\t\t                \\\n})\n\n \nstatic void vmmouse_report_button(struct psmouse *psmouse,\n\t\t\t\t  struct input_dev *abs_dev,\n\t\t\t\t  struct input_dev *rel_dev,\n\t\t\t\t  struct input_dev *pref_dev,\n\t\t\t\t  unsigned int code, int value)\n{\n\tif (test_bit(code, abs_dev->key))\n\t\tpref_dev = abs_dev;\n\telse if (test_bit(code, rel_dev->key))\n\t\tpref_dev = rel_dev;\n\n\tinput_report_key(pref_dev, code, value);\n}\n\n \nstatic psmouse_ret_t vmmouse_report_events(struct psmouse *psmouse)\n{\n\tstruct input_dev *rel_dev = psmouse->dev;\n\tstruct vmmouse_data *priv = psmouse->private;\n\tstruct input_dev *abs_dev = priv->abs_dev;\n\tstruct input_dev *pref_dev;\n\tu32 status, x, y, z;\n\tu32 dummy1, dummy2, dummy3;\n\tunsigned int queue_length;\n\tunsigned int count = 255;\n\n\twhile (count--) {\n\t\t \n\t\tVMMOUSE_CMD(ABSPOINTER_STATUS, 0,\n\t\t\t    status, dummy1, dummy2, dummy3);\n\t\tif ((status & VMMOUSE_ERROR) == VMMOUSE_ERROR) {\n\t\t\tpsmouse_err(psmouse, \"failed to fetch status data\\n\");\n\t\t\t \n\t\t\treturn PSMOUSE_BAD_DATA;\n\t\t}\n\n\t\tqueue_length = status & 0xffff;\n\t\tif (queue_length == 0)\n\t\t\tbreak;\n\n\t\tif (queue_length % 4) {\n\t\t\tpsmouse_err(psmouse, \"invalid queue length\\n\");\n\t\t\treturn PSMOUSE_BAD_DATA;\n\t\t}\n\n\t\t \n\t\tVMMOUSE_CMD(ABSPOINTER_DATA, 4, status, x, y, z);\n\n\t\t \n\t\tif (status & VMMOUSE_RELATIVE_PACKET) {\n\t\t\tpref_dev = rel_dev;\n\t\t\tinput_report_rel(rel_dev, REL_X, (s32)x);\n\t\t\tinput_report_rel(rel_dev, REL_Y, -(s32)y);\n\t\t} else {\n\t\t\tpref_dev = abs_dev;\n\t\t\tinput_report_abs(abs_dev, ABS_X, x);\n\t\t\tinput_report_abs(abs_dev, ABS_Y, y);\n\t\t}\n\n\t\t \n\t\tinput_report_rel(rel_dev, REL_WHEEL, -(s8)((u8) z));\n\n\t\tvmmouse_report_button(psmouse, abs_dev, rel_dev,\n\t\t\t\t      pref_dev, BTN_LEFT,\n\t\t\t\t      status & VMMOUSE_LEFT_BUTTON);\n\t\tvmmouse_report_button(psmouse, abs_dev, rel_dev,\n\t\t\t\t      pref_dev, BTN_RIGHT,\n\t\t\t\t      status & VMMOUSE_RIGHT_BUTTON);\n\t\tvmmouse_report_button(psmouse, abs_dev, rel_dev,\n\t\t\t\t      pref_dev, BTN_MIDDLE,\n\t\t\t\t      status & VMMOUSE_MIDDLE_BUTTON);\n\t\tinput_sync(abs_dev);\n\t\tinput_sync(rel_dev);\n\t}\n\n\treturn PSMOUSE_FULL_PACKET;\n}\n\n \nstatic psmouse_ret_t vmmouse_process_byte(struct psmouse *psmouse)\n{\n\tunsigned char *packet = psmouse->packet;\n\n\tswitch (psmouse->pktcnt) {\n\tcase 1:\n\t\treturn (packet[0] & 0x8) == 0x8 ?\n\t\t\tPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\n\n\tcase 2:\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\tdefault:\n\t\treturn vmmouse_report_events(psmouse);\n\t}\n}\n\n \nstatic void vmmouse_disable(struct psmouse *psmouse)\n{\n\tu32 status;\n\tu32 dummy1, dummy2, dummy3, dummy4;\n\n\tVMMOUSE_CMD(ABSPOINTER_COMMAND, VMMOUSE_CMD_DISABLE,\n\t\t    dummy1, dummy2, dummy3, dummy4);\n\n\tVMMOUSE_CMD(ABSPOINTER_STATUS, 0,\n\t\t    status, dummy1, dummy2, dummy3);\n\n\tif ((status & VMMOUSE_ERROR) != VMMOUSE_ERROR)\n\t\tpsmouse_warn(psmouse, \"failed to disable vmmouse device\\n\");\n}\n\n \nstatic int vmmouse_enable(struct psmouse *psmouse)\n{\n\tu32 status, version;\n\tu32 dummy1, dummy2, dummy3, dummy4;\n\n\t \n\tVMMOUSE_CMD(ABSPOINTER_COMMAND, VMMOUSE_CMD_ENABLE,\n\t\t    dummy1, dummy2, dummy3, dummy4);\n\n\t \n\tVMMOUSE_CMD(ABSPOINTER_STATUS, 0, status, dummy1, dummy2, dummy3);\n\tif ((status & 0x0000ffff) == 0) {\n\t\tpsmouse_dbg(psmouse, \"empty flags - assuming no device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tVMMOUSE_CMD(ABSPOINTER_DATA, 1  ,\n\t\t    version, dummy1, dummy2, dummy3);\n\tif (version != VMMOUSE_VERSION_ID) {\n\t\tpsmouse_dbg(psmouse, \"Unexpected version value: %u vs %u\\n\",\n\t\t\t    (unsigned) version, VMMOUSE_VERSION_ID);\n\t\tvmmouse_disable(psmouse);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tVMMOUSE_CMD(ABSPOINTER_RESTRICT, VMMOUSE_RESTRICT_CPL0,\n\t\t    dummy1, dummy2, dummy3, dummy4);\n\n\tVMMOUSE_CMD(ABSPOINTER_COMMAND, VMMOUSE_CMD_REQUEST_ABSOLUTE,\n\t\t    dummy1, dummy2, dummy3, dummy4);\n\n\treturn 0;\n}\n\n \nstatic enum x86_hypervisor_type vmmouse_supported_hypervisors[] = {\n\tX86_HYPER_VMWARE,\n\tX86_HYPER_KVM,\n};\n\n \nstatic bool vmmouse_check_hypervisor(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vmmouse_supported_hypervisors); i++)\n\t\tif (vmmouse_supported_hypervisors[i] == x86_hyper_type)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nint vmmouse_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tu32 response, version, dummy1, dummy2;\n\n\tif (!vmmouse_check_hypervisor()) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"VMMouse not running on supported hypervisor.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tresponse = ~VMMOUSE_PROTO_MAGIC;\n\tVMMOUSE_CMD(GETVERSION, 0, version, response, dummy1, dummy2);\n\tif (response != VMMOUSE_PROTO_MAGIC || version == 0xffffffffU)\n\t\treturn -ENXIO;\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = VMMOUSE_VENDOR;\n\t\tpsmouse->name = VMMOUSE_NAME;\n\t\tpsmouse->model = version;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vmmouse_reset(struct psmouse *psmouse)\n{\n\tvmmouse_disable(psmouse);\n\tpsmouse_reset(psmouse);\n}\n\n \nstatic void vmmouse_disconnect(struct psmouse *psmouse)\n{\n\tstruct vmmouse_data *priv = psmouse->private;\n\n\tvmmouse_disable(psmouse);\n\tpsmouse_reset(psmouse);\n\tinput_unregister_device(priv->abs_dev);\n\tkfree(priv);\n}\n\n \nstatic int vmmouse_reconnect(struct psmouse *psmouse)\n{\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\tvmmouse_disable(psmouse);\n\terror = vmmouse_enable(psmouse);\n\tif (error) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"Unable to re-enable mouse when reconnecting, err: %d\\n\",\n\t\t\t    error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint vmmouse_init(struct psmouse *psmouse)\n{\n\tstruct vmmouse_data *priv;\n\tstruct input_dev *rel_dev = psmouse->dev, *abs_dev;\n\tint error;\n\n\tpsmouse_reset(psmouse);\n\terror = vmmouse_enable(psmouse);\n\tif (error)\n\t\treturn error;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tabs_dev = input_allocate_device();\n\tif (!priv || !abs_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto init_fail;\n\t}\n\n\tpriv->abs_dev = abs_dev;\n\tpsmouse->private = priv;\n\n\t \n\tsnprintf(priv->phys, sizeof(priv->phys), \"%s/input1\",\n\t\t psmouse->ps2dev.serio->phys);\n\n\t \n\tsnprintf(priv->dev_name, sizeof(priv->dev_name), \"%s %s %s\",\n\t\t VMMOUSE_PSNAME, VMMOUSE_VENDOR, VMMOUSE_NAME);\n\tabs_dev->phys = priv->phys;\n\tabs_dev->name = priv->dev_name;\n\tabs_dev->id.bustype = BUS_I8042;\n\tabs_dev->id.vendor = 0x0002;\n\tabs_dev->id.product = PSMOUSE_VMMOUSE;\n\tabs_dev->id.version = psmouse->model;\n\tabs_dev->dev.parent = &psmouse->ps2dev.serio->dev;\n\n\t \n\tinput_set_capability(abs_dev, EV_KEY, BTN_LEFT);\n\tinput_set_capability(abs_dev, EV_KEY, BTN_RIGHT);\n\tinput_set_capability(abs_dev, EV_KEY, BTN_MIDDLE);\n\tinput_set_capability(abs_dev, EV_ABS, ABS_X);\n\tinput_set_capability(abs_dev, EV_ABS, ABS_Y);\n\tinput_set_abs_params(abs_dev, ABS_X, 0, VMMOUSE_MAX_X, 0, 0);\n\tinput_set_abs_params(abs_dev, ABS_Y, 0, VMMOUSE_MAX_Y, 0, 0);\n\n\terror = input_register_device(priv->abs_dev);\n\tif (error)\n\t\tgoto init_fail;\n\n\t \n\tinput_set_capability(rel_dev, EV_REL, REL_WHEEL);\n\n\tpsmouse->protocol_handler = vmmouse_process_byte;\n\tpsmouse->disconnect = vmmouse_disconnect;\n\tpsmouse->reconnect = vmmouse_reconnect;\n\tpsmouse->cleanup = vmmouse_reset;\n\n\treturn 0;\n\ninit_fail:\n\tvmmouse_disable(psmouse);\n\tpsmouse_reset(psmouse);\n\tinput_free_device(abs_dev);\n\tkfree(priv);\n\tpsmouse->private = NULL;\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}