{
  "module_name": "vsxxxaa.c",
  "hash_id": "311e9656959a9b3e28669bbf87785fd8ec48c6793f5f45b48a84ce406dba3d95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/vsxxxaa.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC \"Driver for DEC VSXXX-AA and -GA mice and VSXXX-AB tablet\"\n\nMODULE_AUTHOR(\"Jan-Benedict Glaw <jbglaw@lug-owl.de>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#undef VSXXXAA_DEBUG\n#ifdef VSXXXAA_DEBUG\n#define DBG(x...) printk(x)\n#else\n#define DBG(x...) do {} while (0)\n#endif\n\n#define VSXXXAA_INTRO_MASK\t0x80\n#define VSXXXAA_INTRO_HEAD\t0x80\n#define IS_HDR_BYTE(x)\t\t\t\\\n\t(((x) & VSXXXAA_INTRO_MASK) == VSXXXAA_INTRO_HEAD)\n\n#define VSXXXAA_PACKET_MASK\t0xe0\n#define VSXXXAA_PACKET_REL\t0x80\n#define VSXXXAA_PACKET_ABS\t0xc0\n#define VSXXXAA_PACKET_POR\t0xa0\n#define MATCH_PACKET_TYPE(data, type)\t\\\n\t(((data) & VSXXXAA_PACKET_MASK) == (type))\n\n\n\nstruct vsxxxaa {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n#define BUFLEN 15  \n\tunsigned char buf[BUFLEN];\n\tunsigned char count;\n\tunsigned char version;\n\tunsigned char country;\n\tunsigned char type;\n\tchar name[64];\n\tchar phys[32];\n};\n\nstatic void vsxxxaa_drop_bytes(struct vsxxxaa *mouse, int num)\n{\n\tif (num >= mouse->count) {\n\t\tmouse->count = 0;\n\t} else {\n\t\tmemmove(mouse->buf, mouse->buf + num, BUFLEN - num);\n\t\tmouse->count -= num;\n\t}\n}\n\nstatic void vsxxxaa_queue_byte(struct vsxxxaa *mouse, unsigned char byte)\n{\n\tif (mouse->count == BUFLEN) {\n\t\tprintk(KERN_ERR \"%s on %s: Dropping a byte of full buffer.\\n\",\n\t\t\tmouse->name, mouse->phys);\n\t\tvsxxxaa_drop_bytes(mouse, 1);\n\t}\n\n\tDBG(KERN_INFO \"Queueing byte 0x%02x\\n\", byte);\n\n\tmouse->buf[mouse->count++] = byte;\n}\n\nstatic void vsxxxaa_detection_done(struct vsxxxaa *mouse)\n{\n\tswitch (mouse->type) {\n\tcase 0x02:\n\t\tstrscpy(mouse->name, \"DEC VSXXX-AA/-GA mouse\",\n\t\t\tsizeof(mouse->name));\n\t\tbreak;\n\n\tcase 0x04:\n\t\tstrscpy(mouse->name, \"DEC VSXXX-AB digitizer\",\n\t\t\tsizeof(mouse->name));\n\t\tbreak;\n\n\tdefault:\n\t\tsnprintf(mouse->name, sizeof(mouse->name),\n\t\t\t \"unknown DEC pointer device (type = 0x%02x)\",\n\t\t\t mouse->type);\n\t\tbreak;\n\t}\n\n\tprintk(KERN_INFO\n\t\t\"Found %s version 0x%02x from country 0x%02x on port %s\\n\",\n\t\tmouse->name, mouse->version, mouse->country, mouse->phys);\n}\n\n \nstatic int vsxxxaa_check_packet(struct vsxxxaa *mouse, int packet_len)\n{\n\tint i;\n\n\t \n\tif (!IS_HDR_BYTE(mouse->buf[0])) {\n\t\tDBG(\"vsck: len=%d, 1st=0x%02x\\n\", packet_len, mouse->buf[0]);\n\t\treturn 1;\n\t}\n\n\t \n\tfor (i = 1; i < packet_len; i++) {\n\t\tif (IS_HDR_BYTE(mouse->buf[i])) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"Need to drop %d bytes of a broken packet.\\n\",\n\t\t\t\ti - 1);\n\t\t\tDBG(KERN_INFO \"check: len=%d, b[%d]=0x%02x\\n\",\n\t\t\t    packet_len, i, mouse->buf[i]);\n\t\t\treturn i - 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int vsxxxaa_smells_like_packet(struct vsxxxaa *mouse,\n\t\t\t\t\t     unsigned char type, size_t len)\n{\n\treturn mouse->count >= len && MATCH_PACKET_TYPE(mouse->buf[0], type);\n}\n\nstatic void vsxxxaa_handle_REL_packet(struct vsxxxaa *mouse)\n{\n\tstruct input_dev *dev = mouse->dev;\n\tunsigned char *buf = mouse->buf;\n\tint left, middle, right;\n\tint dx, dy;\n\n\t \n\n\t \n\tdx = buf[1] & 0x7f;\n\tdx *= ((buf[0] >> 4) & 0x01) ? 1 : -1;\n\n\t \n\tdy = buf[2] & 0x7f;\n\tdy *= ((buf[0] >> 3) & 0x01) ? -1 : 1;\n\n\t \n\tleft\t= buf[0] & 0x04;\n\tmiddle\t= buf[0] & 0x02;\n\tright\t= buf[0] & 0x01;\n\n\tvsxxxaa_drop_bytes(mouse, 3);\n\n\tDBG(KERN_INFO \"%s on %s: dx=%d, dy=%d, buttons=%s%s%s\\n\",\n\t    mouse->name, mouse->phys, dx, dy,\n\t    left ? \"L\" : \"l\", middle ? \"M\" : \"m\", right ? \"R\" : \"r\");\n\n\t \n\tinput_report_key(dev, BTN_LEFT, left);\n\tinput_report_key(dev, BTN_MIDDLE, middle);\n\tinput_report_key(dev, BTN_RIGHT, right);\n\tinput_report_key(dev, BTN_TOUCH, 0);\n\tinput_report_rel(dev, REL_X, dx);\n\tinput_report_rel(dev, REL_Y, dy);\n\tinput_sync(dev);\n}\n\nstatic void vsxxxaa_handle_ABS_packet(struct vsxxxaa *mouse)\n{\n\tstruct input_dev *dev = mouse->dev;\n\tunsigned char *buf = mouse->buf;\n\tint left, middle, right, touch;\n\tint x, y;\n\n\t \n\n\t \n\tx = ((buf[2] & 0x3f) << 6) | (buf[1] & 0x3f);\n\ty = ((buf[4] & 0x3f) << 6) | (buf[3] & 0x3f);\n\ty = 1023 - y;\n\n\t \n\tleft\t= buf[0] & 0x02;\n\tmiddle\t= buf[0] & 0x04;\n\tright\t= buf[0] & 0x08;\n\ttouch\t= buf[0] & 0x10;\n\n\tvsxxxaa_drop_bytes(mouse, 5);\n\n\tDBG(KERN_INFO \"%s on %s: x=%d, y=%d, buttons=%s%s%s%s\\n\",\n\t    mouse->name, mouse->phys, x, y,\n\t    left ? \"L\" : \"l\", middle ? \"M\" : \"m\",\n\t    right ? \"R\" : \"r\", touch ? \"T\" : \"t\");\n\n\t \n\tinput_report_key(dev, BTN_LEFT, left);\n\tinput_report_key(dev, BTN_MIDDLE, middle);\n\tinput_report_key(dev, BTN_RIGHT, right);\n\tinput_report_key(dev, BTN_TOUCH, touch);\n\tinput_report_abs(dev, ABS_X, x);\n\tinput_report_abs(dev, ABS_Y, y);\n\tinput_sync(dev);\n}\n\nstatic void vsxxxaa_handle_POR_packet(struct vsxxxaa *mouse)\n{\n\tstruct input_dev *dev = mouse->dev;\n\tunsigned char *buf = mouse->buf;\n\tint left, middle, right;\n\tunsigned char error;\n\n\t \n\n\tmouse->version = buf[0] & 0x0f;\n\tmouse->country = (buf[1] >> 4) & 0x07;\n\tmouse->type = buf[1] & 0x0f;\n\terror = buf[2] & 0x7f;\n\n\t \n\tleft\t= buf[0] & 0x04;\n\tmiddle\t= buf[0] & 0x02;\n\tright\t= buf[0] & 0x01;\n\n\tvsxxxaa_drop_bytes(mouse, 4);\n\tvsxxxaa_detection_done(mouse);\n\n\tif (error <= 0x1f) {\n\t\t \n\t\tinput_report_key(dev, BTN_LEFT, left);\n\t\tinput_report_key(dev, BTN_MIDDLE, middle);\n\t\tinput_report_key(dev, BTN_RIGHT, right);\n\t\tinput_report_key(dev, BTN_TOUCH, 0);\n\t\tinput_sync(dev);\n\n\t\tif (error != 0)\n\t\t\tprintk(KERN_INFO \"Your %s on %s reports error=0x%02x\\n\",\n\t\t\t\tmouse->name, mouse->phys, error);\n\n\t}\n\n\t \n\tprintk(KERN_NOTICE\n\t\t\"%s on %s: Forcing standard packet format, \"\n\t\t\"incremental streaming mode and 72 samples/sec\\n\",\n\t\tmouse->name, mouse->phys);\n\tserio_write(mouse->serio, 'S');\t \n\tmdelay(50);\n\tserio_write(mouse->serio, 'R');\t \n\tmdelay(50);\n\tserio_write(mouse->serio, 'L');\t \n}\n\nstatic void vsxxxaa_parse_buffer(struct vsxxxaa *mouse)\n{\n\tunsigned char *buf = mouse->buf;\n\tint stray_bytes;\n\n\t \n\tdo {\n\t\t \n\t\twhile (mouse->count > 0 && !IS_HDR_BYTE(buf[0])) {\n\t\t\tprintk(KERN_ERR \"%s on %s: Dropping a byte to regain \"\n\t\t\t\t\"sync with mouse data stream...\\n\",\n\t\t\t\tmouse->name, mouse->phys);\n\t\t\tvsxxxaa_drop_bytes(mouse, 1);\n\t\t}\n\n\t\t \n\n\t\tif (vsxxxaa_smells_like_packet(mouse, VSXXXAA_PACKET_REL, 3)) {\n\t\t\t \n\t\t\tstray_bytes = vsxxxaa_check_packet(mouse, 3);\n\t\t\tif (!stray_bytes)\n\t\t\t\tvsxxxaa_handle_REL_packet(mouse);\n\n\t\t} else if (vsxxxaa_smells_like_packet(mouse,\n\t\t\t\t\t\t      VSXXXAA_PACKET_ABS, 5)) {\n\t\t\t \n\t\t\tstray_bytes = vsxxxaa_check_packet(mouse, 5);\n\t\t\tif (!stray_bytes)\n\t\t\t\tvsxxxaa_handle_ABS_packet(mouse);\n\n\t\t} else if (vsxxxaa_smells_like_packet(mouse,\n\t\t\t\t\t\t      VSXXXAA_PACKET_POR, 4)) {\n\t\t\t \n\t\t\tstray_bytes = vsxxxaa_check_packet(mouse, 4);\n\t\t\tif (!stray_bytes)\n\t\t\t\tvsxxxaa_handle_POR_packet(mouse);\n\n\t\t} else {\n\t\t\tbreak;  \n\t\t}\n\n\t\tif (stray_bytes > 0) {\n\t\t\tprintk(KERN_ERR \"Dropping %d bytes now...\\n\",\n\t\t\t\tstray_bytes);\n\t\t\tvsxxxaa_drop_bytes(mouse, stray_bytes);\n\t\t}\n\n\t} while (1);\n}\n\nstatic irqreturn_t vsxxxaa_interrupt(struct serio *serio,\n\t\t\t\t     unsigned char data, unsigned int flags)\n{\n\tstruct vsxxxaa *mouse = serio_get_drvdata(serio);\n\n\tvsxxxaa_queue_byte(mouse, data);\n\tvsxxxaa_parse_buffer(mouse);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void vsxxxaa_disconnect(struct serio *serio)\n{\n\tstruct vsxxxaa *mouse = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(mouse->dev);\n\tkfree(mouse);\n}\n\nstatic int vsxxxaa_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct vsxxxaa *mouse;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\n\tmouse = kzalloc(sizeof(struct vsxxxaa), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!mouse || !input_dev)\n\t\tgoto fail1;\n\n\tmouse->dev = input_dev;\n\tmouse->serio = serio;\n\tstrlcat(mouse->name, \"DEC VSXXX-AA/-GA mouse or VSXXX-AB digitizer\",\n\t\t sizeof(mouse->name));\n\tsnprintf(mouse->phys, sizeof(mouse->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = mouse->name;\n\tinput_dev->phys = mouse->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->dev.parent = &serio->dev;\n\n\t__set_bit(EV_KEY, input_dev->evbit);\t\t \n\t__set_bit(EV_REL, input_dev->evbit);\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(BTN_LEFT, input_dev->keybit);\t\t \n\t__set_bit(BTN_MIDDLE, input_dev->keybit);\n\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\t \n\t__set_bit(REL_X, input_dev->relbit);\n\t__set_bit(REL_Y, input_dev->relbit);\n\tinput_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 1023, 0, 0);\n\n\tserio_set_drvdata(serio, mouse);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\t \n\tserio_write(serio, 'T');  \n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(mouse);\n\treturn err;\n}\n\nstatic struct serio_device_id vsxxaa_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_VSXXXAA,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, vsxxaa_serio_ids);\n\nstatic struct serio_driver vsxxxaa_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"vsxxxaa\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= vsxxaa_serio_ids,\n\t.connect\t= vsxxxaa_connect,\n\t.interrupt\t= vsxxxaa_interrupt,\n\t.disconnect\t= vsxxxaa_disconnect,\n};\n\nmodule_serio_driver(vsxxxaa_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}