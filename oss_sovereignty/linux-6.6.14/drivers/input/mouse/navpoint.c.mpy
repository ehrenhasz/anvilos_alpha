{
  "module_name": "navpoint.c",
  "hash_id": "395958f77b340be9d2c33d3746df21cb871aa289366ead0ac5f4d5280dd21ba0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/navpoint.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/input.h>\n#include <linux/input/navpoint.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/pxa2xx_ssp.h>\n#include <linux/slab.h>\n\n \n#define HEADER_LENGTH(byte)\t((byte) & 0x07)\n#define HEADER_CONTROL(byte)\t(((byte) >> 3) & 0x03)\n#define HEADER_ADDRESS(byte)\t((byte) >> 5)\n\nstruct navpoint {\n\tstruct ssp_device\t*ssp;\n\tstruct input_dev\t*input;\n\tstruct device\t\t*dev;\n\tint\t\t\tgpio;\n\tint\t\t\tindex;\n\tu8\t\t\tdata[1 + HEADER_LENGTH(0xff)];\n};\n\n \nstatic const u32 sscr0 = 0\n\t| SSCR0_TUM\t\t \n\t| SSCR0_RIM\t\t \n\t| SSCR0_SSE\t\t \n\t| SSCR0_Motorola\t \n\t| SSCR0_DataSize(16)\t \n\t;\nstatic const u32 sscr1 = 0\n\t| SSCR1_SCFR\t\t \n\t| SSCR1_SCLKDIR\t\t \n\t| SSCR1_SFRMDIR\t\t \n\t| SSCR1_RWOT\t\t \n\t| SSCR1_RxTresh(1)\t \n\t| SSCR1_SPH\t\t \n\t| SSCR1_RIE\t\t \n\t;\nstatic const u32 sssr = 0\n\t| SSSR_BCE\t\t \n\t| SSSR_TUR\t\t \n\t| SSSR_EOC\t\t \n\t| SSSR_TINT\t\t \n\t| SSSR_PINT\t\t \n\t| SSSR_ROR\t\t \n\t;\n\n \n#define NAVPOINT_X_MIN\t\t1278\n#define NAVPOINT_X_MAX\t\t5340\n#define NAVPOINT_Y_MIN\t\t1572\n#define NAVPOINT_Y_MAX\t\t4396\n#define NAVPOINT_PRESSURE_MIN\t0\n#define NAVPOINT_PRESSURE_MAX\t255\n\nstatic void navpoint_packet(struct navpoint *navpoint)\n{\n\tint finger;\n\tint gesture;\n\tint x, y, z;\n\n\tswitch (navpoint->data[0]) {\n\tcase 0xff:\t \n\tcase 0x00:\t \n\t\tbreak;\n\n\tcase 0x0e:\t \n\t\tfinger = (navpoint->data[1] & 0x01);\n\t\tgesture = (navpoint->data[1] & 0x02);\n\t\tx = ((navpoint->data[2] & 0x1f) << 8) | navpoint->data[3];\n\t\ty = ((navpoint->data[4] & 0x1f) << 8) | navpoint->data[5];\n\t\tz = navpoint->data[6];\n\t\tinput_report_key(navpoint->input, BTN_TOUCH, finger);\n\t\tinput_report_abs(navpoint->input, ABS_X, x);\n\t\tinput_report_abs(navpoint->input, ABS_Y, y);\n\t\tinput_report_abs(navpoint->input, ABS_PRESSURE, z);\n\t\tinput_report_key(navpoint->input, BTN_TOOL_FINGER, finger);\n\t\tinput_report_key(navpoint->input, BTN_LEFT, gesture);\n\t\tinput_sync(navpoint->input);\n\t\tbreak;\n\n\tcase 0x19:\t \n\t\tif ((navpoint->data[1] & 0xf0) == 0x10)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdev_warn(navpoint->dev,\n\t\t\t \"spurious packet: data=0x%02x,0x%02x,...\\n\",\n\t\t\t navpoint->data[0], navpoint->data[1]);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t navpoint_irq(int irq, void *dev_id)\n{\n\tstruct navpoint *navpoint = dev_id;\n\tstruct ssp_device *ssp = navpoint->ssp;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 status;\n\n\tstatus = pxa_ssp_read_reg(ssp, SSSR);\n\tif (status & sssr) {\n\t\tdev_warn(navpoint->dev,\n\t\t\t \"unexpected interrupt: status=0x%08x\\n\", status);\n\t\tpxa_ssp_write_reg(ssp, SSSR, (status & sssr));\n\t\tret = IRQ_HANDLED;\n\t}\n\n\twhile (status & SSSR_RNE) {\n\t\tu32 data;\n\n\t\tdata = pxa_ssp_read_reg(ssp, SSDR);\n\t\tnavpoint->data[navpoint->index + 0] = (data >> 8);\n\t\tnavpoint->data[navpoint->index + 1] = data;\n\t\tnavpoint->index += 2;\n\t\tif (HEADER_LENGTH(navpoint->data[0]) < navpoint->index) {\n\t\t\tnavpoint_packet(navpoint);\n\t\t\tnavpoint->index = 0;\n\t\t}\n\t\tstatus = pxa_ssp_read_reg(ssp, SSSR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic void navpoint_up(struct navpoint *navpoint)\n{\n\tstruct ssp_device *ssp = navpoint->ssp;\n\tint timeout;\n\n\tclk_prepare_enable(ssp->clk);\n\n\tpxa_ssp_write_reg(ssp, SSCR1, sscr1);\n\tpxa_ssp_write_reg(ssp, SSSR, sssr);\n\tpxa_ssp_write_reg(ssp, SSTO, 0);\n\tpxa_ssp_write_reg(ssp, SSCR0, sscr0);\t \n\n\t \n\tfor (timeout = 100; timeout != 0; --timeout) {\n\t\tif (!(pxa_ssp_read_reg(ssp, SSSR) & SSSR_CSS))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (timeout == 0)\n\t\tdev_err(navpoint->dev,\n\t\t\t\"timeout waiting for SSSR[CSS] to clear\\n\");\n\n\tif (gpio_is_valid(navpoint->gpio))\n\t\tgpio_set_value(navpoint->gpio, 1);\n}\n\nstatic void navpoint_down(struct navpoint *navpoint)\n{\n\tstruct ssp_device *ssp = navpoint->ssp;\n\n\tif (gpio_is_valid(navpoint->gpio))\n\t\tgpio_set_value(navpoint->gpio, 0);\n\n\tpxa_ssp_write_reg(ssp, SSCR0, 0);\n\n\tclk_disable_unprepare(ssp->clk);\n}\n\nstatic int navpoint_open(struct input_dev *input)\n{\n\tstruct navpoint *navpoint = input_get_drvdata(input);\n\n\tnavpoint_up(navpoint);\n\n\treturn 0;\n}\n\nstatic void navpoint_close(struct input_dev *input)\n{\n\tstruct navpoint *navpoint = input_get_drvdata(input);\n\n\tnavpoint_down(navpoint);\n}\n\nstatic int navpoint_probe(struct platform_device *pdev)\n{\n\tconst struct navpoint_platform_data *pdata =\n\t\t\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct ssp_device *ssp;\n\tstruct input_dev *input;\n\tstruct navpoint *navpoint;\n\tint error;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (gpio_is_valid(pdata->gpio)) {\n\t\terror = gpio_request_one(pdata->gpio, GPIOF_OUT_INIT_LOW,\n\t\t\t\t\t \"SYNAPTICS_ON\");\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tssp = pxa_ssp_request(pdata->port, pdev->name);\n\tif (!ssp) {\n\t\terror = -ENODEV;\n\t\tgoto err_free_gpio;\n\t}\n\n\t \n\tif (pxa_ssp_read_reg(ssp, SSCR0) & SSCR0_SSE) {\n\t\tpxa_ssp_write_reg(ssp, SSCR0, 0);\n\t\tdev_warn(&pdev->dev, \"ssp%d already enabled\\n\", pdata->port);\n\t}\n\n\tnavpoint = kzalloc(sizeof(*navpoint), GFP_KERNEL);\n\tinput = input_allocate_device();\n\tif (!navpoint || !input) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tnavpoint->ssp = ssp;\n\tnavpoint->input = input;\n\tnavpoint->dev = &pdev->dev;\n\tnavpoint->gpio = pdata->gpio;\n\n\tinput->name = pdev->name;\n\tinput->dev.parent = &pdev->dev;\n\n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(EV_ABS, input->evbit);\n\t__set_bit(BTN_LEFT, input->keybit);\n\t__set_bit(BTN_TOUCH, input->keybit);\n\t__set_bit(BTN_TOOL_FINGER, input->keybit);\n\n\tinput_set_abs_params(input, ABS_X,\n\t\t\t     NAVPOINT_X_MIN, NAVPOINT_X_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_Y,\n\t\t\t     NAVPOINT_Y_MIN, NAVPOINT_Y_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE,\n\t\t\t     NAVPOINT_PRESSURE_MIN, NAVPOINT_PRESSURE_MAX,\n\t\t\t     0, 0);\n\n\tinput->open = navpoint_open;\n\tinput->close = navpoint_close;\n\n\tinput_set_drvdata(input, navpoint);\n\n\terror = request_irq(ssp->irq, navpoint_irq, 0, pdev->name, navpoint);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\terror = input_register_device(input);\n\tif (error)\n\t\tgoto err_free_irq;\n\n\tplatform_set_drvdata(pdev, navpoint);\n\tdev_dbg(&pdev->dev, \"ssp%d, irq %d\\n\", pdata->port, ssp->irq);\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(ssp->irq, navpoint);\nerr_free_mem:\n\tinput_free_device(input);\n\tkfree(navpoint);\n\tpxa_ssp_free(ssp);\nerr_free_gpio:\n\tif (gpio_is_valid(pdata->gpio))\n\t\tgpio_free(pdata->gpio);\n\n\treturn error;\n}\n\nstatic int navpoint_remove(struct platform_device *pdev)\n{\n\tconst struct navpoint_platform_data *pdata =\n\t\t\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct navpoint *navpoint = platform_get_drvdata(pdev);\n\tstruct ssp_device *ssp = navpoint->ssp;\n\n\tfree_irq(ssp->irq, navpoint);\n\n\tinput_unregister_device(navpoint->input);\n\tkfree(navpoint);\n\n\tpxa_ssp_free(ssp);\n\n\tif (gpio_is_valid(pdata->gpio))\n\t\tgpio_free(pdata->gpio);\n\n\treturn 0;\n}\n\nstatic int navpoint_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct navpoint *navpoint = platform_get_drvdata(pdev);\n\tstruct input_dev *input = navpoint->input;\n\n\tmutex_lock(&input->mutex);\n\tif (input_device_enabled(input))\n\t\tnavpoint_down(navpoint);\n\tmutex_unlock(&input->mutex);\n\n\treturn 0;\n}\n\nstatic int navpoint_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct navpoint *navpoint = platform_get_drvdata(pdev);\n\tstruct input_dev *input = navpoint->input;\n\n\tmutex_lock(&input->mutex);\n\tif (input_device_enabled(input))\n\t\tnavpoint_up(navpoint);\n\tmutex_unlock(&input->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(navpoint_pm_ops,\n\t\t\t\tnavpoint_suspend, navpoint_resume);\n\nstatic struct platform_driver navpoint_driver = {\n\t.probe\t\t= navpoint_probe,\n\t.remove\t\t= navpoint_remove,\n\t.driver = {\n\t\t.name\t= \"navpoint\",\n\t\t.pm\t= pm_sleep_ptr(&navpoint_pm_ops),\n\t},\n};\n\nmodule_platform_driver(navpoint_driver);\n\nMODULE_AUTHOR(\"Paul Parsons <lost.distance@yahoo.com>\");\nMODULE_DESCRIPTION(\"Synaptics NavPoint (PXA27x SSP/SPI) driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:navpoint\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}