{
  "module_name": "cypress_ps2.c",
  "hash_id": "b4cc1fcbe72592e28c841e6335a24a94926bb1818477afbbe6defb1575ed2b05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/cypress_ps2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n\n#include \"cypress_ps2.h\"\n\n#undef CYTP_DEBUG_VERBOSE   \n\nstatic void cypress_set_packet_size(struct psmouse *psmouse, unsigned int n)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\tcytp->pkt_size = n;\n}\n\nstatic const unsigned char cytp_rate[] = {10, 20, 40, 60, 100, 200};\nstatic const unsigned char cytp_resolution[] = {0x00, 0x01, 0x02, 0x03};\n\nstatic int cypress_ps2_sendbyte(struct psmouse *psmouse, int value)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\tif (ps2_sendbyte(ps2dev, value & 0xff, CYTP_CMD_TIMEOUT) < 0) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t\t\"sending command 0x%02x failed, resp 0x%02x\\n\",\n\t\t\t\tvalue & 0xff, ps2dev->nak);\n\t\tif (ps2dev->nak == CYTP_PS2_RETRY)\n\t\t\treturn CYTP_PS2_RETRY;\n\t\telse\n\t\t\treturn CYTP_PS2_ERROR;\n\t}\n\n#ifdef CYTP_DEBUG_VERBOSE\n\tpsmouse_dbg(psmouse, \"sending command 0x%02x succeeded, resp 0xfa\\n\",\n\t\t\tvalue & 0xff);\n#endif\n\n\treturn 0;\n}\n\nstatic int cypress_ps2_ext_cmd(struct psmouse *psmouse, unsigned short cmd,\n\t\t\t       unsigned char data)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint tries = CYTP_PS2_CMD_TRIES;\n\tint rc;\n\n\tps2_begin_command(ps2dev);\n\n\tdo {\n\t\t \n\t\trc = cypress_ps2_sendbyte(psmouse, cmd & 0xff);\n\t\tif (rc == CYTP_PS2_RETRY) {\n\t\t\trc = cypress_ps2_sendbyte(psmouse, 0x00);\n\t\t\tif (rc == CYTP_PS2_RETRY)\n\t\t\t\trc = cypress_ps2_sendbyte(psmouse, 0x0a);\n\t\t}\n\t\tif (rc == CYTP_PS2_ERROR)\n\t\t\tcontinue;\n\n\t\trc = cypress_ps2_sendbyte(psmouse, data);\n\t\tif (rc == CYTP_PS2_RETRY)\n\t\t\trc = cypress_ps2_sendbyte(psmouse, data);\n\t\tif (rc == CYTP_PS2_ERROR)\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t} while (--tries > 0);\n\n\tps2_end_command(ps2dev);\n\n\treturn rc;\n}\n\nstatic int cypress_ps2_read_cmd_status(struct psmouse *psmouse,\n\t\t\t\t       unsigned char cmd,\n\t\t\t\t       unsigned char *param)\n{\n\tint rc;\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tenum psmouse_state old_state;\n\tint pktsize;\n\n\tps2_begin_command(ps2dev);\n\n\told_state = psmouse->state;\n\tpsmouse->state = PSMOUSE_CMD_MODE;\n\tpsmouse->pktcnt = 0;\n\n\tpktsize = (cmd == CYTP_CMD_READ_TP_METRICS) ? 8 : 3;\n\tmemset(param, 0, pktsize);\n\n\trc = cypress_ps2_sendbyte(psmouse, 0xe9);\n\tif (rc < 0)\n\t\tgoto out;\n\n\twait_event_timeout(ps2dev->wait,\n\t\t\t(psmouse->pktcnt >= pktsize),\n\t\t\tmsecs_to_jiffies(CYTP_CMD_TIMEOUT));\n\n\tmemcpy(param, psmouse->packet, pktsize);\n\n\tpsmouse_dbg(psmouse, \"Command 0x%02x response data (0x): %*ph\\n\",\n\t\t\tcmd, pktsize, param);\n\nout:\n\tpsmouse->state = old_state;\n\tpsmouse->pktcnt = 0;\n\n\tps2_end_command(ps2dev);\n\n\treturn rc;\n}\n\nstatic bool cypress_verify_cmd_state(struct psmouse *psmouse,\n\t\t\t\t     unsigned char cmd, unsigned char *param)\n{\n\tbool rate_match = false;\n\tbool resolution_match = false;\n\tint i;\n\n\t \n\tif (cmd == CYTP_CMD_READ_CYPRESS_ID ||\n\t    cmd == CYTP_CMD_STANDARD_MODE ||\n\t    cmd == CYTP_CMD_READ_TP_METRICS)\n\t\treturn true;\n\n\tif ((~param[0] & DFLT_RESP_BITS_VALID) == DFLT_RESP_BITS_VALID &&\n\t    (param[0] & DFLT_RESP_BIT_MODE) == DFLT_RESP_STREAM_MODE) {\n\t\tfor (i = 0; i < sizeof(cytp_resolution); i++)\n\t\t\tif (cytp_resolution[i] == param[1])\n\t\t\t\tresolution_match = true;\n\n\t\tfor (i = 0; i < sizeof(cytp_rate); i++)\n\t\t\tif (cytp_rate[i] == param[2])\n\t\t\t\trate_match = true;\n\n\t\tif (resolution_match && rate_match)\n\t\t\treturn true;\n\t}\n\n\tpsmouse_dbg(psmouse, \"verify cmd state failed.\\n\");\n\treturn false;\n}\n\nstatic int cypress_send_ext_cmd(struct psmouse *psmouse, unsigned char cmd,\n\t\t\t\tunsigned char *param)\n{\n\tint tries = CYTP_PS2_CMD_TRIES;\n\tint rc;\n\n\tpsmouse_dbg(psmouse, \"send extension cmd 0x%02x, [%d %d %d %d]\\n\",\n\t\t cmd, DECODE_CMD_AA(cmd), DECODE_CMD_BB(cmd),\n\t\t DECODE_CMD_CC(cmd), DECODE_CMD_DD(cmd));\n\n\tdo {\n\t\tcypress_ps2_ext_cmd(psmouse,\n\t\t\t\t    PSMOUSE_CMD_SETRES, DECODE_CMD_DD(cmd));\n\t\tcypress_ps2_ext_cmd(psmouse,\n\t\t\t\t    PSMOUSE_CMD_SETRES, DECODE_CMD_CC(cmd));\n\t\tcypress_ps2_ext_cmd(psmouse,\n\t\t\t\t    PSMOUSE_CMD_SETRES, DECODE_CMD_BB(cmd));\n\t\tcypress_ps2_ext_cmd(psmouse,\n\t\t\t\t    PSMOUSE_CMD_SETRES, DECODE_CMD_AA(cmd));\n\n\t\trc = cypress_ps2_read_cmd_status(psmouse, cmd, param);\n\t\tif (rc)\n\t\t\tcontinue;\n\n\t\tif (cypress_verify_cmd_state(psmouse, cmd, param))\n\t\t\treturn 0;\n\n\t} while (--tries > 0);\n\n\treturn -EIO;\n}\n\nint cypress_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tunsigned char param[3];\n\n\tif (cypress_send_ext_cmd(psmouse, CYTP_CMD_READ_CYPRESS_ID, param))\n\t\treturn -ENODEV;\n\n\t \n\tif (param[0] != 0x33 || param[1] != 0xCC)\n\t\treturn -ENODEV;\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"Cypress\";\n\t\tpsmouse->name = \"Trackpad\";\n\t}\n\n\treturn 0;\n}\n\nstatic int cypress_read_fw_version(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\tunsigned char param[3];\n\n\tif (cypress_send_ext_cmd(psmouse, CYTP_CMD_READ_CYPRESS_ID, param))\n\t\treturn -ENODEV;\n\n\t \n\tif (param[0] != 0x33 || param[1] != 0xCC)\n\t\treturn -ENODEV;\n\n\tcytp->fw_version = param[2] & FW_VERSION_MASX;\n\tcytp->tp_metrics_supported = (param[2] & TP_METRICS_MASK) ? 1 : 0;\n\n\t \n\tif (cytp->fw_version >= 11)\n\t\tcytp->tp_metrics_supported = 0;\n\n\tpsmouse_dbg(psmouse, \"cytp->fw_version = %d\\n\", cytp->fw_version);\n\tpsmouse_dbg(psmouse, \"cytp->tp_metrics_supported = %d\\n\",\n\t\t cytp->tp_metrics_supported);\n\n\treturn 0;\n}\n\nstatic int cypress_read_tp_metrics(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\tunsigned char param[8];\n\n\t \n\tcytp->tp_width = CYTP_DEFAULT_WIDTH;\n\tcytp->tp_high = CYTP_DEFAULT_HIGH;\n\tcytp->tp_max_abs_x = CYTP_ABS_MAX_X;\n\tcytp->tp_max_abs_y = CYTP_ABS_MAX_Y;\n\tcytp->tp_min_pressure = CYTP_MIN_PRESSURE;\n\tcytp->tp_max_pressure = CYTP_MAX_PRESSURE;\n\tcytp->tp_res_x = cytp->tp_max_abs_x / cytp->tp_width;\n\tcytp->tp_res_y = cytp->tp_max_abs_y / cytp->tp_high;\n\n\tif (!cytp->tp_metrics_supported)\n\t\treturn 0;\n\n\tmemset(param, 0, sizeof(param));\n\tif (cypress_send_ext_cmd(psmouse, CYTP_CMD_READ_TP_METRICS, param) == 0) {\n\t\t \n\t\tcytp->tp_max_abs_x = (param[1] << 8) | param[0];\n\t\tcytp->tp_max_abs_y = (param[3] << 8) | param[2];\n\t\tcytp->tp_min_pressure = param[4];\n\t\tcytp->tp_max_pressure = param[5];\n\t}\n\n\tif (!cytp->tp_max_pressure ||\n\t    cytp->tp_max_pressure < cytp->tp_min_pressure ||\n\t    !cytp->tp_width || !cytp->tp_high ||\n\t    !cytp->tp_max_abs_x ||\n\t    cytp->tp_max_abs_x < cytp->tp_width ||\n\t    !cytp->tp_max_abs_y ||\n\t    cytp->tp_max_abs_y < cytp->tp_high)\n\t\treturn -EINVAL;\n\n\tcytp->tp_res_x = cytp->tp_max_abs_x / cytp->tp_width;\n\tcytp->tp_res_y = cytp->tp_max_abs_y / cytp->tp_high;\n\n#ifdef CYTP_DEBUG_VERBOSE\n\tpsmouse_dbg(psmouse, \"Dump trackpad hardware configuration as below:\\n\");\n\tpsmouse_dbg(psmouse, \"cytp->tp_width = %d\\n\", cytp->tp_width);\n\tpsmouse_dbg(psmouse, \"cytp->tp_high = %d\\n\", cytp->tp_high);\n\tpsmouse_dbg(psmouse, \"cytp->tp_max_abs_x = %d\\n\", cytp->tp_max_abs_x);\n\tpsmouse_dbg(psmouse, \"cytp->tp_max_abs_y = %d\\n\", cytp->tp_max_abs_y);\n\tpsmouse_dbg(psmouse, \"cytp->tp_min_pressure = %d\\n\", cytp->tp_min_pressure);\n\tpsmouse_dbg(psmouse, \"cytp->tp_max_pressure = %d\\n\", cytp->tp_max_pressure);\n\tpsmouse_dbg(psmouse, \"cytp->tp_res_x = %d\\n\", cytp->tp_res_x);\n\tpsmouse_dbg(psmouse, \"cytp->tp_res_y = %d\\n\", cytp->tp_res_y);\n\n\tpsmouse_dbg(psmouse, \"tp_type_APA = %d\\n\",\n\t\t\t(param[6] & TP_METRICS_BIT_APA) ? 1 : 0);\n\tpsmouse_dbg(psmouse, \"tp_type_MTG = %d\\n\",\n\t\t\t(param[6] & TP_METRICS_BIT_MTG) ? 1 : 0);\n\tpsmouse_dbg(psmouse, \"tp_palm = %d\\n\",\n\t\t\t(param[6] & TP_METRICS_BIT_PALM) ? 1 : 0);\n\tpsmouse_dbg(psmouse, \"tp_stubborn = %d\\n\",\n\t\t\t(param[6] & TP_METRICS_BIT_STUBBORN) ? 1 : 0);\n\tpsmouse_dbg(psmouse, \"tp_1f_jitter = %d\\n\",\n\t\t\t(param[6] & TP_METRICS_BIT_1F_JITTER) >> 2);\n\tpsmouse_dbg(psmouse, \"tp_2f_jitter = %d\\n\",\n\t\t\t(param[6] & TP_METRICS_BIT_2F_JITTER) >> 4);\n\tpsmouse_dbg(psmouse, \"tp_1f_spike = %d\\n\",\n\t\t\tparam[7] & TP_METRICS_BIT_1F_SPIKE);\n\tpsmouse_dbg(psmouse, \"tp_2f_spike = %d\\n\",\n\t\t\t(param[7] & TP_METRICS_BIT_2F_SPIKE) >> 2);\n\tpsmouse_dbg(psmouse, \"tp_abs_packet_format_set = %d\\n\",\n\t\t\t(param[7] & TP_METRICS_BIT_ABS_PKT_FORMAT_SET) >> 4);\n#endif\n\n\treturn 0;\n}\n\nstatic int cypress_query_hardware(struct psmouse *psmouse)\n{\n\tint ret;\n\n\tret = cypress_read_fw_version(psmouse);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cypress_read_tp_metrics(psmouse);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cypress_set_absolute_mode(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\tunsigned char param[3];\n\n\tif (cypress_send_ext_cmd(psmouse, CYTP_CMD_ABS_WITH_PRESSURE_MODE, param) < 0)\n\t\treturn -1;\n\n\tcytp->mode = (cytp->mode & ~CYTP_BIT_ABS_REL_MASK)\n\t\t\t| CYTP_BIT_ABS_PRESSURE;\n\tcypress_set_packet_size(psmouse, 5);\n\n\treturn 0;\n}\n\n \nstatic void cypress_reset(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tcytp->mode = 0;\n\n\tpsmouse_reset(psmouse);\n}\n\nstatic int cypress_set_input_params(struct input_dev *input,\n\t\t\t\t    struct cytp_data *cytp)\n{\n\tint ret;\n\n\tif (!cytp->tp_res_x || !cytp->tp_res_y)\n\t\treturn -EINVAL;\n\n\t__set_bit(EV_ABS, input->evbit);\n\tinput_set_abs_params(input, ABS_X, 0, cytp->tp_max_abs_x, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, cytp->tp_max_abs_y, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE,\n\t\t\t     cytp->tp_min_pressure, cytp->tp_max_pressure, 0, 0);\n\tinput_set_abs_params(input, ABS_TOOL_WIDTH, 0, 255, 0, 0);\n\n\t \n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, cytp->tp_max_abs_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, cytp->tp_max_abs_y, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\n\tret = input_mt_init_slots(input, CYTP_MAX_MT_SLOTS,\n\t\t\tINPUT_MT_DROP_UNUSED|INPUT_MT_TRACK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t__set_bit(INPUT_PROP_SEMI_MT, input->propbit);\n\n\tinput_abs_set_res(input, ABS_X, cytp->tp_res_x);\n\tinput_abs_set_res(input, ABS_Y, cytp->tp_res_y);\n\n\tinput_abs_set_res(input, ABS_MT_POSITION_X, cytp->tp_res_x);\n\tinput_abs_set_res(input, ABS_MT_POSITION_Y, cytp->tp_res_y);\n\n\t__set_bit(BTN_TOUCH, input->keybit);\n\t__set_bit(BTN_TOOL_FINGER, input->keybit);\n\t__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);\n\t__set_bit(BTN_TOOL_TRIPLETAP, input->keybit);\n\t__set_bit(BTN_TOOL_QUADTAP, input->keybit);\n\t__set_bit(BTN_TOOL_QUINTTAP, input->keybit);\n\n\t__clear_bit(EV_REL, input->evbit);\n\t__clear_bit(REL_X, input->relbit);\n\t__clear_bit(REL_Y, input->relbit);\n\n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(BTN_LEFT, input->keybit);\n\t__set_bit(BTN_RIGHT, input->keybit);\n\t__set_bit(BTN_MIDDLE, input->keybit);\n\n\treturn 0;\n}\n\nstatic int cypress_get_finger_count(unsigned char header_byte)\n{\n\tunsigned char bits6_7;\n\tint finger_count;\n\n\tbits6_7 = header_byte >> 6;\n\tfinger_count = bits6_7 & 0x03;\n\n\tif (finger_count == 1)\n\t\treturn 1;\n\n\tif (header_byte & ABS_HSCROLL_BIT) {\n\t\t \n\t\tswitch (finger_count) {\n\t\t\tcase 0:\treturn 4;\n\t\t\tcase 2: return 5;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn finger_count;\n}\n\n\nstatic int cypress_parse_packet(struct psmouse *psmouse,\n\t\t\t\tstruct cytp_data *cytp, struct cytp_report_data *report_data)\n{\n\tunsigned char *packet = psmouse->packet;\n\tunsigned char header_byte = packet[0];\n\n\tmemset(report_data, 0, sizeof(struct cytp_report_data));\n\n\treport_data->contact_cnt = cypress_get_finger_count(header_byte);\n\treport_data->tap = (header_byte & ABS_MULTIFINGER_TAP) ? 1 : 0;\n\n\tif (report_data->contact_cnt == 1) {\n\t\treport_data->contacts[0].x =\n\t\t\t((packet[1] & 0x70) << 4) | packet[2];\n\t\treport_data->contacts[0].y =\n\t\t\t((packet[1] & 0x07) << 8) | packet[3];\n\t\tif (cytp->mode & CYTP_BIT_ABS_PRESSURE)\n\t\t\treport_data->contacts[0].z = packet[4];\n\n\t} else if (report_data->contact_cnt >= 2) {\n\t\treport_data->contacts[0].x =\n\t\t\t((packet[1] & 0x70) << 4) | packet[2];\n\t\treport_data->contacts[0].y =\n\t\t\t((packet[1] & 0x07) << 8) | packet[3];\n\t\tif (cytp->mode & CYTP_BIT_ABS_PRESSURE)\n\t\t\treport_data->contacts[0].z = packet[4];\n\n\t\treport_data->contacts[1].x =\n\t\t\t((packet[5] & 0xf0) << 4) | packet[6];\n\t\treport_data->contacts[1].y =\n\t\t\t((packet[5] & 0x0f) << 8) | packet[7];\n\t\tif (cytp->mode & CYTP_BIT_ABS_PRESSURE)\n\t\t\treport_data->contacts[1].z = report_data->contacts[0].z;\n\t}\n\n\treport_data->left = (header_byte & BTN_LEFT_BIT) ? 1 : 0;\n\treport_data->right = (header_byte & BTN_RIGHT_BIT) ? 1 : 0;\n\n\t \n\tif (report_data->tap)\n\t\treport_data->left = 0;\n\n#ifdef CYTP_DEBUG_VERBOSE\n\t{\n\t\tint i;\n\t\tint n = report_data->contact_cnt;\n\t\tpsmouse_dbg(psmouse, \"Dump parsed report data as below:\\n\");\n\t\tpsmouse_dbg(psmouse, \"contact_cnt = %d\\n\",\n\t\t\treport_data->contact_cnt);\n\t\tif (n > CYTP_MAX_MT_SLOTS)\n\t\t    n = CYTP_MAX_MT_SLOTS;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tpsmouse_dbg(psmouse, \"contacts[%d] = {%d, %d, %d}\\n\", i,\n\t\t\t\t\treport_data->contacts[i].x,\n\t\t\t\t\treport_data->contacts[i].y,\n\t\t\t\t\treport_data->contacts[i].z);\n\t\tpsmouse_dbg(psmouse, \"left = %d\\n\", report_data->left);\n\t\tpsmouse_dbg(psmouse, \"right = %d\\n\", report_data->right);\n\t\tpsmouse_dbg(psmouse, \"middle = %d\\n\", report_data->middle);\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void cypress_process_packet(struct psmouse *psmouse, bool zero_pkt)\n{\n\tint i;\n\tstruct input_dev *input = psmouse->dev;\n\tstruct cytp_data *cytp = psmouse->private;\n\tstruct cytp_report_data report_data;\n\tstruct cytp_contact *contact;\n\tstruct input_mt_pos pos[CYTP_MAX_MT_SLOTS];\n\tint slots[CYTP_MAX_MT_SLOTS];\n\tint n;\n\n\tcypress_parse_packet(psmouse, cytp, &report_data);\n\n\tn = report_data.contact_cnt;\n\tif (n > CYTP_MAX_MT_SLOTS)\n\t\tn = CYTP_MAX_MT_SLOTS;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcontact = &report_data.contacts[i];\n\t\tpos[i].x = contact->x;\n\t\tpos[i].y = contact->y;\n\t}\n\n\tinput_mt_assign_slots(input, slots, pos, n, 0);\n\n\tfor (i = 0; i < n; i++) {\n\t\tcontact = &report_data.contacts[i];\n\t\tinput_mt_slot(input, slots[i]);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, contact->x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, contact->y);\n\t\tinput_report_abs(input, ABS_MT_PRESSURE, contact->z);\n\t}\n\n\tinput_mt_sync_frame(input);\n\n\tinput_mt_report_finger_count(input, report_data.contact_cnt);\n\n\tinput_report_key(input, BTN_LEFT, report_data.left);\n\tinput_report_key(input, BTN_RIGHT, report_data.right);\n\tinput_report_key(input, BTN_MIDDLE, report_data.middle);\n\n\tinput_sync(input);\n}\n\nstatic psmouse_ret_t cypress_validate_byte(struct psmouse *psmouse)\n{\n\tint contact_cnt;\n\tint index = psmouse->pktcnt - 1;\n\tunsigned char *packet = psmouse->packet;\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tif (index < 0 || index > cytp->pkt_size)\n\t\treturn PSMOUSE_BAD_DATA;\n\n\tif (index == 0 && (packet[0] & 0xfc) == 0) {\n\t\t \n\t\tcypress_process_packet(psmouse, 1);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\t \n\tif (index != 0)\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\t \n\tif ((cytp->mode & CYTP_BIT_ABS_REL_MASK) == 0)\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\tif ((packet[0] & 0x08) == 0x08)\n\t\treturn PSMOUSE_BAD_DATA;\n\n\tcontact_cnt = cypress_get_finger_count(packet[0]);\n\tif (cytp->mode & CYTP_BIT_ABS_NO_PRESSURE)\n\t\tcypress_set_packet_size(psmouse, contact_cnt == 2 ? 7 : 4);\n\telse\n\t\tcypress_set_packet_size(psmouse, contact_cnt == 2 ? 8 : 5);\n\n\treturn PSMOUSE_GOOD_DATA;\n}\n\nstatic psmouse_ret_t cypress_protocol_handler(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tif (psmouse->pktcnt >= cytp->pkt_size) {\n\t\tcypress_process_packet(psmouse, 0);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\treturn cypress_validate_byte(psmouse);\n}\n\nstatic void cypress_set_rate(struct psmouse *psmouse, unsigned int rate)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tif (rate >= 80) {\n\t\tpsmouse->rate = 80;\n\t\tcytp->mode |= CYTP_BIT_HIGH_RATE;\n\t} else {\n\t\tpsmouse->rate = 40;\n\t\tcytp->mode &= ~CYTP_BIT_HIGH_RATE;\n\t}\n\n\tps2_command(&psmouse->ps2dev, (unsigned char *)&psmouse->rate,\n\t\t    PSMOUSE_CMD_SETRATE);\n}\n\nstatic void cypress_disconnect(struct psmouse *psmouse)\n{\n\tcypress_reset(psmouse);\n\tkfree(psmouse->private);\n\tpsmouse->private = NULL;\n}\n\nstatic int cypress_reconnect(struct psmouse *psmouse)\n{\n\tint tries = CYTP_PS2_CMD_TRIES;\n\tint rc;\n\n\tdo {\n\t\tcypress_reset(psmouse);\n\t\trc = cypress_detect(psmouse, false);\n\t} while (rc && (--tries > 0));\n\n\tif (rc) {\n\t\tpsmouse_err(psmouse, \"Reconnect: unable to detect trackpad.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (cypress_set_absolute_mode(psmouse)) {\n\t\tpsmouse_err(psmouse, \"Reconnect: Unable to initialize Cypress absolute mode.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint cypress_init(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp;\n\n\tcytp = kzalloc(sizeof(struct cytp_data), GFP_KERNEL);\n\tif (!cytp)\n\t\treturn -ENOMEM;\n\n\tpsmouse->private = cytp;\n\tpsmouse->pktsize = 8;\n\n\tcypress_reset(psmouse);\n\n\tif (cypress_query_hardware(psmouse)) {\n\t\tpsmouse_err(psmouse, \"Unable to query Trackpad hardware.\\n\");\n\t\tgoto err_exit;\n\t}\n\n\tif (cypress_set_absolute_mode(psmouse)) {\n\t\tpsmouse_err(psmouse, \"init: Unable to initialize Cypress absolute mode.\\n\");\n\t\tgoto err_exit;\n\t}\n\n\tif (cypress_set_input_params(psmouse->dev, cytp) < 0) {\n\t\tpsmouse_err(psmouse, \"init: Unable to set input params.\\n\");\n\t\tgoto err_exit;\n\t}\n\n\tpsmouse->model = 1;\n\tpsmouse->protocol_handler = cypress_protocol_handler;\n\tpsmouse->set_rate = cypress_set_rate;\n\tpsmouse->disconnect = cypress_disconnect;\n\tpsmouse->reconnect = cypress_reconnect;\n\tpsmouse->cleanup = cypress_reset;\n\tpsmouse->resync_time = 0;\n\n\treturn 0;\n\nerr_exit:\n\t \n\tcypress_reset(psmouse);\n\n\tpsmouse->private = NULL;\n\tkfree(cytp);\n\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}