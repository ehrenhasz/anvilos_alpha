{
  "module_name": "cyapa_gen3.c",
  "hash_id": "11a463c0342382e52657e7b61f187d44ba9ffd261c703cde71f89f5680070017",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/cyapa_gen3.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"cyapa.h\"\n\n\n#define GEN3_MAX_FINGERS 5\n#define GEN3_FINGER_NUM(x) (((x) >> 4) & 0x07)\n\n#define BLK_HEAD_BYTES 32\n\n \n#define PRODUCT_ID_SIZE  16\n#define QUERY_DATA_SIZE  27\n#define REG_PROTOCOL_GEN_QUERY_OFFSET  20\n\n#define REG_OFFSET_DATA_BASE     0x0000\n#define REG_OFFSET_COMMAND_BASE  0x0028\n#define REG_OFFSET_QUERY_BASE    0x002a\n\n#define CYAPA_OFFSET_SOFT_RESET  REG_OFFSET_COMMAND_BASE\n#define OP_RECALIBRATION_MASK    0x80\n#define OP_REPORT_BASELINE_MASK  0x40\n#define REG_OFFSET_MAX_BASELINE  0x0026\n#define REG_OFFSET_MIN_BASELINE  0x0027\n\n#define REG_OFFSET_POWER_MODE (REG_OFFSET_COMMAND_BASE + 1)\n#define SET_POWER_MODE_DELAY   10000   \n#define SET_POWER_MODE_TRIES   5\n\n#define GEN3_BL_CMD_CHECKSUM_SEED 0xff\n#define GEN3_BL_CMD_INITIATE_BL   0x38\n#define GEN3_BL_CMD_WRITE_BLOCK   0x39\n#define GEN3_BL_CMD_VERIFY_BLOCK  0x3a\n#define GEN3_BL_CMD_TERMINATE_BL  0x3b\n#define GEN3_BL_CMD_LAUNCH_APP    0xa5\n\n \n#define CYAPA_DEV_NORMAL  0x03\n#define CYAPA_DEV_BUSY    0x01\n\n#define CYAPA_FW_BLOCK_SIZE\t64\n#define CYAPA_FW_READ_SIZE\t16\n#define CYAPA_FW_HDR_START\t0x0780\n#define CYAPA_FW_HDR_BLOCK_COUNT  2\n#define CYAPA_FW_HDR_BLOCK_START  (CYAPA_FW_HDR_START / CYAPA_FW_BLOCK_SIZE)\n#define CYAPA_FW_HDR_SIZE\t  (CYAPA_FW_HDR_BLOCK_COUNT * \\\n\t\t\t\t\tCYAPA_FW_BLOCK_SIZE)\n#define CYAPA_FW_DATA_START\t0x0800\n#define CYAPA_FW_DATA_BLOCK_COUNT  480\n#define CYAPA_FW_DATA_BLOCK_START  (CYAPA_FW_DATA_START / CYAPA_FW_BLOCK_SIZE)\n#define CYAPA_FW_DATA_SIZE\t(CYAPA_FW_DATA_BLOCK_COUNT * \\\n\t\t\t\t CYAPA_FW_BLOCK_SIZE)\n#define CYAPA_FW_SIZE\t\t(CYAPA_FW_HDR_SIZE + CYAPA_FW_DATA_SIZE)\n#define CYAPA_CMD_LEN\t\t16\n\n#define GEN3_BL_IDLE_FW_MAJ_VER_OFFSET 0x0b\n#define GEN3_BL_IDLE_FW_MIN_VER_OFFSET (GEN3_BL_IDLE_FW_MAJ_VER_OFFSET + 1)\n\n\nstruct cyapa_touch {\n\t \n\tu8 xy_hi;\n\tu8 x_lo;   \n\tu8 y_lo;   \n\tu8 pressure;\n\t \n\tu8 id;\n} __packed;\n\nstruct cyapa_reg_data {\n\t \n\tu8 device_status;\n\t \n\tu8 finger_btn;\n\t \n\tstruct cyapa_touch touches[5];\n} __packed;\n\nstruct gen3_write_block_cmd {\n\tu8 checksum_seed;   \n\tu8 cmd_code;        \n\tu8 key[8];          \n\t__be16 block_num;\n\tu8 block_data[CYAPA_FW_BLOCK_SIZE];\n\tu8 block_checksum;   \n\tu8 cmd_checksum;     \n} __packed;\n\nstatic const u8 security_key[] = {\n\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 };\nstatic const u8 bl_activate[] = { 0x00, 0xff, 0x38, 0x00, 0x01, 0x02, 0x03,\n\t\t0x04, 0x05, 0x06, 0x07 };\nstatic const u8 bl_deactivate[] = { 0x00, 0xff, 0x3b, 0x00, 0x01, 0x02, 0x03,\n\t\t0x04, 0x05, 0x06, 0x07 };\nstatic const u8 bl_exit[] = { 0x00, 0xff, 0xa5, 0x00, 0x01, 0x02, 0x03, 0x04,\n\t\t0x05, 0x06, 0x07 };\n\n\n  \n#define CMD_RESET 0\n#define CMD_POWER_MODE 1\n#define CMD_DEV_STATUS 2\n#define CMD_REPORT_MAX_BASELINE 3\n#define CMD_REPORT_MIN_BASELINE 4\n#define SMBUS_BYTE_CMD(cmd) (((cmd) & 0x3f) << 1)\n#define CYAPA_SMBUS_RESET         SMBUS_BYTE_CMD(CMD_RESET)\n#define CYAPA_SMBUS_POWER_MODE    SMBUS_BYTE_CMD(CMD_POWER_MODE)\n#define CYAPA_SMBUS_DEV_STATUS    SMBUS_BYTE_CMD(CMD_DEV_STATUS)\n#define CYAPA_SMBUS_MAX_BASELINE  SMBUS_BYTE_CMD(CMD_REPORT_MAX_BASELINE)\n#define CYAPA_SMBUS_MIN_BASELINE  SMBUS_BYTE_CMD(CMD_REPORT_MIN_BASELINE)\n\n  \n#define REG_GROUP_DATA  0\n#define REG_GROUP_CMD   2\n#define REG_GROUP_QUERY 3\n#define SMBUS_GROUP_CMD(grp) (0x80 | (((grp) & 0x07) << 3))\n#define CYAPA_SMBUS_GROUP_DATA  SMBUS_GROUP_CMD(REG_GROUP_DATA)\n#define CYAPA_SMBUS_GROUP_CMD   SMBUS_GROUP_CMD(REG_GROUP_CMD)\n#define CYAPA_SMBUS_GROUP_QUERY SMBUS_GROUP_CMD(REG_GROUP_QUERY)\n\n  \n#define CMD_BL_STATUS\t\t0\n#define CMD_BL_HEAD\t\t1\n#define CMD_BL_CMD\t\t2\n#define CMD_BL_DATA\t\t3\n#define CMD_BL_ALL\t\t4\n#define CMD_BLK_PRODUCT_ID\t5\n#define CMD_BLK_HEAD\t\t6\n#define SMBUS_BLOCK_CMD(cmd) (0xc0 | (((cmd) & 0x1f) << 1))\n\n \n#define CYAPA_SMBUS_BL_STATUS SMBUS_BLOCK_CMD(CMD_BL_STATUS)\n#define CYAPA_SMBUS_BL_HEAD   SMBUS_BLOCK_CMD(CMD_BL_HEAD)\n#define CYAPA_SMBUS_BL_CMD    SMBUS_BLOCK_CMD(CMD_BL_CMD)\n#define CYAPA_SMBUS_BL_DATA   SMBUS_BLOCK_CMD(CMD_BL_DATA)\n#define CYAPA_SMBUS_BL_ALL    SMBUS_BLOCK_CMD(CMD_BL_ALL)\n\n \n#define CYAPA_SMBUS_BLK_PRODUCT_ID SMBUS_BLOCK_CMD(CMD_BLK_PRODUCT_ID)\n#define CYAPA_SMBUS_BLK_HEAD       SMBUS_BLOCK_CMD(CMD_BLK_HEAD)\n\nstruct cyapa_cmd_len {\n\tu8 cmd;\n\tu8 len;\n};\n\n \nstatic const struct cyapa_cmd_len cyapa_i2c_cmds[] = {\n\t{ CYAPA_OFFSET_SOFT_RESET, 1 },\t\t \n\t{ REG_OFFSET_COMMAND_BASE + 1, 1 },\t \n\t{ REG_OFFSET_DATA_BASE, 1 },\t\t \n\t{ REG_OFFSET_DATA_BASE, sizeof(struct cyapa_reg_data) },\n\t\t\t\t\t\t \n\t{ REG_OFFSET_COMMAND_BASE, 0 },\t\t \n\t{ REG_OFFSET_QUERY_BASE, QUERY_DATA_SIZE },  \n\t{ BL_HEAD_OFFSET, 3 },\t\t\t \n\t{ BL_HEAD_OFFSET, 16 },\t\t\t \n\t{ BL_HEAD_OFFSET, 16 },\t\t\t \n\t{ BL_DATA_OFFSET, 16 },\t\t\t \n\t{ BL_HEAD_OFFSET, 32 },\t\t\t \n\t{ REG_OFFSET_QUERY_BASE, PRODUCT_ID_SIZE },\n\t\t\t\t\t\t \n\t{ REG_OFFSET_DATA_BASE, 32 },\t\t \n\t{ REG_OFFSET_MAX_BASELINE, 1 },\t\t \n\t{ REG_OFFSET_MIN_BASELINE, 1 },\t\t \n};\n\nstatic const struct cyapa_cmd_len cyapa_smbus_cmds[] = {\n\t{ CYAPA_SMBUS_RESET, 1 },\t\t \n\t{ CYAPA_SMBUS_POWER_MODE, 1 },\t\t \n\t{ CYAPA_SMBUS_DEV_STATUS, 1 },\t\t \n\t{ CYAPA_SMBUS_GROUP_DATA, sizeof(struct cyapa_reg_data) },\n\t\t\t\t\t\t \n\t{ CYAPA_SMBUS_GROUP_CMD, 2 },\t\t \n\t{ CYAPA_SMBUS_GROUP_QUERY, QUERY_DATA_SIZE },\n\t\t\t\t\t\t \n\t{ CYAPA_SMBUS_BL_STATUS, 3 },\t\t \n\t{ CYAPA_SMBUS_BL_HEAD, 16 },\t\t \n\t{ CYAPA_SMBUS_BL_CMD, 16 },\t\t \n\t{ CYAPA_SMBUS_BL_DATA, 16 },\t\t \n\t{ CYAPA_SMBUS_BL_ALL, 32 },\t\t \n\t{ CYAPA_SMBUS_BLK_PRODUCT_ID, PRODUCT_ID_SIZE },\n\t\t\t\t\t\t \n\t{ CYAPA_SMBUS_BLK_HEAD, 16 },\t\t \n\t{ CYAPA_SMBUS_MAX_BASELINE, 1 },\t \n\t{ CYAPA_SMBUS_MIN_BASELINE, 1 },\t \n};\n\nstatic int cyapa_gen3_try_poll_handler(struct cyapa *cyapa);\n\n \nssize_t cyapa_smbus_read_block(struct cyapa *cyapa, u8 cmd, size_t len,\n\t\t\t\t      u8 *values)\n{\n\tssize_t ret;\n\tu8 index;\n\tu8 smbus_cmd;\n\tu8 *buf;\n\tstruct i2c_client *client = cyapa->client;\n\n\tif (!(SMBUS_BYTE_BLOCK_CMD_MASK & cmd))\n\t\treturn -EINVAL;\n\n\tif (SMBUS_GROUP_BLOCK_CMD_MASK & cmd) {\n\t\t \n\t\tsmbus_cmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\n\t\tret = i2c_smbus_read_block_data(client, smbus_cmd, values);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tfor (index = 0; index * I2C_SMBUS_BLOCK_MAX < len; index++) {\n\t\tsmbus_cmd = SMBUS_ENCODE_IDX(cmd, index);\n\t\tsmbus_cmd = SMBUS_ENCODE_RW(smbus_cmd, SMBUS_READ);\n\t\tbuf = values + I2C_SMBUS_BLOCK_MAX * index;\n\t\tret = i2c_smbus_read_block_data(client, smbus_cmd, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret > 0 ? len : ret;\n}\n\nstatic s32 cyapa_read_byte(struct cyapa *cyapa, u8 cmd_idx)\n{\n\tu8 cmd;\n\n\tif (cyapa->smbus) {\n\t\tcmd = cyapa_smbus_cmds[cmd_idx].cmd;\n\t\tcmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\n\t} else {\n\t\tcmd = cyapa_i2c_cmds[cmd_idx].cmd;\n\t}\n\treturn i2c_smbus_read_byte_data(cyapa->client, cmd);\n}\n\nstatic s32 cyapa_write_byte(struct cyapa *cyapa, u8 cmd_idx, u8 value)\n{\n\tu8 cmd;\n\n\tif (cyapa->smbus) {\n\t\tcmd = cyapa_smbus_cmds[cmd_idx].cmd;\n\t\tcmd = SMBUS_ENCODE_RW(cmd, SMBUS_WRITE);\n\t} else {\n\t\tcmd = cyapa_i2c_cmds[cmd_idx].cmd;\n\t}\n\treturn i2c_smbus_write_byte_data(cyapa->client, cmd, value);\n}\n\nssize_t cyapa_i2c_reg_read_block(struct cyapa *cyapa, u8 reg, size_t len,\n\t\t\t\t\tu8 *values)\n{\n\treturn i2c_smbus_read_i2c_block_data(cyapa->client, reg, len, values);\n}\n\nstatic ssize_t cyapa_i2c_reg_write_block(struct cyapa *cyapa, u8 reg,\n\t\t\t\t\t size_t len, const u8 *values)\n{\n\treturn i2c_smbus_write_i2c_block_data(cyapa->client, reg, len, values);\n}\n\nssize_t cyapa_read_block(struct cyapa *cyapa, u8 cmd_idx, u8 *values)\n{\n\tu8 cmd;\n\tsize_t len;\n\n\tif (cyapa->smbus) {\n\t\tcmd = cyapa_smbus_cmds[cmd_idx].cmd;\n\t\tlen = cyapa_smbus_cmds[cmd_idx].len;\n\t\treturn cyapa_smbus_read_block(cyapa, cmd, len, values);\n\t}\n\tcmd = cyapa_i2c_cmds[cmd_idx].cmd;\n\tlen = cyapa_i2c_cmds[cmd_idx].len;\n\treturn cyapa_i2c_reg_read_block(cyapa, cmd, len, values);\n}\n\n \nstatic int cyapa_gen3_state_parse(struct cyapa *cyapa, u8 *reg_data, int len)\n{\n\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\n\t \n\tif (reg_data[REG_BL_FILE] == BL_FILE &&\n\t\treg_data[REG_BL_ERROR] == BL_ERROR_NO_ERR_IDLE &&\n\t\t(reg_data[REG_BL_STATUS] ==\n\t\t\t(BL_STATUS_RUNNING | BL_STATUS_CSUM_VALID) ||\n\t\t\treg_data[REG_BL_STATUS] == BL_STATUS_RUNNING)) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN3;\n\t\tcyapa->state = CYAPA_STATE_BL_IDLE;\n\t} else if (reg_data[REG_BL_FILE] == BL_FILE &&\n\t\t(reg_data[REG_BL_STATUS] & BL_STATUS_RUNNING) ==\n\t\t\tBL_STATUS_RUNNING) {\n\t\tcyapa->gen = CYAPA_GEN3;\n\t\tif (reg_data[REG_BL_STATUS] & BL_STATUS_BUSY) {\n\t\t\tcyapa->state = CYAPA_STATE_BL_BUSY;\n\t\t} else {\n\t\t\tif ((reg_data[REG_BL_ERROR] & BL_ERROR_BOOTLOADING) ==\n\t\t\t\t\tBL_ERROR_BOOTLOADING)\n\t\t\t\tcyapa->state = CYAPA_STATE_BL_ACTIVE;\n\t\t\telse\n\t\t\t\tcyapa->state = CYAPA_STATE_BL_IDLE;\n\t\t}\n\t} else if ((reg_data[REG_OP_STATUS] & OP_STATUS_SRC) &&\n\t\t\t(reg_data[REG_OP_DATA1] & OP_DATA_VALID)) {\n\t\t \n\t\tif (GEN3_FINGER_NUM(reg_data[REG_OP_DATA1]) <=\n\t\t\t\tGEN3_MAX_FINGERS) {\n\t\t\t \n\t\t\tcyapa->gen = CYAPA_GEN3;\n\t\t\tcyapa->state = CYAPA_STATE_OP;\n\t\t}\n\t} else if (reg_data[REG_OP_STATUS] == 0x0C &&\n\t\t\treg_data[REG_OP_DATA1] == 0x08) {\n\t\t \n\t\tcyapa->gen = CYAPA_GEN3;\n\t\tcyapa->state = CYAPA_STATE_OP;\n\t} else if (reg_data[REG_BL_STATUS] &\n\t\t\t(BL_STATUS_RUNNING | BL_STATUS_BUSY)) {\n\t\tcyapa->gen = CYAPA_GEN3;\n\t\tcyapa->state = CYAPA_STATE_BL_BUSY;\n\t}\n\n\tif (cyapa->gen == CYAPA_GEN3 && (cyapa->state == CYAPA_STATE_OP ||\n\t\tcyapa->state == CYAPA_STATE_BL_IDLE ||\n\t\tcyapa->state == CYAPA_STATE_BL_ACTIVE ||\n\t\tcyapa->state == CYAPA_STATE_BL_BUSY))\n\t\treturn 0;\n\n\treturn -EAGAIN;\n}\n\n \nstatic int cyapa_gen3_bl_enter(struct cyapa *cyapa)\n{\n\tint error;\n\tint waiting_time;\n\n\terror = cyapa_poll_state(cyapa, 500);\n\tif (error)\n\t\treturn error;\n\tif (cyapa->state == CYAPA_STATE_BL_IDLE) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (cyapa->state != CYAPA_STATE_OP)\n\t\treturn -EAGAIN;\n\n\tcyapa->operational = false;\n\tcyapa->state = CYAPA_STATE_NO_DEVICE;\n\terror = cyapa_write_byte(cyapa, CYAPA_CMD_SOFT_RESET, 0x01);\n\tif (error)\n\t\treturn -EIO;\n\n\tusleep_range(25000, 50000);\n\twaiting_time = 2000;   \n\tdo {\n\t\terror = cyapa_poll_state(cyapa, 500);\n\t\tif (error) {\n\t\t\tif (error == -ETIMEDOUT) {\n\t\t\t\twaiting_time -= 500;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((cyapa->state == CYAPA_STATE_BL_IDLE) &&\n\t\t\t!(cyapa->status[REG_BL_STATUS] & BL_STATUS_WATCHDOG))\n\t\t\tbreak;\n\n\t\tmsleep(100);\n\t\twaiting_time -= 100;\n\t} while (waiting_time > 0);\n\n\tif ((cyapa->state != CYAPA_STATE_BL_IDLE) ||\n\t\t(cyapa->status[REG_BL_STATUS] & BL_STATUS_WATCHDOG))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen3_bl_activate(struct cyapa *cyapa)\n{\n\tint error;\n\n\terror = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_activate),\n\t\t\t\t\tbl_activate);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(2000);\n\terror = cyapa_poll_state(cyapa, 11000);\n\tif (error)\n\t\treturn error;\n\tif (cyapa->state != CYAPA_STATE_BL_ACTIVE)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen3_bl_deactivate(struct cyapa *cyapa)\n{\n\tint error;\n\n\terror = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_deactivate),\n\t\t\t\t\tbl_deactivate);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(100);\n\terror = cyapa_poll_state(cyapa, 500);\n\tif (error)\n\t\treturn error;\n\tif (cyapa->state != CYAPA_STATE_BL_IDLE)\n\t\treturn -EAGAIN;\n\treturn 0;\n}\n\n \nstatic int cyapa_gen3_bl_exit(struct cyapa *cyapa)\n{\n\tint error;\n\n\terror = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_exit), bl_exit);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(50);\n\t \n\terror = cyapa_poll_state(cyapa, 4000);\n\tif (error < 0)\n\t\treturn error;\n\tif (cyapa->state != CYAPA_STATE_OP)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic u16 cyapa_gen3_csum(const u8 *buf, size_t count)\n{\n\tint i;\n\tu16 csum = 0;\n\n\tfor (i = 0; i < count; i++)\n\t\tcsum += buf[i];\n\n\treturn csum;\n}\n\n \nstatic int cyapa_gen3_check_fw(struct cyapa *cyapa, const struct firmware *fw)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tu16 csum;\n\tu16 csum_expected;\n\n\t \n\tif (fw->size != CYAPA_FW_SIZE) {\n\t\tdev_err(dev, \"invalid firmware size = %zu, expected %u.\\n\",\n\t\t\tfw->size, CYAPA_FW_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcsum_expected = (fw->data[0] << 8) | fw->data[1];\n\tcsum = cyapa_gen3_csum(&fw->data[2], CYAPA_FW_HDR_SIZE - 2);\n\tif (csum != csum_expected) {\n\t\tdev_err(dev, \"%s %04x, expected: %04x\\n\",\n\t\t\t\"invalid firmware header checksum = \",\n\t\t\tcsum, csum_expected);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcsum_expected = (fw->data[CYAPA_FW_HDR_SIZE - 2] << 8) |\n\t\t\t fw->data[CYAPA_FW_HDR_SIZE - 1];\n\tcsum = cyapa_gen3_csum(&fw->data[CYAPA_FW_HDR_SIZE],\n\t\t\tCYAPA_FW_DATA_SIZE);\n\tif (csum != csum_expected) {\n\t\tdev_err(dev, \"%s %04x, expected: %04x\\n\",\n\t\t\t\"invalid firmware header checksum = \",\n\t\t\tcsum, csum_expected);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int cyapa_gen3_write_buffer(struct cyapa *cyapa,\n\t\tconst u8 *buf, size_t len)\n{\n\tint error;\n\tsize_t i;\n\tunsigned char cmd[CYAPA_CMD_LEN + 1];\n\tsize_t cmd_len;\n\n\tfor (i = 0; i < len; i += CYAPA_CMD_LEN) {\n\t\tconst u8 *payload = &buf[i];\n\n\t\tcmd_len = (len - i >= CYAPA_CMD_LEN) ? CYAPA_CMD_LEN : len - i;\n\t\tcmd[0] = i;\n\t\tmemcpy(&cmd[1], payload, cmd_len);\n\n\t\terror = cyapa_i2c_reg_write_block(cyapa, 0, cmd_len + 1, cmd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}\n\n \nstatic int cyapa_gen3_write_fw_block(struct cyapa *cyapa,\n\t\tu16 block, const u8 *data)\n{\n\tint ret;\n\tstruct gen3_write_block_cmd write_block_cmd;\n\tu8 status[BL_STATUS_SIZE];\n\tint tries;\n\tu8 bl_status, bl_error;\n\n\t \n\twrite_block_cmd.checksum_seed = GEN3_BL_CMD_CHECKSUM_SEED;\n\twrite_block_cmd.cmd_code = GEN3_BL_CMD_WRITE_BLOCK;\n\tmemcpy(write_block_cmd.key, security_key, sizeof(security_key));\n\tput_unaligned_be16(block, &write_block_cmd.block_num);\n\tmemcpy(write_block_cmd.block_data, data, CYAPA_FW_BLOCK_SIZE);\n\twrite_block_cmd.block_checksum = cyapa_gen3_csum(\n\t\t\twrite_block_cmd.block_data, CYAPA_FW_BLOCK_SIZE);\n\twrite_block_cmd.cmd_checksum = cyapa_gen3_csum((u8 *)&write_block_cmd,\n\t\t\tsizeof(write_block_cmd) - 1);\n\n\tret = cyapa_gen3_write_buffer(cyapa, (u8 *)&write_block_cmd,\n\t\t\tsizeof(write_block_cmd));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttries = 11;   \n\tdo {\n\t\tusleep_range(10000, 20000);\n\n\t\t \n\t\tret = cyapa_i2c_reg_read_block(cyapa, BL_HEAD_OFFSET,\n\t\t\t\t\t       BL_STATUS_SIZE, status);\n\t\tif (ret != BL_STATUS_SIZE)\n\t\t\treturn (ret < 0) ? ret : -EIO;\n\t} while ((status[REG_BL_STATUS] & BL_STATUS_BUSY) && --tries);\n\n\t \n\tbl_status = status[REG_BL_STATUS] & ~BL_STATUS_REV_MASK;\n\tbl_error = status[REG_BL_ERROR] & ~BL_ERROR_RESERVED;\n\n\tif (bl_status & BL_STATUS_BUSY)\n\t\tret = -ETIMEDOUT;\n\telse if (bl_status != BL_STATUS_RUNNING ||\n\t\tbl_error != BL_ERROR_BOOTLOADING)\n\t\tret = -EIO;\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int cyapa_gen3_write_blocks(struct cyapa *cyapa,\n\t\tsize_t start_block, size_t block_count,\n\t\tconst u8 *image_data)\n{\n\tint error;\n\tint i;\n\n\tfor (i = 0; i < block_count; i++) {\n\t\tsize_t block = start_block + i;\n\t\tsize_t addr = i * CYAPA_FW_BLOCK_SIZE;\n\t\tconst u8 *data = &image_data[addr];\n\n\t\terror = cyapa_gen3_write_fw_block(cyapa, block, data);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}\n\nstatic int cyapa_gen3_do_fw_update(struct cyapa *cyapa,\n\t\tconst struct firmware *fw)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\t \n\terror = cyapa_gen3_write_blocks(cyapa,\n\t\tCYAPA_FW_DATA_BLOCK_START, CYAPA_FW_DATA_BLOCK_COUNT,\n\t\t&fw->data[CYAPA_FW_HDR_BLOCK_COUNT * CYAPA_FW_BLOCK_SIZE]);\n\tif (error) {\n\t\tdev_err(dev, \"FW update aborted, write image: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\terror = cyapa_gen3_write_blocks(cyapa,\n\t\tCYAPA_FW_HDR_BLOCK_START, CYAPA_FW_HDR_BLOCK_COUNT,\n\t\t&fw->data[0]);\n\tif (error) {\n\t\tdev_err(dev, \"FW update aborted, write checksum: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t cyapa_gen3_do_calibrate(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tunsigned long timeout;\n\tint ret;\n\n\tret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading dev status: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif ((ret & CYAPA_DEV_NORMAL) != CYAPA_DEV_NORMAL) {\n\t\tdev_warn(dev, \"Trackpad device is busy, device state: 0x%02x\\n\",\n\t\t\t ret);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = cyapa_write_byte(cyapa, CYAPA_CMD_SOFT_RESET,\n\t\t\t       OP_RECALIBRATION_MASK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to send calibrate command: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\t \n\ttimeout = jiffies + 2 * HZ;\n\tdo {\n\t\t \n\t\tmsleep(100);\n\t\tret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error reading dev status: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret & CYAPA_DEV_NORMAL) == CYAPA_DEV_NORMAL) {\n\t\t\tdev_dbg(dev, \"Calibration successful.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} while (time_is_after_jiffies(timeout));\n\n\tdev_err(dev, \"Failed to calibrate. Timeout.\\n\");\n\tret = -ETIMEDOUT;\n\nout:\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t cyapa_gen3_show_baseline(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct cyapa *cyapa = dev_get_drvdata(dev);\n\tint max_baseline, min_baseline;\n\tint tries;\n\tint ret;\n\n\tret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading dev status. err = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif ((ret & CYAPA_DEV_NORMAL) != CYAPA_DEV_NORMAL) {\n\t\tdev_warn(dev, \"Trackpad device is busy. device state = 0x%x\\n\",\n\t\t\t ret);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = cyapa_write_byte(cyapa, CYAPA_CMD_SOFT_RESET,\n\t\t\t       OP_REPORT_BASELINE_MASK);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to send report baseline command. %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\ttries = 3;   \n\tdo {\n\t\tusleep_range(10000, 20000);\n\n\t\tret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error reading dev status. err = %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret & CYAPA_DEV_NORMAL) == CYAPA_DEV_NORMAL)\n\t\t\tbreak;\n\t} while (--tries);\n\n\tif (tries == 0) {\n\t\tdev_err(dev, \"Device timed out going to Normal state.\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tret = cyapa_read_byte(cyapa, CYAPA_CMD_MAX_BASELINE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read max baseline. err = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tmax_baseline = ret;\n\n\tret = cyapa_read_byte(cyapa, CYAPA_CMD_MIN_BASELINE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read min baseline. err = %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tmin_baseline = ret;\n\n\tdev_dbg(dev, \"Baseline report successful. Max: %d Min: %d\\n\",\n\t\tmax_baseline, min_baseline);\n\tret = scnprintf(buf, PAGE_SIZE, \"%d %d\\n\", max_baseline, min_baseline);\n\nout:\n\treturn ret;\n}\n\n \n\nstatic u16 cyapa_get_wait_time_for_pwr_cmd(u8 pwr_mode)\n{\n\tswitch (pwr_mode) {\n\tcase PWR_MODE_FULL_ACTIVE: return 20;\n\tcase PWR_MODE_BTN_ONLY: return 20;\n\tcase PWR_MODE_OFF: return 20;\n\tdefault: return cyapa_pwr_cmd_to_sleep_time(pwr_mode) + 50;\n\t}\n}\n\n \nstatic int cyapa_gen3_set_power_mode(struct cyapa *cyapa, u8 power_mode,\n\t\tu16 always_unused, enum cyapa_pm_stage pm_stage)\n{\n\tstruct input_dev *input = cyapa->input;\n\tu8 power;\n\tint tries;\n\tint sleep_time;\n\tint interval;\n\tint ret;\n\n\tif (cyapa->state != CYAPA_STATE_OP)\n\t\treturn 0;\n\n\ttries = SET_POWER_MODE_TRIES;\n\twhile (tries--) {\n\t\tret = cyapa_read_byte(cyapa, CYAPA_CMD_POWER_MODE);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tusleep_range(SET_POWER_MODE_DELAY, 2 * SET_POWER_MODE_DELAY);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif ((ret & PWR_MODE_MASK) == power_mode)\n\t\treturn 0;\n\n\tsleep_time = (int)cyapa_get_wait_time_for_pwr_cmd(ret & PWR_MODE_MASK);\n\tpower = ret;\n\tpower &= ~PWR_MODE_MASK;\n\tpower |= power_mode & PWR_MODE_MASK;\n\ttries = SET_POWER_MODE_TRIES;\n\twhile (tries--) {\n\t\tret = cyapa_write_byte(cyapa, CYAPA_CMD_POWER_MODE, power);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tusleep_range(SET_POWER_MODE_DELAY, 2 * SET_POWER_MODE_DELAY);\n\t}\n\n\t \n\tif (cyapa->operational &&\n\t    input && input_device_enabled(input) &&\n\t    (pm_stage == CYAPA_PM_RUNTIME_SUSPEND ||\n\t     pm_stage == CYAPA_PM_RUNTIME_RESUME)) {\n\t\t \n\t\tinterval = 1000 / 120;\n\t\twhile (sleep_time > 0) {\n\t\t\tif (sleep_time > interval)\n\t\t\t\tmsleep(interval);\n\t\t\telse\n\t\t\t\tmsleep(sleep_time);\n\t\t\tsleep_time -= interval;\n\t\t\tcyapa_gen3_try_poll_handler(cyapa);\n\t\t}\n\t} else {\n\t\tmsleep(sleep_time);\n\t}\n\n\treturn ret;\n}\n\nstatic int cyapa_gen3_set_proximity(struct cyapa *cyapa, bool enable)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cyapa_gen3_get_query_data(struct cyapa *cyapa)\n{\n\tu8 query_data[QUERY_DATA_SIZE];\n\tint ret;\n\n\tif (cyapa->state != CYAPA_STATE_OP)\n\t\treturn -EBUSY;\n\n\tret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_QUERY, query_data);\n\tif (ret != QUERY_DATA_SIZE)\n\t\treturn (ret < 0) ? ret : -EIO;\n\n\tmemcpy(&cyapa->product_id[0], &query_data[0], 5);\n\tcyapa->product_id[5] = '-';\n\tmemcpy(&cyapa->product_id[6], &query_data[5], 6);\n\tcyapa->product_id[12] = '-';\n\tmemcpy(&cyapa->product_id[13], &query_data[11], 2);\n\tcyapa->product_id[15] = '\\0';\n\n\tcyapa->fw_maj_ver = query_data[15];\n\tcyapa->fw_min_ver = query_data[16];\n\n\tcyapa->btn_capability = query_data[19] & CAPABILITY_BTN_MASK;\n\n\tcyapa->gen = query_data[20] & 0x0f;\n\n\tcyapa->max_abs_x = ((query_data[21] & 0xf0) << 4) | query_data[22];\n\tcyapa->max_abs_y = ((query_data[21] & 0x0f) << 8) | query_data[23];\n\n\tcyapa->physical_size_x =\n\t\t((query_data[24] & 0xf0) << 4) | query_data[25];\n\tcyapa->physical_size_y =\n\t\t((query_data[24] & 0x0f) << 8) | query_data[26];\n\n\tcyapa->max_z = 255;\n\n\treturn 0;\n}\n\nstatic int cyapa_gen3_bl_query_data(struct cyapa *cyapa)\n{\n\tu8 bl_data[CYAPA_CMD_LEN];\n\tint ret;\n\n\tret = cyapa_i2c_reg_read_block(cyapa, 0, CYAPA_CMD_LEN, bl_data);\n\tif (ret != CYAPA_CMD_LEN)\n\t\treturn (ret < 0) ? ret : -EIO;\n\n\t \n\tif (bl_data[REG_BL_STATUS] ==\n\t\t\t(BL_STATUS_RUNNING | BL_STATUS_CSUM_VALID)) {\n\t\tcyapa->fw_maj_ver = bl_data[GEN3_BL_IDLE_FW_MAJ_VER_OFFSET];\n\t\tcyapa->fw_min_ver = bl_data[GEN3_BL_IDLE_FW_MIN_VER_OFFSET];\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cyapa_gen3_do_operational_check(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tint error;\n\n\tswitch (cyapa->state) {\n\tcase CYAPA_STATE_BL_ACTIVE:\n\t\terror = cyapa_gen3_bl_deactivate(cyapa);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to bl_deactivate: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tfallthrough;\n\tcase CYAPA_STATE_BL_IDLE:\n\t\t \n\t\tcyapa_gen3_bl_query_data(cyapa);\n\n\t\terror = cyapa_gen3_bl_exit(cyapa);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to bl_exit: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tfallthrough;\n\tcase CYAPA_STATE_OP:\n\t\t \n\t\terror = cyapa_gen3_set_power_mode(cyapa,\n\t\t\t\tPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\n\t\tif (error)\n\t\t\tdev_err(dev, \"%s: set full power mode failed: %d\\n\",\n\t\t\t\t__func__, error);\n\t\terror = cyapa_gen3_get_query_data(cyapa);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\t \n\t\tif (cyapa->gen != CYAPA_GEN3) {\n\t\t\tdev_err(dev, \"unsupported protocol version (%d)\",\n\t\t\t\tcyapa->gen);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (memcmp(cyapa->product_id, product_id,\n\t\t\t\tstrlen(product_id)) != 0) {\n\t\t\tdev_err(dev, \"unsupported product ID (%s)\\n\",\n\t\t\t\tcyapa->product_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic bool cyapa_gen3_irq_cmd_handler(struct cyapa *cyapa)\n{\n\t \n\tif (cyapa->gen != CYAPA_GEN3)\n\t\treturn true;\n\n\tif (cyapa->operational)\n\t\treturn true;\n\n\t \n\treturn false;\n}\n\nstatic int cyapa_gen3_event_process(struct cyapa *cyapa,\n\t\t\t\t    struct cyapa_reg_data *data)\n{\n\tstruct input_dev *input = cyapa->input;\n\tint num_fingers;\n\tint i;\n\n\tnum_fingers = (data->finger_btn >> 4) & 0x0f;\n\tfor (i = 0; i < num_fingers; i++) {\n\t\tconst struct cyapa_touch *touch = &data->touches[i];\n\t\t \n\t\tint slot = touch->id - 1;\n\n\t\tinput_mt_slot(input, slot);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X,\n\t\t\t\t ((touch->xy_hi & 0xf0) << 4) | touch->x_lo);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y,\n\t\t\t\t ((touch->xy_hi & 0x0f) << 8) | touch->y_lo);\n\t\tinput_report_abs(input, ABS_MT_PRESSURE, touch->pressure);\n\t}\n\n\tinput_mt_sync_frame(input);\n\n\tif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK)\n\t\tinput_report_key(input, BTN_LEFT,\n\t\t\t\t !!(data->finger_btn & OP_DATA_LEFT_BTN));\n\tif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK)\n\t\tinput_report_key(input, BTN_MIDDLE,\n\t\t\t\t !!(data->finger_btn & OP_DATA_MIDDLE_BTN));\n\tif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK)\n\t\tinput_report_key(input, BTN_RIGHT,\n\t\t\t\t !!(data->finger_btn & OP_DATA_RIGHT_BTN));\n\tinput_sync(input);\n\n\treturn 0;\n}\n\nstatic int cyapa_gen3_irq_handler(struct cyapa *cyapa)\n{\n\tstruct device *dev = &cyapa->client->dev;\n\tstruct cyapa_reg_data data;\n\tint ret;\n\n\tret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_DATA, (u8 *)&data);\n\tif (ret != sizeof(data)) {\n\t\tdev_err(dev, \"failed to read report data, (%d)\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((data.device_status & OP_STATUS_SRC) != OP_STATUS_SRC ||\n\t    (data.device_status & OP_STATUS_DEV) != CYAPA_DEV_NORMAL ||\n\t    (data.finger_btn & OP_DATA_VALID) != OP_DATA_VALID) {\n\t\tdev_err(dev, \"invalid device state bytes: %02x %02x\\n\",\n\t\t\tdata.device_status, data.finger_btn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn cyapa_gen3_event_process(cyapa, &data);\n}\n\n \nstatic int cyapa_gen3_try_poll_handler(struct cyapa *cyapa)\n{\n\tstruct cyapa_reg_data data;\n\tint ret;\n\n\tret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_DATA, (u8 *)&data);\n\tif (ret != sizeof(data))\n\t\treturn -EINVAL;\n\n\tif ((data.device_status & OP_STATUS_SRC) != OP_STATUS_SRC ||\n\t    (data.device_status & OP_STATUS_DEV) != CYAPA_DEV_NORMAL ||\n\t    (data.finger_btn & OP_DATA_VALID) != OP_DATA_VALID)\n\t\treturn -EINVAL;\n\n\treturn cyapa_gen3_event_process(cyapa, &data);\n\n}\n\nstatic int cyapa_gen3_initialize(struct cyapa *cyapa) { return 0; }\nstatic int cyapa_gen3_bl_initiate(struct cyapa *cyapa,\n\t\tconst struct firmware *fw) { return 0; }\nstatic int cyapa_gen3_empty_output_data(struct cyapa *cyapa,\n\t\tu8 *buf, int *len, cb_sort func) { return 0; }\n\nconst struct cyapa_dev_ops cyapa_gen3_ops = {\n\t.check_fw = cyapa_gen3_check_fw,\n\t.bl_enter = cyapa_gen3_bl_enter,\n\t.bl_activate = cyapa_gen3_bl_activate,\n\t.update_fw = cyapa_gen3_do_fw_update,\n\t.bl_deactivate = cyapa_gen3_bl_deactivate,\n\t.bl_initiate = cyapa_gen3_bl_initiate,\n\n\t.show_baseline = cyapa_gen3_show_baseline,\n\t.calibrate_store = cyapa_gen3_do_calibrate,\n\n\t.initialize = cyapa_gen3_initialize,\n\n\t.state_parse = cyapa_gen3_state_parse,\n\t.operational_check = cyapa_gen3_do_operational_check,\n\n\t.irq_handler = cyapa_gen3_irq_handler,\n\t.irq_cmd_handler = cyapa_gen3_irq_cmd_handler,\n\t.sort_empty_output_data = cyapa_gen3_empty_output_data,\n\t.set_power_mode = cyapa_gen3_set_power_mode,\n\n\t.set_proximity = cyapa_gen3_set_proximity,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}