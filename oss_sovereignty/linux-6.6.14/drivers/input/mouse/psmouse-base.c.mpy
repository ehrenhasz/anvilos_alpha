{
  "module_name": "psmouse-base.c",
  "hash_id": "03c5c01c47cd8ec40079c22c8fcaba85d5838c471b6aca13b7fcea4b5a4858b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/psmouse-base.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n#define psmouse_fmt(fmt)\tfmt\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/init.h>\n#include <linux/libps2.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#include \"psmouse.h\"\n#include \"synaptics.h\"\n#include \"logips2pp.h\"\n#include \"alps.h\"\n#include \"hgpk.h\"\n#include \"lifebook.h\"\n#include \"trackpoint.h\"\n#include \"touchkit_ps2.h\"\n#include \"elantech.h\"\n#include \"sentelic.h\"\n#include \"cypress_ps2.h\"\n#include \"focaltech.h\"\n#include \"vmmouse.h\"\n#include \"byd.h\"\n\n#define DRIVER_DESC\t\"PS/2 mouse driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int psmouse_max_proto = PSMOUSE_AUTO;\nstatic int psmouse_set_maxproto(const char *val, const struct kernel_param *);\nstatic int psmouse_get_maxproto(char *buffer, const struct kernel_param *kp);\nstatic const struct kernel_param_ops param_ops_proto_abbrev = {\n\t.set = psmouse_set_maxproto,\n\t.get = psmouse_get_maxproto,\n};\n#define param_check_proto_abbrev(name, p)\t__param_check(name, p, unsigned int)\nmodule_param_named(proto, psmouse_max_proto, proto_abbrev, 0644);\nMODULE_PARM_DESC(proto, \"Highest protocol extension to probe (bare, imps, exps, any). Useful for KVM switches.\");\n\nstatic unsigned int psmouse_resolution = 200;\nmodule_param_named(resolution, psmouse_resolution, uint, 0644);\nMODULE_PARM_DESC(resolution, \"Resolution, in dpi.\");\n\nstatic unsigned int psmouse_rate = 100;\nmodule_param_named(rate, psmouse_rate, uint, 0644);\nMODULE_PARM_DESC(rate, \"Report rate, in reports per second.\");\n\nstatic bool psmouse_smartscroll = true;\nmodule_param_named(smartscroll, psmouse_smartscroll, bool, 0644);\nMODULE_PARM_DESC(smartscroll, \"Logitech Smartscroll autorepeat, 1 = enabled (default), 0 = disabled.\");\n\nstatic bool psmouse_a4tech_2wheels;\nmodule_param_named(a4tech_workaround, psmouse_a4tech_2wheels, bool, 0644);\nMODULE_PARM_DESC(a4tech_workaround, \"A4Tech second scroll wheel workaround, 1 = enabled, 0 = disabled (default).\");\n\nstatic unsigned int psmouse_resetafter = 5;\nmodule_param_named(resetafter, psmouse_resetafter, uint, 0644);\nMODULE_PARM_DESC(resetafter, \"Reset device after so many bad packets (0 = never).\");\n\nstatic unsigned int psmouse_resync_time;\nmodule_param_named(resync_time, psmouse_resync_time, uint, 0644);\nMODULE_PARM_DESC(resync_time, \"How long can mouse stay idle before forcing resync (in seconds, 0 = never).\");\n\nPSMOUSE_DEFINE_ATTR(protocol, S_IWUSR | S_IRUGO,\n\t\t\tNULL,\n\t\t\tpsmouse_attr_show_protocol, psmouse_attr_set_protocol);\nPSMOUSE_DEFINE_ATTR(rate, S_IWUSR | S_IRUGO,\n\t\t\t(void *) offsetof(struct psmouse, rate),\n\t\t\tpsmouse_show_int_attr, psmouse_attr_set_rate);\nPSMOUSE_DEFINE_ATTR(resolution, S_IWUSR | S_IRUGO,\n\t\t\t(void *) offsetof(struct psmouse, resolution),\n\t\t\tpsmouse_show_int_attr, psmouse_attr_set_resolution);\nPSMOUSE_DEFINE_ATTR(resetafter, S_IWUSR | S_IRUGO,\n\t\t\t(void *) offsetof(struct psmouse, resetafter),\n\t\t\tpsmouse_show_int_attr, psmouse_set_int_attr);\nPSMOUSE_DEFINE_ATTR(resync_time, S_IWUSR | S_IRUGO,\n\t\t\t(void *) offsetof(struct psmouse, resync_time),\n\t\t\tpsmouse_show_int_attr, psmouse_set_int_attr);\n\nstatic struct attribute *psmouse_dev_attrs[] = {\n\t&psmouse_attr_protocol.dattr.attr,\n\t&psmouse_attr_rate.dattr.attr,\n\t&psmouse_attr_resolution.dattr.attr,\n\t&psmouse_attr_resetafter.dattr.attr,\n\t&psmouse_attr_resync_time.dattr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(psmouse_dev);\n\n \nstatic DEFINE_MUTEX(psmouse_mutex);\n\nstatic struct workqueue_struct *kpsmoused_wq;\n\nstruct psmouse *psmouse_from_serio(struct serio *serio)\n{\n\tstruct ps2dev *ps2dev = serio_get_drvdata(serio);\n\n\treturn container_of(ps2dev, struct psmouse, ps2dev);\n}\n\nvoid psmouse_report_standard_buttons(struct input_dev *dev, u8 buttons)\n{\n\tinput_report_key(dev, BTN_LEFT,   buttons & BIT(0));\n\tinput_report_key(dev, BTN_MIDDLE, buttons & BIT(2));\n\tinput_report_key(dev, BTN_RIGHT,  buttons & BIT(1));\n}\n\nvoid psmouse_report_standard_motion(struct input_dev *dev, u8 *packet)\n{\n\tint x, y;\n\n\tx = packet[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0;\n\ty = packet[2] ? packet[2] - ((packet[0] << 3) & 0x100) : 0;\n\n\tinput_report_rel(dev, REL_X, x);\n\tinput_report_rel(dev, REL_Y, -y);\n}\n\nvoid psmouse_report_standard_packet(struct input_dev *dev, u8 *packet)\n{\n\tpsmouse_report_standard_buttons(dev, packet[0]);\n\tpsmouse_report_standard_motion(dev, packet);\n}\n\n \npsmouse_ret_t psmouse_process_byte(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev = psmouse->dev;\n\tu8 *packet = psmouse->packet;\n\tint wheel;\n\n\tif (psmouse->pktcnt < psmouse->pktsize)\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\t \n\n\tswitch (psmouse->protocol->type) {\n\tcase PSMOUSE_IMPS:\n\t\t \n\t\tinput_report_rel(dev, REL_WHEEL, -(s8) packet[3]);\n\t\tbreak;\n\n\tcase PSMOUSE_IMEX:\n\t\t \n\t\tswitch (packet[3] & 0xC0) {\n\t\tcase 0x80:  \n\t\t\tinput_report_rel(dev, REL_WHEEL,\n\t\t\t\t\t -sign_extend32(packet[3], 5));\n\t\t\tbreak;\n\t\tcase 0x40:  \n\t\t\tinput_report_rel(dev, REL_HWHEEL,\n\t\t\t\t\t -sign_extend32(packet[3], 5));\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\tcase 0xC0:\n\t\t\twheel = sign_extend32(packet[3], 3);\n\n\t\t\t \n\t\t\tif (psmouse_a4tech_2wheels && abs(wheel) > 1)\n\t\t\t\tinput_report_rel(dev, REL_HWHEEL, wheel / 2);\n\t\t\telse\n\t\t\t\tinput_report_rel(dev, REL_WHEEL, -wheel);\n\n\t\t\tinput_report_key(dev, BTN_SIDE,  packet[3] & BIT(4));\n\t\t\tinput_report_key(dev, BTN_EXTRA, packet[3] & BIT(5));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PSMOUSE_GENPS:\n\t\t \n\t\tinput_report_rel(dev, REL_WHEEL, -(s8) packet[3]);\n\n\t\t \n\t\tinput_report_key(dev, BTN_SIDE,  packet[0] & BIT(6));\n\t\tinput_report_key(dev, BTN_EXTRA, packet[0] & BIT(7));\n\t\tbreak;\n\n\tcase PSMOUSE_THINKPS:\n\t\t \n\t\tinput_report_key(dev, BTN_EXTRA, packet[0] & BIT(3));\n\n\t\t \n\t\tpacket[1] |= (packet[0] & 0x40) << 1;\n\t\tbreak;\n\n\tcase PSMOUSE_CORTRON:\n\t\t \n\t\tinput_report_key(dev, BTN_SIDE, packet[0] & BIT(3));\n\t\tpacket[0] |= BIT(3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tpacket[0] |= psmouse->extra_buttons;\n\tpsmouse_report_standard_packet(dev, packet);\n\n\tinput_sync(dev);\n\n\treturn PSMOUSE_FULL_PACKET;\n}\n\nvoid psmouse_queue_work(struct psmouse *psmouse, struct delayed_work *work,\n\t\tunsigned long delay)\n{\n\tqueue_delayed_work(kpsmoused_wq, work, delay);\n}\n\n \nstatic inline void __psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state)\n{\n\tpsmouse->state = new_state;\n\tpsmouse->pktcnt = psmouse->out_of_sync_cnt = 0;\n\tpsmouse->ps2dev.flags = 0;\n\tpsmouse->last = jiffies;\n}\n\n \nvoid psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state)\n{\n\tserio_pause_rx(psmouse->ps2dev.serio);\n\t__psmouse_set_state(psmouse, new_state);\n\tserio_continue_rx(psmouse->ps2dev.serio);\n}\n\n \nstatic int psmouse_handle_byte(struct psmouse *psmouse)\n{\n\tpsmouse_ret_t rc = psmouse->protocol_handler(psmouse);\n\n\tswitch (rc) {\n\tcase PSMOUSE_BAD_DATA:\n\t\tif (psmouse->state == PSMOUSE_ACTIVATED) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"%s at %s lost sync at byte %d\\n\",\n\t\t\t\t     psmouse->name, psmouse->phys,\n\t\t\t\t     psmouse->pktcnt);\n\t\t\tif (++psmouse->out_of_sync_cnt == psmouse->resetafter) {\n\t\t\t\t__psmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\t\t\t\tpsmouse_notice(psmouse,\n\t\t\t\t\t\t\"issuing reconnect request\\n\");\n\t\t\t\tserio_reconnect(psmouse->ps2dev.serio);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tpsmouse->pktcnt = 0;\n\t\tbreak;\n\n\tcase PSMOUSE_FULL_PACKET:\n\t\tpsmouse->pktcnt = 0;\n\t\tif (psmouse->out_of_sync_cnt) {\n\t\t\tpsmouse->out_of_sync_cnt = 0;\n\t\t\tpsmouse_notice(psmouse,\n\t\t\t\t\t\"%s at %s - driver resynced.\\n\",\n\t\t\t\t\tpsmouse->name, psmouse->phys);\n\t\t}\n\t\tbreak;\n\n\tcase PSMOUSE_GOOD_DATA:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void psmouse_handle_oob_data(struct psmouse *psmouse, u8 data)\n{\n\tswitch (psmouse->oob_data_type) {\n\tcase PSMOUSE_OOB_NONE:\n\t\tpsmouse->oob_data_type = data;\n\t\tbreak;\n\n\tcase PSMOUSE_OOB_EXTRA_BTNS:\n\t\tpsmouse_report_standard_buttons(psmouse->dev, data);\n\t\tinput_sync(psmouse->dev);\n\n\t\tpsmouse->extra_buttons = data;\n\t\tpsmouse->oob_data_type = PSMOUSE_OOB_NONE;\n\t\tbreak;\n\n\tdefault:\n\t\tpsmouse_warn(psmouse,\n\t\t\t     \"unknown OOB_DATA type: 0x%02x\\n\",\n\t\t\t     psmouse->oob_data_type);\n\t\tpsmouse->oob_data_type = PSMOUSE_OOB_NONE;\n\t\tbreak;\n\t}\n}\n\nstatic enum ps2_disposition psmouse_pre_receive_byte(struct ps2dev *ps2dev,\n\t\t\t\t\t\t     u8 data,\n\t\t\t\t\t\t     unsigned int flags)\n{\n\tstruct psmouse *psmouse = container_of(ps2dev, struct psmouse, ps2dev);\n\n\tif (psmouse->state == PSMOUSE_IGNORE)\n\t\treturn PS2_IGNORE;\n\n\tif (unlikely((flags & SERIO_TIMEOUT) ||\n\t\t     ((flags & SERIO_PARITY) &&\n\t\t      !psmouse->protocol->ignore_parity))) {\n\n\t\tif (psmouse->state == PSMOUSE_ACTIVATED)\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"bad data from KBC -%s%s\\n\",\n\t\t\t\t     flags & SERIO_TIMEOUT ? \" timeout\" : \"\",\n\t\t\t\t     flags & SERIO_PARITY ? \" bad parity\" : \"\");\n\t\treturn PS2_ERROR;\n\t}\n\n\tif (flags & SERIO_OOB_DATA) {\n\t\tpsmouse_handle_oob_data(psmouse, data);\n\t\treturn PS2_IGNORE;\n\t}\n\n\treturn PS2_PROCESS;\n}\n\nstatic void psmouse_receive_byte(struct ps2dev *ps2dev, u8 data)\n{\n\tstruct psmouse *psmouse = container_of(ps2dev, struct psmouse, ps2dev);\n\n\tpm_wakeup_event(&ps2dev->serio->dev, 0);\n\n\tif (psmouse->state <= PSMOUSE_RESYNCING)\n\t\treturn;\n\n\tif (psmouse->state == PSMOUSE_ACTIVATED &&\n\t    psmouse->pktcnt && time_after(jiffies, psmouse->last + HZ/2)) {\n\t\tpsmouse_info(psmouse, \"%s at %s lost synchronization, throwing %d bytes away.\\n\",\n\t\t\t     psmouse->name, psmouse->phys, psmouse->pktcnt);\n\t\tpsmouse->badbyte = psmouse->packet[0];\n\t\t__psmouse_set_state(psmouse, PSMOUSE_RESYNCING);\n\t\tpsmouse_queue_work(psmouse, &psmouse->resync_work, 0);\n\t\treturn;\n\t}\n\n\tpsmouse->packet[psmouse->pktcnt++] = data;\n\n\t \n\tif (unlikely(psmouse->packet[0] == PSMOUSE_RET_BAT && psmouse->pktcnt <= 2)) {\n\t\tif (psmouse->pktcnt == 1) {\n\t\t\tpsmouse->last = jiffies;\n\t\t\treturn;\n\t\t}\n\n\t\tif (psmouse->packet[1] == PSMOUSE_RET_ID ||\n\t\t    (psmouse->protocol->type == PSMOUSE_HGPK &&\n\t\t     psmouse->packet[1] == PSMOUSE_RET_BAT)) {\n\t\t\t__psmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\t\t\tserio_reconnect(ps2dev->serio);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tpsmouse->pktcnt = 1;\n\t\tif (psmouse_handle_byte(psmouse))\n\t\t\treturn;\n\n\t\tpsmouse->packet[psmouse->pktcnt++] = data;\n\t}\n\n\t \n\tif (psmouse->state == PSMOUSE_ACTIVATED &&\n\t    psmouse->pktcnt == 1 && psmouse->resync_time &&\n\t    time_after(jiffies, psmouse->last + psmouse->resync_time * HZ)) {\n\t\tpsmouse->badbyte = psmouse->packet[0];\n\t\t__psmouse_set_state(psmouse, PSMOUSE_RESYNCING);\n\t\tpsmouse_queue_work(psmouse, &psmouse->resync_work, 0);\n\t\treturn;\n\t}\n\n\tpsmouse->last = jiffies;\n\tpsmouse_handle_byte(psmouse);\n}\n\n \nint psmouse_reset(struct psmouse *psmouse)\n{\n\tu8 param[2];\n\tint error;\n\n\terror = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_RESET_BAT);\n\tif (error)\n\t\treturn error;\n\n\tif (param[0] != PSMOUSE_RET_BAT && param[1] != PSMOUSE_RET_ID)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nvoid psmouse_set_resolution(struct psmouse *psmouse, unsigned int resolution)\n{\n\tstatic const u8 params[] = { 0, 1, 2, 2, 3 };\n\tu8 p;\n\n\tif (resolution == 0 || resolution > 200)\n\t\tresolution = 200;\n\n\tp = params[resolution / 50];\n\tps2_command(&psmouse->ps2dev, &p, PSMOUSE_CMD_SETRES);\n\tpsmouse->resolution = 25 << p;\n}\n\n \nstatic void psmouse_set_rate(struct psmouse *psmouse, unsigned int rate)\n{\n\tstatic const u8 rates[] = { 200, 100, 80, 60, 40, 20, 10, 0 };\n\tu8 r;\n\tint i = 0;\n\n\twhile (rates[i] > rate)\n\t\ti++;\n\tr = rates[i];\n\tps2_command(&psmouse->ps2dev, &r, PSMOUSE_CMD_SETRATE);\n\tpsmouse->rate = r;\n}\n\n \nstatic void psmouse_set_scale(struct psmouse *psmouse, enum psmouse_scale scale)\n{\n\tps2_command(&psmouse->ps2dev, NULL,\n\t\t    scale == PSMOUSE_SCALE21 ? PSMOUSE_CMD_SETSCALE21 :\n\t\t\t\t\t       PSMOUSE_CMD_SETSCALE11);\n}\n\n \nstatic int psmouse_poll(struct psmouse *psmouse)\n{\n\treturn ps2_command(&psmouse->ps2dev, psmouse->packet,\n\t\t\t   PSMOUSE_CMD_POLL | (psmouse->pktsize << 8));\n}\n\nstatic bool psmouse_check_pnp_id(const char *id, const char * const ids[])\n{\n\tint i;\n\n\tfor (i = 0; ids[i]; i++)\n\t\tif (!strcasecmp(id, ids[i]))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nbool psmouse_matches_pnp_id(struct psmouse *psmouse, const char * const ids[])\n{\n\tstruct serio *serio = psmouse->ps2dev.serio;\n\tchar *p, *fw_id_copy, *save_ptr;\n\tbool found = false;\n\n\tif (strncmp(serio->firmware_id, \"PNP: \", 5))\n\t\treturn false;\n\n\tfw_id_copy = kstrndup(&serio->firmware_id[5],\n\t\t\t      sizeof(serio->firmware_id) - 5,\n\t\t\t      GFP_KERNEL);\n\tif (!fw_id_copy)\n\t\treturn false;\n\n\tsave_ptr = fw_id_copy;\n\twhile ((p = strsep(&fw_id_copy, \" \")) != NULL) {\n\t\tif (psmouse_check_pnp_id(p, ids)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(save_ptr);\n\treturn found;\n}\n\n \nstatic int genius_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param[4];\n\n\tparam[0] = 3;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\n\tps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11);\n\tps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11);\n\tps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO);\n\n\tif (param[0] != 0x00 || param[1] != 0x33 || param[2] != 0x55)\n\t\treturn -ENODEV;\n\n\tif (set_properties) {\n\t\t__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\n\t\t__set_bit(BTN_EXTRA, psmouse->dev->keybit);\n\t\t__set_bit(BTN_SIDE, psmouse->dev->keybit);\n\t\t__set_bit(REL_WHEEL, psmouse->dev->relbit);\n\n\t\tpsmouse->vendor = \"Genius\";\n\t\tpsmouse->name = \"Mouse\";\n\t\tpsmouse->pktsize = 4;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int intellimouse_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param[2];\n\n\tparam[0] = 200;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] = 100;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] =  80;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\n\n\tif (param[0] != 3)\n\t\treturn -ENODEV;\n\n\tif (set_properties) {\n\t\t__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\n\t\t__set_bit(REL_WHEEL, psmouse->dev->relbit);\n\n\t\tif (!psmouse->vendor)\n\t\t\tpsmouse->vendor = \"Generic\";\n\t\tif (!psmouse->name)\n\t\t\tpsmouse->name = \"Wheel Mouse\";\n\t\tpsmouse->pktsize = 4;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int im_explorer_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param[2];\n\n\tintellimouse_detect(psmouse, 0);\n\n\tparam[0] = 200;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] = 200;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] =  80;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\n\n\tif (param[0] != 4)\n\t\treturn -ENODEV;\n\n\t \n\tparam[0] = 200;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] =  80;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] =  40;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\n\tif (set_properties) {\n\t\t__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\n\t\t__set_bit(REL_WHEEL, psmouse->dev->relbit);\n\t\t__set_bit(REL_HWHEEL, psmouse->dev->relbit);\n\t\t__set_bit(BTN_SIDE, psmouse->dev->keybit);\n\t\t__set_bit(BTN_EXTRA, psmouse->dev->keybit);\n\n\t\tif (!psmouse->vendor)\n\t\t\tpsmouse->vendor = \"Generic\";\n\t\tif (!psmouse->name)\n\t\t\tpsmouse->name = \"Explorer Mouse\";\n\t\tpsmouse->pktsize = 4;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int thinking_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param[2];\n\tstatic const u8 seq[] = { 20, 60, 40, 20, 20, 60, 40, 20, 20 };\n\tint i;\n\n\tparam[0] = 10;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\tparam[0] = 0;\n\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\n\tfor (i = 0; i < ARRAY_SIZE(seq); i++) {\n\t\tparam[0] = seq[i];\n\t\tps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\n\t}\n\tps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\n\n\tif (param[0] != 2)\n\t\treturn -ENODEV;\n\n\tif (set_properties) {\n\t\t__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\n\t\t__set_bit(BTN_EXTRA, psmouse->dev->keybit);\n\n\t\tpsmouse->vendor = \"Kensington\";\n\t\tpsmouse->name = \"ThinkingMouse\";\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ps2bare_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tif (set_properties) {\n\t\tif (!psmouse->vendor)\n\t\t\tpsmouse->vendor = \"Generic\";\n\t\tif (!psmouse->name)\n\t\t\tpsmouse->name = \"Mouse\";\n\n\t\t \n\t\tinput_set_capability(psmouse->dev, EV_KEY, BTN_MIDDLE);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cortron_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"Cortron\";\n\t\tpsmouse->name = \"PS/2 Trackball\";\n\n\t\t__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\n\t\t__set_bit(BTN_SIDE, psmouse->dev->keybit);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct psmouse_protocol psmouse_protocols[] = {\n\t{\n\t\t.type\t\t= PSMOUSE_PS2,\n\t\t.name\t\t= \"PS/2\",\n\t\t.alias\t\t= \"bare\",\n\t\t.maxproto\t= true,\n\t\t.ignore_parity\t= true,\n\t\t.detect\t\t= ps2bare_detect,\n\t\t.try_passthru\t= true,\n\t},\n#ifdef CONFIG_MOUSE_PS2_LOGIPS2PP\n\t{\n\t\t.type\t\t= PSMOUSE_PS2PP,\n\t\t.name\t\t= \"PS2++\",\n\t\t.alias\t\t= \"logitech\",\n\t\t.detect\t\t= ps2pp_detect,\n\t},\n#endif\n\t{\n\t\t.type\t\t= PSMOUSE_THINKPS,\n\t\t.name\t\t= \"ThinkPS/2\",\n\t\t.alias\t\t= \"thinkps\",\n\t\t.detect\t\t= thinking_detect,\n\t},\n#ifdef CONFIG_MOUSE_PS2_CYPRESS\n\t{\n\t\t.type\t\t= PSMOUSE_CYPRESS,\n\t\t.name\t\t= \"CyPS/2\",\n\t\t.alias\t\t= \"cypress\",\n\t\t.detect\t\t= cypress_detect,\n\t\t.init\t\t= cypress_init,\n\t},\n#endif\n\t{\n\t\t.type\t\t= PSMOUSE_GENPS,\n\t\t.name\t\t= \"GenPS/2\",\n\t\t.alias\t\t= \"genius\",\n\t\t.detect\t\t= genius_detect,\n\t},\n\t{\n\t\t.type\t\t= PSMOUSE_IMPS,\n\t\t.name\t\t= \"ImPS/2\",\n\t\t.alias\t\t= \"imps\",\n\t\t.maxproto\t= true,\n\t\t.ignore_parity\t= true,\n\t\t.detect\t\t= intellimouse_detect,\n\t\t.try_passthru\t= true,\n\t},\n\t{\n\t\t.type\t\t= PSMOUSE_IMEX,\n\t\t.name\t\t= \"ImExPS/2\",\n\t\t.alias\t\t= \"exps\",\n\t\t.maxproto\t= true,\n\t\t.ignore_parity\t= true,\n\t\t.detect\t\t= im_explorer_detect,\n\t\t.try_passthru\t= true,\n\t},\n#ifdef CONFIG_MOUSE_PS2_SYNAPTICS\n\t{\n\t\t.type\t\t= PSMOUSE_SYNAPTICS,\n\t\t.name\t\t= \"SynPS/2\",\n\t\t.alias\t\t= \"synaptics\",\n\t\t.detect\t\t= synaptics_detect,\n\t\t.init\t\t= synaptics_init_absolute,\n\t},\n\t{\n\t\t.type\t\t= PSMOUSE_SYNAPTICS_RELATIVE,\n\t\t.name\t\t= \"SynRelPS/2\",\n\t\t.alias\t\t= \"synaptics-relative\",\n\t\t.detect\t\t= synaptics_detect,\n\t\t.init\t\t= synaptics_init_relative,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS\n\t{\n\t\t.type\t\t= PSMOUSE_SYNAPTICS_SMBUS,\n\t\t.name\t\t= \"SynSMBus\",\n\t\t.alias\t\t= \"synaptics-smbus\",\n\t\t.detect\t\t= synaptics_detect,\n\t\t.init\t\t= synaptics_init_smbus,\n\t\t.smbus_companion = true,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_ALPS\n\t{\n\t\t.type\t\t= PSMOUSE_ALPS,\n\t\t.name\t\t= \"AlpsPS/2\",\n\t\t.alias\t\t= \"alps\",\n\t\t.detect\t\t= alps_detect,\n\t\t.init\t\t= alps_init,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_LIFEBOOK\n\t{\n\t\t.type\t\t= PSMOUSE_LIFEBOOK,\n\t\t.name\t\t= \"LBPS/2\",\n\t\t.alias\t\t= \"lifebook\",\n\t\t.detect\t\t= lifebook_detect,\n\t\t.init\t\t= lifebook_init,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_TRACKPOINT\n\t{\n\t\t.type\t\t= PSMOUSE_TRACKPOINT,\n\t\t.name\t\t= \"TPPS/2\",\n\t\t.alias\t\t= \"trackpoint\",\n\t\t.detect\t\t= trackpoint_detect,\n\t\t.try_passthru\t= true,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_TOUCHKIT\n\t{\n\t\t.type\t\t= PSMOUSE_TOUCHKIT_PS2,\n\t\t.name\t\t= \"touchkitPS/2\",\n\t\t.alias\t\t= \"touchkit\",\n\t\t.detect\t\t= touchkit_ps2_detect,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_OLPC\n\t{\n\t\t.type\t\t= PSMOUSE_HGPK,\n\t\t.name\t\t= \"OLPC HGPK\",\n\t\t.alias\t\t= \"hgpk\",\n\t\t.detect\t\t= hgpk_detect,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_ELANTECH\n\t{\n\t\t.type\t\t= PSMOUSE_ELANTECH,\n\t\t.name\t\t= \"ETPS/2\",\n\t\t.alias\t\t= \"elantech\",\n\t\t.detect\t\t= elantech_detect,\n\t\t.init\t\t= elantech_init_ps2,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_ELANTECH_SMBUS\n\t{\n\t\t.type\t\t= PSMOUSE_ELANTECH_SMBUS,\n\t\t.name\t\t= \"ETSMBus\",\n\t\t.alias\t\t= \"elantech-smbus\",\n\t\t.detect\t\t= elantech_detect,\n\t\t.init\t\t= elantech_init_smbus,\n\t\t.smbus_companion = true,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_SENTELIC\n\t{\n\t\t.type\t\t= PSMOUSE_FSP,\n\t\t.name\t\t= \"FSPPS/2\",\n\t\t.alias\t\t= \"fsp\",\n\t\t.detect\t\t= fsp_detect,\n\t\t.init\t\t= fsp_init,\n\t},\n#endif\n\t{\n\t\t.type\t\t= PSMOUSE_CORTRON,\n\t\t.name\t\t= \"CortronPS/2\",\n\t\t.alias\t\t= \"cortps\",\n\t\t.detect\t\t= cortron_detect,\n\t},\n#ifdef CONFIG_MOUSE_PS2_FOCALTECH\n\t{\n\t\t.type\t\t= PSMOUSE_FOCALTECH,\n\t\t.name\t\t= \"FocalTechPS/2\",\n\t\t.alias\t\t= \"focaltech\",\n\t\t.detect\t\t= focaltech_detect,\n\t\t.init\t\t= focaltech_init,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_VMMOUSE\n\t{\n\t\t.type\t\t= PSMOUSE_VMMOUSE,\n\t\t.name\t\t= VMMOUSE_PSNAME,\n\t\t.alias\t\t= \"vmmouse\",\n\t\t.detect\t\t= vmmouse_detect,\n\t\t.init\t\t= vmmouse_init,\n\t},\n#endif\n#ifdef CONFIG_MOUSE_PS2_BYD\n\t{\n\t\t.type\t\t= PSMOUSE_BYD,\n\t\t.name\t\t= \"BYDPS/2\",\n\t\t.alias\t\t= \"byd\",\n\t\t.detect\t\t= byd_detect,\n\t\t.init\t\t= byd_init,\n\t},\n#endif\n\t{\n\t\t.type\t\t= PSMOUSE_AUTO,\n\t\t.name\t\t= \"auto\",\n\t\t.alias\t\t= \"any\",\n\t\t.maxproto\t= true,\n\t},\n};\n\nstatic const struct psmouse_protocol *__psmouse_protocol_by_type(enum psmouse_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(psmouse_protocols); i++)\n\t\tif (psmouse_protocols[i].type == type)\n\t\t\treturn &psmouse_protocols[i];\n\n\treturn NULL;\n}\n\nstatic const struct psmouse_protocol *psmouse_protocol_by_type(enum psmouse_type type)\n{\n\tconst struct psmouse_protocol *proto;\n\n\tproto = __psmouse_protocol_by_type(type);\n\tif (proto)\n\t\treturn proto;\n\n\tWARN_ON(1);\n\treturn &psmouse_protocols[0];\n}\n\nstatic const struct psmouse_protocol *psmouse_protocol_by_name(const char *name, size_t len)\n{\n\tconst struct psmouse_protocol *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(psmouse_protocols); i++) {\n\t\tp = &psmouse_protocols[i];\n\n\t\tif ((strlen(p->name) == len && !strncmp(p->name, name, len)) ||\n\t\t    (strlen(p->alias) == len && !strncmp(p->alias, name, len)))\n\t\t\treturn &psmouse_protocols[i];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void psmouse_apply_defaults(struct psmouse *psmouse)\n{\n\tstruct input_dev *input_dev = psmouse->dev;\n\n\tbitmap_zero(input_dev->evbit, EV_CNT);\n\tbitmap_zero(input_dev->keybit, KEY_CNT);\n\tbitmap_zero(input_dev->relbit, REL_CNT);\n\tbitmap_zero(input_dev->absbit, ABS_CNT);\n\tbitmap_zero(input_dev->mscbit, MSC_CNT);\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_LEFT);\n\tinput_set_capability(input_dev, EV_KEY, BTN_RIGHT);\n\n\tinput_set_capability(input_dev, EV_REL, REL_X);\n\tinput_set_capability(input_dev, EV_REL, REL_Y);\n\n\t__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tpsmouse->protocol = &psmouse_protocols[0];\n\n\tpsmouse->set_rate = psmouse_set_rate;\n\tpsmouse->set_resolution = psmouse_set_resolution;\n\tpsmouse->set_scale = psmouse_set_scale;\n\tpsmouse->poll = psmouse_poll;\n\tpsmouse->protocol_handler = psmouse_process_byte;\n\tpsmouse->pktsize = 3;\n\tpsmouse->reconnect = NULL;\n\tpsmouse->fast_reconnect = NULL;\n\tpsmouse->disconnect = NULL;\n\tpsmouse->cleanup = NULL;\n\tpsmouse->pt_activate = NULL;\n\tpsmouse->pt_deactivate = NULL;\n}\n\nstatic bool psmouse_do_detect(int (*detect)(struct psmouse *, bool),\n\t\t\t      struct psmouse *psmouse, bool allow_passthrough,\n\t\t\t      bool set_properties)\n{\n\tif (psmouse->ps2dev.serio->id.type == SERIO_PS_PSTHRU &&\n\t    !allow_passthrough) {\n\t\treturn false;\n\t}\n\n\tif (set_properties)\n\t\tpsmouse_apply_defaults(psmouse);\n\n\treturn detect(psmouse, set_properties) == 0;\n}\n\nstatic bool psmouse_try_protocol(struct psmouse *psmouse,\n\t\t\t\t enum psmouse_type type,\n\t\t\t\t unsigned int *max_proto,\n\t\t\t\t bool set_properties, bool init_allowed)\n{\n\tconst struct psmouse_protocol *proto;\n\n\tproto = __psmouse_protocol_by_type(type);\n\tif (!proto)\n\t\treturn false;\n\n\tif (!psmouse_do_detect(proto->detect, psmouse, proto->try_passthru,\n\t\t\t       set_properties))\n\t\treturn false;\n\n\tif (set_properties && proto->init && init_allowed) {\n\t\tif (proto->init(psmouse) != 0) {\n\t\t\t \n\t\t\tif (*max_proto > PSMOUSE_IMEX)\n\t\t\t\t*max_proto = PSMOUSE_IMEX;\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic int psmouse_extensions(struct psmouse *psmouse,\n\t\t\t      unsigned int max_proto, bool set_properties)\n{\n\tbool synaptics_hardware = false;\n\tint ret;\n\n\t \n\tif (psmouse_do_detect(focaltech_detect,\n\t\t\t      psmouse, false, set_properties)) {\n\t\tif (max_proto > PSMOUSE_IMEX &&\n\t\t    IS_ENABLED(CONFIG_MOUSE_PS2_FOCALTECH) &&\n\t\t    (!set_properties || focaltech_init(psmouse) == 0)) {\n\t\t\treturn PSMOUSE_FOCALTECH;\n\t\t}\n\t\t \n\t\tpsmouse_max_proto = max_proto = PSMOUSE_PS2;\n\t}\n\n\t \n\tif (psmouse_try_protocol(psmouse, PSMOUSE_LIFEBOOK, &max_proto,\n\t\t\t\t set_properties, max_proto > PSMOUSE_IMEX))\n\t\treturn PSMOUSE_LIFEBOOK;\n\n\tif (psmouse_try_protocol(psmouse, PSMOUSE_VMMOUSE, &max_proto,\n\t\t\t\t set_properties, max_proto > PSMOUSE_IMEX))\n\t\treturn PSMOUSE_VMMOUSE;\n\n\t \n\tif (max_proto > PSMOUSE_IMEX &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_THINKPS, &max_proto,\n\t\t\t\t set_properties, true)) {\n\t\treturn PSMOUSE_THINKPS;\n\t}\n\n\t \n\tif (max_proto > PSMOUSE_PS2 &&\n\t    psmouse_do_detect(synaptics_detect,\n\t\t\t      psmouse, false, set_properties)) {\n\t\tsynaptics_hardware = true;\n\n\t\tif (max_proto > PSMOUSE_IMEX) {\n\t\t\t \n\t\t\tif (IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS) ||\n\t\t\t    IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)) {\n\t\t\t\tif (!set_properties)\n\t\t\t\t\treturn PSMOUSE_SYNAPTICS;\n\n\t\t\t\tret = synaptics_init(psmouse);\n\t\t\t\tif (ret >= 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tmax_proto = PSMOUSE_IMEX;\n\t\t}\n\n\t\t \n\t\tsynaptics_reset(psmouse);\n\t}\n\n\t \n\tif (max_proto > PSMOUSE_IMEX &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_CYPRESS, &max_proto,\n\t\t\t\t set_properties, true)) {\n\t\treturn PSMOUSE_CYPRESS;\n\t}\n\n\t \n\tif (max_proto > PSMOUSE_IMEX) {\n\t\tps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\n\t\tif (psmouse_try_protocol(psmouse, PSMOUSE_ALPS,\n\t\t\t\t\t &max_proto, set_properties, true))\n\t\t\treturn PSMOUSE_ALPS;\n\t}\n\n\t \n\tif (max_proto > PSMOUSE_IMEX &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_HGPK, &max_proto,\n\t\t\t\t set_properties, true)) {\n\t\treturn PSMOUSE_HGPK;\n\t}\n\n\t \n\tif (max_proto > PSMOUSE_IMEX &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_ELANTECH,\n\t\t\t\t &max_proto, set_properties, false)) {\n\t\tif (!set_properties)\n\t\t\treturn PSMOUSE_ELANTECH;\n\n\t\tret = elantech_init(psmouse);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t}\n\n\tif (max_proto > PSMOUSE_IMEX) {\n\t\tif (psmouse_try_protocol(psmouse, PSMOUSE_GENPS,\n\t\t\t\t\t &max_proto, set_properties, true))\n\t\t\treturn PSMOUSE_GENPS;\n\n\t\tif (psmouse_try_protocol(psmouse, PSMOUSE_PS2PP,\n\t\t\t\t\t &max_proto, set_properties, true))\n\t\t\treturn PSMOUSE_PS2PP;\n\n\t\tif (psmouse_try_protocol(psmouse, PSMOUSE_TRACKPOINT,\n\t\t\t\t\t &max_proto, set_properties, true))\n\t\t\treturn PSMOUSE_TRACKPOINT;\n\n\t\tif (psmouse_try_protocol(psmouse, PSMOUSE_TOUCHKIT_PS2,\n\t\t\t\t\t &max_proto, set_properties, true))\n\t\t\treturn PSMOUSE_TOUCHKIT_PS2;\n\t}\n\n\t \n\tif (max_proto > PSMOUSE_IMEX &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_FSP,\n\t\t\t\t &max_proto, set_properties, true)) {\n\t\treturn PSMOUSE_FSP;\n\t}\n\n\t \n\tps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\n\tpsmouse_reset(psmouse);\n\n\tif (max_proto >= PSMOUSE_IMEX &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_IMEX,\n\t\t\t\t &max_proto, set_properties, true)) {\n\t\treturn PSMOUSE_IMEX;\n\t}\n\n\tif (max_proto >= PSMOUSE_IMPS &&\n\t    psmouse_try_protocol(psmouse, PSMOUSE_IMPS,\n\t\t\t\t &max_proto, set_properties, true)) {\n\t\treturn PSMOUSE_IMPS;\n\t}\n\n\t \n\tpsmouse_try_protocol(psmouse, PSMOUSE_PS2,\n\t\t\t     &max_proto, set_properties, true);\n\n\tif (synaptics_hardware) {\n\t\t \n\t\tpsmouse_reset(psmouse);\n\t}\n\n\treturn PSMOUSE_PS2;\n}\n\n \nstatic int psmouse_probe(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param[2];\n\tint error;\n\n\t \n\tparam[0] = 0xa5;\n\terror = ps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\n\tif (error)\n\t\treturn error;\n\n\tif (param[0] != 0x00 && param[0] != 0x03 &&\n\t    param[0] != 0x04 && param[0] != 0xff)\n\t\treturn -ENODEV;\n\n\t \n\terror = ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\n\tif (error)\n\t\tpsmouse_warn(psmouse, \"Failed to reset mouse on %s: %d\\n\",\n\t\t\t     ps2dev->serio->phys, error);\n\n\treturn 0;\n}\n\n \nstatic void psmouse_initialize(struct psmouse *psmouse)\n{\n\t \n\tif (psmouse_max_proto != PSMOUSE_PS2) {\n\t\tpsmouse->set_rate(psmouse, psmouse->rate);\n\t\tpsmouse->set_resolution(psmouse, psmouse->resolution);\n\t\tpsmouse->set_scale(psmouse, PSMOUSE_SCALE11);\n\t}\n}\n\n \nint psmouse_activate(struct psmouse *psmouse)\n{\n\tif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\n\t\tpsmouse_warn(psmouse, \"Failed to enable mouse on %s\\n\",\n\t\t\t     psmouse->ps2dev.serio->phys);\n\t\treturn -1;\n\t}\n\n\tpsmouse_set_state(psmouse, PSMOUSE_ACTIVATED);\n\treturn 0;\n}\n\n \nint psmouse_deactivate(struct psmouse *psmouse)\n{\n\tint error;\n\n\terror = ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_DISABLE);\n\tif (error) {\n\t\tpsmouse_warn(psmouse, \"Failed to deactivate mouse on %s: %d\\n\",\n\t\t\t     psmouse->ps2dev.serio->phys, error);\n\t\treturn error;\n\t}\n\n\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\treturn 0;\n}\n\n \nstatic void psmouse_resync(struct work_struct *work)\n{\n\tstruct psmouse *parent = NULL, *psmouse =\n\t\tcontainer_of(work, struct psmouse, resync_work.work);\n\tstruct serio *serio = psmouse->ps2dev.serio;\n\tpsmouse_ret_t rc = PSMOUSE_GOOD_DATA;\n\tbool failed = false, enabled = false;\n\tint i;\n\n\tmutex_lock(&psmouse_mutex);\n\n\tif (psmouse->state != PSMOUSE_RESYNCING)\n\t\tgoto out;\n\n\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\tparent = psmouse_from_serio(serio->parent);\n\t\tpsmouse_deactivate(parent);\n\t}\n\n\t \n\tpsmouse->num_resyncs++;\n\n\tif (ps2_sendbyte(&psmouse->ps2dev, PSMOUSE_CMD_DISABLE, 20)) {\n\t\tif (psmouse->num_resyncs < 3 || psmouse->acks_disable_command)\n\t\t\tfailed = true;\n\t} else\n\t\tpsmouse->acks_disable_command = true;\n\n\t \n\tif (!failed) {\n\t\tif (psmouse->poll(psmouse))\n\t\t\tfailed = true;\n\t\telse {\n\t\t\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\t\t\tfor (i = 0; i < psmouse->pktsize; i++) {\n\t\t\t\tpsmouse->pktcnt++;\n\t\t\t\trc = psmouse->protocol_handler(psmouse);\n\t\t\t\tif (rc != PSMOUSE_GOOD_DATA)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rc != PSMOUSE_FULL_PACKET)\n\t\t\t\tfailed = true;\n\t\t\tpsmouse_set_state(psmouse, PSMOUSE_RESYNCING);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (!ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\n\t\t\tenabled = true;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(200);\n\t}\n\n\tif (!enabled) {\n\t\tpsmouse_warn(psmouse, \"failed to re-enable mouse on %s\\n\",\n\t\t\t     psmouse->ps2dev.serio->phys);\n\t\tfailed = true;\n\t}\n\n\tif (failed) {\n\t\tpsmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\t\tpsmouse_info(psmouse,\n\t\t\t     \"resync failed, issuing reconnect request\\n\");\n\t\tserio_reconnect(serio);\n\t} else\n\t\tpsmouse_set_state(psmouse, PSMOUSE_ACTIVATED);\n\n\tif (parent)\n\t\tpsmouse_activate(parent);\n out:\n\tmutex_unlock(&psmouse_mutex);\n}\n\n \nstatic void psmouse_cleanup(struct serio *serio)\n{\n\tstruct psmouse *psmouse = psmouse_from_serio(serio);\n\tstruct psmouse *parent = NULL;\n\n\tmutex_lock(&psmouse_mutex);\n\n\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\tparent = psmouse_from_serio(serio->parent);\n\t\tpsmouse_deactivate(parent);\n\t}\n\n\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\t \n\tif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_DISABLE))\n\t\tpsmouse_warn(psmouse, \"Failed to disable mouse on %s\\n\",\n\t\t\t     psmouse->ps2dev.serio->phys);\n\n\tif (psmouse->cleanup)\n\t\tpsmouse->cleanup(psmouse);\n\n\t \n\tps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\n\n\t \n\tps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_ENABLE);\n\n\tif (parent) {\n\t\tif (parent->pt_deactivate)\n\t\t\tparent->pt_deactivate(parent);\n\n\t\tpsmouse_activate(parent);\n\t}\n\n\tmutex_unlock(&psmouse_mutex);\n}\n\n \nstatic void psmouse_disconnect(struct serio *serio)\n{\n\tstruct psmouse *psmouse = psmouse_from_serio(serio);\n\tstruct psmouse *parent = NULL;\n\n\tmutex_lock(&psmouse_mutex);\n\n\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\n\t \n\tmutex_unlock(&psmouse_mutex);\n\tflush_workqueue(kpsmoused_wq);\n\tmutex_lock(&psmouse_mutex);\n\n\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\tparent = psmouse_from_serio(serio->parent);\n\t\tpsmouse_deactivate(parent);\n\t}\n\n\tif (psmouse->disconnect)\n\t\tpsmouse->disconnect(psmouse);\n\n\tif (parent && parent->pt_deactivate)\n\t\tparent->pt_deactivate(parent);\n\n\tpsmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\n\tif (psmouse->dev)\n\t\tinput_unregister_device(psmouse->dev);\n\n\tkfree(psmouse);\n\n\tif (parent)\n\t\tpsmouse_activate(parent);\n\n\tmutex_unlock(&psmouse_mutex);\n}\n\nstatic int psmouse_switch_protocol(struct psmouse *psmouse,\n\t\t\t\t   const struct psmouse_protocol *proto)\n{\n\tconst struct psmouse_protocol *selected_proto;\n\tstruct input_dev *input_dev = psmouse->dev;\n\tenum psmouse_type type;\n\n\tinput_dev->dev.parent = &psmouse->ps2dev.serio->dev;\n\n\tif (proto && (proto->detect || proto->init)) {\n\t\tpsmouse_apply_defaults(psmouse);\n\n\t\tif (proto->detect && proto->detect(psmouse, true) < 0)\n\t\t\treturn -1;\n\n\t\tif (proto->init && proto->init(psmouse) < 0)\n\t\t\treturn -1;\n\n\t\tselected_proto = proto;\n\t} else {\n\t\ttype = psmouse_extensions(psmouse, psmouse_max_proto, true);\n\t\tselected_proto = psmouse_protocol_by_type(type);\n\t}\n\n\tpsmouse->protocol = selected_proto;\n\n\t \n\tif (psmouse->pktsize == 3)\n\t\tpsmouse->resync_time = 0;\n\n\t \n\tif (psmouse->resync_time && psmouse->poll(psmouse))\n\t\tpsmouse->resync_time = 0;\n\n\tsnprintf(psmouse->devname, sizeof(psmouse->devname), \"%s %s %s\",\n\t\t selected_proto->name, psmouse->vendor, psmouse->name);\n\n\tinput_dev->name = psmouse->devname;\n\tinput_dev->phys = psmouse->phys;\n\tinput_dev->id.bustype = BUS_I8042;\n\tinput_dev->id.vendor = 0x0002;\n\tinput_dev->id.product = psmouse->protocol->type;\n\tinput_dev->id.version = psmouse->model;\n\n\treturn 0;\n}\n\n \nstatic int psmouse_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct psmouse *psmouse, *parent = NULL;\n\tstruct input_dev *input_dev;\n\tint retval = 0, error = -ENOMEM;\n\n\tmutex_lock(&psmouse_mutex);\n\n\t \n\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\tparent = psmouse_from_serio(serio->parent);\n\t\tpsmouse_deactivate(parent);\n\t}\n\n\tpsmouse = kzalloc(sizeof(struct psmouse), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!psmouse || !input_dev)\n\t\tgoto err_free;\n\n\tps2_init(&psmouse->ps2dev, serio,\n\t\t psmouse_pre_receive_byte, psmouse_receive_byte);\n\tINIT_DELAYED_WORK(&psmouse->resync_work, psmouse_resync);\n\tpsmouse->dev = input_dev;\n\tsnprintf(psmouse->phys, sizeof(psmouse->phys), \"%s/input0\", serio->phys);\n\n\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\terror = serio_open(serio, drv);\n\tif (error)\n\t\tgoto err_clear_drvdata;\n\n\t \n\tif (serio->id.type == SERIO_PS_PSTHRU)\n\t\tusleep_range(10000, 15000);\n\n\tif (psmouse_probe(psmouse) < 0) {\n\t\terror = -ENODEV;\n\t\tgoto err_close_serio;\n\t}\n\n\tpsmouse->rate = psmouse_rate;\n\tpsmouse->resolution = psmouse_resolution;\n\tpsmouse->resetafter = psmouse_resetafter;\n\tpsmouse->resync_time = parent ? 0 : psmouse_resync_time;\n\tpsmouse->smartscroll = psmouse_smartscroll;\n\n\tpsmouse_switch_protocol(psmouse, NULL);\n\n\tif (!psmouse->protocol->smbus_companion) {\n\t\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\t\tpsmouse_initialize(psmouse);\n\n\t\terror = input_register_device(input_dev);\n\t\tif (error)\n\t\t\tgoto err_protocol_disconnect;\n\t} else {\n\t\t \n\t\tinput_free_device(input_dev);\n\t\tpsmouse->dev = input_dev = NULL;\n\t}\n\n\tif (parent && parent->pt_activate)\n\t\tparent->pt_activate(parent);\n\n\t \n\tif (!psmouse->protocol->smbus_companion)\n\t\tpsmouse_activate(psmouse);\n\n out:\n\t \n\tif (parent)\n\t\tpsmouse_activate(parent);\n\n\tmutex_unlock(&psmouse_mutex);\n\treturn retval;\n\n err_protocol_disconnect:\n\tif (psmouse->disconnect)\n\t\tpsmouse->disconnect(psmouse);\n\tpsmouse_set_state(psmouse, PSMOUSE_IGNORE);\n err_close_serio:\n\tserio_close(serio);\n err_clear_drvdata:\n\tserio_set_drvdata(serio, NULL);\n err_free:\n\tinput_free_device(input_dev);\n\tkfree(psmouse);\n\n\tretval = error;\n\tgoto out;\n}\n\nstatic int __psmouse_reconnect(struct serio *serio, bool fast_reconnect)\n{\n\tstruct psmouse *psmouse = psmouse_from_serio(serio);\n\tstruct psmouse *parent = NULL;\n\tint (*reconnect_handler)(struct psmouse *);\n\tenum psmouse_type type;\n\tint rc = -1;\n\n\tmutex_lock(&psmouse_mutex);\n\n\tif (fast_reconnect) {\n\t\treconnect_handler = psmouse->fast_reconnect;\n\t\tif (!reconnect_handler) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\treconnect_handler = psmouse->reconnect;\n\t}\n\n\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\tparent = psmouse_from_serio(serio->parent);\n\t\tpsmouse_deactivate(parent);\n\t}\n\n\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\tif (reconnect_handler) {\n\t\tif (reconnect_handler(psmouse))\n\t\t\tgoto out;\n\t} else {\n\t\tpsmouse_reset(psmouse);\n\n\t\tif (psmouse_probe(psmouse) < 0)\n\t\t\tgoto out;\n\n\t\ttype = psmouse_extensions(psmouse, psmouse_max_proto, false);\n\t\tif (psmouse->protocol->type != type)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (!psmouse->protocol->smbus_companion) {\n\t\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\t\tpsmouse_initialize(psmouse);\n\t}\n\n\tif (parent && parent->pt_activate)\n\t\tparent->pt_activate(parent);\n\n\t \n\tif (!psmouse->protocol->smbus_companion)\n\t\tpsmouse_activate(psmouse);\n\n\trc = 0;\n\nout:\n\t \n\tif (parent)\n\t\tpsmouse_activate(parent);\n\nout_unlock:\n\tmutex_unlock(&psmouse_mutex);\n\treturn rc;\n}\n\nstatic int psmouse_reconnect(struct serio *serio)\n{\n\treturn __psmouse_reconnect(serio, false);\n}\n\nstatic int psmouse_fast_reconnect(struct serio *serio)\n{\n\treturn __psmouse_reconnect(serio, true);\n}\n\nstatic struct serio_device_id psmouse_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_8042,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_PS_PSTHRU,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, psmouse_serio_ids);\n\nstatic struct serio_driver psmouse_drv = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"psmouse\",\n\t\t.dev_groups\t= psmouse_dev_groups,\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= psmouse_serio_ids,\n\t.interrupt\t= ps2_interrupt,\n\t.connect\t= psmouse_connect,\n\t.reconnect\t= psmouse_reconnect,\n\t.fast_reconnect\t= psmouse_fast_reconnect,\n\t.disconnect\t= psmouse_disconnect,\n\t.cleanup\t= psmouse_cleanup,\n};\n\nssize_t psmouse_attr_show_helper(struct device *dev, struct device_attribute *devattr,\n\t\t\t\t char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct psmouse_attribute *attr = to_psmouse_attr(devattr);\n\tstruct psmouse *psmouse = psmouse_from_serio(serio);\n\n\tif (psmouse->protocol->smbus_companion &&\n\t\t\tdevattr != &psmouse_attr_protocol.dattr)\n\t\treturn -ENOENT;\n\n\treturn attr->show(psmouse, attr->data, buf);\n}\n\nssize_t psmouse_attr_set_helper(struct device *dev, struct device_attribute *devattr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct psmouse_attribute *attr = to_psmouse_attr(devattr);\n\tstruct psmouse *psmouse, *parent = NULL;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&psmouse_mutex);\n\tif (retval)\n\t\tgoto out;\n\n\tpsmouse = psmouse_from_serio(serio);\n\n\tif (psmouse->protocol->smbus_companion &&\n\t\t\tdevattr != &psmouse_attr_protocol.dattr) {\n\t\tretval = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (attr->protect) {\n\t\tif (psmouse->state == PSMOUSE_IGNORE) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\t\tparent = psmouse_from_serio(serio->parent);\n\t\t\tpsmouse_deactivate(parent);\n\t\t}\n\n\t\tif (!psmouse->protocol->smbus_companion)\n\t\t\tpsmouse_deactivate(psmouse);\n\t}\n\n\tretval = attr->set(psmouse, attr->data, buf, count);\n\n\tif (attr->protect) {\n\t\tif (retval != -ENODEV && !psmouse->protocol->smbus_companion)\n\t\t\tpsmouse_activate(psmouse);\n\n\t\tif (parent)\n\t\t\tpsmouse_activate(parent);\n\t}\n\n out_unlock:\n\tmutex_unlock(&psmouse_mutex);\n out:\n\treturn retval;\n}\n\nstatic ssize_t psmouse_show_int_attr(struct psmouse *psmouse, void *offset, char *buf)\n{\n\tunsigned int *field = (unsigned int *)((char *)psmouse + (size_t)offset);\n\n\treturn sprintf(buf, \"%u\\n\", *field);\n}\n\nstatic ssize_t psmouse_set_int_attr(struct psmouse *psmouse, void *offset, const char *buf, size_t count)\n{\n\tunsigned int *field = (unsigned int *)((char *)psmouse + (size_t)offset);\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\t*field = value;\n\n\treturn count;\n}\n\nstatic ssize_t psmouse_attr_show_protocol(struct psmouse *psmouse, void *data, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", psmouse->protocol->name);\n}\n\nstatic ssize_t psmouse_attr_set_protocol(struct psmouse *psmouse, void *data, const char *buf, size_t count)\n{\n\tstruct serio *serio = psmouse->ps2dev.serio;\n\tstruct psmouse *parent = NULL;\n\tstruct input_dev *old_dev, *new_dev;\n\tconst struct psmouse_protocol *proto, *old_proto;\n\tint error;\n\tint retry = 0;\n\n\tproto = psmouse_protocol_by_name(buf, count);\n\tif (!proto)\n\t\treturn -EINVAL;\n\n\tif (psmouse->protocol == proto)\n\t\treturn count;\n\n\tnew_dev = input_allocate_device();\n\tif (!new_dev)\n\t\treturn -ENOMEM;\n\n\twhile (!list_empty(&serio->children)) {\n\t\tif (++retry > 3) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"failed to destroy children ports, protocol change aborted.\\n\");\n\t\t\tinput_free_device(new_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tmutex_unlock(&psmouse_mutex);\n\t\tserio_unregister_child_port(serio);\n\t\tmutex_lock(&psmouse_mutex);\n\n\t\tif (serio->drv != &psmouse_drv) {\n\t\t\tinput_free_device(new_dev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (psmouse->protocol == proto) {\n\t\t\tinput_free_device(new_dev);\n\t\t\treturn count;  \n\t\t}\n\t}\n\n\tif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\n\t\tparent = psmouse_from_serio(serio->parent);\n\t\tif (parent->pt_deactivate)\n\t\t\tparent->pt_deactivate(parent);\n\t}\n\n\told_dev = psmouse->dev;\n\told_proto = psmouse->protocol;\n\n\tif (psmouse->disconnect)\n\t\tpsmouse->disconnect(psmouse);\n\n\tpsmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\n\tpsmouse->dev = new_dev;\n\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\n\tif (psmouse_switch_protocol(psmouse, proto) < 0) {\n\t\tpsmouse_reset(psmouse);\n\t\t \n\t\tpsmouse_switch_protocol(psmouse, &psmouse_protocols[0]);\n\t}\n\n\tpsmouse_initialize(psmouse);\n\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\n\tif (psmouse->protocol->smbus_companion) {\n\t\tinput_free_device(psmouse->dev);\n\t\tpsmouse->dev = NULL;\n\t} else {\n\t\terror = input_register_device(psmouse->dev);\n\t\tif (error) {\n\t\t\tif (psmouse->disconnect)\n\t\t\t\tpsmouse->disconnect(psmouse);\n\n\t\t\tpsmouse_set_state(psmouse, PSMOUSE_IGNORE);\n\t\t\tinput_free_device(new_dev);\n\t\t\tpsmouse->dev = old_dev;\n\t\t\tpsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\n\t\t\tpsmouse_switch_protocol(psmouse, old_proto);\n\t\t\tpsmouse_initialize(psmouse);\n\t\t\tpsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (old_dev)\n\t\tinput_unregister_device(old_dev);\n\n\tif (parent && parent->pt_activate)\n\t\tparent->pt_activate(parent);\n\n\treturn count;\n}\n\nstatic ssize_t psmouse_attr_set_rate(struct psmouse *psmouse, void *data, const char *buf, size_t count)\n{\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tpsmouse->set_rate(psmouse, value);\n\treturn count;\n}\n\nstatic ssize_t psmouse_attr_set_resolution(struct psmouse *psmouse, void *data, const char *buf, size_t count)\n{\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tpsmouse->set_resolution(psmouse, value);\n\treturn count;\n}\n\n\nstatic int psmouse_set_maxproto(const char *val, const struct kernel_param *kp)\n{\n\tconst struct psmouse_protocol *proto;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tproto = psmouse_protocol_by_name(val, strlen(val));\n\n\tif (!proto || !proto->maxproto)\n\t\treturn -EINVAL;\n\n\t*((unsigned int *)kp->arg) = proto->type;\n\n\treturn 0;\n}\n\nstatic int psmouse_get_maxproto(char *buffer, const struct kernel_param *kp)\n{\n\tint type = *((unsigned int *)kp->arg);\n\n\treturn sprintf(buffer, \"%s\\n\", psmouse_protocol_by_type(type)->name);\n}\n\nstatic int __init psmouse_init(void)\n{\n\tint err;\n\n\tlifebook_module_init();\n\tsynaptics_module_init();\n\thgpk_module_init();\n\n\terr = psmouse_smbus_module_init();\n\tif (err)\n\t\treturn err;\n\n\tkpsmoused_wq = alloc_ordered_workqueue(\"kpsmoused\", 0);\n\tif (!kpsmoused_wq) {\n\t\tpr_err(\"failed to create kpsmoused workqueue\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_smbus_exit;\n\t}\n\n\terr = serio_register_driver(&psmouse_drv);\n\tif (err)\n\t\tgoto err_destroy_wq;\n\n\treturn 0;\n\nerr_destroy_wq:\n\tdestroy_workqueue(kpsmoused_wq);\nerr_smbus_exit:\n\tpsmouse_smbus_module_exit();\n\treturn err;\n}\n\nstatic void __exit psmouse_exit(void)\n{\n\tserio_unregister_driver(&psmouse_drv);\n\tdestroy_workqueue(kpsmoused_wq);\n\tpsmouse_smbus_module_exit();\n}\n\nmodule_init(psmouse_init);\nmodule_exit(psmouse_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}