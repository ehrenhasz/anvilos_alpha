{
  "module_name": "lifebook.c",
  "hash_id": "9751ffad3f2c3323b259ae81515ba22e48c5a1d449b03de61274ce0d9e1d95f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/lifebook.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"psmouse.h\"\n#include \"lifebook.h\"\n\nstruct lifebook_data {\n\tstruct input_dev *dev2;\t\t \n\tchar phys[32];\n};\n\nstatic bool lifebook_present;\n\nstatic const char *desired_serio_phys;\n\nstatic int lifebook_limit_serio3(const struct dmi_system_id *d)\n{\n\tdesired_serio_phys = \"isa0060/serio3\";\n\treturn 1;\n}\n\nstatic bool lifebook_use_6byte_proto;\n\nstatic int lifebook_set_6byte_proto(const struct dmi_system_id *d)\n{\n\tlifebook_use_6byte_proto = true;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id lifebook_dmi_table[] __initconst = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"FLORA-ie 55mi\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Lifebook B Series\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook B Series\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK B Series\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ZEPHYR\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook B2131/B2133/B2150\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZEPHYR\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CF-18\"),\n\t\t},\n\t\t.callback = lifebook_limit_serio3,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Matsushita\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CF-28\"),\n\t\t},\n\t\t.callback = lifebook_set_6byte_proto,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Matsushita\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CF-29\"),\n\t\t},\n\t\t.callback = lifebook_set_6byte_proto,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CF-72\"),\n\t\t},\n\t\t.callback = lifebook_set_6byte_proto,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook B142\"),\n\t\t},\n\t},\n\t{ }\n};\n\nvoid __init lifebook_module_init(void)\n{\n\tlifebook_present = dmi_check_system(lifebook_dmi_table);\n}\n\nstatic psmouse_ret_t lifebook_process_byte(struct psmouse *psmouse)\n{\n\tstruct lifebook_data *priv = psmouse->private;\n\tstruct input_dev *dev1 = psmouse->dev;\n\tstruct input_dev *dev2 = priv ? priv->dev2 : NULL;\n\tu8 *packet = psmouse->packet;\n\tbool relative_packet = packet[0] & 0x08;\n\n\tif (relative_packet || !lifebook_use_6byte_proto) {\n\t\tif (psmouse->pktcnt != 3)\n\t\t\treturn PSMOUSE_GOOD_DATA;\n\t} else {\n\t\tswitch (psmouse->pktcnt) {\n\t\tcase 1:\n\t\t\treturn (packet[0] & 0xf8) == 0x00 ?\n\t\t\t\tPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\n\t\tcase 2:\n\t\t\treturn PSMOUSE_GOOD_DATA;\n\t\tcase 3:\n\t\t\treturn ((packet[2] & 0x30) << 2) == (packet[2] & 0xc0) ?\n\t\t\t\tPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\n\t\tcase 4:\n\t\t\treturn (packet[3] & 0xf8) == 0xc0 ?\n\t\t\t\tPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\n\t\tcase 5:\n\t\t\treturn (packet[4] & 0xc0) == (packet[2] & 0xc0) ?\n\t\t\t\tPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\n\t\tcase 6:\n\t\t\tif (((packet[5] & 0x30) << 2) != (packet[5] & 0xc0))\n\t\t\t\treturn PSMOUSE_BAD_DATA;\n\t\t\tif ((packet[5] & 0xc0) != (packet[1] & 0xc0))\n\t\t\t\treturn PSMOUSE_BAD_DATA;\n\t\t\tbreak;  \n\t\t}\n\t}\n\n\tif (relative_packet) {\n\t\tif (!dev2)\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"got relative packet but no relative device set up\\n\");\n\t} else {\n\t\tif (lifebook_use_6byte_proto) {\n\t\t\tinput_report_abs(dev1, ABS_X,\n\t\t\t\t((packet[1] & 0x3f) << 6) | (packet[2] & 0x3f));\n\t\t\tinput_report_abs(dev1, ABS_Y,\n\t\t\t\t4096 - (((packet[4] & 0x3f) << 6) | (packet[5] & 0x3f)));\n\t\t} else {\n\t\t\tinput_report_abs(dev1, ABS_X,\n\t\t\t\t(packet[1] | ((packet[0] & 0x30) << 4)));\n\t\t\tinput_report_abs(dev1, ABS_Y,\n\t\t\t\t1024 - (packet[2] | ((packet[0] & 0xC0) << 2)));\n\t\t}\n\t\tinput_report_key(dev1, BTN_TOUCH, packet[0] & 0x04);\n\t\tinput_sync(dev1);\n\t}\n\n\tif (dev2) {\n\t\tif (relative_packet)\n\t\t\tpsmouse_report_standard_motion(dev2, packet);\n\n\t\tpsmouse_report_standard_buttons(dev2, packet[0]);\n\t\tinput_sync(dev2);\n\t}\n\n\treturn PSMOUSE_FULL_PACKET;\n}\n\nstatic int lifebook_absolute_mode(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param;\n\tint error;\n\n\terror = psmouse_reset(psmouse);\n\tif (error)\n\t\treturn error;\n\n\t \n\tparam = lifebook_use_6byte_proto ? 0x08 : 0x07;\n\tps2_command(ps2dev, &param, PSMOUSE_CMD_SETRES);\n\n\treturn 0;\n}\n\nstatic void lifebook_relative_mode(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tu8 param = 0x06;\n\n\tps2_command(ps2dev, &param, PSMOUSE_CMD_SETRES);\n}\n\nstatic void lifebook_set_resolution(struct psmouse *psmouse, unsigned int resolution)\n{\n\tstatic const u8 params[] = { 0, 1, 2, 2, 3 };\n\tu8 p;\n\n\tif (resolution == 0 || resolution > 400)\n\t\tresolution = 400;\n\n\tp = params[resolution / 100];\n\tps2_command(&psmouse->ps2dev, &p, PSMOUSE_CMD_SETRES);\n\tpsmouse->resolution = 50 << p;\n}\n\nstatic void lifebook_disconnect(struct psmouse *psmouse)\n{\n\tstruct lifebook_data *priv = psmouse->private;\n\n\tpsmouse_reset(psmouse);\n\tif (priv) {\n\t\tinput_unregister_device(priv->dev2);\n\t\tkfree(priv);\n\t}\n\tpsmouse->private = NULL;\n}\n\nint lifebook_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tif (!lifebook_present)\n\t\treturn -ENXIO;\n\n\tif (desired_serio_phys &&\n\t    strcmp(psmouse->ps2dev.serio->phys, desired_serio_phys))\n\t\treturn -ENXIO;\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"Fujitsu\";\n\t\tpsmouse->name = \"Lifebook TouchScreen\";\n\t}\n\n\treturn 0;\n}\n\nstatic int lifebook_create_relative_device(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev2;\n\tstruct lifebook_data *priv;\n\tint error = -ENOMEM;\n\n\tpriv = kzalloc(sizeof(struct lifebook_data), GFP_KERNEL);\n\tdev2 = input_allocate_device();\n\tif (!priv || !dev2)\n\t\tgoto err_out;\n\n\tpriv->dev2 = dev2;\n\tsnprintf(priv->phys, sizeof(priv->phys),\n\t\t \"%s/input1\", psmouse->ps2dev.serio->phys);\n\n\tdev2->phys = priv->phys;\n\tdev2->name = \"LBPS/2 Fujitsu Lifebook Touchpad\";\n\tdev2->id.bustype = BUS_I8042;\n\tdev2->id.vendor  = 0x0002;\n\tdev2->id.product = PSMOUSE_LIFEBOOK;\n\tdev2->id.version = 0x0000;\n\tdev2->dev.parent = &psmouse->ps2dev.serio->dev;\n\n\tinput_set_capability(dev2, EV_REL, REL_X);\n\tinput_set_capability(dev2, EV_REL, REL_Y);\n\tinput_set_capability(dev2, EV_KEY, BTN_LEFT);\n\tinput_set_capability(dev2, EV_KEY, BTN_RIGHT);\n\n\terror = input_register_device(priv->dev2);\n\tif (error)\n\t\tgoto err_out;\n\n\tpsmouse->private = priv;\n\treturn 0;\n\n err_out:\n\tinput_free_device(dev2);\n\tkfree(priv);\n\treturn error;\n}\n\nint lifebook_init(struct psmouse *psmouse)\n{\n\tstruct input_dev *dev1 = psmouse->dev;\n\tint max_coord = lifebook_use_6byte_proto ? 4096 : 1024;\n\tint error;\n\n\terror = lifebook_absolute_mode(psmouse);\n\tif (error)\n\t\treturn error;\n\n\t \n\tbitmap_zero(dev1->evbit, EV_CNT);\n\tbitmap_zero(dev1->relbit, REL_CNT);\n\tbitmap_zero(dev1->keybit, KEY_CNT);\n\n\tinput_set_capability(dev1, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(dev1, ABS_X, 0, max_coord, 0, 0);\n\tinput_set_abs_params(dev1, ABS_Y, 0, max_coord, 0, 0);\n\n\tif (!desired_serio_phys) {\n\t\terror = lifebook_create_relative_device(psmouse);\n\t\tif (error) {\n\t\t\tlifebook_relative_mode(psmouse);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tpsmouse->protocol_handler = lifebook_process_byte;\n\tpsmouse->set_resolution = lifebook_set_resolution;\n\tpsmouse->disconnect = lifebook_disconnect;\n\tpsmouse->reconnect  = lifebook_absolute_mode;\n\n\tpsmouse->model = lifebook_use_6byte_proto ? 6 : 3;\n\n\t \n\tpsmouse->pktsize = 3;\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}