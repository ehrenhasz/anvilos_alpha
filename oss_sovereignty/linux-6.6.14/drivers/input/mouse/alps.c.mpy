{
  "module_name": "alps.c",
  "hash_id": "1687794793b04a6ec0c2247c3a88442d3e295e4c5e4ad5b5e32f969d9bcd591a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mouse/alps.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/serio.h>\n#include <linux/libps2.h>\n#include <linux/dmi.h>\n\n#include \"psmouse.h\"\n#include \"alps.h\"\n#include \"trackpoint.h\"\n\n \n#define ALPS_CMD_NIBBLE_10\t0x01f2\n\n#define ALPS_REG_BASE_RUSHMORE\t0xc2c0\n#define ALPS_REG_BASE_V7\t0xc2c0\n#define ALPS_REG_BASE_PINNACLE\t0x0000\n\nstatic const struct alps_nibble_commands alps_v3_nibble_commands[] = {\n\t{ PSMOUSE_CMD_SETPOLL,\t\t0x00 },  \n\t{ PSMOUSE_CMD_RESET_DIS,\t0x00 },  \n\t{ PSMOUSE_CMD_SETSCALE21,\t0x00 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x0a },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x14 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x28 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x3c },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x50 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x64 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0xc8 },  \n\t{ ALPS_CMD_NIBBLE_10,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x01 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x02 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x03 },  \n\t{ PSMOUSE_CMD_SETSCALE11,\t0x00 },  \n};\n\nstatic const struct alps_nibble_commands alps_v4_nibble_commands[] = {\n\t{ PSMOUSE_CMD_ENABLE,\t\t0x00 },  \n\t{ PSMOUSE_CMD_RESET_DIS,\t0x00 },  \n\t{ PSMOUSE_CMD_SETSCALE21,\t0x00 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x0a },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x14 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x28 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x3c },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x50 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x64 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0xc8 },  \n\t{ ALPS_CMD_NIBBLE_10,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x01 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x02 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x03 },  \n\t{ PSMOUSE_CMD_SETSCALE11,\t0x00 },  \n};\n\nstatic const struct alps_nibble_commands alps_v6_nibble_commands[] = {\n\t{ PSMOUSE_CMD_ENABLE,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x0a },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x14 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x28 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x3c },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x50 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0x64 },  \n\t{ PSMOUSE_CMD_SETRATE,\t\t0xc8 },  \n\t{ PSMOUSE_CMD_GETID,\t\t0x00 },  \n\t{ PSMOUSE_CMD_GETINFO,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x00 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x01 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x02 },  \n\t{ PSMOUSE_CMD_SETRES,\t\t0x03 },  \n\t{ PSMOUSE_CMD_SETSCALE21,\t0x00 },  \n\t{ PSMOUSE_CMD_SETSCALE11,\t0x00 },  \n};\n\n\n#define ALPS_DUALPOINT\t\t0x02\t \n#define ALPS_PASS\t\t0x04\t \n\n#define ALPS_WHEEL\t\t0x08\t \n#define ALPS_FW_BK_1\t\t0x10\t \n#define ALPS_FW_BK_2\t\t0x20\t \n#define ALPS_FOUR_BUTTONS\t0x40\t \n#define ALPS_PS2_INTERLEAVED\t0x80\t \n#define ALPS_STICK_BITS\t\t0x100\t \n#define ALPS_BUTTONPAD\t\t0x200\t \n#define ALPS_DUALPOINT_WITH_PRESSURE\t0x400\t \n\nstatic const struct alps_model_info alps_model_data[] = {\n\t \n\t{ { 0x20, 0x02, 0x0e }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT } },\n\n\t{ { 0x22, 0x02, 0x0a }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT } },\n\t{ { 0x22, 0x02, 0x14 }, { ALPS_PROTO_V2, 0xff, 0xff, ALPS_PASS | ALPS_DUALPOINT } },\t \n\t{ { 0x32, 0x02, 0x14 }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT } },\t \n\t{ { 0x33, 0x02, 0x0a }, { ALPS_PROTO_V1, 0x88, 0xf8, 0 } },\t\t\t\t \n\t{ { 0x52, 0x01, 0x14 }, { ALPS_PROTO_V2, 0xff, 0xff,\n\t\tALPS_PASS | ALPS_DUALPOINT | ALPS_PS2_INTERLEAVED } },\t\t\t\t \n\t{ { 0x53, 0x02, 0x0a }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\n\t{ { 0x53, 0x02, 0x14 }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\n\t{ { 0x60, 0x03, 0xc8 }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\t\t\t\t \n\t{ { 0x62, 0x02, 0x14 }, { ALPS_PROTO_V2, 0xcf, 0xcf,\n\t\tALPS_PASS | ALPS_DUALPOINT | ALPS_PS2_INTERLEAVED } },\t\t\t\t \n\t{ { 0x63, 0x02, 0x0a }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\n\t{ { 0x63, 0x02, 0x14 }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\n\t{ { 0x63, 0x02, 0x28 }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_FW_BK_2 } },\t\t\t \n\t{ { 0x63, 0x02, 0x3c }, { ALPS_PROTO_V2, 0x8f, 0x8f, ALPS_WHEEL } },\t\t\t \n\t{ { 0x63, 0x02, 0x50 }, { ALPS_PROTO_V2, 0xef, 0xef, ALPS_FW_BK_1 } },\t\t\t \n\t{ { 0x63, 0x02, 0x64 }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\n\t{ { 0x63, 0x03, 0xc8 }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT } },\t \n\t{ { 0x73, 0x00, 0x0a }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_DUALPOINT } },\t\t \n\t{ { 0x73, 0x00, 0x14 }, { ALPS_PROTO_V6, 0xff, 0xff, ALPS_DUALPOINT } },\t\t \n\t{ { 0x73, 0x02, 0x0a }, { ALPS_PROTO_V2, 0xf8, 0xf8, 0 } },\n\t{ { 0x73, 0x02, 0x14 }, { ALPS_PROTO_V2, 0xf8, 0xf8, ALPS_FW_BK_2 } },\t\t\t \n\t{ { 0x73, 0x02, 0x50 }, { ALPS_PROTO_V2, 0xcf, 0xcf, ALPS_FOUR_BUTTONS } },\t\t \n};\n\nstatic const struct alps_protocol_info alps_v3_protocol_data = {\n\tALPS_PROTO_V3, 0x8f, 0x8f, ALPS_DUALPOINT | ALPS_DUALPOINT_WITH_PRESSURE\n};\n\nstatic const struct alps_protocol_info alps_v3_rushmore_data = {\n\tALPS_PROTO_V3_RUSHMORE, 0x8f, 0x8f, ALPS_DUALPOINT | ALPS_DUALPOINT_WITH_PRESSURE\n};\n\nstatic const struct alps_protocol_info alps_v4_protocol_data = {\n\tALPS_PROTO_V4, 0x8f, 0x8f, 0\n};\n\nstatic const struct alps_protocol_info alps_v5_protocol_data = {\n\tALPS_PROTO_V5, 0xc8, 0xd8, 0\n};\n\nstatic const struct alps_protocol_info alps_v7_protocol_data = {\n\tALPS_PROTO_V7, 0x48, 0x48, ALPS_DUALPOINT | ALPS_DUALPOINT_WITH_PRESSURE\n};\n\nstatic const struct alps_protocol_info alps_v8_protocol_data = {\n\tALPS_PROTO_V8, 0x18, 0x18, 0\n};\n\nstatic const struct alps_protocol_info alps_v9_protocol_data = {\n\tALPS_PROTO_V9, 0xc8, 0xc8, 0\n};\n\n \nstatic const struct dmi_system_id alps_dmi_has_separate_stick_buttons[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude D420\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude D430\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude D620\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude D630\"),\n\t\t},\n\t},\n#endif\n\t{ }\n};\n\nstatic void alps_set_abs_params_st(struct alps_data *priv,\n\t\t\t\t   struct input_dev *dev1);\nstatic void alps_set_abs_params_semi_mt(struct alps_data *priv,\n\t\t\t\t\tstruct input_dev *dev1);\nstatic void alps_set_abs_params_v7(struct alps_data *priv,\n\t\t\t\t   struct input_dev *dev1);\nstatic void alps_set_abs_params_ss4_v2(struct alps_data *priv,\n\t\t\t\t       struct input_dev *dev1);\n\n \n\nstatic bool alps_is_valid_first_byte(struct alps_data *priv,\n\t\t\t\t     unsigned char data)\n{\n\treturn (data & priv->mask0) == priv->byte0;\n}\n\nstatic void alps_report_buttons(struct input_dev *dev1, struct input_dev *dev2,\n\t\t\t\tint left, int right, int middle)\n{\n\tstruct input_dev *dev;\n\n\t \n\tdev = (dev2 && test_bit(BTN_LEFT, dev2->key)) ? dev2 : dev1;\n\tinput_report_key(dev, BTN_LEFT, left);\n\n\tdev = (dev2 && test_bit(BTN_RIGHT, dev2->key)) ? dev2 : dev1;\n\tinput_report_key(dev, BTN_RIGHT, right);\n\n\tdev = (dev2 && test_bit(BTN_MIDDLE, dev2->key)) ? dev2 : dev1;\n\tinput_report_key(dev, BTN_MIDDLE, middle);\n\n\t \n\tif (dev2)\n\t\tinput_sync(dev2);\n}\n\nstatic void alps_process_packet_v1_v2(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct input_dev *dev2 = priv->dev2;\n\tint x, y, z, ges, fin, left, right, middle;\n\tint back = 0, forward = 0;\n\n\tif (priv->proto_version == ALPS_PROTO_V1) {\n\t\tleft = packet[2] & 0x10;\n\t\tright = packet[2] & 0x08;\n\t\tmiddle = 0;\n\t\tx = packet[1] | ((packet[0] & 0x07) << 7);\n\t\ty = packet[4] | ((packet[3] & 0x07) << 7);\n\t\tz = packet[5];\n\t} else {\n\t\tleft = packet[3] & 1;\n\t\tright = packet[3] & 2;\n\t\tmiddle = packet[3] & 4;\n\t\tx = packet[1] | ((packet[2] & 0x78) << (7 - 3));\n\t\ty = packet[4] | ((packet[3] & 0x70) << (7 - 4));\n\t\tz = packet[5];\n\t}\n\n\tif (priv->flags & ALPS_FW_BK_1) {\n\t\tback = packet[0] & 0x10;\n\t\tforward = packet[2] & 4;\n\t}\n\n\tif (priv->flags & ALPS_FW_BK_2) {\n\t\tback = packet[3] & 4;\n\t\tforward = packet[2] & 4;\n\t\tif ((middle = forward && back))\n\t\t\tforward = back = 0;\n\t}\n\n\tges = packet[2] & 1;\n\tfin = packet[2] & 2;\n\n\tif ((priv->flags & ALPS_DUALPOINT) && z == 127) {\n\t\tinput_report_rel(dev2, REL_X,  (x > 383 ? (x - 768) : x));\n\t\tinput_report_rel(dev2, REL_Y, -(y > 255 ? (y - 512) : y));\n\n\t\talps_report_buttons(dev2, dev, left, right, middle);\n\n\t\tinput_sync(dev2);\n\t\treturn;\n\t}\n\n\t \n\tif (priv->flags & ALPS_STICK_BITS) {\n\t\tleft |= packet[0] & 1;\n\t\tright |= packet[0] & 2;\n\t\tmiddle |= packet[0] & 4;\n\t}\n\n\talps_report_buttons(dev, dev2, left, right, middle);\n\n\t \n\tif (ges && !fin)\n\t\tz = 40;\n\n\t \n\tif (ges && fin && !priv->prev_fin) {\n\t\tinput_report_abs(dev, ABS_X, x);\n\t\tinput_report_abs(dev, ABS_Y, y);\n\t\tinput_report_abs(dev, ABS_PRESSURE, 0);\n\t\tinput_report_key(dev, BTN_TOOL_FINGER, 0);\n\t\tinput_sync(dev);\n\t}\n\tpriv->prev_fin = fin;\n\n\tif (z > 30)\n\t\tinput_report_key(dev, BTN_TOUCH, 1);\n\tif (z < 25)\n\t\tinput_report_key(dev, BTN_TOUCH, 0);\n\n\tif (z > 0) {\n\t\tinput_report_abs(dev, ABS_X, x);\n\t\tinput_report_abs(dev, ABS_Y, y);\n\t}\n\n\tinput_report_abs(dev, ABS_PRESSURE, z);\n\tinput_report_key(dev, BTN_TOOL_FINGER, z > 0);\n\n\tif (priv->flags & ALPS_WHEEL)\n\t\tinput_report_rel(dev, REL_WHEEL, ((packet[2] << 1) & 0x08) - ((packet[0] >> 4) & 0x07));\n\n\tif (priv->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\n\t\tinput_report_key(dev, BTN_FORWARD, forward);\n\t\tinput_report_key(dev, BTN_BACK, back);\n\t}\n\n\tif (priv->flags & ALPS_FOUR_BUTTONS) {\n\t\tinput_report_key(dev, BTN_0, packet[2] & 4);\n\t\tinput_report_key(dev, BTN_1, packet[0] & 0x10);\n\t\tinput_report_key(dev, BTN_2, packet[3] & 4);\n\t\tinput_report_key(dev, BTN_3, packet[0] & 0x20);\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic void alps_get_bitmap_points(unsigned int map,\n\t\t\t\t   struct alps_bitmap_point *low,\n\t\t\t\t   struct alps_bitmap_point *high,\n\t\t\t\t   int *fingers)\n{\n\tstruct alps_bitmap_point *point;\n\tint i, bit, prev_bit = 0;\n\n\tpoint = low;\n\tfor (i = 0; map != 0; i++, map >>= 1) {\n\t\tbit = map & 1;\n\t\tif (bit) {\n\t\t\tif (!prev_bit) {\n\t\t\t\tpoint->start_bit = i;\n\t\t\t\tpoint->num_bits = 0;\n\t\t\t\t(*fingers)++;\n\t\t\t}\n\t\t\tpoint->num_bits++;\n\t\t} else {\n\t\t\tif (prev_bit)\n\t\t\t\tpoint = high;\n\t\t}\n\t\tprev_bit = bit;\n\t}\n}\n\n \nstatic int alps_process_bitmap(struct alps_data *priv,\n\t\t\t       struct alps_fields *fields)\n{\n\tint i, fingers_x = 0, fingers_y = 0, fingers, closest;\n\tstruct alps_bitmap_point x_low = {0,}, x_high = {0,};\n\tstruct alps_bitmap_point y_low = {0,}, y_high = {0,};\n\tstruct input_mt_pos corner[4];\n\n\tif (!fields->x_map || !fields->y_map)\n\t\treturn 0;\n\n\talps_get_bitmap_points(fields->x_map, &x_low, &x_high, &fingers_x);\n\talps_get_bitmap_points(fields->y_map, &y_low, &y_high, &fingers_y);\n\n\t \n\tfingers = max(fingers_x, fingers_y);\n\n\t \n\tif (fingers_x == 1) {\n\t\ti = (x_low.num_bits - 1) / 2;\n\t\tx_low.num_bits = x_low.num_bits - i;\n\t\tx_high.start_bit = x_low.start_bit + i;\n\t\tx_high.num_bits = max(i, 1);\n\t}\n\tif (fingers_y == 1) {\n\t\ti = (y_low.num_bits - 1) / 2;\n\t\ty_low.num_bits = y_low.num_bits - i;\n\t\ty_high.start_bit = y_low.start_bit + i;\n\t\ty_high.num_bits = max(i, 1);\n\t}\n\n\t \n\tcorner[0].x =\n\t\t(priv->x_max * (2 * x_low.start_bit + x_low.num_bits - 1)) /\n\t\t(2 * (priv->x_bits - 1));\n\tcorner[0].y =\n\t\t(priv->y_max * (2 * y_low.start_bit + y_low.num_bits - 1)) /\n\t\t(2 * (priv->y_bits - 1));\n\n\t \n\tcorner[1].x =\n\t\t(priv->x_max * (2 * x_high.start_bit + x_high.num_bits - 1)) /\n\t\t(2 * (priv->x_bits - 1));\n\tcorner[1].y =\n\t\t(priv->y_max * (2 * y_low.start_bit + y_low.num_bits - 1)) /\n\t\t(2 * (priv->y_bits - 1));\n\n\t \n\tcorner[2].x =\n\t\t(priv->x_max * (2 * x_high.start_bit + x_high.num_bits - 1)) /\n\t\t(2 * (priv->x_bits - 1));\n\tcorner[2].y =\n\t\t(priv->y_max * (2 * y_high.start_bit + y_high.num_bits - 1)) /\n\t\t(2 * (priv->y_bits - 1));\n\n\t \n\tcorner[3].x =\n\t\t(priv->x_max * (2 * x_low.start_bit + x_low.num_bits - 1)) /\n\t\t(2 * (priv->x_bits - 1));\n\tcorner[3].y =\n\t\t(priv->y_max * (2 * y_high.start_bit + y_high.num_bits - 1)) /\n\t\t(2 * (priv->y_bits - 1));\n\n\t \n\tif (priv->proto_version == ALPS_PROTO_V5) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tcorner[i].x = priv->x_max - corner[i].x;\n\t}\n\n\t \n\tif (priv->proto_version == ALPS_PROTO_V3 ||\n\t    priv->proto_version == ALPS_PROTO_V4) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tcorner[i].y = priv->y_max - corner[i].y;\n\t}\n\n\t \n\tif (priv->second_touch == -1) {\n\t\t \n\t\tclosest = 0x7fffffff;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint dx = fields->st.x - corner[i].x;\n\t\t\tint dy = fields->st.y - corner[i].y;\n\t\t\tint distance = dx * dx + dy * dy;\n\n\t\t\tif (distance < closest) {\n\t\t\t\tpriv->second_touch = i;\n\t\t\t\tclosest = distance;\n\t\t\t}\n\t\t}\n\t\t \n\t\tpriv->second_touch = (priv->second_touch + 2) % 4;\n\t}\n\n\tfields->mt[0] = fields->st;\n\tfields->mt[1] = corner[priv->second_touch];\n\n\treturn fingers;\n}\n\nstatic void alps_set_slot(struct input_dev *dev, int slot, int x, int y)\n{\n\tinput_mt_slot(dev, slot);\n\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, true);\n\tinput_report_abs(dev, ABS_MT_POSITION_X, x);\n\tinput_report_abs(dev, ABS_MT_POSITION_Y, y);\n}\n\nstatic void alps_report_mt_data(struct psmouse *psmouse, int n)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct alps_fields *f = &priv->f;\n\tint i, slot[MAX_TOUCHES];\n\n\tinput_mt_assign_slots(dev, slot, f->mt, n, 0);\n\tfor (i = 0; i < n; i++)\n\t\talps_set_slot(dev, slot[i], f->mt[i].x, f->mt[i].y);\n\n\tinput_mt_sync_frame(dev);\n}\n\nstatic void alps_report_semi_mt_data(struct psmouse *psmouse, int fingers)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct alps_fields *f = &priv->f;\n\n\t \n\tif (fingers < 2) {\n\t\tf->mt[0].x = f->st.x;\n\t\tf->mt[0].y = f->st.y;\n\t\tfingers = f->pressure > 0 ? 1 : 0;\n\t\tpriv->second_touch = -1;\n\t}\n\n\tif (fingers >= 1)\n\t\talps_set_slot(dev, 0, f->mt[0].x, f->mt[0].y);\n\tif (fingers >= 2)\n\t\talps_set_slot(dev, 1, f->mt[1].x, f->mt[1].y);\n\tinput_mt_sync_frame(dev);\n\n\tinput_mt_report_finger_count(dev, fingers);\n\n\tinput_report_key(dev, BTN_LEFT, f->left);\n\tinput_report_key(dev, BTN_RIGHT, f->right);\n\tinput_report_key(dev, BTN_MIDDLE, f->middle);\n\n\tinput_report_abs(dev, ABS_PRESSURE, f->pressure);\n\n\tinput_sync(dev);\n}\n\nstatic void alps_process_trackstick_packet_v3(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct input_dev *dev = priv->dev2;\n\tint x, y, z, left, right, middle;\n\n\t \n\tif (!(priv->flags & ALPS_DUALPOINT)) {\n\t\tpsmouse_warn(psmouse,\n\t\t\t     \"Rejected trackstick packet from non DualPoint device\");\n\t\treturn;\n\t}\n\n\t \n\tif (!(packet[0] & 0x40)) {\n\t\tpsmouse_dbg(psmouse, \"Bad trackstick packet, discarding\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (packet[1] == 0x7f && packet[2] == 0x7f && packet[4] == 0x7f)\n\t\treturn;\n\n\tx = (s8)(((packet[0] & 0x20) << 2) | (packet[1] & 0x7f));\n\ty = (s8)(((packet[0] & 0x10) << 3) | (packet[2] & 0x7f));\n\tz = packet[4] & 0x7f;\n\n\t \n\tx /= 8;\n\ty /= 8;\n\n\tinput_report_rel(dev, REL_X, x);\n\tinput_report_rel(dev, REL_Y, -y);\n\tinput_report_abs(dev, ABS_PRESSURE, z);\n\n\t \n\tleft = packet[3] & 0x01;\n\tright = packet[3] & 0x02;\n\tmiddle = packet[3] & 0x04;\n\n\tif (!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) &&\n\t    (left || right || middle))\n\t\tpriv->quirks |= ALPS_QUIRK_TRACKSTICK_BUTTONS;\n\n\tif (priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) {\n\t\tinput_report_key(dev, BTN_LEFT, left);\n\t\tinput_report_key(dev, BTN_RIGHT, right);\n\t\tinput_report_key(dev, BTN_MIDDLE, middle);\n\t}\n\n\tinput_sync(dev);\n\treturn;\n}\n\nstatic void alps_decode_buttons_v3(struct alps_fields *f, unsigned char *p)\n{\n\tf->left = !!(p[3] & 0x01);\n\tf->right = !!(p[3] & 0x02);\n\tf->middle = !!(p[3] & 0x04);\n\n\tf->ts_left = !!(p[3] & 0x10);\n\tf->ts_right = !!(p[3] & 0x20);\n\tf->ts_middle = !!(p[3] & 0x40);\n}\n\nstatic int alps_decode_pinnacle(struct alps_fields *f, unsigned char *p,\n\t\t\t\t struct psmouse *psmouse)\n{\n\tf->first_mp = !!(p[4] & 0x40);\n\tf->is_mp = !!(p[0] & 0x40);\n\n\tif (f->is_mp) {\n\t\tf->fingers = (p[5] & 0x3) + 1;\n\t\tf->x_map = ((p[4] & 0x7e) << 8) |\n\t\t\t   ((p[1] & 0x7f) << 2) |\n\t\t\t   ((p[0] & 0x30) >> 4);\n\t\tf->y_map = ((p[3] & 0x70) << 4) |\n\t\t\t   ((p[2] & 0x7f) << 1) |\n\t\t\t   (p[4] & 0x01);\n\t} else {\n\t\tf->st.x = ((p[1] & 0x7f) << 4) | ((p[4] & 0x30) >> 2) |\n\t\t       ((p[0] & 0x30) >> 4);\n\t\tf->st.y = ((p[2] & 0x7f) << 4) | (p[4] & 0x0f);\n\t\tf->pressure = p[5] & 0x7f;\n\n\t\talps_decode_buttons_v3(f, p);\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_decode_rushmore(struct alps_fields *f, unsigned char *p,\n\t\t\t\t struct psmouse *psmouse)\n{\n\tf->first_mp = !!(p[4] & 0x40);\n\tf->is_mp = !!(p[5] & 0x40);\n\n\tif (f->is_mp) {\n\t\tf->fingers = max((p[5] & 0x3), ((p[5] >> 2) & 0x3)) + 1;\n\t\tf->x_map = ((p[5] & 0x10) << 11) |\n\t\t\t   ((p[4] & 0x7e) << 8) |\n\t\t\t   ((p[1] & 0x7f) << 2) |\n\t\t\t   ((p[0] & 0x30) >> 4);\n\t\tf->y_map = ((p[5] & 0x20) << 6) |\n\t\t\t   ((p[3] & 0x70) << 4) |\n\t\t\t   ((p[2] & 0x7f) << 1) |\n\t\t\t   (p[4] & 0x01);\n\t} else {\n\t\tf->st.x = ((p[1] & 0x7f) << 4) | ((p[4] & 0x30) >> 2) |\n\t\t       ((p[0] & 0x30) >> 4);\n\t\tf->st.y = ((p[2] & 0x7f) << 4) | (p[4] & 0x0f);\n\t\tf->pressure = p[5] & 0x7f;\n\n\t\talps_decode_buttons_v3(f, p);\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_decode_dolphin(struct alps_fields *f, unsigned char *p,\n\t\t\t\tstruct psmouse *psmouse)\n{\n\tu64 palm_data = 0;\n\tstruct alps_data *priv = psmouse->private;\n\n\tf->first_mp = !!(p[0] & 0x02);\n\tf->is_mp = !!(p[0] & 0x20);\n\n\tif (!f->is_mp) {\n\t\tf->st.x = ((p[1] & 0x7f) | ((p[4] & 0x0f) << 7));\n\t\tf->st.y = ((p[2] & 0x7f) | ((p[4] & 0xf0) << 3));\n\t\tf->pressure = (p[0] & 4) ? 0 : p[5] & 0x7f;\n\t\talps_decode_buttons_v3(f, p);\n\t} else {\n\t\tf->fingers = ((p[0] & 0x6) >> 1 |\n\t\t     (p[0] & 0x10) >> 2);\n\n\t\tpalm_data = (p[1] & 0x7f) |\n\t\t\t    ((p[2] & 0x7f) << 7) |\n\t\t\t    ((p[4] & 0x7f) << 14) |\n\t\t\t    ((p[5] & 0x7f) << 21) |\n\t\t\t    ((p[3] & 0x07) << 28) |\n\t\t\t    (((u64)p[3] & 0x70) << 27) |\n\t\t\t    (((u64)p[0] & 0x01) << 34);\n\n\t\t \n\t\tf->y_map = palm_data & (BIT(priv->y_bits) - 1);\n\n\t\t \n\t\tf->x_map = (palm_data >> priv->y_bits) &\n\t\t\t   (BIT(priv->x_bits) - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void alps_process_touchpad_packet_v3_v5(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct input_dev *dev2 = priv->dev2;\n\tstruct alps_fields *f = &priv->f;\n\tint fingers = 0;\n\n\tmemset(f, 0, sizeof(*f));\n\n\tpriv->decode_fields(f, packet, psmouse);\n\n\t \n\tif (priv->multi_packet) {\n\t\t \n\t\tif (f->is_mp) {\n\t\t\tfingers = f->fingers;\n\t\t\t \n\t\t\tpriv->decode_fields(f, priv->multi_data, psmouse);\n\t\t\tif (alps_process_bitmap(priv, f) == 0)\n\t\t\t\tfingers = 0;  \n\t\t} else {\n\t\t\tpriv->multi_packet = 0;\n\t\t}\n\t}\n\n\t \n\tif (f->is_mp)\n\t\treturn;\n\n\tif (!priv->multi_packet && f->first_mp) {\n\t\tpriv->multi_packet = 1;\n\t\tmemcpy(priv->multi_data, packet, sizeof(priv->multi_data));\n\t\treturn;\n\t}\n\n\tpriv->multi_packet = 0;\n\n\t \n\tif (f->st.x && f->st.y && !f->pressure)\n\t\treturn;\n\n\talps_report_semi_mt_data(psmouse, fingers);\n\n\tif ((priv->flags & ALPS_DUALPOINT) &&\n\t    !(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS)) {\n\t\tinput_report_key(dev2, BTN_LEFT, f->ts_left);\n\t\tinput_report_key(dev2, BTN_RIGHT, f->ts_right);\n\t\tinput_report_key(dev2, BTN_MIDDLE, f->ts_middle);\n\t\tinput_sync(dev2);\n\t}\n}\n\nstatic void alps_process_packet_v3(struct psmouse *psmouse)\n{\n\tunsigned char *packet = psmouse->packet;\n\n\t \n\tif (packet[5] == 0x3f) {\n\t\talps_process_trackstick_packet_v3(psmouse);\n\t\treturn;\n\t}\n\n\talps_process_touchpad_packet_v3_v5(psmouse);\n}\n\nstatic void alps_process_packet_v6(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct input_dev *dev2 = priv->dev2;\n\tint x, y, z;\n\n\t \n\tif (packet[5] == 0x7F) {\n\t\t \n\t\tif (!(priv->flags & ALPS_DUALPOINT)) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"Rejected trackstick packet from non DualPoint device\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tx = packet[1] | ((packet[3] & 0x20) << 2);\n\t\ty = packet[2] | ((packet[3] & 0x40) << 1);\n\t\tz = packet[4];\n\n\t\t \n\t\tif (x == 0x7F && y == 0x7F && z == 0x7F)\n\t\t\tx = y = z = 0;\n\n\t\t \n\t\tinput_report_rel(dev2, REL_X, (s8)x / 4);\n\t\tinput_report_rel(dev2, REL_Y, -((s8)y / 4));\n\n\t\tpsmouse_report_standard_buttons(dev2, packet[3]);\n\n\t\tinput_sync(dev2);\n\t\treturn;\n\t}\n\n\t \n\tx = packet[1] | ((packet[3] & 0x78) << 4);\n\ty = packet[2] | ((packet[4] & 0x78) << 4);\n\tz = packet[5];\n\n\tif (z > 30)\n\t\tinput_report_key(dev, BTN_TOUCH, 1);\n\tif (z < 25)\n\t\tinput_report_key(dev, BTN_TOUCH, 0);\n\n\tif (z > 0) {\n\t\tinput_report_abs(dev, ABS_X, x);\n\t\tinput_report_abs(dev, ABS_Y, y);\n\t}\n\n\tinput_report_abs(dev, ABS_PRESSURE, z);\n\tinput_report_key(dev, BTN_TOOL_FINGER, z > 0);\n\n\t \n\tpacket[3] &= ~BIT(2);\n\tpsmouse_report_standard_buttons(dev2, packet[3]);\n\n\tinput_sync(dev);\n}\n\nstatic void alps_process_packet_v4(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct alps_fields *f = &priv->f;\n\tint offset;\n\n\t \n\tif (packet[6] & 0x40) {\n\t\t \n\t\tpriv->multi_packet = 0;\n\t}\n\n\tif (WARN_ON_ONCE(priv->multi_packet > 2))\n\t\treturn;\n\n\toffset = 2 * priv->multi_packet;\n\tpriv->multi_data[offset] = packet[6];\n\tpriv->multi_data[offset + 1] = packet[7];\n\n\tf->left = !!(packet[4] & 0x01);\n\tf->right = !!(packet[4] & 0x02);\n\n\tf->st.x = ((packet[1] & 0x7f) << 4) | ((packet[3] & 0x30) >> 2) |\n\t\t  ((packet[0] & 0x30) >> 4);\n\tf->st.y = ((packet[2] & 0x7f) << 4) | (packet[3] & 0x0f);\n\tf->pressure = packet[5] & 0x7f;\n\n\tif (++priv->multi_packet > 2) {\n\t\tpriv->multi_packet = 0;\n\n\t\tf->x_map = ((priv->multi_data[2] & 0x1f) << 10) |\n\t\t\t   ((priv->multi_data[3] & 0x60) << 3) |\n\t\t\t   ((priv->multi_data[0] & 0x3f) << 2) |\n\t\t\t   ((priv->multi_data[1] & 0x60) >> 5);\n\t\tf->y_map = ((priv->multi_data[5] & 0x01) << 10) |\n\t\t\t   ((priv->multi_data[3] & 0x1f) << 5) |\n\t\t\t    (priv->multi_data[1] & 0x1f);\n\n\t\tf->fingers = alps_process_bitmap(priv, f);\n\t}\n\n\talps_report_semi_mt_data(psmouse, f->fingers);\n}\n\nstatic bool alps_is_valid_package_v7(struct psmouse *psmouse)\n{\n\tswitch (psmouse->pktcnt) {\n\tcase 3:\n\t\treturn (psmouse->packet[2] & 0x40) == 0x40;\n\tcase 4:\n\t\treturn (psmouse->packet[3] & 0x48) == 0x48;\n\tcase 6:\n\t\treturn (psmouse->packet[5] & 0x40) == 0x00;\n\t}\n\treturn true;\n}\n\nstatic unsigned char alps_get_packet_id_v7(char *byte)\n{\n\tunsigned char packet_id;\n\n\tif (byte[4] & 0x40)\n\t\tpacket_id = V7_PACKET_ID_TWO;\n\telse if (byte[4] & 0x01)\n\t\tpacket_id = V7_PACKET_ID_MULTI;\n\telse if ((byte[0] & 0x10) && !(byte[4] & 0x43))\n\t\tpacket_id = V7_PACKET_ID_NEW;\n\telse if (byte[1] == 0x00 && byte[4] == 0x00)\n\t\tpacket_id = V7_PACKET_ID_IDLE;\n\telse\n\t\tpacket_id = V7_PACKET_ID_UNKNOWN;\n\n\treturn packet_id;\n}\n\nstatic void alps_get_finger_coordinate_v7(struct input_mt_pos *mt,\n\t\t\t\t\t  unsigned char *pkt,\n\t\t\t\t\t  unsigned char pkt_id)\n{\n\tmt[0].x = ((pkt[2] & 0x80) << 4);\n\tmt[0].x |= ((pkt[2] & 0x3F) << 5);\n\tmt[0].x |= ((pkt[3] & 0x30) >> 1);\n\tmt[0].x |= (pkt[3] & 0x07);\n\tmt[0].y = (pkt[1] << 3) | (pkt[0] & 0x07);\n\n\tmt[1].x = ((pkt[3] & 0x80) << 4);\n\tmt[1].x |= ((pkt[4] & 0x80) << 3);\n\tmt[1].x |= ((pkt[4] & 0x3F) << 4);\n\tmt[1].y = ((pkt[5] & 0x80) << 3);\n\tmt[1].y |= ((pkt[5] & 0x3F) << 4);\n\n\tswitch (pkt_id) {\n\tcase V7_PACKET_ID_TWO:\n\t\tmt[1].x &= ~0x000F;\n\t\tmt[1].y |= 0x000F;\n\t\t \n\t\tif (mt[1].y == 0x7ff && mt[1].x == 0xff0) {\n\t\t\tmt[1].x = 0;\n\t\t\t \n\t\t}\n\t\tbreak;\n\n\tcase V7_PACKET_ID_MULTI:\n\t\tmt[1].x &= ~0x003F;\n\t\tmt[1].y &= ~0x0020;\n\t\tmt[1].y |= ((pkt[4] & 0x02) << 4);\n\t\tmt[1].y |= 0x001F;\n\t\tbreak;\n\n\tcase V7_PACKET_ID_NEW:\n\t\tmt[1].x &= ~0x003F;\n\t\tmt[1].x |= (pkt[0] & 0x20);\n\t\tmt[1].y |= 0x000F;\n\t\tbreak;\n\t}\n\n\tmt[0].y = 0x7FF - mt[0].y;\n\tmt[1].y = 0x7FF - mt[1].y;\n}\n\nstatic int alps_get_mt_count(struct input_mt_pos *mt)\n{\n\tint i, fingers = 0;\n\n\tfor (i = 0; i < MAX_TOUCHES; i++) {\n\t\tif (mt[i].x != 0 || mt[i].y != 0)\n\t\t\tfingers++;\n\t}\n\n\treturn fingers;\n}\n\nstatic int alps_decode_packet_v7(struct alps_fields *f,\n\t\t\t\t  unsigned char *p,\n\t\t\t\t  struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char pkt_id;\n\n\tpkt_id = alps_get_packet_id_v7(p);\n\tif (pkt_id == V7_PACKET_ID_IDLE)\n\t\treturn 0;\n\tif (pkt_id == V7_PACKET_ID_UNKNOWN)\n\t\treturn -1;\n\t \n\tif (pkt_id == V7_PACKET_ID_NEW)\n\t\treturn 1;\n\n\talps_get_finger_coordinate_v7(f->mt, p, pkt_id);\n\n\tif (pkt_id == V7_PACKET_ID_TWO)\n\t\tf->fingers = alps_get_mt_count(f->mt);\n\telse  \n\t\tf->fingers = 3 + (p[5] & 0x03);\n\n\tf->left = (p[0] & 0x80) >> 7;\n\tif (priv->flags & ALPS_BUTTONPAD) {\n\t\tif (p[0] & 0x20)\n\t\t\tf->fingers++;\n\t\tif (p[0] & 0x10)\n\t\t\tf->fingers++;\n\t} else {\n\t\tf->right = (p[0] & 0x20) >> 5;\n\t\tf->middle = (p[0] & 0x10) >> 4;\n\t}\n\n\t \n\tif (f->fingers == 1 && f->mt[0].x == 0 && f->mt[0].y == 0) {\n\t\tf->mt[0].x = f->mt[1].x;\n\t\tf->mt[0].y = f->mt[1].y;\n\t\tf->mt[1].x = 0;\n\t\tf->mt[1].y = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void alps_process_trackstick_packet_v7(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct input_dev *dev2 = priv->dev2;\n\tint x, y, z;\n\n\t \n\tif (!(priv->flags & ALPS_DUALPOINT)) {\n\t\tpsmouse_warn(psmouse,\n\t\t\t     \"Rejected trackstick packet from non DualPoint device\");\n\t\treturn;\n\t}\n\n\tx = ((packet[2] & 0xbf)) | ((packet[3] & 0x10) << 2);\n\ty = (packet[3] & 0x07) | (packet[4] & 0xb8) |\n\t    ((packet[3] & 0x20) << 1);\n\tz = (packet[5] & 0x3f) | ((packet[3] & 0x80) >> 1);\n\n\tinput_report_rel(dev2, REL_X, (s8)x);\n\tinput_report_rel(dev2, REL_Y, -((s8)y));\n\tinput_report_abs(dev2, ABS_PRESSURE, z);\n\n\tpsmouse_report_standard_buttons(dev2, packet[1]);\n\n\tinput_sync(dev2);\n}\n\nstatic void alps_process_touchpad_packet_v7(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct alps_fields *f = &priv->f;\n\n\tmemset(f, 0, sizeof(*f));\n\n\tif (priv->decode_fields(f, psmouse->packet, psmouse))\n\t\treturn;\n\n\talps_report_mt_data(psmouse, alps_get_mt_count(f->mt));\n\n\tinput_mt_report_finger_count(dev, f->fingers);\n\n\tinput_report_key(dev, BTN_LEFT, f->left);\n\tinput_report_key(dev, BTN_RIGHT, f->right);\n\tinput_report_key(dev, BTN_MIDDLE, f->middle);\n\n\tinput_sync(dev);\n}\n\nstatic void alps_process_packet_v7(struct psmouse *psmouse)\n{\n\tunsigned char *packet = psmouse->packet;\n\n\tif (packet[0] == 0x48 && (packet[4] & 0x47) == 0x06)\n\t\talps_process_trackstick_packet_v7(psmouse);\n\telse\n\t\talps_process_touchpad_packet_v7(psmouse);\n}\n\nstatic enum SS4_PACKET_ID alps_get_pkt_id_ss4_v2(unsigned char *byte)\n{\n\tenum SS4_PACKET_ID pkt_id = SS4_PACKET_ID_IDLE;\n\n\tswitch (byte[3] & 0x30) {\n\tcase 0x00:\n\t\tif (SS4_IS_IDLE_V2(byte)) {\n\t\t\tpkt_id = SS4_PACKET_ID_IDLE;\n\t\t} else {\n\t\t\tpkt_id = SS4_PACKET_ID_ONE;\n\t\t}\n\t\tbreak;\n\tcase 0x10:\n\t\t \n\t\tpkt_id = SS4_PACKET_ID_TWO;\n\t\tbreak;\n\tcase 0x20:\n\t\t \n\t\tpkt_id = SS4_PACKET_ID_STICK;\n\t\tbreak;\n\tcase 0x30:\n\t\t \n\t\tpkt_id = SS4_PACKET_ID_MULTI;\n\t\tbreak;\n\t}\n\n\treturn pkt_id;\n}\n\nstatic int alps_decode_ss4_v2(struct alps_fields *f,\n\t\t\t      unsigned char *p, struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tenum SS4_PACKET_ID pkt_id;\n\tunsigned int no_data_x, no_data_y;\n\n\tpkt_id = alps_get_pkt_id_ss4_v2(p);\n\n\t \n\tswitch (pkt_id) {\n\tcase SS4_PACKET_ID_ONE:\n\t\tf->mt[0].x = SS4_1F_X_V2(p);\n\t\tf->mt[0].y = SS4_1F_Y_V2(p);\n\t\tf->pressure = ((SS4_1F_Z_V2(p)) * 2) & 0x7f;\n\t\t \n\t\tf->fingers = f->pressure > 0 ? 1 : 0;\n\t\tf->first_mp = 0;\n\t\tf->is_mp = 0;\n\t\tbreak;\n\n\tcase SS4_PACKET_ID_TWO:\n\t\tif (priv->flags & ALPS_BUTTONPAD) {\n\t\t\tif (IS_SS4PLUS_DEV(priv->dev_id)) {\n\t\t\t\tf->mt[0].x = SS4_PLUS_BTL_MF_X_V2(p, 0);\n\t\t\t\tf->mt[1].x = SS4_PLUS_BTL_MF_X_V2(p, 1);\n\t\t\t} else {\n\t\t\t\tf->mt[0].x = SS4_BTL_MF_X_V2(p, 0);\n\t\t\t\tf->mt[1].x = SS4_BTL_MF_X_V2(p, 1);\n\t\t\t}\n\t\t\tf->mt[0].y = SS4_BTL_MF_Y_V2(p, 0);\n\t\t\tf->mt[1].y = SS4_BTL_MF_Y_V2(p, 1);\n\t\t} else {\n\t\t\tif (IS_SS4PLUS_DEV(priv->dev_id)) {\n\t\t\t\tf->mt[0].x = SS4_PLUS_STD_MF_X_V2(p, 0);\n\t\t\t\tf->mt[1].x = SS4_PLUS_STD_MF_X_V2(p, 1);\n\t\t\t} else {\n\t\t\t\tf->mt[0].x = SS4_STD_MF_X_V2(p, 0);\n\t\t\t\tf->mt[1].x = SS4_STD_MF_X_V2(p, 1);\n\t\t\t}\n\t\t\tf->mt[0].y = SS4_STD_MF_Y_V2(p, 0);\n\t\t\tf->mt[1].y = SS4_STD_MF_Y_V2(p, 1);\n\t\t}\n\t\tf->pressure = SS4_MF_Z_V2(p, 0) ? 0x30 : 0;\n\n\t\tif (SS4_IS_MF_CONTINUE(p)) {\n\t\t\tf->first_mp = 1;\n\t\t} else {\n\t\t\tf->fingers = 2;\n\t\t\tf->first_mp = 0;\n\t\t}\n\t\tf->is_mp = 0;\n\n\t\tbreak;\n\n\tcase SS4_PACKET_ID_MULTI:\n\t\tif (priv->flags & ALPS_BUTTONPAD) {\n\t\t\tif (IS_SS4PLUS_DEV(priv->dev_id)) {\n\t\t\t\tf->mt[2].x = SS4_PLUS_BTL_MF_X_V2(p, 0);\n\t\t\t\tf->mt[3].x = SS4_PLUS_BTL_MF_X_V2(p, 1);\n\t\t\t\tno_data_x = SS4_PLUS_MFPACKET_NO_AX_BL;\n\t\t\t} else {\n\t\t\t\tf->mt[2].x = SS4_BTL_MF_X_V2(p, 0);\n\t\t\t\tf->mt[3].x = SS4_BTL_MF_X_V2(p, 1);\n\t\t\t\tno_data_x = SS4_MFPACKET_NO_AX_BL;\n\t\t\t}\n\t\t\tno_data_y = SS4_MFPACKET_NO_AY_BL;\n\n\t\t\tf->mt[2].y = SS4_BTL_MF_Y_V2(p, 0);\n\t\t\tf->mt[3].y = SS4_BTL_MF_Y_V2(p, 1);\n\t\t} else {\n\t\t\tif (IS_SS4PLUS_DEV(priv->dev_id)) {\n\t\t\t\tf->mt[2].x = SS4_PLUS_STD_MF_X_V2(p, 0);\n\t\t\t\tf->mt[3].x = SS4_PLUS_STD_MF_X_V2(p, 1);\n\t\t\t\tno_data_x = SS4_PLUS_MFPACKET_NO_AX;\n\t\t\t} else {\n\t\t\t\tf->mt[2].x = SS4_STD_MF_X_V2(p, 0);\n\t\t\t\tf->mt[3].x = SS4_STD_MF_X_V2(p, 1);\n\t\t\t\tno_data_x = SS4_MFPACKET_NO_AX;\n\t\t\t}\n\t\t\tno_data_y = SS4_MFPACKET_NO_AY;\n\n\t\t\tf->mt[2].y = SS4_STD_MF_Y_V2(p, 0);\n\t\t\tf->mt[3].y = SS4_STD_MF_Y_V2(p, 1);\n\t\t}\n\n\t\tf->first_mp = 0;\n\t\tf->is_mp = 1;\n\n\t\tif (SS4_IS_5F_DETECTED(p)) {\n\t\t\tf->fingers = 5;\n\t\t} else if (f->mt[3].x == no_data_x &&\n\t\t\t     f->mt[3].y == no_data_y) {\n\t\t\tf->mt[3].x = 0;\n\t\t\tf->mt[3].y = 0;\n\t\t\tf->fingers = 3;\n\t\t} else {\n\t\t\tf->fingers = 4;\n\t\t}\n\t\tbreak;\n\n\tcase SS4_PACKET_ID_STICK:\n\t\t \n\t\tf->first_mp = 0;\n\t\tf->is_mp = 0;\n\t\tbreak;\n\n\tcase SS4_PACKET_ID_IDLE:\n\tdefault:\n\t\tmemset(f, 0, sizeof(struct alps_fields));\n\t\tbreak;\n\t}\n\n\t \n\tif (pkt_id == SS4_PACKET_ID_STICK) {\n\t\tf->ts_left = !!(SS4_BTN_V2(p) & 0x01);\n\t\tf->ts_right = !!(SS4_BTN_V2(p) & 0x02);\n\t\tf->ts_middle = !!(SS4_BTN_V2(p) & 0x04);\n\t} else {\n\t\tf->left = !!(SS4_BTN_V2(p) & 0x01);\n\t\tif (!(priv->flags & ALPS_BUTTONPAD)) {\n\t\t\tf->right = !!(SS4_BTN_V2(p) & 0x02);\n\t\t\tf->middle = !!(SS4_BTN_V2(p) & 0x04);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void alps_process_packet_ss4_v2(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char *packet = psmouse->packet;\n\tstruct input_dev *dev = psmouse->dev;\n\tstruct input_dev *dev2 = priv->dev2;\n\tstruct alps_fields *f = &priv->f;\n\n\tmemset(f, 0, sizeof(struct alps_fields));\n\tpriv->decode_fields(f, packet, psmouse);\n\tif (priv->multi_packet) {\n\t\t \n\t\tif (f->is_mp) {\n\t\t\t \n\t\t\tpriv->decode_fields(f, priv->multi_data, psmouse);\n\t\t} else {\n\t\t\tpriv->multi_packet = 0;\n\t\t}\n\t}\n\n\t \n\tif (f->is_mp)\n\t\treturn;\n\n\t \n\tif (!priv->multi_packet && f->first_mp) {\n\t\tpriv->multi_packet = 1;\n\t\tmemcpy(priv->multi_data, packet, sizeof(priv->multi_data));\n\t\treturn;\n\t}\n\n\tpriv->multi_packet = 0;\n\n\t \n\tif (alps_get_pkt_id_ss4_v2(packet) == SS4_PACKET_ID_STICK) {\n\t\tif (!(priv->flags & ALPS_DUALPOINT)) {\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"Rejected trackstick packet from non DualPoint device\");\n\t\t\treturn;\n\t\t}\n\n\t\tinput_report_rel(dev2, REL_X, SS4_TS_X_V2(packet));\n\t\tinput_report_rel(dev2, REL_Y, SS4_TS_Y_V2(packet));\n\t\tinput_report_abs(dev2, ABS_PRESSURE, SS4_TS_Z_V2(packet));\n\n\t\tinput_report_key(dev2, BTN_LEFT, f->ts_left);\n\t\tinput_report_key(dev2, BTN_RIGHT, f->ts_right);\n\t\tinput_report_key(dev2, BTN_MIDDLE, f->ts_middle);\n\n\t\tinput_sync(dev2);\n\t\treturn;\n\t}\n\n\t \n\talps_report_mt_data(psmouse, (f->fingers <= 4) ? f->fingers : 4);\n\n\tinput_mt_report_finger_count(dev, f->fingers);\n\n\tinput_report_key(dev, BTN_LEFT, f->left);\n\tinput_report_key(dev, BTN_RIGHT, f->right);\n\tinput_report_key(dev, BTN_MIDDLE, f->middle);\n\n\tinput_report_abs(dev, ABS_PRESSURE, f->pressure);\n\tinput_sync(dev);\n}\n\nstatic bool alps_is_valid_package_ss4_v2(struct psmouse *psmouse)\n{\n\tif (psmouse->pktcnt == 4 && ((psmouse->packet[3] & 0x08) != 0x08))\n\t\treturn false;\n\tif (psmouse->pktcnt == 6 && ((psmouse->packet[5] & 0x10) != 0x0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic DEFINE_MUTEX(alps_mutex);\n\nstatic void alps_register_bare_ps2_mouse(struct work_struct *work)\n{\n\tstruct alps_data *priv =\n\t\tcontainer_of(work, struct alps_data, dev3_register_work.work);\n\tstruct psmouse *psmouse = priv->psmouse;\n\tstruct input_dev *dev3;\n\tint error = 0;\n\n\tmutex_lock(&alps_mutex);\n\n\tif (priv->dev3)\n\t\tgoto out;\n\n\tdev3 = input_allocate_device();\n\tif (!dev3) {\n\t\tpsmouse_err(psmouse, \"failed to allocate secondary device\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsnprintf(priv->phys3, sizeof(priv->phys3), \"%s/%s\",\n\t\t psmouse->ps2dev.serio->phys,\n\t\t (priv->dev2 ? \"input2\" : \"input1\"));\n\tdev3->phys = priv->phys3;\n\n\t \n\tdev3->name = \"PS/2 ALPS Mouse\";\n\n\tdev3->id.bustype = BUS_I8042;\n\tdev3->id.vendor  = 0x0002;\n\tdev3->id.product = PSMOUSE_PS2;\n\tdev3->id.version = 0x0000;\n\tdev3->dev.parent = &psmouse->ps2dev.serio->dev;\n\n\tinput_set_capability(dev3, EV_REL, REL_X);\n\tinput_set_capability(dev3, EV_REL, REL_Y);\n\tinput_set_capability(dev3, EV_KEY, BTN_LEFT);\n\tinput_set_capability(dev3, EV_KEY, BTN_RIGHT);\n\tinput_set_capability(dev3, EV_KEY, BTN_MIDDLE);\n\n\t__set_bit(INPUT_PROP_POINTER, dev3->propbit);\n\n\terror = input_register_device(dev3);\n\tif (error) {\n\t\tpsmouse_err(psmouse,\n\t\t\t    \"failed to register secondary device: %d\\n\",\n\t\t\t    error);\n\t\tinput_free_device(dev3);\n\t\tgoto out;\n\t}\n\n\tpriv->dev3 = dev3;\n\nout:\n\t \n\tif (error)\n\t\tpriv->dev3 = ERR_PTR(error);\n\n\tmutex_unlock(&alps_mutex);\n}\n\nstatic void alps_report_bare_ps2_packet(struct psmouse *psmouse,\n\t\t\t\t\tunsigned char packet[],\n\t\t\t\t\tbool report_buttons)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct input_dev *dev, *dev2 = NULL;\n\n\t \n\tif (priv->proto_version == ALPS_PROTO_V2 &&\n\t    (priv->flags & ALPS_DUALPOINT)) {\n\t\t \n\t\tdev = priv->dev2;\n\t\tdev2 = psmouse->dev;\n\t} else if (unlikely(IS_ERR_OR_NULL(priv->dev3))) {\n\t\t \n\t\tif (!IS_ERR(priv->dev3))\n\t\t\tpsmouse_queue_work(psmouse, &priv->dev3_register_work,\n\t\t\t\t\t   0);\n\t\treturn;\n\t} else {\n\t\tdev = priv->dev3;\n\t}\n\n\tif (report_buttons)\n\t\talps_report_buttons(dev, dev2,\n\t\t\t\tpacket[0] & 1, packet[0] & 2, packet[0] & 4);\n\n\tpsmouse_report_standard_motion(dev, packet);\n\n\tinput_sync(dev);\n}\n\nstatic psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\n\tif (psmouse->pktcnt < 6)\n\t\treturn PSMOUSE_GOOD_DATA;\n\n\tif (psmouse->pktcnt == 6) {\n\t\t \n\t\tmod_timer(&priv->timer, jiffies + msecs_to_jiffies(20));\n\t\treturn PSMOUSE_GOOD_DATA;\n\t}\n\n\tdel_timer(&priv->timer);\n\n\tif (psmouse->packet[6] & 0x80) {\n\n\t\t \n\n\t\tif (((psmouse->packet[3] |\n\t\t      psmouse->packet[4] |\n\t\t      psmouse->packet[5]) & 0x80) ||\n\t\t    (!alps_is_valid_first_byte(priv, psmouse->packet[6]))) {\n\t\t\tpsmouse_dbg(psmouse,\n\t\t\t\t    \"refusing packet %4ph (suspected interleaved ps/2)\\n\",\n\t\t\t\t    psmouse->packet + 3);\n\t\t\treturn PSMOUSE_BAD_DATA;\n\t\t}\n\n\t\tpriv->process_packet(psmouse);\n\n\t\t \n\t\tpsmouse->packet[0] = psmouse->packet[6];\n\t\tpsmouse->pktcnt = 1;\n\n\t} else {\n\n\t\t \n\n\t\talps_report_bare_ps2_packet(psmouse, &psmouse->packet[3],\n\t\t\t\t\t    false);\n\n\t\t \n\t\tpsmouse->packet[3] = psmouse->packet[6] & 0xf7;\n\t\tpsmouse->pktcnt = 4;\n\t}\n\n\treturn PSMOUSE_GOOD_DATA;\n}\n\nstatic void alps_flush_packet(struct timer_list *t)\n{\n\tstruct alps_data *priv = from_timer(priv, t, timer);\n\tstruct psmouse *psmouse = priv->psmouse;\n\n\tserio_pause_rx(psmouse->ps2dev.serio);\n\n\tif (psmouse->pktcnt == psmouse->pktsize) {\n\n\t\t \n\t\tif ((psmouse->packet[3] |\n\t\t     psmouse->packet[4] |\n\t\t     psmouse->packet[5]) & 0x80) {\n\t\t\tpsmouse_dbg(psmouse,\n\t\t\t\t    \"refusing packet %3ph (suspected interleaved ps/2)\\n\",\n\t\t\t\t    psmouse->packet + 3);\n\t\t} else {\n\t\t\tpriv->process_packet(psmouse);\n\t\t}\n\t\tpsmouse->pktcnt = 0;\n\t}\n\n\tserio_continue_rx(psmouse->ps2dev.serio);\n}\n\nstatic psmouse_ret_t alps_process_byte(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\n\t \n\tif (priv->proto_version != ALPS_PROTO_V8 &&\n\t    !psmouse->out_of_sync_cnt &&\n\t    (psmouse->packet[0] & 0xc8) == 0x08) {\n\n\t\tif (psmouse->pktcnt == 3) {\n\t\t\talps_report_bare_ps2_packet(psmouse, psmouse->packet,\n\t\t\t\t\t\t    true);\n\t\t\treturn PSMOUSE_FULL_PACKET;\n\t\t}\n\t\treturn PSMOUSE_GOOD_DATA;\n\t}\n\n\t \n\n\tif ((priv->flags & ALPS_PS2_INTERLEAVED) &&\n\t    psmouse->pktcnt >= 4 && (psmouse->packet[3] & 0x0f) == 0x0f) {\n\t\treturn alps_handle_interleaved_ps2(psmouse);\n\t}\n\n\tif (!alps_is_valid_first_byte(priv, psmouse->packet[0])) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"refusing packet[0] = %x (mask0 = %x, byte0 = %x)\\n\",\n\t\t\t    psmouse->packet[0], priv->mask0, priv->byte0);\n\t\treturn PSMOUSE_BAD_DATA;\n\t}\n\n\t \n\tif (priv->proto_version < ALPS_PROTO_V5 &&\n\t    psmouse->pktcnt >= 2 && psmouse->pktcnt <= psmouse->pktsize &&\n\t    (psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {\n\t\tpsmouse_dbg(psmouse, \"refusing packet[%i] = %x\\n\",\n\t\t\t    psmouse->pktcnt - 1,\n\t\t\t    psmouse->packet[psmouse->pktcnt - 1]);\n\n\t\tif (priv->proto_version == ALPS_PROTO_V3_RUSHMORE &&\n\t\t    psmouse->pktcnt == psmouse->pktsize) {\n\t\t\t \n\t\t\treturn PSMOUSE_FULL_PACKET;\n\t\t}\n\n\t\treturn PSMOUSE_BAD_DATA;\n\t}\n\n\tif ((priv->proto_version == ALPS_PROTO_V7 &&\n\t\t\t!alps_is_valid_package_v7(psmouse)) ||\n\t    (priv->proto_version == ALPS_PROTO_V8 &&\n\t\t\t!alps_is_valid_package_ss4_v2(psmouse))) {\n\t\tpsmouse_dbg(psmouse, \"refusing packet[%i] = %x\\n\",\n\t\t\t    psmouse->pktcnt - 1,\n\t\t\t    psmouse->packet[psmouse->pktcnt - 1]);\n\t\treturn PSMOUSE_BAD_DATA;\n\t}\n\n\tif (psmouse->pktcnt == psmouse->pktsize) {\n\t\tpriv->process_packet(psmouse);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\treturn PSMOUSE_GOOD_DATA;\n}\n\nstatic int alps_command_mode_send_nibble(struct psmouse *psmouse, int nibble)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tstruct alps_data *priv = psmouse->private;\n\tint command;\n\tunsigned char *param;\n\tunsigned char dummy[4];\n\n\tBUG_ON(nibble > 0xf);\n\n\tcommand = priv->nibble_commands[nibble].command;\n\tparam = (command & 0x0f00) ?\n\t\tdummy : (unsigned char *)&priv->nibble_commands[nibble].data;\n\n\tif (ps2_command(ps2dev, param, command))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_command_mode_set_addr(struct psmouse *psmouse, int addr)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tstruct alps_data *priv = psmouse->private;\n\tint i, nibble;\n\n\tif (ps2_command(ps2dev, NULL, priv->addr_command))\n\t\treturn -1;\n\n\tfor (i = 12; i >= 0; i -= 4) {\n\t\tnibble = (addr >> i) & 0xf;\n\t\tif (alps_command_mode_send_nibble(psmouse, nibble))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[4];\n\n\tif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\n\t\treturn -1;\n\n\t \n\tif (addr != ((param[0] << 8) | param[1]))\n\t\treturn -1;\n\n\treturn param[2];\n}\n\nstatic int alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\n{\n\tif (alps_command_mode_set_addr(psmouse, addr))\n\t\treturn -1;\n\treturn __alps_command_mode_read_reg(psmouse, addr);\n}\n\nstatic int __alps_command_mode_write_reg(struct psmouse *psmouse, u8 value)\n{\n\tif (alps_command_mode_send_nibble(psmouse, (value >> 4) & 0xf))\n\t\treturn -1;\n\tif (alps_command_mode_send_nibble(psmouse, value & 0xf))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int alps_command_mode_write_reg(struct psmouse *psmouse, int addr,\n\t\t\t\t       u8 value)\n{\n\tif (alps_command_mode_set_addr(psmouse, addr))\n\t\treturn -1;\n\treturn __alps_command_mode_write_reg(psmouse, value);\n}\n\nstatic int alps_rpt_cmd(struct psmouse *psmouse, int init_command,\n\t\t\tint repeated_command, unsigned char *param)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\tparam[0] = 0;\n\tif (init_command && ps2_command(ps2dev, param, init_command))\n\t\treturn -EIO;\n\n\tif (ps2_command(ps2dev,  NULL, repeated_command) ||\n\t    ps2_command(ps2dev,  NULL, repeated_command) ||\n\t    ps2_command(ps2dev,  NULL, repeated_command))\n\t\treturn -EIO;\n\n\tparam[0] = param[1] = param[2] = 0xff;\n\tif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\n\t\treturn -EIO;\n\n\tpsmouse_dbg(psmouse, \"%2.2X report: %3ph\\n\",\n\t\t    repeated_command, param);\n\treturn 0;\n}\n\nstatic bool alps_check_valid_firmware_id(unsigned char id[])\n{\n\tif (id[0] == 0x73)\n\t\treturn true;\n\n\tif (id[0] == 0x88 &&\n\t    (id[1] == 0x07 ||\n\t     id[1] == 0x08 ||\n\t     (id[1] & 0xf0) == 0xb0 ||\n\t     (id[1] & 0xf0) == 0xc0)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int alps_enter_command_mode(struct psmouse *psmouse)\n{\n\tunsigned char param[4];\n\n\tif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_RESET_WRAP, param)) {\n\t\tpsmouse_err(psmouse, \"failed to enter command mode\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!alps_check_valid_firmware_id(param)) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"unknown response while entering command mode\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic inline int alps_exit_command_mode(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic int alps_passthrough_mode_v2(struct psmouse *psmouse, bool enable)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint cmd = enable ? PSMOUSE_CMD_SETSCALE21 : PSMOUSE_CMD_SETSCALE11;\n\n\tif (ps2_command(ps2dev, NULL, cmd) ||\n\t    ps2_command(ps2dev, NULL, cmd) ||\n\t    ps2_command(ps2dev, NULL, cmd) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\n\t\treturn -1;\n\n\t \n\tps2_drain(ps2dev, 3, 100);\n\n\treturn 0;\n}\n\nstatic int alps_absolute_mode_v1_v2(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\t \n\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))\n\t\treturn -1;\n\n\t \n\treturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL);\n}\n\nstatic int alps_monitor_mode_send_word(struct psmouse *psmouse, u16 word)\n{\n\tint i, nibble;\n\n\t \n\tfor (i = 0; i <= 8; i += 4) {\n\t\tnibble = (word >> i) & 0xf;\n\t\tif (alps_command_mode_send_nibble(psmouse, nibble))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_monitor_mode_write_reg(struct psmouse *psmouse,\n\t\t\t\t       u16 addr, u16 value)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\t \n\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE) ||\n\t    alps_monitor_mode_send_word(psmouse, 0x0A0) ||\n\t    alps_monitor_mode_send_word(psmouse, addr) ||\n\t    alps_monitor_mode_send_word(psmouse, value) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_monitor_mode(struct psmouse *psmouse, bool enable)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\tif (enable) {\n\t\t \n\t\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_GETINFO) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_GETINFO))\n\t\t\treturn -1;\n\t} else {\n\t\t \n\t\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_absolute_mode_v6(struct psmouse *psmouse)\n{\n\tu16 reg_val = 0x181;\n\tint ret;\n\n\t \n\tif (alps_monitor_mode(psmouse, true))\n\t\treturn -1;\n\n\tret = alps_monitor_mode_write_reg(psmouse, 0x000, reg_val);\n\n\tif (alps_monitor_mode(psmouse, false))\n\t\tret = -1;\n\n\treturn ret;\n}\n\nstatic int alps_get_status(struct psmouse *psmouse, char *param)\n{\n\t \n\tif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_DISABLE, param))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int alps_tap_mode(struct psmouse *psmouse, int enable)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint cmd = enable ? PSMOUSE_CMD_SETRATE : PSMOUSE_CMD_SETRES;\n\tunsigned char tap_arg = enable ? 0x0A : 0x00;\n\tunsigned char param[4];\n\n\tif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\n\t    ps2_command(ps2dev, &tap_arg, cmd))\n\t\treturn -1;\n\n\tif (alps_get_status(psmouse, param))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int alps_poll(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tunsigned char buf[sizeof(psmouse->packet)];\n\tbool poll_failed;\n\n\tif (priv->flags & ALPS_PASS)\n\t\talps_passthrough_mode_v2(psmouse, true);\n\n\tpoll_failed = ps2_command(&psmouse->ps2dev, buf,\n\t\t\t\t  PSMOUSE_CMD_POLL | (psmouse->pktsize << 8)) < 0;\n\n\tif (priv->flags & ALPS_PASS)\n\t\talps_passthrough_mode_v2(psmouse, false);\n\n\tif (poll_failed || (buf[0] & priv->mask0) != priv->byte0)\n\t\treturn -1;\n\n\tif ((psmouse->badbyte & 0xc8) == 0x08) {\n \n\t\tif (ps2_command(&psmouse->ps2dev, buf, PSMOUSE_CMD_POLL | (3 << 8)))\n\t\t\treturn -1;\n\t}\n\n\tmemcpy(psmouse->packet, buf, sizeof(buf));\n\treturn 0;\n}\n\nstatic int alps_hw_init_v1_v2(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\n\tif ((priv->flags & ALPS_PASS) &&\n\t    alps_passthrough_mode_v2(psmouse, true)) {\n\t\treturn -1;\n\t}\n\n\tif (alps_tap_mode(psmouse, true)) {\n\t\tpsmouse_warn(psmouse, \"Failed to enable hardware tapping\\n\");\n\t\treturn -1;\n\t}\n\n\tif (alps_absolute_mode_v1_v2(psmouse)) {\n\t\tpsmouse_err(psmouse, \"Failed to enable absolute mode\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((priv->flags & ALPS_PASS) &&\n\t    alps_passthrough_mode_v2(psmouse, false)) {\n\t\treturn -1;\n\t}\n\n\t \n\tif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)) {\n\t\tpsmouse_err(psmouse, \"Failed to enable stream mode\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int alps_trackstick_enter_extended_mode_v3_v6(struct psmouse *psmouse)\n{\n\tunsigned char param[2] = {0xC8, 0x14};\n\n\tif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t    ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t    ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\n\t    ps2_command(&psmouse->ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(&psmouse->ps2dev, &param[1], PSMOUSE_CMD_SETRATE))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_hw_init_v6(struct psmouse *psmouse)\n{\n\tint ret;\n\n\t \n\tif (alps_passthrough_mode_v2(psmouse, true))\n\t\treturn -1;\n\n\tret = alps_trackstick_enter_extended_mode_v3_v6(psmouse);\n\n\tif (alps_passthrough_mode_v2(psmouse, false))\n\t\treturn -1;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (alps_absolute_mode_v6(psmouse)) {\n\t\tpsmouse_err(psmouse, \"Failed to enable absolute mode\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int alps_passthrough_mode_v3(struct psmouse *psmouse,\n\t\t\t\t    int reg_base, bool enable)\n{\n\tint reg_val, ret = -1;\n\n\tif (alps_enter_command_mode(psmouse))\n\t\treturn -1;\n\n\treg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x0008);\n\tif (reg_val == -1)\n\t\tgoto error;\n\n\tif (enable)\n\t\treg_val |= 0x01;\n\telse\n\t\treg_val &= ~0x01;\n\n\tret = __alps_command_mode_write_reg(psmouse, reg_val);\n\nerror:\n\tif (alps_exit_command_mode(psmouse))\n\t\tret = -1;\n\treturn ret;\n}\n\n \nstatic int alps_absolute_mode_v3(struct psmouse *psmouse)\n{\n\tint reg_val;\n\n\treg_val = alps_command_mode_read_reg(psmouse, 0x0004);\n\tif (reg_val == -1)\n\t\treturn -1;\n\n\treg_val |= 0x06;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_probe_trackstick_v3_v7(struct psmouse *psmouse, int reg_base)\n{\n\tint ret = -EIO, reg_val;\n\n\tif (alps_enter_command_mode(psmouse))\n\t\tgoto error;\n\n\treg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x08);\n\tif (reg_val == -1)\n\t\tgoto error;\n\n\t \n\tret = reg_val & 0x80 ? 0 : -ENODEV;\n\nerror:\n\talps_exit_command_mode(psmouse);\n\treturn ret;\n}\n\nstatic int alps_setup_trackstick_v3(struct psmouse *psmouse, int reg_base)\n{\n\tint ret = 0;\n\tint reg_val;\n\tunsigned char param[4];\n\n\t \n\n\tif (alps_passthrough_mode_v3(psmouse, reg_base, true))\n\t\treturn -EIO;\n\n\t \n\tif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_SETSCALE21, param)) {\n\t\tpsmouse_warn(psmouse, \"Failed to initialize trackstick (E7 report failed)\\n\");\n\t\tret = -ENODEV;\n\t} else {\n\t\tpsmouse_dbg(psmouse, \"trackstick E7 report: %3ph\\n\", param);\n\t\tif (alps_trackstick_enter_extended_mode_v3_v6(psmouse)) {\n\t\t\tpsmouse_err(psmouse, \"Failed to enter into trackstick extended mode\\n\");\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\tif (alps_passthrough_mode_v3(psmouse, reg_base, false))\n\t\treturn -EIO;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (alps_enter_command_mode(psmouse))\n\t\treturn -EIO;\n\n\treg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x08);\n\tif (reg_val == -1) {\n\t\tret = -EIO;\n\t} else {\n\t\t \n\t\treg_val |= BIT(1);\n\t\tif (__alps_command_mode_write_reg(psmouse, reg_val))\n\t\t\tret = -EIO;\n\t}\n\n\tif (alps_exit_command_mode(psmouse))\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int alps_hw_init_v3(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint reg_val;\n\tunsigned char param[4];\n\n\tif ((priv->flags & ALPS_DUALPOINT) &&\n\t    alps_setup_trackstick_v3(psmouse, ALPS_REG_BASE_PINNACLE) == -EIO)\n\t\tgoto error;\n\n\tif (alps_enter_command_mode(psmouse) ||\n\t    alps_absolute_mode_v3(psmouse)) {\n\t\tpsmouse_err(psmouse, \"Failed to enter absolute mode\\n\");\n\t\tgoto error;\n\t}\n\n\treg_val = alps_command_mode_read_reg(psmouse, 0x0006);\n\tif (reg_val == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\n\t\tgoto error;\n\n\treg_val = alps_command_mode_read_reg(psmouse, 0x0007);\n\tif (reg_val == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\n\t\tgoto error;\n\n\tif (alps_command_mode_read_reg(psmouse, 0x0144) == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, 0x04))\n\t\tgoto error;\n\n\tif (alps_command_mode_read_reg(psmouse, 0x0159) == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, 0x03))\n\t\tgoto error;\n\n\tif (alps_command_mode_read_reg(psmouse, 0x0163) == -1)\n\t\tgoto error;\n\tif (alps_command_mode_write_reg(psmouse, 0x0163, 0x03))\n\t\tgoto error;\n\n\tif (alps_command_mode_read_reg(psmouse, 0x0162) == -1)\n\t\tgoto error;\n\tif (alps_command_mode_write_reg(psmouse, 0x0162, 0x04))\n\t\tgoto error;\n\n\talps_exit_command_mode(psmouse);\n\n\t \n\tparam[0] = 0x64;\n\tif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\n\t\tpsmouse_err(psmouse, \"Failed to enable data reporting\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\t \n\talps_exit_command_mode(psmouse);\n\treturn -1;\n}\n\nstatic int alps_get_v3_v7_resolution(struct psmouse *psmouse, int reg_pitch)\n{\n\tint reg, x_pitch, y_pitch, x_electrode, y_electrode, x_phys, y_phys;\n\tstruct alps_data *priv = psmouse->private;\n\n\treg = alps_command_mode_read_reg(psmouse, reg_pitch);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tx_pitch = (s8)(reg << 4) >> 4;  \n\tx_pitch = 50 + 2 * x_pitch;  \n\n\ty_pitch = (s8)reg >> 4;  \n\ty_pitch = 36 + 2 * y_pitch;  \n\n\treg = alps_command_mode_read_reg(psmouse, reg_pitch + 1);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tx_electrode = (s8)(reg << 4) >> 4;  \n\tx_electrode = 17 + x_electrode;\n\n\ty_electrode = (s8)reg >> 4;  \n\ty_electrode = 13 + y_electrode;\n\n\tx_phys = x_pitch * (x_electrode - 1);  \n\ty_phys = y_pitch * (y_electrode - 1);  \n\n\tpriv->x_res = priv->x_max * 10 / x_phys;  \n\tpriv->y_res = priv->y_max * 10 / y_phys;  \n\n\tpsmouse_dbg(psmouse,\n\t\t    \"pitch %dx%d num-electrodes %dx%d physical size %dx%d mm res %dx%d\\n\",\n\t\t    x_pitch, y_pitch, x_electrode, y_electrode,\n\t\t    x_phys / 10, y_phys / 10, priv->x_res, priv->y_res);\n\n\treturn 0;\n}\n\nstatic int alps_hw_init_rushmore_v3(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint reg_val, ret = -1;\n\n\tif (priv->flags & ALPS_DUALPOINT) {\n\t\treg_val = alps_setup_trackstick_v3(psmouse,\n\t\t\t\t\t\t   ALPS_REG_BASE_RUSHMORE);\n\t\tif (reg_val == -EIO)\n\t\t\tgoto error;\n\t}\n\n\tif (alps_enter_command_mode(psmouse) ||\n\t    alps_command_mode_read_reg(psmouse, 0xc2d9) == -1 ||\n\t    alps_command_mode_write_reg(psmouse, 0xc2cb, 0x00))\n\t\tgoto error;\n\n\tif (alps_get_v3_v7_resolution(psmouse, 0xc2da))\n\t\tgoto error;\n\n\treg_val = alps_command_mode_read_reg(psmouse, 0xc2c6);\n\tif (reg_val == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val & 0xfd))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0xc2c9, 0x64))\n\t\tgoto error;\n\n\t \n\treg_val = alps_command_mode_read_reg(psmouse, 0xc2c4);\n\tif (reg_val == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val | 0x02))\n\t\tgoto error;\n\n\talps_exit_command_mode(psmouse);\n\treturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\n\nerror:\n\talps_exit_command_mode(psmouse);\n\treturn ret;\n}\n\n \nstatic int alps_absolute_mode_v4(struct psmouse *psmouse)\n{\n\tint reg_val;\n\n\treg_val = alps_command_mode_read_reg(psmouse, 0x0004);\n\tif (reg_val == -1)\n\t\treturn -1;\n\n\treg_val |= 0x02;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_hw_init_v4(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[4];\n\n\tif (alps_enter_command_mode(psmouse))\n\t\tgoto error;\n\n\tif (alps_absolute_mode_v4(psmouse)) {\n\t\tpsmouse_err(psmouse, \"Failed to enter absolute mode\\n\");\n\t\tgoto error;\n\t}\n\n\tif (alps_command_mode_write_reg(psmouse, 0x0007, 0x8c))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x0149, 0x03))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x0160, 0x03))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x017f, 0x15))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x0151, 0x01))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x0168, 0x03))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x014a, 0x03))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0x0161, 0x03))\n\t\tgoto error;\n\n\talps_exit_command_mode(psmouse);\n\n\t \n\tparam[0] = 0xc8;\n\tparam[1] = 0x64;\n\tparam[2] = 0x50;\n\tif (ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, &param[2], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, param, PSMOUSE_CMD_GETID))\n\t\treturn -1;\n\n\t \n\tparam[0] = 0x64;\n\tif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\n\t\tpsmouse_err(psmouse, \"Failed to enable data reporting\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\t \n\talps_exit_command_mode(psmouse);\n\treturn -1;\n}\n\nstatic int alps_get_otp_values_ss4_v2(struct psmouse *psmouse,\n\t\t\t\t      unsigned char index, unsigned char otp[])\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\tswitch (index) {\n\tcase 0:\n\t\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)  ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)  ||\n\t\t    ps2_command(ps2dev, otp, PSMOUSE_CMD_GETINFO))\n\t\t\treturn -1;\n\n\t\tbreak;\n\n\tcase 1:\n\t\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL)  ||\n\t\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL)  ||\n\t\t    ps2_command(ps2dev, otp, PSMOUSE_CMD_GETINFO))\n\t\t\treturn -1;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_update_device_area_ss4_v2(unsigned char otp[][4],\n\t\t\t\t\t  struct alps_data *priv)\n{\n\tint num_x_electrode;\n\tint num_y_electrode;\n\tint x_pitch, y_pitch, x_phys, y_phys;\n\n\tif (IS_SS4PLUS_DEV(priv->dev_id)) {\n\t\tnum_x_electrode =\n\t\t\tSS4PLUS_NUMSENSOR_XOFFSET + (otp[0][2] & 0x0F);\n\t\tnum_y_electrode =\n\t\t\tSS4PLUS_NUMSENSOR_YOFFSET + ((otp[0][2] >> 4) & 0x0F);\n\n\t\tpriv->x_max =\n\t\t\t(num_x_electrode - 1) * SS4PLUS_COUNT_PER_ELECTRODE;\n\t\tpriv->y_max =\n\t\t\t(num_y_electrode - 1) * SS4PLUS_COUNT_PER_ELECTRODE;\n\n\t\tx_pitch = (otp[0][1] & 0x0F) + SS4PLUS_MIN_PITCH_MM;\n\t\ty_pitch = ((otp[0][1] >> 4) & 0x0F) + SS4PLUS_MIN_PITCH_MM;\n\n\t} else {\n\t\tnum_x_electrode =\n\t\t\tSS4_NUMSENSOR_XOFFSET + (otp[1][0] & 0x0F);\n\t\tnum_y_electrode =\n\t\t\tSS4_NUMSENSOR_YOFFSET + ((otp[1][0] >> 4) & 0x0F);\n\n\t\tpriv->x_max =\n\t\t\t(num_x_electrode - 1) * SS4_COUNT_PER_ELECTRODE;\n\t\tpriv->y_max =\n\t\t\t(num_y_electrode - 1) * SS4_COUNT_PER_ELECTRODE;\n\n\t\tx_pitch = ((otp[1][2] >> 2) & 0x07) + SS4_MIN_PITCH_MM;\n\t\ty_pitch = ((otp[1][2] >> 5) & 0x07) + SS4_MIN_PITCH_MM;\n\t}\n\n\tx_phys = x_pitch * (num_x_electrode - 1);  \n\ty_phys = y_pitch * (num_y_electrode - 1);  \n\n\tpriv->x_res = priv->x_max * 10 / x_phys;  \n\tpriv->y_res = priv->y_max * 10 / y_phys;  \n\n\treturn 0;\n}\n\nstatic int alps_update_btn_info_ss4_v2(unsigned char otp[][4],\n\t\t\t\t       struct alps_data *priv)\n{\n\tunsigned char is_btnless;\n\n\tif (IS_SS4PLUS_DEV(priv->dev_id))\n\t\tis_btnless = (otp[1][0] >> 1) & 0x01;\n\telse\n\t\tis_btnless = (otp[1][1] >> 3) & 0x01;\n\n\tif (is_btnless)\n\t\tpriv->flags |= ALPS_BUTTONPAD;\n\n\treturn 0;\n}\n\nstatic int alps_update_dual_info_ss4_v2(unsigned char otp[][4],\n\t\t\t\t\tstruct alps_data *priv,\n\t\t\t\t\tstruct psmouse *psmouse)\n{\n\tbool is_dual = false;\n\tint reg_val = 0;\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\n\tif (IS_SS4PLUS_DEV(priv->dev_id)) {\n\t\tis_dual = (otp[0][0] >> 4) & 0x01;\n\n\t\tif (!is_dual) {\n\t\t\t \n\t\t\tif (alps_exit_command_mode(psmouse) == 0 &&\n\t\t\t\talps_enter_command_mode(psmouse) == 0) {\n\t\t\t\treg_val = alps_command_mode_read_reg(psmouse,\n\t\t\t\t\t\t\t\t\t0xD7);\n\t\t\t}\n\t\t\talps_exit_command_mode(psmouse);\n\t\t\tps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\n\n\t\t\tif (reg_val == 0x0C || reg_val == 0x1D)\n\t\t\t\tis_dual = true;\n\t\t}\n\t}\n\n\tif (is_dual)\n\t\tpriv->flags |= ALPS_DUALPOINT |\n\t\t\t\t\tALPS_DUALPOINT_WITH_PRESSURE;\n\n\treturn 0;\n}\n\nstatic int alps_set_defaults_ss4_v2(struct psmouse *psmouse,\n\t\t\t\t    struct alps_data *priv)\n{\n\tunsigned char otp[2][4];\n\n\tmemset(otp, 0, sizeof(otp));\n\n\tif (alps_get_otp_values_ss4_v2(psmouse, 1, &otp[1][0]) ||\n\t    alps_get_otp_values_ss4_v2(psmouse, 0, &otp[0][0]))\n\t\treturn -1;\n\n\talps_update_device_area_ss4_v2(otp, priv);\n\n\talps_update_btn_info_ss4_v2(otp, priv);\n\n\talps_update_dual_info_ss4_v2(otp, priv, psmouse);\n\n\treturn 0;\n}\n\nstatic int alps_dolphin_get_device_area(struct psmouse *psmouse,\n\t\t\t\t\tstruct alps_data *priv)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[4] = {0};\n\tint num_x_electrode, num_y_electrode;\n\n\tif (alps_enter_command_mode(psmouse))\n\t\treturn -1;\n\n\tparam[0] = 0x0a;\n\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETPOLL) ||\n\t    ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE))\n\t\treturn -1;\n\n\tif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\n\t\treturn -1;\n\n\t \n\tnum_x_electrode = DOLPHIN_PROFILE_XOFFSET + (param[2] & 0x0F);\n\tnum_y_electrode = DOLPHIN_PROFILE_YOFFSET + ((param[2] >> 4) & 0x0F);\n\tpriv->x_bits = num_x_electrode;\n\tpriv->y_bits = num_y_electrode;\n\tpriv->x_max = (num_x_electrode - 1) * DOLPHIN_COUNT_PER_ELECTRODE;\n\tpriv->y_max = (num_y_electrode - 1) * DOLPHIN_COUNT_PER_ELECTRODE;\n\n\tif (alps_exit_command_mode(psmouse))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_hw_init_dolphin_v1(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tunsigned char param[2];\n\n\t \n\tparam[0] = 0x64;\n\tparam[1] = 0x28;\n\n\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\n\t    ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int alps_hw_init_v7(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tint reg_val, ret = -1;\n\n\tif (alps_enter_command_mode(psmouse) ||\n\t    alps_command_mode_read_reg(psmouse, 0xc2d9) == -1)\n\t\tgoto error;\n\n\tif (alps_get_v3_v7_resolution(psmouse, 0xc397))\n\t\tgoto error;\n\n\tif (alps_command_mode_write_reg(psmouse, 0xc2c9, 0x64))\n\t\tgoto error;\n\n\treg_val = alps_command_mode_read_reg(psmouse, 0xc2c4);\n\tif (reg_val == -1)\n\t\tgoto error;\n\tif (__alps_command_mode_write_reg(psmouse, reg_val | 0x02))\n\t\tgoto error;\n\n\talps_exit_command_mode(psmouse);\n\treturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\n\nerror:\n\talps_exit_command_mode(psmouse);\n\treturn ret;\n}\n\nstatic int alps_hw_init_ss4_v2(struct psmouse *psmouse)\n{\n\tstruct ps2dev *ps2dev = &psmouse->ps2dev;\n\tchar param[2] = {0x64, 0x28};\n\tint ret = -1;\n\n\t \n\tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\n\t    ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\n\t    ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\n\t    ps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE)) {\n\t\tgoto error;\n\t}\n\n\t \n\tif (alps_exit_command_mode(psmouse) ||\n\t    alps_enter_command_mode(psmouse) ||\n\t    alps_command_mode_write_reg(psmouse, 0x001D, 0x20)) {\n\t\tgoto error;\n\t}\n\talps_exit_command_mode(psmouse);\n\n\treturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\n\nerror:\n\talps_exit_command_mode(psmouse);\n\treturn ret;\n}\n\nstatic int alps_set_protocol(struct psmouse *psmouse,\n\t\t\t     struct alps_data *priv,\n\t\t\t     const struct alps_protocol_info *protocol)\n{\n\tpsmouse->private = priv;\n\n\ttimer_setup(&priv->timer, alps_flush_packet, 0);\n\n\tpriv->proto_version = protocol->version;\n\tpriv->byte0 = protocol->byte0;\n\tpriv->mask0 = protocol->mask0;\n\tpriv->flags = protocol->flags;\n\n\tpriv->x_max = 2000;\n\tpriv->y_max = 1400;\n\tpriv->x_bits = 15;\n\tpriv->y_bits = 11;\n\n\tswitch (priv->proto_version) {\n\tcase ALPS_PROTO_V1:\n\tcase ALPS_PROTO_V2:\n\t\tpriv->hw_init = alps_hw_init_v1_v2;\n\t\tpriv->process_packet = alps_process_packet_v1_v2;\n\t\tpriv->set_abs_params = alps_set_abs_params_st;\n\t\tpriv->x_max = 1023;\n\t\tpriv->y_max = 767;\n\t\tif (dmi_check_system(alps_dmi_has_separate_stick_buttons))\n\t\t\tpriv->flags |= ALPS_STICK_BITS;\n\t\tbreak;\n\n\tcase ALPS_PROTO_V3:\n\t\tpriv->hw_init = alps_hw_init_v3;\n\t\tpriv->process_packet = alps_process_packet_v3;\n\t\tpriv->set_abs_params = alps_set_abs_params_semi_mt;\n\t\tpriv->decode_fields = alps_decode_pinnacle;\n\t\tpriv->nibble_commands = alps_v3_nibble_commands;\n\t\tpriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\n\n\t\tif (alps_probe_trackstick_v3_v7(psmouse,\n\t\t\t\t\t\tALPS_REG_BASE_PINNACLE) < 0)\n\t\t\tpriv->flags &= ~ALPS_DUALPOINT;\n\n\t\tbreak;\n\n\tcase ALPS_PROTO_V3_RUSHMORE:\n\t\tpriv->hw_init = alps_hw_init_rushmore_v3;\n\t\tpriv->process_packet = alps_process_packet_v3;\n\t\tpriv->set_abs_params = alps_set_abs_params_semi_mt;\n\t\tpriv->decode_fields = alps_decode_rushmore;\n\t\tpriv->nibble_commands = alps_v3_nibble_commands;\n\t\tpriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\n\t\tpriv->x_bits = 16;\n\t\tpriv->y_bits = 12;\n\n\t\tif (alps_probe_trackstick_v3_v7(psmouse,\n\t\t\t\t\t\tALPS_REG_BASE_RUSHMORE) < 0)\n\t\t\tpriv->flags &= ~ALPS_DUALPOINT;\n\n\t\tbreak;\n\n\tcase ALPS_PROTO_V4:\n\t\tpriv->hw_init = alps_hw_init_v4;\n\t\tpriv->process_packet = alps_process_packet_v4;\n\t\tpriv->set_abs_params = alps_set_abs_params_semi_mt;\n\t\tpriv->nibble_commands = alps_v4_nibble_commands;\n\t\tpriv->addr_command = PSMOUSE_CMD_DISABLE;\n\t\tbreak;\n\n\tcase ALPS_PROTO_V5:\n\t\tpriv->hw_init = alps_hw_init_dolphin_v1;\n\t\tpriv->process_packet = alps_process_touchpad_packet_v3_v5;\n\t\tpriv->decode_fields = alps_decode_dolphin;\n\t\tpriv->set_abs_params = alps_set_abs_params_semi_mt;\n\t\tpriv->nibble_commands = alps_v3_nibble_commands;\n\t\tpriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\n\t\tpriv->x_bits = 23;\n\t\tpriv->y_bits = 12;\n\n\t\tif (alps_dolphin_get_device_area(psmouse, priv))\n\t\t\treturn -EIO;\n\n\t\tbreak;\n\n\tcase ALPS_PROTO_V6:\n\t\tpriv->hw_init = alps_hw_init_v6;\n\t\tpriv->process_packet = alps_process_packet_v6;\n\t\tpriv->set_abs_params = alps_set_abs_params_st;\n\t\tpriv->nibble_commands = alps_v6_nibble_commands;\n\t\tpriv->x_max = 2047;\n\t\tpriv->y_max = 1535;\n\t\tbreak;\n\n\tcase ALPS_PROTO_V7:\n\t\tpriv->hw_init = alps_hw_init_v7;\n\t\tpriv->process_packet = alps_process_packet_v7;\n\t\tpriv->decode_fields = alps_decode_packet_v7;\n\t\tpriv->set_abs_params = alps_set_abs_params_v7;\n\t\tpriv->nibble_commands = alps_v3_nibble_commands;\n\t\tpriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\n\t\tpriv->x_max = 0xfff;\n\t\tpriv->y_max = 0x7ff;\n\n\t\tif (priv->fw_ver[1] != 0xba)\n\t\t\tpriv->flags |= ALPS_BUTTONPAD;\n\n\t\tif (alps_probe_trackstick_v3_v7(psmouse, ALPS_REG_BASE_V7) < 0)\n\t\t\tpriv->flags &= ~ALPS_DUALPOINT;\n\n\t\tbreak;\n\n\tcase ALPS_PROTO_V8:\n\t\tpriv->hw_init = alps_hw_init_ss4_v2;\n\t\tpriv->process_packet = alps_process_packet_ss4_v2;\n\t\tpriv->decode_fields = alps_decode_ss4_v2;\n\t\tpriv->set_abs_params = alps_set_abs_params_ss4_v2;\n\t\tpriv->nibble_commands = alps_v3_nibble_commands;\n\t\tpriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\n\n\t\tif (alps_set_defaults_ss4_v2(psmouse, priv))\n\t\t\treturn -EIO;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct alps_protocol_info *alps_match_table(unsigned char *e7,\n\t\t\t\t\t\t\t unsigned char *ec)\n{\n\tconst struct alps_model_info *model;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(alps_model_data); i++) {\n\t\tmodel = &alps_model_data[i];\n\n\t\tif (!memcmp(e7, model->signature, sizeof(model->signature)))\n\t\t\treturn &model->protocol_info;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool alps_is_cs19_trackpoint(struct psmouse *psmouse)\n{\n\tu8 param[2] = { 0 };\n\n\tif (ps2_command(&psmouse->ps2dev,\n\t\t\tparam, MAKE_PS2_CMD(0, 2, TP_READ_ID)))\n\t\treturn false;\n\n\t \n\treturn param[0] == TP_VARIANT_ALPS && ((param[1] & 0xf0) == 0x20);\n}\n\nstatic int alps_identify(struct psmouse *psmouse, struct alps_data *priv)\n{\n\tconst struct alps_protocol_info *protocol;\n\tunsigned char e6[4], e7[4], ec[4];\n\tint error;\n\n\t \n\tif (alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\n\t\t\t PSMOUSE_CMD_SETSCALE11, e6))\n\t\treturn -EIO;\n\n\tif ((e6[0] & 0xf8) != 0 || e6[1] != 0 || (e6[2] != 10 && e6[2] != 100))\n\t\treturn -EINVAL;\n\n\t \n\tif (alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\n\t\t\t PSMOUSE_CMD_SETSCALE21, e7) ||\n\t    alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\n\t\t\t PSMOUSE_CMD_RESET_WRAP, ec) ||\n\t    alps_exit_command_mode(psmouse))\n\t\treturn -EIO;\n\n\tprotocol = alps_match_table(e7, ec);\n\tif (!protocol) {\n\t\tif (e7[0] == 0x73 && e7[1] == 0x02 && e7[2] == 0x64 &&\n\t\t\t   ec[2] == 0x8a) {\n\t\t\tprotocol = &alps_v4_protocol_data;\n\t\t} else if (e7[0] == 0x73 && e7[1] == 0x03 && e7[2] == 0x50 &&\n\t\t\t   ec[0] == 0x73 && (ec[1] == 0x01 || ec[1] == 0x02)) {\n\t\t\tprotocol = &alps_v5_protocol_data;\n\t\t} else if (ec[0] == 0x88 &&\n\t\t\t   ((ec[1] & 0xf0) == 0xb0 || (ec[1] & 0xf0) == 0xc0)) {\n\t\t\tprotocol = &alps_v7_protocol_data;\n\t\t} else if (ec[0] == 0x88 && ec[1] == 0x08) {\n\t\t\tprotocol = &alps_v3_rushmore_data;\n\t\t} else if (ec[0] == 0x88 && ec[1] == 0x07 &&\n\t\t\t   ec[2] >= 0x90 && ec[2] <= 0x9d) {\n\t\t\tprotocol = &alps_v3_protocol_data;\n\t\t} else if (e7[0] == 0x73 && e7[1] == 0x03 &&\n\t\t\t   (e7[2] == 0x14 || e7[2] == 0x28)) {\n\t\t\tprotocol = &alps_v8_protocol_data;\n\t\t} else if (e7[0] == 0x73 && e7[1] == 0x03 && e7[2] == 0xc8) {\n\t\t\tprotocol = &alps_v9_protocol_data;\n\t\t\tpsmouse_warn(psmouse,\n\t\t\t\t     \"Unsupported ALPS V9 touchpad: E7=%3ph, EC=%3ph\\n\",\n\t\t\t\t     e7, ec);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tpsmouse_dbg(psmouse,\n\t\t\t\t    \"Likely not an ALPS touchpad: E7=%3ph, EC=%3ph\\n\", e7, ec);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (priv) {\n\t\t \n\t\tmemcpy(priv->dev_id, e7, 3);\n\t\tmemcpy(priv->fw_ver, ec, 3);\n\t\terror = alps_set_protocol(psmouse, priv, protocol);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_reconnect(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\n\tpsmouse_reset(psmouse);\n\n\tif (alps_identify(psmouse, priv) < 0)\n\t\treturn -1;\n\n\treturn priv->hw_init(psmouse);\n}\n\nstatic void alps_disconnect(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\n\tpsmouse_reset(psmouse);\n\ttimer_shutdown_sync(&priv->timer);\n\tif (priv->dev2)\n\t\tinput_unregister_device(priv->dev2);\n\tif (!IS_ERR_OR_NULL(priv->dev3))\n\t\tinput_unregister_device(priv->dev3);\n\tkfree(priv);\n}\n\nstatic void alps_set_abs_params_st(struct alps_data *priv,\n\t\t\t\t   struct input_dev *dev1)\n{\n\tinput_set_abs_params(dev1, ABS_X, 0, priv->x_max, 0, 0);\n\tinput_set_abs_params(dev1, ABS_Y, 0, priv->y_max, 0, 0);\n\tinput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\n}\n\nstatic void alps_set_abs_params_mt_common(struct alps_data *priv,\n\t\t\t\t\t  struct input_dev *dev1)\n{\n\tinput_set_abs_params(dev1, ABS_MT_POSITION_X, 0, priv->x_max, 0, 0);\n\tinput_set_abs_params(dev1, ABS_MT_POSITION_Y, 0, priv->y_max, 0, 0);\n\n\tinput_abs_set_res(dev1, ABS_MT_POSITION_X, priv->x_res);\n\tinput_abs_set_res(dev1, ABS_MT_POSITION_Y, priv->y_res);\n\n\tset_bit(BTN_TOOL_TRIPLETAP, dev1->keybit);\n\tset_bit(BTN_TOOL_QUADTAP, dev1->keybit);\n}\n\nstatic void alps_set_abs_params_semi_mt(struct alps_data *priv,\n\t\t\t\t\tstruct input_dev *dev1)\n{\n\talps_set_abs_params_mt_common(priv, dev1);\n\tinput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\n\n\tinput_mt_init_slots(dev1, MAX_TOUCHES,\n\t\t\t    INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\n\t\t\t\tINPUT_MT_SEMI_MT);\n}\n\nstatic void alps_set_abs_params_v7(struct alps_data *priv,\n\t\t\t\t   struct input_dev *dev1)\n{\n\talps_set_abs_params_mt_common(priv, dev1);\n\tset_bit(BTN_TOOL_QUINTTAP, dev1->keybit);\n\n\tinput_mt_init_slots(dev1, MAX_TOUCHES,\n\t\t\t    INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\n\t\t\t\tINPUT_MT_TRACK);\n\n\tset_bit(BTN_TOOL_QUINTTAP, dev1->keybit);\n}\n\nstatic void alps_set_abs_params_ss4_v2(struct alps_data *priv,\n\t\t\t\t       struct input_dev *dev1)\n{\n\talps_set_abs_params_mt_common(priv, dev1);\n\tinput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\n\tset_bit(BTN_TOOL_QUINTTAP, dev1->keybit);\n\n\tinput_mt_init_slots(dev1, MAX_TOUCHES,\n\t\t\t    INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\n\t\t\t\tINPUT_MT_TRACK);\n}\n\nint alps_init(struct psmouse *psmouse)\n{\n\tstruct alps_data *priv = psmouse->private;\n\tstruct input_dev *dev1 = psmouse->dev;\n\tint error;\n\n\terror = priv->hw_init(psmouse);\n\tif (error)\n\t\tgoto init_fail;\n\n\t \n\t__clear_bit(EV_REL, dev1->evbit);\n\t__clear_bit(REL_X, dev1->relbit);\n\t__clear_bit(REL_Y, dev1->relbit);\n\n\t \n\tdev1->evbit[BIT_WORD(EV_KEY)] |= BIT_MASK(EV_KEY);\n\tdev1->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);\n\tdev1->keybit[BIT_WORD(BTN_TOOL_FINGER)] |= BIT_MASK(BTN_TOOL_FINGER);\n\tdev1->keybit[BIT_WORD(BTN_LEFT)] |=\n\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\n\n\tdev1->evbit[BIT_WORD(EV_ABS)] |= BIT_MASK(EV_ABS);\n\n\tpriv->set_abs_params(priv, dev1);\n\n\tif (priv->flags & ALPS_WHEEL) {\n\t\tdev1->evbit[BIT_WORD(EV_REL)] |= BIT_MASK(EV_REL);\n\t\tdev1->relbit[BIT_WORD(REL_WHEEL)] |= BIT_MASK(REL_WHEEL);\n\t}\n\n\tif (priv->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\n\t\tdev1->keybit[BIT_WORD(BTN_FORWARD)] |= BIT_MASK(BTN_FORWARD);\n\t\tdev1->keybit[BIT_WORD(BTN_BACK)] |= BIT_MASK(BTN_BACK);\n\t}\n\n\tif (priv->flags & ALPS_FOUR_BUTTONS) {\n\t\tdev1->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_0);\n\t\tdev1->keybit[BIT_WORD(BTN_1)] |= BIT_MASK(BTN_1);\n\t\tdev1->keybit[BIT_WORD(BTN_2)] |= BIT_MASK(BTN_2);\n\t\tdev1->keybit[BIT_WORD(BTN_3)] |= BIT_MASK(BTN_3);\n\t} else if (priv->flags & ALPS_BUTTONPAD) {\n\t\tset_bit(INPUT_PROP_BUTTONPAD, dev1->propbit);\n\t\tclear_bit(BTN_RIGHT, dev1->keybit);\n\t} else {\n\t\tdev1->keybit[BIT_WORD(BTN_MIDDLE)] |= BIT_MASK(BTN_MIDDLE);\n\t}\n\n\tif (priv->flags & ALPS_DUALPOINT) {\n\t\tstruct input_dev *dev2;\n\n\t\tdev2 = input_allocate_device();\n\t\tif (!dev2) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"failed to allocate trackstick device\\n\");\n\t\t\terror = -ENOMEM;\n\t\t\tgoto init_fail;\n\t\t}\n\n\t\tsnprintf(priv->phys2, sizeof(priv->phys2), \"%s/input1\",\n\t\t\t psmouse->ps2dev.serio->phys);\n\t\tdev2->phys = priv->phys2;\n\n\t\t \n\t\tdev2->name = \"AlpsPS/2 ALPS DualPoint Stick\";\n\n\t\tdev2->id.bustype = BUS_I8042;\n\t\tdev2->id.vendor  = 0x0002;\n\t\tdev2->id.product = PSMOUSE_ALPS;\n\t\tdev2->id.version = priv->proto_version;\n\t\tdev2->dev.parent = &psmouse->ps2dev.serio->dev;\n\n\t\tinput_set_capability(dev2, EV_REL, REL_X);\n\t\tinput_set_capability(dev2, EV_REL, REL_Y);\n\t\tif (priv->flags & ALPS_DUALPOINT_WITH_PRESSURE) {\n\t\t\tinput_set_capability(dev2, EV_ABS, ABS_PRESSURE);\n\t\t\tinput_set_abs_params(dev2, ABS_PRESSURE, 0, 127, 0, 0);\n\t\t}\n\t\tinput_set_capability(dev2, EV_KEY, BTN_LEFT);\n\t\tinput_set_capability(dev2, EV_KEY, BTN_RIGHT);\n\t\tinput_set_capability(dev2, EV_KEY, BTN_MIDDLE);\n\n\t\t__set_bit(INPUT_PROP_POINTER, dev2->propbit);\n\t\t__set_bit(INPUT_PROP_POINTING_STICK, dev2->propbit);\n\n\t\terror = input_register_device(dev2);\n\t\tif (error) {\n\t\t\tpsmouse_err(psmouse,\n\t\t\t\t    \"failed to register trackstick device: %d\\n\",\n\t\t\t\t    error);\n\t\t\tinput_free_device(dev2);\n\t\t\tgoto init_fail;\n\t\t}\n\n\t\tpriv->dev2 = dev2;\n\t}\n\n\tpriv->psmouse = psmouse;\n\n\tINIT_DELAYED_WORK(&priv->dev3_register_work,\n\t\t\t  alps_register_bare_ps2_mouse);\n\n\tpsmouse->protocol_handler = alps_process_byte;\n\tpsmouse->poll = alps_poll;\n\tpsmouse->disconnect = alps_disconnect;\n\tpsmouse->reconnect = alps_reconnect;\n\tpsmouse->pktsize = priv->proto_version == ALPS_PROTO_V4 ? 8 : 6;\n\n\t \n\tpsmouse->resync_time = 0;\n\n\t \n\tpsmouse->resetafter = psmouse->pktsize * 2;\n\n\treturn 0;\n\ninit_fail:\n\tpsmouse_reset(psmouse);\n\t \n\tkfree(psmouse->private);\n\tpsmouse->private = NULL;\n\treturn error;\n}\n\nint alps_detect(struct psmouse *psmouse, bool set_properties)\n{\n\tstruct alps_data *priv;\n\tint error;\n\n\terror = alps_identify(psmouse, NULL);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (alps_is_cs19_trackpoint(psmouse)) {\n\t\tpsmouse_dbg(psmouse,\n\t\t\t    \"ALPS CS19 trackpoint-only device detected, ignoring\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpsmouse_reset(psmouse);\n\n\tpriv = kzalloc(sizeof(struct alps_data), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\terror = alps_identify(psmouse, priv);\n\tif (error) {\n\t\tkfree(priv);\n\t\treturn error;\n\t}\n\n\tif (set_properties) {\n\t\tpsmouse->vendor = \"ALPS\";\n\t\tpsmouse->name = priv->flags & ALPS_DUALPOINT ?\n\t\t\t\t\"DualPoint TouchPad\" : \"GlidePoint\";\n\t\tpsmouse->model = priv->proto_version;\n\t} else {\n\t\t \n\t\tkfree(priv);\n\t\tpsmouse->private = NULL;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}