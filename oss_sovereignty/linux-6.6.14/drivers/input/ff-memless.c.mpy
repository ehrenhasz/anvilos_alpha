{
  "module_name": "ff-memless.c",
  "hash_id": "2340c86709dad979877b12e391d01ee4ff5d418c66d829200214eef3b67fbc79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/ff-memless.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n#include <linux/fixp-arith.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Anssi Hannula <anssi.hannula@gmail.com>\");\nMODULE_DESCRIPTION(\"Force feedback support for memoryless devices\");\n\n \n#define FF_MEMLESS_EFFECTS\t16\n\n \n#define FF_ENVELOPE_INTERVAL\t50\n\n#define FF_EFFECT_STARTED\t0\n#define FF_EFFECT_PLAYING\t1\n#define FF_EFFECT_ABORTING\t2\n\nstruct ml_effect_state {\n\tstruct ff_effect *effect;\n\tunsigned long flags;\t \n\tint count;\t\t \n\tunsigned long play_at;\t \n\tunsigned long stop_at;\t \n\tunsigned long adj_at;\t \n};\n\nstruct ml_device {\n\tvoid *private;\n\tstruct ml_effect_state states[FF_MEMLESS_EFFECTS];\n\tint gain;\n\tstruct timer_list timer;\n\tstruct input_dev *dev;\n\n\tint (*play_effect)(struct input_dev *dev, void *data,\n\t\t\t   struct ff_effect *effect);\n};\n\nstatic const struct ff_envelope *get_envelope(const struct ff_effect *effect)\n{\n\tstatic const struct ff_envelope empty_envelope;\n\n\tswitch (effect->type) {\n\tcase FF_PERIODIC:\n\t\treturn &effect->u.periodic.envelope;\n\n\tcase FF_CONSTANT:\n\t\treturn &effect->u.constant.envelope;\n\n\tdefault:\n\t\treturn &empty_envelope;\n\t}\n}\n\n \nstatic unsigned long calculate_next_time(struct ml_effect_state *state)\n{\n\tconst struct ff_envelope *envelope = get_envelope(state->effect);\n\tunsigned long attack_stop, fade_start, next_fade;\n\n\tif (envelope->attack_length) {\n\t\tattack_stop = state->play_at +\n\t\t\tmsecs_to_jiffies(envelope->attack_length);\n\t\tif (time_before(state->adj_at, attack_stop))\n\t\t\treturn state->adj_at +\n\t\t\t\t\tmsecs_to_jiffies(FF_ENVELOPE_INTERVAL);\n\t}\n\n\tif (state->effect->replay.length) {\n\t\tif (envelope->fade_length) {\n\t\t\t \n\t\t\tfade_start = state->stop_at -\n\t\t\t\t\tmsecs_to_jiffies(envelope->fade_length);\n\n\t\t\tif (time_before(state->adj_at, fade_start))\n\t\t\t\treturn fade_start;\n\n\t\t\t \n\t\t\tnext_fade = state->adj_at +\n\t\t\t\t\tmsecs_to_jiffies(FF_ENVELOPE_INTERVAL);\n\t\t\tif (time_before(next_fade, state->stop_at))\n\t\t\t\treturn next_fade;\n\t\t}\n\n\t\treturn state->stop_at;\n\t}\n\n\treturn state->play_at;\n}\n\nstatic void ml_schedule_timer(struct ml_device *ml)\n{\n\tstruct ml_effect_state *state;\n\tunsigned long now = jiffies;\n\tunsigned long earliest = 0;\n\tunsigned long next_at;\n\tint events = 0;\n\tint i;\n\n\tpr_debug(\"calculating next timer\\n\");\n\n\tfor (i = 0; i < FF_MEMLESS_EFFECTS; i++) {\n\n\t\tstate = &ml->states[i];\n\n\t\tif (!test_bit(FF_EFFECT_STARTED, &state->flags))\n\t\t\tcontinue;\n\n\t\tif (test_bit(FF_EFFECT_PLAYING, &state->flags))\n\t\t\tnext_at = calculate_next_time(state);\n\t\telse\n\t\t\tnext_at = state->play_at;\n\n\t\tif (time_before_eq(now, next_at) &&\n\t\t    (++events == 1 || time_before(next_at, earliest)))\n\t\t\tearliest = next_at;\n\t}\n\n\tif (!events) {\n\t\tpr_debug(\"no actions\\n\");\n\t\tdel_timer(&ml->timer);\n\t} else {\n\t\tpr_debug(\"timer set\\n\");\n\t\tmod_timer(&ml->timer, earliest);\n\t}\n}\n\n \nstatic int apply_envelope(struct ml_effect_state *state, int value,\n\t\t\t  struct ff_envelope *envelope)\n{\n\tstruct ff_effect *effect = state->effect;\n\tunsigned long now = jiffies;\n\tint time_from_level;\n\tint time_of_envelope;\n\tint envelope_level;\n\tint difference;\n\n\tif (envelope->attack_length &&\n\t    time_before(now,\n\t\t\tstate->play_at + msecs_to_jiffies(envelope->attack_length))) {\n\t\tpr_debug(\"value = 0x%x, attack_level = 0x%x\\n\",\n\t\t\t value, envelope->attack_level);\n\t\ttime_from_level = jiffies_to_msecs(now - state->play_at);\n\t\ttime_of_envelope = envelope->attack_length;\n\t\tenvelope_level = min_t(u16, envelope->attack_level, 0x7fff);\n\n\t} else if (envelope->fade_length && effect->replay.length &&\n\t\t   time_after(now,\n\t\t\t      state->stop_at - msecs_to_jiffies(envelope->fade_length)) &&\n\t\t   time_before(now, state->stop_at)) {\n\t\ttime_from_level = jiffies_to_msecs(state->stop_at - now);\n\t\ttime_of_envelope = envelope->fade_length;\n\t\tenvelope_level = min_t(u16, envelope->fade_level, 0x7fff);\n\t} else\n\t\treturn value;\n\n\tdifference = abs(value) - envelope_level;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\tpr_debug(\"time_from_level = 0x%x\\n\", time_from_level);\n\tpr_debug(\"time_of_envelope = 0x%x\\n\", time_of_envelope);\n\n\tdifference = difference * time_from_level / time_of_envelope;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\n\treturn value < 0 ?\n\t\t-(difference + envelope_level) : (difference + envelope_level);\n}\n\n \nstatic int get_compatible_type(struct ff_device *ff, int effect_type)\n{\n\n\tif (test_bit(effect_type, ff->ffbit))\n\t\treturn effect_type;\n\n\tif (effect_type == FF_PERIODIC && test_bit(FF_RUMBLE, ff->ffbit))\n\t\treturn FF_RUMBLE;\n\n\tpr_err(\"invalid type in get_compatible_type()\\n\");\n\n\treturn 0;\n}\n\n \nstatic u16 ml_calculate_direction(u16 direction, u16 force,\n\t\t\t\t  u16 new_direction, u16 new_force)\n{\n\tif (!force)\n\t\treturn new_direction;\n\tif (!new_force)\n\t\treturn direction;\n\treturn (((u32)(direction >> 1) * force +\n\t\t (new_direction >> 1) * new_force) /\n\t\t(force + new_force)) << 1;\n}\n\n#define FRAC_N 8\nstatic inline s16 fixp_new16(s16 a)\n{\n\treturn ((s32)a) >> (16 - FRAC_N);\n}\n\nstatic inline s16 fixp_mult(s16 a, s16 b)\n{\n\ta = ((s32)a * 0x100) / 0x7fff;\n\treturn ((s32)(a * b)) >> FRAC_N;\n}\n\n \nstatic void ml_combine_effects(struct ff_effect *effect,\n\t\t\t       struct ml_effect_state *state,\n\t\t\t       int gain)\n{\n\tstruct ff_effect *new = state->effect;\n\tunsigned int strong, weak, i;\n\tint x, y;\n\ts16 level;\n\n\tswitch (new->type) {\n\tcase FF_CONSTANT:\n\t\ti = new->direction * 360 / 0xffff;\n\t\tlevel = fixp_new16(apply_envelope(state,\n\t\t\t\t\tnew->u.constant.level,\n\t\t\t\t\t&new->u.constant.envelope));\n\t\tx = fixp_mult(fixp_sin16(i), level) * gain / 0xffff;\n\t\ty = fixp_mult(-fixp_cos16(i), level) * gain / 0xffff;\n\t\t \n\t\teffect->u.ramp.start_level =\n\t\t\tclamp_val(effect->u.ramp.start_level + x, -0x80, 0x7f);\n\t\teffect->u.ramp.end_level =\n\t\t\tclamp_val(effect->u.ramp.end_level + y, -0x80, 0x7f);\n\t\tbreak;\n\n\tcase FF_RUMBLE:\n\t\tstrong = (u32)new->u.rumble.strong_magnitude * gain / 0xffff;\n\t\tweak = (u32)new->u.rumble.weak_magnitude * gain / 0xffff;\n\n\t\tif (effect->u.rumble.strong_magnitude + strong)\n\t\t\teffect->direction = ml_calculate_direction(\n\t\t\t\teffect->direction,\n\t\t\t\teffect->u.rumble.strong_magnitude,\n\t\t\t\tnew->direction, strong);\n\t\telse if (effect->u.rumble.weak_magnitude + weak)\n\t\t\teffect->direction = ml_calculate_direction(\n\t\t\t\teffect->direction,\n\t\t\t\teffect->u.rumble.weak_magnitude,\n\t\t\t\tnew->direction, weak);\n\t\telse\n\t\t\teffect->direction = 0;\n\t\teffect->u.rumble.strong_magnitude =\n\t\t\tmin(strong + effect->u.rumble.strong_magnitude,\n\t\t\t    0xffffU);\n\t\teffect->u.rumble.weak_magnitude =\n\t\t\tmin(weak + effect->u.rumble.weak_magnitude, 0xffffU);\n\t\tbreak;\n\n\tcase FF_PERIODIC:\n\t\ti = apply_envelope(state, abs(new->u.periodic.magnitude),\n\t\t\t\t   &new->u.periodic.envelope);\n\n\t\t \n\t\ti = i * gain / 0x7fff;\n\n\t\tif (effect->u.rumble.strong_magnitude + i)\n\t\t\teffect->direction = ml_calculate_direction(\n\t\t\t\teffect->direction,\n\t\t\t\teffect->u.rumble.strong_magnitude,\n\t\t\t\tnew->direction, i);\n\t\telse\n\t\t\teffect->direction = 0;\n\t\teffect->u.rumble.strong_magnitude =\n\t\t\tmin(i + effect->u.rumble.strong_magnitude, 0xffffU);\n\t\teffect->u.rumble.weak_magnitude =\n\t\t\tmin(i + effect->u.rumble.weak_magnitude, 0xffffU);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"invalid type in ml_combine_effects()\\n\");\n\t\tbreak;\n\t}\n\n}\n\n\n \nstatic int ml_get_combo_effect(struct ml_device *ml,\n\t\t\t       unsigned long *effect_handled,\n\t\t\t       struct ff_effect *combo_effect)\n{\n\tstruct ff_effect *effect;\n\tstruct ml_effect_state *state;\n\tint effect_type;\n\tint i;\n\n\tmemset(combo_effect, 0, sizeof(struct ff_effect));\n\n\tfor (i = 0; i < FF_MEMLESS_EFFECTS; i++) {\n\t\tif (__test_and_set_bit(i, effect_handled))\n\t\t\tcontinue;\n\n\t\tstate = &ml->states[i];\n\t\teffect = state->effect;\n\n\t\tif (!test_bit(FF_EFFECT_STARTED, &state->flags))\n\t\t\tcontinue;\n\n\t\tif (time_before(jiffies, state->play_at))\n\t\t\tcontinue;\n\n\t\t \n\t\teffect_type = get_compatible_type(ml->dev->ff, effect->type);\n\t\tif (combo_effect->type != effect_type) {\n\t\t\tif (combo_effect->type != 0) {\n\t\t\t\t__clear_bit(i, effect_handled);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcombo_effect->type = effect_type;\n\t\t}\n\n\t\tif (__test_and_clear_bit(FF_EFFECT_ABORTING, &state->flags)) {\n\t\t\t__clear_bit(FF_EFFECT_PLAYING, &state->flags);\n\t\t\t__clear_bit(FF_EFFECT_STARTED, &state->flags);\n\t\t} else if (effect->replay.length &&\n\t\t\t   time_after_eq(jiffies, state->stop_at)) {\n\n\t\t\t__clear_bit(FF_EFFECT_PLAYING, &state->flags);\n\n\t\t\tif (--state->count <= 0) {\n\t\t\t\t__clear_bit(FF_EFFECT_STARTED, &state->flags);\n\t\t\t} else {\n\t\t\t\tstate->play_at = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(effect->replay.delay);\n\t\t\t\tstate->stop_at = state->play_at +\n\t\t\t\t\tmsecs_to_jiffies(effect->replay.length);\n\t\t\t}\n\t\t} else {\n\t\t\t__set_bit(FF_EFFECT_PLAYING, &state->flags);\n\t\t\tstate->adj_at = jiffies;\n\t\t\tml_combine_effects(combo_effect, state, ml->gain);\n\t\t}\n\t}\n\n\treturn combo_effect->type != 0;\n}\n\nstatic void ml_play_effects(struct ml_device *ml)\n{\n\tstruct ff_effect effect;\n\tDECLARE_BITMAP(handled_bm, FF_MEMLESS_EFFECTS);\n\n\tmemset(handled_bm, 0, sizeof(handled_bm));\n\n\twhile (ml_get_combo_effect(ml, handled_bm, &effect))\n\t\tml->play_effect(ml->dev, ml->private, &effect);\n\n\tml_schedule_timer(ml);\n}\n\nstatic void ml_effect_timer(struct timer_list *t)\n{\n\tstruct ml_device *ml = from_timer(ml, t, timer);\n\tstruct input_dev *dev = ml->dev;\n\tunsigned long flags;\n\n\tpr_debug(\"timer: updating effects\\n\");\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tml_play_effects(ml);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\n \nstatic void ml_ff_set_gain(struct input_dev *dev, u16 gain)\n{\n\tstruct ml_device *ml = dev->ff->private;\n\tint i;\n\n\tml->gain = gain;\n\n\tfor (i = 0; i < FF_MEMLESS_EFFECTS; i++)\n\t\t__clear_bit(FF_EFFECT_PLAYING, &ml->states[i].flags);\n\n\tml_play_effects(ml);\n}\n\n \nstatic int ml_ff_playback(struct input_dev *dev, int effect_id, int value)\n{\n\tstruct ml_device *ml = dev->ff->private;\n\tstruct ml_effect_state *state = &ml->states[effect_id];\n\n\tif (value > 0) {\n\t\tpr_debug(\"initiated play\\n\");\n\n\t\t__set_bit(FF_EFFECT_STARTED, &state->flags);\n\t\tstate->count = value;\n\t\tstate->play_at = jiffies +\n\t\t\t\t msecs_to_jiffies(state->effect->replay.delay);\n\t\tstate->stop_at = state->play_at +\n\t\t\t\t msecs_to_jiffies(state->effect->replay.length);\n\t\tstate->adj_at = state->play_at;\n\n\t} else {\n\t\tpr_debug(\"initiated stop\\n\");\n\n\t\tif (test_bit(FF_EFFECT_PLAYING, &state->flags))\n\t\t\t__set_bit(FF_EFFECT_ABORTING, &state->flags);\n\t\telse\n\t\t\t__clear_bit(FF_EFFECT_STARTED, &state->flags);\n\t}\n\n\tml_play_effects(ml);\n\n\treturn 0;\n}\n\nstatic int ml_ff_upload(struct input_dev *dev,\n\t\t\tstruct ff_effect *effect, struct ff_effect *old)\n{\n\tstruct ml_device *ml = dev->ff->private;\n\tstruct ml_effect_state *state = &ml->states[effect->id];\n\n\tspin_lock_irq(&dev->event_lock);\n\n\tif (test_bit(FF_EFFECT_STARTED, &state->flags)) {\n\t\t__clear_bit(FF_EFFECT_PLAYING, &state->flags);\n\t\tstate->play_at = jiffies +\n\t\t\t\t msecs_to_jiffies(state->effect->replay.delay);\n\t\tstate->stop_at = state->play_at +\n\t\t\t\t msecs_to_jiffies(state->effect->replay.length);\n\t\tstate->adj_at = state->play_at;\n\t\tml_schedule_timer(ml);\n\t}\n\n\tspin_unlock_irq(&dev->event_lock);\n\n\treturn 0;\n}\n\nstatic void ml_ff_destroy(struct ff_device *ff)\n{\n\tstruct ml_device *ml = ff->private;\n\n\t \n\tdel_timer_sync(&ml->timer);\n\n\tkfree(ml->private);\n}\n\n \nint input_ff_create_memless(struct input_dev *dev, void *data,\n\t\tint (*play_effect)(struct input_dev *, void *, struct ff_effect *))\n{\n\tstruct ml_device *ml;\n\tstruct ff_device *ff;\n\tint error;\n\tint i;\n\n\tml = kzalloc(sizeof(struct ml_device), GFP_KERNEL);\n\tif (!ml)\n\t\treturn -ENOMEM;\n\n\tml->dev = dev;\n\tml->private = data;\n\tml->play_effect = play_effect;\n\tml->gain = 0xffff;\n\ttimer_setup(&ml->timer, ml_effect_timer, 0);\n\n\tset_bit(FF_GAIN, dev->ffbit);\n\n\terror = input_ff_create(dev, FF_MEMLESS_EFFECTS);\n\tif (error) {\n\t\tkfree(ml);\n\t\treturn error;\n\t}\n\n\tff = dev->ff;\n\tff->private = ml;\n\tff->upload = ml_ff_upload;\n\tff->playback = ml_ff_playback;\n\tff->set_gain = ml_ff_set_gain;\n\tff->destroy = ml_ff_destroy;\n\n\t \n\tif (test_bit(FF_RUMBLE, ff->ffbit)) {\n\t\tset_bit(FF_PERIODIC, dev->ffbit);\n\t\tset_bit(FF_SINE, dev->ffbit);\n\t\tset_bit(FF_TRIANGLE, dev->ffbit);\n\t\tset_bit(FF_SQUARE, dev->ffbit);\n\t}\n\n\tfor (i = 0; i < FF_MEMLESS_EFFECTS; i++)\n\t\tml->states[i].effect = &ff->effects[i];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(input_ff_create_memless);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}