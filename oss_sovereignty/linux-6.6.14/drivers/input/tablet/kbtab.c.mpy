{
  "module_name": "kbtab.c",
  "hash_id": "04a7277441d88a7fa600ac6c41772cb84cd93b7c11afe9ae4ea04e36149354cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/tablet/kbtab.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n#include <asm/unaligned.h>\n\n \n\nMODULE_AUTHOR(\"Josh Myer <josh@joshisanerd.com>\");\nMODULE_DESCRIPTION(\"USB KB Gear JamStudio Tablet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define USB_VENDOR_ID_KBGEAR\t0x084e\n\nstatic int kb_pressure_click = 0x10;\nmodule_param(kb_pressure_click, int, 0);\nMODULE_PARM_DESC(kb_pressure_click, \"pressure threshold for clicks\");\n\nstruct kbtab {\n\tunsigned char *data;\n\tdma_addr_t data_dma;\n\tstruct input_dev *dev;\n\tstruct usb_interface *intf;\n\tstruct urb *irq;\n\tchar phys[32];\n};\n\nstatic void kbtab_irq(struct urb *urb)\n{\n\tstruct kbtab *kbtab = urb->context;\n\tunsigned char *data = kbtab->data;\n\tstruct input_dev *dev = kbtab->dev;\n\tint pressure;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&kbtab->intf->dev,\n\t\t\t\"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&kbtab->intf->dev,\n\t\t\t\"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\n\tinput_report_key(dev, BTN_TOOL_PEN, 1);\n\n\tinput_report_abs(dev, ABS_X, get_unaligned_le16(&data[1]));\n\tinput_report_abs(dev, ABS_Y, get_unaligned_le16(&data[3]));\n\n\t \n\tinput_report_key(dev, BTN_RIGHT, data[0] & 0x02);\n\n\tpressure = data[5];\n\tif (kb_pressure_click == -1)\n\t\tinput_report_abs(dev, ABS_PRESSURE, pressure);\n\telse\n\t\tinput_report_key(dev, BTN_LEFT, pressure > kb_pressure_click ? 1 : 0);\n\n\tinput_sync(dev);\n\n exit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&kbtab->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic const struct usb_device_id kbtab_ids[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_KBGEAR, 0x1001), .driver_info = 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, kbtab_ids);\n\nstatic int kbtab_open(struct input_dev *dev)\n{\n\tstruct kbtab *kbtab = input_get_drvdata(dev);\n\tstruct usb_device *udev = interface_to_usbdev(kbtab->intf);\n\n\tkbtab->irq->dev = udev;\n\tif (usb_submit_urb(kbtab->irq, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void kbtab_close(struct input_dev *dev)\n{\n\tstruct kbtab *kbtab = input_get_drvdata(dev);\n\n\tusb_kill_urb(kbtab->irq);\n}\n\nstatic int kbtab_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct kbtab *kbtab;\n\tstruct input_dev *input_dev;\n\tint error = -ENOMEM;\n\n\tif (intf->cur_altsetting->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tendpoint = &intf->cur_altsetting->endpoint[0].desc;\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -ENODEV;\n\n\tkbtab = kzalloc(sizeof(struct kbtab), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!kbtab || !input_dev)\n\t\tgoto fail1;\n\n\tkbtab->data = usb_alloc_coherent(dev, 8, GFP_KERNEL, &kbtab->data_dma);\n\tif (!kbtab->data)\n\t\tgoto fail1;\n\n\tkbtab->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!kbtab->irq)\n\t\tgoto fail2;\n\n\tkbtab->intf = intf;\n\tkbtab->dev = input_dev;\n\n\tusb_make_path(dev, kbtab->phys, sizeof(kbtab->phys));\n\tstrlcat(kbtab->phys, \"/input0\", sizeof(kbtab->phys));\n\n\tinput_dev->name = \"KB Gear Tablet\";\n\tinput_dev->phys = kbtab->phys;\n\tusb_to_input_id(dev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, kbtab);\n\n\tinput_dev->open = kbtab_open;\n\tinput_dev->close = kbtab_close;\n\n\tinput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_LEFT)] |=\n\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\n\tinput_dev->keybit[BIT_WORD(BTN_DIGI)] |=\n\t\tBIT_MASK(BTN_TOOL_PEN) | BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X, 0, 0x2000, 4, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 0x1750, 4, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 0xff, 0, 0);\n\n\tusb_fill_int_urb(kbtab->irq, dev,\n\t\t\t usb_rcvintpipe(dev, endpoint->bEndpointAddress),\n\t\t\t kbtab->data, 8,\n\t\t\t kbtab_irq, kbtab, endpoint->bInterval);\n\tkbtab->irq->transfer_dma = kbtab->data_dma;\n\tkbtab->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\terror = input_register_device(kbtab->dev);\n\tif (error)\n\t\tgoto fail3;\n\n\tusb_set_intfdata(intf, kbtab);\n\n\treturn 0;\n\n fail3:\tusb_free_urb(kbtab->irq);\n fail2:\tusb_free_coherent(dev, 8, kbtab->data, kbtab->data_dma);\n fail1:\tinput_free_device(input_dev);\n\tkfree(kbtab);\n\treturn error;\n}\n\nstatic void kbtab_disconnect(struct usb_interface *intf)\n{\n\tstruct kbtab *kbtab = usb_get_intfdata(intf);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tinput_unregister_device(kbtab->dev);\n\tusb_free_urb(kbtab->irq);\n\tusb_free_coherent(udev, 8, kbtab->data, kbtab->data_dma);\n\tkfree(kbtab);\n}\n\nstatic struct usb_driver kbtab_driver = {\n\t.name =\t\t\"kbtab\",\n\t.probe =\tkbtab_probe,\n\t.disconnect =\tkbtab_disconnect,\n\t.id_table =\tkbtab_ids,\n};\n\nmodule_usb_driver(kbtab_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}