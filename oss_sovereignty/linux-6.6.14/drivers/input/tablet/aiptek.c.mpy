{
  "module_name": "aiptek.c",
  "hash_id": "fd4891d2b6bcaeb0f616df3dff02e8e17543cefdb2fde7d396277ed9d3bb41bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/tablet/aiptek.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n \n\n#define USB_VENDOR_ID_AIPTEK\t\t\t\t0x08ca\n#define USB_VENDOR_ID_KYE\t\t\t\t0x0458\n#define USB_REQ_GET_REPORT\t\t\t\t0x01\n#define USB_REQ_SET_REPORT\t\t\t\t0x09\n\n\t \n#define AIPTEK_POINTER_ONLY_MOUSE_MODE\t\t\t0\n#define AIPTEK_POINTER_ONLY_STYLUS_MODE\t\t\t1\n#define AIPTEK_POINTER_EITHER_MODE\t\t\t2\n\n#define AIPTEK_POINTER_ALLOW_MOUSE_MODE(a)\t\t\\\n\t(a == AIPTEK_POINTER_ONLY_MOUSE_MODE ||\t\t\\\n\t a == AIPTEK_POINTER_EITHER_MODE)\n#define AIPTEK_POINTER_ALLOW_STYLUS_MODE(a)\t\t\\\n\t(a == AIPTEK_POINTER_ONLY_STYLUS_MODE ||\t\\\n\t a == AIPTEK_POINTER_EITHER_MODE)\n\n\t \n#define AIPTEK_COORDINATE_RELATIVE_MODE\t\t\t0\n#define AIPTEK_COORDINATE_ABSOLUTE_MODE\t\t\t1\n\n        \n#define AIPTEK_TILT_MIN\t\t\t\t\t(-128)\n#define AIPTEK_TILT_MAX\t\t\t\t\t127\n#define AIPTEK_TILT_DISABLE\t\t\t\t(-10101)\n\n\t \n#define AIPTEK_WHEEL_MIN\t\t\t\t0\n#define AIPTEK_WHEEL_MAX\t\t\t\t1024\n#define AIPTEK_WHEEL_DISABLE\t\t\t\t(-10101)\n\n\t \n\t \n#define AIPTEK_TOOL_BUTTON_PEN_MODE\t\t\tBTN_TOOL_PEN\n#define AIPTEK_TOOL_BUTTON_PENCIL_MODE\t\t\tBTN_TOOL_PENCIL\n#define AIPTEK_TOOL_BUTTON_BRUSH_MODE\t\t\tBTN_TOOL_BRUSH\n#define AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE\t\tBTN_TOOL_AIRBRUSH\n#define AIPTEK_TOOL_BUTTON_ERASER_MODE\t\t\tBTN_TOOL_RUBBER\n#define AIPTEK_TOOL_BUTTON_MOUSE_MODE\t\t\tBTN_TOOL_MOUSE\n#define AIPTEK_TOOL_BUTTON_LENS_MODE\t\t\tBTN_TOOL_LENS\n\n\t \n#define AIPTEK_DIAGNOSTIC_NA\t\t\t\t0\n#define AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE\t1\n#define AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE\t2\n#define AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED\t\t3\n\n\t \n#define AIPTEK_JITTER_DELAY_DEFAULT\t\t\t50\n\n\t \n#define AIPTEK_PROGRAMMABLE_DELAY_25\t\t25\n#define AIPTEK_PROGRAMMABLE_DELAY_50\t\t50\n#define AIPTEK_PROGRAMMABLE_DELAY_100\t\t100\n#define AIPTEK_PROGRAMMABLE_DELAY_200\t\t200\n#define AIPTEK_PROGRAMMABLE_DELAY_300\t\t300\n#define AIPTEK_PROGRAMMABLE_DELAY_400\t\t400\n#define AIPTEK_PROGRAMMABLE_DELAY_DEFAULT\tAIPTEK_PROGRAMMABLE_DELAY_400\n\n\t \n#define AIPTEK_MOUSE_LEFT_BUTTON\t\t0x04\n#define AIPTEK_MOUSE_RIGHT_BUTTON\t\t0x08\n#define AIPTEK_MOUSE_MIDDLE_BUTTON\t\t0x10\n\n\t \n#define AIPTEK_STYLUS_LOWER_BUTTON\t\t0x08\n#define AIPTEK_STYLUS_UPPER_BUTTON\t\t0x10\n\n\t \n#define AIPTEK_PACKET_LENGTH\t\t\t8\n\n\t \n#define AIPTEK_REPORT_TOOL_UNKNOWN\t\t0x10\n#define AIPTEK_REPORT_TOOL_STYLUS\t\t0x20\n#define AIPTEK_REPORT_TOOL_MOUSE\t\t0x40\n\nstatic int programmableDelay = AIPTEK_PROGRAMMABLE_DELAY_DEFAULT;\nstatic int jitterDelay = AIPTEK_JITTER_DELAY_DEFAULT;\n\nstruct aiptek_features {\n\tint odmCode;\t\t \n\tint modelCode;\t\t \n\tint firmwareCode;\t \n\tchar usbPath[64 + 1];\t \n};\n\nstruct aiptek_settings {\n\tint pointerMode;\t \n\tint coordinateMode;\t \n\tint toolMode;\t\t \n\tint xTilt;\t\t \n\tint yTilt;\t\t \n\tint wheel;\t\t \n\tint stylusButtonUpper;\t \n\tint stylusButtonLower;\t \n\tint mouseButtonLeft;\t \n\tint mouseButtonMiddle;\t \n\tint mouseButtonRight;\t \n\tint programmableDelay;\t \n\tint jitterDelay;\t \n};\n\nstruct aiptek {\n\tstruct input_dev *inputdev;\t\t \n\tstruct usb_interface *intf;\t\t \n\tstruct urb *urb;\t\t\t \n\tdma_addr_t data_dma;\t\t\t \n\tstruct aiptek_features features;\t \n\tstruct aiptek_settings curSetting;\t \n\tstruct aiptek_settings newSetting;\t \n\tunsigned int ifnum;\t\t\t \n\tint diagnostic;\t\t\t\t \n\tunsigned long eventCount;\t\t \n\tint inDelay;\t\t\t\t \n\tunsigned long endDelay;\t\t\t \n\tint previousJitterable;\t\t\t \n\n\tint lastMacro;\t\t\t\t \n\tint previousToolMode;\t\t\t \n\tunsigned char *data;\t\t\t \n};\n\nstatic const int eventTypes[] = {\n        EV_KEY, EV_ABS, EV_REL, EV_MSC,\n};\n\nstatic const int absEvents[] = {\n        ABS_X, ABS_Y, ABS_PRESSURE, ABS_TILT_X, ABS_TILT_Y,\n        ABS_WHEEL, ABS_MISC,\n};\n\nstatic const int relEvents[] = {\n        REL_X, REL_Y, REL_WHEEL,\n};\n\nstatic const int buttonEvents[] = {\n\tBTN_LEFT, BTN_RIGHT, BTN_MIDDLE,\n\tBTN_TOOL_PEN, BTN_TOOL_RUBBER, BTN_TOOL_PENCIL, BTN_TOOL_AIRBRUSH,\n\tBTN_TOOL_BRUSH, BTN_TOOL_MOUSE, BTN_TOOL_LENS, BTN_TOUCH,\n\tBTN_STYLUS, BTN_STYLUS2,\n};\n\n \nstatic const int macroKeyEvents[] = {\n\tKEY_ESC, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5,\n\tKEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11,\n\tKEY_F12, KEY_F13, KEY_F14, KEY_F15, KEY_F16, KEY_F17,\n\tKEY_F18, KEY_F19, KEY_F20, KEY_F21, KEY_F22, KEY_F23,\n\tKEY_F24, KEY_STOP, KEY_AGAIN, KEY_PROPS, KEY_UNDO,\n\tKEY_FRONT, KEY_COPY, KEY_OPEN, KEY_PASTE, 0\n};\n\n \n#define AIPTEK_INVALID_VALUE\t-1\n\nstruct aiptek_map {\n\tconst char *string;\n\tint value;\n};\n\nstatic int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)\n{\n\tconst struct aiptek_map *p;\n\n\tif (str[count - 1] == '\\n')\n\t\tcount--;\n\n\tfor (p = map; p->string; p++)\n\t        if (!strncmp(str, p->string, count))\n\t\t\treturn p->value;\n\n\treturn AIPTEK_INVALID_VALUE;\n}\n\nstatic const char *map_val_to_str(const struct aiptek_map *map, int val)\n{\n\tconst struct aiptek_map *p;\n\n\tfor (p = map; p->value != AIPTEK_INVALID_VALUE; p++)\n\t\tif (val == p->value)\n\t\t\treturn p->string;\n\n\treturn \"unknown\";\n}\n\n \n\nstatic void aiptek_irq(struct urb *urb)\n{\n\tstruct aiptek *aiptek = urb->context;\n\tunsigned char *data = aiptek->data;\n\tstruct input_dev *inputdev = aiptek->inputdev;\n\tstruct usb_interface *intf = aiptek->intf;\n\tint jitterable = 0;\n\tint retval, macro, x, y, z, left, right, middle, p, dv, tip, bs, pck;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&intf->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\n\tdefault:\n\t\tdev_dbg(&intf->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (aiptek->inDelay == 1 && time_after(aiptek->endDelay, jiffies)) {\n\t\tgoto exit;\n\t}\n\n\taiptek->inDelay = 0;\n\taiptek->eventCount++;\n\n\t \n\tif (data[0] == 1) {\n\t\tif (aiptek->curSetting.coordinateMode ==\n\t\t    AIPTEK_COORDINATE_ABSOLUTE_MODE) {\n\t\t\taiptek->diagnostic =\n\t\t\t    AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE;\n\t\t} else {\n\t\t\tx = (signed char) data[2];\n\t\t\ty = (signed char) data[3];\n\n\t\t\t \n\t\t\tjitterable = data[1] & 0x07;\n\n\t\t\tleft = (data[1] & aiptek->curSetting.mouseButtonLeft >> 2) != 0 ? 1 : 0;\n\t\t\tright = (data[1] & aiptek->curSetting.mouseButtonRight >> 2) != 0 ? 1 : 0;\n\t\t\tmiddle = (data[1] & aiptek->curSetting.mouseButtonMiddle >> 2) != 0 ? 1 : 0;\n\n\t\t\tinput_report_key(inputdev, BTN_LEFT, left);\n\t\t\tinput_report_key(inputdev, BTN_MIDDLE, middle);\n\t\t\tinput_report_key(inputdev, BTN_RIGHT, right);\n\n\t\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t\t 1 | AIPTEK_REPORT_TOOL_UNKNOWN);\n\t\t\tinput_report_rel(inputdev, REL_X, x);\n\t\t\tinput_report_rel(inputdev, REL_Y, y);\n\n\t\t\t \n\t\t\tif (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {\n\t\t\t\tinput_report_rel(inputdev, REL_WHEEL,\n\t\t\t\t\t\t aiptek->curSetting.wheel);\n\t\t\t\taiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\n\t\t\t}\n\t\t\tif (aiptek->lastMacro != -1) {\n\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\t\taiptek->lastMacro = -1;\n\t\t\t}\n\t\t\tinput_sync(inputdev);\n\t\t}\n\t}\n\t \n\telse if (data[0] == 2) {\n\t\tif (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {\n\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;\n\t\t} else if (!AIPTEK_POINTER_ALLOW_STYLUS_MODE\n\t\t\t    (aiptek->curSetting.pointerMode)) {\n\t\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;\n\t\t} else {\n\t\t\tx = get_unaligned_le16(data + 1);\n\t\t\ty = get_unaligned_le16(data + 3);\n\t\t\tz = get_unaligned_le16(data + 6);\n\n\t\t\tdv = (data[5] & 0x01) != 0 ? 1 : 0;\n\t\t\tp = (data[5] & 0x02) != 0 ? 1 : 0;\n\t\t\ttip = (data[5] & 0x04) != 0 ? 1 : 0;\n\n\t\t\t \n\t\t\tjitterable = data[5] & 0x18;\n\n\t\t\tbs = (data[5] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;\n\t\t\tpck = (data[5] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;\n\n\t\t\t \n\t\t\tif (dv != 0) {\n\t\t\t\t \n\t\t\t\tif (aiptek->previousToolMode !=\n\t\t\t\t    aiptek->curSetting.toolMode) {\n\t\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t\t\t 1);\n\t\t\t\t\taiptek->previousToolMode =\n\t\t\t\t\t          aiptek->curSetting.toolMode;\n\t\t\t\t}\n\n\t\t\t\tif (p != 0) {\n\t\t\t\t\tinput_report_abs(inputdev, ABS_X, x);\n\t\t\t\t\tinput_report_abs(inputdev, ABS_Y, y);\n\t\t\t\t\tinput_report_abs(inputdev, ABS_PRESSURE, z);\n\n\t\t\t\t\tinput_report_key(inputdev, BTN_TOUCH, tip);\n\t\t\t\t\tinput_report_key(inputdev, BTN_STYLUS, bs);\n\t\t\t\t\tinput_report_key(inputdev, BTN_STYLUS2, pck);\n\n\t\t\t\t\tif (aiptek->curSetting.xTilt !=\n\t\t\t\t\t    AIPTEK_TILT_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_TILT_X,\n\t\t\t\t\t\t\t\t aiptek->curSetting.xTilt);\n\t\t\t\t\t}\n\t\t\t\t\tif (aiptek->curSetting.yTilt != AIPTEK_TILT_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_TILT_Y,\n\t\t\t\t\t\t\t\t aiptek->curSetting.yTilt);\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (aiptek->curSetting.wheel !=\n\t\t\t\t\t    AIPTEK_WHEEL_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_WHEEL,\n\t\t\t\t\t\t\t\t aiptek->curSetting.wheel);\n\t\t\t\t\t\taiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_STYLUS);\n\t\t\t\tif (aiptek->lastMacro != -1) {\n\t\t\t                input_report_key(inputdev,\n\t\t\t\t\t\t\t macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\t\t\taiptek->lastMacro = -1;\n\t\t\t\t}\n\t\t\t\tinput_sync(inputdev);\n\t\t\t}\n\t\t}\n\t}\n\t \n\telse if (data[0] == 3) {\n\t\tif (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {\n\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;\n\t\t} else if (!AIPTEK_POINTER_ALLOW_MOUSE_MODE\n\t\t\t(aiptek->curSetting.pointerMode)) {\n\t\t\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;\n\t\t} else {\n\t\t\tx = get_unaligned_le16(data + 1);\n\t\t\ty = get_unaligned_le16(data + 3);\n\n\t\t\tjitterable = data[5] & 0x1c;\n\n\t\t\tdv = (data[5] & 0x01) != 0 ? 1 : 0;\n\t\t\tp = (data[5] & 0x02) != 0 ? 1 : 0;\n\t\t\tleft = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;\n\t\t\tright = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;\n\t\t\tmiddle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;\n\n\t\t\tif (dv != 0) {\n\t\t\t\t \n\t\t\t\tif (aiptek->previousToolMode !=\n\t\t\t\t    aiptek->curSetting.toolMode) {\n\t\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t\t\t 1);\n\t\t\t\t\taiptek->previousToolMode =\n\t\t\t\t\t          aiptek->curSetting.toolMode;\n\t\t\t\t}\n\n\t\t\t\tif (p != 0) {\n\t\t\t\t\tinput_report_abs(inputdev, ABS_X, x);\n\t\t\t\t\tinput_report_abs(inputdev, ABS_Y, y);\n\n\t\t\t\t\tinput_report_key(inputdev, BTN_LEFT, left);\n\t\t\t\t\tinput_report_key(inputdev, BTN_MIDDLE, middle);\n\t\t\t\t\tinput_report_key(inputdev, BTN_RIGHT, right);\n\n\t\t\t\t\t \n\t\t\t\t\tif (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {\n\t\t\t\t\t\tinput_report_abs(inputdev,\n\t\t\t\t\t\t\t\t ABS_WHEEL,\n\t\t\t\t\t\t\t\t aiptek->curSetting.wheel);\n\t\t\t\t\t\taiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);\n\t\t\t\tif (aiptek->lastMacro != -1) {\n\t\t\t                input_report_key(inputdev,\n\t\t\t\t\t\t\t macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\t\t        aiptek->lastMacro = -1;\n\t\t\t\t}\n\t\t\t\tinput_sync(inputdev);\n\t\t\t}\n\t\t}\n\t}\n\t \n\telse if (data[0] == 4) {\n\t\tjitterable = data[1] & 0x18;\n\n\t\tdv = (data[1] & 0x01) != 0 ? 1 : 0;\n\t\tp = (data[1] & 0x02) != 0 ? 1 : 0;\n\t\ttip = (data[1] & 0x04) != 0 ? 1 : 0;\n\t\tbs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;\n\t\tpck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;\n\n\t\tmacro = dv && p && tip && !(data[3] & 1) ? (data[3] >> 1) : -1;\n\t\tz = get_unaligned_le16(data + 4);\n\n\t\tif (dv) {\n\t\t         \n\t\t        if (aiptek->previousToolMode !=\n\t\t\t    aiptek->curSetting.toolMode) {\n\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t\t 1);\n\t\t\t\taiptek->previousToolMode =\n\t\t\t\t        aiptek->curSetting.toolMode;\n\t\t\t}\n\t\t}\n\n\t\tif (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {\n\t\t        input_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\taiptek->lastMacro = -1;\n\t\t}\n\n\t\tif (macro != -1 && macro != aiptek->lastMacro) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro], 1);\n\t\t\taiptek->lastMacro = macro;\n\t\t}\n\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t p | AIPTEK_REPORT_TOOL_STYLUS);\n\t\tinput_sync(inputdev);\n\t}\n\t \n\telse if (data[0] == 5) {\n\t\tjitterable = data[1] & 0x1c;\n\n\t\tdv = (data[1] & 0x01) != 0 ? 1 : 0;\n\t\tp = (data[1] & 0x02) != 0 ? 1 : 0;\n\t\tleft = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;\n\t\tright = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;\n\t\tmiddle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;\n\t\tmacro = dv && p && left && !(data[3] & 1) ? (data[3] >> 1) : 0;\n\n\t\tif (dv) {\n\t\t         \n\t\t        if (aiptek->previousToolMode !=\n\t\t\t    aiptek->curSetting.toolMode) {\n\t\t                input_report_key(inputdev,\n\t\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\t        input_report_key(inputdev,\n\t\t\t\t\t\t aiptek->curSetting.toolMode, 1);\n\t\t\t        aiptek->previousToolMode = aiptek->curSetting.toolMode;\n\t\t\t}\n\t\t}\n\n\t\tif (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {\n\t\t        input_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);\n\t\t\taiptek->lastMacro = -1;\n\t\t}\n\n\t\tif (macro != -1 && macro != aiptek->lastMacro) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro], 1);\n\t\t\taiptek->lastMacro = macro;\n\t\t}\n\n\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t p | AIPTEK_REPORT_TOOL_MOUSE);\n\t\tinput_sync(inputdev);\n\t}\n\t \n\telse if (data[0] == 6) {\n\t\tmacro = get_unaligned_le16(data + 1);\n\t\tif (macro > 0) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro - 1],\n\t\t\t\t\t 0);\n\t\t}\n\t\tif (macro < 25) {\n\t\t\tinput_report_key(inputdev, macroKeyEvents[macro + 1],\n\t\t\t\t\t 0);\n\t\t}\n\n\t\t \n\t\tif (aiptek->previousToolMode !=\n\t\t    aiptek->curSetting.toolMode) {\n\t\t        input_report_key(inputdev,\n\t\t\t\t\t aiptek->previousToolMode, 0);\n\t\t\tinput_report_key(inputdev,\n\t\t\t\t\t aiptek->curSetting.toolMode,\n\t\t\t\t\t 1);\n\t\t\taiptek->previousToolMode =\n\t\t\t\taiptek->curSetting.toolMode;\n\t\t}\n\n\t\tinput_report_key(inputdev, macroKeyEvents[macro], 1);\n\t\tinput_report_abs(inputdev, ABS_MISC,\n\t\t\t\t 1 | AIPTEK_REPORT_TOOL_UNKNOWN);\n\t\tinput_sync(inputdev);\n\t} else {\n\t\tdev_dbg(&intf->dev, \"Unknown report %d\\n\", data[0]);\n\t}\n\n\t \n\n\tif (aiptek->previousJitterable != jitterable &&\n\t    aiptek->curSetting.jitterDelay != 0 && aiptek->inDelay != 1) {\n\t\taiptek->endDelay = jiffies +\n\t\t    ((aiptek->curSetting.jitterDelay * HZ) / 1000);\n\t\taiptek->inDelay = 1;\n\t}\n\taiptek->previousJitterable = jitterable;\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval != 0) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n\n \nstatic const struct usb_device_id aiptek_ids[] = {\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x01)},\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x10)},\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x20)},\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x21)},\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x22)},\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x23)},\n\t{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x24)},\n\t{USB_DEVICE(USB_VENDOR_ID_KYE, 0x5003)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, aiptek_ids);\n\n \nstatic int aiptek_open(struct input_dev *inputdev)\n{\n\tstruct aiptek *aiptek = input_get_drvdata(inputdev);\n\n\taiptek->urb->dev = interface_to_usbdev(aiptek->intf);\n\tif (usb_submit_urb(aiptek->urb, GFP_KERNEL) != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic void aiptek_close(struct input_dev *inputdev)\n{\n\tstruct aiptek *aiptek = input_get_drvdata(inputdev);\n\n\tusb_kill_urb(aiptek->urb);\n}\n\n \nstatic int\naiptek_set_report(struct aiptek *aiptek,\n\t\t  unsigned char report_type,\n\t\t  unsigned char report_id, void *buffer, int size)\n{\n\tstruct usb_device *udev = interface_to_usbdev(aiptek->intf);\n\n\treturn usb_control_msg(udev,\n\t\t\t       usb_sndctrlpipe(udev, 0),\n\t\t\t       USB_REQ_SET_REPORT,\n\t\t\t       USB_TYPE_CLASS | USB_RECIP_INTERFACE |\n\t\t\t       USB_DIR_OUT, (report_type << 8) + report_id,\n\t\t\t       aiptek->ifnum, buffer, size, 5000);\n}\n\nstatic int\naiptek_get_report(struct aiptek *aiptek,\n\t\t  unsigned char report_type,\n\t\t  unsigned char report_id, void *buffer, int size)\n{\n\tstruct usb_device *udev = interface_to_usbdev(aiptek->intf);\n\n\treturn usb_control_msg(udev,\n\t\t\t       usb_rcvctrlpipe(udev, 0),\n\t\t\t       USB_REQ_GET_REPORT,\n\t\t\t       USB_TYPE_CLASS | USB_RECIP_INTERFACE |\n\t\t\t       USB_DIR_IN, (report_type << 8) + report_id,\n\t\t\t       aiptek->ifnum, buffer, size, 5000);\n}\n\n \nstatic int\naiptek_command(struct aiptek *aiptek, unsigned char command, unsigned char data)\n{\n\tconst int sizeof_buf = 3 * sizeof(u8);\n\tint ret;\n\tu8 *buf;\n\n\tbuf = kmalloc(sizeof_buf, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 2;\n\tbuf[1] = command;\n\tbuf[2] = data;\n\n\tif ((ret =\n\t     aiptek_set_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {\n\t\tdev_dbg(&aiptek->intf->dev,\n\t\t\t\"aiptek_program: failed, tried to send: 0x%02x 0x%02x\\n\",\n\t\t\tcommand, data);\n\t}\n\tkfree(buf);\n\treturn ret < 0 ? ret : 0;\n}\n\n \nstatic int\naiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)\n{\n\tconst int sizeof_buf = 3 * sizeof(u8);\n\tint ret;\n\tu8 *buf;\n\n\tbuf = kmalloc(sizeof_buf, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = 2;\n\tbuf[1] = command;\n\tbuf[2] = data;\n\n\tif (aiptek_command(aiptek, command, data) != 0) {\n\t\tkfree(buf);\n\t\treturn -EIO;\n\t}\n\tmsleep(aiptek->curSetting.programmableDelay);\n\n\tif (aiptek_get_report(aiptek, 3, 2, buf, sizeof_buf) != sizeof_buf) {\n\t\tdev_dbg(&aiptek->intf->dev,\n\t\t\t\"aiptek_query failed: returned 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\tbuf[0], buf[1], buf[2]);\n\t\tret = -EIO;\n\t} else {\n\t\tret = get_unaligned_le16(buf + 1);\n\t}\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int aiptek_program_tablet(struct aiptek *aiptek)\n{\n\tint ret;\n\t \n\tif ((ret = aiptek_command(aiptek, 0x18, 0x04)) < 0)\n\t\treturn ret;\n\n\t \n\tif ((ret = aiptek_query(aiptek, 0x02, 0x00)) < 0)\n\t\treturn ret;\n\taiptek->features.modelCode = ret & 0xff;\n\n\t \n\tif ((ret = aiptek_query(aiptek, 0x03, 0x00)) < 0)\n\t\treturn ret;\n\taiptek->features.odmCode = ret;\n\n\t \n\tif ((ret = aiptek_query(aiptek, 0x04, 0x00)) < 0)\n\t\treturn ret;\n\taiptek->features.firmwareCode = ret;\n\n\t \n\tif ((ret = aiptek_query(aiptek, 0x01, 0x00)) < 0)\n\t\treturn ret;\n\tinput_set_abs_params(aiptek->inputdev, ABS_X, 0, ret - 1, 0, 0);\n\n\t \n\tif ((ret = aiptek_query(aiptek, 0x01, 0x01)) < 0)\n\t\treturn ret;\n\tinput_set_abs_params(aiptek->inputdev, ABS_Y, 0, ret - 1, 0, 0);\n\n\t \n\tif ((ret = aiptek_query(aiptek, 0x08, 0x00)) < 0)\n\t\treturn ret;\n\tinput_set_abs_params(aiptek->inputdev, ABS_PRESSURE, 0, ret - 1, 0, 0);\n\n\t \n\tif (aiptek->curSetting.coordinateMode ==\n\t    AIPTEK_COORDINATE_ABSOLUTE_MODE) {\n\t\t \n\t\tif ((ret = aiptek_command(aiptek, 0x10, 0x01)) < 0) {\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((ret = aiptek_command(aiptek, 0x10, 0x00)) < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif ((ret = aiptek_command(aiptek, 0x11, 0x02)) < 0)\n\t\treturn ret;\n#if 0\n\t \n\tif ((ret = aiptek_command(aiptek, 0x17, 0x00)) < 0)\n\t\treturn ret;\n#endif\n\n\t \n\tif ((ret = aiptek_command(aiptek, 0x12, 0xff)) < 0)\n\t\treturn ret;\n\n\t \n\taiptek->diagnostic = AIPTEK_DIAGNOSTIC_NA;\n\taiptek->eventCount = 0;\n\n\treturn 0;\n}\n\n \n\n \nstatic ssize_t show_tabletSize(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%dx%d\\n\",\n\t\t\t  input_abs_get_max(aiptek->inputdev, ABS_X) + 1,\n\t\t\t  input_abs_get_max(aiptek->inputdev, ABS_Y) + 1);\n}\n\n \nstatic DEVICE_ATTR(size, S_IRUGO, show_tabletSize, NULL);\n\n \nstatic struct aiptek_map pointer_mode_map[] = {\n\t{ \"stylus\",\tAIPTEK_POINTER_ONLY_STYLUS_MODE },\n\t{ \"mouse\",\tAIPTEK_POINTER_ONLY_MOUSE_MODE },\n\t{ \"either\",\tAIPTEK_POINTER_EITHER_MODE },\n\t{ NULL,\t\tAIPTEK_INVALID_VALUE }\n};\n\nstatic ssize_t show_tabletPointerMode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(pointer_mode_map,\n\t\t\t\t\t\t      aiptek->curSetting.pointerMode));\n}\n\nstatic ssize_t\nstore_tabletPointerMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_mode = map_str_to_val(pointer_mode_map, buf, count);\n\n\tif (new_mode == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.pointerMode = new_mode;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(pointer_mode,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletPointerMode, store_tabletPointerMode);\n\n \n\nstatic struct aiptek_map coordinate_mode_map[] = {\n\t{ \"absolute\",\tAIPTEK_COORDINATE_ABSOLUTE_MODE },\n\t{ \"relative\",\tAIPTEK_COORDINATE_RELATIVE_MODE },\n\t{ NULL,\t\tAIPTEK_INVALID_VALUE }\n};\n\nstatic ssize_t show_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(coordinate_mode_map,\n\t\t\t\t\t\t      aiptek->curSetting.coordinateMode));\n}\n\nstatic ssize_t\nstore_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_mode = map_str_to_val(coordinate_mode_map, buf, count);\n\n\tif (new_mode == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.coordinateMode = new_mode;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(coordinate_mode,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletCoordinateMode, store_tabletCoordinateMode);\n\n \n\nstatic struct aiptek_map tool_mode_map[] = {\n\t{ \"mouse\",\tAIPTEK_TOOL_BUTTON_MOUSE_MODE },\n\t{ \"eraser\",\tAIPTEK_TOOL_BUTTON_ERASER_MODE },\n\t{ \"pencil\",\tAIPTEK_TOOL_BUTTON_PENCIL_MODE },\n\t{ \"pen\",\tAIPTEK_TOOL_BUTTON_PEN_MODE },\n\t{ \"brush\",\tAIPTEK_TOOL_BUTTON_BRUSH_MODE },\n\t{ \"airbrush\",\tAIPTEK_TOOL_BUTTON_AIRBRUSH_MODE },\n\t{ \"lens\",\tAIPTEK_TOOL_BUTTON_LENS_MODE },\n\t{ NULL,\t\tAIPTEK_INVALID_VALUE }\n};\n\nstatic ssize_t show_tabletToolMode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(tool_mode_map,\n\t\t\t\t\t\t      aiptek->curSetting.toolMode));\n}\n\nstatic ssize_t\nstore_tabletToolMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_mode = map_str_to_val(tool_mode_map, buf, count);\n\n\tif (new_mode == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.toolMode = new_mode;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(tool_mode,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletToolMode, store_tabletToolMode);\n\n \nstatic ssize_t show_tabletXtilt(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\tif (aiptek->curSetting.xTilt == AIPTEK_TILT_DISABLE) {\n\t\treturn sysfs_emit(buf, \"disable\\n\");\n\t} else {\n\t\treturn sysfs_emit(buf, \"%d\\n\", aiptek->curSetting.xTilt);\n\t}\n}\n\nstatic ssize_t\nstore_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint x;\n\n\tif (kstrtoint(buf, 10, &x)) {\n\t\tsize_t len = buf[count - 1] == '\\n' ? count - 1 : count;\n\n\t\tif (strncmp(buf, \"disable\", len))\n\t\t\treturn -EINVAL;\n\n\t\taiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;\n\t} else {\n\t\tif (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\taiptek->newSetting.xTilt = x;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(xtilt,\n\t\t   S_IRUGO | S_IWUSR, show_tabletXtilt, store_tabletXtilt);\n\n \nstatic ssize_t show_tabletYtilt(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\tif (aiptek->curSetting.yTilt == AIPTEK_TILT_DISABLE) {\n\t\treturn sysfs_emit(buf, \"disable\\n\");\n\t} else {\n\t\treturn sysfs_emit(buf, \"%d\\n\", aiptek->curSetting.yTilt);\n\t}\n}\n\nstatic ssize_t\nstore_tabletYtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint y;\n\n\tif (kstrtoint(buf, 10, &y)) {\n\t\tsize_t len = buf[count - 1] == '\\n' ? count - 1 : count;\n\n\t\tif (strncmp(buf, \"disable\", len))\n\t\t\treturn -EINVAL;\n\n\t\taiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;\n\t} else {\n\t\tif (y < AIPTEK_TILT_MIN || y > AIPTEK_TILT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\taiptek->newSetting.yTilt = y;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(ytilt,\n\t\t   S_IRUGO | S_IWUSR, show_tabletYtilt, store_tabletYtilt);\n\n \nstatic ssize_t show_tabletJitterDelay(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", aiptek->curSetting.jitterDelay);\n}\n\nstatic ssize_t\nstore_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint err, j;\n\n\terr = kstrtoint(buf, 10, &j);\n\tif (err)\n\t\treturn err;\n\n\taiptek->newSetting.jitterDelay = j;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(jitter,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletJitterDelay, store_tabletJitterDelay);\n\n \nstatic ssize_t show_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", aiptek->curSetting.programmableDelay);\n}\n\nstatic ssize_t\nstore_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint err, d;\n\n\terr = kstrtoint(buf, 10, &d);\n\tif (err)\n\t\treturn err;\n\n\taiptek->newSetting.programmableDelay = d;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(delay,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletProgrammableDelay, store_tabletProgrammableDelay);\n\n \nstatic ssize_t show_tabletEventsReceived(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", aiptek->eventCount);\n}\n\nstatic DEVICE_ATTR(event_count, S_IRUGO, show_tabletEventsReceived, NULL);\n\n \nstatic ssize_t show_tabletDiagnosticMessage(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tchar *retMsg;\n\n\tswitch (aiptek->diagnostic) {\n\tcase AIPTEK_DIAGNOSTIC_NA:\n\t\tretMsg = \"no errors\\n\";\n\t\tbreak;\n\n\tcase AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE:\n\t\tretMsg = \"Error: receiving relative reports\\n\";\n\t\tbreak;\n\n\tcase AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE:\n\t\tretMsg = \"Error: receiving absolute reports\\n\";\n\t\tbreak;\n\n\tcase AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED:\n\t\tif (aiptek->curSetting.pointerMode ==\n\t\t    AIPTEK_POINTER_ONLY_MOUSE_MODE) {\n\t\t\tretMsg = \"Error: receiving stylus reports\\n\";\n\t\t} else {\n\t\t\tretMsg = \"Error: receiving mouse reports\\n\";\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn sysfs_emit(buf, retMsg);\n}\n\nstatic DEVICE_ATTR(diagnostic, S_IRUGO, show_tabletDiagnosticMessage, NULL);\n\n \n\nstatic struct aiptek_map stylus_button_map[] = {\n\t{ \"upper\",\tAIPTEK_STYLUS_UPPER_BUTTON },\n\t{ \"lower\",\tAIPTEK_STYLUS_LOWER_BUTTON },\n\t{ NULL,\t\tAIPTEK_INVALID_VALUE }\n};\n\nstatic ssize_t show_tabletStylusUpper(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(stylus_button_map,\n\t\t\t\t\t\t      aiptek->curSetting.stylusButtonUpper));\n}\n\nstatic ssize_t\nstore_tabletStylusUpper(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_button = map_str_to_val(stylus_button_map, buf, count);\n\n\tif (new_button == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.stylusButtonUpper = new_button;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(stylus_upper,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletStylusUpper, store_tabletStylusUpper);\n\n \n\nstatic ssize_t show_tabletStylusLower(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(stylus_button_map,\n\t\t\t\t\t\t      aiptek->curSetting.stylusButtonLower));\n}\n\nstatic ssize_t\nstore_tabletStylusLower(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_button = map_str_to_val(stylus_button_map, buf, count);\n\n\tif (new_button == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.stylusButtonLower = new_button;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(stylus_lower,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletStylusLower, store_tabletStylusLower);\n\n \n\nstatic struct aiptek_map mouse_button_map[] = {\n\t{ \"left\",\tAIPTEK_MOUSE_LEFT_BUTTON },\n\t{ \"middle\",\tAIPTEK_MOUSE_MIDDLE_BUTTON },\n\t{ \"right\",\tAIPTEK_MOUSE_RIGHT_BUTTON },\n\t{ NULL,\t\tAIPTEK_INVALID_VALUE }\n};\n\nstatic ssize_t show_tabletMouseLeft(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(mouse_button_map,\n\t\t\t\t\t\t      aiptek->curSetting.mouseButtonLeft));\n}\n\nstatic ssize_t\nstore_tabletMouseLeft(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_button = map_str_to_val(mouse_button_map, buf, count);\n\n\tif (new_button == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.mouseButtonLeft = new_button;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(mouse_left,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletMouseLeft, store_tabletMouseLeft);\n\n \nstatic ssize_t show_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(mouse_button_map,\n\t\t\t\t\t\t      aiptek->curSetting.mouseButtonMiddle));\n}\n\nstatic ssize_t\nstore_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_button = map_str_to_val(mouse_button_map, buf, count);\n\n\tif (new_button == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.mouseButtonMiddle = new_button;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(mouse_middle,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletMouseMiddle, store_tabletMouseMiddle);\n\n \nstatic ssize_t show_tabletMouseRight(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", map_val_to_str(mouse_button_map,\n\t\t\t\t\t\t      aiptek->curSetting.mouseButtonRight));\n}\n\nstatic ssize_t\nstore_tabletMouseRight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint new_button = map_str_to_val(mouse_button_map, buf, count);\n\n\tif (new_button == AIPTEK_INVALID_VALUE)\n\t\treturn -EINVAL;\n\n\taiptek->newSetting.mouseButtonRight = new_button;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(mouse_right,\n\t\t   S_IRUGO | S_IWUSR,\n\t\t   show_tabletMouseRight, store_tabletMouseRight);\n\n \nstatic ssize_t show_tabletWheel(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\tif (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {\n\t\treturn sysfs_emit(buf, \"disable\\n\");\n\t} else {\n\t\treturn sysfs_emit(buf, \"%d\\n\", aiptek->curSetting.wheel);\n\t}\n}\n\nstatic ssize_t\nstore_tabletWheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\tint err, w;\n\n\terr = kstrtoint(buf, 10, &w);\n\tif (err)\n\t\treturn err;\n\n\taiptek->newSetting.wheel = w;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(wheel,\n\t\t   S_IRUGO | S_IWUSR, show_tabletWheel, store_tabletWheel);\n\n \nstatic ssize_t show_tabletExecute(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t \n\treturn sysfs_emit(buf, \"Write anything to this file to program your tablet.\\n\");\n}\n\nstatic ssize_t\nstore_tabletExecute(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\t \n\tmemcpy(&aiptek->curSetting, &aiptek->newSetting,\n\t       sizeof(struct aiptek_settings));\n\n\tif (aiptek_program_tablet(aiptek) < 0)\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(execute,\n\t\t   S_IRUGO | S_IWUSR, show_tabletExecute, store_tabletExecute);\n\n \nstatic ssize_t show_tabletODMCode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"0x%04x\\n\", aiptek->features.odmCode);\n}\n\nstatic DEVICE_ATTR(odm_code, S_IRUGO, show_tabletODMCode, NULL);\n\n \nstatic ssize_t show_tabletModelCode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"0x%04x\\n\", aiptek->features.modelCode);\n}\n\nstatic DEVICE_ATTR(model_code, S_IRUGO, show_tabletModelCode, NULL);\n\n \nstatic ssize_t show_firmwareCode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%04x\\n\", aiptek->features.firmwareCode);\n}\n\nstatic DEVICE_ATTR(firmware_code, S_IRUGO, show_firmwareCode, NULL);\n\nstatic struct attribute *aiptek_dev_attrs[] = {\n\t&dev_attr_size.attr,\n\t&dev_attr_pointer_mode.attr,\n\t&dev_attr_coordinate_mode.attr,\n\t&dev_attr_tool_mode.attr,\n\t&dev_attr_xtilt.attr,\n\t&dev_attr_ytilt.attr,\n\t&dev_attr_jitter.attr,\n\t&dev_attr_delay.attr,\n\t&dev_attr_event_count.attr,\n\t&dev_attr_diagnostic.attr,\n\t&dev_attr_odm_code.attr,\n\t&dev_attr_model_code.attr,\n\t&dev_attr_firmware_code.attr,\n\t&dev_attr_stylus_lower.attr,\n\t&dev_attr_stylus_upper.attr,\n\t&dev_attr_mouse_left.attr,\n\t&dev_attr_mouse_middle.attr,\n\t&dev_attr_mouse_right.attr,\n\t&dev_attr_wheel.attr,\n\t&dev_attr_execute.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(aiptek_dev);\n\n \nstatic int\naiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct aiptek *aiptek;\n\tstruct input_dev *inputdev;\n\tint i;\n\tint speeds[] = { 0,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_50,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_400,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_25,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_100,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_200,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_300\n\t};\n\tint err = -ENOMEM;\n\n\t \n\tspeeds[0] = programmableDelay;\n\n\taiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);\n\tinputdev = input_allocate_device();\n\tif (!aiptek || !inputdev) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"cannot allocate memory or input device\\n\");\n\t\tgoto fail1;\n        }\n\n\taiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,\n\t\t\t\t\t  GFP_KERNEL, &aiptek->data_dma);\n        if (!aiptek->data) {\n\t\tdev_warn(&intf->dev, \"cannot allocate usb buffer\\n\");\n\t\tgoto fail1;\n\t}\n\n\taiptek->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!aiptek->urb) {\n\t        dev_warn(&intf->dev, \"cannot allocate urb\\n\");\n\t\tgoto fail2;\n\t}\n\n\taiptek->inputdev = inputdev;\n\taiptek->intf = intf;\n\taiptek->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\taiptek->inDelay = 0;\n\taiptek->endDelay = 0;\n\taiptek->previousJitterable = 0;\n\taiptek->lastMacro = -1;\n\n\t \n\taiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;\n\taiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;\n\taiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;\n\taiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;\n\taiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;\n\taiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;\n\taiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;\n\taiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;\n\taiptek->curSetting.jitterDelay = jitterDelay;\n\taiptek->curSetting.programmableDelay = programmableDelay;\n\n\t \n\taiptek->newSetting = aiptek->curSetting;\n\n\t \n\tusb_make_path(usbdev, aiptek->features.usbPath,\n\t\t\tsizeof(aiptek->features.usbPath));\n\tstrlcat(aiptek->features.usbPath, \"/input0\",\n\t\tsizeof(aiptek->features.usbPath));\n\n\t \n\tinputdev->name = \"Aiptek\";\n\tinputdev->phys = aiptek->features.usbPath;\n\tusb_to_input_id(usbdev, &inputdev->id);\n\tinputdev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(inputdev, aiptek);\n\n\tinputdev->open = aiptek_open;\n\tinputdev->close = aiptek_close;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(eventTypes); ++i)\n\t        __set_bit(eventTypes[i], inputdev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(absEvents); ++i)\n\t        __set_bit(absEvents[i], inputdev->absbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(relEvents); ++i)\n\t        __set_bit(relEvents[i], inputdev->relbit);\n\n\t__set_bit(MSC_SERIAL, inputdev->mscbit);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)\n\t\t__set_bit(buttonEvents[i], inputdev->keybit);\n\n\tfor (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)\n\t\t__set_bit(macroKeyEvents[i], inputdev->keybit);\n\n\t \n\tinput_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);\n\n\terr = usb_find_common_endpoints(intf->cur_altsetting,\n\t\t\t\t\tNULL, NULL, &endpoint, NULL);\n\tif (err) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"interface has no int in endpoints, but must have minimum 1\\n\");\n\t\tgoto fail3;\n\t}\n\n\t \n\tusb_fill_int_urb(aiptek->urb,\n\t\t\t usbdev,\n\t\t\t usb_rcvintpipe(usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t aiptek->data, 8, aiptek_irq, aiptek,\n\t\t\t endpoint->bInterval);\n\n\taiptek->urb->transfer_dma = aiptek->data_dma;\n\taiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(speeds); ++i) {\n\t\taiptek->curSetting.programmableDelay = speeds[i];\n\t\t(void)aiptek_program_tablet(aiptek);\n\t\tif (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Aiptek using %d ms programming speed\\n\",\n\t\t\t\t aiptek->curSetting.programmableDelay);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == ARRAY_SIZE(speeds)) {\n\t\tdev_info(&intf->dev,\n\t\t\t \"Aiptek tried all speeds, no sane response\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail3;\n\t}\n\n\t \n\tusb_set_intfdata(intf, aiptek);\n\n\t \n\terr = input_register_device(aiptek->inputdev);\n\tif (err) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"input_register_device returned err: %d\\n\", err);\n\t\tgoto fail3;\n        }\n\treturn 0;\n\n fail3: usb_free_urb(aiptek->urb);\n fail2:\tusb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,\n\t\t\t  aiptek->data_dma);\n fail1: usb_set_intfdata(intf, NULL);\n\tinput_free_device(inputdev);\n\tkfree(aiptek);\n\treturn err;\n}\n\n \nstatic void aiptek_disconnect(struct usb_interface *intf)\n{\n\tstruct aiptek *aiptek = usb_get_intfdata(intf);\n\n\t \n\tusb_set_intfdata(intf, NULL);\n\tif (aiptek != NULL) {\n\t\t \n\t\tusb_kill_urb(aiptek->urb);\n\t\tinput_unregister_device(aiptek->inputdev);\n\t\tusb_free_urb(aiptek->urb);\n\t\tusb_free_coherent(interface_to_usbdev(intf),\n\t\t\t\t  AIPTEK_PACKET_LENGTH,\n\t\t\t\t  aiptek->data, aiptek->data_dma);\n\t\tkfree(aiptek);\n\t}\n}\n\nstatic struct usb_driver aiptek_driver = {\n\t.name = \"aiptek\",\n\t.probe = aiptek_probe,\n\t.disconnect = aiptek_disconnect,\n\t.id_table = aiptek_ids,\n\t.dev_groups = aiptek_dev_groups,\n};\n\nmodule_usb_driver(aiptek_driver);\n\nMODULE_AUTHOR(\"Bryan W. Headley/Chris Atenasio/Cedric Brun/Rene van Paassen\");\nMODULE_DESCRIPTION(\"Aiptek HyperPen USB Tablet Driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(programmableDelay, int, 0);\nMODULE_PARM_DESC(programmableDelay, \"delay used during tablet programming\");\nmodule_param(jitterDelay, int, 0);\nMODULE_PARM_DESC(jitterDelay, \"stylus/mouse settlement delay\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}