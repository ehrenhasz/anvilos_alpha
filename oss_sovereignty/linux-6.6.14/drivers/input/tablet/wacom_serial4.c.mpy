{
  "module_name": "wacom_serial4.c",
  "hash_id": "511d1f21f8f25cbfba0fc38964162b358d82c3b1f61f1ba7babf3f9cd6440bb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/tablet/wacom_serial4.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nMODULE_AUTHOR(\"Julian Squires <julian@cipht.net>, Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Wacom protocol 4 serial tablet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define REQUEST_MODEL_AND_ROM_VERSION\t\"~#\"\n#define REQUEST_MAX_COORDINATES\t\t\"~C\\r\"\n#define REQUEST_CONFIGURATION_STRING\t\"~R\\r\"\n#define REQUEST_RESET_TO_PROTOCOL_IV\t\"\\r#\"\n \n\n#define COMMAND_START_SENDING_PACKETS\t\t\"ST\\r\"\n#define COMMAND_STOP_SENDING_PACKETS\t\t\"SP\\r\"\n#define COMMAND_MULTI_MODE_INPUT\t\t\"MU1\\r\"\n#define COMMAND_ORIGIN_IN_UPPER_LEFT\t\t\"OC1\\r\"\n#define COMMAND_ENABLE_ALL_MACRO_BUTTONS\t\"~M0\\r\"\n#define COMMAND_DISABLE_GROUP_1_MACRO_BUTTONS\t\"~M1\\r\"\n#define COMMAND_TRANSMIT_AT_MAX_RATE\t\t\"IT0\\r\"\n#define COMMAND_DISABLE_INCREMENTAL_MODE\t\"IN0\\r\"\n#define COMMAND_ENABLE_CONTINUOUS_MODE\t\t\"SR\\r\"\n#define COMMAND_ENABLE_PRESSURE_MODE\t\t\"PH1\\r\"\n#define COMMAND_Z_FILTER\t\t\t\"ZF1\\r\"\n\n \n#define PACKET_LENGTH\t\t7\n#define DATA_SIZE\t\t32\n\n \n#define F_COVERS_SCREEN\t\t0x01\n#define F_HAS_STYLUS2\t\t0x02\n#define F_HAS_SCROLLWHEEL\t0x04\n\n \n#define STYLUS_DEVICE_ID\t0x02\n#define CURSOR_DEVICE_ID\t0x06\n#define ERASER_DEVICE_ID\t0x0A\n\nenum { STYLUS = 1, ERASER, CURSOR };\n\nstatic const struct {\n\tint device_id;\n\tint input_id;\n} tools[] = {\n\t{ 0, 0 },\n\t{ STYLUS_DEVICE_ID, BTN_TOOL_PEN },\n\t{ ERASER_DEVICE_ID, BTN_TOOL_RUBBER },\n\t{ CURSOR_DEVICE_ID, BTN_TOOL_MOUSE },\n};\n\nstruct wacom {\n\tstruct input_dev *dev;\n\tstruct completion cmd_done;\n\tint result;\n\tu8 expect;\n\tu8 eraser_mask;\n\tunsigned int extra_z_bits;\n\tunsigned int flags;\n\tunsigned int res_x, res_y;\n\tunsigned int max_x, max_y;\n\tunsigned int tool;\n\tunsigned int idx;\n\tu8 data[DATA_SIZE];\n\tchar phys[32];\n};\n\nenum {\n\tMODEL_CINTIQ\t\t= 0x504C,  \n\tMODEL_CINTIQ2\t\t= 0x4454,  \n\tMODEL_DIGITIZER_II\t= 0x5544,  \n\tMODEL_GRAPHIRE\t\t= 0x4554,  \n\tMODEL_PENPARTNER\t= 0x4354,  \n\tMODEL_ARTPAD_II\t\t= 0x4B54,  \n};\n\nstatic void wacom_handle_model_response(struct wacom *wacom)\n{\n\tint major_v, minor_v, r = 0;\n\tchar *p;\n\n\tp = strrchr(wacom->data, 'V');\n\tif (p)\n\t\tr = sscanf(p + 1, \"%u.%u\", &major_v, &minor_v);\n\tif (r != 2)\n\t\tmajor_v = minor_v = 0;\n\n\tswitch (wacom->data[2] << 8 | wacom->data[3]) {\n\tcase MODEL_CINTIQ:\t \n\tcase MODEL_CINTIQ2:\n\t\tif ((wacom->data[2] << 8 | wacom->data[3]) == MODEL_CINTIQ) {\n\t\t\twacom->dev->name = \"Wacom Cintiq\";\n\t\t\twacom->dev->id.version = MODEL_CINTIQ;\n\t\t} else {\n\t\t\twacom->dev->name = \"Wacom Cintiq II\";\n\t\t\twacom->dev->id.version = MODEL_CINTIQ2;\n\t\t}\n\t\twacom->res_x = 508;\n\t\twacom->res_y = 508;\n\n\t\tswitch (wacom->data[5] << 8 | wacom->data[6]) {\n\t\tcase 0x3731:  \n\t\t\twacom->res_x = 2540;\n\t\t\twacom->res_y = 2540;\n\t\t\tfallthrough;\n\t\tcase 0x3535:  \n\t\tcase 0x3830:  \n\t\t\twacom->extra_z_bits = 2;\n\t\t}\n\n\t\twacom->flags = F_COVERS_SCREEN;\n\t\tbreak;\n\n\tcase MODEL_PENPARTNER:\n\t\twacom->dev->name = \"Wacom Penpartner\";\n\t\twacom->dev->id.version = MODEL_PENPARTNER;\n\t\twacom->res_x = 1000;\n\t\twacom->res_y = 1000;\n\t\tbreak;\n\n\tcase MODEL_GRAPHIRE:\n\t\twacom->dev->name = \"Wacom Graphire\";\n\t\twacom->dev->id.version = MODEL_GRAPHIRE;\n\t\twacom->res_x = 1016;\n\t\twacom->res_y = 1016;\n\t\twacom->max_x = 5103;\n\t\twacom->max_y = 3711;\n\t\twacom->extra_z_bits = 2;\n\t\twacom->eraser_mask = 0x08;\n\t\twacom->flags = F_HAS_STYLUS2 | F_HAS_SCROLLWHEEL;\n\t\tbreak;\n\n\tcase MODEL_ARTPAD_II:\n\tcase MODEL_DIGITIZER_II:\n\t\twacom->dev->name = \"Wacom Digitizer II\";\n\t\twacom->dev->id.version = MODEL_DIGITIZER_II;\n\t\tif (major_v == 1 && minor_v <= 2)\n\t\t\twacom->extra_z_bits = 0;  \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&wacom->dev->dev, \"Unsupported Wacom model %s\\n\",\n\t\t\twacom->data);\n\t\twacom->result = -ENODEV;\n\t\treturn;\n\t}\n\n\tdev_info(&wacom->dev->dev, \"%s tablet, version %u.%u\\n\",\n\t\t wacom->dev->name, major_v, minor_v);\n}\n\nstatic void wacom_handle_configuration_response(struct wacom *wacom)\n{\n\tint r, skip;\n\n\tdev_dbg(&wacom->dev->dev, \"Configuration string: %s\\n\", wacom->data);\n\tr = sscanf(wacom->data, \"~R%x,%u,%u,%u,%u\", &skip, &skip, &skip,\n\t\t   &wacom->res_x, &wacom->res_y);\n\tif (r != 5)\n\t\tdev_warn(&wacom->dev->dev, \"could not get resolution\\n\");\n}\n\nstatic void wacom_handle_coordinates_response(struct wacom *wacom)\n{\n\tint r;\n\n\tdev_dbg(&wacom->dev->dev, \"Coordinates string: %s\\n\", wacom->data);\n\tr = sscanf(wacom->data, \"~C%u,%u\", &wacom->max_x, &wacom->max_y);\n\tif (r != 2)\n\t\tdev_warn(&wacom->dev->dev, \"could not get max coordinates\\n\");\n}\n\nstatic void wacom_handle_response(struct wacom *wacom)\n{\n\tif (wacom->data[0] != '~' || wacom->data[1] != wacom->expect) {\n\t\tdev_err(&wacom->dev->dev,\n\t\t\t\"Wacom got an unexpected response: %s\\n\", wacom->data);\n\t\twacom->result = -EIO;\n\t} else {\n\t\twacom->result = 0;\n\n\t\tswitch (wacom->data[1]) {\n\t\tcase '#':\n\t\t\twacom_handle_model_response(wacom);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\twacom_handle_configuration_response(wacom);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\twacom_handle_coordinates_response(wacom);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcomplete(&wacom->cmd_done);\n}\n\nstatic void wacom_handle_packet(struct wacom *wacom)\n{\n\tu8 in_proximity_p, stylus_p, button;\n\tunsigned int tool;\n\tint x, y, z;\n\n\tin_proximity_p = wacom->data[0] & 0x40;\n\tstylus_p = wacom->data[0] & 0x20;\n\tbutton = (wacom->data[3] & 0x78) >> 3;\n\tx = (wacom->data[0] & 3) << 14 | wacom->data[1]<<7 | wacom->data[2];\n\ty = (wacom->data[3] & 3) << 14 | wacom->data[4]<<7 | wacom->data[5];\n\n\tif (in_proximity_p && stylus_p) {\n\t\tz = wacom->data[6] & 0x7f;\n\t\tif (wacom->extra_z_bits >= 1)\n\t\t\tz = z << 1 | (wacom->data[3] & 0x4) >> 2;\n\t\tif (wacom->extra_z_bits > 1)\n\t\t\tz = z << 1 | (wacom->data[0] & 0x4) >> 2;\n\t\tz = z ^ (0x40 << wacom->extra_z_bits);\n\t} else {\n\t\tz = -1;\n\t}\n\n\tif (stylus_p)\n\t\ttool = (button & wacom->eraser_mask) ? ERASER : STYLUS;\n\telse\n\t\ttool = CURSOR;\n\n\tif (tool != wacom->tool && wacom->tool != 0) {\n\t\tinput_report_key(wacom->dev, tools[wacom->tool].input_id, 0);\n\t\tinput_sync(wacom->dev);\n\t}\n\twacom->tool = tool;\n\n\tinput_report_key(wacom->dev, tools[tool].input_id, in_proximity_p);\n\tinput_report_abs(wacom->dev, ABS_MISC,\n\t\t\t in_proximity_p ? tools[tool].device_id : 0);\n\tinput_report_abs(wacom->dev, ABS_X, x);\n\tinput_report_abs(wacom->dev, ABS_Y, y);\n\tinput_report_abs(wacom->dev, ABS_PRESSURE, z);\n\tif (stylus_p) {\n\t\tinput_report_key(wacom->dev, BTN_TOUCH, button & 1);\n\t\tinput_report_key(wacom->dev, BTN_STYLUS, button & 2);\n\t\tinput_report_key(wacom->dev, BTN_STYLUS2, button & 4);\n\t} else {\n\t\tinput_report_key(wacom->dev, BTN_LEFT, button & 1);\n\t\tinput_report_key(wacom->dev, BTN_RIGHT, button & 2);\n\t\tinput_report_key(wacom->dev, BTN_MIDDLE, button & 4);\n\t\t \n\t\tz = (wacom->data[6] & 0x30) >> 4;\n\t\tif (wacom->data[6] & 0x40)\n\t\t\tz = -z;\n\t\tinput_report_rel(wacom->dev, REL_WHEEL, z);\n\t}\n\tinput_sync(wacom->dev);\n}\n\nstatic void wacom_clear_data_buf(struct wacom *wacom)\n{\n\tmemset(wacom->data, 0, DATA_SIZE);\n\twacom->idx = 0;\n}\n\nstatic irqreturn_t wacom_interrupt(struct serio *serio, unsigned char data,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct wacom *wacom = serio_get_drvdata(serio);\n\n\tif (data & 0x80)\n\t\twacom->idx = 0;\n\n\t \n\tif (data == '\\r' && !(wacom->data[0] & 0x80)) {\n\t\twacom_handle_response(wacom);\n\t\twacom_clear_data_buf(wacom);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (wacom->idx > (DATA_SIZE - 2)) {\n\t\tdev_dbg(&wacom->dev->dev,\n\t\t\t\"throwing away %d bytes of garbage\\n\", wacom->idx);\n\t\twacom_clear_data_buf(wacom);\n\t}\n\twacom->data[wacom->idx++] = data;\n\n\tif (wacom->idx == PACKET_LENGTH && (wacom->data[0] & 0x80)) {\n\t\twacom_handle_packet(wacom);\n\t\twacom_clear_data_buf(wacom);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wacom_disconnect(struct serio *serio)\n{\n\tstruct wacom *wacom = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(wacom->dev);\n\tkfree(wacom);\n}\n\nstatic int wacom_send(struct serio *serio, const u8 *command)\n{\n\tint err = 0;\n\n\tfor (; !err && *command; command++)\n\t\terr = serio_write(serio, *command);\n\n\treturn err;\n}\n\nstatic int wacom_send_setup_string(struct wacom *wacom, struct serio *serio)\n{\n\tconst u8 *cmd;\n\n\tswitch (wacom->dev->id.version) {\n\tcase MODEL_CINTIQ:\t \n\t\tcmd = COMMAND_ORIGIN_IN_UPPER_LEFT\n\t\t\tCOMMAND_TRANSMIT_AT_MAX_RATE\n\t\t\tCOMMAND_ENABLE_CONTINUOUS_MODE\n\t\t\tCOMMAND_START_SENDING_PACKETS;\n\t\tbreak;\n\n\tcase MODEL_PENPARTNER:\n\t\tcmd = COMMAND_ENABLE_PRESSURE_MODE\n\t\t\tCOMMAND_START_SENDING_PACKETS;\n\t\tbreak;\n\n\tdefault:\n\t\tcmd = COMMAND_MULTI_MODE_INPUT\n\t\t\tCOMMAND_ORIGIN_IN_UPPER_LEFT\n\t\t\tCOMMAND_ENABLE_ALL_MACRO_BUTTONS\n\t\t\tCOMMAND_DISABLE_GROUP_1_MACRO_BUTTONS\n\t\t\tCOMMAND_TRANSMIT_AT_MAX_RATE\n\t\t\tCOMMAND_DISABLE_INCREMENTAL_MODE\n\t\t\tCOMMAND_ENABLE_CONTINUOUS_MODE\n\t\t\tCOMMAND_Z_FILTER\n\t\t\tCOMMAND_START_SENDING_PACKETS;\n\t\tbreak;\n\t}\n\n\treturn wacom_send(serio, cmd);\n}\n\nstatic int wacom_send_and_wait(struct wacom *wacom, struct serio *serio,\n\t\t\t       const u8 *cmd, const char *desc)\n{\n\tint err;\n\tunsigned long u;\n\n\twacom->expect = cmd[1];\n\tinit_completion(&wacom->cmd_done);\n\n\terr = wacom_send(serio, cmd);\n\tif (err)\n\t\treturn err;\n\n\tu = wait_for_completion_timeout(&wacom->cmd_done, HZ);\n\tif (u == 0) {\n\t\t \n\t\twacom_handle_response(wacom);\n\t}\n\n\twacom->expect = 0;\n\treturn wacom->result;\n}\n\nstatic int wacom_setup(struct wacom *wacom, struct serio *serio)\n{\n\tint err;\n\n\t \n\terr = wacom_send_and_wait(wacom, serio, REQUEST_MODEL_AND_ROM_VERSION,\n\t\t\t\t  \"model and version\");\n\tif (err)\n\t\treturn err;\n\n\tif (!(wacom->res_x && wacom->res_y)) {\n\t\terr = wacom_send_and_wait(wacom, serio,\n\t\t\t\t\t  REQUEST_CONFIGURATION_STRING,\n\t\t\t\t\t  \"configuration string\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!(wacom->max_x && wacom->max_y)) {\n\t\terr = wacom_send_and_wait(wacom, serio,\n\t\t\t\t\t  REQUEST_MAX_COORDINATES,\n\t\t\t\t\t  \"coordinates string\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn wacom_send_setup_string(wacom, serio);\n}\n\nstatic int wacom_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct wacom *wacom;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\n\twacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!wacom || !input_dev)\n\t\tgoto free_device;\n\n\twacom->dev = input_dev;\n\twacom->extra_z_bits = 1;\n\twacom->eraser_mask = 0x04;\n\twacom->tool = wacom->idx = 0;\n\tsnprintf(wacom->phys, sizeof(wacom->phys), \"%s/input0\", serio->phys);\n\tinput_dev->phys = wacom->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor  = SERIO_WACOM_IV;\n\tinput_dev->id.product = serio->id.extra;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] =\n\t\tBIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) | BIT_MASK(EV_REL);\n\tset_bit(ABS_MISC, input_dev->absbit);\n\tset_bit(BTN_TOOL_PEN, input_dev->keybit);\n\tset_bit(BTN_TOOL_RUBBER, input_dev->keybit);\n\tset_bit(BTN_TOOL_MOUSE, input_dev->keybit);\n\tset_bit(BTN_TOUCH, input_dev->keybit);\n\tset_bit(BTN_STYLUS, input_dev->keybit);\n\tset_bit(BTN_LEFT, input_dev->keybit);\n\tset_bit(BTN_RIGHT, input_dev->keybit);\n\tset_bit(BTN_MIDDLE, input_dev->keybit);\n\n\tserio_set_drvdata(serio, wacom);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto free_device;\n\n\terr = wacom_setup(wacom, serio);\n\tif (err)\n\t\tgoto close_serio;\n\n\tset_bit(INPUT_PROP_DIRECT, input_dev->propbit);\n\tif (!(wacom->flags & F_COVERS_SCREEN))\n\t\t__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tif (wacom->flags & F_HAS_STYLUS2)\n\t\t__set_bit(BTN_STYLUS2, input_dev->keybit);\n\n\tif (wacom->flags & F_HAS_SCROLLWHEEL)\n\t\t__set_bit(REL_WHEEL, input_dev->relbit);\n\n\tinput_abs_set_res(wacom->dev, ABS_X, wacom->res_x);\n\tinput_abs_set_res(wacom->dev, ABS_Y, wacom->res_y);\n\tinput_set_abs_params(wacom->dev, ABS_X, 0, wacom->max_x, 0, 0);\n\tinput_set_abs_params(wacom->dev, ABS_Y, 0, wacom->max_y, 0, 0);\n\tinput_set_abs_params(wacom->dev, ABS_PRESSURE, -1,\n\t\t\t     (1 << (7 + wacom->extra_z_bits)) - 1, 0, 0);\n\n\terr = input_register_device(wacom->dev);\n\tif (err)\n\t\tgoto close_serio;\n\n\treturn 0;\n\nclose_serio:\n\tserio_close(serio);\nfree_device:\n\tserio_set_drvdata(serio, NULL);\n\tinput_free_device(input_dev);\n\tkfree(wacom);\n\treturn err;\n}\n\nstatic const struct serio_device_id wacom_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_WACOM_IV,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, wacom_serio_ids);\n\nstatic struct serio_driver wacom_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"wacom_serial4\",\n\t},\n\t.description\t= \"Wacom protocol 4 serial tablet driver\",\n\t.id_table\t= wacom_serio_ids,\n\t.interrupt\t= wacom_interrupt,\n\t.connect\t= wacom_connect,\n\t.disconnect\t= wacom_disconnect,\n};\n\nmodule_serio_driver(wacom_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}