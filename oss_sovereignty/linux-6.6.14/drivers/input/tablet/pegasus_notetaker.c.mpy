{
  "module_name": "pegasus_notetaker.c",
  "hash_id": "dc5bf691daf1a7b951e6f19305e76a2f30885348d8b5066f7e1c84c60947ec6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/tablet/pegasus_notetaker.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/usb/input.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n\n \n#define USB_REQ_GET_REPORT\t\t0x01\n#define USB_REQ_SET_REPORT\t\t0x09\n\n#define USB_VENDOR_ID_PEGASUSTECH\t0x0e20\n#define USB_DEVICE_ID_PEGASUS_NOTETAKER_EN100\t0x0101\n\n \n#define NOTETAKER_REPORT_ID\t\t0x02\n#define NOTETAKER_SET_CMD\t\t0x80\n#define NOTETAKER_SET_MODE\t\t0xb5\n\n#define NOTETAKER_LED_MOUSE\t\t0x02\n#define PEN_MODE_XY\t\t\t0x01\n\n#define SPECIAL_COMMAND\t\t\t0x80\n#define BUTTON_PRESSED\t\t\t0xb5\n#define COMMAND_VERSION\t\t\t0xa9\n\n \n#define BATTERY_NO_REPORT\t\t0x40\n#define BATTERY_LOW\t\t\t0x41\n#define BATTERY_GOOD\t\t\t0x42\n#define PEN_BUTTON_PRESSED\t\tBIT(1)\n#define PEN_TIP\t\t\t\tBIT(0)\n\nstruct pegasus {\n\tunsigned char *data;\n\tu8 data_len;\n\tdma_addr_t data_dma;\n\tstruct input_dev *dev;\n\tstruct usb_device *usbdev;\n\tstruct usb_interface *intf;\n\tstruct urb *irq;\n\n\t \n\tstruct mutex pm_mutex;\n\tbool is_open;\n\n\tchar name[128];\n\tchar phys[64];\n\tstruct work_struct init;\n};\n\nstatic int pegasus_control_msg(struct pegasus *pegasus, u8 *data, int len)\n{\n\tconst int sizeof_buf = len + 2;\n\tint result;\n\tint error;\n\tu8 *cmd_buf;\n\n\tcmd_buf = kmalloc(sizeof_buf, GFP_KERNEL);\n\tif (!cmd_buf)\n\t\treturn -ENOMEM;\n\n\tcmd_buf[0] = NOTETAKER_REPORT_ID;\n\tcmd_buf[1] = len;\n\tmemcpy(cmd_buf + 2, data, len);\n\n\tresult = usb_control_msg(pegasus->usbdev,\n\t\t\t\t usb_sndctrlpipe(pegasus->usbdev, 0),\n\t\t\t\t USB_REQ_SET_REPORT,\n\t\t\t\t USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t 0, 0, cmd_buf, sizeof_buf,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\n\tkfree(cmd_buf);\n\n\tif (unlikely(result != sizeof_buf)) {\n\t\terror = result < 0 ? result : -EIO;\n\t\tdev_err(&pegasus->usbdev->dev, \"control msg error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int pegasus_set_mode(struct pegasus *pegasus, u8 mode, u8 led)\n{\n\tu8 cmd[] = { NOTETAKER_SET_CMD, NOTETAKER_SET_MODE, led, mode };\n\n\treturn pegasus_control_msg(pegasus, cmd, sizeof(cmd));\n}\n\nstatic void pegasus_parse_packet(struct pegasus *pegasus)\n{\n\tunsigned char *data = pegasus->data;\n\tstruct input_dev *dev = pegasus->dev;\n\tu16 x, y;\n\n\tswitch (data[0]) {\n\tcase SPECIAL_COMMAND:\n\t\t \n\t\tif (data[1] == BUTTON_PRESSED)\n\t\t\tschedule_work(&pegasus->init);\n\n\t\tbreak;\n\n\t \n\tcase BATTERY_LOW:\n\t\tdev_warn_once(&dev->dev, \"Pen battery low\\n\");\n\t\tfallthrough;\n\n\tcase BATTERY_NO_REPORT:\n\tcase BATTERY_GOOD:\n\t\tx = le16_to_cpup((__le16 *)&data[2]);\n\t\ty = le16_to_cpup((__le16 *)&data[4]);\n\n\t\t \n\t\tif (x == 0 && y == 0)\n\t\t\tbreak;\n\n\t\tinput_report_key(dev, BTN_TOUCH, data[1] & PEN_TIP);\n\t\tinput_report_key(dev, BTN_RIGHT, data[1] & PEN_BUTTON_PRESSED);\n\t\tinput_report_key(dev, BTN_TOOL_PEN, 1);\n\t\tinput_report_abs(dev, ABS_X, (s16)x);\n\t\tinput_report_abs(dev, ABS_Y, y);\n\n\t\tinput_sync(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn_once(&pegasus->usbdev->dev,\n\t\t\t      \"unknown answer from device\\n\");\n\t}\n}\n\nstatic void pegasus_irq(struct urb *urb)\n{\n\tstruct pegasus *pegasus = urb->context;\n\tstruct usb_device *dev = pegasus->usbdev;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tpegasus_parse_packet(pegasus);\n\t\tusb_mark_last_busy(pegasus->usbdev);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_err(&dev->dev, \"%s - urb shutting down with status: %d\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\n\tdefault:\n\t\tdev_err(&dev->dev, \"%s - nonzero urb status received: %d\",\n\t\t\t__func__, urb->status);\n\t\tbreak;\n\t}\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->dev, \"%s - usb_submit_urb failed with result %d\",\n\t\t\t__func__, retval);\n}\n\nstatic void pegasus_init(struct work_struct *work)\n{\n\tstruct pegasus *pegasus = container_of(work, struct pegasus, init);\n\tint error;\n\n\terror = pegasus_set_mode(pegasus, PEN_MODE_XY, NOTETAKER_LED_MOUSE);\n\tif (error)\n\t\tdev_err(&pegasus->usbdev->dev, \"pegasus_set_mode error: %d\\n\",\n\t\t\terror);\n}\n\nstatic int pegasus_open(struct input_dev *dev)\n{\n\tstruct pegasus *pegasus = input_get_drvdata(dev);\n\tint error;\n\n\terror = usb_autopm_get_interface(pegasus->intf);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&pegasus->pm_mutex);\n\tpegasus->irq->dev = pegasus->usbdev;\n\tif (usb_submit_urb(pegasus->irq, GFP_KERNEL)) {\n\t\terror = -EIO;\n\t\tgoto err_autopm_put;\n\t}\n\n\terror = pegasus_set_mode(pegasus, PEN_MODE_XY, NOTETAKER_LED_MOUSE);\n\tif (error)\n\t\tgoto err_kill_urb;\n\n\tpegasus->is_open = true;\n\tmutex_unlock(&pegasus->pm_mutex);\n\treturn 0;\n\nerr_kill_urb:\n\tusb_kill_urb(pegasus->irq);\n\tcancel_work_sync(&pegasus->init);\nerr_autopm_put:\n\tmutex_unlock(&pegasus->pm_mutex);\n\tusb_autopm_put_interface(pegasus->intf);\n\treturn error;\n}\n\nstatic void pegasus_close(struct input_dev *dev)\n{\n\tstruct pegasus *pegasus = input_get_drvdata(dev);\n\n\tmutex_lock(&pegasus->pm_mutex);\n\tusb_kill_urb(pegasus->irq);\n\tcancel_work_sync(&pegasus->init);\n\tpegasus->is_open = false;\n\tmutex_unlock(&pegasus->pm_mutex);\n\n\tusb_autopm_put_interface(pegasus->intf);\n}\n\nstatic int pegasus_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct pegasus *pegasus;\n\tstruct input_dev *input_dev;\n\tint error;\n\tint pipe;\n\n\t \n\tif (intf->cur_altsetting->desc.bInterfaceNumber >= 1)\n\t\treturn -ENODEV;\n\n\t \n\tif (intf->cur_altsetting->desc.bNumEndpoints < 1) {\n\t\tdev_err(&intf->dev, \"Invalid number of endpoints\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint = &intf->cur_altsetting->endpoint[0].desc;\n\n\tpegasus = kzalloc(sizeof(*pegasus), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!pegasus || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tmutex_init(&pegasus->pm_mutex);\n\n\tpegasus->usbdev = dev;\n\tpegasus->dev = input_dev;\n\tpegasus->intf = intf;\n\n\tpipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n\t \n\tif (usb_pipe_type_check(dev, pipe)) {\n\t\terror = -EINVAL;\n\t\tgoto err_free_mem;\n\t}\n\n\tpegasus->data_len = usb_maxpacket(dev, pipe);\n\n\tpegasus->data = usb_alloc_coherent(dev, pegasus->data_len, GFP_KERNEL,\n\t\t\t\t\t   &pegasus->data_dma);\n\tif (!pegasus->data) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tpegasus->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->irq) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_dma;\n\t}\n\n\tusb_fill_int_urb(pegasus->irq, dev, pipe,\n\t\t\t pegasus->data, pegasus->data_len,\n\t\t\t pegasus_irq, pegasus, endpoint->bInterval);\n\n\tpegasus->irq->transfer_dma = pegasus->data_dma;\n\tpegasus->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tif (dev->manufacturer)\n\t\tstrscpy(pegasus->name, dev->manufacturer,\n\t\t\tsizeof(pegasus->name));\n\n\tif (dev->product) {\n\t\tif (dev->manufacturer)\n\t\t\tstrlcat(pegasus->name, \" \", sizeof(pegasus->name));\n\t\tstrlcat(pegasus->name, dev->product, sizeof(pegasus->name));\n\t}\n\n\tif (!strlen(pegasus->name))\n\t\tsnprintf(pegasus->name, sizeof(pegasus->name),\n\t\t\t \"USB Pegasus Device %04x:%04x\",\n\t\t\t le16_to_cpu(dev->descriptor.idVendor),\n\t\t\t le16_to_cpu(dev->descriptor.idProduct));\n\n\tusb_make_path(dev, pegasus->phys, sizeof(pegasus->phys));\n\tstrlcat(pegasus->phys, \"/input0\", sizeof(pegasus->phys));\n\n\tINIT_WORK(&pegasus->init, pegasus_init);\n\n\tusb_set_intfdata(intf, pegasus);\n\n\tinput_dev->name = pegasus->name;\n\tinput_dev->phys = pegasus->phys;\n\tusb_to_input_id(dev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, pegasus);\n\n\tinput_dev->open = pegasus_open;\n\tinput_dev->close = pegasus_close;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\n\t__set_bit(ABS_X, input_dev->absbit);\n\t__set_bit(ABS_Y, input_dev->absbit);\n\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t__set_bit(BTN_TOOL_PEN, input_dev->keybit);\n\n\t__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\n\t__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tinput_set_abs_params(input_dev, ABS_X, -1500, 1500, 8, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 1600, 3000, 8, 0);\n\n\terror = input_register_device(pegasus->dev);\n\tif (error)\n\t\tgoto err_free_urb;\n\n\treturn 0;\n\nerr_free_urb:\n\tusb_free_urb(pegasus->irq);\nerr_free_dma:\n\tusb_free_coherent(dev, pegasus->data_len,\n\t\t\t  pegasus->data, pegasus->data_dma);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(pegasus);\n\tusb_set_intfdata(intf, NULL);\n\n\treturn error;\n}\n\nstatic void pegasus_disconnect(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tinput_unregister_device(pegasus->dev);\n\n\tusb_free_urb(pegasus->irq);\n\tusb_free_coherent(interface_to_usbdev(intf),\n\t\t\t  pegasus->data_len, pegasus->data,\n\t\t\t  pegasus->data_dma);\n\n\tkfree(pegasus);\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic int pegasus_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tmutex_lock(&pegasus->pm_mutex);\n\tusb_kill_urb(pegasus->irq);\n\tcancel_work_sync(&pegasus->init);\n\tmutex_unlock(&pegasus->pm_mutex);\n\n\treturn 0;\n}\n\nstatic int pegasus_resume(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\tint retval = 0;\n\n\tmutex_lock(&pegasus->pm_mutex);\n\tif (pegasus->is_open && usb_submit_urb(pegasus->irq, GFP_NOIO) < 0)\n\t\tretval = -EIO;\n\tmutex_unlock(&pegasus->pm_mutex);\n\n\treturn retval;\n}\n\nstatic int pegasus_reset_resume(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\tint retval = 0;\n\n\tmutex_lock(&pegasus->pm_mutex);\n\tif (pegasus->is_open) {\n\t\tretval = pegasus_set_mode(pegasus, PEN_MODE_XY,\n\t\t\t\t\t  NOTETAKER_LED_MOUSE);\n\t\tif (!retval && usb_submit_urb(pegasus->irq, GFP_NOIO) < 0)\n\t\t\tretval = -EIO;\n\t}\n\tmutex_unlock(&pegasus->pm_mutex);\n\n\treturn retval;\n}\n\nstatic const struct usb_device_id pegasus_ids[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_PEGASUSTECH,\n\t\t     USB_DEVICE_ID_PEGASUS_NOTETAKER_EN100) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, pegasus_ids);\n\nstatic struct usb_driver pegasus_driver = {\n\t.name\t\t= \"pegasus_notetaker\",\n\t.probe\t\t= pegasus_probe,\n\t.disconnect\t= pegasus_disconnect,\n\t.suspend\t= pegasus_suspend,\n\t.resume\t\t= pegasus_resume,\n\t.reset_resume\t= pegasus_reset_resume,\n\t.id_table\t= pegasus_ids,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(pegasus_driver);\n\nMODULE_AUTHOR(\"Martin Kepplinger <martink@posteo.de>\");\nMODULE_DESCRIPTION(\"Pegasus Mobile Notetaker Pen tablet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}