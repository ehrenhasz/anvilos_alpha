{
  "module_name": "hanwang.c",
  "hash_id": "a71ce6c4971f0e07a0c8da46d55854d8e3b5fd678fc14f517851084e747b9f80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/tablet/hanwang.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n\nMODULE_AUTHOR(\"Xing Wei <weixing@hanwang.com.cn>\");\nMODULE_DESCRIPTION(\"USB Hanwang tablet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define USB_VENDOR_ID_HANWANG\t\t0x0b57\n#define HANWANG_TABLET_INT_CLASS\t0x0003\n#define HANWANG_TABLET_INT_SUB_CLASS\t0x0001\n#define HANWANG_TABLET_INT_PROTOCOL\t0x0002\n\n#define ART_MASTER_PKGLEN_MAX\t10\n\n \n#define STYLUS_DEVICE_ID\t0x02\n#define TOUCH_DEVICE_ID\t\t0x03\n#define CURSOR_DEVICE_ID\t0x06\n#define ERASER_DEVICE_ID\t0x0A\n#define PAD_DEVICE_ID\t\t0x0F\n\n \n#define HANWANG_TABLET_DEVICE(vend, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_VENDOR \\\n\t\t| USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\nenum hanwang_tablet_type {\n\tHANWANG_ART_MASTER_III,\n\tHANWANG_ART_MASTER_HD,\n\tHANWANG_ART_MASTER_II,\n};\n\nstruct hanwang {\n\tunsigned char *data;\n\tdma_addr_t data_dma;\n\tstruct input_dev *dev;\n\tstruct usb_device *usbdev;\n\tstruct urb *irq;\n\tconst struct hanwang_features *features;\n\tunsigned int current_tool;\n\tunsigned int current_id;\n\tchar name[64];\n\tchar phys[32];\n};\n\nstruct hanwang_features {\n\tunsigned short pid;\n\tchar *name;\n\tenum hanwang_tablet_type type;\n\tint pkg_len;\n\tint max_x;\n\tint max_y;\n\tint max_tilt_x;\n\tint max_tilt_y;\n\tint max_pressure;\n};\n\nstatic const struct hanwang_features features_array[] = {\n\t{ 0x8528, \"Hanwang Art Master III 0906\", HANWANG_ART_MASTER_III,\n\t  ART_MASTER_PKGLEN_MAX, 0x5757, 0x3692, 0x3f, 0x7f, 2048 },\n\t{ 0x8529, \"Hanwang Art Master III 0604\", HANWANG_ART_MASTER_III,\n\t  ART_MASTER_PKGLEN_MAX, 0x3d84, 0x2672, 0x3f, 0x7f, 2048 },\n\t{ 0x852a, \"Hanwang Art Master III 1308\", HANWANG_ART_MASTER_III,\n\t  ART_MASTER_PKGLEN_MAX, 0x7f00, 0x4f60, 0x3f, 0x7f, 2048 },\n\t{ 0x8401, \"Hanwang Art Master HD 5012\", HANWANG_ART_MASTER_HD,\n\t  ART_MASTER_PKGLEN_MAX, 0x678e, 0x4150, 0x3f, 0x7f, 1024 },\n\t{ 0x8503, \"Hanwang Art Master II\", HANWANG_ART_MASTER_II,\n\t  ART_MASTER_PKGLEN_MAX, 0x27de, 0x1cfe, 0x3f, 0x7f, 1024 },\n};\n\nstatic const int hw_eventtypes[] = {\n\tEV_KEY, EV_ABS, EV_MSC,\n};\n\nstatic const int hw_absevents[] = {\n\tABS_X, ABS_Y, ABS_TILT_X, ABS_TILT_Y, ABS_WHEEL,\n\tABS_RX, ABS_RY, ABS_PRESSURE, ABS_MISC,\n};\n\nstatic const int hw_btnevents[] = {\n\tBTN_STYLUS, BTN_STYLUS2, BTN_TOOL_PEN, BTN_TOOL_RUBBER,\n\tBTN_TOOL_MOUSE, BTN_TOOL_FINGER,\n\tBTN_0, BTN_1, BTN_2, BTN_3, BTN_4, BTN_5, BTN_6, BTN_7, BTN_8,\n};\n\nstatic const int hw_mscevents[] = {\n\tMSC_SERIAL,\n};\n\nstatic void hanwang_parse_packet(struct hanwang *hanwang)\n{\n\tunsigned char *data = hanwang->data;\n\tstruct input_dev *input_dev = hanwang->dev;\n\tstruct usb_device *dev = hanwang->usbdev;\n\tenum hanwang_tablet_type type = hanwang->features->type;\n\tint i;\n\tu16 p;\n\n\tif (type == HANWANG_ART_MASTER_II) {\n\t\thanwang->current_tool = BTN_TOOL_PEN;\n\t\thanwang->current_id = STYLUS_DEVICE_ID;\n\t}\n\n\tswitch (data[0]) {\n\tcase 0x02:\t \n\t\tswitch (data[1]) {\n\t\tcase 0x80:\t \n\t\t\tif (type != HANWANG_ART_MASTER_II) {\n\t\t\t\thanwang->current_id = 0;\n\t\t\t\tinput_report_key(input_dev,\n\t\t\t\t\t\t hanwang->current_tool, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x00:\t \n\t\t\tif (type == HANWANG_ART_MASTER_II) {\n\t\t\t\thanwang->current_id = 0;\n\t\t\t\tinput_report_key(input_dev,\n\t\t\t\t\t\t hanwang->current_tool, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0xc2:\t \n\t\t\tswitch (data[3] & 0xf0) {\n\t\t\tcase 0x20:\t \n\t\t\tcase 0x30:\t \n\t\t\t\thanwang->current_id = STYLUS_DEVICE_ID;\n\t\t\t\thanwang->current_tool = BTN_TOOL_PEN;\n\t\t\t\tinput_report_key(input_dev, BTN_TOOL_PEN, 1);\n\t\t\t\tbreak;\n\t\t\tcase 0xa0:\t \n\t\t\tcase 0xb0:\t \n\t\t\t\thanwang->current_id = ERASER_DEVICE_ID;\n\t\t\t\thanwang->current_tool = BTN_TOOL_RUBBER;\n\t\t\t\tinput_report_key(input_dev, BTN_TOOL_RUBBER, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\thanwang->current_id = 0;\n\t\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\t\"unknown tablet tool %02x\\n\", data[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\t \n\t\t\tswitch (type) {\n\t\t\tcase HANWANG_ART_MASTER_III:\n\t\t\t\tp = (data[6] << 3) |\n\t\t\t\t    ((data[7] & 0xc0) >> 5) |\n\t\t\t\t    (data[1] & 0x01);\n\t\t\t\tbreak;\n\n\t\t\tcase HANWANG_ART_MASTER_HD:\n\t\t\tcase HANWANG_ART_MASTER_II:\n\t\t\t\tp = (data[7] >> 6) | (data[6] << 2);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tp = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinput_report_abs(input_dev, ABS_X,\n\t\t\t\t\t be16_to_cpup((__be16 *)&data[2]));\n\t\t\tinput_report_abs(input_dev, ABS_Y,\n\t\t\t\t\t be16_to_cpup((__be16 *)&data[4]));\n\t\t\tinput_report_abs(input_dev, ABS_PRESSURE, p);\n\t\t\tinput_report_abs(input_dev, ABS_TILT_X, data[7] & 0x3f);\n\t\t\tinput_report_abs(input_dev, ABS_TILT_Y, data[8] & 0x7f);\n\t\t\tinput_report_key(input_dev, BTN_STYLUS, data[1] & 0x02);\n\n\t\t\tif (type != HANWANG_ART_MASTER_II)\n\t\t\t\tinput_report_key(input_dev, BTN_STYLUS2,\n\t\t\t\t\t\t data[1] & 0x04);\n\t\t\telse\n\t\t\t\tinput_report_key(input_dev, BTN_TOOL_PEN, 1);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tinput_report_abs(input_dev, ABS_MISC, hanwang->current_id);\n\t\tinput_event(input_dev, EV_MSC, MSC_SERIAL,\n\t\t\t\thanwang->features->pid);\n\t\tbreak;\n\n\tcase 0x0c:\n\t\t \n\t\thanwang->current_id = PAD_DEVICE_ID;\n\n\t\tswitch (type) {\n\t\tcase HANWANG_ART_MASTER_III:\n\t\t\tinput_report_key(input_dev, BTN_TOOL_FINGER,\n\t\t\t\t\t data[1] || data[2] || data[3]);\n\t\t\tinput_report_abs(input_dev, ABS_WHEEL, data[1]);\n\t\t\tinput_report_key(input_dev, BTN_0, data[2]);\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tinput_report_key(input_dev,\n\t\t\t\t\t BTN_1 + i, data[3] & (1 << i));\n\t\t\tbreak;\n\n\t\tcase HANWANG_ART_MASTER_HD:\n\t\t\tinput_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||\n\t\t\t\t\tdata[2] || data[3] || data[4] ||\n\t\t\t\t\tdata[5] || data[6]);\n\t\t\tinput_report_abs(input_dev, ABS_RX,\n\t\t\t\t\t((data[1] & 0x1f) << 8) | data[2]);\n\t\t\tinput_report_abs(input_dev, ABS_RY,\n\t\t\t\t\t((data[3] & 0x1f) << 8) | data[4]);\n\t\t\tinput_report_key(input_dev, BTN_0, data[5] & 0x01);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tinput_report_key(input_dev,\n\t\t\t\t\t BTN_1 + i, data[5] & (1 << i));\n\t\t\t\tinput_report_key(input_dev,\n\t\t\t\t\t BTN_5 + i, data[6] & (1 << i));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HANWANG_ART_MASTER_II:\n\t\t\tdev_dbg(&dev->dev, \"error packet  %02x\\n\", data[0]);\n\t\t\treturn;\n\t\t}\n\n\t\tinput_report_abs(input_dev, ABS_MISC, hanwang->current_id);\n\t\tinput_event(input_dev, EV_MSC, MSC_SERIAL, 0xffffffff);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&dev->dev, \"error packet  %02x\\n\", data[0]);\n\t\tbreak;\n\t}\n\n\tinput_sync(input_dev);\n}\n\nstatic void hanwang_irq(struct urb *urb)\n{\n\tstruct hanwang *hanwang = urb->context;\n\tstruct usb_device *dev = hanwang->usbdev;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t ;\n\t\thanwang_parse_packet(hanwang);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_err(&dev->dev, \"%s - urb shutting down with status: %d\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&dev->dev, \"%s - nonzero urb status received: %d\",\n\t\t\t__func__, urb->status);\n\t\tbreak;\n\t}\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->dev, \"%s - usb_submit_urb failed with result %d\",\n\t\t\t__func__, retval);\n}\n\nstatic int hanwang_open(struct input_dev *dev)\n{\n\tstruct hanwang *hanwang = input_get_drvdata(dev);\n\n\thanwang->irq->dev = hanwang->usbdev;\n\tif (usb_submit_urb(hanwang->irq, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void hanwang_close(struct input_dev *dev)\n{\n\tstruct hanwang *hanwang = input_get_drvdata(dev);\n\n\tusb_kill_urb(hanwang->irq);\n}\n\nstatic bool get_features(struct usb_device *dev, struct hanwang *hanwang)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(features_array); i++) {\n\t\tif (le16_to_cpu(dev->descriptor.idProduct) ==\n\t\t\t\tfeatures_array[i].pid) {\n\t\t\thanwang->features = &features_array[i];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\nstatic int hanwang_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct hanwang *hanwang;\n\tstruct input_dev *input_dev;\n\tint error;\n\tint i;\n\n\tif (intf->cur_altsetting->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\thanwang = kzalloc(sizeof(struct hanwang), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!hanwang || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tif (!get_features(dev, hanwang)) {\n\t\terror = -ENXIO;\n\t\tgoto fail1;\n\t}\n\n\thanwang->data = usb_alloc_coherent(dev, hanwang->features->pkg_len,\n\t\t\t\t\tGFP_KERNEL, &hanwang->data_dma);\n\tif (!hanwang->data) {\n\t\terror = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\thanwang->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hanwang->irq) {\n\t\terror = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\thanwang->usbdev = dev;\n\thanwang->dev = input_dev;\n\n\tusb_make_path(dev, hanwang->phys, sizeof(hanwang->phys));\n\tstrlcat(hanwang->phys, \"/input0\", sizeof(hanwang->phys));\n\n\tstrscpy(hanwang->name, hanwang->features->name, sizeof(hanwang->name));\n\tinput_dev->name = hanwang->name;\n\tinput_dev->phys = hanwang->phys;\n\tusb_to_input_id(dev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, hanwang);\n\n\tinput_dev->open = hanwang_open;\n\tinput_dev->close = hanwang_close;\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_eventtypes); ++i)\n\t\t__set_bit(hw_eventtypes[i], input_dev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_absevents); ++i)\n\t\t__set_bit(hw_absevents[i], input_dev->absbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_btnevents); ++i)\n\t\t__set_bit(hw_btnevents[i], input_dev->keybit);\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_mscevents); ++i)\n\t\t__set_bit(hw_mscevents[i], input_dev->mscbit);\n\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\t     0, hanwang->features->max_x, 4, 0);\n\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\t     0, hanwang->features->max_y, 4, 0);\n\tinput_set_abs_params(input_dev, ABS_TILT_X,\n\t\t\t     0, hanwang->features->max_tilt_x, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_TILT_Y,\n\t\t\t     0, hanwang->features->max_tilt_y, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE,\n\t\t\t     0, hanwang->features->max_pressure, 0, 0);\n\n\tendpoint = &intf->cur_altsetting->endpoint[0].desc;\n\tusb_fill_int_urb(hanwang->irq, dev,\n\t\t\tusb_rcvintpipe(dev, endpoint->bEndpointAddress),\n\t\t\thanwang->data, hanwang->features->pkg_len,\n\t\t\thanwang_irq, hanwang, endpoint->bInterval);\n\thanwang->irq->transfer_dma = hanwang->data_dma;\n\thanwang->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\terror = input_register_device(hanwang->dev);\n\tif (error)\n\t\tgoto fail3;\n\n\tusb_set_intfdata(intf, hanwang);\n\n\treturn 0;\n\n fail3:\tusb_free_urb(hanwang->irq);\n fail2:\tusb_free_coherent(dev, hanwang->features->pkg_len,\n\t\t\thanwang->data, hanwang->data_dma);\n fail1:\tinput_free_device(input_dev);\n\tkfree(hanwang);\n\treturn error;\n\n}\n\nstatic void hanwang_disconnect(struct usb_interface *intf)\n{\n\tstruct hanwang *hanwang = usb_get_intfdata(intf);\n\n\tinput_unregister_device(hanwang->dev);\n\tusb_free_urb(hanwang->irq);\n\tusb_free_coherent(interface_to_usbdev(intf),\n\t\t\thanwang->features->pkg_len, hanwang->data,\n\t\t\thanwang->data_dma);\n\tkfree(hanwang);\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic const struct usb_device_id hanwang_ids[] = {\n\t{ HANWANG_TABLET_DEVICE(USB_VENDOR_ID_HANWANG, HANWANG_TABLET_INT_CLASS,\n\t\tHANWANG_TABLET_INT_SUB_CLASS, HANWANG_TABLET_INT_PROTOCOL) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, hanwang_ids);\n\nstatic struct usb_driver hanwang_driver = {\n\t.name\t\t= \"hanwang\",\n\t.probe\t\t= hanwang_probe,\n\t.disconnect\t= hanwang_disconnect,\n\t.id_table\t= hanwang_ids,\n};\n\nmodule_usb_driver(hanwang_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}