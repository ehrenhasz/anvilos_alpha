{
  "module_name": "locomokbd.c",
  "hash_id": "f25413b4ca126bd726cab9155733729be9630bec14c5a8d1ac747a293a04fcf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/locomokbd.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n\n#include <asm/hardware/locomo.h>\n#include <asm/irq.h>\n\nMODULE_AUTHOR(\"John Lenz <lenz@cs.wisc.edu>\");\nMODULE_DESCRIPTION(\"LoCoMo keyboard driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define LOCOMOKBD_NUMKEYS\t128\n\n#define KEY_ACTIVITY\t\tKEY_F16\n#define KEY_CONTACT\t\tKEY_F18\n#define KEY_CENTER\t\tKEY_F15\n\nstatic const unsigned char\nlocomokbd_keycode[LOCOMOKBD_NUMKEYS] = {\n\t0, KEY_ESC, KEY_ACTIVITY, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t \n\t0, 0, 0, 0, 0, 0, 0, KEY_MENU, KEY_HOME, KEY_CONTACT,\t\t\t \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\t\t\t \n\t0, 0, 0, KEY_CENTER, 0, KEY_MAIL, 0, 0, 0, 0,\t\t\t\t \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, KEY_RIGHT,\t\t\t\t\t \n\tKEY_UP, KEY_LEFT, 0, 0, KEY_P, 0, KEY_O, KEY_I, KEY_Y, KEY_T,\t\t \n\tKEY_E, KEY_W, 0, 0, 0, 0, KEY_DOWN, KEY_ENTER, 0, 0,\t\t\t \n\tKEY_BACKSPACE, 0, KEY_L, KEY_U, KEY_H, KEY_R, KEY_D, KEY_Q, 0, 0,\t \n\t0, 0, 0, 0, 0, 0, KEY_ENTER, KEY_RIGHTSHIFT, KEY_K, KEY_J,\t\t \n\tKEY_G, KEY_F, KEY_X, KEY_S, 0, 0, 0, 0, 0, 0,\t\t\t\t \n\t0, 0, KEY_DOT, 0, KEY_COMMA, KEY_N, KEY_B, KEY_C, KEY_Z, KEY_A,\t\t \n\tKEY_LEFTSHIFT, KEY_TAB, KEY_LEFTCTRL, 0, 0, 0, 0, 0, 0, 0,\t\t \n\tKEY_M, KEY_SPACE, KEY_V, KEY_APOSTROPHE, KEY_SLASH, 0, 0, 0\t\t \n};\n\n#define KB_ROWS\t\t\t16\n#define KB_COLS\t\t\t8\n#define KB_ROWMASK(r)\t\t(1 << (r))\n#define SCANCODE(c,r)\t\t( ((c)<<4) + (r) + 1 )\n\n#define KB_DELAY\t\t8\n#define SCAN_INTERVAL\t\t(HZ/10)\n\nstruct locomokbd {\n\tunsigned char keycode[LOCOMOKBD_NUMKEYS];\n\tstruct input_dev *input;\n\tchar phys[32];\n\n\tunsigned long base;\n\tspinlock_t lock;\n\n\tstruct timer_list timer;\n\tunsigned long suspend_jiffies;\n\tunsigned int count_cancel;\n};\n\n \nstatic inline void locomokbd_charge_all(unsigned long membase)\n{\n\tlocomo_writel(0x00FF, membase + LOCOMO_KSC);\n}\n\nstatic inline void locomokbd_activate_all(unsigned long membase)\n{\n\tunsigned long r;\n\n\tlocomo_writel(0, membase + LOCOMO_KSC);\n\tr = locomo_readl(membase + LOCOMO_KIC);\n\tr &= 0xFEFF;\n\tlocomo_writel(r, membase + LOCOMO_KIC);\n}\n\nstatic inline void locomokbd_activate_col(unsigned long membase, int col)\n{\n\tunsigned short nset;\n\tunsigned short nbset;\n\n\tnset = 0xFF & ~(1 << col);\n\tnbset = (nset << 8) + nset;\n\tlocomo_writel(nbset, membase + LOCOMO_KSC);\n}\n\nstatic inline void locomokbd_reset_col(unsigned long membase, int col)\n{\n\tunsigned short nbset;\n\n\tnbset = ((0xFF & ~(1 << col)) << 8) + 0xFF;\n\tlocomo_writel(nbset, membase + LOCOMO_KSC);\n}\n\n \n\n \nstatic void locomokbd_scankeyboard(struct locomokbd *locomokbd)\n{\n\tunsigned int row, col, rowd;\n\tunsigned long flags;\n\tunsigned int num_pressed;\n\tunsigned long membase = locomokbd->base;\n\n\tspin_lock_irqsave(&locomokbd->lock, flags);\n\n\tlocomokbd_charge_all(membase);\n\n\tnum_pressed = 0;\n\tfor (col = 0; col < KB_COLS; col++) {\n\n\t\tlocomokbd_activate_col(membase, col);\n\t\tudelay(KB_DELAY);\n\n\t\trowd = ~locomo_readl(membase + LOCOMO_KIB);\n\t\tfor (row = 0; row < KB_ROWS; row++) {\n\t\t\tunsigned int scancode, pressed, key;\n\n\t\t\tscancode = SCANCODE(col, row);\n\t\t\tpressed = rowd & KB_ROWMASK(row);\n\t\t\tkey = locomokbd->keycode[scancode];\n\n\t\t\tinput_report_key(locomokbd->input, key, pressed);\n\t\t\tif (likely(!pressed))\n\t\t\t\tcontinue;\n\n\t\t\tnum_pressed++;\n\n\t\t\t \n\t\t\tif (unlikely(key == KEY_ESC)) {\n\t\t\t\tif (!time_after(jiffies,\n\t\t\t\t\tlocomokbd->suspend_jiffies + HZ))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (locomokbd->count_cancel++\n\t\t\t\t\t!= (HZ/SCAN_INTERVAL + 1))\n\t\t\t\t\tcontinue;\n\t\t\t\tinput_event(locomokbd->input, EV_PWR,\n\t\t\t\t\tKEY_SUSPEND, 1);\n\t\t\t\tlocomokbd->suspend_jiffies = jiffies;\n\t\t\t} else\n\t\t\t\tlocomokbd->count_cancel = 0;\n\t\t}\n\t\tlocomokbd_reset_col(membase, col);\n\t}\n\tlocomokbd_activate_all(membase);\n\n\tinput_sync(locomokbd->input);\n\n\t \n\tif (num_pressed)\n\t\tmod_timer(&locomokbd->timer, jiffies + SCAN_INTERVAL);\n\telse\n\t\tlocomokbd->count_cancel = 0;\n\n\tspin_unlock_irqrestore(&locomokbd->lock, flags);\n}\n\n \nstatic irqreturn_t locomokbd_interrupt(int irq, void *dev_id)\n{\n\tstruct locomokbd *locomokbd = dev_id;\n\tu16 r;\n\n\tr = locomo_readl(locomokbd->base + LOCOMO_KIC);\n\tif ((r & 0x0001) == 0)\n\t\treturn IRQ_HANDLED;\n\n\tlocomo_writel(r & ~0x0100, locomokbd->base + LOCOMO_KIC);  \n\n\t \n\tudelay(100);\n\n\tlocomokbd_scankeyboard(locomokbd);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void locomokbd_timer_callback(struct timer_list *t)\n{\n\tstruct locomokbd *locomokbd = from_timer(locomokbd, t, timer);\n\n\tlocomokbd_scankeyboard(locomokbd);\n}\n\nstatic int locomokbd_open(struct input_dev *dev)\n{\n\tstruct locomokbd *locomokbd = input_get_drvdata(dev);\n\tu16 r;\n\t\n\tr = locomo_readl(locomokbd->base + LOCOMO_KIC) | 0x0010;\n\tlocomo_writel(r, locomokbd->base + LOCOMO_KIC);\n\treturn 0;\n}\n\nstatic void locomokbd_close(struct input_dev *dev)\n{\n\tstruct locomokbd *locomokbd = input_get_drvdata(dev);\n\tu16 r;\n\t\n\tr = locomo_readl(locomokbd->base + LOCOMO_KIC) & ~0x0010;\n\tlocomo_writel(r, locomokbd->base + LOCOMO_KIC);\n}\n\nstatic int locomokbd_probe(struct locomo_dev *dev)\n{\n\tstruct locomokbd *locomokbd;\n\tstruct input_dev *input_dev;\n\tint i, err;\n\n\tlocomokbd = kzalloc(sizeof(struct locomokbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!locomokbd || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\t \n\tif (!request_mem_region((unsigned long) dev->mapbase,\n\t\t\t\tdev->length,\n\t\t\t\tLOCOMO_DRIVER_NAME(dev))) {\n\t\terr = -EBUSY;\n\t\tprintk(KERN_ERR \"locomokbd: Can't acquire access to io memory for keyboard\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\tlocomo_set_drvdata(dev, locomokbd);\n\n\tlocomokbd->base = (unsigned long) dev->mapbase;\n\n\tspin_lock_init(&locomokbd->lock);\n\n\ttimer_setup(&locomokbd->timer, locomokbd_timer_callback, 0);\n\n\tlocomokbd->suspend_jiffies = jiffies;\n\n\tlocomokbd->input = input_dev;\n\tstrcpy(locomokbd->phys, \"locomokbd/input0\");\n\n\tinput_dev->name = \"LoCoMo keyboard\";\n\tinput_dev->phys = locomokbd->phys;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->open = locomokbd_open;\n\tinput_dev->close = locomokbd_close;\n\tinput_dev->dev.parent = &dev->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |\n\t\t\t\tBIT_MASK(EV_PWR);\n\tinput_dev->keycode = locomokbd->keycode;\n\tinput_dev->keycodesize = sizeof(locomokbd_keycode[0]);\n\tinput_dev->keycodemax = ARRAY_SIZE(locomokbd_keycode);\n\n\tinput_set_drvdata(input_dev, locomokbd);\n\n\tmemcpy(locomokbd->keycode, locomokbd_keycode, sizeof(locomokbd->keycode));\n\tfor (i = 0; i < LOCOMOKBD_NUMKEYS; i++)\n\t\tset_bit(locomokbd->keycode[i], input_dev->keybit);\n\tclear_bit(0, input_dev->keybit);\n\n\t \n\terr = request_irq(dev->irq[0], locomokbd_interrupt, 0, \"locomokbd\", locomokbd);\n\tif (err) {\n\t\tprintk(KERN_ERR \"locomokbd: Can't get irq for keyboard\\n\");\n\t\tgoto err_release_region;\n\t}\n\n\terr = input_register_device(locomokbd->input);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(dev->irq[0], locomokbd);\n err_release_region:\n\trelease_mem_region((unsigned long) dev->mapbase, dev->length);\n\tlocomo_set_drvdata(dev, NULL);\n err_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(locomokbd);\n\n\treturn err;\n}\n\nstatic void locomokbd_remove(struct locomo_dev *dev)\n{\n\tstruct locomokbd *locomokbd = locomo_get_drvdata(dev);\n\n\tfree_irq(dev->irq[0], locomokbd);\n\n\ttimer_shutdown_sync(&locomokbd->timer);\n\n\tinput_unregister_device(locomokbd->input);\n\tlocomo_set_drvdata(dev, NULL);\n\n\trelease_mem_region((unsigned long) dev->mapbase, dev->length);\n\n\tkfree(locomokbd);\n}\n\nstatic struct locomo_driver keyboard_driver = {\n\t.drv = {\n\t\t.name = \"locomokbd\"\n\t},\n\t.devid\t= LOCOMO_DEVID_KEYBOARD,\n\t.probe\t= locomokbd_probe,\n\t.remove\t= locomokbd_remove,\n};\n\nstatic int __init locomokbd_init(void)\n{\n\treturn locomo_driver_register(&keyboard_driver);\n}\n\nstatic void __exit locomokbd_exit(void)\n{\n\tlocomo_driver_unregister(&keyboard_driver);\n}\n\nmodule_init(locomokbd_init);\nmodule_exit(locomokbd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}