{
  "module_name": "pxa27x_keypad.c",
  "hash_id": "eba831fb99d3f9c0cc5196a8e956d24663ede2ab70eb7ec2aecdb96c609691ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/pxa27x_keypad.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/keypad-pxa27x.h>\n \n#define KPC             0x0000  \n#define KPDK            0x0008  \n#define KPREC           0x0010  \n#define KPMK            0x0018  \n#define KPAS            0x0020  \n\n \n#define KPASMKP0        0x0028\n#define KPASMKP1        0x0030\n#define KPASMKP2        0x0038\n#define KPASMKP3        0x0040\n#define KPKDI           0x0048\n\n \n#define KPC_MKRN(n)\t((((n) - 1) & 0x7) << 26)  \n#define KPC_MKCN(n)\t((((n) - 1) & 0x7) << 23)  \n#define KPC_DKN(n)\t((((n) - 1) & 0x7) << 6)   \n\n#define KPC_AS          (0x1 << 30)   \n#define KPC_ASACT       (0x1 << 29)   \n#define KPC_MI          (0x1 << 22)   \n#define KPC_IMKP        (0x1 << 21)   \n\n#define KPC_MS(n)\t(0x1 << (13 + (n)))\t \n#define KPC_MS_ALL      (0xff << 13)\n\n#define KPC_ME          (0x1 << 12)   \n#define KPC_MIE         (0x1 << 11)   \n#define KPC_DK_DEB_SEL\t(0x1 <<  9)   \n#define KPC_DI          (0x1 <<  5)   \n#define KPC_RE_ZERO_DEB (0x1 <<  4)   \n#define KPC_REE1        (0x1 <<  3)   \n#define KPC_REE0        (0x1 <<  2)   \n#define KPC_DE          (0x1 <<  1)   \n#define KPC_DIE         (0x1 <<  0)   \n\n#define KPDK_DKP        (0x1 << 31)\n#define KPDK_DK(n)\t((n) & 0xff)\n\n#define KPREC_OF1       (0x1 << 31)\n#define kPREC_UF1       (0x1 << 30)\n#define KPREC_OF0       (0x1 << 15)\n#define KPREC_UF0       (0x1 << 14)\n\n#define KPREC_RECOUNT0(n)\t((n) & 0xff)\n#define KPREC_RECOUNT1(n)\t(((n) >> 16) & 0xff)\n\n#define KPMK_MKP        (0x1 << 31)\n#define KPAS_SO         (0x1 << 31)\n#define KPASMKPx_SO     (0x1 << 31)\n\n#define KPAS_MUKP(n)\t(((n) >> 26) & 0x1f)\n#define KPAS_RP(n)\t(((n) >> 4) & 0xf)\n#define KPAS_CP(n)\t((n) & 0xf)\n\n#define KPASMKP_MKC_MASK\t(0xff)\n\n#define keypad_readl(off)\t__raw_readl(keypad->mmio_base + (off))\n#define keypad_writel(off, v)\t__raw_writel((v), keypad->mmio_base + (off))\n\n#define MAX_MATRIX_KEY_NUM\t(MAX_MATRIX_KEY_ROWS * MAX_MATRIX_KEY_COLS)\n#define MAX_KEYPAD_KEYS\t\t(MAX_MATRIX_KEY_NUM + MAX_DIRECT_KEY_NUM)\n\nstruct pxa27x_keypad {\n\tconst struct pxa27x_keypad_platform_data *pdata;\n\n\tstruct clk *clk;\n\tstruct input_dev *input_dev;\n\tvoid __iomem *mmio_base;\n\n\tint irq;\n\n\tunsigned short keycodes[MAX_KEYPAD_KEYS];\n\tint rotary_rel_code[2];\n\n\tunsigned int row_shift;\n\n\t \n\tuint32_t matrix_key_state[MAX_MATRIX_KEY_COLS];\n\tuint32_t direct_key_state;\n\n\tunsigned int direct_key_mask;\n};\n\n#ifdef CONFIG_OF\nstatic int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad,\n\t\t\t\tstruct pxa27x_keypad_platform_data *pdata)\n{\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tstruct device *dev = input_dev->dev.parent;\n\tu32 rows, cols;\n\tint error;\n\n\terror = matrix_keypad_parse_properties(dev, &rows, &cols);\n\tif (error)\n\t\treturn error;\n\n\tif (rows > MAX_MATRIX_KEY_ROWS || cols > MAX_MATRIX_KEY_COLS) {\n\t\tdev_err(dev, \"rows or cols exceeds maximum value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->matrix_key_rows = rows;\n\tpdata->matrix_key_cols = cols;\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   pdata->matrix_key_rows,\n\t\t\t\t\t   pdata->matrix_key_cols,\n\t\t\t\t\t   keypad->keycodes, input_dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int pxa27x_keypad_direct_key_parse_dt(struct pxa27x_keypad *keypad,\n\t\t\t\tstruct pxa27x_keypad_platform_data *pdata)\n{\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tstruct device *dev = input_dev->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tconst __be16 *prop;\n\tunsigned short code;\n\tunsigned int proplen, size;\n\tint i;\n\tint error;\n\n\terror = of_property_read_u32(np, \"marvell,direct-key-count\",\n\t\t\t\t     &pdata->direct_key_num);\n\tif (error) {\n\t\t \n\t\treturn error == -EINVAL ? 0 : error;\n\t}\n\n\terror = of_property_read_u32(np, \"marvell,direct-key-mask\",\n\t\t\t\t     &pdata->direct_key_mask);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\treturn error;\n\n\t\t \n\t\tpdata->direct_key_mask = 0;\n\t}\n\n\tpdata->direct_key_low_active = of_property_read_bool(np,\n\t\t\t\t\t\"marvell,direct-key-low-active\");\n\n\tprop = of_get_property(np, \"marvell,direct-key-map\", &proplen);\n\tif (!prop)\n\t\treturn -EINVAL;\n\n\tif (proplen % sizeof(u16))\n\t\treturn -EINVAL;\n\n\tsize = proplen / sizeof(u16);\n\n\t \n\tif (size > MAX_DIRECT_KEY_NUM)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < size; i++) {\n\t\tcode = be16_to_cpup(prop + i);\n\t\tkeypad->keycodes[MAX_MATRIX_KEY_NUM + i] = code;\n\t\t__set_bit(code, input_dev->keybit);\n\t}\n\n\treturn 0;\n}\n\nstatic int pxa27x_keypad_rotary_parse_dt(struct pxa27x_keypad *keypad,\n\t\t\t\tstruct pxa27x_keypad_platform_data *pdata)\n{\n\tconst __be32 *prop;\n\tint i, relkey_ret;\n\tunsigned int code, proplen;\n\tconst char *rotaryname[2] = {\n\t\t\t\"marvell,rotary0\", \"marvell,rotary1\"};\n\tconst char relkeyname[] = {\"marvell,rotary-rel-key\"};\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tstruct device *dev = input_dev->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\n\trelkey_ret = of_property_read_u32(np, relkeyname, &code);\n\t \n\tif (relkey_ret == 0) {\n\t\tunsigned short relcode;\n\n\t\t \n\t\trelcode = code & 0xffff;\n\t\tpdata->rotary0_rel_code = (code & 0xffff);\n\t\t__set_bit(relcode, input_dev->relbit);\n\n\t\trelcode = code >> 16;\n\t\tpdata->rotary1_rel_code = relcode;\n\t\t__set_bit(relcode, input_dev->relbit);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tprop = of_get_property(np, rotaryname[i], &proplen);\n\t\t \n\t\tif (!prop)\n\t\t\tcontinue;\n\n\t\tcode = be32_to_cpup(prop);\n\t\t \n\t\tif ((!(code & 0xffff) || !(code >> 16)) && relkey_ret) {\n\t\t\treturn relkey_ret;\n\t\t} else {\n\t\t\tunsigned int n = MAX_MATRIX_KEY_NUM + (i << 1);\n\t\t\tunsigned short keycode;\n\n\t\t\tkeycode = code & 0xffff;\n\t\t\tkeypad->keycodes[n] = keycode;\n\t\t\t__set_bit(keycode, input_dev->keybit);\n\n\t\t\tkeycode = code >> 16;\n\t\t\tkeypad->keycodes[n + 1] = keycode;\n\t\t\t__set_bit(keycode, input_dev->keybit);\n\n\t\t\tif (i == 0)\n\t\t\t\tpdata->rotary0_rel_code = -1;\n\t\t\telse\n\t\t\t\tpdata->rotary1_rel_code = -1;\n\t\t}\n\t\tif (i == 0)\n\t\t\tpdata->enable_rotary0 = 1;\n\t\telse\n\t\t\tpdata->enable_rotary1 = 1;\n\t}\n\n\tkeypad->rotary_rel_code[0] = pdata->rotary0_rel_code;\n\tkeypad->rotary_rel_code[1] = pdata->rotary1_rel_code;\n\n\treturn 0;\n}\n\nstatic int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)\n{\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tstruct device *dev = input_dev->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tstruct pxa27x_keypad_platform_data *pdata;\n\tint error;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tdev_err(dev, \"failed to allocate memory for pdata\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terror = pxa27x_keypad_matrix_key_parse_dt(keypad, pdata);\n\tif (error) {\n\t\tdev_err(dev, \"failed to parse matrix key\\n\");\n\t\treturn error;\n\t}\n\n\terror = pxa27x_keypad_direct_key_parse_dt(keypad, pdata);\n\tif (error) {\n\t\tdev_err(dev, \"failed to parse direct key\\n\");\n\t\treturn error;\n\t}\n\n\terror = pxa27x_keypad_rotary_parse_dt(keypad, pdata);\n\tif (error) {\n\t\tdev_err(dev, \"failed to parse rotary key\\n\");\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(np, \"marvell,debounce-interval\",\n\t\t\t\t     &pdata->debounce_interval);\n\tif (error) {\n\t\tdev_err(dev, \"failed to parse debounce-interval\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tinput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\n\n\tkeypad->pdata = pdata;\n\treturn 0;\n}\n\n#else\n\nstatic int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)\n{\n\tdev_info(keypad->input_dev->dev.parent, \"missing platform data\\n\");\n\n\treturn -EINVAL;\n}\n\n#endif\n\nstatic int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tunsigned short keycode;\n\tint i;\n\tint error;\n\n\terror = matrix_keypad_build_keymap(pdata->matrix_keymap_data, NULL,\n\t\t\t\t\t   pdata->matrix_key_rows,\n\t\t\t\t\t   pdata->matrix_key_cols,\n\t\t\t\t\t   keypad->keycodes, input_dev);\n\tif (error)\n\t\treturn error;\n\n\t \n\tinput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\n\n\t \n\tfor (i = 0; i < pdata->direct_key_num; i++) {\n\t\tkeycode = pdata->direct_key_map[i];\n\t\tkeypad->keycodes[MAX_MATRIX_KEY_NUM + i] = keycode;\n\t\t__set_bit(keycode, input_dev->keybit);\n\t}\n\n\tif (pdata->enable_rotary0) {\n\t\tif (pdata->rotary0_up_key && pdata->rotary0_down_key) {\n\t\t\tkeycode = pdata->rotary0_up_key;\n\t\t\tkeypad->keycodes[MAX_MATRIX_KEY_NUM + 0] = keycode;\n\t\t\t__set_bit(keycode, input_dev->keybit);\n\n\t\t\tkeycode = pdata->rotary0_down_key;\n\t\t\tkeypad->keycodes[MAX_MATRIX_KEY_NUM + 1] = keycode;\n\t\t\t__set_bit(keycode, input_dev->keybit);\n\n\t\t\tkeypad->rotary_rel_code[0] = -1;\n\t\t} else {\n\t\t\tkeypad->rotary_rel_code[0] = pdata->rotary0_rel_code;\n\t\t\t__set_bit(pdata->rotary0_rel_code, input_dev->relbit);\n\t\t}\n\t}\n\n\tif (pdata->enable_rotary1) {\n\t\tif (pdata->rotary1_up_key && pdata->rotary1_down_key) {\n\t\t\tkeycode = pdata->rotary1_up_key;\n\t\t\tkeypad->keycodes[MAX_MATRIX_KEY_NUM + 2] = keycode;\n\t\t\t__set_bit(keycode, input_dev->keybit);\n\n\t\t\tkeycode = pdata->rotary1_down_key;\n\t\t\tkeypad->keycodes[MAX_MATRIX_KEY_NUM + 3] = keycode;\n\t\t\t__set_bit(keycode, input_dev->keybit);\n\n\t\t\tkeypad->rotary_rel_code[1] = -1;\n\t\t} else {\n\t\t\tkeypad->rotary_rel_code[1] = pdata->rotary1_rel_code;\n\t\t\t__set_bit(pdata->rotary1_rel_code, input_dev->relbit);\n\t\t}\n\t}\n\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\treturn 0;\n}\n\nstatic void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tint row, col, num_keys_pressed = 0;\n\tuint32_t new_state[MAX_MATRIX_KEY_COLS];\n\tuint32_t kpas = keypad_readl(KPAS);\n\n\tnum_keys_pressed = KPAS_MUKP(kpas);\n\n\tmemset(new_state, 0, sizeof(new_state));\n\n\tif (num_keys_pressed == 0)\n\t\tgoto scan;\n\n\tif (num_keys_pressed == 1) {\n\t\tcol = KPAS_CP(kpas);\n\t\trow = KPAS_RP(kpas);\n\n\t\t \n\t\tif (col >= pdata->matrix_key_cols ||\n\t\t    row >= pdata->matrix_key_rows)\n\t\t\tgoto scan;\n\n\t\tnew_state[col] = (1 << row);\n\t\tgoto scan;\n\t}\n\n\tif (num_keys_pressed > 1) {\n\t\tuint32_t kpasmkp0 = keypad_readl(KPASMKP0);\n\t\tuint32_t kpasmkp1 = keypad_readl(KPASMKP1);\n\t\tuint32_t kpasmkp2 = keypad_readl(KPASMKP2);\n\t\tuint32_t kpasmkp3 = keypad_readl(KPASMKP3);\n\n\t\tnew_state[0] = kpasmkp0 & KPASMKP_MKC_MASK;\n\t\tnew_state[1] = (kpasmkp0 >> 16) & KPASMKP_MKC_MASK;\n\t\tnew_state[2] = kpasmkp1 & KPASMKP_MKC_MASK;\n\t\tnew_state[3] = (kpasmkp1 >> 16) & KPASMKP_MKC_MASK;\n\t\tnew_state[4] = kpasmkp2 & KPASMKP_MKC_MASK;\n\t\tnew_state[5] = (kpasmkp2 >> 16) & KPASMKP_MKC_MASK;\n\t\tnew_state[6] = kpasmkp3 & KPASMKP_MKC_MASK;\n\t\tnew_state[7] = (kpasmkp3 >> 16) & KPASMKP_MKC_MASK;\n\t}\nscan:\n\tfor (col = 0; col < pdata->matrix_key_cols; col++) {\n\t\tuint32_t bits_changed;\n\t\tint code;\n\n\t\tbits_changed = keypad->matrix_key_state[col] ^ new_state[col];\n\t\tif (bits_changed == 0)\n\t\t\tcontinue;\n\n\t\tfor (row = 0; row < pdata->matrix_key_rows; row++) {\n\t\t\tif ((bits_changed & (1 << row)) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\n\n\t\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(input_dev, keypad->keycodes[code],\n\t\t\t\t\t new_state[col] & (1 << row));\n\t\t}\n\t}\n\tinput_sync(input_dev);\n\tmemcpy(keypad->matrix_key_state, new_state, sizeof(new_state));\n}\n\n#define DEFAULT_KPREC\t(0x007f007f)\n\nstatic inline int rotary_delta(uint32_t kprec)\n{\n\tif (kprec & KPREC_OF0)\n\t\treturn (kprec & 0xff) + 0x7f;\n\telse if (kprec & KPREC_UF0)\n\t\treturn (kprec & 0xff) - 0x7f - 0xff;\n\telse\n\t\treturn (kprec & 0xff) - 0x7f;\n}\n\nstatic void report_rotary_event(struct pxa27x_keypad *keypad, int r, int delta)\n{\n\tstruct input_dev *dev = keypad->input_dev;\n\n\tif (delta == 0)\n\t\treturn;\n\n\tif (keypad->rotary_rel_code[r] == -1) {\n\t\tint code = MAX_MATRIX_KEY_NUM + 2 * r + (delta > 0 ? 0 : 1);\n\t\tunsigned char keycode = keypad->keycodes[code];\n\n\t\t \n\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(dev, keycode, 1);\n\t\tinput_sync(dev);\n\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(dev, keycode, 0);\n\t\tinput_sync(dev);\n\t} else {\n\t\tinput_report_rel(dev, keypad->rotary_rel_code[r], delta);\n\t\tinput_sync(dev);\n\t}\n}\n\nstatic void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\n\tuint32_t kprec;\n\n\t \n\tkprec = keypad_readl(KPREC);\n\tkeypad_writel(KPREC, DEFAULT_KPREC);\n\n\tif (pdata->enable_rotary0)\n\t\treport_rotary_event(keypad, 0, rotary_delta(kprec));\n\n\tif (pdata->enable_rotary1)\n\t\treport_rotary_event(keypad, 1, rotary_delta(kprec >> 16));\n}\n\nstatic void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tunsigned int new_state;\n\tuint32_t kpdk, bits_changed;\n\tint i;\n\n\tkpdk = keypad_readl(KPDK);\n\n\tif (pdata->enable_rotary0 || pdata->enable_rotary1)\n\t\tpxa27x_keypad_scan_rotary(keypad);\n\n\t \n\tif (pdata->direct_key_low_active)\n\t\tnew_state = ~KPDK_DK(kpdk) & keypad->direct_key_mask;\n\telse\n\t\tnew_state = KPDK_DK(kpdk) & keypad->direct_key_mask;\n\n\tbits_changed = keypad->direct_key_state ^ new_state;\n\n\tif (bits_changed == 0)\n\t\treturn;\n\n\tfor (i = 0; i < pdata->direct_key_num; i++) {\n\t\tif (bits_changed & (1 << i)) {\n\t\t\tint code = MAX_MATRIX_KEY_NUM + i;\n\n\t\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(input_dev, keypad->keycodes[code],\n\t\t\t\t\t new_state & (1 << i));\n\t\t}\n\t}\n\tinput_sync(input_dev);\n\tkeypad->direct_key_state = new_state;\n}\n\nstatic void clear_wakeup_event(struct pxa27x_keypad *keypad)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\n\n\tif (pdata->clear_wakeup_event)\n\t\t(pdata->clear_wakeup_event)();\n}\n\nstatic irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)\n{\n\tstruct pxa27x_keypad *keypad = dev_id;\n\tunsigned long kpc = keypad_readl(KPC);\n\n\tclear_wakeup_event(keypad);\n\n\tif (kpc & KPC_DI)\n\t\tpxa27x_keypad_scan_direct(keypad);\n\n\tif (kpc & KPC_MI)\n\t\tpxa27x_keypad_scan_matrix(keypad);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pxa27x_keypad_config(struct pxa27x_keypad *keypad)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata = keypad->pdata;\n\tunsigned int mask = 0, direct_key_num = 0;\n\tunsigned long kpc = 0;\n\n\t \n\tkeypad_readl(KPC);\n\n\t \n\tif (pdata->matrix_key_rows && pdata->matrix_key_cols) {\n\t\tkpc |= KPC_ASACT | KPC_MIE | KPC_ME | KPC_MS_ALL;\n\t\tkpc |= KPC_MKRN(pdata->matrix_key_rows) |\n\t\t       KPC_MKCN(pdata->matrix_key_cols);\n\t}\n\n\t \n\tif (pdata->enable_rotary0) {\n\t\tmask |= 0x03;\n\t\tdirect_key_num = 2;\n\t\tkpc |= KPC_REE0;\n\t}\n\n\tif (pdata->enable_rotary1) {\n\t\tmask |= 0x0c;\n\t\tdirect_key_num = 4;\n\t\tkpc |= KPC_REE1;\n\t}\n\n\tif (pdata->direct_key_num > direct_key_num)\n\t\tdirect_key_num = pdata->direct_key_num;\n\n\t \n\tif (pdata->direct_key_mask)\n\t\tkeypad->direct_key_mask = pdata->direct_key_mask;\n\telse\n\t\tkeypad->direct_key_mask = ((1 << direct_key_num) - 1) & ~mask;\n\n\t \n\tif (direct_key_num)\n\t\tkpc |= KPC_DE | KPC_DIE | KPC_DKN(direct_key_num);\n\n\tkeypad_writel(KPC, kpc | KPC_RE_ZERO_DEB);\n\tkeypad_writel(KPREC, DEFAULT_KPREC);\n\tkeypad_writel(KPKDI, pdata->debounce_interval);\n}\n\nstatic int pxa27x_keypad_open(struct input_dev *dev)\n{\n\tstruct pxa27x_keypad *keypad = input_get_drvdata(dev);\n\tint ret;\n\t \n\tret = clk_prepare_enable(keypad->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpxa27x_keypad_config(keypad);\n\n\treturn 0;\n}\n\nstatic void pxa27x_keypad_close(struct input_dev *dev)\n{\n\tstruct pxa27x_keypad *keypad = input_get_drvdata(dev);\n\n\t \n\tclk_disable_unprepare(keypad->clk);\n}\n\nstatic int pxa27x_keypad_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\n\n\t \n\tif (device_may_wakeup(&pdev->dev))\n\t\tenable_irq_wake(keypad->irq);\n\telse\n\t\tclk_disable_unprepare(keypad->clk);\n\n\treturn 0;\n}\n\nstatic int pxa27x_keypad_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tint ret = 0;\n\n\t \n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tdisable_irq_wake(keypad->irq);\n\t} else {\n\t\tmutex_lock(&input_dev->mutex);\n\n\t\tif (input_device_enabled(input_dev)) {\n\t\t\t \n\t\t\tret = clk_prepare_enable(keypad->clk);\n\t\t\tif (!ret)\n\t\t\t\tpxa27x_keypad_config(keypad);\n\t\t}\n\n\t\tmutex_unlock(&input_dev->mutex);\n\t}\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pxa27x_keypad_pm_ops,\n\t\t\t\tpxa27x_keypad_suspend, pxa27x_keypad_resume);\n\n\nstatic int pxa27x_keypad_probe(struct platform_device *pdev)\n{\n\tconst struct pxa27x_keypad_platform_data *pdata =\n\t\t\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct pxa27x_keypad *keypad;\n\tstruct input_dev *input_dev;\n\tint irq, error;\n\n\t \n\tif (!np && !pdata)\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(*keypad),\n\t\t\t      GFP_KERNEL);\n\tif (!keypad)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tkeypad->pdata = pdata;\n\tkeypad->input_dev = input_dev;\n\tkeypad->irq = irq;\n\n\tkeypad->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(keypad->mmio_base))\n\t\treturn PTR_ERR(keypad->mmio_base);\n\n\tkeypad->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(keypad->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get keypad clock\\n\");\n\t\treturn PTR_ERR(keypad->clk);\n\t}\n\n\tinput_dev->name = pdev->name;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->open = pxa27x_keypad_open;\n\tinput_dev->close = pxa27x_keypad_close;\n\tinput_dev->dev.parent = &pdev->dev;\n\n\tinput_dev->keycode = keypad->keycodes;\n\tinput_dev->keycodesize = sizeof(keypad->keycodes[0]);\n\tinput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\n\n\tinput_set_drvdata(input_dev, keypad);\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\n\tif (pdata) {\n\t\terror = pxa27x_keypad_build_keycode(keypad);\n\t} else {\n\t\terror = pxa27x_keypad_build_keycode_from_dt(keypad);\n\t\t \n\t\tpdata = keypad->pdata;\n\t}\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to build keycode\\n\");\n\t\treturn error;\n\t}\n\n\tkeypad->row_shift = get_count_order(pdata->matrix_key_cols);\n\n\tif ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||\n\t    (pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_REL);\n\t}\n\n\terror = devm_request_irq(&pdev->dev, irq, pxa27x_keypad_irq_handler,\n\t\t\t\t 0, pdev->name, keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, keypad);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa27x_keypad_dt_match[] = {\n\t{ .compatible = \"marvell,pxa27x-keypad\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pxa27x_keypad_dt_match);\n#endif\n\nstatic struct platform_driver pxa27x_keypad_driver = {\n\t.probe\t\t= pxa27x_keypad_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa27x-keypad\",\n\t\t.of_match_table = of_match_ptr(pxa27x_keypad_dt_match),\n\t\t.pm\t= pm_sleep_ptr(&pxa27x_keypad_pm_ops),\n\t},\n};\nmodule_platform_driver(pxa27x_keypad_driver);\n\nMODULE_DESCRIPTION(\"PXA27x Keypad Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n \nMODULE_ALIAS(\"platform:pxa27x-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}