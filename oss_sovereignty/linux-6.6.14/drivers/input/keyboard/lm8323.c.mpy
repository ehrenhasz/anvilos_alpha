{
  "module_name": "lm8323.c",
  "hash_id": "002222d0e9a12c5510f8828d700bd254743ed5f9dcdc6e061ac612f23e09ce27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/lm8323.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/leds.h>\n#include <linux/platform_data/lm8323.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n\n \n#define LM8323_CMD_READ_ID\t\t0x80  \n#define LM8323_CMD_WRITE_CFG\t\t0x81  \n#define LM8323_CMD_READ_INT\t\t0x82  \n#define LM8323_CMD_RESET\t\t0x83  \n#define LM8323_CMD_WRITE_PORT_SEL\t0x85  \n#define LM8323_CMD_WRITE_PORT_STATE\t0x86  \n#define LM8323_CMD_READ_PORT_SEL\t0x87  \n#define LM8323_CMD_READ_PORT_STATE\t0x88  \n#define LM8323_CMD_READ_FIFO\t\t0x89  \n#define LM8323_CMD_RPT_READ_FIFO\t0x8a  \n#define LM8323_CMD_SET_ACTIVE\t\t0x8b  \n#define LM8323_CMD_READ_ERR\t\t0x8c  \n#define LM8323_CMD_READ_ROTATOR\t\t0x8e  \n#define LM8323_CMD_SET_DEBOUNCE\t\t0x8f  \n#define LM8323_CMD_SET_KEY_SIZE\t\t0x90  \n#define LM8323_CMD_READ_KEY_SIZE\t0x91  \n#define LM8323_CMD_READ_CFG\t\t0x92  \n#define LM8323_CMD_WRITE_CLOCK\t\t0x93  \n#define LM8323_CMD_READ_CLOCK\t\t0x94  \n#define LM8323_CMD_PWM_WRITE\t\t0x95  \n#define LM8323_CMD_START_PWM\t\t0x96  \n#define LM8323_CMD_STOP_PWM\t\t0x97  \n\n \n#define INT_KEYPAD\t\t\t0x01  \n#define INT_ROTATOR\t\t\t0x02  \n#define INT_ERROR\t\t\t0x08  \n#define INT_NOINIT\t\t\t0x10  \n#define INT_PWM1\t\t\t0x20  \n#define INT_PWM2\t\t\t0x40  \n#define INT_PWM3\t\t\t0x80  \n\n \n#define ERR_BADPAR\t\t\t0x01  \n#define ERR_CMDUNK\t\t\t0x02  \n#define ERR_KEYOVR\t\t\t0x04  \n#define ERR_FIFOOVER\t\t\t0x40  \n\n \n#define CFG_MUX1SEL\t\t\t0x01  \n#define CFG_MUX1EN\t\t\t0x02  \n#define CFG_MUX2SEL\t\t\t0x04  \n#define CFG_MUX2EN\t\t\t0x08  \n#define CFG_PSIZE\t\t\t0x20  \n#define CFG_ROTEN\t\t\t0x40  \n\n \n#define CLK_RCPWM_INTERNAL\t\t0x00\n#define CLK_RCPWM_EXTERNAL\t\t0x03\n#define CLK_SLOWCLKEN\t\t\t0x08  \n#define CLK_SLOWCLKOUT\t\t\t0x40  \n\n \n#define LM8323_I2C_ADDR00\t\t(0x84 >> 1)\t \n#define LM8323_I2C_ADDR01\t\t(0x86 >> 1)\t \n#define LM8323_I2C_ADDR10\t\t(0x88 >> 1)\t \n#define LM8323_I2C_ADDR11\t\t(0x8A >> 1)\t \n\n \n#define LM8323_FIFO_LEN\t\t\t15\n\n \n \n#define PWM_SET(v)\t\t\t(0x4000 | ((v) & 0xff))\n \n#define PWM_GOTOSTART\t\t\t0x0000\n \n#define PWM_END(reset)\t\t\t(0xc000 | (!!(reset) << 11))\n \n#define PWM_RAMP(s, t, n, u)\t\t((!!(s) << 14) | ((t) & 0x3f) << 8 | \\\n\t\t\t\t\t ((n) & 0x7f) | ((u) ? 0 : 0x80))\n \n#define PWM_LOOP(cnt, pos)\t\t(0xa000 | (((cnt) & 0x3f) << 7) | \\\n\t\t\t\t\t ((pos) & 0x3f))\n \n#define PWM_WAIT_TRIG(chans)\t\t(0xe000 | (((chans) & 0x7) << 6))\n \n#define PWM_SEND_TRIG(chans)\t\t(0xe000 | ((chans) & 0x7))\n\nstruct lm8323_pwm {\n\tint\t\t\tid;\n\tint\t\t\tfade_time;\n\tint\t\t\tbrightness;\n\tint\t\t\tdesired_brightness;\n\tbool\t\t\tenabled;\n\tbool\t\t\trunning;\n\t \n\tstruct mutex\t\tlock;\n\tstruct work_struct\twork;\n\tstruct led_classdev\tcdev;\n\tstruct lm8323_chip\t*chip;\n};\n\nstruct lm8323_chip {\n\t \n\tstruct mutex\t\tlock;\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*idev;\n\tbool\t\t\tkp_enabled;\n\tbool\t\t\tpm_suspend;\n\tunsigned\t\tkeys_down;\n\tchar\t\t\tphys[32];\n\tunsigned short\t\tkeymap[LM8323_KEYMAP_SIZE];\n\tint\t\t\tsize_x;\n\tint\t\t\tsize_y;\n\tint\t\t\tdebounce_time;\n\tint\t\t\tactive_time;\n\tstruct lm8323_pwm\tpwm[LM8323_NUM_PWMS];\n};\n\n#define client_to_lm8323(c)\tcontainer_of(c, struct lm8323_chip, client)\n#define dev_to_lm8323(d)\tcontainer_of(d, struct lm8323_chip, client->dev)\n#define cdev_to_pwm(c)\t\tcontainer_of(c, struct lm8323_pwm, cdev)\n#define work_to_pwm(w)\t\tcontainer_of(w, struct lm8323_pwm, work)\n\n#define LM8323_MAX_DATA 8\n\n \nstatic int lm8323_write(struct lm8323_chip *lm, int len, ...)\n{\n\tint ret, i;\n\tva_list ap;\n\tu8 data[LM8323_MAX_DATA];\n\n\tva_start(ap, len);\n\n\tif (unlikely(len > LM8323_MAX_DATA)) {\n\t\tdev_err(&lm->client->dev, \"tried to send %d bytes\\n\", len);\n\t\tva_end(ap);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < len; i++)\n\t\tdata[i] = va_arg(ap, int);\n\n\tva_end(ap);\n\n\t \n\tret = i2c_master_send(lm->client, data, len);\n\tif (unlikely(ret == -EREMOTEIO))\n\t\tret = i2c_master_send(lm->client, data, len);\n\tif (unlikely(ret != len))\n\t\tdev_err(&lm->client->dev, \"sent %d bytes of %d total\\n\",\n\t\t\tlen, ret);\n\n\treturn ret;\n}\n\n \nstatic int lm8323_read(struct lm8323_chip *lm, u8 cmd, u8 *buf, int len)\n{\n\tint ret;\n\n\t \n\tret = i2c_master_send(lm->client, &cmd, 1);\n\tif (unlikely(ret == -EREMOTEIO))\n\t\tret = i2c_master_send(lm->client, &cmd, 1);\n\tif (unlikely(ret != 1)) {\n\t\tdev_err(&lm->client->dev, \"sending read cmd 0x%02x failed\\n\",\n\t\t\tcmd);\n\t\treturn 0;\n\t}\n\n\tret = i2c_master_recv(lm->client, buf, len);\n\tif (unlikely(ret != len))\n\t\tdev_err(&lm->client->dev, \"wanted %d bytes, got %d\\n\",\n\t\t\tlen, ret);\n\n\treturn ret;\n}\n\n \nstatic void lm8323_set_active_time(struct lm8323_chip *lm, int time)\n{\n\tlm8323_write(lm, 2, LM8323_CMD_SET_ACTIVE, time >> 2);\n}\n\n \nstatic inline u8 lm8323_whichkey(u8 event)\n{\n\treturn event & 0x7f;\n}\n\nstatic inline int lm8323_ispress(u8 event)\n{\n\treturn (event & 0x80) ? 1 : 0;\n}\n\nstatic void process_keys(struct lm8323_chip *lm)\n{\n\tu8 event;\n\tu8 key_fifo[LM8323_FIFO_LEN + 1];\n\tint old_keys_down = lm->keys_down;\n\tint ret;\n\tint i = 0;\n\n\t \n\tret = lm8323_read(lm, LM8323_CMD_READ_FIFO, key_fifo, LM8323_FIFO_LEN);\n\n\tif (ret < 0) {\n\t\tdev_err(&lm->client->dev, \"Failed reading fifo \\n\");\n\t\treturn;\n\t}\n\tkey_fifo[ret] = 0;\n\n\twhile ((event = key_fifo[i++])) {\n\t\tu8 key = lm8323_whichkey(event);\n\t\tint isdown = lm8323_ispress(event);\n\t\tunsigned short keycode = lm->keymap[key];\n\n\t\tdev_vdbg(&lm->client->dev, \"key 0x%02x %s\\n\",\n\t\t\t key, isdown ? \"down\" : \"up\");\n\n\t\tif (lm->kp_enabled) {\n\t\t\tinput_event(lm->idev, EV_MSC, MSC_SCAN, key);\n\t\t\tinput_report_key(lm->idev, keycode, isdown);\n\t\t\tinput_sync(lm->idev);\n\t\t}\n\n\t\tif (isdown)\n\t\t\tlm->keys_down++;\n\t\telse\n\t\t\tlm->keys_down--;\n\t}\n\n\t \n\tif (!old_keys_down && lm->keys_down)\n\t\tlm8323_set_active_time(lm, 0);\n\tif (old_keys_down && !lm->keys_down)\n\t\tlm8323_set_active_time(lm, lm->active_time);\n}\n\nstatic void lm8323_process_error(struct lm8323_chip *lm)\n{\n\tu8 error;\n\n\tif (lm8323_read(lm, LM8323_CMD_READ_ERR, &error, 1) == 1) {\n\t\tif (error & ERR_FIFOOVER)\n\t\t\tdev_vdbg(&lm->client->dev, \"fifo overflow!\\n\");\n\t\tif (error & ERR_KEYOVR)\n\t\t\tdev_vdbg(&lm->client->dev,\n\t\t\t\t\t\"more than two keys pressed\\n\");\n\t\tif (error & ERR_CMDUNK)\n\t\t\tdev_vdbg(&lm->client->dev,\n\t\t\t\t\t\"unknown command submitted\\n\");\n\t\tif (error & ERR_BADPAR)\n\t\t\tdev_vdbg(&lm->client->dev, \"bad command parameter\\n\");\n\t}\n}\n\nstatic void lm8323_reset(struct lm8323_chip *lm)\n{\n\t \n\tlm8323_write(lm, 2, LM8323_CMD_RESET, 0xAA);\n}\n\nstatic int lm8323_configure(struct lm8323_chip *lm)\n{\n\tint keysize = (lm->size_x << 4) | lm->size_y;\n\tint clock = (CLK_SLOWCLKEN | CLK_RCPWM_EXTERNAL);\n\tint debounce = lm->debounce_time >> 2;\n\tint active = lm->active_time >> 2;\n\n\t \n\tif (debounce >= active)\n\t\tactive = debounce + 3;\n\n\tlm8323_write(lm, 2, LM8323_CMD_WRITE_CFG, 0);\n\tlm8323_write(lm, 2, LM8323_CMD_WRITE_CLOCK, clock);\n\tlm8323_write(lm, 2, LM8323_CMD_SET_KEY_SIZE, keysize);\n\tlm8323_set_active_time(lm, lm->active_time);\n\tlm8323_write(lm, 2, LM8323_CMD_SET_DEBOUNCE, debounce);\n\tlm8323_write(lm, 3, LM8323_CMD_WRITE_PORT_STATE, 0xff, 0xff);\n\tlm8323_write(lm, 3, LM8323_CMD_WRITE_PORT_SEL, 0, 0);\n\n\t \n\n\treturn 0;\n}\n\nstatic void pwm_done(struct lm8323_pwm *pwm)\n{\n\tmutex_lock(&pwm->lock);\n\tpwm->running = false;\n\tif (pwm->desired_brightness != pwm->brightness)\n\t\tschedule_work(&pwm->work);\n\tmutex_unlock(&pwm->lock);\n}\n\n \nstatic irqreturn_t lm8323_irq(int irq, void *_lm)\n{\n\tstruct lm8323_chip *lm = _lm;\n\tu8 ints;\n\tint i;\n\n\tmutex_lock(&lm->lock);\n\n\twhile ((lm8323_read(lm, LM8323_CMD_READ_INT, &ints, 1) == 1) && ints) {\n\t\tif (likely(ints & INT_KEYPAD))\n\t\t\tprocess_keys(lm);\n\t\tif (ints & INT_ROTATOR) {\n\t\t\t \n\t\t\tdev_vdbg(&lm->client->dev, \"rotator fired\\n\");\n\t\t}\n\t\tif (ints & INT_ERROR) {\n\t\t\tdev_vdbg(&lm->client->dev, \"error!\\n\");\n\t\t\tlm8323_process_error(lm);\n\t\t}\n\t\tif (ints & INT_NOINIT) {\n\t\t\tdev_err(&lm->client->dev, \"chip lost config; \"\n\t\t\t\t\t\t  \"reinitialising\\n\");\n\t\t\tlm8323_configure(lm);\n\t\t}\n\t\tfor (i = 0; i < LM8323_NUM_PWMS; i++) {\n\t\t\tif (ints & (INT_PWM1 << i)) {\n\t\t\t\tdev_vdbg(&lm->client->dev,\n\t\t\t\t\t \"pwm%d engine completed\\n\", i);\n\t\t\t\tpwm_done(&lm->pwm[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&lm->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int lm8323_read_id(struct lm8323_chip *lm, u8 *buf)\n{\n\tint bytes;\n\n\tbytes = lm8323_read(lm, LM8323_CMD_READ_ID, buf, 2);\n\tif (unlikely(bytes != 2))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void lm8323_write_pwm_one(struct lm8323_pwm *pwm, int pos, u16 cmd)\n{\n\tlm8323_write(pwm->chip, 4, LM8323_CMD_PWM_WRITE, (pos << 2) | pwm->id,\n\t\t     (cmd & 0xff00) >> 8, cmd & 0x00ff);\n}\n\n \nstatic void lm8323_write_pwm(struct lm8323_pwm *pwm, int kill,\n\t\t\t     int len, const u16 *cmds)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tlm8323_write_pwm_one(pwm, i, cmds[i]);\n\n\tlm8323_write_pwm_one(pwm, i++, PWM_END(kill));\n\tlm8323_write(pwm->chip, 2, LM8323_CMD_START_PWM, pwm->id);\n\tpwm->running = true;\n}\n\nstatic void lm8323_pwm_work(struct work_struct *work)\n{\n\tstruct lm8323_pwm *pwm = work_to_pwm(work);\n\tint div512, perstep, steps, hz, up, kill;\n\tu16 pwm_cmds[3];\n\tint num_cmds = 0;\n\n\tmutex_lock(&pwm->lock);\n\n\t \n\tif (pwm->running || pwm->desired_brightness == pwm->brightness)\n\t\tgoto out;\n\n\tkill = (pwm->desired_brightness == 0);\n\tup = (pwm->desired_brightness > pwm->brightness);\n\tsteps = abs(pwm->desired_brightness - pwm->brightness);\n\n\t \n\tif ((pwm->fade_time / steps) > (32768 / 512)) {\n\t\tdiv512 = 1;\n\t\thz = 32768 / 512;\n\t} else {\n\t\tdiv512 = 0;\n\t\thz = 32768 / 16;\n\t}\n\n\tperstep = (hz * pwm->fade_time) / (steps * 1000);\n\n\tif (perstep == 0)\n\t\tperstep = 1;\n\telse if (perstep > 63)\n\t\tperstep = 63;\n\n\twhile (steps) {\n\t\tint s;\n\n\t\ts = min(126, steps);\n\t\tpwm_cmds[num_cmds++] = PWM_RAMP(div512, perstep, s, up);\n\t\tsteps -= s;\n\t}\n\n\tlm8323_write_pwm(pwm, kill, num_cmds, pwm_cmds);\n\tpwm->brightness = pwm->desired_brightness;\n\n out:\n\tmutex_unlock(&pwm->lock);\n}\n\nstatic void lm8323_pwm_set_brightness(struct led_classdev *led_cdev,\n\t\t\t\t      enum led_brightness brightness)\n{\n\tstruct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);\n\tstruct lm8323_chip *lm = pwm->chip;\n\n\tmutex_lock(&pwm->lock);\n\tpwm->desired_brightness = brightness;\n\tmutex_unlock(&pwm->lock);\n\n\tif (in_interrupt()) {\n\t\tschedule_work(&pwm->work);\n\t} else {\n\t\t \n\t\tmutex_lock(&lm->lock);\n\t\tif (likely(!lm->pm_suspend))\n\t\t\tschedule_work(&pwm->work);\n\t\telse\n\t\t\tlm8323_pwm_work(&pwm->work);\n\t\tmutex_unlock(&lm->lock);\n\t}\n}\n\nstatic ssize_t lm8323_pwm_show_time(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);\n\n\treturn sprintf(buf, \"%d\\n\", pwm->fade_time);\n}\n\nstatic ssize_t lm8323_pwm_store_time(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);\n\tint ret, time;\n\n\tret = kstrtoint(buf, 10, &time);\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tpwm->fade_time = time;\n\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR(time, 0644, lm8323_pwm_show_time, lm8323_pwm_store_time);\n\nstatic struct attribute *lm8323_pwm_attrs[] = {\n\t&dev_attr_time.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lm8323_pwm);\n\nstatic int init_pwm(struct lm8323_chip *lm, int id, struct device *dev,\n\t\t    const char *name)\n{\n\tstruct lm8323_pwm *pwm;\n\tint err;\n\n\tBUG_ON(id > 3);\n\n\tpwm = &lm->pwm[id - 1];\n\n\tpwm->id = id;\n\tpwm->fade_time = 0;\n\tpwm->brightness = 0;\n\tpwm->desired_brightness = 0;\n\tpwm->running = false;\n\tpwm->enabled = false;\n\tINIT_WORK(&pwm->work, lm8323_pwm_work);\n\tmutex_init(&pwm->lock);\n\tpwm->chip = lm;\n\n\tif (name) {\n\t\tpwm->cdev.name = name;\n\t\tpwm->cdev.brightness_set = lm8323_pwm_set_brightness;\n\t\tpwm->cdev.groups = lm8323_pwm_groups;\n\n\t\terr = devm_led_classdev_register(dev, &pwm->cdev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"couldn't register PWM %d: %d\\n\", id, err);\n\t\t\treturn err;\n\t\t}\n\t\tpwm->enabled = true;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t lm8323_show_disable(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct lm8323_chip *lm = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", !lm->kp_enabled);\n}\n\nstatic ssize_t lm8323_set_disable(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct lm8323_chip *lm = dev_get_drvdata(dev);\n\tint ret;\n\tunsigned int i;\n\n\tret = kstrtouint(buf, 10, &i);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&lm->lock);\n\tlm->kp_enabled = !i;\n\tmutex_unlock(&lm->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR(disable_kp, 0644, lm8323_show_disable, lm8323_set_disable);\n\nstatic struct attribute *lm8323_attrs[] = {\n\t&dev_attr_disable_kp.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(lm8323);\n\nstatic int lm8323_probe(struct i2c_client *client)\n{\n\tstruct lm8323_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct input_dev *idev;\n\tstruct lm8323_chip *lm;\n\tint pwm;\n\tint i, err;\n\tunsigned long tmo;\n\tu8 data[2];\n\n\tif (!pdata || !pdata->size_x || !pdata->size_y) {\n\t\tdev_err(&client->dev, \"missing platform_data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->size_x > 8) {\n\t\tdev_err(&client->dev, \"invalid x size %d specified\\n\",\n\t\t\tpdata->size_x);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->size_y > 12) {\n\t\tdev_err(&client->dev, \"invalid y size %d specified\\n\",\n\t\t\tpdata->size_y);\n\t\treturn -EINVAL;\n\t}\n\n\tlm = devm_kzalloc(&client->dev, sizeof(*lm), GFP_KERNEL);\n\tif (!lm)\n\t\treturn -ENOMEM;\n\n\tidev = devm_input_allocate_device(&client->dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tlm->client = client;\n\tlm->idev = idev;\n\tmutex_init(&lm->lock);\n\n\tlm->size_x = pdata->size_x;\n\tlm->size_y = pdata->size_y;\n\tdev_vdbg(&client->dev, \"Keypad size: %d x %d\\n\",\n\t\t lm->size_x, lm->size_y);\n\n\tlm->debounce_time = pdata->debounce_time;\n\tlm->active_time = pdata->active_time;\n\n\tlm8323_reset(lm);\n\n\t \n\ttmo = jiffies + msecs_to_jiffies(100);\n\twhile (lm8323_read(lm, LM8323_CMD_READ_INT, data, 1) == 1) {\n\t\tif (data[0] & INT_NOINIT)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, tmo)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"timeout waiting for initialisation\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(1);\n\t}\n\n\tlm8323_configure(lm);\n\n\t \n\tif (lm8323_read_id(lm, data) != 0) {\n\t\tdev_err(&client->dev, \"device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (pwm = 0; pwm < LM8323_NUM_PWMS; pwm++) {\n\t\terr = init_pwm(lm, pwm + 1, &client->dev,\n\t\t\t       pdata->pwm_names[pwm]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tlm->kp_enabled = true;\n\n\tidev->name = pdata->name ? : \"LM8323 keypad\";\n\tsnprintf(lm->phys, sizeof(lm->phys),\n\t\t \"%s/input-kp\", dev_name(&client->dev));\n\tidev->phys = lm->phys;\n\n\tidev->evbit[0] = BIT(EV_KEY) | BIT(EV_MSC);\n\t__set_bit(MSC_SCAN, idev->mscbit);\n\tfor (i = 0; i < LM8323_KEYMAP_SIZE; i++) {\n\t\t__set_bit(pdata->keymap[i], idev->keybit);\n\t\tlm->keymap[i] = pdata->keymap[i];\n\t}\n\t__clear_bit(KEY_RESERVED, idev->keybit);\n\n\tif (pdata->repeat)\n\t\t__set_bit(EV_REP, idev->evbit);\n\n\terr = input_register_device(idev);\n\tif (err) {\n\t\tdev_dbg(&client->dev, \"error registering input device\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, lm8323_irq,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\"lm8323\", lm);\n\tif (err) {\n\t\tdev_err(&client->dev, \"could not get IRQ %d\\n\", client->irq);\n\t\treturn err;\n\t}\n\n\ti2c_set_clientdata(client, lm);\n\n\tdevice_init_wakeup(&client->dev, 1);\n\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\n \nstatic int lm8323_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct lm8323_chip *lm = i2c_get_clientdata(client);\n\tint i;\n\n\tirq_set_irq_wake(client->irq, 0);\n\tdisable_irq(client->irq);\n\n\tmutex_lock(&lm->lock);\n\tlm->pm_suspend = true;\n\tmutex_unlock(&lm->lock);\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (lm->pwm[i].enabled)\n\t\t\tled_classdev_suspend(&lm->pwm[i].cdev);\n\n\treturn 0;\n}\n\nstatic int lm8323_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct lm8323_chip *lm = i2c_get_clientdata(client);\n\tint i;\n\n\tmutex_lock(&lm->lock);\n\tlm->pm_suspend = false;\n\tmutex_unlock(&lm->lock);\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (lm->pwm[i].enabled)\n\t\t\tled_classdev_resume(&lm->pwm[i].cdev);\n\n\tenable_irq(client->irq);\n\tirq_set_irq_wake(client->irq, 1);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(lm8323_pm_ops, lm8323_suspend, lm8323_resume);\n\nstatic const struct i2c_device_id lm8323_id[] = {\n\t{ \"lm8323\", 0 },\n\t{ }\n};\n\nstatic struct i2c_driver lm8323_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"lm8323\",\n\t\t.pm\t\t= pm_sleep_ptr(&lm8323_pm_ops),\n\t\t.dev_groups\t= lm8323_groups,\n\t},\n\t.probe\t\t= lm8323_probe,\n\t.id_table\t= lm8323_id,\n};\nMODULE_DEVICE_TABLE(i2c, lm8323_id);\n\nmodule_i2c_driver(lm8323_i2c_driver);\n\nMODULE_AUTHOR(\"Timo O. Karjalainen <timo.o.karjalainen@nokia.com>\");\nMODULE_AUTHOR(\"Daniel Stone\");\nMODULE_AUTHOR(\"Felipe Balbi <felipe.balbi@nokia.com>\");\nMODULE_DESCRIPTION(\"LM8323 keypad driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}