{
  "module_name": "bcm-keypad.c",
  "hash_id": "569225bcbf5881c2de3e6c8b34927023dff60c45d26f116634e705a81ba29cbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/bcm-keypad.c",
  "human_readable_source": "\n\n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define DEFAULT_CLK_HZ\t\t\t31250\n#define MAX_ROWS\t\t\t8\n#define MAX_COLS\t\t\t8\n\n \n#define KPCR_OFFSET\t\t\t0x00000080\n#define KPCR_MODE\t\t\t0x00000002\n#define KPCR_MODE_SHIFT\t\t\t1\n#define KPCR_MODE_MASK\t\t\t1\n#define KPCR_ENABLE\t\t\t0x00000001\n#define KPCR_STATUSFILTERENABLE\t\t0x00008000\n#define KPCR_STATUSFILTERTYPE_SHIFT\t12\n#define KPCR_COLFILTERENABLE\t\t0x00000800\n#define KPCR_COLFILTERTYPE_SHIFT\t8\n#define KPCR_ROWWIDTH_SHIFT\t\t20\n#define KPCR_COLUMNWIDTH_SHIFT\t\t16\n\n#define KPIOR_OFFSET\t\t\t0x00000084\n#define KPIOR_ROWOCONTRL_SHIFT\t\t24\n#define KPIOR_ROWOCONTRL_MASK\t\t0xFF000000\n#define KPIOR_COLUMNOCONTRL_SHIFT\t16\n#define KPIOR_COLUMNOCONTRL_MASK\t0x00FF0000\n#define KPIOR_COLUMN_IO_DATA_SHIFT\t0\n\n#define KPEMR0_OFFSET\t\t\t0x00000090\n#define KPEMR1_OFFSET\t\t\t0x00000094\n#define KPEMR2_OFFSET\t\t\t0x00000098\n#define KPEMR3_OFFSET\t\t\t0x0000009C\n#define KPEMR_EDGETYPE_BOTH\t\t3\n\n#define KPSSR0_OFFSET\t\t\t0x000000A0\n#define KPSSR1_OFFSET\t\t\t0x000000A4\n#define KPSSRN_OFFSET(reg_n)\t\t(KPSSR0_OFFSET + 4 * (reg_n))\n#define KPIMR0_OFFSET\t\t\t0x000000B0\n#define KPIMR1_OFFSET\t\t\t0x000000B4\n#define KPICR0_OFFSET\t\t\t0x000000B8\n#define KPICR1_OFFSET\t\t\t0x000000BC\n#define KPICRN_OFFSET(reg_n)\t\t(KPICR0_OFFSET + 4 * (reg_n))\n#define KPISR0_OFFSET\t\t\t0x000000C0\n#define KPISR1_OFFSET\t\t\t0x000000C4\n\n#define KPCR_STATUSFILTERTYPE_MAX\t7\n#define KPCR_COLFILTERTYPE_MAX\t\t7\n\n \n#define BIT_TO_ROW_SSRN(bit_nr, reg_n)\t(((bit_nr) >> 3) + 4 * (reg_n))\n#define BIT_TO_COL(bit_nr)\t\t((bit_nr) % 8)\n\n \nstruct bcm_kp {\n\tvoid __iomem *base;\n\tint irq;\n\tstruct clk *clk;\n\tstruct input_dev *input_dev;\n\tunsigned long last_state[2];\n\tunsigned int n_rows;\n\tunsigned int n_cols;\n\tu32 kpcr;\n\tu32 kpior;\n\tu32 kpemr;\n\tu32 imr0_val;\n\tu32 imr1_val;\n};\n\n \nstatic int bcm_kp_get_keycode(struct bcm_kp *kp, int row, int col)\n{\n\tunsigned int row_shift = get_count_order(kp->n_cols);\n\tunsigned short *keymap = kp->input_dev->keycode;\n\n\treturn keymap[MATRIX_SCAN_CODE(row, col, row_shift)];\n}\n\nstatic void bcm_kp_report_keys(struct bcm_kp *kp, int reg_num, int pull_mode)\n{\n\tunsigned long state, change;\n\tint bit_nr;\n\tint key_press;\n\tint row, col;\n\tunsigned int keycode;\n\n\t \n\twritel(0xFFFFFFFF, kp->base + KPICRN_OFFSET(reg_num));\n\n\tstate = readl(kp->base + KPSSRN_OFFSET(reg_num));\n\tchange = kp->last_state[reg_num] ^ state;\n\tkp->last_state[reg_num] = state;\n\n\tfor_each_set_bit(bit_nr, &change, BITS_PER_LONG) {\n\t\tkey_press = state & BIT(bit_nr);\n\t\t \n\t\tkey_press = pull_mode ? !key_press : key_press;\n\t\trow = BIT_TO_ROW_SSRN(bit_nr, reg_num);\n\t\tcol = BIT_TO_COL(bit_nr);\n\t\tkeycode = bcm_kp_get_keycode(kp, row, col);\n\t\tinput_report_key(kp->input_dev, keycode, key_press);\n\t}\n}\n\nstatic irqreturn_t bcm_kp_isr_thread(int irq, void *dev_id)\n{\n\tstruct bcm_kp *kp = dev_id;\n\tint pull_mode = (kp->kpcr >> KPCR_MODE_SHIFT) & KPCR_MODE_MASK;\n\tint reg_num;\n\n\tfor (reg_num = 0; reg_num <= 1; reg_num++)\n\t\tbcm_kp_report_keys(kp, reg_num, pull_mode);\n\n\tinput_sync(kp->input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm_kp_start(struct bcm_kp *kp)\n{\n\tint error;\n\n\tif (kp->clk) {\n\t\terror = clk_prepare_enable(kp->clk);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\twritel(kp->kpior, kp->base + KPIOR_OFFSET);\n\n\twritel(kp->imr0_val, kp->base + KPIMR0_OFFSET);\n\twritel(kp->imr1_val, kp->base + KPIMR1_OFFSET);\n\n\twritel(kp->kpemr, kp->base + KPEMR0_OFFSET);\n\twritel(kp->kpemr, kp->base + KPEMR1_OFFSET);\n\twritel(kp->kpemr, kp->base + KPEMR2_OFFSET);\n\twritel(kp->kpemr, kp->base + KPEMR3_OFFSET);\n\n\twritel(0xFFFFFFFF, kp->base + KPICR0_OFFSET);\n\twritel(0xFFFFFFFF, kp->base + KPICR1_OFFSET);\n\n\tkp->last_state[0] = readl(kp->base + KPSSR0_OFFSET);\n\tkp->last_state[0] = readl(kp->base + KPSSR1_OFFSET);\n\n\twritel(kp->kpcr | KPCR_ENABLE, kp->base + KPCR_OFFSET);\n\n\treturn 0;\n}\n\nstatic void bcm_kp_stop(const struct bcm_kp *kp)\n{\n\tu32 val;\n\n\tval = readl(kp->base + KPCR_OFFSET);\n\tval &= ~KPCR_ENABLE;\n\twritel(0, kp->base + KPCR_OFFSET);\n\twritel(0, kp->base + KPIMR0_OFFSET);\n\twritel(0, kp->base + KPIMR1_OFFSET);\n\twritel(0xFFFFFFFF, kp->base + KPICR0_OFFSET);\n\twritel(0xFFFFFFFF, kp->base + KPICR1_OFFSET);\n\n\tclk_disable_unprepare(kp->clk);\n}\n\nstatic int bcm_kp_open(struct input_dev *dev)\n{\n\tstruct bcm_kp *kp = input_get_drvdata(dev);\n\n\treturn bcm_kp_start(kp);\n}\n\nstatic void bcm_kp_close(struct input_dev *dev)\n{\n\tstruct bcm_kp *kp = input_get_drvdata(dev);\n\n\tbcm_kp_stop(kp);\n}\n\nstatic int bcm_kp_matrix_key_parse_dt(struct bcm_kp *kp)\n{\n\tstruct device *dev = kp->input_dev->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tint error;\n\tunsigned int dt_val;\n\tunsigned int i;\n\tunsigned int num_rows, col_mask, rows_set;\n\n\t \n\tkp->kpcr = KPCR_STATUSFILTERENABLE | KPCR_COLFILTERENABLE;\n\n\terror = matrix_keypad_parse_properties(dev, &kp->n_rows, &kp->n_cols);\n\tif (error) {\n\t\tdev_err(dev, \"failed to parse kp params\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tkp->kpcr |= (kp->n_rows - 1) << KPCR_ROWWIDTH_SHIFT;\n\n\t \n\tkp->kpcr |= (kp->n_cols - 1) << KPCR_COLUMNWIDTH_SHIFT;\n\n\t \n\n\t \n\tcol_mask = (1 << (kp->n_cols)) - 1;\n\tnum_rows = kp->n_rows;\n\n\t \n\tkp->imr0_val = col_mask;\n\n\trows_set = 1;\n\twhile (--num_rows && rows_set++ < 4)\n\t\tkp->imr0_val |= kp->imr0_val << MAX_COLS;\n\n\t \n\tkp->imr1_val = 0;\n\tif (num_rows) {\n\t\tkp->imr1_val = col_mask;\n\t\twhile (--num_rows)\n\t\t\tkp->imr1_val |= kp->imr1_val << MAX_COLS;\n\t}\n\n\t \n\t \n\tkp->kpemr = 0;\n\tfor (i = 0; i <= 30; i += 2)\n\t\tkp->kpemr |= (KPEMR_EDGETYPE_BOTH << i);\n\n\t \n\tof_property_read_u32(np, \"status-debounce-filter-period\", &dt_val);\n\n\tif (dt_val > KPCR_STATUSFILTERTYPE_MAX) {\n\t\tdev_err(dev, \"Invalid Status filter debounce value %d\\n\",\n\t\t\tdt_val);\n\t\treturn -EINVAL;\n\t}\n\n\tkp->kpcr |= dt_val << KPCR_STATUSFILTERTYPE_SHIFT;\n\n\t \n\tof_property_read_u32(np, \"col-debounce-filter-period\", &dt_val);\n\n\tif (dt_val > KPCR_COLFILTERTYPE_MAX) {\n\t\tdev_err(dev, \"Invalid Column filter debounce value %d\\n\",\n\t\t\tdt_val);\n\t\treturn -EINVAL;\n\t}\n\n\tkp->kpcr |= dt_val << KPCR_COLFILTERTYPE_SHIFT;\n\n\t \n\tif (of_property_read_bool(np, \"row-output-enabled\")) {\n\t\t \n\t\tkp->kpior = ((1 << kp->n_rows) - 1) <<\n\t\t\t\tKPIOR_ROWOCONTRL_SHIFT;\n\t} else {\n\t\tkp->kpior = ((1 << kp->n_cols) - 1) <<\n\t\t\t\tKPIOR_COLUMNOCONTRL_SHIFT;\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"pull-up-enabled\"))\n\t\tkp->kpcr |= KPCR_MODE;\n\n\tdev_dbg(dev, \"n_rows=%d n_col=%d kpcr=%x kpior=%x kpemr=%x\\n\",\n\t\tkp->n_rows, kp->n_cols,\n\t\tkp->kpcr, kp->kpior, kp->kpemr);\n\n\treturn 0;\n}\n\n\nstatic int bcm_kp_probe(struct platform_device *pdev)\n{\n\tstruct bcm_kp *kp;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\n\tif (!kp)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate the input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\n\t \n\tif (of_property_read_bool(pdev->dev.of_node, \"autorepeat\"))\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\n\tinput_dev->name = pdev->name;\n\tinput_dev->phys = \"keypad/input0\";\n\tinput_dev->dev.parent = &pdev->dev;\n\tinput_dev->open = bcm_kp_open;\n\tinput_dev->close = bcm_kp_close;\n\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\n\tinput_set_drvdata(input_dev, kp);\n\n\tkp->input_dev = input_dev;\n\n\terror = bcm_kp_matrix_key_parse_dt(kp);\n\tif (error)\n\t\treturn error;\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   kp->n_rows, kp->n_cols,\n\t\t\t\t\t   NULL, input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tkp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(kp->base))\n\t\treturn PTR_ERR(kp->base);\n\n\t \n\tkp->clk = devm_clk_get_optional(&pdev->dev, \"peri_clk\");\n\tif (IS_ERR(kp->clk)) {\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(kp->clk), \"Failed to get clock\\n\");\n\t} else if (!kp->clk) {\n\t\tdev_dbg(&pdev->dev, \"No clock specified. Assuming it's enabled\\n\");\n\t} else {\n\t\tunsigned int desired_rate;\n\t\tlong actual_rate;\n\n\t\terror = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t     \"clock-frequency\", &desired_rate);\n\t\tif (error < 0)\n\t\t\tdesired_rate = DEFAULT_CLK_HZ;\n\n\t\tactual_rate = clk_round_rate(kp->clk, desired_rate);\n\t\tif (actual_rate <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terror = clk_set_rate(kp->clk, actual_rate);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = clk_prepare_enable(kp->clk);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tbcm_kp_stop(kp);\n\n\tkp->irq = platform_get_irq(pdev, 0);\n\tif (kp->irq < 0)\n\t\treturn -EINVAL;\n\n\terror = devm_request_threaded_irq(&pdev->dev, kp->irq,\n\t\t\t\t\t  NULL, bcm_kp_isr_thread,\n\t\t\t\t\t  IRQF_ONESHOT, pdev->name, kp);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm_kp_of_match[] = {\n\t{ .compatible = \"brcm,bcm-keypad\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm_kp_of_match);\n\nstatic struct platform_driver bcm_kp_device_driver = {\n\t.probe\t\t= bcm_kp_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"bcm-keypad\",\n\t\t.of_match_table = of_match_ptr(bcm_kp_of_match),\n\t}\n};\n\nmodule_platform_driver(bcm_kp_device_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"BCM Keypad Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}