{
  "module_name": "lkkbd.c",
  "hash_id": "e1ba49001b90274aada0f9d5782051bee7c7b0f7a01ea9770caabfb0cd5a0f5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/lkkbd.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/workqueue.h>\n\n#define DRIVER_DESC\t\"LK keyboard driver\"\n\nMODULE_AUTHOR(\"Jan-Benedict Glaw <jbglaw@lug-owl.de>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int bell_volume = 100;  \nmodule_param(bell_volume, int, 0);\nMODULE_PARM_DESC(bell_volume, \"Bell volume (in %). default is 100%\");\n\nstatic int keyclick_volume = 100;  \nmodule_param(keyclick_volume, int, 0);\nMODULE_PARM_DESC(keyclick_volume, \"Keyclick volume (in %), default is 100%\");\n\nstatic int ctrlclick_volume = 100;  \nmodule_param(ctrlclick_volume, int, 0);\nMODULE_PARM_DESC(ctrlclick_volume, \"Ctrlclick volume (in %), default is 100%\");\n\nstatic int lk201_compose_is_alt;\nmodule_param(lk201_compose_is_alt, int, 0);\nMODULE_PARM_DESC(lk201_compose_is_alt,\n\t\t \"If set non-zero, LK201' Compose key will act as an Alt key\");\n\n\n\n#undef LKKBD_DEBUG\n#ifdef LKKBD_DEBUG\n#define DBG(x...) printk(x)\n#else\n#define DBG(x...) do {} while (0)\n#endif\n\n \n#define LK_LED_WAIT\t\t0x81\n#define LK_LED_COMPOSE\t\t0x82\n#define LK_LED_SHIFTLOCK\t0x84\n#define LK_LED_SCROLLLOCK\t0x88\n#define LK_CMD_LED_ON\t\t0x13\n#define LK_CMD_LED_OFF\t\t0x11\n\n \n#define LK_MODE_DOWN\t\t0x80\n#define LK_MODE_AUTODOWN\t0x82\n#define LK_MODE_UPDOWN\t\t0x86\n#define LK_CMD_SET_MODE(mode, div)\t((mode) | ((div) << 3))\n\n \n#define LK_CMD_ENABLE_KEYCLICK\t0x1b\n#define LK_CMD_DISABLE_KEYCLICK\t0x99\n#define LK_CMD_DISABLE_BELL\t0xa1\n#define LK_CMD_SOUND_BELL\t0xa7\n#define LK_CMD_ENABLE_BELL\t0x23\n#define LK_CMD_DISABLE_CTRCLICK\t0xb9\n#define LK_CMD_ENABLE_CTRCLICK\t0xbb\n#define LK_CMD_SET_DEFAULTS\t0xd3\n#define LK_CMD_POWERCYCLE_RESET\t0xfd\n#define LK_CMD_ENABLE_LK401\t0xe9\n#define LK_CMD_REQUEST_ID\t0xab\n\n \n#define LK_STUCK_KEY\t\t0x3d\n#define LK_SELFTEST_FAILED\t0x3e\n#define LK_ALL_KEYS_UP\t\t0xb3\n#define LK_METRONOME\t\t0xb4\n#define LK_OUTPUT_ERROR\t\t0xb5\n#define LK_INPUT_ERROR\t\t0xb6\n#define LK_KBD_LOCKED\t\t0xb7\n#define LK_KBD_TEST_MODE_ACK\t0xb8\n#define LK_PREFIX_KEY_DOWN\t0xb9\n#define LK_MODE_CHANGE_ACK\t0xba\n#define LK_RESPONSE_RESERVED\t0xbb\n\n#define LK_NUM_KEYCODES\t\t256\n#define LK_NUM_IGNORE_BYTES\t6\n\nstatic unsigned short lkkbd_keycode[LK_NUM_KEYCODES] = {\n\t[0x56] = KEY_F1,\n\t[0x57] = KEY_F2,\n\t[0x58] = KEY_F3,\n\t[0x59] = KEY_F4,\n\t[0x5a] = KEY_F5,\n\t[0x64] = KEY_F6,\n\t[0x65] = KEY_F7,\n\t[0x66] = KEY_F8,\n\t[0x67] = KEY_F9,\n\t[0x68] = KEY_F10,\n\t[0x71] = KEY_F11,\n\t[0x72] = KEY_F12,\n\t[0x73] = KEY_F13,\n\t[0x74] = KEY_F14,\n\t[0x7c] = KEY_F15,\n\t[0x7d] = KEY_F16,\n\t[0x80] = KEY_F17,\n\t[0x81] = KEY_F18,\n\t[0x82] = KEY_F19,\n\t[0x83] = KEY_F20,\n\t[0x8a] = KEY_FIND,\n\t[0x8b] = KEY_INSERT,\n\t[0x8c] = KEY_DELETE,\n\t[0x8d] = KEY_SELECT,\n\t[0x8e] = KEY_PAGEUP,\n\t[0x8f] = KEY_PAGEDOWN,\n\t[0x92] = KEY_KP0,\n\t[0x94] = KEY_KPDOT,\n\t[0x95] = KEY_KPENTER,\n\t[0x96] = KEY_KP1,\n\t[0x97] = KEY_KP2,\n\t[0x98] = KEY_KP3,\n\t[0x99] = KEY_KP4,\n\t[0x9a] = KEY_KP5,\n\t[0x9b] = KEY_KP6,\n\t[0x9c] = KEY_KPCOMMA,\n\t[0x9d] = KEY_KP7,\n\t[0x9e] = KEY_KP8,\n\t[0x9f] = KEY_KP9,\n\t[0xa0] = KEY_KPMINUS,\n\t[0xa1] = KEY_PROG1,\n\t[0xa2] = KEY_PROG2,\n\t[0xa3] = KEY_PROG3,\n\t[0xa4] = KEY_PROG4,\n\t[0xa7] = KEY_LEFT,\n\t[0xa8] = KEY_RIGHT,\n\t[0xa9] = KEY_DOWN,\n\t[0xaa] = KEY_UP,\n\t[0xab] = KEY_RIGHTSHIFT,\n\t[0xac] = KEY_LEFTALT,\n\t[0xad] = KEY_COMPOSE,  \n\t[0xae] = KEY_LEFTSHIFT,  \n\t[0xaf] = KEY_LEFTCTRL,\n\t[0xb0] = KEY_CAPSLOCK,\n\t[0xb1] = KEY_COMPOSE,  \n\t[0xb2] = KEY_RIGHTALT,\n\t[0xbc] = KEY_BACKSPACE,\n\t[0xbd] = KEY_ENTER,\n\t[0xbe] = KEY_TAB,\n\t[0xbf] = KEY_ESC,\n\t[0xc0] = KEY_1,\n\t[0xc1] = KEY_Q,\n\t[0xc2] = KEY_A,\n\t[0xc3] = KEY_Z,\n\t[0xc5] = KEY_2,\n\t[0xc6] = KEY_W,\n\t[0xc7] = KEY_S,\n\t[0xc8] = KEY_X,\n\t[0xc9] = KEY_102ND,\n\t[0xcb] = KEY_3,\n\t[0xcc] = KEY_E,\n\t[0xcd] = KEY_D,\n\t[0xce] = KEY_C,\n\t[0xd0] = KEY_4,\n\t[0xd1] = KEY_R,\n\t[0xd2] = KEY_F,\n\t[0xd3] = KEY_V,\n\t[0xd4] = KEY_SPACE,\n\t[0xd6] = KEY_5,\n\t[0xd7] = KEY_T,\n\t[0xd8] = KEY_G,\n\t[0xd9] = KEY_B,\n\t[0xdb] = KEY_6,\n\t[0xdc] = KEY_Y,\n\t[0xdd] = KEY_H,\n\t[0xde] = KEY_N,\n\t[0xe0] = KEY_7,\n\t[0xe1] = KEY_U,\n\t[0xe2] = KEY_J,\n\t[0xe3] = KEY_M,\n\t[0xe5] = KEY_8,\n\t[0xe6] = KEY_I,\n\t[0xe7] = KEY_K,\n\t[0xe8] = KEY_COMMA,\n\t[0xea] = KEY_9,\n\t[0xeb] = KEY_O,\n\t[0xec] = KEY_L,\n\t[0xed] = KEY_DOT,\n\t[0xef] = KEY_0,\n\t[0xf0] = KEY_P,\n\t[0xf2] = KEY_SEMICOLON,\n\t[0xf3] = KEY_SLASH,\n\t[0xf5] = KEY_EQUAL,\n\t[0xf6] = KEY_RIGHTBRACE,\n\t[0xf7] = KEY_BACKSLASH,\n\t[0xf9] = KEY_MINUS,\n\t[0xfa] = KEY_LEFTBRACE,\n\t[0xfb] = KEY_APOSTROPHE,\n};\n\n#define CHECK_LED(LK, VAR_ON, VAR_OFF, LED, BITS) do {\t\t\\\n\tif (test_bit(LED, (LK)->dev->led))\t\t\t\\\n\t\tVAR_ON |= BITS;\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tVAR_OFF |= BITS;\t\t\t\t\\\n\t} while (0)\n\n \nstruct lkkbd {\n\tunsigned short keycode[LK_NUM_KEYCODES];\n\tint ignore_bytes;\n\tunsigned char id[LK_NUM_IGNORE_BYTES];\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tstruct work_struct tq;\n\tchar name[64];\n\tchar phys[32];\n\tchar type;\n\tint bell_volume;\n\tint keyclick_volume;\n\tint ctrlclick_volume;\n};\n\n#ifdef LKKBD_DEBUG\n \nstatic struct {\n\tunsigned char value;\n\tunsigned char *name;\n} lk_response[] = {\n#define RESPONSE(x) { .value = (x), .name = #x, }\n\tRESPONSE(LK_STUCK_KEY),\n\tRESPONSE(LK_SELFTEST_FAILED),\n\tRESPONSE(LK_ALL_KEYS_UP),\n\tRESPONSE(LK_METRONOME),\n\tRESPONSE(LK_OUTPUT_ERROR),\n\tRESPONSE(LK_INPUT_ERROR),\n\tRESPONSE(LK_KBD_LOCKED),\n\tRESPONSE(LK_KBD_TEST_MODE_ACK),\n\tRESPONSE(LK_PREFIX_KEY_DOWN),\n\tRESPONSE(LK_MODE_CHANGE_ACK),\n\tRESPONSE(LK_RESPONSE_RESERVED),\n#undef RESPONSE\n};\n\nstatic unsigned char *response_name(unsigned char value)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lk_response); i++)\n\t\tif (lk_response[i].value == value)\n\t\t\treturn lk_response[i].name;\n\n\treturn \"<unknown>\";\n}\n#endif  \n\n \nstatic unsigned char volume_to_hw(int volume_percent)\n{\n\tunsigned char ret = 0;\n\n\tif (volume_percent < 0)\n\t\tvolume_percent = 0;\n\tif (volume_percent > 100)\n\t\tvolume_percent = 100;\n\n\tif (volume_percent >= 0)\n\t\tret = 7;\n\tif (volume_percent >= 13)\t \n\t\tret = 6;\n\tif (volume_percent >= 25)\n\t\tret = 5;\n\tif (volume_percent >= 38)\t \n\t\tret = 4;\n\tif (volume_percent >= 50)\n\t\tret = 3;\n\tif (volume_percent >= 63)\t \n\t\tret = 2;\t\t \n\tif (volume_percent >= 75)\n\t\tret = 1;\n\tif (volume_percent >= 88)\t \n\t\tret = 0;\n\n\tret |= 0x80;\n\n\treturn ret;\n}\n\nstatic void lkkbd_detection_done(struct lkkbd *lk)\n{\n\tint i;\n\n\t \n\tlk->keycode[0xb1] = KEY_COMPOSE;\n\n\t \n\tswitch (lk->id[4]) {\n\tcase 1:\n\t\tstrscpy(lk->name, \"DEC LK201 keyboard\", sizeof(lk->name));\n\n\t\tif (lk201_compose_is_alt)\n\t\t\tlk->keycode[0xb1] = KEY_LEFTALT;\n\t\tbreak;\n\n\tcase 2:\n\t\tstrscpy(lk->name, \"DEC LK401 keyboard\", sizeof(lk->name));\n\t\tbreak;\n\n\tdefault:\n\t\tstrscpy(lk->name, \"Unknown DEC keyboard\", sizeof(lk->name));\n\t\tprintk(KERN_ERR\n\t\t\t\"lkkbd: keyboard on %s is unknown, please report to \"\n\t\t\t\"Jan-Benedict Glaw <jbglaw@lug-owl.de>\\n\", lk->phys);\n\t\tprintk(KERN_ERR \"lkkbd: keyboard ID'ed as:\");\n\t\tfor (i = 0; i < LK_NUM_IGNORE_BYTES; i++)\n\t\t\tprintk(\" 0x%02x\", lk->id[i]);\n\t\tprintk(\"\\n\");\n\t\tbreak;\n\t}\n\n\tprintk(KERN_INFO \"lkkbd: keyboard on %s identified as: %s\\n\",\n\t\tlk->phys, lk->name);\n\n\t \n\tswitch (lk->id[2]) {\n\tcase 0x00:\n\t\t \n\t\tbreak;\n\n\tcase LK_STUCK_KEY:\n\t\tprintk(KERN_ERR \"lkkbd: Stuck key on keyboard at %s\\n\",\n\t\t\tlk->phys);\n\t\tbreak;\n\n\tcase LK_SELFTEST_FAILED:\n\t\tprintk(KERN_ERR\n\t\t\t\"lkkbd: Selftest failed on keyboard at %s, \"\n\t\t\t\"keyboard may not work properly\\n\", lk->phys);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR\n\t\t\t\"lkkbd: Unknown error %02x on keyboard at %s\\n\",\n\t\t\tlk->id[2], lk->phys);\n\t\tbreak;\n\t}\n\n\t \n\tif (lk->id[2] == LK_STUCK_KEY && lk->id[3] != 0)\n\t\tprintk(KERN_ERR\n\t\t\t\"Scancode of stuck key is 0x%02x, keycode is 0x%04x\\n\",\n\t\t\tlk->id[3], lk->keycode[lk->id[3]]);\n}\n\n \nstatic irqreturn_t lkkbd_interrupt(struct serio *serio,\n\t\t\t\t   unsigned char data, unsigned int flags)\n{\n\tstruct lkkbd *lk = serio_get_drvdata(serio);\n\tstruct input_dev *input_dev = lk->dev;\n\tunsigned int keycode;\n\tint i;\n\n\tDBG(KERN_INFO \"Got byte 0x%02x\\n\", data);\n\n\tif (lk->ignore_bytes > 0) {\n\t\tDBG(KERN_INFO \"Ignoring a byte on %s\\n\", lk->name);\n\t\tlk->id[LK_NUM_IGNORE_BYTES - lk->ignore_bytes--] = data;\n\n\t\tif (lk->ignore_bytes == 0)\n\t\t\tlkkbd_detection_done(lk);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tswitch (data) {\n\tcase LK_ALL_KEYS_UP:\n\t\tfor (i = 0; i < ARRAY_SIZE(lkkbd_keycode); i++)\n\t\t\tinput_report_key(input_dev, lk->keycode[i], 0);\n\t\tinput_sync(input_dev);\n\t\tbreak;\n\n\tcase 0x01:\n\t\tDBG(KERN_INFO \"Got 0x01, scheduling re-initialization\\n\");\n\t\tlk->ignore_bytes = LK_NUM_IGNORE_BYTES;\n\t\tlk->id[LK_NUM_IGNORE_BYTES - lk->ignore_bytes--] = data;\n\t\tschedule_work(&lk->tq);\n\t\tbreak;\n\n\tcase LK_METRONOME:\n\tcase LK_OUTPUT_ERROR:\n\tcase LK_INPUT_ERROR:\n\tcase LK_KBD_LOCKED:\n\tcase LK_KBD_TEST_MODE_ACK:\n\tcase LK_PREFIX_KEY_DOWN:\n\tcase LK_MODE_CHANGE_ACK:\n\tcase LK_RESPONSE_RESERVED:\n\t\tDBG(KERN_INFO \"Got %s and don't know how to handle...\\n\",\n\t\t\tresponse_name(data));\n\t\tbreak;\n\n\tdefault:\n\t\tkeycode = lk->keycode[data];\n\t\tif (keycode != KEY_RESERVED) {\n\t\t\tinput_report_key(input_dev, keycode,\n\t\t\t\t\t !test_bit(keycode, input_dev->key));\n\t\t\tinput_sync(input_dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"%s: Unknown key with scancode 0x%02x on %s.\\n\",\n\t\t\t\t__FILE__, data, lk->name);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void lkkbd_toggle_leds(struct lkkbd *lk)\n{\n\tstruct serio *serio = lk->serio;\n\tunsigned char leds_on = 0;\n\tunsigned char leds_off = 0;\n\n\tCHECK_LED(lk, leds_on, leds_off, LED_CAPSL, LK_LED_SHIFTLOCK);\n\tCHECK_LED(lk, leds_on, leds_off, LED_COMPOSE, LK_LED_COMPOSE);\n\tCHECK_LED(lk, leds_on, leds_off, LED_SCROLLL, LK_LED_SCROLLLOCK);\n\tCHECK_LED(lk, leds_on, leds_off, LED_SLEEP, LK_LED_WAIT);\n\tif (leds_on != 0) {\n\t\tserio_write(serio, LK_CMD_LED_ON);\n\t\tserio_write(serio, leds_on);\n\t}\n\tif (leds_off != 0) {\n\t\tserio_write(serio, LK_CMD_LED_OFF);\n\t\tserio_write(serio, leds_off);\n\t}\n}\n\nstatic void lkkbd_toggle_keyclick(struct lkkbd *lk, bool on)\n{\n\tstruct serio *serio = lk->serio;\n\n\tif (on) {\n\t\tDBG(\"%s: Activating key clicks\\n\", __func__);\n\t\tserio_write(serio, LK_CMD_ENABLE_KEYCLICK);\n\t\tserio_write(serio, volume_to_hw(lk->keyclick_volume));\n\t\tserio_write(serio, LK_CMD_ENABLE_CTRCLICK);\n\t\tserio_write(serio, volume_to_hw(lk->ctrlclick_volume));\n\t} else {\n\t\tDBG(\"%s: Deactivating key clicks\\n\", __func__);\n\t\tserio_write(serio, LK_CMD_DISABLE_KEYCLICK);\n\t\tserio_write(serio, LK_CMD_DISABLE_CTRCLICK);\n\t}\n\n}\n\n \nstatic int lkkbd_event(struct input_dev *dev,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct lkkbd *lk = input_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase EV_LED:\n\t\tlkkbd_toggle_leds(lk);\n\t\treturn 0;\n\n\tcase EV_SND:\n\t\tswitch (code) {\n\t\tcase SND_CLICK:\n\t\t\tlkkbd_toggle_keyclick(lk, value);\n\t\t\treturn 0;\n\n\t\tcase SND_BELL:\n\t\t\tif (value != 0)\n\t\t\t\tserio_write(lk->serio, LK_CMD_SOUND_BELL);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"%s(): Got unknown type %d, code %d, value %d\\n\",\n\t\t\t__func__, type, code, value);\n\t}\n\n\treturn -1;\n}\n\n \nstatic void lkkbd_reinit(struct work_struct *work)\n{\n\tstruct lkkbd *lk = container_of(work, struct lkkbd, tq);\n\tint division;\n\n\t \n\tserio_write(lk->serio, LK_CMD_REQUEST_ID);\n\n\t \n\tserio_write(lk->serio, LK_CMD_SET_DEFAULTS);\n\n\t \n\tlkkbd_toggle_leds(lk);\n\n\t \n\tserio_write(lk->serio, LK_CMD_ENABLE_LK401);\n\n\t \n\tfor (division = 1; division <= 14; division++)\n\t\tserio_write(lk->serio,\n\t\t\t    LK_CMD_SET_MODE(LK_MODE_UPDOWN, division));\n\n\t \n\tserio_write(lk->serio, LK_CMD_ENABLE_BELL);\n\tserio_write(lk->serio, volume_to_hw(lk->bell_volume));\n\n\t \n\tlkkbd_toggle_keyclick(lk, test_bit(SND_CLICK, lk->dev->snd));\n\n\t \n\tif (test_bit(SND_BELL, lk->dev->snd))\n\t\tserio_write(lk->serio, LK_CMD_SOUND_BELL);\n}\n\n \nstatic int lkkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct lkkbd *lk;\n\tstruct input_dev *input_dev;\n\tint i;\n\tint err;\n\n\tlk = kzalloc(sizeof(struct lkkbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!lk || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tlk->serio = serio;\n\tlk->dev = input_dev;\n\tINIT_WORK(&lk->tq, lkkbd_reinit);\n\tlk->bell_volume = bell_volume;\n\tlk->keyclick_volume = keyclick_volume;\n\tlk->ctrlclick_volume = ctrlclick_volume;\n\tmemcpy(lk->keycode, lkkbd_keycode, sizeof(lk->keycode));\n\n\tstrscpy(lk->name, \"DEC LK keyboard\", sizeof(lk->name));\n\tsnprintf(lk->phys, sizeof(lk->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = lk->name;\n\tinput_dev->phys = lk->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_LKKBD;\n\tinput_dev->id.product = 0;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\tinput_dev->event = lkkbd_event;\n\n\tinput_set_drvdata(input_dev, lk);\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(EV_LED, input_dev->evbit);\n\t__set_bit(EV_SND, input_dev->evbit);\n\t__set_bit(EV_REP, input_dev->evbit);\n\t__set_bit(LED_CAPSL, input_dev->ledbit);\n\t__set_bit(LED_SLEEP, input_dev->ledbit);\n\t__set_bit(LED_COMPOSE, input_dev->ledbit);\n\t__set_bit(LED_SCROLLL, input_dev->ledbit);\n\t__set_bit(SND_BELL, input_dev->sndbit);\n\t__set_bit(SND_CLICK, input_dev->sndbit);\n\n\tinput_dev->keycode = lk->keycode;\n\tinput_dev->keycodesize = sizeof(lk->keycode[0]);\n\tinput_dev->keycodemax = ARRAY_SIZE(lk->keycode);\n\n\tfor (i = 0; i < LK_NUM_KEYCODES; i++)\n\t\t__set_bit(lk->keycode[i], input_dev->keybit);\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\tserio_set_drvdata(serio, lk);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(lk->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\tserio_write(lk->serio, LK_CMD_POWERCYCLE_RESET);\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(lk);\n\treturn err;\n}\n\n \nstatic void lkkbd_disconnect(struct serio *serio)\n{\n\tstruct lkkbd *lk = serio_get_drvdata(serio);\n\n\tinput_get_device(lk->dev);\n\tinput_unregister_device(lk->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_put_device(lk->dev);\n\tkfree(lk);\n}\n\nstatic const struct serio_device_id lkkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_LKKBD,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, lkkbd_serio_ids);\n\nstatic struct serio_driver lkkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"lkkbd\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= lkkbd_serio_ids,\n\t.connect\t= lkkbd_connect,\n\t.disconnect\t= lkkbd_disconnect,\n\t.interrupt\t= lkkbd_interrupt,\n};\n\nmodule_serio_driver(lkkbd_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}