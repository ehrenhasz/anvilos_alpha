{
  "module_name": "qt1050.c",
  "hash_id": "98fe4019153136d802c4359a5278f326cff27aeda98de1edd399858e1079fc5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/qt1050.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n \n#define QT1050_CHIP_ID\t\t0x00\n#define QT1050_CHIP_ID_VER\t0x46\n\n \n#define QT1050_FW_VERSION\t0x01\n\n \n#define QT1050_DET_STATUS\t0x02\n\n \n#define QT1050_KEY_STATUS\t0x03\n\n \n#define QT1050_KEY_SIGNAL_0_MSB\t0x06\n#define QT1050_KEY_SIGNAL_0_LSB\t0x07\n#define QT1050_KEY_SIGNAL_1_MSB\t0x08\n#define QT1050_KEY_SIGNAL_1_LSB\t0x09\n#define QT1050_KEY_SIGNAL_2_MSB\t0x0c\n#define QT1050_KEY_SIGNAL_2_LSB\t0x0d\n#define QT1050_KEY_SIGNAL_3_MSB\t0x0e\n#define QT1050_KEY_SIGNAL_3_LSB\t0x0f\n#define QT1050_KEY_SIGNAL_4_MSB\t0x10\n#define QT1050_KEY_SIGNAL_4_LSB\t0x11\n\n \n#define QT1050_REF_DATA_0_MSB\t0x14\n#define QT1050_REF_DATA_0_LSB\t0x15\n#define QT1050_REF_DATA_1_MSB\t0x16\n#define QT1050_REF_DATA_1_LSB\t0x17\n#define QT1050_REF_DATA_2_MSB\t0x1a\n#define QT1050_REF_DATA_2_LSB\t0x1b\n#define QT1050_REF_DATA_3_MSB\t0x1c\n#define QT1050_REF_DATA_3_LSB\t0x1d\n#define QT1050_REF_DATA_4_MSB\t0x1e\n#define QT1050_REF_DATA_4_LSB\t0x1f\n\n \n#define QT1050_NTHR_0\t\t0x21\n#define QT1050_NTHR_1\t\t0x22\n#define QT1050_NTHR_2\t\t0x24\n#define QT1050_NTHR_3\t\t0x25\n#define QT1050_NTHR_4\t\t0x26\n\n \n#define QT1050_PULSE_SCALE_0\t0x28\n#define QT1050_PULSE_SCALE_1\t0x29\n#define QT1050_PULSE_SCALE_2\t0x2b\n#define QT1050_PULSE_SCALE_3\t0x2c\n#define QT1050_PULSE_SCALE_4\t0x2d\n\n \n#define QT1050_DI_AKS_0\t\t0x2f\n#define QT1050_DI_AKS_1\t\t0x30\n#define QT1050_DI_AKS_2\t\t0x32\n#define QT1050_DI_AKS_3\t\t0x33\n#define QT1050_DI_AKS_4\t\t0x34\n\n \n#define QT1050_CSD_0\t\t0x36\n#define QT1050_CSD_1\t\t0x37\n#define QT1050_CSD_2\t\t0x39\n#define QT1050_CSD_3\t\t0x3a\n#define QT1050_CSD_4\t\t0x3b\n\n \n#define QT1050_LPMODE\t\t0x3d\n\n \n#define QT1050_RES_CAL\t\t0x3f\n#define QT1050_RES_CAL_RESET\t\tBIT(7)\n#define QT1050_RES_CAL_CALIBRATE\tBIT(1)\n\n#define QT1050_MAX_KEYS\t\t5\n#define QT1050_RESET_TIME\t255\n\nstruct qt1050_key_regs {\n\tunsigned int nthr;\n\tunsigned int pulse_scale;\n\tunsigned int di_aks;\n\tunsigned int csd;\n};\n\nstruct qt1050_key {\n\tu32 num;\n\tu32 charge_delay;\n\tu32 thr_cnt;\n\tu32 samples;\n\tu32 scale;\n\tu32 keycode;\n};\n\nstruct qt1050_priv {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input;\n\tstruct regmap\t\t*regmap;\n\tstruct qt1050_key\tkeys[QT1050_MAX_KEYS];\n\tunsigned short\t\tkeycodes[QT1050_MAX_KEYS];\n\tu8\t\t\treg_keys;\n\tu8\t\t\tlast_keys;\n};\n\nstatic const struct qt1050_key_regs qt1050_key_regs_data[] = {\n\t{\n\t\t.nthr = QT1050_NTHR_0,\n\t\t.pulse_scale = QT1050_PULSE_SCALE_0,\n\t\t.di_aks = QT1050_DI_AKS_0,\n\t\t.csd = QT1050_CSD_0,\n\t}, {\n\t\t.nthr = QT1050_NTHR_1,\n\t\t.pulse_scale = QT1050_PULSE_SCALE_1,\n\t\t.di_aks = QT1050_DI_AKS_1,\n\t\t.csd = QT1050_CSD_1,\n\t}, {\n\t\t.nthr = QT1050_NTHR_2,\n\t\t.pulse_scale = QT1050_PULSE_SCALE_2,\n\t\t.di_aks = QT1050_DI_AKS_2,\n\t\t.csd = QT1050_CSD_2,\n\t}, {\n\t\t.nthr = QT1050_NTHR_3,\n\t\t.pulse_scale = QT1050_PULSE_SCALE_3,\n\t\t.di_aks = QT1050_DI_AKS_3,\n\t\t.csd = QT1050_CSD_3,\n\t}, {\n\t\t.nthr = QT1050_NTHR_4,\n\t\t.pulse_scale = QT1050_PULSE_SCALE_4,\n\t\t.di_aks = QT1050_DI_AKS_4,\n\t\t.csd = QT1050_CSD_4,\n\t}\n};\n\nstatic bool qt1050_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase QT1050_DET_STATUS:\n\tcase QT1050_KEY_STATUS:\n\tcase QT1050_KEY_SIGNAL_0_MSB:\n\tcase QT1050_KEY_SIGNAL_0_LSB:\n\tcase QT1050_KEY_SIGNAL_1_MSB:\n\tcase QT1050_KEY_SIGNAL_1_LSB:\n\tcase QT1050_KEY_SIGNAL_2_MSB:\n\tcase QT1050_KEY_SIGNAL_2_LSB:\n\tcase QT1050_KEY_SIGNAL_3_MSB:\n\tcase QT1050_KEY_SIGNAL_3_LSB:\n\tcase QT1050_KEY_SIGNAL_4_MSB:\n\tcase QT1050_KEY_SIGNAL_4_LSB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_range qt1050_readable_ranges[] = {\n\tregmap_reg_range(QT1050_CHIP_ID, QT1050_KEY_STATUS),\n\tregmap_reg_range(QT1050_KEY_SIGNAL_0_MSB, QT1050_KEY_SIGNAL_1_LSB),\n\tregmap_reg_range(QT1050_KEY_SIGNAL_2_MSB, QT1050_KEY_SIGNAL_4_LSB),\n\tregmap_reg_range(QT1050_REF_DATA_0_MSB, QT1050_REF_DATA_1_LSB),\n\tregmap_reg_range(QT1050_REF_DATA_2_MSB, QT1050_REF_DATA_4_LSB),\n\tregmap_reg_range(QT1050_NTHR_0, QT1050_NTHR_1),\n\tregmap_reg_range(QT1050_NTHR_2, QT1050_NTHR_4),\n\tregmap_reg_range(QT1050_PULSE_SCALE_0, QT1050_PULSE_SCALE_1),\n\tregmap_reg_range(QT1050_PULSE_SCALE_2, QT1050_PULSE_SCALE_4),\n\tregmap_reg_range(QT1050_DI_AKS_0, QT1050_DI_AKS_1),\n\tregmap_reg_range(QT1050_DI_AKS_2, QT1050_DI_AKS_4),\n\tregmap_reg_range(QT1050_CSD_0, QT1050_CSD_1),\n\tregmap_reg_range(QT1050_CSD_2, QT1050_RES_CAL),\n};\n\nstatic const struct regmap_access_table qt1050_readable_table = {\n\t.yes_ranges = qt1050_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(qt1050_readable_ranges),\n};\n\nstatic const struct regmap_range qt1050_writeable_ranges[] = {\n\tregmap_reg_range(QT1050_NTHR_0, QT1050_NTHR_1),\n\tregmap_reg_range(QT1050_NTHR_2, QT1050_NTHR_4),\n\tregmap_reg_range(QT1050_PULSE_SCALE_0, QT1050_PULSE_SCALE_1),\n\tregmap_reg_range(QT1050_PULSE_SCALE_2, QT1050_PULSE_SCALE_4),\n\tregmap_reg_range(QT1050_DI_AKS_0, QT1050_DI_AKS_1),\n\tregmap_reg_range(QT1050_DI_AKS_2, QT1050_DI_AKS_4),\n\tregmap_reg_range(QT1050_CSD_0, QT1050_CSD_1),\n\tregmap_reg_range(QT1050_CSD_2, QT1050_RES_CAL),\n};\n\nstatic const struct regmap_access_table qt1050_writeable_table = {\n\t.yes_ranges = qt1050_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(qt1050_writeable_ranges),\n};\n\nstatic struct regmap_config qt1050_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = QT1050_RES_CAL,\n\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.wr_table = &qt1050_writeable_table,\n\t.rd_table = &qt1050_readable_table,\n\t.volatile_reg = qt1050_volatile_reg,\n};\n\nstatic bool qt1050_identify(struct qt1050_priv *ts)\n{\n\tunsigned int val;\n\tint err;\n\n\t \n\tregmap_read(ts->regmap, QT1050_CHIP_ID, &val);\n\tif (val != QT1050_CHIP_ID_VER) {\n\t\tdev_err(&ts->client->dev, \"ID %d not supported\\n\", val);\n\t\treturn false;\n\t}\n\n\t \n\terr = regmap_read(ts->regmap, QT1050_FW_VERSION, &val);\n\tif (err) {\n\t\tdev_err(&ts->client->dev, \"could not read the firmware version\\n\");\n\t\treturn false;\n\t}\n\n\tdev_info(&ts->client->dev, \"AT42QT1050 firmware version %1d.%1d\\n\",\n\t\t val >> 4, val & 0xf);\n\n\treturn true;\n}\n\nstatic irqreturn_t qt1050_irq_threaded(int irq, void *dev_id)\n{\n\tstruct qt1050_priv *ts = dev_id;\n\tstruct input_dev *input = ts->input;\n\tunsigned long new_keys, changed;\n\tunsigned int val;\n\tint i, err;\n\n\t \n\terr = regmap_read(ts->regmap, QT1050_DET_STATUS, &val);\n\tif (err) {\n\t\tdev_err(&ts->client->dev, \"Fail to read detection status: %d\\n\",\n\t\t\terr);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\terr = regmap_read(ts->regmap, QT1050_KEY_STATUS, &val);\n\tif (err) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Fail to determine the key status: %d\\n\", err);\n\t\treturn IRQ_NONE;\n\t}\n\tnew_keys = (val & 0x70) >> 2 | (val & 0x6) >> 1;\n\tchanged = ts->last_keys ^ new_keys;\n\t \n\tchanged &= ts->reg_keys;\n\n\tfor_each_set_bit(i, &changed, QT1050_MAX_KEYS)\n\t\tinput_report_key(input, ts->keys[i].keycode,\n\t\t\t\t test_bit(i, &new_keys));\n\n\tts->last_keys = new_keys;\n\tinput_sync(input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct qt1050_key_regs *qt1050_get_key_regs(int key_num)\n{\n\treturn &qt1050_key_regs_data[key_num];\n}\n\nstatic int qt1050_set_key(struct regmap *map, int number, int on)\n{\n\tconst struct qt1050_key_regs *key_regs;\n\n\tkey_regs = qt1050_get_key_regs(number);\n\n\treturn regmap_update_bits(map, key_regs->di_aks, 0xfc,\n\t\t\t\t  on ? BIT(4) : 0x00);\n}\n\nstatic int qt1050_apply_fw_data(struct qt1050_priv *ts)\n{\n\tstruct regmap *map = ts->regmap;\n\tstruct qt1050_key *button = &ts->keys[0];\n\tconst struct qt1050_key_regs *key_regs;\n\tint i, err;\n\n\t \n\tfor (i = 0; i < QT1050_MAX_KEYS; i++) {\n\t\terr = qt1050_set_key(map, i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < QT1050_MAX_KEYS; i++, button++) {\n\t\t \n\t\tif (button->keycode == KEY_RESERVED)\n\t\t\tcontinue;\n\n\t\terr = qt1050_set_key(map, button->num, 1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tkey_regs = qt1050_get_key_regs(button->num);\n\n\t\terr = regmap_write(map, key_regs->pulse_scale,\n\t\t\t\t   (button->samples << 4) | (button->scale));\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = regmap_write(map, key_regs->csd, button->charge_delay);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = regmap_write(map, key_regs->nthr, button->thr_cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int qt1050_parse_fw(struct qt1050_priv *ts)\n{\n\tstruct device *dev = &ts->client->dev;\n\tstruct fwnode_handle *child;\n\tint nbuttons;\n\n\tnbuttons = device_get_child_node_count(dev);\n\tif (nbuttons == 0 || nbuttons > QT1050_MAX_KEYS)\n\t\treturn -ENODEV;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tstruct qt1050_key button;\n\n\t\t \n\t\tif (fwnode_property_read_u32(child, \"linux,code\",\n\t\t\t\t\t     &button.keycode)) {\n\t\t\tdev_err(dev, \"Button without keycode\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (button.keycode >= KEY_MAX) {\n\t\t\tdev_err(dev, \"Invalid keycode 0x%x\\n\",\n\t\t\t\tbutton.keycode);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (fwnode_property_read_u32(child, \"reg\",\n\t\t\t\t\t     &button.num)) {\n\t\t\tdev_err(dev, \"Button without pad number\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (button.num < 0 || button.num > QT1050_MAX_KEYS - 1)\n\t\t\tgoto err;\n\n\t\tts->reg_keys |= BIT(button.num);\n\n\t\t \n\t\tif (fwnode_property_read_u32(child,\n\t\t\t\t\t     \"microchip,pre-charge-time-ns\",\n\t\t\t\t\t     &button.charge_delay)) {\n\t\t\tbutton.charge_delay = 0;\n\t\t} else {\n\t\t\tif (button.charge_delay % 2500 == 0)\n\t\t\t\tbutton.charge_delay =\n\t\t\t\t\tbutton.charge_delay / 2500;\n\t\t\telse\n\t\t\t\tbutton.charge_delay = 0;\n\t\t}\n\n\t\tif (fwnode_property_read_u32(child, \"microchip,average-samples\",\n\t\t\t\t\t &button.samples)) {\n\t\t\tbutton.samples = 0;\n\t\t} else {\n\t\t\tif (is_power_of_2(button.samples))\n\t\t\t\tbutton.samples = ilog2(button.samples);\n\t\t\telse\n\t\t\t\tbutton.samples = 0;\n\t\t}\n\n\t\tif (fwnode_property_read_u32(child, \"microchip,average-scaling\",\n\t\t\t\t\t     &button.scale)) {\n\t\t\tbutton.scale = 0;\n\t\t} else {\n\t\t\tif (is_power_of_2(button.scale))\n\t\t\t\tbutton.scale = ilog2(button.scale);\n\t\t\telse\n\t\t\t\tbutton.scale = 0;\n\n\t\t}\n\n\t\tif (fwnode_property_read_u32(child, \"microchip,threshold\",\n\t\t\t\t\t &button.thr_cnt)) {\n\t\t\tbutton.thr_cnt = 20;\n\t\t} else {\n\t\t\tif (button.thr_cnt > 255)\n\t\t\t\tbutton.thr_cnt = 20;\n\t\t}\n\n\t\tts->keys[button.num] = button;\n\t}\n\n\treturn 0;\n\nerr:\n\tfwnode_handle_put(child);\n\treturn -EINVAL;\n}\n\nstatic int qt1050_probe(struct i2c_client *client)\n{\n\tstruct qt1050_priv *ts;\n\tstruct input_dev *input;\n\tstruct device *dev = &client->dev;\n\tstruct regmap *map;\n\tunsigned int status, i;\n\tint err;\n\n\t \n\terr = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE);\n\tif (!err) {\n\t\tdev_err(&client->dev, \"%s adapter not supported\\n\",\n\t\t\tdev_driver_string(&client->adapter->dev));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"assign a irq line to this device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tmap = devm_regmap_init_i2c(client, &qt1050_regmap_config);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tts->client = client;\n\tts->input = input;\n\tts->regmap = map;\n\n\ti2c_set_clientdata(client, ts);\n\n\t \n\tif (!qt1050_identify(ts))\n\t\treturn -ENODEV;\n\n\t \n\terr = qt1050_parse_fw(ts);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to parse firmware: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tinput->name = \"AT42QT1050 QTouch Sensor\";\n\tinput->dev.parent = &client->dev;\n\tinput->id.bustype = BUS_I2C;\n\n\t \n\tinput->keycode = ts->keycodes;\n\tinput->keycodesize = sizeof(ts->keycodes[0]);\n\tinput->keycodemax = QT1050_MAX_KEYS;\n\n\t__set_bit(EV_KEY, input->evbit);\n\tfor (i = 0; i < QT1050_MAX_KEYS; i++) {\n\t\tts->keycodes[i] = ts->keys[i].keycode;\n\t\t__set_bit(ts->keycodes[i], input->keybit);\n\t}\n\n\t \n\terr = regmap_update_bits(ts->regmap, QT1050_RES_CAL, 0x7f,\n\t\t\t\t QT1050_RES_CAL_CALIBRATE);\n\tif (err) {\n\t\tdev_err(dev, \"Trigger calibration failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\terr = regmap_read_poll_timeout(ts->regmap, QT1050_DET_STATUS, status,\n\t\t\t\t status >> 7 == 1, 10000, 200000);\n\tif (err) {\n\t\tdev_err(dev, \"Calibration failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = regmap_update_bits(ts->regmap, QT1050_RES_CAL,\n\t\t\t\t QT1050_RES_CAL_RESET, QT1050_RES_CAL_RESET);\n\tif (err) {\n\t\tdev_err(dev, \"Trigger soft reset failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\tmsleep(QT1050_RESET_TIME);\n\n\t \n\terr = qt1050_apply_fw_data(ts);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to set firmware data: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tqt1050_irq_threaded, IRQF_ONESHOT,\n\t\t\t\t\t\"qt1050\", ts);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to request irq: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = regmap_read(ts->regmap, QT1050_DET_STATUS, &status);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to clear #CHANGE line level: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = input_register_device(ts->input);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to register input device: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int qt1050_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct qt1050_priv *ts = i2c_get_clientdata(client);\n\n\tdisable_irq(client->irq);\n\n\t \n\treturn regmap_write(ts->regmap, QT1050_LPMODE,\n\t\t\t    device_may_wakeup(dev) ? 125 : 0);\n}\n\nstatic int qt1050_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct qt1050_priv *ts = i2c_get_clientdata(client);\n\n\tenable_irq(client->irq);\n\n\t \n\treturn regmap_write(ts->regmap, QT1050_LPMODE, 2);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(qt1050_pm_ops, qt1050_suspend, qt1050_resume);\n\nstatic const struct of_device_id __maybe_unused qt1050_of_match[] = {\n\t{ .compatible = \"microchip,qt1050\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qt1050_of_match);\n\nstatic struct i2c_driver qt1050_driver = {\n\t.driver\t= {\n\t\t.name = \"qt1050\",\n\t\t.of_match_table = of_match_ptr(qt1050_of_match),\n\t\t.pm = pm_sleep_ptr(&qt1050_pm_ops),\n\t},\n\t.probe = qt1050_probe,\n};\n\nmodule_i2c_driver(qt1050_driver);\n\nMODULE_AUTHOR(\"Marco Felsch <kernel@pengutronix.de\");\nMODULE_DESCRIPTION(\"Driver for AT42QT1050 QTouch sensor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}