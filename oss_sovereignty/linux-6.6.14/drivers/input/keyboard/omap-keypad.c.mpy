{
  "module_name": "omap-keypad.c",
  "hash_id": "474ad700536637ffec10af9ba36517938b0b807ea47f390db0443e769962ab47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/omap-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <linux/platform_data/gpio-omap.h>\n#include <linux/platform_data/keypad-omap.h>\n#include <linux/soc/ti/omap1-io.h>\n\n#undef NEW_BOARD_LEARNING_MODE\n\nstatic void omap_kp_tasklet(unsigned long);\nstatic void omap_kp_timer(struct timer_list *);\n\nstatic unsigned char keypad_state[8];\nstatic DEFINE_MUTEX(kp_enable_mutex);\nstatic int kp_enable = 1;\nstatic int kp_cur_group = -1;\n\nstruct omap_kp {\n\tstruct input_dev *input;\n\tstruct timer_list timer;\n\tint irq;\n\tunsigned int rows;\n\tunsigned int cols;\n\tunsigned long delay;\n\tunsigned int debounce;\n\tunsigned short keymap[];\n};\n\nstatic DECLARE_TASKLET_DISABLED_OLD(kp_tasklet, omap_kp_tasklet);\n\nstatic unsigned int *row_gpios;\nstatic unsigned int *col_gpios;\n\nstatic irqreturn_t omap_kp_interrupt(int irq, void *dev_id)\n{\n\t \n\tomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\n\n\ttasklet_schedule(&kp_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void omap_kp_timer(struct timer_list *unused)\n{\n\ttasklet_schedule(&kp_tasklet);\n}\n\nstatic void omap_kp_scan_keypad(struct omap_kp *omap_kp, unsigned char *state)\n{\n\tint col = 0;\n\n\t \n\tomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\n\n\t \n\tomap_writew(0xff, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);\n\tfor (col = 0; col < omap_kp->cols; col++) {\n\t\tomap_writew(~(1 << col) & 0xff,\n\t\t\t    OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);\n\n\t\tudelay(omap_kp->delay);\n\n\t\tstate[col] = ~omap_readw(OMAP1_MPUIO_BASE +\n\t\t\t\t\t OMAP_MPUIO_KBR_LATCH) & 0xff;\n\t}\n\tomap_writew(0x00, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);\n\tudelay(2);\n}\n\nstatic void omap_kp_tasklet(unsigned long data)\n{\n\tstruct omap_kp *omap_kp_data = (struct omap_kp *) data;\n\tunsigned short *keycodes = omap_kp_data->input->keycode;\n\tunsigned int row_shift = get_count_order(omap_kp_data->cols);\n\tunsigned char new_state[8], changed, key_down = 0;\n\tint col, row;\n\n\t \n\tomap_kp_scan_keypad(omap_kp_data, new_state);\n\n\t \n\tfor (col = 0; col < omap_kp_data->cols; col++) {\n\t\tchanged = new_state[col] ^ keypad_state[col];\n\t\tkey_down |= new_state[col];\n\t\tif (changed == 0)\n\t\t\tcontinue;\n\n\t\tfor (row = 0; row < omap_kp_data->rows; row++) {\n\t\t\tint key;\n\t\t\tif (!(changed & (1 << row)))\n\t\t\t\tcontinue;\n#ifdef NEW_BOARD_LEARNING_MODE\n\t\t\tprintk(KERN_INFO \"omap-keypad: key %d-%d %s\\n\", col,\n\t\t\t       row, (new_state[col] & (1 << row)) ?\n\t\t\t       \"pressed\" : \"released\");\n#else\n\t\t\tkey = keycodes[MATRIX_SCAN_CODE(row, col, row_shift)];\n\n\t\t\tif (!(kp_cur_group == (key & GROUP_MASK) ||\n\t\t\t      kp_cur_group == -1))\n\t\t\t\tcontinue;\n\n\t\t\tkp_cur_group = key & GROUP_MASK;\n\t\t\tinput_report_key(omap_kp_data->input, key & ~GROUP_MASK,\n\t\t\t\t\t new_state[col] & (1 << row));\n#endif\n\t\t}\n\t}\n\tinput_sync(omap_kp_data->input);\n\tmemcpy(keypad_state, new_state, sizeof(keypad_state));\n\n\tif (key_down) {\n\t\t \n\t\tmod_timer(&omap_kp_data->timer, jiffies + HZ / 20);\n\t} else {\n\t\t \n\t\tomap_writew(0, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\n\t\tkp_cur_group = -1;\n\t}\n}\n\nstatic ssize_t omap_kp_enable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", kp_enable);\n}\n\nstatic ssize_t omap_kp_enable_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct omap_kp *omap_kp = dev_get_drvdata(dev);\n\tint state;\n\n\tif (sscanf(buf, \"%u\", &state) != 1)\n\t\treturn -EINVAL;\n\n\tif ((state != 1) && (state != 0))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kp_enable_mutex);\n\tif (state != kp_enable) {\n\t\tif (state)\n\t\t\tenable_irq(omap_kp->irq);\n\t\telse\n\t\t\tdisable_irq(omap_kp->irq);\n\t\tkp_enable = state;\n\t}\n\tmutex_unlock(&kp_enable_mutex);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, omap_kp_enable_show, omap_kp_enable_store);\n\nstatic int omap_kp_probe(struct platform_device *pdev)\n{\n\tstruct omap_kp *omap_kp;\n\tstruct input_dev *input_dev;\n\tstruct omap_kp_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tint i, col_idx, row_idx, ret;\n\tunsigned int row_shift, keycodemax;\n\n\tif (!pdata->rows || !pdata->cols || !pdata->keymap_data) {\n\t\tprintk(KERN_ERR \"No rows, cols or keymap_data from pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trow_shift = get_count_order(pdata->cols);\n\tkeycodemax = pdata->rows << row_shift;\n\n\tomap_kp = kzalloc(struct_size(omap_kp, keymap, keycodemax), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!omap_kp || !input_dev) {\n\t\tkfree(omap_kp);\n\t\tinput_free_device(input_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, omap_kp);\n\n\tomap_kp->input = input_dev;\n\n\t \n\tomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\n\n\tif (pdata->delay)\n\t\tomap_kp->delay = pdata->delay;\n\n\tif (pdata->row_gpios && pdata->col_gpios) {\n\t\trow_gpios = pdata->row_gpios;\n\t\tcol_gpios = pdata->col_gpios;\n\t}\n\n\tomap_kp->rows = pdata->rows;\n\tomap_kp->cols = pdata->cols;\n\n\tcol_idx = 0;\n\trow_idx = 0;\n\n\ttimer_setup(&omap_kp->timer, omap_kp_timer, 0);\n\n\t \n\tkp_tasklet.data = (unsigned long) omap_kp;\n\ttasklet_enable(&kp_tasklet);\n\n\tret = device_create_file(&pdev->dev, &dev_attr_enable);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\t \n\tinput_dev->name = \"omap-keypad\";\n\tinput_dev->phys = \"omap-keypad/input0\";\n\tinput_dev->dev.parent = &pdev->dev;\n\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\n\tif (pdata->rep)\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\n\tret = matrix_keypad_build_keymap(pdata->keymap_data, NULL,\n\t\t\t\t\t pdata->rows, pdata->cols,\n\t\t\t\t\t omap_kp->keymap, input_dev);\n\tif (ret < 0)\n\t\tgoto err3;\n\n\tret = input_register_device(omap_kp->input);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"Unable to register omap-keypad input device\\n\");\n\t\tgoto err3;\n\t}\n\n\tif (pdata->dbounce)\n\t\tomap_writew(0xff, OMAP1_MPUIO_BASE + OMAP_MPUIO_GPIO_DEBOUNCING);\n\n\t \n\tomap_kp_scan_keypad(omap_kp, keypad_state);\n\tomap_kp->irq = platform_get_irq(pdev, 0);\n\tif (omap_kp->irq >= 0) {\n\t\tif (request_irq(omap_kp->irq, omap_kp_interrupt, 0,\n\t\t\t\t\"omap-keypad\", omap_kp) < 0)\n\t\t\tgoto err4;\n\t}\n\tomap_writew(0, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\n\n\treturn 0;\n\nerr4:\n\tinput_unregister_device(omap_kp->input);\n\tinput_dev = NULL;\nerr3:\n\tdevice_remove_file(&pdev->dev, &dev_attr_enable);\nerr2:\n\tfor (i = row_idx - 1; i >= 0; i--)\n\t\tgpio_free(row_gpios[i]);\n\tfor (i = col_idx - 1; i >= 0; i--)\n\t\tgpio_free(col_gpios[i]);\n\n\tkfree(omap_kp);\n\tinput_free_device(input_dev);\n\n\treturn -EINVAL;\n}\n\nstatic int omap_kp_remove(struct platform_device *pdev)\n{\n\tstruct omap_kp *omap_kp = platform_get_drvdata(pdev);\n\n\t \n\ttasklet_disable(&kp_tasklet);\n\tomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\n\tfree_irq(omap_kp->irq, omap_kp);\n\n\ttimer_shutdown_sync(&omap_kp->timer);\n\ttasklet_kill(&kp_tasklet);\n\n\t \n\tinput_unregister_device(omap_kp->input);\n\n\tkfree(omap_kp);\n\n\treturn 0;\n}\n\nstatic struct platform_driver omap_kp_driver = {\n\t.probe\t\t= omap_kp_probe,\n\t.remove\t\t= omap_kp_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap-keypad\",\n\t},\n};\nmodule_platform_driver(omap_kp_driver);\n\nMODULE_AUTHOR(\"Timo Ter\u00e4s\");\nMODULE_DESCRIPTION(\"OMAP Keypad Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}