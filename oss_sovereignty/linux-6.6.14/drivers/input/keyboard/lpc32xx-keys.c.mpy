{
  "module_name": "lpc32xx-keys.c",
  "hash_id": "b2e374b4d261e0482be06989252d7e497e92519273a9754e77f0344fd4d82a19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/lpc32xx-keys.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/pm.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/input/matrix_keypad.h>\n\n#define DRV_NAME\t\t\t\t\"lpc32xx_keys\"\n\n \n#define LPC32XX_KS_DEB(x)\t\t\t((x) + 0x00)\n#define LPC32XX_KS_STATE_COND(x)\t\t((x) + 0x04)\n#define LPC32XX_KS_IRQ(x)\t\t\t((x) + 0x08)\n#define LPC32XX_KS_SCAN_CTL(x)\t\t\t((x) + 0x0C)\n#define LPC32XX_KS_FAST_TST(x)\t\t\t((x) + 0x10)\n#define LPC32XX_KS_MATRIX_DIM(x)\t\t((x) + 0x14)  \n#define LPC32XX_KS_DATA(x, y)\t\t\t((x) + 0x40 + ((y) << 2))\n\n#define LPC32XX_KSCAN_DEB_NUM_DEB_PASS(n)\t((n) & 0xFF)\n\n#define LPC32XX_KSCAN_SCOND_IN_IDLE\t\t0x0\n#define LPC32XX_KSCAN_SCOND_IN_SCANONCE\t\t0x1\n#define LPC32XX_KSCAN_SCOND_IN_IRQGEN\t\t0x2\n#define LPC32XX_KSCAN_SCOND_IN_SCAN_MATRIX\t0x3\n\n#define LPC32XX_KSCAN_IRQ_PENDING_CLR\t\t0x1\n\n#define LPC32XX_KSCAN_SCTRL_SCAN_DELAY(n)\t((n) & 0xFF)\n\n#define LPC32XX_KSCAN_FTST_FORCESCANONCE\t0x1\n#define LPC32XX_KSCAN_FTST_USE32K_CLK\t\t0x2\n\n#define LPC32XX_KSCAN_MSEL_SELECT(n)\t\t((n) & 0xF)\n\nstruct lpc32xx_kscan_drv {\n\tstruct input_dev *input;\n\tstruct clk *clk;\n\tvoid __iomem *kscan_base;\n\tunsigned int irq;\n\n\tu32 matrix_sz;\t\t \n\tu32 deb_clks;\t\t \n\tu32 scan_delay;\t\t \n\n\tunsigned short *keymap;\t \n\tunsigned int row_shift;\n\n\tu8 lastkeystates[8];\n};\n\nstatic void lpc32xx_mod_states(struct lpc32xx_kscan_drv *kscandat, int col)\n{\n\tstruct input_dev *input = kscandat->input;\n\tunsigned row, changed, scancode, keycode;\n\tu8 key;\n\n\tkey = readl(LPC32XX_KS_DATA(kscandat->kscan_base, col));\n\tchanged = key ^ kscandat->lastkeystates[col];\n\tkscandat->lastkeystates[col] = key;\n\n\tfor (row = 0; changed; row++, changed >>= 1) {\n\t\tif (changed & 1) {\n\t\t\t \n\t\t\tscancode = MATRIX_SCAN_CODE(row, col,\n\t\t\t\t\t\t    kscandat->row_shift);\n\t\t\tkeycode = kscandat->keymap[scancode];\n\t\t\tinput_event(input, EV_MSC, MSC_SCAN, scancode);\n\t\t\tinput_report_key(input, keycode, key & (1 << row));\n\t\t}\n\t}\n}\n\nstatic irqreturn_t lpc32xx_kscan_irq(int irq, void *dev_id)\n{\n\tstruct lpc32xx_kscan_drv *kscandat = dev_id;\n\tint i;\n\n\tfor (i = 0; i < kscandat->matrix_sz; i++)\n\t\tlpc32xx_mod_states(kscandat, i);\n\n\twritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\n\n\tinput_sync(kscandat->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lpc32xx_kscan_open(struct input_dev *dev)\n{\n\tstruct lpc32xx_kscan_drv *kscandat = input_get_drvdata(dev);\n\tint error;\n\n\terror = clk_prepare_enable(kscandat->clk);\n\tif (error)\n\t\treturn error;\n\n\twritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\n\n\treturn 0;\n}\n\nstatic void lpc32xx_kscan_close(struct input_dev *dev)\n{\n\tstruct lpc32xx_kscan_drv *kscandat = input_get_drvdata(dev);\n\n\twritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\n\tclk_disable_unprepare(kscandat->clk);\n}\n\nstatic int lpc32xx_parse_dt(struct device *dev,\n\t\t\t\t      struct lpc32xx_kscan_drv *kscandat)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 rows = 0, columns = 0;\n\tint err;\n\n\terr = matrix_keypad_parse_properties(dev, &rows, &columns);\n\tif (err)\n\t\treturn err;\n\tif (rows != columns) {\n\t\tdev_err(dev, \"rows and columns must be equal!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkscandat->matrix_sz = rows;\n\tkscandat->row_shift = get_count_order(columns);\n\n\tof_property_read_u32(np, \"nxp,debounce-delay-ms\", &kscandat->deb_clks);\n\tof_property_read_u32(np, \"nxp,scan-delay-ms\", &kscandat->scan_delay);\n\tif (!kscandat->deb_clks || !kscandat->scan_delay) {\n\t\tdev_err(dev, \"debounce or scan delay not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc32xx_kscan_probe(struct platform_device *pdev)\n{\n\tstruct lpc32xx_kscan_drv *kscandat;\n\tstruct input_dev *input;\n\tsize_t keymap_size;\n\tint error;\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tkscandat = devm_kzalloc(&pdev->dev, sizeof(*kscandat),\n\t\t\t\tGFP_KERNEL);\n\tif (!kscandat)\n\t\treturn -ENOMEM;\n\n\terror = lpc32xx_parse_dt(&pdev->dev, kscandat);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to parse device tree\\n\");\n\t\treturn error;\n\t}\n\n\tkeymap_size = sizeof(kscandat->keymap[0]) *\n\t\t\t\t(kscandat->matrix_sz << kscandat->row_shift);\n\tkscandat->keymap = devm_kzalloc(&pdev->dev, keymap_size, GFP_KERNEL);\n\tif (!kscandat->keymap)\n\t\treturn -ENOMEM;\n\n\tkscandat->input = input = devm_input_allocate_device(&pdev->dev);\n\tif (!input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tinput->name\t\t= pdev->name;\n\tinput->phys\t\t= \"lpc32xx/input0\";\n\tinput->id.vendor\t= 0x0001;\n\tinput->id.product\t= 0x0001;\n\tinput->id.version\t= 0x0100;\n\tinput->open\t\t= lpc32xx_kscan_open;\n\tinput->close\t\t= lpc32xx_kscan_close;\n\tinput->dev.parent\t= &pdev->dev;\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   kscandat->matrix_sz,\n\t\t\t\t\t   kscandat->matrix_sz,\n\t\t\t\t\t   kscandat->keymap, kscandat->input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tinput_set_drvdata(kscandat->input, kscandat);\n\n\tkscandat->kscan_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(kscandat->kscan_base))\n\t\treturn PTR_ERR(kscandat->kscan_base);\n\n\t \n\tkscandat->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(kscandat->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(kscandat->clk);\n\t}\n\n\t \n\terror = clk_prepare_enable(kscandat->clk);\n\tif (error)\n\t\treturn error;\n\n\twritel(kscandat->deb_clks, LPC32XX_KS_DEB(kscandat->kscan_base));\n\twritel(kscandat->scan_delay, LPC32XX_KS_SCAN_CTL(kscandat->kscan_base));\n\twritel(LPC32XX_KSCAN_FTST_USE32K_CLK,\n\t       LPC32XX_KS_FAST_TST(kscandat->kscan_base));\n\twritel(kscandat->matrix_sz,\n\t       LPC32XX_KS_MATRIX_DIM(kscandat->kscan_base));\n\twritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\n\tclk_disable_unprepare(kscandat->clk);\n\n\terror = devm_request_irq(&pdev->dev, irq, lpc32xx_kscan_irq, 0,\n\t\t\t\t pdev->name, kscandat);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request irq\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(kscandat->input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, kscandat);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_kscan_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\n\tstruct input_dev *input = kscandat->input;\n\n\tmutex_lock(&input->mutex);\n\n\tif (input_device_enabled(input)) {\n\t\t \n\t\twritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\n\t\tclk_disable_unprepare(kscandat->clk);\n\t}\n\n\tmutex_unlock(&input->mutex);\n\treturn 0;\n}\n\nstatic int lpc32xx_kscan_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\n\tstruct input_dev *input = kscandat->input;\n\tint retval = 0;\n\n\tmutex_lock(&input->mutex);\n\n\tif (input_device_enabled(input)) {\n\t\t \n\t\tretval = clk_prepare_enable(kscandat->clk);\n\t\tif (retval == 0)\n\t\t\twritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\n\t}\n\n\tmutex_unlock(&input->mutex);\n\treturn retval;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(lpc32xx_kscan_pm_ops, lpc32xx_kscan_suspend,\n\t\t\t\tlpc32xx_kscan_resume);\n\nstatic const struct of_device_id lpc32xx_kscan_match[] = {\n\t{ .compatible = \"nxp,lpc3220-key\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_kscan_match);\n\nstatic struct platform_driver lpc32xx_kscan_driver = {\n\t.probe\t\t= lpc32xx_kscan_probe,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.pm\t= pm_sleep_ptr(&lpc32xx_kscan_pm_ops),\n\t\t.of_match_table = lpc32xx_kscan_match,\n\t}\n};\n\nmodule_platform_driver(lpc32xx_kscan_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com>\");\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"Key scanner driver for LPC32XX devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}