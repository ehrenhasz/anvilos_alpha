{
  "module_name": "omap4-keypad.c",
  "hash_id": "e635839d54f8cba3b67c04083bf68b6dc81da556739955c53556dc7c007df9cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/omap4-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n\n \n#define OMAP4_KBD_REVISION\t\t0x00\n#define OMAP4_KBD_SYSCONFIG\t\t0x10\n#define OMAP4_KBD_SYSSTATUS\t\t0x14\n#define OMAP4_KBD_IRQSTATUS\t\t0x18\n#define OMAP4_KBD_IRQENABLE\t\t0x1C\n#define OMAP4_KBD_WAKEUPENABLE\t\t0x20\n#define OMAP4_KBD_PENDING\t\t0x24\n#define OMAP4_KBD_CTRL\t\t\t0x28\n#define OMAP4_KBD_DEBOUNCINGTIME\t0x2C\n#define OMAP4_KBD_LONGKEYTIME\t\t0x30\n#define OMAP4_KBD_TIMEOUT\t\t0x34\n#define OMAP4_KBD_STATEMACHINE\t\t0x38\n#define OMAP4_KBD_ROWINPUTS\t\t0x3C\n#define OMAP4_KBD_COLUMNOUTPUTS\t\t0x40\n#define OMAP4_KBD_FULLCODE31_0\t\t0x44\n#define OMAP4_KBD_FULLCODE63_32\t\t0x48\n\n \n#define OMAP4_DEF_IRQENABLE_EVENTEN\tBIT(0)\n#define OMAP4_DEF_IRQENABLE_LONGKEY\tBIT(1)\n#define OMAP4_DEF_WUP_EVENT_ENA\t\tBIT(0)\n#define OMAP4_DEF_WUP_LONG_KEY_ENA\tBIT(1)\n#define OMAP4_DEF_CTRL_NOSOFTMODE\tBIT(1)\n#define OMAP4_DEF_CTRL_PTV_SHIFT\t2\n\n \n#define OMAP4_VAL_IRQDISABLE\t\t0x0\n\n \n#define OMAP4_KEYPAD_PTV_DIV_128        0x6\n#define OMAP4_KEYPAD_DEBOUNCINGTIME_MS(dbms, ptv)     \\\n\t((((dbms) * 1000) / ((1 << ((ptv) + 1)) * (1000000 / 32768))) - 1)\n#define OMAP4_VAL_DEBOUNCINGTIME_16MS\t\t\t\t\t\\\n\tOMAP4_KEYPAD_DEBOUNCINGTIME_MS(16, OMAP4_KEYPAD_PTV_DIV_128)\n#define OMAP4_KEYPAD_AUTOIDLE_MS\t50\t \n#define OMAP4_KEYPAD_IDLE_CHECK_MS\t(OMAP4_KEYPAD_AUTOIDLE_MS / 2)\n\nenum {\n\tKBD_REVISION_OMAP4 = 0,\n\tKBD_REVISION_OMAP5,\n};\n\nstruct omap4_keypad {\n\tstruct input_dev *input;\n\n\tvoid __iomem *base;\n\tunsigned int irq;\n\tstruct mutex lock;\t\t \n\n\tunsigned int rows;\n\tunsigned int cols;\n\tu32 reg_offset;\n\tu32 irqreg_offset;\n\tunsigned int row_shift;\n\tbool no_autorepeat;\n\tu64 keys;\n\tunsigned short *keymap;\n};\n\nstatic int kbd_readl(struct omap4_keypad *keypad_data, u32 offset)\n{\n\treturn __raw_readl(keypad_data->base +\n\t\t\t\tkeypad_data->reg_offset + offset);\n}\n\nstatic void kbd_writel(struct omap4_keypad *keypad_data, u32 offset, u32 value)\n{\n\t__raw_writel(value,\n\t\t     keypad_data->base + keypad_data->reg_offset + offset);\n}\n\nstatic int kbd_read_irqreg(struct omap4_keypad *keypad_data, u32 offset)\n{\n\treturn __raw_readl(keypad_data->base +\n\t\t\t\tkeypad_data->irqreg_offset + offset);\n}\n\nstatic void kbd_write_irqreg(struct omap4_keypad *keypad_data,\n\t\t\t     u32 offset, u32 value)\n{\n\t__raw_writel(value,\n\t\t     keypad_data->base + keypad_data->irqreg_offset + offset);\n}\n\nstatic int omap4_keypad_report_keys(struct omap4_keypad *keypad_data,\n\t\t\t\t    u64 keys, bool down)\n{\n\tstruct input_dev *input_dev = keypad_data->input;\n\tunsigned int col, row, code;\n\tDECLARE_BITMAP(mask, 64);\n\tunsigned long bit;\n\tint events = 0;\n\n\tbitmap_from_u64(mask, keys);\n\n\tfor_each_set_bit(bit, mask, keypad_data->rows * BITS_PER_BYTE) {\n\t\trow = bit / BITS_PER_BYTE;\n\t\tcol = bit % BITS_PER_BYTE;\n\t\tcode = MATRIX_SCAN_CODE(row, col, keypad_data->row_shift);\n\n\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(input_dev, keypad_data->keymap[code], down);\n\n\t\tevents++;\n\t}\n\n\tif (events)\n\t\tinput_sync(input_dev);\n\n\treturn events;\n}\n\nstatic void omap4_keypad_scan_keys(struct omap4_keypad *keypad_data, u64 keys)\n{\n\tu64 changed;\n\n\tmutex_lock(&keypad_data->lock);\n\n\tchanged = keys ^ keypad_data->keys;\n\n\t \n\tomap4_keypad_report_keys(keypad_data, changed & ~keys, false);\n\n\t \n\tomap4_keypad_report_keys(keypad_data, changed & keys, true);\n\n\tkeypad_data->keys = keys;\n\n\tmutex_unlock(&keypad_data->lock);\n}\n\n \nstatic irqreturn_t omap4_keypad_irq_handler(int irq, void *dev_id)\n{\n\tstruct omap4_keypad *keypad_data = dev_id;\n\n\tif (kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS))\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t omap4_keypad_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct omap4_keypad *keypad_data = dev_id;\n\tstruct device *dev = keypad_data->input->dev.parent;\n\tu32 low, high;\n\tint error;\n\tu64 keys;\n\n\terror = pm_runtime_resume_and_get(dev);\n\tif (error)\n\t\treturn IRQ_NONE;\n\n\tlow = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE31_0);\n\thigh = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE63_32);\n\tkeys = low | (u64)high << 32;\n\n\tomap4_keypad_scan_keys(keypad_data, keys);\n\n\t \n\tkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,\n\t\t\t kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int omap4_keypad_open(struct input_dev *input)\n{\n\tstruct omap4_keypad *keypad_data = input_get_drvdata(input);\n\tstruct device *dev = input->dev.parent;\n\tint error;\n\n\terror = pm_runtime_resume_and_get(dev);\n\tif (error)\n\t\treturn error;\n\n\tdisable_irq(keypad_data->irq);\n\n\tkbd_writel(keypad_data, OMAP4_KBD_CTRL,\n\t\t\tOMAP4_DEF_CTRL_NOSOFTMODE |\n\t\t\t(OMAP4_KEYPAD_PTV_DIV_128 << OMAP4_DEF_CTRL_PTV_SHIFT));\n\tkbd_writel(keypad_data, OMAP4_KBD_DEBOUNCINGTIME,\n\t\t\tOMAP4_VAL_DEBOUNCINGTIME_16MS);\n\t \n\tkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,\n\t\t\t kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));\n\tkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,\n\t\t\tOMAP4_DEF_IRQENABLE_EVENTEN);\n\tkbd_writel(keypad_data, OMAP4_KBD_WAKEUPENABLE,\n\t\t\tOMAP4_DEF_WUP_EVENT_ENA);\n\n\tenable_irq(keypad_data->irq);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic void omap4_keypad_stop(struct omap4_keypad *keypad_data)\n{\n\t \n\tkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,\n\t\t\t OMAP4_VAL_IRQDISABLE);\n\tkbd_writel(keypad_data, OMAP4_KBD_WAKEUPENABLE, 0);\n\n\t \n\tkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,\n\t\t\t kbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));\n}\n\nstatic void omap4_keypad_close(struct input_dev *input)\n{\n\tstruct omap4_keypad *keypad_data = input_get_drvdata(input);\n\tstruct device *dev = input->dev.parent;\n\tint error;\n\n\terror = pm_runtime_resume_and_get(dev);\n\tif (error)\n\t\tdev_err(dev, \"%s: pm_runtime_resume_and_get() failed: %d\\n\",\n\t\t\t__func__, error);\n\n\tdisable_irq(keypad_data->irq);\n\tomap4_keypad_stop(keypad_data);\n\tenable_irq(keypad_data->irq);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n\nstatic int omap4_keypad_parse_dt(struct device *dev,\n\t\t\t\t struct omap4_keypad *keypad_data)\n{\n\tstruct device_node *np = dev->of_node;\n\tint err;\n\n\terr = matrix_keypad_parse_properties(dev, &keypad_data->rows,\n\t\t\t\t\t     &keypad_data->cols);\n\tif (err)\n\t\treturn err;\n\n\tkeypad_data->no_autorepeat = of_property_read_bool(np, \"linux,input-no-autorepeat\");\n\n\treturn 0;\n}\n\nstatic int omap4_keypad_check_revision(struct device *dev,\n\t\t\t\t       struct omap4_keypad *keypad_data)\n{\n\tunsigned int rev;\n\n\trev = __raw_readl(keypad_data->base + OMAP4_KBD_REVISION);\n\trev &= 0x03 << 30;\n\trev >>= 30;\n\tswitch (rev) {\n\tcase KBD_REVISION_OMAP4:\n\t\tkeypad_data->reg_offset = 0x00;\n\t\tkeypad_data->irqreg_offset = 0x00;\n\t\tbreak;\n\tcase KBD_REVISION_OMAP5:\n\t\tkeypad_data->reg_offset = 0x10;\n\t\tkeypad_data->irqreg_offset = 0x0c;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Keypad reports unsupported revision %d\", rev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int omap4_keypad_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct omap4_keypad *keypad_data = platform_get_drvdata(pdev);\n\tu32 active;\n\n\tactive = kbd_readl(keypad_data, OMAP4_KBD_STATEMACHINE);\n\tif (active) {\n\t\tpm_runtime_mark_last_busy(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tomap4_keypad_scan_keys(keypad_data, 0);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap4_keypad_pm_ops = {\n\tRUNTIME_PM_OPS(omap4_keypad_runtime_suspend, NULL, NULL)\n};\n\nstatic void omap4_disable_pm(void *d)\n{\n\tpm_runtime_dont_use_autosuspend(d);\n\tpm_runtime_disable(d);\n}\n\nstatic int omap4_keypad_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct omap4_keypad *keypad_data;\n\tstruct input_dev *input_dev;\n\tunsigned int max_keys;\n\tint irq;\n\tint error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tkeypad_data = devm_kzalloc(dev, sizeof(*keypad_data), GFP_KERNEL);\n\tif (!keypad_data) {\n\t\tdev_err(dev, \"keypad_data memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad_data->irq = irq;\n\tmutex_init(&keypad_data->lock);\n\tplatform_set_drvdata(pdev, keypad_data);\n\n\terror = omap4_keypad_parse_dt(dev, keypad_data);\n\tif (error)\n\t\treturn error;\n\n\tkeypad_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(keypad_data->base))\n\t\treturn PTR_ERR(keypad_data->base);\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, OMAP4_KEYPAD_IDLE_CHECK_MS);\n\tpm_runtime_enable(dev);\n\n\terror = devm_add_action_or_reset(dev, omap4_disable_pm, dev);\n\tif (error) {\n\t\tdev_err(dev, \"unable to register cleanup action\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = pm_runtime_resume_and_get(dev);\n\tif (error) {\n\t\tdev_err(dev, \"pm_runtime_resume_and_get() failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = omap4_keypad_check_revision(dev, keypad_data);\n\tif (!error) {\n\t\t \n\t\tomap4_keypad_stop(keypad_data);\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tif (error)\n\t\treturn error;\n\n\t \n\tkeypad_data->input = input_dev = devm_input_allocate_device(dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = pdev->name;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0001;\n\n\tinput_dev->open = omap4_keypad_open;\n\tinput_dev->close = omap4_keypad_close;\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tif (!keypad_data->no_autorepeat)\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\n\tinput_set_drvdata(input_dev, keypad_data);\n\n\tkeypad_data->row_shift = get_count_order(keypad_data->cols);\n\tmax_keys = keypad_data->rows << keypad_data->row_shift;\n\tkeypad_data->keymap = devm_kcalloc(dev,\n\t\t\t\t\t   max_keys,\n\t\t\t\t\t   sizeof(keypad_data->keymap[0]),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!keypad_data->keymap) {\n\t\tdev_err(dev, \"Not enough memory for keymap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   keypad_data->rows, keypad_data->cols,\n\t\t\t\t\t   keypad_data->keymap, input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, keypad_data->irq,\n\t\t\t\t\t  omap4_keypad_irq_handler,\n\t\t\t\t\t  omap4_keypad_irq_thread_fn,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"omap4-keypad\", keypad_data);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(keypad_data->input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(dev, true);\n\terror = dev_pm_set_wake_irq(dev, keypad_data->irq);\n\tif (error)\n\t\tdev_warn(dev, \"failed to set up wakeup irq: %d\\n\", error);\n\n\treturn 0;\n}\n\nstatic int omap4_keypad_remove(struct platform_device *pdev)\n{\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id omap_keypad_dt_match[] = {\n\t{ .compatible = \"ti,omap4-keypad\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_keypad_dt_match);\n\nstatic struct platform_driver omap4_keypad_driver = {\n\t.probe\t\t= omap4_keypad_probe,\n\t.remove\t\t= omap4_keypad_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap4-keypad\",\n\t\t.of_match_table = omap_keypad_dt_match,\n\t\t.pm = pm_ptr(&omap4_keypad_pm_ops),\n\t},\n};\nmodule_platform_driver(omap4_keypad_driver);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"OMAP4 Keypad Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap4-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}