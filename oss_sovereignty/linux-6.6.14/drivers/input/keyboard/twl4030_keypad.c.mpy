{
  "module_name": "twl4030_keypad.c",
  "hash_id": "4e5bbaff107bc43d6868e9361315eebf2e13b80fb808b0705f37f2b9dd701d1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/twl4030_keypad.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/twl.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n \n#define TWL4030_MAX_ROWS\t8\t \n#define TWL4030_MAX_COLS\t8\n \n#define TWL4030_ROW_SHIFT\t4\n#define TWL4030_KEYMAP_SIZE\t(TWL4030_MAX_ROWS << TWL4030_ROW_SHIFT)\n\nstruct twl4030_keypad {\n\tunsigned short\tkeymap[TWL4030_KEYMAP_SIZE];\n\tu16\t\tkp_state[TWL4030_MAX_ROWS];\n\tbool\t\tautorepeat;\n\tunsigned int\tn_rows;\n\tunsigned int\tn_cols;\n\tint\t\tirq;\n\n\tstruct device *dbg_dev;\n\tstruct input_dev *input;\n};\n\n \n\n \n#define PTV_PRESCALER\t\t\t4\n\n \n#define KEYP_CTRL\t\t\t0x00\n#define KEYP_DEB\t\t\t0x01\n#define KEYP_LONG_KEY\t\t\t0x02\n#define KEYP_LK_PTV\t\t\t0x03\n#define KEYP_TIMEOUT_L\t\t\t0x04\n#define KEYP_TIMEOUT_H\t\t\t0x05\n#define KEYP_KBC\t\t\t0x06\n#define KEYP_KBR\t\t\t0x07\n#define KEYP_SMS\t\t\t0x08\n#define KEYP_FULL_CODE_7_0\t\t0x09\t \n#define KEYP_FULL_CODE_15_8\t\t0x0a\t \n#define KEYP_FULL_CODE_23_16\t\t0x0b\n#define KEYP_FULL_CODE_31_24\t\t0x0c\n#define KEYP_FULL_CODE_39_32\t\t0x0d\n#define KEYP_FULL_CODE_47_40\t\t0x0e\n#define KEYP_FULL_CODE_55_48\t\t0x0f\n#define KEYP_FULL_CODE_63_56\t\t0x10\n#define KEYP_ISR1\t\t\t0x11\n#define KEYP_IMR1\t\t\t0x12\n#define KEYP_ISR2\t\t\t0x13\n#define KEYP_IMR2\t\t\t0x14\n#define KEYP_SIR\t\t\t0x15\n#define KEYP_EDR\t\t\t0x16\t \n#define KEYP_SIH_CTRL\t\t\t0x17\n\n \n#define KEYP_CTRL_SOFT_NRST\t\tBIT(0)\n#define KEYP_CTRL_SOFTMODEN\t\tBIT(1)\n#define KEYP_CTRL_LK_EN\t\t\tBIT(2)\n#define KEYP_CTRL_TOE_EN\t\tBIT(3)\n#define KEYP_CTRL_TOLE_EN\t\tBIT(4)\n#define KEYP_CTRL_RP_EN\t\t\tBIT(5)\n#define KEYP_CTRL_KBD_ON\t\tBIT(6)\n\n \n#define KEYP_PERIOD_US(t, prescale)\t((t) / (31 << ((prescale) + 1)) - 1)\n\n \n#define KEYP_LK_PTV_PTV_SHIFT\t\t5\n\n \n#define KEYP_IMR1_MIS\t\t\tBIT(3)\n#define KEYP_IMR1_TO\t\t\tBIT(2)\n#define KEYP_IMR1_LK\t\t\tBIT(1)\n#define KEYP_IMR1_KP\t\t\tBIT(0)\n\n \n#define KEYP_EDR_KP_FALLING\t\t0x01\n#define KEYP_EDR_KP_RISING\t\t0x02\n#define KEYP_EDR_KP_BOTH\t\t0x03\n#define KEYP_EDR_LK_FALLING\t\t0x04\n#define KEYP_EDR_LK_RISING\t\t0x08\n#define KEYP_EDR_TO_FALLING\t\t0x10\n#define KEYP_EDR_TO_RISING\t\t0x20\n#define KEYP_EDR_MIS_FALLING\t\t0x40\n#define KEYP_EDR_MIS_RISING\t\t0x80\n\n\n \n\nstatic int twl4030_kpread(struct twl4030_keypad *kp,\n\t\tu8 *data, u32 reg, u8 num_bytes)\n{\n\tint ret = twl_i2c_read(TWL4030_MODULE_KEYPAD, data, reg, num_bytes);\n\n\tif (ret < 0)\n\t\tdev_warn(kp->dbg_dev,\n\t\t\t\"Couldn't read TWL4030: %X - ret %d[%x]\\n\",\n\t\t\t reg, ret, ret);\n\n\treturn ret;\n}\n\nstatic int twl4030_kpwrite_u8(struct twl4030_keypad *kp, u8 data, u32 reg)\n{\n\tint ret = twl_i2c_write_u8(TWL4030_MODULE_KEYPAD, data, reg);\n\n\tif (ret < 0)\n\t\tdev_warn(kp->dbg_dev,\n\t\t\t\"Could not write TWL4030: %X - ret %d[%x]\\n\",\n\t\t\t reg, ret, ret);\n\n\treturn ret;\n}\n\nstatic inline u16 twl4030_col_xlate(struct twl4030_keypad *kp, u8 col)\n{\n\t \n\tif (col == 0xFF)\n\t\treturn 1 << kp->n_cols;\n\telse\n\t\treturn col & ((1 << kp->n_cols) - 1);\n}\n\nstatic int twl4030_read_kp_matrix_state(struct twl4030_keypad *kp, u16 *state)\n{\n\tu8 new_state[TWL4030_MAX_ROWS];\n\tint row;\n\tint ret = twl4030_kpread(kp, new_state,\n\t\t\t\t KEYP_FULL_CODE_7_0, kp->n_rows);\n\tif (ret >= 0)\n\t\tfor (row = 0; row < kp->n_rows; row++)\n\t\t\tstate[row] = twl4030_col_xlate(kp, new_state[row]);\n\n\treturn ret;\n}\n\nstatic bool twl4030_is_in_ghost_state(struct twl4030_keypad *kp, u16 *key_state)\n{\n\tint i;\n\tu16 check = 0;\n\n\tfor (i = 0; i < kp->n_rows; i++) {\n\t\tu16 col = key_state[i];\n\n\t\tif ((col & check) && hweight16(col) > 1)\n\t\t\treturn true;\n\n\t\tcheck |= col;\n\t}\n\n\treturn false;\n}\n\nstatic void twl4030_kp_scan(struct twl4030_keypad *kp, bool release_all)\n{\n\tstruct input_dev *input = kp->input;\n\tu16 new_state[TWL4030_MAX_ROWS];\n\tint col, row;\n\n\tif (release_all) {\n\t\tmemset(new_state, 0, sizeof(new_state));\n\t} else {\n\t\t \n\t\tint ret = twl4030_read_kp_matrix_state(kp, new_state);\n\n\t\tif (ret < 0)\t \n\t\t\treturn;\n\n\t\tif (twl4030_is_in_ghost_state(kp, new_state))\n\t\t\treturn;\n\t}\n\n\t \n\tfor (row = 0; row < kp->n_rows; row++) {\n\t\tint changed = new_state[row] ^ kp->kp_state[row];\n\n\t\tif (!changed)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (col = 0; col < kp->n_cols + 1; col++) {\n\t\t\tint code;\n\n\t\t\tif (!(changed & (1 << col)))\n\t\t\t\tcontinue;\n\n\t\t\tdev_dbg(kp->dbg_dev, \"key [%d:%d] %s\\n\", row, col,\n\t\t\t\t(new_state[row] & (1 << col)) ?\n\t\t\t\t\"press\" : \"release\");\n\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, TWL4030_ROW_SHIFT);\n\t\t\tinput_event(input, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(input, kp->keymap[code],\n\t\t\t\t\t new_state[row] & (1 << col));\n\t\t}\n\t\tkp->kp_state[row] = new_state[row];\n\t}\n\tinput_sync(input);\n}\n\n \nstatic irqreturn_t do_kp_irq(int irq, void *_kp)\n{\n\tstruct twl4030_keypad *kp = _kp;\n\tu8 reg;\n\tint ret;\n\n\t \n\tret = twl4030_kpread(kp, &reg, KEYP_ISR1, 1);\n\n\t \n\tif (ret >= 0 && (reg & KEYP_IMR1_KP))\n\t\ttwl4030_kp_scan(kp, false);\n\telse\n\t\ttwl4030_kp_scan(kp, true);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int twl4030_kp_program(struct twl4030_keypad *kp)\n{\n\tu8 reg;\n\tint i;\n\n\t \n\treg = KEYP_CTRL_SOFT_NRST | KEYP_CTRL_SOFTMODEN\n\t\t| KEYP_CTRL_TOE_EN | KEYP_CTRL_KBD_ON;\n\tif (twl4030_kpwrite_u8(kp, reg, KEYP_CTRL) < 0)\n\t\treturn -EIO;\n\n\t \n\n\t \n\treg = KEYP_EDR_KP_BOTH | KEYP_EDR_TO_RISING;\n\tif (twl4030_kpwrite_u8(kp, reg, KEYP_EDR) < 0)\n\t\treturn -EIO;\n\n\t \n\treg = (PTV_PRESCALER << KEYP_LK_PTV_PTV_SHIFT);\n\tif (twl4030_kpwrite_u8(kp, reg, KEYP_LK_PTV) < 0)\n\t\treturn -EIO;\n\n\t \n\ti = KEYP_PERIOD_US(20000, PTV_PRESCALER);\n\tif (twl4030_kpwrite_u8(kp, i, KEYP_DEB) < 0)\n\t\treturn -EIO;\n\n\t \n\ti = KEYP_PERIOD_US(200000, PTV_PRESCALER);\n\tif (twl4030_kpwrite_u8(kp, (i & 0xFF), KEYP_TIMEOUT_L) < 0)\n\t\treturn -EIO;\n\n\tif (twl4030_kpwrite_u8(kp, (i >> 8), KEYP_TIMEOUT_H) < 0)\n\t\treturn -EIO;\n\n\t \n\treg = TWL4030_SIH_CTRL_COR_MASK | TWL4030_SIH_CTRL_PENDDIS_MASK;\n\tif (twl4030_kpwrite_u8(kp, reg, KEYP_SIH_CTRL) < 0)\n\t\treturn -EIO;\n\n\t \n\tif (twl4030_read_kp_matrix_state(kp, kp->kp_state) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int twl4030_kp_probe(struct platform_device *pdev)\n{\n\tstruct twl4030_keypad_data *pdata = dev_get_platdata(&pdev->dev);\n\tconst struct matrix_keymap_data *keymap_data = NULL;\n\tstruct twl4030_keypad *kp;\n\tstruct input_dev *input;\n\tu8 reg;\n\tint error;\n\n\tkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\n\tif (!kp)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\t \n\tkp->dbg_dev\t\t= &pdev->dev;\n\tkp->input\t\t= input;\n\n\t \n\tinput->name\t\t= \"TWL4030 Keypad\";\n\tinput->phys\t\t= \"twl4030_keypad/input0\";\n\n\tinput->id.bustype\t= BUS_HOST;\n\tinput->id.vendor\t= 0x0001;\n\tinput->id.product\t= 0x0001;\n\tinput->id.version\t= 0x0003;\n\n\tif (pdata) {\n\t\tif (!pdata->rows || !pdata->cols || !pdata->keymap_data) {\n\t\t\tdev_err(&pdev->dev, \"Missing platform_data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkp->n_rows = pdata->rows;\n\t\tkp->n_cols = pdata->cols;\n\t\tkp->autorepeat = pdata->rep;\n\t\tkeymap_data = pdata->keymap_data;\n\t} else {\n\t\terror = matrix_keypad_parse_properties(&pdev->dev, &kp->n_rows,\n\t\t\t\t\t\t       &kp->n_cols);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tkp->autorepeat = true;\n\t}\n\n\tif (kp->n_rows > TWL4030_MAX_ROWS || kp->n_cols > TWL4030_MAX_COLS) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Invalid rows/cols amount specified in platform/devicetree data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkp->irq = platform_get_irq(pdev, 0);\n\tif (kp->irq < 0)\n\t\treturn kp->irq;\n\n\terror = matrix_keypad_build_keymap(keymap_data, NULL,\n\t\t\t\t\t   TWL4030_MAX_ROWS,\n\t\t\t\t\t   1 << TWL4030_ROW_SHIFT,\n\t\t\t\t\t   kp->keymap, input);\n\tif (error) {\n\t\tdev_err(kp->dbg_dev, \"Failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\t \n\tif (kp->autorepeat)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(kp->dbg_dev,\n\t\t\t\"Unable to register twl4030 keypad device\\n\");\n\t\treturn error;\n\t}\n\n\terror = twl4030_kp_program(kp);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = devm_request_threaded_irq(&pdev->dev, kp->irq, NULL, do_kp_irq,\n\t\t\t\t\t  0, pdev->name, kp);\n\tif (error) {\n\t\tdev_info(kp->dbg_dev, \"request_irq failed for irq no=%d: %d\\n\",\n\t\t\tkp->irq, error);\n\t\treturn error;\n\t}\n\n\t \n\treg = (u8) ~(KEYP_IMR1_KP | KEYP_IMR1_TO);\n\tif (twl4030_kpwrite_u8(kp, reg, KEYP_IMR1)) {\n\t\t \n\t\t(void) twl4030_kpwrite_u8(kp, 0xff, KEYP_IMR1);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id twl4030_keypad_dt_match_table[] = {\n\t{ .compatible = \"ti,twl4030-keypad\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, twl4030_keypad_dt_match_table);\n#endif\n\n \n\nstatic struct platform_driver twl4030_kp_driver = {\n\t.probe\t\t= twl4030_kp_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"twl4030_keypad\",\n\t\t.of_match_table = of_match_ptr(twl4030_keypad_dt_match_table),\n\t},\n};\nmodule_platform_driver(twl4030_kp_driver);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"TWL4030 Keypad Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:twl4030_keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}