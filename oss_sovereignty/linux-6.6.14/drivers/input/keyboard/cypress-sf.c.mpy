{
  "module_name": "cypress-sf.c",
  "hash_id": "86b2276417e2f120973bb7de3d09e6c7b208e6fa0881e3f54dedea5a695c1aad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/cypress-sf.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n\n#define CYPRESS_SF_DEV_NAME \"cypress-sf\"\n\n#define CYPRESS_SF_REG_BUTTON_STATUS\t0x4a\n\nstruct cypress_sf_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct regulator_bulk_data regulators[2];\n\tu32 *keycodes;\n\tunsigned long keystates;\n\tint num_keys;\n};\n\nstatic irqreturn_t cypress_sf_irq_handler(int irq, void *devid)\n{\n\tstruct cypress_sf_data *touchkey = devid;\n\tunsigned long keystates, changed;\n\tbool new_state;\n\tint val, key;\n\n\tval = i2c_smbus_read_byte_data(touchkey->client,\n\t\t\t\t       CYPRESS_SF_REG_BUTTON_STATUS);\n\tif (val < 0) {\n\t\tdev_err(&touchkey->client->dev,\n\t\t\t\"Failed to read button status: %d\", val);\n\t\treturn IRQ_NONE;\n\t}\n\tkeystates = val;\n\n\tbitmap_xor(&changed, &keystates, &touchkey->keystates,\n\t\t   touchkey->num_keys);\n\n\tfor_each_set_bit(key, &changed, touchkey->num_keys) {\n\t\tnew_state = keystates & BIT(key);\n\t\tdev_dbg(&touchkey->client->dev,\n\t\t\t\"Key %d changed to %d\", key, new_state);\n\t\tinput_report_key(touchkey->input_dev,\n\t\t\t\t touchkey->keycodes[key], new_state);\n\t}\n\n\tinput_sync(touchkey->input_dev);\n\ttouchkey->keystates = keystates;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void cypress_sf_disable_regulators(void *arg)\n{\n\tstruct cypress_sf_data *touchkey = arg;\n\n\tregulator_bulk_disable(ARRAY_SIZE(touchkey->regulators),\n\t\t\t       touchkey->regulators);\n}\n\nstatic int cypress_sf_probe(struct i2c_client *client)\n{\n\tstruct cypress_sf_data *touchkey;\n\tint key, error;\n\n\ttouchkey = devm_kzalloc(&client->dev, sizeof(*touchkey), GFP_KERNEL);\n\tif (!touchkey)\n\t\treturn -ENOMEM;\n\n\ttouchkey->client = client;\n\ti2c_set_clientdata(client, touchkey);\n\n\ttouchkey->regulators[0].supply = \"vdd\";\n\ttouchkey->regulators[1].supply = \"avdd\";\n\n\terror = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t\tARRAY_SIZE(touchkey->regulators),\n\t\t\t\t\ttouchkey->regulators);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to get regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ttouchkey->num_keys = device_property_read_u32_array(&client->dev,\n\t\t\t\t\t\t\t    \"linux,keycodes\",\n\t\t\t\t\t\t\t    NULL, 0);\n\tif (touchkey->num_keys < 0) {\n\t\t \n\t\ttouchkey->num_keys = 2;\n\t}\n\n\ttouchkey->keycodes = devm_kcalloc(&client->dev,\n\t\t\t\t\t  touchkey->num_keys,\n\t\t\t\t\t  sizeof(*touchkey->keycodes),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!touchkey->keycodes)\n\t\treturn -ENOMEM;\n\n\terror = device_property_read_u32_array(&client->dev, \"linux,keycodes\",\n\t\t\t\t\t       touchkey->keycodes,\n\t\t\t\t\t       touchkey->num_keys);\n\n\tif (error) {\n\t\tdev_warn(&client->dev,\n\t\t\t \"Failed to read keycodes: %d, using defaults\\n\",\n\t\t\t error);\n\n\t\t \n\t\ttouchkey->keycodes[0] = KEY_BACK;\n\t\ttouchkey->keycodes[1] = KEY_MENU;\n\t}\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(touchkey->regulators),\n\t\t\t\t      touchkey->regulators);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enable regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t cypress_sf_disable_regulators,\n\t\t\t\t\t touchkey);\n\tif (error)\n\t\treturn error;\n\n\ttouchkey->input_dev = devm_input_allocate_device(&client->dev);\n\tif (!touchkey->input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttouchkey->input_dev->name = CYPRESS_SF_DEV_NAME;\n\ttouchkey->input_dev->id.bustype = BUS_I2C;\n\n\tfor (key = 0; key < touchkey->num_keys; ++key)\n\t\tinput_set_capability(touchkey->input_dev,\n\t\t\t\t     EV_KEY, touchkey->keycodes[key]);\n\n\terror = input_register_device(touchkey->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, cypress_sf_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  CYPRESS_SF_DEV_NAME, touchkey);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register threaded irq: %d\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n};\n\nstatic int cypress_sf_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cypress_sf_data *touchkey = i2c_get_clientdata(client);\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\terror = regulator_bulk_disable(ARRAY_SIZE(touchkey->regulators),\n\t\t\t\t       touchkey->regulators);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to disable regulators: %d\", error);\n\t\tenable_irq(client->irq);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int cypress_sf_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cypress_sf_data *touchkey = i2c_get_clientdata(client);\n\tint error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(touchkey->regulators),\n\t\t\t\t      touchkey->regulators);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to enable regulators: %d\", error);\n\t\treturn error;\n\t}\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cypress_sf_pm_ops,\n\t\t\t\tcypress_sf_suspend, cypress_sf_resume);\n\nstatic struct i2c_device_id cypress_sf_id_table[] = {\n\t{ CYPRESS_SF_DEV_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cypress_sf_id_table);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cypress_sf_of_match[] = {\n\t{ .compatible = \"cypress,sf3155\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cypress_sf_of_match);\n#endif\n\nstatic struct i2c_driver cypress_sf_driver = {\n\t.driver = {\n\t\t.name = CYPRESS_SF_DEV_NAME,\n\t\t.pm = pm_sleep_ptr(&cypress_sf_pm_ops),\n\t\t.of_match_table = of_match_ptr(cypress_sf_of_match),\n\t},\n\t.id_table = cypress_sf_id_table,\n\t.probe = cypress_sf_probe,\n};\nmodule_i2c_driver(cypress_sf_driver);\n\nMODULE_AUTHOR(\"Yassine Oudjana <y.oudjana@protonmail.com>\");\nMODULE_DESCRIPTION(\"Cypress StreetFighter Touchkey Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}