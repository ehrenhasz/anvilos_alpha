{
  "module_name": "clps711x-keypad.c",
  "hash_id": "19efb6193f69e48863ddc809d28899793100e1acd29413a512bd1282765ad375",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/clps711x-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/clps711x.h>\n\n#define CLPS711X_KEYPAD_COL_COUNT\t8\n\nstruct clps711x_gpio_data {\n\tstruct gpio_desc *desc;\n\tDECLARE_BITMAP(last_state, CLPS711X_KEYPAD_COL_COUNT);\n};\n\nstruct clps711x_keypad_data {\n\tstruct regmap\t\t\t*syscon;\n\tint\t\t\t\trow_count;\n\tunsigned int\t\t\trow_shift;\n\tstruct clps711x_gpio_data\t*gpio_data;\n};\n\nstatic void clps711x_keypad_poll(struct input_dev *input)\n{\n\tconst unsigned short *keycodes = input->keycode;\n\tstruct clps711x_keypad_data *priv = input_get_drvdata(input);\n\tbool sync = false;\n\tint col, row;\n\n\tfor (col = 0; col < CLPS711X_KEYPAD_COL_COUNT; col++) {\n\t\t \n\t\tregmap_update_bits(priv->syscon, SYSCON_OFFSET,\n\t\t\t\t   SYSCON1_KBDSCAN_MASK,\n\t\t\t\t   SYSCON1_KBDSCAN(8 + col));\n\n\t\t \n\t\tfor (row = 0; row < priv->row_count; row++) {\n\t\t\tstruct clps711x_gpio_data *data = &priv->gpio_data[row];\n\t\t\tbool state, state1;\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\tstate = gpiod_get_value_cansleep(data->desc);\n\t\t\t\tcond_resched();\n\t\t\t\tstate1 = gpiod_get_value_cansleep(data->desc);\n\t\t\t} while (state != state1);\n\n\t\t\tif (test_bit(col, data->last_state) != state) {\n\t\t\t\tint code = MATRIX_SCAN_CODE(row, col,\n\t\t\t\t\t\t\t    priv->row_shift);\n\n\t\t\t\tif (state) {\n\t\t\t\t\tset_bit(col, data->last_state);\n\t\t\t\t\tinput_event(input,\n\t\t\t\t\t\t    EV_MSC, MSC_SCAN, code);\n\t\t\t\t} else {\n\t\t\t\t\tclear_bit(col, data->last_state);\n\t\t\t\t}\n\n\t\t\t\tif (keycodes[code])\n\t\t\t\t\tinput_report_key(input,\n\t\t\t\t\t\t\t keycodes[code], state);\n\t\t\t\tsync = true;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(priv->syscon, SYSCON_OFFSET,\n\t\t\t\t   SYSCON1_KBDSCAN_MASK, SYSCON1_KBDSCAN(1));\n\t}\n\n\tif (sync)\n\t\tinput_sync(input);\n}\n\nstatic int clps711x_keypad_probe(struct platform_device *pdev)\n{\n\tstruct clps711x_keypad_data *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct input_dev *input;\n\tu32 poll_interval;\n\tint i, err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->syscon = syscon_regmap_lookup_by_phandle(dev->of_node, \"syscon\");\n\tif (IS_ERR(priv->syscon))\n\t\treturn PTR_ERR(priv->syscon);\n\n\tpriv->row_count = gpiod_count(dev, \"row\");\n\tif (priv->row_count < 1)\n\t\treturn -EINVAL;\n\n\tpriv->gpio_data = devm_kcalloc(dev,\n\t\t\t\tpriv->row_count, sizeof(*priv->gpio_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->gpio_data)\n\t\treturn -ENOMEM;\n\n\tpriv->row_shift = get_count_order(CLPS711X_KEYPAD_COL_COUNT);\n\n\tfor (i = 0; i < priv->row_count; i++) {\n\t\tstruct clps711x_gpio_data *data = &priv->gpio_data[i];\n\n\t\tdata->desc = devm_gpiod_get_index(dev, \"row\", i, GPIOD_IN);\n\t\tif (IS_ERR(data->desc))\n\t\t\treturn PTR_ERR(data->desc);\n\t}\n\n\terr = device_property_read_u32(dev, \"poll-interval\", &poll_interval);\n\tif (err)\n\t\treturn err;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(input, priv);\n\n\tinput->name\t\t= pdev->name;\n\tinput->dev.parent\t= dev;\n\tinput->id.bustype\t= BUS_HOST;\n\tinput->id.vendor\t= 0x0001;\n\tinput->id.product\t= 0x0001;\n\tinput->id.version\t= 0x0100;\n\n\terr = matrix_keypad_build_keymap(NULL, NULL, priv->row_count,\n\t\t\t\t\t CLPS711X_KEYPAD_COL_COUNT,\n\t\t\t\t\t NULL, input);\n\tif (err)\n\t\treturn err;\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\tif (device_property_read_bool(dev, \"autorepeat\"))\n\t\t__set_bit(EV_REP, input->evbit);\n\n\t \n\tregmap_update_bits(priv->syscon, SYSCON_OFFSET, SYSCON1_KBDSCAN_MASK,\n\t\t\t   SYSCON1_KBDSCAN(1));\n\n\n\terr = input_setup_polling(input, clps711x_keypad_poll);\n\tif (err)\n\t\treturn err;\n\n\tinput_set_poll_interval(input, poll_interval);\n\n\terr = input_register_device(input);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id clps711x_keypad_of_match[] = {\n\t{ .compatible = \"cirrus,ep7209-keypad\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clps711x_keypad_of_match);\n\nstatic struct platform_driver clps711x_keypad_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"clps711x-keypad\",\n\t\t.of_match_table\t= clps711x_keypad_of_match,\n\t},\n\t.probe\t= clps711x_keypad_probe,\n};\nmodule_platform_driver(clps711x_keypad_driver);\n\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CLPS711X Keypad driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}