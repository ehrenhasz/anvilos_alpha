{
  "module_name": "adp5588-keys.c",
  "hash_id": "1e99beb2ccbf3268d61be0fa9eea82bb99c96ceed8595d34464155036081c579",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/adp5588-keys.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/timekeeping.h>\n\n#define DEV_ID 0x00\t\t \n#define CFG 0x01\t\t \n#define INT_STAT 0x02\t\t \n#define KEY_LCK_EC_STAT 0x03\t \n#define KEY_EVENTA 0x04\t\t \n#define KEY_EVENTB 0x05\t\t \n#define KEY_EVENTC 0x06\t\t \n#define KEY_EVENTD 0x07\t\t \n#define KEY_EVENTE 0x08\t\t \n#define KEY_EVENTF 0x09\t\t \n#define KEY_EVENTG 0x0A\t\t \n#define KEY_EVENTH 0x0B\t\t \n#define KEY_EVENTI 0x0C\t\t \n#define KEY_EVENTJ 0x0D\t\t \n#define KP_LCK_TMR 0x0E\t\t \n#define UNLOCK1 0x0F\t\t \n#define UNLOCK2 0x10\t\t \n#define GPIO_INT_STAT1 0x11\t \n#define GPIO_INT_STAT2 0x12\t \n#define GPIO_INT_STAT3 0x13\t \n#define GPIO_DAT_STAT1 0x14\t \n#define GPIO_DAT_STAT2 0x15\t \n#define GPIO_DAT_STAT3 0x16\t \n#define GPIO_DAT_OUT1 0x17\t \n#define GPIO_DAT_OUT2 0x18\t \n#define GPIO_DAT_OUT3 0x19\t \n#define GPIO_INT_EN1 0x1A\t \n#define GPIO_INT_EN2 0x1B\t \n#define GPIO_INT_EN3 0x1C\t \n#define KP_GPIO1 0x1D\t\t \n#define KP_GPIO2 0x1E\t\t \n#define KP_GPIO3 0x1F\t\t \n#define GPI_EM1 0x20\t\t \n#define GPI_EM2 0x21\t\t \n#define GPI_EM3 0x22\t\t \n#define GPIO_DIR1 0x23\t\t \n#define GPIO_DIR2 0x24\t\t \n#define GPIO_DIR3 0x25\t\t \n#define GPIO_INT_LVL1 0x26\t \n#define GPIO_INT_LVL2 0x27\t \n#define GPIO_INT_LVL3 0x28\t \n#define DEBOUNCE_DIS1 0x29\t \n#define DEBOUNCE_DIS2 0x2A\t \n#define DEBOUNCE_DIS3 0x2B\t \n#define GPIO_PULL1 0x2C\t\t \n#define GPIO_PULL2 0x2D\t\t \n#define GPIO_PULL3 0x2E\t\t \n#define CMP_CFG_STAT 0x30\t \n#define CMP_CONFG_SENS1 0x31\t \n#define CMP_CONFG_SENS2 0x32\t \n#define CMP1_LVL2_TRIP 0x33\t \n#define CMP1_LVL2_HYS 0x34\t \n#define CMP1_LVL3_TRIP 0x35\t \n#define CMP1_LVL3_HYS 0x36\t \n#define CMP2_LVL2_TRIP 0x37\t \n#define CMP2_LVL2_HYS 0x38\t \n#define CMP2_LVL3_TRIP 0x39\t \n#define CMP2_LVL3_HYS 0x3A\t \n#define CMP1_ADC_DAT_R1 0x3B\t \n#define CMP1_ADC_DAT_R2 0x3C\t \n#define CMP2_ADC_DAT_R1 0x3D\t \n#define CMP2_ADC_DAT_R2 0x3E\t \n\n#define ADP5588_DEVICE_ID_MASK\t0xF\n\n  \n#define ADP5588_AUTO_INC\tBIT(7)\n#define ADP5588_GPIEM_CFG\tBIT(6)\n#define ADP5588_OVR_FLOW_M\tBIT(5)\n#define ADP5588_INT_CFG\t\tBIT(4)\n#define ADP5588_OVR_FLOW_IEN\tBIT(3)\n#define ADP5588_K_LCK_IM\tBIT(2)\n#define ADP5588_GPI_IEN\t\tBIT(1)\n#define ADP5588_KE_IEN\t\tBIT(0)\n\n \n#define ADP5588_CMP2_INT\tBIT(5)\n#define ADP5588_CMP1_INT\tBIT(4)\n#define ADP5588_OVR_FLOW_INT\tBIT(3)\n#define ADP5588_K_LCK_INT\tBIT(2)\n#define ADP5588_GPI_INT\t\tBIT(1)\n#define ADP5588_KE_INT\t\tBIT(0)\n\n \n#define ADP5588_K_LCK_EN\tBIT(6)\n#define ADP5588_LCK21\t\t0x30\n#define ADP5588_KEC\t\tGENMASK(3, 0)\n\n#define ADP5588_MAXGPIO\t\t18\n#define ADP5588_BANK(offs)\t((offs) >> 3)\n#define ADP5588_BIT(offs)\t(1u << ((offs) & 0x7))\n\n \n\n \n#define ADP5588_KEYMAPSIZE 128\n\n#define GPI_PIN_ROW0 97\n#define GPI_PIN_ROW1 98\n#define GPI_PIN_ROW2 99\n#define GPI_PIN_ROW3 100\n#define GPI_PIN_ROW4 101\n#define GPI_PIN_ROW5 102\n#define GPI_PIN_ROW6 103\n#define GPI_PIN_ROW7 104\n#define GPI_PIN_COL0 105\n#define GPI_PIN_COL1 106\n#define GPI_PIN_COL2 107\n#define GPI_PIN_COL3 108\n#define GPI_PIN_COL4 109\n#define GPI_PIN_COL5 110\n#define GPI_PIN_COL6 111\n#define GPI_PIN_COL7 112\n#define GPI_PIN_COL8 113\n#define GPI_PIN_COL9 114\n\n#define GPI_PIN_ROW_BASE GPI_PIN_ROW0\n#define GPI_PIN_ROW_END GPI_PIN_ROW7\n#define GPI_PIN_COL_BASE GPI_PIN_COL0\n#define GPI_PIN_COL_END GPI_PIN_COL9\n\n#define GPI_PIN_BASE GPI_PIN_ROW_BASE\n#define GPI_PIN_END GPI_PIN_COL_END\n\n#define ADP5588_ROWS_MAX (GPI_PIN_ROW7 - GPI_PIN_ROW0 + 1)\n#define ADP5588_COLS_MAX (GPI_PIN_COL9 - GPI_PIN_COL0 + 1)\n\n#define ADP5588_GPIMAPSIZE_MAX (GPI_PIN_END - GPI_PIN_BASE + 1)\n\n \n#define KEY_EV_PRESSED\t\tBIT(7)\n#define KEY_EV_MASK\t\tGENMASK(6, 0)\n\n#define KP_SEL(x)\t\t(BIT(x) - 1)\t \n\n#define KEYP_MAX_EVENT\t\t10\n\n \n#define WA_DELAYED_READOUT_REVID(rev)\t\t((rev) < 4)\n#define WA_DELAYED_READOUT_TIME\t\t\t25\n\n#define ADP5588_INVALID_HWIRQ\t(~0UL)\n\nstruct adp5588_kpad {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tktime_t irq_time;\n\tunsigned long delay;\n\tu32 row_shift;\n\tu32 rows;\n\tu32 cols;\n\tu32 unlock_keys[2];\n\tint nkeys_unlock;\n\tunsigned short keycode[ADP5588_KEYMAPSIZE];\n\tunsigned char gpiomap[ADP5588_MAXGPIO];\n\tstruct gpio_chip gc;\n\tstruct mutex gpio_lock;\t \n\tu8 dat_out[3];\n\tu8 dir[3];\n\tu8 int_en[3];\n\tu8 irq_mask[3];\n\tu8 pull_dis[3];\n};\n\nstatic int adp5588_read(struct i2c_client *client, u8 reg)\n{\n\tint ret = i2c_smbus_read_byte_data(client, reg);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Read Error\\n\");\n\n\treturn ret;\n}\n\nstatic int adp5588_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\nstatic int adp5588_gpio_get_value(struct gpio_chip *chip, unsigned int off)\n{\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\n\tunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\n\tint val;\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tif (kpad->dir[bank] & bit)\n\t\tval = kpad->dat_out[bank];\n\telse\n\t\tval = adp5588_read(kpad->client, GPIO_DAT_STAT1 + bank);\n\n\tmutex_unlock(&kpad->gpio_lock);\n\n\treturn !!(val & bit);\n}\n\nstatic void adp5588_gpio_set_value(struct gpio_chip *chip,\n\t\t\t\t   unsigned int off, int val)\n{\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\n\tunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tif (val)\n\t\tkpad->dat_out[bank] |= bit;\n\telse\n\t\tkpad->dat_out[bank] &= ~bit;\n\n\tadp5588_write(kpad->client, GPIO_DAT_OUT1 + bank, kpad->dat_out[bank]);\n\n\tmutex_unlock(&kpad->gpio_lock);\n}\n\nstatic int adp5588_gpio_set_config(struct gpio_chip *chip,  unsigned int off,\n\t\t\t\t   unsigned long config)\n{\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\n\tunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\n\tbool pull_disable;\n\tint ret;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tpull_disable = false;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tpull_disable = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tif (pull_disable)\n\t\tkpad->pull_dis[bank] |= bit;\n\telse\n\t\tkpad->pull_dis[bank] &= bit;\n\n\tret = adp5588_write(kpad->client, GPIO_PULL1 + bank,\n\t\t\t    kpad->pull_dis[bank]);\n\n\tmutex_unlock(&kpad->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int adp5588_gpio_direction_input(struct gpio_chip *chip, unsigned int off)\n{\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\n\tunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\n\tint ret;\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tkpad->dir[bank] &= ~bit;\n\tret = adp5588_write(kpad->client, GPIO_DIR1 + bank, kpad->dir[bank]);\n\n\tmutex_unlock(&kpad->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int adp5588_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int off, int val)\n{\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\n\tunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\n\tint ret;\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tkpad->dir[bank] |= bit;\n\n\tif (val)\n\t\tkpad->dat_out[bank] |= bit;\n\telse\n\t\tkpad->dat_out[bank] &= ~bit;\n\n\tret = adp5588_write(kpad->client, GPIO_DAT_OUT1 + bank,\n\t\t\t    kpad->dat_out[bank]);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = adp5588_write(kpad->client, GPIO_DIR1 + bank, kpad->dir[bank]);\n\nout_unlock:\n\tmutex_unlock(&kpad->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int adp5588_build_gpiomap(struct adp5588_kpad *kpad)\n{\n\tbool pin_used[ADP5588_MAXGPIO];\n\tint n_unused = 0;\n\tint i;\n\n\tmemset(pin_used, 0, sizeof(pin_used));\n\n\tfor (i = 0; i < kpad->rows; i++)\n\t\tpin_used[i] = true;\n\n\tfor (i = 0; i < kpad->cols; i++)\n\t\tpin_used[i + GPI_PIN_COL_BASE - GPI_PIN_BASE] = true;\n\n\tfor (i = 0; i < ADP5588_MAXGPIO; i++)\n\t\tif (!pin_used[i])\n\t\t\tkpad->gpiomap[n_unused++] = i;\n\n\treturn n_unused;\n}\n\nstatic void adp5588_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(gc);\n\n\tmutex_lock(&kpad->gpio_lock);\n}\n\nstatic void adp5588_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(gc);\n\tint i;\n\n\tfor (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {\n\t\tif (kpad->int_en[i] ^ kpad->irq_mask[i]) {\n\t\t\tkpad->int_en[i] = kpad->irq_mask[i];\n\t\t\tadp5588_write(kpad->client, GPI_EM1 + i, kpad->int_en[i]);\n\t\t}\n\t}\n\n\tmutex_unlock(&kpad->gpio_lock);\n}\n\nstatic void adp5588_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long real_irq = kpad->gpiomap[hwirq];\n\n\tkpad->irq_mask[ADP5588_BANK(real_irq)] &= ~ADP5588_BIT(real_irq);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void adp5588_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct adp5588_kpad *kpad = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long real_irq = kpad->gpiomap[hwirq];\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tkpad->irq_mask[ADP5588_BANK(real_irq)] |= ADP5588_BIT(real_irq);\n}\n\nstatic int adp5588_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tif (!(type & IRQ_TYPE_EDGE_BOTH))\n\t\treturn -EINVAL;\n\n\tirq_set_handler_locked(d, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip adp5588_irq_chip = {\n\t.name = \"adp5588\",\n\t.irq_mask = adp5588_irq_mask,\n\t.irq_unmask = adp5588_irq_unmask,\n\t.irq_bus_lock = adp5588_irq_bus_lock,\n\t.irq_bus_sync_unlock = adp5588_irq_bus_sync_unlock,\n\t.irq_set_type = adp5588_irq_set_type,\n\t.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int adp5588_gpio_add(struct adp5588_kpad *kpad)\n{\n\tstruct device *dev = &kpad->client->dev;\n\tstruct gpio_irq_chip *girq;\n\tint i, error;\n\n\tkpad->gc.ngpio = adp5588_build_gpiomap(kpad);\n\tif (kpad->gc.ngpio == 0) {\n\t\tdev_info(dev, \"No unused gpios left to export\\n\");\n\t\treturn 0;\n\t}\n\n\tkpad->gc.parent = &kpad->client->dev;\n\tkpad->gc.direction_input = adp5588_gpio_direction_input;\n\tkpad->gc.direction_output = adp5588_gpio_direction_output;\n\tkpad->gc.get = adp5588_gpio_get_value;\n\tkpad->gc.set = adp5588_gpio_set_value;\n\tkpad->gc.set_config = adp5588_gpio_set_config;\n\tkpad->gc.can_sleep = 1;\n\n\tkpad->gc.base = -1;\n\tkpad->gc.label = kpad->client->name;\n\tkpad->gc.owner = THIS_MODULE;\n\n\tgirq = &kpad->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &adp5588_irq_chip);\n\tgirq->handler = handle_bad_irq;\n\tgirq->threaded = true;\n\n\tmutex_init(&kpad->gpio_lock);\n\n\terror = devm_gpiochip_add_data(dev, &kpad->gc, kpad);\n\tif (error) {\n\t\tdev_err(dev, \"gpiochip_add failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {\n\t\tkpad->dat_out[i] = adp5588_read(kpad->client,\n\t\t\t\t\t\tGPIO_DAT_OUT1 + i);\n\t\tkpad->dir[i] = adp5588_read(kpad->client, GPIO_DIR1 + i);\n\t\tkpad->pull_dis[i] = adp5588_read(kpad->client, GPIO_PULL1 + i);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long adp5588_gpiomap_get_hwirq(struct device *dev,\n\t\t\t\t\t       const u8 *map, unsigned int gpio,\n\t\t\t\t\t       unsigned int ngpios)\n{\n\tunsigned int hwirq;\n\n\tfor (hwirq = 0; hwirq < ngpios; hwirq++)\n\t\tif (map[hwirq] == gpio)\n\t\t\treturn hwirq;\n\n\t \n\tdev_warn_ratelimited(dev, \"could not find the hwirq for gpio(%u)\\n\", gpio);\n\n\treturn ADP5588_INVALID_HWIRQ;\n}\n\nstatic void adp5588_gpio_irq_handle(struct adp5588_kpad *kpad, int key_val,\n\t\t\t\t    int key_press)\n{\n\tunsigned int irq, gpio = key_val - GPI_PIN_BASE, irq_type;\n\tstruct i2c_client *client = kpad->client;\n\tstruct irq_data *irqd;\n\tunsigned long hwirq;\n\n\thwirq = adp5588_gpiomap_get_hwirq(&client->dev, kpad->gpiomap,\n\t\t\t\t\t  gpio, kpad->gc.ngpio);\n\tif (hwirq == ADP5588_INVALID_HWIRQ) {\n\t\tdev_err(&client->dev, \"Could not get hwirq for key(%u)\\n\", key_val);\n\t\treturn;\n\t}\n\n\tirq = irq_find_mapping(kpad->gc.irq.domain, hwirq);\n\tif (!irq)\n\t\treturn;\n\n\tirqd = irq_get_irq_data(irq);\n\tif (!irqd) {\n\t\tdev_err(&client->dev, \"Could not get irq(%u) data\\n\", irq);\n\t\treturn;\n\t}\n\n\tirq_type = irqd_get_trigger_type(irqd);\n\n\t \n\tif ((irq_type & IRQ_TYPE_EDGE_RISING && !key_press) ||\n\t    (irq_type & IRQ_TYPE_EDGE_FALLING && key_press))\n\t\thandle_nested_irq(irq);\n}\n\nstatic void adp5588_report_events(struct adp5588_kpad *kpad, int ev_cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < ev_cnt; i++) {\n\t\tint key = adp5588_read(kpad->client, KEY_EVENTA + i);\n\t\tint key_val = key & KEY_EV_MASK;\n\t\tint key_press = key & KEY_EV_PRESSED;\n\n\t\tif (key_val >= GPI_PIN_BASE && key_val <= GPI_PIN_END) {\n\t\t\t \n\t\t\tadp5588_gpio_irq_handle(kpad, key_val, key_press);\n\t\t} else {\n\t\t\tint row = (key_val - 1) / ADP5588_COLS_MAX;\n\t\t\tint col =  (key_val - 1) % ADP5588_COLS_MAX;\n\t\t\tint code = MATRIX_SCAN_CODE(row, col, kpad->row_shift);\n\n\t\t\tdev_dbg_ratelimited(&kpad->client->dev,\n\t\t\t\t\t    \"report key(%d) r(%d) c(%d) code(%d)\\n\",\n\t\t\t\t\t    key_val, row, col, kpad->keycode[code]);\n\n\t\t\tinput_report_key(kpad->input,\n\t\t\t\t\t kpad->keycode[code], key_press);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t adp5588_hard_irq(int irq, void *handle)\n{\n\tstruct adp5588_kpad *kpad = handle;\n\n\tkpad->irq_time = ktime_get();\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t adp5588_thread_irq(int irq, void *handle)\n{\n\tstruct adp5588_kpad *kpad = handle;\n\tstruct i2c_client *client = kpad->client;\n\tktime_t target_time, now;\n\tunsigned long delay;\n\tint status, ev_cnt;\n\n\t \n\tif (kpad->delay) {\n\t\ttarget_time = ktime_add_ms(kpad->irq_time, kpad->delay);\n\t\tnow = ktime_get();\n\t\tif (ktime_before(now, target_time)) {\n\t\t\tdelay = ktime_to_us(ktime_sub(target_time, now));\n\t\t\tusleep_range(delay, delay + 1000);\n\t\t}\n\t}\n\n\tstatus = adp5588_read(client, INT_STAT);\n\n\tif (status & ADP5588_OVR_FLOW_INT)\t \n\t\tdev_err(&client->dev, \"Event Overflow Error\\n\");\n\n\tif (status & ADP5588_KE_INT) {\n\t\tev_cnt = adp5588_read(client, KEY_LCK_EC_STAT) & ADP5588_KEC;\n\t\tif (ev_cnt) {\n\t\t\tadp5588_report_events(kpad, ev_cnt);\n\t\t\tinput_sync(kpad->input);\n\t\t}\n\t}\n\n\tadp5588_write(client, INT_STAT, status);  \n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adp5588_setup(struct adp5588_kpad *kpad)\n{\n\tstruct i2c_client *client = kpad->client;\n\tint i, ret;\n\n\tret = adp5588_write(client, KP_GPIO1, KP_SEL(kpad->rows));\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp5588_write(client, KP_GPIO2, KP_SEL(kpad->cols) & 0xFF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adp5588_write(client, KP_GPIO3, KP_SEL(kpad->cols) >> 8);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < kpad->nkeys_unlock; i++) {\n\t\tret = adp5588_write(client, UNLOCK1 + i, kpad->unlock_keys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (kpad->nkeys_unlock) {\n\t\tret = adp5588_write(client, KEY_LCK_EC_STAT, ADP5588_K_LCK_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < KEYP_MAX_EVENT; i++) {\n\t\tret = adp5588_read(client, KEY_EVENTA);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = adp5588_write(client, INT_STAT,\n\t\t\t    ADP5588_CMP2_INT | ADP5588_CMP1_INT |\n\t\t\t    ADP5588_OVR_FLOW_INT | ADP5588_K_LCK_INT |\n\t\t\t    ADP5588_GPI_INT | ADP5588_KE_INT);  \n\tif (ret)\n\t\treturn ret;\n\n\treturn adp5588_write(client, CFG, ADP5588_INT_CFG |\n\t\t\t     ADP5588_OVR_FLOW_IEN | ADP5588_KE_IEN);\n}\n\nstatic int adp5588_fw_parse(struct adp5588_kpad *kpad)\n{\n\tstruct i2c_client *client = kpad->client;\n\tint ret, i;\n\n\tret = matrix_keypad_parse_properties(&client->dev, &kpad->rows,\n\t\t\t\t\t     &kpad->cols);\n\tif (ret)\n\t\treturn ret;\n\n\tif (kpad->rows > ADP5588_ROWS_MAX || kpad->cols > ADP5588_COLS_MAX) {\n\t\tdev_err(&client->dev, \"Invalid nr of rows(%u) or cols(%u)\\n\",\n\t\t\tkpad->rows, kpad->cols);\n\t\treturn -EINVAL;\n\t}\n\n\tret = matrix_keypad_build_keymap(NULL, NULL, kpad->rows, kpad->cols,\n\t\t\t\t\t kpad->keycode, kpad->input);\n\tif (ret)\n\t\treturn ret;\n\n\tkpad->row_shift = get_count_order(kpad->cols);\n\n\tif (device_property_read_bool(&client->dev, \"autorepeat\"))\n\t\t__set_bit(EV_REP, kpad->input->evbit);\n\n\tkpad->nkeys_unlock = device_property_count_u32(&client->dev,\n\t\t\t\t\t\t       \"adi,unlock-keys\");\n\tif (kpad->nkeys_unlock <= 0) {\n\t\t \n\t\tkpad->nkeys_unlock = 0;\n\t\treturn 0;\n\t}\n\n\tif (kpad->nkeys_unlock > ARRAY_SIZE(kpad->unlock_keys)) {\n\t\tdev_err(&client->dev, \"number of unlock keys(%d) > (%zu)\\n\",\n\t\t\tkpad->nkeys_unlock, ARRAY_SIZE(kpad->unlock_keys));\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32_array(&client->dev, \"adi,unlock-keys\",\n\t\t\t\t\t     kpad->unlock_keys,\n\t\t\t\t\t     kpad->nkeys_unlock);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < kpad->nkeys_unlock; i++) {\n\t\t \n\t\tif (kpad->unlock_keys[i] >= kpad->cols * kpad->rows) {\n\t\t\tdev_err(&client->dev, \"Invalid unlock key(%d)\\n\",\n\t\t\t\tkpad->unlock_keys[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tkpad->unlock_keys[i] += 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int adp5588_probe(struct i2c_client *client)\n{\n\tstruct adp5588_kpad *kpad;\n\tstruct input_dev *input;\n\tstruct gpio_desc *gpio;\n\tunsigned int revid;\n\tint ret;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"SMBUS Byte Data not Supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tkpad = devm_kzalloc(&client->dev, sizeof(*kpad), GFP_KERNEL);\n\tif (!kpad)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tkpad->client = client;\n\tkpad->input = input;\n\n\terror = adp5588_fw_parse(kpad);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_regulator_get_enable(&client->dev, \"vcc\");\n\tif (error)\n\t\treturn error;\n\n\tgpio = devm_gpiod_get_optional(&client->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\tif (gpio) {\n\t\tfsleep(30);\n\t\tgpiod_set_value_cansleep(gpio, 0);\n\t\tfsleep(60);\n\t}\n\n\tret = adp5588_read(client, DEV_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trevid = ret & ADP5588_DEVICE_ID_MASK;\n\tif (WA_DELAYED_READOUT_REVID(revid))\n\t\tkpad->delay = msecs_to_jiffies(WA_DELAYED_READOUT_TIME);\n\n\tinput->name = client->name;\n\tinput->phys = \"adp5588-keys/input0\";\n\n\tinput_set_drvdata(input, kpad);\n\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = revid;\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&client->dev, \"unable to register input device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = adp5588_setup(kpad);\n\tif (error)\n\t\treturn error;\n\n\terror = adp5588_gpio_add(kpad);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  adp5588_hard_irq, adp5588_thread_irq,\n\t\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t  client->dev.driver->name, kpad);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to request irq %d: %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\tdev_info(&client->dev, \"Rev.%d keypad, irq %d\\n\", revid, client->irq);\n\treturn 0;\n}\n\nstatic void adp5588_remove(struct i2c_client *client)\n{\n\tadp5588_write(client, CFG, 0);\n\n\t \n}\n\nstatic int adp5588_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int adp5588_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(adp5588_dev_pm_ops, adp5588_suspend, adp5588_resume);\n\nstatic const struct i2c_device_id adp5588_id[] = {\n\t{ \"adp5588-keys\", 0 },\n\t{ \"adp5587-keys\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adp5588_id);\n\nstatic const struct of_device_id adp5588_of_match[] = {\n\t{ .compatible = \"adi,adp5588\" },\n\t{ .compatible = \"adi,adp5587\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, adp5588_of_match);\n\nstatic struct i2c_driver adp5588_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = adp5588_of_match,\n\t\t.pm   = pm_sleep_ptr(&adp5588_dev_pm_ops),\n\t},\n\t.probe    = adp5588_probe,\n\t.remove   = adp5588_remove,\n\t.id_table = adp5588_id,\n};\n\nmodule_i2c_driver(adp5588_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"ADP5588/87 Keypad driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}