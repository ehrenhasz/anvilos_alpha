{
  "module_name": "imx_sc_key.c",
  "hash_id": "4cba7176b9049737e64759c6a0f13ad115326b52ca0aafdac502a550c042581d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/imx_sc_key.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define DEBOUNCE_TIME\t\t\t\t30\n#define REPEAT_INTERVAL\t\t\t\t60\n\n#define SC_IRQ_BUTTON\t\t\t\t1\n#define SC_IRQ_GROUP_WAKE\t\t\t3\n\n#define IMX_SC_MISC_FUNC_GET_BUTTON_STATUS\t18\n\nstruct imx_key_drv_data {\n\tu32 keycode;\n\tbool keystate;   \n\tstruct delayed_work check_work;\n\tstruct input_dev *input;\n\tstruct imx_sc_ipc *key_ipc_handle;\n\tstruct notifier_block key_notifier;\n};\n\nstruct imx_sc_msg_key {\n\tstruct imx_sc_rpc_msg hdr;\n\tu32 state;\n};\n\nstatic int imx_sc_key_notify(struct notifier_block *nb,\n\t\t\t     unsigned long event, void *group)\n{\n\tstruct imx_key_drv_data *priv =\n\t\t\t\t container_of(nb,\n\t\t\t\t\t      struct imx_key_drv_data,\n\t\t\t\t\t      key_notifier);\n\n\tif ((event & SC_IRQ_BUTTON) && (*(u8 *)group == SC_IRQ_GROUP_WAKE)) {\n\t\tschedule_delayed_work(&priv->check_work,\n\t\t\t\t      msecs_to_jiffies(DEBOUNCE_TIME));\n\t\tpm_wakeup_event(priv->input->dev.parent, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_sc_check_for_events(struct work_struct *work)\n{\n\tstruct imx_key_drv_data *priv =\n\t\t\t\t container_of(work,\n\t\t\t\t\t      struct imx_key_drv_data,\n\t\t\t\t\t      check_work.work);\n\tstruct input_dev *input = priv->input;\n\tstruct imx_sc_msg_key msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tbool state;\n\tint error;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_MISC;\n\thdr->func = IMX_SC_MISC_FUNC_GET_BUTTON_STATUS;\n\thdr->size = 1;\n\n\terror = imx_scu_call_rpc(priv->key_ipc_handle, &msg, true);\n\tif (error) {\n\t\tdev_err(&input->dev, \"read imx sc key failed, error %d\\n\", error);\n\t\treturn;\n\t}\n\n\t \n\tstate = (bool)(msg.state & 0xff);\n\n\tif (state ^ priv->keystate) {\n\t\tpriv->keystate = state;\n\t\tinput_event(input, EV_KEY, priv->keycode, state);\n\t\tinput_sync(input);\n\t\tif (!priv->keystate)\n\t\t\tpm_relax(priv->input->dev.parent);\n\t}\n\n\tif (state)\n\t\tschedule_delayed_work(&priv->check_work,\n\t\t\t\t      msecs_to_jiffies(REPEAT_INTERVAL));\n}\n\nstatic void imx_sc_key_action(void *data)\n{\n\tstruct imx_key_drv_data *priv = data;\n\n\timx_scu_irq_group_enable(SC_IRQ_GROUP_WAKE, SC_IRQ_BUTTON, false);\n\timx_scu_irq_unregister_notifier(&priv->key_notifier);\n\tcancel_delayed_work_sync(&priv->check_work);\n}\n\nstatic int imx_sc_key_probe(struct platform_device *pdev)\n{\n\tstruct imx_key_drv_data *priv;\n\tstruct input_dev *input;\n\tint error;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\terror = imx_scu_get_handle(&priv->key_ipc_handle);\n\tif (error)\n\t\treturn error;\n\n\tif (device_property_read_u32(&pdev->dev, \"linux,keycodes\",\n\t\t\t\t     &priv->keycode)) {\n\t\tdev_err(&pdev->dev, \"missing linux,keycodes property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tINIT_DELAYED_WORK(&priv->check_work, imx_sc_check_for_events);\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate the input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = pdev->name;\n\tinput->phys = \"imx-sc-key/input0\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput_set_capability(input, EV_KEY, priv->keycode);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tpriv->input = input;\n\tplatform_set_drvdata(pdev, priv);\n\n\terror = imx_scu_irq_group_enable(SC_IRQ_GROUP_WAKE, SC_IRQ_BUTTON,\n\t\t\t\t\t true);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to enable scu group irq\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&pdev->dev, imx_sc_key_action, &priv);\n\tif (error)\n\t\treturn error;\n\n\tpriv->key_notifier.notifier_call = imx_sc_key_notify;\n\terror = imx_scu_irq_register_notifier(&priv->key_notifier);\n\tif (error)\n\t\tdev_err(&pdev->dev, \"failed to register scu notifier\\n\");\n\n\treturn error;\n}\n\nstatic const struct of_device_id imx_sc_key_ids[] = {\n\t{ .compatible = \"fsl,imx-sc-key\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_sc_key_ids);\n\nstatic struct platform_driver imx_sc_key_driver = {\n\t.driver = {\n\t\t.name = \"imx-sc-key\",\n\t\t.of_match_table = imx_sc_key_ids,\n\t},\n\t.probe = imx_sc_key_probe,\n};\nmodule_platform_driver(imx_sc_key_driver);\n\nMODULE_AUTHOR(\"Anson Huang <Anson.Huang@nxp.com>\");\nMODULE_DESCRIPTION(\"i.MX System Controller Key Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}