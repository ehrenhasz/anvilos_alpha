{
  "module_name": "tca6416-keypad.c",
  "hash_id": "5e99bf9c0b4162790914bfdc727c0eea6d6b912d0572fd8964a73c86c19b6934",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/tca6416-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/tca6416_keypad.h>\n\n#define TCA6416_INPUT          0\n#define TCA6416_OUTPUT         1\n#define TCA6416_INVERT         2\n#define TCA6416_DIRECTION      3\n\n#define TCA6416_POLL_INTERVAL\t100  \n\nstatic const struct i2c_device_id tca6416_id[] = {\n\t{ \"tca6416-keys\", 16, },\n\t{ \"tca6408-keys\", 8, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tca6416_id);\n\nstruct tca6416_drv_data {\n\tstruct input_dev *input;\n\tstruct tca6416_button data[];\n};\n\nstruct tca6416_keypad_chip {\n\tuint16_t reg_output;\n\tuint16_t reg_direction;\n\tuint16_t reg_input;\n\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tint io_size;\n\tint irqnum;\n\tu16 pinmask;\n\tbool use_polling;\n\tstruct tca6416_button buttons[];\n};\n\nstatic int tca6416_write_reg(struct tca6416_keypad_chip *chip, int reg, u16 val)\n{\n\tint error;\n\n\terror = chip->io_size > 8 ?\n\t\ti2c_smbus_write_word_data(chip->client, reg << 1, val) :\n\t\ti2c_smbus_write_byte_data(chip->client, reg, val);\n\tif (error < 0) {\n\t\tdev_err(&chip->client->dev,\n\t\t\t\"%s failed, reg: %d, val: %d, error: %d\\n\",\n\t\t\t__func__, reg, val, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int tca6416_read_reg(struct tca6416_keypad_chip *chip, int reg, u16 *val)\n{\n\tint retval;\n\n\tretval = chip->io_size > 8 ?\n\t\t i2c_smbus_read_word_data(chip->client, reg << 1) :\n\t\t i2c_smbus_read_byte_data(chip->client, reg);\n\tif (retval < 0) {\n\t\tdev_err(&chip->client->dev, \"%s failed, reg: %d, error: %d\\n\",\n\t\t\t__func__, reg, retval);\n\t\treturn retval;\n\t}\n\n\t*val = (u16)retval;\n\treturn 0;\n}\n\nstatic void tca6416_keys_scan(struct input_dev *input)\n{\n\tstruct tca6416_keypad_chip *chip = input_get_drvdata(input);\n\tu16 reg_val, val;\n\tint error, i, pin_index;\n\n\terror = tca6416_read_reg(chip, TCA6416_INPUT, &reg_val);\n\tif (error)\n\t\treturn;\n\n\treg_val &= chip->pinmask;\n\n\t \n\tval = reg_val ^ chip->reg_input;\n\tchip->reg_input = reg_val;\n\n\tfor (i = 0, pin_index = 0; i < 16; i++) {\n\t\tif (val & (1 << i)) {\n\t\t\tstruct tca6416_button *button = &chip->buttons[pin_index];\n\t\t\tunsigned int type = button->type ?: EV_KEY;\n\t\t\tint state = ((reg_val & (1 << i)) ? 1 : 0)\n\t\t\t\t\t\t^ button->active_low;\n\n\t\t\tinput_event(input, type, button->code, !!state);\n\t\t\tinput_sync(input);\n\t\t}\n\n\t\tif (chip->pinmask & (1 << i))\n\t\t\tpin_index++;\n\t}\n}\n\n \nstatic irqreturn_t tca6416_keys_isr(int irq, void *dev_id)\n{\n\ttca6416_keys_scan(dev_id);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tca6416_keys_open(struct input_dev *dev)\n{\n\tstruct tca6416_keypad_chip *chip = input_get_drvdata(dev);\n\n\tif (!chip->use_polling) {\n\t\t \n\t\ttca6416_keys_scan(dev);\n\t\tenable_irq(chip->client->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic void tca6416_keys_close(struct input_dev *dev)\n{\n\tstruct tca6416_keypad_chip *chip = input_get_drvdata(dev);\n\n\tif (!chip->use_polling)\n\t\tdisable_irq(chip->client->irq);\n}\n\nstatic int tca6416_setup_registers(struct tca6416_keypad_chip *chip)\n{\n\tint error;\n\n\terror = tca6416_read_reg(chip, TCA6416_OUTPUT, &chip->reg_output);\n\tif (error)\n\t\treturn error;\n\n\terror = tca6416_read_reg(chip, TCA6416_DIRECTION, &chip->reg_direction);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = tca6416_write_reg(chip, TCA6416_DIRECTION,\n\t\t\t\t  chip->reg_direction | chip->pinmask);\n\tif (error)\n\t\treturn error;\n\n\terror = tca6416_read_reg(chip, TCA6416_DIRECTION, &chip->reg_direction);\n\tif (error)\n\t\treturn error;\n\n\terror = tca6416_read_reg(chip, TCA6416_INPUT, &chip->reg_input);\n\tif (error)\n\t\treturn error;\n\n\tchip->reg_input &= chip->pinmask;\n\n\treturn 0;\n}\n\nstatic int tca6416_keypad_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct tca6416_keys_platform_data *pdata;\n\tstruct tca6416_keypad_chip *chip;\n\tstruct input_dev *input;\n\tint error;\n\tint i;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {\n\t\tdev_err(&client->dev, \"%s adapter not supported\\n\",\n\t\t\tdev_driver_string(&client->adapter->dev));\n\t\treturn -ENODEV;\n\t}\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata) {\n\t\tdev_dbg(&client->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip = devm_kzalloc(&client->dev,\n\t\t\t    struct_size(chip, buttons, pdata->nbuttons),\n\t\t\t    GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tchip->input = input;\n\tchip->io_size = id->driver_data;\n\tchip->pinmask = pdata->pinmask;\n\tchip->use_polling = pdata->use_polling;\n\n\tinput->phys = \"tca6416-keys/input0\";\n\tinput->name = client->name;\n\n\tinput->open = tca6416_keys_open;\n\tinput->close = tca6416_keys_close;\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = 0x0100;\n\n\t \n\tif (pdata->rep)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tfor (i = 0; i < pdata->nbuttons; i++) {\n\t\tunsigned int type;\n\n\t\tchip->buttons[i] = pdata->buttons[i];\n\t\ttype = (pdata->buttons[i].type) ?: EV_KEY;\n\t\tinput_set_capability(input, type, pdata->buttons[i].code);\n\t}\n\n\tinput_set_drvdata(input, chip);\n\n\t \n\terror = tca6416_setup_registers(chip);\n\tif (error)\n\t\treturn error;\n\n\tif (chip->use_polling) {\n\t\terror = input_setup_polling(input, tca6416_keys_scan);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Failed to setup polling\\n\");\n\t\t\treturn error;\n\t\t}\n\n\t\tinput_set_poll_interval(input, TCA6416_POLL_INTERVAL);\n\t} else {\n\t\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\t  NULL, tca6416_keys_isr,\n\t\t\t\t\t\t  IRQF_TRIGGER_FALLING |\n\t\t\t\t\t\t\tIRQF_ONESHOT |\n\t\t\t\t\t\t\tIRQF_NO_AUTOEN,\n\t\t\t\t\t\t  \"tca6416-keypad\", input);\n\t\tif (error) {\n\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\"Unable to claim irq %d; error %d\\n\",\n\t\t\t\tclient->irq, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"Unable to register input device, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, chip);\n\n\treturn 0;\n}\n\nstatic struct i2c_driver tca6416_keypad_driver = {\n\t.driver = {\n\t\t.name\t= \"tca6416-keypad\",\n\t},\n\t.probe\t\t= tca6416_keypad_probe,\n\t.id_table\t= tca6416_id,\n};\n\nstatic int __init tca6416_keypad_init(void)\n{\n\treturn i2c_add_driver(&tca6416_keypad_driver);\n}\n\nsubsys_initcall(tca6416_keypad_init);\n\nstatic void __exit tca6416_keypad_exit(void)\n{\n\ti2c_del_driver(&tca6416_keypad_driver);\n}\nmodule_exit(tca6416_keypad_exit);\n\nMODULE_AUTHOR(\"Sriramakrishnan <srk@ti.com>\");\nMODULE_DESCRIPTION(\"Keypad driver over tca6416 IO expander\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}