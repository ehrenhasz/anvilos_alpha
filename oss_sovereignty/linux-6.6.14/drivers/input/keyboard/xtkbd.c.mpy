{
  "module_name": "xtkbd.c",
  "hash_id": "20b31f8b41c14829e42775d51e9f01bd80c8982cfb17bad7adc7a4110cfe4fd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/xtkbd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"XT keyboard driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define XTKBD_EMUL0\t0xe0\n#define XTKBD_EMUL1\t0xe1\n#define XTKBD_KEY\t0x7f\n#define XTKBD_RELEASE\t0x80\n\nstatic unsigned char xtkbd_keycode[256] = {\n\t  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n\t 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n\t 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n\t 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n\t 80, 81, 82, 83,  0,  0,  0, 87, 88,  0,  0,  0,  0,  0,  0,  0,\n\t  0,  0,  0,  0,  0, 87, 88,  0,  0,  0,  0,110,111,103,108,105,\n\t106\n};\n\nstruct xtkbd {\n\tunsigned char keycode[256];\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tchar phys[32];\n};\n\nstatic irqreturn_t xtkbd_interrupt(struct serio *serio,\n\tunsigned char data, unsigned int flags)\n{\n\tstruct xtkbd *xtkbd = serio_get_drvdata(serio);\n\n\tswitch (data) {\n\t\tcase XTKBD_EMUL0:\n\t\tcase XTKBD_EMUL1:\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\tif (xtkbd->keycode[data & XTKBD_KEY]) {\n\t\t\t\tinput_report_key(xtkbd->dev, xtkbd->keycode[data & XTKBD_KEY], !(data & XTKBD_RELEASE));\n\t\t\t\tinput_sync(xtkbd->dev);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"xtkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\t\tdata & XTKBD_KEY, data & XTKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int xtkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct xtkbd *xtkbd;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\txtkbd = kmalloc(sizeof(struct xtkbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!xtkbd || !input_dev)\n\t\tgoto fail1;\n\n\txtkbd->serio = serio;\n\txtkbd->dev = input_dev;\n\tsnprintf(xtkbd->phys, sizeof(xtkbd->phys), \"%s/input0\", serio->phys);\n\tmemcpy(xtkbd->keycode, xtkbd_keycode, sizeof(xtkbd->keycode));\n\n\tinput_dev->name = \"XT Keyboard\";\n\tinput_dev->phys = xtkbd->phys;\n\tinput_dev->id.bustype = BUS_XTKBD;\n\tinput_dev->id.vendor  = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\tinput_dev->keycode = xtkbd->keycode;\n\tinput_dev->keycodesize = sizeof(unsigned char);\n\tinput_dev->keycodemax = ARRAY_SIZE(xtkbd_keycode);\n\n\tfor (i = 0; i < 255; i++)\n\t\tset_bit(xtkbd->keycode[i], input_dev->keybit);\n\tclear_bit(0, input_dev->keybit);\n\n\tserio_set_drvdata(serio, xtkbd);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(xtkbd->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(xtkbd);\n\treturn err;\n}\n\nstatic void xtkbd_disconnect(struct serio *serio)\n{\n\tstruct xtkbd *xtkbd = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(xtkbd->dev);\n\tkfree(xtkbd);\n}\n\nstatic const struct serio_device_id xtkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_XT,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, xtkbd_serio_ids);\n\nstatic struct serio_driver xtkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"xtkbd\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= xtkbd_serio_ids,\n\t.interrupt\t= xtkbd_interrupt,\n\t.connect\t= xtkbd_connect,\n\t.disconnect\t= xtkbd_disconnect,\n};\n\nmodule_serio_driver(xtkbd_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}