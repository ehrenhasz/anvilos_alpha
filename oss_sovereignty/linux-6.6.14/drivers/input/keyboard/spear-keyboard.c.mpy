{
  "module_name": "spear-keyboard.c",
  "hash_id": "ecaf3efc513a8b4b1792cfe035ab2bb527e6eb42d66b435eea788b4c3fe36414",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/spear-keyboard.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeup.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/platform_data/keyboard-spear.h>\n\n \n#define MODE_CTL_REG\t0x00\n#define STATUS_REG\t0x0C\n#define DATA_REG\t0x10\n#define INTR_MASK\t0x54\n\n \n#define NUM_ROWS\t16\n#define NUM_COLS\t16\n#define MODE_CTL_PCLK_FREQ_SHIFT\t9\n#define MODE_CTL_PCLK_FREQ_MSK\t\t0x7F\n\n#define MODE_CTL_KEYBOARD\t(0x2 << 0)\n#define MODE_CTL_SCAN_RATE_10\t(0x0 << 2)\n#define MODE_CTL_SCAN_RATE_20\t(0x1 << 2)\n#define MODE_CTL_SCAN_RATE_40\t(0x2 << 2)\n#define MODE_CTL_SCAN_RATE_80\t(0x3 << 2)\n#define MODE_CTL_KEYNUM_SHIFT\t6\n#define MODE_CTL_START_SCAN\t(0x1 << 8)\n\n#define STATUS_DATA_AVAIL\t(0x1 << 1)\n\n#define DATA_ROW_MASK\t\t0xF0\n#define DATA_COLUMN_MASK\t0x0F\n\n#define ROW_SHIFT\t\t4\n\nstruct spear_kbd {\n\tstruct input_dev *input;\n\tvoid __iomem *io_base;\n\tstruct clk *clk;\n\tunsigned int irq;\n\tunsigned int mode;\n\tunsigned int suspended_rate;\n\tunsigned short last_key;\n\tunsigned short keycodes[NUM_ROWS * NUM_COLS];\n\tbool rep;\n\tbool irq_wake_enabled;\n\tu32 mode_ctl_reg;\n};\n\nstatic irqreturn_t spear_kbd_interrupt(int irq, void *dev_id)\n{\n\tstruct spear_kbd *kbd = dev_id;\n\tstruct input_dev *input = kbd->input;\n\tunsigned int key;\n\tu32 sts, val;\n\n\tsts = readl_relaxed(kbd->io_base + STATUS_REG);\n\tif (!(sts & STATUS_DATA_AVAIL))\n\t\treturn IRQ_NONE;\n\n\tif (kbd->last_key != KEY_RESERVED) {\n\t\tinput_report_key(input, kbd->last_key, 0);\n\t\tkbd->last_key = KEY_RESERVED;\n\t}\n\n\t \n\tval = readl_relaxed(kbd->io_base + DATA_REG) &\n\t\t(DATA_ROW_MASK | DATA_COLUMN_MASK);\n\tkey = kbd->keycodes[val];\n\n\tinput_event(input, EV_MSC, MSC_SCAN, val);\n\tinput_report_key(input, key, 1);\n\tinput_sync(input);\n\n\tkbd->last_key = key;\n\n\t \n\twritel_relaxed(0, kbd->io_base + STATUS_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spear_kbd_open(struct input_dev *dev)\n{\n\tstruct spear_kbd *kbd = input_get_drvdata(dev);\n\tint error;\n\tu32 val;\n\n\tkbd->last_key = KEY_RESERVED;\n\n\terror = clk_enable(kbd->clk);\n\tif (error)\n\t\treturn error;\n\n\t \n\tval = clk_get_rate(kbd->clk) / 1000000 - 1;\n\tval = (val & MODE_CTL_PCLK_FREQ_MSK) << MODE_CTL_PCLK_FREQ_SHIFT;\n\n\t \n\tval = MODE_CTL_SCAN_RATE_80 | MODE_CTL_KEYBOARD | val |\n\t\t(kbd->mode << MODE_CTL_KEYNUM_SHIFT);\n\twritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\n\twritel_relaxed(1, kbd->io_base + STATUS_REG);\n\n\t \n\tval = readl_relaxed(kbd->io_base + MODE_CTL_REG);\n\tval |= MODE_CTL_START_SCAN;\n\twritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\n\n\treturn 0;\n}\n\nstatic void spear_kbd_close(struct input_dev *dev)\n{\n\tstruct spear_kbd *kbd = input_get_drvdata(dev);\n\tu32 val;\n\n\t \n\tval = readl_relaxed(kbd->io_base + MODE_CTL_REG);\n\tval &= ~MODE_CTL_START_SCAN;\n\twritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\n\n\tclk_disable(kbd->clk);\n\n\tkbd->last_key = KEY_RESERVED;\n}\n\n#ifdef CONFIG_OF\nstatic int spear_kbd_parse_dt(struct platform_device *pdev,\n                                        struct spear_kbd *kbd)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint error;\n\tu32 val, suspended_rate;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Missing DT data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(np, \"autorepeat\"))\n\t\tkbd->rep = true;\n\n\tif (of_property_read_u32(np, \"suspended_rate\", &suspended_rate))\n\t\tkbd->suspended_rate = suspended_rate;\n\n\terror = of_property_read_u32(np, \"st,mode\", &val);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"DT: Invalid or missing mode\\n\");\n\t\treturn error;\n\t}\n\n\tkbd->mode = val;\n\treturn 0;\n}\n#else\nstatic inline int spear_kbd_parse_dt(struct platform_device *pdev,\n\t\t\t\t     struct spear_kbd *kbd)\n{\n\treturn -ENOSYS;\n}\n#endif\n\nstatic int spear_kbd_probe(struct platform_device *pdev)\n{\n\tstruct kbd_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tconst struct matrix_keymap_data *keymap = pdata ? pdata->keymap : NULL;\n\tstruct spear_kbd *kbd;\n\tstruct input_dev *input_dev;\n\tint irq;\n\tint error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tkbd = devm_kzalloc(&pdev->dev, sizeof(*kbd), GFP_KERNEL);\n\tif (!kbd) {\n\t\tdev_err(&pdev->dev, \"not enough memory for driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkbd->input = input_dev;\n\tkbd->irq = irq;\n\n\tif (!pdata) {\n\t\terror = spear_kbd_parse_dt(pdev, kbd);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tkbd->mode = pdata->mode;\n\t\tkbd->rep = pdata->rep;\n\t\tkbd->suspended_rate = pdata->suspended_rate;\n\t}\n\n\tkbd->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(kbd->io_base))\n\t\treturn PTR_ERR(kbd->io_base);\n\n\tkbd->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(kbd->clk))\n\t\treturn PTR_ERR(kbd->clk);\n\n\tinput_dev->name = \"Spear Keyboard\";\n\tinput_dev->phys = \"keyboard/input0\";\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->open = spear_kbd_open;\n\tinput_dev->close = spear_kbd_close;\n\n\terror = matrix_keypad_build_keymap(keymap, NULL, NUM_ROWS, NUM_COLS,\n\t\t\t\t\t   kbd->keycodes, input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tif (kbd->rep)\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\n\tinput_set_drvdata(input_dev, kbd);\n\n\terror = devm_request_irq(&pdev->dev, irq, spear_kbd_interrupt, 0,\n\t\t\t\"keyboard\", kbd);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = clk_prepare(kbd->clk);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Unable to register keyboard device\\n\");\n\t\tclk_unprepare(kbd->clk);\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tplatform_set_drvdata(pdev, kbd);\n\n\treturn 0;\n}\n\nstatic int spear_kbd_remove(struct platform_device *pdev)\n{\n\tstruct spear_kbd *kbd = platform_get_drvdata(pdev);\n\n\tinput_unregister_device(kbd->input);\n\tclk_unprepare(kbd->clk);\n\n\treturn 0;\n}\n\nstatic int spear_kbd_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct spear_kbd *kbd = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = kbd->input;\n\tunsigned int rate = 0, mode_ctl_reg, val;\n\n\tmutex_lock(&input_dev->mutex);\n\n\t \n\tclk_enable(kbd->clk);\n\n\tmode_ctl_reg = readl_relaxed(kbd->io_base + MODE_CTL_REG);\n\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (!enable_irq_wake(kbd->irq))\n\t\t\tkbd->irq_wake_enabled = true;\n\n\t\t \n\t\tif (kbd->suspended_rate)\n\t\t\trate = kbd->suspended_rate / 1000000 - 1;\n\t\telse\n\t\t\trate = clk_get_rate(kbd->clk) / 1000000 - 1;\n\n\t\tval = mode_ctl_reg &\n\t\t\t~(MODE_CTL_PCLK_FREQ_MSK << MODE_CTL_PCLK_FREQ_SHIFT);\n\t\tval |= (rate & MODE_CTL_PCLK_FREQ_MSK)\n\t\t\t<< MODE_CTL_PCLK_FREQ_SHIFT;\n\t\twritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\n\n\t} else {\n\t\tif (input_device_enabled(input_dev)) {\n\t\t\twritel_relaxed(mode_ctl_reg & ~MODE_CTL_START_SCAN,\n\t\t\t\t\tkbd->io_base + MODE_CTL_REG);\n\t\t\tclk_disable(kbd->clk);\n\t\t}\n\t}\n\n\t \n\tif (input_device_enabled(input_dev))\n\t\tkbd->mode_ctl_reg = mode_ctl_reg;\n\n\t \n\tclk_disable(kbd->clk);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int spear_kbd_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct spear_kbd *kbd = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = kbd->input;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (kbd->irq_wake_enabled) {\n\t\t\tkbd->irq_wake_enabled = false;\n\t\t\tdisable_irq_wake(kbd->irq);\n\t\t}\n\t} else {\n\t\tif (input_device_enabled(input_dev))\n\t\t\tclk_enable(kbd->clk);\n\t}\n\n\t \n\tif (input_device_enabled(input_dev))\n\t\twritel_relaxed(kbd->mode_ctl_reg, kbd->io_base + MODE_CTL_REG);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(spear_kbd_pm_ops,\n\t\t\t\tspear_kbd_suspend, spear_kbd_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spear_kbd_id_table[] = {\n\t{ .compatible = \"st,spear300-kbd\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spear_kbd_id_table);\n#endif\n\nstatic struct platform_driver spear_kbd_driver = {\n\t.probe\t\t= spear_kbd_probe,\n\t.remove\t\t= spear_kbd_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"keyboard\",\n\t\t.pm\t= pm_sleep_ptr(&spear_kbd_pm_ops),\n\t\t.of_match_table = of_match_ptr(spear_kbd_id_table),\n\t},\n};\nmodule_platform_driver(spear_kbd_driver);\n\nMODULE_AUTHOR(\"Rajeev Kumar\");\nMODULE_DESCRIPTION(\"SPEAr Keyboard Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}