{
  "module_name": "samsung-keypad.c",
  "hash_id": "9de436db9b8edbcf95023e9847e354a5b95cd82fda7a871f1b62673b4347b0b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/samsung-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/sched.h>\n#include <linux/input/samsung-keypad.h>\n\n#define SAMSUNG_KEYIFCON\t\t\t0x00\n#define SAMSUNG_KEYIFSTSCLR\t\t\t0x04\n#define SAMSUNG_KEYIFCOL\t\t\t0x08\n#define SAMSUNG_KEYIFROW\t\t\t0x0c\n#define SAMSUNG_KEYIFFC\t\t\t\t0x10\n\n \n#define SAMSUNG_KEYIFCON_INT_F_EN\t\t(1 << 0)\n#define SAMSUNG_KEYIFCON_INT_R_EN\t\t(1 << 1)\n#define SAMSUNG_KEYIFCON_DF_EN\t\t\t(1 << 2)\n#define SAMSUNG_KEYIFCON_FC_EN\t\t\t(1 << 3)\n#define SAMSUNG_KEYIFCON_WAKEUPEN\t\t(1 << 4)\n\n \n#define SAMSUNG_KEYIFSTSCLR_P_INT_MASK\t\t(0xff << 0)\n#define SAMSUNG_KEYIFSTSCLR_R_INT_MASK\t\t(0xff << 8)\n#define SAMSUNG_KEYIFSTSCLR_R_INT_OFFSET\t8\n#define S5PV210_KEYIFSTSCLR_P_INT_MASK\t\t(0x3fff << 0)\n#define S5PV210_KEYIFSTSCLR_R_INT_MASK\t\t(0x3fff << 16)\n#define S5PV210_KEYIFSTSCLR_R_INT_OFFSET\t16\n\n \n#define SAMSUNG_KEYIFCOL_MASK\t\t\t(0xff << 0)\n#define S5PV210_KEYIFCOLEN_MASK\t\t\t(0xff << 8)\n\n \n#define SAMSUNG_KEYIFROW_MASK\t\t\t(0xff << 0)\n#define S5PV210_KEYIFROW_MASK\t\t\t(0x3fff << 0)\n\n \n#define SAMSUNG_KEYIFFC_MASK\t\t\t(0x3ff << 0)\n\nenum samsung_keypad_type {\n\tKEYPAD_TYPE_SAMSUNG,\n\tKEYPAD_TYPE_S5PV210,\n};\n\nstruct samsung_keypad {\n\tstruct input_dev *input_dev;\n\tstruct platform_device *pdev;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\twait_queue_head_t wait;\n\tbool stopped;\n\tbool wake_enabled;\n\tint irq;\n\tenum samsung_keypad_type type;\n\tunsigned int row_shift;\n\tunsigned int rows;\n\tunsigned int cols;\n\tunsigned int row_state[SAMSUNG_MAX_COLS];\n\tunsigned short keycodes[];\n};\n\nstatic void samsung_keypad_scan(struct samsung_keypad *keypad,\n\t\t\t\tunsigned int *row_state)\n{\n\tunsigned int col;\n\tunsigned int val;\n\n\tfor (col = 0; col < keypad->cols; col++) {\n\t\tif (keypad->type == KEYPAD_TYPE_S5PV210) {\n\t\t\tval = S5PV210_KEYIFCOLEN_MASK;\n\t\t\tval &= ~(1 << col) << 8;\n\t\t} else {\n\t\t\tval = SAMSUNG_KEYIFCOL_MASK;\n\t\t\tval &= ~(1 << col);\n\t\t}\n\n\t\twritel(val, keypad->base + SAMSUNG_KEYIFCOL);\n\t\tmdelay(1);\n\n\t\tval = readl(keypad->base + SAMSUNG_KEYIFROW);\n\t\trow_state[col] = ~val & ((1 << keypad->rows) - 1);\n\t}\n\n\t \n\twritel(0, keypad->base + SAMSUNG_KEYIFCOL);\n}\n\nstatic bool samsung_keypad_report(struct samsung_keypad *keypad,\n\t\t\t\t  unsigned int *row_state)\n{\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tunsigned int changed;\n\tunsigned int pressed;\n\tunsigned int key_down = 0;\n\tunsigned int val;\n\tunsigned int col, row;\n\n\tfor (col = 0; col < keypad->cols; col++) {\n\t\tchanged = row_state[col] ^ keypad->row_state[col];\n\t\tkey_down |= row_state[col];\n\t\tif (!changed)\n\t\t\tcontinue;\n\n\t\tfor (row = 0; row < keypad->rows; row++) {\n\t\t\tif (!(changed & (1 << row)))\n\t\t\t\tcontinue;\n\n\t\t\tpressed = row_state[col] & (1 << row);\n\n\t\t\tdev_dbg(&keypad->input_dev->dev,\n\t\t\t\t\"key %s, row: %d, col: %d\\n\",\n\t\t\t\tpressed ? \"pressed\" : \"released\", row, col);\n\n\t\t\tval = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\n\n\t\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, val);\n\t\t\tinput_report_key(input_dev,\n\t\t\t\t\tkeypad->keycodes[val], pressed);\n\t\t}\n\t\tinput_sync(keypad->input_dev);\n\t}\n\n\tmemcpy(keypad->row_state, row_state, sizeof(keypad->row_state));\n\n\treturn key_down;\n}\n\nstatic irqreturn_t samsung_keypad_irq(int irq, void *dev_id)\n{\n\tstruct samsung_keypad *keypad = dev_id;\n\tunsigned int row_state[SAMSUNG_MAX_COLS];\n\tbool key_down;\n\n\tpm_runtime_get_sync(&keypad->pdev->dev);\n\n\tdo {\n\t\treadl(keypad->base + SAMSUNG_KEYIFSTSCLR);\n\t\t \n\t\twritel(~0x0, keypad->base + SAMSUNG_KEYIFSTSCLR);\n\n\t\tsamsung_keypad_scan(keypad, row_state);\n\n\t\tkey_down = samsung_keypad_report(keypad, row_state);\n\t\tif (key_down)\n\t\t\twait_event_timeout(keypad->wait, keypad->stopped,\n\t\t\t\t\t   msecs_to_jiffies(50));\n\n\t} while (key_down && !keypad->stopped);\n\n\tpm_runtime_put(&keypad->pdev->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void samsung_keypad_start(struct samsung_keypad *keypad)\n{\n\tunsigned int val;\n\n\tpm_runtime_get_sync(&keypad->pdev->dev);\n\n\t \n\tkeypad->stopped = false;\n\n\tclk_enable(keypad->clk);\n\n\t \n\tval = readl(keypad->base + SAMSUNG_KEYIFCON);\n\tval |= SAMSUNG_KEYIFCON_INT_F_EN | SAMSUNG_KEYIFCON_INT_R_EN;\n\twritel(val, keypad->base + SAMSUNG_KEYIFCON);\n\n\t \n\twritel(0, keypad->base + SAMSUNG_KEYIFCOL);\n\n\tpm_runtime_put(&keypad->pdev->dev);\n}\n\nstatic void samsung_keypad_stop(struct samsung_keypad *keypad)\n{\n\tunsigned int val;\n\n\tpm_runtime_get_sync(&keypad->pdev->dev);\n\n\t \n\tkeypad->stopped = true;\n\twake_up(&keypad->wait);\n\tdisable_irq(keypad->irq);\n\n\t \n\twritel(~0x0, keypad->base + SAMSUNG_KEYIFSTSCLR);\n\n\t \n\tval = readl(keypad->base + SAMSUNG_KEYIFCON);\n\tval &= ~(SAMSUNG_KEYIFCON_INT_F_EN | SAMSUNG_KEYIFCON_INT_R_EN);\n\twritel(val, keypad->base + SAMSUNG_KEYIFCON);\n\n\tclk_disable(keypad->clk);\n\n\t \n\tenable_irq(keypad->irq);\n\n\tpm_runtime_put(&keypad->pdev->dev);\n}\n\nstatic int samsung_keypad_open(struct input_dev *input_dev)\n{\n\tstruct samsung_keypad *keypad = input_get_drvdata(input_dev);\n\n\tsamsung_keypad_start(keypad);\n\n\treturn 0;\n}\n\nstatic void samsung_keypad_close(struct input_dev *input_dev)\n{\n\tstruct samsung_keypad *keypad = input_get_drvdata(input_dev);\n\n\tsamsung_keypad_stop(keypad);\n}\n\n#ifdef CONFIG_OF\nstatic struct samsung_keypad_platdata *\nsamsung_keypad_parse_dt(struct device *dev)\n{\n\tstruct samsung_keypad_platdata *pdata;\n\tstruct matrix_keymap_data *keymap_data;\n\tuint32_t *keymap, num_rows = 0, num_cols = 0;\n\tstruct device_node *np = dev->of_node, *key_np;\n\tunsigned int key_count;\n\n\tif (!np) {\n\t\tdev_err(dev, \"missing device tree data\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tdev_err(dev, \"could not allocate memory for platform data\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tof_property_read_u32(np, \"samsung,keypad-num-rows\", &num_rows);\n\tof_property_read_u32(np, \"samsung,keypad-num-columns\", &num_cols);\n\tif (!num_rows || !num_cols) {\n\t\tdev_err(dev, \"number of keypad rows/columns not specified\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tpdata->rows = num_rows;\n\tpdata->cols = num_cols;\n\n\tkeymap_data = devm_kzalloc(dev, sizeof(*keymap_data), GFP_KERNEL);\n\tif (!keymap_data) {\n\t\tdev_err(dev, \"could not allocate memory for keymap data\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tpdata->keymap_data = keymap_data;\n\n\tkey_count = of_get_child_count(np);\n\tkeymap_data->keymap_size = key_count;\n\tkeymap = devm_kcalloc(dev, key_count, sizeof(uint32_t), GFP_KERNEL);\n\tif (!keymap) {\n\t\tdev_err(dev, \"could not allocate memory for keymap\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tkeymap_data->keymap = keymap;\n\n\tfor_each_child_of_node(np, key_np) {\n\t\tu32 row, col, key_code;\n\t\tof_property_read_u32(key_np, \"keypad,row\", &row);\n\t\tof_property_read_u32(key_np, \"keypad,column\", &col);\n\t\tof_property_read_u32(key_np, \"linux,code\", &key_code);\n\t\t*keymap++ = KEY(row, col, key_code);\n\t}\n\n\tpdata->no_autorepeat = of_property_read_bool(np, \"linux,input-no-autorepeat\");\n\n\tpdata->wakeup = of_property_read_bool(np, \"wakeup-source\") ||\n\t\t\t \n\t\t\tof_property_read_bool(np, \"linux,input-wakeup\");\n\n\n\treturn pdata;\n}\n#else\nstatic struct samsung_keypad_platdata *\nsamsung_keypad_parse_dt(struct device *dev)\n{\n\tdev_err(dev, \"no platform data defined\\n\");\n\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\nstatic int samsung_keypad_probe(struct platform_device *pdev)\n{\n\tconst struct samsung_keypad_platdata *pdata;\n\tconst struct matrix_keymap_data *keymap_data;\n\tstruct samsung_keypad *keypad;\n\tstruct resource *res;\n\tstruct input_dev *input_dev;\n\tunsigned int row_shift;\n\tunsigned int keymap_size;\n\tint error;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tpdata = samsung_keypad_parse_dt(&pdev->dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tkeymap_data = pdata->keymap_data;\n\tif (!keymap_data) {\n\t\tdev_err(&pdev->dev, \"no keymap data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->rows || pdata->rows > SAMSUNG_MAX_ROWS)\n\t\treturn -EINVAL;\n\n\tif (!pdata->cols || pdata->cols > SAMSUNG_MAX_COLS)\n\t\treturn -EINVAL;\n\n\t \n\tif (pdata->cfg_gpio)\n\t\tpdata->cfg_gpio(pdata->rows, pdata->cols);\n\n\trow_shift = get_count_order(pdata->cols);\n\tkeymap_size = (pdata->rows << row_shift) * sizeof(keypad->keycodes[0]);\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(*keypad) + keymap_size,\n\t\t\t      GFP_KERNEL);\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!keypad || !input_dev)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tkeypad->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!keypad->base)\n\t\treturn -EBUSY;\n\n\tkeypad->clk = devm_clk_get(&pdev->dev, \"keypad\");\n\tif (IS_ERR(keypad->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get keypad clk\\n\");\n\t\treturn PTR_ERR(keypad->clk);\n\t}\n\n\terror = clk_prepare(keypad->clk);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"keypad clock prepare failed\\n\");\n\t\treturn error;\n\t}\n\n\tkeypad->input_dev = input_dev;\n\tkeypad->pdev = pdev;\n\tkeypad->row_shift = row_shift;\n\tkeypad->rows = pdata->rows;\n\tkeypad->cols = pdata->cols;\n\tkeypad->stopped = true;\n\tinit_waitqueue_head(&keypad->wait);\n\n\tif (pdev->dev.of_node)\n\t\tkeypad->type = of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t\t\"samsung,s5pv210-keypad\");\n\telse\n\t\tkeypad->type = platform_get_device_id(pdev)->driver_data;\n\n\tinput_dev->name = pdev->name;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->dev.parent = &pdev->dev;\n\n\tinput_dev->open = samsung_keypad_open;\n\tinput_dev->close = samsung_keypad_close;\n\n\terror = matrix_keypad_build_keymap(keymap_data, NULL,\n\t\t\t\t\t   pdata->rows, pdata->cols,\n\t\t\t\t\t   keypad->keycodes, input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\tgoto err_unprepare_clk;\n\t}\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tif (!pdata->no_autorepeat)\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\n\tinput_set_drvdata(input_dev, keypad);\n\n\tkeypad->irq = platform_get_irq(pdev, 0);\n\tif (keypad->irq < 0) {\n\t\terror = keypad->irq;\n\t\tgoto err_unprepare_clk;\n\t}\n\n\terror = devm_request_threaded_irq(&pdev->dev, keypad->irq, NULL,\n\t\t\t\t\t  samsung_keypad_irq, IRQF_ONESHOT,\n\t\t\t\t\t  dev_name(&pdev->dev), keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register keypad interrupt\\n\");\n\t\tgoto err_unprepare_clk;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, pdata->wakeup);\n\tplatform_set_drvdata(pdev, keypad);\n\tpm_runtime_enable(&pdev->dev);\n\n\terror = input_register_device(keypad->input_dev);\n\tif (error)\n\t\tgoto err_disable_runtime_pm;\n\n\tif (pdev->dev.of_node) {\n\t\tdevm_kfree(&pdev->dev, (void *)pdata->keymap_data->keymap);\n\t\tdevm_kfree(&pdev->dev, (void *)pdata->keymap_data);\n\t\tdevm_kfree(&pdev->dev, (void *)pdata);\n\t}\n\treturn 0;\n\nerr_disable_runtime_pm:\n\tpm_runtime_disable(&pdev->dev);\nerr_unprepare_clk:\n\tclk_unprepare(keypad->clk);\n\treturn error;\n}\n\nstatic int samsung_keypad_remove(struct platform_device *pdev)\n{\n\tstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tinput_unregister_device(keypad->input_dev);\n\n\tclk_unprepare(keypad->clk);\n\n\treturn 0;\n}\n\nstatic int samsung_keypad_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\n\tunsigned int val;\n\tint error;\n\n\tif (keypad->stopped)\n\t\treturn 0;\n\n\t \n\terror = enable_irq_wake(keypad->irq);\n\tif (!error)\n\t\tkeypad->wake_enabled = true;\n\n\tval = readl(keypad->base + SAMSUNG_KEYIFCON);\n\tval |= SAMSUNG_KEYIFCON_WAKEUPEN;\n\twritel(val, keypad->base + SAMSUNG_KEYIFCON);\n\n\tclk_disable(keypad->clk);\n\n\treturn 0;\n}\n\nstatic int samsung_keypad_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\n\tunsigned int val;\n\n\tif (keypad->stopped)\n\t\treturn 0;\n\n\tclk_enable(keypad->clk);\n\n\tval = readl(keypad->base + SAMSUNG_KEYIFCON);\n\tval &= ~SAMSUNG_KEYIFCON_WAKEUPEN;\n\twritel(val, keypad->base + SAMSUNG_KEYIFCON);\n\n\tif (keypad->wake_enabled)\n\t\tdisable_irq_wake(keypad->irq);\n\n\treturn 0;\n}\n\nstatic void samsung_keypad_toggle_wakeup(struct samsung_keypad *keypad,\n\t\t\t\t\t bool enable)\n{\n\tunsigned int val;\n\n\tclk_enable(keypad->clk);\n\n\tval = readl(keypad->base + SAMSUNG_KEYIFCON);\n\tif (enable) {\n\t\tval |= SAMSUNG_KEYIFCON_WAKEUPEN;\n\t\tif (device_may_wakeup(&keypad->pdev->dev))\n\t\t\tenable_irq_wake(keypad->irq);\n\t} else {\n\t\tval &= ~SAMSUNG_KEYIFCON_WAKEUPEN;\n\t\tif (device_may_wakeup(&keypad->pdev->dev))\n\t\t\tdisable_irq_wake(keypad->irq);\n\t}\n\twritel(val, keypad->base + SAMSUNG_KEYIFCON);\n\n\tclk_disable(keypad->clk);\n}\n\nstatic int samsung_keypad_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = keypad->input_dev;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tsamsung_keypad_stop(keypad);\n\n\tsamsung_keypad_toggle_wakeup(keypad, true);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int samsung_keypad_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = keypad->input_dev;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tsamsung_keypad_toggle_wakeup(keypad, false);\n\n\tif (input_device_enabled(input_dev))\n\t\tsamsung_keypad_start(keypad);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops samsung_keypad_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(samsung_keypad_suspend, samsung_keypad_resume)\n\tRUNTIME_PM_OPS(samsung_keypad_runtime_suspend,\n\t\t       samsung_keypad_runtime_resume, NULL)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id samsung_keypad_dt_match[] = {\n\t{ .compatible = \"samsung,s3c6410-keypad\" },\n\t{ .compatible = \"samsung,s5pv210-keypad\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, samsung_keypad_dt_match);\n#endif\n\nstatic const struct platform_device_id samsung_keypad_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"samsung-keypad\",\n\t\t.driver_data\t= KEYPAD_TYPE_SAMSUNG,\n\t}, {\n\t\t.name\t\t= \"s5pv210-keypad\",\n\t\t.driver_data\t= KEYPAD_TYPE_S5PV210,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, samsung_keypad_driver_ids);\n\nstatic struct platform_driver samsung_keypad_driver = {\n\t.probe\t\t= samsung_keypad_probe,\n\t.remove\t\t= samsung_keypad_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"samsung-keypad\",\n\t\t.of_match_table = of_match_ptr(samsung_keypad_dt_match),\n\t\t.pm\t= pm_ptr(&samsung_keypad_pm_ops),\n\t},\n\t.id_table\t= samsung_keypad_driver_ids,\n};\nmodule_platform_driver(samsung_keypad_driver);\n\nMODULE_DESCRIPTION(\"Samsung keypad driver\");\nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_AUTHOR(\"Donghwa Lee <dh09.lee@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}