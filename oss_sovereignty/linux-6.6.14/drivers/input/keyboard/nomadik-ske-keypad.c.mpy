{
  "module_name": "nomadik-ske-keypad.c",
  "hash_id": "0ca2057fa31de6b7d873d331e2e50a1cee355ed2958debce72e1f61a266b55cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/nomadik-ske-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n\n#include <linux/platform_data/keypad-nomadik-ske.h>\n\n \n#define SKE_KPMLT\t(0x1 << 6)\n#define SKE_KPCN\t(0x7 << 3)\n#define SKE_KPASEN\t(0x1 << 2)\n#define SKE_KPASON\t(0x1 << 7)\n\n \n#define SKE_KPIMA\t(0x1 << 2)\n\n \n#define SKE_KPICS\t(0x1 << 3)\n#define SKE_KPICA\t(0x1 << 2)\n\n \n#define SKE_KPRISA\t(0x1 << 2)\n\n#define SKE_KEYPAD_ROW_SHIFT\t3\n#define SKE_KPD_NUM_ROWS\t8\n#define SKE_KPD_NUM_COLS\t8\n\n \n#define SKE_ASR0\t0x20\n#define SKE_ASR1\t0x24\n#define SKE_ASR2\t0x28\n#define SKE_ASR3\t0x2C\n\n#define SKE_NUM_ASRX_REGISTERS\t(4)\n#define\tKEY_PRESSED_DELAY\t10\n\n \nstruct ske_keypad {\n\tint irq;\n\tvoid __iomem *reg_base;\n\tstruct input_dev *input;\n\tconst struct ske_keypad_platform_data *board;\n\tunsigned short keymap[SKE_KPD_NUM_ROWS * SKE_KPD_NUM_COLS];\n\tstruct clk *clk;\n\tstruct clk *pclk;\n\tspinlock_t ske_keypad_lock;\n};\n\nstatic void ske_keypad_set_bits(struct ske_keypad *keypad, u16 addr,\n\t\tu8 mask, u8 data)\n{\n\tu32 ret;\n\n\tspin_lock(&keypad->ske_keypad_lock);\n\n\tret = readl(keypad->reg_base + addr);\n\tret &= ~mask;\n\tret |= data;\n\twritel(ret, keypad->reg_base + addr);\n\n\tspin_unlock(&keypad->ske_keypad_lock);\n}\n\n \nstatic int __init ske_keypad_chip_init(struct ske_keypad *keypad)\n{\n\tu32 value;\n\tint timeout = keypad->board->debounce_ms;\n\n\t \n\twhile ((readl(keypad->reg_base + SKE_RIS) != 0x00000000) && timeout--)\n\t\tcpu_relax();\n\n\tif (timeout == -1)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&keypad->ske_keypad_lock);\n\tvalue = readl(keypad->reg_base + SKE_DBCR);\n\tvalue = value & 0xff;\n\tvalue |= ((keypad->board->debounce_ms * 32000)/32768) << 8;\n\twritel(value, keypad->reg_base + SKE_DBCR);\n\tspin_unlock(&keypad->ske_keypad_lock);\n\n\t \n\tske_keypad_set_bits(keypad, SKE_CR, 0x0, SKE_KPMLT);\n\n\t \n\tvalue = (keypad->board->kcol - 1) << 3;\n\tske_keypad_set_bits(keypad, SKE_CR, SKE_KPCN, value);\n\n\t \n\tske_keypad_set_bits(keypad, SKE_ICR, 0x0, SKE_KPICA | SKE_KPICS);\n\n\t \n\tske_keypad_set_bits(keypad, SKE_IMSC, 0x0, SKE_KPIMA);\n\n\t \n\tske_keypad_set_bits(keypad, SKE_CR, 0x0, SKE_KPASEN);\n\n\treturn 0;\n}\n\nstatic void ske_keypad_report(struct ske_keypad *keypad, u8 status, int col)\n{\n\tint row = 0, code, pos;\n\tstruct input_dev *input = keypad->input;\n\tu32 ske_ris;\n\tint key_pressed;\n\tint num_of_rows;\n\n\t \n\tnum_of_rows = hweight8(status);\n\tdo {\n\t\tpos = __ffs(status);\n\t\trow = pos;\n\t\tstatus &= ~(1 << pos);\n\n\t\tcode = MATRIX_SCAN_CODE(row, col, SKE_KEYPAD_ROW_SHIFT);\n\t\tske_ris = readl(keypad->reg_base + SKE_RIS);\n\t\tkey_pressed = ske_ris & SKE_KPRISA;\n\n\t\tinput_event(input, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(input, keypad->keymap[code], key_pressed);\n\t\tinput_sync(input);\n\t\tnum_of_rows--;\n\t} while (num_of_rows);\n}\n\nstatic void ske_keypad_read_data(struct ske_keypad *keypad)\n{\n\tu8 status;\n\tint col = 0;\n\tint ske_asr, i;\n\n\t \n\tfor (i = 0; i < SKE_NUM_ASRX_REGISTERS; i++) {\n\t\tske_asr = readl(keypad->reg_base + SKE_ASR0 + (4 * i));\n\t\tif (!ske_asr)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = ske_asr & 0xff;\n\t\tif (status) {\n\t\t\tcol = i * 2;\n\t\t\tske_keypad_report(keypad, status, col);\n\t\t}\n\t\tstatus = (ske_asr & 0xff00) >> 8;\n\t\tif (status) {\n\t\t\tcol = (i * 2) + 1;\n\t\t\tske_keypad_report(keypad, status, col);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t ske_keypad_irq(int irq, void *dev_id)\n{\n\tstruct ske_keypad *keypad = dev_id;\n\tint timeout = keypad->board->debounce_ms;\n\n\t \n\tske_keypad_set_bits(keypad, SKE_IMSC, ~SKE_KPIMA, 0x0);\n\tske_keypad_set_bits(keypad, SKE_ICR, 0x0, SKE_KPICA);\n\n\twhile ((readl(keypad->reg_base + SKE_CR) & SKE_KPASON) && --timeout)\n\t\tcpu_relax();\n\n\t \n\tske_keypad_read_data(keypad);\n\n\t \n\twhile ((readl(keypad->reg_base + SKE_RIS)) && --timeout)\n\t\tmsleep(KEY_PRESSED_DELAY);\n\n\t \n\tske_keypad_set_bits(keypad, SKE_IMSC, 0x0, SKE_KPIMA);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ske_keypad_board_exit(void *data)\n{\n\tstruct ske_keypad *keypad = data;\n\n\tkeypad->board->exit();\n}\n\nstatic int __init ske_keypad_probe(struct platform_device *pdev)\n{\n\tconst struct ske_keypad_platform_data *plat =\n\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tstruct ske_keypad *keypad;\n\tstruct input_dev *input;\n\tint irq;\n\tint error;\n\n\tif (!plat) {\n\t\tdev_err(&pdev->dev, \"invalid keypad platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tkeypad = devm_kzalloc(dev, sizeof(struct ske_keypad),\n\t\t\t      GFP_KERNEL);\n\tinput = devm_input_allocate_device(dev);\n\tif (!keypad || !input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate keypad memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad->irq = irq;\n\tkeypad->board = plat;\n\tkeypad->input = input;\n\tspin_lock_init(&keypad->ske_keypad_lock);\n\n\tkeypad->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(keypad->reg_base))\n\t\treturn PTR_ERR(keypad->reg_base);\n\n\tkeypad->pclk = devm_clk_get_enabled(dev, \"apb_pclk\");\n\tif (IS_ERR(keypad->pclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get pclk\\n\");\n\t\treturn PTR_ERR(keypad->pclk);\n\t}\n\n\tkeypad->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(keypad->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clk\\n\");\n\t\treturn PTR_ERR(keypad->clk);\n\t}\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->name = \"ux500-ske-keypad\";\n\tinput->dev.parent = &pdev->dev;\n\n\terror = matrix_keypad_build_keymap(plat->keymap_data, NULL,\n\t\t\t\t\t   SKE_KPD_NUM_ROWS, SKE_KPD_NUM_COLS,\n\t\t\t\t\t   keypad->keymap, input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\tif (!plat->no_autorepeat)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\t \n\tif (keypad->board->init)\n\t\tkeypad->board->init();\n\n\tif (keypad->board->exit) {\n\t\terror = devm_add_action_or_reset(dev, ske_keypad_board_exit,\n\t\t\t\t\t\t keypad);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = ske_keypad_chip_init(keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"unable to init keypad hardware\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, keypad->irq,\n\t\t\t\t\t  NULL, ske_keypad_irq,\n\t\t\t\t\t  IRQF_ONESHOT, \"ske-keypad\", keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"allocate irq %d failed\\n\", keypad->irq);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (plat->wakeup_enable)\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\n\tplatform_set_drvdata(pdev, keypad);\n\n\treturn 0;\n}\n\nstatic int ske_keypad_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ske_keypad *keypad = platform_get_drvdata(pdev);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(irq);\n\telse\n\t\tske_keypad_set_bits(keypad, SKE_IMSC, ~SKE_KPIMA, 0x0);\n\n\treturn 0;\n}\n\nstatic int ske_keypad_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ske_keypad *keypad = platform_get_drvdata(pdev);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(irq);\n\telse\n\t\tske_keypad_set_bits(keypad, SKE_IMSC, 0x0, SKE_KPIMA);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ske_keypad_dev_pm_ops,\n\t\t\t\tske_keypad_suspend, ske_keypad_resume);\n\nstatic struct platform_driver ske_keypad_driver = {\n\t.driver = {\n\t\t.name = \"nmk-ske-keypad\",\n\t\t.pm = pm_sleep_ptr(&ske_keypad_dev_pm_ops),\n\t},\n};\n\nmodule_platform_driver_probe(ske_keypad_driver, ske_keypad_probe);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Naveen Kumar <naveen.gaddipati@stericsson.com> / Sundar Iyer <sundar.iyer@stericsson.com>\");\nMODULE_DESCRIPTION(\"Nomadik Scroll-Key-Encoder Keypad Driver\");\nMODULE_ALIAS(\"platform:nomadik-ske-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}