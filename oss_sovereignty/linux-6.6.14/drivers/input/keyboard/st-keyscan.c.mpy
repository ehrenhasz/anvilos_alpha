{
  "module_name": "st-keyscan.c",
  "hash_id": "6520321359950e4d755ba4b37ba4a7a06f7d3b288538b4cc64d78a0994f647fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/st-keyscan.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define ST_KEYSCAN_MAXKEYS 16\n\n#define KEYSCAN_CONFIG_OFF\t\t0x0\n#define KEYSCAN_CONFIG_ENABLE\t\t0x1\n#define KEYSCAN_DEBOUNCE_TIME_OFF\t0x4\n#define KEYSCAN_MATRIX_STATE_OFF\t0x8\n#define KEYSCAN_MATRIX_DIM_OFF\t\t0xc\n#define KEYSCAN_MATRIX_DIM_X_SHIFT\t0x0\n#define KEYSCAN_MATRIX_DIM_Y_SHIFT\t0x2\n\nstruct st_keyscan {\n\tvoid __iomem *base;\n\tint irq;\n\tstruct clk *clk;\n\tstruct input_dev *input_dev;\n\tunsigned long last_state;\n\tunsigned int n_rows;\n\tunsigned int n_cols;\n\tunsigned int debounce_us;\n};\n\nstatic irqreturn_t keyscan_isr(int irq, void *dev_id)\n{\n\tstruct st_keyscan *keypad = dev_id;\n\tunsigned short *keycode = keypad->input_dev->keycode;\n\tunsigned long state, change;\n\tint bit_nr;\n\n\tstate = readl(keypad->base + KEYSCAN_MATRIX_STATE_OFF) & 0xffff;\n\tchange = keypad->last_state ^ state;\n\tkeypad->last_state = state;\n\n\tfor_each_set_bit(bit_nr, &change, BITS_PER_LONG)\n\t\tinput_report_key(keypad->input_dev,\n\t\t\t\t keycode[bit_nr], state & BIT(bit_nr));\n\n\tinput_sync(keypad->input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int keyscan_start(struct st_keyscan *keypad)\n{\n\tint error;\n\n\terror = clk_enable(keypad->clk);\n\tif (error)\n\t\treturn error;\n\n\twritel(keypad->debounce_us * (clk_get_rate(keypad->clk) / 1000000),\n\t       keypad->base + KEYSCAN_DEBOUNCE_TIME_OFF);\n\n\twritel(((keypad->n_cols - 1) << KEYSCAN_MATRIX_DIM_X_SHIFT) |\n\t       ((keypad->n_rows - 1) << KEYSCAN_MATRIX_DIM_Y_SHIFT),\n\t       keypad->base + KEYSCAN_MATRIX_DIM_OFF);\n\n\twritel(KEYSCAN_CONFIG_ENABLE, keypad->base + KEYSCAN_CONFIG_OFF);\n\n\treturn 0;\n}\n\nstatic void keyscan_stop(struct st_keyscan *keypad)\n{\n\twritel(0, keypad->base + KEYSCAN_CONFIG_OFF);\n\n\tclk_disable(keypad->clk);\n}\n\nstatic int keyscan_open(struct input_dev *dev)\n{\n\tstruct st_keyscan *keypad = input_get_drvdata(dev);\n\n\treturn keyscan_start(keypad);\n}\n\nstatic void keyscan_close(struct input_dev *dev)\n{\n\tstruct st_keyscan *keypad = input_get_drvdata(dev);\n\n\tkeyscan_stop(keypad);\n}\n\nstatic int keypad_matrix_key_parse_dt(struct st_keyscan *keypad_data)\n{\n\tstruct device *dev = keypad_data->input_dev->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tint error;\n\n\terror = matrix_keypad_parse_properties(dev, &keypad_data->n_rows,\n\t\t\t\t\t       &keypad_data->n_cols);\n\tif (error) {\n\t\tdev_err(dev, \"failed to parse keypad params\\n\");\n\t\treturn error;\n\t}\n\n\tof_property_read_u32(np, \"st,debounce-us\", &keypad_data->debounce_us);\n\n\tdev_dbg(dev, \"n_rows=%d n_col=%d debounce=%d\\n\",\n\t\tkeypad_data->n_rows, keypad_data->n_cols,\n\t\tkeypad_data->debounce_us);\n\n\treturn 0;\n}\n\nstatic int keyscan_probe(struct platform_device *pdev)\n{\n\tstruct st_keyscan *keypad_data;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"no DT data present\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkeypad_data = devm_kzalloc(&pdev->dev, sizeof(*keypad_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!keypad_data)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate the input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name = pdev->name;\n\tinput_dev->phys = \"keyscan-keys/input0\";\n\tinput_dev->dev.parent = &pdev->dev;\n\tinput_dev->open = keyscan_open;\n\tinput_dev->close = keyscan_close;\n\n\tinput_dev->id.bustype = BUS_HOST;\n\n\tkeypad_data->input_dev = input_dev;\n\n\terror = keypad_matrix_key_parse_dt(keypad_data);\n\tif (error)\n\t\treturn error;\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   keypad_data->n_rows,\n\t\t\t\t\t   keypad_data->n_cols,\n\t\t\t\t\t   NULL, input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tinput_set_drvdata(input_dev, keypad_data);\n\n\tkeypad_data->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(keypad_data->base))\n\t\treturn PTR_ERR(keypad_data->base);\n\n\tkeypad_data->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(keypad_data->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(keypad_data->clk);\n\t}\n\n\terror = clk_enable(keypad_data->clk);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\treturn error;\n\t}\n\n\tkeyscan_stop(keypad_data);\n\n\tkeypad_data->irq = platform_get_irq(pdev, 0);\n\tif (keypad_data->irq < 0)\n\t\treturn -EINVAL;\n\n\terror = devm_request_irq(&pdev->dev, keypad_data->irq, keyscan_isr, 0,\n\t\t\t\t pdev->name, keypad_data);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, keypad_data);\n\n\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\n\treturn 0;\n}\n\nstatic int keyscan_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct st_keyscan *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input = keypad->input_dev;\n\n\tmutex_lock(&input->mutex);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(keypad->irq);\n\telse if (input_device_enabled(input))\n\t\tkeyscan_stop(keypad);\n\n\tmutex_unlock(&input->mutex);\n\treturn 0;\n}\n\nstatic int keyscan_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct st_keyscan *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input = keypad->input_dev;\n\tint retval = 0;\n\n\tmutex_lock(&input->mutex);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(keypad->irq);\n\telse if (input_device_enabled(input))\n\t\tretval = keyscan_start(keypad);\n\n\tmutex_unlock(&input->mutex);\n\treturn retval;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(keyscan_dev_pm_ops,\n\t\t\t\tkeyscan_suspend, keyscan_resume);\n\nstatic const struct of_device_id keyscan_of_match[] = {\n\t{ .compatible = \"st,sti-keyscan\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, keyscan_of_match);\n\nstatic struct platform_driver keyscan_device_driver = {\n\t.probe\t\t= keyscan_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"st-keyscan\",\n\t\t.pm\t= pm_sleep_ptr(&keyscan_dev_pm_ops),\n\t\t.of_match_table = keyscan_of_match,\n\t}\n};\n\nmodule_platform_driver(keyscan_device_driver);\n\nMODULE_AUTHOR(\"Stuart Menefy <stuart.menefy@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics keyscan device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}