{
  "module_name": "hilkbd.c",
  "hash_id": "bb8148e6656c13b08523053baa49e1b5d9be2a0705c3b7c4e15e12488cf1cd8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/hilkbd.c",
  "human_readable_source": "\n \n\n#include <linux/pci_ids.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/hil.h>\n#include <linux/io.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <asm/irq.h>\n#ifdef CONFIG_HP300\n#include <asm/hwtest.h>\n#endif\n\n\nMODULE_AUTHOR(\"Philip Blundell, Matthew Wilcox, Helge Deller\");\nMODULE_DESCRIPTION(\"HIL keyboard driver (basic functionality)\");\nMODULE_LICENSE(\"GPL v2\");\n\n\n#if defined(CONFIG_PARISC)\n\n #include <asm/io.h>\n #include <asm/hardware.h>\n #include <asm/parisc-device.h>\n static unsigned long hil_base;\t \n static unsigned int hil_irq;\n #define HILBASE\t\thil_base  \n #define HIL_DATA\t\t0x800\n #define HIL_CMD\t\t0x801\n #define HIL_IRQ\t\thil_irq\n #define hil_readb(p)\t\tgsc_readb(p)\n #define hil_writeb(v,p)\tgsc_writeb((v),(p))\n\n#elif defined(CONFIG_HP300)\n\n #define HILBASE\t\t0xf0428000UL  \n #define HIL_DATA\t\t0x1\n #define HIL_CMD\t\t0x3\n #define HIL_IRQ\t\t2\n #define hil_readb(p)\t\treadb((const volatile void __iomem *)(p))\n #define hil_writeb(v, p)\twriteb((v), (volatile void __iomem *)(p))\n\n#else\n#error \"HIL is not supported on this platform\"\n#endif\n\n\n\n \n\n#define hil_busy()              (hil_readb(HILBASE + HIL_CMD) & HIL_BUSY)\n#define hil_data_available()    (hil_readb(HILBASE + HIL_CMD) & HIL_DATA_RDY)\n#define hil_status()            (hil_readb(HILBASE + HIL_CMD))\n#define hil_command(x)          do { hil_writeb((x), HILBASE + HIL_CMD); } while (0)\n#define hil_read_data()         (hil_readb(HILBASE + HIL_DATA))\n#define hil_write_data(x)       do { hil_writeb((x), HILBASE + HIL_DATA); } while (0)\n\n \n\n#define\tHIL_BUSY\t\t0x02\n#define\tHIL_DATA_RDY\t\t0x01\n\n#define\tHIL_SETARD\t\t0xA0\t\t \n#define\tHIL_SETARR\t\t0xA2\t\t \n#define\tHIL_SETTONE\t\t0xA3\t\t \n#define\tHIL_CNMT\t\t0xB2\t\t \n#define\tHIL_INTON\t\t0x5C\t\t \n#define\tHIL_INTOFF\t\t0x5D\t\t \n\n#define\tHIL_READKBDSADR\t\t0xF9\n#define\tHIL_WRITEKBDSADR\t0xE9\n\nstatic unsigned int hphilkeyb_keycode[HIL_KEYCODES_SET1_TBLSIZE] __read_mostly =\n\t{ HIL_KEYCODES_SET1 };\n\n \nstatic struct {\n\tstruct input_dev *dev;\n\n\tunsigned int curdev;\n\n\tunsigned char s;\n\tunsigned char c;\n\tint valid;\n\n\tunsigned char data[16];\n\tunsigned int ptr;\n\tspinlock_t lock;\n\n\tvoid *dev_id;\t \n} hil_dev;\n\n\nstatic void poll_finished(void)\n{\n\tint down;\n\tint key;\n\tunsigned char scode;\n\n\tswitch (hil_dev.data[0]) {\n\tcase 0x40:\n\t\tdown = (hil_dev.data[1] & 1) == 0;\n\t\tscode = hil_dev.data[1] >> 1;\n\t\tkey = hphilkeyb_keycode[scode];\n\t\tinput_report_key(hil_dev.dev, key, down);\n\t\tbreak;\n\t}\n\thil_dev.curdev = 0;\n}\n\n\nstatic inline void handle_status(unsigned char s, unsigned char c)\n{\n\tif (c & 0x8) {\n\t\t \n\t\tif (c & 0x10)\n\t\t\tpoll_finished();\n\t} else {\n\t\tif (c & 0x10) {\n\t\t\tif (hil_dev.curdev)\n\t\t\t\tpoll_finished();   \n\t\t\thil_dev.curdev = c & 7;\n\t\t\thil_dev.ptr = 0;\n\t\t}\n\t}\n}\n\n\nstatic inline void handle_data(unsigned char s, unsigned char c)\n{\n\tif (hil_dev.curdev) {\n\t\thil_dev.data[hil_dev.ptr++] = c;\n\t\thil_dev.ptr &= 15;\n\t}\n}\n\n\n \nstatic irqreturn_t hil_interrupt(int irq, void *handle)\n{\n\tunsigned char s, c;\n\n\ts = hil_status();\n\tc = hil_read_data();\n\n\tswitch (s >> 4) {\n\tcase 0x5:\n\t\thandle_status(s, c);\n\t\tbreak;\n\tcase 0x6:\n\t\thandle_data(s, c);\n\t\tbreak;\n\tcase 0x4:\n\t\thil_dev.s = s;\n\t\thil_dev.c = c;\n\t\tmb();\n\t\thil_dev.valid = 1;\n\t\tbreak;\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic void hil_do(unsigned char cmd, unsigned char *data, unsigned int len)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hil_dev.lock, flags);\n\twhile (hil_busy())\n\t\t ;\n\thil_command(cmd);\n\twhile (len--) {\n\t\twhile (hil_busy())\n\t\t\t ;\n\t\thil_write_data(*(data++));\n\t}\n\tspin_unlock_irqrestore(&hil_dev.lock, flags);\n}\n\n\n \nstatic int hil_keyb_init(void)\n{\n\tunsigned char c;\n\tunsigned int i, kbid;\n\twait_queue_head_t hil_wait;\n\tint err;\n\n\tif (hil_dev.dev)\n\t\treturn -ENODEV;  \n\n\tinit_waitqueue_head(&hil_wait);\n\tspin_lock_init(&hil_dev.lock);\n\n\thil_dev.dev = input_allocate_device();\n\tif (!hil_dev.dev)\n\t\treturn -ENOMEM;\n\n\terr = request_irq(HIL_IRQ, hil_interrupt, 0, \"hil\", hil_dev.dev_id);\n\tif (err) {\n\t\tprintk(KERN_ERR \"HIL: Can't get IRQ\\n\");\n\t\tgoto err1;\n\t}\n\n\t \n\thil_do(HIL_INTON, NULL, 0);\n\n\t \n\thil_dev.valid = 0;\t \n\thil_do(HIL_READKBDSADR, NULL, 0);\n\n\twait_event_interruptible_timeout(hil_wait, hil_dev.valid, 3 * HZ);\n\tif (!hil_dev.valid)\n\t\tprintk(KERN_WARNING \"HIL: timed out, assuming no keyboard present\\n\");\n\n\tc = hil_dev.c;\n\thil_dev.valid = 0;\n\tif (c == 0) {\n\t\tkbid = -1;\n\t\tprintk(KERN_WARNING \"HIL: no keyboard present\\n\");\n\t} else {\n\t\tkbid = ffz(~c);\n\t\tprintk(KERN_INFO \"HIL: keyboard found at id %d\\n\", kbid);\n\t}\n\n\t \n\tc = 0;\n\thil_do(HIL_WRITEKBDSADR, &c, 1);\n\n\tfor (i = 0; i < HIL_KEYCODES_SET1_TBLSIZE; i++)\n\t\tif (hphilkeyb_keycode[i] != KEY_RESERVED)\n\t\t\t__set_bit(hphilkeyb_keycode[i], hil_dev.dev->keybit);\n\n\thil_dev.dev->evbit[0]\t= BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\thil_dev.dev->ledbit[0]\t= BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |\n\t\tBIT_MASK(LED_SCROLLL);\n\thil_dev.dev->keycodemax\t= HIL_KEYCODES_SET1_TBLSIZE;\n\thil_dev.dev->keycodesize= sizeof(hphilkeyb_keycode[0]);\n\thil_dev.dev->keycode\t= hphilkeyb_keycode;\n\thil_dev.dev->name\t= \"HIL keyboard\";\n\thil_dev.dev->phys\t= \"hpkbd/input0\";\n\n\thil_dev.dev->id.bustype\t= BUS_HIL;\n\thil_dev.dev->id.vendor\t= PCI_VENDOR_ID_HP;\n\thil_dev.dev->id.product\t= 0x0001;\n\thil_dev.dev->id.version\t= 0x0010;\n\n\terr = input_register_device(hil_dev.dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"HIL: Can't register device\\n\");\n\t\tgoto err2;\n\t}\n\n\tprintk(KERN_INFO \"input: %s, ID %d at 0x%08lx (irq %d) found and attached\\n\",\n\t       hil_dev.dev->name, kbid, HILBASE, HIL_IRQ);\n\n\treturn 0;\n\nerr2:\n\thil_do(HIL_INTOFF, NULL, 0);\n\tfree_irq(HIL_IRQ, hil_dev.dev_id);\nerr1:\n\tinput_free_device(hil_dev.dev);\n\thil_dev.dev = NULL;\n\treturn err;\n}\n\nstatic void hil_keyb_exit(void)\n{\n\tif (HIL_IRQ)\n\t\tfree_irq(HIL_IRQ, hil_dev.dev_id);\n\n\t \n\thil_do(HIL_INTOFF, NULL, 0);\n\n\tinput_unregister_device(hil_dev.dev);\n\thil_dev.dev = NULL;\n}\n\n#if defined(CONFIG_PARISC)\nstatic int __init hil_probe_chip(struct parisc_device *dev)\n{\n\t \n\tif (hil_dev.dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->irq) {\n\t\tprintk(KERN_WARNING \"HIL: IRQ not found for HIL bus at 0x%p\\n\",\n\t\t\t(void *)dev->hpa.start);\n\t\treturn -ENODEV;\n\t}\n\n\thil_base = dev->hpa.start;\n\thil_irq  = dev->irq;\n\thil_dev.dev_id = dev;\n\n\tprintk(KERN_INFO \"Found HIL bus at 0x%08lx, IRQ %d\\n\", hil_base, hil_irq);\n\n\treturn hil_keyb_init();\n}\n\nstatic void __exit hil_remove_chip(struct parisc_device *dev)\n{\n\thil_keyb_exit();\n}\n\nstatic const struct parisc_device_id hil_tbl[] __initconst = {\n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00073 },\n\t{ 0, }\n};\n\n#if 0\n \nMODULE_DEVICE_TABLE(parisc, hil_tbl);\n#endif\n\nstatic struct parisc_driver hil_driver __refdata = {\n\t.name\t\t= \"hil\",\n\t.id_table\t= hil_tbl,\n\t.probe\t\t= hil_probe_chip,\n\t.remove\t\t= __exit_p(hil_remove_chip),\n};\n\nstatic int __init hil_init(void)\n{\n\treturn register_parisc_driver(&hil_driver);\n}\n\nstatic void __exit hil_exit(void)\n{\n\tunregister_parisc_driver(&hil_driver);\n}\n\n#else  \n\nstatic int __init hil_init(void)\n{\n\tint error;\n\n\t \n\tif (hil_dev.dev)\n\t\treturn -EBUSY;\n\n\tif (!MACH_IS_HP300)\n\t\treturn -ENODEV;\n\n\tif (!hwreg_present((void *)(HILBASE + HIL_DATA))) {\n\t\tprintk(KERN_ERR \"HIL: hardware register was not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!request_region(HILBASE + HIL_DATA, 2, \"hil\")) {\n\t\tprintk(KERN_ERR \"HIL: IOPORT region already used\\n\");\n\t\treturn -EIO;\n\t}\n\n\terror = hil_keyb_init();\n\tif (error) {\n\t\trelease_region(HILBASE + HIL_DATA, 2);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hil_exit(void)\n{\n\thil_keyb_exit();\n\trelease_region(HILBASE + HIL_DATA, 2);\n}\n\n#endif  \n\nmodule_init(hil_init);\nmodule_exit(hil_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}