{
  "module_name": "tca8418_keypad.c",
  "hash_id": "847107774b7b802c05ff506759b678f3e05f6e76c1de2e54c5b2c98163b89d7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/tca8418_keypad.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#define TCA8418_MAX_ROWS\t8\n#define TCA8418_MAX_COLS\t10\n\n \n#define REG_CFG\t\t\t0x01\n#define REG_INT_STAT\t\t0x02\n#define REG_KEY_LCK_EC\t\t0x03\n#define REG_KEY_EVENT_A\t\t0x04\n#define REG_KEY_EVENT_B\t\t0x05\n#define REG_KEY_EVENT_C\t\t0x06\n#define REG_KEY_EVENT_D\t\t0x07\n#define REG_KEY_EVENT_E\t\t0x08\n#define REG_KEY_EVENT_F\t\t0x09\n#define REG_KEY_EVENT_G\t\t0x0A\n#define REG_KEY_EVENT_H\t\t0x0B\n#define REG_KEY_EVENT_I\t\t0x0C\n#define REG_KEY_EVENT_J\t\t0x0D\n#define REG_KP_LCK_TIMER\t0x0E\n#define REG_UNLOCK1\t\t0x0F\n#define REG_UNLOCK2\t\t0x10\n#define REG_GPIO_INT_STAT1\t0x11\n#define REG_GPIO_INT_STAT2\t0x12\n#define REG_GPIO_INT_STAT3\t0x13\n#define REG_GPIO_DAT_STAT1\t0x14\n#define REG_GPIO_DAT_STAT2\t0x15\n#define REG_GPIO_DAT_STAT3\t0x16\n#define REG_GPIO_DAT_OUT1\t0x17\n#define REG_GPIO_DAT_OUT2\t0x18\n#define REG_GPIO_DAT_OUT3\t0x19\n#define REG_GPIO_INT_EN1\t0x1A\n#define REG_GPIO_INT_EN2\t0x1B\n#define REG_GPIO_INT_EN3\t0x1C\n#define REG_KP_GPIO1\t\t0x1D\n#define REG_KP_GPIO2\t\t0x1E\n#define REG_KP_GPIO3\t\t0x1F\n#define REG_GPI_EM1\t\t0x20\n#define REG_GPI_EM2\t\t0x21\n#define REG_GPI_EM3\t\t0x22\n#define REG_GPIO_DIR1\t\t0x23\n#define REG_GPIO_DIR2\t\t0x24\n#define REG_GPIO_DIR3\t\t0x25\n#define REG_GPIO_INT_LVL1\t0x26\n#define REG_GPIO_INT_LVL2\t0x27\n#define REG_GPIO_INT_LVL3\t0x28\n#define REG_DEBOUNCE_DIS1\t0x29\n#define REG_DEBOUNCE_DIS2\t0x2A\n#define REG_DEBOUNCE_DIS3\t0x2B\n#define REG_GPIO_PULL1\t\t0x2C\n#define REG_GPIO_PULL2\t\t0x2D\n#define REG_GPIO_PULL3\t\t0x2E\n\n \n#define CFG_AI\t\t\tBIT(7)\n#define CFG_GPI_E_CFG\t\tBIT(6)\n#define CFG_OVR_FLOW_M\t\tBIT(5)\n#define CFG_INT_CFG\t\tBIT(4)\n#define CFG_OVR_FLOW_IEN\tBIT(3)\n#define CFG_K_LCK_IEN\t\tBIT(2)\n#define CFG_GPI_IEN\t\tBIT(1)\n#define CFG_KE_IEN\t\tBIT(0)\n\n#define INT_STAT_CAD_INT\tBIT(4)\n#define INT_STAT_OVR_FLOW_INT\tBIT(3)\n#define INT_STAT_K_LCK_INT\tBIT(2)\n#define INT_STAT_GPI_INT\tBIT(1)\n#define INT_STAT_K_INT\t\tBIT(0)\n\n \n#define KEY_LCK_EC_KEC\t\t0x7\n#define KEY_EVENT_CODE\t\t0x7f\n#define KEY_EVENT_VALUE\t\t0x80\n\nstruct tca8418_keypad {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\n\tunsigned int row_shift;\n};\n\n \nstatic int tca8418_write_byte(struct tca8418_keypad *keypad_data,\n\t\t\t      int reg, u8 val)\n{\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(keypad_data->client, reg, val);\n\tif (error < 0) {\n\t\tdev_err(&keypad_data->client->dev,\n\t\t\t\"%s failed, reg: %d, val: %d, error: %d\\n\",\n\t\t\t__func__, reg, val, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tca8418_read_byte(struct tca8418_keypad *keypad_data,\n\t\t\t     int reg, u8 *val)\n{\n\tint error;\n\n\terror = i2c_smbus_read_byte_data(keypad_data->client, reg);\n\tif (error < 0) {\n\t\tdev_err(&keypad_data->client->dev,\n\t\t\t\t\"%s failed, reg: %d, error: %d\\n\",\n\t\t\t\t__func__, reg, error);\n\t\treturn error;\n\t}\n\n\t*val = (u8)error;\n\n\treturn 0;\n}\n\nstatic void tca8418_read_keypad(struct tca8418_keypad *keypad_data)\n{\n\tstruct input_dev *input = keypad_data->input;\n\tunsigned short *keymap = input->keycode;\n\tint error, col, row;\n\tu8 reg, state, code;\n\n\tdo {\n\t\terror = tca8418_read_byte(keypad_data, REG_KEY_EVENT_A, &reg);\n\t\tif (error < 0) {\n\t\t\tdev_err(&keypad_data->client->dev,\n\t\t\t\t\"unable to read REG_KEY_EVENT_A\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (reg <= 0)\n\t\t\tbreak;\n\n\t\tstate = reg & KEY_EVENT_VALUE;\n\t\tcode  = reg & KEY_EVENT_CODE;\n\n\t\trow = code / TCA8418_MAX_COLS;\n\t\tcol = code % TCA8418_MAX_COLS;\n\n\t\trow = (col) ? row : row - 1;\n\t\tcol = (col) ? col - 1 : TCA8418_MAX_COLS - 1;\n\n\t\tcode = MATRIX_SCAN_CODE(row, col, keypad_data->row_shift);\n\t\tinput_event(input, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(input, keymap[code], state);\n\n\t} while (1);\n\n\tinput_sync(input);\n}\n\n \nstatic irqreturn_t tca8418_irq_handler(int irq, void *dev_id)\n{\n\tstruct tca8418_keypad *keypad_data = dev_id;\n\tu8 reg;\n\tint error;\n\n\terror = tca8418_read_byte(keypad_data, REG_INT_STAT, &reg);\n\tif (error) {\n\t\tdev_err(&keypad_data->client->dev,\n\t\t\t\"unable to read REG_INT_STAT\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\tif (reg & INT_STAT_OVR_FLOW_INT)\n\t\tdev_warn(&keypad_data->client->dev, \"overflow occurred\\n\");\n\n\tif (reg & INT_STAT_K_INT)\n\t\ttca8418_read_keypad(keypad_data);\n\n\t \n\treg = 0xff;\n\terror = tca8418_write_byte(keypad_data, REG_INT_STAT, reg);\n\tif (error)\n\t\tdev_err(&keypad_data->client->dev,\n\t\t\t\"unable to clear REG_INT_STAT\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int tca8418_configure(struct tca8418_keypad *keypad_data,\n\t\t\t     u32 rows, u32 cols)\n{\n\tint reg, error = 0;\n\n\t \n\treg  =  ~(~0 << rows);\n\treg += (~(~0 << cols)) << 8;\n\n\t \n\terror |= tca8418_write_byte(keypad_data, REG_KP_GPIO1, reg);\n\terror |= tca8418_write_byte(keypad_data, REG_KP_GPIO2, reg >> 8);\n\terror |= tca8418_write_byte(keypad_data, REG_KP_GPIO3, reg >> 16);\n\n\t \n\terror |= tca8418_write_byte(keypad_data, REG_DEBOUNCE_DIS1, reg);\n\terror |= tca8418_write_byte(keypad_data, REG_DEBOUNCE_DIS2, reg >> 8);\n\terror |= tca8418_write_byte(keypad_data, REG_DEBOUNCE_DIS3, reg >> 16);\n\n\tif (error)\n\t\treturn error;\n\n\terror = tca8418_write_byte(keypad_data, REG_CFG,\n\t\t\t\tCFG_INT_CFG | CFG_OVR_FLOW_IEN | CFG_KE_IEN);\n\n\treturn error;\n}\n\nstatic int tca8418_keypad_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tca8418_keypad *keypad_data;\n\tstruct input_dev *input;\n\tu32 rows = 0, cols = 0;\n\tint error, row_shift;\n\tu8 reg;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {\n\t\tdev_err(dev, \"%s adapter not supported\\n\",\n\t\t\tdev_driver_string(&client->adapter->dev));\n\t\treturn -ENODEV;\n\t}\n\n\terror = matrix_keypad_parse_properties(dev, &rows, &cols);\n\tif (error)\n\t\treturn error;\n\n\tif (!rows || rows > TCA8418_MAX_ROWS) {\n\t\tdev_err(dev, \"invalid rows\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cols || cols > TCA8418_MAX_COLS) {\n\t\tdev_err(dev, \"invalid columns\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trow_shift = get_count_order(cols);\n\n\t \n\tkeypad_data = devm_kzalloc(dev, sizeof(*keypad_data), GFP_KERNEL);\n\tif (!keypad_data)\n\t\treturn -ENOMEM;\n\n\tkeypad_data->client = client;\n\tkeypad_data->row_shift = row_shift;\n\n\t \n\terror = tca8418_read_byte(keypad_data, REG_KEY_LCK_EC, &reg);\n\tif (error)\n\t\treturn -ENODEV;\n\n\t \n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tkeypad_data->input = input;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor  = 0x0001;\n\tinput->id.product = 0x001;\n\tinput->id.version = 0x0001;\n\n\terror = matrix_keypad_build_keymap(NULL, NULL, rows, cols, NULL, input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tif (device_property_read_bool(dev, \"keypad,autorepeat\"))\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, tca8418_irq_handler,\n\t\t\t\t\t  IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t  client->name, keypad_data);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to claim irq %d; error %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\t \n\terror = tca8418_configure(keypad_data, rows, cols);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to register input device, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tca8418_id[] = {\n\t{ \"tca8418\", 8418, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tca8418_id);\n\nstatic const struct of_device_id tca8418_dt_ids[] = {\n\t{ .compatible = \"ti,tca8418\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tca8418_dt_ids);\n\nstatic struct i2c_driver tca8418_keypad_driver = {\n\t.driver = {\n\t\t.name\t= \"tca8418_keypad\",\n\t\t.of_match_table = tca8418_dt_ids,\n\t},\n\t.probe\t\t= tca8418_keypad_probe,\n\t.id_table\t= tca8418_id,\n};\n\nstatic int __init tca8418_keypad_init(void)\n{\n\treturn i2c_add_driver(&tca8418_keypad_driver);\n}\nsubsys_initcall(tca8418_keypad_init);\n\nstatic void __exit tca8418_keypad_exit(void)\n{\n\ti2c_del_driver(&tca8418_keypad_driver);\n}\nmodule_exit(tca8418_keypad_exit);\n\nMODULE_AUTHOR(\"Kyle Manna <kyle.manna@fuel7.com>\");\nMODULE_DESCRIPTION(\"Keypad driver for TCA8418\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}