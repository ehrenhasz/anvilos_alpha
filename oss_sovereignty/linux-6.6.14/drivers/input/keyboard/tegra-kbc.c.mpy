{
  "module_name": "tegra-kbc.c",
  "hash_id": "0b65a788bcf08a4c4a540ed1450189dced8d15552e09d07ed4a0d9c68f7b3f64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/tegra-kbc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/reset.h>\n#include <linux/err.h>\n\n#define KBC_MAX_KPENT\t8\n\n \n#define KBC_MAX_GPIO\t24\n \n#define KBC_MAX_KEY\t(16 * 8)\n\n#define KBC_MAX_DEBOUNCE_CNT\t0x3ffu\n\n \n#define KBC_ROW_SCAN_TIME\t16\n#define KBC_ROW_SCAN_DLY\t5\n\n \n#define KBC_CYCLE_MS\t32\n\n \n\n \n#define KBC_CONTROL_0\t0x0\n#define KBC_FIFO_TH_CNT_SHIFT(cnt)\t(cnt << 14)\n#define KBC_DEBOUNCE_CNT_SHIFT(cnt)\t(cnt << 4)\n#define KBC_CONTROL_FIFO_CNT_INT_EN\t(1 << 3)\n#define KBC_CONTROL_KEYPRESS_INT_EN\t(1 << 1)\n#define KBC_CONTROL_KBC_EN\t\t(1 << 0)\n\n \n#define KBC_INT_0\t0x4\n#define KBC_INT_FIFO_CNT_INT_STATUS\t(1 << 2)\n#define KBC_INT_KEYPRESS_INT_STATUS\t(1 << 0)\n\n#define KBC_ROW_CFG0_0\t0x8\n#define KBC_COL_CFG0_0\t0x18\n#define KBC_TO_CNT_0\t0x24\n#define KBC_INIT_DLY_0\t0x28\n#define KBC_RPT_DLY_0\t0x2c\n#define KBC_KP_ENT0_0\t0x30\n#define KBC_KP_ENT1_0\t0x34\n#define KBC_ROW0_MASK_0\t0x38\n\n#define KBC_ROW_SHIFT\t3\n\nenum tegra_pin_type {\n\tPIN_CFG_IGNORE,\n\tPIN_CFG_COL,\n\tPIN_CFG_ROW,\n};\n\n \nstruct tegra_kbc_hw_support {\n\tint max_rows;\n\tint max_columns;\n};\n\nstruct tegra_kbc_pin_cfg {\n\tenum tegra_pin_type type;\n\tunsigned char num;\n};\n\nstruct tegra_kbc {\n\tstruct device *dev;\n\tunsigned int debounce_cnt;\n\tunsigned int repeat_cnt;\n\tstruct tegra_kbc_pin_cfg pin_cfg[KBC_MAX_GPIO];\n\tconst struct matrix_keymap_data *keymap_data;\n\tbool wakeup;\n\tvoid __iomem *mmio;\n\tstruct input_dev *idev;\n\tint irq;\n\tspinlock_t lock;\n\tunsigned int repoll_dly;\n\tunsigned long cp_dly_jiffies;\n\tunsigned int cp_to_wkup_dly;\n\tbool use_fn_map;\n\tbool use_ghost_filter;\n\tbool keypress_caused_wake;\n\tunsigned short keycode[KBC_MAX_KEY * 2];\n\tunsigned short current_keys[KBC_MAX_KPENT];\n\tunsigned int num_pressed_keys;\n\tu32 wakeup_key;\n\tstruct timer_list timer;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tconst struct tegra_kbc_hw_support *hw_support;\n\tint max_keys;\n\tint num_rows_and_columns;\n};\n\nstatic void tegra_kbc_report_released_keys(struct input_dev *input,\n\t\t\t\t\t   unsigned short old_keycodes[],\n\t\t\t\t\t   unsigned int old_num_keys,\n\t\t\t\t\t   unsigned short new_keycodes[],\n\t\t\t\t\t   unsigned int new_num_keys)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < old_num_keys; i++) {\n\t\tfor (j = 0; j < new_num_keys; j++)\n\t\t\tif (old_keycodes[i] == new_keycodes[j])\n\t\t\t\tbreak;\n\n\t\tif (j == new_num_keys)\n\t\t\tinput_report_key(input, old_keycodes[i], 0);\n\t}\n}\n\nstatic void tegra_kbc_report_pressed_keys(struct input_dev *input,\n\t\t\t\t\t  unsigned char scancodes[],\n\t\t\t\t\t  unsigned short keycodes[],\n\t\t\t\t\t  unsigned int num_pressed_keys)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_pressed_keys; i++) {\n\t\tinput_event(input, EV_MSC, MSC_SCAN, scancodes[i]);\n\t\tinput_report_key(input, keycodes[i], 1);\n\t}\n}\n\nstatic void tegra_kbc_report_keys(struct tegra_kbc *kbc)\n{\n\tunsigned char scancodes[KBC_MAX_KPENT];\n\tunsigned short keycodes[KBC_MAX_KPENT];\n\tu32 val = 0;\n\tunsigned int i;\n\tunsigned int num_down = 0;\n\tbool fn_keypress = false;\n\tbool key_in_same_row = false;\n\tbool key_in_same_col = false;\n\n\tfor (i = 0; i < KBC_MAX_KPENT; i++) {\n\t\tif ((i % 4) == 0)\n\t\t\tval = readl(kbc->mmio + KBC_KP_ENT0_0 + i);\n\n\t\tif (val & 0x80) {\n\t\t\tunsigned int col = val & 0x07;\n\t\t\tunsigned int row = (val >> 3) & 0x0f;\n\t\t\tunsigned char scancode =\n\t\t\t\tMATRIX_SCAN_CODE(row, col, KBC_ROW_SHIFT);\n\n\t\t\tscancodes[num_down] = scancode;\n\t\t\tkeycodes[num_down] = kbc->keycode[scancode];\n\t\t\t \n\t\t\tif ((keycodes[num_down] == KEY_FN) && kbc->use_fn_map)\n\t\t\t\tfn_keypress = true;\n\t\t\telse\n\t\t\t\tnum_down++;\n\t\t}\n\n\t\tval >>= 8;\n\t}\n\n\t \n\tif (kbc->use_ghost_filter && num_down >= 3) {\n\t\tfor (i = 0; i < num_down; i++) {\n\t\t\tunsigned int j;\n\t\t\tu8 curr_col = scancodes[i] & 0x07;\n\t\t\tu8 curr_row = scancodes[i] >> KBC_ROW_SHIFT;\n\n\t\t\t \n\t\t\tfor (j = i + 1; j < num_down; j++) {\n\t\t\t\tu8 col = scancodes[j] & 0x07;\n\t\t\t\tu8 row = scancodes[j] >> KBC_ROW_SHIFT;\n\n\t\t\t\tif (col == curr_col)\n\t\t\t\t\tkey_in_same_col = true;\n\t\t\t\tif (row == curr_row)\n\t\t\t\t\tkey_in_same_row = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (fn_keypress) {\n\t\tfor (i = 0; i < num_down; i++) {\n\t\t\tscancodes[i] += kbc->max_keys;\n\t\t\tkeycodes[i] = kbc->keycode[scancodes[i]];\n\t\t}\n\t}\n\n\t \n\tif (key_in_same_col && key_in_same_row)\n\t\treturn;\n\n\ttegra_kbc_report_released_keys(kbc->idev,\n\t\t\t\t       kbc->current_keys, kbc->num_pressed_keys,\n\t\t\t\t       keycodes, num_down);\n\ttegra_kbc_report_pressed_keys(kbc->idev, scancodes, keycodes, num_down);\n\tinput_sync(kbc->idev);\n\n\tmemcpy(kbc->current_keys, keycodes, sizeof(kbc->current_keys));\n\tkbc->num_pressed_keys = num_down;\n}\n\nstatic void tegra_kbc_set_fifo_interrupt(struct tegra_kbc *kbc, bool enable)\n{\n\tu32 val;\n\n\tval = readl(kbc->mmio + KBC_CONTROL_0);\n\tif (enable)\n\t\tval |= KBC_CONTROL_FIFO_CNT_INT_EN;\n\telse\n\t\tval &= ~KBC_CONTROL_FIFO_CNT_INT_EN;\n\twritel(val, kbc->mmio + KBC_CONTROL_0);\n}\n\nstatic void tegra_kbc_keypress_timer(struct timer_list *t)\n{\n\tstruct tegra_kbc *kbc = from_timer(kbc, t, timer);\n\tunsigned long flags;\n\tu32 val;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&kbc->lock, flags);\n\n\tval = (readl(kbc->mmio + KBC_INT_0) >> 4) & 0xf;\n\tif (val) {\n\t\tunsigned long dly;\n\n\t\ttegra_kbc_report_keys(kbc);\n\n\t\t \n\t\tdly = (val == 1) ? kbc->repoll_dly : 1;\n\t\tmod_timer(&kbc->timer, jiffies + msecs_to_jiffies(dly));\n\t} else {\n\t\t \n\t\tfor (i = 0; i < kbc->num_pressed_keys; i++)\n\t\t\tinput_report_key(kbc->idev, kbc->current_keys[i], 0);\n\t\tinput_sync(kbc->idev);\n\n\t\tkbc->num_pressed_keys = 0;\n\n\t\t \n\t\ttegra_kbc_set_fifo_interrupt(kbc, true);\n\t}\n\n\tspin_unlock_irqrestore(&kbc->lock, flags);\n}\n\nstatic irqreturn_t tegra_kbc_isr(int irq, void *args)\n{\n\tstruct tegra_kbc *kbc = args;\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&kbc->lock, flags);\n\n\t \n\tval = readl(kbc->mmio + KBC_INT_0);\n\twritel(val, kbc->mmio + KBC_INT_0);\n\n\tif (val & KBC_INT_FIFO_CNT_INT_STATUS) {\n\t\t \n\t\ttegra_kbc_set_fifo_interrupt(kbc, false);\n\t\tmod_timer(&kbc->timer, jiffies + kbc->cp_dly_jiffies);\n\t} else if (val & KBC_INT_KEYPRESS_INT_STATUS) {\n\t\t \n\t\tkbc->keypress_caused_wake = true;\n\t}\n\n\tspin_unlock_irqrestore(&kbc->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_kbc_setup_wakekeys(struct tegra_kbc *kbc, bool filter)\n{\n\tint i;\n\tunsigned int rst_val;\n\n\t \n\trst_val = (filter && !kbc->wakeup) ? ~0 : 0;\n\n\tfor (i = 0; i < kbc->hw_support->max_rows; i++)\n\t\twritel(rst_val, kbc->mmio + KBC_ROW0_MASK_0 + i * 4);\n}\n\nstatic void tegra_kbc_config_pins(struct tegra_kbc *kbc)\n{\n\tint i;\n\n\tfor (i = 0; i < KBC_MAX_GPIO; i++) {\n\t\tu32 r_shft = 5 * (i % 6);\n\t\tu32 c_shft = 4 * (i % 8);\n\t\tu32 r_mask = 0x1f << r_shft;\n\t\tu32 c_mask = 0x0f << c_shft;\n\t\tu32 r_offs = (i / 6) * 4 + KBC_ROW_CFG0_0;\n\t\tu32 c_offs = (i / 8) * 4 + KBC_COL_CFG0_0;\n\t\tu32 row_cfg = readl(kbc->mmio + r_offs);\n\t\tu32 col_cfg = readl(kbc->mmio + c_offs);\n\n\t\trow_cfg &= ~r_mask;\n\t\tcol_cfg &= ~c_mask;\n\n\t\tswitch (kbc->pin_cfg[i].type) {\n\t\tcase PIN_CFG_ROW:\n\t\t\trow_cfg |= ((kbc->pin_cfg[i].num << 1) | 1) << r_shft;\n\t\t\tbreak;\n\n\t\tcase PIN_CFG_COL:\n\t\t\tcol_cfg |= ((kbc->pin_cfg[i].num << 1) | 1) << c_shft;\n\t\t\tbreak;\n\n\t\tcase PIN_CFG_IGNORE:\n\t\t\tbreak;\n\t\t}\n\n\t\twritel(row_cfg, kbc->mmio + r_offs);\n\t\twritel(col_cfg, kbc->mmio + c_offs);\n\t}\n}\n\nstatic int tegra_kbc_start(struct tegra_kbc *kbc)\n{\n\tunsigned int debounce_cnt;\n\tu32 val = 0;\n\tint ret;\n\n\tret = clk_prepare_enable(kbc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treset_control_assert(kbc->rst);\n\tudelay(100);\n\treset_control_deassert(kbc->rst);\n\tudelay(100);\n\n\ttegra_kbc_config_pins(kbc);\n\ttegra_kbc_setup_wakekeys(kbc, false);\n\n\twritel(kbc->repeat_cnt, kbc->mmio + KBC_RPT_DLY_0);\n\n\t \n\tdebounce_cnt = min(kbc->debounce_cnt, KBC_MAX_DEBOUNCE_CNT);\n\tval = KBC_DEBOUNCE_CNT_SHIFT(debounce_cnt);\n\tval |= KBC_FIFO_TH_CNT_SHIFT(1);  \n\tval |= KBC_CONTROL_FIFO_CNT_INT_EN;   \n\tval |= KBC_CONTROL_KBC_EN;      \n\twritel(val, kbc->mmio + KBC_CONTROL_0);\n\n\t \n\tval = readl(kbc->mmio + KBC_INIT_DLY_0);\n\tkbc->cp_dly_jiffies = usecs_to_jiffies((val & 0xfffff) * 32);\n\n\tkbc->num_pressed_keys = 0;\n\n\t \n\twhile (1) {\n\t\tval = readl(kbc->mmio + KBC_INT_0);\n\t\tval >>= 4;\n\t\tif (!val)\n\t\t\tbreak;\n\n\t\tval = readl(kbc->mmio + KBC_KP_ENT0_0);\n\t\tval = readl(kbc->mmio + KBC_KP_ENT1_0);\n\t}\n\twritel(0x7, kbc->mmio + KBC_INT_0);\n\n\tenable_irq(kbc->irq);\n\n\treturn 0;\n}\n\nstatic void tegra_kbc_stop(struct tegra_kbc *kbc)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&kbc->lock, flags);\n\tval = readl(kbc->mmio + KBC_CONTROL_0);\n\tval &= ~1;\n\twritel(val, kbc->mmio + KBC_CONTROL_0);\n\tspin_unlock_irqrestore(&kbc->lock, flags);\n\n\tdisable_irq(kbc->irq);\n\tdel_timer_sync(&kbc->timer);\n\n\tclk_disable_unprepare(kbc->clk);\n}\n\nstatic int tegra_kbc_open(struct input_dev *dev)\n{\n\tstruct tegra_kbc *kbc = input_get_drvdata(dev);\n\n\treturn tegra_kbc_start(kbc);\n}\n\nstatic void tegra_kbc_close(struct input_dev *dev)\n{\n\tstruct tegra_kbc *kbc = input_get_drvdata(dev);\n\n\treturn tegra_kbc_stop(kbc);\n}\n\nstatic bool tegra_kbc_check_pin_cfg(const struct tegra_kbc *kbc,\n\t\t\t\t\tunsigned int *num_rows)\n{\n\tint i;\n\n\t*num_rows = 0;\n\n\tfor (i = 0; i < KBC_MAX_GPIO; i++) {\n\t\tconst struct tegra_kbc_pin_cfg *pin_cfg = &kbc->pin_cfg[i];\n\n\t\tswitch (pin_cfg->type) {\n\t\tcase PIN_CFG_ROW:\n\t\t\tif (pin_cfg->num >= kbc->hw_support->max_rows) {\n\t\t\t\tdev_err(kbc->dev,\n\t\t\t\t\t\"pin_cfg[%d]: invalid row number %d\\n\",\n\t\t\t\t\ti, pin_cfg->num);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t(*num_rows)++;\n\t\t\tbreak;\n\n\t\tcase PIN_CFG_COL:\n\t\t\tif (pin_cfg->num >= kbc->hw_support->max_columns) {\n\t\t\t\tdev_err(kbc->dev,\n\t\t\t\t\t\"pin_cfg[%d]: invalid column number %d\\n\",\n\t\t\t\t\ti, pin_cfg->num);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PIN_CFG_IGNORE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(kbc->dev,\n\t\t\t\t\"pin_cfg[%d]: invalid entry type %d\\n\",\n\t\t\t\tpin_cfg->type, pin_cfg->num);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int tegra_kbc_parse_dt(struct tegra_kbc *kbc)\n{\n\tstruct device_node *np = kbc->dev->of_node;\n\tu32 prop;\n\tint i;\n\tu32 num_rows = 0;\n\tu32 num_cols = 0;\n\tu32 cols_cfg[KBC_MAX_GPIO];\n\tu32 rows_cfg[KBC_MAX_GPIO];\n\tint proplen;\n\tint ret;\n\n\tif (!of_property_read_u32(np, \"nvidia,debounce-delay-ms\", &prop))\n\t\tkbc->debounce_cnt = prop;\n\n\tif (!of_property_read_u32(np, \"nvidia,repeat-delay-ms\", &prop))\n\t\tkbc->repeat_cnt = prop;\n\n\tkbc->use_ghost_filter = of_property_present(np, \"nvidia,needs-ghost-filter\");\n\n\tif (of_property_read_bool(np, \"wakeup-source\") ||\n\t    of_property_read_bool(np, \"nvidia,wakeup-source\"))  \n\t\tkbc->wakeup = true;\n\n\tif (!of_get_property(np, \"nvidia,kbc-row-pins\", &proplen)) {\n\t\tdev_err(kbc->dev, \"property nvidia,kbc-row-pins not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\tnum_rows = proplen / sizeof(u32);\n\n\tif (!of_get_property(np, \"nvidia,kbc-col-pins\", &proplen)) {\n\t\tdev_err(kbc->dev, \"property nvidia,kbc-col-pins not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\tnum_cols = proplen / sizeof(u32);\n\n\tif (num_rows > kbc->hw_support->max_rows) {\n\t\tdev_err(kbc->dev,\n\t\t\t\"Number of rows is more than supported by hardware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_cols > kbc->hw_support->max_columns) {\n\t\tdev_err(kbc->dev,\n\t\t\t\"Number of cols is more than supported by hardware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_get_property(np, \"linux,keymap\", &proplen)) {\n\t\tdev_err(kbc->dev, \"property linux,keymap not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!num_rows || !num_cols || ((num_rows + num_cols) > KBC_MAX_GPIO)) {\n\t\tdev_err(kbc->dev,\n\t\t\t\"keypad rows/columns not properly specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < kbc->num_rows_and_columns; i++)\n\t\tkbc->pin_cfg[i].type = PIN_CFG_IGNORE;\n\n\tret = of_property_read_u32_array(np, \"nvidia,kbc-row-pins\",\n\t\t\t\trows_cfg, num_rows);\n\tif (ret < 0) {\n\t\tdev_err(kbc->dev, \"Rows configurations are not proper\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_array(np, \"nvidia,kbc-col-pins\",\n\t\t\t\tcols_cfg, num_cols);\n\tif (ret < 0) {\n\t\tdev_err(kbc->dev, \"Cols configurations are not proper\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tkbc->pin_cfg[rows_cfg[i]].type = PIN_CFG_ROW;\n\t\tkbc->pin_cfg[rows_cfg[i]].num = i;\n\t}\n\n\tfor (i = 0; i < num_cols; i++) {\n\t\tkbc->pin_cfg[cols_cfg[i]].type = PIN_CFG_COL;\n\t\tkbc->pin_cfg[cols_cfg[i]].num = i;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tegra_kbc_hw_support tegra20_kbc_hw_support = {\n\t.max_rows\t= 16,\n\t.max_columns\t= 8,\n};\n\nstatic const struct tegra_kbc_hw_support tegra11_kbc_hw_support = {\n\t.max_rows\t= 11,\n\t.max_columns\t= 8,\n};\n\nstatic const struct of_device_id tegra_kbc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra114-kbc\", .data = &tegra11_kbc_hw_support},\n\t{ .compatible = \"nvidia,tegra30-kbc\", .data = &tegra20_kbc_hw_support},\n\t{ .compatible = \"nvidia,tegra20-kbc\", .data = &tegra20_kbc_hw_support},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_kbc_of_match);\n\nstatic int tegra_kbc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_kbc *kbc;\n\tint err;\n\tint num_rows = 0;\n\tunsigned int debounce_cnt;\n\tunsigned int scan_time_rows;\n\tunsigned int keymap_rows;\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_device(tegra_kbc_of_match, &pdev->dev);\n\n\tkbc = devm_kzalloc(&pdev->dev, sizeof(*kbc), GFP_KERNEL);\n\tif (!kbc) {\n\t\tdev_err(&pdev->dev, \"failed to alloc memory for kbc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkbc->dev = &pdev->dev;\n\tkbc->hw_support = match->data;\n\tkbc->max_keys = kbc->hw_support->max_rows *\n\t\t\t\tkbc->hw_support->max_columns;\n\tkbc->num_rows_and_columns = kbc->hw_support->max_rows +\n\t\t\t\t\tkbc->hw_support->max_columns;\n\tkeymap_rows = kbc->max_keys;\n\tspin_lock_init(&kbc->lock);\n\n\terr = tegra_kbc_parse_dt(kbc);\n\tif (err)\n\t\treturn err;\n\n\tif (!tegra_kbc_check_pin_cfg(kbc, &num_rows))\n\t\treturn -EINVAL;\n\n\tkbc->irq = platform_get_irq(pdev, 0);\n\tif (kbc->irq < 0)\n\t\treturn -ENXIO;\n\n\tkbc->idev = devm_input_allocate_device(&pdev->dev);\n\tif (!kbc->idev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttimer_setup(&kbc->timer, tegra_kbc_keypress_timer, 0);\n\n\tkbc->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(kbc->mmio))\n\t\treturn PTR_ERR(kbc->mmio);\n\n\tkbc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(kbc->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get keyboard clock\\n\");\n\t\treturn PTR_ERR(kbc->clk);\n\t}\n\n\tkbc->rst = devm_reset_control_get(&pdev->dev, \"kbc\");\n\tif (IS_ERR(kbc->rst)) {\n\t\tdev_err(&pdev->dev, \"failed to get keyboard reset\\n\");\n\t\treturn PTR_ERR(kbc->rst);\n\t}\n\n\t \n\tdebounce_cnt = min(kbc->debounce_cnt, KBC_MAX_DEBOUNCE_CNT);\n\tscan_time_rows = (KBC_ROW_SCAN_TIME + debounce_cnt) * num_rows;\n\tkbc->repoll_dly = KBC_ROW_SCAN_DLY + scan_time_rows + kbc->repeat_cnt;\n\tkbc->repoll_dly = DIV_ROUND_UP(kbc->repoll_dly, KBC_CYCLE_MS);\n\n\tkbc->idev->name = pdev->name;\n\tkbc->idev->id.bustype = BUS_HOST;\n\tkbc->idev->dev.parent = &pdev->dev;\n\tkbc->idev->open = tegra_kbc_open;\n\tkbc->idev->close = tegra_kbc_close;\n\n\tif (kbc->keymap_data && kbc->use_fn_map)\n\t\tkeymap_rows *= 2;\n\n\terr = matrix_keypad_build_keymap(kbc->keymap_data, NULL,\n\t\t\t\t\t keymap_rows,\n\t\t\t\t\t kbc->hw_support->max_columns,\n\t\t\t\t\t kbc->keycode, kbc->idev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to setup keymap\\n\");\n\t\treturn err;\n\t}\n\n\t__set_bit(EV_REP, kbc->idev->evbit);\n\tinput_set_capability(kbc->idev, EV_MSC, MSC_SCAN);\n\n\tinput_set_drvdata(kbc->idev, kbc);\n\n\terr = devm_request_irq(&pdev->dev, kbc->irq, tegra_kbc_isr,\n\t\t\t       IRQF_TRIGGER_HIGH | IRQF_NO_AUTOEN,\n\t\t\t       pdev->name, kbc);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to request keyboard IRQ\\n\");\n\t\treturn err;\n\t}\n\n\terr = input_register_device(kbc->idev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, kbc);\n\tdevice_init_wakeup(&pdev->dev, kbc->wakeup);\n\n\treturn 0;\n}\n\nstatic void tegra_kbc_set_keypress_interrupt(struct tegra_kbc *kbc, bool enable)\n{\n\tu32 val;\n\n\tval = readl(kbc->mmio + KBC_CONTROL_0);\n\tif (enable)\n\t\tval |= KBC_CONTROL_KEYPRESS_INT_EN;\n\telse\n\t\tval &= ~KBC_CONTROL_KEYPRESS_INT_EN;\n\twritel(val, kbc->mmio + KBC_CONTROL_0);\n}\n\nstatic int tegra_kbc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct tegra_kbc *kbc = platform_get_drvdata(pdev);\n\n\tmutex_lock(&kbc->idev->mutex);\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tdisable_irq(kbc->irq);\n\t\tdel_timer_sync(&kbc->timer);\n\t\ttegra_kbc_set_fifo_interrupt(kbc, false);\n\n\t\t \n\t\twritel(0x7, kbc->mmio + KBC_INT_0);\n\t\t \n\t\tkbc->cp_to_wkup_dly = readl(kbc->mmio + KBC_TO_CNT_0);\n\t\twritel(0, kbc->mmio + KBC_TO_CNT_0);\n\n\t\ttegra_kbc_setup_wakekeys(kbc, true);\n\t\tmsleep(30);\n\n\t\tkbc->keypress_caused_wake = false;\n\t\t \n\t\ttegra_kbc_set_keypress_interrupt(kbc, true);\n\t\tenable_irq(kbc->irq);\n\t\tenable_irq_wake(kbc->irq);\n\t} else {\n\t\tif (input_device_enabled(kbc->idev))\n\t\t\ttegra_kbc_stop(kbc);\n\t}\n\tmutex_unlock(&kbc->idev->mutex);\n\n\treturn 0;\n}\n\nstatic int tegra_kbc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct tegra_kbc *kbc = platform_get_drvdata(pdev);\n\tint err = 0;\n\n\tmutex_lock(&kbc->idev->mutex);\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tdisable_irq_wake(kbc->irq);\n\t\ttegra_kbc_setup_wakekeys(kbc, false);\n\t\t \n\t\ttegra_kbc_set_keypress_interrupt(kbc, false);\n\n\t\t \n\t\twritel(kbc->cp_to_wkup_dly, kbc->mmio + KBC_TO_CNT_0);\n\n\t\ttegra_kbc_set_fifo_interrupt(kbc, true);\n\n\t\tif (kbc->keypress_caused_wake && kbc->wakeup_key) {\n\t\t\t \n\t\t\tinput_report_key(kbc->idev, kbc->wakeup_key, 1);\n\t\t\tinput_sync(kbc->idev);\n\t\t\tinput_report_key(kbc->idev, kbc->wakeup_key, 0);\n\t\t\tinput_sync(kbc->idev);\n\t\t}\n\t} else {\n\t\tif (input_device_enabled(kbc->idev))\n\t\t\terr = tegra_kbc_start(kbc);\n\t}\n\tmutex_unlock(&kbc->idev->mutex);\n\n\treturn err;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tegra_kbc_pm_ops,\n\t\t\t\ttegra_kbc_suspend, tegra_kbc_resume);\n\nstatic struct platform_driver tegra_kbc_driver = {\n\t.probe\t\t= tegra_kbc_probe,\n\t.driver\t= {\n\t\t.name\t= \"tegra-kbc\",\n\t\t.pm\t= pm_sleep_ptr(&tegra_kbc_pm_ops),\n\t\t.of_match_table = tegra_kbc_of_match,\n\t},\n};\nmodule_platform_driver(tegra_kbc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Rakesh Iyer <riyer@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra matrix keyboard controller driver\");\nMODULE_ALIAS(\"platform:tegra-kbc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}