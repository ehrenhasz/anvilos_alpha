{
  "module_name": "qt2160.c",
  "hash_id": "0caf57f59ceabd62f514032575265d9058141488ebe4e95f08c80e4d0f3f2a72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/qt2160.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n\n#define QT2160_VALID_CHIPID  0x11\n\n#define QT2160_CMD_CHIPID     0\n#define QT2160_CMD_CODEVER    1\n#define QT2160_CMD_GSTAT      2\n#define QT2160_CMD_KEYS3      3\n#define QT2160_CMD_KEYS4      4\n#define QT2160_CMD_SLIDE      5\n#define QT2160_CMD_GPIOS      6\n#define QT2160_CMD_SUBVER     7\n#define QT2160_CMD_CALIBRATE  10\n#define QT2160_CMD_DRIVE_X    70\n#define QT2160_CMD_PWMEN_X    74\n#define QT2160_CMD_PWM_DUTY   76\n\n#define QT2160_NUM_LEDS_X\t8\n\n#define QT2160_CYCLE_INTERVAL\t2000  \n\nstatic unsigned char qt2160_key2code[] = {\n\tKEY_0, KEY_1, KEY_2, KEY_3,\n\tKEY_4, KEY_5, KEY_6, KEY_7,\n\tKEY_8, KEY_9, KEY_A, KEY_B,\n\tKEY_C, KEY_D, KEY_E, KEY_F,\n};\n\n#ifdef CONFIG_LEDS_CLASS\nstruct qt2160_led {\n\tstruct qt2160_data *qt2160;\n\tstruct led_classdev cdev;\n\tchar name[32];\n\tint id;\n\tenum led_brightness brightness;\n};\n#endif\n\nstruct qt2160_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tunsigned short keycodes[ARRAY_SIZE(qt2160_key2code)];\n\tu16 key_matrix;\n#ifdef CONFIG_LEDS_CLASS\n\tstruct qt2160_led leds[QT2160_NUM_LEDS_X];\n#endif\n};\n\nstatic int qt2160_read(struct i2c_client *client, u8 reg);\nstatic int qt2160_write(struct i2c_client *client, u8 reg, u8 data);\n\n#ifdef CONFIG_LEDS_CLASS\n\nstatic int qt2160_led_set(struct led_classdev *cdev,\n\t\t\t  enum led_brightness value)\n{\n\tstruct qt2160_led *led = container_of(cdev, struct qt2160_led, cdev);\n\tstruct qt2160_data *qt2160 = led->qt2160;\n\tstruct i2c_client *client = qt2160->client;\n\tu32 drive, pwmen;\n\n\tif (value != led->brightness) {\n\t\tdrive = qt2160_read(client, QT2160_CMD_DRIVE_X);\n\t\tpwmen = qt2160_read(client, QT2160_CMD_PWMEN_X);\n\t\tif (value != LED_OFF) {\n\t\t\tdrive |= BIT(led->id);\n\t\t\tpwmen |= BIT(led->id);\n\n\t\t} else {\n\t\t\tdrive &= ~BIT(led->id);\n\t\t\tpwmen &= ~BIT(led->id);\n\t\t}\n\t\tqt2160_write(client, QT2160_CMD_DRIVE_X, drive);\n\t\tqt2160_write(client, QT2160_CMD_PWMEN_X, pwmen);\n\n\t\t \n\t\tif (value != LED_OFF)\n\t\t\tqt2160_write(client, QT2160_CMD_PWM_DUTY, value);\n\n\t\tled->brightness = value;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n\nstatic int qt2160_read_block(struct i2c_client *client,\n\t\t\t     u8 inireg, u8 *buffer, unsigned int count)\n{\n\tint error, idx = 0;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\t{\n\n\t\terror = i2c_smbus_write_byte(client, inireg + idx);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"couldn't send request. Returned %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = i2c_master_recv(client, buffer, count);\n\t\tif (error != count) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"couldn't read registers. Returned %d bytes\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t} else {\n\n\t\twhile (count--) {\n\t\t\tint data;\n\n\t\t\terror = i2c_smbus_write_byte(client, inireg + idx);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't send request. Returned %d\\n\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tdata = i2c_smbus_read_byte(client);\n\t\t\tif (data < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"couldn't read register. Returned %d\\n\", data);\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tbuffer[idx++] = data;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void qt2160_get_key_matrix(struct input_dev *input)\n{\n\tstruct qt2160_data *qt2160 = input_get_drvdata(input);\n\tstruct i2c_client *client = qt2160->client;\n\tu8 regs[6];\n\tu16 old_matrix, new_matrix;\n\tint ret, i, mask;\n\n\tdev_dbg(&client->dev, \"requesting keys...\\n\");\n\n\t \n\tret = qt2160_read_block(client, QT2160_CMD_GSTAT, regs, 6);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"could not perform chip read.\\n\");\n\t\treturn;\n\t}\n\n\told_matrix = qt2160->key_matrix;\n\tqt2160->key_matrix = new_matrix = (regs[2] << 8) | regs[1];\n\n\tmask = 0x01;\n\tfor (i = 0; i < 16; ++i, mask <<= 1) {\n\t\tint keyval = new_matrix & mask;\n\n\t\tif ((old_matrix & mask) != keyval) {\n\t\t\tinput_report_key(input, qt2160->keycodes[i], keyval);\n\t\t\tdev_dbg(&client->dev, \"key %d %s\\n\",\n\t\t\t\ti, keyval ? \"pressed\" : \"released\");\n\t\t}\n\t}\n\n\tinput_sync(input);\n}\n\nstatic irqreturn_t qt2160_irq(int irq, void *data)\n{\n\tstruct input_dev *input = data;\n\n\tqt2160_get_key_matrix(input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qt2160_read(struct i2c_client *client, u8 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte(client, reg);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"couldn't send request. Returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"couldn't read register. Returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int qt2160_write(struct i2c_client *client, u8 reg, u8 data)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, reg, data);\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"couldn't write data. Returned %d\\n\", ret);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_LEDS_CLASS\n\nstatic int qt2160_register_leds(struct qt2160_data *qt2160)\n{\n\tstruct i2c_client *client = qt2160->client;\n\tint error;\n\tint i;\n\n\tfor (i = 0; i < QT2160_NUM_LEDS_X; i++) {\n\t\tstruct qt2160_led *led = &qt2160->leds[i];\n\n\t\tsnprintf(led->name, sizeof(led->name), \"qt2160:x%d\", i);\n\t\tled->cdev.name = led->name;\n\t\tled->cdev.brightness_set_blocking = qt2160_led_set;\n\t\tled->cdev.brightness = LED_OFF;\n\t\tled->id = i;\n\t\tled->qt2160 = qt2160;\n\n\t\terror = devm_led_classdev_register(&client->dev, &led->cdev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tqt2160_write(client, QT2160_CMD_DRIVE_X, 0);\n\tqt2160_write(client, QT2160_CMD_PWMEN_X, 0);\n\tqt2160_write(client, QT2160_CMD_PWM_DUTY, 0);\n\n\treturn 0;\n}\n\n#else\n\nstatic inline int qt2160_register_leds(struct qt2160_data *qt2160)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic bool qt2160_identify(struct i2c_client *client)\n{\n\tint id, ver, rev;\n\n\t \n\tid = qt2160_read(client, QT2160_CMD_CHIPID);\n\tif (id != QT2160_VALID_CHIPID) {\n\t\tdev_err(&client->dev, \"ID %d not supported\\n\", id);\n\t\treturn false;\n\t}\n\n\t \n\tver = qt2160_read(client, QT2160_CMD_CODEVER);\n\tif (ver < 0) {\n\t\tdev_err(&client->dev, \"could not get firmware version\\n\");\n\t\treturn false;\n\t}\n\n\t \n\trev = qt2160_read(client, QT2160_CMD_SUBVER);\n\tif (rev < 0) {\n\t\tdev_err(&client->dev, \"could not get firmware revision\\n\");\n\t\treturn false;\n\t}\n\n\tdev_info(&client->dev, \"AT42QT2160 firmware version %d.%d.%d\\n\",\n\t\t\tver >> 4, ver & 0xf, rev);\n\n\treturn true;\n}\n\nstatic int qt2160_probe(struct i2c_client *client)\n{\n\tstruct qt2160_data *qt2160;\n\tstruct input_dev *input;\n\tint i;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {\n\t\tdev_err(&client->dev, \"%s adapter not supported\\n\",\n\t\t\tdev_driver_string(&client->adapter->dev));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!qt2160_identify(client))\n\t\treturn -ENODEV;\n\n\t \n\tqt2160 = devm_kzalloc(&client->dev, sizeof(*qt2160), GFP_KERNEL);\n\tif (!qt2160)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tqt2160->client = client;\n\tqt2160->input = input;\n\n\tinput->name = \"AT42QT2160 Touch Sense Keyboard\";\n\tinput->id.bustype = BUS_I2C;\n\n\tinput->keycode = qt2160->keycodes;\n\tinput->keycodesize = sizeof(qt2160->keycodes[0]);\n\tinput->keycodemax = ARRAY_SIZE(qt2160_key2code);\n\n\t__set_bit(EV_KEY, input->evbit);\n\t__clear_bit(EV_REP, input->evbit);\n\tfor (i = 0; i < ARRAY_SIZE(qt2160_key2code); i++) {\n\t\tqt2160->keycodes[i] = qt2160_key2code[i];\n\t\t__set_bit(qt2160_key2code[i], input->keybit);\n\t}\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\tinput_set_drvdata(input, qt2160);\n\n\t \n\terror = qt2160_write(client, QT2160_CMD_CALIBRATE, 1);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to calibrate device\\n\");\n\t\treturn error;\n\t}\n\n\tif (client->irq) {\n\t\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t\t  NULL, qt2160_irq,\n\t\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t\t  \"qt2160\", input);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to allocate irq %d\\n\", client->irq);\n\t\t\treturn error;\n\t\t}\n\t} else {\n\t\terror = input_setup_polling(input, qt2160_get_key_matrix);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Failed to setup polling\\n\");\n\t\t\treturn error;\n\t\t}\n\t\tinput_set_poll_interval(input, QT2160_CYCLE_INTERVAL);\n\t}\n\n\terror = qt2160_register_leds(qt2160);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register leds\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(qt2160->input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id qt2160_idtable[] = {\n\t{ \"qt2160\", 0, },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, qt2160_idtable);\n\nstatic struct i2c_driver qt2160_driver = {\n\t.driver = {\n\t\t.name\t= \"qt2160\",\n\t},\n\n\t.id_table\t= qt2160_idtable,\n\t.probe\t\t= qt2160_probe,\n};\n\nmodule_i2c_driver(qt2160_driver);\n\nMODULE_AUTHOR(\"Raphael Derosso Pereira <raphaelpereira@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for AT42QT2160 Touch Sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}