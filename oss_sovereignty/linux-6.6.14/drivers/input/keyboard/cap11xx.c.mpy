{
  "module_name": "cap11xx.c",
  "hash_id": "900fb6e9f8a23cfca2d35bd64f843ad50abd8eebf219395bdfa0c49ec7875c96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/cap11xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/leds.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n\n#define CAP11XX_REG_MAIN_CONTROL\t0x00\n#define CAP11XX_REG_MAIN_CONTROL_GAIN_SHIFT\t(6)\n#define CAP11XX_REG_MAIN_CONTROL_GAIN_MASK\t(0xc0)\n#define CAP11XX_REG_MAIN_CONTROL_DLSEEP\t\tBIT(4)\n#define CAP11XX_REG_GENERAL_STATUS\t0x02\n#define CAP11XX_REG_SENSOR_INPUT\t0x03\n#define CAP11XX_REG_NOISE_FLAG_STATUS\t0x0a\n#define CAP11XX_REG_SENOR_DELTA(X)\t(0x10 + (X))\n#define CAP11XX_REG_SENSITIVITY_CONTROL\t0x1f\n#define CAP11XX_REG_CONFIG\t\t0x20\n#define CAP11XX_REG_SENSOR_ENABLE\t0x21\n#define CAP11XX_REG_SENSOR_CONFIG\t0x22\n#define CAP11XX_REG_SENSOR_CONFIG2\t0x23\n#define CAP11XX_REG_SAMPLING_CONFIG\t0x24\n#define CAP11XX_REG_CALIBRATION\t\t0x26\n#define CAP11XX_REG_INT_ENABLE\t\t0x27\n#define CAP11XX_REG_REPEAT_RATE\t\t0x28\n#define CAP11XX_REG_MT_CONFIG\t\t0x2a\n#define CAP11XX_REG_MT_PATTERN_CONFIG\t0x2b\n#define CAP11XX_REG_MT_PATTERN\t\t0x2d\n#define CAP11XX_REG_RECALIB_CONFIG\t0x2f\n#define CAP11XX_REG_SENSOR_THRESH(X)\t(0x30 + (X))\n#define CAP11XX_REG_SENSOR_NOISE_THRESH\t0x38\n#define CAP11XX_REG_STANDBY_CHANNEL\t0x40\n#define CAP11XX_REG_STANDBY_CONFIG\t0x41\n#define CAP11XX_REG_STANDBY_SENSITIVITY\t0x42\n#define CAP11XX_REG_STANDBY_THRESH\t0x43\n#define CAP11XX_REG_CONFIG2\t\t0x44\n#define CAP11XX_REG_CONFIG2_ALT_POL\tBIT(6)\n#define CAP11XX_REG_SENSOR_BASE_CNT(X)\t(0x50 + (X))\n#define CAP11XX_REG_LED_POLARITY\t0x73\n#define CAP11XX_REG_LED_OUTPUT_CONTROL\t0x74\n\n#define CAP11XX_REG_LED_DUTY_CYCLE_1\t0x90\n#define CAP11XX_REG_LED_DUTY_CYCLE_2\t0x91\n#define CAP11XX_REG_LED_DUTY_CYCLE_3\t0x92\n#define CAP11XX_REG_LED_DUTY_CYCLE_4\t0x93\n\n#define CAP11XX_REG_LED_DUTY_MIN_MASK\t(0x0f)\n#define CAP11XX_REG_LED_DUTY_MIN_MASK_SHIFT\t(0)\n#define CAP11XX_REG_LED_DUTY_MAX_MASK\t(0xf0)\n#define CAP11XX_REG_LED_DUTY_MAX_MASK_SHIFT\t(4)\n#define CAP11XX_REG_LED_DUTY_MAX_VALUE\t(15)\n\n#define CAP11XX_REG_SENSOR_CALIB\t(0xb1 + (X))\n#define CAP11XX_REG_SENSOR_CALIB_LSB1\t0xb9\n#define CAP11XX_REG_SENSOR_CALIB_LSB2\t0xba\n#define CAP11XX_REG_PRODUCT_ID\t\t0xfd\n#define CAP11XX_REG_MANUFACTURER_ID\t0xfe\n#define CAP11XX_REG_REVISION\t\t0xff\n\n#define CAP11XX_MANUFACTURER_ID\t0x5d\n\n#ifdef CONFIG_LEDS_CLASS\nstruct cap11xx_led {\n\tstruct cap11xx_priv *priv;\n\tstruct led_classdev cdev;\n\tu32 reg;\n};\n#endif\n\nstruct cap11xx_priv {\n\tstruct regmap *regmap;\n\tstruct input_dev *idev;\n\n\tstruct cap11xx_led *leds;\n\tint num_leds;\n\n\t \n\tu32 keycodes[];\n};\n\nstruct cap11xx_hw_model {\n\tu8 product_id;\n\tunsigned int num_channels;\n\tunsigned int num_leds;\n\tbool no_gain;\n};\n\nenum {\n\tCAP1106,\n\tCAP1126,\n\tCAP1188,\n\tCAP1203,\n\tCAP1206,\n\tCAP1293,\n\tCAP1298\n};\n\nstatic const struct cap11xx_hw_model cap11xx_devices[] = {\n\t[CAP1106] = { .product_id = 0x55, .num_channels = 6, .num_leds = 0, .no_gain = false },\n\t[CAP1126] = { .product_id = 0x53, .num_channels = 6, .num_leds = 2, .no_gain = false },\n\t[CAP1188] = { .product_id = 0x50, .num_channels = 8, .num_leds = 8, .no_gain = false },\n\t[CAP1203] = { .product_id = 0x6d, .num_channels = 3, .num_leds = 0, .no_gain = true },\n\t[CAP1206] = { .product_id = 0x67, .num_channels = 6, .num_leds = 0, .no_gain = true },\n\t[CAP1293] = { .product_id = 0x6f, .num_channels = 3, .num_leds = 0, .no_gain = false },\n\t[CAP1298] = { .product_id = 0x71, .num_channels = 8, .num_leds = 0, .no_gain = false },\n};\n\nstatic const struct reg_default cap11xx_reg_defaults[] = {\n\t{ CAP11XX_REG_MAIN_CONTROL,\t\t0x00 },\n\t{ CAP11XX_REG_GENERAL_STATUS,\t\t0x00 },\n\t{ CAP11XX_REG_SENSOR_INPUT,\t\t0x00 },\n\t{ CAP11XX_REG_NOISE_FLAG_STATUS,\t0x00 },\n\t{ CAP11XX_REG_SENSITIVITY_CONTROL,\t0x2f },\n\t{ CAP11XX_REG_CONFIG,\t\t\t0x20 },\n\t{ CAP11XX_REG_SENSOR_ENABLE,\t\t0x3f },\n\t{ CAP11XX_REG_SENSOR_CONFIG,\t\t0xa4 },\n\t{ CAP11XX_REG_SENSOR_CONFIG2,\t\t0x07 },\n\t{ CAP11XX_REG_SAMPLING_CONFIG,\t\t0x39 },\n\t{ CAP11XX_REG_CALIBRATION,\t\t0x00 },\n\t{ CAP11XX_REG_INT_ENABLE,\t\t0x3f },\n\t{ CAP11XX_REG_REPEAT_RATE,\t\t0x3f },\n\t{ CAP11XX_REG_MT_CONFIG,\t\t0x80 },\n\t{ CAP11XX_REG_MT_PATTERN_CONFIG,\t0x00 },\n\t{ CAP11XX_REG_MT_PATTERN,\t\t0x3f },\n\t{ CAP11XX_REG_RECALIB_CONFIG,\t\t0x8a },\n\t{ CAP11XX_REG_SENSOR_THRESH(0),\t\t0x40 },\n\t{ CAP11XX_REG_SENSOR_THRESH(1),\t\t0x40 },\n\t{ CAP11XX_REG_SENSOR_THRESH(2),\t\t0x40 },\n\t{ CAP11XX_REG_SENSOR_THRESH(3),\t\t0x40 },\n\t{ CAP11XX_REG_SENSOR_THRESH(4),\t\t0x40 },\n\t{ CAP11XX_REG_SENSOR_THRESH(5),\t\t0x40 },\n\t{ CAP11XX_REG_SENSOR_NOISE_THRESH,\t0x01 },\n\t{ CAP11XX_REG_STANDBY_CHANNEL,\t\t0x00 },\n\t{ CAP11XX_REG_STANDBY_CONFIG,\t\t0x39 },\n\t{ CAP11XX_REG_STANDBY_SENSITIVITY,\t0x02 },\n\t{ CAP11XX_REG_STANDBY_THRESH,\t\t0x40 },\n\t{ CAP11XX_REG_CONFIG2,\t\t\t0x40 },\n\t{ CAP11XX_REG_LED_POLARITY,\t\t0x00 },\n\t{ CAP11XX_REG_SENSOR_CALIB_LSB1,\t0x00 },\n\t{ CAP11XX_REG_SENSOR_CALIB_LSB2,\t0x00 },\n};\n\nstatic bool cap11xx_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CAP11XX_REG_MAIN_CONTROL:\n\tcase CAP11XX_REG_SENSOR_INPUT:\n\tcase CAP11XX_REG_SENOR_DELTA(0):\n\tcase CAP11XX_REG_SENOR_DELTA(1):\n\tcase CAP11XX_REG_SENOR_DELTA(2):\n\tcase CAP11XX_REG_SENOR_DELTA(3):\n\tcase CAP11XX_REG_SENOR_DELTA(4):\n\tcase CAP11XX_REG_SENOR_DELTA(5):\n\tcase CAP11XX_REG_PRODUCT_ID:\n\tcase CAP11XX_REG_MANUFACTURER_ID:\n\tcase CAP11XX_REG_REVISION:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config cap11xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CAP11XX_REG_REVISION,\n\t.reg_defaults = cap11xx_reg_defaults,\n\n\t.num_reg_defaults = ARRAY_SIZE(cap11xx_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = cap11xx_volatile_reg,\n};\n\nstatic irqreturn_t cap11xx_thread_func(int irq_num, void *data)\n{\n\tstruct cap11xx_priv *priv = data;\n\tunsigned int status;\n\tint ret, i;\n\n\t \n\tret = regmap_update_bits(priv->regmap, CAP11XX_REG_MAIN_CONTROL, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_read(priv->regmap, CAP11XX_REG_SENSOR_INPUT, &status);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < priv->idev->keycodemax; i++)\n\t\tinput_report_key(priv->idev, priv->keycodes[i],\n\t\t\t\t status & (1 << i));\n\n\tinput_sync(priv->idev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int cap11xx_set_sleep(struct cap11xx_priv *priv, bool sleep)\n{\n\t \n\tif (IS_ENABLED(CONFIG_LEDS_CLASS) && priv->num_leds)\n\t\treturn 0;\n\n\treturn regmap_update_bits(priv->regmap, CAP11XX_REG_MAIN_CONTROL,\n\t\t\t\t  CAP11XX_REG_MAIN_CONTROL_DLSEEP,\n\t\t\t\t  sleep ? CAP11XX_REG_MAIN_CONTROL_DLSEEP : 0);\n}\n\nstatic int cap11xx_input_open(struct input_dev *idev)\n{\n\tstruct cap11xx_priv *priv = input_get_drvdata(idev);\n\n\treturn cap11xx_set_sleep(priv, false);\n}\n\nstatic void cap11xx_input_close(struct input_dev *idev)\n{\n\tstruct cap11xx_priv *priv = input_get_drvdata(idev);\n\n\tcap11xx_set_sleep(priv, true);\n}\n\n#ifdef CONFIG_LEDS_CLASS\nstatic int cap11xx_led_set(struct led_classdev *cdev,\n\t\t\t    enum led_brightness value)\n{\n\tstruct cap11xx_led *led = container_of(cdev, struct cap11xx_led, cdev);\n\tstruct cap11xx_priv *priv = led->priv;\n\n\t \n\treturn regmap_update_bits(priv->regmap,\n\t\t\t\t  CAP11XX_REG_LED_OUTPUT_CONTROL,\n\t\t\t\t  BIT(led->reg),\n\t\t\t\t  value ? BIT(led->reg) : 0);\n}\n\nstatic int cap11xx_init_leds(struct device *dev,\n\t\t\t     struct cap11xx_priv *priv, int num_leds)\n{\n\tstruct device_node *node = dev->of_node, *child;\n\tstruct cap11xx_led *led;\n\tint cnt = of_get_child_count(node);\n\tint error;\n\n\tif (!num_leds || !cnt)\n\t\treturn 0;\n\n\tif (cnt > num_leds)\n\t\treturn -EINVAL;\n\n\tled = devm_kcalloc(dev, cnt, sizeof(struct cap11xx_led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tpriv->leds = led;\n\n\terror = regmap_update_bits(priv->regmap,\n\t\t\t\tCAP11XX_REG_LED_OUTPUT_CONTROL, 0xff, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = regmap_update_bits(priv->regmap, CAP11XX_REG_LED_DUTY_CYCLE_4,\n\t\t\t\tCAP11XX_REG_LED_DUTY_MAX_MASK,\n\t\t\t\tCAP11XX_REG_LED_DUTY_MAX_VALUE <<\n\t\t\t\tCAP11XX_REG_LED_DUTY_MAX_MASK_SHIFT);\n\tif (error)\n\t\treturn error;\n\n\tfor_each_child_of_node(node, child) {\n\t\tu32 reg;\n\n\t\tled->cdev.name =\n\t\t\tof_get_property(child, \"label\", NULL) ? : child->name;\n\t\tled->cdev.default_trigger =\n\t\t\tof_get_property(child, \"linux,default-trigger\", NULL);\n\t\tled->cdev.flags = 0;\n\t\tled->cdev.brightness_set_blocking = cap11xx_led_set;\n\t\tled->cdev.max_brightness = 1;\n\t\tled->cdev.brightness = LED_OFF;\n\n\t\terror = of_property_read_u32(child, \"reg\", &reg);\n\t\tif (error != 0 || reg >= num_leds) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tled->reg = reg;\n\t\tled->priv = priv;\n\n\t\terror = devm_led_classdev_register(dev, &led->cdev);\n\t\tif (error) {\n\t\t\tof_node_put(child);\n\t\t\treturn error;\n\t\t}\n\n\t\tpriv->num_leds++;\n\t\tled++;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int cap11xx_init_leds(struct device *dev,\n\t\t\t     struct cap11xx_priv *priv, int num_leds)\n{\n\treturn 0;\n}\n#endif\n\nstatic int cap11xx_i2c_probe(struct i2c_client *i2c_client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c_client);\n\tstruct device *dev = &i2c_client->dev;\n\tstruct cap11xx_priv *priv;\n\tstruct device_node *node;\n\tconst struct cap11xx_hw_model *cap;\n\tint i, error, irq, gain = 0;\n\tunsigned int val, rev;\n\tu32 gain32;\n\n\tif (id->driver_data >= ARRAY_SIZE(cap11xx_devices)) {\n\t\tdev_err(dev, \"Invalid device ID %lu\\n\", id->driver_data);\n\t\treturn -EINVAL;\n\t}\n\n\tcap = &cap11xx_devices[id->driver_data];\n\tif (!cap || !cap->num_channels) {\n\t\tdev_err(dev, \"Invalid device configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev,\n\t\t\t    struct_size(priv, keycodes, cap->num_channels),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c_client, &cap11xx_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\terror = regmap_read(priv->regmap, CAP11XX_REG_PRODUCT_ID, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != cap->product_id) {\n\t\tdev_err(dev, \"Product ID: Got 0x%02x, expected 0x%02x\\n\",\n\t\t\tval, cap->product_id);\n\t\treturn -ENXIO;\n\t}\n\n\terror = regmap_read(priv->regmap, CAP11XX_REG_MANUFACTURER_ID, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val != CAP11XX_MANUFACTURER_ID) {\n\t\tdev_err(dev, \"Manufacturer ID: Got 0x%02x, expected 0x%02x\\n\",\n\t\t\tval, CAP11XX_MANUFACTURER_ID);\n\t\treturn -ENXIO;\n\t}\n\n\terror = regmap_read(priv->regmap, CAP11XX_REG_REVISION, &rev);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_info(dev, \"CAP11XX detected, model %s, revision 0x%02x\\n\",\n\t\t id->name, rev);\n\tnode = dev->of_node;\n\n\tif (!of_property_read_u32(node, \"microchip,sensor-gain\", &gain32)) {\n\t\tif (cap->no_gain)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"This version doesn't support sensor gain\\n\");\n\t\telse if (is_power_of_2(gain32) && gain32 <= 8)\n\t\t\tgain = ilog2(gain32);\n\t\telse\n\t\t\tdev_err(dev, \"Invalid sensor-gain value %d\\n\", gain32);\n\t}\n\n\tif (id->driver_data == CAP1106 ||\n\t    id->driver_data == CAP1126 ||\n\t    id->driver_data == CAP1188) {\n\t\tif (of_property_read_bool(node, \"microchip,irq-active-high\")) {\n\t\t\terror = regmap_update_bits(priv->regmap,\n\t\t\t\t\t\t   CAP11XX_REG_CONFIG2,\n\t\t\t\t\t\t   CAP11XX_REG_CONFIG2_ALT_POL,\n\t\t\t\t\t\t   0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < cap->num_channels; i++)\n\t\tpriv->keycodes[i] = KEY_A + i;\n\n\tof_property_read_u32_array(node, \"linux,keycodes\",\n\t\t\t\t   priv->keycodes, cap->num_channels);\n\n\tif (!cap->no_gain) {\n\t\terror = regmap_update_bits(priv->regmap,\n\t\t\t\tCAP11XX_REG_MAIN_CONTROL,\n\t\t\t\tCAP11XX_REG_MAIN_CONTROL_GAIN_MASK,\n\t\t\t\tgain << CAP11XX_REG_MAIN_CONTROL_GAIN_SHIFT);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\terror = regmap_write(priv->regmap, CAP11XX_REG_REPEAT_RATE, 0);\n\tif (error)\n\t\treturn error;\n\n\tpriv->idev = devm_input_allocate_device(dev);\n\tif (!priv->idev)\n\t\treturn -ENOMEM;\n\n\tpriv->idev->name = \"CAP11XX capacitive touch sensor\";\n\tpriv->idev->id.bustype = BUS_I2C;\n\tpriv->idev->evbit[0] = BIT_MASK(EV_KEY);\n\n\tif (of_property_read_bool(node, \"autorepeat\"))\n\t\t__set_bit(EV_REP, priv->idev->evbit);\n\n\tfor (i = 0; i < cap->num_channels; i++)\n\t\t__set_bit(priv->keycodes[i], priv->idev->keybit);\n\n\t__clear_bit(KEY_RESERVED, priv->idev->keybit);\n\n\tpriv->idev->keycode = priv->keycodes;\n\tpriv->idev->keycodesize = sizeof(priv->keycodes[0]);\n\tpriv->idev->keycodemax = cap->num_channels;\n\n\tpriv->idev->id.vendor = CAP11XX_MANUFACTURER_ID;\n\tpriv->idev->id.product = cap->product_id;\n\tpriv->idev->id.version = rev;\n\n\tpriv->idev->open = cap11xx_input_open;\n\tpriv->idev->close = cap11xx_input_close;\n\n\terror = cap11xx_init_leds(dev, priv, cap->num_leds);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_drvdata(priv->idev, priv);\n\n\t \n\tcap11xx_set_sleep(priv, true);\n\n\terror = input_register_device(priv->idev);\n\tif (error)\n\t\treturn error;\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"Unable to parse or map IRQ\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\terror = devm_request_threaded_irq(dev, irq, NULL, cap11xx_thread_func,\n\t\t\t\t\t  IRQF_ONESHOT, dev_name(dev), priv);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cap11xx_dt_ids[] = {\n\t{ .compatible = \"microchip,cap1106\", },\n\t{ .compatible = \"microchip,cap1126\", },\n\t{ .compatible = \"microchip,cap1188\", },\n\t{ .compatible = \"microchip,cap1203\", },\n\t{ .compatible = \"microchip,cap1206\", },\n\t{ .compatible = \"microchip,cap1293\", },\n\t{ .compatible = \"microchip,cap1298\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cap11xx_dt_ids);\n\nstatic const struct i2c_device_id cap11xx_i2c_ids[] = {\n\t{ \"cap1106\", CAP1106 },\n\t{ \"cap1126\", CAP1126 },\n\t{ \"cap1188\", CAP1188 },\n\t{ \"cap1203\", CAP1203 },\n\t{ \"cap1206\", CAP1206 },\n\t{ \"cap1293\", CAP1293 },\n\t{ \"cap1298\", CAP1298 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cap11xx_i2c_ids);\n\nstatic struct i2c_driver cap11xx_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"cap11xx\",\n\t\t.of_match_table = cap11xx_dt_ids,\n\t},\n\t.id_table\t= cap11xx_i2c_ids,\n\t.probe\t\t= cap11xx_i2c_probe,\n};\n\nmodule_i2c_driver(cap11xx_i2c_driver);\n\nMODULE_DESCRIPTION(\"Microchip CAP11XX driver\");\nMODULE_AUTHOR(\"Daniel Mack <linux@zonque.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}