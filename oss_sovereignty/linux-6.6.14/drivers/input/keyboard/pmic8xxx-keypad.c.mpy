{
  "module_name": "pmic8xxx-keypad.c",
  "hash_id": "1ade083dd30ba533951fa551c6128304d9d7a3c39df97c875a42aacc09202a86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/pmic8xxx-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/input/matrix_keypad.h>\n\n#define PM8XXX_MAX_ROWS\t\t18\n#define PM8XXX_MAX_COLS\t\t8\n#define PM8XXX_ROW_SHIFT\t3\n#define PM8XXX_MATRIX_MAX_SIZE\t(PM8XXX_MAX_ROWS * PM8XXX_MAX_COLS)\n\n#define PM8XXX_MIN_ROWS\t\t5\n#define PM8XXX_MIN_COLS\t\t5\n\n#define MAX_SCAN_DELAY\t\t128\n#define MIN_SCAN_DELAY\t\t1\n\n \n#define MAX_ROW_HOLD_DELAY\t122000\n#define MIN_ROW_HOLD_DELAY\t30500\n\n#define MAX_DEBOUNCE_TIME\t20\n#define MIN_DEBOUNCE_TIME\t5\n\n#define KEYP_CTRL\t\t\t0x148\n\n#define KEYP_CTRL_EVNTS\t\t\tBIT(0)\n#define KEYP_CTRL_EVNTS_MASK\t\t0x3\n\n#define KEYP_CTRL_SCAN_COLS_SHIFT\t5\n#define KEYP_CTRL_SCAN_COLS_MIN\t\t5\n#define KEYP_CTRL_SCAN_COLS_BITS\t0x3\n\n#define KEYP_CTRL_SCAN_ROWS_SHIFT\t2\n#define KEYP_CTRL_SCAN_ROWS_MIN\t\t5\n#define KEYP_CTRL_SCAN_ROWS_BITS\t0x7\n\n#define KEYP_CTRL_KEYP_EN\t\tBIT(7)\n\n#define KEYP_SCAN\t\t\t0x149\n\n#define KEYP_SCAN_READ_STATE\t\tBIT(0)\n#define KEYP_SCAN_DBOUNCE_SHIFT\t\t1\n#define KEYP_SCAN_PAUSE_SHIFT\t\t3\n#define KEYP_SCAN_ROW_HOLD_SHIFT\t6\n\n#define KEYP_TEST\t\t\t0x14A\n\n#define KEYP_TEST_CLEAR_RECENT_SCAN\tBIT(6)\n#define KEYP_TEST_CLEAR_OLD_SCAN\tBIT(5)\n#define KEYP_TEST_READ_RESET\t\tBIT(4)\n#define KEYP_TEST_DTEST_EN\t\tBIT(3)\n#define KEYP_TEST_ABORT_READ\t\tBIT(0)\n\n#define KEYP_TEST_DBG_SELECT_SHIFT\t1\n\n \n#define KEYP_RECENT_DATA\t\t0x14B\n#define KEYP_OLD_DATA\t\t\t0x14C\n\n#define KEYP_CLOCK_FREQ\t\t\t32768\n\n \nstruct pmic8xxx_kp {\n\tunsigned int num_rows;\n\tunsigned int num_cols;\n\tstruct input_dev *input;\n\tstruct regmap *regmap;\n\tint key_sense_irq;\n\tint key_stuck_irq;\n\n\tunsigned short keycodes[PM8XXX_MATRIX_MAX_SIZE];\n\n\tstruct device *dev;\n\tu16 keystate[PM8XXX_MAX_ROWS];\n\tu16 stuckstate[PM8XXX_MAX_ROWS];\n\n\tu8 ctrl_reg;\n};\n\nstatic u8 pmic8xxx_col_state(struct pmic8xxx_kp *kp, u8 col)\n{\n\t \n\tif (col == 0x00)\n\t\treturn 1 << kp->num_cols;\n\telse\n\t\treturn col & ((1 << kp->num_cols) - 1);\n}\n\n \nstatic int pmic8xxx_chk_sync_read(struct pmic8xxx_kp *kp)\n{\n\tint rc;\n\tunsigned int scan_val;\n\n\trc = regmap_read(kp->regmap, KEYP_SCAN, &scan_val);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev, \"Error reading KEYP_SCAN reg, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tscan_val |= 0x1;\n\n\trc = regmap_write(kp->regmap, KEYP_SCAN, scan_val);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev, \"Error writing KEYP_SCAN reg, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tudelay((2 * DIV_ROUND_UP(USEC_PER_SEC, KEYP_CLOCK_FREQ)) + 1);\n\n\treturn rc;\n}\n\nstatic int pmic8xxx_kp_read_data(struct pmic8xxx_kp *kp, u16 *state,\n\t\t\t\t\tu16 data_reg, int read_rows)\n{\n\tint rc, row;\n\tunsigned int val;\n\n\tfor (row = 0; row < read_rows; row++) {\n\t\trc = regmap_read(kp->regmap, data_reg, &val);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tdev_dbg(kp->dev, \"%d = %d\\n\", row, val);\n\t\tstate[row] = pmic8xxx_col_state(kp, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int pmic8xxx_kp_read_matrix(struct pmic8xxx_kp *kp, u16 *new_state,\n\t\t\t\t\t u16 *old_state)\n{\n\tint rc, read_rows;\n\tunsigned int scan_val;\n\n\tif (kp->num_rows < PM8XXX_MIN_ROWS)\n\t\tread_rows = PM8XXX_MIN_ROWS;\n\telse\n\t\tread_rows = kp->num_rows;\n\n\tpmic8xxx_chk_sync_read(kp);\n\n\tif (old_state) {\n\t\trc = pmic8xxx_kp_read_data(kp, old_state, KEYP_OLD_DATA,\n\t\t\t\t\t\tread_rows);\n\t\tif (rc < 0) {\n\t\t\tdev_err(kp->dev,\n\t\t\t\t\"Error reading KEYP_OLD_DATA, rc=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = pmic8xxx_kp_read_data(kp, new_state, KEYP_RECENT_DATA,\n\t\t\t\t\t read_rows);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev,\n\t\t\t\"Error reading KEYP_RECENT_DATA, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tudelay((4 * DIV_ROUND_UP(USEC_PER_SEC, KEYP_CLOCK_FREQ)) + 1);\n\n\trc = regmap_read(kp->regmap, KEYP_SCAN, &scan_val);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev, \"Error reading KEYP_SCAN reg, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tscan_val &= 0xFE;\n\trc = regmap_write(kp->regmap, KEYP_SCAN, scan_val);\n\tif (rc < 0)\n\t\tdev_err(kp->dev, \"Error writing KEYP_SCAN reg, rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void __pmic8xxx_kp_scan_matrix(struct pmic8xxx_kp *kp, u16 *new_state,\n\t\t\t\t\t u16 *old_state)\n{\n\tint row, col, code;\n\n\tfor (row = 0; row < kp->num_rows; row++) {\n\t\tint bits_changed = new_state[row] ^ old_state[row];\n\n\t\tif (!bits_changed)\n\t\t\tcontinue;\n\n\t\tfor (col = 0; col < kp->num_cols; col++) {\n\t\t\tif (!(bits_changed & (1 << col)))\n\t\t\t\tcontinue;\n\n\t\t\tdev_dbg(kp->dev, \"key [%d:%d] %s\\n\", row, col,\n\t\t\t\t\t!(new_state[row] & (1 << col)) ?\n\t\t\t\t\t\"pressed\" : \"released\");\n\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, PM8XXX_ROW_SHIFT);\n\n\t\t\tinput_event(kp->input, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(kp->input,\n\t\t\t\t\tkp->keycodes[code],\n\t\t\t\t\t!(new_state[row] & (1 << col)));\n\n\t\t\tinput_sync(kp->input);\n\t\t}\n\t}\n}\n\nstatic bool pmic8xxx_detect_ghost_keys(struct pmic8xxx_kp *kp, u16 *new_state)\n{\n\tint row, found_first = -1;\n\tu16 check, row_state;\n\n\tcheck = 0;\n\tfor (row = 0; row < kp->num_rows; row++) {\n\t\trow_state = (~new_state[row]) &\n\t\t\t\t ((1 << kp->num_cols) - 1);\n\n\t\tif (hweight16(row_state) > 1) {\n\t\t\tif (found_first == -1)\n\t\t\t\tfound_first = row;\n\t\t\tif (check & row_state) {\n\t\t\t\tdev_dbg(kp->dev, \"detected ghost key on row[%d]\"\n\t\t\t\t\t \" and row[%d]\\n\", found_first, row);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcheck |= row_state;\n\t}\n\treturn false;\n}\n\nstatic int pmic8xxx_kp_scan_matrix(struct pmic8xxx_kp *kp, unsigned int events)\n{\n\tu16 new_state[PM8XXX_MAX_ROWS];\n\tu16 old_state[PM8XXX_MAX_ROWS];\n\tint rc;\n\n\tswitch (events) {\n\tcase 0x1:\n\t\trc = pmic8xxx_kp_read_matrix(kp, new_state, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (pmic8xxx_detect_ghost_keys(kp, new_state))\n\t\t\treturn 0;\n\t\t__pmic8xxx_kp_scan_matrix(kp, new_state, kp->keystate);\n\t\tmemcpy(kp->keystate, new_state, sizeof(new_state));\n\tbreak;\n\tcase 0x3:  \n\t\trc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t__pmic8xxx_kp_scan_matrix(kp, old_state, kp->keystate);\n\t\t__pmic8xxx_kp_scan_matrix(kp, new_state, old_state);\n\t\tmemcpy(kp->keystate, new_state, sizeof(new_state));\n\tbreak;\n\tcase 0x2:\n\t\tdev_dbg(kp->dev, \"Some key events were lost\\n\");\n\t\trc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\t__pmic8xxx_kp_scan_matrix(kp, old_state, kp->keystate);\n\t\t__pmic8xxx_kp_scan_matrix(kp, new_state, old_state);\n\t\tmemcpy(kp->keystate, new_state, sizeof(new_state));\n\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\n \nstatic irqreturn_t pmic8xxx_kp_stuck_irq(int irq, void *data)\n{\n\tu16 new_state[PM8XXX_MAX_ROWS];\n\tu16 old_state[PM8XXX_MAX_ROWS];\n\tint rc;\n\tstruct pmic8xxx_kp *kp = data;\n\n\trc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev, \"failed to read keypad matrix\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t__pmic8xxx_kp_scan_matrix(kp, new_state, kp->stuckstate);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pmic8xxx_kp_irq(int irq, void *data)\n{\n\tstruct pmic8xxx_kp *kp = data;\n\tunsigned int ctrl_val, events;\n\tint rc;\n\n\trc = regmap_read(kp->regmap, KEYP_CTRL, &ctrl_val);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev, \"failed to read keyp_ctrl register\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tevents = ctrl_val & KEYP_CTRL_EVNTS_MASK;\n\n\trc = pmic8xxx_kp_scan_matrix(kp, events);\n\tif (rc < 0)\n\t\tdev_err(kp->dev, \"failed to scan matrix\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pmic8xxx_kpd_init(struct pmic8xxx_kp *kp,\n\t\t\t     struct platform_device *pdev)\n{\n\tconst struct device_node *of_node = pdev->dev.of_node;\n\tunsigned int scan_delay_ms;\n\tunsigned int row_hold_ns;\n\tunsigned int debounce_ms;\n\tint bits, rc, cycles;\n\tu8 scan_val = 0, ctrl_val = 0;\n\tstatic const u8 row_bits[] = {\n\t\t0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7,\n\t};\n\n\t \n\tif (kp->num_cols < KEYP_CTRL_SCAN_COLS_MIN)\n\t\tbits = 0;\n\telse\n\t\tbits = kp->num_cols - KEYP_CTRL_SCAN_COLS_MIN;\n\tctrl_val = (bits & KEYP_CTRL_SCAN_COLS_BITS) <<\n\t\tKEYP_CTRL_SCAN_COLS_SHIFT;\n\n\t \n\tif (kp->num_rows < KEYP_CTRL_SCAN_ROWS_MIN)\n\t\tbits = 0;\n\telse\n\t\tbits = row_bits[kp->num_rows - KEYP_CTRL_SCAN_ROWS_MIN];\n\n\tctrl_val |= (bits << KEYP_CTRL_SCAN_ROWS_SHIFT);\n\n\trc = regmap_write(kp->regmap, KEYP_CTRL, ctrl_val);\n\tif (rc < 0) {\n\t\tdev_err(kp->dev, \"Error writing KEYP_CTRL reg, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (of_property_read_u32(of_node, \"scan-delay\", &scan_delay_ms))\n\t\tscan_delay_ms = MIN_SCAN_DELAY;\n\n\tif (scan_delay_ms > MAX_SCAN_DELAY || scan_delay_ms < MIN_SCAN_DELAY ||\n\t    !is_power_of_2(scan_delay_ms)) {\n\t\tdev_err(&pdev->dev, \"invalid keypad scan time supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(of_node, \"row-hold\", &row_hold_ns))\n\t\trow_hold_ns = MIN_ROW_HOLD_DELAY;\n\n\tif (row_hold_ns > MAX_ROW_HOLD_DELAY ||\n\t    row_hold_ns < MIN_ROW_HOLD_DELAY ||\n\t    ((row_hold_ns % MIN_ROW_HOLD_DELAY) != 0)) {\n\t\tdev_err(&pdev->dev, \"invalid keypad row hold time supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(of_node, \"debounce\", &debounce_ms))\n\t\tdebounce_ms = MIN_DEBOUNCE_TIME;\n\n\tif (((debounce_ms % 5) != 0) ||\n\t    debounce_ms > MAX_DEBOUNCE_TIME ||\n\t    debounce_ms < MIN_DEBOUNCE_TIME) {\n\t\tdev_err(&pdev->dev, \"invalid debounce time supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbits = (debounce_ms / 5) - 1;\n\n\tscan_val |= (bits << KEYP_SCAN_DBOUNCE_SHIFT);\n\n\tbits = fls(scan_delay_ms) - 1;\n\tscan_val |= (bits << KEYP_SCAN_PAUSE_SHIFT);\n\n\t \n\tcycles = (row_hold_ns * KEYP_CLOCK_FREQ) / NSEC_PER_SEC;\n\n\tscan_val |= (cycles << KEYP_SCAN_ROW_HOLD_SHIFT);\n\n\trc = regmap_write(kp->regmap, KEYP_SCAN, scan_val);\n\tif (rc)\n\t\tdev_err(kp->dev, \"Error writing KEYP_SCAN reg, rc=%d\\n\", rc);\n\n\treturn rc;\n\n}\n\nstatic int pmic8xxx_kp_enable(struct pmic8xxx_kp *kp)\n{\n\tint rc;\n\n\tkp->ctrl_reg |= KEYP_CTRL_KEYP_EN;\n\n\trc = regmap_write(kp->regmap, KEYP_CTRL, kp->ctrl_reg);\n\tif (rc < 0)\n\t\tdev_err(kp->dev, \"Error writing KEYP_CTRL reg, rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int pmic8xxx_kp_disable(struct pmic8xxx_kp *kp)\n{\n\tint rc;\n\n\tkp->ctrl_reg &= ~KEYP_CTRL_KEYP_EN;\n\n\trc = regmap_write(kp->regmap, KEYP_CTRL, kp->ctrl_reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn rc;\n}\n\nstatic int pmic8xxx_kp_open(struct input_dev *dev)\n{\n\tstruct pmic8xxx_kp *kp = input_get_drvdata(dev);\n\n\treturn pmic8xxx_kp_enable(kp);\n}\n\nstatic void pmic8xxx_kp_close(struct input_dev *dev)\n{\n\tstruct pmic8xxx_kp *kp = input_get_drvdata(dev);\n\n\tpmic8xxx_kp_disable(kp);\n}\n\n \nstatic int pmic8xxx_kp_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tunsigned int rows, cols;\n\tbool repeat;\n\tbool wakeup;\n\tstruct pmic8xxx_kp *kp;\n\tint rc;\n\tunsigned int ctrl_val;\n\n\trc = matrix_keypad_parse_properties(&pdev->dev, &rows, &cols);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cols > PM8XXX_MAX_COLS || rows > PM8XXX_MAX_ROWS ||\n\t    cols < PM8XXX_MIN_COLS) {\n\t\tdev_err(&pdev->dev, \"invalid platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trepeat = !of_property_read_bool(np, \"linux,input-no-autorepeat\");\n\n\twakeup = of_property_read_bool(np, \"wakeup-source\") ||\n\t\t  \n\t\t of_property_read_bool(np, \"linux,keypad-wakeup\");\n\n\tkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\n\tif (!kp)\n\t\treturn -ENOMEM;\n\n\tkp->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!kp->regmap)\n\t\treturn -ENODEV;\n\n\tplatform_set_drvdata(pdev, kp);\n\n\tkp->num_rows\t= rows;\n\tkp->num_cols\t= cols;\n\tkp->dev\t\t= &pdev->dev;\n\n\tkp->input = devm_input_allocate_device(&pdev->dev);\n\tif (!kp->input) {\n\t\tdev_err(&pdev->dev, \"unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkp->key_sense_irq = platform_get_irq(pdev, 0);\n\tif (kp->key_sense_irq < 0)\n\t\treturn kp->key_sense_irq;\n\n\tkp->key_stuck_irq = platform_get_irq(pdev, 1);\n\tif (kp->key_stuck_irq < 0)\n\t\treturn kp->key_stuck_irq;\n\n\tkp->input->name = \"PMIC8XXX keypad\";\n\tkp->input->phys = \"pmic8xxx_keypad/input0\";\n\n\tkp->input->id.bustype\t= BUS_I2C;\n\tkp->input->id.version\t= 0x0001;\n\tkp->input->id.product\t= 0x0001;\n\tkp->input->id.vendor\t= 0x0001;\n\n\tkp->input->open\t\t= pmic8xxx_kp_open;\n\tkp->input->close\t= pmic8xxx_kp_close;\n\n\trc = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\tPM8XXX_MAX_ROWS, PM8XXX_MAX_COLS,\n\t\t\t\t\tkp->keycodes, kp->input);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\treturn rc;\n\t}\n\n\tif (repeat)\n\t\t__set_bit(EV_REP, kp->input->evbit);\n\tinput_set_capability(kp->input, EV_MSC, MSC_SCAN);\n\n\tinput_set_drvdata(kp->input, kp);\n\n\t \n\tmemset(kp->keystate, 0xff, sizeof(kp->keystate));\n\tmemset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));\n\n\trc = pmic8xxx_kpd_init(kp, pdev);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"unable to initialize keypad controller\\n\");\n\t\treturn rc;\n\t}\n\n\trc = devm_request_any_context_irq(&pdev->dev, kp->key_sense_irq,\n\t\t\tpmic8xxx_kp_irq, IRQF_TRIGGER_RISING, \"pmic-keypad\",\n\t\t\tkp);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request keypad sense irq\\n\");\n\t\treturn rc;\n\t}\n\n\trc = devm_request_any_context_irq(&pdev->dev, kp->key_stuck_irq,\n\t\t\tpmic8xxx_kp_stuck_irq, IRQF_TRIGGER_RISING,\n\t\t\t\"pmic-keypad-stuck\", kp);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request keypad stuck irq\\n\");\n\t\treturn rc;\n\t}\n\n\trc = regmap_read(kp->regmap, KEYP_CTRL, &ctrl_val);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"failed to read KEYP_CTRL register\\n\");\n\t\treturn rc;\n\t}\n\n\tkp->ctrl_reg = ctrl_val;\n\n\trc = input_register_device(kp->input);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"unable to register keypad input device\\n\");\n\t\treturn rc;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, wakeup);\n\n\treturn 0;\n}\n\nstatic int pmic8xxx_kp_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = kp->input;\n\n\tif (device_may_wakeup(dev)) {\n\t\tenable_irq_wake(kp->key_sense_irq);\n\t} else {\n\t\tmutex_lock(&input_dev->mutex);\n\n\t\tif (input_device_enabled(input_dev))\n\t\t\tpmic8xxx_kp_disable(kp);\n\n\t\tmutex_unlock(&input_dev->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic int pmic8xxx_kp_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = kp->input;\n\n\tif (device_may_wakeup(dev)) {\n\t\tdisable_irq_wake(kp->key_sense_irq);\n\t} else {\n\t\tmutex_lock(&input_dev->mutex);\n\n\t\tif (input_device_enabled(input_dev))\n\t\t\tpmic8xxx_kp_enable(kp);\n\n\t\tmutex_unlock(&input_dev->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pm8xxx_kp_pm_ops,\n\t\t\t\tpmic8xxx_kp_suspend, pmic8xxx_kp_resume);\n\nstatic const struct of_device_id pm8xxx_match_table[] = {\n\t{ .compatible = \"qcom,pm8058-keypad\" },\n\t{ .compatible = \"qcom,pm8921-keypad\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_match_table);\n\nstatic struct platform_driver pmic8xxx_kp_driver = {\n\t.probe\t\t= pmic8xxx_kp_probe,\n\t.driver\t\t= {\n\t\t.name = \"pm8xxx-keypad\",\n\t\t.pm = pm_sleep_ptr(&pm8xxx_kp_pm_ops),\n\t\t.of_match_table = pm8xxx_match_table,\n\t},\n};\nmodule_platform_driver(pmic8xxx_kp_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PMIC8XXX keypad driver\");\nMODULE_ALIAS(\"platform:pmic8xxx_keypad\");\nMODULE_AUTHOR(\"Trilok Soni <tsoni@codeaurora.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}