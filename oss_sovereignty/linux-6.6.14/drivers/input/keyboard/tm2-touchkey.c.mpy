{
  "module_name": "tm2-touchkey.c",
  "hash_id": "7433cb5ac99dd8a7551f666f7160e9ea4b4e1fcc5a202699ce62e7275bfe674f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/tm2-touchkey.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n\n#define TM2_TOUCHKEY_DEV_NAME\t\t\"tm2-touchkey\"\n\n#define ARIES_TOUCHKEY_CMD_LED_ON\t0x1\n#define ARIES_TOUCHKEY_CMD_LED_OFF\t0x2\n#define TM2_TOUCHKEY_CMD_LED_ON\t\t0x10\n#define TM2_TOUCHKEY_CMD_LED_OFF\t0x20\n#define TM2_TOUCHKEY_BIT_PRESS_EV\tBIT(3)\n#define TM2_TOUCHKEY_BIT_KEYCODE\tGENMASK(2, 0)\n#define TM2_TOUCHKEY_LED_VOLTAGE_MIN\t2500000\n#define TM2_TOUCHKEY_LED_VOLTAGE_MAX\t3300000\n\nstruct touchkey_variant {\n\tu8 keycode_reg;\n\tu8 base_reg;\n\tu8 cmd_led_on;\n\tu8 cmd_led_off;\n\tbool no_reg;\n\tbool fixed_regulator;\n};\n\nstruct tm2_touchkey_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct led_classdev led_dev;\n\tstruct regulator *vdd;\n\tstruct regulator_bulk_data regulators[3];\n\tconst struct touchkey_variant *variant;\n\tu32 keycodes[4];\n\tint num_keycodes;\n};\n\nstatic const struct touchkey_variant tm2_touchkey_variant = {\n\t.keycode_reg = 0x03,\n\t.base_reg = 0x00,\n\t.cmd_led_on = TM2_TOUCHKEY_CMD_LED_ON,\n\t.cmd_led_off = TM2_TOUCHKEY_CMD_LED_OFF,\n};\n\nstatic const struct touchkey_variant midas_touchkey_variant = {\n\t.keycode_reg = 0x00,\n\t.base_reg = 0x00,\n\t.cmd_led_on = TM2_TOUCHKEY_CMD_LED_ON,\n\t.cmd_led_off = TM2_TOUCHKEY_CMD_LED_OFF,\n};\n\nstatic struct touchkey_variant aries_touchkey_variant = {\n\t.no_reg = true,\n\t.fixed_regulator = true,\n\t.cmd_led_on = ARIES_TOUCHKEY_CMD_LED_ON,\n\t.cmd_led_off = ARIES_TOUCHKEY_CMD_LED_OFF,\n};\n\nstatic const struct touchkey_variant tc360_touchkey_variant = {\n\t.keycode_reg = 0x00,\n\t.base_reg = 0x00,\n\t.fixed_regulator = true,\n\t.cmd_led_on = TM2_TOUCHKEY_CMD_LED_ON,\n\t.cmd_led_off = TM2_TOUCHKEY_CMD_LED_OFF,\n};\n\nstatic int tm2_touchkey_led_brightness_set(struct led_classdev *led_dev,\n\t\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct tm2_touchkey_data *touchkey =\n\t\tcontainer_of(led_dev, struct tm2_touchkey_data, led_dev);\n\tu32 volt;\n\tu8 data;\n\n\tif (brightness == LED_OFF) {\n\t\tvolt = TM2_TOUCHKEY_LED_VOLTAGE_MIN;\n\t\tdata = touchkey->variant->cmd_led_off;\n\t} else {\n\t\tvolt = TM2_TOUCHKEY_LED_VOLTAGE_MAX;\n\t\tdata = touchkey->variant->cmd_led_on;\n\t}\n\n\tif (!touchkey->variant->fixed_regulator)\n\t\tregulator_set_voltage(touchkey->vdd, volt, volt);\n\n\treturn touchkey->variant->no_reg ?\n\t\ti2c_smbus_write_byte(touchkey->client, data) :\n\t\ti2c_smbus_write_byte_data(touchkey->client,\n\t\t\t\t\t  touchkey->variant->base_reg, data);\n}\n\nstatic int tm2_touchkey_power_enable(struct tm2_touchkey_data *touchkey)\n{\n\tint error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(touchkey->regulators),\n\t\t\t\t      touchkey->regulators);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(150);\n\n\treturn 0;\n}\n\nstatic void tm2_touchkey_power_disable(void *data)\n{\n\tstruct tm2_touchkey_data *touchkey = data;\n\n\tregulator_bulk_disable(ARRAY_SIZE(touchkey->regulators),\n\t\t\t       touchkey->regulators);\n}\n\nstatic irqreturn_t tm2_touchkey_irq_handler(int irq, void *devid)\n{\n\tstruct tm2_touchkey_data *touchkey = devid;\n\tint data;\n\tint index;\n\tint i;\n\n\tif (touchkey->variant->no_reg)\n\t\tdata = i2c_smbus_read_byte(touchkey->client);\n\telse\n\t\tdata = i2c_smbus_read_byte_data(touchkey->client,\n\t\t\t\t\t\ttouchkey->variant->keycode_reg);\n\tif (data < 0) {\n\t\tdev_err(&touchkey->client->dev,\n\t\t\t\"failed to read i2c data: %d\\n\", data);\n\t\tgoto out;\n\t}\n\n\tindex = (data & TM2_TOUCHKEY_BIT_KEYCODE) - 1;\n\tif (index < 0 || index >= touchkey->num_keycodes) {\n\t\tdev_warn(&touchkey->client->dev,\n\t\t\t \"invalid keycode index %d\\n\", index);\n\t\tgoto out;\n\t}\n\n\tinput_event(touchkey->input_dev, EV_MSC, MSC_SCAN, index);\n\n\tif (data & TM2_TOUCHKEY_BIT_PRESS_EV) {\n\t\tfor (i = 0; i < touchkey->num_keycodes; i++)\n\t\t\tinput_report_key(touchkey->input_dev,\n\t\t\t\t\t touchkey->keycodes[i], 0);\n\t} else {\n\t\tinput_report_key(touchkey->input_dev,\n\t\t\t\t touchkey->keycodes[index], 1);\n\t}\n\n\tinput_sync(touchkey->input_dev);\n\nout:\n\tif (touchkey->variant->fixed_regulator &&\n\t\t\t\tdata & TM2_TOUCHKEY_BIT_PRESS_EV) {\n\t\t \n\t\tif (touchkey->led_dev.brightness == LED_OFF)\n\t\t\ttm2_touchkey_led_brightness_set(&touchkey->led_dev,\n\t\t\t\t\t\t\tLED_OFF);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tm2_touchkey_probe(struct i2c_client *client)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tstruct tm2_touchkey_data *touchkey;\n\tint error;\n\tint i;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\tI2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"incompatible I2C adapter\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttouchkey = devm_kzalloc(&client->dev, sizeof(*touchkey), GFP_KERNEL);\n\tif (!touchkey)\n\t\treturn -ENOMEM;\n\n\ttouchkey->client = client;\n\ti2c_set_clientdata(client, touchkey);\n\n\ttouchkey->variant = of_device_get_match_data(&client->dev);\n\n\ttouchkey->regulators[0].supply = \"vcc\";\n\ttouchkey->regulators[1].supply = \"vdd\";\n\ttouchkey->regulators[2].supply = \"vddio\";\n\terror = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t\tARRAY_SIZE(touchkey->regulators),\n\t\t\t\t\ttouchkey->regulators);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\ttouchkey->vdd = touchkey->regulators[1].consumer;\n\n\ttouchkey->num_keycodes = of_property_read_variable_u32_array(np,\n\t\t\t\t\t\"linux,keycodes\", touchkey->keycodes, 0,\n\t\t\t\t\tARRAY_SIZE(touchkey->keycodes));\n\tif (touchkey->num_keycodes <= 0) {\n\t\t \n\t\ttouchkey->keycodes[0] = KEY_PHONE;\n\t\ttouchkey->keycodes[1] = KEY_BACK;\n\t\ttouchkey->num_keycodes = 2;\n\t}\n\n\terror = tm2_touchkey_power_enable(touchkey);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to power up device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t tm2_touchkey_power_disable, touchkey);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to install poweroff handler: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\ttouchkey->input_dev = devm_input_allocate_device(&client->dev);\n\tif (!touchkey->input_dev) {\n\t\tdev_err(&client->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttouchkey->input_dev->name = TM2_TOUCHKEY_DEV_NAME;\n\ttouchkey->input_dev->id.bustype = BUS_I2C;\n\n\ttouchkey->input_dev->keycode = touchkey->keycodes;\n\ttouchkey->input_dev->keycodemax = touchkey->num_keycodes;\n\ttouchkey->input_dev->keycodesize = sizeof(touchkey->keycodes[0]);\n\n\tinput_set_capability(touchkey->input_dev, EV_MSC, MSC_SCAN);\n\tfor (i = 0; i < touchkey->num_keycodes; i++)\n\t\tinput_set_capability(touchkey->input_dev, EV_KEY,\n\t\t\t\t     touchkey->keycodes[i]);\n\n\terror = input_register_device(touchkey->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, tm2_touchkey_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  TM2_TOUCHKEY_DEV_NAME, touchkey);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to request threaded irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\ttouchkey->led_dev.name = TM2_TOUCHKEY_DEV_NAME;\n\ttouchkey->led_dev.brightness = LED_ON;\n\ttouchkey->led_dev.max_brightness = LED_ON;\n\ttouchkey->led_dev.brightness_set_blocking =\n\t\t\t\t\ttm2_touchkey_led_brightness_set;\n\n\terror = devm_led_classdev_register(&client->dev, &touchkey->led_dev);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to register touchkey led: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (touchkey->variant->fixed_regulator)\n\t\ttm2_touchkey_led_brightness_set(&touchkey->led_dev, LED_ON);\n\n\treturn 0;\n}\n\nstatic int tm2_touchkey_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tm2_touchkey_data *touchkey = i2c_get_clientdata(client);\n\n\tdisable_irq(client->irq);\n\ttm2_touchkey_power_disable(touchkey);\n\n\treturn 0;\n}\n\nstatic int tm2_touchkey_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tm2_touchkey_data *touchkey = i2c_get_clientdata(client);\n\tint ret;\n\n\tenable_irq(client->irq);\n\n\tret = tm2_touchkey_power_enable(touchkey);\n\tif (ret)\n\t\tdev_err(dev, \"failed to enable power: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tm2_touchkey_pm_ops,\n\t\t\t\ttm2_touchkey_suspend, tm2_touchkey_resume);\n\nstatic const struct i2c_device_id tm2_touchkey_id_table[] = {\n\t{ TM2_TOUCHKEY_DEV_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tm2_touchkey_id_table);\n\nstatic const struct of_device_id tm2_touchkey_of_match[] = {\n\t{\n\t\t.compatible = \"cypress,tm2-touchkey\",\n\t\t.data = &tm2_touchkey_variant,\n\t}, {\n\t\t.compatible = \"cypress,midas-touchkey\",\n\t\t.data = &midas_touchkey_variant,\n\t}, {\n\t\t.compatible = \"cypress,aries-touchkey\",\n\t\t.data = &aries_touchkey_variant,\n\t}, {\n\t\t.compatible = \"coreriver,tc360-touchkey\",\n\t\t.data = &tc360_touchkey_variant,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tm2_touchkey_of_match);\n\nstatic struct i2c_driver tm2_touchkey_driver = {\n\t.driver = {\n\t\t.name = TM2_TOUCHKEY_DEV_NAME,\n\t\t.pm = pm_sleep_ptr(&tm2_touchkey_pm_ops),\n\t\t.of_match_table = tm2_touchkey_of_match,\n\t},\n\t.probe = tm2_touchkey_probe,\n\t.id_table = tm2_touchkey_id_table,\n};\nmodule_i2c_driver(tm2_touchkey_driver);\n\nMODULE_AUTHOR(\"Beomho Seo <beomho.seo@samsung.com>\");\nMODULE_AUTHOR(\"Jaechul Lee <jcsing.lee@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung touchkey driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}