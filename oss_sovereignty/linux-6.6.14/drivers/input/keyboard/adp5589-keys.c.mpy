{
  "module_name": "adp5589-keys.c",
  "hash_id": "3fdbfdd9a7196008b8b5c9ebb374558d2fc4f35e76ddde4bc75da5831ca09f74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/adp5589-keys.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/workqueue.h>\n#include <linux/errno.h>\n#include <linux/pm.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/i2c.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n\n#include <linux/input/adp5589.h>\n\n \n#define ADP5589_5_ID\t\t\t0x00\n#define ADP5589_5_INT_STATUS\t\t0x01\n#define ADP5589_5_STATUS\t\t0x02\n#define ADP5589_5_FIFO_1\t\t0x03\n#define ADP5589_5_FIFO_2\t\t0x04\n#define ADP5589_5_FIFO_3\t\t0x05\n#define ADP5589_5_FIFO_4\t\t0x06\n#define ADP5589_5_FIFO_5\t\t0x07\n#define ADP5589_5_FIFO_6\t\t0x08\n#define ADP5589_5_FIFO_7\t\t0x09\n#define ADP5589_5_FIFO_8\t\t0x0A\n#define ADP5589_5_FIFO_9\t\t0x0B\n#define ADP5589_5_FIFO_10\t\t0x0C\n#define ADP5589_5_FIFO_11\t\t0x0D\n#define ADP5589_5_FIFO_12\t\t0x0E\n#define ADP5589_5_FIFO_13\t\t0x0F\n#define ADP5589_5_FIFO_14\t\t0x10\n#define ADP5589_5_FIFO_15\t\t0x11\n#define ADP5589_5_FIFO_16\t\t0x12\n#define ADP5589_5_GPI_INT_STAT_A\t0x13\n#define ADP5589_5_GPI_INT_STAT_B\t0x14\n\n \n#define ADP5589_GPI_INT_STAT_C\t\t0x15\n#define ADP5589_GPI_STATUS_A\t\t0x16\n#define ADP5589_GPI_STATUS_B\t\t0x17\n#define ADP5589_GPI_STATUS_C\t\t0x18\n#define ADP5589_RPULL_CONFIG_A\t\t0x19\n#define ADP5589_RPULL_CONFIG_B\t\t0x1A\n#define ADP5589_RPULL_CONFIG_C\t\t0x1B\n#define ADP5589_RPULL_CONFIG_D\t\t0x1C\n#define ADP5589_RPULL_CONFIG_E\t\t0x1D\n#define ADP5589_GPI_INT_LEVEL_A\t\t0x1E\n#define ADP5589_GPI_INT_LEVEL_B\t\t0x1F\n#define ADP5589_GPI_INT_LEVEL_C\t\t0x20\n#define ADP5589_GPI_EVENT_EN_A\t\t0x21\n#define ADP5589_GPI_EVENT_EN_B\t\t0x22\n#define ADP5589_GPI_EVENT_EN_C\t\t0x23\n#define ADP5589_GPI_INTERRUPT_EN_A\t0x24\n#define ADP5589_GPI_INTERRUPT_EN_B\t0x25\n#define ADP5589_GPI_INTERRUPT_EN_C\t0x26\n#define ADP5589_DEBOUNCE_DIS_A\t\t0x27\n#define ADP5589_DEBOUNCE_DIS_B\t\t0x28\n#define ADP5589_DEBOUNCE_DIS_C\t\t0x29\n#define ADP5589_GPO_DATA_OUT_A\t\t0x2A\n#define ADP5589_GPO_DATA_OUT_B\t\t0x2B\n#define ADP5589_GPO_DATA_OUT_C\t\t0x2C\n#define ADP5589_GPO_OUT_MODE_A\t\t0x2D\n#define ADP5589_GPO_OUT_MODE_B\t\t0x2E\n#define ADP5589_GPO_OUT_MODE_C\t\t0x2F\n#define ADP5589_GPIO_DIRECTION_A\t0x30\n#define ADP5589_GPIO_DIRECTION_B\t0x31\n#define ADP5589_GPIO_DIRECTION_C\t0x32\n#define ADP5589_UNLOCK1\t\t\t0x33\n#define ADP5589_UNLOCK2\t\t\t0x34\n#define ADP5589_EXT_LOCK_EVENT\t\t0x35\n#define ADP5589_UNLOCK_TIMERS\t\t0x36\n#define ADP5589_LOCK_CFG\t\t0x37\n#define ADP5589_RESET1_EVENT_A\t\t0x38\n#define ADP5589_RESET1_EVENT_B\t\t0x39\n#define ADP5589_RESET1_EVENT_C\t\t0x3A\n#define ADP5589_RESET2_EVENT_A\t\t0x3B\n#define ADP5589_RESET2_EVENT_B\t\t0x3C\n#define ADP5589_RESET_CFG\t\t0x3D\n#define ADP5589_PWM_OFFT_LOW\t\t0x3E\n#define ADP5589_PWM_OFFT_HIGH\t\t0x3F\n#define ADP5589_PWM_ONT_LOW\t\t0x40\n#define ADP5589_PWM_ONT_HIGH\t\t0x41\n#define ADP5589_PWM_CFG\t\t\t0x42\n#define ADP5589_CLOCK_DIV_CFG\t\t0x43\n#define ADP5589_LOGIC_1_CFG\t\t0x44\n#define ADP5589_LOGIC_2_CFG\t\t0x45\n#define ADP5589_LOGIC_FF_CFG\t\t0x46\n#define ADP5589_LOGIC_INT_EVENT_EN\t0x47\n#define ADP5589_POLL_PTIME_CFG\t\t0x48\n#define ADP5589_PIN_CONFIG_A\t\t0x49\n#define ADP5589_PIN_CONFIG_B\t\t0x4A\n#define ADP5589_PIN_CONFIG_C\t\t0x4B\n#define ADP5589_PIN_CONFIG_D\t\t0x4C\n#define ADP5589_GENERAL_CFG\t\t0x4D\n#define ADP5589_INT_EN\t\t\t0x4E\n\n \n#define ADP5585_GPI_STATUS_A\t\t0x15\n#define ADP5585_GPI_STATUS_B\t\t0x16\n#define ADP5585_RPULL_CONFIG_A\t\t0x17\n#define ADP5585_RPULL_CONFIG_B\t\t0x18\n#define ADP5585_RPULL_CONFIG_C\t\t0x19\n#define ADP5585_RPULL_CONFIG_D\t\t0x1A\n#define ADP5585_GPI_INT_LEVEL_A\t\t0x1B\n#define ADP5585_GPI_INT_LEVEL_B\t\t0x1C\n#define ADP5585_GPI_EVENT_EN_A\t\t0x1D\n#define ADP5585_GPI_EVENT_EN_B\t\t0x1E\n#define ADP5585_GPI_INTERRUPT_EN_A\t0x1F\n#define ADP5585_GPI_INTERRUPT_EN_B\t0x20\n#define ADP5585_DEBOUNCE_DIS_A\t\t0x21\n#define ADP5585_DEBOUNCE_DIS_B\t\t0x22\n#define ADP5585_GPO_DATA_OUT_A\t\t0x23\n#define ADP5585_GPO_DATA_OUT_B\t\t0x24\n#define ADP5585_GPO_OUT_MODE_A\t\t0x25\n#define ADP5585_GPO_OUT_MODE_B\t\t0x26\n#define ADP5585_GPIO_DIRECTION_A\t0x27\n#define ADP5585_GPIO_DIRECTION_B\t0x28\n#define ADP5585_RESET1_EVENT_A\t\t0x29\n#define ADP5585_RESET1_EVENT_B\t\t0x2A\n#define ADP5585_RESET1_EVENT_C\t\t0x2B\n#define ADP5585_RESET2_EVENT_A\t\t0x2C\n#define ADP5585_RESET2_EVENT_B\t\t0x2D\n#define ADP5585_RESET_CFG\t\t0x2E\n#define ADP5585_PWM_OFFT_LOW\t\t0x2F\n#define ADP5585_PWM_OFFT_HIGH\t\t0x30\n#define ADP5585_PWM_ONT_LOW\t\t0x31\n#define ADP5585_PWM_ONT_HIGH\t\t0x32\n#define ADP5585_PWM_CFG\t\t\t0x33\n#define ADP5585_LOGIC_CFG\t\t0x34\n#define ADP5585_LOGIC_FF_CFG\t\t0x35\n#define ADP5585_LOGIC_INT_EVENT_EN\t0x36\n#define ADP5585_POLL_PTIME_CFG\t\t0x37\n#define ADP5585_PIN_CONFIG_A\t\t0x38\n#define ADP5585_PIN_CONFIG_B\t\t0x39\n#define ADP5585_PIN_CONFIG_D\t\t0x3A\n#define ADP5585_GENERAL_CFG\t\t0x3B\n#define ADP5585_INT_EN\t\t\t0x3C\n\n \n#define ADP5589_5_DEVICE_ID_MASK\t0xF\n#define ADP5589_5_MAN_ID_MASK\t\t0xF\n#define ADP5589_5_MAN_ID_SHIFT\t\t4\n#define ADP5589_5_MAN_ID\t\t0x02\n\n \n#define OSC_EN\t\tBIT(7)\n#define CORE_CLK(x)\t(((x) & 0x3) << 5)\n#define LCK_TRK_LOGIC\tBIT(4)\t\t \n#define LCK_TRK_GPI\tBIT(3)\t\t \n#define INT_CFG\t\tBIT(1)\n#define RST_CFG\t\tBIT(0)\n\n \n#define LOGIC2_IEN\tBIT(5)\t\t \n#define LOGIC1_IEN\tBIT(4)\n#define LOCK_IEN\tBIT(3)\t\t \n#define OVRFLOW_IEN\tBIT(2)\n#define GPI_IEN\t\tBIT(1)\n#define EVENT_IEN\tBIT(0)\n\n \n#define LOGIC2_INT\tBIT(5)\t\t \n#define LOGIC1_INT\tBIT(4)\n#define LOCK_INT\tBIT(3)\t\t \n#define OVRFLOW_INT\tBIT(2)\n#define GPI_INT\t\tBIT(1)\n#define EVENT_INT\tBIT(0)\n\n \n#define LOGIC2_STAT\tBIT(7)\t\t \n#define LOGIC1_STAT\tBIT(6)\n#define LOCK_STAT\tBIT(5)\t\t \n#define KEC\t\t0x1F\n\n \n#define C4_EXTEND_CFG\tBIT(6)\t\t \n#define R4_EXTEND_CFG\tBIT(5)\t\t \n\n \n#define LOCK_EN\t\tBIT(0)\n\n#define PTIME_MASK\t0x3\n#define LTIME_MASK\t0x3\t\t \n\n \n#define KEY_EV_PRESSED\tBIT(7)\n#define KEY_EV_MASK\t0x7F\n\n#define KEYP_MAX_EVENT\t\t16\n#define ADP5589_MAXGPIO\t\t19\n#define ADP5585_MAXGPIO\t\t11  \n\nenum {\n\tADP5589,\n\tADP5585_01,\n\tADP5585_02\n};\n\nstruct adp_constants {\n\tu8 maxgpio;\n\tu8 keymapsize;\n\tu8 gpi_pin_row_base;\n\tu8 gpi_pin_row_end;\n\tu8 gpi_pin_col_base;\n\tu8 gpi_pin_base;\n\tu8 gpi_pin_end;\n\tu8 gpimapsize_max;\n\tu8 max_row_num;\n\tu8 max_col_num;\n\tu8 row_mask;\n\tu8 col_mask;\n\tu8 col_shift;\n\tu8 c4_extend_cfg;\n\tu8 (*bank) (u8 offset);\n\tu8 (*bit) (u8 offset);\n\tu8 (*reg) (u8 reg);\n};\n\nstruct adp5589_kpad {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tconst struct adp_constants *var;\n\tunsigned short keycode[ADP5589_KEYMAPSIZE];\n\tconst struct adp5589_gpi_map *gpimap;\n\tunsigned short gpimapsize;\n\tunsigned extend_cfg;\n\tbool is_adp5585;\n\tbool support_row5;\n#ifdef CONFIG_GPIOLIB\n\tunsigned char gpiomap[ADP5589_MAXGPIO];\n\tstruct gpio_chip gc;\n\tstruct mutex gpio_lock;\t \n\tu8 dat_out[3];\n\tu8 dir[3];\n#endif\n};\n\n \n\n\n \n\nstatic unsigned char adp5589_bank(unsigned char offset)\n{\n\treturn offset >> 3;\n}\n\nstatic unsigned char adp5589_bit(unsigned char offset)\n{\n\treturn 1u << (offset & 0x7);\n}\n\nstatic unsigned char adp5589_reg(unsigned char reg)\n{\n\treturn reg;\n}\n\nstatic const struct adp_constants const_adp5589 = {\n\t.maxgpio\t\t= ADP5589_MAXGPIO,\n\t.keymapsize\t\t= ADP5589_KEYMAPSIZE,\n\t.gpi_pin_row_base\t= ADP5589_GPI_PIN_ROW_BASE,\n\t.gpi_pin_row_end\t= ADP5589_GPI_PIN_ROW_END,\n\t.gpi_pin_col_base\t= ADP5589_GPI_PIN_COL_BASE,\n\t.gpi_pin_base\t\t= ADP5589_GPI_PIN_BASE,\n\t.gpi_pin_end\t\t= ADP5589_GPI_PIN_END,\n\t.gpimapsize_max\t\t= ADP5589_GPIMAPSIZE_MAX,\n\t.c4_extend_cfg\t\t= 12,\n\t.max_row_num\t\t= ADP5589_MAX_ROW_NUM,\n\t.max_col_num\t\t= ADP5589_MAX_COL_NUM,\n\t.row_mask\t\t= ADP5589_ROW_MASK,\n\t.col_mask\t\t= ADP5589_COL_MASK,\n\t.col_shift\t\t= ADP5589_COL_SHIFT,\n\t.bank\t\t\t= adp5589_bank,\n\t.bit\t\t\t= adp5589_bit,\n\t.reg\t\t\t= adp5589_reg,\n};\n\n \n\nstatic unsigned char adp5585_bank(unsigned char offset)\n{\n\treturn offset > ADP5585_MAX_ROW_NUM;\n}\n\nstatic unsigned char adp5585_bit(unsigned char offset)\n{\n\treturn (offset > ADP5585_MAX_ROW_NUM) ?\n\t\t1u << (offset - ADP5585_COL_SHIFT) : 1u << offset;\n}\n\nstatic const unsigned char adp5585_reg_lut[] = {\n\t[ADP5589_GPI_STATUS_A]\t\t= ADP5585_GPI_STATUS_A,\n\t[ADP5589_GPI_STATUS_B]\t\t= ADP5585_GPI_STATUS_B,\n\t[ADP5589_RPULL_CONFIG_A]\t= ADP5585_RPULL_CONFIG_A,\n\t[ADP5589_RPULL_CONFIG_B]\t= ADP5585_RPULL_CONFIG_B,\n\t[ADP5589_RPULL_CONFIG_C]\t= ADP5585_RPULL_CONFIG_C,\n\t[ADP5589_RPULL_CONFIG_D]\t= ADP5585_RPULL_CONFIG_D,\n\t[ADP5589_GPI_INT_LEVEL_A]\t= ADP5585_GPI_INT_LEVEL_A,\n\t[ADP5589_GPI_INT_LEVEL_B]\t= ADP5585_GPI_INT_LEVEL_B,\n\t[ADP5589_GPI_EVENT_EN_A]\t= ADP5585_GPI_EVENT_EN_A,\n\t[ADP5589_GPI_EVENT_EN_B]\t= ADP5585_GPI_EVENT_EN_B,\n\t[ADP5589_GPI_INTERRUPT_EN_A]\t= ADP5585_GPI_INTERRUPT_EN_A,\n\t[ADP5589_GPI_INTERRUPT_EN_B]\t= ADP5585_GPI_INTERRUPT_EN_B,\n\t[ADP5589_DEBOUNCE_DIS_A]\t= ADP5585_DEBOUNCE_DIS_A,\n\t[ADP5589_DEBOUNCE_DIS_B]\t= ADP5585_DEBOUNCE_DIS_B,\n\t[ADP5589_GPO_DATA_OUT_A]\t= ADP5585_GPO_DATA_OUT_A,\n\t[ADP5589_GPO_DATA_OUT_B]\t= ADP5585_GPO_DATA_OUT_B,\n\t[ADP5589_GPO_OUT_MODE_A]\t= ADP5585_GPO_OUT_MODE_A,\n\t[ADP5589_GPO_OUT_MODE_B]\t= ADP5585_GPO_OUT_MODE_B,\n\t[ADP5589_GPIO_DIRECTION_A]\t= ADP5585_GPIO_DIRECTION_A,\n\t[ADP5589_GPIO_DIRECTION_B]\t= ADP5585_GPIO_DIRECTION_B,\n\t[ADP5589_RESET1_EVENT_A]\t= ADP5585_RESET1_EVENT_A,\n\t[ADP5589_RESET1_EVENT_B]\t= ADP5585_RESET1_EVENT_B,\n\t[ADP5589_RESET1_EVENT_C]\t= ADP5585_RESET1_EVENT_C,\n\t[ADP5589_RESET2_EVENT_A]\t= ADP5585_RESET2_EVENT_A,\n\t[ADP5589_RESET2_EVENT_B]\t= ADP5585_RESET2_EVENT_B,\n\t[ADP5589_RESET_CFG]\t\t= ADP5585_RESET_CFG,\n\t[ADP5589_PWM_OFFT_LOW]\t\t= ADP5585_PWM_OFFT_LOW,\n\t[ADP5589_PWM_OFFT_HIGH]\t\t= ADP5585_PWM_OFFT_HIGH,\n\t[ADP5589_PWM_ONT_LOW]\t\t= ADP5585_PWM_ONT_LOW,\n\t[ADP5589_PWM_ONT_HIGH]\t\t= ADP5585_PWM_ONT_HIGH,\n\t[ADP5589_PWM_CFG]\t\t= ADP5585_PWM_CFG,\n\t[ADP5589_LOGIC_1_CFG]\t\t= ADP5585_LOGIC_CFG,\n\t[ADP5589_LOGIC_FF_CFG]\t\t= ADP5585_LOGIC_FF_CFG,\n\t[ADP5589_LOGIC_INT_EVENT_EN]\t= ADP5585_LOGIC_INT_EVENT_EN,\n\t[ADP5589_POLL_PTIME_CFG]\t= ADP5585_POLL_PTIME_CFG,\n\t[ADP5589_PIN_CONFIG_A]\t\t= ADP5585_PIN_CONFIG_A,\n\t[ADP5589_PIN_CONFIG_B]\t\t= ADP5585_PIN_CONFIG_B,\n\t[ADP5589_PIN_CONFIG_D]\t\t= ADP5585_PIN_CONFIG_D,\n\t[ADP5589_GENERAL_CFG]\t\t= ADP5585_GENERAL_CFG,\n\t[ADP5589_INT_EN]\t\t= ADP5585_INT_EN,\n};\n\nstatic unsigned char adp5585_reg(unsigned char reg)\n{\n\treturn adp5585_reg_lut[reg];\n}\n\nstatic const struct adp_constants const_adp5585 = {\n\t.maxgpio\t\t= ADP5585_MAXGPIO,\n\t.keymapsize\t\t= ADP5585_KEYMAPSIZE,\n\t.gpi_pin_row_base\t= ADP5585_GPI_PIN_ROW_BASE,\n\t.gpi_pin_row_end\t= ADP5585_GPI_PIN_ROW_END,\n\t.gpi_pin_col_base\t= ADP5585_GPI_PIN_COL_BASE,\n\t.gpi_pin_base\t\t= ADP5585_GPI_PIN_BASE,\n\t.gpi_pin_end\t\t= ADP5585_GPI_PIN_END,\n\t.gpimapsize_max\t\t= ADP5585_GPIMAPSIZE_MAX,\n\t.c4_extend_cfg\t\t= 10,\n\t.max_row_num\t\t= ADP5585_MAX_ROW_NUM,\n\t.max_col_num\t\t= ADP5585_MAX_COL_NUM,\n\t.row_mask\t\t= ADP5585_ROW_MASK,\n\t.col_mask\t\t= ADP5585_COL_MASK,\n\t.col_shift\t\t= ADP5585_COL_SHIFT,\n\t.bank\t\t\t= adp5585_bank,\n\t.bit\t\t\t= adp5585_bit,\n\t.reg\t\t\t= adp5585_reg,\n};\n\nstatic int adp5589_read(struct i2c_client *client, u8 reg)\n{\n\tint ret = i2c_smbus_read_byte_data(client, reg);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"Read Error\\n\");\n\n\treturn ret;\n}\n\nstatic int adp5589_write(struct i2c_client *client, u8 reg, u8 val)\n{\n\treturn i2c_smbus_write_byte_data(client, reg, val);\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic int adp5589_gpio_get_value(struct gpio_chip *chip, unsigned off)\n{\n\tstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\n\tunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\n\n\treturn !!(adp5589_read(kpad->client,\n\t\t\t       kpad->var->reg(ADP5589_GPI_STATUS_A) + bank) &\n\t\t\t       bit);\n}\n\nstatic void adp5589_gpio_set_value(struct gpio_chip *chip,\n\t\t\t\t   unsigned off, int val)\n{\n\tstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\n\tunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tif (val)\n\t\tkpad->dat_out[bank] |= bit;\n\telse\n\t\tkpad->dat_out[bank] &= ~bit;\n\n\tadp5589_write(kpad->client, kpad->var->reg(ADP5589_GPO_DATA_OUT_A) +\n\t\t      bank, kpad->dat_out[bank]);\n\n\tmutex_unlock(&kpad->gpio_lock);\n}\n\nstatic int adp5589_gpio_direction_input(struct gpio_chip *chip, unsigned off)\n{\n\tstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\n\tunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\n\tint ret;\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tkpad->dir[bank] &= ~bit;\n\tret = adp5589_write(kpad->client,\n\t\t\t    kpad->var->reg(ADP5589_GPIO_DIRECTION_A) + bank,\n\t\t\t    kpad->dir[bank]);\n\n\tmutex_unlock(&kpad->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int adp5589_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned off, int val)\n{\n\tstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\n\tunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\n\tunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\n\tint ret;\n\n\tmutex_lock(&kpad->gpio_lock);\n\n\tkpad->dir[bank] |= bit;\n\n\tif (val)\n\t\tkpad->dat_out[bank] |= bit;\n\telse\n\t\tkpad->dat_out[bank] &= ~bit;\n\n\tret = adp5589_write(kpad->client, kpad->var->reg(ADP5589_GPO_DATA_OUT_A)\n\t\t\t    + bank, kpad->dat_out[bank]);\n\tret |= adp5589_write(kpad->client,\n\t\t\t     kpad->var->reg(ADP5589_GPIO_DIRECTION_A) + bank,\n\t\t\t     kpad->dir[bank]);\n\n\tmutex_unlock(&kpad->gpio_lock);\n\n\treturn ret;\n}\n\nstatic int adp5589_build_gpiomap(struct adp5589_kpad *kpad,\n\t\t\t\tconst struct adp5589_kpad_platform_data *pdata)\n{\n\tbool pin_used[ADP5589_MAXGPIO];\n\tint n_unused = 0;\n\tint i;\n\n\tmemset(pin_used, false, sizeof(pin_used));\n\n\tfor (i = 0; i < kpad->var->maxgpio; i++)\n\t\tif (pdata->keypad_en_mask & BIT(i))\n\t\t\tpin_used[i] = true;\n\n\tfor (i = 0; i < kpad->gpimapsize; i++)\n\t\tpin_used[kpad->gpimap[i].pin - kpad->var->gpi_pin_base] = true;\n\n\tif (kpad->extend_cfg & R4_EXTEND_CFG)\n\t\tpin_used[4] = true;\n\n\tif (kpad->extend_cfg & C4_EXTEND_CFG)\n\t\tpin_used[kpad->var->c4_extend_cfg] = true;\n\n\tif (!kpad->support_row5)\n\t\tpin_used[5] = true;\n\n\tfor (i = 0; i < kpad->var->maxgpio; i++)\n\t\tif (!pin_used[i])\n\t\t\tkpad->gpiomap[n_unused++] = i;\n\n\treturn n_unused;\n}\n\nstatic int adp5589_gpio_add(struct adp5589_kpad *kpad)\n{\n\tstruct device *dev = &kpad->client->dev;\n\tconst struct adp5589_kpad_platform_data *pdata = dev_get_platdata(dev);\n\tconst struct adp5589_gpio_platform_data *gpio_data = pdata->gpio_data;\n\tint i, error;\n\n\tif (!gpio_data)\n\t\treturn 0;\n\n\tkpad->gc.parent = dev;\n\tkpad->gc.ngpio = adp5589_build_gpiomap(kpad, pdata);\n\tif (kpad->gc.ngpio == 0) {\n\t\tdev_info(dev, \"No unused gpios left to export\\n\");\n\t\treturn 0;\n\t}\n\n\tkpad->gc.direction_input = adp5589_gpio_direction_input;\n\tkpad->gc.direction_output = adp5589_gpio_direction_output;\n\tkpad->gc.get = adp5589_gpio_get_value;\n\tkpad->gc.set = adp5589_gpio_set_value;\n\tkpad->gc.can_sleep = 1;\n\n\tkpad->gc.base = gpio_data->gpio_start;\n\tkpad->gc.label = kpad->client->name;\n\tkpad->gc.owner = THIS_MODULE;\n\n\tmutex_init(&kpad->gpio_lock);\n\n\terror = devm_gpiochip_add_data(dev, &kpad->gc, kpad);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i <= kpad->var->bank(kpad->var->maxgpio); i++) {\n\t\tkpad->dat_out[i] = adp5589_read(kpad->client, kpad->var->reg(\n\t\t\t\t\t\tADP5589_GPO_DATA_OUT_A) + i);\n\t\tkpad->dir[i] = adp5589_read(kpad->client, kpad->var->reg(\n\t\t\t\t\t    ADP5589_GPIO_DIRECTION_A) + i);\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int adp5589_gpio_add(struct adp5589_kpad *kpad)\n{\n\treturn 0;\n}\n#endif\n\nstatic void adp5589_report_switches(struct adp5589_kpad *kpad,\n\t\t\t\t    int key, int key_val)\n{\n\tint i;\n\n\tfor (i = 0; i < kpad->gpimapsize; i++) {\n\t\tif (key_val == kpad->gpimap[i].pin) {\n\t\t\tinput_report_switch(kpad->input,\n\t\t\t\t\t    kpad->gpimap[i].sw_evt,\n\t\t\t\t\t    key & KEY_EV_PRESSED);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void adp5589_report_events(struct adp5589_kpad *kpad, int ev_cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < ev_cnt; i++) {\n\t\tint key = adp5589_read(kpad->client, ADP5589_5_FIFO_1 + i);\n\t\tint key_val = key & KEY_EV_MASK;\n\n\t\tif (key_val >= kpad->var->gpi_pin_base &&\n\t\t    key_val <= kpad->var->gpi_pin_end) {\n\t\t\tadp5589_report_switches(kpad, key, key_val);\n\t\t} else {\n\t\t\tinput_report_key(kpad->input,\n\t\t\t\t\t kpad->keycode[key_val - 1],\n\t\t\t\t\t key & KEY_EV_PRESSED);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t adp5589_irq(int irq, void *handle)\n{\n\tstruct adp5589_kpad *kpad = handle;\n\tstruct i2c_client *client = kpad->client;\n\tint status, ev_cnt;\n\n\tstatus = adp5589_read(client, ADP5589_5_INT_STATUS);\n\n\tif (status & OVRFLOW_INT)\t \n\t\tdev_err(&client->dev, \"Event Overflow Error\\n\");\n\n\tif (status & EVENT_INT) {\n\t\tev_cnt = adp5589_read(client, ADP5589_5_STATUS) & KEC;\n\t\tif (ev_cnt) {\n\t\t\tadp5589_report_events(kpad, ev_cnt);\n\t\t\tinput_sync(kpad->input);\n\t\t}\n\t}\n\n\tadp5589_write(client, ADP5589_5_INT_STATUS, status);  \n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adp5589_get_evcode(struct adp5589_kpad *kpad, unsigned short key)\n{\n\tint i;\n\n\tfor (i = 0; i < kpad->var->keymapsize; i++)\n\t\tif (key == kpad->keycode[i])\n\t\t\treturn (i + 1) | KEY_EV_PRESSED;\n\n\tdev_err(&kpad->client->dev, \"RESET/UNLOCK key not in keycode map\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int adp5589_setup(struct adp5589_kpad *kpad)\n{\n\tstruct i2c_client *client = kpad->client;\n\tconst struct adp5589_kpad_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tu8 (*reg) (u8) = kpad->var->reg;\n\tunsigned char evt_mode1 = 0, evt_mode2 = 0, evt_mode3 = 0;\n\tunsigned char pull_mask = 0;\n\tint i, ret;\n\n\tret = adp5589_write(client, reg(ADP5589_PIN_CONFIG_A),\n\t\t\t    pdata->keypad_en_mask & kpad->var->row_mask);\n\tret |= adp5589_write(client, reg(ADP5589_PIN_CONFIG_B),\n\t\t\t     (pdata->keypad_en_mask >> kpad->var->col_shift) &\n\t\t\t     kpad->var->col_mask);\n\n\tif (!kpad->is_adp5585)\n\t\tret |= adp5589_write(client, ADP5589_PIN_CONFIG_C,\n\t\t\t\t     (pdata->keypad_en_mask >> 16) & 0xFF);\n\n\tif (!kpad->is_adp5585 && pdata->en_keylock) {\n\t\tret |= adp5589_write(client, ADP5589_UNLOCK1,\n\t\t\t\t     pdata->unlock_key1);\n\t\tret |= adp5589_write(client, ADP5589_UNLOCK2,\n\t\t\t\t     pdata->unlock_key2);\n\t\tret |= adp5589_write(client, ADP5589_UNLOCK_TIMERS,\n\t\t\t\t     pdata->unlock_timer & LTIME_MASK);\n\t\tret |= adp5589_write(client, ADP5589_LOCK_CFG, LOCK_EN);\n\t}\n\n\tfor (i = 0; i < KEYP_MAX_EVENT; i++)\n\t\tret |= adp5589_read(client, ADP5589_5_FIFO_1 + i);\n\n\tfor (i = 0; i < pdata->gpimapsize; i++) {\n\t\tunsigned short pin = pdata->gpimap[i].pin;\n\n\t\tif (pin <= kpad->var->gpi_pin_row_end) {\n\t\t\tevt_mode1 |= BIT(pin - kpad->var->gpi_pin_row_base);\n\t\t} else {\n\t\t\tevt_mode2 |=\n\t\t\t    BIT(pin - kpad->var->gpi_pin_col_base) & 0xFF;\n\t\t\tif (!kpad->is_adp5585)\n\t\t\t\tevt_mode3 |=\n\t\t\t\t    BIT(pin - kpad->var->gpi_pin_col_base) >> 8;\n\t\t}\n\t}\n\n\tif (pdata->gpimapsize) {\n\t\tret |= adp5589_write(client, reg(ADP5589_GPI_EVENT_EN_A),\n\t\t\t\t     evt_mode1);\n\t\tret |= adp5589_write(client, reg(ADP5589_GPI_EVENT_EN_B),\n\t\t\t\t     evt_mode2);\n\t\tif (!kpad->is_adp5585)\n\t\t\tret |= adp5589_write(client,\n\t\t\t\t\t     reg(ADP5589_GPI_EVENT_EN_C),\n\t\t\t\t\t     evt_mode3);\n\t}\n\n\tif (pdata->pull_dis_mask & pdata->pullup_en_100k &\n\t\tpdata->pullup_en_300k & pdata->pulldown_en_300k)\n\t\tdev_warn(&client->dev, \"Conflicting pull resistor config\\n\");\n\n\tfor (i = 0; i <= kpad->var->max_row_num; i++) {\n\t\tunsigned int val = 0, bit = BIT(i);\n\t\tif (pdata->pullup_en_300k & bit)\n\t\t\tval = 0;\n\t\telse if (pdata->pulldown_en_300k & bit)\n\t\t\tval = 1;\n\t\telse if (pdata->pullup_en_100k & bit)\n\t\t\tval = 2;\n\t\telse if (pdata->pull_dis_mask & bit)\n\t\t\tval = 3;\n\n\t\tpull_mask |= val << (2 * (i & 0x3));\n\n\t\tif (i % 4 == 3 || i == kpad->var->max_row_num) {\n\t\t\tret |= adp5589_write(client, reg(ADP5585_RPULL_CONFIG_A)\n\t\t\t\t\t     + (i >> 2), pull_mask);\n\t\t\tpull_mask = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= kpad->var->max_col_num; i++) {\n\t\tunsigned int val = 0, bit = BIT(i + kpad->var->col_shift);\n\t\tif (pdata->pullup_en_300k & bit)\n\t\t\tval = 0;\n\t\telse if (pdata->pulldown_en_300k & bit)\n\t\t\tval = 1;\n\t\telse if (pdata->pullup_en_100k & bit)\n\t\t\tval = 2;\n\t\telse if (pdata->pull_dis_mask & bit)\n\t\t\tval = 3;\n\n\t\tpull_mask |= val << (2 * (i & 0x3));\n\n\t\tif (i % 4 == 3 || i == kpad->var->max_col_num) {\n\t\t\tret |= adp5589_write(client,\n\t\t\t\t\t     reg(ADP5585_RPULL_CONFIG_C) +\n\t\t\t\t\t     (i >> 2), pull_mask);\n\t\t\tpull_mask = 0;\n\t\t}\n\t}\n\n\tif (pdata->reset1_key_1 && pdata->reset1_key_2 && pdata->reset1_key_3) {\n\t\tret |= adp5589_write(client, reg(ADP5589_RESET1_EVENT_A),\n\t\t\t\t     adp5589_get_evcode(kpad,\n\t\t\t\t\t\t\tpdata->reset1_key_1));\n\t\tret |= adp5589_write(client, reg(ADP5589_RESET1_EVENT_B),\n\t\t\t\t     adp5589_get_evcode(kpad,\n\t\t\t\t\t\t\tpdata->reset1_key_2));\n\t\tret |= adp5589_write(client, reg(ADP5589_RESET1_EVENT_C),\n\t\t\t\t     adp5589_get_evcode(kpad,\n\t\t\t\t\t\t\tpdata->reset1_key_3));\n\t\tkpad->extend_cfg |= R4_EXTEND_CFG;\n\t}\n\n\tif (pdata->reset2_key_1 && pdata->reset2_key_2) {\n\t\tret |= adp5589_write(client, reg(ADP5589_RESET2_EVENT_A),\n\t\t\t\t     adp5589_get_evcode(kpad,\n\t\t\t\t\t\t\tpdata->reset2_key_1));\n\t\tret |= adp5589_write(client, reg(ADP5589_RESET2_EVENT_B),\n\t\t\t\t     adp5589_get_evcode(kpad,\n\t\t\t\t\t\t\tpdata->reset2_key_2));\n\t\tkpad->extend_cfg |= C4_EXTEND_CFG;\n\t}\n\n\tif (kpad->extend_cfg) {\n\t\tret |= adp5589_write(client, reg(ADP5589_RESET_CFG),\n\t\t\t\t     pdata->reset_cfg);\n\t\tret |= adp5589_write(client, reg(ADP5589_PIN_CONFIG_D),\n\t\t\t\t     kpad->extend_cfg);\n\t}\n\n\tret |= adp5589_write(client, reg(ADP5589_DEBOUNCE_DIS_A),\n\t\t\t    pdata->debounce_dis_mask & kpad->var->row_mask);\n\n\tret |= adp5589_write(client, reg(ADP5589_DEBOUNCE_DIS_B),\n\t\t\t     (pdata->debounce_dis_mask >> kpad->var->col_shift)\n\t\t\t     & kpad->var->col_mask);\n\n\tif (!kpad->is_adp5585)\n\t\tret |= adp5589_write(client, reg(ADP5589_DEBOUNCE_DIS_C),\n\t\t\t\t     (pdata->debounce_dis_mask >> 16) & 0xFF);\n\n\tret |= adp5589_write(client, reg(ADP5589_POLL_PTIME_CFG),\n\t\t\t     pdata->scan_cycle_time & PTIME_MASK);\n\tret |= adp5589_write(client, ADP5589_5_INT_STATUS,\n\t\t\t     (kpad->is_adp5585 ? 0 : LOGIC2_INT) |\n\t\t\t     LOGIC1_INT | OVRFLOW_INT |\n\t\t\t     (kpad->is_adp5585 ? 0 : LOCK_INT) |\n\t\t\t     GPI_INT | EVENT_INT);\t \n\n\tret |= adp5589_write(client, reg(ADP5589_GENERAL_CFG),\n\t\t\t     INT_CFG | OSC_EN | CORE_CLK(3));\n\tret |= adp5589_write(client, reg(ADP5589_INT_EN),\n\t\t\t     OVRFLOW_IEN | GPI_IEN | EVENT_IEN);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Write Error\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void adp5589_report_switch_state(struct adp5589_kpad *kpad)\n{\n\tint gpi_stat_tmp, pin_loc;\n\tint i;\n\tint gpi_stat1 = adp5589_read(kpad->client,\n\t\t\t\t     kpad->var->reg(ADP5589_GPI_STATUS_A));\n\tint gpi_stat2 = adp5589_read(kpad->client,\n\t\t\t\t     kpad->var->reg(ADP5589_GPI_STATUS_B));\n\tint gpi_stat3 = !kpad->is_adp5585 ?\n\t\t\tadp5589_read(kpad->client, ADP5589_GPI_STATUS_C) : 0;\n\n\tfor (i = 0; i < kpad->gpimapsize; i++) {\n\t\tunsigned short pin = kpad->gpimap[i].pin;\n\n\t\tif (pin <= kpad->var->gpi_pin_row_end) {\n\t\t\tgpi_stat_tmp = gpi_stat1;\n\t\t\tpin_loc = pin - kpad->var->gpi_pin_row_base;\n\t\t} else if ((pin - kpad->var->gpi_pin_col_base) < 8) {\n\t\t\tgpi_stat_tmp = gpi_stat2;\n\t\t\tpin_loc = pin - kpad->var->gpi_pin_col_base;\n\t\t} else {\n\t\t\tgpi_stat_tmp = gpi_stat3;\n\t\t\tpin_loc = pin - kpad->var->gpi_pin_col_base - 8;\n\t\t}\n\n\t\tif (gpi_stat_tmp < 0) {\n\t\t\tdev_err(&kpad->client->dev,\n\t\t\t\t\"Can't read GPIO_DAT_STAT switch %d, default to OFF\\n\",\n\t\t\t\tpin);\n\t\t\tgpi_stat_tmp = 0;\n\t\t}\n\n\t\tinput_report_switch(kpad->input,\n\t\t\t\t    kpad->gpimap[i].sw_evt,\n\t\t\t\t    !(gpi_stat_tmp & BIT(pin_loc)));\n\t}\n\n\tinput_sync(kpad->input);\n}\n\nstatic int adp5589_keypad_add(struct adp5589_kpad *kpad, unsigned int revid)\n{\n\tstruct i2c_client *client = kpad->client;\n\tconst struct adp5589_kpad_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tstruct input_dev *input;\n\tunsigned int i;\n\tint error;\n\n\tif (!((pdata->keypad_en_mask & kpad->var->row_mask) &&\n\t\t\t(pdata->keypad_en_mask >> kpad->var->col_shift)) ||\n\t\t\t!pdata->keymap) {\n\t\tdev_err(&client->dev, \"no rows, cols or keymap from pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->keymapsize != kpad->var->keymapsize) {\n\t\tdev_err(&client->dev, \"invalid keymapsize\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata->gpimap && pdata->gpimapsize) {\n\t\tdev_err(&client->dev, \"invalid gpimap from pdata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->gpimapsize > kpad->var->gpimapsize_max) {\n\t\tdev_err(&client->dev, \"invalid gpimapsize\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < pdata->gpimapsize; i++) {\n\t\tunsigned short pin = pdata->gpimap[i].pin;\n\n\t\tif (pin < kpad->var->gpi_pin_base ||\n\t\t\t\tpin > kpad->var->gpi_pin_end) {\n\t\t\tdev_err(&client->dev, \"invalid gpi pin data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BIT(pin - kpad->var->gpi_pin_row_base) &\n\t\t\t\tpdata->keypad_en_mask) {\n\t\t\tdev_err(&client->dev, \"invalid gpi row/col data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"no IRQ?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tkpad->input = input;\n\n\tinput->name = client->name;\n\tinput->phys = \"adp5589-keys/input0\";\n\tinput->dev.parent = &client->dev;\n\n\tinput_set_drvdata(input, kpad);\n\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = revid;\n\n\tinput->keycodesize = sizeof(kpad->keycode[0]);\n\tinput->keycodemax = pdata->keymapsize;\n\tinput->keycode = kpad->keycode;\n\n\tmemcpy(kpad->keycode, pdata->keymap,\n\t       pdata->keymapsize * input->keycodesize);\n\n\tkpad->gpimap = pdata->gpimap;\n\tkpad->gpimapsize = pdata->gpimapsize;\n\n\t \n\t__set_bit(EV_KEY, input->evbit);\n\n\tif (pdata->repeat)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tfor (i = 0; i < input->keycodemax; i++)\n\t\tif (kpad->keycode[i] <= KEY_MAX)\n\t\t\t__set_bit(kpad->keycode[i], input->keybit);\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\tif (kpad->gpimapsize)\n\t\t__set_bit(EV_SW, input->evbit);\n\tfor (i = 0; i < kpad->gpimapsize; i++)\n\t\t__set_bit(kpad->gpimap[i].sw_evt, input->swbit);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&client->dev, \"unable to register input device\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, adp5589_irq,\n\t\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t  client->dev.driver->name, kpad);\n\tif (error) {\n\t\tdev_err(&client->dev, \"unable to request irq %d\\n\", client->irq);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void adp5589_clear_config(void *data)\n{\n\tstruct i2c_client *client = data;\n\tstruct adp5589_kpad *kpad = i2c_get_clientdata(client);\n\n\tadp5589_write(client, kpad->var->reg(ADP5589_GENERAL_CFG), 0);\n}\n\nstatic int adp5589_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct adp5589_kpad *kpad;\n\tconst struct adp5589_kpad_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tunsigned int revid;\n\tint error, ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"SMBUS Byte Data not Supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"no platform data?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkpad = devm_kzalloc(&client->dev, sizeof(*kpad), GFP_KERNEL);\n\tif (!kpad)\n\t\treturn -ENOMEM;\n\n\tkpad->client = client;\n\n\tswitch (id->driver_data) {\n\tcase ADP5585_02:\n\t\tkpad->support_row5 = true;\n\t\tfallthrough;\n\tcase ADP5585_01:\n\t\tkpad->is_adp5585 = true;\n\t\tkpad->var = &const_adp5585;\n\t\tbreak;\n\tcase ADP5589:\n\t\tkpad->support_row5 = true;\n\t\tkpad->var = &const_adp5589;\n\t\tbreak;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev, adp5589_clear_config,\n\t\t\t\t\t client);\n\tif (error)\n\t\treturn error;\n\n\tret = adp5589_read(client, ADP5589_5_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trevid = (u8) ret & ADP5589_5_DEVICE_ID_MASK;\n\n\tif (pdata->keymapsize) {\n\t\terror = adp5589_keypad_add(kpad, revid);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = adp5589_setup(kpad);\n\tif (error)\n\t\treturn error;\n\n\tif (kpad->gpimapsize)\n\t\tadp5589_report_switch_state(kpad);\n\n\terror = adp5589_gpio_add(kpad);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, kpad);\n\n\tdev_info(&client->dev, \"Rev.%d keypad, irq %d\\n\", revid, client->irq);\n\treturn 0;\n}\n\nstatic int adp5589_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct adp5589_kpad *kpad = i2c_get_clientdata(client);\n\n\tif (kpad->input)\n\t\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int adp5589_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct adp5589_kpad *kpad = i2c_get_clientdata(client);\n\n\tif (kpad->input)\n\t\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(adp5589_dev_pm_ops, adp5589_suspend, adp5589_resume);\n\nstatic const struct i2c_device_id adp5589_id[] = {\n\t{\"adp5589-keys\", ADP5589},\n\t{\"adp5585-keys\", ADP5585_01},\n\t{\"adp5585-02-keys\", ADP5585_02},  \n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, adp5589_id);\n\nstatic struct i2c_driver adp5589_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.pm = pm_sleep_ptr(&adp5589_dev_pm_ops),\n\t},\n\t.probe = adp5589_probe,\n\t.id_table = adp5589_id,\n};\n\nmodule_i2c_driver(adp5589_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"ADP5589/ADP5585 Keypad driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}