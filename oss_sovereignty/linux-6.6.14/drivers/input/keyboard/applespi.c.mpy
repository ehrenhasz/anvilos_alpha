{
  "module_name": "applespi.c",
  "hash_id": "267e2cec8188ad9c3dbc16083369b3a0b32590bda42a77c044c3a8075a381edd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/applespi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/acpi.h>\n#include <linux/crc16.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/efi.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/ktime.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/spi/spi.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include <asm/barrier.h>\n#include <asm/unaligned.h>\n\n#define CREATE_TRACE_POINTS\n#include \"applespi.h\"\n#include \"applespi_trace.h\"\n\n#define APPLESPI_PACKET_SIZE\t256\n#define APPLESPI_STATUS_SIZE\t4\n\n#define PACKET_TYPE_READ\t0x20\n#define PACKET_TYPE_WRITE\t0x40\n#define PACKET_DEV_KEYB\t\t0x01\n#define PACKET_DEV_TPAD\t\t0x02\n#define PACKET_DEV_INFO\t\t0xd0\n\n#define MAX_ROLLOVER\t\t6\n\n#define MAX_FINGERS\t\t11\n#define MAX_FINGER_ORIENTATION\t16384\n#define MAX_PKTS_PER_MSG\t2\n\n#define KBD_BL_LEVEL_MIN\t32U\n#define KBD_BL_LEVEL_MAX\t255U\n#define KBD_BL_LEVEL_SCALE\t1000000U\n#define KBD_BL_LEVEL_ADJ\t\\\n\t((KBD_BL_LEVEL_MAX - KBD_BL_LEVEL_MIN) * KBD_BL_LEVEL_SCALE / 255U)\n\n#define EFI_BL_LEVEL_NAME\tL\"KeyboardBacklightLevel\"\n#define EFI_BL_LEVEL_GUID\tEFI_GUID(0xa076d2af, 0x9678, 0x4386, 0x8b, 0x58, 0x1f, 0xc8, 0xef, 0x04, 0x16, 0x19)\n\n#define APPLE_FLAG_FKEY\t\t0x01\n\n#define SPI_RW_CHG_DELAY_US\t100\t \n\n#define SYNAPTICS_VENDOR_ID\t0x06cb\n\nstatic unsigned int fnmode = 1;\nmodule_param(fnmode, uint, 0644);\nMODULE_PARM_DESC(fnmode, \"Mode of Fn key on Apple keyboards (0 = disabled, [1] = fkeyslast, 2 = fkeysfirst)\");\n\nstatic unsigned int fnremap;\nmodule_param(fnremap, uint, 0644);\nMODULE_PARM_DESC(fnremap, \"Remap Fn key ([0] = no-remap; 1 = left-ctrl, 2 = left-shift, 3 = left-alt, 4 = left-meta, 6 = right-shift, 7 = right-alt, 8 = right-meta)\");\n\nstatic bool iso_layout;\nmodule_param(iso_layout, bool, 0644);\nMODULE_PARM_DESC(iso_layout, \"Enable/Disable hardcoded ISO-layout of the keyboard. ([0] = disabled, 1 = enabled)\");\n\nstatic char touchpad_dimensions[40];\nmodule_param_string(touchpad_dimensions, touchpad_dimensions,\n\t\t    sizeof(touchpad_dimensions), 0444);\nMODULE_PARM_DESC(touchpad_dimensions, \"The pixel dimensions of the touchpad, as XxY+W+H .\");\n\n \nstruct keyboard_protocol {\n\tu8\t\t\tunknown1;\n\tu8\t\t\tmodifiers;\n\tu8\t\t\tunknown2;\n\tu8\t\t\tkeys_pressed[MAX_ROLLOVER];\n\tu8\t\t\tfn_pressed;\n\t__le16\t\t\tcrc16;\n};\n\n \nstruct tp_finger {\n\t__le16 origin;\n\t__le16 abs_x;\n\t__le16 abs_y;\n\t__le16 rel_x;\n\t__le16 rel_y;\n\t__le16 tool_major;\n\t__le16 tool_minor;\n\t__le16 orientation;\n\t__le16 touch_major;\n\t__le16 touch_minor;\n\t__le16 unused[2];\n\t__le16 pressure;\n\t__le16 multi;\n\t__le16 crc16;\n};\n\n \nstruct touchpad_protocol {\n\tu8\t\t\tunknown1[1];\n\tu8\t\t\tclicked;\n\tu8\t\t\tunknown2[28];\n\tu8\t\t\tnumber_of_fingers;\n\tu8\t\t\tclicked2;\n\tu8\t\t\tunknown3[16];\n\tstruct tp_finger\tfingers[];\n};\n\n \nstruct command_protocol_tp_info {\n\t__le16\t\t\tcrc16;\n};\n\n \nstruct touchpad_info_protocol {\n\tu8\t\t\tunknown1[105];\n\tu8\t\t\tmodel_flags;\n\tu8\t\t\tmodel_no;\n\tu8\t\t\tunknown2[3];\n\t__le16\t\t\tcrc16;\n};\n\n \nstruct command_protocol_mt_init {\n\t__le16\t\t\tcmd;\n\t__le16\t\t\tcrc16;\n};\n\n \nstruct command_protocol_capsl {\n\tu8\t\t\tunknown;\n\tu8\t\t\tled;\n\t__le16\t\t\tcrc16;\n};\n\n \nstruct command_protocol_bl {\n\t__le16\t\t\tconst1;\n\t__le16\t\t\tlevel;\n\t__le16\t\t\tconst2;\n\t__le16\t\t\tcrc16;\n};\n\n \nstruct message {\n\t__le16\t\ttype;\n\tu8\t\tzero;\n\tu8\t\tcounter;\n\t__le16\t\trsp_buf_len;\n\t__le16\t\tlength;\n\tunion {\n\t\tstruct keyboard_protocol\tkeyboard;\n\t\tstruct touchpad_protocol\ttouchpad;\n\t\tstruct touchpad_info_protocol\ttp_info;\n\t\tstruct command_protocol_tp_info\ttp_info_command;\n\t\tstruct command_protocol_mt_init\tinit_mt_command;\n\t\tstruct command_protocol_capsl\tcapsl_command;\n\t\tstruct command_protocol_bl\tbl_command;\n\t\tDECLARE_FLEX_ARRAY(u8, \t\tdata);\n\t};\n};\n\n \n#define MSG_HEADER_SIZE\t\t8\n\n \nstruct spi_packet {\n\tu8\t\t\tflags;\n\tu8\t\t\tdevice;\n\t__le16\t\t\toffset;\n\t__le16\t\t\tremaining;\n\t__le16\t\t\tlength;\n\tu8\t\t\tdata[246];\n\t__le16\t\t\tcrc16;\n};\n\nstruct spi_settings {\n\tu64\tspi_cs_delay;\t\t \n\tu64\treset_a2r_usec;\t\t \n\tu64\treset_rec_usec;\t\t \n};\n\n \nstruct applespi_tp_info {\n\tint\tx_min;\n\tint\ty_min;\n\tint\tx_max;\n\tint\ty_max;\n};\n\nstruct applespi_data {\n\tstruct spi_device\t\t*spi;\n\tstruct spi_settings\t\tspi_settings;\n\tstruct input_dev\t\t*keyboard_input_dev;\n\tstruct input_dev\t\t*touchpad_input_dev;\n\n\tu8\t\t\t\t*tx_buffer;\n\tu8\t\t\t\t*tx_status;\n\tu8\t\t\t\t*rx_buffer;\n\n\tu8\t\t\t\t*msg_buf;\n\tunsigned int\t\t\tsaved_msg_len;\n\n\tstruct applespi_tp_info\t\ttp_info;\n\n\tu8\t\t\t\tlast_keys_pressed[MAX_ROLLOVER];\n\tu8\t\t\t\tlast_keys_fn_pressed[MAX_ROLLOVER];\n\tu8\t\t\t\tlast_fn_pressed;\n\tstruct input_mt_pos\t\tpos[MAX_FINGERS];\n\tint\t\t\t\tslots[MAX_FINGERS];\n\tint\t\t\t\tgpe;\n\tacpi_handle\t\t\tsien;\n\tacpi_handle\t\t\tsist;\n\n\tstruct spi_transfer\t\tdl_t;\n\tstruct spi_transfer\t\trd_t;\n\tstruct spi_message\t\trd_m;\n\n\tstruct spi_transfer\t\tww_t;\n\tstruct spi_transfer\t\twd_t;\n\tstruct spi_transfer\t\twr_t;\n\tstruct spi_transfer\t\tst_t;\n\tstruct spi_message\t\twr_m;\n\n\tbool\t\t\t\twant_tp_info_cmd;\n\tbool\t\t\t\twant_mt_init_cmd;\n\tbool\t\t\t\twant_cl_led_on;\n\tbool\t\t\t\thave_cl_led_on;\n\tunsigned int\t\t\twant_bl_level;\n\tunsigned int\t\t\thave_bl_level;\n\tunsigned int\t\t\tcmd_msg_cntr;\n\t \n\tspinlock_t\t\t\tcmd_msg_lock;\n\tktime_t\t\t\t\tcmd_msg_queued;\n\tenum applespi_evt_type\t\tcmd_evt_type;\n\n\tstruct led_classdev\t\tbacklight_info;\n\n\tbool\t\t\t\tsuspended;\n\tbool\t\t\t\tdrain;\n\twait_queue_head_t\t\tdrain_complete;\n\tbool\t\t\t\tread_active;\n\tbool\t\t\t\twrite_active;\n\n\tstruct work_struct\t\twork;\n\tstruct touchpad_info_protocol\trcvd_tp_info;\n\n\tstruct dentry\t\t\t*debugfs_root;\n\tbool\t\t\t\tdebug_tp_dim;\n\tchar\t\t\t\ttp_dim_val[40];\n\tint\t\t\t\ttp_dim_min_x;\n\tint\t\t\t\ttp_dim_max_x;\n\tint\t\t\t\ttp_dim_min_y;\n\tint\t\t\t\ttp_dim_max_y;\n};\n\nstatic const unsigned char applespi_scancodes[] = {\n\t0, 0, 0, 0,\n\tKEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J,\n\tKEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T,\n\tKEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z,\n\tKEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_0,\n\tKEY_ENTER, KEY_ESC, KEY_BACKSPACE, KEY_TAB, KEY_SPACE, KEY_MINUS,\n\tKEY_EQUAL, KEY_LEFTBRACE, KEY_RIGHTBRACE, KEY_BACKSLASH, 0,\n\tKEY_SEMICOLON, KEY_APOSTROPHE, KEY_GRAVE, KEY_COMMA, KEY_DOT, KEY_SLASH,\n\tKEY_CAPSLOCK,\n\tKEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9,\n\tKEY_F10, KEY_F11, KEY_F12, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\tKEY_RIGHT, KEY_LEFT, KEY_DOWN, KEY_UP,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, KEY_102ND,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, KEY_RO, 0, KEY_YEN, 0, 0, 0, 0, 0,\n\t0, KEY_KATAKANAHIRAGANA, KEY_MUHENKAN\n};\n\n \nstatic const unsigned char applespi_controlcodes[] = {\n\tKEY_LEFTCTRL,\n\tKEY_LEFTSHIFT,\n\tKEY_LEFTALT,\n\tKEY_LEFTMETA,\n\t0,\n\tKEY_RIGHTSHIFT,\n\tKEY_RIGHTALT,\n\tKEY_RIGHTMETA\n};\n\nstruct applespi_key_translation {\n\tu16 from;\n\tu16 to;\n\tu8 flags;\n};\n\nstatic const struct applespi_key_translation applespi_fn_codes[] = {\n\t{ KEY_BACKSPACE, KEY_DELETE },\n\t{ KEY_ENTER,\tKEY_INSERT },\n\t{ KEY_F1,\tKEY_BRIGHTNESSDOWN,\tAPPLE_FLAG_FKEY },\n\t{ KEY_F2,\tKEY_BRIGHTNESSUP,\tAPPLE_FLAG_FKEY },\n\t{ KEY_F3,\tKEY_SCALE,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F4,\tKEY_DASHBOARD,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F5,\tKEY_KBDILLUMDOWN,\tAPPLE_FLAG_FKEY },\n\t{ KEY_F6,\tKEY_KBDILLUMUP,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F7,\tKEY_PREVIOUSSONG,\tAPPLE_FLAG_FKEY },\n\t{ KEY_F8,\tKEY_PLAYPAUSE,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F9,\tKEY_NEXTSONG,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F10,\tKEY_MUTE,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F11,\tKEY_VOLUMEDOWN,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_F12,\tKEY_VOLUMEUP,\t\tAPPLE_FLAG_FKEY },\n\t{ KEY_RIGHT,\tKEY_END },\n\t{ KEY_LEFT,\tKEY_HOME },\n\t{ KEY_DOWN,\tKEY_PAGEDOWN },\n\t{ KEY_UP,\tKEY_PAGEUP },\n\t{ }\n};\n\nstatic const struct applespi_key_translation apple_iso_keyboard[] = {\n\t{ KEY_GRAVE,\tKEY_102ND },\n\t{ KEY_102ND,\tKEY_GRAVE },\n\t{ }\n};\n\nstruct applespi_tp_model_info {\n\tu16\t\t\tmodel;\n\tstruct applespi_tp_info\ttp_info;\n};\n\nstatic const struct applespi_tp_model_info applespi_tp_models[] = {\n\t{\n\t\t.model = 0x04,\t \n\t\t.tp_info = { -5087, -182, 5579, 6089 },\n\t},\n\t{\n\t\t.model = 0x05,\t \n\t\t.tp_info = { -6243, -170, 6749, 7685 },\n\t},\n\t{\n\t\t.model = 0x06,\t \n\t\t.tp_info = { -7456, -163, 7976, 9283 },\n\t},\n\t{}\n};\n\ntypedef void (*applespi_trace_fun)(enum applespi_evt_type,\n\t\t\t\t   enum applespi_pkt_type, u8 *, size_t);\n\nstatic applespi_trace_fun applespi_get_trace_fun(enum applespi_evt_type type)\n{\n\tswitch (type) {\n\tcase ET_CMD_TP_INI:\n\t\treturn trace_applespi_tp_ini_cmd;\n\tcase ET_CMD_BL:\n\t\treturn trace_applespi_backlight_cmd;\n\tcase ET_CMD_CL:\n\t\treturn trace_applespi_caps_lock_cmd;\n\tcase ET_RD_KEYB:\n\t\treturn trace_applespi_keyboard_data;\n\tcase ET_RD_TPAD:\n\t\treturn trace_applespi_touchpad_data;\n\tcase ET_RD_UNKN:\n\t\treturn trace_applespi_unknown_data;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown msg type %d\", type);\n\t\treturn trace_applespi_unknown_data;\n\t}\n}\n\nstatic void applespi_setup_read_txfrs(struct applespi_data *applespi)\n{\n\tstruct spi_message *msg = &applespi->rd_m;\n\tstruct spi_transfer *dl_t = &applespi->dl_t;\n\tstruct spi_transfer *rd_t = &applespi->rd_t;\n\n\tmemset(dl_t, 0, sizeof(*dl_t));\n\tmemset(rd_t, 0, sizeof(*rd_t));\n\n\tdl_t->delay.value = applespi->spi_settings.spi_cs_delay;\n\tdl_t->delay.unit = SPI_DELAY_UNIT_USECS;\n\n\trd_t->rx_buf = applespi->rx_buffer;\n\trd_t->len = APPLESPI_PACKET_SIZE;\n\n\tspi_message_init(msg);\n\tspi_message_add_tail(dl_t, msg);\n\tspi_message_add_tail(rd_t, msg);\n}\n\nstatic void applespi_setup_write_txfrs(struct applespi_data *applespi)\n{\n\tstruct spi_message *msg = &applespi->wr_m;\n\tstruct spi_transfer *wt_t = &applespi->ww_t;\n\tstruct spi_transfer *dl_t = &applespi->wd_t;\n\tstruct spi_transfer *wr_t = &applespi->wr_t;\n\tstruct spi_transfer *st_t = &applespi->st_t;\n\n\tmemset(wt_t, 0, sizeof(*wt_t));\n\tmemset(dl_t, 0, sizeof(*dl_t));\n\tmemset(wr_t, 0, sizeof(*wr_t));\n\tmemset(st_t, 0, sizeof(*st_t));\n\n\t \n\twt_t->delay.value = SPI_RW_CHG_DELAY_US;\n\twt_t->delay.unit = SPI_DELAY_UNIT_USECS;\n\twt_t->cs_change = 1;\n\n\tdl_t->delay.value = applespi->spi_settings.spi_cs_delay;\n\tdl_t->delay.unit = SPI_DELAY_UNIT_USECS;\n\n\twr_t->tx_buf = applespi->tx_buffer;\n\twr_t->len = APPLESPI_PACKET_SIZE;\n\twr_t->delay.value = SPI_RW_CHG_DELAY_US;\n\twr_t->delay.unit = SPI_DELAY_UNIT_USECS;\n\n\tst_t->rx_buf = applespi->tx_status;\n\tst_t->len = APPLESPI_STATUS_SIZE;\n\n\tspi_message_init(msg);\n\tspi_message_add_tail(wt_t, msg);\n\tspi_message_add_tail(dl_t, msg);\n\tspi_message_add_tail(wr_t, msg);\n\tspi_message_add_tail(st_t, msg);\n}\n\nstatic int applespi_async(struct applespi_data *applespi,\n\t\t\t  struct spi_message *message, void (*complete)(void *))\n{\n\tmessage->complete = complete;\n\tmessage->context = applespi;\n\n\treturn spi_async(applespi->spi, message);\n}\n\nstatic inline bool applespi_check_write_status(struct applespi_data *applespi,\n\t\t\t\t\t       int sts)\n{\n\tstatic u8 status_ok[] = { 0xac, 0x27, 0x68, 0xd5 };\n\n\tif (sts < 0) {\n\t\tdev_warn(&applespi->spi->dev, \"Error writing to device: %d\\n\",\n\t\t\t sts);\n\t\treturn false;\n\t}\n\n\tif (memcmp(applespi->tx_status, status_ok, APPLESPI_STATUS_SIZE)) {\n\t\tdev_warn(&applespi->spi->dev, \"Error writing to device: %*ph\\n\",\n\t\t\t APPLESPI_STATUS_SIZE, applespi->tx_status);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int applespi_get_spi_settings(struct applespi_data *applespi)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&applespi->spi->dev);\n\tconst union acpi_object *o;\n\tstruct spi_settings *settings = &applespi->spi_settings;\n\n\tif (!acpi_dev_get_property(adev, \"spiCSDelay\", ACPI_TYPE_BUFFER, &o))\n\t\tsettings->spi_cs_delay = *(u64 *)o->buffer.pointer;\n\telse\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Property spiCSDelay not found\\n\");\n\n\tif (!acpi_dev_get_property(adev, \"resetA2RUsec\", ACPI_TYPE_BUFFER, &o))\n\t\tsettings->reset_a2r_usec = *(u64 *)o->buffer.pointer;\n\telse\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Property resetA2RUsec not found\\n\");\n\n\tif (!acpi_dev_get_property(adev, \"resetRecUsec\", ACPI_TYPE_BUFFER, &o))\n\t\tsettings->reset_rec_usec = *(u64 *)o->buffer.pointer;\n\telse\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Property resetRecUsec not found\\n\");\n\n\tdev_dbg(&applespi->spi->dev,\n\t\t\"SPI settings: spi_cs_delay=%llu reset_a2r_usec=%llu reset_rec_usec=%llu\\n\",\n\t\tsettings->spi_cs_delay, settings->reset_a2r_usec,\n\t\tsettings->reset_rec_usec);\n\n\treturn 0;\n}\n\nstatic int applespi_setup_spi(struct applespi_data *applespi)\n{\n\tint sts;\n\n\tsts = applespi_get_spi_settings(applespi);\n\tif (sts)\n\t\treturn sts;\n\n\tspin_lock_init(&applespi->cmd_msg_lock);\n\tinit_waitqueue_head(&applespi->drain_complete);\n\n\treturn 0;\n}\n\nstatic int applespi_enable_spi(struct applespi_data *applespi)\n{\n\tacpi_status acpi_sts;\n\tunsigned long long spi_status;\n\n\t \n\tacpi_sts = acpi_evaluate_integer(applespi->sist, NULL, NULL,\n\t\t\t\t\t &spi_status);\n\tif (ACPI_SUCCESS(acpi_sts) && spi_status)\n\t\treturn 0;\n\n\t \n\tacpi_sts = acpi_execute_simple_method(applespi->sien, NULL, 1);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(&applespi->spi->dev, \"SIEN failed: %s\\n\",\n\t\t\tacpi_format_exception(acpi_sts));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmsleep(50);\n\n\treturn 0;\n}\n\nstatic int applespi_send_cmd_msg(struct applespi_data *applespi);\n\nstatic void applespi_msg_complete(struct applespi_data *applespi,\n\t\t\t\t  bool is_write_msg, bool is_read_compl)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tif (is_read_compl)\n\t\tapplespi->read_active = false;\n\tif (is_write_msg)\n\t\tapplespi->write_active = false;\n\n\tif (applespi->drain && !applespi->write_active)\n\t\twake_up_all(&applespi->drain_complete);\n\n\tif (is_write_msg) {\n\t\tapplespi->cmd_msg_queued = 0;\n\t\tapplespi_send_cmd_msg(applespi);\n\t}\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n}\n\nstatic void applespi_async_write_complete(void *context)\n{\n\tstruct applespi_data *applespi = context;\n\tenum applespi_evt_type evt_type = applespi->cmd_evt_type;\n\n\tapplespi_get_trace_fun(evt_type)(evt_type, PT_WRITE,\n\t\t\t\t\t applespi->tx_buffer,\n\t\t\t\t\t APPLESPI_PACKET_SIZE);\n\tapplespi_get_trace_fun(evt_type)(evt_type, PT_STATUS,\n\t\t\t\t\t applespi->tx_status,\n\t\t\t\t\t APPLESPI_STATUS_SIZE);\n\n\tudelay(SPI_RW_CHG_DELAY_US);\n\n\tif (!applespi_check_write_status(applespi, applespi->wr_m.status)) {\n\t\t \n\t\tapplespi_msg_complete(applespi, true, false);\n\t}\n}\n\nstatic int applespi_send_cmd_msg(struct applespi_data *applespi)\n{\n\tu16 crc;\n\tint sts;\n\tstruct spi_packet *packet = (struct spi_packet *)applespi->tx_buffer;\n\tstruct message *message = (struct message *)packet->data;\n\tu16 msg_len;\n\tu8 device;\n\n\t \n\tif (applespi->drain)\n\t\treturn 0;\n\n\t \n\tif (applespi->cmd_msg_queued) {\n\t\tif (ktime_ms_delta(ktime_get(), applespi->cmd_msg_queued) < 1000)\n\t\t\treturn 0;\n\n\t\tdev_warn(&applespi->spi->dev, \"Command %d timed out\\n\",\n\t\t\t applespi->cmd_evt_type);\n\n\t\tapplespi->cmd_msg_queued = 0;\n\t\tapplespi->write_active = false;\n\t}\n\n\t \n\tmemset(packet, 0, APPLESPI_PACKET_SIZE);\n\n\t \n\tif (applespi->want_tp_info_cmd) {\n\t\tapplespi->want_tp_info_cmd = false;\n\t\tapplespi->want_mt_init_cmd = true;\n\t\tapplespi->cmd_evt_type = ET_CMD_TP_INI;\n\n\t\t \n\t\tdevice = PACKET_DEV_INFO;\n\n\t\tmessage->type = cpu_to_le16(0x1020);\n\t\tmsg_len = sizeof(message->tp_info_command);\n\n\t\tmessage->zero = 0x02;\n\t\tmessage->rsp_buf_len = cpu_to_le16(0x0200);\n\n\t} else if (applespi->want_mt_init_cmd) {\n\t\tapplespi->want_mt_init_cmd = false;\n\t\tapplespi->cmd_evt_type = ET_CMD_TP_INI;\n\n\t\t \n\t\tdevice = PACKET_DEV_TPAD;\n\n\t\tmessage->type = cpu_to_le16(0x0252);\n\t\tmsg_len = sizeof(message->init_mt_command);\n\n\t\tmessage->init_mt_command.cmd = cpu_to_le16(0x0102);\n\n\t \n\t} else if (applespi->want_cl_led_on != applespi->have_cl_led_on) {\n\t\tapplespi->have_cl_led_on = applespi->want_cl_led_on;\n\t\tapplespi->cmd_evt_type = ET_CMD_CL;\n\n\t\t \n\t\tdevice = PACKET_DEV_KEYB;\n\n\t\tmessage->type = cpu_to_le16(0x0151);\n\t\tmsg_len = sizeof(message->capsl_command);\n\n\t\tmessage->capsl_command.unknown = 0x01;\n\t\tmessage->capsl_command.led = applespi->have_cl_led_on ? 2 : 0;\n\n\t \n\t} else if (applespi->want_bl_level != applespi->have_bl_level) {\n\t\tapplespi->have_bl_level = applespi->want_bl_level;\n\t\tapplespi->cmd_evt_type = ET_CMD_BL;\n\n\t\t \n\t\tdevice = PACKET_DEV_KEYB;\n\n\t\tmessage->type = cpu_to_le16(0xB051);\n\t\tmsg_len = sizeof(message->bl_command);\n\n\t\tmessage->bl_command.const1 = cpu_to_le16(0x01B0);\n\t\tmessage->bl_command.level =\n\t\t\t\tcpu_to_le16(applespi->have_bl_level);\n\n\t\tif (applespi->have_bl_level > 0)\n\t\t\tmessage->bl_command.const2 = cpu_to_le16(0x01F4);\n\t\telse\n\t\t\tmessage->bl_command.const2 = cpu_to_le16(0x0001);\n\n\t \n\t} else {\n\t\treturn 0;\n\t}\n\n\t \n\tpacket->flags = PACKET_TYPE_WRITE;\n\tpacket->device = device;\n\tpacket->length = cpu_to_le16(MSG_HEADER_SIZE + msg_len);\n\n\tmessage->counter = applespi->cmd_msg_cntr++ % (U8_MAX + 1);\n\n\tmessage->length = cpu_to_le16(msg_len - 2);\n\tif (!message->rsp_buf_len)\n\t\tmessage->rsp_buf_len = message->length;\n\n\tcrc = crc16(0, (u8 *)message, le16_to_cpu(packet->length) - 2);\n\tput_unaligned_le16(crc, &message->data[msg_len - 2]);\n\n\tcrc = crc16(0, (u8 *)packet, sizeof(*packet) - 2);\n\tpacket->crc16 = cpu_to_le16(crc);\n\n\t \n\tsts = applespi_async(applespi, &applespi->wr_m,\n\t\t\t     applespi_async_write_complete);\n\tif (sts) {\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Error queueing async write to device: %d\\n\", sts);\n\t\treturn sts;\n\t}\n\n\tapplespi->cmd_msg_queued = ktime_get_coarse();\n\tapplespi->write_active = true;\n\n\treturn 0;\n}\n\nstatic void applespi_init(struct applespi_data *applespi, bool is_resume)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tif (is_resume)\n\t\tapplespi->want_mt_init_cmd = true;\n\telse\n\t\tapplespi->want_tp_info_cmd = true;\n\tapplespi_send_cmd_msg(applespi);\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n}\n\nstatic int applespi_set_capsl_led(struct applespi_data *applespi,\n\t\t\t\t  bool capslock_on)\n{\n\tunsigned long flags;\n\tint sts;\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tapplespi->want_cl_led_on = capslock_on;\n\tsts = applespi_send_cmd_msg(applespi);\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n\n\treturn sts;\n}\n\nstatic void applespi_set_bl_level(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness value)\n{\n\tstruct applespi_data *applespi =\n\t\tcontainer_of(led_cdev, struct applespi_data, backlight_info);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tif (value == 0) {\n\t\tapplespi->want_bl_level = value;\n\t} else {\n\t\t \n\t\tapplespi->want_bl_level =\n\t\t\t((value * KBD_BL_LEVEL_ADJ) / KBD_BL_LEVEL_SCALE +\n\t\t\t KBD_BL_LEVEL_MIN);\n\t}\n\n\tapplespi_send_cmd_msg(applespi);\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n}\n\nstatic int applespi_event(struct input_dev *dev, unsigned int type,\n\t\t\t  unsigned int code, int value)\n{\n\tstruct applespi_data *applespi = input_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase EV_LED:\n\t\tapplespi_set_capsl_led(applespi, !!test_bit(LED_CAPSL, dev->led));\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n \nstatic inline int le16_to_int(__le16 x)\n{\n\treturn (signed short)le16_to_cpu(x);\n}\n\nstatic void applespi_debug_update_dimensions(struct applespi_data *applespi,\n\t\t\t\t\t     const struct tp_finger *f)\n{\n\tapplespi->tp_dim_min_x = min(applespi->tp_dim_min_x,\n\t\t\t\t     le16_to_int(f->abs_x));\n\tapplespi->tp_dim_max_x = max(applespi->tp_dim_max_x,\n\t\t\t\t     le16_to_int(f->abs_x));\n\tapplespi->tp_dim_min_y = min(applespi->tp_dim_min_y,\n\t\t\t\t     le16_to_int(f->abs_y));\n\tapplespi->tp_dim_max_y = max(applespi->tp_dim_max_y,\n\t\t\t\t     le16_to_int(f->abs_y));\n}\n\nstatic int applespi_tp_dim_open(struct inode *inode, struct file *file)\n{\n\tstruct applespi_data *applespi = inode->i_private;\n\n\tfile->private_data = applespi;\n\n\tsnprintf(applespi->tp_dim_val, sizeof(applespi->tp_dim_val),\n\t\t \"0x%.4x %dx%d+%u+%u\\n\",\n\t\t applespi->touchpad_input_dev->id.product,\n\t\t applespi->tp_dim_min_x, applespi->tp_dim_min_y,\n\t\t applespi->tp_dim_max_x - applespi->tp_dim_min_x,\n\t\t applespi->tp_dim_max_y - applespi->tp_dim_min_y);\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t applespi_tp_dim_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *off)\n{\n\tstruct applespi_data *applespi = file->private_data;\n\n\treturn simple_read_from_buffer(buf, len, off, applespi->tp_dim_val,\n\t\t\t\t       strlen(applespi->tp_dim_val));\n}\n\nstatic const struct file_operations applespi_tp_dim_fops = {\n\t.owner = THIS_MODULE,\n\t.open = applespi_tp_dim_open,\n\t.read = applespi_tp_dim_read,\n\t.llseek = no_llseek,\n};\n\nstatic void report_finger_data(struct input_dev *input, int slot,\n\t\t\t       const struct input_mt_pos *pos,\n\t\t\t       const struct tp_finger *f)\n{\n\tinput_mt_slot(input, slot);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\n\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t le16_to_int(f->touch_major) << 1);\n\tinput_report_abs(input, ABS_MT_TOUCH_MINOR,\n\t\t\t le16_to_int(f->touch_minor) << 1);\n\tinput_report_abs(input, ABS_MT_WIDTH_MAJOR,\n\t\t\t le16_to_int(f->tool_major) << 1);\n\tinput_report_abs(input, ABS_MT_WIDTH_MINOR,\n\t\t\t le16_to_int(f->tool_minor) << 1);\n\tinput_report_abs(input, ABS_MT_ORIENTATION,\n\t\t\t MAX_FINGER_ORIENTATION - le16_to_int(f->orientation));\n\tinput_report_abs(input, ABS_MT_POSITION_X, pos->x);\n\tinput_report_abs(input, ABS_MT_POSITION_Y, pos->y);\n}\n\nstatic void report_tp_state(struct applespi_data *applespi,\n\t\t\t    struct touchpad_protocol *t)\n{\n\tconst struct tp_finger *f;\n\tstruct input_dev *input;\n\tconst struct applespi_tp_info *tp_info = &applespi->tp_info;\n\tint i, n;\n\n\t \n\tinput = smp_load_acquire(&applespi->touchpad_input_dev);\n\tif (!input)\n\t\treturn;\t \n\n\tn = 0;\n\n\tfor (i = 0; i < t->number_of_fingers; i++) {\n\t\tf = &t->fingers[i];\n\t\tif (le16_to_int(f->touch_major) == 0)\n\t\t\tcontinue;\n\t\tapplespi->pos[n].x = le16_to_int(f->abs_x);\n\t\tapplespi->pos[n].y = tp_info->y_min + tp_info->y_max -\n\t\t\t\t     le16_to_int(f->abs_y);\n\t\tn++;\n\n\t\tif (applespi->debug_tp_dim)\n\t\t\tapplespi_debug_update_dimensions(applespi, f);\n\t}\n\n\tinput_mt_assign_slots(input, applespi->slots, applespi->pos, n, 0);\n\n\tfor (i = 0; i < n; i++)\n\t\treport_finger_data(input, applespi->slots[i],\n\t\t\t\t   &applespi->pos[i], &t->fingers[i]);\n\n\tinput_mt_sync_frame(input);\n\tinput_report_key(input, BTN_LEFT, t->clicked);\n\n\tinput_sync(input);\n}\n\nstatic const struct applespi_key_translation *\napplespi_find_translation(const struct applespi_key_translation *table, u16 key)\n{\n\tconst struct applespi_key_translation *trans;\n\n\tfor (trans = table; trans->from; trans++)\n\t\tif (trans->from == key)\n\t\t\treturn trans;\n\n\treturn NULL;\n}\n\nstatic unsigned int applespi_translate_fn_key(unsigned int key, int fn_pressed)\n{\n\tconst struct applespi_key_translation *trans;\n\tint do_translate;\n\n\ttrans = applespi_find_translation(applespi_fn_codes, key);\n\tif (trans) {\n\t\tif (trans->flags & APPLE_FLAG_FKEY)\n\t\t\tdo_translate = (fnmode == 2 && fn_pressed) ||\n\t\t\t\t       (fnmode == 1 && !fn_pressed);\n\t\telse\n\t\t\tdo_translate = fn_pressed;\n\n\t\tif (do_translate)\n\t\t\tkey = trans->to;\n\t}\n\n\treturn key;\n}\n\nstatic unsigned int applespi_translate_iso_layout(unsigned int key)\n{\n\tconst struct applespi_key_translation *trans;\n\n\ttrans = applespi_find_translation(apple_iso_keyboard, key);\n\tif (trans)\n\t\tkey = trans->to;\n\n\treturn key;\n}\n\nstatic unsigned int applespi_code_to_key(u8 code, int fn_pressed)\n{\n\tunsigned int key = applespi_scancodes[code];\n\n\tif (fnmode)\n\t\tkey = applespi_translate_fn_key(key, fn_pressed);\n\tif (iso_layout)\n\t\tkey = applespi_translate_iso_layout(key);\n\treturn key;\n}\n\nstatic void\napplespi_remap_fn_key(struct keyboard_protocol *keyboard_protocol)\n{\n\tunsigned char tmp;\n\tu8 bit = BIT((fnremap - 1) & 0x07);\n\n\tif (!fnremap || fnremap > ARRAY_SIZE(applespi_controlcodes) ||\n\t    !applespi_controlcodes[fnremap - 1])\n\t\treturn;\n\n\ttmp = keyboard_protocol->fn_pressed;\n\tkeyboard_protocol->fn_pressed = !!(keyboard_protocol->modifiers & bit);\n\tif (tmp)\n\t\tkeyboard_protocol->modifiers |= bit;\n\telse\n\t\tkeyboard_protocol->modifiers &= ~bit;\n}\n\nstatic void\napplespi_handle_keyboard_event(struct applespi_data *applespi,\n\t\t\t       struct keyboard_protocol *keyboard_protocol)\n{\n\tunsigned int key;\n\tint i;\n\n\tcompiletime_assert(ARRAY_SIZE(applespi_controlcodes) ==\n\t\t\t   sizeof_field(struct keyboard_protocol, modifiers) * 8,\n\t\t\t   \"applespi_controlcodes has wrong number of entries\");\n\n\t \n\tif (!memchr_inv(keyboard_protocol->keys_pressed, 1, MAX_ROLLOVER))\n\t\treturn;\n\n\t \n\tapplespi_remap_fn_key(keyboard_protocol);\n\n\t \n\tfor (i = 0; i < MAX_ROLLOVER; i++) {\n\t\tif (memchr(keyboard_protocol->keys_pressed,\n\t\t\t   applespi->last_keys_pressed[i], MAX_ROLLOVER))\n\t\t\tcontinue;\t \n\n\t\tkey = applespi_code_to_key(applespi->last_keys_pressed[i],\n\t\t\t\t\t   applespi->last_keys_fn_pressed[i]);\n\t\tinput_report_key(applespi->keyboard_input_dev, key, 0);\n\t\tapplespi->last_keys_fn_pressed[i] = 0;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_ROLLOVER; i++) {\n\t\tif (keyboard_protocol->keys_pressed[i] <\n\t\t\t\tARRAY_SIZE(applespi_scancodes) &&\n\t\t    keyboard_protocol->keys_pressed[i] > 0) {\n\t\t\tkey = applespi_code_to_key(\n\t\t\t\t\tkeyboard_protocol->keys_pressed[i],\n\t\t\t\t\tkeyboard_protocol->fn_pressed);\n\t\t\tinput_report_key(applespi->keyboard_input_dev, key, 1);\n\t\t\tapplespi->last_keys_fn_pressed[i] =\n\t\t\t\t\tkeyboard_protocol->fn_pressed;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(applespi_controlcodes); i++) {\n\t\tif (keyboard_protocol->modifiers & BIT(i))\n\t\t\tinput_report_key(applespi->keyboard_input_dev,\n\t\t\t\t\t applespi_controlcodes[i], 1);\n\t\telse\n\t\t\tinput_report_key(applespi->keyboard_input_dev,\n\t\t\t\t\t applespi_controlcodes[i], 0);\n\t}\n\n\t \n\tif (keyboard_protocol->fn_pressed && !applespi->last_fn_pressed)\n\t\tinput_report_key(applespi->keyboard_input_dev, KEY_FN, 1);\n\telse if (!keyboard_protocol->fn_pressed && applespi->last_fn_pressed)\n\t\tinput_report_key(applespi->keyboard_input_dev, KEY_FN, 0);\n\tapplespi->last_fn_pressed = keyboard_protocol->fn_pressed;\n\n\t \n\tinput_sync(applespi->keyboard_input_dev);\n\tmemcpy(&applespi->last_keys_pressed, keyboard_protocol->keys_pressed,\n\t       sizeof(applespi->last_keys_pressed));\n}\n\nstatic const struct applespi_tp_info *applespi_find_touchpad_info(u8 model)\n{\n\tconst struct applespi_tp_model_info *info;\n\n\tfor (info = applespi_tp_models; info->model; info++) {\n\t\tif (info->model == model)\n\t\t\treturn &info->tp_info;\n\t}\n\n\treturn NULL;\n}\n\nstatic int\napplespi_register_touchpad_device(struct applespi_data *applespi,\n\t\t\t\t  struct touchpad_info_protocol *rcvd_tp_info)\n{\n\tconst struct applespi_tp_info *tp_info;\n\tstruct input_dev *touchpad_input_dev;\n\tint sts;\n\n\t \n\ttp_info = applespi_find_touchpad_info(rcvd_tp_info->model_no);\n\tif (!tp_info) {\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Unknown touchpad model %x - falling back to MB8 touchpad\\n\",\n\t\t\t rcvd_tp_info->model_no);\n\t\ttp_info = &applespi_tp_models[0].tp_info;\n\t}\n\n\tapplespi->tp_info = *tp_info;\n\n\tif (touchpad_dimensions[0]) {\n\t\tint x, y, w, h;\n\n\t\tsts = sscanf(touchpad_dimensions, \"%dx%d+%u+%u\", &x, &y, &w, &h);\n\t\tif (sts == 4) {\n\t\t\tdev_info(&applespi->spi->dev,\n\t\t\t\t \"Overriding touchpad dimensions from module param\\n\");\n\t\t\tapplespi->tp_info.x_min = x;\n\t\t\tapplespi->tp_info.y_min = y;\n\t\t\tapplespi->tp_info.x_max = x + w;\n\t\t\tapplespi->tp_info.y_max = y + h;\n\t\t} else {\n\t\t\tdev_warn(&applespi->spi->dev,\n\t\t\t\t \"Invalid touchpad dimensions '%s': must be in the form XxY+W+H\\n\",\n\t\t\t\t touchpad_dimensions);\n\t\t\ttouchpad_dimensions[0] = '\\0';\n\t\t}\n\t}\n\tif (!touchpad_dimensions[0]) {\n\t\tsnprintf(touchpad_dimensions, sizeof(touchpad_dimensions),\n\t\t\t \"%dx%d+%u+%u\",\n\t\t\t applespi->tp_info.x_min,\n\t\t\t applespi->tp_info.y_min,\n\t\t\t applespi->tp_info.x_max - applespi->tp_info.x_min,\n\t\t\t applespi->tp_info.y_max - applespi->tp_info.y_min);\n\t}\n\n\t \n\ttouchpad_input_dev = devm_input_allocate_device(&applespi->spi->dev);\n\tif (!touchpad_input_dev) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to allocate touchpad input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttouchpad_input_dev->name = \"Apple SPI Touchpad\";\n\ttouchpad_input_dev->phys = \"applespi/input1\";\n\ttouchpad_input_dev->dev.parent = &applespi->spi->dev;\n\ttouchpad_input_dev->id.bustype = BUS_SPI;\n\ttouchpad_input_dev->id.vendor = SYNAPTICS_VENDOR_ID;\n\ttouchpad_input_dev->id.product =\n\t\t\trcvd_tp_info->model_no << 8 | rcvd_tp_info->model_flags;\n\n\t \n\tinput_set_capability(touchpad_input_dev, EV_REL, REL_X);\n\tinput_set_capability(touchpad_input_dev, EV_REL, REL_Y);\n\n\t__set_bit(INPUT_PROP_POINTER, touchpad_input_dev->propbit);\n\t__set_bit(INPUT_PROP_BUTTONPAD, touchpad_input_dev->propbit);\n\n\t \n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, 5000, 0, 0);\n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_TOUCH_MINOR,\n\t\t\t     0, 5000, 0, 0);\n\n\t \n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_WIDTH_MAJOR,\n\t\t\t     0, 5000, 0, 0);\n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_WIDTH_MINOR,\n\t\t\t     0, 5000, 0, 0);\n\n\t \n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_ORIENTATION,\n\t\t\t     -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION,\n\t\t\t     0, 0);\n\n\t \n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_POSITION_X,\n\t\t\t     applespi->tp_info.x_min, applespi->tp_info.x_max,\n\t\t\t     0, 0);\n\tinput_set_abs_params(touchpad_input_dev, ABS_MT_POSITION_Y,\n\t\t\t     applespi->tp_info.y_min, applespi->tp_info.y_max,\n\t\t\t     0, 0);\n\n\t \n\tinput_set_capability(touchpad_input_dev, EV_KEY, BTN_LEFT);\n\n\t \n\tsts = input_mt_init_slots(touchpad_input_dev, MAX_FINGERS,\n\t\t\t\t  INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\n\t\t\t\t\tINPUT_MT_TRACK);\n\tif (sts) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"failed to initialize slots: %d\", sts);\n\t\treturn sts;\n\t}\n\n\t \n\tsts = input_register_device(touchpad_input_dev);\n\tif (sts) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Unable to register touchpad input device (%d)\\n\", sts);\n\t\treturn sts;\n\t}\n\n\t \n\tsmp_store_release(&applespi->touchpad_input_dev, touchpad_input_dev);\n\n\treturn 0;\n}\n\nstatic void applespi_worker(struct work_struct *work)\n{\n\tstruct applespi_data *applespi =\n\t\tcontainer_of(work, struct applespi_data, work);\n\n\tapplespi_register_touchpad_device(applespi, &applespi->rcvd_tp_info);\n}\n\nstatic void applespi_handle_cmd_response(struct applespi_data *applespi,\n\t\t\t\t\t struct spi_packet *packet,\n\t\t\t\t\t struct message *message)\n{\n\tif (packet->device == PACKET_DEV_INFO &&\n\t    le16_to_cpu(message->type) == 0x1020) {\n\t\t \n\t\tapplespi->rcvd_tp_info = message->tp_info;\n\t\tschedule_work(&applespi->work);\n\t\treturn;\n\t}\n\n\tif (le16_to_cpu(message->length) != 0x0000) {\n\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t     \"Received unexpected write response: length=%x\\n\",\n\t\t\t\t     le16_to_cpu(message->length));\n\t\treturn;\n\t}\n\n\tif (packet->device == PACKET_DEV_TPAD &&\n\t    le16_to_cpu(message->type) == 0x0252 &&\n\t    le16_to_cpu(message->rsp_buf_len) == 0x0002)\n\t\tdev_info(&applespi->spi->dev, \"modeswitch done.\\n\");\n}\n\nstatic bool applespi_verify_crc(struct applespi_data *applespi, u8 *buffer,\n\t\t\t\tsize_t buflen)\n{\n\tu16 crc;\n\n\tcrc = crc16(0, buffer, buflen);\n\tif (crc) {\n\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t     \"Received corrupted packet (crc mismatch)\\n\");\n\t\ttrace_applespi_bad_crc(ET_RD_CRC, READ, buffer, buflen);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void applespi_debug_print_read_packet(struct applespi_data *applespi,\n\t\t\t\t\t     struct spi_packet *packet)\n{\n\tunsigned int evt_type;\n\n\tif (packet->flags == PACKET_TYPE_READ &&\n\t    packet->device == PACKET_DEV_KEYB)\n\t\tevt_type = ET_RD_KEYB;\n\telse if (packet->flags == PACKET_TYPE_READ &&\n\t\t packet->device == PACKET_DEV_TPAD)\n\t\tevt_type = ET_RD_TPAD;\n\telse if (packet->flags == PACKET_TYPE_WRITE)\n\t\tevt_type = applespi->cmd_evt_type;\n\telse\n\t\tevt_type = ET_RD_UNKN;\n\n\tapplespi_get_trace_fun(evt_type)(evt_type, PT_READ, applespi->rx_buffer,\n\t\t\t\t\t APPLESPI_PACKET_SIZE);\n}\n\nstatic void applespi_got_data(struct applespi_data *applespi)\n{\n\tstruct spi_packet *packet;\n\tstruct message *message;\n\tunsigned int msg_len;\n\tunsigned int off;\n\tunsigned int rem;\n\tunsigned int len;\n\n\t \n\tif (!applespi_verify_crc(applespi, applespi->rx_buffer,\n\t\t\t\t APPLESPI_PACKET_SIZE)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\t\tif (applespi->drain) {\n\t\t\tapplespi->read_active = false;\n\t\t\tapplespi->write_active = false;\n\n\t\t\twake_up_all(&applespi->drain_complete);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n\n\t\treturn;\n\t}\n\n\tpacket = (struct spi_packet *)applespi->rx_buffer;\n\n\tapplespi_debug_print_read_packet(applespi, packet);\n\n\toff = le16_to_cpu(packet->offset);\n\trem = le16_to_cpu(packet->remaining);\n\tlen = le16_to_cpu(packet->length);\n\n\tif (len > sizeof(packet->data)) {\n\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t     \"Received corrupted packet (invalid packet length %u)\\n\",\n\t\t\t\t     len);\n\t\tgoto msg_complete;\n\t}\n\n\t \n\tif (rem > 0 || off > 0) {\n\t\tif (off != applespi->saved_msg_len) {\n\t\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t\t     \"Received unexpected offset (got %u, expected %u)\\n\",\n\t\t\t\t\t     off, applespi->saved_msg_len);\n\t\t\tgoto msg_complete;\n\t\t}\n\n\t\tif (off + rem > MAX_PKTS_PER_MSG * APPLESPI_PACKET_SIZE) {\n\t\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t\t     \"Received message too large (size %u)\\n\",\n\t\t\t\t\t     off + rem);\n\t\t\tgoto msg_complete;\n\t\t}\n\n\t\tif (off + len > MAX_PKTS_PER_MSG * APPLESPI_PACKET_SIZE) {\n\t\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t\t     \"Received message too large (size %u)\\n\",\n\t\t\t\t\t     off + len);\n\t\t\tgoto msg_complete;\n\t\t}\n\n\t\tmemcpy(applespi->msg_buf + off, &packet->data, len);\n\t\tapplespi->saved_msg_len += len;\n\n\t\tif (rem > 0)\n\t\t\treturn;\n\n\t\tmessage = (struct message *)applespi->msg_buf;\n\t\tmsg_len = applespi->saved_msg_len;\n\t} else {\n\t\tmessage = (struct message *)&packet->data;\n\t\tmsg_len = len;\n\t}\n\n\t \n\tif (!applespi_verify_crc(applespi, (u8 *)message, msg_len))\n\t\tgoto msg_complete;\n\n\tif (le16_to_cpu(message->length) != msg_len - MSG_HEADER_SIZE - 2) {\n\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t     \"Received corrupted packet (invalid message length %u - expected %u)\\n\",\n\t\t\t\t     le16_to_cpu(message->length),\n\t\t\t\t     msg_len - MSG_HEADER_SIZE - 2);\n\t\tgoto msg_complete;\n\t}\n\n\t \n\tif (packet->flags == PACKET_TYPE_READ &&\n\t    packet->device == PACKET_DEV_KEYB) {\n\t\tapplespi_handle_keyboard_event(applespi, &message->keyboard);\n\n\t} else if (packet->flags == PACKET_TYPE_READ &&\n\t\t   packet->device == PACKET_DEV_TPAD) {\n\t\tstruct touchpad_protocol *tp;\n\t\tsize_t tp_len;\n\n\t\ttp = &message->touchpad;\n\t\ttp_len = struct_size(tp, fingers, tp->number_of_fingers);\n\n\t\tif (le16_to_cpu(message->length) + 2 != tp_len) {\n\t\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t\t     \"Received corrupted packet (invalid message length %u - num-fingers %u, tp-len %zu)\\n\",\n\t\t\t\t\t     le16_to_cpu(message->length),\n\t\t\t\t\t     tp->number_of_fingers, tp_len);\n\t\t\tgoto msg_complete;\n\t\t}\n\n\t\tif (tp->number_of_fingers > MAX_FINGERS) {\n\t\t\tdev_warn_ratelimited(&applespi->spi->dev,\n\t\t\t\t\t     \"Number of reported fingers (%u) exceeds max (%u))\\n\",\n\t\t\t\t\t     tp->number_of_fingers,\n\t\t\t\t\t     MAX_FINGERS);\n\t\t\ttp->number_of_fingers = MAX_FINGERS;\n\t\t}\n\n\t\treport_tp_state(applespi, tp);\n\n\t} else if (packet->flags == PACKET_TYPE_WRITE) {\n\t\tapplespi_handle_cmd_response(applespi, packet, message);\n\t}\n\nmsg_complete:\n\tapplespi->saved_msg_len = 0;\n\n\tapplespi_msg_complete(applespi, packet->flags == PACKET_TYPE_WRITE,\n\t\t\t      true);\n}\n\nstatic void applespi_async_read_complete(void *context)\n{\n\tstruct applespi_data *applespi = context;\n\n\tif (applespi->rd_m.status < 0) {\n\t\tdev_warn(&applespi->spi->dev, \"Error reading from device: %d\\n\",\n\t\t\t applespi->rd_m.status);\n\t\t \n\t\tapplespi_msg_complete(applespi, true, true);\n\t} else {\n\t\tapplespi_got_data(applespi);\n\t}\n\n\tacpi_finish_gpe(NULL, applespi->gpe);\n}\n\nstatic u32 applespi_notify(acpi_handle gpe_device, u32 gpe, void *context)\n{\n\tstruct applespi_data *applespi = context;\n\tint sts;\n\tunsigned long flags;\n\n\ttrace_applespi_irq_received(ET_RD_IRQ, PT_READ);\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tif (!applespi->suspended) {\n\t\tsts = applespi_async(applespi, &applespi->rd_m,\n\t\t\t\t     applespi_async_read_complete);\n\t\tif (sts)\n\t\t\tdev_warn(&applespi->spi->dev,\n\t\t\t\t \"Error queueing async read to device: %d\\n\",\n\t\t\t\t sts);\n\t\telse\n\t\t\tapplespi->read_active = true;\n\t}\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n\n\treturn ACPI_INTERRUPT_HANDLED;\n}\n\nstatic int applespi_get_saved_bl_level(struct applespi_data *applespi)\n{\n\tefi_status_t sts = EFI_NOT_FOUND;\n\tu16 efi_data = 0;\n\tunsigned long efi_data_len = sizeof(efi_data);\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\tsts = efi.get_variable(EFI_BL_LEVEL_NAME, &EFI_BL_LEVEL_GUID,\n\t\t\t\t       NULL, &efi_data_len, &efi_data);\n\tif (sts != EFI_SUCCESS && sts != EFI_NOT_FOUND)\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Error getting backlight level from EFI vars: 0x%lx\\n\",\n\t\t\t sts);\n\n\treturn sts != EFI_SUCCESS ? -ENODEV : efi_data;\n}\n\nstatic void applespi_save_bl_level(struct applespi_data *applespi,\n\t\t\t\t   unsigned int level)\n{\n\tefi_status_t sts = EFI_UNSUPPORTED;\n\tu32 efi_attr;\n\tu16 efi_data;\n\n\tefi_data = (u16)level;\n\tefi_attr = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS |\n\t\t   EFI_VARIABLE_RUNTIME_ACCESS;\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_SET_VARIABLE))\n\t\tsts = efi.set_variable(EFI_BL_LEVEL_NAME, &EFI_BL_LEVEL_GUID,\n\t\t\t\t       efi_attr, sizeof(efi_data), &efi_data);\n\tif (sts != EFI_SUCCESS)\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Error saving backlight level to EFI vars: 0x%lx\\n\", sts);\n}\n\nstatic int applespi_probe(struct spi_device *spi)\n{\n\tstruct applespi_data *applespi;\n\tacpi_handle spi_handle = ACPI_HANDLE(&spi->dev);\n\tacpi_status acpi_sts;\n\tint sts, i;\n\tunsigned long long gpe, usb_status;\n\n\t \n\tacpi_sts = acpi_evaluate_integer(spi_handle, \"UIST\", NULL, &usb_status);\n\tif (ACPI_SUCCESS(acpi_sts) && usb_status) {\n\t\t \n\t\tdev_info(&spi->dev, \"USB interface already enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tapplespi = devm_kzalloc(&spi->dev, sizeof(*applespi), GFP_KERNEL);\n\tif (!applespi)\n\t\treturn -ENOMEM;\n\n\tapplespi->spi = spi;\n\n\tINIT_WORK(&applespi->work, applespi_worker);\n\n\t \n\tspi_set_drvdata(spi, applespi);\n\n\t \n\tapplespi->tx_buffer = devm_kmalloc(&spi->dev, APPLESPI_PACKET_SIZE,\n\t\t\t\t\t   GFP_KERNEL);\n\tapplespi->tx_status = devm_kmalloc(&spi->dev, APPLESPI_STATUS_SIZE,\n\t\t\t\t\t   GFP_KERNEL);\n\tapplespi->rx_buffer = devm_kmalloc(&spi->dev, APPLESPI_PACKET_SIZE,\n\t\t\t\t\t   GFP_KERNEL);\n\tapplespi->msg_buf = devm_kmalloc_array(&spi->dev, MAX_PKTS_PER_MSG,\n\t\t\t\t\t       APPLESPI_PACKET_SIZE,\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!applespi->tx_buffer || !applespi->tx_status ||\n\t    !applespi->rx_buffer || !applespi->msg_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tapplespi_setup_read_txfrs(applespi);\n\tapplespi_setup_write_txfrs(applespi);\n\n\t \n\tacpi_sts = acpi_get_handle(spi_handle, \"SIEN\", &applespi->sien);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to get SIEN ACPI method handle: %s\\n\",\n\t\t\tacpi_format_exception(acpi_sts));\n\t\treturn -ENODEV;\n\t}\n\n\tacpi_sts = acpi_get_handle(spi_handle, \"SIST\", &applespi->sist);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to get SIST ACPI method handle: %s\\n\",\n\t\t\tacpi_format_exception(acpi_sts));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsts = applespi_setup_spi(applespi);\n\tif (sts)\n\t\treturn sts;\n\n\tsts = applespi_enable_spi(applespi);\n\tif (sts)\n\t\treturn sts;\n\n\t \n\tapplespi->keyboard_input_dev = devm_input_allocate_device(&spi->dev);\n\n\tif (!applespi->keyboard_input_dev)\n\t\treturn -ENOMEM;\n\n\tapplespi->keyboard_input_dev->name = \"Apple SPI Keyboard\";\n\tapplespi->keyboard_input_dev->phys = \"applespi/input0\";\n\tapplespi->keyboard_input_dev->dev.parent = &spi->dev;\n\tapplespi->keyboard_input_dev->id.bustype = BUS_SPI;\n\n\tapplespi->keyboard_input_dev->evbit[0] =\n\t\t\tBIT_MASK(EV_KEY) | BIT_MASK(EV_LED) | BIT_MASK(EV_REP);\n\tapplespi->keyboard_input_dev->ledbit[0] = BIT_MASK(LED_CAPSL);\n\n\tinput_set_drvdata(applespi->keyboard_input_dev, applespi);\n\tapplespi->keyboard_input_dev->event = applespi_event;\n\n\tfor (i = 0; i < ARRAY_SIZE(applespi_scancodes); i++)\n\t\tif (applespi_scancodes[i])\n\t\t\tinput_set_capability(applespi->keyboard_input_dev,\n\t\t\t\t\t     EV_KEY, applespi_scancodes[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(applespi_controlcodes); i++)\n\t\tif (applespi_controlcodes[i])\n\t\t\tinput_set_capability(applespi->keyboard_input_dev,\n\t\t\t\t\t     EV_KEY, applespi_controlcodes[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(applespi_fn_codes); i++)\n\t\tif (applespi_fn_codes[i].to)\n\t\t\tinput_set_capability(applespi->keyboard_input_dev,\n\t\t\t\t\t     EV_KEY, applespi_fn_codes[i].to);\n\n\tinput_set_capability(applespi->keyboard_input_dev, EV_KEY, KEY_FN);\n\n\tsts = input_register_device(applespi->keyboard_input_dev);\n\tif (sts) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Unable to register keyboard input device (%d)\\n\", sts);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tacpi_sts = acpi_evaluate_integer(spi_handle, \"_GPE\", NULL, &gpe);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to obtain GPE for SPI slave device: %s\\n\",\n\t\t\tacpi_format_exception(acpi_sts));\n\t\treturn -ENODEV;\n\t}\n\tapplespi->gpe = (int)gpe;\n\n\tacpi_sts = acpi_install_gpe_handler(NULL, applespi->gpe,\n\t\t\t\t\t    ACPI_GPE_LEVEL_TRIGGERED,\n\t\t\t\t\t    applespi_notify, applespi);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to install GPE handler for GPE %d: %s\\n\",\n\t\t\tapplespi->gpe, acpi_format_exception(acpi_sts));\n\t\treturn -ENODEV;\n\t}\n\n\tapplespi->suspended = false;\n\n\tacpi_sts = acpi_enable_gpe(NULL, applespi->gpe);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to enable GPE handler for GPE %d: %s\\n\",\n\t\t\tapplespi->gpe, acpi_format_exception(acpi_sts));\n\t\tacpi_remove_gpe_handler(NULL, applespi->gpe, applespi_notify);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tapplespi_init(applespi, false);\n\n\t \n\tdevice_wakeup_enable(&spi->dev);\n\n\t \n\tsts = applespi_get_saved_bl_level(applespi);\n\tif (sts >= 0)\n\t\tapplespi_set_bl_level(&applespi->backlight_info, sts);\n\n\tapplespi->backlight_info.name            = \"spi::kbd_backlight\";\n\tapplespi->backlight_info.default_trigger = \"kbd-backlight\";\n\tapplespi->backlight_info.brightness_set  = applespi_set_bl_level;\n\n\tsts = devm_led_classdev_register(&spi->dev, &applespi->backlight_info);\n\tif (sts)\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Unable to register keyboard backlight class dev (%d)\\n\",\n\t\t\t sts);\n\n\t \n\tapplespi->debugfs_root = debugfs_create_dir(\"applespi\", NULL);\n\n\tdebugfs_create_bool(\"enable_tp_dim\", 0600, applespi->debugfs_root,\n\t\t\t    &applespi->debug_tp_dim);\n\n\tdebugfs_create_file(\"tp_dim\", 0400, applespi->debugfs_root, applespi,\n\t\t\t    &applespi_tp_dim_fops);\n\n\treturn 0;\n}\n\nstatic void applespi_drain_writes(struct applespi_data *applespi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tapplespi->drain = true;\n\twait_event_lock_irq(applespi->drain_complete, !applespi->write_active,\n\t\t\t    applespi->cmd_msg_lock);\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n}\n\nstatic void applespi_drain_reads(struct applespi_data *applespi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\twait_event_lock_irq(applespi->drain_complete, !applespi->read_active,\n\t\t\t    applespi->cmd_msg_lock);\n\n\tapplespi->suspended = true;\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n}\n\nstatic void applespi_remove(struct spi_device *spi)\n{\n\tstruct applespi_data *applespi = spi_get_drvdata(spi);\n\n\tapplespi_drain_writes(applespi);\n\n\tacpi_disable_gpe(NULL, applespi->gpe);\n\tacpi_remove_gpe_handler(NULL, applespi->gpe, applespi_notify);\n\tdevice_wakeup_disable(&spi->dev);\n\n\tapplespi_drain_reads(applespi);\n\n\tdebugfs_remove_recursive(applespi->debugfs_root);\n}\n\nstatic void applespi_shutdown(struct spi_device *spi)\n{\n\tstruct applespi_data *applespi = spi_get_drvdata(spi);\n\n\tapplespi_save_bl_level(applespi, applespi->have_bl_level);\n}\n\nstatic int applespi_poweroff_late(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct applespi_data *applespi = spi_get_drvdata(spi);\n\n\tapplespi_save_bl_level(applespi, applespi->have_bl_level);\n\n\treturn 0;\n}\n\nstatic int applespi_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct applespi_data *applespi = spi_get_drvdata(spi);\n\tacpi_status acpi_sts;\n\tint sts;\n\n\t \n\tsts = applespi_set_capsl_led(applespi, false);\n\tif (sts)\n\t\tdev_warn(&applespi->spi->dev,\n\t\t\t \"Failed to turn off caps-lock led (%d)\\n\", sts);\n\n\tapplespi_drain_writes(applespi);\n\n\t \n\tacpi_sts = acpi_disable_gpe(NULL, applespi->gpe);\n\tif (ACPI_FAILURE(acpi_sts))\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to disable GPE handler for GPE %d: %s\\n\",\n\t\t\tapplespi->gpe, acpi_format_exception(acpi_sts));\n\n\tapplespi_drain_reads(applespi);\n\n\treturn 0;\n}\n\nstatic int applespi_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct applespi_data *applespi = spi_get_drvdata(spi);\n\tacpi_status acpi_sts;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&applespi->cmd_msg_lock, flags);\n\n\tapplespi->drain = false;\n\tapplespi->have_cl_led_on = false;\n\tapplespi->have_bl_level = 0;\n\tapplespi->cmd_msg_queued = 0;\n\tapplespi->read_active = false;\n\tapplespi->write_active = false;\n\n\tapplespi->suspended = false;\n\n\tspin_unlock_irqrestore(&applespi->cmd_msg_lock, flags);\n\n\t \n\tapplespi_enable_spi(applespi);\n\n\t \n\tacpi_sts = acpi_enable_gpe(NULL, applespi->gpe);\n\tif (ACPI_FAILURE(acpi_sts))\n\t\tdev_err(&applespi->spi->dev,\n\t\t\t\"Failed to re-enable GPE handler for GPE %d: %s\\n\",\n\t\t\tapplespi->gpe, acpi_format_exception(acpi_sts));\n\n\t \n\tapplespi_init(applespi, true);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id applespi_acpi_match[] = {\n\t{ \"APP000D\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, applespi_acpi_match);\n\nstatic const struct dev_pm_ops applespi_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(applespi_suspend, applespi_resume)\n\t.poweroff_late\t= pm_sleep_ptr(applespi_poweroff_late),\n};\n\nstatic struct spi_driver applespi_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t\t= \"applespi\",\n\t\t.acpi_match_table\t= applespi_acpi_match,\n\t\t.pm\t\t\t= pm_sleep_ptr(&applespi_pm_ops),\n\t},\n\t.probe\t\t= applespi_probe,\n\t.remove\t\t= applespi_remove,\n\t.shutdown\t= applespi_shutdown,\n};\n\nmodule_spi_driver(applespi_driver)\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MacBook(Pro) SPI Keyboard/Touchpad driver\");\nMODULE_AUTHOR(\"Federico Lorenzi\");\nMODULE_AUTHOR(\"Ronald Tschal\u00e4r\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}