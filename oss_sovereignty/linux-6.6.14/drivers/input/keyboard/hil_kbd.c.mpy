{
  "module_name": "hil_kbd.c",
  "hash_id": "24c085beaf365cdeb8cfa940095f6e48f4ddfaf34f9e49971f629831317f27b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/hil_kbd.c",
  "human_readable_source": " \n\n#include <linux/hil.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/pci_ids.h>\n\n#define PREFIX \"HIL: \"\n\nMODULE_AUTHOR(\"Brian S. Julin <bri@calyx.com>\");\nMODULE_DESCRIPTION(\"HIL keyboard/mouse driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"serio:ty03pr25id00ex*\");  \nMODULE_ALIAS(\"serio:ty03pr25id0Fex*\");  \n\n#define HIL_PACKET_MAX_LENGTH 16\n\n#define HIL_KBD_SET1_UPBIT 0x01\n#define HIL_KBD_SET1_SHIFT 1\nstatic unsigned int hil_kbd_set1[HIL_KEYCODES_SET1_TBLSIZE] __read_mostly =\n\t{ HIL_KEYCODES_SET1 };\n\n#define HIL_KBD_SET2_UPBIT 0x01\n#define HIL_KBD_SET2_SHIFT 1\n \n\n#define HIL_KBD_SET3_UPBIT 0x80\n#define HIL_KBD_SET3_SHIFT 0\nstatic unsigned int hil_kbd_set3[HIL_KEYCODES_SET3_TBLSIZE] __read_mostly =\n\t{ HIL_KEYCODES_SET3 };\n\nstatic const char hil_language[][16] = { HIL_LOCALE_MAP };\n\nstruct hil_dev {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\n\t \n\thil_packet data[HIL_PACKET_MAX_LENGTH];\n\tint idx4;  \n\n\t \n\tchar\tidd[HIL_PACKET_MAX_LENGTH];\t \n\tchar\trsc[HIL_PACKET_MAX_LENGTH];\t \n\tchar\texd[HIL_PACKET_MAX_LENGTH];\t \n\tchar\trnm[HIL_PACKET_MAX_LENGTH + 1];\t \n\n\tstruct completion cmd_done;\n\n\tbool is_pointer;\n\t \n\tunsigned int nbtn, naxes;\n\tunsigned int btnmap[7];\n};\n\nstatic bool hil_dev_is_command_response(hil_packet p)\n{\n\tif ((p & ~HIL_CMDCT_POL) == (HIL_ERR_INT | HIL_PKT_CMD | HIL_CMD_POL))\n\t\treturn false;\n\n\tif ((p & ~HIL_CMDCT_RPL) == (HIL_ERR_INT | HIL_PKT_CMD | HIL_CMD_RPL))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void hil_dev_handle_command_response(struct hil_dev *dev)\n{\n\thil_packet p;\n\tchar *buf;\n\tint i, idx;\n\n\tidx = dev->idx4 / 4;\n\tp = dev->data[idx - 1];\n\n\tswitch (p & HIL_PKT_DATA_MASK) {\n\tcase HIL_CMD_IDD:\n\t\tbuf = dev->idd;\n\t\tbreak;\n\n\tcase HIL_CMD_RSC:\n\t\tbuf = dev->rsc;\n\t\tbreak;\n\n\tcase HIL_CMD_EXD:\n\t\tbuf = dev->exd;\n\t\tbreak;\n\n\tcase HIL_CMD_RNM:\n\t\tdev->rnm[HIL_PACKET_MAX_LENGTH] = 0;\n\t\tbuf = dev->rnm;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (p != (HIL_ERR_INT | HIL_PKT_CMD)) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING PREFIX \"Device sent unknown record %x\\n\", p);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < idx; i++)\n\t\tbuf[i] = dev->data[i] & HIL_PKT_DATA_MASK;\n\tfor (; i < HIL_PACKET_MAX_LENGTH; i++)\n\t\tbuf[i] = 0;\n out:\n\tcomplete(&dev->cmd_done);\n}\n\nstatic void hil_dev_handle_kbd_events(struct hil_dev *kbd)\n{\n\tstruct input_dev *dev = kbd->dev;\n\tint idx = kbd->idx4 / 4;\n\tint i;\n\n\tswitch (kbd->data[0] & HIL_POL_CHARTYPE_MASK) {\n\tcase HIL_POL_CHARTYPE_NONE:\n\t\treturn;\n\n\tcase HIL_POL_CHARTYPE_ASCII:\n\t\tfor (i = 1; i < idx - 1; i++)\n\t\t\tinput_report_key(dev, kbd->data[i] & 0x7f, 1);\n\t\tbreak;\n\n\tcase HIL_POL_CHARTYPE_RSVD1:\n\tcase HIL_POL_CHARTYPE_RSVD2:\n\tcase HIL_POL_CHARTYPE_BINARY:\n\t\tfor (i = 1; i < idx - 1; i++)\n\t\t\tinput_report_key(dev, kbd->data[i], 1);\n\t\tbreak;\n\n\tcase HIL_POL_CHARTYPE_SET1:\n\t\tfor (i = 1; i < idx - 1; i++) {\n\t\t\tunsigned int key = kbd->data[i];\n\t\t\tint up = key & HIL_KBD_SET1_UPBIT;\n\n\t\t\tkey &= (~HIL_KBD_SET1_UPBIT & 0xff);\n\t\t\tkey = hil_kbd_set1[key >> HIL_KBD_SET1_SHIFT];\n\t\t\tinput_report_key(dev, key, !up);\n\t\t}\n\t\tbreak;\n\n\tcase HIL_POL_CHARTYPE_SET2:\n\t\tfor (i = 1; i < idx - 1; i++) {\n\t\t\tunsigned int key = kbd->data[i];\n\t\t\tint up = key & HIL_KBD_SET2_UPBIT;\n\n\t\t\tkey &= (~HIL_KBD_SET1_UPBIT & 0xff);\n\t\t\tkey = key >> HIL_KBD_SET2_SHIFT;\n\t\t\tinput_report_key(dev, key, !up);\n\t\t}\n\t\tbreak;\n\n\tcase HIL_POL_CHARTYPE_SET3:\n\t\tfor (i = 1; i < idx - 1; i++) {\n\t\t\tunsigned int key = kbd->data[i];\n\t\t\tint up = key & HIL_KBD_SET3_UPBIT;\n\n\t\t\tkey &= (~HIL_KBD_SET1_UPBIT & 0xff);\n\t\t\tkey = hil_kbd_set3[key >> HIL_KBD_SET3_SHIFT];\n\t\t\tinput_report_key(dev, key, !up);\n\t\t}\n\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic void hil_dev_handle_ptr_events(struct hil_dev *ptr)\n{\n\tstruct input_dev *dev = ptr->dev;\n\tint idx = ptr->idx4 / 4;\n\thil_packet p = ptr->data[idx - 1];\n\tint i, cnt, laxis;\n\tbool absdev, ax16;\n\n\tif ((p & HIL_CMDCT_POL) != idx - 1) {\n\t\tprintk(KERN_WARNING PREFIX\n\t\t\t\"Malformed poll packet %x (idx = %i)\\n\", p, idx);\n\t\treturn;\n\t}\n\n\ti = (p & HIL_POL_AXIS_ALT) ? 3 : 0;\n\tlaxis = (p & HIL_POL_NUM_AXES_MASK) + i;\n\n\tax16 = ptr->idd[1] & HIL_IDD_HEADER_16BIT;  \n\tabsdev = ptr->idd[1] & HIL_IDD_HEADER_ABS;\n\n\tfor (cnt = 1; i < laxis; i++) {\n\t\tunsigned int lo, hi, val;\n\n\t\tlo = ptr->data[cnt++] & HIL_PKT_DATA_MASK;\n\t\thi = ax16 ? (ptr->data[cnt++] & HIL_PKT_DATA_MASK) : 0;\n\n\t\tif (absdev) {\n\t\t\tval = lo + (hi << 8);\n#ifdef TABLET_AUTOADJUST\n\t\t\tif (val < input_abs_get_min(dev, ABS_X + i))\n\t\t\t\tinput_abs_set_min(dev, ABS_X + i, val);\n\t\t\tif (val > input_abs_get_max(dev, ABS_X + i))\n\t\t\t\tinput_abs_set_max(dev, ABS_X + i, val);\n#endif\n\t\t\tif (i % 3)\n\t\t\t\tval = input_abs_get_max(dev, ABS_X + i) - val;\n\t\t\tinput_report_abs(dev, ABS_X + i, val);\n\t\t} else {\n\t\t\tval = (int) (((int8_t) lo) | ((int8_t) hi << 8));\n\t\t\tif (i % 3)\n\t\t\t\tval *= -1;\n\t\t\tinput_report_rel(dev, REL_X + i, val);\n\t\t}\n\t}\n\n\twhile (cnt < idx - 1) {\n\t\tunsigned int btn = ptr->data[cnt++];\n\t\tint up = btn & 1;\n\n\t\tbtn &= 0xfe;\n\t\tif (btn == 0x8e)\n\t\t\tcontinue;  \n\t\tif (btn > 0x8c || btn < 0x80)\n\t\t\tcontinue;\n\t\tbtn = (btn - 0x80) >> 1;\n\t\tbtn = ptr->btnmap[btn];\n\t\tinput_report_key(dev, btn, !up);\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic void hil_dev_process_err(struct hil_dev *dev)\n{\n\tprintk(KERN_WARNING PREFIX \"errored HIL packet\\n\");\n\tdev->idx4 = 0;\n\tcomplete(&dev->cmd_done);  \n}\n\nstatic irqreturn_t hil_dev_interrupt(struct serio *serio,\n\t\t\t\tunsigned char data, unsigned int flags)\n{\n\tstruct hil_dev *dev;\n\thil_packet packet;\n\tint idx;\n\n\tdev = serio_get_drvdata(serio);\n\tBUG_ON(dev == NULL);\n\n\tif (dev->idx4 >= HIL_PACKET_MAX_LENGTH * sizeof(hil_packet)) {\n\t\thil_dev_process_err(dev);\n\t\tgoto out;\n\t}\n\n\tidx = dev->idx4 / 4;\n\tif (!(dev->idx4 % 4))\n\t\tdev->data[idx] = 0;\n\tpacket = dev->data[idx];\n\tpacket |= ((hil_packet)data) << ((3 - (dev->idx4 % 4)) * 8);\n\tdev->data[idx] = packet;\n\n\t \n\tif ((++dev->idx4 % 4) == 0) {\n\t\tif ((packet & 0xffff0000) != HIL_ERR_INT) {\n\t\t\thil_dev_process_err(dev);\n\t\t} else if (packet & HIL_PKT_CMD) {\n\t\t\tif (hil_dev_is_command_response(packet))\n\t\t\t\thil_dev_handle_command_response(dev);\n\t\t\telse if (dev->is_pointer)\n\t\t\t\thil_dev_handle_ptr_events(dev);\n\t\t\telse\n\t\t\t\thil_dev_handle_kbd_events(dev);\n\t\t\tdev->idx4 = 0;\n\t\t}\n\t}\n out:\n\treturn IRQ_HANDLED;\n}\n\nstatic void hil_dev_disconnect(struct serio *serio)\n{\n\tstruct hil_dev *dev = serio_get_drvdata(serio);\n\n\tBUG_ON(dev == NULL);\n\n\tserio_close(serio);\n\tinput_unregister_device(dev->dev);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(dev);\n}\n\nstatic void hil_dev_keyboard_setup(struct hil_dev *kbd)\n{\n\tstruct input_dev *input_dev = kbd->dev;\n\tuint8_t did = kbd->idd[0];\n\tint i;\n\n\tinput_dev->evbit[0]\t= BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\tinput_dev->ledbit[0]\t= BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |\n\t\t\t\t  BIT_MASK(LED_SCROLLL);\n\n\tfor (i = 0; i < 128; i++) {\n\t\t__set_bit(hil_kbd_set1[i], input_dev->keybit);\n\t\t__set_bit(hil_kbd_set3[i], input_dev->keybit);\n\t}\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\tinput_dev->keycodemax\t= HIL_KEYCODES_SET1_TBLSIZE;\n\tinput_dev->keycodesize\t= sizeof(hil_kbd_set1[0]);\n\tinput_dev->keycode\t= hil_kbd_set1;\n\n\tinput_dev->name\t= strlen(kbd->rnm) ? kbd->rnm : \"HIL keyboard\";\n\tinput_dev->phys\t= \"hpkbd/input0\";\n\n\tprintk(KERN_INFO PREFIX \"HIL keyboard found (did = 0x%02x, lang = %s)\\n\",\n\t\tdid, hil_language[did & HIL_IDD_DID_TYPE_KB_LANG_MASK]);\n}\n\nstatic void hil_dev_pointer_setup(struct hil_dev *ptr)\n{\n\tstruct input_dev *input_dev = ptr->dev;\n\tuint8_t did = ptr->idd[0];\n\tuint8_t *idd = ptr->idd + 1;\n\tunsigned int naxsets = HIL_IDD_NUM_AXSETS(*idd);\n\tunsigned int i, btntype;\n\tconst char *txt;\n\n\tptr->naxes = HIL_IDD_NUM_AXES_PER_SET(*idd);\n\n\tswitch (did & HIL_IDD_DID_TYPE_MASK) {\n\tcase HIL_IDD_DID_TYPE_REL:\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_REL);\n\n\t\tfor (i = 0; i < ptr->naxes; i++)\n\t\t\t__set_bit(REL_X + i, input_dev->relbit);\n\n\t\tfor (i = 3; naxsets > 1 && i < ptr->naxes + 3; i++)\n\t\t\t__set_bit(REL_X + i, input_dev->relbit);\n\n\t\ttxt = \"relative\";\n\t\tbreak;\n\n\tcase HIL_IDD_DID_TYPE_ABS:\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_ABS);\n\n\t\tfor (i = 0; i < ptr->naxes; i++)\n\t\t\tinput_set_abs_params(input_dev, ABS_X + i,\n\t\t\t\t\t0, HIL_IDD_AXIS_MAX(idd, i), 0, 0);\n\n\t\tfor (i = 3; naxsets > 1 && i < ptr->naxes + 3; i++)\n\t\t\tinput_set_abs_params(input_dev, ABS_X + i,\n\t\t\t\t\t0, HIL_IDD_AXIS_MAX(idd, i - 3), 0, 0);\n\n#ifdef TABLET_AUTOADJUST\n\t\tfor (i = 0; i < ABS_MAX; i++) {\n\t\t\tint diff = input_abs_get_max(input_dev, ABS_X + i) / 10;\n\t\t\tinput_abs_set_min(input_dev, ABS_X + i,\n\t\t\t\tinput_abs_get_min(input_dev, ABS_X + i) + diff);\n\t\t\tinput_abs_set_max(input_dev, ABS_X + i,\n\t\t\t\tinput_abs_get_max(input_dev, ABS_X + i) - diff);\n\t\t}\n#endif\n\n\t\ttxt = \"absolute\";\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tptr->nbtn = HIL_IDD_NUM_BUTTONS(idd);\n\tif (ptr->nbtn)\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_KEY);\n\n\tbtntype = BTN_MISC;\n\tif ((did & HIL_IDD_DID_ABS_TABLET_MASK) == HIL_IDD_DID_ABS_TABLET)\n#ifdef TABLET_SIMULATES_MOUSE\n\t\tbtntype = BTN_TOUCH;\n#else\n\t\tbtntype = BTN_DIGI;\n#endif\n\tif ((did & HIL_IDD_DID_ABS_TSCREEN_MASK) == HIL_IDD_DID_ABS_TSCREEN)\n\t\tbtntype = BTN_TOUCH;\n\n\tif ((did & HIL_IDD_DID_REL_MOUSE_MASK) == HIL_IDD_DID_REL_MOUSE)\n\t\tbtntype = BTN_MOUSE;\n\n\tfor (i = 0; i < ptr->nbtn; i++) {\n\t\t__set_bit(btntype | i, input_dev->keybit);\n\t\tptr->btnmap[i] = btntype | i;\n\t}\n\n\tif (btntype == BTN_MOUSE) {\n\t\t \n\t\tptr->btnmap[1] = BTN_MIDDLE;\n\t\tptr->btnmap[2] = BTN_RIGHT;\n\t}\n\n\tinput_dev->name = strlen(ptr->rnm) ? ptr->rnm : \"HIL pointer device\";\n\n\tprintk(KERN_INFO PREFIX\n\t\t\"HIL pointer device found (did: 0x%02x, axis: %s)\\n\",\n\t\tdid, txt);\n\tprintk(KERN_INFO PREFIX\n\t\t\"HIL pointer has %i buttons and %i sets of %i axes\\n\",\n\t\tptr->nbtn, naxsets, ptr->naxes);\n}\n\nstatic int hil_dev_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct hil_dev *dev;\n\tstruct input_dev *input_dev;\n\tuint8_t did, *idd;\n\tint error;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!dev || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto bail0;\n\t}\n\n\tdev->serio = serio;\n\tdev->dev = input_dev;\n\n\terror = serio_open(serio, drv);\n\tif (error)\n\t\tgoto bail0;\n\n\tserio_set_drvdata(serio, dev);\n\n\t \n\tinit_completion(&dev->cmd_done);\n\tserio_write(serio, 0);\n\tserio_write(serio, 0);\n\tserio_write(serio, HIL_PKT_CMD >> 8);\n\tserio_write(serio, HIL_CMD_IDD);\n\terror = wait_for_completion_killable(&dev->cmd_done);\n\tif (error)\n\t\tgoto bail1;\n\n\treinit_completion(&dev->cmd_done);\n\tserio_write(serio, 0);\n\tserio_write(serio, 0);\n\tserio_write(serio, HIL_PKT_CMD >> 8);\n\tserio_write(serio, HIL_CMD_RSC);\n\terror = wait_for_completion_killable(&dev->cmd_done);\n\tif (error)\n\t\tgoto bail1;\n\n\treinit_completion(&dev->cmd_done);\n\tserio_write(serio, 0);\n\tserio_write(serio, 0);\n\tserio_write(serio, HIL_PKT_CMD >> 8);\n\tserio_write(serio, HIL_CMD_RNM);\n\terror = wait_for_completion_killable(&dev->cmd_done);\n\tif (error)\n\t\tgoto bail1;\n\n\treinit_completion(&dev->cmd_done);\n\tserio_write(serio, 0);\n\tserio_write(serio, 0);\n\tserio_write(serio, HIL_PKT_CMD >> 8);\n\tserio_write(serio, HIL_CMD_EXD);\n\terror = wait_for_completion_killable(&dev->cmd_done);\n\tif (error)\n\t\tgoto bail1;\n\n\tdid = dev->idd[0];\n\tidd = dev->idd + 1;\n\n\tswitch (did & HIL_IDD_DID_TYPE_MASK) {\n\tcase HIL_IDD_DID_TYPE_KB_INTEGRAL:\n\tcase HIL_IDD_DID_TYPE_KB_ITF:\n\tcase HIL_IDD_DID_TYPE_KB_RSVD:\n\tcase HIL_IDD_DID_TYPE_CHAR:\n\t\tif (HIL_IDD_NUM_BUTTONS(idd) ||\n\t\t    HIL_IDD_NUM_AXES_PER_SET(*idd)) {\n\t\t\tprintk(KERN_INFO PREFIX\n\t\t\t\t\"combo devices are not supported.\\n\");\n\t\t\terror = -EINVAL;\n\t\t\tgoto bail1;\n\t\t}\n\n\t\tdev->is_pointer = false;\n\t\thil_dev_keyboard_setup(dev);\n\t\tbreak;\n\n\tcase HIL_IDD_DID_TYPE_REL:\n\tcase HIL_IDD_DID_TYPE_ABS:\n\t\tdev->is_pointer = true;\n\t\thil_dev_pointer_setup(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto bail1;\n\t}\n\n\tinput_dev->id.bustype\t= BUS_HIL;\n\tinput_dev->id.vendor\t= PCI_VENDOR_ID_HP;\n\tinput_dev->id.product\t= 0x0001;  \n\tinput_dev->id.version\t= 0x0100;  \n\tinput_dev->dev.parent\t= &serio->dev;\n\n\tif (!dev->is_pointer) {\n\t\tserio_write(serio, 0);\n\t\tserio_write(serio, 0);\n\t\tserio_write(serio, HIL_PKT_CMD >> 8);\n\t\t \n\t\tserio_write(serio, HIL_CMD_EK1);\n\t\t \n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\tgoto bail1;\n\n\treturn 0;\n\n bail1:\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n bail0:\n\tinput_free_device(input_dev);\n\tkfree(dev);\n\treturn error;\n}\n\nstatic const struct serio_device_id hil_dev_ids[] = {\n\t{\n\t\t.type = SERIO_HIL_MLC,\n\t\t.proto = SERIO_HIL,\n\t\t.id = SERIO_ANY,\n\t\t.extra = SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, hil_dev_ids);\n\nstatic struct serio_driver hil_serio_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"hil_dev\",\n\t},\n\t.description\t= \"HP HIL keyboard/mouse/tablet driver\",\n\t.id_table\t= hil_dev_ids,\n\t.connect\t= hil_dev_connect,\n\t.disconnect\t= hil_dev_disconnect,\n\t.interrupt\t= hil_dev_interrupt\n};\n\nmodule_serio_driver(hil_serio_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}