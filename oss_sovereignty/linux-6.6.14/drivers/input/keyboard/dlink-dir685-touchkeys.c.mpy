{
  "module_name": "dlink-dir685-touchkeys.c",
  "hash_id": "c5145adb9d4e21dde3ec23ce6c21cffa848bcb1d6049e307da512a413276a045",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/dlink-dir685-touchkeys.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct dir685_touchkeys {\n\tstruct device\t\t*dev;\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input;\n\tunsigned long\t\tcur_key;\n\tu16\t\t\tcodes[7];\n};\n\nstatic irqreturn_t dir685_tk_irq_thread(int irq, void *data)\n{\n\tstruct dir685_touchkeys *tk = data;\n\tconst int num_bits = min_t(int, ARRAY_SIZE(tk->codes), 16);\n\tunsigned long changed;\n\tu8 buf[6];\n\tunsigned long key;\n\tint i;\n\tint err;\n\n\tmemset(buf, 0, sizeof(buf));\n\terr = i2c_master_recv(tk->client, buf, sizeof(buf));\n\tif (err != sizeof(buf)) {\n\t\tdev_err(tk->dev, \"short read %d\\n\", err);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdev_dbg(tk->dev, \"IN: %*ph\\n\", (int)sizeof(buf), buf);\n\tkey = be16_to_cpup((__be16 *) &buf[4]);\n\n\t \n\tchanged = tk->cur_key ^ key;\n\tfor_each_set_bit(i, &changed, num_bits) {\n\t\tdev_dbg(tk->dev, \"key %d is %s\\n\", i,\n\t\t\ttest_bit(i, &key) ? \"down\" : \"up\");\n\t\tinput_report_key(tk->input, tk->codes[i], test_bit(i, &key));\n\t}\n\n\t \n\ttk->cur_key = key;\n\tinput_sync(tk->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dir685_tk_probe(struct i2c_client *client)\n{\n\tstatic const u8 bl_data[] = { 0xa7, 0x40 };\n\tstruct device *dev = &client->dev;\n\tstruct dir685_touchkeys *tk;\n\tint err;\n\tint i;\n\n\ttk = devm_kzalloc(&client->dev, sizeof(*tk), GFP_KERNEL);\n\tif (!tk)\n\t\treturn -ENOMEM;\n\n\ttk->input = devm_input_allocate_device(dev);\n\tif (!tk->input)\n\t\treturn -ENOMEM;\n\n\ttk->client = client;\n\ttk->dev = dev;\n\n\ttk->input->keycodesize = sizeof(u16);\n\ttk->input->keycodemax = ARRAY_SIZE(tk->codes);\n\ttk->input->keycode = tk->codes;\n\ttk->codes[0] = KEY_UP;\n\ttk->codes[1] = KEY_DOWN;\n\ttk->codes[2] = KEY_LEFT;\n\ttk->codes[3] = KEY_RIGHT;\n\ttk->codes[4] = KEY_ENTER;\n\ttk->codes[5] = KEY_WPS_BUTTON;\n\t \n\ttk->codes[6] = KEY_RESERVED;\n\n\t__set_bit(EV_KEY, tk->input->evbit);\n\tfor (i = 0; i < ARRAY_SIZE(tk->codes); i++)\n\t\t__set_bit(tk->codes[i], tk->input->keybit);\n\t__clear_bit(KEY_RESERVED, tk->input->keybit);\n\n\ttk->input->name = \"D-Link DIR-685 touchkeys\";\n\ttk->input->id.bustype = BUS_I2C;\n\n\terr = input_register_device(tk->input);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = i2c_master_send(client, bl_data, sizeof(bl_data));\n\tif (err != sizeof(bl_data))\n\t\tdev_warn(tk->dev, \"error setting brightness level\\n\");\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"no IRQ on the I2C device\\n\");\n\t\treturn -ENODEV;\n\t}\n\terr = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\tNULL, dir685_tk_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"dir685-tk\", tk);\n\tif (err) {\n\t\tdev_err(dev, \"can't request IRQ\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id dir685_tk_id[] = {\n\t{ \"dir685tk\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, dir685_tk_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dir685_tk_of_match[] = {\n\t{ .compatible = \"dlink,dir685-touchkeys\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dir685_tk_of_match);\n#endif\n\nstatic struct i2c_driver dir685_tk_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"dlink-dir685-touchkeys\",\n\t\t.of_match_table = of_match_ptr(dir685_tk_of_match),\n\t},\n\t.probe\t\t= dir685_tk_probe,\n\t.id_table\t= dir685_tk_id,\n};\nmodule_i2c_driver(dir685_tk_i2c_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"D-Link DIR-685 touchkeys driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}