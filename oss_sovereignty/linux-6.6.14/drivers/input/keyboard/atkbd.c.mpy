{
  "module_name": "atkbd.c",
  "hash_id": "4a3a20564fd4ba7ff42a0c5fd188e906826b573d4815b00f2f0b4a76d84ba4bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/atkbd.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/input/vivaldi-fmap.h>\n#include <linux/serio.h>\n#include <linux/workqueue.h>\n#include <linux/libps2.h>\n#include <linux/mutex.h>\n#include <linux/dmi.h>\n#include <linux/property.h>\n\n#define DRIVER_DESC\t\"AT and PS/2 keyboard driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic int atkbd_set = 2;\nmodule_param_named(set, atkbd_set, int, 0);\nMODULE_PARM_DESC(set, \"Select keyboard code set (2 = default, 3 = PS/2 native)\");\n\n#if defined(__i386__) || defined(__x86_64__) || defined(__hppa__)\nstatic bool atkbd_reset;\n#else\nstatic bool atkbd_reset = true;\n#endif\nmodule_param_named(reset, atkbd_reset, bool, 0);\nMODULE_PARM_DESC(reset, \"Reset keyboard during initialization\");\n\nstatic bool atkbd_softrepeat;\nmodule_param_named(softrepeat, atkbd_softrepeat, bool, 0);\nMODULE_PARM_DESC(softrepeat, \"Use software keyboard repeat\");\n\nstatic bool atkbd_softraw = true;\nmodule_param_named(softraw, atkbd_softraw, bool, 0);\nMODULE_PARM_DESC(softraw, \"Use software generated rawmode\");\n\nstatic bool atkbd_scroll;\nmodule_param_named(scroll, atkbd_scroll, bool, 0);\nMODULE_PARM_DESC(scroll, \"Enable scroll-wheel on MS Office and similar keyboards\");\n\nstatic bool atkbd_extra;\nmodule_param_named(extra, atkbd_extra, bool, 0);\nMODULE_PARM_DESC(extra, \"Enable extra LEDs and keys on IBM RapidAcces, EzKey and similar keyboards\");\n\nstatic bool atkbd_terminal;\nmodule_param_named(terminal, atkbd_terminal, bool, 0);\nMODULE_PARM_DESC(terminal, \"Enable break codes on an IBM Terminal keyboard connected via AT/PS2\");\n\n#define SCANCODE(keymap)\t((keymap >> 16) & 0xFFFF)\n#define KEYCODE(keymap)\t\t(keymap & 0xFFFF)\n\n \n\n#define ATKBD_KEYMAP_SIZE\t512\n\nstatic const unsigned short atkbd_set2_keycode[ATKBD_KEYMAP_SIZE] = {\n\n#ifdef CONFIG_KEYBOARD_ATKBD_HP_KEYCODES\n\n \n\n#include \"hpps2atkbd.h\"\t \n\n#else\n\t  0, 67, 65, 63, 61, 59, 60, 88,  0, 68, 66, 64, 62, 15, 41,117,\n\t  0, 56, 42, 93, 29, 16,  2,  0,  0,  0, 44, 31, 30, 17,  3,  0,\n\t  0, 46, 45, 32, 18,  5,  4, 95,  0, 57, 47, 33, 20, 19,  6,183,\n\t  0, 49, 48, 35, 34, 21,  7,184,  0,  0, 50, 36, 22,  8,  9,185,\n\t  0, 51, 37, 23, 24, 11, 10,  0,  0, 52, 53, 38, 39, 25, 12,  0,\n\t  0, 89, 40,  0, 26, 13,  0,  0, 58, 54, 28, 27,  0, 43,  0, 85,\n\t  0, 86, 91, 90, 92,  0, 14, 94,  0, 79,124, 75, 71,121,  0,  0,\n\t 82, 83, 80, 76, 77, 72,  1, 69, 87, 78, 81, 74, 55, 73, 70, 99,\n\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t217,100,255,  0, 97,165,  0,  0,156,  0,  0,  0,  0,  0,  0,125,\n\t173,114,  0,113,  0,  0,  0,126,128,  0,  0,140,  0,  0,  0,127,\n\t159,  0,115,  0,164,  0,  0,116,158,  0,172,166,  0,  0,  0,142,\n\t157,  0,  0,  0,  0,  0,  0,  0,155,  0, 98,  0,  0,163,  0,  0,\n\t226,  0,  0,  0,  0,  0,  0,  0,  0,255, 96,  0,  0,  0,143,  0,\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,107,  0,105,102,  0,  0,112,\n\t110,111,108,112,106,103,  0,119,  0,118,109,  0, 99,104,119,  0,\n\n\t  0,  0,  0, 65, 99,\n#endif\n};\n\nstatic const unsigned short atkbd_set3_keycode[ATKBD_KEYMAP_SIZE] = {\n\n\t  0,  0,  0,  0,  0,  0,  0, 59,  1,138,128,129,130, 15, 41, 60,\n\t131, 29, 42, 86, 58, 16,  2, 61,133, 56, 44, 31, 30, 17,  3, 62,\n\t134, 46, 45, 32, 18,  5,  4, 63,135, 57, 47, 33, 20, 19,  6, 64,\n\t136, 49, 48, 35, 34, 21,  7, 65,137,100, 50, 36, 22,  8,  9, 66,\n\t125, 51, 37, 23, 24, 11, 10, 67,126, 52, 53, 38, 39, 25, 12, 68,\n\t113,114, 40, 43, 26, 13, 87, 99, 97, 54, 28, 27, 43, 43, 88, 70,\n\t108,105,119,103,111,107, 14,110,  0, 79,106, 75, 71,109,102,104,\n\t 82, 83, 80, 76, 77, 72, 69, 98,  0, 96, 81,  0, 78, 73, 55,183,\n\n\t184,185,186,187, 74, 94, 92, 93,  0,  0,  0,125,126,127,112,  0,\n\t  0,139,172,163,165,115,152,172,166,140,160,154,113,114,167,168,\n\t148,149,147,140\n};\n\nstatic const unsigned short atkbd_unxlate_table[128] = {\n          0,118, 22, 30, 38, 37, 46, 54, 61, 62, 70, 69, 78, 85,102, 13,\n         21, 29, 36, 45, 44, 53, 60, 67, 68, 77, 84, 91, 90, 20, 28, 27,\n         35, 43, 52, 51, 59, 66, 75, 76, 82, 14, 18, 93, 26, 34, 33, 42,\n         50, 49, 58, 65, 73, 74, 89,124, 17, 41, 88,  5,  6,  4, 12,  3,\n         11,  2, 10,  1,  9,119,126,108,117,125,123,107,115,116,121,105,\n        114,122,112,113,127, 96, 97,120,  7, 15, 23, 31, 39, 47, 55, 63,\n         71, 79, 86, 94,  8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 87,111,\n         19, 25, 57, 81, 83, 92, 95, 98, 99,100,101,103,104,106,109,110\n};\n\n#define ATKBD_CMD_SETLEDS\t0x10ed\n#define ATKBD_CMD_GSCANSET\t0x11f0\n#define ATKBD_CMD_SSCANSET\t0x10f0\n#define ATKBD_CMD_GETID\t\t0x02f2\n#define ATKBD_CMD_SETREP\t0x10f3\n#define ATKBD_CMD_ENABLE\t0x00f4\n#define ATKBD_CMD_RESET_DIS\t0x00f5\t \n#define ATKBD_CMD_RESET_DEF\t0x00f6\t \n#define ATKBD_CMD_SETALL_MB\t0x00f8\t \n#define ATKBD_CMD_SETALL_MBR\t0x00fa   \n#define ATKBD_CMD_RESET_BAT\t0x02ff\n#define ATKBD_CMD_RESEND\t0x00fe\n#define ATKBD_CMD_EX_ENABLE\t0x10ea\n#define ATKBD_CMD_EX_SETLEDS\t0x20eb\n#define ATKBD_CMD_OK_GETID\t0x02e8\n\n#define ATKBD_RET_ACK\t\t0xfa\n#define ATKBD_RET_NAK\t\t0xfe\n#define ATKBD_RET_BAT\t\t0xaa\n#define ATKBD_RET_EMUL0\t\t0xe0\n#define ATKBD_RET_EMUL1\t\t0xe1\n#define ATKBD_RET_RELEASE\t0xf0\n#define ATKBD_RET_HANJA\t\t0xf1\n#define ATKBD_RET_HANGEUL\t0xf2\n#define ATKBD_RET_ERR\t\t0xff\n\n#define ATKBD_KEY_UNKNOWN\t0\n#define ATKBD_KEY_NULL\t\t255\n\n#define ATKBD_SCR_1\t\t0xfffe\n#define ATKBD_SCR_2\t\t0xfffd\n#define ATKBD_SCR_4\t\t0xfffc\n#define ATKBD_SCR_8\t\t0xfffb\n#define ATKBD_SCR_CLICK\t\t0xfffa\n#define ATKBD_SCR_LEFT\t\t0xfff9\n#define ATKBD_SCR_RIGHT\t\t0xfff8\n\n#define ATKBD_SPECIAL\t\tATKBD_SCR_RIGHT\n\n#define ATKBD_LED_EVENT_BIT\t0\n#define ATKBD_REP_EVENT_BIT\t1\n\n#define ATKBD_XL_ERR\t\t0x01\n#define ATKBD_XL_BAT\t\t0x02\n#define ATKBD_XL_ACK\t\t0x04\n#define ATKBD_XL_NAK\t\t0x08\n#define ATKBD_XL_HANGEUL\t0x10\n#define ATKBD_XL_HANJA\t\t0x20\n\nstatic const struct {\n\tunsigned short keycode;\n\tunsigned char set2;\n} atkbd_scroll_keys[] = {\n\t{ ATKBD_SCR_1,     0xc5 },\n\t{ ATKBD_SCR_2,     0x9d },\n\t{ ATKBD_SCR_4,     0xa4 },\n\t{ ATKBD_SCR_8,     0x9b },\n\t{ ATKBD_SCR_CLICK, 0xe0 },\n\t{ ATKBD_SCR_LEFT,  0xcb },\n\t{ ATKBD_SCR_RIGHT, 0xd2 },\n};\n\n \n\nstruct atkbd {\n\n\tstruct ps2dev ps2dev;\n\tstruct input_dev *dev;\n\n\t \n\tchar name[64];\n\tchar phys[32];\n\n\tunsigned short id;\n\tunsigned short keycode[ATKBD_KEYMAP_SIZE];\n\tDECLARE_BITMAP(force_release_mask, ATKBD_KEYMAP_SIZE);\n\tunsigned char set;\n\tbool translated;\n\tbool extra;\n\tbool write;\n\tbool softrepeat;\n\tbool softraw;\n\tbool scroll;\n\tbool enabled;\n\n\t \n\tunsigned char emul;\n\tbool resend;\n\tbool release;\n\tunsigned long xl_bit;\n\tunsigned int last;\n\tunsigned long time;\n\tunsigned long err_count;\n\n\tstruct delayed_work event_work;\n\tunsigned long event_jiffies;\n\tunsigned long event_mask;\n\n\t \n\tstruct mutex mutex;\n\n\tstruct vivaldi_data vdata;\n};\n\n \nstatic void (*atkbd_platform_fixup)(struct atkbd *, const void *data);\nstatic void *atkbd_platform_fixup_data;\nstatic unsigned int (*atkbd_platform_scancode_fixup)(struct atkbd *, unsigned int);\n\n \nstatic bool atkbd_skip_deactivate;\n\nstatic ssize_t atkbd_attr_show_helper(struct device *dev, char *buf,\n\t\t\t\tssize_t (*handler)(struct atkbd *, char *));\nstatic ssize_t atkbd_attr_set_helper(struct device *dev, const char *buf, size_t count,\n\t\t\t\tssize_t (*handler)(struct atkbd *, const char *, size_t));\n#define ATKBD_DEFINE_ATTR(_name)\t\t\t\t\t\t\\\nstatic ssize_t atkbd_show_##_name(struct atkbd *, char *);\t\t\t\\\nstatic ssize_t atkbd_set_##_name(struct atkbd *, const char *, size_t);\t\t\\\nstatic ssize_t atkbd_do_show_##_name(struct device *d,\t\t\t\t\\\n\t\t\t\tstruct device_attribute *attr, char *b)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn atkbd_attr_show_helper(d, b, atkbd_show_##_name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t atkbd_do_set_##_name(struct device *d,\t\t\t\t\\\n\t\t\tstruct device_attribute *attr, const char *b, size_t s)\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn atkbd_attr_set_helper(d, b, s, atkbd_set_##_name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic struct device_attribute atkbd_attr_##_name =\t\t\t\t\\\n\t__ATTR(_name, S_IWUSR | S_IRUGO, atkbd_do_show_##_name, atkbd_do_set_##_name);\n\nATKBD_DEFINE_ATTR(extra);\nATKBD_DEFINE_ATTR(force_release);\nATKBD_DEFINE_ATTR(scroll);\nATKBD_DEFINE_ATTR(set);\nATKBD_DEFINE_ATTR(softrepeat);\nATKBD_DEFINE_ATTR(softraw);\n\n#define ATKBD_DEFINE_RO_ATTR(_name)\t\t\t\t\t\t\\\nstatic ssize_t atkbd_show_##_name(struct atkbd *, char *);\t\t\t\\\nstatic ssize_t atkbd_do_show_##_name(struct device *d,\t\t\t\t\\\n\t\t\t\tstruct device_attribute *attr, char *b)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn atkbd_attr_show_helper(d, b, atkbd_show_##_name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nstatic struct device_attribute atkbd_attr_##_name =\t\t\t\t\\\n\t__ATTR(_name, S_IRUGO, atkbd_do_show_##_name, NULL);\n\nATKBD_DEFINE_RO_ATTR(err_count);\nATKBD_DEFINE_RO_ATTR(function_row_physmap);\n\nstatic struct attribute *atkbd_attributes[] = {\n\t&atkbd_attr_extra.attr,\n\t&atkbd_attr_force_release.attr,\n\t&atkbd_attr_scroll.attr,\n\t&atkbd_attr_set.attr,\n\t&atkbd_attr_softrepeat.attr,\n\t&atkbd_attr_softraw.attr,\n\t&atkbd_attr_err_count.attr,\n\t&atkbd_attr_function_row_physmap.attr,\n\tNULL\n};\n\nstatic ssize_t atkbd_show_function_row_physmap(struct atkbd *atkbd, char *buf)\n{\n\treturn vivaldi_function_row_physmap_show(&atkbd->vdata, buf);\n}\n\nstatic struct atkbd *atkbd_from_serio(struct serio *serio)\n{\n\tstruct ps2dev *ps2dev = serio_get_drvdata(serio);\n\n\treturn container_of(ps2dev, struct atkbd, ps2dev);\n}\n\nstatic umode_t atkbd_attr_is_visible(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, int i)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\n\tif (attr == &atkbd_attr_function_row_physmap.attr &&\n\t    !atkbd->vdata.num_function_row_keys)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group atkbd_attribute_group = {\n\t.attrs\t= atkbd_attributes,\n\t.is_visible = atkbd_attr_is_visible,\n};\n\n__ATTRIBUTE_GROUPS(atkbd_attribute);\n\nstatic const unsigned int xl_table[] = {\n\tATKBD_RET_BAT, ATKBD_RET_ERR, ATKBD_RET_ACK,\n\tATKBD_RET_NAK, ATKBD_RET_HANJA, ATKBD_RET_HANGEUL,\n};\n\n \nstatic bool atkbd_need_xlate(unsigned long xl_bit, unsigned char code)\n{\n\tint i;\n\n\tif (code == ATKBD_RET_EMUL0 || code == ATKBD_RET_EMUL1)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(xl_table); i++)\n\t\tif (code == xl_table[i])\n\t\t\treturn test_bit(i, &xl_bit);\n\n\treturn true;\n}\n\n \nstatic void atkbd_calculate_xl_bit(struct atkbd *atkbd, unsigned char code)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xl_table); i++) {\n\t\tif (!((code ^ xl_table[i]) & 0x7f)) {\n\t\t\tif (code & 0x80)\n\t\t\t\t__clear_bit(i, &atkbd->xl_bit);\n\t\t\telse\n\t\t\t\t__set_bit(i, &atkbd->xl_bit);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic unsigned int atkbd_compat_scancode(struct atkbd *atkbd, unsigned int code)\n{\n\tif (atkbd->set == 3) {\n\t\tif (atkbd->emul == 1)\n\t\t\tcode |= 0x100;\n        } else {\n\t\tcode = (code & 0x7f) | ((code & 0x80) << 1);\n\t\tif (atkbd->emul == 1)\n\t\t\tcode |= 0x80;\n\t}\n\n\treturn code;\n}\n\n \nstatic bool __maybe_unused atkbd_handle_frame_error(struct ps2dev *ps2dev,\n\t\t\t\t\t\t    u8 data, unsigned int flags)\n{\n\tstruct atkbd *atkbd = container_of(ps2dev, struct atkbd, ps2dev);\n\tstruct serio *serio = ps2dev->serio;\n\n\tif ((flags & (SERIO_FRAME | SERIO_PARITY)) &&\n\t    (~flags & SERIO_TIMEOUT) &&\n\t    !atkbd->resend && atkbd->write) {\n\t\tdev_warn(&serio->dev, \"Frame/parity error: %02x\\n\", flags);\n\t\tserio_write(serio, ATKBD_CMD_RESEND);\n\t\tatkbd->resend = true;\n\t\treturn true;\n\t}\n\n\tif (!flags && data == ATKBD_RET_ACK)\n\t\tatkbd->resend = false;\n\n\treturn false;\n}\n\nstatic enum ps2_disposition atkbd_pre_receive_byte(struct ps2dev *ps2dev,\n\t\t\t\t\t\t   u8 data, unsigned int flags)\n{\n\tstruct serio *serio = ps2dev->serio;\n\n\tdev_dbg(&serio->dev, \"Received %02x flags %02x\\n\", data, flags);\n\n#if !defined(__i386__) && !defined (__x86_64__)\n\tif (atkbd_handle_frame_error(ps2dev, data, flags))\n\t\treturn PS2_IGNORE;\n#endif\n\n\treturn PS2_PROCESS;\n}\n\nstatic void atkbd_receive_byte(struct ps2dev *ps2dev, u8 data)\n{\n\tstruct serio *serio = ps2dev->serio;\n\tstruct atkbd *atkbd = container_of(ps2dev, struct atkbd, ps2dev);\n\tstruct input_dev *dev = atkbd->dev;\n\tunsigned int code = data;\n\tint scroll = 0, hscroll = 0, click = -1;\n\tint value;\n\tunsigned short keycode;\n\n\tpm_wakeup_event(&serio->dev, 0);\n\n\tif (!atkbd->enabled)\n\t\treturn;\n\n\tinput_event(dev, EV_MSC, MSC_RAW, code);\n\n\tif (atkbd_platform_scancode_fixup)\n\t\tcode = atkbd_platform_scancode_fixup(atkbd, code);\n\n\tif (atkbd->translated) {\n\n\t\tif (atkbd->emul || atkbd_need_xlate(atkbd->xl_bit, code)) {\n\t\t\tatkbd->release = code >> 7;\n\t\t\tcode &= 0x7f;\n\t\t}\n\n\t\tif (!atkbd->emul)\n\t\t\tatkbd_calculate_xl_bit(atkbd, data);\n\t}\n\n\tswitch (code) {\n\tcase ATKBD_RET_BAT:\n\t\tatkbd->enabled = false;\n\t\tserio_reconnect(atkbd->ps2dev.serio);\n\t\treturn;\n\tcase ATKBD_RET_EMUL0:\n\t\tatkbd->emul = 1;\n\t\treturn;\n\tcase ATKBD_RET_EMUL1:\n\t\tatkbd->emul = 2;\n\t\treturn;\n\tcase ATKBD_RET_RELEASE:\n\t\tatkbd->release = true;\n\t\treturn;\n\tcase ATKBD_RET_ACK:\n\tcase ATKBD_RET_NAK:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&serio->dev,\n\t\t\t\t \"Spurious %s on %s. \"\n\t\t\t\t \"Some program might be trying to access hardware directly.\\n\",\n\t\t\t\t data == ATKBD_RET_ACK ? \"ACK\" : \"NAK\", serio->phys);\n\t\treturn;\n\tcase ATKBD_RET_ERR:\n\t\tatkbd->err_count++;\n\t\tdev_dbg(&serio->dev, \"Keyboard on %s reports too many keys pressed.\\n\",\n\t\t\tserio->phys);\n\t\treturn;\n\t}\n\n\tcode = atkbd_compat_scancode(atkbd, code);\n\n\tif (atkbd->emul && --atkbd->emul)\n\t\treturn;\n\n\tkeycode = atkbd->keycode[code];\n\n\tif (!(atkbd->release && test_bit(code, atkbd->force_release_mask)))\n\t\tif (keycode != ATKBD_KEY_NULL)\n\t\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\n\tswitch (keycode) {\n\tcase ATKBD_KEY_NULL:\n\t\tbreak;\n\tcase ATKBD_KEY_UNKNOWN:\n\t\tdev_warn(&serio->dev,\n\t\t\t \"Unknown key %s (%s set %d, code %#x on %s).\\n\",\n\t\t\t atkbd->release ? \"released\" : \"pressed\",\n\t\t\t atkbd->translated ? \"translated\" : \"raw\",\n\t\t\t atkbd->set, code, serio->phys);\n\t\tdev_warn(&serio->dev,\n\t\t\t \"Use 'setkeycodes %s%02x <keycode>' to make it known.\\n\",\n\t\t\t code & 0x80 ? \"e0\" : \"\", code & 0x7f);\n\t\tinput_sync(dev);\n\t\tbreak;\n\tcase ATKBD_SCR_1:\n\t\tscroll = 1;\n\t\tbreak;\n\tcase ATKBD_SCR_2:\n\t\tscroll = 2;\n\t\tbreak;\n\tcase ATKBD_SCR_4:\n\t\tscroll = 4;\n\t\tbreak;\n\tcase ATKBD_SCR_8:\n\t\tscroll = 8;\n\t\tbreak;\n\tcase ATKBD_SCR_CLICK:\n\t\tclick = !atkbd->release;\n\t\tbreak;\n\tcase ATKBD_SCR_LEFT:\n\t\thscroll = -1;\n\t\tbreak;\n\tcase ATKBD_SCR_RIGHT:\n\t\thscroll = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (atkbd->release) {\n\t\t\tvalue = 0;\n\t\t\tatkbd->last = 0;\n\t\t} else if (!atkbd->softrepeat && test_bit(keycode, dev->key)) {\n\t\t\t \n\t\t\tvalue = time_before(jiffies, atkbd->time) && atkbd->last == code ? 1 : 2;\n\t\t} else {\n\t\t\tvalue = 1;\n\t\t\tatkbd->last = code;\n\t\t\tatkbd->time = jiffies + msecs_to_jiffies(dev->rep[REP_DELAY]) / 2;\n\t\t}\n\n\t\tinput_event(dev, EV_KEY, keycode, value);\n\t\tinput_sync(dev);\n\n\t\tif (value && test_bit(code, atkbd->force_release_mask)) {\n\t\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(dev, keycode, 0);\n\t\t\tinput_sync(dev);\n\t\t}\n\t}\n\n\tif (atkbd->scroll) {\n\t\tif (click != -1)\n\t\t\tinput_report_key(dev, BTN_MIDDLE, click);\n\t\tinput_report_rel(dev, REL_WHEEL,\n\t\t\t\t atkbd->release ? -scroll : scroll);\n\t\tinput_report_rel(dev, REL_HWHEEL, hscroll);\n\t\tinput_sync(dev);\n\t}\n\n\tatkbd->release = false;\n}\n\nstatic int atkbd_set_repeat_rate(struct atkbd *atkbd)\n{\n\tconst short period[32] =\n\t\t{ 33,  37,  42,  46,  50,  54,  58,  63,  67,  75,  83,  92, 100, 109, 116, 125,\n\t\t 133, 149, 167, 182, 200, 217, 232, 250, 270, 303, 333, 370, 400, 435, 470, 500 };\n\tconst short delay[4] =\n\t\t{ 250, 500, 750, 1000 };\n\n\tstruct input_dev *dev = atkbd->dev;\n\tunsigned char param;\n\tint i = 0, j = 0;\n\n\twhile (i < ARRAY_SIZE(period) - 1 && period[i] < dev->rep[REP_PERIOD])\n\t\ti++;\n\tdev->rep[REP_PERIOD] = period[i];\n\n\twhile (j < ARRAY_SIZE(delay) - 1 && delay[j] < dev->rep[REP_DELAY])\n\t\tj++;\n\tdev->rep[REP_DELAY] = delay[j];\n\n\tparam = i | (j << 5);\n\treturn ps2_command(&atkbd->ps2dev, &param, ATKBD_CMD_SETREP);\n}\n\nstatic int atkbd_set_leds(struct atkbd *atkbd)\n{\n\tstruct input_dev *dev = atkbd->dev;\n\tunsigned char param[2];\n\n\tparam[0] = (test_bit(LED_SCROLLL, dev->led) ? 1 : 0)\n\t\t | (test_bit(LED_NUML,    dev->led) ? 2 : 0)\n\t\t | (test_bit(LED_CAPSL,   dev->led) ? 4 : 0);\n\tif (ps2_command(&atkbd->ps2dev, param, ATKBD_CMD_SETLEDS))\n\t\treturn -1;\n\n\tif (atkbd->extra) {\n\t\tparam[0] = 0;\n\t\tparam[1] = (test_bit(LED_COMPOSE, dev->led) ? 0x01 : 0)\n\t\t\t | (test_bit(LED_SLEEP,   dev->led) ? 0x02 : 0)\n\t\t\t | (test_bit(LED_SUSPEND, dev->led) ? 0x04 : 0)\n\t\t\t | (test_bit(LED_MISC,    dev->led) ? 0x10 : 0)\n\t\t\t | (test_bit(LED_MUTE,    dev->led) ? 0x20 : 0);\n\t\tif (ps2_command(&atkbd->ps2dev, param, ATKBD_CMD_EX_SETLEDS))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void atkbd_event_work(struct work_struct *work)\n{\n\tstruct atkbd *atkbd = container_of(work, struct atkbd, event_work.work);\n\n\tmutex_lock(&atkbd->mutex);\n\n\tif (!atkbd->enabled) {\n\t\t \n\t\tschedule_delayed_work(&atkbd->event_work,\n\t\t\t\t\tmsecs_to_jiffies(100));\n\t} else {\n\t\tif (test_and_clear_bit(ATKBD_LED_EVENT_BIT, &atkbd->event_mask))\n\t\t\tatkbd_set_leds(atkbd);\n\n\t\tif (test_and_clear_bit(ATKBD_REP_EVENT_BIT, &atkbd->event_mask))\n\t\t\tatkbd_set_repeat_rate(atkbd);\n\t}\n\n\tmutex_unlock(&atkbd->mutex);\n}\n\n \nstatic void atkbd_schedule_event_work(struct atkbd *atkbd, int event_bit)\n{\n\tunsigned long delay = msecs_to_jiffies(50);\n\n\tif (time_after(jiffies, atkbd->event_jiffies + delay))\n\t\tdelay = 0;\n\n\tatkbd->event_jiffies = jiffies;\n\tset_bit(event_bit, &atkbd->event_mask);\n\tmb();\n\tschedule_delayed_work(&atkbd->event_work, delay);\n}\n\n \n\nstatic int atkbd_event(struct input_dev *dev,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct atkbd *atkbd = input_get_drvdata(dev);\n\n\tif (!atkbd->write)\n\t\treturn -1;\n\n\tswitch (type) {\n\n\tcase EV_LED:\n\t\tatkbd_schedule_event_work(atkbd, ATKBD_LED_EVENT_BIT);\n\t\treturn 0;\n\n\tcase EV_REP:\n\t\tif (!atkbd->softrepeat)\n\t\t\tatkbd_schedule_event_work(atkbd, ATKBD_REP_EVENT_BIT);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \n\nstatic inline void atkbd_enable(struct atkbd *atkbd)\n{\n\tserio_pause_rx(atkbd->ps2dev.serio);\n\tatkbd->enabled = true;\n\tserio_continue_rx(atkbd->ps2dev.serio);\n}\n\n \n\nstatic inline void atkbd_disable(struct atkbd *atkbd)\n{\n\tserio_pause_rx(atkbd->ps2dev.serio);\n\tatkbd->enabled = false;\n\tserio_continue_rx(atkbd->ps2dev.serio);\n}\n\nstatic int atkbd_activate(struct atkbd *atkbd)\n{\n\tstruct ps2dev *ps2dev = &atkbd->ps2dev;\n\n \n\n\tif (ps2_command(ps2dev, NULL, ATKBD_CMD_ENABLE)) {\n\t\tdev_err(&ps2dev->serio->dev,\n\t\t\t\"Failed to enable keyboard on %s\\n\",\n\t\t\tps2dev->serio->phys);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void atkbd_deactivate(struct atkbd *atkbd)\n{\n\tstruct ps2dev *ps2dev = &atkbd->ps2dev;\n\n\tif (ps2_command(ps2dev, NULL, ATKBD_CMD_RESET_DIS))\n\t\tdev_err(&ps2dev->serio->dev,\n\t\t\t\"Failed to deactivate keyboard on %s\\n\",\n\t\t\tps2dev->serio->phys);\n}\n\n#ifdef CONFIG_X86\nstatic bool atkbd_is_portable_device(void)\n{\n\tstatic const char * const chassis_types[] = {\n\t\t\"8\",\t \n\t\t\"9\",\t \n\t\t\"10\",\t \n\t\t\"14\",\t \n\t\t\"31\",\t \n\t\t\"32\",\t \n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chassis_types); i++)\n\t\tif (dmi_match(DMI_CHASSIS_TYPE, chassis_types[i]))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool atkbd_skip_getid(struct atkbd *atkbd)\n{\n\treturn atkbd->translated && atkbd_is_portable_device();\n}\n#else\nstatic inline bool atkbd_skip_getid(struct atkbd *atkbd) { return false; }\n#endif\n\n \n\nstatic int atkbd_probe(struct atkbd *atkbd)\n{\n\tstruct ps2dev *ps2dev = &atkbd->ps2dev;\n\tunsigned char param[2];\n\tbool skip_getid;\n\n \n\n\tif (atkbd_reset)\n\t\tif (ps2_command(ps2dev, NULL, ATKBD_CMD_RESET_BAT))\n\t\t\tdev_warn(&ps2dev->serio->dev,\n\t\t\t\t \"keyboard reset failed on %s\\n\",\n\t\t\t\t ps2dev->serio->phys);\n\n \n\n\tparam[0] = param[1] = 0xa5;\t \n\tskip_getid = atkbd_skip_getid(atkbd);\n\tif (skip_getid || ps2_command(ps2dev, param, ATKBD_CMD_GETID)) {\n\n \n\t\tparam[0] = 0;\n\t\tif (ps2_command(ps2dev, param, ATKBD_CMD_SETLEDS))\n\t\t\treturn -1;\n\t\tatkbd->id = skip_getid ? 0xab83 : 0xabba;\n\t\treturn 0;\n\t}\n\n\tif (!ps2_is_keyboard_id(param[0]))\n\t\treturn -1;\n\n\tatkbd->id = (param[0] << 8) | param[1];\n\n\tif (atkbd->id == 0xaca1 && atkbd->translated) {\n\t\tdev_err(&ps2dev->serio->dev,\n\t\t\t\"NCD terminal keyboards are only supported on non-translating controllers. \"\n\t\t\t\"Use i8042.direct=1 to disable translation.\\n\");\n\t\treturn -1;\n\t}\n\n \n\tif (!atkbd_skip_deactivate)\n\t\tatkbd_deactivate(atkbd);\n\n\treturn 0;\n}\n\n \n\nstatic int atkbd_select_set(struct atkbd *atkbd, int target_set, int allow_extra)\n{\n\tstruct ps2dev *ps2dev = &atkbd->ps2dev;\n\tunsigned char param[2];\n\n\tatkbd->extra = false;\n \n\n\tif (atkbd->translated)\n\t\treturn 2;\n\n\tif (atkbd->id == 0xaca1) {\n\t\tparam[0] = 3;\n\t\tps2_command(ps2dev, param, ATKBD_CMD_SSCANSET);\n\t\treturn 3;\n\t}\n\n\tif (allow_extra) {\n\t\tparam[0] = 0x71;\n\t\tif (!ps2_command(ps2dev, param, ATKBD_CMD_EX_ENABLE)) {\n\t\t\tatkbd->extra = true;\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (atkbd_terminal) {\n\t\tps2_command(ps2dev, param, ATKBD_CMD_SETALL_MB);\n\t\treturn 3;\n\t}\n\n\tif (target_set != 3)\n\t\treturn 2;\n\n\tif (!ps2_command(ps2dev, param, ATKBD_CMD_OK_GETID)) {\n\t\tatkbd->id = param[0] << 8 | param[1];\n\t\treturn 2;\n\t}\n\n\tparam[0] = 3;\n\tif (ps2_command(ps2dev, param, ATKBD_CMD_SSCANSET))\n\t\treturn 2;\n\n\tparam[0] = 0;\n\tif (ps2_command(ps2dev, param, ATKBD_CMD_GSCANSET))\n\t\treturn 2;\n\n\tif (param[0] != 3) {\n\t\tparam[0] = 2;\n\t\tif (ps2_command(ps2dev, param, ATKBD_CMD_SSCANSET))\n\t\t\treturn 2;\n\t}\n\n\tps2_command(ps2dev, param, ATKBD_CMD_SETALL_MBR);\n\n\treturn 3;\n}\n\nstatic int atkbd_reset_state(struct atkbd *atkbd)\n{\n        struct ps2dev *ps2dev = &atkbd->ps2dev;\n\tunsigned char param[1];\n\n \n\n\tparam[0] = 0;\n\tif (ps2_command(ps2dev, param, ATKBD_CMD_SETLEDS))\n\t\treturn -1;\n\n \n\n\tparam[0] = 0;\n\tif (ps2_command(ps2dev, param, ATKBD_CMD_SETREP))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n\nstatic void atkbd_cleanup(struct serio *serio)\n{\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\n\tatkbd_disable(atkbd);\n\tps2_command(&atkbd->ps2dev, NULL, ATKBD_CMD_RESET_DEF);\n}\n\n\n \n\nstatic void atkbd_disconnect(struct serio *serio)\n{\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\n\tatkbd_disable(atkbd);\n\n\tinput_unregister_device(atkbd->dev);\n\n\t \n\tcancel_delayed_work_sync(&atkbd->event_work);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(atkbd);\n}\n\n \nstatic void atkbd_apply_forced_release_keylist(struct atkbd* atkbd,\n\t\t\t\t\t\tconst void *data)\n{\n\tconst unsigned int *keys = data;\n\tunsigned int i;\n\n\tif (atkbd->set == 2)\n\t\tfor (i = 0; keys[i] != -1U; i++)\n\t\t\t__set_bit(keys[i], atkbd->force_release_mask);\n}\n\n \nstatic unsigned int atkbd_dell_laptop_forced_release_keys[] = {\n\t0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8f, 0x93, -1U\n};\n\n \nstatic unsigned int atkbd_hp_forced_release_keys[] = {\n\t0x94, -1U\n};\n\n \nstatic unsigned int atkbd_samsung_forced_release_keys[] = {\n\t0x82, 0x83, 0x84, 0x86, 0x88, 0x89, 0xb3, 0xf7, 0xf9, -1U\n};\n\n \nstatic unsigned int atkbd_amilo_pi3525_forced_release_keys[] = {\n\t0x20, 0xa0, 0x2e, 0xae, 0x30, 0xb0, -1U\n};\n\n \nstatic unsigned int atkbd_amilo_xi3650_forced_release_keys[] = {\n\t0x67, 0xed, 0x90, 0xa2, 0x99, 0xa4, 0xae, 0xb0, -1U\n};\n\n \nstatic unsigned int atkdb_soltech_ta12_forced_release_keys[] = {\n\t0xa0, 0xae, 0xb0, -1U\n};\n\n \nstatic unsigned int atkbd_volume_forced_release_keys[] = {\n\t0xae, 0xb0, -1U\n};\n\n \nstatic unsigned int atkbd_oqo_01plus_scancode_fixup(struct atkbd *atkbd,\n\t\t\t\t\t\t    unsigned int code)\n{\n\tif (atkbd->translated && atkbd->emul == 1 &&\n\t    (code == 0x64 || code == 0x65 || code == 0x66)) {\n\t\tatkbd->emul = 0;\n\t\tcode |= 0x80;\n\t}\n\n\treturn code;\n}\n\nstatic int atkbd_get_keymap_from_fwnode(struct atkbd *atkbd)\n{\n\tstruct device *dev = &atkbd->ps2dev.serio->dev;\n\tint i, n;\n\tu32 *ptr;\n\tu16 scancode, keycode;\n\n\t \n\tn = device_property_count_u32(dev, \"linux,keymap\");\n\tif (n <= 0 || n > ATKBD_KEYMAP_SIZE)\n\t\treturn -ENXIO;\n\n\tptr = kcalloc(n, sizeof(u32), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tif (device_property_read_u32_array(dev, \"linux,keymap\", ptr, n)) {\n\t\tdev_err(dev, \"problem parsing FW keymap property\\n\");\n\t\tkfree(ptr);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(atkbd->keycode, 0, sizeof(atkbd->keycode));\n\tfor (i = 0; i < n; i++) {\n\t\tscancode = SCANCODE(ptr[i]);\n\t\tkeycode = KEYCODE(ptr[i]);\n\t\tatkbd->keycode[scancode] = keycode;\n\t}\n\n\tkfree(ptr);\n\treturn 0;\n}\n\n \n\nstatic void atkbd_set_keycode_table(struct atkbd *atkbd)\n{\n\tstruct device *dev = &atkbd->ps2dev.serio->dev;\n\tunsigned int scancode;\n\tint i, j;\n\n\tmemset(atkbd->keycode, 0, sizeof(atkbd->keycode));\n\tbitmap_zero(atkbd->force_release_mask, ATKBD_KEYMAP_SIZE);\n\n\tif (!atkbd_get_keymap_from_fwnode(atkbd)) {\n\t\tdev_dbg(dev, \"Using FW keymap\\n\");\n\t} else if (atkbd->translated) {\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tscancode = atkbd_unxlate_table[i];\n\t\t\tatkbd->keycode[i] = atkbd_set2_keycode[scancode];\n\t\t\tatkbd->keycode[i | 0x80] = atkbd_set2_keycode[scancode | 0x80];\n\t\t\tif (atkbd->scroll)\n\t\t\t\tfor (j = 0; j < ARRAY_SIZE(atkbd_scroll_keys); j++)\n\t\t\t\t\tif ((scancode | 0x80) == atkbd_scroll_keys[j].set2)\n\t\t\t\t\t\tatkbd->keycode[i | 0x80] = atkbd_scroll_keys[j].keycode;\n\t\t}\n\t} else if (atkbd->set == 3) {\n\t\tmemcpy(atkbd->keycode, atkbd_set3_keycode, sizeof(atkbd->keycode));\n\t} else {\n\t\tmemcpy(atkbd->keycode, atkbd_set2_keycode, sizeof(atkbd->keycode));\n\n\t\tif (atkbd->scroll)\n\t\t\tfor (i = 0; i < ARRAY_SIZE(atkbd_scroll_keys); i++) {\n\t\t\t\tscancode = atkbd_scroll_keys[i].set2;\n\t\t\t\tatkbd->keycode[scancode] = atkbd_scroll_keys[i].keycode;\n\t\t}\n\t}\n\n \n\tscancode = atkbd_compat_scancode(atkbd, ATKBD_RET_HANGEUL);\n\tatkbd->keycode[scancode] = KEY_HANGEUL;\n\t__set_bit(scancode, atkbd->force_release_mask);\n\n\tscancode = atkbd_compat_scancode(atkbd, ATKBD_RET_HANJA);\n\tatkbd->keycode[scancode] = KEY_HANJA;\n\t__set_bit(scancode, atkbd->force_release_mask);\n\n \n\tif (atkbd_platform_fixup)\n\t\tatkbd_platform_fixup(atkbd, atkbd_platform_fixup_data);\n}\n\n \n\nstatic void atkbd_set_device_attrs(struct atkbd *atkbd)\n{\n\tstruct input_dev *input_dev = atkbd->dev;\n\tint i;\n\n\tif (atkbd->extra)\n\t\tsnprintf(atkbd->name, sizeof(atkbd->name),\n\t\t\t \"AT Set 2 Extra keyboard\");\n\telse\n\t\tsnprintf(atkbd->name, sizeof(atkbd->name),\n\t\t\t \"AT %s Set %d keyboard\",\n\t\t\t atkbd->translated ? \"Translated\" : \"Raw\", atkbd->set);\n\n\tsnprintf(atkbd->phys, sizeof(atkbd->phys),\n\t\t \"%s/input0\", atkbd->ps2dev.serio->phys);\n\n\tinput_dev->name = atkbd->name;\n\tinput_dev->phys = atkbd->phys;\n\tinput_dev->id.bustype = BUS_I8042;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = atkbd->translated ? 1 : atkbd->set;\n\tinput_dev->id.version = atkbd->id;\n\tinput_dev->event = atkbd_event;\n\tinput_dev->dev.parent = &atkbd->ps2dev.serio->dev;\n\n\tinput_set_drvdata(input_dev, atkbd);\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |\n\t\tBIT_MASK(EV_MSC);\n\n\tif (atkbd->write) {\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_LED);\n\t\tinput_dev->ledbit[0] = BIT_MASK(LED_NUML) |\n\t\t\tBIT_MASK(LED_CAPSL) | BIT_MASK(LED_SCROLLL);\n\t}\n\n\tif (atkbd->extra)\n\t\tinput_dev->ledbit[0] |= BIT_MASK(LED_COMPOSE) |\n\t\t\tBIT_MASK(LED_SUSPEND) | BIT_MASK(LED_SLEEP) |\n\t\t\tBIT_MASK(LED_MUTE) | BIT_MASK(LED_MISC);\n\n\tif (!atkbd->softrepeat) {\n\t\tinput_dev->rep[REP_DELAY] = 250;\n\t\tinput_dev->rep[REP_PERIOD] = 33;\n\t}\n\n\tinput_dev->mscbit[0] = atkbd->softraw ? BIT_MASK(MSC_SCAN) :\n\t\tBIT_MASK(MSC_RAW) | BIT_MASK(MSC_SCAN);\n\n\tif (atkbd->scroll) {\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_REL);\n\t\tinput_dev->relbit[0] = BIT_MASK(REL_WHEEL) |\n\t\t\tBIT_MASK(REL_HWHEEL);\n\t\t__set_bit(BTN_MIDDLE, input_dev->keybit);\n\t}\n\n\tinput_dev->keycode = atkbd->keycode;\n\tinput_dev->keycodesize = sizeof(unsigned short);\n\tinput_dev->keycodemax = ARRAY_SIZE(atkbd_set2_keycode);\n\n\tfor (i = 0; i < ATKBD_KEYMAP_SIZE; i++) {\n\t\tif (atkbd->keycode[i] != KEY_RESERVED &&\n\t\t    atkbd->keycode[i] != ATKBD_KEY_NULL &&\n\t\t    atkbd->keycode[i] < ATKBD_SPECIAL) {\n\t\t\t__set_bit(atkbd->keycode[i], input_dev->keybit);\n\t\t}\n\t}\n}\n\nstatic void atkbd_parse_fwnode_data(struct serio *serio)\n{\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\tstruct device *dev = &serio->dev;\n\tint n;\n\n\t \n\tn = device_property_count_u32(dev, \"function-row-physmap\");\n\tif (n > 0 && n <= VIVALDI_MAX_FUNCTION_ROW_KEYS &&\n\t    !device_property_read_u32_array(dev, \"function-row-physmap\",\n\t\t\t\t\t    atkbd->vdata.function_row_physmap,\n\t\t\t\t\t    n)) {\n\t\tatkbd->vdata.num_function_row_keys = n;\n\t\tdev_dbg(dev, \"FW reported %d function-row key locations\\n\", n);\n\t}\n}\n\n \n\nstatic int atkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct atkbd *atkbd;\n\tstruct input_dev *dev;\n\tint err = -ENOMEM;\n\n\tatkbd = kzalloc(sizeof(struct atkbd), GFP_KERNEL);\n\tdev = input_allocate_device();\n\tif (!atkbd || !dev)\n\t\tgoto fail1;\n\n\tatkbd->dev = dev;\n\tps2_init(&atkbd->ps2dev, serio,\n\t\t atkbd_pre_receive_byte, atkbd_receive_byte);\n\tINIT_DELAYED_WORK(&atkbd->event_work, atkbd_event_work);\n\tmutex_init(&atkbd->mutex);\n\n\tswitch (serio->id.type) {\n\n\tcase SERIO_8042_XL:\n\t\tatkbd->translated = true;\n\t\tfallthrough;\n\n\tcase SERIO_8042:\n\t\tif (serio->write)\n\t\t\tatkbd->write = true;\n\t\tbreak;\n\t}\n\n\tatkbd->softraw = atkbd_softraw;\n\tatkbd->softrepeat = atkbd_softrepeat;\n\tatkbd->scroll = atkbd_scroll;\n\n\tif (atkbd->softrepeat)\n\t\tatkbd->softraw = true;\n\n\tserio_set_drvdata(serio, atkbd);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\tif (atkbd->write) {\n\n\t\tif (atkbd_probe(atkbd)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto fail3;\n\t\t}\n\n\t\tatkbd->set = atkbd_select_set(atkbd, atkbd_set, atkbd_extra);\n\t\tatkbd_reset_state(atkbd);\n\n\t} else {\n\t\tatkbd->set = 2;\n\t\tatkbd->id = 0xab00;\n\t}\n\n\tatkbd_parse_fwnode_data(serio);\n\n\tatkbd_set_keycode_table(atkbd);\n\tatkbd_set_device_attrs(atkbd);\n\n\tatkbd_enable(atkbd);\n\tif (serio->write)\n\t\tatkbd_activate(atkbd);\n\n\terr = input_register_device(atkbd->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(dev);\n\tkfree(atkbd);\n\treturn err;\n}\n\n \n\nstatic int atkbd_reconnect(struct serio *serio)\n{\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\tstruct serio_driver *drv = serio->drv;\n\tint retval = -1;\n\n\tif (!atkbd || !drv) {\n\t\tdev_dbg(&serio->dev,\n\t\t\t\"reconnect request, but serio is disconnected, ignoring...\\n\");\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&atkbd->mutex);\n\n\tatkbd_disable(atkbd);\n\n\tif (atkbd->write) {\n\t\tif (atkbd_probe(atkbd))\n\t\t\tgoto out;\n\n\t\tif (atkbd->set != atkbd_select_set(atkbd, atkbd->set, atkbd->extra))\n\t\t\tgoto out;\n\n\t\t \n\t\tatkbd_set_leds(atkbd);\n\t\tif (!atkbd->softrepeat)\n\t\t\tatkbd_set_repeat_rate(atkbd);\n\n\t}\n\n\t \n\tatkbd->xl_bit = 0;\n\tatkbd->emul = 0;\n\n\tatkbd_enable(atkbd);\n\tif (atkbd->write)\n\t\tatkbd_activate(atkbd);\n\n\tretval = 0;\n\n out:\n\tmutex_unlock(&atkbd->mutex);\n\treturn retval;\n}\n\nstatic const struct serio_device_id atkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_8042,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_8042_XL,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_PS2SER,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, atkbd_serio_ids);\n\nstatic struct serio_driver atkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"atkbd\",\n\t\t.dev_groups\t= atkbd_attribute_groups,\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= atkbd_serio_ids,\n\t.interrupt\t= ps2_interrupt,\n\t.connect\t= atkbd_connect,\n\t.reconnect\t= atkbd_reconnect,\n\t.disconnect\t= atkbd_disconnect,\n\t.cleanup\t= atkbd_cleanup,\n};\n\nstatic ssize_t atkbd_attr_show_helper(struct device *dev, char *buf,\n\t\t\t\tssize_t (*handler)(struct atkbd *, char *))\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\n\treturn handler(atkbd, buf);\n}\n\nstatic ssize_t atkbd_attr_set_helper(struct device *dev, const char *buf, size_t count,\n\t\t\t\tssize_t (*handler)(struct atkbd *, const char *, size_t))\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct atkbd *atkbd = atkbd_from_serio(serio);\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&atkbd->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tatkbd_disable(atkbd);\n\tretval = handler(atkbd, buf, count);\n\tatkbd_enable(atkbd);\n\n\tmutex_unlock(&atkbd->mutex);\n\n\treturn retval;\n}\n\nstatic ssize_t atkbd_show_extra(struct atkbd *atkbd, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", atkbd->extra ? 1 : 0);\n}\n\nstatic ssize_t atkbd_set_extra(struct atkbd *atkbd, const char *buf, size_t count)\n{\n\tstruct input_dev *old_dev, *new_dev;\n\tunsigned int value;\n\tint err;\n\tbool old_extra;\n\tunsigned char old_set;\n\n\tif (!atkbd->write)\n\t\treturn -EIO;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (atkbd->extra != value) {\n\t\t \n\t\told_dev = atkbd->dev;\n\t\told_extra = atkbd->extra;\n\t\told_set = atkbd->set;\n\n\t\tnew_dev = input_allocate_device();\n\t\tif (!new_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tatkbd->dev = new_dev;\n\t\tatkbd->set = atkbd_select_set(atkbd, atkbd->set, value);\n\t\tatkbd_reset_state(atkbd);\n\t\tatkbd_activate(atkbd);\n\t\tatkbd_set_keycode_table(atkbd);\n\t\tatkbd_set_device_attrs(atkbd);\n\n\t\terr = input_register_device(atkbd->dev);\n\t\tif (err) {\n\t\t\tinput_free_device(new_dev);\n\n\t\t\tatkbd->dev = old_dev;\n\t\t\tatkbd->set = atkbd_select_set(atkbd, old_set, old_extra);\n\t\t\tatkbd_set_keycode_table(atkbd);\n\t\t\tatkbd_set_device_attrs(atkbd);\n\n\t\t\treturn err;\n\t\t}\n\t\tinput_unregister_device(old_dev);\n\n\t}\n\treturn count;\n}\n\nstatic ssize_t atkbd_show_force_release(struct atkbd *atkbd, char *buf)\n{\n\tsize_t len = scnprintf(buf, PAGE_SIZE - 1, \"%*pbl\",\n\t\t\t       ATKBD_KEYMAP_SIZE, atkbd->force_release_mask);\n\n\tbuf[len++] = '\\n';\n\tbuf[len] = '\\0';\n\n\treturn len;\n}\n\nstatic ssize_t atkbd_set_force_release(struct atkbd *atkbd,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\t \n\tDECLARE_BITMAP(new_mask, ATKBD_KEYMAP_SIZE);\n\tint err;\n\n\terr = bitmap_parselist(buf, new_mask, ATKBD_KEYMAP_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(atkbd->force_release_mask, new_mask, sizeof(atkbd->force_release_mask));\n\treturn count;\n}\n\n\nstatic ssize_t atkbd_show_scroll(struct atkbd *atkbd, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", atkbd->scroll ? 1 : 0);\n}\n\nstatic ssize_t atkbd_set_scroll(struct atkbd *atkbd, const char *buf, size_t count)\n{\n\tstruct input_dev *old_dev, *new_dev;\n\tunsigned int value;\n\tint err;\n\tbool old_scroll;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (atkbd->scroll != value) {\n\t\told_dev = atkbd->dev;\n\t\told_scroll = atkbd->scroll;\n\n\t\tnew_dev = input_allocate_device();\n\t\tif (!new_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tatkbd->dev = new_dev;\n\t\tatkbd->scroll = value;\n\t\tatkbd_set_keycode_table(atkbd);\n\t\tatkbd_set_device_attrs(atkbd);\n\n\t\terr = input_register_device(atkbd->dev);\n\t\tif (err) {\n\t\t\tinput_free_device(new_dev);\n\n\t\t\tatkbd->scroll = old_scroll;\n\t\t\tatkbd->dev = old_dev;\n\t\t\tatkbd_set_keycode_table(atkbd);\n\t\t\tatkbd_set_device_attrs(atkbd);\n\n\t\t\treturn err;\n\t\t}\n\t\tinput_unregister_device(old_dev);\n\t}\n\treturn count;\n}\n\nstatic ssize_t atkbd_show_set(struct atkbd *atkbd, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", atkbd->set);\n}\n\nstatic ssize_t atkbd_set_set(struct atkbd *atkbd, const char *buf, size_t count)\n{\n\tstruct input_dev *old_dev, *new_dev;\n\tunsigned int value;\n\tint err;\n\tunsigned char old_set;\n\tbool old_extra;\n\n\tif (!atkbd->write)\n\t\treturn -EIO;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value != 2 && value != 3)\n\t\treturn -EINVAL;\n\n\tif (atkbd->set != value) {\n\t\told_dev = atkbd->dev;\n\t\told_extra = atkbd->extra;\n\t\told_set = atkbd->set;\n\n\t\tnew_dev = input_allocate_device();\n\t\tif (!new_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tatkbd->dev = new_dev;\n\t\tatkbd->set = atkbd_select_set(atkbd, value, atkbd->extra);\n\t\tatkbd_reset_state(atkbd);\n\t\tatkbd_activate(atkbd);\n\t\tatkbd_set_keycode_table(atkbd);\n\t\tatkbd_set_device_attrs(atkbd);\n\n\t\terr = input_register_device(atkbd->dev);\n\t\tif (err) {\n\t\t\tinput_free_device(new_dev);\n\n\t\t\tatkbd->dev = old_dev;\n\t\t\tatkbd->set = atkbd_select_set(atkbd, old_set, old_extra);\n\t\t\tatkbd_set_keycode_table(atkbd);\n\t\t\tatkbd_set_device_attrs(atkbd);\n\n\t\t\treturn err;\n\t\t}\n\t\tinput_unregister_device(old_dev);\n\t}\n\treturn count;\n}\n\nstatic ssize_t atkbd_show_softrepeat(struct atkbd *atkbd, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", atkbd->softrepeat ? 1 : 0);\n}\n\nstatic ssize_t atkbd_set_softrepeat(struct atkbd *atkbd, const char *buf, size_t count)\n{\n\tstruct input_dev *old_dev, *new_dev;\n\tunsigned int value;\n\tint err;\n\tbool old_softrepeat, old_softraw;\n\n\tif (!atkbd->write)\n\t\treturn -EIO;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (atkbd->softrepeat != value) {\n\t\told_dev = atkbd->dev;\n\t\told_softrepeat = atkbd->softrepeat;\n\t\told_softraw = atkbd->softraw;\n\n\t\tnew_dev = input_allocate_device();\n\t\tif (!new_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tatkbd->dev = new_dev;\n\t\tatkbd->softrepeat = value;\n\t\tif (atkbd->softrepeat)\n\t\t\tatkbd->softraw = true;\n\t\tatkbd_set_device_attrs(atkbd);\n\n\t\terr = input_register_device(atkbd->dev);\n\t\tif (err) {\n\t\t\tinput_free_device(new_dev);\n\n\t\t\tatkbd->dev = old_dev;\n\t\t\tatkbd->softrepeat = old_softrepeat;\n\t\t\tatkbd->softraw = old_softraw;\n\t\t\tatkbd_set_device_attrs(atkbd);\n\n\t\t\treturn err;\n\t\t}\n\t\tinput_unregister_device(old_dev);\n\t}\n\treturn count;\n}\n\n\nstatic ssize_t atkbd_show_softraw(struct atkbd *atkbd, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", atkbd->softraw ? 1 : 0);\n}\n\nstatic ssize_t atkbd_set_softraw(struct atkbd *atkbd, const char *buf, size_t count)\n{\n\tstruct input_dev *old_dev, *new_dev;\n\tunsigned int value;\n\tint err;\n\tbool old_softraw;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (atkbd->softraw != value) {\n\t\told_dev = atkbd->dev;\n\t\told_softraw = atkbd->softraw;\n\n\t\tnew_dev = input_allocate_device();\n\t\tif (!new_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tatkbd->dev = new_dev;\n\t\tatkbd->softraw = value;\n\t\tatkbd_set_device_attrs(atkbd);\n\n\t\terr = input_register_device(atkbd->dev);\n\t\tif (err) {\n\t\t\tinput_free_device(new_dev);\n\n\t\t\tatkbd->dev = old_dev;\n\t\t\tatkbd->softraw = old_softraw;\n\t\t\tatkbd_set_device_attrs(atkbd);\n\n\t\t\treturn err;\n\t\t}\n\t\tinput_unregister_device(old_dev);\n\t}\n\treturn count;\n}\n\nstatic ssize_t atkbd_show_err_count(struct atkbd *atkbd, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", atkbd->err_count);\n}\n\nstatic int __init atkbd_setup_forced_release(const struct dmi_system_id *id)\n{\n\tatkbd_platform_fixup = atkbd_apply_forced_release_keylist;\n\tatkbd_platform_fixup_data = id->driver_data;\n\n\treturn 1;\n}\n\nstatic int __init atkbd_setup_scancode_fixup(const struct dmi_system_id *id)\n{\n\tatkbd_platform_scancode_fixup = id->driver_data;\n\n\treturn 1;\n}\n\nstatic int __init atkbd_deactivate_fixup(const struct dmi_system_id *id)\n{\n\tatkbd_skip_deactivate = true;\n\treturn 1;\n}\n\n \nstatic const struct dmi_system_id atkbd_dmi_quirk_table[] __initconst = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"8\"),  \n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_dell_laptop_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"8\"),  \n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_dell_laptop_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP 2133\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_hp_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Pavilion ZV6100\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_volume_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Presario R4000\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_volume_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Presario R4100\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_volume_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Presario R4200\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_volume_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"INVENTEC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SYMPHONY 6.0/7.0\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_volume_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"NC10\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_samsung_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"NC20\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_samsung_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SQ45S70S\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_samsung_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Pa 1510\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_volume_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Pi 3525\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_amilo_pi3525_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Xi 3650\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkbd_amilo_xi3650_forced_release_keys,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Soltech Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TA12\"),\n\t\t},\n\t\t.callback = atkbd_setup_forced_release,\n\t\t.driver_data = atkdb_soltech_ta12_forced_release_keys,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"OQO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZEPTO\"),\n\t\t},\n\t\t.callback = atkbd_setup_scancode_fixup,\n\t\t.driver_data = atkbd_oqo_01plus_scancode_fixup,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LG Electronics\"),\n\t\t},\n\t\t.callback = atkbd_deactivate_fixup,\n\t},\n\t{ }\n};\n\nstatic int __init atkbd_init(void)\n{\n\tdmi_check_system(atkbd_dmi_quirk_table);\n\n\treturn serio_register_driver(&atkbd_drv);\n}\n\nstatic void __exit atkbd_exit(void)\n{\n\tserio_unregister_driver(&atkbd_drv);\n}\n\nmodule_init(atkbd_init);\nmodule_exit(atkbd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}