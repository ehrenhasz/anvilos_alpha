{
  "module_name": "mcs_touchkey.c",
  "hash_id": "480fa5d712007d1760afdc36f546f6390a4f2ca27a19eecd6efb12c1dd676ce0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/mcs_touchkey.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/platform_data/mcs.h>\n#include <linux/pm.h>\n\n \n#define MCS5000_TOUCHKEY_STATUS\t\t0x04\n#define MCS5000_TOUCHKEY_STATUS_PRESS\t7\n#define MCS5000_TOUCHKEY_FW\t\t0x0a\n#define MCS5000_TOUCHKEY_BASE_VAL\t0x61\n\n \n#define MCS5080_TOUCHKEY_STATUS\t\t0x00\n#define MCS5080_TOUCHKEY_STATUS_PRESS\t3\n#define MCS5080_TOUCHKEY_FW\t\t0x01\n#define MCS5080_TOUCHKEY_BASE_VAL\t0x1\n\nenum mcs_touchkey_type {\n\tMCS5000_TOUCHKEY,\n\tMCS5080_TOUCHKEY,\n};\n\nstruct mcs_touchkey_chip {\n\tunsigned int status_reg;\n\tunsigned int pressbit;\n\tunsigned int press_invert;\n\tunsigned int baseval;\n};\n\nstruct mcs_touchkey_data {\n\tvoid (*poweron)(bool);\n\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct mcs_touchkey_chip chip;\n\tunsigned int key_code;\n\tunsigned int key_val;\n\tunsigned short keycodes[];\n};\n\nstatic irqreturn_t mcs_touchkey_interrupt(int irq, void *dev_id)\n{\n\tstruct mcs_touchkey_data *data = dev_id;\n\tstruct mcs_touchkey_chip *chip = &data->chip;\n\tstruct i2c_client *client = data->client;\n\tstruct input_dev *input = data->input_dev;\n\tunsigned int key_val;\n\tunsigned int pressed;\n\tint val;\n\n\tval = i2c_smbus_read_byte_data(client, chip->status_reg);\n\tif (val < 0) {\n\t\tdev_err(&client->dev, \"i2c read error [%d]\\n\", val);\n\t\tgoto out;\n\t}\n\n\tpressed = (val & (1 << chip->pressbit)) >> chip->pressbit;\n\tif (chip->press_invert)\n\t\tpressed ^= chip->press_invert;\n\n\t \n\tif (pressed) {\n\t\tkey_val = val & (0xff >> (8 - chip->pressbit));\n\t\tif (!key_val)\n\t\t\tgoto out;\n\t\tkey_val -= chip->baseval;\n\t\tdata->key_code = data->keycodes[key_val];\n\t\tdata->key_val = key_val;\n\t}\n\n\tinput_event(input, EV_MSC, MSC_SCAN, data->key_val);\n\tinput_report_key(input, data->key_code, pressed);\n\tinput_sync(input);\n\n\tdev_dbg(&client->dev, \"key %d %d %s\\n\", data->key_val, data->key_code,\n\t\tpressed ? \"pressed\" : \"released\");\n\n out:\n\treturn IRQ_HANDLED;\n}\n\nstatic void mcs_touchkey_poweroff(void *data)\n{\n\tstruct mcs_touchkey_data *touchkey = data;\n\n\ttouchkey->poweron(false);\n}\n\nstatic int mcs_touchkey_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct mcs_platform_data *pdata;\n\tstruct mcs_touchkey_data *data;\n\tstruct input_dev *input_dev;\n\tunsigned int fw_reg;\n\tint fw_ver;\n\tint error;\n\tint i;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"no platform data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(&client->dev,\n\t\t\t    struct_size(data, keycodes, pdata->key_maxval + 1),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->client = client;\n\tdata->input_dev = input_dev;\n\n\tif (id->driver_data == MCS5000_TOUCHKEY) {\n\t\tdata->chip.status_reg = MCS5000_TOUCHKEY_STATUS;\n\t\tdata->chip.pressbit = MCS5000_TOUCHKEY_STATUS_PRESS;\n\t\tdata->chip.baseval = MCS5000_TOUCHKEY_BASE_VAL;\n\t\tfw_reg = MCS5000_TOUCHKEY_FW;\n\t} else {\n\t\tdata->chip.status_reg = MCS5080_TOUCHKEY_STATUS;\n\t\tdata->chip.pressbit = MCS5080_TOUCHKEY_STATUS_PRESS;\n\t\tdata->chip.press_invert = 1;\n\t\tdata->chip.baseval = MCS5080_TOUCHKEY_BASE_VAL;\n\t\tfw_reg = MCS5080_TOUCHKEY_FW;\n\t}\n\n\tfw_ver = i2c_smbus_read_byte_data(client, fw_reg);\n\tif (fw_ver < 0) {\n\t\tdev_err(&client->dev, \"i2c read error[%d]\\n\", fw_ver);\n\t\treturn fw_ver;\n\t}\n\tdev_info(&client->dev, \"Firmware version: %d\\n\", fw_ver);\n\n\tinput_dev->name = \"MELFAS MCS Touchkey\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY);\n\tif (!pdata->no_autorepeat)\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_REP);\n\tinput_dev->keycode = data->keycodes;\n\tinput_dev->keycodesize = sizeof(data->keycodes[0]);\n\tinput_dev->keycodemax = pdata->key_maxval + 1;\n\n\tfor (i = 0; i < pdata->keymap_size; i++) {\n\t\tunsigned int val = MCS_KEY_VAL(pdata->keymap[i]);\n\t\tunsigned int code = MCS_KEY_CODE(pdata->keymap[i]);\n\n\t\tdata->keycodes[val] = code;\n\t\t__set_bit(code, input_dev->keybit);\n\t}\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tinput_set_drvdata(input_dev, data);\n\n\tif (pdata->cfg_pin)\n\t\tpdata->cfg_pin();\n\n\tif (pdata->poweron) {\n\t\tdata->poweron = pdata->poweron;\n\t\tdata->poweron(true);\n\n\t\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t\t mcs_touchkey_poweroff, data);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, mcs_touchkey_interrupt,\n\t\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t  client->dev.driver->name, data);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, data);\n\treturn 0;\n}\n\nstatic void mcs_touchkey_shutdown(struct i2c_client *client)\n{\n\tstruct mcs_touchkey_data *data = i2c_get_clientdata(client);\n\n\tif (data->poweron)\n\t\tdata->poweron(false);\n}\n\nstatic int mcs_touchkey_suspend(struct device *dev)\n{\n\tstruct mcs_touchkey_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\t \n\tdisable_irq(client->irq);\n\n\t \n\tif (data->poweron)\n\t\tdata->poweron(false);\n\n\treturn 0;\n}\n\nstatic int mcs_touchkey_resume(struct device *dev)\n{\n\tstruct mcs_touchkey_data *data = dev_get_drvdata(dev);\n\tstruct i2c_client *client = data->client;\n\n\t \n\tif (data->poweron)\n\t\tdata->poweron(true);\n\n\t \n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mcs_touchkey_pm_ops,\n\t\t\t\tmcs_touchkey_suspend, mcs_touchkey_resume);\n\nstatic const struct i2c_device_id mcs_touchkey_id[] = {\n\t{ \"mcs5000_touchkey\", MCS5000_TOUCHKEY },\n\t{ \"mcs5080_touchkey\", MCS5080_TOUCHKEY },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mcs_touchkey_id);\n\nstatic struct i2c_driver mcs_touchkey_driver = {\n\t.driver = {\n\t\t.name\t= \"mcs_touchkey\",\n\t\t.pm\t= pm_sleep_ptr(&mcs_touchkey_pm_ops),\n\t},\n\t.probe\t\t= mcs_touchkey_probe,\n\t.shutdown       = mcs_touchkey_shutdown,\n\t.id_table\t= mcs_touchkey_id,\n};\n\nmodule_i2c_driver(mcs_touchkey_driver);\n\n \nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_AUTHOR(\"HeungJun Kim <riverful.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"Touchkey driver for MELFAS MCS5000/5080 controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}