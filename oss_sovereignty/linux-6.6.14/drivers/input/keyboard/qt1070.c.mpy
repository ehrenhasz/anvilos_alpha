{
  "module_name": "qt1070.c",
  "hash_id": "935f3c08b2227dc959c2034ceb904004f2cd4c4bdd7d685fd84143160de04333",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/qt1070.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n\n \n#define CHIP_ID            0x00\n#define QT1070_CHIP_ID     0x2E\n\n#define FW_VERSION         0x01\n#define QT1070_FW_VERSION  0x15\n\n#define DET_STATUS         0x02\n\n#define KEY_STATUS         0x03\n\n \n#define CALIBRATE_CMD      0x38\n#define QT1070_CAL_TIME    200\n\n \n#define RESET              0x39\n#define QT1070_RESET_TIME  255\n\n \nstatic const unsigned short qt1070_key2code[] = {\n\tKEY_0, KEY_1, KEY_2, KEY_3,\n\tKEY_4, KEY_5, KEY_6,\n};\n\nstruct qt1070_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tunsigned int irq;\n\tunsigned short keycodes[ARRAY_SIZE(qt1070_key2code)];\n\tu8 last_keys;\n};\n\nstatic int qt1070_read(struct i2c_client *client, u8 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"can not read register, returned %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int qt1070_write(struct i2c_client *client, u8 reg, u8 data)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, reg, data);\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"can not write register, returned %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic bool qt1070_identify(struct i2c_client *client)\n{\n\tint id, ver;\n\n\t \n\tid = qt1070_read(client, CHIP_ID);\n\tif (id != QT1070_CHIP_ID) {\n\t\tdev_err(&client->dev, \"ID %d not supported\\n\", id);\n\t\treturn false;\n\t}\n\n\t \n\tver = qt1070_read(client, FW_VERSION);\n\tif (ver < 0) {\n\t\tdev_err(&client->dev, \"could not read the firmware version\\n\");\n\t\treturn false;\n\t}\n\n\tdev_info(&client->dev, \"AT42QT1070 firmware version %x\\n\", ver);\n\n\treturn true;\n}\n\nstatic irqreturn_t qt1070_interrupt(int irq, void *dev_id)\n{\n\tstruct qt1070_data *data = dev_id;\n\tstruct i2c_client *client = data->client;\n\tstruct input_dev *input = data->input;\n\tint i;\n\tu8 new_keys, keyval, mask = 0x01;\n\n\t \n\tqt1070_read(client, DET_STATUS);\n\n\t \n\tnew_keys = qt1070_read(client, KEY_STATUS);\n\n\tfor (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {\n\t\tkeyval = new_keys & mask;\n\t\tif ((data->last_keys & mask) != keyval)\n\t\t\tinput_report_key(input, data->keycodes[i], keyval);\n\t\tmask <<= 1;\n\t}\n\tinput_sync(input);\n\n\tdata->last_keys = new_keys;\n\treturn IRQ_HANDLED;\n}\n\nstatic int qt1070_probe(struct i2c_client *client)\n{\n\tstruct qt1070_data *data;\n\tstruct input_dev *input;\n\tint i;\n\tint err;\n\n\terr = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE);\n\tif (!err) {\n\t\tdev_err(&client->dev, \"%s adapter not supported\\n\",\n\t\t\tdev_driver_string(&client->adapter->dev));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"please assign the irq to this device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!qt1070_identify(client))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct qt1070_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->input = input;\n\tdata->irq = client->irq;\n\n\tinput->name = \"AT42QT1070 QTouch Sensor\";\n\tinput->id.bustype = BUS_I2C;\n\n\t \n\tinput->keycode = data->keycodes;\n\tinput->keycodesize = sizeof(data->keycodes[0]);\n\tinput->keycodemax = ARRAY_SIZE(qt1070_key2code);\n\n\t__set_bit(EV_KEY, input->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {\n\t\tdata->keycodes[i] = qt1070_key2code[i];\n\t\t__set_bit(qt1070_key2code[i], input->keybit);\n\t}\n\n\t \n\tqt1070_write(client, CALIBRATE_CMD, 1);\n\tmsleep(QT1070_CAL_TIME);\n\n\t \n\tqt1070_write(client, RESET, 1);\n\tmsleep(QT1070_RESET_TIME);\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, qt1070_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_NONE | IRQF_ONESHOT,\n\t\t\t\t\tclient->dev.driver->name, data);\n\tif (err) {\n\t\tdev_err(&client->dev, \"fail to request irq\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = input_register_device(data->input);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to register input device\\n\");\n\t\treturn err;\n\t}\n\n\ti2c_set_clientdata(client, data);\n\n\t \n\tqt1070_read(client, DET_STATUS);\n\n\treturn 0;\n}\n\nstatic int qt1070_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct qt1070_data *data = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(data->irq);\n\n\treturn 0;\n}\n\nstatic int qt1070_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct qt1070_data *data = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(data->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(qt1070_pm_ops, qt1070_suspend, qt1070_resume);\n\nstatic const struct i2c_device_id qt1070_id[] = {\n\t{ \"qt1070\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, qt1070_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id qt1070_of_match[] = {\n\t{ .compatible = \"qt1070\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qt1070_of_match);\n#endif\n\nstatic struct i2c_driver qt1070_driver = {\n\t.driver\t= {\n\t\t.name\t= \"qt1070\",\n\t\t.of_match_table = of_match_ptr(qt1070_of_match),\n\t\t.pm\t= pm_sleep_ptr(&qt1070_pm_ops),\n\t},\n\t.id_table\t= qt1070_id,\n\t.probe\t\t= qt1070_probe,\n};\n\nmodule_i2c_driver(qt1070_driver);\n\nMODULE_AUTHOR(\"Bo Shen <voice.shen@atmel.com>\");\nMODULE_DESCRIPTION(\"Driver for AT42QT1070 QTouch sensor\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}