{
  "module_name": "snvs_pwrkey.c",
  "hash_id": "7cf157c913714f94c48388143e6b8b01a80c9beda0502de64f6ea62b9826a6d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/snvs_pwrkey.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#define SNVS_HPVIDR1_REG\t0xBF8\n#define SNVS_LPSR_REG\t\t0x4C\t \n#define SNVS_LPCR_REG\t\t0x38\t \n#define SNVS_HPSR_REG\t\t0x14\n#define SNVS_HPSR_BTN\t\tBIT(6)\n#define SNVS_LPSR_SPO\t\tBIT(18)\n#define SNVS_LPCR_DEP_EN\tBIT(5)\n\n#define DEBOUNCE_TIME\t\t30\n#define REPEAT_INTERVAL\t\t60\n\nstruct pwrkey_drv_data {\n\tstruct regmap *snvs;\n\tint irq;\n\tint keycode;\n\tint keystate;   \n\tint wakeup;\n\tstruct timer_list check_timer;\n\tstruct input_dev *input;\n\tu8 minor_rev;\n};\n\nstatic void imx_imx_snvs_check_for_events(struct timer_list *t)\n{\n\tstruct pwrkey_drv_data *pdata = from_timer(pdata, t, check_timer);\n\tstruct input_dev *input = pdata->input;\n\tu32 state;\n\n\tregmap_read(pdata->snvs, SNVS_HPSR_REG, &state);\n\tstate = state & SNVS_HPSR_BTN ? 1 : 0;\n\n\t \n\tif (state ^ pdata->keystate) {\n\t\tpdata->keystate = state;\n\t\tinput_event(input, EV_KEY, pdata->keycode, state);\n\t\tinput_sync(input);\n\t\tpm_relax(pdata->input->dev.parent);\n\t}\n\n\t \n\tif (state) {\n\t\tmod_timer(&pdata->check_timer,\n\t\t\t  jiffies + msecs_to_jiffies(REPEAT_INTERVAL));\n\t}\n}\n\nstatic irqreturn_t imx_snvs_pwrkey_interrupt(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct pwrkey_drv_data *pdata = platform_get_drvdata(pdev);\n\tstruct input_dev *input = pdata->input;\n\tu32 lp_status;\n\n\tpm_wakeup_event(input->dev.parent, 0);\n\n\tregmap_read(pdata->snvs, SNVS_LPSR_REG, &lp_status);\n\tif (lp_status & SNVS_LPSR_SPO) {\n\t\tif (pdata->minor_rev == 0) {\n\t\t\t \n\t\t\tinput_report_key(input, pdata->keycode, 1);\n\t\t\tinput_sync(input);\n\t\t\tinput_report_key(input, pdata->keycode, 0);\n\t\t\tinput_sync(input);\n\t\t\tpm_relax(input->dev.parent);\n\t\t} else {\n\t\t\tmod_timer(&pdata->check_timer,\n\t\t\t          jiffies + msecs_to_jiffies(DEBOUNCE_TIME));\n\t\t}\n\t}\n\n\t \n\tregmap_write(pdata->snvs, SNVS_LPSR_REG, SNVS_LPSR_SPO);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void imx_snvs_pwrkey_disable_clk(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void imx_snvs_pwrkey_act(void *pdata)\n{\n\tstruct pwrkey_drv_data *pd = pdata;\n\n\tdel_timer_sync(&pd->check_timer);\n}\n\nstatic int imx_snvs_pwrkey_probe(struct platform_device *pdev)\n{\n\tstruct pwrkey_drv_data *pdata;\n\tstruct input_dev *input;\n\tstruct device_node *np;\n\tstruct clk *clk;\n\tint error;\n\tu32 vid;\n\n\t \n\tnp = pdev->dev.of_node;\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->snvs = syscon_regmap_lookup_by_phandle(np, \"regmap\");\n\tif (IS_ERR(pdata->snvs)) {\n\t\tdev_err(&pdev->dev, \"Can't get snvs syscon\\n\");\n\t\treturn PTR_ERR(pdata->snvs);\n\t}\n\n\tif (of_property_read_u32(np, \"linux,keycode\", &pdata->keycode)) {\n\t\tpdata->keycode = KEY_POWER;\n\t\tdev_warn(&pdev->dev, \"KEY_POWER without setting in dts\\n\");\n\t}\n\n\tclk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get snvs clock (%pe)\\n\", clk);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\terror = clk_prepare_enable(clk);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to enable snvs clock (%pe)\\n\",\n\t\t\tERR_PTR(error));\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t\t imx_snvs_pwrkey_disable_clk, clk);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register clock cleanup handler (%pe)\\n\",\n\t\t\tERR_PTR(error));\n\t\treturn error;\n\t}\n\n\tpdata->wakeup = of_property_read_bool(np, \"wakeup-source\");\n\n\tpdata->irq = platform_get_irq(pdev, 0);\n\tif (pdata->irq < 0)\n\t\treturn -EINVAL;\n\n\tregmap_read(pdata->snvs, SNVS_HPVIDR1_REG, &vid);\n\tpdata->minor_rev = vid & 0xff;\n\n\tregmap_update_bits(pdata->snvs, SNVS_LPCR_REG, SNVS_LPCR_DEP_EN, SNVS_LPCR_DEP_EN);\n\n\t \n\tregmap_write(pdata->snvs, SNVS_LPSR_REG, SNVS_LPSR_SPO);\n\n\ttimer_setup(&pdata->check_timer, imx_imx_snvs_check_for_events, 0);\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate the input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = pdev->name;\n\tinput->phys = \"snvs-pwrkey/input0\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput_set_capability(input, EV_KEY, pdata->keycode);\n\n\t \n\terror = devm_add_action(&pdev->dev, imx_snvs_pwrkey_act, pdata);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register remove action\\n\");\n\t\treturn error;\n\t}\n\n\tpdata->input = input;\n\tplatform_set_drvdata(pdev, pdata);\n\n\terror = devm_request_irq(&pdev->dev, pdata->irq,\n\t\t\t       imx_snvs_pwrkey_interrupt,\n\t\t\t       0, pdev->name, pdev);\n\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"interrupt not available.\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, pdata->wakeup);\n\terror = dev_pm_set_wake_irq(&pdev->dev, pdata->irq);\n\tif (error)\n\t\tdev_err(&pdev->dev, \"irq wake enable failed.\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id imx_snvs_pwrkey_ids[] = {\n\t{ .compatible = \"fsl,sec-v4.0-pwrkey\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_snvs_pwrkey_ids);\n\nstatic struct platform_driver imx_snvs_pwrkey_driver = {\n\t.driver = {\n\t\t.name = \"snvs_pwrkey\",\n\t\t.of_match_table = imx_snvs_pwrkey_ids,\n\t},\n\t.probe = imx_snvs_pwrkey_probe,\n};\nmodule_platform_driver(imx_snvs_pwrkey_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor\");\nMODULE_DESCRIPTION(\"i.MX snvs power key Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}