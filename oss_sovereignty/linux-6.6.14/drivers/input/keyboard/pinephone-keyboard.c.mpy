{
  "module_name": "pinephone-keyboard.c",
  "hash_id": "d649e9195ddb50bc3304d04ea0c6368823e73b45c78b69cc2e3f14550e625500",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/pinephone-keyboard.c",
  "human_readable_source": "\n\n\n\n#include <linux/crc8.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#define DRV_NAME\t\t\t\"pinephone-keyboard\"\n\n#define PPKB_CRC8_POLYNOMIAL\t\t0x07\n\n#define PPKB_DEVICE_ID_HI\t\t0x00\n#define PPKB_DEVICE_ID_HI_VALUE\t\t\t'K'\n#define PPKB_DEVICE_ID_LO\t\t0x01\n#define PPKB_DEVICE_ID_LO_VALUE\t\t\t'B'\n#define PPKB_FW_REVISION\t\t0x02\n#define PPKB_FW_FEATURES\t\t0x03\n#define PPKB_MATRIX_SIZE\t\t0x06\n#define PPKB_SCAN_CRC\t\t\t0x07\n#define PPKB_SCAN_DATA\t\t\t0x08\n#define PPKB_SYS_CONFIG\t\t\t0x20\n#define PPKB_SYS_CONFIG_DISABLE_SCAN\t\tBIT(0)\n#define PPKB_SYS_SMBUS_COMMAND\t\t0x21\n#define PPKB_SYS_SMBUS_DATA\t\t0x22\n#define PPKB_SYS_COMMAND\t\t0x23\n#define PPKB_SYS_COMMAND_SMBUS_READ\t\t0x91\n#define PPKB_SYS_COMMAND_SMBUS_WRITE\t\t0xa1\n\n#define PPKB_ROWS\t\t\t6\n#define PPKB_COLS\t\t\t12\n\n \n#define PPKB_BUF_LEN\t\t\t(1 + PPKB_COLS)\n\nstatic const uint32_t ppkb_keymap[] = {\n\tKEY(0,  0, KEY_ESC),\n\tKEY(0,  1, KEY_1),\n\tKEY(0,  2, KEY_2),\n\tKEY(0,  3, KEY_3),\n\tKEY(0,  4, KEY_4),\n\tKEY(0,  5, KEY_5),\n\tKEY(0,  6, KEY_6),\n\tKEY(0,  7, KEY_7),\n\tKEY(0,  8, KEY_8),\n\tKEY(0,  9, KEY_9),\n\tKEY(0, 10, KEY_0),\n\tKEY(0, 11, KEY_BACKSPACE),\n\n\tKEY(1,  0, KEY_TAB),\n\tKEY(1,  1, KEY_Q),\n\tKEY(1,  2, KEY_W),\n\tKEY(1,  3, KEY_E),\n\tKEY(1,  4, KEY_R),\n\tKEY(1,  5, KEY_T),\n\tKEY(1,  6, KEY_Y),\n\tKEY(1,  7, KEY_U),\n\tKEY(1,  8, KEY_I),\n\tKEY(1,  9, KEY_O),\n\tKEY(1, 10, KEY_P),\n\tKEY(1, 11, KEY_ENTER),\n\n\tKEY(2,  0, KEY_LEFTMETA),\n\tKEY(2,  1, KEY_A),\n\tKEY(2,  2, KEY_S),\n\tKEY(2,  3, KEY_D),\n\tKEY(2,  4, KEY_F),\n\tKEY(2,  5, KEY_G),\n\tKEY(2,  6, KEY_H),\n\tKEY(2,  7, KEY_J),\n\tKEY(2,  8, KEY_K),\n\tKEY(2,  9, KEY_L),\n\tKEY(2, 10, KEY_SEMICOLON),\n\n\tKEY(3,  0, KEY_LEFTSHIFT),\n\tKEY(3,  1, KEY_Z),\n\tKEY(3,  2, KEY_X),\n\tKEY(3,  3, KEY_C),\n\tKEY(3,  4, KEY_V),\n\tKEY(3,  5, KEY_B),\n\tKEY(3,  6, KEY_N),\n\tKEY(3,  7, KEY_M),\n\tKEY(3,  8, KEY_COMMA),\n\tKEY(3,  9, KEY_DOT),\n\tKEY(3, 10, KEY_SLASH),\n\n\tKEY(4,  1, KEY_LEFTCTRL),\n\tKEY(4,  4, KEY_SPACE),\n\tKEY(4,  6, KEY_APOSTROPHE),\n\tKEY(4,  8, KEY_RIGHTBRACE),\n\tKEY(4,  9, KEY_LEFTBRACE),\n\n\tKEY(5,  2, KEY_FN),\n\tKEY(5,  3, KEY_LEFTALT),\n\tKEY(5,  5, KEY_RIGHTALT),\n\n\t \n\tKEY(PPKB_ROWS + 0,  0, KEY_FN_ESC),\n\tKEY(PPKB_ROWS + 0,  1, KEY_F1),\n\tKEY(PPKB_ROWS + 0,  2, KEY_F2),\n\tKEY(PPKB_ROWS + 0,  3, KEY_F3),\n\tKEY(PPKB_ROWS + 0,  4, KEY_F4),\n\tKEY(PPKB_ROWS + 0,  5, KEY_F5),\n\tKEY(PPKB_ROWS + 0,  6, KEY_F6),\n\tKEY(PPKB_ROWS + 0,  7, KEY_F7),\n\tKEY(PPKB_ROWS + 0,  8, KEY_F8),\n\tKEY(PPKB_ROWS + 0,  9, KEY_F9),\n\tKEY(PPKB_ROWS + 0, 10, KEY_F10),\n\tKEY(PPKB_ROWS + 0, 11, KEY_DELETE),\n\n\tKEY(PPKB_ROWS + 1, 10, KEY_PAGEUP),\n\n\tKEY(PPKB_ROWS + 2,  0, KEY_SYSRQ),\n\tKEY(PPKB_ROWS + 2,  9, KEY_PAGEDOWN),\n\tKEY(PPKB_ROWS + 2, 10, KEY_INSERT),\n\n\tKEY(PPKB_ROWS + 3,  0, KEY_LEFTSHIFT),\n\tKEY(PPKB_ROWS + 3,  8, KEY_HOME),\n\tKEY(PPKB_ROWS + 3,  9, KEY_UP),\n\tKEY(PPKB_ROWS + 3, 10, KEY_END),\n\n\tKEY(PPKB_ROWS + 4, 1, KEY_LEFTCTRL),\n\tKEY(PPKB_ROWS + 4, 6, KEY_LEFT),\n\tKEY(PPKB_ROWS + 4, 8, KEY_RIGHT),\n\tKEY(PPKB_ROWS + 4, 9, KEY_DOWN),\n\n\tKEY(PPKB_ROWS + 5, 3, KEY_LEFTALT),\n\tKEY(PPKB_ROWS + 5, 5, KEY_RIGHTALT),\n};\n\nstatic const struct matrix_keymap_data ppkb_keymap_data = {\n\t.keymap\t\t= ppkb_keymap,\n\t.keymap_size\t= ARRAY_SIZE(ppkb_keymap),\n};\n\nstruct pinephone_keyboard {\n\tstruct i2c_adapter adapter;\n\tstruct input_dev *input;\n\tu8 buf[2][PPKB_BUF_LEN];\n\tu8 crc_table[CRC8_TABLE_SIZE];\n\tu8 fn_state[PPKB_COLS];\n\tbool buf_swap;\n\tbool fn_pressed;\n};\n\nstatic int ppkb_adap_smbus_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\tstruct i2c_client *client = adap->algo_data;\n\tu8 buf[3];\n\tint ret;\n\n\tbuf[0] = command;\n\tbuf[1] = data->byte;\n\tbuf[2] = read_write == I2C_SMBUS_READ ? PPKB_SYS_COMMAND_SMBUS_READ\n\t\t\t\t\t      : PPKB_SYS_COMMAND_SMBUS_WRITE;\n\n\tret = i2c_smbus_write_i2c_block_data(client, PPKB_SYS_SMBUS_COMMAND,\n\t\t\t\t\t     sizeof(buf), buf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\tusleep_range(300, 500);\n\t\tret = i2c_smbus_read_byte_data(client, PPKB_SYS_COMMAND);\n\t} while (ret == buf[2]);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tif (ret)\n\t\treturn -EIO;\n\n\tif (read_write == I2C_SMBUS_READ) {\n\t\tret = i2c_smbus_read_byte_data(client, PPKB_SYS_SMBUS_DATA);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->byte = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 ppkg_adap_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_BYTE_DATA;\n}\n\nstatic const struct i2c_algorithm ppkb_adap_algo = {\n\t.smbus_xfer\t\t= ppkb_adap_smbus_xfer,\n\t.functionality\t\t= ppkg_adap_functionality,\n};\n\nstatic void ppkb_update(struct i2c_client *client)\n{\n\tstruct pinephone_keyboard *ppkb = i2c_get_clientdata(client);\n\tunsigned short *keymap = ppkb->input->keycode;\n\tint row_shift = get_count_order(PPKB_COLS);\n\tu8 *old_buf = ppkb->buf[!ppkb->buf_swap];\n\tu8 *new_buf = ppkb->buf[ppkb->buf_swap];\n\tint col, crc, ret, row;\n\tstruct device *dev = &client->dev;\n\n\tret = i2c_smbus_read_i2c_block_data(client, PPKB_SCAN_CRC,\n\t\t\t\t\t    PPKB_BUF_LEN, new_buf);\n\tif (ret != PPKB_BUF_LEN) {\n\t\tdev_err(dev, \"Failed to read scan data: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tcrc = crc8(ppkb->crc_table, &new_buf[1], PPKB_COLS, CRC8_INIT_VALUE);\n\tif (crc != new_buf[0]) {\n\t\tdev_err(dev, \"Bad scan data (%02x != %02x)\\n\", crc, new_buf[0]);\n\t\treturn;\n\t}\n\n\tppkb->buf_swap = !ppkb->buf_swap;\n\n\tfor (col = 0; col < PPKB_COLS; ++col) {\n\t\tu8 old = old_buf[1 + col];\n\t\tu8 new = new_buf[1 + col];\n\t\tu8 changed = old ^ new;\n\n\t\tif (!changed)\n\t\t\tcontinue;\n\n\t\tfor (row = 0; row < PPKB_ROWS; ++row) {\n\t\t\tu8 mask = BIT(row);\n\t\t\tu8 value = new & mask;\n\t\t\tunsigned short code;\n\t\t\tbool fn_state;\n\n\t\t\tif (!(changed & mask))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfn_state = value ? ppkb->fn_pressed : ppkb->fn_state[col] & mask;\n\t\t\tif (fn_state)\n\t\t\t\tppkb->fn_state[col] ^= mask;\n\n\t\t\t \n\t\t\tcode = MATRIX_SCAN_CODE(fn_state ? PPKB_ROWS + row : row,\n\t\t\t\t\t\tcol, row_shift);\n\t\t\tinput_event(ppkb->input, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(ppkb->input, keymap[code], value);\n\t\t\tif (keymap[code] == KEY_FN)\n\t\t\t\tppkb->fn_pressed = value;\n\t\t}\n\t}\n\tinput_sync(ppkb->input);\n}\n\nstatic irqreturn_t ppkb_irq_thread(int irq, void *data)\n{\n\tstruct i2c_client *client = data;\n\n\tppkb_update(client);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ppkb_set_scan(struct i2c_client *client, bool enable)\n{\n\tstruct device *dev = &client->dev;\n\tint ret, val;\n\n\tret = i2c_smbus_read_byte_data(client, PPKB_SYS_CONFIG);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (enable)\n\t\tval = ret & ~PPKB_SYS_CONFIG_DISABLE_SCAN;\n\telse\n\t\tval = ret | PPKB_SYS_CONFIG_DISABLE_SCAN;\n\n\tret = i2c_smbus_write_byte_data(client, PPKB_SYS_CONFIG, val);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to write config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ppkb_open(struct input_dev *input)\n{\n\tstruct i2c_client *client = input_get_drvdata(input);\n\tint error;\n\n\terror = ppkb_set_scan(client, true);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic void ppkb_close(struct input_dev *input)\n{\n\tstruct i2c_client *client = input_get_drvdata(input);\n\n\tppkb_set_scan(client, false);\n}\n\nstatic int ppkb_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tunsigned int phys_rows, phys_cols;\n\tstruct pinephone_keyboard *ppkb;\n\tu8 info[PPKB_MATRIX_SIZE + 1];\n\tstruct device_node *i2c_bus;\n\tint ret;\n\tint error;\n\n\terror = devm_regulator_get_enable(dev, \"vbat\");\n\tif (error) {\n\t\tdev_err(dev, \"Failed to get VBAT supply: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tret = i2c_smbus_read_i2c_block_data(client, 0, sizeof(info), info);\n\tif (ret != sizeof(info)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(dev, \"Failed to read device ID: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (info[PPKB_DEVICE_ID_HI] != PPKB_DEVICE_ID_HI_VALUE ||\n\t    info[PPKB_DEVICE_ID_LO] != PPKB_DEVICE_ID_LO_VALUE) {\n\t\tdev_warn(dev, \"Unexpected device ID: %#02x %#02x\\n\",\n\t\t\t info[PPKB_DEVICE_ID_HI], info[PPKB_DEVICE_ID_LO]);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev, \"Found firmware version %d.%d features %#x\\n\",\n\t\t info[PPKB_FW_REVISION] >> 4,\n\t\t info[PPKB_FW_REVISION] & 0xf,\n\t\t info[PPKB_FW_FEATURES]);\n\n\tphys_rows = info[PPKB_MATRIX_SIZE] & 0xf;\n\tphys_cols = info[PPKB_MATRIX_SIZE] >> 4;\n\tif (phys_rows != PPKB_ROWS || phys_cols != PPKB_COLS) {\n\t\tdev_err(dev, \"Unexpected keyboard size %ux%u\\n\",\n\t\t\tphys_rows, phys_cols);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terror = ppkb_set_scan(client, false);\n\tif (error)\n\t\treturn error;\n\n\tppkb = devm_kzalloc(dev, sizeof(*ppkb), GFP_KERNEL);\n\tif (!ppkb)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ppkb);\n\n\ti2c_bus = of_get_child_by_name(dev->of_node, \"i2c\");\n\tif (i2c_bus) {\n\t\tppkb->adapter.owner = THIS_MODULE;\n\t\tppkb->adapter.algo = &ppkb_adap_algo;\n\t\tppkb->adapter.algo_data = client;\n\t\tppkb->adapter.dev.parent = dev;\n\t\tppkb->adapter.dev.of_node = i2c_bus;\n\t\tstrscpy(ppkb->adapter.name, DRV_NAME, sizeof(ppkb->adapter.name));\n\n\t\terror = devm_i2c_add_adapter(dev, &ppkb->adapter);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Failed to add I2C adapter: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tcrc8_populate_msb(ppkb->crc_table, PPKB_CRC8_POLYNOMIAL);\n\n\tppkb->input = devm_input_allocate_device(dev);\n\tif (!ppkb->input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(ppkb->input, client);\n\n\tppkb->input->name = \"PinePhone Keyboard\";\n\tppkb->input->phys = DRV_NAME \"/input0\";\n\tppkb->input->id.bustype = BUS_I2C;\n\tppkb->input->open = ppkb_open;\n\tppkb->input->close = ppkb_close;\n\n\tinput_set_capability(ppkb->input, EV_MSC, MSC_SCAN);\n\t__set_bit(EV_REP, ppkb->input->evbit);\n\n\terror = matrix_keypad_build_keymap(&ppkb_keymap_data, NULL,\n\t\t\t\t\t   2 * PPKB_ROWS, PPKB_COLS, NULL,\n\t\t\t\t\t   ppkb->input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to build keymap: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ppkb->input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, ppkb_irq_thread,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, client);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ppkb_of_match[] = {\n\t{ .compatible = \"pine64,pinephone-keyboard\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ppkb_of_match);\n\nstatic struct i2c_driver ppkb_driver = {\n\t.probe\t\t= ppkb_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table = ppkb_of_match,\n\t},\n};\nmodule_i2c_driver(ppkb_driver);\n\nMODULE_AUTHOR(\"Samuel Holland <samuel@sholland.org>\");\nMODULE_DESCRIPTION(\"Pine64 PinePhone keyboard driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}