{
  "module_name": "goldfish_events.c",
  "hash_id": "bfad0eee10ac0c5eb32f965a32abe3be46292eeb0585a30ea7c8e4af810b4161",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/goldfish_events.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n\nenum {\n\tREG_READ        = 0x00,\n\tREG_SET_PAGE    = 0x00,\n\tREG_LEN         = 0x04,\n\tREG_DATA        = 0x08,\n\n\tPAGE_NAME       = 0x00000,\n\tPAGE_EVBITS     = 0x10000,\n\tPAGE_ABSDATA    = 0x20000 | EV_ABS,\n};\n\nstruct event_dev {\n\tstruct input_dev *input;\n\tint irq;\n\tvoid __iomem *addr;\n\tchar name[];\n};\n\nstatic irqreturn_t events_interrupt(int irq, void *dev_id)\n{\n\tstruct event_dev *edev = dev_id;\n\tunsigned int type, code, value;\n\n\ttype = __raw_readl(edev->addr + REG_READ);\n\tcode = __raw_readl(edev->addr + REG_READ);\n\tvalue = __raw_readl(edev->addr + REG_READ);\n\n\tinput_event(edev->input, type, code, value);\n\tinput_sync(edev->input);\n\treturn IRQ_HANDLED;\n}\n\nstatic void events_import_bits(struct event_dev *edev,\n\t\t\tunsigned long bits[], unsigned int type, size_t count)\n{\n\tvoid __iomem *addr = edev->addr;\n\tint i, j;\n\tsize_t size;\n\tuint8_t val;\n\n\t__raw_writel(PAGE_EVBITS | type, addr + REG_SET_PAGE);\n\n\tsize = __raw_readl(addr + REG_LEN) * 8;\n\tif (size < count)\n\t\tcount = size;\n\n\taddr += REG_DATA;\n\tfor (i = 0; i < count; i += 8) {\n\t\tval = __raw_readb(addr++);\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tif (val & 1 << j)\n\t\t\t\tset_bit(i + j, bits);\n\t}\n}\n\nstatic void events_import_abs_params(struct event_dev *edev)\n{\n\tstruct input_dev *input_dev = edev->input;\n\tvoid __iomem *addr = edev->addr;\n\tu32 val[4];\n\tint count;\n\tint i, j;\n\n\t__raw_writel(PAGE_ABSDATA, addr + REG_SET_PAGE);\n\n\tcount = __raw_readl(addr + REG_LEN) / sizeof(val);\n\tif (count > ABS_MAX)\n\t\tcount = ABS_MAX;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!test_bit(i, input_dev->absbit))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(val); j++) {\n\t\t\tint offset = (i * ARRAY_SIZE(val) + j) * sizeof(u32);\n\n\t\t\tval[j] = __raw_readl(edev->addr + REG_DATA + offset);\n\t\t}\n\n\t\tinput_set_abs_params(input_dev, i,\n\t\t\t\t     val[0], val[1], val[2], val[3]);\n\t}\n}\n\nstatic int events_probe(struct platform_device *pdev)\n{\n\tstruct input_dev *input_dev;\n\tstruct event_dev *edev;\n\tstruct resource *res;\n\tunsigned int keymapnamelen;\n\tvoid __iomem *addr;\n\tint irq;\n\tint i;\n\tint error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\taddr = devm_ioremap(&pdev->dev, res->start, 4096);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\t__raw_writel(PAGE_NAME, addr + REG_SET_PAGE);\n\tkeymapnamelen = __raw_readl(addr + REG_LEN);\n\n\tedev = devm_kzalloc(&pdev->dev,\n\t\t\t    sizeof(struct event_dev) + keymapnamelen + 1,\n\t\t\t    GFP_KERNEL);\n\tif (!edev)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tedev->input = input_dev;\n\tedev->addr = addr;\n\tedev->irq = irq;\n\n\tfor (i = 0; i < keymapnamelen; i++)\n\t\tedev->name[i] = __raw_readb(edev->addr + REG_DATA + i);\n\n\tpr_debug(\"%s: keymap=%s\\n\", __func__, edev->name);\n\n\tinput_dev->name = edev->name;\n\tinput_dev->id.bustype = BUS_HOST;\n\n\tevents_import_bits(edev, input_dev->evbit, EV_SYN, EV_MAX);\n\tevents_import_bits(edev, input_dev->keybit, EV_KEY, KEY_MAX);\n\tevents_import_bits(edev, input_dev->relbit, EV_REL, REL_MAX);\n\tevents_import_bits(edev, input_dev->absbit, EV_ABS, ABS_MAX);\n\tevents_import_bits(edev, input_dev->mscbit, EV_MSC, MSC_MAX);\n\tevents_import_bits(edev, input_dev->ledbit, EV_LED, LED_MAX);\n\tevents_import_bits(edev, input_dev->sndbit, EV_SND, SND_MAX);\n\tevents_import_bits(edev, input_dev->ffbit, EV_FF, FF_MAX);\n\tevents_import_bits(edev, input_dev->swbit, EV_SW, SW_MAX);\n\n\tevents_import_abs_params(edev);\n\n\terror = devm_request_irq(&pdev->dev, edev->irq, events_interrupt, 0,\n\t\t\t\t \"goldfish-events-keypad\", edev);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id goldfish_events_of_match[] = {\n\t{ .compatible = \"google,goldfish-events-keypad\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, goldfish_events_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id goldfish_events_acpi_match[] = {\n\t{ \"GFSH0002\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, goldfish_events_acpi_match);\n#endif\n\nstatic struct platform_driver events_driver = {\n\t.probe\t= events_probe,\n\t.driver\t= {\n\t\t.name\t= \"goldfish_events\",\n\t\t.of_match_table = goldfish_events_of_match,\n\t\t.acpi_match_table = ACPI_PTR(goldfish_events_acpi_match),\n\t},\n};\n\nmodule_platform_driver(events_driver);\n\nMODULE_AUTHOR(\"Brian Swetland\");\nMODULE_DESCRIPTION(\"Goldfish Event Device\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}