{
  "module_name": "matrix_keypad.c",
  "hash_id": "ba81b3a59d594cf68bfb571d44ced4f1c8ed113f0fc83318642272f108fb1ea9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/matrix_keypad.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/gpio.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_platform.h>\n\nstruct matrix_keypad {\n\tconst struct matrix_keypad_platform_data *pdata;\n\tstruct input_dev *input_dev;\n\tunsigned int row_shift;\n\n\tDECLARE_BITMAP(disabled_gpios, MATRIX_MAX_ROWS);\n\n\tuint32_t last_key_state[MATRIX_MAX_COLS];\n\tstruct delayed_work work;\n\tspinlock_t lock;\n\tbool scan_pending;\n\tbool stopped;\n\tbool gpio_all_disabled;\n};\n\n \nstatic void __activate_col(const struct matrix_keypad_platform_data *pdata,\n\t\t\t   int col, bool on)\n{\n\tbool level_on = !pdata->active_low;\n\n\tif (on) {\n\t\tgpio_direction_output(pdata->col_gpios[col], level_on);\n\t} else {\n\t\tgpio_set_value_cansleep(pdata->col_gpios[col], !level_on);\n\t\tif (!pdata->drive_inactive_cols)\n\t\t\tgpio_direction_input(pdata->col_gpios[col]);\n\t}\n}\n\nstatic void activate_col(const struct matrix_keypad_platform_data *pdata,\n\t\t\t int col, bool on)\n{\n\t__activate_col(pdata, col, on);\n\n\tif (on && pdata->col_scan_delay_us)\n\t\tudelay(pdata->col_scan_delay_us);\n}\n\nstatic void activate_all_cols(const struct matrix_keypad_platform_data *pdata,\n\t\t\t      bool on)\n{\n\tint col;\n\n\tfor (col = 0; col < pdata->num_col_gpios; col++)\n\t\t__activate_col(pdata, col, on);\n}\n\nstatic bool row_asserted(const struct matrix_keypad_platform_data *pdata,\n\t\t\t int row)\n{\n\treturn gpio_get_value_cansleep(pdata->row_gpios[row]) ?\n\t\t\t!pdata->active_low : pdata->active_low;\n}\n\nstatic void enable_row_irqs(struct matrix_keypad *keypad)\n{\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tint i;\n\n\tif (pdata->clustered_irq > 0)\n\t\tenable_irq(pdata->clustered_irq);\n\telse {\n\t\tfor (i = 0; i < pdata->num_row_gpios; i++)\n\t\t\tenable_irq(gpio_to_irq(pdata->row_gpios[i]));\n\t}\n}\n\nstatic void disable_row_irqs(struct matrix_keypad *keypad)\n{\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tint i;\n\n\tif (pdata->clustered_irq > 0)\n\t\tdisable_irq_nosync(pdata->clustered_irq);\n\telse {\n\t\tfor (i = 0; i < pdata->num_row_gpios; i++)\n\t\t\tdisable_irq_nosync(gpio_to_irq(pdata->row_gpios[i]));\n\t}\n}\n\n \nstatic void matrix_keypad_scan(struct work_struct *work)\n{\n\tstruct matrix_keypad *keypad =\n\t\tcontainer_of(work, struct matrix_keypad, work.work);\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tconst unsigned short *keycodes = input_dev->keycode;\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tuint32_t new_state[MATRIX_MAX_COLS];\n\tint row, col, code;\n\n\t \n\tactivate_all_cols(pdata, false);\n\n\tmemset(new_state, 0, sizeof(new_state));\n\n\tfor (row = 0; row < pdata->num_row_gpios; row++)\n\t\tgpio_direction_input(pdata->row_gpios[row]);\n\n\t \n\tfor (col = 0; col < pdata->num_col_gpios; col++) {\n\n\t\tactivate_col(pdata, col, true);\n\n\t\tfor (row = 0; row < pdata->num_row_gpios; row++)\n\t\t\tnew_state[col] |=\n\t\t\t\trow_asserted(pdata, row) ? (1 << row) : 0;\n\n\t\tactivate_col(pdata, col, false);\n\t}\n\n\tfor (col = 0; col < pdata->num_col_gpios; col++) {\n\t\tuint32_t bits_changed;\n\n\t\tbits_changed = keypad->last_key_state[col] ^ new_state[col];\n\t\tif (bits_changed == 0)\n\t\t\tcontinue;\n\n\t\tfor (row = 0; row < pdata->num_row_gpios; row++) {\n\t\t\tif ((bits_changed & (1 << row)) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\n\t\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(input_dev,\n\t\t\t\t\t keycodes[code],\n\t\t\t\t\t new_state[col] & (1 << row));\n\t\t}\n\t}\n\tinput_sync(input_dev);\n\n\tmemcpy(keypad->last_key_state, new_state, sizeof(new_state));\n\n\tactivate_all_cols(pdata, true);\n\n\t \n\tspin_lock_irq(&keypad->lock);\n\tkeypad->scan_pending = false;\n\tenable_row_irqs(keypad);\n\tspin_unlock_irq(&keypad->lock);\n}\n\nstatic irqreturn_t matrix_keypad_interrupt(int irq, void *id)\n{\n\tstruct matrix_keypad *keypad = id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&keypad->lock, flags);\n\n\t \n\tif (unlikely(keypad->scan_pending || keypad->stopped))\n\t\tgoto out;\n\n\tdisable_row_irqs(keypad);\n\tkeypad->scan_pending = true;\n\tschedule_delayed_work(&keypad->work,\n\t\tmsecs_to_jiffies(keypad->pdata->debounce_ms));\n\nout:\n\tspin_unlock_irqrestore(&keypad->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int matrix_keypad_start(struct input_dev *dev)\n{\n\tstruct matrix_keypad *keypad = input_get_drvdata(dev);\n\n\tkeypad->stopped = false;\n\tmb();\n\n\t \n\tschedule_delayed_work(&keypad->work, 0);\n\n\treturn 0;\n}\n\nstatic void matrix_keypad_stop(struct input_dev *dev)\n{\n\tstruct matrix_keypad *keypad = input_get_drvdata(dev);\n\n\tspin_lock_irq(&keypad->lock);\n\tkeypad->stopped = true;\n\tspin_unlock_irq(&keypad->lock);\n\n\tflush_delayed_work(&keypad->work);\n\t \n\tdisable_row_irqs(keypad);\n}\n\nstatic void matrix_keypad_enable_wakeup(struct matrix_keypad *keypad)\n{\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tunsigned int gpio;\n\tint i;\n\n\tif (pdata->clustered_irq > 0) {\n\t\tif (enable_irq_wake(pdata->clustered_irq) == 0)\n\t\t\tkeypad->gpio_all_disabled = true;\n\t} else {\n\n\t\tfor (i = 0; i < pdata->num_row_gpios; i++) {\n\t\t\tif (!test_bit(i, keypad->disabled_gpios)) {\n\t\t\t\tgpio = pdata->row_gpios[i];\n\n\t\t\t\tif (enable_irq_wake(gpio_to_irq(gpio)) == 0)\n\t\t\t\t\t__set_bit(i, keypad->disabled_gpios);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void matrix_keypad_disable_wakeup(struct matrix_keypad *keypad)\n{\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tunsigned int gpio;\n\tint i;\n\n\tif (pdata->clustered_irq > 0) {\n\t\tif (keypad->gpio_all_disabled) {\n\t\t\tdisable_irq_wake(pdata->clustered_irq);\n\t\t\tkeypad->gpio_all_disabled = false;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < pdata->num_row_gpios; i++) {\n\t\t\tif (test_and_clear_bit(i, keypad->disabled_gpios)) {\n\t\t\t\tgpio = pdata->row_gpios[i];\n\t\t\t\tdisable_irq_wake(gpio_to_irq(gpio));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int matrix_keypad_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct matrix_keypad *keypad = platform_get_drvdata(pdev);\n\n\tmatrix_keypad_stop(keypad->input_dev);\n\n\tif (device_may_wakeup(&pdev->dev))\n\t\tmatrix_keypad_enable_wakeup(keypad);\n\n\treturn 0;\n}\n\nstatic int matrix_keypad_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct matrix_keypad *keypad = platform_get_drvdata(pdev);\n\n\tif (device_may_wakeup(&pdev->dev))\n\t\tmatrix_keypad_disable_wakeup(keypad);\n\n\tmatrix_keypad_start(keypad->input_dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(matrix_keypad_pm_ops,\n\t\t\t\tmatrix_keypad_suspend, matrix_keypad_resume);\n\nstatic int matrix_keypad_init_gpio(struct platform_device *pdev,\n\t\t\t\t   struct matrix_keypad *keypad)\n{\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tint i, err;\n\n\t \n\tfor (i = 0; i < pdata->num_col_gpios; i++) {\n\t\terr = gpio_request(pdata->col_gpios[i], \"matrix_kbd_col\");\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to request GPIO%d for COL%d\\n\",\n\t\t\t\tpdata->col_gpios[i], i);\n\t\t\tgoto err_free_cols;\n\t\t}\n\n\t\tgpio_direction_output(pdata->col_gpios[i], !pdata->active_low);\n\t}\n\n\tfor (i = 0; i < pdata->num_row_gpios; i++) {\n\t\terr = gpio_request(pdata->row_gpios[i], \"matrix_kbd_row\");\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to request GPIO%d for ROW%d\\n\",\n\t\t\t\tpdata->row_gpios[i], i);\n\t\t\tgoto err_free_rows;\n\t\t}\n\n\t\tgpio_direction_input(pdata->row_gpios[i]);\n\t}\n\n\tif (pdata->clustered_irq > 0) {\n\t\terr = request_any_context_irq(pdata->clustered_irq,\n\t\t\t\tmatrix_keypad_interrupt,\n\t\t\t\tpdata->clustered_irq_flags,\n\t\t\t\t\"matrix-keypad\", keypad);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unable to acquire clustered interrupt\\n\");\n\t\t\tgoto err_free_rows;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < pdata->num_row_gpios; i++) {\n\t\t\terr = request_any_context_irq(\n\t\t\t\t\tgpio_to_irq(pdata->row_gpios[i]),\n\t\t\t\t\tmatrix_keypad_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\t\"matrix-keypad\", keypad);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Unable to acquire interrupt for GPIO line %i\\n\",\n\t\t\t\t\tpdata->row_gpios[i]);\n\t\t\t\tgoto err_free_irqs;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdisable_row_irqs(keypad);\n\treturn 0;\n\nerr_free_irqs:\n\twhile (--i >= 0)\n\t\tfree_irq(gpio_to_irq(pdata->row_gpios[i]), keypad);\n\ti = pdata->num_row_gpios;\nerr_free_rows:\n\twhile (--i >= 0)\n\t\tgpio_free(pdata->row_gpios[i]);\n\ti = pdata->num_col_gpios;\nerr_free_cols:\n\twhile (--i >= 0)\n\t\tgpio_free(pdata->col_gpios[i]);\n\n\treturn err;\n}\n\nstatic void matrix_keypad_free_gpio(struct matrix_keypad *keypad)\n{\n\tconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\n\tint i;\n\n\tif (pdata->clustered_irq > 0) {\n\t\tfree_irq(pdata->clustered_irq, keypad);\n\t} else {\n\t\tfor (i = 0; i < pdata->num_row_gpios; i++)\n\t\t\tfree_irq(gpio_to_irq(pdata->row_gpios[i]), keypad);\n\t}\n\n\tfor (i = 0; i < pdata->num_row_gpios; i++)\n\t\tgpio_free(pdata->row_gpios[i]);\n\n\tfor (i = 0; i < pdata->num_col_gpios; i++)\n\t\tgpio_free(pdata->col_gpios[i]);\n}\n\n#ifdef CONFIG_OF\nstatic struct matrix_keypad_platform_data *\nmatrix_keypad_parse_dt(struct device *dev)\n{\n\tstruct matrix_keypad_platform_data *pdata;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int *gpios;\n\tint ret, i, nrow, ncol;\n\n\tif (!np) {\n\t\tdev_err(dev, \"device lacks DT data\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tdev_err(dev, \"could not allocate memory for platform data\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tpdata->num_row_gpios = nrow = gpiod_count(dev, \"row\");\n\tpdata->num_col_gpios = ncol = gpiod_count(dev, \"col\");\n\tif (nrow < 0 || ncol < 0) {\n\t\tdev_err(dev, \"number of keypad rows/columns not specified\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata->no_autorepeat = of_property_read_bool(np, \"linux,no-autorepeat\");\n\n\tpdata->wakeup = of_property_read_bool(np, \"wakeup-source\") ||\n\t\t\tof_property_read_bool(np, \"linux,wakeup\");  \n\n\tpdata->active_low = of_property_read_bool(np, \"gpio-activelow\");\n\n\tpdata->drive_inactive_cols =\n\t\tof_property_read_bool(np, \"drive-inactive-cols\");\n\n\tof_property_read_u32(np, \"debounce-delay-ms\", &pdata->debounce_ms);\n\tof_property_read_u32(np, \"col-scan-delay-us\",\n\t\t\t\t\t\t&pdata->col_scan_delay_us);\n\n\tgpios = devm_kcalloc(dev,\n\t\t\t     pdata->num_row_gpios + pdata->num_col_gpios,\n\t\t\t     sizeof(unsigned int),\n\t\t\t     GFP_KERNEL);\n\tif (!gpios) {\n\t\tdev_err(dev, \"could not allocate memory for gpios\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < nrow; i++) {\n\t\tret = of_get_named_gpio(np, \"row-gpios\", i);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t\tgpios[i] = ret;\n\t}\n\n\tfor (i = 0; i < ncol; i++) {\n\t\tret = of_get_named_gpio(np, \"col-gpios\", i);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t\tgpios[nrow + i] = ret;\n\t}\n\n\tpdata->row_gpios = gpios;\n\tpdata->col_gpios = &gpios[pdata->num_row_gpios];\n\n\treturn pdata;\n}\n#else\nstatic inline struct matrix_keypad_platform_data *\nmatrix_keypad_parse_dt(struct device *dev)\n{\n\tdev_err(dev, \"no platform data defined\\n\");\n\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\nstatic int matrix_keypad_probe(struct platform_device *pdev)\n{\n\tconst struct matrix_keypad_platform_data *pdata;\n\tstruct matrix_keypad *keypad;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tpdata = matrix_keypad_parse_dt(&pdev->dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t} else if (!pdata->keymap_data) {\n\t\tdev_err(&pdev->dev, \"no keymap data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkeypad = kzalloc(sizeof(struct matrix_keypad), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!keypad || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tkeypad->input_dev = input_dev;\n\tkeypad->pdata = pdata;\n\tkeypad->row_shift = get_count_order(pdata->num_col_gpios);\n\tkeypad->stopped = true;\n\tINIT_DELAYED_WORK(&keypad->work, matrix_keypad_scan);\n\tspin_lock_init(&keypad->lock);\n\n\tinput_dev->name\t\t= pdev->name;\n\tinput_dev->id.bustype\t= BUS_HOST;\n\tinput_dev->dev.parent\t= &pdev->dev;\n\tinput_dev->open\t\t= matrix_keypad_start;\n\tinput_dev->close\t= matrix_keypad_stop;\n\n\terr = matrix_keypad_build_keymap(pdata->keymap_data, NULL,\n\t\t\t\t\t pdata->num_row_gpios,\n\t\t\t\t\t pdata->num_col_gpios,\n\t\t\t\t\t NULL, input_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\tif (!pdata->no_autorepeat)\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tinput_set_drvdata(input_dev, keypad);\n\n\terr = matrix_keypad_init_gpio(pdev, keypad);\n\tif (err)\n\t\tgoto err_free_mem;\n\n\terr = input_register_device(keypad->input_dev);\n\tif (err)\n\t\tgoto err_free_gpio;\n\n\tdevice_init_wakeup(&pdev->dev, pdata->wakeup);\n\tplatform_set_drvdata(pdev, keypad);\n\n\treturn 0;\n\nerr_free_gpio:\n\tmatrix_keypad_free_gpio(keypad);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(keypad);\n\treturn err;\n}\n\nstatic int matrix_keypad_remove(struct platform_device *pdev)\n{\n\tstruct matrix_keypad *keypad = platform_get_drvdata(pdev);\n\n\tmatrix_keypad_free_gpio(keypad);\n\tinput_unregister_device(keypad->input_dev);\n\tkfree(keypad);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id matrix_keypad_dt_match[] = {\n\t{ .compatible = \"gpio-matrix-keypad\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, matrix_keypad_dt_match);\n#endif\n\nstatic struct platform_driver matrix_keypad_driver = {\n\t.probe\t\t= matrix_keypad_probe,\n\t.remove\t\t= matrix_keypad_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"matrix-keypad\",\n\t\t.pm\t= pm_sleep_ptr(&matrix_keypad_pm_ops),\n\t\t.of_match_table = of_match_ptr(matrix_keypad_dt_match),\n\t},\n};\nmodule_platform_driver(matrix_keypad_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut@gmail.com>\");\nMODULE_DESCRIPTION(\"GPIO Driven Matrix Keypad Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:matrix-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}