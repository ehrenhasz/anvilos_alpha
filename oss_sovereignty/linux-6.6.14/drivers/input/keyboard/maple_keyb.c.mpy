{
  "module_name": "maple_keyb.c",
  "hash_id": "bd5670b5eaa54474da49bac078e22166cd59cdb3356cde5362bbf110963ee20d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/maple_keyb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/maple.h>\n\n \nstatic DEFINE_MUTEX(maple_keyb_mutex);\n\n#define NR_SCANCODES 256\n\nMODULE_AUTHOR(\"Adrian McMenamin <adrian@mcmen.demon.co.uk\");\nMODULE_DESCRIPTION(\"SEGA Dreamcast keyboard driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct dc_kbd {\n\tstruct input_dev *dev;\n\tunsigned short keycode[NR_SCANCODES];\n\tunsigned char new[8];\n\tunsigned char old[8];\n};\n\nstatic const unsigned short dc_kbd_keycode[NR_SCANCODES] = {\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_A, KEY_B,\n\tKEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L,\n\tKEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V,\n\tKEY_W, KEY_X, KEY_Y, KEY_Z, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6,\n\tKEY_7, KEY_8, KEY_9, KEY_0, KEY_ENTER, KEY_ESC, KEY_BACKSPACE,\n\tKEY_TAB, KEY_SPACE, KEY_MINUS, KEY_EQUAL, KEY_LEFTBRACE,\n\tKEY_RIGHTBRACE, KEY_BACKSLASH, KEY_BACKSLASH, KEY_SEMICOLON,\n\tKEY_APOSTROPHE, KEY_GRAVE, KEY_COMMA, KEY_DOT, KEY_SLASH,\n\tKEY_CAPSLOCK, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6,\n\tKEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_SYSRQ,\n\tKEY_SCROLLLOCK, KEY_PAUSE, KEY_INSERT, KEY_HOME, KEY_PAGEUP,\n\tKEY_DELETE, KEY_END, KEY_PAGEDOWN, KEY_RIGHT, KEY_LEFT, KEY_DOWN,\n\tKEY_UP, KEY_NUMLOCK, KEY_KPSLASH, KEY_KPASTERISK, KEY_KPMINUS,\n\tKEY_KPPLUS, KEY_KPENTER, KEY_KP1, KEY_KP2, KEY_KP3, KEY_KP4, KEY_KP5,\n\tKEY_KP6, KEY_KP7, KEY_KP8, KEY_KP9, KEY_KP0, KEY_KPDOT, KEY_102ND,\n\tKEY_COMPOSE, KEY_POWER, KEY_KPEQUAL, KEY_F13, KEY_F14, KEY_F15,\n\tKEY_F16, KEY_F17, KEY_F18, KEY_F19, KEY_F20, KEY_F21, KEY_F22,\n\tKEY_F23, KEY_F24, KEY_OPEN, KEY_HELP, KEY_PROPS, KEY_FRONT, KEY_STOP,\n\tKEY_AGAIN, KEY_UNDO, KEY_CUT, KEY_COPY, KEY_PASTE, KEY_FIND, KEY_MUTE,\n\tKEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_KPCOMMA, KEY_RESERVED, KEY_RO, KEY_KATAKANAHIRAGANA , KEY_YEN,\n\tKEY_HENKAN, KEY_MUHENKAN, KEY_KPJPCOMMA, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_HANGEUL, KEY_HANJA, KEY_KATAKANA, KEY_HIRAGANA,\n\tKEY_ZENKAKUHANKAKU, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,\n\tKEY_RESERVED, KEY_RESERVED, KEY_LEFTCTRL, KEY_LEFTSHIFT, KEY_LEFTALT,\n\tKEY_LEFTMETA, KEY_RIGHTCTRL, KEY_RIGHTSHIFT, KEY_RIGHTALT,\n\tKEY_RIGHTMETA, KEY_PLAYPAUSE, KEY_STOPCD, KEY_PREVIOUSSONG,\n\tKEY_NEXTSONG, KEY_EJECTCD, KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE,\n\tKEY_WWW, KEY_BACK, KEY_FORWARD, KEY_STOP, KEY_FIND, KEY_SCROLLUP,\n\tKEY_SCROLLDOWN, KEY_EDIT, KEY_SLEEP, KEY_SCREENLOCK, KEY_REFRESH,\n\tKEY_CALC, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED\n};\n\nstatic void dc_scan_kbd(struct dc_kbd *kbd)\n{\n\tstruct input_dev *dev = kbd->dev;\n\tvoid *ptr;\n\tint code, keycode;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tcode = i + 224;\n\t\tkeycode = kbd->keycode[code];\n\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(dev, keycode, (kbd->new[0] >> i) & 1);\n\t}\n\n\tfor (i = 2; i < 8; i++) {\n\t\tptr = memchr(kbd->new + 2, kbd->old[i], 6);\n\t\tcode = kbd->old[i];\n\t\tif (code > 3 && ptr == NULL) {\n\t\t\tkeycode = kbd->keycode[code];\n\t\t\tif (keycode) {\n\t\t\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\t\t\t\tinput_report_key(dev, keycode, 0);\n\t\t\t} else\n\t\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\t\"Unknown key (scancode %#x) released.\",\n\t\t\t\t\tcode);\n\t\t}\n\t\tptr = memchr(kbd->old + 2, kbd->new[i], 6);\n\t\tcode = kbd->new[i];\n\t\tif (code > 3 && ptr) {\n\t\t\tkeycode = kbd->keycode[code];\n\t\t\tif (keycode) {\n\t\t\t\tinput_event(dev, EV_MSC, MSC_SCAN, code);\n\t\t\t\tinput_report_key(dev, keycode, 1);\n\t\t\t} else\n\t\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\t\"Unknown key (scancode %#x) pressed.\",\n\t\t\t\t\tcode);\n\t\t}\n\t}\n\tinput_sync(dev);\n\tmemcpy(kbd->old, kbd->new, 8);\n}\n\nstatic void dc_kbd_callback(struct mapleq *mq)\n{\n\tstruct maple_device *mapledev = mq->dev;\n\tstruct dc_kbd *kbd = maple_get_drvdata(mapledev);\n\tunsigned long *buf = (unsigned long *)(mq->recvbuf->buf);\n\n\t \n\tif (likely(mutex_trylock(&maple_keyb_mutex))) {\n\n\t\tif (buf[1] == mapledev->function) {\n\t\t\tmemcpy(kbd->new, buf + 2, 8);\n\t\t\tdc_scan_kbd(kbd);\n\t\t}\n\n\t\tmutex_unlock(&maple_keyb_mutex);\n\t}\n}\n\nstatic int probe_maple_kbd(struct device *dev)\n{\n\tstruct maple_device *mdev;\n\tstruct maple_driver *mdrv;\n\tint i, error;\n\tstruct dc_kbd *kbd;\n\tstruct input_dev *idev;\n\n\tmdev = to_maple_dev(dev);\n\tmdrv = to_maple_driver(dev->driver);\n\n\tkbd = kzalloc(sizeof(struct dc_kbd), GFP_KERNEL);\n\tif (!kbd) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tidev = input_allocate_device();\n\tif (!idev) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_idev_alloc;\n\t}\n\n\tkbd->dev = idev;\n\tmemcpy(kbd->keycode, dc_kbd_keycode, sizeof(kbd->keycode));\n\n\tidev->name = mdev->product_name;\n\tidev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);\n\tidev->keycode = kbd->keycode;\n\tidev->keycodesize = sizeof(unsigned short);\n\tidev->keycodemax = ARRAY_SIZE(kbd->keycode);\n\tidev->id.bustype = BUS_HOST;\n\tidev->dev.parent = &mdev->dev;\n\n\tfor (i = 0; i < NR_SCANCODES; i++)\n\t\t__set_bit(dc_kbd_keycode[i], idev->keybit);\n\t__clear_bit(KEY_RESERVED, idev->keybit);\n\n\tinput_set_capability(idev, EV_MSC, MSC_SCAN);\n\n\terror = input_register_device(idev);\n\tif (error)\n\t\tgoto fail_register;\n\n\t \n\tmaple_getcond_callback(mdev, dc_kbd_callback, HZ/50,\n\t\tMAPLE_FUNC_KEYBOARD);\n\n\tmdev->driver = mdrv;\n\n\tmaple_set_drvdata(mdev, kbd);\n\n\treturn error;\n\nfail_register:\n\tmaple_set_drvdata(mdev, NULL);\n\tinput_free_device(idev);\nfail_idev_alloc:\n\tkfree(kbd);\nfail:\n\treturn error;\n}\n\nstatic int remove_maple_kbd(struct device *dev)\n{\n\tstruct maple_device *mdev = to_maple_dev(dev);\n\tstruct dc_kbd *kbd = maple_get_drvdata(mdev);\n\n\tmutex_lock(&maple_keyb_mutex);\n\n\tinput_unregister_device(kbd->dev);\n\tkfree(kbd);\n\n\tmaple_set_drvdata(mdev, NULL);\n\n\tmutex_unlock(&maple_keyb_mutex);\n\treturn 0;\n}\n\nstatic struct maple_driver dc_kbd_driver = {\n\t.function = MAPLE_FUNC_KEYBOARD,\n\t.drv = {\n\t\t.name = \"Dreamcast_keyboard\",\n\t\t.probe = probe_maple_kbd,\n\t\t.remove = remove_maple_kbd,\n\t},\n};\n\nstatic int __init dc_kbd_init(void)\n{\n\treturn maple_driver_register(&dc_kbd_driver);\n}\n\nstatic void __exit dc_kbd_exit(void)\n{\n\tmaple_driver_unregister(&dc_kbd_driver);\n}\n\nmodule_init(dc_kbd_init);\nmodule_exit(dc_kbd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}