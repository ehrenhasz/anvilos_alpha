{
  "module_name": "gpio_keys_polled.c",
  "hash_id": "5ef98ae61ee428d0054472cbe26ced0e6dd76d31780266c423ff874d6125a669",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/gpio_keys_polled.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio_keys.h>\n#include <linux/property.h>\n\n#define DRV_NAME\t\"gpio-keys-polled\"\n\nstruct gpio_keys_button_data {\n\tstruct gpio_desc *gpiod;\n\tint last_state;\n\tint count;\n\tint threshold;\n};\n\nstruct gpio_keys_polled_dev {\n\tstruct input_dev *input;\n\tstruct device *dev;\n\tconst struct gpio_keys_platform_data *pdata;\n\tunsigned long rel_axis_seen[BITS_TO_LONGS(REL_CNT)];\n\tunsigned long abs_axis_seen[BITS_TO_LONGS(ABS_CNT)];\n\tstruct gpio_keys_button_data data[];\n};\n\nstatic void gpio_keys_button_event(struct input_dev *input,\n\t\t\t\t   const struct gpio_keys_button *button,\n\t\t\t\t   int state)\n{\n\tstruct gpio_keys_polled_dev *bdev = input_get_drvdata(input);\n\tunsigned int type = button->type ?: EV_KEY;\n\n\tif (type == EV_REL) {\n\t\tif (state) {\n\t\t\tinput_event(input, type, button->code, button->value);\n\t\t\t__set_bit(button->code, bdev->rel_axis_seen);\n\t\t}\n\t} else if (type == EV_ABS) {\n\t\tif (state) {\n\t\t\tinput_event(input, type, button->code, button->value);\n\t\t\t__set_bit(button->code, bdev->abs_axis_seen);\n\t\t}\n\t} else {\n\t\tinput_event(input, type, button->code, state);\n\t\tinput_sync(input);\n\t}\n}\n\nstatic void gpio_keys_polled_check_state(struct input_dev *input,\n\t\t\t\t\t const struct gpio_keys_button *button,\n\t\t\t\t\t struct gpio_keys_button_data *bdata)\n{\n\tint state;\n\n\tstate = gpiod_get_value_cansleep(bdata->gpiod);\n\tif (state < 0) {\n\t\tdev_err(input->dev.parent,\n\t\t\t\"failed to get gpio state: %d\\n\", state);\n\t} else {\n\t\tgpio_keys_button_event(input, button, state);\n\n\t\tif (state != bdata->last_state) {\n\t\t\tbdata->count = 0;\n\t\t\tbdata->last_state = state;\n\t\t}\n\t}\n}\n\nstatic void gpio_keys_polled_poll(struct input_dev *input)\n{\n\tstruct gpio_keys_polled_dev *bdev = input_get_drvdata(input);\n\tconst struct gpio_keys_platform_data *pdata = bdev->pdata;\n\tint i;\n\n\tmemset(bdev->rel_axis_seen, 0, sizeof(bdev->rel_axis_seen));\n\tmemset(bdev->abs_axis_seen, 0, sizeof(bdev->abs_axis_seen));\n\n\tfor (i = 0; i < pdata->nbuttons; i++) {\n\t\tstruct gpio_keys_button_data *bdata = &bdev->data[i];\n\n\t\tif (bdata->count < bdata->threshold) {\n\t\t\tbdata->count++;\n\t\t\tgpio_keys_button_event(input, &pdata->buttons[i],\n\t\t\t\t\t       bdata->last_state);\n\t\t} else {\n\t\t\tgpio_keys_polled_check_state(input, &pdata->buttons[i],\n\t\t\t\t\t\t     bdata);\n\t\t}\n\t}\n\n\tfor_each_set_bit(i, input->relbit, REL_CNT) {\n\t\tif (!test_bit(i, bdev->rel_axis_seen))\n\t\t\tinput_event(input, EV_REL, i, 0);\n\t}\n\n\tfor_each_set_bit(i, input->absbit, ABS_CNT) {\n\t\tif (!test_bit(i, bdev->abs_axis_seen))\n\t\t\tinput_event(input, EV_ABS, i, 0);\n\t}\n\n\tinput_sync(input);\n}\n\nstatic int gpio_keys_polled_open(struct input_dev *input)\n{\n\tstruct gpio_keys_polled_dev *bdev = input_get_drvdata(input);\n\tconst struct gpio_keys_platform_data *pdata = bdev->pdata;\n\n\tif (pdata->enable)\n\t\tpdata->enable(bdev->dev);\n\n\treturn 0;\n}\n\nstatic void gpio_keys_polled_close(struct input_dev *input)\n{\n\tstruct gpio_keys_polled_dev *bdev = input_get_drvdata(input);\n\tconst struct gpio_keys_platform_data *pdata = bdev->pdata;\n\n\tif (pdata->disable)\n\t\tpdata->disable(bdev->dev);\n}\n\nstatic struct gpio_keys_platform_data *\ngpio_keys_polled_get_devtree_pdata(struct device *dev)\n{\n\tstruct gpio_keys_platform_data *pdata;\n\tstruct gpio_keys_button *button;\n\tstruct fwnode_handle *child;\n\tint nbuttons;\n\n\tnbuttons = device_get_child_node_count(dev);\n\tif (nbuttons == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata) + nbuttons * sizeof(*button),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbutton = (struct gpio_keys_button *)(pdata + 1);\n\n\tpdata->buttons = button;\n\tpdata->nbuttons = nbuttons;\n\n\tpdata->rep = device_property_present(dev, \"autorepeat\");\n\tdevice_property_read_u32(dev, \"poll-interval\", &pdata->poll_interval);\n\n\tdevice_property_read_string(dev, \"label\", &pdata->name);\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tif (fwnode_property_read_u32(child, \"linux,code\",\n\t\t\t\t\t     &button->code)) {\n\t\t\tdev_err(dev, \"button without keycode\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tfwnode_property_read_string(child, \"label\", &button->desc);\n\n\t\tif (fwnode_property_read_u32(child, \"linux,input-type\",\n\t\t\t\t\t     &button->type))\n\t\t\tbutton->type = EV_KEY;\n\n\t\tif (fwnode_property_read_u32(child, \"linux,input-value\",\n\t\t\t\t\t     (u32 *)&button->value))\n\t\t\tbutton->value = 1;\n\n\t\tbutton->wakeup =\n\t\t\tfwnode_property_read_bool(child, \"wakeup-source\") ||\n\t\t\t \n\t\t\tfwnode_property_read_bool(child, \"gpio-key,wakeup\");\n\n\t\tif (fwnode_property_read_u32(child, \"debounce-interval\",\n\t\t\t\t\t     &button->debounce_interval))\n\t\t\tbutton->debounce_interval = 5;\n\n\t\tbutton++;\n\t}\n\n\treturn pdata;\n}\n\nstatic void gpio_keys_polled_set_abs_params(struct input_dev *input,\n\tconst struct gpio_keys_platform_data *pdata, unsigned int code)\n{\n\tint i, min = 0, max = 0;\n\n\tfor (i = 0; i < pdata->nbuttons; i++) {\n\t\tconst struct gpio_keys_button *button = &pdata->buttons[i];\n\n\t\tif (button->type != EV_ABS || button->code != code)\n\t\t\tcontinue;\n\n\t\tif (button->value < min)\n\t\t\tmin = button->value;\n\t\tif (button->value > max)\n\t\t\tmax = button->value;\n\t}\n\n\tinput_set_abs_params(input, code, min, max, 0, 0);\n}\n\nstatic const struct of_device_id gpio_keys_polled_of_match[] = {\n\t{ .compatible = \"gpio-keys-polled\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gpio_keys_polled_of_match);\n\nstatic int gpio_keys_polled_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *child = NULL;\n\tconst struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);\n\tstruct gpio_keys_polled_dev *bdev;\n\tstruct input_dev *input;\n\tint error;\n\tint i;\n\n\tif (!pdata) {\n\t\tpdata = gpio_keys_polled_get_devtree_pdata(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tif (!pdata->poll_interval) {\n\t\tdev_err(dev, \"missing poll_interval value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = devm_kzalloc(dev, struct_size(bdev, data, pdata->nbuttons),\n\t\t\t    GFP_KERNEL);\n\tif (!bdev) {\n\t\tdev_err(dev, \"no memory for private data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"no memory for input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(input, bdev);\n\n\tinput->name = pdata->name ?: pdev->name;\n\tinput->phys = DRV_NAME\"/input0\";\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = 0x0100;\n\n\tinput->open = gpio_keys_polled_open;\n\tinput->close = gpio_keys_polled_close;\n\n\t__set_bit(EV_KEY, input->evbit);\n\tif (pdata->rep)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tfor (i = 0; i < pdata->nbuttons; i++) {\n\t\tconst struct gpio_keys_button *button = &pdata->buttons[i];\n\t\tstruct gpio_keys_button_data *bdata = &bdev->data[i];\n\t\tunsigned int type = button->type ?: EV_KEY;\n\n\t\tif (button->wakeup) {\n\t\t\tdev_err(dev, DRV_NAME \" does not support wakeup\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!dev_get_platdata(dev)) {\n\t\t\t \n\t\t\tchild = device_get_next_child_node(dev, child);\n\t\t\tif (!child) {\n\t\t\t\tdev_err(dev, \"missing child device node\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tbdata->gpiod = devm_fwnode_gpiod_get(dev, child,\n\t\t\t\t\t\t\t     NULL, GPIOD_IN,\n\t\t\t\t\t\t\t     button->desc);\n\t\t\tif (IS_ERR(bdata->gpiod)) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn dev_err_probe(dev, PTR_ERR(bdata->gpiod),\n\t\t\t\t\t\t     \"failed to get gpio\\n\");\n\t\t\t}\n\t\t} else if (gpio_is_valid(button->gpio)) {\n\t\t\t \n\t\t\tunsigned flags = GPIOF_IN;\n\n\t\t\tif (button->active_low)\n\t\t\t\tflags |= GPIOF_ACTIVE_LOW;\n\n\t\t\terror = devm_gpio_request_one(dev, button->gpio,\n\t\t\t\t\tflags, button->desc ? : DRV_NAME);\n\t\t\tif (error) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"unable to claim gpio %u, err=%d\\n\",\n\t\t\t\t\tbutton->gpio, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tbdata->gpiod = gpio_to_desc(button->gpio);\n\t\t\tif (!bdata->gpiod) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"unable to convert gpio %u to descriptor\\n\",\n\t\t\t\t\tbutton->gpio);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tbdata->last_state = -1;\n\t\tbdata->threshold = DIV_ROUND_UP(button->debounce_interval,\n\t\t\t\t\t\tpdata->poll_interval);\n\n\t\tinput_set_capability(input, type, button->code);\n\t\tif (type == EV_ABS)\n\t\t\tgpio_keys_polled_set_abs_params(input, pdata,\n\t\t\t\t\t\t\tbutton->code);\n\t}\n\n\tfwnode_handle_put(child);\n\n\tbdev->input = input;\n\tbdev->dev = dev;\n\tbdev->pdata = pdata;\n\n\terror = input_setup_polling(input, gpio_keys_polled_poll);\n\tif (error) {\n\t\tdev_err(dev, \"unable to set up polling, err=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput_set_poll_interval(input, pdata->poll_interval);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"unable to register polled device, err=%d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tfor (i = 0; i < pdata->nbuttons; i++)\n\t\tgpio_keys_polled_check_state(input, &pdata->buttons[i],\n\t\t\t\t\t     &bdev->data[i]);\n\n\tinput_sync(input);\n\n\treturn 0;\n}\n\nstatic struct platform_driver gpio_keys_polled_driver = {\n\t.probe\t= gpio_keys_polled_probe,\n\t.driver\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = gpio_keys_polled_of_match,\n\t},\n};\nmodule_platform_driver(gpio_keys_polled_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Gabor Juhos <juhosg@openwrt.org>\");\nMODULE_DESCRIPTION(\"Polled GPIO Buttons driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}