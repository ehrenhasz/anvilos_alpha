{
  "module_name": "lm8333.c",
  "hash_id": "6efb18578fa7ebb4bc088f218f91f4fe02199d17a2d24887310bc34406987c2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/lm8333.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/input/lm8333.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define LM8333_FIFO_READ\t\t0x20\n#define LM8333_DEBOUNCE\t\t\t0x22\n#define LM8333_READ_INT\t\t\t0xD0\n#define LM8333_ACTIVE\t\t\t0xE4\n#define LM8333_READ_ERROR\t\t0xF0\n\n#define LM8333_KEYPAD_IRQ\t\t(1 << 0)\n#define LM8333_ERROR_IRQ\t\t(1 << 3)\n\n#define LM8333_ERROR_KEYOVR\t\t0x04\n#define LM8333_ERROR_FIFOOVR\t\t0x40\n\n#define LM8333_FIFO_TRANSFER_SIZE\t16\n\n#define LM8333_NUM_ROWS\t\t8\n#define LM8333_NUM_COLS\t\t16\n#define LM8333_ROW_SHIFT\t4\n\nstruct lm8333 {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tunsigned short keycodes[LM8333_NUM_ROWS << LM8333_ROW_SHIFT];\n};\n\n \n#define LM8333_READ_RETRIES 2\n\nint lm8333_read8(struct lm8333 *lm8333, u8 cmd)\n{\n\tint retries = 0, ret;\n\n\tdo {\n\t\tret = i2c_smbus_read_byte_data(lm8333->client, cmd);\n\t} while (ret < 0 && retries++ < LM8333_READ_RETRIES);\n\n\treturn ret;\n}\n\nint lm8333_write8(struct lm8333 *lm8333, u8 cmd, u8 val)\n{\n\tint retries = 0, ret;\n\n\tdo {\n\t\tret = i2c_smbus_write_byte_data(lm8333->client, cmd, val);\n\t} while (ret < 0 && retries++ < LM8333_READ_RETRIES);\n\n\treturn ret;\n}\n\nint lm8333_read_block(struct lm8333 *lm8333, u8 cmd, u8 len, u8 *buf)\n{\n\tint retries = 0, ret;\n\n\tdo {\n\t\tret = i2c_smbus_read_i2c_block_data(lm8333->client,\n\t\t\t\t\t\t    cmd, len, buf);\n\t} while (ret < 0 && retries++ < LM8333_READ_RETRIES);\n\n\treturn ret;\n}\n\nstatic void lm8333_key_handler(struct lm8333 *lm8333)\n{\n\tstruct input_dev *input = lm8333->input;\n\tu8 keys[LM8333_FIFO_TRANSFER_SIZE];\n\tu8 code, pressed;\n\tint i, ret;\n\n\tret = lm8333_read_block(lm8333, LM8333_FIFO_READ,\n\t\t\t\tLM8333_FIFO_TRANSFER_SIZE, keys);\n\tif (ret != LM8333_FIFO_TRANSFER_SIZE) {\n\t\tdev_err(&lm8333->client->dev,\n\t\t\t\"Error %d while reading FIFO\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < LM8333_FIFO_TRANSFER_SIZE && keys[i]; i++) {\n\t\tpressed = keys[i] & 0x80;\n\t\tcode = keys[i] & 0x7f;\n\n\t\tinput_event(input, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(input, lm8333->keycodes[code], pressed);\n\t}\n\n\tinput_sync(input);\n}\n\nstatic irqreturn_t lm8333_irq_thread(int irq, void *data)\n{\n\tstruct lm8333 *lm8333 = data;\n\tu8 status = lm8333_read8(lm8333, LM8333_READ_INT);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (status & LM8333_ERROR_IRQ) {\n\t\tu8 err = lm8333_read8(lm8333, LM8333_READ_ERROR);\n\n\t\tif (err & (LM8333_ERROR_KEYOVR | LM8333_ERROR_FIFOOVR)) {\n\t\t\tu8 dummy[LM8333_FIFO_TRANSFER_SIZE];\n\n\t\t\tlm8333_read_block(lm8333, LM8333_FIFO_READ,\n\t\t\t\t\tLM8333_FIFO_TRANSFER_SIZE, dummy);\n\t\t}\n\t\tdev_err(&lm8333->client->dev, \"Got error %02x\\n\", err);\n\t}\n\n\tif (status & LM8333_KEYPAD_IRQ)\n\t\tlm8333_key_handler(lm8333);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lm8333_probe(struct i2c_client *client)\n{\n\tconst struct lm8333_platform_data *pdata =\n\t\t\tdev_get_platdata(&client->dev);\n\tstruct lm8333 *lm8333;\n\tstruct input_dev *input;\n\tint err, active_time;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tactive_time = pdata->active_time ?: 500;\n\tif (active_time / 3 <= pdata->debounce_time / 3) {\n\t\tdev_err(&client->dev, \"Active time not big enough!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlm8333 = devm_kzalloc(&client->dev, sizeof(*lm8333), GFP_KERNEL);\n\tif (!lm8333)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tlm8333->client = client;\n\tlm8333->input = input;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\n\terr = matrix_keypad_build_keymap(pdata->matrix_data, NULL,\n\t\t\t\t\t LM8333_NUM_ROWS, LM8333_NUM_COLS,\n\t\t\t\t\t lm8333->keycodes, input);\n\tif (err)\n\t\treturn err;\n\n\tif (pdata->debounce_time) {\n\t\terr = lm8333_write8(lm8333, LM8333_DEBOUNCE,\n\t\t\t\t    pdata->debounce_time / 3);\n\t\tif (err)\n\t\t\tdev_warn(&client->dev, \"Unable to set debounce time\\n\");\n\t}\n\n\tif (pdata->active_time) {\n\t\terr = lm8333_write8(lm8333, LM8333_ACTIVE,\n\t\t\t\t    pdata->active_time / 3);\n\t\tif (err)\n\t\t\tdev_warn(&client->dev, \"Unable to set active time\\n\");\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, lm8333_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\"lm8333\", lm8333);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(input);\n\tif (err)\n\t\treturn err;\n\n\ti2c_set_clientdata(client, lm8333);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id lm8333_id[] = {\n\t{ \"lm8333\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lm8333_id);\n\nstatic struct i2c_driver lm8333_driver = {\n\t.driver = {\n\t\t.name\t\t= \"lm8333\",\n\t},\n\t.probe\t\t= lm8333_probe,\n\t.id_table\t= lm8333_id,\n};\nmodule_i2c_driver(lm8333_driver);\n\nMODULE_AUTHOR(\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"LM8333 keyboard driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}