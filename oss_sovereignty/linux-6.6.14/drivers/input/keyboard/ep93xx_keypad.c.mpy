{
  "module_name": "ep93xx_keypad.c",
  "hash_id": "f31ed7c6efc166b0c522fb91f363f133d90ac75c1bea48e613d41dff3abdcb23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/ep93xx_keypad.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/slab.h>\n#include <linux/soc/cirrus/ep93xx.h>\n#include <linux/platform_data/keypad-ep93xx.h>\n#include <linux/pm_wakeirq.h>\n\n \n#define KEY_INIT\t\t0x00\t \n#define KEY_DIAG\t\t0x04\t \n#define KEY_REG\t\t\t0x08\t \n\n \n#define KEY_INIT_DBNC_MASK\tGENMASK(23, 16)\n#define KEY_INIT_DBNC_SHIFT\t16\n#define KEY_INIT_DIS3KY\t\tBIT(15)\n#define KEY_INIT_DIAG\t\tBIT(14)\n#define KEY_INIT_BACK\t\tBIT(13)\n#define KEY_INIT_T2\t\tBIT(12)\n#define KEY_INIT_PRSCL_MASK\tGENMASK(9, 0)\n#define KEY_INIT_PRSCL_SHIFT\t0\n\n \n#define KEY_DIAG_MASK\t\tGENMASK(5, 0)\n#define KEY_DIAG_SHIFT\t\t0\n\n \n#define KEY_REG_K\t\tBIT(15)\n#define KEY_REG_INT\t\tBIT(14)\n#define KEY_REG_2KEYS\t\tBIT(13)\n#define KEY_REG_1KEY\t\tBIT(12)\n#define KEY_REG_KEY2_MASK\tGENMASK(11, 6)\n#define KEY_REG_KEY2_SHIFT\t6\n#define KEY_REG_KEY1_MASK\tGENMASK(5, 0)\n#define KEY_REG_KEY1_SHIFT\t0\n\n#define EP93XX_MATRIX_SIZE\t(EP93XX_MATRIX_ROWS * EP93XX_MATRIX_COLS)\n\nstruct ep93xx_keypad {\n\tstruct ep93xx_keypad_platform_data *pdata;\n\tstruct input_dev *input_dev;\n\tstruct clk *clk;\n\n\tvoid __iomem *mmio_base;\n\n\tunsigned short keycodes[EP93XX_MATRIX_SIZE];\n\n\tint key1;\n\tint key2;\n\n\tint irq;\n\n\tbool enabled;\n};\n\nstatic irqreturn_t ep93xx_keypad_irq_handler(int irq, void *dev_id)\n{\n\tstruct ep93xx_keypad *keypad = dev_id;\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tunsigned int status;\n\tint keycode, key1, key2;\n\n\tstatus = __raw_readl(keypad->mmio_base + KEY_REG);\n\n\tkeycode = (status & KEY_REG_KEY1_MASK) >> KEY_REG_KEY1_SHIFT;\n\tkey1 = keypad->keycodes[keycode];\n\n\tkeycode = (status & KEY_REG_KEY2_MASK) >> KEY_REG_KEY2_SHIFT;\n\tkey2 = keypad->keycodes[keycode];\n\n\tif (status & KEY_REG_2KEYS) {\n\t\tif (keypad->key1 && key1 != keypad->key1 && key2 != keypad->key1)\n\t\t\tinput_report_key(input_dev, keypad->key1, 0);\n\n\t\tif (keypad->key2 && key1 != keypad->key2 && key2 != keypad->key2)\n\t\t\tinput_report_key(input_dev, keypad->key2, 0);\n\n\t\tinput_report_key(input_dev, key1, 1);\n\t\tinput_report_key(input_dev, key2, 1);\n\n\t\tkeypad->key1 = key1;\n\t\tkeypad->key2 = key2;\n\n\t} else if (status & KEY_REG_1KEY) {\n\t\tif (keypad->key1 && key1 != keypad->key1)\n\t\t\tinput_report_key(input_dev, keypad->key1, 0);\n\n\t\tif (keypad->key2 && key1 != keypad->key2)\n\t\t\tinput_report_key(input_dev, keypad->key2, 0);\n\n\t\tinput_report_key(input_dev, key1, 1);\n\n\t\tkeypad->key1 = key1;\n\t\tkeypad->key2 = 0;\n\n\t} else {\n\t\tinput_report_key(input_dev, keypad->key1, 0);\n\t\tinput_report_key(input_dev, keypad->key2, 0);\n\n\t\tkeypad->key1 = keypad->key2 = 0;\n\t}\n\tinput_sync(input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ep93xx_keypad_config(struct ep93xx_keypad *keypad)\n{\n\tstruct ep93xx_keypad_platform_data *pdata = keypad->pdata;\n\tunsigned int val = 0;\n\n\tclk_set_rate(keypad->clk, pdata->clk_rate);\n\n\tif (pdata->flags & EP93XX_KEYPAD_DISABLE_3_KEY)\n\t\tval |= KEY_INIT_DIS3KY;\n\tif (pdata->flags & EP93XX_KEYPAD_DIAG_MODE)\n\t\tval |= KEY_INIT_DIAG;\n\tif (pdata->flags & EP93XX_KEYPAD_BACK_DRIVE)\n\t\tval |= KEY_INIT_BACK;\n\tif (pdata->flags & EP93XX_KEYPAD_TEST_MODE)\n\t\tval |= KEY_INIT_T2;\n\n\tval |= ((pdata->debounce << KEY_INIT_DBNC_SHIFT) & KEY_INIT_DBNC_MASK);\n\n\tval |= ((pdata->prescale << KEY_INIT_PRSCL_SHIFT) & KEY_INIT_PRSCL_MASK);\n\n\t__raw_writel(val, keypad->mmio_base + KEY_INIT);\n}\n\nstatic int ep93xx_keypad_open(struct input_dev *pdev)\n{\n\tstruct ep93xx_keypad *keypad = input_get_drvdata(pdev);\n\n\tif (!keypad->enabled) {\n\t\tep93xx_keypad_config(keypad);\n\t\tclk_prepare_enable(keypad->clk);\n\t\tkeypad->enabled = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void ep93xx_keypad_close(struct input_dev *pdev)\n{\n\tstruct ep93xx_keypad *keypad = input_get_drvdata(pdev);\n\n\tif (keypad->enabled) {\n\t\tclk_disable_unprepare(keypad->clk);\n\t\tkeypad->enabled = false;\n\t}\n}\n\n\nstatic int ep93xx_keypad_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ep93xx_keypad *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = keypad->input_dev;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (keypad->enabled) {\n\t\tclk_disable(keypad->clk);\n\t\tkeypad->enabled = false;\n\t}\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int ep93xx_keypad_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ep93xx_keypad *keypad = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = keypad->input_dev;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev)) {\n\t\tif (!keypad->enabled) {\n\t\t\tep93xx_keypad_config(keypad);\n\t\t\tclk_enable(keypad->clk);\n\t\t\tkeypad->enabled = true;\n\t\t}\n\t}\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ep93xx_keypad_pm_ops,\n\t\t\t\tep93xx_keypad_suspend, ep93xx_keypad_resume);\n\nstatic void ep93xx_keypad_release_gpio_action(void *_pdev)\n{\n\tstruct platform_device *pdev = _pdev;\n\n\tep93xx_keypad_release_gpio(pdev);\n}\n\nstatic int ep93xx_keypad_probe(struct platform_device *pdev)\n{\n\tstruct ep93xx_keypad *keypad;\n\tconst struct matrix_keymap_data *keymap_data;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(*keypad), GFP_KERNEL);\n\tif (!keypad)\n\t\treturn -ENOMEM;\n\n\tkeypad->pdata = dev_get_platdata(&pdev->dev);\n\tif (!keypad->pdata)\n\t\treturn -EINVAL;\n\n\tkeymap_data = keypad->pdata->keymap_data;\n\tif (!keymap_data)\n\t\treturn -EINVAL;\n\n\tkeypad->irq = platform_get_irq(pdev, 0);\n\tif (keypad->irq < 0)\n\t\treturn keypad->irq;\n\n\tkeypad->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(keypad->mmio_base))\n\t\treturn PTR_ERR(keypad->mmio_base);\n\n\terr = ep93xx_keypad_acquire_gpio(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       ep93xx_keypad_release_gpio_action, pdev);\n\tif (err)\n\t\treturn err;\n\n\tkeypad->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(keypad->clk))\n\t\treturn PTR_ERR(keypad->clk);\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tkeypad->input_dev = input_dev;\n\n\tinput_dev->name = pdev->name;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->open = ep93xx_keypad_open;\n\tinput_dev->close = ep93xx_keypad_close;\n\n\terr = matrix_keypad_build_keymap(keymap_data, NULL,\n\t\t\t\t\t EP93XX_MATRIX_ROWS, EP93XX_MATRIX_COLS,\n\t\t\t\t\t keypad->keycodes, input_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (keypad->pdata->flags & EP93XX_KEYPAD_AUTOREPEAT)\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\tinput_set_drvdata(input_dev, keypad);\n\n\terr = devm_request_irq(&pdev->dev, keypad->irq,\n\t\t\t       ep93xx_keypad_irq_handler,\n\t\t\t       0, pdev->name, keypad);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, keypad);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\terr = dev_pm_set_wake_irq(&pdev->dev, keypad->irq);\n\tif (err)\n\t\tdev_warn(&pdev->dev, \"failed to set up wakeup irq: %d\\n\", err);\n\n\treturn 0;\n}\n\nstatic int ep93xx_keypad_remove(struct platform_device *pdev)\n{\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ep93xx_keypad_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ep93xx-keypad\",\n\t\t.pm\t= pm_sleep_ptr(&ep93xx_keypad_pm_ops),\n\t},\n\t.probe\t\t= ep93xx_keypad_probe,\n\t.remove\t\t= ep93xx_keypad_remove,\n};\nmodule_platform_driver(ep93xx_keypad_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"H Hartley Sweeten <hsweeten@visionengravers.com>\");\nMODULE_DESCRIPTION(\"EP93xx Matrix Keypad Controller\");\nMODULE_ALIAS(\"platform:ep93xx-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}