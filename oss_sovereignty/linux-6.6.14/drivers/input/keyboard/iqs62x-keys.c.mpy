{
  "module_name": "iqs62x-keys.c",
  "hash_id": "6ed569407d9b77a10f7b3f48e0eb0f01b08485d0b7f93befb1931ae9a33e5491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/iqs62x-keys.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/mfd/iqs62x.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nenum {\n\tIQS62X_SW_HALL_N,\n\tIQS62X_SW_HALL_S,\n};\n\nstatic const char * const iqs62x_switch_names[] = {\n\t[IQS62X_SW_HALL_N] = \"hall-switch-north\",\n\t[IQS62X_SW_HALL_S] = \"hall-switch-south\",\n};\n\nstruct iqs62x_switch_desc {\n\tenum iqs62x_event_flag flag;\n\tunsigned int code;\n\tbool enabled;\n};\n\nstruct iqs62x_keys_private {\n\tstruct iqs62x_core *iqs62x;\n\tstruct input_dev *input;\n\tstruct notifier_block notifier;\n\tstruct iqs62x_switch_desc switches[ARRAY_SIZE(iqs62x_switch_names)];\n\tunsigned int keycode[IQS62X_NUM_KEYS];\n\tunsigned int keycodemax;\n\tu8 interval;\n};\n\nstatic int iqs62x_keys_parse_prop(struct platform_device *pdev,\n\t\t\t\t  struct iqs62x_keys_private *iqs62x_keys)\n{\n\tstruct fwnode_handle *child;\n\tunsigned int val;\n\tint ret, i;\n\n\tret = device_property_count_u32(&pdev->dev, \"linux,keycodes\");\n\tif (ret > IQS62X_NUM_KEYS) {\n\t\tdev_err(&pdev->dev, \"Too many keycodes present\\n\");\n\t\treturn -EINVAL;\n\t} else if (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to count keycodes: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tiqs62x_keys->keycodemax = ret;\n\n\tret = device_property_read_u32_array(&pdev->dev, \"linux,keycodes\",\n\t\t\t\t\t     iqs62x_keys->keycode,\n\t\t\t\t\t     iqs62x_keys->keycodemax);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to read keycodes: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs62x_keys->switches); i++) {\n\t\tchild = device_get_named_child_node(&pdev->dev,\n\t\t\t\t\t\t    iqs62x_switch_names[i]);\n\t\tif (!child)\n\t\t\tcontinue;\n\n\t\tret = fwnode_property_read_u32(child, \"linux,code\", &val);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to read switch code: %d\\n\",\n\t\t\t\tret);\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\tiqs62x_keys->switches[i].code = val;\n\t\tiqs62x_keys->switches[i].enabled = true;\n\n\t\tif (fwnode_property_present(child, \"azoteq,use-prox\"))\n\t\t\tiqs62x_keys->switches[i].flag = (i == IQS62X_SW_HALL_N ?\n\t\t\t\t\t\t\t IQS62X_EVENT_HALL_N_P :\n\t\t\t\t\t\t\t IQS62X_EVENT_HALL_S_P);\n\t\telse\n\t\t\tiqs62x_keys->switches[i].flag = (i == IQS62X_SW_HALL_N ?\n\t\t\t\t\t\t\t IQS62X_EVENT_HALL_N_T :\n\t\t\t\t\t\t\t IQS62X_EVENT_HALL_S_T);\n\n\t\tfwnode_handle_put(child);\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs62x_keys_init(struct iqs62x_keys_private *iqs62x_keys)\n{\n\tstruct iqs62x_core *iqs62x = iqs62x_keys->iqs62x;\n\tenum iqs62x_event_flag flag;\n\tunsigned int event_reg, val;\n\tunsigned int event_mask = 0;\n\tint ret, i;\n\n\tswitch (iqs62x->dev_desc->prod_num) {\n\tcase IQS620_PROD_NUM:\n\tcase IQS621_PROD_NUM:\n\tcase IQS622_PROD_NUM:\n\t\tevent_reg = IQS620_GLBL_EVENT_MASK;\n\n\t\t \n\t\tfor (i = 0; i < iqs62x_keys->keycodemax; i++) {\n\t\t\tif (iqs62x_keys->keycode[i] == KEY_RESERVED)\n\t\t\t\tcontinue;\n\n\t\t\tif (iqs62x_events[i].reg == IQS62X_EVENT_PROX)\n\t\t\t\tevent_mask |= iqs62x->dev_desc->prox_mask;\n\t\t\telse if (iqs62x_events[i].reg == IQS62X_EVENT_HYST)\n\t\t\t\tevent_mask |= (iqs62x->dev_desc->hyst_mask |\n\t\t\t\t\t       iqs62x->dev_desc->sar_mask);\n\t\t}\n\n\t\tret = regmap_read(iqs62x->regmap, iqs62x->dev_desc->hall_flags,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(iqs62x_keys->switches); i++) {\n\t\t\tif (!(iqs62x_keys->switches[i].enabled))\n\t\t\t\tcontinue;\n\n\t\t\tflag = iqs62x_keys->switches[i].flag;\n\n\t\t\tif (iqs62x_events[flag].reg != IQS62X_EVENT_HALL)\n\t\t\t\tcontinue;\n\n\t\t\tevent_mask |= iqs62x->dev_desc->hall_mask;\n\n\t\t\tinput_report_switch(iqs62x_keys->input,\n\t\t\t\t\t    iqs62x_keys->switches[i].code,\n\t\t\t\t\t    (val & iqs62x_events[flag].mask) ==\n\t\t\t\t\t    iqs62x_events[flag].val);\n\t\t}\n\n\t\tinput_sync(iqs62x_keys->input);\n\t\tbreak;\n\n\tcase IQS624_PROD_NUM:\n\t\tevent_reg = IQS624_HALL_UI;\n\n\t\t \n\t\tif (iqs62x_keys->keycode[IQS62X_EVENT_WHEEL_UP] != KEY_RESERVED)\n\t\t\tevent_mask |= IQS624_HALL_UI_INT_EVENT;\n\n\t\tif (iqs62x_keys->keycode[IQS62X_EVENT_WHEEL_DN] != KEY_RESERVED)\n\t\t\tevent_mask |= IQS624_HALL_UI_INT_EVENT;\n\n\t\tret = regmap_read(iqs62x->regmap, iqs62x->dev_desc->interval,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tiqs62x_keys->interval = val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn regmap_update_bits(iqs62x->regmap, event_reg, event_mask, 0);\n}\n\nstatic int iqs62x_keys_notifier(struct notifier_block *notifier,\n\t\t\t\tunsigned long event_flags, void *context)\n{\n\tstruct iqs62x_event_data *event_data = context;\n\tstruct iqs62x_keys_private *iqs62x_keys;\n\tint ret, i;\n\n\tiqs62x_keys = container_of(notifier, struct iqs62x_keys_private,\n\t\t\t\t   notifier);\n\n\tif (event_flags & BIT(IQS62X_EVENT_SYS_RESET)) {\n\t\tret = iqs62x_keys_init(iqs62x_keys);\n\t\tif (ret) {\n\t\t\tdev_err(iqs62x_keys->input->dev.parent,\n\t\t\t\t\"Failed to re-initialize device: %d\\n\", ret);\n\t\t\treturn NOTIFY_BAD;\n\t\t}\n\n\t\treturn NOTIFY_OK;\n\t}\n\n\tfor (i = 0; i < iqs62x_keys->keycodemax; i++) {\n\t\tif (iqs62x_events[i].reg == IQS62X_EVENT_WHEEL &&\n\t\t    event_data->interval == iqs62x_keys->interval)\n\t\t\tcontinue;\n\n\t\tinput_report_key(iqs62x_keys->input, iqs62x_keys->keycode[i],\n\t\t\t\t event_flags & BIT(i));\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs62x_keys->switches); i++)\n\t\tif (iqs62x_keys->switches[i].enabled)\n\t\t\tinput_report_switch(iqs62x_keys->input,\n\t\t\t\t\t    iqs62x_keys->switches[i].code,\n\t\t\t\t\t    event_flags &\n\t\t\t\t\t    BIT(iqs62x_keys->switches[i].flag));\n\n\tinput_sync(iqs62x_keys->input);\n\n\tif (event_data->interval == iqs62x_keys->interval)\n\t\treturn NOTIFY_OK;\n\n\t \n\tif (event_flags & BIT(IQS62X_EVENT_WHEEL_UP)) {\n\t\tinput_report_key(iqs62x_keys->input,\n\t\t\t\t iqs62x_keys->keycode[IQS62X_EVENT_WHEEL_UP],\n\t\t\t\t 0);\n\t\tinput_sync(iqs62x_keys->input);\n\t} else if (event_flags & BIT(IQS62X_EVENT_WHEEL_DN)) {\n\t\tinput_report_key(iqs62x_keys->input,\n\t\t\t\t iqs62x_keys->keycode[IQS62X_EVENT_WHEEL_DN],\n\t\t\t\t 0);\n\t\tinput_sync(iqs62x_keys->input);\n\t}\n\n\tiqs62x_keys->interval = event_data->interval;\n\n\treturn NOTIFY_OK;\n}\n\nstatic int iqs62x_keys_probe(struct platform_device *pdev)\n{\n\tstruct iqs62x_core *iqs62x = dev_get_drvdata(pdev->dev.parent);\n\tstruct iqs62x_keys_private *iqs62x_keys;\n\tstruct input_dev *input;\n\tint ret, i;\n\n\tiqs62x_keys = devm_kzalloc(&pdev->dev, sizeof(*iqs62x_keys),\n\t\t\t\t   GFP_KERNEL);\n\tif (!iqs62x_keys)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, iqs62x_keys);\n\n\tret = iqs62x_keys_parse_prop(pdev, iqs62x_keys);\n\tif (ret)\n\t\treturn ret;\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->keycodemax = iqs62x_keys->keycodemax;\n\tinput->keycode = iqs62x_keys->keycode;\n\tinput->keycodesize = sizeof(*iqs62x_keys->keycode);\n\n\tinput->name = iqs62x->dev_desc->dev_name;\n\tinput->id.bustype = BUS_I2C;\n\n\tfor (i = 0; i < iqs62x_keys->keycodemax; i++)\n\t\tif (iqs62x_keys->keycode[i] != KEY_RESERVED)\n\t\t\tinput_set_capability(input, EV_KEY,\n\t\t\t\t\t     iqs62x_keys->keycode[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs62x_keys->switches); i++)\n\t\tif (iqs62x_keys->switches[i].enabled)\n\t\t\tinput_set_capability(input, EV_SW,\n\t\t\t\t\t     iqs62x_keys->switches[i].code);\n\n\tiqs62x_keys->iqs62x = iqs62x;\n\tiqs62x_keys->input = input;\n\n\tret = iqs62x_keys_init(iqs62x_keys);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = input_register_device(iqs62x_keys->input);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tiqs62x_keys->notifier.notifier_call = iqs62x_keys_notifier;\n\tret = blocking_notifier_chain_register(&iqs62x_keys->iqs62x->nh,\n\t\t\t\t\t       &iqs62x_keys->notifier);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to register notifier: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int iqs62x_keys_remove(struct platform_device *pdev)\n{\n\tstruct iqs62x_keys_private *iqs62x_keys = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = blocking_notifier_chain_unregister(&iqs62x_keys->iqs62x->nh,\n\t\t\t\t\t\t &iqs62x_keys->notifier);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to unregister notifier: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic struct platform_driver iqs62x_keys_platform_driver = {\n\t.driver = {\n\t\t.name = \"iqs62x-keys\",\n\t},\n\t.probe = iqs62x_keys_probe,\n\t.remove = iqs62x_keys_remove,\n};\nmodule_platform_driver(iqs62x_keys_platform_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS620A/621/622/624/625 Keys and Switches\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:iqs62x-keys\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}