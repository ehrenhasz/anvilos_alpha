{
  "module_name": "adp5520-keys.c",
  "hash_id": "081a021dff975512dd28ae6a4faf994424ad170b09a0b8120ca480a967964dae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/adp5520-keys.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/mfd/adp5520.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\nstruct adp5520_keys {\n\tstruct input_dev *input;\n\tstruct notifier_block notifier;\n\tstruct device *master;\n\tunsigned short keycode[ADP5520_KEYMAPSIZE];\n};\n\nstatic void adp5520_keys_report_event(struct adp5520_keys *dev,\n\t\t\t\t\tunsigned short keymask, int value)\n{\n\tint i;\n\n\tfor (i = 0; i < ADP5520_MAXKEYS; i++)\n\t\tif (keymask & (1 << i))\n\t\t\tinput_report_key(dev->input, dev->keycode[i], value);\n\n\tinput_sync(dev->input);\n}\n\nstatic int adp5520_keys_notifier(struct notifier_block *nb,\n\t\t\t\t unsigned long event, void *data)\n{\n\tstruct adp5520_keys *dev;\n\tuint8_t reg_val_lo, reg_val_hi;\n\tunsigned short keymask;\n\n\tdev = container_of(nb, struct adp5520_keys, notifier);\n\n\tif (event & ADP5520_KP_INT) {\n\t\tadp5520_read(dev->master, ADP5520_KP_INT_STAT_1, &reg_val_lo);\n\t\tadp5520_read(dev->master, ADP5520_KP_INT_STAT_2, &reg_val_hi);\n\n\t\tkeymask = (reg_val_hi << 8) | reg_val_lo;\n\t\t \n\t\tadp5520_read(dev->master, ADP5520_KP_INT_STAT_1, &reg_val_lo);\n\t\tadp5520_read(dev->master, ADP5520_KP_INT_STAT_2, &reg_val_hi);\n\t\tkeymask |= (reg_val_hi << 8) | reg_val_lo;\n\t\tadp5520_keys_report_event(dev, keymask, 1);\n\t}\n\n\tif (event & ADP5520_KR_INT) {\n\t\tadp5520_read(dev->master, ADP5520_KR_INT_STAT_1, &reg_val_lo);\n\t\tadp5520_read(dev->master, ADP5520_KR_INT_STAT_2, &reg_val_hi);\n\n\t\tkeymask = (reg_val_hi << 8) | reg_val_lo;\n\t\t \n\t\tadp5520_read(dev->master, ADP5520_KR_INT_STAT_1, &reg_val_lo);\n\t\tadp5520_read(dev->master, ADP5520_KR_INT_STAT_2, &reg_val_hi);\n\t\tkeymask |= (reg_val_hi << 8) | reg_val_lo;\n\t\tadp5520_keys_report_event(dev, keymask, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int adp5520_keys_probe(struct platform_device *pdev)\n{\n\tstruct adp5520_keys_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct input_dev *input;\n\tstruct adp5520_keys *dev;\n\tint ret, i;\n\tunsigned char en_mask, ctl_mask = 0;\n\n\tif (pdev->id != ID_ADP5520) {\n\t\tdev_err(&pdev->dev, \"only ADP5520 supports Keypad\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(pdata->rows_en_mask && pdata->cols_en_mask))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"failed to alloc memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tdev->master = pdev->dev.parent;\n\tdev->input = input;\n\n\tinput->name = pdev->name;\n\tinput->phys = \"adp5520-keys/input0\";\n\tinput->dev.parent = &pdev->dev;\n\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x5520;\n\tinput->id.version = 0x0001;\n\n\tinput->keycodesize = sizeof(dev->keycode[0]);\n\tinput->keycodemax = pdata->keymapsize;\n\tinput->keycode = dev->keycode;\n\n\tmemcpy(dev->keycode, pdata->keymap,\n\t\tpdata->keymapsize * input->keycodesize);\n\n\t \n\t__set_bit(EV_KEY, input->evbit);\n\n\tif (pdata->repeat)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tfor (i = 0; i < input->keycodemax; i++)\n\t\t__set_bit(dev->keycode[i], input->keybit);\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\tret = input_register_device(input);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to register input device\\n\");\n\t\treturn ret;\n\t}\n\n\ten_mask = pdata->rows_en_mask | pdata->cols_en_mask;\n\n\tret = adp5520_set_bits(dev->master, ADP5520_GPIO_CFG_1, en_mask);\n\n\tif (en_mask & ADP5520_COL_C3)\n\t\tctl_mask |= ADP5520_C3_MODE;\n\n\tif (en_mask & ADP5520_ROW_R3)\n\t\tctl_mask |= ADP5520_R3_MODE;\n\n\tif (ctl_mask)\n\t\tret |= adp5520_set_bits(dev->master, ADP5520_LED_CONTROL,\n\t\t\tctl_mask);\n\n\tret |= adp5520_set_bits(dev->master, ADP5520_GPIO_PULLUP,\n\t\tpdata->rows_en_mask);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to write\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev->notifier.notifier_call = adp5520_keys_notifier;\n\tret = adp5520_register_notifier(dev->master, &dev->notifier,\n\t\t\tADP5520_KP_IEN | ADP5520_KR_IEN);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register notifier\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\treturn 0;\n}\n\nstatic int adp5520_keys_remove(struct platform_device *pdev)\n{\n\tstruct adp5520_keys *dev = platform_get_drvdata(pdev);\n\n\tadp5520_unregister_notifier(dev->master, &dev->notifier,\n\t\t\t\tADP5520_KP_IEN | ADP5520_KR_IEN);\n\n\treturn 0;\n}\n\nstatic struct platform_driver adp5520_keys_driver = {\n\t.driver\t= {\n\t\t.name\t= \"adp5520-keys\",\n\t},\n\t.probe\t\t= adp5520_keys_probe,\n\t.remove\t\t= adp5520_keys_remove,\n};\nmodule_platform_driver(adp5520_keys_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"Keys ADP5520 Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:adp5520-keys\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}