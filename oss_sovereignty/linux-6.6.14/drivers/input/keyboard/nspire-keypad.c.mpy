{
  "module_name": "nspire-keypad.c",
  "hash_id": "0691b7c6c4b680eca435494a5943bafcf56262dcdd6907017b5bf086336f2468",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/nspire-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/input/matrix_keypad.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#define KEYPAD_SCAN_MODE\t0x00\n#define KEYPAD_CNTL\t\t0x04\n#define KEYPAD_INT\t\t0x08\n#define KEYPAD_INTMSK\t\t0x0C\n\n#define KEYPAD_DATA\t\t0x10\n#define KEYPAD_GPIO\t\t0x30\n\n#define KEYPAD_UNKNOWN_INT\t0x40\n#define KEYPAD_UNKNOWN_INT_STS\t0x44\n\n#define KEYPAD_BITMASK_COLS\t11\n#define KEYPAD_BITMASK_ROWS\t8\n\nstruct nspire_keypad {\n\tvoid __iomem *reg_base;\n\tu32 int_mask;\n\n\tstruct input_dev *input;\n\tstruct clk *clk;\n\n\tstruct matrix_keymap_data *keymap;\n\tint row_shift;\n\n\t \n\tu32 scan_interval;\t \n\tu32 row_delay;\t\t \n\n\tu16 state[KEYPAD_BITMASK_ROWS];\n\n\tbool active_low;\n};\n\nstatic irqreturn_t nspire_keypad_irq(int irq, void *dev_id)\n{\n\tstruct nspire_keypad *keypad = dev_id;\n\tstruct input_dev *input = keypad->input;\n\tunsigned short *keymap = input->keycode;\n\tunsigned int code;\n\tint row, col;\n\tu32 int_sts;\n\tu16 state[8];\n\tu16 bits, changed;\n\n\tint_sts = readl(keypad->reg_base + KEYPAD_INT) & keypad->int_mask;\n\tif (!int_sts)\n\t\treturn IRQ_NONE;\n\n\tmemcpy_fromio(state, keypad->reg_base + KEYPAD_DATA, sizeof(state));\n\n\tfor (row = 0; row < KEYPAD_BITMASK_ROWS; row++) {\n\t\tbits = state[row];\n\t\tif (keypad->active_low)\n\t\t\tbits = ~bits;\n\n\t\tchanged = bits ^ keypad->state[row];\n\t\tif (!changed)\n\t\t\tcontinue;\n\n\t\tkeypad->state[row] = bits;\n\n\t\tfor (col = 0; col < KEYPAD_BITMASK_COLS; col++) {\n\t\t\tif (!(changed & (1U << col)))\n\t\t\t\tcontinue;\n\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\n\t\t\tinput_event(input, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(input, keymap[code],\n\t\t\t\t\t bits & (1U << col));\n\t\t}\n\t}\n\n\tinput_sync(input);\n\n\twritel(0x3, keypad->reg_base + KEYPAD_INT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nspire_keypad_open(struct input_dev *input)\n{\n\tstruct nspire_keypad *keypad = input_get_drvdata(input);\n\tunsigned long val = 0, cycles_per_us, delay_cycles, row_delay_cycles;\n\tint error;\n\n\terror = clk_prepare_enable(keypad->clk);\n\tif (error)\n\t\treturn error;\n\n\tcycles_per_us = (clk_get_rate(keypad->clk) / 1000000);\n\tif (cycles_per_us == 0)\n\t\tcycles_per_us = 1;\n\n\tdelay_cycles = cycles_per_us * keypad->scan_interval;\n\tWARN_ON(delay_cycles >= (1 << 16));  \n\tdelay_cycles &= 0xffff;\n\n\trow_delay_cycles = cycles_per_us * keypad->row_delay;\n\tWARN_ON(row_delay_cycles >= (1 << 14));  \n\trow_delay_cycles &= 0x3fff;\n\n\tval |= 3 << 0;  \n\tval |= row_delay_cycles << 2;  \n\tval |= delay_cycles << 16;  \n\twritel(val, keypad->reg_base + KEYPAD_SCAN_MODE);\n\n\tval = (KEYPAD_BITMASK_ROWS & 0xff) | (KEYPAD_BITMASK_COLS & 0xff)<<8;\n\twritel(val, keypad->reg_base + KEYPAD_CNTL);\n\n\t \n\tkeypad->int_mask = 1 << 1;\n\twritel(keypad->int_mask, keypad->reg_base + KEYPAD_INTMSK);\n\n\treturn 0;\n}\n\nstatic void nspire_keypad_close(struct input_dev *input)\n{\n\tstruct nspire_keypad *keypad = input_get_drvdata(input);\n\n\t \n\twritel(0, keypad->reg_base + KEYPAD_INTMSK);\n\t \n\twritel(~0, keypad->reg_base + KEYPAD_INT);\n\n\tclk_disable_unprepare(keypad->clk);\n}\n\nstatic int nspire_keypad_probe(struct platform_device *pdev)\n{\n\tconst struct device_node *of_node = pdev->dev.of_node;\n\tstruct nspire_keypad *keypad;\n\tstruct input_dev *input;\n\tstruct resource *res;\n\tint irq;\n\tint error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(struct nspire_keypad),\n\t\t\t      GFP_KERNEL);\n\tif (!keypad) {\n\t\tdev_err(&pdev->dev, \"failed to allocate keypad memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad->row_shift = get_count_order(KEYPAD_BITMASK_COLS);\n\n\terror = of_property_read_u32(of_node, \"scan-interval\",\n\t\t\t\t     &keypad->scan_interval);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to get scan-interval\\n\");\n\t\treturn error;\n\t}\n\n\terror = of_property_read_u32(of_node, \"row-delay\",\n\t\t\t\t     &keypad->row_delay);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to get row-delay\\n\");\n\t\treturn error;\n\t}\n\n\tkeypad->active_low = of_property_read_bool(of_node, \"active-low\");\n\n\tkeypad->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(keypad->clk)) {\n\t\tdev_err(&pdev->dev, \"unable to get clock\\n\");\n\t\treturn PTR_ERR(keypad->clk);\n\t}\n\n\tkeypad->reg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(keypad->reg_base))\n\t\treturn PTR_ERR(keypad->reg_base);\n\n\tkeypad->input = input = devm_input_allocate_device(&pdev->dev);\n\tif (!input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terror = clk_prepare_enable(keypad->clk);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\treturn error;\n\t}\n\n\t \n\twritel(0, keypad->reg_base + KEYPAD_INTMSK);\n\t \n\twritel(~0, keypad->reg_base + KEYPAD_INT);\n\n\t \n\t \n\twritel(0, keypad->reg_base + KEYPAD_UNKNOWN_INT);\n\t \n\twritel(~0, keypad->reg_base + KEYPAD_UNKNOWN_INT_STS);\n\n\tclk_disable_unprepare(keypad->clk);\n\n\tinput_set_drvdata(input, keypad);\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->name = \"nspire-keypad\";\n\tinput->open = nspire_keypad_open;\n\tinput->close = nspire_keypad_close;\n\n\t__set_bit(EV_KEY, input->evbit);\n\t__set_bit(EV_REP, input->evbit);\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   KEYPAD_BITMASK_ROWS,\n\t\t\t\t\t   KEYPAD_BITMASK_COLS,\n\t\t\t\t\t   NULL, input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"building keymap failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_irq(&pdev->dev, irq, nspire_keypad_irq, 0,\n\t\t\t\t \"nspire_keypad\", keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"allocate irq %d failed\\n\", irq);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tdev_dbg(&pdev->dev,\n\t\t\"TI-NSPIRE keypad at %pR (scan_interval=%uus, row_delay=%uus%s)\\n\",\n\t\tres, keypad->row_delay, keypad->scan_interval,\n\t\tkeypad->active_low ? \", active_low\" : \"\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nspire_keypad_dt_match[] = {\n\t{ .compatible = \"ti,nspire-keypad\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, nspire_keypad_dt_match);\n\nstatic struct platform_driver nspire_keypad_driver = {\n\t.driver = {\n\t\t.name = \"nspire-keypad\",\n\t\t.of_match_table = nspire_keypad_dt_match,\n\t},\n\t.probe = nspire_keypad_probe,\n};\n\nmodule_platform_driver(nspire_keypad_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TI-NSPIRE Keypad Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}