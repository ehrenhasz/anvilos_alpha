{
  "module_name": "adc-keys.c",
  "hash_id": "1af6a152d62a7a74e497d9011d272e4e36515e6aebc702f8b0f1441c145f6ac1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/adc-keys.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/types.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\nstruct adc_keys_button {\n\tu32 voltage;\n\tu32 keycode;\n};\n\nstruct adc_keys_state {\n\tstruct iio_channel *channel;\n\tu32 num_keys;\n\tu32 last_key;\n\tu32 keyup_voltage;\n\tconst struct adc_keys_button *map;\n};\n\nstatic void adc_keys_poll(struct input_dev *input)\n{\n\tstruct adc_keys_state *st = input_get_drvdata(input);\n\tint i, value, ret;\n\tu32 diff, closest = 0xffffffff;\n\tint keycode = 0;\n\n\tret = iio_read_channel_processed(st->channel, &value);\n\tif (unlikely(ret < 0)) {\n\t\t \n\t\tvalue = st->keyup_voltage;\n\t} else {\n\t\tfor (i = 0; i < st->num_keys; i++) {\n\t\t\tdiff = abs(st->map[i].voltage - value);\n\t\t\tif (diff < closest) {\n\t\t\t\tclosest = diff;\n\t\t\t\tkeycode = st->map[i].keycode;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (abs(st->keyup_voltage - value) < closest)\n\t\tkeycode = 0;\n\n\tif (st->last_key && st->last_key != keycode)\n\t\tinput_report_key(input, st->last_key, 0);\n\n\tif (keycode)\n\t\tinput_report_key(input, keycode, 1);\n\n\tinput_sync(input);\n\tst->last_key = keycode;\n}\n\nstatic int adc_keys_load_keymap(struct device *dev, struct adc_keys_state *st)\n{\n\tstruct adc_keys_button *map;\n\tstruct fwnode_handle *child;\n\tint i;\n\n\tst->num_keys = device_get_child_node_count(dev);\n\tif (st->num_keys == 0) {\n\t\tdev_err(dev, \"keymap is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmap = devm_kmalloc_array(dev, st->num_keys, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdevice_for_each_child_node(dev, child) {\n\t\tif (fwnode_property_read_u32(child, \"press-threshold-microvolt\",\n\t\t\t\t\t     &map[i].voltage)) {\n\t\t\tdev_err(dev, \"Key with invalid or missing voltage\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmap[i].voltage /= 1000;\n\n\t\tif (fwnode_property_read_u32(child, \"linux,code\",\n\t\t\t\t\t     &map[i].keycode)) {\n\t\t\tdev_err(dev, \"Key with invalid or missing linux,code\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tst->map = map;\n\treturn 0;\n}\n\nstatic int adc_keys_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct adc_keys_state *st;\n\tstruct input_dev *input;\n\tenum iio_chan_type type;\n\tint i, value;\n\tint error;\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->channel = devm_iio_channel_get(dev, \"buttons\");\n\tif (IS_ERR(st->channel))\n\t\treturn PTR_ERR(st->channel);\n\n\tif (!st->channel->indio_dev)\n\t\treturn -ENXIO;\n\n\terror = iio_get_channel_type(st->channel, &type);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (type != IIO_VOLTAGE) {\n\t\tdev_err(dev, \"Incompatible channel type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(dev, \"keyup-threshold-microvolt\",\n\t\t\t\t     &st->keyup_voltage)) {\n\t\tdev_err(dev, \"Invalid or missing keyup voltage\\n\");\n\t\treturn -EINVAL;\n\t}\n\tst->keyup_voltage /= 1000;\n\n\terror = adc_keys_load_keymap(dev, st);\n\tif (error)\n\t\treturn error;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(input, st);\n\n\tinput->name = pdev->name;\n\tinput->phys = \"adc-keys/input0\";\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = 0x0100;\n\n\t__set_bit(EV_KEY, input->evbit);\n\tfor (i = 0; i < st->num_keys; i++)\n\t\t__set_bit(st->map[i].keycode, input->keybit);\n\n\tif (device_property_read_bool(dev, \"autorepeat\"))\n\t\t__set_bit(EV_REP, input->evbit);\n\n\n\terror = input_setup_polling(input, adc_keys_poll);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to set up polling: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (!device_property_read_u32(dev, \"poll-interval\", &value))\n\t\tinput_set_poll_interval(input, value);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id adc_keys_of_match[] = {\n\t{ .compatible = \"adc-keys\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adc_keys_of_match);\n#endif\n\nstatic struct platform_driver adc_keys_driver = {\n\t.driver = {\n\t\t.name = \"adc_keys\",\n\t\t.of_match_table = of_match_ptr(adc_keys_of_match),\n\t},\n\t.probe = adc_keys_probe,\n};\nmodule_platform_driver(adc_keys_driver);\n\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Input driver for resistor ladder connected on ADC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}