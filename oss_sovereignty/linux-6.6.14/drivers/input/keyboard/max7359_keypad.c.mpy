{
  "module_name": "max7359_keypad.c",
  "hash_id": "ac7d111b984616f32007830ce533d668a089ef2ea4324777b17359822971c9d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/max7359_keypad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n\n#define MAX7359_MAX_KEY_ROWS\t8\n#define MAX7359_MAX_KEY_COLS\t8\n#define MAX7359_MAX_KEY_NUM\t(MAX7359_MAX_KEY_ROWS * MAX7359_MAX_KEY_COLS)\n#define MAX7359_ROW_SHIFT\t3\n\n \n#define MAX7359_REG_KEYFIFO\t0x00\n#define MAX7359_REG_CONFIG\t0x01\n#define MAX7359_REG_DEBOUNCE\t0x02\n#define MAX7359_REG_INTERRUPT\t0x03\n#define MAX7359_REG_PORTS\t0x04\n#define MAX7359_REG_KEYREP\t0x05\n#define MAX7359_REG_SLEEP\t0x06\n\n \n#define MAX7359_CFG_SLEEP\t(1 << 7)\n#define MAX7359_CFG_INTERRUPT\t(1 << 5)\n#define MAX7359_CFG_KEY_RELEASE\t(1 << 3)\n#define MAX7359_CFG_WAKEUP\t(1 << 1)\n#define MAX7359_CFG_TIMEOUT\t(1 << 0)\n\n \n#define MAX7359_AUTOSLEEP_8192\t0x01\n#define MAX7359_AUTOSLEEP_4096\t0x02\n#define MAX7359_AUTOSLEEP_2048\t0x03\n#define MAX7359_AUTOSLEEP_1024\t0x04\n#define MAX7359_AUTOSLEEP_512\t0x05\n#define MAX7359_AUTOSLEEP_256\t0x06\n\nstruct max7359_keypad {\n\t \n\tunsigned short keycodes[MAX7359_MAX_KEY_NUM];\n\n\tstruct input_dev *input_dev;\n\tstruct i2c_client *client;\n};\n\nstatic int max7359_write_reg(struct i2c_client *client, u8 reg, u8 val)\n{\n\tint ret = i2c_smbus_write_byte_data(client, reg, val);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, val 0x%x, err %d\\n\",\n\t\t\t__func__, reg, val, ret);\n\treturn ret;\n}\n\nstatic int max7359_read_reg(struct i2c_client *client, int reg)\n{\n\tint ret = i2c_smbus_read_byte_data(client, reg);\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"%s: reg 0x%x, err %d\\n\",\n\t\t\t__func__, reg, ret);\n\treturn ret;\n}\n\n \nstatic irqreturn_t max7359_interrupt(int irq, void *dev_id)\n{\n\tstruct max7359_keypad *keypad = dev_id;\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tint val, row, col, release, code;\n\n\tval = max7359_read_reg(keypad->client, MAX7359_REG_KEYFIFO);\n\trow = val & 0x7;\n\tcol = (val >> 3) & 0x7;\n\trelease = val & 0x40;\n\n\tcode = MATRIX_SCAN_CODE(row, col, MAX7359_ROW_SHIFT);\n\n\tdev_dbg(&keypad->client->dev,\n\t\t\"key[%d:%d] %s\\n\", row, col, release ? \"release\" : \"press\");\n\n\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\tinput_report_key(input_dev, keypad->keycodes[code], !release);\n\tinput_sync(input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic inline void max7359_fall_deepsleep(struct i2c_client *client)\n{\n\tmax7359_write_reg(client, MAX7359_REG_SLEEP, MAX7359_AUTOSLEEP_8192);\n}\n\n \nstatic inline void max7359_take_catnap(struct i2c_client *client)\n{\n\tmax7359_write_reg(client, MAX7359_REG_SLEEP, MAX7359_AUTOSLEEP_256);\n}\n\nstatic int max7359_open(struct input_dev *dev)\n{\n\tstruct max7359_keypad *keypad = input_get_drvdata(dev);\n\n\tmax7359_take_catnap(keypad->client);\n\n\treturn 0;\n}\n\nstatic void max7359_close(struct input_dev *dev)\n{\n\tstruct max7359_keypad *keypad = input_get_drvdata(dev);\n\n\tmax7359_fall_deepsleep(keypad->client);\n}\n\nstatic void max7359_initialize(struct i2c_client *client)\n{\n\tmax7359_write_reg(client, MAX7359_REG_CONFIG,\n\t\tMAX7359_CFG_KEY_RELEASE |  \n\t\tMAX7359_CFG_WAKEUP);  \n\n\t \n\tmax7359_write_reg(client, MAX7359_REG_DEBOUNCE, 0x1F);\n\n\t \n\tmax7359_write_reg(client, MAX7359_REG_INTERRUPT, 0x01);\n\n\tmax7359_fall_deepsleep(client);\n}\n\nstatic int max7359_probe(struct i2c_client *client)\n{\n\tconst struct matrix_keymap_data *keymap_data =\n\t\t\tdev_get_platdata(&client->dev);\n\tstruct max7359_keypad *keypad;\n\tstruct input_dev *input_dev;\n\tint ret;\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"The irq number should not be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = max7359_read_reg(client, MAX7359_REG_KEYFIFO);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to detect device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&client->dev, \"keys FIFO is 0x%02x\\n\", ret);\n\n\tkeypad = devm_kzalloc(&client->dev, sizeof(struct max7359_keypad),\n\t\t\t      GFP_KERNEL);\n\tif (!keypad) {\n\t\tdev_err(&client->dev, \"failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad->client = client;\n\tkeypad->input_dev = input_dev;\n\n\tinput_dev->name = client->name;\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->open = max7359_open;\n\tinput_dev->close = max7359_close;\n\tinput_dev->dev.parent = &client->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\tinput_dev->keycodesize = sizeof(keypad->keycodes[0]);\n\tinput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\n\tinput_dev->keycode = keypad->keycodes;\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tinput_set_drvdata(input_dev, keypad);\n\n\terror = matrix_keypad_build_keymap(keymap_data, NULL,\n\t\t\t\t\t   MAX7359_MAX_KEY_ROWS,\n\t\t\t\t\t   MAX7359_MAX_KEY_COLS,\n\t\t\t\t\t   keypad->keycodes,\n\t\t\t\t\t   input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t  max7359_interrupt,\n\t\t\t\t\t  IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t  client->name, keypad);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tmax7359_initialize(client);\n\n\tdevice_init_wakeup(&client->dev, 1);\n\n\treturn 0;\n}\n\nstatic int max7359_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tmax7359_fall_deepsleep(client);\n\n\tif (device_may_wakeup(&client->dev))\n\t\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic int max7359_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (device_may_wakeup(&client->dev))\n\t\tdisable_irq_wake(client->irq);\n\n\t \n\tmax7359_take_catnap(client);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max7359_pm, max7359_suspend, max7359_resume);\n\nstatic const struct i2c_device_id max7359_ids[] = {\n\t{ \"max7359\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max7359_ids);\n\nstatic struct i2c_driver max7359_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max7359\",\n\t\t.pm   = pm_sleep_ptr(&max7359_pm),\n\t},\n\t.probe\t\t= max7359_probe,\n\t.id_table\t= max7359_ids,\n};\n\nmodule_i2c_driver(max7359_i2c_driver);\n\nMODULE_AUTHOR(\"Kim Kyuwon <q1.kim@samsung.com>\");\nMODULE_DESCRIPTION(\"MAX7359 Key Switch Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}