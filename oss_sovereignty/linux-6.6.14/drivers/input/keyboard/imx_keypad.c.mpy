{
  "module_name": "imx_keypad.c",
  "hash_id": "9073ee27c550c1ee72429b4d78b88e792d77e4c8eff978d63990497df616cf86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/imx_keypad.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n \n#define KPCR\t\t0x00  \n\n#define KPSR\t\t0x02  \n#define KBD_STAT_KPKD\t(0x1 << 0)  \n#define KBD_STAT_KPKR\t(0x1 << 1)  \n#define KBD_STAT_KDSC\t(0x1 << 2)  \n#define KBD_STAT_KRSS\t(0x1 << 3)  \n#define KBD_STAT_KDIE\t(0x1 << 8)  \n#define KBD_STAT_KRIE\t(0x1 << 9)  \n#define KBD_STAT_KPPEN\t(0x1 << 10)  \n\n#define KDDR\t\t0x04  \n#define KPDR\t\t0x06  \n\n#define MAX_MATRIX_KEY_ROWS\t8\n#define MAX_MATRIX_KEY_COLS\t8\n#define MATRIX_ROW_SHIFT\t3\n\n#define MAX_MATRIX_KEY_NUM\t(MAX_MATRIX_KEY_ROWS * MAX_MATRIX_KEY_COLS)\n\nstruct imx_keypad {\n\n\tstruct clk *clk;\n\tstruct input_dev *input_dev;\n\tvoid __iomem *mmio_base;\n\n\tint\t\t\tirq;\n\tstruct timer_list\tcheck_matrix_timer;\n\n\t \n#define IMX_KEYPAD_SCANS_FOR_STABILITY 3\n\tint\t\t\tstable_count;\n\n\tbool\t\t\tenabled;\n\n\t \n\tunsigned short\t\trows_en_mask;\n\tunsigned short\t\tcols_en_mask;\n\n\tunsigned short\t\tkeycodes[MAX_MATRIX_KEY_NUM];\n\n\t \n\tunsigned short\t\tmatrix_stable_state[MAX_MATRIX_KEY_COLS];\n\tunsigned short\t\tmatrix_unstable_state[MAX_MATRIX_KEY_COLS];\n};\n\n \nstatic void imx_keypad_scan_matrix(struct imx_keypad *keypad,\n\t\t\t\t  unsigned short *matrix_volatile_state)\n{\n\tint col;\n\tunsigned short reg_val;\n\n\tfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\n\t\tif ((keypad->cols_en_mask & (1 << col)) == 0)\n\t\t\tcontinue;\n\t\t \n\t\treg_val = readw(keypad->mmio_base + KPDR);\n\t\treg_val |= 0xff00;\n\t\twritew(reg_val, keypad->mmio_base + KPDR);\n\n\t\treg_val = readw(keypad->mmio_base + KPCR);\n\t\treg_val &= ~((keypad->cols_en_mask & 0xff) << 8);\n\t\twritew(reg_val, keypad->mmio_base + KPCR);\n\n\t\tudelay(2);\n\n\t\treg_val = readw(keypad->mmio_base + KPCR);\n\t\treg_val |= (keypad->cols_en_mask & 0xff) << 8;\n\t\twritew(reg_val, keypad->mmio_base + KPCR);\n\n\t\t \n\t\treg_val = readw(keypad->mmio_base + KPDR);\n\t\treg_val &= ~(1 << (8 + col));\n\t\twritew(reg_val, keypad->mmio_base + KPDR);\n\n\t\t \n\t\tudelay(5);\n\n\t\t \n\t\treg_val = readw(keypad->mmio_base + KPDR);\n\t\tmatrix_volatile_state[col] = (~reg_val) & keypad->rows_en_mask;\n\t}\n\n\t \n\treg_val = readw(keypad->mmio_base + KPDR);\n\treg_val &= 0x00ff;\n\twritew(reg_val, keypad->mmio_base + KPDR);\n}\n\n \nstatic void imx_keypad_fire_events(struct imx_keypad *keypad,\n\t\t\t\t   unsigned short *matrix_volatile_state)\n{\n\tstruct input_dev *input_dev = keypad->input_dev;\n\tint row, col;\n\n\tfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\n\t\tunsigned short bits_changed;\n\t\tint code;\n\n\t\tif ((keypad->cols_en_mask & (1 << col)) == 0)\n\t\t\tcontinue;  \n\n\t\tbits_changed = keypad->matrix_stable_state[col] ^\n\t\t\t\t\t\tmatrix_volatile_state[col];\n\n\t\tif (bits_changed == 0)\n\t\t\tcontinue;  \n\n\t\tfor (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {\n\t\t\tif ((keypad->rows_en_mask & (1 << row)) == 0)\n\t\t\t\tcontinue;  \n\t\t\tif ((bits_changed & (1 << row)) == 0)\n\t\t\t\tcontinue;  \n\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);\n\t\t\tinput_event(input_dev, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(input_dev, keypad->keycodes[code],\n\t\t\t\tmatrix_volatile_state[col] & (1 << row));\n\t\t\tdev_dbg(&input_dev->dev, \"Event code: %d, val: %d\",\n\t\t\t\tkeypad->keycodes[code],\n\t\t\t\tmatrix_volatile_state[col] & (1 << row));\n\t\t}\n\t}\n\tinput_sync(input_dev);\n}\n\n \nstatic void imx_keypad_check_for_events(struct timer_list *t)\n{\n\tstruct imx_keypad *keypad = from_timer(keypad, t, check_matrix_timer);\n\tunsigned short matrix_volatile_state[MAX_MATRIX_KEY_COLS];\n\tunsigned short reg_val;\n\tbool state_changed, is_zero_matrix;\n\tint i;\n\n\tmemset(matrix_volatile_state, 0, sizeof(matrix_volatile_state));\n\n\timx_keypad_scan_matrix(keypad, matrix_volatile_state);\n\n\tstate_changed = false;\n\tfor (i = 0; i < MAX_MATRIX_KEY_COLS; i++) {\n\t\tif ((keypad->cols_en_mask & (1 << i)) == 0)\n\t\t\tcontinue;\n\n\t\tif (keypad->matrix_unstable_state[i] ^ matrix_volatile_state[i]) {\n\t\t\tstate_changed = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (state_changed) {\n\t\tmemcpy(keypad->matrix_unstable_state, matrix_volatile_state,\n\t\t\tsizeof(matrix_volatile_state));\n\t\tkeypad->stable_count = 0;\n\t} else\n\t\tkeypad->stable_count++;\n\n\t \n\tif (keypad->stable_count < IMX_KEYPAD_SCANS_FOR_STABILITY) {\n\t\tmod_timer(&keypad->check_matrix_timer,\n\t\t\t  jiffies + msecs_to_jiffies(10));\n\t\treturn;\n\t}\n\n\t \n\tif (keypad->stable_count == IMX_KEYPAD_SCANS_FOR_STABILITY) {\n\t\timx_keypad_fire_events(keypad, matrix_volatile_state);\n\n\t\tmemcpy(keypad->matrix_stable_state, matrix_volatile_state,\n\t\t\tsizeof(matrix_volatile_state));\n\t}\n\n\tis_zero_matrix = true;\n\tfor (i = 0; i < MAX_MATRIX_KEY_COLS; i++) {\n\t\tif (matrix_volatile_state[i] != 0) {\n\t\t\tis_zero_matrix = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tif (is_zero_matrix) {\n\t\t \n\t\treg_val = readw(keypad->mmio_base + KPSR);\n\t\treg_val |= KBD_STAT_KPKD | KBD_STAT_KDSC;\n\t\twritew(reg_val, keypad->mmio_base + KPSR);\n\n\t\treg_val = readw(keypad->mmio_base + KPSR);\n\t\treg_val |= KBD_STAT_KDIE;\n\t\treg_val &= ~KBD_STAT_KRIE;\n\t\twritew(reg_val, keypad->mmio_base + KPSR);\n\t} else {\n\t\t \n\t\tmod_timer(&keypad->check_matrix_timer,\n\t\t\t  jiffies + msecs_to_jiffies(60));\n\n\t\treg_val = readw(keypad->mmio_base + KPSR);\n\t\treg_val |= KBD_STAT_KPKR | KBD_STAT_KRSS;\n\t\twritew(reg_val, keypad->mmio_base + KPSR);\n\n\t\treg_val = readw(keypad->mmio_base + KPSR);\n\t\treg_val |= KBD_STAT_KRIE;\n\t\treg_val &= ~KBD_STAT_KDIE;\n\t\twritew(reg_val, keypad->mmio_base + KPSR);\n\t}\n}\n\nstatic irqreturn_t imx_keypad_irq_handler(int irq, void *dev_id)\n{\n\tstruct imx_keypad *keypad = dev_id;\n\tunsigned short reg_val;\n\n\treg_val = readw(keypad->mmio_base + KPSR);\n\n\t \n\treg_val &= ~(KBD_STAT_KRIE | KBD_STAT_KDIE);\n\t \n\treg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD;\n\twritew(reg_val, keypad->mmio_base + KPSR);\n\n\tif (keypad->enabled) {\n\t\t \n\t\tkeypad->stable_count = 0;\n\n\t\t \n\t\tmod_timer(&keypad->check_matrix_timer,\n\t\t\t  jiffies + msecs_to_jiffies(2));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void imx_keypad_config(struct imx_keypad *keypad)\n{\n\tunsigned short reg_val;\n\n\t \n\treg_val = readw(keypad->mmio_base + KPCR);\n\treg_val |= keypad->rows_en_mask & 0xff;\t\t \n\treg_val |= (keypad->cols_en_mask & 0xff) << 8;\t \n\twritew(reg_val, keypad->mmio_base + KPCR);\n\n\t \n\treg_val = readw(keypad->mmio_base + KPDR);\n\treg_val &= 0x00ff;\n\twritew(reg_val, keypad->mmio_base + KPDR);\n\n\t \n\twritew(0xff00, keypad->mmio_base + KDDR);\n\n\t \n\treg_val = readw(keypad->mmio_base + KPSR);\n\treg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD |\n\t\t   KBD_STAT_KDSC | KBD_STAT_KRSS;\n\twritew(reg_val, keypad->mmio_base + KPSR);\n\n\t \n\treg_val |= KBD_STAT_KDIE;\n\treg_val &= ~KBD_STAT_KRIE;\n\twritew(reg_val, keypad->mmio_base + KPSR);\n}\n\nstatic void imx_keypad_inhibit(struct imx_keypad *keypad)\n{\n\tunsigned short reg_val;\n\n\t \n\treg_val = readw(keypad->mmio_base + KPSR);\n\treg_val &= ~(KBD_STAT_KRIE | KBD_STAT_KDIE);\n\treg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD;\n\twritew(reg_val, keypad->mmio_base + KPSR);\n\n\t \n\treg_val = (keypad->cols_en_mask & 0xff) << 8;\n\twritew(reg_val, keypad->mmio_base + KPCR);\n}\n\nstatic void imx_keypad_close(struct input_dev *dev)\n{\n\tstruct imx_keypad *keypad = input_get_drvdata(dev);\n\n\tdev_dbg(&dev->dev, \">%s\\n\", __func__);\n\n\t \n\tkeypad->enabled = false;\n\tsynchronize_irq(keypad->irq);\n\tdel_timer_sync(&keypad->check_matrix_timer);\n\n\timx_keypad_inhibit(keypad);\n\n\t \n\tclk_disable_unprepare(keypad->clk);\n}\n\nstatic int imx_keypad_open(struct input_dev *dev)\n{\n\tstruct imx_keypad *keypad = input_get_drvdata(dev);\n\tint error;\n\n\tdev_dbg(&dev->dev, \">%s\\n\", __func__);\n\n\t \n\terror = clk_prepare_enable(keypad->clk);\n\tif (error)\n\t\treturn error;\n\n\t \n\tkeypad->enabled = true;\n\n\timx_keypad_config(keypad);\n\n\t \n\tif ((readw(keypad->mmio_base + KPDR) & keypad->rows_en_mask) == 0) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"too many keys pressed, control pins initialisation\\n\");\n\t\tgoto open_err;\n\t}\n\n\treturn 0;\n\nopen_err:\n\timx_keypad_close(dev);\n\treturn -EIO;\n}\n\nstatic const struct of_device_id imx_keypad_of_match[] = {\n\t{ .compatible = \"fsl,imx21-kpp\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_keypad_of_match);\n\nstatic int imx_keypad_probe(struct platform_device *pdev)\n{\n\tstruct imx_keypad *keypad;\n\tstruct input_dev *input_dev;\n\tint irq, error, i, row, col;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate the input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(*keypad), GFP_KERNEL);\n\tif (!keypad) {\n\t\tdev_err(&pdev->dev, \"not enough memory for driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad->input_dev = input_dev;\n\tkeypad->irq = irq;\n\tkeypad->stable_count = 0;\n\n\ttimer_setup(&keypad->check_matrix_timer,\n\t\t    imx_keypad_check_for_events, 0);\n\n\tkeypad->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(keypad->mmio_base))\n\t\treturn PTR_ERR(keypad->mmio_base);\n\n\tkeypad->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(keypad->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get keypad clock\\n\");\n\t\treturn PTR_ERR(keypad->clk);\n\t}\n\n\t \n\tinput_dev->name = pdev->name;\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->dev.parent = &pdev->dev;\n\tinput_dev->open = imx_keypad_open;\n\tinput_dev->close = imx_keypad_close;\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   MAX_MATRIX_KEY_ROWS,\n\t\t\t\t\t   MAX_MATRIX_KEY_COLS,\n\t\t\t\t\t   keypad->keycodes, input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tfor (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {\n\t\tfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\n\t\t\ti = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);\n\t\t\tif (keypad->keycodes[i] != KEY_RESERVED) {\n\t\t\t\tkeypad->rows_en_mask |= 1 << row;\n\t\t\t\tkeypad->cols_en_mask |= 1 << col;\n\t\t\t}\n\t\t}\n\t}\n\tdev_dbg(&pdev->dev, \"enabled rows mask: %x\\n\", keypad->rows_en_mask);\n\tdev_dbg(&pdev->dev, \"enabled cols mask: %x\\n\", keypad->cols_en_mask);\n\n\t__set_bit(EV_REP, input_dev->evbit);\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tinput_set_drvdata(input_dev, keypad);\n\n\t \n\terror = clk_prepare_enable(keypad->clk);\n\tif (error)\n\t\treturn error;\n\timx_keypad_inhibit(keypad);\n\tclk_disable_unprepare(keypad->clk);\n\n\terror = devm_request_irq(&pdev->dev, irq, imx_keypad_irq_handler, 0,\n\t\t\t    pdev->name, keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, keypad);\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_kbd_noirq_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct imx_keypad *kbd = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = kbd->input_dev;\n\tunsigned short reg_val = readw(kbd->mmio_base + KPSR);\n\n\t \n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tclk_disable_unprepare(kbd->clk);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\tif (device_may_wakeup(&pdev->dev)) {\n\t\tif (reg_val & KBD_STAT_KPKD)\n\t\t\treg_val |= KBD_STAT_KRIE;\n\t\tif (reg_val & KBD_STAT_KPKR)\n\t\t\treg_val |= KBD_STAT_KDIE;\n\t\twritew(reg_val, kbd->mmio_base + KPSR);\n\n\t\tenable_irq_wake(kbd->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_kbd_noirq_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct imx_keypad *kbd = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = kbd->input_dev;\n\tint ret = 0;\n\n\tif (device_may_wakeup(&pdev->dev))\n\t\tdisable_irq_wake(kbd->irq);\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev)) {\n\t\tret = clk_prepare_enable(kbd->clk);\n\t\tif (ret)\n\t\t\tgoto err_clk;\n\t}\n\nerr_clk:\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops imx_kbd_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx_kbd_noirq_suspend, imx_kbd_noirq_resume)\n};\n\nstatic struct platform_driver imx_keypad_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"imx-keypad\",\n\t\t.pm\t= &imx_kbd_pm_ops,\n\t\t.of_match_table = imx_keypad_of_match,\n\t},\n\t.probe\t\t= imx_keypad_probe,\n};\nmodule_platform_driver(imx_keypad_driver);\n\nMODULE_AUTHOR(\"Alberto Panizzo <maramaopercheseimorto@gmail.com>\");\nMODULE_DESCRIPTION(\"IMX Keypad Port Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx-keypad\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}