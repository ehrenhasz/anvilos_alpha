{
  "module_name": "newtonkbd.c",
  "hash_id": "d61dc6658ed01ff93578d576f138beae32b6ad5d0f27fbc72d9ed7e57d69bd06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/newtonkbd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"Newton keyboard driver\"\n\nMODULE_AUTHOR(\"Justin Cormack <j.cormack@doc.ic.ac.uk>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define NKBD_KEY\t0x7f\n#define NKBD_PRESS\t0x80\n\nstatic unsigned char nkbd_keycode[128] = {\n\tKEY_A, KEY_S, KEY_D, KEY_F, KEY_H, KEY_G, KEY_Z, KEY_X,\n\tKEY_C, KEY_V, 0, KEY_B, KEY_Q, KEY_W, KEY_E, KEY_R,\n\tKEY_Y, KEY_T, KEY_1, KEY_2, KEY_3, KEY_4, KEY_6, KEY_5,\n\tKEY_EQUAL, KEY_9, KEY_7, KEY_MINUS, KEY_8, KEY_0, KEY_RIGHTBRACE, KEY_O,\n\tKEY_U, KEY_LEFTBRACE, KEY_I, KEY_P, KEY_ENTER, KEY_L, KEY_J, KEY_APOSTROPHE,\n\tKEY_K, KEY_SEMICOLON, KEY_BACKSLASH, KEY_COMMA, KEY_SLASH, KEY_N, KEY_M, KEY_DOT,\n\tKEY_TAB, KEY_SPACE, KEY_GRAVE, KEY_DELETE, 0, 0, 0, KEY_LEFTMETA,\n\tKEY_LEFTSHIFT, KEY_CAPSLOCK, KEY_LEFTALT, KEY_LEFTCTRL, KEY_RIGHTSHIFT, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\tKEY_LEFT, KEY_RIGHT, KEY_DOWN, KEY_UP, 0\n};\n\nstruct nkbd {\n\tunsigned char keycode[128];\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tchar phys[32];\n};\n\nstatic irqreturn_t nkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct nkbd *nkbd = serio_get_drvdata(serio);\n\n\t \n\tif (nkbd->keycode[data & NKBD_KEY]) {\n\t\tinput_report_key(nkbd->dev, nkbd->keycode[data & NKBD_KEY], data & NKBD_PRESS);\n\t\tinput_sync(nkbd->dev);\n\t}\n\n\telse if (data == 0xe7)  \n\t\tprintk(KERN_INFO \"input: %s on %s\\n\", nkbd->dev->name, serio->phys);\n\treturn IRQ_HANDLED;\n\n}\n\nstatic int nkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct nkbd *nkbd;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tnkbd = kzalloc(sizeof(struct nkbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!nkbd || !input_dev)\n\t\tgoto fail1;\n\n\tnkbd->serio = serio;\n\tnkbd->dev = input_dev;\n\tsnprintf(nkbd->phys, sizeof(nkbd->phys), \"%s/input0\", serio->phys);\n\tmemcpy(nkbd->keycode, nkbd_keycode, sizeof(nkbd->keycode));\n\n\tinput_dev->name = \"Newton Keyboard\";\n\tinput_dev->phys = nkbd->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_NEWTON;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\tinput_dev->keycode = nkbd->keycode;\n\tinput_dev->keycodesize = sizeof(unsigned char);\n\tinput_dev->keycodemax = ARRAY_SIZE(nkbd_keycode);\n\tfor (i = 0; i < 128; i++)\n\t\tset_bit(nkbd->keycode[i], input_dev->keybit);\n\tclear_bit(0, input_dev->keybit);\n\n\tserio_set_drvdata(serio, nkbd);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(nkbd->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(nkbd);\n\treturn err;\n}\n\nstatic void nkbd_disconnect(struct serio *serio)\n{\n\tstruct nkbd *nkbd = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(nkbd->dev);\n\tkfree(nkbd);\n}\n\nstatic const struct serio_device_id nkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_NEWTON,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, nkbd_serio_ids);\n\nstatic struct serio_driver nkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"newtonkbd\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= nkbd_serio_ids,\n\t.interrupt\t= nkbd_interrupt,\n\t.connect\t= nkbd_connect,\n\t.disconnect\t= nkbd_disconnect,\n};\n\nmodule_serio_driver(nkbd_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}