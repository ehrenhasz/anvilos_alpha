{
  "module_name": "stmpe-keypad.c",
  "hash_id": "15b9d20e3b984a36a05ac6b29f7a8f97296aefdc05bc3c28cb4300d70228c6b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/stmpe-keypad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/mfd/stmpe.h>\n\n \n#define STMPE_KPC_COL\t\t\t0x60\n#define STMPE_KPC_ROW_MSB\t\t0x61\n#define STMPE_KPC_ROW_LSB\t\t0x62\n#define STMPE_KPC_CTRL_MSB\t\t0x63\n#define STMPE_KPC_CTRL_LSB\t\t0x64\n#define STMPE_KPC_COMBI_KEY_0\t\t0x65\n#define STMPE_KPC_COMBI_KEY_1\t\t0x66\n#define STMPE_KPC_COMBI_KEY_2\t\t0x67\n#define STMPE_KPC_DATA_BYTE0\t\t0x68\n#define STMPE_KPC_DATA_BYTE1\t\t0x69\n#define STMPE_KPC_DATA_BYTE2\t\t0x6a\n#define STMPE_KPC_DATA_BYTE3\t\t0x6b\n#define STMPE_KPC_DATA_BYTE4\t\t0x6c\n\n#define STMPE_KPC_CTRL_LSB_SCAN\t\t(0x1 << 0)\n#define STMPE_KPC_CTRL_LSB_DEBOUNCE\t(0x7f << 1)\n#define STMPE_KPC_CTRL_MSB_SCAN_COUNT\t(0xf << 4)\n\n#define STMPE_KPC_ROW_MSB_ROWS\t\t0xff\n\n#define STMPE_KPC_DATA_UP\t\t(0x1 << 7)\n#define STMPE_KPC_DATA_ROW\t\t(0xf << 3)\n#define STMPE_KPC_DATA_COL\t\t(0x7 << 0)\n#define STMPE_KPC_DATA_NOKEY_MASK\t0x78\n\n#define STMPE_KEYPAD_MAX_DEBOUNCE\t127\n#define STMPE_KEYPAD_MAX_SCAN_COUNT\t15\n\n#define STMPE_KEYPAD_MAX_ROWS\t\t8\n#define STMPE_KEYPAD_MAX_COLS\t\t8\n#define STMPE_KEYPAD_ROW_SHIFT\t\t3\n#define STMPE_KEYPAD_KEYMAP_MAX_SIZE \\\n\t(STMPE_KEYPAD_MAX_ROWS * STMPE_KEYPAD_MAX_COLS)\n\n\n#define STMPE1601_NUM_DATA\t5\n#define STMPE2401_NUM_DATA\t3\n#define STMPE2403_NUM_DATA\t5\n\n \n#define MAX_NUM_DATA\t\t5\n\n \nstruct stmpe_keypad_variant {\n\tbool\t\tauto_increment;\n\tbool\t\tset_pullup;\n\tint\t\tnum_data;\n\tint\t\tnum_normal_data;\n\tint\t\tmax_cols;\n\tint\t\tmax_rows;\n\tunsigned int\tcol_gpios;\n\tunsigned int\trow_gpios;\n};\n\nstatic const struct stmpe_keypad_variant stmpe_keypad_variants[] = {\n\t[STMPE1601] = {\n\t\t.auto_increment\t\t= true,\n\t\t.num_data\t\t= STMPE1601_NUM_DATA,\n\t\t.num_normal_data\t= 3,\n\t\t.max_cols\t\t= 8,\n\t\t.max_rows\t\t= 8,\n\t\t.col_gpios\t\t= 0x000ff,\t \n\t\t.row_gpios\t\t= 0x0ff00,\t \n\t},\n\t[STMPE2401] = {\n\t\t.auto_increment\t\t= false,\n\t\t.set_pullup\t\t= true,\n\t\t.num_data\t\t= STMPE2401_NUM_DATA,\n\t\t.num_normal_data\t= 2,\n\t\t.max_cols\t\t= 8,\n\t\t.max_rows\t\t= 12,\n\t\t.col_gpios\t\t= 0x0000ff,\t \n\t\t.row_gpios\t\t= 0x1f7f00,\t \n\t},\n\t[STMPE2403] = {\n\t\t.auto_increment\t\t= true,\n\t\t.set_pullup\t\t= true,\n\t\t.num_data\t\t= STMPE2403_NUM_DATA,\n\t\t.num_normal_data\t= 3,\n\t\t.max_cols\t\t= 8,\n\t\t.max_rows\t\t= 12,\n\t\t.col_gpios\t\t= 0x0000ff,\t \n\t\t.row_gpios\t\t= 0x1fef00,\t \n\t},\n};\n\n \nstruct stmpe_keypad {\n\tstruct stmpe *stmpe;\n\tstruct input_dev *input;\n\tconst struct stmpe_keypad_variant *variant;\n\tunsigned int debounce_ms;\n\tunsigned int scan_count;\n\tbool no_autorepeat;\n\tunsigned int rows;\n\tunsigned int cols;\n\tunsigned short keymap[STMPE_KEYPAD_KEYMAP_MAX_SIZE];\n};\n\nstatic int stmpe_keypad_read_data(struct stmpe_keypad *keypad, u8 *data)\n{\n\tconst struct stmpe_keypad_variant *variant = keypad->variant;\n\tstruct stmpe *stmpe = keypad->stmpe;\n\tint ret;\n\tint i;\n\n\tif (variant->auto_increment)\n\t\treturn stmpe_block_read(stmpe, STMPE_KPC_DATA_BYTE0,\n\t\t\t\t\tvariant->num_data, data);\n\n\tfor (i = 0; i < variant->num_data; i++) {\n\t\tret = stmpe_reg_read(stmpe, STMPE_KPC_DATA_BYTE0 + i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata[i] = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t stmpe_keypad_irq(int irq, void *dev)\n{\n\tstruct stmpe_keypad *keypad = dev;\n\tstruct input_dev *input = keypad->input;\n\tconst struct stmpe_keypad_variant *variant = keypad->variant;\n\tu8 fifo[MAX_NUM_DATA];\n\tint ret;\n\tint i;\n\n\tret = stmpe_keypad_read_data(keypad, fifo);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < variant->num_normal_data; i++) {\n\t\tu8 data = fifo[i];\n\t\tint row = (data & STMPE_KPC_DATA_ROW) >> 3;\n\t\tint col = data & STMPE_KPC_DATA_COL;\n\t\tint code = MATRIX_SCAN_CODE(row, col, STMPE_KEYPAD_ROW_SHIFT);\n\t\tbool up = data & STMPE_KPC_DATA_UP;\n\n\t\tif ((data & STMPE_KPC_DATA_NOKEY_MASK)\n\t\t\t== STMPE_KPC_DATA_NOKEY_MASK)\n\t\t\tcontinue;\n\n\t\tinput_event(input, EV_MSC, MSC_SCAN, code);\n\t\tinput_report_key(input, keypad->keymap[code], !up);\n\t\tinput_sync(input);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stmpe_keypad_altfunc_init(struct stmpe_keypad *keypad)\n{\n\tconst struct stmpe_keypad_variant *variant = keypad->variant;\n\tunsigned int col_gpios = variant->col_gpios;\n\tunsigned int row_gpios = variant->row_gpios;\n\tstruct stmpe *stmpe = keypad->stmpe;\n\tu8 pureg = stmpe->regs[STMPE_IDX_GPPUR_LSB];\n\tunsigned int pins = 0;\n\tunsigned int pu_pins = 0;\n\tint ret;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < variant->max_cols; i++) {\n\t\tint num = __ffs(col_gpios);\n\n\t\tif (keypad->cols & (1 << i)) {\n\t\t\tpins |= 1 << num;\n\t\t\tpu_pins |= 1 << num;\n\t\t}\n\n\t\tcol_gpios &= ~(1 << num);\n\t}\n\n\tfor (i = 0; i < variant->max_rows; i++) {\n\t\tint num = __ffs(row_gpios);\n\n\t\tif (keypad->rows & (1 << i))\n\t\t\tpins |= 1 << num;\n\n\t\trow_gpios &= ~(1 << num);\n\t}\n\n\tret = stmpe_set_altfunc(stmpe, pins, STMPE_BLOCK_KEYPAD);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (variant->set_pullup) {\n\t\tu8 val;\n\n\t\tret = stmpe_reg_read(stmpe, pureg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval = ret & ~pu_pins;\n\t\tval |= pu_pins;\n\n\t\tret = stmpe_reg_write(stmpe, pureg, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int stmpe_keypad_chip_init(struct stmpe_keypad *keypad)\n{\n\tconst struct stmpe_keypad_variant *variant = keypad->variant;\n\tstruct stmpe *stmpe = keypad->stmpe;\n\tint ret;\n\n\tif (keypad->debounce_ms > STMPE_KEYPAD_MAX_DEBOUNCE)\n\t\treturn -EINVAL;\n\n\tif (keypad->scan_count > STMPE_KEYPAD_MAX_SCAN_COUNT)\n\t\treturn -EINVAL;\n\n\tret = stmpe_enable(stmpe, STMPE_BLOCK_KEYPAD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stmpe_keypad_altfunc_init(keypad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stmpe_reg_write(stmpe, STMPE_KPC_COL, keypad->cols);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stmpe_reg_write(stmpe, STMPE_KPC_ROW_LSB, keypad->rows);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (variant->max_rows > 8) {\n\t\tret = stmpe_set_bits(stmpe, STMPE_KPC_ROW_MSB,\n\t\t\t\t     STMPE_KPC_ROW_MSB_ROWS,\n\t\t\t\t     keypad->rows >> 8);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = stmpe_set_bits(stmpe, STMPE_KPC_CTRL_MSB,\n\t\t\t     STMPE_KPC_CTRL_MSB_SCAN_COUNT,\n\t\t\t     keypad->scan_count << 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn stmpe_set_bits(stmpe, STMPE_KPC_CTRL_LSB,\n\t\t\t      STMPE_KPC_CTRL_LSB_SCAN |\n\t\t\t      STMPE_KPC_CTRL_LSB_DEBOUNCE,\n\t\t\t      STMPE_KPC_CTRL_LSB_SCAN |\n\t\t\t      (keypad->debounce_ms << 1));\n}\n\nstatic void stmpe_keypad_fill_used_pins(struct stmpe_keypad *keypad,\n\t\t\t\t\tu32 used_rows, u32 used_cols)\n{\n\tint row, col;\n\n\tfor (row = 0; row < used_rows; row++) {\n\t\tfor (col = 0; col < used_cols; col++) {\n\t\t\tint code = MATRIX_SCAN_CODE(row, col,\n\t\t\t\t\t\t    STMPE_KEYPAD_ROW_SHIFT);\n\t\t\tif (keypad->keymap[code] != KEY_RESERVED) {\n\t\t\t\tkeypad->rows |= 1 << row;\n\t\t\t\tkeypad->cols |= 1 << col;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int stmpe_keypad_probe(struct platform_device *pdev)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct stmpe_keypad *keypad;\n\tstruct input_dev *input;\n\tu32 rows;\n\tu32 cols;\n\tint error;\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(struct stmpe_keypad),\n\t\t\t      GFP_KERNEL);\n\tif (!keypad)\n\t\treturn -ENOMEM;\n\n\tkeypad->stmpe = stmpe;\n\tkeypad->variant = &stmpe_keypad_variants[stmpe->partnum];\n\n\tof_property_read_u32(np, \"debounce-interval\", &keypad->debounce_ms);\n\tof_property_read_u32(np, \"st,scan-count\", &keypad->scan_count);\n\tkeypad->no_autorepeat = of_property_read_bool(np, \"st,no-autorepeat\");\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"STMPE keypad\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->dev.parent = &pdev->dev;\n\n\terror = matrix_keypad_parse_properties(&pdev->dev, &rows, &cols);\n\tif (error)\n\t\treturn error;\n\n\terror = matrix_keypad_build_keymap(NULL, NULL, rows, cols,\n\t\t\t\t\t   keypad->keymap, input);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_capability(input, EV_MSC, MSC_SCAN);\n\tif (!keypad->no_autorepeat)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tstmpe_keypad_fill_used_pins(keypad, rows, cols);\n\n\tkeypad->input = input;\n\n\terror = stmpe_keypad_chip_init(keypad);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\t  NULL, stmpe_keypad_irq,\n\t\t\t\t\t  IRQF_ONESHOT, \"stmpe-keypad\", keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"unable to get irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, keypad);\n\n\treturn 0;\n}\n\nstatic int stmpe_keypad_remove(struct platform_device *pdev)\n{\n\tstruct stmpe_keypad *keypad = platform_get_drvdata(pdev);\n\n\tstmpe_disable(keypad->stmpe, STMPE_BLOCK_KEYPAD);\n\n\treturn 0;\n}\n\nstatic struct platform_driver stmpe_keypad_driver = {\n\t.driver.name\t= \"stmpe-keypad\",\n\t.driver.owner\t= THIS_MODULE,\n\t.probe\t\t= stmpe_keypad_probe,\n\t.remove\t\t= stmpe_keypad_remove,\n};\nmodule_platform_driver(stmpe_keypad_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"STMPExxxx keypad driver\");\nMODULE_AUTHOR(\"Rabin Vincent <rabin.vincent@stericsson.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}