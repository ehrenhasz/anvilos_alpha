{
  "module_name": "mtk-pmic-keys.c",
  "hash_id": "484acb4068575f2669d6dc30b711ea470c57d089a43ecd1248c7ae438518afbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/mtk-pmic-keys.c",
  "human_readable_source": "\n \n\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/mt6323/registers.h>\n#include <linux/mfd/mt6331/registers.h>\n#include <linux/mfd/mt6357/registers.h>\n#include <linux/mfd/mt6358/registers.h>\n#include <linux/mfd/mt6397/core.h>\n#include <linux/mfd/mt6397/registers.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define MTK_PMIC_RST_DU_MASK\tGENMASK(9, 8)\n#define MTK_PMIC_PWRKEY_RST\tBIT(6)\n#define MTK_PMIC_HOMEKEY_RST\tBIT(5)\n\n#define MTK_PMIC_MT6331_RST_DU_MASK\tGENMASK(13, 12)\n#define MTK_PMIC_MT6331_PWRKEY_RST\tBIT(9)\n#define MTK_PMIC_MT6331_HOMEKEY_RST\tBIT(8)\n\n#define MTK_PMIC_PWRKEY_INDEX\t0\n#define MTK_PMIC_HOMEKEY_INDEX\t1\n#define MTK_PMIC_MAX_KEY_COUNT\t2\n\nstruct mtk_pmic_keys_regs {\n\tu32 deb_reg;\n\tu32 deb_mask;\n\tu32 intsel_reg;\n\tu32 intsel_mask;\n\tu32 rst_en_mask;\n};\n\n#define MTK_PMIC_KEYS_REGS(_deb_reg, _deb_mask,\t\t\\\n\t_intsel_reg, _intsel_mask, _rst_mask)\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.deb_reg\t\t= _deb_reg,\t\t\\\n\t.deb_mask\t\t= _deb_mask,\t\t\\\n\t.intsel_reg\t\t= _intsel_reg,\t\t\\\n\t.intsel_mask\t\t= _intsel_mask,\t\t\\\n\t.rst_en_mask\t\t= _rst_mask,\t\t\\\n}\n\nstruct mtk_pmic_regs {\n\tconst struct mtk_pmic_keys_regs keys_regs[MTK_PMIC_MAX_KEY_COUNT];\n\tu32 pmic_rst_reg;\n\tu32 rst_lprst_mask;  \n};\n\nstatic const struct mtk_pmic_regs mt6397_regs = {\n\t.keys_regs[MTK_PMIC_PWRKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6397_CHRSTATUS,\n\t\t0x8, MT6397_INT_RSV, 0x10, MTK_PMIC_PWRKEY_RST),\n\t.keys_regs[MTK_PMIC_HOMEKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6397_OCSTATUS2,\n\t\t0x10, MT6397_INT_RSV, 0x8, MTK_PMIC_HOMEKEY_RST),\n\t.pmic_rst_reg = MT6397_TOP_RST_MISC,\n\t.rst_lprst_mask = MTK_PMIC_RST_DU_MASK,\n};\n\nstatic const struct mtk_pmic_regs mt6323_regs = {\n\t.keys_regs[MTK_PMIC_PWRKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6323_CHRSTATUS,\n\t\t0x2, MT6323_INT_MISC_CON, 0x10, MTK_PMIC_PWRKEY_RST),\n\t.keys_regs[MTK_PMIC_HOMEKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6323_CHRSTATUS,\n\t\t0x4, MT6323_INT_MISC_CON, 0x8, MTK_PMIC_HOMEKEY_RST),\n\t.pmic_rst_reg = MT6323_TOP_RST_MISC,\n\t.rst_lprst_mask = MTK_PMIC_RST_DU_MASK,\n};\n\nstatic const struct mtk_pmic_regs mt6331_regs = {\n\t.keys_regs[MTK_PMIC_PWRKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6331_TOPSTATUS, 0x2,\n\t\t\t\t   MT6331_INT_MISC_CON, 0x4,\n\t\t\t\t   MTK_PMIC_MT6331_PWRKEY_RST),\n\t.keys_regs[MTK_PMIC_HOMEKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6331_TOPSTATUS, 0x4,\n\t\t\t\t   MT6331_INT_MISC_CON, 0x2,\n\t\t\t\t   MTK_PMIC_MT6331_HOMEKEY_RST),\n\t.pmic_rst_reg = MT6331_TOP_RST_MISC,\n\t.rst_lprst_mask = MTK_PMIC_MT6331_RST_DU_MASK,\n};\n\nstatic const struct mtk_pmic_regs mt6357_regs = {\n\t.keys_regs[MTK_PMIC_PWRKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6357_TOPSTATUS,\n\t\t\t\t   0x2, MT6357_PSC_TOP_INT_CON0, 0x5,\n\t\t\t\t   MTK_PMIC_PWRKEY_RST),\n\t.keys_regs[MTK_PMIC_HOMEKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6357_TOPSTATUS,\n\t\t\t\t   0x8, MT6357_PSC_TOP_INT_CON0, 0xa,\n\t\t\t\t   MTK_PMIC_HOMEKEY_INDEX),\n\t.pmic_rst_reg = MT6357_TOP_RST_MISC,\n\t.rst_lprst_mask = MTK_PMIC_RST_DU_MASK,\n};\n\nstatic const struct mtk_pmic_regs mt6358_regs = {\n\t.keys_regs[MTK_PMIC_PWRKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6358_TOPSTATUS,\n\t\t\t\t   0x2, MT6358_PSC_TOP_INT_CON0, 0x5,\n\t\t\t\t   MTK_PMIC_PWRKEY_RST),\n\t.keys_regs[MTK_PMIC_HOMEKEY_INDEX] =\n\t\tMTK_PMIC_KEYS_REGS(MT6358_TOPSTATUS,\n\t\t\t\t   0x8, MT6358_PSC_TOP_INT_CON0, 0xa,\n\t\t\t\t   MTK_PMIC_HOMEKEY_RST),\n\t.pmic_rst_reg = MT6358_TOP_RST_MISC,\n\t.rst_lprst_mask = MTK_PMIC_RST_DU_MASK,\n};\n\nstruct mtk_pmic_keys_info {\n\tstruct mtk_pmic_keys *keys;\n\tconst struct mtk_pmic_keys_regs *regs;\n\tunsigned int keycode;\n\tint irq;\n\tint irq_r;  \n\tbool wakeup:1;\n};\n\nstruct mtk_pmic_keys {\n\tstruct input_dev *input_dev;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mtk_pmic_keys_info keys[MTK_PMIC_MAX_KEY_COUNT];\n};\n\nenum mtk_pmic_keys_lp_mode {\n\tLP_DISABLE,\n\tLP_ONEKEY,\n\tLP_TWOKEY,\n};\n\nstatic void mtk_pmic_keys_lp_reset_setup(struct mtk_pmic_keys *keys,\n\t\t\t\t\t const struct mtk_pmic_regs *regs)\n{\n\tconst struct mtk_pmic_keys_regs *kregs_home, *kregs_pwr;\n\tu32 long_press_mode, long_press_debounce;\n\tu32 value, mask;\n\tint error;\n\n\tkregs_home = keys->keys[MTK_PMIC_HOMEKEY_INDEX].regs;\n\tkregs_pwr = keys->keys[MTK_PMIC_PWRKEY_INDEX].regs;\n\n\terror = of_property_read_u32(keys->dev->of_node, \"power-off-time-sec\",\n\t\t\t\t     &long_press_debounce);\n\tif (error)\n\t\tlong_press_debounce = 0;\n\n\tmask = regs->rst_lprst_mask;\n\tvalue = long_press_debounce << (ffs(regs->rst_lprst_mask) - 1);\n\n\terror  = of_property_read_u32(keys->dev->of_node,\n\t\t\t\t      \"mediatek,long-press-mode\",\n\t\t\t\t      &long_press_mode);\n\tif (error)\n\t\tlong_press_mode = LP_DISABLE;\n\n\tswitch (long_press_mode) {\n\tcase LP_TWOKEY:\n\t\tvalue |= kregs_home->rst_en_mask;\n\t\tfallthrough;\n\n\tcase LP_ONEKEY:\n\t\tvalue |= kregs_pwr->rst_en_mask;\n\t\tfallthrough;\n\n\tcase LP_DISABLE:\n\t\tmask |= kregs_home->rst_en_mask;\n\t\tmask |= kregs_pwr->rst_en_mask;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tregmap_update_bits(keys->regmap, regs->pmic_rst_reg, mask, value);\n}\n\nstatic irqreturn_t mtk_pmic_keys_irq_handler_thread(int irq, void *data)\n{\n\tstruct mtk_pmic_keys_info *info = data;\n\tu32 key_deb, pressed;\n\n\tregmap_read(info->keys->regmap, info->regs->deb_reg, &key_deb);\n\n\tkey_deb &= info->regs->deb_mask;\n\n\tpressed = !key_deb;\n\n\tinput_report_key(info->keys->input_dev, info->keycode, pressed);\n\tinput_sync(info->keys->input_dev);\n\n\tdev_dbg(info->keys->dev, \"(%s) key =%d using PMIC\\n\",\n\t\t pressed ? \"pressed\" : \"released\", info->keycode);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_pmic_key_setup(struct mtk_pmic_keys *keys,\n\t\tstruct mtk_pmic_keys_info *info)\n{\n\tint ret;\n\n\tinfo->keys = keys;\n\n\tret = regmap_update_bits(keys->regmap, info->regs->intsel_reg,\n\t\t\t\t info->regs->intsel_mask,\n\t\t\t\t info->regs->intsel_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(keys->dev, info->irq, NULL,\n\t\t\t\t\tmtk_pmic_keys_irq_handler_thread,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t\t\t\"mtk-pmic-keys\", info);\n\tif (ret) {\n\t\tdev_err(keys->dev, \"Failed to request IRQ: %d: %d\\n\",\n\t\t\tinfo->irq, ret);\n\t\treturn ret;\n\t}\n\n\tif (info->irq_r > 0) {\n\t\tret = devm_request_threaded_irq(keys->dev, info->irq_r, NULL,\n\t\t\t\t\t\tmtk_pmic_keys_irq_handler_thread,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t\t\t\t\"mtk-pmic-keys\", info);\n\t\tif (ret) {\n\t\t\tdev_err(keys->dev, \"Failed to request IRQ_r: %d: %d\\n\",\n\t\t\t\tinfo->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tinput_set_capability(keys->input_dev, EV_KEY, info->keycode);\n\n\treturn 0;\n}\n\nstatic int mtk_pmic_keys_suspend(struct device *dev)\n{\n\tstruct mtk_pmic_keys *keys = dev_get_drvdata(dev);\n\tint index;\n\n\tfor (index = 0; index < MTK_PMIC_MAX_KEY_COUNT; index++) {\n\t\tif (keys->keys[index].wakeup) {\n\t\t\tenable_irq_wake(keys->keys[index].irq);\n\t\t\tif (keys->keys[index].irq_r > 0)\n\t\t\t\tenable_irq_wake(keys->keys[index].irq_r);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pmic_keys_resume(struct device *dev)\n{\n\tstruct mtk_pmic_keys *keys = dev_get_drvdata(dev);\n\tint index;\n\n\tfor (index = 0; index < MTK_PMIC_MAX_KEY_COUNT; index++) {\n\t\tif (keys->keys[index].wakeup) {\n\t\t\tdisable_irq_wake(keys->keys[index].irq);\n\t\t\tif (keys->keys[index].irq_r > 0)\n\t\t\t\tdisable_irq_wake(keys->keys[index].irq_r);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mtk_pmic_keys_pm_ops, mtk_pmic_keys_suspend,\n\t\t\t\tmtk_pmic_keys_resume);\n\nstatic const struct of_device_id of_mtk_pmic_keys_match_tbl[] = {\n\t{\n\t\t.compatible = \"mediatek,mt6397-keys\",\n\t\t.data = &mt6397_regs,\n\t}, {\n\t\t.compatible = \"mediatek,mt6323-keys\",\n\t\t.data = &mt6323_regs,\n\t}, {\n\t\t.compatible = \"mediatek,mt6331-keys\",\n\t\t.data = &mt6331_regs,\n\t}, {\n\t\t.compatible = \"mediatek,mt6357-keys\",\n\t\t.data = &mt6357_regs,\n\t}, {\n\t\t.compatible = \"mediatek,mt6358-keys\",\n\t\t.data = &mt6358_regs,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, of_mtk_pmic_keys_match_tbl);\n\nstatic int mtk_pmic_keys_probe(struct platform_device *pdev)\n{\n\tint error, index = 0;\n\tunsigned int keycount;\n\tstruct mt6397_chip *pmic_chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *node = pdev->dev.of_node, *child;\n\tstatic const char *const irqnames[] = { \"powerkey\", \"homekey\" };\n\tstatic const char *const irqnames_r[] = { \"powerkey_r\", \"homekey_r\" };\n\tstruct mtk_pmic_keys *keys;\n\tconst struct mtk_pmic_regs *mtk_pmic_regs;\n\tstruct input_dev *input_dev;\n\tconst struct of_device_id *of_id =\n\t\tof_match_device(of_mtk_pmic_keys_match_tbl, &pdev->dev);\n\n\tkeys = devm_kzalloc(&pdev->dev, sizeof(*keys), GFP_KERNEL);\n\tif (!keys)\n\t\treturn -ENOMEM;\n\n\tkeys->dev = &pdev->dev;\n\tkeys->regmap = pmic_chip->regmap;\n\tmtk_pmic_regs = of_id->data;\n\n\tkeys->input_dev = input_dev = devm_input_allocate_device(keys->dev);\n\tif (!input_dev) {\n\t\tdev_err(keys->dev, \"input allocate device fail.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name = \"mtk-pmic-keys\";\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0001;\n\n\tkeycount = of_get_available_child_count(node);\n\tif (keycount > MTK_PMIC_MAX_KEY_COUNT ||\n\t    keycount > ARRAY_SIZE(irqnames)) {\n\t\tdev_err(keys->dev, \"too many keys defined (%d)\\n\", keycount);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(node, child) {\n\t\tkeys->keys[index].regs = &mtk_pmic_regs->keys_regs[index];\n\n\t\tkeys->keys[index].irq =\n\t\t\tplatform_get_irq_byname(pdev, irqnames[index]);\n\t\tif (keys->keys[index].irq < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn keys->keys[index].irq;\n\t\t}\n\n\t\tif (of_device_is_compatible(node, \"mediatek,mt6358-keys\")) {\n\t\t\tkeys->keys[index].irq_r = platform_get_irq_byname(pdev,\n\t\t\t\t\t\t\t\t\t  irqnames_r[index]);\n\n\t\t\tif (keys->keys[index].irq_r < 0) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn keys->keys[index].irq_r;\n\t\t\t}\n\t\t}\n\n\t\terror = of_property_read_u32(child,\n\t\t\t\"linux,keycodes\", &keys->keys[index].keycode);\n\t\tif (error) {\n\t\t\tdev_err(keys->dev,\n\t\t\t\t\"failed to read key:%d linux,keycode property: %d\\n\",\n\t\t\t\tindex, error);\n\t\t\tof_node_put(child);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (of_property_read_bool(child, \"wakeup-source\"))\n\t\t\tkeys->keys[index].wakeup = true;\n\n\t\terror = mtk_pmic_key_setup(keys, &keys->keys[index]);\n\t\tif (error) {\n\t\t\tof_node_put(child);\n\t\t\treturn error;\n\t\t}\n\n\t\tindex++;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"register input device failed (%d)\\n\", error);\n\t\treturn error;\n\t}\n\n\tmtk_pmic_keys_lp_reset_setup(keys, mtk_pmic_regs);\n\n\tplatform_set_drvdata(pdev, keys);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pmic_keys_pdrv = {\n\t.probe = mtk_pmic_keys_probe,\n\t.driver = {\n\t\t   .name = \"mtk-pmic-keys\",\n\t\t   .of_match_table = of_mtk_pmic_keys_match_tbl,\n\t\t   .pm = pm_sleep_ptr(&mtk_pmic_keys_pm_ops),\n\t},\n};\n\nmodule_platform_driver(pmic_keys_pdrv);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Chen Zhong <chen.zhong@mediatek.com>\");\nMODULE_DESCRIPTION(\"MTK pmic-keys driver v0.1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}