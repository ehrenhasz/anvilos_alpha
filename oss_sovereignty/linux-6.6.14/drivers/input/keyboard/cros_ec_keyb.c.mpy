{
  "module_name": "cros_ec_keyb.c",
  "hash_id": "cb6948f798167e207c288f7cd3dbbff94e2ad14fefc719cca74a2ae45c36466a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/cros_ec_keyb.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/vivaldi-fmap.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sysrq.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n\n#include <asm/unaligned.h>\n\n \nstruct cros_ec_keyb {\n\tunsigned int rows;\n\tunsigned int cols;\n\tint row_shift;\n\tconst struct matrix_keymap_data *keymap_data;\n\tbool ghost_filter;\n\tuint8_t *valid_keys;\n\tuint8_t *old_kb_state;\n\n\tstruct device *dev;\n\tstruct cros_ec_device *ec;\n\n\tstruct input_dev *idev;\n\tstruct input_dev *bs_idev;\n\tstruct notifier_block notifier;\n\n\tstruct vivaldi_data vdata;\n};\n\n \nstruct cros_ec_bs_map {\n\tunsigned int ev_type;\n\tunsigned int code;\n\tu8 bit;\n\tbool inverted;\n};\n\n \nstatic const struct cros_ec_bs_map cros_ec_keyb_bs[] = {\n\t \n\t{\n\t\t.ev_type\t= EV_KEY,\n\t\t.code\t\t= KEY_POWER,\n\t\t.bit\t\t= EC_MKBP_POWER_BUTTON,\n\t},\n\t{\n\t\t.ev_type\t= EV_KEY,\n\t\t.code\t\t= KEY_VOLUMEUP,\n\t\t.bit\t\t= EC_MKBP_VOL_UP,\n\t},\n\t{\n\t\t.ev_type\t= EV_KEY,\n\t\t.code\t\t= KEY_VOLUMEDOWN,\n\t\t.bit\t\t= EC_MKBP_VOL_DOWN,\n\t},\n\t{\n\t\t.ev_type        = EV_KEY,\n\t\t.code           = KEY_BRIGHTNESSUP,\n\t\t.bit            = EC_MKBP_BRI_UP,\n\t},\n\t{\n\t\t.ev_type        = EV_KEY,\n\t\t.code           = KEY_BRIGHTNESSDOWN,\n\t\t.bit            = EC_MKBP_BRI_DOWN,\n\t},\n\t{\n\t\t.ev_type        = EV_KEY,\n\t\t.code           = KEY_SCREENLOCK,\n\t\t.bit            = EC_MKBP_SCREEN_LOCK,\n\t},\n\n\t \n\t{\n\t\t.ev_type\t= EV_SW,\n\t\t.code\t\t= SW_LID,\n\t\t.bit\t\t= EC_MKBP_LID_OPEN,\n\t\t.inverted\t= true,\n\t},\n\t{\n\t\t.ev_type\t= EV_SW,\n\t\t.code\t\t= SW_TABLET_MODE,\n\t\t.bit\t\t= EC_MKBP_TABLET_MODE,\n\t},\n};\n\n \nstatic bool cros_ec_keyb_has_ghosting(struct cros_ec_keyb *ckdev, uint8_t *buf)\n{\n\tint col1, col2, buf1, buf2;\n\tstruct device *dev = ckdev->dev;\n\tuint8_t *valid_keys = ckdev->valid_keys;\n\n\t \n\tfor (col1 = 0; col1 < ckdev->cols; col1++) {\n\t\tbuf1 = buf[col1] & valid_keys[col1];\n\t\tfor (col2 = col1 + 1; col2 < ckdev->cols; col2++) {\n\t\t\tbuf2 = buf[col2] & valid_keys[col2];\n\t\t\tif (hweight8(buf1 & buf2) > 1) {\n\t\t\t\tdev_dbg(dev, \"ghost found at: B[%02d]:0x%02x & B[%02d]:0x%02x\",\n\t\t\t\t\tcol1, buf1, col2, buf2);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n \nstatic void cros_ec_keyb_process(struct cros_ec_keyb *ckdev,\n\t\t\t uint8_t *kb_state, int len)\n{\n\tstruct input_dev *idev = ckdev->idev;\n\tint col, row;\n\tint new_state;\n\tint old_state;\n\n\tif (ckdev->ghost_filter && cros_ec_keyb_has_ghosting(ckdev, kb_state)) {\n\t\t \n\t\tdev_dbg(ckdev->dev, \"ghosting found\\n\");\n\t\treturn;\n\t}\n\n\tfor (col = 0; col < ckdev->cols; col++) {\n\t\tfor (row = 0; row < ckdev->rows; row++) {\n\t\t\tint pos = MATRIX_SCAN_CODE(row, col, ckdev->row_shift);\n\t\t\tconst unsigned short *keycodes = idev->keycode;\n\n\t\t\tnew_state = kb_state[col] & (1 << row);\n\t\t\told_state = ckdev->old_kb_state[col] & (1 << row);\n\t\t\tif (new_state != old_state) {\n\t\t\t\tdev_dbg(ckdev->dev,\n\t\t\t\t\t\"changed: [r%d c%d]: byte %02x\\n\",\n\t\t\t\t\trow, col, new_state);\n\n\t\t\t\tinput_event(idev, EV_MSC, MSC_SCAN, pos);\n\t\t\t\tinput_report_key(idev, keycodes[pos],\n\t\t\t\t\t\t new_state);\n\t\t\t}\n\t\t}\n\t\tckdev->old_kb_state[col] = kb_state[col];\n\t}\n\tinput_sync(ckdev->idev);\n}\n\n \nstatic void cros_ec_keyb_report_bs(struct cros_ec_keyb *ckdev,\n\t\t\t\t   unsigned int ev_type, u32 mask)\n\n{\n\tstruct input_dev *idev = ckdev->bs_idev;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cros_ec_keyb_bs); i++) {\n\t\tconst struct cros_ec_bs_map *map = &cros_ec_keyb_bs[i];\n\n\t\tif (map->ev_type != ev_type)\n\t\t\tcontinue;\n\n\t\tinput_event(idev, ev_type, map->code,\n\t\t\t    !!(mask & BIT(map->bit)) ^ map->inverted);\n\t}\n\tinput_sync(idev);\n}\n\nstatic int cros_ec_keyb_work(struct notifier_block *nb,\n\t\t\t     unsigned long queued_during_suspend, void *_notify)\n{\n\tstruct cros_ec_keyb *ckdev = container_of(nb, struct cros_ec_keyb,\n\t\t\t\t\t\t  notifier);\n\tu32 val;\n\tunsigned int ev_type;\n\n\t \n\tif (queued_during_suspend && !device_may_wakeup(ckdev->dev))\n\t\treturn NOTIFY_OK;\n\n\tswitch (ckdev->ec->event_data.event_type) {\n\tcase EC_MKBP_EVENT_KEY_MATRIX:\n\t\tpm_wakeup_event(ckdev->dev, 0);\n\n\t\tif (ckdev->ec->event_size != ckdev->cols) {\n\t\t\tdev_err(ckdev->dev,\n\t\t\t\t\"Discarded incomplete key matrix event.\\n\");\n\t\t\treturn NOTIFY_OK;\n\t\t}\n\n\t\tcros_ec_keyb_process(ckdev,\n\t\t\t\t     ckdev->ec->event_data.data.key_matrix,\n\t\t\t\t     ckdev->ec->event_size);\n\t\tbreak;\n\n\tcase EC_MKBP_EVENT_SYSRQ:\n\t\tpm_wakeup_event(ckdev->dev, 0);\n\n\t\tval = get_unaligned_le32(&ckdev->ec->event_data.data.sysrq);\n\t\tdev_dbg(ckdev->dev, \"sysrq code from EC: %#x\\n\", val);\n\t\thandle_sysrq(val);\n\t\tbreak;\n\n\tcase EC_MKBP_EVENT_BUTTON:\n\tcase EC_MKBP_EVENT_SWITCH:\n\t\tpm_wakeup_event(ckdev->dev, 0);\n\n\t\tif (ckdev->ec->event_data.event_type == EC_MKBP_EVENT_BUTTON) {\n\t\t\tval = get_unaligned_le32(\n\t\t\t\t\t&ckdev->ec->event_data.data.buttons);\n\t\t\tev_type = EV_KEY;\n\t\t} else {\n\t\t\tval = get_unaligned_le32(\n\t\t\t\t\t&ckdev->ec->event_data.data.switches);\n\t\t\tev_type = EV_SW;\n\t\t}\n\t\tcros_ec_keyb_report_bs(ckdev, ev_type, val);\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic void cros_ec_keyb_compute_valid_keys(struct cros_ec_keyb *ckdev)\n{\n\tint row, col;\n\tint row_shift = ckdev->row_shift;\n\tunsigned short *keymap = ckdev->idev->keycode;\n\tunsigned short code;\n\n\tBUG_ON(ckdev->idev->keycodesize != sizeof(*keymap));\n\n\tfor (col = 0; col < ckdev->cols; col++) {\n\t\tfor (row = 0; row < ckdev->rows; row++) {\n\t\t\tcode = keymap[MATRIX_SCAN_CODE(row, col, row_shift)];\n\t\t\tif (code && (code != KEY_BATTERY))\n\t\t\t\tckdev->valid_keys[col] |= 1 << row;\n\t\t}\n\t\tdev_dbg(ckdev->dev, \"valid_keys[%02d] = 0x%02x\\n\",\n\t\t\tcol, ckdev->valid_keys[col]);\n\t}\n}\n\n \nstatic int cros_ec_keyb_info(struct cros_ec_device *ec_dev,\n\t\t\t     enum ec_mkbp_info_type info_type,\n\t\t\t     enum ec_mkbp_event event_type,\n\t\t\t     union ec_response_get_next_data *result,\n\t\t\t     size_t result_size)\n{\n\tstruct ec_params_mkbp_info *params;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(sizeof(*msg) + max_t(size_t, result_size,\n\t\t\t\t\t   sizeof(*params)), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_MKBP_INFO;\n\tmsg->version = 1;\n\tmsg->outsize = sizeof(*params);\n\tmsg->insize = result_size;\n\tparams = (struct ec_params_mkbp_info *)msg->data;\n\tparams->info_type = info_type;\n\tparams->event_type = event_type;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret == -ENOPROTOOPT) {\n\t\t \n\t\tmemset(result, 0, result_size);\n\t\tret = 0;\n\t} else if (ret < 0) {\n\t\tdev_warn(ec_dev->dev, \"Transfer error %d/%d: %d\\n\",\n\t\t\t (int)info_type, (int)event_type, ret);\n\t} else if (ret != result_size) {\n\t\tdev_warn(ec_dev->dev, \"Wrong size %d/%d: %d != %zu\\n\",\n\t\t\t (int)info_type, (int)event_type,\n\t\t\t ret, result_size);\n\t\tret = -EPROTO;\n\t} else {\n\t\tmemcpy(result, msg->data, result_size);\n\t\tret = 0;\n\t}\n\n\tkfree(msg);\n\n\treturn ret;\n}\n\n \nstatic int cros_ec_keyb_query_switches(struct cros_ec_keyb *ckdev)\n{\n\tstruct cros_ec_device *ec_dev = ckdev->ec;\n\tunion ec_response_get_next_data event_data = {};\n\tint ret;\n\n\tret = cros_ec_keyb_info(ec_dev, EC_MKBP_INFO_CURRENT,\n\t\t\t\tEC_MKBP_EVENT_SWITCH, &event_data,\n\t\t\t\tsizeof(event_data.switches));\n\tif (ret)\n\t\treturn ret;\n\n\tcros_ec_keyb_report_bs(ckdev, EV_SW,\n\t\t\t       get_unaligned_le32(&event_data.switches));\n\n\treturn 0;\n}\n\n \nstatic int cros_ec_keyb_resume(struct device *dev)\n{\n\tstruct cros_ec_keyb *ckdev = dev_get_drvdata(dev);\n\n\tif (ckdev->bs_idev)\n\t\treturn cros_ec_keyb_query_switches(ckdev);\n\n\treturn 0;\n}\n\n \nstatic int cros_ec_keyb_register_bs(struct cros_ec_keyb *ckdev,\n\t\t\t\t    bool expect_buttons_switches)\n{\n\tstruct cros_ec_device *ec_dev = ckdev->ec;\n\tstruct device *dev = ckdev->dev;\n\tstruct input_dev *idev;\n\tunion ec_response_get_next_data event_data = {};\n\tconst char *phys;\n\tu32 buttons;\n\tu32 switches;\n\tint ret;\n\tint i;\n\n\tret = cros_ec_keyb_info(ec_dev, EC_MKBP_INFO_SUPPORTED,\n\t\t\t\tEC_MKBP_EVENT_BUTTON, &event_data,\n\t\t\t\tsizeof(event_data.buttons));\n\tif (ret)\n\t\treturn ret;\n\tbuttons = get_unaligned_le32(&event_data.buttons);\n\n\tret = cros_ec_keyb_info(ec_dev, EC_MKBP_INFO_SUPPORTED,\n\t\t\t\tEC_MKBP_EVENT_SWITCH, &event_data,\n\t\t\t\tsizeof(event_data.switches));\n\tif (ret)\n\t\treturn ret;\n\tswitches = get_unaligned_le32(&event_data.switches);\n\n\tif (!buttons && !switches)\n\t\treturn expect_buttons_switches ? -EINVAL : 0;\n\n\t \n\tphys = devm_kasprintf(dev, GFP_KERNEL, \"%s/input1\", ec_dev->phys_name);\n\tif (!phys)\n\t\treturn -ENOMEM;\n\n\tidev = devm_input_allocate_device(dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->name = \"cros_ec_buttons\";\n\tidev->phys = phys;\n\t__set_bit(EV_REP, idev->evbit);\n\n\tidev->id.bustype = BUS_VIRTUAL;\n\tidev->id.version = 1;\n\tidev->id.product = 0;\n\tidev->dev.parent = dev;\n\n\tinput_set_drvdata(idev, ckdev);\n\tckdev->bs_idev = idev;\n\n\tfor (i = 0; i < ARRAY_SIZE(cros_ec_keyb_bs); i++) {\n\t\tconst struct cros_ec_bs_map *map = &cros_ec_keyb_bs[i];\n\n\t\tif ((map->ev_type == EV_KEY && (buttons & BIT(map->bit))) ||\n\t\t    (map->ev_type == EV_SW && (switches & BIT(map->bit))))\n\t\t\tinput_set_capability(idev, map->ev_type, map->code);\n\t}\n\n\tret = cros_ec_keyb_query_switches(ckdev);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot query switches\\n\");\n\t\treturn ret;\n\t}\n\n\tret = input_register_device(ckdev->bs_idev);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot register input device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void cros_ec_keyb_parse_vivaldi_physmap(struct cros_ec_keyb *ckdev)\n{\n\tu32 *physmap = ckdev->vdata.function_row_physmap;\n\tunsigned int row, col, scancode;\n\tint n_physmap;\n\tint error;\n\tint i;\n\n\tn_physmap = device_property_count_u32(ckdev->dev,\n\t\t\t\t\t      \"function-row-physmap\");\n\tif (n_physmap <= 0)\n\t\treturn;\n\n\tif (n_physmap >= VIVALDI_MAX_FUNCTION_ROW_KEYS) {\n\t\tdev_warn(ckdev->dev,\n\t\t\t \"only up to %d top row keys is supported (%d specified)\\n\",\n\t\t\t VIVALDI_MAX_FUNCTION_ROW_KEYS, n_physmap);\n\t\tn_physmap = VIVALDI_MAX_FUNCTION_ROW_KEYS;\n\t}\n\n\terror = device_property_read_u32_array(ckdev->dev,\n\t\t\t\t\t       \"function-row-physmap\",\n\t\t\t\t\t       physmap, n_physmap);\n\tif (error) {\n\t\tdev_warn(ckdev->dev,\n\t\t\t \"failed to parse function-row-physmap property: %d\\n\",\n\t\t\t error);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < n_physmap; i++) {\n\t\trow = KEY_ROW(physmap[i]);\n\t\tcol = KEY_COL(physmap[i]);\n\t\tscancode = MATRIX_SCAN_CODE(row, col, ckdev->row_shift);\n\t\tphysmap[i] = scancode;\n\t}\n\n\tckdev->vdata.num_function_row_keys = n_physmap;\n}\n\n \nstatic int cros_ec_keyb_register_matrix(struct cros_ec_keyb *ckdev)\n{\n\tstruct cros_ec_device *ec_dev = ckdev->ec;\n\tstruct device *dev = ckdev->dev;\n\tstruct input_dev *idev;\n\tconst char *phys;\n\tint err;\n\n\terr = matrix_keypad_parse_properties(dev, &ckdev->rows, &ckdev->cols);\n\tif (err)\n\t\treturn err;\n\n\tckdev->valid_keys = devm_kzalloc(dev, ckdev->cols, GFP_KERNEL);\n\tif (!ckdev->valid_keys)\n\t\treturn -ENOMEM;\n\n\tckdev->old_kb_state = devm_kzalloc(dev, ckdev->cols, GFP_KERNEL);\n\tif (!ckdev->old_kb_state)\n\t\treturn -ENOMEM;\n\n\t \n\tphys = devm_kasprintf(dev, GFP_KERNEL, \"%s/input0\", ec_dev->phys_name);\n\tif (!phys)\n\t\treturn -ENOMEM;\n\n\tidev = devm_input_allocate_device(dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->name = CROS_EC_DEV_NAME;\n\tidev->phys = phys;\n\t__set_bit(EV_REP, idev->evbit);\n\n\tidev->id.bustype = BUS_VIRTUAL;\n\tidev->id.version = 1;\n\tidev->id.product = 0;\n\tidev->dev.parent = dev;\n\n\tckdev->ghost_filter = device_property_read_bool(dev,\n\t\t\t\t\t\"google,needs-ghost-filter\");\n\n\terr = matrix_keypad_build_keymap(NULL, NULL, ckdev->rows, ckdev->cols,\n\t\t\t\t\t NULL, idev);\n\tif (err) {\n\t\tdev_err(dev, \"cannot build key matrix\\n\");\n\t\treturn err;\n\t}\n\n\tckdev->row_shift = get_count_order(ckdev->cols);\n\n\tinput_set_capability(idev, EV_MSC, MSC_SCAN);\n\tinput_set_drvdata(idev, ckdev);\n\tckdev->idev = idev;\n\tcros_ec_keyb_compute_valid_keys(ckdev);\n\tcros_ec_keyb_parse_vivaldi_physmap(ckdev);\n\n\terr = input_register_device(ckdev->idev);\n\tif (err) {\n\t\tdev_err(dev, \"cannot register input device\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t function_row_physmap_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tconst struct cros_ec_keyb *ckdev = dev_get_drvdata(dev);\n\tconst struct vivaldi_data *data = &ckdev->vdata;\n\n\treturn vivaldi_function_row_physmap_show(data, buf);\n}\n\nstatic DEVICE_ATTR_RO(function_row_physmap);\n\nstatic struct attribute *cros_ec_keyb_attrs[] = {\n\t&dev_attr_function_row_physmap.attr,\n\tNULL,\n};\n\nstatic umode_t cros_ec_keyb_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *attr,\n\t\t\t\t\t    int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cros_ec_keyb *ckdev = dev_get_drvdata(dev);\n\n\tif (attr == &dev_attr_function_row_physmap.attr &&\n\t    !ckdev->vdata.num_function_row_keys)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group cros_ec_keyb_attr_group = {\n\t.is_visible = cros_ec_keyb_attr_is_visible,\n\t.attrs = cros_ec_keyb_attrs,\n};\n\nstatic int cros_ec_keyb_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_device *ec;\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_keyb *ckdev;\n\tbool buttons_switches_only = device_get_match_data(dev);\n\tint err;\n\n\t \n\tec = dev_get_drvdata(pdev->dev.parent);\n\tif (!ec)\n\t\treturn -EPROBE_DEFER;\n\n\tckdev = devm_kzalloc(dev, sizeof(*ckdev), GFP_KERNEL);\n\tif (!ckdev)\n\t\treturn -ENOMEM;\n\n\tckdev->ec = ec;\n\tckdev->dev = dev;\n\tdev_set_drvdata(dev, ckdev);\n\n\tif (!buttons_switches_only) {\n\t\terr = cros_ec_keyb_register_matrix(ckdev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"cannot register matrix inputs: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = cros_ec_keyb_register_bs(ckdev, buttons_switches_only);\n\tif (err) {\n\t\tdev_err(dev, \"cannot register non-matrix inputs: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_device_add_group(dev, &cros_ec_keyb_attr_group);\n\tif (err) {\n\t\tdev_err(dev, \"failed to create attributes: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tckdev->notifier.notifier_call = cros_ec_keyb_work;\n\terr = blocking_notifier_chain_register(&ckdev->ec->event_notifier,\n\t\t\t\t\t       &ckdev->notifier);\n\tif (err) {\n\t\tdev_err(dev, \"cannot register notifier: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdevice_init_wakeup(ckdev->dev, true);\n\treturn 0;\n}\n\nstatic int cros_ec_keyb_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_keyb *ckdev = dev_get_drvdata(&pdev->dev);\n\n\tblocking_notifier_chain_unregister(&ckdev->ec->event_notifier,\n\t\t\t\t\t   &ckdev->notifier);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_ec_keyb_acpi_match[] = {\n\t{ \"GOOG0007\", true },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cros_ec_keyb_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cros_ec_keyb_of_match[] = {\n\t{ .compatible = \"google,cros-ec-keyb\" },\n\t{ .compatible = \"google,cros-ec-keyb-switches\", .data = (void *)true },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cros_ec_keyb_of_match);\n#endif\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cros_ec_keyb_pm_ops, NULL, cros_ec_keyb_resume);\n\nstatic struct platform_driver cros_ec_keyb_driver = {\n\t.probe = cros_ec_keyb_probe,\n\t.remove = cros_ec_keyb_remove,\n\t.driver = {\n\t\t.name = \"cros-ec-keyb\",\n\t\t.of_match_table = of_match_ptr(cros_ec_keyb_of_match),\n\t\t.acpi_match_table = ACPI_PTR(cros_ec_keyb_acpi_match),\n\t\t.pm = pm_sleep_ptr(&cros_ec_keyb_pm_ops),\n\t},\n};\n\nmodule_platform_driver(cros_ec_keyb_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChromeOS EC keyboard driver\");\nMODULE_ALIAS(\"platform:cros-ec-keyb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}