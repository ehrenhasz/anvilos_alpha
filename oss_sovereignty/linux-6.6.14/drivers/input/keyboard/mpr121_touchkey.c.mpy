{
  "module_name": "mpr121_touchkey.c",
  "hash_id": "100119792147740757c5437af0307137d6927eec772b92b53c1acfcae1c22aa3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/mpr121_touchkey.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n \n#define ELE_TOUCH_STATUS_0_ADDR\t0x0\n#define ELE_TOUCH_STATUS_1_ADDR\t0X1\n#define MHD_RISING_ADDR\t\t0x2b\n#define NHD_RISING_ADDR\t\t0x2c\n#define NCL_RISING_ADDR\t\t0x2d\n#define FDL_RISING_ADDR\t\t0x2e\n#define MHD_FALLING_ADDR\t0x2f\n#define NHD_FALLING_ADDR\t0x30\n#define NCL_FALLING_ADDR\t0x31\n#define FDL_FALLING_ADDR\t0x32\n#define ELE0_TOUCH_THRESHOLD_ADDR\t0x41\n#define ELE0_RELEASE_THRESHOLD_ADDR\t0x42\n#define AFE_CONF_ADDR\t\t\t0x5c\n#define FILTER_CONF_ADDR\t\t0x5d\n\n \n#define ELECTRODE_CONF_ADDR\t\t0x5e\n#define ELECTRODE_CONF_QUICK_CHARGE\t0x80\n#define AUTO_CONFIG_CTRL_ADDR\t\t0x7b\n#define AUTO_CONFIG_USL_ADDR\t\t0x7d\n#define AUTO_CONFIG_LSL_ADDR\t\t0x7e\n#define AUTO_CONFIG_TL_ADDR\t\t0x7f\n\n \n#define TOUCH_THRESHOLD\t\t\t0x08\n#define RELEASE_THRESHOLD\t\t0x05\n \n#define TOUCH_STATUS_MASK\t\t0xfff\n \n#define MPR121_MAX_KEY_COUNT\t\t12\n\n#define MPR121_MIN_POLL_INTERVAL\t10\n#define MPR121_MAX_POLL_INTERVAL\t200\n\nstruct mpr121_touchkey {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input_dev;\n\tunsigned int\t\tstatusbits;\n\tunsigned int\t\tkeycount;\n\tu32\t\t\tkeycodes[MPR121_MAX_KEY_COUNT];\n};\n\nstruct mpr121_init_register {\n\tint addr;\n\tu8 val;\n};\n\nstatic const struct mpr121_init_register init_reg_table[] = {\n\t{ MHD_RISING_ADDR,\t0x1 },\n\t{ NHD_RISING_ADDR,\t0x1 },\n\t{ MHD_FALLING_ADDR,\t0x1 },\n\t{ NHD_FALLING_ADDR,\t0x1 },\n\t{ NCL_FALLING_ADDR,\t0xff },\n\t{ FDL_FALLING_ADDR,\t0x02 },\n\t{ FILTER_CONF_ADDR,\t0x04 },\n\t{ AFE_CONF_ADDR,\t0x0b },\n\t{ AUTO_CONFIG_CTRL_ADDR, 0x0b },\n};\n\nstatic void mpr121_vdd_supply_disable(void *data)\n{\n\tstruct regulator *vdd_supply = data;\n\n\tregulator_disable(vdd_supply);\n}\n\nstatic struct regulator *mpr121_vdd_supply_init(struct device *dev)\n{\n\tstruct regulator *vdd_supply;\n\tint err;\n\n\tvdd_supply = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(vdd_supply)) {\n\t\tdev_err(dev, \"failed to get vdd regulator: %ld\\n\",\n\t\t\tPTR_ERR(vdd_supply));\n\t\treturn vdd_supply;\n\t}\n\n\terr = regulator_enable(vdd_supply);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable vdd regulator: %d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = devm_add_action_or_reset(dev, mpr121_vdd_supply_disable,\n\t\t\t\t       vdd_supply);\n\tif (err) {\n\t\tdev_err(dev, \"failed to add disable regulator action: %d\\n\",\n\t\t\terr);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn vdd_supply;\n}\n\nstatic void mpr_touchkey_report(struct input_dev *dev)\n{\n\tstruct mpr121_touchkey *mpr121 = input_get_drvdata(dev);\n\tstruct input_dev *input = mpr121->input_dev;\n\tstruct i2c_client *client = mpr121->client;\n\tunsigned long bit_changed;\n\tunsigned int key_num;\n\tint reg;\n\n\treg = i2c_smbus_read_byte_data(client, ELE_TOUCH_STATUS_1_ADDR);\n\tif (reg < 0) {\n\t\tdev_err(&client->dev, \"i2c read error [%d]\\n\", reg);\n\t\treturn;\n\t}\n\n\treg <<= 8;\n\treg |= i2c_smbus_read_byte_data(client, ELE_TOUCH_STATUS_0_ADDR);\n\tif (reg < 0) {\n\t\tdev_err(&client->dev, \"i2c read error [%d]\\n\", reg);\n\t\treturn;\n\t}\n\n\treg &= TOUCH_STATUS_MASK;\n\t \n\tbit_changed = reg ^ mpr121->statusbits;\n\tmpr121->statusbits = reg;\n\tfor_each_set_bit(key_num, &bit_changed, mpr121->keycount) {\n\t\tunsigned int key_val, pressed;\n\n\t\tpressed = reg & BIT(key_num);\n\t\tkey_val = mpr121->keycodes[key_num];\n\n\t\tinput_event(input, EV_MSC, MSC_SCAN, key_num);\n\t\tinput_report_key(input, key_val, pressed);\n\n\t\tdev_dbg(&client->dev, \"key %d %d %s\\n\", key_num, key_val,\n\t\t\tpressed ? \"pressed\" : \"released\");\n\n\t}\n\tinput_sync(input);\n}\n\nstatic irqreturn_t mpr_touchkey_interrupt(int irq, void *dev_id)\n{\n\tstruct mpr121_touchkey *mpr121 = dev_id;\n\n\tmpr_touchkey_report(mpr121->input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mpr121_phys_init(struct mpr121_touchkey *mpr121,\n\t\t\t    struct i2c_client *client, int vdd_uv)\n{\n\tconst struct mpr121_init_register *reg;\n\tunsigned char usl, lsl, tl, eleconf;\n\tint i, t, vdd, ret;\n\n\t \n\tfor (i = 0; i <= MPR121_MAX_KEY_COUNT; i++) {\n\t\tt = ELE0_TOUCH_THRESHOLD_ADDR + (i * 2);\n\t\tret = i2c_smbus_write_byte_data(client, t, TOUCH_THRESHOLD);\n\t\tif (ret < 0)\n\t\t\tgoto err_i2c_write;\n\t\tret = i2c_smbus_write_byte_data(client, t + 1,\n\t\t\t\t\t\tRELEASE_THRESHOLD);\n\t\tif (ret < 0)\n\t\t\tgoto err_i2c_write;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(init_reg_table); i++) {\n\t\treg = &init_reg_table[i];\n\t\tret = i2c_smbus_write_byte_data(client, reg->addr, reg->val);\n\t\tif (ret < 0)\n\t\t\tgoto err_i2c_write;\n\t}\n\n\n\t \n\tvdd = vdd_uv / 1000;\n\tusl = ((vdd - 700) * 256) / vdd;\n\tlsl = (usl * 65) / 100;\n\ttl = (usl * 90) / 100;\n\tret = i2c_smbus_write_byte_data(client, AUTO_CONFIG_USL_ADDR, usl);\n\tret |= i2c_smbus_write_byte_data(client, AUTO_CONFIG_LSL_ADDR, lsl);\n\tret |= i2c_smbus_write_byte_data(client, AUTO_CONFIG_TL_ADDR, tl);\n\n\t \n\teleconf = mpr121->keycount | ELECTRODE_CONF_QUICK_CHARGE;\n\tret |= i2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR,\n\t\t\t\t\t eleconf);\n\tif (ret != 0)\n\t\tgoto err_i2c_write;\n\n\tdev_dbg(&client->dev, \"set up with %x keys.\\n\", mpr121->keycount);\n\n\treturn 0;\n\nerr_i2c_write:\n\tdev_err(&client->dev, \"i2c write error: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mpr_touchkey_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct regulator *vdd_supply;\n\tint vdd_uv;\n\tstruct mpr121_touchkey *mpr121;\n\tstruct input_dev *input_dev;\n\tu32 poll_interval = 0;\n\tint error;\n\tint i;\n\n\tvdd_supply = mpr121_vdd_supply_init(dev);\n\tif (IS_ERR(vdd_supply))\n\t\treturn PTR_ERR(vdd_supply);\n\n\tvdd_uv = regulator_get_voltage(vdd_supply);\n\n\tmpr121 = devm_kzalloc(dev, sizeof(*mpr121), GFP_KERNEL);\n\tif (!mpr121)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tmpr121->client = client;\n\tmpr121->input_dev = input_dev;\n\tmpr121->keycount = device_property_count_u32(dev, \"linux,keycodes\");\n\tif (mpr121->keycount > MPR121_MAX_KEY_COUNT) {\n\t\tdev_err(dev, \"too many keys defined (%d)\\n\", mpr121->keycount);\n\t\treturn -EINVAL;\n\t}\n\n\terror = device_property_read_u32_array(dev, \"linux,keycodes\",\n\t\t\t\t\t       mpr121->keycodes,\n\t\t\t\t\t       mpr121->keycount);\n\tif (error) {\n\t\tdev_err(dev,\n\t\t\t\"failed to read linux,keycode property: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput_dev->name = \"Freescale MPR121 Touchkey\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->dev.parent = dev;\n\tif (device_property_read_bool(dev, \"autorepeat\"))\n\t\t__set_bit(EV_REP, input_dev->evbit);\n\tinput_set_capability(input_dev, EV_MSC, MSC_SCAN);\n\tinput_set_drvdata(input_dev, mpr121);\n\n\tinput_dev->keycode = mpr121->keycodes;\n\tinput_dev->keycodesize = sizeof(mpr121->keycodes[0]);\n\tinput_dev->keycodemax = mpr121->keycount;\n\n\tfor (i = 0; i < mpr121->keycount; i++)\n\t\tinput_set_capability(input_dev, EV_KEY, mpr121->keycodes[i]);\n\n\terror = mpr121_phys_init(mpr121, client, vdd_uv);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to init register\\n\");\n\t\treturn error;\n\t}\n\n\tdevice_property_read_u32(dev, \"poll-interval\", &poll_interval);\n\n\tif (client->irq) {\n\t\terror = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\t  mpr_touchkey_interrupt,\n\t\t\t\t\t\t  IRQF_TRIGGER_FALLING |\n\t\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t\t  dev->driver->name, mpr121);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Failed to register interrupt\\n\");\n\t\t\treturn error;\n\t\t}\n\t} else if (poll_interval) {\n\t\tif (poll_interval < MPR121_MIN_POLL_INTERVAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (poll_interval > MPR121_MAX_POLL_INTERVAL)\n\t\t\treturn -EINVAL;\n\n\t\terror = input_setup_polling(input_dev, mpr_touchkey_report);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Failed to setup polling\\n\");\n\t\t\treturn error;\n\t\t}\n\n\t\tinput_set_poll_interval(input_dev, poll_interval);\n\t\tinput_set_min_poll_interval(input_dev,\n\t\t\t\t\t    MPR121_MIN_POLL_INTERVAL);\n\t\tinput_set_max_poll_interval(input_dev,\n\t\t\t\t\t    MPR121_MAX_POLL_INTERVAL);\n\t} else {\n\t\tdev_err(dev,\n\t\t\t\"invalid IRQ number and polling not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, mpr121);\n\tdevice_init_wakeup(dev,\n\t\t\tdevice_property_read_bool(dev, \"wakeup-source\"));\n\n\treturn 0;\n}\n\nstatic int mpr_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (device_may_wakeup(&client->dev))\n\t\tenable_irq_wake(client->irq);\n\n\ti2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR, 0x00);\n\n\treturn 0;\n}\n\nstatic int mpr_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mpr121_touchkey *mpr121 = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(&client->dev))\n\t\tdisable_irq_wake(client->irq);\n\n\ti2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR,\n\t\t\t\t  mpr121->keycount);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mpr121_touchkey_pm_ops, mpr_suspend, mpr_resume);\n\nstatic const struct i2c_device_id mpr121_id[] = {\n\t{ \"mpr121_touchkey\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mpr121_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mpr121_touchkey_dt_match_table[] = {\n\t{ .compatible = \"fsl,mpr121-touchkey\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mpr121_touchkey_dt_match_table);\n#endif\n\nstatic struct i2c_driver mpr_touchkey_driver = {\n\t.driver = {\n\t\t.name\t= \"mpr121\",\n\t\t.pm\t= pm_sleep_ptr(&mpr121_touchkey_pm_ops),\n\t\t.of_match_table = of_match_ptr(mpr121_touchkey_dt_match_table),\n\t},\n\t.id_table\t= mpr121_id,\n\t.probe\t\t= mpr_touchkey_probe,\n};\n\nmodule_i2c_driver(mpr_touchkey_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Zhang Jiejing <jiejing.zhang@freescale.com>\");\nMODULE_DESCRIPTION(\"Touch Key driver for Freescale MPR121 Chip\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}