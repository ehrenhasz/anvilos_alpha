{
  "module_name": "mt6779-keypad.c",
  "hash_id": "c4c1856210de3118dad6fded4e66d6822caf53133806abc8a5221674a8e88c96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/mt6779-keypad.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define MTK_KPD_NAME\t\t\"mt6779-keypad\"\n#define MTK_KPD_MEM\t\t0x0004\n#define MTK_KPD_DEBOUNCE\t0x0018\n#define MTK_KPD_DEBOUNCE_MASK\tGENMASK(13, 0)\n#define MTK_KPD_DEBOUNCE_MAX_MS\t256\n#define MTK_KPD_SEL\t\t0x0020\n#define MTK_KPD_SEL_DOUBLE_KP_MODE\tBIT(0)\n#define MTK_KPD_SEL_COL\tGENMASK(15, 10)\n#define MTK_KPD_SEL_ROW\tGENMASK(9, 4)\n#define MTK_KPD_SEL_COLMASK(c)\tGENMASK((c) + 9, 10)\n#define MTK_KPD_SEL_ROWMASK(r)\tGENMASK((r) + 3, 4)\n#define MTK_KPD_NUM_MEMS\t5\n#define MTK_KPD_NUM_BITS\t136\t \n\nstruct mt6779_keypad {\n\tstruct regmap *regmap;\n\tstruct input_dev *input_dev;\n\tstruct clk *clk;\n\tu32 n_rows;\n\tu32 n_cols;\n\tvoid (*calc_row_col)(unsigned int key,\n\t\t\t     unsigned int *row, unsigned int *col);\n\tDECLARE_BITMAP(keymap_state, MTK_KPD_NUM_BITS);\n};\n\nstatic const struct regmap_config mt6779_keypad_regmap_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = sizeof(u32),\n\t.max_register = 36,\n};\n\nstatic irqreturn_t mt6779_keypad_irq_handler(int irq, void *dev_id)\n{\n\tstruct mt6779_keypad *keypad = dev_id;\n\tconst unsigned short *keycode = keypad->input_dev->keycode;\n\tDECLARE_BITMAP(new_state, MTK_KPD_NUM_BITS);\n\tDECLARE_BITMAP(change, MTK_KPD_NUM_BITS);\n\tunsigned int bit_nr, key;\n\tunsigned int row, col;\n\tunsigned int scancode;\n\tunsigned int row_shift = get_count_order(keypad->n_cols);\n\tbool pressed;\n\n\tregmap_bulk_read(keypad->regmap, MTK_KPD_MEM,\n\t\t\t new_state, MTK_KPD_NUM_MEMS);\n\n\tbitmap_xor(change, new_state, keypad->keymap_state, MTK_KPD_NUM_BITS);\n\n\tfor_each_set_bit(bit_nr, change, MTK_KPD_NUM_BITS) {\n\t\t \n\t\tif (bit_nr % 32 >= 16)\n\t\t\tcontinue;\n\n\t\tkey = bit_nr / 32 * 16 + bit_nr % 32;\n\t\tkeypad->calc_row_col(key, &row, &col);\n\n\t\tscancode = MATRIX_SCAN_CODE(row, col, row_shift);\n\t\t \n\t\tpressed = !test_bit(bit_nr, new_state);\n\t\tdev_dbg(&keypad->input_dev->dev, \"%s\",\n\t\t\tpressed ? \"pressed\" : \"released\");\n\n\t\tinput_event(keypad->input_dev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_report_key(keypad->input_dev, keycode[scancode], pressed);\n\t\tinput_sync(keypad->input_dev);\n\n\t\tdev_dbg(&keypad->input_dev->dev,\n\t\t\t\"report Linux keycode = %d\\n\", keycode[scancode]);\n\t}\n\n\tbitmap_copy(keypad->keymap_state, new_state, MTK_KPD_NUM_BITS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mt6779_keypad_clk_disable(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void mt6779_keypad_calc_row_col_single(unsigned int key,\n\t\t\t\t\t      unsigned int *row,\n\t\t\t\t\t      unsigned int *col)\n{\n\t*row = key / 9;\n\t*col = key % 9;\n}\n\nstatic void mt6779_keypad_calc_row_col_double(unsigned int key,\n\t\t\t\t\t      unsigned int *row,\n\t\t\t\t\t      unsigned int *col)\n{\n\t*row = key / 13;\n\t*col = (key % 13) / 2;\n}\n\nstatic int mt6779_keypad_pdrv_probe(struct platform_device *pdev)\n{\n\tstruct mt6779_keypad *keypad;\n\tvoid __iomem *base;\n\tint irq;\n\tu32 debounce;\n\tu32 keys_per_group;\n\tbool wakeup;\n\tint error;\n\n\tkeypad = devm_kzalloc(&pdev->dev, sizeof(*keypad), GFP_KERNEL);\n\tif (!keypad)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tkeypad->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t       &mt6779_keypad_regmap_cfg);\n\tif (IS_ERR(keypad->regmap)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"regmap init failed:%pe\\n\", keypad->regmap);\n\t\treturn PTR_ERR(keypad->regmap);\n\t}\n\n\tbitmap_fill(keypad->keymap_state, MTK_KPD_NUM_BITS);\n\n\tkeypad->input_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!keypad->input_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate input dev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkeypad->input_dev->name = MTK_KPD_NAME;\n\tkeypad->input_dev->id.bustype = BUS_HOST;\n\n\terror = matrix_keypad_parse_properties(&pdev->dev, &keypad->n_rows,\n\t\t\t\t\t       &keypad->n_cols);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to parse keypad params\\n\");\n\t\treturn error;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"debounce-delay-ms\",\n\t\t\t\t     &debounce))\n\t\tdebounce = 16;\n\n\tif (debounce > MTK_KPD_DEBOUNCE_MAX_MS) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Debounce time exceeds the maximum allowed time %dms\\n\",\n\t\t\tMTK_KPD_DEBOUNCE_MAX_MS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&pdev->dev, \"mediatek,keys-per-group\",\n\t\t\t\t     &keys_per_group))\n\t\tkeys_per_group = 1;\n\n\tswitch (keys_per_group) {\n\tcase 1:\n\t\tkeypad->calc_row_col = mt6779_keypad_calc_row_col_single;\n\t\tbreak;\n\tcase 2:\n\t\tkeypad->calc_row_col = mt6779_keypad_calc_row_col_double;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Invalid keys-per-group: %d\\n\", keys_per_group);\n\t\treturn -EINVAL;\n\t}\n\n\twakeup = device_property_read_bool(&pdev->dev, \"wakeup-source\");\n\n\tdev_dbg(&pdev->dev, \"n_row=%d n_col=%d debounce=%d\\n\",\n\t\tkeypad->n_rows, keypad->n_cols, debounce);\n\n\terror = matrix_keypad_build_keymap(NULL, NULL,\n\t\t\t\t\t   keypad->n_rows, keypad->n_cols,\n\t\t\t\t\t   NULL, keypad->input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to build keymap\\n\");\n\t\treturn error;\n\t}\n\n\tinput_set_capability(keypad->input_dev, EV_MSC, MSC_SCAN);\n\n\tregmap_write(keypad->regmap, MTK_KPD_DEBOUNCE,\n\t\t     (debounce * (1 << 5)) & MTK_KPD_DEBOUNCE_MASK);\n\n\tif (keys_per_group == 2)\n\t\tregmap_update_bits(keypad->regmap, MTK_KPD_SEL,\n\t\t\t\t   MTK_KPD_SEL_DOUBLE_KP_MODE,\n\t\t\t\t   MTK_KPD_SEL_DOUBLE_KP_MODE);\n\n\tregmap_update_bits(keypad->regmap, MTK_KPD_SEL, MTK_KPD_SEL_ROW,\n\t\t\t   MTK_KPD_SEL_ROWMASK(keypad->n_rows));\n\tregmap_update_bits(keypad->regmap, MTK_KPD_SEL, MTK_KPD_SEL_COL,\n\t\t\t   MTK_KPD_SEL_COLMASK(keypad->n_cols));\n\n\tkeypad->clk = devm_clk_get(&pdev->dev, \"kpd\");\n\tif (IS_ERR(keypad->clk))\n\t\treturn PTR_ERR(keypad->clk);\n\n\terror = clk_prepare_enable(keypad->clk);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"cannot prepare/enable keypad clock\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&pdev->dev, mt6779_keypad_clk_disable,\n\t\t\t\t\t keypad->clk);\n\tif (error)\n\t\treturn error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terror = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\t  NULL, mt6779_keypad_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT, MTK_KPD_NAME, keypad);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ#%d: %d\\n\",\n\t\t\tirq, error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(keypad->input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to register device\\n\");\n\t\treturn error;\n\t}\n\n\terror = device_init_wakeup(&pdev->dev, wakeup);\n\tif (error)\n\t\tdev_warn(&pdev->dev, \"device_init_wakeup() failed: %d\\n\",\n\t\t\t error);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mt6779_keypad_of_match[] = {\n\t{ .compatible = \"mediatek,mt6779-keypad\" },\n\t{ .compatible = \"mediatek,mt6873-keypad\" },\n\t{   }\n};\n\nstatic struct platform_driver mt6779_keypad_pdrv = {\n\t.probe = mt6779_keypad_pdrv_probe,\n\t.driver = {\n\t\t   .name = MTK_KPD_NAME,\n\t\t   .of_match_table = mt6779_keypad_of_match,\n\t},\n};\nmodule_platform_driver(mt6779_keypad_pdrv);\n\nMODULE_AUTHOR(\"Mediatek Corporation\");\nMODULE_DESCRIPTION(\"MTK Keypad (KPD) Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}