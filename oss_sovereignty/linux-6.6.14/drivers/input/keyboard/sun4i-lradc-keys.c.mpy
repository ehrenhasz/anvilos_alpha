{
  "module_name": "sun4i-lradc-keys.c",
  "hash_id": "94f885a11b122dcd629e99dfc9b8a532675881cd701c8f4839ab0a25f28f12cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/sun4i-lradc-keys.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/pm_wakeup.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#define LRADC_CTRL\t\t0x00\n#define LRADC_INTC\t\t0x04\n#define LRADC_INTS\t\t0x08\n#define LRADC_DATA0\t\t0x0c\n#define LRADC_DATA1\t\t0x10\n\n \n#define FIRST_CONVERT_DLY(x)\t((x) << 24)  \n#define CHAN_SELECT(x)\t\t((x) << 22)  \n#define CONTINUE_TIME_SEL(x)\t((x) << 16)  \n#define KEY_MODE_SEL(x)\t\t((x) << 12)  \n#define LEVELA_B_CNT(x)\t\t((x) << 8)   \n#define HOLD_KEY_EN(x)\t\t((x) << 7)\n#define HOLD_EN(x)\t\t((x) << 6)\n#define LEVELB_VOL(x)\t\t((x) << 4)   \n#define SAMPLE_RATE(x)\t\t((x) << 2)   \n#define ENABLE(x)\t\t((x) << 0)\n\n \n#define CHAN1_KEYUP_IRQ\t\tBIT(12)\n#define CHAN1_ALRDY_HOLD_IRQ\tBIT(11)\n#define CHAN1_HOLD_IRQ\t\tBIT(10)\n#define\tCHAN1_KEYDOWN_IRQ\tBIT(9)\n#define CHAN1_DATA_IRQ\t\tBIT(8)\n#define CHAN0_KEYUP_IRQ\t\tBIT(4)\n#define CHAN0_ALRDY_HOLD_IRQ\tBIT(3)\n#define CHAN0_HOLD_IRQ\t\tBIT(2)\n#define\tCHAN0_KEYDOWN_IRQ\tBIT(1)\n#define CHAN0_DATA_IRQ\t\tBIT(0)\n\n \nstruct lradc_variant {\n\tu8 divisor_numerator;\n\tu8 divisor_denominator;\n\tbool has_clock_reset;\n};\n\nstatic const struct lradc_variant lradc_variant_a10 = {\n\t.divisor_numerator = 2,\n\t.divisor_denominator = 3\n};\n\nstatic const struct lradc_variant r_lradc_variant_a83t = {\n\t.divisor_numerator = 3,\n\t.divisor_denominator = 4\n};\n\nstatic const struct lradc_variant lradc_variant_r329 = {\n\t.divisor_numerator = 3,\n\t.divisor_denominator = 4,\n\t.has_clock_reset = true,\n};\n\nstruct sun4i_lradc_keymap {\n\tu32 voltage;\n\tu32 keycode;\n};\n\nstruct sun4i_lradc_data {\n\tstruct device *dev;\n\tstruct input_dev *input;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *reset;\n\tstruct regulator *vref_supply;\n\tstruct sun4i_lradc_keymap *chan0_map;\n\tconst struct lradc_variant *variant;\n\tu32 chan0_map_count;\n\tu32 chan0_keycode;\n\tu32 vref;\n};\n\nstatic irqreturn_t sun4i_lradc_irq(int irq, void *dev_id)\n{\n\tstruct sun4i_lradc_data *lradc = dev_id;\n\tu32 i, ints, val, voltage, diff, keycode = 0, closest = 0xffffffff;\n\n\tints  = readl(lradc->base + LRADC_INTS);\n\n\t \n\n\tif (ints & CHAN0_KEYUP_IRQ) {\n\t\tinput_report_key(lradc->input, lradc->chan0_keycode, 0);\n\t\tlradc->chan0_keycode = 0;\n\t}\n\n\tif ((ints & CHAN0_KEYDOWN_IRQ) && lradc->chan0_keycode == 0) {\n\t\tval = readl(lradc->base + LRADC_DATA0) & 0x3f;\n\t\tvoltage = val * lradc->vref / 63;\n\n\t\tfor (i = 0; i < lradc->chan0_map_count; i++) {\n\t\t\tdiff = abs(lradc->chan0_map[i].voltage - voltage);\n\t\t\tif (diff < closest) {\n\t\t\t\tclosest = diff;\n\t\t\t\tkeycode = lradc->chan0_map[i].keycode;\n\t\t\t}\n\t\t}\n\n\t\tlradc->chan0_keycode = keycode;\n\t\tinput_report_key(lradc->input, lradc->chan0_keycode, 1);\n\t}\n\n\tinput_sync(lradc->input);\n\n\twritel(ints, lradc->base + LRADC_INTS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_lradc_open(struct input_dev *dev)\n{\n\tstruct sun4i_lradc_data *lradc = input_get_drvdata(dev);\n\tint error;\n\n\terror = regulator_enable(lradc->vref_supply);\n\tif (error)\n\t\treturn error;\n\n\terror = reset_control_deassert(lradc->reset);\n\tif (error)\n\t\tgoto err_disable_reg;\n\n\terror = clk_prepare_enable(lradc->clk);\n\tif (error)\n\t\tgoto err_assert_reset;\n\n\tlradc->vref = regulator_get_voltage(lradc->vref_supply) *\n\t\t      lradc->variant->divisor_numerator /\n\t\t      lradc->variant->divisor_denominator;\n\t \n\twritel(FIRST_CONVERT_DLY(2) | LEVELA_B_CNT(1) | HOLD_EN(1) |\n\t\tSAMPLE_RATE(0) | ENABLE(1), lradc->base + LRADC_CTRL);\n\n\twritel(CHAN0_KEYUP_IRQ | CHAN0_KEYDOWN_IRQ, lradc->base + LRADC_INTC);\n\n\treturn 0;\n\nerr_assert_reset:\n\treset_control_assert(lradc->reset);\nerr_disable_reg:\n\tregulator_disable(lradc->vref_supply);\n\n\treturn error;\n}\n\nstatic void sun4i_lradc_close(struct input_dev *dev)\n{\n\tstruct sun4i_lradc_data *lradc = input_get_drvdata(dev);\n\n\t \n\twritel(FIRST_CONVERT_DLY(2) | LEVELA_B_CNT(1) | HOLD_EN(1) |\n\t\tSAMPLE_RATE(2), lradc->base + LRADC_CTRL);\n\twritel(0, lradc->base + LRADC_INTC);\n\n\tclk_disable_unprepare(lradc->clk);\n\treset_control_assert(lradc->reset);\n\tregulator_disable(lradc->vref_supply);\n}\n\nstatic int sun4i_lradc_load_dt_keymap(struct device *dev,\n\t\t\t\t      struct sun4i_lradc_data *lradc)\n{\n\tstruct device_node *np, *pp;\n\tint i;\n\tint error;\n\n\tnp = dev->of_node;\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tlradc->chan0_map_count = of_get_child_count(np);\n\tif (lradc->chan0_map_count == 0) {\n\t\tdev_err(dev, \"keymap is missing in device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlradc->chan0_map = devm_kmalloc_array(dev, lradc->chan0_map_count,\n\t\t\t\t\t      sizeof(struct sun4i_lradc_keymap),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!lradc->chan0_map)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_child_of_node(np, pp) {\n\t\tstruct sun4i_lradc_keymap *map = &lradc->chan0_map[i];\n\t\tu32 channel;\n\n\t\terror = of_property_read_u32(pp, \"channel\", &channel);\n\t\tif (error || channel != 0) {\n\t\t\tdev_err(dev, \"%pOFn: Inval channel prop\\n\", pp);\n\t\t\tof_node_put(pp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terror = of_property_read_u32(pp, \"voltage\", &map->voltage);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"%pOFn: Inval voltage prop\\n\", pp);\n\t\t\tof_node_put(pp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terror = of_property_read_u32(pp, \"linux,code\", &map->keycode);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"%pOFn: Inval linux,code prop\\n\", pp);\n\t\t\tof_node_put(pp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun4i_lradc_probe(struct platform_device *pdev)\n{\n\tstruct sun4i_lradc_data *lradc;\n\tstruct device *dev = &pdev->dev;\n\tint error, i, irq;\n\n\tlradc = devm_kzalloc(dev, sizeof(struct sun4i_lradc_data), GFP_KERNEL);\n\tif (!lradc)\n\t\treturn -ENOMEM;\n\n\terror = sun4i_lradc_load_dt_keymap(dev, lradc);\n\tif (error)\n\t\treturn error;\n\n\tlradc->variant = of_device_get_match_data(&pdev->dev);\n\tif (!lradc->variant) {\n\t\tdev_err(&pdev->dev, \"Missing sun4i-a10-lradc-keys variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (lradc->variant->has_clock_reset) {\n\t\tlradc->clk = devm_clk_get(dev, NULL);\n\t\tif (IS_ERR(lradc->clk))\n\t\t\treturn PTR_ERR(lradc->clk);\n\n\t\tlradc->reset = devm_reset_control_get_exclusive(dev, NULL);\n\t\tif (IS_ERR(lradc->reset))\n\t\t\treturn PTR_ERR(lradc->reset);\n\t}\n\n\tlradc->vref_supply = devm_regulator_get(dev, \"vref\");\n\tif (IS_ERR(lradc->vref_supply))\n\t\treturn PTR_ERR(lradc->vref_supply);\n\n\tlradc->dev = dev;\n\tlradc->input = devm_input_allocate_device(dev);\n\tif (!lradc->input)\n\t\treturn -ENOMEM;\n\n\tlradc->input->name = pdev->name;\n\tlradc->input->phys = \"sun4i_lradc/input0\";\n\tlradc->input->open = sun4i_lradc_open;\n\tlradc->input->close = sun4i_lradc_close;\n\tlradc->input->id.bustype = BUS_HOST;\n\tlradc->input->id.vendor = 0x0001;\n\tlradc->input->id.product = 0x0001;\n\tlradc->input->id.version = 0x0100;\n\n\t__set_bit(EV_KEY, lradc->input->evbit);\n\tfor (i = 0; i < lradc->chan0_map_count; i++)\n\t\t__set_bit(lradc->chan0_map[i].keycode, lradc->input->keybit);\n\n\tinput_set_drvdata(lradc->input, lradc);\n\n\tlradc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lradc->base))\n\t\treturn PTR_ERR(lradc->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terror = devm_request_irq(dev, irq, sun4i_lradc_irq, 0,\n\t\t\t\t \"sun4i-a10-lradc-keys\", lradc);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(lradc->input);\n\tif (error)\n\t\treturn error;\n\n\tif (device_property_read_bool(dev, \"wakeup-source\")) {\n\t\terror = dev_pm_set_wake_irq(dev, irq);\n\t\tif (error)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Failed to set IRQ %d as a wake IRQ: %d\\n\",\n\t\t\t\t irq, error);\n\t\telse\n\t\t\tdevice_set_wakeup_capable(dev, true);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun4i_lradc_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-lradc-keys\",\n\t\t.data = &lradc_variant_a10 },\n\t{ .compatible = \"allwinner,sun8i-a83t-r-lradc\",\n\t\t.data = &r_lradc_variant_a83t },\n\t{ .compatible = \"allwinner,sun50i-r329-lradc\",\n\t\t.data = &lradc_variant_r329 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun4i_lradc_of_match);\n\nstatic struct platform_driver sun4i_lradc_driver = {\n\t.driver = {\n\t\t.name\t= \"sun4i-a10-lradc-keys\",\n\t\t.of_match_table = of_match_ptr(sun4i_lradc_of_match),\n\t},\n\t.probe\t= sun4i_lradc_probe,\n};\n\nmodule_platform_driver(sun4i_lradc_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sun4i low res adc attached tablet keys driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}