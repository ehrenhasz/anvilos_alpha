{
  "module_name": "sh_keysc.c",
  "hash_id": "839e7daa7faef57100e741b0b34a7e4484dfcdfebc42fc0623cd9b25ebd651fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/sh_keysc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/input/sh_keysc.h>\n#include <linux/bitmap.h>\n#include <linux/pm_runtime.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char kymd, keyout, keyin;\n} sh_keysc_mode[] = {\n\t[SH_KEYSC_MODE_1] = { 0, 6, 5 },\n\t[SH_KEYSC_MODE_2] = { 1, 5, 6 },\n\t[SH_KEYSC_MODE_3] = { 2, 4, 7 },\n\t[SH_KEYSC_MODE_4] = { 3, 6, 6 },\n\t[SH_KEYSC_MODE_5] = { 4, 6, 7 },\n\t[SH_KEYSC_MODE_6] = { 5, 8, 8 },\n};\n\nstruct sh_keysc_priv {\n\tvoid __iomem *iomem_base;\n\tDECLARE_BITMAP(last_keys, SH_KEYSC_MAXKEYS);\n\tstruct input_dev *input;\n\tstruct sh_keysc_info pdata;\n};\n\n#define KYCR1 0\n#define KYCR2 1\n#define KYINDR 2\n#define KYOUTDR 3\n\n#define KYCR2_IRQ_LEVEL    0x10\n#define KYCR2_IRQ_DISABLED 0x00\n\nstatic unsigned long sh_keysc_read(struct sh_keysc_priv *p, int reg_nr)\n{\n\treturn ioread16(p->iomem_base + (reg_nr << 2));\n}\n\nstatic void sh_keysc_write(struct sh_keysc_priv *p, int reg_nr,\n\t\t\t   unsigned long value)\n{\n\tiowrite16(value, p->iomem_base + (reg_nr << 2));\n}\n\nstatic void sh_keysc_level_mode(struct sh_keysc_priv *p,\n\t\t\t\tunsigned long keys_set)\n{\n\tstruct sh_keysc_info *pdata = &p->pdata;\n\n\tsh_keysc_write(p, KYOUTDR, 0);\n\tsh_keysc_write(p, KYCR2, KYCR2_IRQ_LEVEL | (keys_set << 8));\n\n\tif (pdata->kycr2_delay)\n\t\tudelay(pdata->kycr2_delay);\n}\n\nstatic void sh_keysc_map_dbg(struct device *dev, unsigned long *map,\n\t\t\t     const char *str)\n{\n\tint k;\n\n\tfor (k = 0; k < BITS_TO_LONGS(SH_KEYSC_MAXKEYS); k++)\n\t\tdev_dbg(dev, \"%s[%d] 0x%lx\\n\", str, k, map[k]);\n}\n\nstatic irqreturn_t sh_keysc_isr(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\tstruct sh_keysc_priv *priv = platform_get_drvdata(pdev);\n\tstruct sh_keysc_info *pdata = &priv->pdata;\n\tint keyout_nr = sh_keysc_mode[pdata->mode].keyout;\n\tint keyin_nr = sh_keysc_mode[pdata->mode].keyin;\n\tDECLARE_BITMAP(keys, SH_KEYSC_MAXKEYS);\n\tDECLARE_BITMAP(keys0, SH_KEYSC_MAXKEYS);\n\tDECLARE_BITMAP(keys1, SH_KEYSC_MAXKEYS);\n\tunsigned char keyin_set, tmp;\n\tint i, k, n;\n\n\tdev_dbg(&pdev->dev, \"isr!\\n\");\n\n\tbitmap_fill(keys1, SH_KEYSC_MAXKEYS);\n\tbitmap_zero(keys0, SH_KEYSC_MAXKEYS);\n\n\tdo {\n\t\tbitmap_zero(keys, SH_KEYSC_MAXKEYS);\n\t\tkeyin_set = 0;\n\n\t\tsh_keysc_write(priv, KYCR2, KYCR2_IRQ_DISABLED);\n\n\t\tfor (i = 0; i < keyout_nr; i++) {\n\t\t\tn = keyin_nr * i;\n\n\t\t\t \n\t\t\tsh_keysc_write(priv, KYOUTDR, 0xffff ^ (3 << (i * 2)));\n\t\t\tudelay(pdata->delay);\n\t\t\ttmp = sh_keysc_read(priv, KYINDR);\n\n\t\t\t \n\t\t\tfor (k = 0; k < keyin_nr; k++) {\n\t\t\t\tif (tmp & (1 << k))\n\t\t\t\t\t__set_bit(n + k, keys);\n\t\t\t}\n\n\t\t\t \n\t\t\tkeyin_set |= tmp ^ ((1 << keyin_nr) - 1);\n\t\t}\n\n\t\tsh_keysc_level_mode(priv, keyin_set);\n\n\t\tbitmap_complement(keys, keys, SH_KEYSC_MAXKEYS);\n\t\tbitmap_and(keys1, keys1, keys, SH_KEYSC_MAXKEYS);\n\t\tbitmap_or(keys0, keys0, keys, SH_KEYSC_MAXKEYS);\n\n\t\tsh_keysc_map_dbg(&pdev->dev, keys, \"keys\");\n\n\t} while (sh_keysc_read(priv, KYCR2) & 0x01);\n\n\tsh_keysc_map_dbg(&pdev->dev, priv->last_keys, \"last_keys\");\n\tsh_keysc_map_dbg(&pdev->dev, keys0, \"keys0\");\n\tsh_keysc_map_dbg(&pdev->dev, keys1, \"keys1\");\n\n\tfor (i = 0; i < SH_KEYSC_MAXKEYS; i++) {\n\t\tk = pdata->keycodes[i];\n\t\tif (!k)\n\t\t\tcontinue;\n\n\t\tif (test_bit(i, keys0) == test_bit(i, priv->last_keys))\n\t\t\tcontinue;\n\n\t\tif (test_bit(i, keys1) || test_bit(i, keys0)) {\n\t\t\tinput_event(priv->input, EV_KEY, k, 1);\n\t\t\t__set_bit(i, priv->last_keys);\n\t\t}\n\n\t\tif (!test_bit(i, keys1)) {\n\t\t\tinput_event(priv->input, EV_KEY, k, 0);\n\t\t\t__clear_bit(i, priv->last_keys);\n\t\t}\n\n\t}\n\tinput_sync(priv->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sh_keysc_probe(struct platform_device *pdev)\n{\n\tstruct sh_keysc_priv *priv;\n\tstruct sh_keysc_info *pdata;\n\tstruct resource *res;\n\tstruct input_dev *input;\n\tint i;\n\tint irq, error;\n\n\tif (!dev_get_platdata(&pdev->dev)) {\n\t\tdev_err(&pdev->dev, \"no platform data defined\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\terror = -ENXIO;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to get I/O memory\\n\");\n\t\tgoto err0;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\tgoto err0;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to allocate driver data\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tmemcpy(&priv->pdata, dev_get_platdata(&pdev->dev), sizeof(priv->pdata));\n\tpdata = &priv->pdata;\n\n\tpriv->iomem_base = ioremap(res->start, resource_size(res));\n\tif (priv->iomem_base == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to remap I/O memory\\n\");\n\t\terror = -ENXIO;\n\t\tgoto err1;\n\t}\n\n\tpriv->input = input_allocate_device();\n\tif (!priv->input) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tinput = priv->input;\n\tinput->evbit[0] = BIT_MASK(EV_KEY);\n\n\tinput->name = pdev->name;\n\tinput->phys = \"sh-keysc-keys/input0\";\n\tinput->dev.parent = &pdev->dev;\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = 0x0100;\n\n\tinput->keycode = pdata->keycodes;\n\tinput->keycodesize = sizeof(pdata->keycodes[0]);\n\tinput->keycodemax = ARRAY_SIZE(pdata->keycodes);\n\n\terror = request_threaded_irq(irq, NULL, sh_keysc_isr, IRQF_ONESHOT,\n\t\t\t\t     dev_name(&pdev->dev), pdev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\tgoto err3;\n\t}\n\n\tfor (i = 0; i < SH_KEYSC_MAXKEYS; i++)\n\t\t__set_bit(pdata->keycodes[i], input->keybit);\n\t__clear_bit(KEY_RESERVED, input->keybit);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed to register input device\\n\");\n\t\tgoto err4;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tsh_keysc_write(priv, KYCR1, (sh_keysc_mode[pdata->mode].kymd << 8) |\n\t\t       pdata->scan_timing);\n\tsh_keysc_level_mode(priv, 0);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\treturn 0;\n\n err4:\n\tfree_irq(irq, pdev);\n err3:\n\tinput_free_device(input);\n err2:\n\tiounmap(priv->iomem_base);\n err1:\n\tkfree(priv);\n err0:\n\treturn error;\n}\n\nstatic int sh_keysc_remove(struct platform_device *pdev)\n{\n\tstruct sh_keysc_priv *priv = platform_get_drvdata(pdev);\n\n\tsh_keysc_write(priv, KYCR2, KYCR2_IRQ_DISABLED);\n\n\tinput_unregister_device(priv->input);\n\tfree_irq(platform_get_irq(pdev, 0), pdev);\n\tiounmap(priv->iomem_base);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic int sh_keysc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct sh_keysc_priv *priv = platform_get_drvdata(pdev);\n\tint irq = platform_get_irq(pdev, 0);\n\tunsigned short value;\n\n\tvalue = sh_keysc_read(priv, KYCR1);\n\n\tif (device_may_wakeup(dev)) {\n\t\tsh_keysc_write(priv, KYCR1, value | 0x80);\n\t\tenable_irq_wake(irq);\n\t} else {\n\t\tsh_keysc_write(priv, KYCR1, value & ~0x80);\n\t\tpm_runtime_put_sync(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_keysc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint irq = platform_get_irq(pdev, 0);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(irq);\n\telse\n\t\tpm_runtime_get_sync(dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(sh_keysc_dev_pm_ops,\n\t\t\t\tsh_keysc_suspend, sh_keysc_resume);\n\nstatic struct platform_driver sh_keysc_device_driver = {\n\t.probe\t\t= sh_keysc_probe,\n\t.remove\t\t= sh_keysc_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sh_keysc\",\n\t\t.pm\t= pm_sleep_ptr(&sh_keysc_dev_pm_ops),\n\t}\n};\nmodule_platform_driver(sh_keysc_device_driver);\n\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_DESCRIPTION(\"SuperH KEYSC Keypad Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}