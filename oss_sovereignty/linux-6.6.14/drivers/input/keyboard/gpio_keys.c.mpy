{
  "module_name": "gpio_keys.c",
  "hash_id": "0bbe33b2de8c62b4b9a48327f3293f3ef2d61c825a3e6e29e7fe9bea59689283",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/gpio_keys.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/hrtimer.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/sched.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/proc_fs.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/gpio_keys.h>\n#include <linux/workqueue.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n#include <dt-bindings/input/gpio-keys.h>\n\nstruct gpio_button_data {\n\tconst struct gpio_keys_button *button;\n\tstruct input_dev *input;\n\tstruct gpio_desc *gpiod;\n\n\tunsigned short *code;\n\n\tstruct hrtimer release_timer;\n\tunsigned int release_delay;\t \n\n\tstruct delayed_work work;\n\tstruct hrtimer debounce_timer;\n\tunsigned int software_debounce;\t \n\n\tunsigned int irq;\n\tunsigned int wakeup_trigger_type;\n\tspinlock_t lock;\n\tbool disabled;\n\tbool key_pressed;\n\tbool suspended;\n\tbool debounce_use_hrtimer;\n};\n\nstruct gpio_keys_drvdata {\n\tconst struct gpio_keys_platform_data *pdata;\n\tstruct input_dev *input;\n\tstruct mutex disable_lock;\n\tunsigned short *keymap;\n\tstruct gpio_button_data data[];\n};\n\n \n\n \nstatic int get_n_events_by_type(int type)\n{\n\tBUG_ON(type != EV_SW && type != EV_KEY);\n\n\treturn (type == EV_KEY) ? KEY_CNT : SW_CNT;\n}\n\n \nstatic const unsigned long *get_bm_events_by_type(struct input_dev *dev,\n\t\t\t\t\t\t  int type)\n{\n\tBUG_ON(type != EV_SW && type != EV_KEY);\n\n\treturn (type == EV_KEY) ? dev->keybit : dev->swbit;\n}\n\nstatic void gpio_keys_quiesce_key(void *data)\n{\n\tstruct gpio_button_data *bdata = data;\n\n\tif (!bdata->gpiod)\n\t\thrtimer_cancel(&bdata->release_timer);\n\telse if (bdata->debounce_use_hrtimer)\n\t\thrtimer_cancel(&bdata->debounce_timer);\n\telse\n\t\tcancel_delayed_work_sync(&bdata->work);\n}\n\n \nstatic void gpio_keys_disable_button(struct gpio_button_data *bdata)\n{\n\tif (!bdata->disabled) {\n\t\t \n\t\tdisable_irq(bdata->irq);\n\t\tgpio_keys_quiesce_key(bdata);\n\t\tbdata->disabled = true;\n\t}\n}\n\n \nstatic void gpio_keys_enable_button(struct gpio_button_data *bdata)\n{\n\tif (bdata->disabled) {\n\t\tenable_irq(bdata->irq);\n\t\tbdata->disabled = false;\n\t}\n}\n\n \nstatic ssize_t gpio_keys_attr_show_helper(struct gpio_keys_drvdata *ddata,\n\t\t\t\t\t  char *buf, unsigned int type,\n\t\t\t\t\t  bool only_disabled)\n{\n\tint n_events = get_n_events_by_type(type);\n\tunsigned long *bits;\n\tssize_t ret;\n\tint i;\n\n\tbits = bitmap_zalloc(n_events, GFP_KERNEL);\n\tif (!bits)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ddata->pdata->nbuttons; i++) {\n\t\tstruct gpio_button_data *bdata = &ddata->data[i];\n\n\t\tif (bdata->button->type != type)\n\t\t\tcontinue;\n\n\t\tif (only_disabled && !bdata->disabled)\n\t\t\tcontinue;\n\n\t\t__set_bit(*bdata->code, bits);\n\t}\n\n\tret = scnprintf(buf, PAGE_SIZE - 1, \"%*pbl\", n_events, bits);\n\tbuf[ret++] = '\\n';\n\tbuf[ret] = '\\0';\n\n\tbitmap_free(bits);\n\n\treturn ret;\n}\n\n \nstatic ssize_t gpio_keys_attr_store_helper(struct gpio_keys_drvdata *ddata,\n\t\t\t\t\t   const char *buf, unsigned int type)\n{\n\tint n_events = get_n_events_by_type(type);\n\tconst unsigned long *bitmap = get_bm_events_by_type(ddata->input, type);\n\tunsigned long *bits;\n\tssize_t error;\n\tint i;\n\n\tbits = bitmap_alloc(n_events, GFP_KERNEL);\n\tif (!bits)\n\t\treturn -ENOMEM;\n\n\terror = bitmap_parselist(buf, bits, n_events);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (!bitmap_subset(bits, bitmap, n_events)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ddata->pdata->nbuttons; i++) {\n\t\tstruct gpio_button_data *bdata = &ddata->data[i];\n\n\t\tif (bdata->button->type != type)\n\t\t\tcontinue;\n\n\t\tif (test_bit(*bdata->code, bits) &&\n\t\t    !bdata->button->can_disable) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmutex_lock(&ddata->disable_lock);\n\n\tfor (i = 0; i < ddata->pdata->nbuttons; i++) {\n\t\tstruct gpio_button_data *bdata = &ddata->data[i];\n\n\t\tif (bdata->button->type != type)\n\t\t\tcontinue;\n\n\t\tif (test_bit(*bdata->code, bits))\n\t\t\tgpio_keys_disable_button(bdata);\n\t\telse\n\t\t\tgpio_keys_enable_button(bdata);\n\t}\n\n\tmutex_unlock(&ddata->disable_lock);\n\nout:\n\tbitmap_free(bits);\n\treturn error;\n}\n\n#define ATTR_SHOW_FN(name, type, only_disabled)\t\t\t\t\\\nstatic ssize_t gpio_keys_show_##name(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct platform_device *pdev = to_platform_device(dev);\t\t\\\n\tstruct gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn gpio_keys_attr_show_helper(ddata, buf,\t\t\t\\\n\t\t\t\t\t  type, only_disabled);\t\t\\\n}\n\nATTR_SHOW_FN(keys, EV_KEY, false);\nATTR_SHOW_FN(switches, EV_SW, false);\nATTR_SHOW_FN(disabled_keys, EV_KEY, true);\nATTR_SHOW_FN(disabled_switches, EV_SW, true);\n\n \nstatic DEVICE_ATTR(keys, S_IRUGO, gpio_keys_show_keys, NULL);\nstatic DEVICE_ATTR(switches, S_IRUGO, gpio_keys_show_switches, NULL);\n\n#define ATTR_STORE_FN(name, type)\t\t\t\t\t\\\nstatic ssize_t gpio_keys_store_##name(struct device *dev,\t\t\\\n\t\t\t\t      struct device_attribute *attr,\t\\\n\t\t\t\t      const char *buf,\t\t\t\\\n\t\t\t\t      size_t count)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct platform_device *pdev = to_platform_device(dev);\t\t\\\n\tstruct gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);\t\\\n\tssize_t error;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terror = gpio_keys_attr_store_helper(ddata, buf, type);\t\t\\\n\tif (error)\t\t\t\t\t\t\t\\\n\t\treturn error;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nATTR_STORE_FN(disabled_keys, EV_KEY);\nATTR_STORE_FN(disabled_switches, EV_SW);\n\n \nstatic DEVICE_ATTR(disabled_keys, S_IWUSR | S_IRUGO,\n\t\t   gpio_keys_show_disabled_keys,\n\t\t   gpio_keys_store_disabled_keys);\nstatic DEVICE_ATTR(disabled_switches, S_IWUSR | S_IRUGO,\n\t\t   gpio_keys_show_disabled_switches,\n\t\t   gpio_keys_store_disabled_switches);\n\nstatic struct attribute *gpio_keys_attrs[] = {\n\t&dev_attr_keys.attr,\n\t&dev_attr_switches.attr,\n\t&dev_attr_disabled_keys.attr,\n\t&dev_attr_disabled_switches.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gpio_keys);\n\nstatic void gpio_keys_gpio_report_event(struct gpio_button_data *bdata)\n{\n\tconst struct gpio_keys_button *button = bdata->button;\n\tstruct input_dev *input = bdata->input;\n\tunsigned int type = button->type ?: EV_KEY;\n\tint state;\n\n\tstate = bdata->debounce_use_hrtimer ?\n\t\t\tgpiod_get_value(bdata->gpiod) :\n\t\t\tgpiod_get_value_cansleep(bdata->gpiod);\n\tif (state < 0) {\n\t\tdev_err(input->dev.parent,\n\t\t\t\"failed to get gpio state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\tif (type == EV_ABS) {\n\t\tif (state)\n\t\t\tinput_event(input, type, button->code, button->value);\n\t} else {\n\t\tinput_event(input, type, *bdata->code, state);\n\t}\n}\n\nstatic void gpio_keys_debounce_event(struct gpio_button_data *bdata)\n{\n\tgpio_keys_gpio_report_event(bdata);\n\tinput_sync(bdata->input);\n\n\tif (bdata->button->wakeup)\n\t\tpm_relax(bdata->input->dev.parent);\n}\n\nstatic void gpio_keys_gpio_work_func(struct work_struct *work)\n{\n\tstruct gpio_button_data *bdata =\n\t\tcontainer_of(work, struct gpio_button_data, work.work);\n\n\tgpio_keys_debounce_event(bdata);\n}\n\nstatic enum hrtimer_restart gpio_keys_debounce_timer(struct hrtimer *t)\n{\n\tstruct gpio_button_data *bdata =\n\t\tcontainer_of(t, struct gpio_button_data, debounce_timer);\n\n\tgpio_keys_debounce_event(bdata);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic irqreturn_t gpio_keys_gpio_isr(int irq, void *dev_id)\n{\n\tstruct gpio_button_data *bdata = dev_id;\n\n\tBUG_ON(irq != bdata->irq);\n\n\tif (bdata->button->wakeup) {\n\t\tconst struct gpio_keys_button *button = bdata->button;\n\n\t\tpm_stay_awake(bdata->input->dev.parent);\n\t\tif (bdata->suspended  &&\n\t\t    (button->type == 0 || button->type == EV_KEY)) {\n\t\t\t \n\t\t\tinput_report_key(bdata->input, button->code, 1);\n\t\t}\n\t}\n\n\tif (bdata->debounce_use_hrtimer) {\n\t\thrtimer_start(&bdata->debounce_timer,\n\t\t\t      ms_to_ktime(bdata->software_debounce),\n\t\t\t      HRTIMER_MODE_REL);\n\t} else {\n\t\tmod_delayed_work(system_wq,\n\t\t\t\t &bdata->work,\n\t\t\t\t msecs_to_jiffies(bdata->software_debounce));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic enum hrtimer_restart gpio_keys_irq_timer(struct hrtimer *t)\n{\n\tstruct gpio_button_data *bdata = container_of(t,\n\t\t\t\t\t\t      struct gpio_button_data,\n\t\t\t\t\t\t      release_timer);\n\tstruct input_dev *input = bdata->input;\n\n\tif (bdata->key_pressed) {\n\t\tinput_report_key(input, *bdata->code, 0);\n\t\tinput_sync(input);\n\t\tbdata->key_pressed = false;\n\t}\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)\n{\n\tstruct gpio_button_data *bdata = dev_id;\n\tstruct input_dev *input = bdata->input;\n\tunsigned long flags;\n\n\tBUG_ON(irq != bdata->irq);\n\n\tspin_lock_irqsave(&bdata->lock, flags);\n\n\tif (!bdata->key_pressed) {\n\t\tif (bdata->button->wakeup)\n\t\t\tpm_wakeup_event(bdata->input->dev.parent, 0);\n\n\t\tinput_report_key(input, *bdata->code, 1);\n\t\tinput_sync(input);\n\n\t\tif (!bdata->release_delay) {\n\t\t\tinput_report_key(input, *bdata->code, 0);\n\t\t\tinput_sync(input);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbdata->key_pressed = true;\n\t}\n\n\tif (bdata->release_delay)\n\t\thrtimer_start(&bdata->release_timer,\n\t\t\t      ms_to_ktime(bdata->release_delay),\n\t\t\t      HRTIMER_MODE_REL_HARD);\nout:\n\tspin_unlock_irqrestore(&bdata->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int gpio_keys_setup_key(struct platform_device *pdev,\n\t\t\t\tstruct input_dev *input,\n\t\t\t\tstruct gpio_keys_drvdata *ddata,\n\t\t\t\tconst struct gpio_keys_button *button,\n\t\t\t\tint idx,\n\t\t\t\tstruct fwnode_handle *child)\n{\n\tconst char *desc = button->desc ? button->desc : \"gpio_keys\";\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_button_data *bdata = &ddata->data[idx];\n\tirq_handler_t isr;\n\tunsigned long irqflags;\n\tint irq;\n\tint error;\n\n\tbdata->input = input;\n\tbdata->button = button;\n\tspin_lock_init(&bdata->lock);\n\n\tif (child) {\n\t\tbdata->gpiod = devm_fwnode_gpiod_get(dev, child,\n\t\t\t\t\t\t     NULL, GPIOD_IN, desc);\n\t\tif (IS_ERR(bdata->gpiod)) {\n\t\t\terror = PTR_ERR(bdata->gpiod);\n\t\t\tif (error != -ENOENT)\n\t\t\t\treturn dev_err_probe(dev, error,\n\t\t\t\t\t\t     \"failed to get gpio\\n\");\n\n\t\t\t \n\t\t\tbdata->gpiod = NULL;\n\t\t}\n\t} else if (gpio_is_valid(button->gpio)) {\n\t\t \n\t\tunsigned flags = GPIOF_IN;\n\n\t\tif (button->active_low)\n\t\t\tflags |= GPIOF_ACTIVE_LOW;\n\n\t\terror = devm_gpio_request_one(dev, button->gpio, flags, desc);\n\t\tif (error < 0) {\n\t\t\tdev_err(dev, \"Failed to request GPIO %d, error %d\\n\",\n\t\t\t\tbutton->gpio, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tbdata->gpiod = gpio_to_desc(button->gpio);\n\t\tif (!bdata->gpiod)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bdata->gpiod) {\n\t\tbool active_low = gpiod_is_active_low(bdata->gpiod);\n\n\t\tif (button->debounce_interval) {\n\t\t\terror = gpiod_set_debounce(bdata->gpiod,\n\t\t\t\t\tbutton->debounce_interval * 1000);\n\t\t\t \n\t\t\tif (error < 0)\n\t\t\t\tbdata->software_debounce =\n\t\t\t\t\t\tbutton->debounce_interval;\n\n\t\t\t \n\t\t\tbdata->debounce_use_hrtimer =\n\t\t\t\t\t!gpiod_cansleep(bdata->gpiod);\n\t\t}\n\n\t\tif (button->irq) {\n\t\t\tbdata->irq = button->irq;\n\t\t} else {\n\t\t\tirq = gpiod_to_irq(bdata->gpiod);\n\t\t\tif (irq < 0) {\n\t\t\t\terror = irq;\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Unable to get irq number for GPIO %d, error %d\\n\",\n\t\t\t\t\tbutton->gpio, error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbdata->irq = irq;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&bdata->work, gpio_keys_gpio_work_func);\n\n\t\thrtimer_init(&bdata->debounce_timer,\n\t\t\t     CLOCK_REALTIME, HRTIMER_MODE_REL);\n\t\tbdata->debounce_timer.function = gpio_keys_debounce_timer;\n\n\t\tisr = gpio_keys_gpio_isr;\n\t\tirqflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;\n\n\t\tswitch (button->wakeup_event_action) {\n\t\tcase EV_ACT_ASSERTED:\n\t\t\tbdata->wakeup_trigger_type = active_low ?\n\t\t\t\tIRQ_TYPE_EDGE_FALLING : IRQ_TYPE_EDGE_RISING;\n\t\t\tbreak;\n\t\tcase EV_ACT_DEASSERTED:\n\t\t\tbdata->wakeup_trigger_type = active_low ?\n\t\t\t\tIRQ_TYPE_EDGE_RISING : IRQ_TYPE_EDGE_FALLING;\n\t\t\tbreak;\n\t\tcase EV_ACT_ANY:\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (!button->irq) {\n\t\t\tdev_err(dev, \"Found button without gpio or irq\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbdata->irq = button->irq;\n\n\t\tif (button->type && button->type != EV_KEY) {\n\t\t\tdev_err(dev, \"Only EV_KEY allowed for IRQ buttons.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbdata->release_delay = button->debounce_interval;\n\t\thrtimer_init(&bdata->release_timer,\n\t\t\t     CLOCK_REALTIME, HRTIMER_MODE_REL_HARD);\n\t\tbdata->release_timer.function = gpio_keys_irq_timer;\n\n\t\tisr = gpio_keys_irq_isr;\n\t\tirqflags = 0;\n\n\t\t \n\t}\n\n\tbdata->code = &ddata->keymap[idx];\n\t*bdata->code = button->code;\n\tinput_set_capability(input, button->type ?: EV_KEY, *bdata->code);\n\n\t \n\terror = devm_add_action(dev, gpio_keys_quiesce_key, bdata);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register quiesce action, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tif (!button->can_disable)\n\t\tirqflags |= IRQF_SHARED;\n\n\terror = devm_request_any_context_irq(dev, bdata->irq, isr, irqflags,\n\t\t\t\t\t     desc, bdata);\n\tif (error < 0) {\n\t\tdev_err(dev, \"Unable to claim irq %d; error %d\\n\",\n\t\t\tbdata->irq, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void gpio_keys_report_state(struct gpio_keys_drvdata *ddata)\n{\n\tstruct input_dev *input = ddata->input;\n\tint i;\n\n\tfor (i = 0; i < ddata->pdata->nbuttons; i++) {\n\t\tstruct gpio_button_data *bdata = &ddata->data[i];\n\t\tif (bdata->gpiod)\n\t\t\tgpio_keys_gpio_report_event(bdata);\n\t}\n\tinput_sync(input);\n}\n\nstatic int gpio_keys_open(struct input_dev *input)\n{\n\tstruct gpio_keys_drvdata *ddata = input_get_drvdata(input);\n\tconst struct gpio_keys_platform_data *pdata = ddata->pdata;\n\tint error;\n\n\tif (pdata->enable) {\n\t\terror = pdata->enable(input->dev.parent);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tgpio_keys_report_state(ddata);\n\n\treturn 0;\n}\n\nstatic void gpio_keys_close(struct input_dev *input)\n{\n\tstruct gpio_keys_drvdata *ddata = input_get_drvdata(input);\n\tconst struct gpio_keys_platform_data *pdata = ddata->pdata;\n\n\tif (pdata->disable)\n\t\tpdata->disable(input->dev.parent);\n}\n\n \n\n \nstatic struct gpio_keys_platform_data *\ngpio_keys_get_devtree_pdata(struct device *dev)\n{\n\tstruct gpio_keys_platform_data *pdata;\n\tstruct gpio_keys_button *button;\n\tstruct fwnode_handle *child;\n\tint nbuttons;\n\n\tnbuttons = device_get_child_node_count(dev);\n\tif (nbuttons == 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdata = devm_kzalloc(dev,\n\t\t\t     sizeof(*pdata) + nbuttons * sizeof(*button),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbutton = (struct gpio_keys_button *)(pdata + 1);\n\n\tpdata->buttons = button;\n\tpdata->nbuttons = nbuttons;\n\n\tpdata->rep = device_property_read_bool(dev, \"autorepeat\");\n\n\tdevice_property_read_string(dev, \"label\", &pdata->name);\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tif (is_of_node(child))\n\t\t\tbutton->irq =\n\t\t\t\tirq_of_parse_and_map(to_of_node(child), 0);\n\n\t\tif (fwnode_property_read_u32(child, \"linux,code\",\n\t\t\t\t\t     &button->code)) {\n\t\t\tdev_err(dev, \"Button without keycode\\n\");\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tfwnode_property_read_string(child, \"label\", &button->desc);\n\n\t\tif (fwnode_property_read_u32(child, \"linux,input-type\",\n\t\t\t\t\t     &button->type))\n\t\t\tbutton->type = EV_KEY;\n\n\t\tfwnode_property_read_u32(child, \"linux,input-value\",\n\t\t\t\t\t (u32 *)&button->value);\n\n\t\tbutton->wakeup =\n\t\t\tfwnode_property_read_bool(child, \"wakeup-source\") ||\n\t\t\t \n\t\t\tfwnode_property_read_bool(child, \"gpio-key,wakeup\");\n\n\t\tfwnode_property_read_u32(child, \"wakeup-event-action\",\n\t\t\t\t\t &button->wakeup_event_action);\n\n\t\tbutton->can_disable =\n\t\t\tfwnode_property_read_bool(child, \"linux,can-disable\");\n\n\t\tif (fwnode_property_read_u32(child, \"debounce-interval\",\n\t\t\t\t\t &button->debounce_interval))\n\t\t\tbutton->debounce_interval = 5;\n\n\t\tbutton++;\n\t}\n\n\treturn pdata;\n}\n\nstatic const struct of_device_id gpio_keys_of_match[] = {\n\t{ .compatible = \"gpio-keys\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gpio_keys_of_match);\n\nstatic int gpio_keys_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);\n\tstruct fwnode_handle *child = NULL;\n\tstruct gpio_keys_drvdata *ddata;\n\tstruct input_dev *input;\n\tint i, error;\n\tint wakeup = 0;\n\n\tif (!pdata) {\n\t\tpdata = gpio_keys_get_devtree_pdata(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tddata = devm_kzalloc(dev, struct_size(ddata, data, pdata->nbuttons),\n\t\t\t     GFP_KERNEL);\n\tif (!ddata) {\n\t\tdev_err(dev, \"failed to allocate state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tddata->keymap = devm_kcalloc(dev,\n\t\t\t\t     pdata->nbuttons, sizeof(ddata->keymap[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!ddata->keymap)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tddata->pdata = pdata;\n\tddata->input = input;\n\tmutex_init(&ddata->disable_lock);\n\n\tplatform_set_drvdata(pdev, ddata);\n\tinput_set_drvdata(input, ddata);\n\n\tinput->name = pdata->name ? : pdev->name;\n\tinput->phys = \"gpio-keys/input0\";\n\tinput->dev.parent = dev;\n\tinput->open = gpio_keys_open;\n\tinput->close = gpio_keys_close;\n\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0001;\n\tinput->id.version = 0x0100;\n\n\tinput->keycode = ddata->keymap;\n\tinput->keycodesize = sizeof(ddata->keymap[0]);\n\tinput->keycodemax = pdata->nbuttons;\n\n\t \n\tif (pdata->rep)\n\t\t__set_bit(EV_REP, input->evbit);\n\n\tfor (i = 0; i < pdata->nbuttons; i++) {\n\t\tconst struct gpio_keys_button *button = &pdata->buttons[i];\n\n\t\tif (!dev_get_platdata(dev)) {\n\t\t\tchild = device_get_next_child_node(dev, child);\n\t\t\tif (!child) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"missing child device node for entry %d\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\terror = gpio_keys_setup_key(pdev, input, ddata,\n\t\t\t\t\t    button, i, child);\n\t\tif (error) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (button->wakeup)\n\t\t\twakeup = 1;\n\t}\n\n\tfwnode_handle_put(child);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to register input device, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(dev, wakeup);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\ngpio_keys_button_enable_wakeup(struct gpio_button_data *bdata)\n{\n\tint error;\n\n\terror = enable_irq_wake(bdata->irq);\n\tif (error) {\n\t\tdev_err(bdata->input->dev.parent,\n\t\t\t\"failed to configure IRQ %d as wakeup source: %d\\n\",\n\t\t\tbdata->irq, error);\n\t\treturn error;\n\t}\n\n\tif (bdata->wakeup_trigger_type) {\n\t\terror = irq_set_irq_type(bdata->irq,\n\t\t\t\t\t bdata->wakeup_trigger_type);\n\t\tif (error) {\n\t\t\tdev_err(bdata->input->dev.parent,\n\t\t\t\t\"failed to set wakeup trigger %08x for IRQ %d: %d\\n\",\n\t\t\t\tbdata->wakeup_trigger_type, bdata->irq, error);\n\t\t\tdisable_irq_wake(bdata->irq);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __maybe_unused\ngpio_keys_button_disable_wakeup(struct gpio_button_data *bdata)\n{\n\tint error;\n\n\t \n\tif (bdata->wakeup_trigger_type) {\n\t\terror = irq_set_irq_type(bdata->irq, IRQ_TYPE_EDGE_BOTH);\n\t\tif (error)\n\t\t\tdev_warn(bdata->input->dev.parent,\n\t\t\t\t \"failed to restore interrupt trigger for IRQ %d: %d\\n\",\n\t\t\t\t bdata->irq, error);\n\t}\n\n\terror = disable_irq_wake(bdata->irq);\n\tif (error)\n\t\tdev_warn(bdata->input->dev.parent,\n\t\t\t \"failed to disable IRQ %d as wake source: %d\\n\",\n\t\t\t bdata->irq, error);\n}\n\nstatic int __maybe_unused\ngpio_keys_enable_wakeup(struct gpio_keys_drvdata *ddata)\n{\n\tstruct gpio_button_data *bdata;\n\tint error;\n\tint i;\n\n\tfor (i = 0; i < ddata->pdata->nbuttons; i++) {\n\t\tbdata = &ddata->data[i];\n\t\tif (bdata->button->wakeup) {\n\t\t\terror = gpio_keys_button_enable_wakeup(bdata);\n\t\t\tif (error)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tbdata->suspended = true;\n\t}\n\n\treturn 0;\n\nerr_out:\n\twhile (i--) {\n\t\tbdata = &ddata->data[i];\n\t\tif (bdata->button->wakeup)\n\t\t\tgpio_keys_button_disable_wakeup(bdata);\n\t\tbdata->suspended = false;\n\t}\n\n\treturn error;\n}\n\nstatic void __maybe_unused\ngpio_keys_disable_wakeup(struct gpio_keys_drvdata *ddata)\n{\n\tstruct gpio_button_data *bdata;\n\tint i;\n\n\tfor (i = 0; i < ddata->pdata->nbuttons; i++) {\n\t\tbdata = &ddata->data[i];\n\t\tbdata->suspended = false;\n\t\tif (irqd_is_wakeup_set(irq_get_irq_data(bdata->irq)))\n\t\t\tgpio_keys_button_disable_wakeup(bdata);\n\t}\n}\n\nstatic int gpio_keys_suspend(struct device *dev)\n{\n\tstruct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);\n\tstruct input_dev *input = ddata->input;\n\tint error;\n\n\tif (device_may_wakeup(dev)) {\n\t\terror = gpio_keys_enable_wakeup(ddata);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmutex_lock(&input->mutex);\n\t\tif (input_device_enabled(input))\n\t\t\tgpio_keys_close(input);\n\t\tmutex_unlock(&input->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_keys_resume(struct device *dev)\n{\n\tstruct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);\n\tstruct input_dev *input = ddata->input;\n\tint error = 0;\n\n\tif (device_may_wakeup(dev)) {\n\t\tgpio_keys_disable_wakeup(ddata);\n\t} else {\n\t\tmutex_lock(&input->mutex);\n\t\tif (input_device_enabled(input))\n\t\t\terror = gpio_keys_open(input);\n\t\tmutex_unlock(&input->mutex);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\tgpio_keys_report_state(ddata);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(gpio_keys_pm_ops, gpio_keys_suspend, gpio_keys_resume);\n\nstatic void gpio_keys_shutdown(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = gpio_keys_suspend(&pdev->dev);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to shutdown\\n\");\n}\n\nstatic struct platform_driver gpio_keys_device_driver = {\n\t.probe\t\t= gpio_keys_probe,\n\t.shutdown\t= gpio_keys_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-keys\",\n\t\t.pm\t= pm_sleep_ptr(&gpio_keys_pm_ops),\n\t\t.of_match_table = gpio_keys_of_match,\n\t\t.dev_groups\t= gpio_keys_groups,\n\t}\n};\n\nstatic int __init gpio_keys_init(void)\n{\n\treturn platform_driver_register(&gpio_keys_device_driver);\n}\n\nstatic void __exit gpio_keys_exit(void)\n{\n\tplatform_driver_unregister(&gpio_keys_device_driver);\n}\n\nlate_initcall(gpio_keys_init);\nmodule_exit(gpio_keys_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Phil Blundell <pb@handhelds.org>\");\nMODULE_DESCRIPTION(\"Keyboard driver for GPIOs\");\nMODULE_ALIAS(\"platform:gpio-keys\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}