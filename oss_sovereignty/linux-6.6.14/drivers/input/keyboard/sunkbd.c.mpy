{
  "module_name": "sunkbd.c",
  "hash_id": "3b6b9228e5745b9555a1f1265c51c58869db1ebb747463aa6cfc433e452222d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/keyboard/sunkbd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/workqueue.h>\n\n#define DRIVER_DESC\t\"Sun keyboard driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned char sunkbd_keycode[128] = {\n\t  0,128,114,129,115, 59, 60, 68, 61, 87, 62, 88, 63,100, 64,112,\n\t 65, 66, 67, 56,103,119, 99, 70,105,130,131,108,106,  1,  2,  3,\n\t  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 41, 14,110,113, 98, 55,\n\t116,132, 83,133,102, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\t 26, 27,111,127, 71, 72, 73, 74,134,135,107,  0, 29, 30, 31, 32,\n\t 33, 34, 35, 36, 37, 38, 39, 40, 43, 28, 96, 75, 76, 77, 82,136,\n\t104,137, 69, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,101,\n\t 79, 80, 81,  0,  0,  0,138, 58,125, 57,126,109, 86, 78\n};\n\n#define SUNKBD_CMD_RESET\t0x1\n#define SUNKBD_CMD_BELLON\t0x2\n#define SUNKBD_CMD_BELLOFF\t0x3\n#define SUNKBD_CMD_CLICK\t0xa\n#define SUNKBD_CMD_NOCLICK\t0xb\n#define SUNKBD_CMD_SETLED\t0xe\n#define SUNKBD_CMD_LAYOUT\t0xf\n\n#define SUNKBD_RET_RESET\t0xff\n#define SUNKBD_RET_ALLUP\t0x7f\n#define SUNKBD_RET_LAYOUT\t0xfe\n\n#define SUNKBD_LAYOUT_5_MASK\t0x20\n#define SUNKBD_RELEASE\t\t0x80\n#define SUNKBD_KEY\t\t0x7f\n\n \n\nstruct sunkbd {\n\tunsigned char keycode[ARRAY_SIZE(sunkbd_keycode)];\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tstruct work_struct tq;\n\twait_queue_head_t wait;\n\tchar name[64];\n\tchar phys[32];\n\tchar type;\n\tbool enabled;\n\tvolatile s8 reset;\n\tvolatile s8 layout;\n};\n\n \n\nstatic irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tif (sunkbd->reset <= -1) {\n\t\t \n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tif (sunkbd->enabled)\n\t\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP:  \n\t\tbreak;\n\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int sunkbd_event(struct input_dev *dev,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct sunkbd *sunkbd = input_get_drvdata(dev);\n\n\tswitch (type) {\n\n\tcase EV_LED:\n\n\t\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\t\tserio_write(sunkbd->serio,\n\t\t\t(!!test_bit(LED_CAPSL,   dev->led) << 3) |\n\t\t\t(!!test_bit(LED_SCROLLL, dev->led) << 2) |\n\t\t\t(!!test_bit(LED_COMPOSE, dev->led) << 1) |\n\t\t\t !!test_bit(LED_NUML,    dev->led));\n\t\treturn 0;\n\n\tcase EV_SND:\n\n\t\tswitch (code) {\n\n\t\tcase SND_CLICK:\n\t\t\tserio_write(sunkbd->serio, SUNKBD_CMD_NOCLICK - value);\n\t\t\treturn 0;\n\n\t\tcase SND_BELL:\n\t\t\tserio_write(sunkbd->serio, SUNKBD_CMD_BELLOFF - value);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n \n\nstatic int sunkbd_initialize(struct sunkbd *sunkbd)\n{\n\tsunkbd->reset = -2;\n\tserio_write(sunkbd->serio, SUNKBD_CMD_RESET);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tif (sunkbd->reset < 0)\n\t\treturn -1;\n\n\tsunkbd->type = sunkbd->reset;\n\n\tif (sunkbd->type == 4) {\t \n\t\tsunkbd->layout = -2;\n\t\tserio_write(sunkbd->serio, SUNKBD_CMD_LAYOUT);\n\t\twait_event_interruptible_timeout(sunkbd->wait,\n\t\t\t\t\t\t sunkbd->layout >= 0, HZ / 4);\n\t\tif (sunkbd->layout < 0)\n\t\t\treturn -1;\n\t\tif (sunkbd->layout & SUNKBD_LAYOUT_5_MASK)\n\t\t\tsunkbd->type = 5;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}\n\n\n \n\nstatic void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\t \n\twait_event_interruptible_timeout(sunkbd->wait,\n\t\t\t\t\t sunkbd->reset >= 0 || !sunkbd->enabled,\n\t\t\t\t\t HZ);\n\n\tif (sunkbd->reset >= 0 && sunkbd->enabled)\n\t\tsunkbd_set_leds_beeps(sunkbd);\n}\n\nstatic void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}\n\n \n\nstatic int sunkbd_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct sunkbd *sunkbd;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tsunkbd = kzalloc(sizeof(struct sunkbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!sunkbd || !input_dev)\n\t\tgoto fail1;\n\n\tsunkbd->serio = serio;\n\tsunkbd->dev = input_dev;\n\tinit_waitqueue_head(&sunkbd->wait);\n\tINIT_WORK(&sunkbd->tq, sunkbd_reinit);\n\tsnprintf(sunkbd->phys, sizeof(sunkbd->phys), \"%s/input0\", serio->phys);\n\n\tserio_set_drvdata(serio, sunkbd);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\tif (sunkbd_initialize(sunkbd) < 0) {\n\t\terr = -ENODEV;\n\t\tgoto fail3;\n\t}\n\n\tsnprintf(sunkbd->name, sizeof(sunkbd->name),\n\t\t \"Sun Type %d keyboard\", sunkbd->type);\n\tmemcpy(sunkbd->keycode, sunkbd_keycode, sizeof(sunkbd->keycode));\n\n\tinput_dev->name = sunkbd->name;\n\tinput_dev->phys = sunkbd->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor  = SERIO_SUNKBD;\n\tinput_dev->id.product = sunkbd->type;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_set_drvdata(input_dev, sunkbd);\n\n\tinput_dev->event = sunkbd_event;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\n\t\tBIT_MASK(EV_SND) | BIT_MASK(EV_REP);\n\tinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) | BIT_MASK(LED_COMPOSE) |\n\t\tBIT_MASK(LED_SCROLLL) | BIT_MASK(LED_NUML);\n\tinput_dev->sndbit[0] = BIT_MASK(SND_CLICK) | BIT_MASK(SND_BELL);\n\n\tinput_dev->keycode = sunkbd->keycode;\n\tinput_dev->keycodesize = sizeof(unsigned char);\n\tinput_dev->keycodemax = ARRAY_SIZE(sunkbd_keycode);\n\tfor (i = 0; i < ARRAY_SIZE(sunkbd_keycode); i++)\n\t\t__set_bit(sunkbd->keycode[i], input_dev->keybit);\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\tsunkbd_enable(sunkbd, true);\n\n\terr = input_register_device(sunkbd->dev);\n\tif (err)\n\t\tgoto fail4;\n\n\treturn 0;\n\n fail4:\tsunkbd_enable(sunkbd, false);\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(sunkbd);\n\treturn err;\n}\n\n \n\nstatic void sunkbd_disconnect(struct serio *serio)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\n\tsunkbd_enable(sunkbd, false);\n\tinput_unregister_device(sunkbd->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(sunkbd);\n}\n\nstatic const struct serio_device_id sunkbd_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_SUNKBD,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_UNKNOWN,  \n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, sunkbd_serio_ids);\n\nstatic struct serio_driver sunkbd_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"sunkbd\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= sunkbd_serio_ids,\n\t.interrupt\t= sunkbd_interrupt,\n\t.connect\t= sunkbd_connect,\n\t.disconnect\t= sunkbd_disconnect,\n};\n\nmodule_serio_driver(sunkbd_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}