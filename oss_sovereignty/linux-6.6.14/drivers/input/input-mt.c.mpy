{
  "module_name": "input-mt.c",
  "hash_id": "1596ee568e4c56212164b2290f5756f4bbd78a7f7e4c82b44cfda29c29a7035f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/input-mt.c",
  "human_readable_source": "\n \n\n#include <linux/input/mt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include \"input-core-private.h\"\n\n#define TRKID_SGN\t((TRKID_MAX + 1) >> 1)\n\nstatic void copy_abs(struct input_dev *dev, unsigned int dst, unsigned int src)\n{\n\tif (dev->absinfo && test_bit(src, dev->absbit)) {\n\t\tdev->absinfo[dst] = dev->absinfo[src];\n\t\tdev->absinfo[dst].fuzz = 0;\n\t\t__set_bit(dst, dev->absbit);\n\t}\n}\n\n \nint input_mt_init_slots(struct input_dev *dev, unsigned int num_slots,\n\t\t\tunsigned int flags)\n{\n\tstruct input_mt *mt = dev->mt;\n\tint i;\n\n\tif (!num_slots)\n\t\treturn 0;\n\tif (mt)\n\t\treturn mt->num_slots != num_slots ? -EINVAL : 0;\n\n\tmt = kzalloc(struct_size(mt, slots, num_slots), GFP_KERNEL);\n\tif (!mt)\n\t\tgoto err_mem;\n\n\tmt->num_slots = num_slots;\n\tmt->flags = flags;\n\tinput_set_abs_params(dev, ABS_MT_SLOT, 0, num_slots - 1, 0, 0);\n\tinput_set_abs_params(dev, ABS_MT_TRACKING_ID, 0, TRKID_MAX, 0, 0);\n\n\tif (flags & (INPUT_MT_POINTER | INPUT_MT_DIRECT)) {\n\t\t__set_bit(EV_KEY, dev->evbit);\n\t\t__set_bit(BTN_TOUCH, dev->keybit);\n\n\t\tcopy_abs(dev, ABS_X, ABS_MT_POSITION_X);\n\t\tcopy_abs(dev, ABS_Y, ABS_MT_POSITION_Y);\n\t\tcopy_abs(dev, ABS_PRESSURE, ABS_MT_PRESSURE);\n\t}\n\tif (flags & INPUT_MT_POINTER) {\n\t\t__set_bit(BTN_TOOL_FINGER, dev->keybit);\n\t\t__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\n\t\tif (num_slots >= 3)\n\t\t\t__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);\n\t\tif (num_slots >= 4)\n\t\t\t__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\n\t\tif (num_slots >= 5)\n\t\t\t__set_bit(BTN_TOOL_QUINTTAP, dev->keybit);\n\t\t__set_bit(INPUT_PROP_POINTER, dev->propbit);\n\t}\n\tif (flags & INPUT_MT_DIRECT)\n\t\t__set_bit(INPUT_PROP_DIRECT, dev->propbit);\n\tif (flags & INPUT_MT_SEMI_MT)\n\t\t__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\n\tif (flags & INPUT_MT_TRACK) {\n\t\tunsigned int n2 = num_slots * num_slots;\n\t\tmt->red = kcalloc(n2, sizeof(*mt->red), GFP_KERNEL);\n\t\tif (!mt->red)\n\t\t\tgoto err_mem;\n\t}\n\n\t \n\tfor (i = 0; i < num_slots; i++)\n\t\tinput_mt_set_value(&mt->slots[i], ABS_MT_TRACKING_ID, -1);\n\n\t \n\tmt->frame = 1;\n\n\tdev->mt = mt;\n\treturn 0;\nerr_mem:\n\tkfree(mt);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(input_mt_init_slots);\n\n \nvoid input_mt_destroy_slots(struct input_dev *dev)\n{\n\tif (dev->mt) {\n\t\tkfree(dev->mt->red);\n\t\tkfree(dev->mt);\n\t}\n\tdev->mt = NULL;\n}\nEXPORT_SYMBOL(input_mt_destroy_slots);\n\n \nbool input_mt_report_slot_state(struct input_dev *dev,\n\t\t\t\tunsigned int tool_type, bool active)\n{\n\tstruct input_mt *mt = dev->mt;\n\tstruct input_mt_slot *slot;\n\tint id;\n\n\tif (!mt)\n\t\treturn false;\n\n\tslot = &mt->slots[mt->slot];\n\tslot->frame = mt->frame;\n\n\tif (!active) {\n\t\tinput_event(dev, EV_ABS, ABS_MT_TRACKING_ID, -1);\n\t\treturn false;\n\t}\n\n\tid = input_mt_get_value(slot, ABS_MT_TRACKING_ID);\n\tif (id < 0)\n\t\tid = input_mt_new_trkid(mt);\n\n\tinput_event(dev, EV_ABS, ABS_MT_TRACKING_ID, id);\n\tinput_event(dev, EV_ABS, ABS_MT_TOOL_TYPE, tool_type);\n\n\treturn true;\n}\nEXPORT_SYMBOL(input_mt_report_slot_state);\n\n \nvoid input_mt_report_finger_count(struct input_dev *dev, int count)\n{\n\tinput_event(dev, EV_KEY, BTN_TOOL_FINGER, count == 1);\n\tinput_event(dev, EV_KEY, BTN_TOOL_DOUBLETAP, count == 2);\n\tinput_event(dev, EV_KEY, BTN_TOOL_TRIPLETAP, count == 3);\n\tinput_event(dev, EV_KEY, BTN_TOOL_QUADTAP, count == 4);\n\tinput_event(dev, EV_KEY, BTN_TOOL_QUINTTAP, count == 5);\n}\nEXPORT_SYMBOL(input_mt_report_finger_count);\n\n \nvoid input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count)\n{\n\tstruct input_mt *mt = dev->mt;\n\tstruct input_mt_slot *oldest;\n\tint oldid, count, i;\n\n\tif (!mt)\n\t\treturn;\n\n\toldest = NULL;\n\toldid = mt->trkid;\n\tcount = 0;\n\n\tfor (i = 0; i < mt->num_slots; ++i) {\n\t\tstruct input_mt_slot *ps = &mt->slots[i];\n\t\tint id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\n\n\t\tif (id < 0)\n\t\t\tcontinue;\n\t\tif ((id - oldid) & TRKID_SGN) {\n\t\t\toldest = ps;\n\t\t\toldid = id;\n\t\t}\n\t\tcount++;\n\t}\n\n\tinput_event(dev, EV_KEY, BTN_TOUCH, count > 0);\n\n\tif (use_count) {\n\t\tif (count == 0 &&\n\t\t    !test_bit(ABS_MT_DISTANCE, dev->absbit) &&\n\t\t    test_bit(ABS_DISTANCE, dev->absbit) &&\n\t\t    input_abs_get_val(dev, ABS_DISTANCE) != 0) {\n\t\t\t \n\t\t\tcount = 1;\n\t\t}\n\n\t\tinput_mt_report_finger_count(dev, count);\n\t}\n\n\tif (oldest) {\n\t\tint x = input_mt_get_value(oldest, ABS_MT_POSITION_X);\n\t\tint y = input_mt_get_value(oldest, ABS_MT_POSITION_Y);\n\n\t\tinput_event(dev, EV_ABS, ABS_X, x);\n\t\tinput_event(dev, EV_ABS, ABS_Y, y);\n\n\t\tif (test_bit(ABS_MT_PRESSURE, dev->absbit)) {\n\t\t\tint p = input_mt_get_value(oldest, ABS_MT_PRESSURE);\n\t\t\tinput_event(dev, EV_ABS, ABS_PRESSURE, p);\n\t\t}\n\t} else {\n\t\tif (test_bit(ABS_MT_PRESSURE, dev->absbit))\n\t\t\tinput_event(dev, EV_ABS, ABS_PRESSURE, 0);\n\t}\n}\nEXPORT_SYMBOL(input_mt_report_pointer_emulation);\n\nstatic void __input_mt_drop_unused(struct input_dev *dev, struct input_mt *mt)\n{\n\tint i;\n\n\tlockdep_assert_held(&dev->event_lock);\n\n\tfor (i = 0; i < mt->num_slots; i++) {\n\t\tif (input_mt_is_active(&mt->slots[i]) &&\n\t\t    !input_mt_is_used(mt, &mt->slots[i])) {\n\t\t\tinput_handle_event(dev, EV_ABS, ABS_MT_SLOT, i);\n\t\t\tinput_handle_event(dev, EV_ABS, ABS_MT_TRACKING_ID, -1);\n\t\t}\n\t}\n}\n\n \nvoid input_mt_drop_unused(struct input_dev *dev)\n{\n\tstruct input_mt *mt = dev->mt;\n\n\tif (mt) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t\t__input_mt_drop_unused(dev, mt);\n\t\tmt->frame++;\n\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(input_mt_drop_unused);\n\n \nvoid input_mt_release_slots(struct input_dev *dev)\n{\n\tstruct input_mt *mt = dev->mt;\n\n\tlockdep_assert_held(&dev->event_lock);\n\n\tif (mt) {\n\t\t \n\t\tmt->frame++;\n\n\t\t__input_mt_drop_unused(dev, mt);\n\n\t\tif (test_bit(ABS_PRESSURE, dev->absbit))\n\t\t\tinput_handle_event(dev, EV_ABS, ABS_PRESSURE, 0);\n\n\t\tmt->frame++;\n\t}\n}\n\n \nvoid input_mt_sync_frame(struct input_dev *dev)\n{\n\tstruct input_mt *mt = dev->mt;\n\tbool use_count = false;\n\n\tif (!mt)\n\t\treturn;\n\n\tif (mt->flags & INPUT_MT_DROP_UNUSED) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\t__input_mt_drop_unused(dev, mt);\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n\n\tif ((mt->flags & INPUT_MT_POINTER) && !(mt->flags & INPUT_MT_SEMI_MT))\n\t\tuse_count = true;\n\n\tinput_mt_report_pointer_emulation(dev, use_count);\n\n\tmt->frame++;\n}\nEXPORT_SYMBOL(input_mt_sync_frame);\n\nstatic int adjust_dual(int *begin, int step, int *end, int eq, int mu)\n{\n\tint f, *p, s, c;\n\n\tif (begin == end)\n\t\treturn 0;\n\n\tf = *begin;\n\tp = begin + step;\n\ts = p == end ? f + 1 : *p;\n\n\tfor (; p != end; p += step) {\n\t\tif (*p < f) {\n\t\t\ts = f;\n\t\t\tf = *p;\n\t\t} else if (*p < s) {\n\t\t\ts = *p;\n\t\t}\n\t}\n\n\tc = (f + s + 1) / 2;\n\tif (c == 0 || (c > mu && (!eq || mu > 0)))\n\t\treturn 0;\n\t \n\tif (s < 0 && mu <= 0)\n\t\tc *= 2;\n\n\tfor (p = begin; p != end; p += step)\n\t\t*p -= c;\n\n\treturn (c < s && s <= 0) || (f >= 0 && f < c);\n}\n\nstatic void find_reduced_matrix(int *w, int nr, int nc, int nrc, int mu)\n{\n\tint i, k, sum;\n\n\tfor (k = 0; k < nrc; k++) {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tadjust_dual(w + i, nr, w + i + nrc, nr <= nc, mu);\n\t\tsum = 0;\n\t\tfor (i = 0; i < nrc; i += nr)\n\t\t\tsum += adjust_dual(w + i, 1, w + i + nr, nc <= nr, mu);\n\t\tif (!sum)\n\t\t\tbreak;\n\t}\n}\n\nstatic int input_mt_set_matrix(struct input_mt *mt,\n\t\t\t       const struct input_mt_pos *pos, int num_pos,\n\t\t\t       int mu)\n{\n\tconst struct input_mt_pos *p;\n\tstruct input_mt_slot *s;\n\tint *w = mt->red;\n\tint x, y;\n\n\tfor (s = mt->slots; s != mt->slots + mt->num_slots; s++) {\n\t\tif (!input_mt_is_active(s))\n\t\t\tcontinue;\n\t\tx = input_mt_get_value(s, ABS_MT_POSITION_X);\n\t\ty = input_mt_get_value(s, ABS_MT_POSITION_Y);\n\t\tfor (p = pos; p != pos + num_pos; p++) {\n\t\t\tint dx = x - p->x, dy = y - p->y;\n\t\t\t*w++ = dx * dx + dy * dy - mu;\n\t\t}\n\t}\n\n\treturn w - mt->red;\n}\n\nstatic void input_mt_set_slots(struct input_mt *mt,\n\t\t\t       int *slots, int num_pos)\n{\n\tstruct input_mt_slot *s;\n\tint *w = mt->red, j;\n\n\tfor (j = 0; j != num_pos; j++)\n\t\tslots[j] = -1;\n\n\tfor (s = mt->slots; s != mt->slots + mt->num_slots; s++) {\n\t\tif (!input_mt_is_active(s))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j != num_pos; j++) {\n\t\t\tif (w[j] < 0) {\n\t\t\t\tslots[j] = s - mt->slots;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tw += num_pos;\n\t}\n\n\tfor (s = mt->slots; s != mt->slots + mt->num_slots; s++) {\n\t\tif (input_mt_is_active(s))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j != num_pos; j++) {\n\t\t\tif (slots[j] < 0) {\n\t\t\t\tslots[j] = s - mt->slots;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint input_mt_assign_slots(struct input_dev *dev, int *slots,\n\t\t\t  const struct input_mt_pos *pos, int num_pos,\n\t\t\t  int dmax)\n{\n\tstruct input_mt *mt = dev->mt;\n\tint mu = 2 * dmax * dmax;\n\tint nrc;\n\n\tif (!mt || !mt->red)\n\t\treturn -ENXIO;\n\tif (num_pos > mt->num_slots)\n\t\treturn -EINVAL;\n\tif (num_pos < 1)\n\t\treturn 0;\n\n\tnrc = input_mt_set_matrix(mt, pos, num_pos, mu);\n\tfind_reduced_matrix(mt->red, num_pos, nrc / num_pos, nrc, mu);\n\tinput_mt_set_slots(mt, slots, num_pos);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(input_mt_assign_slots);\n\n \nint input_mt_get_slot_by_key(struct input_dev *dev, int key)\n{\n\tstruct input_mt *mt = dev->mt;\n\tstruct input_mt_slot *s;\n\n\tif (!mt)\n\t\treturn -1;\n\n\tfor (s = mt->slots; s != mt->slots + mt->num_slots; s++)\n\t\tif (input_mt_is_active(s) && s->key == key)\n\t\t\treturn s - mt->slots;\n\n\tfor (s = mt->slots; s != mt->slots + mt->num_slots; s++)\n\t\tif (!input_mt_is_active(s) && !input_mt_is_used(mt, s)) {\n\t\t\ts->key = key;\n\t\t\treturn s - mt->slots;\n\t\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL(input_mt_get_slot_by_key);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}