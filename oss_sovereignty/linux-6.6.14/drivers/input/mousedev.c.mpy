{
  "module_name": "mousedev.c",
  "hash_id": "af6872b8807714cebe5088983868f8707ee92feddcad0459da60761e743b8997",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/mousedev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define MOUSEDEV_MINOR_BASE\t32\n#define MOUSEDEV_MINORS\t\t31\n#define MOUSEDEV_MIX\t\t63\n\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/random.h>\n#include <linux/major.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/kernel.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Mouse (ExplorerPS/2) device interfaces\");\nMODULE_LICENSE(\"GPL\");\n\n#ifndef CONFIG_INPUT_MOUSEDEV_SCREEN_X\n#define CONFIG_INPUT_MOUSEDEV_SCREEN_X\t1024\n#endif\n#ifndef CONFIG_INPUT_MOUSEDEV_SCREEN_Y\n#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y\t768\n#endif\n\nstatic int xres = CONFIG_INPUT_MOUSEDEV_SCREEN_X;\nmodule_param(xres, uint, 0644);\nMODULE_PARM_DESC(xres, \"Horizontal screen resolution\");\n\nstatic int yres = CONFIG_INPUT_MOUSEDEV_SCREEN_Y;\nmodule_param(yres, uint, 0644);\nMODULE_PARM_DESC(yres, \"Vertical screen resolution\");\n\nstatic unsigned tap_time = 200;\nmodule_param(tap_time, uint, 0644);\nMODULE_PARM_DESC(tap_time, \"Tap time for touchpads in absolute mode (msecs)\");\n\nstruct mousedev_hw_data {\n\tint dx, dy, dz;\n\tint x, y;\n\tint abs_event;\n\tunsigned long buttons;\n};\n\nstruct mousedev {\n\tint open;\n\tstruct input_handle handle;\n\twait_queue_head_t wait;\n\tstruct list_head client_list;\n\tspinlock_t client_lock;  \n\tstruct mutex mutex;\n\tstruct device dev;\n\tstruct cdev cdev;\n\tbool exist;\n\n\tstruct list_head mixdev_node;\n\tbool opened_by_mixdev;\n\n\tstruct mousedev_hw_data packet;\n\tunsigned int pkt_count;\n\tint old_x[4], old_y[4];\n\tint frac_dx, frac_dy;\n\tunsigned long touch;\n\n\tint (*open_device)(struct mousedev *mousedev);\n\tvoid (*close_device)(struct mousedev *mousedev);\n};\n\nenum mousedev_emul {\n\tMOUSEDEV_EMUL_PS2,\n\tMOUSEDEV_EMUL_IMPS,\n\tMOUSEDEV_EMUL_EXPS\n};\n\nstruct mousedev_motion {\n\tint dx, dy, dz;\n\tunsigned long buttons;\n};\n\n#define PACKET_QUEUE_LEN\t16\nstruct mousedev_client {\n\tstruct fasync_struct *fasync;\n\tstruct mousedev *mousedev;\n\tstruct list_head node;\n\n\tstruct mousedev_motion packets[PACKET_QUEUE_LEN];\n\tunsigned int head, tail;\n\tspinlock_t packet_lock;\n\tint pos_x, pos_y;\n\n\tu8 ps2[6];\n\tunsigned char ready, buffer, bufsiz;\n\tunsigned char imexseq, impsseq;\n\tenum mousedev_emul mode;\n\tunsigned long last_buttons;\n};\n\n#define MOUSEDEV_SEQ_LEN\t6\n\nstatic unsigned char mousedev_imps_seq[] = { 0xf3, 200, 0xf3, 100, 0xf3, 80 };\nstatic unsigned char mousedev_imex_seq[] = { 0xf3, 200, 0xf3, 200, 0xf3, 80 };\n\nstatic struct mousedev *mousedev_mix;\nstatic LIST_HEAD(mousedev_mix_list);\n\n#define fx(i)  (mousedev->old_x[(mousedev->pkt_count - (i)) & 03])\n#define fy(i)  (mousedev->old_y[(mousedev->pkt_count - (i)) & 03])\n\nstatic void mousedev_touchpad_event(struct input_dev *dev,\n\t\t\t\t    struct mousedev *mousedev,\n\t\t\t\t    unsigned int code, int value)\n{\n\tint size, tmp;\n\tenum { FRACTION_DENOM = 128 };\n\n\tswitch (code) {\n\n\tcase ABS_X:\n\n\t\tfx(0) = value;\n\t\tif (mousedev->touch && mousedev->pkt_count >= 2) {\n\t\t\tsize = input_abs_get_max(dev, ABS_X) -\n\t\t\t\t\tinput_abs_get_min(dev, ABS_X);\n\t\t\tif (size == 0)\n\t\t\t\tsize = 256 * 2;\n\n\t\t\ttmp = ((value - fx(2)) * 256 * FRACTION_DENOM) / size;\n\t\t\ttmp += mousedev->frac_dx;\n\t\t\tmousedev->packet.dx = tmp / FRACTION_DENOM;\n\t\t\tmousedev->frac_dx =\n\t\t\t\ttmp - mousedev->packet.dx * FRACTION_DENOM;\n\t\t}\n\t\tbreak;\n\n\tcase ABS_Y:\n\t\tfy(0) = value;\n\t\tif (mousedev->touch && mousedev->pkt_count >= 2) {\n\t\t\t \n\t\t\tsize = input_abs_get_max(dev, ABS_X) -\n\t\t\t\t\tinput_abs_get_min(dev, ABS_X);\n\t\t\tif (size == 0)\n\t\t\t\tsize = 256 * 2;\n\n\t\t\ttmp = -((value - fy(2)) * 256 * FRACTION_DENOM) / size;\n\t\t\ttmp += mousedev->frac_dy;\n\t\t\tmousedev->packet.dy = tmp / FRACTION_DENOM;\n\t\t\tmousedev->frac_dy = tmp -\n\t\t\t\tmousedev->packet.dy * FRACTION_DENOM;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mousedev_abs_event(struct input_dev *dev, struct mousedev *mousedev,\n\t\t\t\tunsigned int code, int value)\n{\n\tint min, max, size;\n\n\tswitch (code) {\n\n\tcase ABS_X:\n\t\tmin = input_abs_get_min(dev, ABS_X);\n\t\tmax = input_abs_get_max(dev, ABS_X);\n\n\t\tsize = max - min;\n\t\tif (size == 0)\n\t\t\tsize = xres ? : 1;\n\n\t\tvalue = clamp(value, min, max);\n\n\t\tmousedev->packet.x = ((value - min) * xres) / size;\n\t\tmousedev->packet.abs_event = 1;\n\t\tbreak;\n\n\tcase ABS_Y:\n\t\tmin = input_abs_get_min(dev, ABS_Y);\n\t\tmax = input_abs_get_max(dev, ABS_Y);\n\n\t\tsize = max - min;\n\t\tif (size == 0)\n\t\t\tsize = yres ? : 1;\n\n\t\tvalue = clamp(value, min, max);\n\n\t\tmousedev->packet.y = yres - ((value - min) * yres) / size;\n\t\tmousedev->packet.abs_event = 1;\n\t\tbreak;\n\t}\n}\n\nstatic void mousedev_rel_event(struct mousedev *mousedev,\n\t\t\t\tunsigned int code, int value)\n{\n\tswitch (code) {\n\tcase REL_X:\n\t\tmousedev->packet.dx += value;\n\t\tbreak;\n\n\tcase REL_Y:\n\t\tmousedev->packet.dy -= value;\n\t\tbreak;\n\n\tcase REL_WHEEL:\n\t\tmousedev->packet.dz -= value;\n\t\tbreak;\n\t}\n}\n\nstatic void mousedev_key_event(struct mousedev *mousedev,\n\t\t\t\tunsigned int code, int value)\n{\n\tint index;\n\n\tswitch (code) {\n\n\tcase BTN_TOUCH:\n\tcase BTN_0:\n\tcase BTN_LEFT:\t\tindex = 0; break;\n\n\tcase BTN_STYLUS:\n\tcase BTN_1:\n\tcase BTN_RIGHT:\t\tindex = 1; break;\n\n\tcase BTN_2:\n\tcase BTN_FORWARD:\n\tcase BTN_STYLUS2:\n\tcase BTN_MIDDLE:\tindex = 2; break;\n\n\tcase BTN_3:\n\tcase BTN_BACK:\n\tcase BTN_SIDE:\t\tindex = 3; break;\n\n\tcase BTN_4:\n\tcase BTN_EXTRA:\t\tindex = 4; break;\n\n\tdefault:\t\treturn;\n\t}\n\n\tif (value) {\n\t\tset_bit(index, &mousedev->packet.buttons);\n\t\tset_bit(index, &mousedev_mix->packet.buttons);\n\t} else {\n\t\tclear_bit(index, &mousedev->packet.buttons);\n\t\tclear_bit(index, &mousedev_mix->packet.buttons);\n\t}\n}\n\nstatic void mousedev_notify_readers(struct mousedev *mousedev,\n\t\t\t\t    struct mousedev_hw_data *packet)\n{\n\tstruct mousedev_client *client;\n\tstruct mousedev_motion *p;\n\tunsigned int new_head;\n\tint wake_readers = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(client, &mousedev->client_list, node) {\n\n\t\t \n\t\tspin_lock(&client->packet_lock);\n\n\t\tp = &client->packets[client->head];\n\t\tif (client->ready && p->buttons != mousedev->packet.buttons) {\n\t\t\tnew_head = (client->head + 1) % PACKET_QUEUE_LEN;\n\t\t\tif (new_head != client->tail) {\n\t\t\t\tp = &client->packets[client->head = new_head];\n\t\t\t\tmemset(p, 0, sizeof(struct mousedev_motion));\n\t\t\t}\n\t\t}\n\n\t\tif (packet->abs_event) {\n\t\t\tp->dx += packet->x - client->pos_x;\n\t\t\tp->dy += packet->y - client->pos_y;\n\t\t\tclient->pos_x = packet->x;\n\t\t\tclient->pos_y = packet->y;\n\t\t}\n\n\t\tclient->pos_x += packet->dx;\n\t\tclient->pos_x = clamp_val(client->pos_x, 0, xres);\n\n\t\tclient->pos_y += packet->dy;\n\t\tclient->pos_y = clamp_val(client->pos_y, 0, yres);\n\n\t\tp->dx += packet->dx;\n\t\tp->dy += packet->dy;\n\t\tp->dz += packet->dz;\n\t\tp->buttons = mousedev->packet.buttons;\n\n\t\tif (p->dx || p->dy || p->dz ||\n\t\t    p->buttons != client->last_buttons)\n\t\t\tclient->ready = 1;\n\n\t\tspin_unlock(&client->packet_lock);\n\n\t\tif (client->ready) {\n\t\t\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n\t\t\twake_readers = 1;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (wake_readers)\n\t\twake_up_interruptible(&mousedev->wait);\n}\n\nstatic void mousedev_touchpad_touch(struct mousedev *mousedev, int value)\n{\n\tif (!value) {\n\t\tif (mousedev->touch &&\n\t\t    time_before(jiffies,\n\t\t\t\tmousedev->touch + msecs_to_jiffies(tap_time))) {\n\t\t\t \n\t\t\tset_bit(0, &mousedev->packet.buttons);\n\t\t\tset_bit(0, &mousedev_mix->packet.buttons);\n\t\t\tmousedev_notify_readers(mousedev, &mousedev_mix->packet);\n\t\t\tmousedev_notify_readers(mousedev_mix,\n\t\t\t\t\t\t&mousedev_mix->packet);\n\t\t\tclear_bit(0, &mousedev->packet.buttons);\n\t\t\tclear_bit(0, &mousedev_mix->packet.buttons);\n\t\t}\n\t\tmousedev->touch = mousedev->pkt_count = 0;\n\t\tmousedev->frac_dx = 0;\n\t\tmousedev->frac_dy = 0;\n\n\t} else if (!mousedev->touch)\n\t\tmousedev->touch = jiffies;\n}\n\nstatic void mousedev_event(struct input_handle *handle,\n\t\t\t   unsigned int type, unsigned int code, int value)\n{\n\tstruct mousedev *mousedev = handle->private;\n\n\tswitch (type) {\n\n\tcase EV_ABS:\n\t\t \n\t\tif (test_bit(BTN_TRIGGER, handle->dev->keybit))\n\t\t\treturn;\n\n\t\tif (test_bit(BTN_TOOL_FINGER, handle->dev->keybit))\n\t\t\tmousedev_touchpad_event(handle->dev,\n\t\t\t\t\t\tmousedev, code, value);\n\t\telse\n\t\t\tmousedev_abs_event(handle->dev, mousedev, code, value);\n\n\t\tbreak;\n\n\tcase EV_REL:\n\t\tmousedev_rel_event(mousedev, code, value);\n\t\tbreak;\n\n\tcase EV_KEY:\n\t\tif (value != 2) {\n\t\t\tif (code == BTN_TOUCH &&\n\t\t\t    test_bit(BTN_TOOL_FINGER, handle->dev->keybit))\n\t\t\t\tmousedev_touchpad_touch(mousedev, value);\n\t\t\telse\n\t\t\t\tmousedev_key_event(mousedev, code, value);\n\t\t}\n\t\tbreak;\n\n\tcase EV_SYN:\n\t\tif (code == SYN_REPORT) {\n\t\t\tif (mousedev->touch) {\n\t\t\t\tmousedev->pkt_count++;\n\t\t\t\t \n\t\t\t\tfx(0) = fx(1);\n\t\t\t\tfy(0) = fy(1);\n\t\t\t}\n\n\t\t\tmousedev_notify_readers(mousedev, &mousedev->packet);\n\t\t\tmousedev_notify_readers(mousedev_mix, &mousedev->packet);\n\n\t\t\tmousedev->packet.dx = mousedev->packet.dy =\n\t\t\t\tmousedev->packet.dz = 0;\n\t\t\tmousedev->packet.abs_event = 0;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int mousedev_fasync(int fd, struct file *file, int on)\n{\n\tstruct mousedev_client *client = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &client->fasync);\n}\n\nstatic void mousedev_free(struct device *dev)\n{\n\tstruct mousedev *mousedev = container_of(dev, struct mousedev, dev);\n\n\tinput_put_device(mousedev->handle.dev);\n\tkfree(mousedev);\n}\n\nstatic int mousedev_open_device(struct mousedev *mousedev)\n{\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&mousedev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!mousedev->exist)\n\t\tretval = -ENODEV;\n\telse if (!mousedev->open++) {\n\t\tretval = input_open_device(&mousedev->handle);\n\t\tif (retval)\n\t\t\tmousedev->open--;\n\t}\n\n\tmutex_unlock(&mousedev->mutex);\n\treturn retval;\n}\n\nstatic void mousedev_close_device(struct mousedev *mousedev)\n{\n\tmutex_lock(&mousedev->mutex);\n\n\tif (mousedev->exist && !--mousedev->open)\n\t\tinput_close_device(&mousedev->handle);\n\n\tmutex_unlock(&mousedev->mutex);\n}\n\n \nstatic int mixdev_open_devices(struct mousedev *mixdev)\n{\n\tint error;\n\n\terror = mutex_lock_interruptible(&mixdev->mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (!mixdev->open++) {\n\t\tstruct mousedev *mousedev;\n\n\t\tlist_for_each_entry(mousedev, &mousedev_mix_list, mixdev_node) {\n\t\t\tif (!mousedev->opened_by_mixdev) {\n\t\t\t\tif (mousedev_open_device(mousedev))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmousedev->opened_by_mixdev = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&mixdev->mutex);\n\treturn 0;\n}\n\n \nstatic void mixdev_close_devices(struct mousedev *mixdev)\n{\n\tmutex_lock(&mixdev->mutex);\n\n\tif (!--mixdev->open) {\n\t\tstruct mousedev *mousedev;\n\n\t\tlist_for_each_entry(mousedev, &mousedev_mix_list, mixdev_node) {\n\t\t\tif (mousedev->opened_by_mixdev) {\n\t\t\t\tmousedev->opened_by_mixdev = false;\n\t\t\t\tmousedev_close_device(mousedev);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&mixdev->mutex);\n}\n\n\nstatic void mousedev_attach_client(struct mousedev *mousedev,\n\t\t\t\t   struct mousedev_client *client)\n{\n\tspin_lock(&mousedev->client_lock);\n\tlist_add_tail_rcu(&client->node, &mousedev->client_list);\n\tspin_unlock(&mousedev->client_lock);\n}\n\nstatic void mousedev_detach_client(struct mousedev *mousedev,\n\t\t\t\t   struct mousedev_client *client)\n{\n\tspin_lock(&mousedev->client_lock);\n\tlist_del_rcu(&client->node);\n\tspin_unlock(&mousedev->client_lock);\n\tsynchronize_rcu();\n}\n\nstatic int mousedev_release(struct inode *inode, struct file *file)\n{\n\tstruct mousedev_client *client = file->private_data;\n\tstruct mousedev *mousedev = client->mousedev;\n\n\tmousedev_detach_client(mousedev, client);\n\tkfree(client);\n\n\tmousedev->close_device(mousedev);\n\n\treturn 0;\n}\n\nstatic int mousedev_open(struct inode *inode, struct file *file)\n{\n\tstruct mousedev_client *client;\n\tstruct mousedev *mousedev;\n\tint error;\n\n#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX\n\tif (imajor(inode) == MISC_MAJOR)\n\t\tmousedev = mousedev_mix;\n\telse\n#endif\n\t\tmousedev = container_of(inode->i_cdev, struct mousedev, cdev);\n\n\tclient = kzalloc(sizeof(struct mousedev_client), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&client->packet_lock);\n\tclient->pos_x = xres / 2;\n\tclient->pos_y = yres / 2;\n\tclient->mousedev = mousedev;\n\tmousedev_attach_client(mousedev, client);\n\n\terror = mousedev->open_device(mousedev);\n\tif (error)\n\t\tgoto err_free_client;\n\n\tfile->private_data = client;\n\tstream_open(inode, file);\n\n\treturn 0;\n\n err_free_client:\n\tmousedev_detach_client(mousedev, client);\n\tkfree(client);\n\treturn error;\n}\n\nstatic void mousedev_packet(struct mousedev_client *client, u8 *ps2_data)\n{\n\tstruct mousedev_motion *p = &client->packets[client->tail];\n\ts8 dx, dy, dz;\n\n\tdx = clamp_val(p->dx, -127, 127);\n\tp->dx -= dx;\n\n\tdy = clamp_val(p->dy, -127, 127);\n\tp->dy -= dy;\n\n\tps2_data[0] = BIT(3);\n\tps2_data[0] |= ((dx & BIT(7)) >> 3) | ((dy & BIT(7)) >> 2);\n\tps2_data[0] |= p->buttons & 0x07;\n\tps2_data[1] = dx;\n\tps2_data[2] = dy;\n\n\tswitch (client->mode) {\n\tcase MOUSEDEV_EMUL_EXPS:\n\t\tdz = clamp_val(p->dz, -7, 7);\n\t\tp->dz -= dz;\n\n\t\tps2_data[3] = (dz & 0x0f) | ((p->buttons & 0x18) << 1);\n\t\tclient->bufsiz = 4;\n\t\tbreak;\n\n\tcase MOUSEDEV_EMUL_IMPS:\n\t\tdz = clamp_val(p->dz, -127, 127);\n\t\tp->dz -= dz;\n\n\t\tps2_data[0] |= ((p->buttons & 0x10) >> 3) |\n\t\t\t       ((p->buttons & 0x08) >> 1);\n\t\tps2_data[3] = dz;\n\n\t\tclient->bufsiz = 4;\n\t\tbreak;\n\n\tcase MOUSEDEV_EMUL_PS2:\n\tdefault:\n\t\tp->dz = 0;\n\n\t\tps2_data[0] |= ((p->buttons & 0x10) >> 3) |\n\t\t\t       ((p->buttons & 0x08) >> 1);\n\n\t\tclient->bufsiz = 3;\n\t\tbreak;\n\t}\n\n\tif (!p->dx && !p->dy && !p->dz) {\n\t\tif (client->tail == client->head) {\n\t\t\tclient->ready = 0;\n\t\t\tclient->last_buttons = p->buttons;\n\t\t} else\n\t\t\tclient->tail = (client->tail + 1) % PACKET_QUEUE_LEN;\n\t}\n}\n\nstatic void mousedev_generate_response(struct mousedev_client *client,\n\t\t\t\t\tint command)\n{\n\tclient->ps2[0] = 0xfa;  \n\n\tswitch (command) {\n\n\tcase 0xeb:  \n\t\tmousedev_packet(client, &client->ps2[1]);\n\t\tclient->bufsiz++;  \n\t\tbreak;\n\n\tcase 0xf2:  \n\t\tswitch (client->mode) {\n\t\tcase MOUSEDEV_EMUL_PS2:\n\t\t\tclient->ps2[1] = 0;\n\t\t\tbreak;\n\t\tcase MOUSEDEV_EMUL_IMPS:\n\t\t\tclient->ps2[1] = 3;\n\t\t\tbreak;\n\t\tcase MOUSEDEV_EMUL_EXPS:\n\t\t\tclient->ps2[1] = 4;\n\t\t\tbreak;\n\t\t}\n\t\tclient->bufsiz = 2;\n\t\tbreak;\n\n\tcase 0xe9:  \n\t\tclient->ps2[1] = 0x60; client->ps2[2] = 3; client->ps2[3] = 200;\n\t\tclient->bufsiz = 4;\n\t\tbreak;\n\n\tcase 0xff:  \n\t\tclient->impsseq = client->imexseq = 0;\n\t\tclient->mode = MOUSEDEV_EMUL_PS2;\n\t\tclient->ps2[1] = 0xaa; client->ps2[2] = 0x00;\n\t\tclient->bufsiz = 3;\n\t\tbreak;\n\n\tdefault:\n\t\tclient->bufsiz = 1;\n\t\tbreak;\n\t}\n\tclient->buffer = client->bufsiz;\n}\n\nstatic ssize_t mousedev_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mousedev_client *client = file->private_data;\n\tunsigned char c;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif (get_user(c, buffer + i))\n\t\t\treturn -EFAULT;\n\n\t\tspin_lock_irq(&client->packet_lock);\n\n\t\tif (c == mousedev_imex_seq[client->imexseq]) {\n\t\t\tif (++client->imexseq == MOUSEDEV_SEQ_LEN) {\n\t\t\t\tclient->imexseq = 0;\n\t\t\t\tclient->mode = MOUSEDEV_EMUL_EXPS;\n\t\t\t}\n\t\t} else\n\t\t\tclient->imexseq = 0;\n\n\t\tif (c == mousedev_imps_seq[client->impsseq]) {\n\t\t\tif (++client->impsseq == MOUSEDEV_SEQ_LEN) {\n\t\t\t\tclient->impsseq = 0;\n\t\t\t\tclient->mode = MOUSEDEV_EMUL_IMPS;\n\t\t\t}\n\t\t} else\n\t\t\tclient->impsseq = 0;\n\n\t\tmousedev_generate_response(client, c);\n\n\t\tspin_unlock_irq(&client->packet_lock);\n\t\tcond_resched();\n\t}\n\n\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible(&client->mousedev->wait);\n\n\treturn count;\n}\n\nstatic ssize_t mousedev_read(struct file *file, char __user *buffer,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct mousedev_client *client = file->private_data;\n\tstruct mousedev *mousedev = client->mousedev;\n\tu8 data[sizeof(client->ps2)];\n\tint retval = 0;\n\n\tif (!client->ready && !client->buffer && mousedev->exist &&\n\t    (file->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\n\tretval = wait_event_interruptible(mousedev->wait,\n\t\t\t!mousedev->exist || client->ready || client->buffer);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!mousedev->exist)\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&client->packet_lock);\n\n\tif (!client->buffer && client->ready) {\n\t\tmousedev_packet(client, client->ps2);\n\t\tclient->buffer = client->bufsiz;\n\t}\n\n\tif (count > client->buffer)\n\t\tcount = client->buffer;\n\n\tmemcpy(data, client->ps2 + client->bufsiz - client->buffer, count);\n\tclient->buffer -= count;\n\n\tspin_unlock_irq(&client->packet_lock);\n\n\tif (copy_to_user(buffer, data, count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\n \nstatic __poll_t mousedev_poll(struct file *file, poll_table *wait)\n{\n\tstruct mousedev_client *client = file->private_data;\n\tstruct mousedev *mousedev = client->mousedev;\n\t__poll_t mask;\n\n\tpoll_wait(file, &mousedev->wait, wait);\n\n\tmask = mousedev->exist ? EPOLLOUT | EPOLLWRNORM : EPOLLHUP | EPOLLERR;\n\tif (client->ready || client->buffer)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic const struct file_operations mousedev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= mousedev_read,\n\t.write\t\t= mousedev_write,\n\t.poll\t\t= mousedev_poll,\n\t.open\t\t= mousedev_open,\n\t.release\t= mousedev_release,\n\t.fasync\t\t= mousedev_fasync,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic void mousedev_mark_dead(struct mousedev *mousedev)\n{\n\tmutex_lock(&mousedev->mutex);\n\tmousedev->exist = false;\n\tmutex_unlock(&mousedev->mutex);\n}\n\n \nstatic void mousedev_hangup(struct mousedev *mousedev)\n{\n\tstruct mousedev_client *client;\n\n\tspin_lock(&mousedev->client_lock);\n\tlist_for_each_entry(client, &mousedev->client_list, node)\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\tspin_unlock(&mousedev->client_lock);\n\n\twake_up_interruptible(&mousedev->wait);\n}\n\nstatic void mousedev_cleanup(struct mousedev *mousedev)\n{\n\tstruct input_handle *handle = &mousedev->handle;\n\n\tmousedev_mark_dead(mousedev);\n\tmousedev_hangup(mousedev);\n\n\t \n\tif (mousedev->open)\n\t\tinput_close_device(handle);\n}\n\nstatic int mousedev_reserve_minor(bool mixdev)\n{\n\tint minor;\n\n\tif (mixdev) {\n\t\tminor = input_get_new_minor(MOUSEDEV_MIX, 1, false);\n\t\tif (minor < 0)\n\t\t\tpr_err(\"failed to reserve mixdev minor: %d\\n\", minor);\n\t} else {\n\t\tminor = input_get_new_minor(MOUSEDEV_MINOR_BASE,\n\t\t\t\t\t    MOUSEDEV_MINORS, true);\n\t\tif (minor < 0)\n\t\t\tpr_err(\"failed to reserve new minor: %d\\n\", minor);\n\t}\n\n\treturn minor;\n}\n\nstatic struct mousedev *mousedev_create(struct input_dev *dev,\n\t\t\t\t\tstruct input_handler *handler,\n\t\t\t\t\tbool mixdev)\n{\n\tstruct mousedev *mousedev;\n\tint minor;\n\tint error;\n\n\tminor = mousedev_reserve_minor(mixdev);\n\tif (minor < 0) {\n\t\terror = minor;\n\t\tgoto err_out;\n\t}\n\n\tmousedev = kzalloc(sizeof(struct mousedev), GFP_KERNEL);\n\tif (!mousedev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_minor;\n\t}\n\n\tINIT_LIST_HEAD(&mousedev->client_list);\n\tINIT_LIST_HEAD(&mousedev->mixdev_node);\n\tspin_lock_init(&mousedev->client_lock);\n\tmutex_init(&mousedev->mutex);\n\tlockdep_set_subclass(&mousedev->mutex,\n\t\t\t     mixdev ? SINGLE_DEPTH_NESTING : 0);\n\tinit_waitqueue_head(&mousedev->wait);\n\n\tif (mixdev) {\n\t\tdev_set_name(&mousedev->dev, \"mice\");\n\n\t\tmousedev->open_device = mixdev_open_devices;\n\t\tmousedev->close_device = mixdev_close_devices;\n\t} else {\n\t\tint dev_no = minor;\n\t\t \n\t\tif (dev_no < MOUSEDEV_MINOR_BASE + MOUSEDEV_MINORS)\n\t\t\tdev_no -= MOUSEDEV_MINOR_BASE;\n\t\tdev_set_name(&mousedev->dev, \"mouse%d\", dev_no);\n\n\t\tmousedev->open_device = mousedev_open_device;\n\t\tmousedev->close_device = mousedev_close_device;\n\t}\n\n\tmousedev->exist = true;\n\tmousedev->handle.dev = input_get_device(dev);\n\tmousedev->handle.name = dev_name(&mousedev->dev);\n\tmousedev->handle.handler = handler;\n\tmousedev->handle.private = mousedev;\n\n\tmousedev->dev.class = &input_class;\n\tif (dev)\n\t\tmousedev->dev.parent = &dev->dev;\n\tmousedev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n\tmousedev->dev.release = mousedev_free;\n\tdevice_initialize(&mousedev->dev);\n\n\tif (!mixdev) {\n\t\terror = input_register_handle(&mousedev->handle);\n\t\tif (error)\n\t\t\tgoto err_free_mousedev;\n\t}\n\n\tcdev_init(&mousedev->cdev, &mousedev_fops);\n\n\terror = cdev_device_add(&mousedev->cdev, &mousedev->dev);\n\tif (error)\n\t\tgoto err_cleanup_mousedev;\n\n\treturn mousedev;\n\n err_cleanup_mousedev:\n\tmousedev_cleanup(mousedev);\n\tif (!mixdev)\n\t\tinput_unregister_handle(&mousedev->handle);\n err_free_mousedev:\n\tput_device(&mousedev->dev);\n err_free_minor:\n\tinput_free_minor(minor);\n err_out:\n\treturn ERR_PTR(error);\n}\n\nstatic void mousedev_destroy(struct mousedev *mousedev)\n{\n\tcdev_device_del(&mousedev->cdev, &mousedev->dev);\n\tmousedev_cleanup(mousedev);\n\tinput_free_minor(MINOR(mousedev->dev.devt));\n\tif (mousedev != mousedev_mix)\n\t\tinput_unregister_handle(&mousedev->handle);\n\tput_device(&mousedev->dev);\n}\n\nstatic int mixdev_add_device(struct mousedev *mousedev)\n{\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&mousedev_mix->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (mousedev_mix->open) {\n\t\tretval = mousedev_open_device(mousedev);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tmousedev->opened_by_mixdev = true;\n\t}\n\n\tget_device(&mousedev->dev);\n\tlist_add_tail(&mousedev->mixdev_node, &mousedev_mix_list);\n\n out:\n\tmutex_unlock(&mousedev_mix->mutex);\n\treturn retval;\n}\n\nstatic void mixdev_remove_device(struct mousedev *mousedev)\n{\n\tmutex_lock(&mousedev_mix->mutex);\n\n\tif (mousedev->opened_by_mixdev) {\n\t\tmousedev->opened_by_mixdev = false;\n\t\tmousedev_close_device(mousedev);\n\t}\n\n\tlist_del_init(&mousedev->mixdev_node);\n\tmutex_unlock(&mousedev_mix->mutex);\n\n\tput_device(&mousedev->dev);\n}\n\nstatic int mousedev_connect(struct input_handler *handler,\n\t\t\t    struct input_dev *dev,\n\t\t\t    const struct input_device_id *id)\n{\n\tstruct mousedev *mousedev;\n\tint error;\n\n\tmousedev = mousedev_create(dev, handler, false);\n\tif (IS_ERR(mousedev))\n\t\treturn PTR_ERR(mousedev);\n\n\terror = mixdev_add_device(mousedev);\n\tif (error) {\n\t\tmousedev_destroy(mousedev);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void mousedev_disconnect(struct input_handle *handle)\n{\n\tstruct mousedev *mousedev = handle->private;\n\n\tmixdev_remove_device(mousedev);\n\tmousedev_destroy(mousedev);\n}\n\nstatic const struct input_device_id mousedev_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_RELBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) },\n\t\t.keybit = { [BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) },\n\t\t.relbit = { BIT_MASK(REL_X) | BIT_MASK(REL_Y) },\n\t},\t \n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_RELBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) },\n\t\t.relbit = { BIT_MASK(REL_WHEEL) },\n\t},\t \n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) },\n\t\t.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },\n\t\t.absbit = { BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },\n\t},\t \n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) },\n\t\t.keybit = { [BIT_WORD(BTN_TOOL_FINGER)] =\n\t\t\t\tBIT_MASK(BTN_TOOL_FINGER) },\n\t\t.absbit = { BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\n\t\t\t\tBIT_MASK(ABS_PRESSURE) |\n\t\t\t\tBIT_MASK(ABS_TOOL_WIDTH) },\n\t},\t \n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT |\n\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) },\n\t\t.keybit = { [BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) },\n\t\t.absbit = { BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },\n\t},\t \n\n\t{ },\t \n};\n\nMODULE_DEVICE_TABLE(input, mousedev_ids);\n\nstatic struct input_handler mousedev_handler = {\n\t.event\t\t= mousedev_event,\n\t.connect\t= mousedev_connect,\n\t.disconnect\t= mousedev_disconnect,\n\t.legacy_minors\t= true,\n\t.minor\t\t= MOUSEDEV_MINOR_BASE,\n\t.name\t\t= \"mousedev\",\n\t.id_table\t= mousedev_ids,\n};\n\n#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX\n#include <linux/miscdevice.h>\n\nstatic struct miscdevice psaux_mouse = {\n\t.minor\t= PSMOUSE_MINOR,\n\t.name\t= \"psaux\",\n\t.fops\t= &mousedev_fops,\n};\n\nstatic bool psaux_registered;\n\nstatic void __init mousedev_psaux_register(void)\n{\n\tint error;\n\n\terror = misc_register(&psaux_mouse);\n\tif (error)\n\t\tpr_warn(\"could not register psaux device, error: %d\\n\",\n\t\t\t   error);\n\telse\n\t\tpsaux_registered = true;\n}\n\nstatic void __exit mousedev_psaux_unregister(void)\n{\n\tif (psaux_registered)\n\t\tmisc_deregister(&psaux_mouse);\n}\n#else\nstatic inline void mousedev_psaux_register(void) { }\nstatic inline void mousedev_psaux_unregister(void) { }\n#endif\n\nstatic int __init mousedev_init(void)\n{\n\tint error;\n\n\tmousedev_mix = mousedev_create(NULL, &mousedev_handler, true);\n\tif (IS_ERR(mousedev_mix))\n\t\treturn PTR_ERR(mousedev_mix);\n\n\terror = input_register_handler(&mousedev_handler);\n\tif (error) {\n\t\tmousedev_destroy(mousedev_mix);\n\t\treturn error;\n\t}\n\n\tmousedev_psaux_register();\n\n\tpr_info(\"PS/2 mouse device common for all mice\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit mousedev_exit(void)\n{\n\tmousedev_psaux_unregister();\n\tinput_unregister_handler(&mousedev_handler);\n\tmousedev_destroy(mousedev_mix);\n}\n\nmodule_init(mousedev_init);\nmodule_exit(mousedev_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}