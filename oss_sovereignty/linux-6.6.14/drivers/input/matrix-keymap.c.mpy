{
  "module_name": "matrix-keymap.c",
  "hash_id": "c83f93a32f1701a3d592215e3e36d6cad5eb5b02264ecf4dd00980651ac8110b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/matrix-keymap.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic bool matrix_keypad_map_key(struct input_dev *input_dev,\n\t\t\t\t  unsigned int rows, unsigned int cols,\n\t\t\t\t  unsigned int row_shift, unsigned int key)\n{\n\tunsigned short *keymap = input_dev->keycode;\n\tunsigned int row = KEY_ROW(key);\n\tunsigned int col = KEY_COL(key);\n\tunsigned short code = KEY_VAL(key);\n\n\tif (row >= rows || col >= cols) {\n\t\tdev_err(input_dev->dev.parent,\n\t\t\t\"%s: invalid keymap entry 0x%x (row: %d, col: %d, rows: %d, cols: %d)\\n\",\n\t\t\t__func__, key, row, col, rows, cols);\n\t\treturn false;\n\t}\n\n\tkeymap[MATRIX_SCAN_CODE(row, col, row_shift)] = code;\n\t__set_bit(code, input_dev->keybit);\n\n\treturn true;\n}\n\n \nint matrix_keypad_parse_properties(struct device *dev,\n\t\t\t\t   unsigned int *rows, unsigned int *cols)\n{\n\t*rows = *cols = 0;\n\n\tdevice_property_read_u32(dev, \"keypad,num-rows\", rows);\n\tdevice_property_read_u32(dev, \"keypad,num-columns\", cols);\n\n\tif (!*rows || !*cols) {\n\t\tdev_err(dev, \"number of keypad rows/columns not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(matrix_keypad_parse_properties);\n\nstatic int matrix_keypad_parse_keymap(const char *propname,\n\t\t\t\t      unsigned int rows, unsigned int cols,\n\t\t\t\t      struct input_dev *input_dev)\n{\n\tstruct device *dev = input_dev->dev.parent;\n\tunsigned int row_shift = get_count_order(cols);\n\tunsigned int max_keys = rows << row_shift;\n\tu32 *keys;\n\tint i;\n\tint size;\n\tint retval;\n\n\tif (!propname)\n\t\tpropname = \"linux,keymap\";\n\n\tsize = device_property_count_u32(dev, propname);\n\tif (size <= 0) {\n\t\tdev_err(dev, \"missing or malformed property %s: %d\\n\",\n\t\t\tpropname, size);\n\t\treturn size < 0 ? size : -EINVAL;\n\t}\n\n\tif (size > max_keys) {\n\t\tdev_err(dev, \"%s size overflow (%d vs max %u)\\n\",\n\t\t\tpropname, size, max_keys);\n\t\treturn -EINVAL;\n\t}\n\n\tkeys = kmalloc_array(size, sizeof(u32), GFP_KERNEL);\n\tif (!keys)\n\t\treturn -ENOMEM;\n\n\tretval = device_property_read_u32_array(dev, propname, keys, size);\n\tif (retval) {\n\t\tdev_err(dev, \"failed to read %s property: %d\\n\",\n\t\t\tpropname, retval);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (!matrix_keypad_map_key(input_dev, rows, cols,\n\t\t\t\t\t   row_shift, keys[i])) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tretval = 0;\n\nout:\n\tkfree(keys);\n\treturn retval;\n}\n\n \nint matrix_keypad_build_keymap(const struct matrix_keymap_data *keymap_data,\n\t\t\t       const char *keymap_name,\n\t\t\t       unsigned int rows, unsigned int cols,\n\t\t\t       unsigned short *keymap,\n\t\t\t       struct input_dev *input_dev)\n{\n\tunsigned int row_shift = get_count_order(cols);\n\tsize_t max_keys = rows << row_shift;\n\tint i;\n\tint error;\n\n\tif (WARN_ON(!input_dev->dev.parent))\n\t\treturn -EINVAL;\n\n\tif (!keymap) {\n\t\tkeymap = devm_kcalloc(input_dev->dev.parent,\n\t\t\t\t      max_keys, sizeof(*keymap),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!keymap) {\n\t\t\tdev_err(input_dev->dev.parent,\n\t\t\t\t\"Unable to allocate memory for keymap\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tinput_dev->keycode = keymap;\n\tinput_dev->keycodesize = sizeof(*keymap);\n\tinput_dev->keycodemax = max_keys;\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\n\tif (keymap_data) {\n\t\tfor (i = 0; i < keymap_data->keymap_size; i++) {\n\t\t\tunsigned int key = keymap_data->keymap[i];\n\n\t\t\tif (!matrix_keypad_map_key(input_dev, rows, cols,\n\t\t\t\t\t\t   row_shift, key))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\terror = matrix_keypad_parse_keymap(keymap_name, rows, cols,\n\t\t\t\t\t\t   input_dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t__clear_bit(KEY_RESERVED, input_dev->keybit);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(matrix_keypad_build_keymap);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}