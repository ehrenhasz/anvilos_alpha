{
  "module_name": "joydev.c",
  "hash_id": "6c9a4364eb47815bea6e1a3486acb6f8c34f1a6f065eabf510fc3e3315c5b2ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joydev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm/io.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/joystick.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Joystick device interfaces\");\nMODULE_LICENSE(\"GPL\");\n\n#define JOYDEV_MINOR_BASE\t0\n#define JOYDEV_MINORS\t\t16\n#define JOYDEV_BUFFER_SIZE\t64\n\nstruct joydev {\n\tint open;\n\tstruct input_handle handle;\n\twait_queue_head_t wait;\n\tstruct list_head client_list;\n\tspinlock_t client_lock;  \n\tstruct mutex mutex;\n\tstruct device dev;\n\tstruct cdev cdev;\n\tbool exist;\n\n\tstruct js_corr corr[ABS_CNT];\n\tstruct JS_DATA_SAVE_TYPE glue;\n\tint nabs;\n\tint nkey;\n\t__u16 keymap[KEY_MAX - BTN_MISC + 1];\n\t__u16 keypam[KEY_MAX - BTN_MISC + 1];\n\t__u8 absmap[ABS_CNT];\n\t__u8 abspam[ABS_CNT];\n\t__s16 abs[ABS_CNT];\n};\n\nstruct joydev_client {\n\tstruct js_event buffer[JOYDEV_BUFFER_SIZE];\n\tint head;\n\tint tail;\n\tint startup;\n\tspinlock_t buffer_lock;  \n\tstruct fasync_struct *fasync;\n\tstruct joydev *joydev;\n\tstruct list_head node;\n};\n\nstatic int joydev_correct(int value, struct js_corr *corr)\n{\n\tswitch (corr->type) {\n\n\tcase JS_CORR_NONE:\n\t\tbreak;\n\n\tcase JS_CORR_BROKEN:\n\t\tvalue = value > corr->coef[0] ? (value < corr->coef[1] ? 0 :\n\t\t\t((corr->coef[3] * (value - corr->coef[1])) >> 14)) :\n\t\t\t((corr->coef[2] * (value - corr->coef[0])) >> 14);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn clamp(value, -32767, 32767);\n}\n\nstatic void joydev_pass_event(struct joydev_client *client,\n\t\t\t      struct js_event *event)\n{\n\tstruct joydev *joydev = client->joydev;\n\n\t \n\tspin_lock(&client->buffer_lock);\n\n\tclient->buffer[client->head] = *event;\n\n\tif (client->startup == joydev->nabs + joydev->nkey) {\n\t\tclient->head++;\n\t\tclient->head &= JOYDEV_BUFFER_SIZE - 1;\n\t\tif (client->tail == client->head)\n\t\t\tclient->startup = 0;\n\t}\n\n\tspin_unlock(&client->buffer_lock);\n\n\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n}\n\nstatic void joydev_event(struct input_handle *handle,\n\t\t\t unsigned int type, unsigned int code, int value)\n{\n\tstruct joydev *joydev = handle->private;\n\tstruct joydev_client *client;\n\tstruct js_event event;\n\n\tswitch (type) {\n\n\tcase EV_KEY:\n\t\tif (code < BTN_MISC || value == 2)\n\t\t\treturn;\n\t\tevent.type = JS_EVENT_BUTTON;\n\t\tevent.number = joydev->keymap[code - BTN_MISC];\n\t\tevent.value = value;\n\t\tbreak;\n\n\tcase EV_ABS:\n\t\tevent.type = JS_EVENT_AXIS;\n\t\tevent.number = joydev->absmap[code];\n\t\tevent.value = joydev_correct(value,\n\t\t\t\t\t&joydev->corr[event.number]);\n\t\tif (event.value == joydev->abs[event.number])\n\t\t\treturn;\n\t\tjoydev->abs[event.number] = event.value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tevent.time = jiffies_to_msecs(jiffies);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(client, &joydev->client_list, node)\n\t\tjoydev_pass_event(client, &event);\n\trcu_read_unlock();\n\n\twake_up_interruptible(&joydev->wait);\n}\n\nstatic int joydev_fasync(int fd, struct file *file, int on)\n{\n\tstruct joydev_client *client = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &client->fasync);\n}\n\nstatic void joydev_free(struct device *dev)\n{\n\tstruct joydev *joydev = container_of(dev, struct joydev, dev);\n\n\tinput_put_device(joydev->handle.dev);\n\tkfree(joydev);\n}\n\nstatic void joydev_attach_client(struct joydev *joydev,\n\t\t\t\t struct joydev_client *client)\n{\n\tspin_lock(&joydev->client_lock);\n\tlist_add_tail_rcu(&client->node, &joydev->client_list);\n\tspin_unlock(&joydev->client_lock);\n}\n\nstatic void joydev_detach_client(struct joydev *joydev,\n\t\t\t\t struct joydev_client *client)\n{\n\tspin_lock(&joydev->client_lock);\n\tlist_del_rcu(&client->node);\n\tspin_unlock(&joydev->client_lock);\n\tsynchronize_rcu();\n}\n\nstatic void joydev_refresh_state(struct joydev *joydev)\n{\n\tstruct input_dev *dev = joydev->handle.dev;\n\tint i, val;\n\n\tfor (i = 0; i < joydev->nabs; i++) {\n\t\tval = input_abs_get_val(dev, joydev->abspam[i]);\n\t\tjoydev->abs[i] = joydev_correct(val, &joydev->corr[i]);\n\t}\n}\n\nstatic int joydev_open_device(struct joydev *joydev)\n{\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&joydev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!joydev->exist)\n\t\tretval = -ENODEV;\n\telse if (!joydev->open++) {\n\t\tretval = input_open_device(&joydev->handle);\n\t\tif (retval)\n\t\t\tjoydev->open--;\n\t\telse\n\t\t\tjoydev_refresh_state(joydev);\n\t}\n\n\tmutex_unlock(&joydev->mutex);\n\treturn retval;\n}\n\nstatic void joydev_close_device(struct joydev *joydev)\n{\n\tmutex_lock(&joydev->mutex);\n\n\tif (joydev->exist && !--joydev->open)\n\t\tinput_close_device(&joydev->handle);\n\n\tmutex_unlock(&joydev->mutex);\n}\n\n \nstatic void joydev_hangup(struct joydev *joydev)\n{\n\tstruct joydev_client *client;\n\n\tspin_lock(&joydev->client_lock);\n\tlist_for_each_entry(client, &joydev->client_list, node)\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\tspin_unlock(&joydev->client_lock);\n\n\twake_up_interruptible(&joydev->wait);\n}\n\nstatic int joydev_release(struct inode *inode, struct file *file)\n{\n\tstruct joydev_client *client = file->private_data;\n\tstruct joydev *joydev = client->joydev;\n\n\tjoydev_detach_client(joydev, client);\n\tkfree(client);\n\n\tjoydev_close_device(joydev);\n\n\treturn 0;\n}\n\nstatic int joydev_open(struct inode *inode, struct file *file)\n{\n\tstruct joydev *joydev =\n\t\t\tcontainer_of(inode->i_cdev, struct joydev, cdev);\n\tstruct joydev_client *client;\n\tint error;\n\n\tclient = kzalloc(sizeof(struct joydev_client), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&client->buffer_lock);\n\tclient->joydev = joydev;\n\tjoydev_attach_client(joydev, client);\n\n\terror = joydev_open_device(joydev);\n\tif (error)\n\t\tgoto err_free_client;\n\n\tfile->private_data = client;\n\tstream_open(inode, file);\n\n\treturn 0;\n\n err_free_client:\n\tjoydev_detach_client(joydev, client);\n\tkfree(client);\n\treturn error;\n}\n\nstatic int joydev_generate_startup_event(struct joydev_client *client,\n\t\t\t\t\t struct input_dev *input,\n\t\t\t\t\t struct js_event *event)\n{\n\tstruct joydev *joydev = client->joydev;\n\tint have_event;\n\n\tspin_lock_irq(&client->buffer_lock);\n\n\thave_event = client->startup < joydev->nabs + joydev->nkey;\n\n\tif (have_event) {\n\n\t\tevent->time = jiffies_to_msecs(jiffies);\n\t\tif (client->startup < joydev->nkey) {\n\t\t\tevent->type = JS_EVENT_BUTTON | JS_EVENT_INIT;\n\t\t\tevent->number = client->startup;\n\t\t\tevent->value = !!test_bit(joydev->keypam[event->number],\n\t\t\t\t\t\t  input->key);\n\t\t} else {\n\t\t\tevent->type = JS_EVENT_AXIS | JS_EVENT_INIT;\n\t\t\tevent->number = client->startup - joydev->nkey;\n\t\t\tevent->value = joydev->abs[event->number];\n\t\t}\n\t\tclient->startup++;\n\t}\n\n\tspin_unlock_irq(&client->buffer_lock);\n\n\treturn have_event;\n}\n\nstatic int joydev_fetch_next_event(struct joydev_client *client,\n\t\t\t\t   struct js_event *event)\n{\n\tint have_event;\n\n\tspin_lock_irq(&client->buffer_lock);\n\n\thave_event = client->head != client->tail;\n\tif (have_event) {\n\t\t*event = client->buffer[client->tail++];\n\t\tclient->tail &= JOYDEV_BUFFER_SIZE - 1;\n\t}\n\n\tspin_unlock_irq(&client->buffer_lock);\n\n\treturn have_event;\n}\n\n \nstatic ssize_t joydev_0x_read(struct joydev_client *client,\n\t\t\t      struct input_dev *input,\n\t\t\t      char __user *buf)\n{\n\tstruct joydev *joydev = client->joydev;\n\tstruct JS_DATA_TYPE data;\n\tint i;\n\n\tspin_lock_irq(&input->event_lock);\n\n\t \n\tfor (data.buttons = i = 0; i < 32 && i < joydev->nkey; i++)\n\t\tdata.buttons |=\n\t\t\ttest_bit(joydev->keypam[i], input->key) ? (1 << i) : 0;\n\tdata.x = (joydev->abs[0] / 256 + 128) >> joydev->glue.JS_CORR.x;\n\tdata.y = (joydev->abs[1] / 256 + 128) >> joydev->glue.JS_CORR.y;\n\n\t \n\tspin_lock(&client->buffer_lock);\n\tclient->startup = 0;\n\tclient->tail = client->head;\n\tspin_unlock(&client->buffer_lock);\n\n\tspin_unlock_irq(&input->event_lock);\n\n\tif (copy_to_user(buf, &data, sizeof(struct JS_DATA_TYPE)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(struct JS_DATA_TYPE);\n}\n\nstatic inline int joydev_data_pending(struct joydev_client *client)\n{\n\tstruct joydev *joydev = client->joydev;\n\n\treturn client->startup < joydev->nabs + joydev->nkey ||\n\t\tclient->head != client->tail;\n}\n\nstatic ssize_t joydev_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct joydev_client *client = file->private_data;\n\tstruct joydev *joydev = client->joydev;\n\tstruct input_dev *input = joydev->handle.dev;\n\tstruct js_event event;\n\tint retval;\n\n\tif (!joydev->exist)\n\t\treturn -ENODEV;\n\n\tif (count < sizeof(struct js_event))\n\t\treturn -EINVAL;\n\n\tif (count == sizeof(struct JS_DATA_TYPE))\n\t\treturn joydev_0x_read(client, input, buf);\n\n\tif (!joydev_data_pending(client) && (file->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\n\tretval = wait_event_interruptible(joydev->wait,\n\t\t\t!joydev->exist || joydev_data_pending(client));\n\tif (retval)\n\t\treturn retval;\n\n\tif (!joydev->exist)\n\t\treturn -ENODEV;\n\n\twhile (retval + sizeof(struct js_event) <= count &&\n\t       joydev_generate_startup_event(client, input, &event)) {\n\n\t\tif (copy_to_user(buf + retval, &event, sizeof(struct js_event)))\n\t\t\treturn -EFAULT;\n\n\t\tretval += sizeof(struct js_event);\n\t}\n\n\twhile (retval + sizeof(struct js_event) <= count &&\n\t       joydev_fetch_next_event(client, &event)) {\n\n\t\tif (copy_to_user(buf + retval, &event, sizeof(struct js_event)))\n\t\t\treturn -EFAULT;\n\n\t\tretval += sizeof(struct js_event);\n\t}\n\n\treturn retval;\n}\n\n \nstatic __poll_t joydev_poll(struct file *file, poll_table *wait)\n{\n\tstruct joydev_client *client = file->private_data;\n\tstruct joydev *joydev = client->joydev;\n\n\tpoll_wait(file, &joydev->wait, wait);\n\treturn (joydev_data_pending(client) ? (EPOLLIN | EPOLLRDNORM) : 0) |\n\t\t(joydev->exist ?  0 : (EPOLLHUP | EPOLLERR));\n}\n\nstatic int joydev_handle_JSIOCSAXMAP(struct joydev *joydev,\n\t\t\t\t     void __user *argp, size_t len)\n{\n\t__u8 *abspam;\n\tint i;\n\tint retval = 0;\n\n\tlen = min(len, sizeof(joydev->abspam));\n\n\t \n\tabspam = memdup_user(argp, len);\n\tif (IS_ERR(abspam))\n\t\treturn PTR_ERR(abspam);\n\n\tfor (i = 0; i < len && i < joydev->nabs; i++) {\n\t\tif (abspam[i] > ABS_MAX) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(joydev->abspam, abspam, len);\n\n\tfor (i = 0; i < joydev->nabs; i++)\n\t\tjoydev->absmap[joydev->abspam[i]] = i;\n\n out:\n\tkfree(abspam);\n\treturn retval;\n}\n\nstatic int joydev_handle_JSIOCSBTNMAP(struct joydev *joydev,\n\t\t\t\t      void __user *argp, size_t len)\n{\n\t__u16 *keypam;\n\tint i;\n\tint retval = 0;\n\n\tif (len % sizeof(*keypam))\n\t\treturn -EINVAL;\n\n\tlen = min(len, sizeof(joydev->keypam));\n\n\t \n\tkeypam = memdup_user(argp, len);\n\tif (IS_ERR(keypam))\n\t\treturn PTR_ERR(keypam);\n\n\tfor (i = 0; i < (len / 2) && i < joydev->nkey; i++) {\n\t\tif (keypam[i] > KEY_MAX || keypam[i] < BTN_MISC) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(joydev->keypam, keypam, len);\n\n\tfor (i = 0; i < joydev->nkey; i++)\n\t\tjoydev->keymap[joydev->keypam[i] - BTN_MISC] = i;\n\n out:\n\tkfree(keypam);\n\treturn retval;\n}\n\n\nstatic int joydev_ioctl_common(struct joydev *joydev,\n\t\t\t\tunsigned int cmd, void __user *argp)\n{\n\tstruct input_dev *dev = joydev->handle.dev;\n\tsize_t len;\n\tint i;\n\tconst char *name;\n\n\t \n\tswitch (cmd) {\n\n\tcase JS_SET_CAL:\n\t\treturn copy_from_user(&joydev->glue.JS_CORR, argp,\n\t\t\t\tsizeof(joydev->glue.JS_CORR)) ? -EFAULT : 0;\n\n\tcase JS_GET_CAL:\n\t\treturn copy_to_user(argp, &joydev->glue.JS_CORR,\n\t\t\t\tsizeof(joydev->glue.JS_CORR)) ? -EFAULT : 0;\n\n\tcase JS_SET_TIMEOUT:\n\t\treturn get_user(joydev->glue.JS_TIMEOUT, (s32 __user *) argp);\n\n\tcase JS_GET_TIMEOUT:\n\t\treturn put_user(joydev->glue.JS_TIMEOUT, (s32 __user *) argp);\n\n\tcase JSIOCGVERSION:\n\t\treturn put_user(JS_VERSION, (__u32 __user *) argp);\n\n\tcase JSIOCGAXES:\n\t\treturn put_user(joydev->nabs, (__u8 __user *) argp);\n\n\tcase JSIOCGBUTTONS:\n\t\treturn put_user(joydev->nkey, (__u8 __user *) argp);\n\n\tcase JSIOCSCORR:\n\t\tif (copy_from_user(joydev->corr, argp,\n\t\t\t      sizeof(joydev->corr[0]) * joydev->nabs))\n\t\t\treturn -EFAULT;\n\n\t\tfor (i = 0; i < joydev->nabs; i++) {\n\t\t\tint val = input_abs_get_val(dev, joydev->abspam[i]);\n\t\t\tjoydev->abs[i] = joydev_correct(val, &joydev->corr[i]);\n\t\t}\n\t\treturn 0;\n\n\tcase JSIOCGCORR:\n\t\treturn copy_to_user(argp, joydev->corr,\n\t\t\tsizeof(joydev->corr[0]) * joydev->nabs) ? -EFAULT : 0;\n\n\t}\n\n\t \n\tswitch (cmd & ~IOCSIZE_MASK) {\n\n\tcase (JSIOCSAXMAP & ~IOCSIZE_MASK):\n\t\treturn joydev_handle_JSIOCSAXMAP(joydev, argp, _IOC_SIZE(cmd));\n\n\tcase (JSIOCGAXMAP & ~IOCSIZE_MASK):\n\t\tlen = min_t(size_t, _IOC_SIZE(cmd), sizeof(joydev->abspam));\n\t\treturn copy_to_user(argp, joydev->abspam, len) ? -EFAULT : len;\n\n\tcase (JSIOCSBTNMAP & ~IOCSIZE_MASK):\n\t\treturn joydev_handle_JSIOCSBTNMAP(joydev, argp, _IOC_SIZE(cmd));\n\n\tcase (JSIOCGBTNMAP & ~IOCSIZE_MASK):\n\t\tlen = min_t(size_t, _IOC_SIZE(cmd), sizeof(joydev->keypam));\n\t\treturn copy_to_user(argp, joydev->keypam, len) ? -EFAULT : len;\n\n\tcase JSIOCGNAME(0):\n\t\tname = dev->name;\n\t\tif (!name)\n\t\t\treturn 0;\n\n\t\tlen = min_t(size_t, _IOC_SIZE(cmd), strlen(name) + 1);\n\t\treturn copy_to_user(argp, name, len) ? -EFAULT : len;\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long joydev_compat_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct joydev_client *client = file->private_data;\n\tstruct joydev *joydev = client->joydev;\n\tvoid __user *argp = (void __user *)arg;\n\ts32 tmp32;\n\tstruct JS_DATA_SAVE_TYPE_32 ds32;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&joydev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!joydev->exist) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\n\tcase JS_SET_TIMELIMIT:\n\t\tretval = get_user(tmp32, (s32 __user *) arg);\n\t\tif (retval == 0)\n\t\t\tjoydev->glue.JS_TIMELIMIT = tmp32;\n\t\tbreak;\n\n\tcase JS_GET_TIMELIMIT:\n\t\ttmp32 = joydev->glue.JS_TIMELIMIT;\n\t\tretval = put_user(tmp32, (s32 __user *) arg);\n\t\tbreak;\n\n\tcase JS_SET_ALL:\n\t\tretval = copy_from_user(&ds32, argp,\n\t\t\t\t\tsizeof(ds32)) ? -EFAULT : 0;\n\t\tif (retval == 0) {\n\t\t\tjoydev->glue.JS_TIMEOUT    = ds32.JS_TIMEOUT;\n\t\t\tjoydev->glue.BUSY          = ds32.BUSY;\n\t\t\tjoydev->glue.JS_EXPIRETIME = ds32.JS_EXPIRETIME;\n\t\t\tjoydev->glue.JS_TIMELIMIT  = ds32.JS_TIMELIMIT;\n\t\t\tjoydev->glue.JS_SAVE       = ds32.JS_SAVE;\n\t\t\tjoydev->glue.JS_CORR       = ds32.JS_CORR;\n\t\t}\n\t\tbreak;\n\n\tcase JS_GET_ALL:\n\t\tds32.JS_TIMEOUT    = joydev->glue.JS_TIMEOUT;\n\t\tds32.BUSY          = joydev->glue.BUSY;\n\t\tds32.JS_EXPIRETIME = joydev->glue.JS_EXPIRETIME;\n\t\tds32.JS_TIMELIMIT  = joydev->glue.JS_TIMELIMIT;\n\t\tds32.JS_SAVE       = joydev->glue.JS_SAVE;\n\t\tds32.JS_CORR       = joydev->glue.JS_CORR;\n\n\t\tretval = copy_to_user(argp, &ds32, sizeof(ds32)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tdefault:\n\t\tretval = joydev_ioctl_common(joydev, cmd, argp);\n\t\tbreak;\n\t}\n\n out:\n\tmutex_unlock(&joydev->mutex);\n\treturn retval;\n}\n#endif  \n\nstatic long joydev_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct joydev_client *client = file->private_data;\n\tstruct joydev *joydev = client->joydev;\n\tvoid __user *argp = (void __user *)arg;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&joydev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!joydev->exist) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\n\tcase JS_SET_TIMELIMIT:\n\t\tretval = get_user(joydev->glue.JS_TIMELIMIT,\n\t\t\t\t  (long __user *) arg);\n\t\tbreak;\n\n\tcase JS_GET_TIMELIMIT:\n\t\tretval = put_user(joydev->glue.JS_TIMELIMIT,\n\t\t\t\t  (long __user *) arg);\n\t\tbreak;\n\n\tcase JS_SET_ALL:\n\t\tretval = copy_from_user(&joydev->glue, argp,\n\t\t\t\t\tsizeof(joydev->glue)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase JS_GET_ALL:\n\t\tretval = copy_to_user(argp, &joydev->glue,\n\t\t\t\t      sizeof(joydev->glue)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tdefault:\n\t\tretval = joydev_ioctl_common(joydev, cmd, argp);\n\t\tbreak;\n\t}\n out:\n\tmutex_unlock(&joydev->mutex);\n\treturn retval;\n}\n\nstatic const struct file_operations joydev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= joydev_read,\n\t.poll\t\t= joydev_poll,\n\t.open\t\t= joydev_open,\n\t.release\t= joydev_release,\n\t.unlocked_ioctl\t= joydev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= joydev_compat_ioctl,\n#endif\n\t.fasync\t\t= joydev_fasync,\n\t.llseek\t\t= no_llseek,\n};\n\n \nstatic void joydev_mark_dead(struct joydev *joydev)\n{\n\tmutex_lock(&joydev->mutex);\n\tjoydev->exist = false;\n\tmutex_unlock(&joydev->mutex);\n}\n\nstatic void joydev_cleanup(struct joydev *joydev)\n{\n\tstruct input_handle *handle = &joydev->handle;\n\n\tjoydev_mark_dead(joydev);\n\tjoydev_hangup(joydev);\n\n\t \n\tif (joydev->open)\n\t\tinput_close_device(handle);\n}\n\n \n#define USB_VENDOR_ID_SONY\t\t\t0x054c\n#define USB_DEVICE_ID_SONY_PS3_CONTROLLER\t\t0x0268\n#define USB_DEVICE_ID_SONY_PS4_CONTROLLER\t\t0x05c4\n#define USB_DEVICE_ID_SONY_PS4_CONTROLLER_2\t\t0x09cc\n#define USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE\t0x0ba0\n\n#define USB_VENDOR_ID_THQ\t\t\t0x20d6\n#define USB_DEVICE_ID_THQ_PS3_UDRAW\t\t\t0xcb17\n\n#define USB_VENDOR_ID_NINTENDO\t\t0x057e\n#define USB_DEVICE_ID_NINTENDO_JOYCONL\t0x2006\n#define USB_DEVICE_ID_NINTENDO_JOYCONR\t0x2007\n#define USB_DEVICE_ID_NINTENDO_PROCON\t0x2009\n#define USB_DEVICE_ID_NINTENDO_CHRGGRIP\t0x200E\n\n#define ACCEL_DEV(vnd, prd)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.flags = INPUT_DEVICE_ID_MATCH_VENDOR |\t\t\t\\\n\t\t\t\tINPUT_DEVICE_ID_MATCH_PRODUCT |\t\t\\\n\t\t\t\tINPUT_DEVICE_ID_MATCH_PROPBIT,\t\t\\\n\t\t.vendor = (vnd),\t\t\t\t\t\\\n\t\t.product = (prd),\t\t\t\t\t\\\n\t\t.propbit = { BIT_MASK(INPUT_PROP_ACCELEROMETER) },\t\\\n\t}\n\nstatic const struct input_device_id joydev_blacklist[] = {\n\t \n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },\n\t},\n\t \n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(BTN_DIGI)] = BIT_MASK(BTN_DIGI) },\n\t},\n\t \n\tACCEL_DEV(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER),\n\tACCEL_DEV(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER),\n\tACCEL_DEV(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER_2),\n\tACCEL_DEV(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE),\n\tACCEL_DEV(USB_VENDOR_ID_THQ, USB_DEVICE_ID_THQ_PS3_UDRAW),\n\tACCEL_DEV(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_PROCON),\n\tACCEL_DEV(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_CHRGGRIP),\n\tACCEL_DEV(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_JOYCONL),\n\tACCEL_DEV(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_JOYCONR),\n\t{   }\n};\n\nstatic bool joydev_dev_is_blacklisted(struct input_dev *dev)\n{\n\tconst struct input_device_id *id;\n\n\tfor (id = joydev_blacklist; id->flags; id++) {\n\t\tif (input_match_device_id(dev, id)) {\n\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\"joydev: blacklisting '%s'\\n\", dev->name);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool joydev_dev_is_absolute_mouse(struct input_dev *dev)\n{\n\tDECLARE_BITMAP(jd_scratch, KEY_CNT);\n\tbool ev_match = false;\n\n\tBUILD_BUG_ON(ABS_CNT > KEY_CNT || EV_CNT > KEY_CNT);\n\n\t \n\n\tbitmap_zero(jd_scratch, EV_CNT);\n\t \n\t__set_bit(EV_ABS, jd_scratch);\n\t__set_bit(EV_KEY, jd_scratch);\n\t__set_bit(EV_SYN, jd_scratch);\n\tif (bitmap_equal(jd_scratch, dev->evbit, EV_CNT))\n\t\tev_match = true;\n\n\t \n\t__set_bit(EV_MSC, jd_scratch);\n\tif (bitmap_equal(jd_scratch, dev->evbit, EV_CNT))\n\t\tev_match = true;\n\n\t \n\t__set_bit(EV_REL, jd_scratch);\n\tif (bitmap_equal(jd_scratch, dev->evbit, EV_CNT))\n\t\tev_match = true;\n\n\tif (!ev_match)\n\t\treturn false;\n\n\tbitmap_zero(jd_scratch, ABS_CNT);\n\t__set_bit(ABS_X, jd_scratch);\n\t__set_bit(ABS_Y, jd_scratch);\n\tif (!bitmap_equal(dev->absbit, jd_scratch, ABS_CNT))\n\t\treturn false;\n\n\tbitmap_zero(jd_scratch, KEY_CNT);\n\t__set_bit(BTN_LEFT, jd_scratch);\n\t__set_bit(BTN_RIGHT, jd_scratch);\n\t__set_bit(BTN_MIDDLE, jd_scratch);\n\n\tif (!bitmap_equal(dev->keybit, jd_scratch, KEY_CNT))\n\t\treturn false;\n\n\t \n\tif (dev->id.bustype == BUS_AMIGA)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool joydev_match(struct input_handler *handler, struct input_dev *dev)\n{\n\t \n\tif (joydev_dev_is_blacklisted(dev))\n\t\treturn false;\n\n\t \n\tif (joydev_dev_is_absolute_mouse(dev))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int joydev_connect(struct input_handler *handler, struct input_dev *dev,\n\t\t\t  const struct input_device_id *id)\n{\n\tstruct joydev *joydev;\n\tint i, j, t, minor, dev_no;\n\tint error;\n\n\tminor = input_get_new_minor(JOYDEV_MINOR_BASE, JOYDEV_MINORS, true);\n\tif (minor < 0) {\n\t\terror = minor;\n\t\tpr_err(\"failed to reserve new minor: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tjoydev = kzalloc(sizeof(struct joydev), GFP_KERNEL);\n\tif (!joydev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_minor;\n\t}\n\n\tINIT_LIST_HEAD(&joydev->client_list);\n\tspin_lock_init(&joydev->client_lock);\n\tmutex_init(&joydev->mutex);\n\tinit_waitqueue_head(&joydev->wait);\n\tjoydev->exist = true;\n\n\tdev_no = minor;\n\t \n\tif (dev_no < JOYDEV_MINOR_BASE + JOYDEV_MINORS)\n\t\tdev_no -= JOYDEV_MINOR_BASE;\n\tdev_set_name(&joydev->dev, \"js%d\", dev_no);\n\n\tjoydev->handle.dev = input_get_device(dev);\n\tjoydev->handle.name = dev_name(&joydev->dev);\n\tjoydev->handle.handler = handler;\n\tjoydev->handle.private = joydev;\n\n\tfor_each_set_bit(i, dev->absbit, ABS_CNT) {\n\t\tjoydev->absmap[i] = joydev->nabs;\n\t\tjoydev->abspam[joydev->nabs] = i;\n\t\tjoydev->nabs++;\n\t}\n\n\tfor (i = BTN_JOYSTICK - BTN_MISC; i < KEY_MAX - BTN_MISC + 1; i++)\n\t\tif (test_bit(i + BTN_MISC, dev->keybit)) {\n\t\t\tjoydev->keymap[i] = joydev->nkey;\n\t\t\tjoydev->keypam[joydev->nkey] = i + BTN_MISC;\n\t\t\tjoydev->nkey++;\n\t\t}\n\n\tfor (i = 0; i < BTN_JOYSTICK - BTN_MISC; i++)\n\t\tif (test_bit(i + BTN_MISC, dev->keybit)) {\n\t\t\tjoydev->keymap[i] = joydev->nkey;\n\t\t\tjoydev->keypam[joydev->nkey] = i + BTN_MISC;\n\t\t\tjoydev->nkey++;\n\t\t}\n\n\tfor (i = 0; i < joydev->nabs; i++) {\n\t\tj = joydev->abspam[i];\n\t\tif (input_abs_get_max(dev, j) == input_abs_get_min(dev, j)) {\n\t\t\tjoydev->corr[i].type = JS_CORR_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\tjoydev->corr[i].type = JS_CORR_BROKEN;\n\t\tjoydev->corr[i].prec = input_abs_get_fuzz(dev, j);\n\n\t\tt = (input_abs_get_max(dev, j) + input_abs_get_min(dev, j)) / 2;\n\t\tjoydev->corr[i].coef[0] = t - input_abs_get_flat(dev, j);\n\t\tjoydev->corr[i].coef[1] = t + input_abs_get_flat(dev, j);\n\n\t\tt = (input_abs_get_max(dev, j) - input_abs_get_min(dev, j)) / 2\n\t\t\t- 2 * input_abs_get_flat(dev, j);\n\t\tif (t) {\n\t\t\tjoydev->corr[i].coef[2] = (1 << 29) / t;\n\t\t\tjoydev->corr[i].coef[3] = (1 << 29) / t;\n\t\t}\n\t}\n\n\tjoydev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n\tjoydev->dev.class = &input_class;\n\tjoydev->dev.parent = &dev->dev;\n\tjoydev->dev.release = joydev_free;\n\tdevice_initialize(&joydev->dev);\n\n\terror = input_register_handle(&joydev->handle);\n\tif (error)\n\t\tgoto err_free_joydev;\n\n\tcdev_init(&joydev->cdev, &joydev_fops);\n\n\terror = cdev_device_add(&joydev->cdev, &joydev->dev);\n\tif (error)\n\t\tgoto err_cleanup_joydev;\n\n\treturn 0;\n\n err_cleanup_joydev:\n\tjoydev_cleanup(joydev);\n\tinput_unregister_handle(&joydev->handle);\n err_free_joydev:\n\tput_device(&joydev->dev);\n err_free_minor:\n\tinput_free_minor(minor);\n\treturn error;\n}\n\nstatic void joydev_disconnect(struct input_handle *handle)\n{\n\tstruct joydev *joydev = handle->private;\n\n\tcdev_device_del(&joydev->cdev, &joydev->dev);\n\tjoydev_cleanup(joydev);\n\tinput_free_minor(MINOR(joydev->dev.devt));\n\tinput_unregister_handle(handle);\n\tput_device(&joydev->dev);\n}\n\nstatic const struct input_device_id joydev_ids[] = {\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_ABS) },\n\t\t.absbit = { BIT_MASK(ABS_X) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_ABS) },\n\t\t.absbit = { BIT_MASK(ABS_Z) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_ABS) },\n\t\t.absbit = { BIT_MASK(ABS_WHEEL) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_ABSBIT,\n\t\t.evbit = { BIT_MASK(EV_ABS) },\n\t\t.absbit = { BIT_MASK(ABS_THROTTLE) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = {[BIT_WORD(BTN_JOYSTICK)] = BIT_MASK(BTN_JOYSTICK) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(BTN_GAMEPAD)] = BIT_MASK(BTN_GAMEPAD) },\n\t},\n\t{\n\t\t.flags = INPUT_DEVICE_ID_MATCH_EVBIT |\n\t\t\t\tINPUT_DEVICE_ID_MATCH_KEYBIT,\n\t\t.evbit = { BIT_MASK(EV_KEY) },\n\t\t.keybit = { [BIT_WORD(BTN_TRIGGER_HAPPY)] = BIT_MASK(BTN_TRIGGER_HAPPY) },\n\t},\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(input, joydev_ids);\n\nstatic struct input_handler joydev_handler = {\n\t.event\t\t= joydev_event,\n\t.match\t\t= joydev_match,\n\t.connect\t= joydev_connect,\n\t.disconnect\t= joydev_disconnect,\n\t.legacy_minors\t= true,\n\t.minor\t\t= JOYDEV_MINOR_BASE,\n\t.name\t\t= \"joydev\",\n\t.id_table\t= joydev_ids,\n};\n\nstatic int __init joydev_init(void)\n{\n\treturn input_register_handler(&joydev_handler);\n}\n\nstatic void __exit joydev_exit(void)\n{\n\tinput_unregister_handler(&joydev_handler);\n}\n\nmodule_init(joydev_init);\nmodule_exit(joydev_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}