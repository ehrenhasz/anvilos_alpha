{
  "module_name": "goodix.c",
  "hash_id": "b5dbd19db61b3ece6455032b8b9264a86799b8b0524aa6fae013b9f79c0a77c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/goodix.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/dmi.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_data/x86/soc.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <asm/unaligned.h>\n#include \"goodix.h\"\n\n#define GOODIX_GPIO_INT_NAME\t\t\"irq\"\n#define GOODIX_GPIO_RST_NAME\t\t\"reset\"\n\n#define GOODIX_MAX_HEIGHT\t\t4096\n#define GOODIX_MAX_WIDTH\t\t4096\n#define GOODIX_INT_TRIGGER\t\t1\n#define GOODIX_CONTACT_SIZE\t\t8\n#define GOODIX_MAX_CONTACT_SIZE\t\t9\n#define GOODIX_MAX_CONTACTS\t\t10\n\n#define GOODIX_CONFIG_MIN_LENGTH\t186\n#define GOODIX_CONFIG_911_LENGTH\t186\n#define GOODIX_CONFIG_967_LENGTH\t228\n#define GOODIX_CONFIG_GT9X_LENGTH\t240\n\n#define GOODIX_BUFFER_STATUS_READY\tBIT(7)\n#define GOODIX_HAVE_KEY\t\t\tBIT(4)\n#define GOODIX_BUFFER_STATUS_TIMEOUT\t20\n\n#define RESOLUTION_LOC\t\t1\n#define MAX_CONTACTS_LOC\t5\n#define TRIGGER_LOC\t\t6\n\n \n#if defined CONFIG_X86 && defined CONFIG_ACPI\n#define ACPI_GPIO_SUPPORT\n#endif\n\nstruct goodix_chip_id {\n\tconst char *id;\n\tconst struct goodix_chip_data *data;\n};\n\nstatic int goodix_check_cfg_8(struct goodix_ts_data *ts,\n\t\t\t      const u8 *cfg, int len);\nstatic int goodix_check_cfg_16(struct goodix_ts_data *ts,\n\t\t\t       const u8 *cfg, int len);\nstatic void goodix_calc_cfg_checksum_8(struct goodix_ts_data *ts);\nstatic void goodix_calc_cfg_checksum_16(struct goodix_ts_data *ts);\n\nstatic const struct goodix_chip_data gt1x_chip_data = {\n\t.config_addr\t\t= GOODIX_GT1X_REG_CONFIG_DATA,\n\t.config_len\t\t= GOODIX_CONFIG_GT9X_LENGTH,\n\t.check_config\t\t= goodix_check_cfg_16,\n\t.calc_config_checksum\t= goodix_calc_cfg_checksum_16,\n};\n\nstatic const struct goodix_chip_data gt911_chip_data = {\n\t.config_addr\t\t= GOODIX_GT9X_REG_CONFIG_DATA,\n\t.config_len\t\t= GOODIX_CONFIG_911_LENGTH,\n\t.check_config\t\t= goodix_check_cfg_8,\n\t.calc_config_checksum\t= goodix_calc_cfg_checksum_8,\n};\n\nstatic const struct goodix_chip_data gt967_chip_data = {\n\t.config_addr\t\t= GOODIX_GT9X_REG_CONFIG_DATA,\n\t.config_len\t\t= GOODIX_CONFIG_967_LENGTH,\n\t.check_config\t\t= goodix_check_cfg_8,\n\t.calc_config_checksum\t= goodix_calc_cfg_checksum_8,\n};\n\nstatic const struct goodix_chip_data gt9x_chip_data = {\n\t.config_addr\t\t= GOODIX_GT9X_REG_CONFIG_DATA,\n\t.config_len\t\t= GOODIX_CONFIG_GT9X_LENGTH,\n\t.check_config\t\t= goodix_check_cfg_8,\n\t.calc_config_checksum\t= goodix_calc_cfg_checksum_8,\n};\n\nstatic const struct goodix_chip_id goodix_chip_ids[] = {\n\t{ .id = \"1151\", .data = &gt1x_chip_data },\n\t{ .id = \"1158\", .data = &gt1x_chip_data },\n\t{ .id = \"5663\", .data = &gt1x_chip_data },\n\t{ .id = \"5688\", .data = &gt1x_chip_data },\n\t{ .id = \"917S\", .data = &gt1x_chip_data },\n\t{ .id = \"9286\", .data = &gt1x_chip_data },\n\n\t{ .id = \"911\", .data = &gt911_chip_data },\n\t{ .id = \"9271\", .data = &gt911_chip_data },\n\t{ .id = \"9110\", .data = &gt911_chip_data },\n\t{ .id = \"9111\", .data = &gt911_chip_data },\n\t{ .id = \"927\", .data = &gt911_chip_data },\n\t{ .id = \"928\", .data = &gt911_chip_data },\n\n\t{ .id = \"912\", .data = &gt967_chip_data },\n\t{ .id = \"9147\", .data = &gt967_chip_data },\n\t{ .id = \"967\", .data = &gt967_chip_data },\n\t{ }\n};\n\nstatic const unsigned long goodix_irq_flags[] = {\n\tIRQ_TYPE_EDGE_RISING,\n\tIRQ_TYPE_EDGE_FALLING,\n\tIRQ_TYPE_LEVEL_LOW,\n\tIRQ_TYPE_LEVEL_HIGH,\n};\n\nstatic const struct dmi_system_id nine_bytes_report[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"CHERRYVIEW D1 PLATFORM\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_VERSION, \"YETI-11\"),\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\t \n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Lenovo YB1-X91\"),\n\t\t}\n\t},\n#endif\n\t{}\n};\n\n \nstatic const struct dmi_system_id inverted_x_screen[] = {\n#if defined(CONFIG_DMI) && defined(CONFIG_X86)\n\t{\n\t\t.ident = \"Cube I15-TC\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Cube\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"I15-TC\")\n\t\t},\n\t},\n#endif\n\t{}\n};\n\n \nint goodix_i2c_read(struct i2c_client *client, u16 reg, u8 *buf, int len)\n{\n\tstruct i2c_msg msgs[2];\n\t__be16 wbuf = cpu_to_be16(reg);\n\tint ret;\n\n\tmsgs[0].flags = 0;\n\tmsgs[0].addr  = client->addr;\n\tmsgs[0].len   = 2;\n\tmsgs[0].buf   = (u8 *)&wbuf;\n\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].addr  = client->addr;\n\tmsgs[1].len   = len;\n\tmsgs[1].buf   = buf;\n\n\tret = i2c_transfer(client->adapter, msgs, 2);\n\tif (ret >= 0)\n\t\tret = (ret == ARRAY_SIZE(msgs) ? 0 : -EIO);\n\n\tif (ret)\n\t\tdev_err(&client->dev, \"Error reading %d bytes from 0x%04x: %d\\n\",\n\t\t\tlen, reg, ret);\n\treturn ret;\n}\n\n \nint goodix_i2c_write(struct i2c_client *client, u16 reg, const u8 *buf, int len)\n{\n\tu8 *addr_buf;\n\tstruct i2c_msg msg;\n\tint ret;\n\n\taddr_buf = kmalloc(len + 2, GFP_KERNEL);\n\tif (!addr_buf)\n\t\treturn -ENOMEM;\n\n\taddr_buf[0] = reg >> 8;\n\taddr_buf[1] = reg & 0xFF;\n\tmemcpy(&addr_buf[2], buf, len);\n\n\tmsg.flags = 0;\n\tmsg.addr = client->addr;\n\tmsg.buf = addr_buf;\n\tmsg.len = len + 2;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret >= 0)\n\t\tret = (ret == 1 ? 0 : -EIO);\n\n\tkfree(addr_buf);\n\n\tif (ret)\n\t\tdev_err(&client->dev, \"Error writing %d bytes to 0x%04x: %d\\n\",\n\t\t\tlen, reg, ret);\n\treturn ret;\n}\n\nint goodix_i2c_write_u8(struct i2c_client *client, u16 reg, u8 value)\n{\n\treturn goodix_i2c_write(client, reg, &value, sizeof(value));\n}\n\nstatic const struct goodix_chip_data *goodix_get_chip_data(const char *id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; goodix_chip_ids[i].id; i++) {\n\t\tif (!strcmp(goodix_chip_ids[i].id, id))\n\t\t\treturn goodix_chip_ids[i].data;\n\t}\n\n\treturn &gt9x_chip_data;\n}\n\nstatic int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data)\n{\n\tunsigned long max_timeout;\n\tint touch_num;\n\tint error;\n\tu16 addr = GOODIX_READ_COOR_ADDR;\n\t \n\tconst int header_contact_keycode_size = 1 + ts->contact_size + 1;\n\n\t \n\tmax_timeout = jiffies + msecs_to_jiffies(GOODIX_BUFFER_STATUS_TIMEOUT);\n\tdo {\n\t\terror = goodix_i2c_read(ts->client, addr, data,\n\t\t\t\t\theader_contact_keycode_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (data[0] & GOODIX_BUFFER_STATUS_READY) {\n\t\t\ttouch_num = data[0] & 0x0f;\n\t\t\tif (touch_num > ts->max_touch_num)\n\t\t\t\treturn -EPROTO;\n\n\t\t\tif (touch_num > 1) {\n\t\t\t\taddr += header_contact_keycode_size;\n\t\t\t\tdata += header_contact_keycode_size;\n\t\t\t\terror = goodix_i2c_read(ts->client,\n\t\t\t\t\t\taddr, data,\n\t\t\t\t\t\tts->contact_size *\n\t\t\t\t\t\t\t(touch_num - 1));\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\treturn touch_num;\n\t\t}\n\n\t\tif (data[0] == 0 && ts->firmware_name) {\n\t\t\tif (goodix_handle_fw_request(ts))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 2000);  \n\t} while (time_before(jiffies, max_timeout));\n\n\t \n\treturn -ENOMSG;\n}\n\nstatic int goodix_create_pen_input(struct goodix_ts_data *ts)\n{\n\tstruct device *dev = &ts->client->dev;\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_copy_abs(input, ABS_X, ts->input_dev, ABS_MT_POSITION_X);\n\tinput_copy_abs(input, ABS_Y, ts->input_dev, ABS_MT_POSITION_Y);\n\t \n\tinput_abs_set_res(input, ABS_X, 10);\n\tinput_abs_set_res(input, ABS_Y, 10);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 255, 0, 0);\n\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_capability(input, EV_KEY, BTN_TOOL_PEN);\n\tinput_set_capability(input, EV_KEY, BTN_STYLUS);\n\tinput_set_capability(input, EV_KEY, BTN_STYLUS2);\n\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\n\tinput->name = \"Goodix Active Pen\";\n\tinput->phys = \"input/pen\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = 0x0416;\n\tif (kstrtou16(ts->id, 10, &input->id.product))\n\t\tinput->id.product = 0x1001;\n\tinput->id.version = ts->version;\n\n\tts->input_pen = input;\n\treturn 0;\n}\n\nstatic void goodix_ts_report_pen_down(struct goodix_ts_data *ts, u8 *data)\n{\n\tint input_x, input_y, input_w, error;\n\tu8 key_value;\n\n\tif (!ts->pen_input_registered) {\n\t\terror = input_register_device(ts->input_pen);\n\t\tts->pen_input_registered = (error == 0) ? 1 : error;\n\t}\n\n\tif (ts->pen_input_registered < 0)\n\t\treturn;\n\n\tif (ts->contact_size == 9) {\n\t\tinput_x = get_unaligned_le16(&data[4]);\n\t\tinput_y = get_unaligned_le16(&data[6]);\n\t\tinput_w = get_unaligned_le16(&data[8]);\n\t} else {\n\t\tinput_x = get_unaligned_le16(&data[2]);\n\t\tinput_y = get_unaligned_le16(&data[4]);\n\t\tinput_w = get_unaligned_le16(&data[6]);\n\t}\n\n\ttouchscreen_report_pos(ts->input_pen, &ts->prop, input_x, input_y, false);\n\tinput_report_abs(ts->input_pen, ABS_PRESSURE, input_w);\n\n\tinput_report_key(ts->input_pen, BTN_TOUCH, 1);\n\tinput_report_key(ts->input_pen, BTN_TOOL_PEN, 1);\n\n\tif (data[0] & GOODIX_HAVE_KEY) {\n\t\tkey_value = data[1 + ts->contact_size];\n\t\tinput_report_key(ts->input_pen, BTN_STYLUS, key_value & 0x10);\n\t\tinput_report_key(ts->input_pen, BTN_STYLUS2, key_value & 0x20);\n\t} else {\n\t\tinput_report_key(ts->input_pen, BTN_STYLUS, 0);\n\t\tinput_report_key(ts->input_pen, BTN_STYLUS2, 0);\n\t}\n\n\tinput_sync(ts->input_pen);\n}\n\nstatic void goodix_ts_report_pen_up(struct goodix_ts_data *ts)\n{\n\tif (!ts->input_pen)\n\t\treturn;\n\n\tinput_report_key(ts->input_pen, BTN_TOUCH, 0);\n\tinput_report_key(ts->input_pen, BTN_TOOL_PEN, 0);\n\tinput_report_key(ts->input_pen, BTN_STYLUS, 0);\n\tinput_report_key(ts->input_pen, BTN_STYLUS2, 0);\n\n\tinput_sync(ts->input_pen);\n}\n\nstatic void goodix_ts_report_touch_8b(struct goodix_ts_data *ts, u8 *coor_data)\n{\n\tint id = coor_data[0] & 0x0F;\n\tint input_x = get_unaligned_le16(&coor_data[1]);\n\tint input_y = get_unaligned_le16(&coor_data[3]);\n\tint input_w = get_unaligned_le16(&coor_data[5]);\n\n\tinput_mt_slot(ts->input_dev, id);\n\tinput_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);\n\ttouchscreen_report_pos(ts->input_dev, &ts->prop,\n\t\t\t       input_x, input_y, true);\n\tinput_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);\n\tinput_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);\n}\n\nstatic void goodix_ts_report_touch_9b(struct goodix_ts_data *ts, u8 *coor_data)\n{\n\tint id = coor_data[1] & 0x0F;\n\tint input_x = get_unaligned_le16(&coor_data[3]);\n\tint input_y = get_unaligned_le16(&coor_data[5]);\n\tint input_w = get_unaligned_le16(&coor_data[7]);\n\n\tinput_mt_slot(ts->input_dev, id);\n\tinput_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);\n\ttouchscreen_report_pos(ts->input_dev, &ts->prop,\n\t\t\t       input_x, input_y, true);\n\tinput_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);\n\tinput_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);\n}\n\nstatic void goodix_ts_release_keys(struct goodix_ts_data *ts)\n{\n\tint i;\n\n\tfor (i = 0; i < GOODIX_MAX_KEYS; i++)\n\t\tinput_report_key(ts->input_dev, ts->keymap[i], 0);\n}\n\nstatic void goodix_ts_report_key(struct goodix_ts_data *ts, u8 *data)\n{\n\tint touch_num;\n\tu8 key_value;\n\tint i;\n\n\tif (data[0] & GOODIX_HAVE_KEY) {\n\t\ttouch_num = data[0] & 0x0f;\n\t\tkey_value = data[1 + ts->contact_size * touch_num];\n\t\tfor (i = 0; i < GOODIX_MAX_KEYS; i++)\n\t\t\tif (key_value & BIT(i))\n\t\t\t\tinput_report_key(ts->input_dev,\n\t\t\t\t\t\t ts->keymap[i], 1);\n\t} else {\n\t\tgoodix_ts_release_keys(ts);\n\t}\n}\n\n \nstatic void goodix_process_events(struct goodix_ts_data *ts)\n{\n\tu8  point_data[2 + GOODIX_MAX_CONTACT_SIZE * GOODIX_MAX_CONTACTS];\n\tint touch_num;\n\tint i;\n\n\ttouch_num = goodix_ts_read_input_report(ts, point_data);\n\tif (touch_num < 0)\n\t\treturn;\n\n\t \n\tif (touch_num == 1 && (point_data[1] & 0x80)) {\n\t\tgoodix_ts_report_pen_down(ts, point_data);\n\t\tgoodix_ts_release_keys(ts);\n\t\tgoto sync;  \n\t} else {\n\t\tgoodix_ts_report_pen_up(ts);\n\t}\n\n\tgoodix_ts_report_key(ts, point_data);\n\n\tfor (i = 0; i < touch_num; i++)\n\t\tif (ts->contact_size == 9)\n\t\t\tgoodix_ts_report_touch_9b(ts,\n\t\t\t\t&point_data[1 + ts->contact_size * i]);\n\t\telse\n\t\t\tgoodix_ts_report_touch_8b(ts,\n\t\t\t\t&point_data[1 + ts->contact_size * i]);\n\nsync:\n\tinput_mt_sync_frame(ts->input_dev);\n\tinput_sync(ts->input_dev);\n}\n\n \nstatic irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)\n{\n\tstruct goodix_ts_data *ts = dev_id;\n\n\tgoodix_process_events(ts);\n\tgoodix_i2c_write_u8(ts->client, GOODIX_READ_COOR_ADDR, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void goodix_free_irq(struct goodix_ts_data *ts)\n{\n\tdevm_free_irq(&ts->client->dev, ts->client->irq, ts);\n}\n\nstatic int goodix_request_irq(struct goodix_ts_data *ts)\n{\n\treturn devm_request_threaded_irq(&ts->client->dev, ts->client->irq,\n\t\t\t\t\t NULL, goodix_ts_irq_handler,\n\t\t\t\t\t ts->irq_flags, ts->client->name, ts);\n}\n\nstatic int goodix_check_cfg_8(struct goodix_ts_data *ts, const u8 *cfg, int len)\n{\n\tint i, raw_cfg_len = len - 2;\n\tu8 check_sum = 0;\n\n\tfor (i = 0; i < raw_cfg_len; i++)\n\t\tcheck_sum += cfg[i];\n\tcheck_sum = (~check_sum) + 1;\n\tif (check_sum != cfg[raw_cfg_len]) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"The checksum of the config fw is not correct\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg[raw_cfg_len + 1] != 1) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Config fw must have Config_Fresh register set\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void goodix_calc_cfg_checksum_8(struct goodix_ts_data *ts)\n{\n\tint i, raw_cfg_len = ts->chip->config_len - 2;\n\tu8 check_sum = 0;\n\n\tfor (i = 0; i < raw_cfg_len; i++)\n\t\tcheck_sum += ts->config[i];\n\tcheck_sum = (~check_sum) + 1;\n\n\tts->config[raw_cfg_len] = check_sum;\n\tts->config[raw_cfg_len + 1] = 1;  \n}\n\nstatic int goodix_check_cfg_16(struct goodix_ts_data *ts, const u8 *cfg,\n\t\t\t       int len)\n{\n\tint i, raw_cfg_len = len - 3;\n\tu16 check_sum = 0;\n\n\tfor (i = 0; i < raw_cfg_len; i += 2)\n\t\tcheck_sum += get_unaligned_be16(&cfg[i]);\n\tcheck_sum = (~check_sum) + 1;\n\tif (check_sum != get_unaligned_be16(&cfg[raw_cfg_len])) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"The checksum of the config fw is not correct\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg[raw_cfg_len + 2] != 1) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Config fw must have Config_Fresh register set\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void goodix_calc_cfg_checksum_16(struct goodix_ts_data *ts)\n{\n\tint i, raw_cfg_len = ts->chip->config_len - 3;\n\tu16 check_sum = 0;\n\n\tfor (i = 0; i < raw_cfg_len; i += 2)\n\t\tcheck_sum += get_unaligned_be16(&ts->config[i]);\n\tcheck_sum = (~check_sum) + 1;\n\n\tput_unaligned_be16(check_sum, &ts->config[raw_cfg_len]);\n\tts->config[raw_cfg_len + 2] = 1;  \n}\n\n \nstatic int goodix_check_cfg(struct goodix_ts_data *ts, const u8 *cfg, int len)\n{\n\tif (len < GOODIX_CONFIG_MIN_LENGTH ||\n\t    len > GOODIX_CONFIG_MAX_LENGTH) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"The length of the config fw is not correct\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ts->chip->check_config(ts, cfg, len);\n}\n\n \nint goodix_send_cfg(struct goodix_ts_data *ts, const u8 *cfg, int len)\n{\n\tint error;\n\n\terror = goodix_check_cfg(ts, cfg, len);\n\tif (error)\n\t\treturn error;\n\n\terror = goodix_i2c_write(ts->client, ts->chip->config_addr, cfg, len);\n\tif (error)\n\t\treturn error;\n\n\tdev_dbg(&ts->client->dev, \"Config sent successfully.\");\n\n\t \n\tusleep_range(10000, 11000);\n\n\treturn 0;\n}\n\n#ifdef ACPI_GPIO_SUPPORT\nstatic int goodix_pin_acpi_direction_input(struct goodix_ts_data *ts)\n{\n\tacpi_handle handle = ACPI_HANDLE(&ts->client->dev);\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(handle, \"INTI\", NULL, NULL);\n\treturn ACPI_SUCCESS(status) ? 0 : -EIO;\n}\n\nstatic int goodix_pin_acpi_output_method(struct goodix_ts_data *ts, int value)\n{\n\tacpi_handle handle = ACPI_HANDLE(&ts->client->dev);\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(handle, \"INTO\", value);\n\treturn ACPI_SUCCESS(status) ? 0 : -EIO;\n}\n#else\nstatic int goodix_pin_acpi_direction_input(struct goodix_ts_data *ts)\n{\n\tdev_err(&ts->client->dev,\n\t\t\"%s called on device without ACPI support\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic int goodix_pin_acpi_output_method(struct goodix_ts_data *ts, int value)\n{\n\tdev_err(&ts->client->dev,\n\t\t\"%s called on device without ACPI support\\n\", __func__);\n\treturn -EINVAL;\n}\n#endif\n\nstatic int goodix_irq_direction_output(struct goodix_ts_data *ts, int value)\n{\n\tswitch (ts->irq_pin_access_method) {\n\tcase IRQ_PIN_ACCESS_NONE:\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"%s called without an irq_pin_access_method set\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\tcase IRQ_PIN_ACCESS_GPIO:\n\t\treturn gpiod_direction_output(ts->gpiod_int, value);\n\tcase IRQ_PIN_ACCESS_ACPI_GPIO:\n\t\t \n\t\treturn gpiod_direction_output_raw(ts->gpiod_int, value);\n\tcase IRQ_PIN_ACCESS_ACPI_METHOD:\n\t\treturn goodix_pin_acpi_output_method(ts, value);\n\t}\n\n\treturn -EINVAL;  \n}\n\nstatic int goodix_irq_direction_input(struct goodix_ts_data *ts)\n{\n\tswitch (ts->irq_pin_access_method) {\n\tcase IRQ_PIN_ACCESS_NONE:\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"%s called without an irq_pin_access_method set\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\tcase IRQ_PIN_ACCESS_GPIO:\n\t\treturn gpiod_direction_input(ts->gpiod_int);\n\tcase IRQ_PIN_ACCESS_ACPI_GPIO:\n\t\treturn gpiod_direction_input(ts->gpiod_int);\n\tcase IRQ_PIN_ACCESS_ACPI_METHOD:\n\t\treturn goodix_pin_acpi_direction_input(ts);\n\t}\n\n\treturn -EINVAL;  \n}\n\nint goodix_int_sync(struct goodix_ts_data *ts)\n{\n\tint error;\n\n\terror = goodix_irq_direction_output(ts, 0);\n\tif (error)\n\t\tgoto error;\n\n\tmsleep(50);\t\t\t\t \n\n\terror = goodix_irq_direction_input(ts);\n\tif (error)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdev_err(&ts->client->dev, \"Controller irq sync failed.\\n\");\n\treturn error;\n}\n\n \nint goodix_reset_no_int_sync(struct goodix_ts_data *ts)\n{\n\tint error;\n\n\t \n\terror = gpiod_direction_output(ts->gpiod_rst, 0);\n\tif (error)\n\t\tgoto error;\n\n\tmsleep(20);\t\t\t\t \n\n\t \n\terror = goodix_irq_direction_output(ts, ts->client->addr == 0x14);\n\tif (error)\n\t\tgoto error;\n\n\tusleep_range(100, 2000);\t\t \n\n\terror = gpiod_direction_output(ts->gpiod_rst, 1);\n\tif (error)\n\t\tgoto error;\n\n\tusleep_range(6000, 10000);\t\t \n\n\t \n\tif (ts->irq_pin_access_method == IRQ_PIN_ACCESS_GPIO) {\n\t\terror = gpiod_direction_input(ts->gpiod_rst);\n\t\tif (error)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tdev_err(&ts->client->dev, \"Controller reset failed.\\n\");\n\treturn error;\n}\n\n \nstatic int goodix_reset(struct goodix_ts_data *ts)\n{\n\tint error;\n\n\terror = goodix_reset_no_int_sync(ts);\n\tif (error)\n\t\treturn error;\n\n\treturn goodix_int_sync(ts);\n}\n\n#ifdef ACPI_GPIO_SUPPORT\nstatic const struct acpi_gpio_params first_gpio = { 0, 0, false };\nstatic const struct acpi_gpio_params second_gpio = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_goodix_int_first_gpios[] = {\n\t{ GOODIX_GPIO_INT_NAME \"-gpios\", &first_gpio, 1 },\n\t{ GOODIX_GPIO_RST_NAME \"-gpios\", &second_gpio, 1 },\n\t{ },\n};\n\nstatic const struct acpi_gpio_mapping acpi_goodix_int_last_gpios[] = {\n\t{ GOODIX_GPIO_RST_NAME \"-gpios\", &first_gpio, 1 },\n\t{ GOODIX_GPIO_INT_NAME \"-gpios\", &second_gpio, 1 },\n\t{ },\n};\n\nstatic const struct acpi_gpio_mapping acpi_goodix_reset_only_gpios[] = {\n\t{ GOODIX_GPIO_RST_NAME \"-gpios\", &first_gpio, 1 },\n\t{ },\n};\n\nstatic int goodix_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct goodix_ts_data *ts = data;\n\tstruct device *dev = &ts->client->dev;\n\tstruct acpi_resource_gpio *gpio;\n\n\tif (acpi_gpio_get_irq_resource(ares, &gpio)) {\n\t\tif (ts->gpio_int_idx == -1) {\n\t\t\tts->gpio_int_idx = ts->gpio_count;\n\t\t} else {\n\t\t\tdev_err(dev, \"More then one GpioInt resource, ignoring ACPI GPIO resources\\n\");\n\t\t\tts->gpio_int_idx = -2;\n\t\t}\n\t\tts->gpio_count++;\n\t} else if (acpi_gpio_get_io_resource(ares, &gpio))\n\t\tts->gpio_count++;\n\n\treturn 0;\n}\n\n \nstatic int goodix_add_acpi_gpio_mappings(struct goodix_ts_data *ts)\n{\n\tconst struct acpi_gpio_mapping *gpio_mapping = NULL;\n\tstruct device *dev = &ts->client->dev;\n\tLIST_HEAD(resources);\n\tint irq, ret;\n\n\tts->gpio_count = 0;\n\tts->gpio_int_idx = -1;\n\tret = acpi_dev_get_resources(ACPI_COMPANION(dev), &resources,\n\t\t\t\t     goodix_resource, ts);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error getting ACPI resources: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tacpi_dev_free_resource_list(&resources);\n\n\t \n\tif (soc_intel_is_cht() && ts->gpio_count == 2 && ts->gpio_int_idx != -1) {\n\t\tirq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), 0);\n\t\tif (irq > 0 && irq != ts->client->irq) {\n\t\t\tdev_warn(dev, \"Overriding IRQ %d -> %d\\n\", ts->client->irq, irq);\n\t\t\tts->client->irq = irq;\n\t\t}\n\t}\n\n\tif (ts->gpio_count == 2 && ts->gpio_int_idx == 0) {\n\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_ACPI_GPIO;\n\t\tgpio_mapping = acpi_goodix_int_first_gpios;\n\t} else if (ts->gpio_count == 2 && ts->gpio_int_idx == 1) {\n\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_ACPI_GPIO;\n\t\tgpio_mapping = acpi_goodix_int_last_gpios;\n\t} else if (ts->gpio_count == 1 && ts->gpio_int_idx == -1 &&\n\t\t   acpi_has_method(ACPI_HANDLE(dev), \"INTI\") &&\n\t\t   acpi_has_method(ACPI_HANDLE(dev), \"INTO\")) {\n\t\tdev_info(dev, \"Using ACPI INTI and INTO methods for IRQ pin access\\n\");\n\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_ACPI_METHOD;\n\t\tgpio_mapping = acpi_goodix_reset_only_gpios;\n\t} else if (soc_intel_is_byt() && ts->gpio_count == 2 && ts->gpio_int_idx == -1) {\n\t\tdev_info(dev, \"No ACPI GpioInt resource, assuming that the GPIO order is reset, int\\n\");\n\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_ACPI_GPIO;\n\t\tgpio_mapping = acpi_goodix_int_last_gpios;\n\t} else if (ts->gpio_count == 1 && ts->gpio_int_idx == 0) {\n\t\t \n\t\tacpi_device_fix_up_power(ACPI_COMPANION(dev));\n\n\t\t \n\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_NONE;\n\t\tgpio_mapping = acpi_goodix_int_first_gpios;\n\t} else {\n\t\tdev_warn(dev, \"Unexpected ACPI resources: gpio_count %d, gpio_int_idx %d\\n\",\n\t\t\t ts->gpio_count, ts->gpio_int_idx);\n\t\t \n\t\tacpi_device_fix_up_power(ACPI_COMPANION(dev));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tts->gpiod_rst_flags = GPIOD_ASIS;\n\n\treturn devm_acpi_dev_add_driver_gpios(dev, gpio_mapping);\n}\n#else\nstatic int goodix_add_acpi_gpio_mappings(struct goodix_ts_data *ts)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n \nstatic int goodix_get_gpio_config(struct goodix_ts_data *ts)\n{\n\tstruct device *dev;\n\tstruct gpio_desc *gpiod;\n\tbool added_acpi_mappings = false;\n\n\tif (!ts->client)\n\t\treturn -EINVAL;\n\tdev = &ts->client->dev;\n\n\t \n\tts->gpiod_rst_flags = GPIOD_IN;\n\n\tts->avdd28 = devm_regulator_get(dev, \"AVDD28\");\n\tif (IS_ERR(ts->avdd28))\n\t\treturn dev_err_probe(dev, PTR_ERR(ts->avdd28), \"Failed to get AVDD28 regulator\\n\");\n\n\tts->vddio = devm_regulator_get(dev, \"VDDIO\");\n\tif (IS_ERR(ts->vddio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ts->vddio), \"Failed to get VDDIO regulator\\n\");\n\nretry_get_irq_gpio:\n\t \n\tgpiod = devm_gpiod_get_optional(dev, GOODIX_GPIO_INT_NAME, GPIOD_IN);\n\tif (IS_ERR(gpiod))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpiod), \"Failed to get %s GPIO\\n\",\n\t\t\t\t     GOODIX_GPIO_INT_NAME);\n\n\tif (!gpiod && has_acpi_companion(dev) && !added_acpi_mappings) {\n\t\tadded_acpi_mappings = true;\n\t\tif (goodix_add_acpi_gpio_mappings(ts) == 0)\n\t\t\tgoto retry_get_irq_gpio;\n\t}\n\n\tts->gpiod_int = gpiod;\n\n\t \n\tgpiod = devm_gpiod_get_optional(dev, GOODIX_GPIO_RST_NAME, ts->gpiod_rst_flags);\n\tif (IS_ERR(gpiod))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpiod), \"Failed to get %s GPIO\\n\",\n\t\t\t\t     GOODIX_GPIO_RST_NAME);\n\n\tts->gpiod_rst = gpiod;\n\n\tswitch (ts->irq_pin_access_method) {\n\tcase IRQ_PIN_ACCESS_ACPI_GPIO:\n\t\t \n\t\tif (!ts->gpiod_int || !ts->gpiod_rst)\n\t\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_NONE;\n\t\tbreak;\n\tcase IRQ_PIN_ACCESS_ACPI_METHOD:\n\t\tif (!ts->gpiod_rst)\n\t\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_NONE;\n\t\tbreak;\n\tdefault:\n\t\tif (ts->gpiod_int && ts->gpiod_rst) {\n\t\t\tts->reset_controller_at_probe = true;\n\t\t\tts->load_cfg_from_disk = true;\n\t\t\tts->irq_pin_access_method = IRQ_PIN_ACCESS_GPIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void goodix_read_config(struct goodix_ts_data *ts)\n{\n\tint x_max, y_max;\n\tint error;\n\n\t \n\tif (!ts->firmware_name) {\n\t\terror = goodix_i2c_read(ts->client, ts->chip->config_addr,\n\t\t\t\t\tts->config, ts->chip->config_len);\n\t\tif (error) {\n\t\t\tts->int_trigger_type = GOODIX_INT_TRIGGER;\n\t\t\tts->max_touch_num = GOODIX_MAX_CONTACTS;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tts->int_trigger_type = ts->config[TRIGGER_LOC] & 0x03;\n\tts->max_touch_num = ts->config[MAX_CONTACTS_LOC] & 0x0f;\n\n\tx_max = get_unaligned_le16(&ts->config[RESOLUTION_LOC]);\n\ty_max = get_unaligned_le16(&ts->config[RESOLUTION_LOC + 2]);\n\tif (x_max && y_max) {\n\t\tinput_abs_set_max(ts->input_dev, ABS_MT_POSITION_X, x_max - 1);\n\t\tinput_abs_set_max(ts->input_dev, ABS_MT_POSITION_Y, y_max - 1);\n\t}\n\n\tts->chip->calc_config_checksum(ts);\n}\n\n \nstatic int goodix_read_version(struct goodix_ts_data *ts)\n{\n\tint error;\n\tu8 buf[6];\n\tchar id_str[GOODIX_ID_MAX_LEN + 1];\n\n\terror = goodix_i2c_read(ts->client, GOODIX_REG_ID, buf, sizeof(buf));\n\tif (error)\n\t\treturn error;\n\n\tmemcpy(id_str, buf, GOODIX_ID_MAX_LEN);\n\tid_str[GOODIX_ID_MAX_LEN] = 0;\n\tstrscpy(ts->id, id_str, GOODIX_ID_MAX_LEN + 1);\n\n\tts->version = get_unaligned_le16(&buf[4]);\n\n\tdev_info(&ts->client->dev, \"ID %s, version: %04x\\n\", ts->id,\n\t\t ts->version);\n\n\treturn 0;\n}\n\n \nstatic int goodix_i2c_test(struct i2c_client *client)\n{\n\tint retry = 0;\n\tint error;\n\tu8 test;\n\n\twhile (retry++ < 2) {\n\t\terror = goodix_i2c_read(client, GOODIX_REG_ID, &test, 1);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\tmsleep(20);\n\t}\n\n\treturn error;\n}\n\n \nstatic int goodix_configure_dev(struct goodix_ts_data *ts)\n{\n\tint error;\n\tint i;\n\n\tts->int_trigger_type = GOODIX_INT_TRIGGER;\n\tts->max_touch_num = GOODIX_MAX_CONTACTS;\n\n\tts->input_dev = devm_input_allocate_device(&ts->client->dev);\n\tif (!ts->input_dev) {\n\t\tdev_err(&ts->client->dev, \"Failed to allocate input device.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->input_dev->name = \"Goodix Capacitive TouchScreen\";\n\tts->input_dev->phys = \"input/ts\";\n\tts->input_dev->id.bustype = BUS_I2C;\n\tts->input_dev->id.vendor = 0x0416;\n\tif (kstrtou16(ts->id, 10, &ts->input_dev->id.product))\n\t\tts->input_dev->id.product = 0x1001;\n\tts->input_dev->id.version = ts->version;\n\n\tts->input_dev->keycode = ts->keymap;\n\tts->input_dev->keycodesize = sizeof(ts->keymap[0]);\n\tts->input_dev->keycodemax = GOODIX_MAX_KEYS;\n\n\t \n\tfor (i = 0; i < GOODIX_MAX_KEYS; ++i) {\n\t\tif (i == 0)\n\t\t\tts->keymap[i] = KEY_LEFTMETA;\n\t\telse\n\t\t\tts->keymap[i] = KEY_F1 + (i - 1);\n\n\t\tinput_set_capability(ts->input_dev, EV_KEY, ts->keymap[i]);\n\t}\n\n\tinput_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\nretry_read_config:\n\t \n\tgoodix_read_config(ts);\n\n\t \n\ttouchscreen_parse_properties(ts->input_dev, true, &ts->prop);\n\n\tif (!ts->prop.max_x || !ts->prop.max_y || !ts->max_touch_num) {\n\t\tif (!ts->reset_controller_at_probe &&\n\t\t    ts->irq_pin_access_method != IRQ_PIN_ACCESS_NONE) {\n\t\t\tdev_info(&ts->client->dev, \"Config not set, resetting controller\\n\");\n\t\t\t \n\t\t\tts->reset_controller_at_probe = true;\n\t\t\terror = goodix_reset(ts);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgoto retry_read_config;\n\t\t}\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Invalid config (%d, %d, %d), using defaults\\n\",\n\t\t\tts->prop.max_x, ts->prop.max_y, ts->max_touch_num);\n\t\tts->prop.max_x = GOODIX_MAX_WIDTH - 1;\n\t\tts->prop.max_y = GOODIX_MAX_HEIGHT - 1;\n\t\tts->max_touch_num = GOODIX_MAX_CONTACTS;\n\t\tinput_abs_set_max(ts->input_dev,\n\t\t\t\t  ABS_MT_POSITION_X, ts->prop.max_x);\n\t\tinput_abs_set_max(ts->input_dev,\n\t\t\t\t  ABS_MT_POSITION_Y, ts->prop.max_y);\n\t}\n\n\tif (dmi_check_system(nine_bytes_report)) {\n\t\tts->contact_size = 9;\n\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"Non-standard 9-bytes report format quirk\\n\");\n\t}\n\n\tif (dmi_check_system(inverted_x_screen)) {\n\t\tts->prop.invert_x = true;\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"Applying 'inverted x screen' quirk\\n\");\n\t}\n\n\terror = input_mt_init_slots(ts->input_dev, ts->max_touch_num,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to initialize MT slots: %d\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input_dev);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to register input device: %d\", error);\n\t\treturn error;\n\t}\n\n\t \n\terror = goodix_create_pen_input(ts);\n\tif (error)\n\t\treturn error;\n\n\tts->irq_flags = goodix_irq_flags[ts->int_trigger_type] | IRQF_ONESHOT;\n\terror = goodix_request_irq(ts);\n\tif (error) {\n\t\tdev_err(&ts->client->dev, \"request IRQ failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void goodix_config_cb(const struct firmware *cfg, void *ctx)\n{\n\tstruct goodix_ts_data *ts = ctx;\n\tint error;\n\n\tif (ts->firmware_name) {\n\t\tif (!cfg)\n\t\t\tgoto err_release_cfg;\n\n\t\terror = goodix_check_cfg(ts, cfg->data, cfg->size);\n\t\tif (error)\n\t\t\tgoto err_release_cfg;\n\n\t\tmemcpy(ts->config, cfg->data, cfg->size);\n\t} else if (cfg) {\n\t\t \n\t\terror = goodix_send_cfg(ts, cfg->data, cfg->size);\n\t\tif (error)\n\t\t\tgoto err_release_cfg;\n\t}\n\n\tgoodix_configure_dev(ts);\n\nerr_release_cfg:\n\trelease_firmware(cfg);\n\tcomplete_all(&ts->firmware_loading_complete);\n}\n\nstatic void goodix_disable_regulators(void *arg)\n{\n\tstruct goodix_ts_data *ts = arg;\n\n\tregulator_disable(ts->vddio);\n\tregulator_disable(ts->avdd28);\n}\n\nstatic int goodix_ts_probe(struct i2c_client *client)\n{\n\tstruct goodix_ts_data *ts;\n\tconst char *cfg_name;\n\tint error;\n\n\tdev_dbg(&client->dev, \"I2C Address: 0x%02x\\n\", client->addr);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"I2C check functionality failed.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\ti2c_set_clientdata(client, ts);\n\tinit_completion(&ts->firmware_loading_complete);\n\tts->contact_size = GOODIX_CONTACT_SIZE;\n\n\terror = goodix_get_gpio_config(ts);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = regulator_enable(ts->avdd28);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enable AVDD28 regulator: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(ts->vddio);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enable VDDIO regulator: %d\\n\",\n\t\t\terror);\n\t\tregulator_disable(ts->avdd28);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t goodix_disable_regulators, ts);\n\tif (error)\n\t\treturn error;\n\nreset:\n\tif (ts->reset_controller_at_probe) {\n\t\t \n\t\terror = goodix_reset(ts);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = goodix_i2c_test(client);\n\tif (error) {\n\t\tif (!ts->reset_controller_at_probe &&\n\t\t    ts->irq_pin_access_method != IRQ_PIN_ACCESS_NONE) {\n\t\t\t \n\t\t\tts->reset_controller_at_probe = true;\n\t\t\tgoto reset;\n\t\t}\n\t\tdev_err(&client->dev, \"I2C communication failure: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = goodix_firmware_check(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = goodix_read_version(ts);\n\tif (error)\n\t\treturn error;\n\n\tts->chip = goodix_get_chip_data(ts->id);\n\n\tif (ts->load_cfg_from_disk) {\n\t\t \n\t\terror = device_property_read_string(&client->dev,\n\t\t\t\t\t\t    \"goodix,config-name\",\n\t\t\t\t\t\t    &cfg_name);\n\t\tif (!error)\n\t\t\tsnprintf(ts->cfg_name, sizeof(ts->cfg_name),\n\t\t\t\t \"goodix/%s\", cfg_name);\n\t\telse\n\t\t\tsnprintf(ts->cfg_name, sizeof(ts->cfg_name),\n\t\t\t\t \"goodix_%s_cfg.bin\", ts->id);\n\n\t\terror = request_firmware_nowait(THIS_MODULE, true, ts->cfg_name,\n\t\t\t\t\t\t&client->dev, GFP_KERNEL, ts,\n\t\t\t\t\t\tgoodix_config_cb);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to invoke firmware loader: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\terror = goodix_configure_dev(ts);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void goodix_ts_remove(struct i2c_client *client)\n{\n\tstruct goodix_ts_data *ts = i2c_get_clientdata(client);\n\n\tif (ts->load_cfg_from_disk)\n\t\twait_for_completion(&ts->firmware_loading_complete);\n}\n\nstatic int goodix_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct goodix_ts_data *ts = i2c_get_clientdata(client);\n\tint error;\n\n\tif (ts->load_cfg_from_disk)\n\t\twait_for_completion(&ts->firmware_loading_complete);\n\n\t \n\tif (ts->irq_pin_access_method == IRQ_PIN_ACCESS_NONE) {\n\t\tdisable_irq(client->irq);\n\t\treturn 0;\n\t}\n\n\t \n\tgoodix_free_irq(ts);\n\n\t \n\tgoodix_save_bak_ref(ts);\n\n\t \n\terror = goodix_irq_direction_output(ts, 0);\n\tif (error) {\n\t\tgoodix_request_irq(ts);\n\t\treturn error;\n\t}\n\n\tusleep_range(5000, 6000);\n\n\terror = goodix_i2c_write_u8(ts->client, GOODIX_REG_COMMAND,\n\t\t\t\t    GOODIX_CMD_SCREEN_OFF);\n\tif (error) {\n\t\tgoodix_irq_direction_input(ts);\n\t\tgoodix_request_irq(ts);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tmsleep(58);\n\treturn 0;\n}\n\nstatic int goodix_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct goodix_ts_data *ts = i2c_get_clientdata(client);\n\tu8 config_ver;\n\tint error;\n\n\tif (ts->irq_pin_access_method == IRQ_PIN_ACCESS_NONE) {\n\t\tenable_irq(client->irq);\n\t\treturn 0;\n\t}\n\n\t \n\terror = goodix_irq_direction_output(ts, 1);\n\tif (error)\n\t\treturn error;\n\n\tusleep_range(2000, 5000);\n\n\terror = goodix_int_sync(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = goodix_i2c_read(ts->client, ts->chip->config_addr,\n\t\t\t\t&config_ver, 1);\n\tif (!error && config_ver != ts->config[0])\n\t\tdev_info(dev, \"Config version mismatch %d != %d, resetting controller\\n\",\n\t\t\t config_ver, ts->config[0]);\n\n\tif (error != 0 || config_ver != ts->config[0]) {\n\t\terror = goodix_reset(ts);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = goodix_send_cfg(ts, ts->config, ts->chip->config_len);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = goodix_request_irq(ts);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(goodix_pm_ops, goodix_suspend, goodix_resume);\n\nstatic const struct i2c_device_id goodix_ts_id[] = {\n\t{ \"GDIX1001:00\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, goodix_ts_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id goodix_acpi_match[] = {\n\t{ \"GDIX1001\", 0 },\n\t{ \"GDIX1002\", 0 },\n\t{ \"GDX9110\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, goodix_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id goodix_of_match[] = {\n\t{ .compatible = \"goodix,gt1151\" },\n\t{ .compatible = \"goodix,gt1158\" },\n\t{ .compatible = \"goodix,gt5663\" },\n\t{ .compatible = \"goodix,gt5688\" },\n\t{ .compatible = \"goodix,gt911\" },\n\t{ .compatible = \"goodix,gt9110\" },\n\t{ .compatible = \"goodix,gt912\" },\n\t{ .compatible = \"goodix,gt9147\" },\n\t{ .compatible = \"goodix,gt917s\" },\n\t{ .compatible = \"goodix,gt927\" },\n\t{ .compatible = \"goodix,gt9271\" },\n\t{ .compatible = \"goodix,gt928\" },\n\t{ .compatible = \"goodix,gt9286\" },\n\t{ .compatible = \"goodix,gt967\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, goodix_of_match);\n#endif\n\nstatic struct i2c_driver goodix_ts_driver = {\n\t.probe = goodix_ts_probe,\n\t.remove = goodix_ts_remove,\n\t.id_table = goodix_ts_id,\n\t.driver = {\n\t\t.name = \"Goodix-TS\",\n\t\t.acpi_match_table = ACPI_PTR(goodix_acpi_match),\n\t\t.of_match_table = of_match_ptr(goodix_of_match),\n\t\t.pm = pm_sleep_ptr(&goodix_pm_ops),\n\t},\n};\nmodule_i2c_driver(goodix_ts_driver);\n\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_AUTHOR(\"Bastien Nocera <hadess@hadess.net>\");\nMODULE_DESCRIPTION(\"Goodix touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}