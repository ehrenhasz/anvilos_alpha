{
  "module_name": "stmpe-ts.c",
  "hash_id": "f67c02c81bff7ddafe08dad5dfa77462cf8e2bd97a14edfca2a3fd92a0756fae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/stmpe-ts.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/workqueue.h>\n\n#include <linux/mfd/stmpe.h>\n\n \n#define STMPE_REG_INT_STA\t\t0x0B\n#define STMPE_REG_TSC_CTRL\t\t0x40\n#define STMPE_REG_TSC_CFG\t\t0x41\n#define STMPE_REG_FIFO_TH\t\t0x4A\n#define STMPE_REG_FIFO_STA\t\t0x4B\n#define STMPE_REG_FIFO_SIZE\t\t0x4C\n#define STMPE_REG_TSC_DATA_XYZ\t\t0x52\n#define STMPE_REG_TSC_FRACTION_Z\t0x56\n#define STMPE_REG_TSC_I_DRIVE\t\t0x58\n\n#define OP_MOD_XYZ\t\t\t0\n\n#define STMPE_TSC_CTRL_TSC_EN\t\t(1<<0)\n\n#define STMPE_FIFO_STA_RESET\t\t(1<<0)\n\n#define STMPE_IRQ_TOUCH_DET\t\t0\n\n#define STMPE_TS_NAME\t\t\t\"stmpe-ts\"\n#define XY_MASK\t\t\t\t0xfff\n\n \nstruct stmpe_touch {\n\tstruct stmpe *stmpe;\n\tstruct input_dev *idev;\n\tstruct delayed_work work;\n\tstruct device *dev;\n\tstruct touchscreen_properties prop;\n\tu8 ave_ctrl;\n\tu8 touch_det_delay;\n\tu8 settling;\n\tu8 fraction_z;\n\tu8 i_drive;\n};\n\nstatic int __stmpe_reset_fifo(struct stmpe *stmpe)\n{\n\tint ret;\n\n\tret = stmpe_set_bits(stmpe, STMPE_REG_FIFO_STA,\n\t\t\tSTMPE_FIFO_STA_RESET, STMPE_FIFO_STA_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\treturn stmpe_set_bits(stmpe, STMPE_REG_FIFO_STA,\n\t\t\tSTMPE_FIFO_STA_RESET, 0);\n}\n\nstatic void stmpe_work(struct work_struct *work)\n{\n\tint int_sta;\n\tu32 timeout = 40;\n\n\tstruct stmpe_touch *ts =\n\t    container_of(work, struct stmpe_touch, work.work);\n\n\tint_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);\n\n\t \n\twhile ((int_sta & (1 << STMPE_IRQ_TOUCH_DET)) && (timeout > 0)) {\n\t\ttimeout--;\n\t\tint_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);\n\t\tudelay(100);\n\t}\n\n\t \n\t__stmpe_reset_fifo(ts->stmpe);\n\n\tinput_report_abs(ts->idev, ABS_PRESSURE, 0);\n\tinput_report_key(ts->idev, BTN_TOUCH, 0);\n\tinput_sync(ts->idev);\n}\n\nstatic irqreturn_t stmpe_ts_handler(int irq, void *data)\n{\n\tu8 data_set[4];\n\tint x, y, z;\n\tstruct stmpe_touch *ts = data;\n\n\t \n\tcancel_delayed_work_sync(&ts->work);\n\n\t \n\tstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\n\t\t\t\tSTMPE_TSC_CTRL_TSC_EN, 0);\n\n\tstmpe_block_read(ts->stmpe, STMPE_REG_TSC_DATA_XYZ, 4, data_set);\n\n\tx = (data_set[0] << 4) | (data_set[1] >> 4);\n\ty = ((data_set[1] & 0xf) << 8) | data_set[2];\n\tz = data_set[3];\n\n\ttouchscreen_report_pos(ts->idev, &ts->prop, x, y, false);\n\tinput_report_abs(ts->idev, ABS_PRESSURE, z);\n\tinput_report_key(ts->idev, BTN_TOUCH, 1);\n\tinput_sync(ts->idev);\n\n        \n\t__stmpe_reset_fifo(ts->stmpe);\n\n\t \n\tstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\n\t\t\tSTMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);\n\n\t \n\tschedule_delayed_work(&ts->work, msecs_to_jiffies(50));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stmpe_init_hw(struct stmpe_touch *ts)\n{\n\tint ret;\n\tu8 tsc_cfg, tsc_cfg_mask;\n\tstruct stmpe *stmpe = ts->stmpe;\n\tstruct device *dev = ts->dev;\n\n\tret = stmpe_enable(stmpe, STMPE_BLOCK_TOUCHSCREEN | STMPE_BLOCK_ADC);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not enable clock for ADC and TS\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmpe811_adc_common_init(stmpe);\n\tif (ret) {\n\t\tstmpe_disable(stmpe, STMPE_BLOCK_TOUCHSCREEN | STMPE_BLOCK_ADC);\n\t\treturn ret;\n\t}\n\n\ttsc_cfg = STMPE_AVE_CTRL(ts->ave_ctrl) |\n\t\t  STMPE_DET_DELAY(ts->touch_det_delay) |\n\t\t  STMPE_SETTLING(ts->settling);\n\ttsc_cfg_mask = STMPE_AVE_CTRL(0xff) | STMPE_DET_DELAY(0xff) |\n\t\t       STMPE_SETTLING(0xff);\n\n\tret = stmpe_set_bits(stmpe, STMPE_REG_TSC_CFG, tsc_cfg_mask, tsc_cfg);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not config touch\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmpe_set_bits(stmpe, STMPE_REG_TSC_FRACTION_Z,\n\t\t\tSTMPE_FRACTION_Z(0xff), STMPE_FRACTION_Z(ts->fraction_z));\n\tif (ret) {\n\t\tdev_err(dev, \"Could not config touch\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmpe_set_bits(stmpe, STMPE_REG_TSC_I_DRIVE,\n\t\t\tSTMPE_I_DRIVE(0xff), STMPE_I_DRIVE(ts->i_drive));\n\tif (ret) {\n\t\tdev_err(dev, \"Could not config touch\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = stmpe_reg_write(stmpe, STMPE_REG_FIFO_TH, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not set FIFO\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmpe_set_bits(stmpe, STMPE_REG_TSC_CTRL,\n\t\t\tSTMPE_OP_MODE(0xff), STMPE_OP_MODE(OP_MOD_XYZ));\n\tif (ret) {\n\t\tdev_err(dev, \"Could not set mode\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmpe_ts_open(struct input_dev *dev)\n{\n\tstruct stmpe_touch *ts = input_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = __stmpe_reset_fifo(ts->stmpe);\n\tif (ret)\n\t\treturn ret;\n\n\treturn stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\n\t\t\tSTMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);\n}\n\nstatic void stmpe_ts_close(struct input_dev *dev)\n{\n\tstruct stmpe_touch *ts = input_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&ts->work);\n\n\tstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\n\t\t\tSTMPE_TSC_CTRL_TSC_EN, 0);\n}\n\nstatic void stmpe_ts_get_platform_info(struct platform_device *pdev,\n\t\t\t\t\tstruct stmpe_touch *ts)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 val;\n\n\tif (np) {\n\t\tif (!of_property_read_u32(np, \"st,sample-time\", &val))\n\t\t\tts->stmpe->sample_time = val;\n\t\tif (!of_property_read_u32(np, \"st,mod-12b\", &val))\n\t\t\tts->stmpe->mod_12b = val;\n\t\tif (!of_property_read_u32(np, \"st,ref-sel\", &val))\n\t\t\tts->stmpe->ref_sel = val;\n\t\tif (!of_property_read_u32(np, \"st,adc-freq\", &val))\n\t\t\tts->stmpe->adc_freq = val;\n\t\tif (!of_property_read_u32(np, \"st,ave-ctrl\", &val))\n\t\t\tts->ave_ctrl = val;\n\t\tif (!of_property_read_u32(np, \"st,touch-det-delay\", &val))\n\t\t\tts->touch_det_delay = val;\n\t\tif (!of_property_read_u32(np, \"st,settling\", &val))\n\t\t\tts->settling = val;\n\t\tif (!of_property_read_u32(np, \"st,fraction-z\", &val))\n\t\t\tts->fraction_z = val;\n\t\tif (!of_property_read_u32(np, \"st,i-drive\", &val))\n\t\t\tts->i_drive = val;\n\t}\n}\n\nstatic int stmpe_input_probe(struct platform_device *pdev)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\n\tstruct stmpe_touch *ts;\n\tstruct input_dev *idev;\n\tint error;\n\tint ts_irq;\n\n\tts_irq = platform_get_irq_byname(pdev, \"FIFO_TH\");\n\tif (ts_irq < 0)\n\t\treturn ts_irq;\n\n\tts = devm_kzalloc(&pdev->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tidev = devm_input_allocate_device(&pdev->dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ts);\n\tts->stmpe = stmpe;\n\tts->idev = idev;\n\tts->dev = &pdev->dev;\n\n\tstmpe_ts_get_platform_info(pdev, ts);\n\n\tINIT_DELAYED_WORK(&ts->work, stmpe_work);\n\n\terror = devm_request_threaded_irq(&pdev->dev, ts_irq,\n\t\t\t\t\t  NULL, stmpe_ts_handler,\n\t\t\t\t\t  IRQF_ONESHOT, STMPE_TS_NAME, ts);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ %d\\n\", ts_irq);\n\t\treturn error;\n\t}\n\n\terror = stmpe_init_hw(ts);\n\tif (error)\n\t\treturn error;\n\n\tidev->name = STMPE_TS_NAME;\n\tidev->phys = STMPE_TS_NAME\"/input0\";\n\tidev->id.bustype = BUS_I2C;\n\n\tidev->open = stmpe_ts_open;\n\tidev->close = stmpe_ts_close;\n\n\tinput_set_drvdata(idev, ts);\n\n\tinput_set_capability(idev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(idev, ABS_X, 0, XY_MASK, 0, 0);\n\tinput_set_abs_params(idev, ABS_Y, 0, XY_MASK, 0, 0);\n\tinput_set_abs_params(idev, ABS_PRESSURE, 0x0, 0xff, 0, 0);\n\n\ttouchscreen_parse_properties(idev, false, &ts->prop);\n\n\terror = input_register_device(idev);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Could not register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmpe_ts_remove(struct platform_device *pdev)\n{\n\tstruct stmpe_touch *ts = platform_get_drvdata(pdev);\n\n\tstmpe_disable(ts->stmpe, STMPE_BLOCK_TOUCHSCREEN);\n\n\treturn 0;\n}\n\nstatic struct platform_driver stmpe_ts_driver = {\n\t.driver = {\n\t\t.name = STMPE_TS_NAME,\n\t},\n\t.probe = stmpe_input_probe,\n\t.remove = stmpe_ts_remove,\n};\nmodule_platform_driver(stmpe_ts_driver);\n\nstatic const struct of_device_id stmpe_ts_ids[] = {\n\t{ .compatible = \"st,stmpe-ts\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, stmpe_ts_ids);\n\nMODULE_AUTHOR(\"Luotao Fu <l.fu@pengutronix.de>\");\nMODULE_DESCRIPTION(\"STMPEXXX touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}