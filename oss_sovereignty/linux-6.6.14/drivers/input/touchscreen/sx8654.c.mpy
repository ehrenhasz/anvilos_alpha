{
  "module_name": "sx8654.c",
  "hash_id": "13d706c5ec96aeedc56fb0c235a21b32bb1c1187d8ce3b721081241da62d9363",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/sx8654.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n \n#define I2C_REG_TOUCH0\t\t\t0x00\n#define I2C_REG_TOUCH1\t\t\t0x01\n#define I2C_REG_CHANMASK\t\t0x04\n#define I2C_REG_IRQMASK\t\t\t0x22\n#define I2C_REG_IRQSRC\t\t\t0x23\n#define I2C_REG_SOFTRESET\t\t0x3f\n\n#define I2C_REG_SX8650_STAT\t\t0x05\n#define SX8650_STAT_CONVIRQ\t\tBIT(7)\n\n \n#define CMD_READ_REGISTER\t\t0x40\n#define CMD_PENTRG\t\t\t0xe0\n\n \n#define SOFTRESET_VALUE\t\t\t0xde\n\n \n#define IRQ_PENTOUCH_TOUCHCONVDONE\tBIT(3)\n#define IRQ_PENRELEASE\t\t\tBIT(2)\n\n \n#define CONDIRQ\t\t\t\t0x20\n#define RPDNT_100K\t\t\t0x00\n#define FILT_7SA\t\t\t0x03\n\n \n#define CONV_X\t\t\t\tBIT(7)\n#define CONV_Y\t\t\t\tBIT(6)\n\n \n#define RATE_MANUAL\t\t\t0x00\n#define RATE_5000CPS\t\t\t0xf0\n\n \n#define POWDLY_1_1MS\t\t\t0x0b\n\n \n#define SX8650_PENIRQ_TIMEOUT\t\tmsecs_to_jiffies(10)\n\n#define MAX_12BIT\t\t\t((1 << 12) - 1)\n#define MAX_I2C_READ_LEN\t\t10  \n\n \n#define CH_X\t\t\t\t0x00\n#define CH_Y\t\t\t\t0x01\n\nstruct sx865x_data {\n\tu8 cmd_manual;\n\tu8 chan_mask;\n\tbool has_irq_penrelease;\n\tbool has_reg_irqmask;\n\tirq_handler_t irqh;\n};\n\nstruct sx8654 {\n\tstruct input_dev *input;\n\tstruct i2c_client *client;\n\tstruct gpio_desc *gpio_reset;\n\n\tspinlock_t lock;\t \n\tstruct timer_list timer;\n\n\tstruct touchscreen_properties props;\n\n\tconst struct sx865x_data *data;\n};\n\nstatic inline void sx865x_penrelease(struct sx8654 *ts)\n{\n\tstruct input_dev *input_dev = ts->input;\n\n\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\tinput_sync(input_dev);\n}\n\nstatic void sx865x_penrelease_timer_handler(struct timer_list *t)\n{\n\tstruct sx8654 *ts = from_timer(ts, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ts->lock, flags);\n\tsx865x_penrelease(ts);\n\tspin_unlock_irqrestore(&ts->lock, flags);\n\tdev_dbg(&ts->client->dev, \"penrelease by timer\\n\");\n}\n\nstatic irqreturn_t sx8650_irq(int irq, void *handle)\n{\n\tstruct sx8654 *ts = handle;\n\tstruct device *dev = &ts->client->dev;\n\tint len, i;\n\tunsigned long flags;\n\tu8 stat;\n\tu16 x, y;\n\tu16 ch;\n\tu16 chdata;\n\t__be16 data[MAX_I2C_READ_LEN / sizeof(__be16)];\n\tu8 nchan = hweight32(ts->data->chan_mask);\n\tu8 readlen = nchan * sizeof(*data);\n\n\tstat = i2c_smbus_read_byte_data(ts->client, CMD_READ_REGISTER\n\t\t\t\t\t\t    | I2C_REG_SX8650_STAT);\n\n\tif (!(stat & SX8650_STAT_CONVIRQ)) {\n\t\tdev_dbg(dev, \"%s ignore stat [0x%02x]\", __func__, stat);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tlen = i2c_master_recv(ts->client, (u8 *)data, readlen);\n\tif (len != readlen) {\n\t\tdev_dbg(dev, \"ignore short recv (%d)\\n\", len);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock_irqsave(&ts->lock, flags);\n\n\tx = 0;\n\ty = 0;\n\tfor (i = 0; i < nchan; i++) {\n\t\tchdata = be16_to_cpu(data[i]);\n\n\t\tif (unlikely(chdata == 0xFFFF)) {\n\t\t\tdev_dbg(dev, \"invalid qualified data @ %d\\n\", i);\n\t\t\tcontinue;\n\t\t} else if (unlikely(chdata & 0x8000)) {\n\t\t\tdev_warn(dev, \"hibit @ %d [0x%04x]\\n\", i, chdata);\n\t\t\tcontinue;\n\t\t}\n\n\t\tch = chdata >> 12;\n\t\tif (ch == CH_X)\n\t\t\tx = chdata & MAX_12BIT;\n\t\telse if (ch == CH_Y)\n\t\t\ty = chdata & MAX_12BIT;\n\t\telse\n\t\t\tdev_warn(dev, \"unknown channel %d [0x%04x]\\n\", ch,\n\t\t\t\t chdata);\n\t}\n\n\ttouchscreen_report_pos(ts->input, &ts->props, x, y, false);\n\tinput_report_key(ts->input, BTN_TOUCH, 1);\n\tinput_sync(ts->input);\n\tdev_dbg(dev, \"point(%4d,%4d)\\n\", x, y);\n\n\tmod_timer(&ts->timer, jiffies + SX8650_PENIRQ_TIMEOUT);\n\tspin_unlock_irqrestore(&ts->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sx8654_irq(int irq, void *handle)\n{\n\tstruct sx8654 *sx8654 = handle;\n\tint irqsrc;\n\tu8 data[4];\n\tunsigned int x, y;\n\tint retval;\n\n\tirqsrc = i2c_smbus_read_byte_data(sx8654->client,\n\t\t\t\t\t  CMD_READ_REGISTER | I2C_REG_IRQSRC);\n\tdev_dbg(&sx8654->client->dev, \"irqsrc = 0x%x\", irqsrc);\n\n\tif (irqsrc < 0)\n\t\tgoto out;\n\n\tif (irqsrc & IRQ_PENRELEASE) {\n\t\tdev_dbg(&sx8654->client->dev, \"pen release interrupt\");\n\n\t\tinput_report_key(sx8654->input, BTN_TOUCH, 0);\n\t\tinput_sync(sx8654->input);\n\t}\n\n\tif (irqsrc & IRQ_PENTOUCH_TOUCHCONVDONE) {\n\t\tdev_dbg(&sx8654->client->dev, \"pen touch interrupt\");\n\n\t\tretval = i2c_master_recv(sx8654->client, data, sizeof(data));\n\t\tif (retval != sizeof(data))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (unlikely(data[0] & 0x80 || data[2] & 0x80))\n\t\t\tgoto out;\n\n\t\tx = ((data[0] & 0xf) << 8) | (data[1]);\n\t\ty = ((data[2] & 0xf) << 8) | (data[3]);\n\n\t\ttouchscreen_report_pos(sx8654->input, &sx8654->props, x, y,\n\t\t\t\t       false);\n\t\tinput_report_key(sx8654->input, BTN_TOUCH, 1);\n\t\tinput_sync(sx8654->input);\n\n\t\tdev_dbg(&sx8654->client->dev, \"point(%4d,%4d)\\n\", x, y);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int sx8654_reset(struct sx8654 *ts)\n{\n\tint err;\n\n\tif (ts->gpio_reset) {\n\t\tgpiod_set_value_cansleep(ts->gpio_reset, 1);\n\t\tudelay(2);  \n\t\tgpiod_set_value_cansleep(ts->gpio_reset, 0);\n\t} else {\n\t\tdev_dbg(&ts->client->dev, \"NRST unavailable, try softreset\\n\");\n\t\terr = i2c_smbus_write_byte_data(ts->client, I2C_REG_SOFTRESET,\n\t\t\t\t\t\tSOFTRESET_VALUE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int sx8654_open(struct input_dev *dev)\n{\n\tstruct sx8654 *sx8654 = input_get_drvdata(dev);\n\tstruct i2c_client *client = sx8654->client;\n\tint error;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, I2C_REG_TOUCH0,\n\t\t\t\t\t  RATE_5000CPS | POWDLY_1_1MS);\n\tif (error) {\n\t\tdev_err(&client->dev, \"writing to I2C_REG_TOUCH0 failed\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte(client, CMD_PENTRG);\n\tif (error) {\n\t\tdev_err(&client->dev, \"writing command CMD_PENTRG failed\");\n\t\treturn error;\n\t}\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic void sx8654_close(struct input_dev *dev)\n{\n\tstruct sx8654 *sx8654 = input_get_drvdata(dev);\n\tstruct i2c_client *client = sx8654->client;\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\tif (!sx8654->data->has_irq_penrelease)\n\t\tdel_timer_sync(&sx8654->timer);\n\n\t \n\terror = i2c_smbus_write_byte(client, sx8654->data->cmd_manual);\n\tif (error) {\n\t\tdev_err(&client->dev, \"writing command CMD_MANUAL failed\");\n\t\treturn;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, I2C_REG_TOUCH0, RATE_MANUAL);\n\tif (error) {\n\t\tdev_err(&client->dev, \"writing to I2C_REG_TOUCH0 failed\");\n\t\treturn;\n\t}\n}\n\nstatic int sx8654_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct sx8654 *sx8654;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -ENXIO;\n\n\tsx8654 = devm_kzalloc(&client->dev, sizeof(*sx8654), GFP_KERNEL);\n\tif (!sx8654)\n\t\treturn -ENOMEM;\n\n\tsx8654->gpio_reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(sx8654->gpio_reset))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(sx8654->gpio_reset),\n\t\t\t\t     \"unable to get reset-gpio\\n\");\n\tdev_dbg(&client->dev, \"got GPIO reset pin\\n\");\n\n\tsx8654->data = device_get_match_data(&client->dev);\n\tif (!sx8654->data)\n\t\tsx8654->data = (const struct sx865x_data *)id->driver_data;\n\tif (!sx8654->data) {\n\t\tdev_err(&client->dev, \"invalid or missing device data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sx8654->data->has_irq_penrelease) {\n\t\tdev_dbg(&client->dev, \"use timer for penrelease\\n\");\n\t\ttimer_setup(&sx8654->timer, sx865x_penrelease_timer_handler, 0);\n\t\tspin_lock_init(&sx8654->lock);\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"SX8654 I2C Touchscreen\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->dev.parent = &client->dev;\n\tinput->open = sx8654_open;\n\tinput->close = sx8654_close;\n\n\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input, ABS_X, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, MAX_12BIT, 0, 0);\n\n\ttouchscreen_parse_properties(input, false, &sx8654->props);\n\n\tsx8654->client = client;\n\tsx8654->input = input;\n\n\tinput_set_drvdata(sx8654->input, sx8654);\n\n\terror = sx8654_reset(sx8654);\n\tif (error) {\n\t\tdev_err(&client->dev, \"reset failed\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, I2C_REG_CHANMASK,\n\t\t\t\t\t  sx8654->data->chan_mask);\n\tif (error) {\n\t\tdev_err(&client->dev, \"writing to I2C_REG_CHANMASK failed\");\n\t\treturn error;\n\t}\n\n\tif (sx8654->data->has_reg_irqmask) {\n\t\terror = i2c_smbus_write_byte_data(client, I2C_REG_IRQMASK,\n\t\t\t\t\t\t  IRQ_PENTOUCH_TOUCHCONVDONE |\n\t\t\t\t\t\t\tIRQ_PENRELEASE);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"writing I2C_REG_IRQMASK failed\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, I2C_REG_TOUCH1,\n\t\t\t\t\t  CONDIRQ | RPDNT_100K | FILT_7SA);\n\tif (error) {\n\t\tdev_err(&client->dev, \"writing to I2C_REG_TOUCH1 failed\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, sx8654->data->irqh,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  client->name, sx8654);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enable IRQ %d, error: %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\t \n\tdisable_irq(client->irq);\n\n\terror = input_register_device(sx8654->input);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct sx865x_data sx8650_data = {\n\t.cmd_manual\t\t= 0xb0,\n\t.has_irq_penrelease\t= false,\n\t.has_reg_irqmask\t= false,\n\t.chan_mask\t\t= (CONV_X | CONV_Y),\n\t.irqh\t\t\t= sx8650_irq,\n};\n\nstatic const struct sx865x_data sx8654_data = {\n\t.cmd_manual\t\t= 0xc0,\n\t.has_irq_penrelease\t= true,\n\t.has_reg_irqmask\t= true,\n\t.chan_mask\t\t= (CONV_X | CONV_Y),\n\t.irqh\t\t\t= sx8654_irq,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sx8654_of_match[] = {\n\t{\n\t\t.compatible = \"semtech,sx8650\",\n\t\t.data = &sx8650_data,\n\t}, {\n\t\t.compatible = \"semtech,sx8654\",\n\t\t.data = &sx8654_data,\n\t}, {\n\t\t.compatible = \"semtech,sx8655\",\n\t\t.data = &sx8654_data,\n\t}, {\n\t\t.compatible = \"semtech,sx8656\",\n\t\t.data = &sx8654_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sx8654_of_match);\n#endif\n\nstatic const struct i2c_device_id sx8654_id_table[] = {\n\t{ .name = \"semtech_sx8650\", .driver_data = (long)&sx8650_data },\n\t{ .name = \"semtech_sx8654\", .driver_data = (long)&sx8654_data },\n\t{ .name = \"semtech_sx8655\", .driver_data = (long)&sx8654_data },\n\t{ .name = \"semtech_sx8656\", .driver_data = (long)&sx8654_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sx8654_id_table);\n\nstatic struct i2c_driver sx8654_driver = {\n\t.driver = {\n\t\t.name = \"sx8654\",\n\t\t.of_match_table = of_match_ptr(sx8654_of_match),\n\t},\n\t.id_table = sx8654_id_table,\n\t.probe = sx8654_probe,\n};\nmodule_i2c_driver(sx8654_driver);\n\nMODULE_AUTHOR(\"S\u00e9bastien Szymanski <sebastien.szymanski@armadeus.com>\");\nMODULE_DESCRIPTION(\"Semtech SX8654 I2C Touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}