{
  "module_name": "st1232.c",
  "hash_id": "e52f51809a2668591c9575ee15381fc48aeefe5f2e3c7bd352e87e2dedfe0d2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/st1232.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define ST1232_TS_NAME\t\"st1232-ts\"\n#define ST1633_TS_NAME\t\"st1633-ts\"\n\n#define REG_STATUS\t\t0x01\t \n\n#define STATUS_NORMAL\t\t0x00\n#define STATUS_INIT\t\t0x01\n#define STATUS_ERROR\t\t0x02\n#define STATUS_AUTO_TUNING\t0x03\n#define STATUS_IDLE\t\t0x04\n#define STATUS_POWER_DOWN\t0x05\n\n#define ERROR_NONE\t\t0x00\n#define ERROR_INVALID_ADDRESS\t0x10\n#define ERROR_INVALID_VALUE\t0x20\n#define ERROR_INVALID_PLATFORM\t0x30\n\n#define REG_XY_RESOLUTION\t0x04\n#define REG_XY_COORDINATES\t0x12\n#define ST_TS_MAX_FINGERS\t10\n\nstruct st_chip_info {\n\tbool\thave_z;\n\tu16\tmax_area;\n\tu16\tmax_fingers;\n};\n\nstruct st1232_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct touchscreen_properties prop;\n\tstruct dev_pm_qos_request low_latency_req;\n\tstruct gpio_desc *reset_gpio;\n\tconst struct st_chip_info *chip_info;\n\tint read_buf_len;\n\tu8 *read_buf;\n};\n\nstatic int st1232_ts_read_data(struct st1232_ts_data *ts, u8 reg,\n\t\t\t       unsigned int n)\n{\n\tstruct i2c_client *client = ts->client;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.len\t= sizeof(reg),\n\t\t\t.buf\t= &reg,\n\t\t},\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD | I2C_M_DMA_SAFE,\n\t\t\t.len\t= n,\n\t\t\t.buf\t= ts->read_buf,\n\t\t}\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int st1232_ts_wait_ready(struct st1232_ts_data *ts)\n{\n\tunsigned int retries;\n\tint error;\n\n\tfor (retries = 100; retries; retries--) {\n\t\terror = st1232_ts_read_data(ts, REG_STATUS, 1);\n\t\tif (!error) {\n\t\t\tswitch (ts->read_buf[0]) {\n\t\t\tcase STATUS_NORMAL | ERROR_NONE:\n\t\t\tcase STATUS_IDLE | ERROR_NONE:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int st1232_ts_read_resolution(struct st1232_ts_data *ts, u16 *max_x,\n\t\t\t\t     u16 *max_y)\n{\n\tu8 *buf;\n\tint error;\n\n\t \n\terror = st1232_ts_read_data(ts, REG_XY_RESOLUTION, 3);\n\tif (error)\n\t\treturn error;\n\n\tbuf = ts->read_buf;\n\n\t*max_x = (((buf[0] & 0x0070) << 4) | buf[1]) - 1;\n\t*max_y = (((buf[0] & 0x0007) << 8) | buf[2]) - 1;\n\n\treturn 0;\n}\n\nstatic int st1232_ts_parse_and_report(struct st1232_ts_data *ts)\n{\n\tstruct input_dev *input = ts->input_dev;\n\tstruct input_mt_pos pos[ST_TS_MAX_FINGERS];\n\tu8 z[ST_TS_MAX_FINGERS];\n\tint slots[ST_TS_MAX_FINGERS];\n\tint n_contacts = 0;\n\tint i;\n\n\tfor (i = 0; i < ts->chip_info->max_fingers; i++) {\n\t\tu8 *buf = &ts->read_buf[i * 4];\n\n\t\tif (buf[0] & BIT(7)) {\n\t\t\tunsigned int x = ((buf[0] & 0x70) << 4) | buf[1];\n\t\t\tunsigned int y = ((buf[0] & 0x07) << 8) | buf[2];\n\n\t\t\ttouchscreen_set_mt_pos(&pos[n_contacts],\n\t\t\t\t\t       &ts->prop, x, y);\n\n\t\t\t \n\t\t\tif (ts->chip_info->have_z)\n\t\t\t\tz[n_contacts] = ts->read_buf[i + 6];\n\n\t\t\tn_contacts++;\n\t\t}\n\t}\n\n\tinput_mt_assign_slots(input, slots, pos, n_contacts, 0);\n\tfor (i = 0; i < n_contacts; i++) {\n\t\tinput_mt_slot(input, slots[i]);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, pos[i].x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, pos[i].y);\n\t\tif (ts->chip_info->have_z)\n\t\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, z[i]);\n\t}\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n\n\treturn n_contacts;\n}\n\nstatic irqreturn_t st1232_ts_irq_handler(int irq, void *dev_id)\n{\n\tstruct st1232_ts_data *ts = dev_id;\n\tint count;\n\tint error;\n\n\terror = st1232_ts_read_data(ts, REG_XY_COORDINATES, ts->read_buf_len);\n\tif (error)\n\t\tgoto out;\n\n\tcount = st1232_ts_parse_and_report(ts);\n\tif (!count) {\n\t\tif (ts->low_latency_req.dev) {\n\t\t\tdev_pm_qos_remove_request(&ts->low_latency_req);\n\t\t\tts->low_latency_req.dev = NULL;\n\t\t}\n\t} else if (!ts->low_latency_req.dev) {\n\t\t \n\t\tdev_pm_qos_add_ancestor_request(&ts->client->dev,\n\t\t\t\t\t\t&ts->low_latency_req,\n\t\t\t\t\t\tDEV_PM_QOS_RESUME_LATENCY, 100);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void st1232_ts_power(struct st1232_ts_data *ts, bool poweron)\n{\n\tif (ts->reset_gpio)\n\t\tgpiod_set_value_cansleep(ts->reset_gpio, !poweron);\n}\n\nstatic void st1232_ts_power_off(void *data)\n{\n\tst1232_ts_power(data, false);\n}\n\nstatic const struct st_chip_info st1232_chip_info = {\n\t.have_z\t\t= true,\n\t.max_area\t= 0xff,\n\t.max_fingers\t= 2,\n};\n\nstatic const struct st_chip_info st1633_chip_info = {\n\t.have_z\t\t= false,\n\t.max_area\t= 0x00,\n\t.max_fingers\t= 5,\n};\n\nstatic int st1232_ts_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct st_chip_info *match;\n\tstruct st1232_ts_data *ts;\n\tstruct input_dev *input_dev;\n\tu16 max_x, max_y;\n\tint error;\n\n\tmatch = device_get_match_data(&client->dev);\n\tif (!match && id)\n\t\tmatch = (const void *)id->driver_data;\n\tif (!match) {\n\t\tdev_err(&client->dev, \"unknown device model\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"need I2C_FUNC_I2C\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"no IRQ?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->chip_info = match;\n\n\t \n\tts->read_buf_len = ts->chip_info->max_fingers * 4;\n\tts->read_buf = devm_kzalloc(&client->dev, ts->read_buf_len, GFP_KERNEL);\n\tif (!ts->read_buf)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\tts->input_dev = input_dev;\n\n\tts->reset_gpio = devm_gpiod_get_optional(&client->dev, NULL,\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(&client->dev, \"Unable to request GPIO pin: %d.\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tst1232_ts_power(ts, true);\n\n\terror = devm_add_action_or_reset(&client->dev, st1232_ts_power_off, ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to install power off action: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput_dev->name = \"st1232-touchscreen\";\n\tinput_dev->id.bustype = BUS_I2C;\n\n\t \n\terror = st1232_ts_wait_ready(ts);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = st1232_ts_read_resolution(ts, &max_x, &max_y);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read resolution: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (ts->chip_info->have_z)\n\t\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0,\n\t\t\t\t     ts->chip_info->max_area, 0, 0);\n\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t     0, max_x, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t     0, max_y, 0, 0);\n\n\ttouchscreen_parse_properties(input_dev, true, &ts->prop);\n\n\terror = input_mt_init_slots(input_dev, ts->chip_info->max_fingers,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_TRACK |\n\t\t\t\t\tINPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to initialize MT slots\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, st1232_ts_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  client->name, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to register %s input device\\n\",\n\t\t\tinput_dev->name);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, ts);\n\n\treturn 0;\n}\n\nstatic int st1232_ts_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct st1232_ts_data *ts = i2c_get_clientdata(client);\n\n\tdisable_irq(client->irq);\n\n\tif (!device_may_wakeup(&client->dev))\n\t\tst1232_ts_power(ts, false);\n\n\treturn 0;\n}\n\nstatic int st1232_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct st1232_ts_data *ts = i2c_get_clientdata(client);\n\n\tif (!device_may_wakeup(&client->dev))\n\t\tst1232_ts_power(ts, true);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(st1232_ts_pm_ops,\n\t\t\t\tst1232_ts_suspend, st1232_ts_resume);\n\nstatic const struct i2c_device_id st1232_ts_id[] = {\n\t{ ST1232_TS_NAME, (unsigned long)&st1232_chip_info },\n\t{ ST1633_TS_NAME, (unsigned long)&st1633_chip_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, st1232_ts_id);\n\nstatic const struct of_device_id st1232_ts_dt_ids[] = {\n\t{ .compatible = \"sitronix,st1232\", .data = &st1232_chip_info },\n\t{ .compatible = \"sitronix,st1633\", .data = &st1633_chip_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, st1232_ts_dt_ids);\n\nstatic struct i2c_driver st1232_ts_driver = {\n\t.probe\t\t= st1232_ts_probe,\n\t.id_table\t= st1232_ts_id,\n\t.driver = {\n\t\t.name\t= ST1232_TS_NAME,\n\t\t.of_match_table = st1232_ts_dt_ids,\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= pm_sleep_ptr(&st1232_ts_pm_ops),\n\t},\n};\n\nmodule_i2c_driver(st1232_ts_driver);\n\nMODULE_AUTHOR(\"Tony SIM <chinyeow.sim.xt@renesas.com>\");\nMODULE_AUTHOR(\"Martin Kepplinger <martin.kepplinger@ginzinger.com>\");\nMODULE_DESCRIPTION(\"SITRONIX ST1232 Touchscreen Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}