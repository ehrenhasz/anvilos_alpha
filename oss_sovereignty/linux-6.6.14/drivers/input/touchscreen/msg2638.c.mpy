{
  "module_name": "msg2638.c",
  "hash_id": "1df2f9670e9ec25f4d8bb908218e79b482f13a62e463cc2ad251260a342b4a70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/msg2638.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#define MODE_DATA_RAW\t\t\t0x5A\n\n#define MSG2138_MAX_FINGERS\t\t2\n#define MSG2638_MAX_FINGERS\t\t5\n\n#define MAX_BUTTONS\t\t\t4\n\n#define CHIP_ON_DELAY_MS\t\t15\n#define FIRMWARE_ON_DELAY_MS\t\t50\n#define RESET_DELAY_MIN_US\t\t10000\n#define RESET_DELAY_MAX_US\t\t11000\n\nstruct msg_chip_data {\n\tirq_handler_t irq_handler;\n\tunsigned int max_fingers;\n};\n\nstruct msg2138_packet {\n\tu8\txy_hi;  \n\tu8\tx_low;\n\tu8\ty_low;\n};\n\nstruct msg2138_touch_event {\n\tu8\tmagic;\n\tstruct\tmsg2138_packet pkt[MSG2138_MAX_FINGERS];\n\tu8\tchecksum;\n};\n\nstruct msg2638_packet {\n\tu8\txy_hi;  \n\tu8\tx_low;\n\tu8\ty_low;\n\tu8\tpressure;\n};\n\nstruct msg2638_touch_event {\n\tu8\tmode;\n\tstruct\tmsg2638_packet pkt[MSG2638_MAX_FINGERS];\n\tu8\tproximity;\n\tu8\tchecksum;\n};\n\nstruct msg2638_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct touchscreen_properties prop;\n\tstruct regulator_bulk_data supplies[2];\n\tstruct gpio_desc *reset_gpiod;\n\tint max_fingers;\n\tu32 keycodes[MAX_BUTTONS];\n\tint num_keycodes;\n};\n\nstatic u8 msg2638_checksum(u8 *data, u32 length)\n{\n\ts32 sum = 0;\n\tu32 i;\n\n\tfor (i = 0; i < length; i++)\n\t\tsum += data[i];\n\n\treturn (u8)((-sum) & 0xFF);\n}\n\nstatic void msg2138_report_keys(struct msg2638_ts_data *msg2638, u8 keys)\n{\n\tint i;\n\n\t \n\tif (keys == 0xff)\n\t\tkeys = 0;\n\n\tfor (i = 0; i < msg2638->num_keycodes; ++i)\n\t\tinput_report_key(msg2638->input_dev, msg2638->keycodes[i],\n\t\t\t\t keys & BIT(i));\n}\n\nstatic irqreturn_t msg2138_ts_irq_handler(int irq, void *msg2638_handler)\n{\n\tstruct msg2638_ts_data *msg2638 = msg2638_handler;\n\tstruct i2c_client *client = msg2638->client;\n\tstruct input_dev *input = msg2638->input_dev;\n\tstruct msg2138_touch_event touch_event;\n\tu32 len = sizeof(touch_event);\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= sizeof(touch_event),\n\t\t\t.buf\t= (u8 *)&touch_event,\n\t\t},\n\t};\n\tstruct msg2138_packet *p0, *p1;\n\tu16 x, y, delta_x, delta_y;\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed I2C transfer in irq handler: %d\\n\",\n\t\t\tret < 0 ? ret : -EIO);\n\t\tgoto out;\n\t}\n\n\tif (msg2638_checksum((u8 *)&touch_event, len - 1) !=\n\t\t\t\t\t\ttouch_event.checksum) {\n\t\tdev_err(&client->dev, \"Failed checksum!\\n\");\n\t\tgoto out;\n\t}\n\n\tp0 = &touch_event.pkt[0];\n\tp1 = &touch_event.pkt[1];\n\n\t \n\tif (p0->xy_hi == 0xFF && p0->x_low == 0xFF && p0->y_low == 0xFF) {\n\t\tif (p1->xy_hi == 0xFF && p1->y_low == 0xFF)\n\t\t\tmsg2138_report_keys(msg2638, p1->x_low);\n\t\tgoto report;\n\t}\n\n\tx = ((p0->xy_hi & 0xF0) << 4) | p0->x_low;\n\ty = ((p0->xy_hi & 0x0F) << 8) | p0->y_low;\n\n\tinput_mt_slot(input, 0);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\ttouchscreen_report_pos(input, &msg2638->prop, x, y, true);\n\n\t \n\tif (p1->xy_hi == 0xFF && p1->x_low == 0xFF && p1->y_low == 0xFF)\n\t\tgoto report;\n\n\t \n\tdelta_x = ((p1->xy_hi & 0xF0) << 4) | p1->x_low;\n\tdelta_y = ((p1->xy_hi & 0x0F) << 8) | p1->y_low;\n\n\t \n\tif (delta_x == 0 && delta_y == 0)\n\t\tgoto report;\n\n\tx += delta_x;\n\ty += delta_y;\n\n\tinput_mt_slot(input, 1);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\ttouchscreen_report_pos(input, &msg2638->prop, x, y, true);\n\nreport:\n\tinput_mt_sync_frame(msg2638->input_dev);\n\tinput_sync(msg2638->input_dev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t msg2638_ts_irq_handler(int irq, void *msg2638_handler)\n{\n\tstruct msg2638_ts_data *msg2638 = msg2638_handler;\n\tstruct i2c_client *client = msg2638->client;\n\tstruct input_dev *input = msg2638->input_dev;\n\tstruct msg2638_touch_event touch_event;\n\tu32 len = sizeof(touch_event);\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= sizeof(touch_event),\n\t\t\t.buf\t= (u8 *)&touch_event,\n\t\t},\n\t};\n\tstruct msg2638_packet *p;\n\tu16 x, y;\n\tint ret;\n\tint i;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed I2C transfer in irq handler: %d\\n\",\n\t\t\tret < 0 ? ret : -EIO);\n\t\tgoto out;\n\t}\n\n\tif (touch_event.mode != MODE_DATA_RAW)\n\t\tgoto out;\n\n\tif (msg2638_checksum((u8 *)&touch_event, len - 1) !=\n\t\t\t\t\t\ttouch_event.checksum) {\n\t\tdev_err(&client->dev, \"Failed checksum!\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < msg2638->max_fingers; i++) {\n\t\tp = &touch_event.pkt[i];\n\n\t\t \n\t\tif (p->xy_hi == 0xFF && p->x_low == 0xFF && p->y_low == 0xFF)\n\t\t\tcontinue;\n\n\t\tx = (((p->xy_hi & 0xF0) << 4) | p->x_low);\n\t\ty = (((p->xy_hi & 0x0F) << 8) | p->y_low);\n\n\t\tinput_mt_slot(input, i);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\ttouchscreen_report_pos(input, &msg2638->prop, x, y, true);\n\t}\n\n\tinput_mt_sync_frame(msg2638->input_dev);\n\tinput_sync(msg2638->input_dev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void msg2638_reset(struct msg2638_ts_data *msg2638)\n{\n\tgpiod_set_value_cansleep(msg2638->reset_gpiod, 1);\n\tusleep_range(RESET_DELAY_MIN_US, RESET_DELAY_MAX_US);\n\tgpiod_set_value_cansleep(msg2638->reset_gpiod, 0);\n\tmsleep(FIRMWARE_ON_DELAY_MS);\n}\n\nstatic int msg2638_start(struct msg2638_ts_data *msg2638)\n{\n\tint error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(msg2638->supplies),\n\t\t\t\t      msg2638->supplies);\n\tif (error) {\n\t\tdev_err(&msg2638->client->dev,\n\t\t\t\"Failed to enable regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(CHIP_ON_DELAY_MS);\n\n\tmsg2638_reset(msg2638);\n\n\tenable_irq(msg2638->client->irq);\n\n\treturn 0;\n}\n\nstatic int msg2638_stop(struct msg2638_ts_data *msg2638)\n{\n\tint error;\n\n\tdisable_irq(msg2638->client->irq);\n\n\terror = regulator_bulk_disable(ARRAY_SIZE(msg2638->supplies),\n\t\t\t\t       msg2638->supplies);\n\tif (error) {\n\t\tdev_err(&msg2638->client->dev,\n\t\t\t\"Failed to disable regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int msg2638_input_open(struct input_dev *dev)\n{\n\tstruct msg2638_ts_data *msg2638 = input_get_drvdata(dev);\n\n\treturn msg2638_start(msg2638);\n}\n\nstatic void msg2638_input_close(struct input_dev *dev)\n{\n\tstruct msg2638_ts_data *msg2638 = input_get_drvdata(dev);\n\n\tmsg2638_stop(msg2638);\n}\n\nstatic int msg2638_init_input_dev(struct msg2638_ts_data *msg2638)\n{\n\tstruct device *dev = &msg2638->client->dev;\n\tstruct input_dev *input_dev;\n\tint error;\n\tint i;\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev) {\n\t\tdev_err(dev, \"Failed to allocate input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(input_dev, msg2638);\n\tmsg2638->input_dev = input_dev;\n\n\tinput_dev->name = \"MStar TouchScreen\";\n\tinput_dev->phys = \"input/ts\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->open = msg2638_input_open;\n\tinput_dev->close = msg2638_input_close;\n\n\tif (msg2638->num_keycodes) {\n\t\tinput_dev->keycode = msg2638->keycodes;\n\t\tinput_dev->keycodemax = msg2638->num_keycodes;\n\t\tinput_dev->keycodesize = sizeof(msg2638->keycodes[0]);\n\t\tfor (i = 0; i < msg2638->num_keycodes; i++)\n\t\t\tinput_set_capability(input_dev,\n\t\t\t\t\t     EV_KEY, msg2638->keycodes[i]);\n\t}\n\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\n\ttouchscreen_parse_properties(input_dev, true, &msg2638->prop);\n\tif (!msg2638->prop.max_x || !msg2638->prop.max_y) {\n\t\tdev_err(dev, \"touchscreen-size-x and/or touchscreen-size-y not set in properties\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_mt_init_slots(input_dev, msg2638->max_fingers,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int msg2638_ts_probe(struct i2c_client *client)\n{\n\tconst struct msg_chip_data *chip_data;\n\tstruct device *dev = &client->dev;\n\tstruct msg2638_ts_data *msg2638;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"Failed to assert adapter's support for plain I2C.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmsg2638 = devm_kzalloc(dev, sizeof(*msg2638), GFP_KERNEL);\n\tif (!msg2638)\n\t\treturn -ENOMEM;\n\n\tmsg2638->client = client;\n\ti2c_set_clientdata(client, msg2638);\n\n\tchip_data = device_get_match_data(&client->dev);\n\tif (!chip_data || !chip_data->max_fingers) {\n\t\tdev_err(dev, \"Invalid or missing chip data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmsg2638->max_fingers = chip_data->max_fingers;\n\n\tmsg2638->supplies[0].supply = \"vdd\";\n\tmsg2638->supplies[1].supply = \"vddio\";\n\terror = devm_regulator_bulk_get(dev, ARRAY_SIZE(msg2638->supplies),\n\t\t\t\t\tmsg2638->supplies);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsg2638->reset_gpiod = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(msg2638->reset_gpiod)) {\n\t\terror = PTR_ERR(msg2638->reset_gpiod);\n\t\tdev_err(dev, \"Failed to request reset GPIO: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsg2638->num_keycodes = device_property_count_u32(dev,\n\t\t\t\t\t\t\t  \"linux,keycodes\");\n\tif (msg2638->num_keycodes == -EINVAL) {\n\t\tmsg2638->num_keycodes = 0;\n\t} else if (msg2638->num_keycodes < 0) {\n\t\tdev_err(dev, \"Unable to parse linux,keycodes property: %d\\n\",\n\t\t\tmsg2638->num_keycodes);\n\t\treturn msg2638->num_keycodes;\n\t} else if (msg2638->num_keycodes > ARRAY_SIZE(msg2638->keycodes)) {\n\t\tdev_warn(dev, \"Found %d linux,keycodes but max is %zd, ignoring the rest\\n\",\n\t\t\t msg2638->num_keycodes, ARRAY_SIZE(msg2638->keycodes));\n\t\tmsg2638->num_keycodes = ARRAY_SIZE(msg2638->keycodes);\n\t}\n\n\tif (msg2638->num_keycodes > 0) {\n\t\terror = device_property_read_u32_array(dev, \"linux,keycodes\",\n\t\t\t\t\t\t       msg2638->keycodes,\n\t\t\t\t\t\t       msg2638->num_keycodes);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Unable to read linux,keycodes values: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, chip_data->irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  client->name, msg2638);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = msg2638_init_input_dev(msg2638);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to initialize input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int msg2638_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct msg2638_ts_data *msg2638 = i2c_get_clientdata(client);\n\n\tmutex_lock(&msg2638->input_dev->mutex);\n\n\tif (input_device_enabled(msg2638->input_dev))\n\t\tmsg2638_stop(msg2638);\n\n\tmutex_unlock(&msg2638->input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int msg2638_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct msg2638_ts_data *msg2638 = i2c_get_clientdata(client);\n\tint ret = 0;\n\n\tmutex_lock(&msg2638->input_dev->mutex);\n\n\tif (input_device_enabled(msg2638->input_dev))\n\t\tret = msg2638_start(msg2638);\n\n\tmutex_unlock(&msg2638->input_dev->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(msg2638_pm_ops, msg2638_suspend, msg2638_resume);\n\nstatic const struct msg_chip_data msg2138_data = {\n\t.irq_handler = msg2138_ts_irq_handler,\n\t.max_fingers = MSG2138_MAX_FINGERS,\n};\n\nstatic const struct msg_chip_data msg2638_data = {\n\t.irq_handler = msg2638_ts_irq_handler,\n\t.max_fingers = MSG2638_MAX_FINGERS,\n};\n\nstatic const struct of_device_id msg2638_of_match[] = {\n\t{ .compatible = \"mstar,msg2138\", .data = &msg2138_data },\n\t{ .compatible = \"mstar,msg2638\", .data = &msg2638_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, msg2638_of_match);\n\nstatic struct i2c_driver msg2638_ts_driver = {\n\t.probe = msg2638_ts_probe,\n\t.driver = {\n\t\t.name = \"MStar-TS\",\n\t\t.pm = pm_sleep_ptr(&msg2638_pm_ops),\n\t\t.of_match_table = msg2638_of_match,\n\t},\n};\nmodule_i2c_driver(msg2638_ts_driver);\n\nMODULE_AUTHOR(\"Vincent Knecht <vincent.knecht@mailoo.org>\");\nMODULE_DESCRIPTION(\"MStar MSG2638 touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}