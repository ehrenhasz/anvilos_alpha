{
  "module_name": "wm9712.c",
  "hash_id": "aba6bfa3eec6df0b30819202a3e7dbf8064d87410bfc19b5e1a506c00aa66b9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wm9712.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/wm97xx.h>\n\n#define TS_NAME\t\t\t\"wm97xx\"\n#define WM9712_VERSION\t\t\"1.00\"\n#define DEFAULT_PRESSURE\t0xb0c0\n\n \n\n \nstatic int rpu = 8;\nmodule_param(rpu, int, 0);\nMODULE_PARM_DESC(rpu, \"Set internal pull up resistor for pen detect.\");\n\n \nstatic int pil;\nmodule_param(pil, int, 0);\nMODULE_PARM_DESC(pil, \"Set current used for pressure measurement.\");\n\n \nstatic int pressure = DEFAULT_PRESSURE & 0xfff;\nmodule_param(pressure, int, 0);\nMODULE_PARM_DESC(pressure, \"Set threshold for pressure measurement.\");\n\n \nstatic int delay = 3;\nmodule_param(delay, int, 0);\nMODULE_PARM_DESC(delay, \"Set adc sample delay.\");\n\n \nstatic int five_wire;\nmodule_param(five_wire, int, 0);\nMODULE_PARM_DESC(five_wire, \"Set to '1' to use 5-wire touchscreen.\");\n\n \nstatic int mask;\nmodule_param(mask, int, 0);\nMODULE_PARM_DESC(mask, \"Set adc mask function.\");\n\n \nstatic int coord;\nmodule_param(coord, int, 0);\nMODULE_PARM_DESC(coord, \"Polling coordinate mode\");\n\n \nstatic const int delay_table[] = {\n\t21,     \n\t42,     \n\t84,     \n\t167,    \n\t333,    \n\t667,    \n\t1000,   \n\t1333,   \n\t2000,   \n\t2667,   \n\t3333,   \n\t4000,   \n\t4667,   \n\t5333,   \n\t6000,   \n\t0       \n};\n\n \nstatic inline void poll_delay(int d)\n{\n\tudelay(3 * AC97_LINK_FRAME + delay_table[d]);\n}\n\n \nstatic void wm9712_phy_init(struct wm97xx *wm)\n{\n\tu16 dig1 = 0;\n\tu16 dig2 = WM97XX_RPR | WM9712_RPU(1);\n\n\t \n\tif (rpu) {\n\t\tdig2 &= 0xffc0;\n\t\tdig2 |= WM9712_RPU(rpu);\n\t\tdev_dbg(wm->dev, \"setting pen detect pull-up to %d Ohms\\n\",\n\t\t\t64000 / rpu);\n\t}\n\n\t \n\tif (five_wire) {\n\t\tdig2 |= WM9712_45W;\n\t\tdev_dbg(wm->dev, \"setting 5-wire touchscreen mode.\\n\");\n\n\t\tif (pil) {\n\t\t\tdev_warn(wm->dev, \"pressure measurement is not \"\n\t\t\t\t \"supported in 5-wire mode\\n\");\n\t\t\tpil = 0;\n\t\t}\n\t}\n\n\t \n\tif (pil == 2) {\n\t\tdig2 |= WM9712_PIL;\n\t\tdev_dbg(wm->dev,\n\t\t\t\"setting pressure measurement current to 400uA.\\n\");\n\t} else if (pil)\n\t\tdev_dbg(wm->dev,\n\t\t\t\"setting pressure measurement current to 200uA.\\n\");\n\tif (!pil)\n\t\tpressure = 0;\n\n\t \n\tif (delay < 0 || delay > 15) {\n\t\tdev_dbg(wm->dev, \"supplied delay out of range.\\n\");\n\t\tdelay = 4;\n\t}\n\tdig1 &= 0xff0f;\n\tdig1 |= WM97XX_DELAY(delay);\n\tdev_dbg(wm->dev, \"setting adc sample delay to %d u Secs.\\n\",\n\t\tdelay_table[delay]);\n\n\t \n\tdig2 |= ((mask & 0x3) << 6);\n\tif (mask) {\n\t\tu16 reg;\n\t\t \n\t\treg = wm97xx_reg_read(wm, AC97_MISC_AFE);\n\t\twm97xx_reg_write(wm, AC97_MISC_AFE, reg | WM97XX_GPIO_4);\n\t\treg = wm97xx_reg_read(wm, AC97_GPIO_CFG);\n\t\twm97xx_reg_write(wm, AC97_GPIO_CFG, reg | WM97XX_GPIO_4);\n\t}\n\n\t \n\tif (coord)\n\t\tdig2 |= WM9712_WAIT;\n\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, dig1);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, dig2);\n}\n\nstatic void wm9712_dig_enable(struct wm97xx *wm, int enable)\n{\n\tu16 dig2 = wm->dig[2];\n\n\tif (enable) {\n\t\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2,\n\t\t\t\t dig2 | WM97XX_PRP_DET_DIG);\n\t\twm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);  \n\t} else\n\t\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2,\n\t\t\t\t dig2 & ~WM97XX_PRP_DET_DIG);\n}\n\nstatic void wm9712_aux_prepare(struct wm97xx *wm)\n{\n\tmemcpy(wm->dig_save, wm->dig, sizeof(wm->dig));\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, 0);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, WM97XX_PRP_DET_DIG);\n}\n\nstatic void wm9712_dig_restore(struct wm97xx *wm)\n{\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, wm->dig_save[1]);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, wm->dig_save[2]);\n}\n\nstatic inline int is_pden(struct wm97xx *wm)\n{\n\treturn wm->dig[2] & WM9712_PDEN;\n}\n\n \nstatic int wm9712_poll_sample(struct wm97xx *wm, int adcsel, int *sample)\n{\n\tint timeout = 5 * delay;\n\tbool wants_pen = adcsel & WM97XX_PEN_DOWN;\n\n\tif (wants_pen && !wm->pen_probably_down) {\n\t\tu16 data = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t\tif (!(data & WM97XX_PEN_DOWN))\n\t\t\treturn RC_PENUP;\n\t\twm->pen_probably_down = 1;\n\t}\n\n\t \n\tif (wm->mach_ops && wm->mach_ops->pre_sample)\n\t\twm->mach_ops->pre_sample(adcsel);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, (adcsel & WM97XX_ADCSEL_MASK)\n\t\t\t\t| WM97XX_POLL | WM97XX_DELAY(delay));\n\n\t \n\tpoll_delay(delay);\n\n\t \n\twhile ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)\n\t       && timeout) {\n\t\tudelay(AC97_LINK_FRAME);\n\t\ttimeout--;\n\t}\n\n\tif (timeout <= 0) {\n\t\t \n\t\tif (is_pden(wm))\n\t\t\twm->pen_probably_down = 0;\n\t\telse\n\t\t\tdev_dbg(wm->dev, \"adc sample timeout\\n\");\n\t\treturn RC_PENUP;\n\t}\n\n\t*sample = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\tif (wm->mach_ops && wm->mach_ops->post_sample)\n\t\twm->mach_ops->post_sample(adcsel);\n\n\t \n\tif ((*sample ^ adcsel) & WM97XX_ADCSEL_MASK) {\n\t\tdev_dbg(wm->dev, \"adc wrong sample, wanted %x got %x\\n\",\n\t\t\tadcsel & WM97XX_ADCSEL_MASK,\n\t\t\t*sample & WM97XX_ADCSEL_MASK);\n\t\treturn RC_AGAIN;\n\t}\n\n\tif (wants_pen && !(*sample & WM97XX_PEN_DOWN)) {\n\t\t \n\t\t*sample = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t\tif (!(*sample & WM97XX_PEN_DOWN)) {\n\t\t\twm->pen_probably_down = 0;\n\t\t\treturn RC_PENUP;\n\t\t}\n\t}\n\n\treturn RC_VALID;\n}\n\n \nstatic int wm9712_poll_coord(struct wm97xx *wm, struct wm97xx_data *data)\n{\n\tint timeout = 5 * delay;\n\n\tif (!wm->pen_probably_down) {\n\t\tu16 data_rd = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t\tif (!(data_rd & WM97XX_PEN_DOWN))\n\t\t\treturn RC_PENUP;\n\t\twm->pen_probably_down = 1;\n\t}\n\n\t \n\tif (wm->mach_ops && wm->mach_ops->pre_sample)\n\t\twm->mach_ops->pre_sample(WM97XX_ADCSEL_X | WM97XX_ADCSEL_Y);\n\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1,\n\t\tWM97XX_COO | WM97XX_POLL | WM97XX_DELAY(delay));\n\n\t \n\tpoll_delay(delay);\n\tdata->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t \n\twhile ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)\n\t       && timeout) {\n\t\tudelay(AC97_LINK_FRAME);\n\t\ttimeout--;\n\t}\n\n\tif (timeout <= 0) {\n\t\t \n\t\tif (is_pden(wm))\n\t\t\twm->pen_probably_down = 0;\n\t\telse\n\t\t\tdev_dbg(wm->dev, \"adc sample timeout\\n\");\n\t\treturn RC_PENUP;\n\t}\n\n\t \n\tdata->y = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\tif (pil)\n\t\tdata->p = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\telse\n\t\tdata->p = DEFAULT_PRESSURE;\n\n\tif (wm->mach_ops && wm->mach_ops->post_sample)\n\t\twm->mach_ops->post_sample(WM97XX_ADCSEL_X | WM97XX_ADCSEL_Y);\n\n\t \n\tif (!(data->x & WM97XX_ADCSEL_X) || !(data->y & WM97XX_ADCSEL_Y))\n\t\tgoto err;\n\tif (pil && !(data->p & WM97XX_ADCSEL_PRES))\n\t\tgoto err;\n\n\tif (!(data->x & WM97XX_PEN_DOWN) || !(data->y & WM97XX_PEN_DOWN)) {\n\t\twm->pen_probably_down = 0;\n\t\treturn RC_PENUP;\n\t}\n\treturn RC_VALID;\nerr:\n\treturn 0;\n}\n\n \nstatic int wm9712_poll_touch(struct wm97xx *wm, struct wm97xx_data *data)\n{\n\tint rc;\n\n\tif (coord) {\n\t\trc = wm9712_poll_coord(wm, data);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\t} else {\n\t\trc = wm9712_poll_sample(wm, WM97XX_ADCSEL_X | WM97XX_PEN_DOWN,\n\t\t\t\t\t&data->x);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\n\t\trc = wm9712_poll_sample(wm, WM97XX_ADCSEL_Y | WM97XX_PEN_DOWN,\n\t\t\t\t\t&data->y);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\n\t\tif (pil && !five_wire) {\n\t\t\trc = wm9712_poll_sample(wm, WM97XX_ADCSEL_PRES | WM97XX_PEN_DOWN,\n\t\t\t\t\t\t&data->p);\n\t\t\tif (rc != RC_VALID)\n\t\t\t\treturn rc;\n\t\t} else\n\t\t\tdata->p = DEFAULT_PRESSURE;\n\t}\n\treturn RC_VALID;\n}\n\n \nstatic int wm9712_acc_enable(struct wm97xx *wm, int enable)\n{\n\tu16 dig1, dig2;\n\tint ret = 0;\n\n\tdig1 = wm->dig[1];\n\tdig2 = wm->dig[2];\n\n\tif (enable) {\n\t\t \n\t\tif (wm->mach_ops->acc_startup) {\n\t\t\tret = wm->mach_ops->acc_startup(wm);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tdig1 &= ~(WM97XX_CM_RATE_MASK | WM97XX_ADCSEL_MASK |\n\t\t\tWM97XX_DELAY_MASK | WM97XX_SLT_MASK);\n\t\tdig1 |= WM97XX_CTC | WM97XX_COO | WM97XX_SLEN |\n\t\t\tWM97XX_DELAY(delay) |\n\t\t\tWM97XX_SLT(wm->acc_slot) |\n\t\t\tWM97XX_RATE(wm->acc_rate);\n\t\tif (pil)\n\t\t\tdig1 |= WM97XX_ADCSEL_PRES;\n\t\tdig2 |= WM9712_PDEN;\n\t} else {\n\t\tdig1 &= ~(WM97XX_CTC | WM97XX_COO | WM97XX_SLEN);\n\t\tdig2 &= ~WM9712_PDEN;\n\t\tif (wm->mach_ops->acc_shutdown)\n\t\t\twm->mach_ops->acc_shutdown(wm);\n\t}\n\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, dig1);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, dig2);\n\n\treturn 0;\n}\n\nstruct wm97xx_codec_drv wm9712_codec = {\n\t.id = WM9712_ID2,\n\t.name = \"wm9712\",\n\t.poll_sample = wm9712_poll_sample,\n\t.poll_touch = wm9712_poll_touch,\n\t.acc_enable = wm9712_acc_enable,\n\t.phy_init = wm9712_phy_init,\n\t.dig_enable = wm9712_dig_enable,\n\t.dig_restore = wm9712_dig_restore,\n\t.aux_prepare = wm9712_aux_prepare,\n};\nEXPORT_SYMBOL_GPL(wm9712_codec);\n\n \nMODULE_AUTHOR(\"Liam Girdwood <lrg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"WM9712 Touch Screen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}