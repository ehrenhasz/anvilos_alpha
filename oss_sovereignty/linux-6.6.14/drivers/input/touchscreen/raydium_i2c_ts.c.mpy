{
  "module_name": "raydium_i2c_ts.c",
  "hash_id": "7adc5f35a64024a0da24547cd538d05dda50bb799e1757ea63366a071fe519b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/raydium_i2c_ts.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n \n#define RM_BOOT_BLDR\t\t0x02\n#define RM_BOOT_MAIN\t\t0x03\n\n \n#define RM_CMD_BOOT_PAGE_WRT\t0x0B\t\t \n#define RM_CMD_BOOT_WRT\t\t0x11\t\t \n#define RM_CMD_BOOT_ACK\t\t0x22\t\t \n#define RM_CMD_BOOT_CHK\t\t0x33\t\t \n#define RM_CMD_BOOT_READ\t0x44\t\t \n\n#define RM_BOOT_RDY\t\t0xFF\t\t \n#define RM_BOOT_CMD_READHWID\t0x0E\t\t \n\n \n#define RM_CMD_QUERY_BANK\t0x2B\n#define RM_CMD_DATA_BANK\t0x4D\n#define RM_CMD_ENTER_SLEEP\t0x4E\n#define RM_CMD_BANK_SWITCH\t0xAA\n\n#define RM_RESET_MSG_ADDR\t0x40000004\n\n#define RM_MAX_READ_SIZE\t56\n#define RM_PACKET_CRC_SIZE\t2\n\n \n#define RM_MAX_RETRIES\t\t3\n#define RM_RETRY_DELAY_MS\t20\n#define RM_MAX_TOUCH_NUM\t10\n#define RM_BOOT_DELAY_MS\t100\n\n \n#define RM_CONTACT_STATE_POS\t0\n#define RM_CONTACT_X_POS\t1\n#define RM_CONTACT_Y_POS\t3\n#define RM_CONTACT_PRESSURE_POS\t5\n#define RM_CONTACT_WIDTH_X_POS\t6\n#define RM_CONTACT_WIDTH_Y_POS\t7\n\n \n#define RM_BL_WRT_CMD_SIZE\t3\t \n#define RM_BL_WRT_PKG_SIZE\t32\t \n#define RM_BL_WRT_LEN\t\t(RM_BL_WRT_PKG_SIZE + RM_BL_WRT_CMD_SIZE)\n#define RM_FW_PAGE_SIZE\t\t128\n#define RM_MAX_FW_RETRIES\t30\n#define RM_MAX_FW_SIZE\t\t0xD000\n\n#define RM_POWERON_DELAY_USEC\t500\n#define RM_RESET_DELAY_MSEC\t50\n\nenum raydium_bl_cmd {\n\tBL_HEADER = 0,\n\tBL_PAGE_STR,\n\tBL_PKG_IDX,\n\tBL_DATA_STR,\n};\n\nenum raydium_bl_ack {\n\tRAYDIUM_ACK_NULL = 0,\n\tRAYDIUM_WAIT_READY,\n\tRAYDIUM_PATH_READY,\n};\n\nenum raydium_boot_mode {\n\tRAYDIUM_TS_MAIN = 0,\n\tRAYDIUM_TS_BLDR,\n};\n\n \nstruct raydium_data_info {\n\t__le32 data_bank_addr;\n\tu8 pkg_size;\n\tu8 tp_info_size;\n};\n\nstruct raydium_info {\n\t__le32 hw_ver;\t\t \n\tu8 main_ver;\n\tu8 sub_ver;\n\t__le16 ft_ver;\t\t \n\tu8 x_num;\n\tu8 y_num;\n\t__le16 x_max;\n\t__le16 y_max;\n\tu8 x_res;\t\t \n\tu8 y_res;\t\t \n};\n\n \nstruct raydium_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\n\tstruct regulator *avdd;\n\tstruct regulator *vccio;\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct raydium_info info;\n\n\tstruct mutex sysfs_mutex;\n\n\tu8 *report_data;\n\n\tu32 data_bank_addr;\n\tu8 report_size;\n\tu8 contact_size;\n\tu8 pkg_size;\n\n\tenum raydium_boot_mode boot_mode;\n};\n\n \nstruct __packed raydium_bank_switch_header {\n\tu8 cmd;\n\t__be32 be_addr;\n};\n\nstatic int raydium_i2c_xfer(struct i2c_client *client, u32 addr,\n\t\t\t    struct i2c_msg *xfer, size_t xfer_count)\n{\n\tint ret;\n\t \n\tint xfer_start_idx = (addr > 0xff) ? 0 : 1;\n\txfer_count -= xfer_start_idx;\n\n\tret = i2c_transfer(client->adapter, &xfer[xfer_start_idx], xfer_count);\n\tif (likely(ret == xfer_count))\n\t\treturn 0;\n\n\treturn ret < 0 ? ret : -EIO;\n}\n\nstatic int raydium_i2c_send(struct i2c_client *client,\n\t\t\t    u32 addr, const void *data, size_t len)\n{\n\tint tries = 0;\n\tint error;\n\tu8 *tx_buf;\n\tu8 reg_addr = addr & 0xff;\n\n\ttx_buf = kmalloc(len + 1, GFP_KERNEL);\n\tif (!tx_buf)\n\t\treturn -ENOMEM;\n\n\ttx_buf[0] = reg_addr;\n\tmemcpy(tx_buf + 1, data, len);\n\n\tdo {\n\t\tstruct raydium_bank_switch_header header = {\n\t\t\t.cmd = RM_CMD_BANK_SWITCH,\n\t\t\t.be_addr = cpu_to_be32(addr),\n\t\t};\n\n\t\t \n\t\tstruct i2c_msg xfer[] = {\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = sizeof(header),\n\t\t\t\t.buf = (u8 *)&header,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = len + 1,\n\t\t\t\t.buf = tx_buf,\n\t\t\t},\n\t\t};\n\n\t\terror = raydium_i2c_xfer(client, addr, xfer, ARRAY_SIZE(xfer));\n\t\tif (likely(!error))\n\t\t\tgoto out;\n\n\t\tmsleep(RM_RETRY_DELAY_MS);\n\t} while (++tries < RM_MAX_RETRIES);\n\n\tdev_err(&client->dev, \"%s failed: %d\\n\", __func__, error);\nout:\n\tkfree(tx_buf);\n\treturn error;\n}\n\nstatic int raydium_i2c_read(struct i2c_client *client,\n\t\t\t    u32 addr, void *data, size_t len)\n{\n\tint error;\n\n\twhile (len) {\n\t\tu8 reg_addr = addr & 0xff;\n\t\tstruct raydium_bank_switch_header header = {\n\t\t\t.cmd = RM_CMD_BANK_SWITCH,\n\t\t\t.be_addr = cpu_to_be32(addr),\n\t\t};\n\t\tsize_t xfer_len = min_t(size_t, len, RM_MAX_READ_SIZE);\n\n\t\t \n\t\tstruct i2c_msg xfer[] = {\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = sizeof(header),\n\t\t\t\t.buf = (u8 *)&header,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = 1,\n\t\t\t\t.buf = &reg_addr,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.addr = client->addr,\n\t\t\t\t.len = xfer_len,\n\t\t\t\t.buf = data,\n\t\t\t\t.flags = I2C_M_RD,\n\t\t\t}\n\t\t};\n\n\t\terror = raydium_i2c_xfer(client, addr, xfer, ARRAY_SIZE(xfer));\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\n\t\tlen -= xfer_len;\n\t\tdata += xfer_len;\n\t\taddr += xfer_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_sw_reset(struct i2c_client *client)\n{\n\tconst u8 soft_rst_cmd = 0x01;\n\tint error;\n\n\terror = raydium_i2c_send(client, RM_RESET_MSG_ADDR, &soft_rst_cmd,\n\t\t\t\t sizeof(soft_rst_cmd));\n\tif (error) {\n\t\tdev_err(&client->dev, \"software reset failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(RM_RESET_DELAY_MSEC);\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_query_ts_bootloader_info(struct raydium_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tstatic const u8 get_hwid[] = { RM_BOOT_CMD_READHWID,\n\t\t\t\t       0x10, 0xc0, 0x01, 0x00, 0x04, 0x00 };\n\tu8 rbuf[5] = { 0 };\n\tu32 hw_ver;\n\tint error;\n\n\terror = raydium_i2c_send(client, RM_CMD_BOOT_WRT,\n\t\t\t\t get_hwid, sizeof(get_hwid));\n\tif (error) {\n\t\tdev_err(&client->dev, \"WRT HWID command failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = raydium_i2c_send(client, RM_CMD_BOOT_ACK, rbuf, 1);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Ack HWID command failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = raydium_i2c_read(client, RM_CMD_BOOT_CHK, rbuf, sizeof(rbuf));\n\tif (error) {\n\t\tdev_err(&client->dev, \"Read HWID command failed: %d (%4ph)\\n\",\n\t\t\terror, rbuf + 1);\n\t\thw_ver = 0xffffffffUL;\n\t} else {\n\t\thw_ver = get_unaligned_be32(rbuf + 1);\n\t}\n\n\tts->info.hw_ver = cpu_to_le32(hw_ver);\n\tts->info.main_ver = 0xff;\n\tts->info.sub_ver = 0xff;\n\n\treturn error;\n}\n\nstatic int raydium_i2c_query_ts_info(struct raydium_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tstruct raydium_data_info data_info;\n\t__le32 query_bank_addr;\n\n\tint error, retry_cnt;\n\n\tfor (retry_cnt = 0; retry_cnt < RM_MAX_RETRIES; retry_cnt++) {\n\t\terror = raydium_i2c_read(client, RM_CMD_DATA_BANK,\n\t\t\t\t\t &data_info, sizeof(data_info));\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ts->report_data && ts->pkg_size != data_info.pkg_size) {\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"report size changes, was: %d, new: %d\\n\",\n\t\t\t\t ts->pkg_size, data_info.pkg_size);\n\t\t} else {\n\t\t\tts->pkg_size = data_info.pkg_size;\n\t\t\tts->report_size = ts->pkg_size - RM_PACKET_CRC_SIZE;\n\t\t}\n\n\t\tts->contact_size = data_info.tp_info_size;\n\t\tts->data_bank_addr = le32_to_cpu(data_info.data_bank_addr);\n\n\t\tdev_dbg(&client->dev,\n\t\t\t\"data_bank_addr: %#08x, report_size: %d, contact_size: %d\\n\",\n\t\t\tts->data_bank_addr, ts->report_size, ts->contact_size);\n\n\t\terror = raydium_i2c_read(client, RM_CMD_QUERY_BANK,\n\t\t\t\t\t &query_bank_addr,\n\t\t\t\t\t sizeof(query_bank_addr));\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\terror = raydium_i2c_read(client, le32_to_cpu(query_bank_addr),\n\t\t\t\t\t &ts->info, sizeof(ts->info));\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\treturn 0;\n\t}\n\n\tdev_err(&client->dev, \"failed to query device parameters: %d\\n\", error);\n\treturn error;\n}\n\nstatic int raydium_i2c_check_fw_status(struct raydium_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tstatic const u8 bl_ack = 0x62;\n\tstatic const u8 main_ack = 0x66;\n\tu8 buf[4];\n\tint error;\n\n\terror = raydium_i2c_read(client, RM_CMD_BOOT_READ, buf, sizeof(buf));\n\tif (!error) {\n\t\tif (buf[0] == bl_ack)\n\t\t\tts->boot_mode = RAYDIUM_TS_BLDR;\n\t\telse if (buf[0] == main_ack)\n\t\t\tts->boot_mode = RAYDIUM_TS_MAIN;\n\t\treturn 0;\n\t}\n\n\treturn error;\n}\n\nstatic int raydium_i2c_initialize(struct raydium_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error, retry_cnt;\n\n\tfor (retry_cnt = 0; retry_cnt < RM_MAX_RETRIES; retry_cnt++) {\n\t\t \n\t\tmsleep(RM_BOOT_DELAY_MS);\n\n\t\terror = raydium_i2c_check_fw_status(ts);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to read 'hello' packet: %d\\n\", error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ts->boot_mode == RAYDIUM_TS_BLDR ||\n\t\t    ts->boot_mode == RAYDIUM_TS_MAIN) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error)\n\t\tts->boot_mode = RAYDIUM_TS_BLDR;\n\n\tif (ts->boot_mode == RAYDIUM_TS_BLDR)\n\t\traydium_i2c_query_ts_bootloader_info(ts);\n\telse\n\t\traydium_i2c_query_ts_info(ts);\n\n\treturn error;\n}\n\nstatic int raydium_i2c_bl_chk_state(struct i2c_client *client,\n\t\t\t\t    enum raydium_bl_ack state)\n{\n\tstatic const u8 ack_ok[] = { 0xFF, 0x39, 0x30, 0x30, 0x54 };\n\tu8 rbuf[sizeof(ack_ok)];\n\tu8 retry;\n\tint error;\n\n\tfor (retry = 0; retry < RM_MAX_FW_RETRIES; retry++) {\n\t\tswitch (state) {\n\t\tcase RAYDIUM_ACK_NULL:\n\t\t\treturn 0;\n\n\t\tcase RAYDIUM_WAIT_READY:\n\t\t\terror = raydium_i2c_read(client, RM_CMD_BOOT_CHK,\n\t\t\t\t\t\t &rbuf[0], 1);\n\t\t\tif (!error && rbuf[0] == RM_BOOT_RDY)\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\n\t\tcase RAYDIUM_PATH_READY:\n\t\t\terror = raydium_i2c_read(client, RM_CMD_BOOT_CHK,\n\t\t\t\t\t\t rbuf, sizeof(rbuf));\n\t\t\tif (!error && !memcmp(rbuf, ack_ok, sizeof(ack_ok)))\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&client->dev, \"%s: invalid target state %d\\n\",\n\t\t\t\t__func__, state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmsleep(20);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int raydium_i2c_write_object(struct i2c_client *client,\n\t\t\t\t    const void *data, size_t len,\n\t\t\t\t    enum raydium_bl_ack state)\n{\n\tint error;\n\tstatic const u8 cmd[] = { 0xFF, 0x39 };\n\n\terror = raydium_i2c_send(client, RM_CMD_BOOT_WRT, data, len);\n\tif (error) {\n\t\tdev_err(&client->dev, \"WRT obj command failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = raydium_i2c_send(client, RM_CMD_BOOT_ACK, cmd, sizeof(cmd));\n\tif (error) {\n\t\tdev_err(&client->dev, \"Ack obj command failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = raydium_i2c_bl_chk_state(client, state);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BL check state failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\nstatic int raydium_i2c_boot_trigger(struct i2c_client *client)\n{\n\tstatic const u8 cmd[7][6] = {\n\t\t{ 0x08, 0x0C, 0x09, 0x00, 0x50, 0xD7 },\n\t\t{ 0x08, 0x04, 0x09, 0x00, 0x50, 0xA5 },\n\t\t{ 0x08, 0x04, 0x09, 0x00, 0x50, 0x00 },\n\t\t{ 0x08, 0x04, 0x09, 0x00, 0x50, 0xA5 },\n\t\t{ 0x08, 0x0C, 0x09, 0x00, 0x50, 0x00 },\n\t\t{ 0x06, 0x01, 0x00, 0x00, 0x00, 0x00 },\n\t\t{ 0x02, 0xA2, 0x00, 0x00, 0x00, 0x00 },\n\t};\n\tint i;\n\tint error;\n\n\tfor (i = 0; i < 7; i++) {\n\t\terror = raydium_i2c_write_object(client, cmd[i], sizeof(cmd[i]),\n\t\t\t\t\t\t RAYDIUM_WAIT_READY);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"boot trigger failed at step %d: %d\\n\",\n\t\t\t\ti, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_fw_trigger(struct i2c_client *client)\n{\n\tstatic const u8 cmd[5][11] = {\n\t\t{ 0, 0x09, 0x71, 0x0C, 0x09, 0x00, 0x50, 0xD7, 0, 0, 0 },\n\t\t{ 0, 0x09, 0x71, 0x04, 0x09, 0x00, 0x50, 0xA5, 0, 0, 0 },\n\t\t{ 0, 0x09, 0x71, 0x04, 0x09, 0x00, 0x50, 0x00, 0, 0, 0 },\n\t\t{ 0, 0x09, 0x71, 0x04, 0x09, 0x00, 0x50, 0xA5, 0, 0, 0 },\n\t\t{ 0, 0x09, 0x71, 0x0C, 0x09, 0x00, 0x50, 0x00, 0, 0, 0 },\n\t};\n\tint i;\n\tint error;\n\n\tfor (i = 0; i < 5; i++) {\n\t\terror = raydium_i2c_write_object(client, cmd[i], sizeof(cmd[i]),\n\t\t\t\t\t\t RAYDIUM_ACK_NULL);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"fw trigger failed at step %d: %d\\n\",\n\t\t\t\ti, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_check_path(struct i2c_client *client)\n{\n\tstatic const u8 cmd[] = { 0x09, 0x00, 0x09, 0x00, 0x50, 0x10, 0x00 };\n\tint error;\n\n\terror = raydium_i2c_write_object(client, cmd, sizeof(cmd),\n\t\t\t\t\t RAYDIUM_PATH_READY);\n\tif (error) {\n\t\tdev_err(&client->dev, \"check path command failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_enter_bl(struct i2c_client *client)\n{\n\tstatic const u8 cal_cmd[] = { 0x00, 0x01, 0x52 };\n\tint error;\n\n\terror = raydium_i2c_write_object(client, cal_cmd, sizeof(cal_cmd),\n\t\t\t\t\t RAYDIUM_ACK_NULL);\n\tif (error) {\n\t\tdev_err(&client->dev, \"enter bl command failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(RM_BOOT_DELAY_MS);\n\treturn 0;\n}\n\nstatic int raydium_i2c_leave_bl(struct i2c_client *client)\n{\n\tstatic const u8 leave_cmd[] = { 0x05, 0x00 };\n\tint error;\n\n\terror = raydium_i2c_write_object(client, leave_cmd, sizeof(leave_cmd),\n\t\t\t\t\t RAYDIUM_ACK_NULL);\n\tif (error) {\n\t\tdev_err(&client->dev, \"leave bl command failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(RM_BOOT_DELAY_MS);\n\treturn 0;\n}\n\nstatic int raydium_i2c_write_checksum(struct i2c_client *client,\n\t\t\t\t      size_t length, u16 checksum)\n{\n\tu8 checksum_cmd[] = { 0x00, 0x05, 0x6D, 0x00, 0x00, 0x00, 0x00 };\n\tint error;\n\n\tput_unaligned_le16(length, &checksum_cmd[3]);\n\tput_unaligned_le16(checksum, &checksum_cmd[5]);\n\n\terror = raydium_i2c_write_object(client,\n\t\t\t\t\t checksum_cmd, sizeof(checksum_cmd),\n\t\t\t\t\t RAYDIUM_ACK_NULL);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to write checksum: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_disable_watch_dog(struct i2c_client *client)\n{\n\tstatic const u8 cmd[] = { 0x0A, 0xAA };\n\tint error;\n\n\terror = raydium_i2c_write_object(client, cmd, sizeof(cmd),\n\t\t\t\t\t RAYDIUM_WAIT_READY);\n\tif (error) {\n\t\tdev_err(&client->dev, \"disable watchdog command failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_fw_write_page(struct i2c_client *client,\n\t\t\t\t     u16 page_idx, const void *data, size_t len)\n{\n\tu8 buf[RM_BL_WRT_LEN];\n\tsize_t xfer_len;\n\tint error;\n\tint i;\n\n\tBUILD_BUG_ON((RM_FW_PAGE_SIZE % RM_BL_WRT_PKG_SIZE) != 0);\n\n\tfor (i = 0; i < RM_FW_PAGE_SIZE / RM_BL_WRT_PKG_SIZE; i++) {\n\t\tbuf[BL_HEADER] = RM_CMD_BOOT_PAGE_WRT;\n\t\tbuf[BL_PAGE_STR] = page_idx ? 0xff : 0;\n\t\tbuf[BL_PKG_IDX] = i + 1;\n\n\t\txfer_len = min_t(size_t, len, RM_BL_WRT_PKG_SIZE);\n\t\tmemcpy(&buf[BL_DATA_STR], data, xfer_len);\n\t\tif (len < RM_BL_WRT_PKG_SIZE)\n\t\t\tmemset(&buf[BL_DATA_STR + xfer_len], 0xff,\n\t\t\t\tRM_BL_WRT_PKG_SIZE - xfer_len);\n\n\t\terror = raydium_i2c_write_object(client, buf, RM_BL_WRT_LEN,\n\t\t\t\t\t\t RAYDIUM_WAIT_READY);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"page write command failed for page %d, chunk %d: %d\\n\",\n\t\t\t\tpage_idx, i, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tdata += xfer_len;\n\t\tlen -= xfer_len;\n\t}\n\n\treturn error;\n}\n\nstatic u16 raydium_calc_chksum(const u8 *buf, u16 len)\n{\n\tu16 checksum = 0;\n\tu16 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tchecksum += buf[i];\n\n\treturn checksum;\n}\n\nstatic int raydium_i2c_do_update_firmware(struct raydium_data *ts,\n\t\t\t\t\t const struct firmware *fw)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst void *data;\n\tsize_t data_len;\n\tsize_t len;\n\tint page_nr;\n\tint i;\n\tint error;\n\tu16 fw_checksum;\n\n\tif (fw->size == 0 || fw->size > RM_MAX_FW_SIZE) {\n\t\tdev_err(&client->dev, \"Invalid firmware length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = raydium_i2c_check_fw_status(ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to access IC %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (ts->boot_mode == RAYDIUM_TS_MAIN) {\n\t\tfor (i = 0; i < RM_MAX_RETRIES; i++) {\n\t\t\terror = raydium_i2c_enter_bl(client);\n\t\t\tif (!error) {\n\t\t\t\terror = raydium_i2c_check_fw_status(ts);\n\t\t\t\tif (error) {\n\t\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\t\"unable to access IC: %d\\n\",\n\t\t\t\t\t\terror);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\n\t\t\t\tif (ts->boot_mode == RAYDIUM_TS_BLDR)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ts->boot_mode == RAYDIUM_TS_MAIN) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to jump to boot loader: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\terror = raydium_i2c_disable_watch_dog(client);\n\tif (error)\n\t\treturn error;\n\n\terror = raydium_i2c_check_path(client);\n\tif (error)\n\t\treturn error;\n\n\terror = raydium_i2c_boot_trigger(client);\n\tif (error) {\n\t\tdev_err(&client->dev, \"send boot trigger fail: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(RM_BOOT_DELAY_MS);\n\n\tdata = fw->data;\n\tdata_len = fw->size;\n\tpage_nr = 0;\n\n\twhile (data_len) {\n\t\tlen = min_t(size_t, data_len, RM_FW_PAGE_SIZE);\n\n\t\terror = raydium_i2c_fw_write_page(client, page_nr++, data, len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmsleep(20);\n\n\t\tdata += len;\n\t\tdata_len -= len;\n\t}\n\n\terror = raydium_i2c_leave_bl(client);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to leave boot loader: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tdev_dbg(&client->dev, \"left boot loader mode\\n\");\n\tmsleep(RM_BOOT_DELAY_MS);\n\n\terror = raydium_i2c_check_fw_status(ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to check fw status after write: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (ts->boot_mode != RAYDIUM_TS_MAIN) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to switch to main fw after writing firmware: %d\\n\",\n\t\t\terror);\n\t\treturn -EINVAL;\n\t}\n\n\terror = raydium_i2c_fw_trigger(client);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to trigger fw: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tfw_checksum = raydium_calc_chksum(fw->data, fw->size);\n\n\terror = raydium_i2c_write_checksum(client, fw->size, fw_checksum);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_fw_update(struct raydium_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst struct firmware *fw = NULL;\n\tchar *fw_file;\n\tint error;\n\n\tfw_file = kasprintf(GFP_KERNEL, \"raydium_%#04x.fw\",\n\t\t\t    le32_to_cpu(ts->info.hw_ver));\n\tif (!fw_file)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&client->dev, \"firmware name: %s\\n\", fw_file);\n\n\terror = request_firmware(&fw, fw_file, &client->dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to open firmware %s\\n\", fw_file);\n\t\tgoto out_free_fw_file;\n\t}\n\n\tdisable_irq(client->irq);\n\n\terror = raydium_i2c_do_update_firmware(ts, fw);\n\tif (error) {\n\t\tdev_err(&client->dev, \"firmware update failed: %d\\n\", error);\n\t\tts->boot_mode = RAYDIUM_TS_BLDR;\n\t\tgoto out_enable_irq;\n\t}\n\n\terror = raydium_i2c_initialize(ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to initialize device after firmware update: %d\\n\",\n\t\t\terror);\n\t\tts->boot_mode = RAYDIUM_TS_BLDR;\n\t\tgoto out_enable_irq;\n\t}\n\n\tts->boot_mode = RAYDIUM_TS_MAIN;\n\nout_enable_irq:\n\tenable_irq(client->irq);\n\tmsleep(100);\n\n\trelease_firmware(fw);\n\nout_free_fw_file:\n\tkfree(fw_file);\n\n\treturn error;\n}\n\nstatic void raydium_mt_event(struct raydium_data *ts)\n{\n\tint i;\n\n\tfor (i = 0; i < ts->report_size / ts->contact_size; i++) {\n\t\tu8 *contact = &ts->report_data[ts->contact_size * i];\n\t\tbool state = contact[RM_CONTACT_STATE_POS];\n\t\tu8 wx, wy;\n\n\t\tinput_mt_slot(ts->input, i);\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, state);\n\n\t\tif (!state)\n\t\t\tcontinue;\n\n\t\tinput_report_abs(ts->input, ABS_MT_POSITION_X,\n\t\t\t\tget_unaligned_le16(&contact[RM_CONTACT_X_POS]));\n\t\tinput_report_abs(ts->input, ABS_MT_POSITION_Y,\n\t\t\t\tget_unaligned_le16(&contact[RM_CONTACT_Y_POS]));\n\t\tinput_report_abs(ts->input, ABS_MT_PRESSURE,\n\t\t\t\tcontact[RM_CONTACT_PRESSURE_POS]);\n\n\t\twx = contact[RM_CONTACT_WIDTH_X_POS];\n\t\twy = contact[RM_CONTACT_WIDTH_Y_POS];\n\n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, max(wx, wy));\n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MINOR, min(wx, wy));\n\t}\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n}\n\nstatic irqreturn_t raydium_i2c_irq(int irq, void *_dev)\n{\n\tstruct raydium_data *ts = _dev;\n\tint error;\n\tu16 fw_crc;\n\tu16 calc_crc;\n\n\tif (ts->boot_mode != RAYDIUM_TS_MAIN)\n\t\tgoto out;\n\n\terror = raydium_i2c_read(ts->client, ts->data_bank_addr,\n\t\t\t\t ts->report_data, ts->pkg_size);\n\tif (error)\n\t\tgoto out;\n\n\tfw_crc = get_unaligned_le16(&ts->report_data[ts->report_size]);\n\tcalc_crc = raydium_calc_chksum(ts->report_data, ts->report_size);\n\tif (unlikely(fw_crc != calc_crc)) {\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"%s: invalid packet crc %#04x vs %#04x\\n\",\n\t\t\t __func__, calc_crc, fw_crc);\n\t\tgoto out;\n\t}\n\n\traydium_mt_event(ts);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t raydium_i2c_fw_ver_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d.%d\\n\", ts->info.main_ver, ts->info.sub_ver);\n}\n\nstatic ssize_t raydium_i2c_hw_ver_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%#04x\\n\", le32_to_cpu(ts->info.hw_ver));\n}\n\nstatic ssize_t raydium_i2c_boot_mode_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       ts->boot_mode == RAYDIUM_TS_MAIN ?\n\t\t\t\t\"Normal\" : \"Recovery\");\n}\n\nstatic ssize_t raydium_i2c_update_fw_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\tint error;\n\n\terror = mutex_lock_interruptible(&ts->sysfs_mutex);\n\tif (error)\n\t\treturn error;\n\n\terror = raydium_i2c_fw_update(ts);\n\n\tmutex_unlock(&ts->sysfs_mutex);\n\n\treturn error ?: count;\n}\n\nstatic ssize_t raydium_i2c_calibrate_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\tstatic const u8 cal_cmd[] = { 0x00, 0x01, 0x9E };\n\tint error;\n\n\terror = mutex_lock_interruptible(&ts->sysfs_mutex);\n\tif (error)\n\t\treturn error;\n\n\terror = raydium_i2c_write_object(client, cal_cmd, sizeof(cal_cmd),\n\t\t\t\t\t RAYDIUM_WAIT_READY);\n\tif (error)\n\t\tdev_err(&client->dev, \"calibrate command failed: %d\\n\", error);\n\n\tmutex_unlock(&ts->sysfs_mutex);\n\treturn error ?: count;\n}\n\nstatic DEVICE_ATTR(fw_version, S_IRUGO, raydium_i2c_fw_ver_show, NULL);\nstatic DEVICE_ATTR(hw_version, S_IRUGO, raydium_i2c_hw_ver_show, NULL);\nstatic DEVICE_ATTR(boot_mode, S_IRUGO, raydium_i2c_boot_mode_show, NULL);\nstatic DEVICE_ATTR(update_fw, S_IWUSR, NULL, raydium_i2c_update_fw_store);\nstatic DEVICE_ATTR(calibrate, S_IWUSR, NULL, raydium_i2c_calibrate_store);\n\nstatic struct attribute *raydium_i2c_attributes[] = {\n\t&dev_attr_update_fw.attr,\n\t&dev_attr_boot_mode.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_hw_version.attr,\n\t&dev_attr_calibrate.attr,\n\tNULL\n};\n\nstatic const struct attribute_group raydium_i2c_attribute_group = {\n\t.attrs = raydium_i2c_attributes,\n};\n\nstatic int raydium_i2c_power_on(struct raydium_data *ts)\n{\n\tint error;\n\n\tif (!ts->reset_gpio)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(ts->reset_gpio, 1);\n\n\terror = regulator_enable(ts->avdd);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to enable avdd regulator: %d\\n\", error);\n\t\tgoto release_reset_gpio;\n\t}\n\n\terror = regulator_enable(ts->vccio);\n\tif (error) {\n\t\tregulator_disable(ts->avdd);\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to enable vccio regulator: %d\\n\", error);\n\t\tgoto release_reset_gpio;\n\t}\n\n\tudelay(RM_POWERON_DELAY_USEC);\n\nrelease_reset_gpio:\n\tgpiod_set_value_cansleep(ts->reset_gpio, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tmsleep(RM_RESET_DELAY_MSEC);\n\n\treturn 0;\n}\n\nstatic void raydium_i2c_power_off(void *_data)\n{\n\tstruct raydium_data *ts = _data;\n\n\tif (ts->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 1);\n\t\tregulator_disable(ts->vccio);\n\t\tregulator_disable(ts->avdd);\n\t}\n}\n\nstatic int raydium_i2c_probe(struct i2c_client *client)\n{\n\tunion i2c_smbus_data dummy;\n\tstruct raydium_data *ts;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"i2c check functionality error (need I2C_FUNC_I2C)\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ts->sysfs_mutex);\n\n\tts->client = client;\n\ti2c_set_clientdata(client, ts);\n\n\tts->avdd = devm_regulator_get(&client->dev, \"avdd\");\n\tif (IS_ERR(ts->avdd))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->avdd),\n\t\t\t\t     \"Failed to get 'avdd' regulator\\n\");\n\n\tts->vccio = devm_regulator_get(&client->dev, \"vccio\");\n\tif (IS_ERR(ts->vccio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->vccio),\n\t\t\t\t     \"Failed to get 'vccio' regulator\\n\");\n\n\tts->reset_gpio = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->reset_gpio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->reset_gpio),\n\t\t\t\t     \"Failed to get reset gpio\\n\");\n\n\terror = raydium_i2c_power_on(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t raydium_i2c_power_off, ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to install power off action: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tif (i2c_smbus_xfer(client->adapter, client->addr, 0,\n\t\t\t   I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0) {\n\t\tdev_err(&client->dev, \"nothing at this address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\terror = raydium_i2c_initialize(ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to initialize: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->report_data = devm_kmalloc(&client->dev,\n\t\t\t\t       ts->pkg_size, GFP_KERNEL);\n\tif (!ts->report_data)\n\t\treturn -ENOMEM;\n\n\tts->input = devm_input_allocate_device(&client->dev);\n\tif (!ts->input) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->input->name = \"Raydium Touchscreen\";\n\tts->input->id.bustype = BUS_I2C;\n\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_X,\n\t\t\t     0, le16_to_cpu(ts->info.x_max), 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_Y,\n\t\t\t     0, le16_to_cpu(ts->info.y_max), 0, 0);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->info.x_res);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->info.y_res);\n\n\tinput_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\n\terror = input_mt_init_slots(ts->input, RM_MAX_TOUCH_NUM,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, raydium_i2c_irq,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev,\n\t\t\t\t   &raydium_i2c_attribute_group);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to create sysfs attributes: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void raydium_enter_sleep(struct i2c_client *client)\n{\n\tstatic const u8 sleep_cmd[] = { 0x5A, 0xff, 0x00, 0x0f };\n\tint error;\n\n\terror = raydium_i2c_send(client, RM_CMD_ENTER_SLEEP,\n\t\t\t\t sleep_cmd, sizeof(sleep_cmd));\n\tif (error)\n\t\tdev_err(&client->dev,\n\t\t\t\"sleep command failed: %d\\n\", error);\n}\n\nstatic int raydium_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\n\t \n\tif (ts->boot_mode != RAYDIUM_TS_MAIN)\n\t\treturn -EBUSY;\n\n\tdisable_irq(client->irq);\n\n\tif (device_may_wakeup(dev)) {\n\t\traydium_enter_sleep(client);\n\t} else {\n\t\traydium_i2c_power_off(ts);\n\t}\n\n\treturn 0;\n}\n\nstatic int raydium_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct raydium_data *ts = i2c_get_clientdata(client);\n\n\tif (device_may_wakeup(dev)) {\n\t\traydium_i2c_sw_reset(client);\n\t} else {\n\t\traydium_i2c_power_on(ts);\n\t\traydium_i2c_initialize(ts);\n\t}\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(raydium_i2c_pm_ops,\n\t\t\t\traydium_i2c_suspend, raydium_i2c_resume);\n\nstatic const struct i2c_device_id raydium_i2c_id[] = {\n\t{ \"raydium_i2c\", 0 },\n\t{ \"rm32380\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, raydium_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id raydium_acpi_id[] = {\n\t{ \"RAYD0001\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, raydium_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id raydium_of_match[] = {\n\t{ .compatible = \"raydium,rm32380\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, raydium_of_match);\n#endif\n\nstatic struct i2c_driver raydium_i2c_driver = {\n\t.probe = raydium_i2c_probe,\n\t.id_table = raydium_i2c_id,\n\t.driver = {\n\t\t.name = \"raydium_ts\",\n\t\t.pm = pm_sleep_ptr(&raydium_i2c_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(raydium_acpi_id),\n\t\t.of_match_table = of_match_ptr(raydium_of_match),\n\t},\n};\nmodule_i2c_driver(raydium_i2c_driver);\n\nMODULE_AUTHOR(\"Raydium\");\nMODULE_DESCRIPTION(\"Raydium I2c Touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}