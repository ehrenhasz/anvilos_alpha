{
  "module_name": "tps6507x-ts.c",
  "hash_id": "e029aaf4f44acdad46268094012192b9ea9feceb4e12faf8276bf21ee33fc196",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/tps6507x-ts.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/tps6507x.h>\n#include <linux/input/tps6507x-ts.h>\n#include <linux/delay.h>\n\n#define TSC_DEFAULT_POLL_PERIOD 30  \n#define TPS_DEFAULT_MIN_PRESSURE 0x30\n#define MAX_10BIT ((1 << 10) - 1)\n\n#define\tTPS6507X_ADCONFIG_CONVERT_TS (TPS6507X_ADCONFIG_AD_ENABLE | \\\n\t\t\t\t\t TPS6507X_ADCONFIG_START_CONVERSION | \\\n\t\t\t\t\t TPS6507X_ADCONFIG_INPUT_REAL_TSC)\n#define\tTPS6507X_ADCONFIG_POWER_DOWN_TS (TPS6507X_ADCONFIG_INPUT_REAL_TSC)\n\nstruct ts_event {\n\tu16\tx;\n\tu16\ty;\n\tu16\tpressure;\n};\n\nstruct tps6507x_ts {\n\tstruct device\t\t*dev;\n\tstruct input_dev\t*input;\n\tstruct tps6507x_dev\t*mfd;\n\tchar\t\t\tphys[32];\n\tstruct ts_event\t\ttc;\n\tu16\t\t\tmin_pressure;\n\tbool\t\t\tpendown;\n};\n\nstatic int tps6507x_read_u8(struct tps6507x_ts *tsc, u8 reg, u8 *data)\n{\n\treturn tsc->mfd->read_dev(tsc->mfd, reg, 1, data);\n}\n\nstatic int tps6507x_write_u8(struct tps6507x_ts *tsc, u8 reg, u8 data)\n{\n\treturn tsc->mfd->write_dev(tsc->mfd, reg, 1, &data);\n}\n\nstatic s32 tps6507x_adc_conversion(struct tps6507x_ts *tsc,\n\t\t\t\t   u8 tsc_mode, u16 *value)\n{\n\ts32 ret;\n\tu8 adc_status;\n\tu8 result;\n\n\t \n\n\tret = tps6507x_write_u8(tsc, TPS6507X_REG_TSCMODE, tsc_mode);\n\tif (ret) {\n\t\tdev_err(tsc->dev, \"TSC mode read failed\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\n\tret = tps6507x_write_u8(tsc, TPS6507X_REG_ADCONFIG,\n\t\t\t\tTPS6507X_ADCONFIG_CONVERT_TS);\n\tif (ret) {\n\t\tdev_err(tsc->dev, \"ADC config write failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\tret = tps6507x_read_u8(tsc, TPS6507X_REG_ADCONFIG,\n\t\t\t\t       &adc_status);\n\t\tif (ret) {\n\t\t\tdev_err(tsc->dev, \"ADC config read failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t} while (adc_status & TPS6507X_ADCONFIG_START_CONVERSION);\n\n\tret = tps6507x_read_u8(tsc, TPS6507X_REG_ADRESULT_2, &result);\n\tif (ret) {\n\t\tdev_err(tsc->dev, \"ADC result 2 read failed\\n\");\n\t\tgoto err;\n\t}\n\n\t*value = (result & TPS6507X_REG_ADRESULT_2_MASK) << 8;\n\n\tret = tps6507x_read_u8(tsc, TPS6507X_REG_ADRESULT_1, &result);\n\tif (ret) {\n\t\tdev_err(tsc->dev, \"ADC result 1 read failed\\n\");\n\t\tgoto err;\n\t}\n\n\t*value |= result;\n\n\tdev_dbg(tsc->dev, \"TSC channel %d = 0x%X\\n\", tsc_mode, *value);\n\nerr:\n\treturn ret;\n}\n\n \n\nstatic s32 tps6507x_adc_standby(struct tps6507x_ts *tsc)\n{\n\ts32 ret;\n\tu8 val;\n\n\tret = tps6507x_write_u8(tsc,  TPS6507X_REG_ADCONFIG,\n\t\t\t\tTPS6507X_ADCONFIG_INPUT_TSC);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps6507x_write_u8(tsc, TPS6507X_REG_TSCMODE,\n\t\t\t\tTPS6507X_TSCMODE_STANDBY);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (val & TPS6507X_REG_TSC_INT) {\n\t\tmdelay(10);\n\t\tret = tps6507x_read_u8(tsc, TPS6507X_REG_INT, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void tps6507x_ts_poll(struct input_dev *input_dev)\n{\n\tstruct tps6507x_ts *tsc = input_get_drvdata(input_dev);\n\tbool pendown;\n\ts32 ret;\n\n\tret = tps6507x_adc_conversion(tsc, TPS6507X_TSCMODE_PRESSURE,\n\t\t\t\t      &tsc->tc.pressure);\n\tif (ret)\n\t\tgoto done;\n\n\tpendown = tsc->tc.pressure > tsc->min_pressure;\n\n\tif (unlikely(!pendown && tsc->pendown)) {\n\t\tdev_dbg(tsc->dev, \"UP\\n\");\n\t\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\t\tinput_report_abs(input_dev, ABS_PRESSURE, 0);\n\t\tinput_sync(input_dev);\n\t\ttsc->pendown = false;\n\t}\n\n\tif (pendown) {\n\n\t\tif (!tsc->pendown) {\n\t\t\tdev_dbg(tsc->dev, \"DOWN\\n\");\n\t\t\tinput_report_key(input_dev, BTN_TOUCH, 1);\n\t\t} else\n\t\t\tdev_dbg(tsc->dev, \"still down\\n\");\n\n\t\tret =  tps6507x_adc_conversion(tsc, TPS6507X_TSCMODE_X_POSITION,\n\t\t\t\t\t       &tsc->tc.x);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tret =  tps6507x_adc_conversion(tsc, TPS6507X_TSCMODE_Y_POSITION,\n\t\t\t\t\t       &tsc->tc.y);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tinput_report_abs(input_dev, ABS_X, tsc->tc.x);\n\t\tinput_report_abs(input_dev, ABS_Y, tsc->tc.y);\n\t\tinput_report_abs(input_dev, ABS_PRESSURE, tsc->tc.pressure);\n\t\tinput_sync(input_dev);\n\t\ttsc->pendown = true;\n\t}\n\ndone:\n\ttps6507x_adc_standby(tsc);\n}\n\nstatic int tps6507x_ts_probe(struct platform_device *pdev)\n{\n\tstruct tps6507x_dev *tps6507x_dev = dev_get_drvdata(pdev->dev.parent);\n\tconst struct tps6507x_board *tps_board;\n\tconst struct touchscreen_init_data *init_data;\n\tstruct tps6507x_ts *tsc;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\t \n\ttps_board = dev_get_platdata(tps6507x_dev->dev);\n\tif (!tps_board) {\n\t\tdev_err(tps6507x_dev->dev,\n\t\t\t\"Could not find tps6507x platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tinit_data = tps_board->tps6507x_ts_init_data;\n\n\ttsc = devm_kzalloc(&pdev->dev, sizeof(struct tps6507x_ts), GFP_KERNEL);\n\tif (!tsc) {\n\t\tdev_err(tps6507x_dev->dev, \"failed to allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttsc->mfd = tps6507x_dev;\n\ttsc->dev = tps6507x_dev->dev;\n\ttsc->min_pressure = init_data ?\n\t\t\tinit_data->min_pressure : TPS_DEFAULT_MIN_PRESSURE;\n\n\tsnprintf(tsc->phys, sizeof(tsc->phys),\n\t\t \"%s/input0\", dev_name(tsc->dev));\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(tsc->dev, \"Failed to allocate polled input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttsc->input = input_dev;\n\tinput_set_drvdata(input_dev, tsc);\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X, 0, MAX_10BIT, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MAX_10BIT, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_10BIT, 0, 0);\n\n\tinput_dev->name = \"TPS6507x Touchscreen\";\n\tinput_dev->phys = tsc->phys;\n\tinput_dev->dev.parent = tsc->dev;\n\tinput_dev->id.bustype = BUS_I2C;\n\tif (init_data) {\n\t\tinput_dev->id.vendor = init_data->vendor;\n\t\tinput_dev->id.product = init_data->product;\n\t\tinput_dev->id.version = init_data->version;\n\t}\n\n\terror = tps6507x_adc_standby(tsc);\n\tif (error)\n\t\treturn error;\n\n\terror = input_setup_polling(input_dev, tps6507x_ts_poll);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_poll_interval(input_dev,\n\t\t\t\tinit_data ? init_data->poll_period :\n\t\t\t\t\t    TSC_DEFAULT_POLL_PERIOD);\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic struct platform_driver tps6507x_ts_driver = {\n\t.driver = {\n\t\t.name = \"tps6507x-ts\",\n\t},\n\t.probe = tps6507x_ts_probe,\n};\nmodule_platform_driver(tps6507x_ts_driver);\n\nMODULE_AUTHOR(\"Todd Fischer <todd.fischer@ridgerun.com>\");\nMODULE_DESCRIPTION(\"TPS6507x - TouchScreen driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:tps6507x-ts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}