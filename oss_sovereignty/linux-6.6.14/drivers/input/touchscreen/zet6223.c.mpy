{
  "module_name": "zet6223.c",
  "hash_id": "5f368d1b82dbaa3f1f2b9de8adf54245549b405fcb67aab697237b5dfd10cab2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/zet6223.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <asm/unaligned.h>\n\n#define ZET6223_MAX_FINGERS\t\t16\n#define ZET6223_MAX_PKT_SIZE\t\t(3 + 4 * ZET6223_MAX_FINGERS)\n\n#define ZET6223_CMD_INFO\t\t0xB2\n#define ZET6223_CMD_INFO_LENGTH\t\t17\n#define ZET6223_VALID_PACKET\t\t0x3c\n\n#define ZET6223_POWER_ON_DELAY_MSEC\t30\n\nstruct zet6223_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct regulator *vcc;\n\tstruct regulator *vio;\n\tstruct touchscreen_properties prop;\n\tstruct regulator_bulk_data supplies[2];\n\tu16 max_x;\n\tu16 max_y;\n\tu8 fingernum;\n};\n\nstatic int zet6223_start(struct input_dev *dev)\n{\n\tstruct zet6223_ts *ts = input_get_drvdata(dev);\n\n\tenable_irq(ts->client->irq);\n\n\treturn 0;\n}\n\nstatic void zet6223_stop(struct input_dev *dev)\n{\n\tstruct zet6223_ts *ts = input_get_drvdata(dev);\n\n\tdisable_irq(ts->client->irq);\n}\n\nstatic irqreturn_t zet6223_irq(int irq, void *dev_id)\n{\n\tstruct zet6223_ts *ts = dev_id;\n\tu16 finger_bits;\n\n\t \n\tu8 bufsize = 3 + 4 * ts->fingernum;\n\tu8 buf[ZET6223_MAX_PKT_SIZE];\n\tint i;\n\tint ret;\n\tint error;\n\n\tret = i2c_master_recv(ts->client, buf, bufsize);\n\tif (ret != bufsize) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err_ratelimited(&ts->client->dev,\n\t\t\t\t    \"Error reading input data: %d\\n\", error);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (buf[0] != ZET6223_VALID_PACKET)\n\t\treturn IRQ_HANDLED;\n\n\tfinger_bits = get_unaligned_be16(buf + 1);\n\tfor (i = 0; i < ts->fingernum; i++) {\n\t\tif (!(finger_bits & BIT(15 - i)))\n\t\t\tcontinue;\n\n\t\tinput_mt_slot(ts->input, i);\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\n\t\tinput_event(ts->input, EV_ABS, ABS_MT_POSITION_X,\n\t\t\t\t((buf[i + 3] >> 4) << 8) + buf[i + 4]);\n\t\tinput_event(ts->input, EV_ABS, ABS_MT_POSITION_Y,\n\t\t\t\t((buf[i + 3] & 0xF) << 8) + buf[i + 5]);\n\t}\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void zet6223_power_off(void *_ts)\n{\n\tstruct zet6223_ts *ts = _ts;\n\n\tregulator_bulk_disable(ARRAY_SIZE(ts->supplies), ts->supplies);\n}\n\nstatic int zet6223_power_on(struct zet6223_ts *ts)\n{\n\tstruct device *dev = &ts->client->dev;\n\tint error;\n\n\tts->supplies[0].supply = \"vio\";\n\tts->supplies[1].supply = \"vcc\";\n\n\terror = devm_regulator_bulk_get(dev, ARRAY_SIZE(ts->supplies),\n\t\t\t\t\tts->supplies);\n\tif (error)\n\t\treturn error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(ts->supplies), ts->supplies);\n\tif (error)\n\t\treturn error;\n\n\tmsleep(ZET6223_POWER_ON_DELAY_MSEC);\n\n\terror = devm_add_action_or_reset(dev, zet6223_power_off, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to install poweroff action: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int zet6223_query_device(struct zet6223_ts *ts)\n{\n\tu8 buf[ZET6223_CMD_INFO_LENGTH];\n\tu8 cmd = ZET6223_CMD_INFO;\n\tint ret;\n\tint error;\n\n\tret = i2c_master_send(ts->client, &cmd, sizeof(cmd));\n\tif (ret != sizeof(cmd)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"touchpanel info cmd failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tret = i2c_master_recv(ts->client, buf, sizeof(buf));\n\tif (ret != sizeof(buf)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to retrieve touchpanel info: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->fingernum = buf[15] & 0x7F;\n\tif (ts->fingernum > ZET6223_MAX_FINGERS) {\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"touchpanel reports %d fingers, limiting to %d\\n\",\n\t\t\t ts->fingernum, ZET6223_MAX_FINGERS);\n\t\tts->fingernum = ZET6223_MAX_FINGERS;\n\t}\n\n\tts->max_x = get_unaligned_le16(&buf[8]);\n\tts->max_y = get_unaligned_le16(&buf[10]);\n\n\treturn 0;\n}\n\nstatic int zet6223_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct zet6223_ts *ts;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"no irq specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\n\terror = zet6223_power_on(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = zet6223_query_device(ts);\n\tif (error)\n\t\treturn error;\n\n\tts->input = input = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(input, ts);\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = zet6223_start;\n\tinput->close = zet6223_stop;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, &ts->prop);\n\n\terror = input_mt_init_slots(input, ts->fingernum,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, zet6223_irq,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request irq %d: %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\tzet6223_stop(input);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zet6223_of_match[] = {\n\t{ .compatible = \"zeitec,zet6223\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, zet6223_of_match);\n\nstatic const struct i2c_device_id zet6223_id[] = {\n\t{ \"zet6223\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, zet6223_id);\n\nstatic struct i2c_driver zet6223_driver = {\n\t.driver = {\n\t\t.name = \"zet6223\",\n\t\t.of_match_table = zet6223_of_match,\n\t},\n\t.probe = zet6223_probe,\n\t.id_table = zet6223_id\n};\nmodule_i2c_driver(zet6223_driver);\n\nMODULE_AUTHOR(\"Jelle van der Waa <jelle@vdwaa.nl>\");\nMODULE_DESCRIPTION(\"ZEITEC zet622x I2C touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}