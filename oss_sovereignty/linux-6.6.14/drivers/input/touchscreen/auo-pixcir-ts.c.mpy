{
  "module_name": "auo-pixcir-ts.c",
  "hash_id": "89b76fba3c758e5d45c281b1a1c4bbbf4d1df011569ad758b4671c6f2c67e273",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/auo-pixcir-ts.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/property.h>\n\n \n#define AUO_PIXCIR_REG_X1_LSB\t\t0x00\n#define AUO_PIXCIR_REG_X1_MSB\t\t0x01\n#define AUO_PIXCIR_REG_Y1_LSB\t\t0x02\n#define AUO_PIXCIR_REG_Y1_MSB\t\t0x03\n#define AUO_PIXCIR_REG_X2_LSB\t\t0x04\n#define AUO_PIXCIR_REG_X2_MSB\t\t0x05\n#define AUO_PIXCIR_REG_Y2_LSB\t\t0x06\n#define AUO_PIXCIR_REG_Y2_MSB\t\t0x07\n\n#define AUO_PIXCIR_REG_STRENGTH\t\t0x0d\n#define AUO_PIXCIR_REG_STRENGTH_X1_LSB\t0x0e\n#define AUO_PIXCIR_REG_STRENGTH_X1_MSB\t0x0f\n\n#define AUO_PIXCIR_REG_RAW_DATA_X\t0x2b\n#define AUO_PIXCIR_REG_RAW_DATA_Y\t0x4f\n\n#define AUO_PIXCIR_REG_X_SENSITIVITY\t0x6f\n#define AUO_PIXCIR_REG_Y_SENSITIVITY\t0x70\n#define AUO_PIXCIR_REG_INT_SETTING\t0x71\n#define AUO_PIXCIR_REG_INT_WIDTH\t0x72\n#define AUO_PIXCIR_REG_POWER_MODE\t0x73\n\n#define AUO_PIXCIR_REG_VERSION\t\t0x77\n#define AUO_PIXCIR_REG_CALIBRATE\t0x78\n\n#define AUO_PIXCIR_REG_TOUCHAREA_X1\t0x1e\n#define AUO_PIXCIR_REG_TOUCHAREA_Y1\t0x1f\n#define AUO_PIXCIR_REG_TOUCHAREA_X2\t0x20\n#define AUO_PIXCIR_REG_TOUCHAREA_Y2\t0x21\n\n#define AUO_PIXCIR_REG_EEPROM_CALIB_X\t0x42\n#define AUO_PIXCIR_REG_EEPROM_CALIB_Y\t0xad\n\n#define AUO_PIXCIR_INT_TPNUM_MASK\t0xe0\n#define AUO_PIXCIR_INT_TPNUM_SHIFT\t5\n#define AUO_PIXCIR_INT_RELEASE\t\t(1 << 4)\n#define AUO_PIXCIR_INT_ENABLE\t\t(1 << 3)\n#define AUO_PIXCIR_INT_POL_HIGH\t\t(1 << 2)\n\n \n#define AUO_PIXCIR_INT_PERIODICAL\t0x00\n#define AUO_PIXCIR_INT_COMP_COORD\t0x01\n#define AUO_PIXCIR_INT_TOUCH_IND\t0x02\n#define AUO_PIXCIR_INT_MODE_MASK\t0x03\n\n \n#define AUO_PIXCIR_POWER_ACTIVE\t\t0x00\n#define AUO_PIXCIR_POWER_SLEEP\t\t0x01\n#define AUO_PIXCIR_POWER_DEEP_SLEEP\t0x02\n#define AUO_PIXCIR_POWER_MASK\t\t0x03\n\n#define AUO_PIXCIR_POWER_ALLOW_SLEEP\t(1 << 2)\n#define AUO_PIXCIR_POWER_IDLE_TIME(ms)\t((ms & 0xf) << 4)\n\n#define AUO_PIXCIR_CALIBRATE\t\t0x03\n\n#define AUO_PIXCIR_EEPROM_CALIB_X_LEN\t62\n#define AUO_PIXCIR_EEPROM_CALIB_Y_LEN\t36\n\n#define AUO_PIXCIR_RAW_DATA_X_LEN\t18\n#define AUO_PIXCIR_RAW_DATA_Y_LEN\t11\n\n#define AUO_PIXCIR_STRENGTH_ENABLE\t(1 << 0)\n\n \n#define AUO_PIXCIR_REPORT_POINTS\t2\n#define AUO_PIXCIR_MAX_AREA\t\t0xff\n#define AUO_PIXCIR_PENUP_TIMEOUT_MS\t10\n\nstruct auo_pixcir_ts {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input;\n\tstruct gpio_desc\t*gpio_int;\n\tstruct gpio_desc\t*gpio_rst;\n\tchar\t\t\tphys[32];\n\n\tunsigned int\t\tx_max;\n\tunsigned int\t\ty_max;\n\n\t \n\tbool\t\t\ttouch_ind_mode;\n\n\twait_queue_head_t\twait;\n\tbool\t\t\tstopped;\n};\n\nstruct auo_point_t {\n\tint\tcoord_x;\n\tint\tcoord_y;\n\tint\tarea_major;\n\tint\tarea_minor;\n\tint\torientation;\n};\n\nstatic int auo_pixcir_collect_data(struct auo_pixcir_ts *ts,\n\t\t\t\t   struct auo_point_t *point)\n{\n\tstruct i2c_client *client = ts->client;\n\tuint8_t raw_coord[8];\n\tuint8_t raw_area[4];\n\tint i, ret;\n\n\t \n\tret = i2c_smbus_read_i2c_block_data(client, AUO_PIXCIR_REG_X1_LSB,\n\t\t\t\t\t    8, raw_coord);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed to read coordinate, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = i2c_smbus_read_i2c_block_data(client, AUO_PIXCIR_REG_TOUCHAREA_X1,\n\t\t\t\t\t    4, raw_area);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"could not read touch area, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < AUO_PIXCIR_REPORT_POINTS; i++) {\n\t\tpoint[i].coord_x =\n\t\t\traw_coord[4 * i + 1] << 8 | raw_coord[4 * i];\n\t\tpoint[i].coord_y =\n\t\t\traw_coord[4 * i + 3] << 8 | raw_coord[4 * i + 2];\n\n\t\tif (point[i].coord_x > ts->x_max ||\n\t\t    point[i].coord_y > ts->y_max) {\n\t\t\tdev_warn(&client->dev, \"coordinates (%d,%d) invalid\\n\",\n\t\t\t\tpoint[i].coord_x, point[i].coord_y);\n\t\t\tpoint[i].coord_x = point[i].coord_y = 0;\n\t\t}\n\n\t\t \n\t\tpoint[i].area_major = max(raw_area[2 * i], raw_area[2 * i + 1]);\n\t\tpoint[i].area_minor = min(raw_area[2 * i], raw_area[2 * i + 1]);\n\t\tpoint[i].orientation = raw_area[2 * i] > raw_area[2 * i + 1];\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t auo_pixcir_interrupt(int irq, void *dev_id)\n{\n\tstruct auo_pixcir_ts *ts = dev_id;\n\tstruct auo_point_t point[AUO_PIXCIR_REPORT_POINTS];\n\tint i;\n\tint ret;\n\tint fingers = 0;\n\tint abs = -1;\n\n\twhile (!ts->stopped) {\n\n\t\t \n\t\tif (ts->touch_ind_mode) {\n\t\t\tif (gpiod_get_value_cansleep(ts->gpio_int) == 0) {\n\t\t\t\tinput_mt_sync(ts->input);\n\t\t\t\tinput_report_key(ts->input, BTN_TOUCH, 0);\n\t\t\t\tinput_sync(ts->input);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret = auo_pixcir_collect_data(ts, point);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tif (!ts->touch_ind_mode)\n\t\t\t\tbreak;\n\n\t\t\twait_event_timeout(ts->wait, ts->stopped,\n\t\t\t\tmsecs_to_jiffies(AUO_PIXCIR_PENUP_TIMEOUT_MS));\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < AUO_PIXCIR_REPORT_POINTS; i++) {\n\t\t\tif (point[i].coord_x > 0 || point[i].coord_y > 0) {\n\t\t\t\tinput_report_abs(ts->input, ABS_MT_POSITION_X,\n\t\t\t\t\t\t point[i].coord_x);\n\t\t\t\tinput_report_abs(ts->input, ABS_MT_POSITION_Y,\n\t\t\t\t\t\t point[i].coord_y);\n\t\t\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t\t\t point[i].area_major);\n\t\t\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MINOR,\n\t\t\t\t\t\t point[i].area_minor);\n\t\t\t\tinput_report_abs(ts->input, ABS_MT_ORIENTATION,\n\t\t\t\t\t\t point[i].orientation);\n\t\t\t\tinput_mt_sync(ts->input);\n\n\t\t\t\t \n\t\t\t\tif (fingers == 0)\n\t\t\t\t\tabs = i;\n\n\t\t\t\t \n\t\t\t\tfingers++;\n\t\t\t}\n\t\t}\n\n\t\tinput_report_key(ts->input, BTN_TOUCH, fingers > 0);\n\n\t\tif (abs > -1) {\n\t\t\tinput_report_abs(ts->input, ABS_X, point[abs].coord_x);\n\t\t\tinput_report_abs(ts->input, ABS_Y, point[abs].coord_y);\n\t\t}\n\n\t\tinput_sync(ts->input);\n\n\t\t \n\t\tif (!ts->touch_ind_mode)\n\t\t\tbreak;\n\n\t\twait_event_timeout(ts->wait, ts->stopped,\n\t\t\t\t msecs_to_jiffies(AUO_PIXCIR_PENUP_TIMEOUT_MS));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int auo_pixcir_power_mode(struct auo_pixcir_ts *ts, int mode)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_POWER_MODE);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to read reg %Xh, %d\\n\",\n\t\t\tAUO_PIXCIR_REG_POWER_MODE, ret);\n\t\treturn ret;\n\t}\n\n\tret &= ~AUO_PIXCIR_POWER_MASK;\n\tret |= mode;\n\n\tret = i2c_smbus_write_byte_data(client, AUO_PIXCIR_REG_POWER_MODE, ret);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to write reg %Xh, %d\\n\",\n\t\t\tAUO_PIXCIR_REG_POWER_MODE, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int auo_pixcir_int_config(struct auo_pixcir_ts *ts, int int_setting)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_INT_SETTING);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to read reg %Xh, %d\\n\",\n\t\t\tAUO_PIXCIR_REG_INT_SETTING, ret);\n\t\treturn ret;\n\t}\n\n\tret &= ~AUO_PIXCIR_INT_MODE_MASK;\n\tret |= int_setting;\n\tret |= AUO_PIXCIR_INT_POL_HIGH;  \n\n\tret = i2c_smbus_write_byte_data(client, AUO_PIXCIR_REG_INT_SETTING,\n\t\t\t\t\tret);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to write reg %Xh, %d\\n\",\n\t\t\tAUO_PIXCIR_REG_INT_SETTING, ret);\n\t\treturn ret;\n\t}\n\n\tts->touch_ind_mode = int_setting == AUO_PIXCIR_INT_TOUCH_IND;\n\n\treturn 0;\n}\n\n \nstatic int auo_pixcir_int_toggle(struct auo_pixcir_ts *ts, bool enable)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_INT_SETTING);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to read reg %Xh, %d\\n\",\n\t\t\tAUO_PIXCIR_REG_INT_SETTING, ret);\n\t\treturn ret;\n\t}\n\n\tif (enable)\n\t\tret |= AUO_PIXCIR_INT_ENABLE;\n\telse\n\t\tret &= ~AUO_PIXCIR_INT_ENABLE;\n\n\tret = i2c_smbus_write_byte_data(client, AUO_PIXCIR_REG_INT_SETTING,\n\t\t\t\t\tret);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"unable to write reg %Xh, %d\\n\",\n\t\t\tAUO_PIXCIR_REG_INT_SETTING, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int auo_pixcir_start(struct auo_pixcir_ts *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = auo_pixcir_power_mode(ts, AUO_PIXCIR_POWER_ACTIVE);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"could not set power mode, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tts->stopped = false;\n\tmb();\n\tenable_irq(client->irq);\n\n\tret = auo_pixcir_int_toggle(ts, 1);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"could not enable interrupt, %d\\n\",\n\t\t\tret);\n\t\tdisable_irq(client->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int auo_pixcir_stop(struct auo_pixcir_ts *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = auo_pixcir_int_toggle(ts, 0);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"could not disable interrupt, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tdisable_irq(client->irq);\n\tts->stopped = true;\n\tmb();\n\twake_up(&ts->wait);\n\n\treturn auo_pixcir_power_mode(ts, AUO_PIXCIR_POWER_DEEP_SLEEP);\n}\n\nstatic int auo_pixcir_input_open(struct input_dev *dev)\n{\n\tstruct auo_pixcir_ts *ts = input_get_drvdata(dev);\n\n\treturn auo_pixcir_start(ts);\n}\n\nstatic void auo_pixcir_input_close(struct input_dev *dev)\n{\n\tstruct auo_pixcir_ts *ts = input_get_drvdata(dev);\n\n\tauo_pixcir_stop(ts);\n}\n\nstatic int auo_pixcir_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct auo_pixcir_ts *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\tint ret = 0;\n\n\tmutex_lock(&input->mutex);\n\n\t \n\tif (device_may_wakeup(&client->dev)) {\n\t\t \n\t\tif (!input_device_enabled(input)) {\n\t\t\tret = auo_pixcir_start(ts);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tenable_irq_wake(client->irq);\n\t\tret = auo_pixcir_power_mode(ts, AUO_PIXCIR_POWER_SLEEP);\n\t} else if (input_device_enabled(input)) {\n\t\tret = auo_pixcir_stop(ts);\n\t}\n\nunlock:\n\tmutex_unlock(&input->mutex);\n\n\treturn ret;\n}\n\nstatic int auo_pixcir_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct auo_pixcir_ts *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\tint ret = 0;\n\n\tmutex_lock(&input->mutex);\n\n\tif (device_may_wakeup(&client->dev)) {\n\t\tdisable_irq_wake(client->irq);\n\n\t\t \n\t\tif (!input_device_enabled(input)) {\n\t\t\tret = auo_pixcir_stop(ts);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t} else if (input_device_enabled(input)) {\n\t\tret = auo_pixcir_start(ts);\n\t}\n\nunlock:\n\tmutex_unlock(&input->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(auo_pixcir_pm_ops,\n\t\t\t\tauo_pixcir_suspend, auo_pixcir_resume);\n\nstatic void auo_pixcir_reset(void *data)\n{\n\tstruct auo_pixcir_ts *ts = data;\n\n\tgpiod_set_value_cansleep(ts->gpio_rst, 1);\n}\n\nstatic int auo_pixcir_probe(struct i2c_client *client)\n{\n\tstruct auo_pixcir_ts *ts;\n\tstruct input_dev *input_dev;\n\tint version;\n\tint error;\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"could not allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->client = client;\n\tts->input = input_dev;\n\tts->touch_ind_mode = 0;\n\tts->stopped = true;\n\tinit_waitqueue_head(&ts->wait);\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t \"%s/input0\", dev_name(&client->dev));\n\n\tif (device_property_read_u32(&client->dev, \"x-size\", &ts->x_max)) {\n\t\tdev_err(&client->dev, \"failed to get x-size property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(&client->dev, \"y-size\", &ts->y_max)) {\n\t\tdev_err(&client->dev, \"failed to get y-size property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinput_dev->name = \"AUO-Pixcir touchscreen\";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->id.bustype = BUS_I2C;\n\n\tinput_dev->open = auo_pixcir_input_open;\n\tinput_dev->close = auo_pixcir_input_close;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_X, 0, ts->x_max, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, ts->y_max, 0, 0);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, ts->x_max, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, ts->y_max, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, AUO_PIXCIR_MAX_AREA, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,\n\t\t\t     0, AUO_PIXCIR_MAX_AREA, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\n\n\tinput_set_drvdata(ts->input, ts);\n\n\tts->gpio_int = devm_gpiod_get_index(&client->dev, NULL, 0, GPIOD_IN);\n\terror = PTR_ERR_OR_ZERO(ts->gpio_int);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"request of int gpio failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tgpiod_set_consumer_name(ts->gpio_int, \"auo_pixcir_ts_int\");\n\n\t \n\tts->gpio_rst = devm_gpiod_get_index(&client->dev, NULL, 1,\n\t\t\t\t\t    GPIOD_OUT_LOW);\n\terror = PTR_ERR_OR_ZERO(ts->gpio_rst);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"request of reset gpio failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tgpiod_set_consumer_name(ts->gpio_rst, \"auo_pixcir_ts_rst\");\n\n\terror = devm_add_action_or_reset(&client->dev, auo_pixcir_reset, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to register reset action, %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tmsleep(200);\n\n\tversion = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_VERSION);\n\tif (version < 0) {\n\t\terror = version;\n\t\treturn error;\n\t}\n\n\tdev_info(&client->dev, \"firmware version 0x%X\\n\", version);\n\n\t \n\terror = auo_pixcir_int_config(ts, AUO_PIXCIR_INT_TOUCH_IND);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, auo_pixcir_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  input_dev->name, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"irq %d requested failed, %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\t \n\terror = auo_pixcir_stop(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"could not register input device, %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, ts);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id auo_pixcir_idtable[] = {\n\t{ \"auo_pixcir_ts\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, auo_pixcir_idtable);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id auo_pixcir_ts_dt_idtable[] = {\n\t{ .compatible = \"auo,auo_pixcir_ts\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, auo_pixcir_ts_dt_idtable);\n#endif\n\nstatic struct i2c_driver auo_pixcir_driver = {\n\t.driver = {\n\t\t.name\t= \"auo_pixcir_ts\",\n\t\t.pm\t= pm_sleep_ptr(&auo_pixcir_pm_ops),\n\t\t.of_match_table\t= of_match_ptr(auo_pixcir_ts_dt_idtable),\n\t},\n\t.probe\t\t= auo_pixcir_probe,\n\t.id_table\t= auo_pixcir_idtable,\n};\n\nmodule_i2c_driver(auo_pixcir_driver);\n\nMODULE_DESCRIPTION(\"AUO-PIXCIR touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Heiko Stuebner <heiko@sntech.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}