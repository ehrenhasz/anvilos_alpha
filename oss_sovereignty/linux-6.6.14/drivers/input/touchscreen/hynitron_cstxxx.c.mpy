{
  "module_name": "hynitron_cstxxx.c",
  "hash_id": "7ee6c58407cd7ccbfd40a7625d4b99c32c6ed720ce3d6c0d6945ed79fb68ca3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/hynitron_cstxxx.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <asm/unaligned.h>\n\n \nstruct hynitron_ts_chip_data {\n\tunsigned int max_touch_num;\n\tu32 ic_chkcode;\n\tint (*firmware_info)(struct i2c_client *client);\n\tint (*bootloader_enter)(struct i2c_client *client);\n\tint (*init_input)(struct i2c_client *client);\n\tvoid (*report_touch)(struct i2c_client *client);\n};\n\n \nstruct hynitron_ts_data {\n\tconst struct hynitron_ts_chip_data *chip;\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct touchscreen_properties prop;\n\tstruct gpio_desc *reset_gpio;\n};\n\n \n#define CST3XX_FIRMWARE_INFO_START_CMD\t\t0x01d1\n#define CST3XX_FIRMWARE_INFO_END_CMD\t\t0x09d1\n#define CST3XX_FIRMWARE_CHK_CODE_REG\t\t0xfcd1\n#define CST3XX_FIRMWARE_VERSION_REG\t\t0x08d2\n#define CST3XX_FIRMWARE_VER_INVALID_VAL\t\t0xa5a5a5a5\n\n#define CST3XX_BOOTLDR_PROG_CMD\t\t\t0xaa01a0\n#define CST3XX_BOOTLDR_PROG_CHK_REG\t\t0x02a0\n#define CST3XX_BOOTLDR_CHK_VAL\t\t\t0xac\n\n#define CST3XX_TOUCH_DATA_PART_REG\t\t0x00d0\n#define CST3XX_TOUCH_DATA_FULL_REG\t\t0x07d0\n#define CST3XX_TOUCH_DATA_CHK_VAL\t\t0xab\n#define CST3XX_TOUCH_DATA_TOUCH_VAL\t\t0x03\n#define CST3XX_TOUCH_DATA_STOP_CMD\t\t0xab00d0\n#define CST3XX_TOUCH_COUNT_MASK\t\t\tGENMASK(6, 0)\n\n\n \nstatic void hyn_reset_proc(struct i2c_client *client, int delay)\n{\n\tstruct hynitron_ts_data *ts_data = i2c_get_clientdata(client);\n\n\tgpiod_set_value_cansleep(ts_data->reset_gpio, 1);\n\tmsleep(20);\n\tgpiod_set_value_cansleep(ts_data->reset_gpio, 0);\n\tif (delay)\n\t\tfsleep(delay * 1000);\n}\n\nstatic irqreturn_t hyn_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct i2c_client *client = dev_id;\n\tstruct hynitron_ts_data *ts_data = i2c_get_clientdata(client);\n\n\tts_data->chip->report_touch(client);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int cst3xx_i2c_write(struct i2c_client *client,\n\t\t\t    unsigned char *buf, int len)\n{\n\tint ret;\n\tint retries = 0;\n\n\twhile (retries < 2) {\n\t\tret = i2c_master_send(client, buf, len);\n\t\tif (ret == len)\n\t\t\treturn 0;\n\t\tif (ret <= 0)\n\t\t\tretries++;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn ret < 0 ? ret : -EIO;\n}\n\nstatic int cst3xx_i2c_read_register(struct i2c_client *client, u16 reg,\n\t\t\t\t    u8 *val, u16 len)\n{\n\t__le16 buf = cpu_to_le16(reg);\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 2,\n\t\t\t.buf = (u8 *)&buf,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = val,\n\t\t}\n\t};\n\tint err;\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret == ARRAY_SIZE(msgs))\n\t\treturn 0;\n\n\terr = ret < 0 ? ret : -EIO;\n\tdev_err(&client->dev, \"Error reading %d bytes from 0x%04x: %d (%d)\\n\",\n\t\tlen, reg, err, ret);\n\n\treturn err;\n}\n\nstatic int cst3xx_firmware_info(struct i2c_client *client)\n{\n\tstruct hynitron_ts_data *ts_data = i2c_get_clientdata(client);\n\tint err;\n\tu32 tmp;\n\tunsigned char buf[4];\n\n\t \n\tput_unaligned_le16(CST3XX_FIRMWARE_INFO_START_CMD, buf);\n\terr = cst3xx_i2c_write(client, buf, 2);\n\tif (err)\n\t\treturn err;\n\n\tusleep_range(10000, 11000);\n\n\t \n\terr = cst3xx_i2c_read_register(client, CST3XX_FIRMWARE_CHK_CODE_REG,\n\t\t\t\t       buf, 4);\n\tif (err)\n\t\treturn err;\n\n\ttmp = get_unaligned_le32(buf);\n\tif ((tmp & 0xffff0000) != ts_data->chip->ic_chkcode) {\n\t\tdev_err(&client->dev, \"%s ic mismatch, chkcode is %u\\n\",\n\t\t\t__func__, tmp);\n\t\treturn -ENODEV;\n\t}\n\n\tusleep_range(10000, 11000);\n\n\t \n\terr = cst3xx_i2c_read_register(client, CST3XX_FIRMWARE_VERSION_REG,\n\t\t\t\t       buf, 4);\n\tif (err)\n\t\treturn err;\n\n\ttmp = get_unaligned_le32(buf);\n\tif (tmp == CST3XX_FIRMWARE_VER_INVALID_VAL) {\n\t\tdev_err(&client->dev, \"Device firmware missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tput_unaligned_le16(CST3XX_FIRMWARE_INFO_END_CMD, buf);\n\terr = cst3xx_i2c_write(client, buf, 2);\n\tif (err)\n\t\treturn err;\n\n\tusleep_range(5000, 6000);\n\n\treturn 0;\n}\n\nstatic int cst3xx_bootloader_enter(struct i2c_client *client)\n{\n\tint err;\n\tu8 retry;\n\tu32 tmp = 0;\n\tunsigned char buf[3];\n\n\tfor (retry = 0; retry < 5; retry++) {\n\t\thyn_reset_proc(client, (7 + retry));\n\t\t \n\t\tput_unaligned_le24(CST3XX_BOOTLDR_PROG_CMD, buf);\n\t\terr = cst3xx_i2c_write(client, buf, 3);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tusleep_range(2000, 2500);\n\n\t\t \n\t\terr = cst3xx_i2c_read_register(client,\n\t\t\t\t\t       CST3XX_BOOTLDR_PROG_CHK_REG,\n\t\t\t\t\t       buf, 1);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\ttmp = get_unaligned(buf);\n\t\tif (tmp == CST3XX_BOOTLDR_CHK_VAL)\n\t\t\tbreak;\n\t}\n\n\tif (tmp != CST3XX_BOOTLDR_CHK_VAL) {\n\t\tdev_err(&client->dev, \"%s unable to enter bootloader mode\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\thyn_reset_proc(client, 40);\n\n\treturn 0;\n}\n\nstatic void cst3xx_report_contact(struct hynitron_ts_data *ts_data,\n\t\t\t\t  u8 id, unsigned int x, unsigned int y, u8 w)\n{\n\tinput_mt_slot(ts_data->input_dev, id);\n\tinput_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER, 1);\n\ttouchscreen_report_pos(ts_data->input_dev, &ts_data->prop, x, y, true);\n\tinput_report_abs(ts_data->input_dev, ABS_MT_TOUCH_MAJOR, w);\n}\n\nstatic int cst3xx_finish_touch_read(struct i2c_client *client)\n{\n\tunsigned char buf[3];\n\tint err;\n\n\tput_unaligned_le24(CST3XX_TOUCH_DATA_STOP_CMD, buf);\n\terr = cst3xx_i2c_write(client, buf, 3);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"send read touch info ending failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cst3xx_touch_report(struct i2c_client *client)\n{\n\tstruct hynitron_ts_data *ts_data = i2c_get_clientdata(client);\n\tu8 buf[28];\n\tu8 finger_id, sw, w;\n\tunsigned int x, y;\n\tunsigned int touch_cnt, end_byte;\n\tunsigned int idx = 0;\n\tunsigned int i;\n\tint err;\n\n\t \n\terr = cst3xx_i2c_read_register(client, CST3XX_TOUCH_DATA_PART_REG,\n\t\t\t\t       buf, 28);\n\tif (err ||\n\t    buf[6] != CST3XX_TOUCH_DATA_CHK_VAL ||\n\t    buf[0] == CST3XX_TOUCH_DATA_CHK_VAL) {\n\t\tdev_err(&client->dev, \"cst3xx touch read failure\\n\");\n\t\treturn;\n\t}\n\n\t \n\terr = cst3xx_finish_touch_read(client);\n\tif (err)\n\t\treturn;\n\n\ttouch_cnt = buf[5] & CST3XX_TOUCH_COUNT_MASK;\n\t \n\tif (touch_cnt > 1) {\n\t\tend_byte = touch_cnt * 5 + 2;\n\t\tif (buf[end_byte] != CST3XX_TOUCH_DATA_CHK_VAL) {\n\t\t\tdev_err(&client->dev, \"cst3xx touch read failure\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < touch_cnt; i++) {\n\t\tx = ((buf[idx + 1] << 4) | ((buf[idx + 3] >> 4) & 0x0f));\n\t\ty = ((buf[idx + 2] << 4) | (buf[idx + 3] & 0x0f));\n\t\tw = (buf[idx + 4] >> 3);\n\t\tsw = (buf[idx] & 0x0f) >> 1;\n\t\tfinger_id = (buf[idx] >> 4) & 0x0f;\n\n\t\t \n\t\tif (ts_data->chip->max_touch_num < finger_id) {\n\t\t\tdev_err(&client->dev, \"cst3xx touch read failure\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (sw == CST3XX_TOUCH_DATA_TOUCH_VAL)\n\t\t\tcst3xx_report_contact(ts_data, finger_id, x, y, w);\n\n\t\tidx += 5;\n\n\t\t \n\t\tif (i == 0)\n\t\t\tidx += 2;\n\t}\n\n\tinput_mt_sync_frame(ts_data->input_dev);\n\tinput_sync(ts_data->input_dev);\n}\n\nstatic int cst3xx_input_dev_int(struct i2c_client *client)\n{\n\tstruct hynitron_ts_data *ts_data = i2c_get_clientdata(client);\n\tint err;\n\n\tts_data->input_dev = devm_input_allocate_device(&client->dev);\n\tif (!ts_data->input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts_data->input_dev->name = \"Hynitron cst3xx Touchscreen\";\n\tts_data->input_dev->phys = \"input/ts\";\n\tts_data->input_dev->id.bustype = BUS_I2C;\n\n\tinput_set_drvdata(ts_data->input_dev, ts_data);\n\n\tinput_set_capability(ts_data->input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(ts_data->input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(ts_data->input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, 255, 0, 0);\n\n\ttouchscreen_parse_properties(ts_data->input_dev, true, &ts_data->prop);\n\n\tif (!ts_data->prop.max_x || !ts_data->prop.max_y) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Invalid x/y (%d, %d), using defaults\\n\",\n\t\t\tts_data->prop.max_x, ts_data->prop.max_y);\n\t\tts_data->prop.max_x = 1152;\n\t\tts_data->prop.max_y = 1920;\n\t\tinput_abs_set_max(ts_data->input_dev,\n\t\t\t\t  ABS_MT_POSITION_X, ts_data->prop.max_x);\n\t\tinput_abs_set_max(ts_data->input_dev,\n\t\t\t\t  ABS_MT_POSITION_Y, ts_data->prop.max_y);\n\t}\n\n\terr = input_mt_init_slots(ts_data->input_dev,\n\t\t\t\t  ts_data->chip->max_touch_num,\n\t\t\t\t  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to initialize input slots: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = input_register_device(ts_data->input_dev);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Input device registration failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int hyn_probe(struct i2c_client *client)\n{\n\tstruct hynitron_ts_data *ts_data;\n\tint err;\n\n\tts_data = devm_kzalloc(&client->dev, sizeof(*ts_data), GFP_KERNEL);\n\tif (!ts_data)\n\t\treturn -ENOMEM;\n\n\tts_data->client = client;\n\ti2c_set_clientdata(client, ts_data);\n\n\tts_data->chip = device_get_match_data(&client->dev);\n\tif (!ts_data->chip)\n\t\treturn -EINVAL;\n\n\tts_data->reset_gpio = devm_gpiod_get(&client->dev,\n\t\t\t\t\t     \"reset\", GPIOD_OUT_LOW);\n\terr = PTR_ERR_OR_ZERO(ts_data->reset_gpio);\n\tif (err) {\n\t\tdev_err(&client->dev, \"request reset gpio failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thyn_reset_proc(client, 60);\n\n\terr = ts_data->chip->bootloader_enter(client);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ts_data->chip->init_input(client);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ts_data->chip->firmware_info(client);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, hyn_interrupt_handler,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"Hynitron Touch Int\", client);\n\tif (err) {\n\t\tdev_err(&client->dev, \"failed to request IRQ: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hynitron_ts_chip_data cst3xx_data = {\n\t.max_touch_num\t\t= 5,\n\t.ic_chkcode\t\t= 0xcaca0000,\n\t.firmware_info\t\t= &cst3xx_firmware_info,\n\t.bootloader_enter\t= &cst3xx_bootloader_enter,\n\t.init_input\t\t= &cst3xx_input_dev_int,\n\t.report_touch\t\t= &cst3xx_touch_report,\n};\n\nstatic const struct i2c_device_id hyn_tpd_id[] = {\n\t{ .name = \"hynitron_ts\", 0 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(i2c, hyn_tpd_id);\n\nstatic const struct of_device_id hyn_dt_match[] = {\n\t{ .compatible = \"hynitron,cst340\", .data = &cst3xx_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, hyn_dt_match);\n\nstatic struct i2c_driver hynitron_i2c_driver = {\n\t.driver = {\n\t\t.name = \"Hynitron-TS\",\n\t\t.of_match_table = hyn_dt_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table = hyn_tpd_id,\n\t.probe = hyn_probe,\n};\n\nmodule_i2c_driver(hynitron_i2c_driver);\n\nMODULE_AUTHOR(\"Chris Morgan\");\nMODULE_DESCRIPTION(\"Hynitron Touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}