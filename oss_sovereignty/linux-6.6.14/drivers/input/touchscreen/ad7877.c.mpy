{
  "module_name": "ad7877.c",
  "hash_id": "867b8971afff2f7020d0a26f3604293f9f62fd2a9b5c94dc88f1d5f7dee20fd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ad7877.c",
  "human_readable_source": "\n \n\n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/ad7877.h>\n#include <linux/module.h>\n#include <asm/irq.h>\n\n#define\tTS_PEN_UP_TIMEOUT\tmsecs_to_jiffies(100)\n\n#define MAX_SPI_FREQ_HZ\t\t\t20000000\n#define\tMAX_12BIT\t\t\t((1<<12)-1)\n\n#define AD7877_REG_ZEROS\t\t\t0\n#define AD7877_REG_CTRL1\t\t\t1\n#define AD7877_REG_CTRL2\t\t\t2\n#define AD7877_REG_ALERT\t\t\t3\n#define AD7877_REG_AUX1HIGH\t\t\t4\n#define AD7877_REG_AUX1LOW\t\t\t5\n#define AD7877_REG_BAT1HIGH\t\t\t6\n#define AD7877_REG_BAT1LOW\t\t\t7\n#define AD7877_REG_BAT2HIGH\t\t\t8\n#define AD7877_REG_BAT2LOW\t\t\t9\n#define AD7877_REG_TEMP1HIGH\t\t\t10\n#define AD7877_REG_TEMP1LOW\t\t\t11\n#define AD7877_REG_SEQ0\t\t\t\t12\n#define AD7877_REG_SEQ1\t\t\t\t13\n#define AD7877_REG_DAC\t\t\t\t14\n#define AD7877_REG_NONE1\t\t\t15\n#define AD7877_REG_EXTWRITE\t\t\t15\n#define AD7877_REG_XPLUS\t\t\t16\n#define AD7877_REG_YPLUS\t\t\t17\n#define AD7877_REG_Z2\t\t\t\t18\n#define AD7877_REG_aux1\t\t\t\t19\n#define AD7877_REG_aux2\t\t\t\t20\n#define AD7877_REG_aux3\t\t\t\t21\n#define AD7877_REG_bat1\t\t\t\t22\n#define AD7877_REG_bat2\t\t\t\t23\n#define AD7877_REG_temp1\t\t\t24\n#define AD7877_REG_temp2\t\t\t25\n#define AD7877_REG_Z1\t\t\t\t26\n#define AD7877_REG_GPIOCTRL1\t\t\t27\n#define AD7877_REG_GPIOCTRL2\t\t\t28\n#define AD7877_REG_GPIODATA\t\t\t29\n#define AD7877_REG_NONE2\t\t\t30\n#define AD7877_REG_NONE3\t\t\t31\n\n#define AD7877_SEQ_YPLUS_BIT\t\t\t(1<<11)\n#define AD7877_SEQ_XPLUS_BIT\t\t\t(1<<10)\n#define AD7877_SEQ_Z2_BIT\t\t\t(1<<9)\n#define AD7877_SEQ_AUX1_BIT\t\t\t(1<<8)\n#define AD7877_SEQ_AUX2_BIT\t\t\t(1<<7)\n#define AD7877_SEQ_AUX3_BIT\t\t\t(1<<6)\n#define AD7877_SEQ_BAT1_BIT\t\t\t(1<<5)\n#define AD7877_SEQ_BAT2_BIT\t\t\t(1<<4)\n#define AD7877_SEQ_TEMP1_BIT\t\t\t(1<<3)\n#define AD7877_SEQ_TEMP2_BIT\t\t\t(1<<2)\n#define AD7877_SEQ_Z1_BIT\t\t\t(1<<1)\n\nenum {\n\tAD7877_SEQ_YPOS  = 0,\n\tAD7877_SEQ_XPOS  = 1,\n\tAD7877_SEQ_Z2    = 2,\n\tAD7877_SEQ_AUX1  = 3,\n\tAD7877_SEQ_AUX2  = 4,\n\tAD7877_SEQ_AUX3  = 5,\n\tAD7877_SEQ_BAT1  = 6,\n\tAD7877_SEQ_BAT2  = 7,\n\tAD7877_SEQ_TEMP1 = 8,\n\tAD7877_SEQ_TEMP2 = 9,\n\tAD7877_SEQ_Z1    = 10,\n\tAD7877_NR_SENSE  = 11,\n};\n\n \n#define AD7877_DAC_CONF\t\t\t0x1\n\n \n#define AD7877_EXTW_GPIO_3_CONF\t\t0x1C4\n#define AD7877_EXTW_GPIO_DATA\t\t0x200\n\n \n#define AD7877_TMR(x)\t\t\t((x & 0x3) << 0)\n#define AD7877_REF(x)\t\t\t((x & 0x1) << 2)\n#define AD7877_POL(x)\t\t\t((x & 0x1) << 3)\n#define AD7877_FCD(x)\t\t\t((x & 0x3) << 4)\n#define AD7877_PM(x)\t\t\t((x & 0x3) << 6)\n#define AD7877_ACQ(x)\t\t\t((x & 0x3) << 8)\n#define AD7877_AVG(x)\t\t\t((x & 0x3) << 10)\n\n \n#define\tAD7877_SER\t\t\t(1 << 11)\t \n#define\tAD7877_DFR\t\t\t(0 << 11)\t \n\n#define AD7877_MODE_NOC  (0)\t \n#define AD7877_MODE_SCC  (1)\t \n#define AD7877_MODE_SEQ0 (2)\t \n#define AD7877_MODE_SEQ1 (3)\t \n\n#define AD7877_CHANADD(x)\t\t((x&0xF)<<7)\n#define AD7877_READADD(x)\t\t((x)<<2)\n#define AD7877_WRITEADD(x)\t\t((x)<<12)\n\n#define AD7877_READ_CHAN(x) (AD7877_WRITEADD(AD7877_REG_CTRL1) | AD7877_SER | \\\n\t\tAD7877_MODE_SCC | AD7877_CHANADD(AD7877_REG_ ## x) | \\\n\t\tAD7877_READADD(AD7877_REG_ ## x))\n\n#define AD7877_MM_SEQUENCE (AD7877_SEQ_YPLUS_BIT | AD7877_SEQ_XPLUS_BIT | \\\n\t\tAD7877_SEQ_Z2_BIT | AD7877_SEQ_Z1_BIT)\n\n \n\nstruct ser_req {\n\tu16\t\t\treset;\n\tu16\t\t\tref_on;\n\tu16\t\t\tcommand;\n\tstruct spi_message\tmsg;\n\tstruct spi_transfer\txfer[6];\n\n\t \n\tu16 sample ____cacheline_aligned;\n};\n\nstruct ad7877 {\n\tstruct input_dev\t*input;\n\tchar\t\t\tphys[32];\n\n\tstruct spi_device\t*spi;\n\tu16\t\t\tmodel;\n\tu16\t\t\tvref_delay_usecs;\n\tu16\t\t\tx_plate_ohms;\n\tu16\t\t\tpressure_max;\n\n\tu16\t\t\tcmd_crtl1;\n\tu16\t\t\tcmd_crtl2;\n\tu16\t\t\tcmd_dummy;\n\tu16\t\t\tdac;\n\n\tu8\t\t\tstopacq_polarity;\n\tu8\t\t\tfirst_conversion_delay;\n\tu8\t\t\tacquisition_time;\n\tu8\t\t\taveraging;\n\tu8\t\t\tpen_down_acc_interval;\n\n\tstruct spi_transfer\txfer[AD7877_NR_SENSE + 2];\n\tstruct spi_message\tmsg;\n\n\tstruct mutex\t\tmutex;\n\tbool\t\t\tdisabled;\t \n\tbool\t\t\tgpio3;\t\t \n\tbool\t\t\tgpio4;\t\t \n\n\tspinlock_t\t\tlock;\n\tstruct timer_list\ttimer;\t\t \n\n\t \n\tu16 conversion_data[AD7877_NR_SENSE] ____cacheline_aligned;\n};\n\nstatic bool gpio3;\nmodule_param(gpio3, bool, 0);\nMODULE_PARM_DESC(gpio3, \"If gpio3 is set to 1 AUX3 acts as GPIO3\");\n\nstatic int ad7877_read(struct spi_device *spi, u16 reg)\n{\n\tstruct ser_req *req;\n\tint status, ret;\n\n\treq = kzalloc(sizeof *req, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tspi_message_init(&req->msg);\n\n\treq->command = (u16) (AD7877_WRITEADD(AD7877_REG_CTRL1) |\n\t\t\tAD7877_READADD(reg));\n\treq->xfer[0].tx_buf = &req->command;\n\treq->xfer[0].len = 2;\n\treq->xfer[0].cs_change = 1;\n\n\treq->xfer[1].rx_buf = &req->sample;\n\treq->xfer[1].len = 2;\n\n\tspi_message_add_tail(&req->xfer[0], &req->msg);\n\tspi_message_add_tail(&req->xfer[1], &req->msg);\n\n\tstatus = spi_sync(spi, &req->msg);\n\tret = status ? : req->sample;\n\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic int ad7877_write(struct spi_device *spi, u16 reg, u16 val)\n{\n\tstruct ser_req *req;\n\tint status;\n\n\treq = kzalloc(sizeof *req, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tspi_message_init(&req->msg);\n\n\treq->command = (u16) (AD7877_WRITEADD(reg) | (val & MAX_12BIT));\n\treq->xfer[0].tx_buf = &req->command;\n\treq->xfer[0].len = 2;\n\n\tspi_message_add_tail(&req->xfer[0], &req->msg);\n\n\tstatus = spi_sync(spi, &req->msg);\n\n\tkfree(req);\n\n\treturn status;\n}\n\nstatic int ad7877_read_adc(struct spi_device *spi, unsigned command)\n{\n\tstruct ad7877 *ts = spi_get_drvdata(spi);\n\tstruct ser_req *req;\n\tint status;\n\tint sample;\n\tint i;\n\n\treq = kzalloc(sizeof *req, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tspi_message_init(&req->msg);\n\n\t \n\treq->ref_on = AD7877_WRITEADD(AD7877_REG_CTRL2) |\n\t\t\t AD7877_POL(ts->stopacq_polarity) |\n\t\t\t AD7877_AVG(0) | AD7877_PM(2) | AD7877_TMR(0) |\n\t\t\t AD7877_ACQ(ts->acquisition_time) | AD7877_FCD(0);\n\n\treq->reset = AD7877_WRITEADD(AD7877_REG_CTRL1) | AD7877_MODE_NOC;\n\n\treq->command = (u16) command;\n\n\treq->xfer[0].tx_buf = &req->reset;\n\treq->xfer[0].len = 2;\n\treq->xfer[0].cs_change = 1;\n\n\treq->xfer[1].tx_buf = &req->ref_on;\n\treq->xfer[1].len = 2;\n\treq->xfer[1].delay.value = ts->vref_delay_usecs;\n\treq->xfer[1].delay.unit = SPI_DELAY_UNIT_USECS;\n\treq->xfer[1].cs_change = 1;\n\n\treq->xfer[2].tx_buf = &req->command;\n\treq->xfer[2].len = 2;\n\treq->xfer[2].delay.value = ts->vref_delay_usecs;\n\treq->xfer[2].delay.unit = SPI_DELAY_UNIT_USECS;\n\treq->xfer[2].cs_change = 1;\n\n\treq->xfer[3].rx_buf = &req->sample;\n\treq->xfer[3].len = 2;\n\treq->xfer[3].cs_change = 1;\n\n\treq->xfer[4].tx_buf = &ts->cmd_crtl2;\t \n\treq->xfer[4].len = 2;\n\treq->xfer[4].cs_change = 1;\n\n\treq->xfer[5].tx_buf = &ts->cmd_crtl1;\t \n\treq->xfer[5].len = 2;\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tspi_message_add_tail(&req->xfer[i], &req->msg);\n\n\tstatus = spi_sync(spi, &req->msg);\n\tsample = req->sample;\n\n\tkfree(req);\n\n\treturn status ? : sample;\n}\n\nstatic int ad7877_process_data(struct ad7877 *ts)\n{\n\tstruct input_dev *input_dev = ts->input;\n\tunsigned Rt;\n\tu16 x, y, z1, z2;\n\n\tx = ts->conversion_data[AD7877_SEQ_XPOS] & MAX_12BIT;\n\ty = ts->conversion_data[AD7877_SEQ_YPOS] & MAX_12BIT;\n\tz1 = ts->conversion_data[AD7877_SEQ_Z1] & MAX_12BIT;\n\tz2 = ts->conversion_data[AD7877_SEQ_Z2] & MAX_12BIT;\n\n\t \n\n\tif (likely(x && z1)) {\n\t\t \n\t\tRt = (z2 - z1) * x * ts->x_plate_ohms;\n\t\tRt /= z1;\n\t\tRt = (Rt + 2047) >> 12;\n\n\t\t \n\t\tif (Rt > ts->pressure_max)\n\t\t\treturn -EINVAL;\n\n\t\tif (!timer_pending(&ts->timer))\n\t\t\tinput_report_key(input_dev, BTN_TOUCH, 1);\n\n\t\tinput_report_abs(input_dev, ABS_X, x);\n\t\tinput_report_abs(input_dev, ABS_Y, y);\n\t\tinput_report_abs(input_dev, ABS_PRESSURE, Rt);\n\t\tinput_sync(input_dev);\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline void ad7877_ts_event_release(struct ad7877 *ts)\n{\n\tstruct input_dev *input_dev = ts->input;\n\n\tinput_report_abs(input_dev, ABS_PRESSURE, 0);\n\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\tinput_sync(input_dev);\n}\n\nstatic void ad7877_timer(struct timer_list *t)\n{\n\tstruct ad7877 *ts = from_timer(ts, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ts->lock, flags);\n\tad7877_ts_event_release(ts);\n\tspin_unlock_irqrestore(&ts->lock, flags);\n}\n\nstatic irqreturn_t ad7877_irq(int irq, void *handle)\n{\n\tstruct ad7877 *ts = handle;\n\tunsigned long flags;\n\tint error;\n\n\terror = spi_sync(ts->spi, &ts->msg);\n\tif (error) {\n\t\tdev_err(&ts->spi->dev, \"spi_sync --> %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ts->lock, flags);\n\terror = ad7877_process_data(ts);\n\tif (!error)\n\t\tmod_timer(&ts->timer, jiffies + TS_PEN_UP_TIMEOUT);\n\tspin_unlock_irqrestore(&ts->lock, flags);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void ad7877_disable(void *data)\n{\n\tstruct ad7877 *ts = data;\n\n\tmutex_lock(&ts->mutex);\n\n\tif (!ts->disabled) {\n\t\tts->disabled = true;\n\t\tdisable_irq(ts->spi->irq);\n\n\t\tif (del_timer_sync(&ts->timer))\n\t\t\tad7877_ts_event_release(ts);\n\t}\n\n\t \n\n\tmutex_unlock(&ts->mutex);\n}\n\nstatic void ad7877_enable(struct ad7877 *ts)\n{\n\tmutex_lock(&ts->mutex);\n\n\tif (ts->disabled) {\n\t\tts->disabled = false;\n\t\tenable_irq(ts->spi->irq);\n\t}\n\n\tmutex_unlock(&ts->mutex);\n}\n\n#define SHOW(name) static ssize_t \\\nname ## _show(struct device *dev, struct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct ad7877 *ts = dev_get_drvdata(dev); \\\n\tssize_t v = ad7877_read_adc(ts->spi, \\\n\t\t\tAD7877_READ_CHAN(name)); \\\n\tif (v < 0) \\\n\t\treturn v; \\\n\treturn sprintf(buf, \"%u\\n\", (unsigned) v); \\\n} \\\nstatic DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);\n\nSHOW(aux1)\nSHOW(aux2)\nSHOW(aux3)\nSHOW(bat1)\nSHOW(bat2)\nSHOW(temp1)\nSHOW(temp2)\n\nstatic ssize_t ad7877_disable_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->disabled);\n}\n\nstatic ssize_t ad7877_disable_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tif (val)\n\t\tad7877_disable(ts);\n\telse\n\t\tad7877_enable(ts);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(disable, 0664, ad7877_disable_show, ad7877_disable_store);\n\nstatic ssize_t ad7877_dac_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->dac);\n}\n\nstatic ssize_t ad7877_dac_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ts->mutex);\n\tts->dac = val & 0xFF;\n\tad7877_write(ts->spi, AD7877_REG_DAC, (ts->dac << 4) | AD7877_DAC_CONF);\n\tmutex_unlock(&ts->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(dac, 0664, ad7877_dac_show, ad7877_dac_store);\n\nstatic ssize_t ad7877_gpio3_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->gpio3);\n}\n\nstatic ssize_t ad7877_gpio3_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ts->mutex);\n\tts->gpio3 = !!val;\n\tad7877_write(ts->spi, AD7877_REG_EXTWRITE, AD7877_EXTW_GPIO_DATA |\n\t\t (ts->gpio4 << 4) | (ts->gpio3 << 5));\n\tmutex_unlock(&ts->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(gpio3, 0664, ad7877_gpio3_show, ad7877_gpio3_store);\n\nstatic ssize_t ad7877_gpio4_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->gpio4);\n}\n\nstatic ssize_t ad7877_gpio4_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&ts->mutex);\n\tts->gpio4 = !!val;\n\tad7877_write(ts->spi, AD7877_REG_EXTWRITE, AD7877_EXTW_GPIO_DATA |\n\t\t     (ts->gpio4 << 4) | (ts->gpio3 << 5));\n\tmutex_unlock(&ts->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(gpio4, 0664, ad7877_gpio4_show, ad7877_gpio4_store);\n\nstatic struct attribute *ad7877_attributes[] = {\n\t&dev_attr_temp1.attr,\n\t&dev_attr_temp2.attr,\n\t&dev_attr_aux1.attr,\n\t&dev_attr_aux2.attr,\n\t&dev_attr_aux3.attr,\n\t&dev_attr_bat1.attr,\n\t&dev_attr_bat2.attr,\n\t&dev_attr_disable.attr,\n\t&dev_attr_dac.attr,\n\t&dev_attr_gpio3.attr,\n\t&dev_attr_gpio4.attr,\n\tNULL\n};\n\nstatic umode_t ad7877_attr_is_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int n)\n{\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_aux3.attr) {\n\t\tif (gpio3)\n\t\t\tmode = 0;\n\t} else if (attr == &dev_attr_gpio3.attr) {\n\t\tif (!gpio3)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct attribute_group ad7877_attr_group = {\n\t.is_visible\t= ad7877_attr_is_visible,\n\t.attrs\t\t= ad7877_attributes,\n};\n\nstatic void ad7877_setup_ts_def_msg(struct spi_device *spi, struct ad7877 *ts)\n{\n\tstruct spi_message *m;\n\tint i;\n\n\tts->cmd_crtl2 = AD7877_WRITEADD(AD7877_REG_CTRL2) |\n\t\t\tAD7877_POL(ts->stopacq_polarity) |\n\t\t\tAD7877_AVG(ts->averaging) | AD7877_PM(1) |\n\t\t\tAD7877_TMR(ts->pen_down_acc_interval) |\n\t\t\tAD7877_ACQ(ts->acquisition_time) |\n\t\t\tAD7877_FCD(ts->first_conversion_delay);\n\n\tad7877_write(spi, AD7877_REG_CTRL2, ts->cmd_crtl2);\n\n\tts->cmd_crtl1 = AD7877_WRITEADD(AD7877_REG_CTRL1) |\n\t\t\tAD7877_READADD(AD7877_REG_XPLUS-1) |\n\t\t\tAD7877_MODE_SEQ1 | AD7877_DFR;\n\n\tad7877_write(spi, AD7877_REG_CTRL1, ts->cmd_crtl1);\n\n\tts->cmd_dummy = 0;\n\n\tm = &ts->msg;\n\n\tspi_message_init(m);\n\n\tm->context = ts;\n\n\tts->xfer[0].tx_buf = &ts->cmd_crtl1;\n\tts->xfer[0].len = 2;\n\tts->xfer[0].cs_change = 1;\n\n\tspi_message_add_tail(&ts->xfer[0], m);\n\n\tts->xfer[1].tx_buf = &ts->cmd_dummy;  \n\tts->xfer[1].len = 2;\n\tts->xfer[1].cs_change = 1;\n\n\tspi_message_add_tail(&ts->xfer[1], m);\n\n\tfor (i = 0; i < AD7877_NR_SENSE; i++) {\n\t\tts->xfer[i + 2].rx_buf = &ts->conversion_data[AD7877_SEQ_YPOS + i];\n\t\tts->xfer[i + 2].len = 2;\n\t\tif (i < (AD7877_NR_SENSE - 1))\n\t\t\tts->xfer[i + 2].cs_change = 1;\n\t\tspi_message_add_tail(&ts->xfer[i + 2], m);\n\t}\n}\n\nstatic int ad7877_probe(struct spi_device *spi)\n{\n\tstruct ad7877\t\t\t*ts;\n\tstruct input_dev\t\t*input_dev;\n\tstruct ad7877_platform_data\t*pdata = dev_get_platdata(&spi->dev);\n\tint\t\t\t\terr;\n\tu16\t\t\t\tverify;\n\n\tif (!spi->irq) {\n\t\tdev_dbg(&spi->dev, \"no IRQ?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pdata) {\n\t\tdev_dbg(&spi->dev, \"no platform data?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (spi->max_speed_hz > MAX_SPI_FREQ_HZ) {\n\t\tdev_dbg(&spi->dev, \"SPI CLK %d Hz?\\n\",spi->max_speed_hz);\n\t\treturn -EINVAL;\n\t}\n\n\tspi->bits_per_word = 16;\n\terr = spi_setup(spi);\n\tif (err) {\n\t\tdev_dbg(&spi->dev, \"spi master doesn't support 16 bits/word\\n\");\n\t\treturn err;\n\t}\n\n\tts = devm_kzalloc(&spi->dev, sizeof(struct ad7877), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&spi->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\terr = devm_add_action_or_reset(&spi->dev, ad7877_disable, ts);\n\tif (err)\n\t\treturn err;\n\n\tspi_set_drvdata(spi, ts);\n\tts->spi = spi;\n\tts->input = input_dev;\n\n\ttimer_setup(&ts->timer, ad7877_timer, 0);\n\tmutex_init(&ts->mutex);\n\tspin_lock_init(&ts->lock);\n\n\tts->model = pdata->model ? : 7877;\n\tts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;\n\tts->x_plate_ohms = pdata->x_plate_ohms ? : 400;\n\tts->pressure_max = pdata->pressure_max ? : ~0;\n\n\tts->stopacq_polarity = pdata->stopacq_polarity;\n\tts->first_conversion_delay = pdata->first_conversion_delay;\n\tts->acquisition_time = pdata->acquisition_time;\n\tts->averaging = pdata->averaging;\n\tts->pen_down_acc_interval = pdata->pen_down_acc_interval;\n\n\tsnprintf(ts->phys, sizeof(ts->phys), \"%s/input0\", dev_name(&spi->dev));\n\n\tinput_dev->name = \"AD7877 Touchscreen\";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->dev.parent = &spi->dev;\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(ABS_X, input_dev->absbit);\n\t__set_bit(ABS_Y, input_dev->absbit);\n\t__set_bit(ABS_PRESSURE, input_dev->absbit);\n\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\tpdata->x_min ? : 0,\n\t\t\tpdata->x_max ? : MAX_12BIT,\n\t\t\t0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\tpdata->y_min ? : 0,\n\t\t\tpdata->y_max ? : MAX_12BIT,\n\t\t\t0, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE,\n\t\t\tpdata->pressure_min, pdata->pressure_max, 0, 0);\n\n\tad7877_write(spi, AD7877_REG_SEQ1, AD7877_MM_SEQUENCE);\n\n\tverify = ad7877_read(spi, AD7877_REG_SEQ1);\n\n\tif (verify != AD7877_MM_SEQUENCE) {\n\t\tdev_err(&spi->dev, \"%s: Failed to probe %s\\n\",\n\t\t\tdev_name(&spi->dev), input_dev->name);\n\t\treturn -ENODEV;\n\t}\n\n\tif (gpio3)\n\t\tad7877_write(spi, AD7877_REG_EXTWRITE, AD7877_EXTW_GPIO_3_CONF);\n\n\tad7877_setup_ts_def_msg(spi, ts);\n\n\t \n\n\terr = devm_request_threaded_irq(&spi->dev, spi->irq, NULL, ad7877_irq,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tspi->dev.driver->name, ts);\n\tif (err) {\n\t\tdev_dbg(&spi->dev, \"irq %d busy?\\n\", spi->irq);\n\t\treturn err;\n\t}\n\n\terr = devm_device_add_group(&spi->dev, &ad7877_attr_group);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ad7877_suspend(struct device *dev)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\n\tad7877_disable(ts);\n\n\treturn 0;\n}\n\nstatic int ad7877_resume(struct device *dev)\n{\n\tstruct ad7877 *ts = dev_get_drvdata(dev);\n\n\tad7877_enable(ts);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ad7877_pm, ad7877_suspend, ad7877_resume);\n\nstatic struct spi_driver ad7877_driver = {\n\t.driver = {\n\t\t.name\t= \"ad7877\",\n\t\t.pm\t= pm_sleep_ptr(&ad7877_pm),\n\t},\n\t.probe\t\t= ad7877_probe,\n};\n\nmodule_spi_driver(ad7877_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <hennerich@blackfin.uclinux.org>\");\nMODULE_DESCRIPTION(\"AD7877 touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:ad7877\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}