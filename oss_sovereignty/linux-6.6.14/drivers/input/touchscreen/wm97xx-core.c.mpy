{
  "module_name": "wm97xx-core.c",
  "hash_id": "aadb2a1fd846cf8b698d80cef437fd1ca78124aa4a59747b165432c7009906b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wm97xx-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/proc_fs.h>\n#include <linux/pm.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/mfd/wm97xx.h>\n#include <linux/workqueue.h>\n#include <linux/wm97xx.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#define TS_NAME\t\t\t\"wm97xx\"\n#define WM_CORE_VERSION\t\t\"1.00\"\n#define DEFAULT_PRESSURE\t0xb0c0\n\n\n \n\nstatic int abs_x[3] = {150, 4000, 5};\nmodule_param_array(abs_x, int, NULL, 0);\nMODULE_PARM_DESC(abs_x, \"Touchscreen absolute X min, max, fuzz\");\n\nstatic int abs_y[3] = {200, 4000, 40};\nmodule_param_array(abs_y, int, NULL, 0);\nMODULE_PARM_DESC(abs_y, \"Touchscreen absolute Y min, max, fuzz\");\n\nstatic int abs_p[3] = {0, 150, 4};\nmodule_param_array(abs_p, int, NULL, 0);\nMODULE_PARM_DESC(abs_p, \"Touchscreen absolute Pressure min, max, fuzz\");\n\n \nint wm97xx_reg_read(struct wm97xx *wm, u16 reg)\n{\n\tif (wm->ac97)\n\t\treturn wm->ac97->bus->ops->read(wm->ac97, reg);\n\telse\n\t\treturn -1;\n}\nEXPORT_SYMBOL_GPL(wm97xx_reg_read);\n\nvoid wm97xx_reg_write(struct wm97xx *wm, u16 reg, u16 val)\n{\n\t \n\tif (reg >= AC97_WM9713_DIG1 && reg <= AC97_WM9713_DIG3)\n\t\twm->dig[(reg - AC97_WM9713_DIG1) >> 1] = val;\n\n\t \n\tif (reg >= AC97_GPIO_CFG && reg <= AC97_MISC_AFE)\n\t\twm->gpio[(reg - AC97_GPIO_CFG) >> 1] = val;\n\n\t \n\tif (reg == 0x5a)\n\t\twm->misc = val;\n\n\tif (wm->ac97)\n\t\twm->ac97->bus->ops->write(wm->ac97, reg, val);\n}\nEXPORT_SYMBOL_GPL(wm97xx_reg_write);\n\n \n\nint wm97xx_read_aux_adc(struct wm97xx *wm, u16 adcsel)\n{\n\tint power_adc = 0, auxval;\n\tu16 power = 0;\n\tint rc = 0;\n\tint timeout = 0;\n\n\t \n\tmutex_lock(&wm->codec_mutex);\n\n\t \n\tif (wm->id == WM9713_ID2 &&\n\t    (power = wm97xx_reg_read(wm, AC97_EXTENDED_MID)) & 0x8000) {\n\t\tpower_adc = 1;\n\t\twm97xx_reg_write(wm, AC97_EXTENDED_MID, power & 0x7fff);\n\t}\n\n\t \n\twm->codec->aux_prepare(wm);\n\n\t \n\twm->pen_probably_down = 1;\n\n\twhile (rc != RC_VALID && timeout++ < 5)\n\t\trc = wm->codec->poll_sample(wm, adcsel, &auxval);\n\n\tif (power_adc)\n\t\twm97xx_reg_write(wm, AC97_EXTENDED_MID, power | 0x8000);\n\n\twm->codec->dig_restore(wm);\n\n\twm->pen_probably_down = 0;\n\n\tif (timeout >= 5) {\n\t\tdev_err(wm->dev,\n\t\t\t\"timeout reading auxadc %d, disabling digitiser\\n\",\n\t\t\tadcsel);\n\t\twm->codec->dig_enable(wm, false);\n\t}\n\n\tmutex_unlock(&wm->codec_mutex);\n\treturn (rc == RC_VALID ? auxval & 0xfff : -EBUSY);\n}\nEXPORT_SYMBOL_GPL(wm97xx_read_aux_adc);\n\n \n\nenum wm97xx_gpio_status wm97xx_get_gpio(struct wm97xx *wm, u32 gpio)\n{\n\tu16 status;\n\tenum wm97xx_gpio_status ret;\n\n\tmutex_lock(&wm->codec_mutex);\n\tstatus = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\n\n\tif (status & gpio)\n\t\tret = WM97XX_GPIO_HIGH;\n\telse\n\t\tret = WM97XX_GPIO_LOW;\n\n\tmutex_unlock(&wm->codec_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm97xx_get_gpio);\n\n \n\nvoid wm97xx_set_gpio(struct wm97xx *wm, u32 gpio,\n\t\t\t\tenum wm97xx_gpio_status status)\n{\n\tu16 reg;\n\n\tmutex_lock(&wm->codec_mutex);\n\treg = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\n\n\tif (status == WM97XX_GPIO_HIGH)\n\t\treg |= gpio;\n\telse\n\t\treg &= ~gpio;\n\n\tif (wm->id == WM9712_ID2 && wm->variant != WM97xx_WM1613)\n\t\twm97xx_reg_write(wm, AC97_GPIO_STATUS, reg << 1);\n\telse\n\t\twm97xx_reg_write(wm, AC97_GPIO_STATUS, reg);\n\tmutex_unlock(&wm->codec_mutex);\n}\nEXPORT_SYMBOL_GPL(wm97xx_set_gpio);\n\n \nvoid wm97xx_config_gpio(struct wm97xx *wm, u32 gpio, enum wm97xx_gpio_dir dir,\n\t\t   enum wm97xx_gpio_pol pol, enum wm97xx_gpio_sticky sticky,\n\t\t   enum wm97xx_gpio_wake wake)\n{\n\tu16 reg;\n\n\tmutex_lock(&wm->codec_mutex);\n\treg = wm97xx_reg_read(wm, AC97_GPIO_POLARITY);\n\n\tif (pol == WM97XX_GPIO_POL_HIGH)\n\t\treg |= gpio;\n\telse\n\t\treg &= ~gpio;\n\n\twm97xx_reg_write(wm, AC97_GPIO_POLARITY, reg);\n\treg = wm97xx_reg_read(wm, AC97_GPIO_STICKY);\n\n\tif (sticky == WM97XX_GPIO_STICKY)\n\t\treg |= gpio;\n\telse\n\t\treg &= ~gpio;\n\n\twm97xx_reg_write(wm, AC97_GPIO_STICKY, reg);\n\treg = wm97xx_reg_read(wm, AC97_GPIO_WAKEUP);\n\n\tif (wake == WM97XX_GPIO_WAKE)\n\t\treg |= gpio;\n\telse\n\t\treg &= ~gpio;\n\n\twm97xx_reg_write(wm, AC97_GPIO_WAKEUP, reg);\n\treg = wm97xx_reg_read(wm, AC97_GPIO_CFG);\n\n\tif (dir == WM97XX_GPIO_IN)\n\t\treg |= gpio;\n\telse\n\t\treg &= ~gpio;\n\n\twm97xx_reg_write(wm, AC97_GPIO_CFG, reg);\n\tmutex_unlock(&wm->codec_mutex);\n}\nEXPORT_SYMBOL_GPL(wm97xx_config_gpio);\n\n \nvoid wm97xx_set_suspend_mode(struct wm97xx *wm, u16 mode)\n{\n\twm->suspend_mode = mode;\n\tdevice_init_wakeup(&wm->input_dev->dev, mode != 0);\n}\nEXPORT_SYMBOL_GPL(wm97xx_set_suspend_mode);\n\n \nstatic irqreturn_t wm97xx_pen_interrupt(int irq, void *dev_id)\n{\n\tstruct wm97xx *wm = dev_id;\n\tint pen_was_down = wm->pen_is_down;\n\n\t \n\tif (wm->id == WM9705_ID2) {\n\t\tif (wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD) &\n\t\t\t\t\tWM97XX_PEN_DOWN)\n\t\t\twm->pen_is_down = 1;\n\t\telse\n\t\t\twm->pen_is_down = 0;\n\t} else {\n\t\tu16 status, pol;\n\t\tmutex_lock(&wm->codec_mutex);\n\t\tstatus = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\n\t\tpol = wm97xx_reg_read(wm, AC97_GPIO_POLARITY);\n\n\t\tif (WM97XX_GPIO_13 & pol & status) {\n\t\t\twm->pen_is_down = 1;\n\t\t\twm97xx_reg_write(wm, AC97_GPIO_POLARITY, pol &\n\t\t\t\t\t\t~WM97XX_GPIO_13);\n\t\t} else {\n\t\t\twm->pen_is_down = 0;\n\t\t\twm97xx_reg_write(wm, AC97_GPIO_POLARITY, pol |\n\t\t\t\t\t WM97XX_GPIO_13);\n\t\t}\n\n\t\tif (wm->id == WM9712_ID2 && wm->variant != WM97xx_WM1613)\n\t\t\twm97xx_reg_write(wm, AC97_GPIO_STATUS, (status &\n\t\t\t\t\t\t~WM97XX_GPIO_13) << 1);\n\t\telse\n\t\t\twm97xx_reg_write(wm, AC97_GPIO_STATUS, status &\n\t\t\t\t\t\t~WM97XX_GPIO_13);\n\t\tmutex_unlock(&wm->codec_mutex);\n\t}\n\n\t \n\tif (!wm->mach_ops->acc_enabled || wm->mach_ops->acc_pen_down) {\n\t\tif (wm->pen_is_down && !pen_was_down) {\n\t\t\t \n\t\t\tqueue_delayed_work(wm->ts_workq, &wm->ts_reader, 1);\n\t\t}\n\n\t\t \n\t\tif (!wm->pen_is_down && pen_was_down)\n\t\t\twm->pen_is_down = 1;\n\t}\n\n\tif (!wm->pen_is_down && wm->mach_ops->acc_enabled)\n\t\twm->mach_ops->acc_pen_up(wm);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int wm97xx_init_pen_irq(struct wm97xx *wm)\n{\n\tu16 reg;\n\n\tif (request_threaded_irq(wm->pen_irq, NULL, wm97xx_pen_interrupt,\n\t\t\t\t IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t \"wm97xx-pen\", wm)) {\n\t\tdev_err(wm->dev,\n\t\t\t\"Failed to register pen down interrupt, polling\");\n\t\twm->pen_irq = 0;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wm->id != WM9705_ID2) {\n\t\tBUG_ON(!wm->mach_ops->irq_gpio);\n\t\treg = wm97xx_reg_read(wm, AC97_MISC_AFE);\n\t\twm97xx_reg_write(wm, AC97_MISC_AFE,\n\t\t\t\treg & ~(wm->mach_ops->irq_gpio));\n\t\treg = wm97xx_reg_read(wm, 0x5a);\n\t\twm97xx_reg_write(wm, 0x5a, reg & ~0x0001);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm97xx_read_samples(struct wm97xx *wm)\n{\n\tstruct wm97xx_data data;\n\tint rc;\n\n\tmutex_lock(&wm->codec_mutex);\n\n\tif (wm->mach_ops && wm->mach_ops->acc_enabled)\n\t\trc = wm->mach_ops->acc_pen_down(wm);\n\telse\n\t\trc = wm->codec->poll_touch(wm, &data);\n\n\tif (rc & RC_PENUP) {\n\t\tif (wm->pen_is_down) {\n\t\t\twm->pen_is_down = 0;\n\t\t\tdev_dbg(wm->dev, \"pen up\\n\");\n\t\t\tinput_report_abs(wm->input_dev, ABS_PRESSURE, 0);\n\t\t\tinput_report_key(wm->input_dev, BTN_TOUCH, 0);\n\t\t\tinput_sync(wm->input_dev);\n\t\t} else if (!(rc & RC_AGAIN)) {\n\t\t\t \n\t\t\tif (wm->ts_reader_interval < HZ / 10)\n\t\t\t\twm->ts_reader_interval++;\n\t\t}\n\n\t} else if (rc & RC_VALID) {\n\t\tdev_dbg(wm->dev,\n\t\t\t\"pen down: x=%x:%d, y=%x:%d, pressure=%x:%d\\n\",\n\t\t\tdata.x >> 12, data.x & 0xfff, data.y >> 12,\n\t\t\tdata.y & 0xfff, data.p >> 12, data.p & 0xfff);\n\n\t\tif (abs_x[0] > (data.x & 0xfff) ||\n\t\t    abs_x[1] < (data.x & 0xfff) ||\n\t\t    abs_y[0] > (data.y & 0xfff) ||\n\t\t    abs_y[1] < (data.y & 0xfff)) {\n\t\t\tdev_dbg(wm->dev, \"Measurement out of range, dropping it\\n\");\n\t\t\trc = RC_AGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinput_report_abs(wm->input_dev, ABS_X, data.x & 0xfff);\n\t\tinput_report_abs(wm->input_dev, ABS_Y, data.y & 0xfff);\n\t\tinput_report_abs(wm->input_dev, ABS_PRESSURE, data.p & 0xfff);\n\t\tinput_report_key(wm->input_dev, BTN_TOUCH, 1);\n\t\tinput_sync(wm->input_dev);\n\t\twm->pen_is_down = 1;\n\t\twm->ts_reader_interval = wm->ts_reader_min_interval;\n\t} else if (rc & RC_PENDOWN) {\n\t\tdev_dbg(wm->dev, \"pen down\\n\");\n\t\twm->pen_is_down = 1;\n\t\twm->ts_reader_interval = wm->ts_reader_min_interval;\n\t}\n\nout:\n\tmutex_unlock(&wm->codec_mutex);\n\treturn rc;\n}\n\n \nstatic void wm97xx_ts_reader(struct work_struct *work)\n{\n\tint rc;\n\tstruct wm97xx *wm = container_of(work, struct wm97xx, ts_reader.work);\n\n\tBUG_ON(!wm->codec);\n\n\tdo {\n\t\trc = wm97xx_read_samples(wm);\n\t} while (rc & RC_AGAIN);\n\n\tif (wm->pen_is_down || !wm->pen_irq)\n\t\tqueue_delayed_work(wm->ts_workq, &wm->ts_reader,\n\t\t\t\t   wm->ts_reader_interval);\n}\n\n \nstatic int wm97xx_ts_input_open(struct input_dev *idev)\n{\n\tstruct wm97xx *wm = input_get_drvdata(idev);\n\n\twm->ts_workq = alloc_ordered_workqueue(\"kwm97xx\", 0);\n\tif (wm->ts_workq == NULL) {\n\t\tdev_err(wm->dev,\n\t\t\t\"Failed to create workqueue\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wm->mach_ops && wm->mach_ops->acc_enabled)\n\t\twm->codec->acc_enable(wm, 1);\n\twm->codec->dig_enable(wm, 1);\n\n\tINIT_DELAYED_WORK(&wm->ts_reader, wm97xx_ts_reader);\n\n\twm->ts_reader_min_interval = HZ >= 100 ? HZ / 100 : 1;\n\tif (wm->ts_reader_min_interval < 1)\n\t\twm->ts_reader_min_interval = 1;\n\twm->ts_reader_interval = wm->ts_reader_min_interval;\n\n\twm->pen_is_down = 0;\n\tif (wm->pen_irq)\n\t\twm97xx_init_pen_irq(wm);\n\telse\n\t\tdev_err(wm->dev, \"No IRQ specified\\n\");\n\n\t \n\tif (wm->pen_irq == 0)\n\t\tqueue_delayed_work(wm->ts_workq, &wm->ts_reader,\n\t\t\t\t   wm->ts_reader_interval);\n\n\treturn 0;\n}\n\n \n\nstatic void wm97xx_ts_input_close(struct input_dev *idev)\n{\n\tstruct wm97xx *wm = input_get_drvdata(idev);\n\tu16 reg;\n\n\tif (wm->pen_irq) {\n\t\t \n\t\tif (wm->id != WM9705_ID2) {\n\t\t\tBUG_ON(!wm->mach_ops->irq_gpio);\n\t\t\treg = wm97xx_reg_read(wm, AC97_MISC_AFE);\n\t\t\twm97xx_reg_write(wm, AC97_MISC_AFE,\n\t\t\t\t\t reg | wm->mach_ops->irq_gpio);\n\t\t}\n\n\t\tfree_irq(wm->pen_irq, wm);\n\t}\n\n\twm->pen_is_down = 0;\n\n\t \n\tcancel_delayed_work_sync(&wm->ts_reader);\n\n\tdestroy_workqueue(wm->ts_workq);\n\n\t \n\twm->codec->dig_enable(wm, 0);\n\tif (wm->mach_ops && wm->mach_ops->acc_enabled)\n\t\twm->codec->acc_enable(wm, 0);\n}\n\nstatic int wm97xx_register_touch(struct wm97xx *wm)\n{\n\tstruct wm97xx_pdata *pdata = dev_get_platdata(wm->dev);\n\tint ret;\n\n\twm->input_dev = devm_input_allocate_device(wm->dev);\n\tif (wm->input_dev == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\twm->input_dev->name = \"wm97xx touchscreen\";\n\twm->input_dev->phys = \"wm97xx\";\n\twm->input_dev->open = wm97xx_ts_input_open;\n\twm->input_dev->close = wm97xx_ts_input_close;\n\n\t__set_bit(EV_ABS, wm->input_dev->evbit);\n\t__set_bit(EV_KEY, wm->input_dev->evbit);\n\t__set_bit(BTN_TOUCH, wm->input_dev->keybit);\n\n\tinput_set_abs_params(wm->input_dev, ABS_X, abs_x[0], abs_x[1],\n\t\t\t     abs_x[2], 0);\n\tinput_set_abs_params(wm->input_dev, ABS_Y, abs_y[0], abs_y[1],\n\t\t\t     abs_y[2], 0);\n\tinput_set_abs_params(wm->input_dev, ABS_PRESSURE, abs_p[0], abs_p[1],\n\t\t\t     abs_p[2], 0);\n\n\tinput_set_drvdata(wm->input_dev, wm);\n\twm->input_dev->dev.parent = wm->dev;\n\n\tret = input_register_device(wm->input_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twm->touch_dev = platform_device_alloc(\"wm97xx-touch\", -1);\n\tif (!wm->touch_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(wm->touch_dev, wm);\n\twm->touch_dev->dev.parent = wm->dev;\n\twm->touch_dev->dev.platform_data = pdata;\n\tret = platform_device_add(wm->touch_dev);\n\tif (ret < 0)\n\t\tgoto touch_reg_err;\n\n\treturn 0;\ntouch_reg_err:\n\tplatform_device_put(wm->touch_dev);\n\n\treturn ret;\n}\n\nstatic void wm97xx_unregister_touch(struct wm97xx *wm)\n{\n\tplatform_device_unregister(wm->touch_dev);\n}\n\nstatic int _wm97xx_probe(struct wm97xx *wm)\n{\n\tint id = 0;\n\n\tmutex_init(&wm->codec_mutex);\n\tdev_set_drvdata(wm->dev, wm);\n\n\t \n\tid = wm97xx_reg_read(wm, AC97_VENDOR_ID1);\n\tif (id != WM97XX_ID1) {\n\t\tdev_err(wm->dev,\n\t\t\t\"Device with vendor %04x is not a wm97xx\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\twm->id = wm97xx_reg_read(wm, AC97_VENDOR_ID2);\n\n\twm->variant = WM97xx_GENERIC;\n\n\tdev_info(wm->dev, \"detected a wm97%02x codec\\n\", wm->id & 0xff);\n\n\tswitch (wm->id & 0xff) {\n#ifdef CONFIG_TOUCHSCREEN_WM9705\n\tcase 0x05:\n\t\twm->codec = &wm9705_codec;\n\t\tbreak;\n#endif\n#ifdef CONFIG_TOUCHSCREEN_WM9712\n\tcase 0x12:\n\t\twm->codec = &wm9712_codec;\n\t\tbreak;\n#endif\n#ifdef CONFIG_TOUCHSCREEN_WM9713\n\tcase 0x13:\n\t\twm->codec = &wm9713_codec;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_err(wm->dev, \"Support for wm97%02x not compiled in.\\n\",\n\t\t\twm->id & 0xff);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\twm->codec->phy_init(wm);\n\n\t \n\twm->gpio[0] = wm97xx_reg_read(wm, AC97_GPIO_CFG);\n\twm->gpio[1] = wm97xx_reg_read(wm, AC97_GPIO_POLARITY);\n\twm->gpio[2] = wm97xx_reg_read(wm, AC97_GPIO_STICKY);\n\twm->gpio[3] = wm97xx_reg_read(wm, AC97_GPIO_WAKEUP);\n\twm->gpio[4] = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\n\twm->gpio[5] = wm97xx_reg_read(wm, AC97_MISC_AFE);\n\n\treturn wm97xx_register_touch(wm);\n}\n\nstatic void wm97xx_remove_battery(struct wm97xx *wm)\n{\n\tplatform_device_unregister(wm->battery_dev);\n}\n\nstatic int wm97xx_add_battery(struct wm97xx *wm,\n\t\t\t      struct wm97xx_batt_pdata *pdata)\n{\n\tint ret;\n\n\twm->battery_dev = platform_device_alloc(\"wm97xx-battery\", -1);\n\tif (!wm->battery_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(wm->battery_dev, wm);\n\twm->battery_dev->dev.parent = wm->dev;\n\twm->battery_dev->dev.platform_data = pdata;\n\tret = platform_device_add(wm->battery_dev);\n\tif (ret)\n\t\tplatform_device_put(wm->battery_dev);\n\n\treturn ret;\n}\n\nstatic int wm97xx_probe(struct device *dev)\n{\n\tstruct wm97xx *wm;\n\tint ret;\n\tstruct wm97xx_pdata *pdata = dev_get_platdata(dev);\n\n\twm = devm_kzalloc(dev, sizeof(struct wm97xx), GFP_KERNEL);\n\tif (!wm)\n\t\treturn -ENOMEM;\n\n\twm->dev = dev;\n\twm->ac97 = to_ac97_t(dev);\n\n\tret =  _wm97xx_probe(wm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wm97xx_add_battery(wm, pdata ? pdata->batt_pdata : NULL);\n\tif (ret < 0)\n\t\tgoto batt_err;\n\n\treturn ret;\n\nbatt_err:\n\twm97xx_unregister_touch(wm);\n\treturn ret;\n}\n\nstatic int wm97xx_remove(struct device *dev)\n{\n\tstruct wm97xx *wm = dev_get_drvdata(dev);\n\n\twm97xx_remove_battery(wm);\n\twm97xx_unregister_touch(wm);\n\n\treturn 0;\n}\n\nstatic int wm97xx_mfd_probe(struct platform_device *pdev)\n{\n\tstruct wm97xx *wm;\n\tstruct wm97xx_platform_data *mfd_pdata = dev_get_platdata(&pdev->dev);\n\tint ret;\n\n\twm = devm_kzalloc(&pdev->dev, sizeof(struct wm97xx), GFP_KERNEL);\n\tif (!wm)\n\t\treturn -ENOMEM;\n\n\twm->dev = &pdev->dev;\n\twm->ac97 = mfd_pdata->ac97;\n\n\tret =  _wm97xx_probe(wm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wm97xx_add_battery(wm, mfd_pdata->batt_pdata);\n\tif (ret < 0)\n\t\tgoto batt_err;\n\n\treturn ret;\n\nbatt_err:\n\twm97xx_unregister_touch(wm);\n\treturn ret;\n}\n\nstatic int wm97xx_mfd_remove(struct platform_device *pdev)\n{\n\twm97xx_remove(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int wm97xx_suspend(struct device *dev)\n{\n\tstruct wm97xx *wm = dev_get_drvdata(dev);\n\tu16 reg;\n\tint suspend_mode;\n\n\tif (device_may_wakeup(&wm->input_dev->dev))\n\t\tsuspend_mode = wm->suspend_mode;\n\telse\n\t\tsuspend_mode = 0;\n\n\tmutex_lock(&wm->input_dev->mutex);\n\tif (input_device_enabled(wm->input_dev))\n\t\tcancel_delayed_work_sync(&wm->ts_reader);\n\n\t \n\treg = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER2);\n\treg &= ~WM97XX_PRP_DET_DIG;\n\tif (input_device_enabled(wm->input_dev))\n\t\treg |= suspend_mode;\n\twm->ac97->bus->ops->write(wm->ac97, AC97_WM97XX_DIGITISER2, reg);\n\n\t \n\tif (wm->id == WM9713_ID2 &&\n\t    (!input_device_enabled(wm->input_dev) || !suspend_mode)) {\n\t\treg = wm97xx_reg_read(wm, AC97_EXTENDED_MID) | 0x8000;\n\t\twm97xx_reg_write(wm, AC97_EXTENDED_MID, reg);\n\t}\n\tmutex_unlock(&wm->input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int wm97xx_resume(struct device *dev)\n{\n\tstruct wm97xx *wm = dev_get_drvdata(dev);\n\n\tmutex_lock(&wm->input_dev->mutex);\n\t \n\tif (wm->id == WM9713_ID2) {\n\t\twm97xx_reg_write(wm, AC97_WM9713_DIG1, wm->dig[0]);\n\t\twm97xx_reg_write(wm, 0x5a, wm->misc);\n\t\tif (input_device_enabled(wm->input_dev)) {\n\t\t\tu16 reg;\n\t\t\treg = wm97xx_reg_read(wm, AC97_EXTENDED_MID) & 0x7fff;\n\t\t\twm97xx_reg_write(wm, AC97_EXTENDED_MID, reg);\n\t\t}\n\t}\n\n\twm97xx_reg_write(wm, AC97_WM9713_DIG2, wm->dig[1]);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig[2]);\n\n\twm97xx_reg_write(wm, AC97_GPIO_CFG, wm->gpio[0]);\n\twm97xx_reg_write(wm, AC97_GPIO_POLARITY, wm->gpio[1]);\n\twm97xx_reg_write(wm, AC97_GPIO_STICKY, wm->gpio[2]);\n\twm97xx_reg_write(wm, AC97_GPIO_WAKEUP, wm->gpio[3]);\n\twm97xx_reg_write(wm, AC97_GPIO_STATUS, wm->gpio[4]);\n\twm97xx_reg_write(wm, AC97_MISC_AFE, wm->gpio[5]);\n\n\tif (input_device_enabled(wm->input_dev) && !wm->pen_irq) {\n\t\twm->ts_reader_interval = wm->ts_reader_min_interval;\n\t\tqueue_delayed_work(wm->ts_workq, &wm->ts_reader,\n\t\t\t\t   wm->ts_reader_interval);\n\t}\n\tmutex_unlock(&wm->input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(wm97xx_pm_ops, wm97xx_suspend, wm97xx_resume);\n\n \nint wm97xx_register_mach_ops(struct wm97xx *wm,\n\t\t\t     struct wm97xx_mach_ops *mach_ops)\n{\n\tmutex_lock(&wm->codec_mutex);\n\tif (wm->mach_ops) {\n\t\tmutex_unlock(&wm->codec_mutex);\n\t\treturn -EINVAL;\n\t}\n\twm->mach_ops = mach_ops;\n\tmutex_unlock(&wm->codec_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm97xx_register_mach_ops);\n\nvoid wm97xx_unregister_mach_ops(struct wm97xx *wm)\n{\n\tmutex_lock(&wm->codec_mutex);\n\twm->mach_ops = NULL;\n\tmutex_unlock(&wm->codec_mutex);\n}\nEXPORT_SYMBOL_GPL(wm97xx_unregister_mach_ops);\n\nstatic struct device_driver wm97xx_driver = {\n\t.name =\t\t\"wm97xx-ts\",\n#ifdef CONFIG_AC97_BUS\n\t.bus =\t\t&ac97_bus_type,\n#endif\n\t.owner =\tTHIS_MODULE,\n\t.probe =\twm97xx_probe,\n\t.remove =\twm97xx_remove,\n\t.pm =\t\tpm_sleep_ptr(&wm97xx_pm_ops),\n};\n\nstatic struct platform_driver wm97xx_mfd_driver = {\n\t.driver = {\n\t\t.name =\t\t\"wm97xx-ts\",\n\t\t.pm =\t\tpm_sleep_ptr(&wm97xx_pm_ops),\n\t},\n\t.probe =\twm97xx_mfd_probe,\n\t.remove =\twm97xx_mfd_remove,\n};\n\nstatic int __init wm97xx_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&wm97xx_mfd_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_BUILTIN(CONFIG_AC97_BUS))\n\t\tret =  driver_register(&wm97xx_driver);\n\treturn ret;\n}\n\nstatic void __exit wm97xx_exit(void)\n{\n\tif (IS_BUILTIN(CONFIG_AC97_BUS))\n\t\tdriver_unregister(&wm97xx_driver);\n\tplatform_driver_unregister(&wm97xx_mfd_driver);\n}\n\nmodule_init(wm97xx_init);\nmodule_exit(wm97xx_exit);\n\n \nMODULE_AUTHOR(\"Liam Girdwood <lrg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"WM97xx Core - Touch Screen / AUX ADC / GPIO Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}