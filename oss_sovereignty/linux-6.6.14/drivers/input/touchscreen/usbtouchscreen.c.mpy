{
  "module_name": "usbtouchscreen.c",
  "hash_id": "285f01bdbef2307d61f8cfacc103da42b0f9c1ed368a7553f38360aa23cada9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/usbtouchscreen.c",
  "human_readable_source": "\n \n\n\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <linux/hid.h>\n#include <linux/mutex.h>\n\nstatic bool swap_xy;\nmodule_param(swap_xy, bool, 0644);\nMODULE_PARM_DESC(swap_xy, \"If set X and Y axes are swapped.\");\n\nstatic bool hwcalib_xy;\nmodule_param(hwcalib_xy, bool, 0644);\nMODULE_PARM_DESC(hwcalib_xy, \"If set hw-calibrated X/Y are used if available\");\n\n \nstruct usbtouch_usb;\nstruct usbtouch_device_info {\n\tint min_xc, max_xc;\n\tint min_yc, max_yc;\n\tint min_press, max_press;\n\tint rept_size;\n\n\t \n\tbool irq_always;\n\n\tvoid (*process_pkt) (struct usbtouch_usb *usbtouch, unsigned char *pkt, int len);\n\n\t \n\tint  (*get_pkt_len) (unsigned char *pkt, int len);\n\n\tint  (*read_data)   (struct usbtouch_usb *usbtouch, unsigned char *pkt);\n\tint  (*alloc)       (struct usbtouch_usb *usbtouch);\n\tint  (*init)        (struct usbtouch_usb *usbtouch);\n\tvoid (*exit)\t    (struct usbtouch_usb *usbtouch);\n};\n\n \nstruct usbtouch_usb {\n\tunsigned char *data;\n\tdma_addr_t data_dma;\n\tint data_size;\n\tunsigned char *buffer;\n\tint buf_len;\n\tstruct urb *irq;\n\tstruct usb_interface *interface;\n\tstruct input_dev *input;\n\tstruct usbtouch_device_info *type;\n\tstruct mutex pm_mutex;   \n\tbool is_open;\n\tchar name[128];\n\tchar phys[64];\n\tvoid *priv;\n\n\tint x, y;\n\tint touch, press;\n};\n\n\n \nenum {\n\tDEVTYPE_IGNORE = -1,\n\tDEVTYPE_EGALAX,\n\tDEVTYPE_PANJIT,\n\tDEVTYPE_3M,\n\tDEVTYPE_ITM,\n\tDEVTYPE_ETURBO,\n\tDEVTYPE_GUNZE,\n\tDEVTYPE_DMC_TSC10,\n\tDEVTYPE_IRTOUCH,\n\tDEVTYPE_IRTOUCH_HIRES,\n\tDEVTYPE_IDEALTEK,\n\tDEVTYPE_GENERAL_TOUCH,\n\tDEVTYPE_GOTOP,\n\tDEVTYPE_JASTEC,\n\tDEVTYPE_E2I,\n\tDEVTYPE_ZYTRONIC,\n\tDEVTYPE_TC45USB,\n\tDEVTYPE_NEXIO,\n\tDEVTYPE_ELO,\n\tDEVTYPE_ETOUCH,\n};\n\n#define USB_DEVICE_HID_CLASS(vend, prod) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS \\\n\t\t| USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = USB_INTERFACE_CLASS_HID\n\nstatic const struct usb_device_id usbtouch_devices[] = {\n#ifdef CONFIG_TOUCHSCREEN_USB_EGALAX\n\t \n\t{USB_DEVICE_HID_CLASS(0x0eef, 0x0001), .driver_info = DEVTYPE_IGNORE},\n\t{USB_DEVICE_HID_CLASS(0x0eef, 0x0002), .driver_info = DEVTYPE_IGNORE},\n\n\t \n\t{USB_DEVICE(0x3823, 0x0001), .driver_info = DEVTYPE_EGALAX},\n\t{USB_DEVICE(0x3823, 0x0002), .driver_info = DEVTYPE_EGALAX},\n\t{USB_DEVICE(0x0123, 0x0001), .driver_info = DEVTYPE_EGALAX},\n\t{USB_DEVICE(0x0eef, 0x0001), .driver_info = DEVTYPE_EGALAX},\n\t{USB_DEVICE(0x0eef, 0x0002), .driver_info = DEVTYPE_EGALAX},\n\t{USB_DEVICE(0x1234, 0x0001), .driver_info = DEVTYPE_EGALAX},\n\t{USB_DEVICE(0x1234, 0x0002), .driver_info = DEVTYPE_EGALAX},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_PANJIT\n\t{USB_DEVICE(0x134c, 0x0001), .driver_info = DEVTYPE_PANJIT},\n\t{USB_DEVICE(0x134c, 0x0002), .driver_info = DEVTYPE_PANJIT},\n\t{USB_DEVICE(0x134c, 0x0003), .driver_info = DEVTYPE_PANJIT},\n\t{USB_DEVICE(0x134c, 0x0004), .driver_info = DEVTYPE_PANJIT},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_3M\n\t{USB_DEVICE(0x0596, 0x0001), .driver_info = DEVTYPE_3M},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ITM\n\t{USB_DEVICE(0x0403, 0xf9e9), .driver_info = DEVTYPE_ITM},\n\t{USB_DEVICE(0x16e3, 0xf9e9), .driver_info = DEVTYPE_ITM},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ETURBO\n\t{USB_DEVICE(0x1234, 0x5678), .driver_info = DEVTYPE_ETURBO},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_GUNZE\n\t{USB_DEVICE(0x0637, 0x0001), .driver_info = DEVTYPE_GUNZE},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_DMC_TSC10\n\t{USB_DEVICE(0x0afa, 0x03e8), .driver_info = DEVTYPE_DMC_TSC10},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_IRTOUCH\n\t{USB_DEVICE(0x255e, 0x0001), .driver_info = DEVTYPE_IRTOUCH},\n\t{USB_DEVICE(0x595a, 0x0001), .driver_info = DEVTYPE_IRTOUCH},\n\t{USB_DEVICE(0x6615, 0x0001), .driver_info = DEVTYPE_IRTOUCH},\n\t{USB_DEVICE(0x6615, 0x0012), .driver_info = DEVTYPE_IRTOUCH_HIRES},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_IDEALTEK\n\t{USB_DEVICE(0x1391, 0x1000), .driver_info = DEVTYPE_IDEALTEK},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH\n\t{USB_DEVICE(0x0dfc, 0x0001), .driver_info = DEVTYPE_GENERAL_TOUCH},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_GOTOP\n\t{USB_DEVICE(0x08f2, 0x007f), .driver_info = DEVTYPE_GOTOP},\n\t{USB_DEVICE(0x08f2, 0x00ce), .driver_info = DEVTYPE_GOTOP},\n\t{USB_DEVICE(0x08f2, 0x00f4), .driver_info = DEVTYPE_GOTOP},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_JASTEC\n\t{USB_DEVICE(0x0f92, 0x0001), .driver_info = DEVTYPE_JASTEC},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_E2I\n\t{USB_DEVICE(0x1ac7, 0x0001), .driver_info = DEVTYPE_E2I},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ZYTRONIC\n\t{USB_DEVICE(0x14c8, 0x0003), .driver_info = DEVTYPE_ZYTRONIC},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ETT_TC45USB\n\t \n\t{USB_DEVICE(0x0664, 0x0309), .driver_info = DEVTYPE_TC45USB},\n\t \n\t{USB_DEVICE(0x0664, 0x0306), .driver_info = DEVTYPE_TC45USB},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_NEXIO\n\t \n\t{USB_DEVICE_AND_INTERFACE_INFO(0x10f0, 0x2002, 0x0a, 0x00, 0x00),\n\t\t.driver_info = DEVTYPE_NEXIO},\n\t{USB_DEVICE_AND_INTERFACE_INFO(0x1870, 0x0001, 0x0a, 0x00, 0x00),\n\t\t.driver_info = DEVTYPE_NEXIO},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ELO\n\t{USB_DEVICE(0x04e7, 0x0020), .driver_info = DEVTYPE_ELO},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_EASYTOUCH\n\t{USB_DEVICE(0x7374, 0x0001), .driver_info = DEVTYPE_ETOUCH},\n#endif\n\n\t{}\n};\n\n\n \n\n#ifdef CONFIG_TOUCHSCREEN_USB_E2I\nstatic int e2i_init(struct usbtouch_usb *usbtouch)\n{\n\tint ret;\n\tstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t                      0x01, 0x02, 0x0000, 0x0081,\n\t                      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\n\tdev_dbg(&usbtouch->interface->dev,\n\t\t\"%s - usb_control_msg - E2I_RESET - bytes|err: %d\\n\",\n\t\t__func__, ret);\n\treturn ret;\n}\n\nstatic int e2i_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tint tmp = (pkt[0] << 8) | pkt[1];\n\tdev->x  = (pkt[2] << 8) | pkt[3];\n\tdev->y  = (pkt[4] << 8) | pkt[5];\n\n\ttmp = tmp - 0xA000;\n\tdev->touch = (tmp > 0);\n\tdev->press = (tmp > 0 ? tmp : 0);\n\n\treturn 1;\n}\n#endif\n\n\n \n\n#ifdef CONFIG_TOUCHSCREEN_USB_EGALAX\n\n#ifndef MULTI_PACKET\n#define MULTI_PACKET\n#endif\n\n#define EGALAX_PKT_TYPE_MASK\t\t0xFE\n#define EGALAX_PKT_TYPE_REPT\t\t0x80\n#define EGALAX_PKT_TYPE_DIAG\t\t0x0A\n\nstatic int egalax_init(struct usbtouch_usb *usbtouch)\n{\n\tint ret, i;\n\tunsigned char *buf;\n\tstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\n\n\t \n\n\tbuf = kmalloc(3, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = EGALAX_PKT_TYPE_DIAG;\n\tbuf[1] = 1;\t \n\tbuf[2] = 'A';\t \n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      0,\n\t\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t      0, 0, buf, 3,\n\t\t\t\t      USB_CTRL_SET_TIMEOUT);\n\t\tif (ret >= 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != -EPIPE)\n\t\t\tbreak;\n\t}\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int egalax_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tif ((pkt[0] & EGALAX_PKT_TYPE_MASK) != EGALAX_PKT_TYPE_REPT)\n\t\treturn 0;\n\n\tdev->x = ((pkt[3] & 0x0F) << 7) | (pkt[4] & 0x7F);\n\tdev->y = ((pkt[1] & 0x0F) << 7) | (pkt[2] & 0x7F);\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n\nstatic int egalax_get_pkt_len(unsigned char *buf, int len)\n{\n\tswitch (buf[0] & EGALAX_PKT_TYPE_MASK) {\n\tcase EGALAX_PKT_TYPE_REPT:\n\t\treturn 5;\n\n\tcase EGALAX_PKT_TYPE_DIAG:\n\t\tif (len < 2)\n\t\t\treturn -1;\n\n\t\treturn buf[1] + 2;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n\n#ifdef CONFIG_TOUCHSCREEN_USB_EASYTOUCH\n\n#ifndef MULTI_PACKET\n#define MULTI_PACKET\n#endif\n\n#define ETOUCH_PKT_TYPE_MASK\t\t0xFE\n#define ETOUCH_PKT_TYPE_REPT\t\t0x80\n#define ETOUCH_PKT_TYPE_REPT2\t\t0xB0\n#define ETOUCH_PKT_TYPE_DIAG\t\t0x0A\n\nstatic int etouch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tif ((pkt[0] & ETOUCH_PKT_TYPE_MASK) != ETOUCH_PKT_TYPE_REPT &&\n\t\t(pkt[0] & ETOUCH_PKT_TYPE_MASK) != ETOUCH_PKT_TYPE_REPT2)\n\t\treturn 0;\n\n\tdev->x = ((pkt[1] & 0x1F) << 7) | (pkt[2] & 0x7F);\n\tdev->y = ((pkt[3] & 0x1F) << 7) | (pkt[4] & 0x7F);\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n\nstatic int etouch_get_pkt_len(unsigned char *buf, int len)\n{\n\tswitch (buf[0] & ETOUCH_PKT_TYPE_MASK) {\n\tcase ETOUCH_PKT_TYPE_REPT:\n\tcase ETOUCH_PKT_TYPE_REPT2:\n\t\treturn 5;\n\n\tcase ETOUCH_PKT_TYPE_DIAG:\n\t\tif (len < 2)\n\t\t\treturn -1;\n\n\t\treturn buf[1] + 2;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_PANJIT\nstatic int panjit_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = ((pkt[2] & 0x0F) << 8) | pkt[1];\n\tdev->y = ((pkt[4] & 0x0F) << 8) | pkt[3];\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n#endif\n\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_3M\n\n#define MTOUCHUSB_ASYNC_REPORT          1\n#define MTOUCHUSB_RESET                 7\n#define MTOUCHUSB_REQ_CTRLLR_ID         10\n\n#define MTOUCHUSB_REQ_CTRLLR_ID_LEN\t16\n\nstatic int mtouch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tif (hwcalib_xy) {\n\t\tdev->x = (pkt[4] << 8) | pkt[3];\n\t\tdev->y = 0xffff - ((pkt[6] << 8) | pkt[5]);\n\t} else {\n\t\tdev->x = (pkt[8] << 8) | pkt[7];\n\t\tdev->y = (pkt[10] << 8) | pkt[9];\n\t}\n\tdev->touch = (pkt[2] & 0x40) ? 1 : 0;\n\n\treturn 1;\n}\n\nstruct mtouch_priv {\n\tu8 fw_rev_major;\n\tu8 fw_rev_minor;\n};\n\nstatic ssize_t mtouch_firmware_rev_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *output)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\n\tstruct mtouch_priv *priv = usbtouch->priv;\n\n\treturn scnprintf(output, PAGE_SIZE, \"%1x.%1x\\n\",\n\t\t\t priv->fw_rev_major, priv->fw_rev_minor);\n}\nstatic DEVICE_ATTR(firmware_rev, 0444, mtouch_firmware_rev_show, NULL);\n\nstatic struct attribute *mtouch_attrs[] = {\n\t&dev_attr_firmware_rev.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mtouch_attr_group = {\n\t.attrs = mtouch_attrs,\n};\n\nstatic int mtouch_get_fw_revision(struct usbtouch_usb *usbtouch)\n{\n\tstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\n\tstruct mtouch_priv *priv = usbtouch->priv;\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kzalloc(MTOUCHUSB_REQ_CTRLLR_ID_LEN, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      MTOUCHUSB_REQ_CTRLLR_ID,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      0, 0, buf, MTOUCHUSB_REQ_CTRLLR_ID_LEN,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != MTOUCHUSB_REQ_CTRLLR_ID_LEN) {\n\t\tdev_warn(&usbtouch->interface->dev,\n\t\t\t \"Failed to read FW rev: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto free;\n\t}\n\n\tpriv->fw_rev_major = buf[3];\n\tpriv->fw_rev_minor = buf[4];\n\n\tret = 0;\n\nfree:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int mtouch_alloc(struct usbtouch_usb *usbtouch)\n{\n\tint ret;\n\n\tusbtouch->priv = kmalloc(sizeof(struct mtouch_priv), GFP_KERNEL);\n\tif (!usbtouch->priv)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(&usbtouch->interface->dev.kobj,\n\t\t\t\t &mtouch_attr_group);\n\tif (ret) {\n\t\tkfree(usbtouch->priv);\n\t\tusbtouch->priv = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtouch_init(struct usbtouch_usb *usbtouch)\n{\n\tint ret, i;\n\tstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\n\n\tret = mtouch_get_fw_revision(usbtouch);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t                      MTOUCHUSB_RESET,\n\t                      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t                      1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tdev_dbg(&usbtouch->interface->dev,\n\t\t\"%s - usb_control_msg - MTOUCHUSB_RESET - bytes|err: %d\\n\",\n\t\t__func__, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(150);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t      MTOUCHUSB_ASYNC_REPORT,\n\t\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t      1, 1, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\t\tdev_dbg(&usbtouch->interface->dev,\n\t\t\t\"%s - usb_control_msg - MTOUCHUSB_ASYNC_REPORT - bytes|err: %d\\n\",\n\t\t\t__func__, ret);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tif (ret != -EPIPE)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (hwcalib_xy) {\n\t\tinput_set_abs_params(usbtouch->input, ABS_X, 0, 0xffff, 0, 0);\n\t\tinput_set_abs_params(usbtouch->input, ABS_Y, 0, 0xffff, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtouch_exit(struct usbtouch_usb *usbtouch)\n{\n\tstruct mtouch_priv *priv = usbtouch->priv;\n\n\tsysfs_remove_group(&usbtouch->interface->dev.kobj, &mtouch_attr_group);\n\tkfree(priv);\n}\n#endif\n\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_ITM\nstatic int itm_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tint touch;\n\t \n\tdev->press = ((pkt[2] & 0x01) << 7) | (pkt[5] & 0x7F);\n\n\ttouch = ~pkt[7] & 0x20;\n\tif (!touch) {\n\t\tif (dev->touch) {\n\t\t\tdev->touch = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdev->x = ((pkt[0] & 0x1F) << 7) | (pkt[3] & 0x7F);\n\tdev->y = ((pkt[1] & 0x1F) << 7) | (pkt[4] & 0x7F);\n\tdev->touch = touch;\n\n\treturn 1;\n}\n#endif\n\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_ETURBO\n#ifndef MULTI_PACKET\n#define MULTI_PACKET\n#endif\nstatic int eturbo_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tunsigned int shift;\n\n\t \n\tif (!(pkt[0] & 0x80))\n\t\treturn 0;\n\n\tshift = (6 - (pkt[0] & 0x03));\n\tdev->x = ((pkt[3] << 7) | pkt[4]) >> shift;\n\tdev->y = ((pkt[1] << 7) | pkt[2]) >> shift;\n\tdev->touch = (pkt[0] & 0x10) ? 1 : 0;\n\n\treturn 1;\n}\n\nstatic int eturbo_get_pkt_len(unsigned char *buf, int len)\n{\n\tif (buf[0] & 0x80)\n\t\treturn 5;\n\tif (buf[0] == 0x01)\n\t\treturn 3;\n\treturn 0;\n}\n#endif\n\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_GUNZE\nstatic int gunze_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tif (!(pkt[0] & 0x80) || ((pkt[1] | pkt[2] | pkt[3]) & 0x80))\n\t\treturn 0;\n\n\tdev->x = ((pkt[0] & 0x1F) << 7) | (pkt[2] & 0x7F);\n\tdev->y = ((pkt[1] & 0x1F) << 7) | (pkt[3] & 0x7F);\n\tdev->touch = pkt[0] & 0x20;\n\n\treturn 1;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_DMC_TSC10\n\n \n#define TSC10_RATE_POINT\t0x50\n#define TSC10_RATE_30\t\t0x40\n#define TSC10_RATE_50\t\t0x41\n#define TSC10_RATE_80\t\t0x42\n#define TSC10_RATE_100\t\t0x43\n#define TSC10_RATE_130\t\t0x44\n#define TSC10_RATE_150\t\t0x45\n\n \n#define TSC10_CMD_RESET\t\t0x55\n#define TSC10_CMD_RATE\t\t0x05\n#define TSC10_CMD_DATA1\t\t0x01\n\nstatic int dmc_tsc10_init(struct usbtouch_usb *usbtouch)\n{\n\tstruct usb_device *dev = interface_to_usbdev(usbtouch->interface);\n\tint ret = -ENOMEM;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(2, GFP_NOIO);\n\tif (!buf)\n\t\tgoto err_nobuf;\n\t \n\tbuf[0] = buf[1] = 0xFF;\n\tret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),\n\t                      TSC10_CMD_RESET,\n\t                      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t                      0, 0, buf, 2, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tif (buf[0] != 0x06) {\n\t\tret = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tmsleep(150);\n\n\t \n\tbuf[0] = buf[1] = 0xFF;\n\tret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),\n\t                      TSC10_CMD_RATE,\n\t                      USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t                      TSC10_RATE_150, 0, buf, 2, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tif ((buf[0] != 0x06) && (buf[0] != 0x15 || buf[1] != 0x01)) {\n\t\tret = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t                      TSC10_CMD_DATA1,\n\t                      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t                      0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\nerr_out:\n\tkfree(buf);\nerr_nobuf:\n\treturn ret;\n}\n\n\nstatic int dmc_tsc10_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = ((pkt[2] & 0x03) << 8) | pkt[1];\n\tdev->y = ((pkt[4] & 0x03) << 8) | pkt[3];\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n#endif\n\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_IRTOUCH\nstatic int irtouch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = (pkt[3] << 8) | pkt[2];\n\tdev->y = (pkt[5] << 8) | pkt[4];\n\tdev->touch = (pkt[1] & 0x03) ? 1 : 0;\n\n\treturn 1;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_ETT_TC45USB\nstatic int tc45usb_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = ((pkt[2] & 0x0F) << 8) | pkt[1];\n\tdev->y = ((pkt[4] & 0x0F) << 8) | pkt[3];\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_IDEALTEK\n#ifndef MULTI_PACKET\n#define MULTI_PACKET\n#endif\nstatic int idealtek_get_pkt_len(unsigned char *buf, int len)\n{\n\tif (buf[0] & 0x80)\n\t\treturn 5;\n\tif (buf[0] == 0x01)\n\t\treturn len;\n\treturn 0;\n}\n\nstatic int idealtek_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tswitch (pkt[0] & 0x98) {\n\tcase 0x88:\n\t\t \n\t\tdev->x = (pkt[1] << 5) | (pkt[2] >> 2);\n\t\tdev->y = (pkt[3] << 5) | (pkt[4] >> 2);\n\t\tdev->touch = (pkt[0] & 0x40) ? 1 : 0;\n\t\treturn 1;\n\n\tcase 0x98:\n\t\t \n\t\tdev->x = (pkt[2] << 5) | (pkt[1] >> 2);\n\t\tdev->y = (pkt[4] << 5) | (pkt[3] >> 2);\n\t\tdev->touch = (pkt[0] & 0x40) ? 1 : 0;\n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH\nstatic int general_touch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = (pkt[2] << 8) | pkt[1];\n\tdev->y = (pkt[4] << 8) | pkt[3];\n\tdev->press = pkt[5] & 0xff;\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_GOTOP\nstatic int gotop_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = ((pkt[1] & 0x38) << 4) | pkt[2];\n\tdev->y = ((pkt[1] & 0x07) << 7) | pkt[3];\n\tdev->touch = pkt[0] & 0x01;\n\n\treturn 1;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_JASTEC\nstatic int jastec_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = ((pkt[0] & 0x3f) << 6) | (pkt[2] & 0x3f);\n\tdev->y = ((pkt[1] & 0x3f) << 6) | (pkt[3] & 0x3f);\n\tdev->touch = (pkt[0] & 0x40) >> 6;\n\n\treturn 1;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_ZYTRONIC\nstatic int zytronic_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tstruct usb_interface *intf = dev->interface;\n\n\tswitch (pkt[0]) {\n\tcase 0x3A:  \n\t\tdev_dbg(&intf->dev, \"%s: Command response %d\\n\", __func__, pkt[1]);\n\t\tbreak;\n\n\tcase 0xC0:  \n\t\tdev->x = (pkt[1] & 0x7f) | ((pkt[2] & 0x07) << 7);\n\t\tdev->y = (pkt[3] & 0x7f) | ((pkt[4] & 0x07) << 7);\n\t\tdev->touch = 1;\n\t\tdev_dbg(&intf->dev, \"%s: down %d,%d\\n\", __func__, dev->x, dev->y);\n\t\treturn 1;\n\n\tcase 0x80:  \n\t\tdev->x = (pkt[1] & 0x7f) | ((pkt[2] & 0x07) << 7);\n\t\tdev->y = (pkt[3] & 0x7f) | ((pkt[4] & 0x07) << 7);\n\t\tdev->touch = 0;\n\t\tdev_dbg(&intf->dev, \"%s: up %d,%d\\n\", __func__, dev->x, dev->y);\n\t\treturn 1;\n\n\tdefault:\n\t\tdev_dbg(&intf->dev, \"%s: Unknown return %d\\n\", __func__, pkt[0]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n#ifdef CONFIG_TOUCHSCREEN_USB_NEXIO\n\n#define NEXIO_TIMEOUT\t5000\n#define NEXIO_BUFSIZE\t1024\n#define NEXIO_THRESHOLD\t50\n\nstruct nexio_priv {\n\tstruct urb *ack;\n\tunsigned char *ack_buf;\n};\n\nstruct nexio_touch_packet {\n\tu8\tflags;\t\t \n\t__be16\tdata_len;\t \n\t__be16\tx_len;\t\t \n\t__be16\ty_len;\t\t \n\tu8\tdata[];\n} __attribute__ ((packed));\n\nstatic unsigned char nexio_ack_pkt[2] = { 0xaa, 0x02 };\nstatic unsigned char nexio_init_pkt[4] = { 0x82, 0x04, 0x0a, 0x0f };\n\nstatic void nexio_ack_complete(struct urb *urb)\n{\n}\n\nstatic int nexio_alloc(struct usbtouch_usb *usbtouch)\n{\n\tstruct nexio_priv *priv;\n\tint ret = -ENOMEM;\n\n\tusbtouch->priv = kmalloc(sizeof(struct nexio_priv), GFP_KERNEL);\n\tif (!usbtouch->priv)\n\t\tgoto out_buf;\n\n\tpriv = usbtouch->priv;\n\n\tpriv->ack_buf = kmemdup(nexio_ack_pkt, sizeof(nexio_ack_pkt),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->ack_buf)\n\t\tgoto err_priv;\n\n\tpriv->ack = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!priv->ack) {\n\t\tdev_dbg(&usbtouch->interface->dev,\n\t\t\t\"%s - usb_alloc_urb failed: usbtouch->ack\\n\", __func__);\n\t\tgoto err_ack_buf;\n\t}\n\n\treturn 0;\n\nerr_ack_buf:\n\tkfree(priv->ack_buf);\nerr_priv:\n\tkfree(priv);\nout_buf:\n\treturn ret;\n}\n\nstatic int nexio_init(struct usbtouch_usb *usbtouch)\n{\n\tstruct usb_device *dev = interface_to_usbdev(usbtouch->interface);\n\tstruct usb_host_interface *interface = usbtouch->interface->cur_altsetting;\n\tstruct nexio_priv *priv = usbtouch->priv;\n\tint ret = -ENOMEM;\n\tint actual_len, i;\n\tunsigned char *buf;\n\tchar *firmware_ver = NULL, *device_name = NULL;\n\tint input_ep = 0, output_ep = 0;\n\n\t \n\tfor (i = 0; i < interface->desc.bNumEndpoints; i++) {\n\t\tif (!input_ep &&\n\t\t    usb_endpoint_dir_in(&interface->endpoint[i].desc))\n\t\t\tinput_ep = interface->endpoint[i].desc.bEndpointAddress;\n\t\tif (!output_ep &&\n\t\t    usb_endpoint_dir_out(&interface->endpoint[i].desc))\n\t\t\toutput_ep = interface->endpoint[i].desc.bEndpointAddress;\n\t}\n\tif (!input_ep || !output_ep)\n\t\treturn -ENXIO;\n\n\tbuf = kmalloc(NEXIO_BUFSIZE, GFP_NOIO);\n\tif (!buf)\n\t\tgoto out_buf;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, input_ep),\n\t\t\t\t   buf, NEXIO_BUFSIZE, &actual_len,\n\t\t\t\t   NEXIO_TIMEOUT);\n\t\tif (ret < 0)\n\t\t\tgoto out_buf;\n\t}\n\n\t \n\tmemcpy(buf, nexio_init_pkt, sizeof(nexio_init_pkt));\n\tret = usb_bulk_msg(dev, usb_sndbulkpipe(dev, output_ep),\n\t\t\t   buf, sizeof(nexio_init_pkt), &actual_len,\n\t\t\t   NEXIO_TIMEOUT);\n\tif (ret < 0)\n\t\tgoto out_buf;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tmemset(buf, 0, NEXIO_BUFSIZE);\n\t\tret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, input_ep),\n\t\t\t\t   buf, NEXIO_BUFSIZE, &actual_len,\n\t\t\t\t   NEXIO_TIMEOUT);\n\t\tif (ret < 0 || actual_len < 1 || buf[1] != actual_len)\n\t\t\tcontinue;\n\t\tswitch (buf[0]) {\n\t\tcase 0x83:\t \n\t\t\tif (!firmware_ver)\n\t\t\t\tfirmware_ver = kstrdup(&buf[2], GFP_NOIO);\n\t\t\tbreak;\n\t\tcase 0x84:\t \n\t\t\tif (!device_name)\n\t\t\t\tdevice_name = kstrdup(&buf[2], GFP_NOIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintk(KERN_INFO \"Nexio device: %s, firmware version: %s\\n\",\n\t       device_name, firmware_ver);\n\n\tkfree(firmware_ver);\n\tkfree(device_name);\n\n\tusb_fill_bulk_urb(priv->ack, dev, usb_sndbulkpipe(dev, output_ep),\n\t\t\t  priv->ack_buf, sizeof(nexio_ack_pkt),\n\t\t\t  nexio_ack_complete, usbtouch);\n\tret = 0;\n\nout_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void nexio_exit(struct usbtouch_usb *usbtouch)\n{\n\tstruct nexio_priv *priv = usbtouch->priv;\n\n\tusb_kill_urb(priv->ack);\n\tusb_free_urb(priv->ack);\n\tkfree(priv->ack_buf);\n\tkfree(priv);\n}\n\nstatic int nexio_read_data(struct usbtouch_usb *usbtouch, unsigned char *pkt)\n{\n\tstruct device *dev = &usbtouch->interface->dev;\n\tstruct nexio_touch_packet *packet = (void *) pkt;\n\tstruct nexio_priv *priv = usbtouch->priv;\n\tunsigned int data_len = be16_to_cpu(packet->data_len);\n\tunsigned int x_len = be16_to_cpu(packet->x_len);\n\tunsigned int y_len = be16_to_cpu(packet->y_len);\n\tint x, y, begin_x, begin_y, end_x, end_y, w, h, ret;\n\n\t \n\tif ((pkt[0] & 0xe0) != 0xe0)\n\t\treturn 0;\n\n\tif (data_len > 0xff)\n\t\tdata_len -= 0x100;\n\tif (x_len > 0xff)\n\t\tx_len -= 0x80;\n\n\t \n\tret = usb_submit_urb(priv->ack, GFP_ATOMIC);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to submit ACK URB: %d\\n\", ret);\n\n\tif (!usbtouch->type->max_xc) {\n\t\tusbtouch->type->max_xc = 2 * x_len;\n\t\tinput_set_abs_params(usbtouch->input, ABS_X,\n\t\t\t\t     0, usbtouch->type->max_xc, 0, 0);\n\t\tusbtouch->type->max_yc = 2 * y_len;\n\t\tinput_set_abs_params(usbtouch->input, ABS_Y,\n\t\t\t\t     0, usbtouch->type->max_yc, 0, 0);\n\t}\n\t \n\tbegin_x = end_x = begin_y = end_y = -1;\n\tfor (x = 0; x < x_len; x++) {\n\t\tif (begin_x == -1 && packet->data[x] > NEXIO_THRESHOLD) {\n\t\t\tbegin_x = x;\n\t\t\tcontinue;\n\t\t}\n\t\tif (end_x == -1 && begin_x != -1 && packet->data[x] < NEXIO_THRESHOLD) {\n\t\t\tend_x = x - 1;\n\t\t\tfor (y = x_len; y < data_len; y++) {\n\t\t\t\tif (begin_y == -1 && packet->data[y] > NEXIO_THRESHOLD) {\n\t\t\t\t\tbegin_y = y - x_len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (end_y == -1 &&\n\t\t\t\t    begin_y != -1 && packet->data[y] < NEXIO_THRESHOLD) {\n\t\t\t\t\tend_y = y - 1 - x_len;\n\t\t\t\t\tw = end_x - begin_x;\n\t\t\t\t\th = end_y - begin_y;\n#if 0\n\t\t\t\t\t \n\t\t\t\t\tinput_report_abs(usbtouch->input,\n\t\t\t\t\t\t    ABS_MT_TOUCH_MAJOR, max(w,h));\n\t\t\t\t\tinput_report_abs(usbtouch->input,\n\t\t\t\t\t\t    ABS_MT_TOUCH_MINOR, min(x,h));\n\t\t\t\t\tinput_report_abs(usbtouch->input,\n\t\t\t\t\t\t    ABS_MT_POSITION_X, 2*begin_x+w);\n\t\t\t\t\tinput_report_abs(usbtouch->input,\n\t\t\t\t\t\t    ABS_MT_POSITION_Y, 2*begin_y+h);\n\t\t\t\t\tinput_report_abs(usbtouch->input,\n\t\t\t\t\t\t    ABS_MT_ORIENTATION, w > h);\n\t\t\t\t\tinput_mt_sync(usbtouch->input);\n#endif\n\t\t\t\t\t \n\t\t\t\t\tusbtouch->x = 2 * begin_x + w;\n\t\t\t\t\tusbtouch->y = 2 * begin_y + h;\n\t\t\t\t\tusbtouch->touch = packet->flags & 0x01;\n\t\t\t\t\tbegin_y = end_y = -1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbegin_x = end_x = -1;\n\t\t}\n\n\t}\n\treturn 0;\n}\n#endif\n\n\n \n\n#ifdef CONFIG_TOUCHSCREEN_USB_ELO\n\nstatic int elo_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\n{\n\tdev->x = (pkt[3] << 8) | pkt[2];\n\tdev->y = (pkt[5] << 8) | pkt[4];\n\tdev->touch = pkt[6] > 0;\n\tdev->press = pkt[6];\n\n\treturn 1;\n}\n#endif\n\n\n \n#ifdef MULTI_PACKET\nstatic void usbtouch_process_multi(struct usbtouch_usb *usbtouch,\n\t\t\t\t   unsigned char *pkt, int len);\n#endif\n\nstatic struct usbtouch_device_info usbtouch_dev_info[] = {\n#ifdef CONFIG_TOUCHSCREEN_USB_ELO\n\t[DEVTYPE_ELO] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.max_press\t= 0xff,\n\t\t.rept_size\t= 8,\n\t\t.read_data\t= elo_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_EGALAX\n\t[DEVTYPE_EGALAX] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x07ff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x07ff,\n\t\t.rept_size\t= 16,\n\t\t.process_pkt\t= usbtouch_process_multi,\n\t\t.get_pkt_len\t= egalax_get_pkt_len,\n\t\t.read_data\t= egalax_read_data,\n\t\t.init\t\t= egalax_init,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_PANJIT\n\t[DEVTYPE_PANJIT] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.rept_size\t= 8,\n\t\t.read_data\t= panjit_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_3M\n\t[DEVTYPE_3M] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x4000,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x4000,\n\t\t.rept_size\t= 11,\n\t\t.read_data\t= mtouch_read_data,\n\t\t.alloc\t\t= mtouch_alloc,\n\t\t.init\t\t= mtouch_init,\n\t\t.exit\t\t= mtouch_exit,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ITM\n\t[DEVTYPE_ITM] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.max_press\t= 0xff,\n\t\t.rept_size\t= 8,\n\t\t.read_data\t= itm_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ETURBO\n\t[DEVTYPE_ETURBO] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x07ff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x07ff,\n\t\t.rept_size\t= 8,\n\t\t.process_pkt\t= usbtouch_process_multi,\n\t\t.get_pkt_len\t= eturbo_get_pkt_len,\n\t\t.read_data\t= eturbo_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_GUNZE\n\t[DEVTYPE_GUNZE] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.rept_size\t= 4,\n\t\t.read_data\t= gunze_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_DMC_TSC10\n\t[DEVTYPE_DMC_TSC10] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x03ff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x03ff,\n\t\t.rept_size\t= 5,\n\t\t.init\t\t= dmc_tsc10_init,\n\t\t.read_data\t= dmc_tsc10_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_IRTOUCH\n\t[DEVTYPE_IRTOUCH] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.rept_size\t= 8,\n\t\t.read_data\t= irtouch_read_data,\n\t},\n\n\t[DEVTYPE_IRTOUCH_HIRES] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x7fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x7fff,\n\t\t.rept_size\t= 8,\n\t\t.read_data\t= irtouch_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_IDEALTEK\n\t[DEVTYPE_IDEALTEK] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.rept_size\t= 8,\n\t\t.process_pkt\t= usbtouch_process_multi,\n\t\t.get_pkt_len\t= idealtek_get_pkt_len,\n\t\t.read_data\t= idealtek_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH\n\t[DEVTYPE_GENERAL_TOUCH] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x7fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x7fff,\n\t\t.rept_size\t= 7,\n\t\t.read_data\t= general_touch_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_GOTOP\n\t[DEVTYPE_GOTOP] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x03ff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x03ff,\n\t\t.rept_size\t= 4,\n\t\t.read_data\t= gotop_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_JASTEC\n\t[DEVTYPE_JASTEC] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.rept_size\t= 4,\n\t\t.read_data\t= jastec_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_E2I\n\t[DEVTYPE_E2I] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x7fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x7fff,\n\t\t.rept_size\t= 6,\n\t\t.init\t\t= e2i_init,\n\t\t.read_data\t= e2i_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ZYTRONIC\n\t[DEVTYPE_ZYTRONIC] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x03ff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x03ff,\n\t\t.rept_size\t= 5,\n\t\t.read_data\t= zytronic_read_data,\n\t\t.irq_always     = true,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_ETT_TC45USB\n\t[DEVTYPE_TC45USB] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x0fff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x0fff,\n\t\t.rept_size\t= 5,\n\t\t.read_data\t= tc45usb_read_data,\n\t},\n#endif\n\n#ifdef CONFIG_TOUCHSCREEN_USB_NEXIO\n\t[DEVTYPE_NEXIO] = {\n\t\t.rept_size\t= 1024,\n\t\t.irq_always\t= true,\n\t\t.read_data\t= nexio_read_data,\n\t\t.alloc\t\t= nexio_alloc,\n\t\t.init\t\t= nexio_init,\n\t\t.exit\t\t= nexio_exit,\n\t},\n#endif\n#ifdef CONFIG_TOUCHSCREEN_USB_EASYTOUCH\n\t[DEVTYPE_ETOUCH] = {\n\t\t.min_xc\t\t= 0x0,\n\t\t.max_xc\t\t= 0x07ff,\n\t\t.min_yc\t\t= 0x0,\n\t\t.max_yc\t\t= 0x07ff,\n\t\t.rept_size\t= 16,\n\t\t.process_pkt\t= usbtouch_process_multi,\n\t\t.get_pkt_len\t= etouch_get_pkt_len,\n\t\t.read_data\t= etouch_read_data,\n\t},\n#endif\n};\n\n\n \nstatic void usbtouch_process_pkt(struct usbtouch_usb *usbtouch,\n                                 unsigned char *pkt, int len)\n{\n\tstruct usbtouch_device_info *type = usbtouch->type;\n\n\tif (!type->read_data(usbtouch, pkt))\n\t\t\treturn;\n\n\tinput_report_key(usbtouch->input, BTN_TOUCH, usbtouch->touch);\n\n\tif (swap_xy) {\n\t\tinput_report_abs(usbtouch->input, ABS_X, usbtouch->y);\n\t\tinput_report_abs(usbtouch->input, ABS_Y, usbtouch->x);\n\t} else {\n\t\tinput_report_abs(usbtouch->input, ABS_X, usbtouch->x);\n\t\tinput_report_abs(usbtouch->input, ABS_Y, usbtouch->y);\n\t}\n\tif (type->max_press)\n\t\tinput_report_abs(usbtouch->input, ABS_PRESSURE, usbtouch->press);\n\tinput_sync(usbtouch->input);\n}\n\n\n#ifdef MULTI_PACKET\nstatic void usbtouch_process_multi(struct usbtouch_usb *usbtouch,\n                                   unsigned char *pkt, int len)\n{\n\tunsigned char *buffer;\n\tint pkt_len, pos, buf_len, tmp;\n\n\t \n\tif (unlikely(usbtouch->buf_len)) {\n\t\t \n\t\tpkt_len = usbtouch->type->get_pkt_len(\n\t\t\t\tusbtouch->buffer, usbtouch->buf_len);\n\n\t\t \n\t\tif (unlikely(!pkt_len))\n\t\t\tgoto out_flush_buf;\n\n\t\t \n\t\tif (unlikely(pkt_len < 0)) {\n\t\t\tint append = -pkt_len;\n\t\t\tif (unlikely(append > len))\n\t\t\t       append = len;\n\t\t\tif (usbtouch->buf_len + append >= usbtouch->type->rept_size)\n\t\t\t\tgoto out_flush_buf;\n\t\t\tmemcpy(usbtouch->buffer + usbtouch->buf_len, pkt, append);\n\t\t\tusbtouch->buf_len += append;\n\n\t\t\tpkt_len = usbtouch->type->get_pkt_len(\n\t\t\t\t\tusbtouch->buffer, usbtouch->buf_len);\n\t\t\tif (pkt_len < 0)\n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\t\ttmp = pkt_len - usbtouch->buf_len;\n\t\tif (usbtouch->buf_len + tmp >= usbtouch->type->rept_size)\n\t\t\tgoto out_flush_buf;\n\t\tmemcpy(usbtouch->buffer + usbtouch->buf_len, pkt, tmp);\n\t\tusbtouch_process_pkt(usbtouch, usbtouch->buffer, pkt_len);\n\n\t\tbuffer = pkt + tmp;\n\t\tbuf_len = len - tmp;\n\t} else {\n\t\tbuffer = pkt;\n\t\tbuf_len = len;\n\t}\n\n\t \n\tpos = 0;\n\twhile (pos < buf_len) {\n\t\t \n\t\tpkt_len = usbtouch->type->get_pkt_len(buffer + pos,\n\t\t\t\t\t\t\tbuf_len - pos);\n\n\t\t \n\t\tif (unlikely(!pkt_len)) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (likely((pkt_len > 0) && (pkt_len <= buf_len - pos))) {\n\t\t\tusbtouch_process_pkt(usbtouch, buffer + pos, pkt_len);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(usbtouch->buffer, buffer + pos, buf_len - pos);\n\t\t\tusbtouch->buf_len = buf_len - pos;\n\t\t\treturn;\n\t\t}\n\t\tpos += pkt_len;\n\t}\n\nout_flush_buf:\n\tusbtouch->buf_len = 0;\n\treturn;\n}\n#endif\n\n\nstatic void usbtouch_irq(struct urb *urb)\n{\n\tstruct usbtouch_usb *usbtouch = urb->context;\n\tstruct device *dev = &usbtouch->interface->dev;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ETIME:\n\t\t \n\t\tdev_dbg(dev,\n\t\t\t\"%s - urb timed out - was the device unplugged?\\n\",\n\t\t\t__func__);\n\t\treturn;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EPIPE:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\tusbtouch->type->process_pkt(usbtouch, usbtouch->data, urb->actual_length);\n\nexit:\n\tusb_mark_last_busy(interface_to_usbdev(usbtouch->interface));\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result: %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic int usbtouch_open(struct input_dev *input)\n{\n\tstruct usbtouch_usb *usbtouch = input_get_drvdata(input);\n\tint r;\n\n\tusbtouch->irq->dev = interface_to_usbdev(usbtouch->interface);\n\n\tr = usb_autopm_get_interface(usbtouch->interface) ? -EIO : 0;\n\tif (r < 0)\n\t\tgoto out;\n\n\tmutex_lock(&usbtouch->pm_mutex);\n\tif (!usbtouch->type->irq_always) {\n\t\tif (usb_submit_urb(usbtouch->irq, GFP_KERNEL)) {\n\t\t\tr = -EIO;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tusbtouch->interface->needs_remote_wakeup = 1;\n\tusbtouch->is_open = true;\nout_put:\n\tmutex_unlock(&usbtouch->pm_mutex);\n\tusb_autopm_put_interface(usbtouch->interface);\nout:\n\treturn r;\n}\n\nstatic void usbtouch_close(struct input_dev *input)\n{\n\tstruct usbtouch_usb *usbtouch = input_get_drvdata(input);\n\tint r;\n\n\tmutex_lock(&usbtouch->pm_mutex);\n\tif (!usbtouch->type->irq_always)\n\t\tusb_kill_urb(usbtouch->irq);\n\tusbtouch->is_open = false;\n\tmutex_unlock(&usbtouch->pm_mutex);\n\n\tr = usb_autopm_get_interface(usbtouch->interface);\n\tusbtouch->interface->needs_remote_wakeup = 0;\n\tif (!r)\n\t\tusb_autopm_put_interface(usbtouch->interface);\n}\n\nstatic int usbtouch_suspend\n(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\n\n\tusb_kill_urb(usbtouch->irq);\n\n\treturn 0;\n}\n\nstatic int usbtouch_resume(struct usb_interface *intf)\n{\n\tstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\n\tint result = 0;\n\n\tmutex_lock(&usbtouch->pm_mutex);\n\tif (usbtouch->is_open || usbtouch->type->irq_always)\n\t\tresult = usb_submit_urb(usbtouch->irq, GFP_NOIO);\n\tmutex_unlock(&usbtouch->pm_mutex);\n\n\treturn result;\n}\n\nstatic int usbtouch_reset_resume(struct usb_interface *intf)\n{\n\tstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\n\tint err = 0;\n\n\t \n\tif (usbtouch->type->init) {\n\t\terr = usbtouch->type->init(usbtouch);\n\t\tif (err) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"%s - type->init() failed, err: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&usbtouch->pm_mutex);\n\tif (usbtouch->is_open)\n\t\terr = usb_submit_urb(usbtouch->irq, GFP_NOIO);\n\tmutex_unlock(&usbtouch->pm_mutex);\n\n\treturn err;\n}\n\nstatic void usbtouch_free_buffers(struct usb_device *udev,\n\t\t\t\t  struct usbtouch_usb *usbtouch)\n{\n\tusb_free_coherent(udev, usbtouch->data_size,\n\t\t\t  usbtouch->data, usbtouch->data_dma);\n\tkfree(usbtouch->buffer);\n}\n\nstatic struct usb_endpoint_descriptor *\nusbtouch_get_input_endpoint(struct usb_host_interface *interface)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->desc.bNumEndpoints; i++)\n\t\tif (usb_endpoint_dir_in(&interface->endpoint[i].desc))\n\t\t\treturn &interface->endpoint[i].desc;\n\n\treturn NULL;\n}\n\nstatic int usbtouch_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct usbtouch_usb *usbtouch;\n\tstruct input_dev *input_dev;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usbtouch_device_info *type;\n\tint err = -ENOMEM;\n\n\t \n\tif (id->driver_info == DEVTYPE_IGNORE)\n\t\treturn -ENODEV;\n\n\tif (id->driver_info >= ARRAY_SIZE(usbtouch_dev_info))\n\t\treturn -ENODEV;\n\n\tendpoint = usbtouch_get_input_endpoint(intf->cur_altsetting);\n\tif (!endpoint)\n\t\treturn -ENXIO;\n\n\tusbtouch = kzalloc(sizeof(struct usbtouch_usb), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!usbtouch || !input_dev)\n\t\tgoto out_free;\n\n\tmutex_init(&usbtouch->pm_mutex);\n\n\ttype = &usbtouch_dev_info[id->driver_info];\n\tusbtouch->type = type;\n\tif (!type->process_pkt)\n\t\ttype->process_pkt = usbtouch_process_pkt;\n\n\tusbtouch->data_size = type->rept_size;\n\tif (type->get_pkt_len) {\n\t\t \n\t\tusbtouch->data_size = min(usbtouch->data_size,\n\t\t\t\t\t  usb_endpoint_maxp(endpoint));\n\t}\n\n\tusbtouch->data = usb_alloc_coherent(udev, usbtouch->data_size,\n\t\t\t\t\t    GFP_KERNEL, &usbtouch->data_dma);\n\tif (!usbtouch->data)\n\t\tgoto out_free;\n\n\tif (type->get_pkt_len) {\n\t\tusbtouch->buffer = kmalloc(type->rept_size, GFP_KERNEL);\n\t\tif (!usbtouch->buffer)\n\t\t\tgoto out_free_buffers;\n\t}\n\n\tusbtouch->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usbtouch->irq) {\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"%s - usb_alloc_urb failed: usbtouch->irq\\n\", __func__);\n\t\tgoto out_free_buffers;\n\t}\n\n\tusbtouch->interface = intf;\n\tusbtouch->input = input_dev;\n\n\tif (udev->manufacturer)\n\t\tstrscpy(usbtouch->name, udev->manufacturer, sizeof(usbtouch->name));\n\n\tif (udev->product) {\n\t\tif (udev->manufacturer)\n\t\t\tstrlcat(usbtouch->name, \" \", sizeof(usbtouch->name));\n\t\tstrlcat(usbtouch->name, udev->product, sizeof(usbtouch->name));\n\t}\n\n\tif (!strlen(usbtouch->name))\n\t\tsnprintf(usbtouch->name, sizeof(usbtouch->name),\n\t\t\t\"USB Touchscreen %04x:%04x\",\n\t\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t\t le16_to_cpu(udev->descriptor.idProduct));\n\n\tusb_make_path(udev, usbtouch->phys, sizeof(usbtouch->phys));\n\tstrlcat(usbtouch->phys, \"/input0\", sizeof(usbtouch->phys));\n\n\tinput_dev->name = usbtouch->name;\n\tinput_dev->phys = usbtouch->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, usbtouch);\n\n\tinput_dev->open = usbtouch_open;\n\tinput_dev->close = usbtouch_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X, type->min_xc, type->max_xc, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, type->min_yc, type->max_yc, 0, 0);\n\tif (type->max_press)\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, type->min_press,\n\t\t                     type->max_press, 0, 0);\n\n\tif (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)\n\t\tusb_fill_int_urb(usbtouch->irq, udev,\n\t\t\t usb_rcvintpipe(udev, endpoint->bEndpointAddress),\n\t\t\t usbtouch->data, usbtouch->data_size,\n\t\t\t usbtouch_irq, usbtouch, endpoint->bInterval);\n\telse\n\t\tusb_fill_bulk_urb(usbtouch->irq, udev,\n\t\t\t usb_rcvbulkpipe(udev, endpoint->bEndpointAddress),\n\t\t\t usbtouch->data, usbtouch->data_size,\n\t\t\t usbtouch_irq, usbtouch);\n\n\tusbtouch->irq->dev = udev;\n\tusbtouch->irq->transfer_dma = usbtouch->data_dma;\n\tusbtouch->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\tif (type->alloc) {\n\t\terr = type->alloc(usbtouch);\n\t\tif (err) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"%s - type->alloc() failed, err: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\tgoto out_free_urb;\n\t\t}\n\t}\n\n\t \n\tif (type->init) {\n\t\terr = type->init(usbtouch);\n\t\tif (err) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"%s - type->init() failed, err: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\tgoto out_do_exit;\n\t\t}\n\t}\n\n\terr = input_register_device(usbtouch->input);\n\tif (err) {\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"%s - input_register_device failed, err: %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto out_do_exit;\n\t}\n\n\tusb_set_intfdata(intf, usbtouch);\n\n\tif (usbtouch->type->irq_always) {\n\t\t \n\t\tusb_autopm_get_interface(intf);\n\t\terr = usb_submit_urb(usbtouch->irq, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_autopm_put_interface(intf);\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"%s - usb_submit_urb failed with result: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\tgoto out_unregister_input;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_unregister_input:\n\tinput_unregister_device(input_dev);\n\tinput_dev = NULL;\nout_do_exit:\n\tif (type->exit)\n\t\ttype->exit(usbtouch);\nout_free_urb:\n\tusb_free_urb(usbtouch->irq);\nout_free_buffers:\n\tusbtouch_free_buffers(udev, usbtouch);\nout_free:\n\tinput_free_device(input_dev);\n\tkfree(usbtouch);\n\treturn err;\n}\n\nstatic void usbtouch_disconnect(struct usb_interface *intf)\n{\n\tstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\n\n\tif (!usbtouch)\n\t\treturn;\n\n\tdev_dbg(&intf->dev,\n\t\t\"%s - usbtouch is initialized, cleaning up\\n\", __func__);\n\n\tusb_set_intfdata(intf, NULL);\n\t \n\tinput_unregister_device(usbtouch->input);\n\tusb_free_urb(usbtouch->irq);\n\tif (usbtouch->type->exit)\n\t\tusbtouch->type->exit(usbtouch);\n\tusbtouch_free_buffers(interface_to_usbdev(intf), usbtouch);\n\tkfree(usbtouch);\n}\n\nMODULE_DEVICE_TABLE(usb, usbtouch_devices);\n\nstatic struct usb_driver usbtouch_driver = {\n\t.name\t\t= \"usbtouchscreen\",\n\t.probe\t\t= usbtouch_probe,\n\t.disconnect\t= usbtouch_disconnect,\n\t.suspend\t= usbtouch_suspend,\n\t.resume\t\t= usbtouch_resume,\n\t.reset_resume\t= usbtouch_reset_resume,\n\t.id_table\t= usbtouch_devices,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(usbtouch_driver);\n\nMODULE_AUTHOR(\"Daniel Ritz <daniel.ritz@gmx.ch>\");\nMODULE_DESCRIPTION(\"USB Touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS(\"touchkitusb\");\nMODULE_ALIAS(\"itmtouch\");\nMODULE_ALIAS(\"mtouchusb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}