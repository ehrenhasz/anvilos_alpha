{
  "module_name": "mtouch.c",
  "hash_id": "066ba3a64f4b0bf35176cf3948ad1bf4de4fbdd6f2ef6db3aea9a3e88fbb1bc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mtouch.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"MicroTouch serial touchscreen driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define MTOUCH_FORMAT_TABLET_STATUS_BIT 0x80\n#define MTOUCH_FORMAT_TABLET_TOUCH_BIT 0x40\n#define MTOUCH_FORMAT_TABLET_LENGTH 5\n#define MTOUCH_RESPONSE_BEGIN_BYTE 0x01\n#define MTOUCH_RESPONSE_END_BYTE 0x0d\n\n \n#define MTOUCH_MAX_LENGTH 16\n\n#define MTOUCH_MIN_XC 0\n#define MTOUCH_MAX_XC 0x3fff\n#define MTOUCH_MIN_YC 0\n#define MTOUCH_MAX_YC 0x3fff\n\n#define MTOUCH_GET_XC(data) (((data[2])<<7) | data[1])\n#define MTOUCH_GET_YC(data) (((data[4])<<7) | data[3])\n#define MTOUCH_GET_TOUCHED(data) (MTOUCH_FORMAT_TABLET_TOUCH_BIT & data[0])\n\n \n\nstruct mtouch {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tint idx;\n\tunsigned char data[MTOUCH_MAX_LENGTH];\n\tchar phys[32];\n};\n\nstatic void mtouch_process_format_tablet(struct mtouch *mtouch)\n{\n\tstruct input_dev *dev = mtouch->dev;\n\n\tif (MTOUCH_FORMAT_TABLET_LENGTH == ++mtouch->idx) {\n\t\tinput_report_abs(dev, ABS_X, MTOUCH_GET_XC(mtouch->data));\n\t\tinput_report_abs(dev, ABS_Y, MTOUCH_MAX_YC - MTOUCH_GET_YC(mtouch->data));\n\t\tinput_report_key(dev, BTN_TOUCH, MTOUCH_GET_TOUCHED(mtouch->data));\n\t\tinput_sync(dev);\n\n\t\tmtouch->idx = 0;\n\t}\n}\n\nstatic void mtouch_process_response(struct mtouch *mtouch)\n{\n\tif (MTOUCH_RESPONSE_END_BYTE == mtouch->data[mtouch->idx++]) {\n\t\t \n\t\tmtouch->idx = 0;\n\t} else if (MTOUCH_MAX_LENGTH == mtouch->idx) {\n\t\tprintk(KERN_ERR \"mtouch.c: too many response bytes\\n\");\n\t\tmtouch->idx = 0;\n\t}\n}\n\nstatic irqreturn_t mtouch_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct mtouch *mtouch = serio_get_drvdata(serio);\n\n\tmtouch->data[mtouch->idx] = data;\n\n\tif (MTOUCH_FORMAT_TABLET_STATUS_BIT & mtouch->data[0])\n\t\tmtouch_process_format_tablet(mtouch);\n\telse if (MTOUCH_RESPONSE_BEGIN_BYTE == mtouch->data[0])\n\t\tmtouch_process_response(mtouch);\n\telse\n\t\tprintk(KERN_DEBUG \"mtouch.c: unknown/unsynchronized data from device, byte %x\\n\",mtouch->data[0]);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void mtouch_disconnect(struct serio *serio)\n{\n\tstruct mtouch *mtouch = serio_get_drvdata(serio);\n\n\tinput_get_device(mtouch->dev);\n\tinput_unregister_device(mtouch->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_put_device(mtouch->dev);\n\tkfree(mtouch);\n}\n\n \n\nstatic int mtouch_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct mtouch *mtouch;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tmtouch = kzalloc(sizeof(struct mtouch), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!mtouch || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tmtouch->serio = serio;\n\tmtouch->dev = input_dev;\n\tsnprintf(mtouch->phys, sizeof(mtouch->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"MicroTouch Serial TouchScreen\";\n\tinput_dev->phys = mtouch->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_MICROTOUCH;\n\tinput_dev->id.product = 0;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(mtouch->dev, ABS_X, MTOUCH_MIN_XC, MTOUCH_MAX_XC, 0, 0);\n\tinput_set_abs_params(mtouch->dev, ABS_Y, MTOUCH_MIN_YC, MTOUCH_MAX_YC, 0, 0);\n\n\tserio_set_drvdata(serio, mtouch);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(mtouch->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(mtouch);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id mtouch_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_MICROTOUCH,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, mtouch_serio_ids);\n\nstatic struct serio_driver mtouch_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"mtouch\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= mtouch_serio_ids,\n\t.interrupt\t= mtouch_interrupt,\n\t.connect\t= mtouch_connect,\n\t.disconnect\t= mtouch_disconnect,\n};\n\nmodule_serio_driver(mtouch_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}