{
  "module_name": "wm831x-ts.c",
  "hash_id": "3b1ec598a167d19aeca4e3b82850f727ff5854671cbfd34b6518438c02a01748",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wm831x-ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/pm.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/irq.h>\n#include <linux/mfd/wm831x/pdata.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#define WM831X_TCH_ENA                          0x8000   \n#define WM831X_TCH_CVT_ENA                      0x4000   \n#define WM831X_TCH_SLPENA                       0x1000   \n#define WM831X_TCH_Z_ENA                        0x0400   \n#define WM831X_TCH_Y_ENA                        0x0200   \n#define WM831X_TCH_X_ENA                        0x0100   \n#define WM831X_TCH_DELAY_MASK                   0x00E0   \n#define WM831X_TCH_DELAY_SHIFT                       5   \n#define WM831X_TCH_DELAY_WIDTH                       3   \n#define WM831X_TCH_RATE_MASK                    0x001F   \n#define WM831X_TCH_RATE_SHIFT                        0   \n#define WM831X_TCH_RATE_WIDTH                        5   \n\n \n#define WM831X_TCH_PD_WK                        0x2000   \n#define WM831X_TCH_5WIRE                        0x1000   \n#define WM831X_TCH_PDONLY                       0x0800   \n#define WM831X_TCH_ISEL                         0x0100   \n#define WM831X_TCH_RPU_MASK                     0x000F   \n#define WM831X_TCH_RPU_SHIFT                         0   \n#define WM831X_TCH_RPU_WIDTH                         4   \n\n \n#define WM831X_TCH_PD                           0x8000   \n#define WM831X_TCH_DATA_MASK                    0x0FFF   \n#define WM831X_TCH_DATA_SHIFT                        0   \n#define WM831X_TCH_DATA_WIDTH                       12   \n\nstruct wm831x_ts {\n\tstruct input_dev *input_dev;\n\tstruct wm831x *wm831x;\n\tunsigned int data_irq;\n\tunsigned int pd_irq;\n\tbool pressure;\n\tbool pen_down;\n\tstruct work_struct pd_data_work;\n};\n\nstatic void wm831x_pd_data_work(struct work_struct *work)\n{\n\tstruct wm831x_ts *wm831x_ts =\n\t\tcontainer_of(work, struct wm831x_ts, pd_data_work);\n\n\tif (wm831x_ts->pen_down) {\n\t\tenable_irq(wm831x_ts->data_irq);\n\t\tdev_dbg(wm831x_ts->wm831x->dev, \"IRQ PD->DATA done\\n\");\n\t} else {\n\t\tenable_irq(wm831x_ts->pd_irq);\n\t\tdev_dbg(wm831x_ts->wm831x->dev, \"IRQ DATA->PD done\\n\");\n\t}\n}\n\nstatic irqreturn_t wm831x_ts_data_irq(int irq, void *irq_data)\n{\n\tstruct wm831x_ts *wm831x_ts = irq_data;\n\tstruct wm831x *wm831x = wm831x_ts->wm831x;\n\tstatic int data_types[] = { ABS_X, ABS_Y, ABS_PRESSURE };\n\tu16 data[3];\n\tint count;\n\tint i, ret;\n\n\tif (wm831x_ts->pressure)\n\t\tcount = 3;\n\telse\n\t\tcount = 2;\n\n\twm831x_set_bits(wm831x, WM831X_INTERRUPT_STATUS_1,\n\t\t\tWM831X_TCHDATA_EINT, WM831X_TCHDATA_EINT);\n\n\tret = wm831x_bulk_read(wm831x, WM831X_TOUCH_DATA_X, count,\n\t\t\t       data);\n\tif (ret != 0) {\n\t\tdev_err(wm831x->dev, \"Failed to read touch data: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twm831x_ts->pen_down = true;\n\tfor (i = 0; i < count; i++) {\n\t\tif (!(data[i] & WM831X_TCH_PD)) {\n\t\t\twm831x_ts->pen_down = false;\n\t\t\tcontinue;\n\t\t}\n\t\tinput_report_abs(wm831x_ts->input_dev, data_types[i],\n\t\t\t\t data[i] & WM831X_TCH_DATA_MASK);\n\t}\n\n\tif (!wm831x_ts->pen_down) {\n\t\t \n\t\tdev_dbg(wm831x->dev, \"IRQ DATA->PD\\n\");\n\n\t\tdisable_irq_nosync(wm831x_ts->data_irq);\n\n\t\t \n\t\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,\n\t\t\t\tWM831X_TCH_X_ENA | WM831X_TCH_Y_ENA |\n\t\t\t\tWM831X_TCH_Z_ENA, 0);\n\n\t\t \n\t\twm831x_set_bits(wm831x, WM831X_INTERRUPT_STATUS_1,\n\t\t\t\tWM831X_TCHDATA_EINT, WM831X_TCHDATA_EINT);\n\n\t\twm831x_bulk_read(wm831x, WM831X_TOUCH_DATA_X, count, data);\n\n\t\tif (wm831x_ts->pressure)\n\t\t\tinput_report_abs(wm831x_ts->input_dev,\n\t\t\t\t\t ABS_PRESSURE, 0);\n\n\t\tinput_report_key(wm831x_ts->input_dev, BTN_TOUCH, 0);\n\n\t\tschedule_work(&wm831x_ts->pd_data_work);\n\t} else {\n\t\tinput_report_key(wm831x_ts->input_dev, BTN_TOUCH, 1);\n\t}\n\n\tinput_sync(wm831x_ts->input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wm831x_ts_pen_down_irq(int irq, void *irq_data)\n{\n\tstruct wm831x_ts *wm831x_ts = irq_data;\n\tstruct wm831x *wm831x = wm831x_ts->wm831x;\n\tint ena = 0;\n\n\tif (wm831x_ts->pen_down)\n\t\treturn IRQ_HANDLED;\n\n\tdisable_irq_nosync(wm831x_ts->pd_irq);\n\n\t \n\tif (wm831x_ts->pressure)\n\t\tena |= WM831X_TCH_Z_ENA;\n\n\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,\n\t\t\tWM831X_TCH_X_ENA | WM831X_TCH_Y_ENA | WM831X_TCH_Z_ENA,\n\t\t\tWM831X_TCH_X_ENA | WM831X_TCH_Y_ENA | ena);\n\n\twm831x_set_bits(wm831x, WM831X_INTERRUPT_STATUS_1,\n\t\t\tWM831X_TCHPD_EINT, WM831X_TCHPD_EINT);\n\n\twm831x_ts->pen_down = true;\n\n\t \n\tdev_dbg(wm831x->dev, \"IRQ PD->DATA\\n\");\n\tschedule_work(&wm831x_ts->pd_data_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wm831x_ts_input_open(struct input_dev *idev)\n{\n\tstruct wm831x_ts *wm831x_ts = input_get_drvdata(idev);\n\tstruct wm831x *wm831x = wm831x_ts->wm831x;\n\n\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,\n\t\t\tWM831X_TCH_ENA | WM831X_TCH_CVT_ENA |\n\t\t\tWM831X_TCH_X_ENA | WM831X_TCH_Y_ENA |\n\t\t\tWM831X_TCH_Z_ENA, WM831X_TCH_ENA);\n\n\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,\n\t\t\tWM831X_TCH_CVT_ENA, WM831X_TCH_CVT_ENA);\n\n\treturn 0;\n}\n\nstatic void wm831x_ts_input_close(struct input_dev *idev)\n{\n\tstruct wm831x_ts *wm831x_ts = input_get_drvdata(idev);\n\tstruct wm831x *wm831x = wm831x_ts->wm831x;\n\n\t \n\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,\n\t\t\tWM831X_TCH_ENA | WM831X_TCH_X_ENA |\n\t\t\tWM831X_TCH_Y_ENA | WM831X_TCH_Z_ENA, 0);\n\n\t \n\tsynchronize_irq(wm831x_ts->data_irq);\n\tsynchronize_irq(wm831x_ts->pd_irq);\n\n\t \n\tflush_work(&wm831x_ts->pd_data_work);\n\n\t \n\tif (wm831x_ts->pen_down) {\n\t\tdisable_irq(wm831x_ts->data_irq);\n\t\tenable_irq(wm831x_ts->pd_irq);\n\t\twm831x_ts->pen_down = false;\n\t}\n}\n\nstatic int wm831x_ts_probe(struct platform_device *pdev)\n{\n\tstruct wm831x_ts *wm831x_ts;\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *core_pdata = dev_get_platdata(pdev->dev.parent);\n\tstruct wm831x_touch_pdata *pdata = NULL;\n\tstruct input_dev *input_dev;\n\tint error, irqf;\n\n\tif (core_pdata)\n\t\tpdata = core_pdata->touch;\n\n\twm831x_ts = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ts),\n\t\t\t\t GFP_KERNEL);\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!wm831x_ts || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\twm831x_ts->wm831x = wm831x;\n\twm831x_ts->input_dev = input_dev;\n\tINIT_WORK(&wm831x_ts->pd_data_work, wm831x_pd_data_work);\n\n\t \n\twm831x_ts->data_irq = wm831x_irq(wm831x,\n\t\t\t\t\t platform_get_irq_byname(pdev,\n\t\t\t\t\t\t\t\t \"TCHDATA\"));\n\tif (pdata && pdata->data_irq)\n\t\twm831x_ts->data_irq = pdata->data_irq;\n\n\twm831x_ts->pd_irq = wm831x_irq(wm831x,\n\t\t\t\t       platform_get_irq_byname(pdev, \"TCHPD\"));\n\tif (pdata && pdata->pd_irq)\n\t\twm831x_ts->pd_irq = pdata->pd_irq;\n\n\tif (pdata)\n\t\twm831x_ts->pressure = pdata->pressure;\n\telse\n\t\twm831x_ts->pressure = true;\n\n\t \n\tif (pdata && pdata->fivewire) {\n\t\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,\n\t\t\t\tWM831X_TCH_5WIRE, WM831X_TCH_5WIRE);\n\n\t\t \n\t\tWARN_ON(pdata->pressure && pdata->fivewire);\n\t\twm831x_ts->pressure = false;\n\t} else {\n\t\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,\n\t\t\t\tWM831X_TCH_5WIRE, 0);\n\t}\n\n\tif (pdata) {\n\t\tswitch (pdata->isel) {\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"Unsupported ISEL setting: %d\\n\",\n\t\t\t\tpdata->isel);\n\t\t\tfallthrough;\n\t\tcase 200:\n\t\tcase 0:\n\t\t\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,\n\t\t\t\t\tWM831X_TCH_ISEL, 0);\n\t\t\tbreak;\n\t\tcase 400:\n\t\t\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,\n\t\t\t\t\tWM831X_TCH_ISEL, WM831X_TCH_ISEL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_2,\n\t\t\tWM831X_TCH_PDONLY, 0);\n\n\t \n\twm831x_set_bits(wm831x, WM831X_TOUCH_CONTROL_1,\n\t\t\tWM831X_TCH_RATE_MASK, 6);\n\n\tif (pdata && pdata->data_irqf)\n\t\tirqf = pdata->data_irqf;\n\telse\n\t\tirqf = IRQF_TRIGGER_HIGH;\n\n\terror = request_threaded_irq(wm831x_ts->data_irq,\n\t\t\t\t     NULL, wm831x_ts_data_irq,\n\t\t\t\t     irqf | IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t     \"Touchscreen data\", wm831x_ts);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to request data IRQ %d: %d\\n\",\n\t\t\twm831x_ts->data_irq, error);\n\t\tgoto err_alloc;\n\t}\n\n\tif (pdata && pdata->pd_irqf)\n\t\tirqf = pdata->pd_irqf;\n\telse\n\t\tirqf = IRQF_TRIGGER_HIGH;\n\n\terror = request_threaded_irq(wm831x_ts->pd_irq,\n\t\t\t\t     NULL, wm831x_ts_pen_down_irq,\n\t\t\t\t     irqf | IRQF_ONESHOT,\n\t\t\t\t     \"Touchscreen pen down\", wm831x_ts);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to request pen down IRQ %d: %d\\n\",\n\t\t\twm831x_ts->pd_irq, error);\n\t\tgoto err_data_irq;\n\t}\n\n\t \n\tinput_dev->name = \"WM831x touchscreen\";\n\tinput_dev->phys = \"wm831x\";\n\tinput_dev->open = wm831x_ts_input_open;\n\tinput_dev->close = wm831x_ts_input_close;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, 4095, 5, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 4095, 5, 0);\n\tif (wm831x_ts->pressure)\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 4095, 5, 0);\n\n\tinput_set_drvdata(input_dev, wm831x_ts);\n\tinput_dev->dev.parent = &pdev->dev;\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\tgoto err_pd_irq;\n\n\tplatform_set_drvdata(pdev, wm831x_ts);\n\treturn 0;\n\nerr_pd_irq:\n\tfree_irq(wm831x_ts->pd_irq, wm831x_ts);\nerr_data_irq:\n\tfree_irq(wm831x_ts->data_irq, wm831x_ts);\nerr_alloc:\n\n\treturn error;\n}\n\nstatic int wm831x_ts_remove(struct platform_device *pdev)\n{\n\tstruct wm831x_ts *wm831x_ts = platform_get_drvdata(pdev);\n\n\tfree_irq(wm831x_ts->pd_irq, wm831x_ts);\n\tfree_irq(wm831x_ts->data_irq, wm831x_ts);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wm831x_ts_driver = {\n\t.driver = {\n\t\t.name = \"wm831x-touch\",\n\t},\n\t.probe = wm831x_ts_probe,\n\t.remove = wm831x_ts_remove,\n};\nmodule_platform_driver(wm831x_ts_driver);\n\n \nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM831x PMIC touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-touch\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}