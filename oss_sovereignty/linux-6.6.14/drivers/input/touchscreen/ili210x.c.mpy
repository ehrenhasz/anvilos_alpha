{
  "module_name": "ili210x.c",
  "hash_id": "13a7124a7647ac01ec28fa22eecc8bec0c8e24d08d54dce045bf262f8e0d0320",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ili210x.c",
  "human_readable_source": "\n#include <linux/crc-ccitt.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/ihex.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define ILI2XXX_POLL_PERIOD\t15\n\n#define ILI210X_DATA_SIZE\t64\n#define ILI211X_DATA_SIZE\t43\n#define ILI251X_DATA_SIZE1\t31\n#define ILI251X_DATA_SIZE2\t20\n\n \n#define REG_TOUCHDATA\t\t0x10\n#define REG_PANEL_INFO\t\t0x20\n#define REG_FIRMWARE_VERSION\t0x40\n#define REG_PROTOCOL_VERSION\t0x42\n#define REG_KERNEL_VERSION\t0x61\n#define REG_IC_BUSY\t\t0x80\n#define REG_IC_BUSY_NOT_BUSY\t0x50\n#define REG_GET_MODE\t\t0xc0\n#define REG_GET_MODE_AP\t\t0x5a\n#define REG_GET_MODE_BL\t\t0x55\n#define REG_SET_MODE_AP\t\t0xc1\n#define REG_SET_MODE_BL\t\t0xc2\n#define REG_WRITE_DATA\t\t0xc3\n#define REG_WRITE_ENABLE\t0xc4\n#define REG_READ_DATA_CRC\t0xc7\n#define REG_CALIBRATE\t\t0xcc\n\n#define ILI251X_FW_FILENAME\t\"ilitek/ili251x.bin\"\n\nstruct ili2xxx_chip {\n\tint (*read_reg)(struct i2c_client *client, u8 reg,\n\t\t\tvoid *buf, size_t len);\n\tint (*get_touch_data)(struct i2c_client *client, u8 *data);\n\tbool (*parse_touch_data)(const u8 *data, unsigned int finger,\n\t\t\t\t unsigned int *x, unsigned int *y,\n\t\t\t\t unsigned int *z);\n\tbool (*continue_polling)(const u8 *data, bool touch);\n\tunsigned int max_touches;\n\tunsigned int resolution;\n\tbool has_calibrate_reg;\n\tbool has_firmware_proto;\n\tbool has_pressure_reg;\n};\n\nstruct ili210x {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *reset_gpio;\n\tstruct touchscreen_properties prop;\n\tconst struct ili2xxx_chip *chip;\n\tu8 version_firmware[8];\n\tu8 version_kernel[5];\n\tu8 version_proto[2];\n\tu8 ic_mode[2];\n\tbool stop;\n};\n\nstatic int ili210x_read_reg(struct i2c_client *client,\n\t\t\t    u8 reg, void *buf, size_t len)\n{\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &reg,\n\t\t},\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= len,\n\t\t\t.buf\t= buf,\n\t\t}\n\t};\n\tint error, ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&client->dev, \"%s failed: %d\\n\", __func__, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ili210x_read_touch_data(struct i2c_client *client, u8 *data)\n{\n\treturn ili210x_read_reg(client, REG_TOUCHDATA,\n\t\t\t\tdata, ILI210X_DATA_SIZE);\n}\n\nstatic bool ili210x_touchdata_to_coords(const u8 *touchdata,\n\t\t\t\t\tunsigned int finger,\n\t\t\t\t\tunsigned int *x, unsigned int *y,\n\t\t\t\t\tunsigned int *z)\n{\n\tif (!(touchdata[0] & BIT(finger)))\n\t\treturn false;\n\n\t*x = get_unaligned_be16(touchdata + 1 + (finger * 4) + 0);\n\t*y = get_unaligned_be16(touchdata + 1 + (finger * 4) + 2);\n\n\treturn true;\n}\n\nstatic bool ili210x_check_continue_polling(const u8 *data, bool touch)\n{\n\treturn data[0] & 0xf3;\n}\n\nstatic const struct ili2xxx_chip ili210x_chip = {\n\t.read_reg\t\t= ili210x_read_reg,\n\t.get_touch_data\t\t= ili210x_read_touch_data,\n\t.parse_touch_data\t= ili210x_touchdata_to_coords,\n\t.continue_polling\t= ili210x_check_continue_polling,\n\t.max_touches\t\t= 2,\n\t.has_calibrate_reg\t= true,\n};\n\nstatic int ili211x_read_touch_data(struct i2c_client *client, u8 *data)\n{\n\ts16 sum = 0;\n\tint error;\n\tint ret;\n\tint i;\n\n\tret = i2c_master_recv(client, data, ILI211X_DATA_SIZE);\n\tif (ret != ILI211X_DATA_SIZE) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&client->dev, \"%s failed: %d\\n\", __func__, error);\n\t\treturn error;\n\t}\n\n\t \n\tfor (i = 0; i < ILI211X_DATA_SIZE - 1; i++)\n\t\tsum = (sum + data[i]) & 0xff;\n\n\tif ((-sum & 0xff) != data[ILI211X_DATA_SIZE - 1]) {\n\t\tdev_err(&client->dev,\n\t\t\t\"CRC error (crc=0x%02x expected=0x%02x)\\n\",\n\t\t\tsum, data[ILI211X_DATA_SIZE - 1]);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ili211x_touchdata_to_coords(const u8 *touchdata,\n\t\t\t\t\tunsigned int finger,\n\t\t\t\t\tunsigned int *x, unsigned int *y,\n\t\t\t\t\tunsigned int *z)\n{\n\tu32 data;\n\n\tdata = get_unaligned_be32(touchdata + 1 + (finger * 4) + 0);\n\tif (data == 0xffffffff)\t \n\t\treturn false;\n\n\t*x = ((touchdata[1 + (finger * 4) + 0] & 0xf0) << 4) |\n\t     touchdata[1 + (finger * 4) + 1];\n\t*y = ((touchdata[1 + (finger * 4) + 0] & 0x0f) << 8) |\n\t     touchdata[1 + (finger * 4) + 2];\n\n\treturn true;\n}\n\nstatic bool ili211x_decline_polling(const u8 *data, bool touch)\n{\n\treturn false;\n}\n\nstatic const struct ili2xxx_chip ili211x_chip = {\n\t.read_reg\t\t= ili210x_read_reg,\n\t.get_touch_data\t\t= ili211x_read_touch_data,\n\t.parse_touch_data\t= ili211x_touchdata_to_coords,\n\t.continue_polling\t= ili211x_decline_polling,\n\t.max_touches\t\t= 10,\n\t.resolution\t\t= 2048,\n};\n\nstatic bool ili212x_touchdata_to_coords(const u8 *touchdata,\n\t\t\t\t\tunsigned int finger,\n\t\t\t\t\tunsigned int *x, unsigned int *y,\n\t\t\t\t\tunsigned int *z)\n{\n\tu16 val;\n\n\tval = get_unaligned_be16(touchdata + 3 + (finger * 5) + 0);\n\tif (!(val & BIT(15)))\t \n\t\treturn false;\n\n\t*x = val & 0x3fff;\n\t*y = get_unaligned_be16(touchdata + 3 + (finger * 5) + 2);\n\n\treturn true;\n}\n\nstatic bool ili212x_check_continue_polling(const u8 *data, bool touch)\n{\n\treturn touch;\n}\n\nstatic const struct ili2xxx_chip ili212x_chip = {\n\t.read_reg\t\t= ili210x_read_reg,\n\t.get_touch_data\t\t= ili210x_read_touch_data,\n\t.parse_touch_data\t= ili212x_touchdata_to_coords,\n\t.continue_polling\t= ili212x_check_continue_polling,\n\t.max_touches\t\t= 10,\n\t.has_calibrate_reg\t= true,\n};\n\nstatic int ili251x_read_reg_common(struct i2c_client *client,\n\t\t\t\t   u8 reg, void *buf, size_t len,\n\t\t\t\t   unsigned int delay)\n{\n\tint error;\n\tint ret;\n\n\tret = i2c_master_send(client, &reg, 1);\n\tif (ret == 1) {\n\t\tif (delay)\n\t\t\tusleep_range(delay, delay + 500);\n\n\t\tret = i2c_master_recv(client, buf, len);\n\t\tif (ret == len)\n\t\t\treturn 0;\n\t}\n\n\terror = ret < 0 ? ret : -EIO;\n\tdev_err(&client->dev, \"%s failed: %d\\n\", __func__, error);\n\treturn ret;\n}\n\nstatic int ili251x_read_reg(struct i2c_client *client,\n\t\t\t    u8 reg, void *buf, size_t len)\n{\n\treturn ili251x_read_reg_common(client, reg, buf, len, 5000);\n}\n\nstatic int ili251x_read_touch_data(struct i2c_client *client, u8 *data)\n{\n\tint error;\n\n\terror = ili251x_read_reg_common(client, REG_TOUCHDATA,\n\t\t\t\t\tdata, ILI251X_DATA_SIZE1, 0);\n\tif (!error && data[0] == 2) {\n\t\terror = i2c_master_recv(client, data + ILI251X_DATA_SIZE1,\n\t\t\t\t\tILI251X_DATA_SIZE2);\n\t\tif (error >= 0 && error != ILI251X_DATA_SIZE2)\n\t\t\terror = -EIO;\n\t}\n\n\treturn error;\n}\n\nstatic bool ili251x_touchdata_to_coords(const u8 *touchdata,\n\t\t\t\t\tunsigned int finger,\n\t\t\t\t\tunsigned int *x, unsigned int *y,\n\t\t\t\t\tunsigned int *z)\n{\n\tu16 val;\n\n\tval = get_unaligned_be16(touchdata + 1 + (finger * 5) + 0);\n\tif (!(val & BIT(15)))\t \n\t\treturn false;\n\n\t*x = val & 0x3fff;\n\t*y = get_unaligned_be16(touchdata + 1 + (finger * 5) + 2);\n\t*z = touchdata[1 + (finger * 5) + 4];\n\n\treturn true;\n}\n\nstatic bool ili251x_check_continue_polling(const u8 *data, bool touch)\n{\n\treturn touch;\n}\n\nstatic const struct ili2xxx_chip ili251x_chip = {\n\t.read_reg\t\t= ili251x_read_reg,\n\t.get_touch_data\t\t= ili251x_read_touch_data,\n\t.parse_touch_data\t= ili251x_touchdata_to_coords,\n\t.continue_polling\t= ili251x_check_continue_polling,\n\t.max_touches\t\t= 10,\n\t.has_calibrate_reg\t= true,\n\t.has_firmware_proto\t= true,\n\t.has_pressure_reg\t= true,\n};\n\nstatic bool ili210x_report_events(struct ili210x *priv, u8 *touchdata)\n{\n\tstruct input_dev *input = priv->input;\n\tint i;\n\tbool contact = false, touch;\n\tunsigned int x = 0, y = 0, z = 0;\n\n\tfor (i = 0; i < priv->chip->max_touches; i++) {\n\t\ttouch = priv->chip->parse_touch_data(touchdata, i, &x, &y, &z);\n\n\t\tinput_mt_slot(input, i);\n\t\tif (input_mt_report_slot_state(input, MT_TOOL_FINGER, touch)) {\n\t\t\ttouchscreen_report_pos(input, &priv->prop, x, y, true);\n\t\t\tif (priv->chip->has_pressure_reg)\n\t\t\t\tinput_report_abs(input, ABS_MT_PRESSURE, z);\n\t\t\tcontact = true;\n\t\t}\n\t}\n\n\tinput_mt_report_pointer_emulation(input, false);\n\tinput_sync(input);\n\n\treturn contact;\n}\n\nstatic irqreturn_t ili210x_irq(int irq, void *irq_data)\n{\n\tstruct ili210x *priv = irq_data;\n\tstruct i2c_client *client = priv->client;\n\tconst struct ili2xxx_chip *chip = priv->chip;\n\tu8 touchdata[ILI210X_DATA_SIZE] = { 0 };\n\tbool keep_polling;\n\tktime_t time_next;\n\ts64 time_delta;\n\tbool touch;\n\tint error;\n\n\tdo {\n\t\ttime_next = ktime_add_ms(ktime_get(), ILI2XXX_POLL_PERIOD);\n\t\terror = chip->get_touch_data(client, touchdata);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to get touch data: %d\\n\", error);\n\t\t\tbreak;\n\t\t}\n\n\t\ttouch = ili210x_report_events(priv, touchdata);\n\t\tkeep_polling = chip->continue_polling(touchdata, touch);\n\t\tif (keep_polling) {\n\t\t\ttime_delta = ktime_us_delta(time_next, ktime_get());\n\t\t\tif (time_delta > 0)\n\t\t\t\tusleep_range(time_delta, time_delta + 1000);\n\t\t}\n\t} while (!priv->stop && keep_polling);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ili251x_firmware_update_resolution(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu16 resx, resy;\n\tu8 rs[10];\n\tint error;\n\n\t \n\terror = priv->chip->read_reg(client, REG_PANEL_INFO, &rs, sizeof(rs));\n\tif (!error) {\n\t\tresx = le16_to_cpup((__le16 *)rs);\n\t\tresy = le16_to_cpup((__le16 *)(rs + 2));\n\n\t\t \n\t\tif (!resx || resx == 0xffff || !resy || resy == 0xffff)\n\t\t\terror = -EINVAL;\n\t}\n\n\t \n\tif (error) {\n\t\tdev_warn(dev, \"Invalid resolution reported by controller.\\n\");\n\t\tresx = 16384;\n\t\tresy = 16384;\n\t}\n\n\tinput_abs_set_max(priv->input, ABS_X, resx - 1);\n\tinput_abs_set_max(priv->input, ABS_Y, resy - 1);\n\tinput_abs_set_max(priv->input, ABS_MT_POSITION_X, resx - 1);\n\tinput_abs_set_max(priv->input, ABS_MT_POSITION_Y, resy - 1);\n\n\treturn error;\n}\n\nstatic ssize_t ili251x_firmware_update_firmware_version(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tint error;\n\tu8 fw[8];\n\n\t \n\terror = priv->chip->read_reg(client, REG_FIRMWARE_VERSION,\n\t\t\t\t     &fw, sizeof(fw));\n\tif (!error)\n\t\tmemcpy(priv->version_firmware, fw, sizeof(fw));\n\n\treturn error;\n}\n\nstatic ssize_t ili251x_firmware_update_kernel_version(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tint error;\n\tu8 kv[5];\n\n\t \n\terror = priv->chip->read_reg(client, REG_KERNEL_VERSION,\n\t\t\t\t     &kv, sizeof(kv));\n\tif (!error)\n\t\tmemcpy(priv->version_kernel, kv, sizeof(kv));\n\n\treturn error;\n}\n\nstatic ssize_t ili251x_firmware_update_protocol_version(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tint error;\n\tu8 pv[2];\n\n\t \n\terror = priv->chip->read_reg(client, REG_PROTOCOL_VERSION,\n\t\t\t\t     &pv, sizeof(pv));\n\tif (!error)\n\t\tmemcpy(priv->version_proto, pv, sizeof(pv));\n\n\treturn error;\n}\n\nstatic ssize_t ili251x_firmware_update_ic_mode(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tint error;\n\tu8 md[2];\n\n\t \n\terror = priv->chip->read_reg(client, REG_GET_MODE, &md, sizeof(md));\n\tif (!error)\n\t\tmemcpy(priv->ic_mode, md, sizeof(md));\n\n\treturn error;\n}\n\nstatic int ili251x_firmware_update_cached_state(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tint error;\n\n\tif (!priv->chip->has_firmware_proto)\n\t\treturn 0;\n\n\t \n\tmsleep(200);\n\n\t \n\terror = ili251x_firmware_update_resolution(dev);\n\tif (error)\n\t\treturn error;\n\n\terror = ili251x_firmware_update_firmware_version(dev);\n\tif (error)\n\t\treturn error;\n\n\terror = ili251x_firmware_update_kernel_version(dev);\n\tif (error)\n\t\treturn error;\n\n\terror = ili251x_firmware_update_protocol_version(dev);\n\tif (error)\n\t\treturn error;\n\n\terror = ili251x_firmware_update_ic_mode(dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic ssize_t ili251x_firmware_version_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu8 *fw = priv->version_firmware;\n\n\treturn sysfs_emit(buf, \"%02x%02x.%02x%02x.%02x%02x.%02x%02x\\n\",\n\t\t\t  fw[0], fw[1], fw[2], fw[3],\n\t\t\t  fw[4], fw[5], fw[6], fw[7]);\n}\nstatic DEVICE_ATTR(firmware_version, 0444, ili251x_firmware_version_show, NULL);\n\nstatic ssize_t ili251x_kernel_version_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu8 *kv = priv->version_kernel;\n\n\treturn sysfs_emit(buf, \"%02x.%02x.%02x.%02x.%02x\\n\",\n\t\t\t  kv[0], kv[1], kv[2], kv[3], kv[4]);\n}\nstatic DEVICE_ATTR(kernel_version, 0444, ili251x_kernel_version_show, NULL);\n\nstatic ssize_t ili251x_protocol_version_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu8 *pv = priv->version_proto;\n\n\treturn sysfs_emit(buf, \"%02x.%02x\\n\", pv[0], pv[1]);\n}\nstatic DEVICE_ATTR(protocol_version, 0444, ili251x_protocol_version_show, NULL);\n\nstatic ssize_t ili251x_mode_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu8 *md = priv->ic_mode;\n\tchar *mode = \"AP\";\n\n\tif (md[0] == REG_GET_MODE_AP)\t\t \n\t\tmode = \"AP\";\n\telse if (md[0] == REG_GET_MODE_BL)\t \n\t\tmode = \"BL\";\n\telse\t\t\t\t\t \n\t\tmode = \"??\";\n\n\treturn sysfs_emit(buf, \"%02x.%02x:%s\\n\", md[0], md[1], mode);\n}\nstatic DEVICE_ATTR(mode, 0444, ili251x_mode_show, NULL);\n\nstatic ssize_t ili210x_calibrate(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tunsigned long calibrate;\n\tint rc;\n\tu8 cmd = REG_CALIBRATE;\n\n\tif (kstrtoul(buf, 10, &calibrate))\n\t\treturn -EINVAL;\n\n\tif (calibrate > 1)\n\t\treturn -EINVAL;\n\n\tif (calibrate) {\n\t\trc = i2c_master_send(priv->client, &cmd, sizeof(cmd));\n\t\tif (rc != sizeof(cmd))\n\t\t\treturn -EIO;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(calibrate, S_IWUSR, NULL, ili210x_calibrate);\n\nstatic int ili251x_firmware_to_buffer(const struct firmware *fw,\n\t\t\t\t      u8 **buf, u16 *ac_end, u16 *df_end)\n{\n\tconst struct ihex_binrec *rec;\n\tu32 fw_addr, fw_last_addr = 0;\n\tu16 fw_len;\n\tu8 *fw_buf;\n\tint error;\n\n\t \n\tfw_buf = kzalloc(SZ_64K, GFP_KERNEL);\n\tif (!fw_buf)\n\t\treturn -ENOMEM;\n\n\trec = (const struct ihex_binrec *)fw->data;\n\twhile (rec) {\n\t\tfw_addr = be32_to_cpu(rec->addr);\n\t\tfw_len = be16_to_cpu(rec->len);\n\n\t\t \n\t\tif (fw_addr + fw_len > SZ_64K || fw_addr > SZ_64K - 32) {\n\t\t\terror = -EFBIG;\n\t\t\tgoto err_big;\n\t\t}\n\n\t\t \n\t\tif (fw_addr == 0xf000)\n\t\t\t*ac_end = fw_last_addr;\n\t\tfw_last_addr = fw_addr + fw_len;\n\n\t\tmemcpy(fw_buf + fw_addr, rec->data, fw_len);\n\t\trec = ihex_next_binrec(rec);\n\t}\n\n\t \n\t*df_end = fw_addr + fw_len;\n\t*buf = fw_buf;\n\treturn 0;\n\nerr_big:\n\tkfree(fw_buf);\n\treturn error;\n}\n\n \nstatic int ili251x_switch_ic_mode(struct i2c_client *client, u8 cmd_mode)\n{\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu8 cmd_wren[3] = { REG_WRITE_ENABLE, 0x5a, 0xa5 };\n\tu8 md[2];\n\tint error;\n\n\terror = priv->chip->read_reg(client, REG_GET_MODE, md, sizeof(md));\n\tif (error)\n\t\treturn error;\n\t \n\tif ((cmd_mode == REG_SET_MODE_AP && md[0] == REG_GET_MODE_AP) ||\n\t    (cmd_mode == REG_SET_MODE_BL && md[0] == REG_GET_MODE_BL))\n\t\treturn 0;\n\n\t \n\terror = i2c_master_send(client, cmd_wren, sizeof(cmd_wren));\n\tif (error != sizeof(cmd_wren))\n\t\treturn -EINVAL;\n\n\tmdelay(20);\n\n\t \n\terror = i2c_master_send(client, &cmd_mode, 1);\n\tif (error != 1)\n\t\treturn -EINVAL;\n\n\tmdelay(200);\t \n\n\t \n\terror = priv->chip->read_reg(client, REG_GET_MODE, md, sizeof(md));\n\tif (error)\n\t\treturn error;\n\t \n\tif ((cmd_mode == REG_SET_MODE_AP && md[0] == REG_GET_MODE_AP) ||\n\t    (cmd_mode == REG_SET_MODE_BL && md[0] == REG_GET_MODE_BL))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int ili251x_firmware_busy(struct i2c_client *client)\n{\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tint error, i = 0;\n\tu8 data;\n\n\tdo {\n\t\t \n\t\terror = priv->chip->read_reg(client, REG_IC_BUSY, &data, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (i++ == 100000)\n\t\t\treturn -ETIMEDOUT;\n\t} while (data != REG_IC_BUSY_NOT_BUSY);\n\n\treturn 0;\n}\n\nstatic int ili251x_firmware_write_to_ic(struct device *dev, u8 *fwbuf,\n\t\t\t\t\tu16 start, u16 end, u8 dataflash)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tu8 cmd_crc = REG_READ_DATA_CRC;\n\tu8 crcrb[4] = { 0 };\n\tu8 fw_data[33];\n\tu16 fw_addr;\n\tint error;\n\n\t \n\tu16 crc = crc_ccitt(0, fwbuf + start + (dataflash ? 2 : 0),\n\t\t\t    end - start - 2);\n\n\t \n\tu8 cmd_wr[10] = {\n\t\tREG_WRITE_ENABLE, 0x5a, 0xa5, dataflash,\n\t\t(end >> 16) & 0xff, (end >> 8) & 0xff, end & 0xff,\n\t\t(crc >> 16) & 0xff, (crc >> 8) & 0xff, crc & 0xff\n\t};\n\n\terror = i2c_master_send(client, cmd_wr, sizeof(cmd_wr));\n\tif (error != sizeof(cmd_wr))\n\t\treturn -EINVAL;\n\n\terror = ili251x_firmware_busy(client);\n\tif (error)\n\t\treturn error;\n\n\tfor (fw_addr = start; fw_addr < end; fw_addr += 32) {\n\t\tfw_data[0] = REG_WRITE_DATA;\n\t\tmemcpy(&(fw_data[1]), fwbuf + fw_addr, 32);\n\t\terror = i2c_master_send(client, fw_data, 33);\n\t\tif (error != sizeof(fw_data))\n\t\t\treturn error;\n\t\terror = ili251x_firmware_busy(client);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = i2c_master_send(client, &cmd_crc, 1);\n\tif (error != 1)\n\t\treturn -EINVAL;\n\n\terror = ili251x_firmware_busy(client);\n\tif (error)\n\t\treturn error;\n\n\terror = priv->chip->read_reg(client, REG_READ_DATA_CRC,\n\t\t\t\t   &crcrb, sizeof(crcrb));\n\tif (error)\n\t\treturn error;\n\n\t \n\tif ((crcrb[0] != (crc & 0xff)) || crcrb[1] != ((crc >> 8) & 0xff))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ili251x_firmware_reset(struct i2c_client *client)\n{\n\tu8 cmd_reset[2] = { 0xf2, 0x01 };\n\tint error;\n\n\terror = i2c_master_send(client, cmd_reset, sizeof(cmd_reset));\n\tif (error != sizeof(cmd_reset))\n\t\treturn -EINVAL;\n\n\treturn ili251x_firmware_busy(client);\n}\n\nstatic void ili210x_hardware_reset(struct gpio_desc *reset_gpio)\n{\n\t \n\tgpiod_set_value_cansleep(reset_gpio, 1);\n\tusleep_range(12000, 15000);\n\tgpiod_set_value_cansleep(reset_gpio, 0);\n\tmsleep(300);\n}\n\nstatic ssize_t ili210x_firmware_update_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\tconst char *fwname = ILI251X_FW_FILENAME;\n\tconst struct firmware *fw;\n\tu16 ac_end, df_end;\n\tu8 *fwbuf;\n\tint error;\n\tint i;\n\n\terror = request_ihex_firmware(&fw, fwname, dev);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request firmware %s, error=%d\\n\",\n\t\t\tfwname, error);\n\t\treturn error;\n\t}\n\n\terror = ili251x_firmware_to_buffer(fw, &fwbuf, &ac_end, &df_end);\n\trelease_firmware(fw);\n\tif (error)\n\t\treturn error;\n\n\t \n\tdisable_irq(client->irq);\n\n\tdev_dbg(dev, \"Firmware update started, firmware=%s\\n\", fwname);\n\n\tili210x_hardware_reset(priv->reset_gpio);\n\n\terror = ili251x_firmware_reset(client);\n\tif (error)\n\t\tgoto exit;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\terror = ili251x_switch_ic_mode(client, REG_SET_MODE_BL);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tif (error)\n\t\tgoto exit;\n\n\tdev_dbg(dev, \"IC is now in BootLoader mode\\n\");\n\n\tmsleep(200);\t \n\n\terror = ili251x_firmware_write_to_ic(dev, fwbuf, 0xf000, df_end, 1);\n\tif (error) {\n\t\tdev_err(dev, \"DF firmware update failed, error=%d\\n\", error);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"DataFlash firmware written\\n\");\n\n\terror = ili251x_firmware_write_to_ic(dev, fwbuf, 0x2000, ac_end, 0);\n\tif (error) {\n\t\tdev_err(dev, \"AC firmware update failed, error=%d\\n\", error);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"Application firmware written\\n\");\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\terror = ili251x_switch_ic_mode(client, REG_SET_MODE_AP);\n\t\tif (!error)\n\t\t\tbreak;\n\t}\n\n\tif (error)\n\t\tgoto exit;\n\n\tdev_dbg(dev, \"IC is now in Application mode\\n\");\n\n\terror = ili251x_firmware_update_cached_state(dev);\n\tif (error)\n\t\tgoto exit;\n\n\terror = count;\n\nexit:\n\tili210x_hardware_reset(priv->reset_gpio);\n\tdev_dbg(dev, \"Firmware update ended, error=%i\\n\", error);\n\tenable_irq(client->irq);\n\tkfree(fwbuf);\n\treturn error;\n}\n\nstatic DEVICE_ATTR(firmware_update, 0200, NULL, ili210x_firmware_update_store);\n\nstatic struct attribute *ili210x_attributes[] = {\n\t&dev_attr_calibrate.attr,\n\t&dev_attr_firmware_update.attr,\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_kernel_version.attr,\n\t&dev_attr_protocol_version.attr,\n\t&dev_attr_mode.attr,\n\tNULL,\n};\n\nstatic umode_t ili210x_attributes_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ili210x *priv = i2c_get_clientdata(client);\n\n\t \n\tif (attr == &dev_attr_calibrate.attr)\n\t\treturn priv->chip->has_calibrate_reg ? attr->mode : 0;\n\n\t \n\tif (!priv->chip->has_firmware_proto)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group ili210x_attr_group = {\n\t.attrs = ili210x_attributes,\n\t.is_visible = ili210x_attributes_visible,\n};\n\nstatic void ili210x_power_down(void *data)\n{\n\tstruct gpio_desc *reset_gpio = data;\n\n\tgpiod_set_value_cansleep(reset_gpio, 1);\n}\n\nstatic void ili210x_stop(void *data)\n{\n\tstruct ili210x *priv = data;\n\n\t \n\tpriv->stop = true;\n}\n\nstatic int ili210x_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tconst struct ili2xxx_chip *chip;\n\tstruct ili210x *priv;\n\tstruct gpio_desc *reset_gpio;\n\tstruct input_dev *input;\n\tint error;\n\tunsigned int max_xy;\n\n\tdev_dbg(dev, \"Probing for ILI210X I2C Touschreen driver\");\n\n\tchip = device_get_match_data(dev);\n\tif (!chip && id)\n\t\tchip = (const struct ili2xxx_chip *)id->driver_data;\n\tif (!chip) {\n\t\tdev_err(&client->dev, \"unknown device model\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (client->irq <= 0) {\n\t\tdev_err(dev, \"No IRQ!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset_gpio))\n\t\treturn PTR_ERR(reset_gpio);\n\n\tif (reset_gpio) {\n\t\terror = devm_add_action_or_reset(dev, ili210x_power_down,\n\t\t\t\t\t\t reset_gpio);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tili210x_hardware_reset(reset_gpio);\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\tpriv->input = input;\n\tpriv->reset_gpio = reset_gpio;\n\tpriv->chip = chip;\n\ti2c_set_clientdata(client, priv);\n\n\t \n\tinput->name = \"ILI210x Touchscreen\";\n\tinput->id.bustype = BUS_I2C;\n\n\t \n\tmax_xy = (chip->resolution ?: SZ_64K) - 1;\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, max_xy, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_xy, 0, 0);\n\tif (priv->chip->has_pressure_reg)\n\t\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xa, 0, 0);\n\terror = ili251x_firmware_update_cached_state(dev);\n\tif (error)\n\t\tdev_warn(dev, \"Unable to cache firmware information, err: %d\\n\",\n\t\t\t error);\n\n\ttouchscreen_parse_properties(input, true, &priv->prop);\n\n\terror = input_mt_init_slots(input, priv->chip->max_touches,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to set up slots, err: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, ili210x_irq,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, priv);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to request touchscreen IRQ, err: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, ili210x_stop, priv);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_device_add_group(dev, &ili210x_attr_group);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to create sysfs attributes, err: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(priv->input);\n\tif (error) {\n\t\tdev_err(dev, \"Cannot register input device, err: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ili210x_i2c_id[] = {\n\t{ \"ili210x\", (long)&ili210x_chip },\n\t{ \"ili2117\", (long)&ili211x_chip },\n\t{ \"ili2120\", (long)&ili212x_chip },\n\t{ \"ili251x\", (long)&ili251x_chip },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ili210x_i2c_id);\n\nstatic const struct of_device_id ili210x_dt_ids[] = {\n\t{ .compatible = \"ilitek,ili210x\", .data = &ili210x_chip },\n\t{ .compatible = \"ilitek,ili2117\", .data = &ili211x_chip },\n\t{ .compatible = \"ilitek,ili2120\", .data = &ili212x_chip },\n\t{ .compatible = \"ilitek,ili251x\", .data = &ili251x_chip },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ili210x_dt_ids);\n\nstatic struct i2c_driver ili210x_ts_driver = {\n\t.driver = {\n\t\t.name = \"ili210x_i2c\",\n\t\t.of_match_table = ili210x_dt_ids,\n\t},\n\t.id_table = ili210x_i2c_id,\n\t.probe = ili210x_i2c_probe,\n};\n\nmodule_i2c_driver(ili210x_ts_driver);\n\nMODULE_AUTHOR(\"Olivier Sobrie <olivier@sobrie.be>\");\nMODULE_DESCRIPTION(\"ILI210X I2C Touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}