{
  "module_name": "da9034-ts.c",
  "hash_id": "a56c8c010839300b94bcb842bb1859ea84a508f22571d43c579f0dd1acc543df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/da9034-ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/workqueue.h>\n#include <linux/mfd/da903x.h>\n#include <linux/slab.h>\n\n#define DA9034_MANUAL_CTRL\t0x50\n#define DA9034_LDO_ADC_EN\t(1 << 4)\n\n#define DA9034_AUTO_CTRL1\t0x51\n\n#define DA9034_AUTO_CTRL2\t0x52\n#define DA9034_AUTO_TSI_EN\t(1 << 3)\n#define DA9034_PEN_DETECT\t(1 << 4)\n\n#define DA9034_TSI_CTRL1\t0x53\n#define DA9034_TSI_CTRL2\t0x54\n#define DA9034_TSI_X_MSB\t0x6c\n#define DA9034_TSI_Y_MSB\t0x6d\n#define DA9034_TSI_XY_LSB\t0x6e\n\nenum {\n\tSTATE_IDLE,\t \n\tSTATE_BUSY,\t \n\tSTATE_STOP,\t \n\tSTATE_WAIT,\t \n};\n\nenum {\n\tEVENT_PEN_DOWN,\n\tEVENT_PEN_UP,\n\tEVENT_TSI_READY,\n\tEVENT_TIMEDOUT,\n};\n\nstruct da9034_touch {\n\tstruct device\t\t*da9034_dev;\n\tstruct input_dev\t*input_dev;\n\n\tstruct delayed_work\ttsi_work;\n\tstruct notifier_block\tnotifier;\n\n\tint\tstate;\n\n\tint\tinterval_ms;\n\tint\tx_inverted;\n\tint\ty_inverted;\n\n\tint\tlast_x;\n\tint\tlast_y;\n};\n\nstatic inline int is_pen_down(struct da9034_touch *touch)\n{\n\treturn da903x_query_status(touch->da9034_dev, DA9034_STATUS_PEN_DOWN);\n}\n\nstatic inline int detect_pen_down(struct da9034_touch *touch, int on)\n{\n\tif (on)\n\t\treturn da903x_set_bits(touch->da9034_dev,\n\t\t\t\tDA9034_AUTO_CTRL2, DA9034_PEN_DETECT);\n\telse\n\t\treturn da903x_clr_bits(touch->da9034_dev,\n\t\t\t\tDA9034_AUTO_CTRL2, DA9034_PEN_DETECT);\n}\n\nstatic int read_tsi(struct da9034_touch *touch)\n{\n\tuint8_t _x, _y, _v;\n\tint ret;\n\n\tret = da903x_read(touch->da9034_dev, DA9034_TSI_X_MSB, &_x);\n\tif (ret)\n\t\treturn ret;\n\n\tret = da903x_read(touch->da9034_dev, DA9034_TSI_Y_MSB, &_y);\n\tif (ret)\n\t\treturn ret;\n\n\tret = da903x_read(touch->da9034_dev, DA9034_TSI_XY_LSB, &_v);\n\tif (ret)\n\t\treturn ret;\n\n\ttouch->last_x = ((_x << 2) & 0x3fc) | (_v & 0x3);\n\ttouch->last_y = ((_y << 2) & 0x3fc) | ((_v & 0xc) >> 2);\n\n\treturn 0;\n}\n\nstatic inline int start_tsi(struct da9034_touch *touch)\n{\n\treturn da903x_set_bits(touch->da9034_dev,\n\t\t\tDA9034_AUTO_CTRL2, DA9034_AUTO_TSI_EN);\n}\n\nstatic inline int stop_tsi(struct da9034_touch *touch)\n{\n\treturn da903x_clr_bits(touch->da9034_dev,\n\t\t\tDA9034_AUTO_CTRL2, DA9034_AUTO_TSI_EN);\n}\n\nstatic inline void report_pen_down(struct da9034_touch *touch)\n{\n\tint x = touch->last_x;\n\tint y = touch->last_y;\n\n\tx &= 0xfff;\n\tif (touch->x_inverted)\n\t\tx = 1024 - x;\n\ty &= 0xfff;\n\tif (touch->y_inverted)\n\t\ty = 1024 - y;\n\n\tinput_report_abs(touch->input_dev, ABS_X, x);\n\tinput_report_abs(touch->input_dev, ABS_Y, y);\n\tinput_report_key(touch->input_dev, BTN_TOUCH, 1);\n\n\tinput_sync(touch->input_dev);\n}\n\nstatic inline void report_pen_up(struct da9034_touch *touch)\n{\n\tinput_report_key(touch->input_dev, BTN_TOUCH, 0);\n\tinput_sync(touch->input_dev);\n}\n\nstatic void da9034_event_handler(struct da9034_touch *touch, int event)\n{\n\tint err;\n\n\tswitch (touch->state) {\n\tcase STATE_IDLE:\n\t\tif (event != EVENT_PEN_DOWN)\n\t\t\tbreak;\n\n\t\t \n\t\terr = start_tsi(touch);\n\t\tif (err)\n\t\t\tgoto err_reset;\n\n\t\ttouch->state = STATE_BUSY;\n\t\tbreak;\n\n\tcase STATE_BUSY:\n\t\tif (event != EVENT_TSI_READY)\n\t\t\tbreak;\n\n\t\terr = read_tsi(touch);\n\t\tif (err)\n\t\t\tgoto err_reset;\n\n\t\t \n\t\terr = stop_tsi(touch);\n\t\tif (err)\n\t\t\tgoto err_reset;\n\n\t\ttouch->state = STATE_STOP;\n\n\t\t \n\t\tmdelay(1);\n\t\tda9034_event_handler(touch,\n\t\t\t\t     is_pen_down(touch) ? EVENT_PEN_DOWN :\n\t\t\t\t\t\t\t  EVENT_PEN_UP);\n\t\tbreak;\n\n\tcase STATE_STOP:\n\t\tif (event == EVENT_PEN_DOWN) {\n\t\t\treport_pen_down(touch);\n\t\t\tschedule_delayed_work(&touch->tsi_work,\n\t\t\t\tmsecs_to_jiffies(touch->interval_ms));\n\t\t\ttouch->state = STATE_WAIT;\n\t\t}\n\n\t\tif (event == EVENT_PEN_UP) {\n\t\t\treport_pen_up(touch);\n\t\t\ttouch->state = STATE_IDLE;\n\t\t}\n\t\tbreak;\n\n\tcase STATE_WAIT:\n\t\tif (event != EVENT_TIMEDOUT)\n\t\t\tbreak;\n\n\t\tif (is_pen_down(touch)) {\n\t\t\tstart_tsi(touch);\n\t\t\ttouch->state = STATE_BUSY;\n\t\t} else {\n\t\t\treport_pen_up(touch);\n\t\t\ttouch->state = STATE_IDLE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n\nerr_reset:\n\ttouch->state = STATE_IDLE;\n\tstop_tsi(touch);\n\tdetect_pen_down(touch, 1);\n}\n\nstatic void da9034_tsi_work(struct work_struct *work)\n{\n\tstruct da9034_touch *touch =\n\t\tcontainer_of(work, struct da9034_touch, tsi_work.work);\n\n\tda9034_event_handler(touch, EVENT_TIMEDOUT);\n}\n\nstatic int da9034_touch_notifier(struct notifier_block *nb,\n\t\t\t\t unsigned long event, void *data)\n{\n\tstruct da9034_touch *touch =\n\t\tcontainer_of(nb, struct da9034_touch, notifier);\n\n\tif (event & DA9034_EVENT_TSI_READY)\n\t\tda9034_event_handler(touch, EVENT_TSI_READY);\n\n\tif ((event & DA9034_EVENT_PEN_DOWN) && touch->state == STATE_IDLE)\n\t\tda9034_event_handler(touch, EVENT_PEN_DOWN);\n\n\treturn 0;\n}\n\nstatic int da9034_touch_open(struct input_dev *dev)\n{\n\tstruct da9034_touch *touch = input_get_drvdata(dev);\n\tint ret;\n\n\tret = da903x_register_notifier(touch->da9034_dev, &touch->notifier,\n\t\t\tDA9034_EVENT_PEN_DOWN | DA9034_EVENT_TSI_READY);\n\tif (ret)\n\t\treturn -EBUSY;\n\n\t \n\tret = da903x_set_bits(touch->da9034_dev,\n\t\t\tDA9034_MANUAL_CTRL, DA9034_LDO_ADC_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = da903x_write(touch->da9034_dev, DA9034_TSI_CTRL1, 0x1b);\n\tif (ret)\n\t\treturn ret;\n\n\tret = da903x_write(touch->da9034_dev, DA9034_TSI_CTRL2, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\ttouch->state = STATE_IDLE;\n\tdetect_pen_down(touch, 1);\n\n\treturn 0;\n}\n\nstatic void da9034_touch_close(struct input_dev *dev)\n{\n\tstruct da9034_touch *touch = input_get_drvdata(dev);\n\n\tda903x_unregister_notifier(touch->da9034_dev, &touch->notifier,\n\t\t\tDA9034_EVENT_PEN_DOWN | DA9034_EVENT_TSI_READY);\n\n\tcancel_delayed_work_sync(&touch->tsi_work);\n\n\ttouch->state = STATE_IDLE;\n\tstop_tsi(touch);\n\tdetect_pen_down(touch, 0);\n\n\t \n\tda903x_clr_bits(touch->da9034_dev,\n\t\t\tDA9034_MANUAL_CTRL, DA9034_LDO_ADC_EN);\n}\n\n\nstatic int da9034_touch_probe(struct platform_device *pdev)\n{\n\tstruct da9034_touch_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct da9034_touch *touch;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\ttouch = devm_kzalloc(&pdev->dev, sizeof(struct da9034_touch),\n\t\t\t     GFP_KERNEL);\n\tif (!touch) {\n\t\tdev_err(&pdev->dev, \"failed to allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttouch->da9034_dev = pdev->dev.parent;\n\n\tif (pdata) {\n\t\ttouch->interval_ms\t= pdata->interval_ms;\n\t\ttouch->x_inverted\t= pdata->x_inverted;\n\t\ttouch->y_inverted\t= pdata->y_inverted;\n\t} else {\n\t\t \n\t\ttouch->interval_ms\t= 10;\n\t}\n\n\tINIT_DELAYED_WORK(&touch->tsi_work, da9034_tsi_work);\n\ttouch->notifier.notifier_call = da9034_touch_notifier;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name\t\t= pdev->name;\n\tinput_dev->open\t\t= da9034_touch_open;\n\tinput_dev->close\t= da9034_touch_close;\n\tinput_dev->dev.parent\t= &pdev->dev;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(ABS_X, input_dev->absbit);\n\t__set_bit(ABS_Y, input_dev->absbit);\n\tinput_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 1023, 0, 0);\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\n\ttouch->input_dev = input_dev;\n\tinput_set_drvdata(input_dev, touch);\n\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9034_touch_driver = {\n\t.driver\t= {\n\t\t.name\t= \"da9034-touch\",\n\t},\n\t.probe\t\t= da9034_touch_probe,\n};\nmodule_platform_driver(da9034_touch_driver);\n\nMODULE_DESCRIPTION(\"Touchscreen driver for Dialog Semiconductor DA9034\");\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>, Bin Yang <bin.yang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9034-touch\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}