{
  "module_name": "ts4800-ts.c",
  "hash_id": "ed0d0fce26ca8b94e7ff627ebeee9d96379c3971730fc78f6e8d0b0d27d7c813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ts4800-ts.c",
  "human_readable_source": " \n\n#include <linux/bitops.h>\n#include <linux/input.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define POLL_INTERVAL\t\t3\n\n#define DEBOUNCE_COUNT\t\t1\n\n \n#define MAX_12BIT\t\t((1 << 12) - 1)\n\n#define PENDOWN_MASK\t\t0x1\n\n#define X_OFFSET\t\t0x0\n#define Y_OFFSET\t\t0x2\n\nstruct ts4800_ts {\n\tstruct input_dev        *input;\n\tstruct device           *dev;\n\tchar                    phys[32];\n\n\tvoid __iomem            *base;\n\tstruct regmap           *regmap;\n\tunsigned int            reg;\n\tunsigned int            bit;\n\n\tbool                    pendown;\n\tint                     debounce;\n};\n\nstatic int ts4800_ts_open(struct input_dev *input_dev)\n{\n\tstruct ts4800_ts *ts = input_get_drvdata(input_dev);\n\tint error;\n\n\tts->pendown = false;\n\tts->debounce = DEBOUNCE_COUNT;\n\n\terror = regmap_update_bits(ts->regmap, ts->reg, ts->bit, ts->bit);\n\tif (error) {\n\t\tdev_warn(ts->dev, \"Failed to enable touchscreen: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void ts4800_ts_close(struct input_dev *input_dev)\n{\n\tstruct ts4800_ts *ts = input_get_drvdata(input_dev);\n\tint ret;\n\n\tret = regmap_update_bits(ts->regmap, ts->reg, ts->bit, 0);\n\tif (ret)\n\t\tdev_warn(ts->dev, \"Failed to disable touchscreen\\n\");\n\n}\n\nstatic void ts4800_ts_poll(struct input_dev *input_dev)\n{\n\tstruct ts4800_ts *ts = input_get_drvdata(input_dev);\n\tu16 last_x = readw(ts->base + X_OFFSET);\n\tu16 last_y = readw(ts->base + Y_OFFSET);\n\tbool pendown = last_x & PENDOWN_MASK;\n\n\tif (pendown) {\n\t\tif (ts->debounce) {\n\t\t\tts->debounce--;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!ts->pendown) {\n\t\t\tinput_report_key(input_dev, BTN_TOUCH, 1);\n\t\t\tts->pendown = true;\n\t\t}\n\n\t\tlast_x = ((~last_x) >> 4) & MAX_12BIT;\n\t\tlast_y = ((~last_y) >> 4) & MAX_12BIT;\n\n\t\tinput_report_abs(input_dev, ABS_X, last_x);\n\t\tinput_report_abs(input_dev, ABS_Y, last_y);\n\t\tinput_sync(input_dev);\n\t} else if (ts->pendown) {\n\t\tts->pendown = false;\n\t\tts->debounce = DEBOUNCE_COUNT;\n\t\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\t\tinput_sync(input_dev);\n\t}\n}\n\nstatic int ts4800_parse_dt(struct platform_device *pdev,\n\t\t\t   struct ts4800_ts *ts)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *syscon_np;\n\tu32 reg, bit;\n\tint error;\n\n\tsyscon_np = of_parse_phandle(np, \"syscon\", 0);\n\tif (!syscon_np) {\n\t\tdev_err(dev, \"no syscon property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tts->regmap = syscon_node_to_regmap(syscon_np);\n\tof_node_put(syscon_np);\n\tif (IS_ERR(ts->regmap)) {\n\t\tdev_err(dev, \"cannot get parent's regmap\\n\");\n\t\treturn PTR_ERR(ts->regmap);\n\t}\n\n\terror = of_property_read_u32_index(np, \"syscon\", 1, &reg);\n\tif (error < 0) {\n\t\tdev_err(dev, \"no offset in syscon\\n\");\n\t\treturn error;\n\t}\n\n\tts->reg = reg;\n\n\terror = of_property_read_u32_index(np, \"syscon\", 2, &bit);\n\tif (error < 0) {\n\t\tdev_err(dev, \"no bit in syscon\\n\");\n\t\treturn error;\n\t}\n\n\tts->bit = BIT(bit);\n\n\treturn 0;\n}\n\nstatic int ts4800_ts_probe(struct platform_device *pdev)\n{\n\tstruct input_dev *input_dev;\n\tstruct ts4800_ts *ts;\n\tint error;\n\n\tts = devm_kzalloc(&pdev->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\terror = ts4800_parse_dt(pdev, ts);\n\tif (error)\n\t\treturn error;\n\n\tts->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ts->base))\n\t\treturn PTR_ERR(ts->base);\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tsnprintf(ts->phys, sizeof(ts->phys), \"%s/input0\", dev_name(&pdev->dev));\n\tts->input = input_dev;\n\tts->dev = &pdev->dev;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\tinput_dev->name = \"TS-4800 Touchscreen\";\n\tinput_dev->phys = ts->phys;\n\n\tinput_dev->open = ts4800_ts_open;\n\tinput_dev->close = ts4800_ts_close;\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\n\n\terror = input_setup_polling(input_dev, ts4800_ts_poll);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Unable to set up polling: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput_set_poll_interval(input_dev, POLL_INTERVAL);\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ts4800_ts_of_match[] = {\n\t{ .compatible = \"technologic,ts4800-ts\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ts4800_ts_of_match);\n\nstatic struct platform_driver ts4800_ts_driver = {\n\t.driver = {\n\t\t.name = \"ts4800-ts\",\n\t\t.of_match_table = ts4800_ts_of_match,\n\t},\n\t.probe = ts4800_ts_probe,\n};\nmodule_platform_driver(ts4800_ts_driver);\n\nMODULE_AUTHOR(\"Damien Riegel <damien.riegel@savoirfairelinux.com>\");\nMODULE_DESCRIPTION(\"TS-4800 Touchscreen Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:ts4800_ts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}