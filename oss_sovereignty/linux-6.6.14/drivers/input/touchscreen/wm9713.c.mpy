{
  "module_name": "wm9713.c",
  "hash_id": "53efc011846b8e41cc56251be2ec9df34c49d251d46001d0d2acd7d9b0c78555",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wm9713.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/wm97xx.h>\n\n#define TS_NAME\t\t\t\"wm97xx\"\n#define WM9713_VERSION\t\t\"1.00\"\n#define DEFAULT_PRESSURE\t0xb0c0\n\n \n\n \nstatic int rpu = 8;\nmodule_param(rpu, int, 0);\nMODULE_PARM_DESC(rpu, \"Set internal pull up resistor for pen detect.\");\n\n \nstatic int pil;\nmodule_param(pil, int, 0);\nMODULE_PARM_DESC(pil, \"Set current used for pressure measurement.\");\n\n \nstatic int pressure = DEFAULT_PRESSURE & 0xfff;\nmodule_param(pressure, int, 0);\nMODULE_PARM_DESC(pressure, \"Set threshold for pressure measurement.\");\n\n \nstatic int delay = 4;\nmodule_param(delay, int, 0);\nMODULE_PARM_DESC(delay, \"Set adc sample delay.\");\n\n \nstatic int five_wire;\nmodule_param(five_wire, int, 0);\nMODULE_PARM_DESC(five_wire, \"Set to '1' to use 5-wire touchscreen.\");\n\n \nstatic int mask;\nmodule_param(mask, int, 0);\nMODULE_PARM_DESC(mask, \"Set adc mask function.\");\n\n \nstatic int coord;\nmodule_param(coord, int, 0);\nMODULE_PARM_DESC(coord, \"Polling coordinate mode\");\n\n \nstatic const int delay_table[] = {\n\t21,     \n\t42,     \n\t84,     \n\t167,    \n\t333,    \n\t667,    \n\t1000,   \n\t1333,   \n\t2000,   \n\t2667,   \n\t3333,   \n\t4000,   \n\t4667,   \n\t5333,   \n\t6000,   \n\t0       \n};\n\n \nstatic inline void poll_delay(int d)\n{\n\tudelay(3 * AC97_LINK_FRAME + delay_table[d]);\n}\n\n \nstatic void wm9713_phy_init(struct wm97xx *wm)\n{\n\tu16 dig1 = 0, dig2, dig3;\n\n\t \n\tdig2 = WM97XX_DELAY(4) | WM97XX_SLT(5);\n\tdig3 = WM9712_RPU(1);\n\n\t \n\tif (rpu) {\n\t\tdig3 &= 0xffc0;\n\t\tdig3 |= WM9712_RPU(rpu);\n\t\tdev_info(wm->dev, \"setting pen detect pull-up to %d Ohms\\n\",\n\t\t\t 64000 / rpu);\n\t}\n\n\t \n\tif (five_wire) {\n\t\tdig3 |= WM9713_45W;\n\t\tdev_info(wm->dev, \"setting 5-wire touchscreen mode.\");\n\n\t\tif (pil) {\n\t\t\tdev_warn(wm->dev,\n\t\t\t\t \"Pressure measurement not supported in 5 \"\n\t\t\t\t \"wire mode, disabling\\n\");\n\t\t\tpil = 0;\n\t\t}\n\t}\n\n\t \n\tif (pil == 2) {\n\t\tdig3 |= WM9712_PIL;\n\t\tdev_info(wm->dev,\n\t\t\t \"setting pressure measurement current to 400uA.\");\n\t} else if (pil)\n\t\tdev_info(wm->dev,\n\t\t\t \"setting pressure measurement current to 200uA.\");\n\tif (!pil)\n\t\tpressure = 0;\n\n\t \n\tif (delay < 0 || delay > 15) {\n\t\tdev_info(wm->dev, \"supplied delay out of range.\");\n\t\tdelay = 4;\n\t\tdev_info(wm->dev, \"setting adc sample delay to %d u Secs.\",\n\t\t\t delay_table[delay]);\n\t}\n\tdig2 &= 0xff0f;\n\tdig2 |= WM97XX_DELAY(delay);\n\n\t \n\tdig3 |= ((mask & 0x3) << 4);\n\tif (coord)\n\t\tdig3 |= WM9713_WAIT;\n\n\twm->misc = wm97xx_reg_read(wm, 0x5a);\n\n\twm97xx_reg_write(wm, AC97_WM9713_DIG1, dig1);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG2, dig2);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG3, dig3);\n\twm97xx_reg_write(wm, AC97_GPIO_STICKY, 0x0);\n}\n\nstatic void wm9713_dig_enable(struct wm97xx *wm, int enable)\n{\n\tu16 val;\n\n\tif (enable) {\n\t\tval = wm97xx_reg_read(wm, AC97_EXTENDED_MID);\n\t\twm97xx_reg_write(wm, AC97_EXTENDED_MID, val & 0x7fff);\n\t\twm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig[2] |\n\t\t\t\t WM97XX_PRP_DET_DIG);\n\t\twm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);  \n\t} else {\n\t\twm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig[2] &\n\t\t\t\t\t~WM97XX_PRP_DET_DIG);\n\t\tval = wm97xx_reg_read(wm, AC97_EXTENDED_MID);\n\t\twm97xx_reg_write(wm, AC97_EXTENDED_MID, val | 0x8000);\n\t}\n}\n\nstatic void wm9713_dig_restore(struct wm97xx *wm)\n{\n\twm97xx_reg_write(wm, AC97_WM9713_DIG1, wm->dig_save[0]);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG2, wm->dig_save[1]);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig_save[2]);\n}\n\nstatic void wm9713_aux_prepare(struct wm97xx *wm)\n{\n\tmemcpy(wm->dig_save, wm->dig, sizeof(wm->dig));\n\twm97xx_reg_write(wm, AC97_WM9713_DIG1, 0);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG2, 0);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG3, WM97XX_PRP_DET_DIG);\n}\n\nstatic inline int is_pden(struct wm97xx *wm)\n{\n\treturn wm->dig[2] & WM9713_PDEN;\n}\n\n \nstatic int wm9713_poll_sample(struct wm97xx *wm, int adcsel, int *sample)\n{\n\tu16 dig1;\n\tint timeout = 5 * delay;\n\tbool wants_pen = adcsel & WM97XX_PEN_DOWN;\n\n\tif (wants_pen && !wm->pen_probably_down) {\n\t\tu16 data = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t\tif (!(data & WM97XX_PEN_DOWN))\n\t\t\treturn RC_PENUP;\n\t\twm->pen_probably_down = 1;\n\t}\n\n\t \n\tdig1 = wm97xx_reg_read(wm, AC97_WM9713_DIG1);\n\tdig1 &= ~WM9713_ADCSEL_MASK;\n\t \n\tdig1 |= 1 << ((adcsel & WM97XX_ADCSEL_MASK) >> 12);\n\n\tif (wm->mach_ops && wm->mach_ops->pre_sample)\n\t\twm->mach_ops->pre_sample(adcsel);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG1, dig1 | WM9713_POLL);\n\n\t \n\tpoll_delay(delay);\n\n\t \n\twhile ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL) &&\n\t\ttimeout) {\n\t\tudelay(AC97_LINK_FRAME);\n\t\ttimeout--;\n\t}\n\n\tif (timeout <= 0) {\n\t\t \n\t\tif (is_pden(wm))\n\t\t\twm->pen_probably_down = 0;\n\t\telse\n\t\t\tdev_dbg(wm->dev, \"adc sample timeout\");\n\t\treturn RC_PENUP;\n\t}\n\n\t*sample = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\tif (wm->mach_ops && wm->mach_ops->post_sample)\n\t\twm->mach_ops->post_sample(adcsel);\n\n\t \n\tif ((*sample ^ adcsel) & WM97XX_ADCSEL_MASK) {\n\t\tdev_dbg(wm->dev, \"adc wrong sample, wanted %x got %x\",\n\t\t\tadcsel & WM97XX_ADCSEL_MASK,\n\t\t\t*sample & WM97XX_ADCSEL_MASK);\n\t\treturn RC_PENUP;\n\t}\n\n\tif (wants_pen && !(*sample & WM97XX_PEN_DOWN)) {\n\t\twm->pen_probably_down = 0;\n\t\treturn RC_PENUP;\n\t}\n\n\treturn RC_VALID;\n}\n\n \nstatic int wm9713_poll_coord(struct wm97xx *wm, struct wm97xx_data *data)\n{\n\tu16 dig1;\n\tint timeout = 5 * delay;\n\n\tif (!wm->pen_probably_down) {\n\t\tu16 val = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t\tif (!(val & WM97XX_PEN_DOWN))\n\t\t\treturn RC_PENUP;\n\t\twm->pen_probably_down = 1;\n\t}\n\n\t \n\tdig1 = wm97xx_reg_read(wm, AC97_WM9713_DIG1);\n\tdig1 &= ~WM9713_ADCSEL_MASK;\n\tif (pil)\n\t\tdig1 |= WM9713_ADCSEL_PRES;\n\n\tif (wm->mach_ops && wm->mach_ops->pre_sample)\n\t\twm->mach_ops->pre_sample(WM97XX_ADCSEL_X | WM97XX_ADCSEL_Y);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG1,\n\t\t\t dig1 | WM9713_POLL | WM9713_COO);\n\n\t \n\tpoll_delay(delay);\n\tdata->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t \n\twhile ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL)\n\t       && timeout) {\n\t\tudelay(AC97_LINK_FRAME);\n\t\ttimeout--;\n\t}\n\n\tif (timeout <= 0) {\n\t\t \n\t\tif (is_pden(wm))\n\t\t\twm->pen_probably_down = 0;\n\t\telse\n\t\t\tdev_dbg(wm->dev, \"adc sample timeout\");\n\t\treturn RC_PENUP;\n\t}\n\n\t \n\tdata->y = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\tif (pil)\n\t\tdata->p = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\telse\n\t\tdata->p = DEFAULT_PRESSURE;\n\n\tif (wm->mach_ops && wm->mach_ops->post_sample)\n\t\twm->mach_ops->post_sample(WM97XX_ADCSEL_X | WM97XX_ADCSEL_Y);\n\n\t \n\tif (!(data->x & WM97XX_ADCSEL_X) || !(data->y & WM97XX_ADCSEL_Y))\n\t\tgoto err;\n\tif (pil && !(data->p & WM97XX_ADCSEL_PRES))\n\t\tgoto err;\n\n\tif (!(data->x & WM97XX_PEN_DOWN) || !(data->y & WM97XX_PEN_DOWN)) {\n\t\twm->pen_probably_down = 0;\n\t\treturn RC_PENUP;\n\t}\n\treturn RC_VALID;\nerr:\n\treturn 0;\n}\n\n \nstatic int wm9713_poll_touch(struct wm97xx *wm, struct wm97xx_data *data)\n{\n\tint rc;\n\n\tif (coord) {\n\t\trc = wm9713_poll_coord(wm, data);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\t} else {\n\t\trc = wm9713_poll_sample(wm, WM97XX_ADCSEL_X | WM97XX_PEN_DOWN, &data->x);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\t\trc = wm9713_poll_sample(wm, WM97XX_ADCSEL_Y | WM97XX_PEN_DOWN, &data->y);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\t\tif (pil) {\n\t\t\trc = wm9713_poll_sample(wm, WM97XX_ADCSEL_PRES | WM97XX_PEN_DOWN,\n\t\t\t\t\t\t&data->p);\n\t\t\tif (rc != RC_VALID)\n\t\t\t\treturn rc;\n\t\t} else\n\t\t\tdata->p = DEFAULT_PRESSURE;\n\t}\n\treturn RC_VALID;\n}\n\n \nstatic int wm9713_acc_enable(struct wm97xx *wm, int enable)\n{\n\tu16 dig1, dig2, dig3;\n\tint ret = 0;\n\n\tdig1 = wm->dig[0];\n\tdig2 = wm->dig[1];\n\tdig3 = wm->dig[2];\n\n\tif (enable) {\n\t\t \n\t\tif (wm->mach_ops->acc_startup &&\n\t\t\t(ret = wm->mach_ops->acc_startup(wm)) < 0)\n\t\t\treturn ret;\n\n\t\tdig1 &= ~WM9713_ADCSEL_MASK;\n\t\tdig1 |= WM9713_CTC | WM9713_COO | WM9713_ADCSEL_X |\n\t\t\tWM9713_ADCSEL_Y;\n\t\tif (pil)\n\t\t\tdig1 |= WM9713_ADCSEL_PRES;\n\t\tdig2 &= ~(WM97XX_DELAY_MASK | WM97XX_SLT_MASK  |\n\t\t\tWM97XX_CM_RATE_MASK);\n\t\tdig2 |= WM97XX_SLEN | WM97XX_DELAY(delay) |\n\t\tWM97XX_SLT(wm->acc_slot) | WM97XX_RATE(wm->acc_rate);\n\t\tdig3 |= WM9713_PDEN;\n\t} else {\n\t\tdig1 &= ~(WM9713_CTC | WM9713_COO);\n\t\tdig2 &= ~WM97XX_SLEN;\n\t\tdig3 &= ~WM9713_PDEN;\n\t\tif (wm->mach_ops->acc_shutdown)\n\t\t\twm->mach_ops->acc_shutdown(wm);\n\t}\n\n\twm97xx_reg_write(wm, AC97_WM9713_DIG1, dig1);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG2, dig2);\n\twm97xx_reg_write(wm, AC97_WM9713_DIG3, dig3);\n\n\treturn ret;\n}\n\nstruct wm97xx_codec_drv wm9713_codec = {\n\t.id = WM9713_ID2,\n\t.name = \"wm9713\",\n\t.poll_sample = wm9713_poll_sample,\n\t.poll_touch = wm9713_poll_touch,\n\t.acc_enable = wm9713_acc_enable,\n\t.phy_init = wm9713_phy_init,\n\t.dig_enable = wm9713_dig_enable,\n\t.dig_restore = wm9713_dig_restore,\n\t.aux_prepare = wm9713_aux_prepare,\n};\nEXPORT_SYMBOL_GPL(wm9713_codec);\n\n \nMODULE_AUTHOR(\"Liam Girdwood <lrg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"WM9713 Touch Screen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}