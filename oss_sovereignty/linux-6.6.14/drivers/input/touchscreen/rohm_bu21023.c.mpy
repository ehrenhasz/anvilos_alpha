{
  "module_name": "rohm_bu21023.c",
  "hash_id": "d9fa9562713786556db8f056b745266c430324732ac7e8d1ae7e47c8fc06e52d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/rohm_bu21023.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define BU21023_NAME\t\t\t\"bu21023_ts\"\n#define BU21023_FIRMWARE_NAME\t\t\"bu21023.bin\"\n\n#define MAX_CONTACTS\t\t\t2\n\n#define AXIS_ADJUST\t\t\t4\n#define AXIS_OFFSET\t\t\t8\n\n#define FIRMWARE_BLOCK_SIZE\t\t32U\n#define FIRMWARE_RETRY_MAX\t\t4\n\n#define SAMPLING_DELAY\t\t\t12\t \n\n#define CALIBRATION_RETRY_MAX\t\t6\n\n#define ROHM_TS_ABS_X_MIN\t\t40\n#define ROHM_TS_ABS_X_MAX\t\t990\n#define ROHM_TS_ABS_Y_MIN\t\t160\n#define ROHM_TS_ABS_Y_MAX\t\t920\n#define ROHM_TS_DISPLACEMENT_MAX\t0\t \n\n \n#define VADOUT_YP_H\t\t0x00\n#define VADOUT_YP_L\t\t0x01\n#define VADOUT_XP_H\t\t0x02\n#define VADOUT_XP_L\t\t0x03\n#define VADOUT_YN_H\t\t0x04\n#define VADOUT_YN_L\t\t0x05\n#define VADOUT_XN_H\t\t0x06\n#define VADOUT_XN_L\t\t0x07\n\n#define PRM1_X_H\t\t0x08\n#define PRM1_X_L\t\t0x09\n#define PRM1_Y_H\t\t0x0a\n#define PRM1_Y_L\t\t0x0b\n#define PRM2_X_H\t\t0x0c\n#define PRM2_X_L\t\t0x0d\n#define PRM2_Y_H\t\t0x0e\n#define PRM2_Y_L\t\t0x0f\n\n#define MLT_PRM_MONI_X\t\t0x10\n#define MLT_PRM_MONI_Y\t\t0x11\n\n#define DEBUG_MONI_1\t\t0x12\n#define DEBUG_MONI_2\t\t0x13\n\n#define VADOUT_ZX_H\t\t0x14\n#define VADOUT_ZX_L\t\t0x15\n#define VADOUT_ZY_H\t\t0x16\n#define VADOUT_ZY_L\t\t0x17\n\n#define Z_PARAM_H\t\t0x18\n#define Z_PARAM_L\t\t0x19\n\n \n#define VADOUT_L_MASK\t\t0x01\n\n \n#define PRM_L_MASK\t\t0x01\n\n#define POS_X1_H\t\t0x20\n#define POS_X1_L\t\t0x21\n#define POS_Y1_H\t\t0x22\n#define POS_Y1_L\t\t0x23\n#define POS_X2_H\t\t0x24\n#define POS_X2_L\t\t0x25\n#define POS_Y2_H\t\t0x26\n#define POS_Y2_L\t\t0x27\n\n \n#define POS_L_MASK\t\t0x01\n\n#define TOUCH\t\t\t0x28\n#define TOUCH_DETECT\t\t0x01\n\n#define TOUCH_GESTURE\t\t0x29\n#define SINGLE_TOUCH\t\t0x01\n#define DUAL_TOUCH\t\t0x03\n#define TOUCH_MASK\t\t0x03\n#define CALIBRATION_REQUEST\t0x04\n#define CALIBRATION_STATUS\t0x08\n#define CALIBRATION_MASK\t0x0c\n#define GESTURE_SPREAD\t\t0x10\n#define GESTURE_PINCH\t\t0x20\n#define GESTURE_ROTATE_R\t0x40\n#define GESTURE_ROTATE_L\t0x80\n\n#define INT_STATUS\t\t0x2a\n#define INT_MASK\t\t0x3d\n#define INT_CLEAR\t\t0x3e\n\n \n#define COORD_UPDATE\t\t0x01\n#define CALIBRATION_DONE\t0x02\n#define SLEEP_IN\t\t0x04\n#define SLEEP_OUT\t\t0x08\n#define PROGRAM_LOAD_DONE\t0x10\n#define ERROR\t\t\t0x80\n#define INT_ALL\t\t\t0x9f\n\n#define ERR_STATUS\t\t0x2b\n#define ERR_MASK\t\t0x3f\n\n \n#define ADC_TIMEOUT\t\t0x01\n#define CPU_TIMEOUT\t\t0x02\n#define CALIBRATION_ERR\t\t0x04\n#define PROGRAM_LOAD_ERR\t0x10\n\n#define COMMON_SETUP1\t\t\t0x30\n#define PROGRAM_LOAD_HOST\t\t0x02\n#define PROGRAM_LOAD_EEPROM\t\t0x03\n#define CENSOR_4PORT\t\t\t0x04\n#define CENSOR_8PORT\t\t\t0x00\t \n#define CALIBRATION_TYPE_DEFAULT\t0x08\n#define CALIBRATION_TYPE_SPECIAL\t0x00\n#define INT_ACTIVE_HIGH\t\t\t0x10\n#define INT_ACTIVE_LOW\t\t\t0x00\n#define AUTO_CALIBRATION\t\t0x40\n#define MANUAL_CALIBRATION\t\t0x00\n#define COMMON_SETUP1_DEFAULT\t\t0x4e\n\n#define COMMON_SETUP2\t\t0x31\n#define MAF_NONE\t\t0x00\n#define MAF_1SAMPLE\t\t0x01\n#define MAF_3SAMPLES\t\t0x02\n#define MAF_5SAMPLES\t\t0x03\n#define INV_Y\t\t\t0x04\n#define INV_X\t\t\t0x08\n#define SWAP_XY\t\t\t0x10\n\n#define COMMON_SETUP3\t\t0x32\n#define EN_SLEEP\t\t0x01\n#define EN_MULTI\t\t0x02\n#define EN_GESTURE\t\t0x04\n#define EN_INTVL\t\t0x08\n#define SEL_STEP\t\t0x10\n#define SEL_MULTI\t\t0x20\n#define SEL_TBL_DEFAULT\t\t0x40\n\n#define INTERVAL_TIME\t\t0x33\n#define INTERVAL_TIME_DEFAULT\t0x10\n\n#define STEP_X\t\t\t0x34\n#define STEP_X_DEFAULT\t\t0x41\n\n#define STEP_Y\t\t\t0x35\n#define STEP_Y_DEFAULT\t\t0x8d\n\n#define OFFSET_X\t\t0x38\n#define OFFSET_X_DEFAULT\t0x0c\n\n#define OFFSET_Y\t\t0x39\n#define OFFSET_Y_DEFAULT\t0x0c\n\n#define THRESHOLD_TOUCH\t\t0x3a\n#define THRESHOLD_TOUCH_DEFAULT\t0xa0\n\n#define THRESHOLD_GESTURE\t\t0x3b\n#define THRESHOLD_GESTURE_DEFAULT\t0x17\n\n#define SYSTEM\t\t\t0x40\n#define ANALOG_POWER_ON\t\t0x01\n#define ANALOG_POWER_OFF\t0x00\n#define CPU_POWER_ON\t\t0x02\n#define CPU_POWER_OFF\t\t0x00\n\n#define FORCE_CALIBRATION\t0x42\n#define FORCE_CALIBRATION_ON\t0x01\n#define FORCE_CALIBRATION_OFF\t0x00\n\n#define CPU_FREQ\t\t0x50\t \n#define CPU_FREQ_10MHZ\t\t0x00\n#define CPU_FREQ_5MHZ\t\t0x01\n#define CPU_FREQ_1MHZ\t\t0x09\n\n#define EEPROM_ADDR\t\t0x51\n\n#define CALIBRATION_ADJUST\t\t0x52\n#define CALIBRATION_ADJUST_DEFAULT\t0x00\n\n#define THRESHOLD_SLEEP_IN\t0x53\n\n#define EVR_XY\t\t\t0x56\n#define EVR_XY_DEFAULT\t\t0x10\n\n#define PRM_SWOFF_TIME\t\t0x57\n#define PRM_SWOFF_TIME_DEFAULT\t0x04\n\n#define PROGRAM_VERSION\t\t0x5f\n\n#define ADC_CTRL\t\t0x60\n#define ADC_DIV_MASK\t\t0x1f\t \n#define ADC_DIV_DEFAULT\t\t0x08\n\n#define ADC_WAIT\t\t0x61\n#define ADC_WAIT_DEFAULT\t0x0a\n\n#define SWCONT\t\t\t0x62\n#define SWCONT_DEFAULT\t\t0x0f\n\n#define EVR_X\t\t\t0x63\n#define EVR_X_DEFAULT\t\t0x86\n\n#define EVR_Y\t\t\t0x64\n#define EVR_Y_DEFAULT\t\t0x64\n\n#define TEST1\t\t\t0x65\n#define DUALTOUCH_STABILIZE_ON\t0x01\n#define DUALTOUCH_STABILIZE_OFF\t0x00\n#define DUALTOUCH_REG_ON\t0x20\n#define DUALTOUCH_REG_OFF\t0x00\n\n#define CALIBRATION_REG1\t\t0x68\n#define CALIBRATION_REG1_DEFAULT\t0xd9\n\n#define CALIBRATION_REG2\t\t0x69\n#define CALIBRATION_REG2_DEFAULT\t0x36\n\n#define CALIBRATION_REG3\t\t0x6a\n#define CALIBRATION_REG3_DEFAULT\t0x32\n\n#define EX_ADDR_H\t\t0x70\n#define EX_ADDR_L\t\t0x71\n#define EX_WDAT\t\t\t0x72\n#define EX_RDAT\t\t\t0x73\n#define EX_CHK_SUM1\t\t0x74\n#define EX_CHK_SUM2\t\t0x75\n#define EX_CHK_SUM3\t\t0x76\n\nstruct rohm_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\n\tbool initialized;\n\n\tunsigned int contact_count[MAX_CONTACTS + 1];\n\tint finger_count;\n\n\tu8 setup2;\n};\n\n \nstatic int rohm_i2c_burst_read(struct i2c_client *client, u8 start, void *buf,\n\t\t\t       size_t len)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct i2c_msg msg[2];\n\tint i, ret = 0;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = &start;\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = len;\n\tmsg[1].buf = buf;\n\n\ti2c_lock_bus(adap, I2C_LOCK_SEGMENT);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (__i2c_transfer(adap, &msg[i], 1) < 0) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti2c_unlock_bus(adap, I2C_LOCK_SEGMENT);\n\n\treturn ret;\n}\n\nstatic int rohm_ts_manual_calibration(struct rohm_ts_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tstruct device *dev = &client->dev;\n\tu8 buf[33];\t \n\n\tint retry;\n\tbool success = false;\n\tbool first_time = true;\n\tbool calibration_done;\n\n\tu8 reg1, reg2, reg3;\n\ts32 reg1_orig, reg2_orig, reg3_orig;\n\ts32 val;\n\n\tint calib_x = 0, calib_y = 0;\n\tint reg_x, reg_y;\n\tint err_x, err_y;\n\n\tint error, error2;\n\tint i;\n\n\treg1_orig = i2c_smbus_read_byte_data(client, CALIBRATION_REG1);\n\tif (reg1_orig < 0)\n\t\treturn reg1_orig;\n\n\treg2_orig = i2c_smbus_read_byte_data(client, CALIBRATION_REG2);\n\tif (reg2_orig < 0)\n\t\treturn reg2_orig;\n\n\treg3_orig = i2c_smbus_read_byte_data(client, CALIBRATION_REG3);\n\tif (reg3_orig < 0)\n\t\treturn reg3_orig;\n\n\terror = i2c_smbus_write_byte_data(client, INT_MASK,\n\t\t\t\t\t  COORD_UPDATE | SLEEP_IN | SLEEP_OUT |\n\t\t\t\t\t  PROGRAM_LOAD_DONE);\n\tif (error)\n\t\tgoto out;\n\n\terror = i2c_smbus_write_byte_data(client, TEST1,\n\t\t\t\t\t  DUALTOUCH_STABILIZE_ON);\n\tif (error)\n\t\tgoto out;\n\n\tfor (retry = 0; retry < CALIBRATION_RETRY_MAX; retry++) {\n\t\t \n\t\tmdelay(2 * SAMPLING_DELAY);\n\n#define READ_CALIB_BUF(reg)\tbuf[((reg) - PRM1_X_H)]\n\n\t\terror = rohm_i2c_burst_read(client, PRM1_X_H, buf, sizeof(buf));\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (READ_CALIB_BUF(TOUCH) & TOUCH_DETECT)\n\t\t\tcontinue;\n\n\t\tif (first_time) {\n\t\t\t \n\t\t\tcalib_x = ((int)READ_CALIB_BUF(PRM1_X_H) << 2 |\n\t\t\t\tREAD_CALIB_BUF(PRM1_X_L)) - AXIS_OFFSET;\n\t\t\tcalib_y = ((int)READ_CALIB_BUF(PRM1_Y_H) << 2 |\n\t\t\t\tREAD_CALIB_BUF(PRM1_Y_L)) - AXIS_OFFSET;\n\n\t\t\terror = i2c_smbus_write_byte_data(client, TEST1,\n\t\t\t\tDUALTOUCH_STABILIZE_ON | DUALTOUCH_REG_ON);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tfirst_time = false;\n\t\t} else {\n\t\t\t \n\t\t\terr_x = (int)READ_CALIB_BUF(PRM1_X_H) << 2 |\n\t\t\t\tREAD_CALIB_BUF(PRM1_X_L);\n\t\t\terr_y = (int)READ_CALIB_BUF(PRM1_Y_H) << 2 |\n\t\t\t\tREAD_CALIB_BUF(PRM1_Y_L);\n\n\t\t\t \n\t\t\tif (err_x <= 4)\n\t\t\t\tcalib_x -= AXIS_ADJUST;\n\t\t\telse if (err_x >= 60)\n\t\t\t\tcalib_x += AXIS_ADJUST;\n\n\t\t\t \n\t\t\tif (err_y <= 4)\n\t\t\t\tcalib_y -= AXIS_ADJUST;\n\t\t\telse if (err_y >= 60)\n\t\t\t\tcalib_y += AXIS_ADJUST;\n\t\t}\n\n\t\t \n\t\treg_x = calib_x + ((calib_x & 0x200) << 1);\n\t\treg_y = calib_y + ((calib_y & 0x200) << 1);\n\n\t\t \n\t\treg1 = reg_x >> 3;\n\t\treg2 = (reg_y & 0x7) << 4 | (reg_x & 0x7);\n\t\treg3 = reg_y >> 3;\n\n\t\terror = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t  CALIBRATION_REG1, reg1);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t  CALIBRATION_REG2, reg2);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client,\n\t\t\t\t\t\t  CALIBRATION_REG3, reg3);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\terror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\n\t\t\t\t\t\t  FORCE_CALIBRATION_OFF);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\n\t\t\t\t\t\t  FORCE_CALIBRATION_ON);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\terror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\tcalibration_done = false;\n\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tmdelay(SAMPLING_DELAY);\n\n\t\t\tval = i2c_smbus_read_byte_data(client, TOUCH_GESTURE);\n\t\t\tif (!(val & CALIBRATION_MASK)) {\n\t\t\t\tcalibration_done = true;\n\t\t\t\tbreak;\n\t\t\t} else if (val < 0) {\n\t\t\t\terror = val;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (calibration_done) {\n\t\t\tval = i2c_smbus_read_byte_data(client, INT_STATUS);\n\t\t\tif (val == CALIBRATION_DONE) {\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t} else if (val < 0) {\n\t\t\t\terror = val;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(dev, \"calibration timeout\\n\");\n\t\t}\n\t}\n\n\tif (!success) {\n\t\terror = i2c_smbus_write_byte_data(client, CALIBRATION_REG1,\n\t\t\t\t\t\t  reg1_orig);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client, CALIBRATION_REG2,\n\t\t\t\t\t\t  reg2_orig);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client, CALIBRATION_REG3,\n\t\t\t\t\t\t  reg3_orig);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\terror = i2c_smbus_write_byte_data(client, TEST1,\n\t\t\t\t\t\t  DUALTOUCH_STABILIZE_ON |\n\t\t\t\t\t\t  DUALTOUCH_REG_ON);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\tmdelay(10 * SAMPLING_DELAY);\n\n\t\terror = -EBUSY;\n\t}\n\nout:\n\terror2 = i2c_smbus_write_byte_data(client, INT_MASK, INT_ALL);\n\tif (!error2)\n\t\t \n\t\terror2 = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\n\n\treturn error ? error : error2;\n}\n\nstatic const unsigned int untouch_threshold[3] = { 0, 1, 5 };\nstatic const unsigned int single_touch_threshold[3] = { 0, 0, 4 };\nstatic const unsigned int dual_touch_threshold[3] = { 10, 8, 0 };\n\nstatic irqreturn_t rohm_ts_soft_irq(int irq, void *dev_id)\n{\n\tstruct rohm_ts_data *ts = dev_id;\n\tstruct i2c_client *client = ts->client;\n\tstruct input_dev *input_dev = ts->input;\n\tstruct device *dev = &client->dev;\n\n\tu8 buf[10];\t \n\n\tstruct input_mt_pos pos[MAX_CONTACTS];\n\tint slots[MAX_CONTACTS];\n\tu8 touch_flags;\n\tunsigned int threshold;\n\tint finger_count = -1;\n\tint prev_finger_count = ts->finger_count;\n\tint count;\n\tint error;\n\tint i;\n\n\terror = i2c_smbus_write_byte_data(client, INT_MASK, INT_ALL);\n\tif (error)\n\t\treturn IRQ_HANDLED;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\n\tif (error)\n\t\treturn IRQ_HANDLED;\n\n#define READ_POS_BUF(reg)\tbuf[((reg) - POS_X1_H)]\n\n\terror = rohm_i2c_burst_read(client, POS_X1_H, buf, sizeof(buf));\n\tif (error)\n\t\treturn IRQ_HANDLED;\n\n\ttouch_flags = READ_POS_BUF(TOUCH_GESTURE) & TOUCH_MASK;\n\tif (touch_flags) {\n\t\t \n\t\tpos[0].x = ((s16)READ_POS_BUF(POS_X1_H) << 2) |\n\t\t\t   READ_POS_BUF(POS_X1_L);\n\t\tpos[0].y = ((s16)READ_POS_BUF(POS_Y1_H) << 2) |\n\t\t\t   READ_POS_BUF(POS_Y1_L);\n\t\tpos[1].x = ((s16)READ_POS_BUF(POS_X2_H) << 2) |\n\t\t\t   READ_POS_BUF(POS_X2_L);\n\t\tpos[1].y = ((s16)READ_POS_BUF(POS_Y2_H) << 2) |\n\t\t\t   READ_POS_BUF(POS_Y2_L);\n\t}\n\n\tswitch (touch_flags) {\n\tcase 0:\n\t\tthreshold = untouch_threshold[prev_finger_count];\n\t\tif (++ts->contact_count[0] >= threshold)\n\t\t\tfinger_count = 0;\n\t\tbreak;\n\n\tcase SINGLE_TOUCH:\n\t\tthreshold = single_touch_threshold[prev_finger_count];\n\t\tif (++ts->contact_count[1] >= threshold)\n\t\t\tfinger_count = 1;\n\n\t\tif (finger_count == 1) {\n\t\t\tif (pos[1].x != 0 && pos[1].y != 0) {\n\t\t\t\tpos[0].x = pos[1].x;\n\t\t\t\tpos[0].y = pos[1].y;\n\t\t\t\tpos[1].x = 0;\n\t\t\t\tpos[1].y = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DUAL_TOUCH:\n\t\tthreshold = dual_touch_threshold[prev_finger_count];\n\t\tif (++ts->contact_count[2] >= threshold)\n\t\t\tfinger_count = 2;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(dev,\n\t\t\t\"Three or more touches are not supported\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (finger_count >= 0) {\n\t\tif (prev_finger_count != finger_count) {\n\t\t\tcount = ts->contact_count[finger_count];\n\t\t\tmemset(ts->contact_count, 0, sizeof(ts->contact_count));\n\t\t\tts->contact_count[finger_count] = count;\n\t\t}\n\n\t\tinput_mt_assign_slots(input_dev, slots, pos,\n\t\t\t\t      finger_count, ROHM_TS_DISPLACEMENT_MAX);\n\n\t\tfor (i = 0; i < finger_count; i++) {\n\t\t\tinput_mt_slot(input_dev, slots[i]);\n\t\t\tinput_mt_report_slot_state(input_dev,\n\t\t\t\t\t\t   MT_TOOL_FINGER, true);\n\t\t\tinput_report_abs(input_dev,\n\t\t\t\t\t ABS_MT_POSITION_X, pos[i].x);\n\t\t\tinput_report_abs(input_dev,\n\t\t\t\t\t ABS_MT_POSITION_Y, pos[i].y);\n\t\t}\n\n\t\tinput_mt_sync_frame(input_dev);\n\t\tinput_mt_report_pointer_emulation(input_dev, true);\n\t\tinput_sync(input_dev);\n\n\t\tts->finger_count = finger_count;\n\t}\n\n\tif (READ_POS_BUF(TOUCH_GESTURE) & CALIBRATION_REQUEST) {\n\t\terror = rohm_ts_manual_calibration(ts);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"manual calibration failed: %d\\n\",\n\t\t\t\t error);\n\t}\n\n\ti2c_smbus_write_byte_data(client, INT_MASK,\n\t\t\t\t  CALIBRATION_DONE | SLEEP_OUT | SLEEP_IN |\n\t\t\t\t  PROGRAM_LOAD_DONE);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rohm_ts_load_firmware(struct i2c_client *client,\n\t\t\t\t const char *firmware_name)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct firmware *fw;\n\ts32 status;\n\tunsigned int offset, len, xfer_len;\n\tunsigned int retry = 0;\n\tint error, error2;\n\n\terror = request_firmware(&fw, firmware_name, dev);\n\tif (error) {\n\t\tdev_err(dev, \"unable to retrieve firmware %s: %d\\n\",\n\t\t\tfirmware_name, error);\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, INT_MASK,\n\t\t\t\t\t  COORD_UPDATE | CALIBRATION_DONE |\n\t\t\t\t\t  SLEEP_IN | SLEEP_OUT);\n\tif (error)\n\t\tgoto out;\n\n\tdo {\n\t\tif (retry) {\n\t\t\tdev_warn(dev, \"retrying firmware load\\n\");\n\n\t\t\t \n\t\t\terror = i2c_smbus_write_byte_data(client, EX_WDAT, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terror = i2c_smbus_write_byte_data(client, EX_ADDR_H, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client, EX_ADDR_L, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = i2c_smbus_write_byte_data(client, COMMON_SETUP1,\n\t\t\t\t\t\t  COMMON_SETUP1_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t \n\t\toffset = 0;\n\t\tlen = fw->size;\n\n\t\twhile (len) {\n\t\t\txfer_len = min(FIRMWARE_BLOCK_SIZE, len);\n\n\t\t\terror = i2c_smbus_write_i2c_block_data(client, EX_WDAT,\n\t\t\t\t\t\txfer_len, &fw->data[offset]);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tlen -= xfer_len;\n\t\t\toffset += xfer_len;\n\t\t}\n\n\t\t \n\t\tstatus = i2c_smbus_read_byte_data(client, INT_STATUS);\n\t\tif (status < 0) {\n\t\t\terror = status;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (status == PROGRAM_LOAD_DONE)\n\t\t\tbreak;\n\n\t\terror = -EIO;\n\t} while (++retry <= FIRMWARE_RETRY_MAX);\n\nout:\n\terror2 = i2c_smbus_write_byte_data(client, INT_MASK, INT_ALL);\n\n\trelease_firmware(fw);\n\n\treturn error ? error : error2;\n}\n\nstatic ssize_t swap_xy_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d\\n\", !!(ts->setup2 & SWAP_XY));\n}\n\nstatic ssize_t swap_xy_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = mutex_lock_interruptible(&ts->input->mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (val)\n\t\tts->setup2 |= SWAP_XY;\n\telse\n\t\tts->setup2 &= ~SWAP_XY;\n\n\tif (ts->initialized)\n\t\terror = i2c_smbus_write_byte_data(ts->client, COMMON_SETUP2,\n\t\t\t\t\t\t  ts->setup2);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn error ? error : count;\n}\n\nstatic ssize_t inv_x_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d\\n\", !!(ts->setup2 & INV_X));\n}\n\nstatic ssize_t inv_x_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = mutex_lock_interruptible(&ts->input->mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (val)\n\t\tts->setup2 |= INV_X;\n\telse\n\t\tts->setup2 &= ~INV_X;\n\n\tif (ts->initialized)\n\t\terror = i2c_smbus_write_byte_data(ts->client, COMMON_SETUP2,\n\t\t\t\t\t\t  ts->setup2);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn error ? error : count;\n}\n\nstatic ssize_t inv_y_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%d\\n\", !!(ts->setup2 & INV_Y));\n}\n\nstatic ssize_t inv_y_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rohm_ts_data *ts = i2c_get_clientdata(client);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 0, &val);\n\tif (error)\n\t\treturn error;\n\n\terror = mutex_lock_interruptible(&ts->input->mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (val)\n\t\tts->setup2 |= INV_Y;\n\telse\n\t\tts->setup2 &= ~INV_Y;\n\n\tif (ts->initialized)\n\t\terror = i2c_smbus_write_byte_data(client, COMMON_SETUP2,\n\t\t\t\t\t\t  ts->setup2);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn error ? error : count;\n}\n\nstatic DEVICE_ATTR_RW(swap_xy);\nstatic DEVICE_ATTR_RW(inv_x);\nstatic DEVICE_ATTR_RW(inv_y);\n\nstatic struct attribute *rohm_ts_attrs[] = {\n\t&dev_attr_swap_xy.attr,\n\t&dev_attr_inv_x.attr,\n\t&dev_attr_inv_y.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rohm_ts_attr_group = {\n\t.attrs = rohm_ts_attrs,\n};\n\nstatic int rohm_ts_device_init(struct i2c_client *client, u8 setup2)\n{\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\t \n\tudelay(200);\n\n\t \n\terror = i2c_smbus_write_byte_data(client, SYSTEM,\n\t\t\t\t\t  ANALOG_POWER_ON | CPU_POWER_OFF);\n\tif (error)\n\t\treturn error;\n\n\t \n\tudelay(200);\n\n\t \n\terror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, EX_WDAT, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, COMMON_SETUP1, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, COMMON_SETUP2, setup2);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, COMMON_SETUP3,\n\t\t\t\t\t  SEL_TBL_DEFAULT | EN_MULTI);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, THRESHOLD_GESTURE,\n\t\t\t\t\t  THRESHOLD_GESTURE_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, INTERVAL_TIME,\n\t\t\t\t\t  INTERVAL_TIME_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, CPU_FREQ, CPU_FREQ_10MHZ);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, PRM_SWOFF_TIME,\n\t\t\t\t\t  PRM_SWOFF_TIME_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, ADC_CTRL, ADC_DIV_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, ADC_WAIT, ADC_WAIT_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, STEP_X, STEP_X_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, STEP_Y, STEP_Y_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, OFFSET_X, OFFSET_X_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, OFFSET_Y, OFFSET_Y_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, THRESHOLD_TOUCH,\n\t\t\t\t\t  THRESHOLD_TOUCH_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, EVR_XY, EVR_XY_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, EVR_X, EVR_X_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, EVR_Y, EVR_Y_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, CALIBRATION_ADJUST,\n\t\t\t\t\t  CALIBRATION_ADJUST_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, SWCONT, SWCONT_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, TEST1,\n\t\t\t\t\t  DUALTOUCH_STABILIZE_ON |\n\t\t\t\t\t  DUALTOUCH_REG_ON);\n\tif (error)\n\t\treturn error;\n\n\terror = rohm_ts_load_firmware(client, BU21023_FIRMWARE_NAME);\n\tif (error) {\n\t\tdev_err(dev, \"failed to load firmware: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\terror = i2c_smbus_write_byte_data(client, CALIBRATION_REG1,\n\t\t\t\t\t  CALIBRATION_REG1_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, CALIBRATION_REG2,\n\t\t\t\t\t  CALIBRATION_REG2_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, CALIBRATION_REG3,\n\t\t\t\t\t  CALIBRATION_REG3_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\n\t\t\t\t\t  FORCE_CALIBRATION_OFF);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\n\t\t\t\t\t  FORCE_CALIBRATION_ON);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, INT_MASK,\n\t\t\t\t\t  CALIBRATION_DONE | SLEEP_OUT |\n\t\t\t\t\t  SLEEP_IN | PROGRAM_LOAD_DONE);\n\tif (error)\n\t\treturn error;\n\n\terror = i2c_smbus_write_byte_data(client, ERR_MASK,\n\t\t\t\t\t  PROGRAM_LOAD_ERR | CPU_TIMEOUT |\n\t\t\t\t\t  ADC_TIMEOUT);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = i2c_smbus_write_byte_data(client, SYSTEM,\n\t\t\t\t\t  ANALOG_POWER_ON | CPU_POWER_ON);\n\n\tenable_irq(client->irq);\n\n\treturn error;\n}\n\nstatic int rohm_ts_power_off(struct i2c_client *client)\n{\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(client, SYSTEM,\n\t\t\t\t\t  ANALOG_POWER_ON | CPU_POWER_OFF);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to power off device CPU: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, SYSTEM,\n\t\t\t\t\t  ANALOG_POWER_OFF | CPU_POWER_OFF);\n\tif (error)\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to power off the device: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic int rohm_ts_open(struct input_dev *input_dev)\n{\n\tstruct rohm_ts_data *ts = input_get_drvdata(input_dev);\n\tstruct i2c_client *client = ts->client;\n\tint error;\n\n\tif (!ts->initialized) {\n\t\terror = rohm_ts_device_init(client, ts->setup2);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"device initialization failed: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tts->initialized = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void rohm_ts_close(struct input_dev *input_dev)\n{\n\tstruct rohm_ts_data *ts = input_get_drvdata(input_dev);\n\n\trohm_ts_power_off(ts->client);\n\n\tts->initialized = false;\n}\n\nstatic int rohm_bu21023_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct rohm_ts_data *ts;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"IRQ is not assigned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!client->adapter->algo->master_xfer) {\n\t\tdev_err(dev, \"I2C level transfers not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\terror = rohm_ts_power_off(client);\n\tif (error)\n\t\treturn error;\n\n\tts = devm_kzalloc(dev, sizeof(struct rohm_ts_data), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\tts->setup2 = MAF_1SAMPLE;\n\ti2c_set_clientdata(client, ts);\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = BU21023_NAME;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = rohm_ts_open;\n\tinput->close = rohm_ts_close;\n\n\tts->input = input;\n\tinput_set_drvdata(input, ts);\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t     ROHM_TS_ABS_X_MIN, ROHM_TS_ABS_X_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t     ROHM_TS_ABS_Y_MIN, ROHM_TS_ABS_Y_MAX, 0, 0);\n\n\terror = input_mt_init_slots(input, MAX_CONTACTS,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_TRACK |\n\t\t\t\t    INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"failed to multi touch slots initialization\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, rohm_ts_soft_irq,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(dev, &rohm_ts_attr_group);\n\tif (error) {\n\t\tdev_err(dev, \"failed to create sysfs group: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn error;\n}\n\nstatic const struct i2c_device_id rohm_bu21023_i2c_id[] = {\n\t{ BU21023_NAME, 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, rohm_bu21023_i2c_id);\n\nstatic struct i2c_driver rohm_bu21023_i2c_driver = {\n\t.driver = {\n\t\t.name = BU21023_NAME,\n\t},\n\t.probe = rohm_bu21023_i2c_probe,\n\t.id_table = rohm_bu21023_i2c_id,\n};\nmodule_i2c_driver(rohm_bu21023_i2c_driver);\n\nMODULE_DESCRIPTION(\"ROHM BU21023/24 Touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"ROHM Co., Ltd.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}