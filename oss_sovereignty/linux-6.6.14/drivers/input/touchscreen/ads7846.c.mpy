{
  "module_name": "ads7846.c",
  "hash_id": "bc77d5b7f00b5ef1f3c2d46f8835a2b8ed887d4b950dcf65784b3c93474c2099",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ads7846.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/hwmon.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/ads7846.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n \n\n#define TS_POLL_DELAY\t1\t \n#define TS_POLL_PERIOD\t5\t \n\n \n#define\tSAMPLE_BITS\t(8   + 16   + 2  )\n\nstruct ads7846_buf {\n\tu8 cmd;\n\t__be16 data;\n} __packed;\n\nstruct ads7846_buf_layout {\n\tunsigned int offset;\n\tunsigned int count;\n\tunsigned int skip;\n};\n\n \nstruct ads7846_packet {\n\tunsigned int count;\n\tunsigned int count_skip;\n\tunsigned int cmds;\n\tunsigned int last_cmd_idx;\n\tstruct ads7846_buf_layout l[5];\n\tstruct ads7846_buf *rx;\n\tstruct ads7846_buf *tx;\n\n\tstruct ads7846_buf pwrdown_cmd;\n\n\tbool ignore;\n\tu16 x, y, z1, z2;\n};\n\nstruct ads7846 {\n\tstruct input_dev\t*input;\n\tchar\t\t\tphys[32];\n\tchar\t\t\tname[32];\n\n\tstruct spi_device\t*spi;\n\tstruct regulator\t*reg;\n\n\tu16\t\t\tmodel;\n\tu16\t\t\tvref_mv;\n\tu16\t\t\tvref_delay_usecs;\n\tu16\t\t\tx_plate_ohms;\n\tu16\t\t\tpressure_max;\n\n\tbool\t\t\tswap_xy;\n\tbool\t\t\tuse_internal;\n\n\tstruct ads7846_packet\t*packet;\n\n\tstruct spi_transfer\txfer[18];\n\tstruct spi_message\tmsg[5];\n\tint\t\t\tmsg_count;\n\twait_queue_head_t\twait;\n\n\tbool\t\t\tpendown;\n\n\tint\t\t\tread_cnt;\n\tint\t\t\tread_rep;\n\tint\t\t\tlast_read;\n\n\tu16\t\t\tdebounce_max;\n\tu16\t\t\tdebounce_tol;\n\tu16\t\t\tdebounce_rep;\n\n\tu16\t\t\tpenirq_recheck_delay_usecs;\n\n\tstruct touchscreen_properties core_prop;\n\n\tstruct mutex\t\tlock;\n\tbool\t\t\tstopped;\t \n\tbool\t\t\tdisabled;\t \n\tbool\t\t\tsuspended;\t \n\n\tint\t\t\t(*filter)(void *data, int data_idx, int *val);\n\tvoid\t\t\t*filter_data;\n\tint\t\t\t(*get_pendown_state)(void);\n\tstruct gpio_desc\t*gpio_pendown;\n\n\tvoid\t\t\t(*wait_for_sync)(void);\n};\n\nenum ads7846_filter {\n\tADS7846_FILTER_OK,\n\tADS7846_FILTER_REPEAT,\n\tADS7846_FILTER_IGNORE,\n};\n\n \n#if\t0\n#define\tCS_CHANGE(xfer)\t((xfer).cs_change = 1)\n#else\n#define\tCS_CHANGE(xfer)\t((xfer).cs_change = 0)\n#endif\n\n \n\n \n#define\tADS_START\t\t(1 << 7)\n#define\tADS_A2A1A0_d_y\t\t(1 << 4)\t \n#define\tADS_A2A1A0_d_z1\t\t(3 << 4)\t \n#define\tADS_A2A1A0_d_z2\t\t(4 << 4)\t \n#define\tADS_A2A1A0_d_x\t\t(5 << 4)\t \n#define\tADS_A2A1A0_temp0\t(0 << 4)\t \n#define\tADS_A2A1A0_vbatt\t(2 << 4)\t \n#define\tADS_A2A1A0_vaux\t\t(6 << 4)\t \n#define\tADS_A2A1A0_temp1\t(7 << 4)\t \n#define\tADS_8_BIT\t\t(1 << 3)\n#define\tADS_12_BIT\t\t(0 << 3)\n#define\tADS_SER\t\t\t(1 << 2)\t \n#define\tADS_DFR\t\t\t(0 << 2)\t \n#define\tADS_PD10_PDOWN\t\t(0 << 0)\t \n#define\tADS_PD10_ADC_ON\t\t(1 << 0)\t \n#define\tADS_PD10_REF_ON\t\t(2 << 0)\t \n#define\tADS_PD10_ALL_ON\t\t(3 << 0)\t \n\n#define\tMAX_12BIT\t((1<<12)-1)\n\n \n#define\tREAD_12BIT_DFR(x, adc, vref) (ADS_START | ADS_A2A1A0_d_ ## x \\\n\t| ADS_12_BIT | ADS_DFR | \\\n\t(adc ? ADS_PD10_ADC_ON : 0) | (vref ? ADS_PD10_REF_ON : 0))\n\n#define\tREAD_Y(vref)\t(READ_12BIT_DFR(y,  1, vref))\n#define\tREAD_Z1(vref)\t(READ_12BIT_DFR(z1, 1, vref))\n#define\tREAD_Z2(vref)\t(READ_12BIT_DFR(z2, 1, vref))\n#define\tREAD_X(vref)\t(READ_12BIT_DFR(x,  1, vref))\n#define\tPWRDOWN\t\t(READ_12BIT_DFR(y,  0, 0))\t \n\n \n#define\tREAD_12BIT_SER(x) (ADS_START | ADS_A2A1A0_ ## x \\\n\t| ADS_12_BIT | ADS_SER)\n\n#define\tREF_ON\t(READ_12BIT_DFR(x, 1, 1))\n#define\tREF_OFF\t(READ_12BIT_DFR(y, 0, 0))\n\n \nenum ads7846_cmds {\n\tADS7846_X,\n\tADS7846_Y,\n\tADS7846_Z1,\n\tADS7846_Z2,\n\tADS7846_PWDOWN,\n};\n\nstatic int get_pendown_state(struct ads7846 *ts)\n{\n\tif (ts->get_pendown_state)\n\t\treturn ts->get_pendown_state();\n\n\treturn gpiod_get_value(ts->gpio_pendown);\n}\n\nstatic void ads7846_report_pen_up(struct ads7846 *ts)\n{\n\tstruct input_dev *input = ts->input;\n\n\tinput_report_key(input, BTN_TOUCH, 0);\n\tinput_report_abs(input, ABS_PRESSURE, 0);\n\tinput_sync(input);\n\n\tts->pendown = false;\n\tdev_vdbg(&ts->spi->dev, \"UP\\n\");\n}\n\n \nstatic void ads7846_stop(struct ads7846 *ts)\n{\n\tif (!ts->disabled && !ts->suspended) {\n\t\t \n\t\tts->stopped = true;\n\t\tmb();\n\t\twake_up(&ts->wait);\n\t\tdisable_irq(ts->spi->irq);\n\t}\n}\n\n \nstatic void ads7846_restart(struct ads7846 *ts)\n{\n\tif (!ts->disabled && !ts->suspended) {\n\t\t \n\t\tif (ts->pendown && !get_pendown_state(ts))\n\t\t\tads7846_report_pen_up(ts);\n\n\t\t \n\t\tts->stopped = false;\n\t\tmb();\n\t\tenable_irq(ts->spi->irq);\n\t}\n}\n\n \nstatic void __ads7846_disable(struct ads7846 *ts)\n{\n\tads7846_stop(ts);\n\tregulator_disable(ts->reg);\n\n\t \n}\n\n \nstatic void __ads7846_enable(struct ads7846 *ts)\n{\n\tint error;\n\n\terror = regulator_enable(ts->reg);\n\tif (error != 0)\n\t\tdev_err(&ts->spi->dev, \"Failed to enable supply: %d\\n\", error);\n\n\tads7846_restart(ts);\n}\n\nstatic void ads7846_disable(struct ads7846 *ts)\n{\n\tmutex_lock(&ts->lock);\n\n\tif (!ts->disabled) {\n\n\t\tif  (!ts->suspended)\n\t\t\t__ads7846_disable(ts);\n\n\t\tts->disabled = true;\n\t}\n\n\tmutex_unlock(&ts->lock);\n}\n\nstatic void ads7846_enable(struct ads7846 *ts)\n{\n\tmutex_lock(&ts->lock);\n\n\tif (ts->disabled) {\n\n\t\tts->disabled = false;\n\n\t\tif (!ts->suspended)\n\t\t\t__ads7846_enable(ts);\n\t}\n\n\tmutex_unlock(&ts->lock);\n}\n\n \n\n \n\nstruct ser_req {\n\tu8\t\t\tref_on;\n\tu8\t\t\tcommand;\n\tu8\t\t\tref_off;\n\tu16\t\t\tscratch;\n\tstruct spi_message\tmsg;\n\tstruct spi_transfer\txfer[6];\n\t \n\t__be16 sample ____cacheline_aligned;\n};\n\nstruct ads7845_ser_req {\n\tu8\t\t\tcommand[3];\n\tstruct spi_message\tmsg;\n\tstruct spi_transfer\txfer[2];\n\t \n\tu8 sample[3] ____cacheline_aligned;\n};\n\nstatic int ads7846_read12_ser(struct device *dev, unsigned command)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\tstruct ser_req *req;\n\tint status;\n\n\treq = kzalloc(sizeof *req, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tspi_message_init(&req->msg);\n\n\t \n\tif (ts->use_internal) {\n\t\treq->ref_on = REF_ON;\n\t\treq->xfer[0].tx_buf = &req->ref_on;\n\t\treq->xfer[0].len = 1;\n\t\tspi_message_add_tail(&req->xfer[0], &req->msg);\n\n\t\treq->xfer[1].rx_buf = &req->scratch;\n\t\treq->xfer[1].len = 2;\n\n\t\t \n\t\treq->xfer[1].delay.value = ts->vref_delay_usecs;\n\t\treq->xfer[1].delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tspi_message_add_tail(&req->xfer[1], &req->msg);\n\n\t\t \n\t\tcommand |= ADS_PD10_REF_ON;\n\t}\n\n\t \n\tcommand |= ADS_PD10_ADC_ON;\n\n\t \n\treq->command = (u8) command;\n\treq->xfer[2].tx_buf = &req->command;\n\treq->xfer[2].len = 1;\n\tspi_message_add_tail(&req->xfer[2], &req->msg);\n\n\treq->xfer[3].rx_buf = &req->sample;\n\treq->xfer[3].len = 2;\n\tspi_message_add_tail(&req->xfer[3], &req->msg);\n\n\t \n\n\t \n\treq->ref_off = PWRDOWN;\n\treq->xfer[4].tx_buf = &req->ref_off;\n\treq->xfer[4].len = 1;\n\tspi_message_add_tail(&req->xfer[4], &req->msg);\n\n\treq->xfer[5].rx_buf = &req->scratch;\n\treq->xfer[5].len = 2;\n\tCS_CHANGE(req->xfer[5]);\n\tspi_message_add_tail(&req->xfer[5], &req->msg);\n\n\tmutex_lock(&ts->lock);\n\tads7846_stop(ts);\n\tstatus = spi_sync(spi, &req->msg);\n\tads7846_restart(ts);\n\tmutex_unlock(&ts->lock);\n\n\tif (status == 0) {\n\t\t \n\t\tstatus = be16_to_cpu(req->sample);\n\t\tstatus = status >> 3;\n\t\tstatus &= 0x0fff;\n\t}\n\n\tkfree(req);\n\treturn status;\n}\n\nstatic int ads7845_read12_ser(struct device *dev, unsigned command)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\tstruct ads7845_ser_req *req;\n\tint status;\n\n\treq = kzalloc(sizeof *req, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tspi_message_init(&req->msg);\n\n\treq->command[0] = (u8) command;\n\treq->xfer[0].tx_buf = req->command;\n\treq->xfer[0].rx_buf = req->sample;\n\treq->xfer[0].len = 3;\n\tspi_message_add_tail(&req->xfer[0], &req->msg);\n\n\tmutex_lock(&ts->lock);\n\tads7846_stop(ts);\n\tstatus = spi_sync(spi, &req->msg);\n\tads7846_restart(ts);\n\tmutex_unlock(&ts->lock);\n\n\tif (status == 0) {\n\t\t \n\t\tstatus = get_unaligned_be16(&req->sample[1]);\n\t\tstatus = status >> 3;\n\t\tstatus &= 0x0fff;\n\t}\n\n\tkfree(req);\n\treturn status;\n}\n\n#if IS_ENABLED(CONFIG_HWMON)\n\n#define SHOW(name, var, adjust) static ssize_t \\\nname ## _show(struct device *dev, struct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct ads7846 *ts = dev_get_drvdata(dev); \\\n\tssize_t v = ads7846_read12_ser(&ts->spi->dev, \\\n\t\t\tREAD_12BIT_SER(var)); \\\n\tif (v < 0) \\\n\t\treturn v; \\\n\treturn sprintf(buf, \"%u\\n\", adjust(ts, v)); \\\n} \\\nstatic DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);\n\n\n \nstatic inline unsigned null_adjust(struct ads7846 *ts, ssize_t v)\n{\n\treturn v;\n}\n\nSHOW(temp0, temp0, null_adjust)\t\t \nSHOW(temp1, temp1, null_adjust)\t\t \n\n\n \nstatic inline unsigned vaux_adjust(struct ads7846 *ts, ssize_t v)\n{\n\tunsigned retval = v;\n\n\t \n\tretval *= ts->vref_mv;\n\tretval = retval >> 12;\n\n\treturn retval;\n}\n\nstatic inline unsigned vbatt_adjust(struct ads7846 *ts, ssize_t v)\n{\n\tunsigned retval = vaux_adjust(ts, v);\n\n\t \n\tif (ts->model == 7846)\n\t\tretval *= 4;\n\n\treturn retval;\n}\n\nSHOW(in0_input, vaux, vaux_adjust)\nSHOW(in1_input, vbatt, vbatt_adjust)\n\nstatic umode_t ads7846_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\n\tif (ts->model == 7843 && index < 2)\t \n\t\treturn 0;\n\tif (ts->model == 7845 && index != 2)\t \n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *ads7846_attributes[] = {\n\t&dev_attr_temp0.attr,\t\t \n\t&dev_attr_temp1.attr,\t\t \n\t&dev_attr_in0_input.attr,\t \n\t&dev_attr_in1_input.attr,\t \n\tNULL,\n};\n\nstatic const struct attribute_group ads7846_attr_group = {\n\t.attrs = ads7846_attributes,\n\t.is_visible = ads7846_is_visible,\n};\n__ATTRIBUTE_GROUPS(ads7846_attr);\n\nstatic int ads784x_hwmon_register(struct spi_device *spi, struct ads7846 *ts)\n{\n\tstruct device *hwmon;\n\n\t \n\tswitch (ts->model) {\n\tcase 7846:\n\t\tif (!ts->vref_mv) {\n\t\t\tdev_dbg(&spi->dev, \"assuming 2.5V internal vREF\\n\");\n\t\t\tts->vref_mv = 2500;\n\t\t\tts->use_internal = true;\n\t\t}\n\t\tbreak;\n\tcase 7845:\n\tcase 7843:\n\t\tif (!ts->vref_mv) {\n\t\t\tdev_warn(&spi->dev,\n\t\t\t\t\"external vREF for ADS%d not specified\\n\",\n\t\t\t\tts->model);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\thwmon = devm_hwmon_device_register_with_groups(&spi->dev,\n\t\t\t\t\t\t       spi->modalias, ts,\n\t\t\t\t\t\t       ads7846_attr_groups);\n\n\treturn PTR_ERR_OR_ZERO(hwmon);\n}\n\n#else\nstatic inline int ads784x_hwmon_register(struct spi_device *spi,\n\t\t\t\t\t struct ads7846 *ts)\n{\n\treturn 0;\n}\n#endif\n\nstatic ssize_t ads7846_pen_down_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->pendown);\n}\n\nstatic DEVICE_ATTR(pen_down, S_IRUGO, ads7846_pen_down_show, NULL);\n\nstatic ssize_t ads7846_disable_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->disabled);\n}\n\nstatic ssize_t ads7846_disable_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\tunsigned int i;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &i);\n\tif (err)\n\t\treturn err;\n\n\tif (i)\n\t\tads7846_disable(ts);\n\telse\n\t\tads7846_enable(ts);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(disable, 0664, ads7846_disable_show, ads7846_disable_store);\n\nstatic struct attribute *ads784x_attributes[] = {\n\t&dev_attr_pen_down.attr,\n\t&dev_attr_disable.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ads784x_attr_group = {\n\t.attrs = ads784x_attributes,\n};\n\n \n\nstatic void null_wait_for_sync(void)\n{\n}\n\nstatic int ads7846_debounce_filter(void *ads, int data_idx, int *val)\n{\n\tstruct ads7846 *ts = ads;\n\n\tif (!ts->read_cnt || (abs(ts->last_read - *val) > ts->debounce_tol)) {\n\t\t \n\t\tts->read_rep = 0;\n\t\t \n\t\tif (ts->read_cnt < ts->debounce_max) {\n\t\t\tts->last_read = *val;\n\t\t\tts->read_cnt++;\n\t\t\treturn ADS7846_FILTER_REPEAT;\n\t\t} else {\n\t\t\t \n\t\t\tts->read_cnt = 0;\n\t\t\treturn ADS7846_FILTER_IGNORE;\n\t\t}\n\t} else {\n\t\tif (++ts->read_rep > ts->debounce_rep) {\n\t\t\t \n\t\t\tts->read_cnt = 0;\n\t\t\tts->read_rep = 0;\n\t\t\treturn ADS7846_FILTER_OK;\n\t\t} else {\n\t\t\t \n\t\t\tts->read_cnt++;\n\t\t\treturn ADS7846_FILTER_REPEAT;\n\t\t}\n\t}\n}\n\nstatic int ads7846_no_filter(void *ads, int data_idx, int *val)\n{\n\treturn ADS7846_FILTER_OK;\n}\n\nstatic int ads7846_get_value(struct ads7846_buf *buf)\n{\n\tint value;\n\n\tvalue = be16_to_cpup(&buf->data);\n\n\t \n\treturn (value >> 3) & 0xfff;\n}\n\nstatic void ads7846_set_cmd_val(struct ads7846 *ts, enum ads7846_cmds cmd_idx,\n\t\t\t\tu16 val)\n{\n\tstruct ads7846_packet *packet = ts->packet;\n\n\tswitch (cmd_idx) {\n\tcase ADS7846_Y:\n\t\tpacket->y = val;\n\t\tbreak;\n\tcase ADS7846_X:\n\t\tpacket->x = val;\n\t\tbreak;\n\tcase ADS7846_Z1:\n\t\tpacket->z1 = val;\n\t\tbreak;\n\tcase ADS7846_Z2:\n\t\tpacket->z2 = val;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic u8 ads7846_get_cmd(enum ads7846_cmds cmd_idx, int vref)\n{\n\tswitch (cmd_idx) {\n\tcase ADS7846_Y:\n\t\treturn READ_Y(vref);\n\tcase ADS7846_X:\n\t\treturn READ_X(vref);\n\n\t \n\tcase ADS7846_Z1:\n\t\treturn READ_Z1(vref);\n\tcase ADS7846_Z2:\n\t\treturn READ_Z2(vref);\n\tcase ADS7846_PWDOWN:\n\t\treturn PWRDOWN;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\treturn 0;\n}\n\nstatic bool ads7846_cmd_need_settle(enum ads7846_cmds cmd_idx)\n{\n\tswitch (cmd_idx) {\n\tcase ADS7846_X:\n\tcase ADS7846_Y:\n\tcase ADS7846_Z1:\n\tcase ADS7846_Z2:\n\t\treturn true;\n\tcase ADS7846_PWDOWN:\n\t\treturn false;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\treturn false;\n}\n\nstatic int ads7846_filter(struct ads7846 *ts)\n{\n\tstruct ads7846_packet *packet = ts->packet;\n\tint action;\n\tint val;\n\tunsigned int cmd_idx, b;\n\n\tpacket->ignore = false;\n\tfor (cmd_idx = packet->last_cmd_idx; cmd_idx < packet->cmds - 1; cmd_idx++) {\n\t\tstruct ads7846_buf_layout *l = &packet->l[cmd_idx];\n\n\t\tpacket->last_cmd_idx = cmd_idx;\n\n\t\tfor (b = l->skip; b < l->count; b++) {\n\t\t\tval = ads7846_get_value(&packet->rx[l->offset + b]);\n\n\t\t\taction = ts->filter(ts->filter_data, cmd_idx, &val);\n\t\t\tif (action == ADS7846_FILTER_REPEAT) {\n\t\t\t\tif (b == l->count - 1)\n\t\t\t\t\treturn -EAGAIN;\n\t\t\t} else if (action == ADS7846_FILTER_OK) {\n\t\t\t\tads7846_set_cmd_val(ts, cmd_idx, val);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpacket->ignore = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ads7846_read_state(struct ads7846 *ts)\n{\n\tstruct ads7846_packet *packet = ts->packet;\n\tstruct spi_message *m;\n\tint msg_idx = 0;\n\tint error;\n\n\tpacket->last_cmd_idx = 0;\n\n\twhile (true) {\n\t\tts->wait_for_sync();\n\n\t\tm = &ts->msg[msg_idx];\n\t\terror = spi_sync(ts->spi, m);\n\t\tif (error) {\n\t\t\tdev_err(&ts->spi->dev, \"spi_sync --> %d\\n\", error);\n\t\t\tpacket->ignore = true;\n\t\t\treturn;\n\t\t}\n\n\t\terror = ads7846_filter(ts);\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}\n\nstatic void ads7846_report_state(struct ads7846 *ts)\n{\n\tstruct ads7846_packet *packet = ts->packet;\n\tunsigned int Rt;\n\tu16 x, y, z1, z2;\n\n\tx = packet->x;\n\ty = packet->y;\n\tif (ts->model == 7845) {\n\t\tz1 = 0;\n\t\tz2 = 0;\n\t} else {\n\t\tz1 = packet->z1;\n\t\tz2 = packet->z2;\n\t}\n\n\t \n\tif (x == MAX_12BIT)\n\t\tx = 0;\n\n\tif (ts->model == 7843 || ts->model == 7845) {\n\t\tRt = ts->pressure_max / 2;\n\t} else if (likely(x && z1)) {\n\t\t \n\t\tRt = z2;\n\t\tRt -= z1;\n\t\tRt *= ts->x_plate_ohms;\n\t\tRt = DIV_ROUND_CLOSEST(Rt, 16);\n\t\tRt *= x;\n\t\tRt /= z1;\n\t\tRt = DIV_ROUND_CLOSEST(Rt, 256);\n\t} else {\n\t\tRt = 0;\n\t}\n\n\t \n\tif (packet->ignore || Rt > ts->pressure_max) {\n\t\tdev_vdbg(&ts->spi->dev, \"ignored %d pressure %d\\n\",\n\t\t\t packet->ignore, Rt);\n\t\treturn;\n\t}\n\n\t \n\tif (ts->penirq_recheck_delay_usecs) {\n\t\tudelay(ts->penirq_recheck_delay_usecs);\n\t\tif (!get_pendown_state(ts))\n\t\t\tRt = 0;\n\t}\n\n\t \n\tif (Rt) {\n\t\tstruct input_dev *input = ts->input;\n\n\t\tif (!ts->pendown) {\n\t\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\t\tts->pendown = true;\n\t\t\tdev_vdbg(&ts->spi->dev, \"DOWN\\n\");\n\t\t}\n\n\t\ttouchscreen_report_pos(input, &ts->core_prop, x, y, false);\n\t\tinput_report_abs(input, ABS_PRESSURE, ts->pressure_max - Rt);\n\n\t\tinput_sync(input);\n\t\tdev_vdbg(&ts->spi->dev, \"%4d/%4d/%4d\\n\", x, y, Rt);\n\t}\n}\n\nstatic irqreturn_t ads7846_hard_irq(int irq, void *handle)\n{\n\tstruct ads7846 *ts = handle;\n\n\treturn get_pendown_state(ts) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t ads7846_irq(int irq, void *handle)\n{\n\tstruct ads7846 *ts = handle;\n\n\t \n\tmsleep(TS_POLL_DELAY);\n\n\twhile (!ts->stopped && get_pendown_state(ts)) {\n\n\t\t \n\t\tads7846_read_state(ts);\n\n\t\tif (!ts->stopped)\n\t\t\tads7846_report_state(ts);\n\n\t\twait_event_timeout(ts->wait, ts->stopped,\n\t\t\t\t   msecs_to_jiffies(TS_POLL_PERIOD));\n\t}\n\n\tif (ts->pendown && !ts->stopped)\n\t\tads7846_report_pen_up(ts);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ads7846_suspend(struct device *dev)\n{\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->lock);\n\n\tif (!ts->suspended) {\n\n\t\tif (!ts->disabled)\n\t\t\t__ads7846_disable(ts);\n\n\t\tif (device_may_wakeup(&ts->spi->dev))\n\t\t\tenable_irq_wake(ts->spi->irq);\n\n\t\tts->suspended = true;\n\t}\n\n\tmutex_unlock(&ts->lock);\n\n\treturn 0;\n}\n\nstatic int ads7846_resume(struct device *dev)\n{\n\tstruct ads7846 *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->lock);\n\n\tif (ts->suspended) {\n\n\t\tts->suspended = false;\n\n\t\tif (device_may_wakeup(&ts->spi->dev))\n\t\t\tdisable_irq_wake(ts->spi->irq);\n\n\t\tif (!ts->disabled)\n\t\t\t__ads7846_enable(ts);\n\t}\n\n\tmutex_unlock(&ts->lock);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ads7846_pm, ads7846_suspend, ads7846_resume);\n\nstatic int ads7846_setup_pendown(struct spi_device *spi,\n\t\t\t\t struct ads7846 *ts,\n\t\t\t\t const struct ads7846_platform_data *pdata)\n{\n\t \n\n\tif (pdata->get_pendown_state) {\n\t\tts->get_pendown_state = pdata->get_pendown_state;\n\t} else {\n\t\tts->gpio_pendown = gpiod_get(&spi->dev, \"pendown\", GPIOD_IN);\n\t\tif (IS_ERR(ts->gpio_pendown)) {\n\t\t\tdev_err(&spi->dev, \"failed to request pendown GPIO\\n\");\n\t\t\treturn PTR_ERR(ts->gpio_pendown);\n\t\t}\n\t\tif (pdata->gpio_pendown_debounce)\n\t\t\tgpiod_set_debounce(ts->gpio_pendown,\n\t\t\t\t\t   pdata->gpio_pendown_debounce);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ads7846_setup_spi_msg(struct ads7846 *ts,\n\t\t\t\t  const struct ads7846_platform_data *pdata)\n{\n\tstruct spi_message *m = &ts->msg[0];\n\tstruct spi_transfer *x = ts->xfer;\n\tstruct ads7846_packet *packet = ts->packet;\n\tint vref = pdata->keep_vref_on;\n\tunsigned int count, offset = 0;\n\tunsigned int cmd_idx, b;\n\tunsigned long time;\n\tsize_t size = 0;\n\n\t \n\ttime = NSEC_PER_SEC / ts->spi->max_speed_hz;\n\n\tcount = pdata->settle_delay_usecs * NSEC_PER_USEC / time;\n\tpacket->count_skip = DIV_ROUND_UP(count, 24);\n\n\tif (ts->debounce_max && ts->debounce_rep)\n\t\t \n\t\tpacket->count = ts->debounce_rep + 2;\n\telse\n\t\tpacket->count = 1;\n\n\tif (ts->model == 7846)\n\t\tpacket->cmds = 5;  \n\telse\n\t\tpacket->cmds = 3;  \n\n\tfor (cmd_idx = 0; cmd_idx < packet->cmds; cmd_idx++) {\n\t\tstruct ads7846_buf_layout *l = &packet->l[cmd_idx];\n\t\tunsigned int max_count;\n\n\t\tif (cmd_idx == packet->cmds - 1)\n\t\t\tcmd_idx = ADS7846_PWDOWN;\n\n\t\tif (ads7846_cmd_need_settle(cmd_idx))\n\t\t\tmax_count = packet->count + packet->count_skip;\n\t\telse\n\t\t\tmax_count = packet->count;\n\n\t\tl->offset = offset;\n\t\toffset += max_count;\n\t\tl->count = max_count;\n\t\tl->skip = packet->count_skip;\n\t\tsize += sizeof(*packet->tx) * max_count;\n\t}\n\n\tpacket->tx = devm_kzalloc(&ts->spi->dev, size, GFP_KERNEL);\n\tif (!packet->tx)\n\t\treturn -ENOMEM;\n\n\tpacket->rx = devm_kzalloc(&ts->spi->dev, size, GFP_KERNEL);\n\tif (!packet->rx)\n\t\treturn -ENOMEM;\n\n\tif (ts->model == 7873) {\n\t\t \n\t\tts->model = 7846;\n\t\tvref = 0;\n\t}\n\n\tts->msg_count = 1;\n\tspi_message_init(m);\n\tm->context = ts;\n\n\tfor (cmd_idx = 0; cmd_idx < packet->cmds; cmd_idx++) {\n\t\tstruct ads7846_buf_layout *l = &packet->l[cmd_idx];\n\t\tu8 cmd;\n\n\t\tif (cmd_idx == packet->cmds - 1)\n\t\t\tcmd_idx = ADS7846_PWDOWN;\n\n\t\tcmd = ads7846_get_cmd(cmd_idx, vref);\n\n\t\tfor (b = 0; b < l->count; b++)\n\t\t\tpacket->tx[l->offset + b].cmd = cmd;\n\t}\n\n\tx->tx_buf = packet->tx;\n\tx->rx_buf = packet->rx;\n\tx->len = size;\n\tspi_message_add_tail(x, m);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ads7846_dt_ids[] = {\n\t{ .compatible = \"ti,tsc2046\",\t.data = (void *) 7846 },\n\t{ .compatible = \"ti,ads7843\",\t.data = (void *) 7843 },\n\t{ .compatible = \"ti,ads7845\",\t.data = (void *) 7845 },\n\t{ .compatible = \"ti,ads7846\",\t.data = (void *) 7846 },\n\t{ .compatible = \"ti,ads7873\",\t.data = (void *) 7873 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ads7846_dt_ids);\n\nstatic const struct ads7846_platform_data *ads7846_get_props(struct device *dev)\n{\n\tstruct ads7846_platform_data *pdata;\n\tu32 value;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->model = (uintptr_t)device_get_match_data(dev);\n\n\tdevice_property_read_u16(dev, \"ti,vref-delay-usecs\",\n\t\t\t\t &pdata->vref_delay_usecs);\n\tdevice_property_read_u16(dev, \"ti,vref-mv\", &pdata->vref_mv);\n\tpdata->keep_vref_on = device_property_read_bool(dev, \"ti,keep-vref-on\");\n\n\tpdata->swap_xy = device_property_read_bool(dev, \"ti,swap-xy\");\n\n\tdevice_property_read_u16(dev, \"ti,settle-delay-usec\",\n\t\t\t\t &pdata->settle_delay_usecs);\n\tdevice_property_read_u16(dev, \"ti,penirq-recheck-delay-usecs\",\n\t\t\t\t &pdata->penirq_recheck_delay_usecs);\n\n\tdevice_property_read_u16(dev, \"ti,x-plate-ohms\", &pdata->x_plate_ohms);\n\tdevice_property_read_u16(dev, \"ti,y-plate-ohms\", &pdata->y_plate_ohms);\n\n\tdevice_property_read_u16(dev, \"ti,x-min\", &pdata->x_min);\n\tdevice_property_read_u16(dev, \"ti,y-min\", &pdata->y_min);\n\tdevice_property_read_u16(dev, \"ti,x-max\", &pdata->x_max);\n\tdevice_property_read_u16(dev, \"ti,y-max\", &pdata->y_max);\n\n\t \n\tdevice_property_read_u16(dev, \"ti,pressure-min\", &pdata->pressure_min);\n\tif (!device_property_read_u32(dev, \"touchscreen-min-pressure\", &value))\n\t\tpdata->pressure_min = (u16) value;\n\tdevice_property_read_u16(dev, \"ti,pressure-max\", &pdata->pressure_max);\n\n\tdevice_property_read_u16(dev, \"ti,debounce-max\", &pdata->debounce_max);\n\tif (!device_property_read_u32(dev, \"touchscreen-average-samples\", &value))\n\t\tpdata->debounce_max = (u16) value;\n\tdevice_property_read_u16(dev, \"ti,debounce-tol\", &pdata->debounce_tol);\n\tdevice_property_read_u16(dev, \"ti,debounce-rep\", &pdata->debounce_rep);\n\n\tdevice_property_read_u32(dev, \"ti,pendown-gpio-debounce\",\n\t\t\t     &pdata->gpio_pendown_debounce);\n\n\tpdata->wakeup = device_property_read_bool(dev, \"wakeup-source\") ||\n\t\t\tdevice_property_read_bool(dev, \"linux,wakeup\");\n\n\treturn pdata;\n}\n\nstatic void ads7846_regulator_disable(void *regulator)\n{\n\tregulator_disable(regulator);\n}\n\nstatic int ads7846_probe(struct spi_device *spi)\n{\n\tconst struct ads7846_platform_data *pdata;\n\tstruct ads7846 *ts;\n\tstruct device *dev = &spi->dev;\n\tstruct ads7846_packet *packet;\n\tstruct input_dev *input_dev;\n\tunsigned long irq_flags;\n\tint err;\n\n\tif (!spi->irq) {\n\t\tdev_dbg(dev, \"no IRQ?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (spi->max_speed_hz > (125000 * SAMPLE_BITS)) {\n\t\tdev_err(dev, \"f(sample) %d KHz?\\n\",\n\t\t\t(spi->max_speed_hz/SAMPLE_BITS)/1000);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspi->bits_per_word = 8;\n\tspi->mode &= ~SPI_MODE_X_MASK;\n\tspi->mode |= SPI_MODE_0;\n\terr = spi_setup(spi);\n\tif (err < 0)\n\t\treturn err;\n\n\tts = devm_kzalloc(dev, sizeof(struct ads7846), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tpacket = devm_kzalloc(dev, sizeof(struct ads7846_packet), GFP_KERNEL);\n\tif (!packet)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, ts);\n\n\tts->packet = packet;\n\tts->spi = spi;\n\tts->input = input_dev;\n\n\tmutex_init(&ts->lock);\n\tinit_waitqueue_head(&ts->wait);\n\n\tpdata = dev_get_platdata(dev);\n\tif (!pdata) {\n\t\tpdata = ads7846_get_props(dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tts->model = pdata->model ? : 7846;\n\tts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;\n\tts->x_plate_ohms = pdata->x_plate_ohms ? : 400;\n\tts->vref_mv = pdata->vref_mv;\n\n\tif (pdata->debounce_max) {\n\t\tts->debounce_max = pdata->debounce_max;\n\t\tif (ts->debounce_max < 2)\n\t\t\tts->debounce_max = 2;\n\t\tts->debounce_tol = pdata->debounce_tol;\n\t\tts->debounce_rep = pdata->debounce_rep;\n\t\tts->filter = ads7846_debounce_filter;\n\t\tts->filter_data = ts;\n\t} else {\n\t\tts->filter = ads7846_no_filter;\n\t}\n\n\terr = ads7846_setup_pendown(spi, ts, pdata);\n\tif (err)\n\t\treturn err;\n\n\tif (pdata->penirq_recheck_delay_usecs)\n\t\tts->penirq_recheck_delay_usecs =\n\t\t\t\tpdata->penirq_recheck_delay_usecs;\n\n\tts->wait_for_sync = pdata->wait_for_sync ? : null_wait_for_sync;\n\n\tsnprintf(ts->phys, sizeof(ts->phys), \"%s/input0\", dev_name(dev));\n\tsnprintf(ts->name, sizeof(ts->name), \"ADS%d Touchscreen\", ts->model);\n\n\tinput_dev->name = ts->name;\n\tinput_dev->phys = ts->phys;\n\n\tinput_dev->id.bustype = BUS_SPI;\n\tinput_dev->id.product = pdata->model;\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\tpdata->x_min ? : 0,\n\t\t\tpdata->x_max ? : MAX_12BIT,\n\t\t\t0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\tpdata->y_min ? : 0,\n\t\t\tpdata->y_max ? : MAX_12BIT,\n\t\t\t0, 0);\n\tif (ts->model != 7845)\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE,\n\t\t\t\tpdata->pressure_min, pdata->pressure_max, 0, 0);\n\n\t \n\ttouchscreen_parse_properties(ts->input, false, &ts->core_prop);\n\tts->pressure_max = input_abs_get_max(input_dev, ABS_PRESSURE) ? : ~0;\n\n\t \n\tif (!ts->core_prop.swap_x_y && pdata->swap_xy) {\n\t\tswap(input_dev->absinfo[ABS_X], input_dev->absinfo[ABS_Y]);\n\t\tts->core_prop.swap_x_y = true;\n\t}\n\n\tads7846_setup_spi_msg(ts, pdata);\n\n\tts->reg = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(ts->reg)) {\n\t\terr = PTR_ERR(ts->reg);\n\t\tdev_err(dev, \"unable to get regulator: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = regulator_enable(ts->reg);\n\tif (err) {\n\t\tdev_err(dev, \"unable to enable regulator: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(dev, ads7846_regulator_disable, ts->reg);\n\tif (err)\n\t\treturn err;\n\n\tirq_flags = pdata->irq_flags ? : IRQF_TRIGGER_FALLING;\n\tirq_flags |= IRQF_ONESHOT;\n\n\terr = devm_request_threaded_irq(dev, spi->irq,\n\t\t\t\t\tads7846_hard_irq, ads7846_irq,\n\t\t\t\t\tirq_flags, dev->driver->name, ts);\n\tif (err && err != -EPROBE_DEFER && !pdata->irq_flags) {\n\t\tdev_info(dev,\n\t\t\t\"trying pin change workaround on irq %d\\n\", spi->irq);\n\t\tirq_flags |= IRQF_TRIGGER_RISING;\n\t\terr = devm_request_threaded_irq(dev, spi->irq,\n\t\t\t\t\t\tads7846_hard_irq, ads7846_irq,\n\t\t\t\t\t\tirq_flags, dev->driver->name,\n\t\t\t\t\t\tts);\n\t}\n\n\tif (err) {\n\t\tdev_dbg(dev, \"irq %d busy?\\n\", spi->irq);\n\t\treturn err;\n\t}\n\n\terr = ads784x_hwmon_register(spi, ts);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(dev, \"touchscreen, irq %d\\n\", spi->irq);\n\n\t \n\tif (ts->model == 7845)\n\t\tads7845_read12_ser(dev, PWRDOWN);\n\telse\n\t\t(void) ads7846_read12_ser(dev, READ_12BIT_SER(vaux));\n\n\terr = devm_device_add_group(dev, &ads784x_attr_group);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\tdevice_init_wakeup(dev, pdata->wakeup);\n\n\t \n\tif (!dev_get_platdata(dev))\n\t\tdevm_kfree(dev, (void *)pdata);\n\n\treturn 0;\n}\n\nstatic void ads7846_remove(struct spi_device *spi)\n{\n\tstruct ads7846 *ts = spi_get_drvdata(spi);\n\n\tads7846_stop(ts);\n}\n\nstatic struct spi_driver ads7846_driver = {\n\t.driver = {\n\t\t.name\t= \"ads7846\",\n\t\t.pm\t= pm_sleep_ptr(&ads7846_pm),\n\t\t.of_match_table = ads7846_dt_ids,\n\t},\n\t.probe\t\t= ads7846_probe,\n\t.remove\t\t= ads7846_remove,\n};\n\nmodule_spi_driver(ads7846_driver);\n\nMODULE_DESCRIPTION(\"ADS7846 TouchScreen Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:ads7846\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}