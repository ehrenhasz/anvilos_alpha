{
  "module_name": "mxs-lradc-ts.c",
  "hash_id": "ca579642f87442fabb8a45e23ad7fc8c8092f0d2c20333ba002d8ee776fd269f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mxs-lradc-ts.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/mxs-lradc.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\nstatic const char * const mxs_lradc_ts_irq_names[] = {\n\t\"mxs-lradc-touchscreen\",\n\t\"mxs-lradc-channel6\",\n\t\"mxs-lradc-channel7\",\n};\n\n \nenum mxs_lradc_ts_plate {\n\tLRADC_TOUCH = 0,\n\tLRADC_SAMPLE_X,\n\tLRADC_SAMPLE_Y,\n\tLRADC_SAMPLE_PRESSURE,\n\tLRADC_SAMPLE_VALID,\n};\n\nstruct mxs_lradc_ts {\n\tstruct mxs_lradc\t*lradc;\n\tstruct device\t\t*dev;\n\n\tvoid __iomem\t\t*base;\n\t \n#define TOUCHSCREEN_VCHANNEL1\t\t7\n#define TOUCHSCREEN_VCHANNEL2\t\t6\n\n\tstruct input_dev\t*ts_input;\n\n\tenum mxs_lradc_ts_plate\tcur_plate;  \n\tbool\t\t\tts_valid;\n\tunsigned int\t\tts_x_pos;\n\tunsigned int\t\tts_y_pos;\n\tunsigned int\t\tts_pressure;\n\n\t \n\t \n\tunsigned int\t\tover_sample_cnt;\n\t \n\tunsigned int\t\tover_sample_delay;\n\t \n\tunsigned int\t\tsettling_delay;\n\tspinlock_t\t\tlock;\n};\n\nstruct state_info {\n\tu32\t\tmask;\n\tu32\t\tbit;\n\tu32\t\tx_plate;\n\tu32\t\ty_plate;\n\tu32\t\tpressure;\n};\n\nstatic struct state_info info[] = {\n\t{LRADC_CTRL0_MX23_PLATE_MASK, LRADC_CTRL0_MX23_TOUCH_DETECT_ENABLE,\n\t LRADC_CTRL0_MX23_XP | LRADC_CTRL0_MX23_XM,\n\t LRADC_CTRL0_MX23_YP | LRADC_CTRL0_MX23_YM,\n\t LRADC_CTRL0_MX23_YP | LRADC_CTRL0_MX23_XM},\n\t{LRADC_CTRL0_MX28_PLATE_MASK, LRADC_CTRL0_MX28_TOUCH_DETECT_ENABLE,\n\t LRADC_CTRL0_MX28_XPPSW | LRADC_CTRL0_MX28_XNNSW,\n\t LRADC_CTRL0_MX28_YPPSW | LRADC_CTRL0_MX28_YNNSW,\n\t LRADC_CTRL0_MX28_YPPSW | LRADC_CTRL0_MX28_XNNSW}\n};\n\nstatic bool mxs_lradc_check_touch_event(struct mxs_lradc_ts *ts)\n{\n\treturn !!(readl(ts->base + LRADC_STATUS) &\n\t\t\t\t\tLRADC_STATUS_TOUCH_DETECT_RAW);\n}\n\nstatic void mxs_lradc_map_ts_channel(struct mxs_lradc_ts *ts, unsigned int vch,\n\t\t\t\t     unsigned int ch)\n{\n\twritel(LRADC_CTRL4_LRADCSELECT_MASK(vch),\n\t       ts->base + LRADC_CTRL4 + STMP_OFFSET_REG_CLR);\n\twritel(LRADC_CTRL4_LRADCSELECT(vch, ch),\n\t       ts->base + LRADC_CTRL4 + STMP_OFFSET_REG_SET);\n}\n\nstatic void mxs_lradc_setup_ts_channel(struct mxs_lradc_ts *ts, unsigned int ch)\n{\n\t \n\twritel(LRADC_CH_ACCUMULATE |\n\t       LRADC_CH_NUM_SAMPLES(ts->over_sample_cnt - 1),\n\t       ts->base + LRADC_CH(ch));\n\n\t \n\twritel(LRADC_CH_VALUE_MASK,\n\t       ts->base + LRADC_CH(ch) + STMP_OFFSET_REG_CLR);\n\n\t \n\twritel(LRADC_DELAY_TRIGGER(1 << ch) | LRADC_DELAY_TRIGGER_DELAYS(0) |\n\t       LRADC_DELAY_LOOP(ts->over_sample_cnt - 1) |\n\t       LRADC_DELAY_DELAY(ts->over_sample_delay - 1),\n\t       ts->base + LRADC_DELAY(3));\n\n\twritel(LRADC_CTRL1_LRADC_IRQ(ch),\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\t \n\twritel(LRADC_DELAY_TRIGGER(0) | LRADC_DELAY_TRIGGER_DELAYS(BIT(3)) |\n\t       LRADC_DELAY_KICK | LRADC_DELAY_DELAY(ts->settling_delay),\n\t       ts->base + LRADC_DELAY(2));\n}\n\n \nstatic void mxs_lradc_setup_ts_pressure(struct mxs_lradc_ts *ts,\n\t\t\t\t\tunsigned int ch1, unsigned int ch2)\n{\n\tu32 reg;\n\n\t \n\treg = LRADC_CH_ACCUMULATE |\n\t\tLRADC_CH_NUM_SAMPLES(ts->over_sample_cnt - 1);\n\twritel(reg, ts->base + LRADC_CH(ch1));\n\twritel(reg, ts->base + LRADC_CH(ch2));\n\n\t \n\twritel(LRADC_CH_VALUE_MASK,\n\t       ts->base + LRADC_CH(ch1) + STMP_OFFSET_REG_CLR);\n\twritel(LRADC_CH_VALUE_MASK,\n\t       ts->base + LRADC_CH(ch2) + STMP_OFFSET_REG_CLR);\n\n\t \n\twritel(LRADC_DELAY_TRIGGER(1 << ch1) | LRADC_DELAY_TRIGGER(1 << ch2) |\n\t       LRADC_DELAY_TRIGGER_DELAYS(0) |\n\t       LRADC_DELAY_LOOP(ts->over_sample_cnt - 1) |\n\t       LRADC_DELAY_DELAY(ts->over_sample_delay - 1),\n\t       ts->base + LRADC_DELAY(3));\n\n\twritel(LRADC_CTRL1_LRADC_IRQ(ch2),\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\t \n\twritel(LRADC_DELAY_TRIGGER(0) | LRADC_DELAY_TRIGGER_DELAYS(BIT(3)) |\n\t       LRADC_DELAY_KICK | LRADC_DELAY_DELAY(ts->settling_delay),\n\t       ts->base + LRADC_DELAY(2));\n}\n\nstatic unsigned int mxs_lradc_ts_read_raw_channel(struct mxs_lradc_ts *ts,\n\t\t\t\t\t\t  unsigned int channel)\n{\n\tu32 reg;\n\tunsigned int num_samples, val;\n\n\treg = readl(ts->base + LRADC_CH(channel));\n\tif (reg & LRADC_CH_ACCUMULATE)\n\t\tnum_samples = ts->over_sample_cnt;\n\telse\n\t\tnum_samples = 1;\n\n\tval = (reg & LRADC_CH_VALUE_MASK) >> LRADC_CH_VALUE_OFFSET;\n\treturn val / num_samples;\n}\n\nstatic unsigned int mxs_lradc_read_ts_pressure(struct mxs_lradc_ts *ts,\n\t\t\t\t\tunsigned int ch1, unsigned int ch2)\n{\n\tu32 reg, mask;\n\tunsigned int pressure, m1, m2;\n\n\tmask = LRADC_CTRL1_LRADC_IRQ(ch1) | LRADC_CTRL1_LRADC_IRQ(ch2);\n\treg = readl(ts->base + LRADC_CTRL1) & mask;\n\n\twhile (reg != mask) {\n\t\treg = readl(ts->base + LRADC_CTRL1) & mask;\n\t\tdev_dbg(ts->dev, \"One channel is still busy: %X\\n\", reg);\n\t}\n\n\tm1 = mxs_lradc_ts_read_raw_channel(ts, ch1);\n\tm2 = mxs_lradc_ts_read_raw_channel(ts, ch2);\n\n\tif (m2 == 0) {\n\t\tdev_warn(ts->dev, \"Cannot calculate pressure\\n\");\n\t\treturn 1 << (LRADC_RESOLUTION - 1);\n\t}\n\n\t \n\tpressure = m1;\n\tpressure *= (1 << LRADC_RESOLUTION);\n\tpressure /= m2;\n\n\tdev_dbg(ts->dev, \"Pressure = %u\\n\", pressure);\n\treturn pressure;\n}\n\n#define TS_CH_XP 2\n#define TS_CH_YP 3\n#define TS_CH_XM 4\n#define TS_CH_YM 5\n\n \nstatic void mxs_lradc_setup_touch_detection(struct mxs_lradc_ts *ts)\n{\n\tstruct mxs_lradc *lradc = ts->lradc;\n\n\t \n\twritel(info[lradc->soc].mask,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\twritel(info[lradc->soc].bit,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\n}\n\n \nstatic void mxs_lradc_prepare_x_pos(struct mxs_lradc_ts *ts)\n{\n\tstruct mxs_lradc *lradc = ts->lradc;\n\n\twritel(info[lradc->soc].mask,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\twritel(info[lradc->soc].x_plate,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\n\n\tts->cur_plate = LRADC_SAMPLE_X;\n\tmxs_lradc_map_ts_channel(ts, TOUCHSCREEN_VCHANNEL1, TS_CH_YP);\n\tmxs_lradc_setup_ts_channel(ts, TOUCHSCREEN_VCHANNEL1);\n}\n\n \nstatic void mxs_lradc_prepare_y_pos(struct mxs_lradc_ts *ts)\n{\n\tstruct mxs_lradc *lradc = ts->lradc;\n\n\twritel(info[lradc->soc].mask,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\twritel(info[lradc->soc].y_plate,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\n\n\tts->cur_plate = LRADC_SAMPLE_Y;\n\tmxs_lradc_map_ts_channel(ts, TOUCHSCREEN_VCHANNEL1, TS_CH_XM);\n\tmxs_lradc_setup_ts_channel(ts, TOUCHSCREEN_VCHANNEL1);\n}\n\n \nstatic void mxs_lradc_prepare_pressure(struct mxs_lradc_ts *ts)\n{\n\tstruct mxs_lradc *lradc = ts->lradc;\n\n\twritel(info[lradc->soc].mask,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\twritel(info[lradc->soc].pressure,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\n\n\tts->cur_plate = LRADC_SAMPLE_PRESSURE;\n\tmxs_lradc_map_ts_channel(ts, TOUCHSCREEN_VCHANNEL1, TS_CH_YM);\n\tmxs_lradc_map_ts_channel(ts, TOUCHSCREEN_VCHANNEL2, TS_CH_XP);\n\tmxs_lradc_setup_ts_pressure(ts, TOUCHSCREEN_VCHANNEL2,\n\t\t\t\t    TOUCHSCREEN_VCHANNEL1);\n}\n\nstatic void mxs_lradc_enable_touch_detection(struct mxs_lradc_ts *ts)\n{\n\tmxs_lradc_setup_touch_detection(ts);\n\n\tts->cur_plate = LRADC_TOUCH;\n\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ | LRADC_CTRL1_TOUCH_DETECT_IRQ_EN,\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ_EN,\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\n}\n\nstatic void mxs_lradc_start_touch_event(struct mxs_lradc_ts *ts)\n{\n\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ_EN,\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\twritel(LRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL1),\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\n\t \n\tmxs_lradc_prepare_y_pos(ts);\n}\n\nstatic void mxs_lradc_report_ts_event(struct mxs_lradc_ts *ts)\n{\n\tinput_report_abs(ts->ts_input, ABS_X, ts->ts_x_pos);\n\tinput_report_abs(ts->ts_input, ABS_Y, ts->ts_y_pos);\n\tinput_report_abs(ts->ts_input, ABS_PRESSURE, ts->ts_pressure);\n\tinput_report_key(ts->ts_input, BTN_TOUCH, 1);\n\tinput_sync(ts->ts_input);\n}\n\nstatic void mxs_lradc_complete_touch_event(struct mxs_lradc_ts *ts)\n{\n\tmxs_lradc_setup_touch_detection(ts);\n\tts->cur_plate = LRADC_SAMPLE_VALID;\n\t \n\twritel(0, ts->base + LRADC_CH(TOUCHSCREEN_VCHANNEL1));\n\twritel(LRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1) |\n\t       LRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL2),\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\twritel(LRADC_DELAY_TRIGGER(1 << TOUCHSCREEN_VCHANNEL1) |\n\t       LRADC_DELAY_KICK | LRADC_DELAY_DELAY(10),\n\t       ts->base + LRADC_DELAY(2));\n}\n\n \nstatic void mxs_lradc_finish_touch_event(struct mxs_lradc_ts *ts, bool valid)\n{\n\t \n\tif (valid && mxs_lradc_check_touch_event(ts)) {\n\t\tts->ts_valid = true;\n\t\tmxs_lradc_report_ts_event(ts);\n\t}\n\n\t \n\tif (mxs_lradc_check_touch_event(ts)) {\n\t\tmxs_lradc_prepare_y_pos(ts);\n\t\treturn;\n\t}\n\n\tif (ts->ts_valid) {\n\t\t \n\t\tts->ts_valid = false;\n\t\tinput_report_key(ts->ts_input, BTN_TOUCH, 0);\n\t\tinput_sync(ts->ts_input);\n\t}\n\n\t \n\tts->cur_plate = LRADC_TOUCH;\n\twritel(0, ts->base + LRADC_DELAY(2));\n\twritel(0, ts->base + LRADC_DELAY(3));\n\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ |\n\t       LRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL1) |\n\t       LRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1),\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ_EN,\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);\n}\n\n \nstatic void mxs_lradc_handle_touch(struct mxs_lradc_ts *ts)\n{\n\tswitch (ts->cur_plate) {\n\tcase LRADC_TOUCH:\n\t\tif (mxs_lradc_check_touch_event(ts))\n\t\t\tmxs_lradc_start_touch_event(ts);\n\t\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ,\n\t\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\t\treturn;\n\n\tcase LRADC_SAMPLE_Y:\n\t\tts->ts_y_pos =\n\t\t    mxs_lradc_ts_read_raw_channel(ts, TOUCHSCREEN_VCHANNEL1);\n\t\tmxs_lradc_prepare_x_pos(ts);\n\t\treturn;\n\n\tcase LRADC_SAMPLE_X:\n\t\tts->ts_x_pos =\n\t\t    mxs_lradc_ts_read_raw_channel(ts, TOUCHSCREEN_VCHANNEL1);\n\t\tmxs_lradc_prepare_pressure(ts);\n\t\treturn;\n\n\tcase LRADC_SAMPLE_PRESSURE:\n\t\tts->ts_pressure =\n\t\t    mxs_lradc_read_ts_pressure(ts,\n\t\t\t\t\t       TOUCHSCREEN_VCHANNEL2,\n\t\t\t\t\t       TOUCHSCREEN_VCHANNEL1);\n\t\tmxs_lradc_complete_touch_event(ts);\n\t\treturn;\n\n\tcase LRADC_SAMPLE_VALID:\n\t\tmxs_lradc_finish_touch_event(ts, 1);\n\t\tbreak;\n\t}\n}\n\n \nstatic irqreturn_t mxs_lradc_ts_handle_irq(int irq, void *data)\n{\n\tstruct mxs_lradc_ts *ts = data;\n\tstruct mxs_lradc *lradc = ts->lradc;\n\tunsigned long reg = readl(ts->base + LRADC_CTRL1);\n\tu32 clr_irq = mxs_lradc_irq_mask(lradc);\n\tconst u32 ts_irq_mask =\n\t\tLRADC_CTRL1_TOUCH_DETECT_IRQ |\n\t\tLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1) |\n\t\tLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL2);\n\tunsigned long flags;\n\n\tif (!(reg & mxs_lradc_irq_mask(lradc)))\n\t\treturn IRQ_NONE;\n\n\tif (reg & ts_irq_mask) {\n\t\tspin_lock_irqsave(&ts->lock, flags);\n\t\tmxs_lradc_handle_touch(ts);\n\t\tspin_unlock_irqrestore(&ts->lock, flags);\n\t\t \n\t\tclr_irq &= ~(LRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1) |\n\t\t\t\tLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL2));\n\t\twritel(reg & clr_irq,\n\t\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxs_lradc_ts_open(struct input_dev *dev)\n{\n\tstruct mxs_lradc_ts *ts = input_get_drvdata(dev);\n\n\t \n\tmxs_lradc_enable_touch_detection(ts);\n\n\treturn 0;\n}\n\nstatic void mxs_lradc_ts_stop(struct mxs_lradc_ts *ts)\n{\n\tint i;\n\tstruct mxs_lradc *lradc = ts->lradc;\n\n\t \n\twritel(LRADC_CTRL1_TOUCH_DETECT_IRQ_EN |\n\t       LRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL1) |\n\t       LRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL2),\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\t \n\twritel(info[lradc->soc].mask,\n\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\n\twritel(lradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\n\t       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);\n\n\tfor (i = 1; i < LRADC_MAX_DELAY_CHANS; i++)\n\t\twritel(0, ts->base + LRADC_DELAY(i));\n}\n\nstatic void mxs_lradc_ts_close(struct input_dev *dev)\n{\n\tstruct mxs_lradc_ts *ts = input_get_drvdata(dev);\n\n\tmxs_lradc_ts_stop(ts);\n}\n\nstatic void mxs_lradc_ts_hw_init(struct mxs_lradc_ts *ts)\n{\n\tstruct mxs_lradc *lradc = ts->lradc;\n\n\t \n\tif (lradc->soc == IMX28_LRADC) {\n\t\twritel(LRADC_CTRL0_MX28_TOUCH_SCREEN_TYPE,\n\t\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);\n\n\t\tif (lradc->touchscreen_wire == MXS_LRADC_TOUCHSCREEN_5WIRE)\n\t\t\twritel(LRADC_CTRL0_MX28_TOUCH_SCREEN_TYPE,\n\t\t\t       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);\n\t}\n}\n\nstatic int mxs_lradc_ts_register(struct mxs_lradc_ts *ts)\n{\n\tstruct input_dev *input;\n\tstruct device *dev = ts->dev;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"mxs-lradc-ts\";\n\tinput->id.bustype = BUS_HOST;\n\tinput->open = mxs_lradc_ts_open;\n\tinput->close = mxs_lradc_ts_close;\n\n\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input, ABS_X, 0, LRADC_SINGLE_SAMPLE_MASK, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, LRADC_SINGLE_SAMPLE_MASK, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, LRADC_SINGLE_SAMPLE_MASK,\n\t\t\t     0, 0);\n\n\tts->ts_input = input;\n\tinput_set_drvdata(input, ts);\n\n\treturn input_register_device(input);\n}\n\nstatic int mxs_lradc_ts_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->parent->of_node;\n\tstruct mxs_lradc *lradc = dev_get_drvdata(dev->parent);\n\tstruct mxs_lradc_ts *ts;\n\tint ret, irq, virq, i;\n\tu32 ts_wires = 0, adapt;\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ts);\n\n\tts->lradc = lradc;\n\tts->dev = dev;\n\tspin_lock_init(&ts->lock);\n\n\tts->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ts->base))\n\t\treturn PTR_ERR(ts->base);\n\n\tret = of_property_read_u32(node, \"fsl,lradc-touchscreen-wires\",\n\t\t\t\t   &ts_wires);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_u32(node, \"fsl,ave-ctrl\", &adapt)) {\n\t\tts->over_sample_cnt = 4;\n\t} else {\n\t\tif (adapt >= 1 && adapt <= 32) {\n\t\t\tts->over_sample_cnt = adapt;\n\t\t} else {\n\t\t\tdev_err(ts->dev, \"Invalid sample count (%u)\\n\",\n\t\t\t\tadapt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (of_property_read_u32(node, \"fsl,ave-delay\", &adapt)) {\n\t\tts->over_sample_delay = 2;\n\t} else {\n\t\tif (adapt >= 2 && adapt <= LRADC_DELAY_DELAY_MASK + 1) {\n\t\t\tts->over_sample_delay = adapt;\n\t\t} else {\n\t\t\tdev_err(ts->dev, \"Invalid sample delay (%u)\\n\",\n\t\t\t\tadapt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (of_property_read_u32(node, \"fsl,settling\", &adapt)) {\n\t\tts->settling_delay = 10;\n\t} else {\n\t\tif (adapt >= 1 && adapt <= LRADC_DELAY_DELAY_MASK) {\n\t\t\tts->settling_delay = adapt;\n\t\t} else {\n\t\t\tdev_err(ts->dev, \"Invalid settling delay (%u)\\n\",\n\t\t\t\tadapt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = stmp_reset_block(ts->base);\n\tif (ret)\n\t\treturn ret;\n\n\tmxs_lradc_ts_hw_init(ts);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tirq = platform_get_irq_byname(pdev, mxs_lradc_ts_irq_names[i]);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tvirq = irq_of_parse_and_map(node, irq);\n\n\t\tmxs_lradc_ts_stop(ts);\n\n\t\tret = devm_request_irq(dev, virq,\n\t\t\t\t       mxs_lradc_ts_handle_irq,\n\t\t\t\t       0, mxs_lradc_ts_irq_names[i], ts);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn mxs_lradc_ts_register(ts);\n}\n\nstatic struct platform_driver mxs_lradc_ts_driver = {\n\t.driver\t= {\n\t\t.name = \"mxs-lradc-ts\",\n\t},\n\t.probe\t= mxs_lradc_ts_probe,\n};\nmodule_platform_driver(mxs_lradc_ts_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Freescale MXS LRADC touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mxs-lradc-ts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}