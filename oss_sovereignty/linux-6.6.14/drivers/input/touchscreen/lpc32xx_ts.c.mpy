{
  "module_name": "lpc32xx_ts.c",
  "hash_id": "71eaafacad63686b63dcd163190c5797bc9fde15352392b706aad6e9d2f2a291",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/lpc32xx_ts.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n \n#define LPC32XX_TSC_STAT\t\t\t0x00\n#define LPC32XX_TSC_SEL\t\t\t\t0x04\n#define LPC32XX_TSC_CON\t\t\t\t0x08\n#define LPC32XX_TSC_FIFO\t\t\t0x0C\n#define LPC32XX_TSC_DTR\t\t\t\t0x10\n#define LPC32XX_TSC_RTR\t\t\t\t0x14\n#define LPC32XX_TSC_UTR\t\t\t\t0x18\n#define LPC32XX_TSC_TTR\t\t\t\t0x1C\n#define LPC32XX_TSC_DXP\t\t\t\t0x20\n#define LPC32XX_TSC_MIN_X\t\t\t0x24\n#define LPC32XX_TSC_MAX_X\t\t\t0x28\n#define LPC32XX_TSC_MIN_Y\t\t\t0x2C\n#define LPC32XX_TSC_MAX_Y\t\t\t0x30\n#define LPC32XX_TSC_AUX_UTR\t\t\t0x34\n#define LPC32XX_TSC_AUX_MIN\t\t\t0x38\n#define LPC32XX_TSC_AUX_MAX\t\t\t0x3C\n\n#define LPC32XX_TSC_STAT_FIFO_OVRRN\t\tBIT(8)\n#define LPC32XX_TSC_STAT_FIFO_EMPTY\t\tBIT(7)\n\n#define LPC32XX_TSC_SEL_DEFVAL\t\t\t0x0284\n\n#define LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4\t(0x1 << 11)\n#define LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(s)\t((10 - (s)) << 7)\n#define LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(s)\t((10 - (s)) << 4)\n#define LPC32XX_TSC_ADCCON_POWER_UP\t\tBIT(2)\n#define LPC32XX_TSC_ADCCON_AUTO_EN\t\tBIT(0)\n\n#define LPC32XX_TSC_FIFO_TS_P_LEVEL\t\tBIT(31)\n#define LPC32XX_TSC_FIFO_NORMALIZE_X_VAL(x)\t(((x) & 0x03FF0000) >> 16)\n#define LPC32XX_TSC_FIFO_NORMALIZE_Y_VAL(y)\t((y) & 0x000003FF)\n\n#define LPC32XX_TSC_ADCDAT_VALUE_MASK\t\t0x000003FF\n\n#define LPC32XX_TSC_MIN_XY_VAL\t\t\t0x0\n#define LPC32XX_TSC_MAX_XY_VAL\t\t\t0x3FF\n\n#define MOD_NAME \"ts-lpc32xx\"\n\n#define tsc_readl(dev, reg) \\\n\t__raw_readl((dev)->tsc_base + (reg))\n#define tsc_writel(dev, reg, val) \\\n\t__raw_writel((val), (dev)->tsc_base + (reg))\n\nstruct lpc32xx_tsc {\n\tstruct input_dev *dev;\n\tvoid __iomem *tsc_base;\n\tint irq;\n\tstruct clk *clk;\n};\n\nstatic void lpc32xx_fifo_clear(struct lpc32xx_tsc *tsc)\n{\n\twhile (!(tsc_readl(tsc, LPC32XX_TSC_STAT) &\n\t\t\tLPC32XX_TSC_STAT_FIFO_EMPTY))\n\t\ttsc_readl(tsc, LPC32XX_TSC_FIFO);\n}\n\nstatic irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)\n{\n\tu32 tmp, rv[4], xs[4], ys[4];\n\tint idx;\n\tstruct lpc32xx_tsc *tsc = dev_id;\n\tstruct input_dev *input = tsc->dev;\n\n\ttmp = tsc_readl(tsc, LPC32XX_TSC_STAT);\n\n\tif (tmp & LPC32XX_TSC_STAT_FIFO_OVRRN) {\n\t\t \n\t\tlpc32xx_fifo_clear(tsc);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tidx = 0;\n\twhile (idx < 4 &&\n\t       !(tsc_readl(tsc, LPC32XX_TSC_STAT) &\n\t\t\tLPC32XX_TSC_STAT_FIFO_EMPTY)) {\n\t\ttmp = tsc_readl(tsc, LPC32XX_TSC_FIFO);\n\t\txs[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -\n\t\t\tLPC32XX_TSC_FIFO_NORMALIZE_X_VAL(tmp);\n\t\tys[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -\n\t\t\tLPC32XX_TSC_FIFO_NORMALIZE_Y_VAL(tmp);\n\t\trv[idx] = tmp;\n\t\tidx++;\n\t}\n\n\t \n\tif (!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL) && idx == 4) {\n\t\t \n\t\tinput_report_abs(input, ABS_X, (xs[1] + xs[2]) / 2);\n\t\tinput_report_abs(input, ABS_Y, (ys[1] + ys[2]) / 2);\n\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t} else {\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t}\n\n\tinput_sync(input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void lpc32xx_stop_tsc(struct lpc32xx_tsc *tsc)\n{\n\t \n\ttsc_writel(tsc, LPC32XX_TSC_CON,\n\t\t   tsc_readl(tsc, LPC32XX_TSC_CON) &\n\t\t\t     ~LPC32XX_TSC_ADCCON_AUTO_EN);\n\n\tclk_disable_unprepare(tsc->clk);\n}\n\nstatic int lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)\n{\n\tu32 tmp;\n\tint err;\n\n\terr = clk_prepare_enable(tsc->clk);\n\tif (err)\n\t\treturn err;\n\n\ttmp = tsc_readl(tsc, LPC32XX_TSC_CON) & ~LPC32XX_TSC_ADCCON_POWER_UP;\n\n\t \n\ttmp = LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4 |\n\t      LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(10) |\n\t      LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(10);\n\ttsc_writel(tsc, LPC32XX_TSC_CON, tmp);\n\n\t \n\ttsc_writel(tsc, LPC32XX_TSC_SEL, LPC32XX_TSC_SEL_DEFVAL);\n\ttsc_writel(tsc, LPC32XX_TSC_MIN_X, LPC32XX_TSC_MIN_XY_VAL);\n\ttsc_writel(tsc, LPC32XX_TSC_MAX_X, LPC32XX_TSC_MAX_XY_VAL);\n\ttsc_writel(tsc, LPC32XX_TSC_MIN_Y, LPC32XX_TSC_MIN_XY_VAL);\n\ttsc_writel(tsc, LPC32XX_TSC_MAX_Y, LPC32XX_TSC_MAX_XY_VAL);\n\n\t \n\ttsc_writel(tsc, LPC32XX_TSC_AUX_UTR, 0);\n\ttsc_writel(tsc, LPC32XX_TSC_AUX_MIN, 0);\n\ttsc_writel(tsc, LPC32XX_TSC_AUX_MAX, 0);\n\n\t \n\ttsc_writel(tsc, LPC32XX_TSC_RTR, 0x2);\n\ttsc_writel(tsc, LPC32XX_TSC_DTR, 0x2);\n\ttsc_writel(tsc, LPC32XX_TSC_TTR, 0x10);\n\ttsc_writel(tsc, LPC32XX_TSC_DXP, 0x4);\n\ttsc_writel(tsc, LPC32XX_TSC_UTR, 88);\n\n\tlpc32xx_fifo_clear(tsc);\n\n\t \n\ttsc_writel(tsc, LPC32XX_TSC_CON, tmp | LPC32XX_TSC_ADCCON_AUTO_EN);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_ts_open(struct input_dev *dev)\n{\n\tstruct lpc32xx_tsc *tsc = input_get_drvdata(dev);\n\n\treturn lpc32xx_setup_tsc(tsc);\n}\n\nstatic void lpc32xx_ts_close(struct input_dev *dev)\n{\n\tstruct lpc32xx_tsc *tsc = input_get_drvdata(dev);\n\n\tlpc32xx_stop_tsc(tsc);\n}\n\nstatic int lpc32xx_ts_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lpc32xx_tsc *tsc;\n\tstruct input_dev *input;\n\tint irq;\n\tint error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\ttsc = devm_kzalloc(dev, sizeof(*tsc), GFP_KERNEL);\n\tif (!tsc)\n\t\treturn -ENOMEM;\n\n\ttsc->irq = irq;\n\n\ttsc->tsc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tsc->tsc_base))\n\t\treturn PTR_ERR(tsc->tsc_base);\n\n\ttsc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(tsc->clk)) {\n\t\tdev_err(&pdev->dev, \"failed getting clock\\n\");\n\t\treturn PTR_ERR(tsc->clk);\n\t}\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(&pdev->dev, \"failed allocating input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = MOD_NAME;\n\tinput->phys = \"lpc32xx/input0\";\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.vendor = 0x0001;\n\tinput->id.product = 0x0002;\n\tinput->id.version = 0x0100;\n\tinput->open = lpc32xx_ts_open;\n\tinput->close = lpc32xx_ts_close;\n\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input, ABS_X, LPC32XX_TSC_MIN_XY_VAL,\n\t\t\t     LPC32XX_TSC_MAX_XY_VAL, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, LPC32XX_TSC_MIN_XY_VAL,\n\t\t\t     LPC32XX_TSC_MAX_XY_VAL, 0, 0);\n\n\tinput_set_drvdata(input, tsc);\n\ttsc->dev = input;\n\n\terror = devm_request_irq(dev, tsc->irq, lpc32xx_ts_interrupt,\n\t\t\t\t 0, pdev->name, tsc);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed requesting interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"failed registering input device\\n\");\n\t\treturn error;\n\t}\n\n\tplatform_set_drvdata(pdev, tsc);\n\tdevice_init_wakeup(&pdev->dev, true);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int lpc32xx_ts_suspend(struct device *dev)\n{\n\tstruct lpc32xx_tsc *tsc = dev_get_drvdata(dev);\n\tstruct input_dev *input = tsc->dev;\n\n\t \n\tmutex_lock(&input->mutex);\n\n\tif (input_device_enabled(input)) {\n\t\tif (device_may_wakeup(dev))\n\t\t\tenable_irq_wake(tsc->irq);\n\t\telse\n\t\t\tlpc32xx_stop_tsc(tsc);\n\t}\n\n\tmutex_unlock(&input->mutex);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_ts_resume(struct device *dev)\n{\n\tstruct lpc32xx_tsc *tsc = dev_get_drvdata(dev);\n\tstruct input_dev *input = tsc->dev;\n\n\tmutex_lock(&input->mutex);\n\n\tif (input_device_enabled(input)) {\n\t\tif (device_may_wakeup(dev))\n\t\t\tdisable_irq_wake(tsc->irq);\n\t\telse\n\t\t\tlpc32xx_setup_tsc(tsc);\n\t}\n\n\tmutex_unlock(&input->mutex);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lpc32xx_ts_pm_ops = {\n\t.suspend\t= lpc32xx_ts_suspend,\n\t.resume\t\t= lpc32xx_ts_resume,\n};\n#define LPC32XX_TS_PM_OPS (&lpc32xx_ts_pm_ops)\n#else\n#define LPC32XX_TS_PM_OPS NULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lpc32xx_tsc_of_match[] = {\n\t{ .compatible = \"nxp,lpc3220-tsc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_tsc_of_match);\n#endif\n\nstatic struct platform_driver lpc32xx_ts_driver = {\n\t.probe\t\t= lpc32xx_ts_probe,\n\t.driver\t\t= {\n\t\t.name\t= MOD_NAME,\n\t\t.pm\t= LPC32XX_TS_PM_OPS,\n\t\t.of_match_table = of_match_ptr(lpc32xx_tsc_of_match),\n\t},\n};\nmodule_platform_driver(lpc32xx_ts_driver);\n\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com\");\nMODULE_DESCRIPTION(\"LPC32XX TSC Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lpc32xx_ts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}