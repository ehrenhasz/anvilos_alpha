{
  "module_name": "tsc2007_iio.c",
  "hash_id": "096003767491e3117d8e0fc0b76e7399e0035f061edc0e10aa7c73a07801120a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/tsc2007_iio.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/iio/iio.h>\n#include \"tsc2007.h\"\n\nstruct tsc2007_iio {\n\tstruct tsc2007 *ts;\n};\n\n#define TSC2007_CHAN_IIO(_chan, _name, _type, _chan_info) \\\n{ \\\n\t.datasheet_name = _name, \\\n\t.type = _type, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\t\\\n\t\t\tBIT(_chan_info), \\\n\t.indexed = 1, \\\n\t.channel = _chan, \\\n}\n\nstatic const struct iio_chan_spec tsc2007_iio_channel[] = {\n\tTSC2007_CHAN_IIO(0, \"x\", IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(1, \"y\", IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(2, \"z1\", IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(3, \"z2\", IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(4, \"adc\", IIO_VOLTAGE, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(5, \"rt\", IIO_VOLTAGE, IIO_CHAN_INFO_RAW),  \n\tTSC2007_CHAN_IIO(6, \"pen\", IIO_PRESSURE, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(7, \"temp0\", IIO_TEMP, IIO_CHAN_INFO_RAW),\n\tTSC2007_CHAN_IIO(8, \"temp1\", IIO_TEMP, IIO_CHAN_INFO_RAW),\n};\n\nstatic int tsc2007_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *chan,\n\t\t\t    int *val, int *val2, long mask)\n{\n\tstruct tsc2007_iio *iio = iio_priv(indio_dev);\n\tstruct tsc2007 *tsc = iio->ts;\n\tint adc_chan = chan->channel;\n\tint ret = 0;\n\n\tif (adc_chan >= ARRAY_SIZE(tsc2007_iio_channel))\n\t\treturn -EINVAL;\n\n\tif (mask != IIO_CHAN_INFO_RAW)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tsc->mlock);\n\n\tswitch (chan->channel) {\n\tcase 0:\n\t\t*val = tsc2007_xfer(tsc, READ_X);\n\t\tbreak;\n\tcase 1:\n\t\t*val = tsc2007_xfer(tsc, READ_Y);\n\t\tbreak;\n\tcase 2:\n\t\t*val = tsc2007_xfer(tsc, READ_Z1);\n\t\tbreak;\n\tcase 3:\n\t\t*val = tsc2007_xfer(tsc, READ_Z2);\n\t\tbreak;\n\tcase 4:\n\t\t*val = tsc2007_xfer(tsc, (ADC_ON_12BIT | TSC2007_MEASURE_AUX));\n\t\tbreak;\n\tcase 5: {\n\t\tstruct ts_event tc;\n\n\t\ttc.x = tsc2007_xfer(tsc, READ_X);\n\t\ttc.z1 = tsc2007_xfer(tsc, READ_Z1);\n\t\ttc.z2 = tsc2007_xfer(tsc, READ_Z2);\n\t\t*val = tsc2007_calculate_resistance(tsc, &tc);\n\t\tbreak;\n\t}\n\tcase 6:\n\t\t*val = tsc2007_is_pen_down(tsc);\n\t\tbreak;\n\tcase 7:\n\t\t*val = tsc2007_xfer(tsc,\n\t\t\t\t    (ADC_ON_12BIT | TSC2007_MEASURE_TEMP0));\n\t\tbreak;\n\tcase 8:\n\t\t*val = tsc2007_xfer(tsc,\n\t\t\t\t    (ADC_ON_12BIT | TSC2007_MEASURE_TEMP1));\n\t\tbreak;\n\t}\n\n\t \n\ttsc2007_xfer(tsc, PWRDOWN);\n\n\tmutex_unlock(&tsc->mlock);\n\n\tret = IIO_VAL_INT;\n\n\treturn ret;\n}\n\nstatic const struct iio_info tsc2007_iio_info = {\n\t.read_raw = tsc2007_read_raw,\n};\n\nint tsc2007_iio_configure(struct tsc2007 *ts)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct tsc2007_iio *iio;\n\tint error;\n\n\tindio_dev = devm_iio_device_alloc(&ts->client->dev, sizeof(*iio));\n\tif (!indio_dev) {\n\t\tdev_err(&ts->client->dev, \"iio_device_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tiio = iio_priv(indio_dev);\n\tiio->ts = ts;\n\n\tindio_dev->name = \"tsc2007\";\n\tindio_dev->info = &tsc2007_iio_info;\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->channels = tsc2007_iio_channel;\n\tindio_dev->num_channels = ARRAY_SIZE(tsc2007_iio_channel);\n\n\terror = devm_iio_device_register(&ts->client->dev, indio_dev);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"iio_device_register() failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}