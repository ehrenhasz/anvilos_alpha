{
  "module_name": "edt-ft5x06.c",
  "hash_id": "5be84bcc026e5a6a37cbdf78469b92ee7d76aca5b5d30521bd3824c1cbf825f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/edt-ft5x06.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/ratelimit.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <asm/unaligned.h>\n\n#define WORK_REGISTER_THRESHOLD\t\t0x00\n#define WORK_REGISTER_REPORT_RATE\t0x08\n#define WORK_REGISTER_GAIN\t\t0x30\n#define WORK_REGISTER_OFFSET\t\t0x31\n#define WORK_REGISTER_NUM_X\t\t0x33\n#define WORK_REGISTER_NUM_Y\t\t0x34\n\n#define PMOD_REGISTER_ACTIVE\t\t0x00\n#define PMOD_REGISTER_HIBERNATE\t\t0x03\n\n#define M09_REGISTER_THRESHOLD\t\t0x80\n#define M09_REGISTER_GAIN\t\t0x92\n#define M09_REGISTER_OFFSET\t\t0x93\n#define M09_REGISTER_NUM_X\t\t0x94\n#define M09_REGISTER_NUM_Y\t\t0x95\n\n#define M12_REGISTER_REPORT_RATE\t0x88\n\n#define EV_REGISTER_THRESHOLD\t\t0x40\n#define EV_REGISTER_GAIN\t\t0x41\n#define EV_REGISTER_OFFSET_Y\t\t0x45\n#define EV_REGISTER_OFFSET_X\t\t0x46\n\n#define NO_REGISTER\t\t\t0xff\n\n#define WORK_REGISTER_OPMODE\t\t0x3c\n#define FACTORY_REGISTER_OPMODE\t\t0x01\n#define PMOD_REGISTER_OPMODE\t\t0xa5\n\n#define TOUCH_EVENT_DOWN\t\t0x00\n#define TOUCH_EVENT_UP\t\t\t0x01\n#define TOUCH_EVENT_ON\t\t\t0x02\n#define TOUCH_EVENT_RESERVED\t\t0x03\n\n#define EDT_NAME_LEN\t\t\t23\n#define EDT_SWITCH_MODE_RETRIES\t\t10\n#define EDT_SWITCH_MODE_DELAY\t\t5  \n#define EDT_RAW_DATA_RETRIES\t\t100\n#define EDT_RAW_DATA_DELAY\t\t1000  \n\n#define EDT_DEFAULT_NUM_X\t\t1024\n#define EDT_DEFAULT_NUM_Y\t\t1024\n\n#define M06_REG_CMD(factory) ((factory) ? 0xf3 : 0xfc)\n#define M06_REG_ADDR(factory, addr) ((factory) ? (addr) & 0x7f : (addr) & 0x3f)\n\nenum edt_pmode {\n\tEDT_PMODE_NOT_SUPPORTED,\n\tEDT_PMODE_HIBERNATE,\n\tEDT_PMODE_POWEROFF,\n};\n\nenum edt_ver {\n\tEDT_M06,\n\tEDT_M09,\n\tEDT_M12,\n\tEV_FT,\n\tGENERIC_FT,\n};\n\nstruct edt_reg_addr {\n\tint reg_threshold;\n\tint reg_report_rate;\n\tint reg_gain;\n\tint reg_offset;\n\tint reg_offset_x;\n\tint reg_offset_y;\n\tint reg_num_x;\n\tint reg_num_y;\n};\n\nstruct edt_ft5x06_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct touchscreen_properties prop;\n\tu16 num_x;\n\tu16 num_y;\n\tstruct regulator *vcc;\n\tstruct regulator *iovcc;\n\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *wake_gpio;\n\n\tstruct regmap *regmap;\n\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *debug_dir;\n\tu8 *raw_buffer;\n\tsize_t raw_bufsize;\n#endif\n\n\tstruct mutex mutex;\n\tbool factory_mode;\n\tenum edt_pmode suspend_mode;\n\tint threshold;\n\tint gain;\n\tint offset;\n\tint offset_x;\n\tint offset_y;\n\tint report_rate;\n\tint max_support_points;\n\tint point_len;\n\tu8 tdata_cmd;\n\tint tdata_len;\n\tint tdata_offset;\n\n\tchar name[EDT_NAME_LEN];\n\tchar fw_version[EDT_NAME_LEN];\n\n\tstruct edt_reg_addr reg_addr;\n\tenum edt_ver version;\n\tunsigned int crc_errors;\n\tunsigned int header_errors;\n};\n\nstruct edt_i2c_chip_data {\n\tint  max_support_points;\n};\n\nstatic const struct regmap_config edt_ft5x06_i2c_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic bool edt_ft5x06_ts_check_crc(struct edt_ft5x06_ts_data *tsdata,\n\t\t\t\t    u8 *buf, int buflen)\n{\n\tint i;\n\tu8 crc = 0;\n\n\tfor (i = 0; i < buflen - 1; i++)\n\t\tcrc ^= buf[i];\n\n\tif (crc != buf[buflen - 1]) {\n\t\ttsdata->crc_errors++;\n\t\tdev_err_ratelimited(&tsdata->client->dev,\n\t\t\t\t    \"crc error: 0x%02x expected, got 0x%02x\\n\",\n\t\t\t\t    crc, buf[buflen - 1]);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int edt_M06_i2c_read(void *context, const void *reg_buf, size_t reg_size,\n\t\t\t    void *val_buf, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(i2c);\n\tstruct i2c_msg xfer[2];\n\tbool reg_read = false;\n\tu8 addr;\n\tu8 wlen;\n\tu8 wbuf[4], rbuf[3];\n\tint ret;\n\n\taddr = *((u8 *)reg_buf);\n\twbuf[0] = addr;\n\tswitch (addr) {\n\tcase 0xf5:\n\t\twlen = 3;\n\t\twbuf[0] = 0xf5;\n\t\twbuf[1] = 0xe;\n\t\twbuf[2] = *((u8 *)val_buf);\n\t\tbreak;\n\tcase 0xf9:\n\t\twlen = 1;\n\t\tbreak;\n\tdefault:\n\t\twlen = 2;\n\t\treg_read = true;\n\t\twbuf[0] = M06_REG_CMD(tsdata->factory_mode);\n\t\twbuf[1] = M06_REG_ADDR(tsdata->factory_mode, addr);\n\t\twbuf[1] |= tsdata->factory_mode ? 0x80 : 0x40;\n\t}\n\n\txfer[0].addr  = i2c->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = wlen;\n\txfer[0].buf = wbuf;\n\n\txfer[1].addr = i2c->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = reg_read ? 2 : val_size;\n\txfer[1].buf = reg_read ? rbuf : val_buf;\n\n\tret = i2c_transfer(i2c->adapter, xfer, 2);\n\tif (ret != 2) {\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn -EIO;\n\t}\n\n\tif (addr == 0xf9) {\n\t\tu8 *buf = (u8 *)val_buf;\n\n\t\tif (buf[0] != 0xaa || buf[1] != 0xaa ||\n\t\t    buf[2] != val_size) {\n\t\t\ttsdata->header_errors++;\n\t\t\tdev_err_ratelimited(dev,\n\t\t\t\t\t    \"Unexpected header: %02x%02x%02x\\n\",\n\t\t\t\t\t    buf[0], buf[1], buf[2]);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (!edt_ft5x06_ts_check_crc(tsdata, val_buf, val_size))\n\t\t\treturn -EIO;\n\t} else if (reg_read) {\n\t\twbuf[2] = rbuf[0];\n\t\twbuf[3] = rbuf[1];\n\t\tif (!edt_ft5x06_ts_check_crc(tsdata, wbuf, 4))\n\t\t\treturn -EIO;\n\n\t\t*((u8 *)val_buf) = rbuf[0];\n\t}\n\n\treturn 0;\n}\n\nstatic int edt_M06_i2c_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(i2c);\n\tu8 addr, val;\n\tu8 wbuf[4];\n\tstruct i2c_msg xfer;\n\tint ret;\n\n\taddr = *((u8 *)data);\n\tval = *((u8 *)data + 1);\n\n\twbuf[0] = M06_REG_CMD(tsdata->factory_mode);\n\twbuf[1] = M06_REG_ADDR(tsdata->factory_mode, addr);\n\twbuf[2] = val;\n\twbuf[3] = wbuf[0] ^ wbuf[1] ^ wbuf[2];\n\n\txfer.addr  = i2c->addr;\n\txfer.flags = 0;\n\txfer.len = 4;\n\txfer.buf = wbuf;\n\n\tret = i2c_transfer(i2c->adapter, &xfer, 1);\n\tif (ret != 1) {\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config edt_M06_i2c_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.read = edt_M06_i2c_read,\n\t.write = edt_M06_i2c_write,\n};\n\nstatic irqreturn_t edt_ft5x06_ts_isr(int irq, void *dev_id)\n{\n\tstruct edt_ft5x06_ts_data *tsdata = dev_id;\n\tstruct device *dev = &tsdata->client->dev;\n\tu8 rdbuf[63];\n\tint i, type, x, y, id;\n\tint error;\n\n\tmemset(rdbuf, 0, sizeof(rdbuf));\n\terror = regmap_bulk_read(tsdata->regmap, tsdata->tdata_cmd, rdbuf,\n\t\t\t\t tsdata->tdata_len);\n\tif (error) {\n\t\tdev_err_ratelimited(dev, \"Unable to fetch data, error: %d\\n\",\n\t\t\t\t    error);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < tsdata->max_support_points; i++) {\n\t\tu8 *buf = &rdbuf[i * tsdata->point_len + tsdata->tdata_offset];\n\n\t\ttype = buf[0] >> 6;\n\t\t \n\t\tif (type == TOUCH_EVENT_RESERVED)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tsdata->version == EDT_M06 && type == TOUCH_EVENT_DOWN)\n\t\t\tcontinue;\n\n\t\tx = get_unaligned_be16(buf) & 0x0fff;\n\t\ty = get_unaligned_be16(buf + 2) & 0x0fff;\n\t\t \n\t\tif (tsdata->version == EV_FT)\n\t\t\tswap(x, y);\n\n\t\tid = (buf[2] >> 4) & 0x0f;\n\n\t\tinput_mt_slot(tsdata->input, id);\n\t\tif (input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER,\n\t\t\t\t\t       type != TOUCH_EVENT_UP))\n\t\t\ttouchscreen_report_pos(tsdata->input, &tsdata->prop,\n\t\t\t\t\t       x, y, true);\n\t}\n\n\tinput_mt_report_pointer_emulation(tsdata->input, true);\n\tinput_sync(tsdata->input);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstruct edt_ft5x06_attribute {\n\tstruct device_attribute dattr;\n\tsize_t field_offset;\n\tu8 limit_low;\n\tu8 limit_high;\n\tu8 addr_m06;\n\tu8 addr_m09;\n\tu8 addr_ev;\n};\n\n#define EDT_ATTR(_field, _mode, _addr_m06, _addr_m09, _addr_ev,\t\t\\\n\t\t_limit_low, _limit_high)\t\t\t\t\\\n\tstruct edt_ft5x06_attribute edt_ft5x06_attr_##_field = {\t\\\n\t\t.dattr = __ATTR(_field, _mode,\t\t\t\t\\\n\t\t\t\tedt_ft5x06_setting_show,\t\t\\\n\t\t\t\tedt_ft5x06_setting_store),\t\t\\\n\t\t.field_offset = offsetof(struct edt_ft5x06_ts_data, _field), \\\n\t\t.addr_m06 = _addr_m06,\t\t\t\t\t\\\n\t\t.addr_m09 = _addr_m09,\t\t\t\t\t\\\n\t\t.addr_ev  = _addr_ev,\t\t\t\t\t\\\n\t\t.limit_low = _limit_low,\t\t\t\t\\\n\t\t.limit_high = _limit_high,\t\t\t\t\\\n\t}\n\nstatic ssize_t edt_ft5x06_setting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *dattr,\n\t\t\t\t       char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\tstruct edt_ft5x06_attribute *attr =\n\t\t\tcontainer_of(dattr, struct edt_ft5x06_attribute, dattr);\n\tu8 *field = (u8 *)tsdata + attr->field_offset;\n\tunsigned int val;\n\tsize_t count = 0;\n\tint error = 0;\n\tu8 addr;\n\n\tmutex_lock(&tsdata->mutex);\n\n\tif (tsdata->factory_mode) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (tsdata->version) {\n\tcase EDT_M06:\n\t\taddr = attr->addr_m06;\n\t\tbreak;\n\n\tcase EDT_M09:\n\tcase EDT_M12:\n\tcase GENERIC_FT:\n\t\taddr = attr->addr_m09;\n\t\tbreak;\n\n\tcase EV_FT:\n\t\taddr = attr->addr_ev;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (addr != NO_REGISTER) {\n\t\terror = regmap_read(tsdata->regmap, addr, &val);\n\t\tif (error) {\n\t\t\tdev_err(&tsdata->client->dev,\n\t\t\t\t\"Failed to fetch attribute %s, error %d\\n\",\n\t\t\t\tdattr->attr.name, error);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tval = *field;\n\t}\n\n\tif (val != *field) {\n\t\tdev_warn(&tsdata->client->dev,\n\t\t\t \"%s: read (%d) and stored value (%d) differ\\n\",\n\t\t\t dattr->attr.name, val, *field);\n\t\t*field = val;\n\t}\n\n\tcount = scnprintf(buf, PAGE_SIZE, \"%d\\n\", val);\nout:\n\tmutex_unlock(&tsdata->mutex);\n\treturn error ?: count;\n}\n\nstatic ssize_t edt_ft5x06_setting_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *dattr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\tstruct edt_ft5x06_attribute *attr =\n\t\t\tcontainer_of(dattr, struct edt_ft5x06_attribute, dattr);\n\tu8 *field = (u8 *)tsdata + attr->field_offset;\n\tunsigned int val;\n\tint error;\n\tu8 addr;\n\n\tmutex_lock(&tsdata->mutex);\n\n\tif (tsdata->factory_mode) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = kstrtouint(buf, 0, &val);\n\tif (error)\n\t\tgoto out;\n\n\tif (val < attr->limit_low || val > attr->limit_high) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tswitch (tsdata->version) {\n\tcase EDT_M06:\n\t\taddr = attr->addr_m06;\n\t\tbreak;\n\n\tcase EDT_M09:\n\tcase EDT_M12:\n\tcase GENERIC_FT:\n\t\taddr = attr->addr_m09;\n\t\tbreak;\n\n\tcase EV_FT:\n\t\taddr = attr->addr_ev;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (addr != NO_REGISTER) {\n\t\terror = regmap_write(tsdata->regmap, addr, val);\n\t\tif (error) {\n\t\t\tdev_err(&tsdata->client->dev,\n\t\t\t\t\"Failed to update attribute %s, error: %d\\n\",\n\t\t\t\tdattr->attr.name, error);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t*field = val;\n\nout:\n\tmutex_unlock(&tsdata->mutex);\n\treturn error ?: count;\n}\n\n \nstatic EDT_ATTR(gain, S_IWUSR | S_IRUGO, WORK_REGISTER_GAIN,\n\t\tM09_REGISTER_GAIN, EV_REGISTER_GAIN, 0, 31);\n \nstatic EDT_ATTR(offset, S_IWUSR | S_IRUGO, WORK_REGISTER_OFFSET,\n\t\tM09_REGISTER_OFFSET, NO_REGISTER, 0, 31);\n \nstatic EDT_ATTR(offset_x, S_IWUSR | S_IRUGO, NO_REGISTER, NO_REGISTER,\n\t\tEV_REGISTER_OFFSET_X, 0, 80);\n \nstatic EDT_ATTR(offset_y, S_IWUSR | S_IRUGO, NO_REGISTER, NO_REGISTER,\n\t\tEV_REGISTER_OFFSET_Y, 0, 80);\n \nstatic EDT_ATTR(threshold, S_IWUSR | S_IRUGO, WORK_REGISTER_THRESHOLD,\n\t\tM09_REGISTER_THRESHOLD, EV_REGISTER_THRESHOLD, 0, 255);\n \nstatic EDT_ATTR(report_rate, S_IWUSR | S_IRUGO, WORK_REGISTER_REPORT_RATE,\n\t\tM12_REGISTER_REPORT_RATE, NO_REGISTER, 0, 255);\n\nstatic ssize_t model_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\n\treturn sysfs_emit(buf, \"%s\\n\", tsdata->name);\n}\n\nstatic DEVICE_ATTR_RO(model);\n\nstatic ssize_t fw_version_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\n\treturn sysfs_emit(buf, \"%s\\n\", tsdata->fw_version);\n}\n\nstatic DEVICE_ATTR_RO(fw_version);\n\n \nstatic ssize_t header_errors_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\n\treturn sysfs_emit(buf, \"%d\\n\", tsdata->header_errors);\n}\n\nstatic DEVICE_ATTR_RO(header_errors);\n\n \nstatic ssize_t crc_errors_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\n\treturn sysfs_emit(buf, \"%d\\n\", tsdata->crc_errors);\n}\n\nstatic DEVICE_ATTR_RO(crc_errors);\n\nstatic struct attribute *edt_ft5x06_attrs[] = {\n\t&edt_ft5x06_attr_gain.dattr.attr,\n\t&edt_ft5x06_attr_offset.dattr.attr,\n\t&edt_ft5x06_attr_offset_x.dattr.attr,\n\t&edt_ft5x06_attr_offset_y.dattr.attr,\n\t&edt_ft5x06_attr_threshold.dattr.attr,\n\t&edt_ft5x06_attr_report_rate.dattr.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_header_errors.attr,\n\t&dev_attr_crc_errors.attr,\n\tNULL\n};\n\nstatic const struct attribute_group edt_ft5x06_attr_group = {\n\t.attrs = edt_ft5x06_attrs,\n};\n\nstatic void edt_ft5x06_restore_reg_parameters(struct edt_ft5x06_ts_data *tsdata)\n{\n\tstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\n\tstruct regmap *regmap = tsdata->regmap;\n\n\tregmap_write(regmap, reg_addr->reg_threshold, tsdata->threshold);\n\tregmap_write(regmap, reg_addr->reg_gain, tsdata->gain);\n\tif (reg_addr->reg_offset != NO_REGISTER)\n\t\tregmap_write(regmap, reg_addr->reg_offset, tsdata->offset);\n\tif (reg_addr->reg_offset_x != NO_REGISTER)\n\t\tregmap_write(regmap, reg_addr->reg_offset_x, tsdata->offset_x);\n\tif (reg_addr->reg_offset_y != NO_REGISTER)\n\t\tregmap_write(regmap, reg_addr->reg_offset_y, tsdata->offset_y);\n\tif (reg_addr->reg_report_rate != NO_REGISTER)\n\t\tregmap_write(regmap, reg_addr->reg_report_rate,\n\t\t\t     tsdata->report_rate);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int edt_ft5x06_factory_mode(struct edt_ft5x06_ts_data *tsdata)\n{\n\tstruct i2c_client *client = tsdata->client;\n\tint retries = EDT_SWITCH_MODE_RETRIES;\n\tunsigned int val;\n\tint error;\n\n\tif (tsdata->version != EDT_M06) {\n\t\tdev_err(&client->dev,\n\t\t\t\"No factory mode support for non-M06 devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdisable_irq(client->irq);\n\n\tif (!tsdata->raw_buffer) {\n\t\ttsdata->raw_bufsize = tsdata->num_x * tsdata->num_y *\n\t\t\t\t      sizeof(u16);\n\t\ttsdata->raw_buffer = kzalloc(tsdata->raw_bufsize, GFP_KERNEL);\n\t\tif (!tsdata->raw_buffer) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\terror = regmap_write(tsdata->regmap, WORK_REGISTER_OPMODE, 0x03);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to switch to factory mode, error %d\\n\", error);\n\t\tgoto err_out;\n\t}\n\n\ttsdata->factory_mode = true;\n\tdo {\n\t\tmdelay(EDT_SWITCH_MODE_DELAY);\n\t\t \n\t\terror = regmap_read(tsdata->regmap, FACTORY_REGISTER_OPMODE,\n\t\t\t\t    &val);\n\t\tif (!error && val == 0x03)\n\t\t\tbreak;\n\t} while (--retries > 0);\n\n\tif (retries == 0) {\n\t\tdev_err(&client->dev, \"not in factory mode after %dms.\\n\",\n\t\t\tEDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);\n\t\terror = -EIO;\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tkfree(tsdata->raw_buffer);\n\ttsdata->raw_buffer = NULL;\n\ttsdata->factory_mode = false;\n\tenable_irq(client->irq);\n\n\treturn error;\n}\n\nstatic int edt_ft5x06_work_mode(struct edt_ft5x06_ts_data *tsdata)\n{\n\tstruct i2c_client *client = tsdata->client;\n\tint retries = EDT_SWITCH_MODE_RETRIES;\n\tunsigned int val;\n\tint error;\n\n\t \n\terror = regmap_write(tsdata->regmap, FACTORY_REGISTER_OPMODE, 0x1);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to switch to work mode, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ttsdata->factory_mode = false;\n\n\tdo {\n\t\tmdelay(EDT_SWITCH_MODE_DELAY);\n\t\t \n\t\terror = regmap_read(tsdata->regmap, WORK_REGISTER_OPMODE, &val);\n\t\tif (!error && val == 0x01)\n\t\t\tbreak;\n\t} while (--retries > 0);\n\n\tif (retries == 0) {\n\t\tdev_err(&client->dev, \"not in work mode after %dms.\\n\",\n\t\t\tEDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);\n\t\ttsdata->factory_mode = true;\n\t\treturn -EIO;\n\t}\n\n\tkfree(tsdata->raw_buffer);\n\ttsdata->raw_buffer = NULL;\n\n\tedt_ft5x06_restore_reg_parameters(tsdata);\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int edt_ft5x06_debugfs_mode_get(void *data, u64 *mode)\n{\n\tstruct edt_ft5x06_ts_data *tsdata = data;\n\n\t*mode = tsdata->factory_mode;\n\n\treturn 0;\n};\n\nstatic int edt_ft5x06_debugfs_mode_set(void *data, u64 mode)\n{\n\tstruct edt_ft5x06_ts_data *tsdata = data;\n\tint retval = 0;\n\n\tif (mode > 1)\n\t\treturn -ERANGE;\n\n\tmutex_lock(&tsdata->mutex);\n\n\tif (mode != tsdata->factory_mode) {\n\t\tretval = mode ? edt_ft5x06_factory_mode(tsdata) :\n\t\t\t\tedt_ft5x06_work_mode(tsdata);\n\t}\n\n\tmutex_unlock(&tsdata->mutex);\n\n\treturn retval;\n};\n\nDEFINE_SIMPLE_ATTRIBUTE(debugfs_mode_fops, edt_ft5x06_debugfs_mode_get,\n\t\t\tedt_ft5x06_debugfs_mode_set, \"%llu\\n\");\n\nstatic ssize_t edt_ft5x06_debugfs_raw_data_read(struct file *file,\n\t\t\t\t\t\tchar __user *buf, size_t count,\n\t\t\t\t\t\tloff_t *off)\n{\n\tstruct edt_ft5x06_ts_data *tsdata = file->private_data;\n\tstruct i2c_client *client = tsdata->client;\n\tint retries  = EDT_RAW_DATA_RETRIES;\n\tunsigned int val;\n\tint i, error;\n\tsize_t read = 0;\n\tint colbytes;\n\tu8 *rdbuf;\n\n\tif (*off < 0 || *off >= tsdata->raw_bufsize)\n\t\treturn 0;\n\n\tmutex_lock(&tsdata->mutex);\n\n\tif (!tsdata->factory_mode || !tsdata->raw_buffer) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = regmap_write(tsdata->regmap, 0x08, 0x01);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to write 0x08 register, error %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tusleep_range(EDT_RAW_DATA_DELAY, EDT_RAW_DATA_DELAY + 100);\n\t\terror = regmap_read(tsdata->regmap, 0x08, &val);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to read 0x08 register, error %d\\n\",\n\t\t\t\terror);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (val == 1)\n\t\t\tbreak;\n\t} while (--retries > 0);\n\n\tif (retries == 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"timed out waiting for register to settle\\n\");\n\t\terror = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\trdbuf = tsdata->raw_buffer;\n\tcolbytes = tsdata->num_y * sizeof(u16);\n\n\tfor (i = 0; i < tsdata->num_x; i++) {\n\t\trdbuf[0] = i;   \n\t\terror = regmap_bulk_read(tsdata->regmap, 0xf5, rdbuf, colbytes);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\trdbuf += colbytes;\n\t}\n\n\tread = min_t(size_t, count, tsdata->raw_bufsize - *off);\n\tif (copy_to_user(buf, tsdata->raw_buffer + *off, read)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t*off += read;\nout:\n\tmutex_unlock(&tsdata->mutex);\n\treturn error ?: read;\n};\n\nstatic const struct file_operations debugfs_raw_data_fops = {\n\t.open = simple_open,\n\t.read = edt_ft5x06_debugfs_raw_data_read,\n};\n\nstatic void edt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,\n\t\t\t\t\t  const char *debugfs_name)\n{\n\ttsdata->debug_dir = debugfs_create_dir(debugfs_name, NULL);\n\n\tdebugfs_create_u16(\"num_x\", S_IRUSR, tsdata->debug_dir, &tsdata->num_x);\n\tdebugfs_create_u16(\"num_y\", S_IRUSR, tsdata->debug_dir, &tsdata->num_y);\n\n\tdebugfs_create_file(\"mode\", S_IRUSR | S_IWUSR,\n\t\t\t    tsdata->debug_dir, tsdata, &debugfs_mode_fops);\n\tdebugfs_create_file(\"raw_data\", S_IRUSR,\n\t\t\t    tsdata->debug_dir, tsdata, &debugfs_raw_data_fops);\n}\n\nstatic void edt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)\n{\n\tdebugfs_remove_recursive(tsdata->debug_dir);\n\tkfree(tsdata->raw_buffer);\n}\n\n#else\n\nstatic int edt_ft5x06_factory_mode(struct edt_ft5x06_ts_data *tsdata)\n{\n\treturn -ENOSYS;\n}\n\nstatic void edt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,\n\t\t\t\t\t  const char *debugfs_name)\n{\n}\n\nstatic void edt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)\n{\n}\n\n#endif  \n\nstatic int edt_ft5x06_ts_identify(struct i2c_client *client,\n\t\t\t\t  struct edt_ft5x06_ts_data *tsdata)\n{\n\tu8 rdbuf[EDT_NAME_LEN];\n\tchar *p;\n\tint error;\n\tchar *model_name = tsdata->name;\n\tchar *fw_version = tsdata->fw_version;\n\n\t \n\tmemset(rdbuf, 0, sizeof(rdbuf));\n\terror = regmap_bulk_read(tsdata->regmap, 0xBB, rdbuf, EDT_NAME_LEN - 1);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!strncasecmp(rdbuf + 1, \"EP0\", 3)) {\n\t\ttsdata->version = EDT_M06;\n\n\t\t \n\t\trdbuf[EDT_NAME_LEN - 1] = '\\0';\n\t\tif (rdbuf[EDT_NAME_LEN - 2] == '$')\n\t\t\trdbuf[EDT_NAME_LEN - 2] = '\\0';\n\n\t\t \n\t\tp = strchr(rdbuf, '*');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\t\tstrscpy(model_name, rdbuf + 1, EDT_NAME_LEN);\n\t\tstrscpy(fw_version, p ? p : \"\", EDT_NAME_LEN);\n\n\t\tregmap_exit(tsdata->regmap);\n\t\ttsdata->regmap = regmap_init_i2c(client,\n\t\t\t\t\t\t &edt_M06_i2c_regmap_config);\n\t\tif (IS_ERR(tsdata->regmap)) {\n\t\t\tdev_err(&client->dev, \"regmap allocation failed\\n\");\n\t\t\treturn PTR_ERR(tsdata->regmap);\n\t\t}\n\t} else if (!strncasecmp(rdbuf, \"EP0\", 3)) {\n\t\ttsdata->version = EDT_M12;\n\n\t\t \n\t\trdbuf[EDT_NAME_LEN - 2] = '\\0';\n\t\tif (rdbuf[EDT_NAME_LEN - 3] == '$')\n\t\t\trdbuf[EDT_NAME_LEN - 3] = '\\0';\n\n\t\t \n\t\tp = strchr(rdbuf, '*');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\t\tstrscpy(model_name, rdbuf, EDT_NAME_LEN);\n\t\tstrscpy(fw_version, p ? p : \"\", EDT_NAME_LEN);\n\t} else {\n\t\t \n\t\ttsdata->version = GENERIC_FT;\n\n\t\terror = regmap_bulk_read(tsdata->regmap, 0xA6, rdbuf, 2);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tstrscpy(fw_version, rdbuf, 2);\n\n\t\terror = regmap_bulk_read(tsdata->regmap, 0xA8, rdbuf, 1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t \n\t\tswitch (rdbuf[0]) {\n\t\tcase 0x11:    \n\t\tcase 0x35:    \n\t\tcase 0x43:    \n\t\tcase 0x50:    \n\t\tcase 0x57:    \n\t\tcase 0x70:    \n\t\t\ttsdata->version = EDT_M09;\n\t\t\tsnprintf(model_name, EDT_NAME_LEN, \"EP0%i%i0M09\",\n\t\t\t\t rdbuf[0] >> 4, rdbuf[0] & 0x0F);\n\t\t\tbreak;\n\t\tcase 0xa1:    \n\t\t\ttsdata->version = EDT_M09;\n\t\t\tsnprintf(model_name, EDT_NAME_LEN, \"EP%i%i0ML00\",\n\t\t\t\t rdbuf[0] >> 4, rdbuf[0] & 0x0F);\n\t\t\tbreak;\n\t\tcase 0x5a:    \n\t\t\tsnprintf(model_name, EDT_NAME_LEN, \"GKTW50SCED1R0\");\n\t\t\tbreak;\n\t\tcase 0x59:   \n\t\t\ttsdata->version = EV_FT;\n\t\t\terror = regmap_bulk_read(tsdata->regmap, 0x53, rdbuf, 1);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tstrscpy(fw_version, rdbuf, 1);\n\t\t\tsnprintf(model_name, EDT_NAME_LEN,\n\t\t\t\t \"EVERVISION-FT5726NEi\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(model_name, EDT_NAME_LEN,\n\t\t\t\t \"generic ft5x06 (%02x)\",\n\t\t\t\t rdbuf[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void edt_ft5x06_ts_get_defaults(struct device *dev,\n\t\t\t\t       struct edt_ft5x06_ts_data *tsdata)\n{\n\tstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\n\tstruct regmap *regmap = tsdata->regmap;\n\tu32 val;\n\tint error;\n\n\terror = device_property_read_u32(dev, \"threshold\", &val);\n\tif (!error) {\n\t\tregmap_write(regmap, reg_addr->reg_threshold, val);\n\t\ttsdata->threshold = val;\n\t}\n\n\terror = device_property_read_u32(dev, \"gain\", &val);\n\tif (!error) {\n\t\tregmap_write(regmap, reg_addr->reg_gain, val);\n\t\ttsdata->gain = val;\n\t}\n\n\terror = device_property_read_u32(dev, \"offset\", &val);\n\tif (!error) {\n\t\tif (reg_addr->reg_offset != NO_REGISTER)\n\t\t\tregmap_write(regmap, reg_addr->reg_offset, val);\n\t\ttsdata->offset = val;\n\t}\n\n\terror = device_property_read_u32(dev, \"offset-x\", &val);\n\tif (!error) {\n\t\tif (reg_addr->reg_offset_x != NO_REGISTER)\n\t\t\tregmap_write(regmap, reg_addr->reg_offset_x, val);\n\t\ttsdata->offset_x = val;\n\t}\n\n\terror = device_property_read_u32(dev, \"offset-y\", &val);\n\tif (!error) {\n\t\tif (reg_addr->reg_offset_y != NO_REGISTER)\n\t\t\tregmap_write(regmap, reg_addr->reg_offset_y, val);\n\t\ttsdata->offset_y = val;\n\t}\n}\n\nstatic void edt_ft5x06_ts_get_parameters(struct edt_ft5x06_ts_data *tsdata)\n{\n\tstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\n\tstruct regmap *regmap = tsdata->regmap;\n\tunsigned int val;\n\n\tregmap_read(regmap, reg_addr->reg_threshold, &tsdata->threshold);\n\tregmap_read(regmap, reg_addr->reg_gain, &tsdata->gain);\n\tif (reg_addr->reg_offset != NO_REGISTER)\n\t\tregmap_read(regmap, reg_addr->reg_offset, &tsdata->offset);\n\tif (reg_addr->reg_offset_x != NO_REGISTER)\n\t\tregmap_read(regmap, reg_addr->reg_offset_x, &tsdata->offset_x);\n\tif (reg_addr->reg_offset_y != NO_REGISTER)\n\t\tregmap_read(regmap, reg_addr->reg_offset_y, &tsdata->offset_y);\n\tif (reg_addr->reg_report_rate != NO_REGISTER)\n\t\tregmap_read(regmap, reg_addr->reg_report_rate,\n\t\t\t    &tsdata->report_rate);\n\ttsdata->num_x = EDT_DEFAULT_NUM_X;\n\tif (reg_addr->reg_num_x != NO_REGISTER) {\n\t\tif (!regmap_read(regmap, reg_addr->reg_num_x, &val))\n\t\t\ttsdata->num_x = val;\n\t}\n\ttsdata->num_y = EDT_DEFAULT_NUM_Y;\n\tif (reg_addr->reg_num_y != NO_REGISTER) {\n\t\tif (!regmap_read(regmap, reg_addr->reg_num_y, &val))\n\t\t\ttsdata->num_y = val;\n\t}\n}\n\nstatic void edt_ft5x06_ts_set_tdata_parameters(struct edt_ft5x06_ts_data *tsdata)\n{\n\tint crclen;\n\n\tif (tsdata->version == EDT_M06) {\n\t\ttsdata->tdata_cmd = 0xf9;\n\t\ttsdata->tdata_offset = 5;\n\t\ttsdata->point_len = 4;\n\t\tcrclen = 1;\n\t} else {\n\t\ttsdata->tdata_cmd = 0x0;\n\t\ttsdata->tdata_offset = 3;\n\t\ttsdata->point_len = 6;\n\t\tcrclen = 0;\n\t}\n\n\ttsdata->tdata_len = tsdata->point_len * tsdata->max_support_points +\n\t\ttsdata->tdata_offset + crclen;\n}\n\nstatic void edt_ft5x06_ts_set_regs(struct edt_ft5x06_ts_data *tsdata)\n{\n\tstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\n\n\tswitch (tsdata->version) {\n\tcase EDT_M06:\n\t\treg_addr->reg_threshold = WORK_REGISTER_THRESHOLD;\n\t\treg_addr->reg_report_rate = WORK_REGISTER_REPORT_RATE;\n\t\treg_addr->reg_gain = WORK_REGISTER_GAIN;\n\t\treg_addr->reg_offset = WORK_REGISTER_OFFSET;\n\t\treg_addr->reg_offset_x = NO_REGISTER;\n\t\treg_addr->reg_offset_y = NO_REGISTER;\n\t\treg_addr->reg_num_x = WORK_REGISTER_NUM_X;\n\t\treg_addr->reg_num_y = WORK_REGISTER_NUM_Y;\n\t\tbreak;\n\n\tcase EDT_M09:\n\tcase EDT_M12:\n\t\treg_addr->reg_threshold = M09_REGISTER_THRESHOLD;\n\t\treg_addr->reg_report_rate = tsdata->version == EDT_M12 ?\n\t\t\tM12_REGISTER_REPORT_RATE : NO_REGISTER;\n\t\treg_addr->reg_gain = M09_REGISTER_GAIN;\n\t\treg_addr->reg_offset = M09_REGISTER_OFFSET;\n\t\treg_addr->reg_offset_x = NO_REGISTER;\n\t\treg_addr->reg_offset_y = NO_REGISTER;\n\t\treg_addr->reg_num_x = M09_REGISTER_NUM_X;\n\t\treg_addr->reg_num_y = M09_REGISTER_NUM_Y;\n\t\tbreak;\n\n\tcase EV_FT:\n\t\treg_addr->reg_threshold = EV_REGISTER_THRESHOLD;\n\t\treg_addr->reg_report_rate = NO_REGISTER;\n\t\treg_addr->reg_gain = EV_REGISTER_GAIN;\n\t\treg_addr->reg_offset = NO_REGISTER;\n\t\treg_addr->reg_offset_x = EV_REGISTER_OFFSET_X;\n\t\treg_addr->reg_offset_y = EV_REGISTER_OFFSET_Y;\n\t\treg_addr->reg_num_x = NO_REGISTER;\n\t\treg_addr->reg_num_y = NO_REGISTER;\n\t\tbreak;\n\n\tcase GENERIC_FT:\n\t\t \n\t\treg_addr->reg_threshold = M09_REGISTER_THRESHOLD;\n\t\treg_addr->reg_report_rate = NO_REGISTER;\n\t\treg_addr->reg_gain = M09_REGISTER_GAIN;\n\t\treg_addr->reg_offset = M09_REGISTER_OFFSET;\n\t\treg_addr->reg_offset_x = NO_REGISTER;\n\t\treg_addr->reg_offset_y = NO_REGISTER;\n\t\treg_addr->reg_num_x = NO_REGISTER;\n\t\treg_addr->reg_num_y = NO_REGISTER;\n\t\tbreak;\n\t}\n}\n\nstatic void edt_ft5x06_disable_regulators(void *arg)\n{\n\tstruct edt_ft5x06_ts_data *data = arg;\n\n\tregulator_disable(data->vcc);\n\tregulator_disable(data->iovcc);\n}\n\nstatic int edt_ft5x06_ts_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct edt_i2c_chip_data *chip_data;\n\tstruct edt_ft5x06_ts_data *tsdata;\n\tunsigned int val;\n\tstruct input_dev *input;\n\tunsigned long irq_flags;\n\tint error;\n\tu32 report_rate;\n\n\tdev_dbg(&client->dev, \"probing for EDT FT5x06 I2C\\n\");\n\n\ttsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);\n\tif (!tsdata) {\n\t\tdev_err(&client->dev, \"failed to allocate driver data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttsdata->regmap = regmap_init_i2c(client, &edt_ft5x06_i2c_regmap_config);\n\tif (IS_ERR(tsdata->regmap)) {\n\t\tdev_err(&client->dev, \"regmap allocation failed\\n\");\n\t\treturn PTR_ERR(tsdata->regmap);\n\t}\n\n\tchip_data = device_get_match_data(&client->dev);\n\tif (!chip_data)\n\t\tchip_data = (const struct edt_i2c_chip_data *)id->driver_data;\n\tif (!chip_data || !chip_data->max_support_points) {\n\t\tdev_err(&client->dev, \"invalid or missing chip data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttsdata->max_support_points = chip_data->max_support_points;\n\n\ttsdata->vcc = devm_regulator_get(&client->dev, \"vcc\");\n\tif (IS_ERR(tsdata->vcc))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(tsdata->vcc),\n\t\t\t\t     \"failed to request regulator\\n\");\n\n\ttsdata->iovcc = devm_regulator_get(&client->dev, \"iovcc\");\n\tif (IS_ERR(tsdata->iovcc)) {\n\t\terror = PTR_ERR(tsdata->iovcc);\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to request iovcc regulator: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(tsdata->iovcc);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to enable iovcc: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tusleep_range(10, 100);\n\n\terror = regulator_enable(tsdata->vcc);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to enable vcc: %d\\n\", error);\n\t\tregulator_disable(tsdata->iovcc);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t edt_ft5x06_disable_regulators,\n\t\t\t\t\t tsdata);\n\tif (error)\n\t\treturn error;\n\n\ttsdata->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t     \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tsdata->reset_gpio)) {\n\t\terror = PTR_ERR(tsdata->reset_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to request GPIO reset pin, error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ttsdata->wake_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t    \"wake\", GPIOD_OUT_LOW);\n\tif (IS_ERR(tsdata->wake_gpio)) {\n\t\terror = PTR_ERR(tsdata->wake_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to request GPIO wake pin, error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tif (tsdata->reset_gpio)\n\t\ttsdata->suspend_mode = EDT_PMODE_POWEROFF;\n\telse if (tsdata->wake_gpio)\n\t\ttsdata->suspend_mode = EDT_PMODE_HIBERNATE;\n\telse\n\t\ttsdata->suspend_mode = EDT_PMODE_NOT_SUPPORTED;\n\n\tif (tsdata->wake_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->wake_gpio, 1);\n\t\tusleep_range(5000, 6000);\n\t}\n\n\tif (tsdata->reset_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->reset_gpio, 0);\n\t\tmsleep(300);\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input) {\n\t\tdev_err(&client->dev, \"failed to allocate input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tsdata->mutex);\n\ttsdata->client = client;\n\ttsdata->input = input;\n\ttsdata->factory_mode = false;\n\ti2c_set_clientdata(client, tsdata);\n\n\terror = edt_ft5x06_ts_identify(client, tsdata);\n\tif (error) {\n\t\tdev_err(&client->dev, \"touchscreen probe failed\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tregmap_read(tsdata->regmap, 0x00, &val);\n\n\tedt_ft5x06_ts_set_tdata_parameters(tsdata);\n\tedt_ft5x06_ts_set_regs(tsdata);\n\tedt_ft5x06_ts_get_defaults(&client->dev, tsdata);\n\tedt_ft5x06_ts_get_parameters(tsdata);\n\n\tif (tsdata->reg_addr.reg_report_rate != NO_REGISTER &&\n\t    !device_property_read_u32(&client->dev,\n\t\t\t\t      \"report-rate-hz\", &report_rate)) {\n\t\tif (tsdata->version == EDT_M06)\n\t\t\ttsdata->report_rate = clamp_val(report_rate, 30, 140);\n\t\telse\n\t\t\ttsdata->report_rate = clamp_val(report_rate, 1, 255);\n\n\t\tif (report_rate != tsdata->report_rate)\n\t\t\tdev_warn(&client->dev,\n\t\t\t\t \"report-rate %dHz is unsupported, use %dHz\\n\",\n\t\t\t\t report_rate, tsdata->report_rate);\n\n\t\tif (tsdata->version == EDT_M06)\n\t\t\ttsdata->report_rate /= 10;\n\n\t\tregmap_write(tsdata->regmap, tsdata->reg_addr.reg_report_rate,\n\t\t\t     tsdata->report_rate);\n\t}\n\n\tdev_dbg(&client->dev,\n\t\t\"Model \\\"%s\\\", Rev. \\\"%s\\\", %dx%d sensors\\n\",\n\t\ttsdata->name, tsdata->fw_version, tsdata->num_x, tsdata->num_y);\n\n\tinput->name = tsdata->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->dev.parent = &client->dev;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t     0, tsdata->num_x * 64 - 1, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t     0, tsdata->num_y * 64 - 1, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, &tsdata->prop);\n\n\terror = input_mt_init_slots(input, tsdata->max_support_points,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to init MT slots.\\n\");\n\t\treturn error;\n\t}\n\n\tirq_flags = irq_get_trigger_type(client->irq);\n\tif (irq_flags == IRQF_TRIGGER_NONE)\n\t\tirq_flags = IRQF_TRIGGER_FALLING;\n\tirq_flags |= IRQF_ONESHOT;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, edt_ft5x06_ts_isr, irq_flags,\n\t\t\t\t\t  client->name, tsdata);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to request touchscreen IRQ.\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &edt_ft5x06_attr_group);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\tedt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&client->dev));\n\n\tdev_dbg(&client->dev,\n\t\t\"EDT FT5x06 initialized: IRQ %d, WAKE pin %d, Reset pin %d.\\n\",\n\t\tclient->irq,\n\t\ttsdata->wake_gpio ? desc_to_gpio(tsdata->wake_gpio) : -1,\n\t\ttsdata->reset_gpio ? desc_to_gpio(tsdata->reset_gpio) : -1);\n\n\treturn 0;\n}\n\nstatic void edt_ft5x06_ts_remove(struct i2c_client *client)\n{\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\n\tedt_ft5x06_ts_teardown_debugfs(tsdata);\n\tregmap_exit(tsdata->regmap);\n}\n\nstatic int edt_ft5x06_ts_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\tstruct gpio_desc *reset_gpio = tsdata->reset_gpio;\n\tint ret;\n\n\tif (device_may_wakeup(dev))\n\t\treturn 0;\n\n\tif (tsdata->suspend_mode == EDT_PMODE_NOT_SUPPORTED)\n\t\treturn 0;\n\n\t \n\tret = regmap_write(tsdata->regmap, PMOD_REGISTER_OPMODE,\n\t\t\t   PMOD_REGISTER_HIBERNATE);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to set hibernate mode\\n\");\n\n\tif (tsdata->suspend_mode == EDT_PMODE_HIBERNATE)\n\t\treturn 0;\n\n\t \n\tdisable_irq(tsdata->client->irq);\n\n\tgpiod_set_value_cansleep(reset_gpio, 1);\n\tusleep_range(1000, 2000);\n\n\tret = regulator_disable(tsdata->vcc);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to disable vcc\\n\");\n\tret = regulator_disable(tsdata->iovcc);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to disable iovcc\\n\");\n\n\treturn 0;\n}\n\nstatic int edt_ft5x06_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\n\tint ret = 0;\n\n\tif (device_may_wakeup(dev))\n\t\treturn 0;\n\n\tif (tsdata->suspend_mode == EDT_PMODE_NOT_SUPPORTED)\n\t\treturn 0;\n\n\tif (tsdata->suspend_mode == EDT_PMODE_POWEROFF) {\n\t\tstruct gpio_desc *reset_gpio = tsdata->reset_gpio;\n\n\t\t \n\t\tgpiod_set_value_cansleep(reset_gpio, 1);\n\t\tusleep_range(5000, 6000);\n\n\t\tret = regulator_enable(tsdata->iovcc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable iovcc\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tusleep_range(10, 100);\n\n\t\tret = regulator_enable(tsdata->vcc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable vcc\\n\");\n\t\t\tregulator_disable(tsdata->iovcc);\n\t\t\treturn ret;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\tmsleep(300);\n\n\t\tedt_ft5x06_restore_reg_parameters(tsdata);\n\t\tenable_irq(tsdata->client->irq);\n\n\t\tif (tsdata->factory_mode)\n\t\t\tret = edt_ft5x06_factory_mode(tsdata);\n\t} else {\n\t\tstruct gpio_desc *wake_gpio = tsdata->wake_gpio;\n\n\t\tgpiod_set_value_cansleep(wake_gpio, 0);\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(wake_gpio, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(edt_ft5x06_ts_pm_ops,\n\t\t\t\tedt_ft5x06_ts_suspend, edt_ft5x06_ts_resume);\n\nstatic const struct edt_i2c_chip_data edt_ft5x06_data = {\n\t.max_support_points = 5,\n};\n\nstatic const struct edt_i2c_chip_data edt_ft5506_data = {\n\t.max_support_points = 10,\n};\n\nstatic const struct edt_i2c_chip_data edt_ft6236_data = {\n\t.max_support_points = 2,\n};\n\nstatic const struct i2c_device_id edt_ft5x06_ts_id[] = {\n\t{ .name = \"edt-ft5x06\", .driver_data = (long)&edt_ft5x06_data },\n\t{ .name = \"edt-ft5506\", .driver_data = (long)&edt_ft5506_data },\n\t{ .name = \"ev-ft5726\", .driver_data = (long)&edt_ft5506_data },\n\t \n\t{ .name = \"ft6236\", .driver_data = (long)&edt_ft6236_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, edt_ft5x06_ts_id);\n\nstatic const struct of_device_id edt_ft5x06_of_match[] = {\n\t{ .compatible = \"edt,edt-ft5206\", .data = &edt_ft5x06_data },\n\t{ .compatible = \"edt,edt-ft5306\", .data = &edt_ft5x06_data },\n\t{ .compatible = \"edt,edt-ft5406\", .data = &edt_ft5x06_data },\n\t{ .compatible = \"edt,edt-ft5506\", .data = &edt_ft5506_data },\n\t{ .compatible = \"evervision,ev-ft5726\", .data = &edt_ft5506_data },\n\t \n\t{ .compatible = \"focaltech,ft6236\", .data = &edt_ft6236_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, edt_ft5x06_of_match);\n\nstatic struct i2c_driver edt_ft5x06_ts_driver = {\n\t.driver = {\n\t\t.name = \"edt_ft5x06\",\n\t\t.of_match_table = edt_ft5x06_of_match,\n\t\t.pm = pm_sleep_ptr(&edt_ft5x06_ts_pm_ops),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table = edt_ft5x06_ts_id,\n\t.probe    = edt_ft5x06_ts_probe,\n\t.remove   = edt_ft5x06_ts_remove,\n};\n\nmodule_i2c_driver(edt_ft5x06_ts_driver);\n\nMODULE_AUTHOR(\"Simon Budig <simon.budig@kernelconcepts.de>\");\nMODULE_DESCRIPTION(\"EDT FT5x06 I2C Touchscreen Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}