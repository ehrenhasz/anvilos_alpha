{
  "module_name": "wm9705.c",
  "hash_id": "3e06ca9b316603f6a4a6aa1e036110bfefac1d18ffb6ea287ec2f4d569c035e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wm9705.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/wm97xx.h>\n\n#define TS_NAME\t\t\t\"wm97xx\"\n#define WM9705_VERSION\t\t\"1.00\"\n#define DEFAULT_PRESSURE\t0xb0c0\n\n \n\n \nstatic int pil;\nmodule_param(pil, int, 0);\nMODULE_PARM_DESC(pil, \"Set current used for pressure measurement.\");\n\n \nstatic int pressure = DEFAULT_PRESSURE & 0xfff;\nmodule_param(pressure, int, 0);\nMODULE_PARM_DESC(pressure, \"Set threshold for pressure measurement.\");\n\n \nstatic int delay = 4;\nmodule_param(delay, int, 0);\nMODULE_PARM_DESC(delay, \"Set adc sample delay.\");\n\n \nstatic int pdd = 8;\nmodule_param(pdd, int, 0);\nMODULE_PARM_DESC(pdd, \"Set pen detect comparator threshold\");\n\n \nstatic int mask;\nmodule_param(mask, int, 0);\nMODULE_PARM_DESC(mask, \"Set adc mask function.\");\n\n \nstatic const int delay_table[] = {\n\t21,     \n\t42,     \n\t84,     \n\t167,    \n\t333,    \n\t667,    \n\t1000,   \n\t1333,   \n\t2000,   \n\t2667,   \n\t3333,   \n\t4000,   \n\t4667,   \n\t5333,   \n\t6000,   \n\t0       \n};\n\n \nstatic inline void poll_delay(int d)\n{\n\tudelay(3 * AC97_LINK_FRAME + delay_table[d]);\n}\n\n \nstatic void wm9705_phy_init(struct wm97xx *wm)\n{\n\tu16 dig1 = 0, dig2 = WM97XX_RPR;\n\n\t \n\twm97xx_reg_write(wm, AC97_AUX, 0x8000);\n\twm97xx_reg_write(wm, AC97_VIDEO, 0x8000);\n\n\t \n\tif (pil == 2) {\n\t\tdig2 |= WM9705_PIL;\n\t\tdev_dbg(wm->dev,\n\t\t\t\"setting pressure measurement current to 400uA.\");\n\t} else if (pil)\n\t\tdev_dbg(wm->dev,\n\t\t\t\"setting pressure measurement current to 200uA.\");\n\tif (!pil)\n\t\tpressure = 0;\n\n\t \n\tif (delay != 4) {\n\t\tif (delay < 0 || delay > 15) {\n\t\t\tdev_dbg(wm->dev, \"supplied delay out of range.\");\n\t\t\tdelay = 4;\n\t\t}\n\t}\n\tdig1 &= 0xff0f;\n\tdig1 |= WM97XX_DELAY(delay);\n\tdev_dbg(wm->dev, \"setting adc sample delay to %d u Secs.\",\n\t\tdelay_table[delay]);\n\n\t \n\tdig2 |= (pdd & 0x000f);\n\tdev_dbg(wm->dev, \"setting pdd to Vmid/%d\", 1 - (pdd & 0x000f));\n\n\t \n\tdig2 |= ((mask & 0x3) << 4);\n\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, dig1);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, dig2);\n}\n\nstatic void wm9705_dig_enable(struct wm97xx *wm, int enable)\n{\n\tif (enable) {\n\t\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2,\n\t\t\t\t wm->dig[2] | WM97XX_PRP_DET_DIG);\n\t\twm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);  \n\t} else\n\t\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2,\n\t\t\t\t wm->dig[2] & ~WM97XX_PRP_DET_DIG);\n}\n\nstatic void wm9705_aux_prepare(struct wm97xx *wm)\n{\n\tmemcpy(wm->dig_save, wm->dig, sizeof(wm->dig));\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, 0);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, WM97XX_PRP_DET_DIG);\n}\n\nstatic void wm9705_dig_restore(struct wm97xx *wm)\n{\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, wm->dig_save[1]);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, wm->dig_save[2]);\n}\n\nstatic inline int is_pden(struct wm97xx *wm)\n{\n\treturn wm->dig[2] & WM9705_PDEN;\n}\n\n \nstatic int wm9705_poll_sample(struct wm97xx *wm, int adcsel, int *sample)\n{\n\tint timeout = 5 * delay;\n\tbool wants_pen = adcsel & WM97XX_PEN_DOWN;\n\n\tif (wants_pen && !wm->pen_probably_down) {\n\t\tu16 data = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\t\tif (!(data & WM97XX_PEN_DOWN))\n\t\t\treturn RC_PENUP;\n\t\twm->pen_probably_down = 1;\n\t}\n\n\t \n\tif (wm->mach_ops && wm->mach_ops->pre_sample)\n\t\twm->mach_ops->pre_sample(adcsel);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, (adcsel & WM97XX_ADCSEL_MASK)\n\t\t\t\t| WM97XX_POLL | WM97XX_DELAY(delay));\n\n\t \n\tpoll_delay(delay);\n\n\t \n\twhile ((wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER1) & WM97XX_POLL)\n\t       && timeout) {\n\t\tudelay(AC97_LINK_FRAME);\n\t\ttimeout--;\n\t}\n\n\tif (timeout == 0) {\n\t\t \n\t\tif (is_pden(wm))\n\t\t\twm->pen_probably_down = 0;\n\t\telse\n\t\t\tdev_dbg(wm->dev, \"adc sample timeout\");\n\t\treturn RC_PENUP;\n\t}\n\n\t*sample = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\n\tif (wm->mach_ops && wm->mach_ops->post_sample)\n\t\twm->mach_ops->post_sample(adcsel);\n\n\t \n\tif ((*sample ^ adcsel) & WM97XX_ADCSEL_MASK) {\n\t\tdev_dbg(wm->dev, \"adc wrong sample, wanted %x got %x\",\n\t\t\tadcsel & WM97XX_ADCSEL_MASK,\n\t\t\t*sample & WM97XX_ADCSEL_MASK);\n\t\treturn RC_PENUP;\n\t}\n\n\tif (wants_pen && !(*sample & WM97XX_PEN_DOWN)) {\n\t\twm->pen_probably_down = 0;\n\t\treturn RC_PENUP;\n\t}\n\n\treturn RC_VALID;\n}\n\n \nstatic int wm9705_poll_touch(struct wm97xx *wm, struct wm97xx_data *data)\n{\n\tint rc;\n\n\trc = wm9705_poll_sample(wm, WM97XX_ADCSEL_X | WM97XX_PEN_DOWN, &data->x);\n\tif (rc != RC_VALID)\n\t\treturn rc;\n\trc = wm9705_poll_sample(wm, WM97XX_ADCSEL_Y | WM97XX_PEN_DOWN, &data->y);\n\tif (rc != RC_VALID)\n\t\treturn rc;\n\tif (pil) {\n\t\trc = wm9705_poll_sample(wm, WM97XX_ADCSEL_PRES | WM97XX_PEN_DOWN, &data->p);\n\t\tif (rc != RC_VALID)\n\t\t\treturn rc;\n\t} else\n\t\tdata->p = DEFAULT_PRESSURE;\n\n\treturn RC_VALID;\n}\n\n \nstatic int wm9705_acc_enable(struct wm97xx *wm, int enable)\n{\n\tu16 dig1, dig2;\n\tint ret = 0;\n\n\tdig1 = wm->dig[1];\n\tdig2 = wm->dig[2];\n\n\tif (enable) {\n\t\t \n\t\tif (wm->mach_ops->acc_startup &&\n\t\t    (ret = wm->mach_ops->acc_startup(wm)) < 0)\n\t\t\treturn ret;\n\t\tdig1 &= ~(WM97XX_CM_RATE_MASK | WM97XX_ADCSEL_MASK |\n\t\t\t  WM97XX_DELAY_MASK | WM97XX_SLT_MASK);\n\t\tdig1 |= WM97XX_CTC | WM97XX_COO | WM97XX_SLEN |\n\t\t\tWM97XX_DELAY(delay) |\n\t\t\tWM97XX_SLT(wm->acc_slot) |\n\t\t\tWM97XX_RATE(wm->acc_rate);\n\t\tif (pil)\n\t\t\tdig1 |= WM97XX_ADCSEL_PRES;\n\t\tdig2 |= WM9705_PDEN;\n\t} else {\n\t\tdig1 &= ~(WM97XX_CTC | WM97XX_COO | WM97XX_SLEN);\n\t\tdig2 &= ~WM9705_PDEN;\n\t\tif (wm->mach_ops->acc_shutdown)\n\t\t\twm->mach_ops->acc_shutdown(wm);\n\t}\n\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER1, dig1);\n\twm97xx_reg_write(wm, AC97_WM97XX_DIGITISER2, dig2);\n\n\treturn ret;\n}\n\nstruct wm97xx_codec_drv wm9705_codec = {\n\t.id = WM9705_ID2,\n\t.name = \"wm9705\",\n\t.poll_sample = wm9705_poll_sample,\n\t.poll_touch = wm9705_poll_touch,\n\t.acc_enable = wm9705_acc_enable,\n\t.phy_init = wm9705_phy_init,\n\t.dig_enable = wm9705_dig_enable,\n\t.dig_restore = wm9705_dig_restore,\n\t.aux_prepare = wm9705_aux_prepare,\n};\nEXPORT_SYMBOL_GPL(wm9705_codec);\n\n \nMODULE_AUTHOR(\"Liam Girdwood <lrg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"WM9705 Touch Screen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}