{
  "module_name": "cy8ctma140.c",
  "hash_id": "fb7dbd2f58fbb9b43676cba666c55e4efa31363d53af9f090db7712e7cd9db71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cy8ctma140.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/input/mt.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/regulator/consumer.h>\n#include <linux/delay.h>\n\n#define CY8CTMA140_NAME\t\t\t\"cy8ctma140\"\n\n#define CY8CTMA140_MAX_FINGERS\t\t4\n\n#define CY8CTMA140_GET_FINGERS\t\t0x00\n#define CY8CTMA140_GET_FW_INFO\t\t0x19\n\n \n#define CY8CTMA140_PACKET_SIZE\t\t31\n\n#define CY8CTMA140_INVALID_BUFFER_BIT\t5\n\nstruct cy8ctma140 {\n\tstruct input_dev *input;\n\tstruct touchscreen_properties props;\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tstruct regulator_bulk_data regulators[2];\n\tu8 prev_fingers;\n\tu8 prev_f1id;\n\tu8 prev_f2id;\n};\n\nstatic void cy8ctma140_report(struct cy8ctma140 *ts, u8 *data, int n_fingers)\n{\n\tstatic const u8 contact_offsets[] = { 0x03, 0x09, 0x10, 0x16 };\n\tu8 *buf;\n\tu16 x, y;\n\tu8 w;\n\tu8 id;\n\tint slot;\n\tint i;\n\n\tfor (i = 0; i < n_fingers; i++) {\n\t\tbuf = &data[contact_offsets[i]];\n\n\t\t \n\t\tid = i % 2 ? buf[-1] & 0x0f : buf[5] >> 4;\n\t\tslot = input_mt_get_slot_by_key(ts->input, id);\n\t\tif (slot < 0)\n\t\t\tcontinue;\n\n\t\tx = get_unaligned_be16(buf);\n\t\ty = get_unaligned_be16(buf + 2);\n\t\tw = buf[4];\n\n\t\tdev_dbg(ts->dev, \"finger %d: ID %02x (%d, %d) w: %d\\n\",\n\t\t\tslot, id, x, y, w);\n\n\t\tinput_mt_slot(ts->input, slot);\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\n\t\ttouchscreen_report_pos(ts->input, &ts->props, x, y, true);\n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, w);\n\t}\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n}\n\nstatic irqreturn_t cy8ctma140_irq_thread(int irq, void *d)\n{\n\tstruct cy8ctma140 *ts = d;\n\tu8 cmdbuf[] = { CY8CTMA140_GET_FINGERS };\n\tu8 buf[CY8CTMA140_PACKET_SIZE];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(cmdbuf),\n\t\t\t.buf = cmdbuf,\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(buf),\n\t\t\t.buf = buf,\n\t\t},\n\t};\n\tu8 n_fingers;\n\tint ret;\n\n\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tif (ret < 0)\n\t\t\tdev_err(ts->dev, \"error reading message: %d\\n\", ret);\n\t\telse\n\t\t\tdev_err(ts->dev, \"wrong number of messages\\n\");\n\t\tgoto out;\n\t}\n\n\tif (buf[1] & BIT(CY8CTMA140_INVALID_BUFFER_BIT)) {\n\t\tdev_dbg(ts->dev, \"invalid event\\n\");\n\t\tgoto out;\n\t}\n\n\tn_fingers = buf[2] & 0x0f;\n\tif (n_fingers > CY8CTMA140_MAX_FINGERS) {\n\t\tdev_err(ts->dev, \"unexpected number of fingers: %d\\n\",\n\t\t\tn_fingers);\n\t\tgoto out;\n\t}\n\n\tcy8ctma140_report(ts, buf, n_fingers);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int cy8ctma140_init(struct cy8ctma140 *ts)\n{\n\tu8 addr[1];\n\tu8 buf[5];\n\tint ret;\n\n\taddr[0] = CY8CTMA140_GET_FW_INFO;\n\tret = i2c_master_send(ts->client, addr, 1);\n\tif (ret < 0) {\n\t\tdev_err(ts->dev, \"error sending FW info message\\n\");\n\t\treturn ret;\n\t}\n\tret = i2c_master_recv(ts->client, buf, 5);\n\tif (ret < 0) {\n\t\tdev_err(ts->dev, \"error receiving FW info message\\n\");\n\t\treturn ret;\n\t}\n\tif (ret != 5) {\n\t\tdev_err(ts->dev, \"got only %d bytes\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(ts->dev, \"vendor %c%c, HW ID %.2d, FW ver %.4d\\n\",\n\t\tbuf[0], buf[1], buf[3], buf[4]);\n\n\treturn 0;\n}\n\nstatic int cy8ctma140_power_up(struct cy8ctma140 *ts)\n{\n\tint error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(ts->regulators),\n\t\t\t\t      ts->regulators);\n\tif (error) {\n\t\tdev_err(ts->dev, \"failed to enable regulators\\n\");\n\t\treturn error;\n\t}\n\n\tmsleep(250);\n\n\treturn 0;\n}\n\nstatic void cy8ctma140_power_down(struct cy8ctma140 *ts)\n{\n\tregulator_bulk_disable(ARRAY_SIZE(ts->regulators),\n\t\t\t       ts->regulators);\n}\n\n \nstatic void cy8ctma140_power_off_action(void *d)\n{\n\tstruct cy8ctma140 *ts = d;\n\n\tcy8ctma140_power_down(ts);\n}\n\nstatic int cy8ctma140_probe(struct i2c_client *client)\n{\n\tstruct cy8ctma140 *ts;\n\tstruct input_dev *input;\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tts->dev = dev;\n\tts->client = client;\n\tts->input = input;\n\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_Y);\n\t \n\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\t \n\ttouchscreen_parse_properties(input, true, &ts->props);\n\tinput_abs_set_fuzz(input, ABS_MT_POSITION_X, 0);\n\tinput_abs_set_fuzz(input, ABS_MT_POSITION_Y, 0);\n\n\terror = input_mt_init_slots(input, CY8CTMA140_MAX_FINGERS,\n\t\t\t\t  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error)\n\t\treturn error;\n\n\tinput->name = CY8CTMA140_NAME;\n\tinput->id.bustype = BUS_I2C;\n\tinput_set_drvdata(input, ts);\n\n\t \n\tts->regulators[0].supply = \"vcpin\";\n\tts->regulators[1].supply = \"vdd\";\n\terror = devm_regulator_bulk_get(dev, ARRAY_SIZE(ts->regulators),\n\t\t\t\t      ts->regulators);\n\tif (error)\n\t\treturn dev_err_probe(dev, error, \"Failed to get regulators\\n\");\n\n\terror = cy8ctma140_power_up(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(dev, cy8ctma140_power_off_action, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to install power off handler\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, cy8ctma140_irq_thread,\n\t\t\t\t\t  IRQF_ONESHOT, CY8CTMA140_NAME, ts);\n\tif (error) {\n\t\tdev_err(dev, \"irq %d busy? error %d\\n\", client->irq, error);\n\t\treturn error;\n\t}\n\n\terror = cy8ctma140_init(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, ts);\n\n\treturn 0;\n}\n\nstatic int cy8ctma140_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cy8ctma140 *ts = i2c_get_clientdata(client);\n\n\tif (!device_may_wakeup(&client->dev))\n\t\tcy8ctma140_power_down(ts);\n\n\treturn 0;\n}\n\nstatic int cy8ctma140_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cy8ctma140 *ts = i2c_get_clientdata(client);\n\tint error;\n\n\tif (!device_may_wakeup(&client->dev)) {\n\t\terror = cy8ctma140_power_up(ts);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cy8ctma140_pm,\n\t\t\t\tcy8ctma140_suspend, cy8ctma140_resume);\n\nstatic const struct i2c_device_id cy8ctma140_idtable[] = {\n\t{ CY8CTMA140_NAME, 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, cy8ctma140_idtable);\n\nstatic const struct of_device_id cy8ctma140_of_match[] = {\n\t{ .compatible = \"cypress,cy8ctma140\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cy8ctma140_of_match);\n\nstatic struct i2c_driver cy8ctma140_driver = {\n\t.driver\t\t= {\n\t\t.name\t= CY8CTMA140_NAME,\n\t\t.pm\t= pm_sleep_ptr(&cy8ctma140_pm),\n\t\t.of_match_table = cy8ctma140_of_match,\n\t},\n\t.id_table\t= cy8ctma140_idtable,\n\t.probe\t\t= cy8ctma140_probe,\n};\nmodule_i2c_driver(cy8ctma140_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"CY8CTMA140 TouchScreen Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}