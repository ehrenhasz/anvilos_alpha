{
  "module_name": "hideep.c",
  "hash_id": "8d50c2b3fdfc4faddc5d1ffa64150810ff34d0213bf8a887cced5f7b9b8862d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/hideep.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/regulator/consumer.h>\n#include <asm/unaligned.h>\n\n#define HIDEEP_TS_NAME\t\t\t\"HiDeep Touchscreen\"\n#define HIDEEP_I2C_NAME\t\t\t\"hideep_ts\"\n\n#define HIDEEP_MT_MAX\t\t\t10\n#define HIDEEP_KEY_MAX\t\t\t3\n\n \n#define HIDEEP_MAX_EVENT\t\t108UL\n\n#define HIDEEP_TOUCH_EVENT_INDEX\t2\n#define HIDEEP_KEY_EVENT_INDEX\t\t102\n\n \n#define HIDEEP_EVENT_ADDR\t\t0x240\n\n \n#define HIDEEP_WORK_MODE\t\t0x081e\n#define HIDEEP_RESET_CMD\t\t0x9800\n\n \n#define HIDEEP_MT_RELEASED\t\tBIT(4)\n#define HIDEEP_KEY_PRESSED\t\tBIT(7)\n#define HIDEEP_KEY_FIRST_PRESSED\tBIT(8)\n#define HIDEEP_KEY_PRESSED_MASK\t\t(HIDEEP_KEY_PRESSED | \\\n\t\t\t\t\t HIDEEP_KEY_FIRST_PRESSED)\n\n#define HIDEEP_KEY_IDX_MASK\t\t0x0f\n\n \n#define HIDEEP_YRAM_BASE\t\t0x40000000\n#define HIDEEP_PERIPHERAL_BASE\t\t0x50000000\n#define HIDEEP_ESI_BASE\t\t\t(HIDEEP_PERIPHERAL_BASE + 0x00000000)\n#define HIDEEP_FLASH_BASE\t\t(HIDEEP_PERIPHERAL_BASE + 0x01000000)\n#define HIDEEP_SYSCON_BASE\t\t(HIDEEP_PERIPHERAL_BASE + 0x02000000)\n\n#define HIDEEP_SYSCON_MOD_CON\t\t(HIDEEP_SYSCON_BASE + 0x0000)\n#define HIDEEP_SYSCON_SPC_CON\t\t(HIDEEP_SYSCON_BASE + 0x0004)\n#define HIDEEP_SYSCON_CLK_CON\t\t(HIDEEP_SYSCON_BASE + 0x0008)\n#define HIDEEP_SYSCON_CLK_ENA\t\t(HIDEEP_SYSCON_BASE + 0x000C)\n#define HIDEEP_SYSCON_RST_CON\t\t(HIDEEP_SYSCON_BASE + 0x0010)\n#define HIDEEP_SYSCON_WDT_CON\t\t(HIDEEP_SYSCON_BASE + 0x0014)\n#define HIDEEP_SYSCON_WDT_CNT\t\t(HIDEEP_SYSCON_BASE + 0x0018)\n#define HIDEEP_SYSCON_PWR_CON\t\t(HIDEEP_SYSCON_BASE + 0x0020)\n#define HIDEEP_SYSCON_PGM_ID\t\t(HIDEEP_SYSCON_BASE + 0x00F4)\n\n#define HIDEEP_FLASH_CON\t\t(HIDEEP_FLASH_BASE + 0x0000)\n#define HIDEEP_FLASH_STA\t\t(HIDEEP_FLASH_BASE + 0x0004)\n#define HIDEEP_FLASH_CFG\t\t(HIDEEP_FLASH_BASE + 0x0008)\n#define HIDEEP_FLASH_TIM\t\t(HIDEEP_FLASH_BASE + 0x000C)\n#define HIDEEP_FLASH_CACHE_CFG\t\t(HIDEEP_FLASH_BASE + 0x0010)\n#define HIDEEP_FLASH_PIO_SIG\t\t(HIDEEP_FLASH_BASE + 0x400000)\n\n#define HIDEEP_ESI_TX_INVALID\t\t(HIDEEP_ESI_BASE + 0x0008)\n\n#define HIDEEP_PERASE\t\t\t0x00040000\n#define HIDEEP_WRONLY\t\t\t0x00100000\n\n#define HIDEEP_NVM_MASK_OFS\t\t0x0000000C\n#define HIDEEP_NVM_DEFAULT_PAGE\t\t0\n#define HIDEEP_NVM_SFR_WPAGE\t\t1\n#define HIDEEP_NVM_SFR_RPAGE\t\t2\n\n#define HIDEEP_PIO_SIG\t\t\t0x00400000\n#define HIDEEP_PROT_MODE\t\t0x03400000\n\n#define HIDEEP_NVM_PAGE_SIZE\t\t128\n\n#define HIDEEP_DWZ_INFO\t\t\t0x000002C0\n\nstruct hideep_event {\n\t__le16 x;\n\t__le16 y;\n\t__le16 z;\n\tu8 w;\n\tu8 flag;\n\tu8 type;\n\tu8 index;\n};\n\nstruct dwz_info {\n\t__be32 code_start;\n\tu8 code_crc[12];\n\n\t__be32 c_code_start;\n\t__be16 gen_ver;\n\t__be16 c_code_len;\n\n\t__be32 vr_start;\n\t__be16 rsv0;\n\t__be16 vr_len;\n\n\t__be32 ft_start;\n\t__be16 vr_version;\n\t__be16 ft_len;\n\n\t__be16 core_ver;\n\t__be16 boot_ver;\n\n\t__be16 release_ver;\n\t__be16 custom_ver;\n\n\tu8 factory_id;\n\tu8 panel_type;\n\tu8 model_name[6];\n\n\t__be16 extra_option;\n\t__be16 product_code;\n\n\t__be16 vendor_id;\n\t__be16 product_id;\n};\n\nstruct pgm_packet {\n\tstruct {\n\t\tu8 unused[3];\n\t\tu8 len;\n\t\t__be32 addr;\n\t} header;\n\t__be32 payload[HIDEEP_NVM_PAGE_SIZE / sizeof(__be32)];\n};\n\n#define HIDEEP_XFER_BUF_SIZE\tsizeof(struct pgm_packet)\n\nstruct hideep_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct regmap *reg;\n\n\tstruct touchscreen_properties prop;\n\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct regulator *vcc_vdd;\n\tstruct regulator *vcc_vid;\n\n\tstruct mutex dev_mutex;\n\n\tu32 tch_count;\n\tu32 lpm_count;\n\n\t \n\tu8 xfer_buf[HIDEEP_XFER_BUF_SIZE] __aligned(4);\n\n\tint key_num;\n\tu32 key_codes[HIDEEP_KEY_MAX];\n\n\tstruct dwz_info dwz_info;\n\n\tunsigned int fw_size;\n\tu32 nvm_mask;\n};\n\nstatic int hideep_pgm_w_mem(struct hideep_ts *ts, u32 addr,\n\t\t\t    const __be32 *data, size_t count)\n{\n\tstruct pgm_packet *packet = (void *)ts->xfer_buf;\n\tsize_t len = count * sizeof(*data);\n\tstruct i2c_msg msg = {\n\t\t.addr\t= ts->client->addr,\n\t\t.len\t= len + sizeof(packet->header.len) +\n\t\t\t\tsizeof(packet->header.addr),\n\t\t.buf\t= &packet->header.len,\n\t};\n\tint ret;\n\n\tif (len > HIDEEP_NVM_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tpacket->header.len = 0x80 | (count - 1);\n\tpacket->header.addr = cpu_to_be32(addr);\n\tmemcpy(packet->payload, data, len);\n\n\tret = i2c_transfer(ts->client->adapter, &msg, 1);\n\tif (ret != 1)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int hideep_pgm_r_mem(struct hideep_ts *ts, u32 addr,\n\t\t\t    __be32 *data, size_t count)\n{\n\tstruct pgm_packet *packet = (void *)ts->xfer_buf;\n\tsize_t len = count * sizeof(*data);\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= ts->client->addr,\n\t\t\t.len\t= sizeof(packet->header.len) +\n\t\t\t\t\tsizeof(packet->header.addr),\n\t\t\t.buf\t= &packet->header.len,\n\t\t},\n\t\t{\n\t\t\t.addr\t= ts->client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= len,\n\t\t\t.buf\t= (u8 *)data,\n\t\t},\n\t};\n\tint ret;\n\n\tif (len > HIDEEP_NVM_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tpacket->header.len = count - 1;\n\tpacket->header.addr = cpu_to_be32(addr);\n\n\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int hideep_pgm_r_reg(struct hideep_ts *ts, u32 addr, u32 *val)\n{\n\t__be32 data;\n\tint error;\n\n\terror = hideep_pgm_r_mem(ts, addr, &data, 1);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"read of register %#08x failed: %d\\n\",\n\t\t\taddr, error);\n\t\treturn error;\n\t}\n\n\t*val = be32_to_cpu(data);\n\treturn 0;\n}\n\nstatic int hideep_pgm_w_reg(struct hideep_ts *ts, u32 addr, u32 val)\n{\n\t__be32 data = cpu_to_be32(val);\n\tint error;\n\n\terror = hideep_pgm_w_mem(ts, addr, &data, 1);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"write to register %#08x (%#08x) failed: %d\\n\",\n\t\t\taddr, val, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n#define SW_RESET_IN_PGM(clk)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t__be32 data = cpu_to_be32(0x01);\t\t\t\\\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_WDT_CNT, (clk));\t\\\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_WDT_CON, 0x03);\t\\\n\t \t\t\t\t\t\t\t\\\n\thideep_pgm_w_mem(ts, HIDEEP_SYSCON_WDT_CON, &data, 1);\t\\\n}\n\n#define SET_FLASH_PIO(ce)\t\t\t\t\t\\\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CON,\t\t\t\\\n\t\t\t 0x01 | ((ce) << 1))\n\n#define SET_PIO_SIG(x, y)\t\t\t\t\t\\\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_PIO_SIG + (x), (y))\n\n#define SET_FLASH_HWCONTROL()\t\t\t\t\t\\\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CON, 0x00)\n\n#define NVM_W_SFR(x, y)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tSET_FLASH_PIO(1);\t\t\t\t\t\\\n\tSET_PIO_SIG(x, y);\t\t\t\t\t\\\n\tSET_FLASH_PIO(0);\t\t\t\t\t\\\n}\n\nstatic void hideep_pgm_set(struct hideep_ts *ts)\n{\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_WDT_CON, 0x00);\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_SPC_CON, 0x00);\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_CLK_ENA, 0xFF);\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_CLK_CON, 0x01);\n\thideep_pgm_w_reg(ts, HIDEEP_SYSCON_PWR_CON, 0x01);\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_TIM, 0x03);\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CACHE_CFG, 0x00);\n}\n\nstatic int hideep_pgm_get_pattern(struct hideep_ts *ts, u32 *pattern)\n{\n\tu16 p1 = 0xAF39;\n\tu16 p2 = 0xDF9D;\n\tint error;\n\n\terror = regmap_bulk_write(ts->reg, p1, &p2, 1);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"%s: regmap_bulk_write() failed with %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\tusleep_range(1000, 1100);\n\n\t \n\terror = hideep_pgm_w_reg(ts, HIDEEP_ESI_TX_INVALID, 0x01);\n\tif (error)\n\t\treturn error;\n\n\terror = hideep_pgm_r_reg(ts, HIDEEP_SYSCON_PGM_ID, pattern);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int hideep_enter_pgm(struct hideep_ts *ts)\n{\n\tint retry_count = 10;\n\tu32 pattern;\n\tint error;\n\n\twhile (retry_count--) {\n\t\terror = hideep_pgm_get_pattern(ts, &pattern);\n\t\tif (error) {\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"hideep_pgm_get_pattern failed: %d\\n\", error);\n\t\t} else if (pattern != 0x39AF9DDF) {\n\t\t\tdev_err(&ts->client->dev, \"%s: bad pattern: %#08x\\n\",\n\t\t\t\t__func__, pattern);\n\t\t} else {\n\t\t\tdev_dbg(&ts->client->dev, \"found magic code\");\n\n\t\t\thideep_pgm_set(ts);\n\t\t\tusleep_range(1000, 1100);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(&ts->client->dev, \"failed to  enter pgm mode\\n\");\n\tSW_RESET_IN_PGM(1000);\n\treturn -EIO;\n}\n\nstatic int hideep_nvm_unlock(struct hideep_ts *ts)\n{\n\tu32 unmask_code;\n\tint error;\n\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CFG, HIDEEP_NVM_SFR_RPAGE);\n\terror = hideep_pgm_r_reg(ts, 0x0000000C, &unmask_code);\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CFG, HIDEEP_NVM_DEFAULT_PAGE);\n\tif (error)\n\t\treturn error;\n\n\t \n\tunmask_code &= ~HIDEEP_PROT_MODE;\n\n\t \n\tif (unmask_code != ts->nvm_mask)\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"read mask code different %#08x vs %#08x\",\n\t\t\t unmask_code, ts->nvm_mask);\n\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CFG, HIDEEP_NVM_SFR_WPAGE);\n\tSET_FLASH_PIO(0);\n\n\tNVM_W_SFR(HIDEEP_NVM_MASK_OFS, ts->nvm_mask);\n\tSET_FLASH_HWCONTROL();\n\thideep_pgm_w_reg(ts, HIDEEP_FLASH_CFG, HIDEEP_NVM_DEFAULT_PAGE);\n\n\treturn 0;\n}\n\nstatic int hideep_check_status(struct hideep_ts *ts)\n{\n\tint time_out = 100;\n\tint status;\n\tint error;\n\n\twhile (time_out--) {\n\t\terror = hideep_pgm_r_reg(ts, HIDEEP_FLASH_STA, &status);\n\t\tif (!error && status)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int hideep_program_page(struct hideep_ts *ts, u32 addr,\n\t\t\t       const __be32 *ucode, size_t xfer_count)\n{\n\tu32 val;\n\tint error;\n\n\terror = hideep_check_status(ts);\n\tif (error)\n\t\treturn -EBUSY;\n\n\taddr &= ~(HIDEEP_NVM_PAGE_SIZE - 1);\n\n\tSET_FLASH_PIO(0);\n\tSET_FLASH_PIO(1);\n\n\t \n\tSET_PIO_SIG(HIDEEP_PERASE | addr, 0xFFFFFFFF);\n\n\tSET_FLASH_PIO(0);\n\n\terror = hideep_check_status(ts);\n\tif (error)\n\t\treturn -EBUSY;\n\n\t \n\tSET_FLASH_PIO(1);\n\n\tval = be32_to_cpu(ucode[0]);\n\tSET_PIO_SIG(HIDEEP_WRONLY | addr, val);\n\n\thideep_pgm_w_mem(ts, HIDEEP_FLASH_PIO_SIG | HIDEEP_WRONLY,\n\t\t\t ucode, xfer_count);\n\n\tval = be32_to_cpu(ucode[xfer_count - 1]);\n\tSET_PIO_SIG(124, val);\n\n\tSET_FLASH_PIO(0);\n\n\tusleep_range(1000, 1100);\n\n\terror = hideep_check_status(ts);\n\tif (error)\n\t\treturn -EBUSY;\n\n\tSET_FLASH_HWCONTROL();\n\n\treturn 0;\n}\n\nstatic int hideep_program_nvm(struct hideep_ts *ts,\n\t\t\t      const __be32 *ucode, size_t ucode_len)\n{\n\tstruct pgm_packet *packet_r = (void *)ts->xfer_buf;\n\t__be32 *current_ucode = packet_r->payload;\n\tsize_t xfer_len;\n\tsize_t xfer_count;\n\tu32 addr = 0;\n\tint error;\n\n\terror = hideep_nvm_unlock(ts);\n\tif (error)\n\t\treturn error;\n\n\twhile (ucode_len > 0) {\n\t\txfer_len = min_t(size_t, ucode_len, HIDEEP_NVM_PAGE_SIZE);\n\t\txfer_count = xfer_len / sizeof(*ucode);\n\n\t\terror = hideep_pgm_r_mem(ts, 0x00000000 + addr,\n\t\t\t\t\t current_ucode, xfer_count);\n\t\tif (error) {\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"%s: failed to read page at offset %#08x: %d\\n\",\n\t\t\t\t__func__, addr, error);\n\t\t\treturn error;\n\t\t}\n\n\t\t \n\t\tif (memcmp(ucode, current_ucode, xfer_len)) {\n\t\t\terror = hideep_program_page(ts, addr,\n\t\t\t\t\t\t    ucode, xfer_count);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\t\"%s: iwrite failure @%#08x: %d\\n\",\n\t\t\t\t\t__func__, addr, error);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tusleep_range(1000, 1100);\n\t\t}\n\n\t\tucode += xfer_count;\n\t\taddr += xfer_len;\n\t\tucode_len -= xfer_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int hideep_verify_nvm(struct hideep_ts *ts,\n\t\t\t     const __be32 *ucode, size_t ucode_len)\n{\n\tstruct pgm_packet *packet_r = (void *)ts->xfer_buf;\n\t__be32 *current_ucode = packet_r->payload;\n\tsize_t xfer_len;\n\tsize_t xfer_count;\n\tu32 addr = 0;\n\tint i;\n\tint error;\n\n\twhile (ucode_len > 0) {\n\t\txfer_len = min_t(size_t, ucode_len, HIDEEP_NVM_PAGE_SIZE);\n\t\txfer_count = xfer_len / sizeof(*ucode);\n\n\t\terror = hideep_pgm_r_mem(ts, 0x00000000 + addr,\n\t\t\t\t\t current_ucode, xfer_count);\n\t\tif (error) {\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"%s: failed to read page at offset %#08x: %d\\n\",\n\t\t\t\t__func__, addr, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (memcmp(ucode, current_ucode, xfer_len)) {\n\t\t\tconst u8 *ucode_bytes = (const u8 *)ucode;\n\t\t\tconst u8 *current_bytes = (const u8 *)current_ucode;\n\n\t\t\tfor (i = 0; i < xfer_len; i++)\n\t\t\t\tif (ucode_bytes[i] != current_bytes[i])\n\t\t\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\t\t\"%s: mismatch @%#08x: (%#02x vs %#02x)\\n\",\n\t\t\t\t\t\t__func__, addr + i,\n\t\t\t\t\t\tucode_bytes[i],\n\t\t\t\t\t\tcurrent_bytes[i]);\n\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tucode += xfer_count;\n\t\taddr += xfer_len;\n\t\tucode_len -= xfer_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int hideep_load_dwz(struct hideep_ts *ts)\n{\n\tu16 product_code;\n\tint error;\n\n\terror = hideep_enter_pgm(ts);\n\tif (error)\n\t\treturn error;\n\n\tmsleep(50);\n\n\terror = hideep_pgm_r_mem(ts, HIDEEP_DWZ_INFO,\n\t\t\t\t (void *)&ts->dwz_info,\n\t\t\t\t sizeof(ts->dwz_info) / sizeof(__be32));\n\n\tSW_RESET_IN_PGM(10);\n\tmsleep(50);\n\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to fetch DWZ data: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tproduct_code = be16_to_cpu(ts->dwz_info.product_code);\n\n\tswitch (product_code & 0xF0) {\n\tcase 0x40:\n\t\tdev_dbg(&ts->client->dev, \"used crimson IC\");\n\t\tts->fw_size = 1024 * 48;\n\t\tts->nvm_mask = 0x00310000;\n\t\tbreak;\n\tcase 0x60:\n\t\tdev_dbg(&ts->client->dev, \"used lime IC\");\n\t\tts->fw_size = 1024 * 64;\n\t\tts->nvm_mask = 0x0030027B;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ts->client->dev, \"product code is wrong: %#04x\",\n\t\t\tproduct_code);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&ts->client->dev, \"firmware release version: %#04x\",\n\t\tbe16_to_cpu(ts->dwz_info.release_ver));\n\n\treturn 0;\n}\n\nstatic int hideep_flash_firmware(struct hideep_ts *ts,\n\t\t\t\t const __be32 *ucode, size_t ucode_len)\n{\n\tint retry_cnt = 3;\n\tint error;\n\n\twhile (retry_cnt--) {\n\t\terror = hideep_program_nvm(ts, ucode, ucode_len);\n\t\tif (!error) {\n\t\t\terror = hideep_verify_nvm(ts, ucode, ucode_len);\n\t\t\tif (!error)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn error;\n}\n\nstatic int hideep_update_firmware(struct hideep_ts *ts,\n\t\t\t\t  const __be32 *ucode, size_t ucode_len)\n{\n\tint error, error2;\n\n\tdev_dbg(&ts->client->dev, \"starting firmware update\");\n\n\t \n\terror = hideep_enter_pgm(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = hideep_flash_firmware(ts, ucode, ucode_len);\n\tif (error)\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"firmware update failed: %d\\n\", error);\n\telse\n\t\tdev_dbg(&ts->client->dev, \"firmware updated successfully\\n\");\n\n\tSW_RESET_IN_PGM(1000);\n\n\terror2 = hideep_load_dwz(ts);\n\tif (error2)\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to load dwz after firmware update: %d\\n\",\n\t\t\terror2);\n\n\treturn error ?: error2;\n}\n\nstatic int hideep_power_on(struct hideep_ts *ts)\n{\n\tint error = 0;\n\n\terror = regulator_enable(ts->vcc_vdd);\n\tif (error)\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to enable 'vdd' regulator: %d\", error);\n\n\tusleep_range(999, 1000);\n\n\terror = regulator_enable(ts->vcc_vid);\n\tif (error)\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to enable 'vcc_vid' regulator: %d\",\n\t\t\terror);\n\n\tmsleep(30);\n\n\tif (ts->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 0);\n\t} else {\n\t\terror = regmap_write(ts->reg, HIDEEP_RESET_CMD, 0x01);\n\t\tif (error)\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"failed to send 'reset' command: %d\\n\", error);\n\t}\n\n\tmsleep(50);\n\n\treturn error;\n}\n\nstatic void hideep_power_off(void *data)\n{\n\tstruct hideep_ts *ts = data;\n\n\tif (ts->reset_gpio)\n\t\tgpiod_set_value(ts->reset_gpio, 1);\n\n\tregulator_disable(ts->vcc_vid);\n\tregulator_disable(ts->vcc_vdd);\n}\n\n#define __GET_MT_TOOL_TYPE(type) ((type) == 0x01 ? MT_TOOL_FINGER : MT_TOOL_PEN)\n\nstatic void hideep_report_slot(struct input_dev *input,\n\t\t\t       const struct hideep_event *event)\n{\n\tinput_mt_slot(input, event->index & 0x0f);\n\tinput_mt_report_slot_state(input,\n\t\t\t\t   __GET_MT_TOOL_TYPE(event->type),\n\t\t\t\t   !(event->flag & HIDEEP_MT_RELEASED));\n\tif (!(event->flag & HIDEEP_MT_RELEASED)) {\n\t\tinput_report_abs(input, ABS_MT_POSITION_X,\n\t\t\t\t le16_to_cpup(&event->x));\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y,\n\t\t\t\t le16_to_cpup(&event->y));\n\t\tinput_report_abs(input, ABS_MT_PRESSURE,\n\t\t\t\t le16_to_cpup(&event->z));\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, event->w);\n\t}\n}\n\nstatic void hideep_parse_and_report(struct hideep_ts *ts)\n{\n\tconst struct hideep_event *events =\n\t\t\t(void *)&ts->xfer_buf[HIDEEP_TOUCH_EVENT_INDEX];\n\tconst u8 *keys = &ts->xfer_buf[HIDEEP_KEY_EVENT_INDEX];\n\tint touch_count = ts->xfer_buf[0];\n\tint key_count = ts->xfer_buf[1] & 0x0f;\n\tint lpm_count = ts->xfer_buf[1] & 0xf0;\n\tint i;\n\n\t \n\tdev_dbg(&ts->client->dev, \"mt = %d, key = %d, lpm = %02x\",\n\t\ttouch_count, key_count, lpm_count);\n\n\ttouch_count = min(touch_count, HIDEEP_MT_MAX);\n\tfor (i = 0; i < touch_count; i++)\n\t\thideep_report_slot(ts->input_dev, events + i);\n\n\tkey_count = min(key_count, HIDEEP_KEY_MAX);\n\tfor (i = 0; i < key_count; i++) {\n\t\tu8 key_data = keys[i * 2];\n\n\t\tinput_report_key(ts->input_dev,\n\t\t\t\t ts->key_codes[key_data & HIDEEP_KEY_IDX_MASK],\n\t\t\t\t key_data & HIDEEP_KEY_PRESSED_MASK);\n\t}\n\n\tinput_mt_sync_frame(ts->input_dev);\n\tinput_sync(ts->input_dev);\n}\n\nstatic irqreturn_t hideep_irq(int irq, void *handle)\n{\n\tstruct hideep_ts *ts = handle;\n\tint error;\n\n\tBUILD_BUG_ON(HIDEEP_MAX_EVENT > HIDEEP_XFER_BUF_SIZE);\n\n\terror = regmap_bulk_read(ts->reg, HIDEEP_EVENT_ADDR,\n\t\t\t\t ts->xfer_buf, HIDEEP_MAX_EVENT / 2);\n\tif (error) {\n\t\tdev_err(&ts->client->dev, \"failed to read events: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\thideep_parse_and_report(ts);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int hideep_get_axis_info(struct hideep_ts *ts)\n{\n\t__le16 val[2];\n\tint error;\n\n\terror = regmap_bulk_read(ts->reg, 0x28, val, ARRAY_SIZE(val));\n\tif (error)\n\t\treturn error;\n\n\tts->prop.max_x = le16_to_cpup(val);\n\tts->prop.max_y = le16_to_cpup(val + 1);\n\n\tdev_dbg(&ts->client->dev, \"X: %d, Y: %d\",\n\t\tts->prop.max_x, ts->prop.max_y);\n\n\treturn 0;\n}\n\nstatic int hideep_init_input(struct hideep_ts *ts)\n{\n\tstruct device *dev = &ts->client->dev;\n\tint i;\n\tint error;\n\n\tts->input_dev = devm_input_allocate_device(dev);\n\tif (!ts->input_dev) {\n\t\tdev_err(dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->input_dev->name = HIDEEP_TS_NAME;\n\tts->input_dev->id.bustype = BUS_I2C;\n\tinput_set_drvdata(ts->input_dev, ts);\n\n\tinput_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, 65535, 0, 0);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_TOOL_TYPE,\n\t\t\t     0, MT_TOOL_MAX, 0, 0);\n\ttouchscreen_parse_properties(ts->input_dev, true, &ts->prop);\n\n\tif (ts->prop.max_x == 0 || ts->prop.max_y == 0) {\n\t\terror = hideep_get_axis_info(ts);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = input_mt_init_slots(ts->input_dev, HIDEEP_MT_MAX,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error)\n\t\treturn error;\n\n\tts->key_num = device_property_count_u32(dev, \"linux,keycodes\");\n\tif (ts->key_num > HIDEEP_KEY_MAX) {\n\t\tdev_err(dev, \"too many keys defined: %d\\n\",\n\t\t\tts->key_num);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ts->key_num <= 0) {\n\t\tdev_dbg(dev,\n\t\t\t\"missing or malformed 'linux,keycodes' property\\n\");\n\t} else {\n\t\terror = device_property_read_u32_array(dev, \"linux,keycodes\",\n\t\t\t\t\t\t       ts->key_codes,\n\t\t\t\t\t\t       ts->key_num);\n\t\tif (error) {\n\t\t\tdev_dbg(dev, \"failed to read keymap: %d\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (ts->key_num) {\n\t\t\tts->input_dev->keycode = ts->key_codes;\n\t\t\tts->input_dev->keycodesize = sizeof(ts->key_codes[0]);\n\t\t\tts->input_dev->keycodemax = ts->key_num;\n\n\t\t\tfor (i = 0; i < ts->key_num; i++)\n\t\t\t\tinput_set_capability(ts->input_dev, EV_KEY,\n\t\t\t\t\tts->key_codes[i]);\n\t\t}\n\t}\n\n\terror = input_register_device(ts->input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t hideep_update_fw(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hideep_ts *ts = i2c_get_clientdata(client);\n\tconst struct firmware *fw_entry;\n\tchar *fw_name;\n\tint mode;\n\tint error;\n\n\terror = kstrtoint(buf, 0, &mode);\n\tif (error)\n\t\treturn error;\n\n\tfw_name = kasprintf(GFP_KERNEL, \"hideep_ts_%04x.bin\",\n\t\t\t    be16_to_cpu(ts->dwz_info.product_id));\n\tif (!fw_name)\n\t\treturn -ENOMEM;\n\n\terror = request_firmware(&fw_entry, fw_name, dev);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request firmware %s: %d\",\n\t\t\tfw_name, error);\n\t\tgoto out_free_fw_name;\n\t}\n\n\tif (fw_entry->size % sizeof(__be32)) {\n\t\tdev_err(dev, \"invalid firmware size %zu\\n\", fw_entry->size);\n\t\terror = -EINVAL;\n\t\tgoto out_release_fw;\n\t}\n\n\tif (fw_entry->size > ts->fw_size) {\n\t\tdev_err(dev, \"fw size (%zu) is too big (memory size %d)\\n\",\n\t\t\tfw_entry->size, ts->fw_size);\n\t\terror = -EFBIG;\n\t\tgoto out_release_fw;\n\t}\n\n\tmutex_lock(&ts->dev_mutex);\n\tdisable_irq(client->irq);\n\n\terror = hideep_update_firmware(ts, (const __be32 *)fw_entry->data,\n\t\t\t\t       fw_entry->size);\n\n\tenable_irq(client->irq);\n\tmutex_unlock(&ts->dev_mutex);\n\nout_release_fw:\n\trelease_firmware(fw_entry);\nout_free_fw_name:\n\tkfree(fw_name);\n\n\treturn error ?: count;\n}\n\nstatic ssize_t hideep_fw_version_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hideep_ts *ts = i2c_get_clientdata(client);\n\tssize_t len;\n\n\tmutex_lock(&ts->dev_mutex);\n\tlen = scnprintf(buf, PAGE_SIZE, \"%04x\\n\",\n\t\t\tbe16_to_cpu(ts->dwz_info.release_ver));\n\tmutex_unlock(&ts->dev_mutex);\n\n\treturn len;\n}\n\nstatic ssize_t hideep_product_id_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hideep_ts *ts = i2c_get_clientdata(client);\n\tssize_t len;\n\n\tmutex_lock(&ts->dev_mutex);\n\tlen = scnprintf(buf, PAGE_SIZE, \"%04x\\n\",\n\t\t\tbe16_to_cpu(ts->dwz_info.product_id));\n\tmutex_unlock(&ts->dev_mutex);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(version, 0664, hideep_fw_version_show, NULL);\nstatic DEVICE_ATTR(product_id, 0664, hideep_product_id_show, NULL);\nstatic DEVICE_ATTR(update_fw, 0664, NULL, hideep_update_fw);\n\nstatic struct attribute *hideep_ts_sysfs_entries[] = {\n\t&dev_attr_version.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_update_fw.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hideep_ts_attr_group = {\n\t.attrs = hideep_ts_sysfs_entries,\n};\n\nstatic void hideep_set_work_mode(struct hideep_ts *ts)\n{\n\t \n\tif (device_property_read_bool(&ts->client->dev, \"hideep,force-native-protocol\"))\n\t\tregmap_write(ts->reg, HIDEEP_WORK_MODE, 0x00);\n}\n\nstatic int hideep_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hideep_ts *ts = i2c_get_clientdata(client);\n\n\tdisable_irq(client->irq);\n\thideep_power_off(ts);\n\n\treturn 0;\n}\n\nstatic int hideep_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hideep_ts *ts = i2c_get_clientdata(client);\n\tint error;\n\n\terror = hideep_power_on(ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"power on failed\");\n\t\treturn error;\n\t}\n\n\thideep_set_work_mode(ts);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(hideep_pm_ops, hideep_suspend, hideep_resume);\n\nstatic const struct regmap_config hideep_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_bits = 16,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.max_register = 0xffff,\n};\n\nstatic int hideep_probe(struct i2c_client *client)\n{\n\tstruct hideep_ts *ts;\n\tint error;\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"check i2c device error\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (client->irq <= 0) {\n\t\tdev_err(&client->dev, \"missing irq: %d\\n\", client->irq);\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\ti2c_set_clientdata(client, ts);\n\tmutex_init(&ts->dev_mutex);\n\n\tts->reg = devm_regmap_init_i2c(client, &hideep_regmap_config);\n\tif (IS_ERR(ts->reg)) {\n\t\terror = PTR_ERR(ts->reg);\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to initialize regmap: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->vcc_vdd = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(ts->vcc_vdd))\n\t\treturn PTR_ERR(ts->vcc_vdd);\n\n\tts->vcc_vid = devm_regulator_get(&client->dev, \"vid\");\n\tif (IS_ERR(ts->vcc_vid))\n\t\treturn PTR_ERR(ts->vcc_vid);\n\n\tts->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->reset_gpio))\n\t\treturn PTR_ERR(ts->reset_gpio);\n\n\terror = hideep_power_on(ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"power on failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev, hideep_power_off, ts);\n\tif (error)\n\t\treturn error;\n\n\terror = hideep_load_dwz(ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to load dwz: %d\", error);\n\t\treturn error;\n\t}\n\n\thideep_set_work_mode(ts);\n\n\terror = hideep_init_input(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, hideep_irq, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to request irq %d: %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &hideep_ts_attr_group);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to add sysfs attributes: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id hideep_i2c_id[] = {\n\t{ HIDEEP_I2C_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, hideep_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id hideep_acpi_id[] = {\n\t{ \"HIDP0001\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, hideep_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id hideep_match_table[] = {\n\t{ .compatible = \"hideep,hideep-ts\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hideep_match_table);\n#endif\n\nstatic struct i2c_driver hideep_driver = {\n\t.driver = {\n\t\t.name\t\t\t= HIDEEP_I2C_NAME,\n\t\t.of_match_table\t\t= of_match_ptr(hideep_match_table),\n\t\t.acpi_match_table\t= ACPI_PTR(hideep_acpi_id),\n\t\t.pm\t\t\t= pm_sleep_ptr(&hideep_pm_ops),\n\t},\n\t.id_table\t= hideep_i2c_id,\n\t.probe\t\t= hideep_probe,\n};\n\nmodule_i2c_driver(hideep_driver);\n\nMODULE_DESCRIPTION(\"Driver for HiDeep Touchscreen Controller\");\nMODULE_AUTHOR(\"anthony.kim@hideep.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}