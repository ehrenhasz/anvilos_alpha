{
  "module_name": "cyttsp_core.c",
  "hash_id": "3d2b0cfe66b8ff32789dbdae29c4b508efd48ab57fc9c5bb887020016fc3a2cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cyttsp_core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/property.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include \"cyttsp_core.h\"\n\n \n#define CY_NUM_BL_KEYS\t\t8\n\n \n#define GET_NUM_TOUCHES(x)\t\t((x) & 0x0F)\n#define IS_LARGE_AREA(x)\t\t(((x) & 0x10) >> 4)\n#define IS_BAD_PKT(x)\t\t\t((x) & 0x20)\n#define IS_VALID_APP(x)\t\t\t((x) & 0x01)\n#define IS_OPERATIONAL_ERR(x)\t\t((x) & 0x3F)\n#define GET_HSTMODE(reg)\t\t(((reg) & 0x70) >> 4)\n#define GET_BOOTLOADERMODE(reg)\t\t(((reg) & 0x10) >> 4)\n\n#define CY_REG_BASE\t\t\t0x00\n#define CY_REG_ACT_DIST\t\t\t0x1E\n#define CY_REG_ACT_INTRVL\t\t0x1D\n#define CY_REG_TCH_TMOUT\t\t(CY_REG_ACT_INTRVL + 1)\n#define CY_REG_LP_INTRVL\t\t(CY_REG_TCH_TMOUT + 1)\n#define CY_MAXZ\t\t\t\t255\n#define CY_DELAY_DFLT\t\t\t20  \n#define CY_DELAY_MAX\t\t\t500\n \n#define CY_ACT_DIST_DFLT\t\t0xF8  \n#define CY_ACT_DIST_MASK\t\t0x0F\n \n#define CY_ACT_INTRVL_DFLT\t\t0x00  \n \n#define CY_LP_INTRVL_DFLT\t\t0x0A  \n \n#define CY_TCH_TMOUT_DFLT\t\t0xFF  \n#define CY_HNDSHK_BIT\t\t\t0x80\n \n#define CY_OPERATE_MODE\t\t\t0x00\n#define CY_SYSINFO_MODE\t\t\t0x10\n \n#define CY_SOFT_RESET_MODE\t\t0x01  \n#define CY_DEEP_SLEEP_MODE\t\t0x02\n#define CY_LOW_POWER_MODE\t\t0x04\n\n \n#define CY_MAX_FINGER\t\t\t4\n#define CY_MAX_ID\t\t\t16\n\nstatic const u8 bl_command[] = {\n\t0x00,\t\t\t \n\t0xFF,\t\t\t \n\t0xA5,\t\t\t \n\t0, 1, 2, 3, 4, 5, 6, 7\t \n};\n\nstatic int ttsp_read_block_data(struct cyttsp *ts, u8 command,\n\t\t\t\tu8 length, void *buf)\n{\n\tint error;\n\tint tries;\n\n\tfor (tries = 0; tries < CY_NUM_RETRY; tries++) {\n\t\terror = ts->bus_ops->read(ts->dev, ts->xfer_buf, command,\n\t\t\t\tlength, buf);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\tmsleep(CY_DELAY_DFLT);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int ttsp_write_block_data(struct cyttsp *ts, u8 command,\n\t\t\t\t u8 length, void *buf)\n{\n\tint error;\n\tint tries;\n\n\tfor (tries = 0; tries < CY_NUM_RETRY; tries++) {\n\t\terror = ts->bus_ops->write(ts->dev, ts->xfer_buf, command,\n\t\t\t\tlength, buf);\n\t\tif (!error)\n\t\t\treturn 0;\n\n\t\tmsleep(CY_DELAY_DFLT);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int ttsp_send_command(struct cyttsp *ts, u8 cmd)\n{\n\treturn ttsp_write_block_data(ts, CY_REG_BASE, sizeof(cmd), &cmd);\n}\n\nstatic int cyttsp_handshake(struct cyttsp *ts)\n{\n\tif (ts->use_hndshk)\n\t\treturn ttsp_send_command(ts,\n\t\t\t\tts->xy_data.hst_mode ^ CY_HNDSHK_BIT);\n\n\treturn 0;\n}\n\nstatic int cyttsp_load_bl_regs(struct cyttsp *ts)\n{\n\tmemset(&ts->bl_data, 0, sizeof(ts->bl_data));\n\tts->bl_data.bl_status = 0x10;\n\n\treturn ttsp_read_block_data(ts, CY_REG_BASE,\n\t\t\t\t    sizeof(ts->bl_data), &ts->bl_data);\n}\n\nstatic int cyttsp_exit_bl_mode(struct cyttsp *ts)\n{\n\tint error;\n\tu8 bl_cmd[sizeof(bl_command)];\n\n\tmemcpy(bl_cmd, bl_command, sizeof(bl_command));\n\tif (ts->bl_keys)\n\t\tmemcpy(&bl_cmd[sizeof(bl_command) - CY_NUM_BL_KEYS],\n\t\t\tts->bl_keys, CY_NUM_BL_KEYS);\n\n\terror = ttsp_write_block_data(ts, CY_REG_BASE,\n\t\t\t\t      sizeof(bl_cmd), bl_cmd);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(CY_DELAY_DFLT);\n\n\terror = cyttsp_load_bl_regs(ts);\n\tif (error)\n\t\treturn error;\n\n\tif (GET_BOOTLOADERMODE(ts->bl_data.bl_status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int cyttsp_set_operational_mode(struct cyttsp *ts)\n{\n\tint error;\n\n\terror = ttsp_send_command(ts, CY_OPERATE_MODE);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = ttsp_read_block_data(ts, CY_REG_BASE,\n\t\t\t\t     sizeof(ts->xy_data), &ts->xy_data);\n\tif (error)\n\t\treturn error;\n\n\terror = cyttsp_handshake(ts);\n\tif (error)\n\t\treturn error;\n\n\treturn ts->xy_data.act_dist == CY_ACT_DIST_DFLT ? -EIO : 0;\n}\n\nstatic int cyttsp_set_sysinfo_mode(struct cyttsp *ts)\n{\n\tint error;\n\n\tmemset(&ts->sysinfo_data, 0, sizeof(ts->sysinfo_data));\n\n\t \n\terror = ttsp_send_command(ts, CY_SYSINFO_MODE);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsleep(CY_DELAY_DFLT);\n\terror = ttsp_read_block_data(ts, CY_REG_BASE, sizeof(ts->sysinfo_data),\n\t\t\t\t      &ts->sysinfo_data);\n\tif (error)\n\t\treturn error;\n\n\terror = cyttsp_handshake(ts);\n\tif (error)\n\t\treturn error;\n\n\tif (!ts->sysinfo_data.tts_verh && !ts->sysinfo_data.tts_verl)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int cyttsp_set_sysinfo_regs(struct cyttsp *ts)\n{\n\tint retval = 0;\n\n\tif (ts->act_intrvl != CY_ACT_INTRVL_DFLT ||\n\t    ts->tch_tmout != CY_TCH_TMOUT_DFLT ||\n\t    ts->lp_intrvl != CY_LP_INTRVL_DFLT) {\n\n\t\tu8 intrvl_ray[] = {\n\t\t\tts->act_intrvl,\n\t\t\tts->tch_tmout,\n\t\t\tts->lp_intrvl\n\t\t};\n\n\t\t \n\t\tretval = ttsp_write_block_data(ts, CY_REG_ACT_INTRVL,\n\t\t\t\t\tsizeof(intrvl_ray), intrvl_ray);\n\t\tmsleep(CY_DELAY_DFLT);\n\t}\n\n\treturn retval;\n}\n\nstatic void cyttsp_hard_reset(struct cyttsp *ts)\n{\n\tif (ts->reset_gpio) {\n\t\t \n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 1);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 0);\n\t\tusleep_range(5000, 6000);\n\t}\n}\n\nstatic int cyttsp_soft_reset(struct cyttsp *ts)\n{\n\tint retval;\n\n\t \n\treinit_completion(&ts->bl_ready);\n\tts->state = CY_BL_STATE;\n\n\tenable_irq(ts->irq);\n\n\tretval = ttsp_send_command(ts, CY_SOFT_RESET_MODE);\n\tif (retval) {\n\t\tdev_err(ts->dev, \"failed to send soft reset\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!wait_for_completion_timeout(&ts->bl_ready,\n\t\t\tmsecs_to_jiffies(CY_DELAY_DFLT * CY_DELAY_MAX))) {\n\t\tdev_err(ts->dev, \"timeout waiting for soft reset\\n\");\n\t\tretval = -EIO;\n\t}\n\nout:\n\tts->state = CY_IDLE_STATE;\n\tdisable_irq(ts->irq);\n\treturn retval;\n}\n\nstatic int cyttsp_act_dist_setup(struct cyttsp *ts)\n{\n\tu8 act_dist_setup = ts->act_dist;\n\n\t \n\treturn ttsp_write_block_data(ts, CY_REG_ACT_DIST,\n\t\t\t\tsizeof(act_dist_setup), &act_dist_setup);\n}\n\nstatic void cyttsp_extract_track_ids(struct cyttsp_xydata *xy_data, int *ids)\n{\n\tids[0] = xy_data->touch12_id >> 4;\n\tids[1] = xy_data->touch12_id & 0xF;\n\tids[2] = xy_data->touch34_id >> 4;\n\tids[3] = xy_data->touch34_id & 0xF;\n}\n\nstatic const struct cyttsp_tch *cyttsp_get_tch(struct cyttsp_xydata *xy_data,\n\t\t\t\t\t       int idx)\n{\n\tswitch (idx) {\n\tcase 0:\n\t\treturn &xy_data->tch1;\n\tcase 1:\n\t\treturn &xy_data->tch2;\n\tcase 2:\n\t\treturn &xy_data->tch3;\n\tcase 3:\n\t\treturn &xy_data->tch4;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void cyttsp_report_tchdata(struct cyttsp *ts)\n{\n\tstruct cyttsp_xydata *xy_data = &ts->xy_data;\n\tstruct input_dev *input = ts->input;\n\tint num_tch = GET_NUM_TOUCHES(xy_data->tt_stat);\n\tconst struct cyttsp_tch *tch;\n\tint ids[CY_MAX_ID];\n\tint i;\n\tDECLARE_BITMAP(used, CY_MAX_ID);\n\n\tif (IS_LARGE_AREA(xy_data->tt_stat) == 1) {\n\t\t \n\t\tnum_tch = 0;\n\t\tdev_dbg(ts->dev, \"%s: Large area detected\\n\", __func__);\n\t} else if (num_tch > CY_MAX_FINGER) {\n\t\t \n\t\tnum_tch = 0;\n\t\tdev_dbg(ts->dev, \"%s: Num touch error detected\\n\", __func__);\n\t} else if (IS_BAD_PKT(xy_data->tt_mode)) {\n\t\t \n\t\tnum_tch = 0;\n\t\tdev_dbg(ts->dev, \"%s: Invalid buffer detected\\n\", __func__);\n\t}\n\n\tcyttsp_extract_track_ids(xy_data, ids);\n\n\tbitmap_zero(used, CY_MAX_ID);\n\n\tfor (i = 0; i < num_tch; i++) {\n\t\ttch = cyttsp_get_tch(xy_data, i);\n\n\t\tinput_mt_slot(input, ids[i]);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, be16_to_cpu(tch->x));\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, be16_to_cpu(tch->y));\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, tch->z);\n\n\t\t__set_bit(ids[i], used);\n\t}\n\n\tfor (i = 0; i < CY_MAX_ID; i++) {\n\t\tif (test_bit(i, used))\n\t\t\tcontinue;\n\n\t\tinput_mt_slot(input, i);\n\t\tinput_mt_report_slot_inactive(input);\n\t}\n\n\tinput_sync(input);\n}\n\nstatic irqreturn_t cyttsp_irq(int irq, void *handle)\n{\n\tstruct cyttsp *ts = handle;\n\tint error;\n\n\tif (unlikely(ts->state == CY_BL_STATE)) {\n\t\tcomplete(&ts->bl_ready);\n\t\tgoto out;\n\t}\n\n\t \n\terror = ttsp_read_block_data(ts, CY_REG_BASE,\n\t\t\t\t sizeof(struct cyttsp_xydata), &ts->xy_data);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = cyttsp_handshake(ts);\n\tif (error)\n\t\tgoto out;\n\n\tif (unlikely(ts->state == CY_IDLE_STATE))\n\t\tgoto out;\n\n\tif (GET_BOOTLOADERMODE(ts->xy_data.tt_mode)) {\n\t\t \n\t\terror = cyttsp_exit_bl_mode(ts);\n\t\tif (error) {\n\t\t\tdev_err(ts->dev,\n\t\t\t\t\"Could not return to operational mode, err: %d\\n\",\n\t\t\t\terror);\n\t\t\tts->state = CY_IDLE_STATE;\n\t\t}\n\t} else {\n\t\tcyttsp_report_tchdata(ts);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int cyttsp_power_on(struct cyttsp *ts)\n{\n\tint error;\n\n\terror = cyttsp_soft_reset(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = cyttsp_load_bl_regs(ts);\n\tif (error)\n\t\treturn error;\n\n\tif (GET_BOOTLOADERMODE(ts->bl_data.bl_status) &&\n\t    IS_VALID_APP(ts->bl_data.bl_status)) {\n\t\terror = cyttsp_exit_bl_mode(ts);\n\t\tif (error) {\n\t\t\tdev_err(ts->dev, \"failed to exit bootloader mode\\n\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (GET_HSTMODE(ts->bl_data.bl_file) != CY_OPERATE_MODE ||\n\t    IS_OPERATIONAL_ERR(ts->bl_data.bl_status)) {\n\t\treturn -ENODEV;\n\t}\n\n\terror = cyttsp_set_sysinfo_mode(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = cyttsp_set_sysinfo_regs(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = cyttsp_set_operational_mode(ts);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = cyttsp_act_dist_setup(ts);\n\tif (error)\n\t\treturn error;\n\n\tts->state = CY_ACTIVE_STATE;\n\n\treturn 0;\n}\n\nstatic int cyttsp_enable(struct cyttsp *ts)\n{\n\tint error;\n\n\t \n\terror = ttsp_read_block_data(ts, CY_REG_BASE,\n\t\t\t\t     sizeof(ts->xy_data), &ts->xy_data);\n\tif (error)\n\t\treturn error;\n\n\tif (GET_HSTMODE(ts->xy_data.hst_mode))\n\t\treturn -EIO;\n\n\tenable_irq(ts->irq);\n\n\treturn 0;\n}\n\nstatic int cyttsp_disable(struct cyttsp *ts)\n{\n\tint error;\n\n\terror = ttsp_send_command(ts, CY_LOW_POWER_MODE);\n\tif (error)\n\t\treturn error;\n\n\tdisable_irq(ts->irq);\n\n\treturn 0;\n}\n\nstatic int cyttsp_suspend(struct device *dev)\n{\n\tstruct cyttsp *ts = dev_get_drvdata(dev);\n\tint retval = 0;\n\n\tmutex_lock(&ts->input->mutex);\n\n\tif (input_device_enabled(ts->input)) {\n\t\tretval = cyttsp_disable(ts);\n\t\tif (retval == 0)\n\t\t\tts->suspended = true;\n\t}\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn retval;\n}\n\nstatic int cyttsp_resume(struct device *dev)\n{\n\tstruct cyttsp *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->input->mutex);\n\n\tif (input_device_enabled(ts->input))\n\t\tcyttsp_enable(ts);\n\n\tts->suspended = false;\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn 0;\n}\n\nEXPORT_GPL_SIMPLE_DEV_PM_OPS(cyttsp_pm_ops, cyttsp_suspend, cyttsp_resume);\n\nstatic int cyttsp_open(struct input_dev *dev)\n{\n\tstruct cyttsp *ts = input_get_drvdata(dev);\n\tint retval = 0;\n\n\tif (!ts->suspended)\n\t\tretval = cyttsp_enable(ts);\n\n\treturn retval;\n}\n\nstatic void cyttsp_close(struct input_dev *dev)\n{\n\tstruct cyttsp *ts = input_get_drvdata(dev);\n\n\tif (!ts->suspended)\n\t\tcyttsp_disable(ts);\n}\n\nstatic int cyttsp_parse_properties(struct cyttsp *ts)\n{\n\tstruct device *dev = ts->dev;\n\tu32 dt_value;\n\tint ret;\n\n\tts->bl_keys = devm_kzalloc(dev, CY_NUM_BL_KEYS, GFP_KERNEL);\n\tif (!ts->bl_keys)\n\t\treturn -ENOMEM;\n\n\t \n\tts->use_hndshk = false;\n\tts->act_dist = CY_ACT_DIST_DFLT;\n\tts->act_intrvl = CY_ACT_INTRVL_DFLT;\n\tts->tch_tmout = CY_TCH_TMOUT_DFLT;\n\tts->lp_intrvl = CY_LP_INTRVL_DFLT;\n\n\tret = device_property_read_u8_array(dev, \"bootloader-key\",\n\t\t\t\t\t    ts->bl_keys, CY_NUM_BL_KEYS);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"bootloader-key property could not be retrieved\\n\");\n\t\treturn ret;\n\t}\n\n\tts->use_hndshk = device_property_present(dev, \"use-handshake\");\n\n\tif (!device_property_read_u32(dev, \"active-distance\", &dt_value)) {\n\t\tif (dt_value > 15) {\n\t\t\tdev_err(dev, \"active-distance (%u) must be [0-15]\\n\",\n\t\t\t\tdt_value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tts->act_dist &= ~CY_ACT_DIST_MASK;\n\t\tts->act_dist |= dt_value;\n\t}\n\n\tif (!device_property_read_u32(dev, \"active-interval-ms\", &dt_value)) {\n\t\tif (dt_value > 255) {\n\t\t\tdev_err(dev, \"active-interval-ms (%u) must be [0-255]\\n\",\n\t\t\t\tdt_value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tts->act_intrvl = dt_value;\n\t}\n\n\tif (!device_property_read_u32(dev, \"lowpower-interval-ms\", &dt_value)) {\n\t\tif (dt_value > 2550) {\n\t\t\tdev_err(dev, \"lowpower-interval-ms (%u) must be [0-2550]\\n\",\n\t\t\t\tdt_value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tts->lp_intrvl = dt_value / 10;\n\t}\n\n\tif (!device_property_read_u32(dev, \"touch-timeout-ms\", &dt_value)) {\n\t\tif (dt_value > 2550) {\n\t\t\tdev_err(dev, \"touch-timeout-ms (%u) must be [0-2550]\\n\",\n\t\t\t\tdt_value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tts->tch_tmout = dt_value / 10;\n\t}\n\n\treturn 0;\n}\n\nstatic void cyttsp_disable_regulators(void *_ts)\n{\n\tstruct cyttsp *ts = _ts;\n\n\tregulator_bulk_disable(ARRAY_SIZE(ts->regulators),\n\t\t\t       ts->regulators);\n}\n\nstruct cyttsp *cyttsp_probe(const struct cyttsp_bus_ops *bus_ops,\n\t\t\t    struct device *dev, int irq, size_t xfer_buf_size)\n{\n\tstruct cyttsp *ts;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tts = devm_kzalloc(dev, sizeof(*ts) + xfer_buf_size, GFP_KERNEL);\n\tif (!ts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tts->dev = dev;\n\tts->input = input_dev;\n\tts->bus_ops = bus_ops;\n\tts->irq = irq;\n\n\t \n\tts->regulators[0].supply = \"vcpin\";\n\tts->regulators[1].supply = \"vdd\";\n\terror = devm_regulator_bulk_get(dev, ARRAY_SIZE(ts->regulators),\n\t\t\t\t\tts->regulators);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", error);\n\t\treturn ERR_PTR(error);\n\t}\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(ts->regulators),\n\t\t\t\t      ts->regulators);\n\tif (error) {\n\t\tdev_err(dev, \"Cannot enable regulators: %d\\n\", error);\n\t\treturn ERR_PTR(error);\n\t}\n\n\terror = devm_add_action_or_reset(dev, cyttsp_disable_regulators, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to install chip disable handler\\n\");\n\t\treturn ERR_PTR(error);\n\t}\n\n\tts->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(dev, \"Failed to request reset gpio, error %d\\n\", error);\n\t\treturn ERR_PTR(error);\n\t}\n\n\terror = cyttsp_parse_properties(ts);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinit_completion(&ts->bl_ready);\n\n\tinput_dev->name = \"Cypress TTSP TouchScreen\";\n\tinput_dev->id.bustype = bus_ops->bustype;\n\tinput_dev->dev.parent = ts->dev;\n\n\tinput_dev->open = cyttsp_open;\n\tinput_dev->close = cyttsp_close;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\t \n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\n\ttouchscreen_parse_properties(input_dev, true, NULL);\n\n\terror = input_mt_init_slots(input_dev, CY_MAX_ID, INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to init MT slots.\\n\");\n\t\treturn ERR_PTR(error);\n\t}\n\n\terror = devm_request_threaded_irq(dev, ts->irq, NULL, cyttsp_irq,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  \"cyttsp\", ts);\n\tif (error) {\n\t\tdev_err(ts->dev, \"failed to request IRQ %d, err: %d\\n\",\n\t\t\tts->irq, error);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tcyttsp_hard_reset(ts);\n\n\terror = cyttsp_power_on(ts);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(ts->dev, \"failed to register input device: %d\\n\",\n\t\t\terror);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn ts;\n}\nEXPORT_SYMBOL_GPL(cyttsp_probe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cypress TrueTouch(R) Standard touchscreen driver core\");\nMODULE_AUTHOR(\"Cypress\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}