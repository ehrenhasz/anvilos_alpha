{
  "module_name": "hp680_ts_input.c",
  "hash_id": "2d35da9209a476ba0f467c3de719337abec63acb4ea928da791e9c3c3578fa59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/hp680_ts_input.c",
  "human_readable_source": "\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <asm/io.h>\n#include <asm/delay.h>\n#include <asm/adc.h>\n#include <mach/hp6xx.h>\n\n#define MODNAME \"hp680_ts_input\"\n\n#define HP680_TS_ABS_X_MIN\t40\n#define HP680_TS_ABS_X_MAX\t950\n#define HP680_TS_ABS_Y_MIN\t80\n#define HP680_TS_ABS_Y_MAX\t910\n\n#define\tPHDR\t0xa400012e\n#define SCPDR\t0xa4000136\n\nstatic void do_softint(struct work_struct *work);\n\nstatic struct input_dev *hp680_ts_dev;\nstatic DECLARE_DELAYED_WORK(work, do_softint);\n\nstatic void do_softint(struct work_struct *work)\n{\n\tint absx = 0, absy = 0;\n\tu8 scpdr;\n\tint touched = 0;\n\n\tif (__raw_readb(PHDR) & PHDR_TS_PEN_DOWN) {\n\t\tscpdr = __raw_readb(SCPDR);\n\t\tscpdr |= SCPDR_TS_SCAN_ENABLE;\n\t\tscpdr &= ~SCPDR_TS_SCAN_Y;\n\t\t__raw_writeb(scpdr, SCPDR);\n\t\tudelay(30);\n\n\t\tabsy = adc_single(ADC_CHANNEL_TS_Y);\n\n\t\tscpdr = __raw_readb(SCPDR);\n\t\tscpdr |= SCPDR_TS_SCAN_Y;\n\t\tscpdr &= ~SCPDR_TS_SCAN_X;\n\t\t__raw_writeb(scpdr, SCPDR);\n\t\tudelay(30);\n\n\t\tabsx = adc_single(ADC_CHANNEL_TS_X);\n\n\t\tscpdr = __raw_readb(SCPDR);\n\t\tscpdr |= SCPDR_TS_SCAN_X;\n\t\tscpdr &= ~SCPDR_TS_SCAN_ENABLE;\n\t\t__raw_writeb(scpdr, SCPDR);\n\t\tudelay(100);\n\t\ttouched = __raw_readb(PHDR) & PHDR_TS_PEN_DOWN;\n\t}\n\n\tif (touched) {\n\t\tinput_report_key(hp680_ts_dev, BTN_TOUCH, 1);\n\t\tinput_report_abs(hp680_ts_dev, ABS_X, absx);\n\t\tinput_report_abs(hp680_ts_dev, ABS_Y, absy);\n\t} else {\n\t\tinput_report_key(hp680_ts_dev, BTN_TOUCH, 0);\n\t}\n\n\tinput_sync(hp680_ts_dev);\n\tenable_irq(HP680_TS_IRQ);\n}\n\nstatic irqreturn_t hp680_ts_interrupt(int irq, void *dev)\n{\n\tdisable_irq_nosync(irq);\n\tschedule_delayed_work(&work, HZ / 20);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init hp680_ts_init(void)\n{\n\tint err;\n\n\thp680_ts_dev = input_allocate_device();\n\tif (!hp680_ts_dev)\n\t\treturn -ENOMEM;\n\n\thp680_ts_dev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);\n\thp680_ts_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tinput_set_abs_params(hp680_ts_dev, ABS_X,\n\t\tHP680_TS_ABS_X_MIN, HP680_TS_ABS_X_MAX, 0, 0);\n\tinput_set_abs_params(hp680_ts_dev, ABS_Y,\n\t\tHP680_TS_ABS_Y_MIN, HP680_TS_ABS_Y_MAX, 0, 0);\n\n\thp680_ts_dev->name = \"HP Jornada touchscreen\";\n\thp680_ts_dev->phys = \"hp680_ts/input0\";\n\n\tif (request_irq(HP680_TS_IRQ, hp680_ts_interrupt,\n\t\t\t0, MODNAME, NULL) < 0) {\n\t\tprintk(KERN_ERR \"hp680_touchscreen.c: Can't allocate irq %d\\n\",\n\t\t       HP680_TS_IRQ);\n\t\terr = -EBUSY;\n\t\tgoto fail1;\n\t}\n\n\terr = input_register_device(hp680_ts_dev);\n\tif (err)\n\t\tgoto fail2;\n\n\treturn 0;\n\n fail2:\tfree_irq(HP680_TS_IRQ, NULL);\n\tcancel_delayed_work_sync(&work);\n fail1:\tinput_free_device(hp680_ts_dev);\n\treturn err;\n}\n\nstatic void __exit hp680_ts_exit(void)\n{\n\tfree_irq(HP680_TS_IRQ, NULL);\n\tcancel_delayed_work_sync(&work);\n\tinput_unregister_device(hp680_ts_dev);\n}\n\nmodule_init(hp680_ts_init);\nmodule_exit(hp680_ts_exit);\n\nMODULE_AUTHOR(\"Andriy Skulysh, askulysh@image.kiev.ua\");\nMODULE_DESCRIPTION(\"HP Jornada 680 touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}