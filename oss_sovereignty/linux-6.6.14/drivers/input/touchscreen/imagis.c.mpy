{
  "module_name": "imagis.c",
  "hash_id": "d01510935f3340f8714d1aff440415c9df96589524b97909710f568bc4d3fd28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/imagis.c",
  "human_readable_source": "\n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n\n#define IST3038C_HIB_ACCESS\t\t(0x800B << 16)\n#define IST3038C_DIRECT_ACCESS\t\tBIT(31)\n#define IST3038C_REG_CHIPID\t\t0x40001000\n#define IST3038C_REG_HIB_BASE\t\t0x30000100\n#define IST3038C_REG_TOUCH_STATUS\t(IST3038C_REG_HIB_BASE | IST3038C_HIB_ACCESS)\n#define IST3038C_REG_TOUCH_COORD\t(IST3038C_REG_HIB_BASE | IST3038C_HIB_ACCESS | 0x8)\n#define IST3038C_REG_INTR_MESSAGE\t(IST3038C_REG_HIB_BASE | IST3038C_HIB_ACCESS | 0x4)\n#define IST3038C_WHOAMI\t\t\t0x38c\n#define IST3038C_CHIP_ON_DELAY_MS\t60\n#define IST3038C_I2C_RETRY_COUNT\t3\n#define IST3038C_MAX_FINGER_NUM\t\t10\n#define IST3038C_X_MASK\t\t\tGENMASK(23, 12)\n#define IST3038C_X_SHIFT\t\t12\n#define IST3038C_Y_MASK\t\t\tGENMASK(11, 0)\n#define IST3038C_AREA_MASK\t\tGENMASK(27, 24)\n#define IST3038C_AREA_SHIFT\t\t24\n#define IST3038C_FINGER_COUNT_MASK\tGENMASK(15, 12)\n#define IST3038C_FINGER_COUNT_SHIFT\t12\n#define IST3038C_FINGER_STATUS_MASK\tGENMASK(9, 0)\n\nstruct imagis_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct touchscreen_properties prop;\n\tstruct regulator_bulk_data supplies[2];\n};\n\nstatic int imagis_i2c_read_reg(struct imagis_ts *ts,\n\t\t\t       unsigned int reg, u32 *data)\n{\n\t__be32 ret_be;\n\t__be32 reg_be = cpu_to_be32(reg);\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = (unsigned char *)&reg_be,\n\t\t\t.len = sizeof(reg_be),\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = (unsigned char *)&ret_be,\n\t\t\t.len = sizeof(ret_be),\n\t\t},\n\t};\n\tint ret, error;\n\tint retry = IST3038C_I2C_RETRY_COUNT;\n\n\t \n\tdo {\n\t\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret == ARRAY_SIZE(msg)) {\n\t\t\t*data = be32_to_cpu(ret_be);\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"%s - i2c_transfer failed: %d (%d)\\n\",\n\t\t\t__func__, error, ret);\n\t} while (--retry);\n\n\treturn error;\n}\n\nstatic irqreturn_t imagis_interrupt(int irq, void *dev_id)\n{\n\tstruct imagis_ts *ts = dev_id;\n\tu32 intr_message, finger_status;\n\tunsigned int finger_count, finger_pressed;\n\tint i;\n\tint error;\n\n\terror = imagis_i2c_read_reg(ts, IST3038C_REG_INTR_MESSAGE,\n\t\t\t\t    &intr_message);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to read the interrupt message: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tfinger_count = (intr_message & IST3038C_FINGER_COUNT_MASK) >>\n\t\t\t\tIST3038C_FINGER_COUNT_SHIFT;\n\tif (finger_count > IST3038C_MAX_FINGER_NUM) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"finger count %d is more than maximum supported\\n\",\n\t\t\tfinger_count);\n\t\tgoto out;\n\t}\n\n\tfinger_pressed = intr_message & IST3038C_FINGER_STATUS_MASK;\n\n\tfor (i = 0; i < finger_count; i++) {\n\t\terror = imagis_i2c_read_reg(ts,\n\t\t\t\t\t    IST3038C_REG_TOUCH_COORD + (i * 4),\n\t\t\t\t\t    &finger_status);\n\t\tif (error) {\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"failed to read coordinates for finger %d: %d\\n\",\n\t\t\t\ti, error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tinput_mt_slot(ts->input_dev, i);\n\t\tinput_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER,\n\t\t\t\t\t   finger_pressed & BIT(i));\n\t\ttouchscreen_report_pos(ts->input_dev, &ts->prop,\n\t\t\t\t       (finger_status & IST3038C_X_MASK) >>\n\t\t\t\t\t\tIST3038C_X_SHIFT,\n\t\t\t\t       finger_status & IST3038C_Y_MASK, 1);\n\t\tinput_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t (finger_status & IST3038C_AREA_MASK) >>\n\t\t\t\t\tIST3038C_AREA_SHIFT);\n\t}\n\n\tinput_mt_sync_frame(ts->input_dev);\n\tinput_sync(ts->input_dev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void imagis_power_off(void *_ts)\n{\n\tstruct imagis_ts *ts = _ts;\n\n\tregulator_bulk_disable(ARRAY_SIZE(ts->supplies), ts->supplies);\n}\n\nstatic int imagis_power_on(struct imagis_ts *ts)\n{\n\tint error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(ts->supplies), ts->supplies);\n\tif (error)\n\t\treturn error;\n\n\tmsleep(IST3038C_CHIP_ON_DELAY_MS);\n\n\treturn 0;\n}\n\nstatic int imagis_start(struct imagis_ts *ts)\n{\n\tint error;\n\n\terror = imagis_power_on(ts);\n\tif (error)\n\t\treturn error;\n\n\tenable_irq(ts->client->irq);\n\n\treturn 0;\n}\n\nstatic int imagis_stop(struct imagis_ts *ts)\n{\n\tdisable_irq(ts->client->irq);\n\n\timagis_power_off(ts);\n\n\treturn 0;\n}\n\nstatic int imagis_input_open(struct input_dev *dev)\n{\n\tstruct imagis_ts *ts = input_get_drvdata(dev);\n\n\treturn imagis_start(ts);\n}\n\nstatic void imagis_input_close(struct input_dev *dev)\n{\n\tstruct imagis_ts *ts = input_get_drvdata(dev);\n\n\timagis_stop(ts);\n}\n\nstatic int imagis_init_input_dev(struct imagis_ts *ts)\n{\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tinput_dev = devm_input_allocate_device(&ts->client->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tts->input_dev = input_dev;\n\n\tinput_dev->name = \"Imagis capacitive touchscreen\";\n\tinput_dev->phys = \"input/ts\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->open = imagis_input_open;\n\tinput_dev->close = imagis_input_close;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\n\ttouchscreen_parse_properties(input_dev, true, &ts->prop);\n\tif (!ts->prop.max_x || !ts->prop.max_y) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Touchscreen-size-x and/or touchscreen-size-y not set in dts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_mt_init_slots(input_dev,\n\t\t\t\t    IST3038C_MAX_FINGER_NUM,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to initialize MT slots: %d\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to register input device: %d\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int imagis_init_regulators(struct imagis_ts *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\n\tts->supplies[0].supply = \"vdd\";\n\tts->supplies[1].supply = \"vddio\";\n\treturn devm_regulator_bulk_get(&client->dev,\n\t\t\t\t       ARRAY_SIZE(ts->supplies),\n\t\t\t\t       ts->supplies);\n}\n\nstatic int imagis_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct imagis_ts *ts;\n\tint chip_id, error;\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = i2c;\n\n\terror = imagis_init_regulators(ts);\n\tif (error) {\n\t\tdev_err(dev, \"regulator init error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = imagis_power_on(ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to enable regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, imagis_power_off, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to install poweroff action: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = imagis_i2c_read_reg(ts,\n\t\t\tIST3038C_REG_CHIPID | IST3038C_DIRECT_ACCESS,\n\t\t\t&chip_id);\n\tif (error) {\n\t\tdev_err(dev, \"chip ID read failure: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (chip_id != IST3038C_WHOAMI) {\n\t\tdev_err(dev, \"unknown chip ID: 0x%x\\n\", chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = devm_request_threaded_irq(dev, i2c->irq,\n\t\t\t\t\t  NULL, imagis_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  \"imagis-touchscreen\", ts);\n\tif (error) {\n\t\tdev_err(dev, \"IRQ %d allocation failure: %d\\n\",\n\t\t\ti2c->irq, error);\n\t\treturn error;\n\t}\n\n\terror = imagis_init_input_dev(ts);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int imagis_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct imagis_ts *ts = i2c_get_clientdata(client);\n\tint retval = 0;\n\n\tmutex_lock(&ts->input_dev->mutex);\n\n\tif (input_device_enabled(ts->input_dev))\n\t\tretval = imagis_stop(ts);\n\n\tmutex_unlock(&ts->input_dev->mutex);\n\n\treturn retval;\n}\n\nstatic int imagis_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct imagis_ts *ts = i2c_get_clientdata(client);\n\tint retval = 0;\n\n\tmutex_lock(&ts->input_dev->mutex);\n\n\tif (input_device_enabled(ts->input_dev))\n\t\tretval = imagis_start(ts);\n\n\tmutex_unlock(&ts->input_dev->mutex);\n\n\treturn retval;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(imagis_pm_ops, imagis_suspend, imagis_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id imagis_of_match[] = {\n\t{ .compatible = \"imagis,ist3038c\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imagis_of_match);\n#endif\n\nstatic struct i2c_driver imagis_ts_driver = {\n\t.driver = {\n\t\t.name = \"imagis-touchscreen\",\n\t\t.pm = pm_sleep_ptr(&imagis_pm_ops),\n\t\t.of_match_table = of_match_ptr(imagis_of_match),\n\t},\n\t.probe = imagis_probe,\n};\n\nmodule_i2c_driver(imagis_ts_driver);\n\nMODULE_DESCRIPTION(\"Imagis IST3038C Touchscreen Driver\");\nMODULE_AUTHOR(\"Markuss Broks <markuss.broks@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}