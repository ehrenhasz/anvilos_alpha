{
  "module_name": "wacom_w8001.c",
  "hash_id": "9a54789cdba33d7d2d9020bab059f2d9f71727ab68d8796d57e25fa050a6f8c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wacom_w8001.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input/mt.h>\n#include <linux/serio.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n\n#define DRIVER_DESC\t\"Wacom W8001 serial touchscreen driver\"\n\nMODULE_AUTHOR(\"Jaya Kumar <jayakumar.lkml@gmail.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define W8001_MAX_PHYS\t\t42\n\n#define W8001_MAX_LENGTH\t13\n#define W8001_LEAD_MASK\t\t0x80\n#define W8001_LEAD_BYTE\t\t0x80\n#define W8001_TAB_MASK\t\t0x40\n#define W8001_TAB_BYTE\t\t0x40\n \n#define W8001_TOUCH_MASK\t(0x10 | W8001_LEAD_MASK)\n#define W8001_TOUCH_BYTE\t(0x10 | W8001_LEAD_BYTE)\n\n#define W8001_QUERY_PACKET\t0x20\n\n#define W8001_CMD_STOP\t\t'0'\n#define W8001_CMD_START\t\t'1'\n#define W8001_CMD_QUERY\t\t'*'\n#define W8001_CMD_TOUCHQUERY\t'%'\n\n \n#define W8001_PKTLEN_TOUCH93\t5\n#define W8001_PKTLEN_TOUCH9A\t7\n#define W8001_PKTLEN_TPCPEN\t9\n#define W8001_PKTLEN_TPCCTL\t11\t \n#define W8001_PKTLEN_TOUCH2FG\t13\n\n \n#define W8001_PEN_RESOLUTION    100\n#define W8001_TOUCH_RESOLUTION  10\n\nstruct w8001_coord {\n\tu8 rdy;\n\tu8 tsw;\n\tu8 f1;\n\tu8 f2;\n\tu16 x;\n\tu16 y;\n\tu16 pen_pressure;\n\tu8 tilt_x;\n\tu8 tilt_y;\n};\n\n \nstruct w8001_touch_query {\n\tu16 x;\n\tu16 y;\n\tu8 panel_res;\n\tu8 capacity_res;\n\tu8 sensor_id;\n};\n\n \n\nstruct w8001 {\n\tstruct input_dev *pen_dev;\n\tstruct input_dev *touch_dev;\n\tstruct serio *serio;\n\tstruct completion cmd_done;\n\tint id;\n\tint idx;\n\tunsigned char response_type;\n\tunsigned char response[W8001_MAX_LENGTH];\n\tunsigned char data[W8001_MAX_LENGTH];\n\tchar phys[W8001_MAX_PHYS];\n\tint type;\n\tunsigned int pktlen;\n\tu16 max_touch_x;\n\tu16 max_touch_y;\n\tu16 max_pen_x;\n\tu16 max_pen_y;\n\tchar pen_name[64];\n\tchar touch_name[64];\n\tint open_count;\n\tstruct mutex mutex;\n};\n\nstatic void parse_pen_data(u8 *data, struct w8001_coord *coord)\n{\n\tmemset(coord, 0, sizeof(*coord));\n\n\tcoord->rdy = data[0] & 0x20;\n\tcoord->tsw = data[0] & 0x01;\n\tcoord->f1 = data[0] & 0x02;\n\tcoord->f2 = data[0] & 0x04;\n\n\tcoord->x = (data[1] & 0x7F) << 9;\n\tcoord->x |= (data[2] & 0x7F) << 2;\n\tcoord->x |= (data[6] & 0x60) >> 5;\n\n\tcoord->y = (data[3] & 0x7F) << 9;\n\tcoord->y |= (data[4] & 0x7F) << 2;\n\tcoord->y |= (data[6] & 0x18) >> 3;\n\n\tcoord->pen_pressure = data[5] & 0x7F;\n\tcoord->pen_pressure |= (data[6] & 0x07) << 7 ;\n\n\tcoord->tilt_x = data[7] & 0x7F;\n\tcoord->tilt_y = data[8] & 0x7F;\n}\n\nstatic void parse_single_touch(u8 *data, struct w8001_coord *coord)\n{\n\tcoord->x = (data[1] << 7) | data[2];\n\tcoord->y = (data[3] << 7) | data[4];\n\tcoord->tsw = data[0] & 0x01;\n}\n\nstatic void scale_touch_coordinates(struct w8001 *w8001,\n\t\t\t\t    unsigned int *x, unsigned int *y)\n{\n\tif (w8001->max_pen_x && w8001->max_touch_x)\n\t\t*x = *x * w8001->max_pen_x / w8001->max_touch_x;\n\n\tif (w8001->max_pen_y && w8001->max_touch_y)\n\t\t*y = *y * w8001->max_pen_y / w8001->max_touch_y;\n}\n\nstatic void parse_multi_touch(struct w8001 *w8001)\n{\n\tstruct input_dev *dev = w8001->touch_dev;\n\tunsigned char *data = w8001->data;\n\tunsigned int x, y;\n\tint i;\n\tint count = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tbool touch = data[0] & (1 << i);\n\n\t\tinput_mt_slot(dev, i);\n\t\tinput_mt_report_slot_state(dev, MT_TOOL_FINGER, touch);\n\t\tif (touch) {\n\t\t\tx = (data[6 * i + 1] << 7) | data[6 * i + 2];\n\t\t\ty = (data[6 * i + 3] << 7) | data[6 * i + 4];\n\t\t\t \n\n\t\t\t \n\t\t\tscale_touch_coordinates(w8001, &x, &y);\n\n\t\t\tinput_report_abs(dev, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(dev, ABS_MT_POSITION_Y, y);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t \n\tif (w8001->type != BTN_TOOL_PEN &&\n\t\t\t    w8001->type != BTN_TOOL_RUBBER) {\n\t\tw8001->type = count == 1 ? BTN_TOOL_FINGER : KEY_RESERVED;\n\t\tinput_mt_report_pointer_emulation(dev, true);\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic void parse_touchquery(u8 *data, struct w8001_touch_query *query)\n{\n\tmemset(query, 0, sizeof(*query));\n\n\tquery->panel_res = data[1];\n\tquery->sensor_id = data[2] & 0x7;\n\tquery->capacity_res = data[7];\n\n\tquery->x = data[3] << 9;\n\tquery->x |= data[4] << 2;\n\tquery->x |= (data[2] >> 5) & 0x3;\n\n\tquery->y = data[5] << 9;\n\tquery->y |= data[6] << 2;\n\tquery->y |= (data[2] >> 3) & 0x3;\n\n\t \n\tif (!query->x && !query->y) {\n\t\tquery->x = 1024;\n\t\tquery->y = 1024;\n\t\tif (query->panel_res)\n\t\t\tquery->x = query->y = (1 << query->panel_res);\n\t\tquery->panel_res = W8001_TOUCH_RESOLUTION;\n\t}\n}\n\nstatic void report_pen_events(struct w8001 *w8001, struct w8001_coord *coord)\n{\n\tstruct input_dev *dev = w8001->pen_dev;\n\n\t \n\n\tswitch (w8001->type) {\n\tcase BTN_TOOL_RUBBER:\n\t\tif (!coord->f2) {\n\t\t\tinput_report_abs(dev, ABS_PRESSURE, 0);\n\t\t\tinput_report_key(dev, BTN_TOUCH, 0);\n\t\t\tinput_report_key(dev, BTN_STYLUS, 0);\n\t\t\tinput_report_key(dev, BTN_STYLUS2, 0);\n\t\t\tinput_report_key(dev, BTN_TOOL_RUBBER, 0);\n\t\t\tinput_sync(dev);\n\t\t\tw8001->type = BTN_TOOL_PEN;\n\t\t}\n\t\tbreak;\n\n\tcase BTN_TOOL_FINGER:\n\tcase KEY_RESERVED:\n\t\tw8001->type = coord->f2 ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\n\t\tbreak;\n\n\tdefault:\n\t\tinput_report_key(dev, BTN_STYLUS2, coord->f2);\n\t\tbreak;\n\t}\n\n\tinput_report_abs(dev, ABS_X, coord->x);\n\tinput_report_abs(dev, ABS_Y, coord->y);\n\tinput_report_abs(dev, ABS_PRESSURE, coord->pen_pressure);\n\tinput_report_key(dev, BTN_TOUCH, coord->tsw);\n\tinput_report_key(dev, BTN_STYLUS, coord->f1);\n\tinput_report_key(dev, w8001->type, coord->rdy);\n\tinput_sync(dev);\n\n\tif (!coord->rdy)\n\t\tw8001->type = KEY_RESERVED;\n}\n\nstatic void report_single_touch(struct w8001 *w8001, struct w8001_coord *coord)\n{\n\tstruct input_dev *dev = w8001->touch_dev;\n\tunsigned int x = coord->x;\n\tunsigned int y = coord->y;\n\n\t \n\tscale_touch_coordinates(w8001, &x, &y);\n\n\tinput_report_abs(dev, ABS_X, x);\n\tinput_report_abs(dev, ABS_Y, y);\n\tinput_report_key(dev, BTN_TOUCH, coord->tsw);\n\n\tinput_sync(dev);\n\n\tw8001->type = coord->tsw ? BTN_TOOL_FINGER : KEY_RESERVED;\n}\n\nstatic irqreturn_t w8001_interrupt(struct serio *serio,\n\t\t\t\t   unsigned char data, unsigned int flags)\n{\n\tstruct w8001 *w8001 = serio_get_drvdata(serio);\n\tstruct w8001_coord coord;\n\tunsigned char tmp;\n\n\tw8001->data[w8001->idx] = data;\n\tswitch (w8001->idx++) {\n\tcase 0:\n\t\tif ((data & W8001_LEAD_MASK) != W8001_LEAD_BYTE) {\n\t\t\tpr_debug(\"w8001: unsynchronized data: 0x%02x\\n\", data);\n\t\t\tw8001->idx = 0;\n\t\t}\n\t\tbreak;\n\n\tcase W8001_PKTLEN_TOUCH93 - 1:\n\tcase W8001_PKTLEN_TOUCH9A - 1:\n\t\ttmp = w8001->data[0] & W8001_TOUCH_BYTE;\n\t\tif (tmp != W8001_TOUCH_BYTE)\n\t\t\tbreak;\n\n\t\tif (w8001->pktlen == w8001->idx) {\n\t\t\tw8001->idx = 0;\n\t\t\tif (w8001->type != BTN_TOOL_PEN &&\n\t\t\t    w8001->type != BTN_TOOL_RUBBER) {\n\t\t\t\tparse_single_touch(w8001->data, &coord);\n\t\t\t\treport_single_touch(w8001, &coord);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t \n\tcase W8001_PKTLEN_TPCPEN - 1:\n\t\ttmp = w8001->data[0] & W8001_TAB_MASK;\n\t\tif (unlikely(tmp == W8001_TAB_BYTE))\n\t\t\tbreak;\n\n\t\ttmp = w8001->data[0] & W8001_TOUCH_BYTE;\n\t\tif (tmp == W8001_TOUCH_BYTE)\n\t\t\tbreak;\n\n\t\tw8001->idx = 0;\n\t\tparse_pen_data(w8001->data, &coord);\n\t\treport_pen_events(w8001, &coord);\n\t\tbreak;\n\n\t \n\tcase W8001_PKTLEN_TPCCTL - 1:\n\t\ttmp = w8001->data[0] & W8001_TOUCH_MASK;\n\t\tif (tmp == W8001_TOUCH_BYTE)\n\t\t\tbreak;\n\n\t\tw8001->idx = 0;\n\t\tmemcpy(w8001->response, w8001->data, W8001_MAX_LENGTH);\n\t\tw8001->response_type = W8001_QUERY_PACKET;\n\t\tcomplete(&w8001->cmd_done);\n\t\tbreak;\n\n\t \n\tcase W8001_PKTLEN_TOUCH2FG - 1:\n\t\tw8001->idx = 0;\n\t\tparse_multi_touch(w8001);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (!w8001->touch_dev && w8001->idx > W8001_PKTLEN_TPCPEN - 1)\n\t\t\tw8001->idx = 0;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int w8001_command(struct w8001 *w8001, unsigned char command,\n\t\t\t bool wait_response)\n{\n\tint rc;\n\n\tw8001->response_type = 0;\n\tinit_completion(&w8001->cmd_done);\n\n\trc = serio_write(w8001->serio, command);\n\tif (rc == 0 && wait_response) {\n\n\t\twait_for_completion_timeout(&w8001->cmd_done, HZ);\n\t\tif (w8001->response_type != W8001_QUERY_PACKET)\n\t\t\trc = -EIO;\n\t}\n\n\treturn rc;\n}\n\nstatic int w8001_open(struct input_dev *dev)\n{\n\tstruct w8001 *w8001 = input_get_drvdata(dev);\n\tint err;\n\n\terr = mutex_lock_interruptible(&w8001->mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (w8001->open_count++ == 0) {\n\t\terr = w8001_command(w8001, W8001_CMD_START, false);\n\t\tif (err)\n\t\t\tw8001->open_count--;\n\t}\n\n\tmutex_unlock(&w8001->mutex);\n\treturn err;\n}\n\nstatic void w8001_close(struct input_dev *dev)\n{\n\tstruct w8001 *w8001 = input_get_drvdata(dev);\n\n\tmutex_lock(&w8001->mutex);\n\n\tif (--w8001->open_count == 0)\n\t\tw8001_command(w8001, W8001_CMD_STOP, false);\n\n\tmutex_unlock(&w8001->mutex);\n}\n\nstatic int w8001_detect(struct w8001 *w8001)\n{\n\tint error;\n\n\terror = w8001_command(w8001, W8001_CMD_STOP, false);\n\tif (error)\n\t\treturn error;\n\n\tmsleep(250);\t \n\n\treturn 0;\n}\n\nstatic int w8001_setup_pen(struct w8001 *w8001, char *basename,\n\t\t\t   size_t basename_sz)\n{\n\tstruct input_dev *dev = w8001->pen_dev;\n\tstruct w8001_coord coord;\n\tint error;\n\n\t \n\terror = w8001_command(w8001, W8001_CMD_QUERY, true);\n\tif (error)\n\t\treturn error;\n\n\t__set_bit(EV_KEY, dev->evbit);\n\t__set_bit(EV_ABS, dev->evbit);\n\t__set_bit(BTN_TOUCH, dev->keybit);\n\t__set_bit(BTN_TOOL_PEN, dev->keybit);\n\t__set_bit(BTN_TOOL_RUBBER, dev->keybit);\n\t__set_bit(BTN_STYLUS, dev->keybit);\n\t__set_bit(BTN_STYLUS2, dev->keybit);\n\t__set_bit(INPUT_PROP_DIRECT, dev->propbit);\n\n\tparse_pen_data(w8001->response, &coord);\n\tw8001->max_pen_x = coord.x;\n\tw8001->max_pen_y = coord.y;\n\n\tinput_set_abs_params(dev, ABS_X, 0, coord.x, 0, 0);\n\tinput_set_abs_params(dev, ABS_Y, 0, coord.y, 0, 0);\n\tinput_abs_set_res(dev, ABS_X, W8001_PEN_RESOLUTION);\n\tinput_abs_set_res(dev, ABS_Y, W8001_PEN_RESOLUTION);\n\tinput_set_abs_params(dev, ABS_PRESSURE, 0, coord.pen_pressure, 0, 0);\n\tif (coord.tilt_x && coord.tilt_y) {\n\t\tinput_set_abs_params(dev, ABS_TILT_X, 0, coord.tilt_x, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_TILT_Y, 0, coord.tilt_y, 0, 0);\n\t}\n\n\tw8001->id = 0x90;\n\tstrlcat(basename, \" Penabled\", basename_sz);\n\n\treturn 0;\n}\n\nstatic int w8001_setup_touch(struct w8001 *w8001, char *basename,\n\t\t\t     size_t basename_sz)\n{\n\tstruct input_dev *dev = w8001->touch_dev;\n\tstruct w8001_touch_query touch;\n\tint error;\n\n\n\t \n\terror = w8001_command(w8001, W8001_CMD_TOUCHQUERY, true);\n\tif (error)\n\t\treturn error;\n\t \n\tif (!w8001->response[1])\n\t\treturn -ENXIO;\n\n\t__set_bit(EV_KEY, dev->evbit);\n\t__set_bit(EV_ABS, dev->evbit);\n\t__set_bit(BTN_TOUCH, dev->keybit);\n\t__set_bit(INPUT_PROP_DIRECT, dev->propbit);\n\n\tparse_touchquery(w8001->response, &touch);\n\tw8001->max_touch_x = touch.x;\n\tw8001->max_touch_y = touch.y;\n\n\tif (w8001->max_pen_x && w8001->max_pen_y) {\n\t\t \n\t\ttouch.x = w8001->max_pen_x;\n\t\ttouch.y = w8001->max_pen_y;\n\t\ttouch.panel_res = W8001_PEN_RESOLUTION;\n\t}\n\n\tinput_set_abs_params(dev, ABS_X, 0, touch.x, 0, 0);\n\tinput_set_abs_params(dev, ABS_Y, 0, touch.y, 0, 0);\n\tinput_abs_set_res(dev, ABS_X, touch.panel_res);\n\tinput_abs_set_res(dev, ABS_Y, touch.panel_res);\n\n\tswitch (touch.sensor_id) {\n\tcase 0:\n\tcase 2:\n\t\tw8001->pktlen = W8001_PKTLEN_TOUCH93;\n\t\tw8001->id = 0x93;\n\t\tstrlcat(basename, \" 1FG\", basename_sz);\n\t\tbreak;\n\n\tcase 1:\n\tcase 3:\n\tcase 4:\n\t\tw8001->pktlen = W8001_PKTLEN_TOUCH9A;\n\t\tstrlcat(basename, \" 1FG\", basename_sz);\n\t\tw8001->id = 0x9a;\n\t\tbreak;\n\n\tcase 5:\n\t\tw8001->pktlen = W8001_PKTLEN_TOUCH2FG;\n\n\t\t__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\n\t\terror = input_mt_init_slots(dev, 2, 0);\n\t\tif (error) {\n\t\t\tdev_err(&w8001->serio->dev,\n\t\t\t\t\"failed to initialize MT slots: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_X,\n\t\t\t\t\t0, touch.x, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_POSITION_Y,\n\t\t\t\t\t0, touch.y, 0, 0);\n\t\tinput_set_abs_params(dev, ABS_MT_TOOL_TYPE,\n\t\t\t\t\t0, MT_TOOL_MAX, 0, 0);\n\t\tinput_abs_set_res(dev, ABS_MT_POSITION_X, touch.panel_res);\n\t\tinput_abs_set_res(dev, ABS_MT_POSITION_Y, touch.panel_res);\n\n\t\tstrlcat(basename, \" 2FG\", basename_sz);\n\t\tif (w8001->max_pen_x && w8001->max_pen_y)\n\t\t\tw8001->id = 0xE3;\n\t\telse\n\t\t\tw8001->id = 0xE2;\n\t\tbreak;\n\t}\n\n\tstrlcat(basename, \" Touchscreen\", basename_sz);\n\n\treturn 0;\n}\n\nstatic void w8001_set_devdata(struct input_dev *dev, struct w8001 *w8001,\n\t\t\t      struct serio *serio)\n{\n\tdev->phys = w8001->phys;\n\tdev->id.bustype = BUS_RS232;\n\tdev->id.product = w8001->id;\n\tdev->id.vendor = 0x056a;\n\tdev->id.version = 0x0100;\n\tdev->open = w8001_open;\n\tdev->close = w8001_close;\n\n\tdev->dev.parent = &serio->dev;\n\n\tinput_set_drvdata(dev, w8001);\n}\n\n \n\nstatic void w8001_disconnect(struct serio *serio)\n{\n\tstruct w8001 *w8001 = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\n\tif (w8001->pen_dev)\n\t\tinput_unregister_device(w8001->pen_dev);\n\tif (w8001->touch_dev)\n\t\tinput_unregister_device(w8001->touch_dev);\n\tkfree(w8001);\n\n\tserio_set_drvdata(serio, NULL);\n}\n\n \n\nstatic int w8001_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct w8001 *w8001;\n\tstruct input_dev *input_dev_pen;\n\tstruct input_dev *input_dev_touch;\n\tchar basename[64];\n\tint err, err_pen, err_touch;\n\n\tw8001 = kzalloc(sizeof(struct w8001), GFP_KERNEL);\n\tinput_dev_pen = input_allocate_device();\n\tinput_dev_touch = input_allocate_device();\n\tif (!w8001 || !input_dev_pen || !input_dev_touch) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tw8001->serio = serio;\n\tw8001->pen_dev = input_dev_pen;\n\tw8001->touch_dev = input_dev_touch;\n\tmutex_init(&w8001->mutex);\n\tinit_completion(&w8001->cmd_done);\n\tsnprintf(w8001->phys, sizeof(w8001->phys), \"%s/input0\", serio->phys);\n\n\tserio_set_drvdata(serio, w8001);\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = w8001_detect(w8001);\n\tif (err)\n\t\tgoto fail3;\n\n\t \n\tstrscpy(basename, \"Wacom Serial\", sizeof(basename));\n\n\terr_pen = w8001_setup_pen(w8001, basename, sizeof(basename));\n\terr_touch = w8001_setup_touch(w8001, basename, sizeof(basename));\n\tif (err_pen && err_touch) {\n\t\terr = -ENXIO;\n\t\tgoto fail3;\n\t}\n\n\tif (!err_pen) {\n\t\tstrscpy(w8001->pen_name, basename, sizeof(w8001->pen_name));\n\t\tstrlcat(w8001->pen_name, \" Pen\", sizeof(w8001->pen_name));\n\t\tinput_dev_pen->name = w8001->pen_name;\n\n\t\tw8001_set_devdata(input_dev_pen, w8001, serio);\n\n\t\terr = input_register_device(w8001->pen_dev);\n\t\tif (err)\n\t\t\tgoto fail3;\n\t} else {\n\t\tinput_free_device(input_dev_pen);\n\t\tinput_dev_pen = NULL;\n\t\tw8001->pen_dev = NULL;\n\t}\n\n\tif (!err_touch) {\n\t\tstrscpy(w8001->touch_name, basename, sizeof(w8001->touch_name));\n\t\tstrlcat(w8001->touch_name, \" Finger\",\n\t\t\tsizeof(w8001->touch_name));\n\t\tinput_dev_touch->name = w8001->touch_name;\n\n\t\tw8001_set_devdata(input_dev_touch, w8001, serio);\n\n\t\terr = input_register_device(w8001->touch_dev);\n\t\tif (err)\n\t\t\tgoto fail4;\n\t} else {\n\t\tinput_free_device(input_dev_touch);\n\t\tinput_dev_touch = NULL;\n\t\tw8001->touch_dev = NULL;\n\t}\n\n\treturn 0;\n\nfail4:\n\tif (w8001->pen_dev)\n\t\tinput_unregister_device(w8001->pen_dev);\nfail3:\n\tserio_close(serio);\nfail2:\n\tserio_set_drvdata(serio, NULL);\nfail1:\n\tinput_free_device(input_dev_pen);\n\tinput_free_device(input_dev_touch);\n\tkfree(w8001);\n\treturn err;\n}\n\nstatic const struct serio_device_id w8001_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_W8001,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, w8001_serio_ids);\n\nstatic struct serio_driver w8001_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"w8001\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= w8001_serio_ids,\n\t.interrupt\t= w8001_interrupt,\n\t.connect\t= w8001_connect,\n\t.disconnect\t= w8001_disconnect,\n};\n\nmodule_serio_driver(w8001_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}