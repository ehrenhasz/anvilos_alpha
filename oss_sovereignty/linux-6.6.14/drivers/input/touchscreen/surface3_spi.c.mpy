{
  "module_name": "surface3_spi.c",
  "hash_id": "435951ac6ac02c082794c4d2814cd44a21490bc61c519c1f723925c720241a61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/surface3_spi.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/acpi.h>\n\n#include <asm/unaligned.h>\n\n#define SURFACE3_PACKET_SIZE\t264\n\n#define SURFACE3_REPORT_TOUCH\t0xd2\n#define SURFACE3_REPORT_PEN\t0x16\n\nstruct surface3_ts_data {\n\tstruct spi_device *spi;\n\tstruct gpio_desc *gpiod_rst[2];\n\tstruct input_dev *input_dev;\n\tstruct input_dev *pen_input_dev;\n\tint pen_tool;\n\n\tu8 rd_buf[SURFACE3_PACKET_SIZE]\t\t____cacheline_aligned;\n};\n\nstruct surface3_ts_data_finger {\n\tu8 status;\n\t__le16 tracking_id;\n\t__le16 x;\n\t__le16 cx;\n\t__le16 y;\n\t__le16 cy;\n\t__le16 width;\n\t__le16 height;\n\tu32 padding;\n} __packed;\n\nstruct surface3_ts_data_pen {\n\tu8 status;\n\t__le16 x;\n\t__le16 y;\n\t__le16 pressure;\n\tu8 padding;\n} __packed;\n\nstatic int surface3_spi_read(struct surface3_ts_data *ts_data)\n{\n\tstruct spi_device *spi = ts_data->spi;\n\n\tmemset(ts_data->rd_buf, 0, sizeof(ts_data->rd_buf));\n\treturn spi_read(spi, ts_data->rd_buf, sizeof(ts_data->rd_buf));\n}\n\nstatic void surface3_spi_report_touch(struct surface3_ts_data *ts_data,\n\t\t\t\t   struct surface3_ts_data_finger *finger)\n{\n\tint st = finger->status & 0x01;\n\tint slot;\n\n\tslot = input_mt_get_slot_by_key(ts_data->input_dev,\n\t\t\t\tget_unaligned_le16(&finger->tracking_id));\n\tif (slot < 0)\n\t\treturn;\n\n\tinput_mt_slot(ts_data->input_dev, slot);\n\tinput_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER, st);\n\tif (st) {\n\t\tinput_report_abs(ts_data->input_dev,\n\t\t\t\t ABS_MT_POSITION_X,\n\t\t\t\t get_unaligned_le16(&finger->x));\n\t\tinput_report_abs(ts_data->input_dev,\n\t\t\t\t ABS_MT_POSITION_Y,\n\t\t\t\t get_unaligned_le16(&finger->y));\n\t\tinput_report_abs(ts_data->input_dev,\n\t\t\t\t ABS_MT_WIDTH_MAJOR,\n\t\t\t\t get_unaligned_le16(&finger->width));\n\t\tinput_report_abs(ts_data->input_dev,\n\t\t\t\t ABS_MT_WIDTH_MINOR,\n\t\t\t\t get_unaligned_le16(&finger->height));\n\t}\n}\n\nstatic void surface3_spi_process_touch(struct surface3_ts_data *ts_data, u8 *data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < 13; i++) {\n\t\tstruct surface3_ts_data_finger *finger;\n\n\t\tfinger = (struct surface3_ts_data_finger *)&data[17 +\n\t\t\t\ti * sizeof(struct surface3_ts_data_finger)];\n\n\t\t \n\t\tif (finger->status & 0x10)\n\t\t\tbreak;\n\n\t\tsurface3_spi_report_touch(ts_data, finger);\n\t}\n\n\tinput_mt_sync_frame(ts_data->input_dev);\n\tinput_sync(ts_data->input_dev);\n}\n\nstatic void surface3_spi_report_pen(struct surface3_ts_data *ts_data,\n\t\t\t\t    struct surface3_ts_data_pen *pen)\n{\n\tstruct input_dev *dev = ts_data->pen_input_dev;\n\tint st = pen->status;\n\tint prox = st & 0x01;\n\tint rubber = st & 0x18;\n\tint tool = (prox && rubber) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\n\n\t \n\tif (ts_data->pen_tool != tool) {\n\t\tinput_report_key(dev, ts_data->pen_tool, 0);\n\t\tinput_sync(dev);\n\t\tts_data->pen_tool = tool;\n\t}\n\n\tinput_report_key(dev, BTN_TOUCH, st & 0x12);\n\n\tinput_report_key(dev, ts_data->pen_tool, prox);\n\n\tif (st) {\n\t\tinput_report_key(dev,\n\t\t\t\t BTN_STYLUS,\n\t\t\t\t st & 0x04);\n\n\t\tinput_report_abs(dev,\n\t\t\t\t ABS_X,\n\t\t\t\t get_unaligned_le16(&pen->x));\n\t\tinput_report_abs(dev,\n\t\t\t\t ABS_Y,\n\t\t\t\t get_unaligned_le16(&pen->y));\n\t\tinput_report_abs(dev,\n\t\t\t\t ABS_PRESSURE,\n\t\t\t\t get_unaligned_le16(&pen->pressure));\n\t}\n}\n\nstatic void surface3_spi_process_pen(struct surface3_ts_data *ts_data, u8 *data)\n{\n\tstruct surface3_ts_data_pen *pen;\n\n\tpen = (struct surface3_ts_data_pen *)&data[15];\n\n\tsurface3_spi_report_pen(ts_data, pen);\n\tinput_sync(ts_data->pen_input_dev);\n}\n\nstatic void surface3_spi_process(struct surface3_ts_data *ts_data)\n{\n\tstatic const char header[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xa5, 0x5a, 0xe7, 0x7e, 0x01\n\t};\n\tu8 *data = ts_data->rd_buf;\n\n\tif (memcmp(header, data, sizeof(header)))\n\t\tdev_err(&ts_data->spi->dev,\n\t\t\t\"%s header error: %*ph, ignoring...\\n\",\n\t\t\t__func__, (int)sizeof(header), data);\n\n\tswitch (data[9]) {\n\tcase SURFACE3_REPORT_TOUCH:\n\t\tsurface3_spi_process_touch(ts_data, data);\n\t\tbreak;\n\tcase SURFACE3_REPORT_PEN:\n\t\tsurface3_spi_process_pen(ts_data, data);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ts_data->spi->dev,\n\t\t\t\"%s unknown packet type: %x, ignoring...\\n\",\n\t\t\t__func__, data[9]);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t surface3_spi_irq_handler(int irq, void *dev_id)\n{\n\tstruct surface3_ts_data *data = dev_id;\n\n\tif (surface3_spi_read(data))\n\t\treturn IRQ_HANDLED;\n\n\tdev_dbg(&data->spi->dev, \"%s received -> %*ph\\n\",\n\t\t__func__, SURFACE3_PACKET_SIZE, data->rd_buf);\n\tsurface3_spi_process(data);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void surface3_spi_power(struct surface3_ts_data *data, bool on)\n{\n\tgpiod_set_value(data->gpiod_rst[0], on);\n\tgpiod_set_value(data->gpiod_rst[1], on);\n\t \n\tmsleep(20);\n}\n\n \nstatic int surface3_spi_get_gpio_config(struct surface3_ts_data *data)\n{\n\tstruct device *dev;\n\tstruct gpio_desc *gpiod;\n\tint i;\n\n\tdev = &data->spi->dev;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tgpiod = devm_gpiod_get_index(dev, NULL, i, GPIOD_OUT_LOW);\n\t\tif (IS_ERR(gpiod))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(gpiod),\n\t\t\t\t\t     \"Failed to get power GPIO %d\\n\", i);\n\n\t\tdata->gpiod_rst[i] = gpiod;\n\t}\n\n\treturn 0;\n}\n\nstatic int surface3_spi_create_touch_input(struct surface3_ts_data *data)\n{\n\tstruct input_dev *input;\n\tint error;\n\n\tinput = devm_input_allocate_device(&data->spi->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tdata->input_dev = input;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, 9600, 0, 0);\n\tinput_abs_set_res(input, ABS_MT_POSITION_X, 40);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, 7200, 0, 0);\n\tinput_abs_set_res(input, ABS_MT_POSITION_Y, 48);\n\tinput_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 1024, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_WIDTH_MINOR, 0, 1024, 0, 0);\n\tinput_mt_init_slots(input, 10, INPUT_MT_DIRECT);\n\n\tinput->name = \"Surface3 SPI Capacitive TouchScreen\";\n\tinput->phys = \"input/ts\";\n\tinput->id.bustype = BUS_SPI;\n\tinput->id.vendor = 0x045e;\t \n\tinput->id.product = 0x0001;\n\tinput->id.version = 0x0000;\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"Failed to register input device: %d\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int surface3_spi_create_pen_input(struct surface3_ts_data *data)\n{\n\tstruct input_dev *input;\n\tint error;\n\n\tinput = devm_input_allocate_device(&data->spi->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tdata->pen_input_dev = input;\n\tdata->pen_tool = BTN_TOOL_PEN;\n\n\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\tinput_set_abs_params(input, ABS_X, 0, 9600, 0, 0);\n\tinput_abs_set_res(input, ABS_X, 40);\n\tinput_set_abs_params(input, ABS_Y, 0, 7200, 0, 0);\n\tinput_abs_set_res(input, ABS_Y, 48);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 1024, 0, 0);\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_capability(input, EV_KEY, BTN_STYLUS);\n\tinput_set_capability(input, EV_KEY, BTN_TOOL_PEN);\n\tinput_set_capability(input, EV_KEY, BTN_TOOL_RUBBER);\n\n\tinput->name = \"Surface3 SPI Pen Input\";\n\tinput->phys = \"input/ts\";\n\tinput->id.bustype = BUS_SPI;\n\tinput->id.vendor = 0x045e;      \n\tinput->id.product = 0x0002;\n\tinput->id.version = 0x0000;\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&data->spi->dev,\n\t\t\t\"Failed to register input device: %d\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int surface3_spi_probe(struct spi_device *spi)\n{\n\tstruct surface3_ts_data *data;\n\tint error;\n\n\t \n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_0;\n\terror = spi_setup(spi);\n\tif (error)\n\t\treturn error;\n\n\tdata = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->spi = spi;\n\tspi_set_drvdata(spi, data);\n\n\terror = surface3_spi_get_gpio_config(data);\n\tif (error)\n\t\treturn error;\n\n\tsurface3_spi_power(data, true);\n\tsurface3_spi_power(data, false);\n\tsurface3_spi_power(data, true);\n\n\terror = surface3_spi_create_touch_input(data);\n\tif (error)\n\t\treturn error;\n\n\terror = surface3_spi_create_pen_input(data);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&spi->dev, spi->irq,\n\t\t\t\t\t  NULL, surface3_spi_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"Surface3-irq\", data);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int surface3_spi_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct surface3_ts_data *data = spi_get_drvdata(spi);\n\n\tdisable_irq(data->spi->irq);\n\n\tsurface3_spi_power(data, false);\n\n\treturn 0;\n}\n\nstatic int surface3_spi_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct surface3_ts_data *data = spi_get_drvdata(spi);\n\n\tsurface3_spi_power(data, true);\n\n\tenable_irq(data->spi->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(surface3_spi_pm_ops,\n\t\t\t\tsurface3_spi_suspend,\n\t\t\t\tsurface3_spi_resume);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id surface3_spi_acpi_match[] = {\n\t{ \"MSHW0037\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, surface3_spi_acpi_match);\n#endif\n\nstatic struct spi_driver surface3_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"Surface3-spi\",\n\t\t.acpi_match_table = ACPI_PTR(surface3_spi_acpi_match),\n\t\t.pm = pm_sleep_ptr(&surface3_spi_pm_ops),\n\t},\n\t.probe = surface3_spi_probe,\n};\n\nmodule_spi_driver(surface3_spi_driver);\n\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_DESCRIPTION(\"Surface 3 SPI touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}