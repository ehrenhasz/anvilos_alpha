{
  "module_name": "elants_i2c.c",
  "hash_id": "804be8bb1096d3f3eb57bcb59336ab1ff91218229449d0fa230ba70b00cfb4af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/elants_i2c.c",
  "human_readable_source": "\n \n\n\n#include <linux/bits.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/async.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/uuid.h>\n#include <asm/unaligned.h>\n\n \n#define DEVICE_NAME\t\"elants_i2c\"\n\n \n#define ELAN_TS_RESOLUTION(n, m)   (((n) - 1) * (m))\n\n \n#define HEADER_SIZE\t\t4\n#define FW_HDR_TYPE\t\t0\n#define FW_HDR_COUNT\t\t1\n#define FW_HDR_LENGTH\t\t2\n\n \n#define QUEUE_HEADER_SINGLE\t0x62\n#define QUEUE_HEADER_NORMAL\t0X63\n#define QUEUE_HEADER_WAIT\t0x64\n#define QUEUE_HEADER_NORMAL2\t0x66\n\n \n#define CMD_HEADER_WRITE\t0x54\n#define CMD_HEADER_READ\t\t0x53\n#define CMD_HEADER_6B_READ\t0x5B\n#define CMD_HEADER_ROM_READ\t0x96\n#define CMD_HEADER_RESP\t\t0x52\n#define CMD_HEADER_6B_RESP\t0x9B\n#define CMD_HEADER_ROM_RESP\t0x95\n#define CMD_HEADER_HELLO\t0x55\n#define CMD_HEADER_REK\t\t0x66\n\n \n#define PACKET_SIZE_OLD\t\t40\n#define PACKET_SIZE\t\t55\n#define MAX_CONTACT_NUM\t\t10\n#define FW_POS_HEADER\t\t0\n#define FW_POS_STATE\t\t1\n#define FW_POS_TOTAL\t\t2\n#define FW_POS_XY\t\t3\n#define FW_POS_TOOL_TYPE\t33\n#define FW_POS_CHECKSUM\t\t34\n#define FW_POS_WIDTH\t\t35\n#define FW_POS_PRESSURE\t\t45\n\n#define HEADER_REPORT_10_FINGER\t0x62\n\n \n#define MAX_PACKET_SIZE\t\t169\n\n#define BOOT_TIME_DELAY_MS\t50\n\n \n#define E_ELAN_INFO_FW_VER\t0x00\n#define E_ELAN_INFO_BC_VER\t0x10\n#define E_ELAN_INFO_X_RES\t0x60\n#define E_ELAN_INFO_Y_RES\t0x63\n#define E_ELAN_INFO_REK\t\t0xD0\n#define E_ELAN_INFO_TEST_VER\t0xE0\n#define E_ELAN_INFO_FW_ID\t0xF0\n#define E_INFO_OSR\t\t0xD6\n#define E_INFO_PHY_SCAN\t\t0xD7\n#define E_INFO_PHY_DRIVER\t0xD8\n\n \n#define E_POWER_STATE_SLEEP\t0x50\n#define E_POWER_STATE_RESUME\t0x58\n\n#define MAX_RETRIES\t\t3\n#define MAX_FW_UPDATE_RETRIES\t30\n\n#define ELAN_FW_PAGESIZE\t132\n\n \n#define ELAN_CALI_TIMEOUT_MSEC\t12000\n\n#define ELAN_POWERON_DELAY_USEC\t5000\n#define ELAN_RESET_DELAY_MSEC\t20\n\n \n#define BC_VER_H_BYTE_FOR_EKTH3900x1_I2C        0x72\n#define BC_VER_H_BYTE_FOR_EKTH3900x2_I2C        0x82\n#define BC_VER_H_BYTE_FOR_EKTH3900x3_I2C        0x92\n#define BC_VER_H_BYTE_FOR_EKTH5312x1_I2C        0x6D\n#define BC_VER_H_BYTE_FOR_EKTH5312x2_I2C        0x6E\n#define BC_VER_H_BYTE_FOR_EKTH5312cx1_I2C       0x77\n#define BC_VER_H_BYTE_FOR_EKTH5312cx2_I2C       0x78\n#define BC_VER_H_BYTE_FOR_EKTH5312x1_I2C_USB    0x67\n#define BC_VER_H_BYTE_FOR_EKTH5312x2_I2C_USB    0x68\n#define BC_VER_H_BYTE_FOR_EKTH5312cx1_I2C_USB   0x74\n#define BC_VER_H_BYTE_FOR_EKTH5312cx2_I2C_USB   0x75\n\nenum elants_chip_id {\n\tEKTH3500,\n\tEKTF3624,\n};\n\nenum elants_state {\n\tELAN_STATE_NORMAL,\n\tELAN_WAIT_QUEUE_HEADER,\n\tELAN_WAIT_RECALIBRATION,\n};\n\nenum elants_iap_mode {\n\tELAN_IAP_OPERATIONAL,\n\tELAN_IAP_RECOVERY,\n};\n\n \nstruct elants_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\n\tstruct regulator *vcc33;\n\tstruct regulator *vccio;\n\tstruct gpio_desc *reset_gpio;\n\n\tu16 fw_version;\n\tu8 test_version;\n\tu8 solution_version;\n\tu8 bc_version;\n\tu8 iap_version;\n\tu16 hw_version;\n\tu8 major_res;\n\tunsigned int x_res;\t \n\tunsigned int y_res;\n\tunsigned int x_max;\n\tunsigned int y_max;\n\tunsigned int phy_x;\n\tunsigned int phy_y;\n\tstruct touchscreen_properties prop;\n\n\tenum elants_state state;\n\tenum elants_chip_id chip_id;\n\tenum elants_iap_mode iap_mode;\n\n\t \n\tstruct mutex sysfs_mutex;\n\n\tu8 cmd_resp[HEADER_SIZE];\n\tstruct completion cmd_done;\n\n\tbool keep_power_in_suspend;\n\n\t \n\tu8 buf[MAX_PACKET_SIZE] ____cacheline_aligned;\n};\n\nstatic int elants_i2c_send(struct i2c_client *client,\n\t\t\t   const void *data, size_t size)\n{\n\tint ret;\n\n\tret = i2c_master_send(client, data, size);\n\tif (ret == size)\n\t\treturn 0;\n\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tdev_err(&client->dev, \"%s failed (%*ph): %d\\n\",\n\t\t__func__, (int)size, data, ret);\n\n\treturn ret;\n}\n\nstatic int elants_i2c_read(struct i2c_client *client, void *data, size_t size)\n{\n\tint ret;\n\n\tret = i2c_master_recv(client, data, size);\n\tif (ret == size)\n\t\treturn 0;\n\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tdev_err(&client->dev, \"%s failed: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int elants_i2c_execute_command(struct i2c_client *client,\n\t\t\t\t      const u8 *cmd, size_t cmd_size,\n\t\t\t\t      u8 *resp, size_t resp_size,\n\t\t\t\t      int retries, const char *cmd_name)\n{\n\tstruct i2c_msg msgs[2];\n\tint ret;\n\tu8 expected_response;\n\n\tswitch (cmd[0]) {\n\tcase CMD_HEADER_READ:\n\t\texpected_response = CMD_HEADER_RESP;\n\t\tbreak;\n\n\tcase CMD_HEADER_6B_READ:\n\t\texpected_response = CMD_HEADER_6B_RESP;\n\t\tbreak;\n\n\tcase CMD_HEADER_ROM_READ:\n\t\texpected_response = CMD_HEADER_ROM_RESP;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&client->dev, \"(%s): invalid command: %*ph\\n\",\n\t\t\tcmd_name, (int)cmd_size, cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (;;) {\n\t\tmsgs[0].addr = client->addr;\n\t\tmsgs[0].flags = client->flags & I2C_M_TEN;\n\t\tmsgs[0].len = cmd_size;\n\t\tmsgs[0].buf = (u8 *)cmd;\n\n\t\tmsgs[1].addr = client->addr;\n\t\tmsgs[1].flags = (client->flags & I2C_M_TEN) | I2C_M_RD;\n\t\tmsgs[1].flags |= I2C_M_RD;\n\t\tmsgs[1].len = resp_size;\n\t\tmsgs[1].buf = resp;\n\n\t\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\t\tif (ret < 0) {\n\t\t\tif (--retries > 0) {\n\t\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\t\"(%s) I2C transfer failed: %pe (retrying)\\n\",\n\t\t\t\t\tcmd_name, ERR_PTR(ret));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"(%s) I2C transfer failed: %pe\\n\",\n\t\t\t\tcmd_name, ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret != ARRAY_SIZE(msgs) ||\n\t\t    resp[FW_HDR_TYPE] != expected_response) {\n\t\t\tif (--retries > 0) {\n\t\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\t\"(%s) unexpected response: %*ph (retrying)\\n\",\n\t\t\t\t\tcmd_name, ret, resp);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"(%s) unexpected response: %*ph\\n\",\n\t\t\t\tcmd_name, ret, resp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nstatic int elants_i2c_calibrate(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret, error;\n\tstatic const u8 w_flashkey[] = { CMD_HEADER_WRITE, 0xC0, 0xE1, 0x5A };\n\tstatic const u8 rek[] = { CMD_HEADER_WRITE, 0x29, 0x00, 0x01 };\n\tstatic const u8 rek_resp[] = { CMD_HEADER_REK, 0x66, 0x66, 0x66 };\n\n\tdisable_irq(client->irq);\n\n\tts->state = ELAN_WAIT_RECALIBRATION;\n\treinit_completion(&ts->cmd_done);\n\n\telants_i2c_send(client, w_flashkey, sizeof(w_flashkey));\n\telants_i2c_send(client, rek, sizeof(rek));\n\n\tenable_irq(client->irq);\n\n\tret = wait_for_completion_interruptible_timeout(&ts->cmd_done,\n\t\t\t\tmsecs_to_jiffies(ELAN_CALI_TIMEOUT_MSEC));\n\n\tts->state = ELAN_STATE_NORMAL;\n\n\tif (ret <= 0) {\n\t\terror = ret < 0 ? ret : -ETIMEDOUT;\n\t\tdev_err(&client->dev,\n\t\t\t\"error while waiting for calibration to complete: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (memcmp(rek_resp, ts->cmd_resp, sizeof(rek_resp))) {\n\t\tdev_err(&client->dev,\n\t\t\t\"unexpected calibration response: %*ph\\n\",\n\t\t\t(int)sizeof(ts->cmd_resp), ts->cmd_resp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int elants_i2c_sw_reset(struct i2c_client *client)\n{\n\tconst u8 soft_rst_cmd[] = { 0x77, 0x77, 0x77, 0x77 };\n\tint error;\n\n\terror = elants_i2c_send(client, soft_rst_cmd,\n\t\t\t\tsizeof(soft_rst_cmd));\n\tif (error) {\n\t\tdev_err(&client->dev, \"software reset failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tmsleep(30);\n\n\treturn 0;\n}\n\nstatic u16 elants_i2c_parse_version(u8 *buf)\n{\n\treturn get_unaligned_be32(buf) >> 4;\n}\n\nstatic int elants_i2c_query_hw_version(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint retry_cnt = MAX_RETRIES;\n\tconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_FW_ID, 0x00, 0x01 };\n\tu8 resp[HEADER_SIZE];\n\tint error;\n\n\twhile (retry_cnt--) {\n\t\terror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\n\t\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t\t   \"read fw id\");\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tts->hw_version = elants_i2c_parse_version(resp);\n\t\tif (ts->hw_version != 0xffff)\n\t\t\treturn 0;\n\t}\n\n\tdev_err(&client->dev, \"Invalid fw id: %#04x\\n\", ts->hw_version);\n\n\treturn -EINVAL;\n}\n\nstatic int elants_i2c_query_fw_version(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint retry_cnt = MAX_RETRIES;\n\tconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_FW_VER, 0x00, 0x01 };\n\tu8 resp[HEADER_SIZE];\n\tint error;\n\n\twhile (retry_cnt--) {\n\t\terror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\n\t\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t\t   \"read fw version\");\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tts->fw_version = elants_i2c_parse_version(resp);\n\t\tif (ts->fw_version != 0x0000 && ts->fw_version != 0xffff)\n\t\t\treturn 0;\n\n\t\tdev_dbg(&client->dev, \"(read fw version) resp %*phC\\n\",\n\t\t\t(int)sizeof(resp), resp);\n\t}\n\n\tdev_err(&client->dev, \"Invalid fw ver: %#04x\\n\", ts->fw_version);\n\n\treturn -EINVAL;\n}\n\nstatic int elants_i2c_query_test_version(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error;\n\tu16 version;\n\tconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_TEST_VER, 0x00, 0x01 };\n\tu8 resp[HEADER_SIZE];\n\n\terror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\n\t\t\t\t\t   resp, sizeof(resp), MAX_RETRIES,\n\t\t\t\t\t   \"read test version\");\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read test version\\n\");\n\t\treturn error;\n\t}\n\n\tversion = elants_i2c_parse_version(resp);\n\tts->test_version = version >> 8;\n\tts->solution_version = version & 0xff;\n\n\treturn 0;\n}\n\nstatic int elants_i2c_query_bc_version(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_BC_VER, 0x00, 0x01 };\n\tu8 resp[HEADER_SIZE];\n\tu16 version;\n\tint error;\n\n\terror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"read BC version\");\n\tif (error)\n\t\treturn error;\n\n\tversion = elants_i2c_parse_version(resp);\n\tts->bc_version = version >> 8;\n\tts->iap_version = version & 0xff;\n\n\treturn 0;\n}\n\nstatic int elants_i2c_query_ts_info_ektf(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error;\n\tu8 resp[4];\n\tu16 phy_x, phy_y;\n\tconst u8 get_xres_cmd[] = {\n\t\tCMD_HEADER_READ, E_ELAN_INFO_X_RES, 0x00, 0x00\n\t};\n\tconst u8 get_yres_cmd[] = {\n\t\tCMD_HEADER_READ, E_ELAN_INFO_Y_RES, 0x00, 0x00\n\t};\n\n\t \n\terror = elants_i2c_execute_command(client, get_xres_cmd,\n\t\t\t\t\t   sizeof(get_xres_cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"get X size\");\n\tif (error)\n\t\treturn error;\n\n\tphy_x = resp[2] | ((resp[3] & 0xF0) << 4);\n\n\terror = elants_i2c_execute_command(client, get_yres_cmd,\n\t\t\t\t\t   sizeof(get_yres_cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"get Y size\");\n\tif (error)\n\t\treturn error;\n\n\tphy_y = resp[2] | ((resp[3] & 0xF0) << 4);\n\n\tdev_dbg(&client->dev, \"phy_x=%d, phy_y=%d\\n\", phy_x, phy_y);\n\n\tts->phy_x = phy_x;\n\tts->phy_y = phy_y;\n\n\t \n\tts->x_max = 2240 - 1;\n\tts->y_max = 1408 - 1;\n\n\treturn 0;\n}\n\nstatic int elants_i2c_query_ts_info_ekth(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error;\n\tu8 resp[17];\n\tu16 phy_x, phy_y, rows, cols, osr;\n\tconst u8 get_resolution_cmd[] = {\n\t\tCMD_HEADER_6B_READ, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tconst u8 get_osr_cmd[] = {\n\t\tCMD_HEADER_READ, E_INFO_OSR, 0x00, 0x01\n\t};\n\tconst u8 get_physical_scan_cmd[] = {\n\t\tCMD_HEADER_READ, E_INFO_PHY_SCAN, 0x00, 0x01\n\t};\n\tconst u8 get_physical_drive_cmd[] = {\n\t\tCMD_HEADER_READ, E_INFO_PHY_DRIVER, 0x00, 0x01\n\t};\n\n\t \n\terror = elants_i2c_execute_command(client,\n\t\t\t\t\t   get_resolution_cmd,\n\t\t\t\t\t   sizeof(get_resolution_cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"get resolution\");\n\tif (error)\n\t\treturn error;\n\n\trows = resp[2] + resp[6] + resp[10];\n\tcols = resp[3] + resp[7] + resp[11];\n\n\t \n\tts->major_res = resp[16];\n\n\t \n\terror = elants_i2c_execute_command(client,\n\t\t\t\t\t   get_osr_cmd, sizeof(get_osr_cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1, \"get osr\");\n\tif (error)\n\t\treturn error;\n\n\tosr = resp[3];\n\n\terror = elants_i2c_execute_command(client,\n\t\t\t\t\t   get_physical_scan_cmd,\n\t\t\t\t\t   sizeof(get_physical_scan_cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"get physical scan\");\n\tif (error)\n\t\treturn error;\n\n\tphy_x = get_unaligned_be16(&resp[2]);\n\n\terror = elants_i2c_execute_command(client,\n\t\t\t\t\t   get_physical_drive_cmd,\n\t\t\t\t\t   sizeof(get_physical_drive_cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"get physical drive\");\n\tif (error)\n\t\treturn error;\n\n\tphy_y = get_unaligned_be16(&resp[2]);\n\n\tdev_dbg(&client->dev, \"phy_x=%d, phy_y=%d\\n\", phy_x, phy_y);\n\n\tif (rows == 0 || cols == 0 || osr == 0) {\n\t\tdev_warn(&client->dev,\n\t\t\t \"invalid trace number data: %d, %d, %d\\n\",\n\t\t\t rows, cols, osr);\n\t} else {\n\t\t \n\t\tts->x_max = ELAN_TS_RESOLUTION(rows, osr);\n\t\tts->x_res = DIV_ROUND_CLOSEST(ts->x_max, phy_x);\n\t\tts->y_max = ELAN_TS_RESOLUTION(cols, osr);\n\t\tts->y_res = DIV_ROUND_CLOSEST(ts->y_max, phy_y);\n\t\tts->phy_x = phy_x;\n\t\tts->phy_y = phy_y;\n\t}\n\n\treturn 0;\n}\n\nstatic int elants_i2c_fastboot(struct i2c_client *client)\n{\n\tconst u8 boot_cmd[] = { 0x4D, 0x61, 0x69, 0x6E };\n\tint error;\n\n\terror = elants_i2c_send(client, boot_cmd, sizeof(boot_cmd));\n\tif (error) {\n\t\tdev_err(&client->dev, \"boot failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tdev_dbg(&client->dev, \"boot success -- 0x%x\\n\", client->addr);\n\treturn 0;\n}\n\nstatic int elants_i2c_initialize(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error, error2, retry_cnt;\n\tconst u8 hello_packet[] = { 0x55, 0x55, 0x55, 0x55 };\n\tconst u8 recov_packet[] = { 0x55, 0x55, 0x80, 0x80 };\n\tu8 buf[HEADER_SIZE];\n\n\tfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\n\t\terror = elants_i2c_sw_reset(client);\n\t\tif (error) {\n\t\t\t \n\t\t\tif (retry_cnt < MAX_RETRIES - 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terror = elants_i2c_fastboot(client);\n\t\tif (error) {\n\t\t\t \n\t\t\tif (retry_cnt < MAX_RETRIES - 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmsleep(BOOT_TIME_DELAY_MS);\n\n\t\terror = elants_i2c_read(client, buf, sizeof(buf));\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to read 'hello' packet: %d\\n\", error);\n\t\t} else if (!memcmp(buf, hello_packet, sizeof(hello_packet))) {\n\t\t\tts->iap_mode = ELAN_IAP_OPERATIONAL;\n\t\t\tbreak;\n\t\t} else if (!memcmp(buf, recov_packet, sizeof(recov_packet))) {\n\t\t\t \n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"invalid 'hello' packet: %*ph\\n\",\n\t\t\t\t(int)sizeof(buf), buf);\n\t\t}\n\t}\n\n\t \n\terror2 = elants_i2c_query_hw_version(ts);\n\tif (!error2)\n\t\terror2 = elants_i2c_query_bc_version(ts);\n\tif (!error)\n\t\terror = error2;\n\n\tif (!error)\n\t\terror = elants_i2c_query_fw_version(ts);\n\tif (!error)\n\t\terror = elants_i2c_query_test_version(ts);\n\n\tswitch (ts->chip_id) {\n\tcase EKTH3500:\n\t\tif (!error)\n\t\t\terror = elants_i2c_query_ts_info_ekth(ts);\n\t\tbreak;\n\tcase EKTF3624:\n\t\tif (!error)\n\t\t\terror = elants_i2c_query_ts_info_ektf(ts);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (error)\n\t\tts->iap_mode = ELAN_IAP_RECOVERY;\n\n\treturn 0;\n}\n\n \n\nstatic int elants_i2c_fw_write_page(struct i2c_client *client,\n\t\t\t\t    const void *page)\n{\n\tconst u8 ack_ok[] = { 0xaa, 0xaa };\n\tu8 buf[2];\n\tint retry;\n\tint error;\n\n\tfor (retry = 0; retry < MAX_FW_UPDATE_RETRIES; retry++) {\n\t\terror = elants_i2c_send(client, page, ELAN_FW_PAGESIZE);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"IAP Write Page failed: %d\\n\", error);\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = elants_i2c_read(client, buf, 2);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"IAP Ack read failed: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (!memcmp(buf, ack_ok, sizeof(ack_ok)))\n\t\t\treturn 0;\n\n\t\terror = -EIO;\n\t\tdev_err(&client->dev,\n\t\t\t\"IAP Get Ack Error [%02x:%02x]\\n\",\n\t\t\tbuf[0], buf[1]);\n\t}\n\n\treturn error;\n}\n\nstatic int elants_i2c_validate_remark_id(struct elants_data *ts,\n\t\t\t\t\t const struct firmware *fw)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error;\n\tconst u8 cmd[] = { CMD_HEADER_ROM_READ, 0x80, 0x1F, 0x00, 0x00, 0x21 };\n\tu8 resp[6] = { 0 };\n\tu16 ts_remark_id = 0;\n\tu16 fw_remark_id = 0;\n\n\t \n\terror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\n\t\t\t\t\t   resp, sizeof(resp),\n\t\t\t\t\t   1, \"read Remark ID\");\n\tif (error)\n\t\treturn error;\n\n\tts_remark_id = get_unaligned_be16(&resp[3]);\n\n\tfw_remark_id = get_unaligned_le16(&fw->data[fw->size - 4]);\n\n\tif (fw_remark_id != ts_remark_id) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Remark ID Mismatched: ts_remark_id=0x%04x, fw_remark_id=0x%04x.\\n\",\n\t\t\tts_remark_id, fw_remark_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool elants_i2c_should_check_remark_id(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst u8 bootcode_version = ts->iap_version;\n\tbool check;\n\n\t \n\tif ((bootcode_version == BC_VER_H_BYTE_FOR_EKTH3900x1_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH3900x2_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH3900x3_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312x1_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312x2_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312cx1_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312cx2_I2C) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312x1_I2C_USB) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312x2_I2C_USB) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312cx1_I2C_USB) ||\n\t    (bootcode_version == BC_VER_H_BYTE_FOR_EKTH5312cx2_I2C_USB)) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"eKTH3900/eKTH5312(0x%02x) are not support remark id\\n\",\n\t\t\tbootcode_version);\n\t\tcheck = false;\n\t} else if (bootcode_version >= 0x60) {\n\t\tcheck = true;\n\t} else {\n\t\tcheck = false;\n\t}\n\n\treturn check;\n}\n\nstatic int elants_i2c_do_update_firmware(struct i2c_client *client,\n\t\t\t\t\t const struct firmware *fw,\n\t\t\t\t\t bool force)\n{\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\tconst u8 enter_iap[] = { 0x45, 0x49, 0x41, 0x50 };\n\tconst u8 enter_iap2[] = { 0x54, 0x00, 0x12, 0x34 };\n\tconst u8 iap_ack[] = { 0x55, 0xaa, 0x33, 0xcc };\n\tconst u8 close_idle[] = { 0x54, 0x2c, 0x01, 0x01 };\n\tu8 buf[HEADER_SIZE];\n\tu16 send_id;\n\tint page, n_fw_pages;\n\tint error;\n\tbool check_remark_id = elants_i2c_should_check_remark_id(ts);\n\n\t \n\tif (force) {\n\t\tdev_dbg(&client->dev, \"Recovery mode procedure\\n\");\n\n\t\tif (check_remark_id) {\n\t\t\terror = elants_i2c_validate_remark_id(ts, fw);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = elants_i2c_send(client, enter_iap2, sizeof(enter_iap2));\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to enter IAP mode: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t} else {\n\t\t \n\t\tdev_dbg(&client->dev, \"Normal IAP procedure\\n\");\n\n\t\t \n\t\terror = elants_i2c_send(client, close_idle, sizeof(close_idle));\n\t\tif (error)\n\t\t\tdev_err(&client->dev, \"Failed close idle: %d\\n\", error);\n\t\tmsleep(60);\n\n\t\telants_i2c_sw_reset(client);\n\t\tmsleep(20);\n\n\t\tif (check_remark_id) {\n\t\t\terror = elants_i2c_validate_remark_id(ts, fw);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = elants_i2c_send(client, enter_iap, sizeof(enter_iap));\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"failed to enter IAP mode: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tmsleep(20);\n\n\t \n\terror = elants_i2c_read(client, buf, 4);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to read IAP acknowledgement: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (memcmp(buf, iap_ack, sizeof(iap_ack))) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to enter IAP: %*ph (expected %*ph)\\n\",\n\t\t\t(int)sizeof(buf), buf, (int)sizeof(iap_ack), iap_ack);\n\t\treturn -EIO;\n\t}\n\n\tdev_info(&client->dev, \"successfully entered IAP mode\");\n\n\tsend_id = client->addr;\n\terror = elants_i2c_send(client, &send_id, 1);\n\tif (error) {\n\t\tdev_err(&client->dev, \"sending dummy byte failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\terror = elants_i2c_send(client, fw->data, ELAN_FW_PAGESIZE);\n\tif (error) {\n\t\tdev_err(&client->dev, \"clearing of the last page failed: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = elants_i2c_read(client, buf, 2);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to read ACK for clearing the last page: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tn_fw_pages = fw->size / ELAN_FW_PAGESIZE;\n\tdev_dbg(&client->dev, \"IAP Pages = %d\\n\", n_fw_pages);\n\n\tfor (page = 0; page < n_fw_pages; page++) {\n\t\terror = elants_i2c_fw_write_page(client,\n\t\t\t\t\tfw->data + page * ELAN_FW_PAGESIZE);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to write FW page %d: %d\\n\",\n\t\t\t\tpage, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t \n\tmsleep(300);\n\n\tdev_info(&client->dev, \"firmware update completed\\n\");\n\treturn 0;\n}\n\nstatic int elants_i2c_fw_update(struct elants_data *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst struct firmware *fw;\n\tchar *fw_name;\n\tint error;\n\n\tfw_name = kasprintf(GFP_KERNEL, \"elants_i2c_%04x.bin\", ts->hw_version);\n\tif (!fw_name)\n\t\treturn -ENOMEM;\n\n\tdev_info(&client->dev, \"requesting fw name = %s\\n\", fw_name);\n\terror = request_firmware(&fw, fw_name, &client->dev);\n\tkfree(fw_name);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to request firmware: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (fw->size % ELAN_FW_PAGESIZE) {\n\t\tdev_err(&client->dev, \"invalid firmware length: %zu\\n\",\n\t\t\tfw->size);\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdisable_irq(client->irq);\n\n\terror = elants_i2c_do_update_firmware(client, fw,\n\t\t\t\t\tts->iap_mode == ELAN_IAP_RECOVERY);\n\tif (error) {\n\t\tdev_err(&client->dev, \"firmware update failed: %d\\n\", error);\n\t\tts->iap_mode = ELAN_IAP_RECOVERY;\n\t\tgoto out_enable_irq;\n\t}\n\n\terror = elants_i2c_initialize(ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to initialize device after firmware update: %d\\n\",\n\t\t\terror);\n\t\tts->iap_mode = ELAN_IAP_RECOVERY;\n\t\tgoto out_enable_irq;\n\t}\n\n\tts->iap_mode = ELAN_IAP_OPERATIONAL;\n\nout_enable_irq:\n\tts->state = ELAN_STATE_NORMAL;\n\tenable_irq(client->irq);\n\tmsleep(100);\n\n\tif (!error)\n\t\telants_i2c_calibrate(ts);\nout:\n\trelease_firmware(fw);\n\treturn error;\n}\n\n \n\nstatic void elants_i2c_mt_event(struct elants_data *ts, u8 *buf,\n\t\t\t\tsize_t packet_size)\n{\n\tstruct input_dev *input = ts->input;\n\tunsigned int n_fingers;\n\tunsigned int tool_type;\n\tu16 finger_state;\n\tint i;\n\n\tn_fingers = buf[FW_POS_STATE + 1] & 0x0f;\n\tfinger_state = ((buf[FW_POS_STATE + 1] & 0x30) << 4) |\n\t\t\tbuf[FW_POS_STATE];\n\n\tdev_dbg(&ts->client->dev,\n\t\t\"n_fingers: %u, state: %04x\\n\",  n_fingers, finger_state);\n\n\t \n\ttool_type = buf[FW_POS_TOOL_TYPE] & BIT(0) ?\n\t\t\tMT_TOOL_FINGER : MT_TOOL_PALM;\n\n\tfor (i = 0; i < MAX_CONTACT_NUM && n_fingers; i++) {\n\t\tif (finger_state & 1) {\n\t\t\tunsigned int x, y, p, w;\n\t\t\tu8 *pos;\n\n\t\t\tpos = &buf[FW_POS_XY + i * 3];\n\t\t\tx = (((u16)pos[0] & 0xf0) << 4) | pos[1];\n\t\t\ty = (((u16)pos[0] & 0x0f) << 8) | pos[2];\n\n\t\t\t \n\t\t\tif (packet_size == PACKET_SIZE_OLD &&\n\t\t\t    ts->chip_id == EKTF3624) {\n\t\t\t\tw = buf[FW_POS_WIDTH + i / 2];\n\t\t\t\tw >>= 4 * (~i & 1);\n\t\t\t\tw |= w << 4;\n\t\t\t\tw |= !w;\n\t\t\t\tp = w;\n\t\t\t} else {\n\t\t\t\tp = buf[FW_POS_PRESSURE + i];\n\t\t\t\tw = buf[FW_POS_WIDTH + i];\n\t\t\t}\n\n\t\t\tdev_dbg(&ts->client->dev, \"i=%d x=%d y=%d p=%d w=%d\\n\",\n\t\t\t\ti, x, y, p, w);\n\n\t\t\tinput_mt_slot(input, i);\n\t\t\tinput_mt_report_slot_state(input, tool_type, true);\n\t\t\ttouchscreen_report_pos(input, &ts->prop, x, y, true);\n\t\t\tinput_event(input, EV_ABS, ABS_MT_PRESSURE, p);\n\t\t\tinput_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, w);\n\n\t\t\tn_fingers--;\n\t\t}\n\n\t\tfinger_state >>= 1;\n\t}\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n}\n\nstatic u8 elants_i2c_calculate_checksum(u8 *buf)\n{\n\tu8 checksum = 0;\n\tu8 i;\n\n\tfor (i = 0; i < FW_POS_CHECKSUM; i++)\n\t\tchecksum += buf[i];\n\n\treturn checksum;\n}\n\nstatic void elants_i2c_event(struct elants_data *ts, u8 *buf,\n\t\t\t     size_t packet_size)\n{\n\tu8 checksum = elants_i2c_calculate_checksum(buf);\n\n\tif (unlikely(buf[FW_POS_CHECKSUM] != checksum))\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"%s: invalid checksum for packet %02x: %02x vs. %02x\\n\",\n\t\t\t __func__, buf[FW_POS_HEADER],\n\t\t\t checksum, buf[FW_POS_CHECKSUM]);\n\telse if (unlikely(buf[FW_POS_HEADER] != HEADER_REPORT_10_FINGER))\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"%s: unknown packet type: %02x\\n\",\n\t\t\t __func__, buf[FW_POS_HEADER]);\n\telse\n\t\telants_i2c_mt_event(ts, buf, packet_size);\n}\n\nstatic irqreturn_t elants_i2c_irq(int irq, void *_dev)\n{\n\tconst u8 wait_packet[] = { 0x64, 0x64, 0x64, 0x64 };\n\tstruct elants_data *ts = _dev;\n\tstruct i2c_client *client = ts->client;\n\tint report_count, report_len;\n\tint i;\n\tint len;\n\n\tlen = i2c_master_recv_dmasafe(client, ts->buf, sizeof(ts->buf));\n\tif (len < 0) {\n\t\tdev_err(&client->dev, \"%s: failed to read data: %d\\n\",\n\t\t\t__func__, len);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&client->dev, \"%s: packet %*ph\\n\",\n\t\t__func__, HEADER_SIZE, ts->buf);\n\n\tswitch (ts->state) {\n\tcase ELAN_WAIT_RECALIBRATION:\n\t\tif (ts->buf[FW_HDR_TYPE] == CMD_HEADER_REK) {\n\t\t\tmemcpy(ts->cmd_resp, ts->buf, sizeof(ts->cmd_resp));\n\t\t\tcomplete(&ts->cmd_done);\n\t\t\tts->state = ELAN_STATE_NORMAL;\n\t\t}\n\t\tbreak;\n\n\tcase ELAN_WAIT_QUEUE_HEADER:\n\t\tif (ts->buf[FW_HDR_TYPE] != QUEUE_HEADER_NORMAL)\n\t\t\tbreak;\n\n\t\tts->state = ELAN_STATE_NORMAL;\n\t\tfallthrough;\n\n\tcase ELAN_STATE_NORMAL:\n\n\t\tswitch (ts->buf[FW_HDR_TYPE]) {\n\t\tcase CMD_HEADER_HELLO:\n\t\tcase CMD_HEADER_RESP:\n\t\t\tbreak;\n\n\t\tcase QUEUE_HEADER_WAIT:\n\t\t\tif (memcmp(ts->buf, wait_packet, sizeof(wait_packet))) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"invalid wait packet %*ph\\n\",\n\t\t\t\t\tHEADER_SIZE, ts->buf);\n\t\t\t} else {\n\t\t\t\tts->state = ELAN_WAIT_QUEUE_HEADER;\n\t\t\t\tudelay(30);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QUEUE_HEADER_SINGLE:\n\t\t\telants_i2c_event(ts, &ts->buf[HEADER_SIZE],\n\t\t\t\t\t ts->buf[FW_HDR_LENGTH]);\n\t\t\tbreak;\n\n\t\tcase QUEUE_HEADER_NORMAL2:  \n\t\t\t \n\t\t\tif (ts->chip_id != EKTF3624)\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\n\t\tcase QUEUE_HEADER_NORMAL:\n\t\t\treport_count = ts->buf[FW_HDR_COUNT];\n\t\t\tif (report_count == 0 || report_count > 3) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"bad report count: %*ph\\n\",\n\t\t\t\t\tHEADER_SIZE, ts->buf);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treport_len = ts->buf[FW_HDR_LENGTH] / report_count;\n\n\t\t\tif (report_len == PACKET_SIZE_OLD &&\n\t\t\t    ts->chip_id == EKTF3624) {\n\t\t\t\tdev_dbg_once(&client->dev,\n\t\t\t\t\t     \"using old report format\\n\");\n\t\t\t} else if (report_len != PACKET_SIZE) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"mismatching report length: %*ph\\n\",\n\t\t\t\t\tHEADER_SIZE, ts->buf);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < report_count; i++) {\n\t\t\t\tu8 *buf = ts->buf + HEADER_SIZE +\n\t\t\t\t\t\t\ti * report_len;\n\t\t\t\telants_i2c_event(ts, buf, report_len);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&client->dev, \"unknown packet %*ph\\n\",\n\t\t\t\tHEADER_SIZE, ts->buf);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic ssize_t calibrate_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\tint error;\n\n\terror = mutex_lock_interruptible(&ts->sysfs_mutex);\n\tif (error)\n\t\treturn error;\n\n\terror = elants_i2c_calibrate(ts);\n\n\tmutex_unlock(&ts->sysfs_mutex);\n\treturn error ?: count;\n}\n\nstatic ssize_t write_update_fw(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\tint error;\n\n\terror = mutex_lock_interruptible(&ts->sysfs_mutex);\n\tif (error)\n\t\treturn error;\n\n\terror = elants_i2c_fw_update(ts);\n\tdev_dbg(dev, \"firmware update result: %d\\n\", error);\n\n\tmutex_unlock(&ts->sysfs_mutex);\n\treturn error ?: count;\n}\n\nstatic ssize_t show_iap_mode(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       ts->iap_mode == ELAN_IAP_OPERATIONAL ?\n\t\t\t\t\"Normal\" : \"Recovery\");\n}\n\nstatic ssize_t show_calibration_count(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_REK, 0x00, 0x01 };\n\tu8 resp[HEADER_SIZE];\n\tu16 rek_count;\n\tint error;\n\n\terror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\n\t\t\t\t\t   resp, sizeof(resp), 1,\n\t\t\t\t\t   \"read ReK status\");\n\tif (error)\n\t\treturn sprintf(buf, \"%d\\n\", error);\n\n\trek_count = get_unaligned_be16(&resp[2]);\n\treturn sprintf(buf, \"0x%04x\\n\", rek_count);\n}\n\nstatic DEVICE_ATTR_WO(calibrate);\nstatic DEVICE_ATTR(iap_mode, S_IRUGO, show_iap_mode, NULL);\nstatic DEVICE_ATTR(calibration_count, S_IRUGO, show_calibration_count, NULL);\nstatic DEVICE_ATTR(update_fw, S_IWUSR, NULL, write_update_fw);\n\nstruct elants_version_attribute {\n\tstruct device_attribute dattr;\n\tsize_t field_offset;\n\tsize_t field_size;\n};\n\n#define __ELANTS_FIELD_SIZE(_field)\t\t\t\t\t\\\n\tsizeof(((struct elants_data *)NULL)->_field)\n#define __ELANTS_VERIFY_SIZE(_field)\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO(__ELANTS_FIELD_SIZE(_field) > 2) +\t\t\\\n\t __ELANTS_FIELD_SIZE(_field))\n#define ELANTS_VERSION_ATTR(_field)\t\t\t\t\t\\\n\tstruct elants_version_attribute elants_ver_attr_##_field = {\t\\\n\t\t.dattr = __ATTR(_field, S_IRUGO,\t\t\t\\\n\t\t\t\telants_version_attribute_show, NULL),\t\\\n\t\t.field_offset = offsetof(struct elants_data, _field),\t\\\n\t\t.field_size = __ELANTS_VERIFY_SIZE(_field),\t\t\\\n\t}\n\nstatic ssize_t elants_version_attribute_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *dattr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\tstruct elants_version_attribute *attr =\n\t\tcontainer_of(dattr, struct elants_version_attribute, dattr);\n\tu8 *field = (u8 *)((char *)ts + attr->field_offset);\n\tunsigned int fmt_size;\n\tunsigned int val;\n\n\tif (attr->field_size == 1) {\n\t\tval = *field;\n\t\tfmt_size = 2;  \n\t} else {\n\t\tval = *(u16 *)field;\n\t\tfmt_size = 4;  \n\t}\n\n\treturn sprintf(buf, \"%0*x\\n\", fmt_size, val);\n}\n\nstatic ELANTS_VERSION_ATTR(fw_version);\nstatic ELANTS_VERSION_ATTR(hw_version);\nstatic ELANTS_VERSION_ATTR(test_version);\nstatic ELANTS_VERSION_ATTR(solution_version);\nstatic ELANTS_VERSION_ATTR(bc_version);\nstatic ELANTS_VERSION_ATTR(iap_version);\n\nstatic struct attribute *elants_attributes[] = {\n\t&dev_attr_calibrate.attr,\n\t&dev_attr_update_fw.attr,\n\t&dev_attr_iap_mode.attr,\n\t&dev_attr_calibration_count.attr,\n\n\t&elants_ver_attr_fw_version.dattr.attr,\n\t&elants_ver_attr_hw_version.dattr.attr,\n\t&elants_ver_attr_test_version.dattr.attr,\n\t&elants_ver_attr_solution_version.dattr.attr,\n\t&elants_ver_attr_bc_version.dattr.attr,\n\t&elants_ver_attr_iap_version.dattr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group elants_attribute_group = {\n\t.attrs = elants_attributes,\n};\n\nstatic int elants_i2c_power_on(struct elants_data *ts)\n{\n\tint error;\n\n\t \n\tif (IS_ERR_OR_NULL(ts->reset_gpio))\n\t\treturn 0;\n\n\terror = regulator_enable(ts->vcc33);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to enable vcc33 regulator: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(ts->vccio);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"failed to enable vccio regulator: %d\\n\",\n\t\t\terror);\n\t\tregulator_disable(ts->vcc33);\n\t\treturn error;\n\t}\n\n\t \n\tusleep_range(ELAN_POWERON_DELAY_USEC, ELAN_POWERON_DELAY_USEC + 100);\n\n\tgpiod_set_value_cansleep(ts->reset_gpio, 0);\n\n\tmsleep(ELAN_RESET_DELAY_MSEC);\n\n\treturn 0;\n}\n\nstatic void elants_i2c_power_off(void *_data)\n{\n\tstruct elants_data *ts = _data;\n\n\tif (!IS_ERR_OR_NULL(ts->reset_gpio)) {\n\t\t \n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 1);\n\t\tregulator_disable(ts->vccio);\n\t\tregulator_disable(ts->vcc33);\n\t}\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id i2c_hid_ids[] = {\n\t{\"ACPI0C50\", 0 },\n\t{\"PNP0C50\", 0 },\n\t{ },\n};\n\nstatic const guid_t i2c_hid_guid =\n\tGUID_INIT(0x3CDFF6F7, 0x4267, 0x4555,\n\t\t  0xAD, 0x05, 0xB3, 0x0A, 0x3D, 0x89, 0x38, 0xDE);\n\nstatic bool elants_acpi_is_hid_device(struct device *dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object *obj;\n\n\tif (acpi_match_device_ids(ACPI_COMPANION(dev), i2c_hid_ids))\n\t\treturn false;\n\n\tobj = acpi_evaluate_dsm_typed(handle, &i2c_hid_guid, 1, 1, NULL, ACPI_TYPE_INTEGER);\n\tif (obj) {\n\t\tACPI_FREE(obj);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n#else\nstatic bool elants_acpi_is_hid_device(struct device *dev)\n{\n\treturn false;\n}\n#endif\n\nstatic int elants_i2c_probe(struct i2c_client *client)\n{\n\tunion i2c_smbus_data dummy;\n\tstruct elants_data *ts;\n\tunsigned long irqflags;\n\tint error;\n\n\t \n\tif (elants_acpi_is_hid_device(&client->dev)) {\n\t\tdev_warn(&client->dev, \"This device appears to be an I2C-HID device, not binding\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"I2C check functionality error\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(struct elants_data), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ts->sysfs_mutex);\n\tinit_completion(&ts->cmd_done);\n\n\tts->client = client;\n\tts->chip_id = (enum elants_chip_id)(uintptr_t)device_get_match_data(&client->dev);\n\ti2c_set_clientdata(client, ts);\n\n\tts->vcc33 = devm_regulator_get(&client->dev, \"vcc33\");\n\tif (IS_ERR(ts->vcc33))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->vcc33),\n\t\t\t\t     \"Failed to get 'vcc33' regulator\\n\");\n\n\tts->vccio = devm_regulator_get(&client->dev, \"vccio\");\n\tif (IS_ERR(ts->vccio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->vccio),\n\t\t\t\t     \"Failed to get 'vccio' regulator\\n\");\n\n\tts->reset_gpio = devm_gpiod_get(&client->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\n\t\tif (error == -EPROBE_DEFER)\n\t\t\treturn error;\n\n\t\tif (error != -ENOENT && error != -ENOSYS) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to get reset gpio: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tts->keep_power_in_suspend = true;\n\t}\n\n\terror = elants_i2c_power_on(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t elants_i2c_power_off, ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to install power off action: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tif (i2c_smbus_xfer(client->adapter, client->addr, 0,\n\t\t\t   I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0) {\n\t\tdev_err(&client->dev, \"nothing at this address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\terror = elants_i2c_initialize(ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to initialize: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->input = devm_input_allocate_device(&client->dev);\n\tif (!ts->input) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->input->name = \"Elan Touchscreen\";\n\tts->input->id.bustype = BUS_I2C;\n\n\t \n\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->x_max, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->y_max, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_TOOL_TYPE,\n\t\t\t     0, MT_TOOL_PALM, 0, 0);\n\n\ttouchscreen_parse_properties(ts->input, true, &ts->prop);\n\n\tif (ts->chip_id == EKTF3624 && ts->phy_x && ts->phy_y) {\n\t\t \n\t\tts->x_res = DIV_ROUND_CLOSEST(ts->prop.max_x, ts->phy_x);\n\t\tts->y_res = DIV_ROUND_CLOSEST(ts->prop.max_y, ts->phy_y);\n\t}\n\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->x_res);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->y_res);\n\tinput_abs_set_res(ts->input, ABS_MT_TOUCH_MAJOR, ts->major_res);\n\n\terror = input_mt_init_slots(ts->input, MAX_CONTACT_NUM,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tirqflags = irq_get_trigger_type(client->irq);\n\tif (!irqflags)\n\t\tirqflags = IRQF_TRIGGER_FALLING;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, elants_i2c_irq,\n\t\t\t\t\t  irqflags | IRQF_ONESHOT,\n\t\t\t\t\t  client->name, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &elants_attribute_group);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to create sysfs attributes: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int elants_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\tconst u8 set_sleep_cmd[] = {\n\t\tCMD_HEADER_WRITE, E_POWER_STATE_SLEEP, 0x00, 0x01\n\t};\n\tint retry_cnt;\n\tint error;\n\n\t \n\tif (ts->iap_mode != ELAN_IAP_OPERATIONAL)\n\t\treturn -EBUSY;\n\n\tdisable_irq(client->irq);\n\n\tif (device_may_wakeup(dev)) {\n\t\t \n\t\treturn 0;\n\t} else if (ts->keep_power_in_suspend) {\n\t\tfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\n\t\t\terror = elants_i2c_send(client, set_sleep_cmd,\n\t\t\t\t\t\tsizeof(set_sleep_cmd));\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"suspend command failed: %d\\n\", error);\n\t\t}\n\t} else {\n\t\telants_i2c_power_off(ts);\n\t}\n\n\treturn 0;\n}\n\nstatic int elants_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct elants_data *ts = i2c_get_clientdata(client);\n\tconst u8 set_active_cmd[] = {\n\t\tCMD_HEADER_WRITE, E_POWER_STATE_RESUME, 0x00, 0x01\n\t};\n\tint retry_cnt;\n\tint error;\n\n\tif (device_may_wakeup(dev)) {\n\t\telants_i2c_sw_reset(client);\n\t} else if (ts->keep_power_in_suspend) {\n\t\tfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\n\t\t\terror = elants_i2c_send(client, set_active_cmd,\n\t\t\t\t\t\tsizeof(set_active_cmd));\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"resume command failed: %d\\n\", error);\n\t\t}\n\t} else {\n\t\telants_i2c_power_on(ts);\n\t\telants_i2c_initialize(ts);\n\t}\n\n\tts->state = ELAN_STATE_NORMAL;\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(elants_i2c_pm_ops,\n\t\t\t\telants_i2c_suspend, elants_i2c_resume);\n\nstatic const struct i2c_device_id elants_i2c_id[] = {\n\t{ DEVICE_NAME, EKTH3500 },\n\t{ \"ekth3500\", EKTH3500 },\n\t{ \"ektf3624\", EKTF3624 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, elants_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id elants_acpi_id[] = {\n\t{ \"ELAN0001\", EKTH3500 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, elants_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id elants_of_match[] = {\n\t{ .compatible = \"elan,ekth3500\", .data = (void *)EKTH3500 },\n\t{ .compatible = \"elan,ektf3624\", .data = (void *)EKTF3624 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, elants_of_match);\n#endif\n\nstatic struct i2c_driver elants_i2c_driver = {\n\t.probe = elants_i2c_probe,\n\t.id_table = elants_i2c_id,\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.pm = pm_sleep_ptr(&elants_i2c_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(elants_acpi_id),\n\t\t.of_match_table = of_match_ptr(elants_of_match),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_i2c_driver(elants_i2c_driver);\n\nMODULE_AUTHOR(\"Scott Liu <scott.liu@emc.com.tw>\");\nMODULE_DESCRIPTION(\"Elan I2c Touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}