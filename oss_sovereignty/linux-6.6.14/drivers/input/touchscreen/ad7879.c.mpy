{
  "module_name": "ad7879.c",
  "hash_id": "8d49407a73b291dbb1ad06b160b9dec4b0035caa12916e1caeff328323f069fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ad7879.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/gpio/driver.h>\n\n#include <linux/input/touchscreen.h>\n#include <linux/module.h>\n#include \"ad7879.h\"\n\n#define AD7879_REG_ZEROS\t\t0\n#define AD7879_REG_CTRL1\t\t1\n#define AD7879_REG_CTRL2\t\t2\n#define AD7879_REG_CTRL3\t\t3\n#define AD7879_REG_AUX1HIGH\t\t4\n#define AD7879_REG_AUX1LOW\t\t5\n#define AD7879_REG_TEMP1HIGH\t\t6\n#define AD7879_REG_TEMP1LOW\t\t7\n#define AD7879_REG_XPLUS\t\t8\n#define AD7879_REG_YPLUS\t\t9\n#define AD7879_REG_Z1\t\t\t10\n#define AD7879_REG_Z2\t\t\t11\n#define AD7879_REG_AUXVBAT\t\t12\n#define AD7879_REG_TEMP\t\t\t13\n#define AD7879_REG_REVID\t\t14\n\n \n#define AD7879_TMR(x)\t\t\t((x & 0xFF) << 0)\n#define AD7879_ACQ(x)\t\t\t((x & 0x3) << 8)\n#define AD7879_MODE_NOC\t\t\t(0 << 10)\t \n#define AD7879_MODE_SCC\t\t\t(1 << 10)\t \n#define AD7879_MODE_SEQ0\t\t(2 << 10)\t \n#define AD7879_MODE_SEQ1\t\t(3 << 10)\t \n#define AD7879_MODE_INT\t\t\t(1 << 15)\t \n\n \n#define AD7879_FCD(x)\t\t\t((x & 0x3) << 0)\n#define AD7879_RESET\t\t\t(1 << 4)\n#define AD7879_MFS(x)\t\t\t((x & 0x3) << 5)\n#define AD7879_AVG(x)\t\t\t((x & 0x3) << 7)\n#define\tAD7879_SER\t\t\t(1 << 9)\t \n#define\tAD7879_DFR\t\t\t(0 << 9)\t \n#define AD7879_GPIOPOL\t\t\t(1 << 10)\n#define AD7879_GPIODIR\t\t\t(1 << 11)\n#define AD7879_GPIO_DATA\t\t(1 << 12)\n#define AD7879_GPIO_EN\t\t\t(1 << 13)\n#define AD7879_PM(x)\t\t\t((x & 0x3) << 14)\n#define AD7879_PM_SHUTDOWN\t\t(0)\n#define AD7879_PM_DYN\t\t\t(1)\n#define AD7879_PM_FULLON\t\t(2)\n\n \n#define AD7879_TEMPMASK_BIT\t\t(1<<15)\n#define AD7879_AUXVBATMASK_BIT\t\t(1<<14)\n#define AD7879_INTMODE_BIT\t\t(1<<13)\n#define AD7879_GPIOALERTMASK_BIT\t(1<<12)\n#define AD7879_AUXLOW_BIT\t\t(1<<11)\n#define AD7879_AUXHIGH_BIT\t\t(1<<10)\n#define AD7879_TEMPLOW_BIT\t\t(1<<9)\n#define AD7879_TEMPHIGH_BIT\t\t(1<<8)\n#define AD7879_YPLUS_BIT\t\t(1<<7)\n#define AD7879_XPLUS_BIT\t\t(1<<6)\n#define AD7879_Z1_BIT\t\t\t(1<<5)\n#define AD7879_Z2_BIT\t\t\t(1<<4)\n#define AD7879_AUX_BIT\t\t\t(1<<3)\n#define AD7879_VBAT_BIT\t\t\t(1<<2)\n#define AD7879_TEMP_BIT\t\t\t(1<<1)\n\nenum {\n\tAD7879_SEQ_YPOS  = 0,\n\tAD7879_SEQ_XPOS  = 1,\n\tAD7879_SEQ_Z1    = 2,\n\tAD7879_SEQ_Z2    = 3,\n\tAD7879_NR_SENSE  = 4,\n};\n\n#define\tMAX_12BIT\t\t\t((1<<12)-1)\n#define\tTS_PEN_UP_TIMEOUT\t\tmsecs_to_jiffies(50)\n\nstruct ad7879 {\n\tstruct regmap\t\t*regmap;\n\tstruct device\t\t*dev;\n\tstruct input_dev\t*input;\n\tstruct timer_list\ttimer;\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip\tgc;\n\tstruct mutex\t\tmutex;\n#endif\n\tunsigned int\t\tirq;\n\tbool\t\t\tdisabled;\t \n\tbool\t\t\tsuspended;\t \n\tbool\t\t\tswap_xy;\n\tu16\t\t\tconversion_data[AD7879_NR_SENSE];\n\tchar\t\t\tphys[32];\n\tu8\t\t\tfirst_conversion_delay;\n\tu8\t\t\tacquisition_time;\n\tu8\t\t\taveraging;\n\tu8\t\t\tpen_down_acc_interval;\n\tu8\t\t\tmedian;\n\tu16\t\t\tx_plate_ohms;\n\tu16\t\t\tcmd_crtl1;\n\tu16\t\t\tcmd_crtl2;\n\tu16\t\t\tcmd_crtl3;\n\tint\t\t\tx;\n\tint\t\t\ty;\n\tint\t\t\tRt;\n};\n\nstatic int ad7879_read(struct ad7879 *ts, u8 reg)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = regmap_read(ts->regmap, reg, &val);\n\tif (error) {\n\t\tdev_err(ts->dev, \"failed to read register %#02x: %d\\n\",\n\t\t\treg, error);\n\t\treturn error;\n\t}\n\n\treturn val;\n}\n\nstatic int ad7879_write(struct ad7879 *ts, u8 reg, u16 val)\n{\n\tint error;\n\n\terror = regmap_write(ts->regmap, reg, val);\n\tif (error) {\n\t\tdev_err(ts->dev,\n\t\t\t\"failed to write %#04x to register %#02x: %d\\n\",\n\t\t\tval, reg, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad7879_report(struct ad7879 *ts)\n{\n\tstruct input_dev *input_dev = ts->input;\n\tunsigned Rt;\n\tu16 x, y, z1, z2;\n\n\tx = ts->conversion_data[AD7879_SEQ_XPOS] & MAX_12BIT;\n\ty = ts->conversion_data[AD7879_SEQ_YPOS] & MAX_12BIT;\n\tz1 = ts->conversion_data[AD7879_SEQ_Z1] & MAX_12BIT;\n\tz2 = ts->conversion_data[AD7879_SEQ_Z2] & MAX_12BIT;\n\n\tif (ts->swap_xy)\n\t\tswap(x, y);\n\n\t \n\n\tif (likely(x && z1)) {\n\t\t \n\t\tRt = (z2 - z1) * x * ts->x_plate_ohms;\n\t\tRt /= z1;\n\t\tRt = (Rt + 2047) >> 12;\n\n\t\t \n\t\tif (Rt > input_abs_get_max(input_dev, ABS_PRESSURE))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (timer_pending(&ts->timer)) {\n\t\t\t \n\t\t\tinput_report_key(input_dev, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(input_dev, ABS_X, ts->x);\n\t\t\tinput_report_abs(input_dev, ABS_Y, ts->y);\n\t\t\tinput_report_abs(input_dev, ABS_PRESSURE, ts->Rt);\n\t\t\tinput_sync(input_dev);\n\t\t}\n\n\t\tts->x = x;\n\t\tts->y = y;\n\t\tts->Rt = Rt;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void ad7879_ts_event_release(struct ad7879 *ts)\n{\n\tstruct input_dev *input_dev = ts->input;\n\n\tinput_report_abs(input_dev, ABS_PRESSURE, 0);\n\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\tinput_sync(input_dev);\n}\n\nstatic void ad7879_timer(struct timer_list *t)\n{\n\tstruct ad7879 *ts = from_timer(ts, t, timer);\n\n\tad7879_ts_event_release(ts);\n}\n\nstatic irqreturn_t ad7879_irq(int irq, void *handle)\n{\n\tstruct ad7879 *ts = handle;\n\tint error;\n\n\terror = regmap_bulk_read(ts->regmap, AD7879_REG_XPLUS,\n\t\t\t\t ts->conversion_data, AD7879_NR_SENSE);\n\tif (error)\n\t\tdev_err_ratelimited(ts->dev, \"failed to read %#02x: %d\\n\",\n\t\t\t\t    AD7879_REG_XPLUS, error);\n\telse if (!ad7879_report(ts))\n\t\tmod_timer(&ts->timer, jiffies + TS_PEN_UP_TIMEOUT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void __ad7879_enable(struct ad7879 *ts)\n{\n\tad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\n\tad7879_write(ts, AD7879_REG_CTRL3, ts->cmd_crtl3);\n\tad7879_write(ts, AD7879_REG_CTRL1, ts->cmd_crtl1);\n\n\tenable_irq(ts->irq);\n}\n\nstatic void __ad7879_disable(struct ad7879 *ts)\n{\n\tu16 reg = (ts->cmd_crtl2 & ~AD7879_PM(-1)) |\n\t\tAD7879_PM(AD7879_PM_SHUTDOWN);\n\tdisable_irq(ts->irq);\n\n\tif (del_timer_sync(&ts->timer))\n\t\tad7879_ts_event_release(ts);\n\n\tad7879_write(ts, AD7879_REG_CTRL2, reg);\n}\n\n\nstatic int ad7879_open(struct input_dev *input)\n{\n\tstruct ad7879 *ts = input_get_drvdata(input);\n\n\t \n\tif (!ts->disabled && !ts->suspended)\n\t\t__ad7879_enable(ts);\n\n\treturn 0;\n}\n\nstatic void ad7879_close(struct input_dev *input)\n{\n\tstruct ad7879 *ts = input_get_drvdata(input);\n\n\t \n\tif (!ts->disabled && !ts->suspended)\n\t\t__ad7879_disable(ts);\n}\n\nstatic int __maybe_unused ad7879_suspend(struct device *dev)\n{\n\tstruct ad7879 *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->input->mutex);\n\n\tif (!ts->suspended && !ts->disabled && input_device_enabled(ts->input))\n\t\t__ad7879_disable(ts);\n\n\tts->suspended = true;\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ad7879_resume(struct device *dev)\n{\n\tstruct ad7879 *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->input->mutex);\n\n\tif (ts->suspended && !ts->disabled && input_device_enabled(ts->input))\n\t\t__ad7879_enable(ts);\n\n\tts->suspended = false;\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(ad7879_pm_ops, ad7879_suspend, ad7879_resume);\nEXPORT_SYMBOL(ad7879_pm_ops);\n\nstatic void ad7879_toggle(struct ad7879 *ts, bool disable)\n{\n\tmutex_lock(&ts->input->mutex);\n\n\tif (!ts->suspended && input_device_enabled(ts->input)) {\n\n\t\tif (disable) {\n\t\t\tif (ts->disabled)\n\t\t\t\t__ad7879_enable(ts);\n\t\t} else {\n\t\t\tif (!ts->disabled)\n\t\t\t\t__ad7879_disable(ts);\n\t\t}\n\t}\n\n\tts->disabled = disable;\n\n\tmutex_unlock(&ts->input->mutex);\n}\n\nstatic ssize_t ad7879_disable_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ad7879 *ts = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", ts->disabled);\n}\n\nstatic ssize_t ad7879_disable_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ad7879 *ts = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint error;\n\n\terror = kstrtouint(buf, 10, &val);\n\tif (error)\n\t\treturn error;\n\n\tad7879_toggle(ts, val);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(disable, 0664, ad7879_disable_show, ad7879_disable_store);\n\nstatic struct attribute *ad7879_attributes[] = {\n\t&dev_attr_disable.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ad7879_attr_group = {\n\t.attrs = ad7879_attributes,\n};\n\n#ifdef CONFIG_GPIOLIB\nstatic int ad7879_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned gpio)\n{\n\tstruct ad7879 *ts = gpiochip_get_data(chip);\n\tint err;\n\n\tmutex_lock(&ts->mutex);\n\tts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIODIR | AD7879_GPIOPOL;\n\terr = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\n\tmutex_unlock(&ts->mutex);\n\n\treturn err;\n}\n\nstatic int ad7879_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned gpio, int level)\n{\n\tstruct ad7879 *ts = gpiochip_get_data(chip);\n\tint err;\n\n\tmutex_lock(&ts->mutex);\n\tts->cmd_crtl2 &= ~AD7879_GPIODIR;\n\tts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIOPOL;\n\tif (level)\n\t\tts->cmd_crtl2 |= AD7879_GPIO_DATA;\n\telse\n\t\tts->cmd_crtl2 &= ~AD7879_GPIO_DATA;\n\n\terr = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\n\tmutex_unlock(&ts->mutex);\n\n\treturn err;\n}\n\nstatic int ad7879_gpio_get_value(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct ad7879 *ts = gpiochip_get_data(chip);\n\tu16 val;\n\n\tmutex_lock(&ts->mutex);\n\tval = ad7879_read(ts, AD7879_REG_CTRL2);\n\tmutex_unlock(&ts->mutex);\n\n\treturn !!(val & AD7879_GPIO_DATA);\n}\n\nstatic void ad7879_gpio_set_value(struct gpio_chip *chip,\n\t\t\t\t  unsigned gpio, int value)\n{\n\tstruct ad7879 *ts = gpiochip_get_data(chip);\n\n\tmutex_lock(&ts->mutex);\n\tif (value)\n\t\tts->cmd_crtl2 |= AD7879_GPIO_DATA;\n\telse\n\t\tts->cmd_crtl2 &= ~AD7879_GPIO_DATA;\n\n\tad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\n\tmutex_unlock(&ts->mutex);\n}\n\nstatic int ad7879_gpio_add(struct ad7879 *ts)\n{\n\tint ret = 0;\n\n\tmutex_init(&ts->mutex);\n\n\t \n\tif (!device_property_read_bool(ts->dev, \"gpio-controller\"))\n\t\treturn 0;\n\n\tts->gc.direction_input = ad7879_gpio_direction_input;\n\tts->gc.direction_output = ad7879_gpio_direction_output;\n\tts->gc.get = ad7879_gpio_get_value;\n\tts->gc.set = ad7879_gpio_set_value;\n\tts->gc.can_sleep = 1;\n\tts->gc.base = -1;\n\tts->gc.ngpio = 1;\n\tts->gc.label = \"AD7879-GPIO\";\n\tts->gc.owner = THIS_MODULE;\n\tts->gc.parent = ts->dev;\n\n\tret = devm_gpiochip_add_data(ts->dev, &ts->gc, ts);\n\tif (ret)\n\t\tdev_err(ts->dev, \"failed to register gpio %d\\n\",\n\t\t\tts->gc.base);\n\n\treturn ret;\n}\n#else\nstatic int ad7879_gpio_add(struct ad7879 *ts)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ad7879_parse_dt(struct device *dev, struct ad7879 *ts)\n{\n\tint err;\n\tu32 tmp;\n\n\terr = device_property_read_u32(dev, \"adi,resistance-plate-x\", &tmp);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get resistance-plate-x property\\n\");\n\t\treturn err;\n\t}\n\tts->x_plate_ohms = (u16)tmp;\n\n\tdevice_property_read_u8(dev, \"adi,first-conversion-delay\",\n\t\t\t\t&ts->first_conversion_delay);\n\tdevice_property_read_u8(dev, \"adi,acquisition-time\",\n\t\t\t\t&ts->acquisition_time);\n\tdevice_property_read_u8(dev, \"adi,median-filter-size\", &ts->median);\n\tdevice_property_read_u8(dev, \"adi,averaging\", &ts->averaging);\n\tdevice_property_read_u8(dev, \"adi,conversion-interval\",\n\t\t\t\t&ts->pen_down_acc_interval);\n\n\tts->swap_xy = device_property_read_bool(dev, \"touchscreen-swapped-x-y\");\n\n\treturn 0;\n}\n\nint ad7879_probe(struct device *dev, struct regmap *regmap,\n\t\t int irq, u16 bustype, u8 devid)\n{\n\tstruct ad7879 *ts;\n\tstruct input_dev *input_dev;\n\tint err;\n\tu16 revid;\n\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"No IRQ specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\terr = ad7879_parse_dt(dev, ts);\n\tif (err)\n\t\treturn err;\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev) {\n\t\tdev_err(dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->dev = dev;\n\tts->input = input_dev;\n\tts->irq = irq;\n\tts->regmap = regmap;\n\n\ttimer_setup(&ts->timer, ad7879_timer, 0);\n\tsnprintf(ts->phys, sizeof(ts->phys), \"%s/input0\", dev_name(dev));\n\n\tinput_dev->name = \"AD7879 Touchscreen\";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->dev.parent = dev;\n\tinput_dev->id.bustype = bustype;\n\n\tinput_dev->open = ad7879_open;\n\tinput_dev->close = ad7879_close;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\n\tinput_set_capability(input_dev, EV_ABS, ABS_PRESSURE);\n\ttouchscreen_parse_properties(input_dev, false, NULL);\n\tif (!input_abs_get_max(input_dev, ABS_PRESSURE)) {\n\t\tdev_err(dev, \"Touchscreen pressure is not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = ad7879_write(ts, AD7879_REG_CTRL2, AD7879_RESET);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to write %s\\n\", input_dev->name);\n\t\treturn err;\n\t}\n\n\trevid = ad7879_read(ts, AD7879_REG_REVID);\n\tinput_dev->id.product = (revid & 0xff);\n\tinput_dev->id.version = revid >> 8;\n\tif (input_dev->id.product != devid) {\n\t\tdev_err(dev, \"Failed to probe %s (%x vs %x)\\n\",\n\t\t\tinput_dev->name, devid, revid);\n\t\treturn -ENODEV;\n\t}\n\n\tts->cmd_crtl3 = AD7879_YPLUS_BIT |\n\t\t\tAD7879_XPLUS_BIT |\n\t\t\tAD7879_Z2_BIT |\n\t\t\tAD7879_Z1_BIT |\n\t\t\tAD7879_TEMPMASK_BIT |\n\t\t\tAD7879_AUXVBATMASK_BIT |\n\t\t\tAD7879_GPIOALERTMASK_BIT;\n\n\tts->cmd_crtl2 = AD7879_PM(AD7879_PM_DYN) | AD7879_DFR |\n\t\t\tAD7879_AVG(ts->averaging) |\n\t\t\tAD7879_MFS(ts->median) |\n\t\t\tAD7879_FCD(ts->first_conversion_delay);\n\n\tts->cmd_crtl1 = AD7879_MODE_INT | AD7879_MODE_SEQ1 |\n\t\t\tAD7879_ACQ(ts->acquisition_time) |\n\t\t\tAD7879_TMR(ts->pen_down_acc_interval);\n\n\terr = devm_request_threaded_irq(dev, ts->irq, NULL, ad7879_irq,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), ts);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t__ad7879_disable(ts);\n\n\terr = devm_device_add_group(dev, &ad7879_attr_group);\n\tif (err)\n\t\treturn err;\n\n\terr = ad7879_gpio_add(ts);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\tdev_set_drvdata(dev, ts);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ad7879_probe);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"AD7879(-1) touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}