{
  "module_name": "ti_am335x_tsc.c",
  "hash_id": "22e098e32a20605bfc73cc9c4059d36a35ad833a5b882049b0004d6aa0061a32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ti_am335x_tsc.c",
  "human_readable_source": " \n\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/sort.h>\n#include <linux/pm_wakeirq.h>\n\n#include <linux/mfd/ti_am335x_tscadc.h>\n\n#define ADCFSM_STEPID\t\t0x10\n#define SEQ_SETTLE\t\t275\n#define MAX_12BIT\t\t((1 << 12) - 1)\n\n#define TSC_IRQENB_MASK\t\t(IRQENB_FIFO0THRES | IRQENB_EOS | IRQENB_HW_PEN)\n\nstatic const int config_pins[] = {\n\tSTEPCONFIG_XPP,\n\tSTEPCONFIG_XNN,\n\tSTEPCONFIG_YPP,\n\tSTEPCONFIG_YNN,\n};\n\nstruct titsc {\n\tstruct input_dev\t*input;\n\tstruct ti_tscadc_dev\t*mfd_tscadc;\n\tstruct device\t\t*dev;\n\tunsigned int\t\tirq;\n\tunsigned int\t\twires;\n\tunsigned int\t\tx_plate_resistance;\n\tbool\t\t\tpen_down;\n\tint\t\t\tcoordinate_readouts;\n\tu32\t\t\tconfig_inp[4];\n\tu32\t\t\tbit_xp, bit_xn, bit_yp, bit_yn;\n\tu32\t\t\tinp_xp, inp_xn, inp_yp, inp_yn;\n\tu32\t\t\tstep_mask;\n\tu32\t\t\tcharge_delay;\n};\n\nstatic unsigned int titsc_readl(struct titsc *ts, unsigned int reg)\n{\n\treturn readl(ts->mfd_tscadc->tscadc_base + reg);\n}\n\nstatic void titsc_writel(struct titsc *tsc, unsigned int reg,\n\t\t\t\t\tunsigned int val)\n{\n\twritel(val, tsc->mfd_tscadc->tscadc_base + reg);\n}\n\nstatic int titsc_config_wires(struct titsc *ts_dev)\n{\n\tu32 analog_line[4];\n\tu32 wire_order[4];\n\tint i, bit_cfg;\n\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\tanalog_line[i] = (ts_dev->config_inp[i] & 0xF0) >> 4;\n\t\twire_order[i] = ts_dev->config_inp[i] & 0x0F;\n\t\tif (WARN_ON(analog_line[i] > 7))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(wire_order[i] > ARRAY_SIZE(config_pins)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint an_line;\n\t\tint wi_order;\n\n\t\tan_line = analog_line[i];\n\t\twi_order = wire_order[i];\n\t\tbit_cfg = config_pins[wi_order];\n\t\tif (bit_cfg == 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (wi_order) {\n\t\tcase 0:\n\t\t\tts_dev->bit_xp = bit_cfg;\n\t\t\tts_dev->inp_xp = an_line;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tts_dev->bit_xn = bit_cfg;\n\t\t\tts_dev->inp_xn = an_line;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tts_dev->bit_yp = bit_cfg;\n\t\t\tts_dev->inp_yp = an_line;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tts_dev->bit_yn = bit_cfg;\n\t\t\tts_dev->inp_yn = an_line;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void titsc_step_config(struct titsc *ts_dev)\n{\n\tunsigned int\tconfig;\n\tint i, n;\n\tint end_step, first_step, tsc_steps;\n\tu32 stepenable;\n\n\tconfig = STEPCONFIG_MODE_HWSYNC |\n\t\t\tSTEPCONFIG_AVG_16 | ts_dev->bit_xp |\n\t\t\tSTEPCONFIG_INM_ADCREFM;\n\tswitch (ts_dev->wires) {\n\tcase 4:\n\t\tconfig |= STEPCONFIG_INP(ts_dev->inp_yp) | ts_dev->bit_xn;\n\t\tbreak;\n\tcase 5:\n\t\tconfig |= ts_dev->bit_yn |\n\t\t\t\tSTEPCONFIG_INP_AN4 | ts_dev->bit_xn |\n\t\t\t\tts_dev->bit_yp;\n\t\tbreak;\n\tcase 8:\n\t\tconfig |= STEPCONFIG_INP(ts_dev->inp_yp) | ts_dev->bit_xn;\n\t\tbreak;\n\t}\n\n\ttsc_steps = ts_dev->coordinate_readouts * 2 + 2;\n\tfirst_step = TOTAL_STEPS - tsc_steps;\n\t \n\tend_step = first_step + tsc_steps;\n\tn = 0;\n\tfor (i = end_step - ts_dev->coordinate_readouts; i < end_step; i++) {\n\t\ttitsc_writel(ts_dev, REG_STEPCONFIG(i), config);\n\t\ttitsc_writel(ts_dev, REG_STEPDELAY(i),\n\t\t\t     n++ == 0 ? STEPCONFIG_OPENDLY : 0);\n\t}\n\n\tconfig = 0;\n\tconfig = STEPCONFIG_MODE_HWSYNC |\n\t\t\tSTEPCONFIG_AVG_16 | ts_dev->bit_yn |\n\t\t\tSTEPCONFIG_INM_ADCREFM;\n\tswitch (ts_dev->wires) {\n\tcase 4:\n\t\tconfig |= ts_dev->bit_yp | STEPCONFIG_INP(ts_dev->inp_xp);\n\t\tbreak;\n\tcase 5:\n\t\tconfig |= ts_dev->bit_xp | STEPCONFIG_INP_AN4 |\n\t\t\t\tSTEPCONFIG_XNP | STEPCONFIG_YPN;\n\t\tbreak;\n\tcase 8:\n\t\tconfig |= ts_dev->bit_yp | STEPCONFIG_INP(ts_dev->inp_xp);\n\t\tbreak;\n\t}\n\n\t \n\tend_step = first_step + ts_dev->coordinate_readouts;\n\tn = 0;\n\tfor (i = first_step; i < end_step; i++) {\n\t\ttitsc_writel(ts_dev, REG_STEPCONFIG(i), config);\n\t\ttitsc_writel(ts_dev, REG_STEPDELAY(i),\n\t\t\t     n++ == 0 ? STEPCONFIG_OPENDLY : 0);\n\t}\n\n\t \n\n\tconfig = titsc_readl(ts_dev, REG_IDLECONFIG);\n\ttitsc_writel(ts_dev, REG_CHARGECONFIG, config);\n\ttitsc_writel(ts_dev, REG_CHARGEDELAY, ts_dev->charge_delay);\n\n\t \n\tconfig = STEPCONFIG_MODE_HWSYNC |\n\t\t\tSTEPCONFIG_AVG_16 | ts_dev->bit_yp |\n\t\t\tts_dev->bit_xn | STEPCONFIG_INM_ADCREFM |\n\t\t\tSTEPCONFIG_INP(ts_dev->inp_xp);\n\ttitsc_writel(ts_dev, REG_STEPCONFIG(end_step), config);\n\ttitsc_writel(ts_dev, REG_STEPDELAY(end_step),\n\t\t\tSTEPCONFIG_OPENDLY);\n\n\tend_step++;\n\tconfig = STEPCONFIG_MODE_HWSYNC |\n\t\t\tSTEPCONFIG_AVG_16 | ts_dev->bit_yp |\n\t\t\tts_dev->bit_xn | STEPCONFIG_INM_ADCREFM |\n\t\t\tSTEPCONFIG_INP(ts_dev->inp_yn);\n\ttitsc_writel(ts_dev, REG_STEPCONFIG(end_step), config);\n\ttitsc_writel(ts_dev, REG_STEPDELAY(end_step),\n\t\t\tSTEPCONFIG_OPENDLY);\n\n\t \n\tstepenable = 1;\n\tfor (i = 0; i < tsc_steps; i++)\n\t\tstepenable |= 1 << (first_step + i + 1);\n\n\tts_dev->step_mask = stepenable;\n\tam335x_tsc_se_set_cache(ts_dev->mfd_tscadc, ts_dev->step_mask);\n}\n\nstatic int titsc_cmp_coord(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}\n\nstatic void titsc_read_coordinates(struct titsc *ts_dev,\n\t\tu32 *x, u32 *y, u32 *z1, u32 *z2)\n{\n\tunsigned int yvals[7], xvals[7];\n\tunsigned int i, xsum = 0, ysum = 0;\n\tunsigned int creads = ts_dev->coordinate_readouts;\n\n\tfor (i = 0; i < creads; i++) {\n\t\tyvals[i] = titsc_readl(ts_dev, REG_FIFO0);\n\t\tyvals[i] &= 0xfff;\n\t}\n\n\t*z1 = titsc_readl(ts_dev, REG_FIFO0);\n\t*z1 &= 0xfff;\n\t*z2 = titsc_readl(ts_dev, REG_FIFO0);\n\t*z2 &= 0xfff;\n\n\tfor (i = 0; i < creads; i++) {\n\t\txvals[i] = titsc_readl(ts_dev, REG_FIFO0);\n\t\txvals[i] &= 0xfff;\n\t}\n\n\t \n\tif (creads <=  3) {\n\t\tfor (i = 0; i < creads; i++) {\n\t\t\tysum += yvals[i];\n\t\t\txsum += xvals[i];\n\t\t}\n\t\tysum /= creads;\n\t\txsum /= creads;\n\t} else {\n\t\tsort(yvals, creads, sizeof(unsigned int),\n\t\t     titsc_cmp_coord, NULL);\n\t\tsort(xvals, creads, sizeof(unsigned int),\n\t\t     titsc_cmp_coord, NULL);\n\t\tfor (i = 1; i < creads - 1; i++) {\n\t\t\tysum += yvals[i];\n\t\t\txsum += xvals[i];\n\t\t}\n\t\tysum /= creads - 2;\n\t\txsum /= creads - 2;\n\t}\n\t*y = ysum;\n\t*x = xsum;\n}\n\nstatic irqreturn_t titsc_irq(int irq, void *dev)\n{\n\tstruct titsc *ts_dev = dev;\n\tstruct input_dev *input_dev = ts_dev->input;\n\tunsigned int fsm, status, irqclr = 0;\n\tunsigned int x = 0, y = 0;\n\tunsigned int z1, z2, z;\n\n\tstatus = titsc_readl(ts_dev, REG_RAWIRQSTATUS);\n\tif (status & IRQENB_HW_PEN) {\n\t\tts_dev->pen_down = true;\n\t\tirqclr |= IRQENB_HW_PEN;\n\t\tpm_stay_awake(ts_dev->dev);\n\t}\n\n\tif (status & IRQENB_PENUP) {\n\t\tfsm = titsc_readl(ts_dev, REG_ADCFSM);\n\t\tif (fsm == ADCFSM_STEPID) {\n\t\t\tts_dev->pen_down = false;\n\t\t\tinput_report_key(input_dev, BTN_TOUCH, 0);\n\t\t\tinput_report_abs(input_dev, ABS_PRESSURE, 0);\n\t\t\tinput_sync(input_dev);\n\t\t\tpm_relax(ts_dev->dev);\n\t\t} else {\n\t\t\tts_dev->pen_down = true;\n\t\t}\n\t\tirqclr |= IRQENB_PENUP;\n\t}\n\n\tif (status & IRQENB_EOS)\n\t\tirqclr |= IRQENB_EOS;\n\n\t \n\tif (status & IRQENB_FIFO0THRES) {\n\n\t\ttitsc_read_coordinates(ts_dev, &x, &y, &z1, &z2);\n\n\t\tif (ts_dev->pen_down && z1 != 0 && z2 != 0) {\n\t\t\t \n\t\t\tz = z1 - z2;\n\t\t\tz *= x;\n\t\t\tz *= ts_dev->x_plate_resistance;\n\t\t\tz /= z2;\n\t\t\tz = (z + 2047) >> 12;\n\n\t\t\tif (z <= MAX_12BIT) {\n\t\t\t\tinput_report_abs(input_dev, ABS_X, x);\n\t\t\t\tinput_report_abs(input_dev, ABS_Y, y);\n\t\t\t\tinput_report_abs(input_dev, ABS_PRESSURE, z);\n\t\t\t\tinput_report_key(input_dev, BTN_TOUCH, 1);\n\t\t\t\tinput_sync(input_dev);\n\t\t\t}\n\t\t}\n\t\tirqclr |= IRQENB_FIFO0THRES;\n\t}\n\tif (irqclr) {\n\t\ttitsc_writel(ts_dev, REG_IRQSTATUS, irqclr);\n\t\tif (status & IRQENB_EOS)\n\t\t\tam335x_tsc_se_set_cache(ts_dev->mfd_tscadc,\n\t\t\t\t\t\tts_dev->step_mask);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int titsc_parse_dt(struct platform_device *pdev,\n\t\t\t\t\tstruct titsc *ts_dev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tint err;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\terr = of_property_read_u32(node, \"ti,wires\", &ts_dev->wires);\n\tif (err < 0)\n\t\treturn err;\n\tswitch (ts_dev->wires) {\n\tcase 4:\n\tcase 5:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = of_property_read_u32(node, \"ti,x-plate-resistance\",\n\t\t\t&ts_dev->x_plate_resistance);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = of_property_read_u32(node, \"ti,coordinate-readouts\",\n\t\t\t&ts_dev->coordinate_readouts);\n\tif (err < 0) {\n\t\tdev_warn(&pdev->dev, \"please use 'ti,coordinate-readouts' instead\\n\");\n\t\terr = of_property_read_u32(node, \"ti,coordiante-readouts\",\n\t\t\t\t&ts_dev->coordinate_readouts);\n\t}\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (ts_dev->coordinate_readouts <= 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"invalid co-ordinate readouts, resetting it to 5\\n\");\n\t\tts_dev->coordinate_readouts = 5;\n\t}\n\n\terr = of_property_read_u32(node, \"ti,charge-delay\",\n\t\t\t\t   &ts_dev->charge_delay);\n\t \n\tif (err < 0) {\n\t\tts_dev->charge_delay = CHARGEDLY_OPENDLY;\n\t\tdev_warn(&pdev->dev, \"ti,charge-delay not specified\\n\");\n\t}\n\n\treturn of_property_read_u32_array(node, \"ti,wire-config\",\n\t\t\tts_dev->config_inp, ARRAY_SIZE(ts_dev->config_inp));\n}\n\n \n\nstatic int titsc_probe(struct platform_device *pdev)\n{\n\tstruct titsc *ts_dev;\n\tstruct input_dev *input_dev;\n\tstruct ti_tscadc_dev *tscadc_dev = ti_tscadc_dev_get(pdev);\n\tint err;\n\n\t \n\tts_dev = kzalloc(sizeof(*ts_dev), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!ts_dev || !input_dev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate memory.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\ttscadc_dev->tsc = ts_dev;\n\tts_dev->mfd_tscadc = tscadc_dev;\n\tts_dev->input = input_dev;\n\tts_dev->irq = tscadc_dev->irq;\n\tts_dev->dev = &pdev->dev;\n\n\terr = titsc_parse_dt(pdev, ts_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Could not find valid DT data.\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\terr = request_irq(ts_dev->irq, titsc_irq,\n\t\t\t  IRQF_SHARED, pdev->dev.driver->name, ts_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to allocate irq.\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\terr = dev_pm_set_wake_irq(&pdev->dev, ts_dev->irq);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"irq wake enable failed.\\n\");\n\n\ttitsc_writel(ts_dev, REG_IRQSTATUS, TSC_IRQENB_MASK);\n\ttitsc_writel(ts_dev, REG_IRQENABLE, IRQENB_FIFO0THRES);\n\ttitsc_writel(ts_dev, REG_IRQENABLE, IRQENB_EOS);\n\terr = titsc_config_wires(ts_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"wrong i/p wire configuration\\n\");\n\t\tgoto err_free_irq;\n\t}\n\ttitsc_step_config(ts_dev);\n\ttitsc_writel(ts_dev, REG_FIFO0THR,\n\t\t\tts_dev->coordinate_readouts * 2 + 2 - 1);\n\n\tinput_dev->name = \"ti-tsc\";\n\tinput_dev->dev.parent = &pdev->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);\n\n\t \n\terr = input_register_device(input_dev);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\tplatform_set_drvdata(pdev, ts_dev);\n\treturn 0;\n\nerr_free_irq:\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\tfree_irq(ts_dev->irq, ts_dev);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(ts_dev);\n\treturn err;\n}\n\nstatic int titsc_remove(struct platform_device *pdev)\n{\n\tstruct titsc *ts_dev = platform_get_drvdata(pdev);\n\tu32 steps;\n\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\tfree_irq(ts_dev->irq, ts_dev);\n\n\t \n\tsteps = 2 * ts_dev->coordinate_readouts + 2;\n\tsteps = (1 << steps) - 1;\n\tam335x_tsc_se_clr(ts_dev->mfd_tscadc, steps);\n\n\tinput_unregister_device(ts_dev->input);\n\n\tkfree(ts_dev);\n\treturn 0;\n}\n\nstatic int titsc_suspend(struct device *dev)\n{\n\tstruct titsc *ts_dev = dev_get_drvdata(dev);\n\tunsigned int idle;\n\n\tif (device_may_wakeup(dev)) {\n\t\ttitsc_writel(ts_dev, REG_IRQSTATUS, TSC_IRQENB_MASK);\n\t\tidle = titsc_readl(ts_dev, REG_IRQENABLE);\n\t\ttitsc_writel(ts_dev, REG_IRQENABLE,\n\t\t\t\t(idle | IRQENB_HW_PEN));\n\t\ttitsc_writel(ts_dev, REG_IRQWAKEUP, IRQWKUP_ENB);\n\t}\n\treturn 0;\n}\n\nstatic int titsc_resume(struct device *dev)\n{\n\tstruct titsc *ts_dev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\ttitsc_writel(ts_dev, REG_IRQWAKEUP,\n\t\t\t\t0x00);\n\t\ttitsc_writel(ts_dev, REG_IRQCLR, IRQENB_HW_PEN);\n\t\tpm_relax(dev);\n\t}\n\ttitsc_step_config(ts_dev);\n\ttitsc_writel(ts_dev, REG_FIFO0THR,\n\t\t\tts_dev->coordinate_readouts * 2 + 2 - 1);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(titsc_pm_ops, titsc_suspend, titsc_resume);\n\nstatic const struct of_device_id ti_tsc_dt_ids[] = {\n\t{ .compatible = \"ti,am3359-tsc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_tsc_dt_ids);\n\nstatic struct platform_driver ti_tsc_driver = {\n\t.probe\t= titsc_probe,\n\t.remove\t= titsc_remove,\n\t.driver\t= {\n\t\t.name   = \"TI-am335x-tsc\",\n\t\t.pm\t= pm_sleep_ptr(&titsc_pm_ops),\n\t\t.of_match_table = ti_tsc_dt_ids,\n\t},\n};\nmodule_platform_driver(ti_tsc_driver);\n\nMODULE_DESCRIPTION(\"TI touchscreen controller driver\");\nMODULE_AUTHOR(\"Rachna Patil <rachna@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}