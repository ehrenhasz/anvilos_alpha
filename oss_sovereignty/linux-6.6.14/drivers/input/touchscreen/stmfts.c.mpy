{
  "module_name": "stmfts.c",
  "hash_id": "502a12abe1fb411144f2ba80fa31d712a8072a7ef5a6110dade47499fdacb737",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/stmfts.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n \n#define STMFTS_READ_INFO\t\t\t0x80\n#define STMFTS_READ_STATUS\t\t\t0x84\n#define STMFTS_READ_ONE_EVENT\t\t\t0x85\n#define STMFTS_READ_ALL_EVENT\t\t\t0x86\n#define STMFTS_LATEST_EVENT\t\t\t0x87\n#define STMFTS_SLEEP_IN\t\t\t\t0x90\n#define STMFTS_SLEEP_OUT\t\t\t0x91\n#define STMFTS_MS_MT_SENSE_OFF\t\t\t0x92\n#define STMFTS_MS_MT_SENSE_ON\t\t\t0x93\n#define STMFTS_SS_HOVER_SENSE_OFF\t\t0x94\n#define STMFTS_SS_HOVER_SENSE_ON\t\t0x95\n#define STMFTS_MS_KEY_SENSE_OFF\t\t\t0x9a\n#define STMFTS_MS_KEY_SENSE_ON\t\t\t0x9b\n#define STMFTS_SYSTEM_RESET\t\t\t0xa0\n#define STMFTS_CLEAR_EVENT_STACK\t\t0xa1\n#define STMFTS_FULL_FORCE_CALIBRATION\t\t0xa2\n#define STMFTS_MS_CX_TUNING\t\t\t0xa3\n#define STMFTS_SS_CX_TUNING\t\t\t0xa4\n\n \n#define STMFTS_EV_NO_EVENT\t\t\t0x00\n#define STMFTS_EV_MULTI_TOUCH_DETECTED\t\t0x02\n#define STMFTS_EV_MULTI_TOUCH_ENTER\t\t0x03\n#define STMFTS_EV_MULTI_TOUCH_LEAVE\t\t0x04\n#define STMFTS_EV_MULTI_TOUCH_MOTION\t\t0x05\n#define STMFTS_EV_HOVER_ENTER\t\t\t0x07\n#define STMFTS_EV_HOVER_LEAVE\t\t\t0x08\n#define STMFTS_EV_HOVER_MOTION\t\t\t0x09\n#define STMFTS_EV_KEY_STATUS\t\t\t0x0e\n#define STMFTS_EV_ERROR\t\t\t\t0x0f\n#define STMFTS_EV_CONTROLLER_READY\t\t0x10\n#define STMFTS_EV_SLEEP_OUT_CONTROLLER_READY\t0x11\n#define STMFTS_EV_STATUS\t\t\t0x16\n#define STMFTS_EV_DEBUG\t\t\t\t0xdb\n\n \n#define STMFTS_MASK_EVENT_ID\t\t\t0x0f\n#define STMFTS_MASK_TOUCH_ID\t\t\t0xf0\n#define STMFTS_MASK_LEFT_EVENT\t\t\t0x0f\n#define STMFTS_MASK_X_MSB\t\t\t0x0f\n#define STMFTS_MASK_Y_LSB\t\t\t0xf0\n\n \n#define STMFTS_MASK_KEY_NO_TOUCH\t\t0x00\n#define STMFTS_MASK_KEY_MENU\t\t\t0x01\n#define STMFTS_MASK_KEY_BACK\t\t\t0x02\n\n#define STMFTS_EVENT_SIZE\t8\n#define STMFTS_STACK_DEPTH\t32\n#define STMFTS_DATA_MAX_SIZE\t(STMFTS_EVENT_SIZE * STMFTS_STACK_DEPTH)\n#define STMFTS_MAX_FINGERS\t10\n#define STMFTS_DEV_NAME\t\t\"stmfts\"\n\nenum stmfts_regulators {\n\tSTMFTS_REGULATOR_VDD,\n\tSTMFTS_REGULATOR_AVDD,\n};\n\nstruct stmfts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct led_classdev led_cdev;\n\tstruct mutex mutex;\n\n\tstruct touchscreen_properties prop;\n\n\tstruct regulator_bulk_data regulators[2];\n\n\t \n\tstruct regulator *ledvdd;\n\n\tu16 chip_id;\n\tu8 chip_ver;\n\tu16 fw_ver;\n\tu8 config_id;\n\tu8 config_ver;\n\n\tu8 data[STMFTS_DATA_MAX_SIZE];\n\n\tstruct completion cmd_done;\n\n\tbool use_key;\n\tbool led_status;\n\tbool hover_enabled;\n\tbool running;\n};\n\nstatic int stmfts_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness value)\n{\n\tstruct stmfts_data *sdata = container_of(led_cdev,\n\t\t\t\t\tstruct stmfts_data, led_cdev);\n\tint err;\n\n\tif (value != sdata->led_status && sdata->ledvdd) {\n\t\tif (!value) {\n\t\t\tregulator_disable(sdata->ledvdd);\n\t\t} else {\n\t\t\terr = regulator_enable(sdata->ledvdd);\n\t\t\tif (err) {\n\t\t\t\tdev_warn(&sdata->client->dev,\n\t\t\t\t\t \"failed to disable ledvdd regulator: %d\\n\",\n\t\t\t\t\t err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tsdata->led_status = value;\n\t}\n\n\treturn 0;\n}\n\nstatic enum led_brightness stmfts_brightness_get(struct led_classdev *led_cdev)\n{\n\tstruct stmfts_data *sdata = container_of(led_cdev,\n\t\t\t\t\t\tstruct stmfts_data, led_cdev);\n\n\treturn !!regulator_is_enabled(sdata->ledvdd);\n}\n\n \nstatic int stmfts_read_events(struct stmfts_data *sdata)\n{\n\tu8 cmd = STMFTS_READ_ALL_EVENT;\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr\t= sdata->client->addr,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &cmd,\n\t\t},\n\t\t{\n\t\t\t.addr\t= sdata->client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= STMFTS_DATA_MAX_SIZE,\n\t\t\t.buf\t= sdata->data,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(sdata->client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret == ARRAY_SIZE(msgs) ? 0 : -EIO;\n}\n\nstatic void stmfts_report_contact_event(struct stmfts_data *sdata,\n\t\t\t\t\tconst u8 event[])\n{\n\tu8 slot_id = (event[0] & STMFTS_MASK_TOUCH_ID) >> 4;\n\tu16 x = event[1] | ((event[2] & STMFTS_MASK_X_MSB) << 8);\n\tu16 y = (event[2] >> 4) | (event[3] << 4);\n\tu8 maj = event[4];\n\tu8 min = event[5];\n\tu8 orientation = event[6];\n\tu8 area = event[7];\n\n\tinput_mt_slot(sdata->input, slot_id);\n\n\tinput_mt_report_slot_state(sdata->input, MT_TOOL_FINGER, true);\n\tinput_report_abs(sdata->input, ABS_MT_POSITION_X, x);\n\tinput_report_abs(sdata->input, ABS_MT_POSITION_Y, y);\n\tinput_report_abs(sdata->input, ABS_MT_TOUCH_MAJOR, maj);\n\tinput_report_abs(sdata->input, ABS_MT_TOUCH_MINOR, min);\n\tinput_report_abs(sdata->input, ABS_MT_PRESSURE, area);\n\tinput_report_abs(sdata->input, ABS_MT_ORIENTATION, orientation);\n\n\tinput_sync(sdata->input);\n}\n\nstatic void stmfts_report_contact_release(struct stmfts_data *sdata,\n\t\t\t\t\t  const u8 event[])\n{\n\tu8 slot_id = (event[0] & STMFTS_MASK_TOUCH_ID) >> 4;\n\n\tinput_mt_slot(sdata->input, slot_id);\n\tinput_mt_report_slot_inactive(sdata->input);\n\n\tinput_sync(sdata->input);\n}\n\nstatic void stmfts_report_hover_event(struct stmfts_data *sdata,\n\t\t\t\t      const u8 event[])\n{\n\tu16 x = (event[2] << 4) | (event[4] >> 4);\n\tu16 y = (event[3] << 4) | (event[4] & STMFTS_MASK_Y_LSB);\n\tu8 z = event[5];\n\n\tinput_report_abs(sdata->input, ABS_X, x);\n\tinput_report_abs(sdata->input, ABS_Y, y);\n\tinput_report_abs(sdata->input, ABS_DISTANCE, z);\n\n\tinput_sync(sdata->input);\n}\n\nstatic void stmfts_report_key_event(struct stmfts_data *sdata, const u8 event[])\n{\n\tswitch (event[2]) {\n\tcase 0:\n\t\tinput_report_key(sdata->input, KEY_BACK, 0);\n\t\tinput_report_key(sdata->input, KEY_MENU, 0);\n\t\tbreak;\n\n\tcase STMFTS_MASK_KEY_BACK:\n\t\tinput_report_key(sdata->input, KEY_BACK, 1);\n\t\tbreak;\n\n\tcase STMFTS_MASK_KEY_MENU:\n\t\tinput_report_key(sdata->input, KEY_MENU, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&sdata->client->dev,\n\t\t\t \"unknown key event: %#02x\\n\", event[2]);\n\t\tbreak;\n\t}\n\n\tinput_sync(sdata->input);\n}\n\nstatic void stmfts_parse_events(struct stmfts_data *sdata)\n{\n\tint i;\n\n\tfor (i = 0; i < STMFTS_STACK_DEPTH; i++) {\n\t\tu8 *event = &sdata->data[i * STMFTS_EVENT_SIZE];\n\n\t\tswitch (event[0]) {\n\n\t\tcase STMFTS_EV_CONTROLLER_READY:\n\t\tcase STMFTS_EV_SLEEP_OUT_CONTROLLER_READY:\n\t\tcase STMFTS_EV_STATUS:\n\t\t\tcomplete(&sdata->cmd_done);\n\t\t\tfallthrough;\n\n\t\tcase STMFTS_EV_NO_EVENT:\n\t\tcase STMFTS_EV_DEBUG:\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event[0] & STMFTS_MASK_EVENT_ID) {\n\n\t\tcase STMFTS_EV_MULTI_TOUCH_ENTER:\n\t\tcase STMFTS_EV_MULTI_TOUCH_MOTION:\n\t\t\tstmfts_report_contact_event(sdata, event);\n\t\t\tbreak;\n\n\t\tcase STMFTS_EV_MULTI_TOUCH_LEAVE:\n\t\t\tstmfts_report_contact_release(sdata, event);\n\t\t\tbreak;\n\n\t\tcase STMFTS_EV_HOVER_ENTER:\n\t\tcase STMFTS_EV_HOVER_LEAVE:\n\t\tcase STMFTS_EV_HOVER_MOTION:\n\t\t\tstmfts_report_hover_event(sdata, event);\n\t\t\tbreak;\n\n\t\tcase STMFTS_EV_KEY_STATUS:\n\t\t\tstmfts_report_key_event(sdata, event);\n\t\t\tbreak;\n\n\t\tcase STMFTS_EV_ERROR:\n\t\t\tdev_warn(&sdata->client->dev,\n\t\t\t\t\t\"error code: 0x%x%x%x%x%x%x\",\n\t\t\t\t\tevent[6], event[5], event[4],\n\t\t\t\t\tevent[3], event[2], event[1]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&sdata->client->dev,\n\t\t\t\t\"unknown event %#02x\\n\", event[0]);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t stmfts_irq_handler(int irq, void *dev)\n{\n\tstruct stmfts_data *sdata = dev;\n\tint err;\n\n\tmutex_lock(&sdata->mutex);\n\n\terr = stmfts_read_events(sdata);\n\tif (unlikely(err))\n\t\tdev_err(&sdata->client->dev,\n\t\t\t\"failed to read events: %d\\n\", err);\n\telse\n\t\tstmfts_parse_events(sdata);\n\n\tmutex_unlock(&sdata->mutex);\n\treturn IRQ_HANDLED;\n}\n\nstatic int stmfts_command(struct stmfts_data *sdata, const u8 cmd)\n{\n\tint err;\n\n\treinit_completion(&sdata->cmd_done);\n\n\terr = i2c_smbus_write_byte(sdata->client, cmd);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&sdata->cmd_done,\n\t\t\t\t\t msecs_to_jiffies(1000)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int stmfts_input_open(struct input_dev *dev)\n{\n\tstruct stmfts_data *sdata = input_get_drvdata(dev);\n\tint err;\n\n\terr = pm_runtime_resume_and_get(&sdata->client->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = i2c_smbus_write_byte(sdata->client, STMFTS_MS_MT_SENSE_ON);\n\tif (err) {\n\t\tpm_runtime_put_sync(&sdata->client->dev);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&sdata->mutex);\n\tsdata->running = true;\n\n\tif (sdata->hover_enabled) {\n\t\terr = i2c_smbus_write_byte(sdata->client,\n\t\t\t\t\t   STMFTS_SS_HOVER_SENSE_ON);\n\t\tif (err)\n\t\t\tdev_warn(&sdata->client->dev,\n\t\t\t\t \"failed to enable hover\\n\");\n\t}\n\tmutex_unlock(&sdata->mutex);\n\n\tif (sdata->use_key) {\n\t\terr = i2c_smbus_write_byte(sdata->client,\n\t\t\t\t\t   STMFTS_MS_KEY_SENSE_ON);\n\t\tif (err)\n\t\t\t \n\t\t\tdev_warn(&sdata->client->dev,\n\t\t\t\t \"failed to enable touchkey\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void stmfts_input_close(struct input_dev *dev)\n{\n\tstruct stmfts_data *sdata = input_get_drvdata(dev);\n\tint err;\n\n\terr = i2c_smbus_write_byte(sdata->client, STMFTS_MS_MT_SENSE_OFF);\n\tif (err)\n\t\tdev_warn(&sdata->client->dev,\n\t\t\t \"failed to disable touchscreen: %d\\n\", err);\n\n\tmutex_lock(&sdata->mutex);\n\n\tsdata->running = false;\n\n\tif (sdata->hover_enabled) {\n\t\terr = i2c_smbus_write_byte(sdata->client,\n\t\t\t\t\t   STMFTS_SS_HOVER_SENSE_OFF);\n\t\tif (err)\n\t\t\tdev_warn(&sdata->client->dev,\n\t\t\t\t \"failed to disable hover: %d\\n\", err);\n\t}\n\tmutex_unlock(&sdata->mutex);\n\n\tif (sdata->use_key) {\n\t\terr = i2c_smbus_write_byte(sdata->client,\n\t\t\t\t\t   STMFTS_MS_KEY_SENSE_OFF);\n\t\tif (err)\n\t\t\tdev_warn(&sdata->client->dev,\n\t\t\t\t \"failed to disable touchkey: %d\\n\", err);\n\t}\n\n\tpm_runtime_put_sync(&sdata->client->dev);\n}\n\nstatic ssize_t stmfts_sysfs_chip_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", sdata->chip_id);\n}\n\nstatic ssize_t stmfts_sysfs_chip_version(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdata->chip_ver);\n}\n\nstatic ssize_t stmfts_sysfs_fw_ver(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdata->fw_ver);\n}\n\nstatic ssize_t stmfts_sysfs_config_id(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", sdata->config_id);\n}\n\nstatic ssize_t stmfts_sysfs_config_version(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdata->config_ver);\n}\n\nstatic ssize_t stmfts_sysfs_read_status(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\tu8 status[4];\n\tint err;\n\n\terr = i2c_smbus_read_i2c_block_data(sdata->client, STMFTS_READ_STATUS,\n\t\t\t\t\t    sizeof(status), status);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%#02x\\n\", status[0]);\n}\n\nstatic ssize_t stmfts_sysfs_hover_enable_read(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%u\\n\", sdata->hover_enabled);\n}\n\nstatic ssize_t stmfts_sysfs_hover_enable_write(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\tunsigned long value;\n\tint err = 0;\n\n\tif (kstrtoul(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sdata->mutex);\n\n\tif (value && sdata->hover_enabled)\n\t\tgoto out;\n\n\tif (sdata->running)\n\t\terr = i2c_smbus_write_byte(sdata->client,\n\t\t\t\t\t   value ? STMFTS_SS_HOVER_SENSE_ON :\n\t\t\t\t\t\t   STMFTS_SS_HOVER_SENSE_OFF);\n\n\tif (!err)\n\t\tsdata->hover_enabled = !!value;\n\nout:\n\tmutex_unlock(&sdata->mutex);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(chip_id, 0444, stmfts_sysfs_chip_id, NULL);\nstatic DEVICE_ATTR(chip_version, 0444, stmfts_sysfs_chip_version, NULL);\nstatic DEVICE_ATTR(fw_ver, 0444, stmfts_sysfs_fw_ver, NULL);\nstatic DEVICE_ATTR(config_id, 0444, stmfts_sysfs_config_id, NULL);\nstatic DEVICE_ATTR(config_version, 0444, stmfts_sysfs_config_version, NULL);\nstatic DEVICE_ATTR(status, 0444, stmfts_sysfs_read_status, NULL);\nstatic DEVICE_ATTR(hover_enable, 0644, stmfts_sysfs_hover_enable_read,\n\t\t\t\t\tstmfts_sysfs_hover_enable_write);\n\nstatic struct attribute *stmfts_sysfs_attrs[] = {\n\t&dev_attr_chip_id.attr,\n\t&dev_attr_chip_version.attr,\n\t&dev_attr_fw_ver.attr,\n\t&dev_attr_config_id.attr,\n\t&dev_attr_config_version.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_hover_enable.attr,\n\tNULL\n};\n\nstatic struct attribute_group stmfts_attribute_group = {\n\t.attrs = stmfts_sysfs_attrs\n};\n\nstatic int stmfts_power_on(struct stmfts_data *sdata)\n{\n\tint err;\n\tu8 reg[8];\n\n\terr = regulator_bulk_enable(ARRAY_SIZE(sdata->regulators),\n\t\t\t\t    sdata->regulators);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsleep(20);\n\n\terr = i2c_smbus_read_i2c_block_data(sdata->client, STMFTS_READ_INFO,\n\t\t\t\t\t    sizeof(reg), reg);\n\tif (err < 0)\n\t\treturn err;\n\tif (err != sizeof(reg))\n\t\treturn -EIO;\n\n\tsdata->chip_id = be16_to_cpup((__be16 *)&reg[6]);\n\tsdata->chip_ver = reg[0];\n\tsdata->fw_ver = be16_to_cpup((__be16 *)&reg[2]);\n\tsdata->config_id = reg[4];\n\tsdata->config_ver = reg[5];\n\n\tenable_irq(sdata->client->irq);\n\n\tmsleep(50);\n\n\terr = stmfts_command(sdata, STMFTS_SYSTEM_RESET);\n\tif (err)\n\t\treturn err;\n\n\terr = stmfts_command(sdata, STMFTS_SLEEP_OUT);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = stmfts_command(sdata, STMFTS_MS_CX_TUNING);\n\tif (err)\n\t\tdev_warn(&sdata->client->dev,\n\t\t\t \"failed to perform mutual auto tune: %d\\n\", err);\n\n\t \n\terr = stmfts_command(sdata, STMFTS_SS_CX_TUNING);\n\tif (err)\n\t\tdev_warn(&sdata->client->dev,\n\t\t\t \"failed to perform self auto tune: %d\\n\", err);\n\n\terr = stmfts_command(sdata, STMFTS_FULL_FORCE_CALIBRATION);\n\tif (err)\n\t\treturn err;\n\n\t \n\t(void) i2c_smbus_write_byte(sdata->client, STMFTS_SLEEP_IN);\n\n\treturn 0;\n}\n\nstatic void stmfts_power_off(void *data)\n{\n\tstruct stmfts_data *sdata = data;\n\n\tdisable_irq(sdata->client->irq);\n\tregulator_bulk_disable(ARRAY_SIZE(sdata->regulators),\n\t\t\t\t\t\tsdata->regulators);\n}\n\n \nstatic int stmfts_enable_led(struct stmfts_data *sdata)\n{\n\tint err;\n\n\t \n\tsdata->ledvdd = devm_regulator_get(&sdata->client->dev, \"ledvdd\");\n\tif (IS_ERR(sdata->ledvdd))\n\t\treturn PTR_ERR(sdata->ledvdd);\n\n\tsdata->led_cdev.name = STMFTS_DEV_NAME;\n\tsdata->led_cdev.max_brightness = LED_ON;\n\tsdata->led_cdev.brightness = LED_OFF;\n\tsdata->led_cdev.brightness_set_blocking = stmfts_brightness_set;\n\tsdata->led_cdev.brightness_get = stmfts_brightness_get;\n\n\terr = devm_led_classdev_register(&sdata->client->dev, &sdata->led_cdev);\n\tif (err) {\n\t\tdevm_regulator_put(sdata->ledvdd);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmfts_probe(struct i2c_client *client)\n{\n\tint err;\n\tstruct stmfts_data *sdata;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tsdata = devm_kzalloc(&client->dev, sizeof(*sdata), GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, sdata);\n\n\tsdata->client = client;\n\tmutex_init(&sdata->mutex);\n\tinit_completion(&sdata->cmd_done);\n\n\tsdata->regulators[STMFTS_REGULATOR_VDD].supply = \"vdd\";\n\tsdata->regulators[STMFTS_REGULATOR_AVDD].supply = \"avdd\";\n\terr = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t      ARRAY_SIZE(sdata->regulators),\n\t\t\t\t      sdata->regulators);\n\tif (err)\n\t\treturn err;\n\n\tsdata->input = devm_input_allocate_device(&client->dev);\n\tif (!sdata->input)\n\t\treturn -ENOMEM;\n\n\tsdata->input->name = STMFTS_DEV_NAME;\n\tsdata->input->id.bustype = BUS_I2C;\n\tsdata->input->open = stmfts_input_open;\n\tsdata->input->close = stmfts_input_close;\n\n\tinput_set_capability(sdata->input, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(sdata->input, EV_ABS, ABS_MT_POSITION_Y);\n\ttouchscreen_parse_properties(sdata->input, true, &sdata->prop);\n\n\tinput_set_abs_params(sdata->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_ORIENTATION, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_DISTANCE, 0, 255, 0, 0);\n\n\tsdata->use_key = device_property_read_bool(&client->dev,\n\t\t\t\t\t\t   \"touch-key-connected\");\n\tif (sdata->use_key) {\n\t\tinput_set_capability(sdata->input, EV_KEY, KEY_MENU);\n\t\tinput_set_capability(sdata->input, EV_KEY, KEY_BACK);\n\t}\n\n\terr = input_mt_init_slots(sdata->input,\n\t\t\t\t  STMFTS_MAX_FINGERS, INPUT_MT_DIRECT);\n\tif (err)\n\t\treturn err;\n\n\tinput_set_drvdata(sdata->input, sdata);\n\n\t \n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, stmfts_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t\"stmfts_irq\", sdata);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(&client->dev, \"initializing ST-Microelectronics FTS...\\n\");\n\n\terr = stmfts_power_on(sdata);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&client->dev, stmfts_power_off, sdata);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(sdata->input);\n\tif (err)\n\t\treturn err;\n\n\tif (sdata->use_key) {\n\t\terr = stmfts_enable_led(sdata);\n\t\tif (err) {\n\t\t\t \n\t\t\tdev_warn(&client->dev, \"unable to use touchkey leds\\n\");\n\t\t\tsdata->ledvdd = NULL;\n\t\t}\n\t}\n\n\terr = devm_device_add_group(&client->dev, &stmfts_attribute_group);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_enable(&client->dev);\n\tdevice_enable_async_suspend(&client->dev);\n\n\treturn 0;\n}\n\nstatic void stmfts_remove(struct i2c_client *client)\n{\n\tpm_runtime_disable(&client->dev);\n}\n\nstatic int stmfts_runtime_suspend(struct device *dev)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte(sdata->client, STMFTS_SLEEP_IN);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to suspend device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int stmfts_runtime_resume(struct device *dev)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte(sdata->client, STMFTS_SLEEP_OUT);\n\tif (ret)\n\t\tdev_err(dev, \"failed to resume device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int stmfts_suspend(struct device *dev)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\tstmfts_power_off(sdata);\n\n\treturn 0;\n}\n\nstatic int stmfts_resume(struct device *dev)\n{\n\tstruct stmfts_data *sdata = dev_get_drvdata(dev);\n\n\treturn stmfts_power_on(sdata);\n}\n\nstatic const struct dev_pm_ops stmfts_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(stmfts_suspend, stmfts_resume)\n\tRUNTIME_PM_OPS(stmfts_runtime_suspend, stmfts_runtime_resume, NULL)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id stmfts_of_match[] = {\n\t{ .compatible = \"st,stmfts\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, stmfts_of_match);\n#endif\n\nstatic const struct i2c_device_id stmfts_id[] = {\n\t{ \"stmfts\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, stmfts_id);\n\nstatic struct i2c_driver stmfts_driver = {\n\t.driver = {\n\t\t.name = STMFTS_DEV_NAME,\n\t\t.of_match_table = of_match_ptr(stmfts_of_match),\n\t\t.pm = pm_ptr(&stmfts_pm_ops),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = stmfts_probe,\n\t.remove = stmfts_remove,\n\t.id_table = stmfts_id,\n};\n\nmodule_i2c_driver(stmfts_driver);\n\nMODULE_AUTHOR(\"Andi Shyti <andi.shyti@samsung.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics FTS Touch Screen\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}