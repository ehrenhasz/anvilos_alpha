{
  "module_name": "colibri-vf50-ts.c",
  "hash_id": "d81f67b070cdd05a274204ee96ebf4e22803a70e34472e0202a1519506834505",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/colibri-vf50-ts.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/types.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define DRIVER_NAME\t\t\t\"colibri-vf50-ts\"\n\n#define VF_ADC_MAX\t\t\t((1 << 12) - 1)\n\n#define COLI_TOUCH_MIN_DELAY_US\t\t1000\n#define COLI_TOUCH_MAX_DELAY_US\t\t2000\n#define COLI_PULLUP_MIN_DELAY_US\t10000\n#define COLI_PULLUP_MAX_DELAY_US\t11000\n#define COLI_TOUCH_NO_OF_AVGS\t\t5\n#define COLI_TOUCH_REQ_ADC_CHAN\t\t4\n\nstruct vf50_touch_device {\n\tstruct platform_device *pdev;\n\tstruct input_dev *ts_input;\n\tstruct iio_channel *channels;\n\tstruct gpio_desc *gpio_xp;\n\tstruct gpio_desc *gpio_xm;\n\tstruct gpio_desc *gpio_yp;\n\tstruct gpio_desc *gpio_ym;\n\tint pen_irq;\n\tint min_pressure;\n\tbool stop_touchscreen;\n};\n\n \nstatic int adc_ts_measure(struct iio_channel *channel,\n\t\t\t  struct gpio_desc *plate_p, struct gpio_desc *plate_m)\n{\n\tint i, value = 0, val = 0;\n\tint error;\n\n\tgpiod_set_value(plate_p, 1);\n\tgpiod_set_value(plate_m, 1);\n\n\tusleep_range(COLI_TOUCH_MIN_DELAY_US, COLI_TOUCH_MAX_DELAY_US);\n\n\tfor (i = 0; i < COLI_TOUCH_NO_OF_AVGS; i++) {\n\t\terror = iio_read_channel_raw(channel, &val);\n\t\tif (error < 0) {\n\t\t\tvalue = error;\n\t\t\tgoto error_iio_read;\n\t\t}\n\n\t\tvalue += val;\n\t}\n\n\tvalue /= COLI_TOUCH_NO_OF_AVGS;\n\nerror_iio_read:\n\tgpiod_set_value(plate_p, 0);\n\tgpiod_set_value(plate_m, 0);\n\n\treturn value;\n}\n\n \nstatic void vf50_ts_enable_touch_detection(struct vf50_touch_device *vf50_ts)\n{\n\t \n\tgpiod_set_value(vf50_ts->gpio_ym, 1);\n\n\t \n\tpinctrl_pm_select_idle_state(&vf50_ts->pdev->dev);\n\n\t \n\tusleep_range(COLI_PULLUP_MIN_DELAY_US, COLI_PULLUP_MAX_DELAY_US);\n}\n\n \nstatic irqreturn_t vf50_ts_irq_bh(int irq, void *private)\n{\n\tstruct vf50_touch_device *vf50_ts = private;\n\tstruct device *dev = &vf50_ts->pdev->dev;\n\tint val_x, val_y, val_z1, val_z2, val_p = 0;\n\tbool discard_val_on_start = true;\n\n\t \n\tgpiod_set_value(vf50_ts->gpio_ym, 0);\n\n\t \n\tpinctrl_pm_select_default_state(dev);\n\n\twhile (!vf50_ts->stop_touchscreen) {\n\t\t \n\t\tval_x = adc_ts_measure(&vf50_ts->channels[0],\n\t\t\t\tvf50_ts->gpio_xp, vf50_ts->gpio_xm);\n\t\tif (val_x < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tval_y = adc_ts_measure(&vf50_ts->channels[1],\n\t\t\t\tvf50_ts->gpio_yp, vf50_ts->gpio_ym);\n\t\tif (val_y < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tval_z1 = adc_ts_measure(&vf50_ts->channels[2],\n\t\t\t\tvf50_ts->gpio_yp, vf50_ts->gpio_xm);\n\t\tif (val_z1 < 0)\n\t\t\tbreak;\n\t\tval_z2 = adc_ts_measure(&vf50_ts->channels[3],\n\t\t\t\tvf50_ts->gpio_yp, vf50_ts->gpio_xm);\n\t\tif (val_z2 < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (val_z1 > 64 && val_x > 64) {\n\t\t\t \n\t\t\tint r_x = (1000 * val_x) / VF_ADC_MAX;\n\n\t\t\tval_p = (r_x * val_z2) / val_z1 - r_x;\n\n\t\t} else {\n\t\t\tval_p = 2000;\n\t\t}\n\n\t\tval_p = 2000 - val_p;\n\t\tdev_dbg(dev,\n\t\t\t\"Measured values: x: %d, y: %d, z1: %d, z2: %d, p: %d\\n\",\n\t\t\tval_x, val_y, val_z1, val_z2, val_p);\n\n\t\t \n\t\tif (val_p < vf50_ts->min_pressure || val_p > 2000)\n\t\t\tbreak;\n\n\t\t \n\t\tif (discard_val_on_start) {\n\t\t\tdiscard_val_on_start = false;\n\t\t} else {\n\t\t\t \n\t\t\tinput_report_abs(vf50_ts->ts_input,\n\t\t\t\t\tABS_X, VF_ADC_MAX - val_x);\n\t\t\tinput_report_abs(vf50_ts->ts_input,\n\t\t\t\t\tABS_Y, VF_ADC_MAX - val_y);\n\t\t\tinput_report_abs(vf50_ts->ts_input,\n\t\t\t\t\tABS_PRESSURE, val_p);\n\t\t\tinput_report_key(vf50_ts->ts_input, BTN_TOUCH, 1);\n\t\t\tinput_sync(vf50_ts->ts_input);\n\t\t}\n\n\t\tusleep_range(COLI_PULLUP_MIN_DELAY_US,\n\t\t\t     COLI_PULLUP_MAX_DELAY_US);\n\t}\n\n\t \n\tinput_report_abs(vf50_ts->ts_input, ABS_PRESSURE, 0);\n\tinput_report_key(vf50_ts->ts_input, BTN_TOUCH, 0);\n\tinput_sync(vf50_ts->ts_input);\n\n\tvf50_ts_enable_touch_detection(vf50_ts);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vf50_ts_open(struct input_dev *dev_input)\n{\n\tstruct vf50_touch_device *touchdev = input_get_drvdata(dev_input);\n\tstruct device *dev = &touchdev->pdev->dev;\n\n\tdev_dbg(dev, \"Input device %s opened, starting touch detection\\n\",\n\t\tdev_input->name);\n\n\ttouchdev->stop_touchscreen = false;\n\n\t \n\tvf50_ts_enable_touch_detection(touchdev);\n\n\treturn 0;\n}\n\nstatic void vf50_ts_close(struct input_dev *dev_input)\n{\n\tstruct vf50_touch_device *touchdev = input_get_drvdata(dev_input);\n\tstruct device *dev = &touchdev->pdev->dev;\n\n\ttouchdev->stop_touchscreen = true;\n\n\t \n\tmb();\n\tsynchronize_irq(touchdev->pen_irq);\n\n\tgpiod_set_value(touchdev->gpio_ym, 0);\n\tpinctrl_pm_select_default_state(dev);\n\n\tdev_dbg(dev, \"Input device %s closed, disable touch detection\\n\",\n\t\tdev_input->name);\n}\n\nstatic int vf50_ts_get_gpiod(struct device *dev, struct gpio_desc **gpio_d,\n\t\t\t     const char *con_id, enum gpiod_flags flags)\n{\n\tint error;\n\n\t*gpio_d = devm_gpiod_get(dev, con_id, flags);\n\tif (IS_ERR(*gpio_d)) {\n\t\terror = PTR_ERR(*gpio_d);\n\t\tdev_err(dev, \"Could not get gpio_%s %d\\n\", con_id, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void vf50_ts_channel_release(void *data)\n{\n\tstruct iio_channel *channels = data;\n\n\tiio_channel_release_all(channels);\n}\n\nstatic int vf50_ts_probe(struct platform_device *pdev)\n{\n\tstruct input_dev *input;\n\tstruct iio_channel *channels;\n\tstruct device *dev = &pdev->dev;\n\tstruct vf50_touch_device *touchdev;\n\tint num_adc_channels;\n\tint error;\n\n\tchannels = iio_channel_get_all(dev);\n\tif (IS_ERR(channels))\n\t\treturn PTR_ERR(channels);\n\n\terror = devm_add_action(dev, vf50_ts_channel_release, channels);\n\tif (error) {\n\t\tiio_channel_release_all(channels);\n\t\tdev_err(dev, \"Failed to register iio channel release action\");\n\t\treturn error;\n\t}\n\n\tnum_adc_channels = 0;\n\twhile (channels[num_adc_channels].indio_dev)\n\t\tnum_adc_channels++;\n\n\tif (num_adc_channels != COLI_TOUCH_REQ_ADC_CHAN) {\n\t\tdev_err(dev, \"Inadequate ADC channels specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttouchdev = devm_kzalloc(dev, sizeof(*touchdev), GFP_KERNEL);\n\tif (!touchdev)\n\t\treturn -ENOMEM;\n\n\ttouchdev->pdev = pdev;\n\ttouchdev->channels = channels;\n\n\terror = of_property_read_u32(dev->of_node, \"vf50-ts-min-pressure\",\n\t\t\t\t &touchdev->min_pressure);\n\tif (error)\n\t\treturn error;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"Failed to allocate TS input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = DRIVER_NAME;\n\tinput->id.bustype = BUS_HOST;\n\tinput->dev.parent = dev;\n\tinput->open = vf50_ts_open;\n\tinput->close = vf50_ts_close;\n\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input, ABS_X, 0, VF_ADC_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, VF_ADC_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, VF_ADC_MAX, 0, 0);\n\n\ttouchdev->ts_input = input;\n\tinput_set_drvdata(input, touchdev);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\terror = vf50_ts_get_gpiod(dev, &touchdev->gpio_xp, \"xp\", GPIOD_OUT_LOW);\n\tif (error)\n\t\treturn error;\n\n\terror = vf50_ts_get_gpiod(dev, &touchdev->gpio_xm,\n\t\t\t\t\"xm\", GPIOD_OUT_LOW);\n\tif (error)\n\t\treturn error;\n\n\terror = vf50_ts_get_gpiod(dev, &touchdev->gpio_yp, \"yp\", GPIOD_OUT_LOW);\n\tif (error)\n\t\treturn error;\n\n\terror = vf50_ts_get_gpiod(dev, &touchdev->gpio_ym, \"ym\", GPIOD_OUT_LOW);\n\tif (error)\n\t\treturn error;\n\n\ttouchdev->pen_irq = platform_get_irq(pdev, 0);\n\tif (touchdev->pen_irq < 0)\n\t\treturn touchdev->pen_irq;\n\n\terror = devm_request_threaded_irq(dev, touchdev->pen_irq,\n\t\t\t\t\t  NULL, vf50_ts_irq_bh, IRQF_ONESHOT,\n\t\t\t\t\t  \"vf50 touch\", touchdev);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\ttouchdev->pen_irq, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vf50_touch_of_match[] = {\n\t{ .compatible = \"toradex,vf50-touchscreen\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, vf50_touch_of_match);\n\nstatic struct platform_driver vf50_touch_driver = {\n\t.driver = {\n\t\t.name = \"toradex,vf50_touchctrl\",\n\t\t.of_match_table = vf50_touch_of_match,\n\t},\n\t.probe = vf50_ts_probe,\n};\nmodule_platform_driver(vf50_touch_driver);\n\nMODULE_AUTHOR(\"Sanchayan Maity\");\nMODULE_DESCRIPTION(\"Colibri VF50 Touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}