{
  "module_name": "fsl-imx25-tcq.c",
  "hash_id": "6f395359f93b675f872aaf38de60c84fcbb053a9999b34d8390447b1331ee22b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/fsl-imx25-tcq.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/imx25-tsadc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\nstatic const char mx25_tcq_name[] = \"mx25-tcq\";\n\nenum mx25_tcq_mode {\n\tMX25_TS_4WIRE,\n};\n\nstruct mx25_tcq_priv {\n\tstruct regmap *regs;\n\tstruct regmap *core_regs;\n\tstruct input_dev *idev;\n\tenum mx25_tcq_mode mode;\n\tunsigned int pen_threshold;\n\tunsigned int sample_count;\n\tunsigned int expected_samples;\n\tunsigned int pen_debounce;\n\tunsigned int settling_time;\n\tstruct clk *clk;\n\tint irq;\n\tstruct device *dev;\n};\n\nstatic struct regmap_config mx25_tcq_regconfig = {\n\t.fast_io = true,\n\t.max_register = 0x5c,\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic const struct of_device_id mx25_tcq_ids[] = {\n\t{ .compatible = \"fsl,imx25-tcq\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mx25_tcq_ids);\n\n#define TSC_4WIRE_PRE_INDEX 0\n#define TSC_4WIRE_X_INDEX 1\n#define TSC_4WIRE_Y_INDEX 2\n#define TSC_4WIRE_POST_INDEX 3\n#define TSC_4WIRE_LEAVE 4\n\n#define MX25_TSC_DEF_THRESHOLD 80\n#define TSC_MAX_SAMPLES 16\n\n#define MX25_TSC_REPEAT_WAIT 14\n\nenum mx25_adc_configurations {\n\tMX25_CFG_PRECHARGE = 0,\n\tMX25_CFG_TOUCH_DETECT,\n\tMX25_CFG_X_MEASUREMENT,\n\tMX25_CFG_Y_MEASUREMENT,\n};\n\n#define MX25_PRECHARGE_VALUE (\\\n\t\t\tMX25_ADCQ_CFG_YPLL_OFF | \\\n\t\t\tMX25_ADCQ_CFG_XNUR_OFF | \\\n\t\t\tMX25_ADCQ_CFG_XPUL_HIGH | \\\n\t\t\tMX25_ADCQ_CFG_REFP_INT | \\\n\t\t\tMX25_ADCQ_CFG_IN_XP | \\\n\t\t\tMX25_ADCQ_CFG_REFN_NGND2 | \\\n\t\t\tMX25_ADCQ_CFG_IGS)\n\n#define MX25_TOUCH_DETECT_VALUE (\\\n\t\t\tMX25_ADCQ_CFG_YNLR | \\\n\t\t\tMX25_ADCQ_CFG_YPLL_OFF | \\\n\t\t\tMX25_ADCQ_CFG_XNUR_OFF | \\\n\t\t\tMX25_ADCQ_CFG_XPUL_OFF | \\\n\t\t\tMX25_ADCQ_CFG_REFP_INT | \\\n\t\t\tMX25_ADCQ_CFG_IN_XP | \\\n\t\t\tMX25_ADCQ_CFG_REFN_NGND2 | \\\n\t\t\tMX25_ADCQ_CFG_PENIACK)\n\nstatic void imx25_setup_queue_cfgs(struct mx25_tcq_priv *priv,\n\t\t\t\t   unsigned int settling_cnt)\n{\n\tu32 precharge_cfg =\n\t\t\tMX25_PRECHARGE_VALUE |\n\t\t\tMX25_ADCQ_CFG_SETTLING_TIME(settling_cnt);\n\tu32 touch_detect_cfg =\n\t\t\tMX25_TOUCH_DETECT_VALUE |\n\t\t\tMX25_ADCQ_CFG_NOS(1) |\n\t\t\tMX25_ADCQ_CFG_SETTLING_TIME(settling_cnt);\n\n\tregmap_write(priv->core_regs, MX25_TSC_TICR, precharge_cfg);\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_PRECHARGE),\n\t\t     precharge_cfg);\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_TOUCH_DETECT),\n\t\t     touch_detect_cfg);\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_X_MEASUREMENT),\n\t\t     MX25_ADCQ_CFG_YPLL_OFF |\n\t\t     MX25_ADCQ_CFG_XNUR_LOW |\n\t\t     MX25_ADCQ_CFG_XPUL_HIGH |\n\t\t     MX25_ADCQ_CFG_REFP_XP |\n\t\t     MX25_ADCQ_CFG_IN_YP |\n\t\t     MX25_ADCQ_CFG_REFN_XN |\n\t\t     MX25_ADCQ_CFG_NOS(priv->sample_count) |\n\t\t     MX25_ADCQ_CFG_SETTLING_TIME(settling_cnt));\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_Y_MEASUREMENT),\n\t\t     MX25_ADCQ_CFG_YNLR |\n\t\t     MX25_ADCQ_CFG_YPLL_HIGH |\n\t\t     MX25_ADCQ_CFG_XNUR_OFF |\n\t\t     MX25_ADCQ_CFG_XPUL_OFF |\n\t\t     MX25_ADCQ_CFG_REFP_YP |\n\t\t     MX25_ADCQ_CFG_IN_XP |\n\t\t     MX25_ADCQ_CFG_REFN_YN |\n\t\t     MX25_ADCQ_CFG_NOS(priv->sample_count) |\n\t\t     MX25_ADCQ_CFG_SETTLING_TIME(settling_cnt));\n\n\t \n\tregmap_write(priv->core_regs, MX25_TSC_TICR, touch_detect_cfg |\n\t\t     MX25_ADCQ_CFG_IGS);\n}\n\nstatic int imx25_setup_queue_4wire(struct mx25_tcq_priv *priv,\n\t\t\t\t   unsigned settling_cnt, int *items)\n{\n\timx25_setup_queue_cfgs(priv, settling_cnt);\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_ITEM_7_0,\n\t\t     MX25_ADCQ_ITEM(0, MX25_CFG_PRECHARGE) |\n\t\t     MX25_ADCQ_ITEM(1, MX25_CFG_TOUCH_DETECT) |\n\t\t     MX25_ADCQ_ITEM(2, MX25_CFG_X_MEASUREMENT) |\n\t\t     MX25_ADCQ_ITEM(3, MX25_CFG_Y_MEASUREMENT) |\n\t\t     MX25_ADCQ_ITEM(4, MX25_CFG_PRECHARGE) |\n\t\t     MX25_ADCQ_ITEM(5, MX25_CFG_TOUCH_DETECT));\n\n\t \n\tpriv->expected_samples = priv->sample_count * 2 + 2;\n\t*items = 6;\n\n\treturn 0;\n}\n\nstatic void mx25_tcq_disable_touch_irq(struct mx25_tcq_priv *priv)\n{\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_PDMSK,\n\t\t\t   MX25_ADCQ_CR_PDMSK);\n}\n\nstatic void mx25_tcq_enable_touch_irq(struct mx25_tcq_priv *priv)\n{\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_PDMSK, 0);\n}\n\nstatic void mx25_tcq_disable_fifo_irq(struct mx25_tcq_priv *priv)\n{\n\tregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_FDRY_IRQ,\n\t\t\t   MX25_ADCQ_MR_FDRY_IRQ);\n}\n\nstatic void mx25_tcq_enable_fifo_irq(struct mx25_tcq_priv *priv)\n{\n\tregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_FDRY_IRQ, 0);\n}\n\nstatic void mx25_tcq_force_queue_start(struct mx25_tcq_priv *priv)\n{\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR,\n\t\t\t   MX25_ADCQ_CR_FQS,\n\t\t\t   MX25_ADCQ_CR_FQS);\n}\n\nstatic void mx25_tcq_force_queue_stop(struct mx25_tcq_priv *priv)\n{\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR,\n\t\t\t   MX25_ADCQ_CR_FQS, 0);\n}\n\nstatic void mx25_tcq_fifo_reset(struct mx25_tcq_priv *priv)\n{\n\tu32 tcqcr;\n\n\tregmap_read(priv->regs, MX25_ADCQ_CR, &tcqcr);\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FRST,\n\t\t\t   MX25_ADCQ_CR_FRST);\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FRST, 0);\n\tregmap_write(priv->regs, MX25_ADCQ_CR, tcqcr);\n}\n\nstatic void mx25_tcq_re_enable_touch_detection(struct mx25_tcq_priv *priv)\n{\n\t \n\tmx25_tcq_force_queue_stop(priv);\n\n\t \n\tregmap_write(priv->core_regs, MX25_TSC_TICR, MX25_PRECHARGE_VALUE);\n\n\t \n\tmx25_tcq_fifo_reset(priv);\n\n\t \n\tregmap_write(priv->core_regs, MX25_TSC_TICR,\n\t\t     MX25_TOUCH_DETECT_VALUE | MX25_ADCQ_CFG_IGS);\n\n\tregmap_update_bits(priv->regs, MX25_ADCQ_SR, MX25_ADCQ_SR_PD,\n\t\t\t   MX25_ADCQ_SR_PD);\n\n\t \n\tregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_PD_IRQ, 0);\n\n\t \n\tmx25_tcq_enable_touch_irq(priv);\n}\n\nstatic void mx25_tcq_create_event_for_4wire(struct mx25_tcq_priv *priv,\n\t\t\t\t\t    u32 *sample_buf,\n\t\t\t\t\t    unsigned int samples)\n{\n\tunsigned int x_pos = 0;\n\tunsigned int y_pos = 0;\n\tunsigned int touch_pre = 0;\n\tunsigned int touch_post = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < samples; i++) {\n\t\tunsigned int index = MX25_ADCQ_FIFO_ID(sample_buf[i]);\n\t\tunsigned int val = MX25_ADCQ_FIFO_DATA(sample_buf[i]);\n\n\t\tswitch (index) {\n\t\tcase 1:\n\t\t\ttouch_pre = val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tx_pos = val;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ty_pos = val;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\ttouch_post = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(priv->dev, \"Dropped samples because of invalid index %d\\n\",\n\t\t\t\tindex);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (samples != 0) {\n\t\t \n\t\tif (touch_pre < priv->pen_threshold &&\n\t\t    touch_post < priv->pen_threshold) {\n\t\t\t \n\t\t\tx_pos /= priv->sample_count;\n\t\t\ty_pos /= priv->sample_count;\n\t\t\tinput_report_abs(priv->idev, ABS_X, x_pos);\n\t\t\tinput_report_abs(priv->idev, ABS_Y, y_pos);\n\t\t\tinput_report_key(priv->idev, BTN_TOUCH, 1);\n\t\t\tinput_sync(priv->idev);\n\n\t\t\t \n\t\t\tmx25_tcq_enable_fifo_irq(priv);\n\t\t} else if (touch_pre >= priv->pen_threshold &&\n\t\t\t   touch_post >= priv->pen_threshold) {\n\t\t\t \n\t\t\tinput_report_key(priv->idev, BTN_TOUCH, 0);\n\t\t\tinput_sync(priv->idev);\n\t\t\tmx25_tcq_re_enable_touch_detection(priv);\n\t\t} else {\n\t\t\t \n\t\t\tmx25_tcq_enable_fifo_irq(priv);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t mx25_tcq_irq_thread(int irq, void *dev_id)\n{\n\tstruct mx25_tcq_priv *priv = dev_id;\n\tu32 sample_buf[TSC_MAX_SAMPLES];\n\tunsigned int samples;\n\tu32 stats;\n\tunsigned int i;\n\n\t \n\tregmap_read(priv->regs, MX25_ADCQ_SR, &stats);\n\tsamples = MX25_ADCQ_SR_FDN(stats);\n\tsamples -= samples % priv->sample_count;\n\n\tif (!samples)\n\t\treturn IRQ_HANDLED;\n\n\tfor (i = 0; i != samples; ++i)\n\t\tregmap_read(priv->regs, MX25_ADCQ_FIFO, &sample_buf[i]);\n\n\tmx25_tcq_create_event_for_4wire(priv, sample_buf, samples);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mx25_tcq_irq(int irq, void *dev_id)\n{\n\tstruct mx25_tcq_priv *priv = dev_id;\n\tu32 stat;\n\tint ret = IRQ_HANDLED;\n\n\tregmap_read(priv->regs, MX25_ADCQ_SR, &stat);\n\n\tif (stat & (MX25_ADCQ_SR_FRR | MX25_ADCQ_SR_FUR | MX25_ADCQ_SR_FOR))\n\t\tmx25_tcq_re_enable_touch_detection(priv);\n\n\tif (stat & MX25_ADCQ_SR_PD) {\n\t\tmx25_tcq_disable_touch_irq(priv);\n\t\tmx25_tcq_force_queue_start(priv);\n\t\tmx25_tcq_enable_fifo_irq(priv);\n\t}\n\n\tif (stat & MX25_ADCQ_SR_FDRY) {\n\t\tmx25_tcq_disable_fifo_irq(priv);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tregmap_update_bits(priv->regs, MX25_ADCQ_SR, MX25_ADCQ_SR_FRR |\n\t\t\t   MX25_ADCQ_SR_FUR | MX25_ADCQ_SR_FOR |\n\t\t\t   MX25_ADCQ_SR_PD,\n\t\t\t   MX25_ADCQ_SR_FRR | MX25_ADCQ_SR_FUR |\n\t\t\t   MX25_ADCQ_SR_FOR | MX25_ADCQ_SR_PD);\n\n\treturn ret;\n}\n\n \nstatic int mx25_tcq_init(struct mx25_tcq_priv *priv)\n{\n\tu32 tgcr;\n\tunsigned int ipg_div;\n\tunsigned int adc_period;\n\tunsigned int debounce_cnt;\n\tunsigned int settling_cnt;\n\tint itemct;\n\tint error;\n\n\tregmap_read(priv->core_regs, MX25_TSC_TGCR, &tgcr);\n\tipg_div = max_t(unsigned int, 4, MX25_TGCR_GET_ADCCLK(tgcr));\n\tadc_period = USEC_PER_SEC * ipg_div * 2 + 2;\n\tadc_period /= clk_get_rate(priv->clk) / 1000 + 1;\n\tdebounce_cnt = DIV_ROUND_UP(priv->pen_debounce, adc_period * 8) - 1;\n\tsettling_cnt = DIV_ROUND_UP(priv->settling_time, adc_period * 8) - 1;\n\n\t \n\tregmap_write(priv->regs, MX25_ADCQ_CR,\n\t\t     MX25_ADCQ_CR_QRST | MX25_ADCQ_CR_FRST);\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR,\n\t\t\t   MX25_ADCQ_CR_QRST | MX25_ADCQ_CR_FRST, 0);\n\n\t \n\tif (debounce_cnt > 127)\n\t\tdebounce_cnt = 127;\n\n\t \n\tif (settling_cnt > 255)\n\t\tsettling_cnt = 255;\n\n\terror = imx25_setup_queue_4wire(priv, settling_cnt, &itemct);\n\tif (error)\n\t\treturn error;\n\n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR,\n\t\t\t   MX25_ADCQ_CR_LITEMID_MASK | MX25_ADCQ_CR_WMRK_MASK,\n\t\t\t   MX25_ADCQ_CR_LITEMID(itemct - 1) |\n\t\t\t   MX25_ADCQ_CR_WMRK(priv->expected_samples - 1));\n\n\t \n\tregmap_update_bits(priv->core_regs, MX25_TSC_TGCR,\n\t\t\t   MX25_TGCR_PDBTIME_MASK,\n\t\t\t   MX25_TGCR_PDBTIME(debounce_cnt));\n\n\t \n\tregmap_update_bits(priv->core_regs, MX25_TSC_TGCR, MX25_TGCR_PDBEN,\n\t\t\t   MX25_TGCR_PDBEN);\n\tregmap_update_bits(priv->core_regs, MX25_TSC_TGCR, MX25_TGCR_PDEN,\n\t\t\t   MX25_TGCR_PDEN);\n\n\t \n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_QSM_MASK,\n\t\t\t   MX25_ADCQ_CR_QSM_FQS);\n\n\t \n\tregmap_update_bits(priv->regs, MX25_ADCQ_CR,\n\t\t\t   MX25_ADCQ_CR_RPT | MX25_ADCQ_CR_RWAIT_MASK,\n\t\t\t   MX25_ADCQ_CR_RPT |\n\t\t\t   MX25_ADCQ_CR_RWAIT(MX25_TSC_REPEAT_WAIT));\n\n\treturn 0;\n}\n\nstatic int mx25_tcq_parse_dt(struct platform_device *pdev,\n\t\t\t     struct mx25_tcq_priv *priv)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 wires;\n\tint error;\n\n\t \n\tpriv->pen_threshold = 500;\n\tpriv->sample_count = 3;\n\tpriv->pen_debounce = 1000000;\n\tpriv->settling_time = 250000;\n\n\terror = of_property_read_u32(np, \"fsl,wires\", &wires);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to find fsl,wires properties\\n\");\n\t\treturn error;\n\t}\n\n\tif (wires == 4) {\n\t\tpriv->mode = MX25_TS_4WIRE;\n\t} else {\n\t\tdev_err(&pdev->dev, \"%u-wire mode not supported\\n\", wires);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tof_property_read_u32(np, \"fsl,pen-threshold\", &priv->pen_threshold);\n\tof_property_read_u32(np, \"fsl,settling-time-ns\", &priv->settling_time);\n\tof_property_read_u32(np, \"fsl,pen-debounce-ns\", &priv->pen_debounce);\n\n\treturn 0;\n}\n\nstatic int mx25_tcq_open(struct input_dev *idev)\n{\n\tstruct device *dev = &idev->dev;\n\tstruct mx25_tcq_priv *priv = dev_get_drvdata(dev);\n\tint error;\n\n\terror = clk_prepare_enable(priv->clk);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to enable ipg clock\\n\");\n\t\treturn error;\n\t}\n\n\terror = mx25_tcq_init(priv);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to init tcq\\n\");\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn error;\n\t}\n\n\tmx25_tcq_re_enable_touch_detection(priv);\n\n\treturn 0;\n}\n\nstatic void mx25_tcq_close(struct input_dev *idev)\n{\n\tstruct mx25_tcq_priv *priv = input_get_drvdata(idev);\n\n\tmx25_tcq_force_queue_stop(priv);\n\tmx25_tcq_disable_touch_irq(priv);\n\tmx25_tcq_disable_fifo_irq(priv);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic int mx25_tcq_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct input_dev *idev;\n\tstruct mx25_tcq_priv *priv;\n\tstruct mx25_tsadc *tsadc = dev_get_drvdata(dev->parent);\n\tvoid __iomem *mem;\n\tint error;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = dev;\n\n\tmem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\terror = mx25_tcq_parse_dt(pdev, priv);\n\tif (error)\n\t\treturn error;\n\n\tpriv->regs = devm_regmap_init_mmio(dev, mem, &mx25_tcq_regconfig);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(priv->regs);\n\t}\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq <= 0)\n\t\treturn priv->irq;\n\n\tidev = devm_input_allocate_device(dev);\n\tif (!idev) {\n\t\tdev_err(dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tidev->name = mx25_tcq_name;\n\tinput_set_capability(idev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(idev, ABS_X, 0, 0xfff, 0, 0);\n\tinput_set_abs_params(idev, ABS_Y, 0, 0xfff, 0, 0);\n\n\tidev->id.bustype = BUS_HOST;\n\tidev->open = mx25_tcq_open;\n\tidev->close = mx25_tcq_close;\n\n\tpriv->idev = idev;\n\tinput_set_drvdata(idev, priv);\n\n\tpriv->core_regs = tsadc->regs;\n\tif (!priv->core_regs)\n\t\treturn -EINVAL;\n\n\tpriv->clk = tsadc->clk;\n\tif (!priv->clk)\n\t\treturn -EINVAL;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\terror = devm_request_threaded_irq(dev, priv->irq, mx25_tcq_irq,\n\t\t\t\t\t  mx25_tcq_irq_thread, 0, pdev->name,\n\t\t\t\t\t  priv);\n\tif (error) {\n\t\tdev_err(dev, \"Failed requesting IRQ\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(idev);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver mx25_tcq_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"mx25-tcq\",\n\t\t.of_match_table = mx25_tcq_ids,\n\t},\n\t.probe\t\t= mx25_tcq_probe,\n};\nmodule_platform_driver(mx25_tcq_driver);\n\nMODULE_DESCRIPTION(\"TS input driver for Freescale mx25\");\nMODULE_AUTHOR(\"Markus Pargmann <mpa@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}