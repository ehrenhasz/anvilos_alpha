{
  "module_name": "zinitix.c",
  "hash_id": "8dc206ea94c0c9c6f90a36566359e026614d7d5556145a504cbe163d81c38be0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/zinitix.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n \n\n#define ZINITIX_SWRESET_CMD\t\t\t0x0000\n#define ZINITIX_WAKEUP_CMD\t\t\t0x0001\n\n#define ZINITIX_IDLE_CMD\t\t\t0x0004\n#define ZINITIX_SLEEP_CMD\t\t\t0x0005\n\n#define ZINITIX_CLEAR_INT_STATUS_CMD\t\t0x0003\n#define ZINITIX_CALIBRATE_CMD\t\t\t0x0006\n#define ZINITIX_SAVE_STATUS_CMD\t\t\t0x0007\n#define ZINITIX_SAVE_CALIBRATION_CMD\t\t0x0008\n#define ZINITIX_RECALL_FACTORY_CMD\t\t0x000f\n\n#define ZINITIX_THRESHOLD\t\t\t0x0020\n\n#define ZINITIX_LARGE_PALM_REJECT_AREA_TH\t0x003F\n\n#define ZINITIX_DEBUG_REG\t\t\t0x0115  \n\n#define ZINITIX_TOUCH_MODE\t\t\t0x0010\n#define ZINITIX_CHIP_REVISION\t\t\t0x0011\n#define ZINITIX_FIRMWARE_VERSION\t\t0x0012\n\n#define ZINITIX_USB_DETECT\t\t\t0x116\n\n#define ZINITIX_MINOR_FW_VERSION\t\t0x0121\n\n#define ZINITIX_VENDOR_ID\t\t\t0x001C\n#define ZINITIX_HW_ID\t\t\t\t0x0014\n\n#define ZINITIX_DATA_VERSION_REG\t\t0x0013\n#define ZINITIX_SUPPORTED_FINGER_NUM\t\t0x0015\n#define ZINITIX_EEPROM_INFO\t\t\t0x0018\n#define ZINITIX_INITIAL_TOUCH_MODE\t\t0x0019\n\n#define ZINITIX_TOTAL_NUMBER_OF_X\t\t0x0060\n#define ZINITIX_TOTAL_NUMBER_OF_Y\t\t0x0061\n\n#define ZINITIX_DELAY_RAW_FOR_HOST\t\t0x007f\n\n#define ZINITIX_BUTTON_SUPPORTED_NUM\t\t0x00B0\n#define ZINITIX_BUTTON_SENSITIVITY\t\t0x00B2\n#define ZINITIX_DUMMY_BUTTON_SENSITIVITY\t0X00C8\n\n#define ZINITIX_X_RESOLUTION\t\t\t0x00C0\n#define ZINITIX_Y_RESOLUTION\t\t\t0x00C1\n\n#define ZINITIX_POINT_STATUS_REG\t\t0x0080\n#define ZINITIX_ICON_STATUS_REG\t\t\t0x00AA\n\n#define ZINITIX_POINT_COORD_REG\t\t\t(ZINITIX_POINT_STATUS_REG + 2)\n\n#define ZINITIX_AFE_FREQUENCY\t\t\t0x0100\n#define ZINITIX_DND_N_COUNT\t\t\t0x0122\n#define ZINITIX_DND_U_COUNT\t\t\t0x0135\n\n#define ZINITIX_RAWDATA_REG\t\t\t0x0200\n\n#define ZINITIX_EEPROM_INFO_REG\t\t\t0x0018\n\n#define ZINITIX_INT_ENABLE_FLAG\t\t\t0x00f0\n#define ZINITIX_PERIODICAL_INTERRUPT_INTERVAL\t0x00f1\n\n#define ZINITIX_BTN_WIDTH\t\t\t0x016d\n\n#define ZINITIX_CHECKSUM_RESULT\t\t\t0x012c\n\n#define ZINITIX_INIT_FLASH\t\t\t0x01d0\n#define ZINITIX_WRITE_FLASH\t\t\t0x01d1\n#define ZINITIX_READ_FLASH\t\t\t0x01d2\n\n#define ZINITIX_INTERNAL_FLAG_02\t\t0x011e\n#define ZINITIX_INTERNAL_FLAG_03\t\t0x011f\n\n#define ZINITIX_I2C_CHECKSUM_WCNT\t\t0x016a\n#define ZINITIX_I2C_CHECKSUM_RESULT\t\t0x016c\n\n \n\n#define BIT_PT_CNT_CHANGE\t\t\tBIT(0)\n#define BIT_DOWN\t\t\t\tBIT(1)\n#define BIT_MOVE\t\t\t\tBIT(2)\n#define BIT_UP\t\t\t\t\tBIT(3)\n#define BIT_PALM\t\t\t\tBIT(4)\n#define BIT_PALM_REJECT\t\t\t\tBIT(5)\n#define BIT_RESERVED_0\t\t\t\tBIT(6)\n#define BIT_RESERVED_1\t\t\t\tBIT(7)\n#define BIT_WEIGHT_CHANGE\t\t\tBIT(8)\n#define BIT_PT_NO_CHANGE\t\t\tBIT(9)\n#define BIT_REJECT\t\t\t\tBIT(10)\n#define BIT_PT_EXIST\t\t\t\tBIT(11)\n#define BIT_RESERVED_2\t\t\t\tBIT(12)\n#define BIT_ERROR\t\t\t\tBIT(13)\n#define BIT_DEBUG\t\t\t\tBIT(14)\n#define BIT_ICON_EVENT\t\t\t\tBIT(15)\n\n#define SUB_BIT_EXIST\t\t\t\tBIT(0)\n#define SUB_BIT_DOWN\t\t\t\tBIT(1)\n#define SUB_BIT_MOVE\t\t\t\tBIT(2)\n#define SUB_BIT_UP\t\t\t\tBIT(3)\n#define SUB_BIT_UPDATE\t\t\t\tBIT(4)\n#define SUB_BIT_WAIT\t\t\t\tBIT(5)\n\n#define DEFAULT_TOUCH_POINT_MODE\t\t2\n#define MAX_SUPPORTED_FINGER_NUM\t\t5\n\n#define CHIP_ON_DELAY\t\t\t\t15 \n#define FIRMWARE_ON_DELAY\t\t\t40 \n\nstruct point_coord {\n\t__le16\tx;\n\t__le16\ty;\n\tu8\twidth;\n\tu8\tsub_status;\n\t\n\tu8\tminor_width;\n\tu8\tangle;\n};\n\nstruct touch_event {\n\t__le16\tstatus;\n\tu8\tfinger_mask;\n\tu8\ttime_stamp;\n\tstruct point_coord point_coord[MAX_SUPPORTED_FINGER_NUM];\n};\n\nstruct bt541_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tstruct touchscreen_properties prop;\n\tstruct regulator_bulk_data supplies[2];\n\tu32 zinitix_mode;\n};\n\nstatic int zinitix_read_data(struct i2c_client *client,\n\t\t\t     u16 reg, void *values, size_t length)\n{\n\t__le16 reg_le = cpu_to_le16(reg);\n\tint ret;\n\n\t \n\tret = i2c_master_send(client, (u8 *)&reg_le, sizeof(reg_le));\n\tif (ret != sizeof(reg_le))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\tret = i2c_master_recv(client, (u8 *)values, length);\n\tif (ret != length)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int zinitix_write_u16(struct i2c_client *client, u16 reg, u16 value)\n{\n\t__le16 packet[2] = {cpu_to_le16(reg), cpu_to_le16(value)};\n\tint ret;\n\n\tret = i2c_master_send(client, (u8 *)packet, sizeof(packet));\n\tif (ret != sizeof(packet))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int zinitix_write_cmd(struct i2c_client *client, u16 reg)\n{\n\t__le16 reg_le = cpu_to_le16(reg);\n\tint ret;\n\n\tret = i2c_master_send(client, (u8 *)&reg_le, sizeof(reg_le));\n\tif (ret != sizeof(reg_le))\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int zinitix_init_touch(struct bt541_ts_data *bt541)\n{\n\tstruct i2c_client *client = bt541->client;\n\tint i;\n\tint error;\n\n\terror = zinitix_write_cmd(client, ZINITIX_SWRESET_CMD);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to write reset command\\n\");\n\t\treturn error;\n\t}\n\n\terror = zinitix_write_u16(client, ZINITIX_INT_ENABLE_FLAG, 0x0);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to reset interrupt enable flag\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = zinitix_write_u16(client, ZINITIX_X_RESOLUTION,\n\t\t\t\t  bt541->prop.max_x);\n\tif (error)\n\t\treturn error;\n\n\terror = zinitix_write_u16(client, ZINITIX_Y_RESOLUTION,\n\t\t\t\t  bt541->prop.max_y);\n\tif (error)\n\t\treturn error;\n\n\terror = zinitix_write_u16(client, ZINITIX_SUPPORTED_FINGER_NUM,\n\t\t\t\t  MAX_SUPPORTED_FINGER_NUM);\n\tif (error)\n\t\treturn error;\n\n\terror = zinitix_write_u16(client, ZINITIX_INITIAL_TOUCH_MODE,\n\t\t\t\t  bt541->zinitix_mode);\n\tif (error)\n\t\treturn error;\n\n\terror = zinitix_write_u16(client, ZINITIX_TOUCH_MODE,\n\t\t\t\t  bt541->zinitix_mode);\n\tif (error)\n\t\treturn error;\n\n\terror = zinitix_write_u16(client, ZINITIX_INT_ENABLE_FLAG,\n\t\t\t\t  BIT_PT_CNT_CHANGE | BIT_DOWN | BIT_MOVE |\n\t\t\t\t\tBIT_UP);\n\tif (error)\n\t\treturn error;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tzinitix_write_cmd(client, ZINITIX_CLEAR_INT_STATUS_CMD);\n\t\tudelay(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int zinitix_init_regulators(struct bt541_ts_data *bt541)\n{\n\tstruct device *dev = &bt541->client->dev;\n\tint error;\n\n\t \n\tif (of_property_present(dev->of_node, \"vddo-supply\")) {\n\t\tbt541->supplies[0].supply = \"vdd\";\n\t\tbt541->supplies[1].supply = \"vddo\";\n\t} else {\n\t\t \n\t\tbt541->supplies[0].supply = \"vcca\";\n\t\tbt541->supplies[1].supply = \"vdd\";\n\t}\n\terror = devm_regulator_bulk_get(dev,\n\t\t\t\t\tARRAY_SIZE(bt541->supplies),\n\t\t\t\t\tbt541->supplies);\n\tif (error < 0) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int zinitix_send_power_on_sequence(struct bt541_ts_data *bt541)\n{\n\tint error;\n\tstruct i2c_client *client = bt541->client;\n\n\terror = zinitix_write_u16(client, 0xc000, 0x0001);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to send power sequence(vendor cmd enable)\\n\");\n\t\treturn error;\n\t}\n\tudelay(10);\n\n\terror = zinitix_write_cmd(client, 0xc004);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to send power sequence (intn clear)\\n\");\n\t\treturn error;\n\t}\n\tudelay(10);\n\n\terror = zinitix_write_u16(client, 0xc002, 0x0001);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to send power sequence (nvm init)\\n\");\n\t\treturn error;\n\t}\n\tmdelay(2);\n\n\terror = zinitix_write_u16(client, 0xc001, 0x0001);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to send power sequence (program start)\\n\");\n\t\treturn error;\n\t}\n\tmsleep(FIRMWARE_ON_DELAY);\n\n\treturn 0;\n}\n\nstatic void zinitix_report_finger(struct bt541_ts_data *bt541, int slot,\n\t\t\t\t  const struct point_coord *p)\n{\n\tu16 x, y;\n\n\tif (unlikely(!(p->sub_status &\n\t\t       (SUB_BIT_UP | SUB_BIT_DOWN | SUB_BIT_MOVE)))) {\n\t\tdev_dbg(&bt541->client->dev, \"unknown finger event %#02x\\n\",\n\t\t\tp->sub_status);\n\t\treturn;\n\t}\n\n\tx = le16_to_cpu(p->x);\n\ty = le16_to_cpu(p->y);\n\n\tinput_mt_slot(bt541->input_dev, slot);\n\tif (input_mt_report_slot_state(bt541->input_dev, MT_TOOL_FINGER,\n\t\t\t\t       !(p->sub_status & SUB_BIT_UP))) {\n\t\ttouchscreen_report_pos(bt541->input_dev,\n\t\t\t\t       &bt541->prop, x, y, true);\n\t\tinput_report_abs(bt541->input_dev,\n\t\t\t\t ABS_MT_TOUCH_MAJOR, p->width);\n\t\tdev_dbg(&bt541->client->dev, \"finger %d %s (%u, %u)\\n\",\n\t\t\tslot, p->sub_status & SUB_BIT_DOWN ? \"down\" : \"move\",\n\t\t\tx, y);\n\t} else {\n\t\tdev_dbg(&bt541->client->dev, \"finger %d up (%u, %u)\\n\",\n\t\t\tslot, x, y);\n\t}\n}\n\nstatic irqreturn_t zinitix_ts_irq_handler(int irq, void *bt541_handler)\n{\n\tstruct bt541_ts_data *bt541 = bt541_handler;\n\tstruct i2c_client *client = bt541->client;\n\tstruct touch_event touch_event;\n\tunsigned long finger_mask;\n\tint error;\n\tint i;\n\n\tmemset(&touch_event, 0, sizeof(struct touch_event));\n\n\terror = zinitix_read_data(bt541->client, ZINITIX_POINT_STATUS_REG,\n\t\t\t\t  &touch_event, sizeof(struct touch_event));\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read in touchpoint struct\\n\");\n\t\tgoto out;\n\t}\n\n\tfinger_mask = touch_event.finger_mask;\n\tfor_each_set_bit(i, &finger_mask, MAX_SUPPORTED_FINGER_NUM) {\n\t\tconst struct point_coord *p = &touch_event.point_coord[i];\n\n\t\t \n\t\tif (p->sub_status & SUB_BIT_EXIST)\n\t\t\tzinitix_report_finger(bt541, i, p);\n\t}\n\n\tinput_mt_sync_frame(bt541->input_dev);\n\tinput_sync(bt541->input_dev);\n\nout:\n\tzinitix_write_cmd(bt541->client, ZINITIX_CLEAR_INT_STATUS_CMD);\n\treturn IRQ_HANDLED;\n}\n\nstatic int zinitix_start(struct bt541_ts_data *bt541)\n{\n\tint error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(bt541->supplies),\n\t\t\t\t      bt541->supplies);\n\tif (error) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Failed to enable regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(CHIP_ON_DELAY);\n\n\terror = zinitix_send_power_on_sequence(bt541);\n\tif (error) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Error while sending power-on sequence: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = zinitix_init_touch(bt541);\n\tif (error) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Error while configuring touch IC\\n\");\n\t\treturn error;\n\t}\n\n\tenable_irq(bt541->client->irq);\n\n\treturn 0;\n}\n\nstatic int zinitix_stop(struct bt541_ts_data *bt541)\n{\n\tint error;\n\n\tdisable_irq(bt541->client->irq);\n\n\terror = regulator_bulk_disable(ARRAY_SIZE(bt541->supplies),\n\t\t\t\t       bt541->supplies);\n\tif (error) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Failed to disable regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int zinitix_input_open(struct input_dev *dev)\n{\n\tstruct bt541_ts_data *bt541 = input_get_drvdata(dev);\n\n\treturn zinitix_start(bt541);\n}\n\nstatic void zinitix_input_close(struct input_dev *dev)\n{\n\tstruct bt541_ts_data *bt541 = input_get_drvdata(dev);\n\n\tzinitix_stop(bt541);\n}\n\nstatic int zinitix_init_input_dev(struct bt541_ts_data *bt541)\n{\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tinput_dev = devm_input_allocate_device(&bt541->client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Failed to allocate input device.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_drvdata(input_dev, bt541);\n\tbt541->input_dev = input_dev;\n\n\tinput_dev->name = \"Zinitix Capacitive TouchScreen\";\n\tinput_dev->phys = \"input/ts\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->open = zinitix_input_open;\n\tinput_dev->close = zinitix_input_close;\n\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\n\ttouchscreen_parse_properties(input_dev, true, &bt541->prop);\n\tif (!bt541->prop.max_x || !bt541->prop.max_y) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Touchscreen-size-x and/or touchscreen-size-y not set in dts\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_mt_init_slots(input_dev, MAX_SUPPORTED_FINGER_NUM,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Failed to initialize MT slots: %d\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(&bt541->client->dev,\n\t\t\t\"Failed to register input device: %d\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int zinitix_ts_probe(struct i2c_client *client)\n{\n\tstruct bt541_ts_data *bt541;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to assert adapter's support for plain I2C.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tbt541 = devm_kzalloc(&client->dev, sizeof(*bt541), GFP_KERNEL);\n\tif (!bt541)\n\t\treturn -ENOMEM;\n\n\tbt541->client = client;\n\ti2c_set_clientdata(client, bt541);\n\n\terror = zinitix_init_regulators(bt541);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to initialize regulators: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, zinitix_ts_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  client->name, bt541);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = zinitix_init_input_dev(bt541);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to initialize input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = device_property_read_u32(&client->dev, \"zinitix,mode\",\n\t\t\t\t\t &bt541->zinitix_mode);\n\tif (error < 0) {\n\t\t \n\t\tbt541->zinitix_mode = DEFAULT_TOUCH_POINT_MODE;\n\t}\n\n\tif (bt541->zinitix_mode != 2) {\n\t\t \n\t\tdev_err(&client->dev,\n\t\t\t\"Malformed zinitix,mode property, must be 2 (supplied: %d)\\n\",\n\t\t\tbt541->zinitix_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int zinitix_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bt541_ts_data *bt541 = i2c_get_clientdata(client);\n\n\tmutex_lock(&bt541->input_dev->mutex);\n\n\tif (input_device_enabled(bt541->input_dev))\n\t\tzinitix_stop(bt541);\n\n\tmutex_unlock(&bt541->input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int zinitix_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bt541_ts_data *bt541 = i2c_get_clientdata(client);\n\tint ret = 0;\n\n\tmutex_lock(&bt541->input_dev->mutex);\n\n\tif (input_device_enabled(bt541->input_dev))\n\t\tret = zinitix_start(bt541);\n\n\tmutex_unlock(&bt541->input_dev->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(zinitix_pm_ops, zinitix_suspend, zinitix_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id zinitix_of_match[] = {\n\t{ .compatible = \"zinitix,bt402\" },\n\t{ .compatible = \"zinitix,bt403\" },\n\t{ .compatible = \"zinitix,bt404\" },\n\t{ .compatible = \"zinitix,bt412\" },\n\t{ .compatible = \"zinitix,bt413\" },\n\t{ .compatible = \"zinitix,bt431\" },\n\t{ .compatible = \"zinitix,bt432\" },\n\t{ .compatible = \"zinitix,bt531\" },\n\t{ .compatible = \"zinitix,bt532\" },\n\t{ .compatible = \"zinitix,bt538\" },\n\t{ .compatible = \"zinitix,bt541\" },\n\t{ .compatible = \"zinitix,bt548\" },\n\t{ .compatible = \"zinitix,bt554\" },\n\t{ .compatible = \"zinitix,at100\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, zinitix_of_match);\n#endif\n\nstatic struct i2c_driver zinitix_ts_driver = {\n\t.probe = zinitix_ts_probe,\n\t.driver = {\n\t\t.name = \"Zinitix-TS\",\n\t\t.pm = pm_sleep_ptr(&zinitix_pm_ops),\n\t\t.of_match_table = of_match_ptr(zinitix_of_match),\n\t},\n};\nmodule_i2c_driver(zinitix_ts_driver);\n\nMODULE_AUTHOR(\"Michael Srba <Michael.Srba@seznam.cz>\");\nMODULE_DESCRIPTION(\"Zinitix touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}