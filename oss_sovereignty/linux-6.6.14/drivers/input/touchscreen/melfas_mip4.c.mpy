{
  "module_name": "melfas_mip4.c",
  "hash_id": "5c3313115ebb95b4b650638ccd7ca294f1649ddbcd03ba3b9d82a03af6b81e1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/melfas_mip4.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define MIP4_DEVICE_NAME\t\"mip4_ts\"\n\n \n\n \n#define MIP4_R0_BOOT\t\t\t\t0x00\n#define MIP4_R1_BOOT_MODE\t\t\t0x01\n#define MIP4_R1_BOOT_BUF_ADDR\t\t\t0x10\n#define MIP4_R1_BOOT_STATUS\t\t\t0x20\n#define MIP4_R1_BOOT_CMD\t\t\t0x30\n#define MIP4_R1_BOOT_TARGET_ADDR\t\t0x40\n#define MIP4_R1_BOOT_SIZE\t\t\t0x44\n\n#define MIP4_R0_INFO\t\t\t\t0x01\n#define MIP4_R1_INFO_PRODUCT_NAME\t\t0x00\n#define MIP4_R1_INFO_RESOLUTION_X\t\t0x10\n#define MIP4_R1_INFO_RESOLUTION_Y\t\t0x12\n#define MIP4_R1_INFO_NODE_NUM_X\t\t\t0x14\n#define MIP4_R1_INFO_NODE_NUM_Y\t\t\t0x15\n#define MIP4_R1_INFO_KEY_NUM\t\t\t0x16\n#define MIP4_R1_INFO_PRESSURE_NUM\t\t0x17\n#define MIP4_R1_INFO_LENGTH_X\t\t\t0x18\n#define MIP4_R1_INFO_LENGTH_Y\t\t\t0x1A\n#define MIP4_R1_INFO_PPM_X\t\t\t0x1C\n#define MIP4_R1_INFO_PPM_Y\t\t\t0x1D\n#define MIP4_R1_INFO_VERSION_BOOT\t\t0x20\n#define MIP4_R1_INFO_VERSION_CORE\t\t0x22\n#define MIP4_R1_INFO_VERSION_APP\t\t0x24\n#define MIP4_R1_INFO_VERSION_PARAM\t\t0x26\n#define MIP4_R1_INFO_SECT_BOOT_START\t\t0x30\n#define MIP4_R1_INFO_SECT_BOOT_END\t\t0x31\n#define MIP4_R1_INFO_SECT_CORE_START\t\t0x32\n#define MIP4_R1_INFO_SECT_CORE_END\t\t0x33\n#define MIP4_R1_INFO_SECT_APP_START\t\t0x34\n#define MIP4_R1_INFO_SECT_APP_END\t\t0x35\n#define MIP4_R1_INFO_SECT_PARAM_START\t\t0x36\n#define MIP4_R1_INFO_SECT_PARAM_END\t\t0x37\n#define MIP4_R1_INFO_BUILD_DATE\t\t\t0x40\n#define MIP4_R1_INFO_BUILD_TIME\t\t\t0x44\n#define MIP4_R1_INFO_CHECKSUM_PRECALC\t\t0x48\n#define MIP4_R1_INFO_CHECKSUM_REALTIME\t\t0x4A\n#define MIP4_R1_INFO_PROTOCOL_NAME\t\t0x50\n#define MIP4_R1_INFO_PROTOCOL_VERSION\t\t0x58\n#define MIP4_R1_INFO_IC_ID\t\t\t0x70\n#define MIP4_R1_INFO_IC_NAME\t\t\t0x71\n#define MIP4_R1_INFO_IC_VENDOR_ID\t\t0x75\n#define MIP4_R1_INFO_IC_HW_CATEGORY\t\t0x77\n#define MIP4_R1_INFO_CONTACT_THD_SCR\t\t0x78\n#define MIP4_R1_INFO_CONTACT_THD_KEY\t\t0x7A\n#define MIP4_R1_INFO_PID\t\t\t\t0x7C\n#define MIP4_R1_INFO_VID\t\t\t\t0x7E\n#define MIP4_R1_INFO_SLAVE_ADDR\t\t\t0x80\n\n#define MIP4_R0_EVENT\t\t\t\t0x02\n#define MIP4_R1_EVENT_SUPPORTED_FUNC\t\t0x00\n#define MIP4_R1_EVENT_FORMAT\t\t\t0x04\n#define MIP4_R1_EVENT_SIZE\t\t\t0x06\n#define MIP4_R1_EVENT_PACKET_INFO\t\t0x10\n#define MIP4_R1_EVENT_PACKET_DATA\t\t0x11\n\n#define MIP4_R0_CTRL\t\t\t\t0x06\n#define MIP4_R1_CTRL_READY_STATUS\t\t0x00\n#define MIP4_R1_CTRL_EVENT_READY\t\t0x01\n#define MIP4_R1_CTRL_MODE\t\t\t0x10\n#define MIP4_R1_CTRL_EVENT_TRIGGER_TYPE\t\t0x11\n#define MIP4_R1_CTRL_RECALIBRATE\t\t0x12\n#define MIP4_R1_CTRL_POWER_STATE\t\t0x13\n#define MIP4_R1_CTRL_GESTURE_TYPE\t\t0x14\n#define MIP4_R1_CTRL_DISABLE_ESD_ALERT\t\t0x18\n#define MIP4_R1_CTRL_CHARGER_MODE\t\t0x19\n#define MIP4_R1_CTRL_HIGH_SENS_MODE\t\t0x1A\n#define MIP4_R1_CTRL_WINDOW_MODE\t\t0x1B\n#define MIP4_R1_CTRL_PALM_REJECTION\t\t0x1C\n#define MIP4_R1_CTRL_EDGE_CORRECTION\t\t0x1D\n#define MIP4_R1_CTRL_ENTER_GLOVE_MODE\t\t0x1E\n#define MIP4_R1_CTRL_I2C_ON_LPM\t\t\t0x1F\n#define MIP4_R1_CTRL_GESTURE_DEBUG\t\t0x20\n#define MIP4_R1_CTRL_PALM_EVENT\t\t\t0x22\n#define MIP4_R1_CTRL_PROXIMITY_SENSING\t\t0x23\n\n \n#define MIP4_BOOT_MODE_BOOT\t\t\t0x01\n#define MIP4_BOOT_MODE_APP\t\t\t0x02\n\n#define MIP4_BOOT_STATUS_BUSY\t\t\t0x05\n#define MIP4_BOOT_STATUS_ERROR\t\t\t0x0E\n#define MIP4_BOOT_STATUS_DONE\t\t\t0xA0\n\n#define MIP4_BOOT_CMD_MASS_ERASE\t\t0x15\n#define MIP4_BOOT_CMD_PROGRAM\t\t\t0x54\n#define MIP4_BOOT_CMD_ERASE\t\t\t0x8F\n#define MIP4_BOOT_CMD_WRITE\t\t\t0xA5\n#define MIP4_BOOT_CMD_READ\t\t\t0xC2\n\n#define MIP4_EVENT_INPUT_TYPE_KEY\t\t0\n#define MIP4_EVENT_INPUT_TYPE_SCREEN\t\t1\n#define MIP4_EVENT_INPUT_TYPE_PROXIMITY\t\t2\n\n#define I2C_RETRY_COUNT\t\t\t\t3\t \n\n#define MIP4_BUF_SIZE\t\t\t\t128\n#define MIP4_MAX_FINGERS\t\t\t10\n#define MIP4_MAX_KEYS\t\t\t\t4\n\n#define MIP4_TOUCH_MAJOR_MIN\t\t\t0\n#define MIP4_TOUCH_MAJOR_MAX\t\t\t255\n#define MIP4_TOUCH_MINOR_MIN\t\t\t0\n#define MIP4_TOUCH_MINOR_MAX\t\t\t255\n#define MIP4_PRESSURE_MIN\t\t\t0\n#define MIP4_PRESSURE_MAX\t\t\t255\n\n#define MIP4_FW_NAME\t\t\t\"melfas_mip4.fw\"\n#define MIP4_FW_UPDATE_DEBUG\t\t0\t \n\nstruct mip4_fw_version {\n\tu16 boot;\n\tu16 core;\n\tu16 app;\n\tu16 param;\n};\n\nstruct mip4_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *gpio_ce;\n\n\tchar phys[32];\n\tchar product_name[16];\n\tu16 product_id;\n\tchar ic_name[4];\n\tchar fw_name[32];\n\n\tunsigned int max_x;\n\tunsigned int max_y;\n\tu8 node_x;\n\tu8 node_y;\n\tu8 node_key;\n\tunsigned int ppm_x;\n\tunsigned int ppm_y;\n\n\tstruct mip4_fw_version fw_version;\n\n\tunsigned int event_size;\n\tunsigned int event_format;\n\n\tunsigned int key_num;\n\tunsigned short key_code[MIP4_MAX_KEYS];\n\n\tbool wake_irq_enabled;\n\n\tu8 buf[MIP4_BUF_SIZE];\n};\n\nstatic int mip4_i2c_xfer(struct mip4_ts *ts,\n\t\t\t char *write_buf, unsigned int write_len,\n\t\t\t char *read_buf, unsigned int read_len)\n{\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = write_buf,\n\t\t\t.len = write_len,\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = read_buf,\n\t\t\t.len = read_len,\n\t\t},\n\t};\n\tint retry = I2C_RETRY_COUNT;\n\tint res;\n\tint error;\n\n\tdo {\n\t\tres = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (res == ARRAY_SIZE(msg))\n\t\t\treturn 0;\n\n\t\terror = res < 0 ? res : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"%s - i2c_transfer failed: %d (%d)\\n\",\n\t\t\t__func__, error, res);\n\t} while (--retry);\n\n\treturn error;\n}\n\nstatic void mip4_parse_fw_version(const u8 *buf, struct mip4_fw_version *v)\n{\n\tv->boot  = get_unaligned_le16(buf + 0);\n\tv->core  = get_unaligned_le16(buf + 2);\n\tv->app   = get_unaligned_le16(buf + 4);\n\tv->param = get_unaligned_le16(buf + 6);\n}\n\n \nstatic int mip4_get_fw_version(struct mip4_ts *ts)\n{\n\tu8 cmd[] = { MIP4_R0_INFO, MIP4_R1_INFO_VERSION_BOOT };\n\tu8 buf[sizeof(ts->fw_version)];\n\tint error;\n\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, sizeof(buf));\n\tif (error) {\n\t\tmemset(&ts->fw_version, 0xff, sizeof(ts->fw_version));\n\t\treturn error;\n\t}\n\n\tmip4_parse_fw_version(buf, &ts->fw_version);\n\n\treturn 0;\n}\n\n \nstatic int mip4_query_device(struct mip4_ts *ts)\n{\n\tunion i2c_smbus_data dummy;\n\tint error;\n\tu8 cmd[2];\n\tu8 buf[14];\n\n\t \n\tif (i2c_smbus_xfer(ts->client->adapter, ts->client->addr,\n\t\t\t   0, I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0) {\n\t\tdev_err(&ts->client->dev, \"nothing at this address\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_INFO;\n\tcmd[1] = MIP4_R1_INFO_PRODUCT_NAME;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd),\n\t\t\t      ts->product_name, sizeof(ts->product_name));\n\tif (error)\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"Failed to retrieve product name: %d\\n\", error);\n\telse\n\t\tdev_dbg(&ts->client->dev, \"product name: %.*s\\n\",\n\t\t\t(int)sizeof(ts->product_name), ts->product_name);\n\n\t \n\tcmd[0] = MIP4_R0_INFO;\n\tcmd[1] = MIP4_R1_INFO_PID;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, 2);\n\tif (error) {\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"Failed to retrieve product id: %d\\n\", error);\n\t} else {\n\t\tts->product_id = get_unaligned_le16(&buf[0]);\n\t\tdev_dbg(&ts->client->dev, \"product id: %04X\\n\", ts->product_id);\n\t}\n\n\t \n\tsnprintf(ts->fw_name, sizeof(ts->fw_name),\n\t\t\"melfas_mip4_%04X.fw\", ts->product_id);\n\tdev_dbg(&ts->client->dev, \"firmware name: %s\\n\", ts->fw_name);\n\n\t \n\tcmd[0] = MIP4_R0_INFO;\n\tcmd[1] = MIP4_R1_INFO_IC_NAME;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd),\n\t\t\t      ts->ic_name, sizeof(ts->ic_name));\n\tif (error)\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"Failed to retrieve IC name: %d\\n\", error);\n\telse\n\t\tdev_dbg(&ts->client->dev, \"IC name: %.*s\\n\",\n\t\t\t(int)sizeof(ts->ic_name), ts->ic_name);\n\n\t \n\terror = mip4_get_fw_version(ts);\n\tif (error)\n\t\tdev_warn(&ts->client->dev,\n\t\t\t\"Failed to retrieve FW version: %d\\n\", error);\n\telse\n\t\tdev_dbg(&ts->client->dev, \"F/W Version: %04X %04X %04X %04X\\n\",\n\t\t\t ts->fw_version.boot, ts->fw_version.core,\n\t\t\t ts->fw_version.app, ts->fw_version.param);\n\n\t \n\tcmd[0] = MIP4_R0_INFO;\n\tcmd[1] = MIP4_R1_INFO_RESOLUTION_X;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, 14);\n\tif (error) {\n\t\tdev_warn(&ts->client->dev,\n\t\t\t \"Failed to retrieve touchscreen parameters: %d\\n\",\n\t\t\t error);\n\t} else {\n\t\tts->max_x = get_unaligned_le16(&buf[0]);\n\t\tts->max_y = get_unaligned_le16(&buf[2]);\n\t\tdev_dbg(&ts->client->dev, \"max_x: %d, max_y: %d\\n\",\n\t\t\tts->max_x, ts->max_y);\n\n\t\tts->node_x = buf[4];\n\t\tts->node_y = buf[5];\n\t\tts->node_key = buf[6];\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"node_x: %d, node_y: %d, node_key: %d\\n\",\n\t\t\tts->node_x, ts->node_y, ts->node_key);\n\n\t\tts->ppm_x = buf[12];\n\t\tts->ppm_y = buf[13];\n\t\tdev_dbg(&ts->client->dev, \"ppm_x: %d, ppm_y: %d\\n\",\n\t\t\tts->ppm_x, ts->ppm_y);\n\n\t\t \n\t\tif (ts->node_key > 0)\n\t\t\tts->key_num = ts->node_key;\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_EVENT;\n\tcmd[1] = MIP4_R1_EVENT_SUPPORTED_FUNC;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), buf, 7);\n\tif (error) {\n\t\tdev_warn(&ts->client->dev,\n\t\t\t\"Failed to retrieve device type: %d\\n\", error);\n\t\tts->event_format = 0xff;\n\t} else {\n\t\tts->event_format = get_unaligned_le16(&buf[4]);\n\t\tts->event_size = buf[6];\n\t\tdev_dbg(&ts->client->dev, \"event_format: %d, event_size: %d\\n\",\n\t\t\tts->event_format, ts->event_size);\n\n\t\tif (ts->event_format == 2 || ts->event_format > 3)\n\t\t\tdev_warn(&ts->client->dev,\n\t\t\t\t \"Unknown event format %d\\n\", ts->event_format);\n\t}\n\n\treturn 0;\n}\n\nstatic int mip4_power_on(struct mip4_ts *ts)\n{\n\tif (ts->gpio_ce) {\n\t\tgpiod_set_value_cansleep(ts->gpio_ce, 1);\n\n\t\t \n\t\tusleep_range(200 * 1000, 300 * 1000);\n\t}\n\n\treturn 0;\n}\n\nstatic void mip4_power_off(struct mip4_ts *ts)\n{\n\tif (ts->gpio_ce)\n\t\tgpiod_set_value_cansleep(ts->gpio_ce, 0);\n}\n\n \nstatic void mip4_clear_input(struct mip4_ts *ts)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < MIP4_MAX_FINGERS; i++) {\n\t\tinput_mt_slot(ts->input, i);\n\t\tinput_mt_report_slot_inactive(ts->input);\n\t}\n\n\t \n\tfor (i = 0; i < ts->key_num; i++)\n\t\tinput_report_key(ts->input, ts->key_code[i], 0);\n\n\tinput_sync(ts->input);\n}\n\nstatic int mip4_enable(struct mip4_ts *ts)\n{\n\tint error;\n\n\terror = mip4_power_on(ts);\n\tif (error)\n\t\treturn error;\n\n\tenable_irq(ts->client->irq);\n\n\treturn 0;\n}\n\nstatic void mip4_disable(struct mip4_ts *ts)\n{\n\tdisable_irq(ts->client->irq);\n\n\tmip4_power_off(ts);\n\n\tmip4_clear_input(ts);\n}\n\n \n\nstatic void mip4_report_keys(struct mip4_ts *ts, u8 *packet)\n{\n\tu8 key;\n\tbool down;\n\n\tswitch (ts->event_format) {\n\tcase 0:\n\tcase 1:\n\t\tkey = packet[0] & 0x0F;\n\t\tdown = packet[0] & 0x80;\n\t\tbreak;\n\n\tcase 3:\n\tdefault:\n\t\tkey = packet[0] & 0x0F;\n\t\tdown = packet[1] & 0x01;\n\t\tbreak;\n\t}\n\n\t \n\tif (key >= 1 && key <= ts->key_num) {\n\t\tunsigned short keycode = ts->key_code[key - 1];\n\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"Key - ID: %d, keycode: %d, state: %d\\n\",\n\t\t\tkey, keycode, down);\n\n\t\tinput_event(ts->input, EV_MSC, MSC_SCAN, keycode);\n\t\tinput_report_key(ts->input, keycode, down);\n\n\t} else {\n\t\tdev_err(&ts->client->dev, \"Unknown key: %d\\n\", key);\n\t}\n}\n\nstatic void mip4_report_touch(struct mip4_ts *ts, u8 *packet)\n{\n\tint id;\n\tbool __always_unused hover;\n\tbool palm;\n\tbool state;\n\tu16 x, y;\n\tu8 __always_unused pressure_stage = 0;\n\tu8 pressure;\n\tu8 __always_unused size;\n\tu8 touch_major;\n\tu8 touch_minor;\n\n\tswitch (ts->event_format) {\n\tcase 0:\n\tcase 1:\n\t\t \n\t\tstate = packet[0] & BIT(7);\n\t\thover = packet[0] & BIT(5);\n\t\tpalm = packet[0] & BIT(4);\n\t\tid = (packet[0] & 0x0F) - 1;\n\t\tx = ((packet[1] & 0x0F) << 8) | packet[2];\n\t\ty = (((packet[1] >> 4) & 0x0F) << 8) |\n\t\t\tpacket[3];\n\t\tpressure = packet[4];\n\t\tsize = packet[5];\n\t\tif (ts->event_format == 0) {\n\t\t\ttouch_major = packet[5];\n\t\t\ttouch_minor = packet[5];\n\t\t} else {\n\t\t\ttouch_major = packet[6];\n\t\t\ttouch_minor = packet[7];\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\tdefault:\n\t\t \n\t\tid = (packet[0] & 0x0F) - 1;\n\t\thover = packet[1] & BIT(2);\n\t\tpalm = packet[1] & BIT(1);\n\t\tstate = packet[1] & BIT(0);\n\t\tx = ((packet[2] & 0x0F) << 8) | packet[3];\n\t\ty = (((packet[2] >> 4) & 0x0F) << 8) |\n\t\t\tpacket[4];\n\t\tsize = packet[6];\n\t\tpressure_stage = (packet[7] & 0xF0) >> 4;\n\t\tpressure = ((packet[7] & 0x0F) << 8) |\n\t\t\tpacket[8];\n\t\ttouch_major = packet[9];\n\t\ttouch_minor = packet[10];\n\t\tbreak;\n\t}\n\n\tdev_dbg(&ts->client->dev,\n\t\t\"Screen - Slot: %d State: %d X: %04d Y: %04d Z: %d\\n\",\n\t\tid, state, x, y, pressure);\n\n\tif (unlikely(id < 0 || id >= MIP4_MAX_FINGERS)) {\n\t\tdev_err(&ts->client->dev, \"Screen - invalid slot ID: %d\\n\", id);\n\t\tgoto out;\n\t}\n\n\tinput_mt_slot(ts->input, id);\n\tif (input_mt_report_slot_state(ts->input,\n\t\t\t\t       palm ? MT_TOOL_PALM : MT_TOOL_FINGER,\n\t\t\t\t       state)) {\n\t\tinput_report_abs(ts->input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(ts->input, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(ts->input, ABS_MT_PRESSURE, pressure);\n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, touch_major);\n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MINOR, touch_minor);\n\t}\n\nout:\n\tinput_mt_sync_frame(ts->input);\n}\n\nstatic int mip4_handle_packet(struct mip4_ts *ts, u8 *packet)\n{\n\tu8 type;\n\n\tswitch (ts->event_format) {\n\tcase 0:\n\tcase 1:\n\t\ttype = (packet[0] & 0x40) >> 6;\n\t\tbreak;\n\n\tcase 3:\n\t\ttype = (packet[0] & 0xF0) >> 4;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&ts->client->dev, \"Type: %d\\n\", type);\n\n\t \n\tswitch (type) {\n\tcase MIP4_EVENT_INPUT_TYPE_KEY:\n\t\tmip4_report_keys(ts, packet);\n\t\tbreak;\n\n\tcase MIP4_EVENT_INPUT_TYPE_SCREEN:\n\t\tmip4_report_touch(ts, packet);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&ts->client->dev, \"Unknown event type: %d\\n\", type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t mip4_interrupt(int irq, void *dev_id)\n{\n\tstruct mip4_ts *ts = dev_id;\n\tstruct i2c_client *client = ts->client;\n\tunsigned int i;\n\tint error;\n\tu8 cmd[2];\n\tu8 size;\n\tbool alert;\n\n\t \n\tcmd[0] = MIP4_R0_EVENT;\n\tcmd[1] = MIP4_R1_EVENT_PACKET_INFO;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), ts->buf, 1);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read packet info: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tsize = ts->buf[0] & 0x7F;\n\talert = ts->buf[0] & BIT(7);\n\tdev_dbg(&client->dev, \"packet size: %d, alert: %d\\n\", size, alert);\n\n\t \n\tif (!size) {\n\t\tdev_err(&client->dev, \"Empty packet\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_EVENT;\n\tcmd[1] = MIP4_R1_EVENT_PACKET_DATA;\n\terror = mip4_i2c_xfer(ts, cmd, sizeof(cmd), ts->buf, size);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read packet data: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\tif (alert) {\n\t\tdev_dbg(&client->dev, \"Alert: %d\\n\", ts->buf[0]);\n\t} else {\n\t\tfor (i = 0; i < size; i += ts->event_size) {\n\t\t\terror = mip4_handle_packet(ts, &ts->buf[i]);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tinput_sync(ts->input);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int mip4_input_open(struct input_dev *dev)\n{\n\tstruct mip4_ts *ts = input_get_drvdata(dev);\n\n\treturn mip4_enable(ts);\n}\n\nstatic void mip4_input_close(struct input_dev *dev)\n{\n\tstruct mip4_ts *ts = input_get_drvdata(dev);\n\n\tmip4_disable(ts);\n}\n\n \n\n \n#define MIP4_BL_PAGE_SIZE\t\t512\t \n#define MIP4_BL_PACKET_SIZE\t\t512\t \n\n \n\nstruct mip4_bin_tail {\n\tu8 tail_mark[4];\n\tu8 chip_name[4];\n\n\t__le32 bin_start_addr;\n\t__le32 bin_length;\n\n\t__le16 ver_boot;\n\t__le16 ver_core;\n\t__le16 ver_app;\n\t__le16 ver_param;\n\n\tu8 boot_start;\n\tu8 boot_end;\n\tu8 core_start;\n\tu8 core_end;\n\tu8 app_start;\n\tu8 app_end;\n\tu8 param_start;\n\tu8 param_end;\n\n\tu8 checksum_type;\n\tu8 hw_category;\n\n\t__le16 param_id;\n\t__le32 param_length;\n\t__le32 build_date;\n\t__le32 build_time;\n\n\t__le32 reserved1;\n\t__le32 reserved2;\n\t__le16 reserved3;\n\t__le16 tail_size;\n\t__le32 crc;\n} __packed;\n\n#define MIP4_BIN_TAIL_MARK\t\"MBT\\001\"\n#define MIP4_BIN_TAIL_SIZE\t(sizeof(struct mip4_bin_tail))\n\n \nstatic int mip4_bl_read_status(struct mip4_ts *ts)\n{\n\tu8 cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_STATUS };\n\tu8 result;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = cmd,\n\t\t\t.len = sizeof(cmd),\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = &result,\n\t\t\t.len = sizeof(result),\n\t\t},\n\t};\n\tint ret;\n\tint error;\n\tint retry = 1000;\n\n\tdo {\n\t\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret != ARRAY_SIZE(msg)) {\n\t\t\terror = ret < 0 ? ret : -EIO;\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Failed to read bootloader status: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tswitch (result) {\n\t\tcase MIP4_BOOT_STATUS_DONE:\n\t\t\tdev_dbg(&ts->client->dev, \"%s - done\\n\", __func__);\n\t\t\treturn 0;\n\n\t\tcase MIP4_BOOT_STATUS_ERROR:\n\t\t\tdev_err(&ts->client->dev, \"Bootloader failure\\n\");\n\t\t\treturn -EIO;\n\n\t\tcase MIP4_BOOT_STATUS_BUSY:\n\t\t\tdev_dbg(&ts->client->dev, \"%s - Busy\\n\", __func__);\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Unexpected bootloader status: %#02x\\n\",\n\t\t\t\tresult);\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t} while (--retry);\n\n\treturn error;\n}\n\n \nstatic int mip4_bl_change_mode(struct mip4_ts *ts, u8 mode)\n{\n\tu8 mode_chg_cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_MODE, mode };\n\tu8 mode_read_cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_MODE };\n\tu8 result;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = mode_read_cmd,\n\t\t\t.len = sizeof(mode_read_cmd),\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = &result,\n\t\t\t.len = sizeof(result),\n\t\t},\n\t};\n\tint retry = 10;\n\tint ret;\n\tint error;\n\n\tdo {\n\t\t \n\t\tret = i2c_master_send(ts->client,\n\t\t\t\t      mode_chg_cmd, sizeof(mode_chg_cmd));\n\t\tif (ret != sizeof(mode_chg_cmd)) {\n\t\t\terror = ret < 0 ? ret : -EIO;\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Failed to send %d mode change: %d (%d)\\n\",\n\t\t\t\tmode, error, ret);\n\t\t\treturn error;\n\t\t}\n\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"Sent mode change request (mode: %d)\\n\", mode);\n\n\t\t \n\t\tmsleep(1000);\n\n\t\t \n\t\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret != ARRAY_SIZE(msg)) {\n\t\t\terror = ret < 0 ? ret : -EIO;\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Failed to read device mode: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"Current device mode: %d, want: %d\\n\", result, mode);\n\n\t\tif (result == mode)\n\t\t\treturn 0;\n\n\t} while (--retry);\n\n\treturn -EIO;\n}\n\n \nstatic int mip4_bl_enter(struct mip4_ts *ts)\n{\n\treturn mip4_bl_change_mode(ts, MIP4_BOOT_MODE_BOOT);\n}\n\n \nstatic int mip4_bl_exit(struct mip4_ts *ts)\n{\n\treturn mip4_bl_change_mode(ts, MIP4_BOOT_MODE_APP);\n}\n\nstatic int mip4_bl_get_address(struct mip4_ts *ts, u16 *buf_addr)\n{\n\tu8 cmd[] = { MIP4_R0_BOOT, MIP4_R1_BOOT_BUF_ADDR };\n\tu8 result[sizeof(u16)];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = cmd,\n\t\t\t.len = sizeof(cmd),\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = result,\n\t\t\t.len = sizeof(result),\n\t\t},\n\t};\n\tint ret;\n\tint error;\n\n\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to retrieve bootloader buffer address: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t*buf_addr = get_unaligned_le16(result);\n\tdev_dbg(&ts->client->dev,\n\t\t\"Bootloader buffer address %#04x\\n\", *buf_addr);\n\n\treturn 0;\n}\n\nstatic int mip4_bl_program_page(struct mip4_ts *ts, int offset,\n\t\t\t\tconst u8 *data, int length, u16 buf_addr)\n{\n\tu8 cmd[6];\n\tu8 *data_buf;\n\tu16 buf_offset;\n\tint ret;\n\tint error;\n\n\tdev_dbg(&ts->client->dev, \"Writing page @%#06x (%d)\\n\",\n\t\toffset, length);\n\n\tif (length > MIP4_BL_PAGE_SIZE || length % MIP4_BL_PACKET_SIZE) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Invalid page length: %d\\n\", length);\n\t\treturn -EINVAL;\n\t}\n\n\tdata_buf = kmalloc(2 + MIP4_BL_PACKET_SIZE, GFP_KERNEL);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tcmd[0] = MIP4_R0_BOOT;\n\tcmd[1] = MIP4_R1_BOOT_TARGET_ADDR;\n\tput_unaligned_le32(offset, &cmd[2]);\n\tret = i2c_master_send(ts->client, cmd, 6);\n\tif (ret != 6) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to send write page address: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_BOOT;\n\tcmd[1] = MIP4_R1_BOOT_SIZE;\n\tput_unaligned_le32(length, &cmd[2]);\n\tret = i2c_master_send(ts->client, cmd, 6);\n\tif (ret != 6) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to send write page size: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\t \n\tfor (buf_offset = 0;\n\t     buf_offset < length;\n\t     buf_offset += MIP4_BL_PACKET_SIZE) {\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"writing chunk at %#04x (size %d)\\n\",\n\t\t\tbuf_offset, MIP4_BL_PACKET_SIZE);\n\t\tput_unaligned_be16(buf_addr + buf_offset, data_buf);\n\t\tmemcpy(&data_buf[2], &data[buf_offset], MIP4_BL_PACKET_SIZE);\n\t\tret = i2c_master_send(ts->client,\n\t\t\t\t      data_buf, 2 + MIP4_BL_PACKET_SIZE);\n\t\tif (ret != 2 + MIP4_BL_PACKET_SIZE) {\n\t\t\terror = ret < 0 ? ret : -EIO;\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Failed to read chunk at %#04x (size %d): %d\\n\",\n\t\t\t\tbuf_offset, MIP4_BL_PACKET_SIZE, error);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_BOOT;\n\tcmd[1] = MIP4_R1_BOOT_CMD;\n\tcmd[2] = MIP4_BOOT_CMD_PROGRAM;\n\tret = i2c_master_send(ts->client, cmd, 3);\n\tif (ret != 3) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to send 'write' command: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\t \n\terror = mip4_bl_read_status(ts);\n\nout:\n\tkfree(data_buf);\n\treturn error ? error : 0;\n}\n\nstatic int mip4_bl_verify_page(struct mip4_ts *ts, int offset,\n\t\t\t       const u8 *data, int length, int buf_addr)\n{\n\tu8 cmd[8];\n\tu8 *read_buf;\n\tint buf_offset;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = 0,\n\t\t\t.buf = cmd,\n\t\t\t.len = 2,\n\t\t}, {\n\t\t\t.addr = ts->client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = MIP4_BL_PACKET_SIZE,\n\t\t},\n\t};\n\tint ret;\n\tint error;\n\n\tdev_dbg(&ts->client->dev, \"Validating page @%#06x (%d)\\n\",\n\t\toffset, length);\n\n\t \n\tcmd[0] = MIP4_R0_BOOT;\n\tcmd[1] = MIP4_R1_BOOT_TARGET_ADDR;\n\tput_unaligned_le32(offset, &cmd[2]);\n\tret = i2c_master_send(ts->client, cmd, 6);\n\tif (ret != 6) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to send read page address: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_BOOT;\n\tcmd[1] = MIP4_R1_BOOT_SIZE;\n\tput_unaligned_le32(length, &cmd[2]);\n\tret = i2c_master_send(ts->client, cmd, 6);\n\tif (ret != 6) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to send read page size: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tcmd[0] = MIP4_R0_BOOT;\n\tcmd[1] = MIP4_R1_BOOT_CMD;\n\tcmd[2] = MIP4_BOOT_CMD_READ;\n\tret = i2c_master_send(ts->client, cmd, 3);\n\tif (ret != 3) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to send 'read' command: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\terror = mip4_bl_read_status(ts);\n\tif (error)\n\t\treturn error;\n\n\t \n\tmsg[1].buf = read_buf = kmalloc(MIP4_BL_PACKET_SIZE, GFP_KERNEL);\n\tif (!read_buf)\n\t\treturn -ENOMEM;\n\n\tfor (buf_offset = 0;\n\t     buf_offset < length;\n\t     buf_offset += MIP4_BL_PACKET_SIZE) {\n\t\tdev_dbg(&ts->client->dev,\n\t\t\t\"reading chunk at %#04x (size %d)\\n\",\n\t\t\tbuf_offset, MIP4_BL_PACKET_SIZE);\n\t\tput_unaligned_be16(buf_addr + buf_offset, cmd);\n\t\tret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret != ARRAY_SIZE(msg)) {\n\t\t\terror = ret < 0 ? ret : -EIO;\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Failed to read chunk at %#04x (size %d): %d\\n\",\n\t\t\t\tbuf_offset, MIP4_BL_PACKET_SIZE, error);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memcmp(&data[buf_offset], read_buf, MIP4_BL_PACKET_SIZE)) {\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"Failed to validate chunk at %#04x (size %d)\\n\",\n\t\t\t\tbuf_offset, MIP4_BL_PACKET_SIZE);\n#if MIP4_FW_UPDATE_DEBUG\n\t\t\tprint_hex_dump(KERN_DEBUG,\n\t\t\t\t       MIP4_DEVICE_NAME \" F/W File: \",\n\t\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       data + offset, MIP4_BL_PACKET_SIZE,\n\t\t\t\t       false);\n\t\t\tprint_hex_dump(KERN_DEBUG,\n\t\t\t\t       MIP4_DEVICE_NAME \" F/W Chip: \",\n\t\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t       read_buf, MIP4_BL_PAGE_SIZE, false);\n#endif\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(read_buf);\n\treturn error ? error : 0;\n}\n\n \nstatic int mip4_flash_fw(struct mip4_ts *ts,\n\t\t\t const u8 *fw_data, u32 fw_size, u32 fw_offset)\n{\n\tstruct i2c_client *client = ts->client;\n\tint offset;\n\tu16 buf_addr;\n\tint error, error2;\n\n\t \n\tdev_dbg(&client->dev, \"Entering bootloader mode\\n\");\n\n\terror = mip4_bl_enter(ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enter bootloader mode: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\terror = mip4_bl_get_address(ts, &buf_addr);\n\tif (error)\n\t\tgoto exit_bl;\n\n\t \n\tdev_dbg(&client->dev,\n\t\t\"Program & Verify, page size: %d, packet size: %d\\n\",\n\t\tMIP4_BL_PAGE_SIZE, MIP4_BL_PACKET_SIZE);\n\n\tfor (offset = fw_offset;\n\t     offset < fw_offset + fw_size;\n\t     offset += MIP4_BL_PAGE_SIZE) {\n\t\t \n\t\terror = mip4_bl_program_page(ts, offset, fw_data + offset,\n\t\t\t\t\t     MIP4_BL_PAGE_SIZE, buf_addr);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t \n\t\terror = mip4_bl_verify_page(ts, offset, fw_data + offset,\n\t\t\t\t\t    MIP4_BL_PAGE_SIZE, buf_addr);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\nexit_bl:\n\t \n\tdev_dbg(&client->dev, \"Exiting bootloader mode\\n\");\n\n\terror2 = mip4_bl_exit(ts);\n\tif (error2) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to exit bootloader mode: %d\\n\", error2);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\t \n\tmip4_power_off(ts);\n\tmip4_power_on(ts);\n\n\tmip4_query_device(ts);\n\n\t \n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_X, 0, ts->max_x, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_Y, 0, ts->max_y, 0, 0);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->ppm_x);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->ppm_y);\n\tinput_abs_set_res(ts->input, ABS_X, ts->ppm_x);\n\tinput_abs_set_res(ts->input, ABS_Y, ts->ppm_y);\n\n\treturn error ? error : 0;\n}\n\nstatic int mip4_parse_firmware(struct mip4_ts *ts, const struct firmware *fw,\n\t\t\t       u32 *fw_offset_start, u32 *fw_size,\n\t\t\t       const struct mip4_bin_tail **pfw_info)\n{\n\tconst struct mip4_bin_tail *fw_info;\n\tstruct mip4_fw_version fw_version;\n\tu16 tail_size;\n\n\tif (fw->size < MIP4_BIN_TAIL_SIZE) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Invalid firmware, size mismatch (tail %zd vs %zd)\\n\",\n\t\t\tMIP4_BIN_TAIL_SIZE, fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_info = (const void *)&fw->data[fw->size - MIP4_BIN_TAIL_SIZE];\n\n#if MIP4_FW_UPDATE_DEBUG\n\tprint_hex_dump(KERN_ERR, MIP4_DEVICE_NAME \" Bin Info: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1, *fw_info, tail_size, false);\n#endif\n\n\ttail_size = get_unaligned_le16(&fw_info->tail_size);\n\tif (tail_size != MIP4_BIN_TAIL_SIZE) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"wrong tail size: %d (expected %zd)\\n\",\n\t\t\ttail_size, MIP4_BIN_TAIL_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (memcmp(fw_info->tail_mark, MIP4_BIN_TAIL_MARK,\n\t\t   sizeof(fw_info->tail_mark))) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"unable to locate tail marker (%*ph vs %*ph)\\n\",\n\t\t\t(int)sizeof(fw_info->tail_mark), fw_info->tail_mark,\n\t\t\t(int)sizeof(fw_info->tail_mark), MIP4_BIN_TAIL_MARK);\n\t\treturn -EINVAL;\n\t}\n\n\t*fw_offset_start = get_unaligned_le32(&fw_info->bin_start_addr);\n\t*fw_size = get_unaligned_le32(&fw_info->bin_length);\n\n\tdev_dbg(&ts->client->dev,\n\t\t\"F/W Data offset: %#08x, size: %d\\n\",\n\t\t*fw_offset_start, *fw_size);\n\n\tif (*fw_size % MIP4_BL_PAGE_SIZE) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"encoded fw length %d is not multiple of pages (%d)\\n\",\n\t\t\t*fw_size, MIP4_BL_PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size != *fw_offset_start + *fw_size) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Wrong firmware size, expected %d bytes, got %zd\\n\",\n\t\t\t*fw_offset_start + *fw_size, fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tmip4_parse_fw_version((const u8 *)&fw_info->ver_boot, &fw_version);\n\n\tdev_dbg(&ts->client->dev,\n\t\t\"F/W file version %04X %04X %04X %04X\\n\",\n\t\tfw_version.boot, fw_version.core,\n\t\tfw_version.app, fw_version.param);\n\n\tdev_dbg(&ts->client->dev, \"F/W chip version: %04X %04X %04X %04X\\n\",\n\t\t ts->fw_version.boot, ts->fw_version.core,\n\t\t ts->fw_version.app, ts->fw_version.param);\n\n\t \n\tif (fw_version.boot != 0xEEEE && fw_version.boot != 0xFFFF &&\n\t    fw_version.core == 0xEEEE &&\n\t    fw_version.app == 0xEEEE &&\n\t    fw_version.param == 0xEEEE) {\n\t\tdev_dbg(&ts->client->dev, \"F/W type: Bootloader\\n\");\n\t} else if (fw_version.boot == 0xEEEE &&\n\t\t   fw_version.core != 0xEEEE && fw_version.core != 0xFFFF &&\n\t\t   fw_version.app != 0xEEEE && fw_version.app != 0xFFFF &&\n\t\t   fw_version.param != 0xEEEE && fw_version.param != 0xFFFF) {\n\t\tdev_dbg(&ts->client->dev, \"F/W type: Main\\n\");\n\t} else {\n\t\tdev_err(&ts->client->dev, \"Wrong firmware type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mip4_execute_fw_update(struct mip4_ts *ts, const struct firmware *fw)\n{\n\tconst struct mip4_bin_tail *fw_info;\n\tu32 fw_start_offset;\n\tu32 fw_size;\n\tint retires = 3;\n\tint error;\n\n\terror = mip4_parse_firmware(ts, fw,\n\t\t\t\t    &fw_start_offset, &fw_size, &fw_info);\n\tif (error)\n\t\treturn error;\n\n\tif (input_device_enabled(ts->input)) {\n\t\tdisable_irq(ts->client->irq);\n\t} else {\n\t\terror = mip4_power_on(ts);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tdo {\n\t\terror = mip4_flash_fw(ts, fw->data, fw_size, fw_start_offset);\n\t\tif (!error)\n\t\t\tbreak;\n\t} while (--retires);\n\n\tif (error)\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to flash firmware: %d\\n\", error);\n\n\t \n\tif (input_device_enabled(ts->input))\n\t\tenable_irq(ts->client->irq);\n\telse\n\t\tmip4_power_off(ts);\n\n\treturn error ? error : 0;\n}\n\nstatic ssize_t mip4_sysfs_fw_update(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tconst struct firmware *fw;\n\tint error;\n\n\terror = request_firmware(&fw, ts->fw_name, dev);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to retrieve firmware %s: %d\\n\",\n\t\t\tts->fw_name, error);\n\t\treturn error;\n\t}\n\n\t \n\tmutex_lock(&ts->input->mutex);\n\n\terror = mip4_execute_fw_update(ts, fw);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\trelease_firmware(fw);\n\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Firmware update failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(update_fw, S_IWUSR, NULL, mip4_sysfs_fw_update);\n\nstatic ssize_t mip4_sysfs_read_fw_version(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tsize_t count;\n\n\t \n\tmutex_lock(&ts->input->mutex);\n\n\tcount = snprintf(buf, PAGE_SIZE, \"%04X %04X %04X %04X\\n\",\n\t\t\t ts->fw_version.boot, ts->fw_version.core,\n\t\t\t ts->fw_version.app, ts->fw_version.param);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(fw_version, S_IRUGO, mip4_sysfs_read_fw_version, NULL);\n\nstatic ssize_t mip4_sysfs_read_hw_version(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tsize_t count;\n\n\t \n\tmutex_lock(&ts->input->mutex);\n\n\t \n\tcount = snprintf(buf, PAGE_SIZE, \"%.*s\\n\",\n\t\t\t (int)sizeof(ts->product_name), ts->product_name);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(hw_version, S_IRUGO, mip4_sysfs_read_hw_version, NULL);\n\nstatic ssize_t mip4_sysfs_read_product_id(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tsize_t count;\n\n\tmutex_lock(&ts->input->mutex);\n\n\tcount = snprintf(buf, PAGE_SIZE, \"%04X\\n\", ts->product_id);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(product_id, S_IRUGO, mip4_sysfs_read_product_id, NULL);\n\nstatic ssize_t mip4_sysfs_read_ic_name(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tsize_t count;\n\n\tmutex_lock(&ts->input->mutex);\n\n\tcount = snprintf(buf, PAGE_SIZE, \"%.*s\\n\",\n\t\t\t (int)sizeof(ts->ic_name), ts->ic_name);\n\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(ic_name, S_IRUGO, mip4_sysfs_read_ic_name, NULL);\n\nstatic struct attribute *mip4_attrs[] = {\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_hw_version.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_ic_name.attr,\n\t&dev_attr_update_fw.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mip4_attr_group = {\n\t.attrs = mip4_attrs,\n};\n\nstatic int mip4_probe(struct i2c_client *client)\n{\n\tstruct mip4_ts *ts;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"Not supported I2C adapter\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\tts->input = input;\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t \"%s/input0\", dev_name(&client->dev));\n\n\tts->gpio_ce = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t      \"ce\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->gpio_ce))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->gpio_ce), \"Failed to get gpio\\n\");\n\n\terror = mip4_power_on(ts);\n\tif (error)\n\t\treturn error;\n\terror = mip4_query_device(ts);\n\tmip4_power_off(ts);\n\tif (error)\n\t\treturn error;\n\n\tinput->name = \"MELFAS MIP4 Touchscreen\";\n\tinput->phys = ts->phys;\n\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = 0x13c5;\n\tinput->id.product = ts->product_id;\n\n\tinput->open = mip4_input_open;\n\tinput->close = mip4_input_close;\n\n\tinput_set_drvdata(input, ts);\n\n\tinput->keycode = ts->key_code;\n\tinput->keycodesize = sizeof(*ts->key_code);\n\tinput->keycodemax = ts->key_num;\n\n\tinput_set_abs_params(input, ABS_MT_TOOL_TYPE, 0, MT_TOOL_PALM, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE,\n\t\t\t     MIP4_PRESSURE_MIN, MIP4_PRESSURE_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t     MIP4_TOUCH_MAJOR_MIN, MIP4_TOUCH_MAJOR_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MINOR,\n\t\t\t     MIP4_TOUCH_MINOR_MIN, MIP4_TOUCH_MINOR_MAX, 0, 0);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->ppm_x);\n\tinput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->ppm_y);\n\n\terror = input_mt_init_slots(input, MIP4_MAX_FINGERS, INPUT_MT_DIRECT);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, ts);\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, mip4_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  MIP4_DEVICE_NAME, ts);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to request interrupt %d: %d\\n\",\n\t\t\tclient->irq, error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &mip4_attr_group);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to create sysfs attribute group: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int mip4_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\n\tmutex_lock(&input->mutex);\n\n\tif (device_may_wakeup(dev))\n\t\tts->wake_irq_enabled = enable_irq_wake(client->irq) == 0;\n\telse if (input_device_enabled(input))\n\t\tmip4_disable(ts);\n\n\tmutex_unlock(&input->mutex);\n\n\treturn 0;\n}\n\nstatic int mip4_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mip4_ts *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\n\tmutex_lock(&input->mutex);\n\n\tif (ts->wake_irq_enabled)\n\t\tdisable_irq_wake(client->irq);\n\telse if (input_device_enabled(input))\n\t\tmip4_enable(ts);\n\n\tmutex_unlock(&input->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mip4_pm_ops, mip4_suspend, mip4_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mip4_of_match[] = {\n\t{ .compatible = \"melfas,\"MIP4_DEVICE_NAME, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mip4_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id mip4_acpi_match[] = {\n\t{ \"MLFS0000\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, mip4_acpi_match);\n#endif\n\nstatic const struct i2c_device_id mip4_i2c_ids[] = {\n\t{ MIP4_DEVICE_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, mip4_i2c_ids);\n\nstatic struct i2c_driver mip4_driver = {\n\t.id_table = mip4_i2c_ids,\n\t.probe = mip4_probe,\n\t.driver = {\n\t\t.name = MIP4_DEVICE_NAME,\n\t\t.of_match_table = of_match_ptr(mip4_of_match),\n\t\t.acpi_match_table = ACPI_PTR(mip4_acpi_match),\n\t\t.pm = pm_sleep_ptr(&mip4_pm_ops),\n\t},\n};\nmodule_i2c_driver(mip4_driver);\n\nMODULE_DESCRIPTION(\"MELFAS MIP4 Touchscreen\");\nMODULE_AUTHOR(\"Sangwon Jee <jeesw@melfas.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}