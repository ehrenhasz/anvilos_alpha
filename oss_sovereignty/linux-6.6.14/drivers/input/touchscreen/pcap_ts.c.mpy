{
  "module_name": "pcap_ts.c",
  "hash_id": "779ffe171ef60f7ae22df2c669214fd6e484f7b3c59095bc62b2c501327364b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/pcap_ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/mfd/ezx-pcap.h>\n\nstruct pcap_ts {\n\tstruct pcap_chip *pcap;\n\tstruct input_dev *input;\n\tstruct delayed_work work;\n\tu16 x, y;\n\tu16 pressure;\n\tu8 read_state;\n};\n\n#define SAMPLE_DELAY\t20  \n\n#define X_AXIS_MIN\t0\n#define X_AXIS_MAX\t1023\n#define Y_AXIS_MAX\tX_AXIS_MAX\n#define Y_AXIS_MIN\tX_AXIS_MIN\n#define PRESSURE_MAX\tX_AXIS_MAX\n#define PRESSURE_MIN\tX_AXIS_MIN\n\nstatic void pcap_ts_read_xy(void *data, u16 res[2])\n{\n\tstruct pcap_ts *pcap_ts = data;\n\n\tswitch (pcap_ts->read_state) {\n\tcase PCAP_ADC_TS_M_PRESSURE:\n\t\t \n\t\tif (res[0] > PRESSURE_MIN && res[0] < PRESSURE_MAX)\n\t\t\tpcap_ts->pressure = res[0];\n\t\tpcap_ts->read_state = PCAP_ADC_TS_M_XY;\n\t\tschedule_delayed_work(&pcap_ts->work, 0);\n\t\tbreak;\n\tcase PCAP_ADC_TS_M_XY:\n\t\tpcap_ts->y = res[0];\n\t\tpcap_ts->x = res[1];\n\t\tif (pcap_ts->x <= X_AXIS_MIN || pcap_ts->x >= X_AXIS_MAX ||\n\t\t    pcap_ts->y <= Y_AXIS_MIN || pcap_ts->y >= Y_AXIS_MAX) {\n\t\t\t \n\t\t\tinput_report_abs(pcap_ts->input, ABS_PRESSURE, 0);\n\t\t\tinput_report_key(pcap_ts->input, BTN_TOUCH, 0);\n\n\t\t\tpcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;\n\t\t\tschedule_delayed_work(&pcap_ts->work, 0);\n\t\t} else {\n\t\t\t \n\t\t\tinput_report_abs(pcap_ts->input, ABS_X, pcap_ts->x);\n\t\t\tinput_report_abs(pcap_ts->input, ABS_Y, pcap_ts->y);\n\t\t\tinput_report_key(pcap_ts->input, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(pcap_ts->input, ABS_PRESSURE,\n\t\t\t\t\t\tpcap_ts->pressure);\n\n\t\t\t \n\t\t\tpcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;\n\t\t\tschedule_delayed_work(&pcap_ts->work,\n\t\t\t\t\tmsecs_to_jiffies(SAMPLE_DELAY));\n\t\t}\n\t\tinput_sync(pcap_ts->input);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pcap_ts->input->dev,\n\t\t\t\t\"pcap_ts: Warning, unhandled read_state %d\\n\",\n\t\t\t\tpcap_ts->read_state);\n\t\tbreak;\n\t}\n}\n\nstatic void pcap_ts_work(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct pcap_ts *pcap_ts = container_of(dw, struct pcap_ts, work);\n\tu8 ch[2];\n\n\tpcap_set_ts_bits(pcap_ts->pcap,\n\t\t\tpcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\n\n\tif (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY)\n\t\treturn;\n\n\t \n\tch[0] = PCAP_ADC_CH_TS_X1;\n\tch[1] = PCAP_ADC_CH_TS_Y1;\n\tpcap_adc_async(pcap_ts->pcap, PCAP_ADC_BANK_1, 0, ch,\n\t\t\t\t\t\tpcap_ts_read_xy, pcap_ts);\n}\n\nstatic irqreturn_t pcap_ts_event_touch(int pirq, void *data)\n{\n\tstruct pcap_ts *pcap_ts = data;\n\n\tif (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY) {\n\t\tpcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;\n\t\tschedule_delayed_work(&pcap_ts->work, 0);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int pcap_ts_open(struct input_dev *dev)\n{\n\tstruct pcap_ts *pcap_ts = input_get_drvdata(dev);\n\n\tpcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;\n\tschedule_delayed_work(&pcap_ts->work, 0);\n\n\treturn 0;\n}\n\nstatic void pcap_ts_close(struct input_dev *dev)\n{\n\tstruct pcap_ts *pcap_ts = input_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&pcap_ts->work);\n\n\tpcap_ts->read_state = PCAP_ADC_TS_M_NONTS;\n\tpcap_set_ts_bits(pcap_ts->pcap,\n\t\t\t\tpcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\n}\n\nstatic int pcap_ts_probe(struct platform_device *pdev)\n{\n\tstruct input_dev *input_dev;\n\tstruct pcap_ts *pcap_ts;\n\tint err = -ENOMEM;\n\n\tpcap_ts = kzalloc(sizeof(*pcap_ts), GFP_KERNEL);\n\tif (!pcap_ts)\n\t\treturn err;\n\n\tpcap_ts->pcap = dev_get_drvdata(pdev->dev.parent);\n\tplatform_set_drvdata(pdev, pcap_ts);\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\tgoto fail;\n\n\tINIT_DELAYED_WORK(&pcap_ts->work, pcap_ts_work);\n\n\tpcap_ts->read_state = PCAP_ADC_TS_M_NONTS;\n\tpcap_set_ts_bits(pcap_ts->pcap,\n\t\t\t\tpcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\n\n\tpcap_ts->input = input_dev;\n\tinput_set_drvdata(input_dev, pcap_ts);\n\n\tinput_dev->name = \"pcap-touchscreen\";\n\tinput_dev->phys = \"pcap_ts/input0\";\n\tinput_dev->id.bustype = BUS_HOST;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = 0x0002;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &pdev->dev;\n\tinput_dev->open = pcap_ts_open;\n\tinput_dev->close = pcap_ts_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, PRESSURE_MIN,\n\t\t\t     PRESSURE_MAX, 0, 0);\n\n\terr = input_register_device(pcap_ts->input);\n\tif (err)\n\t\tgoto fail_allocate;\n\n\terr = request_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS),\n\t\t\tpcap_ts_event_touch, 0, \"Touch Screen\", pcap_ts);\n\tif (err)\n\t\tgoto fail_register;\n\n\treturn 0;\n\nfail_register:\n\tinput_unregister_device(input_dev);\n\tgoto fail;\nfail_allocate:\n\tinput_free_device(input_dev);\nfail:\n\tkfree(pcap_ts);\n\n\treturn err;\n}\n\nstatic int pcap_ts_remove(struct platform_device *pdev)\n{\n\tstruct pcap_ts *pcap_ts = platform_get_drvdata(pdev);\n\n\tfree_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS), pcap_ts);\n\tcancel_delayed_work_sync(&pcap_ts->work);\n\n\tinput_unregister_device(pcap_ts->input);\n\n\tkfree(pcap_ts);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int pcap_ts_suspend(struct device *dev)\n{\n\tstruct pcap_ts *pcap_ts = dev_get_drvdata(dev);\n\n\tpcap_set_ts_bits(pcap_ts->pcap, PCAP_ADC_TS_REF_LOWPWR);\n\treturn 0;\n}\n\nstatic int pcap_ts_resume(struct device *dev)\n{\n\tstruct pcap_ts *pcap_ts = dev_get_drvdata(dev);\n\n\tpcap_set_ts_bits(pcap_ts->pcap,\n\t\t\t\tpcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops pcap_ts_pm_ops = {\n\t.suspend\t= pcap_ts_suspend,\n\t.resume\t\t= pcap_ts_resume,\n};\n#define PCAP_TS_PM_OPS (&pcap_ts_pm_ops)\n#else\n#define PCAP_TS_PM_OPS NULL\n#endif\n\nstatic struct platform_driver pcap_ts_driver = {\n\t.probe\t\t= pcap_ts_probe,\n\t.remove\t\t= pcap_ts_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pcap-ts\",\n\t\t.pm\t= PCAP_TS_PM_OPS,\n\t},\n};\nmodule_platform_driver(pcap_ts_driver);\n\nMODULE_DESCRIPTION(\"Motorola PCAP2 touchscreen driver\");\nMODULE_AUTHOR(\"Daniel Ribeiro / Harald Welte\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pcap_ts\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}