{
  "module_name": "penmount.c",
  "hash_id": "a88caf0d21984de0b3b4dababe6525d352b9a3e47fa83c1ca5bf360cb8e42d0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/penmount.c",
  "human_readable_source": "\n \n\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"PenMount serial touchscreen driver\"\n\nMODULE_AUTHOR(\"Rick Koch <n1gp@hotmail.com>\");\nMODULE_AUTHOR(\"John Sung <penmount.touch@gmail.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define\tPM_MAX_LENGTH\t6\n#define\tPM_MAX_MTSLOT\t16\n#define\tPM_3000_MTSLOT\t2\n#define\tPM_6250_MTSLOT\t12\n\n \n\nstruct mt_slot {\n\tunsigned short x, y;\n\tbool active;  \n};\n\n \n\nstruct pm {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tint idx;\n\tunsigned char data[PM_MAX_LENGTH];\n\tchar phys[32];\n\tunsigned char packetsize;\n\tunsigned char maxcontacts;\n\tstruct mt_slot slots[PM_MAX_MTSLOT];\n\tvoid (*parse_packet)(struct pm *);\n};\n\n \n\nstatic void pm_mtevent(struct pm *pm, struct input_dev *input)\n{\n\tint i;\n\n\tfor (i = 0; i < pm->maxcontacts; ++i) {\n\t\tinput_mt_slot(input, i);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER,\n\t\t\t\tpm->slots[i].active);\n\t\tif (pm->slots[i].active) {\n\t\t\tinput_event(input, EV_ABS, ABS_MT_POSITION_X, pm->slots[i].x);\n\t\t\tinput_event(input, EV_ABS, ABS_MT_POSITION_Y, pm->slots[i].y);\n\t\t}\n\t}\n\n\tinput_mt_report_pointer_emulation(input, true);\n\tinput_sync(input);\n}\n\n \n\nstatic bool pm_checkpacket(unsigned char *packet)\n{\n\tint total = 0;\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\ttotal += packet[i];\n\n\treturn packet[5] == (unsigned char)~(total & 0xff);\n}\n\nstatic void pm_parse_9000(struct pm *pm)\n{\n\tstruct input_dev *dev = pm->dev;\n\n\tif ((pm->data[0] & 0x80) && pm->packetsize == ++pm->idx) {\n\t\tinput_report_abs(dev, ABS_X, pm->data[1] * 128 + pm->data[2]);\n\t\tinput_report_abs(dev, ABS_Y, pm->data[3] * 128 + pm->data[4]);\n\t\tinput_report_key(dev, BTN_TOUCH, !!(pm->data[0] & 0x40));\n\t\tinput_sync(dev);\n\t\tpm->idx = 0;\n\t}\n}\n\nstatic void pm_parse_6000(struct pm *pm)\n{\n\tstruct input_dev *dev = pm->dev;\n\n\tif ((pm->data[0] & 0xbf) == 0x30 && pm->packetsize == ++pm->idx) {\n\t\tif (pm_checkpacket(pm->data)) {\n\t\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t\tpm->data[2] * 256 + pm->data[1]);\n\t\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t\tpm->data[4] * 256 + pm->data[3]);\n\t\t\tinput_report_key(dev, BTN_TOUCH, pm->data[0] & 0x40);\n\t\t\tinput_sync(dev);\n\t\t}\n\t\tpm->idx = 0;\n\t}\n}\n\nstatic void pm_parse_3000(struct pm *pm)\n{\n\tstruct input_dev *dev = pm->dev;\n\n\tif ((pm->data[0] & 0xce) == 0x40 && pm->packetsize == ++pm->idx) {\n\t\tif (pm_checkpacket(pm->data)) {\n\t\t\tint slotnum = pm->data[0] & 0x0f;\n\t\t\tpm->slots[slotnum].active = pm->data[0] & 0x30;\n\t\t\tpm->slots[slotnum].x = pm->data[2] * 256 + pm->data[1];\n\t\t\tpm->slots[slotnum].y = pm->data[4] * 256 + pm->data[3];\n\t\t\tpm_mtevent(pm, dev);\n\t\t}\n\t\tpm->idx = 0;\n\t}\n}\n\nstatic void pm_parse_6250(struct pm *pm)\n{\n\tstruct input_dev *dev = pm->dev;\n\n\tif ((pm->data[0] & 0xb0) == 0x30 && pm->packetsize == ++pm->idx) {\n\t\tif (pm_checkpacket(pm->data)) {\n\t\t\tint slotnum = pm->data[0] & 0x0f;\n\t\t\tpm->slots[slotnum].active = pm->data[0] & 0x40;\n\t\t\tpm->slots[slotnum].x = pm->data[2] * 256 + pm->data[1];\n\t\t\tpm->slots[slotnum].y = pm->data[4] * 256 + pm->data[3];\n\t\t\tpm_mtevent(pm, dev);\n\t\t}\n\t\tpm->idx = 0;\n\t}\n}\n\nstatic irqreturn_t pm_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct pm *pm = serio_get_drvdata(serio);\n\n\tpm->data[pm->idx] = data;\n\n\tpm->parse_packet(pm);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void pm_disconnect(struct serio *serio)\n{\n\tstruct pm *pm = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\n\tinput_unregister_device(pm->dev);\n\tkfree(pm);\n\n\tserio_set_drvdata(serio, NULL);\n}\n\n \n\nstatic int pm_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct pm *pm;\n\tstruct input_dev *input_dev;\n\tint max_x, max_y;\n\tint err;\n\n\tpm = kzalloc(sizeof(struct pm), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!pm || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tpm->serio = serio;\n\tpm->dev = input_dev;\n\tsnprintf(pm->phys, sizeof(pm->phys), \"%s/input0\", serio->phys);\n\tpm->maxcontacts = 1;\n\n\tinput_dev->name = \"PenMount Serial TouchScreen\";\n\tinput_dev->phys = pm->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_PENMOUNT;\n\tinput_dev->id.product = 0;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tswitch (serio->id.id) {\n\tdefault:\n\tcase 0:\n\t\tpm->packetsize = 5;\n\t\tpm->parse_packet = pm_parse_9000;\n\t\tinput_dev->id.product = 0x9000;\n\t\tmax_x = max_y = 0x3ff;\n\t\tbreak;\n\n\tcase 1:\n\t\tpm->packetsize = 6;\n\t\tpm->parse_packet = pm_parse_6000;\n\t\tinput_dev->id.product = 0x6000;\n\t\tmax_x = max_y = 0x3ff;\n\t\tbreak;\n\n\tcase 2:\n\t\tpm->packetsize = 6;\n\t\tpm->parse_packet = pm_parse_3000;\n\t\tinput_dev->id.product = 0x3000;\n\t\tmax_x = max_y = 0x7ff;\n\t\tpm->maxcontacts = PM_3000_MTSLOT;\n\t\tbreak;\n\n\tcase 3:\n\t\tpm->packetsize = 6;\n\t\tpm->parse_packet = pm_parse_6250;\n\t\tinput_dev->id.product = 0x6250;\n\t\tmax_x = max_y = 0x3ff;\n\t\tpm->maxcontacts = PM_6250_MTSLOT;\n\t\tbreak;\n\t}\n\n\tinput_set_abs_params(pm->dev, ABS_X, 0, max_x, 0, 0);\n\tinput_set_abs_params(pm->dev, ABS_Y, 0, max_y, 0, 0);\n\n\tif (pm->maxcontacts > 1) {\n\t\tinput_mt_init_slots(pm->dev, pm->maxcontacts, 0);\n\t\tinput_set_abs_params(pm->dev,\n\t\t\t\t     ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\t\tinput_set_abs_params(pm->dev,\n\t\t\t\t     ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\t}\n\n\tserio_set_drvdata(serio, pm);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(pm->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(pm);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id pm_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_PENMOUNT,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, pm_serio_ids);\n\nstatic struct serio_driver pm_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"serio-penmount\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= pm_serio_ids,\n\t.interrupt\t= pm_interrupt,\n\t.connect\t= pm_connect,\n\t.disconnect\t= pm_disconnect,\n};\n\nmodule_serio_driver(pm_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}