{
  "module_name": "iqs5xx.c",
  "hash_id": "fceafab289f2b99180d5253a9eff6996031479cf5ab0ff8ca5d0440e4fbd581b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/iqs5xx.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define IQS5XX_FW_FILE_LEN\t64\n#define IQS5XX_NUM_RETRIES\t10\n#define IQS5XX_NUM_CONTACTS\t5\n#define IQS5XX_WR_BYTES_MAX\t2\n\n#define IQS5XX_PROD_NUM_IQS550\t40\n#define IQS5XX_PROD_NUM_IQS572\t58\n#define IQS5XX_PROD_NUM_IQS525\t52\n\n#define IQS5XX_SHOW_RESET\tBIT(7)\n#define IQS5XX_ACK_RESET\tBIT(7)\n\n#define IQS5XX_SUSPEND\t\tBIT(0)\n#define IQS5XX_RESUME\t\t0\n\n#define IQS5XX_SETUP_COMPLETE\tBIT(6)\n#define IQS5XX_WDT\t\tBIT(5)\n#define IQS5XX_ALP_REATI\tBIT(3)\n#define IQS5XX_REATI\t\tBIT(2)\n\n#define IQS5XX_TP_EVENT\t\tBIT(2)\n#define IQS5XX_EVENT_MODE\tBIT(0)\n\n#define IQS5XX_PROD_NUM\t\t0x0000\n#define IQS5XX_SYS_INFO0\t0x000F\n#define IQS5XX_SYS_INFO1\t0x0010\n#define IQS5XX_SYS_CTRL0\t0x0431\n#define IQS5XX_SYS_CTRL1\t0x0432\n#define IQS5XX_SYS_CFG0\t\t0x058E\n#define IQS5XX_SYS_CFG1\t\t0x058F\n#define IQS5XX_X_RES\t\t0x066E\n#define IQS5XX_Y_RES\t\t0x0670\n#define IQS5XX_EXP_FILE\t\t0x0677\n#define IQS5XX_CHKSM\t\t0x83C0\n#define IQS5XX_APP\t\t0x8400\n#define IQS5XX_CSTM\t\t0xBE00\n#define IQS5XX_PMAP_END\t\t0xBFFF\n#define IQS5XX_END_COMM\t\t0xEEEE\n\n#define IQS5XX_CHKSM_LEN\t(IQS5XX_APP - IQS5XX_CHKSM)\n#define IQS5XX_APP_LEN\t\t(IQS5XX_CSTM - IQS5XX_APP)\n#define IQS5XX_CSTM_LEN\t\t(IQS5XX_PMAP_END + 1 - IQS5XX_CSTM)\n#define IQS5XX_PMAP_LEN\t\t(IQS5XX_PMAP_END + 1 - IQS5XX_CHKSM)\n\n#define IQS5XX_REC_HDR_LEN\t4\n#define IQS5XX_REC_LEN_MAX\t255\n#define IQS5XX_REC_TYPE_DATA\t0x00\n#define IQS5XX_REC_TYPE_EOF\t0x01\n\n#define IQS5XX_BL_ADDR_MASK\t0x40\n#define IQS5XX_BL_CMD_VER\t0x00\n#define IQS5XX_BL_CMD_READ\t0x01\n#define IQS5XX_BL_CMD_EXEC\t0x02\n#define IQS5XX_BL_CMD_CRC\t0x03\n#define IQS5XX_BL_BLK_LEN_MAX\t64\n#define IQS5XX_BL_ID\t\t0x0200\n#define IQS5XX_BL_STATUS_NONE\t0xEE\n#define IQS5XX_BL_CRC_PASS\t0x00\n#define IQS5XX_BL_CRC_FAIL\t0x01\n#define IQS5XX_BL_ATTEMPTS\t3\n\nstruct iqs5xx_dev_id_info {\n\t__be16 prod_num;\n\t__be16 proj_num;\n\tu8 major_ver;\n\tu8 minor_ver;\n\tu8 bl_status;\n} __packed;\n\nstruct iqs5xx_ihex_rec {\n\tchar start;\n\tchar len[2];\n\tchar addr[4];\n\tchar type[2];\n\tchar data[2];\n} __packed;\n\nstruct iqs5xx_touch_data {\n\t__be16 abs_x;\n\t__be16 abs_y;\n\t__be16 strength;\n\tu8 area;\n} __packed;\n\nstruct iqs5xx_status {\n\tu8 sys_info[2];\n\tu8 num_active;\n\t__be16 rel_x;\n\t__be16 rel_y;\n\tstruct iqs5xx_touch_data touch_data[IQS5XX_NUM_CONTACTS];\n} __packed;\n\nstruct iqs5xx_private {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *reset_gpio;\n\tstruct touchscreen_properties prop;\n\tstruct mutex lock;\n\tstruct iqs5xx_dev_id_info dev_id_info;\n\tu8 exp_file[2];\n};\n\nstatic int iqs5xx_read_burst(struct i2c_client *client,\n\t\t\t     u16 reg, void *val, u16 len)\n{\n\t__be16 reg_buf = cpu_to_be16(reg);\n\tint ret, i;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(reg_buf),\n\t\t\t.buf = (u8 *)&reg_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = (u8 *)val,\n\t\t},\n\t};\n\n\t \n\tfor (i = 0; i < IQS5XX_NUM_RETRIES; i++) {\n\t\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret == ARRAY_SIZE(msg))\n\t\t\treturn 0;\n\n\t\tusleep_range(200, 300);\n\t}\n\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tdev_err(&client->dev, \"Failed to read from address 0x%04X: %d\\n\",\n\t\treg, ret);\n\n\treturn ret;\n}\n\nstatic int iqs5xx_read_word(struct i2c_client *client, u16 reg, u16 *val)\n{\n\t__be16 val_buf;\n\tint error;\n\n\terror = iqs5xx_read_burst(client, reg, &val_buf, sizeof(val_buf));\n\tif (error)\n\t\treturn error;\n\n\t*val = be16_to_cpu(val_buf);\n\n\treturn 0;\n}\n\nstatic int iqs5xx_write_burst(struct i2c_client *client,\n\t\t\t      u16 reg, const void *val, u16 len)\n{\n\tint ret, i;\n\tu16 mlen = sizeof(reg) + len;\n\tu8 mbuf[sizeof(reg) + IQS5XX_WR_BYTES_MAX];\n\n\tif (len > IQS5XX_WR_BYTES_MAX)\n\t\treturn -EINVAL;\n\n\tput_unaligned_be16(reg, mbuf);\n\tmemcpy(mbuf + sizeof(reg), val, len);\n\n\t \n\tfor (i = 0; i < IQS5XX_NUM_RETRIES; i++) {\n\t\tret = i2c_master_send(client, mbuf, mlen);\n\t\tif (ret == mlen)\n\t\t\treturn 0;\n\n\t\tusleep_range(200, 300);\n\t}\n\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tdev_err(&client->dev, \"Failed to write to address 0x%04X: %d\\n\",\n\t\treg, ret);\n\n\treturn ret;\n}\n\nstatic int iqs5xx_write_word(struct i2c_client *client, u16 reg, u16 val)\n{\n\t__be16 val_buf = cpu_to_be16(val);\n\n\treturn iqs5xx_write_burst(client, reg, &val_buf, sizeof(val_buf));\n}\n\nstatic int iqs5xx_write_byte(struct i2c_client *client, u16 reg, u8 val)\n{\n\treturn iqs5xx_write_burst(client, reg, &val, sizeof(val));\n}\n\nstatic void iqs5xx_reset(struct i2c_client *client)\n{\n\tstruct iqs5xx_private *iqs5xx = i2c_get_clientdata(client);\n\n\tgpiod_set_value_cansleep(iqs5xx->reset_gpio, 1);\n\tusleep_range(200, 300);\n\n\tgpiod_set_value_cansleep(iqs5xx->reset_gpio, 0);\n}\n\nstatic int iqs5xx_bl_cmd(struct i2c_client *client, u8 bl_cmd, u16 bl_addr)\n{\n\tstruct i2c_msg msg;\n\tint ret;\n\tu8 mbuf[sizeof(bl_cmd) + sizeof(bl_addr)];\n\n\tmsg.addr = client->addr ^ IQS5XX_BL_ADDR_MASK;\n\tmsg.flags = 0;\n\tmsg.len = sizeof(bl_cmd);\n\tmsg.buf = mbuf;\n\n\t*mbuf = bl_cmd;\n\n\tswitch (bl_cmd) {\n\tcase IQS5XX_BL_CMD_VER:\n\tcase IQS5XX_BL_CMD_CRC:\n\tcase IQS5XX_BL_CMD_EXEC:\n\t\tbreak;\n\tcase IQS5XX_BL_CMD_READ:\n\t\tmsg.len += sizeof(bl_addr);\n\t\tput_unaligned_be16(bl_addr, mbuf + sizeof(bl_cmd));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1)\n\t\tgoto msg_fail;\n\n\tswitch (bl_cmd) {\n\tcase IQS5XX_BL_CMD_VER:\n\t\tmsg.len = sizeof(u16);\n\t\tbreak;\n\tcase IQS5XX_BL_CMD_CRC:\n\t\tmsg.len = sizeof(u8);\n\t\t \n\t\tmsleep(50);\n\t\tbreak;\n\tcase IQS5XX_BL_CMD_EXEC:\n\t\tusleep_range(10000, 10100);\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tmsg.flags = I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1)\n\t\tgoto msg_fail;\n\n\tif (bl_cmd == IQS5XX_BL_CMD_VER &&\n\t    get_unaligned_be16(mbuf) != IQS5XX_BL_ID) {\n\t\tdev_err(&client->dev, \"Unrecognized bootloader ID: 0x%04X\\n\",\n\t\t\tget_unaligned_be16(mbuf));\n\t\treturn -EINVAL;\n\t}\n\n\tif (bl_cmd == IQS5XX_BL_CMD_CRC && *mbuf != IQS5XX_BL_CRC_PASS) {\n\t\tdev_err(&client->dev, \"Bootloader CRC failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n\nmsg_fail:\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tif (bl_cmd != IQS5XX_BL_CMD_VER)\n\t\tdev_err(&client->dev,\n\t\t\t\"Unsuccessful bootloader command 0x%02X: %d\\n\",\n\t\t\tbl_cmd, ret);\n\n\treturn ret;\n}\n\nstatic int iqs5xx_bl_open(struct i2c_client *client)\n{\n\tint error, i, j;\n\n\t \n\tfor (i = 0; i < IQS5XX_BL_ATTEMPTS; i++) {\n\t\tiqs5xx_reset(client);\n\t\tusleep_range(350, 400);\n\n\t\tfor (j = 0; j < IQS5XX_NUM_RETRIES; j++) {\n\t\t\terror = iqs5xx_bl_cmd(client, IQS5XX_BL_CMD_VER, 0);\n\t\t\tif (!error)\n\t\t\t\tusleep_range(10000, 10100);\n\t\t\telse if (error != -EINVAL)\n\t\t\t\tcontinue;\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tdev_err(&client->dev, \"Failed to open bootloader: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic int iqs5xx_bl_write(struct i2c_client *client,\n\t\t\t   u16 bl_addr, u8 *pmap_data, u16 pmap_len)\n{\n\tstruct i2c_msg msg;\n\tint ret, i;\n\tu8 mbuf[sizeof(bl_addr) + IQS5XX_BL_BLK_LEN_MAX];\n\n\tif (pmap_len % IQS5XX_BL_BLK_LEN_MAX)\n\t\treturn -EINVAL;\n\n\tmsg.addr = client->addr ^ IQS5XX_BL_ADDR_MASK;\n\tmsg.flags = 0;\n\tmsg.len = sizeof(mbuf);\n\tmsg.buf = mbuf;\n\n\tfor (i = 0; i < pmap_len; i += IQS5XX_BL_BLK_LEN_MAX) {\n\t\tput_unaligned_be16(bl_addr + i, mbuf);\n\t\tmemcpy(mbuf + sizeof(bl_addr), pmap_data + i,\n\t\t       sizeof(mbuf) - sizeof(bl_addr));\n\n\t\tret = i2c_transfer(client->adapter, &msg, 1);\n\t\tif (ret != 1)\n\t\t\tgoto msg_fail;\n\n\t\tusleep_range(10000, 10100);\n\t}\n\n\treturn 0;\n\nmsg_fail:\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tdev_err(&client->dev, \"Failed to write block at address 0x%04X: %d\\n\",\n\t\tbl_addr + i, ret);\n\n\treturn ret;\n}\n\nstatic int iqs5xx_bl_verify(struct i2c_client *client,\n\t\t\t    u16 bl_addr, u8 *pmap_data, u16 pmap_len)\n{\n\tstruct i2c_msg msg;\n\tint ret, i;\n\tu8 bl_data[IQS5XX_BL_BLK_LEN_MAX];\n\n\tif (pmap_len % IQS5XX_BL_BLK_LEN_MAX)\n\t\treturn -EINVAL;\n\n\tmsg.addr = client->addr ^ IQS5XX_BL_ADDR_MASK;\n\tmsg.flags = I2C_M_RD;\n\tmsg.len = sizeof(bl_data);\n\tmsg.buf = bl_data;\n\n\tfor (i = 0; i < pmap_len; i += IQS5XX_BL_BLK_LEN_MAX) {\n\t\tret = iqs5xx_bl_cmd(client, IQS5XX_BL_CMD_READ, bl_addr + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = i2c_transfer(client->adapter, &msg, 1);\n\t\tif (ret != 1)\n\t\t\tgoto msg_fail;\n\n\t\tif (memcmp(bl_data, pmap_data + i, sizeof(bl_data))) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to verify block at address 0x%04X\\n\",\n\t\t\t\tbl_addr + i);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n\nmsg_fail:\n\tif (ret >= 0)\n\t\tret = -EIO;\n\n\tdev_err(&client->dev, \"Failed to read block at address 0x%04X: %d\\n\",\n\t\tbl_addr + i, ret);\n\n\treturn ret;\n}\n\nstatic int iqs5xx_set_state(struct i2c_client *client, u8 state)\n{\n\tstruct iqs5xx_private *iqs5xx = i2c_get_clientdata(client);\n\tint error1, error2;\n\n\tif (!iqs5xx->dev_id_info.bl_status)\n\t\treturn 0;\n\n\tmutex_lock(&iqs5xx->lock);\n\n\t \n\tdisable_irq(client->irq);\n\n\terror1 = iqs5xx_write_byte(client, IQS5XX_SYS_CTRL1, state);\n\terror2 = iqs5xx_write_byte(client, IQS5XX_END_COMM, 0);\n\n\tusleep_range(50, 100);\n\tenable_irq(client->irq);\n\n\tmutex_unlock(&iqs5xx->lock);\n\n\tif (error1)\n\t\treturn error1;\n\n\treturn error2;\n}\n\nstatic int iqs5xx_open(struct input_dev *input)\n{\n\tstruct iqs5xx_private *iqs5xx = input_get_drvdata(input);\n\n\treturn iqs5xx_set_state(iqs5xx->client, IQS5XX_RESUME);\n}\n\nstatic void iqs5xx_close(struct input_dev *input)\n{\n\tstruct iqs5xx_private *iqs5xx = input_get_drvdata(input);\n\n\tiqs5xx_set_state(iqs5xx->client, IQS5XX_SUSPEND);\n}\n\nstatic int iqs5xx_axis_init(struct i2c_client *client)\n{\n\tstruct iqs5xx_private *iqs5xx = i2c_get_clientdata(client);\n\tstruct touchscreen_properties *prop = &iqs5xx->prop;\n\tstruct input_dev *input = iqs5xx->input;\n\tu16 max_x, max_y;\n\tint error;\n\n\tif (!input) {\n\t\tinput = devm_input_allocate_device(&client->dev);\n\t\tif (!input)\n\t\t\treturn -ENOMEM;\n\n\t\tinput->name = client->name;\n\t\tinput->id.bustype = BUS_I2C;\n\t\tinput->open = iqs5xx_open;\n\t\tinput->close = iqs5xx_close;\n\n\t\tinput_set_drvdata(input, iqs5xx);\n\t\tiqs5xx->input = input;\n\t}\n\n\terror = iqs5xx_read_word(client, IQS5XX_X_RES, &max_x);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs5xx_read_word(client, IQS5XX_Y_RES, &max_y);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, U16_MAX, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, prop);\n\n\t \n\tif (prop->max_x >= U16_MAX || prop->max_y >= U16_MAX) {\n\t\tdev_err(&client->dev, \"Invalid touchscreen size: %u*%u\\n\",\n\t\t\tprop->max_x, prop->max_y);\n\t\treturn -EINVAL;\n\t}\n\n\tif (prop->max_x != max_x) {\n\t\terror = iqs5xx_write_word(client, IQS5XX_X_RES, prop->max_x);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (prop->max_y != max_y) {\n\t\terror = iqs5xx_write_word(client, IQS5XX_Y_RES, prop->max_y);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = input_mt_init_slots(input, IQS5XX_NUM_CONTACTS,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to initialize slots: %d\\n\",\n\t\t\terror);\n\n\treturn error;\n}\n\nstatic int iqs5xx_dev_init(struct i2c_client *client)\n{\n\tstruct iqs5xx_private *iqs5xx = i2c_get_clientdata(client);\n\tstruct iqs5xx_dev_id_info *dev_id_info;\n\tint error;\n\tu8 buf[sizeof(*dev_id_info) + 1];\n\n\terror = iqs5xx_read_burst(client, IQS5XX_PROD_NUM,\n\t\t\t\t  &buf[1], sizeof(*dev_id_info));\n\tif (error)\n\t\treturn iqs5xx_bl_open(client);\n\n\t \n\tbuf[0] = 0;\n\tdev_id_info = (struct iqs5xx_dev_id_info *)&buf[buf[1] ? 0 : 1];\n\n\tswitch (be16_to_cpu(dev_id_info->prod_num)) {\n\tcase IQS5XX_PROD_NUM_IQS550:\n\tcase IQS5XX_PROD_NUM_IQS572:\n\tcase IQS5XX_PROD_NUM_IQS525:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Unrecognized product number: %u\\n\",\n\t\t\tbe16_to_cpu(dev_id_info->prod_num));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (buf[1]) {\n\t\tdev_err(&client->dev, \"Opening bootloader for A000 device\\n\");\n\t\treturn iqs5xx_bl_open(client);\n\t}\n\n\terror = iqs5xx_read_burst(client, IQS5XX_EXP_FILE,\n\t\t\t\t  iqs5xx->exp_file, sizeof(iqs5xx->exp_file));\n\tif (error)\n\t\treturn error;\n\n\terror = iqs5xx_axis_init(client);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs5xx_write_byte(client, IQS5XX_SYS_CTRL0, IQS5XX_ACK_RESET);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs5xx_write_byte(client, IQS5XX_SYS_CFG0,\n\t\t\t\t  IQS5XX_SETUP_COMPLETE | IQS5XX_WDT |\n\t\t\t\t  IQS5XX_ALP_REATI | IQS5XX_REATI);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs5xx_write_byte(client, IQS5XX_SYS_CFG1,\n\t\t\t\t  IQS5XX_TP_EVENT | IQS5XX_EVENT_MODE);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs5xx_write_byte(client, IQS5XX_END_COMM, 0);\n\tif (error)\n\t\treturn error;\n\n\tiqs5xx->dev_id_info = *dev_id_info;\n\n\t \n\tmsleep(250);\n\n\treturn 0;\n}\n\nstatic irqreturn_t iqs5xx_irq(int irq, void *data)\n{\n\tstruct iqs5xx_private *iqs5xx = data;\n\tstruct iqs5xx_status status;\n\tstruct i2c_client *client = iqs5xx->client;\n\tstruct input_dev *input = iqs5xx->input;\n\tint error, i;\n\n\t \n\tif (!iqs5xx->dev_id_info.bl_status)\n\t\treturn IRQ_NONE;\n\n\terror = iqs5xx_read_burst(client, IQS5XX_SYS_INFO0,\n\t\t\t\t  &status, sizeof(status));\n\tif (error)\n\t\treturn IRQ_NONE;\n\n\tif (status.sys_info[0] & IQS5XX_SHOW_RESET) {\n\t\tdev_err(&client->dev, \"Unexpected device reset\\n\");\n\n\t\terror = iqs5xx_dev_init(client);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to re-initialize device: %d\\n\", error);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(status.touch_data); i++) {\n\t\tstruct iqs5xx_touch_data *touch_data = &status.touch_data[i];\n\t\tu16 pressure = be16_to_cpu(touch_data->strength);\n\n\t\tinput_mt_slot(input, i);\n\t\tif (input_mt_report_slot_state(input, MT_TOOL_FINGER,\n\t\t\t\t\t       pressure != 0)) {\n\t\t\ttouchscreen_report_pos(input, &iqs5xx->prop,\n\t\t\t\t\t       be16_to_cpu(touch_data->abs_x),\n\t\t\t\t\t       be16_to_cpu(touch_data->abs_y),\n\t\t\t\t\t       true);\n\t\t\tinput_report_abs(input, ABS_MT_PRESSURE, pressure);\n\t\t}\n\t}\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n\n\terror = iqs5xx_write_byte(client, IQS5XX_END_COMM, 0);\n\tif (error)\n\t\treturn IRQ_NONE;\n\n\t \n\tusleep_range(50, 100);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int iqs5xx_fw_file_parse(struct i2c_client *client,\n\t\t\t\tconst char *fw_file, u8 *pmap)\n{\n\tconst struct firmware *fw;\n\tstruct iqs5xx_ihex_rec *rec;\n\tsize_t pos = 0;\n\tint error, i;\n\tu16 rec_num = 1;\n\tu16 rec_addr;\n\tu8 rec_len, rec_type, rec_chksm, chksm;\n\tu8 rec_hdr[IQS5XX_REC_HDR_LEN];\n\tu8 rec_data[IQS5XX_REC_LEN_MAX];\n\n\t \n\terror = request_firmware(&fw, fw_file, &client->dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to request firmware %s: %d\\n\",\n\t\t\tfw_file, error);\n\t\treturn error;\n\t}\n\n\tdo {\n\t\tif (pos + sizeof(*rec) > fw->size) {\n\t\t\tdev_err(&client->dev, \"Insufficient firmware size\\n\");\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trec = (struct iqs5xx_ihex_rec *)(fw->data + pos);\n\t\tpos += sizeof(*rec);\n\n\t\tif (rec->start != ':') {\n\t\t\tdev_err(&client->dev, \"Invalid start at record %u\\n\",\n\t\t\t\trec_num);\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terror = hex2bin(rec_hdr, rec->len, sizeof(rec_hdr));\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Invalid header at record %u\\n\",\n\t\t\t\trec_num);\n\t\t\tbreak;\n\t\t}\n\n\t\trec_len = *rec_hdr;\n\t\trec_addr = get_unaligned_be16(rec_hdr + sizeof(rec_len));\n\t\trec_type = *(rec_hdr + sizeof(rec_len) + sizeof(rec_addr));\n\n\t\tif (pos + rec_len * 2 > fw->size) {\n\t\t\tdev_err(&client->dev, \"Insufficient firmware size\\n\");\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpos += (rec_len * 2);\n\n\t\terror = hex2bin(rec_data, rec->data, rec_len);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Invalid data at record %u\\n\",\n\t\t\t\trec_num);\n\t\t\tbreak;\n\t\t}\n\n\t\terror = hex2bin(&rec_chksm,\n\t\t\t\trec->data + rec_len * 2, sizeof(rec_chksm));\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Invalid checksum at record %u\\n\",\n\t\t\t\trec_num);\n\t\t\tbreak;\n\t\t}\n\n\t\tchksm = 0;\n\t\tfor (i = 0; i < sizeof(rec_hdr); i++)\n\t\t\tchksm += rec_hdr[i];\n\t\tfor (i = 0; i < rec_len; i++)\n\t\t\tchksm += rec_data[i];\n\t\tchksm = ~chksm + 1;\n\n\t\tif (chksm != rec_chksm && rec_addr < IQS5XX_CSTM) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Incorrect checksum at record %u\\n\",\n\t\t\t\trec_num);\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (rec_type) {\n\t\tcase IQS5XX_REC_TYPE_DATA:\n\t\t\tif (rec_addr < IQS5XX_CHKSM ||\n\t\t\t    rec_addr > IQS5XX_PMAP_END) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid address at record %u\\n\",\n\t\t\t\t\trec_num);\n\t\t\t\terror = -EINVAL;\n\t\t\t} else {\n\t\t\t\tmemcpy(pmap + rec_addr - IQS5XX_CHKSM,\n\t\t\t\t       rec_data, rec_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IQS5XX_REC_TYPE_EOF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&client->dev, \"Invalid type at record %u\\n\",\n\t\t\t\trec_num);\n\t\t\terror = -EINVAL;\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\trec_num++;\n\t\twhile (pos < fw->size) {\n\t\t\tif (*(fw->data + pos) == ':')\n\t\t\t\tbreak;\n\t\t\tpos++;\n\t\t}\n\t} while (rec_type != IQS5XX_REC_TYPE_EOF);\n\n\trelease_firmware(fw);\n\n\treturn error;\n}\n\nstatic int iqs5xx_fw_file_write(struct i2c_client *client, const char *fw_file)\n{\n\tstruct iqs5xx_private *iqs5xx = i2c_get_clientdata(client);\n\tint error, error_init = 0;\n\tu8 *pmap;\n\n\tpmap = kzalloc(IQS5XX_PMAP_LEN, GFP_KERNEL);\n\tif (!pmap)\n\t\treturn -ENOMEM;\n\n\terror = iqs5xx_fw_file_parse(client, fw_file, pmap);\n\tif (error)\n\t\tgoto err_kfree;\n\n\tmutex_lock(&iqs5xx->lock);\n\n\t \n\tdisable_irq(client->irq);\n\n\tiqs5xx->dev_id_info.bl_status = 0;\n\n\terror = iqs5xx_bl_cmd(client, IQS5XX_BL_CMD_VER, 0);\n\tif (error) {\n\t\terror = iqs5xx_bl_open(client);\n\t\tif (error)\n\t\t\tgoto err_reset;\n\t}\n\n\terror = iqs5xx_bl_write(client, IQS5XX_CHKSM, pmap, IQS5XX_PMAP_LEN);\n\tif (error)\n\t\tgoto err_reset;\n\n\terror = iqs5xx_bl_cmd(client, IQS5XX_BL_CMD_CRC, 0);\n\tif (error)\n\t\tgoto err_reset;\n\n\terror = iqs5xx_bl_verify(client, IQS5XX_CSTM,\n\t\t\t\t pmap + IQS5XX_CHKSM_LEN + IQS5XX_APP_LEN,\n\t\t\t\t IQS5XX_CSTM_LEN);\n\nerr_reset:\n\tiqs5xx_reset(client);\n\tusleep_range(15000, 15100);\n\n\terror_init = iqs5xx_dev_init(client);\n\tif (!iqs5xx->dev_id_info.bl_status)\n\t\terror_init = error_init ? : -EINVAL;\n\n\tenable_irq(client->irq);\n\n\tmutex_unlock(&iqs5xx->lock);\n\nerr_kfree:\n\tkfree(pmap);\n\n\treturn error ? : error_init;\n}\n\nstatic ssize_t fw_file_store(struct device *dev,\n\t\t\t     struct device_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct iqs5xx_private *iqs5xx = dev_get_drvdata(dev);\n\tstruct i2c_client *client = iqs5xx->client;\n\tsize_t len = count;\n\tbool input_reg = !iqs5xx->input;\n\tchar fw_file[IQS5XX_FW_FILE_LEN + 1];\n\tint error;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len - 1] == '\\n')\n\t\tlen--;\n\n\tif (len > IQS5XX_FW_FILE_LEN)\n\t\treturn -ENAMETOOLONG;\n\n\tmemcpy(fw_file, buf, len);\n\tfw_file[len] = '\\0';\n\n\terror = iqs5xx_fw_file_write(client, fw_file);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (input_reg) {\n\t\terror = input_register_device(iqs5xx->input);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to register device: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t fw_info_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct iqs5xx_private *iqs5xx = dev_get_drvdata(dev);\n\n\tif (!iqs5xx->dev_id_info.bl_status)\n\t\treturn -ENODATA;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u.%u.%u.%u:%u.%u\\n\",\n\t\t\t be16_to_cpu(iqs5xx->dev_id_info.prod_num),\n\t\t\t be16_to_cpu(iqs5xx->dev_id_info.proj_num),\n\t\t\t iqs5xx->dev_id_info.major_ver,\n\t\t\t iqs5xx->dev_id_info.minor_ver,\n\t\t\t iqs5xx->exp_file[0], iqs5xx->exp_file[1]);\n}\n\nstatic DEVICE_ATTR_WO(fw_file);\nstatic DEVICE_ATTR_RO(fw_info);\n\nstatic struct attribute *iqs5xx_attrs[] = {\n\t&dev_attr_fw_file.attr,\n\t&dev_attr_fw_info.attr,\n\tNULL,\n};\n\nstatic umode_t iqs5xx_attr_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int i)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct iqs5xx_private *iqs5xx = dev_get_drvdata(dev);\n\n\tif (attr == &dev_attr_fw_file.attr &&\n\t    (iqs5xx->dev_id_info.bl_status == IQS5XX_BL_STATUS_NONE ||\n\t    !iqs5xx->reset_gpio))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group iqs5xx_attr_group = {\n\t.is_visible = iqs5xx_attr_is_visible,\n\t.attrs = iqs5xx_attrs,\n};\n\nstatic int iqs5xx_suspend(struct device *dev)\n{\n\tstruct iqs5xx_private *iqs5xx = dev_get_drvdata(dev);\n\tstruct input_dev *input = iqs5xx->input;\n\tint error = 0;\n\n\tif (!input || device_may_wakeup(dev))\n\t\treturn error;\n\n\tmutex_lock(&input->mutex);\n\n\tif (input_device_enabled(input))\n\t\terror = iqs5xx_set_state(iqs5xx->client, IQS5XX_SUSPEND);\n\n\tmutex_unlock(&input->mutex);\n\n\treturn error;\n}\n\nstatic int iqs5xx_resume(struct device *dev)\n{\n\tstruct iqs5xx_private *iqs5xx = dev_get_drvdata(dev);\n\tstruct input_dev *input = iqs5xx->input;\n\tint error = 0;\n\n\tif (!input || device_may_wakeup(dev))\n\t\treturn error;\n\n\tmutex_lock(&input->mutex);\n\n\tif (input_device_enabled(input))\n\t\terror = iqs5xx_set_state(iqs5xx->client, IQS5XX_RESUME);\n\n\tmutex_unlock(&input->mutex);\n\n\treturn error;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(iqs5xx_pm, iqs5xx_suspend, iqs5xx_resume);\n\nstatic int iqs5xx_probe(struct i2c_client *client)\n{\n\tstruct iqs5xx_private *iqs5xx;\n\tint error;\n\n\tiqs5xx = devm_kzalloc(&client->dev, sizeof(*iqs5xx), GFP_KERNEL);\n\tif (!iqs5xx)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, iqs5xx);\n\tiqs5xx->client = client;\n\n\tiqs5xx->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t     \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(iqs5xx->reset_gpio)) {\n\t\terror = PTR_ERR(iqs5xx->reset_gpio);\n\t\tdev_err(&client->dev, \"Failed to request GPIO: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmutex_init(&iqs5xx->lock);\n\n\terror = iqs5xx_dev_init(client);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, iqs5xx_irq, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, iqs5xx);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &iqs5xx_attr_group);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to add attributes: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (iqs5xx->input) {\n\t\terror = input_register_device(iqs5xx->input);\n\t\tif (error)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to register device: %d\\n\",\n\t\t\t\terror);\n\t}\n\n\treturn error;\n}\n\nstatic const struct i2c_device_id iqs5xx_id[] = {\n\t{ \"iqs550\", 0 },\n\t{ \"iqs572\", 1 },\n\t{ \"iqs525\", 2 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, iqs5xx_id);\n\nstatic const struct of_device_id iqs5xx_of_match[] = {\n\t{ .compatible = \"azoteq,iqs550\" },\n\t{ .compatible = \"azoteq,iqs572\" },\n\t{ .compatible = \"azoteq,iqs525\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, iqs5xx_of_match);\n\nstatic struct i2c_driver iqs5xx_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"iqs5xx\",\n\t\t.of_match_table\t= iqs5xx_of_match,\n\t\t.pm\t\t= pm_sleep_ptr(&iqs5xx_pm),\n\t},\n\t.id_table\t= iqs5xx_id,\n\t.probe\t\t= iqs5xx_probe,\n};\nmodule_i2c_driver(iqs5xx_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS550/572/525 Trackpad/Touchscreen Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}