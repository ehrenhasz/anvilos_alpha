{
  "module_name": "cyttsp_spi.c",
  "hash_id": "0ec456f3cb00b847816664d01504038613cb7890e6d07be11dfb4b886621fd76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cyttsp_spi.c",
  "human_readable_source": "\n \n\n#include \"cyttsp_core.h\"\n\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/spi/spi.h>\n\n#define CY_SPI_NAME\t\t\"cyttsp-spi\"\n\n#define CY_SPI_WR_OP\t\t0x00  \n#define CY_SPI_RD_OP\t\t0x01\n#define CY_SPI_CMD_BYTES\t4\n#define CY_SPI_SYNC_BYTE\t2\n#define CY_SPI_SYNC_ACK1\t0x62  \n#define CY_SPI_SYNC_ACK2\t0x9D  \n#define CY_SPI_DATA_SIZE\t128\n#define CY_SPI_DATA_BUF_SIZE\t(CY_SPI_CMD_BYTES + CY_SPI_DATA_SIZE)\n#define CY_SPI_BITS_PER_WORD\t8\n\nstatic int cyttsp_spi_xfer(struct device *dev, u8 *xfer_buf,\n\t\t\t   u8 op, u16 reg, u8 *buf, int length)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer[2];\n\tu8 *wr_buf = &xfer_buf[0];\n\tu8 *rd_buf = &xfer_buf[CY_SPI_DATA_BUF_SIZE];\n\tint retval;\n\tint i;\n\n\tif (length > CY_SPI_DATA_SIZE) {\n\t\tdev_err(dev, \"%s: length %d is too big.\\n\",\n\t\t\t__func__, length);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(wr_buf, 0, CY_SPI_DATA_BUF_SIZE);\n\tmemset(rd_buf, 0, CY_SPI_DATA_BUF_SIZE);\n\n\twr_buf[0] = 0x00;  \n\twr_buf[1] = 0xFF;  \n\twr_buf[2] = reg;   \n\twr_buf[3] = op;    \n\tif (op == CY_SPI_WR_OP)\n\t\tmemcpy(wr_buf + CY_SPI_CMD_BYTES, buf, length);\n\n\tmemset(xfer, 0, sizeof(xfer));\n\tspi_message_init(&msg);\n\n\t \n\txfer[0].tx_buf = wr_buf;\n\txfer[0].rx_buf = rd_buf;\n\tswitch (op) {\n\tcase CY_SPI_WR_OP:\n\t\txfer[0].len = length + CY_SPI_CMD_BYTES;\n\t\tspi_message_add_tail(&xfer[0], &msg);\n\t\tbreak;\n\n\tcase CY_SPI_RD_OP:\n\t\txfer[0].len = CY_SPI_CMD_BYTES;\n\t\tspi_message_add_tail(&xfer[0], &msg);\n\n\t\txfer[1].rx_buf = buf;\n\t\txfer[1].len = length;\n\t\tspi_message_add_tail(&xfer[1], &msg);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"%s: bad operation code=%d\\n\", __func__, op);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = spi_sync(spi, &msg);\n\tif (retval < 0) {\n\t\tdev_dbg(dev, \"%s: spi_sync() error %d, len=%d, op=%d\\n\",\n\t\t\t__func__, retval, xfer[1].len, op);\n\n\t\t \n\t}\n\n\tif (rd_buf[CY_SPI_SYNC_BYTE] != CY_SPI_SYNC_ACK1 ||\n\t    rd_buf[CY_SPI_SYNC_BYTE + 1] != CY_SPI_SYNC_ACK2) {\n\t\tdev_dbg(dev, \"%s: operation %d failed\\n\", __func__, op);\n\n\t\tfor (i = 0; i < CY_SPI_CMD_BYTES; i++)\n\t\t\tdev_dbg(dev, \"%s: test rd_buf[%d]:0x%02x\\n\",\n\t\t\t\t__func__, i, rd_buf[i]);\n\t\tfor (i = 0; i < length; i++)\n\t\t\tdev_dbg(dev, \"%s: test buf[%d]:0x%02x\\n\",\n\t\t\t\t__func__, i, buf[i]);\n\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyttsp_spi_read_block_data(struct device *dev, u8 *xfer_buf,\n\t\t\t\t      u16 addr, u8 length, void *data)\n{\n\treturn cyttsp_spi_xfer(dev, xfer_buf, CY_SPI_RD_OP, addr, data,\n\t\t\tlength);\n}\n\nstatic int cyttsp_spi_write_block_data(struct device *dev, u8 *xfer_buf,\n\t\t\t\t       u16 addr, u8 length, const void *data)\n{\n\treturn cyttsp_spi_xfer(dev, xfer_buf, CY_SPI_WR_OP, addr, (void *)data,\n\t\t\tlength);\n}\n\nstatic const struct cyttsp_bus_ops cyttsp_spi_bus_ops = {\n\t.bustype\t= BUS_SPI,\n\t.write\t\t= cyttsp_spi_write_block_data,\n\t.read\t\t= cyttsp_spi_read_block_data,\n};\n\nstatic int cyttsp_spi_probe(struct spi_device *spi)\n{\n\tstruct cyttsp *ts;\n\tint error;\n\n\t \n\tspi->bits_per_word = CY_SPI_BITS_PER_WORD;\n\tspi->mode = SPI_MODE_0;\n\terror = spi_setup(spi);\n\tif (error < 0) {\n\t\tdev_err(&spi->dev, \"%s: SPI setup error %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\tts = cyttsp_probe(&cyttsp_spi_bus_ops, &spi->dev, spi->irq,\n\t\t\t  CY_SPI_DATA_BUF_SIZE * 2);\n\tif (IS_ERR(ts))\n\t\treturn PTR_ERR(ts);\n\n\tspi_set_drvdata(spi, ts);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cyttsp_of_spi_match[] = {\n\t{ .compatible = \"cypress,cy8ctma340\", },\n\t{ .compatible = \"cypress,cy8ctst341\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cyttsp_of_spi_match);\n\nstatic struct spi_driver cyttsp_spi_driver = {\n\t.driver = {\n\t\t.name\t= CY_SPI_NAME,\n\t\t.pm\t= pm_sleep_ptr(&cyttsp_pm_ops),\n\t\t.of_match_table = cyttsp_of_spi_match,\n\t},\n\t.probe  = cyttsp_spi_probe,\n};\n\nmodule_spi_driver(cyttsp_spi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cypress TrueTouch(R) Standard Product (TTSP) SPI driver\");\nMODULE_AUTHOR(\"Cypress\");\nMODULE_ALIAS(\"spi:cyttsp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}