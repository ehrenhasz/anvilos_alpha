{
  "module_name": "atmel_mxt_ts.c",
  "hash_id": "b34958f1b9c01c26cc3eab9587632f5d23b7bd2cfe9667614c908479d623ddf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/atmel_mxt_ts.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <asm/unaligned.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n#include <dt-bindings/input/atmel-maxtouch.h>\n\n \n#define MXT_FW_NAME\t\t\"maxtouch.fw\"\n#define MXT_CFG_NAME\t\t\"maxtouch.cfg\"\n#define MXT_CFG_MAGIC\t\t\"OBP_RAW V1\"\n\n \n#define MXT_OBJECT_START\t0x07\n#define MXT_OBJECT_SIZE\t\t6\n#define MXT_INFO_CHECKSUM_SIZE\t3\n#define MXT_MAX_BLOCK_WRITE\t256\n\n \n#define MXT_DEBUG_DIAGNOSTIC_T37\t37\n#define MXT_GEN_MESSAGE_T5\t\t5\n#define MXT_GEN_COMMAND_T6\t\t6\n#define MXT_GEN_POWER_T7\t\t7\n#define MXT_GEN_ACQUIRE_T8\t\t8\n#define MXT_GEN_DATASOURCE_T53\t\t53\n#define MXT_TOUCH_MULTI_T9\t\t9\n#define MXT_TOUCH_KEYARRAY_T15\t\t15\n#define MXT_TOUCH_PROXIMITY_T23\t\t23\n#define MXT_TOUCH_PROXKEY_T52\t\t52\n#define MXT_TOUCH_PTC_KEYS_T97\t\t97\n#define MXT_PROCI_GRIPFACE_T20\t\t20\n#define MXT_PROCG_NOISE_T22\t\t22\n#define MXT_PROCI_ONETOUCH_T24\t\t24\n#define MXT_PROCI_TWOTOUCH_T27\t\t27\n#define MXT_PROCI_GRIP_T40\t\t40\n#define MXT_PROCI_PALM_T41\t\t41\n#define MXT_PROCI_TOUCHSUPPRESSION_T42\t42\n#define MXT_PROCI_STYLUS_T47\t\t47\n#define MXT_PROCG_NOISESUPPRESSION_T48\t48\n#define MXT_SPT_COMMSCONFIG_T18\t\t18\n#define MXT_SPT_GPIOPWM_T19\t\t19\n#define MXT_SPT_SELFTEST_T25\t\t25\n#define MXT_SPT_CTECONFIG_T28\t\t28\n#define MXT_SPT_USERDATA_T38\t\t38\n#define MXT_SPT_DIGITIZER_T43\t\t43\n#define MXT_SPT_MESSAGECOUNT_T44\t44\n#define MXT_SPT_CTECONFIG_T46\t\t46\n#define MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71 71\n#define MXT_TOUCH_MULTITOUCHSCREEN_T100 100\n\n \n#define MXT_RPTID_NOMSG\t\t0xff\n\n \n#define MXT_COMMAND_RESET\t0\n#define MXT_COMMAND_BACKUPNV\t1\n#define MXT_COMMAND_CALIBRATE\t2\n#define MXT_COMMAND_REPORTALL\t3\n#define MXT_COMMAND_DIAGNOSTIC\t5\n\n \n#define MXT_T6_STATUS_RESET\tBIT(7)\n#define MXT_T6_STATUS_OFL\tBIT(6)\n#define MXT_T6_STATUS_SIGERR\tBIT(5)\n#define MXT_T6_STATUS_CAL\tBIT(4)\n#define MXT_T6_STATUS_CFGERR\tBIT(3)\n#define MXT_T6_STATUS_COMSERR\tBIT(2)\n\n \nstruct t7_config {\n\tu8 idle;\n\tu8 active;\n} __packed;\n\n#define MXT_POWER_CFG_RUN\t\t0\n#define MXT_POWER_CFG_DEEPSLEEP\t\t1\n\n \n#define MXT_T9_CTRL\t\t0\n#define MXT_T9_XSIZE\t\t3\n#define MXT_T9_YSIZE\t\t4\n#define MXT_T9_ORIENT\t\t9\n#define MXT_T9_RANGE\t\t18\n\n \n#define MXT_T9_UNGRIP\t\tBIT(0)\n#define MXT_T9_SUPPRESS\t\tBIT(1)\n#define MXT_T9_AMP\t\tBIT(2)\n#define MXT_T9_VECTOR\t\tBIT(3)\n#define MXT_T9_MOVE\t\tBIT(4)\n#define MXT_T9_RELEASE\t\tBIT(5)\n#define MXT_T9_PRESS\t\tBIT(6)\n#define MXT_T9_DETECT\t\tBIT(7)\n\nstruct t9_range {\n\t__le16 x;\n\t__le16 y;\n} __packed;\n\n \n#define MXT_T9_ORIENT_SWITCH\tBIT(0)\n#define MXT_T9_ORIENT_INVERTX\tBIT(1)\n#define MXT_T9_ORIENT_INVERTY\tBIT(2)\n\n \n#define MXT_COMMS_CTRL\t\t0\n#define MXT_COMMS_CMD\t\t1\n#define MXT_COMMS_RETRIGEN\tBIT(6)\n\n \n#define MXT_DIAGNOSTIC_PAGEUP\t0x01\n#define MXT_DIAGNOSTIC_DELTAS\t0x10\n#define MXT_DIAGNOSTIC_REFS\t0x11\n#define MXT_DIAGNOSTIC_SIZE\t128\n\n#define MXT_FAMILY_1386\t\t\t160\n#define MXT1386_COLUMNS\t\t\t3\n#define MXT1386_PAGES_PER_COLUMN\t8\n\nstruct t37_debug {\n#ifdef CONFIG_TOUCHSCREEN_ATMEL_MXT_T37\n\tu8 mode;\n\tu8 page;\n\tu8 data[MXT_DIAGNOSTIC_SIZE];\n#endif\n};\n\n \n#define MXT_BOOT_VALUE\t\t0xa5\n#define MXT_RESET_VALUE\t\t0x01\n#define MXT_BACKUP_VALUE\t0x55\n\n \n#define MXT_T100_CTRL\t\t0\n#define MXT_T100_CFG1\t\t1\n#define MXT_T100_TCHAUX\t\t3\n#define MXT_T100_XSIZE\t\t9\n#define MXT_T100_XRANGE\t\t13\n#define MXT_T100_YSIZE\t\t20\n#define MXT_T100_YRANGE\t\t24\n\n#define MXT_T100_CFG_SWITCHXY\tBIT(5)\n#define MXT_T100_CFG_INVERTY\tBIT(6)\n#define MXT_T100_CFG_INVERTX\tBIT(7)\n\n#define MXT_T100_TCHAUX_VECT\tBIT(0)\n#define MXT_T100_TCHAUX_AMPL\tBIT(1)\n#define MXT_T100_TCHAUX_AREA\tBIT(2)\n\n#define MXT_T100_DETECT\t\tBIT(7)\n#define MXT_T100_TYPE_MASK\t0x70\n\nenum t100_type {\n\tMXT_T100_TYPE_FINGER\t\t= 1,\n\tMXT_T100_TYPE_PASSIVE_STYLUS\t= 2,\n\tMXT_T100_TYPE_HOVERING_FINGER\t= 4,\n\tMXT_T100_TYPE_GLOVE\t\t= 5,\n\tMXT_T100_TYPE_LARGE_TOUCH\t= 6,\n};\n\n#define MXT_DISTANCE_ACTIVE_TOUCH\t0\n#define MXT_DISTANCE_HOVERING\t\t1\n\n#define MXT_TOUCH_MAJOR_DEFAULT\t\t1\n#define MXT_PRESSURE_DEFAULT\t\t1\n\n \n#define MXT_BACKUP_TIME\t\t50\t \n#define MXT_RESET_GPIO_TIME\t20\t \n#define MXT_RESET_INVALID_CHG\t100\t \n#define MXT_RESET_TIME\t\t200\t \n#define MXT_RESET_TIMEOUT\t3000\t \n#define MXT_CRC_TIMEOUT\t\t1000\t \n#define MXT_FW_RESET_TIME\t3000\t \n#define MXT_FW_CHG_TIMEOUT\t300\t \n#define MXT_WAKEUP_TIME\t\t25\t \n\n \n#define MXT_UNLOCK_CMD_MSB\t0xaa\n#define MXT_UNLOCK_CMD_LSB\t0xdc\n\n \n#define MXT_WAITING_BOOTLOAD_CMD\t0xc0\t \n#define MXT_WAITING_FRAME_DATA\t0x80\t \n#define MXT_FRAME_CRC_CHECK\t0x02\n#define MXT_FRAME_CRC_FAIL\t0x03\n#define MXT_FRAME_CRC_PASS\t0x04\n#define MXT_APP_CRC_FAIL\t0x40\t \n#define MXT_BOOT_STATUS_MASK\t0x3f\n#define MXT_BOOT_EXTENDED_ID\tBIT(5)\n#define MXT_BOOT_ID_MASK\t0x1f\n\n \n#define MXT_MAX_AREA\t\t0xff\n\n#define MXT_PIXELS_PER_MM\t20\n\nstruct mxt_info {\n\tu8 family_id;\n\tu8 variant_id;\n\tu8 version;\n\tu8 build;\n\tu8 matrix_xsize;\n\tu8 matrix_ysize;\n\tu8 object_num;\n};\n\nstruct mxt_object {\n\tu8 type;\n\tu16 start_address;\n\tu8 size_minus_one;\n\tu8 instances_minus_one;\n\tu8 num_report_ids;\n} __packed;\n\nstruct mxt_dbg {\n\tu16 t37_address;\n\tu16 diag_cmd_address;\n\tstruct t37_debug *t37_buf;\n\tunsigned int t37_pages;\n\tunsigned int t37_nodes;\n\n\tstruct v4l2_device v4l2;\n\tstruct v4l2_pix_format format;\n\tstruct video_device vdev;\n\tstruct vb2_queue queue;\n\tstruct mutex lock;\n\tint input;\n};\n\nenum v4l_dbg_inputs {\n\tMXT_V4L_INPUT_DELTAS,\n\tMXT_V4L_INPUT_REFS,\n\tMXT_V4L_INPUT_MAX,\n};\n\nenum mxt_suspend_mode {\n\tMXT_SUSPEND_DEEP_SLEEP\t= 0,\n\tMXT_SUSPEND_T9_CTRL\t= 1,\n};\n\n \nstruct mxt_cfg {\n\tu8 *raw;\n\tsize_t raw_size;\n\toff_t raw_pos;\n\n\tu8 *mem;\n\tsize_t mem_size;\n\tint start_ofs;\n\n\tstruct mxt_info info;\n};\n\n \nstruct mxt_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tchar phys[64];\t\t \n\tstruct mxt_object *object_table;\n\tstruct mxt_info *info;\n\tvoid *raw_info_block;\n\tunsigned int irq;\n\tunsigned int max_x;\n\tunsigned int max_y;\n\tbool invertx;\n\tbool inverty;\n\tbool xy_switch;\n\tu8 xsize;\n\tu8 ysize;\n\tbool in_bootloader;\n\tu16 mem_size;\n\tu8 t100_aux_ampl;\n\tu8 t100_aux_area;\n\tu8 t100_aux_vect;\n\tu8 max_reportid;\n\tu32 config_crc;\n\tu32 info_crc;\n\tu8 bootloader_addr;\n\tu8 *msg_buf;\n\tu8 t6_status;\n\tbool update_input;\n\tu8 last_message_count;\n\tu8 num_touchids;\n\tu8 multitouch;\n\tstruct t7_config t7_cfg;\n\tstruct mxt_dbg dbg;\n\tstruct regulator_bulk_data regulators[2];\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *wake_gpio;\n\tbool use_retrigen_workaround;\n\n\t \n\tu16 T5_address;\n\tu8 T5_msg_size;\n\tu8 T6_reportid;\n\tu16 T6_address;\n\tu16 T7_address;\n\tu16 T71_address;\n\tu8 T9_reportid_min;\n\tu8 T9_reportid_max;\n\tu8 T15_reportid_min;\n\tu8 T15_reportid_max;\n\tu16 T18_address;\n\tu8 T19_reportid;\n\tu16 T44_address;\n\tu8 T97_reportid_min;\n\tu8 T97_reportid_max;\n\tu8 T100_reportid_min;\n\tu8 T100_reportid_max;\n\n\t \n\tstruct completion bl_completion;\n\n\t \n\tstruct completion reset_completion;\n\n\t \n\tstruct completion crc_completion;\n\n\tu32 *t19_keymap;\n\tunsigned int t19_num_keys;\n\n\tu32 *t15_keymap;\n\tunsigned int t15_num_keys;\n\n\tenum mxt_suspend_mode suspend_mode;\n\n\tu32 wakeup_method;\n};\n\nstruct mxt_vb2_buffer {\n\tstruct vb2_buffer\tvb;\n\tstruct list_head\tlist;\n};\n\nstatic size_t mxt_obj_size(const struct mxt_object *obj)\n{\n\treturn obj->size_minus_one + 1;\n}\n\nstatic size_t mxt_obj_instances(const struct mxt_object *obj)\n{\n\treturn obj->instances_minus_one + 1;\n}\n\nstatic bool mxt_object_readable(unsigned int type)\n{\n\tswitch (type) {\n\tcase MXT_GEN_COMMAND_T6:\n\tcase MXT_GEN_POWER_T7:\n\tcase MXT_GEN_ACQUIRE_T8:\n\tcase MXT_GEN_DATASOURCE_T53:\n\tcase MXT_TOUCH_MULTI_T9:\n\tcase MXT_TOUCH_KEYARRAY_T15:\n\tcase MXT_TOUCH_PROXIMITY_T23:\n\tcase MXT_TOUCH_PROXKEY_T52:\n\tcase MXT_TOUCH_PTC_KEYS_T97:\n\tcase MXT_TOUCH_MULTITOUCHSCREEN_T100:\n\tcase MXT_PROCI_GRIPFACE_T20:\n\tcase MXT_PROCG_NOISE_T22:\n\tcase MXT_PROCI_ONETOUCH_T24:\n\tcase MXT_PROCI_TWOTOUCH_T27:\n\tcase MXT_PROCI_GRIP_T40:\n\tcase MXT_PROCI_PALM_T41:\n\tcase MXT_PROCI_TOUCHSUPPRESSION_T42:\n\tcase MXT_PROCI_STYLUS_T47:\n\tcase MXT_PROCG_NOISESUPPRESSION_T48:\n\tcase MXT_SPT_COMMSCONFIG_T18:\n\tcase MXT_SPT_GPIOPWM_T19:\n\tcase MXT_SPT_SELFTEST_T25:\n\tcase MXT_SPT_CTECONFIG_T28:\n\tcase MXT_SPT_USERDATA_T38:\n\tcase MXT_SPT_DIGITIZER_T43:\n\tcase MXT_SPT_CTECONFIG_T46:\n\tcase MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void mxt_dump_message(struct mxt_data *data, u8 *message)\n{\n\tdev_dbg(&data->client->dev, \"message: %*ph\\n\",\n\t\tdata->T5_msg_size, message);\n}\n\nstatic int mxt_wait_for_completion(struct mxt_data *data,\n\t\t\t\t   struct completion *comp,\n\t\t\t\t   unsigned int timeout_ms)\n{\n\tstruct device *dev = &data->client->dev;\n\tunsigned long timeout = msecs_to_jiffies(timeout_ms);\n\tlong ret;\n\n\tret = wait_for_completion_interruptible_timeout(comp, timeout);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret == 0) {\n\t\tdev_err(dev, \"Wait for completion timed out.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\nstatic int mxt_bootloader_read(struct mxt_data *data,\n\t\t\t       u8 *val, unsigned int count)\n{\n\tint ret;\n\tstruct i2c_msg msg;\n\n\tmsg.addr = data->bootloader_addr;\n\tmsg.flags = data->client->flags & I2C_M_TEN;\n\tmsg.flags |= I2C_M_RD;\n\tmsg.len = count;\n\tmsg.buf = val;\n\n\tret = i2c_transfer(data->client->adapter, &msg, 1);\n\tif (ret == 1) {\n\t\tret = 0;\n\t} else {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tdev_err(&data->client->dev, \"%s: i2c recv failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int mxt_bootloader_write(struct mxt_data *data,\n\t\t\t\tconst u8 * const val, unsigned int count)\n{\n\tint ret;\n\tstruct i2c_msg msg;\n\n\tmsg.addr = data->bootloader_addr;\n\tmsg.flags = data->client->flags & I2C_M_TEN;\n\tmsg.len = count;\n\tmsg.buf = (u8 *)val;\n\n\tret = i2c_transfer(data->client->adapter, &msg, 1);\n\tif (ret == 1) {\n\t\tret = 0;\n\t} else {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tdev_err(&data->client->dev, \"%s: i2c send failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int mxt_lookup_bootloader_address(struct mxt_data *data, bool retry)\n{\n\tu8 appmode = data->client->addr;\n\tu8 bootloader;\n\tu8 family_id = data->info ? data->info->family_id : 0;\n\n\tswitch (appmode) {\n\tcase 0x4a:\n\tcase 0x4b:\n\t\t \n\t\tif (retry || family_id >= 0xa2) {\n\t\t\tbootloader = appmode - 0x24;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tcase 0x4c:\n\tcase 0x4d:\n\tcase 0x5a:\n\tcase 0x5b:\n\t\tbootloader = appmode - 0x26;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&data->client->dev,\n\t\t\t\"Appmode i2c address 0x%02x not found\\n\",\n\t\t\tappmode);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->bootloader_addr = bootloader;\n\treturn 0;\n}\n\nstatic int mxt_probe_bootloader(struct mxt_data *data, bool alt_address)\n{\n\tstruct device *dev = &data->client->dev;\n\tint error;\n\tu8 val;\n\tbool crc_failure;\n\n\terror = mxt_lookup_bootloader_address(data, alt_address);\n\tif (error)\n\t\treturn error;\n\n\terror = mxt_bootloader_read(data, &val, 1);\n\tif (error)\n\t\treturn error;\n\n\t \n\tcrc_failure = (val & ~MXT_BOOT_STATUS_MASK) == MXT_APP_CRC_FAIL;\n\n\tdev_err(dev, \"Detected bootloader, status:%02X%s\\n\",\n\t\t\tval, crc_failure ? \", APP_CRC_FAIL\" : \"\");\n\n\treturn 0;\n}\n\nstatic u8 mxt_get_bootloader_version(struct mxt_data *data, u8 val)\n{\n\tstruct device *dev = &data->client->dev;\n\tu8 buf[3];\n\n\tif (val & MXT_BOOT_EXTENDED_ID) {\n\t\tif (mxt_bootloader_read(data, &buf[0], 3) != 0) {\n\t\t\tdev_err(dev, \"%s: i2c failure\\n\", __func__);\n\t\t\treturn val;\n\t\t}\n\n\t\tdev_dbg(dev, \"Bootloader ID:%d Version:%d\\n\", buf[1], buf[2]);\n\n\t\treturn buf[0];\n\t} else {\n\t\tdev_dbg(dev, \"Bootloader ID:%d\\n\", val & MXT_BOOT_ID_MASK);\n\n\t\treturn val;\n\t}\n}\n\nstatic int mxt_check_bootloader(struct mxt_data *data, unsigned int state,\n\t\t\t\tbool wait)\n{\n\tstruct device *dev = &data->client->dev;\n\tu8 val;\n\tint ret;\n\nrecheck:\n\tif (wait) {\n\t\t \n\t\tret = mxt_wait_for_completion(data, &data->bl_completion,\n\t\t\t\t\t      MXT_FW_CHG_TIMEOUT);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_err(dev, \"Update wait error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = mxt_bootloader_read(data, &val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state == MXT_WAITING_BOOTLOAD_CMD)\n\t\tval = mxt_get_bootloader_version(data, val);\n\n\tswitch (state) {\n\tcase MXT_WAITING_BOOTLOAD_CMD:\n\tcase MXT_WAITING_FRAME_DATA:\n\tcase MXT_APP_CRC_FAIL:\n\t\tval &= ~MXT_BOOT_STATUS_MASK;\n\t\tbreak;\n\tcase MXT_FRAME_CRC_PASS:\n\t\tif (val == MXT_FRAME_CRC_CHECK) {\n\t\t\tgoto recheck;\n\t\t} else if (val == MXT_FRAME_CRC_FAIL) {\n\t\t\tdev_err(dev, \"Bootloader CRC fail\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (val != state) {\n\t\tdev_err(dev, \"Invalid bootloader state %02X != %02X\\n\",\n\t\t\tval, state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_send_bootloader_cmd(struct mxt_data *data, bool unlock)\n{\n\tu8 buf[2];\n\n\tif (unlock) {\n\t\tbuf[0] = MXT_UNLOCK_CMD_LSB;\n\t\tbuf[1] = MXT_UNLOCK_CMD_MSB;\n\t} else {\n\t\tbuf[0] = 0x01;\n\t\tbuf[1] = 0x01;\n\t}\n\n\treturn mxt_bootloader_write(data, buf, sizeof(buf));\n}\n\nstatic bool mxt_wakeup_toggle(struct i2c_client *client,\n\t\t\t      bool wake_up, bool in_i2c)\n{\n\tstruct mxt_data *data = i2c_get_clientdata(client);\n\n\tswitch (data->wakeup_method) {\n\tcase ATMEL_MXT_WAKEUP_I2C_SCL:\n\t\tif (!in_i2c)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase ATMEL_MXT_WAKEUP_GPIO:\n\t\tif (in_i2c)\n\t\t\treturn false;\n\n\t\tgpiod_set_value(data->wake_gpio, wake_up);\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (wake_up) {\n\t\tdev_dbg(&client->dev, \"waking up controller\\n\");\n\n\t\tmsleep(MXT_WAKEUP_TIME);\n\t}\n\n\treturn true;\n}\n\nstatic int __mxt_read_reg(struct i2c_client *client,\n\t\t\t       u16 reg, u16 len, void *val)\n{\n\tstruct i2c_msg xfer[2];\n\tbool retried = false;\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = reg & 0xff;\n\tbuf[1] = (reg >> 8) & 0xff;\n\n\t \n\txfer[0].addr = client->addr;\n\txfer[0].flags = 0;\n\txfer[0].len = 2;\n\txfer[0].buf = buf;\n\n\t \n\txfer[1].addr = client->addr;\n\txfer[1].flags = I2C_M_RD;\n\txfer[1].len = len;\n\txfer[1].buf = val;\n\nretry:\n\tret = i2c_transfer(client->adapter, xfer, 2);\n\tif (ret == 2) {\n\t\tret = 0;\n\t} else if (!retried && mxt_wakeup_toggle(client, true, true)) {\n\t\tretried = true;\n\t\tgoto retry;\n\t} else {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tdev_err(&client->dev, \"%s: i2c transfer failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int __mxt_write_reg(struct i2c_client *client, u16 reg, u16 len,\n\t\t\t   const void *val)\n{\n\tbool retried = false;\n\tu8 *buf;\n\tsize_t count;\n\tint ret;\n\n\tcount = len + 2;\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = reg & 0xff;\n\tbuf[1] = (reg >> 8) & 0xff;\n\tmemcpy(&buf[2], val, len);\n\nretry:\n\tret = i2c_master_send(client, buf, count);\n\tif (ret == count) {\n\t\tret = 0;\n\t} else if (!retried && mxt_wakeup_toggle(client, true, true)) {\n\t\tretried = true;\n\t\tgoto retry;\n\t} else {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tdev_err(&client->dev, \"%s: i2c send failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int mxt_write_reg(struct i2c_client *client, u16 reg, u8 val)\n{\n\treturn __mxt_write_reg(client, reg, 1, &val);\n}\n\nstatic struct mxt_object *\nmxt_get_object(struct mxt_data *data, u8 type)\n{\n\tstruct mxt_object *object;\n\tint i;\n\n\tfor (i = 0; i < data->info->object_num; i++) {\n\t\tobject = data->object_table + i;\n\t\tif (object->type == type)\n\t\t\treturn object;\n\t}\n\n\tdev_warn(&data->client->dev, \"Invalid object type T%u\\n\", type);\n\treturn NULL;\n}\n\nstatic void mxt_proc_t6_messages(struct mxt_data *data, u8 *msg)\n{\n\tstruct device *dev = &data->client->dev;\n\tu8 status = msg[1];\n\tu32 crc = msg[2] | (msg[3] << 8) | (msg[4] << 16);\n\n\tif (crc != data->config_crc) {\n\t\tdata->config_crc = crc;\n\t\tdev_dbg(dev, \"T6 Config Checksum: 0x%06X\\n\", crc);\n\t}\n\n\tcomplete(&data->crc_completion);\n\n\t \n\tif (status & MXT_T6_STATUS_RESET)\n\t\tcomplete(&data->reset_completion);\n\n\t \n\tif (status != data->t6_status)\n\t\tdev_dbg(dev, \"T6 Status 0x%02X%s%s%s%s%s%s%s\\n\",\n\t\t\tstatus,\n\t\t\tstatus == 0 ? \" OK\" : \"\",\n\t\t\tstatus & MXT_T6_STATUS_RESET ? \" RESET\" : \"\",\n\t\t\tstatus & MXT_T6_STATUS_OFL ? \" OFL\" : \"\",\n\t\t\tstatus & MXT_T6_STATUS_SIGERR ? \" SIGERR\" : \"\",\n\t\t\tstatus & MXT_T6_STATUS_CAL ? \" CAL\" : \"\",\n\t\t\tstatus & MXT_T6_STATUS_CFGERR ? \" CFGERR\" : \"\",\n\t\t\tstatus & MXT_T6_STATUS_COMSERR ? \" COMSERR\" : \"\");\n\n\t \n\tdata->t6_status = status;\n}\n\nstatic int mxt_write_object(struct mxt_data *data,\n\t\t\t\t u8 type, u8 offset, u8 val)\n{\n\tstruct mxt_object *object;\n\tu16 reg;\n\n\tobject = mxt_get_object(data, type);\n\tif (!object || offset >= mxt_obj_size(object))\n\t\treturn -EINVAL;\n\n\treg = object->start_address;\n\treturn mxt_write_reg(data->client, reg + offset, val);\n}\n\nstatic void mxt_input_button(struct mxt_data *data, u8 *message)\n{\n\tstruct input_dev *input = data->input_dev;\n\tint i;\n\n\tfor (i = 0; i < data->t19_num_keys; i++) {\n\t\tif (data->t19_keymap[i] == KEY_RESERVED)\n\t\t\tcontinue;\n\n\t\t \n\t\tinput_report_key(input, data->t19_keymap[i],\n\t\t\t\t !(message[1] & BIT(i)));\n\t}\n}\n\nstatic void mxt_input_sync(struct mxt_data *data)\n{\n\tinput_mt_report_pointer_emulation(data->input_dev,\n\t\t\t\t\t  data->t19_num_keys);\n\tinput_sync(data->input_dev);\n}\n\nstatic void mxt_proc_t9_message(struct mxt_data *data, u8 *message)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct input_dev *input_dev = data->input_dev;\n\tint id;\n\tu8 status;\n\tint x;\n\tint y;\n\tint area;\n\tint amplitude;\n\n\tid = message[0] - data->T9_reportid_min;\n\tstatus = message[1];\n\tx = (message[2] << 4) | ((message[4] >> 4) & 0xf);\n\ty = (message[3] << 4) | ((message[4] & 0xf));\n\n\t \n\tif (data->max_x < 1024)\n\t\tx >>= 2;\n\tif (data->max_y < 1024)\n\t\ty >>= 2;\n\n\tarea = message[5];\n\tamplitude = message[6];\n\n\tdev_dbg(dev,\n\t\t\"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u\\n\",\n\t\tid,\n\t\t(status & MXT_T9_DETECT) ? 'D' : '.',\n\t\t(status & MXT_T9_PRESS) ? 'P' : '.',\n\t\t(status & MXT_T9_RELEASE) ? 'R' : '.',\n\t\t(status & MXT_T9_MOVE) ? 'M' : '.',\n\t\t(status & MXT_T9_VECTOR) ? 'V' : '.',\n\t\t(status & MXT_T9_AMP) ? 'A' : '.',\n\t\t(status & MXT_T9_SUPPRESS) ? 'S' : '.',\n\t\t(status & MXT_T9_UNGRIP) ? 'U' : '.',\n\t\tx, y, area, amplitude);\n\n\tinput_mt_slot(input_dev, id);\n\n\tif (status & MXT_T9_DETECT) {\n\t\t \n\t\tif (status & MXT_T9_RELEASE) {\n\t\t\tinput_mt_report_slot_inactive(input_dev);\n\t\t\tmxt_input_sync(data);\n\t\t}\n\n\t\t \n\t\tif (!amplitude)\n\t\t\tamplitude = MXT_PRESSURE_DEFAULT;\n\n\t\t \n\t\tinput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 1);\n\t\tinput_report_abs(input_dev, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(input_dev, ABS_MT_PRESSURE, amplitude);\n\t\tinput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, area);\n\t} else {\n\t\t \n\t\tinput_mt_report_slot_inactive(input_dev);\n\t}\n\n\tdata->update_input = true;\n}\n\nstatic void mxt_proc_t15_messages(struct mxt_data *data, u8 *message)\n{\n\tstruct input_dev *input_dev = data->input_dev;\n\tunsigned long keystates = get_unaligned_le32(&message[2]);\n\tint key;\n\n\tfor (key = 0; key < data->t15_num_keys; key++)\n\t\tinput_report_key(input_dev, data->t15_keymap[key],\n\t\t\t\t keystates & BIT(key));\n\n\tdata->update_input = true;\n}\n\nstatic void mxt_proc_t97_messages(struct mxt_data *data, u8 *message)\n{\n\tmxt_proc_t15_messages(data, message);\n}\n\nstatic void mxt_proc_t100_message(struct mxt_data *data, u8 *message)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct input_dev *input_dev = data->input_dev;\n\tint id;\n\tu8 status;\n\tu8 type = 0;\n\tu16 x;\n\tu16 y;\n\tint distance = 0;\n\tint tool = 0;\n\tu8 major = 0;\n\tu8 pressure = 0;\n\tu8 orientation = 0;\n\n\tid = message[0] - data->T100_reportid_min - 2;\n\n\t \n\tif (id < 0)\n\t\treturn;\n\n\tstatus = message[1];\n\tx = get_unaligned_le16(&message[2]);\n\ty = get_unaligned_le16(&message[4]);\n\n\tif (status & MXT_T100_DETECT) {\n\t\ttype = (status & MXT_T100_TYPE_MASK) >> 4;\n\n\t\tswitch (type) {\n\t\tcase MXT_T100_TYPE_HOVERING_FINGER:\n\t\t\ttool = MT_TOOL_FINGER;\n\t\t\tdistance = MXT_DISTANCE_HOVERING;\n\n\t\t\tif (data->t100_aux_vect)\n\t\t\t\torientation = message[data->t100_aux_vect];\n\n\t\t\tbreak;\n\n\t\tcase MXT_T100_TYPE_FINGER:\n\t\tcase MXT_T100_TYPE_GLOVE:\n\t\t\ttool = MT_TOOL_FINGER;\n\t\t\tdistance = MXT_DISTANCE_ACTIVE_TOUCH;\n\n\t\t\tif (data->t100_aux_area)\n\t\t\t\tmajor = message[data->t100_aux_area];\n\n\t\t\tif (data->t100_aux_ampl)\n\t\t\t\tpressure = message[data->t100_aux_ampl];\n\n\t\t\tif (data->t100_aux_vect)\n\t\t\t\torientation = message[data->t100_aux_vect];\n\n\t\t\tbreak;\n\n\t\tcase MXT_T100_TYPE_PASSIVE_STYLUS:\n\t\t\ttool = MT_TOOL_PEN;\n\n\t\t\t \n\t\t\tmajor = MXT_TOUCH_MAJOR_DEFAULT;\n\n\t\t\tif (data->t100_aux_ampl)\n\t\t\t\tpressure = message[data->t100_aux_ampl];\n\n\t\t\tbreak;\n\n\t\tcase MXT_T100_TYPE_LARGE_TOUCH:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"Unexpected T100 type\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (!pressure && type != MXT_T100_TYPE_HOVERING_FINGER)\n\t\tpressure = MXT_PRESSURE_DEFAULT;\n\n\tinput_mt_slot(input_dev, id);\n\n\tif (status & MXT_T100_DETECT) {\n\t\tdev_dbg(dev, \"[%u] type:%u x:%u y:%u a:%02X p:%02X v:%02X\\n\",\n\t\t\tid, type, x, y, major, pressure, orientation);\n\n\t\tinput_mt_report_slot_state(input_dev, tool, 1);\n\t\tinput_report_abs(input_dev, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, major);\n\t\tinput_report_abs(input_dev, ABS_MT_PRESSURE, pressure);\n\t\tinput_report_abs(input_dev, ABS_MT_DISTANCE, distance);\n\t\tinput_report_abs(input_dev, ABS_MT_ORIENTATION, orientation);\n\t} else {\n\t\tdev_dbg(dev, \"[%u] release\\n\", id);\n\n\t\t \n\t\tinput_mt_report_slot_inactive(input_dev);\n\t}\n\n\tdata->update_input = true;\n}\n\nstatic int mxt_proc_message(struct mxt_data *data, u8 *message)\n{\n\tu8 report_id = message[0];\n\n\tif (report_id == MXT_RPTID_NOMSG)\n\t\treturn 0;\n\n\tif (report_id == data->T6_reportid) {\n\t\tmxt_proc_t6_messages(data, message);\n\t} else if (!data->input_dev) {\n\t\t \n\t\tmxt_dump_message(data, message);\n\t} else if (report_id >= data->T9_reportid_min &&\n\t\t   report_id <= data->T9_reportid_max) {\n\t\tmxt_proc_t9_message(data, message);\n\t} else if (report_id >= data->T15_reportid_min &&\n\t\t   report_id <= data->T15_reportid_max) {\n\t\tmxt_proc_t15_messages(data, message);\n\t} else if (report_id >= data->T97_reportid_min &&\n\t\t   report_id <= data->T97_reportid_max) {\n\t\tmxt_proc_t97_messages(data, message);\n\t} else if (report_id >= data->T100_reportid_min &&\n\t\t   report_id <= data->T100_reportid_max) {\n\t\tmxt_proc_t100_message(data, message);\n\t} else if (report_id == data->T19_reportid) {\n\t\tmxt_input_button(data, message);\n\t\tdata->update_input = true;\n\t} else {\n\t\tmxt_dump_message(data, message);\n\t}\n\n\treturn 1;\n}\n\nstatic int mxt_read_and_process_messages(struct mxt_data *data, u8 count)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\tint i;\n\tu8 num_valid = 0;\n\n\t \n\tif (count > data->max_reportid)\n\t\treturn -EINVAL;\n\n\t \n\tret = __mxt_read_reg(data->client, data->T5_address,\n\t\t\t\tdata->T5_msg_size * count, data->msg_buf);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read %u messages (%d)\\n\", count, ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0;  i < count; i++) {\n\t\tret = mxt_proc_message(data,\n\t\t\tdata->msg_buf + data->T5_msg_size * i);\n\n\t\tif (ret == 1)\n\t\t\tnum_valid++;\n\t}\n\n\t \n\treturn num_valid;\n}\n\nstatic irqreturn_t mxt_process_messages_t44(struct mxt_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret;\n\tu8 count, num_left;\n\n\t \n\tret = __mxt_read_reg(data->client, data->T44_address,\n\t\tdata->T5_msg_size + 1, data->msg_buf);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read T44 and T5 (%d)\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tcount = data->msg_buf[0];\n\n\t \n\tif (count == 0)\n\t\treturn IRQ_NONE;\n\n\tif (count > data->max_reportid) {\n\t\tdev_warn(dev, \"T44 count %d exceeded max report id\\n\", count);\n\t\tcount = data->max_reportid;\n\t}\n\n\t \n\tret = mxt_proc_message(data, data->msg_buf + 1);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Unexpected invalid message\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tnum_left = count - 1;\n\n\t \n\tif (num_left) {\n\t\tret = mxt_read_and_process_messages(data, num_left);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\telse if (ret != num_left)\n\t\t\tdev_warn(dev, \"Unexpected invalid message\\n\");\n\t}\n\nend:\n\tif (data->update_input) {\n\t\tmxt_input_sync(data);\n\t\tdata->update_input = false;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxt_process_messages_until_invalid(struct mxt_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint count, read;\n\tu8 tries = 2;\n\n\tcount = data->max_reportid;\n\n\t \n\tdo {\n\t\tread = mxt_read_and_process_messages(data, count);\n\t\tif (read < count)\n\t\t\treturn 0;\n\t} while (--tries);\n\n\tif (data->update_input) {\n\t\tmxt_input_sync(data);\n\t\tdata->update_input = false;\n\t}\n\n\tdev_err(dev, \"CHG pin isn't cleared\\n\");\n\treturn -EBUSY;\n}\n\nstatic irqreturn_t mxt_process_messages(struct mxt_data *data)\n{\n\tint total_handled, num_handled;\n\tu8 count = data->last_message_count;\n\n\tif (count < 1 || count > data->max_reportid)\n\t\tcount = 1;\n\n\t \n\ttotal_handled = mxt_read_and_process_messages(data, count + 1);\n\tif (total_handled < 0)\n\t\treturn IRQ_NONE;\n\t \n\telse if (total_handled <= count)\n\t\tgoto update_count;\n\n\t \n\tdo {\n\t\tnum_handled = mxt_read_and_process_messages(data, 2);\n\t\tif (num_handled < 0)\n\t\t\treturn IRQ_NONE;\n\n\t\ttotal_handled += num_handled;\n\n\t\tif (num_handled < 2)\n\t\t\tbreak;\n\t} while (total_handled < data->num_touchids);\n\nupdate_count:\n\tdata->last_message_count = total_handled;\n\n\tif (data->update_input) {\n\t\tmxt_input_sync(data);\n\t\tdata->update_input = false;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mxt_interrupt(int irq, void *dev_id)\n{\n\tstruct mxt_data *data = dev_id;\n\n\tif (data->in_bootloader) {\n\t\t \n\t\tcomplete(&data->bl_completion);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!data->object_table)\n\t\treturn IRQ_HANDLED;\n\n\tif (data->T44_address) {\n\t\treturn mxt_process_messages_t44(data);\n\t} else {\n\t\treturn mxt_process_messages(data);\n\t}\n}\n\nstatic int mxt_t6_command(struct mxt_data *data, u16 cmd_offset,\n\t\t\t  u8 value, bool wait)\n{\n\tu16 reg;\n\tu8 command_register;\n\tint timeout_counter = 0;\n\tint ret;\n\n\treg = data->T6_address + cmd_offset;\n\n\tret = mxt_write_reg(data->client, reg, value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait)\n\t\treturn 0;\n\n\tdo {\n\t\tmsleep(20);\n\t\tret = __mxt_read_reg(data->client, reg, 1, &command_register);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (command_register != 0 && timeout_counter++ <= 100);\n\n\tif (timeout_counter > 100) {\n\t\tdev_err(&data->client->dev, \"Command failed!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_acquire_irq(struct mxt_data *data)\n{\n\tint error;\n\n\tenable_irq(data->irq);\n\n\tif (data->use_retrigen_workaround) {\n\t\terror = mxt_process_messages_until_invalid(data);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_soft_reset(struct mxt_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint ret = 0;\n\n\tdev_info(dev, \"Resetting device\\n\");\n\n\tdisable_irq(data->irq);\n\n\treinit_completion(&data->reset_completion);\n\n\tret = mxt_t6_command(data, MXT_COMMAND_RESET, MXT_RESET_VALUE, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(MXT_RESET_INVALID_CHG);\n\n\tmxt_acquire_irq(data);\n\n\tret = mxt_wait_for_completion(data, &data->reset_completion,\n\t\t\t\t      MXT_RESET_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void mxt_update_crc(struct mxt_data *data, u8 cmd, u8 value)\n{\n\t \n\tdata->config_crc = 0;\n\treinit_completion(&data->crc_completion);\n\n\tmxt_t6_command(data, cmd, value, true);\n\n\t \n\tmxt_wait_for_completion(data, &data->crc_completion, MXT_CRC_TIMEOUT);\n}\n\nstatic void mxt_calc_crc24(u32 *crc, u8 firstbyte, u8 secondbyte)\n{\n\tstatic const unsigned int crcpoly = 0x80001B;\n\tu32 result;\n\tu32 data_word;\n\n\tdata_word = (secondbyte << 8) | firstbyte;\n\tresult = ((*crc << 1) ^ data_word);\n\n\tif (result & 0x1000000)\n\t\tresult ^= crcpoly;\n\n\t*crc = result;\n}\n\nstatic u32 mxt_calculate_crc(u8 *base, off_t start_off, off_t end_off)\n{\n\tu32 crc = 0;\n\tu8 *ptr = base + start_off;\n\tu8 *last_val = base + end_off - 1;\n\n\tif (end_off < start_off)\n\t\treturn -EINVAL;\n\n\twhile (ptr < last_val) {\n\t\tmxt_calc_crc24(&crc, *ptr, *(ptr + 1));\n\t\tptr += 2;\n\t}\n\n\t \n\tif (ptr == last_val)\n\t\tmxt_calc_crc24(&crc, *ptr, 0);\n\n\t \n\tcrc &= 0x00FFFFFF;\n\n\treturn crc;\n}\n\nstatic int mxt_check_retrigen(struct mxt_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint error;\n\tint val;\n\tstruct irq_data *irqd;\n\n\tdata->use_retrigen_workaround = false;\n\n\tirqd = irq_get_irq_data(data->irq);\n\tif (!irqd)\n\t\treturn -EINVAL;\n\n\tif (irqd_is_level_type(irqd))\n\t\treturn 0;\n\n\tif (data->T18_address) {\n\t\terror = __mxt_read_reg(client,\n\t\t\t\t       data->T18_address + MXT_COMMS_CTRL,\n\t\t\t\t       1, &val);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (val & MXT_COMMS_RETRIGEN)\n\t\t\treturn 0;\n\t}\n\n\tdev_warn(&client->dev, \"Enabling RETRIGEN workaround\\n\");\n\tdata->use_retrigen_workaround = true;\n\treturn 0;\n}\n\nstatic int mxt_prepare_cfg_mem(struct mxt_data *data, struct mxt_cfg *cfg)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct mxt_object *object;\n\tunsigned int type, instance, size, byte_offset;\n\tint offset;\n\tint ret;\n\tint i;\n\tu16 reg;\n\tu8 val;\n\n\twhile (cfg->raw_pos < cfg->raw_size) {\n\t\t \n\t\tret = sscanf(cfg->raw + cfg->raw_pos, \"%x %x %x%n\",\n\t\t\t     &type, &instance, &size, &offset);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (ret != 3) {\n\t\t\tdev_err(dev, \"Bad format: failed to parse object\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->raw_pos += offset;\n\n\t\tobject = mxt_get_object(data, type);\n\t\tif (!object) {\n\t\t\t \n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tret = sscanf(cfg->raw + cfg->raw_pos, \"%hhx%n\",\n\t\t\t\t\t     &val, &offset);\n\t\t\t\tif (ret != 1) {\n\t\t\t\t\tdev_err(dev, \"Bad format in T%d at %d\\n\",\n\t\t\t\t\t\ttype, i);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tcfg->raw_pos += offset;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (size > mxt_obj_size(object)) {\n\t\t\t \n\t\t\tdev_warn(dev, \"Discarding %zu byte(s) in T%u\\n\",\n\t\t\t\t size - mxt_obj_size(object), type);\n\t\t} else if (mxt_obj_size(object) > size) {\n\t\t\t \n\t\t\tdev_warn(dev, \"Zeroing %zu byte(s) in T%d\\n\",\n\t\t\t\t mxt_obj_size(object) - size, type);\n\t\t}\n\n\t\tif (instance >= mxt_obj_instances(object)) {\n\t\t\tdev_err(dev, \"Object instances exceeded!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treg = object->start_address + mxt_obj_size(object) * instance;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tret = sscanf(cfg->raw + cfg->raw_pos, \"%hhx%n\",\n\t\t\t\t     &val,\n\t\t\t\t     &offset);\n\t\t\tif (ret != 1) {\n\t\t\t\tdev_err(dev, \"Bad format in T%d at %d\\n\",\n\t\t\t\t\ttype, i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcfg->raw_pos += offset;\n\n\t\t\tif (i > mxt_obj_size(object))\n\t\t\t\tcontinue;\n\n\t\t\tbyte_offset = reg + i - cfg->start_ofs;\n\n\t\t\tif (byte_offset >= 0 && byte_offset < cfg->mem_size) {\n\t\t\t\t*(cfg->mem + byte_offset) = val;\n\t\t\t} else {\n\t\t\t\tdev_err(dev, \"Bad object: reg:%d, T%d, ofs=%d\\n\",\n\t\t\t\t\treg, object->type, byte_offset);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_upload_cfg_mem(struct mxt_data *data, struct mxt_cfg *cfg)\n{\n\tunsigned int byte_offset = 0;\n\tint error;\n\n\t \n\twhile (byte_offset < cfg->mem_size) {\n\t\tunsigned int size = cfg->mem_size - byte_offset;\n\n\t\tif (size > MXT_MAX_BLOCK_WRITE)\n\t\t\tsize = MXT_MAX_BLOCK_WRITE;\n\n\t\terror = __mxt_write_reg(data->client,\n\t\t\t\t\tcfg->start_ofs + byte_offset,\n\t\t\t\t\tsize, cfg->mem + byte_offset);\n\t\tif (error) {\n\t\t\tdev_err(&data->client->dev,\n\t\t\t\t\"Config write error, ret=%d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tbyte_offset += size;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_init_t7_power_cfg(struct mxt_data *data);\n\n \nstatic int mxt_update_cfg(struct mxt_data *data, const struct firmware *fw)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct mxt_cfg cfg;\n\tint ret;\n\tint offset;\n\tint i;\n\tu32 info_crc, config_crc, calculated_crc;\n\tu16 crc_start = 0;\n\n\t \n\tcfg.raw = kmemdup_nul(fw->data, fw->size, GFP_KERNEL);\n\tif (!cfg.raw)\n\t\treturn -ENOMEM;\n\n\tcfg.raw_size = fw->size;\n\n\tmxt_update_crc(data, MXT_COMMAND_REPORTALL, 1);\n\n\tif (strncmp(cfg.raw, MXT_CFG_MAGIC, strlen(MXT_CFG_MAGIC))) {\n\t\tdev_err(dev, \"Unrecognised config file\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_raw;\n\t}\n\n\tcfg.raw_pos = strlen(MXT_CFG_MAGIC);\n\n\t \n\tfor (i = 0; i < sizeof(struct mxt_info); i++) {\n\t\tret = sscanf(cfg.raw + cfg.raw_pos, \"%hhx%n\",\n\t\t\t     (unsigned char *)&cfg.info + i,\n\t\t\t     &offset);\n\t\tif (ret != 1) {\n\t\t\tdev_err(dev, \"Bad format\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto release_raw;\n\t\t}\n\n\t\tcfg.raw_pos += offset;\n\t}\n\n\tif (cfg.info.family_id != data->info->family_id) {\n\t\tdev_err(dev, \"Family ID mismatch!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_raw;\n\t}\n\n\tif (cfg.info.variant_id != data->info->variant_id) {\n\t\tdev_err(dev, \"Variant ID mismatch!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_raw;\n\t}\n\n\t \n\tret = sscanf(cfg.raw + cfg.raw_pos, \"%x%n\", &info_crc, &offset);\n\tif (ret != 1) {\n\t\tdev_err(dev, \"Bad format: failed to parse Info CRC\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_raw;\n\t}\n\tcfg.raw_pos += offset;\n\n\tret = sscanf(cfg.raw + cfg.raw_pos, \"%x%n\", &config_crc, &offset);\n\tif (ret != 1) {\n\t\tdev_err(dev, \"Bad format: failed to parse Config CRC\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_raw;\n\t}\n\tcfg.raw_pos += offset;\n\n\t \n\tif (info_crc == data->info_crc) {\n\t\tif (config_crc == 0 || data->config_crc == 0) {\n\t\t\tdev_info(dev, \"CRC zero, attempting to apply config\\n\");\n\t\t} else if (config_crc == data->config_crc) {\n\t\t\tdev_dbg(dev, \"Config CRC 0x%06X: OK\\n\",\n\t\t\t\t data->config_crc);\n\t\t\tret = 0;\n\t\t\tgoto release_raw;\n\t\t} else {\n\t\t\tdev_info(dev, \"Config CRC 0x%06X: does not match file 0x%06X\\n\",\n\t\t\t\t data->config_crc, config_crc);\n\t\t}\n\t} else {\n\t\tdev_warn(dev,\n\t\t\t \"Warning: Info CRC error - device=0x%06X file=0x%06X\\n\",\n\t\t\t data->info_crc, info_crc);\n\t}\n\n\t \n\tcfg.start_ofs = MXT_OBJECT_START +\n\t\t\tdata->info->object_num * sizeof(struct mxt_object) +\n\t\t\tMXT_INFO_CHECKSUM_SIZE;\n\tcfg.mem_size = data->mem_size - cfg.start_ofs;\n\tcfg.mem = kzalloc(cfg.mem_size, GFP_KERNEL);\n\tif (!cfg.mem) {\n\t\tret = -ENOMEM;\n\t\tgoto release_raw;\n\t}\n\n\tret = mxt_prepare_cfg_mem(data, &cfg);\n\tif (ret)\n\t\tgoto release_mem;\n\n\t \n\tif (data->T71_address)\n\t\tcrc_start = data->T71_address;\n\telse if (data->T7_address)\n\t\tcrc_start = data->T7_address;\n\telse\n\t\tdev_warn(dev, \"Could not find CRC start\\n\");\n\n\tif (crc_start > cfg.start_ofs) {\n\t\tcalculated_crc = mxt_calculate_crc(cfg.mem,\n\t\t\t\t\t\t   crc_start - cfg.start_ofs,\n\t\t\t\t\t\t   cfg.mem_size);\n\n\t\tif (config_crc > 0 && config_crc != calculated_crc)\n\t\t\tdev_warn(dev, \"Config CRC in file inconsistent, calculated=%06X, file=%06X\\n\",\n\t\t\t\t calculated_crc, config_crc);\n\t}\n\n\tret = mxt_upload_cfg_mem(data, &cfg);\n\tif (ret)\n\t\tgoto release_mem;\n\n\tmxt_update_crc(data, MXT_COMMAND_BACKUPNV, MXT_BACKUP_VALUE);\n\n\tret = mxt_check_retrigen(data);\n\tif (ret)\n\t\tgoto release_mem;\n\n\tret = mxt_soft_reset(data);\n\tif (ret)\n\t\tgoto release_mem;\n\n\tdev_info(dev, \"Config successfully updated\\n\");\n\n\t \n\tmxt_init_t7_power_cfg(data);\n\nrelease_mem:\n\tkfree(cfg.mem);\nrelease_raw:\n\tkfree(cfg.raw);\n\treturn ret;\n}\n\nstatic void mxt_free_input_device(struct mxt_data *data)\n{\n\tif (data->input_dev) {\n\t\tinput_unregister_device(data->input_dev);\n\t\tdata->input_dev = NULL;\n\t}\n}\n\nstatic void mxt_free_object_table(struct mxt_data *data)\n{\n#ifdef CONFIG_TOUCHSCREEN_ATMEL_MXT_T37\n\tvideo_unregister_device(&data->dbg.vdev);\n\tv4l2_device_unregister(&data->dbg.v4l2);\n#endif\n\tdata->object_table = NULL;\n\tdata->info = NULL;\n\tkfree(data->raw_info_block);\n\tdata->raw_info_block = NULL;\n\tkfree(data->msg_buf);\n\tdata->msg_buf = NULL;\n\tdata->T5_address = 0;\n\tdata->T5_msg_size = 0;\n\tdata->T6_reportid = 0;\n\tdata->T7_address = 0;\n\tdata->T71_address = 0;\n\tdata->T9_reportid_min = 0;\n\tdata->T9_reportid_max = 0;\n\tdata->T15_reportid_min = 0;\n\tdata->T15_reportid_max = 0;\n\tdata->T18_address = 0;\n\tdata->T19_reportid = 0;\n\tdata->T44_address = 0;\n\tdata->T97_reportid_min = 0;\n\tdata->T97_reportid_max = 0;\n\tdata->T100_reportid_min = 0;\n\tdata->T100_reportid_max = 0;\n\tdata->max_reportid = 0;\n}\n\nstatic int mxt_parse_object_table(struct mxt_data *data,\n\t\t\t\t  struct mxt_object *object_table)\n{\n\tstruct i2c_client *client = data->client;\n\tint i;\n\tu8 reportid;\n\tu16 end_address;\n\n\t \n\treportid = 1;\n\tdata->mem_size = 0;\n\tfor (i = 0; i < data->info->object_num; i++) {\n\t\tstruct mxt_object *object = object_table + i;\n\t\tu8 min_id, max_id;\n\n\t\tle16_to_cpus(&object->start_address);\n\n\t\tif (object->num_report_ids) {\n\t\t\tmin_id = reportid;\n\t\t\treportid += object->num_report_ids *\n\t\t\t\t\tmxt_obj_instances(object);\n\t\t\tmax_id = reportid - 1;\n\t\t} else {\n\t\t\tmin_id = 0;\n\t\t\tmax_id = 0;\n\t\t}\n\n\t\tdev_dbg(&data->client->dev,\n\t\t\t\"T%u Start:%u Size:%zu Instances:%zu Report IDs:%u-%u\\n\",\n\t\t\tobject->type, object->start_address,\n\t\t\tmxt_obj_size(object), mxt_obj_instances(object),\n\t\t\tmin_id, max_id);\n\n\t\tswitch (object->type) {\n\t\tcase MXT_GEN_MESSAGE_T5:\n\t\t\tif (data->info->family_id == 0x80 &&\n\t\t\t    data->info->version < 0x20) {\n\t\t\t\t \n\t\t\t\tdata->T5_msg_size = mxt_obj_size(object);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdata->T5_msg_size = mxt_obj_size(object) - 1;\n\t\t\t}\n\t\t\tdata->T5_address = object->start_address;\n\t\t\tbreak;\n\t\tcase MXT_GEN_COMMAND_T6:\n\t\t\tdata->T6_reportid = min_id;\n\t\t\tdata->T6_address = object->start_address;\n\t\t\tbreak;\n\t\tcase MXT_GEN_POWER_T7:\n\t\t\tdata->T7_address = object->start_address;\n\t\t\tbreak;\n\t\tcase MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71:\n\t\t\tdata->T71_address = object->start_address;\n\t\t\tbreak;\n\t\tcase MXT_TOUCH_MULTI_T9:\n\t\t\tdata->multitouch = MXT_TOUCH_MULTI_T9;\n\t\t\t \n\t\t\tdata->T9_reportid_min = min_id;\n\t\t\tdata->T9_reportid_max = min_id +\n\t\t\t\t\t\tobject->num_report_ids - 1;\n\t\t\tdata->num_touchids = object->num_report_ids;\n\t\t\tbreak;\n\t\tcase MXT_TOUCH_KEYARRAY_T15:\n\t\t\tdata->T15_reportid_min = min_id;\n\t\t\tdata->T15_reportid_max = max_id;\n\t\t\tbreak;\n\t\tcase MXT_SPT_COMMSCONFIG_T18:\n\t\t\tdata->T18_address = object->start_address;\n\t\t\tbreak;\n\t\tcase MXT_SPT_MESSAGECOUNT_T44:\n\t\t\tdata->T44_address = object->start_address;\n\t\t\tbreak;\n\t\tcase MXT_SPT_GPIOPWM_T19:\n\t\t\tdata->T19_reportid = min_id;\n\t\t\tbreak;\n\t\tcase MXT_TOUCH_PTC_KEYS_T97:\n\t\t\tdata->T97_reportid_min = min_id;\n\t\t\tdata->T97_reportid_max = max_id;\n\t\t\tbreak;\n\t\tcase MXT_TOUCH_MULTITOUCHSCREEN_T100:\n\t\t\tdata->multitouch = MXT_TOUCH_MULTITOUCHSCREEN_T100;\n\t\t\tdata->T100_reportid_min = min_id;\n\t\t\tdata->T100_reportid_max = max_id;\n\t\t\t \n\t\t\tdata->num_touchids = object->num_report_ids - 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tend_address = object->start_address\n\t\t\t+ mxt_obj_size(object) * mxt_obj_instances(object) - 1;\n\n\t\tif (end_address >= data->mem_size)\n\t\t\tdata->mem_size = end_address + 1;\n\t}\n\n\t \n\tdata->max_reportid = reportid;\n\n\t \n\tif (data->T44_address && (data->T5_address != data->T44_address + 1)) {\n\t\tdev_err(&client->dev, \"Invalid T44 position\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->msg_buf = kcalloc(data->max_reportid,\n\t\t\t\tdata->T5_msg_size, GFP_KERNEL);\n\tif (!data->msg_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int mxt_read_info_block(struct mxt_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint error;\n\tsize_t size;\n\tvoid *id_buf, *buf;\n\tuint8_t num_objects;\n\tu32 calculated_crc;\n\tu8 *crc_ptr;\n\n\t \n\tif (data->raw_info_block)\n\t\tmxt_free_object_table(data);\n\n\t \n\tsize = sizeof(struct mxt_info);\n\tid_buf = kzalloc(size, GFP_KERNEL);\n\tif (!id_buf)\n\t\treturn -ENOMEM;\n\n\terror = __mxt_read_reg(client, 0, size, id_buf);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\t \n\tnum_objects = ((struct mxt_info *)id_buf)->object_num;\n\tsize += (num_objects * sizeof(struct mxt_object))\n\t\t+ MXT_INFO_CHECKSUM_SIZE;\n\n\tbuf = krealloc(id_buf, size, GFP_KERNEL);\n\tif (!buf) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\tid_buf = buf;\n\n\t \n\terror = __mxt_read_reg(client, MXT_OBJECT_START,\n\t\t\t       size - MXT_OBJECT_START,\n\t\t\t       id_buf + MXT_OBJECT_START);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\t \n\tcrc_ptr = id_buf + size - MXT_INFO_CHECKSUM_SIZE;\n\tdata->info_crc = crc_ptr[0] | (crc_ptr[1] << 8) | (crc_ptr[2] << 16);\n\n\tcalculated_crc = mxt_calculate_crc(id_buf, 0,\n\t\t\t\t\t   size - MXT_INFO_CHECKSUM_SIZE);\n\n\t \n\tif ((data->info_crc == 0) || (data->info_crc != calculated_crc)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Info Block CRC error calculated=0x%06X read=0x%06X\\n\",\n\t\t\tcalculated_crc, data->info_crc);\n\t\terror = -EIO;\n\t\tgoto err_free_mem;\n\t}\n\n\tdata->raw_info_block = id_buf;\n\tdata->info = (struct mxt_info *)id_buf;\n\n\tdev_info(&client->dev,\n\t\t \"Family: %u Variant: %u Firmware V%u.%u.%02X Objects: %u\\n\",\n\t\t data->info->family_id, data->info->variant_id,\n\t\t data->info->version >> 4, data->info->version & 0xf,\n\t\t data->info->build, data->info->object_num);\n\n\t \n\terror = mxt_parse_object_table(data, id_buf + MXT_OBJECT_START);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Error %d parsing object table\\n\", error);\n\t\tmxt_free_object_table(data);\n\t\treturn error;\n\t}\n\n\tdata->object_table = (struct mxt_object *)(id_buf + MXT_OBJECT_START);\n\n\treturn 0;\n\nerr_free_mem:\n\tkfree(id_buf);\n\treturn error;\n}\n\nstatic int mxt_read_t9_resolution(struct mxt_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint error;\n\tstruct t9_range range;\n\tunsigned char orient;\n\tstruct mxt_object *object;\n\n\tobject = mxt_get_object(data, MXT_TOUCH_MULTI_T9);\n\tif (!object)\n\t\treturn -EINVAL;\n\n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T9_XSIZE,\n\t\t\t       sizeof(data->xsize), &data->xsize);\n\tif (error)\n\t\treturn error;\n\n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T9_YSIZE,\n\t\t\t       sizeof(data->ysize), &data->ysize);\n\tif (error)\n\t\treturn error;\n\n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T9_RANGE,\n\t\t\t       sizeof(range), &range);\n\tif (error)\n\t\treturn error;\n\n\tdata->max_x = get_unaligned_le16(&range.x);\n\tdata->max_y = get_unaligned_le16(&range.y);\n\n\terror =  __mxt_read_reg(client,\n\t\t\t\tobject->start_address + MXT_T9_ORIENT,\n\t\t\t\t1, &orient);\n\tif (error)\n\t\treturn error;\n\n\tdata->xy_switch = orient & MXT_T9_ORIENT_SWITCH;\n\tdata->invertx = orient & MXT_T9_ORIENT_INVERTX;\n\tdata->inverty = orient & MXT_T9_ORIENT_INVERTY;\n\n\treturn 0;\n}\n\nstatic int mxt_read_t100_config(struct mxt_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint error;\n\tstruct mxt_object *object;\n\tu16 range_x, range_y;\n\tu8 cfg, tchaux;\n\tu8 aux;\n\n\tobject = mxt_get_object(data, MXT_TOUCH_MULTITOUCHSCREEN_T100);\n\tif (!object)\n\t\treturn -EINVAL;\n\n\t \n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T100_XRANGE,\n\t\t\t       sizeof(range_x), &range_x);\n\tif (error)\n\t\treturn error;\n\n\tdata->max_x = get_unaligned_le16(&range_x);\n\n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T100_YRANGE,\n\t\t\t       sizeof(range_y), &range_y);\n\tif (error)\n\t\treturn error;\n\n\tdata->max_y = get_unaligned_le16(&range_y);\n\n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T100_XSIZE,\n\t\t\t       sizeof(data->xsize), &data->xsize);\n\tif (error)\n\t\treturn error;\n\n\terror = __mxt_read_reg(client,\n\t\t\t       object->start_address + MXT_T100_YSIZE,\n\t\t\t       sizeof(data->ysize), &data->ysize);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror =  __mxt_read_reg(client,\n\t\t\t\tobject->start_address + MXT_T100_CFG1,\n\t\t\t\t1, &cfg);\n\tif (error)\n\t\treturn error;\n\n\tdata->xy_switch = cfg & MXT_T100_CFG_SWITCHXY;\n\tdata->invertx = cfg & MXT_T100_CFG_INVERTX;\n\tdata->inverty = cfg & MXT_T100_CFG_INVERTY;\n\n\t \n\terror =  __mxt_read_reg(client,\n\t\t\t\tobject->start_address + MXT_T100_TCHAUX,\n\t\t\t\t1, &tchaux);\n\tif (error)\n\t\treturn error;\n\n\taux = 6;\n\n\tif (tchaux & MXT_T100_TCHAUX_VECT)\n\t\tdata->t100_aux_vect = aux++;\n\n\tif (tchaux & MXT_T100_TCHAUX_AMPL)\n\t\tdata->t100_aux_ampl = aux++;\n\n\tif (tchaux & MXT_T100_TCHAUX_AREA)\n\t\tdata->t100_aux_area = aux++;\n\n\tdev_dbg(&client->dev,\n\t\t\"T100 aux mappings vect:%u ampl:%u area:%u\\n\",\n\t\tdata->t100_aux_vect, data->t100_aux_ampl, data->t100_aux_area);\n\n\treturn 0;\n}\n\nstatic int mxt_input_open(struct input_dev *dev);\nstatic void mxt_input_close(struct input_dev *dev);\n\nstatic void mxt_set_up_as_touchpad(struct input_dev *input_dev,\n\t\t\t\t   struct mxt_data *data)\n{\n\tint i;\n\n\tinput_dev->name = \"Atmel maXTouch Touchpad\";\n\n\t__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\n\n\tinput_abs_set_res(input_dev, ABS_X, MXT_PIXELS_PER_MM);\n\tinput_abs_set_res(input_dev, ABS_Y, MXT_PIXELS_PER_MM);\n\tinput_abs_set_res(input_dev, ABS_MT_POSITION_X,\n\t\t\t  MXT_PIXELS_PER_MM);\n\tinput_abs_set_res(input_dev, ABS_MT_POSITION_Y,\n\t\t\t  MXT_PIXELS_PER_MM);\n\n\tfor (i = 0; i < data->t19_num_keys; i++)\n\t\tif (data->t19_keymap[i] != KEY_RESERVED)\n\t\t\tinput_set_capability(input_dev, EV_KEY,\n\t\t\t\t\t     data->t19_keymap[i]);\n}\n\nstatic int mxt_initialize_input_device(struct mxt_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct input_dev *input_dev;\n\tint error;\n\tunsigned int num_mt_slots;\n\tunsigned int mt_flags = 0;\n\tint i;\n\n\tswitch (data->multitouch) {\n\tcase MXT_TOUCH_MULTI_T9:\n\t\tnum_mt_slots = data->T9_reportid_max - data->T9_reportid_min + 1;\n\t\terror = mxt_read_t9_resolution(data);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"Failed to initialize T9 resolution\\n\");\n\t\tbreak;\n\n\tcase MXT_TOUCH_MULTITOUCHSCREEN_T100:\n\t\tnum_mt_slots = data->num_touchids;\n\t\terror = mxt_read_t100_config(data);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"Failed to read T100 config\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid multitouch object\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data->max_x == 0)\n\t\tdata->max_x = 1023;\n\n\tif (data->max_y == 0)\n\t\tdata->max_y = 1023;\n\n\tif (data->xy_switch)\n\t\tswap(data->max_x, data->max_y);\n\n\tdev_info(dev, \"Touchscreen size X%uY%u\\n\", data->max_x, data->max_y);\n\n\t \n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = \"Atmel maXTouch Touchscreen\";\n\tinput_dev->phys = data->phys;\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->dev.parent = dev;\n\tinput_dev->open = mxt_input_open;\n\tinput_dev->close = mxt_input_close;\n\n\tinput_dev->keycode = data->t15_keymap;\n\tinput_dev->keycodemax = data->t15_num_keys;\n\tinput_dev->keycodesize = sizeof(data->t15_keymap[0]);\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_X, 0, data->max_x, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, data->max_y, 0, 0);\n\n\tif (data->multitouch == MXT_TOUCH_MULTI_T9 ||\n\t    (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&\n\t     data->t100_aux_ampl)) {\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 255, 0, 0);\n\t}\n\n\t \n\tif (data->t19_num_keys) {\n\t\tmxt_set_up_as_touchpad(input_dev, data);\n\t\tmt_flags |= INPUT_MT_POINTER;\n\t} else {\n\t\tmt_flags |= INPUT_MT_DIRECT;\n\t}\n\n\t \n\terror = input_mt_init_slots(input_dev, num_mt_slots, mt_flags);\n\tif (error) {\n\t\tdev_err(dev, \"Error %d initialising slots\\n\", error);\n\t\tgoto err_free_mem;\n\t}\n\n\tif (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100) {\n\t\tinput_set_abs_params(input_dev, ABS_MT_TOOL_TYPE,\n\t\t\t\t     0, MT_TOOL_MAX, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_DISTANCE,\n\t\t\t\t     MXT_DISTANCE_ACTIVE_TOUCH,\n\t\t\t\t     MXT_DISTANCE_HOVERING,\n\t\t\t\t     0, 0);\n\t}\n\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t     0, data->max_x, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t     0, data->max_y, 0, 0);\n\n\tif (data->multitouch == MXT_TOUCH_MULTI_T9 ||\n\t    (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&\n\t     data->t100_aux_area)) {\n\t\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t     0, MXT_MAX_AREA, 0, 0);\n\t}\n\n\tif (data->multitouch == MXT_TOUCH_MULTI_T9 ||\n\t    (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&\n\t     data->t100_aux_ampl)) {\n\t\tinput_set_abs_params(input_dev, ABS_MT_PRESSURE,\n\t\t\t\t     0, 255, 0, 0);\n\t}\n\n\tif (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&\n\t    data->t100_aux_vect) {\n\t\tinput_set_abs_params(input_dev, ABS_MT_ORIENTATION,\n\t\t\t\t     0, 255, 0, 0);\n\t}\n\n\tif (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&\n\t    data->t100_aux_vect) {\n\t\tinput_set_abs_params(input_dev, ABS_MT_ORIENTATION,\n\t\t\t\t     0, 255, 0, 0);\n\t}\n\n\t \n\tif (data->T15_reportid_min || data->T97_reportid_min) {\n\t\tfor (i = 0; i < data->t15_num_keys; i++)\n\t\t\tinput_set_capability(input_dev,\n\t\t\t\t\t     EV_KEY, data->t15_keymap[i]);\n\t}\n\n\tinput_set_drvdata(input_dev, data);\n\n\terror = input_register_device(input_dev);\n\tif (error) {\n\t\tdev_err(dev, \"Error %d registering input device\\n\", error);\n\t\tgoto err_free_mem;\n\t}\n\n\tdata->input_dev = input_dev;\n\n\treturn 0;\n\nerr_free_mem:\n\tinput_free_device(input_dev);\n\treturn error;\n}\n\nstatic int mxt_configure_objects(struct mxt_data *data,\n\t\t\t\t const struct firmware *cfg);\n\nstatic void mxt_config_cb(const struct firmware *cfg, void *ctx)\n{\n\tmxt_configure_objects(ctx, cfg);\n\trelease_firmware(cfg);\n}\n\nstatic int mxt_initialize(struct mxt_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint recovery_attempts = 0;\n\tint error;\n\n\twhile (1) {\n\t\terror = mxt_read_info_block(data);\n\t\tif (!error)\n\t\t\tbreak;\n\n\t\t \n\t\terror = mxt_probe_bootloader(data, false);\n\t\tif (error) {\n\t\t\tdev_info(&client->dev, \"Trying alternate bootloader address\\n\");\n\t\t\terror = mxt_probe_bootloader(data, true);\n\t\t\tif (error) {\n\t\t\t\t \n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (++recovery_attempts > 1) {\n\t\t\tdev_err(&client->dev, \"Could not recover from bootloader mode\\n\");\n\t\t\t \n\t\t\tdata->in_bootloader = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tmxt_send_bootloader_cmd(data, false);\n\t\tmsleep(MXT_FW_RESET_TIME);\n\t}\n\n\terror = mxt_check_retrigen(data);\n\tif (error)\n\t\treturn error;\n\n\terror = mxt_acquire_irq(data);\n\tif (error)\n\t\treturn error;\n\n\terror = request_firmware_nowait(THIS_MODULE, true, MXT_CFG_NAME,\n\t\t\t\t\t&client->dev, GFP_KERNEL, data,\n\t\t\t\t\tmxt_config_cb);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to invoke firmware loader: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_set_t7_power_cfg(struct mxt_data *data, u8 sleep)\n{\n\tstruct device *dev = &data->client->dev;\n\tint error;\n\tstruct t7_config *new_config;\n\tstruct t7_config deepsleep = { .active = 0, .idle = 0 };\n\n\tif (sleep == MXT_POWER_CFG_DEEPSLEEP)\n\t\tnew_config = &deepsleep;\n\telse\n\t\tnew_config = &data->t7_cfg;\n\n\terror = __mxt_write_reg(data->client, data->T7_address,\n\t\t\t\tsizeof(data->t7_cfg), new_config);\n\tif (error)\n\t\treturn error;\n\n\tdev_dbg(dev, \"Set T7 ACTV:%d IDLE:%d\\n\",\n\t\tnew_config->active, new_config->idle);\n\n\treturn 0;\n}\n\nstatic int mxt_init_t7_power_cfg(struct mxt_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint error;\n\tbool retry = false;\n\nrecheck:\n\terror = __mxt_read_reg(data->client, data->T7_address,\n\t\t\t\tsizeof(data->t7_cfg), &data->t7_cfg);\n\tif (error)\n\t\treturn error;\n\n\tif (data->t7_cfg.active == 0 || data->t7_cfg.idle == 0) {\n\t\tif (!retry) {\n\t\t\tdev_dbg(dev, \"T7 cfg zero, resetting\\n\");\n\t\t\tmxt_soft_reset(data);\n\t\t\tretry = true;\n\t\t\tgoto recheck;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"T7 cfg zero after reset, overriding\\n\");\n\t\t\tdata->t7_cfg.active = 20;\n\t\t\tdata->t7_cfg.idle = 100;\n\t\t\treturn mxt_set_t7_power_cfg(data, MXT_POWER_CFG_RUN);\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"Initialized power cfg: ACTV %d, IDLE %d\\n\",\n\t\tdata->t7_cfg.active, data->t7_cfg.idle);\n\treturn 0;\n}\n\n#ifdef CONFIG_TOUCHSCREEN_ATMEL_MXT_T37\nstatic const struct v4l2_file_operations mxt_video_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll,\n};\n\nstatic u16 mxt_get_debug_value(struct mxt_data *data, unsigned int x,\n\t\t\t       unsigned int y)\n{\n\tstruct mxt_info *info = data->info;\n\tstruct mxt_dbg *dbg = &data->dbg;\n\tunsigned int ofs, page;\n\tunsigned int col = 0;\n\tunsigned int col_width;\n\n\tif (info->family_id == MXT_FAMILY_1386) {\n\t\tcol_width = info->matrix_ysize / MXT1386_COLUMNS;\n\t\tcol = y / col_width;\n\t\ty = y % col_width;\n\t} else {\n\t\tcol_width = info->matrix_ysize;\n\t}\n\n\tofs = (y + (x * col_width)) * sizeof(u16);\n\tpage = ofs / MXT_DIAGNOSTIC_SIZE;\n\tofs %= MXT_DIAGNOSTIC_SIZE;\n\n\tif (info->family_id == MXT_FAMILY_1386)\n\t\tpage += col * MXT1386_PAGES_PER_COLUMN;\n\n\treturn get_unaligned_le16(&dbg->t37_buf[page].data[ofs]);\n}\n\nstatic int mxt_convert_debug_pages(struct mxt_data *data, u16 *outbuf)\n{\n\tstruct mxt_dbg *dbg = &data->dbg;\n\tunsigned int x = 0;\n\tunsigned int y = 0;\n\tunsigned int i, rx, ry;\n\n\tfor (i = 0; i < dbg->t37_nodes; i++) {\n\t\t \n\t\trx = data->xy_switch ? y : x;\n\t\try = data->xy_switch ? x : y;\n\t\trx = data->invertx ? (data->xsize - 1 - rx) : rx;\n\t\try = data->inverty ? (data->ysize - 1 - ry) : ry;\n\n\t\toutbuf[i] = mxt_get_debug_value(data, rx, ry);\n\n\t\t \n\t\tif (++x >= (data->xy_switch ? data->ysize : data->xsize)) {\n\t\t\tx = 0;\n\t\t\ty++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_read_diagnostic_debug(struct mxt_data *data, u8 mode,\n\t\t\t\t     u16 *outbuf)\n{\n\tstruct mxt_dbg *dbg = &data->dbg;\n\tint retries = 0;\n\tint page;\n\tint ret;\n\tu8 cmd = mode;\n\tstruct t37_debug *p;\n\tu8 cmd_poll;\n\n\tfor (page = 0; page < dbg->t37_pages; page++) {\n\t\tp = dbg->t37_buf + page;\n\n\t\tret = mxt_write_reg(data->client, dbg->diag_cmd_address,\n\t\t\t\t    cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tretries = 0;\n\t\tmsleep(20);\nwait_cmd:\n\t\t \n\t\tret = __mxt_read_reg(data->client, dbg->diag_cmd_address,\n\t\t\t\t     sizeof(cmd_poll), &cmd_poll);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (cmd_poll) {\n\t\t\tif (retries++ > 100)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmsleep(20);\n\t\t\tgoto wait_cmd;\n\t\t}\n\n\t\t \n\t\tret = __mxt_read_reg(data->client, dbg->t37_address,\n\t\t\t\t     sizeof(struct t37_debug), p);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (p->mode != mode || p->page != page) {\n\t\t\tdev_err(&data->client->dev, \"T37 page mismatch\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(&data->client->dev, \"%s page:%d retries:%d\\n\",\n\t\t\t__func__, page, retries);\n\n\t\t \n\t\tcmd = MXT_DIAGNOSTIC_PAGEUP;\n\t}\n\n\treturn mxt_convert_debug_pages(data, outbuf);\n}\n\nstatic int mxt_queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct mxt_data *data = q->drv_priv;\n\tsize_t size = data->dbg.t37_nodes * sizeof(u16);\n\n\tif (*nplanes)\n\t\treturn sizes[0] < size ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}\n\nstatic void mxt_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct mxt_data *data = vb2_get_drv_priv(vb->vb2_queue);\n\tu16 *ptr;\n\tint ret;\n\tu8 mode;\n\n\tptr = vb2_plane_vaddr(vb, 0);\n\tif (!ptr) {\n\t\tdev_err(&data->client->dev, \"Error acquiring frame ptr\\n\");\n\t\tgoto fault;\n\t}\n\n\tswitch (data->dbg.input) {\n\tcase MXT_V4L_INPUT_DELTAS:\n\tdefault:\n\t\tmode = MXT_DIAGNOSTIC_DELTAS;\n\t\tbreak;\n\n\tcase MXT_V4L_INPUT_REFS:\n\t\tmode = MXT_DIAGNOSTIC_REFS;\n\t\tbreak;\n\t}\n\n\tret = mxt_read_diagnostic_debug(data, mode, ptr);\n\tif (ret)\n\t\tgoto fault;\n\n\tvb2_set_plane_payload(vb, 0, data->dbg.t37_nodes * sizeof(u16));\n\tvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\n\treturn;\n\nfault:\n\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n}\n\n \nstatic const struct vb2_ops mxt_queue_ops = {\n\t.queue_setup\t\t= mxt_queue_setup,\n\t.buf_queue\t\t= mxt_buffer_queue,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic const struct vb2_queue mxt_queue = {\n\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ,\n\t.buf_struct_size = sizeof(struct mxt_vb2_buffer),\n\t.ops = &mxt_queue_ops,\n\t.mem_ops = &vb2_vmalloc_memops,\n\t.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC,\n\t.min_buffers_needed = 1,\n};\n\nstatic int mxt_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_capability *cap)\n{\n\tstruct mxt_data *data = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"atmel_mxt_ts\", sizeof(cap->driver));\n\tstrscpy(cap->card, \"atmel_mxt_ts touch\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"I2C:%s\", dev_name(&data->client->dev));\n\treturn 0;\n}\n\nstatic int mxt_vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_input *i)\n{\n\tif (i->index >= MXT_V4L_INPUT_MAX)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_TOUCH;\n\n\tswitch (i->index) {\n\tcase MXT_V4L_INPUT_REFS:\n\t\tstrscpy(i->name, \"Mutual Capacitance References\",\n\t\t\tsizeof(i->name));\n\t\tbreak;\n\tcase MXT_V4L_INPUT_DELTAS:\n\t\tstrscpy(i->name, \"Mutual Capacitance Deltas\", sizeof(i->name));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_set_input(struct mxt_data *data, unsigned int i)\n{\n\tstruct v4l2_pix_format *f = &data->dbg.format;\n\n\tif (i >= MXT_V4L_INPUT_MAX)\n\t\treturn -EINVAL;\n\n\tif (i == MXT_V4L_INPUT_DELTAS)\n\t\tf->pixelformat = V4L2_TCH_FMT_DELTA_TD16;\n\telse\n\t\tf->pixelformat = V4L2_TCH_FMT_TU16;\n\n\tf->width = data->xy_switch ? data->ysize : data->xsize;\n\tf->height = data->xy_switch ? data->xsize : data->ysize;\n\tf->field = V4L2_FIELD_NONE;\n\tf->colorspace = V4L2_COLORSPACE_RAW;\n\tf->bytesperline = f->width * sizeof(u16);\n\tf->sizeimage = f->width * f->height * sizeof(u16);\n\n\tdata->dbg.input = i;\n\n\treturn 0;\n}\n\nstatic int mxt_vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn mxt_set_input(video_drvdata(file), i);\n}\n\nstatic int mxt_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct mxt_data *data = video_drvdata(file);\n\n\t*i = data->dbg.input;\n\n\treturn 0;\n}\n\nstatic int mxt_vidioc_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct mxt_data *data = video_drvdata(file);\n\n\tf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tf->fmt.pix = data->dbg.format;\n\n\treturn 0;\n}\n\nstatic int mxt_vidioc_enum_fmt(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *fmt)\n{\n\tif (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (fmt->index) {\n\tcase 0:\n\t\tfmt->pixelformat = V4L2_TCH_FMT_TU16;\n\t\tbreak;\n\n\tcase 1:\n\t\tfmt->pixelformat = V4L2_TCH_FMT_DELTA_TD16;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxt_vidioc_g_parm(struct file *file, void *fh,\n\t\t\t     struct v4l2_streamparm *a)\n{\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\ta->parm.capture.readbuffers = 1;\n\ta->parm.capture.timeperframe.numerator = 1;\n\ta->parm.capture.timeperframe.denominator = 10;\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops mxt_video_ioctl_ops = {\n\t.vidioc_querycap        = mxt_vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = mxt_vidioc_enum_fmt,\n\t.vidioc_s_fmt_vid_cap   = mxt_vidioc_fmt,\n\t.vidioc_g_fmt_vid_cap   = mxt_vidioc_fmt,\n\t.vidioc_try_fmt_vid_cap\t= mxt_vidioc_fmt,\n\t.vidioc_g_parm\t\t= mxt_vidioc_g_parm,\n\n\t.vidioc_enum_input      = mxt_vidioc_enum_input,\n\t.vidioc_g_input         = mxt_vidioc_g_input,\n\t.vidioc_s_input         = mxt_vidioc_s_input,\n\n\t.vidioc_reqbufs         = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs     = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf        = vb2_ioctl_querybuf,\n\t.vidioc_qbuf            = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf           = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf          = vb2_ioctl_expbuf,\n\n\t.vidioc_streamon        = vb2_ioctl_streamon,\n\t.vidioc_streamoff       = vb2_ioctl_streamoff,\n};\n\nstatic const struct video_device mxt_video_device = {\n\t.name = \"Atmel maxTouch\",\n\t.fops = &mxt_video_fops,\n\t.ioctl_ops = &mxt_video_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TOUCH |\n\t\t       V4L2_CAP_READWRITE | V4L2_CAP_STREAMING,\n};\n\nstatic void mxt_debug_init(struct mxt_data *data)\n{\n\tstruct mxt_info *info = data->info;\n\tstruct mxt_dbg *dbg = &data->dbg;\n\tstruct mxt_object *object;\n\tint error;\n\n\tobject = mxt_get_object(data, MXT_GEN_COMMAND_T6);\n\tif (!object)\n\t\tgoto error;\n\n\tdbg->diag_cmd_address = object->start_address + MXT_COMMAND_DIAGNOSTIC;\n\n\tobject = mxt_get_object(data, MXT_DEBUG_DIAGNOSTIC_T37);\n\tif (!object)\n\t\tgoto error;\n\n\tif (mxt_obj_size(object) != sizeof(struct t37_debug)) {\n\t\tdev_warn(&data->client->dev, \"Bad T37 size\");\n\t\tgoto error;\n\t}\n\n\tdbg->t37_address = object->start_address;\n\n\t \n\tdbg->t37_nodes = data->xsize * data->ysize;\n\n\tif (info->family_id == MXT_FAMILY_1386)\n\t\tdbg->t37_pages = MXT1386_COLUMNS * MXT1386_PAGES_PER_COLUMN;\n\telse\n\t\tdbg->t37_pages = DIV_ROUND_UP(data->xsize *\n\t\t\t\t\t      info->matrix_ysize *\n\t\t\t\t\t      sizeof(u16),\n\t\t\t\t\t      sizeof(dbg->t37_buf->data));\n\n\tdbg->t37_buf = devm_kmalloc_array(&data->client->dev, dbg->t37_pages,\n\t\t\t\t\t  sizeof(struct t37_debug), GFP_KERNEL);\n\tif (!dbg->t37_buf)\n\t\tgoto error;\n\n\t \n\tmxt_set_input(data, 0);\n\n\t \n\tsnprintf(dbg->v4l2.name, sizeof(dbg->v4l2.name), \"%s\", \"atmel_mxt_ts\");\n\terror = v4l2_device_register(&data->client->dev, &dbg->v4l2);\n\tif (error)\n\t\tgoto error;\n\n\t \n\tmutex_init(&dbg->lock);\n\tdbg->queue = mxt_queue;\n\tdbg->queue.drv_priv = data;\n\tdbg->queue.lock = &dbg->lock;\n\tdbg->queue.dev = &data->client->dev;\n\n\terror = vb2_queue_init(&dbg->queue);\n\tif (error)\n\t\tgoto error_unreg_v4l2;\n\n\tdbg->vdev = mxt_video_device;\n\tdbg->vdev.v4l2_dev = &dbg->v4l2;\n\tdbg->vdev.lock = &dbg->lock;\n\tdbg->vdev.vfl_dir = VFL_DIR_RX;\n\tdbg->vdev.queue = &dbg->queue;\n\tvideo_set_drvdata(&dbg->vdev, data);\n\n\terror = video_register_device(&dbg->vdev, VFL_TYPE_TOUCH, -1);\n\tif (error)\n\t\tgoto error_unreg_v4l2;\n\n\treturn;\n\nerror_unreg_v4l2:\n\tv4l2_device_unregister(&dbg->v4l2);\nerror:\n\tdev_warn(&data->client->dev, \"Error initializing T37\\n\");\n}\n#else\nstatic void mxt_debug_init(struct mxt_data *data)\n{\n}\n#endif\n\nstatic int mxt_configure_objects(struct mxt_data *data,\n\t\t\t\t const struct firmware *cfg)\n{\n\tstruct device *dev = &data->client->dev;\n\tint error;\n\n\terror = mxt_init_t7_power_cfg(data);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to initialize power cfg\\n\");\n\t\treturn error;\n\t}\n\n\tif (cfg) {\n\t\terror = mxt_update_cfg(data, cfg);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"Error %d updating config\\n\", error);\n\t}\n\n\tif (data->multitouch) {\n\t\terror = mxt_initialize_input_device(data);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tdev_warn(dev, \"No touch object detected\\n\");\n\t}\n\n\tmxt_debug_init(data);\n\n\treturn 0;\n}\n\n \nstatic ssize_t mxt_fw_version_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct mxt_data *data = dev_get_drvdata(dev);\n\tstruct mxt_info *info = data->info;\n\treturn scnprintf(buf, PAGE_SIZE, \"%u.%u.%02X\\n\",\n\t\t\t info->version >> 4, info->version & 0xf, info->build);\n}\n\n \nstatic ssize_t mxt_hw_version_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct mxt_data *data = dev_get_drvdata(dev);\n\tstruct mxt_info *info = data->info;\n\treturn scnprintf(buf, PAGE_SIZE, \"%u.%u\\n\",\n\t\t\t info->family_id, info->variant_id);\n}\n\nstatic ssize_t mxt_show_instance(char *buf, int count,\n\t\t\t\t struct mxt_object *object, int instance,\n\t\t\t\t const u8 *val)\n{\n\tint i;\n\n\tif (mxt_obj_instances(object) > 1)\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t   \"Instance %u\\n\", instance);\n\n\tfor (i = 0; i < mxt_obj_size(object); i++)\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t\"\\t[%2u]: %02x (%d)\\n\", i, val[i], val[i]);\n\tcount += scnprintf(buf + count, PAGE_SIZE - count, \"\\n\");\n\n\treturn count;\n}\n\nstatic ssize_t mxt_object_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct mxt_data *data = dev_get_drvdata(dev);\n\tstruct mxt_object *object;\n\tint count = 0;\n\tint i, j;\n\tint error;\n\tu8 *obuf;\n\n\t \n\tobuf = kmalloc(256, GFP_KERNEL);\n\tif (!obuf)\n\t\treturn -ENOMEM;\n\n\terror = 0;\n\tfor (i = 0; i < data->info->object_num; i++) {\n\t\tobject = data->object_table + i;\n\n\t\tif (!mxt_object_readable(object->type))\n\t\t\tcontinue;\n\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count,\n\t\t\t\t\"T%u:\\n\", object->type);\n\n\t\tfor (j = 0; j < mxt_obj_instances(object); j++) {\n\t\t\tu16 size = mxt_obj_size(object);\n\t\t\tu16 addr = object->start_address + j * size;\n\n\t\t\terror = __mxt_read_reg(data->client, addr, size, obuf);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\n\t\t\tcount = mxt_show_instance(buf, count, object, j, obuf);\n\t\t}\n\t}\n\ndone:\n\tkfree(obuf);\n\treturn error ?: count;\n}\n\nstatic int mxt_check_firmware_format(struct device *dev,\n\t\t\t\t     const struct firmware *fw)\n{\n\tunsigned int pos = 0;\n\tchar c;\n\n\twhile (pos < fw->size) {\n\t\tc = *(fw->data + pos);\n\n\t\tif (c < '0' || (c > '9' && c < 'A') || c > 'F')\n\t\t\treturn 0;\n\n\t\tpos++;\n\t}\n\n\t \n\tdev_err(dev, \"Aborting: firmware file must be in binary format\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int mxt_load_fw(struct device *dev, const char *fn)\n{\n\tstruct mxt_data *data = dev_get_drvdata(dev);\n\tconst struct firmware *fw = NULL;\n\tunsigned int frame_size;\n\tunsigned int pos = 0;\n\tunsigned int retry = 0;\n\tunsigned int frame = 0;\n\tint ret;\n\n\tret = request_firmware(&fw, fn, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to open firmware %s\\n\", fn);\n\t\treturn ret;\n\t}\n\n\t \n\tret = mxt_check_firmware_format(dev, fw);\n\tif (ret)\n\t\tgoto release_firmware;\n\n\tif (!data->in_bootloader) {\n\t\t \n\t\tdata->in_bootloader = true;\n\n\t\tret = mxt_t6_command(data, MXT_COMMAND_RESET,\n\t\t\t\t     MXT_BOOT_VALUE, false);\n\t\tif (ret)\n\t\t\tgoto release_firmware;\n\n\t\tmsleep(MXT_RESET_TIME);\n\n\t\t \n\t\tret = mxt_lookup_bootloader_address(data, 0);\n\t\tif (ret)\n\t\t\tgoto release_firmware;\n\n\t\tmxt_free_input_device(data);\n\t\tmxt_free_object_table(data);\n\t} else {\n\t\tenable_irq(data->irq);\n\t}\n\n\treinit_completion(&data->bl_completion);\n\n\tret = mxt_check_bootloader(data, MXT_WAITING_BOOTLOAD_CMD, false);\n\tif (ret) {\n\t\t \n\t\tret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, false);\n\t\tif (ret)\n\t\t\tgoto disable_irq;\n\t} else {\n\t\tdev_info(dev, \"Unlocking bootloader\\n\");\n\n\t\t \n\t\tret = mxt_send_bootloader_cmd(data, true);\n\t\tif (ret)\n\t\t\tgoto disable_irq;\n\t}\n\n\twhile (pos < fw->size) {\n\t\tret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, true);\n\t\tif (ret)\n\t\t\tgoto disable_irq;\n\n\t\tframe_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));\n\n\t\t \n\t\tframe_size += 2;\n\n\t\t \n\t\tret = mxt_bootloader_write(data, fw->data + pos, frame_size);\n\t\tif (ret)\n\t\t\tgoto disable_irq;\n\n\t\tret = mxt_check_bootloader(data, MXT_FRAME_CRC_PASS, true);\n\t\tif (ret) {\n\t\t\tretry++;\n\n\t\t\t \n\t\t\tmsleep(retry * 20);\n\n\t\t\tif (retry > 20) {\n\t\t\t\tdev_err(dev, \"Retry count exceeded\\n\");\n\t\t\t\tgoto disable_irq;\n\t\t\t}\n\t\t} else {\n\t\t\tretry = 0;\n\t\t\tpos += frame_size;\n\t\t\tframe++;\n\t\t}\n\n\t\tif (frame % 50 == 0)\n\t\t\tdev_dbg(dev, \"Sent %d frames, %d/%zd bytes\\n\",\n\t\t\t\tframe, pos, fw->size);\n\t}\n\n\t \n\tret = mxt_wait_for_completion(data, &data->bl_completion,\n\t\t\t\t      MXT_FW_RESET_TIME);\n\tif (ret)\n\t\tgoto disable_irq;\n\n\tdev_dbg(dev, \"Sent %d frames, %d bytes\\n\", frame, pos);\n\n\t \n\tmxt_wait_for_completion(data, &data->bl_completion, MXT_FW_RESET_TIME);\n\n\tdata->in_bootloader = false;\n\ndisable_irq:\n\tdisable_irq(data->irq);\nrelease_firmware:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic ssize_t mxt_update_fw_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct mxt_data *data = dev_get_drvdata(dev);\n\tint error;\n\n\terror = mxt_load_fw(dev, MXT_FW_NAME);\n\tif (error) {\n\t\tdev_err(dev, \"The firmware update failed(%d)\\n\", error);\n\t\tcount = error;\n\t} else {\n\t\tdev_info(dev, \"The firmware update succeeded\\n\");\n\n\t\terror = mxt_initialize(data);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(fw_version, S_IRUGO, mxt_fw_version_show, NULL);\nstatic DEVICE_ATTR(hw_version, S_IRUGO, mxt_hw_version_show, NULL);\nstatic DEVICE_ATTR(object, S_IRUGO, mxt_object_show, NULL);\nstatic DEVICE_ATTR(update_fw, S_IWUSR, NULL, mxt_update_fw_store);\n\nstatic struct attribute *mxt_attrs[] = {\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_hw_version.attr,\n\t&dev_attr_object.attr,\n\t&dev_attr_update_fw.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mxt_attr_group = {\n\t.attrs = mxt_attrs,\n};\n\nstatic void mxt_start(struct mxt_data *data)\n{\n\tmxt_wakeup_toggle(data->client, true, false);\n\n\tswitch (data->suspend_mode) {\n\tcase MXT_SUSPEND_T9_CTRL:\n\t\tmxt_soft_reset(data);\n\n\t\t \n\t\t \n\t\tmxt_write_object(data,\n\t\t\t\tMXT_TOUCH_MULTI_T9, MXT_T9_CTRL, 0x83);\n\t\tbreak;\n\n\tcase MXT_SUSPEND_DEEP_SLEEP:\n\tdefault:\n\t\tmxt_set_t7_power_cfg(data, MXT_POWER_CFG_RUN);\n\n\t\t \n\t\tmxt_t6_command(data, MXT_COMMAND_CALIBRATE, 1, false);\n\t\tbreak;\n\t}\n}\n\nstatic void mxt_stop(struct mxt_data *data)\n{\n\tswitch (data->suspend_mode) {\n\tcase MXT_SUSPEND_T9_CTRL:\n\t\t \n\t\tmxt_write_object(data,\n\t\t\t\tMXT_TOUCH_MULTI_T9, MXT_T9_CTRL, 0);\n\t\tbreak;\n\n\tcase MXT_SUSPEND_DEEP_SLEEP:\n\tdefault:\n\t\tmxt_set_t7_power_cfg(data, MXT_POWER_CFG_DEEPSLEEP);\n\t\tbreak;\n\t}\n\n\tmxt_wakeup_toggle(data->client, false, false);\n}\n\nstatic int mxt_input_open(struct input_dev *dev)\n{\n\tstruct mxt_data *data = input_get_drvdata(dev);\n\n\tmxt_start(data);\n\n\treturn 0;\n}\n\nstatic void mxt_input_close(struct input_dev *dev)\n{\n\tstruct mxt_data *data = input_get_drvdata(dev);\n\n\tmxt_stop(data);\n}\n\nstatic int mxt_parse_device_properties(struct mxt_data *data)\n{\n\tstatic const char keymap_property[] = \"linux,gpio-keymap\";\n\tstatic const char buttons_property[] = \"linux,keycodes\";\n\tstruct device *dev = &data->client->dev;\n\tu32 *keymap;\n\tu32 *buttonmap;\n\tint n_keys;\n\tint error;\n\n\tif (device_property_present(dev, keymap_property)) {\n\t\tn_keys = device_property_count_u32(dev, keymap_property);\n\t\tif (n_keys <= 0) {\n\t\t\terror = n_keys < 0 ? n_keys : -EINVAL;\n\t\t\tdev_err(dev, \"invalid/malformed '%s' property: %d\\n\",\n\t\t\t\tkeymap_property, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tkeymap = devm_kmalloc_array(dev, n_keys, sizeof(*keymap),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!keymap)\n\t\t\treturn -ENOMEM;\n\n\t\terror = device_property_read_u32_array(dev, keymap_property,\n\t\t\t\t\t\t       keymap, n_keys);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to parse '%s' property: %d\\n\",\n\t\t\t\tkeymap_property, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tdata->t19_keymap = keymap;\n\t\tdata->t19_num_keys = n_keys;\n\t}\n\n\tif (device_property_present(dev, buttons_property)) {\n\t\tn_keys = device_property_count_u32(dev, buttons_property);\n\t\tif (n_keys <= 0) {\n\t\t\terror = n_keys < 0 ? n_keys : -EINVAL;\n\t\t\tdev_err(dev, \"invalid/malformed '%s' property: %d\\n\",\n\t\t\t\tbuttons_property, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tbuttonmap = devm_kmalloc_array(dev, n_keys, sizeof(*buttonmap),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!buttonmap)\n\t\t\treturn -ENOMEM;\n\n\t\terror = device_property_read_u32_array(dev, buttons_property,\n\t\t\t\t\t\t       buttonmap, n_keys);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"failed to parse '%s' property: %d\\n\",\n\t\t\t\tbuttons_property, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tdata->t15_keymap = buttonmap;\n\t\tdata->t15_num_keys = n_keys;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id chromebook_T9_suspend_dmi[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Link\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Peppy\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int mxt_probe(struct i2c_client *client)\n{\n\tstruct mxt_data *data;\n\tint error;\n\n\t \n\tif (!device_property_present(&client->dev, \"compatible\"))\n\t\treturn -ENXIO;\n\n\t \n\tif (ACPI_COMPANION(&client->dev) && client->addr < 0x40)\n\t\treturn -ENXIO;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct mxt_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsnprintf(data->phys, sizeof(data->phys), \"i2c-%u-%04x/input0\",\n\t\t client->adapter->nr, client->addr);\n\n\tdata->client = client;\n\tdata->irq = client->irq;\n\ti2c_set_clientdata(client, data);\n\n\tinit_completion(&data->bl_completion);\n\tinit_completion(&data->reset_completion);\n\tinit_completion(&data->crc_completion);\n\n\tdata->suspend_mode = dmi_check_system(chromebook_T9_suspend_dmi) ?\n\t\tMXT_SUSPEND_T9_CTRL : MXT_SUSPEND_DEEP_SLEEP;\n\n\terror = mxt_parse_device_properties(data);\n\tif (error)\n\t\treturn error;\n\n\t \n\tdata->regulators[0].supply = \"vdda\";\n\tdata->regulators[1].supply = \"vdd\";\n\terror = devm_regulator_bulk_get(&client->dev, ARRAY_SIZE(data->regulators),\n\t\t\t\t\tdata->regulators);\n\tif (error) {\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(&client->dev, \"Failed to get regulators %d\\n\",\n\t\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tdata->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t   \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->reset_gpio)) {\n\t\terror = PTR_ERR(data->reset_gpio);\n\t\tdev_err(&client->dev, \"Failed to get reset gpio: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tdata->wake_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t  \"wake\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->wake_gpio)) {\n\t\terror = PTR_ERR(data->wake_gpio);\n\t\tdev_err(&client->dev, \"Failed to get wake gpio: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, mxt_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  client->name, data);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(data->regulators),\n\t\t\t\t      data->regulators);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to enable regulators: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\t \n\tmsleep(MXT_BACKUP_TIME);\n\n\tif (data->reset_gpio) {\n\t\t \n\t\tmsleep(MXT_RESET_GPIO_TIME);\n\t\tgpiod_set_value(data->reset_gpio, 0);\n\t\tmsleep(MXT_RESET_INVALID_CHG);\n\t}\n\n\t \n\tdevice_property_read_u32(&client->dev, \"atmel,wakeup-method\",\n\t\t\t\t &data->wakeup_method);\n\n\terror = mxt_initialize(data);\n\tif (error)\n\t\tgoto err_disable_regulators;\n\n\terror = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failure %d creating sysfs group\\n\",\n\t\t\terror);\n\t\tgoto err_free_object;\n\t}\n\n\treturn 0;\n\nerr_free_object:\n\tmxt_free_input_device(data);\n\tmxt_free_object_table(data);\nerr_disable_regulators:\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators),\n\t\t\t       data->regulators);\n\treturn error;\n}\n\nstatic void mxt_remove(struct i2c_client *client)\n{\n\tstruct mxt_data *data = i2c_get_clientdata(client);\n\n\tdisable_irq(data->irq);\n\tsysfs_remove_group(&client->dev.kobj, &mxt_attr_group);\n\tmxt_free_input_device(data);\n\tmxt_free_object_table(data);\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators),\n\t\t\t       data->regulators);\n}\n\nstatic int mxt_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mxt_data *data = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = data->input_dev;\n\n\tif (!input_dev)\n\t\treturn 0;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tmxt_stop(data);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\tdisable_irq(data->irq);\n\n\treturn 0;\n}\n\nstatic int mxt_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mxt_data *data = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = data->input_dev;\n\n\tif (!input_dev)\n\t\treturn 0;\n\n\tenable_irq(data->irq);\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tmxt_start(data);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume);\n\nstatic const struct of_device_id mxt_of_match[] = {\n\t{ .compatible = \"atmel,maxtouch\", },\n\t \n\t{ .compatible = \"atmel,qt602240_ts\", },\n\t{ .compatible = \"atmel,atmel_mxt_ts\", },\n\t{ .compatible = \"atmel,atmel_mxt_tp\", },\n\t{ .compatible = \"atmel,mXT224\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mxt_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id mxt_acpi_id[] = {\n\t{ \"ATML0000\", 0 },\t \n\t{ \"ATML0001\", 0 },\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, mxt_acpi_id);\n#endif\n\nstatic const struct i2c_device_id mxt_id[] = {\n\t{ \"qt602240_ts\", 0 },\n\t{ \"atmel_mxt_ts\", 0 },\n\t{ \"atmel_mxt_tp\", 0 },\n\t{ \"maxtouch\", 0 },\n\t{ \"mXT224\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mxt_id);\n\nstatic struct i2c_driver mxt_driver = {\n\t.driver = {\n\t\t.name\t= \"atmel_mxt_ts\",\n\t\t.of_match_table = mxt_of_match,\n\t\t.acpi_match_table = ACPI_PTR(mxt_acpi_id),\n\t\t.pm\t= pm_sleep_ptr(&mxt_pm_ops),\n\t},\n\t.probe\t\t= mxt_probe,\n\t.remove\t\t= mxt_remove,\n\t.id_table\t= mxt_id,\n};\n\nmodule_i2c_driver(mxt_driver);\n\n \nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_DESCRIPTION(\"Atmel maXTouch Touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}