{
  "module_name": "zforce_ts.c",
  "hash_id": "d67d91fa1455a8c582cfc9417eae2e8557ae5638932f7933b43d2adb323d673d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/zforce_ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/hrtimer.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/input/mt.h>\n#include <linux/platform_data/zforce_ts.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n\n#define WAIT_TIMEOUT\t\tmsecs_to_jiffies(1000)\n\n#define FRAME_START\t\t0xee\n#define FRAME_MAXSIZE\t\t257\n\n \n#define PAYLOAD_HEADER\t\t0\n#define PAYLOAD_LENGTH\t\t1\n#define PAYLOAD_BODY\t\t2\n\n \n#define RESPONSE_ID\t\t0\n#define RESPONSE_DATA\t\t1\n\n \n#define COMMAND_DEACTIVATE\t0x00\n#define COMMAND_INITIALIZE\t0x01\n#define COMMAND_RESOLUTION\t0x02\n#define COMMAND_SETCONFIG\t0x03\n#define COMMAND_DATAREQUEST\t0x04\n#define COMMAND_SCANFREQ\t0x08\n#define COMMAND_STATUS\t\t0X1e\n\n \n#define RESPONSE_DEACTIVATE\t0x00\n#define RESPONSE_INITIALIZE\t0x01\n#define RESPONSE_RESOLUTION\t0x02\n#define RESPONSE_SETCONFIG\t0x03\n#define RESPONSE_SCANFREQ\t0x08\n#define RESPONSE_STATUS\t\t0X1e\n\n \n#define NOTIFICATION_TOUCH\t\t0x04\n#define NOTIFICATION_BOOTCOMPLETE\t0x07\n#define NOTIFICATION_OVERRUN\t\t0x25\n#define NOTIFICATION_PROXIMITY\t\t0x26\n#define NOTIFICATION_INVALID_COMMAND\t0xfe\n\n#define ZFORCE_REPORT_POINTS\t\t2\n#define ZFORCE_MAX_AREA\t\t\t0xff\n\n#define STATE_DOWN\t\t\t0\n#define STATE_MOVE\t\t\t1\n#define STATE_UP\t\t\t2\n\n#define SETCONFIG_DUALTOUCH\t\t(1 << 0)\n\nstruct zforce_point {\n\tint coord_x;\n\tint coord_y;\n\tint state;\n\tint id;\n\tint area_major;\n\tint area_minor;\n\tint orientation;\n\tint pressure;\n\tint prblty;\n};\n\n \nstruct zforce_ts {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input;\n\tconst struct zforce_ts_platdata *pdata;\n\tchar\t\t\tphys[32];\n\n\tstruct regulator\t*reg_vdd;\n\n\tstruct gpio_desc\t*gpio_int;\n\tstruct gpio_desc\t*gpio_rst;\n\n\tbool\t\t\tsuspending;\n\tbool\t\t\tsuspended;\n\tbool\t\t\tboot_complete;\n\n\t \n\tu16\t\t\tversion_major;\n\tu16\t\t\tversion_minor;\n\tu16\t\t\tversion_build;\n\tu16\t\t\tversion_rev;\n\n\tstruct mutex\t\taccess_mutex;\n\n\tstruct completion\tcommand_done;\n\tstruct mutex\t\tcommand_mutex;\n\tint\t\t\tcommand_waiting;\n\tint\t\t\tcommand_result;\n};\n\nstatic int zforce_command(struct zforce_ts *ts, u8 cmd)\n{\n\tstruct i2c_client *client = ts->client;\n\tchar buf[3];\n\tint ret;\n\n\tdev_dbg(&client->dev, \"%s: 0x%x\\n\", __func__, cmd);\n\n\tbuf[0] = FRAME_START;\n\tbuf[1] = 1;  \n\tbuf[2] = cmd;\n\n\tmutex_lock(&ts->access_mutex);\n\tret = i2c_master_send(client, &buf[0], ARRAY_SIZE(buf));\n\tmutex_unlock(&ts->access_mutex);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"i2c send data request error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void zforce_reset_assert(struct zforce_ts *ts)\n{\n\tgpiod_set_value_cansleep(ts->gpio_rst, 1);\n}\n\nstatic void zforce_reset_deassert(struct zforce_ts *ts)\n{\n\tgpiod_set_value_cansleep(ts->gpio_rst, 0);\n}\n\nstatic int zforce_send_wait(struct zforce_ts *ts, const char *buf, int len)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = mutex_trylock(&ts->command_mutex);\n\tif (!ret) {\n\t\tdev_err(&client->dev, \"already waiting for a command\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdev_dbg(&client->dev, \"sending %d bytes for command 0x%x\\n\",\n\t\tbuf[1], buf[2]);\n\n\tts->command_waiting = buf[2];\n\n\tmutex_lock(&ts->access_mutex);\n\tret = i2c_master_send(client, buf, len);\n\tmutex_unlock(&ts->access_mutex);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"i2c send data request error: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tdev_dbg(&client->dev, \"waiting for result for command 0x%x\\n\", buf[2]);\n\n\tif (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0) {\n\t\tret = -ETIME;\n\t\tgoto unlock;\n\t}\n\n\tret = ts->command_result;\n\nunlock:\n\tmutex_unlock(&ts->command_mutex);\n\treturn ret;\n}\n\nstatic int zforce_command_wait(struct zforce_ts *ts, u8 cmd)\n{\n\tstruct i2c_client *client = ts->client;\n\tchar buf[3];\n\tint ret;\n\n\tdev_dbg(&client->dev, \"%s: 0x%x\\n\", __func__, cmd);\n\n\tbuf[0] = FRAME_START;\n\tbuf[1] = 1;  \n\tbuf[2] = cmd;\n\n\tret = zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"i2c send data request error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int zforce_resolution(struct zforce_ts *ts, u16 x, u16 y)\n{\n\tstruct i2c_client *client = ts->client;\n\tchar buf[7] = { FRAME_START, 5, COMMAND_RESOLUTION,\n\t\t\t(x & 0xff), ((x >> 8) & 0xff),\n\t\t\t(y & 0xff), ((y >> 8) & 0xff) };\n\n\tdev_dbg(&client->dev, \"set resolution to (%d,%d)\\n\", x, y);\n\n\treturn zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\n}\n\nstatic int zforce_scan_frequency(struct zforce_ts *ts, u16 idle, u16 finger,\n\t\t\t\t u16 stylus)\n{\n\tstruct i2c_client *client = ts->client;\n\tchar buf[9] = { FRAME_START, 7, COMMAND_SCANFREQ,\n\t\t\t(idle & 0xff), ((idle >> 8) & 0xff),\n\t\t\t(finger & 0xff), ((finger >> 8) & 0xff),\n\t\t\t(stylus & 0xff), ((stylus >> 8) & 0xff) };\n\n\tdev_dbg(&client->dev,\n\t\t\"set scan frequency to (idle: %d, finger: %d, stylus: %d)\\n\",\n\t\tidle, finger, stylus);\n\n\treturn zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\n}\n\nstatic int zforce_setconfig(struct zforce_ts *ts, char b1)\n{\n\tstruct i2c_client *client = ts->client;\n\tchar buf[7] = { FRAME_START, 5, COMMAND_SETCONFIG,\n\t\t\tb1, 0, 0, 0 };\n\n\tdev_dbg(&client->dev, \"set config to (%d)\\n\", b1);\n\n\treturn zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\n}\n\nstatic int zforce_start(struct zforce_ts *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst struct zforce_ts_platdata *pdata = ts->pdata;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"starting device\\n\");\n\n\tret = zforce_command_wait(ts, COMMAND_INITIALIZE);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to initialize, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = zforce_resolution(ts, pdata->x_max, pdata->y_max);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to set resolution, %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = zforce_scan_frequency(ts, 10, 50, 50);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to set scan frequency, %d\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\tret = zforce_setconfig(ts, SETCONFIG_DUALTOUCH);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to set config\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tret = zforce_command(ts, COMMAND_DATAREQUEST);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Unable to request data\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tmsleep(200);\n\n\treturn 0;\n\nerror:\n\tzforce_command_wait(ts, COMMAND_DEACTIVATE);\n\treturn ret;\n}\n\nstatic int zforce_stop(struct zforce_ts *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"stopping device\\n\");\n\n\t \n\tret = zforce_command_wait(ts, COMMAND_DEACTIVATE);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"could not deactivate device, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int zforce_touch_event(struct zforce_ts *ts, u8 *payload)\n{\n\tstruct i2c_client *client = ts->client;\n\tconst struct zforce_ts_platdata *pdata = ts->pdata;\n\tstruct zforce_point point;\n\tint count, i, num = 0;\n\n\tcount = payload[0];\n\tif (count > ZFORCE_REPORT_POINTS) {\n\t\tdev_warn(&client->dev,\n\t\t\t \"too many coordinates %d, expected max %d\\n\",\n\t\t\t count, ZFORCE_REPORT_POINTS);\n\t\tcount = ZFORCE_REPORT_POINTS;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tpoint.coord_x =\n\t\t\tpayload[9 * i + 2] << 8 | payload[9 * i + 1];\n\t\tpoint.coord_y =\n\t\t\tpayload[9 * i + 4] << 8 | payload[9 * i + 3];\n\n\t\tif (point.coord_x > pdata->x_max ||\n\t\t    point.coord_y > pdata->y_max) {\n\t\t\tdev_warn(&client->dev, \"coordinates (%d,%d) invalid\\n\",\n\t\t\t\tpoint.coord_x, point.coord_y);\n\t\t\tpoint.coord_x = point.coord_y = 0;\n\t\t}\n\n\t\tpoint.state = payload[9 * i + 5] & 0x0f;\n\t\tpoint.id = (payload[9 * i + 5] & 0xf0) >> 4;\n\n\t\t \n\t\tpoint.area_major = max(payload[9 * i + 6],\n\t\t\t\t\t  payload[9 * i + 7]);\n\t\tpoint.area_minor = min(payload[9 * i + 6],\n\t\t\t\t\t  payload[9 * i + 7]);\n\t\tpoint.orientation = payload[9 * i + 6] > payload[9 * i + 7];\n\n\t\tpoint.pressure = payload[9 * i + 8];\n\t\tpoint.prblty = payload[9 * i + 9];\n\n\t\tdev_dbg(&client->dev,\n\t\t\t\"point %d/%d: state %d, id %d, pressure %d, prblty %d, x %d, y %d, amajor %d, aminor %d, ori %d\\n\",\n\t\t\ti, count, point.state, point.id,\n\t\t\tpoint.pressure, point.prblty,\n\t\t\tpoint.coord_x, point.coord_y,\n\t\t\tpoint.area_major, point.area_minor,\n\t\t\tpoint.orientation);\n\n\t\t \n\t\tinput_mt_slot(ts->input, point.id - 1);\n\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER,\n\t\t\t\t\t\tpoint.state != STATE_UP);\n\n\t\tif (point.state != STATE_UP) {\n\t\t\tinput_report_abs(ts->input, ABS_MT_POSITION_X,\n\t\t\t\t\t point.coord_x);\n\t\t\tinput_report_abs(ts->input, ABS_MT_POSITION_Y,\n\t\t\t\t\t point.coord_y);\n\t\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t\t point.area_major);\n\t\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MINOR,\n\t\t\t\t\t point.area_minor);\n\t\t\tinput_report_abs(ts->input, ABS_MT_ORIENTATION,\n\t\t\t\t\t point.orientation);\n\t\t\tnum++;\n\t\t}\n\t}\n\n\tinput_mt_sync_frame(ts->input);\n\n\tinput_mt_report_finger_count(ts->input, num);\n\n\tinput_sync(ts->input);\n\n\treturn 0;\n}\n\nstatic int zforce_read_packet(struct zforce_ts *ts, u8 *buf)\n{\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tmutex_lock(&ts->access_mutex);\n\n\t \n\tret = i2c_master_recv(client, buf, 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error reading header: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tif (buf[PAYLOAD_HEADER] != FRAME_START) {\n\t\tdev_err(&client->dev, \"invalid frame start: %d\\n\", buf[0]);\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tif (buf[PAYLOAD_LENGTH] == 0) {\n\t\tdev_err(&client->dev, \"invalid payload length: %d\\n\",\n\t\t\tbuf[PAYLOAD_LENGTH]);\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = i2c_master_recv(client, &buf[PAYLOAD_BODY], buf[PAYLOAD_LENGTH]);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error reading payload: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tdev_dbg(&client->dev, \"read %d bytes for response command 0x%x\\n\",\n\t\tbuf[PAYLOAD_LENGTH], buf[PAYLOAD_BODY]);\n\nunlock:\n\tmutex_unlock(&ts->access_mutex);\n\treturn ret;\n}\n\nstatic void zforce_complete(struct zforce_ts *ts, int cmd, int result)\n{\n\tstruct i2c_client *client = ts->client;\n\n\tif (ts->command_waiting == cmd) {\n\t\tdev_dbg(&client->dev, \"completing command 0x%x\\n\", cmd);\n\t\tts->command_result = result;\n\t\tcomplete(&ts->command_done);\n\t} else {\n\t\tdev_dbg(&client->dev, \"command %d not for us\\n\", cmd);\n\t}\n}\n\nstatic irqreturn_t zforce_irq(int irq, void *dev_id)\n{\n\tstruct zforce_ts *ts = dev_id;\n\tstruct i2c_client *client = ts->client;\n\n\tif (ts->suspended && device_may_wakeup(&client->dev))\n\t\tpm_wakeup_event(&client->dev, 500);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t zforce_irq_thread(int irq, void *dev_id)\n{\n\tstruct zforce_ts *ts = dev_id;\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\tu8 payload_buffer[FRAME_MAXSIZE];\n\tu8 *payload;\n\n\t \n\tif (ts->suspended) {\n\t\tmsleep(20);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdev_dbg(&client->dev, \"handling interrupt\\n\");\n\n\t \n\tif (!ts->suspending && device_may_wakeup(&client->dev))\n\t\tpm_stay_awake(&client->dev);\n\n\t \n\tdo {\n\t\tret = zforce_read_packet(ts, payload_buffer);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"could not read packet, ret: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tpayload =  &payload_buffer[PAYLOAD_BODY];\n\n\t\tswitch (payload[RESPONSE_ID]) {\n\t\tcase NOTIFICATION_TOUCH:\n\t\t\t \n\t\t\tif (ts->suspending && device_may_wakeup(&client->dev))\n\t\t\t\tpm_wakeup_event(&client->dev, 500);\n\t\t\tzforce_touch_event(ts, &payload[RESPONSE_DATA]);\n\t\t\tbreak;\n\n\t\tcase NOTIFICATION_BOOTCOMPLETE:\n\t\t\tts->boot_complete = payload[RESPONSE_DATA];\n\t\t\tzforce_complete(ts, payload[RESPONSE_ID], 0);\n\t\t\tbreak;\n\n\t\tcase RESPONSE_INITIALIZE:\n\t\tcase RESPONSE_DEACTIVATE:\n\t\tcase RESPONSE_SETCONFIG:\n\t\tcase RESPONSE_RESOLUTION:\n\t\tcase RESPONSE_SCANFREQ:\n\t\t\tzforce_complete(ts, payload[RESPONSE_ID],\n\t\t\t\t\tpayload[RESPONSE_DATA]);\n\t\t\tbreak;\n\n\t\tcase RESPONSE_STATUS:\n\t\t\t \n\t\t\tts->version_major = (payload[RESPONSE_DATA + 1] << 8) |\n\t\t\t\t\t\tpayload[RESPONSE_DATA];\n\t\t\tts->version_minor = (payload[RESPONSE_DATA + 3] << 8) |\n\t\t\t\t\t\tpayload[RESPONSE_DATA + 2];\n\t\t\tts->version_build = (payload[RESPONSE_DATA + 5] << 8) |\n\t\t\t\t\t\tpayload[RESPONSE_DATA + 4];\n\t\t\tts->version_rev   = (payload[RESPONSE_DATA + 7] << 8) |\n\t\t\t\t\t\tpayload[RESPONSE_DATA + 6];\n\t\t\tdev_dbg(&ts->client->dev,\n\t\t\t\t\"Firmware Version %04x:%04x %04x:%04x\\n\",\n\t\t\t\tts->version_major, ts->version_minor,\n\t\t\t\tts->version_build, ts->version_rev);\n\n\t\t\tzforce_complete(ts, payload[RESPONSE_ID], 0);\n\t\t\tbreak;\n\n\t\tcase NOTIFICATION_INVALID_COMMAND:\n\t\t\tdev_err(&ts->client->dev, \"invalid command: 0x%x\\n\",\n\t\t\t\tpayload[RESPONSE_DATA]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"unrecognized response id: 0x%x\\n\",\n\t\t\t\tpayload[RESPONSE_ID]);\n\t\t\tbreak;\n\t\t}\n\t} while (gpiod_get_value_cansleep(ts->gpio_int));\n\n\tif (!ts->suspending && device_may_wakeup(&client->dev))\n\t\tpm_relax(&client->dev);\n\n\tdev_dbg(&client->dev, \"finished interrupt\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int zforce_input_open(struct input_dev *dev)\n{\n\tstruct zforce_ts *ts = input_get_drvdata(dev);\n\n\treturn zforce_start(ts);\n}\n\nstatic void zforce_input_close(struct input_dev *dev)\n{\n\tstruct zforce_ts *ts = input_get_drvdata(dev);\n\tstruct i2c_client *client = ts->client;\n\tint ret;\n\n\tret = zforce_stop(ts);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"stopping zforce failed\\n\");\n\n\treturn;\n}\n\nstatic int zforce_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct zforce_ts *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\tint ret = 0;\n\n\tmutex_lock(&input->mutex);\n\tts->suspending = true;\n\n\t \n\tif (device_may_wakeup(&client->dev)) {\n\t\tdev_dbg(&client->dev, \"suspend while being a wakeup source\\n\");\n\n\t\t \n\t\tif (!input_device_enabled(input)) {\n\t\t\tret = zforce_start(ts);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tenable_irq_wake(client->irq);\n\t} else if (input_device_enabled(input)) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"suspend without being a wakeup source\\n\");\n\n\t\tret = zforce_stop(ts);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tdisable_irq(client->irq);\n\t}\n\n\tts->suspended = true;\n\nunlock:\n\tts->suspending = false;\n\tmutex_unlock(&input->mutex);\n\n\treturn ret;\n}\n\nstatic int zforce_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct zforce_ts *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\tint ret = 0;\n\n\tmutex_lock(&input->mutex);\n\n\tts->suspended = false;\n\n\tif (device_may_wakeup(&client->dev)) {\n\t\tdev_dbg(&client->dev, \"resume from being a wakeup source\\n\");\n\n\t\tdisable_irq_wake(client->irq);\n\n\t\t \n\t\tif (!input_device_enabled(input)) {\n\t\t\tret = zforce_stop(ts);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\t} else if (input_device_enabled(input)) {\n\t\tdev_dbg(&client->dev, \"resume without being a wakeup source\\n\");\n\n\t\tenable_irq(client->irq);\n\n\t\tret = zforce_start(ts);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tmutex_unlock(&input->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(zforce_pm_ops, zforce_suspend, zforce_resume);\n\nstatic void zforce_reset(void *data)\n{\n\tstruct zforce_ts *ts = data;\n\n\tzforce_reset_assert(ts);\n\n\tudelay(10);\n\n\tif (!IS_ERR(ts->reg_vdd))\n\t\tregulator_disable(ts->reg_vdd);\n}\n\nstatic struct zforce_ts_platdata *zforce_parse_dt(struct device *dev)\n{\n\tstruct zforce_ts_platdata *pdata;\n\tstruct device_node *np = dev->of_node;\n\n\tif (!np)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tdev_err(dev, \"failed to allocate platform data\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (of_property_read_u32(np, \"x-size\", &pdata->x_max)) {\n\t\tdev_err(dev, \"failed to get x-size property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (of_property_read_u32(np, \"y-size\", &pdata->y_max)) {\n\t\tdev_err(dev, \"failed to get y-size property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn pdata;\n}\n\nstatic int zforce_probe(struct i2c_client *client)\n{\n\tconst struct zforce_ts_platdata *pdata = dev_get_platdata(&client->dev);\n\tstruct zforce_ts *ts;\n\tstruct input_dev *input_dev;\n\tint ret;\n\n\tif (!pdata) {\n\t\tpdata = zforce_parse_dt(&client->dev);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t}\n\n\tts = devm_kzalloc(&client->dev, sizeof(struct zforce_ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->gpio_rst = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->gpio_rst)) {\n\t\tret = PTR_ERR(ts->gpio_rst);\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to request reset GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ts->gpio_rst) {\n\t\tts->gpio_int = devm_gpiod_get_optional(&client->dev, \"irq\",\n\t\t\t\t\t\t       GPIOD_IN);\n\t\tif (IS_ERR(ts->gpio_int)) {\n\t\t\tret = PTR_ERR(ts->gpio_int);\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to request interrupt GPIO: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\n\t\t \n\t\tts->gpio_int = devm_gpiod_get_index(&client->dev, NULL, 0,\n\t\t\t\t\t\t    GPIOD_IN);\n\t\tif (IS_ERR(ts->gpio_int)) {\n\t\t\tret = PTR_ERR(ts->gpio_int);\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to request interrupt GPIO: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tts->gpio_rst = devm_gpiod_get_index(&client->dev, NULL, 1,\n\t\t\t\t\t    GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(ts->gpio_rst)) {\n\t\t\tret = PTR_ERR(ts->gpio_rst);\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to request reset GPIO: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tts->reg_vdd = devm_regulator_get_optional(&client->dev, \"vdd\");\n\tif (IS_ERR(ts->reg_vdd)) {\n\t\tret = PTR_ERR(ts->reg_vdd);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t} else {\n\t\tret = regulator_enable(ts->reg_vdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tudelay(100);\n\t}\n\n\tret = devm_add_action(&client->dev, zforce_reset, ts);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to register reset action, %d\\n\",\n\t\t\tret);\n\n\t\t \n\t\tif (!IS_ERR(ts->reg_vdd))\n\t\t\tregulator_disable(ts->reg_vdd);\n\n\t\treturn ret;\n\t}\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t \"%s/input0\", dev_name(&client->dev));\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"could not allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&ts->access_mutex);\n\tmutex_init(&ts->command_mutex);\n\n\tts->pdata = pdata;\n\tts->client = client;\n\tts->input = input_dev;\n\n\tinput_dev->name = \"Neonode zForce touchscreen\";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->id.bustype = BUS_I2C;\n\n\tinput_dev->open = zforce_input_open;\n\tinput_dev->close = zforce_input_close;\n\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(EV_SYN, input_dev->evbit);\n\t__set_bit(EV_ABS, input_dev->evbit);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,\n\t\t\t     pdata->x_max, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,\n\t\t\t     pdata->y_max, 0, 0);\n\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0,\n\t\t\t     ZFORCE_MAX_AREA, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0,\n\t\t\t     ZFORCE_MAX_AREA, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\n\tinput_mt_init_slots(input_dev, ZFORCE_REPORT_POINTS, INPUT_MT_DIRECT);\n\n\tinput_set_drvdata(ts->input, ts);\n\n\tinit_completion(&ts->command_done);\n\n\t \n\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tzforce_irq, zforce_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\tinput_dev->name, ts);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"irq %d request failed\\n\", client->irq);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, ts);\n\n\t \n\tzforce_reset_deassert(ts);\n\n\tts->command_waiting = NOTIFICATION_BOOTCOMPLETE;\n\tif (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0)\n\t\tdev_warn(&client->dev, \"bootcomplete timed out\\n\");\n\n\t \n\tret = zforce_command_wait(ts, COMMAND_INITIALIZE);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unable to initialize, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = zforce_command_wait(ts, COMMAND_STATUS);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"couldn't get status, %d\\n\", ret);\n\t\tzforce_stop(ts);\n\t\treturn ret;\n\t}\n\n\t \n\tret = zforce_stop(ts);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdevice_set_wakeup_capable(&client->dev, true);\n\n\tret = input_register_device(input_dev);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"could not register input device, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct i2c_device_id zforce_idtable[] = {\n\t{ \"zforce-ts\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, zforce_idtable);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id zforce_dt_idtable[] = {\n\t{ .compatible = \"neonode,zforce\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, zforce_dt_idtable);\n#endif\n\nstatic struct i2c_driver zforce_driver = {\n\t.driver = {\n\t\t.name\t= \"zforce-ts\",\n\t\t.pm\t= pm_sleep_ptr(&zforce_pm_ops),\n\t\t.of_match_table\t= of_match_ptr(zforce_dt_idtable),\n\t},\n\t.probe\t\t= zforce_probe,\n\t.id_table\t= zforce_idtable,\n};\n\nmodule_i2c_driver(zforce_driver);\n\nMODULE_AUTHOR(\"Heiko Stuebner <heiko@sntech.de>\");\nMODULE_DESCRIPTION(\"zForce TouchScreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}