{
  "module_name": "max11801_ts.c",
  "hash_id": "c5b821c31da567cd38dab72e8e0a9c9fb63e5e657b8f85f02e0cf78d54fdc1a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/max11801_ts.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n \n#define GENERNAL_STATUS_REG\t\t0x00\n#define GENERNAL_CONF_REG\t\t0x01\n#define MESURE_RES_CONF_REG\t\t0x02\n#define MESURE_AVER_CONF_REG\t\t0x03\n#define ADC_SAMPLE_TIME_CONF_REG\t0x04\n#define PANEL_SETUPTIME_CONF_REG\t0x05\n#define DELAY_CONVERSION_CONF_REG\t0x06\n#define TOUCH_DETECT_PULLUP_CONF_REG\t0x07\n#define AUTO_MODE_TIME_CONF_REG\t\t0x08  \n#define APERTURE_CONF_REG\t\t0x09  \n#define AUX_MESURE_CONF_REG\t\t0x0a\n#define OP_MODE_CONF_REG\t\t0x0b\n\n \n#define FIFO_RD_CMD\t\t\t(0x50 << 1)\n#define MAX11801_FIFO_INT\t\t(1 << 2)\n#define MAX11801_FIFO_OVERFLOW\t\t(1 << 3)\n\n#define XY_BUFSIZE\t\t\t4\n#define XY_BUF_OFFSET\t\t\t4\n\n#define MAX11801_MAX_X\t\t\t0xfff\n#define MAX11801_MAX_Y\t\t\t0xfff\n\n#define MEASURE_TAG_OFFSET\t\t2\n#define MEASURE_TAG_MASK\t\t(3 << MEASURE_TAG_OFFSET)\n#define EVENT_TAG_OFFSET\t\t0\n#define EVENT_TAG_MASK\t\t\t(3 << EVENT_TAG_OFFSET)\n#define MEASURE_X_TAG\t\t\t(0 << MEASURE_TAG_OFFSET)\n#define MEASURE_Y_TAG\t\t\t(1 << MEASURE_TAG_OFFSET)\n\n \nenum {\n\tEVENT_INIT,\n\tEVENT_MIDDLE,\n\tEVENT_RELEASE,\n\tEVENT_FIFO_END\n};\n\nstruct max11801_data {\n\tstruct i2c_client\t\t*client;\n\tstruct input_dev\t\t*input_dev;\n};\n\nstatic u8 read_register(struct i2c_client *client, int addr)\n{\n\t \n\treturn i2c_smbus_read_byte_data(client, addr << 1);\n}\n\nstatic int max11801_write_reg(struct i2c_client *client, int addr, int data)\n{\n\t \n\treturn i2c_smbus_write_byte_data(client, addr << 1, data);\n}\n\nstatic irqreturn_t max11801_ts_interrupt(int irq, void *dev_id)\n{\n\tstruct max11801_data *data = dev_id;\n\tstruct i2c_client *client = data->client;\n\tint status, i, ret;\n\tu8 buf[XY_BUFSIZE];\n\tint x = -1;\n\tint y = -1;\n\n\tstatus = read_register(data->client, GENERNAL_STATUS_REG);\n\n\tif (status & (MAX11801_FIFO_INT | MAX11801_FIFO_OVERFLOW)) {\n\t\tstatus = read_register(data->client, GENERNAL_STATUS_REG);\n\n\t\tret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_CMD,\n\t\t\t\t\t\t    XY_BUFSIZE, buf);\n\n\t\t \n\t\tif (ret < XY_BUFSIZE)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {\n\t\t\tif ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)\n\t\t\t\tx = (buf[i] << XY_BUF_OFFSET) +\n\t\t\t\t    (buf[i + 1] >> XY_BUF_OFFSET);\n\t\t\telse if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)\n\t\t\t\ty = (buf[i] << XY_BUF_OFFSET) +\n\t\t\t\t    (buf[i + 1] >> XY_BUF_OFFSET);\n\t\t}\n\n\t\tif ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))\n\t\t\tgoto out;\n\n\t\tswitch (buf[1] & EVENT_TAG_MASK) {\n\t\tcase EVENT_INIT:\n\t\tcase EVENT_MIDDLE:\n\t\t\tinput_report_abs(data->input_dev, ABS_X, x);\n\t\t\tinput_report_abs(data->input_dev, ABS_Y, y);\n\t\t\tinput_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);\n\t\t\tinput_sync(data->input_dev);\n\t\t\tbreak;\n\n\t\tcase EVENT_RELEASE:\n\t\t\tinput_event(data->input_dev, EV_KEY, BTN_TOUCH, 0);\n\t\t\tinput_sync(data->input_dev);\n\t\t\tbreak;\n\n\t\tcase EVENT_FIFO_END:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void max11801_ts_phy_init(struct max11801_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\n\t \n\tmax11801_write_reg(client, MESURE_AVER_CONF_REG, 0xff);\n\t \n\tmax11801_write_reg(client, PANEL_SETUPTIME_CONF_REG, 0x11);\n\t \n\tmax11801_write_reg(client, TOUCH_DETECT_PULLUP_CONF_REG, 0x10);\n\t \n\tmax11801_write_reg(client, AUTO_MODE_TIME_CONF_REG, 0xaa);\n\t \n\tmax11801_write_reg(client, APERTURE_CONF_REG, 0x33);\n\t \n\tmax11801_write_reg(client, OP_MODE_CONF_REG, 0x36);\n}\n\nstatic int max11801_ts_probe(struct i2c_client *client)\n{\n\tstruct max11801_data *data;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!data || !input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->client = client;\n\tdata->input_dev = input_dev;\n\n\tinput_dev->name = \"max11801_ts\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->dev.parent = &client->dev;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\tinput_set_abs_params(input_dev, ABS_X, 0, MAX11801_MAX_X, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MAX11801_MAX_Y, 0, 0);\n\n\tmax11801_ts_phy_init(data);\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t  max11801_ts_interrupt,\n\t\t\t\t\t  IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t  \"max11801_ts\", data);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(data->input_dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max11801_ts_id[] = {\n\t{\"max11801\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max11801_ts_id);\n\nstatic const struct of_device_id max11801_ts_dt_ids[] = {\n\t{ .compatible = \"maxim,max11801\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, max11801_ts_dt_ids);\n\nstatic struct i2c_driver max11801_ts_driver = {\n\t.driver = {\n\t\t.name\t= \"max11801_ts\",\n\t\t.of_match_table = max11801_ts_dt_ids,\n\t},\n\t.id_table\t= max11801_ts_id,\n\t.probe\t\t= max11801_ts_probe,\n};\n\nmodule_i2c_driver(max11801_ts_driver);\n\nMODULE_AUTHOR(\"Zhang Jiejing <jiejing.zhang@freescale.com>\");\nMODULE_DESCRIPTION(\"Touchscreen driver for MAXI MAX11801 controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}