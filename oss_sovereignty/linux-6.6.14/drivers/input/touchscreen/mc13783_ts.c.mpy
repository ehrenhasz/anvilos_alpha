{
  "module_name": "mc13783_ts.c",
  "hash_id": "b9fe12d2620970b7e650bb8d51f0fce70a6c4cb75ae1a102594a2b1c2f837cf2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mc13783_ts.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/mfd/mc13783.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\n#define MC13783_TS_NAME\t\"mc13783-ts\"\n\n#define DEFAULT_SAMPLE_TOLERANCE 300\n\nstatic unsigned int sample_tolerance = DEFAULT_SAMPLE_TOLERANCE;\nmodule_param(sample_tolerance, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(sample_tolerance,\n\t\t\"If the minimal and maximal value read out for one axis (out \"\n\t\t\"of three) differ by this value (default: \"\n\t\t__stringify(DEFAULT_SAMPLE_TOLERANCE) \") or more, the reading \"\n\t\t\"is supposed to be wrong and is discarded.  Set to 0 to \"\n\t\t\"disable this check.\");\n\nstruct mc13783_ts_priv {\n\tstruct input_dev *idev;\n\tstruct mc13xxx *mc13xxx;\n\tstruct delayed_work work;\n\tunsigned int sample[4];\n\tstruct mc13xxx_ts_platform_data *touch;\n};\n\nstatic irqreturn_t mc13783_ts_handler(int irq, void *data)\n{\n\tstruct mc13783_ts_priv *priv = data;\n\n\tmc13xxx_irq_ack(priv->mc13xxx, irq);\n\n\t \n\tschedule_delayed_work(&priv->work, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n#define sort3(a0, a1, a2) ({\t\t\t\t\t\t\\\n\t\tif (a0 > a1)\t\t\t\t\t\t\\\n\t\t\tswap(a0, a1);\t\t\t\t\t\\\n\t\tif (a1 > a2)\t\t\t\t\t\t\\\n\t\t\tswap(a1, a2);\t\t\t\t\t\\\n\t\tif (a0 > a1)\t\t\t\t\t\t\\\n\t\t\tswap(a0, a1);\t\t\t\t\t\\\n\t\t})\n\nstatic void mc13783_ts_report_sample(struct mc13783_ts_priv *priv)\n{\n\tstruct input_dev *idev = priv->idev;\n\tint x0, x1, x2, y0, y1, y2;\n\tint cr0, cr1;\n\n\t \n\tx0 = priv->sample[0] & 0xfff;\n\tx1 = priv->sample[1] & 0xfff;\n\tx2 = priv->sample[2] & 0xfff;\n\ty0 = priv->sample[3] & 0xfff;\n\ty1 = (priv->sample[0] >> 12) & 0xfff;\n\ty2 = (priv->sample[1] >> 12) & 0xfff;\n\tcr0 = (priv->sample[2] >> 12) & 0xfff;\n\tcr1 = (priv->sample[3] >> 12) & 0xfff;\n\n\tdev_dbg(&idev->dev,\n\t\t\"x: (% 4d,% 4d,% 4d) y: (% 4d, % 4d,% 4d) cr: (% 4d, % 4d)\\n\",\n\t\tx0, x1, x2, y0, y1, y2, cr0, cr1);\n\n\tsort3(x0, x1, x2);\n\tsort3(y0, y1, y2);\n\n\tcr0 = (cr0 + cr1) / 2;\n\n\tif (!cr0 || !sample_tolerance ||\n\t\t\t(x2 - x0 < sample_tolerance &&\n\t\t\t y2 - y0 < sample_tolerance)) {\n\t\t \n\t\tif (cr0) {\n\t\t\tinput_report_abs(idev, ABS_X, x1);\n\t\t\tinput_report_abs(idev, ABS_Y, y1);\n\n\t\t\tdev_dbg(&idev->dev, \"report (%d, %d, %d)\\n\",\n\t\t\t\t\tx1, y1, 0x1000 - cr0);\n\t\t\tschedule_delayed_work(&priv->work, HZ / 50);\n\t\t} else {\n\t\t\tdev_dbg(&idev->dev, \"report release\\n\");\n\t\t}\n\n\t\tinput_report_abs(idev, ABS_PRESSURE,\n\t\t\t\tcr0 ? 0x1000 - cr0 : cr0);\n\t\tinput_report_key(idev, BTN_TOUCH, cr0);\n\t\tinput_sync(idev);\n\t} else {\n\t\tdev_dbg(&idev->dev, \"discard event\\n\");\n\t}\n}\n\nstatic void mc13783_ts_work(struct work_struct *work)\n{\n\tstruct mc13783_ts_priv *priv =\n\t\tcontainer_of(work, struct mc13783_ts_priv, work.work);\n\tunsigned int mode = MC13XXX_ADC_MODE_TS;\n\tunsigned int channel = 12;\n\n\tif (mc13xxx_adc_do_conversion(priv->mc13xxx,\n\t\t\t\tmode, channel,\n\t\t\t\tpriv->touch->ato, priv->touch->atox,\n\t\t\t\tpriv->sample) == 0)\n\t\tmc13783_ts_report_sample(priv);\n}\n\nstatic int mc13783_ts_open(struct input_dev *dev)\n{\n\tstruct mc13783_ts_priv *priv = input_get_drvdata(dev);\n\tint ret;\n\n\tmc13xxx_lock(priv->mc13xxx);\n\n\tmc13xxx_irq_ack(priv->mc13xxx, MC13XXX_IRQ_TS);\n\n\tret = mc13xxx_irq_request(priv->mc13xxx, MC13XXX_IRQ_TS,\n\t\tmc13783_ts_handler, MC13783_TS_NAME, priv);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mc13xxx_reg_rmw(priv->mc13xxx, MC13XXX_ADC0,\n\t\t\tMC13XXX_ADC0_TSMOD_MASK, MC13XXX_ADC0_TSMOD0);\n\tif (ret)\n\t\tmc13xxx_irq_free(priv->mc13xxx, MC13XXX_IRQ_TS, priv);\nout:\n\tmc13xxx_unlock(priv->mc13xxx);\n\treturn ret;\n}\n\nstatic void mc13783_ts_close(struct input_dev *dev)\n{\n\tstruct mc13783_ts_priv *priv = input_get_drvdata(dev);\n\n\tmc13xxx_lock(priv->mc13xxx);\n\tmc13xxx_reg_rmw(priv->mc13xxx, MC13XXX_ADC0,\n\t\t\tMC13XXX_ADC0_TSMOD_MASK, 0);\n\tmc13xxx_irq_free(priv->mc13xxx, MC13XXX_IRQ_TS, priv);\n\tmc13xxx_unlock(priv->mc13xxx);\n\n\tcancel_delayed_work_sync(&priv->work);\n}\n\nstatic int __init mc13783_ts_probe(struct platform_device *pdev)\n{\n\tstruct mc13783_ts_priv *priv;\n\tstruct input_dev *idev;\n\tint ret = -ENOMEM;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tidev = input_allocate_device();\n\tif (!priv || !idev)\n\t\tgoto err_free_mem;\n\n\tINIT_DELAYED_WORK(&priv->work, mc13783_ts_work);\n\tpriv->mc13xxx = dev_get_drvdata(pdev->dev.parent);\n\tpriv->idev = idev;\n\tpriv->touch = dev_get_platdata(&pdev->dev);\n\tif (!priv->touch) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free_mem;\n\t}\n\n\tidev->name = MC13783_TS_NAME;\n\tidev->dev.parent = &pdev->dev;\n\n\tidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tidev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(idev, ABS_X, 0, 0xfff, 0, 0);\n\tinput_set_abs_params(idev, ABS_Y, 0, 0xfff, 0, 0);\n\tinput_set_abs_params(idev, ABS_PRESSURE, 0, 0xfff, 0, 0);\n\n\tidev->open = mc13783_ts_open;\n\tidev->close = mc13783_ts_close;\n\n\tinput_set_drvdata(idev, priv);\n\n\tret = input_register_device(priv->idev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"register input device failed with %d\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\treturn 0;\n\nerr_free_mem:\n\tinput_free_device(idev);\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic int mc13783_ts_remove(struct platform_device *pdev)\n{\n\tstruct mc13783_ts_priv *priv = platform_get_drvdata(pdev);\n\n\tinput_unregister_device(priv->idev);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mc13783_ts_driver = {\n\t.remove\t\t= mc13783_ts_remove,\n\t.driver\t\t= {\n\t\t.name\t= MC13783_TS_NAME,\n\t},\n};\n\nmodule_platform_driver_probe(mc13783_ts_driver, mc13783_ts_probe);\n\nMODULE_DESCRIPTION(\"MC13783 input touchscreen driver\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" MC13783_TS_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}