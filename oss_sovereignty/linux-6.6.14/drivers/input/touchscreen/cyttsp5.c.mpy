{
  "module_name": "cyttsp5.c",
  "hash_id": "8dd97611164d1ee3d3805237402bad101e3fd8365b5476b275c6960c8d5925a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cyttsp5.c",
  "human_readable_source": "\n \n\n#include <linux/crc-itu-t.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <asm/unaligned.h>\n\n#define CYTTSP5_NAME\t\t\t\t\"cyttsp5\"\n#define CY_I2C_DATA_SIZE\t\t\t(2 * 256)\n#define HID_VERSION\t\t\t\t0x0100\n#define CY_MAX_INPUT\t\t\t\t512\n#define CYTTSP5_PREALLOCATED_CMD_BUFFER\t\t32\n#define CY_BITS_PER_BTN\t\t\t\t1\n#define CY_NUM_BTN_EVENT_ID\t\t\tGENMASK(CY_BITS_PER_BTN - 1, 0)\n\n#define MAX_AREA\t\t\t\t255\n#define HID_OUTPUT_BL_SOP\t\t\t0x1\n#define HID_OUTPUT_BL_EOP\t\t\t0x17\n#define HID_OUTPUT_BL_LAUNCH_APP\t\t0x3B\n#define HID_OUTPUT_BL_LAUNCH_APP_SIZE\t\t11\n#define HID_OUTPUT_GET_SYSINFO\t\t\t0x2\n#define HID_OUTPUT_GET_SYSINFO_SIZE\t\t5\n#define HID_OUTPUT_MAX_CMD_SIZE\t\t\t12\n\n#define HID_DESC_REG\t\t\t\t0x1\n#define HID_INPUT_REG\t\t\t\t0x3\n#define HID_OUTPUT_REG\t\t\t\t0x4\n#define HID_COMMAND_REG\t\t\t\t0x5\n\n#define REPORT_ID_TOUCH\t\t\t\t0x1\n#define REPORT_ID_BTN\t\t\t\t0x3\n#define REPORT_SIZE_5\t\t\t\t5\n#define REPORT_SIZE_8\t\t\t\t8\n#define REPORT_SIZE_16\t\t\t\t16\n\n \n \n#define TOUCH_REPORT_DESC_HDR_CONTACTCOUNT\t16\n \n#define TOUCH_REPORT_DESC_CONTACTID\t\t8\n#define TOUCH_REPORT_DESC_X\t\t\t16\n#define TOUCH_REPORT_DESC_Y\t\t\t32\n#define TOUCH_REPORT_DESC_P\t\t\t48\n#define TOUCH_REPORT_DESC_MAJ\t\t\t56\n#define TOUCH_REPORT_DESC_MIN\t\t\t64\n\n \n#define HID_TOUCH_REPORT_ID\t\t\t0x1\n#define HID_BTN_REPORT_ID\t\t\t0x3\n#define HID_APP_RESPONSE_REPORT_ID\t\t0x1F\n#define HID_APP_OUTPUT_REPORT_ID\t\t0x2F\n#define HID_BL_RESPONSE_REPORT_ID\t\t0x30\n#define HID_BL_OUTPUT_REPORT_ID\t\t\t0x40\n#define HID_RESPONSE_REPORT_ID\t\t\t0xF0\n\n#define HID_OUTPUT_RESPONSE_REPORT_OFFSET\t2\n#define HID_OUTPUT_RESPONSE_CMD_OFFSET\t\t4\n#define HID_OUTPUT_RESPONSE_CMD_MASK\t\tGENMASK(6, 0)\n\n#define HID_SYSINFO_SENSING_OFFSET\t\t33\n#define HID_SYSINFO_BTN_OFFSET\t\t\t48\n#define HID_SYSINFO_BTN_MASK\t\t\tGENMASK(7, 0)\n#define HID_SYSINFO_MAX_BTN\t\t\t8\n\n#define HID_CMD_SET_POWER\t\t\t0x8\n\n#define HID_POWER_ON\t\t\t\t0x0\n#define HID_POWER_SLEEP\t\t\t\t0x1\n\n#define CY_HID_OUTPUT_TIMEOUT_MS\t\t200\n#define CY_HID_OUTPUT_GET_SYSINFO_TIMEOUT_MS\t3000\n#define CY_HID_GET_HID_DESCRIPTOR_TIMEOUT_MS\t4000\n#define CY_HID_SET_POWER_TIMEOUT\t\t500\n\n \n#define TOUCH_REPORT_SIZE\t\t\t10\n#define TOUCH_INPUT_HEADER_SIZE\t\t\t7\n#define BTN_REPORT_SIZE\t\t\t\t9\n#define BTN_INPUT_HEADER_SIZE\t\t\t5\n\n#define MAX_CY_TCH_T_IDS\t\t\t32\n\n \n#define TOUCH_REPORT_USAGE_PG_X\t\t\t0x00010030\n#define TOUCH_REPORT_USAGE_PG_Y\t\t\t0x00010031\n#define TOUCH_REPORT_USAGE_PG_P\t\t\t0x000D0030\n#define TOUCH_REPORT_USAGE_PG_CONTACTID\t\t0x000D0051\n#define TOUCH_REPORT_USAGE_PG_CONTACTCOUNT\t0x000D0054\n#define TOUCH_REPORT_USAGE_PG_MAJ\t\t0xFF010062\n#define TOUCH_REPORT_USAGE_PG_MIN\t\t0xFF010063\n#define TOUCH_COL_USAGE_PG\t\t\t0x000D0022\n\n#define SET_CMD_LOW(byte, bits) \\\n\t((byte) = (((byte) & 0xF0) | ((bits) & 0x0F)))\n#define SET_CMD_HIGH(byte, bits)\\\n\t((byte) = (((byte) & 0x0F) | ((bits) & 0xF0)))\n#define SET_CMD_OPCODE(byte, opcode) SET_CMD_LOW(byte, opcode)\n#define SET_CMD_REPORT_TYPE(byte, type) SET_CMD_HIGH(byte, ((type) << 4))\n#define SET_CMD_REPORT_ID(byte, id) SET_CMD_LOW(byte, id)\n\n \nstruct cyttsp5_sensing_conf_data_dev {\n\tu8 electrodes_x;\n\tu8 electrodes_y;\n\t__le16 len_x;\n\t__le16 len_y;\n\t__le16 res_x;\n\t__le16 res_y;\n\t__le16 max_z;\n\tu8 origin_x;\n\tu8 origin_y;\n\tu8 panel_id;\n\tu8 btn;\n\tu8 scan_mode;\n\tu8 max_num_of_tch_per_refresh_cycle;\n} __packed;\n\nstruct cyttsp5_sensing_conf_data {\n\tu16 res_x;\n\tu16 res_y;\n\tu16 max_z;\n\tu16 len_x;\n\tu16 len_y;\n\tu8 origin_x;\n\tu8 origin_y;\n\tu8 max_tch;\n};\n\nenum cyttsp5_tch_abs {\t \n\tCY_TCH_X,\t \n\tCY_TCH_Y,\t \n\tCY_TCH_P,\t \n\tCY_TCH_T,\t \n\tCY_TCH_MAJ,\t \n\tCY_TCH_MIN,\t \n\tCY_TCH_NUM_ABS\n};\n\nstruct cyttsp5_tch_abs_params {\n\tsize_t ofs;\t \n\tsize_t size;\t \n\tsize_t min;\t \n\tsize_t max;\t \n\tsize_t bofs;\t \n};\n\nstruct cyttsp5_touch {\n\tint abs[CY_TCH_NUM_ABS];\n};\n\nstruct cyttsp5_sysinfo {\n\tstruct cyttsp5_sensing_conf_data sensing_conf_data;\n\tint num_btns;\n\tstruct cyttsp5_tch_abs_params tch_hdr;\n\tstruct cyttsp5_tch_abs_params tch_abs[CY_TCH_NUM_ABS];\n\tu32 key_code[HID_SYSINFO_MAX_BTN];\n};\n\nstruct cyttsp5_hid_desc {\n\t__le16 hid_desc_len;\n\tu8 packet_id;\n\tu8 reserved_byte;\n\t__le16 bcd_version;\n\t__le16 report_desc_len;\n\t__le16 report_desc_register;\n\t__le16 input_register;\n\t__le16 max_input_len;\n\t__le16 output_register;\n\t__le16 max_output_len;\n\t__le16 command_register;\n\t__le16 data_register;\n\t__le16 vendor_id;\n\t__le16 product_id;\n\t__le16 version_id;\n\tu8 reserved[4];\n} __packed;\n\nstruct cyttsp5 {\n\tstruct device *dev;\n\tstruct completion cmd_done;\n\tstruct cyttsp5_sysinfo sysinfo;\n\tstruct cyttsp5_hid_desc hid_desc;\n\tu8 cmd_buf[CYTTSP5_PREALLOCATED_CMD_BUFFER];\n\tu8 input_buf[CY_MAX_INPUT];\n\tu8 response_buf[CY_MAX_INPUT];\n\tstruct gpio_desc *reset_gpio;\n\tstruct input_dev *input;\n\tchar phys[NAME_MAX];\n\tint num_prv_rec;\n\tstruct regmap *regmap;\n\tstruct touchscreen_properties prop;\n\tstruct regulator *vdd;\n};\n\n \nstatic int cyttsp5_read(struct cyttsp5 *ts, u8 *buf, u32 max)\n{\n\tint error;\n\tu32 size;\n\tu8 temp[2];\n\n\t \n\terror = regmap_bulk_read(ts->regmap, HID_INPUT_REG, temp, sizeof(temp));\n\tif (error)\n\t\treturn error;\n\n\tsize = get_unaligned_le16(temp);\n\tif (!size || size == 2)\n\t\treturn 0;\n\n\tif (size > max)\n\t\treturn -EINVAL;\n\n\t \n\treturn regmap_bulk_read(ts->regmap, HID_INPUT_REG, buf, size);\n}\n\nstatic int cyttsp5_write(struct cyttsp5 *ts, unsigned int reg, u8 *data,\n\t\t\t size_t size)\n{\n\tu8 cmd[HID_OUTPUT_MAX_CMD_SIZE];\n\n\tif (size + 1 > HID_OUTPUT_MAX_CMD_SIZE)\n\t\treturn -E2BIG;\n\n\t \n\tcmd[0] = (reg >> 8) & 0xFF;\n\n\t \n\tif (data)\n\t\tmemcpy(&cmd[1], data, size);\n\n\t \n\treturn regmap_bulk_write(ts->regmap, reg & 0xFF, cmd, size + 1);\n}\n\nstatic void cyttsp5_get_touch_axis(int *axis, int size, int max, u8 *xy_data,\n\t\t\t\t   int bofs)\n{\n\tint nbyte;\n\n\tfor (nbyte = 0, *axis = 0; nbyte < size; nbyte++)\n\t\t*axis += ((xy_data[nbyte] >> bofs) << (nbyte * 8));\n\n\t*axis &= max - 1;\n}\n\nstatic void cyttsp5_get_touch_record(struct cyttsp5 *ts,\n\t\t\t\t     struct cyttsp5_touch *touch, u8 *xy_data)\n{\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\tenum cyttsp5_tch_abs abs;\n\n\tfor (abs = CY_TCH_X; abs < CY_TCH_NUM_ABS; abs++)\n\t\tcyttsp5_get_touch_axis(&touch->abs[abs],\n\t\t\t\t       si->tch_abs[abs].size,\n\t\t\t\t       si->tch_abs[abs].max,\n\t\t\t\t       xy_data + si->tch_abs[abs].ofs,\n\t\t\t\t       si->tch_abs[abs].bofs);\n}\n\nstatic void cyttsp5_get_mt_touches(struct cyttsp5 *ts,\n\t\t\t\t   struct cyttsp5_touch *tch, int num_cur_tch)\n{\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\tint i, t = 0, offset = 0;\n\tDECLARE_BITMAP(ids, MAX_CY_TCH_T_IDS);\n\tu8 *tch_addr;\n\tint tmp;\n\n\tbitmap_zero(ids, MAX_CY_TCH_T_IDS);\n\tmemset(tch->abs, 0, sizeof(tch->abs));\n\n\tswitch (ts->input_buf[2]) {\n\tcase HID_TOUCH_REPORT_ID:\n\t\toffset = TOUCH_INPUT_HEADER_SIZE;\n\t\tbreak;\n\tcase HID_BTN_REPORT_ID:\n\t\toffset = BTN_INPUT_HEADER_SIZE;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < num_cur_tch; i++) {\n\t\ttch_addr = ts->input_buf + offset + (i * TOUCH_REPORT_SIZE);\n\t\tcyttsp5_get_touch_record(ts, tch, tch_addr);\n\n\t\t \n\t\ttmp = tch->abs[CY_TCH_MAJ] * 100 * si->sensing_conf_data.res_x;\n\t\ttch->abs[CY_TCH_MAJ] = tmp / si->sensing_conf_data.len_x;\n\t\ttmp = tch->abs[CY_TCH_MIN] * 100 * si->sensing_conf_data.res_x;\n\t\ttch->abs[CY_TCH_MIN] = tmp / si->sensing_conf_data.len_x;\n\n\t\tt = tch->abs[CY_TCH_T];\n\t\tinput_mt_slot(ts->input, t);\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\n\t\t__set_bit(t, ids);\n\n\t\t \n\t\ttouchscreen_report_pos(ts->input, &ts->prop,\n\t\t\t\t       tch->abs[CY_TCH_X], tch->abs[CY_TCH_Y],\n\t\t\t\t       true);\n\t\tinput_report_abs(ts->input, ABS_MT_PRESSURE,\n\t\t\t\t tch->abs[CY_TCH_P]);\n\n\t\t \n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t tch->abs[CY_TCH_MAJ]);\n\t\tinput_report_abs(ts->input, ABS_MT_TOUCH_MINOR,\n\t\t\t\t tch->abs[CY_TCH_MIN]);\n\t}\n\n\tts->num_prv_rec = num_cur_tch;\n}\n\nstatic int cyttsp5_mt_attention(struct device *dev)\n{\n\tstruct cyttsp5 *ts = dev_get_drvdata(dev);\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\tint max_tch = si->sensing_conf_data.max_tch;\n\tstruct cyttsp5_touch tch;\n\tint num_cur_tch;\n\n\tcyttsp5_get_touch_axis(&num_cur_tch, si->tch_hdr.size,\n\t\t\t       si->tch_hdr.max,\n\t\t\t       ts->input_buf + 3 + si->tch_hdr.ofs,\n\t\t\t       si->tch_hdr.bofs);\n\n\tif (num_cur_tch > max_tch) {\n\t\tdev_err(dev, \"Num touch err detected (n=%d)\\n\", num_cur_tch);\n\t\tnum_cur_tch = max_tch;\n\t}\n\n\tif (num_cur_tch == 0 && ts->num_prv_rec == 0)\n\t\treturn 0;\n\n\t \n\tif (num_cur_tch)\n\t\tcyttsp5_get_mt_touches(ts, &tch, num_cur_tch);\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n\n\treturn 0;\n}\n\nstatic int cyttsp5_setup_input_device(struct device *dev)\n{\n\tstruct cyttsp5 *ts = dev_get_drvdata(dev);\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\tint max_x, max_y, max_p;\n\tint max_x_tmp, max_y_tmp;\n\tint error;\n\n\tmax_x_tmp = si->sensing_conf_data.res_x;\n\tmax_y_tmp = si->sensing_conf_data.res_y;\n\tmax_x = max_x_tmp - 1;\n\tmax_y = max_y_tmp - 1;\n\tmax_p = si->sensing_conf_data.max_z;\n\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, max_p, 0, 0);\n\n\tinput_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, MAX_AREA, 0, 0);\n\tinput_set_abs_params(ts->input, ABS_MT_TOUCH_MINOR, 0, MAX_AREA, 0, 0);\n\n\terror = input_mt_init_slots(ts->input, si->tch_abs[CY_TCH_T].max,\n\t\t\t\t    INPUT_MT_DROP_UNUSED | INPUT_MT_DIRECT);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(ts->input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn error;\n}\n\nstatic int cyttsp5_parse_dt_key_code(struct device *dev)\n{\n\tstruct cyttsp5 *ts = dev_get_drvdata(dev);\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\n\tif (!si->num_btns)\n\t\treturn 0;\n\n\t \n\tmemset32(si->key_code, KEY_RESERVED,  si->num_btns);\n\n\treturn device_property_read_u32_array(dev, \"linux,keycodes\",\n\t\t\t\t\t      si->key_code, si->num_btns);\n}\n\nstatic int cyttsp5_btn_attention(struct device *dev)\n{\n\tstruct cyttsp5 *ts = dev_get_drvdata(dev);\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\tint cur_btn, offset = 0;\n\tint cur_btn_state;\n\n\tswitch (ts->input_buf[2]) {\n\tcase HID_TOUCH_REPORT_ID:\n\t\toffset = TOUCH_INPUT_HEADER_SIZE;\n\t\tbreak;\n\tcase HID_BTN_REPORT_ID:\n\t\toffset = BTN_INPUT_HEADER_SIZE;\n\t\tbreak;\n\t}\n\n\tif (ts->input_buf[2] != HID_BTN_REPORT_ID)\n\t\treturn 0;\n\n\t \n\tfor (cur_btn = 0; cur_btn < si->num_btns; cur_btn++) {\n\t\t \n\t\tcur_btn_state = (ts->input_buf[offset] >> (cur_btn * CY_BITS_PER_BTN))\n\t\t\t\t& CY_NUM_BTN_EVENT_ID;\n\n\t\tinput_report_key(ts->input, si->key_code[cur_btn],\n\t\t\t\t cur_btn_state);\n\t\tinput_sync(ts->input);\n\t}\n\n\treturn 0;\n}\n\nstatic int cyttsp5_validate_cmd_response(struct cyttsp5 *ts, u8 code)\n{\n\tu16 size, crc;\n\tu8 status, report_id;\n\tint command_code;\n\n\tsize = get_unaligned_le16(&ts->response_buf[0]);\n\tif (!size)\n\t\treturn 0;\n\n\treport_id = ts->response_buf[HID_OUTPUT_RESPONSE_REPORT_OFFSET];\n\n\tswitch (report_id) {\n\tcase HID_BL_RESPONSE_REPORT_ID:\n\t\tif (ts->response_buf[4] != HID_OUTPUT_BL_SOP) {\n\t\t\tdev_err(ts->dev, \"HID output response, wrong SOP\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tif (ts->response_buf[size - 1] != HID_OUTPUT_BL_EOP) {\n\t\t\tdev_err(ts->dev, \"HID output response, wrong EOP\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tcrc = crc_itu_t(0xFFFF, &ts->response_buf[4], size - 7);\n\t\tif (get_unaligned_le16(&ts->response_buf[size - 3]) != crc) {\n\t\t\tdev_err(ts->dev,\n\t\t\t\t\"HID output response, wrong CRC 0x%X\\n\",\n\t\t\t\tcrc);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tstatus = ts->response_buf[5];\n\t\tif (status) {\n\t\t\tdev_err(ts->dev, \"HID output response, ERROR:%d\\n\",\n\t\t\t\tstatus);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tbreak;\n\n\tcase HID_APP_RESPONSE_REPORT_ID:\n\t\tcommand_code = ts->response_buf[HID_OUTPUT_RESPONSE_CMD_OFFSET]\n\t\t\t& HID_OUTPUT_RESPONSE_CMD_MASK;\n\t\tif (command_code != code) {\n\t\t\tdev_err(ts->dev,\n\t\t\t\t\"HID output response, wrong command_code:%X\\n\",\n\t\t\t\tcommand_code);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void cyttsp5_si_get_btn_data(struct cyttsp5 *ts)\n{\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\tunsigned int btns = ts->response_buf[HID_SYSINFO_BTN_OFFSET] &\n\t\t\t\tHID_SYSINFO_BTN_MASK;\n\n\tsi->num_btns = hweight8(btns);\n}\n\nstatic int cyttsp5_get_sysinfo_regs(struct cyttsp5 *ts)\n{\n\tstruct cyttsp5_sensing_conf_data *scd = &ts->sysinfo.sensing_conf_data;\n\tstruct cyttsp5_sensing_conf_data_dev *scd_dev =\n\t\t(struct cyttsp5_sensing_conf_data_dev *)\n\t\t&ts->response_buf[HID_SYSINFO_SENSING_OFFSET];\n\n\tcyttsp5_si_get_btn_data(ts);\n\n\tscd->max_tch = scd_dev->max_num_of_tch_per_refresh_cycle;\n\tscd->res_x = get_unaligned_le16(&scd_dev->res_x);\n\tscd->res_y = get_unaligned_le16(&scd_dev->res_y);\n\tscd->max_z = get_unaligned_le16(&scd_dev->max_z);\n\tscd->len_x = get_unaligned_le16(&scd_dev->len_x);\n\tscd->len_y = get_unaligned_le16(&scd_dev->len_y);\n\n\treturn 0;\n}\n\nstatic int cyttsp5_hid_output_get_sysinfo(struct cyttsp5 *ts)\n{\n\tint rc;\n\tu8 cmd[HID_OUTPUT_GET_SYSINFO_SIZE];\n\n\t \n\tput_unaligned_le16(HID_OUTPUT_GET_SYSINFO_SIZE, cmd);\n\tcmd[2] = HID_APP_OUTPUT_REPORT_ID;\n\tcmd[3] = 0x0;  \n\tcmd[4] = HID_OUTPUT_GET_SYSINFO;\n\n\trc = cyttsp5_write(ts, HID_OUTPUT_REG, cmd,\n\t\t\t   HID_OUTPUT_GET_SYSINFO_SIZE);\n\tif (rc) {\n\t\tdev_err(ts->dev, \"Failed to write command %d\", rc);\n\t\treturn rc;\n\t}\n\n\trc = wait_for_completion_interruptible_timeout(&ts->cmd_done,\n\t\t\t\t\t\tmsecs_to_jiffies(CY_HID_OUTPUT_GET_SYSINFO_TIMEOUT_MS));\n\tif (rc <= 0) {\n\t\tdev_err(ts->dev, \"HID output cmd execution timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t\treturn rc;\n\t}\n\n\trc = cyttsp5_validate_cmd_response(ts, HID_OUTPUT_GET_SYSINFO);\n\tif (rc) {\n\t\tdev_err(ts->dev, \"Validation of the response failed\\n\");\n\t\treturn rc;\n\t}\n\n\treturn cyttsp5_get_sysinfo_regs(ts);\n}\n\nstatic int cyttsp5_power_control(struct cyttsp5 *ts, bool on)\n{\n\tu8 state = on ? HID_POWER_ON : HID_POWER_SLEEP;\n\tu8 cmd[2] = { 0 };\n\tint rc;\n\n\tSET_CMD_REPORT_TYPE(cmd[0], 0);\n\tSET_CMD_REPORT_ID(cmd[0], HID_POWER_SLEEP);\n\tSET_CMD_OPCODE(cmd[1], HID_CMD_SET_POWER);\n\n\trc = cyttsp5_write(ts, HID_COMMAND_REG, cmd, sizeof(cmd));\n\tif (rc) {\n\t\tdev_err(ts->dev, \"Failed to write power command %d\", rc);\n\t\treturn rc;\n\t}\n\n\trc = wait_for_completion_interruptible_timeout(&ts->cmd_done,\n\t\t\t\tmsecs_to_jiffies(CY_HID_SET_POWER_TIMEOUT));\n\tif (rc <= 0) {\n\t\tdev_err(ts->dev, \"HID power cmd execution timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (ts->response_buf[2] != HID_RESPONSE_REPORT_ID ||\n\t    (ts->response_buf[3] & 0x03) != state ||\n\t    (ts->response_buf[4] & 0x0f) != HID_CMD_SET_POWER) {\n\t\tdev_err(ts->dev, \"Validation of the %s response failed\\n\",\n\t\t\ton ? \"wakeup\" : \"sleep\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyttsp5_hid_output_bl_launch_app(struct cyttsp5 *ts)\n{\n\tint rc;\n\tu8 cmd[HID_OUTPUT_BL_LAUNCH_APP_SIZE];\n\tu16 crc;\n\n\tput_unaligned_le16(HID_OUTPUT_BL_LAUNCH_APP_SIZE, cmd);\n\tcmd[2] = HID_BL_OUTPUT_REPORT_ID;\n\tcmd[3] = 0x0;  \n\tcmd[4] = HID_OUTPUT_BL_SOP;\n\tcmd[5] = HID_OUTPUT_BL_LAUNCH_APP;\n\tput_unaligned_le16(0x00, &cmd[6]);\n\tcrc = crc_itu_t(0xFFFF, &cmd[4], 4);\n\tput_unaligned_le16(crc, &cmd[8]);\n\tcmd[10] = HID_OUTPUT_BL_EOP;\n\n\trc = cyttsp5_write(ts, HID_OUTPUT_REG, cmd,\n\t\t\t   HID_OUTPUT_BL_LAUNCH_APP_SIZE);\n\tif (rc) {\n\t\tdev_err(ts->dev, \"Failed to write command %d\", rc);\n\t\treturn rc;\n\t}\n\n\trc = wait_for_completion_interruptible_timeout(&ts->cmd_done,\n\t\t\t\tmsecs_to_jiffies(CY_HID_OUTPUT_TIMEOUT_MS));\n\tif (rc <= 0) {\n\t\tdev_err(ts->dev, \"HID output cmd execution timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t\treturn rc;\n\t}\n\n\trc = cyttsp5_validate_cmd_response(ts, HID_OUTPUT_BL_LAUNCH_APP);\n\tif (rc) {\n\t\tdev_err(ts->dev, \"Validation of the response failed\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyttsp5_get_hid_descriptor(struct cyttsp5 *ts,\n\t\t\t\t      struct cyttsp5_hid_desc *desc)\n{\n\tstruct device *dev = ts->dev;\n\tint rc;\n\n\trc = cyttsp5_write(ts, HID_DESC_REG, NULL, 0);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to get HID descriptor, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = wait_for_completion_interruptible_timeout(&ts->cmd_done,\n\t\t\tmsecs_to_jiffies(CY_HID_GET_HID_DESCRIPTOR_TIMEOUT_MS));\n\tif (rc <= 0) {\n\t\tdev_err(ts->dev, \"HID get descriptor timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t\treturn rc;\n\t}\n\n\tmemcpy(desc, ts->response_buf, sizeof(*desc));\n\n\t \n\tif (le16_to_cpu(desc->hid_desc_len) != sizeof(*desc) ||\n\t    le16_to_cpu(desc->bcd_version) != HID_VERSION) {\n\t\tdev_err(dev, \"Unsupported HID version\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_tch_abs(struct cyttsp5_tch_abs_params *tch_abs, int report_size,\n\t\t\tint offset)\n{\n\ttch_abs->ofs = offset / 8;\n\ttch_abs->size = report_size / 8;\n\tif (report_size % 8)\n\t\ttch_abs->size += 1;\n\ttch_abs->min = 0;\n\ttch_abs->max = 1 << report_size;\n\ttch_abs->bofs = offset - (tch_abs->ofs << 3);\n\n\treturn 0;\n}\n\nstatic irqreturn_t cyttsp5_handle_irq(int irq, void *handle)\n{\n\tstruct cyttsp5 *ts = handle;\n\tint report_id;\n\tint size;\n\tint error;\n\n\terror = cyttsp5_read(ts, ts->input_buf, CY_MAX_INPUT);\n\tif (error)\n\t\treturn IRQ_HANDLED;\n\n\tsize = get_unaligned_le16(&ts->input_buf[0]);\n\tif (size == 0) {\n\t\t \n\t\treport_id = 0;\n\t\tsize = 2;\n\t} else {\n\t\treport_id = ts->input_buf[2];\n\t}\n\n\tswitch (report_id) {\n\tcase HID_TOUCH_REPORT_ID:\n\t\tcyttsp5_mt_attention(ts->dev);\n\t\tbreak;\n\tcase HID_BTN_REPORT_ID:\n\t\tcyttsp5_btn_attention(ts->dev);\n\t\tbreak;\n\tcase HID_RESPONSE_REPORT_ID:\n\t\tmemcpy(ts->response_buf, ts->input_buf, size);\n\t\tcomplete(&ts->cmd_done);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmemcpy(ts->response_buf, ts->input_buf, size);\n\t\tcomplete(&ts->cmd_done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cyttsp5_deassert_int(struct cyttsp5 *ts)\n{\n\tu16 size;\n\tu8 buf[2];\n\tint error;\n\n\terror = regmap_bulk_read(ts->regmap, HID_INPUT_REG, buf, sizeof(buf));\n\tif (error < 0)\n\t\treturn error;\n\n\tsize = get_unaligned_le16(&buf[0]);\n\tif (size == 2 || size == 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int cyttsp5_fill_all_touch(struct cyttsp5 *ts)\n{\n\tstruct cyttsp5_sysinfo *si = &ts->sysinfo;\n\n\tfill_tch_abs(&si->tch_abs[CY_TCH_X], REPORT_SIZE_16,\n\t\t     TOUCH_REPORT_DESC_X);\n\tfill_tch_abs(&si->tch_abs[CY_TCH_Y], REPORT_SIZE_16,\n\t\t     TOUCH_REPORT_DESC_Y);\n\tfill_tch_abs(&si->tch_abs[CY_TCH_P], REPORT_SIZE_8,\n\t\t     TOUCH_REPORT_DESC_P);\n\tfill_tch_abs(&si->tch_abs[CY_TCH_T], REPORT_SIZE_5,\n\t\t     TOUCH_REPORT_DESC_CONTACTID);\n\tfill_tch_abs(&si->tch_hdr, REPORT_SIZE_5,\n\t\t     TOUCH_REPORT_DESC_HDR_CONTACTCOUNT);\n\tfill_tch_abs(&si->tch_abs[CY_TCH_MAJ], REPORT_SIZE_8,\n\t\t     TOUCH_REPORT_DESC_MAJ);\n\tfill_tch_abs(&si->tch_abs[CY_TCH_MIN], REPORT_SIZE_8,\n\t\t     TOUCH_REPORT_DESC_MIN);\n\n\treturn 0;\n}\n\nstatic int cyttsp5_startup(struct cyttsp5 *ts)\n{\n\tint error;\n\n\terror = cyttsp5_deassert_int(ts);\n\tif (error) {\n\t\tdev_err(ts->dev, \"Error on deassert int r=%d\\n\", error);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\terror = cyttsp5_hid_output_bl_launch_app(ts);\n\tif (error < 0) {\n\t\tdev_err(ts->dev, \"Error on launch app r=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = cyttsp5_get_hid_descriptor(ts, &ts->hid_desc);\n\tif (error < 0) {\n\t\tdev_err(ts->dev, \"Error on getting HID descriptor r=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = cyttsp5_fill_all_touch(ts);\n\tif (error < 0) {\n\t\tdev_err(ts->dev, \"Error on report descriptor r=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = cyttsp5_hid_output_get_sysinfo(ts);\n\tif (error) {\n\t\tdev_err(ts->dev, \"Error on getting sysinfo r=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn error;\n}\n\nstatic void cyttsp5_cleanup(void *data)\n{\n\tstruct cyttsp5 *ts = data;\n\n\tregulator_disable(ts->vdd);\n}\n\nstatic int cyttsp5_probe(struct device *dev, struct regmap *regmap, int irq,\n\t\t\t const char *name)\n{\n\tstruct cyttsp5 *ts;\n\tstruct cyttsp5_sysinfo *si;\n\tint error, i;\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\t \n\tts->regmap = regmap;\n\tts->dev = dev;\n\tsi = &ts->sysinfo;\n\tdev_set_drvdata(dev, ts);\n\n\tinit_completion(&ts->cmd_done);\n\n\t \n\tts->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(ts->vdd)) {\n\t\terror = PTR_ERR(ts->vdd);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, cyttsp5_cleanup, ts);\n\tif (error)\n\t\treturn error;\n\n\terror = regulator_enable(ts->vdd);\n\tif (error)\n\t\treturn error;\n\n\tts->input = devm_input_allocate_device(dev);\n\tif (!ts->input) {\n\t\tdev_err(dev, \"Error, failed to allocate input device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tts->input->name = \"cyttsp5\";\n\tscnprintf(ts->phys, sizeof(ts->phys), \"%s/input0\", dev_name(dev));\n\tts->input->phys = ts->phys;\n\tinput_set_drvdata(ts->input, ts);\n\n\t \n\tts->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(dev, \"Failed to request reset gpio, error %d\\n\", error);\n\t\treturn error;\n\t}\n\tgpiod_set_value_cansleep(ts->reset_gpio, 0);\n\n\t \n\tmsleep(20);\n\n\terror = devm_request_threaded_irq(dev, irq, NULL, cyttsp5_handle_irq,\n\t\t\t\t\t  IRQF_ONESHOT, name, ts);\n\tif (error) {\n\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\treturn error;\n\t}\n\n\terror = cyttsp5_startup(ts);\n\tif (error) {\n\t\tdev_err(ts->dev, \"Fail initial startup r=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = cyttsp5_parse_dt_key_code(dev);\n\tif (error < 0) {\n\t\tdev_err(ts->dev, \"Error while parsing dts %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ttouchscreen_parse_properties(ts->input, true, &ts->prop);\n\n\t__set_bit(EV_KEY, ts->input->evbit);\n\tfor (i = 0; i < si->num_btns; i++)\n\t\t__set_bit(si->key_code[i], ts->input->keybit);\n\n\treturn cyttsp5_setup_input_device(dev);\n}\n\nstatic int cyttsp5_i2c_probe(struct i2c_client *client)\n{\n\tstruct regmap *regmap;\n\tstatic const struct regmap_config config = {\n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t};\n\n\tregmap = devm_regmap_init_i2c(client, &config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"regmap allocation failed: %ld\\n\",\n\t\t\tPTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\treturn cyttsp5_probe(&client->dev, regmap, client->irq, client->name);\n}\n\nstatic const struct of_device_id cyttsp5_of_match[] = {\n\t{ .compatible = \"cypress,tt21000\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cyttsp5_of_match);\n\nstatic const struct i2c_device_id cyttsp5_i2c_id[] = {\n\t{ CYTTSP5_NAME, 0, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cyttsp5_i2c_id);\n\nstatic int __maybe_unused cyttsp5_suspend(struct device *dev)\n{\n\tstruct cyttsp5 *ts = dev_get_drvdata(dev);\n\n\tif (!device_may_wakeup(dev))\n\t\tcyttsp5_power_control(ts, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cyttsp5_resume(struct device *dev)\n{\n\tstruct cyttsp5 *ts = dev_get_drvdata(dev);\n\n\tif (!device_may_wakeup(dev))\n\t\tcyttsp5_power_control(ts, true);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cyttsp5_pm, cyttsp5_suspend, cyttsp5_resume);\n\nstatic struct i2c_driver cyttsp5_i2c_driver = {\n\t.driver = {\n\t\t.name = CYTTSP5_NAME,\n\t\t.of_match_table = cyttsp5_of_match,\n\t\t.pm = &cyttsp5_pm,\n\t},\n\t.probe = cyttsp5_i2c_probe,\n\t.id_table = cyttsp5_i2c_id,\n};\nmodule_i2c_driver(cyttsp5_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Touchscreen driver for Cypress TrueTouch Gen 5 Product\");\nMODULE_AUTHOR(\"Myl\u00e8ne Josserand <mylene.josserand@bootlin.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}