{
  "module_name": "da9052_tsi.c",
  "hash_id": "9de51da979e22c330f54d8e265dfb19421dcb864a2c9704c91a5389e7abe4d35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/da9052_tsi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n\n#include <linux/mfd/da9052/reg.h>\n#include <linux/mfd/da9052/da9052.h>\n\n#define TSI_PEN_DOWN_STATUS 0x40\n\nstruct da9052_tsi {\n\tstruct da9052 *da9052;\n\tstruct input_dev *dev;\n\tstruct delayed_work ts_pen_work;\n\tbool stopped;\n\tbool adc_on;\n};\n\nstatic void da9052_ts_adc_toggle(struct da9052_tsi *tsi, bool on)\n{\n\tda9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 1 << 0, on);\n\ttsi->adc_on = on;\n}\n\nstatic irqreturn_t da9052_ts_pendwn_irq(int irq, void *data)\n{\n\tstruct da9052_tsi *tsi = data;\n\n\tif (!tsi->stopped) {\n\t\t \n\t\tda9052_disable_irq_nosync(tsi->da9052, DA9052_IRQ_PENDOWN);\n\t\tda9052_enable_irq(tsi->da9052, DA9052_IRQ_TSIREADY);\n\n\t\tda9052_ts_adc_toggle(tsi, true);\n\n\t\tschedule_delayed_work(&tsi->ts_pen_work, HZ / 50);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void da9052_ts_read(struct da9052_tsi *tsi)\n{\n\tstruct input_dev *input = tsi->dev;\n\tint ret;\n\tu16 x, y, z;\n\tu8 v;\n\n\tret = da9052_reg_read(tsi->da9052, DA9052_TSI_X_MSB_REG);\n\tif (ret < 0)\n\t\treturn;\n\n\tx = (u16) ret;\n\n\tret = da9052_reg_read(tsi->da9052, DA9052_TSI_Y_MSB_REG);\n\tif (ret < 0)\n\t\treturn;\n\n\ty = (u16) ret;\n\n\tret = da9052_reg_read(tsi->da9052, DA9052_TSI_Z_MSB_REG);\n\tif (ret < 0)\n\t\treturn;\n\n\tz = (u16) ret;\n\n\tret = da9052_reg_read(tsi->da9052, DA9052_TSI_LSB_REG);\n\tif (ret < 0)\n\t\treturn;\n\n\tv = (u8) ret;\n\n\tx = ((x << 2) & 0x3fc) | (v & 0x3);\n\ty = ((y << 2) & 0x3fc) | ((v & 0xc) >> 2);\n\tz = ((z << 2) & 0x3fc) | ((v & 0x30) >> 4);\n\n\tinput_report_key(input, BTN_TOUCH, 1);\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\tinput_report_abs(input, ABS_PRESSURE, z);\n\tinput_sync(input);\n}\n\nstatic irqreturn_t da9052_ts_datardy_irq(int irq, void *data)\n{\n\tstruct da9052_tsi *tsi = data;\n\n\tda9052_ts_read(tsi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void da9052_ts_pen_work(struct work_struct *work)\n{\n\tstruct da9052_tsi *tsi = container_of(work, struct da9052_tsi,\n\t\t\t\t\t      ts_pen_work.work);\n\tif (!tsi->stopped) {\n\t\tint ret = da9052_reg_read(tsi->da9052, DA9052_TSI_LSB_REG);\n\t\tif (ret < 0 || (ret & TSI_PEN_DOWN_STATUS)) {\n\t\t\t \n\t\t\tschedule_delayed_work(&tsi->ts_pen_work, HZ / 50);\n\t\t} else {\n\t\t\tstruct input_dev *input = tsi->dev;\n\n\t\t\t \n\t\t\tda9052_ts_adc_toggle(tsi, false);\n\n\t\t\t \n\t\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t\t\tinput_report_abs(input, ABS_PRESSURE, 0);\n\t\t\tinput_sync(input);\n\n\t\t\t \n\t\t\tret = da9052_reg_update(tsi->da9052,\n\t\t\t\t\t\tDA9052_EVENT_B_REG, 0xC0, 0xC0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tda9052_disable_irq(tsi->da9052, DA9052_IRQ_TSIREADY);\n\t\t\tda9052_enable_irq(tsi->da9052, DA9052_IRQ_PENDOWN);\n\t\t}\n\t}\n}\n\nstatic int da9052_ts_configure_gpio(struct da9052 *da9052)\n{\n\tint error;\n\n\terror = da9052_reg_update(da9052, DA9052_GPIO_2_3_REG, 0x30, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = da9052_reg_update(da9052, DA9052_GPIO_4_5_REG, 0x33, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = da9052_reg_update(da9052, DA9052_GPIO_6_7_REG, 0x33, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int da9052_configure_tsi(struct da9052_tsi *tsi)\n{\n\tint error;\n\n\terror = da9052_ts_configure_gpio(tsi->da9052);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = da9052_reg_update(tsi->da9052, DA9052_ADC_CONT_REG,\n\t\t\t\t  1 << 6, 1 << 6);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\terror = da9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 0xFC, 0xC0);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\terror = da9052_reg_write(tsi->da9052, DA9052_LDO9_REG, 0x59);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int da9052_ts_input_open(struct input_dev *input_dev)\n{\n\tstruct da9052_tsi *tsi = input_get_drvdata(input_dev);\n\n\ttsi->stopped = false;\n\tmb();\n\n\t \n\tda9052_enable_irq(tsi->da9052, DA9052_IRQ_PENDOWN);\n\n\t \n\treturn da9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG,\n\t\t\t\t 1 << 1, 1 << 1);\n}\n\nstatic void da9052_ts_input_close(struct input_dev *input_dev)\n{\n\tstruct da9052_tsi *tsi = input_get_drvdata(input_dev);\n\n\ttsi->stopped = true;\n\tmb();\n\tda9052_disable_irq(tsi->da9052, DA9052_IRQ_PENDOWN);\n\tcancel_delayed_work_sync(&tsi->ts_pen_work);\n\n\tif (tsi->adc_on) {\n\t\tda9052_disable_irq(tsi->da9052, DA9052_IRQ_TSIREADY);\n\t\tda9052_ts_adc_toggle(tsi, false);\n\n\t\t \n\t\tda9052_enable_irq(tsi->da9052, DA9052_IRQ_PENDOWN);\n\t}\n\n\t \n\tda9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 1 << 1, 0);\n}\n\nstatic int da9052_ts_probe(struct platform_device *pdev)\n{\n\tstruct da9052 *da9052;\n\tstruct da9052_tsi *tsi;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tda9052 = dev_get_drvdata(pdev->dev.parent);\n\tif (!da9052)\n\t\treturn -EINVAL;\n\n\ttsi = kzalloc(sizeof(struct da9052_tsi), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!tsi || !input_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\ttsi->da9052 = da9052;\n\ttsi->dev = input_dev;\n\ttsi->stopped = true;\n\tINIT_DELAYED_WORK(&tsi->ts_pen_work, da9052_ts_pen_work);\n\n\tinput_dev->id.version = 0x0101;\n\tinput_dev->id.vendor = 0x15B6;\n\tinput_dev->id.product = 0x9052;\n\tinput_dev->name = \"Dialog DA9052 TouchScreen Driver\";\n\tinput_dev->dev.parent = &pdev->dev;\n\tinput_dev->open = da9052_ts_input_open;\n\tinput_dev->close = da9052_ts_input_close;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 1023, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 1023, 0, 0);\n\n\tinput_set_drvdata(input_dev, tsi);\n\n\t \n\tda9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 1 << 1, 0);\n\n\t \n\tda9052_ts_adc_toggle(tsi, false);\n\n\terror = da9052_request_irq(tsi->da9052, DA9052_IRQ_PENDOWN,\n\t\t\t\t\"pendown-irq\", da9052_ts_pendwn_irq, tsi);\n\tif (error) {\n\t\tdev_err(tsi->da9052->dev,\n\t\t\t\"Failed to register PENDWN IRQ: %d\\n\", error);\n\t\tgoto err_free_mem;\n\t}\n\n\terror = da9052_request_irq(tsi->da9052, DA9052_IRQ_TSIREADY,\n\t\t\t\t\"tsiready-irq\", da9052_ts_datardy_irq, tsi);\n\tif (error) {\n\t\tdev_err(tsi->da9052->dev,\n\t\t\t\"Failed to register TSIRDY IRQ :%d\\n\", error);\n\t\tgoto err_free_pendwn_irq;\n\t}\n\n\t \n\tda9052_disable_irq(tsi->da9052, DA9052_IRQ_PENDOWN);\n\tda9052_disable_irq(tsi->da9052, DA9052_IRQ_TSIREADY);\n\n\terror = da9052_configure_tsi(tsi);\n\tif (error)\n\t\tgoto err_free_datardy_irq;\n\n\terror = input_register_device(tsi->dev);\n\tif (error)\n\t\tgoto err_free_datardy_irq;\n\n\tplatform_set_drvdata(pdev, tsi);\n\n\treturn 0;\n\nerr_free_datardy_irq:\n\tda9052_free_irq(tsi->da9052, DA9052_IRQ_TSIREADY, tsi);\nerr_free_pendwn_irq:\n\tda9052_free_irq(tsi->da9052, DA9052_IRQ_PENDOWN, tsi);\nerr_free_mem:\n\tkfree(tsi);\n\tinput_free_device(input_dev);\n\n\treturn error;\n}\n\nstatic int  da9052_ts_remove(struct platform_device *pdev)\n{\n\tstruct da9052_tsi *tsi = platform_get_drvdata(pdev);\n\n\tda9052_reg_write(tsi->da9052, DA9052_LDO9_REG, 0x19);\n\n\tda9052_free_irq(tsi->da9052, DA9052_IRQ_TSIREADY, tsi);\n\tda9052_free_irq(tsi->da9052, DA9052_IRQ_PENDOWN, tsi);\n\n\tinput_unregister_device(tsi->dev);\n\tkfree(tsi);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9052_tsi_driver = {\n\t.probe\t= da9052_ts_probe,\n\t.remove\t= da9052_ts_remove,\n\t.driver\t= {\n\t\t.name\t= \"da9052-tsi\",\n\t},\n};\n\nmodule_platform_driver(da9052_tsi_driver);\n\nMODULE_DESCRIPTION(\"Touchscreen driver for Dialog Semiconductor DA9052\");\nMODULE_AUTHOR(\"Anthony Olech <Anthony.Olech@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-tsi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}