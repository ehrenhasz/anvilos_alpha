{
  "module_name": "sur40.c",
  "hash_id": "85e1b2d28dc9aa1fbffc9847c0d24edb7f942e1fd55d05f28c4347c97df6d1c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/sur40.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/printk.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/usb/input.h>\n#include <linux/videodev2.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-sg.h>\n\n \nstruct sur40_header {\n\n\t__le16 type;        \n\t__le16 count;       \n\n\t__le32 packet_id;   \n\n\t__le32 timestamp;   \n\t__le32 unknown;     \n\n} __packed;\n\nstruct sur40_blob {\n\n\t__le16 blob_id;\n\n\tu8 action;          \n\tu8 type;            \n\n\t__le16 bb_pos_x;    \n\t__le16 bb_pos_y;\n\n\t__le16 bb_size_x;   \n\t__le16 bb_size_y;\n\n\t__le16 pos_x;       \n\t__le16 pos_y;\n\n\t__le16 ctr_x;       \n\t__le16 ctr_y;\n\n\t__le16 axis_x;      \n\t__le16 axis_y;      \n\n\t__le32 angle;       \n\n\t__le32 area;        \n\n\tu8 padding[24];\n\n\t__le32 tag_id;      \n\t__le32 unknown;\n\n} __packed;\n\n \nstruct sur40_data {\n\tstruct sur40_header header;\n\tstruct sur40_blob   blobs[];\n} __packed;\n\n \nstruct sur40_image_header {\n\t__le32 magic;      \n\t__le32 packet_id;\n\t__le32 size;       \n\t__le32 timestamp;  \n\t__le32 unknown;    \n} __packed;\n\n \n#define DRIVER_SHORT   \"sur40\"\n#define DRIVER_LONG    \"Samsung SUR40\"\n#define DRIVER_AUTHOR  \"Florian 'floe' Echtler <floe@butterbrot.org>\"\n#define DRIVER_DESC    \"Surface2.0/SUR40/PixelSense input driver\"\n\n \n#define ID_MICROSOFT 0x045e\n#define ID_SUR40     0x0775\n\n \n#define SENSOR_RES_X 1920\n#define SENSOR_RES_Y 1080\n\n \n#define TOUCH_ENDPOINT 0x86\n\n \n#define VIDEO_ENDPOINT 0x82\n\n \n#define VIDEO_HEADER_MAGIC 0x46425553\n#define VIDEO_PACKET_SIZE  16384\n\n \n#define POLL_INTERVAL 1\n\n \n#define MAX_CONTACTS 64\n\n \n#define SUR40_GET_VERSION 0xb0  \n#define SUR40_ACCEL_CAPS  0xb3  \n#define SUR40_SENSOR_CAPS 0xc1  \n\n#define SUR40_POKE        0xc5  \n#define SUR40_PEEK        0xc4  \n\n#define SUR40_GET_STATE   0xc5  \n#define SUR40_GET_SENSORS 0xb1  \n\n#define SUR40_BLOB\t0x01\n#define SUR40_TOUCH\t0x02\n#define SUR40_TAG\t0x04\n\n \n#define SUR40_BRIGHTNESS_MAX 0xff\n#define SUR40_BRIGHTNESS_MIN 0x00\n#define SUR40_BRIGHTNESS_DEF 0xff\n\n#define SUR40_CONTRAST_MAX 0x0f\n#define SUR40_CONTRAST_MIN 0x00\n#define SUR40_CONTRAST_DEF 0x0a\n\n#define SUR40_GAIN_MAX 0x09\n#define SUR40_GAIN_MIN 0x00\n#define SUR40_GAIN_DEF 0x08\n\n#define SUR40_BACKLIGHT_MAX 0x01\n#define SUR40_BACKLIGHT_MIN 0x00\n#define SUR40_BACKLIGHT_DEF 0x01\n\n#define sur40_str(s) #s\n#define SUR40_PARAM_RANGE(lo, hi) \" (range \" sur40_str(lo) \"-\" sur40_str(hi) \")\"\n\n \nstatic uint brightness = SUR40_BRIGHTNESS_DEF;\nmodule_param(brightness, uint, 0644);\nMODULE_PARM_DESC(brightness, \"set initial brightness\"\n\tSUR40_PARAM_RANGE(SUR40_BRIGHTNESS_MIN, SUR40_BRIGHTNESS_MAX));\nstatic uint contrast = SUR40_CONTRAST_DEF;\nmodule_param(contrast, uint, 0644);\nMODULE_PARM_DESC(contrast, \"set initial contrast\"\n\tSUR40_PARAM_RANGE(SUR40_CONTRAST_MIN, SUR40_CONTRAST_MAX));\nstatic uint gain = SUR40_GAIN_DEF;\nmodule_param(gain, uint, 0644);\nMODULE_PARM_DESC(gain, \"set initial gain\"\n\tSUR40_PARAM_RANGE(SUR40_GAIN_MIN, SUR40_GAIN_MAX));\n\nstatic const struct v4l2_pix_format sur40_pix_format[] = {\n\t{\n\t\t.pixelformat = V4L2_TCH_FMT_TU08,\n\t\t.width  = SENSOR_RES_X / 2,\n\t\t.height = SENSOR_RES_Y / 2,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.colorspace = V4L2_COLORSPACE_RAW,\n\t\t.bytesperline = SENSOR_RES_X / 2,\n\t\t.sizeimage = (SENSOR_RES_X/2) * (SENSOR_RES_Y/2),\n\t},\n\t{\n\t\t.pixelformat = V4L2_PIX_FMT_GREY,\n\t\t.width  = SENSOR_RES_X / 2,\n\t\t.height = SENSOR_RES_Y / 2,\n\t\t.field = V4L2_FIELD_NONE,\n\t\t.colorspace = V4L2_COLORSPACE_RAW,\n\t\t.bytesperline = SENSOR_RES_X / 2,\n\t\t.sizeimage = (SENSOR_RES_X/2) * (SENSOR_RES_Y/2),\n\t}\n};\n\n \nstruct sur40_state {\n\n\tstruct usb_device *usbdev;\n\tstruct device *dev;\n\tstruct input_dev *input;\n\n\tstruct v4l2_device v4l2;\n\tstruct video_device vdev;\n\tstruct mutex lock;\n\tstruct v4l2_pix_format pix_fmt;\n\tstruct v4l2_ctrl_handler hdl;\n\n\tstruct vb2_queue queue;\n\tstruct list_head buf_list;\n\tspinlock_t qlock;\n\tint sequence;\n\n\tstruct sur40_data *bulk_in_buffer;\n\tsize_t bulk_in_size;\n\tu8 bulk_in_epaddr;\n\tu8 vsvideo;\n\n\tchar phys[64];\n};\n\nstruct sur40_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\n \nstatic const struct video_device sur40_video_device;\nstatic const struct vb2_queue sur40_queue;\nstatic void sur40_process_video(struct sur40_state *sur40);\nstatic int sur40_s_ctrl(struct v4l2_ctrl *ctrl);\n\nstatic const struct v4l2_ctrl_ops sur40_ctrl_ops = {\n\t.s_ctrl = sur40_s_ctrl,\n};\n\n \n\n \nstatic int sur40_command(struct sur40_state *dev,\n\t\t\t u8 command, u16 index, void *buffer, u16 size)\n{\n\treturn usb_control_msg(dev->usbdev, usb_rcvctrlpipe(dev->usbdev, 0),\n\t\t\t       command,\n\t\t\t       USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\t       0x00, index, buffer, size, 1000);\n}\n\n \nstatic int sur40_poke(struct sur40_state *dev, u8 offset, u8 value)\n{\n\tint result;\n\tu8 index = 0x96;  \n\n\tresult = usb_control_msg(dev->usbdev, usb_sndctrlpipe(dev->usbdev, 0),\n\t\tSUR40_POKE, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t0x32, index, NULL, 0, 1000);\n\tif (result < 0)\n\t\tgoto error;\n\tmsleep(5);\n\n\tresult = usb_control_msg(dev->usbdev, usb_sndctrlpipe(dev->usbdev, 0),\n\t\tSUR40_POKE, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t0x72, offset, NULL, 0, 1000);\n\tif (result < 0)\n\t\tgoto error;\n\tmsleep(5);\n\n\tresult = usb_control_msg(dev->usbdev, usb_sndctrlpipe(dev->usbdev, 0),\n\t\tSUR40_POKE, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t0xb2, value, NULL, 0, 1000);\n\tif (result < 0)\n\t\tgoto error;\n\tmsleep(5);\n\nerror:\n\treturn result;\n}\n\nstatic int sur40_set_preprocessor(struct sur40_state *dev, u8 value)\n{\n\tu8 setting_07[2] = { 0x01, 0x00 };\n\tu8 setting_17[2] = { 0x85, 0x80 };\n\tint result;\n\n\tif (value > 1)\n\t\treturn -ERANGE;\n\n\tresult = usb_control_msg(dev->usbdev, usb_sndctrlpipe(dev->usbdev, 0),\n\t\tSUR40_POKE, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t0x07, setting_07[value], NULL, 0, 1000);\n\tif (result < 0)\n\t\tgoto error;\n\tmsleep(5);\n\n\tresult = usb_control_msg(dev->usbdev, usb_sndctrlpipe(dev->usbdev, 0),\n\t\tSUR40_POKE, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t0x17, setting_17[value], NULL, 0, 1000);\n\tif (result < 0)\n\t\tgoto error;\n\tmsleep(5);\n\nerror:\n\treturn result;\n}\n\nstatic void sur40_set_vsvideo(struct sur40_state *handle, u8 value)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tsur40_poke(handle, 0x1c+i, value);\n\thandle->vsvideo = value;\n}\n\nstatic void sur40_set_irlevel(struct sur40_state *handle, u8 value)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tsur40_poke(handle, 0x08+(2*i), value);\n}\n\n \nstatic int sur40_init(struct sur40_state *dev)\n{\n\tint result;\n\tu8 *buffer;\n\n\tbuffer = kmalloc(24, GFP_KERNEL);\n\tif (!buffer) {\n\t\tresult = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tresult = sur40_command(dev, SUR40_GET_VERSION, 0x00, buffer, 12);\n\tif (result < 0)\n\t\tgoto error;\n\n\tresult = sur40_command(dev, SUR40_GET_VERSION, 0x01, buffer, 12);\n\tif (result < 0)\n\t\tgoto error;\n\n\tresult = sur40_command(dev, SUR40_GET_VERSION, 0x02, buffer, 12);\n\tif (result < 0)\n\t\tgoto error;\n\n\tresult = sur40_command(dev, SUR40_SENSOR_CAPS, 0x00, buffer, 24);\n\tif (result < 0)\n\t\tgoto error;\n\n\tresult = sur40_command(dev, SUR40_ACCEL_CAPS, 0x00, buffer, 5);\n\tif (result < 0)\n\t\tgoto error;\n\n\tresult = sur40_command(dev, SUR40_GET_VERSION, 0x03, buffer, 12);\n\tif (result < 0)\n\t\tgoto error;\n\n\tresult = 0;\n\n\t \nerror:\n\tkfree(buffer);\n\treturn result;\n}\n\n \n\n \nstatic int sur40_open(struct input_dev *input)\n{\n\tstruct sur40_state *sur40 = input_get_drvdata(input);\n\n\tdev_dbg(sur40->dev, \"open\\n\");\n\treturn sur40_init(sur40);\n}\n\n \nstatic void sur40_close(struct input_dev *input)\n{\n\tstruct sur40_state *sur40 = input_get_drvdata(input);\n\n\tdev_dbg(sur40->dev, \"close\\n\");\n\t \n}\n\n \nstatic void sur40_report_blob(struct sur40_blob *blob, struct input_dev *input)\n{\n\tint wide, major, minor;\n\tint bb_size_x, bb_size_y, pos_x, pos_y, ctr_x, ctr_y, slotnum;\n\n\tif (blob->type != SUR40_TOUCH)\n\t\treturn;\n\n\tslotnum = input_mt_get_slot_by_key(input, blob->blob_id);\n\tif (slotnum < 0 || slotnum >= MAX_CONTACTS)\n\t\treturn;\n\n\tbb_size_x = le16_to_cpu(blob->bb_size_x);\n\tbb_size_y = le16_to_cpu(blob->bb_size_y);\n\n\tpos_x = le16_to_cpu(blob->pos_x);\n\tpos_y = le16_to_cpu(blob->pos_y);\n\n\tctr_x = le16_to_cpu(blob->ctr_x);\n\tctr_y = le16_to_cpu(blob->ctr_y);\n\n\tinput_mt_slot(input, slotnum);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, 1);\n\twide = (bb_size_x > bb_size_y);\n\tmajor = max(bb_size_x, bb_size_y);\n\tminor = min(bb_size_x, bb_size_y);\n\n\tinput_report_abs(input, ABS_MT_POSITION_X, pos_x);\n\tinput_report_abs(input, ABS_MT_POSITION_Y, pos_y);\n\tinput_report_abs(input, ABS_MT_TOOL_X, ctr_x);\n\tinput_report_abs(input, ABS_MT_TOOL_Y, ctr_y);\n\n\t \n\tinput_report_abs(input, ABS_MT_ORIENTATION, wide);\n\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, major);\n\tinput_report_abs(input, ABS_MT_TOUCH_MINOR, minor);\n}\n\n \nstatic void sur40_poll(struct input_dev *input)\n{\n\tstruct sur40_state *sur40 = input_get_drvdata(input);\n\tint result, bulk_read, need_blobs, packet_blobs, i;\n\tstruct sur40_header *header = &sur40->bulk_in_buffer->header;\n\tstruct sur40_blob *inblob = &sur40->bulk_in_buffer->blobs[0];\n\n\tdev_dbg(sur40->dev, \"poll\\n\");\n\n\tneed_blobs = -1;\n\n\tdo {\n\n\t\t \n\t\tresult = usb_bulk_msg(sur40->usbdev,\n\t\t\tusb_rcvbulkpipe(sur40->usbdev, sur40->bulk_in_epaddr),\n\t\t\tsur40->bulk_in_buffer, sur40->bulk_in_size,\n\t\t\t&bulk_read, 1000);\n\n\t\tdev_dbg(sur40->dev, \"received %d bytes\\n\", bulk_read);\n\n\t\tif (result < 0) {\n\t\t\tdev_err(sur40->dev, \"error in usb_bulk_read\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tresult = bulk_read - sizeof(struct sur40_header);\n\n\t\tif (result % sizeof(struct sur40_blob) != 0) {\n\t\t\tdev_err(sur40->dev, \"transfer size mismatch\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (need_blobs == -1) {\n\t\t\tneed_blobs = le16_to_cpu(header->count);\n\t\t\tdev_dbg(sur40->dev, \"need %d blobs\\n\", need_blobs);\n\t\t\t \n\t\t}\n\n\t\t \n\n\t\tpacket_blobs = result / sizeof(struct sur40_blob);\n\t\tdev_dbg(sur40->dev, \"received %d blobs\\n\", packet_blobs);\n\n\t\t \n\t\tif (packet_blobs > need_blobs)\n\t\t\tpacket_blobs = need_blobs;\n\n\t\tfor (i = 0; i < packet_blobs; i++) {\n\t\t\tneed_blobs--;\n\t\t\tdev_dbg(sur40->dev, \"processing blob\\n\");\n\t\t\tsur40_report_blob(&(inblob[i]), input);\n\t\t}\n\n\t} while (need_blobs > 0);\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n\n\tsur40_process_video(sur40);\n}\n\n \nstatic void sur40_process_video(struct sur40_state *sur40)\n{\n\n\tstruct sur40_image_header *img = (void *)(sur40->bulk_in_buffer);\n\tstruct sur40_buffer *new_buf;\n\tstruct usb_sg_request sgr;\n\tstruct sg_table *sgt;\n\tint result, bulk_read;\n\n\tif (!vb2_start_streaming_called(&sur40->queue))\n\t\treturn;\n\n\t \n\tspin_lock(&sur40->qlock);\n\tif (list_empty(&sur40->buf_list)) {\n\t\tdev_dbg(sur40->dev, \"buffer queue empty\\n\");\n\t\tspin_unlock(&sur40->qlock);\n\t\treturn;\n\t}\n\tnew_buf = list_entry(sur40->buf_list.next, struct sur40_buffer, list);\n\tlist_del(&new_buf->list);\n\tspin_unlock(&sur40->qlock);\n\n\tdev_dbg(sur40->dev, \"buffer acquired\\n\");\n\n\t \n\tresult = usb_bulk_msg(sur40->usbdev,\n\t\t\tusb_rcvbulkpipe(sur40->usbdev, VIDEO_ENDPOINT),\n\t\t\tsur40->bulk_in_buffer, sur40->bulk_in_size,\n\t\t\t&bulk_read, 1000);\n\n\tif (result < 0) {\n\t\tdev_err(sur40->dev, \"error in usb_bulk_read\\n\");\n\t\tgoto err_poll;\n\t}\n\n\tif (bulk_read != sizeof(struct sur40_image_header)) {\n\t\tdev_err(sur40->dev, \"received %d bytes (%zd expected)\\n\",\n\t\t\tbulk_read, sizeof(struct sur40_image_header));\n\t\tgoto err_poll;\n\t}\n\n\tif (le32_to_cpu(img->magic) != VIDEO_HEADER_MAGIC) {\n\t\tdev_err(sur40->dev, \"image magic mismatch\\n\");\n\t\tgoto err_poll;\n\t}\n\n\tif (le32_to_cpu(img->size) != sur40->pix_fmt.sizeimage) {\n\t\tdev_err(sur40->dev, \"image size mismatch\\n\");\n\t\tgoto err_poll;\n\t}\n\n\tdev_dbg(sur40->dev, \"header acquired\\n\");\n\n\tsgt = vb2_dma_sg_plane_desc(&new_buf->vb.vb2_buf, 0);\n\n\tresult = usb_sg_init(&sgr, sur40->usbdev,\n\t\tusb_rcvbulkpipe(sur40->usbdev, VIDEO_ENDPOINT), 0,\n\t\tsgt->sgl, sgt->nents, sur40->pix_fmt.sizeimage, 0);\n\tif (result < 0) {\n\t\tdev_err(sur40->dev, \"error %d in usb_sg_init\\n\", result);\n\t\tgoto err_poll;\n\t}\n\n\tusb_sg_wait(&sgr);\n\tif (sgr.status < 0) {\n\t\tdev_err(sur40->dev, \"error %d in usb_sg_wait\\n\", sgr.status);\n\t\tgoto err_poll;\n\t}\n\n\tdev_dbg(sur40->dev, \"image acquired\\n\");\n\n\t \n\tif (sur40->sequence == -1)\n\t\treturn;\n\n\t \n\tnew_buf->vb.vb2_buf.timestamp = ktime_get_ns();\n\tnew_buf->vb.sequence = sur40->sequence++;\n\tnew_buf->vb.field = V4L2_FIELD_NONE;\n\tvb2_buffer_done(&new_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\tdev_dbg(sur40->dev, \"buffer marked done\\n\");\n\treturn;\n\nerr_poll:\n\tvb2_buffer_done(&new_buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n}\n\n \nstatic int sur40_input_setup_events(struct input_dev *input_dev)\n{\n\tint error;\n\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t     0, SENSOR_RES_X, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t     0, SENSOR_RES_Y, 0, 0);\n\n\tinput_set_abs_params(input_dev, ABS_MT_TOOL_X,\n\t\t\t     0, SENSOR_RES_X, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOOL_Y,\n\t\t\t     0, SENSOR_RES_Y, 0, 0);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, SENSOR_RES_X, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,\n\t\t\t     0, SENSOR_RES_Y, 0, 0);\n\n\tinput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\n\n\terror = input_mt_init_slots(input_dev, MAX_CONTACTS,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(input_dev->dev.parent, \"failed to set up slots\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sur40_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tstruct sur40_state *sur40;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct input_dev *input;\n\tint error;\n\n\t \n\tiface_desc = interface->cur_altsetting;\n\tif (iface_desc->desc.bInterfaceClass != 0xFF)\n\t\treturn -ENODEV;\n\n\tif (iface_desc->desc.bNumEndpoints < 5)\n\t\treturn -ENODEV;\n\n\t \n\tendpoint = &iface_desc->endpoint[4].desc;\n\tif (endpoint->bEndpointAddress != TOUCH_ENDPOINT)\n\t\treturn -ENODEV;\n\n\t \n\tsur40 = kzalloc(sizeof(struct sur40_state), GFP_KERNEL);\n\tif (!sur40)\n\t\treturn -ENOMEM;\n\n\tinput = input_allocate_device();\n\tif (!input) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&sur40->buf_list);\n\tspin_lock_init(&sur40->qlock);\n\tmutex_init(&sur40->lock);\n\n\t \n\tinput->name = DRIVER_LONG;\n\tusb_to_input_id(usbdev, &input->id);\n\tusb_make_path(usbdev, sur40->phys, sizeof(sur40->phys));\n\tstrlcat(sur40->phys, \"/input0\", sizeof(sur40->phys));\n\tinput->phys = sur40->phys;\n\tinput->dev.parent = &interface->dev;\n\n\tinput->open = sur40_open;\n\tinput->close = sur40_close;\n\n\terror = sur40_input_setup_events(input);\n\tif (error)\n\t\tgoto err_free_input;\n\n\tinput_set_drvdata(input, sur40);\n\terror = input_setup_polling(input, sur40_poll);\n\tif (error) {\n\t\tdev_err(&interface->dev, \"failed to set up polling\");\n\t\tgoto err_free_input;\n\t}\n\n\tinput_set_poll_interval(input, POLL_INTERVAL);\n\n\tsur40->usbdev = usbdev;\n\tsur40->dev = &interface->dev;\n\tsur40->input = input;\n\n\t \n\tsur40->bulk_in_size = usb_endpoint_maxp(endpoint);\n\tsur40->bulk_in_epaddr = endpoint->bEndpointAddress;\n\tsur40->bulk_in_buffer = kmalloc(sur40->bulk_in_size, GFP_KERNEL);\n\tif (!sur40->bulk_in_buffer) {\n\t\tdev_err(&interface->dev, \"Unable to allocate input buffer.\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_input;\n\t}\n\n\t \n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Unable to register polled input device.\");\n\t\tgoto err_free_buffer;\n\t}\n\n\t \n\tsnprintf(sur40->v4l2.name, sizeof(sur40->v4l2.name), \"%s\", DRIVER_LONG);\n\terror = v4l2_device_register(sur40->dev, &sur40->v4l2);\n\tif (error) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Unable to register video master device.\");\n\t\tgoto err_unreg_v4l2;\n\t}\n\n\t \n\tsur40->queue = sur40_queue;\n\tsur40->queue.drv_priv = sur40;\n\tsur40->queue.lock = &sur40->lock;\n\tsur40->queue.dev = sur40->dev;\n\n\t \n\terror = vb2_queue_init(&sur40->queue);\n\tif (error)\n\t\tgoto err_unreg_v4l2;\n\n\tsur40->pix_fmt = sur40_pix_format[0];\n\tsur40->vdev = sur40_video_device;\n\tsur40->vdev.v4l2_dev = &sur40->v4l2;\n\tsur40->vdev.lock = &sur40->lock;\n\tsur40->vdev.queue = &sur40->queue;\n\tvideo_set_drvdata(&sur40->vdev, sur40);\n\n\t \n\tv4l2_ctrl_handler_init(&sur40->hdl, 4);\n\tsur40->v4l2.ctrl_handler = &sur40->hdl;\n\tsur40->vsvideo = (SUR40_CONTRAST_DEF << 4) | SUR40_GAIN_DEF;\n\n\tv4l2_ctrl_new_std(&sur40->hdl, &sur40_ctrl_ops, V4L2_CID_BRIGHTNESS,\n\t  SUR40_BRIGHTNESS_MIN, SUR40_BRIGHTNESS_MAX, 1, clamp(brightness,\n\t  (uint)SUR40_BRIGHTNESS_MIN, (uint)SUR40_BRIGHTNESS_MAX));\n\n\tv4l2_ctrl_new_std(&sur40->hdl, &sur40_ctrl_ops, V4L2_CID_CONTRAST,\n\t  SUR40_CONTRAST_MIN, SUR40_CONTRAST_MAX, 1, clamp(contrast,\n\t  (uint)SUR40_CONTRAST_MIN, (uint)SUR40_CONTRAST_MAX));\n\n\tv4l2_ctrl_new_std(&sur40->hdl, &sur40_ctrl_ops, V4L2_CID_GAIN,\n\t  SUR40_GAIN_MIN, SUR40_GAIN_MAX, 1, clamp(gain,\n\t  (uint)SUR40_GAIN_MIN, (uint)SUR40_GAIN_MAX));\n\n\tv4l2_ctrl_new_std(&sur40->hdl, &sur40_ctrl_ops,\n\t  V4L2_CID_BACKLIGHT_COMPENSATION, SUR40_BACKLIGHT_MIN,\n\t  SUR40_BACKLIGHT_MAX, 1, SUR40_BACKLIGHT_DEF);\n\n\tv4l2_ctrl_handler_setup(&sur40->hdl);\n\n\tif (sur40->hdl.error) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Unable to register video controls.\");\n\t\tv4l2_ctrl_handler_free(&sur40->hdl);\n\t\terror = sur40->hdl.error;\n\t\tgoto err_unreg_v4l2;\n\t}\n\n\terror = video_register_device(&sur40->vdev, VFL_TYPE_TOUCH, -1);\n\tif (error) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Unable to register video subdevice.\");\n\t\tgoto err_unreg_video;\n\t}\n\n\t \n\tusb_set_intfdata(interface, sur40);\n\tdev_dbg(&interface->dev, \"%s is now attached\\n\", DRIVER_DESC);\n\n\treturn 0;\n\nerr_unreg_video:\n\tvideo_unregister_device(&sur40->vdev);\nerr_unreg_v4l2:\n\tv4l2_device_unregister(&sur40->v4l2);\nerr_free_buffer:\n\tkfree(sur40->bulk_in_buffer);\nerr_free_input:\n\tinput_free_device(input);\nerr_free_dev:\n\tkfree(sur40);\n\n\treturn error;\n}\n\n \nstatic void sur40_disconnect(struct usb_interface *interface)\n{\n\tstruct sur40_state *sur40 = usb_get_intfdata(interface);\n\n\tv4l2_ctrl_handler_free(&sur40->hdl);\n\tvideo_unregister_device(&sur40->vdev);\n\tv4l2_device_unregister(&sur40->v4l2);\n\n\tinput_unregister_device(sur40->input);\n\tkfree(sur40->bulk_in_buffer);\n\tkfree(sur40);\n\n\tusb_set_intfdata(interface, NULL);\n\tdev_dbg(&interface->dev, \"%s is now disconnected\\n\", DRIVER_DESC);\n}\n\n \nstatic int sur40_queue_setup(struct vb2_queue *q,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct sur40_state *sur40 = vb2_get_drv_priv(q);\n\n\tif (q->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - q->num_buffers;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < sur40->pix_fmt.sizeimage ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = sur40->pix_fmt.sizeimage;\n\n\treturn 0;\n}\n\n \nstatic int sur40_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct sur40_state *sur40 = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = sur40->pix_fmt.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_err(&sur40->usbdev->dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\treturn 0;\n}\n\n \nstatic void sur40_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct sur40_state *sur40 = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct sur40_buffer *buf = (struct sur40_buffer *)vb;\n\n\tspin_lock(&sur40->qlock);\n\tlist_add_tail(&buf->list, &sur40->buf_list);\n\tspin_unlock(&sur40->qlock);\n}\n\nstatic void return_all_buffers(struct sur40_state *sur40,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tstruct sur40_buffer *buf, *node;\n\n\tspin_lock(&sur40->qlock);\n\tlist_for_each_entry_safe(buf, node, &sur40->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock(&sur40->qlock);\n}\n\n \nstatic int sur40_start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct sur40_state *sur40 = vb2_get_drv_priv(vq);\n\n\tsur40->sequence = 0;\n\treturn 0;\n}\n\n \nstatic void sur40_stop_streaming(struct vb2_queue *vq)\n{\n\tstruct sur40_state *sur40 = vb2_get_drv_priv(vq);\n\tvb2_wait_for_all_buffers(vq);\n\tsur40->sequence = -1;\n\n\t \n\treturn_all_buffers(sur40, VB2_BUF_STATE_ERROR);\n}\n\n \nstatic int sur40_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t struct v4l2_capability *cap)\n{\n\tstruct sur40_state *sur40 = video_drvdata(file);\n\n\tstrscpy(cap->driver, DRIVER_SHORT, sizeof(cap->driver));\n\tstrscpy(cap->card, DRIVER_LONG, sizeof(cap->card));\n\tusb_make_path(sur40->usbdev, cap->bus_info, sizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int sur40_vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_input *i)\n{\n\tif (i->index != 0)\n\t\treturn -EINVAL;\n\ti->type = V4L2_INPUT_TYPE_TOUCH;\n\ti->std = V4L2_STD_UNKNOWN;\n\tstrscpy(i->name, \"In-Cell Sensor\", sizeof(i->name));\n\ti->capabilities = 0;\n\treturn 0;\n}\n\nstatic int sur40_vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn (i == 0) ? 0 : -EINVAL;\n}\n\nstatic int sur40_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int sur40_vidioc_try_fmt(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_GREY:\n\t\tf->fmt.pix = sur40_pix_format[1];\n\t\tbreak;\n\n\tdefault:\n\t\tf->fmt.pix = sur40_pix_format[0];\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sur40_vidioc_s_fmt(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct sur40_state *sur40 = video_drvdata(file);\n\n\tswitch (f->fmt.pix.pixelformat) {\n\tcase V4L2_PIX_FMT_GREY:\n\t\tsur40->pix_fmt = sur40_pix_format[1];\n\t\tbreak;\n\n\tdefault:\n\t\tsur40->pix_fmt = sur40_pix_format[0];\n\t\tbreak;\n\t}\n\n\tf->fmt.pix = sur40->pix_fmt;\n\treturn 0;\n}\n\nstatic int sur40_vidioc_g_fmt(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *f)\n{\n\tstruct sur40_state *sur40 = video_drvdata(file);\n\n\tf->fmt.pix = sur40->pix_fmt;\n\treturn 0;\n}\n\nstatic int sur40_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct sur40_state *sur40  = container_of(ctrl->handler,\n\t  struct sur40_state, hdl);\n\tu8 value = sur40->vsvideo;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\tsur40_set_irlevel(sur40, ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\tvalue = (value & 0x0f) | (ctrl->val << 4);\n\t\tsur40_set_vsvideo(sur40, value);\n\t\tbreak;\n\tcase V4L2_CID_GAIN:\n\t\tvalue = (value & 0xf0) | (ctrl->val);\n\t\tsur40_set_vsvideo(sur40, value);\n\t\tbreak;\n\tcase V4L2_CID_BACKLIGHT_COMPENSATION:\n\t\tsur40_set_preprocessor(sur40, ctrl->val);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sur40_ioctl_parm(struct file *file, void *priv,\n\t\t\t    struct v4l2_streamparm *p)\n{\n\tif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tp->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\n\tp->parm.capture.timeperframe.numerator = 1;\n\tp->parm.capture.timeperframe.denominator = 60;\n\tp->parm.capture.readbuffers = 3;\n\treturn 0;\n}\n\nstatic int sur40_vidioc_enum_fmt(struct file *file, void *priv,\n\t\t\t\t struct v4l2_fmtdesc *f)\n{\n\tif (f->index >= ARRAY_SIZE(sur40_pix_format))\n\t\treturn -EINVAL;\n\n\tf->pixelformat = sur40_pix_format[f->index].pixelformat;\n\tf->flags = 0;\n\treturn 0;\n}\n\nstatic int sur40_vidioc_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t\tstruct v4l2_frmsizeenum *f)\n{\n\tstruct sur40_state *sur40 = video_drvdata(file);\n\n\tif ((f->index != 0) || ((f->pixel_format != V4L2_TCH_FMT_TU08)\n\t\t&& (f->pixel_format != V4L2_PIX_FMT_GREY)))\n\t\treturn -EINVAL;\n\n\tf->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tf->discrete.width  = sur40->pix_fmt.width;\n\tf->discrete.height = sur40->pix_fmt.height;\n\treturn 0;\n}\n\nstatic int sur40_vidioc_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t\t    struct v4l2_frmivalenum *f)\n{\n\tstruct sur40_state *sur40 = video_drvdata(file);\n\n\tif ((f->index > 0) || ((f->pixel_format != V4L2_TCH_FMT_TU08)\n\t\t&& (f->pixel_format != V4L2_PIX_FMT_GREY))\n\t\t|| (f->width  != sur40->pix_fmt.width)\n\t\t|| (f->height != sur40->pix_fmt.height))\n\t\treturn -EINVAL;\n\n\tf->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tf->discrete.denominator  = 60;\n\tf->discrete.numerator = 1;\n\treturn 0;\n}\n\n\nstatic const struct usb_device_id sur40_table[] = {\n\t{ USB_DEVICE(ID_MICROSOFT, ID_SUR40) },   \n\t{ }                                       \n};\nMODULE_DEVICE_TABLE(usb, sur40_table);\n\n \nstatic const struct vb2_ops sur40_queue_ops = {\n\t.queue_setup\t\t= sur40_queue_setup,\n\t.buf_prepare\t\t= sur40_buffer_prepare,\n\t.buf_queue\t\t= sur40_buffer_queue,\n\t.start_streaming\t= sur40_start_streaming,\n\t.stop_streaming\t\t= sur40_stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\nstatic const struct vb2_queue sur40_queue = {\n\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t \n\t.io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF,\n\t.buf_struct_size = sizeof(struct sur40_buffer),\n\t.ops = &sur40_queue_ops,\n\t.mem_ops = &vb2_dma_sg_memops,\n\t.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC,\n\t.min_buffers_needed = 3,\n};\n\nstatic const struct v4l2_file_operations sur40_video_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll,\n};\n\nstatic const struct v4l2_ioctl_ops sur40_video_ioctl_ops = {\n\n\t.vidioc_querycap\t= sur40_vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = sur40_vidioc_enum_fmt,\n\t.vidioc_try_fmt_vid_cap\t= sur40_vidioc_try_fmt,\n\t.vidioc_s_fmt_vid_cap\t= sur40_vidioc_s_fmt,\n\t.vidioc_g_fmt_vid_cap\t= sur40_vidioc_g_fmt,\n\n\t.vidioc_enum_framesizes = sur40_vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals = sur40_vidioc_enum_frameintervals,\n\n\t.vidioc_g_parm = sur40_ioctl_parm,\n\t.vidioc_s_parm = sur40_ioctl_parm,\n\n\t.vidioc_enum_input\t= sur40_vidioc_enum_input,\n\t.vidioc_g_input\t\t= sur40_vidioc_g_input,\n\t.vidioc_s_input\t\t= sur40_vidioc_s_input,\n\n\t.vidioc_reqbufs\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t= vb2_ioctl_expbuf,\n\n\t.vidioc_streamon\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t= vb2_ioctl_streamoff,\n};\n\nstatic const struct video_device sur40_video_device = {\n\t.name = DRIVER_LONG,\n\t.fops = &sur40_video_fops,\n\t.ioctl_ops = &sur40_video_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TOUCH |\n\t\t       V4L2_CAP_READWRITE | V4L2_CAP_STREAMING,\n};\n\n \nstatic struct usb_driver sur40_driver = {\n\t.name = DRIVER_SHORT,\n\t.probe = sur40_probe,\n\t.disconnect = sur40_disconnect,\n\t.id_table = sur40_table,\n};\n\nmodule_usb_driver(sur40_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}