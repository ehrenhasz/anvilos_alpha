{
  "module_name": "ar1021_i2c.c",
  "hash_id": "043617c46d56d8000baba81629773af034f864b9de61257f0527a9abf52b85bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ar1021_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/of.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n\n#define AR1021_TOUCH_PKG_SIZE\t5\n\n#define AR1021_MAX_X\t4095\n#define AR1021_MAX_Y\t4095\n\n#define AR1021_CMD\t0x55\n\n#define AR1021_CMD_ENABLE_TOUCH\t\t0x12\n\nstruct ar1021_i2c {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tu8 data[AR1021_TOUCH_PKG_SIZE];\n};\n\nstatic irqreturn_t ar1021_i2c_irq(int irq, void *dev_id)\n{\n\tstruct ar1021_i2c *ar1021 = dev_id;\n\tstruct input_dev *input = ar1021->input;\n\tu8 *data = ar1021->data;\n\tunsigned int x, y, button;\n\tint retval;\n\n\tretval = i2c_master_recv(ar1021->client,\n\t\t\t\t ar1021->data, sizeof(ar1021->data));\n\tif (retval != sizeof(ar1021->data))\n\t\tgoto out;\n\n\t \n\tif (!(data[0] & BIT(7)))\n\t\tgoto out;\n\n\tbutton = data[0] & BIT(0);\n\tx = ((data[2] & 0x1f) << 7) | (data[1] & 0x7f);\n\ty = ((data[4] & 0x1f) << 7) | (data[3] & 0x7f);\n\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\tinput_report_key(input, BTN_TOUCH, button);\n\tinput_sync(input);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int ar1021_i2c_open(struct input_dev *dev)\n{\n\tstatic const u8 cmd_enable_touch[] = {\n\t\tAR1021_CMD,\n\t\t0x01,  \n\t\tAR1021_CMD_ENABLE_TOUCH\n\t};\n\tstruct ar1021_i2c *ar1021 = input_get_drvdata(dev);\n\tstruct i2c_client *client = ar1021->client;\n\tint error;\n\n\terror = i2c_master_send(ar1021->client, cmd_enable_touch,\n\t\t\t\tsizeof(cmd_enable_touch));\n\tif (error < 0)\n\t\treturn error;\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic void ar1021_i2c_close(struct input_dev *dev)\n{\n\tstruct ar1021_i2c *ar1021 = input_get_drvdata(dev);\n\tstruct i2c_client *client = ar1021->client;\n\n\tdisable_irq(client->irq);\n}\n\nstatic int ar1021_i2c_probe(struct i2c_client *client)\n{\n\tstruct ar1021_i2c *ar1021;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c_check_functionality error\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tar1021 = devm_kzalloc(&client->dev, sizeof(*ar1021), GFP_KERNEL);\n\tif (!ar1021)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tar1021->client = client;\n\tar1021->input = input;\n\n\tinput->name = \"ar1021 I2C Touchscreen\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->dev.parent = &client->dev;\n\tinput->open = ar1021_i2c_open;\n\tinput->close = ar1021_i2c_close;\n\n\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input, ABS_X, 0, AR1021_MAX_X, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, AR1021_MAX_Y, 0, 0);\n\n\tinput_set_drvdata(input, ar1021);\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, ar1021_i2c_irq,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  \"ar1021_i2c\", ar1021);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to enable IRQ, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ar1021->input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ar1021_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int ar1021_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ar1021_i2c_pm,\n\t\t\t\tar1021_i2c_suspend, ar1021_i2c_resume);\n\nstatic const struct i2c_device_id ar1021_i2c_id[] = {\n\t{ \"ar1021\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, ar1021_i2c_id);\n\nstatic const struct of_device_id ar1021_i2c_of_match[] = {\n\t{ .compatible = \"microchip,ar1021-i2c\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ar1021_i2c_of_match);\n\nstatic struct i2c_driver ar1021_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"ar1021_i2c\",\n\t\t.pm\t= pm_sleep_ptr(&ar1021_i2c_pm),\n\t\t.of_match_table = ar1021_i2c_of_match,\n\t},\n\n\t.probe\t\t= ar1021_i2c_probe,\n\t.id_table\t= ar1021_i2c_id,\n};\nmodule_i2c_driver(ar1021_i2c_driver);\n\nMODULE_AUTHOR(\"Christian Gmeiner <christian.gmeiner@gmail.com>\");\nMODULE_DESCRIPTION(\"Microchip AR1020 and AR1021 I2C Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}