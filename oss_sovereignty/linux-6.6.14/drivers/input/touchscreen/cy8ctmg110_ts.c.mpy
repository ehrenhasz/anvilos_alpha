{
  "module_name": "cy8ctmg110_ts.c",
  "hash_id": "498da7dc65863f049d538662e48fcf106cbf99435b483b7e25dc5e0fdd526469",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cy8ctmg110_ts.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n#define CY8CTMG110_DRIVER_NAME      \"cy8ctmg110\"\n\n \n#define CY8CTMG110_X_MIN\t\t0\n#define CY8CTMG110_Y_MIN\t\t0\n#define CY8CTMG110_X_MAX\t\t759\n#define CY8CTMG110_Y_MAX\t\t465\n\n\n \n#define CY8CTMG110_TOUCH_WAKEUP_TIME\t0\n#define CY8CTMG110_TOUCH_SLEEP_TIME\t2\n#define CY8CTMG110_TOUCH_X1\t\t3\n#define CY8CTMG110_TOUCH_Y1\t\t5\n#define CY8CTMG110_TOUCH_X2\t\t7\n#define CY8CTMG110_TOUCH_Y2\t\t9\n#define CY8CTMG110_FINGERS\t\t11\n#define CY8CTMG110_GESTURE\t\t12\n#define CY8CTMG110_REG_MAX\t\t13\n\n\n \nstruct cy8ctmg110 {\n\tstruct input_dev *input;\n\tchar phys[32];\n\tstruct i2c_client *client;\n\tstruct gpio_desc *reset_gpio;\n};\n\n \nstatic void cy8ctmg110_power(struct cy8ctmg110 *ts, bool poweron)\n{\n\tif (ts->reset_gpio)\n\t\tgpiod_set_value_cansleep(ts->reset_gpio, !poweron);\n}\n\nstatic int cy8ctmg110_write_regs(struct cy8ctmg110 *tsc, unsigned char reg,\n\t\tunsigned char len, unsigned char *value)\n{\n\tstruct i2c_client *client = tsc->client;\n\tint ret;\n\tunsigned char i2c_data[6];\n\n\tBUG_ON(len > 5);\n\n\ti2c_data[0] = reg;\n\tmemcpy(i2c_data + 1, value, len);\n\n\tret = i2c_master_send(client, i2c_data, len + 1);\n\tif (ret != len + 1) {\n\t\tdev_err(&client->dev, \"i2c write data cmd failed\\n\");\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cy8ctmg110_read_regs(struct cy8ctmg110 *tsc,\n\t\tunsigned char *data, unsigned char len, unsigned char cmd)\n{\n\tstruct i2c_client *client = tsc->client;\n\tint ret;\n\tstruct i2c_msg msg[2] = {\n\t\t \n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &cmd\n\t\t},\n\t\t \n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = data\n\t\t}\n\t};\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cy8ctmg110_touch_pos(struct cy8ctmg110 *tsc)\n{\n\tstruct input_dev *input = tsc->input;\n\tunsigned char reg_p[CY8CTMG110_REG_MAX];\n\n\tmemset(reg_p, 0, CY8CTMG110_REG_MAX);\n\n\t \n\tif (cy8ctmg110_read_regs(tsc, reg_p, 9, CY8CTMG110_TOUCH_X1) != 0)\n\t\treturn -EIO;\n\n\t \n\tif (reg_p[8] == 0) {\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t} else  {\n\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\tinput_report_abs(input, ABS_X,\n\t\t\t\t be16_to_cpup((__be16 *)(reg_p + 0)));\n\t\tinput_report_abs(input, ABS_Y,\n\t\t\t\t be16_to_cpup((__be16 *)(reg_p + 2)));\n\t}\n\n\tinput_sync(input);\n\n\treturn 0;\n}\n\nstatic int cy8ctmg110_set_sleepmode(struct cy8ctmg110 *ts, bool sleep)\n{\n\tunsigned char reg_p[3];\n\n\tif (sleep) {\n\t\treg_p[0] = 0x00;\n\t\treg_p[1] = 0xff;\n\t\treg_p[2] = 5;\n\t} else {\n\t\treg_p[0] = 0x10;\n\t\treg_p[1] = 0xff;\n\t\treg_p[2] = 0;\n\t}\n\n\treturn cy8ctmg110_write_regs(ts, CY8CTMG110_TOUCH_WAKEUP_TIME, 3, reg_p);\n}\n\nstatic irqreturn_t cy8ctmg110_irq_thread(int irq, void *dev_id)\n{\n\tstruct cy8ctmg110 *tsc = dev_id;\n\n\tcy8ctmg110_touch_pos(tsc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void cy8ctmg110_shut_off(void *_ts)\n{\n\tstruct cy8ctmg110 *ts = _ts;\n\n\tcy8ctmg110_set_sleepmode(ts, true);\n\tcy8ctmg110_power(ts, false);\n}\n\nstatic int cy8ctmg110_probe(struct i2c_client *client)\n{\n\tstruct cy8ctmg110 *ts;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -EIO;\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\tts->input = input_dev;\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t \"%s/input0\", dev_name(&client->dev));\n\n\tinput_dev->name = CY8CTMG110_DRIVER_NAME \" Touchscreen\";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->id.bustype = BUS_I2C;\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\tCY8CTMG110_X_MIN, CY8CTMG110_X_MAX, 4, 0);\n\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\tCY8CTMG110_Y_MIN, CY8CTMG110_Y_MAX, 4, 0);\n\n\t \n\tts->reset_gpio = devm_gpiod_get_optional(&client->dev, NULL,\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terr = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to request reset GPIO: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tcy8ctmg110_power(ts, true);\n\tcy8ctmg110_set_sleepmode(ts, false);\n\n\terr = devm_add_action_or_reset(&client->dev, cy8ctmg110_shut_off, ts);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, cy8ctmg110_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT, \"touch_reset_key\", ts);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"irq %d busy? error %d\\n\", client->irq, err);\n\t\treturn err;\n\t}\n\n\terr = input_register_device(input_dev);\n\tif (err)\n\t\treturn err;\n\n\ti2c_set_clientdata(client, ts);\n\n\treturn 0;\n}\n\nstatic int cy8ctmg110_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cy8ctmg110 *ts = i2c_get_clientdata(client);\n\n\tif (!device_may_wakeup(&client->dev)) {\n\t\tcy8ctmg110_set_sleepmode(ts, true);\n\t\tcy8ctmg110_power(ts, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int cy8ctmg110_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cy8ctmg110 *ts = i2c_get_clientdata(client);\n\n\tif (!device_may_wakeup(&client->dev)) {\n\t\tcy8ctmg110_power(ts, true);\n\t\tcy8ctmg110_set_sleepmode(ts, false);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cy8ctmg110_pm,\n\t\t\t\tcy8ctmg110_suspend, cy8ctmg110_resume);\n\nstatic const struct i2c_device_id cy8ctmg110_idtable[] = {\n\t{ CY8CTMG110_DRIVER_NAME, 1 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, cy8ctmg110_idtable);\n\nstatic struct i2c_driver cy8ctmg110_driver = {\n\t.driver\t\t= {\n\t\t.name\t= CY8CTMG110_DRIVER_NAME,\n\t\t.pm\t= pm_sleep_ptr(&cy8ctmg110_pm),\n\t},\n\t.id_table\t= cy8ctmg110_idtable,\n\t.probe\t\t= cy8ctmg110_probe,\n};\n\nmodule_i2c_driver(cy8ctmg110_driver);\n\nMODULE_AUTHOR(\"Samuli Konttila <samuli.konttila@aavamobile.com>\");\nMODULE_DESCRIPTION(\"cy8ctmg110 TouchScreen Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}