{
  "module_name": "raspberrypi-ts.c",
  "hash_id": "660fa719304be36301e49f38d9a1e6819ceec259c345fe50d7336bed971c83d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/raspberrypi-ts.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <soc/bcm2835/raspberrypi-firmware.h>\n\n#define RPI_TS_DEFAULT_WIDTH\t800\n#define RPI_TS_DEFAULT_HEIGHT\t480\n\n#define RPI_TS_MAX_SUPPORTED_POINTS\t10\n\n#define RPI_TS_FTS_TOUCH_DOWN\t\t0\n#define RPI_TS_FTS_TOUCH_CONTACT\t2\n\n#define RPI_TS_POLL_INTERVAL\t\t17\t \n\n#define RPI_TS_NPOINTS_REG_INVALIDATE\t99\n\nstruct rpi_ts {\n\tstruct platform_device *pdev;\n\tstruct input_dev *input;\n\tstruct touchscreen_properties prop;\n\n\tvoid __iomem *fw_regs_va;\n\tdma_addr_t fw_regs_phys;\n\n\tint known_ids;\n};\n\nstruct rpi_ts_regs {\n\tu8 device_mode;\n\tu8 gesture_id;\n\tu8 num_points;\n\tstruct rpi_ts_touch {\n\t\tu8 xh;\n\t\tu8 xl;\n\t\tu8 yh;\n\t\tu8 yl;\n\t\tu8 pressure;  \n\t\tu8 area;      \n\t} point[RPI_TS_MAX_SUPPORTED_POINTS];\n};\n\nstatic void rpi_ts_poll(struct input_dev *input)\n{\n\tstruct rpi_ts *ts = input_get_drvdata(input);\n\tstruct rpi_ts_regs regs;\n\tint modified_ids = 0;\n\tlong released_ids;\n\tint event_type;\n\tint touchid;\n\tint x, y;\n\tint i;\n\n\tmemcpy_fromio(&regs, ts->fw_regs_va, sizeof(regs));\n\t \n\tiowrite8(RPI_TS_NPOINTS_REG_INVALIDATE,\n\t\t ts->fw_regs_va + offsetof(struct rpi_ts_regs, num_points));\n\n\tif (regs.num_points == RPI_TS_NPOINTS_REG_INVALIDATE ||\n\t    (regs.num_points == 0 && ts->known_ids == 0))\n\t\treturn;\n\n\tfor (i = 0; i < regs.num_points; i++) {\n\t\tx = (((int)regs.point[i].xh & 0xf) << 8) + regs.point[i].xl;\n\t\ty = (((int)regs.point[i].yh & 0xf) << 8) + regs.point[i].yl;\n\t\ttouchid = (regs.point[i].yh >> 4) & 0xf;\n\t\tevent_type = (regs.point[i].xh >> 6) & 0x03;\n\n\t\tmodified_ids |= BIT(touchid);\n\n\t\tif (event_type == RPI_TS_FTS_TOUCH_DOWN ||\n\t\t    event_type == RPI_TS_FTS_TOUCH_CONTACT) {\n\t\t\tinput_mt_slot(input, touchid);\n\t\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, 1);\n\t\t\ttouchscreen_report_pos(input, &ts->prop, x, y, true);\n\t\t}\n\t}\n\n\treleased_ids = ts->known_ids & ~modified_ids;\n\tfor_each_set_bit(i, &released_ids, RPI_TS_MAX_SUPPORTED_POINTS) {\n\t\tinput_mt_slot(input, i);\n\t\tinput_mt_report_slot_inactive(input);\n\t\tmodified_ids &= ~(BIT(i));\n\t}\n\tts->known_ids = modified_ids;\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n}\n\nstatic void rpi_ts_dma_cleanup(void *data)\n{\n\tstruct rpi_ts *ts = data;\n\tstruct device *dev = &ts->pdev->dev;\n\n\tdma_free_coherent(dev, PAGE_SIZE, ts->fw_regs_va, ts->fw_regs_phys);\n}\n\nstatic int rpi_ts_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct input_dev *input;\n\tstruct device_node *fw_node;\n\tstruct rpi_firmware *fw;\n\tstruct rpi_ts *ts;\n\tu32 touchbuf;\n\tint error;\n\n\tfw_node = of_get_parent(np);\n\tif (!fw_node) {\n\t\tdev_err(dev, \"Missing firmware node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tfw = devm_rpi_firmware_get(&pdev->dev, fw_node);\n\tof_node_put(fw_node);\n\tif (!fw)\n\t\treturn -EPROBE_DEFER;\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\tts->pdev = pdev;\n\n\tts->fw_regs_va = dma_alloc_coherent(dev, PAGE_SIZE, &ts->fw_regs_phys,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!ts->fw_regs_va) {\n\t\tdev_err(dev, \"failed to dma_alloc_coherent\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terror = devm_add_action_or_reset(dev, rpi_ts_dma_cleanup, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to devm_add_action_or_reset, %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ttouchbuf = (u32)ts->fw_regs_phys;\n\terror = rpi_firmware_property(fw, RPI_FIRMWARE_FRAMEBUFFER_SET_TOUCHBUF,\n\t\t\t\t      &touchbuf, sizeof(touchbuf));\n\tif (error || touchbuf != 0) {\n\t\tdev_warn(dev, \"Failed to set touchbuf, %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->input = input;\n\tinput_set_drvdata(input, ts);\n\n\tinput->name = \"raspberrypi-ts\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0,\n\t\t\t     RPI_TS_DEFAULT_WIDTH, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\n\t\t\t     RPI_TS_DEFAULT_HEIGHT, 0, 0);\n\ttouchscreen_parse_properties(input, true, &ts->prop);\n\n\terror = input_mt_init_slots(input, RPI_TS_MAX_SUPPORTED_POINTS,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(dev, \"could not init mt slots, %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_setup_polling(input, rpi_ts_poll);\n\tif (error) {\n\t\tdev_err(dev, \"could not set up polling mode, %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput_set_poll_interval(input, RPI_TS_POLL_INTERVAL);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"could not register input device, %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rpi_ts_match[] = {\n\t{ .compatible = \"raspberrypi,firmware-ts\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rpi_ts_match);\n\nstatic struct platform_driver rpi_ts_driver = {\n\t.driver = {\n\t\t.name = \"raspberrypi-ts\",\n\t\t.of_match_table = rpi_ts_match,\n\t},\n\t.probe = rpi_ts_probe,\n};\nmodule_platform_driver(rpi_ts_driver);\n\nMODULE_AUTHOR(\"Gordon Hollingworth\");\nMODULE_AUTHOR(\"Nicolas Saenz Julienne <nsaenzjulienne@suse.de>\");\nMODULE_DESCRIPTION(\"Raspberry Pi firmware based touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}