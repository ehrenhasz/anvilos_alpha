{
  "module_name": "imx6ul_tsc.c",
  "hash_id": "b6ad0aa94ac654b52df80157dc270276cfaf02f97d7388663383593d493fafa1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/imx6ul_tsc.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n\n \n#define ADC_AIEN\t\t(0x1 << 7)\n#define ADC_CONV_DISABLE\t0x1F\n#define ADC_AVGE\t\t(0x1 << 5)\n#define ADC_CAL\t\t\t(0x1 << 7)\n#define ADC_CALF\t\t0x2\n#define ADC_12BIT_MODE\t\t(0x2 << 2)\n#define ADC_CONV_MODE_MASK\t(0x3 << 2)\n#define ADC_IPG_CLK\t\t0x00\n#define ADC_INPUT_CLK_MASK\t0x3\n#define ADC_CLK_DIV_8\t\t(0x03 << 5)\n#define ADC_CLK_DIV_MASK\t(0x3 << 5)\n#define ADC_SHORT_SAMPLE_MODE\t(0x0 << 4)\n#define ADC_SAMPLE_MODE_MASK\t(0x1 << 4)\n#define ADC_HARDWARE_TRIGGER\t(0x1 << 13)\n#define ADC_AVGS_SHIFT\t\t14\n#define ADC_AVGS_MASK\t\t(0x3 << 14)\n#define SELECT_CHANNEL_4\t0x04\n#define SELECT_CHANNEL_1\t0x01\n#define DISABLE_CONVERSION_INT\t(0x0 << 7)\n\n \n#define REG_ADC_HC0\t\t0x00\n#define REG_ADC_HC1\t\t0x04\n#define REG_ADC_HC2\t\t0x08\n#define REG_ADC_HC3\t\t0x0C\n#define REG_ADC_HC4\t\t0x10\n#define REG_ADC_HS\t\t0x14\n#define REG_ADC_R0\t\t0x18\n#define REG_ADC_CFG\t\t0x2C\n#define REG_ADC_GC\t\t0x30\n#define REG_ADC_GS\t\t0x34\n\n#define ADC_TIMEOUT\t\tmsecs_to_jiffies(100)\n\n \n#define REG_TSC_BASIC_SETING\t0x00\n#define REG_TSC_PRE_CHARGE_TIME\t0x10\n#define REG_TSC_FLOW_CONTROL\t0x20\n#define REG_TSC_MEASURE_VALUE\t0x30\n#define REG_TSC_INT_EN\t\t0x40\n#define REG_TSC_INT_SIG_EN\t0x50\n#define REG_TSC_INT_STATUS\t0x60\n#define REG_TSC_DEBUG_MODE\t0x70\n#define REG_TSC_DEBUG_MODE2\t0x80\n\n \n#define DETECT_4_WIRE_MODE\t(0x0 << 4)\n#define AUTO_MEASURE\t\t0x1\n#define MEASURE_SIGNAL\t\t0x1\n#define DETECT_SIGNAL\t\t(0x1 << 4)\n#define VALID_SIGNAL\t\t(0x1 << 8)\n#define MEASURE_INT_EN\t\t0x1\n#define MEASURE_SIG_EN\t\t0x1\n#define VALID_SIG_EN\t\t(0x1 << 8)\n#define DE_GLITCH_2\t\t(0x2 << 29)\n#define START_SENSE\t\t(0x1 << 12)\n#define TSC_DISABLE\t\t(0x1 << 16)\n#define DETECT_MODE\t\t0x2\n\nstruct imx6ul_tsc {\n\tstruct device *dev;\n\tstruct input_dev *input;\n\tvoid __iomem *tsc_regs;\n\tvoid __iomem *adc_regs;\n\tstruct clk *tsc_clk;\n\tstruct clk *adc_clk;\n\tstruct gpio_desc *xnur_gpio;\n\n\tu32 measure_delay_time;\n\tu32 pre_charge_time;\n\tbool average_enable;\n\tu32 average_select;\n\n\tstruct completion completion;\n};\n\n \nstatic int imx6ul_adc_init(struct imx6ul_tsc *tsc)\n{\n\tu32 adc_hc = 0;\n\tu32 adc_gc;\n\tu32 adc_gs;\n\tu32 adc_cfg;\n\tunsigned long timeout;\n\n\treinit_completion(&tsc->completion);\n\n\tadc_cfg = readl(tsc->adc_regs + REG_ADC_CFG);\n\tadc_cfg &= ~(ADC_CONV_MODE_MASK | ADC_INPUT_CLK_MASK);\n\tadc_cfg |= ADC_12BIT_MODE | ADC_IPG_CLK;\n\tadc_cfg &= ~(ADC_CLK_DIV_MASK | ADC_SAMPLE_MODE_MASK);\n\tadc_cfg |= ADC_CLK_DIV_8 | ADC_SHORT_SAMPLE_MODE;\n\tif (tsc->average_enable) {\n\t\tadc_cfg &= ~ADC_AVGS_MASK;\n\t\tadc_cfg |= (tsc->average_select) << ADC_AVGS_SHIFT;\n\t}\n\tadc_cfg &= ~ADC_HARDWARE_TRIGGER;\n\twritel(adc_cfg, tsc->adc_regs + REG_ADC_CFG);\n\n\t \n\tadc_hc |= ADC_AIEN;\n\tadc_hc |= ADC_CONV_DISABLE;\n\twritel(adc_hc, tsc->adc_regs + REG_ADC_HC0);\n\n\t \n\tadc_gc = readl(tsc->adc_regs + REG_ADC_GC);\n\tadc_gc |= ADC_CAL;\n\tif (tsc->average_enable)\n\t\tadc_gc |= ADC_AVGE;\n\twritel(adc_gc, tsc->adc_regs + REG_ADC_GC);\n\n\ttimeout = wait_for_completion_timeout\n\t\t\t(&tsc->completion, ADC_TIMEOUT);\n\tif (timeout == 0) {\n\t\tdev_err(tsc->dev, \"Timeout for adc calibration\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tadc_gs = readl(tsc->adc_regs + REG_ADC_GS);\n\tif (adc_gs & ADC_CALF) {\n\t\tdev_err(tsc->dev, \"ADC calibration failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tadc_cfg = readl(tsc->adc_regs + REG_ADC_CFG);\n\tadc_cfg |= ADC_HARDWARE_TRIGGER;\n\twritel(adc_cfg, tsc->adc_regs + REG_ADC_CFG);\n\n\treturn 0;\n}\n\n \nstatic void imx6ul_tsc_channel_config(struct imx6ul_tsc *tsc)\n{\n\tu32 adc_hc0, adc_hc1, adc_hc2, adc_hc3, adc_hc4;\n\n\tadc_hc0 = DISABLE_CONVERSION_INT;\n\twritel(adc_hc0, tsc->adc_regs + REG_ADC_HC0);\n\n\tadc_hc1 = DISABLE_CONVERSION_INT | SELECT_CHANNEL_4;\n\twritel(adc_hc1, tsc->adc_regs + REG_ADC_HC1);\n\n\tadc_hc2 = DISABLE_CONVERSION_INT;\n\twritel(adc_hc2, tsc->adc_regs + REG_ADC_HC2);\n\n\tadc_hc3 = DISABLE_CONVERSION_INT | SELECT_CHANNEL_1;\n\twritel(adc_hc3, tsc->adc_regs + REG_ADC_HC3);\n\n\tadc_hc4 = DISABLE_CONVERSION_INT;\n\twritel(adc_hc4, tsc->adc_regs + REG_ADC_HC4);\n}\n\n \nstatic void imx6ul_tsc_set(struct imx6ul_tsc *tsc)\n{\n\tu32 basic_setting = 0;\n\tu32 start;\n\n\tbasic_setting |= tsc->measure_delay_time << 8;\n\tbasic_setting |= DETECT_4_WIRE_MODE | AUTO_MEASURE;\n\twritel(basic_setting, tsc->tsc_regs + REG_TSC_BASIC_SETING);\n\n\twritel(DE_GLITCH_2, tsc->tsc_regs + REG_TSC_DEBUG_MODE2);\n\n\twritel(tsc->pre_charge_time, tsc->tsc_regs + REG_TSC_PRE_CHARGE_TIME);\n\twritel(MEASURE_INT_EN, tsc->tsc_regs + REG_TSC_INT_EN);\n\twritel(MEASURE_SIG_EN | VALID_SIG_EN,\n\t\ttsc->tsc_regs + REG_TSC_INT_SIG_EN);\n\n\t \n\tstart = readl(tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\n\tstart |= START_SENSE;\n\tstart &= ~TSC_DISABLE;\n\twritel(start, tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\n}\n\nstatic int imx6ul_tsc_init(struct imx6ul_tsc *tsc)\n{\n\tint err;\n\n\terr = imx6ul_adc_init(tsc);\n\tif (err)\n\t\treturn err;\n\timx6ul_tsc_channel_config(tsc);\n\timx6ul_tsc_set(tsc);\n\n\treturn 0;\n}\n\nstatic void imx6ul_tsc_disable(struct imx6ul_tsc *tsc)\n{\n\tu32 tsc_flow;\n\tu32 adc_cfg;\n\n\t \n\ttsc_flow = readl(tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\n\ttsc_flow |= TSC_DISABLE;\n\twritel(tsc_flow, tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\n\n\t \n\tadc_cfg = readl(tsc->adc_regs + REG_ADC_HC0);\n\tadc_cfg |= ADC_CONV_DISABLE;\n\twritel(adc_cfg, tsc->adc_regs + REG_ADC_HC0);\n}\n\n \nstatic bool tsc_wait_detect_mode(struct imx6ul_tsc *tsc)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(2);\n\tu32 state_machine;\n\tu32 debug_mode2;\n\n\tdo {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn false;\n\n\t\tusleep_range(200, 400);\n\t\tdebug_mode2 = readl(tsc->tsc_regs + REG_TSC_DEBUG_MODE2);\n\t\tstate_machine = (debug_mode2 >> 20) & 0x7;\n\t} while (state_machine != DETECT_MODE);\n\n\tusleep_range(200, 400);\n\treturn true;\n}\n\nstatic irqreturn_t tsc_irq_fn(int irq, void *dev_id)\n{\n\tstruct imx6ul_tsc *tsc = dev_id;\n\tu32 status;\n\tu32 value;\n\tu32 x, y;\n\tu32 start;\n\n\tstatus = readl(tsc->tsc_regs + REG_TSC_INT_STATUS);\n\n\t \n\twritel(MEASURE_SIGNAL | DETECT_SIGNAL,\n\t\ttsc->tsc_regs + REG_TSC_INT_STATUS);\n\n\t \n\tstart = readl(tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\n\tstart |= START_SENSE;\n\twritel(start, tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\n\n\tif (status & MEASURE_SIGNAL) {\n\t\tvalue = readl(tsc->tsc_regs + REG_TSC_MEASURE_VALUE);\n\t\tx = (value >> 16) & 0x0fff;\n\t\ty = value & 0x0fff;\n\n\t\t \n\t\tif (!tsc_wait_detect_mode(tsc) ||\n\t\t    gpiod_get_value_cansleep(tsc->xnur_gpio)) {\n\t\t\tinput_report_key(tsc->input, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(tsc->input, ABS_X, x);\n\t\t\tinput_report_abs(tsc->input, ABS_Y, y);\n\t\t} else {\n\t\t\tinput_report_key(tsc->input, BTN_TOUCH, 0);\n\t\t}\n\n\t\tinput_sync(tsc->input);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t adc_irq_fn(int irq, void *dev_id)\n{\n\tstruct imx6ul_tsc *tsc = dev_id;\n\tu32 coco;\n\n\tcoco = readl(tsc->adc_regs + REG_ADC_HS);\n\tif (coco & 0x01) {\n\t\treadl(tsc->adc_regs + REG_ADC_R0);\n\t\tcomplete(&tsc->completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx6ul_tsc_start(struct imx6ul_tsc *tsc)\n{\n\tint err;\n\n\terr = clk_prepare_enable(tsc->adc_clk);\n\tif (err) {\n\t\tdev_err(tsc->dev,\n\t\t\t\"Could not prepare or enable the adc clock: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(tsc->tsc_clk);\n\tif (err) {\n\t\tdev_err(tsc->dev,\n\t\t\t\"Could not prepare or enable the tsc clock: %d\\n\",\n\t\t\terr);\n\t\tgoto disable_adc_clk;\n\t}\n\n\terr = imx6ul_tsc_init(tsc);\n\tif (err)\n\t\tgoto disable_tsc_clk;\n\n\treturn 0;\n\ndisable_tsc_clk:\n\tclk_disable_unprepare(tsc->tsc_clk);\ndisable_adc_clk:\n\tclk_disable_unprepare(tsc->adc_clk);\n\treturn err;\n}\n\nstatic void imx6ul_tsc_stop(struct imx6ul_tsc *tsc)\n{\n\timx6ul_tsc_disable(tsc);\n\n\tclk_disable_unprepare(tsc->tsc_clk);\n\tclk_disable_unprepare(tsc->adc_clk);\n}\n\n\nstatic int imx6ul_tsc_open(struct input_dev *input_dev)\n{\n\tstruct imx6ul_tsc *tsc = input_get_drvdata(input_dev);\n\n\treturn imx6ul_tsc_start(tsc);\n}\n\nstatic void imx6ul_tsc_close(struct input_dev *input_dev)\n{\n\tstruct imx6ul_tsc *tsc = input_get_drvdata(input_dev);\n\n\timx6ul_tsc_stop(tsc);\n}\n\nstatic int imx6ul_tsc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct imx6ul_tsc *tsc;\n\tstruct input_dev *input_dev;\n\tint err;\n\tint tsc_irq;\n\tint adc_irq;\n\tu32 average_samples;\n\n\ttsc = devm_kzalloc(&pdev->dev, sizeof(*tsc), GFP_KERNEL);\n\tif (!tsc)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(&pdev->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = \"iMX6UL Touchscreen Controller\";\n\tinput_dev->id.bustype = BUS_HOST;\n\n\tinput_dev->open = imx6ul_tsc_open;\n\tinput_dev->close = imx6ul_tsc_close;\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(input_dev, ABS_X, 0, 0xFFF, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 0xFFF, 0, 0);\n\n\tinput_set_drvdata(input_dev, tsc);\n\n\ttsc->dev = &pdev->dev;\n\ttsc->input = input_dev;\n\tinit_completion(&tsc->completion);\n\n\ttsc->xnur_gpio = devm_gpiod_get(&pdev->dev, \"xnur\", GPIOD_IN);\n\tif (IS_ERR(tsc->xnur_gpio)) {\n\t\terr = PTR_ERR(tsc->xnur_gpio);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to request GPIO tsc_X- (xnur): %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttsc->tsc_regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tsc->tsc_regs)) {\n\t\terr = PTR_ERR(tsc->tsc_regs);\n\t\tdev_err(&pdev->dev, \"failed to remap tsc memory: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttsc->adc_regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(tsc->adc_regs)) {\n\t\terr = PTR_ERR(tsc->adc_regs);\n\t\tdev_err(&pdev->dev, \"failed to remap adc memory: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttsc->tsc_clk = devm_clk_get(&pdev->dev, \"tsc\");\n\tif (IS_ERR(tsc->tsc_clk)) {\n\t\terr = PTR_ERR(tsc->tsc_clk);\n\t\tdev_err(&pdev->dev, \"failed getting tsc clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttsc->adc_clk = devm_clk_get(&pdev->dev, \"adc\");\n\tif (IS_ERR(tsc->adc_clk)) {\n\t\terr = PTR_ERR(tsc->adc_clk);\n\t\tdev_err(&pdev->dev, \"failed getting adc clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttsc_irq = platform_get_irq(pdev, 0);\n\tif (tsc_irq < 0)\n\t\treturn tsc_irq;\n\n\tadc_irq = platform_get_irq(pdev, 1);\n\tif (adc_irq < 0)\n\t\treturn adc_irq;\n\n\terr = devm_request_threaded_irq(tsc->dev, tsc_irq,\n\t\t\t\t\tNULL, tsc_irq_fn, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&pdev->dev), tsc);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed requesting tsc irq %d: %d\\n\",\n\t\t\ttsc_irq, err);\n\t\treturn err;\n\t}\n\n\terr = devm_request_irq(tsc->dev, adc_irq, adc_irq_fn, 0,\n\t\t\t\tdev_name(&pdev->dev), tsc);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed requesting adc irq %d: %d\\n\",\n\t\t\tadc_irq, err);\n\t\treturn err;\n\t}\n\n\terr = of_property_read_u32(np, \"measure-delay-time\",\n\t\t\t\t   &tsc->measure_delay_time);\n\tif (err)\n\t\ttsc->measure_delay_time = 0xffff;\n\n\terr = of_property_read_u32(np, \"pre-charge-time\",\n\t\t\t\t   &tsc->pre_charge_time);\n\tif (err)\n\t\ttsc->pre_charge_time = 0xfff;\n\n\terr = of_property_read_u32(np, \"touchscreen-average-samples\",\n\t\t\t\t   &average_samples);\n\tif (err)\n\t\taverage_samples = 1;\n\n\tswitch (average_samples) {\n\tcase 1:\n\t\ttsc->average_enable = false;\n\t\ttsc->average_select = 0;  \n\t\tbreak;\n\tcase 4:\n\tcase 8:\n\tcase 16:\n\tcase 32:\n\t\ttsc->average_enable = true;\n\t\ttsc->average_select = ilog2(average_samples) - 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"touchscreen-average-samples (%u) must be 1, 4, 8, 16 or 32\\n\",\n\t\t\taverage_samples);\n\t\treturn -EINVAL;\n\t}\n\n\terr = input_register_device(tsc->input);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register input device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, tsc);\n\treturn 0;\n}\n\nstatic int imx6ul_tsc_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct imx6ul_tsc *tsc = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = tsc->input;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\timx6ul_tsc_stop(tsc);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int imx6ul_tsc_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct imx6ul_tsc *tsc = platform_get_drvdata(pdev);\n\tstruct input_dev *input_dev = tsc->input;\n\tint retval = 0;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\tretval = imx6ul_tsc_start(tsc);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn retval;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(imx6ul_tsc_pm_ops,\n\t\t\t\timx6ul_tsc_suspend, imx6ul_tsc_resume);\n\nstatic const struct of_device_id imx6ul_tsc_match[] = {\n\t{ .compatible = \"fsl,imx6ul-tsc\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx6ul_tsc_match);\n\nstatic struct platform_driver imx6ul_tsc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"imx6ul-tsc\",\n\t\t.of_match_table\t= imx6ul_tsc_match,\n\t\t.pm\t= pm_sleep_ptr(&imx6ul_tsc_pm_ops),\n\t},\n\t.probe\t\t= imx6ul_tsc_probe,\n};\nmodule_platform_driver(imx6ul_tsc_driver);\n\nMODULE_AUTHOR(\"Haibo Chen <haibo.chen@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale i.MX6UL Touchscreen controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}