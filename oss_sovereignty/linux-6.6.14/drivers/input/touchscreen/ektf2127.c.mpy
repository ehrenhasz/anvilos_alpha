{
  "module_name": "ektf2127.c",
  "hash_id": "4cab9d570174e3e1dc9be4933126551964534324783cc8b59f0573d284f86518",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ektf2127.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n\n \n#define EKTF2127_NOISE\t\t\t0x40\n#define EKTF2127_RESPONSE\t\t0x52\n#define EKTF2127_REQUEST\t\t0x53\n#define EKTF2127_HELLO\t\t\t0x55\n#define EKTF2127_REPORT2\t\t0x5a\n#define EKTF2127_REPORT\t\t\t0x5d\n#define EKTF2127_CALIB_DONE\t\t0x66\n\n \n#define EKTF2127_ENV_NOISY\t\t0x41\n#define EKTF2127_HEIGHT\t\t\t0x60\n#define EKTF2127_WIDTH\t\t\t0x63\n\n \n#define EKTF2127_TOUCH_REPORT_SIZE\t21\n#define EKTF2127_MAX_TOUCHES\t\t5\n\nstruct ektf2127_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *power_gpios;\n\tstruct touchscreen_properties prop;\n};\n\nstatic void ektf2127_parse_coordinates(const u8 *buf, unsigned int touch_count,\n\t\t\t\t       struct input_mt_pos *touches)\n{\n\tint index = 0;\n\tint i;\n\n\tfor (i = 0; i < touch_count; i++) {\n\t\tindex = 2 + i * 3;\n\n\t\ttouches[i].x = (buf[index] & 0x0f);\n\t\ttouches[i].x <<= 8;\n\t\ttouches[i].x |= buf[index + 2];\n\n\t\ttouches[i].y = (buf[index] & 0xf0);\n\t\ttouches[i].y <<= 4;\n\t\ttouches[i].y |= buf[index + 1];\n\t}\n}\n\nstatic void ektf2127_report_event(struct ektf2127_ts *ts, const u8 *buf)\n{\n\tstruct input_mt_pos touches[EKTF2127_MAX_TOUCHES];\n\tint slots[EKTF2127_MAX_TOUCHES];\n\tunsigned int touch_count, i;\n\n\ttouch_count = buf[1] & 0x07;\n\tif (touch_count > EKTF2127_MAX_TOUCHES) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Too many touches %d > %d\\n\",\n\t\t\ttouch_count, EKTF2127_MAX_TOUCHES);\n\t\ttouch_count = EKTF2127_MAX_TOUCHES;\n\t}\n\n\tektf2127_parse_coordinates(buf, touch_count, touches);\n\tinput_mt_assign_slots(ts->input, slots, touches,\n\t\t\t      touch_count, 0);\n\n\tfor (i = 0; i < touch_count; i++) {\n\t\tinput_mt_slot(ts->input, slots[i]);\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\n\t\ttouchscreen_report_pos(ts->input, &ts->prop,\n\t\t\t\t       touches[i].x, touches[i].y, true);\n\t}\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n}\n\nstatic void ektf2127_report2_contact(struct ektf2127_ts *ts, int slot,\n\t\t\t\t     const u8 *buf, bool active)\n{\n\tinput_mt_slot(ts->input, slot);\n\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, active);\n\n\tif (active) {\n\t\tint x = (buf[0] & 0xf0) << 4 | buf[1];\n\t\tint y = (buf[0] & 0x0f) << 8 | buf[2];\n\n\t\ttouchscreen_report_pos(ts->input, &ts->prop, x, y, true);\n\t}\n}\n\nstatic void ektf2127_report2_event(struct ektf2127_ts *ts, const u8 *buf)\n{\n\tektf2127_report2_contact(ts, 0, &buf[1], !!(buf[7] & 2));\n\tektf2127_report2_contact(ts, 1, &buf[4], !!(buf[7] & 4));\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n}\n\nstatic irqreturn_t ektf2127_irq(int irq, void *dev_id)\n{\n\tstruct ektf2127_ts *ts = dev_id;\n\tstruct device *dev = &ts->client->dev;\n\tchar buf[EKTF2127_TOUCH_REPORT_SIZE];\n\tint ret;\n\n\tret = i2c_master_recv(ts->client, buf, EKTF2127_TOUCH_REPORT_SIZE);\n\tif (ret != EKTF2127_TOUCH_REPORT_SIZE) {\n\t\tdev_err(dev, \"Error reading touch data: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tswitch (buf[0]) {\n\tcase EKTF2127_REPORT:\n\t\tektf2127_report_event(ts, buf);\n\t\tbreak;\n\n\tcase EKTF2127_REPORT2:\n\t\tektf2127_report2_event(ts, buf);\n\t\tbreak;\n\n\tcase EKTF2127_NOISE:\n\t\tif (buf[1] == EKTF2127_ENV_NOISY)\n\t\t\tdev_dbg(dev, \"Environment is electrically noisy\\n\");\n\t\tbreak;\n\n\tcase EKTF2127_HELLO:\n\tcase EKTF2127_CALIB_DONE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unexpected packet header byte %#02x\\n\", buf[0]);\n\t\tbreak;\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int ektf2127_start(struct input_dev *dev)\n{\n\tstruct ektf2127_ts *ts = input_get_drvdata(dev);\n\n\tenable_irq(ts->client->irq);\n\tgpiod_set_value_cansleep(ts->power_gpios, 1);\n\n\treturn 0;\n}\n\nstatic void ektf2127_stop(struct input_dev *dev)\n{\n\tstruct ektf2127_ts *ts = input_get_drvdata(dev);\n\n\tdisable_irq(ts->client->irq);\n\tgpiod_set_value_cansleep(ts->power_gpios, 0);\n}\n\nstatic int ektf2127_suspend(struct device *dev)\n{\n\tstruct ektf2127_ts *ts = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&ts->input->mutex);\n\tif (input_device_enabled(ts->input))\n\t\tektf2127_stop(ts->input);\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn 0;\n}\n\nstatic int ektf2127_resume(struct device *dev)\n{\n\tstruct ektf2127_ts *ts = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&ts->input->mutex);\n\tif (input_device_enabled(ts->input))\n\t\tektf2127_start(ts->input);\n\tmutex_unlock(&ts->input->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ektf2127_pm_ops, ektf2127_suspend,\n\t\t\t\tektf2127_resume);\n\nstatic int ektf2127_query_dimension(struct i2c_client *client, bool width)\n{\n\tstruct device *dev = &client->dev;\n\tconst char *what = width ? \"width\" : \"height\";\n\tu8 what_code = width ? EKTF2127_WIDTH : EKTF2127_HEIGHT;\n\tu8 buf[4];\n\tint ret;\n\tint error;\n\n\t \n\tbuf[0] = EKTF2127_REQUEST;\n\tbuf[1] = width ? EKTF2127_WIDTH : EKTF2127_HEIGHT;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x00;\n\tret = i2c_master_send(client, buf, sizeof(buf));\n\tif (ret != sizeof(buf)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(dev, \"Failed to request %s: %d\\n\", what, error);\n\t\treturn error;\n\t}\n\n\tmsleep(20);\n\n\t \n\tret = i2c_master_recv(client, buf, sizeof(buf));\n\tif (ret != sizeof(buf)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(dev, \"Failed to receive %s data: %d\\n\", what, error);\n\t\treturn error;\n\t}\n\n\tif (buf[0] != EKTF2127_RESPONSE || buf[1] != what_code) {\n\t\tdev_err(dev, \"Unexpected %s data: %#02x %#02x\\n\",\n\t\t\twhat, buf[0], buf[1]);\n\t\treturn -EIO;\n\t}\n\n\treturn (((buf[3] & 0xf0) << 4) | buf[2]) - 1;\n}\n\nstatic int ektf2127_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ektf2127_ts *ts;\n\tstruct input_dev *input;\n\tu8 buf[4];\n\tint max_x, max_y;\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"Error no irq specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\t \n\tts->power_gpios = devm_gpiod_get(dev, \"power\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->power_gpios))\n\t\treturn dev_err_probe(dev, PTR_ERR(ts->power_gpios), \"Error getting power gpio\\n\");\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = ektf2127_start;\n\tinput->close = ektf2127_stop;\n\n\tts->client = client;\n\n\t \n\tmsleep(20);\n\ti2c_master_recv(ts->client, buf, sizeof(buf));\n\n\t \n\tmax_x = ektf2127_query_dimension(client, true);\n\tif (max_x < 0)\n\t\treturn max_x;\n\n\tmax_y = ektf2127_query_dimension(client, false);\n\tif (max_y < 0)\n\t\treturn max_y;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\ttouchscreen_parse_properties(input, true, &ts->prop);\n\n\terror = input_mt_init_slots(input, EKTF2127_MAX_TOUCHES,\n\t\t\t\t    INPUT_MT_DIRECT |\n\t\t\t\t\tINPUT_MT_DROP_UNUSED |\n\t\t\t\t\tINPUT_MT_TRACK);\n\tif (error)\n\t\treturn error;\n\n\tts->input = input;\n\tinput_set_drvdata(input, ts);\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, ektf2127_irq,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, ts);\n\tif (error) {\n\t\tdev_err(dev, \"Error requesting irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tektf2127_stop(ts->input);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, ts);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ektf2127_of_match[] = {\n\t{ .compatible = \"elan,ektf2127\" },\n\t{ .compatible = \"elan,ektf2132\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ektf2127_of_match);\n#endif\n\nstatic const struct i2c_device_id ektf2127_i2c_id[] = {\n\t{ \"ektf2127\", 0 },\n\t{ \"ektf2132\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ektf2127_i2c_id);\n\nstatic struct i2c_driver ektf2127_driver = {\n\t.driver = {\n\t\t.name\t= \"elan_ektf2127\",\n\t\t.pm\t= pm_sleep_ptr(&ektf2127_pm_ops),\n\t\t.of_match_table = of_match_ptr(ektf2127_of_match),\n\t},\n\t.probe = ektf2127_probe,\n\t.id_table = ektf2127_i2c_id,\n};\nmodule_i2c_driver(ektf2127_driver);\n\nMODULE_DESCRIPTION(\"ELAN eKTF2127/eKTF2132 I2C Touchscreen Driver\");\nMODULE_AUTHOR(\"Michel Verlaan, Siebren Vroegindeweij\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}