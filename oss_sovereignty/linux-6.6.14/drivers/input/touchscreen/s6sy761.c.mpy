{
  "module_name": "s6sy761.c",
  "hash_id": "91701e43e3a3da979a7c1b49fff150beab16a438e1c45cee8e4ff50f290e4f11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/s6sy761.c",
  "human_readable_source": "\n\n\n\n\n\n#include <asm/unaligned.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n \n#define S6SY761_SENSE_ON\t\t0x10\n#define S6SY761_SENSE_OFF\t\t0x11\n#define S6SY761_TOUCH_FUNCTION\t\t0x30  \n#define S6SY761_FIRMWARE_INTEGRITY\t0x21\n#define S6SY761_PANEL_INFO\t\t0x23\n#define S6SY761_DEVICE_ID\t\t0x52\n#define S6SY761_BOOT_STATUS\t\t0x55\n#define S6SY761_READ_ONE_EVENT\t\t0x60\n#define S6SY761_READ_ALL_EVENT\t\t0x61\n#define S6SY761_CLEAR_EVENT_STACK\t0x62\n#define S6SY761_APPLICATION_MODE\t0xe4\n\n \n#define S6SY761_EVENT_INFO\t\t0x02\n#define S6SY761_EVENT_VENDOR_INFO\t0x07\n\n \n#define S6SY761_INFO_BOOT_COMPLETE\t0x00\n\n \n#define S6SY761_FW_OK\t\t\t0x80\n\n \n \n#define S6SY761_MASK_TOUCH\t\tBIT(0)\n#define S6SY761_MASK_HOVER\t\tBIT(1)\n#define S6SY761_MASK_COVER\t\tBIT(2)\n#define S6SY761_MASK_GLOVE\t\tBIT(3)\n#define S6SY761_MASK_STYLUS\t\tBIT(4)\n#define S6SY761_MASK_PALM\t\tBIT(5)\n#define S6SY761_MASK_WET\t\tBIT(6)\n#define S6SY761_MASK_PROXIMITY\t\tBIT(7)\n\n \n#define S6SY761_BS_BOOT_LOADER\t\t0x10\n#define S6SY761_BS_APPLICATION\t\t0x20\n\n \n#define S6SY761_EVENT_ID_COORDINATE\t0x00\n#define S6SY761_EVENT_ID_STATUS\t\t0x01\n\n \n#define S6SY761_MASK_TOUCH_STATE\t0xc0  \n#define S6SY761_MASK_TID\t\t0x3c\n#define S6SY761_MASK_EID\t\t0x03\n#define S6SY761_MASK_X\t\t\t0xf0  \n#define S6SY761_MASK_Y\t\t\t0x0f\n#define S6SY761_MASK_Z\t\t\t0x3f  \n#define S6SY761_MASK_LEFT_EVENTS\t0x3f  \n#define S6SY761_MASK_TOUCH_TYPE\t\t0xc0  \n\n \n#define S6SY761_TS_NONE\t\t\t0x00\n#define S6SY761_TS_PRESS\t\t0x01\n#define S6SY761_TS_MOVE\t\t\t0x02\n#define S6SY761_TS_RELEASE\t\t0x03\n\n \n#define S6SY761_APP_NORMAL\t\t0x0\n#define S6SY761_APP_LOW_POWER\t\t0x1\n#define S6SY761_APP_TEST\t\t0x2\n#define S6SY761_APP_FLASH\t\t0x3\n#define S6SY761_APP_SLEEP\t\t0x4\n\n#define S6SY761_EVENT_SIZE\t\t8\n#define S6SY761_EVENT_COUNT\t\t32\n#define S6SY761_DEVID_SIZE\t\t3\n#define S6SY761_PANEL_ID_SIZE\t\t11\n#define S6SY761_TS_STATUS_SIZE\t\t5\n#define S6SY761_MAX_FINGERS\t\t10\n\n#define S6SY761_DEV_NAME\t\"s6sy761\"\n\nenum s6sy761_regulators {\n\tS6SY761_REGULATOR_VDD,\n\tS6SY761_REGULATOR_AVDD,\n};\n\nstruct s6sy761_data {\n\tstruct i2c_client *client;\n\tstruct regulator_bulk_data regulators[2];\n\tstruct input_dev *input;\n\tstruct touchscreen_properties prop;\n\n\tu8 data[S6SY761_EVENT_SIZE * S6SY761_EVENT_COUNT];\n\n\tu16 devid;\n\tu8 tx_channel;\n};\n\n \nstatic int s6sy761_read_events(struct s6sy761_data *sdata, u16 n_events)\n{\n\tu8 cmd = S6SY761_READ_ALL_EVENT;\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr\t= sdata->client->addr,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &cmd,\n\t\t},\n\t\t{\n\t\t\t.addr\t= sdata->client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= (n_events * S6SY761_EVENT_SIZE),\n\t\t\t.buf\t= sdata->data + S6SY761_EVENT_SIZE,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(sdata->client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret == ARRAY_SIZE(msgs) ? 0 : -EIO;\n}\n\nstatic void s6sy761_report_coordinates(struct s6sy761_data *sdata,\n\t\t\t\t       u8 *event, u8 tid)\n{\n\tu8 major = event[4];\n\tu8 minor = event[5];\n\tu8 z = event[6] & S6SY761_MASK_Z;\n\tu16 x = (event[1] << 4) | ((event[3] & S6SY761_MASK_X) >> 4);\n\tu16 y = (event[2] << 4) | (event[3] & S6SY761_MASK_Y);\n\n\tinput_mt_slot(sdata->input, tid);\n\n\tinput_mt_report_slot_state(sdata->input, MT_TOOL_FINGER, true);\n\tinput_report_abs(sdata->input, ABS_MT_POSITION_X, x);\n\tinput_report_abs(sdata->input, ABS_MT_POSITION_Y, y);\n\tinput_report_abs(sdata->input, ABS_MT_TOUCH_MAJOR, major);\n\tinput_report_abs(sdata->input, ABS_MT_TOUCH_MINOR, minor);\n\tinput_report_abs(sdata->input, ABS_MT_PRESSURE, z);\n\n\tinput_sync(sdata->input);\n}\n\nstatic void s6sy761_report_release(struct s6sy761_data *sdata,\n\t\t\t\t   u8 *event, u8 tid)\n{\n\tinput_mt_slot(sdata->input, tid);\n\tinput_mt_report_slot_state(sdata->input, MT_TOOL_FINGER, false);\n\n\tinput_sync(sdata->input);\n}\n\nstatic void s6sy761_handle_coordinates(struct s6sy761_data *sdata, u8 *event)\n{\n\tu8 tid;\n\tu8 touch_state;\n\n\tif (unlikely(!(event[0] & S6SY761_MASK_TID)))\n\t\treturn;\n\n\ttid = ((event[0] & S6SY761_MASK_TID) >> 2) - 1;\n\ttouch_state = (event[0] & S6SY761_MASK_TOUCH_STATE) >> 6;\n\n\tswitch (touch_state) {\n\n\tcase S6SY761_TS_NONE:\n\t\tbreak;\n\tcase S6SY761_TS_RELEASE:\n\t\ts6sy761_report_release(sdata, event, tid);\n\t\tbreak;\n\tcase S6SY761_TS_PRESS:\n\tcase S6SY761_TS_MOVE:\n\t\ts6sy761_report_coordinates(sdata, event, tid);\n\t\tbreak;\n\t}\n}\n\nstatic void s6sy761_handle_events(struct s6sy761_data *sdata, u8 n_events)\n{\n\tint i;\n\n\tfor (i = 0; i < n_events; i++) {\n\t\tu8 *event = &sdata->data[i * S6SY761_EVENT_SIZE];\n\t\tu8 event_id = event[0] & S6SY761_MASK_EID;\n\n\t\tif (!event[0])\n\t\t\treturn;\n\n\t\tswitch (event_id) {\n\n\t\tcase S6SY761_EVENT_ID_COORDINATE:\n\t\t\ts6sy761_handle_coordinates(sdata, event);\n\t\t\tbreak;\n\n\t\tcase S6SY761_EVENT_ID_STATUS:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic irqreturn_t s6sy761_irq_handler(int irq, void *dev)\n{\n\tstruct s6sy761_data *sdata = dev;\n\tint ret;\n\tu8 n_events;\n\n\tret = i2c_smbus_read_i2c_block_data(sdata->client,\n\t\t\t\t\t    S6SY761_READ_ONE_EVENT,\n\t\t\t\t\t    S6SY761_EVENT_SIZE,\n\t\t\t\t\t    sdata->data);\n\tif (ret < 0) {\n\t\tdev_err(&sdata->client->dev, \"failed to read events\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!sdata->data[0])\n\t\treturn IRQ_HANDLED;\n\n\tn_events = sdata->data[7] & S6SY761_MASK_LEFT_EVENTS;\n\tif (unlikely(n_events > S6SY761_EVENT_COUNT - 1))\n\t\treturn IRQ_HANDLED;\n\n\tif (n_events) {\n\t\tret = s6sy761_read_events(sdata, n_events);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&sdata->client->dev, \"failed to read events\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\ts6sy761_handle_events(sdata, n_events +  1);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int s6sy761_input_open(struct input_dev *dev)\n{\n\tstruct s6sy761_data *sdata = input_get_drvdata(dev);\n\n\treturn i2c_smbus_write_byte(sdata->client, S6SY761_SENSE_ON);\n}\n\nstatic void s6sy761_input_close(struct input_dev *dev)\n{\n\tstruct s6sy761_data *sdata = input_get_drvdata(dev);\n\tint ret;\n\n\tret = i2c_smbus_write_byte(sdata->client, S6SY761_SENSE_OFF);\n\tif (ret)\n\t\tdev_err(&sdata->client->dev, \"failed to turn off sensing\\n\");\n}\n\nstatic ssize_t s6sy761_sysfs_devid(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct s6sy761_data *sdata = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", sdata->devid);\n}\n\nstatic DEVICE_ATTR(devid, 0444, s6sy761_sysfs_devid, NULL);\n\nstatic struct attribute *s6sy761_sysfs_attrs[] = {\n\t&dev_attr_devid.attr,\n\tNULL\n};\n\nstatic struct attribute_group s6sy761_attribute_group = {\n\t.attrs = s6sy761_sysfs_attrs\n};\n\nstatic int s6sy761_power_on(struct s6sy761_data *sdata)\n{\n\tu8 buffer[S6SY761_EVENT_SIZE];\n\tu8 event;\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(sdata->regulators),\n\t\t\t\t    sdata->regulators);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(140);\n\n\t \n\tret = i2c_smbus_read_i2c_block_data(sdata->client,\n\t\t\t\t\t    S6SY761_READ_ONE_EVENT,\n\t\t\t\t\t    S6SY761_EVENT_SIZE,\n\t\t\t\t\t    buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tevent = (buffer[0] >> 2) & 0xf;\n\n\tif ((event != S6SY761_EVENT_INFO &&\n\t     event != S6SY761_EVENT_VENDOR_INFO) ||\n\t    buffer[1] != S6SY761_INFO_BOOT_COMPLETE) {\n\t\treturn -ENODEV;\n\t}\n\n\tret = i2c_smbus_read_byte_data(sdata->client, S6SY761_BOOT_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret != S6SY761_BS_APPLICATION)\n\t\treturn -ENODEV;\n\n\t \n\tret = i2c_smbus_write_word_data(sdata->client,\n\t\t\t\t\tS6SY761_TOUCH_FUNCTION,\n\t\t\t\t\tS6SY761_MASK_TOUCH);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int s6sy761_hw_init(struct s6sy761_data *sdata,\n\t\t\t   unsigned int *max_x, unsigned int *max_y)\n{\n\tu8 buffer[S6SY761_PANEL_ID_SIZE];  \n\tint ret;\n\n\tret = s6sy761_power_on(sdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_i2c_block_data(sdata->client,\n\t\t\t\t\t    S6SY761_DEVICE_ID,\n\t\t\t\t\t    S6SY761_DEVID_SIZE,\n\t\t\t\t\t    buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsdata->devid = get_unaligned_be16(buffer + 1);\n\n\tret = i2c_smbus_read_i2c_block_data(sdata->client,\n\t\t\t\t\t    S6SY761_PANEL_INFO,\n\t\t\t\t\t    S6SY761_PANEL_ID_SIZE,\n\t\t\t\t\t    buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*max_x = get_unaligned_be16(buffer);\n\t*max_y = get_unaligned_be16(buffer + 2);\n\n\t \n\tsdata->tx_channel = max_t(u8, buffer[8], 1);\n\n\tret = i2c_smbus_read_byte_data(sdata->client,\n\t\t\t\t       S6SY761_FIRMWARE_INTEGRITY);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != S6SY761_FW_OK)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void s6sy761_power_off(void *data)\n{\n\tstruct s6sy761_data *sdata = data;\n\n\tdisable_irq(sdata->client->irq);\n\tregulator_bulk_disable(ARRAY_SIZE(sdata->regulators),\n\t\t\t\t\t\tsdata->regulators);\n}\n\nstatic int s6sy761_probe(struct i2c_client *client)\n{\n\tstruct s6sy761_data *sdata;\n\tunsigned int max_x, max_y;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\n\t\t\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tsdata = devm_kzalloc(&client->dev, sizeof(*sdata), GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, sdata);\n\tsdata->client = client;\n\n\tsdata->regulators[S6SY761_REGULATOR_VDD].supply = \"vdd\";\n\tsdata->regulators[S6SY761_REGULATOR_AVDD].supply = \"avdd\";\n\terr = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t      ARRAY_SIZE(sdata->regulators),\n\t\t\t\t      sdata->regulators);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&client->dev, s6sy761_power_off, sdata);\n\tif (err)\n\t\treturn err;\n\n\terr = s6sy761_hw_init(sdata, &max_x, &max_y);\n\tif (err)\n\t\treturn err;\n\n\tsdata->input = devm_input_allocate_device(&client->dev);\n\tif (!sdata->input)\n\t\treturn -ENOMEM;\n\n\tsdata->input->name = S6SY761_DEV_NAME;\n\tsdata->input->id.bustype = BUS_I2C;\n\tsdata->input->open = s6sy761_input_open;\n\tsdata->input->close = s6sy761_input_close;\n\n\tinput_set_abs_params(sdata->input, ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);\n\tinput_set_abs_params(sdata->input, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\n\ttouchscreen_parse_properties(sdata->input, true, &sdata->prop);\n\n\tif (!input_abs_get_max(sdata->input, ABS_X) ||\n\t    !input_abs_get_max(sdata->input, ABS_Y)) {\n\t\tdev_warn(&client->dev, \"the axis have not been set\\n\");\n\t}\n\n\terr = input_mt_init_slots(sdata->input, sdata->tx_channel,\n\t\t\t\t  INPUT_MT_DIRECT);\n\tif (err)\n\t\treturn err;\n\n\tinput_set_drvdata(sdata->input, sdata);\n\n\terr = input_register_device(sdata->input);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\ts6sy761_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\"s6sy761_irq\", sdata);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_device_add_group(&client->dev, &s6sy761_attribute_group);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_enable(&client->dev);\n\n\treturn 0;\n}\n\nstatic void s6sy761_remove(struct i2c_client *client)\n{\n\tpm_runtime_disable(&client->dev);\n}\n\nstatic int s6sy761_runtime_suspend(struct device *dev)\n{\n\tstruct s6sy761_data *sdata = dev_get_drvdata(dev);\n\n\treturn i2c_smbus_write_byte_data(sdata->client,\n\t\t\t\tS6SY761_APPLICATION_MODE, S6SY761_APP_SLEEP);\n}\n\nstatic int s6sy761_runtime_resume(struct device *dev)\n{\n\tstruct s6sy761_data *sdata = dev_get_drvdata(dev);\n\n\treturn i2c_smbus_write_byte_data(sdata->client,\n\t\t\t\tS6SY761_APPLICATION_MODE, S6SY761_APP_NORMAL);\n}\n\nstatic int s6sy761_suspend(struct device *dev)\n{\n\tstruct s6sy761_data *sdata = dev_get_drvdata(dev);\n\n\ts6sy761_power_off(sdata);\n\n\treturn 0;\n}\n\nstatic int s6sy761_resume(struct device *dev)\n{\n\tstruct s6sy761_data *sdata = dev_get_drvdata(dev);\n\n\tenable_irq(sdata->client->irq);\n\n\treturn s6sy761_power_on(sdata);\n}\n\nstatic const struct dev_pm_ops s6sy761_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(s6sy761_suspend, s6sy761_resume)\n\tRUNTIME_PM_OPS(s6sy761_runtime_suspend, s6sy761_runtime_resume, NULL)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id s6sy761_of_match[] = {\n\t{ .compatible = \"samsung,s6sy761\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, s6sy761_of_match);\n#endif\n\nstatic const struct i2c_device_id s6sy761_id[] = {\n\t{ \"s6sy761\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, s6sy761_id);\n\nstatic struct i2c_driver s6sy761_driver = {\n\t.driver = {\n\t\t.name = S6SY761_DEV_NAME,\n\t\t.of_match_table = of_match_ptr(s6sy761_of_match),\n\t\t.pm = pm_ptr(&s6sy761_pm_ops),\n\t},\n\t.probe = s6sy761_probe,\n\t.remove = s6sy761_remove,\n\t.id_table = s6sy761_id,\n};\n\nmodule_i2c_driver(s6sy761_driver);\n\nMODULE_AUTHOR(\"Andi Shyti <andi.shyti@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung S6SY761 Touch Screen\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}