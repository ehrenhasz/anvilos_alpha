{
  "module_name": "eeti_ts.c",
  "hash_id": "125ef8be540c5f99036f143038fbecd25d9946a970b2356c1ad52988902a3356",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/eeti_ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/timer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\nstruct eeti_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *attn_gpio;\n\tstruct touchscreen_properties props;\n\tstruct mutex mutex;\n\tbool running;\n};\n\n#define EETI_TS_BITDEPTH\t(11)\n#define EETI_MAXVAL\t\t((1 << (EETI_TS_BITDEPTH + 1)) - 1)\n\n#define REPORT_BIT_PRESSED\tBIT(0)\n#define REPORT_BIT_AD0\t\tBIT(1)\n#define REPORT_BIT_AD1\t\tBIT(2)\n#define REPORT_BIT_HAS_PRESSURE\tBIT(6)\n#define REPORT_RES_BITS(v)\t(((v) >> 1) + EETI_TS_BITDEPTH)\n\nstatic void eeti_ts_report_event(struct eeti_ts *eeti, u8 *buf)\n{\n\tunsigned int res;\n\tu16 x, y;\n\n\tres = REPORT_RES_BITS(buf[0] & (REPORT_BIT_AD0 | REPORT_BIT_AD1));\n\n\tx = get_unaligned_be16(&buf[1]);\n\ty = get_unaligned_be16(&buf[3]);\n\n\t \n\tx >>= res - EETI_TS_BITDEPTH;\n\ty >>= res - EETI_TS_BITDEPTH;\n\n\tif (buf[0] & REPORT_BIT_HAS_PRESSURE)\n\t\tinput_report_abs(eeti->input, ABS_PRESSURE, buf[5]);\n\n\ttouchscreen_report_pos(eeti->input, &eeti->props, x, y, false);\n\tinput_report_key(eeti->input, BTN_TOUCH, buf[0] & REPORT_BIT_PRESSED);\n\tinput_sync(eeti->input);\n}\n\nstatic int eeti_ts_read(struct eeti_ts *eeti)\n{\n\tint len, error;\n\tchar buf[6];\n\n\tlen = i2c_master_recv(eeti->client, buf, sizeof(buf));\n\tif (len != sizeof(buf)) {\n\t\terror = len < 0 ? len : -EIO;\n\t\tdev_err(&eeti->client->dev,\n\t\t\t\"failed to read touchscreen data: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tif (buf[0] & 0x80)\n\t\teeti_ts_report_event(eeti, buf);\n\n\treturn 0;\n}\n\nstatic irqreturn_t eeti_ts_isr(int irq, void *dev_id)\n{\n\tstruct eeti_ts *eeti = dev_id;\n\tint error;\n\n\tmutex_lock(&eeti->mutex);\n\n\tdo {\n\t\t \n\t\tif (eeti->attn_gpio &&\n\t\t    !gpiod_get_value_cansleep(eeti->attn_gpio)) {\n\t\t\tbreak;\n\t\t}\n\n\t\terror = eeti_ts_read(eeti);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (eeti->running && eeti->attn_gpio);\n\n\tmutex_unlock(&eeti->mutex);\n\treturn IRQ_HANDLED;\n}\n\nstatic void eeti_ts_start(struct eeti_ts *eeti)\n{\n\tmutex_lock(&eeti->mutex);\n\n\teeti->running = true;\n\tenable_irq(eeti->client->irq);\n\n\t \n\tif (eeti->attn_gpio && gpiod_get_value_cansleep(eeti->attn_gpio))\n\t\teeti_ts_read(eeti);\n\n\tmutex_unlock(&eeti->mutex);\n}\n\nstatic void eeti_ts_stop(struct eeti_ts *eeti)\n{\n\t \n\teeti->running = false;\n\twmb();\n\tdisable_irq(eeti->client->irq);\n}\n\nstatic int eeti_ts_open(struct input_dev *dev)\n{\n\tstruct eeti_ts *eeti = input_get_drvdata(dev);\n\n\teeti_ts_start(eeti);\n\n\treturn 0;\n}\n\nstatic void eeti_ts_close(struct input_dev *dev)\n{\n\tstruct eeti_ts *eeti = input_get_drvdata(dev);\n\n\teeti_ts_stop(eeti);\n}\n\nstatic int eeti_ts_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct eeti_ts *eeti;\n\tstruct input_dev *input;\n\tint error;\n\n\t \n\n\teeti = devm_kzalloc(dev, sizeof(*eeti), GFP_KERNEL);\n\tif (!eeti) {\n\t\tdev_err(dev, \"failed to allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&eeti->mutex);\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"Failed to allocate input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\n\tinput_set_abs_params(input, ABS_X, 0, EETI_MAXVAL, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, EETI_MAXVAL, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 0xff, 0, 0);\n\n\ttouchscreen_parse_properties(input, false, &eeti->props);\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = eeti_ts_open;\n\tinput->close = eeti_ts_close;\n\n\teeti->client = client;\n\teeti->input = input;\n\n\teeti->attn_gpio = devm_gpiod_get_optional(dev, \"attn\", GPIOD_IN);\n\tif (IS_ERR(eeti->attn_gpio))\n\t\treturn PTR_ERR(eeti->attn_gpio);\n\n\ti2c_set_clientdata(client, eeti);\n\tinput_set_drvdata(input, eeti);\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, eeti_ts_isr,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  client->name, eeti);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to request touchscreen IRQ: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\teeti_ts_stop(eeti);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int eeti_ts_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct eeti_ts *eeti = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = eeti->input;\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\teeti_ts_stop(eeti);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\tif (device_may_wakeup(&client->dev))\n\t\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic int eeti_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct eeti_ts *eeti = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = eeti->input;\n\n\tif (device_may_wakeup(&client->dev))\n\t\tdisable_irq_wake(client->irq);\n\n\tmutex_lock(&input_dev->mutex);\n\n\tif (input_device_enabled(input_dev))\n\t\teeti_ts_start(eeti);\n\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(eeti_ts_pm, eeti_ts_suspend, eeti_ts_resume);\n\nstatic const struct i2c_device_id eeti_ts_id[] = {\n\t{ \"eeti_ts\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, eeti_ts_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_eeti_ts_match[] = {\n\t{ .compatible = \"eeti,exc3000-i2c\", },\n\t{ }\n};\n#endif\n\nstatic struct i2c_driver eeti_ts_driver = {\n\t.driver = {\n\t\t.name = \"eeti_ts\",\n\t\t.pm = pm_sleep_ptr(&eeti_ts_pm),\n\t\t.of_match_table = of_match_ptr(of_eeti_ts_match),\n\t},\n\t.probe = eeti_ts_probe,\n\t.id_table = eeti_ts_id,\n};\n\nmodule_i2c_driver(eeti_ts_driver);\n\nMODULE_DESCRIPTION(\"EETI Touchscreen driver\");\nMODULE_AUTHOR(\"Daniel Mack <daniel@zonque.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}