{
  "module_name": "iqs7211.c",
  "hash_id": "e4d02a9eb90e2cbbf422c6f6e3e1f91057841e43c76f0ce404a19d9d79af2bfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/iqs7211.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define IQS7211_PROD_NUM\t\t\t0x00\n\n#define IQS7211_EVENT_MASK_ALL\t\t\tGENMASK(14, 8)\n#define IQS7211_EVENT_MASK_ALP\t\t\tBIT(13)\n#define IQS7211_EVENT_MASK_BTN\t\t\tBIT(12)\n#define IQS7211_EVENT_MASK_ATI\t\t\tBIT(11)\n#define IQS7211_EVENT_MASK_MOVE\t\t\tBIT(10)\n#define IQS7211_EVENT_MASK_GSTR\t\t\tBIT(9)\n#define IQS7211_EVENT_MODE\t\t\tBIT(8)\n\n#define IQS7211_COMMS_ERROR\t\t\t0xEEEE\n#define IQS7211_COMMS_RETRY_MS\t\t\t50\n#define IQS7211_COMMS_SLEEP_US\t\t\t100\n#define IQS7211_COMMS_TIMEOUT_US\t\t(100 * USEC_PER_MSEC)\n#define IQS7211_RESET_TIMEOUT_MS\t\t150\n#define IQS7211_START_TIMEOUT_US\t\t(1 * USEC_PER_SEC)\n\n#define IQS7211_NUM_RETRIES\t\t\t5\n#define IQS7211_NUM_CRX\t\t\t\t8\n#define IQS7211_MAX_CTX\t\t\t\t13\n\n#define IQS7211_MAX_CONTACTS\t\t\t2\n#define IQS7211_MAX_CYCLES\t\t\t21\n\n \n#define iqs7211_irq_wait()\t\t\tusleep_range(2500, 2600)\n\nenum iqs7211_dev_id {\n\tIQS7210A,\n\tIQS7211A,\n\tIQS7211E,\n};\n\nenum iqs7211_comms_mode {\n\tIQS7211_COMMS_MODE_WAIT,\n\tIQS7211_COMMS_MODE_FREE,\n\tIQS7211_COMMS_MODE_FORCE,\n};\n\nstruct iqs7211_reg_field_desc {\n\tstruct list_head list;\n\tu8 addr;\n\tu16 mask;\n\tu16 val;\n};\n\nenum iqs7211_reg_key_id {\n\tIQS7211_REG_KEY_NONE,\n\tIQS7211_REG_KEY_PROX,\n\tIQS7211_REG_KEY_TOUCH,\n\tIQS7211_REG_KEY_TAP,\n\tIQS7211_REG_KEY_HOLD,\n\tIQS7211_REG_KEY_PALM,\n\tIQS7211_REG_KEY_AXIAL_X,\n\tIQS7211_REG_KEY_AXIAL_Y,\n\tIQS7211_REG_KEY_RESERVED\n};\n\nenum iqs7211_reg_grp_id {\n\tIQS7211_REG_GRP_TP,\n\tIQS7211_REG_GRP_BTN,\n\tIQS7211_REG_GRP_ALP,\n\tIQS7211_REG_GRP_SYS,\n\tIQS7211_NUM_REG_GRPS\n};\n\nstatic const char * const iqs7211_reg_grp_names[IQS7211_NUM_REG_GRPS] = {\n\t[IQS7211_REG_GRP_TP] = \"trackpad\",\n\t[IQS7211_REG_GRP_BTN] = \"button\",\n\t[IQS7211_REG_GRP_ALP] = \"alp\",\n};\n\nstatic const u16 iqs7211_reg_grp_masks[IQS7211_NUM_REG_GRPS] = {\n\t[IQS7211_REG_GRP_TP] = IQS7211_EVENT_MASK_GSTR,\n\t[IQS7211_REG_GRP_BTN] = IQS7211_EVENT_MASK_BTN,\n\t[IQS7211_REG_GRP_ALP] = IQS7211_EVENT_MASK_ALP,\n};\n\nstruct iqs7211_event_desc {\n\tconst char *name;\n\tu16 mask;\n\tu16 enable;\n\tenum iqs7211_reg_grp_id reg_grp;\n\tenum iqs7211_reg_key_id reg_key;\n};\n\nstatic const struct iqs7211_event_desc iqs7210a_kp_events[] = {\n\t{\n\t\t.mask = BIT(10),\n\t\t.enable = BIT(13) | BIT(12),\n\t\t.reg_grp = IQS7211_REG_GRP_ALP,\n\t},\n\t{\n\t\t.name = \"event-prox\",\n\t\t.mask = BIT(2),\n\t\t.enable = BIT(5) | BIT(4),\n\t\t.reg_grp = IQS7211_REG_GRP_BTN,\n\t\t.reg_key = IQS7211_REG_KEY_PROX,\n\t},\n\t{\n\t\t.name = \"event-touch\",\n\t\t.mask = BIT(3),\n\t\t.enable = BIT(5) | BIT(4),\n\t\t.reg_grp = IQS7211_REG_GRP_BTN,\n\t\t.reg_key = IQS7211_REG_KEY_TOUCH,\n\t},\n\t{\n\t\t.name = \"event-tap\",\n\t\t.mask = BIT(0),\n\t\t.enable = BIT(0),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-hold\",\n\t\t.mask = BIT(1),\n\t\t.enable = BIT(1),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-neg\",\n\t\t.mask = BIT(2),\n\t\t.enable = BIT(2),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-pos\",\n\t\t.mask = BIT(3),\n\t\t.enable = BIT(3),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-pos\",\n\t\t.mask = BIT(4),\n\t\t.enable = BIT(4),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-neg\",\n\t\t.mask = BIT(5),\n\t\t.enable = BIT(5),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t},\n};\n\nstatic const struct iqs7211_event_desc iqs7211a_kp_events[] = {\n\t{\n\t\t.mask = BIT(14),\n\t\t.reg_grp = IQS7211_REG_GRP_ALP,\n\t},\n\t{\n\t\t.name = \"event-tap\",\n\t\t.mask = BIT(0),\n\t\t.enable = BIT(0),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-hold\",\n\t\t.mask = BIT(1),\n\t\t.enable = BIT(1),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-neg\",\n\t\t.mask = BIT(2),\n\t\t.enable = BIT(2),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-pos\",\n\t\t.mask = BIT(3),\n\t\t.enable = BIT(3),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-pos\",\n\t\t.mask = BIT(4),\n\t\t.enable = BIT(4),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-neg\",\n\t\t.mask = BIT(5),\n\t\t.enable = BIT(5),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t},\n};\n\nstatic const struct iqs7211_event_desc iqs7211e_kp_events[] = {\n\t{\n\t\t.mask = BIT(14),\n\t\t.reg_grp = IQS7211_REG_GRP_ALP,\n\t},\n\t{\n\t\t.name = \"event-tap\",\n\t\t.mask = BIT(0),\n\t\t.enable = BIT(0),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-tap-double\",\n\t\t.mask = BIT(1),\n\t\t.enable = BIT(1),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-tap-triple\",\n\t\t.mask = BIT(2),\n\t\t.enable = BIT(2),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t},\n\t{\n\t\t.name = \"event-hold\",\n\t\t.mask = BIT(3),\n\t\t.enable = BIT(3),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n\t{\n\t\t.name = \"event-palm\",\n\t\t.mask = BIT(4),\n\t\t.enable = BIT(4),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_PALM,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-pos\",\n\t\t.mask = BIT(8),\n\t\t.enable = BIT(8),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-neg\",\n\t\t.mask = BIT(9),\n\t\t.enable = BIT(9),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-pos\",\n\t\t.mask = BIT(10),\n\t\t.enable = BIT(10),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-neg\",\n\t\t.mask = BIT(11),\n\t\t.enable = BIT(11),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-pos-hold\",\n\t\t.mask = BIT(12),\n\t\t.enable = BIT(12),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n\t{\n\t\t.name = \"event-swipe-x-neg-hold\",\n\t\t.mask = BIT(13),\n\t\t.enable = BIT(13),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-pos-hold\",\n\t\t.mask = BIT(14),\n\t\t.enable = BIT(14),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n\t{\n\t\t.name = \"event-swipe-y-neg-hold\",\n\t\t.mask = BIT(15),\n\t\t.enable = BIT(15),\n\t\t.reg_grp = IQS7211_REG_GRP_TP,\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t},\n};\n\nstruct iqs7211_dev_desc {\n\tconst char *tp_name;\n\tconst char *kp_name;\n\tu16 prod_num;\n\tu16 show_reset;\n\tu16 ati_error[IQS7211_NUM_REG_GRPS];\n\tu16 ati_start[IQS7211_NUM_REG_GRPS];\n\tu16 suspend;\n\tu16 ack_reset;\n\tu16 comms_end;\n\tu16 comms_req;\n\tint charge_shift;\n\tint info_offs;\n\tint gesture_offs;\n\tint contact_offs;\n\tu8 sys_stat;\n\tu8 sys_ctrl;\n\tu8 alp_config;\n\tu8 tp_config;\n\tu8 exp_file;\n\tu8 kp_enable[IQS7211_NUM_REG_GRPS];\n\tu8 gesture_angle;\n\tu8 rx_tx_map;\n\tu8 cycle_alloc[2];\n\tu8 cycle_limit[2];\n\tconst struct iqs7211_event_desc *kp_events;\n\tint num_kp_events;\n\tint min_crx_alp;\n\tint num_ctx;\n};\n\nstatic const struct iqs7211_dev_desc iqs7211_devs[] = {\n\t[IQS7210A] = {\n\t\t.tp_name = \"iqs7210a_trackpad\",\n\t\t.kp_name = \"iqs7210a_keys\",\n\t\t.prod_num = 944,\n\t\t.show_reset = BIT(15),\n\t\t.ati_error = {\n\t\t\t[IQS7211_REG_GRP_TP] = BIT(12),\n\t\t\t[IQS7211_REG_GRP_BTN] = BIT(0),\n\t\t\t[IQS7211_REG_GRP_ALP] = BIT(8),\n\t\t},\n\t\t.ati_start = {\n\t\t\t[IQS7211_REG_GRP_TP] = BIT(13),\n\t\t\t[IQS7211_REG_GRP_BTN] = BIT(1),\n\t\t\t[IQS7211_REG_GRP_ALP] = BIT(9),\n\t\t},\n\t\t.suspend = BIT(11),\n\t\t.ack_reset = BIT(7),\n\t\t.comms_end = BIT(2),\n\t\t.comms_req = BIT(1),\n\t\t.charge_shift = 4,\n\t\t.info_offs = 0,\n\t\t.gesture_offs = 1,\n\t\t.contact_offs = 4,\n\t\t.sys_stat = 0x0A,\n\t\t.sys_ctrl = 0x35,\n\t\t.alp_config = 0x39,\n\t\t.tp_config = 0x4E,\n\t\t.exp_file = 0x57,\n\t\t.kp_enable = {\n\t\t\t[IQS7211_REG_GRP_TP] = 0x58,\n\t\t\t[IQS7211_REG_GRP_BTN] = 0x37,\n\t\t\t[IQS7211_REG_GRP_ALP] = 0x37,\n\t\t},\n\t\t.gesture_angle = 0x5F,\n\t\t.rx_tx_map = 0x60,\n\t\t.cycle_alloc = { 0x66, 0x75, },\n\t\t.cycle_limit = { 10, 6, },\n\t\t.kp_events = iqs7210a_kp_events,\n\t\t.num_kp_events = ARRAY_SIZE(iqs7210a_kp_events),\n\t\t.min_crx_alp = 4,\n\t\t.num_ctx = IQS7211_MAX_CTX - 1,\n\t},\n\t[IQS7211A] = {\n\t\t.tp_name = \"iqs7211a_trackpad\",\n\t\t.kp_name = \"iqs7211a_keys\",\n\t\t.prod_num = 763,\n\t\t.show_reset = BIT(7),\n\t\t.ati_error = {\n\t\t\t[IQS7211_REG_GRP_TP] = BIT(3),\n\t\t\t[IQS7211_REG_GRP_ALP] = BIT(5),\n\t\t},\n\t\t.ati_start = {\n\t\t\t[IQS7211_REG_GRP_TP] = BIT(5),\n\t\t\t[IQS7211_REG_GRP_ALP] = BIT(6),\n\t\t},\n\t\t.ack_reset = BIT(7),\n\t\t.comms_req = BIT(4),\n\t\t.charge_shift = 0,\n\t\t.info_offs = 0,\n\t\t.gesture_offs = 1,\n\t\t.contact_offs = 4,\n\t\t.sys_stat = 0x10,\n\t\t.sys_ctrl = 0x50,\n\t\t.tp_config = 0x60,\n\t\t.alp_config = 0x72,\n\t\t.exp_file = 0x74,\n\t\t.kp_enable = {\n\t\t\t[IQS7211_REG_GRP_TP] = 0x80,\n\t\t},\n\t\t.gesture_angle = 0x87,\n\t\t.rx_tx_map = 0x90,\n\t\t.cycle_alloc = { 0xA0, 0xB0, },\n\t\t.cycle_limit = { 10, 8, },\n\t\t.kp_events = iqs7211a_kp_events,\n\t\t.num_kp_events = ARRAY_SIZE(iqs7211a_kp_events),\n\t\t.num_ctx = IQS7211_MAX_CTX - 1,\n\t},\n\t[IQS7211E] = {\n\t\t.tp_name = \"iqs7211e_trackpad\",\n\t\t.kp_name = \"iqs7211e_keys\",\n\t\t.prod_num = 1112,\n\t\t.show_reset = BIT(7),\n\t\t.ati_error = {\n\t\t\t[IQS7211_REG_GRP_TP] = BIT(3),\n\t\t\t[IQS7211_REG_GRP_ALP] = BIT(5),\n\t\t},\n\t\t.ati_start = {\n\t\t\t[IQS7211_REG_GRP_TP] = BIT(5),\n\t\t\t[IQS7211_REG_GRP_ALP] = BIT(6),\n\t\t},\n\t\t.suspend = BIT(11),\n\t\t.ack_reset = BIT(7),\n\t\t.comms_end = BIT(6),\n\t\t.comms_req = BIT(4),\n\t\t.charge_shift = 0,\n\t\t.info_offs = 1,\n\t\t.gesture_offs = 0,\n\t\t.contact_offs = 2,\n\t\t.sys_stat = 0x0E,\n\t\t.sys_ctrl = 0x33,\n\t\t.tp_config = 0x41,\n\t\t.alp_config = 0x36,\n\t\t.exp_file = 0x4A,\n\t\t.kp_enable = {\n\t\t\t[IQS7211_REG_GRP_TP] = 0x4B,\n\t\t},\n\t\t.gesture_angle = 0x55,\n\t\t.rx_tx_map = 0x56,\n\t\t.cycle_alloc = { 0x5D, 0x6C, },\n\t\t.cycle_limit = { 10, 11, },\n\t\t.kp_events = iqs7211e_kp_events,\n\t\t.num_kp_events = ARRAY_SIZE(iqs7211e_kp_events),\n\t\t.num_ctx = IQS7211_MAX_CTX,\n\t},\n};\n\nstruct iqs7211_prop_desc {\n\tconst char *name;\n\tenum iqs7211_reg_key_id reg_key;\n\tu8 reg_addr[IQS7211_NUM_REG_GRPS][ARRAY_SIZE(iqs7211_devs)];\n\tint reg_shift;\n\tint reg_width;\n\tint val_pitch;\n\tint val_min;\n\tint val_max;\n\tconst char *label;\n};\n\nstatic const struct iqs7211_prop_desc iqs7211_props[] = {\n\t{\n\t\t.name = \"azoteq,ati-frac-div-fine\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x1E,\n\t\t\t\t[IQS7211A] = 0x30,\n\t\t\t\t[IQS7211E] = 0x21,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x22,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x23,\n\t\t\t\t[IQS7211A] = 0x36,\n\t\t\t\t[IQS7211E] = 0x25,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 9,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI fine fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-mult-coarse\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x1E,\n\t\t\t\t[IQS7211A] = 0x30,\n\t\t\t\t[IQS7211E] = 0x21,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x22,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x23,\n\t\t\t\t[IQS7211A] = 0x36,\n\t\t\t\t[IQS7211E] = 0x25,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 5,\n\t\t.reg_width = 4,\n\t\t.label = \"ATI coarse fractional multiplier\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-frac-div-coarse\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x1E,\n\t\t\t\t[IQS7211A] = 0x30,\n\t\t\t\t[IQS7211E] = 0x21,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x22,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x23,\n\t\t\t\t[IQS7211A] = 0x36,\n\t\t\t\t[IQS7211E] = 0x25,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 5,\n\t\t.label = \"ATI coarse fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-comp-div\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x1F,\n\t\t\t\t[IQS7211E] = 0x22,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x24,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7211E] = 0x26,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.val_max = 31,\n\t\t.label = \"ATI compensation divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-comp-div\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x24,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_max = 31,\n\t\t.label = \"ATI compensation divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-comp-div\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7211A] = 0x31,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7211A] = 0x37,\n\t\t\t},\n\t\t},\n\t\t.val_max = 31,\n\t\t.label = \"ATI compensation divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-target\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x20,\n\t\t\t\t[IQS7211A] = 0x32,\n\t\t\t\t[IQS7211E] = 0x23,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x27,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x28,\n\t\t\t\t[IQS7211A] = 0x38,\n\t\t\t\t[IQS7211E] = 0x27,\n\t\t\t},\n\t\t},\n\t\t.label = \"ATI target\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-base\",\n\t\t.reg_addr[IQS7211_REG_GRP_ALP] = {\n\t\t\t[IQS7210A] = 0x26,\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 8,\n\t\t.label = \"ATI base\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-base\",\n\t\t.reg_addr[IQS7211_REG_GRP_BTN] = {\n\t\t\t[IQS7210A] = 0x26,\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 8,\n\t\t.label = \"ATI base\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-active-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x29,\n\t\t\t[IQS7211A] = 0x40,\n\t\t\t[IQS7211E] = 0x28,\n\t\t},\n\t\t.label = \"active mode report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-touch-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x2A,\n\t\t\t[IQS7211A] = 0x41,\n\t\t\t[IQS7211E] = 0x29,\n\t\t},\n\t\t.label = \"idle-touch mode report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-idle-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x2B,\n\t\t\t[IQS7211A] = 0x42,\n\t\t\t[IQS7211E] = 0x2A,\n\t\t},\n\t\t.label = \"idle mode report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-lp1-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x2C,\n\t\t\t[IQS7211A] = 0x43,\n\t\t\t[IQS7211E] = 0x2B,\n\t\t},\n\t\t.label = \"low-power mode 1 report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,rate-lp2-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x2D,\n\t\t\t[IQS7211A] = 0x44,\n\t\t\t[IQS7211E] = 0x2C,\n\t\t},\n\t\t.label = \"low-power mode 2 report rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-active-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x2E,\n\t\t\t[IQS7211A] = 0x45,\n\t\t\t[IQS7211E] = 0x2D,\n\t\t},\n\t\t.val_pitch = 1000,\n\t\t.label = \"active mode timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-touch-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x2F,\n\t\t\t[IQS7211A] = 0x46,\n\t\t\t[IQS7211E] = 0x2E,\n\t\t},\n\t\t.val_pitch = 1000,\n\t\t.label = \"idle-touch mode timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-idle-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x30,\n\t\t\t[IQS7211A] = 0x47,\n\t\t\t[IQS7211E] = 0x2F,\n\t\t},\n\t\t.val_pitch = 1000,\n\t\t.label = \"idle mode timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-lp1-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x31,\n\t\t\t[IQS7211A] = 0x48,\n\t\t\t[IQS7211E] = 0x30,\n\t\t},\n\t\t.val_pitch = 1000,\n\t\t.label = \"low-power mode 1 timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-lp2-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x32,\n\t\t\t[IQS7211E] = 0x31,\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_pitch = 1000,\n\t\t.val_max = 60000,\n\t\t.label = \"trackpad reference value update rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-lp2-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7211A] = 0x49,\n\t\t},\n\t\t.val_pitch = 1000,\n\t\t.val_max = 60000,\n\t\t.label = \"trackpad reference value update rate\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-ati-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x32,\n\t\t\t[IQS7211E] = 0x31,\n\t\t},\n\t\t.reg_width = 8,\n\t\t.val_pitch = 1000,\n\t\t.val_max = 60000,\n\t\t.label = \"ATI error timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-ati-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7211A] = 0x35,\n\t\t},\n\t\t.val_pitch = 1000,\n\t\t.val_max = 60000,\n\t\t.label = \"ATI error timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-comms-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x33,\n\t\t\t[IQS7211A] = 0x4A,\n\t\t\t[IQS7211E] = 0x32,\n\t\t},\n\t\t.label = \"communication timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,timeout-press-ms\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x34,\n\t\t},\n\t\t.reg_width = 8,\n\t\t.val_pitch = 1000,\n\t\t.val_max = 60000,\n\t\t.label = \"press timeout\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-mode\",\n\t\t.reg_addr[IQS7211_REG_GRP_ALP] = {\n\t\t\t[IQS7210A] = 0x37,\n\t\t},\n\t\t.reg_shift = 15,\n\t\t.reg_width = 1,\n\t\t.label = \"ATI mode\",\n\t},\n\t{\n\t\t.name = \"azoteq,ati-mode\",\n\t\t.reg_addr[IQS7211_REG_GRP_BTN] = {\n\t\t\t[IQS7210A] = 0x37,\n\t\t},\n\t\t.reg_shift = 7,\n\t\t.reg_width = 1,\n\t\t.label = \"ATI mode\",\n\t},\n\t{\n\t\t.name = \"azoteq,sense-mode\",\n\t\t.reg_addr[IQS7211_REG_GRP_ALP] = {\n\t\t\t[IQS7210A] = 0x37,\n\t\t\t[IQS7211A] = 0x72,\n\t\t\t[IQS7211E] = 0x36,\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 1,\n\t\t.label = \"sensing mode\",\n\t},\n\t{\n\t\t.name = \"azoteq,sense-mode\",\n\t\t.reg_addr[IQS7211_REG_GRP_BTN] = {\n\t\t\t[IQS7210A] = 0x37,\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 2,\n\t\t.val_max = 2,\n\t\t.label = \"sensing mode\",\n\t},\n\t{\n\t\t.name = \"azoteq,fosc-freq\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x38,\n\t\t\t[IQS7211A] = 0x52,\n\t\t\t[IQS7211E] = 0x35,\n\t\t},\n\t\t.reg_shift = 4,\n\t\t.reg_width = 1,\n\t\t.label = \"core clock frequency selection\",\n\t},\n\t{\n\t\t.name = \"azoteq,fosc-trim\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x38,\n\t\t\t[IQS7211A] = 0x52,\n\t\t\t[IQS7211E] = 0x35,\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 4,\n\t\t.label = \"core clock frequency trim\",\n\t},\n\t{\n\t\t.name = \"azoteq,touch-exit\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x3B,\n\t\t\t\t[IQS7211A] = 0x53,\n\t\t\t\t[IQS7211E] = 0x38,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x3E,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"touch exit factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,touch-enter\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x3B,\n\t\t\t\t[IQS7211A] = 0x53,\n\t\t\t\t[IQS7211E] = 0x38,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x3E,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"touch entrance factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,thresh\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x3C,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x3D,\n\t\t\t\t[IQS7211A] = 0x54,\n\t\t\t\t[IQS7211E] = 0x39,\n\t\t\t},\n\t\t},\n\t\t.label = \"threshold\",\n\t},\n\t{\n\t\t.name = \"azoteq,debounce-exit\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x3F,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x40,\n\t\t\t\t[IQS7211A] = 0x56,\n\t\t\t\t[IQS7211E] = 0x3A,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"debounce exit factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,debounce-enter\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x3F,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x40,\n\t\t\t\t[IQS7211A] = 0x56,\n\t\t\t\t[IQS7211E] = 0x3A,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"debounce entrance factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,conv-frac\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x48,\n\t\t\t\t[IQS7211A] = 0x58,\n\t\t\t\t[IQS7211E] = 0x3D,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x49,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x4A,\n\t\t\t\t[IQS7211A] = 0x59,\n\t\t\t\t[IQS7211E] = 0x3E,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"conversion frequency fractional divider\",\n\t},\n\t{\n\t\t.name = \"azoteq,conv-period\",\n\t\t.reg_addr = {\n\t\t\t[IQS7211_REG_GRP_TP] = {\n\t\t\t\t[IQS7210A] = 0x48,\n\t\t\t\t[IQS7211A] = 0x58,\n\t\t\t\t[IQS7211E] = 0x3D,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_BTN] = {\n\t\t\t\t[IQS7210A] = 0x49,\n\t\t\t},\n\t\t\t[IQS7211_REG_GRP_ALP] = {\n\t\t\t\t[IQS7210A] = 0x4A,\n\t\t\t\t[IQS7211A] = 0x59,\n\t\t\t\t[IQS7211E] = 0x3E,\n\t\t\t},\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"conversion period\",\n\t},\n\t{\n\t\t.name = \"azoteq,thresh\",\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x55,\n\t\t\t[IQS7211A] = 0x67,\n\t\t\t[IQS7211E] = 0x48,\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"threshold\",\n\t},\n\t{\n\t\t.name = \"azoteq,contact-split\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x55,\n\t\t\t[IQS7211A] = 0x67,\n\t\t\t[IQS7211E] = 0x48,\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"contact split factor\",\n\t},\n\t{\n\t\t.name = \"azoteq,trim-x\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x56,\n\t\t\t[IQS7211E] = 0x49,\n\t\t},\n\t\t.reg_shift = 0,\n\t\t.reg_width = 8,\n\t\t.label = \"horizontal trim width\",\n\t},\n\t{\n\t\t.name = \"azoteq,trim-x\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7211A] = 0x68,\n\t\t},\n\t\t.label = \"horizontal trim width\",\n\t},\n\t{\n\t\t.name = \"azoteq,trim-y\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7210A] = 0x56,\n\t\t\t[IQS7211E] = 0x49,\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.label = \"vertical trim height\",\n\t},\n\t{\n\t\t.name = \"azoteq,trim-y\",\n\t\t.reg_addr[IQS7211_REG_GRP_SYS] = {\n\t\t\t[IQS7211A] = 0x69,\n\t\t},\n\t\t.label = \"vertical trim height\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x59,\n\t\t\t[IQS7211A] = 0x81,\n\t\t\t[IQS7211E] = 0x4C,\n\t\t},\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-mid-ms\",\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7211E] = 0x4D,\n\t\t},\n\t\t.label = \"repeated gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_key = IQS7211_REG_KEY_TAP,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5A,\n\t\t\t[IQS7211A] = 0x82,\n\t\t\t[IQS7211E] = 0x4E,\n\t\t},\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5A,\n\t\t\t[IQS7211A] = 0x82,\n\t\t\t[IQS7211E] = 0x4E,\n\t\t},\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-min-ms\",\n\t\t.reg_key = IQS7211_REG_KEY_HOLD,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5B,\n\t\t\t[IQS7211A] = 0x83,\n\t\t\t[IQS7211E] = 0x4F,\n\t\t},\n\t\t.label = \"minimum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5C,\n\t\t\t[IQS7211A] = 0x84,\n\t\t\t[IQS7211E] = 0x50,\n\t\t},\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-max-ms\",\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5C,\n\t\t\t[IQS7211A] = 0x84,\n\t\t\t[IQS7211E] = 0x50,\n\t\t},\n\t\t.label = \"maximum gesture time\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5D,\n\t\t\t[IQS7211A] = 0x85,\n\t\t\t[IQS7211E] = 0x51,\n\t\t},\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist\",\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7210A] = 0x5E,\n\t\t\t[IQS7211A] = 0x86,\n\t\t\t[IQS7211E] = 0x52,\n\t\t},\n\t\t.label = \"gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist-rep\",\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_X,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7211E] = 0x53,\n\t\t},\n\t\t.label = \"repeated gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,gesture-dist-rep\",\n\t\t.reg_key = IQS7211_REG_KEY_AXIAL_Y,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7211E] = 0x54,\n\t\t},\n\t\t.label = \"repeated gesture distance\",\n\t},\n\t{\n\t\t.name = \"azoteq,thresh\",\n\t\t.reg_key = IQS7211_REG_KEY_PALM,\n\t\t.reg_addr[IQS7211_REG_GRP_TP] = {\n\t\t\t[IQS7211E] = 0x55,\n\t\t},\n\t\t.reg_shift = 8,\n\t\t.reg_width = 8,\n\t\t.val_max = 42,\n\t\t.label = \"threshold\",\n\t},\n};\n\nstatic const u8 iqs7211_gesture_angle[] = {\n\t0x00, 0x01, 0x02, 0x03,\n\t0x04, 0x06, 0x07, 0x08,\n\t0x09, 0x0A, 0x0B, 0x0C,\n\t0x0E, 0x0F, 0x10, 0x11,\n\t0x12, 0x14, 0x15, 0x16,\n\t0x17, 0x19, 0x1A, 0x1B,\n\t0x1C, 0x1E, 0x1F, 0x21,\n\t0x22, 0x23, 0x25, 0x26,\n\t0x28, 0x2A, 0x2B, 0x2D,\n\t0x2E, 0x30, 0x32, 0x34,\n\t0x36, 0x38, 0x3A, 0x3C,\n\t0x3E, 0x40, 0x42, 0x45,\n\t0x47, 0x4A, 0x4C, 0x4F,\n\t0x52, 0x55, 0x58, 0x5B,\n\t0x5F, 0x63, 0x66, 0x6B,\n\t0x6F, 0x73, 0x78, 0x7E,\n\t0x83, 0x89, 0x90, 0x97,\n\t0x9E, 0xA7, 0xB0, 0xBA,\n\t0xC5, 0xD1, 0xDF, 0xEF,\n};\n\nstruct iqs7211_ver_info {\n\t__le16 prod_num;\n\t__le16 major;\n\t__le16 minor;\n\t__le32 patch;\n} __packed;\n\nstruct iqs7211_touch_data {\n\t__le16 abs_x;\n\t__le16 abs_y;\n\t__le16 pressure;\n\t__le16 area;\n} __packed;\n\nstruct iqs7211_tp_config {\n\tu8 tp_settings;\n\tu8 total_rx;\n\tu8 total_tx;\n\tu8 num_contacts;\n\t__le16 max_x;\n\t__le16 max_y;\n} __packed;\n\nstruct iqs7211_private {\n\tconst struct iqs7211_dev_desc *dev_desc;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *irq_gpio;\n\tstruct i2c_client *client;\n\tstruct input_dev *tp_idev;\n\tstruct input_dev *kp_idev;\n\tstruct iqs7211_ver_info ver_info;\n\tstruct iqs7211_tp_config tp_config;\n\tstruct touchscreen_properties prop;\n\tstruct list_head reg_field_head;\n\tenum iqs7211_comms_mode comms_init;\n\tenum iqs7211_comms_mode comms_mode;\n\tunsigned int num_contacts;\n\tunsigned int kp_code[ARRAY_SIZE(iqs7211e_kp_events)];\n\tu8 rx_tx_map[IQS7211_MAX_CTX + 1];\n\tu8 cycle_alloc[2][33];\n\tu8 exp_file[2];\n\tu16 event_mask;\n\tu16 ati_start;\n\tu16 gesture_cache;\n};\n\nstatic int iqs7211_irq_poll(struct iqs7211_private *iqs7211, u64 timeout_us)\n{\n\tint error, val;\n\n\terror = readx_poll_timeout(gpiod_get_value_cansleep, iqs7211->irq_gpio,\n\t\t\t\t   val, val, IQS7211_COMMS_SLEEP_US, timeout_us);\n\n\treturn val < 0 ? val : error;\n}\n\nstatic int iqs7211_hard_reset(struct iqs7211_private *iqs7211)\n{\n\tif (!iqs7211->reset_gpio)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(iqs7211->reset_gpio, 1);\n\n\t \n\tif (iqs7211->reset_gpio == iqs7211->irq_gpio)\n\t\tmsleep(IQS7211_RESET_TIMEOUT_MS);\n\telse\n\t\tusleep_range(1000, 1100);\n\n\tgpiod_set_value_cansleep(iqs7211->reset_gpio, 0);\n\tif (iqs7211->reset_gpio == iqs7211->irq_gpio)\n\t\tiqs7211_irq_wait();\n\n\treturn iqs7211_irq_poll(iqs7211, IQS7211_START_TIMEOUT_US);\n}\n\nstatic int iqs7211_force_comms(struct iqs7211_private *iqs7211)\n{\n\tu8 msg_buf[] = { 0xFF, };\n\tint ret;\n\n\tswitch (iqs7211->comms_mode) {\n\tcase IQS7211_COMMS_MODE_WAIT:\n\t\treturn iqs7211_irq_poll(iqs7211, IQS7211_START_TIMEOUT_US);\n\n\tcase IQS7211_COMMS_MODE_FREE:\n\t\treturn 0;\n\n\tcase IQS7211_COMMS_MODE_FORCE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = gpiod_get_value_cansleep(iqs7211->irq_gpio);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret > 0)\n\t\treturn 0;\n\n\tret = i2c_master_send(iqs7211->client, msg_buf, sizeof(msg_buf));\n\tif (ret < (int)sizeof(msg_buf)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\n\t\tmsleep(IQS7211_COMMS_RETRY_MS);\n\t\treturn ret;\n\t}\n\n\tiqs7211_irq_wait();\n\n\treturn iqs7211_irq_poll(iqs7211, IQS7211_COMMS_TIMEOUT_US);\n}\n\nstatic int iqs7211_read_burst(struct iqs7211_private *iqs7211,\n\t\t\t      u8 reg, void *val, u16 val_len)\n{\n\tint ret, i;\n\tstruct i2c_client *client = iqs7211->client;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(reg),\n\t\t\t.buf = &reg,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = val_len,\n\t\t\t.buf = (u8 *)val,\n\t\t},\n\t};\n\n\t \n\tfor (i = 0; i < IQS7211_NUM_RETRIES; i++) {\n\t\tret = iqs7211_force_comms(iqs7211);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\t\tif (ret < (int)ARRAY_SIZE(msg)) {\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EIO;\n\n\t\t\tmsleep(IQS7211_COMMS_RETRY_MS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (get_unaligned_le16(msg[1].buf) == IQS7211_COMMS_ERROR) {\n\t\t\tret = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tiqs7211_irq_wait();\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read from address 0x%02X: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int iqs7211_read_word(struct iqs7211_private *iqs7211, u8 reg, u16 *val)\n{\n\t__le16 val_buf;\n\tint error;\n\n\terror = iqs7211_read_burst(iqs7211, reg, &val_buf, sizeof(val_buf));\n\tif (error)\n\t\treturn error;\n\n\t*val = le16_to_cpu(val_buf);\n\n\treturn 0;\n}\n\nstatic int iqs7211_write_burst(struct iqs7211_private *iqs7211,\n\t\t\t       u8 reg, const void *val, u16 val_len)\n{\n\tint msg_len = sizeof(reg) + val_len;\n\tint ret, i;\n\tstruct i2c_client *client = iqs7211->client;\n\tu8 *msg_buf;\n\n\tmsg_buf = kzalloc(msg_len, GFP_KERNEL);\n\tif (!msg_buf)\n\t\treturn -ENOMEM;\n\n\t*msg_buf = reg;\n\tmemcpy(msg_buf + sizeof(reg), val, val_len);\n\n\t \n\tfor (i = 0; i < IQS7211_NUM_RETRIES; i++) {\n\t\tret = iqs7211_force_comms(iqs7211);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tret = i2c_master_send(client, msg_buf, msg_len);\n\t\tif (ret < msg_len) {\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EIO;\n\n\t\t\tmsleep(IQS7211_COMMS_RETRY_MS);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tkfree(msg_buf);\n\n\tiqs7211_irq_wait();\n\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to write to address 0x%02X: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int iqs7211_write_word(struct iqs7211_private *iqs7211, u8 reg, u16 val)\n{\n\t__le16 val_buf = cpu_to_le16(val);\n\n\treturn iqs7211_write_burst(iqs7211, reg, &val_buf, sizeof(val_buf));\n}\n\nstatic int iqs7211_start_comms(struct iqs7211_private *iqs7211)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct i2c_client *client = iqs7211->client;\n\tbool forced_comms;\n\tunsigned int val;\n\tu16 comms_setup;\n\tint error;\n\n\t \n\tforced_comms = device_property_present(&client->dev,\n\t\t\t\t\t       \"azoteq,forced-comms\");\n\n\terror = device_property_read_u32(&client->dev,\n\t\t\t\t\t \"azoteq,forced-comms-default\", &val);\n\tif (error == -EINVAL) {\n\t\tiqs7211->comms_init = IQS7211_COMMS_MODE_WAIT;\n\t} else if (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to read default communication mode: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t} else if (val) {\n\t\tiqs7211->comms_init = forced_comms ? IQS7211_COMMS_MODE_FORCE\n\t\t\t\t\t\t   : IQS7211_COMMS_MODE_WAIT;\n\t} else {\n\t\tiqs7211->comms_init = forced_comms ? IQS7211_COMMS_MODE_WAIT\n\t\t\t\t\t\t   : IQS7211_COMMS_MODE_FREE;\n\t}\n\n\tiqs7211->comms_mode = iqs7211->comms_init;\n\n\terror = iqs7211_hard_reset(iqs7211);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to reset device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = iqs7211_read_burst(iqs7211, IQS7211_PROD_NUM,\n\t\t\t\t   &iqs7211->ver_info,\n\t\t\t\t   sizeof(iqs7211->ver_info));\n\tif (error)\n\t\treturn error;\n\n\tif (le16_to_cpu(iqs7211->ver_info.prod_num) != dev_desc->prod_num) {\n\t\tdev_err(&client->dev, \"Invalid product number: %u\\n\",\n\t\t\tle16_to_cpu(iqs7211->ver_info.prod_num));\n\t\treturn -EINVAL;\n\t}\n\n\terror = iqs7211_read_word(iqs7211, dev_desc->sys_ctrl + 1,\n\t\t\t\t  &comms_setup);\n\tif (error)\n\t\treturn error;\n\n\tif (forced_comms)\n\t\tcomms_setup |= dev_desc->comms_req;\n\telse\n\t\tcomms_setup &= ~dev_desc->comms_req;\n\n\terror = iqs7211_write_word(iqs7211, dev_desc->sys_ctrl + 1,\n\t\t\t\t   comms_setup | dev_desc->comms_end);\n\tif (error)\n\t\treturn error;\n\n\tif (forced_comms)\n\t\tiqs7211->comms_mode = IQS7211_COMMS_MODE_FORCE;\n\telse\n\t\tiqs7211->comms_mode = IQS7211_COMMS_MODE_FREE;\n\n\terror = iqs7211_read_burst(iqs7211, dev_desc->exp_file,\n\t\t\t\t   iqs7211->exp_file,\n\t\t\t\t   sizeof(iqs7211->exp_file));\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7211_read_burst(iqs7211, dev_desc->tp_config,\n\t\t\t\t   &iqs7211->tp_config,\n\t\t\t\t   sizeof(iqs7211->tp_config));\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7211_write_word(iqs7211, dev_desc->sys_ctrl + 1,\n\t\t\t\t   comms_setup);\n\tif (error)\n\t\treturn error;\n\n\tiqs7211->event_mask = comms_setup & ~IQS7211_EVENT_MASK_ALL;\n\tiqs7211->event_mask |= (IQS7211_EVENT_MASK_ATI | IQS7211_EVENT_MODE);\n\n\treturn 0;\n}\n\nstatic int iqs7211_init_device(struct iqs7211_private *iqs7211)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct iqs7211_reg_field_desc *reg_field;\n\t__le16 sys_ctrl[] = {\n\t\tcpu_to_le16(dev_desc->ack_reset),\n\t\tcpu_to_le16(iqs7211->event_mask),\n\t};\n\tint error, i;\n\n\t \n\terror = iqs7211_write_burst(iqs7211, dev_desc->sys_ctrl, sys_ctrl,\n\t\t\t\t    sizeof(sys_ctrl));\n\tif (error)\n\t\treturn error;\n\n\tif (iqs7211->event_mask & dev_desc->comms_req)\n\t\tiqs7211->comms_mode = IQS7211_COMMS_MODE_FORCE;\n\telse\n\t\tiqs7211->comms_mode = IQS7211_COMMS_MODE_FREE;\n\n\t \n\terror = iqs7211_write_word(iqs7211, dev_desc->sys_ctrl + 1,\n\t\t\t\t   iqs7211->event_mask | dev_desc->comms_end);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_entry(reg_field, &iqs7211->reg_field_head, list) {\n\t\tu16 new_val = reg_field->val;\n\n\t\tif (reg_field->mask < U16_MAX) {\n\t\t\tu16 old_val;\n\n\t\t\terror = iqs7211_read_word(iqs7211, reg_field->addr,\n\t\t\t\t\t\t  &old_val);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tnew_val = old_val & ~reg_field->mask;\n\t\t\tnew_val |= reg_field->val;\n\n\t\t\tif (new_val == old_val)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terror = iqs7211_write_word(iqs7211, reg_field->addr, new_val);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = iqs7211_write_burst(iqs7211, dev_desc->tp_config,\n\t\t\t\t    &iqs7211->tp_config,\n\t\t\t\t    sizeof(iqs7211->tp_config));\n\tif (error)\n\t\treturn error;\n\n\tif (**iqs7211->cycle_alloc) {\n\t\terror = iqs7211_write_burst(iqs7211, dev_desc->rx_tx_map,\n\t\t\t\t\t    &iqs7211->rx_tx_map,\n\t\t\t\t\t    dev_desc->num_ctx);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tfor (i = 0; i < sizeof(dev_desc->cycle_limit); i++) {\n\t\t\terror = iqs7211_write_burst(iqs7211,\n\t\t\t\t\t\t    dev_desc->cycle_alloc[i],\n\t\t\t\t\t\t    iqs7211->cycle_alloc[i],\n\t\t\t\t\t\t    dev_desc->cycle_limit[i] * 3);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\t*sys_ctrl = cpu_to_le16(iqs7211->ati_start);\n\n\treturn iqs7211_write_burst(iqs7211, dev_desc->sys_ctrl, sys_ctrl,\n\t\t\t\t   sizeof(sys_ctrl));\n}\n\nstatic int iqs7211_add_field(struct iqs7211_private *iqs7211,\n\t\t\t     struct iqs7211_reg_field_desc new_field)\n{\n\tstruct i2c_client *client = iqs7211->client;\n\tstruct iqs7211_reg_field_desc *reg_field;\n\n\tif (!new_field.addr)\n\t\treturn 0;\n\n\tlist_for_each_entry(reg_field, &iqs7211->reg_field_head, list) {\n\t\tif (reg_field->addr != new_field.addr)\n\t\t\tcontinue;\n\n\t\treg_field->mask |= new_field.mask;\n\t\treg_field->val |= new_field.val;\n\t\treturn 0;\n\t}\n\n\treg_field = devm_kzalloc(&client->dev, sizeof(*reg_field), GFP_KERNEL);\n\tif (!reg_field)\n\t\treturn -ENOMEM;\n\n\treg_field->addr = new_field.addr;\n\treg_field->mask = new_field.mask;\n\treg_field->val = new_field.val;\n\n\tlist_add(&reg_field->list, &iqs7211->reg_field_head);\n\n\treturn 0;\n}\n\nstatic int iqs7211_parse_props(struct iqs7211_private *iqs7211,\n\t\t\t       struct fwnode_handle *reg_grp_node,\n\t\t\t       enum iqs7211_reg_grp_id reg_grp,\n\t\t\t       enum iqs7211_reg_key_id reg_key)\n{\n\tstruct i2c_client *client = iqs7211->client;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(iqs7211_props); i++) {\n\t\tconst char *name = iqs7211_props[i].name;\n\t\tu8 reg_addr = iqs7211_props[i].reg_addr[reg_grp]\n\t\t\t\t\t\t       [iqs7211->dev_desc -\n\t\t\t\t\t\t\tiqs7211_devs];\n\t\tint reg_shift = iqs7211_props[i].reg_shift;\n\t\tint reg_width = iqs7211_props[i].reg_width ? : 16;\n\t\tint val_pitch = iqs7211_props[i].val_pitch ? : 1;\n\t\tint val_min = iqs7211_props[i].val_min;\n\t\tint val_max = iqs7211_props[i].val_max;\n\t\tconst char *label = iqs7211_props[i].label ? : name;\n\t\tstruct iqs7211_reg_field_desc reg_field;\n\t\tunsigned int val;\n\t\tint error;\n\n\t\tif (iqs7211_props[i].reg_key != reg_key)\n\t\t\tcontinue;\n\n\t\tif (!reg_addr)\n\t\t\tcontinue;\n\n\t\terror = fwnode_property_read_u32(reg_grp_node, name, &val);\n\t\tif (error == -EINVAL) {\n\t\t\tcontinue;\n\t\t} else if (error) {\n\t\t\tdev_err(&client->dev, \"Failed to read %s %s: %d\\n\",\n\t\t\t\tfwnode_get_name(reg_grp_node), label, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (!val_max)\n\t\t\tval_max = GENMASK(reg_width - 1, 0) * val_pitch;\n\n\t\tif (val < val_min || val > val_max) {\n\t\t\tdev_err(&client->dev, \"Invalid %s: %u\\n\", label, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treg_field.addr = reg_addr;\n\t\treg_field.mask = GENMASK(reg_shift + reg_width - 1, reg_shift);\n\t\treg_field.val = val / val_pitch << reg_shift;\n\n\t\terror = iqs7211_add_field(iqs7211, reg_field);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs7211_parse_event(struct iqs7211_private *iqs7211,\n\t\t\t       struct fwnode_handle *event_node,\n\t\t\t       enum iqs7211_reg_grp_id reg_grp,\n\t\t\t       enum iqs7211_reg_key_id reg_key,\n\t\t\t       unsigned int *event_code)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct i2c_client *client = iqs7211->client;\n\tstruct iqs7211_reg_field_desc reg_field;\n\tunsigned int val;\n\tint error;\n\n\terror = iqs7211_parse_props(iqs7211, event_node, reg_grp, reg_key);\n\tif (error)\n\t\treturn error;\n\n\tif (reg_key == IQS7211_REG_KEY_AXIAL_X ||\n\t    reg_key == IQS7211_REG_KEY_AXIAL_Y) {\n\t\terror = fwnode_property_read_u32(event_node,\n\t\t\t\t\t\t \"azoteq,gesture-angle\", &val);\n\t\tif (!error) {\n\t\t\tif (val >= ARRAY_SIZE(iqs7211_gesture_angle)) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Invalid %s gesture angle: %u\\n\",\n\t\t\t\t\tfwnode_get_name(event_node), val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treg_field.addr = dev_desc->gesture_angle;\n\t\t\treg_field.mask = U8_MAX;\n\t\t\treg_field.val = iqs7211_gesture_angle[val];\n\n\t\t\terror = iqs7211_add_field(iqs7211, reg_field);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else if (error != -EINVAL) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to read %s gesture angle: %d\\n\",\n\t\t\t\tfwnode_get_name(event_node), error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = fwnode_property_read_u32(event_node, \"linux,code\", event_code);\n\tif (error == -EINVAL)\n\t\terror = 0;\n\telse if (error)\n\t\tdev_err(&client->dev, \"Failed to read %s code: %d\\n\",\n\t\t\tfwnode_get_name(event_node), error);\n\n\treturn error;\n}\n\nstatic int iqs7211_parse_cycles(struct iqs7211_private *iqs7211,\n\t\t\t\tstruct fwnode_handle *tp_node)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct i2c_client *client = iqs7211->client;\n\tint num_cycles = dev_desc->cycle_limit[0] + dev_desc->cycle_limit[1];\n\tint error, count, i, j, k, cycle_start;\n\tunsigned int cycle_alloc[IQS7211_MAX_CYCLES][2];\n\tu8 total_rx = iqs7211->tp_config.total_rx;\n\tu8 total_tx = iqs7211->tp_config.total_tx;\n\n\tfor (i = 0; i < IQS7211_MAX_CYCLES * 2; i++)\n\t\t*(cycle_alloc[0] + i) = U8_MAX;\n\n\tcount = fwnode_property_count_u32(tp_node, \"azoteq,channel-select\");\n\tif (count == -EINVAL) {\n\t\t \n\t\tfor (i = 0, cycle_start = 0; i < total_tx; i++) {\n\t\t\tint cycle_stop = 0;\n\n\t\t\tfor (j = 0; j < total_rx; j++) {\n\t\t\t\t \n\t\t\t\tint slot = iqs7211->rx_tx_map[j] < 4 ? 0 : 1;\n\t\t\t\tint chan = i * total_rx + j;\n\n\t\t\t\tfor (k = cycle_start; k < num_cycles; k++) {\n\t\t\t\t\tif (cycle_alloc[k][slot] < U8_MAX)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcycle_alloc[k][slot] = chan;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (k < num_cycles) {\n\t\t\t\t\tcycle_stop = max(k, cycle_stop);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Insufficient number of cycles\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tcycle_start = cycle_stop + 1;\n\t\t}\n\t} else if (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count channels: %d\\n\", count);\n\t\treturn count;\n\t} else if (count > num_cycles * 2) {\n\t\tdev_err(&client->dev, \"Insufficient number of cycles\\n\");\n\t\treturn -EINVAL;\n\t} else if (count > 0) {\n\t\terror = fwnode_property_read_u32_array(tp_node,\n\t\t\t\t\t\t       \"azoteq,channel-select\",\n\t\t\t\t\t\t       cycle_alloc[0], count);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Failed to read channels: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint chan = *(cycle_alloc[0] + i);\n\n\t\t\tif (chan == U8_MAX)\n\t\t\t\tcontinue;\n\n\t\t\tif (chan >= total_rx * total_tx) {\n\t\t\t\tdev_err(&client->dev, \"Invalid channel: %d\\n\",\n\t\t\t\t\tchan);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tif (j == i || *(cycle_alloc[0] + j) != chan)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdev_err(&client->dev, \"Duplicate channel: %d\\n\",\n\t\t\t\t\tchan);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, cycle_start = 0; i < sizeof(dev_desc->cycle_limit); i++) {\n\t\tint offs = 0;\n\n\t\tfor (j = cycle_start;\n\t\t     j < cycle_start + dev_desc->cycle_limit[i]; j++) {\n\t\t\tiqs7211->cycle_alloc[i][offs++] = 0x05;\n\t\t\tiqs7211->cycle_alloc[i][offs++] = cycle_alloc[j][0];\n\t\t\tiqs7211->cycle_alloc[i][offs++] = cycle_alloc[j][1];\n\t\t}\n\n\t\tcycle_start += dev_desc->cycle_limit[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int iqs7211_parse_tp(struct iqs7211_private *iqs7211,\n\t\t\t    struct fwnode_handle *tp_node)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct i2c_client *client = iqs7211->client;\n\tunsigned int pins[IQS7211_MAX_CTX];\n\tint error, count, i, j;\n\n\tcount = fwnode_property_count_u32(tp_node, \"azoteq,rx-enable\");\n\tif (count == -EINVAL) {\n\t\treturn 0;\n\t} else if (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count CRx pins: %d\\n\", count);\n\t\treturn count;\n\t} else if (count > IQS7211_NUM_CRX) {\n\t\tdev_err(&client->dev, \"Invalid number of CRx pins\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = fwnode_property_read_u32_array(tp_node, \"azoteq,rx-enable\",\n\t\t\t\t\t       pins, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read CRx pins: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (pins[i] >= IQS7211_NUM_CRX) {\n\t\t\tdev_err(&client->dev, \"Invalid CRx pin: %u\\n\", pins[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiqs7211->rx_tx_map[i] = pins[i];\n\t}\n\n\tiqs7211->tp_config.total_rx = count;\n\n\tcount = fwnode_property_count_u32(tp_node, \"azoteq,tx-enable\");\n\tif (count < 0) {\n\t\tdev_err(&client->dev, \"Failed to count CTx pins: %d\\n\", count);\n\t\treturn count;\n\t} else if (count > dev_desc->num_ctx) {\n\t\tdev_err(&client->dev, \"Invalid number of CTx pins\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = fwnode_property_read_u32_array(tp_node, \"azoteq,tx-enable\",\n\t\t\t\t\t       pins, count);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to read CTx pins: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (pins[i] >= dev_desc->num_ctx) {\n\t\t\tdev_err(&client->dev, \"Invalid CTx pin: %u\\n\", pins[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (j = 0; j < iqs7211->tp_config.total_rx; j++) {\n\t\t\tif (iqs7211->rx_tx_map[j] != pins[i])\n\t\t\t\tcontinue;\n\n\t\t\tdev_err(&client->dev, \"Conflicting CTx pin: %u\\n\",\n\t\t\t\tpins[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tiqs7211->rx_tx_map[iqs7211->tp_config.total_rx + i] = pins[i];\n\t}\n\n\tiqs7211->tp_config.total_tx = count;\n\n\treturn iqs7211_parse_cycles(iqs7211, tp_node);\n}\n\nstatic int iqs7211_parse_alp(struct iqs7211_private *iqs7211,\n\t\t\t     struct fwnode_handle *alp_node)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct i2c_client *client = iqs7211->client;\n\tstruct iqs7211_reg_field_desc reg_field;\n\tint error, count, i;\n\n\tcount = fwnode_property_count_u32(alp_node, \"azoteq,rx-enable\");\n\tif (count < 0 && count != -EINVAL) {\n\t\tdev_err(&client->dev, \"Failed to count CRx pins: %d\\n\", count);\n\t\treturn count;\n\t} else if (count > IQS7211_NUM_CRX) {\n\t\tdev_err(&client->dev, \"Invalid number of CRx pins\\n\");\n\t\treturn -EINVAL;\n\t} else if (count >= 0) {\n\t\tunsigned int pins[IQS7211_NUM_CRX];\n\n\t\terror = fwnode_property_read_u32_array(alp_node,\n\t\t\t\t\t\t       \"azoteq,rx-enable\",\n\t\t\t\t\t\t       pins, count);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Failed to read CRx pins: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\treg_field.addr = dev_desc->alp_config;\n\t\treg_field.mask = GENMASK(IQS7211_NUM_CRX - 1, 0);\n\t\treg_field.val = 0;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (pins[i] < dev_desc->min_crx_alp ||\n\t\t\t    pins[i] >= IQS7211_NUM_CRX) {\n\t\t\t\tdev_err(&client->dev, \"Invalid CRx pin: %u\\n\",\n\t\t\t\t\tpins[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treg_field.val |= BIT(pins[i]);\n\t\t}\n\n\t\terror = iqs7211_add_field(iqs7211, reg_field);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tcount = fwnode_property_count_u32(alp_node, \"azoteq,tx-enable\");\n\tif (count < 0 && count != -EINVAL) {\n\t\tdev_err(&client->dev, \"Failed to count CTx pins: %d\\n\", count);\n\t\treturn count;\n\t} else if (count > dev_desc->num_ctx) {\n\t\tdev_err(&client->dev, \"Invalid number of CTx pins\\n\");\n\t\treturn -EINVAL;\n\t} else if (count >= 0) {\n\t\tunsigned int pins[IQS7211_MAX_CTX];\n\n\t\terror = fwnode_property_read_u32_array(alp_node,\n\t\t\t\t\t\t       \"azoteq,tx-enable\",\n\t\t\t\t\t\t       pins, count);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev, \"Failed to read CTx pins: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\treg_field.addr = dev_desc->alp_config + 1;\n\t\treg_field.mask = GENMASK(dev_desc->num_ctx - 1, 0);\n\t\treg_field.val = 0;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (pins[i] >= dev_desc->num_ctx) {\n\t\t\t\tdev_err(&client->dev, \"Invalid CTx pin: %u\\n\",\n\t\t\t\t\tpins[i]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treg_field.val |= BIT(pins[i]);\n\t\t}\n\n\t\terror = iqs7211_add_field(iqs7211, reg_field);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int (*iqs7211_parse_extra[IQS7211_NUM_REG_GRPS])\n\t\t\t\t(struct iqs7211_private *iqs7211,\n\t\t\t\t struct fwnode_handle *reg_grp_node) = {\n\t[IQS7211_REG_GRP_TP] = iqs7211_parse_tp,\n\t[IQS7211_REG_GRP_ALP] = iqs7211_parse_alp,\n};\n\nstatic int iqs7211_parse_reg_grp(struct iqs7211_private *iqs7211,\n\t\t\t\t struct fwnode_handle *reg_grp_node,\n\t\t\t\t enum iqs7211_reg_grp_id reg_grp)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct iqs7211_reg_field_desc reg_field;\n\tint error, i;\n\n\terror = iqs7211_parse_props(iqs7211, reg_grp_node, reg_grp,\n\t\t\t\t    IQS7211_REG_KEY_NONE);\n\tif (error)\n\t\treturn error;\n\n\tif (iqs7211_parse_extra[reg_grp]) {\n\t\terror = iqs7211_parse_extra[reg_grp](iqs7211, reg_grp_node);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tiqs7211->ati_start |= dev_desc->ati_start[reg_grp];\n\n\treg_field.addr = dev_desc->kp_enable[reg_grp];\n\treg_field.mask = 0;\n\treg_field.val = 0;\n\n\tfor (i = 0; i < dev_desc->num_kp_events; i++) {\n\t\tconst char *event_name = dev_desc->kp_events[i].name;\n\t\tstruct fwnode_handle *event_node;\n\n\t\tif (dev_desc->kp_events[i].reg_grp != reg_grp)\n\t\t\tcontinue;\n\n\t\treg_field.mask |= dev_desc->kp_events[i].enable;\n\n\t\tif (event_name)\n\t\t\tevent_node = fwnode_get_named_child_node(reg_grp_node,\n\t\t\t\t\t\t\t\t event_name);\n\t\telse\n\t\t\tevent_node = fwnode_handle_get(reg_grp_node);\n\n\t\tif (!event_node)\n\t\t\tcontinue;\n\n\t\terror = iqs7211_parse_event(iqs7211, event_node,\n\t\t\t\t\t    dev_desc->kp_events[i].reg_grp,\n\t\t\t\t\t    dev_desc->kp_events[i].reg_key,\n\t\t\t\t\t    &iqs7211->kp_code[i]);\n\t\tfwnode_handle_put(event_node);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treg_field.val |= dev_desc->kp_events[i].enable;\n\n\t\tiqs7211->event_mask |= iqs7211_reg_grp_masks[reg_grp];\n\t}\n\n\treturn iqs7211_add_field(iqs7211, reg_field);\n}\n\nstatic int iqs7211_register_kp(struct iqs7211_private *iqs7211)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct input_dev *kp_idev = iqs7211->kp_idev;\n\tstruct i2c_client *client = iqs7211->client;\n\tint error, i;\n\n\tfor (i = 0; i < dev_desc->num_kp_events; i++)\n\t\tif (iqs7211->kp_code[i])\n\t\t\tbreak;\n\n\tif (i == dev_desc->num_kp_events)\n\t\treturn 0;\n\n\tkp_idev = devm_input_allocate_device(&client->dev);\n\tif (!kp_idev)\n\t\treturn -ENOMEM;\n\n\tiqs7211->kp_idev = kp_idev;\n\n\tkp_idev->name = dev_desc->kp_name;\n\tkp_idev->id.bustype = BUS_I2C;\n\n\tfor (i = 0; i < dev_desc->num_kp_events; i++)\n\t\tif (iqs7211->kp_code[i])\n\t\t\tinput_set_capability(iqs7211->kp_idev, EV_KEY,\n\t\t\t\t\t     iqs7211->kp_code[i]);\n\n\terror = input_register_device(kp_idev);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to register %s: %d\\n\",\n\t\t\tkp_idev->name, error);\n\n\treturn error;\n}\n\nstatic int iqs7211_register_tp(struct iqs7211_private *iqs7211)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct touchscreen_properties *prop = &iqs7211->prop;\n\tstruct input_dev *tp_idev = iqs7211->tp_idev;\n\tstruct i2c_client *client = iqs7211->client;\n\tint error;\n\n\terror = device_property_read_u32(&client->dev, \"azoteq,num-contacts\",\n\t\t\t\t\t &iqs7211->num_contacts);\n\tif (error == -EINVAL) {\n\t\treturn 0;\n\t} else if (error) {\n\t\tdev_err(&client->dev, \"Failed to read number of contacts: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t} else if (iqs7211->num_contacts > IQS7211_MAX_CONTACTS) {\n\t\tdev_err(&client->dev, \"Invalid number of contacts: %u\\n\",\n\t\t\tiqs7211->num_contacts);\n\t\treturn -EINVAL;\n\t}\n\n\tiqs7211->tp_config.num_contacts = iqs7211->num_contacts ? : 1;\n\n\tif (!iqs7211->num_contacts)\n\t\treturn 0;\n\n\tiqs7211->event_mask |= IQS7211_EVENT_MASK_MOVE;\n\n\ttp_idev = devm_input_allocate_device(&client->dev);\n\tif (!tp_idev)\n\t\treturn -ENOMEM;\n\n\tiqs7211->tp_idev = tp_idev;\n\n\ttp_idev->name = dev_desc->tp_name;\n\ttp_idev->id.bustype = BUS_I2C;\n\n\tinput_set_abs_params(tp_idev, ABS_MT_POSITION_X,\n\t\t\t     0, le16_to_cpu(iqs7211->tp_config.max_x), 0, 0);\n\n\tinput_set_abs_params(tp_idev, ABS_MT_POSITION_Y,\n\t\t\t     0, le16_to_cpu(iqs7211->tp_config.max_y), 0, 0);\n\n\tinput_set_abs_params(tp_idev, ABS_MT_PRESSURE, 0, U16_MAX, 0, 0);\n\n\ttouchscreen_parse_properties(tp_idev, true, prop);\n\n\t \n\tif (prop->max_x >= U16_MAX || prop->max_y >= U16_MAX) {\n\t\tdev_err(&client->dev, \"Invalid trackpad size: %u*%u\\n\",\n\t\t\tprop->max_x, prop->max_y);\n\t\treturn -EINVAL;\n\t}\n\n\tiqs7211->tp_config.max_x = cpu_to_le16(prop->max_x);\n\tiqs7211->tp_config.max_y = cpu_to_le16(prop->max_y);\n\n\terror = input_mt_init_slots(tp_idev, iqs7211->num_contacts,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to initialize slots: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(tp_idev);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to register %s: %d\\n\",\n\t\t\ttp_idev->name, error);\n\n\treturn error;\n}\n\nstatic int iqs7211_report(struct iqs7211_private *iqs7211)\n{\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tstruct i2c_client *client = iqs7211->client;\n\tstruct iqs7211_touch_data *touch_data;\n\tu16 info_flags, charge_mode, gesture_flags;\n\t__le16 status[12];\n\tint error, i;\n\n\terror = iqs7211_read_burst(iqs7211, dev_desc->sys_stat, status,\n\t\t\t\t   dev_desc->contact_offs * sizeof(__le16) +\n\t\t\t\t   iqs7211->num_contacts * sizeof(*touch_data));\n\tif (error)\n\t\treturn error;\n\n\tinfo_flags = le16_to_cpu(status[dev_desc->info_offs]);\n\n\tif (info_flags & dev_desc->show_reset) {\n\t\tdev_err(&client->dev, \"Unexpected device reset\\n\");\n\n\t\t \n\t\tiqs7211->comms_mode = iqs7211->comms_init;\n\n\t\treturn iqs7211_init_device(iqs7211);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dev_desc->ati_error); i++) {\n\t\tif (!(info_flags & dev_desc->ati_error[i]))\n\t\t\tcontinue;\n\n\t\tdev_err(&client->dev, \"Unexpected %s ATI error\\n\",\n\t\t\tiqs7211_reg_grp_names[i]);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < iqs7211->num_contacts; i++) {\n\t\tu16 pressure;\n\n\t\ttouch_data = (struct iqs7211_touch_data *)\n\t\t\t     &status[dev_desc->contact_offs] + i;\n\t\tpressure = le16_to_cpu(touch_data->pressure);\n\n\t\tinput_mt_slot(iqs7211->tp_idev, i);\n\t\tif (input_mt_report_slot_state(iqs7211->tp_idev, MT_TOOL_FINGER,\n\t\t\t\t\t       pressure != 0)) {\n\t\t\ttouchscreen_report_pos(iqs7211->tp_idev, &iqs7211->prop,\n\t\t\t\t\t       le16_to_cpu(touch_data->abs_x),\n\t\t\t\t\t       le16_to_cpu(touch_data->abs_y),\n\t\t\t\t\t       true);\n\t\t\tinput_report_abs(iqs7211->tp_idev, ABS_MT_PRESSURE,\n\t\t\t\t\t pressure);\n\t\t}\n\t}\n\n\tif (iqs7211->num_contacts) {\n\t\tinput_mt_sync_frame(iqs7211->tp_idev);\n\t\tinput_sync(iqs7211->tp_idev);\n\t}\n\n\tif (!iqs7211->kp_idev)\n\t\treturn 0;\n\n\tcharge_mode = info_flags & GENMASK(dev_desc->charge_shift + 2,\n\t\t\t\t\t   dev_desc->charge_shift);\n\tcharge_mode >>= dev_desc->charge_shift;\n\n\t \n\tif (info_flags & dev_desc->kp_events->mask && charge_mode > 2) {\n\t\tinput_report_key(iqs7211->kp_idev, *iqs7211->kp_code, 1);\n\t\tinput_sync(iqs7211->kp_idev);\n\n\t\tinput_report_key(iqs7211->kp_idev, *iqs7211->kp_code, 0);\n\t}\n\n\tfor (i = 0; i < dev_desc->num_kp_events; i++) {\n\t\tif (dev_desc->kp_events[i].reg_grp != IQS7211_REG_GRP_BTN)\n\t\t\tcontinue;\n\n\t\tinput_report_key(iqs7211->kp_idev, iqs7211->kp_code[i],\n\t\t\t\t info_flags & dev_desc->kp_events[i].mask);\n\t}\n\n\tgesture_flags = le16_to_cpu(status[dev_desc->gesture_offs]);\n\n\tfor (i = 0; i < dev_desc->num_kp_events; i++) {\n\t\tenum iqs7211_reg_key_id reg_key = dev_desc->kp_events[i].reg_key;\n\t\tu16 mask = dev_desc->kp_events[i].mask;\n\n\t\tif (dev_desc->kp_events[i].reg_grp != IQS7211_REG_GRP_TP)\n\t\t\tcontinue;\n\n\t\tif ((gesture_flags ^ iqs7211->gesture_cache) & mask)\n\t\t\tinput_report_key(iqs7211->kp_idev, iqs7211->kp_code[i],\n\t\t\t\t\t gesture_flags & mask);\n\n\t\tiqs7211->gesture_cache &= ~mask;\n\n\t\t \n\t\tif (reg_key == IQS7211_REG_KEY_HOLD ||\n\t\t    reg_key == IQS7211_REG_KEY_PALM) {\n\t\t\tiqs7211->gesture_cache |= gesture_flags & mask;\n\t\t\tgesture_flags &= ~mask;\n\t\t}\n\t}\n\n\tif (gesture_flags) {\n\t\tinput_sync(iqs7211->kp_idev);\n\n\t\tfor (i = 0; i < dev_desc->num_kp_events; i++)\n\t\t\tif (dev_desc->kp_events[i].reg_grp == IQS7211_REG_GRP_TP &&\n\t\t\t    gesture_flags & dev_desc->kp_events[i].mask)\n\t\t\t\tinput_report_key(iqs7211->kp_idev,\n\t\t\t\t\t\t iqs7211->kp_code[i], 0);\n\t}\n\n\tinput_sync(iqs7211->kp_idev);\n\n\treturn 0;\n}\n\nstatic irqreturn_t iqs7211_irq(int irq, void *context)\n{\n\tstruct iqs7211_private *iqs7211 = context;\n\n\treturn iqs7211_report(iqs7211) ? IRQ_NONE : IRQ_HANDLED;\n}\n\nstatic int iqs7211_suspend(struct device *dev)\n{\n\tstruct iqs7211_private *iqs7211 = dev_get_drvdata(dev);\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\tint error;\n\n\tif (!dev_desc->suspend || device_may_wakeup(dev))\n\t\treturn 0;\n\n\t \n\tdisable_irq(gpiod_to_irq(iqs7211->irq_gpio));\n\n\terror = iqs7211_write_word(iqs7211, dev_desc->sys_ctrl,\n\t\t\t\t   dev_desc->suspend);\n\n\tenable_irq(gpiod_to_irq(iqs7211->irq_gpio));\n\n\treturn error;\n}\n\nstatic int iqs7211_resume(struct device *dev)\n{\n\tstruct iqs7211_private *iqs7211 = dev_get_drvdata(dev);\n\tconst struct iqs7211_dev_desc *dev_desc = iqs7211->dev_desc;\n\t__le16 sys_ctrl[] = {\n\t\t0,\n\t\tcpu_to_le16(iqs7211->event_mask),\n\t};\n\tint error;\n\n\tif (!dev_desc->suspend || device_may_wakeup(dev))\n\t\treturn 0;\n\n\tdisable_irq(gpiod_to_irq(iqs7211->irq_gpio));\n\n\t \n\terror = iqs7211_write_burst(iqs7211, dev_desc->sys_ctrl, sys_ctrl,\n\t\t\t\t    sizeof(sys_ctrl));\n\n\tenable_irq(gpiod_to_irq(iqs7211->irq_gpio));\n\n\treturn error;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(iqs7211_pm, iqs7211_suspend, iqs7211_resume);\n\nstatic ssize_t fw_info_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct iqs7211_private *iqs7211 = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u.%u.%u.%u:%u.%u\\n\",\n\t\t\t le16_to_cpu(iqs7211->ver_info.prod_num),\n\t\t\t le32_to_cpu(iqs7211->ver_info.patch),\n\t\t\t le16_to_cpu(iqs7211->ver_info.major),\n\t\t\t le16_to_cpu(iqs7211->ver_info.minor),\n\t\t\t iqs7211->exp_file[1], iqs7211->exp_file[0]);\n}\n\nstatic DEVICE_ATTR_RO(fw_info);\n\nstatic struct attribute *iqs7211_attrs[] = {\n\t&dev_attr_fw_info.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(iqs7211);\n\nstatic const struct of_device_id iqs7211_of_match[] = {\n\t{\n\t\t.compatible = \"azoteq,iqs7210a\",\n\t\t.data = &iqs7211_devs[IQS7210A],\n\t},\n\t{\n\t\t.compatible = \"azoteq,iqs7211a\",\n\t\t.data = &iqs7211_devs[IQS7211A],\n\t},\n\t{\n\t\t.compatible = \"azoteq,iqs7211e\",\n\t\t.data = &iqs7211_devs[IQS7211E],\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, iqs7211_of_match);\n\nstatic int iqs7211_probe(struct i2c_client *client)\n{\n\tstruct iqs7211_private *iqs7211;\n\tenum iqs7211_reg_grp_id reg_grp;\n\tunsigned long irq_flags;\n\tbool shared_irq;\n\tint error, irq;\n\n\tiqs7211 = devm_kzalloc(&client->dev, sizeof(*iqs7211), GFP_KERNEL);\n\tif (!iqs7211)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, iqs7211);\n\tiqs7211->client = client;\n\n\tINIT_LIST_HEAD(&iqs7211->reg_field_head);\n\n\tiqs7211->dev_desc = device_get_match_data(&client->dev);\n\tif (!iqs7211->dev_desc)\n\t\treturn -ENODEV;\n\n\tshared_irq = iqs7211->dev_desc->num_ctx == IQS7211_MAX_CTX;\n\n\t \n\tiqs7211->irq_gpio = devm_gpiod_get(&client->dev, \"irq\",\n\t\t\t\t\t   shared_irq ? GPIOD_OUT_LOW\n\t\t\t\t\t\t      : GPIOD_IN);\n\tif (IS_ERR(iqs7211->irq_gpio)) {\n\t\terror = PTR_ERR(iqs7211->irq_gpio);\n\t\tdev_err(&client->dev, \"Failed to request IRQ GPIO: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (shared_irq) {\n\t\tiqs7211->reset_gpio = iqs7211->irq_gpio;\n\t} else {\n\t\tiqs7211->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t\t      \"reset\",\n\t\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(iqs7211->reset_gpio)) {\n\t\t\terror = PTR_ERR(iqs7211->reset_gpio);\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to request reset GPIO: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = iqs7211_start_comms(iqs7211);\n\tif (error)\n\t\treturn error;\n\n\tfor (reg_grp = 0; reg_grp < IQS7211_NUM_REG_GRPS; reg_grp++) {\n\t\tconst char *reg_grp_name = iqs7211_reg_grp_names[reg_grp];\n\t\tstruct fwnode_handle *reg_grp_node;\n\n\t\tif (reg_grp_name)\n\t\t\treg_grp_node = device_get_named_child_node(&client->dev,\n\t\t\t\t\t\t\t\t   reg_grp_name);\n\t\telse\n\t\t\treg_grp_node = fwnode_handle_get(dev_fwnode(&client->dev));\n\n\t\tif (!reg_grp_node)\n\t\t\tcontinue;\n\n\t\terror = iqs7211_parse_reg_grp(iqs7211, reg_grp_node, reg_grp);\n\t\tfwnode_handle_put(reg_grp_node);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = iqs7211_register_kp(iqs7211);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7211_register_tp(iqs7211);\n\tif (error)\n\t\treturn error;\n\n\terror = iqs7211_init_device(iqs7211);\n\tif (error)\n\t\treturn error;\n\n\tirq = gpiod_to_irq(iqs7211->irq_gpio);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_flags = gpiod_is_active_low(iqs7211->irq_gpio) ? IRQF_TRIGGER_LOW\n\t\t\t\t\t\t\t   : IRQF_TRIGGER_HIGH;\n\tirq_flags |= IRQF_ONESHOT;\n\n\terror = devm_request_threaded_irq(&client->dev, irq, NULL, iqs7211_irq,\n\t\t\t\t\t  irq_flags, client->name, iqs7211);\n\tif (error)\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\n\treturn error;\n}\n\nstatic struct i2c_driver iqs7211_i2c_driver = {\n\t.probe = iqs7211_probe,\n\t.driver = {\n\t\t.name = \"iqs7211\",\n\t\t.of_match_table = iqs7211_of_match,\n\t\t.dev_groups = iqs7211_groups,\n\t\t.pm = pm_sleep_ptr(&iqs7211_pm),\n\t},\n};\nmodule_i2c_driver(iqs7211_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff LaBundy <jeff@labundy.com>\");\nMODULE_DESCRIPTION(\"Azoteq IQS7210A/7211A/E Trackpad/Touchscreen Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}