{
  "module_name": "mms114.c",
  "hash_id": "0676ac2b6bb02449890a8165c7ebc5949ecac08aae8c6ac59ede9d41a2d41ab9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mms114.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/i2c.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n \n#define MMS114_MODE_CONTROL\t\t0x01\n#define MMS114_OPERATION_MODE_MASK\t0xE\n#define MMS114_ACTIVE\t\t\tBIT(1)\n\n#define MMS114_XY_RESOLUTION_H\t\t0x02\n#define MMS114_X_RESOLUTION\t\t0x03\n#define MMS114_Y_RESOLUTION\t\t0x04\n#define MMS114_CONTACT_THRESHOLD\t0x05\n#define MMS114_MOVING_THRESHOLD\t\t0x06\n\n \n#define MMS114_PACKET_SIZE\t\t0x0F\n#define MMS114_INFORMATION\t\t0x10\n#define MMS114_TSP_REV\t\t\t0xF0\n\n#define MMS152_FW_REV\t\t\t0xE1\n#define MMS152_COMPAT_GROUP\t\t0xF2\n\n \n#define MMS114_I2C_DELAY\t\t50\n\n \n#define MMS114_POWERON_DELAY\t\t200\n\n \n#define MMS114_MAX_AREA\t\t\t0xff\n\n#define MMS114_MAX_TOUCHKEYS\t\t15\n#define MMS114_MAX_TOUCH\t\t10\n#define MMS114_EVENT_SIZE\t\t8\n#define MMS136_EVENT_SIZE\t\t6\n\n \n#define MMS114_TYPE_NONE\t\t0\n#define MMS114_TYPE_TOUCHSCREEN\t\t1\n#define MMS114_TYPE_TOUCHKEY\t\t2\n\nenum mms_type {\n\tTYPE_MMS114\t= 114,\n\tTYPE_MMS134S\t= 134,\n\tTYPE_MMS136\t= 136,\n\tTYPE_MMS152\t= 152,\n\tTYPE_MMS345L\t= 345,\n};\n\nstruct mms114_data {\n\tstruct i2c_client\t*client;\n\tstruct input_dev\t*input_dev;\n\tstruct regulator\t*core_reg;\n\tstruct regulator\t*io_reg;\n\tstruct touchscreen_properties props;\n\tenum mms_type\t\ttype;\n\tunsigned int\t\tcontact_threshold;\n\tunsigned int\t\tmoving_threshold;\n\n\tu32 keycodes[MMS114_MAX_TOUCHKEYS];\n\tint num_keycodes;\n\n\t \n\tu8\t\t\tcache_mode_control;\n};\n\nstruct mms114_touch {\n\tu8 id:4, reserved_bit4:1, type:2, pressed:1;\n\tu8 x_hi:4, y_hi:4;\n\tu8 x_lo;\n\tu8 y_lo;\n\tu8 width;\n\tu8 strength;\n\tu8 reserved[2];\n} __packed;\n\nstatic int __mms114_read_reg(struct mms114_data *data, unsigned int reg,\n\t\t\t     unsigned int len, u8 *val)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct i2c_msg xfer[2];\n\tu8 buf = reg & 0xff;\n\tint error;\n\n\tif (reg <= MMS114_MODE_CONTROL && reg + len > MMS114_MODE_CONTROL)\n\t\tBUG();\n\n\t \n\txfer[0].addr = client->addr;\n\txfer[0].flags = client->flags & I2C_M_TEN;\n\txfer[0].len = 1;\n\txfer[0].buf = &buf;\n\n\t \n\txfer[1].addr = client->addr;\n\txfer[1].flags = (client->flags & I2C_M_TEN) | I2C_M_RD;\n\txfer[1].len = len;\n\txfer[1].buf = val;\n\n\terror = i2c_transfer(client->adapter, xfer, 2);\n\tif (error != 2) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: i2c transfer failed (%d)\\n\", __func__, error);\n\t\treturn error < 0 ? error : -EIO;\n\t}\n\tudelay(MMS114_I2C_DELAY);\n\n\treturn 0;\n}\n\nstatic int mms114_read_reg(struct mms114_data *data, unsigned int reg)\n{\n\tu8 val;\n\tint error;\n\n\tif (reg == MMS114_MODE_CONTROL)\n\t\treturn data->cache_mode_control;\n\n\terror = __mms114_read_reg(data, reg, 1, &val);\n\treturn error < 0 ? error : val;\n}\n\nstatic int mms114_write_reg(struct mms114_data *data, unsigned int reg,\n\t\t\t    unsigned int val)\n{\n\tstruct i2c_client *client = data->client;\n\tu8 buf[2];\n\tint error;\n\n\tbuf[0] = reg & 0xff;\n\tbuf[1] = val & 0xff;\n\n\terror = i2c_master_send(client, buf, 2);\n\tif (error != 2) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: i2c send failed (%d)\\n\", __func__, error);\n\t\treturn error < 0 ? error : -EIO;\n\t}\n\tudelay(MMS114_I2C_DELAY);\n\n\tif (reg == MMS114_MODE_CONTROL)\n\t\tdata->cache_mode_control = val;\n\n\treturn 0;\n}\n\nstatic void mms114_process_mt(struct mms114_data *data, struct mms114_touch *touch)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct input_dev *input_dev = data->input_dev;\n\tunsigned int id;\n\tunsigned int x;\n\tunsigned int y;\n\n\tif (touch->id > MMS114_MAX_TOUCH) {\n\t\tdev_err(&client->dev, \"Wrong touch id (%d)\\n\", touch->id);\n\t\treturn;\n\t}\n\n\tid = touch->id - 1;\n\tx = touch->x_lo | touch->x_hi << 8;\n\ty = touch->y_lo | touch->y_hi << 8;\n\n\tdev_dbg(&client->dev,\n\t\t\"id: %d, type: %d, pressed: %d, x: %d, y: %d, width: %d, strength: %d\\n\",\n\t\tid, touch->type, touch->pressed,\n\t\tx, y, touch->width, touch->strength);\n\n\tinput_mt_slot(input_dev, id);\n\tinput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, touch->pressed);\n\n\tif (touch->pressed) {\n\t\ttouchscreen_report_pos(input_dev, &data->props, x, y, true);\n\t\tinput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, touch->width);\n\t\tinput_report_abs(input_dev, ABS_MT_PRESSURE, touch->strength);\n\t}\n}\n\nstatic void mms114_process_touchkey(struct mms114_data *data,\n\t\t\t\t    struct mms114_touch *touch)\n{\n\tstruct i2c_client *client = data->client;\n\tstruct input_dev *input_dev = data->input_dev;\n\tunsigned int keycode_id;\n\n\tif (touch->id == 0)\n\t\treturn;\n\n\tif (touch->id > data->num_keycodes) {\n\t\tdev_err(&client->dev, \"Wrong touch id for touchkey (%d)\\n\",\n\t\t\ttouch->id);\n\t\treturn;\n\t}\n\n\tkeycode_id = touch->id - 1;\n\tdev_dbg(&client->dev, \"keycode id: %d, pressed: %d\\n\", keycode_id,\n\t\ttouch->pressed);\n\n\tinput_report_key(input_dev, data->keycodes[keycode_id], touch->pressed);\n}\n\nstatic irqreturn_t mms114_interrupt(int irq, void *dev_id)\n{\n\tstruct mms114_data *data = dev_id;\n\tstruct i2c_client *client = data->client;\n\tstruct input_dev *input_dev = data->input_dev;\n\tstruct mms114_touch touch[MMS114_MAX_TOUCH];\n\tint packet_size;\n\tint touch_size;\n\tint index;\n\tint error;\n\n\tmutex_lock(&input_dev->mutex);\n\tif (!input_device_enabled(input_dev)) {\n\t\tmutex_unlock(&input_dev->mutex);\n\t\tgoto out;\n\t}\n\tmutex_unlock(&input_dev->mutex);\n\n\tpacket_size = mms114_read_reg(data, MMS114_PACKET_SIZE);\n\tif (packet_size <= 0)\n\t\tgoto out;\n\n\t \n\tif (data->type == TYPE_MMS134S || data->type == TYPE_MMS136)\n\t\ttouch_size = packet_size / MMS136_EVENT_SIZE;\n\telse\n\t\ttouch_size = packet_size / MMS114_EVENT_SIZE;\n\n\terror = __mms114_read_reg(data, MMS114_INFORMATION, packet_size,\n\t\t\t(u8 *)touch);\n\tif (error < 0)\n\t\tgoto out;\n\n\tfor (index = 0; index < touch_size; index++) {\n\t\tswitch (touch[index].type) {\n\t\tcase MMS114_TYPE_TOUCHSCREEN:\n\t\t\tmms114_process_mt(data, touch + index);\n\t\t\tbreak;\n\n\t\tcase MMS114_TYPE_TOUCHKEY:\n\t\t\tmms114_process_touchkey(data, touch + index);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&client->dev, \"Wrong touch type (%d)\\n\",\n\t\t\t\ttouch[index].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinput_mt_report_pointer_emulation(data->input_dev, true);\n\tinput_sync(data->input_dev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int mms114_set_active(struct mms114_data *data, bool active)\n{\n\tint val;\n\n\tval = mms114_read_reg(data, MMS114_MODE_CONTROL);\n\tif (val < 0)\n\t\treturn val;\n\n\tval &= ~MMS114_OPERATION_MODE_MASK;\n\n\t \n\tif (active)\n\t\tval |= MMS114_ACTIVE;\n\n\treturn mms114_write_reg(data, MMS114_MODE_CONTROL, val);\n}\n\nstatic int mms114_get_version(struct mms114_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tu8 buf[6];\n\tint group;\n\tint error;\n\n\tswitch (data->type) {\n\tcase TYPE_MMS345L:\n\t\terror = __mms114_read_reg(data, MMS152_FW_REV, 3, buf);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdev_info(dev, \"TSP FW Rev: bootloader 0x%x / core 0x%x / config 0x%x\\n\",\n\t\t\t buf[0], buf[1], buf[2]);\n\t\tbreak;\n\n\tcase TYPE_MMS152:\n\t\terror = __mms114_read_reg(data, MMS152_FW_REV, 3, buf);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tgroup = i2c_smbus_read_byte_data(data->client,\n\t\t\t\t\t\t  MMS152_COMPAT_GROUP);\n\t\tif (group < 0)\n\t\t\treturn group;\n\n\t\tdev_info(dev, \"TSP FW Rev: bootloader 0x%x / core 0x%x / config 0x%x, Compat group: %c\\n\",\n\t\t\t buf[0], buf[1], buf[2], group);\n\t\tbreak;\n\n\tcase TYPE_MMS114:\n\tcase TYPE_MMS134S:\n\tcase TYPE_MMS136:\n\t\terror = __mms114_read_reg(data, MMS114_TSP_REV, 6, buf);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tdev_info(dev, \"TSP Rev: 0x%x, HW Rev: 0x%x, Firmware Ver: 0x%x\\n\",\n\t\t\t buf[0], buf[1], buf[3]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mms114_setup_regs(struct mms114_data *data)\n{\n\tconst struct touchscreen_properties *props = &data->props;\n\tint val;\n\tint error;\n\n\terror = mms114_get_version(data);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tif (data->type != TYPE_MMS114 && data->type != TYPE_MMS134S &&\n\t    data->type != TYPE_MMS136)\n\t\treturn 0;\n\n\terror = mms114_set_active(data, true);\n\tif (error < 0)\n\t\treturn error;\n\n\tval = (props->max_x >> 8) & 0xf;\n\tval |= ((props->max_y >> 8) & 0xf) << 4;\n\terror = mms114_write_reg(data, MMS114_XY_RESOLUTION_H, val);\n\tif (error < 0)\n\t\treturn error;\n\n\tval = props->max_x & 0xff;\n\terror = mms114_write_reg(data, MMS114_X_RESOLUTION, val);\n\tif (error < 0)\n\t\treturn error;\n\n\tval = props->max_x & 0xff;\n\terror = mms114_write_reg(data, MMS114_Y_RESOLUTION, val);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (data->contact_threshold) {\n\t\terror = mms114_write_reg(data, MMS114_CONTACT_THRESHOLD,\n\t\t\t\tdata->contact_threshold);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (data->moving_threshold) {\n\t\terror = mms114_write_reg(data, MMS114_MOVING_THRESHOLD,\n\t\t\t\tdata->moving_threshold);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int mms114_start(struct mms114_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint error;\n\n\terror = regulator_enable(data->core_reg);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to enable avdd: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(data->io_reg);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to enable vdd: %d\\n\", error);\n\t\tregulator_disable(data->core_reg);\n\t\treturn error;\n\t}\n\n\tmsleep(MMS114_POWERON_DELAY);\n\n\terror = mms114_setup_regs(data);\n\tif (error < 0) {\n\t\tregulator_disable(data->io_reg);\n\t\tregulator_disable(data->core_reg);\n\t\treturn error;\n\t}\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic void mms114_stop(struct mms114_data *data)\n{\n\tstruct i2c_client *client = data->client;\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\terror = regulator_disable(data->io_reg);\n\tif (error)\n\t\tdev_warn(&client->dev, \"Failed to disable vdd: %d\\n\", error);\n\n\terror = regulator_disable(data->core_reg);\n\tif (error)\n\t\tdev_warn(&client->dev, \"Failed to disable avdd: %d\\n\", error);\n}\n\nstatic int mms114_input_open(struct input_dev *dev)\n{\n\tstruct mms114_data *data = input_get_drvdata(dev);\n\n\treturn mms114_start(data);\n}\n\nstatic void mms114_input_close(struct input_dev *dev)\n{\n\tstruct mms114_data *data = input_get_drvdata(dev);\n\n\tmms114_stop(data);\n}\n\nstatic int mms114_parse_legacy_bindings(struct mms114_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tstruct touchscreen_properties *props = &data->props;\n\n\tif (device_property_read_u32(dev, \"x-size\", &props->max_x)) {\n\t\tdev_dbg(dev, \"failed to get legacy x-size property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_u32(dev, \"y-size\", &props->max_y)) {\n\t\tdev_dbg(dev, \"failed to get legacy y-size property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_property_read_u32(dev, \"contact-threshold\",\n\t\t\t\t&data->contact_threshold);\n\tdevice_property_read_u32(dev, \"moving-threshold\",\n\t\t\t\t&data->moving_threshold);\n\n\tif (device_property_read_bool(dev, \"x-invert\"))\n\t\tprops->invert_x = true;\n\tif (device_property_read_bool(dev, \"y-invert\"))\n\t\tprops->invert_y = true;\n\n\tprops->swap_x_y = false;\n\n\treturn 0;\n}\n\nstatic int mms114_probe(struct i2c_client *client)\n{\n\tstruct mms114_data *data;\n\tstruct input_dev *input_dev;\n\tconst void *match_data;\n\tint error;\n\tint i;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"Not supported I2C adapter\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(&client->dev, sizeof(struct mms114_data),\n\t\t\t    GFP_KERNEL);\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!data || !input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->client = client;\n\tdata->input_dev = input_dev;\n\n\tmatch_data = device_get_match_data(&client->dev);\n\tif (!match_data)\n\t\treturn -EINVAL;\n\n\tdata->type = (enum mms_type)match_data;\n\n\tdata->num_keycodes = device_property_count_u32(&client->dev,\n\t\t\t\t\t\t       \"linux,keycodes\");\n\tif (data->num_keycodes == -EINVAL) {\n\t\tdata->num_keycodes = 0;\n\t} else if (data->num_keycodes < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to parse linux,keycodes property: %d\\n\",\n\t\t\tdata->num_keycodes);\n\t\treturn data->num_keycodes;\n\t} else if (data->num_keycodes > MMS114_MAX_TOUCHKEYS) {\n\t\tdev_warn(&client->dev,\n\t\t\t\"Found %d linux,keycodes but max is %d, ignoring the rest\\n\",\n\t\t\t data->num_keycodes, MMS114_MAX_TOUCHKEYS);\n\t\tdata->num_keycodes = MMS114_MAX_TOUCHKEYS;\n\t}\n\n\tif (data->num_keycodes > 0) {\n\t\terror = device_property_read_u32_array(&client->dev,\n\t\t\t\t\t\t       \"linux,keycodes\",\n\t\t\t\t\t\t       data->keycodes,\n\t\t\t\t\t\t       data->num_keycodes);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Unable to read linux,keycodes values: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tinput_dev->keycode = data->keycodes;\n\t\tinput_dev->keycodemax = data->num_keycodes;\n\t\tinput_dev->keycodesize = sizeof(data->keycodes[0]);\n\t\tfor (i = 0; i < data->num_keycodes; i++)\n\t\t\tinput_set_capability(input_dev,\n\t\t\t\t\t     EV_KEY, data->keycodes[i]);\n\t}\n\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, MMS114_MAX_AREA, 0, 0);\n\n\ttouchscreen_parse_properties(input_dev, true, &data->props);\n\tif (!data->props.max_x || !data->props.max_y) {\n\t\tdev_dbg(&client->dev,\n\t\t\t\"missing X/Y size properties, trying legacy bindings\\n\");\n\t\terror = mms114_parse_legacy_bindings(data);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t\t     0, data->props.max_x, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t\t     0, data->props.max_y, 0, 0);\n\t}\n\n\tif (data->type == TYPE_MMS114 || data->type == TYPE_MMS134S ||\n\t    data->type == TYPE_MMS136) {\n\t\t \n\t\tdata->moving_threshold = input_abs_get_fuzz(input_dev,\n\t\t\t\t\t\t\t    ABS_MT_POSITION_X);\n\t\tdata->contact_threshold = input_abs_get_fuzz(input_dev,\n\t\t\t\t\t\t\t     ABS_MT_PRESSURE);\n\t\tinput_abs_set_fuzz(input_dev, ABS_MT_POSITION_X, 0);\n\t\tinput_abs_set_fuzz(input_dev, ABS_MT_POSITION_Y, 0);\n\t\tinput_abs_set_fuzz(input_dev, ABS_MT_PRESSURE, 0);\n\t}\n\n\tinput_dev->name = devm_kasprintf(&client->dev, GFP_KERNEL,\n\t\t\t\t\t \"MELFAS MMS%d Touchscreen\",\n\t\t\t\t\t data->type);\n\tif (!input_dev->name)\n\t\treturn -ENOMEM;\n\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->dev.parent = &client->dev;\n\tinput_dev->open = mms114_input_open;\n\tinput_dev->close = mms114_input_close;\n\n\terror = input_mt_init_slots(input_dev, MMS114_MAX_TOUCH,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error)\n\t\treturn error;\n\n\tinput_set_drvdata(input_dev, data);\n\ti2c_set_clientdata(client, data);\n\n\tdata->core_reg = devm_regulator_get(&client->dev, \"avdd\");\n\tif (IS_ERR(data->core_reg)) {\n\t\terror = PTR_ERR(data->core_reg);\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to get the Core regulator (%d)\\n\", error);\n\t\treturn error;\n\t}\n\n\tdata->io_reg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(data->io_reg)) {\n\t\terror = PTR_ERR(data->io_reg);\n\t\tdev_err(&client->dev,\n\t\t\t\"Unable to get the IO regulator (%d)\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, mms114_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  dev_name(&client->dev), data);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(data->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int mms114_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mms114_data *data = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = data->input_dev;\n\tint id;\n\n\t \n\tfor (id = 0; id < MMS114_MAX_TOUCH; id++) {\n\t\tinput_mt_slot(input_dev, id);\n\t\tinput_mt_report_slot_inactive(input_dev);\n\t}\n\n\tinput_mt_report_pointer_emulation(input_dev, true);\n\tinput_sync(input_dev);\n\n\tmutex_lock(&input_dev->mutex);\n\tif (input_device_enabled(input_dev))\n\t\tmms114_stop(data);\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic int mms114_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mms114_data *data = i2c_get_clientdata(client);\n\tstruct input_dev *input_dev = data->input_dev;\n\tint error;\n\n\tmutex_lock(&input_dev->mutex);\n\tif (input_device_enabled(input_dev)) {\n\t\terror = mms114_start(data);\n\t\tif (error < 0) {\n\t\t\tmutex_unlock(&input_dev->mutex);\n\t\t\treturn error;\n\t\t}\n\t}\n\tmutex_unlock(&input_dev->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mms114_pm_ops, mms114_suspend, mms114_resume);\n\nstatic const struct i2c_device_id mms114_id[] = {\n\t{ \"mms114\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mms114_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mms114_dt_match[] = {\n\t{\n\t\t.compatible = \"melfas,mms114\",\n\t\t.data = (void *)TYPE_MMS114,\n\t}, {\n\t\t.compatible = \"melfas,mms134s\",\n\t\t.data = (void *)TYPE_MMS134S,\n\t}, {\n\t\t.compatible = \"melfas,mms136\",\n\t\t.data = (void *)TYPE_MMS136,\n\t}, {\n\t\t.compatible = \"melfas,mms152\",\n\t\t.data = (void *)TYPE_MMS152,\n\t}, {\n\t\t.compatible = \"melfas,mms345l\",\n\t\t.data = (void *)TYPE_MMS345L,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mms114_dt_match);\n#endif\n\nstatic struct i2c_driver mms114_driver = {\n\t.driver = {\n\t\t.name\t= \"mms114\",\n\t\t.pm\t= pm_sleep_ptr(&mms114_pm_ops),\n\t\t.of_match_table = of_match_ptr(mms114_dt_match),\n\t},\n\t.probe\t\t= mms114_probe,\n\t.id_table\t= mms114_id,\n};\n\nmodule_i2c_driver(mms114_driver);\n\n \nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_DESCRIPTION(\"MELFAS mms114 Touchscreen driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}