{
  "module_name": "tsc200x-core.c",
  "hash_id": "7139beb359839c90ebde5aff9c7a7b329a48753e8a2d6afd5f157ea34603b342",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/tsc200x-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <linux/gpio/consumer.h>\n#include \"tsc200x-core.h\"\n\n \n\nstatic const struct regmap_range tsc200x_writable_ranges[] = {\n\tregmap_reg_range(TSC200X_REG_AUX_HIGH, TSC200X_REG_CFR2),\n};\n\nstatic const struct regmap_access_table tsc200x_writable_table = {\n\t.yes_ranges = tsc200x_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(tsc200x_writable_ranges),\n};\n\nconst struct regmap_config tsc200x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.reg_stride = 0x08,\n\t.max_register = 0x78,\n\t.read_flag_mask = TSC200X_REG_READ,\n\t.write_flag_mask = TSC200X_REG_PND0,\n\t.wr_table = &tsc200x_writable_table,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\nEXPORT_SYMBOL_GPL(tsc200x_regmap_config);\n\nstruct tsc200x_data {\n\tu16 x;\n\tu16 y;\n\tu16 z1;\n\tu16 z2;\n} __packed;\n#define TSC200X_DATA_REGS 4\n\nstruct tsc200x {\n\tstruct device           *dev;\n\tstruct regmap\t\t*regmap;\n\t__u16                   bustype;\n\n\tstruct input_dev\t*idev;\n\tchar\t\t\tphys[32];\n\n\tstruct mutex\t\tmutex;\n\n\t \n\tint\t\t\tin_x;\n\tint\t\t\tin_y;\n\tint                     in_z1;\n\tint\t\t\tin_z2;\n\n\tstruct touchscreen_properties prop;\n\n\tspinlock_t\t\tlock;\n\tstruct timer_list\tpenup_timer;\n\n\tunsigned int\t\tesd_timeout;\n\tstruct delayed_work\tesd_work;\n\tunsigned long\t\tlast_valid_interrupt;\n\n\tunsigned int\t\tx_plate_ohm;\n\n\tbool\t\t\topened;\n\tbool\t\t\tsuspended;\n\n\tbool\t\t\tpen_down;\n\n\tstruct regulator\t*vio;\n\n\tstruct gpio_desc\t*reset_gpio;\n\tint\t\t\t(*tsc200x_cmd)(struct device *dev, u8 cmd);\n\tint\t\t\tirq;\n};\n\nstatic void tsc200x_update_pen_state(struct tsc200x *ts,\n\t\t\t\t     int x, int y, int pressure)\n{\n\tif (pressure) {\n\t\ttouchscreen_report_pos(ts->idev, &ts->prop, x, y, false);\n\t\tinput_report_abs(ts->idev, ABS_PRESSURE, pressure);\n\t\tif (!ts->pen_down) {\n\t\t\tinput_report_key(ts->idev, BTN_TOUCH, !!pressure);\n\t\t\tts->pen_down = true;\n\t\t}\n\t} else {\n\t\tinput_report_abs(ts->idev, ABS_PRESSURE, 0);\n\t\tif (ts->pen_down) {\n\t\t\tinput_report_key(ts->idev, BTN_TOUCH, 0);\n\t\t\tts->pen_down = false;\n\t\t}\n\t}\n\tinput_sync(ts->idev);\n\tdev_dbg(ts->dev, \"point(%4d,%4d), pressure (%4d)\\n\", x, y,\n\t\tpressure);\n}\n\nstatic irqreturn_t tsc200x_irq_thread(int irq, void *_ts)\n{\n\tstruct tsc200x *ts = _ts;\n\tunsigned long flags;\n\tunsigned int pressure;\n\tstruct tsc200x_data tsdata;\n\tint error;\n\n\t \n\terror = regmap_bulk_read(ts->regmap, TSC200X_REG_X, &tsdata,\n\t\t\t\t TSC200X_DATA_REGS);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\t \n\tif (unlikely(tsdata.x > MAX_12BIT || tsdata.y > MAX_12BIT))\n\t\tgoto out;\n\n\t \n\tif (unlikely(tsdata.z1 == 0 || tsdata.z2 > MAX_12BIT))\n\t\tgoto out;\n\tif (unlikely(tsdata.z1 >= tsdata.z2))\n\t\tgoto out;\n\n        \n\tif (!ts->pen_down &&\n\t    ts->in_x == tsdata.x && ts->in_y == tsdata.y &&\n\t    ts->in_z1 == tsdata.z1 && ts->in_z2 == tsdata.z2) {\n\t\tgoto out;\n\t}\n\n\t \n\tts->in_x = tsdata.x;\n\tts->in_y = tsdata.y;\n\tts->in_z1 = tsdata.z1;\n\tts->in_z2 = tsdata.z2;\n\n\t \n\tpressure = tsdata.x * (tsdata.z2 - tsdata.z1) / tsdata.z1;\n\tpressure = pressure * ts->x_plate_ohm / 4096;\n\tif (unlikely(pressure > MAX_12BIT))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&ts->lock, flags);\n\n\ttsc200x_update_pen_state(ts, tsdata.x, tsdata.y, pressure);\n\tmod_timer(&ts->penup_timer,\n\t\t  jiffies + msecs_to_jiffies(TSC200X_PENUP_TIME_MS));\n\n\tspin_unlock_irqrestore(&ts->lock, flags);\n\n\tts->last_valid_interrupt = jiffies;\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void tsc200x_penup_timer(struct timer_list *t)\n{\n\tstruct tsc200x *ts = from_timer(ts, t, penup_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ts->lock, flags);\n\ttsc200x_update_pen_state(ts, 0, 0, 0);\n\tspin_unlock_irqrestore(&ts->lock, flags);\n}\n\nstatic void tsc200x_start_scan(struct tsc200x *ts)\n{\n\tregmap_write(ts->regmap, TSC200X_REG_CFR0, TSC200X_CFR0_INITVALUE);\n\tregmap_write(ts->regmap, TSC200X_REG_CFR1, TSC200X_CFR1_INITVALUE);\n\tregmap_write(ts->regmap, TSC200X_REG_CFR2, TSC200X_CFR2_INITVALUE);\n\tts->tsc200x_cmd(ts->dev, TSC200X_CMD_NORMAL);\n}\n\nstatic void tsc200x_stop_scan(struct tsc200x *ts)\n{\n\tts->tsc200x_cmd(ts->dev, TSC200X_CMD_STOP);\n}\n\nstatic void tsc200x_reset(struct tsc200x *ts)\n{\n\tif (ts->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 1);\n\t\tusleep_range(100, 500);  \n\t\tgpiod_set_value_cansleep(ts->reset_gpio, 0);\n\t}\n}\n\n \nstatic void __tsc200x_disable(struct tsc200x *ts)\n{\n\ttsc200x_stop_scan(ts);\n\n\tdisable_irq(ts->irq);\n\tdel_timer_sync(&ts->penup_timer);\n\n\tcancel_delayed_work_sync(&ts->esd_work);\n\n\tenable_irq(ts->irq);\n}\n\n \nstatic void __tsc200x_enable(struct tsc200x *ts)\n{\n\ttsc200x_start_scan(ts);\n\n\tif (ts->esd_timeout && ts->reset_gpio) {\n\t\tts->last_valid_interrupt = jiffies;\n\t\tschedule_delayed_work(&ts->esd_work,\n\t\t\t\tround_jiffies_relative(\n\t\t\t\t\tmsecs_to_jiffies(ts->esd_timeout)));\n\t}\n}\n\nstatic ssize_t tsc200x_selftest_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct tsc200x *ts = dev_get_drvdata(dev);\n\tunsigned int temp_high;\n\tunsigned int temp_high_orig;\n\tunsigned int temp_high_test;\n\tbool success = true;\n\tint error;\n\n\tmutex_lock(&ts->mutex);\n\n\t \n\t__tsc200x_disable(ts);\n\n\terror = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high_orig);\n\tif (error) {\n\t\tdev_warn(dev, \"selftest failed: read error %d\\n\", error);\n\t\tsuccess = false;\n\t\tgoto out;\n\t}\n\n\ttemp_high_test = (temp_high_orig - 1) & MAX_12BIT;\n\n\terror = regmap_write(ts->regmap, TSC200X_REG_TEMP_HIGH, temp_high_test);\n\tif (error) {\n\t\tdev_warn(dev, \"selftest failed: write error %d\\n\", error);\n\t\tsuccess = false;\n\t\tgoto out;\n\t}\n\n\terror = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high);\n\tif (error) {\n\t\tdev_warn(dev, \"selftest failed: read error %d after write\\n\",\n\t\t\t error);\n\t\tsuccess = false;\n\t\tgoto out;\n\t}\n\n\tif (temp_high != temp_high_test) {\n\t\tdev_warn(dev, \"selftest failed: %d != %d\\n\",\n\t\t\t temp_high, temp_high_test);\n\t\tsuccess = false;\n\t}\n\n\t \n\ttsc200x_reset(ts);\n\n\tif (!success)\n\t\tgoto out;\n\n\t \n\terror = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high);\n\tif (error) {\n\t\tdev_warn(dev, \"selftest failed: read error %d after reset\\n\",\n\t\t\t error);\n\t\tsuccess = false;\n\t\tgoto out;\n\t}\n\n\tif (temp_high != temp_high_orig) {\n\t\tdev_warn(dev, \"selftest failed after reset: %d != %d\\n\",\n\t\t\t temp_high, temp_high_orig);\n\t\tsuccess = false;\n\t}\n\nout:\n\t__tsc200x_enable(ts);\n\tmutex_unlock(&ts->mutex);\n\n\treturn sprintf(buf, \"%d\\n\", success);\n}\n\nstatic DEVICE_ATTR(selftest, S_IRUGO, tsc200x_selftest_show, NULL);\n\nstatic struct attribute *tsc200x_attrs[] = {\n\t&dev_attr_selftest.attr,\n\tNULL\n};\n\nstatic umode_t tsc200x_attr_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct tsc200x *ts = dev_get_drvdata(dev);\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_selftest.attr) {\n\t\tif (!ts->reset_gpio)\n\t\t\tmode = 0;\n\t}\n\n\treturn mode;\n}\n\nstatic const struct attribute_group tsc200x_attr_group = {\n\t.is_visible\t= tsc200x_attr_is_visible,\n\t.attrs\t\t= tsc200x_attrs,\n};\n\nstatic void tsc200x_esd_work(struct work_struct *work)\n{\n\tstruct tsc200x *ts = container_of(work, struct tsc200x, esd_work.work);\n\tint error;\n\tunsigned int r;\n\n\tif (!mutex_trylock(&ts->mutex)) {\n\t\t \n\t\tgoto reschedule;\n\t}\n\n\tif (time_is_after_jiffies(ts->last_valid_interrupt +\n\t\t\t\t  msecs_to_jiffies(ts->esd_timeout)))\n\t\tgoto out;\n\n\t \n\terror = regmap_read(ts->regmap, TSC200X_REG_CFR0, &r);\n\tif (!error &&\n\t    !((r ^ TSC200X_CFR0_INITVALUE) & TSC200X_CFR0_RW_MASK)) {\n\t\tgoto out;\n\t}\n\n\t \n\tdev_info(ts->dev, \"TSC200X not responding - resetting\\n\");\n\n\tdisable_irq(ts->irq);\n\tdel_timer_sync(&ts->penup_timer);\n\n\ttsc200x_update_pen_state(ts, 0, 0, 0);\n\n\ttsc200x_reset(ts);\n\n\tenable_irq(ts->irq);\n\ttsc200x_start_scan(ts);\n\nout:\n\tmutex_unlock(&ts->mutex);\nreschedule:\n\t \n\tschedule_delayed_work(&ts->esd_work,\n\t\t\t      round_jiffies_relative(\n\t\t\t\t\tmsecs_to_jiffies(ts->esd_timeout)));\n}\n\nstatic int tsc200x_open(struct input_dev *input)\n{\n\tstruct tsc200x *ts = input_get_drvdata(input);\n\n\tmutex_lock(&ts->mutex);\n\n\tif (!ts->suspended)\n\t\t__tsc200x_enable(ts);\n\n\tts->opened = true;\n\n\tmutex_unlock(&ts->mutex);\n\n\treturn 0;\n}\n\nstatic void tsc200x_close(struct input_dev *input)\n{\n\tstruct tsc200x *ts = input_get_drvdata(input);\n\n\tmutex_lock(&ts->mutex);\n\n\tif (!ts->suspended)\n\t\t__tsc200x_disable(ts);\n\n\tts->opened = false;\n\n\tmutex_unlock(&ts->mutex);\n}\n\nint tsc200x_probe(struct device *dev, int irq, const struct input_id *tsc_id,\n\t\t  struct regmap *regmap,\n\t\t  int (*tsc200x_cmd)(struct device *dev, u8 cmd))\n{\n\tstruct tsc200x *ts;\n\tstruct input_dev *input_dev;\n\tu32 x_plate_ohm;\n\tu32 esd_timeout;\n\tint error;\n\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"no irq\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tif (!tsc200x_cmd) {\n\t\tdev_err(dev, \"no cmd function\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tinput_dev = devm_input_allocate_device(dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tts->irq = irq;\n\tts->dev = dev;\n\tts->idev = input_dev;\n\tts->regmap = regmap;\n\tts->tsc200x_cmd = tsc200x_cmd;\n\n\terror = device_property_read_u32(dev, \"ti,x-plate-ohms\", &x_plate_ohm);\n\tts->x_plate_ohm = error ? TSC200X_DEF_RESISTOR : x_plate_ohm;\n\n\terror = device_property_read_u32(dev, \"ti,esd-recovery-timeout-ms\",\n\t\t\t\t\t &esd_timeout);\n\tts->esd_timeout = error ? 0 : esd_timeout;\n\n\tts->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(dev, \"error acquiring reset gpio: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->vio = devm_regulator_get(dev, \"vio\");\n\tif (IS_ERR(ts->vio)) {\n\t\terror = PTR_ERR(ts->vio);\n\t\tdev_err(dev, \"error acquiring vio regulator: %d\", error);\n\t\treturn error;\n\t}\n\n\tmutex_init(&ts->mutex);\n\n\tspin_lock_init(&ts->lock);\n\ttimer_setup(&ts->penup_timer, tsc200x_penup_timer, 0);\n\n\tINIT_DELAYED_WORK(&ts->esd_work, tsc200x_esd_work);\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t \"%s/input-ts\", dev_name(dev));\n\n\tif (tsc_id->product == 2004) {\n\t\tinput_dev->name = \"TSC200X touchscreen\";\n\t} else {\n\t\tinput_dev->name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t \"TSC%04d touchscreen\",\n\t\t\t\t\t\t tsc_id->product);\n\t\tif (!input_dev->name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->phys = ts->phys;\n\tinput_dev->id = *tsc_id;\n\n\tinput_dev->open = tsc200x_open;\n\tinput_dev->close = tsc200x_close;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\t__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\t\t     0, MAX_12BIT, TSC200X_DEF_X_FUZZ, 0);\n\tinput_set_abs_params(input_dev, ABS_Y,\n\t\t\t     0, MAX_12BIT, TSC200X_DEF_Y_FUZZ, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE,\n\t\t\t     0, MAX_12BIT, TSC200X_DEF_P_FUZZ, 0);\n\n\ttouchscreen_parse_properties(input_dev, false, &ts->prop);\n\n\t \n\ttsc200x_stop_scan(ts);\n\n\terror = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\t  tsc200x_irq_thread,\n\t\t\t\t\t  IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t  \"tsc200x\", ts);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request irq, err: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(ts->vio);\n\tif (error)\n\t\treturn error;\n\n\tdev_set_drvdata(dev, ts);\n\terror = sysfs_create_group(&dev->kobj, &tsc200x_attr_group);\n\tif (error) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to create sysfs attributes, err: %d\\n\", error);\n\t\tgoto disable_regulator;\n\t}\n\n\terror = input_register_device(ts->idev);\n\tif (error) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to register input device, err: %d\\n\", error);\n\t\tgoto err_remove_sysfs;\n\t}\n\n\tirq_set_irq_wake(irq, 1);\n\treturn 0;\n\nerr_remove_sysfs:\n\tsysfs_remove_group(&dev->kobj, &tsc200x_attr_group);\ndisable_regulator:\n\tregulator_disable(ts->vio);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(tsc200x_probe);\n\nvoid tsc200x_remove(struct device *dev)\n{\n\tstruct tsc200x *ts = dev_get_drvdata(dev);\n\n\tsysfs_remove_group(&dev->kobj, &tsc200x_attr_group);\n\n\tregulator_disable(ts->vio);\n}\nEXPORT_SYMBOL_GPL(tsc200x_remove);\n\nstatic int tsc200x_suspend(struct device *dev)\n{\n\tstruct tsc200x *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->mutex);\n\n\tif (!ts->suspended && ts->opened)\n\t\t__tsc200x_disable(ts);\n\n\tts->suspended = true;\n\n\tmutex_unlock(&ts->mutex);\n\n\treturn 0;\n}\n\nstatic int tsc200x_resume(struct device *dev)\n{\n\tstruct tsc200x *ts = dev_get_drvdata(dev);\n\n\tmutex_lock(&ts->mutex);\n\n\tif (ts->suspended && ts->opened)\n\t\t__tsc200x_enable(ts);\n\n\tts->suspended = false;\n\n\tmutex_unlock(&ts->mutex);\n\n\treturn 0;\n}\n\nEXPORT_GPL_SIMPLE_DEV_PM_OPS(tsc200x_pm_ops, tsc200x_suspend, tsc200x_resume);\n\nMODULE_AUTHOR(\"Lauri Leukkunen <lauri.leukkunen@nokia.com>\");\nMODULE_DESCRIPTION(\"TSC200x Touchscreen Driver Core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}