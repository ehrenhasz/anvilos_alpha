{
  "module_name": "himax_hx83112b.c",
  "hash_id": "8ea6fac4c3fb515e80af4d29329ed92113857691ae827e8f65b33704e07e56b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/himax_hx83112b.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/regmap.h>\n\n#define HIMAX_ID_83112B\t\t\t0x83112b\n\n#define HIMAX_MAX_POINTS\t\t10\n\n#define HIMAX_REG_CFG_SET_ADDR\t\t0x00\n#define HIMAX_REG_CFG_INIT_READ\t\t0x0c\n#define HIMAX_REG_CFG_READ_VALUE\t0x08\n#define HIMAX_REG_READ_EVENT\t\t0x30\n\n#define HIMAX_CFG_PRODUCT_ID\t\t0x900000d0\n\n#define HIMAX_INVALID_COORD\t\t0xffff\n\nstruct himax_event_point {\n\t__be16 x;\n\t__be16 y;\n} __packed;\n\nstruct himax_event {\n\tstruct himax_event_point points[HIMAX_MAX_POINTS];\n\tu8 majors[HIMAX_MAX_POINTS];\n\tu8 pad0[2];\n\tu8 num_points;\n\tu8 pad1[2];\n\tu8 checksum_fix;\n} __packed;\n\nstatic_assert(sizeof(struct himax_event) == 56);\n\nstruct himax_ts_data {\n\tstruct gpio_desc *gpiod_rst;\n\tstruct input_dev *input_dev;\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct touchscreen_properties props;\n};\n\nstatic const struct regmap_config himax_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic int himax_read_config(struct himax_ts_data *ts, u32 address, u32 *dst)\n{\n\tint error;\n\n\terror = regmap_write(ts->regmap, HIMAX_REG_CFG_SET_ADDR, address);\n\tif (error)\n\t\treturn error;\n\n\terror = regmap_write(ts->regmap, HIMAX_REG_CFG_INIT_READ, 0x0);\n\tif (error)\n\t\treturn error;\n\n\terror = regmap_read(ts->regmap, HIMAX_REG_CFG_READ_VALUE, dst);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic void himax_reset(struct himax_ts_data *ts)\n{\n\tgpiod_set_value_cansleep(ts->gpiod_rst, 1);\n\n\t \n\tmsleep(20);\n\tgpiod_set_value_cansleep(ts->gpiod_rst, 0);\n\n\t \n\tusleep_range(1000, 1100);\n}\n\nstatic int himax_read_product_id(struct himax_ts_data *ts, u32 *product_id)\n{\n\tint error;\n\n\terror = himax_read_config(ts, HIMAX_CFG_PRODUCT_ID, product_id);\n\tif (error)\n\t\treturn error;\n\n\t*product_id >>= 8;\n\treturn 0;\n}\n\nstatic int himax_check_product_id(struct himax_ts_data *ts)\n{\n\tint error;\n\tu32 product_id;\n\n\terror = himax_read_product_id(ts, &product_id);\n\tif (error)\n\t\treturn error;\n\n\tdev_dbg(&ts->client->dev, \"Product id: %x\\n\", product_id);\n\n\tswitch (product_id) {\n\tcase HIMAX_ID_83112B:\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Unknown product id: %x\\n\", product_id);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int himax_input_register(struct himax_ts_data *ts)\n{\n\tint error;\n\n\tts->input_dev = devm_input_allocate_device(&ts->client->dev);\n\tif (!ts->input_dev) {\n\t\tdev_err(&ts->client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->input_dev->name = \"Himax Touchscreen\";\n\n\tinput_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);\n\tinput_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 200, 0, 0);\n\n\ttouchscreen_parse_properties(ts->input_dev, true, &ts->props);\n\n\terror = input_mt_init_slots(ts->input_dev, HIMAX_MAX_POINTS,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input_dev);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 himax_event_get_num_points(const struct himax_event *event)\n{\n\tif (event->num_points == 0xff)\n\t\treturn 0;\n\telse\n\t\treturn event->num_points & 0x0f;\n}\n\nstatic bool himax_process_event_point(struct himax_ts_data *ts,\n\t\t\t\t      const struct himax_event *event,\n\t\t\t\t      int point_index)\n{\n\tconst struct himax_event_point *point = &event->points[point_index];\n\tu16 x = be16_to_cpu(point->x);\n\tu16 y = be16_to_cpu(point->y);\n\tu8 w = event->majors[point_index];\n\n\tif (x == HIMAX_INVALID_COORD || y == HIMAX_INVALID_COORD)\n\t\treturn false;\n\n\tinput_mt_slot(ts->input_dev, point_index);\n\tinput_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);\n\ttouchscreen_report_pos(ts->input_dev, &ts->props, x, y, true);\n\tinput_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);\n\tinput_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);\n\treturn true;\n}\n\nstatic void himax_process_event(struct himax_ts_data *ts,\n\t\t\t\tconst struct himax_event *event)\n{\n\tint i;\n\tint num_points_left = himax_event_get_num_points(event);\n\n\tfor (i = 0; i < HIMAX_MAX_POINTS && num_points_left > 0; i++) {\n\t\tif (himax_process_event_point(ts, event, i))\n\t\t\tnum_points_left--;\n\t}\n\n\tinput_mt_sync_frame(ts->input_dev);\n\tinput_sync(ts->input_dev);\n}\n\nstatic bool himax_verify_checksum(struct himax_ts_data *ts,\n\t\t\t\t  const struct himax_event *event)\n{\n\tu8 *data = (u8 *)event;\n\tint i;\n\tu16 checksum = 0;\n\n\tfor (i = 0; i < sizeof(*event); i++)\n\t\tchecksum += data[i];\n\n\tif ((checksum & 0x00ff) != 0) {\n\t\tdev_err(&ts->client->dev, \"Wrong event checksum: %04x\\n\",\n\t\t\tchecksum);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int himax_handle_input(struct himax_ts_data *ts)\n{\n\tint error;\n\tstruct himax_event event;\n\n\terror = regmap_raw_read(ts->regmap, HIMAX_REG_READ_EVENT, &event,\n\t\t\t\tsizeof(event));\n\tif (error) {\n\t\tdev_err(&ts->client->dev, \"Failed to read input event: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tif (himax_verify_checksum(ts, &event))\n\t\thimax_process_event(ts, &event);\n\n\treturn 0;\n}\n\nstatic irqreturn_t himax_irq_handler(int irq, void *dev_id)\n{\n\tint error;\n\tstruct himax_ts_data *ts = dev_id;\n\n\terror = himax_handle_input(ts);\n\tif (error)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int himax_probe(struct i2c_client *client)\n{\n\tint error;\n\tstruct device *dev = &client->dev;\n\tstruct himax_ts_data *ts;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"I2C check functionality failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ts);\n\tts->client = client;\n\n\tts->regmap = devm_regmap_init_i2c(client, &himax_regmap_config);\n\terror = PTR_ERR_OR_ZERO(ts->regmap);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to initialize regmap: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->gpiod_rst = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\terror = PTR_ERR_OR_ZERO(ts->gpiod_rst);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to get reset GPIO: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\thimax_reset(ts);\n\n\terror = himax_check_product_id(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = himax_input_register(ts);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t  himax_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, ts);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int himax_suspend(struct device *dev)\n{\n\tstruct himax_ts_data *ts = dev_get_drvdata(dev);\n\n\tdisable_irq(ts->client->irq);\n\treturn 0;\n}\n\nstatic int himax_resume(struct device *dev)\n{\n\tstruct himax_ts_data *ts = dev_get_drvdata(dev);\n\n\tenable_irq(ts->client->irq);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(himax_pm_ops, himax_suspend, himax_resume);\n\nstatic const struct i2c_device_id himax_ts_id[] = {\n\t{ \"hx83112b\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, himax_ts_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id himax_of_match[] = {\n\t{ .compatible = \"himax,hx83112b\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, himax_of_match);\n#endif\n\nstatic struct i2c_driver himax_ts_driver = {\n\t.probe = himax_probe,\n\t.id_table = himax_ts_id,\n\t.driver = {\n\t\t.name = \"Himax-hx83112b-TS\",\n\t\t.of_match_table = of_match_ptr(himax_of_match),\n\t\t.pm = pm_sleep_ptr(&himax_pm_ops),\n\t},\n};\nmodule_i2c_driver(himax_ts_driver);\n\nMODULE_AUTHOR(\"Job Noorman <job@noorman.info>\");\nMODULE_DESCRIPTION(\"Himax hx83112b touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}