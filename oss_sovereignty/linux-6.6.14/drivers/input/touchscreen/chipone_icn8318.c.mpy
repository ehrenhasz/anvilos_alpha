{
  "module_name": "chipone_icn8318.c",
  "hash_id": "bc91c9c70c0a70f4de676617fc4d35b5ca6ed999d698644cd7d89fb3e297fd75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/chipone_icn8318.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#define ICN8318_REG_POWER\t\t4\n#define ICN8318_REG_TOUCHDATA\t\t16\n\n#define ICN8318_POWER_ACTIVE\t\t0\n#define ICN8318_POWER_MONITOR\t\t1\n#define ICN8318_POWER_HIBERNATE\t\t2\n\n#define ICN8318_MAX_TOUCHES\t\t5\n\nstruct icn8318_touch {\n\t__u8 slot;\n\t__be16 x;\n\t__be16 y;\n\t__u8 pressure;\t \n\t__u8 event;\n \n#define ICN8318_EVENT_NO_DATA\t1  \n#define ICN8318_EVENT_UPDATE1\t2  \n#define ICN8318_EVENT_UPDATE2\t3  \n#define ICN8318_EVENT_END\t4  \n} __packed;\n\nstruct icn8318_touch_data {\n\t__u8 softbutton;\n\t__u8 touch_count;\n\tstruct icn8318_touch touches[ICN8318_MAX_TOUCHES];\n} __packed;\n\nstruct icn8318_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *wake_gpio;\n\tstruct touchscreen_properties prop;\n};\n\nstatic int icn8318_read_touch_data(struct i2c_client *client,\n\t\t\t\t   struct icn8318_touch_data *touch_data)\n{\n\tu8 reg = ICN8318_REG_TOUCHDATA;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(struct icn8318_touch_data),\n\t\t\t.buf = (u8 *)touch_data\n\t\t}\n\t};\n\n\treturn i2c_transfer(client->adapter, msg, 2);\n}\n\nstatic inline bool icn8318_touch_active(u8 event)\n{\n\treturn (event == ICN8318_EVENT_UPDATE1) ||\n\t       (event == ICN8318_EVENT_UPDATE2);\n}\n\nstatic irqreturn_t icn8318_irq(int irq, void *dev_id)\n{\n\tstruct icn8318_data *data = dev_id;\n\tstruct device *dev = &data->client->dev;\n\tstruct icn8318_touch_data touch_data;\n\tint i, ret;\n\n\tret = icn8318_read_touch_data(data->client, &touch_data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error reading touch data: %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (touch_data.softbutton) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (touch_data.touch_count > ICN8318_MAX_TOUCHES) {\n\t\tdev_warn(dev, \"Too much touches %d > %d\\n\",\n\t\t\t touch_data.touch_count, ICN8318_MAX_TOUCHES);\n\t\ttouch_data.touch_count = ICN8318_MAX_TOUCHES;\n\t}\n\n\tfor (i = 0; i < touch_data.touch_count; i++) {\n\t\tstruct icn8318_touch *touch = &touch_data.touches[i];\n\t\tbool act = icn8318_touch_active(touch->event);\n\n\t\tinput_mt_slot(data->input, touch->slot);\n\t\tinput_mt_report_slot_state(data->input, MT_TOOL_FINGER, act);\n\t\tif (!act)\n\t\t\tcontinue;\n\n\t\ttouchscreen_report_pos(data->input, &data->prop,\n\t\t\t\t       be16_to_cpu(touch->x),\n\t\t\t\t       be16_to_cpu(touch->y), true);\n\t}\n\n\tinput_mt_sync_frame(data->input);\n\tinput_sync(data->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int icn8318_start(struct input_dev *dev)\n{\n\tstruct icn8318_data *data = input_get_drvdata(dev);\n\n\tenable_irq(data->client->irq);\n\tgpiod_set_value_cansleep(data->wake_gpio, 1);\n\n\treturn 0;\n}\n\nstatic void icn8318_stop(struct input_dev *dev)\n{\n\tstruct icn8318_data *data = input_get_drvdata(dev);\n\n\tdisable_irq(data->client->irq);\n\ti2c_smbus_write_byte_data(data->client, ICN8318_REG_POWER,\n\t\t\t\t  ICN8318_POWER_HIBERNATE);\n\tgpiod_set_value_cansleep(data->wake_gpio, 0);\n}\n\nstatic int icn8318_suspend(struct device *dev)\n{\n\tstruct icn8318_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&data->input->mutex);\n\tif (input_device_enabled(data->input))\n\t\ticn8318_stop(data->input);\n\tmutex_unlock(&data->input->mutex);\n\n\treturn 0;\n}\n\nstatic int icn8318_resume(struct device *dev)\n{\n\tstruct icn8318_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&data->input->mutex);\n\tif (input_device_enabled(data->input))\n\t\ticn8318_start(data->input);\n\tmutex_unlock(&data->input->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(icn8318_pm_ops, icn8318_suspend, icn8318_resume);\n\nstatic int icn8318_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct icn8318_data *data;\n\tstruct input_dev *input;\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"Error no irq specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->wake_gpio = devm_gpiod_get(dev, \"wake\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->wake_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->wake_gpio), \"Error getting wake gpio\\n\");\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = icn8318_start;\n\tinput->close = icn8318_stop;\n\tinput->dev.parent = dev;\n\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_Y);\n\n\ttouchscreen_parse_properties(input, true, &data->prop);\n\tif (!input_abs_get_max(input, ABS_MT_POSITION_X) ||\n\t    !input_abs_get_max(input, ABS_MT_POSITION_Y)) {\n\t\tdev_err(dev, \"Error touchscreen-size-x and/or -y missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_mt_init_slots(input, ICN8318_MAX_TOUCHES,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error)\n\t\treturn error;\n\n\tdata->client = client;\n\tdata->input = input;\n\tinput_set_drvdata(input, data);\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, icn8318_irq,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, data);\n\tif (error) {\n\t\tdev_err(dev, \"Error requesting irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\ticn8318_stop(data->input);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, data);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id icn8318_of_match[] = {\n\t{ .compatible = \"chipone,icn8318\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, icn8318_of_match);\n\n \nstatic const struct i2c_device_id icn8318_i2c_id[] = {\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, icn8318_i2c_id);\n\nstatic struct i2c_driver icn8318_driver = {\n\t.driver = {\n\t\t.name\t= \"chipone_icn8318\",\n\t\t.pm\t= pm_sleep_ptr(&icn8318_pm_ops),\n\t\t.of_match_table = icn8318_of_match,\n\t},\n\t.probe = icn8318_probe,\n\t.id_table = icn8318_i2c_id,\n};\n\nmodule_i2c_driver(icn8318_driver);\n\nMODULE_DESCRIPTION(\"ChipOne icn8318 I2C Touchscreen Driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}