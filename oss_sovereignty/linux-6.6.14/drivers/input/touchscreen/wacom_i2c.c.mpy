{
  "module_name": "wacom_i2c.c",
  "hash_id": "44dfdc8970d73a80b545d5b37c3cbf3e2ed1ad25721db65cce46dbea85f467a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wacom_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <asm/unaligned.h>\n\n \n#define WACOM_TIP_SWITCH\tBIT(0)\n#define WACOM_BARREL_SWITCH\tBIT(1)\n#define WACOM_ERASER\t\tBIT(2)\n#define WACOM_INVERT\t\tBIT(3)\n#define WACOM_BARREL_SWITCH_2\tBIT(4)\n#define WACOM_IN_PROXIMITY\tBIT(5)\n\n \n#define WACOM_COMMAND_LSB\t0x04\n#define WACOM_COMMAND_MSB\t0x00\n\n#define WACOM_DATA_LSB\t\t0x05\n#define WACOM_DATA_MSB\t\t0x00\n\n \n#define REPORT_FEATURE\t\t0x30\n\n \n#define OPCODE_GET_REPORT\t0x02\n\n#define WACOM_QUERY_REPORT\t3\n#define WACOM_QUERY_SIZE\t19\n\nstruct wacom_features {\n\tint x_max;\n\tint y_max;\n\tint pressure_max;\n\tchar fw_version;\n};\n\nstruct wacom_i2c {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tu8 data[WACOM_QUERY_SIZE];\n\tbool prox;\n\tint tool;\n};\n\nstatic int wacom_query_device(struct i2c_client *client,\n\t\t\t      struct wacom_features *features)\n{\n\tu8 get_query_data_cmd[] = {\n\t\tWACOM_COMMAND_LSB,\n\t\tWACOM_COMMAND_MSB,\n\t\tREPORT_FEATURE | WACOM_QUERY_REPORT,\n\t\tOPCODE_GET_REPORT,\n\t\tWACOM_DATA_LSB,\n\t\tWACOM_DATA_MSB,\n\t};\n\tu8 data[WACOM_QUERY_SIZE];\n\tint ret;\n\n\tstruct i2c_msg msgs[] = {\n\t\t \n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(get_query_data_cmd),\n\t\t\t.buf = get_query_data_cmd,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = sizeof(data),\n\t\t\t.buf = data,\n\t\t},\n\t};\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\tfeatures->x_max = get_unaligned_le16(&data[3]);\n\tfeatures->y_max = get_unaligned_le16(&data[5]);\n\tfeatures->pressure_max = get_unaligned_le16(&data[11]);\n\tfeatures->fw_version = get_unaligned_le16(&data[13]);\n\n\tdev_dbg(&client->dev,\n\t\t\"x_max:%d, y_max:%d, pressure:%d, fw:%d\\n\",\n\t\tfeatures->x_max, features->y_max,\n\t\tfeatures->pressure_max, features->fw_version);\n\n\treturn 0;\n}\n\nstatic irqreturn_t wacom_i2c_irq(int irq, void *dev_id)\n{\n\tstruct wacom_i2c *wac_i2c = dev_id;\n\tstruct input_dev *input = wac_i2c->input;\n\tu8 *data = wac_i2c->data;\n\tunsigned int x, y, pressure;\n\tunsigned char tsw, f1, f2, ers;\n\tint error;\n\n\terror = i2c_master_recv(wac_i2c->client,\n\t\t\t\twac_i2c->data, sizeof(wac_i2c->data));\n\tif (error < 0)\n\t\tgoto out;\n\n\ttsw = data[3] & WACOM_TIP_SWITCH;\n\ters = data[3] & WACOM_ERASER;\n\tf1 = data[3] & WACOM_BARREL_SWITCH;\n\tf2 = data[3] & WACOM_BARREL_SWITCH_2;\n\tx = le16_to_cpup((__le16 *)&data[4]);\n\ty = le16_to_cpup((__le16 *)&data[6]);\n\tpressure = le16_to_cpup((__le16 *)&data[8]);\n\n\tif (!wac_i2c->prox)\n\t\twac_i2c->tool = (data[3] & (WACOM_ERASER | WACOM_INVERT)) ?\n\t\t\tBTN_TOOL_RUBBER : BTN_TOOL_PEN;\n\n\twac_i2c->prox = data[3] & WACOM_IN_PROXIMITY;\n\n\tinput_report_key(input, BTN_TOUCH, tsw || ers);\n\tinput_report_key(input, wac_i2c->tool, wac_i2c->prox);\n\tinput_report_key(input, BTN_STYLUS, f1);\n\tinput_report_key(input, BTN_STYLUS2, f2);\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\tinput_report_abs(input, ABS_PRESSURE, pressure);\n\tinput_sync(input);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int wacom_i2c_open(struct input_dev *dev)\n{\n\tstruct wacom_i2c *wac_i2c = input_get_drvdata(dev);\n\tstruct i2c_client *client = wac_i2c->client;\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic void wacom_i2c_close(struct input_dev *dev)\n{\n\tstruct wacom_i2c *wac_i2c = input_get_drvdata(dev);\n\tstruct i2c_client *client = wac_i2c->client;\n\n\tdisable_irq(client->irq);\n}\n\nstatic int wacom_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct wacom_i2c *wac_i2c;\n\tstruct input_dev *input;\n\tstruct wacom_features features = { 0 };\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"i2c_check_functionality error\\n\");\n\t\treturn -EIO;\n\t}\n\n\terror = wacom_query_device(client, &features);\n\tif (error)\n\t\treturn error;\n\n\twac_i2c = devm_kzalloc(dev, sizeof(*wac_i2c), GFP_KERNEL);\n\tif (!wac_i2c)\n\t\treturn -ENOMEM;\n\n\twac_i2c->client = client;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\twac_i2c->input = input;\n\n\tinput->name = \"Wacom I2C Digitizer\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = 0x56a;\n\tinput->id.version = features.fw_version;\n\tinput->open = wacom_i2c_open;\n\tinput->close = wacom_i2c_close;\n\n\tinput->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\t__set_bit(BTN_TOOL_PEN, input->keybit);\n\t__set_bit(BTN_TOOL_RUBBER, input->keybit);\n\t__set_bit(BTN_STYLUS, input->keybit);\n\t__set_bit(BTN_STYLUS2, input->keybit);\n\t__set_bit(BTN_TOUCH, input->keybit);\n\n\tinput_set_abs_params(input, ABS_X, 0, features.x_max, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, features.y_max, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE,\n\t\t\t     0, features.pressure_max, 0, 0);\n\n\tinput_set_drvdata(input, wac_i2c);\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, wacom_i2c_irq,\n\t\t\t\t\t  IRQF_ONESHOT, \"wacom_i2c\", wac_i2c);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tdisable_irq(client->irq);\n\n\terror = input_register_device(wac_i2c->input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wacom_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int wacom_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(wacom_i2c_pm, wacom_i2c_suspend, wacom_i2c_resume);\n\nstatic const struct i2c_device_id wacom_i2c_id[] = {\n\t{ \"WAC_I2C_EMR\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, wacom_i2c_id);\n\nstatic struct i2c_driver wacom_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"wacom_i2c\",\n\t\t.pm\t= pm_sleep_ptr(&wacom_i2c_pm),\n\t},\n\n\t.probe\t\t= wacom_i2c_probe,\n\t.id_table\t= wacom_i2c_id,\n};\nmodule_i2c_driver(wacom_i2c_driver);\n\nMODULE_AUTHOR(\"Tatsunosuke Tobita <tobita.tatsunosuke@wacom.co.jp>\");\nMODULE_DESCRIPTION(\"WACOM EMR I2C Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}