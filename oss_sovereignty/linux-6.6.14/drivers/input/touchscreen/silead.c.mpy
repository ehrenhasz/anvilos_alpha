{
  "module_name": "silead.c",
  "hash_id": "9506ce0ce84fc14a8a4e492f7a91f9a7214ec3bde4ae3585d4190f9b28b4b03d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/silead.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/irq.h>\n#include <linux/regulator/consumer.h>\n\n#include <asm/unaligned.h>\n\n#define SILEAD_TS_NAME\t\t\"silead_ts\"\n\n#define SILEAD_REG_RESET\t0xE0\n#define SILEAD_REG_DATA\t\t0x80\n#define SILEAD_REG_TOUCH_NR\t0x80\n#define SILEAD_REG_POWER\t0xBC\n#define SILEAD_REG_CLOCK\t0xE4\n#define SILEAD_REG_STATUS\t0xB0\n#define SILEAD_REG_ID\t\t0xFC\n#define SILEAD_REG_MEM_CHECK\t0xB0\n\n#define SILEAD_STATUS_OK\t0x5A5A5A5A\n#define SILEAD_TS_DATA_LEN\t44\n#define SILEAD_CLOCK\t\t0x04\n\n#define SILEAD_CMD_RESET\t0x88\n#define SILEAD_CMD_START\t0x00\n\n#define SILEAD_POINT_DATA_LEN\t0x04\n#define SILEAD_POINT_Y_OFF      0x00\n#define SILEAD_POINT_Y_MSB_OFF\t0x01\n#define SILEAD_POINT_X_OFF\t0x02\n#define SILEAD_POINT_X_MSB_OFF\t0x03\n#define SILEAD_EXTRA_DATA_MASK\t0xF0\n\n#define SILEAD_CMD_SLEEP_MIN\t10000\n#define SILEAD_CMD_SLEEP_MAX\t20000\n#define SILEAD_POWER_SLEEP\t20\n#define SILEAD_STARTUP_SLEEP\t30\n\n#define SILEAD_MAX_FINGERS\t10\n\nenum silead_ts_power {\n\tSILEAD_POWER_ON  = 1,\n\tSILEAD_POWER_OFF = 0\n};\n\nstruct silead_ts_data {\n\tstruct i2c_client *client;\n\tstruct gpio_desc *gpio_power;\n\tstruct input_dev *input;\n\tstruct input_dev *pen_input;\n\tstruct regulator_bulk_data regulators[2];\n\tchar fw_name[64];\n\tstruct touchscreen_properties prop;\n\tu32 max_fingers;\n\tu32 chip_id;\n\tstruct input_mt_pos pos[SILEAD_MAX_FINGERS];\n\tint slots[SILEAD_MAX_FINGERS];\n\tint id[SILEAD_MAX_FINGERS];\n\tu32 efi_fw_min_max[4];\n\tbool efi_fw_min_max_set;\n\tbool pen_supported;\n\tbool pen_down;\n\tu32 pen_x_res;\n\tu32 pen_y_res;\n\tint pen_up_count;\n};\n\nstruct silead_fw_data {\n\tu32 offset;\n\tu32 val;\n};\n\nstatic void silead_apply_efi_fw_min_max(struct silead_ts_data *data)\n{\n\tstruct input_absinfo *absinfo_x = &data->input->absinfo[ABS_MT_POSITION_X];\n\tstruct input_absinfo *absinfo_y = &data->input->absinfo[ABS_MT_POSITION_Y];\n\n\tif (!data->efi_fw_min_max_set)\n\t\treturn;\n\n\tabsinfo_x->minimum = data->efi_fw_min_max[0];\n\tabsinfo_x->maximum = data->efi_fw_min_max[1];\n\tabsinfo_y->minimum = data->efi_fw_min_max[2];\n\tabsinfo_y->maximum = data->efi_fw_min_max[3];\n\n\tif (data->prop.invert_x) {\n\t\tabsinfo_x->maximum -= absinfo_x->minimum;\n\t\tabsinfo_x->minimum = 0;\n\t}\n\n\tif (data->prop.invert_y) {\n\t\tabsinfo_y->maximum -= absinfo_y->minimum;\n\t\tabsinfo_y->minimum = 0;\n\t}\n\n\tif (data->prop.swap_x_y) {\n\t\tswap(absinfo_x->minimum, absinfo_y->minimum);\n\t\tswap(absinfo_x->maximum, absinfo_y->maximum);\n\t}\n}\n\nstatic int silead_ts_request_input_dev(struct silead_ts_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint error;\n\n\tdata->input = devm_input_allocate_device(dev);\n\tif (!data->input) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_abs_params(data->input, ABS_MT_POSITION_X, 0, 4095, 0, 0);\n\tinput_set_abs_params(data->input, ABS_MT_POSITION_Y, 0, 4095, 0, 0);\n\ttouchscreen_parse_properties(data->input, true, &data->prop);\n\tsilead_apply_efi_fw_min_max(data);\n\n\tinput_mt_init_slots(data->input, data->max_fingers,\n\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED |\n\t\t\t    INPUT_MT_TRACK);\n\n\tif (device_property_read_bool(dev, \"silead,home-button\"))\n\t\tinput_set_capability(data->input, EV_KEY, KEY_LEFTMETA);\n\n\tdata->input->name = SILEAD_TS_NAME;\n\tdata->input->phys = \"input/ts\";\n\tdata->input->id.bustype = BUS_I2C;\n\n\terror = input_register_device(data->input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register input device: %d\\n\", error);\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int silead_ts_request_pen_input_dev(struct silead_ts_data *data)\n{\n\tstruct device *dev = &data->client->dev;\n\tint error;\n\n\tif (!data->pen_supported)\n\t\treturn 0;\n\n\tdata->pen_input = devm_input_allocate_device(dev);\n\tif (!data->pen_input)\n\t\treturn -ENOMEM;\n\n\tinput_set_abs_params(data->pen_input, ABS_X, 0, 4095, 0, 0);\n\tinput_set_abs_params(data->pen_input, ABS_Y, 0, 4095, 0, 0);\n\tinput_set_capability(data->pen_input, EV_KEY, BTN_TOUCH);\n\tinput_set_capability(data->pen_input, EV_KEY, BTN_TOOL_PEN);\n\tset_bit(INPUT_PROP_DIRECT, data->pen_input->propbit);\n\ttouchscreen_parse_properties(data->pen_input, false, &data->prop);\n\tinput_abs_set_res(data->pen_input, ABS_X, data->pen_x_res);\n\tinput_abs_set_res(data->pen_input, ABS_Y, data->pen_y_res);\n\n\tdata->pen_input->name = SILEAD_TS_NAME \" pen\";\n\tdata->pen_input->phys = \"input/pen\";\n\tdata->input->id.bustype = BUS_I2C;\n\n\terror = input_register_device(data->pen_input);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to register pen input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void silead_ts_set_power(struct i2c_client *client,\n\t\t\t\tenum silead_ts_power state)\n{\n\tstruct silead_ts_data *data = i2c_get_clientdata(client);\n\n\tif (data->gpio_power) {\n\t\tgpiod_set_value_cansleep(data->gpio_power, state);\n\t\tmsleep(SILEAD_POWER_SLEEP);\n\t}\n}\n\nstatic bool silead_ts_handle_pen_data(struct silead_ts_data *data, u8 *buf)\n{\n\tu8 *coord = buf + SILEAD_POINT_DATA_LEN;\n\tstruct input_mt_pos pos;\n\n\tif (!data->pen_supported || buf[2] != 0x00 || buf[3] != 0x00)\n\t\treturn false;\n\n\tif (buf[0] == 0x00 && buf[1] == 0x00 && data->pen_down) {\n\t\tdata->pen_up_count++;\n\t\tif (data->pen_up_count == 6) {\n\t\t\tdata->pen_down = false;\n\t\t\tgoto sync;\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (buf[0] == 0x01 && buf[1] == 0x08) {\n\t\ttouchscreen_set_mt_pos(&pos, &data->prop,\n\t\t\tget_unaligned_le16(&coord[SILEAD_POINT_X_OFF]) & 0xfff,\n\t\t\tget_unaligned_le16(&coord[SILEAD_POINT_Y_OFF]) & 0xfff);\n\n\t\tinput_report_abs(data->pen_input, ABS_X, pos.x);\n\t\tinput_report_abs(data->pen_input, ABS_Y, pos.y);\n\n\t\tdata->pen_up_count = 0;\n\t\tdata->pen_down = true;\n\t\tgoto sync;\n\t}\n\n\treturn false;\n\nsync:\n\tinput_report_key(data->pen_input, BTN_TOOL_PEN, data->pen_down);\n\tinput_report_key(data->pen_input, BTN_TOUCH, data->pen_down);\n\tinput_sync(data->pen_input);\n\treturn true;\n}\n\nstatic void silead_ts_read_data(struct i2c_client *client)\n{\n\tstruct silead_ts_data *data = i2c_get_clientdata(client);\n\tstruct input_dev *input = data->input;\n\tstruct device *dev = &client->dev;\n\tu8 *bufp, buf[SILEAD_TS_DATA_LEN];\n\tint touch_nr, softbutton, error, i;\n\tbool softbutton_pressed = false;\n\n\terror = i2c_smbus_read_i2c_block_data(client, SILEAD_REG_DATA,\n\t\t\t\t\t      SILEAD_TS_DATA_LEN, buf);\n\tif (error < 0) {\n\t\tdev_err(dev, \"Data read error %d\\n\", error);\n\t\treturn;\n\t}\n\n\tif (buf[0] > data->max_fingers) {\n\t\tdev_warn(dev, \"More touches reported then supported %d > %d\\n\",\n\t\t\t buf[0], data->max_fingers);\n\t\tbuf[0] = data->max_fingers;\n\t}\n\n\tif (silead_ts_handle_pen_data(data, buf))\n\t\tgoto sync;  \n\n\ttouch_nr = 0;\n\tbufp = buf + SILEAD_POINT_DATA_LEN;\n\tfor (i = 0; i < buf[0]; i++, bufp += SILEAD_POINT_DATA_LEN) {\n\t\tsoftbutton = (bufp[SILEAD_POINT_Y_MSB_OFF] &\n\t\t\t      SILEAD_EXTRA_DATA_MASK) >> 4;\n\n\t\tif (softbutton) {\n\t\t\t \n\t\t\tif (softbutton == 0x01)\n\t\t\t\tsoftbutton_pressed = true;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdata->id[touch_nr] = (bufp[SILEAD_POINT_X_MSB_OFF] &\n\t\t\t\t      SILEAD_EXTRA_DATA_MASK) >> 4;\n\t\ttouchscreen_set_mt_pos(&data->pos[touch_nr], &data->prop,\n\t\t\tget_unaligned_le16(&bufp[SILEAD_POINT_X_OFF]) & 0xfff,\n\t\t\tget_unaligned_le16(&bufp[SILEAD_POINT_Y_OFF]) & 0xfff);\n\t\ttouch_nr++;\n\t}\n\n\tinput_mt_assign_slots(input, data->slots, data->pos, touch_nr, 0);\n\n\tfor (i = 0; i < touch_nr; i++) {\n\t\tinput_mt_slot(input, data->slots[i]);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, data->pos[i].x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, data->pos[i].y);\n\n\t\tdev_dbg(dev, \"x=%d y=%d hw_id=%d sw_id=%d\\n\", data->pos[i].x,\n\t\t\tdata->pos[i].y, data->id[i], data->slots[i]);\n\t}\n\nsync:\n\tinput_mt_sync_frame(input);\n\tinput_report_key(input, KEY_LEFTMETA, softbutton_pressed);\n\tinput_sync(input);\n}\n\nstatic int silead_ts_init(struct i2c_client *client)\n{\n\tstruct silead_ts_data *data = i2c_get_clientdata(client);\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET,\n\t\t\t\t\t  SILEAD_CMD_RESET);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_TOUCH_NR,\n\t\t\t\t\tdata->max_fingers);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_CLOCK,\n\t\t\t\t\t  SILEAD_CLOCK);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET,\n\t\t\t\t\t  SILEAD_CMD_START);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\treturn 0;\n\ni2c_write_err:\n\tdev_err(&client->dev, \"Registers clear error %d\\n\", error);\n\treturn error;\n}\n\nstatic int silead_ts_reset(struct i2c_client *client)\n{\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET,\n\t\t\t\t\t  SILEAD_CMD_RESET);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_CLOCK,\n\t\t\t\t\t  SILEAD_CLOCK);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_POWER,\n\t\t\t\t\t  SILEAD_CMD_START);\n\tif (error)\n\t\tgoto i2c_write_err;\n\tusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\n\n\treturn 0;\n\ni2c_write_err:\n\tdev_err(&client->dev, \"Chip reset error %d\\n\", error);\n\treturn error;\n}\n\nstatic int silead_ts_startup(struct i2c_client *client)\n{\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET, 0x00);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Startup error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmsleep(SILEAD_STARTUP_SLEEP);\n\n\treturn 0;\n}\n\nstatic int silead_ts_load_fw(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct silead_ts_data *data = i2c_get_clientdata(client);\n\tconst struct firmware *fw = NULL;\n\tstruct silead_fw_data *fw_data;\n\tunsigned int fw_size, i;\n\tint error;\n\n\tdev_dbg(dev, \"Firmware file name: %s\", data->fw_name);\n\n\t \n\terror = firmware_request_nowarn(&fw, data->fw_name, dev);\n\tif (error) {\n\t\terror = firmware_request_platform(&fw, data->fw_name, dev);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Firmware request error %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = device_property_read_u32_array(dev, \"silead,efi-fw-min-max\",\n\t\t\t\t\t\t       data->efi_fw_min_max,\n\t\t\t\t\t\t       ARRAY_SIZE(data->efi_fw_min_max));\n\t\tif (!error)\n\t\t\tdata->efi_fw_min_max_set = true;\n\n\t\t \n\t\tif (data->pen_supported) {\n\t\t\tdev_warn(dev, \"Warning loading '%s' from filesystem failed, using EFI embedded copy.\\n\",\n\t\t\t\t data->fw_name);\n\t\t\tdev_warn(dev, \"Warning pen support is known to be broken in the EFI embedded fw version\\n\");\n\t\t\tdata->pen_supported = false;\n\t\t}\n\t}\n\n\tfw_size = fw->size / sizeof(*fw_data);\n\tfw_data = (struct silead_fw_data *)fw->data;\n\n\tfor (i = 0; i < fw_size; i++) {\n\t\terror = i2c_smbus_write_i2c_block_data(client,\n\t\t\t\t\t\t       fw_data[i].offset,\n\t\t\t\t\t\t       4,\n\t\t\t\t\t\t       (u8 *)&fw_data[i].val);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"Firmware load error %d\\n\", error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trelease_firmware(fw);\n\treturn error ?: 0;\n}\n\nstatic u32 silead_ts_get_status(struct i2c_client *client)\n{\n\tint error;\n\t__le32 status;\n\n\terror = i2c_smbus_read_i2c_block_data(client, SILEAD_REG_STATUS,\n\t\t\t\t\t      sizeof(status), (u8 *)&status);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Status read error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn le32_to_cpu(status);\n}\n\nstatic int silead_ts_get_id(struct i2c_client *client)\n{\n\tstruct silead_ts_data *data = i2c_get_clientdata(client);\n\t__le32 chip_id;\n\tint error;\n\n\terror = i2c_smbus_read_i2c_block_data(client, SILEAD_REG_ID,\n\t\t\t\t\t      sizeof(chip_id), (u8 *)&chip_id);\n\tif (error < 0)\n\t\treturn error;\n\n\tdata->chip_id = le32_to_cpu(chip_id);\n\tdev_info(&client->dev, \"Silead chip ID: 0x%8X\", data->chip_id);\n\n\treturn 0;\n}\n\nstatic int silead_ts_setup(struct i2c_client *client)\n{\n\tint error;\n\tu32 status;\n\n\t \n\n\tif (device_property_read_bool(&client->dev,\n\t\t\t\t      \"silead,stuck-controller-bug\")) {\n\t\tpm_runtime_set_active(&client->dev);\n\t\tpm_runtime_enable(&client->dev);\n\t\tpm_runtime_allow(&client->dev);\n\n\t\tpm_runtime_suspend(&client->dev);\n\n\t\tdev_warn(&client->dev, FW_BUG \"Stuck I2C bus: please ignore the next 'controller timed out' error\\n\");\n\t\tsilead_ts_get_id(client);\n\n\t\t \n\t\tpm_runtime_forbid(&client->dev);\n\t\tpm_runtime_disable(&client->dev);\n\t}\n\n\tsilead_ts_set_power(client, SILEAD_POWER_OFF);\n\tsilead_ts_set_power(client, SILEAD_POWER_ON);\n\n\terror = silead_ts_get_id(client);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Chip ID read error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = silead_ts_init(client);\n\tif (error)\n\t\treturn error;\n\n\terror = silead_ts_reset(client);\n\tif (error)\n\t\treturn error;\n\n\terror = silead_ts_load_fw(client);\n\tif (error)\n\t\treturn error;\n\n\terror = silead_ts_startup(client);\n\tif (error)\n\t\treturn error;\n\n\tstatus = silead_ts_get_status(client);\n\tif (status != SILEAD_STATUS_OK) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Initialization error, status: 0x%X\\n\", status);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t silead_ts_threaded_irq_handler(int irq, void *id)\n{\n\tstruct silead_ts_data *data = id;\n\tstruct i2c_client *client = data->client;\n\n\tsilead_ts_read_data(client);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void silead_ts_read_props(struct i2c_client *client)\n{\n\tstruct silead_ts_data *data = i2c_get_clientdata(client);\n\tstruct device *dev = &client->dev;\n\tconst char *str;\n\tint error;\n\n\terror = device_property_read_u32(dev, \"silead,max-fingers\",\n\t\t\t\t\t &data->max_fingers);\n\tif (error) {\n\t\tdev_dbg(dev, \"Max fingers read error %d\\n\", error);\n\t\tdata->max_fingers = 5;  \n\t}\n\n\terror = device_property_read_string(dev, \"firmware-name\", &str);\n\tif (!error)\n\t\tsnprintf(data->fw_name, sizeof(data->fw_name),\n\t\t\t \"silead/%s\", str);\n\telse\n\t\tdev_dbg(dev, \"Firmware file name read error. Using default.\");\n\n\tdata->pen_supported = device_property_read_bool(dev, \"silead,pen-supported\");\n\tdevice_property_read_u32(dev, \"silead,pen-resolution-x\", &data->pen_x_res);\n\tdevice_property_read_u32(dev, \"silead,pen-resolution-y\", &data->pen_y_res);\n}\n\n#ifdef CONFIG_ACPI\nstatic int silead_ts_set_default_fw_name(struct silead_ts_data *data,\n\t\t\t\t\t const struct i2c_device_id *id)\n{\n\tconst struct acpi_device_id *acpi_id;\n\tstruct device *dev = &data->client->dev;\n\tint i;\n\n\tif (ACPI_HANDLE(dev)) {\n\t\tacpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);\n\t\tif (!acpi_id)\n\t\t\treturn -ENODEV;\n\n\t\tsnprintf(data->fw_name, sizeof(data->fw_name),\n\t\t\t \"silead/%s.fw\", acpi_id->id);\n\n\t\tfor (i = 0; i < strlen(data->fw_name); i++)\n\t\t\tdata->fw_name[i] = tolower(data->fw_name[i]);\n\t} else {\n\t\tsnprintf(data->fw_name, sizeof(data->fw_name),\n\t\t\t \"silead/%s.fw\", id->name);\n\t}\n\n\treturn 0;\n}\n#else\nstatic int silead_ts_set_default_fw_name(struct silead_ts_data *data,\n\t\t\t\t\t const struct i2c_device_id *id)\n{\n\tsnprintf(data->fw_name, sizeof(data->fw_name),\n\t\t \"silead/%s.fw\", id->name);\n\treturn 0;\n}\n#endif\n\nstatic void silead_disable_regulator(void *arg)\n{\n\tstruct silead_ts_data *data = arg;\n\n\tregulator_bulk_disable(ARRAY_SIZE(data->regulators), data->regulators);\n}\n\nstatic int silead_ts_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct silead_ts_data *data;\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_I2C |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) {\n\t\tdev_err(dev, \"I2C functionality check failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, data);\n\tdata->client = client;\n\n\terror = silead_ts_set_default_fw_name(data, id);\n\tif (error)\n\t\treturn error;\n\n\tsilead_ts_read_props(client);\n\n\t \n\tif (client->irq <= 0)\n\t\treturn -ENODEV;\n\n\tdata->regulators[0].supply = \"vddio\";\n\tdata->regulators[1].supply = \"avdd\";\n\terror = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->regulators),\n\t\t\t\t\tdata->regulators);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = regulator_bulk_enable(ARRAY_SIZE(data->regulators),\n\t\t\t\t      data->regulators);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(dev, silead_disable_regulator, data);\n\tif (error)\n\t\treturn error;\n\n\t \n\tdata->gpio_power = devm_gpiod_get_optional(dev, \"power\", GPIOD_OUT_LOW);\n\tif (IS_ERR(data->gpio_power))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->gpio_power),\n\t\t\t\t     \"Shutdown GPIO request failed\\n\");\n\n\terror = silead_ts_setup(client);\n\tif (error)\n\t\treturn error;\n\n\terror = silead_ts_request_input_dev(data);\n\tif (error)\n\t\treturn error;\n\n\terror = silead_ts_request_pen_input_dev(data);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t  NULL, silead_ts_threaded_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT, client->name, data);\n\tif (error) {\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"IRQ request failed %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int silead_ts_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tdisable_irq(client->irq);\n\tsilead_ts_set_power(client, SILEAD_POWER_OFF);\n\treturn 0;\n}\n\nstatic int silead_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tbool second_try = false;\n\tint error, status;\n\n\tsilead_ts_set_power(client, SILEAD_POWER_ON);\n\n retry:\n\terror = silead_ts_reset(client);\n\tif (error)\n\t\treturn error;\n\n\tif (second_try) {\n\t\terror = silead_ts_load_fw(client);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = silead_ts_startup(client);\n\tif (error)\n\t\treturn error;\n\n\tstatus = silead_ts_get_status(client);\n\tif (status != SILEAD_STATUS_OK) {\n\t\tif (!second_try) {\n\t\t\tsecond_try = true;\n\t\t\tdev_dbg(dev, \"Reloading firmware after unsuccessful resume\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tdev_err(dev, \"Resume error, status: 0x%02x\\n\", status);\n\t\treturn -ENODEV;\n\t}\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(silead_ts_pm, silead_ts_suspend, silead_ts_resume);\n\nstatic const struct i2c_device_id silead_ts_id[] = {\n\t{ \"gsl1680\", 0 },\n\t{ \"gsl1688\", 0 },\n\t{ \"gsl3670\", 0 },\n\t{ \"gsl3675\", 0 },\n\t{ \"gsl3692\", 0 },\n\t{ \"mssl1680\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, silead_ts_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id silead_ts_acpi_match[] = {\n\t{ \"GSL1680\", 0 },\n\t{ \"GSL1688\", 0 },\n\t{ \"GSL3670\", 0 },\n\t{ \"GSL3675\", 0 },\n\t{ \"GSL3692\", 0 },\n\t{ \"MSSL1680\", 0 },\n\t{ \"MSSL0001\", 0 },\n\t{ \"MSSL0002\", 0 },\n\t{ \"MSSL0017\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, silead_ts_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id silead_ts_of_match[] = {\n\t{ .compatible = \"silead,gsl1680\" },\n\t{ .compatible = \"silead,gsl1688\" },\n\t{ .compatible = \"silead,gsl3670\" },\n\t{ .compatible = \"silead,gsl3675\" },\n\t{ .compatible = \"silead,gsl3692\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, silead_ts_of_match);\n#endif\n\nstatic struct i2c_driver silead_ts_driver = {\n\t.probe = silead_ts_probe,\n\t.id_table = silead_ts_id,\n\t.driver = {\n\t\t.name = SILEAD_TS_NAME,\n\t\t.acpi_match_table = ACPI_PTR(silead_ts_acpi_match),\n\t\t.of_match_table = of_match_ptr(silead_ts_of_match),\n\t\t.pm = pm_sleep_ptr(&silead_ts_pm),\n\t},\n};\nmodule_i2c_driver(silead_ts_driver);\n\nMODULE_AUTHOR(\"Robert Dolca <robert.dolca@intel.com>\");\nMODULE_DESCRIPTION(\"Silead I2C touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}