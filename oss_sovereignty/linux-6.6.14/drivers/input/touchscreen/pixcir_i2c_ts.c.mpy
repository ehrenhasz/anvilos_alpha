{
  "module_name": "pixcir_i2c_ts.c",
  "hash_id": "a07d0de4b623adc56e14c084b68c9fd47ca57315120745c3c31f1c756da3cd5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/pixcir_i2c_ts.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#define PIXCIR_MAX_SLOTS       5  \n\n \n#define PIXCIR_REG_POWER_MODE\t51\n#define PIXCIR_REG_INT_MODE\t52\n\n \nenum pixcir_power_mode {\n\tPIXCIR_POWER_ACTIVE,\n\tPIXCIR_POWER_IDLE,\n\tPIXCIR_POWER_HALT,\n};\n\n#define PIXCIR_POWER_MODE_MASK\t0x03\n#define PIXCIR_POWER_ALLOW_IDLE (1UL << 2)\n\n \nenum pixcir_int_mode {\n\tPIXCIR_INT_PERIODICAL,\n\tPIXCIR_INT_DIFF_COORD,\n\tPIXCIR_INT_LEVEL_TOUCH,\n\tPIXCIR_INT_PULSE_TOUCH,\n};\n\n#define PIXCIR_INT_MODE_MASK\t0x03\n#define PIXCIR_INT_ENABLE\t(1UL << 3)\n#define PIXCIR_INT_POL_HIGH\t(1UL << 2)\n\n \nstruct pixcir_i2c_chip_data {\n\tu8 max_fingers;\n\tbool has_hw_ids;\n};\n\nstruct pixcir_i2c_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *gpio_attb;\n\tstruct gpio_desc *gpio_reset;\n\tstruct gpio_desc *gpio_enable;\n\tstruct gpio_desc *gpio_wake;\n\tconst struct pixcir_i2c_chip_data *chip;\n\tstruct touchscreen_properties prop;\n\tbool running;\n};\n\nstruct pixcir_report_data {\n\tint num_touches;\n\tstruct input_mt_pos pos[PIXCIR_MAX_SLOTS];\n\tint ids[PIXCIR_MAX_SLOTS];\n};\n\nstatic void pixcir_ts_parse(struct pixcir_i2c_ts_data *tsdata,\n\t\t\t    struct pixcir_report_data *report)\n{\n\tu8 rdbuf[2 + PIXCIR_MAX_SLOTS * 5];\n\tu8 wrbuf[1] = { 0 };\n\tu8 *bufptr;\n\tu8 touch;\n\tint ret, i;\n\tint readsize;\n\tconst struct pixcir_i2c_chip_data *chip = tsdata->chip;\n\n\tmemset(report, 0, sizeof(struct pixcir_report_data));\n\n\ti = chip->has_hw_ids ? 1 : 0;\n\treadsize = 2 + tsdata->chip->max_fingers * (4 + i);\n\tif (readsize > sizeof(rdbuf))\n\t\treadsize = sizeof(rdbuf);\n\n\tret = i2c_master_send(tsdata->client, wrbuf, sizeof(wrbuf));\n\tif (ret != sizeof(wrbuf)) {\n\t\tdev_err(&tsdata->client->dev,\n\t\t\t\"%s: i2c_master_send failed(), ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\treturn;\n\t}\n\n\tret = i2c_master_recv(tsdata->client, rdbuf, readsize);\n\tif (ret != readsize) {\n\t\tdev_err(&tsdata->client->dev,\n\t\t\t\"%s: i2c_master_recv failed(), ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\treturn;\n\t}\n\n\ttouch = rdbuf[0] & 0x7;\n\tif (touch > tsdata->chip->max_fingers)\n\t\ttouch = tsdata->chip->max_fingers;\n\n\treport->num_touches = touch;\n\tbufptr = &rdbuf[2];\n\n\tfor (i = 0; i < touch; i++) {\n\t\ttouchscreen_set_mt_pos(&report->pos[i], &tsdata->prop,\n\t\t\t\t       get_unaligned_le16(bufptr),\n\t\t\t\t       get_unaligned_le16(bufptr + 2));\n\t\tif (chip->has_hw_ids) {\n\t\t\treport->ids[i] = bufptr[4];\n\t\t\tbufptr = bufptr + 5;\n\t\t} else {\n\t\t\tbufptr = bufptr + 4;\n\t\t}\n\t}\n}\n\nstatic void pixcir_ts_report(struct pixcir_i2c_ts_data *ts,\n\t\t\t     struct pixcir_report_data *report)\n{\n\tint slots[PIXCIR_MAX_SLOTS];\n\tint n, i, slot;\n\tstruct device *dev = &ts->client->dev;\n\tconst struct pixcir_i2c_chip_data *chip = ts->chip;\n\n\tn = report->num_touches;\n\tif (n > PIXCIR_MAX_SLOTS)\n\t\tn = PIXCIR_MAX_SLOTS;\n\n\tif (!ts->chip->has_hw_ids)\n\t\tinput_mt_assign_slots(ts->input, slots, report->pos, n, 0);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (chip->has_hw_ids) {\n\t\t\tslot = input_mt_get_slot_by_key(ts->input,\n\t\t\t\t\t\t\treport->ids[i]);\n\t\t\tif (slot < 0) {\n\t\t\t\tdev_dbg(dev, \"no free slot for id 0x%x\\n\",\n\t\t\t\t\treport->ids[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tslot = slots[i];\n\t\t}\n\n\t\tinput_mt_slot(ts->input, slot);\n\t\tinput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\n\n\t\tinput_report_abs(ts->input, ABS_MT_POSITION_X,\n\t\t\t\t report->pos[i].x);\n\t\tinput_report_abs(ts->input, ABS_MT_POSITION_Y,\n\t\t\t\t report->pos[i].y);\n\n\t\tdev_dbg(dev, \"%d: slot %d, x %d, y %d\\n\",\n\t\t\ti, slot, report->pos[i].x, report->pos[i].y);\n\t}\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n}\n\nstatic irqreturn_t pixcir_ts_isr(int irq, void *dev_id)\n{\n\tstruct pixcir_i2c_ts_data *tsdata = dev_id;\n\tstruct pixcir_report_data report;\n\n\twhile (tsdata->running) {\n\t\t \n\t\tpixcir_ts_parse(tsdata, &report);\n\n\t\t \n\t\tpixcir_ts_report(tsdata, &report);\n\n\t\tif (gpiod_get_value_cansleep(tsdata->gpio_attb)) {\n\t\t\tif (report.num_touches) {\n\t\t\t\t \n\t\t\t\tinput_mt_sync_frame(tsdata->input);\n\t\t\t\tinput_sync(tsdata->input);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pixcir_reset(struct pixcir_i2c_ts_data *tsdata)\n{\n\tif (!IS_ERR_OR_NULL(tsdata->gpio_reset)) {\n\t\tgpiod_set_value_cansleep(tsdata->gpio_reset, 1);\n\t\tndelay(100);\t \n\t\tgpiod_set_value_cansleep(tsdata->gpio_reset, 0);\n\t\t \n\t\tmsleep(100);\n\t}\n}\n\nstatic int pixcir_set_power_mode(struct pixcir_i2c_ts_data *ts,\n\t\t\t\t enum pixcir_power_mode mode)\n{\n\tstruct device *dev = &ts->client->dev;\n\tint ret;\n\n\tif (mode == PIXCIR_POWER_ACTIVE || mode == PIXCIR_POWER_IDLE) {\n\t\tif (ts->gpio_wake)\n\t\t\tgpiod_set_value_cansleep(ts->gpio_wake, 1);\n\t}\n\n\tret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_POWER_MODE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: can't read reg %d : %d\\n\",\n\t\t\t__func__, PIXCIR_REG_POWER_MODE, ret);\n\t\treturn ret;\n\t}\n\n\tret &= ~PIXCIR_POWER_MODE_MASK;\n\tret |= mode;\n\n\t \n\tret |= PIXCIR_POWER_ALLOW_IDLE;\n\n\tret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_POWER_MODE, ret);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: can't write reg %d : %d\\n\",\n\t\t\t__func__, PIXCIR_REG_POWER_MODE, ret);\n\t\treturn ret;\n\t}\n\n\tif (mode == PIXCIR_POWER_HALT) {\n\t\tif (ts->gpio_wake)\n\t\t\tgpiod_set_value_cansleep(ts->gpio_wake, 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pixcir_set_int_mode(struct pixcir_i2c_ts_data *ts,\n\t\t\t       enum pixcir_int_mode mode, bool polarity)\n{\n\tstruct device *dev = &ts->client->dev;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_INT_MODE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: can't read reg %d : %d\\n\",\n\t\t\t__func__, PIXCIR_REG_INT_MODE, ret);\n\t\treturn ret;\n\t}\n\n\tret &= ~PIXCIR_INT_MODE_MASK;\n\tret |= mode;\n\n\tif (polarity)\n\t\tret |= PIXCIR_INT_POL_HIGH;\n\telse\n\t\tret &= ~PIXCIR_INT_POL_HIGH;\n\n\tret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_INT_MODE, ret);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: can't write reg %d : %d\\n\",\n\t\t\t__func__, PIXCIR_REG_INT_MODE, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pixcir_int_enable(struct pixcir_i2c_ts_data *ts, bool enable)\n{\n\tstruct device *dev = &ts->client->dev;\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_INT_MODE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: can't read reg %d : %d\\n\",\n\t\t\t__func__, PIXCIR_REG_INT_MODE, ret);\n\t\treturn ret;\n\t}\n\n\tif (enable)\n\t\tret |= PIXCIR_INT_ENABLE;\n\telse\n\t\tret &= ~PIXCIR_INT_ENABLE;\n\n\tret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_INT_MODE, ret);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: can't write reg %d : %d\\n\",\n\t\t\t__func__, PIXCIR_REG_INT_MODE, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int pixcir_start(struct pixcir_i2c_ts_data *ts)\n{\n\tstruct device *dev = &ts->client->dev;\n\tint error;\n\n\tif (ts->gpio_enable) {\n\t\tgpiod_set_value_cansleep(ts->gpio_enable, 1);\n\t\tmsleep(100);\n\t}\n\n\t \n\terror = pixcir_set_int_mode(ts, PIXCIR_INT_LEVEL_TOUCH, 0);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to set interrupt mode: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tts->running = true;\n\tmb();\t \n\n\t \n\terror = pixcir_int_enable(ts, true);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to enable interrupt generation: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int pixcir_stop(struct pixcir_i2c_ts_data *ts)\n{\n\tint error;\n\n\t \n\terror = pixcir_int_enable(ts, false);\n\tif (error) {\n\t\tdev_err(&ts->client->dev,\n\t\t\t\"Failed to disable interrupt generation: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tts->running = false;\n\tmb();\t \n\n\t \n\tsynchronize_irq(ts->client->irq);\n\n\tif (ts->gpio_enable)\n\t\tgpiod_set_value_cansleep(ts->gpio_enable, 0);\n\n\treturn 0;\n}\n\nstatic int pixcir_input_open(struct input_dev *dev)\n{\n\tstruct pixcir_i2c_ts_data *ts = input_get_drvdata(dev);\n\n\treturn pixcir_start(ts);\n}\n\nstatic void pixcir_input_close(struct input_dev *dev)\n{\n\tstruct pixcir_i2c_ts_data *ts = input_get_drvdata(dev);\n\n\tpixcir_stop(ts);\n}\n\nstatic int pixcir_i2c_ts_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pixcir_i2c_ts_data *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\tint ret = 0;\n\n\tmutex_lock(&input->mutex);\n\n\tif (device_may_wakeup(&client->dev)) {\n\t\tif (!input_device_enabled(input)) {\n\t\t\tret = pixcir_start(ts);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed to start\\n\");\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t} else if (input_device_enabled(input)) {\n\t\tret = pixcir_stop(ts);\n\t}\n\nunlock:\n\tmutex_unlock(&input->mutex);\n\n\treturn ret;\n}\n\nstatic int pixcir_i2c_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pixcir_i2c_ts_data *ts = i2c_get_clientdata(client);\n\tstruct input_dev *input = ts->input;\n\tint ret = 0;\n\n\tmutex_lock(&input->mutex);\n\n\tif (device_may_wakeup(&client->dev)) {\n\t\tif (!input_device_enabled(input)) {\n\t\t\tret = pixcir_stop(ts);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed to stop\\n\");\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t} else if (input_device_enabled(input)) {\n\t\tret = pixcir_start(ts);\n\t}\n\nunlock:\n\tmutex_unlock(&input->mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pixcir_dev_pm_ops,\n\t\t\t\tpixcir_i2c_ts_suspend, pixcir_i2c_ts_resume);\n\nstatic int pixcir_i2c_ts_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct pixcir_i2c_ts_data *tsdata;\n\tstruct input_dev *input;\n\tint error;\n\n\ttsdata = devm_kzalloc(dev, sizeof(*tsdata), GFP_KERNEL);\n\tif (!tsdata)\n\t\treturn -ENOMEM;\n\n\ttsdata->chip = device_get_match_data(dev);\n\tif (!tsdata->chip && id)\n\t\ttsdata->chip = (const void *)id->driver_data;\n\tif (!tsdata->chip) {\n\t\tdev_err(dev, \"can't locate chip data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttsdata->client = client;\n\ttsdata->input = input;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = pixcir_input_open;\n\tinput->close = pixcir_input_close;\n\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_Y);\n\ttouchscreen_parse_properties(input, true, &tsdata->prop);\n\tif (!input_abs_get_max(input, ABS_MT_POSITION_X) ||\n\t    !input_abs_get_max(input, ABS_MT_POSITION_Y)) {\n\t\tdev_err(dev, \"Touchscreen size is not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_mt_init_slots(input, tsdata->chip->max_fingers,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"Error initializing Multi-Touch slots\\n\");\n\t\treturn error;\n\t}\n\n\tinput_set_drvdata(input, tsdata);\n\n\ttsdata->gpio_attb = devm_gpiod_get(dev, \"attb\", GPIOD_IN);\n\tif (IS_ERR(tsdata->gpio_attb))\n\t\treturn dev_err_probe(dev, PTR_ERR(tsdata->gpio_attb),\n\t\t\t\t     \"Failed to request ATTB gpio\\n\");\n\n\ttsdata->gpio_reset = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(tsdata->gpio_reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(tsdata->gpio_reset),\n\t\t\t\t     \"Failed to request RESET gpio\\n\");\n\n\ttsdata->gpio_wake = devm_gpiod_get_optional(dev, \"wake\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(tsdata->gpio_wake))\n\t\treturn dev_err_probe(dev, PTR_ERR(tsdata->gpio_wake),\n\t\t\t\t     \"Failed to get wake gpio\\n\");\n\n\ttsdata->gpio_enable = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(tsdata->gpio_enable))\n\t\treturn dev_err_probe(dev, PTR_ERR(tsdata->gpio_enable),\n\t\t\t\t     \"Failed to get enable gpio\\n\");\n\n\tif (tsdata->gpio_enable)\n\t\tmsleep(100);\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, pixcir_ts_isr,\n\t\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t  client->name, tsdata);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", client->irq);\n\t\treturn error;\n\t}\n\n\tpixcir_reset(tsdata);\n\n\t \n\terror = pixcir_set_power_mode(tsdata, PIXCIR_POWER_IDLE);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to set IDLE mode\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = pixcir_stop(tsdata);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, tsdata);\n\n\treturn 0;\n}\n\nstatic const struct pixcir_i2c_chip_data pixcir_ts_data = {\n\t.max_fingers = 2,\n\t \n};\n\nstatic const struct pixcir_i2c_chip_data pixcir_tangoc_data = {\n\t.max_fingers = 5,\n\t.has_hw_ids = true,\n};\n\nstatic const struct i2c_device_id pixcir_i2c_ts_id[] = {\n\t{ \"pixcir_ts\", (unsigned long) &pixcir_ts_data },\n\t{ \"pixcir_tangoc\", (unsigned long) &pixcir_tangoc_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pixcir_i2c_ts_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pixcir_of_match[] = {\n\t{ .compatible = \"pixcir,pixcir_ts\", .data = &pixcir_ts_data },\n\t{ .compatible = \"pixcir,pixcir_tangoc\", .data = &pixcir_tangoc_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pixcir_of_match);\n#endif\n\nstatic struct i2c_driver pixcir_i2c_ts_driver = {\n\t.driver = {\n\t\t.name\t= \"pixcir_ts\",\n\t\t.pm\t= pm_sleep_ptr(&pixcir_dev_pm_ops),\n\t\t.of_match_table = of_match_ptr(pixcir_of_match),\n\t},\n\t.probe\t\t= pixcir_i2c_ts_probe,\n\t.id_table\t= pixcir_i2c_ts_id,\n};\n\nmodule_i2c_driver(pixcir_i2c_ts_driver);\n\nMODULE_AUTHOR(\"Jianchun Bian <jcbian@pixcir.com.cn>, Dequan Meng <dqmeng@pixcir.com.cn>\");\nMODULE_DESCRIPTION(\"Pixcir I2C Touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}