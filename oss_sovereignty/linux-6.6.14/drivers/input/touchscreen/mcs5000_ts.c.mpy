{
  "module_name": "mcs5000_ts.c",
  "hash_id": "5b56e115857325c932668ef094c6e2ea1852e0ac8e0166e38759fc32d070c63a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mcs5000_ts.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/irq.h>\n#include <linux/platform_data/mcs.h>\n#include <linux/slab.h>\n\n \n#define MCS5000_TS_STATUS\t\t0x00\n#define STATUS_OFFSET\t\t\t0\n#define STATUS_NO\t\t\t(0 << STATUS_OFFSET)\n#define STATUS_INIT\t\t\t(1 << STATUS_OFFSET)\n#define STATUS_SENSING\t\t\t(2 << STATUS_OFFSET)\n#define STATUS_COORD\t\t\t(3 << STATUS_OFFSET)\n#define STATUS_GESTURE\t\t\t(4 << STATUS_OFFSET)\n#define ERROR_OFFSET\t\t\t4\n#define ERROR_NO\t\t\t(0 << ERROR_OFFSET)\n#define ERROR_POWER_ON_RESET\t\t(1 << ERROR_OFFSET)\n#define ERROR_INT_RESET\t\t\t(2 << ERROR_OFFSET)\n#define ERROR_EXT_RESET\t\t\t(3 << ERROR_OFFSET)\n#define ERROR_INVALID_REG_ADDRESS\t(8 << ERROR_OFFSET)\n#define ERROR_INVALID_REG_VALUE\t\t(9 << ERROR_OFFSET)\n\n#define MCS5000_TS_OP_MODE\t\t0x01\n#define RESET_OFFSET\t\t\t0\n#define RESET_NO\t\t\t(0 << RESET_OFFSET)\n#define RESET_EXT_SOFT\t\t\t(1 << RESET_OFFSET)\n#define OP_MODE_OFFSET\t\t\t1\n#define OP_MODE_SLEEP\t\t\t(0 << OP_MODE_OFFSET)\n#define OP_MODE_ACTIVE\t\t\t(1 << OP_MODE_OFFSET)\n#define GESTURE_OFFSET\t\t\t4\n#define GESTURE_DISABLE\t\t\t(0 << GESTURE_OFFSET)\n#define GESTURE_ENABLE\t\t\t(1 << GESTURE_OFFSET)\n#define PROXIMITY_OFFSET\t\t5\n#define PROXIMITY_DISABLE\t\t(0 << PROXIMITY_OFFSET)\n#define PROXIMITY_ENABLE\t\t(1 << PROXIMITY_OFFSET)\n#define SCAN_MODE_OFFSET\t\t6\n#define SCAN_MODE_INTERRUPT\t\t(0 << SCAN_MODE_OFFSET)\n#define SCAN_MODE_POLLING\t\t(1 << SCAN_MODE_OFFSET)\n#define REPORT_RATE_OFFSET\t\t7\n#define REPORT_RATE_40\t\t\t(0 << REPORT_RATE_OFFSET)\n#define REPORT_RATE_80\t\t\t(1 << REPORT_RATE_OFFSET)\n\n#define MCS5000_TS_SENS_CTL\t\t0x02\n#define MCS5000_TS_FILTER_CTL\t\t0x03\n#define PRI_FILTER_OFFSET\t\t0\n#define SEC_FILTER_OFFSET\t\t4\n\n#define MCS5000_TS_X_SIZE_UPPER\t\t0x08\n#define MCS5000_TS_X_SIZE_LOWER\t\t0x09\n#define MCS5000_TS_Y_SIZE_UPPER\t\t0x0A\n#define MCS5000_TS_Y_SIZE_LOWER\t\t0x0B\n\n#define MCS5000_TS_INPUT_INFO\t\t0x10\n#define INPUT_TYPE_OFFSET\t\t0\n#define INPUT_TYPE_NONTOUCH\t\t(0 << INPUT_TYPE_OFFSET)\n#define INPUT_TYPE_SINGLE\t\t(1 << INPUT_TYPE_OFFSET)\n#define INPUT_TYPE_DUAL\t\t\t(2 << INPUT_TYPE_OFFSET)\n#define INPUT_TYPE_PALM\t\t\t(3 << INPUT_TYPE_OFFSET)\n#define INPUT_TYPE_PROXIMITY\t\t(7 << INPUT_TYPE_OFFSET)\n#define GESTURE_CODE_OFFSET\t\t3\n#define GESTURE_CODE_NO\t\t\t(0 << GESTURE_CODE_OFFSET)\n\n#define MCS5000_TS_X_POS_UPPER\t\t0x11\n#define MCS5000_TS_X_POS_LOWER\t\t0x12\n#define MCS5000_TS_Y_POS_UPPER\t\t0x13\n#define MCS5000_TS_Y_POS_LOWER\t\t0x14\n#define MCS5000_TS_Z_POS\t\t0x15\n#define MCS5000_TS_WIDTH\t\t0x16\n#define MCS5000_TS_GESTURE_VAL\t\t0x17\n#define MCS5000_TS_MODULE_REV\t\t0x20\n#define MCS5000_TS_FIRMWARE_VER\t\t0x21\n\n \n#define MCS5000_MAX_XC\t\t\t0x3ff\n#define MCS5000_MAX_YC\t\t\t0x3ff\n\nenum mcs5000_ts_read_offset {\n\tREAD_INPUT_INFO,\n\tREAD_X_POS_UPPER,\n\tREAD_X_POS_LOWER,\n\tREAD_Y_POS_UPPER,\n\tREAD_Y_POS_LOWER,\n\tREAD_BLOCK_SIZE,\n};\n\n \nstruct mcs5000_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input_dev;\n\tconst struct mcs_platform_data *platform_data;\n};\n\nstatic irqreturn_t mcs5000_ts_interrupt(int irq, void *dev_id)\n{\n\tstruct mcs5000_ts_data *data = dev_id;\n\tstruct i2c_client *client = data->client;\n\tu8 buffer[READ_BLOCK_SIZE];\n\tint err;\n\tint x;\n\tint y;\n\n\terr = i2c_smbus_read_i2c_block_data(client, MCS5000_TS_INPUT_INFO,\n\t\t\tREAD_BLOCK_SIZE, buffer);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"%s, err[%d]\\n\", __func__, err);\n\t\tgoto out;\n\t}\n\n\tswitch (buffer[READ_INPUT_INFO]) {\n\tcase INPUT_TYPE_NONTOUCH:\n\t\tinput_report_key(data->input_dev, BTN_TOUCH, 0);\n\t\tinput_sync(data->input_dev);\n\t\tbreak;\n\n\tcase INPUT_TYPE_SINGLE:\n\t\tx = (buffer[READ_X_POS_UPPER] << 8) | buffer[READ_X_POS_LOWER];\n\t\ty = (buffer[READ_Y_POS_UPPER] << 8) | buffer[READ_Y_POS_LOWER];\n\n\t\tinput_report_key(data->input_dev, BTN_TOUCH, 1);\n\t\tinput_report_abs(data->input_dev, ABS_X, x);\n\t\tinput_report_abs(data->input_dev, ABS_Y, y);\n\t\tinput_sync(data->input_dev);\n\t\tbreak;\n\n\tcase INPUT_TYPE_DUAL:\n\t\t \n\t\tbreak;\n\n\tcase INPUT_TYPE_PALM:\n\t\t \n\t\tbreak;\n\n\tcase INPUT_TYPE_PROXIMITY:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&client->dev, \"Unknown ts input type %d\\n\",\n\t\t\t\tbuffer[READ_INPUT_INFO]);\n\t\tbreak;\n\t}\n\n out:\n\treturn IRQ_HANDLED;\n}\n\nstatic void mcs5000_ts_phys_init(struct mcs5000_ts_data *data,\n\t\t\t\t const struct mcs_platform_data *platform_data)\n{\n\tstruct i2c_client *client = data->client;\n\n\t \n\ti2c_smbus_write_byte_data(client, MCS5000_TS_OP_MODE,\n\t\t\tRESET_EXT_SOFT | OP_MODE_SLEEP);\n\n\t \n\ti2c_smbus_write_byte_data(client, MCS5000_TS_X_SIZE_UPPER,\n\t\t\tplatform_data->x_size >> 8);\n\ti2c_smbus_write_byte_data(client, MCS5000_TS_X_SIZE_LOWER,\n\t\t\tplatform_data->x_size & 0xff);\n\ti2c_smbus_write_byte_data(client, MCS5000_TS_Y_SIZE_UPPER,\n\t\t\tplatform_data->y_size >> 8);\n\ti2c_smbus_write_byte_data(client, MCS5000_TS_Y_SIZE_LOWER,\n\t\t\tplatform_data->y_size & 0xff);\n\n\t \n\ti2c_smbus_write_byte_data(data->client, MCS5000_TS_OP_MODE,\n\t\t\tOP_MODE_ACTIVE | REPORT_RATE_80);\n}\n\nstatic int mcs5000_ts_probe(struct i2c_client *client)\n{\n\tconst struct mcs_platform_data *pdata;\n\tstruct mcs5000_ts_data *data;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tdev_err(&client->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->client = client;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev->name = \"MELFAS MCS-5000 Touchscreen\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->dev.parent = &client->dev;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\tinput_set_abs_params(input_dev, ABS_X, 0, MCS5000_MAX_XC, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MCS5000_MAX_YC, 0, 0);\n\n\tdata->input_dev = input_dev;\n\n\tif (pdata->cfg_pin)\n\t\tpdata->cfg_pin();\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, mcs5000_ts_interrupt,\n\t\t\t\t\t  IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t  \"mcs5000_ts\", data);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(data->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\tmcs5000_ts_phys_init(data, pdata);\n\ti2c_set_clientdata(client, data);\n\n\treturn 0;\n}\n\nstatic int mcs5000_ts_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\t \n\ti2c_smbus_write_byte_data(client, MCS5000_TS_OP_MODE, OP_MODE_SLEEP);\n\n\treturn 0;\n}\n\nstatic int mcs5000_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mcs5000_ts_data *data = i2c_get_clientdata(client);\n\tconst struct mcs_platform_data *pdata = dev_get_platdata(dev);\n\n\tmcs5000_ts_phys_init(data, pdata);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mcs5000_ts_pm,\n\t\t\t\tmcs5000_ts_suspend, mcs5000_ts_resume);\n\nstatic const struct i2c_device_id mcs5000_ts_id[] = {\n\t{ \"mcs5000_ts\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mcs5000_ts_id);\n\nstatic struct i2c_driver mcs5000_ts_driver = {\n\t.probe\t\t= mcs5000_ts_probe,\n\t.driver = {\n\t\t.name = \"mcs5000_ts\",\n\t\t.pm   = pm_sleep_ptr(&mcs5000_ts_pm),\n\t},\n\t.id_table\t= mcs5000_ts_id,\n};\n\nmodule_i2c_driver(mcs5000_ts_driver);\n\n \nMODULE_AUTHOR(\"Joonyoung Shim <jy0922.shim@samsung.com>\");\nMODULE_DESCRIPTION(\"Touchscreen driver for MELFAS MCS-5000 controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}