{
  "module_name": "elo.c",
  "hash_id": "a27af3bd5261990af63539586a902ff4b21574eada7a94bea43f00bad889052e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/elo.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/ctype.h>\n\n#define DRIVER_DESC\t\"Elo serial touchscreen driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define ELO_MAX_LENGTH\t\t10\n\n#define ELO10_PACKET_LEN\t8\n#define ELO10_TOUCH\t\t0x03\n#define ELO10_PRESSURE\t\t0x80\n\n#define ELO10_LEAD_BYTE\t\t'U'\n\n#define ELO10_ID_CMD\t\t'i'\n\n#define ELO10_TOUCH_PACKET\t'T'\n#define ELO10_ACK_PACKET\t'A'\n#define ELI10_ID_PACKET\t\t'I'\n\n \n\nstruct elo {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tstruct mutex cmd_mutex;\n\tstruct completion cmd_done;\n\tint id;\n\tint idx;\n\tunsigned char expected_packet;\n\tunsigned char csum;\n\tunsigned char data[ELO_MAX_LENGTH];\n\tunsigned char response[ELO10_PACKET_LEN];\n\tchar phys[32];\n};\n\nstatic void elo_process_data_10(struct elo *elo, unsigned char data)\n{\n\tstruct input_dev *dev = elo->dev;\n\n\telo->data[elo->idx] = data;\n\n\tswitch (elo->idx++) {\n\tcase 0:\n\t\telo->csum = 0xaa;\n\t\tif (data != ELO10_LEAD_BYTE) {\n\t\t\tdev_dbg(&elo->serio->dev,\n\t\t\t\t\"unsynchronized data: 0x%02x\\n\", data);\n\t\t\telo->idx = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 9:\n\t\telo->idx = 0;\n\t\tif (data != elo->csum) {\n\t\t\tdev_dbg(&elo->serio->dev,\n\t\t\t\t\"bad checksum: 0x%02x, expected 0x%02x\\n\",\n\t\t\t\t data, elo->csum);\n\t\t\tbreak;\n\t\t}\n\t\tif (elo->data[1] != elo->expected_packet) {\n\t\t\tif (elo->data[1] != ELO10_TOUCH_PACKET)\n\t\t\t\tdev_dbg(&elo->serio->dev,\n\t\t\t\t\t\"unexpected packet: 0x%02x\\n\",\n\t\t\t\t\t elo->data[1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(elo->data[1] == ELO10_TOUCH_PACKET)) {\n\t\t\tinput_report_abs(dev, ABS_X, (elo->data[4] << 8) | elo->data[3]);\n\t\t\tinput_report_abs(dev, ABS_Y, (elo->data[6] << 8) | elo->data[5]);\n\t\t\tif (elo->data[2] & ELO10_PRESSURE)\n\t\t\t\tinput_report_abs(dev, ABS_PRESSURE,\n\t\t\t\t\t\t(elo->data[8] << 8) | elo->data[7]);\n\t\t\tinput_report_key(dev, BTN_TOUCH, elo->data[2] & ELO10_TOUCH);\n\t\t\tinput_sync(dev);\n\t\t} else if (elo->data[1] == ELO10_ACK_PACKET) {\n\t\t\tif (elo->data[2] == '0')\n\t\t\t\telo->expected_packet = ELO10_TOUCH_PACKET;\n\t\t\tcomplete(&elo->cmd_done);\n\t\t} else {\n\t\t\tmemcpy(elo->response, &elo->data[1], ELO10_PACKET_LEN);\n\t\t\telo->expected_packet = ELO10_ACK_PACKET;\n\t\t}\n\t\tbreak;\n\t}\n\telo->csum += data;\n}\n\nstatic void elo_process_data_6(struct elo *elo, unsigned char data)\n{\n\tstruct input_dev *dev = elo->dev;\n\n\telo->data[elo->idx] = data;\n\n\tswitch (elo->idx++) {\n\n\tcase 0:\n\t\tif ((data & 0xc0) != 0xc0)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\n\tcase 1:\n\t\tif ((data & 0xc0) != 0x80)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\n\tcase 2:\n\t\tif ((data & 0xc0) != 0x40)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tif (data & 0xc0) {\n\t\t\telo->idx = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tinput_report_abs(dev, ABS_X, ((elo->data[0] & 0x3f) << 6) | (elo->data[1] & 0x3f));\n\t\tinput_report_abs(dev, ABS_Y, ((elo->data[2] & 0x3f) << 6) | (elo->data[3] & 0x3f));\n\n\t\tif (elo->id == 2) {\n\t\t\tinput_report_key(dev, BTN_TOUCH, 1);\n\t\t\tinput_sync(dev);\n\t\t\telo->idx = 0;\n\t\t}\n\n\t\tbreak;\n\n\tcase 4:\n\t\tif (data) {\n\t\t\tinput_sync(dev);\n\t\t\telo->idx = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 5:\n\t\tif ((data & 0xf0) == 0) {\n\t\t\tinput_report_abs(dev, ABS_PRESSURE, elo->data[5]);\n\t\t\tinput_report_key(dev, BTN_TOUCH, !!elo->data[5]);\n\t\t}\n\t\tinput_sync(dev);\n\t\telo->idx = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void elo_process_data_3(struct elo *elo, unsigned char data)\n{\n\tstruct input_dev *dev = elo->dev;\n\n\telo->data[elo->idx] = data;\n\n\tswitch (elo->idx++) {\n\n\tcase 0:\n\t\tif ((data & 0x7f) != 0x01)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\tcase 2:\n\t\tinput_report_key(dev, BTN_TOUCH, !(elo->data[1] & 0x80));\n\t\tinput_report_abs(dev, ABS_X, elo->data[1]);\n\t\tinput_report_abs(dev, ABS_Y, elo->data[2]);\n\t\tinput_sync(dev);\n\t\telo->idx = 0;\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t elo_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct elo *elo = serio_get_drvdata(serio);\n\n\tswitch (elo->id) {\n\tcase 0:\n\t\telo_process_data_10(elo, data);\n\t\tbreak;\n\n\tcase 1:\n\tcase 2:\n\t\telo_process_data_6(elo, data);\n\t\tbreak;\n\n\tcase 3:\n\t\telo_process_data_3(elo, data);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int elo_command_10(struct elo *elo, unsigned char *packet)\n{\n\tint rc = -1;\n\tint i;\n\tunsigned char csum = 0xaa + ELO10_LEAD_BYTE;\n\n\tmutex_lock(&elo->cmd_mutex);\n\n\tserio_pause_rx(elo->serio);\n\telo->expected_packet = toupper(packet[0]);\n\tinit_completion(&elo->cmd_done);\n\tserio_continue_rx(elo->serio);\n\n\tif (serio_write(elo->serio, ELO10_LEAD_BYTE))\n\t\tgoto out;\n\n\tfor (i = 0; i < ELO10_PACKET_LEN; i++) {\n\t\tcsum += packet[i];\n\t\tif (serio_write(elo->serio, packet[i]))\n\t\t\tgoto out;\n\t}\n\n\tif (serio_write(elo->serio, csum))\n\t\tgoto out;\n\n\twait_for_completion_timeout(&elo->cmd_done, HZ);\n\n\tif (elo->expected_packet == ELO10_TOUCH_PACKET) {\n\t\t \n\t\tmemcpy(packet, elo->response, ELO10_PACKET_LEN);\n\t\trc = 0;\n\t}\n\n out:\n\tmutex_unlock(&elo->cmd_mutex);\n\treturn rc;\n}\n\nstatic int elo_setup_10(struct elo *elo)\n{\n\tstatic const char *elo_types[] = { \"Accu\", \"Dura\", \"Intelli\", \"Carroll\" };\n\tstruct input_dev *dev = elo->dev;\n\tunsigned char packet[ELO10_PACKET_LEN] = { ELO10_ID_CMD };\n\n\tif (elo_command_10(elo, packet))\n\t\treturn -1;\n\n\tdev->id.version = (packet[5] << 8) | packet[4];\n\n\tinput_set_abs_params(dev, ABS_X, 96, 4000, 0, 0);\n\tinput_set_abs_params(dev, ABS_Y, 96, 4000, 0, 0);\n\tif (packet[3] & ELO10_PRESSURE)\n\t\tinput_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);\n\n\tdev_info(&elo->serio->dev,\n\t\t \"%sTouch touchscreen, fw: %02x.%02x, features: 0x%02x, controller: 0x%02x\\n\",\n\t\t elo_types[(packet[1] -'0') & 0x03],\n\t\t packet[5], packet[4], packet[3], packet[7]);\n\n\treturn 0;\n}\n\n \n\nstatic void elo_disconnect(struct serio *serio)\n{\n\tstruct elo *elo = serio_get_drvdata(serio);\n\n\tinput_get_device(elo->dev);\n\tinput_unregister_device(elo->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_put_device(elo->dev);\n\tkfree(elo);\n}\n\n \n\nstatic int elo_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct elo *elo;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\telo = kzalloc(sizeof(struct elo), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!elo || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\telo->serio = serio;\n\telo->id = serio->id.id;\n\telo->dev = input_dev;\n\telo->expected_packet = ELO10_TOUCH_PACKET;\n\tmutex_init(&elo->cmd_mutex);\n\tinit_completion(&elo->cmd_done);\n\tsnprintf(elo->phys, sizeof(elo->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"Elo Serial TouchScreen\";\n\tinput_dev->phys = elo->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_ELO;\n\tinput_dev->id.product = elo->id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tserio_set_drvdata(serio, elo);\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\tswitch (elo->id) {\n\n\tcase 0:  \n\t\tif (elo_setup_10(elo)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail3;\n\t\t}\n\n\t\tbreak;\n\n\tcase 1:  \n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 15, 0, 0);\n\t\tfallthrough;\n\n\tcase 2:  \n\t\tinput_set_abs_params(input_dev, ABS_X, 96, 4000, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, 96, 4000, 0, 0);\n\t\tbreak;\n\n\tcase 3:  \n\t\tinput_set_abs_params(input_dev, ABS_X, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, 0, 255, 0, 0);\n\t\tbreak;\n\t}\n\n\terr = input_register_device(elo->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3: serio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(elo);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id elo_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_ELO,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, elo_serio_ids);\n\nstatic struct serio_driver elo_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"elo\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= elo_serio_ids,\n\t.interrupt\t= elo_interrupt,\n\t.connect\t= elo_connect,\n\t.disconnect\t= elo_disconnect,\n};\n\nmodule_serio_driver(elo_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}