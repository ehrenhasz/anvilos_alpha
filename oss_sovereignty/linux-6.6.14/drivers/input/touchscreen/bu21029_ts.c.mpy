{
  "module_name": "bu21029_ts.c",
  "hash_id": "b80d1b5c39736042efc65ae8b859713d7fe6f6b0c13d00a7df3dccc6c38aa1e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/bu21029_ts.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/timer.h>\n\n \n#define BU21029_HWID_REG\t(0x0E << 3)\n#define SUPPORTED_HWID\t\t0x0229\n\n \n#define BU21029_CFR0_REG\t(0x00 << 3)\n#define CFR0_VALUE\t\t0x00\n\n \n#define BU21029_CFR1_REG\t(0x01 << 3)\n#define CFR1_VALUE\t\t0xA6\n\n \n#define BU21029_CFR2_REG\t(0x02 << 3)\n#define CFR2_VALUE\t\t0xC9\n\n \n#define BU21029_CFR3_REG\t(0x0B << 3)\n#define CFR3_VALUE\t\t0x42\n\n \n#define BU21029_LDO_REG\t\t(0x0C << 3)\n#define LDO_VALUE\t\t0x77\n\n \n#define BU21029_AUTOSCAN\t0x80\n\n \n#define PEN_UP_TIMEOUT_MS\t50\n\n#define STOP_DELAY_MIN_US\t50\n#define STOP_DELAY_MAX_US\t1000\n#define START_DELAY_MS\t\t2\n#define BUF_LEN\t\t\t8\n#define SCALE_12BIT\t\t(1 << 12)\n#define MAX_12BIT\t\t((1 << 12) - 1)\n#define DRIVER_NAME\t\t\"bu21029\"\n\nstruct bu21029_ts_data {\n\tstruct i2c_client\t\t*client;\n\tstruct input_dev\t\t*in_dev;\n\tstruct timer_list\t\ttimer;\n\tstruct regulator\t\t*vdd;\n\tstruct gpio_desc\t\t*reset_gpios;\n\tu32\t\t\t\tx_plate_ohms;\n\tstruct touchscreen_properties\tprop;\n};\n\nstatic void bu21029_touch_report(struct bu21029_ts_data *bu21029, const u8 *buf)\n{\n\tu16 x, y, z1, z2;\n\tu32 rz;\n\ts32 max_pressure = input_abs_get_max(bu21029->in_dev, ABS_PRESSURE);\n\n\t \n\tx  = (buf[0] << 4) | (buf[1] >> 4);\n\ty  = (buf[2] << 4) | (buf[3] >> 4);\n\tz1 = (buf[4] << 4) | (buf[5] >> 4);\n\tz2 = (buf[6] << 4) | (buf[7] >> 4);\n\n\tif (z1 && z2) {\n\t\t \n\t\trz  = z2 - z1;\n\t\trz *= x;\n\t\trz *= bu21029->x_plate_ohms;\n\t\trz /= z1;\n\t\trz  = DIV_ROUND_CLOSEST(rz, SCALE_12BIT);\n\t\tif (rz <= max_pressure) {\n\t\t\ttouchscreen_report_pos(bu21029->in_dev, &bu21029->prop,\n\t\t\t\t\t       x, y, false);\n\t\t\tinput_report_abs(bu21029->in_dev, ABS_PRESSURE,\n\t\t\t\t\t max_pressure - rz);\n\t\t\tinput_report_key(bu21029->in_dev, BTN_TOUCH, 1);\n\t\t\tinput_sync(bu21029->in_dev);\n\t\t}\n\t}\n}\n\nstatic void bu21029_touch_release(struct timer_list *t)\n{\n\tstruct bu21029_ts_data *bu21029 = from_timer(bu21029, t, timer);\n\n\tinput_report_abs(bu21029->in_dev, ABS_PRESSURE, 0);\n\tinput_report_key(bu21029->in_dev, BTN_TOUCH, 0);\n\tinput_sync(bu21029->in_dev);\n}\n\nstatic irqreturn_t bu21029_touch_soft_irq(int irq, void *data)\n{\n\tstruct bu21029_ts_data *bu21029 = data;\n\tu8 buf[BUF_LEN];\n\tint error;\n\n\t \n\terror = i2c_smbus_read_i2c_block_data(bu21029->client, BU21029_AUTOSCAN,\n\t\t\t\t\t      sizeof(buf), buf);\n\tif (error < 0)\n\t\tgoto out;\n\n\tbu21029_touch_report(bu21029, buf);\n\n\t \n\tmod_timer(&bu21029->timer,\n\t\t  jiffies + msecs_to_jiffies(PEN_UP_TIMEOUT_MS));\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic void bu21029_put_chip_in_reset(struct bu21029_ts_data *bu21029)\n{\n\tif (bu21029->reset_gpios) {\n\t\tgpiod_set_value_cansleep(bu21029->reset_gpios, 1);\n\t\tusleep_range(STOP_DELAY_MIN_US, STOP_DELAY_MAX_US);\n\t}\n}\n\nstatic int bu21029_start_chip(struct input_dev *dev)\n{\n\tstruct bu21029_ts_data *bu21029 = input_get_drvdata(dev);\n\tstruct i2c_client *i2c = bu21029->client;\n\tstruct {\n\t\tu8 reg;\n\t\tu8 value;\n\t} init_table[] = {\n\t\t{BU21029_CFR0_REG, CFR0_VALUE},\n\t\t{BU21029_CFR1_REG, CFR1_VALUE},\n\t\t{BU21029_CFR2_REG, CFR2_VALUE},\n\t\t{BU21029_CFR3_REG, CFR3_VALUE},\n\t\t{BU21029_LDO_REG,  LDO_VALUE}\n\t};\n\tint error, i;\n\t__be16 hwid;\n\n\terror = regulator_enable(bu21029->vdd);\n\tif (error) {\n\t\tdev_err(&i2c->dev, \"failed to power up chip: %d\", error);\n\t\treturn error;\n\t}\n\n\t \n\tif (bu21029->reset_gpios) {\n\t\tgpiod_set_value_cansleep(bu21029->reset_gpios, 0);\n\t\tmsleep(START_DELAY_MS);\n\t}\n\n\terror = i2c_smbus_read_i2c_block_data(i2c, BU21029_HWID_REG,\n\t\t\t\t\t      sizeof(hwid), (u8 *)&hwid);\n\tif (error < 0) {\n\t\tdev_err(&i2c->dev, \"failed to read HW ID\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (be16_to_cpu(hwid) != SUPPORTED_HWID) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"unsupported HW ID 0x%x\\n\", be16_to_cpu(hwid));\n\t\terror = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(init_table); ++i) {\n\t\terror = i2c_smbus_write_byte_data(i2c,\n\t\t\t\t\t\t  init_table[i].reg,\n\t\t\t\t\t\t  init_table[i].value);\n\t\tif (error < 0) {\n\t\t\tdev_err(&i2c->dev,\n\t\t\t\t\"failed to write %#02x to register %#02x: %d\\n\",\n\t\t\t\tinit_table[i].value, init_table[i].reg,\n\t\t\t\terror);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\terror = i2c_smbus_write_byte(i2c, BU21029_AUTOSCAN);\n\tif (error < 0) {\n\t\tdev_err(&i2c->dev, \"failed to start autoscan\\n\");\n\t\tgoto err_out;\n\t}\n\n\tenable_irq(bu21029->client->irq);\n\treturn 0;\n\nerr_out:\n\tbu21029_put_chip_in_reset(bu21029);\n\tregulator_disable(bu21029->vdd);\n\treturn error;\n}\n\nstatic void bu21029_stop_chip(struct input_dev *dev)\n{\n\tstruct bu21029_ts_data *bu21029 = input_get_drvdata(dev);\n\n\tdisable_irq(bu21029->client->irq);\n\tdel_timer_sync(&bu21029->timer);\n\n\tbu21029_put_chip_in_reset(bu21029);\n\tregulator_disable(bu21029->vdd);\n}\n\nstatic int bu21029_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct bu21029_ts_data *bu21029;\n\tstruct input_dev *in_dev;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\n\t\tdev_err(dev, \"i2c functionality support is not sufficient\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbu21029 = devm_kzalloc(dev, sizeof(*bu21029), GFP_KERNEL);\n\tif (!bu21029)\n\t\treturn -ENOMEM;\n\n\terror = device_property_read_u32(dev, \"rohm,x-plate-ohms\", &bu21029->x_plate_ohms);\n\tif (error) {\n\t\tdev_err(dev, \"invalid 'x-plate-ohms' supplied: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tbu21029->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(bu21029->vdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(bu21029->vdd),\n\t\t\t\t     \"failed to acquire 'vdd' supply\\n\");\n\n\tbu21029->reset_gpios = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(bu21029->reset_gpios))\n\t\treturn dev_err_probe(dev, PTR_ERR(bu21029->reset_gpios),\n\t\t\t\t     \"failed to acquire 'reset' gpio\\n\");\n\n\tin_dev = devm_input_allocate_device(dev);\n\tif (!in_dev) {\n\t\tdev_err(dev, \"unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbu21029->client = client;\n\tbu21029->in_dev = in_dev;\n\ttimer_setup(&bu21029->timer, bu21029_touch_release, 0);\n\n\tin_dev->name\t\t= DRIVER_NAME;\n\tin_dev->id.bustype\t= BUS_I2C;\n\tin_dev->open\t\t= bu21029_start_chip;\n\tin_dev->close\t\t= bu21029_stop_chip;\n\n\tinput_set_capability(in_dev, EV_KEY, BTN_TOUCH);\n\tinput_set_abs_params(in_dev, ABS_X, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(in_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\n\tinput_set_abs_params(in_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);\n\ttouchscreen_parse_properties(in_dev, false, &bu21029->prop);\n\n\tinput_set_drvdata(in_dev, bu21029);\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t  bu21029_touch_soft_irq,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t  DRIVER_NAME, bu21029);\n\tif (error) {\n\t\tdev_err(dev, \"unable to request touch irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(in_dev);\n\tif (error) {\n\t\tdev_err(dev, \"unable to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, bu21029);\n\n\treturn 0;\n}\n\nstatic int bu21029_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct bu21029_ts_data *bu21029 = i2c_get_clientdata(i2c);\n\n\tif (!device_may_wakeup(dev)) {\n\t\tmutex_lock(&bu21029->in_dev->mutex);\n\t\tif (input_device_enabled(bu21029->in_dev))\n\t\t\tbu21029_stop_chip(bu21029->in_dev);\n\t\tmutex_unlock(&bu21029->in_dev->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic int bu21029_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct bu21029_ts_data *bu21029 = i2c_get_clientdata(i2c);\n\n\tif (!device_may_wakeup(dev)) {\n\t\tmutex_lock(&bu21029->in_dev->mutex);\n\t\tif (input_device_enabled(bu21029->in_dev))\n\t\t\tbu21029_start_chip(bu21029->in_dev);\n\t\tmutex_unlock(&bu21029->in_dev->mutex);\n\t}\n\n\treturn 0;\n}\nstatic DEFINE_SIMPLE_DEV_PM_OPS(bu21029_pm_ops, bu21029_suspend, bu21029_resume);\n\nstatic const struct i2c_device_id bu21029_ids[] = {\n\t{ DRIVER_NAME, 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, bu21029_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id bu21029_of_ids[] = {\n\t{ .compatible = \"rohm,bu21029\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bu21029_of_ids);\n#endif\n\nstatic struct i2c_driver bu21029_driver = {\n\t.driver\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= of_match_ptr(bu21029_of_ids),\n\t\t.pm\t\t= pm_sleep_ptr(&bu21029_pm_ops),\n\t},\n\t.id_table\t= bu21029_ids,\n\t.probe\t\t= bu21029_probe,\n};\nmodule_i2c_driver(bu21029_driver);\n\nMODULE_AUTHOR(\"Zhu Yi <yi.zhu5@cn.bosch.com>\");\nMODULE_DESCRIPTION(\"Rohm BU21029 touchscreen controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}