{
  "module_name": "mk712.c",
  "hash_id": "8707255c4e0690555d3578ae816c0f1ff2c4f30fe1f125b5a007ae67c47bd589",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mk712.c",
  "human_readable_source": "\n \n\n\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <asm/io.h>\n\nMODULE_AUTHOR(\"Daniel Quinlan <quinlan@pathname.com>, Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"ICS MicroClock MK712 TouchScreen driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int mk712_io = 0x260;\t \nmodule_param_hw_named(io, mk712_io, uint, ioport, 0);\nMODULE_PARM_DESC(io, \"I/O base address of MK712 touchscreen controller\");\n\nstatic unsigned int mk712_irq = 10;\t \nmodule_param_hw_named(irq, mk712_irq, uint, irq, 0);\nMODULE_PARM_DESC(irq, \"IRQ of MK712 touchscreen controller\");\n\n \n#define MK712_STATUS\t\t0\n#define MK712_X\t\t\t2\n#define MK712_Y\t\t\t4\n#define MK712_CONTROL\t\t6\n#define MK712_RATE\t\t7\n\n \n#define\tMK712_STATUS_TOUCH\t\t\t0x10\n#define\tMK712_CONVERSION_COMPLETE\t\t0x80\n\n \n#define MK712_ENABLE_INT\t\t\t0x01\n#define MK712_INT_ON_CONVERSION_COMPLETE\t0x02\n#define MK712_INT_ON_CHANGE_IN_TOUCH_STATUS\t0x04\n#define MK712_ENABLE_PERIODIC_CONVERSIONS\t0x10\n#define MK712_READ_ONE_POINT\t\t\t0x20\n#define MK712_POWERUP\t\t\t\t0x40\n\nstatic struct input_dev *mk712_dev;\nstatic DEFINE_SPINLOCK(mk712_lock);\n\nstatic irqreturn_t mk712_interrupt(int irq, void *dev_id)\n{\n\tunsigned char status;\n\tstatic int debounce = 1;\n\tstatic unsigned short last_x;\n\tstatic unsigned short last_y;\n\n\tspin_lock(&mk712_lock);\n\n\tstatus = inb(mk712_io + MK712_STATUS);\n\n\tif (~status & MK712_CONVERSION_COMPLETE) {\n\t\tdebounce = 1;\n\t\tgoto end;\n\t}\n\n\tif (~status & MK712_STATUS_TOUCH) {\n\t\tdebounce = 1;\n\t\tinput_report_key(mk712_dev, BTN_TOUCH, 0);\n\t\tgoto end;\n\t}\n\n\tif (debounce) {\n\t\tdebounce = 0;\n\t\tgoto end;\n\t}\n\n\tinput_report_key(mk712_dev, BTN_TOUCH, 1);\n\tinput_report_abs(mk712_dev, ABS_X, last_x);\n\tinput_report_abs(mk712_dev, ABS_Y, last_y);\n\n end:\n\tlast_x = inw(mk712_io + MK712_X) & 0x0fff;\n\tlast_y = inw(mk712_io + MK712_Y) & 0x0fff;\n\tinput_sync(mk712_dev);\n\tspin_unlock(&mk712_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mk712_open(struct input_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mk712_lock, flags);\n\n\toutb(0, mk712_io + MK712_CONTROL);  \n\n\toutb(MK712_ENABLE_INT | MK712_INT_ON_CONVERSION_COMPLETE |\n\t\tMK712_INT_ON_CHANGE_IN_TOUCH_STATUS |\n\t\tMK712_ENABLE_PERIODIC_CONVERSIONS |\n\t\tMK712_POWERUP, mk712_io + MK712_CONTROL);\n\n\toutb(10, mk712_io + MK712_RATE);  \n\n\tspin_unlock_irqrestore(&mk712_lock, flags);\n\n\treturn 0;\n}\n\nstatic void mk712_close(struct input_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mk712_lock, flags);\n\n\toutb(0, mk712_io + MK712_CONTROL);\n\n\tspin_unlock_irqrestore(&mk712_lock, flags);\n}\n\nstatic int __init mk712_init(void)\n{\n\tint err;\n\n\tif (!request_region(mk712_io, 8, \"mk712\")) {\n\t\tprintk(KERN_WARNING \"mk712: unable to get IO region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\toutb(0, mk712_io + MK712_CONTROL);\n\n\tif ((inw(mk712_io + MK712_X) & 0xf000) ||\t \n\t    (inw(mk712_io + MK712_Y) & 0xf000) ||\n\t    (inw(mk712_io + MK712_STATUS) & 0xf333)) {\n\t\tprintk(KERN_WARNING \"mk712: device not present\\n\");\n\t\terr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\tmk712_dev = input_allocate_device();\n\tif (!mk712_dev) {\n\t\tprintk(KERN_ERR \"mk712: not enough memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tmk712_dev->name = \"ICS MicroClock MK712 TouchScreen\";\n\tmk712_dev->phys = \"isa0260/input0\";\n\tmk712_dev->id.bustype = BUS_ISA;\n\tmk712_dev->id.vendor  = 0x0005;\n\tmk712_dev->id.product = 0x0001;\n\tmk712_dev->id.version = 0x0100;\n\n\tmk712_dev->open    = mk712_open;\n\tmk712_dev->close   = mk712_close;\n\n\tmk712_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tmk712_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(mk712_dev, ABS_X, 0, 0xfff, 88, 0);\n\tinput_set_abs_params(mk712_dev, ABS_Y, 0, 0xfff, 88, 0);\n\n\tif (request_irq(mk712_irq, mk712_interrupt, 0, \"mk712\", mk712_dev)) {\n\t\tprintk(KERN_WARNING \"mk712: unable to get IRQ\\n\");\n\t\terr = -EBUSY;\n\t\tgoto fail1;\n\t}\n\n\terr = input_register_device(mk712_dev);\n\tif (err)\n\t\tgoto fail2;\n\n\treturn 0;\n\n fail2:\tfree_irq(mk712_irq, mk712_dev);\n fail1:\tinput_free_device(mk712_dev);\n\trelease_region(mk712_io, 8);\n\treturn err;\n}\n\nstatic void __exit mk712_exit(void)\n{\n\tinput_unregister_device(mk712_dev);\n\tfree_irq(mk712_irq, mk712_dev);\n\trelease_region(mk712_io, 8);\n}\n\nmodule_init(mk712_init);\nmodule_exit(mk712_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}