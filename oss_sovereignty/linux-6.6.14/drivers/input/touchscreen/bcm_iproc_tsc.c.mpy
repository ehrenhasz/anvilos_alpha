{
  "module_name": "bcm_iproc_tsc.c",
  "hash_id": "92029d0066cb0ec4891bc94defc0a710f4275d9f71cc1cb08df602f7b05656ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/bcm_iproc_tsc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/keyboard.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <asm/irq.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/serio.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#define IPROC_TS_NAME \"iproc-ts\"\n\n#define PEN_DOWN_STATUS     1\n#define PEN_UP_STATUS       0\n\n#define X_MIN               0\n#define Y_MIN               0\n#define X_MAX               0xFFF\n#define Y_MAX               0xFFF\n\n \n#define INVALID_COORD       0xFFFFFFFF\n\n \n#define REGCTL1             0x00\n#define REGCTL2             0x04\n#define INTERRUPT_THRES     0x08\n#define INTERRUPT_MASK      0x0c\n\n#define INTERRUPT_STATUS    0x10\n#define CONTROLLER_STATUS   0x14\n#define FIFO_DATA           0x18\n#define FIFO_DATA_X_Y_MASK  0xFFFF\n#define ANALOG_CONTROL      0x1c\n\n#define AUX_DATA            0x20\n#define DEBOUNCE_CNTR_STAT  0x24\n#define SCAN_CNTR_STAT      0x28\n#define REM_CNTR_STAT       0x2c\n\n#define SETTLING_TIMER_STAT 0x30\n#define SPARE_REG           0x34\n#define SOFT_BYPASS_CONTROL 0x38\n#define SOFT_BYPASS_DATA    0x3c\n\n\n \n#define TS_PEN_INTR_MASK        BIT(0)\n#define TS_FIFO_INTR_MASK       BIT(2)\n\n \n#define TS_PEN_DOWN             BIT(0)\n\n \n#define SCANNING_PERIOD_SHIFT   24\n#define DEBOUNCE_TIMEOUT_SHIFT  16\n#define SETTLING_TIMEOUT_SHIFT  8\n#define TOUCH_TIMEOUT_SHIFT     0\n\n \n#define X_COORD_SHIFT  0\n#define Y_COORD_SHIFT  16\n\n \n#define TS_CONTROLLER_EN_BIT    BIT(16)\n#define TS_CONTROLLER_AVGDATA_SHIFT 8\n#define TS_CONTROLLER_AVGDATA_MASK (0x7 << TS_CONTROLLER_AVGDATA_SHIFT)\n#define TS_CONTROLLER_PWR_LDO   BIT(5)\n#define TS_CONTROLLER_PWR_ADC   BIT(4)\n#define TS_CONTROLLER_PWR_BGP   BIT(3)\n#define TS_CONTROLLER_PWR_TS    BIT(2)\n#define TS_WIRE_MODE_BIT        BIT(1)\n\n#define dbg_reg(dev, priv, reg) \\\ndo { \\\n\tu32 val; \\\n\tregmap_read(priv->regmap, reg, &val); \\\n\tdev_dbg(dev, \"%20s= 0x%08x\\n\", #reg, val); \\\n} while (0)\n\nstruct tsc_param {\n\t \n\tu32 scanning_period;\n\n\t \n\tu32 debounce_timeout;\n\n\t \n\tu32 settling_timeout;\n\n\t \n\tu32 touch_timeout;\n\n\t \n\tu32 average_data;\n\n\t \n\tu32 fifo_threshold;\n\n\t \n\tu32 max_x;\n\tu32 max_y;\n\tu32 fuzz_x;\n\tu32 fuzz_y;\n\tbool invert_x;\n\tbool invert_y;\n};\n\nstruct iproc_ts_priv {\n\tstruct platform_device *pdev;\n\tstruct input_dev *idev;\n\n\tstruct regmap *regmap;\n\tstruct clk *tsc_clk;\n\n\tint  pen_status;\n\tstruct tsc_param cfg_params;\n};\n\n \nstatic const struct tsc_param iproc_default_config = {\n\t.scanning_period  = 0x5,   \n\t.debounce_timeout = 0x28,  \n\t.settling_timeout = 0x7,   \n\t.touch_timeout    = 0xa,   \n\t.average_data     = 5,     \n\t.fifo_threshold   = 1,     \n\t.max_x            = X_MAX,\n\t.max_y            = Y_MAX,\n};\n\nstatic void ts_reg_dump(struct iproc_ts_priv *priv)\n{\n\tstruct device *dev = &priv->pdev->dev;\n\n\tdbg_reg(dev, priv, REGCTL1);\n\tdbg_reg(dev, priv, REGCTL2);\n\tdbg_reg(dev, priv, INTERRUPT_THRES);\n\tdbg_reg(dev, priv, INTERRUPT_MASK);\n\tdbg_reg(dev, priv, INTERRUPT_STATUS);\n\tdbg_reg(dev, priv, CONTROLLER_STATUS);\n\tdbg_reg(dev, priv, FIFO_DATA);\n\tdbg_reg(dev, priv, ANALOG_CONTROL);\n\tdbg_reg(dev, priv, AUX_DATA);\n\tdbg_reg(dev, priv, DEBOUNCE_CNTR_STAT);\n\tdbg_reg(dev, priv, SCAN_CNTR_STAT);\n\tdbg_reg(dev, priv, REM_CNTR_STAT);\n\tdbg_reg(dev, priv, SETTLING_TIMER_STAT);\n\tdbg_reg(dev, priv, SPARE_REG);\n\tdbg_reg(dev, priv, SOFT_BYPASS_CONTROL);\n\tdbg_reg(dev, priv, SOFT_BYPASS_DATA);\n}\n\nstatic irqreturn_t iproc_touchscreen_interrupt(int irq, void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct iproc_ts_priv *priv = platform_get_drvdata(pdev);\n\tu32 intr_status;\n\tu32 raw_coordinate;\n\tu16 x;\n\tu16 y;\n\tint i;\n\tbool needs_sync = false;\n\n\tregmap_read(priv->regmap, INTERRUPT_STATUS, &intr_status);\n\tintr_status &= TS_PEN_INTR_MASK | TS_FIFO_INTR_MASK;\n\tif (intr_status == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tregmap_write(priv->regmap, INTERRUPT_STATUS, intr_status);\n\t \n\tif (intr_status & TS_PEN_INTR_MASK) {\n\t\tregmap_read(priv->regmap, CONTROLLER_STATUS, &priv->pen_status);\n\t\tif (priv->pen_status & TS_PEN_DOWN)\n\t\t\tpriv->pen_status = PEN_DOWN_STATUS;\n\t\telse\n\t\t\tpriv->pen_status = PEN_UP_STATUS;\n\n\t\tinput_report_key(priv->idev, BTN_TOUCH,\tpriv->pen_status);\n\t\tneeds_sync = true;\n\n\t\tdev_dbg(&priv->pdev->dev,\n\t\t\t\"pen up-down (%d)\\n\", priv->pen_status);\n\t}\n\n\t \n\tif (intr_status & TS_FIFO_INTR_MASK) {\n\t\tfor (i = 0; i < priv->cfg_params.fifo_threshold; i++) {\n\t\t\tregmap_read(priv->regmap, FIFO_DATA, &raw_coordinate);\n\t\t\tif (raw_coordinate == INVALID_COORD)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tx = (raw_coordinate >> X_COORD_SHIFT) &\n\t\t\t\tFIFO_DATA_X_Y_MASK;\n\t\t\ty = (raw_coordinate >> Y_COORD_SHIFT) &\n\t\t\t\tFIFO_DATA_X_Y_MASK;\n\n\t\t\t \n\t\t\tx = (x >> 4) & 0x0FFF;\n\t\t\ty = (y >> 4) & 0x0FFF;\n\n\t\t\t \n\t\t\tif (priv->cfg_params.invert_x)\n\t\t\t\tx = priv->cfg_params.max_x - x;\n\n\t\t\tif (priv->cfg_params.invert_y)\n\t\t\t\ty = priv->cfg_params.max_y - y;\n\n\t\t\tinput_report_abs(priv->idev, ABS_X, x);\n\t\t\tinput_report_abs(priv->idev, ABS_Y, y);\n\t\t\tneeds_sync = true;\n\n\t\t\tdev_dbg(&priv->pdev->dev, \"xy (0x%x 0x%x)\\n\", x, y);\n\t\t}\n\t}\n\n\tif (needs_sync)\n\t\tinput_sync(priv->idev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int iproc_ts_start(struct input_dev *idev)\n{\n\tu32 val;\n\tu32 mask;\n\tint error;\n\tstruct iproc_ts_priv *priv = input_get_drvdata(idev);\n\n\t \n\terror = clk_prepare_enable(priv->tsc_clk);\n\tif (error) {\n\t\tdev_err(&priv->pdev->dev, \"%s clk_prepare_enable failed %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t \n\tval = TS_PEN_INTR_MASK | TS_FIFO_INTR_MASK;\n\tregmap_update_bits(priv->regmap, INTERRUPT_MASK, val, val);\n\n\tval = priv->cfg_params.fifo_threshold;\n\tregmap_write(priv->regmap, INTERRUPT_THRES, val);\n\n\t \n\tval = 0;\n\tval |= priv->cfg_params.scanning_period << SCANNING_PERIOD_SHIFT;\n\tval |= priv->cfg_params.debounce_timeout << DEBOUNCE_TIMEOUT_SHIFT;\n\tval |= priv->cfg_params.settling_timeout << SETTLING_TIMEOUT_SHIFT;\n\tval |= priv->cfg_params.touch_timeout << TOUCH_TIMEOUT_SHIFT;\n\tregmap_write(priv->regmap, REGCTL1, val);\n\n\t \n\tval = TS_FIFO_INTR_MASK | TS_PEN_INTR_MASK;\n\tregmap_update_bits(priv->regmap, INTERRUPT_STATUS, val, val);\n\n\t \n\tval = TS_CONTROLLER_EN_BIT | TS_WIRE_MODE_BIT;\n\tval |= priv->cfg_params.average_data << TS_CONTROLLER_AVGDATA_SHIFT;\n\n\tmask = (TS_CONTROLLER_AVGDATA_MASK);\n\tmask |= (TS_CONTROLLER_PWR_LDO |\t \n\t\t   TS_CONTROLLER_PWR_ADC |\t \n\t\t   TS_CONTROLLER_PWR_BGP |\t \n\t\t   TS_CONTROLLER_PWR_TS);\t \n\tmask |= val;\n\tregmap_update_bits(priv->regmap, REGCTL2, mask, val);\n\n\tts_reg_dump(priv);\n\n\treturn 0;\n}\n\nstatic void iproc_ts_stop(struct input_dev *dev)\n{\n\tu32 val;\n\tstruct iproc_ts_priv *priv = input_get_drvdata(dev);\n\n\t \n\tval = TS_PEN_INTR_MASK | TS_FIFO_INTR_MASK;\n\tregmap_update_bits(priv->regmap, INTERRUPT_MASK, val, 0);\n\n\t \n\tval = TS_CONTROLLER_PWR_TS;\n\tregmap_update_bits(priv->regmap, REGCTL2, val, val);\n\n\tclk_disable(priv->tsc_clk);\n}\n\nstatic int iproc_get_tsc_config(struct device *dev, struct iproc_ts_priv *priv)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 val;\n\n\tpriv->cfg_params = iproc_default_config;\n\n\tif (!np)\n\t\treturn 0;\n\n\tif (of_property_read_u32(np, \"scanning_period\", &val) >= 0) {\n\t\tif (val < 1 || val > 256) {\n\t\t\tdev_err(dev, \"scanning_period (%u) must be [1-256]\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->cfg_params.scanning_period = val;\n\t}\n\n\tif (of_property_read_u32(np, \"debounce_timeout\", &val) >= 0) {\n\t\tif (val > 255) {\n\t\t\tdev_err(dev, \"debounce_timeout (%u) must be [0-255]\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->cfg_params.debounce_timeout = val;\n\t}\n\n\tif (of_property_read_u32(np, \"settling_timeout\", &val) >= 0) {\n\t\tif (val > 11) {\n\t\t\tdev_err(dev, \"settling_timeout (%u) must be [0-11]\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->cfg_params.settling_timeout = val;\n\t}\n\n\tif (of_property_read_u32(np, \"touch_timeout\", &val) >= 0) {\n\t\tif (val > 255) {\n\t\t\tdev_err(dev, \"touch_timeout (%u) must be [0-255]\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->cfg_params.touch_timeout = val;\n\t}\n\n\tif (of_property_read_u32(np, \"average_data\", &val) >= 0) {\n\t\tif (val > 8) {\n\t\t\tdev_err(dev, \"average_data (%u) must be [0-8]\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->cfg_params.average_data = val;\n\t}\n\n\tif (of_property_read_u32(np, \"fifo_threshold\", &val) >= 0) {\n\t\tif (val > 31) {\n\t\t\tdev_err(dev, \"fifo_threshold (%u)) must be [0-31]\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->cfg_params.fifo_threshold = val;\n\t}\n\n\t \n\tof_property_read_u32(np, \"touchscreen-size-x\", &priv->cfg_params.max_x);\n\tof_property_read_u32(np, \"touchscreen-size-y\", &priv->cfg_params.max_y);\n\n\tof_property_read_u32(np, \"touchscreen-fuzz-x\",\n\t\t\t     &priv->cfg_params.fuzz_x);\n\tof_property_read_u32(np, \"touchscreen-fuzz-y\",\n\t\t\t     &priv->cfg_params.fuzz_y);\n\n\tpriv->cfg_params.invert_x =\n\t\tof_property_read_bool(np, \"touchscreen-inverted-x\");\n\tpriv->cfg_params.invert_y =\n\t\tof_property_read_bool(np, \"touchscreen-inverted-y\");\n\n\treturn 0;\n}\n\nstatic int iproc_ts_probe(struct platform_device *pdev)\n{\n\tstruct iproc_ts_priv *priv;\n\tstruct input_dev *idev;\n\tint irq;\n\tint error;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t\"ts_syscon\");\n\tif (IS_ERR(priv->regmap)) {\n\t\terror = PTR_ERR(priv->regmap);\n\t\tdev_err(&pdev->dev, \"unable to map I/O memory:%d\\n\", error);\n\t\treturn error;\n\t}\n\n\tpriv->tsc_clk = devm_clk_get(&pdev->dev, \"tsc_clk\");\n\tif (IS_ERR(priv->tsc_clk)) {\n\t\terror = PTR_ERR(priv->tsc_clk);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed getting clock tsc_clk: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tpriv->pdev = pdev;\n\terror = iproc_get_tsc_config(&pdev->dev, priv);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"get_tsc_config failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tidev = devm_input_allocate_device(&pdev->dev);\n\tif (!idev) {\n\t\tdev_err(&pdev->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->idev = idev;\n\tpriv->pen_status = PEN_UP_STATUS;\n\n\t \n\tidev->name = IPROC_TS_NAME;\n\tidev->dev.parent = &pdev->dev;\n\n\tidev->id.bustype = BUS_HOST;\n\tidev->id.vendor = SERIO_UNKNOWN;\n\tidev->id.product = 0;\n\tidev->id.version = 0;\n\n\tidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t__set_bit(BTN_TOUCH, idev->keybit);\n\n\tinput_set_abs_params(idev, ABS_X, X_MIN, priv->cfg_params.max_x,\n\t\t\t     priv->cfg_params.fuzz_x, 0);\n\tinput_set_abs_params(idev, ABS_Y, Y_MIN, priv->cfg_params.max_y,\n\t\t\t     priv->cfg_params.fuzz_y, 0);\n\n\tidev->open = iproc_ts_start;\n\tidev->close = iproc_ts_stop;\n\n\tinput_set_drvdata(idev, priv);\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terror = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t iproc_touchscreen_interrupt,\n\t\t\t\t IRQF_SHARED, IPROC_TS_NAME, pdev);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(priv->idev);\n\tif (error) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id iproc_ts_of_match[] = {\n\t{.compatible = \"brcm,iproc-touchscreen\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, iproc_ts_of_match);\n\nstatic struct platform_driver iproc_ts_driver = {\n\t.probe = iproc_ts_probe,\n\t.driver = {\n\t\t.name\t= IPROC_TS_NAME,\n\t\t.of_match_table = iproc_ts_of_match,\n\t},\n};\n\nmodule_platform_driver(iproc_ts_driver);\n\nMODULE_DESCRIPTION(\"IPROC Touchscreen driver\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}