{
  "module_name": "cyttsp4_core.c",
  "hash_id": "c0253f6c41f29fb1d5b53ef8893cd39ccabcbacfd859cf3ec89363b4b93af867",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cyttsp4_core.c",
  "human_readable_source": "\n \n\n#include \"cyttsp4_core.h\"\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n \n#define CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT\t500\n#define CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT\t5000\n#define CY_CORE_MODE_CHANGE_TIMEOUT\t\t1000\n#define CY_CORE_RESET_AND_WAIT_TIMEOUT\t\t500\n#define CY_CORE_WAKEUP_TIMEOUT\t\t\t500\n\n#define CY_CORE_STARTUP_RETRY_COUNT\t\t3\n\nstatic const char * const cyttsp4_tch_abs_string[] = {\n\t[CY_TCH_X]\t= \"X\",\n\t[CY_TCH_Y]\t= \"Y\",\n\t[CY_TCH_P]\t= \"P\",\n\t[CY_TCH_T]\t= \"T\",\n\t[CY_TCH_E]\t= \"E\",\n\t[CY_TCH_O]\t= \"O\",\n\t[CY_TCH_W]\t= \"W\",\n\t[CY_TCH_MAJ]\t= \"MAJ\",\n\t[CY_TCH_MIN]\t= \"MIN\",\n\t[CY_TCH_OR]\t= \"OR\",\n\t[CY_TCH_NUM_ABS] = \"INVALID\"\n};\n\nstatic const u8 ldr_exit[] = {\n\t0xFF, 0x01, 0x3B, 0x00, 0x00, 0x4F, 0x6D, 0x17\n};\n\nstatic const u8 ldr_err_app[] = {\n\t0x01, 0x02, 0x00, 0x00, 0x55, 0xDD, 0x17\n};\n\nstatic inline size_t merge_bytes(u8 high, u8 low)\n{\n\treturn (high << 8) + low;\n}\n\n#ifdef VERBOSE_DEBUG\nstatic void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,\n\t\tconst char *data_name)\n{\n\tint i, k;\n\tconst char fmt[] = \"%02X \";\n\tint max;\n\n\tif (!size)\n\t\treturn;\n\n\tmax = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);\n\n\tpr_buf[0] = 0;\n\tfor (i = k = 0; i < size && k < max; i++, k += 3)\n\t\tscnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, dptr[i]);\n\n\tdev_vdbg(dev, \"%s:  %s[0..%d]=%s%s\\n\", __func__, data_name, size - 1,\n\t\t\tpr_buf, size <= max ? \"\" : CY_PR_TRUNCATED);\n}\n#else\n#define cyttsp4_pr_buf(dev, pr_buf, dptr, size, data_name) do { } while (0)\n#endif\n\nstatic int cyttsp4_load_status_regs(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tstruct device *dev = cd->dev;\n\tint rc;\n\n\trc = cyttsp4_adap_read(cd, CY_REG_BASE, si->si_ofs.mode_size,\n\t\t\tsi->xy_mode);\n\tif (rc < 0)\n\t\tdev_err(dev, \"%s: fail read mode regs r=%d\\n\",\n\t\t\t__func__, rc);\n\telse\n\t\tcyttsp4_pr_buf(dev, cd->pr_buf, si->xy_mode,\n\t\t\tsi->si_ofs.mode_size, \"xy_mode\");\n\n\treturn rc;\n}\n\nstatic int cyttsp4_handshake(struct cyttsp4 *cd, u8 mode)\n{\n\tu8 cmd = mode ^ CY_HST_TOGGLE;\n\tint rc;\n\n\t \n\tif (mode & CY_HST_MODE_CHANGE)\n\t\treturn 0;\n\n\trc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(cmd), &cmd);\n\tif (rc < 0)\n\t\tdev_err(cd->dev, \"%s: bus write fail on handshake (ret=%d)\\n\",\n\t\t\t\t__func__, rc);\n\n\treturn rc;\n}\n\nstatic int cyttsp4_hw_soft_reset(struct cyttsp4 *cd)\n{\n\tu8 cmd = CY_HST_RESET;\n\tint rc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(cmd), &cmd);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: FAILED to execute SOFT reset\\n\",\n\t\t\t\t__func__);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int cyttsp4_hw_hard_reset(struct cyttsp4 *cd)\n{\n\tif (cd->cpdata->xres) {\n\t\tcd->cpdata->xres(cd->cpdata, cd->dev);\n\t\tdev_dbg(cd->dev, \"%s: execute HARD reset\\n\", __func__);\n\t\treturn 0;\n\t}\n\tdev_err(cd->dev, \"%s: FAILED to execute HARD reset\\n\", __func__);\n\treturn -ENOSYS;\n}\n\nstatic int cyttsp4_hw_reset(struct cyttsp4 *cd)\n{\n\tint rc = cyttsp4_hw_hard_reset(cd);\n\tif (rc == -ENOSYS)\n\t\trc = cyttsp4_hw_soft_reset(cd);\n\treturn rc;\n}\n\n \nstatic int cyttsp4_bits_2_bytes(unsigned int nbits, size_t *max)\n{\n\t*max = 1UL << nbits;\n\treturn (nbits + 7) / 8;\n}\n\nstatic int cyttsp4_si_data_offsets(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tint rc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(si->si_data),\n\t\t\t&si->si_data);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read sysinfo data offsets r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\t \n\tcyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)&si->si_data,\n\t\t       sizeof(si->si_data), \"sysinfo_data_offsets\");\n\n\t \n\n\tsi->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,\n\t\t\tsi->si_data.map_szl);\n\tsi->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,\n\t\t\tsi->si_data.map_szl);\n\tsi->si_ofs.cydata_ofs = merge_bytes(si->si_data.cydata_ofsh,\n\t\t\tsi->si_data.cydata_ofsl);\n\tsi->si_ofs.test_ofs = merge_bytes(si->si_data.test_ofsh,\n\t\t\tsi->si_data.test_ofsl);\n\tsi->si_ofs.pcfg_ofs = merge_bytes(si->si_data.pcfg_ofsh,\n\t\t\tsi->si_data.pcfg_ofsl);\n\tsi->si_ofs.opcfg_ofs = merge_bytes(si->si_data.opcfg_ofsh,\n\t\t\tsi->si_data.opcfg_ofsl);\n\tsi->si_ofs.ddata_ofs = merge_bytes(si->si_data.ddata_ofsh,\n\t\t\tsi->si_data.ddata_ofsl);\n\tsi->si_ofs.mdata_ofs = merge_bytes(si->si_data.mdata_ofsh,\n\t\t\tsi->si_data.mdata_ofsl);\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_cydata(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tint read_offset;\n\tint mfgid_sz, calc_mfgid_sz;\n\tvoid *p;\n\tint rc;\n\n\tif (si->si_ofs.test_ofs <= si->si_ofs.cydata_ofs) {\n\t\tdev_err(cd->dev,\n\t\t\t\"%s: invalid offset test_ofs: %zu, cydata_ofs: %zu\\n\",\n\t\t\t__func__, si->si_ofs.test_ofs, si->si_ofs.cydata_ofs);\n\t\treturn -EINVAL;\n\t}\n\n\tsi->si_ofs.cydata_size = si->si_ofs.test_ofs - si->si_ofs.cydata_ofs;\n\tdev_dbg(cd->dev, \"%s: cydata size: %zd\\n\", __func__,\n\t\t\tsi->si_ofs.cydata_size);\n\n\tp = krealloc(si->si_ptrs.cydata, si->si_ofs.cydata_size, GFP_KERNEL);\n\tif (p == NULL) {\n\t\tdev_err(cd->dev, \"%s: failed to allocate cydata memory\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tsi->si_ptrs.cydata = p;\n\n\tread_offset = si->si_ofs.cydata_ofs;\n\n\t \n\trc = cyttsp4_adap_read(cd, read_offset,\n\t\t\toffsetof(struct cyttsp4_cydata, mfgid_sz)\n\t\t\t\t+ sizeof(si->si_ptrs.cydata->mfgid_sz),\n\t\t\tsi->si_ptrs.cydata);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read cydata r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\t \n\tmfgid_sz = si->si_ptrs.cydata->mfgid_sz;\n\tcalc_mfgid_sz = si->si_ofs.cydata_size - sizeof(struct cyttsp4_cydata);\n\tif (mfgid_sz != calc_mfgid_sz) {\n\t\tdev_err(cd->dev, \"%s: mismatch in MFGID size, reported:%d calculated:%d\\n\",\n\t\t\t__func__, mfgid_sz, calc_mfgid_sz);\n\t\treturn -EINVAL;\n\t}\n\n\tread_offset += offsetof(struct cyttsp4_cydata, mfgid_sz)\n\t\t\t+ sizeof(si->si_ptrs.cydata->mfgid_sz);\n\n\t \n\trc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata->mfgid_sz,\n\t\t\tsi->si_ptrs.cydata->mfg_id);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read cydata r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\tread_offset += si->si_ptrs.cydata->mfgid_sz;\n\n\t \n\trc = cyttsp4_adap_read(cd, read_offset,\n\t\t\tsizeof(struct cyttsp4_cydata)\n\t\t\t\t- offsetof(struct cyttsp4_cydata, cyito_idh),\n\t\t\t&si->si_ptrs.cydata->cyito_idh);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read cydata r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\tcyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.cydata,\n\t\tsi->si_ofs.cydata_size, \"sysinfo_cydata\");\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_test_data(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tvoid *p;\n\tint rc;\n\n\tif (si->si_ofs.pcfg_ofs <= si->si_ofs.test_ofs) {\n\t\tdev_err(cd->dev,\n\t\t\t\"%s: invalid offset pcfg_ofs: %zu, test_ofs: %zu\\n\",\n\t\t\t__func__, si->si_ofs.pcfg_ofs, si->si_ofs.test_ofs);\n\t\treturn -EINVAL;\n\t}\n\n\tsi->si_ofs.test_size = si->si_ofs.pcfg_ofs - si->si_ofs.test_ofs;\n\n\tp = krealloc(si->si_ptrs.test, si->si_ofs.test_size, GFP_KERNEL);\n\tif (p == NULL) {\n\t\tdev_err(cd->dev, \"%s: failed to allocate test memory\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tsi->si_ptrs.test = p;\n\n\trc = cyttsp4_adap_read(cd, si->si_ofs.test_ofs, si->si_ofs.test_size,\n\t\t\tsi->si_ptrs.test);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read test data r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\tcyttsp4_pr_buf(cd->dev, cd->pr_buf,\n\t\t       (u8 *)si->si_ptrs.test, si->si_ofs.test_size,\n\t\t       \"sysinfo_test_data\");\n\tif (si->si_ptrs.test->post_codel &\n\t    CY_POST_CODEL_WDG_RST)\n\t\tdev_info(cd->dev, \"%s: %s codel=%02X\\n\",\n\t\t\t __func__, \"Reset was a WATCHDOG RESET\",\n\t\t\t si->si_ptrs.test->post_codel);\n\n\tif (!(si->si_ptrs.test->post_codel &\n\t      CY_POST_CODEL_CFG_DATA_CRC_FAIL))\n\t\tdev_info(cd->dev, \"%s: %s codel=%02X\\n\", __func__,\n\t\t\t \"Config Data CRC FAIL\",\n\t\t\t si->si_ptrs.test->post_codel);\n\n\tif (!(si->si_ptrs.test->post_codel &\n\t      CY_POST_CODEL_PANEL_TEST_FAIL))\n\t\tdev_info(cd->dev, \"%s: %s codel=%02X\\n\",\n\t\t\t __func__, \"PANEL TEST FAIL\",\n\t\t\t si->si_ptrs.test->post_codel);\n\n\tdev_info(cd->dev, \"%s: SCANNING is %s codel=%02X\\n\",\n\t\t __func__, si->si_ptrs.test->post_codel & 0x08 ?\n\t\t \"ENABLED\" : \"DISABLED\",\n\t\t si->si_ptrs.test->post_codel);\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_pcfg_data(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tvoid *p;\n\tint rc;\n\n\tif (si->si_ofs.opcfg_ofs <= si->si_ofs.pcfg_ofs) {\n\t\tdev_err(cd->dev,\n\t\t\t\"%s: invalid offset opcfg_ofs: %zu, pcfg_ofs: %zu\\n\",\n\t\t\t__func__, si->si_ofs.opcfg_ofs, si->si_ofs.pcfg_ofs);\n\t\treturn -EINVAL;\n\t}\n\n\tsi->si_ofs.pcfg_size = si->si_ofs.opcfg_ofs - si->si_ofs.pcfg_ofs;\n\n\tp = krealloc(si->si_ptrs.pcfg, si->si_ofs.pcfg_size, GFP_KERNEL);\n\tif (p == NULL) {\n\t\tdev_err(cd->dev, \"%s: failed to allocate pcfg memory\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tsi->si_ptrs.pcfg = p;\n\n\trc = cyttsp4_adap_read(cd, si->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size,\n\t\t\tsi->si_ptrs.pcfg);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read pcfg data r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\tsi->si_ofs.max_x = merge_bytes((si->si_ptrs.pcfg->res_xh\n\t\t\t& CY_PCFG_RESOLUTION_X_MASK), si->si_ptrs.pcfg->res_xl);\n\tsi->si_ofs.x_origin = !!(si->si_ptrs.pcfg->res_xh\n\t\t\t& CY_PCFG_ORIGIN_X_MASK);\n\tsi->si_ofs.max_y = merge_bytes((si->si_ptrs.pcfg->res_yh\n\t\t\t& CY_PCFG_RESOLUTION_Y_MASK), si->si_ptrs.pcfg->res_yl);\n\tsi->si_ofs.y_origin = !!(si->si_ptrs.pcfg->res_yh\n\t\t\t& CY_PCFG_ORIGIN_Y_MASK);\n\tsi->si_ofs.max_p = merge_bytes(si->si_ptrs.pcfg->max_zh,\n\t\t\tsi->si_ptrs.pcfg->max_zl);\n\n\tcyttsp4_pr_buf(cd->dev, cd->pr_buf,\n\t\t       (u8 *)si->si_ptrs.pcfg,\n\t\t       si->si_ofs.pcfg_size, \"sysinfo_pcfg_data\");\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_opcfg_data(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tstruct cyttsp4_tch_abs_params *tch;\n\tstruct cyttsp4_tch_rec_params *tch_old, *tch_new;\n\tenum cyttsp4_tch_abs abs;\n\tint i;\n\tvoid *p;\n\tint rc;\n\n\tif (si->si_ofs.ddata_ofs <= si->si_ofs.opcfg_ofs) {\n\t\tdev_err(cd->dev,\n\t\t\t\"%s: invalid offset ddata_ofs: %zu, opcfg_ofs: %zu\\n\",\n\t\t\t__func__, si->si_ofs.ddata_ofs, si->si_ofs.opcfg_ofs);\n\t\treturn -EINVAL;\n\t}\n\n\tsi->si_ofs.opcfg_size = si->si_ofs.ddata_ofs - si->si_ofs.opcfg_ofs;\n\n\tp = krealloc(si->si_ptrs.opcfg, si->si_ofs.opcfg_size, GFP_KERNEL);\n\tif (p == NULL) {\n\t\tdev_err(cd->dev, \"%s: failed to allocate opcfg memory\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tsi->si_ptrs.opcfg = p;\n\n\trc = cyttsp4_adap_read(cd, si->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size,\n\t\t\tsi->si_ptrs.opcfg);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail read opcfg data r=%d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\tsi->si_ofs.cmd_ofs = si->si_ptrs.opcfg->cmd_ofs;\n\tsi->si_ofs.rep_ofs = si->si_ptrs.opcfg->rep_ofs;\n\tsi->si_ofs.rep_sz = (si->si_ptrs.opcfg->rep_szh * 256) +\n\t\tsi->si_ptrs.opcfg->rep_szl;\n\tsi->si_ofs.num_btns = si->si_ptrs.opcfg->num_btns;\n\tsi->si_ofs.num_btn_regs = (si->si_ofs.num_btns +\n\t\tCY_NUM_BTN_PER_REG - 1) / CY_NUM_BTN_PER_REG;\n\tsi->si_ofs.tt_stat_ofs = si->si_ptrs.opcfg->tt_stat_ofs;\n\tsi->si_ofs.obj_cfg0 = si->si_ptrs.opcfg->obj_cfg0;\n\tsi->si_ofs.max_tchs = si->si_ptrs.opcfg->max_tchs &\n\t\tCY_BYTE_OFS_MASK;\n\tsi->si_ofs.tch_rec_size = si->si_ptrs.opcfg->tch_rec_size &\n\t\tCY_BYTE_OFS_MASK;\n\n\t \n\tfor (abs = CY_TCH_X; abs < CY_NUM_TCH_FIELDS; abs++) {\n\t\ttch = &si->si_ofs.tch_abs[abs];\n\t\ttch_old = &si->si_ptrs.opcfg->tch_rec_old[abs];\n\n\t\ttch->ofs = tch_old->loc & CY_BYTE_OFS_MASK;\n\t\ttch->size = cyttsp4_bits_2_bytes(tch_old->size,\n\t\t\t\t\t\t &tch->max);\n\t\ttch->bofs = (tch_old->loc & CY_BOFS_MASK) >> CY_BOFS_SHIFT;\n\t}\n\n\t \n\tsi->si_ofs.btn_rec_size = si->si_ptrs.opcfg->btn_rec_size;\n\tsi->si_ofs.btn_diff_ofs = si->si_ptrs.opcfg->btn_diff_ofs;\n\tsi->si_ofs.btn_diff_size = si->si_ptrs.opcfg->btn_diff_size;\n\n\tif (si->si_ofs.tch_rec_size > CY_TMA1036_TCH_REC_SIZE) {\n\t\t \n\t\tfor (i = 0; i < CY_NUM_EXT_TCH_FIELDS; abs++, i++) {\n\t\t\ttch = &si->si_ofs.tch_abs[abs];\n\t\t\ttch_new = &si->si_ptrs.opcfg->tch_rec_new[i];\n\n\t\t\ttch->ofs = tch_new->loc & CY_BYTE_OFS_MASK;\n\t\t\ttch->size = cyttsp4_bits_2_bytes(tch_new->size,\n\t\t\t\t\t\t\t &tch->max);\n\t\t\ttch->bofs = (tch_new->loc & CY_BOFS_MASK) >> CY_BOFS_SHIFT;\n\t\t}\n\t}\n\n\tfor (abs = 0; abs < CY_TCH_NUM_ABS; abs++) {\n\t\tdev_dbg(cd->dev, \"%s: tch_rec_%s\\n\", __func__,\n\t\t\tcyttsp4_tch_abs_string[abs]);\n\t\tdev_dbg(cd->dev, \"%s:     ofs =%2zd\\n\", __func__,\n\t\t\tsi->si_ofs.tch_abs[abs].ofs);\n\t\tdev_dbg(cd->dev, \"%s:     siz =%2zd\\n\", __func__,\n\t\t\tsi->si_ofs.tch_abs[abs].size);\n\t\tdev_dbg(cd->dev, \"%s:     max =%2zd\\n\", __func__,\n\t\t\tsi->si_ofs.tch_abs[abs].max);\n\t\tdev_dbg(cd->dev, \"%s:     bofs=%2zd\\n\", __func__,\n\t\t\tsi->si_ofs.tch_abs[abs].bofs);\n\t}\n\n\tsi->si_ofs.mode_size = si->si_ofs.tt_stat_ofs + 1;\n\tsi->si_ofs.data_size = si->si_ofs.max_tchs *\n\t\tsi->si_ptrs.opcfg->tch_rec_size;\n\n\tcyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.opcfg,\n\t\tsi->si_ofs.opcfg_size, \"sysinfo_opcfg_data\");\n\n\treturn 0;\n}\n\nstatic int cyttsp4_si_get_ddata(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tvoid *p;\n\tint rc;\n\n\tsi->si_ofs.ddata_size = si->si_ofs.mdata_ofs - si->si_ofs.ddata_ofs;\n\n\tp = krealloc(si->si_ptrs.ddata, si->si_ofs.ddata_size, GFP_KERNEL);\n\tif (p == NULL) {\n\t\tdev_err(cd->dev, \"%s: fail alloc ddata memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tsi->si_ptrs.ddata = p;\n\n\trc = cyttsp4_adap_read(cd, si->si_ofs.ddata_ofs, si->si_ofs.ddata_size,\n\t\t\tsi->si_ptrs.ddata);\n\tif (rc < 0)\n\t\tdev_err(cd->dev, \"%s: fail read ddata data r=%d\\n\",\n\t\t\t__func__, rc);\n\telse\n\t\tcyttsp4_pr_buf(cd->dev, cd->pr_buf,\n\t\t\t       (u8 *)si->si_ptrs.ddata,\n\t\t\t       si->si_ofs.ddata_size, \"sysinfo_ddata\");\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_mdata(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tvoid *p;\n\tint rc;\n\n\tsi->si_ofs.mdata_size = si->si_ofs.map_sz - si->si_ofs.mdata_ofs;\n\n\tp = krealloc(si->si_ptrs.mdata, si->si_ofs.mdata_size, GFP_KERNEL);\n\tif (p == NULL) {\n\t\tdev_err(cd->dev, \"%s: fail alloc mdata memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tsi->si_ptrs.mdata = p;\n\n\trc = cyttsp4_adap_read(cd, si->si_ofs.mdata_ofs, si->si_ofs.mdata_size,\n\t\t\tsi->si_ptrs.mdata);\n\tif (rc < 0)\n\t\tdev_err(cd->dev, \"%s: fail read mdata data r=%d\\n\",\n\t\t\t__func__, rc);\n\telse\n\t\tcyttsp4_pr_buf(cd->dev, cd->pr_buf,\n\t\t\t       (u8 *)si->si_ptrs.mdata,\n\t\t\t       si->si_ofs.mdata_size, \"sysinfo_mdata\");\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_btn_data(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tint btn;\n\tint num_defined_keys;\n\tu16 *key_table;\n\tvoid *p;\n\tint rc = 0;\n\n\tif (si->si_ofs.num_btns) {\n\t\tsi->si_ofs.btn_keys_size = si->si_ofs.num_btns *\n\t\t\tsizeof(struct cyttsp4_btn);\n\n\t\tp = krealloc(si->btn, si->si_ofs.btn_keys_size,\n\t\t\t\tGFP_KERNEL|__GFP_ZERO);\n\t\tif (p == NULL) {\n\t\t\tdev_err(cd->dev, \"%s: %s\\n\", __func__,\n\t\t\t\t\"fail alloc btn_keys memory\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsi->btn = p;\n\n\t\tif (cd->cpdata->sett[CY_IC_GRPNUM_BTN_KEYS] == NULL)\n\t\t\tnum_defined_keys = 0;\n\t\telse if (cd->cpdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data == NULL)\n\t\t\tnum_defined_keys = 0;\n\t\telse\n\t\t\tnum_defined_keys = cd->cpdata->sett\n\t\t\t\t[CY_IC_GRPNUM_BTN_KEYS]->size;\n\n\t\tfor (btn = 0; btn < si->si_ofs.num_btns &&\n\t\t\tbtn < num_defined_keys; btn++) {\n\t\t\tkey_table = (u16 *)cd->cpdata->sett\n\t\t\t\t[CY_IC_GRPNUM_BTN_KEYS]->data;\n\t\t\tsi->btn[btn].key_code = key_table[btn];\n\t\t\tsi->btn[btn].state = CY_BTN_RELEASED;\n\t\t\tsi->btn[btn].enabled = true;\n\t\t}\n\t\tfor (; btn < si->si_ofs.num_btns; btn++) {\n\t\t\tsi->btn[btn].key_code = KEY_RESERVED;\n\t\t\tsi->btn[btn].state = CY_BTN_RELEASED;\n\t\t\tsi->btn[btn].enabled = true;\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tsi->si_ofs.btn_keys_size = 0;\n\tkfree(si->btn);\n\tsi->btn = NULL;\n\treturn rc;\n}\n\nstatic int cyttsp4_si_get_op_data_ptrs(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tvoid *p;\n\n\tp = krealloc(si->xy_mode, si->si_ofs.mode_size, GFP_KERNEL|__GFP_ZERO);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\tsi->xy_mode = p;\n\n\tp = krealloc(si->xy_data, si->si_ofs.data_size, GFP_KERNEL|__GFP_ZERO);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\tsi->xy_data = p;\n\n\tp = krealloc(si->btn_rec_data,\n\t\t\tsi->si_ofs.btn_rec_size * si->si_ofs.num_btns,\n\t\t\tGFP_KERNEL|__GFP_ZERO);\n\tif (p == NULL)\n\t\treturn -ENOMEM;\n\tsi->btn_rec_data = p;\n\n\treturn 0;\n}\n\nstatic void cyttsp4_si_put_log_data(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tdev_dbg(cd->dev, \"%s: cydata_ofs =%4zd siz=%4zd\\n\", __func__,\n\t\tsi->si_ofs.cydata_ofs, si->si_ofs.cydata_size);\n\tdev_dbg(cd->dev, \"%s: test_ofs   =%4zd siz=%4zd\\n\", __func__,\n\t\tsi->si_ofs.test_ofs, si->si_ofs.test_size);\n\tdev_dbg(cd->dev, \"%s: pcfg_ofs   =%4zd siz=%4zd\\n\", __func__,\n\t\tsi->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size);\n\tdev_dbg(cd->dev, \"%s: opcfg_ofs  =%4zd siz=%4zd\\n\", __func__,\n\t\tsi->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size);\n\tdev_dbg(cd->dev, \"%s: ddata_ofs  =%4zd siz=%4zd\\n\", __func__,\n\t\tsi->si_ofs.ddata_ofs, si->si_ofs.ddata_size);\n\tdev_dbg(cd->dev, \"%s: mdata_ofs  =%4zd siz=%4zd\\n\", __func__,\n\t\tsi->si_ofs.mdata_ofs, si->si_ofs.mdata_size);\n\n\tdev_dbg(cd->dev, \"%s: cmd_ofs       =%4zd\\n\", __func__,\n\t\tsi->si_ofs.cmd_ofs);\n\tdev_dbg(cd->dev, \"%s: rep_ofs       =%4zd\\n\", __func__,\n\t\tsi->si_ofs.rep_ofs);\n\tdev_dbg(cd->dev, \"%s: rep_sz        =%4zd\\n\", __func__,\n\t\tsi->si_ofs.rep_sz);\n\tdev_dbg(cd->dev, \"%s: num_btns      =%4zd\\n\", __func__,\n\t\tsi->si_ofs.num_btns);\n\tdev_dbg(cd->dev, \"%s: num_btn_regs  =%4zd\\n\", __func__,\n\t\tsi->si_ofs.num_btn_regs);\n\tdev_dbg(cd->dev, \"%s: tt_stat_ofs   =%4zd\\n\", __func__,\n\t\tsi->si_ofs.tt_stat_ofs);\n\tdev_dbg(cd->dev, \"%s: tch_rec_size  =%4zd\\n\", __func__,\n\t\tsi->si_ofs.tch_rec_size);\n\tdev_dbg(cd->dev, \"%s: max_tchs      =%4zd\\n\", __func__,\n\t\tsi->si_ofs.max_tchs);\n\tdev_dbg(cd->dev, \"%s: mode_size     =%4zd\\n\", __func__,\n\t\tsi->si_ofs.mode_size);\n\tdev_dbg(cd->dev, \"%s: data_size     =%4zd\\n\", __func__,\n\t\tsi->si_ofs.data_size);\n\tdev_dbg(cd->dev, \"%s: map_sz        =%4zd\\n\", __func__,\n\t\tsi->si_ofs.map_sz);\n\n\tdev_dbg(cd->dev, \"%s: btn_rec_size   =%2zd\\n\", __func__,\n\t\tsi->si_ofs.btn_rec_size);\n\tdev_dbg(cd->dev, \"%s: btn_diff_ofs   =%2zd\\n\", __func__,\n\t\tsi->si_ofs.btn_diff_ofs);\n\tdev_dbg(cd->dev, \"%s: btn_diff_size  =%2zd\\n\", __func__,\n\t\tsi->si_ofs.btn_diff_size);\n\n\tdev_dbg(cd->dev, \"%s: max_x    = 0x%04zX (%zd)\\n\", __func__,\n\t\tsi->si_ofs.max_x, si->si_ofs.max_x);\n\tdev_dbg(cd->dev, \"%s: x_origin = %zd (%s)\\n\", __func__,\n\t\tsi->si_ofs.x_origin,\n\t\tsi->si_ofs.x_origin == CY_NORMAL_ORIGIN ?\n\t\t\"left corner\" : \"right corner\");\n\tdev_dbg(cd->dev, \"%s: max_y    = 0x%04zX (%zd)\\n\", __func__,\n\t\tsi->si_ofs.max_y, si->si_ofs.max_y);\n\tdev_dbg(cd->dev, \"%s: y_origin = %zd (%s)\\n\", __func__,\n\t\tsi->si_ofs.y_origin,\n\t\tsi->si_ofs.y_origin == CY_NORMAL_ORIGIN ?\n\t\t\"upper corner\" : \"lower corner\");\n\tdev_dbg(cd->dev, \"%s: max_p    = 0x%04zX (%zd)\\n\", __func__,\n\t\tsi->si_ofs.max_p, si->si_ofs.max_p);\n\n\tdev_dbg(cd->dev, \"%s: xy_mode=%p xy_data=%p\\n\", __func__,\n\t\tsi->xy_mode, si->xy_data);\n}\n\nstatic int cyttsp4_get_sysinfo_regs(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\tint rc;\n\n\trc = cyttsp4_si_data_offsets(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_cydata(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_test_data(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_pcfg_data(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_opcfg_data(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_ddata(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_mdata(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_btn_data(cd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = cyttsp4_si_get_op_data_ptrs(cd);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: failed to get_op_data\\n\",\n\t\t\t__func__);\n\t\treturn rc;\n\t}\n\n\tcyttsp4_si_put_log_data(cd);\n\n\t \n\trc = cyttsp4_handshake(cd, si->si_data.hst_mode);\n\tif (rc < 0)\n\t\tdev_err(cd->dev, \"%s: handshake fail on sysinfo reg\\n\",\n\t\t\t__func__);\n\n\tsi->ready = true;\n\treturn rc;\n}\n\nstatic void cyttsp4_queue_startup_(struct cyttsp4 *cd)\n{\n\tif (cd->startup_state == STARTUP_NONE) {\n\t\tcd->startup_state = STARTUP_QUEUED;\n\t\tschedule_work(&cd->startup_work);\n\t\tdev_dbg(cd->dev, \"%s: cyttsp4_startup queued\\n\", __func__);\n\t} else {\n\t\tdev_dbg(cd->dev, \"%s: startup_state = %d\\n\", __func__,\n\t\t\tcd->startup_state);\n\t}\n}\n\nstatic void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,\n\t\tint max_slots)\n{\n\tint t;\n\n\tif (md->num_prv_tch == 0)\n\t\treturn;\n\n\tfor (t = 0; t < max_slots; t++) {\n\t\tinput_mt_slot(md->input, t);\n\t\tinput_mt_report_slot_inactive(md->input);\n\t}\n}\n\nstatic void cyttsp4_lift_all(struct cyttsp4_mt_data *md)\n{\n\tif (!md->si)\n\t\treturn;\n\n\tif (md->num_prv_tch != 0) {\n\t\tcyttsp4_report_slot_liftoff(md,\n\t\t\t\tmd->si->si_ofs.tch_abs[CY_TCH_T].max);\n\t\tinput_sync(md->input);\n\t\tmd->num_prv_tch = 0;\n\t}\n}\n\nstatic void cyttsp4_get_touch_axis(struct cyttsp4_mt_data *md,\n\tint *axis, int size, int max, u8 *xy_data, int bofs)\n{\n\tint nbyte;\n\tint next;\n\n\tfor (nbyte = 0, *axis = 0, next = 0; nbyte < size; nbyte++) {\n\t\tdev_vdbg(&md->input->dev,\n\t\t\t\"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p\"\n\t\t\t\" xy_data[%d]=%02X(%d) bofs=%d\\n\",\n\t\t\t__func__, *axis, *axis, size, max, xy_data, next,\n\t\t\txy_data[next], xy_data[next], bofs);\n\t\t*axis = (*axis * 256) + (xy_data[next] >> bofs);\n\t\tnext++;\n\t}\n\n\t*axis &= max - 1;\n\n\tdev_vdbg(&md->input->dev,\n\t\t\"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p\"\n\t\t\" xy_data[%d]=%02X(%d)\\n\",\n\t\t__func__, *axis, *axis, size, max, xy_data, next,\n\t\txy_data[next], xy_data[next]);\n}\n\nstatic void cyttsp4_get_touch(struct cyttsp4_mt_data *md,\n\tstruct cyttsp4_touch *touch, u8 *xy_data)\n{\n\tstruct device *dev = &md->input->dev;\n\tstruct cyttsp4_sysinfo *si = md->si;\n\tenum cyttsp4_tch_abs abs;\n\tbool flipped;\n\n\tfor (abs = CY_TCH_X; abs < CY_TCH_NUM_ABS; abs++) {\n\t\tcyttsp4_get_touch_axis(md, &touch->abs[abs],\n\t\t\tsi->si_ofs.tch_abs[abs].size,\n\t\t\tsi->si_ofs.tch_abs[abs].max,\n\t\t\txy_data + si->si_ofs.tch_abs[abs].ofs,\n\t\t\tsi->si_ofs.tch_abs[abs].bofs);\n\t\tdev_vdbg(dev, \"%s: get %s=%04X(%d)\\n\", __func__,\n\t\t\tcyttsp4_tch_abs_string[abs],\n\t\t\ttouch->abs[abs], touch->abs[abs]);\n\t}\n\n\tif (md->pdata->flags & CY_FLAG_FLIP) {\n\t\tswap(touch->abs[CY_TCH_X], touch->abs[CY_TCH_Y]);\n\t\tflipped = true;\n\t} else\n\t\tflipped = false;\n\n\tif (md->pdata->flags & CY_FLAG_INV_X) {\n\t\tif (flipped)\n\t\t\ttouch->abs[CY_TCH_X] = md->si->si_ofs.max_y -\n\t\t\t\ttouch->abs[CY_TCH_X];\n\t\telse\n\t\t\ttouch->abs[CY_TCH_X] = md->si->si_ofs.max_x -\n\t\t\t\ttouch->abs[CY_TCH_X];\n\t}\n\tif (md->pdata->flags & CY_FLAG_INV_Y) {\n\t\tif (flipped)\n\t\t\ttouch->abs[CY_TCH_Y] = md->si->si_ofs.max_x -\n\t\t\t\ttouch->abs[CY_TCH_Y];\n\t\telse\n\t\t\ttouch->abs[CY_TCH_Y] = md->si->si_ofs.max_y -\n\t\t\t\ttouch->abs[CY_TCH_Y];\n\t}\n\n\tdev_vdbg(dev, \"%s: flip=%s inv-x=%s inv-y=%s x=%04X(%d) y=%04X(%d)\\n\",\n\t\t__func__, flipped ? \"true\" : \"false\",\n\t\tmd->pdata->flags & CY_FLAG_INV_X ? \"true\" : \"false\",\n\t\tmd->pdata->flags & CY_FLAG_INV_Y ? \"true\" : \"false\",\n\t\ttouch->abs[CY_TCH_X], touch->abs[CY_TCH_X],\n\t\ttouch->abs[CY_TCH_Y], touch->abs[CY_TCH_Y]);\n}\n\nstatic void cyttsp4_final_sync(struct input_dev *input, int max_slots, int *ids)\n{\n\tint t;\n\n\tfor (t = 0; t < max_slots; t++) {\n\t\tif (ids[t])\n\t\t\tcontinue;\n\t\tinput_mt_slot(input, t);\n\t\tinput_mt_report_slot_inactive(input);\n\t}\n\n\tinput_sync(input);\n}\n\nstatic void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_tch)\n{\n\tstruct device *dev = &md->input->dev;\n\tstruct cyttsp4_sysinfo *si = md->si;\n\tstruct cyttsp4_touch tch;\n\tint sig;\n\tint i, j, t = 0;\n\tint ids[max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH)];\n\n\tmemset(ids, 0, si->si_ofs.tch_abs[CY_TCH_T].max * sizeof(int));\n\tfor (i = 0; i < num_cur_tch; i++) {\n\t\tcyttsp4_get_touch(md, &tch, si->xy_data +\n\t\t\t(i * si->si_ofs.tch_rec_size));\n\t\tif ((tch.abs[CY_TCH_T] < md->pdata->frmwrk->abs\n\t\t\t[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST]) ||\n\t\t\t(tch.abs[CY_TCH_T] > md->pdata->frmwrk->abs\n\t\t\t[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MAX_OST])) {\n\t\t\tdev_err(dev, \"%s: tch=%d -> bad trk_id=%d max_id=%d\\n\",\n\t\t\t\t__func__, i, tch.abs[CY_TCH_T],\n\t\t\t\tmd->pdata->frmwrk->abs[(CY_ABS_ID_OST *\n\t\t\t\tCY_NUM_ABS_SET) + CY_MAX_OST]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tsig = md->pdata->frmwrk->abs\n\t\t\t[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + 0];\n\t\tif (sig != CY_IGNORE_VALUE) {\n\t\t\tt = tch.abs[CY_TCH_T] - md->pdata->frmwrk->abs\n\t\t\t\t[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST];\n\t\t\tif (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF) {\n\t\t\t\tdev_dbg(dev, \"%s: t=%d e=%d lift-off\\n\",\n\t\t\t\t\t__func__, t, tch.abs[CY_TCH_E]);\n\t\t\t\tgoto cyttsp4_get_mt_touches_pr_tch;\n\t\t\t}\n\t\t\tinput_mt_slot(md->input, t);\n\t\t\tinput_mt_report_slot_state(md->input, MT_TOOL_FINGER,\n\t\t\t\t\ttrue);\n\t\t\tids[t] = true;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j <= CY_ABS_W_OST; j++) {\n\t\t\tsig = md->pdata->frmwrk->abs[((CY_ABS_X_OST + j) *\n\t\t\t\tCY_NUM_ABS_SET) + 0];\n\t\t\tif (sig != CY_IGNORE_VALUE)\n\t\t\t\tinput_report_abs(md->input, sig,\n\t\t\t\t\ttch.abs[CY_TCH_X + j]);\n\t\t}\n\t\tif (si->si_ofs.tch_rec_size > CY_TMA1036_TCH_REC_SIZE) {\n\t\t\t \n\t\t\tif (tch.abs[CY_TCH_P] > 0 && tch.abs[CY_TCH_MAJ] == 0)\n\t\t\t\ttch.abs[CY_TCH_MAJ] = tch.abs[CY_TCH_MIN] = 1;\n\n\t\t\t \n\t\t\tfor (j = 0; j < CY_NUM_EXT_TCH_FIELDS; j++) {\n\t\t\t\tsig = md->pdata->frmwrk->abs\n\t\t\t\t\t[((CY_ABS_MAJ_OST + j) *\n\t\t\t\t\tCY_NUM_ABS_SET) + 0];\n\t\t\t\tif (sig != CY_IGNORE_VALUE)\n\t\t\t\t\tinput_report_abs(md->input, sig,\n\t\t\t\t\t\ttch.abs[CY_TCH_MAJ + j]);\n\t\t\t}\n\t\t}\n\ncyttsp4_get_mt_touches_pr_tch:\n\t\tif (si->si_ofs.tch_rec_size > CY_TMA1036_TCH_REC_SIZE)\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s: t=%d x=%d y=%d z=%d M=%d m=%d o=%d e=%d\\n\",\n\t\t\t\t__func__, t,\n\t\t\t\ttch.abs[CY_TCH_X],\n\t\t\t\ttch.abs[CY_TCH_Y],\n\t\t\t\ttch.abs[CY_TCH_P],\n\t\t\t\ttch.abs[CY_TCH_MAJ],\n\t\t\t\ttch.abs[CY_TCH_MIN],\n\t\t\t\ttch.abs[CY_TCH_OR],\n\t\t\t\ttch.abs[CY_TCH_E]);\n\t\telse\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s: t=%d x=%d y=%d z=%d e=%d\\n\", __func__,\n\t\t\t\tt,\n\t\t\t\ttch.abs[CY_TCH_X],\n\t\t\t\ttch.abs[CY_TCH_Y],\n\t\t\t\ttch.abs[CY_TCH_P],\n\t\t\t\ttch.abs[CY_TCH_E]);\n\t}\n\n\tcyttsp4_final_sync(md->input, si->si_ofs.tch_abs[CY_TCH_T].max, ids);\n\n\tmd->num_prv_tch = num_cur_tch;\n\n\treturn;\n}\n\n \nstatic int cyttsp4_xy_worker(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_mt_data *md = &cd->md;\n\tstruct device *dev = &md->input->dev;\n\tstruct cyttsp4_sysinfo *si = md->si;\n\tu8 num_cur_tch;\n\tu8 hst_mode;\n\tu8 rep_len;\n\tu8 rep_stat;\n\tu8 tt_stat;\n\tint rc = 0;\n\n\t \n\t \n\thst_mode = si->xy_mode[CY_REG_BASE];\n\trep_len = si->xy_mode[si->si_ofs.rep_ofs];\n\trep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];\n\ttt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];\n\tdev_vdbg(dev, \"%s: %s%02X %s%d %s%02X %s%02X\\n\", __func__,\n\t\t\"hst_mode=\", hst_mode, \"rep_len=\", rep_len,\n\t\t\"rep_stat=\", rep_stat, \"tt_stat=\", tt_stat);\n\n\tnum_cur_tch = GET_NUM_TOUCHES(tt_stat);\n\tdev_vdbg(dev, \"%s: num_cur_tch=%d\\n\", __func__, num_cur_tch);\n\n\tif (rep_len == 0 && num_cur_tch > 0) {\n\t\tdev_err(dev, \"%s: report length error rep_len=%d num_tch=%d\\n\",\n\t\t\t__func__, rep_len, num_cur_tch);\n\t\tgoto cyttsp4_xy_worker_exit;\n\t}\n\n\t \n\tif (num_cur_tch > 0) {\n\t\trc = cyttsp4_adap_read(cd, si->si_ofs.tt_stat_ofs + 1,\n\t\t\t\tnum_cur_tch * si->si_ofs.tch_rec_size,\n\t\t\t\tsi->xy_data);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"%s: read fail on touch regs r=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto cyttsp4_xy_worker_exit;\n\t\t}\n\t}\n\n\t \n\tcyttsp4_pr_buf(dev, cd->pr_buf, si->xy_data, num_cur_tch *\n\t\tsi->si_ofs.tch_rec_size, \"xy_data\");\n\n\t \n\tif (IS_BAD_PKT(rep_stat)) {\n\t\tdev_dbg(dev, \"%s: Invalid buffer detected\\n\", __func__);\n\t\trc = 0;\n\t\tgoto cyttsp4_xy_worker_exit;\n\t}\n\n\tif (IS_LARGE_AREA(tt_stat))\n\t\tdev_dbg(dev, \"%s: Large area detected\\n\", __func__);\n\n\tif (num_cur_tch > si->si_ofs.max_tchs) {\n\t\tdev_err(dev, \"%s: too many tch; set to max tch (n=%d c=%zd)\\n\",\n\t\t\t\t__func__, num_cur_tch, si->si_ofs.max_tchs);\n\t\tnum_cur_tch = si->si_ofs.max_tchs;\n\t}\n\n\t \n\tdev_vdbg(dev, \"%s: extract data num_cur_tch=%d\\n\", __func__,\n\t\tnum_cur_tch);\n\tif (num_cur_tch)\n\t\tcyttsp4_get_mt_touches(md, num_cur_tch);\n\telse\n\t\tcyttsp4_lift_all(md);\n\n\trc = 0;\n\ncyttsp4_xy_worker_exit:\n\treturn rc;\n}\n\nstatic int cyttsp4_mt_attention(struct cyttsp4 *cd)\n{\n\tstruct device *dev = cd->dev;\n\tstruct cyttsp4_mt_data *md = &cd->md;\n\tint rc = 0;\n\n\tif (!md->si)\n\t\treturn 0;\n\n\tmutex_lock(&md->report_lock);\n\tif (!md->is_suspended) {\n\t\t \n\t\trc = cyttsp4_xy_worker(cd);\n\t} else {\n\t\tdev_vdbg(dev, \"%s: Ignoring report while suspended\\n\",\n\t\t\t__func__);\n\t}\n\tmutex_unlock(&md->report_lock);\n\tif (rc < 0)\n\t\tdev_err(dev, \"%s: xy_worker error r=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\nstatic irqreturn_t cyttsp4_irq(int irq, void *handle)\n{\n\tstruct cyttsp4 *cd = handle;\n\tstruct device *dev = cd->dev;\n\tenum cyttsp4_mode cur_mode;\n\tu8 cmd_ofs = cd->sysinfo.si_ofs.cmd_ofs;\n\tu8 mode[3];\n\tint rc;\n\n\t \n\tif (atomic_read(&cd->ignore_irq)) {\n\t\tdev_vdbg(dev, \"%s: Ignoring IRQ\\n\", __func__);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdev_dbg(dev, \"%s int:0x%x\\n\", __func__, cd->int_status);\n\n\tmutex_lock(&cd->system_lock);\n\n\t \n\tif (cd->sleep_state == SS_SLEEP_ON || cd->sleep_state == SS_SLEEPING)\n\t\tdev_vdbg(dev, \"%s: Received IRQ while in sleep\\n\", __func__);\n\n\trc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), mode);\n\tif (rc) {\n\t\tdev_err(cd->dev, \"%s: Fail read adapter r=%d\\n\", __func__, rc);\n\t\tgoto cyttsp4_irq_exit;\n\t}\n\tdev_vdbg(dev, \"%s mode[0-2]:0x%X 0x%X 0x%X\\n\", __func__,\n\t\t\tmode[0], mode[1], mode[2]);\n\n\tif (IS_BOOTLOADER(mode[0], mode[1])) {\n\t\tcur_mode = CY_MODE_BOOTLOADER;\n\t\tdev_vdbg(dev, \"%s: bl running\\n\", __func__);\n\t\tif (cd->mode == CY_MODE_BOOTLOADER) {\n\t\t\t \n\t\t\twake_up(&cd->wait_q);\n\t\t\tgoto cyttsp4_irq_exit;\n\t\t}\n\n\t\t \n\t\tdev_dbg(dev, \"%s: restart switch to bl m=%d -> m=%d\\n\",\n\t\t\t__func__, cd->mode, cur_mode);\n\n\t\t \n\t\tif (cd->mode != CY_MODE_UNKNOWN) {\n\t\t\t \n\t\t\tcd->mode = CY_MODE_UNKNOWN;\n\t\t\tcyttsp4_queue_startup_(cd);\n\t\t\tgoto cyttsp4_irq_exit;\n\t\t}\n\n\t\t \n\t\tcd->mode = cur_mode;\n\n\t\tgoto cyttsp4_irq_exit;\n\t}\n\n\tswitch (mode[0] & CY_HST_MODE) {\n\tcase CY_HST_OPERATE:\n\t\tcur_mode = CY_MODE_OPERATIONAL;\n\t\tdev_vdbg(dev, \"%s: operational\\n\", __func__);\n\t\tbreak;\n\tcase CY_HST_CAT:\n\t\tcur_mode = CY_MODE_CAT;\n\t\tdev_vdbg(dev, \"%s: CaT\\n\", __func__);\n\t\tbreak;\n\tcase CY_HST_SYSINFO:\n\t\tcur_mode = CY_MODE_SYSINFO;\n\t\tdev_vdbg(dev, \"%s: sysinfo\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tcur_mode = CY_MODE_UNKNOWN;\n\t\tdev_err(dev, \"%s: unknown HST mode 0x%02X\\n\", __func__,\n\t\t\tmode[0]);\n\t\tbreak;\n\t}\n\n\t \n\tif (cd->int_status & CY_INT_IGNORE) {\n\t\tdev_vdbg(dev, \"%s: Ignoring IRQ\\n\", __func__);\n\t\tgoto cyttsp4_irq_exit;\n\t}\n\n\t \n\tif (cd->int_status & CY_INT_AWAKE) {\n\t\tcd->int_status &= ~CY_INT_AWAKE;\n\t\twake_up(&cd->wait_q);\n\t\tdev_vdbg(dev, \"%s: Received wake up interrupt\\n\", __func__);\n\t\tgoto cyttsp4_irq_handshake;\n\t}\n\n\t \n\tif ((cd->int_status & CY_INT_MODE_CHANGE)\n\t\t\t&& (mode[0] & CY_HST_MODE_CHANGE) == 0) {\n\t\tcd->int_status &= ~CY_INT_MODE_CHANGE;\n\t\tdev_dbg(dev, \"%s: finish mode switch m=%d -> m=%d\\n\",\n\t\t\t\t__func__, cd->mode, cur_mode);\n\t\tcd->mode = cur_mode;\n\t\twake_up(&cd->wait_q);\n\t\tgoto cyttsp4_irq_handshake;\n\t}\n\n\t \n\tdev_vdbg(dev, \"%s: cd->mode=%d cur_mode=%d\\n\",\n\t\t\t__func__, cd->mode, cur_mode);\n\tif ((mode[0] & CY_HST_MODE_CHANGE) == 0 && cd->mode != cur_mode) {\n\t\t \n\t\tdev_err(dev, \"%s %d->%d 0x%x\\n\", __func__, cd->mode,\n\t\t\t\tcur_mode, cd->int_status);\n\t\tdev_dbg(dev, \"%s: Unexpected mode change, startup\\n\",\n\t\t\t\t__func__);\n\t\tcyttsp4_queue_startup_(cd);\n\t\tgoto cyttsp4_irq_exit;\n\t}\n\n\t \n\tdev_vdbg(dev, \"%s: command byte:0x%x\\n\", __func__, mode[cmd_ofs]);\n\tif ((cd->int_status & CY_INT_EXEC_CMD)\n\t\t\t&& mode[cmd_ofs] & CY_CMD_COMPLETE) {\n\t\tcd->int_status &= ~CY_INT_EXEC_CMD;\n\t\tdev_vdbg(dev, \"%s: Received command complete interrupt\\n\",\n\t\t\t\t__func__);\n\t\twake_up(&cd->wait_q);\n\t\t \n\t}\n\n\t \n\tif (cd->mode == CY_MODE_OPERATIONAL) {\n\t\tdev_vdbg(dev, \"%s: Read status registers\\n\", __func__);\n\t\trc = cyttsp4_load_status_regs(cd);\n\t\tif (rc < 0)\n\t\t\tdev_err(dev, \"%s: fail read mode regs r=%d\\n\",\n\t\t\t\t__func__, rc);\n\t}\n\n\tcyttsp4_mt_attention(cd);\n\ncyttsp4_irq_handshake:\n\t \n\tdev_vdbg(dev, \"%s: Handshake mode=0x%02X r=%d\\n\",\n\t\t\t__func__, mode[0], rc);\n\trc = cyttsp4_handshake(cd, mode[0]);\n\tif (rc < 0)\n\t\tdev_err(dev, \"%s: Fail handshake mode=0x%02X r=%d\\n\",\n\t\t\t\t__func__, mode[0], rc);\n\n\t \n\tudelay(cd->cpdata->level_irq_udelay);\n\ncyttsp4_irq_exit:\n\tmutex_unlock(&cd->system_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void cyttsp4_start_wd_timer(struct cyttsp4 *cd)\n{\n\tif (!CY_WATCHDOG_TIMEOUT)\n\t\treturn;\n\n\tmod_timer(&cd->watchdog_timer, jiffies +\n\t\t\tmsecs_to_jiffies(CY_WATCHDOG_TIMEOUT));\n}\n\nstatic void cyttsp4_stop_wd_timer(struct cyttsp4 *cd)\n{\n\tif (!CY_WATCHDOG_TIMEOUT)\n\t\treturn;\n\n\t \n\ttimer_shutdown_sync(&cd->watchdog_timer);\n\tcancel_work_sync(&cd->watchdog_work);\n}\n\nstatic void cyttsp4_watchdog_timer(struct timer_list *t)\n{\n\tstruct cyttsp4 *cd = from_timer(cd, t, watchdog_timer);\n\n\tdev_vdbg(cd->dev, \"%s: Watchdog timer triggered\\n\", __func__);\n\n\tschedule_work(&cd->watchdog_work);\n\n\treturn;\n}\n\nstatic int cyttsp4_request_exclusive(struct cyttsp4 *cd, void *ownptr,\n\t\tint timeout_ms)\n{\n\tint t = msecs_to_jiffies(timeout_ms);\n\tbool with_timeout = (timeout_ms != 0);\n\n\tmutex_lock(&cd->system_lock);\n\tif (!cd->exclusive_dev && cd->exclusive_waits == 0) {\n\t\tcd->exclusive_dev = ownptr;\n\t\tgoto exit;\n\t}\n\n\tcd->exclusive_waits++;\nwait:\n\tmutex_unlock(&cd->system_lock);\n\tif (with_timeout) {\n\t\tt = wait_event_timeout(cd->wait_q, !cd->exclusive_dev, t);\n\t\tif (IS_TMO(t)) {\n\t\t\tdev_err(cd->dev, \"%s: tmo waiting exclusive access\\n\",\n\t\t\t\t__func__);\n\t\t\tmutex_lock(&cd->system_lock);\n\t\t\tcd->exclusive_waits--;\n\t\t\tmutex_unlock(&cd->system_lock);\n\t\t\treturn -ETIME;\n\t\t}\n\t} else {\n\t\twait_event(cd->wait_q, !cd->exclusive_dev);\n\t}\n\tmutex_lock(&cd->system_lock);\n\tif (cd->exclusive_dev)\n\t\tgoto wait;\n\tcd->exclusive_dev = ownptr;\n\tcd->exclusive_waits--;\nexit:\n\tmutex_unlock(&cd->system_lock);\n\n\treturn 0;\n}\n\n \nstatic int cyttsp4_release_exclusive(struct cyttsp4 *cd, void *ownptr)\n{\n\tmutex_lock(&cd->system_lock);\n\tif (cd->exclusive_dev != ownptr) {\n\t\tmutex_unlock(&cd->system_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_vdbg(cd->dev, \"%s: exclusive_dev %p freed\\n\",\n\t\t__func__, cd->exclusive_dev);\n\tcd->exclusive_dev = NULL;\n\twake_up(&cd->wait_q);\n\tmutex_unlock(&cd->system_lock);\n\treturn 0;\n}\n\nstatic int cyttsp4_wait_bl_heartbeat(struct cyttsp4 *cd)\n{\n\tlong t;\n\tint rc = 0;\n\n\t \n\tdev_vdbg(cd->dev, \"%s: wait heartbeat...\\n\", __func__);\n\tt = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_BOOTLOADER,\n\t\t\tmsecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));\n\tif (IS_TMO(t)) {\n\t\tdev_err(cd->dev, \"%s: tmo waiting bl heartbeat cd->mode=%d\\n\",\n\t\t\t__func__, cd->mode);\n\t\trc = -ETIME;\n\t}\n\n\treturn rc;\n}\n\nstatic int cyttsp4_wait_sysinfo_mode(struct cyttsp4 *cd)\n{\n\tlong t;\n\n\tdev_vdbg(cd->dev, \"%s: wait sysinfo...\\n\", __func__);\n\n\tt = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_SYSINFO,\n\t\t\tmsecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));\n\tif (IS_TMO(t)) {\n\t\tdev_err(cd->dev, \"%s: tmo waiting exit bl cd->mode=%d\\n\",\n\t\t\t__func__, cd->mode);\n\t\tmutex_lock(&cd->system_lock);\n\t\tcd->int_status &= ~CY_INT_MODE_CHANGE;\n\t\tmutex_unlock(&cd->system_lock);\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyttsp4_reset_and_wait(struct cyttsp4 *cd)\n{\n\tint rc;\n\n\t \n\tmutex_lock(&cd->system_lock);\n\tdev_dbg(cd->dev, \"%s: reset hw...\\n\", __func__);\n\trc = cyttsp4_hw_reset(cd);\n\tcd->mode = CY_MODE_UNKNOWN;\n\tmutex_unlock(&cd->system_lock);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s:Fail hw reset r=%d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn cyttsp4_wait_bl_heartbeat(cd);\n}\n\n \nstatic int cyttsp4_set_mode(struct cyttsp4 *cd, int new_mode)\n{\n\tu8 new_dev_mode;\n\tu8 mode;\n\tlong t;\n\tint rc;\n\n\tswitch (new_mode) {\n\tcase CY_MODE_OPERATIONAL:\n\t\tnew_dev_mode = CY_HST_OPERATE;\n\t\tbreak;\n\tcase CY_MODE_SYSINFO:\n\t\tnew_dev_mode = CY_HST_SYSINFO;\n\t\tbreak;\n\tcase CY_MODE_CAT:\n\t\tnew_dev_mode = CY_HST_CAT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cd->dev, \"%s: invalid mode: %02X(%d)\\n\",\n\t\t\t__func__, new_mode, new_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev_dbg(cd->dev, \"%s: %s=%p new_dev_mode=%02X new_mode=%d\\n\",\n\t\t\t__func__, \"have exclusive\", cd->exclusive_dev,\n\t\t\tnew_dev_mode, new_mode);\n\n\tmutex_lock(&cd->system_lock);\n\trc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), &mode);\n\tif (rc < 0) {\n\t\tmutex_unlock(&cd->system_lock);\n\t\tdev_err(cd->dev, \"%s: Fail read mode r=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto exit;\n\t}\n\n\t \n\tmode &= ~CY_HST_MODE;\n\tmode |= new_dev_mode | CY_HST_MODE_CHANGE;\n\n\tcd->int_status |= CY_INT_MODE_CHANGE;\n\trc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(mode), &mode);\n\tmutex_unlock(&cd->system_lock);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: Fail write mode change r=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\tgoto exit;\n\t}\n\n\t \n\tt = wait_event_timeout(cd->wait_q,\n\t\t\t(cd->int_status & CY_INT_MODE_CHANGE) == 0,\n\t\t\tmsecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));\n\tdev_dbg(cd->dev, \"%s: back from wait t=%ld cd->mode=%d\\n\",\n\t\t\t__func__, t, cd->mode);\n\n\tif (IS_TMO(t)) {\n\t\tdev_err(cd->dev, \"%s: %s\\n\", __func__,\n\t\t\t\t\"tmo waiting mode change\");\n\t\tmutex_lock(&cd->system_lock);\n\t\tcd->int_status &= ~CY_INT_MODE_CHANGE;\n\t\tmutex_unlock(&cd->system_lock);\n\t\trc = -EINVAL;\n\t}\n\nexit:\n\treturn rc;\n}\n\nstatic void cyttsp4_watchdog_work(struct work_struct *work)\n{\n\tstruct cyttsp4 *cd =\n\t\tcontainer_of(work, struct cyttsp4, watchdog_work);\n\tu8 *mode;\n\tint retval;\n\n\tmutex_lock(&cd->system_lock);\n\tretval = cyttsp4_load_status_regs(cd);\n\tif (retval < 0) {\n\t\tdev_err(cd->dev,\n\t\t\t\"%s: failed to access device in watchdog timer r=%d\\n\",\n\t\t\t__func__, retval);\n\t\tcyttsp4_queue_startup_(cd);\n\t\tgoto cyttsp4_timer_watchdog_exit_error;\n\t}\n\tmode = &cd->sysinfo.xy_mode[CY_REG_BASE];\n\tif (IS_BOOTLOADER(mode[0], mode[1])) {\n\t\tdev_err(cd->dev,\n\t\t\t\"%s: device found in bootloader mode when operational mode\\n\",\n\t\t\t__func__);\n\t\tcyttsp4_queue_startup_(cd);\n\t\tgoto cyttsp4_timer_watchdog_exit_error;\n\t}\n\n\tcyttsp4_start_wd_timer(cd);\ncyttsp4_timer_watchdog_exit_error:\n\tmutex_unlock(&cd->system_lock);\n\treturn;\n}\n\nstatic int cyttsp4_core_sleep_(struct cyttsp4 *cd)\n{\n\tenum cyttsp4_sleep_state ss = SS_SLEEP_ON;\n\tenum cyttsp4_int_state int_status = CY_INT_IGNORE;\n\tint rc = 0;\n\tu8 mode[2];\n\n\t \n\tmutex_lock(&cd->system_lock);\n\tif (cd->sleep_state == SS_SLEEP_ON) {\n\t\tmutex_unlock(&cd->system_lock);\n\t\treturn 0;\n\t}\n\tcd->sleep_state = SS_SLEEPING;\n\tmutex_unlock(&cd->system_lock);\n\n\tcyttsp4_stop_wd_timer(cd);\n\n\t \n\tdisable_irq(cd->irq);\n\n\tdev_vdbg(cd->dev, \"%s: write DEEP SLEEP...\\n\", __func__);\n\tmutex_lock(&cd->system_lock);\n\trc = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), &mode);\n\tif (rc) {\n\t\tmutex_unlock(&cd->system_lock);\n\t\tdev_err(cd->dev, \"%s: Fail read adapter r=%d\\n\", __func__, rc);\n\t\tgoto error;\n\t}\n\n\tif (IS_BOOTLOADER(mode[0], mode[1])) {\n\t\tmutex_unlock(&cd->system_lock);\n\t\tdev_err(cd->dev, \"%s: Device in BOOTLOADER mode.\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tmode[0] |= CY_HST_SLEEP;\n\trc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(mode[0]), &mode[0]);\n\tmutex_unlock(&cd->system_lock);\n\tif (rc) {\n\t\tdev_err(cd->dev, \"%s: Fail write adapter r=%d\\n\", __func__, rc);\n\t\tgoto error;\n\t}\n\tdev_vdbg(cd->dev, \"%s: write DEEP SLEEP succeeded\\n\", __func__);\n\n\tif (cd->cpdata->power) {\n\t\tdev_dbg(cd->dev, \"%s: Power down HW\\n\", __func__);\n\t\trc = cd->cpdata->power(cd->cpdata, 0, cd->dev, &cd->ignore_irq);\n\t} else {\n\t\tdev_dbg(cd->dev, \"%s: No power function\\n\", __func__);\n\t\trc = 0;\n\t}\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: HW Power down fails r=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\tgoto error;\n\t}\n\n\t \n\tmsleep(50);\n\n\tgoto exit;\n\nerror:\n\tss = SS_SLEEP_OFF;\n\tint_status = CY_INT_NONE;\n\tcyttsp4_start_wd_timer(cd);\n\nexit:\n\tmutex_lock(&cd->system_lock);\n\tcd->sleep_state = ss;\n\tcd->int_status |= int_status;\n\tmutex_unlock(&cd->system_lock);\n\tenable_irq(cd->irq);\n\treturn rc;\n}\n\nstatic int cyttsp4_startup_(struct cyttsp4 *cd)\n{\n\tint retry = CY_CORE_STARTUP_RETRY_COUNT;\n\tint rc;\n\n\tcyttsp4_stop_wd_timer(cd);\n\nreset:\n\tif (retry != CY_CORE_STARTUP_RETRY_COUNT)\n\t\tdev_dbg(cd->dev, \"%s: Retry %d\\n\", __func__,\n\t\t\tCY_CORE_STARTUP_RETRY_COUNT - retry);\n\n\t \n\trc = cyttsp4_reset_and_wait(cd);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: Error on h/w reset r=%d\\n\", __func__, rc);\n\t\tif (retry--)\n\t\t\tgoto reset;\n\t\tgoto exit;\n\t}\n\n\t \n\tdev_vdbg(cd->dev, \"%s: write exit ldr...\\n\", __func__);\n\tmutex_lock(&cd->system_lock);\n\tcd->int_status &= ~CY_INT_IGNORE;\n\tcd->int_status |= CY_INT_MODE_CHANGE;\n\n\trc = cyttsp4_adap_write(cd, CY_REG_BASE, sizeof(ldr_exit),\n\t\t\t(u8 *)ldr_exit);\n\tmutex_unlock(&cd->system_lock);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: Fail write r=%d\\n\", __func__, rc);\n\t\tif (retry--)\n\t\t\tgoto reset;\n\t\tgoto exit;\n\t}\n\n\trc = cyttsp4_wait_sysinfo_mode(cd);\n\tif (rc < 0) {\n\t\tu8 buf[sizeof(ldr_err_app)];\n\t\tint rc1;\n\n\t\t \n\t\trc1 = cyttsp4_adap_read(cd, CY_REG_BASE, sizeof(ldr_err_app),\n\t\t\t\tbuf);\n\t\tif (rc1) {\n\t\t\tdev_err(cd->dev, \"%s: Fail read r=%d\\n\", __func__, rc1);\n\t\t} else if (!memcmp(buf, ldr_err_app, sizeof(ldr_err_app))) {\n\t\t\tdev_err(cd->dev, \"%s: Error launching touch application\\n\",\n\t\t\t\t__func__);\n\t\t\tmutex_lock(&cd->system_lock);\n\t\t\tcd->invalid_touch_app = true;\n\t\t\tmutex_unlock(&cd->system_lock);\n\t\t\tgoto exit_no_wd;\n\t\t}\n\n\t\tif (retry--)\n\t\t\tgoto reset;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&cd->system_lock);\n\tcd->invalid_touch_app = false;\n\tmutex_unlock(&cd->system_lock);\n\n\t \n\tdev_vdbg(cd->dev, \"%s: get sysinfo regs..\\n\", __func__);\n\trc = cyttsp4_get_sysinfo_regs(cd);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: failed to get sysinfo regs rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tif (retry--)\n\t\t\tgoto reset;\n\t\tgoto exit;\n\t}\n\n\trc = cyttsp4_set_mode(cd, CY_MODE_OPERATIONAL);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: failed to set mode to operational rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tif (retry--)\n\t\t\tgoto reset;\n\t\tgoto exit;\n\t}\n\n\tcyttsp4_lift_all(&cd->md);\n\n\t \n\tmutex_lock(&cd->system_lock);\n\tif (cd->sleep_state == SS_SLEEP_ON) {\n\t\tcd->sleep_state = SS_SLEEP_OFF;\n\t\tmutex_unlock(&cd->system_lock);\n\t\tcyttsp4_core_sleep_(cd);\n\t\tgoto exit_no_wd;\n\t}\n\tmutex_unlock(&cd->system_lock);\n\nexit:\n\tcyttsp4_start_wd_timer(cd);\nexit_no_wd:\n\treturn rc;\n}\n\nstatic int cyttsp4_startup(struct cyttsp4 *cd)\n{\n\tint rc;\n\n\tmutex_lock(&cd->system_lock);\n\tcd->startup_state = STARTUP_RUNNING;\n\tmutex_unlock(&cd->system_lock);\n\n\trc = cyttsp4_request_exclusive(cd, cd->dev,\n\t\t\tCY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail get exclusive ex=%p own=%p\\n\",\n\t\t\t\t__func__, cd->exclusive_dev, cd->dev);\n\t\tgoto exit;\n\t}\n\n\trc = cyttsp4_startup_(cd);\n\n\tif (cyttsp4_release_exclusive(cd, cd->dev) < 0)\n\t\t \n\t\tdev_err(cd->dev, \"%s: fail to release exclusive\\n\", __func__);\n\telse\n\t\tdev_vdbg(cd->dev, \"%s: pass release exclusive\\n\", __func__);\n\nexit:\n\tmutex_lock(&cd->system_lock);\n\tcd->startup_state = STARTUP_NONE;\n\tmutex_unlock(&cd->system_lock);\n\n\t \n\twake_up(&cd->wait_q);\n\n\treturn rc;\n}\n\nstatic void cyttsp4_startup_work_function(struct work_struct *work)\n{\n\tstruct cyttsp4 *cd =  container_of(work, struct cyttsp4, startup_work);\n\tint rc;\n\n\trc = cyttsp4_startup(cd);\n\tif (rc < 0)\n\t\tdev_err(cd->dev, \"%s: Fail queued startup r=%d\\n\",\n\t\t\t__func__, rc);\n}\n\nstatic void cyttsp4_free_si_ptrs(struct cyttsp4 *cd)\n{\n\tstruct cyttsp4_sysinfo *si = &cd->sysinfo;\n\n\tif (!si)\n\t\treturn;\n\n\tkfree(si->si_ptrs.cydata);\n\tkfree(si->si_ptrs.test);\n\tkfree(si->si_ptrs.pcfg);\n\tkfree(si->si_ptrs.opcfg);\n\tkfree(si->si_ptrs.ddata);\n\tkfree(si->si_ptrs.mdata);\n\tkfree(si->btn);\n\tkfree(si->xy_mode);\n\tkfree(si->xy_data);\n\tkfree(si->btn_rec_data);\n}\n\nstatic int cyttsp4_core_sleep(struct cyttsp4 *cd)\n{\n\tint rc;\n\n\trc = cyttsp4_request_exclusive(cd, cd->dev,\n\t\t\tCY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail get exclusive ex=%p own=%p\\n\",\n\t\t\t\t__func__, cd->exclusive_dev, cd->dev);\n\t\treturn 0;\n\t}\n\n\trc = cyttsp4_core_sleep_(cd);\n\n\tif (cyttsp4_release_exclusive(cd, cd->dev) < 0)\n\t\tdev_err(cd->dev, \"%s: fail to release exclusive\\n\", __func__);\n\telse\n\t\tdev_vdbg(cd->dev, \"%s: pass release exclusive\\n\", __func__);\n\n\treturn rc;\n}\n\nstatic int cyttsp4_core_wake_(struct cyttsp4 *cd)\n{\n\tstruct device *dev = cd->dev;\n\tint rc;\n\tu8 mode;\n\tint t;\n\n\t \n\tmutex_lock(&cd->system_lock);\n\tif (cd->sleep_state == SS_SLEEP_OFF) {\n\t\tmutex_unlock(&cd->system_lock);\n\t\treturn 0;\n\t}\n\tcd->int_status &= ~CY_INT_IGNORE;\n\tcd->int_status |= CY_INT_AWAKE;\n\tcd->sleep_state = SS_WAKING;\n\n\tif (cd->cpdata->power) {\n\t\tdev_dbg(dev, \"%s: Power up HW\\n\", __func__);\n\t\trc = cd->cpdata->power(cd->cpdata, 1, dev, &cd->ignore_irq);\n\t} else {\n\t\tdev_dbg(dev, \"%s: No power function\\n\", __func__);\n\t\trc = -ENOSYS;\n\t}\n\tif (rc < 0) {\n\t\tdev_err(dev, \"%s: HW Power up fails r=%d\\n\",\n\t\t\t\t__func__, rc);\n\n\t\t \n\t\tcyttsp4_adap_read(cd, CY_REG_BASE, sizeof(mode), &mode);\n\t} else\n\t\tdev_vdbg(cd->dev, \"%s: HW power up succeeds\\n\",\n\t\t\t__func__);\n\tmutex_unlock(&cd->system_lock);\n\n\tt = wait_event_timeout(cd->wait_q,\n\t\t\t(cd->int_status & CY_INT_AWAKE) == 0,\n\t\t\tmsecs_to_jiffies(CY_CORE_WAKEUP_TIMEOUT));\n\tif (IS_TMO(t)) {\n\t\tdev_err(dev, \"%s: TMO waiting for wakeup\\n\", __func__);\n\t\tmutex_lock(&cd->system_lock);\n\t\tcd->int_status &= ~CY_INT_AWAKE;\n\t\t \n\t\tcyttsp4_queue_startup_(cd);\n\t\tmutex_unlock(&cd->system_lock);\n\t}\n\n\tmutex_lock(&cd->system_lock);\n\tcd->sleep_state = SS_SLEEP_OFF;\n\tmutex_unlock(&cd->system_lock);\n\n\tcyttsp4_start_wd_timer(cd);\n\n\treturn 0;\n}\n\nstatic int cyttsp4_core_wake(struct cyttsp4 *cd)\n{\n\tint rc;\n\n\trc = cyttsp4_request_exclusive(cd, cd->dev,\n\t\t\tCY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(cd->dev, \"%s: fail get exclusive ex=%p own=%p\\n\",\n\t\t\t\t__func__, cd->exclusive_dev, cd->dev);\n\t\treturn 0;\n\t}\n\n\trc = cyttsp4_core_wake_(cd);\n\n\tif (cyttsp4_release_exclusive(cd, cd->dev) < 0)\n\t\tdev_err(cd->dev, \"%s: fail to release exclusive\\n\", __func__);\n\telse\n\t\tdev_vdbg(cd->dev, \"%s: pass release exclusive\\n\", __func__);\n\n\treturn rc;\n}\n\nstatic int cyttsp4_core_suspend(struct device *dev)\n{\n\tstruct cyttsp4 *cd = dev_get_drvdata(dev);\n\tstruct cyttsp4_mt_data *md = &cd->md;\n\tint rc;\n\n\tmd->is_suspended = true;\n\n\trc = cyttsp4_core_sleep(cd);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"%s: Error on sleep\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int cyttsp4_core_resume(struct device *dev)\n{\n\tstruct cyttsp4 *cd = dev_get_drvdata(dev);\n\tstruct cyttsp4_mt_data *md = &cd->md;\n\tint rc;\n\n\tmd->is_suspended = false;\n\n\trc = cyttsp4_core_wake(cd);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"%s: Error on wake\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nEXPORT_GPL_RUNTIME_DEV_PM_OPS(cyttsp4_pm_ops,\n\t\t\t      cyttsp4_core_suspend, cyttsp4_core_resume, NULL);\n\nstatic int cyttsp4_mt_open(struct input_dev *input)\n{\n\tpm_runtime_get(input->dev.parent);\n\treturn 0;\n}\n\nstatic void cyttsp4_mt_close(struct input_dev *input)\n{\n\tstruct cyttsp4_mt_data *md = input_get_drvdata(input);\n\tmutex_lock(&md->report_lock);\n\tif (!md->is_suspended)\n\t\tpm_runtime_put(input->dev.parent);\n\tmutex_unlock(&md->report_lock);\n}\n\n\nstatic int cyttsp4_setup_input_device(struct cyttsp4 *cd)\n{\n\tstruct device *dev = cd->dev;\n\tstruct cyttsp4_mt_data *md = &cd->md;\n\tint signal = CY_IGNORE_VALUE;\n\tint max_x, max_y, max_p, min, max;\n\tint max_x_tmp, max_y_tmp;\n\tint i;\n\tint rc;\n\n\tdev_vdbg(dev, \"%s: Initialize event signals\\n\", __func__);\n\t__set_bit(EV_ABS, md->input->evbit);\n\t__set_bit(EV_REL, md->input->evbit);\n\t__set_bit(EV_KEY, md->input->evbit);\n\n\tmax_x_tmp = md->si->si_ofs.max_x;\n\tmax_y_tmp = md->si->si_ofs.max_y;\n\n\t \n\tif (md->pdata->flags & CY_FLAG_FLIP) {\n\t\tmax_x = max_y_tmp - 1;\n\t\tmax_y = max_x_tmp - 1;\n\t} else {\n\t\tmax_x = max_x_tmp - 1;\n\t\tmax_y = max_y_tmp - 1;\n\t}\n\tmax_p = md->si->si_ofs.max_p;\n\n\t \n\tfor (i = 0; i < (md->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {\n\t\tsignal = md->pdata->frmwrk->abs\n\t\t\t[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];\n\t\tif (signal != CY_IGNORE_VALUE) {\n\t\t\t__set_bit(signal, md->input->absbit);\n\t\t\tmin = md->pdata->frmwrk->abs\n\t\t\t\t[(i * CY_NUM_ABS_SET) + CY_MIN_OST];\n\t\t\tmax = md->pdata->frmwrk->abs\n\t\t\t\t[(i * CY_NUM_ABS_SET) + CY_MAX_OST];\n\t\t\tif (i == CY_ABS_ID_OST) {\n\t\t\t\t \n\t\t\t\tmax = max - min;\n\t\t\t\tmin = min - min;\n\t\t\t} else if (i == CY_ABS_X_OST)\n\t\t\t\tmax = max_x;\n\t\t\telse if (i == CY_ABS_Y_OST)\n\t\t\t\tmax = max_y;\n\t\t\telse if (i == CY_ABS_P_OST)\n\t\t\t\tmax = max_p;\n\t\t\tinput_set_abs_params(md->input, signal, min, max,\n\t\t\t\tmd->pdata->frmwrk->abs\n\t\t\t\t[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],\n\t\t\t\tmd->pdata->frmwrk->abs\n\t\t\t\t[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);\n\t\t\tdev_dbg(dev, \"%s: register signal=%02X min=%d max=%d\\n\",\n\t\t\t\t__func__, signal, min, max);\n\t\t\tif ((i == CY_ABS_ID_OST) &&\n\t\t\t\t(md->si->si_ofs.tch_rec_size <\n\t\t\t\tCY_TMA4XX_TCH_REC_SIZE))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tinput_mt_init_slots(md->input, md->si->si_ofs.tch_abs[CY_TCH_T].max,\n\t\t\tINPUT_MT_DIRECT);\n\trc = input_register_device(md->input);\n\tif (rc < 0)\n\t\tdev_err(dev, \"%s: Error, failed register input device r=%d\\n\",\n\t\t\t__func__, rc);\n\treturn rc;\n}\n\nstatic int cyttsp4_mt_probe(struct cyttsp4 *cd)\n{\n\tstruct device *dev = cd->dev;\n\tstruct cyttsp4_mt_data *md = &cd->md;\n\tstruct cyttsp4_mt_platform_data *pdata = cd->pdata->mt_pdata;\n\tint rc = 0;\n\n\tmutex_init(&md->report_lock);\n\tmd->pdata = pdata;\n\t \n\tdev_vdbg(dev, \"%s: Create the input device and register it\\n\",\n\t\t__func__);\n\tmd->input = input_allocate_device();\n\tif (md->input == NULL) {\n\t\tdev_err(dev, \"%s: Error, failed to allocate input device\\n\",\n\t\t\t__func__);\n\t\trc = -ENOSYS;\n\t\tgoto error_alloc_failed;\n\t}\n\n\tmd->input->name = pdata->inp_dev_name;\n\tscnprintf(md->phys, sizeof(md->phys)-1, \"%s\", dev_name(dev));\n\tmd->input->phys = md->phys;\n\tmd->input->id.bustype = cd->bus_ops->bustype;\n\tmd->input->dev.parent = dev;\n\tmd->input->open = cyttsp4_mt_open;\n\tmd->input->close = cyttsp4_mt_close;\n\tinput_set_drvdata(md->input, md);\n\n\t \n\tmd->si = &cd->sysinfo;\n\n\trc = cyttsp4_setup_input_device(cd);\n\tif (rc)\n\t\tgoto error_init_input;\n\n\treturn 0;\n\nerror_init_input:\n\tinput_free_device(md->input);\nerror_alloc_failed:\n\tdev_err(dev, \"%s failed.\\n\", __func__);\n\treturn rc;\n}\n\nstruct cyttsp4 *cyttsp4_probe(const struct cyttsp4_bus_ops *ops,\n\t\tstruct device *dev, u16 irq, size_t xfer_buf_size)\n{\n\tstruct cyttsp4 *cd;\n\tstruct cyttsp4_platform_data *pdata = dev_get_platdata(dev);\n\tunsigned long irq_flags;\n\tint rc = 0;\n\n\tif (!pdata || !pdata->core_pdata || !pdata->mt_pdata) {\n\t\tdev_err(dev, \"%s: Missing platform data\\n\", __func__);\n\t\trc = -ENODEV;\n\t\tgoto error_no_pdata;\n\t}\n\n\tcd = kzalloc(sizeof(*cd), GFP_KERNEL);\n\tif (!cd) {\n\t\tdev_err(dev, \"%s: Error, kzalloc\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto error_alloc_data;\n\t}\n\n\tcd->xfer_buf = kzalloc(xfer_buf_size, GFP_KERNEL);\n\tif (!cd->xfer_buf) {\n\t\tdev_err(dev, \"%s: Error, kzalloc\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto error_free_cd;\n\t}\n\n\t \n\tcd->dev = dev;\n\tcd->pdata = pdata;\n\tcd->cpdata = pdata->core_pdata;\n\tcd->bus_ops = ops;\n\n\t \n\tmutex_init(&cd->system_lock);\n\tmutex_init(&cd->adap_lock);\n\n\t \n\tinit_waitqueue_head(&cd->wait_q);\n\n\t \n\tINIT_WORK(&cd->startup_work, cyttsp4_startup_work_function);\n\tINIT_WORK(&cd->watchdog_work, cyttsp4_watchdog_work);\n\n\t \n\tcd->irq = gpio_to_irq(cd->cpdata->irq_gpio);\n\tif (cd->irq < 0) {\n\t\trc = -EINVAL;\n\t\tgoto error_free_xfer;\n\t}\n\n\tdev_set_drvdata(dev, cd);\n\n\t \n\tif (cd->cpdata->init) {\n\t\tdev_dbg(cd->dev, \"%s: Init HW\\n\", __func__);\n\t\trc = cd->cpdata->init(cd->cpdata, 1, cd->dev);\n\t} else {\n\t\tdev_dbg(cd->dev, \"%s: No HW INIT function\\n\", __func__);\n\t\trc = 0;\n\t}\n\tif (rc < 0)\n\t\tdev_err(cd->dev, \"%s: HW Init fail r=%d\\n\", __func__, rc);\n\n\tdev_dbg(dev, \"%s: initialize threaded irq=%d\\n\", __func__, cd->irq);\n\tif (cd->cpdata->level_irq_udelay > 0)\n\t\t \n\t\tirq_flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;\n\telse\n\t\t \n\t\tirq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\n\n\trc = request_threaded_irq(cd->irq, NULL, cyttsp4_irq, irq_flags,\n\t\tdev_name(dev), cd);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"%s: Error, could not request irq\\n\", __func__);\n\t\tgoto error_request_irq;\n\t}\n\n\t \n\ttimer_setup(&cd->watchdog_timer, cyttsp4_watchdog_timer, 0);\n\n\t \n\trc = cyttsp4_startup(cd);\n\n\t \n\tif (rc < 0 && cd->mode == CY_MODE_UNKNOWN) {\n\t\tdev_err(cd->dev, \"%s: Fail initial startup r=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto error_startup;\n\t}\n\n\trc = cyttsp4_mt_probe(cd);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"%s: Error, fail mt probe\\n\", __func__);\n\t\tgoto error_startup;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn cd;\n\nerror_startup:\n\tcancel_work_sync(&cd->startup_work);\n\tcyttsp4_stop_wd_timer(cd);\n\tpm_runtime_disable(dev);\n\tcyttsp4_free_si_ptrs(cd);\n\tfree_irq(cd->irq, cd);\nerror_request_irq:\n\tif (cd->cpdata->init)\n\t\tcd->cpdata->init(cd->cpdata, 0, dev);\nerror_free_xfer:\n\tkfree(cd->xfer_buf);\nerror_free_cd:\n\tkfree(cd);\nerror_alloc_data:\nerror_no_pdata:\n\tdev_err(dev, \"%s failed.\\n\", __func__);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(cyttsp4_probe);\n\nstatic void cyttsp4_mt_release(struct cyttsp4_mt_data *md)\n{\n\tinput_unregister_device(md->input);\n\tinput_set_drvdata(md->input, NULL);\n}\n\nint cyttsp4_remove(struct cyttsp4 *cd)\n{\n\tstruct device *dev = cd->dev;\n\n\tcyttsp4_mt_release(&cd->md);\n\n\t \n\tpm_runtime_suspend(dev);\n\tpm_runtime_disable(dev);\n\n\tcancel_work_sync(&cd->startup_work);\n\n\tcyttsp4_stop_wd_timer(cd);\n\n\tfree_irq(cd->irq, cd);\n\tif (cd->cpdata->init)\n\t\tcd->cpdata->init(cd->cpdata, 0, dev);\n\tcyttsp4_free_si_ptrs(cd);\n\tkfree(cd);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cyttsp4_remove);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cypress TrueTouch(R) Standard touchscreen core driver\");\nMODULE_AUTHOR(\"Cypress\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}