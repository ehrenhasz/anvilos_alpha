{
  "module_name": "htcpen.c",
  "hash_id": "80abdf01845fd4e9f6ced816abfa2f182de7e99c475669801f2f6f24b277e9ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/htcpen.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/isa.h>\n#include <linux/ioport.h>\n#include <linux/dmi.h>\n\nMODULE_AUTHOR(\"Pau Oliva Fora <pau@eslack.org>\");\nMODULE_DESCRIPTION(\"HTC Shift touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define HTCPEN_PORT_IRQ_CLEAR\t0x068\n#define HTCPEN_PORT_INIT\t0x06c\n#define HTCPEN_PORT_INDEX\t0x0250\n#define HTCPEN_PORT_DATA\t0x0251\n#define HTCPEN_IRQ\t\t3\n\n#define DEVICE_ENABLE\t\t0xa2\n#define DEVICE_DISABLE\t\t0xa3\n\n#define X_INDEX\t\t\t3\n#define Y_INDEX\t\t\t5\n#define TOUCH_INDEX\t\t0xb\n#define LSB_XY_INDEX\t\t0xc\n#define X_AXIS_MAX\t\t2040\n#define Y_AXIS_MAX\t\t2040\n\nstatic bool invert_x;\nmodule_param(invert_x, bool, 0644);\nMODULE_PARM_DESC(invert_x, \"If set, X axis is inverted\");\nstatic bool invert_y;\nmodule_param(invert_y, bool, 0644);\nMODULE_PARM_DESC(invert_y, \"If set, Y axis is inverted\");\n\nstatic irqreturn_t htcpen_interrupt(int irq, void *handle)\n{\n\tstruct input_dev *htcpen_dev = handle;\n\tunsigned short x, y, xy;\n\n\t \n\toutb_p(TOUCH_INDEX, HTCPEN_PORT_INDEX);\n\n\tif (inb_p(HTCPEN_PORT_DATA)) {\n\t\tinput_report_key(htcpen_dev, BTN_TOUCH, 0);\n\t} else {\n\t\toutb_p(X_INDEX, HTCPEN_PORT_INDEX);\n\t\tx = inb_p(HTCPEN_PORT_DATA);\n\n\t\toutb_p(Y_INDEX, HTCPEN_PORT_INDEX);\n\t\ty = inb_p(HTCPEN_PORT_DATA);\n\n\t\toutb_p(LSB_XY_INDEX, HTCPEN_PORT_INDEX);\n\t\txy = inb_p(HTCPEN_PORT_DATA);\n\n\t\t \n\t\tx = X_AXIS_MAX - ((x * 8) + ((xy >> 4) & 0xf));\n\t\ty = (y * 8) + (xy & 0xf);\n\t\tif (invert_x)\n\t\t\tx = X_AXIS_MAX - x;\n\t\tif (invert_y)\n\t\t\ty = Y_AXIS_MAX - y;\n\n\t\tif (x != X_AXIS_MAX && x != 0) {\n\t\t\tinput_report_key(htcpen_dev, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(htcpen_dev, ABS_X, x);\n\t\t\tinput_report_abs(htcpen_dev, ABS_Y, y);\n\t\t}\n\t}\n\n\tinput_sync(htcpen_dev);\n\n\tinb_p(HTCPEN_PORT_IRQ_CLEAR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int htcpen_open(struct input_dev *dev)\n{\n\toutb_p(DEVICE_ENABLE, HTCPEN_PORT_INIT);\n\n\treturn 0;\n}\n\nstatic void htcpen_close(struct input_dev *dev)\n{\n\toutb_p(DEVICE_DISABLE, HTCPEN_PORT_INIT);\n\tsynchronize_irq(HTCPEN_IRQ);\n}\n\nstatic int htcpen_isa_probe(struct device *dev, unsigned int id)\n{\n\tstruct input_dev *htcpen_dev;\n\tint err = -EBUSY;\n\n\tif (!request_region(HTCPEN_PORT_IRQ_CLEAR, 1, \"htcpen\")) {\n\t\tprintk(KERN_ERR \"htcpen: unable to get IO region 0x%x\\n\",\n\t\t\tHTCPEN_PORT_IRQ_CLEAR);\n\t\tgoto request_region1_failed;\n\t}\n\n\tif (!request_region(HTCPEN_PORT_INIT, 1, \"htcpen\")) {\n\t\tprintk(KERN_ERR \"htcpen: unable to get IO region 0x%x\\n\",\n\t\t\tHTCPEN_PORT_INIT);\n\t\tgoto request_region2_failed;\n\t}\n\n\tif (!request_region(HTCPEN_PORT_INDEX, 2, \"htcpen\")) {\n\t\tprintk(KERN_ERR \"htcpen: unable to get IO region 0x%x\\n\",\n\t\t\tHTCPEN_PORT_INDEX);\n\t\tgoto request_region3_failed;\n\t}\n\n\thtcpen_dev = input_allocate_device();\n\tif (!htcpen_dev) {\n\t\tprintk(KERN_ERR \"htcpen: can't allocate device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto input_alloc_failed;\n\t}\n\n\thtcpen_dev->name = \"HTC Shift EC TouchScreen\";\n\thtcpen_dev->id.bustype = BUS_ISA;\n\n\thtcpen_dev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);\n\thtcpen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\tinput_set_abs_params(htcpen_dev, ABS_X, 0, X_AXIS_MAX, 0, 0);\n\tinput_set_abs_params(htcpen_dev, ABS_Y, 0, Y_AXIS_MAX, 0, 0);\n\n\thtcpen_dev->open = htcpen_open;\n\thtcpen_dev->close = htcpen_close;\n\n\terr = request_irq(HTCPEN_IRQ, htcpen_interrupt, 0, \"htcpen\",\n\t\t\thtcpen_dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"htcpen: irq busy\\n\");\n\t\tgoto request_irq_failed;\n\t}\n\n\tinb_p(HTCPEN_PORT_IRQ_CLEAR);\n\n\terr = input_register_device(htcpen_dev);\n\tif (err)\n\t\tgoto input_register_failed;\n\n\tdev_set_drvdata(dev, htcpen_dev);\n\n\treturn 0;\n\n input_register_failed:\n\tfree_irq(HTCPEN_IRQ, htcpen_dev);\n request_irq_failed:\n\tinput_free_device(htcpen_dev);\n input_alloc_failed:\n\trelease_region(HTCPEN_PORT_INDEX, 2);\n request_region3_failed:\n\trelease_region(HTCPEN_PORT_INIT, 1);\n request_region2_failed:\n\trelease_region(HTCPEN_PORT_IRQ_CLEAR, 1);\n request_region1_failed:\n\treturn err;\n}\n\nstatic void htcpen_isa_remove(struct device *dev, unsigned int id)\n{\n\tstruct input_dev *htcpen_dev = dev_get_drvdata(dev);\n\n\tinput_unregister_device(htcpen_dev);\n\n\tfree_irq(HTCPEN_IRQ, htcpen_dev);\n\n\trelease_region(HTCPEN_PORT_INDEX, 2);\n\trelease_region(HTCPEN_PORT_INIT, 1);\n\trelease_region(HTCPEN_PORT_IRQ_CLEAR, 1);\n}\n\n#ifdef CONFIG_PM\nstatic int htcpen_isa_suspend(struct device *dev, unsigned int n,\n\t\t\t\tpm_message_t state)\n{\n\toutb_p(DEVICE_DISABLE, HTCPEN_PORT_INIT);\n\n\treturn 0;\n}\n\nstatic int htcpen_isa_resume(struct device *dev, unsigned int n)\n{\n\toutb_p(DEVICE_ENABLE, HTCPEN_PORT_INIT);\n\n\treturn 0;\n}\n#endif\n\nstatic struct isa_driver htcpen_isa_driver = {\n\t.probe\t\t= htcpen_isa_probe,\n\t.remove\t\t= htcpen_isa_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= htcpen_isa_suspend,\n\t.resume\t\t= htcpen_isa_resume,\n#endif\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"htcpen\",\n\t}\n};\n\nstatic const struct dmi_system_id htcshift_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"Shift\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"High Tech Computer Corp\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Shift\"),\n\t\t},\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, htcshift_dmi_table);\n\nstatic int __init htcpen_isa_init(void)\n{\n\tif (!dmi_check_system(htcshift_dmi_table))\n\t\treturn -ENODEV;\n\n\treturn isa_register_driver(&htcpen_isa_driver, 1);\n}\n\nstatic void __exit htcpen_isa_exit(void)\n{\n\tisa_unregister_driver(&htcpen_isa_driver);\n}\n\nmodule_init(htcpen_isa_init);\nmodule_exit(htcpen_isa_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}