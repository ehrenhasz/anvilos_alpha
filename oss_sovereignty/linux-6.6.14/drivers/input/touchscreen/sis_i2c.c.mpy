{
  "module_name": "sis_i2c.c",
  "hash_id": "69c6adebeadaa3a18d304e173358365f454722fcee2cfb4256dd37be2a97f551",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/sis_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/crc-itu-t.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#define SIS_I2C_NAME\t\t\"sis_i2c_ts\"\n\n \n\n#define SIS_MAX_PACKET_SIZE\t\t64\n\n#define SIS_PKT_LEN_OFFSET\t\t0\n#define SIS_PKT_REPORT_OFFSET\t\t2  \n#define SIS_PKT_CONTACT_OFFSET\t\t3  \n\n#define SIS_SCAN_TIME_LEN\t\t2\n\n \n#define SIS_ALL_IN_ONE_PACKAGE\t\t0x10\n#define SIS_PKT_IS_TOUCH(x)\t\t(((x) & 0x0f) == 0x01)\n#define SIS_PKT_IS_HIDI2C(x)\t\t(((x) & 0x0f) == 0x06)\n\n \n#define SIS_PKT_HAS_AREA(x)\t\t((x) & BIT(4))\n#define SIS_PKT_HAS_PRESSURE(x)\t\t((x) & BIT(5))\n#define SIS_PKT_HAS_SCANTIME(x)\t\t((x) & BIT(6))\n\n \n#define SIS_BASE_LEN_PER_CONTACT\t6\n#define SIS_AREA_LEN_PER_CONTACT\t2\n#define SIS_PRESSURE_LEN_PER_CONTACT\t1\n\n \n#define SIS_CONTACT_STATUS_OFFSET\t0\n#define SIS_CONTACT_ID_OFFSET\t\t1  \n#define SIS_CONTACT_X_OFFSET\t\t2\n#define SIS_CONTACT_Y_OFFSET\t\t4\n#define SIS_CONTACT_WIDTH_OFFSET\t6\n#define SIS_CONTACT_HEIGHT_OFFSET\t7\n#define SIS_CONTACT_PRESSURE_OFFSET(id)\t(SIS_PKT_HAS_AREA(id) ? 8 : 6)\n\n \n#define SIS_STATUS_UP\t\t\t0x0\n#define SIS_STATUS_DOWN\t\t\t0x3\n\n \n#define SIS_MAX_FINGERS\t\t\t10\n#define SIS_MAX_X\t\t\t4095\n#define SIS_MAX_Y\t\t\t4095\n#define SIS_MAX_PRESSURE\t\t255\n\n \n#define SIS_AREA_LENGTH_LONGER\t\t5792\n \n#define SIS_AREA_LENGTH_SHORT\t\t5792\n#define SIS_AREA_UNIT\t\t\t(5792 / 32)\n\nstruct sis_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\n\tstruct gpio_desc *attn_gpio;\n\tstruct gpio_desc *reset_gpio;\n\n\tu8 packet[SIS_MAX_PACKET_SIZE];\n};\n\nstatic int sis_read_packet(struct i2c_client *client, u8 *buf,\n\t\t\t   unsigned int *num_contacts,\n\t\t\t   unsigned int *contact_size)\n{\n\tint count_idx;\n\tint ret;\n\tu16 len;\n\tu16 crc, pkg_crc;\n\tu8 report_id;\n\n\tret = i2c_master_recv(client, buf, SIS_MAX_PACKET_SIZE);\n\tif (ret <= 0)\n\t\treturn -EIO;\n\n\tlen = get_unaligned_le16(&buf[SIS_PKT_LEN_OFFSET]);\n\tif (len > SIS_MAX_PACKET_SIZE) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: invalid packet length (%d vs %d)\\n\",\n\t\t\t__func__, len, SIS_MAX_PACKET_SIZE);\n\t\treturn -E2BIG;\n\t}\n\n\tif (len < 10)\n\t\treturn -EINVAL;\n\n\treport_id = buf[SIS_PKT_REPORT_OFFSET];\n\tcount_idx  = len - 1;\n\t*contact_size = SIS_BASE_LEN_PER_CONTACT;\n\n\tif (report_id != SIS_ALL_IN_ONE_PACKAGE) {\n\t\tif (SIS_PKT_IS_TOUCH(report_id)) {\n\t\t\t \n\t\t\tcrc = crc_itu_t(0, buf + 2, len - 2 - 2);\n\t\t\tpkg_crc = get_unaligned_le16(&buf[len - 2]);\n\n\t\t\tif (crc != pkg_crc) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"%s: CRC Error (%d vs %d)\\n\",\n\t\t\t\t\t__func__, crc, pkg_crc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcount_idx -= 2;\n\n\t\t} else if (!SIS_PKT_IS_HIDI2C(report_id)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: invalid packet ID %#02x\\n\",\n\t\t\t\t__func__, report_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (SIS_PKT_HAS_SCANTIME(report_id))\n\t\t\tcount_idx -= SIS_SCAN_TIME_LEN;\n\n\t\tif (SIS_PKT_HAS_AREA(report_id))\n\t\t\t*contact_size += SIS_AREA_LEN_PER_CONTACT;\n\t\tif (SIS_PKT_HAS_PRESSURE(report_id))\n\t\t\t*contact_size += SIS_PRESSURE_LEN_PER_CONTACT;\n\t}\n\n\t*num_contacts = buf[count_idx];\n\treturn 0;\n}\n\nstatic int sis_ts_report_contact(struct sis_ts_data *ts, const u8 *data, u8 id)\n{\n\tstruct input_dev *input = ts->input;\n\tint slot;\n\tu8 status = data[SIS_CONTACT_STATUS_OFFSET];\n\tu8 pressure;\n\tu8 height, width;\n\tu16 x, y;\n\n\tif (status != SIS_STATUS_DOWN && status != SIS_STATUS_UP) {\n\t\tdev_err(&ts->client->dev, \"Unexpected touch status: %#02x\\n\",\n\t\t\tdata[SIS_CONTACT_STATUS_OFFSET]);\n\t\treturn -EINVAL;\n\t}\n\n\tslot = input_mt_get_slot_by_key(input, data[SIS_CONTACT_ID_OFFSET]);\n\tif (slot < 0)\n\t\treturn -ENOENT;\n\n\tinput_mt_slot(input, slot);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER,\n\t\t\t\t   status == SIS_STATUS_DOWN);\n\n\tif (status == SIS_STATUS_DOWN) {\n\t\tpressure = height = width = 1;\n\t\tif (id != SIS_ALL_IN_ONE_PACKAGE) {\n\t\t\tif (SIS_PKT_HAS_AREA(id)) {\n\t\t\t\twidth = data[SIS_CONTACT_WIDTH_OFFSET];\n\t\t\t\theight = data[SIS_CONTACT_HEIGHT_OFFSET];\n\t\t\t}\n\n\t\t\tif (SIS_PKT_HAS_PRESSURE(id))\n\t\t\t\tpressure =\n\t\t\t\t\tdata[SIS_CONTACT_PRESSURE_OFFSET(id)];\n\t\t}\n\n\t\tx = get_unaligned_le16(&data[SIS_CONTACT_X_OFFSET]);\n\t\ty = get_unaligned_le16(&data[SIS_CONTACT_Y_OFFSET]);\n\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t\t width * SIS_AREA_UNIT);\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MINOR,\n\t\t\t\t height * SIS_AREA_UNIT);\n\t\tinput_report_abs(input, ABS_MT_PRESSURE, pressure);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t}\n\n\treturn 0;\n}\n\nstatic void sis_ts_handle_packet(struct sis_ts_data *ts)\n{\n\tconst u8 *contact;\n\tunsigned int num_to_report = 0;\n\tunsigned int num_contacts;\n\tunsigned int num_reported;\n\tunsigned int contact_size;\n\tint error;\n\tu8 report_id;\n\n\tdo {\n\t\terror = sis_read_packet(ts->client, ts->packet,\n\t\t\t\t\t&num_contacts, &contact_size);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (num_to_report == 0) {\n\t\t\tnum_to_report = num_contacts;\n\t\t} else if (num_contacts != 0) {\n\t\t\tdev_err(&ts->client->dev,\n\t\t\t\t\"%s: nonzero (%d) point count in tail packet\\n\",\n\t\t\t\t__func__, num_contacts);\n\t\t\tbreak;\n\t\t}\n\n\t\treport_id = ts->packet[SIS_PKT_REPORT_OFFSET];\n\t\tcontact = &ts->packet[SIS_PKT_CONTACT_OFFSET];\n\t\tnum_reported = 0;\n\n\t\twhile (num_to_report > 0) {\n\t\t\terror = sis_ts_report_contact(ts, contact, report_id);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcontact += contact_size;\n\t\t\tnum_to_report--;\n\t\t\tnum_reported++;\n\n\t\t\tif (report_id != SIS_ALL_IN_ONE_PACKAGE &&\n\t\t\t    num_reported >= 5) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (num_to_report > 0);\n\n\tinput_mt_sync_frame(ts->input);\n\tinput_sync(ts->input);\n}\n\nstatic irqreturn_t sis_ts_irq_handler(int irq, void *dev_id)\n{\n\tstruct sis_ts_data *ts = dev_id;\n\n\tdo {\n\t\tsis_ts_handle_packet(ts);\n\t} while (ts->attn_gpio && gpiod_get_value_cansleep(ts->attn_gpio));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sis_ts_reset(struct sis_ts_data *ts)\n{\n\tif (ts->reset_gpio) {\n\t\t \n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value(ts->reset_gpio, 1);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value(ts->reset_gpio, 0);\n\t\tmsleep(100);\n\t}\n}\n\nstatic int sis_ts_probe(struct i2c_client *client)\n{\n\tstruct sis_ts_data *ts;\n\tstruct input_dev *input;\n\tint error;\n\n\tts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\n\tts->attn_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t\"attn\", GPIOD_IN);\n\tif (IS_ERR(ts->attn_gpio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->attn_gpio),\n\t\t\t\t     \"Failed to get attention GPIO\\n\");\n\n\tts->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->reset_gpio))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(ts->reset_gpio),\n\t\t\t\t     \"Failed to get reset GPIO\\n\");\n\n\tsis_ts_reset(ts);\n\n\tts->input = input = devm_input_allocate_device(&client->dev);\n\tif (!input) {\n\t\tdev_err(&client->dev, \"Failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = \"SiS Touchscreen\";\n\tinput->id.bustype = BUS_I2C;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, SIS_MAX_X, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, SIS_MAX_Y, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, SIS_MAX_PRESSURE, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, SIS_AREA_LENGTH_LONGER, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MINOR,\n\t\t\t     0, SIS_AREA_LENGTH_SHORT, 0, 0);\n\n\terror = input_mt_init_slots(input, SIS_MAX_FINGERS, INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to initialize MT slots: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, sis_ts_irq_handler,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  client->name, ts);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sis_ts_dt_ids[] = {\n\t{ .compatible = \"sis,9200-ts\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sis_ts_dt_ids);\n#endif\n\nstatic const struct i2c_device_id sis_ts_id[] = {\n\t{ SIS_I2C_NAME,\t0 },\n\t{ \"9200-ts\",\t0 },\n\t{    }\n};\nMODULE_DEVICE_TABLE(i2c, sis_ts_id);\n\nstatic struct i2c_driver sis_ts_driver = {\n\t.driver = {\n\t\t.name\t= SIS_I2C_NAME,\n\t\t.of_match_table = of_match_ptr(sis_ts_dt_ids),\n\t},\n\t.probe\t\t= sis_ts_probe,\n\t.id_table\t= sis_ts_id,\n};\nmodule_i2c_driver(sis_ts_driver);\n\nMODULE_DESCRIPTION(\"SiS 9200 Family Touchscreen Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mika Penttil\u00e4 <mika.penttila@nextfour.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}