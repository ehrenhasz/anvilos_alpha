{
  "module_name": "hycon-hy46xx.c",
  "hash_id": "0e131313c282d6f6c811dc902686144799eedce9fc6f61795c479fd1c24b221b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/hycon-hy46xx.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/irq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n\n#include <asm/unaligned.h>\n\n#define HY46XX_CHKSUM_CODE\t\t0x1\n#define HY46XX_FINGER_NUM\t\t0x2\n#define HY46XX_CHKSUM_LEN\t\t0x7\n#define HY46XX_THRESHOLD\t\t0x80\n#define HY46XX_GLOVE_EN\t\t\t0x84\n#define HY46XX_REPORT_SPEED\t\t0x88\n#define HY46XX_PWR_NOISE_EN\t\t0x89\n#define HY46XX_FILTER_DATA\t\t0x8A\n#define HY46XX_GAIN\t\t\t0x92\n#define HY46XX_EDGE_OFFSET\t\t0x93\n#define HY46XX_RX_NR_USED\t\t0x94\n#define HY46XX_TX_NR_USED\t\t0x95\n#define HY46XX_PWR_MODE\t\t\t0xA5\n#define HY46XX_FW_VERSION\t\t0xA6\n#define HY46XX_LIB_VERSION\t\t0xA7\n#define HY46XX_TP_INFO\t\t\t0xA8\n#define HY46XX_TP_CHIP_ID\t\t0xA9\n#define HY46XX_BOOT_VER\t\t\t0xB0\n\n#define HY46XX_TPLEN\t\t\t0x6\n#define HY46XX_REPORT_PKT_LEN\t\t0x44\n\n#define HY46XX_MAX_SUPPORTED_POINTS\t11\n\n#define TOUCH_EVENT_DOWN\t\t0x00\n#define TOUCH_EVENT_UP\t\t\t0x01\n#define TOUCH_EVENT_CONTACT\t\t0x02\n#define TOUCH_EVENT_RESERVED\t\t0x03\n\nstruct hycon_hy46xx_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct touchscreen_properties prop;\n\tstruct regulator *vcc;\n\n\tstruct gpio_desc *reset_gpio;\n\n\tstruct mutex mutex;\n\tstruct regmap *regmap;\n\n\tint threshold;\n\tbool glove_enable;\n\tint report_speed;\n\tbool noise_filter_enable;\n\tint filter_data;\n\tint gain;\n\tint edge_offset;\n\tint rx_number_used;\n\tint tx_number_used;\n\tint power_mode;\n\tint fw_version;\n\tint lib_version;\n\tint tp_information;\n\tint tp_chip_id;\n\tint bootloader_version;\n};\n\nstatic const struct regmap_config hycon_hy46xx_i2c_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic bool hycon_hy46xx_check_checksum(struct hycon_hy46xx_data *tsdata, u8 *buf)\n{\n\tu8 chksum = 0;\n\tint i;\n\n\tfor (i = 2; i < buf[HY46XX_CHKSUM_LEN]; i++)\n\t\tchksum += buf[i];\n\n\tif (chksum == buf[HY46XX_CHKSUM_CODE])\n\t\treturn true;\n\n\tdev_err_ratelimited(&tsdata->client->dev,\n\t\t\t    \"checksum error: 0x%02x expected, got 0x%02x\\n\",\n\t\t\t    chksum, buf[HY46XX_CHKSUM_CODE]);\n\n\treturn false;\n}\n\nstatic irqreturn_t hycon_hy46xx_isr(int irq, void *dev_id)\n{\n\tstruct hycon_hy46xx_data *tsdata = dev_id;\n\tstruct device *dev = &tsdata->client->dev;\n\tu8 rdbuf[HY46XX_REPORT_PKT_LEN];\n\tint i, x, y, id;\n\tint error;\n\n\tmemset(rdbuf, 0, sizeof(rdbuf));\n\n\terror = regmap_bulk_read(tsdata->regmap, 0, rdbuf, sizeof(rdbuf));\n\tif (error) {\n\t\tdev_err_ratelimited(dev, \"Unable to fetch data, error: %d\\n\",\n\t\t\t\t    error);\n\t\tgoto out;\n\t}\n\n\tif (!hycon_hy46xx_check_checksum(tsdata, rdbuf))\n\t\tgoto out;\n\n\tfor (i = 0; i < HY46XX_MAX_SUPPORTED_POINTS; i++) {\n\t\tu8 *buf = &rdbuf[3 + (HY46XX_TPLEN * i)];\n\t\tint type = buf[0] >> 6;\n\n\t\tif (type == TOUCH_EVENT_RESERVED)\n\t\t\tcontinue;\n\n\t\tx = get_unaligned_be16(buf) & 0x0fff;\n\t\ty = get_unaligned_be16(buf + 2) & 0x0fff;\n\n\t\tid = buf[2] >> 4;\n\n\t\tinput_mt_slot(tsdata->input, id);\n\t\tif (input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER,\n\t\t\t\t\t       type != TOUCH_EVENT_UP))\n\t\t\ttouchscreen_report_pos(tsdata->input, &tsdata->prop,\n\t\t\t\t\t       x, y, true);\n\t}\n\n\tinput_mt_report_pointer_emulation(tsdata->input, false);\n\tinput_sync(tsdata->input);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstruct hycon_hy46xx_attribute {\n\tstruct device_attribute dattr;\n\tsize_t field_offset;\n\tu8 address;\n\tu8 limit_low;\n\tu8 limit_high;\n};\n\n#define HYCON_ATTR_U8(_field, _mode, _address, _limit_low, _limit_high)\t\\\n\tstruct hycon_hy46xx_attribute hycon_hy46xx_attr_##_field = {\t\t\\\n\t\t.dattr = __ATTR(_field, _mode,\t\t\t\t\\\n\t\t\t\thycon_hy46xx_setting_show,\t\t\t\\\n\t\t\t\thycon_hy46xx_setting_store),\t\t\t\\\n\t\t.field_offset = offsetof(struct hycon_hy46xx_data, _field),\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.limit_low = _limit_low,\t\t\t\t\\\n\t\t.limit_high = _limit_high,\t\t\t\t\\\n\t}\n\n#define HYCON_ATTR_BOOL(_field, _mode, _address)\t\t\t\\\n\tstruct hycon_hy46xx_attribute hycon_hy46xx_attr_##_field = {\t\t\\\n\t\t.dattr = __ATTR(_field, _mode,\t\t\t\t\\\n\t\t\t\thycon_hy46xx_setting_show,\t\t\t\\\n\t\t\t\thycon_hy46xx_setting_store),\t\t\t\\\n\t\t.field_offset = offsetof(struct hycon_hy46xx_data, _field),\t\\\n\t\t.address = _address,\t\t\t\t\t\\\n\t\t.limit_low = false,\t\t\t\t\t\\\n\t\t.limit_high = true,\t\t\t\t\t\\\n\t}\n\nstatic ssize_t hycon_hy46xx_setting_show(struct device *dev,\n\t\t\t\t   struct device_attribute *dattr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hycon_hy46xx_data *tsdata = i2c_get_clientdata(client);\n\tstruct hycon_hy46xx_attribute *attr =\n\t\t\tcontainer_of(dattr, struct hycon_hy46xx_attribute, dattr);\n\tu8 *field = (u8 *)tsdata + attr->field_offset;\n\tsize_t count = 0;\n\tint error = 0;\n\tint val;\n\n\tmutex_lock(&tsdata->mutex);\n\n\terror = regmap_read(tsdata->regmap, attr->address, &val);\n\tif (error < 0) {\n\t\tdev_err(&tsdata->client->dev,\n\t\t\t\"Failed to fetch attribute %s, error %d\\n\",\n\t\t\tdattr->attr.name, error);\n\t\tgoto out;\n\t}\n\n\tif (val != *field) {\n\t\tdev_warn(&tsdata->client->dev,\n\t\t\t \"%s: read (%d) and stored value (%d) differ\\n\",\n\t\t\t dattr->attr.name, val, *field);\n\t\t*field = val;\n\t}\n\n\tcount = scnprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n\nout:\n\tmutex_unlock(&tsdata->mutex);\n\treturn error ?: count;\n}\n\nstatic ssize_t hycon_hy46xx_setting_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *dattr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hycon_hy46xx_data *tsdata = i2c_get_clientdata(client);\n\tstruct hycon_hy46xx_attribute *attr =\n\t\t\tcontainer_of(dattr, struct hycon_hy46xx_attribute, dattr);\n\tu8 *field = (u8 *)tsdata + attr->field_offset;\n\tunsigned int val;\n\tint error;\n\n\tmutex_lock(&tsdata->mutex);\n\n\terror = kstrtouint(buf, 0, &val);\n\tif (error)\n\t\tgoto out;\n\n\tif (val < attr->limit_low || val > attr->limit_high) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\terror = regmap_write(tsdata->regmap, attr->address, val);\n\tif (error < 0) {\n\t\tdev_err(&tsdata->client->dev,\n\t\t\t\"Failed to update attribute %s, error: %d\\n\",\n\t\t\tdattr->attr.name, error);\n\t\tgoto out;\n\t}\n\t*field = val;\n\nout:\n\tmutex_unlock(&tsdata->mutex);\n\treturn error ?: count;\n}\n\nstatic HYCON_ATTR_U8(threshold, 0644, HY46XX_THRESHOLD, 0, 255);\nstatic HYCON_ATTR_BOOL(glove_enable, 0644, HY46XX_GLOVE_EN);\nstatic HYCON_ATTR_U8(report_speed, 0644, HY46XX_REPORT_SPEED, 0, 255);\nstatic HYCON_ATTR_BOOL(noise_filter_enable, 0644, HY46XX_PWR_NOISE_EN);\nstatic HYCON_ATTR_U8(filter_data, 0644, HY46XX_FILTER_DATA, 0, 5);\nstatic HYCON_ATTR_U8(gain, 0644, HY46XX_GAIN, 0, 5);\nstatic HYCON_ATTR_U8(edge_offset, 0644, HY46XX_EDGE_OFFSET, 0, 5);\nstatic HYCON_ATTR_U8(fw_version, 0444, HY46XX_FW_VERSION, 0, 255);\nstatic HYCON_ATTR_U8(lib_version, 0444, HY46XX_LIB_VERSION, 0, 255);\nstatic HYCON_ATTR_U8(tp_information, 0444, HY46XX_TP_INFO, 0, 255);\nstatic HYCON_ATTR_U8(tp_chip_id, 0444, HY46XX_TP_CHIP_ID, 0, 255);\nstatic HYCON_ATTR_U8(bootloader_version, 0444, HY46XX_BOOT_VER, 0, 255);\n\nstatic struct attribute *hycon_hy46xx_attrs[] = {\n\t&hycon_hy46xx_attr_threshold.dattr.attr,\n\t&hycon_hy46xx_attr_glove_enable.dattr.attr,\n\t&hycon_hy46xx_attr_report_speed.dattr.attr,\n\t&hycon_hy46xx_attr_noise_filter_enable.dattr.attr,\n\t&hycon_hy46xx_attr_filter_data.dattr.attr,\n\t&hycon_hy46xx_attr_gain.dattr.attr,\n\t&hycon_hy46xx_attr_edge_offset.dattr.attr,\n\t&hycon_hy46xx_attr_fw_version.dattr.attr,\n\t&hycon_hy46xx_attr_lib_version.dattr.attr,\n\t&hycon_hy46xx_attr_tp_information.dattr.attr,\n\t&hycon_hy46xx_attr_tp_chip_id.dattr.attr,\n\t&hycon_hy46xx_attr_bootloader_version.dattr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group hycon_hy46xx_attr_group = {\n\t.attrs = hycon_hy46xx_attrs,\n};\n\nstatic void hycon_hy46xx_get_defaults(struct device *dev, struct hycon_hy46xx_data *tsdata)\n{\n\tbool val_bool;\n\tint error;\n\tu32 val;\n\n\terror = device_property_read_u32(dev, \"hycon,threshold\", &val);\n\tif (!error) {\n\t\terror = regmap_write(tsdata->regmap, HY46XX_THRESHOLD, val);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\ttsdata->threshold = val;\n\t}\n\n\tval_bool = device_property_read_bool(dev, \"hycon,glove-enable\");\n\terror = regmap_write(tsdata->regmap, HY46XX_GLOVE_EN, val_bool);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->glove_enable = val_bool;\n\n\terror = device_property_read_u32(dev, \"hycon,report-speed-hz\", &val);\n\tif (!error) {\n\t\terror = regmap_write(tsdata->regmap, HY46XX_REPORT_SPEED, val);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\ttsdata->report_speed = val;\n\t}\n\n\tval_bool = device_property_read_bool(dev, \"hycon,noise-filter-enable\");\n\terror = regmap_write(tsdata->regmap, HY46XX_PWR_NOISE_EN, val_bool);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->noise_filter_enable = val_bool;\n\n\terror = device_property_read_u32(dev, \"hycon,filter-data\", &val);\n\tif (!error) {\n\t\terror = regmap_write(tsdata->regmap, HY46XX_FILTER_DATA, val);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\ttsdata->filter_data = val;\n\t}\n\n\terror = device_property_read_u32(dev, \"hycon,gain\", &val);\n\tif (!error) {\n\t\terror = regmap_write(tsdata->regmap, HY46XX_GAIN, val);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\ttsdata->gain = val;\n\t}\n\n\terror = device_property_read_u32(dev, \"hycon,edge-offset\", &val);\n\tif (!error) {\n\t\terror = regmap_write(tsdata->regmap, HY46XX_EDGE_OFFSET, val);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\ttsdata->edge_offset = val;\n\t}\n\n\treturn;\nout:\n\tdev_err(&tsdata->client->dev, \"Failed to set default settings\");\n}\n\nstatic void hycon_hy46xx_get_parameters(struct hycon_hy46xx_data *tsdata)\n{\n\tint error;\n\tu32 val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_THRESHOLD, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->threshold = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_GLOVE_EN, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->glove_enable = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_REPORT_SPEED, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->report_speed = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_PWR_NOISE_EN, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->noise_filter_enable = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_FILTER_DATA, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->filter_data = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_GAIN, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->gain = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_EDGE_OFFSET, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->edge_offset = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_RX_NR_USED, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->rx_number_used = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_TX_NR_USED, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->tx_number_used = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_PWR_MODE, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->power_mode = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_FW_VERSION, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->fw_version = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_LIB_VERSION, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->lib_version = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_TP_INFO, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->tp_information = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_TP_CHIP_ID, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->tp_chip_id = val;\n\n\terror = regmap_read(tsdata->regmap, HY46XX_BOOT_VER, &val);\n\tif (error < 0)\n\t\tgoto out;\n\ttsdata->bootloader_version = val;\n\n\treturn;\nout:\n\tdev_err(&tsdata->client->dev, \"Failed to read default settings\");\n}\n\nstatic void hycon_hy46xx_disable_regulator(void *arg)\n{\n\tstruct hycon_hy46xx_data *data = arg;\n\n\tregulator_disable(data->vcc);\n}\n\nstatic int hycon_hy46xx_probe(struct i2c_client *client)\n{\n\tstruct hycon_hy46xx_data *tsdata;\n\tstruct input_dev *input;\n\tint error;\n\n\tdev_dbg(&client->dev, \"probing for HYCON HY46XX I2C\\n\");\n\n\ttsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);\n\tif (!tsdata)\n\t\treturn -ENOMEM;\n\n\ttsdata->vcc = devm_regulator_get(&client->dev, \"vcc\");\n\tif (IS_ERR(tsdata->vcc)) {\n\t\terror = PTR_ERR(tsdata->vcc);\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to request regulator: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regulator_enable(tsdata->vcc);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"failed to enable vcc: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t hycon_hy46xx_disable_regulator,\n\t\t\t\t\t tsdata);\n\tif (error)\n\t\treturn error;\n\n\ttsdata->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t     \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(tsdata->reset_gpio)) {\n\t\terror = PTR_ERR(tsdata->reset_gpio);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to request GPIO reset pin, error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (tsdata->reset_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->reset_gpio, 1);\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(tsdata->reset_gpio, 0);\n\t\tmsleep(1000);\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input) {\n\t\tdev_err(&client->dev, \"failed to allocate input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tsdata->mutex);\n\ttsdata->client = client;\n\ttsdata->input = input;\n\n\ttsdata->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t      &hycon_hy46xx_i2c_regmap_config);\n\tif (IS_ERR(tsdata->regmap)) {\n\t\tdev_err(&client->dev, \"regmap allocation failed\\n\");\n\t\treturn PTR_ERR(tsdata->regmap);\n\t}\n\n\thycon_hy46xx_get_defaults(&client->dev, tsdata);\n\thycon_hy46xx_get_parameters(tsdata);\n\n\tinput->name = \"Hycon Capacitive Touch\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->dev.parent = &client->dev;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, -1, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, -1, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, &tsdata->prop);\n\n\terror = input_mt_init_slots(input, HY46XX_MAX_SUPPORTED_POINTS,\n\t\t\t\t    INPUT_MT_DIRECT);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to init MT slots.\\n\");\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, tsdata);\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, hycon_hy46xx_isr, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, tsdata);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Unable to request touchscreen IRQ.\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &hycon_hy46xx_attr_group);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\tdev_dbg(&client->dev,\n\t\t\"HYCON HY46XX initialized: IRQ %d, Reset pin %d.\\n\",\n\t\tclient->irq,\n\t\ttsdata->reset_gpio ? desc_to_gpio(tsdata->reset_gpio) : -1);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id hycon_hy46xx_id[] = {\n\t{ .name = \"hy4613\" },\n\t{ .name = \"hy4614\" },\n\t{ .name = \"hy4621\" },\n\t{ .name = \"hy4623\" },\n\t{ .name = \"hy4633\" },\n\t{ .name = \"hy4635\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, hycon_hy46xx_id);\n\nstatic const struct of_device_id hycon_hy46xx_of_match[] = {\n\t{ .compatible = \"hycon,hy4613\" },\n\t{ .compatible = \"hycon,hy4614\" },\n\t{ .compatible = \"hycon,hy4621\" },\n\t{ .compatible = \"hycon,hy4623\" },\n\t{ .compatible = \"hycon,hy4633\" },\n\t{ .compatible = \"hycon,hy4635\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, hycon_hy46xx_of_match);\n\nstatic struct i2c_driver hycon_hy46xx_driver = {\n\t.driver = {\n\t\t.name = \"hycon_hy46xx\",\n\t\t.of_match_table = hycon_hy46xx_of_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table = hycon_hy46xx_id,\n\t.probe = hycon_hy46xx_probe,\n};\n\nmodule_i2c_driver(hycon_hy46xx_driver);\n\nMODULE_AUTHOR(\"Giulio Benetti <giulio.benetti@benettiengineering.com>\");\nMODULE_DESCRIPTION(\"HYCON HY46XX I2C Touchscreen Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}