{
  "module_name": "88pm860x-ts.c",
  "hash_id": "948f2862e1a11820e994a125ed54445ba64d66aac8ad312dc925b373cdf627ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/88pm860x-ts.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/mfd/88pm860x.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\n#define MEAS_LEN\t\t(8)\n#define ACCURATE_BIT\t\t(12)\n\n \n#define MEAS_EN3\t\t(0x52)\n\n#define MEAS_TSIX_1\t\t(0x8D)\n#define MEAS_TSIX_2\t\t(0x8E)\n#define MEAS_TSIY_1\t\t(0x8F)\n#define MEAS_TSIY_2\t\t(0x90)\n#define MEAS_TSIZ1_1\t\t(0x91)\n#define MEAS_TSIZ1_2\t\t(0x92)\n#define MEAS_TSIZ2_1\t\t(0x93)\n#define MEAS_TSIZ2_2\t\t(0x94)\n\n \n#define MEAS_PD_EN\t\t(1 << 3)\n#define MEAS_TSIX_EN\t\t(1 << 4)\n#define MEAS_TSIY_EN\t\t(1 << 5)\n#define MEAS_TSIZ1_EN\t\t(1 << 6)\n#define MEAS_TSIZ2_EN\t\t(1 << 7)\n\nstruct pm860x_touch {\n\tstruct input_dev *idev;\n\tstruct i2c_client *i2c;\n\tstruct pm860x_chip *chip;\n\tint irq;\n\tint res_x;\t\t \n};\n\nstatic irqreturn_t pm860x_touch_handler(int irq, void *data)\n{\n\tstruct pm860x_touch *touch = data;\n\tstruct pm860x_chip *chip = touch->chip;\n\tunsigned char buf[MEAS_LEN];\n\tint x, y, pen_down;\n\tint z1, z2, rt = 0;\n\tint ret;\n\n\tret = pm860x_bulk_read(touch->i2c, MEAS_TSIX_1, MEAS_LEN, buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpen_down = buf[1] & (1 << 6);\n\tx = ((buf[0] & 0xFF) << 4) | (buf[1] & 0x0F);\n\ty = ((buf[2] & 0xFF) << 4) | (buf[3] & 0x0F);\n\tz1 = ((buf[4] & 0xFF) << 4) | (buf[5] & 0x0F);\n\tz2 = ((buf[6] & 0xFF) << 4) | (buf[7] & 0x0F);\n\n\tif (pen_down) {\n\t\tif ((x != 0) && (z1 != 0) && (touch->res_x != 0)) {\n\t\t\trt = z2 / z1 - 1;\n\t\t\trt = (rt * touch->res_x * x) >> ACCURATE_BIT;\n\t\t\tdev_dbg(chip->dev, \"z1:%d, z2:%d, rt:%d\\n\",\n\t\t\t\tz1, z2, rt);\n\t\t}\n\t\tinput_report_abs(touch->idev, ABS_X, x);\n\t\tinput_report_abs(touch->idev, ABS_Y, y);\n\t\tinput_report_abs(touch->idev, ABS_PRESSURE, rt);\n\t\tinput_report_key(touch->idev, BTN_TOUCH, 1);\n\t\tdev_dbg(chip->dev, \"pen down at [%d, %d].\\n\", x, y);\n\t} else {\n\t\tinput_report_abs(touch->idev, ABS_PRESSURE, 0);\n\t\tinput_report_key(touch->idev, BTN_TOUCH, 0);\n\t\tdev_dbg(chip->dev, \"pen release\\n\");\n\t}\n\tinput_sync(touch->idev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int pm860x_touch_open(struct input_dev *dev)\n{\n\tstruct pm860x_touch *touch = input_get_drvdata(dev);\n\tint data, ret;\n\n\tdata = MEAS_PD_EN | MEAS_TSIX_EN | MEAS_TSIY_EN\n\t\t| MEAS_TSIZ1_EN | MEAS_TSIZ2_EN;\n\tret = pm860x_set_bits(touch->i2c, MEAS_EN3, data, data);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic void pm860x_touch_close(struct input_dev *dev)\n{\n\tstruct pm860x_touch *touch = input_get_drvdata(dev);\n\tint data;\n\n\tdata = MEAS_PD_EN | MEAS_TSIX_EN | MEAS_TSIY_EN\n\t\t| MEAS_TSIZ1_EN | MEAS_TSIZ2_EN;\n\tpm860x_set_bits(touch->i2c, MEAS_EN3, data, 0);\n}\n\n#ifdef CONFIG_OF\nstatic int pm860x_touch_dt_init(struct platform_device *pdev,\n\t\t\t\t\t  struct pm860x_chip *chip,\n\t\t\t\t\t  int *res_x)\n{\n\tstruct device_node *np = pdev->dev.parent->of_node;\n\tstruct i2c_client *i2c = (chip->id == CHIP_PM8607) ? chip->client \\\n\t\t\t\t : chip->companion;\n\tint data, n, ret;\n\tif (!np)\n\t\treturn -ENODEV;\n\tnp = of_get_child_by_name(np, \"touch\");\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Can't find touch node\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tdata = 0;\n\tif (!of_property_read_u32(np, \"marvell,88pm860x-gpadc-prebias\", &n))\n\t\tdata |= (n << 1) & PM8607_GPADC_PREBIAS_MASK;\n\tif (!of_property_read_u32(np, \"marvell,88pm860x-gpadc-slot-cycle\", &n))\n\t\tdata |= (n << 3) & PM8607_GPADC_SLOT_CYCLE_MASK;\n\tif (!of_property_read_u32(np, \"marvell,88pm860x-gpadc-off-scale\", &n))\n\t\tdata |= (n << 5) & PM8607_GPADC_OFF_SCALE_MASK;\n\tif (!of_property_read_u32(np, \"marvell,88pm860x-gpadc-sw-cal\", &n))\n\t\tdata |= (n << 7) & PM8607_GPADC_SW_CAL_MASK;\n\tif (data) {\n\t\tret = pm860x_reg_write(i2c, PM8607_GPADC_MISC1, data);\n\t\tif (ret < 0)\n\t\t\tgoto err_put_node;\n\t}\n\t \n\tif (!of_property_read_u32(np, \"marvell,88pm860x-tsi-prebias\", &data)) {\n\t\tret = pm860x_reg_write(i2c, PM8607_TSI_PREBIAS, data);\n\t\tif (ret < 0)\n\t\t\tgoto err_put_node;\n\t}\n\t \n\tdata = 0;\n\tif (!of_property_read_u32(np, \"marvell,88pm860x-pen-prebias\", &n))\n\t\tdata |= n & PM8607_PD_PREBIAS_MASK;\n\tif (!of_property_read_u32(np, \"marvell,88pm860x-pen-prechg\", &n))\n\t\tdata |= n & PM8607_PD_PRECHG_MASK;\n\tif (data) {\n\t\tret = pm860x_reg_write(i2c, PM8607_PD_PREBIAS, data);\n\t\tif (ret < 0)\n\t\t\tgoto err_put_node;\n\t}\n\tof_property_read_u32(np, \"marvell,88pm860x-resistor-X\", res_x);\n\n\tof_node_put(np);\n\n\treturn 0;\n\nerr_put_node:\n\tof_node_put(np);\n\n\treturn -EINVAL;\n}\n#else\n#define pm860x_touch_dt_init(x, y, z)\t(-1)\n#endif\n\nstatic int pm860x_touch_probe(struct platform_device *pdev)\n{\n\tstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct pm860x_touch_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct pm860x_touch *touch;\n\tstruct i2c_client *i2c = (chip->id == CHIP_PM8607) ? chip->client \\\n\t\t\t\t : chip->companion;\n\tint irq, ret, res_x = 0, data = 0;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tif (pm860x_touch_dt_init(pdev, chip, &res_x)) {\n\t\tif (pdata) {\n\t\t\t \n\t\t\tdata = 0;\n\t\t\tdata |= (pdata->gpadc_prebias << 1)\n\t\t\t\t& PM8607_GPADC_PREBIAS_MASK;\n\t\t\tdata |= (pdata->slot_cycle << 3)\n\t\t\t\t& PM8607_GPADC_SLOT_CYCLE_MASK;\n\t\t\tdata |= (pdata->off_scale << 5)\n\t\t\t\t& PM8607_GPADC_OFF_SCALE_MASK;\n\t\t\tdata |= (pdata->sw_cal << 7)\n\t\t\t\t& PM8607_GPADC_SW_CAL_MASK;\n\t\t\tif (data) {\n\t\t\t\tret = pm860x_reg_write(i2c,\n\t\t\t\t\tPM8607_GPADC_MISC1, data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif (pdata->tsi_prebias) {\n\t\t\t\tdata = pdata->tsi_prebias;\n\t\t\t\tret = pm860x_reg_write(i2c,\n\t\t\t\t\tPM8607_TSI_PREBIAS, data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tdata = 0;\n\t\t\tdata |= pdata->pen_prebias\n\t\t\t\t& PM8607_PD_PREBIAS_MASK;\n\t\t\tdata |= (pdata->pen_prechg << 5)\n\t\t\t\t& PM8607_PD_PRECHG_MASK;\n\t\t\tif (data) {\n\t\t\t\tret = pm860x_reg_write(i2c,\n\t\t\t\t\tPM8607_PD_PREBIAS, data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tres_x = pdata->res_x;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"failed to get platform data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tret = pm860x_set_bits(i2c, PM8607_GPADC_MISC1, PM8607_GPADC_EN,\n\t\t\t      PM8607_GPADC_EN);\n\tif (ret)\n\t\treturn ret;\n\n\ttouch = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_touch),\n\t\t\t     GFP_KERNEL);\n\tif (!touch)\n\t\treturn -ENOMEM;\n\n\ttouch->idev = devm_input_allocate_device(&pdev->dev);\n\tif (!touch->idev) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate input device!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttouch->idev->name = \"88pm860x-touch\";\n\ttouch->idev->phys = \"88pm860x/input0\";\n\ttouch->idev->id.bustype = BUS_I2C;\n\ttouch->idev->dev.parent = &pdev->dev;\n\ttouch->idev->open = pm860x_touch_open;\n\ttouch->idev->close = pm860x_touch_close;\n\ttouch->chip = chip;\n\ttouch->i2c = i2c;\n\ttouch->irq = irq;\n\ttouch->res_x = res_x;\n\tinput_set_drvdata(touch->idev, touch);\n\n\tret = devm_request_threaded_irq(&pdev->dev, touch->irq, NULL,\n\t\t\t\t\tpm860x_touch_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"touch\", touch);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t__set_bit(EV_ABS, touch->idev->evbit);\n\t__set_bit(ABS_X, touch->idev->absbit);\n\t__set_bit(ABS_Y, touch->idev->absbit);\n\t__set_bit(ABS_PRESSURE, touch->idev->absbit);\n\t__set_bit(EV_SYN, touch->idev->evbit);\n\t__set_bit(EV_KEY, touch->idev->evbit);\n\t__set_bit(BTN_TOUCH, touch->idev->keybit);\n\n\tinput_set_abs_params(touch->idev, ABS_X, 0, 1 << ACCURATE_BIT, 0, 0);\n\tinput_set_abs_params(touch->idev, ABS_Y, 0, 1 << ACCURATE_BIT, 0, 0);\n\tinput_set_abs_params(touch->idev, ABS_PRESSURE, 0, 1 << ACCURATE_BIT,\n\t\t\t\t0, 0);\n\n\tret = input_register_device(touch->idev);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to register touch!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver pm860x_touch_driver = {\n\t.driver\t= {\n\t\t.name\t= \"88pm860x-touch\",\n\t},\n\t.probe\t= pm860x_touch_probe,\n};\nmodule_platform_driver(pm860x_touch_driver);\n\nMODULE_DESCRIPTION(\"Touchscreen driver for Marvell Semiconductor 88PM860x\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:88pm860x-touch\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}