{
  "module_name": "wdt87xx_i2c.c",
  "hash_id": "eba0478843dbb6ac58dda875ee090daf2bca57e7ea71756ffa6f1453f2b16c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/wdt87xx_i2c.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/input/mt.h>\n#include <linux/acpi.h>\n#include <asm/unaligned.h>\n\n#define WDT87XX_NAME\t\t\"wdt87xx_i2c\"\n#define WDT87XX_FW_NAME\t\t\"wdt87xx_fw.bin\"\n#define WDT87XX_CFG_NAME\t\"wdt87xx_cfg.bin\"\n\n#define MODE_ACTIVE\t\t\t0x01\n#define MODE_READY\t\t\t0x02\n#define MODE_IDLE\t\t\t0x03\n#define MODE_SLEEP\t\t\t0x04\n#define MODE_STOP\t\t\t0xFF\n\n#define WDT_MAX_FINGER\t\t\t10\n#define WDT_RAW_BUF_COUNT\t\t54\n#define WDT_V1_RAW_BUF_COUNT\t\t74\n#define WDT_FIRMWARE_ID\t\t\t0xa9e368f5\n\n#define PG_SIZE\t\t\t\t0x1000\n#define MAX_RETRIES\t\t\t3\n\n#define MAX_UNIT_AXIS\t\t\t0x7FFF\n\n#define PKT_READ_SIZE\t\t\t72\n#define PKT_WRITE_SIZE\t\t\t80\n\n \n#define FINGER_EV_OFFSET_ID\t\t0\n#define FINGER_EV_OFFSET_X\t\t1\n#define FINGER_EV_OFFSET_Y\t\t3\n#define FINGER_EV_SIZE\t\t\t5\n\n#define FINGER_EV_V1_OFFSET_ID\t\t0\n#define FINGER_EV_V1_OFFSET_W\t\t1\n#define FINGER_EV_V1_OFFSET_P\t\t2\n#define FINGER_EV_V1_OFFSET_X\t\t3\n#define FINGER_EV_V1_OFFSET_Y\t\t5\n#define FINGER_EV_V1_SIZE\t\t7\n\n \n#define TOUCH_PK_OFFSET_REPORT_ID\t0\n#define TOUCH_PK_OFFSET_EVENT\t\t1\n#define TOUCH_PK_OFFSET_SCAN_TIME\t51\n#define TOUCH_PK_OFFSET_FNGR_NUM\t53\n\n#define TOUCH_PK_V1_OFFSET_REPORT_ID\t0\n#define TOUCH_PK_V1_OFFSET_EVENT\t1\n#define TOUCH_PK_V1_OFFSET_SCAN_TIME\t71\n#define TOUCH_PK_V1_OFFSET_FNGR_NUM\t73\n\n \n#define CTL_PARAM_OFFSET_FW_ID\t\t0\n#define CTL_PARAM_OFFSET_PLAT_ID\t2\n#define CTL_PARAM_OFFSET_XMLS_ID1\t4\n#define CTL_PARAM_OFFSET_XMLS_ID2\t6\n#define CTL_PARAM_OFFSET_PHY_CH_X\t8\n#define CTL_PARAM_OFFSET_PHY_CH_Y\t10\n#define CTL_PARAM_OFFSET_PHY_X0\t\t12\n#define CTL_PARAM_OFFSET_PHY_X1\t\t14\n#define CTL_PARAM_OFFSET_PHY_Y0\t\t16\n#define CTL_PARAM_OFFSET_PHY_Y1\t\t18\n#define CTL_PARAM_OFFSET_PHY_W\t\t22\n#define CTL_PARAM_OFFSET_PHY_H\t\t24\n#define CTL_PARAM_OFFSET_FACTOR\t\t32\n\n \n#define WDT_GD_DEVICE\t\t\t1\n#define DEV_DESC_OFFSET_VID\t\t8\n#define DEV_DESC_OFFSET_PID\t\t10\n\n \n#define PACKET_SIZE\t\t\t56\n#define VND_REQ_READ\t\t\t0x06\n#define VND_READ_DATA\t\t\t0x07\n#define VND_REQ_WRITE\t\t\t0x08\n\n#define VND_CMD_START\t\t\t0x00\n#define VND_CMD_STOP\t\t\t0x01\n#define VND_CMD_RESET\t\t\t0x09\n\n#define VND_CMD_ERASE\t\t\t0x1A\n\n#define VND_GET_CHECKSUM\t\t0x66\n\n#define VND_SET_DATA\t\t\t0x83\n#define VND_SET_COMMAND_DATA\t\t0x84\n#define VND_SET_CHECKSUM_CALC\t\t0x86\n#define VND_SET_CHECKSUM_LENGTH\t\t0x87\n\n#define VND_CMD_SFLCK\t\t\t0xFC\n#define VND_CMD_SFUNL\t\t\t0xFD\n\n#define CMD_SFLCK_KEY\t\t\t0xC39B\n#define CMD_SFUNL_KEY\t\t\t0x95DA\n\n#define STRIDX_PLATFORM_ID\t\t0x80\n#define STRIDX_PARAMETERS\t\t0x81\n\n#define CMD_BUF_SIZE\t\t\t8\n#define PKT_BUF_SIZE\t\t\t64\n\n \n#define CMD_REPORT_ID_OFFSET\t\t0x0\n#define CMD_TYPE_OFFSET\t\t\t0x1\n#define CMD_INDEX_OFFSET\t\t0x2\n#define CMD_KEY_OFFSET\t\t\t0x3\n#define CMD_LENGTH_OFFSET\t\t0x4\n#define CMD_DATA_OFFSET\t\t\t0x8\n\n \n#define FOURCC_ID_RIFF\t\t\t0x46464952\n#define FOURCC_ID_WHIF\t\t\t0x46494857\n#define FOURCC_ID_FRMT\t\t\t0x544D5246\n#define FOURCC_ID_FRWR\t\t\t0x52575246\n#define FOURCC_ID_CNFG\t\t\t0x47464E43\n\n#define CHUNK_ID_FRMT\t\t\tFOURCC_ID_FRMT\n#define CHUNK_ID_FRWR\t\t\tFOURCC_ID_FRWR\n#define CHUNK_ID_CNFG\t\t\tFOURCC_ID_CNFG\n\n#define FW_FOURCC1_OFFSET\t\t0\n#define FW_SIZE_OFFSET\t\t\t4\n#define FW_FOURCC2_OFFSET\t\t8\n#define FW_PAYLOAD_OFFSET\t\t40\n\n#define FW_CHUNK_ID_OFFSET\t\t0\n#define FW_CHUNK_SIZE_OFFSET\t\t4\n#define FW_CHUNK_TGT_START_OFFSET\t8\n#define FW_CHUNK_PAYLOAD_LEN_OFFSET\t12\n#define FW_CHUNK_SRC_START_OFFSET\t16\n#define FW_CHUNK_VERSION_OFFSET\t\t20\n#define FW_CHUNK_ATTR_OFFSET\t\t24\n#define FW_CHUNK_PAYLOAD_OFFSET\t\t32\n\n \n#define WDT_COMMAND_DELAY_MS\t\t2\n#define WDT_FLASH_WRITE_DELAY_MS\t4\n#define WDT_FLASH_ERASE_DELAY_MS\t200\n#define WDT_FW_RESET_TIME\t\t2500\n\nstruct wdt87xx_sys_param {\n\tu16\tfw_id;\n\tu16\tplat_id;\n\tu16\txmls_id1;\n\tu16\txmls_id2;\n\tu16\tphy_ch_x;\n\tu16\tphy_ch_y;\n\tu16\tphy_w;\n\tu16\tphy_h;\n\tu16\tscaling_factor;\n\tu32\tmax_x;\n\tu32\tmax_y;\n\tu16\tvendor_id;\n\tu16\tproduct_id;\n};\n\nstruct wdt87xx_data {\n\tstruct i2c_client\t\t*client;\n\tstruct input_dev\t\t*input;\n\t \n\tstruct mutex\t\t\tfw_mutex;\n\tstruct wdt87xx_sys_param\tparam;\n\tu8\t\t\t\tphys[32];\n};\n\nstatic int wdt87xx_i2c_xfer(struct i2c_client *client,\n\t\t\t    void *txdata, size_t txlen,\n\t\t\t    void *rxdata, size_t rxlen)\n{\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= txlen,\n\t\t\t.buf\t= txdata,\n\t\t},\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= rxlen,\n\t\t\t.buf\t= rxdata,\n\t\t},\n\t};\n\tint error;\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\terror = ret < 0 ? ret : -EIO;\n\t\tdev_err(&client->dev, \"%s: i2c transfer failed: %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_get_desc(struct i2c_client *client, u8 desc_idx,\n\t\t\t    u8 *buf, size_t len)\n{\n\tu8 tx_buf[] = { 0x22, 0x00, 0x10, 0x0E, 0x23, 0x00 };\n\tint error;\n\n\ttx_buf[2] |= desc_idx & 0xF;\n\n\terror = wdt87xx_i2c_xfer(client, tx_buf, sizeof(tx_buf),\n\t\t\t\t buf, len);\n\tif (error) {\n\t\tdev_err(&client->dev, \"get desc failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (buf[0] != len) {\n\t\tdev_err(&client->dev, \"unexpected response to get desc: %d\\n\",\n\t\t\tbuf[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tmdelay(WDT_COMMAND_DELAY_MS);\n\n\treturn 0;\n}\n\nstatic int wdt87xx_get_string(struct i2c_client *client, u8 str_idx,\n\t\t\t      u8 *buf, size_t len)\n{\n\tu8 tx_buf[] = { 0x22, 0x00, 0x13, 0x0E, str_idx, 0x23, 0x00 };\n\tu8 rx_buf[PKT_WRITE_SIZE];\n\tsize_t rx_len = len + 2;\n\tint error;\n\n\tif (rx_len > sizeof(rx_buf))\n\t\treturn -EINVAL;\n\n\terror = wdt87xx_i2c_xfer(client, tx_buf, sizeof(tx_buf),\n\t\t\t\t rx_buf, rx_len);\n\tif (error) {\n\t\tdev_err(&client->dev, \"get string failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (rx_buf[1] != 0x03) {\n\t\tdev_err(&client->dev, \"unexpected response to get string: %d\\n\",\n\t\t\trx_buf[1]);\n\t\treturn -EINVAL;\n\t}\n\n\trx_len = min_t(size_t, len, rx_buf[0]);\n\tmemcpy(buf, &rx_buf[2], rx_len);\n\n\tmdelay(WDT_COMMAND_DELAY_MS);\n\n\treturn 0;\n}\n\nstatic int wdt87xx_get_feature(struct i2c_client *client,\n\t\t\t       u8 *buf, size_t buf_size)\n{\n\tu8 tx_buf[8];\n\tu8 rx_buf[PKT_WRITE_SIZE];\n\tsize_t tx_len = 0;\n\tsize_t rx_len = buf_size + 2;\n\tint error;\n\n\tif (rx_len > sizeof(rx_buf))\n\t\treturn -EINVAL;\n\n\t \n\ttx_buf[tx_len++] = 0x22;\n\ttx_buf[tx_len++] = 0x00;\n\tif (buf[CMD_REPORT_ID_OFFSET] > 0xF) {\n\t\ttx_buf[tx_len++] = 0x30;\n\t\ttx_buf[tx_len++] = 0x02;\n\t\ttx_buf[tx_len++] = buf[CMD_REPORT_ID_OFFSET];\n\t} else {\n\t\ttx_buf[tx_len++] = 0x30 | buf[CMD_REPORT_ID_OFFSET];\n\t\ttx_buf[tx_len++] = 0x02;\n\t}\n\ttx_buf[tx_len++] = 0x23;\n\ttx_buf[tx_len++] = 0x00;\n\n\terror = wdt87xx_i2c_xfer(client, tx_buf, tx_len, rx_buf, rx_len);\n\tif (error) {\n\t\tdev_err(&client->dev, \"get feature failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\trx_len = min_t(size_t, buf_size, get_unaligned_le16(rx_buf));\n\tmemcpy(buf, &rx_buf[2], rx_len);\n\n\tmdelay(WDT_COMMAND_DELAY_MS);\n\n\treturn 0;\n}\n\nstatic int wdt87xx_set_feature(struct i2c_client *client,\n\t\t\t       const u8 *buf, size_t buf_size)\n{\n\tu8 tx_buf[PKT_WRITE_SIZE];\n\tint tx_len = 0;\n\tint error;\n\n\t \n\ttx_buf[tx_len++] = 0x22;\n\ttx_buf[tx_len++] = 0x00;\n\tif (buf[CMD_REPORT_ID_OFFSET] > 0xF) {\n\t\ttx_buf[tx_len++] = 0x30;\n\t\ttx_buf[tx_len++] = 0x03;\n\t\ttx_buf[tx_len++] = buf[CMD_REPORT_ID_OFFSET];\n\t} else {\n\t\ttx_buf[tx_len++] = 0x30 | buf[CMD_REPORT_ID_OFFSET];\n\t\ttx_buf[tx_len++] = 0x03;\n\t}\n\ttx_buf[tx_len++] = 0x23;\n\ttx_buf[tx_len++] = 0x00;\n\ttx_buf[tx_len++] = (buf_size & 0xFF);\n\ttx_buf[tx_len++] = ((buf_size & 0xFF00) >> 8);\n\n\tif (tx_len + buf_size > sizeof(tx_buf))\n\t\treturn -EINVAL;\n\n\tmemcpy(&tx_buf[tx_len], buf, buf_size);\n\ttx_len += buf_size;\n\n\terror = i2c_master_send(client, tx_buf, tx_len);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"set feature failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tmdelay(WDT_COMMAND_DELAY_MS);\n\n\treturn 0;\n}\n\nstatic int wdt87xx_send_command(struct i2c_client *client, int cmd, int value)\n{\n\tu8 cmd_buf[CMD_BUF_SIZE];\n\n\t \n\tcmd_buf[CMD_REPORT_ID_OFFSET] = VND_REQ_WRITE;\n\tcmd_buf[CMD_TYPE_OFFSET] = VND_SET_COMMAND_DATA;\n\tput_unaligned_le16((u16)cmd, &cmd_buf[CMD_INDEX_OFFSET]);\n\n\tswitch (cmd) {\n\tcase VND_CMD_START:\n\tcase VND_CMD_STOP:\n\tcase VND_CMD_RESET:\n\t\t \n\t\tput_unaligned_le32((value & 0xFF), &cmd_buf[CMD_LENGTH_OFFSET]);\n\t\tbreak;\n\n\tcase VND_CMD_SFLCK:\n\t\tput_unaligned_le16(CMD_SFLCK_KEY, &cmd_buf[CMD_KEY_OFFSET]);\n\t\tbreak;\n\n\tcase VND_CMD_SFUNL:\n\t\tput_unaligned_le16(CMD_SFUNL_KEY, &cmd_buf[CMD_KEY_OFFSET]);\n\t\tbreak;\n\n\tcase VND_CMD_ERASE:\n\tcase VND_SET_CHECKSUM_CALC:\n\tcase VND_SET_CHECKSUM_LENGTH:\n\t\tput_unaligned_le32(value, &cmd_buf[CMD_KEY_OFFSET]);\n\t\tbreak;\n\n\tdefault:\n\t\tcmd_buf[CMD_REPORT_ID_OFFSET] = 0;\n\t\tdev_err(&client->dev, \"Invalid command: %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn wdt87xx_set_feature(client, cmd_buf, sizeof(cmd_buf));\n}\n\nstatic int wdt87xx_sw_reset(struct i2c_client *client)\n{\n\tint error;\n\n\tdev_dbg(&client->dev, \"resetting device now\\n\");\n\n\terror = wdt87xx_send_command(client, VND_CMD_RESET, 0);\n\tif (error) {\n\t\tdev_err(&client->dev, \"reset failed\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tmsleep(WDT_FW_RESET_TIME);\n\n\treturn 0;\n}\n\nstatic const void *wdt87xx_get_fw_chunk(const struct firmware *fw, u32 id)\n{\n\tsize_t pos = FW_PAYLOAD_OFFSET;\n\tu32 chunk_id, chunk_size;\n\n\twhile (pos < fw->size) {\n\t\tchunk_id = get_unaligned_le32(fw->data +\n\t\t\t\t\t      pos + FW_CHUNK_ID_OFFSET);\n\t\tif (chunk_id == id)\n\t\t\treturn fw->data + pos;\n\n\t\tchunk_size = get_unaligned_le32(fw->data +\n\t\t\t\t\t\tpos + FW_CHUNK_SIZE_OFFSET);\n\t\tpos += chunk_size + 2 * sizeof(u32);  \n\t}\n\n\treturn NULL;\n}\n\nstatic int wdt87xx_get_sysparam(struct i2c_client *client,\n\t\t\t\tstruct wdt87xx_sys_param *param)\n{\n\tu8 buf[PKT_READ_SIZE];\n\tint error;\n\n\terror = wdt87xx_get_desc(client, WDT_GD_DEVICE, buf, 18);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get device desc\\n\");\n\t\treturn error;\n\t}\n\n\tparam->vendor_id = get_unaligned_le16(buf + DEV_DESC_OFFSET_VID);\n\tparam->product_id = get_unaligned_le16(buf + DEV_DESC_OFFSET_PID);\n\n\terror = wdt87xx_get_string(client, STRIDX_PARAMETERS, buf, 34);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get parameters\\n\");\n\t\treturn error;\n\t}\n\n\tparam->xmls_id1 = get_unaligned_le16(buf + CTL_PARAM_OFFSET_XMLS_ID1);\n\tparam->xmls_id2 = get_unaligned_le16(buf + CTL_PARAM_OFFSET_XMLS_ID2);\n\tparam->phy_ch_x = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_CH_X);\n\tparam->phy_ch_y = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_CH_Y);\n\tparam->phy_w = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_W) / 10;\n\tparam->phy_h = get_unaligned_le16(buf + CTL_PARAM_OFFSET_PHY_H) / 10;\n\n\t \n\tparam->scaling_factor =\n\t\t\tget_unaligned_le16(buf + CTL_PARAM_OFFSET_FACTOR);\n\n\tparam->max_x = MAX_UNIT_AXIS;\n\tparam->max_y = DIV_ROUND_CLOSEST(MAX_UNIT_AXIS * param->phy_h,\n\t\t\t\t\t param->phy_w);\n\n\terror = wdt87xx_get_string(client, STRIDX_PLATFORM_ID, buf, 8);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get platform id\\n\");\n\t\treturn error;\n\t}\n\n\tparam->plat_id = buf[1];\n\n\tbuf[0] = 0xf2;\n\terror = wdt87xx_get_feature(client, buf, 16);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to get firmware id\\n\");\n\t\treturn error;\n\t}\n\n\tif (buf[0] != 0xf2) {\n\t\tdev_err(&client->dev, \"wrong id of fw response: 0x%x\\n\",\n\t\t\tbuf[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tparam->fw_id = get_unaligned_le16(&buf[1]);\n\n\tdev_info(&client->dev,\n\t\t \"fw_id: 0x%x, plat_id: 0x%x, xml_id1: %04x, xml_id2: %04x\\n\",\n\t\t param->fw_id, param->plat_id,\n\t\t param->xmls_id1, param->xmls_id2);\n\n\treturn 0;\n}\n\nstatic int wdt87xx_validate_firmware(struct wdt87xx_data *wdt,\n\t\t\t\t     const struct firmware *fw)\n{\n\tconst void *fw_chunk;\n\tu32 data1, data2;\n\tu32 size;\n\tu8 fw_chip_id;\n\tu8 chip_id;\n\n\tdata1 = get_unaligned_le32(fw->data + FW_FOURCC1_OFFSET);\n\tdata2 = get_unaligned_le32(fw->data + FW_FOURCC2_OFFSET);\n\tif (data1 != FOURCC_ID_RIFF || data2 != FOURCC_ID_WHIF) {\n\t\tdev_err(&wdt->client->dev, \"check fw tag failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = get_unaligned_le32(fw->data + FW_SIZE_OFFSET);\n\tif (size != fw->size) {\n\t\tdev_err(&wdt->client->dev,\n\t\t\t\"fw size mismatch: expected %d, actual %zu\\n\",\n\t\t\tsize, fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfw_chunk = wdt87xx_get_fw_chunk(fw, CHUNK_ID_FRWR);\n\tif (!fw_chunk) {\n\t\tdev_err(&wdt->client->dev,\n\t\t\t\"unable to locate firmware chunk\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_chip_id = (get_unaligned_le32(fw_chunk +\n\t\t\t\t\t FW_CHUNK_VERSION_OFFSET) >> 12) & 0xF;\n\tchip_id = (wdt->param.fw_id >> 12) & 0xF;\n\n\tif (fw_chip_id != chip_id) {\n\t\tdev_err(&wdt->client->dev,\n\t\t\t\"fw version mismatch: fw %d vs. chip %d\\n\",\n\t\t\tfw_chip_id, chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_validate_fw_chunk(const void *data, int id)\n{\n\tif (id == CHUNK_ID_FRWR) {\n\t\tu32 fw_id;\n\n\t\tfw_id = get_unaligned_le32(data + FW_CHUNK_PAYLOAD_OFFSET);\n\t\tif (fw_id != WDT_FIRMWARE_ID)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_write_data(struct i2c_client *client, const char *data,\n\t\t\t      u32 address, int length)\n{\n\tu16 packet_size;\n\tint count = 0;\n\tint error;\n\tu8 pkt_buf[PKT_BUF_SIZE];\n\n\t \n\tif ((address & 0x3) != 0 || (length & 0x3) != 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"addr & len must be 4 bytes aligned %x, %x\\n\",\n\t\t\taddress, length);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (length) {\n\t\tpacket_size = min(length, PACKET_SIZE);\n\n\t\tpkt_buf[CMD_REPORT_ID_OFFSET] = VND_REQ_WRITE;\n\t\tpkt_buf[CMD_TYPE_OFFSET] = VND_SET_DATA;\n\t\tput_unaligned_le16(packet_size, &pkt_buf[CMD_INDEX_OFFSET]);\n\t\tput_unaligned_le32(address, &pkt_buf[CMD_LENGTH_OFFSET]);\n\t\tmemcpy(&pkt_buf[CMD_DATA_OFFSET], data, packet_size);\n\n\t\terror = wdt87xx_set_feature(client, pkt_buf, sizeof(pkt_buf));\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tlength -= packet_size;\n\t\tdata += packet_size;\n\t\taddress += packet_size;\n\n\t\t \n\t\tmdelay(WDT_FLASH_WRITE_DELAY_MS);\n\n\t\tif ((++count % 32) == 0) {\n\t\t\t \n\t\t\tmsleep(20);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u16 misr(u16 cur_value, u8 new_value)\n{\n\tu32 a, b;\n\tu32 bit0;\n\tu32 y;\n\n\ta = cur_value;\n\tb = new_value;\n\tbit0 = a ^ (b & 1);\n\tbit0 ^= a >> 1;\n\tbit0 ^= a >> 2;\n\tbit0 ^= a >> 4;\n\tbit0 ^= a >> 5;\n\tbit0 ^= a >> 7;\n\tbit0 ^= a >> 11;\n\tbit0 ^= a >> 15;\n\ty = (a << 1) ^ b;\n\ty = (y & ~1) | (bit0 & 1);\n\n\treturn (u16)y;\n}\n\nstatic u16 wdt87xx_calculate_checksum(const u8 *data, size_t length)\n{\n\tu16 checksum = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < length; i++)\n\t\tchecksum = misr(checksum, data[i]);\n\n\treturn checksum;\n}\n\nstatic int wdt87xx_get_checksum(struct i2c_client *client, u16 *checksum,\n\t\t\t\tu32 address, int length)\n{\n\tint error;\n\tint time_delay;\n\tu8 pkt_buf[PKT_BUF_SIZE];\n\tu8 cmd_buf[CMD_BUF_SIZE];\n\n\terror = wdt87xx_send_command(client, VND_SET_CHECKSUM_LENGTH, length);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to set checksum length\\n\");\n\t\treturn error;\n\t}\n\n\terror = wdt87xx_send_command(client, VND_SET_CHECKSUM_CALC, address);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to set checksum address\\n\");\n\t\treturn error;\n\t}\n\n\t \n\ttime_delay = DIV_ROUND_UP(length, 1024);\n\tmsleep(time_delay * 30);\n\n\tmemset(cmd_buf, 0, sizeof(cmd_buf));\n\tcmd_buf[CMD_REPORT_ID_OFFSET] = VND_REQ_READ;\n\tcmd_buf[CMD_TYPE_OFFSET] = VND_GET_CHECKSUM;\n\terror = wdt87xx_set_feature(client, cmd_buf, sizeof(cmd_buf));\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to request checksum\\n\");\n\t\treturn error;\n\t}\n\n\tmemset(pkt_buf, 0, sizeof(pkt_buf));\n\tpkt_buf[CMD_REPORT_ID_OFFSET] = VND_READ_DATA;\n\terror = wdt87xx_get_feature(client, pkt_buf, sizeof(pkt_buf));\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to read checksum\\n\");\n\t\treturn error;\n\t}\n\n\t*checksum = get_unaligned_le16(&pkt_buf[CMD_DATA_OFFSET]);\n\treturn 0;\n}\n\nstatic int wdt87xx_write_firmware(struct i2c_client *client, const void *chunk)\n{\n\tu32 start_addr = get_unaligned_le32(chunk + FW_CHUNK_TGT_START_OFFSET);\n\tu32 size = get_unaligned_le32(chunk + FW_CHUNK_PAYLOAD_LEN_OFFSET);\n\tconst void *data = chunk + FW_CHUNK_PAYLOAD_OFFSET;\n\tint error;\n\tint err1;\n\tint page_size;\n\tint retry = 0;\n\tu16 device_checksum, firmware_checksum;\n\n\tdev_dbg(&client->dev, \"start 4k page program\\n\");\n\n\terror = wdt87xx_send_command(client, VND_CMD_STOP, MODE_STOP);\n\tif (error) {\n\t\tdev_err(&client->dev, \"stop report mode failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = wdt87xx_send_command(client, VND_CMD_SFUNL, 0);\n\tif (error) {\n\t\tdev_err(&client->dev, \"unlock failed\\n\");\n\t\tgoto out_enable_reporting;\n\t}\n\n\tmdelay(10);\n\n\twhile (size) {\n\t\tdev_dbg(&client->dev, \"%s: %x, %x\\n\", __func__,\n\t\t\tstart_addr, size);\n\n\t\tpage_size = min_t(u32, size, PG_SIZE);\n\t\tsize -= page_size;\n\n\t\tfor (retry = 0; retry < MAX_RETRIES; retry++) {\n\t\t\terror = wdt87xx_send_command(client, VND_CMD_ERASE,\n\t\t\t\t\t\t     start_addr);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"erase failed at %#08x\\n\", start_addr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsleep(WDT_FLASH_ERASE_DELAY_MS);\n\n\t\t\terror = wdt87xx_write_data(client, data, start_addr,\n\t\t\t\t\t\t   page_size);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"write failed at %#08x (%d bytes)\\n\",\n\t\t\t\t\tstart_addr, page_size);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terror = wdt87xx_get_checksum(client, &device_checksum,\n\t\t\t\t\t\t     start_addr, page_size);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"failed to retrieve checksum for %#08x (len: %d)\\n\",\n\t\t\t\t\tstart_addr, page_size);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirmware_checksum =\n\t\t\t\twdt87xx_calculate_checksum(data, page_size);\n\n\t\t\tif (device_checksum == firmware_checksum)\n\t\t\t\tbreak;\n\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"checksum fail: %d vs %d, retry %d\\n\",\n\t\t\t\tdevice_checksum, firmware_checksum, retry);\n\t\t}\n\n\t\tif (retry == MAX_RETRIES) {\n\t\t\tdev_err(&client->dev, \"page write failed\\n\");\n\t\t\terror = -EIO;\n\t\t\tgoto out_lock_device;\n\t\t}\n\n\t\tstart_addr = start_addr + page_size;\n\t\tdata = data + page_size;\n\t}\n\nout_lock_device:\n\terr1 = wdt87xx_send_command(client, VND_CMD_SFLCK, 0);\n\tif (err1)\n\t\tdev_err(&client->dev, \"lock failed\\n\");\n\n\tmdelay(10);\n\nout_enable_reporting:\n\terr1 = wdt87xx_send_command(client, VND_CMD_START, 0);\n\tif (err1)\n\t\tdev_err(&client->dev, \"start to report failed\\n\");\n\n\treturn error ? error : err1;\n}\n\nstatic int wdt87xx_load_chunk(struct i2c_client *client,\n\t\t\t      const struct firmware *fw, u32 ck_id)\n{\n\tconst void *chunk;\n\tint error;\n\n\tchunk = wdt87xx_get_fw_chunk(fw, ck_id);\n\tif (!chunk) {\n\t\tdev_err(&client->dev, \"unable to locate chunk (type %d)\\n\",\n\t\t\tck_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = wdt87xx_validate_fw_chunk(chunk, ck_id);\n\tif (error) {\n\t\tdev_err(&client->dev, \"invalid chunk (type %d): %d\\n\",\n\t\t\tck_id, error);\n\t\treturn error;\n\t}\n\n\terror = wdt87xx_write_firmware(client, chunk);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to write fw chunk (type %d): %d\\n\",\n\t\t\tck_id, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_do_update_firmware(struct i2c_client *client,\n\t\t\t\t      const struct firmware *fw,\n\t\t\t\t      unsigned int chunk_id)\n{\n\tstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\n\tint error;\n\n\terror = wdt87xx_validate_firmware(wdt, fw);\n\tif (error)\n\t\treturn error;\n\n\terror = mutex_lock_interruptible(&wdt->fw_mutex);\n\tif (error)\n\t\treturn error;\n\n\tdisable_irq(client->irq);\n\n\terror = wdt87xx_load_chunk(client, fw, chunk_id);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"firmware load failed (type: %d): %d\\n\",\n\t\t\tchunk_id, error);\n\t\tgoto out;\n\t}\n\n\terror = wdt87xx_sw_reset(client);\n\tif (error) {\n\t\tdev_err(&client->dev, \"soft reset failed: %d\\n\", error);\n\t\tgoto out;\n\t}\n\n\t \n\terror = wdt87xx_get_sysparam(client, &wdt->param);\n\tif (error)\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to refresh system parameters: %d\\n\", error);\nout:\n\tenable_irq(client->irq);\n\tmutex_unlock(&wdt->fw_mutex);\n\n\treturn error ? error : 0;\n}\n\nstatic int wdt87xx_update_firmware(struct device *dev,\n\t\t\t\t   const char *fw_name, unsigned int chunk_id)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tconst struct firmware *fw;\n\tint error;\n\n\terror = request_firmware(&fw, fw_name, dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"unable to retrieve firmware %s: %d\\n\",\n\t\t\tfw_name, error);\n\t\treturn error;\n\t}\n\n\terror = wdt87xx_do_update_firmware(client, fw, chunk_id);\n\n\trelease_firmware(fw);\n\n\treturn error ? error : 0;\n}\n\nstatic ssize_t config_csum_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\n\tu32 cfg_csum;\n\n\tcfg_csum = wdt->param.xmls_id1;\n\tcfg_csum = (cfg_csum << 16) | wdt->param.xmls_id2;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%x\\n\", cfg_csum);\n}\n\nstatic ssize_t fw_version_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%x\\n\", wdt->param.fw_id);\n}\n\nstatic ssize_t plat_id_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct wdt87xx_data *wdt = i2c_get_clientdata(client);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%x\\n\", wdt->param.plat_id);\n}\n\nstatic ssize_t update_config_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint error;\n\n\terror = wdt87xx_update_firmware(dev, WDT87XX_CFG_NAME, CHUNK_ID_CNFG);\n\n\treturn error ? error : count;\n}\n\nstatic ssize_t update_fw_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tint error;\n\n\terror = wdt87xx_update_firmware(dev, WDT87XX_FW_NAME, CHUNK_ID_FRWR);\n\n\treturn error ? error : count;\n}\n\nstatic DEVICE_ATTR_RO(config_csum);\nstatic DEVICE_ATTR_RO(fw_version);\nstatic DEVICE_ATTR_RO(plat_id);\nstatic DEVICE_ATTR_WO(update_config);\nstatic DEVICE_ATTR_WO(update_fw);\n\nstatic struct attribute *wdt87xx_attrs[] = {\n\t&dev_attr_config_csum.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_plat_id.attr,\n\t&dev_attr_update_config.attr,\n\t&dev_attr_update_fw.attr,\n\tNULL\n};\n\nstatic const struct attribute_group wdt87xx_attr_group = {\n\t.attrs = wdt87xx_attrs,\n};\n\nstatic void wdt87xx_report_contact(struct input_dev *input,\n\t\t\t\t   struct wdt87xx_sys_param *param,\n\t\t\t\t   u8 *buf)\n{\n\tint finger_id;\n\tu32 x, y, w;\n\tu8 p;\n\n\tfinger_id = (buf[FINGER_EV_V1_OFFSET_ID] >> 3) - 1;\n\tif (finger_id < 0)\n\t\treturn;\n\n\t \n\tif (!(buf[FINGER_EV_V1_OFFSET_ID] & 0x1))\n\t\treturn;\n\n\tw = buf[FINGER_EV_V1_OFFSET_W];\n\tw *= param->scaling_factor;\n\n\tp = buf[FINGER_EV_V1_OFFSET_P];\n\n\tx = get_unaligned_le16(buf + FINGER_EV_V1_OFFSET_X);\n\n\ty = get_unaligned_le16(buf + FINGER_EV_V1_OFFSET_Y);\n\ty = DIV_ROUND_CLOSEST(y * param->phy_h, param->phy_w);\n\n\t \n\tif (x > param->max_x || y > param->max_y)\n\t\treturn;\n\n\tdev_dbg(input->dev.parent, \"tip on (%d), x(%d), y(%d)\\n\",\n\t\tfinger_id, x, y);\n\n\tinput_mt_slot(input, finger_id);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, 1);\n\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, w);\n\tinput_report_abs(input, ABS_MT_PRESSURE, p);\n\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n}\n\nstatic irqreturn_t wdt87xx_ts_interrupt(int irq, void *dev_id)\n{\n\tstruct wdt87xx_data *wdt = dev_id;\n\tstruct i2c_client *client = wdt->client;\n\tint i, fingers;\n\tint error;\n\tu8 raw_buf[WDT_V1_RAW_BUF_COUNT] = {0};\n\n\terror = i2c_master_recv(client, raw_buf, WDT_V1_RAW_BUF_COUNT);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"read v1 raw data failed: %d\\n\", error);\n\t\tgoto irq_exit;\n\t}\n\n\tfingers = raw_buf[TOUCH_PK_V1_OFFSET_FNGR_NUM];\n\tif (!fingers)\n\t\tgoto irq_exit;\n\n\tfor (i = 0; i < WDT_MAX_FINGER; i++)\n\t\twdt87xx_report_contact(wdt->input,\n\t\t\t\t       &wdt->param,\n\t\t\t\t       &raw_buf[TOUCH_PK_V1_OFFSET_EVENT +\n\t\t\t\t\t\ti * FINGER_EV_V1_SIZE]);\n\n\tinput_mt_sync_frame(wdt->input);\n\tinput_sync(wdt->input);\n\nirq_exit:\n\treturn IRQ_HANDLED;\n}\n\nstatic int wdt87xx_ts_create_input_device(struct wdt87xx_data *wdt)\n{\n\tstruct device *dev = &wdt->client->dev;\n\tstruct input_dev *input;\n\tunsigned int res = DIV_ROUND_CLOSEST(MAX_UNIT_AXIS, wdt->param.phy_w);\n\tint error;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\twdt->input = input;\n\n\tinput->name = \"WDT87xx Touchscreen\";\n\tinput->id.bustype = BUS_I2C;\n\tinput->id.vendor = wdt->param.vendor_id;\n\tinput->id.product = wdt->param.product_id;\n\tinput->phys = wdt->phys;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0,\n\t\t\t     wdt->param.max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\n\t\t\t     wdt->param.max_y, 0, 0);\n\tinput_abs_set_res(input, ABS_MT_POSITION_X, res);\n\tinput_abs_set_res(input, ABS_MT_POSITION_Y, res);\n\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\n\t\t\t     0, wdt->param.max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xFF, 0, 0);\n\n\tinput_mt_init_slots(input, WDT_MAX_FINGER,\n\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_ts_probe(struct i2c_client *client)\n{\n\tstruct wdt87xx_data *wdt;\n\tint error;\n\n\tdev_dbg(&client->dev, \"adapter=%d, client irq: %d\\n\",\n\t\tclient->adapter->nr, client->irq);\n\n\t \n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENXIO;\n\n\twdt = devm_kzalloc(&client->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->client = client;\n\tmutex_init(&wdt->fw_mutex);\n\ti2c_set_clientdata(client, wdt);\n\n\tsnprintf(wdt->phys, sizeof(wdt->phys), \"i2c-%u-%04x/input0\",\n\t\t client->adapter->nr, client->addr);\n\n\terror = wdt87xx_get_sysparam(client, &wdt->param);\n\tif (error)\n\t\treturn error;\n\n\terror = wdt87xx_ts_create_input_device(wdt);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, wdt87xx_ts_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  client->name, wdt);\n\tif (error) {\n\t\tdev_err(&client->dev, \"request irq failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(&client->dev, &wdt87xx_attr_group);\n\tif (error) {\n\t\tdev_err(&client->dev, \"create sysfs failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\terror = wdt87xx_send_command(client, VND_CMD_STOP, MODE_IDLE);\n\tif (error) {\n\t\tenable_irq(client->irq);\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to stop device when suspending: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wdt87xx_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint error;\n\n\t \n\tmsleep(100);\n\n\terror = wdt87xx_send_command(client, VND_CMD_START, 0);\n\tif (error)\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to start device when resuming: %d\\n\",\n\t\t\terror);\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(wdt87xx_pm_ops, wdt87xx_suspend, wdt87xx_resume);\n\nstatic const struct i2c_device_id wdt87xx_dev_id[] = {\n\t{ WDT87XX_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wdt87xx_dev_id);\n\nstatic const struct acpi_device_id wdt87xx_acpi_id[] = {\n\t{ \"WDHT0001\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, wdt87xx_acpi_id);\n\nstatic struct i2c_driver wdt87xx_driver = {\n\t.probe\t\t= wdt87xx_ts_probe,\n\t.id_table\t= wdt87xx_dev_id,\n\t.driver\t= {\n\t\t.name\t= WDT87XX_NAME,\n\t\t.pm     = pm_sleep_ptr(&wdt87xx_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(wdt87xx_acpi_id),\n\t},\n};\nmodule_i2c_driver(wdt87xx_driver);\n\nMODULE_AUTHOR(\"HN Chen <hn.chen@weidahitech.com>\");\nMODULE_DESCRIPTION(\"WeidaHiTech WDT87XX Touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}