{
  "module_name": "sun4i-ts.c",
  "hash_id": "09846732a0e9706e278575334de9098763478fad1a640f2166fe3eb2c1261e48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/sun4i-ts.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/hwmon.h>\n#include <linux/thermal.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define TP_CTRL0\t\t0x00\n#define TP_CTRL1\t\t0x04\n#define TP_CTRL2\t\t0x08\n#define TP_CTRL3\t\t0x0c\n#define TP_INT_FIFOC\t\t0x10\n#define TP_INT_FIFOS\t\t0x14\n#define TP_TPR\t\t\t0x18\n#define TP_CDAT\t\t\t0x1c\n#define TEMP_DATA\t\t0x20\n#define TP_DATA\t\t\t0x24\n\n \n#define ADC_FIRST_DLY(x)\t((x) << 24)  \n#define ADC_FIRST_DLY_MODE(x)\t((x) << 23)\n#define ADC_CLK_SEL(x)\t\t((x) << 22)\n#define ADC_CLK_DIV(x)\t\t((x) << 20)  \n#define FS_DIV(x)\t\t((x) << 16)  \n#define T_ACQ(x)\t\t((x) << 0)  \n\n \n#define STYLUS_UP_DEBOUN(x)\t((x) << 12)  \n#define STYLUS_UP_DEBOUN_EN(x)\t((x) << 9)\n#define TOUCH_PAN_CALI_EN(x)\t((x) << 6)\n#define TP_DUAL_EN(x)\t\t((x) << 5)\n#define TP_MODE_EN(x)\t\t((x) << 4)\n#define TP_ADC_SELECT(x)\t((x) << 3)\n#define ADC_CHAN_SELECT(x)\t((x) << 0)   \n\n \n#define SUN6I_TP_MODE_EN(x)\t((x) << 5)\n\n \n#define TP_SENSITIVE_ADJUST(x)\t((x) << 28)  \n#define TP_MODE_SELECT(x)\t((x) << 26)  \n#define PRE_MEA_EN(x)\t\t((x) << 24)\n#define PRE_MEA_THRE_CNT(x)\t((x) << 0)  \n\n \n#define FILTER_EN(x)\t\t((x) << 2)\n#define FILTER_TYPE(x)\t\t((x) << 0)   \n\n \n#define TEMP_IRQ_EN(x)\t\t((x) << 18)\n#define OVERRUN_IRQ_EN(x)\t((x) << 17)\n#define DATA_IRQ_EN(x)\t\t((x) << 16)\n#define TP_DATA_XY_CHANGE(x)\t((x) << 13)\n#define FIFO_TRIG(x)\t\t((x) << 8)   \n#define DATA_DRQ_EN(x)\t\t((x) << 7)\n#define FIFO_FLUSH(x)\t\t((x) << 4)\n#define TP_UP_IRQ_EN(x)\t\t((x) << 1)\n#define TP_DOWN_IRQ_EN(x)\t((x) << 0)\n\n \n#define TEMP_DATA_PENDING\tBIT(18)\n#define FIFO_OVERRUN_PENDING\tBIT(17)\n#define FIFO_DATA_PENDING\tBIT(16)\n#define TP_IDLE_FLG\t\tBIT(2)\n#define TP_UP_PENDING\t\tBIT(1)\n#define TP_DOWN_PENDING\t\tBIT(0)\n\n \n#define TEMP_ENABLE(x)\t\t((x) << 16)\n#define TEMP_PERIOD(x)\t\t((x) << 0)   \n\nstruct sun4i_ts_data {\n\tstruct device *dev;\n\tstruct input_dev *input;\n\tvoid __iomem *base;\n\tunsigned int irq;\n\tbool ignore_fifo_data;\n\tint temp_data;\n\tint temp_offset;\n\tint temp_step;\n};\n\nstatic void sun4i_ts_irq_handle_input(struct sun4i_ts_data *ts, u32 reg_val)\n{\n\tu32 x, y;\n\n\tif (reg_val & FIFO_DATA_PENDING) {\n\t\tx = readl(ts->base + TP_DATA);\n\t\ty = readl(ts->base + TP_DATA);\n\t\t \n\t\tif (!ts->ignore_fifo_data) {\n\t\t\tinput_report_abs(ts->input, ABS_X, x);\n\t\t\tinput_report_abs(ts->input, ABS_Y, y);\n\t\t\t \n\t\t\tinput_report_key(ts->input, BTN_TOUCH, 1);\n\t\t\tinput_sync(ts->input);\n\t\t} else {\n\t\t\tts->ignore_fifo_data = false;\n\t\t}\n\t}\n\n\tif (reg_val & TP_UP_PENDING) {\n\t\tts->ignore_fifo_data = true;\n\t\tinput_report_key(ts->input, BTN_TOUCH, 0);\n\t\tinput_sync(ts->input);\n\t}\n}\n\nstatic irqreturn_t sun4i_ts_irq(int irq, void *dev_id)\n{\n\tstruct sun4i_ts_data *ts = dev_id;\n\tu32 reg_val;\n\n\treg_val  = readl(ts->base + TP_INT_FIFOS);\n\n\tif (reg_val & TEMP_DATA_PENDING)\n\t\tts->temp_data = readl(ts->base + TEMP_DATA);\n\n\tif (ts->input)\n\t\tsun4i_ts_irq_handle_input(ts, reg_val);\n\n\twritel(reg_val, ts->base + TP_INT_FIFOS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_ts_open(struct input_dev *dev)\n{\n\tstruct sun4i_ts_data *ts = input_get_drvdata(dev);\n\n\t \n\twritel(TEMP_IRQ_EN(1) | DATA_IRQ_EN(1) | FIFO_TRIG(1) | FIFO_FLUSH(1) |\n\t\tTP_UP_IRQ_EN(1), ts->base + TP_INT_FIFOC);\n\n\treturn 0;\n}\n\nstatic void sun4i_ts_close(struct input_dev *dev)\n{\n\tstruct sun4i_ts_data *ts = input_get_drvdata(dev);\n\n\t \n\twritel(TEMP_IRQ_EN(1), ts->base + TP_INT_FIFOC);\n}\n\nstatic int sun4i_get_temp(const struct sun4i_ts_data *ts, int *temp)\n{\n\t \n\tif (ts->temp_data == -1)\n\t\treturn -EAGAIN;\n\n\t*temp = ts->temp_data * ts->temp_step - ts->temp_offset;\n\n\treturn 0;\n}\n\nstatic int sun4i_get_tz_temp(struct thermal_zone_device *tz, int *temp)\n{\n\treturn sun4i_get_temp(thermal_zone_device_priv(tz), temp);\n}\n\nstatic const struct thermal_zone_device_ops sun4i_ts_tz_ops = {\n\t.get_temp = sun4i_get_tz_temp,\n};\n\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tstruct sun4i_ts_data *ts = dev_get_drvdata(dev);\n\tint temp;\n\tint error;\n\n\terror = sun4i_get_temp(ts, &temp);\n\tif (error)\n\t\treturn error;\n\n\treturn sprintf(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t show_temp_label(struct device *dev,\n\t\t\t      struct device_attribute *devattr, char *buf)\n{\n\treturn sprintf(buf, \"SoC temperature\\n\");\n}\n\nstatic DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL);\nstatic DEVICE_ATTR(temp1_label, S_IRUGO, show_temp_label, NULL);\n\nstatic struct attribute *sun4i_ts_attrs[] = {\n\t&dev_attr_temp1_input.attr,\n\t&dev_attr_temp1_label.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(sun4i_ts);\n\nstatic int sun4i_ts_probe(struct platform_device *pdev)\n{\n\tstruct sun4i_ts_data *ts;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device *hwmon;\n\tstruct thermal_zone_device *thermal;\n\tint error;\n\tu32 reg;\n\tbool ts_attached;\n\tu32 tp_sensitive_adjust = 15;\n\tu32 filter_type = 1;\n\n\tts = devm_kzalloc(dev, sizeof(struct sun4i_ts_data), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->dev = dev;\n\tts->ignore_fifo_data = true;\n\tts->temp_data = -1;\n\tif (of_device_is_compatible(np, \"allwinner,sun6i-a31-ts\")) {\n\t\t \n\t\tts->temp_offset = 271000;\n\t\tts->temp_step = 167;\n\t} else if (of_device_is_compatible(np, \"allwinner,sun4i-a10-ts\")) {\n\t\t \n\t\tts->temp_offset = 257000;\n\t\tts->temp_step = 133;\n\t} else {\n\t\t \n\t\tts->temp_offset = 144700;\n\t\tts->temp_step = 100;\n\t}\n\n\tts_attached = of_property_read_bool(np, \"allwinner,ts-attached\");\n\tif (ts_attached) {\n\t\tts->input = devm_input_allocate_device(dev);\n\t\tif (!ts->input)\n\t\t\treturn -ENOMEM;\n\n\t\tts->input->name = pdev->name;\n\t\tts->input->phys = \"sun4i_ts/input0\";\n\t\tts->input->open = sun4i_ts_open;\n\t\tts->input->close = sun4i_ts_close;\n\t\tts->input->id.bustype = BUS_HOST;\n\t\tts->input->id.vendor = 0x0001;\n\t\tts->input->id.product = 0x0001;\n\t\tts->input->id.version = 0x0100;\n\t\tts->input->evbit[0] =  BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);\n\t\t__set_bit(BTN_TOUCH, ts->input->keybit);\n\t\tinput_set_abs_params(ts->input, ABS_X, 0, 4095, 0, 0);\n\t\tinput_set_abs_params(ts->input, ABS_Y, 0, 4095, 0, 0);\n\t\tinput_set_drvdata(ts->input, ts);\n\t}\n\n\tts->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ts->base))\n\t\treturn PTR_ERR(ts->base);\n\n\tts->irq = platform_get_irq(pdev, 0);\n\terror = devm_request_irq(dev, ts->irq, sun4i_ts_irq, 0, \"sun4i-ts\", ts);\n\tif (error)\n\t\treturn error;\n\n\t \n\twritel(ADC_CLK_SEL(0) | ADC_CLK_DIV(2) | FS_DIV(7) | T_ACQ(63),\n\t       ts->base + TP_CTRL0);\n\n\t \n\tof_property_read_u32(np, \"allwinner,tp-sensitive-adjust\",\n\t\t\t     &tp_sensitive_adjust);\n\twritel(TP_SENSITIVE_ADJUST(tp_sensitive_adjust) | TP_MODE_SELECT(0),\n\t       ts->base + TP_CTRL2);\n\n\t \n\tof_property_read_u32(np, \"allwinner,filter-type\", &filter_type);\n\twritel(FILTER_EN(1) | FILTER_TYPE(filter_type), ts->base + TP_CTRL3);\n\n\t \n\twritel(TEMP_ENABLE(1) | TEMP_PERIOD(1953), ts->base + TP_TPR);\n\n\t \n\treg = STYLUS_UP_DEBOUN(5) | STYLUS_UP_DEBOUN_EN(1);\n\tif (of_device_is_compatible(np, \"allwinner,sun6i-a31-ts\"))\n\t\treg |= SUN6I_TP_MODE_EN(1);\n\telse\n\t\treg |= TP_MODE_EN(1);\n\twritel(reg, ts->base + TP_CTRL1);\n\n\t \n\thwmon = devm_hwmon_device_register_with_groups(ts->dev, \"sun4i_ts\",\n\t\t\t\t\t\t       ts, sun4i_ts_groups);\n\tif (IS_ERR(hwmon))\n\t\treturn PTR_ERR(hwmon);\n\n\tthermal = devm_thermal_of_zone_register(ts->dev, 0, ts,\n\t\t\t\t\t\t&sun4i_ts_tz_ops);\n\tif (IS_ERR(thermal))\n\t\treturn PTR_ERR(thermal);\n\n\twritel(TEMP_IRQ_EN(1), ts->base + TP_INT_FIFOC);\n\n\tif (ts_attached) {\n\t\terror = input_register_device(ts->input);\n\t\tif (error) {\n\t\t\twritel(0, ts->base + TP_INT_FIFOC);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, ts);\n\treturn 0;\n}\n\nstatic int sun4i_ts_remove(struct platform_device *pdev)\n{\n\tstruct sun4i_ts_data *ts = platform_get_drvdata(pdev);\n\n\t \n\tif (ts->input)\n\t\tinput_unregister_device(ts->input);\n\n\t \n\twritel(0, ts->base + TP_INT_FIFOC);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun4i_ts_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-ts\", },\n\t{ .compatible = \"allwinner,sun5i-a13-ts\", },\n\t{ .compatible = \"allwinner,sun6i-a31-ts\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun4i_ts_of_match);\n\nstatic struct platform_driver sun4i_ts_driver = {\n\t.driver = {\n\t\t.name\t= \"sun4i-ts\",\n\t\t.of_match_table = sun4i_ts_of_match,\n\t},\n\t.probe\t= sun4i_ts_probe,\n\t.remove\t= sun4i_ts_remove,\n};\n\nmodule_platform_driver(sun4i_ts_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sun4i resistive touchscreen controller driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}