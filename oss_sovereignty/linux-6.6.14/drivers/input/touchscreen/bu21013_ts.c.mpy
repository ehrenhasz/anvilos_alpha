{
  "module_name": "bu21013_ts.c",
  "hash_id": "a5e3455e8aa5ad448dac78e7c31d45bb521cc268cd49f05f40e81f2ee9d3312f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/bu21013_ts.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define MAX_FINGERS\t2\n#define RESET_DELAY\t30\n#define PENUP_TIMEOUT\t(10)\n#define DELTA_MIN\t16\n#define MASK_BITS\t0x03\n#define SHIFT_8\t\t8\n#define SHIFT_2\t\t2\n#define LENGTH_OF_BUFFER\t11\n#define I2C_RETRY_COUNT\t5\n\n#define BU21013_SENSORS_BTN_0_7_REG\t0x70\n#define BU21013_SENSORS_BTN_8_15_REG\t0x71\n#define BU21013_SENSORS_BTN_16_23_REG\t0x72\n#define BU21013_X1_POS_MSB_REG\t\t0x73\n#define BU21013_X1_POS_LSB_REG\t\t0x74\n#define BU21013_Y1_POS_MSB_REG\t\t0x75\n#define BU21013_Y1_POS_LSB_REG\t\t0x76\n#define BU21013_X2_POS_MSB_REG\t\t0x77\n#define BU21013_X2_POS_LSB_REG\t\t0x78\n#define BU21013_Y2_POS_MSB_REG\t\t0x79\n#define BU21013_Y2_POS_LSB_REG\t\t0x7A\n#define BU21013_INT_CLR_REG\t\t0xE8\n#define BU21013_INT_MODE_REG\t\t0xE9\n#define BU21013_GAIN_REG\t\t0xEA\n#define BU21013_OFFSET_MODE_REG\t\t0xEB\n#define BU21013_XY_EDGE_REG\t\t0xEC\n#define BU21013_RESET_REG\t\t0xED\n#define BU21013_CALIB_REG\t\t0xEE\n#define BU21013_DONE_REG\t\t0xEF\n#define BU21013_SENSOR_0_7_REG\t\t0xF0\n#define BU21013_SENSOR_8_15_REG\t\t0xF1\n#define BU21013_SENSOR_16_23_REG\t0xF2\n#define BU21013_POS_MODE1_REG\t\t0xF3\n#define BU21013_POS_MODE2_REG\t\t0xF4\n#define BU21013_CLK_MODE_REG\t\t0xF5\n#define BU21013_IDLE_REG\t\t0xFA\n#define BU21013_FILTER_REG\t\t0xFB\n#define BU21013_TH_ON_REG\t\t0xFC\n#define BU21013_TH_OFF_REG\t\t0xFD\n\n\n#define BU21013_RESET_ENABLE\t\t0x01\n\n#define BU21013_SENSORS_EN_0_7\t\t0x3F\n#define BU21013_SENSORS_EN_8_15\t\t0xFC\n#define BU21013_SENSORS_EN_16_23\t0x1F\n\n#define BU21013_POS_MODE1_0\t\t0x02\n#define BU21013_POS_MODE1_1\t\t0x04\n#define BU21013_POS_MODE1_2\t\t0x08\n\n#define BU21013_POS_MODE2_ZERO\t\t0x01\n#define BU21013_POS_MODE2_AVG1\t\t0x02\n#define BU21013_POS_MODE2_AVG2\t\t0x04\n#define BU21013_POS_MODE2_EN_XY\t\t0x08\n#define BU21013_POS_MODE2_EN_RAW\t0x10\n#define BU21013_POS_MODE2_MULTI\t\t0x80\n\n#define BU21013_CLK_MODE_DIV\t\t0x01\n#define BU21013_CLK_MODE_EXT\t\t0x02\n#define BU21013_CLK_MODE_CALIB\t\t0x80\n\n#define BU21013_IDLET_0\t\t\t0x01\n#define BU21013_IDLET_1\t\t\t0x02\n#define BU21013_IDLET_2\t\t\t0x04\n#define BU21013_IDLET_3\t\t\t0x08\n#define BU21013_IDLE_INTERMIT_EN\t0x10\n\n#define BU21013_DELTA_0_6\t0x7F\n#define BU21013_FILTER_EN\t0x80\n\n#define BU21013_INT_MODE_LEVEL\t0x00\n#define BU21013_INT_MODE_EDGE\t0x01\n\n#define BU21013_GAIN_0\t\t0x01\n#define BU21013_GAIN_1\t\t0x02\n#define BU21013_GAIN_2\t\t0x04\n\n#define BU21013_OFFSET_MODE_DEFAULT\t0x00\n#define BU21013_OFFSET_MODE_MOVE\t0x01\n#define BU21013_OFFSET_MODE_DISABLE\t0x02\n\n#define BU21013_TH_ON_0\t\t0x01\n#define BU21013_TH_ON_1\t\t0x02\n#define BU21013_TH_ON_2\t\t0x04\n#define BU21013_TH_ON_3\t\t0x08\n#define BU21013_TH_ON_4\t\t0x10\n#define BU21013_TH_ON_5\t\t0x20\n#define BU21013_TH_ON_6\t\t0x40\n#define BU21013_TH_ON_7\t\t0x80\n#define BU21013_TH_ON_MAX\t0xFF\n\n#define BU21013_TH_OFF_0\t0x01\n#define BU21013_TH_OFF_1\t0x02\n#define BU21013_TH_OFF_2\t0x04\n#define BU21013_TH_OFF_3\t0x08\n#define BU21013_TH_OFF_4\t0x10\n#define BU21013_TH_OFF_5\t0x20\n#define BU21013_TH_OFF_6\t0x40\n#define BU21013_TH_OFF_7\t0x80\n#define BU21013_TH_OFF_MAX\t0xFF\n\n#define BU21013_X_EDGE_0\t0x01\n#define BU21013_X_EDGE_1\t0x02\n#define BU21013_X_EDGE_2\t0x04\n#define BU21013_X_EDGE_3\t0x08\n#define BU21013_Y_EDGE_0\t0x10\n#define BU21013_Y_EDGE_1\t0x20\n#define BU21013_Y_EDGE_2\t0x40\n#define BU21013_Y_EDGE_3\t0x80\n\n#define BU21013_DONE\t0x01\n#define BU21013_NUMBER_OF_X_SENSORS\t(6)\n#define BU21013_NUMBER_OF_Y_SENSORS\t(11)\n\n#define DRIVER_TP\t\"bu21013_tp\"\n\n \nstruct bu21013_ts {\n\tstruct i2c_client *client;\n\tstruct input_dev *in_dev;\n\tstruct touchscreen_properties props;\n\tstruct regulator *regulator;\n\tstruct gpio_desc *cs_gpiod;\n\tstruct gpio_desc *int_gpiod;\n\tu32 touch_x_max;\n\tu32 touch_y_max;\n\tbool x_flip;\n\tbool y_flip;\n\tbool touch_stopped;\n};\n\nstatic int bu21013_read_block_data(struct bu21013_ts *ts, u8 *buf)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < I2C_RETRY_COUNT; i++) {\n\t\tret = i2c_smbus_read_i2c_block_data(ts->client,\n\t\t\t\t\t\t    BU21013_SENSORS_BTN_0_7_REG,\n\t\t\t\t\t\t    LENGTH_OF_BUFFER, buf);\n\t\tif (ret == LENGTH_OF_BUFFER)\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bu21013_do_touch_report(struct bu21013_ts *ts)\n{\n\tstruct input_dev *input = ts->in_dev;\n\tstruct input_mt_pos pos[MAX_FINGERS];\n\tint slots[MAX_FINGERS];\n\tu8 buf[LENGTH_OF_BUFFER];\n\tbool has_x_sensors, has_y_sensors;\n\tint finger_down_count = 0;\n\tint i;\n\n\tif (bu21013_read_block_data(ts, buf) < 0)\n\t\treturn -EINVAL;\n\n\thas_x_sensors = hweight32(buf[0] & BU21013_SENSORS_EN_0_7);\n\thas_y_sensors = hweight32(((buf[1] & BU21013_SENSORS_EN_8_15) |\n\t\t((buf[2] & BU21013_SENSORS_EN_16_23) << SHIFT_8)) >> SHIFT_2);\n\tif (!has_x_sensors || !has_y_sensors)\n\t\treturn 0;\n\n\tfor (i = 0; i < MAX_FINGERS; i++) {\n\t\tconst u8 *data = &buf[4 * i + 3];\n\t\tunsigned int x, y;\n\n\t\tx = data[0] << SHIFT_2 | (data[1] & MASK_BITS);\n\t\ty = data[2] << SHIFT_2 | (data[3] & MASK_BITS);\n\t\tif (x != 0 && y != 0)\n\t\t\ttouchscreen_set_mt_pos(&pos[finger_down_count++],\n\t\t\t\t\t       &ts->props, x, y);\n\t}\n\n\tif (finger_down_count == 2 &&\n\t    (abs(pos[0].x - pos[1].x) < DELTA_MIN ||\n\t     abs(pos[0].y - pos[1].y) < DELTA_MIN)) {\n\t\treturn 0;\n\t}\n\n\tinput_mt_assign_slots(input, slots, pos, finger_down_count, DELTA_MIN);\n\tfor (i = 0; i < finger_down_count; i++) {\n\t\tinput_mt_slot(input, slots[i]);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, pos[i].x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, pos[i].y);\n\t}\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n\n\treturn 0;\n}\n\nstatic irqreturn_t bu21013_gpio_irq(int irq, void *device_data)\n{\n\tstruct bu21013_ts *ts = device_data;\n\tint keep_polling;\n\tint error;\n\n\tdo {\n\t\terror = bu21013_do_touch_report(ts);\n\t\tif (error) {\n\t\t\tdev_err(&ts->client->dev, \"%s failed\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(ts->touch_stopped))\n\t\t\tbreak;\n\n\t\tkeep_polling = ts->int_gpiod ?\n\t\t\tgpiod_get_value(ts->int_gpiod) : false;\n\t\tif (keep_polling)\n\t\t\tusleep_range(2000, 2500);\n\t} while (keep_polling);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bu21013_init_chip(struct bu21013_ts *ts)\n{\n\tstruct i2c_client *client = ts->client;\n\tint error;\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_RESET_REG,\n\t\t\t\t\t  BU21013_RESET_ENABLE);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_RESET reg write failed\\n\");\n\t\treturn error;\n\t}\n\tmsleep(RESET_DELAY);\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_SENSOR_0_7_REG,\n\t\t\t\t\t  BU21013_SENSORS_EN_0_7);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_SENSOR_0_7 reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_SENSOR_8_15_REG,\n\t\t\t\t\t  BU21013_SENSORS_EN_8_15);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_SENSOR_8_15 reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_SENSOR_16_23_REG,\n\t\t\t\t\t  BU21013_SENSORS_EN_16_23);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_SENSOR_16_23 reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_POS_MODE1_REG,\n\t\t\t\t\t  BU21013_POS_MODE1_0 |\n\t\t\t\t\t\tBU21013_POS_MODE1_1);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_POS_MODE1 reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_POS_MODE2_REG,\n\t\t\t\t\t  BU21013_POS_MODE2_ZERO |\n\t\t\t\t\t\tBU21013_POS_MODE2_AVG1 |\n\t\t\t\t\t\tBU21013_POS_MODE2_AVG2 |\n\t\t\t\t\t\tBU21013_POS_MODE2_EN_RAW |\n\t\t\t\t\t\tBU21013_POS_MODE2_MULTI);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_POS_MODE2 reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_CLK_MODE_REG,\n\t\t\t\t\t  BU21013_CLK_MODE_DIV |\n\t\t\t\t\t\tBU21013_CLK_MODE_CALIB);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_CLK_MODE reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_IDLE_REG,\n\t\t\t\t\t  BU21013_IDLET_0 |\n\t\t\t\t\t\tBU21013_IDLE_INTERMIT_EN);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_IDLE reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_INT_MODE_REG,\n\t\t\t\t\t  BU21013_INT_MODE_LEVEL);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_INT_MODE reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_FILTER_REG,\n\t\t\t\t\t  BU21013_DELTA_0_6 |\n\t\t\t\t\t\tBU21013_FILTER_EN);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_FILTER reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_TH_ON_REG,\n\t\t\t\t\t  BU21013_TH_ON_5);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_TH_ON reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_TH_OFF_REG,\n\t\t\t\t\t  BU21013_TH_OFF_4 | BU21013_TH_OFF_3);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_TH_OFF reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_GAIN_REG,\n\t\t\t\t\t  BU21013_GAIN_0 | BU21013_GAIN_1);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_GAIN reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_OFFSET_MODE_REG,\n\t\t\t\t\t  BU21013_OFFSET_MODE_DEFAULT);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_OFFSET_MODE reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_XY_EDGE_REG,\n\t\t\t\t\t  BU21013_X_EDGE_0 |\n\t\t\t\t\t\tBU21013_X_EDGE_2 |\n\t\t\t\t\t\tBU21013_Y_EDGE_1 |\n\t\t\t\t\t\tBU21013_Y_EDGE_3);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_XY_EDGE reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = i2c_smbus_write_byte_data(client, BU21013_DONE_REG,\n\t\t\t\t\t  BU21013_DONE);\n\tif (error) {\n\t\tdev_err(&client->dev, \"BU21013_REG_DONE reg write failed\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void bu21013_power_off(void *_ts)\n{\n\tstruct bu21013_ts *ts = _ts;\n\n\tregulator_disable(ts->regulator);\n}\n\nstatic void bu21013_disable_chip(void *_ts)\n{\n\tstruct bu21013_ts *ts = _ts;\n\n\tgpiod_set_value(ts->cs_gpiod, 0);\n}\n\nstatic int bu21013_probe(struct i2c_client *client)\n{\n\tstruct bu21013_ts *ts;\n\tstruct input_dev *in_dev;\n\tstruct input_absinfo *info;\n\tu32 max_x = 0, max_y = 0;\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(dev, \"i2c smbus byte data not supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"No IRQ set up\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\n\tts->x_flip = device_property_read_bool(dev, \"rohm,flip-x\");\n\tts->y_flip = device_property_read_bool(dev, \"rohm,flip-y\");\n\n\tin_dev = devm_input_allocate_device(dev);\n\tif (!in_dev) {\n\t\tdev_err(dev, \"device memory alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tts->in_dev = in_dev;\n\tinput_set_drvdata(in_dev, ts);\n\n\t \n\tin_dev->name = DRIVER_TP;\n\tin_dev->id.bustype = BUS_I2C;\n\n\tdevice_property_read_u32(dev, \"rohm,touch-max-x\", &max_x);\n\tdevice_property_read_u32(dev, \"rohm,touch-max-y\", &max_y);\n\n\tinput_set_abs_params(in_dev, ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\tinput_set_abs_params(in_dev, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\n\ttouchscreen_parse_properties(in_dev, true, &ts->props);\n\n\t \n\tif (!ts->props.invert_x &&\n\t    device_property_read_bool(dev, \"rohm,flip-x\")) {\n\t\tinfo = &in_dev->absinfo[ABS_MT_POSITION_X];\n\t\tinfo->maximum -= info->minimum;\n\t\tinfo->minimum = 0;\n\t}\n\n\tif (!ts->props.invert_y &&\n\t    device_property_read_bool(dev, \"rohm,flip-y\")) {\n\t\tinfo = &in_dev->absinfo[ABS_MT_POSITION_Y];\n\t\tinfo->maximum -= info->minimum;\n\t\tinfo->minimum = 0;\n\t}\n\n\terror = input_mt_init_slots(in_dev, MAX_FINGERS,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_TRACK |\n\t\t\t\t\tINPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"failed to initialize MT slots\");\n\t\treturn error;\n\t}\n\n\tts->regulator = devm_regulator_get(dev, \"avdd\");\n\tif (IS_ERR(ts->regulator)) {\n\t\tdev_err(dev, \"regulator_get failed\\n\");\n\t\treturn PTR_ERR(ts->regulator);\n\t}\n\n\terror = regulator_enable(ts->regulator);\n\tif (error) {\n\t\tdev_err(dev, \"regulator enable failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(dev, bu21013_power_off, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to install power off handler\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tts->cs_gpiod = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ts->cs_gpiod))\n\t\treturn dev_err_probe(dev, PTR_ERR(ts->cs_gpiod), \"failed to get CS GPIO\\n\");\n\n\tgpiod_set_consumer_name(ts->cs_gpiod, \"BU21013 CS\");\n\n\terror = devm_add_action_or_reset(dev, bu21013_disable_chip, ts);\n\tif (error) {\n\t\tdev_err(dev, \"failed to install chip disable handler\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tts->int_gpiod = devm_gpiod_get_optional(dev, \"touch\", GPIOD_IN);\n\terror = PTR_ERR_OR_ZERO(ts->int_gpiod);\n\tif (error)\n\t\treturn dev_err_probe(dev, error, \"failed to get INT GPIO\\n\");\n\n\tif (ts->int_gpiod)\n\t\tgpiod_set_consumer_name(ts->int_gpiod, \"BU21013 INT\");\n\n\t \n\terror = bu21013_init_chip(ts);\n\tif (error) {\n\t\tdev_err(dev, \"error in bu21013 config\\n\");\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, bu21013_gpio_irq,\n\t\t\t\t\t  IRQF_ONESHOT, DRIVER_TP, ts);\n\tif (error) {\n\t\tdev_err(dev, \"request irq %d failed\\n\", client->irq);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(in_dev);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device\\n\");\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(client, ts);\n\n\treturn 0;\n}\n\nstatic void bu21013_remove(struct i2c_client *client)\n{\n\tstruct bu21013_ts *ts = i2c_get_clientdata(client);\n\n\t \n\tts->touch_stopped = true;\n\t \n}\n\nstatic int bu21013_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bu21013_ts *ts = i2c_get_clientdata(client);\n\n\tts->touch_stopped = true;\n\tmb();\n\tdisable_irq(client->irq);\n\n\tif (!device_may_wakeup(&client->dev))\n\t\tregulator_disable(ts->regulator);\n\n\treturn 0;\n}\n\nstatic int bu21013_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bu21013_ts *ts = i2c_get_clientdata(client);\n\tint error;\n\n\tif (!device_may_wakeup(&client->dev)) {\n\t\terror = regulator_enable(ts->regulator);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to re-enable regulator when resuming\\n\");\n\t\t\treturn error;\n\t\t}\n\n\t\terror = bu21013_init_chip(ts);\n\t\tif (error) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to reinitialize chip when resuming\\n\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tts->touch_stopped = false;\n\tmb();\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(bu21013_dev_pm_ops, bu21013_suspend, bu21013_resume);\n\nstatic const struct i2c_device_id bu21013_id[] = {\n\t{ DRIVER_TP, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, bu21013_id);\n\nstatic struct i2c_driver bu21013_driver = {\n\t.driver\t= {\n\t\t.name\t=\tDRIVER_TP,\n\t\t.pm\t=\tpm_sleep_ptr(&bu21013_dev_pm_ops),\n\t},\n\t.probe\t\t=\tbu21013_probe,\n\t.remove\t\t=\tbu21013_remove,\n\t.id_table\t=\tbu21013_id,\n};\n\nmodule_i2c_driver(bu21013_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Naveen Kumar G <naveen.gaddipati@stericsson.com>\");\nMODULE_DESCRIPTION(\"bu21013 touch screen controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}