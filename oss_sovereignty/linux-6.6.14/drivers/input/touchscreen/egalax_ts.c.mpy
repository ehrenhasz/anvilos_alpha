{
  "module_name": "egalax_ts.c",
  "hash_id": "c0f34f81007e1867671888a7bc7620e9c94409f0251a8ac8e44efb3a2e17e537",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/egalax_ts.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/irq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/input/mt.h>\n\n \n#define REPORT_MODE_MOUSE\t\t0x1\n \n#define REPORT_MODE_VENDOR\t\t0x3\n \n#define REPORT_MODE_MTTOUCH\t\t0x4\n\n#define MAX_SUPPORT_POINTS\t\t5\n\n#define EVENT_VALID_OFFSET\t7\n#define EVENT_VALID_MASK\t(0x1 << EVENT_VALID_OFFSET)\n#define EVENT_ID_OFFSET\t\t2\n#define EVENT_ID_MASK\t\t(0xf << EVENT_ID_OFFSET)\n#define EVENT_IN_RANGE\t\t(0x1 << 1)\n#define EVENT_DOWN_UP\t\t(0X1 << 0)\n\n#define MAX_I2C_DATA_LEN\t10\n\n#define EGALAX_MAX_X\t32760\n#define EGALAX_MAX_Y\t32760\n#define EGALAX_MAX_TRIES 100\n\nstruct egalax_ts {\n\tstruct i2c_client\t\t*client;\n\tstruct input_dev\t\t*input_dev;\n};\n\nstatic irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)\n{\n\tstruct egalax_ts *ts = dev_id;\n\tstruct input_dev *input_dev = ts->input_dev;\n\tstruct i2c_client *client = ts->client;\n\tu8 buf[MAX_I2C_DATA_LEN];\n\tint id, ret, x, y, z;\n\tint tries = 0;\n\tbool down, valid;\n\tu8 state;\n\n\tdo {\n\t\tret = i2c_master_recv(client, buf, MAX_I2C_DATA_LEN);\n\t} while (ret == -EAGAIN && tries++ < EGALAX_MAX_TRIES);\n\n\tif (ret < 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (buf[0] != REPORT_MODE_MTTOUCH) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tstate = buf[1];\n\tx = (buf[3] << 8) | buf[2];\n\ty = (buf[5] << 8) | buf[4];\n\tz = (buf[7] << 8) | buf[6];\n\n\tvalid = state & EVENT_VALID_MASK;\n\tid = (state & EVENT_ID_MASK) >> EVENT_ID_OFFSET;\n\tdown = state & EVENT_DOWN_UP;\n\n\tif (!valid || id > MAX_SUPPORT_POINTS) {\n\t\tdev_dbg(&client->dev, \"point invalid\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tinput_mt_slot(input_dev, id);\n\tinput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, down);\n\n\tdev_dbg(&client->dev, \"%s id:%d x:%d y:%d z:%d\",\n\t\tdown ? \"down\" : \"up\", id, x, y, z);\n\n\tif (down) {\n\t\tinput_report_abs(input_dev, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(input_dev, ABS_MT_PRESSURE, z);\n\t}\n\n\tinput_mt_report_pointer_emulation(input_dev, true);\n\tinput_sync(input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int egalax_wake_up_device(struct i2c_client *client)\n{\n\tstruct gpio_desc *gpio;\n\tint ret;\n\n\t \n\tgpio = gpiod_get(&client->dev, \"wakeup\", GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(gpio);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to request wakeup gpio, cannot wake up controller: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(gpio, 0);\n\n\t \n\tgpiod_direction_input(gpio);\n\tgpiod_put(gpio);\n\n\treturn 0;\n}\n\nstatic int egalax_firmware_version(struct i2c_client *client)\n{\n\tstatic const u8 cmd[MAX_I2C_DATA_LEN] = { 0x03, 0x03, 0xa, 0x01, 0x41 };\n\tint ret;\n\n\tret = i2c_master_send(client, cmd, MAX_I2C_DATA_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int egalax_ts_probe(struct i2c_client *client)\n{\n\tstruct egalax_ts *ts;\n\tstruct input_dev *input_dev;\n\tint error;\n\n\tts = devm_kzalloc(&client->dev, sizeof(struct egalax_ts), GFP_KERNEL);\n\tif (!ts) {\n\t\tdev_err(&client->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev) {\n\t\tdev_err(&client->dev, \"Failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tts->client = client;\n\tts->input_dev = input_dev;\n\n\t \n\terror = egalax_wake_up_device(client);\n\tif (error)\n\t\treturn error;\n\n\terror = egalax_firmware_version(client);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Failed to read firmware version\\n\");\n\t\treturn error;\n\t}\n\n\tinput_dev->name = \"EETI eGalax Touch Screen\";\n\tinput_dev->id.bustype = BUS_I2C;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, EGALAX_MAX_X, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, EGALAX_MAX_Y, 0, 0);\n\tinput_set_abs_params(input_dev,\n\t\t\t     ABS_MT_POSITION_X, 0, EGALAX_MAX_X, 0, 0);\n\tinput_set_abs_params(input_dev,\n\t\t\t     ABS_MT_POSITION_Y, 0, EGALAX_MAX_Y, 0, 0);\n\tinput_mt_init_slots(input_dev, MAX_SUPPORT_POINTS, 0);\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, egalax_ts_interrupt,\n\t\t\t\t\t  IRQF_ONESHOT, \"egalax_ts\", ts);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Failed to register interrupt\\n\");\n\t\treturn error;\n\t}\n\n\terror = input_register_device(ts->input_dev);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id egalax_ts_id[] = {\n\t{ \"egalax_ts\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, egalax_ts_id);\n\nstatic int egalax_ts_suspend(struct device *dev)\n{\n\tstatic const u8 suspend_cmd[MAX_I2C_DATA_LEN] = {\n\t\t0x3, 0x6, 0xa, 0x3, 0x36, 0x3f, 0x2, 0, 0, 0\n\t};\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\n\tif (device_may_wakeup(dev))\n\t\treturn enable_irq_wake(client->irq);\n\n\tret = i2c_master_send(client, suspend_cmd, MAX_I2C_DATA_LEN);\n\treturn ret > 0 ? 0 : ret;\n}\n\nstatic int egalax_ts_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (device_may_wakeup(dev))\n\t\treturn disable_irq_wake(client->irq);\n\n\treturn egalax_wake_up_device(client);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(egalax_ts_pm_ops,\n\t\t\t\tegalax_ts_suspend, egalax_ts_resume);\n\nstatic const struct of_device_id egalax_ts_dt_ids[] = {\n\t{ .compatible = \"eeti,egalax_ts\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, egalax_ts_dt_ids);\n\nstatic struct i2c_driver egalax_ts_driver = {\n\t.driver = {\n\t\t.name\t= \"egalax_ts\",\n\t\t.pm\t= pm_sleep_ptr(&egalax_ts_pm_ops),\n\t\t.of_match_table\t= egalax_ts_dt_ids,\n\t},\n\t.id_table\t= egalax_ts_id,\n\t.probe\t\t= egalax_ts_probe,\n};\n\nmodule_i2c_driver(egalax_ts_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Touchscreen driver for EETI eGalax touch controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}