{
  "module_name": "mainstone-wm97xx.c",
  "hash_id": "5296fb22aad73d69e9712ec793b2bf1f9c469a9c709e43a978872fe650ca8a26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/mainstone-wm97xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/soc/pxa/cpu.h>\n#include <linux/wm97xx.h>\n\n#include <sound/pxa2xx-lib.h>\n\n#include <asm/mach-types.h>\n\nstruct continuous {\n\tu16 id;     \n\tu8 code;    \n\tu8 reads;   \n\tu32 speed;  \n};\n\n#define WM_READS(sp) ((sp / HZ) + 1)\n\nstatic const struct continuous cinfo[] = {\n\t{ WM9705_ID2, 0, WM_READS(94),  94  },\n\t{ WM9705_ID2, 1, WM_READS(188), 188 },\n\t{ WM9705_ID2, 2, WM_READS(375), 375 },\n\t{ WM9705_ID2, 3, WM_READS(750), 750 },\n\t{ WM9712_ID2, 0, WM_READS(94),  94  },\n\t{ WM9712_ID2, 1, WM_READS(188), 188 },\n\t{ WM9712_ID2, 2, WM_READS(375), 375 },\n\t{ WM9712_ID2, 3, WM_READS(750), 750 },\n\t{ WM9713_ID2, 0, WM_READS(94),  94  },\n\t{ WM9713_ID2, 1, WM_READS(120), 120 },\n\t{ WM9713_ID2, 2, WM_READS(154), 154 },\n\t{ WM9713_ID2, 3, WM_READS(188), 188 },\n};\n\n \nstatic int sp_idx;\nstatic struct gpio_desc *gpiod_irq;\n\n \nstatic int cont_rate = 200;\nmodule_param(cont_rate, int, 0);\nMODULE_PARM_DESC(cont_rate, \"Sampling rate in continuous mode (Hz)\");\n\n \nstatic int pen_int;\nmodule_param(pen_int, int, 0);\nMODULE_PARM_DESC(pen_int, \"Pen down detection (1 = interrupt, 0 = polling)\");\n\n \nstatic int pressure;\nmodule_param(pressure, int, 0);\nMODULE_PARM_DESC(pressure, \"Pressure readback (1 = pressure, 0 = no pressure)\");\n\n \nstatic int ac97_touch_slot = 5;\nmodule_param(ac97_touch_slot, int, 0);\nMODULE_PARM_DESC(ac97_touch_slot, \"Touch screen data slot AC97 number\");\n\n\n \nstatic void wm97xx_acc_pen_up(struct wm97xx *wm)\n{\n\tunsigned int count;\n\n\tmsleep(1);\n\n\tif (cpu_is_pxa27x()) {\n\t\twhile (pxa2xx_ac97_read_misr() & (1 << 2))\n\t\t\tpxa2xx_ac97_read_modr();\n\t} else if (cpu_is_pxa3xx()) {\n\t\tfor (count = 0; count < 16; count++)\n\t\t\tpxa2xx_ac97_read_modr();\n\t}\n}\n\nstatic int wm97xx_acc_pen_down(struct wm97xx *wm)\n{\n\tu16 x, y, p = 0x100 | WM97XX_ADCSEL_PRES;\n\tint reads = 0;\n\tstatic u16 last, tries;\n\n\t \n\tmsleep(1);\n\n\tif (tries > 5) {\n\t\ttries = 0;\n\t\treturn RC_PENUP;\n\t}\n\n\tx = pxa2xx_ac97_read_modr();\n\tif (x == last) {\n\t\ttries++;\n\t\treturn RC_AGAIN;\n\t}\n\tlast = x;\n\tdo {\n\t\tif (reads)\n\t\t\tx = pxa2xx_ac97_read_modr();\n\t\ty = pxa2xx_ac97_read_modr();\n\t\tif (pressure)\n\t\t\tp = pxa2xx_ac97_read_modr();\n\n\t\tdev_dbg(wm->dev, \"Raw coordinates: x=%x, y=%x, p=%x\\n\",\n\t\t\tx, y, p);\n\n\t\t \n\t\tif ((x & WM97XX_ADCSEL_MASK) != WM97XX_ADCSEL_X ||\n\t\t    (y & WM97XX_ADCSEL_MASK) != WM97XX_ADCSEL_Y ||\n\t\t    (p & WM97XX_ADCSEL_MASK) != WM97XX_ADCSEL_PRES)\n\t\t\tgoto up;\n\n\t\t \n\t\ttries = 0;\n\t\tinput_report_abs(wm->input_dev, ABS_X, x & 0xfff);\n\t\tinput_report_abs(wm->input_dev, ABS_Y, y & 0xfff);\n\t\tinput_report_abs(wm->input_dev, ABS_PRESSURE, p & 0xfff);\n\t\tinput_report_key(wm->input_dev, BTN_TOUCH, (p != 0));\n\t\tinput_sync(wm->input_dev);\n\t\treads++;\n\t} while (reads < cinfo[sp_idx].reads);\nup:\n\treturn RC_PENDOWN | RC_AGAIN;\n}\n\nstatic int wm97xx_acc_startup(struct wm97xx *wm)\n{\n\tint idx = 0, ret = 0;\n\n\t \n\tif (wm->ac97 == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(cinfo); idx++) {\n\t\tif (wm->id != cinfo[idx].id)\n\t\t\tcontinue;\n\t\tsp_idx = idx;\n\t\tif (cont_rate <= cinfo[idx].speed)\n\t\t\tbreak;\n\t}\n\twm->acc_rate = cinfo[sp_idx].code;\n\twm->acc_slot = ac97_touch_slot;\n\tdev_info(wm->dev,\n\t\t \"mainstone accelerated touchscreen driver, %d samples/sec\\n\",\n\t\t cinfo[sp_idx].speed);\n\n\tif (pen_int) {\n\t\tgpiod_irq = gpiod_get(wm->dev, \"touch\", GPIOD_IN);\n\t\tif (IS_ERR(gpiod_irq))\n\t\t\tpen_int = 0;\n\t}\n\n\tif (pen_int) {\n\t\twm->pen_irq = gpiod_to_irq(gpiod_irq);\n\t\tirq_set_irq_type(wm->pen_irq, IRQ_TYPE_EDGE_BOTH);\n\t}\n\n\t \n\tif (pen_int) {\n\t\tswitch (wm->id) {\n\t\tcase WM9705_ID2:\n\t\t\tbreak;\n\t\tcase WM9712_ID2:\n\t\tcase WM9713_ID2:\n\t\t\t \n\t\t\twm97xx_config_gpio(wm, WM97XX_GPIO_13, WM97XX_GPIO_IN,\n\t\t\t\t\t   WM97XX_GPIO_POL_HIGH,\n\t\t\t\t\t   WM97XX_GPIO_STICKY,\n\t\t\t\t\t   WM97XX_GPIO_WAKE);\n\t\t\twm97xx_config_gpio(wm, WM97XX_GPIO_2, WM97XX_GPIO_OUT,\n\t\t\t\t\t   WM97XX_GPIO_POL_HIGH,\n\t\t\t\t\t   WM97XX_GPIO_NOTSTICKY,\n\t\t\t\t\t   WM97XX_GPIO_NOWAKE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(wm->dev,\n\t\t\t\t\"pen down irq not supported on this device\\n\");\n\t\t\tpen_int = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void wm97xx_acc_shutdown(struct wm97xx *wm)\n{\n\t \n\tif (pen_int) {\n\t\tif (gpiod_irq)\n\t\t\tgpiod_put(gpiod_irq);\n\t\twm->pen_irq = 0;\n\t}\n}\n\nstatic struct wm97xx_mach_ops mainstone_mach_ops = {\n\t.acc_enabled\t= 1,\n\t.acc_pen_up\t= wm97xx_acc_pen_up,\n\t.acc_pen_down\t= wm97xx_acc_pen_down,\n\t.acc_startup\t= wm97xx_acc_startup,\n\t.acc_shutdown\t= wm97xx_acc_shutdown,\n\t.irq_gpio\t= WM97XX_GPIO_2,\n};\n\nstatic int mainstone_wm97xx_probe(struct platform_device *pdev)\n{\n\tstruct wm97xx *wm = platform_get_drvdata(pdev);\n\n\treturn wm97xx_register_mach_ops(wm, &mainstone_mach_ops);\n}\n\nstatic int mainstone_wm97xx_remove(struct platform_device *pdev)\n{\n\tstruct wm97xx *wm = platform_get_drvdata(pdev);\n\n\twm97xx_unregister_mach_ops(wm);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mainstone_wm97xx_driver = {\n\t.probe\t= mainstone_wm97xx_probe,\n\t.remove\t= mainstone_wm97xx_remove,\n\t.driver\t= {\n\t\t.name\t= \"wm97xx-touch\",\n\t},\n};\nmodule_platform_driver(mainstone_wm97xx_driver);\n\n \nMODULE_AUTHOR(\"Liam Girdwood <lrg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"wm97xx continuous touch driver for mainstone\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}