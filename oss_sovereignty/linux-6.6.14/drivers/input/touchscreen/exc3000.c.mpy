{
  "module_name": "exc3000.c",
  "hash_id": "a234ecc0cf35b25ccbca1cb421563f9eccf6fdcfa3ee17ff6525cb54b7a9af1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/exc3000.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sizes.h>\n#include <linux/timer.h>\n#include <asm/unaligned.h>\n\n#define EXC3000_NUM_SLOTS\t\t10\n#define EXC3000_SLOTS_PER_FRAME\t\t5\n#define EXC3000_LEN_FRAME\t\t66\n#define EXC3000_LEN_VENDOR_REQUEST\t68\n#define EXC3000_LEN_POINT\t\t10\n\n#define EXC3000_LEN_MODEL_NAME\t\t16\n#define EXC3000_LEN_FW_VERSION\t\t16\n\n#define EXC3000_VENDOR_EVENT\t\t0x03\n#define EXC3000_MT1_EVENT\t\t0x06\n#define EXC3000_MT2_EVENT\t\t0x18\n\n#define EXC3000_TIMEOUT_MS\t\t100\n\n#define EXC3000_RESET_MS\t\t10\n#define EXC3000_READY_MS\t\t100\n\nstatic const struct i2c_device_id exc3000_id[];\n\nstruct eeti_dev_info {\n\tconst char *name;\n\tint max_xy;\n};\n\nenum eeti_dev_id {\n\tEETI_EXC3000,\n\tEETI_EXC80H60,\n\tEETI_EXC80H84,\n};\n\nstatic struct eeti_dev_info exc3000_info[] = {\n\t[EETI_EXC3000] = {\n\t\t.name = \"EETI EXC3000 Touch Screen\",\n\t\t.max_xy = SZ_4K - 1,\n\t},\n\t[EETI_EXC80H60] = {\n\t\t.name = \"EETI EXC80H60 Touch Screen\",\n\t\t.max_xy = SZ_16K - 1,\n\t},\n\t[EETI_EXC80H84] = {\n\t\t.name = \"EETI EXC80H84 Touch Screen\",\n\t\t.max_xy = SZ_16K - 1,\n\t},\n};\n\nstruct exc3000_data {\n\tstruct i2c_client *client;\n\tconst struct eeti_dev_info *info;\n\tstruct input_dev *input;\n\tstruct touchscreen_properties prop;\n\tstruct gpio_desc *reset;\n\tstruct timer_list timer;\n\tu8 buf[2 * EXC3000_LEN_FRAME];\n\tstruct completion wait_event;\n\tstruct mutex query_lock;\n};\n\nstatic void exc3000_report_slots(struct input_dev *input,\n\t\t\t\t struct touchscreen_properties *prop,\n\t\t\t\t const u8 *buf, int num)\n{\n\tfor (; num--; buf += EXC3000_LEN_POINT) {\n\t\tif (buf[0] & BIT(0)) {\n\t\t\tinput_mt_slot(input, buf[1]);\n\t\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\t\t\ttouchscreen_report_pos(input, prop,\n\t\t\t\t\t       get_unaligned_le16(buf + 2),\n\t\t\t\t\t       get_unaligned_le16(buf + 4),\n\t\t\t\t\t       true);\n\t\t}\n\t}\n}\n\nstatic void exc3000_timer(struct timer_list *t)\n{\n\tstruct exc3000_data *data = from_timer(data, t, timer);\n\n\tinput_mt_sync_frame(data->input);\n\tinput_sync(data->input);\n}\n\nstatic inline void exc3000_schedule_timer(struct exc3000_data *data)\n{\n\tmod_timer(&data->timer, jiffies + msecs_to_jiffies(EXC3000_TIMEOUT_MS));\n}\n\nstatic void exc3000_shutdown_timer(void *timer)\n{\n\ttimer_shutdown_sync(timer);\n}\n\nstatic int exc3000_read_frame(struct exc3000_data *data, u8 *buf)\n{\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\n\tret = i2c_master_send(client, \"'\", 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\tret = i2c_master_recv(client, buf, EXC3000_LEN_FRAME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != EXC3000_LEN_FRAME)\n\t\treturn -EIO;\n\n\tif (get_unaligned_le16(buf) != EXC3000_LEN_FRAME)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int exc3000_handle_mt_event(struct exc3000_data *data)\n{\n\tstruct input_dev *input = data->input;\n\tint ret, total_slots;\n\tu8 *buf = data->buf;\n\n\ttotal_slots = buf[3];\n\tif (!total_slots || total_slots > EXC3000_NUM_SLOTS) {\n\t\tret = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\n\tif (total_slots > EXC3000_SLOTS_PER_FRAME) {\n\t\t \n\t\tret = exc3000_read_frame(data, buf + EXC3000_LEN_FRAME);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\n\t\t \n\t\tif (buf[EXC3000_LEN_FRAME + 3] != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t \n\tdel_timer_sync(&data->timer);\n\n\twhile (total_slots > 0) {\n\t\tint slots = min(total_slots, EXC3000_SLOTS_PER_FRAME);\n\n\t\texc3000_report_slots(input, &data->prop, buf + 4, slots);\n\t\ttotal_slots -= slots;\n\t\tbuf += EXC3000_LEN_FRAME;\n\t}\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n\n\treturn 0;\n\nout_fail:\n\t \n\texc3000_schedule_timer(data);\n\n\treturn ret;\n}\n\nstatic irqreturn_t exc3000_interrupt(int irq, void *dev_id)\n{\n\tstruct exc3000_data *data = dev_id;\n\tu8 *buf = data->buf;\n\tint ret;\n\n\tret = exc3000_read_frame(data, buf);\n\tif (ret) {\n\t\t \n\t\texc3000_schedule_timer(data);\n\t\tgoto out;\n\t}\n\n\tswitch (buf[2]) {\n\tcase EXC3000_VENDOR_EVENT:\n\t\tcomplete(&data->wait_event);\n\t\tbreak;\n\n\tcase EXC3000_MT1_EVENT:\n\tcase EXC3000_MT2_EVENT:\n\t\texc3000_handle_mt_event(data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int exc3000_vendor_data_request(struct exc3000_data *data, u8 *request,\n\t\t\t\t       u8 request_len, u8 *response, int timeout)\n{\n\tu8 buf[EXC3000_LEN_VENDOR_REQUEST] = { 0x67, 0x00, 0x42, 0x00, 0x03 };\n\tint ret;\n\tunsigned long time_left;\n\n\tmutex_lock(&data->query_lock);\n\n\treinit_completion(&data->wait_event);\n\n\tbuf[5] = request_len;\n\tmemcpy(&buf[6], request, request_len);\n\n\tret = i2c_master_send(data->client, buf, EXC3000_LEN_VENDOR_REQUEST);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tif (response) {\n\t\ttime_left = wait_for_completion_timeout(&data->wait_event,\n\t\t\t\t\t\t\ttimeout * HZ);\n\t\tif (time_left == 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (data->buf[3] >= EXC3000_LEN_FRAME) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmemcpy(response, &data->buf[4], data->buf[3]);\n\t\tret = data->buf[3];\n\t}\n\nout_unlock:\n\tmutex_unlock(&data->query_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t fw_version_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct exc3000_data *data = i2c_get_clientdata(client);\n\tu8 response[EXC3000_LEN_FRAME];\n\tint ret;\n\n\t \n\tret = exc3000_vendor_data_request(data,\n\t\t\t\t\t  (u8[]){0x39, 0x02}, 2, response, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (response[2] || response[3])\n\t\treturn sprintf(buf, \"%d.%d\\n\", response[2], response[3]);\n\n\tret = exc3000_vendor_data_request(data, (u8[]){'D'}, 1, response, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%s\\n\", &response[1]);\n}\nstatic DEVICE_ATTR_RO(fw_version);\n\nstatic ssize_t model_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct exc3000_data *data = i2c_get_clientdata(client);\n\tu8 response[EXC3000_LEN_FRAME];\n\tint ret;\n\n\tret = exc3000_vendor_data_request(data, (u8[]){'E'}, 1, response, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%s\\n\", &response[1]);\n}\nstatic DEVICE_ATTR_RO(model);\n\nstatic ssize_t type_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct exc3000_data *data = i2c_get_clientdata(client);\n\tu8 response[EXC3000_LEN_FRAME];\n\tint ret;\n\n\tret = exc3000_vendor_data_request(data, (u8[]){'F'}, 1, response, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%s\\n\", &response[1]);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic struct attribute *sysfs_attrs[] = {\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_type.attr,\n\tNULL\n};\n\nstatic struct attribute_group exc3000_attribute_group = {\n\t.attrs = sysfs_attrs\n};\n\nstatic int exc3000_probe(struct i2c_client *client)\n{\n\tstruct exc3000_data *data;\n\tstruct input_dev *input;\n\tint error, max_xy, retry;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tdata->info = device_get_match_data(&client->dev);\n\tif (!data->info) {\n\t\tenum eeti_dev_id eeti_dev_id =\n\t\t\ti2c_match_id(exc3000_id, client)->driver_data;\n\t\tdata->info = &exc3000_info[eeti_dev_id];\n\t}\n\ttimer_setup(&data->timer, exc3000_timer, 0);\n\tinit_completion(&data->wait_event);\n\tmutex_init(&data->query_lock);\n\n\tdata->reset = devm_gpiod_get_optional(&client->dev, \"reset\",\n\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->reset))\n\t\treturn PTR_ERR(data->reset);\n\n\t \n\terror = devm_regulator_get_enable(&client->dev, \"vdd\");\n\tif (error && error != -ENODEV)\n\t\treturn dev_err_probe(&client->dev, error,\n\t\t\t\t     \"failed to request vdd regulator\\n\");\n\n\tif (data->reset) {\n\t\tmsleep(EXC3000_RESET_MS);\n\t\tgpiod_set_value_cansleep(data->reset, 0);\n\t\tmsleep(EXC3000_READY_MS);\n\t}\n\n\tinput = devm_input_allocate_device(&client->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tdata->input = input;\n\tinput_set_drvdata(input, data);\n\n\tinput->name = data->info->name;\n\tinput->id.bustype = BUS_I2C;\n\n\tmax_xy = data->info->max_xy;\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, max_xy, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_xy, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, &data->prop);\n\n\terror = input_mt_init_slots(input, EXC3000_NUM_SLOTS,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error)\n\t\treturn error;\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(&client->dev, exc3000_shutdown_timer,\n\t\t\t\t\t &data->timer);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\t  NULL, exc3000_interrupt, IRQF_ONESHOT,\n\t\t\t\t\t  client->name, data);\n\tif (error)\n\t\treturn error;\n\n\t \n\tfor (retry = 0; retry < 3; retry++) {\n\t\tu8 response[EXC3000_LEN_FRAME];\n\n\t\terror = exc3000_vendor_data_request(data, (u8[]){'E'}, 1,\n\t\t\t\t\t\t    response, 1);\n\t\tif (error > 0) {\n\t\t\tdev_dbg(&client->dev, \"TS Model: %s\", &response[1]);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tdev_warn(&client->dev, \"Retry %d get EETI EXC3000 model: %d\\n\",\n\t\t\t retry + 1, error);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, data);\n\n\terror = devm_device_add_group(&client->dev, &exc3000_attribute_group);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id exc3000_id[] = {\n\t{ \"exc3000\", EETI_EXC3000 },\n\t{ \"exc80h60\", EETI_EXC80H60 },\n\t{ \"exc80h84\", EETI_EXC80H84 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, exc3000_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id exc3000_of_match[] = {\n\t{ .compatible = \"eeti,exc3000\", .data = &exc3000_info[EETI_EXC3000] },\n\t{ .compatible = \"eeti,exc80h60\", .data = &exc3000_info[EETI_EXC80H60] },\n\t{ .compatible = \"eeti,exc80h84\", .data = &exc3000_info[EETI_EXC80H84] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, exc3000_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id exc3000_acpi_match[] = {\n\t{ \"EGA00001\", .driver_data = (kernel_ulong_t)&exc3000_info[EETI_EXC80H60] },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, exc3000_acpi_match);\n#endif\n\nstatic struct i2c_driver exc3000_driver = {\n\t.driver = {\n\t\t.name\t= \"exc3000\",\n\t\t.of_match_table = of_match_ptr(exc3000_of_match),\n\t\t.acpi_match_table = ACPI_PTR(exc3000_acpi_match),\n\t},\n\t.id_table\t= exc3000_id,\n\t.probe\t\t= exc3000_probe,\n};\n\nmodule_i2c_driver(exc3000_driver);\n\nMODULE_AUTHOR(\"Ahmet Inan <inan@distec.de>\");\nMODULE_DESCRIPTION(\"I2C connected EETI EXC3000 multiple touch controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}