{
  "module_name": "cyttsp4_spi.c",
  "hash_id": "e6f918589aac62e538ed795136226caea1a30c04d19246a55199f80d9ea6f7a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/cyttsp4_spi.c",
  "human_readable_source": "\n \n\n#include \"cyttsp4_core.h\"\n\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/spi/spi.h>\n\n#define CY_SPI_WR_OP\t\t0x00  \n#define CY_SPI_RD_OP\t\t0x01\n#define CY_SPI_BITS_PER_WORD\t8\n#define CY_SPI_A8_BIT\t\t0x02\n#define CY_SPI_WR_HEADER_BYTES\t2\n#define CY_SPI_RD_HEADER_BYTES\t1\n#define CY_SPI_CMD_BYTES\t2\n#define CY_SPI_SYNC_BYTE\t0\n#define CY_SPI_SYNC_ACK\t\t0x62  \n#define CY_SPI_DATA_SIZE\t(2 * 256)\n\n#define CY_SPI_DATA_BUF_SIZE\t(CY_SPI_CMD_BYTES + CY_SPI_DATA_SIZE)\n\nstatic int cyttsp_spi_xfer(struct device *dev, u8 *xfer_buf,\n\t\t\t   u8 op, u16 reg, u8 *buf, int length)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer[2];\n\tu8 *wr_buf = &xfer_buf[0];\n\tu8 rd_buf[CY_SPI_CMD_BYTES];\n\tint retval;\n\tint i;\n\n\tif (length > CY_SPI_DATA_SIZE) {\n\t\tdev_err(dev, \"%s: length %d is too big.\\n\",\n\t\t\t__func__, length);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(wr_buf, 0, CY_SPI_DATA_BUF_SIZE);\n\tmemset(rd_buf, 0, CY_SPI_CMD_BYTES);\n\n\twr_buf[0] = op + (((reg >> 8) & 0x1) ? CY_SPI_A8_BIT : 0);\n\tif (op == CY_SPI_WR_OP) {\n\t\twr_buf[1] = reg & 0xFF;\n\t\tif (length > 0)\n\t\t\tmemcpy(wr_buf + CY_SPI_CMD_BYTES, buf, length);\n\t}\n\n\tmemset(xfer, 0, sizeof(xfer));\n\tspi_message_init(&msg);\n\n\t \n\txfer[0].tx_buf = wr_buf;\n\txfer[0].rx_buf = rd_buf;\n\tswitch (op) {\n\tcase CY_SPI_WR_OP:\n\t\txfer[0].len = length + CY_SPI_CMD_BYTES;\n\t\tspi_message_add_tail(&xfer[0], &msg);\n\t\tbreak;\n\n\tcase CY_SPI_RD_OP:\n\t\txfer[0].len = CY_SPI_RD_HEADER_BYTES;\n\t\tspi_message_add_tail(&xfer[0], &msg);\n\n\t\txfer[1].rx_buf = buf;\n\t\txfer[1].len = length;\n\t\tspi_message_add_tail(&xfer[1], &msg);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"%s: bad operation code=%d\\n\", __func__, op);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = spi_sync(spi, &msg);\n\tif (retval < 0) {\n\t\tdev_dbg(dev, \"%s: spi_sync() error %d, len=%d, op=%d\\n\",\n\t\t\t__func__, retval, xfer[1].len, op);\n\n\t\t \n\t}\n\n\tif (rd_buf[CY_SPI_SYNC_BYTE] != CY_SPI_SYNC_ACK) {\n\t\tdev_dbg(dev, \"%s: operation %d failed\\n\", __func__, op);\n\n\t\tfor (i = 0; i < CY_SPI_CMD_BYTES; i++)\n\t\t\tdev_dbg(dev, \"%s: test rd_buf[%d]:0x%02x\\n\",\n\t\t\t\t__func__, i, rd_buf[i]);\n\t\tfor (i = 0; i < length; i++)\n\t\t\tdev_dbg(dev, \"%s: test buf[%d]:0x%02x\\n\",\n\t\t\t\t__func__, i, buf[i]);\n\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cyttsp_spi_read_block_data(struct device *dev, u8 *xfer_buf,\n\t\t\t\t      u16 addr, u8 length, void *data)\n{\n\tint rc;\n\n\trc = cyttsp_spi_xfer(dev, xfer_buf, CY_SPI_WR_OP, addr, NULL, 0);\n\tif (rc)\n\t\treturn rc;\n\telse\n\t\treturn cyttsp_spi_xfer(dev, xfer_buf, CY_SPI_RD_OP, addr, data,\n\t\t\t\tlength);\n}\n\nstatic int cyttsp_spi_write_block_data(struct device *dev, u8 *xfer_buf,\n\t\t\t\t       u16 addr, u8 length, const void *data)\n{\n\treturn cyttsp_spi_xfer(dev, xfer_buf, CY_SPI_WR_OP, addr, (void *)data,\n\t\t\tlength);\n}\n\nstatic const struct cyttsp4_bus_ops cyttsp_spi_bus_ops = {\n\t.bustype\t= BUS_SPI,\n\t.write\t\t= cyttsp_spi_write_block_data,\n\t.read\t\t= cyttsp_spi_read_block_data,\n};\n\nstatic int cyttsp4_spi_probe(struct spi_device *spi)\n{\n\tstruct cyttsp4 *ts;\n\tint error;\n\n\t \n\tspi->bits_per_word = CY_SPI_BITS_PER_WORD;\n\tspi->mode = SPI_MODE_0;\n\terror = spi_setup(spi);\n\tif (error < 0) {\n\t\tdev_err(&spi->dev, \"%s: SPI setup error %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\tts = cyttsp4_probe(&cyttsp_spi_bus_ops, &spi->dev, spi->irq,\n\t\t\t  CY_SPI_DATA_BUF_SIZE);\n\n\treturn PTR_ERR_OR_ZERO(ts);\n}\n\nstatic void cyttsp4_spi_remove(struct spi_device *spi)\n{\n\tstruct cyttsp4 *ts = spi_get_drvdata(spi);\n\tcyttsp4_remove(ts);\n}\n\nstatic struct spi_driver cyttsp4_spi_driver = {\n\t.driver = {\n\t\t.name\t= CYTTSP4_SPI_NAME,\n\t\t.pm\t= pm_ptr(&cyttsp4_pm_ops),\n\t},\n\t.probe  = cyttsp4_spi_probe,\n\t.remove = cyttsp4_spi_remove,\n};\n\nmodule_spi_driver(cyttsp4_spi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Cypress TrueTouch(R) Standard Product (TTSP) SPI driver\");\nMODULE_AUTHOR(\"Cypress\");\nMODULE_ALIAS(\"spi:cyttsp4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}