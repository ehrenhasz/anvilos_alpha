{
  "module_name": "tsc2007_core.c",
  "hash_id": "1060d96579ba43b09da79f5af1119e3ba2597d4e5e4b59c41f6f769c19d70339",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/tsc2007_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/platform_data/tsc2007.h>\n#include \"tsc2007.h\"\n\nint tsc2007_xfer(struct tsc2007 *tsc, u8 cmd)\n{\n\ts32 data;\n\tu16 val;\n\n\tdata = i2c_smbus_read_word_data(tsc->client, cmd);\n\tif (data < 0) {\n\t\tdev_err(&tsc->client->dev, \"i2c io error: %d\\n\", data);\n\t\treturn data;\n\t}\n\n\t \n\tval = swab16(data) >> 4;\n\n\tdev_dbg(&tsc->client->dev, \"data: 0x%x, val: 0x%x\\n\", data, val);\n\n\treturn val;\n}\n\nstatic void tsc2007_read_values(struct tsc2007 *tsc, struct ts_event *tc)\n{\n\t \n\ttc->y = tsc2007_xfer(tsc, READ_Y);\n\n\t \n\ttc->x = tsc2007_xfer(tsc, READ_X);\n\n\t \n\ttc->z1 = tsc2007_xfer(tsc, READ_Z1);\n\ttc->z2 = tsc2007_xfer(tsc, READ_Z2);\n\n\t \n\ttsc2007_xfer(tsc, PWRDOWN);\n}\n\nu32 tsc2007_calculate_resistance(struct tsc2007 *tsc, struct ts_event *tc)\n{\n\tu32 rt = 0;\n\n\t \n\tif (tc->x == MAX_12BIT)\n\t\ttc->x = 0;\n\n\tif (likely(tc->x && tc->z1)) {\n\t\t \n\t\trt = tc->z2 - tc->z1;\n\t\trt *= tc->x;\n\t\trt *= tsc->x_plate_ohms;\n\t\trt /= tc->z1;\n\t\trt = (rt + 2047) >> 12;\n\t}\n\n\treturn rt;\n}\n\nbool tsc2007_is_pen_down(struct tsc2007 *ts)\n{\n\t \n\n\tif (!ts->get_pendown_state)\n\t\treturn true;\n\n\treturn ts->get_pendown_state(&ts->client->dev);\n}\n\nstatic irqreturn_t tsc2007_soft_irq(int irq, void *handle)\n{\n\tstruct tsc2007 *ts = handle;\n\tstruct input_dev *input = ts->input;\n\tstruct ts_event tc;\n\tu32 rt;\n\n\twhile (!ts->stopped && tsc2007_is_pen_down(ts)) {\n\n\t\t \n\n\t\tmutex_lock(&ts->mlock);\n\t\ttsc2007_read_values(ts, &tc);\n\t\tmutex_unlock(&ts->mlock);\n\n\t\trt = tsc2007_calculate_resistance(ts, &tc);\n\n\t\tif (!rt && !ts->get_pendown_state) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (rt <= ts->max_rt) {\n\t\t\tdev_dbg(&ts->client->dev,\n\t\t\t\t\"DOWN point(%4d,%4d), resistance (%4u)\\n\",\n\t\t\t\ttc.x, tc.y, rt);\n\n\t\t\trt = ts->max_rt - rt;\n\n\t\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\t\tinput_report_abs(input, ABS_X, tc.x);\n\t\t\tinput_report_abs(input, ABS_Y, tc.y);\n\t\t\tinput_report_abs(input, ABS_PRESSURE, rt);\n\n\t\t\tinput_sync(input);\n\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(&ts->client->dev, \"ignored pressure %d\\n\", rt);\n\t\t}\n\n\t\twait_event_timeout(ts->wait, ts->stopped, ts->poll_period);\n\t}\n\n\tdev_dbg(&ts->client->dev, \"UP\\n\");\n\n\tinput_report_key(input, BTN_TOUCH, 0);\n\tinput_report_abs(input, ABS_PRESSURE, 0);\n\tinput_sync(input);\n\n\tif (ts->clear_penirq)\n\t\tts->clear_penirq();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tsc2007_stop(struct tsc2007 *ts)\n{\n\tts->stopped = true;\n\tmb();\n\twake_up(&ts->wait);\n\n\tdisable_irq(ts->irq);\n}\n\nstatic int tsc2007_open(struct input_dev *input_dev)\n{\n\tstruct tsc2007 *ts = input_get_drvdata(input_dev);\n\tint err;\n\n\tts->stopped = false;\n\tmb();\n\n\tenable_irq(ts->irq);\n\n\t \n\terr = tsc2007_xfer(ts, PWRDOWN);\n\tif (err < 0) {\n\t\ttsc2007_stop(ts);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tsc2007_close(struct input_dev *input_dev)\n{\n\tstruct tsc2007 *ts = input_get_drvdata(input_dev);\n\n\ttsc2007_stop(ts);\n}\n\nstatic int tsc2007_get_pendown_state_gpio(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tsc2007 *ts = i2c_get_clientdata(client);\n\n\treturn gpiod_get_value_cansleep(ts->gpiod);\n}\n\nstatic int tsc2007_probe_properties(struct device *dev, struct tsc2007 *ts)\n{\n\tu32 val32;\n\tu64 val64;\n\n\tif (!device_property_read_u32(dev, \"ti,max-rt\", &val32))\n\t\tts->max_rt = val32;\n\telse\n\t\tts->max_rt = MAX_12BIT;\n\n\tif (!device_property_read_u32(dev, \"ti,fuzzx\", &val32))\n\t\tts->fuzzx = val32;\n\n\tif (!device_property_read_u32(dev, \"ti,fuzzy\", &val32))\n\t\tts->fuzzy = val32;\n\n\tif (!device_property_read_u32(dev, \"ti,fuzzz\", &val32))\n\t\tts->fuzzz = val32;\n\n\tif (!device_property_read_u64(dev, \"ti,poll-period\", &val64))\n\t\tts->poll_period = msecs_to_jiffies(val64);\n\telse\n\t\tts->poll_period = msecs_to_jiffies(1);\n\n\tif (!device_property_read_u32(dev, \"ti,x-plate-ohms\", &val32)) {\n\t\tts->x_plate_ohms = val32;\n\t} else {\n\t\tdev_err(dev, \"Missing ti,x-plate-ohms device property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tts->gpiod = devm_gpiod_get_optional(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(ts->gpiod))\n\t\treturn PTR_ERR(ts->gpiod);\n\n\tif (ts->gpiod)\n\t\tts->get_pendown_state = tsc2007_get_pendown_state_gpio;\n\telse\n\t\tdev_warn(dev, \"Pen down GPIO is not specified in properties\\n\");\n\n\treturn 0;\n}\n\nstatic int tsc2007_probe_pdev(struct device *dev, struct tsc2007 *ts,\n\t\t\t      const struct tsc2007_platform_data *pdata,\n\t\t\t      const struct i2c_device_id *id)\n{\n\tts->model             = pdata->model;\n\tts->x_plate_ohms      = pdata->x_plate_ohms;\n\tts->max_rt            = pdata->max_rt ? : MAX_12BIT;\n\tts->poll_period       = msecs_to_jiffies(pdata->poll_period ? : 1);\n\tts->get_pendown_state = pdata->get_pendown_state;\n\tts->clear_penirq      = pdata->clear_penirq;\n\tts->fuzzx             = pdata->fuzzx;\n\tts->fuzzy             = pdata->fuzzy;\n\tts->fuzzz             = pdata->fuzzz;\n\n\tif (pdata->x_plate_ohms == 0) {\n\t\tdev_err(dev, \"x_plate_ohms is not set up in platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void tsc2007_call_exit_platform_hw(void *data)\n{\n\tstruct device *dev = data;\n\tconst struct tsc2007_platform_data *pdata = dev_get_platdata(dev);\n\n\tpdata->exit_platform_hw();\n}\n\nstatic int tsc2007_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct tsc2007_platform_data *pdata =\n\t\tdev_get_platdata(&client->dev);\n\tstruct tsc2007 *ts;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_READ_WORD_DATA))\n\t\treturn -EIO;\n\n\tts = devm_kzalloc(&client->dev, sizeof(struct tsc2007), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tif (pdata)\n\t\terr = tsc2007_probe_pdev(&client->dev, ts, pdata, id);\n\telse\n\t\terr = tsc2007_probe_properties(&client->dev, ts);\n\tif (err)\n\t\treturn err;\n\n\tinput_dev = devm_input_allocate_device(&client->dev);\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ts);\n\n\tts->client = client;\n\tts->irq = client->irq;\n\tts->input = input_dev;\n\n\tinit_waitqueue_head(&ts->wait);\n\tmutex_init(&ts->mlock);\n\n\tsnprintf(ts->phys, sizeof(ts->phys),\n\t\t \"%s/input0\", dev_name(&client->dev));\n\n\tinput_dev->name = \"TSC2007 Touchscreen\";\n\tinput_dev->phys = ts->phys;\n\tinput_dev->id.bustype = BUS_I2C;\n\n\tinput_dev->open = tsc2007_open;\n\tinput_dev->close = tsc2007_close;\n\n\tinput_set_drvdata(input_dev, ts);\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, ts->fuzzx, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, ts->fuzzy, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT,\n\t\t\t     ts->fuzzz, 0);\n\n\tif (pdata) {\n\t\tif (pdata->exit_platform_hw) {\n\t\t\terr = devm_add_action(&client->dev,\n\t\t\t\t\t      tsc2007_call_exit_platform_hw,\n\t\t\t\t\t      &client->dev);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Failed to register exit_platform_hw action, %d\\n\",\n\t\t\t\t\terr);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (pdata->init_platform_hw)\n\t\t\tpdata->init_platform_hw();\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, ts->irq,\n\t\t\t\t\tNULL, tsc2007_soft_irq,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\tclient->dev.driver->name, ts);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to request irq %d: %d\\n\",\n\t\t\tts->irq, err);\n\t\treturn err;\n\t}\n\n\ttsc2007_stop(ts);\n\n\t \n\terr = tsc2007_xfer(ts, PWRDOWN);\n\tif (err < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to setup chip: %d\\n\", err);\n\t\treturn err;\t \n\t}\n\n\terr = input_register_device(input_dev);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register input device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr =  tsc2007_iio_configure(ts);\n\tif (err) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to register with IIO: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tsc2007_idtable[] = {\n\t{ \"tsc2007\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, tsc2007_idtable);\n\nstatic const struct of_device_id tsc2007_of_match[] = {\n\t{ .compatible = \"ti,tsc2007\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tsc2007_of_match);\n\nstatic struct i2c_driver tsc2007_driver = {\n\t.driver = {\n\t\t.name\t= \"tsc2007\",\n\t\t.of_match_table = tsc2007_of_match,\n\t},\n\t.id_table\t= tsc2007_idtable,\n\t.probe\t\t= tsc2007_probe,\n};\n\nmodule_i2c_driver(tsc2007_driver);\n\nMODULE_AUTHOR(\"Kwangwoo Lee <kwlee@mtekvision.com>\");\nMODULE_DESCRIPTION(\"TSC2007 TouchScreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}