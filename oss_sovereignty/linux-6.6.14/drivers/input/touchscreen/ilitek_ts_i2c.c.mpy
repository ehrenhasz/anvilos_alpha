{
  "module_name": "ilitek_ts_i2c.c",
  "hash_id": "860de022df0b2fc1afb45771f24fac775654a88486de14b0396ecba6b13cfa68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/ilitek_ts_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/errno.h>\n#include <linux/acpi.h>\n#include <linux/input/touchscreen.h>\n#include <asm/unaligned.h>\n\n\n#define ILITEK_TS_NAME\t\t\t\t\t\"ilitek_ts\"\n#define BL_V1_8\t\t\t\t\t\t0x108\n#define BL_V1_7\t\t\t\t\t\t0x107\n#define BL_V1_6\t\t\t\t\t\t0x106\n\n#define ILITEK_TP_CMD_GET_TP_RES\t\t\t0x20\n#define ILITEK_TP_CMD_GET_SCRN_RES\t\t\t0x21\n#define ILITEK_TP_CMD_SET_IC_SLEEP\t\t\t0x30\n#define ILITEK_TP_CMD_SET_IC_WAKE\t\t\t0x31\n#define ILITEK_TP_CMD_GET_FW_VER\t\t\t0x40\n#define ILITEK_TP_CMD_GET_PRL_VER\t\t\t0x42\n#define ILITEK_TP_CMD_GET_MCU_VER\t\t\t0x61\n#define ILITEK_TP_CMD_GET_IC_MODE\t\t\t0xC0\n\n#define REPORT_COUNT_ADDRESS\t\t\t\t61\n#define ILITEK_SUPPORT_MAX_POINT\t\t\t40\n\nstruct ilitek_protocol_info {\n\tu16 ver;\n\tu8 ver_major;\n};\n\nstruct ilitek_ts_data {\n\tstruct i2c_client\t\t*client;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tstruct input_dev\t\t*input_dev;\n\tstruct touchscreen_properties\tprop;\n\n\tconst struct ilitek_protocol_map *ptl_cb_func;\n\tstruct ilitek_protocol_info\tptl;\n\n\tchar\t\t\t\tproduct_id[30];\n\tu16\t\t\t\tmcu_ver;\n\tu8\t\t\t\tic_mode;\n\tu8\t\t\t\tfirmware_ver[8];\n\n\ts32\t\t\t\treset_time;\n\ts32\t\t\t\tscreen_max_x;\n\ts32\t\t\t\tscreen_max_y;\n\ts32\t\t\t\tscreen_min_x;\n\ts32\t\t\t\tscreen_min_y;\n\ts32\t\t\t\tmax_tp;\n};\n\nstruct ilitek_protocol_map {\n\tu16 cmd;\n\tconst char *name;\n\tint (*func)(struct ilitek_ts_data *ts, u16 cmd, u8 *inbuf, u8 *outbuf);\n};\n\nenum ilitek_cmds {\n\t \n\tGET_PTL_VER = 0,\n\tGET_FW_VER,\n\tGET_SCRN_RES,\n\tGET_TP_RES,\n\tGET_IC_MODE,\n\tGET_MCU_VER,\n\tSET_IC_SLEEP,\n\tSET_IC_WAKE,\n\n\t \n\tMAX_CMD_CNT\n};\n\n \nstatic int ilitek_i2c_write_and_read(struct ilitek_ts_data *ts,\n\t\t\t\t     u8 *cmd, int write_len, int delay,\n\t\t\t\t     u8 *data, int read_len)\n{\n\tint error;\n\tstruct i2c_client *client = ts->client;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = write_len,\n\t\t\t.buf = cmd,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = read_len,\n\t\t\t.buf = data,\n\t\t},\n\t};\n\n\tif (delay == 0 && write_len > 0 && read_len > 0) {\n\t\terror = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tif (write_len > 0) {\n\t\t\terror = i2c_transfer(client->adapter, msgs, 1);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (delay > 0)\n\t\t\tmdelay(delay);\n\n\t\tif (read_len > 0) {\n\t\t\terror = i2c_transfer(client->adapter, msgs + 1, 1);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ilitek_touch_down(struct ilitek_ts_data *ts, unsigned int id,\n\t\t\t      unsigned int x, unsigned int y)\n{\n\tstruct input_dev *input = ts->input_dev;\n\n\tinput_mt_slot(input, id);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\n\n\ttouchscreen_report_pos(input, &ts->prop, x, y, true);\n}\n\nstatic int ilitek_process_and_report_v6(struct ilitek_ts_data *ts)\n{\n\tint error = 0;\n\tu8 buf[512];\n\tint packet_len = 5;\n\tint packet_max_point = 10;\n\tint report_max_point;\n\tint i, count;\n\tstruct input_dev *input = ts->input_dev;\n\tstruct device *dev = &ts->client->dev;\n\tunsigned int x, y, status, id;\n\n\terror = ilitek_i2c_write_and_read(ts, NULL, 0, 0, buf, 64);\n\tif (error) {\n\t\tdev_err(dev, \"get touch info failed, err:%d\\n\", error);\n\t\tgoto err_sync_frame;\n\t}\n\n\treport_max_point = buf[REPORT_COUNT_ADDRESS];\n\tif (report_max_point > ts->max_tp) {\n\t\tdev_err(dev, \"FW report max point:%d > panel info. max:%d\\n\",\n\t\t\treport_max_point, ts->max_tp);\n\t\terror = -EINVAL;\n\t\tgoto err_sync_frame;\n\t}\n\n\tcount = DIV_ROUND_UP(report_max_point, packet_max_point);\n\tfor (i = 1; i < count; i++) {\n\t\terror = ilitek_i2c_write_and_read(ts, NULL, 0, 0,\n\t\t\t\t\t\t  buf + i * 64, 64);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"get touch info. failed, cnt:%d, err:%d\\n\",\n\t\t\t\tcount, error);\n\t\t\tgoto err_sync_frame;\n\t\t}\n\t}\n\n\tfor (i = 0; i < report_max_point; i++) {\n\t\tstatus = buf[i * packet_len + 1] & 0x40;\n\t\tif (!status)\n\t\t\tcontinue;\n\n\t\tid = buf[i * packet_len + 1] & 0x3F;\n\n\t\tx = get_unaligned_le16(buf + i * packet_len + 2);\n\t\ty = get_unaligned_le16(buf + i * packet_len + 4);\n\n\t\tif (x > ts->screen_max_x || x < ts->screen_min_x ||\n\t\t    y > ts->screen_max_y || y < ts->screen_min_y) {\n\t\t\tdev_warn(dev, \"invalid position, X[%d,%u,%d], Y[%d,%u,%d]\\n\",\n\t\t\t\t ts->screen_min_x, x, ts->screen_max_x,\n\t\t\t\t ts->screen_min_y, y, ts->screen_max_y);\n\t\t\tcontinue;\n\t\t}\n\n\t\tilitek_touch_down(ts, id, x, y);\n\t}\n\nerr_sync_frame:\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n\treturn error;\n}\n\n \nstatic int api_protocol_set_cmd(struct ilitek_ts_data *ts,\n\t\t\t\tu16 idx, u8 *inbuf, u8 *outbuf)\n{\n\tu16 cmd;\n\tint error;\n\n\tif (idx >= MAX_CMD_CNT)\n\t\treturn -EINVAL;\n\n\tcmd = ts->ptl_cb_func[idx].cmd;\n\terror = ts->ptl_cb_func[idx].func(ts, cmd, inbuf, outbuf);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int api_protocol_get_ptl_ver(struct ilitek_ts_data *ts,\n\t\t\t\t    u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tint error;\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\terror = ilitek_i2c_write_and_read(ts, buf, 1, 5, outbuf, 3);\n\tif (error)\n\t\treturn error;\n\n\tts->ptl.ver = get_unaligned_be16(outbuf);\n\tts->ptl.ver_major = outbuf[0];\n\n\treturn 0;\n}\n\nstatic int api_protocol_get_mcu_ver(struct ilitek_ts_data *ts,\n\t\t\t\t    u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tint error;\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\terror = ilitek_i2c_write_and_read(ts, buf, 1, 5, outbuf, 32);\n\tif (error)\n\t\treturn error;\n\n\tts->mcu_ver = get_unaligned_le16(outbuf);\n\tmemset(ts->product_id, 0, sizeof(ts->product_id));\n\tmemcpy(ts->product_id, outbuf + 6, 26);\n\n\treturn 0;\n}\n\nstatic int api_protocol_get_fw_ver(struct ilitek_ts_data *ts,\n\t\t\t\t   u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tint error;\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\terror = ilitek_i2c_write_and_read(ts, buf, 1, 5, outbuf, 8);\n\tif (error)\n\t\treturn error;\n\n\tmemcpy(ts->firmware_ver, outbuf, 8);\n\n\treturn 0;\n}\n\nstatic int api_protocol_get_scrn_res(struct ilitek_ts_data *ts,\n\t\t\t\t     u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tint error;\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\terror = ilitek_i2c_write_and_read(ts, buf, 1, 5, outbuf, 8);\n\tif (error)\n\t\treturn error;\n\n\tts->screen_min_x = get_unaligned_le16(outbuf);\n\tts->screen_min_y = get_unaligned_le16(outbuf + 2);\n\tts->screen_max_x = get_unaligned_le16(outbuf + 4);\n\tts->screen_max_y = get_unaligned_le16(outbuf + 6);\n\n\treturn 0;\n}\n\nstatic int api_protocol_get_tp_res(struct ilitek_ts_data *ts,\n\t\t\t\t   u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tint error;\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\terror = ilitek_i2c_write_and_read(ts, buf, 1, 5, outbuf, 15);\n\tif (error)\n\t\treturn error;\n\n\tts->max_tp = outbuf[8];\n\tif (ts->max_tp > ILITEK_SUPPORT_MAX_POINT) {\n\t\tdev_err(&ts->client->dev, \"Invalid MAX_TP:%d from FW\\n\",\n\t\t\tts->max_tp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int api_protocol_get_ic_mode(struct ilitek_ts_data *ts,\n\t\t\t\t    u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tint error;\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\terror = ilitek_i2c_write_and_read(ts, buf, 1, 5, outbuf, 2);\n\tif (error)\n\t\treturn error;\n\n\tts->ic_mode = outbuf[0];\n\treturn 0;\n}\n\nstatic int api_protocol_set_ic_sleep(struct ilitek_ts_data *ts,\n\t\t\t\t     u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\treturn ilitek_i2c_write_and_read(ts, buf, 1, 0, NULL, 0);\n}\n\nstatic int api_protocol_set_ic_wake(struct ilitek_ts_data *ts,\n\t\t\t\t    u16 cmd, u8 *inbuf, u8 *outbuf)\n{\n\tu8 buf[64];\n\n\tbuf[0] = cmd;\n\treturn ilitek_i2c_write_and_read(ts, buf, 1, 0, NULL, 0);\n}\n\nstatic const struct ilitek_protocol_map ptl_func_map[] = {\n\t \n\t[GET_PTL_VER] = {\n\t\tILITEK_TP_CMD_GET_PRL_VER, \"GET_PTL_VER\",\n\t\tapi_protocol_get_ptl_ver\n\t},\n\t[GET_FW_VER] = {\n\t\tILITEK_TP_CMD_GET_FW_VER, \"GET_FW_VER\",\n\t\tapi_protocol_get_fw_ver\n\t},\n\t[GET_SCRN_RES] = {\n\t\tILITEK_TP_CMD_GET_SCRN_RES, \"GET_SCRN_RES\",\n\t\tapi_protocol_get_scrn_res\n\t},\n\t[GET_TP_RES] = {\n\t\tILITEK_TP_CMD_GET_TP_RES, \"GET_TP_RES\",\n\t\tapi_protocol_get_tp_res\n\t},\n\t[GET_IC_MODE] = {\n\t\tILITEK_TP_CMD_GET_IC_MODE, \"GET_IC_MODE\",\n\t\t\t   api_protocol_get_ic_mode\n\t},\n\t[GET_MCU_VER] = {\n\t\tILITEK_TP_CMD_GET_MCU_VER, \"GET_MOD_VER\",\n\t\t\t   api_protocol_get_mcu_ver\n\t},\n\t[SET_IC_SLEEP] = {\n\t\tILITEK_TP_CMD_SET_IC_SLEEP, \"SET_IC_SLEEP\",\n\t\tapi_protocol_set_ic_sleep\n\t},\n\t[SET_IC_WAKE] = {\n\t\tILITEK_TP_CMD_SET_IC_WAKE, \"SET_IC_WAKE\",\n\t\tapi_protocol_set_ic_wake\n\t},\n};\n\n \nstatic void ilitek_reset(struct ilitek_ts_data *ts, int delay)\n{\n\tif (ts->reset_gpio) {\n\t\tgpiod_set_value(ts->reset_gpio, 1);\n\t\tmdelay(10);\n\t\tgpiod_set_value(ts->reset_gpio, 0);\n\t\tmdelay(delay);\n\t}\n}\n\nstatic int ilitek_protocol_init(struct ilitek_ts_data *ts)\n{\n\tint error;\n\tu8 outbuf[64];\n\n\tts->ptl_cb_func = ptl_func_map;\n\tts->reset_time = 600;\n\n\terror = api_protocol_set_cmd(ts, GET_PTL_VER, NULL, outbuf);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (ts->ptl.ver_major == 0x3 ||\n\t    ts->ptl.ver == BL_V1_6 ||\n\t    ts->ptl.ver == BL_V1_7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ilitek_read_tp_info(struct ilitek_ts_data *ts, bool boot)\n{\n\tu8 outbuf[256];\n\tint error;\n\n\terror = api_protocol_set_cmd(ts, GET_PTL_VER, NULL, outbuf);\n\tif (error)\n\t\treturn error;\n\n\terror = api_protocol_set_cmd(ts, GET_MCU_VER, NULL, outbuf);\n\tif (error)\n\t\treturn error;\n\n\terror = api_protocol_set_cmd(ts, GET_FW_VER, NULL, outbuf);\n\tif (error)\n\t\treturn error;\n\n\tif (boot) {\n\t\terror = api_protocol_set_cmd(ts, GET_SCRN_RES, NULL,\n\t\t\t\t\t     outbuf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = api_protocol_set_cmd(ts, GET_TP_RES, NULL, outbuf);\n\tif (error)\n\t\treturn error;\n\n\terror = api_protocol_set_cmd(ts, GET_IC_MODE, NULL, outbuf);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int ilitek_input_dev_init(struct device *dev, struct ilitek_ts_data *ts)\n{\n\tint error;\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tts->input_dev = input;\n\tinput->name = ILITEK_TS_NAME;\n\tinput->id.bustype = BUS_I2C;\n\n\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t     ts->screen_min_x, ts->screen_max_x, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t     ts->screen_min_y, ts->screen_max_y, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, &ts->prop);\n\n\terror = input_mt_init_slots(input, ts->max_tp,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error) {\n\t\tdev_err(dev, \"initialize MT slots failed, err:%d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"register input device failed, err:%d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t ilitek_i2c_isr(int irq, void *dev_id)\n{\n\tstruct ilitek_ts_data *ts = dev_id;\n\tint error;\n\n\terror = ilitek_process_and_report_v6(ts);\n\tif (error < 0) {\n\t\tdev_err(&ts->client->dev, \"[%s] err:%d\\n\", __func__, error);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t firmware_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ilitek_ts_data *ts = i2c_get_clientdata(client);\n\n\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t \"fw version: [%02X%02X.%02X%02X.%02X%02X.%02X%02X]\\n\",\n\t\t\t ts->firmware_ver[0], ts->firmware_ver[1],\n\t\t\t ts->firmware_ver[2], ts->firmware_ver[3],\n\t\t\t ts->firmware_ver[4], ts->firmware_ver[5],\n\t\t\t ts->firmware_ver[6], ts->firmware_ver[7]);\n}\nstatic DEVICE_ATTR_RO(firmware_version);\n\nstatic ssize_t product_id_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ilitek_ts_data *ts = i2c_get_clientdata(client);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"product id: [%04X], module: [%s]\\n\",\n\t\t\t ts->mcu_ver, ts->product_id);\n}\nstatic DEVICE_ATTR_RO(product_id);\n\nstatic struct attribute *ilitek_sysfs_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_product_id.attr,\n\tNULL\n};\n\nstatic struct attribute_group ilitek_attrs_group = {\n\t.attrs = ilitek_sysfs_attrs,\n};\n\nstatic int ilitek_ts_i2c_probe(struct i2c_client *client)\n{\n\tstruct ilitek_ts_data *ts;\n\tstruct device *dev = &client->dev;\n\tint error;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"i2c check functionality failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tts->client = client;\n\ti2c_set_clientdata(client, ts);\n\n\tts->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ts->reset_gpio)) {\n\t\terror = PTR_ERR(ts->reset_gpio);\n\t\tdev_err(dev, \"request gpiod failed: %d\", error);\n\t\treturn error;\n\t}\n\n\tilitek_reset(ts, 1000);\n\n\terror = ilitek_protocol_init(ts);\n\tif (error) {\n\t\tdev_err(dev, \"protocol init failed: %d\", error);\n\t\treturn error;\n\t}\n\n\terror = ilitek_read_tp_info(ts, true);\n\tif (error) {\n\t\tdev_err(dev, \"read tp info failed: %d\", error);\n\t\treturn error;\n\t}\n\n\terror = ilitek_input_dev_init(dev, ts);\n\tif (error) {\n\t\tdev_err(dev, \"input dev init failed: %d\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_request_threaded_irq(dev, ts->client->irq,\n\t\t\t\t\t  NULL, ilitek_i2c_isr, IRQF_ONESHOT,\n\t\t\t\t\t  \"ilitek_touch_irq\", ts);\n\tif (error) {\n\t\tdev_err(dev, \"request threaded irq failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_device_add_group(dev, &ilitek_attrs_group);\n\tif (error) {\n\t\tdev_err(dev, \"sysfs create group failed: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ilitek_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ilitek_ts_data *ts = i2c_get_clientdata(client);\n\tint error;\n\n\tdisable_irq(client->irq);\n\n\tif (!device_may_wakeup(dev)) {\n\t\terror = api_protocol_set_cmd(ts, SET_IC_SLEEP, NULL, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int ilitek_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ilitek_ts_data *ts = i2c_get_clientdata(client);\n\tint error;\n\n\tif (!device_may_wakeup(dev)) {\n\t\terror = api_protocol_set_cmd(ts, SET_IC_WAKE, NULL, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tilitek_reset(ts, ts->reset_time);\n\t}\n\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ilitek_pm_ops, ilitek_suspend, ilitek_resume);\n\nstatic const struct i2c_device_id ilitek_ts_i2c_id[] = {\n\t{ ILITEK_TS_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, ilitek_ts_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id ilitekts_acpi_id[] = {\n\t{ \"ILTK0001\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ilitekts_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ilitek_ts_i2c_match[] = {\n\t{.compatible = \"ilitek,ili2130\",},\n\t{.compatible = \"ilitek,ili2131\",},\n\t{.compatible = \"ilitek,ili2132\",},\n\t{.compatible = \"ilitek,ili2316\",},\n\t{.compatible = \"ilitek,ili2322\",},\n\t{.compatible = \"ilitek,ili2323\",},\n\t{.compatible = \"ilitek,ili2326\",},\n\t{.compatible = \"ilitek,ili2520\",},\n\t{.compatible = \"ilitek,ili2521\",},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ilitek_ts_i2c_match);\n#endif\n\nstatic struct i2c_driver ilitek_ts_i2c_driver = {\n\t.driver = {\n\t\t.name = ILITEK_TS_NAME,\n\t\t.pm = pm_sleep_ptr(&ilitek_pm_ops),\n\t\t.of_match_table = of_match_ptr(ilitek_ts_i2c_match),\n\t\t.acpi_match_table = ACPI_PTR(ilitekts_acpi_id),\n\t},\n\t.probe = ilitek_ts_i2c_probe,\n\t.id_table = ilitek_ts_i2c_id,\n};\nmodule_i2c_driver(ilitek_ts_i2c_driver);\n\nMODULE_AUTHOR(\"ILITEK\");\nMODULE_DESCRIPTION(\"ILITEK I2C Touchscreen Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}