{
  "module_name": "goodix_fwupload.c",
  "hash_id": "85ea6c762aafaa851f9b4aa67ecaffbd6784a2bf970aa61a4690a7314e84e43b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/goodix_fwupload.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include \"goodix.h\"\n\n#define GOODIX_FW_HEADER_LENGTH\t\tsizeof(struct goodix_fw_header)\n#define GOODIX_FW_SECTION_LENGTH\t0x2000\n#define GOODIX_FW_DSP_LENGTH\t\t0x1000\n#define GOODIX_FW_UPLOAD_ADDRESS\t0xc000\n\n#define GOODIX_CFG_LOC_HAVE_KEY\t\t 7\n#define GOODIX_CFG_LOC_DRVA_NUM\t\t27\n#define GOODIX_CFG_LOC_DRVB_NUM\t\t28\n#define GOODIX_CFG_LOC_SENS_NUM\t\t29\n\nstruct goodix_fw_header {\n\tu8 hw_info[4];\n\tu8 pid[8];\n\tu8 vid[2];\n} __packed;\n\nstatic u16 goodix_firmware_checksum(const u8 *data, int size)\n{\n\tu16 checksum = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i += 2)\n\t\tchecksum += (data[i] << 8) + data[i + 1];\n\n\treturn checksum;\n}\n\nstatic int goodix_firmware_verify(struct device *dev, const struct firmware *fw)\n{\n\tconst struct goodix_fw_header *fw_header;\n\tsize_t expected_size;\n\tconst u8 *data;\n\tu16 checksum;\n\tchar buf[9];\n\n\texpected_size = GOODIX_FW_HEADER_LENGTH + 4 * GOODIX_FW_SECTION_LENGTH +\n\t\t\tGOODIX_FW_DSP_LENGTH;\n\tif (fw->size != expected_size) {\n\t\tdev_err(dev, \"Firmware has wrong size, expected %zu got %zu\\n\",\n\t\t\texpected_size, fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = fw->data + GOODIX_FW_HEADER_LENGTH;\n\tchecksum = goodix_firmware_checksum(data, 4 * GOODIX_FW_SECTION_LENGTH);\n\tif (checksum) {\n\t\tdev_err(dev, \"Main firmware checksum error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata += 4 * GOODIX_FW_SECTION_LENGTH;\n\tchecksum = goodix_firmware_checksum(data, GOODIX_FW_DSP_LENGTH);\n\tif (checksum) {\n\t\tdev_err(dev, \"DSP firmware checksum error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_header = (const struct goodix_fw_header *)fw->data;\n\tdev_info(dev, \"Firmware hardware info %02x%02x%02x%02x\\n\",\n\t\t fw_header->hw_info[0], fw_header->hw_info[1],\n\t\t fw_header->hw_info[2], fw_header->hw_info[3]);\n\t \n\tmemcpy(buf, fw_header->pid, 8);\n\tbuf[8] = 0;\n\tdev_info(dev, \"Firmware PID: %s VID: %02x%02x\\n\", buf,\n\t\t fw_header->vid[0], fw_header->vid[1]);\n\treturn 0;\n}\n\nstatic int goodix_enter_upload_mode(struct i2c_client *client)\n{\n\tint tries, error;\n\tu8 val;\n\n\ttries = 200;\n\tdo {\n\t\terror = goodix_i2c_write_u8(client,\n\t\t\t\t\t    GOODIX_REG_MISCTL_SWRST, 0x0c);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = goodix_i2c_read(client,\n\t\t\t\t\tGOODIX_REG_MISCTL_SWRST, &val, 1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (val == 0x0c)\n\t\t\tbreak;\n\t} while (--tries);\n\n\tif (!tries) {\n\t\tdev_err(&client->dev, \"Error could not hold ss51 & dsp\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_DSP_CTL, 0x00);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_TMR0_EN, 0x00);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_CACHE_EN, 0x00);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_BOOTCTL, 0x02);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client,\n\t\t\t\t    GOODIX_REG_MISCTL_CPU_SWRST_PULSE, 0x01);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_BOOTCTL, 0x00);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_BOOT_OPT, 0x00);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_MEM_CD_EN, 0x01);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int goodix_start_firmware(struct i2c_client *client)\n{\n\tint error;\n\tu8 val;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_SW_WDT, 0xaa);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_MISCTL_SWRST, 0x00);\n\tif (error)\n\t\treturn error;\n\n\terror = goodix_i2c_read(client, GOODIX_REG_SW_WDT, &val, 1);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (val == 0xaa) {\n\t\tdev_err(&client->dev, \"Error SW_WDT reg not cleared on fw startup\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\terror = goodix_i2c_write_u8(client, GOODIX_REG_SW_WDT, 0xaa);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int goodix_firmware_upload(struct goodix_ts_data *ts)\n{\n\tconst struct firmware *fw;\n\tchar fw_name[64];\n\tconst u8 *data;\n\tint error;\n\n\tsnprintf(fw_name, sizeof(fw_name), \"goodix/%s\", ts->firmware_name);\n\n\terror = request_firmware(&fw, fw_name, &ts->client->dev);\n\tif (error) {\n\t\tdev_err(&ts->client->dev, \"Firmware request error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = goodix_firmware_verify(&ts->client->dev, fw);\n\tif (error)\n\t\tgoto release;\n\n\terror = goodix_reset_no_int_sync(ts);\n\tif (error)\n\t\tgoto release;\n\n\terror = goodix_enter_upload_mode(ts->client);\n\tif (error)\n\t\tgoto release;\n\n\t \n\terror = goodix_i2c_write_u8(ts->client,\n\t\t\t\t    GOODIX_REG_MISCTL_SRAM_BANK, 0x00);\n\tif (error)\n\t\tgoto release;\n\n\tdata = fw->data + GOODIX_FW_HEADER_LENGTH;\n\terror = goodix_i2c_write(ts->client, GOODIX_FW_UPLOAD_ADDRESS,\n\t\t\t\t data, 2 * GOODIX_FW_SECTION_LENGTH);\n\tif (error)\n\t\tgoto release;\n\n\t \n\terror = goodix_i2c_write_u8(ts->client,\n\t\t\t\t    GOODIX_REG_MISCTL_SRAM_BANK, 0x01);\n\tif (error)\n\t\tgoto release;\n\n\tdata += 2 * GOODIX_FW_SECTION_LENGTH;\n\terror = goodix_i2c_write(ts->client, GOODIX_FW_UPLOAD_ADDRESS,\n\t\t\t\t data, 2 * GOODIX_FW_SECTION_LENGTH);\n\tif (error)\n\t\tgoto release;\n\n\t \n\terror = goodix_i2c_write_u8(ts->client,\n\t\t\t\t    GOODIX_REG_MISCTL_SRAM_BANK, 0x02);\n\tif (error)\n\t\tgoto release;\n\n\tdata += 2 * GOODIX_FW_SECTION_LENGTH;\n\terror = goodix_i2c_write(ts->client, GOODIX_FW_UPLOAD_ADDRESS,\n\t\t\t\t data, GOODIX_FW_DSP_LENGTH);\n\tif (error)\n\t\tgoto release;\n\n\terror = goodix_start_firmware(ts->client);\n\tif (error)\n\t\tgoto release;\n\n\terror = goodix_int_sync(ts);\nrelease:\n\trelease_firmware(fw);\n\treturn error;\n}\n\nstatic int goodix_prepare_bak_ref(struct goodix_ts_data *ts)\n{\n\tu8 have_key, driver_num, sensor_num;\n\n\tif (ts->bak_ref)\n\t\treturn 0;  \n\n\thave_key = (ts->config[GOODIX_CFG_LOC_HAVE_KEY] & 0x01);\n\n\tdriver_num = (ts->config[GOODIX_CFG_LOC_DRVA_NUM] & 0x1f) +\n\t\t     (ts->config[GOODIX_CFG_LOC_DRVB_NUM] & 0x1f);\n\tif (have_key)\n\t\tdriver_num--;\n\n\tsensor_num = (ts->config[GOODIX_CFG_LOC_SENS_NUM] & 0x0f) +\n\t\t     ((ts->config[GOODIX_CFG_LOC_SENS_NUM] >> 4) & 0x0f);\n\n\tdev_dbg(&ts->client->dev, \"Drv %d Sen %d Key %d\\n\",\n\t\tdriver_num, sensor_num, have_key);\n\n\tts->bak_ref_len = (driver_num * (sensor_num - 2) + 2) * 2;\n\n\tts->bak_ref = devm_kzalloc(&ts->client->dev,\n\t\t\t\t   ts->bak_ref_len, GFP_KERNEL);\n\tif (!ts->bak_ref)\n\t\treturn -ENOMEM;\n\n\t \n\tts->bak_ref[ts->bak_ref_len - 1] = 1;\n\n\treturn 0;\n}\n\nstatic int goodix_send_main_clock(struct goodix_ts_data *ts)\n{\n\tu32 main_clk = 54;  \n\tu8 checksum = 0;\n\tint i;\n\n\tdevice_property_read_u32(&ts->client->dev,\n\t\t\t\t \"goodix,main-clk\", &main_clk);\n\n\tfor (i = 0; i < (GOODIX_MAIN_CLK_LEN - 1); i++) {\n\t\tts->main_clk[i] = main_clk;\n\t\tchecksum += main_clk;\n\t}\n\n\t \n\tts->main_clk[GOODIX_MAIN_CLK_LEN - 1] = 256 - checksum;\n\n\treturn goodix_i2c_write(ts->client, GOODIX_REG_MAIN_CLK,\n\t\t\t\tts->main_clk, GOODIX_MAIN_CLK_LEN);\n}\n\nint goodix_firmware_check(struct goodix_ts_data *ts)\n{\n\tdevice_property_read_string(&ts->client->dev,\n\t\t\t\t    \"firmware-name\", &ts->firmware_name);\n\tif (!ts->firmware_name)\n\t\treturn 0;\n\n\tif (ts->irq_pin_access_method == IRQ_PIN_ACCESS_NONE) {\n\t\tdev_err(&ts->client->dev, \"Error no IRQ-pin access method, cannot upload fw.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&ts->client->dev, \"Touchscreen controller needs fw-upload\\n\");\n\tts->load_cfg_from_disk = true;\n\n\treturn goodix_firmware_upload(ts);\n}\n\nbool goodix_handle_fw_request(struct goodix_ts_data *ts)\n{\n\tint error;\n\tu8 val;\n\n\terror = goodix_i2c_read(ts->client, GOODIX_REG_REQUEST, &val, 1);\n\tif (error)\n\t\treturn false;\n\n\tswitch (val) {\n\tcase GOODIX_RQST_RESPONDED:\n\t\t \n\t\treturn false;\n\tcase GOODIX_RQST_CONFIG:\n\t\terror = goodix_send_cfg(ts, ts->config, ts->chip->config_len);\n\t\tif (error)\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase GOODIX_RQST_BAK_REF:\n\t\terror = goodix_prepare_bak_ref(ts);\n\t\tif (error)\n\t\t\treturn false;\n\n\t\terror = goodix_i2c_write(ts->client, GOODIX_REG_BAK_REF,\n\t\t\t\t\t ts->bak_ref, ts->bak_ref_len);\n\t\tif (error)\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase GOODIX_RQST_RESET:\n\t\terror = goodix_firmware_upload(ts);\n\t\tif (error)\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase GOODIX_RQST_MAIN_CLOCK:\n\t\terror = goodix_send_main_clock(ts);\n\t\tif (error)\n\t\t\treturn false;\n\n\t\tbreak;\n\tcase GOODIX_RQST_UNKNOWN:\n\tcase GOODIX_RQST_IDLE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err_ratelimited(&ts->client->dev, \"Unknown Request: 0x%02x\\n\", val);\n\t}\n\n\t \n\tgoodix_i2c_write_u8(ts->client,\n\t\t\t    GOODIX_REG_REQUEST, GOODIX_RQST_RESPONDED);\n\treturn true;\n}\n\nvoid goodix_save_bak_ref(struct goodix_ts_data *ts)\n{\n\tint error;\n\tu8 val;\n\n\tif (!ts->firmware_name)\n\t\treturn;\n\n\terror = goodix_i2c_read(ts->client, GOODIX_REG_STATUS, &val, 1);\n\tif (error)\n\t\treturn;\n\n\tif (!(val & 0x80))\n\t\treturn;\n\n\terror = goodix_i2c_read(ts->client, GOODIX_REG_BAK_REF,\n\t\t\t\tts->bak_ref, ts->bak_ref_len);\n\tif (error) {\n\t\tmemset(ts->bak_ref, 0, ts->bak_ref_len);\n\t\tts->bak_ref[ts->bak_ref_len - 1] = 1;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}