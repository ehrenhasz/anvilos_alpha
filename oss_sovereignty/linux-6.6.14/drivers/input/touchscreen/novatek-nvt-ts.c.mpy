{
  "module_name": "novatek-nvt-ts.c",
  "hash_id": "42101ab11c12494bd31039293b2a533334079bf19a69fe7730b4bf193b3a728e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/novatek-nvt-ts.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/module.h>\n\n#include <asm/unaligned.h>\n\n#define NVT_TS_TOUCH_START\t\t0x00\n#define NVT_TS_TOUCH_SIZE\t\t6\n\n#define NVT_TS_PARAMETERS_START\t\t0x78\n \n#define NVT_TS_PARAMS_WIDTH\t\t0x04\n#define NVT_TS_PARAMS_HEIGHT\t\t0x06\n#define NVT_TS_PARAMS_MAX_TOUCH\t\t0x09\n#define NVT_TS_PARAMS_MAX_BUTTONS\t0x0a\n#define NVT_TS_PARAMS_IRQ_TYPE\t\t0x0b\n#define NVT_TS_PARAMS_WAKE_TYPE\t\t0x0c\n#define NVT_TS_PARAMS_CHIP_ID\t\t0x0e\n#define NVT_TS_PARAMS_SIZE\t\t0x0f\n\n#define NVT_TS_SUPPORTED_WAKE_TYPE\t0x05\n#define NVT_TS_SUPPORTED_CHIP_ID\t0x05\n\n#define NVT_TS_MAX_TOUCHES\t\t10\n#define NVT_TS_MAX_SIZE\t\t\t4096\n\n#define NVT_TS_TOUCH_INVALID\t\t0xff\n#define NVT_TS_TOUCH_SLOT_SHIFT\t\t3\n#define NVT_TS_TOUCH_TYPE_MASK\t\tGENMASK(2, 0)\n#define NVT_TS_TOUCH_NEW\t\t1\n#define NVT_TS_TOUCH_UPDATE\t\t2\n#define NVT_TS_TOUCH_RELEASE\t\t3\n\nstatic const int nvt_ts_irq_type[4] = {\n\tIRQF_TRIGGER_RISING,\n\tIRQF_TRIGGER_FALLING,\n\tIRQF_TRIGGER_LOW,\n\tIRQF_TRIGGER_HIGH\n};\n\nstruct nvt_ts_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *reset_gpio;\n\tstruct touchscreen_properties prop;\n\tint max_touches;\n\tu8 buf[NVT_TS_TOUCH_SIZE * NVT_TS_MAX_TOUCHES];\n};\n\nstatic int nvt_ts_read_data(struct i2c_client *client, u8 reg, u8 *data, int count)\n{\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = 1,\n\t\t\t.buf = &reg,\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = count,\n\t\t\t.buf = data,\n\t\t}\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(&client->dev, \"Error reading from 0x%02x: %d\\n\", reg, ret);\n\t\treturn (ret < 0) ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t nvt_ts_irq(int irq, void *dev_id)\n{\n\tstruct nvt_ts_data *data = dev_id;\n\tstruct device *dev = &data->client->dev;\n\tint i, error, slot, x, y;\n\tbool active;\n\tu8 *touch;\n\n\terror = nvt_ts_read_data(data->client, NVT_TS_TOUCH_START, data->buf,\n\t\t\t\t data->max_touches * NVT_TS_TOUCH_SIZE);\n\tif (error)\n\t\treturn IRQ_HANDLED;\n\n\tfor (i = 0; i < data->max_touches; i++) {\n\t\ttouch = &data->buf[i * NVT_TS_TOUCH_SIZE];\n\n\t\tif (touch[0] == NVT_TS_TOUCH_INVALID)\n\t\t\tcontinue;\n\n\t\tslot = touch[0] >> NVT_TS_TOUCH_SLOT_SHIFT;\n\t\tif (slot < 1 || slot > data->max_touches) {\n\t\t\tdev_warn(dev, \"slot %d out of range, ignoring\\n\", slot);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (touch[0] & NVT_TS_TOUCH_TYPE_MASK) {\n\t\tcase NVT_TS_TOUCH_NEW:\n\t\tcase NVT_TS_TOUCH_UPDATE:\n\t\t\tactive = true;\n\t\t\tbreak;\n\t\tcase NVT_TS_TOUCH_RELEASE:\n\t\t\tactive = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"slot %d unknown state %d\\n\", slot, touch[0] & 7);\n\t\t\tcontinue;\n\t\t}\n\n\t\tslot--;\n\t\tx = (touch[1] << 4) | (touch[3] >> 4);\n\t\ty = (touch[2] << 4) | (touch[3] & 0x0f);\n\n\t\tinput_mt_slot(data->input, slot);\n\t\tinput_mt_report_slot_state(data->input, MT_TOOL_FINGER, active);\n\t\ttouchscreen_report_pos(data->input, &data->prop, x, y, true);\n\t}\n\n\tinput_mt_sync_frame(data->input);\n\tinput_sync(data->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nvt_ts_start(struct input_dev *dev)\n{\n\tstruct nvt_ts_data *data = input_get_drvdata(dev);\n\n\tenable_irq(data->client->irq);\n\tgpiod_set_value_cansleep(data->reset_gpio, 0);\n\n\treturn 0;\n}\n\nstatic void nvt_ts_stop(struct input_dev *dev)\n{\n\tstruct nvt_ts_data *data = input_get_drvdata(dev);\n\n\tdisable_irq(data->client->irq);\n\tgpiod_set_value_cansleep(data->reset_gpio, 1);\n}\n\nstatic int nvt_ts_suspend(struct device *dev)\n{\n\tstruct nvt_ts_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&data->input->mutex);\n\tif (input_device_enabled(data->input))\n\t\tnvt_ts_stop(data->input);\n\tmutex_unlock(&data->input->mutex);\n\n\treturn 0;\n}\n\nstatic int nvt_ts_resume(struct device *dev)\n{\n\tstruct nvt_ts_data *data = i2c_get_clientdata(to_i2c_client(dev));\n\n\tmutex_lock(&data->input->mutex);\n\tif (input_device_enabled(data->input))\n\t\tnvt_ts_start(data->input);\n\tmutex_unlock(&data->input->mutex);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(nvt_ts_pm_ops, nvt_ts_suspend, nvt_ts_resume);\n\nstatic int nvt_ts_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tint error, width, height, irq_type;\n\tstruct nvt_ts_data *data;\n\tstruct input_dev *input;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"Error no irq specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\ti2c_set_clientdata(client, data);\n\n\tdata->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\terror = PTR_ERR_OR_ZERO(data->reset_gpio);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request reset GPIO: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tmsleep(100);\n\terror = nvt_ts_read_data(data->client, NVT_TS_PARAMETERS_START,\n\t\t\t\t data->buf, NVT_TS_PARAMS_SIZE);\n\tgpiod_set_value_cansleep(data->reset_gpio, 1);  \n\tif (error)\n\t\treturn error;\n\n\twidth  = get_unaligned_be16(&data->buf[NVT_TS_PARAMS_WIDTH]);\n\theight = get_unaligned_be16(&data->buf[NVT_TS_PARAMS_HEIGHT]);\n\tdata->max_touches = data->buf[NVT_TS_PARAMS_MAX_TOUCH];\n\tirq_type = data->buf[NVT_TS_PARAMS_IRQ_TYPE];\n\n\tif (width > NVT_TS_MAX_SIZE || height >= NVT_TS_MAX_SIZE ||\n\t    data->max_touches > NVT_TS_MAX_TOUCHES ||\n\t    irq_type >= ARRAY_SIZE(nvt_ts_irq_type) ||\n\t    data->buf[NVT_TS_PARAMS_WAKE_TYPE] != NVT_TS_SUPPORTED_WAKE_TYPE ||\n\t    data->buf[NVT_TS_PARAMS_CHIP_ID] != NVT_TS_SUPPORTED_CHIP_ID) {\n\t\tdev_err(dev, \"Unsupported touchscreen parameters: %*ph\\n\",\n\t\t\tNVT_TS_PARAMS_SIZE, data->buf);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev, \"Detected %dx%d touchscreen with %d max touches\\n\",\n\t\twidth, height, data->max_touches);\n\n\tif (data->buf[NVT_TS_PARAMS_MAX_BUTTONS])\n\t\tdev_warn(dev, \"Touchscreen buttons are not supported\\n\");\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\tinput->open = nvt_ts_start;\n\tinput->close = nvt_ts_stop;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, width - 1, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, height - 1, 0, 0);\n\ttouchscreen_parse_properties(input, true, &data->prop);\n\n\terror = input_mt_init_slots(input, data->max_touches,\n\t\t\t\t    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error)\n\t\treturn error;\n\n\tdata->input = input;\n\tinput_set_drvdata(input, data);\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, nvt_ts_irq,\n\t\t\t\t\t  IRQF_ONESHOT | IRQF_NO_AUTOEN |\n\t\t\t\t\t\tnvt_ts_irq_type[irq_type],\n\t\t\t\t\t  client->name, data);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id nvt_ts_i2c_id[] = {\n\t{ \"NVT-ts\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nvt_ts_i2c_id);\n\nstatic struct i2c_driver nvt_ts_driver = {\n\t.driver = {\n\t\t.name\t= \"novatek-nvt-ts\",\n\t\t.pm\t= pm_sleep_ptr(&nvt_ts_pm_ops),\n\t},\n\t.probe = nvt_ts_probe,\n\t.id_table = nvt_ts_i2c_id,\n};\n\nmodule_i2c_driver(nvt_ts_driver);\n\nMODULE_DESCRIPTION(\"Novatek NT11205 touchscreen driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}