{
  "module_name": "resistive-adc-touch.c",
  "hash_id": "727737869789d20d8c91b27087aeaddc4d18be70a52a492870c28bcca528af99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/resistive-adc-touch.c",
  "human_readable_source": "\n \n#include <linux/input.h>\n#include <linux/input/touchscreen.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/iio.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define DRIVER_NAME\t\t\t\t\t\"resistive-adc-touch\"\n#define GRTS_DEFAULT_PRESSURE_MIN\t\t\t50000\n#define GRTS_DEFAULT_PRESSURE_MAX\t\t\t65535\n#define GRTS_MAX_POS_MASK\t\t\t\tGENMASK(11, 0)\n#define GRTS_MAX_CHANNELS\t\t\t\t4\n\nenum grts_ch_type {\n\tGRTS_CH_X,\n\tGRTS_CH_Y,\n\tGRTS_CH_PRESSURE,\n\tGRTS_CH_Z1,\n\tGRTS_CH_Z2,\n\tGRTS_CH_MAX = GRTS_CH_Z2 + 1\n};\n\n \nstruct grts_state {\n\tu32\t\t\t\tx_plate_ohms;\n\tu32\t\t\t\tpressure_min;\n\tbool\t\t\t\tpressure;\n\tstruct iio_channel\t\t*iio_chans;\n\tstruct iio_cb_buffer\t\t*iio_cb;\n\tstruct input_dev\t\t*input;\n\tstruct touchscreen_properties\tprop;\n\tu8\t\t\t\tch_map[GRTS_CH_MAX];\n};\n\nstatic int grts_cb(const void *data, void *private)\n{\n\tconst u16 *touch_info = data;\n\tstruct grts_state *st = private;\n\tunsigned int x, y, press = 0;\n\n\tx = touch_info[st->ch_map[GRTS_CH_X]];\n\ty = touch_info[st->ch_map[GRTS_CH_Y]];\n\n\tif (st->ch_map[GRTS_CH_PRESSURE] < GRTS_MAX_CHANNELS) {\n\t\tpress = touch_info[st->ch_map[GRTS_CH_PRESSURE]];\n\t} else if (st->ch_map[GRTS_CH_Z1] < GRTS_MAX_CHANNELS) {\n\t\tunsigned int z1 = touch_info[st->ch_map[GRTS_CH_Z1]];\n\t\tunsigned int z2 = touch_info[st->ch_map[GRTS_CH_Z2]];\n\t\tunsigned int Rt;\n\n\t\tif (likely(x && z1)) {\n\t\t\tRt = z2;\n\t\t\tRt -= z1;\n\t\t\tRt *= st->x_plate_ohms;\n\t\t\tRt = DIV_ROUND_CLOSEST(Rt, 16);\n\t\t\tRt *= x;\n\t\t\tRt /= z1;\n\t\t\tRt = DIV_ROUND_CLOSEST(Rt, 256);\n\t\t\t \n\t\t\tif (Rt < GRTS_DEFAULT_PRESSURE_MAX)\n\t\t\t\tpress = GRTS_DEFAULT_PRESSURE_MAX - Rt;\n\t\t}\n\t}\n\n\tif ((!x && !y) || (st->pressure && (press < st->pressure_min))) {\n\t\t \n\t\tinput_report_key(st->input, BTN_TOUCH, 0);\n\t\tinput_sync(st->input);\n\t\treturn 0;\n\t}\n\n\t \n\ttouchscreen_report_pos(st->input, &st->prop, x, y, false);\n\tif (st->pressure)\n\t\tinput_report_abs(st->input, ABS_PRESSURE, press);\n\tinput_report_key(st->input, BTN_TOUCH, 1);\n\tinput_sync(st->input);\n\n\treturn 0;\n}\n\nstatic int grts_open(struct input_dev *dev)\n{\n\tint error;\n\tstruct grts_state *st = input_get_drvdata(dev);\n\n\terror = iio_channel_start_all_cb(st->iio_cb);\n\tif (error) {\n\t\tdev_err(dev->dev.parent, \"failed to start callback buffer.\\n\");\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\nstatic void grts_close(struct input_dev *dev)\n{\n\tstruct grts_state *st = input_get_drvdata(dev);\n\n\tiio_channel_stop_all_cb(st->iio_cb);\n}\n\nstatic void grts_disable(void *data)\n{\n\tiio_channel_release_all_cb(data);\n}\n\nstatic int grts_map_channel(struct grts_state *st, struct device *dev,\n\t\t\t    enum grts_ch_type type, const char *name,\n\t\t\t    bool optional)\n{\n\tint idx;\n\n\tidx = device_property_match_string(dev, \"io-channel-names\", name);\n\tif (idx < 0) {\n\t\tif (!optional)\n\t\t\treturn idx;\n\t\tidx = GRTS_MAX_CHANNELS;\n\t} else if (idx >= GRTS_MAX_CHANNELS) {\n\t\treturn -EOVERFLOW;\n\t}\n\n\tst->ch_map[type] = idx;\n\treturn 0;\n}\n\nstatic int grts_get_properties(struct grts_state *st, struct device *dev)\n{\n\tint error;\n\n\terror = grts_map_channel(st, dev, GRTS_CH_X, \"x\", false);\n\tif (error)\n\t\treturn error;\n\n\terror = grts_map_channel(st, dev, GRTS_CH_Y, \"y\", false);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = grts_map_channel(st, dev, GRTS_CH_PRESSURE, \"pressure\", true);\n\tif (error)\n\t\treturn error;\n\n\tif (st->ch_map[GRTS_CH_PRESSURE] < GRTS_MAX_CHANNELS) {\n\t\tst->pressure = true;\n\t\treturn 0;\n\t}\n\n\t \n\terror = grts_map_channel(st, dev, GRTS_CH_Z1, \"z1\", true);\n\tif (error)\n\t\treturn error;\n\n\tif (st->ch_map[GRTS_CH_Z1] >= GRTS_MAX_CHANNELS)\n\t\treturn 0;\n\n\t \n\terror = grts_map_channel(st, dev, GRTS_CH_Z2, \"z2\", true);\n\tif (error)\n\t\treturn error;\n\n\terror = device_property_read_u32(dev,\n\t\t\t\t\t \"touchscreen-x-plate-ohms\",\n\t\t\t\t\t &st->x_plate_ohms);\n\tif (error) {\n\t\tdev_err(dev, \"can't get touchscreen-x-plate-ohms property\\n\");\n\t\treturn error;\n\t}\n\n\tst->pressure = true;\n\treturn 0;\n}\n\nstatic int grts_probe(struct platform_device *pdev)\n{\n\tstruct grts_state *st;\n\tstruct input_dev *input;\n\tstruct device *dev = &pdev->dev;\n\tint error;\n\n\tst = devm_kzalloc(dev, sizeof(struct grts_state), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\t \n\tst->iio_chans = devm_iio_channel_get_all(dev);\n\tif (IS_ERR(st->iio_chans))\n\t\treturn dev_err_probe(dev, PTR_ERR(st->iio_chans), \"can't get iio channels\\n\");\n\n\tif (!device_property_present(dev, \"io-channel-names\"))\n\t\treturn -ENODEV;\n\n\terror = grts_get_properties(st, dev);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to parse properties\\n\");\n\t\treturn error;\n\t}\n\n\tif (st->pressure) {\n\t\terror = device_property_read_u32(dev,\n\t\t\t\t\t\t \"touchscreen-min-pressure\",\n\t\t\t\t\t\t &st->pressure_min);\n\t\tif (error) {\n\t\t\tdev_dbg(dev, \"can't get touchscreen-min-pressure property.\\n\");\n\t\t\tst->pressure_min = GRTS_DEFAULT_PRESSURE_MIN;\n\t\t}\n\t}\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"failed to allocate input device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput->name = DRIVER_NAME;\n\tinput->id.bustype = BUS_HOST;\n\tinput->open = grts_open;\n\tinput->close = grts_close;\n\n\tinput_set_abs_params(input, ABS_X, 0, GRTS_MAX_POS_MASK - 1, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, GRTS_MAX_POS_MASK - 1, 0, 0);\n\tif (st->pressure)\n\t\tinput_set_abs_params(input, ABS_PRESSURE, st->pressure_min,\n\t\t\t\t     GRTS_DEFAULT_PRESSURE_MAX, 0, 0);\n\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\n\t \n\ttouchscreen_parse_properties(input, false, &st->prop);\n\n\tst->input = input;\n\tinput_set_drvdata(input, st);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register input device.\");\n\t\treturn error;\n\t}\n\n\tst->iio_cb = iio_channel_get_all_cb(dev, grts_cb, st);\n\tif (IS_ERR(st->iio_cb)) {\n\t\tdev_err(dev, \"failed to allocate callback buffer.\\n\");\n\t\treturn PTR_ERR(st->iio_cb);\n\t}\n\n\terror = devm_add_action_or_reset(dev, grts_disable, st->iio_cb);\n\tif (error) {\n\t\tdev_err(dev, \"failed to add disable action.\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id grts_of_match[] = {\n\t{\n\t\t.compatible = \"resistive-adc-touch\",\n\t}, {\n\t\t \n\t},\n};\n\nMODULE_DEVICE_TABLE(of, grts_of_match);\n\nstatic struct platform_driver grts_driver = {\n\t.probe = grts_probe,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = grts_of_match,\n\t},\n};\n\nmodule_platform_driver(grts_driver);\n\nMODULE_AUTHOR(\"Eugen Hristev <eugen.hristev@microchip.com>\");\nMODULE_DESCRIPTION(\"Generic ADC Resistive Touch Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}