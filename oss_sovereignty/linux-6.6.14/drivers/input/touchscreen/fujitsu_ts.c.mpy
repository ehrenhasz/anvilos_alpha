{
  "module_name": "fujitsu_ts.c",
  "hash_id": "c40727e555fa04612c30a592e92a9aa6a6b9632f9a739b06ff11e8e469053fb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/fujitsu_ts.c",
  "human_readable_source": "\n \n\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"Fujitsu serial touchscreen driver\"\n\nMODULE_AUTHOR(\"Dmitry Torokhov <dtor@mail.ru>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define FUJITSU_LENGTH 5\n\n \nstruct fujitsu {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tint idx;\n\tunsigned char data[FUJITSU_LENGTH];\n\tchar phys[32];\n};\n\n \nstatic irqreturn_t fujitsu_interrupt(struct serio *serio,\n\t\t\t\t     unsigned char data, unsigned int flags)\n{\n\tstruct fujitsu *fujitsu = serio_get_drvdata(serio);\n\tstruct input_dev *dev = fujitsu->dev;\n\n\tif (fujitsu->idx == 0) {\n\t\t \n\t\tif ((data & 0xf0) != 0x80)\n\t\t\treturn IRQ_HANDLED;\n\t} else {\n\t\t \n\t\tif (data & 0x80) {\n\t\t\tfujitsu->idx = 0;\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\tfujitsu->data[fujitsu->idx++] = data;\n\tif (fujitsu->idx == FUJITSU_LENGTH) {\n\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t (fujitsu->data[2] << 7) | fujitsu->data[1]);\n\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t (fujitsu->data[4] << 7) | fujitsu->data[3]);\n\t\tinput_report_key(dev, BTN_TOUCH,\n\t\t\t\t (fujitsu->data[0] & 0x03) != 2);\n\t\tinput_sync(dev);\n\t\tfujitsu->idx = 0;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void fujitsu_disconnect(struct serio *serio)\n{\n\tstruct fujitsu *fujitsu = serio_get_drvdata(serio);\n\n\tinput_get_device(fujitsu->dev);\n\tinput_unregister_device(fujitsu->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_put_device(fujitsu->dev);\n\tkfree(fujitsu);\n}\n\n \nstatic int fujitsu_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct fujitsu *fujitsu;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\tfujitsu = kzalloc(sizeof(struct fujitsu), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!fujitsu || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tfujitsu->serio = serio;\n\tfujitsu->dev = input_dev;\n\tsnprintf(fujitsu->phys, sizeof(fujitsu->phys),\n\t\t \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"Fujitsu Serial Touchscreen\";\n\tinput_dev->phys = fujitsu->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_FUJITSU;\n\tinput_dev->id.product = 0;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, 4096, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, 4096, 0, 0);\n\tserio_set_drvdata(serio, fujitsu);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(fujitsu->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\n\tserio_close(serio);\n fail2:\n\tserio_set_drvdata(serio, NULL);\n fail1:\n\tinput_free_device(input_dev);\n\tkfree(fujitsu);\n\treturn err;\n}\n\n \nstatic const struct serio_device_id fujitsu_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_FUJITSU,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, fujitsu_serio_ids);\n\nstatic struct serio_driver fujitsu_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"fujitsu_ts\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= fujitsu_serio_ids,\n\t.interrupt\t= fujitsu_interrupt,\n\t.connect\t= fujitsu_connect,\n\t.disconnect\t= fujitsu_disconnect,\n};\n\nmodule_serio_driver(fujitsu_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}