{
  "module_name": "chipone_icn8505.c",
  "hash_id": "68acfed000f1cfc86c0cd91177dd4dc6e9c0fbcf452cf7311bdf41078a0c03e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/touchscreen/chipone_icn8505.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/acpi.h>\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/module.h>\n\n \n#define ICN8505_REG_ADDR_WIDTH\t\t16\n\n#define ICN8505_REG_POWER\t\t0x0004\n#define ICN8505_REG_TOUCHDATA\t\t0x1000\n#define ICN8505_REG_CONFIGDATA\t\t0x8000\n\n \n#define ICN8505_POWER_ACTIVE\t\t0x00\n#define ICN8505_POWER_MONITOR\t\t0x01\n#define ICN8505_POWER_HIBERNATE\t\t0x02\n \n#define ICN8505_POWER_ENA_CHARGER_MODE\t0x55\n#define ICN8505_POWER_DIS_CHARGER_MODE\t0x66\n\n#define ICN8505_MAX_TOUCHES\t\t10\n\n \n#define ICN8505_PROG_I2C_ADDR\t\t0x30\n#define ICN8505_PROG_REG_ADDR_WIDTH\t24\n\n#define MAX_FW_UPLOAD_TRIES\t\t3\n\nstruct icn8505_touch {\n\tu8 slot;\n\tu8 x[2];\n\tu8 y[2];\n\tu8 pressure;\t \n\tu8 event;\n \n#define ICN8505_EVENT_NO_DATA\t1  \n#define ICN8505_EVENT_UPDATE1\t2  \n#define ICN8505_EVENT_UPDATE2\t3  \n#define ICN8505_EVENT_END\t4  \n} __packed;\n\nstruct icn8505_touch_data {\n\tu8 softbutton;\n\tu8 touch_count;\n\tstruct icn8505_touch touches[ICN8505_MAX_TOUCHES];\n} __packed;\n\nstruct icn8505_data {\n\tstruct i2c_client *client;\n\tstruct input_dev *input;\n\tstruct gpio_desc *wake_gpio;\n\tstruct touchscreen_properties prop;\n\tchar firmware_name[32];\n};\n\nstatic int icn8505_read_xfer(struct i2c_client *client, u16 i2c_addr,\n\t\t\t     int reg_addr, int reg_addr_width,\n\t\t\t     void *data, int len, bool silent)\n{\n\tu8 buf[3];\n\tint i, ret;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = i2c_addr,\n\t\t\t.buf = buf,\n\t\t\t.len = reg_addr_width / 8,\n\t\t},\n\t\t{\n\t\t\t.addr = i2c_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.buf = data,\n\t\t\t.len = len,\n\t\t}\n\t};\n\n\tfor (i = 0; i < (reg_addr_width / 8); i++)\n\t\tbuf[i] = (reg_addr >> (reg_addr_width - (i + 1) * 8)) & 0xff;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tif (!silent)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Error reading addr %#x reg %#x: %d\\n\",\n\t\t\t\ti2c_addr, reg_addr, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int icn8505_write_xfer(struct i2c_client *client, u16 i2c_addr,\n\t\t\t      int reg_addr, int reg_addr_width,\n\t\t\t      const void *data, int len, bool silent)\n{\n\tu8 buf[3 + 32];  \n\tint i, ret;\n\tstruct i2c_msg msg = {\n\t\t.addr = i2c_addr,\n\t\t.buf = buf,\n\t\t.len = reg_addr_width / 8 + len,\n\t};\n\n\tif (WARN_ON(len > 32))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < (reg_addr_width / 8); i++)\n\t\tbuf[i] = (reg_addr >> (reg_addr_width - (i + 1) * 8)) & 0xff;\n\n\tmemcpy(buf + reg_addr_width / 8, data, len);\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tif (ret != 1) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tif (!silent)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Error writing addr %#x reg %#x: %d\\n\",\n\t\t\t\ti2c_addr, reg_addr, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int icn8505_read_data(struct icn8505_data *icn8505, int reg,\n\t\t\t     void *buf, int len)\n{\n\treturn icn8505_read_xfer(icn8505->client, icn8505->client->addr, reg,\n\t\t\t\t ICN8505_REG_ADDR_WIDTH, buf, len, false);\n}\n\nstatic int icn8505_read_reg_silent(struct icn8505_data *icn8505, int reg)\n{\n\tu8 buf;\n\tint error;\n\n\terror = icn8505_read_xfer(icn8505->client, icn8505->client->addr, reg,\n\t\t\t\t  ICN8505_REG_ADDR_WIDTH, &buf, 1, true);\n\tif (error)\n\t\treturn error;\n\n\treturn buf;\n}\n\nstatic int icn8505_write_reg(struct icn8505_data *icn8505, int reg, u8 val)\n{\n\treturn icn8505_write_xfer(icn8505->client, icn8505->client->addr, reg,\n\t\t\t\t  ICN8505_REG_ADDR_WIDTH, &val, 1, false);\n}\n\nstatic int icn8505_read_prog_data(struct icn8505_data *icn8505, int reg,\n\t\t\t\t  void *buf, int len)\n{\n\treturn icn8505_read_xfer(icn8505->client, ICN8505_PROG_I2C_ADDR, reg,\n\t\t\t\t ICN8505_PROG_REG_ADDR_WIDTH, buf, len, false);\n}\n\nstatic int icn8505_write_prog_data(struct icn8505_data *icn8505, int reg,\n\t\t\t\t   const void *buf, int len)\n{\n\treturn icn8505_write_xfer(icn8505->client, ICN8505_PROG_I2C_ADDR, reg,\n\t\t\t\t  ICN8505_PROG_REG_ADDR_WIDTH, buf, len, false);\n}\n\nstatic int icn8505_write_prog_reg(struct icn8505_data *icn8505, int reg, u8 val)\n{\n\treturn icn8505_write_xfer(icn8505->client, ICN8505_PROG_I2C_ADDR, reg,\n\t\t\t\t  ICN8505_PROG_REG_ADDR_WIDTH, &val, 1, false);\n}\n\n \nstatic int icn8505_try_fw_upload(struct icn8505_data *icn8505,\n\t\t\t\t const struct firmware *fw)\n{\n\tstruct device *dev = &icn8505->client->dev;\n\tsize_t offset, count;\n\tint error;\n\tu8 buf[4];\n\tu32 crc;\n\n\t \n\terror = icn8505_write_prog_reg(icn8505, 0xcc3355, 0x5a);\n\tif (error)\n\t\treturn error;\n\n\tusleep_range(2000, 5000);\n\n\terror = icn8505_write_prog_reg(icn8505, 0x040400, 0x01);\n\tif (error)\n\t\treturn error;\n\n\tusleep_range(2000, 5000);\n\n\terror = icn8505_read_prog_data(icn8505, 0x040002, buf, 1);\n\tif (error)\n\t\treturn error;\n\n\tif (buf[0] != 0x85) {\n\t\tdev_err(dev, \"Failed to enter programming mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tusleep_range(1000, 5000);\n\n\t \n\terror = icn8505_write_prog_reg(icn8505, 0x40028, 1);\n\tif (error)\n\t\treturn error;\n\n\t \n\tfor (offset = 0; offset < fw->size; offset += count) {\n\t\tcount = min_t(size_t, fw->size - offset, 32);\n\t\terror = icn8505_write_prog_data(icn8505, offset,\n\t\t\t\t\t      fw->data + offset, count);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\terror = icn8505_write_prog_reg(icn8505, 0x40028, 0);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = icn8505_read_prog_data(icn8505, 0x40034, buf, 2);\n\tif (error)\n\t\treturn error;\n\n\tif (get_unaligned_le16(buf) != fw->size) {\n\t\tdev_warn(dev, \"Length mismatch after uploading fw\\n\");\n\t\treturn -EIO;\n\t}\n\n\terror = icn8505_read_prog_data(icn8505, 0x4002c, buf, 4);\n\tif (error)\n\t\treturn error;\n\n\tcrc = crc32_be(0, fw->data, fw->size);\n\tif (get_unaligned_le32(buf) != crc) {\n\t\tdev_warn(dev, \"CRC mismatch after uploading fw\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\terror = icn8505_write_prog_reg(icn8505, 0x40400, 0x03);\n\tif (error)\n\t\treturn error;\n\n\tusleep_range(2000, 5000);\n\treturn 0;\n}\n\nstatic int icn8505_upload_fw(struct icn8505_data *icn8505)\n{\n\tstruct device *dev = &icn8505->client->dev;\n\tconst struct firmware *fw;\n\tint i, error;\n\n\t \n\terror = firmware_request_platform(&fw, icn8505->firmware_name, dev);\n\tif (error) {\n\t\tdev_err(dev, \"Firmware request error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tif (icn8505_read_reg_silent(icn8505, 0x000a) == 0x85)\n\t\tgoto success;\n\n\tfor (i = 1; i <= MAX_FW_UPLOAD_TRIES; i++) {\n\t\terror = icn8505_try_fw_upload(icn8505, fw);\n\t\tif (!error)\n\t\t\tgoto success;\n\n\t\tdev_err(dev, \"Failed to upload firmware: %d (attempt %d/%d)\\n\",\n\t\t\terror, i, MAX_FW_UPLOAD_TRIES);\n\t\tusleep_range(2000, 5000);\n\t}\n\nsuccess:\n\trelease_firmware(fw);\n\treturn error;\n}\n\nstatic bool icn8505_touch_active(u8 event)\n{\n\treturn event == ICN8505_EVENT_UPDATE1 ||\n\t       event == ICN8505_EVENT_UPDATE2;\n}\n\nstatic irqreturn_t icn8505_irq(int irq, void *dev_id)\n{\n\tstruct icn8505_data *icn8505 = dev_id;\n\tstruct device *dev = &icn8505->client->dev;\n\tstruct icn8505_touch_data touch_data;\n\tint i, error;\n\n\terror = icn8505_read_data(icn8505, ICN8505_REG_TOUCHDATA,\n\t\t\t\t  &touch_data, sizeof(touch_data));\n\tif (error) {\n\t\tdev_err(dev, \"Error reading touch data: %d\\n\", error);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (touch_data.touch_count > ICN8505_MAX_TOUCHES) {\n\t\tdev_warn(dev, \"Too many touches %d > %d\\n\",\n\t\t\t touch_data.touch_count, ICN8505_MAX_TOUCHES);\n\t\ttouch_data.touch_count = ICN8505_MAX_TOUCHES;\n\t}\n\n\tfor (i = 0; i < touch_data.touch_count; i++) {\n\t\tstruct icn8505_touch *touch = &touch_data.touches[i];\n\t\tbool act = icn8505_touch_active(touch->event);\n\n\t\tinput_mt_slot(icn8505->input, touch->slot);\n\t\tinput_mt_report_slot_state(icn8505->input, MT_TOOL_FINGER, act);\n\t\tif (!act)\n\t\t\tcontinue;\n\n\t\ttouchscreen_report_pos(icn8505->input, &icn8505->prop,\n\t\t\t\t       get_unaligned_le16(touch->x),\n\t\t\t\t       get_unaligned_le16(touch->y),\n\t\t\t\t       true);\n\t}\n\n\tinput_mt_sync_frame(icn8505->input);\n\tinput_report_key(icn8505->input, KEY_LEFTMETA,\n\t\t\t touch_data.softbutton == 1);\n\tinput_sync(icn8505->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int icn8505_probe_acpi(struct icn8505_data *icn8505, struct device *dev)\n{\n\tconst char *subsys;\n\tint error;\n\n\tsubsys = acpi_get_subsystem_id(ACPI_HANDLE(dev));\n\terror = PTR_ERR_OR_ZERO(subsys);\n\tif (error == -ENODATA)\n\t\tsubsys = \"unknown\";\n\telse if (error)\n\t\treturn error;\n\n\tsnprintf(icn8505->firmware_name, sizeof(icn8505->firmware_name),\n\t\t \"chipone/icn8505-%s.fw\", subsys);\n\n\tkfree_const(subsys);\n\treturn 0;\n}\n\nstatic int icn8505_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct icn8505_data *icn8505;\n\tstruct input_dev *input;\n\t__le16 resolution[2];\n\tint error;\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"No irq specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ticn8505 = devm_kzalloc(dev, sizeof(*icn8505), GFP_KERNEL);\n\tif (!icn8505)\n\t\treturn -ENOMEM;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = client->name;\n\tinput->id.bustype = BUS_I2C;\n\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_X);\n\tinput_set_capability(input, EV_ABS, ABS_MT_POSITION_Y);\n\tinput_set_capability(input, EV_KEY, KEY_LEFTMETA);\n\n\ticn8505->client = client;\n\ticn8505->input = input;\n\tinput_set_drvdata(input, icn8505);\n\n\terror = icn8505_probe_acpi(icn8505, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = icn8505_upload_fw(icn8505);\n\tif (error)\n\t\treturn error;\n\n\terror = icn8505_read_data(icn8505, ICN8505_REG_CONFIGDATA,\n\t\t\t\tresolution, sizeof(resolution));\n\tif (error) {\n\t\tdev_err(dev, \"Error reading resolution: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0,\n\t\t\t     le16_to_cpu(resolution[0]) - 1, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\n\t\t\t     le16_to_cpu(resolution[1]) - 1, 0, 0);\n\n\ttouchscreen_parse_properties(input, true, &icn8505->prop);\n\tif (!input_abs_get_max(input, ABS_MT_POSITION_X) ||\n\t    !input_abs_get_max(input, ABS_MT_POSITION_Y)) {\n\t\tdev_err(dev, \"Error touchscreen-size-x and/or -y missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = input_mt_init_slots(input, ICN8505_MAX_TOUCHES,\n\t\t\t\t  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_request_threaded_irq(dev, client->irq, NULL, icn8505_irq,\n\t\t\t\t\tIRQF_ONESHOT, client->name, icn8505);\n\tif (error) {\n\t\tdev_err(dev, \"Error requesting irq: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = input_register_device(input);\n\tif (error)\n\t\treturn error;\n\n\ti2c_set_clientdata(client, icn8505);\n\treturn 0;\n}\n\nstatic int icn8505_suspend(struct device *dev)\n{\n\tstruct icn8505_data *icn8505 = i2c_get_clientdata(to_i2c_client(dev));\n\n\tdisable_irq(icn8505->client->irq);\n\n\ticn8505_write_reg(icn8505, ICN8505_REG_POWER, ICN8505_POWER_HIBERNATE);\n\n\treturn 0;\n}\n\nstatic int icn8505_resume(struct device *dev)\n{\n\tstruct icn8505_data *icn8505 = i2c_get_clientdata(to_i2c_client(dev));\n\tint error;\n\n\terror = icn8505_upload_fw(icn8505);\n\tif (error)\n\t\treturn error;\n\n\tenable_irq(icn8505->client->irq);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(icn8505_pm_ops, icn8505_suspend, icn8505_resume);\n\nstatic const struct acpi_device_id icn8505_acpi_match[] = {\n\t{ \"CHPN0001\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, icn8505_acpi_match);\n\nstatic struct i2c_driver icn8505_driver = {\n\t.driver = {\n\t\t.name\t= \"chipone_icn8505\",\n\t\t.pm\t= pm_sleep_ptr(&icn8505_pm_ops),\n\t\t.acpi_match_table = icn8505_acpi_match,\n\t},\n\t.probe = icn8505_probe,\n};\n\nmodule_i2c_driver(icn8505_driver);\n\nMODULE_DESCRIPTION(\"ChipOne icn8505 I2C Touchscreen Driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}