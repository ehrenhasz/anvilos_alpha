{
  "module_name": "evdev.c",
  "hash_id": "02616b43f879bde6605459a6907afb1a354adcee76bd228876e2024e7f3fc446",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/evdev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define EVDEV_MINOR_BASE\t64\n#define EVDEV_MINORS\t\t32\n#define EVDEV_MIN_BUFFER_SIZE\t64U\n#define EVDEV_BUF_PACKETS\t8\n\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input/mt.h>\n#include <linux/major.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include \"input-compat.h\"\n\nstruct evdev {\n\tint open;\n\tstruct input_handle handle;\n\tstruct evdev_client __rcu *grab;\n\tstruct list_head client_list;\n\tspinlock_t client_lock;  \n\tstruct mutex mutex;\n\tstruct device dev;\n\tstruct cdev cdev;\n\tbool exist;\n};\n\nstruct evdev_client {\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int packet_head;  \n\tspinlock_t buffer_lock;  \n\twait_queue_head_t wait;\n\tstruct fasync_struct *fasync;\n\tstruct evdev *evdev;\n\tstruct list_head node;\n\tenum input_clock_type clk_type;\n\tbool revoked;\n\tunsigned long *evmasks[EV_CNT];\n\tunsigned int bufsize;\n\tstruct input_event buffer[];\n};\n\nstatic size_t evdev_get_mask_cnt(unsigned int type)\n{\n\tstatic const size_t counts[EV_CNT] = {\n\t\t \n\t\t[EV_SYN]\t= EV_CNT,\n\t\t[EV_KEY]\t= KEY_CNT,\n\t\t[EV_REL]\t= REL_CNT,\n\t\t[EV_ABS]\t= ABS_CNT,\n\t\t[EV_MSC]\t= MSC_CNT,\n\t\t[EV_SW]\t\t= SW_CNT,\n\t\t[EV_LED]\t= LED_CNT,\n\t\t[EV_SND]\t= SND_CNT,\n\t\t[EV_FF]\t\t= FF_CNT,\n\t};\n\n\treturn (type < EV_CNT) ? counts[type] : 0;\n}\n\n \nstatic bool __evdev_is_filtered(struct evdev_client *client,\n\t\t\t\tunsigned int type,\n\t\t\t\tunsigned int code)\n{\n\tunsigned long *mask;\n\tsize_t cnt;\n\n\t \n\tif (type == EV_SYN || type >= EV_CNT)\n\t\treturn false;\n\n\t \n\tmask = client->evmasks[0];\n\tif (mask && !test_bit(type, mask))\n\t\treturn true;\n\n\t \n\tcnt = evdev_get_mask_cnt(type);\n\tif (!cnt || code >= cnt)\n\t\treturn false;\n\n\tmask = client->evmasks[type];\n\treturn mask && !test_bit(code, mask);\n}\n\n \nstatic void __evdev_flush_queue(struct evdev_client *client, unsigned int type)\n{\n\tunsigned int i, head, num;\n\tunsigned int mask = client->bufsize - 1;\n\tbool is_report;\n\tstruct input_event *ev;\n\n\tBUG_ON(type == EV_SYN);\n\n\thead = client->tail;\n\tclient->packet_head = client->tail;\n\n\t \n\tnum = 1;\n\n\tfor (i = client->tail; i != client->head; i = (i + 1) & mask) {\n\t\tev = &client->buffer[i];\n\t\tis_report = ev->type == EV_SYN && ev->code == SYN_REPORT;\n\n\t\tif (ev->type == type) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else if (is_report && !num) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else if (head != i) {\n\t\t\t \n\t\t\tclient->buffer[head] = *ev;\n\t\t}\n\n\t\tnum++;\n\t\thead = (head + 1) & mask;\n\n\t\tif (is_report) {\n\t\t\tnum = 0;\n\t\t\tclient->packet_head = head;\n\t\t}\n\t}\n\n\tclient->head = head;\n}\n\nstatic void __evdev_queue_syn_dropped(struct evdev_client *client)\n{\n\tktime_t *ev_time = input_get_timestamp(client->evdev->handle.dev);\n\tstruct timespec64 ts = ktime_to_timespec64(ev_time[client->clk_type]);\n\tstruct input_event ev;\n\n\tev.input_event_sec = ts.tv_sec;\n\tev.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;\n\tev.type = EV_SYN;\n\tev.code = SYN_DROPPED;\n\tev.value = 0;\n\n\tclient->buffer[client->head++] = ev;\n\tclient->head &= client->bufsize - 1;\n\n\tif (unlikely(client->head == client->tail)) {\n\t\t \n\t\tclient->tail = (client->head - 1) & (client->bufsize - 1);\n\t\tclient->packet_head = client->tail;\n\t}\n}\n\nstatic void evdev_queue_syn_dropped(struct evdev_client *client)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&client->buffer_lock, flags);\n\t__evdev_queue_syn_dropped(client);\n\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n}\n\nstatic int evdev_set_clk_type(struct evdev_client *client, unsigned int clkid)\n{\n\tunsigned long flags;\n\tenum input_clock_type clk_type;\n\n\tswitch (clkid) {\n\n\tcase CLOCK_REALTIME:\n\t\tclk_type = INPUT_CLK_REAL;\n\t\tbreak;\n\tcase CLOCK_MONOTONIC:\n\t\tclk_type = INPUT_CLK_MONO;\n\t\tbreak;\n\tcase CLOCK_BOOTTIME:\n\t\tclk_type = INPUT_CLK_BOOT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (client->clk_type != clk_type) {\n\t\tclient->clk_type = clk_type;\n\n\t\t \n\t\tspin_lock_irqsave(&client->buffer_lock, flags);\n\n\t\tif (client->head != client->tail) {\n\t\t\tclient->packet_head = client->head = client->tail;\n\t\t\t__evdev_queue_syn_dropped(client);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void __pass_event(struct evdev_client *client,\n\t\t\t const struct input_event *event)\n{\n\tclient->buffer[client->head++] = *event;\n\tclient->head &= client->bufsize - 1;\n\n\tif (unlikely(client->head == client->tail)) {\n\t\t \n\t\tclient->tail = (client->head - 2) & (client->bufsize - 1);\n\n\t\tclient->buffer[client->tail] = (struct input_event) {\n\t\t\t.input_event_sec = event->input_event_sec,\n\t\t\t.input_event_usec = event->input_event_usec,\n\t\t\t.type = EV_SYN,\n\t\t\t.code = SYN_DROPPED,\n\t\t\t.value = 0,\n\t\t};\n\n\t\tclient->packet_head = client->tail;\n\t}\n\n\tif (event->type == EV_SYN && event->code == SYN_REPORT) {\n\t\tclient->packet_head = client->head;\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n\t}\n}\n\nstatic void evdev_pass_values(struct evdev_client *client,\n\t\t\tconst struct input_value *vals, unsigned int count,\n\t\t\tktime_t *ev_time)\n{\n\tconst struct input_value *v;\n\tstruct input_event event;\n\tstruct timespec64 ts;\n\tbool wakeup = false;\n\n\tif (client->revoked)\n\t\treturn;\n\n\tts = ktime_to_timespec64(ev_time[client->clk_type]);\n\tevent.input_event_sec = ts.tv_sec;\n\tevent.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t \n\tspin_lock(&client->buffer_lock);\n\n\tfor (v = vals; v != vals + count; v++) {\n\t\tif (__evdev_is_filtered(client, v->type, v->code))\n\t\t\tcontinue;\n\n\t\tif (v->type == EV_SYN && v->code == SYN_REPORT) {\n\t\t\t \n\t\t\tif (client->packet_head == client->head)\n\t\t\t\tcontinue;\n\n\t\t\twakeup = true;\n\t\t}\n\n\t\tevent.type = v->type;\n\t\tevent.code = v->code;\n\t\tevent.value = v->value;\n\t\t__pass_event(client, &event);\n\t}\n\n\tspin_unlock(&client->buffer_lock);\n\n\tif (wakeup)\n\t\twake_up_interruptible_poll(&client->wait,\n\t\t\tEPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM);\n}\n\n \nstatic void evdev_events(struct input_handle *handle,\n\t\t\t const struct input_value *vals, unsigned int count)\n{\n\tstruct evdev *evdev = handle->private;\n\tstruct evdev_client *client;\n\tktime_t *ev_time = input_get_timestamp(handle->dev);\n\n\trcu_read_lock();\n\n\tclient = rcu_dereference(evdev->grab);\n\n\tif (client)\n\t\tevdev_pass_values(client, vals, count, ev_time);\n\telse\n\t\tlist_for_each_entry_rcu(client, &evdev->client_list, node)\n\t\t\tevdev_pass_values(client, vals, count, ev_time);\n\n\trcu_read_unlock();\n}\n\n \nstatic void evdev_event(struct input_handle *handle,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct input_value vals[] = { { type, code, value } };\n\n\tevdev_events(handle, vals, 1);\n}\n\nstatic int evdev_fasync(int fd, struct file *file, int on)\n{\n\tstruct evdev_client *client = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &client->fasync);\n}\n\nstatic void evdev_free(struct device *dev)\n{\n\tstruct evdev *evdev = container_of(dev, struct evdev, dev);\n\n\tinput_put_device(evdev->handle.dev);\n\tkfree(evdev);\n}\n\n \nstatic int evdev_grab(struct evdev *evdev, struct evdev_client *client)\n{\n\tint error;\n\n\tif (evdev->grab)\n\t\treturn -EBUSY;\n\n\terror = input_grab_device(&evdev->handle);\n\tif (error)\n\t\treturn error;\n\n\trcu_assign_pointer(evdev->grab, client);\n\n\treturn 0;\n}\n\nstatic int evdev_ungrab(struct evdev *evdev, struct evdev_client *client)\n{\n\tstruct evdev_client *grab = rcu_dereference_protected(evdev->grab,\n\t\t\t\t\tlockdep_is_held(&evdev->mutex));\n\n\tif (grab != client)\n\t\treturn  -EINVAL;\n\n\trcu_assign_pointer(evdev->grab, NULL);\n\tsynchronize_rcu();\n\tinput_release_device(&evdev->handle);\n\n\treturn 0;\n}\n\nstatic void evdev_attach_client(struct evdev *evdev,\n\t\t\t\tstruct evdev_client *client)\n{\n\tspin_lock(&evdev->client_lock);\n\tlist_add_tail_rcu(&client->node, &evdev->client_list);\n\tspin_unlock(&evdev->client_lock);\n}\n\nstatic void evdev_detach_client(struct evdev *evdev,\n\t\t\t\tstruct evdev_client *client)\n{\n\tspin_lock(&evdev->client_lock);\n\tlist_del_rcu(&client->node);\n\tspin_unlock(&evdev->client_lock);\n\tsynchronize_rcu();\n}\n\nstatic int evdev_open_device(struct evdev *evdev)\n{\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!evdev->exist)\n\t\tretval = -ENODEV;\n\telse if (!evdev->open++) {\n\t\tretval = input_open_device(&evdev->handle);\n\t\tif (retval)\n\t\t\tevdev->open--;\n\t}\n\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}\n\nstatic void evdev_close_device(struct evdev *evdev)\n{\n\tmutex_lock(&evdev->mutex);\n\n\tif (evdev->exist && !--evdev->open)\n\t\tinput_close_device(&evdev->handle);\n\n\tmutex_unlock(&evdev->mutex);\n}\n\n \nstatic void evdev_hangup(struct evdev *evdev)\n{\n\tstruct evdev_client *client;\n\n\tspin_lock(&evdev->client_lock);\n\tlist_for_each_entry(client, &evdev->client_list, node) {\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\t\twake_up_interruptible_poll(&client->wait, EPOLLHUP | EPOLLERR);\n\t}\n\tspin_unlock(&evdev->client_lock);\n}\n\nstatic int evdev_release(struct inode *inode, struct file *file)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\tunsigned int i;\n\n\tmutex_lock(&evdev->mutex);\n\n\tif (evdev->exist && !client->revoked)\n\t\tinput_flush_device(&evdev->handle, file);\n\n\tevdev_ungrab(evdev, client);\n\tmutex_unlock(&evdev->mutex);\n\n\tevdev_detach_client(evdev, client);\n\n\tfor (i = 0; i < EV_CNT; ++i)\n\t\tbitmap_free(client->evmasks[i]);\n\n\tkvfree(client);\n\n\tevdev_close_device(evdev);\n\n\treturn 0;\n}\n\nstatic unsigned int evdev_compute_buffer_size(struct input_dev *dev)\n{\n\tunsigned int n_events =\n\t\tmax(dev->hint_events_per_packet * EVDEV_BUF_PACKETS,\n\t\t    EVDEV_MIN_BUFFER_SIZE);\n\n\treturn roundup_pow_of_two(n_events);\n}\n\nstatic int evdev_open(struct inode *inode, struct file *file)\n{\n\tstruct evdev *evdev = container_of(inode->i_cdev, struct evdev, cdev);\n\tunsigned int bufsize = evdev_compute_buffer_size(evdev->handle.dev);\n\tstruct evdev_client *client;\n\tint error;\n\n\tclient = kvzalloc(struct_size(client, buffer, bufsize), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&client->wait);\n\tclient->bufsize = bufsize;\n\tspin_lock_init(&client->buffer_lock);\n\tclient->evdev = evdev;\n\tevdev_attach_client(evdev, client);\n\n\terror = evdev_open_device(evdev);\n\tif (error)\n\t\tgoto err_free_client;\n\n\tfile->private_data = client;\n\tstream_open(inode, file);\n\n\treturn 0;\n\n err_free_client:\n\tevdev_detach_client(evdev, client);\n\tkvfree(client);\n\treturn error;\n}\n\nstatic ssize_t evdev_write(struct file *file, const char __user *buffer,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\tstruct input_event event;\n\tint retval = 0;\n\n\tif (count != 0 && count < input_event_size())\n\t\treturn -EINVAL;\n\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!evdev->exist || client->revoked) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\twhile (retval + input_event_size() <= count) {\n\n\t\tif (input_event_from_user(buffer + retval, &event)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tretval += input_event_size();\n\n\t\tinput_inject_event(&evdev->handle,\n\t\t\t\t   event.type, event.code, event.value);\n\t\tcond_resched();\n\t}\n\n out:\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}\n\nstatic int evdev_fetch_next_event(struct evdev_client *client,\n\t\t\t\t  struct input_event *event)\n{\n\tint have_event;\n\n\tspin_lock_irq(&client->buffer_lock);\n\n\thave_event = client->packet_head != client->tail;\n\tif (have_event) {\n\t\t*event = client->buffer[client->tail++];\n\t\tclient->tail &= client->bufsize - 1;\n\t}\n\n\tspin_unlock_irq(&client->buffer_lock);\n\n\treturn have_event;\n}\n\nstatic ssize_t evdev_read(struct file *file, char __user *buffer,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\tstruct input_event event;\n\tsize_t read = 0;\n\tint error;\n\n\tif (count != 0 && count < input_event_size())\n\t\treturn -EINVAL;\n\n\tfor (;;) {\n\t\tif (!evdev->exist || client->revoked)\n\t\t\treturn -ENODEV;\n\n\t\tif (client->packet_head == client->tail &&\n\t\t    (file->f_flags & O_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\twhile (read + input_event_size() <= count &&\n\t\t       evdev_fetch_next_event(client, &event)) {\n\n\t\t\tif (input_event_to_user(buffer + read, &event))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tread += input_event_size();\n\t\t}\n\n\t\tif (read)\n\t\t\tbreak;\n\n\t\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\t\terror = wait_event_interruptible(client->wait,\n\t\t\t\t\tclient->packet_head != client->tail ||\n\t\t\t\t\t!evdev->exist || client->revoked);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn read;\n}\n\n \nstatic __poll_t evdev_poll(struct file *file, poll_table *wait)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\t__poll_t mask;\n\n\tpoll_wait(file, &client->wait, wait);\n\n\tif (evdev->exist && !client->revoked)\n\t\tmask = EPOLLOUT | EPOLLWRNORM;\n\telse\n\t\tmask = EPOLLHUP | EPOLLERR;\n\n\tif (client->packet_head != client->tail)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n#ifdef CONFIG_COMPAT\n\n#define BITS_PER_LONG_COMPAT (sizeof(compat_long_t) * 8)\n#define BITS_TO_LONGS_COMPAT(x) ((((x) - 1) / BITS_PER_LONG_COMPAT) + 1)\n\n#ifdef __BIG_ENDIAN\nstatic int bits_to_user(unsigned long *bits, unsigned int maxbit,\n\t\t\tunsigned int maxlen, void __user *p, int compat)\n{\n\tint len, i;\n\n\tif (compat) {\n\t\tlen = BITS_TO_LONGS_COMPAT(maxbit) * sizeof(compat_long_t);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tfor (i = 0; i < len / sizeof(compat_long_t); i++)\n\t\t\tif (copy_to_user((compat_long_t __user *) p + i,\n\t\t\t\t\t (compat_long_t *) bits +\n\t\t\t\t\t\ti + 1 - ((i % 2) << 1),\n\t\t\t\t\t sizeof(compat_long_t)))\n\t\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = BITS_TO_LONGS(maxbit) * sizeof(long);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (copy_to_user(p, bits, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn len;\n}\n\nstatic int bits_from_user(unsigned long *bits, unsigned int maxbit,\n\t\t\t  unsigned int maxlen, const void __user *p, int compat)\n{\n\tint len, i;\n\n\tif (compat) {\n\t\tif (maxlen % sizeof(compat_long_t))\n\t\t\treturn -EINVAL;\n\n\t\tlen = BITS_TO_LONGS_COMPAT(maxbit) * sizeof(compat_long_t);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tfor (i = 0; i < len / sizeof(compat_long_t); i++)\n\t\t\tif (copy_from_user((compat_long_t *) bits +\n\t\t\t\t\t\ti + 1 - ((i % 2) << 1),\n\t\t\t\t\t   (compat_long_t __user *) p + i,\n\t\t\t\t\t   sizeof(compat_long_t)))\n\t\t\t\treturn -EFAULT;\n\t\tif (i % 2)\n\t\t\t*((compat_long_t *) bits + i - 1) = 0;\n\n\t} else {\n\t\tif (maxlen % sizeof(long))\n\t\t\treturn -EINVAL;\n\n\t\tlen = BITS_TO_LONGS(maxbit) * sizeof(long);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (copy_from_user(bits, p, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn len;\n}\n\n#else\n\nstatic int bits_to_user(unsigned long *bits, unsigned int maxbit,\n\t\t\tunsigned int maxlen, void __user *p, int compat)\n{\n\tint len = compat ?\n\t\t\tBITS_TO_LONGS_COMPAT(maxbit) * sizeof(compat_long_t) :\n\t\t\tBITS_TO_LONGS(maxbit) * sizeof(long);\n\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\treturn copy_to_user(p, bits, len) ? -EFAULT : len;\n}\n\nstatic int bits_from_user(unsigned long *bits, unsigned int maxbit,\n\t\t\t  unsigned int maxlen, const void __user *p, int compat)\n{\n\tsize_t chunk_size = compat ? sizeof(compat_long_t) : sizeof(long);\n\tint len;\n\n\tif (maxlen % chunk_size)\n\t\treturn -EINVAL;\n\n\tlen = compat ? BITS_TO_LONGS_COMPAT(maxbit) : BITS_TO_LONGS(maxbit);\n\tlen *= chunk_size;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\treturn copy_from_user(bits, p, len) ? -EFAULT : len;\n}\n\n#endif  \n\n#else\n\nstatic int bits_to_user(unsigned long *bits, unsigned int maxbit,\n\t\t\tunsigned int maxlen, void __user *p, int compat)\n{\n\tint len = BITS_TO_LONGS(maxbit) * sizeof(long);\n\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\treturn copy_to_user(p, bits, len) ? -EFAULT : len;\n}\n\nstatic int bits_from_user(unsigned long *bits, unsigned int maxbit,\n\t\t\t  unsigned int maxlen, const void __user *p, int compat)\n{\n\tint len;\n\n\tif (maxlen % sizeof(long))\n\t\treturn -EINVAL;\n\n\tlen = BITS_TO_LONGS(maxbit) * sizeof(long);\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\treturn copy_from_user(bits, p, len) ? -EFAULT : len;\n}\n\n#endif  \n\nstatic int str_to_user(const char *str, unsigned int maxlen, void __user *p)\n{\n\tint len;\n\n\tif (!str)\n\t\treturn -ENOENT;\n\n\tlen = strlen(str) + 1;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\treturn copy_to_user(p, str, len) ? -EFAULT : len;\n}\n\nstatic int handle_eviocgbit(struct input_dev *dev,\n\t\t\t    unsigned int type, unsigned int size,\n\t\t\t    void __user *p, int compat_mode)\n{\n\tunsigned long *bits;\n\tint len;\n\n\tswitch (type) {\n\n\tcase      0: bits = dev->evbit;  len = EV_MAX;  break;\n\tcase EV_KEY: bits = dev->keybit; len = KEY_MAX; break;\n\tcase EV_REL: bits = dev->relbit; len = REL_MAX; break;\n\tcase EV_ABS: bits = dev->absbit; len = ABS_MAX; break;\n\tcase EV_MSC: bits = dev->mscbit; len = MSC_MAX; break;\n\tcase EV_LED: bits = dev->ledbit; len = LED_MAX; break;\n\tcase EV_SND: bits = dev->sndbit; len = SND_MAX; break;\n\tcase EV_FF:  bits = dev->ffbit;  len = FF_MAX;  break;\n\tcase EV_SW:  bits = dev->swbit;  len = SW_MAX;  break;\n\tdefault: return -EINVAL;\n\t}\n\n\treturn bits_to_user(bits, len, size, p, compat_mode);\n}\n\nstatic int evdev_handle_get_keycode(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke = {\n\t\t.len\t= sizeof(unsigned int),\n\t\t.flags\t= 0,\n\t};\n\tint __user *ip = (int __user *)p;\n\tint error;\n\n\t \n\tif (copy_from_user(ke.scancode, p, sizeof(unsigned int)))\n\t\treturn -EFAULT;\n\n\terror = input_get_keycode(dev, &ke);\n\tif (error)\n\t\treturn error;\n\n\tif (put_user(ke.keycode, ip + 1))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int evdev_handle_get_keycode_v2(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke;\n\tint error;\n\n\tif (copy_from_user(&ke, p, sizeof(ke)))\n\t\treturn -EFAULT;\n\n\terror = input_get_keycode(dev, &ke);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(p, &ke, sizeof(ke)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int evdev_handle_set_keycode(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke = {\n\t\t.len\t= sizeof(unsigned int),\n\t\t.flags\t= 0,\n\t};\n\tint __user *ip = (int __user *)p;\n\n\tif (copy_from_user(ke.scancode, p, sizeof(unsigned int)))\n\t\treturn -EFAULT;\n\n\tif (get_user(ke.keycode, ip + 1))\n\t\treturn -EFAULT;\n\n\treturn input_set_keycode(dev, &ke);\n}\n\nstatic int evdev_handle_set_keycode_v2(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke;\n\n\tif (copy_from_user(&ke, p, sizeof(ke)))\n\t\treturn -EFAULT;\n\n\tif (ke.len > sizeof(ke.scancode))\n\t\treturn -EINVAL;\n\n\treturn input_set_keycode(dev, &ke);\n}\n\n \nstatic int evdev_handle_get_val(struct evdev_client *client,\n\t\t\t\tstruct input_dev *dev, unsigned int type,\n\t\t\t\tunsigned long *bits, unsigned int maxbit,\n\t\t\t\tunsigned int maxlen, void __user *p,\n\t\t\t\tint compat)\n{\n\tint ret;\n\tunsigned long *mem;\n\n\tmem = bitmap_alloc(maxbit, GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&dev->event_lock);\n\tspin_lock(&client->buffer_lock);\n\n\tbitmap_copy(mem, bits, maxbit);\n\n\tspin_unlock(&dev->event_lock);\n\n\t__evdev_flush_queue(client, type);\n\n\tspin_unlock_irq(&client->buffer_lock);\n\n\tret = bits_to_user(mem, maxbit, maxlen, p, compat);\n\tif (ret < 0)\n\t\tevdev_queue_syn_dropped(client);\n\n\tbitmap_free(mem);\n\n\treturn ret;\n}\n\nstatic int evdev_handle_mt_request(struct input_dev *dev,\n\t\t\t\t   unsigned int size,\n\t\t\t\t   int __user *ip)\n{\n\tconst struct input_mt *mt = dev->mt;\n\tunsigned int code;\n\tint max_slots;\n\tint i;\n\n\tif (get_user(code, &ip[0]))\n\t\treturn -EFAULT;\n\tif (!mt || !input_is_mt_value(code))\n\t\treturn -EINVAL;\n\n\tmax_slots = (size - sizeof(__u32)) / sizeof(__s32);\n\tfor (i = 0; i < mt->num_slots && i < max_slots; i++) {\n\t\tint value = input_mt_get_value(&mt->slots[i], code);\n\t\tif (put_user(value, &ip[1 + i]))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int evdev_revoke(struct evdev *evdev, struct evdev_client *client,\n\t\t\tstruct file *file)\n{\n\tclient->revoked = true;\n\tevdev_ungrab(evdev, client);\n\tinput_flush_device(&evdev->handle, file);\n\twake_up_interruptible_poll(&client->wait, EPOLLHUP | EPOLLERR);\n\n\treturn 0;\n}\n\n \nstatic int evdev_set_mask(struct evdev_client *client,\n\t\t\t  unsigned int type,\n\t\t\t  const void __user *codes,\n\t\t\t  u32 codes_size,\n\t\t\t  int compat)\n{\n\tunsigned long flags, *mask, *oldmask;\n\tsize_t cnt;\n\tint error;\n\n\t \n\tcnt = evdev_get_mask_cnt(type);\n\tif (!cnt)\n\t\treturn 0;\n\n\tmask = bitmap_zalloc(cnt, GFP_KERNEL);\n\tif (!mask)\n\t\treturn -ENOMEM;\n\n\terror = bits_from_user(mask, cnt - 1, codes_size, codes, compat);\n\tif (error < 0) {\n\t\tbitmap_free(mask);\n\t\treturn error;\n\t}\n\n\tspin_lock_irqsave(&client->buffer_lock, flags);\n\toldmask = client->evmasks[type];\n\tclient->evmasks[type] = mask;\n\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n\n\tbitmap_free(oldmask);\n\n\treturn 0;\n}\n\n \nstatic int evdev_get_mask(struct evdev_client *client,\n\t\t\t  unsigned int type,\n\t\t\t  void __user *codes,\n\t\t\t  u32 codes_size,\n\t\t\t  int compat)\n{\n\tunsigned long *mask;\n\tsize_t cnt, size, xfer_size;\n\tint i;\n\tint error;\n\n\t \n\tcnt = evdev_get_mask_cnt(type);\n\tsize = sizeof(unsigned long) * BITS_TO_LONGS(cnt);\n\txfer_size = min_t(size_t, codes_size, size);\n\n\tif (cnt > 0) {\n\t\tmask = client->evmasks[type];\n\t\tif (mask) {\n\t\t\terror = bits_to_user(mask, cnt - 1,\n\t\t\t\t\t     xfer_size, codes, compat);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < xfer_size; i++)\n\t\t\t\tif (put_user(0xffU, (u8 __user *)codes + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (xfer_size < codes_size)\n\t\tif (clear_user(codes + xfer_size, codes_size - xfer_size))\n\t\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long evdev_do_ioctl(struct file *file, unsigned int cmd,\n\t\t\t   void __user *p, int compat_mode)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\tstruct input_dev *dev = evdev->handle.dev;\n\tstruct input_absinfo abs;\n\tstruct input_mask mask;\n\tstruct ff_effect effect;\n\tint __user *ip = (int __user *)p;\n\tunsigned int i, t, u, v;\n\tunsigned int size;\n\tint error;\n\n\t \n\tswitch (cmd) {\n\n\tcase EVIOCGVERSION:\n\t\treturn put_user(EV_VERSION, ip);\n\n\tcase EVIOCGID:\n\t\tif (copy_to_user(p, &dev->id, sizeof(struct input_id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase EVIOCGREP:\n\t\tif (!test_bit(EV_REP, dev->evbit))\n\t\t\treturn -ENOSYS;\n\t\tif (put_user(dev->rep[REP_DELAY], ip))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(dev->rep[REP_PERIOD], ip + 1))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase EVIOCSREP:\n\t\tif (!test_bit(EV_REP, dev->evbit))\n\t\t\treturn -ENOSYS;\n\t\tif (get_user(u, ip))\n\t\t\treturn -EFAULT;\n\t\tif (get_user(v, ip + 1))\n\t\t\treturn -EFAULT;\n\n\t\tinput_inject_event(&evdev->handle, EV_REP, REP_DELAY, u);\n\t\tinput_inject_event(&evdev->handle, EV_REP, REP_PERIOD, v);\n\n\t\treturn 0;\n\n\tcase EVIOCRMFF:\n\t\treturn input_ff_erase(dev, (int)(unsigned long) p, file);\n\n\tcase EVIOCGEFFECTS:\n\t\ti = test_bit(EV_FF, dev->evbit) ?\n\t\t\t\tdev->ff->max_effects : 0;\n\t\tif (put_user(i, ip))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase EVIOCGRAB:\n\t\tif (p)\n\t\t\treturn evdev_grab(evdev, client);\n\t\telse\n\t\t\treturn evdev_ungrab(evdev, client);\n\n\tcase EVIOCREVOKE:\n\t\tif (p)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn evdev_revoke(evdev, client, file);\n\n\tcase EVIOCGMASK: {\n\t\tvoid __user *codes_ptr;\n\n\t\tif (copy_from_user(&mask, p, sizeof(mask)))\n\t\t\treturn -EFAULT;\n\n\t\tcodes_ptr = (void __user *)(unsigned long)mask.codes_ptr;\n\t\treturn evdev_get_mask(client,\n\t\t\t\t      mask.type, codes_ptr, mask.codes_size,\n\t\t\t\t      compat_mode);\n\t}\n\n\tcase EVIOCSMASK: {\n\t\tconst void __user *codes_ptr;\n\n\t\tif (copy_from_user(&mask, p, sizeof(mask)))\n\t\t\treturn -EFAULT;\n\n\t\tcodes_ptr = (const void __user *)(unsigned long)mask.codes_ptr;\n\t\treturn evdev_set_mask(client,\n\t\t\t\t      mask.type, codes_ptr, mask.codes_size,\n\t\t\t\t      compat_mode);\n\t}\n\n\tcase EVIOCSCLOCKID:\n\t\tif (copy_from_user(&i, p, sizeof(unsigned int)))\n\t\t\treturn -EFAULT;\n\n\t\treturn evdev_set_clk_type(client, i);\n\n\tcase EVIOCGKEYCODE:\n\t\treturn evdev_handle_get_keycode(dev, p);\n\n\tcase EVIOCSKEYCODE:\n\t\treturn evdev_handle_set_keycode(dev, p);\n\n\tcase EVIOCGKEYCODE_V2:\n\t\treturn evdev_handle_get_keycode_v2(dev, p);\n\n\tcase EVIOCSKEYCODE_V2:\n\t\treturn evdev_handle_set_keycode_v2(dev, p);\n\t}\n\n\tsize = _IOC_SIZE(cmd);\n\n\t \n#define EVIOC_MASK_SIZE(nr)\t((nr) & ~(_IOC_SIZEMASK << _IOC_SIZESHIFT))\n\tswitch (EVIOC_MASK_SIZE(cmd)) {\n\n\tcase EVIOCGPROP(0):\n\t\treturn bits_to_user(dev->propbit, INPUT_PROP_MAX,\n\t\t\t\t    size, p, compat_mode);\n\n\tcase EVIOCGMTSLOTS(0):\n\t\treturn evdev_handle_mt_request(dev, size, ip);\n\n\tcase EVIOCGKEY(0):\n\t\treturn evdev_handle_get_val(client, dev, EV_KEY, dev->key,\n\t\t\t\t\t    KEY_MAX, size, p, compat_mode);\n\n\tcase EVIOCGLED(0):\n\t\treturn evdev_handle_get_val(client, dev, EV_LED, dev->led,\n\t\t\t\t\t    LED_MAX, size, p, compat_mode);\n\n\tcase EVIOCGSND(0):\n\t\treturn evdev_handle_get_val(client, dev, EV_SND, dev->snd,\n\t\t\t\t\t    SND_MAX, size, p, compat_mode);\n\n\tcase EVIOCGSW(0):\n\t\treturn evdev_handle_get_val(client, dev, EV_SW, dev->sw,\n\t\t\t\t\t    SW_MAX, size, p, compat_mode);\n\n\tcase EVIOCGNAME(0):\n\t\treturn str_to_user(dev->name, size, p);\n\n\tcase EVIOCGPHYS(0):\n\t\treturn str_to_user(dev->phys, size, p);\n\n\tcase EVIOCGUNIQ(0):\n\t\treturn str_to_user(dev->uniq, size, p);\n\n\tcase EVIOC_MASK_SIZE(EVIOCSFF):\n\t\tif (input_ff_effect_from_user(p, size, &effect))\n\t\t\treturn -EFAULT;\n\n\t\terror = input_ff_upload(dev, &effect, file);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (put_user(effect.id, &(((struct ff_effect __user *)p)->id)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (_IOC_TYPE(cmd) != 'E')\n\t\treturn -EINVAL;\n\n\tif (_IOC_DIR(cmd) == _IOC_READ) {\n\n\t\tif ((_IOC_NR(cmd) & ~EV_MAX) == _IOC_NR(EVIOCGBIT(0, 0)))\n\t\t\treturn handle_eviocgbit(dev,\n\t\t\t\t\t\t_IOC_NR(cmd) & EV_MAX, size,\n\t\t\t\t\t\tp, compat_mode);\n\n\t\tif ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCGABS(0))) {\n\n\t\t\tif (!dev->absinfo)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tt = _IOC_NR(cmd) & ABS_MAX;\n\t\t\tabs = dev->absinfo[t];\n\n\t\t\tif (copy_to_user(p, &abs, min_t(size_t,\n\t\t\t\t\tsize, sizeof(struct input_absinfo))))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (_IOC_DIR(cmd) == _IOC_WRITE) {\n\n\t\tif ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCSABS(0))) {\n\n\t\t\tif (!dev->absinfo)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tt = _IOC_NR(cmd) & ABS_MAX;\n\n\t\t\tif (copy_from_user(&abs, p, min_t(size_t,\n\t\t\t\t\tsize, sizeof(struct input_absinfo))))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (size < sizeof(struct input_absinfo))\n\t\t\t\tabs.resolution = 0;\n\n\t\t\t \n\t\t\tif (t == ABS_MT_SLOT)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tspin_lock_irq(&dev->event_lock);\n\t\t\tdev->absinfo[t] = abs;\n\t\t\tspin_unlock_irq(&dev->event_lock);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic long evdev_ioctl_handler(struct file *file, unsigned int cmd,\n\t\t\t\tvoid __user *p, int compat_mode)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!evdev->exist || client->revoked) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tretval = evdev_do_ioctl(file, cmd, p, compat_mode);\n\n out:\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}\n\nstatic long evdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn evdev_ioctl_handler(file, cmd, (void __user *)arg, 0);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long evdev_ioctl_compat(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\treturn evdev_ioctl_handler(file, cmd, compat_ptr(arg), 1);\n}\n#endif\n\nstatic const struct file_operations evdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= evdev_read,\n\t.write\t\t= evdev_write,\n\t.poll\t\t= evdev_poll,\n\t.open\t\t= evdev_open,\n\t.release\t= evdev_release,\n\t.unlocked_ioctl\t= evdev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= evdev_ioctl_compat,\n#endif\n\t.fasync\t\t= evdev_fasync,\n\t.llseek\t\t= no_llseek,\n};\n\n \nstatic void evdev_mark_dead(struct evdev *evdev)\n{\n\tmutex_lock(&evdev->mutex);\n\tevdev->exist = false;\n\tmutex_unlock(&evdev->mutex);\n}\n\nstatic void evdev_cleanup(struct evdev *evdev)\n{\n\tstruct input_handle *handle = &evdev->handle;\n\n\tevdev_mark_dead(evdev);\n\tevdev_hangup(evdev);\n\n\t \n\tif (evdev->open) {\n\t\tinput_flush_device(handle, NULL);\n\t\tinput_close_device(handle);\n\t}\n}\n\n \nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\n\t\t\t const struct input_device_id *id)\n{\n\tstruct evdev *evdev;\n\tint minor;\n\tint dev_no;\n\tint error;\n\n\tminor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);\n\tif (minor < 0) {\n\t\terror = minor;\n\t\tpr_err(\"failed to reserve new minor: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tevdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\n\tif (!evdev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_minor;\n\t}\n\n\tINIT_LIST_HEAD(&evdev->client_list);\n\tspin_lock_init(&evdev->client_lock);\n\tmutex_init(&evdev->mutex);\n\tevdev->exist = true;\n\n\tdev_no = minor;\n\t \n\tif (dev_no < EVDEV_MINOR_BASE + EVDEV_MINORS)\n\t\tdev_no -= EVDEV_MINOR_BASE;\n\tdev_set_name(&evdev->dev, \"event%d\", dev_no);\n\n\tevdev->handle.dev = input_get_device(dev);\n\tevdev->handle.name = dev_name(&evdev->dev);\n\tevdev->handle.handler = handler;\n\tevdev->handle.private = evdev;\n\n\tevdev->dev.devt = MKDEV(INPUT_MAJOR, minor);\n\tevdev->dev.class = &input_class;\n\tevdev->dev.parent = &dev->dev;\n\tevdev->dev.release = evdev_free;\n\tdevice_initialize(&evdev->dev);\n\n\terror = input_register_handle(&evdev->handle);\n\tif (error)\n\t\tgoto err_free_evdev;\n\n\tcdev_init(&evdev->cdev, &evdev_fops);\n\n\terror = cdev_device_add(&evdev->cdev, &evdev->dev);\n\tif (error)\n\t\tgoto err_cleanup_evdev;\n\n\treturn 0;\n\n err_cleanup_evdev:\n\tevdev_cleanup(evdev);\n\tinput_unregister_handle(&evdev->handle);\n err_free_evdev:\n\tput_device(&evdev->dev);\n err_free_minor:\n\tinput_free_minor(minor);\n\treturn error;\n}\n\nstatic void evdev_disconnect(struct input_handle *handle)\n{\n\tstruct evdev *evdev = handle->private;\n\n\tcdev_device_del(&evdev->cdev, &evdev->dev);\n\tevdev_cleanup(evdev);\n\tinput_free_minor(MINOR(evdev->dev.devt));\n\tinput_unregister_handle(handle);\n\tput_device(&evdev->dev);\n}\n\nstatic const struct input_device_id evdev_ids[] = {\n\t{ .driver_info = 1 },\t \n\t{ },\t\t\t \n};\n\nMODULE_DEVICE_TABLE(input, evdev_ids);\n\nstatic struct input_handler evdev_handler = {\n\t.event\t\t= evdev_event,\n\t.events\t\t= evdev_events,\n\t.connect\t= evdev_connect,\n\t.disconnect\t= evdev_disconnect,\n\t.legacy_minors\t= true,\n\t.minor\t\t= EVDEV_MINOR_BASE,\n\t.name\t\t= \"evdev\",\n\t.id_table\t= evdev_ids,\n};\n\nstatic int __init evdev_init(void)\n{\n\treturn input_register_handler(&evdev_handler);\n}\n\nstatic void __exit evdev_exit(void)\n{\n\tinput_unregister_handler(&evdev_handler);\n}\n\nmodule_init(evdev_init);\nmodule_exit(evdev_exit);\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input driver event char devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}