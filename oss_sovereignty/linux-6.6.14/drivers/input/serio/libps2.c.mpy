{
  "module_name": "libps2.c",
  "hash_id": "416f3b25d14a6d2f3378cea4e25d84329ba6dbd56c41f8539d017173db5f3f20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/libps2.c",
  "human_readable_source": "\n \n\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/kmsan-checks.h>\n#include <linux/serio.h>\n#include <linux/i8042.h>\n#include <linux/libps2.h>\n\n#define DRIVER_DESC\t\"PS/2 driver library\"\n\n#define PS2_CMD_SETSCALE11\t0x00e6\n#define PS2_CMD_SETRES\t\t0x10e8\n#define PS2_CMD_EX_SETLEDS\t0x20eb\n#define PS2_CMD_SETLEDS\t\t0x10ed\n#define PS2_CMD_GETID\t\t0x02f2\n#define PS2_CMD_SETREP\t\t0x10f3  \n#define PS2_CMD_RESET_BAT\t0x02ff\n\n#define PS2_RET_BAT\t\t0xaa\n#define PS2_RET_ID\t\t0x00\n#define PS2_RET_ACK\t\t0xfa\n#define PS2_RET_NAK\t\t0xfe\n#define PS2_RET_ERR\t\t0xfc\n\n#define PS2_FLAG_ACK\t\tBIT(0)\t \n#define PS2_FLAG_CMD\t\tBIT(1)\t \n#define PS2_FLAG_CMD1\t\tBIT(2)\t \n#define PS2_FLAG_WAITID\t\tBIT(3)\t \n#define PS2_FLAG_NAK\t\tBIT(4)\t \n#define PS2_FLAG_PASS_NOACK\tBIT(5)\t \n\nstatic int ps2_do_sendbyte(struct ps2dev *ps2dev, u8 byte,\n\t\t\t   unsigned int timeout, unsigned int max_attempts)\n\t__releases(&ps2dev->serio->lock) __acquires(&ps2dev->serio->lock)\n{\n\tint attempt = 0;\n\tint error;\n\n\tlockdep_assert_held(&ps2dev->serio->lock);\n\n\tdo {\n\t\tps2dev->nak = 1;\n\t\tps2dev->flags |= PS2_FLAG_ACK;\n\n\t\tserio_continue_rx(ps2dev->serio);\n\n\t\terror = serio_write(ps2dev->serio, byte);\n\t\tif (error)\n\t\t\tdev_dbg(&ps2dev->serio->dev,\n\t\t\t\t\"failed to write %#02x: %d\\n\", byte, error);\n\t\telse\n\t\t\twait_event_timeout(ps2dev->wait,\n\t\t\t\t\t   !(ps2dev->flags & PS2_FLAG_ACK),\n\t\t\t\t\t   msecs_to_jiffies(timeout));\n\n\t\tserio_pause_rx(ps2dev->serio);\n\t} while (ps2dev->nak == PS2_RET_NAK && ++attempt < max_attempts);\n\n\tps2dev->flags &= ~PS2_FLAG_ACK;\n\n\tif (!error) {\n\t\tswitch (ps2dev->nak) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase PS2_RET_NAK:\n\t\t\terror = -EAGAIN;\n\t\t\tbreak;\n\t\tcase PS2_RET_ERR:\n\t\t\terror = -EPROTO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error || attempt > 1)\n\t\tdev_dbg(&ps2dev->serio->dev,\n\t\t\t\"%02x - %d (%x), attempt %d\\n\",\n\t\t\tbyte, error, ps2dev->nak, attempt);\n\n\treturn error;\n}\n\n \nint ps2_sendbyte(struct ps2dev *ps2dev, u8 byte, unsigned int timeout)\n{\n\tint retval;\n\n\tserio_pause_rx(ps2dev->serio);\n\n\tretval = ps2_do_sendbyte(ps2dev, byte, timeout, 1);\n\tdev_dbg(&ps2dev->serio->dev, \"%02x - %x\\n\", byte, ps2dev->nak);\n\n\tserio_continue_rx(ps2dev->serio);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(ps2_sendbyte);\n\n \nvoid ps2_begin_command(struct ps2dev *ps2dev)\n{\n\tstruct mutex *m = ps2dev->serio->ps2_cmd_mutex ?: &ps2dev->cmd_mutex;\n\n\tmutex_lock(m);\n}\nEXPORT_SYMBOL(ps2_begin_command);\n\n \nvoid ps2_end_command(struct ps2dev *ps2dev)\n{\n\tstruct mutex *m = ps2dev->serio->ps2_cmd_mutex ?: &ps2dev->cmd_mutex;\n\n\tmutex_unlock(m);\n}\nEXPORT_SYMBOL(ps2_end_command);\n\n \nvoid ps2_drain(struct ps2dev *ps2dev, size_t maxbytes, unsigned int timeout)\n{\n\tif (maxbytes > sizeof(ps2dev->cmdbuf)) {\n\t\tWARN_ON(1);\n\t\tmaxbytes = sizeof(ps2dev->cmdbuf);\n\t}\n\n\tps2_begin_command(ps2dev);\n\n\tserio_pause_rx(ps2dev->serio);\n\tps2dev->flags = PS2_FLAG_CMD;\n\tps2dev->cmdcnt = maxbytes;\n\tserio_continue_rx(ps2dev->serio);\n\n\twait_event_timeout(ps2dev->wait,\n\t\t\t   !(ps2dev->flags & PS2_FLAG_CMD),\n\t\t\t   msecs_to_jiffies(timeout));\n\n\tps2_end_command(ps2dev);\n}\nEXPORT_SYMBOL(ps2_drain);\n\n \nbool ps2_is_keyboard_id(u8 id_byte)\n{\n\tstatic const u8 keyboard_ids[] = {\n\t\t0xab,\t \n\t\t0xac,\t \n\t\t0x2b,\t \n\t\t0x5d,\t \n\t\t0x60,\t \n\t\t0x47,\t \n\t};\n\n\treturn memchr(keyboard_ids, id_byte, sizeof(keyboard_ids)) != NULL;\n}\nEXPORT_SYMBOL(ps2_is_keyboard_id);\n\n \nstatic int ps2_adjust_timeout(struct ps2dev *ps2dev,\n\t\t\t      unsigned int command, unsigned int timeout)\n{\n\tswitch (command) {\n\tcase PS2_CMD_RESET_BAT:\n\t\t \n\t\tif (timeout > msecs_to_jiffies(100))\n\t\t\ttimeout = msecs_to_jiffies(100);\n\t\tbreak;\n\n\tcase PS2_CMD_GETID:\n\t\t \n\t\tif (ps2dev->cmdbuf[1] == 0xaa) {\n\t\t\tserio_pause_rx(ps2dev->serio);\n\t\t\tps2dev->flags = 0;\n\t\t\tserio_continue_rx(ps2dev->serio);\n\t\t\ttimeout = 0;\n\t\t}\n\n\t\t \n\t\tif (!ps2_is_keyboard_id(ps2dev->cmdbuf[1])) {\n\t\t\tserio_pause_rx(ps2dev->serio);\n\t\t\tps2dev->flags = ps2dev->cmdcnt = 0;\n\t\t\tserio_continue_rx(ps2dev->serio);\n\t\t\ttimeout = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn timeout;\n}\n\n \nint __ps2_command(struct ps2dev *ps2dev, u8 *param, unsigned int command)\n{\n\tunsigned int timeout;\n\tunsigned int send = (command >> 12) & 0xf;\n\tunsigned int receive = (command >> 8) & 0xf;\n\tint rc;\n\tint i;\n\tu8 send_param[16];\n\n\tif (receive > sizeof(ps2dev->cmdbuf)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (send && !param) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(send_param, param, send);\n\n\tserio_pause_rx(ps2dev->serio);\n\n\tps2dev->cmdcnt = receive;\n\n\tswitch (command) {\n\tcase PS2_CMD_GETID:\n\t\t \n\t\tps2dev->flags = PS2_FLAG_WAITID;\n\t\tbreak;\n\n\tcase PS2_CMD_SETLEDS:\n\tcase PS2_CMD_EX_SETLEDS:\n\tcase PS2_CMD_SETREP:\n\t\tps2dev->flags = PS2_FLAG_PASS_NOACK;\n\t\tbreak;\n\n\tdefault:\n\t\tps2dev->flags = 0;\n\t\tbreak;\n\t}\n\n\tif (receive) {\n\t\t \n\t\tps2dev->flags |= PS2_FLAG_CMD | PS2_FLAG_CMD1;\n\t\tif (param)\n\t\t\tfor (i = 0; i < receive; i++)\n\t\t\t\tps2dev->cmdbuf[(receive - 1) - i] = param[i];\n\t}\n\n\t \n\ttimeout = command == PS2_CMD_RESET_BAT ? 1000 : 200;\n\n\trc = ps2_do_sendbyte(ps2dev, command & 0xff, timeout, 2);\n\tif (rc)\n\t\tgoto out_reset_flags;\n\n\t \n\tfor (i = 0; i < send; i++) {\n\t\trc = ps2_do_sendbyte(ps2dev, param[i], 200, 2);\n\t\tif (rc)\n\t\t\tgoto out_reset_flags;\n\t}\n\n\tserio_continue_rx(ps2dev->serio);\n\n\t \n\ttimeout = msecs_to_jiffies(command == PS2_CMD_RESET_BAT ? 4000 : 500);\n\n\ttimeout = wait_event_timeout(ps2dev->wait,\n\t\t\t\t     !(ps2dev->flags & PS2_FLAG_CMD1), timeout);\n\n\tif (ps2dev->cmdcnt && !(ps2dev->flags & PS2_FLAG_CMD1)) {\n\n\t\ttimeout = ps2_adjust_timeout(ps2dev, command, timeout);\n\t\twait_event_timeout(ps2dev->wait,\n\t\t\t\t   !(ps2dev->flags & PS2_FLAG_CMD), timeout);\n\t}\n\n\tserio_pause_rx(ps2dev->serio);\n\n\tif (param) {\n\t\tfor (i = 0; i < receive; i++)\n\t\t\tparam[i] = ps2dev->cmdbuf[(receive - 1) - i];\n\t\tkmsan_unpoison_memory(param, receive);\n\t}\n\n\tif (ps2dev->cmdcnt &&\n\t    (command != PS2_CMD_RESET_BAT || ps2dev->cmdcnt != 1)) {\n\t\trc = -EPROTO;\n\t\tgoto out_reset_flags;\n\t}\n\n\trc = 0;\n\n out_reset_flags:\n\tps2dev->flags = 0;\n\tserio_continue_rx(ps2dev->serio);\n\n\tdev_dbg(&ps2dev->serio->dev,\n\t\t\"%02x [%*ph] - %x/%08lx [%*ph]\\n\",\n\t\tcommand & 0xff, send, send_param,\n\t\tps2dev->nak, ps2dev->flags,\n\t\treceive, param ?: send_param);\n\n\t \n\treturn rc != -EAGAIN ? rc : -EPROTO;\n}\nEXPORT_SYMBOL(__ps2_command);\n\n \nint ps2_command(struct ps2dev *ps2dev, u8 *param, unsigned int command)\n{\n\tint rc;\n\n\tps2_begin_command(ps2dev);\n\trc = __ps2_command(ps2dev, param, command);\n\tps2_end_command(ps2dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(ps2_command);\n\n \nint ps2_sliced_command(struct ps2dev *ps2dev, u8 command)\n{\n\tint i;\n\tint retval;\n\n\tps2_begin_command(ps2dev);\n\n\tretval = __ps2_command(ps2dev, NULL, PS2_CMD_SETSCALE11);\n\tif (retval)\n\t\tgoto out;\n\n\tfor (i = 6; i >= 0; i -= 2) {\n\t\tu8 d = (command >> i) & 3;\n\t\tretval = __ps2_command(ps2dev, &d, PS2_CMD_SETRES);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\nout:\n\tdev_dbg(&ps2dev->serio->dev, \"%02x - %d\\n\", command, retval);\n\tps2_end_command(ps2dev);\n\treturn retval;\n}\nEXPORT_SYMBOL(ps2_sliced_command);\n\n \nvoid ps2_init(struct ps2dev *ps2dev, struct serio *serio,\n\t      ps2_pre_receive_handler_t pre_receive_handler,\n\t      ps2_receive_handler_t receive_handler)\n{\n\tps2dev->pre_receive_handler = pre_receive_handler;\n\tps2dev->receive_handler = receive_handler;\n\n\tmutex_init(&ps2dev->cmd_mutex);\n\tlockdep_set_subclass(&ps2dev->cmd_mutex, serio->depth);\n\tinit_waitqueue_head(&ps2dev->wait);\n\tps2dev->serio = serio;\n\tserio_set_drvdata(serio, ps2dev);\n}\nEXPORT_SYMBOL(ps2_init);\n\n \nstatic void ps2_handle_response(struct ps2dev *ps2dev, u8 data)\n{\n\tif (ps2dev->cmdcnt)\n\t\tps2dev->cmdbuf[--ps2dev->cmdcnt] = data;\n\n\tif (ps2dev->flags & PS2_FLAG_CMD1) {\n\t\tps2dev->flags &= ~PS2_FLAG_CMD1;\n\t\tif (ps2dev->cmdcnt)\n\t\t\twake_up(&ps2dev->wait);\n\t}\n\n\tif (!ps2dev->cmdcnt) {\n\t\tps2dev->flags &= ~PS2_FLAG_CMD;\n\t\twake_up(&ps2dev->wait);\n\t}\n}\n\n \nstatic void ps2_handle_ack(struct ps2dev *ps2dev, u8 data)\n{\n\tswitch (data) {\n\tcase PS2_RET_ACK:\n\t\tps2dev->nak = 0;\n\t\tbreak;\n\n\tcase PS2_RET_NAK:\n\t\tps2dev->flags |= PS2_FLAG_NAK;\n\t\tps2dev->nak = PS2_RET_NAK;\n\t\tbreak;\n\n\tcase PS2_RET_ERR:\n\t\tif (ps2dev->flags & PS2_FLAG_NAK) {\n\t\t\tps2dev->flags &= ~PS2_FLAG_NAK;\n\t\t\tps2dev->nak = PS2_RET_ERR;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\t \n\tcase 0x00:\n\tcase 0x03:\n\tcase 0x04:\n\t\tif (ps2dev->flags & PS2_FLAG_WAITID) {\n\t\t\tps2dev->nak = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tdev_dbg(&ps2dev->serio->dev, \"unexpected %#02x\\n\", data);\n\t\tif (ps2dev->flags & PS2_FLAG_PASS_NOACK)\n\t\t\tps2dev->receive_handler(ps2dev, data);\n\t\tps2dev->flags &= ~(PS2_FLAG_WAITID | PS2_FLAG_PASS_NOACK);\n\t\treturn;\n\t}\n\n\tif (!ps2dev->nak)\n\t\tps2dev->flags &= ~PS2_FLAG_NAK;\n\n\tps2dev->flags &= ~PS2_FLAG_ACK;\n\n\tif (!ps2dev->nak && data != PS2_RET_ACK)\n\t\tps2_handle_response(ps2dev, data);\n\telse\n\t\twake_up(&ps2dev->wait);\n}\n\n \nstatic void ps2_cleanup(struct ps2dev *ps2dev)\n{\n\tunsigned long old_flags = ps2dev->flags;\n\n\t \n\tps2dev->flags &= PS2_FLAG_NAK;\n\n\tif (old_flags & PS2_FLAG_ACK)\n\t\tps2dev->nak = 1;\n\n\tif (old_flags & (PS2_FLAG_ACK | PS2_FLAG_CMD))\n\t\twake_up(&ps2dev->wait);\n}\n\n \nirqreturn_t ps2_interrupt(struct serio *serio, u8 data, unsigned int flags) {\n\tstruct ps2dev *ps2dev = serio_get_drvdata(serio);\n\tenum ps2_disposition rc;\n\n\trc = ps2dev->pre_receive_handler(ps2dev, data, flags);\n\tswitch (rc) {\n\tcase PS2_ERROR:\n\t\tps2_cleanup(ps2dev);\n\t\tbreak;\n\n\tcase PS2_IGNORE:\n\t\tbreak;\n\n\tcase PS2_PROCESS:\n\t\tif (ps2dev->flags & PS2_FLAG_ACK)\n\t\t\tps2_handle_ack(ps2dev, data);\n\t\telse if (ps2dev->flags & PS2_FLAG_CMD)\n\t\t\tps2_handle_response(ps2dev, data);\n\t\telse\n\t\t\tps2dev->receive_handler(ps2dev, data);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(ps2_interrupt);\n\nMODULE_AUTHOR(\"Dmitry Torokhov <dtor@mail.ru>\");\nMODULE_DESCRIPTION(\"PS/2 driver library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}