{
  "module_name": "hp_sdc.c",
  "hash_id": "f327288d35c0abe4308b97f8b08a755ea989a97da2abf04a78d39e12f3ae1b1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/hp_sdc.c",
  "human_readable_source": " \n\n#include <linux/hp_sdc.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/time.h>\n#include <linux/semaphore.h>\n#include <linux/slab.h>\n#include <linux/hil.h>\n#include <asm/io.h>\n\n \n\n#if defined(__hppa__)\n# include <asm/parisc-device.h>\n# define sdc_readb(p)\t\tgsc_readb(p)\n# define sdc_writeb(v,p)\tgsc_writeb((v),(p))\n#elif defined(__mc68000__)\n#include <linux/uaccess.h>\n# define sdc_readb(p)\t\tin_8(p)\n# define sdc_writeb(v,p)\tout_8((p),(v))\n#else\n# error \"HIL is not supported on this platform\"\n#endif\n\n#define PREFIX \"HP SDC: \"\n\nMODULE_AUTHOR(\"Brian S. Julin <bri@calyx.com>\");\nMODULE_DESCRIPTION(\"HP i8042-based SDC Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nEXPORT_SYMBOL(hp_sdc_request_timer_irq);\nEXPORT_SYMBOL(hp_sdc_request_hil_irq);\nEXPORT_SYMBOL(hp_sdc_request_cooked_irq);\n\nEXPORT_SYMBOL(hp_sdc_release_timer_irq);\nEXPORT_SYMBOL(hp_sdc_release_hil_irq);\nEXPORT_SYMBOL(hp_sdc_release_cooked_irq);\n\nEXPORT_SYMBOL(__hp_sdc_enqueue_transaction);\nEXPORT_SYMBOL(hp_sdc_enqueue_transaction);\nEXPORT_SYMBOL(hp_sdc_dequeue_transaction);\n\nstatic bool hp_sdc_disabled;\nmodule_param_named(no_hpsdc, hp_sdc_disabled, bool, 0);\nMODULE_PARM_DESC(no_hpsdc, \"Do not enable HP SDC driver.\");\n\nstatic hp_i8042_sdc\thp_sdc;\t \n\n \nstatic inline uint8_t hp_sdc_status_in8(void)\n{\n\tuint8_t status;\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&hp_sdc.ibf_lock, flags);\n\tstatus = sdc_readb(hp_sdc.status_io);\n\tif (!(status & HP_SDC_STATUS_IBF))\n\t\thp_sdc.ibf = 0;\n\twrite_unlock_irqrestore(&hp_sdc.ibf_lock, flags);\n\n\treturn status;\n}\n\nstatic inline uint8_t hp_sdc_data_in8(void)\n{\n\treturn sdc_readb(hp_sdc.data_io);\n}\n\nstatic inline void hp_sdc_status_out8(uint8_t val)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&hp_sdc.ibf_lock, flags);\n\thp_sdc.ibf = 1;\n\tif ((val & 0xf0) == 0xe0)\n\t\thp_sdc.wi = 0xff;\n\tsdc_writeb(val, hp_sdc.status_io);\n\twrite_unlock_irqrestore(&hp_sdc.ibf_lock, flags);\n}\n\nstatic inline void hp_sdc_data_out8(uint8_t val)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&hp_sdc.ibf_lock, flags);\n\thp_sdc.ibf = 1;\n\tsdc_writeb(val, hp_sdc.data_io);\n\twrite_unlock_irqrestore(&hp_sdc.ibf_lock, flags);\n}\n\n \nstatic inline void hp_sdc_spin_ibf(void)\n{\n\tunsigned long flags;\n\trwlock_t *lock;\n\n\tlock = &hp_sdc.ibf_lock;\n\n\tread_lock_irqsave(lock, flags);\n\tif (!hp_sdc.ibf) {\n\t\tread_unlock_irqrestore(lock, flags);\n\t\treturn;\n\t}\n\tread_unlock(lock);\n\twrite_lock(lock);\n\twhile (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)\n\t\t{ }\n\thp_sdc.ibf = 0;\n\twrite_unlock_irqrestore(lock, flags);\n}\n\n\n \nstatic void hp_sdc_take(int irq, void *dev_id, uint8_t status, uint8_t data)\n{\n\thp_sdc_transaction *curr;\n\n\tread_lock(&hp_sdc.rtq_lock);\n\tif (hp_sdc.rcurr < 0) {\n\t\tread_unlock(&hp_sdc.rtq_lock);\n\t\treturn;\n\t}\n\tcurr = hp_sdc.tq[hp_sdc.rcurr];\n\tread_unlock(&hp_sdc.rtq_lock);\n\n\tcurr->seq[curr->idx++] = status;\n\tcurr->seq[curr->idx++] = data;\n\thp_sdc.rqty -= 2;\n\thp_sdc.rtime = ktime_get();\n\n\tif (hp_sdc.rqty <= 0) {\n\t\t \n\t\tif (curr->seq[curr->actidx] & HP_SDC_ACT_SEMAPHORE)\n\t\t\tif (curr->act.semaphore)\n\t\t\t\tup(curr->act.semaphore);\n\n\t\tif (curr->seq[curr->actidx] & HP_SDC_ACT_CALLBACK)\n\t\t\tif (curr->act.irqhook)\n\t\t\t\tcurr->act.irqhook(irq, dev_id, status, data);\n\n\t\tcurr->actidx = curr->idx;\n\t\tcurr->idx++;\n\t\t \n\t\twrite_lock(&hp_sdc.rtq_lock);\n\t\thp_sdc.rcurr = -1;\n\t\thp_sdc.rqty = 0;\n\t\twrite_unlock(&hp_sdc.rtq_lock);\n\t\ttasklet_schedule(&hp_sdc.task);\n\t}\n}\n\nstatic irqreturn_t hp_sdc_isr(int irq, void *dev_id)\n{\n\tuint8_t status, data;\n\n\tstatus = hp_sdc_status_in8();\n\t \n\tdata =   hp_sdc_data_in8();\n\n\t \n\tif (((status & 0xf1) == 0x51) && data == 0x82)\n\t\treturn IRQ_HANDLED;\n\n\tswitch (status & HP_SDC_STATUS_IRQMASK) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase HP_SDC_STATUS_USERTIMER:\n\tcase HP_SDC_STATUS_PERIODIC:\n\tcase HP_SDC_STATUS_TIMER:\n\t\tread_lock(&hp_sdc.hook_lock);\n\t\tif (hp_sdc.timer != NULL)\n\t\t\thp_sdc.timer(irq, dev_id, status, data);\n\t\tread_unlock(&hp_sdc.hook_lock);\n\t\tbreak;\n\n\tcase HP_SDC_STATUS_REG:\n\t\thp_sdc_take(irq, dev_id, status, data);\n\t\tbreak;\n\n\tcase HP_SDC_STATUS_HILCMD:\n\tcase HP_SDC_STATUS_HILDATA:\n\t\tread_lock(&hp_sdc.hook_lock);\n\t\tif (hp_sdc.hil != NULL)\n\t\t\thp_sdc.hil(irq, dev_id, status, data);\n\t\tread_unlock(&hp_sdc.hook_lock);\n\t\tbreak;\n\n\tcase HP_SDC_STATUS_PUP:\n\t\tread_lock(&hp_sdc.hook_lock);\n\t\tif (hp_sdc.pup != NULL)\n\t\t\thp_sdc.pup(irq, dev_id, status, data);\n\t\telse\n\t\t\tprintk(KERN_INFO PREFIX \"HP SDC reports successful PUP.\\n\");\n\t\tread_unlock(&hp_sdc.hook_lock);\n\t\tbreak;\n\n\tdefault:\n\t\tread_lock(&hp_sdc.hook_lock);\n\t\tif (hp_sdc.cooked != NULL)\n\t\t\thp_sdc.cooked(irq, dev_id, status, data);\n\t\tread_unlock(&hp_sdc.hook_lock);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic irqreturn_t hp_sdc_nmisr(int irq, void *dev_id)\n{\n\tint status;\n\n\tstatus = hp_sdc_status_in8();\n\tprintk(KERN_WARNING PREFIX \"NMI !\\n\");\n\n#if 0\n\tif (status & HP_SDC_NMISTATUS_FHS) {\n\t\tread_lock(&hp_sdc.hook_lock);\n\t\tif (hp_sdc.timer != NULL)\n\t\t\thp_sdc.timer(irq, dev_id, status, 0);\n\t\tread_unlock(&hp_sdc.hook_lock);\n\t} else {\n\t\t \n\t\tprintk(KERN_WARNING PREFIX \"HIL NMI\\n\");\n\t}\n#endif\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nunsigned long hp_sdc_put(void);\n\nstatic void hp_sdc_tasklet(unsigned long foo)\n{\n\twrite_lock_irq(&hp_sdc.rtq_lock);\n\n\tif (hp_sdc.rcurr >= 0) {\n\t\tktime_t now = ktime_get();\n\n\t\tif (ktime_after(now, ktime_add_us(hp_sdc.rtime,\n\t\t\t\t\t\t  HP_SDC_MAX_REG_DELAY))) {\n\t\t\thp_sdc_transaction *curr;\n\t\t\tuint8_t tmp;\n\n\t\t\tcurr = hp_sdc.tq[hp_sdc.rcurr];\n\t\t\t \n\t\t\tprintk(KERN_WARNING PREFIX \"read timeout (%lldus)!\\n\",\n\t\t\t       ktime_us_delta(now, hp_sdc.rtime));\n\t\t\tcurr->idx += hp_sdc.rqty;\n\t\t\thp_sdc.rqty = 0;\n\t\t\ttmp = curr->seq[curr->actidx];\n\t\t\tcurr->seq[curr->actidx] |= HP_SDC_ACT_DEAD;\n\t\t\tif (tmp & HP_SDC_ACT_SEMAPHORE)\n\t\t\t\tif (curr->act.semaphore)\n\t\t\t\t\tup(curr->act.semaphore);\n\n\t\t\tif (tmp & HP_SDC_ACT_CALLBACK) {\n\t\t\t\t \n\t\t\t\tif (curr->act.irqhook)\n\t\t\t\t\tcurr->act.irqhook(0, NULL, 0, 0);\n\t\t\t}\n\n\t\t\tcurr->actidx = curr->idx;\n\t\t\tcurr->idx++;\n\t\t\thp_sdc.rcurr = -1;\n\t\t}\n\t}\n\twrite_unlock_irq(&hp_sdc.rtq_lock);\n\thp_sdc_put();\n}\n\nunsigned long hp_sdc_put(void)\n{\n\thp_sdc_transaction *curr;\n\tuint8_t act;\n\tint idx, curridx;\n\n\tint limit = 0;\n\n\twrite_lock(&hp_sdc.lock);\n\n\t \n\tif (hp_sdc.ibf) {\n\t\thp_sdc_status_in8();\n\t\tif (hp_sdc.ibf)\n\t\t\tgoto finish;\n\t}\n\n anew:\n\t \n\tif (hp_sdc.wcurr < 0)\n\t\thp_sdc.wcurr = 0;\n\tread_lock_irq(&hp_sdc.rtq_lock);\n\tif (hp_sdc.rcurr == hp_sdc.wcurr)\n\t\thp_sdc.wcurr++;\n\tread_unlock_irq(&hp_sdc.rtq_lock);\n\tif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\n\t\thp_sdc.wcurr = 0;\n\tcurridx = hp_sdc.wcurr;\n\n\tif (hp_sdc.tq[curridx] != NULL)\n\t\tgoto start;\n\n\twhile (++curridx != hp_sdc.wcurr) {\n\t\tif (curridx >= HP_SDC_QUEUE_LEN) {\n\t\t\tcurridx = -1;  \n\t\t\tcontinue;\n\t\t}\n\t\tread_lock_irq(&hp_sdc.rtq_lock);\n\t\tif (hp_sdc.rcurr == curridx) {\n\t\t\tread_unlock_irq(&hp_sdc.rtq_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tread_unlock_irq(&hp_sdc.rtq_lock);\n\t\tif (hp_sdc.tq[curridx] != NULL)\n\t\t\tbreak;  \n\t}\n\tif (curridx == hp_sdc.wcurr) {  \n\t\tcurridx = -1;\n\t}\n\thp_sdc.wcurr = curridx;\n\n start:\n\n\t \n\tif (hp_sdc.set_im) {\n\t\thp_sdc_status_out8(hp_sdc.im | HP_SDC_CMD_SET_IM);\n\t\thp_sdc.set_im = 0;\n\t\tgoto finish;\n\t}\n\n\tif (hp_sdc.wcurr == -1)\n\t\tgoto done;\n\n\tcurr = hp_sdc.tq[curridx];\n\tidx = curr->actidx;\n\n\tif (curr->actidx >= curr->endidx) {\n\t\thp_sdc.tq[curridx] = NULL;\n\t\t \n\t\thp_sdc.wcurr++;\n\t\tif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\n\t\t\thp_sdc.wcurr = 0;\n\t\tgoto finish;\n\t}\n\n\tact = curr->seq[idx];\n\tidx++;\n\n\tif (curr->idx >= curr->endidx) {\n\t\tif (act & HP_SDC_ACT_DEALLOC)\n\t\t\tkfree(curr);\n\t\thp_sdc.tq[curridx] = NULL;\n\t\t \n\t\thp_sdc.wcurr++;\n\t\tif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\n\t\t\thp_sdc.wcurr = 0;\n\t\tgoto finish;\n\t}\n\n\twhile (act & HP_SDC_ACT_PRECMD) {\n\t\tif (curr->idx != idx) {\n\t\t\tidx++;\n\t\t\tact &= ~HP_SDC_ACT_PRECMD;\n\t\t\tbreak;\n\t\t}\n\t\thp_sdc_status_out8(curr->seq[idx]);\n\t\tcurr->idx++;\n\t\t \n\t\tif ((act & HP_SDC_ACT_DURING) == HP_SDC_ACT_PRECMD)\n\t\t\tgoto actdone;\n\t\t \n\t\tif (act & HP_SDC_ACT_DATAOUT)\n\t\t\tcurr->idx++;\n\t\tgoto finish;\n\t}\n\tif (act & HP_SDC_ACT_DATAOUT) {\n\t\tint qty;\n\n\t\tqty = curr->seq[idx];\n\t\tidx++;\n\t\tif (curr->idx - idx < qty) {\n\t\t\thp_sdc_data_out8(curr->seq[curr->idx]);\n\t\t\tcurr->idx++;\n\t\t\t \n\t\t\tif (curr->idx - idx >= qty &&\n\t\t\t    (act & HP_SDC_ACT_DURING) == HP_SDC_ACT_DATAOUT)\n\t\t\t\tgoto actdone;\n\t\t\tgoto finish;\n\t\t}\n\t\tidx += qty;\n\t\tact &= ~HP_SDC_ACT_DATAOUT;\n\t} else\n\t    while (act & HP_SDC_ACT_DATAREG) {\n\t\tint mask;\n\t\tuint8_t w7[4];\n\n\t\tmask = curr->seq[idx];\n\t\tif (idx != curr->idx) {\n\t\t\tidx++;\n\t\t\tidx += !!(mask & 1);\n\t\t\tidx += !!(mask & 2);\n\t\t\tidx += !!(mask & 4);\n\t\t\tidx += !!(mask & 8);\n\t\t\tact &= ~HP_SDC_ACT_DATAREG;\n\t\t\tbreak;\n\t\t}\n\n\t\tw7[0] = (mask & 1) ? curr->seq[++idx] : hp_sdc.r7[0];\n\t\tw7[1] = (mask & 2) ? curr->seq[++idx] : hp_sdc.r7[1];\n\t\tw7[2] = (mask & 4) ? curr->seq[++idx] : hp_sdc.r7[2];\n\t\tw7[3] = (mask & 8) ? curr->seq[++idx] : hp_sdc.r7[3];\n\n\t\tif (hp_sdc.wi > 0x73 || hp_sdc.wi < 0x70 ||\n\t\t    w7[hp_sdc.wi - 0x70] == hp_sdc.r7[hp_sdc.wi - 0x70]) {\n\t\t\tint i = 0;\n\n\t\t\t \n\t\t\twhile (i < 4 && w7[i] == hp_sdc.r7[i])\n\t\t\t\ti++;\n\n\t\t\tif (i < 4) {\n\t\t\t\thp_sdc_status_out8(HP_SDC_CMD_SET_D0 + i);\n\t\t\t\thp_sdc.wi = 0x70 + i;\n\t\t\t\tgoto finish;\n\t\t\t}\n\n\t\t\tidx++;\n\t\t\tif ((act & HP_SDC_ACT_DURING) == HP_SDC_ACT_DATAREG)\n\t\t\t\tgoto actdone;\n\n\t\t\tcurr->idx = idx;\n\t\t\tact &= ~HP_SDC_ACT_DATAREG;\n\t\t\tbreak;\n\t\t}\n\n\t\thp_sdc_data_out8(w7[hp_sdc.wi - 0x70]);\n\t\thp_sdc.r7[hp_sdc.wi - 0x70] = w7[hp_sdc.wi - 0x70];\n\t\thp_sdc.wi++;  \n\t\t{\n\t\t\tint i = 0;\n\n\t\t\twhile ((i < 4) && w7[i] == hp_sdc.r7[i])\n\t\t\t\ti++;\n\t\t\tif (i >= 4) {\n\t\t\t\tcurr->idx = idx + 1;\n\t\t\t\tif ((act & HP_SDC_ACT_DURING) ==\n\t\t\t\t    HP_SDC_ACT_DATAREG)\n\t\t\t\t\tgoto actdone;\n\t\t\t}\n\t\t}\n\t\tgoto finish;\n\t}\n\t \n\tread_lock_irq(&hp_sdc.rtq_lock);\n\tif (hp_sdc.rcurr >= 0) {\n\t\tread_unlock_irq(&hp_sdc.rtq_lock);\n\t\tgoto finish;\n\t}\n\tread_unlock_irq(&hp_sdc.rtq_lock);\n\n\n\tif (act & HP_SDC_ACT_POSTCMD) {\n\t\tuint8_t postcmd;\n\n\t\t \n\t\tpostcmd = curr->seq[idx];\n\t\tcurr->idx++;\n\t\tif (act & HP_SDC_ACT_DATAIN) {\n\n\t\t\t \n\t\t\thp_sdc.rqty = curr->seq[curr->idx];\n\t\t\thp_sdc.rtime = ktime_get();\n\t\t\tcurr->idx++;\n\t\t\t \n\t\t\twrite_lock_irq(&hp_sdc.rtq_lock);\n\t\t\thp_sdc.rcurr = curridx;\n\t\t\twrite_unlock_irq(&hp_sdc.rtq_lock);\n\t\t\thp_sdc_status_out8(postcmd);\n\t\t\tgoto finish;\n\t\t}\n\t\thp_sdc_status_out8(postcmd);\n\t\tgoto actdone;\n\t}\n\n actdone:\n\tif (act & HP_SDC_ACT_SEMAPHORE)\n\t\tup(curr->act.semaphore);\n\telse if (act & HP_SDC_ACT_CALLBACK)\n\t\tcurr->act.irqhook(0,NULL,0,0);\n\n\tif (curr->idx >= curr->endidx) {  \n\t\tif (act & HP_SDC_ACT_DEALLOC)\n\t\t\tkfree(curr);\n\t\thp_sdc.tq[curridx] = NULL;\n\t} else {\n\t\tcurr->actidx = idx + 1;\n\t\tcurr->idx = idx + 2;\n\t}\n\t \n\thp_sdc.wcurr++;\n\tif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\n\t\thp_sdc.wcurr = 0;\n\n finish:\n\t \n\tif (!hp_sdc.ibf && limit++ < 20)\n\t\tgoto anew;\n\n done:\n\tif (hp_sdc.wcurr >= 0)\n\t\ttasklet_schedule(&hp_sdc.task);\n\twrite_unlock(&hp_sdc.lock);\n\n\treturn 0;\n}\n\n \nint __hp_sdc_enqueue_transaction(hp_sdc_transaction *this)\n{\n\tint i;\n\n\tif (this == NULL) {\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < HP_SDC_QUEUE_LEN; i++)\n\t\tif (hp_sdc.tq[i] == this)\n\t\t\tgoto fail;\n\n\tthis->actidx = 0;\n\tthis->idx = 1;\n\n\t \n\tfor (i = 0; i < HP_SDC_QUEUE_LEN; i++)\n\t\tif (hp_sdc.tq[i] == NULL) {\n\t\t\thp_sdc.tq[i] = this;\n\t\t\ttasklet_schedule(&hp_sdc.task);\n\t\t\treturn 0;\n\t\t}\n\n\tprintk(KERN_WARNING PREFIX \"No free slot to add transaction.\\n\");\n\treturn -EBUSY;\n\n fail:\n\tprintk(KERN_WARNING PREFIX \"Transaction add failed: transaction already queued?\\n\");\n\treturn -EINVAL;\n}\n\nint hp_sdc_enqueue_transaction(hp_sdc_transaction *this) {\n\tunsigned long flags;\n\tint ret;\n\n\twrite_lock_irqsave(&hp_sdc.lock, flags);\n\tret = __hp_sdc_enqueue_transaction(this);\n\twrite_unlock_irqrestore(&hp_sdc.lock,flags);\n\n\treturn ret;\n}\n\nint hp_sdc_dequeue_transaction(hp_sdc_transaction *this)\n{\n\tunsigned long flags;\n\tint i;\n\n\twrite_lock_irqsave(&hp_sdc.lock, flags);\n\n\t \n\n\tfor (i = 0; i < HP_SDC_QUEUE_LEN; i++)\n\t\tif (hp_sdc.tq[i] == this)\n\t\t\thp_sdc.tq[i] = NULL;\n\n\twrite_unlock_irqrestore(&hp_sdc.lock, flags);\n\treturn 0;\n}\n\n\n\n \nint hp_sdc_request_timer_irq(hp_sdc_irqhook *callback)\n{\n\tif (callback == NULL || hp_sdc.dev == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock_irq(&hp_sdc.hook_lock);\n\tif (hp_sdc.timer != NULL) {\n\t\twrite_unlock_irq(&hp_sdc.hook_lock);\n\t\treturn -EBUSY;\n\t}\n\n\thp_sdc.timer = callback;\n\t \n\thp_sdc.im &= ~HP_SDC_IM_FH;\n        hp_sdc.im &= ~HP_SDC_IM_PT;\n\thp_sdc.im &= ~HP_SDC_IM_TIMERS;\n\thp_sdc.set_im = 1;\n\twrite_unlock_irq(&hp_sdc.hook_lock);\n\n\ttasklet_schedule(&hp_sdc.task);\n\n\treturn 0;\n}\n\nint hp_sdc_request_hil_irq(hp_sdc_irqhook *callback)\n{\n\tif (callback == NULL || hp_sdc.dev == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock_irq(&hp_sdc.hook_lock);\n\tif (hp_sdc.hil != NULL) {\n\t\twrite_unlock_irq(&hp_sdc.hook_lock);\n\t\treturn -EBUSY;\n\t}\n\n\thp_sdc.hil = callback;\n\thp_sdc.im &= ~(HP_SDC_IM_HIL | HP_SDC_IM_RESET);\n\thp_sdc.set_im = 1;\n\twrite_unlock_irq(&hp_sdc.hook_lock);\n\n\ttasklet_schedule(&hp_sdc.task);\n\n\treturn 0;\n}\n\nint hp_sdc_request_cooked_irq(hp_sdc_irqhook *callback)\n{\n\tif (callback == NULL || hp_sdc.dev == NULL)\n\t\treturn -EINVAL;\n\n\twrite_lock_irq(&hp_sdc.hook_lock);\n\tif (hp_sdc.cooked != NULL) {\n\t\twrite_unlock_irq(&hp_sdc.hook_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\thp_sdc.cooked = callback;\n\thp_sdc.im &= ~(HP_SDC_IM_HIL | HP_SDC_IM_RESET);\n\thp_sdc.set_im = 1;\n\twrite_unlock_irq(&hp_sdc.hook_lock);\n\n\ttasklet_schedule(&hp_sdc.task);\n\n\treturn 0;\n}\n\nint hp_sdc_release_timer_irq(hp_sdc_irqhook *callback)\n{\n\twrite_lock_irq(&hp_sdc.hook_lock);\n\tif ((callback != hp_sdc.timer) ||\n\t    (hp_sdc.timer == NULL)) {\n\t\twrite_unlock_irq(&hp_sdc.hook_lock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thp_sdc.timer = NULL;\n\thp_sdc.im |= HP_SDC_IM_TIMERS;\n\thp_sdc.im |= HP_SDC_IM_FH;\n\thp_sdc.im |= HP_SDC_IM_PT;\n\thp_sdc.set_im = 1;\n\twrite_unlock_irq(&hp_sdc.hook_lock);\n\ttasklet_schedule(&hp_sdc.task);\n\n\treturn 0;\n}\n\nint hp_sdc_release_hil_irq(hp_sdc_irqhook *callback)\n{\n\twrite_lock_irq(&hp_sdc.hook_lock);\n\tif ((callback != hp_sdc.hil) ||\n\t    (hp_sdc.hil == NULL)) {\n\t\twrite_unlock_irq(&hp_sdc.hook_lock);\n\t\treturn -EINVAL;\n\t}\n\n\thp_sdc.hil = NULL;\n\t \n\tif(hp_sdc.cooked == NULL) {\n\t\thp_sdc.im |= (HP_SDC_IM_HIL | HP_SDC_IM_RESET);\n\t\thp_sdc.set_im = 1;\n\t}\n\twrite_unlock_irq(&hp_sdc.hook_lock);\n\ttasklet_schedule(&hp_sdc.task);\n\n\treturn 0;\n}\n\nint hp_sdc_release_cooked_irq(hp_sdc_irqhook *callback)\n{\n\twrite_lock_irq(&hp_sdc.hook_lock);\n\tif ((callback != hp_sdc.cooked) ||\n\t    (hp_sdc.cooked == NULL)) {\n\t\twrite_unlock_irq(&hp_sdc.hook_lock);\n\t\treturn -EINVAL;\n\t}\n\n\thp_sdc.cooked = NULL;\n\t \n\tif(hp_sdc.hil == NULL) {\n\t\thp_sdc.im |= (HP_SDC_IM_HIL | HP_SDC_IM_RESET);\n\t\thp_sdc.set_im = 1;\n\t}\n\twrite_unlock_irq(&hp_sdc.hook_lock);\n\ttasklet_schedule(&hp_sdc.task);\n\n\treturn 0;\n}\n\n \n\nstatic void hp_sdc_kicker(struct timer_list *unused)\n{\n\ttasklet_schedule(&hp_sdc.task);\n\t \n\tmod_timer(&hp_sdc.kicker, jiffies + HZ);\n}\n\n \n\n#if defined(__hppa__)\n\nstatic const struct parisc_device_id hp_sdc_tbl[] __initconst = {\n\t{\n\t\t.hw_type =\tHPHW_FIO,\n\t\t.hversion_rev =\tHVERSION_REV_ANY_ID,\n\t\t.hversion =\tHVERSION_ANY_ID,\n\t\t.sversion =\t0x73,\n\t },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, hp_sdc_tbl);\n\nstatic int __init hp_sdc_init_hppa(struct parisc_device *d);\nstatic struct delayed_work moduleloader_work;\n\nstatic struct parisc_driver hp_sdc_driver __refdata = {\n\t.name =\t\t\"hp_sdc\",\n\t.id_table =\thp_sdc_tbl,\n\t.probe =\thp_sdc_init_hppa,\n};\n\n#endif  \n\nstatic int __init hp_sdc_init(void)\n{\n\tchar *errstr;\n\thp_sdc_transaction t_sync;\n\tuint8_t ts_sync[6];\n\tstruct semaphore s_sync;\n\n\trwlock_init(&hp_sdc.lock);\n\trwlock_init(&hp_sdc.ibf_lock);\n\trwlock_init(&hp_sdc.rtq_lock);\n\trwlock_init(&hp_sdc.hook_lock);\n\n\thp_sdc.timer\t\t= NULL;\n\thp_sdc.hil\t\t= NULL;\n\thp_sdc.pup\t\t= NULL;\n\thp_sdc.cooked\t\t= NULL;\n\thp_sdc.im\t\t= HP_SDC_IM_MASK;   \n\thp_sdc.set_im\t\t= 1;\n\thp_sdc.wi\t\t= 0xff;\n\thp_sdc.r7[0]\t\t= 0xff;\n\thp_sdc.r7[1]\t\t= 0xff;\n\thp_sdc.r7[2]\t\t= 0xff;\n\thp_sdc.r7[3]\t\t= 0xff;\n\thp_sdc.ibf\t\t= 1;\n\n\tmemset(&hp_sdc.tq, 0, sizeof(hp_sdc.tq));\n\n\thp_sdc.wcurr\t\t= -1;\n        hp_sdc.rcurr\t\t= -1;\n\thp_sdc.rqty\t\t= 0;\n\n\thp_sdc.dev_err = -ENODEV;\n\n\terrstr = \"IO not found for\";\n\tif (!hp_sdc.base_io)\n\t\tgoto err0;\n\n\terrstr = \"IRQ not found for\";\n\tif (!hp_sdc.irq)\n\t\tgoto err0;\n\n\thp_sdc.dev_err = -EBUSY;\n\n#if defined(__hppa__)\n\terrstr = \"IO not available for\";\n        if (request_region(hp_sdc.data_io, 2, hp_sdc_driver.name))\n\t\tgoto err0;\n#endif\n\n\terrstr = \"IRQ not available for\";\n\tif (request_irq(hp_sdc.irq, &hp_sdc_isr, IRQF_SHARED,\n\t\t\t\"HP SDC\", &hp_sdc))\n\t\tgoto err1;\n\n\terrstr = \"NMI not available for\";\n\tif (request_irq(hp_sdc.nmi, &hp_sdc_nmisr, IRQF_SHARED,\n\t\t\t\"HP SDC NMI\", &hp_sdc))\n\t\tgoto err2;\n\n\tpr_info(PREFIX \"HP SDC at 0x%08lx, IRQ %d (NMI IRQ %d)\\n\",\n\t       hp_sdc.base_io, hp_sdc.irq, hp_sdc.nmi);\n\n\thp_sdc_status_in8();\n\thp_sdc_data_in8();\n\n\ttasklet_init(&hp_sdc.task, hp_sdc_tasklet, 0);\n\n\t \n\tt_sync.actidx\t= 0;\n\tt_sync.idx\t= 1;\n\tt_sync.endidx\t= 6;\n\tt_sync.seq\t= ts_sync;\n\tts_sync[0]\t= HP_SDC_ACT_DATAREG | HP_SDC_ACT_SEMAPHORE;\n\tts_sync[1]\t= 0x0f;\n\tts_sync[2] = ts_sync[3]\t= ts_sync[4] = ts_sync[5] = 0;\n\tt_sync.act.semaphore = &s_sync;\n\tsema_init(&s_sync, 0);\n\thp_sdc_enqueue_transaction(&t_sync);\n\tdown(&s_sync);  \n\n\t \n\ttimer_setup(&hp_sdc.kicker, hp_sdc_kicker, 0);\n\thp_sdc.kicker.expires = jiffies + HZ;\n\tadd_timer(&hp_sdc.kicker);\n\n\thp_sdc.dev_err = 0;\n\treturn 0;\n err2:\n\tfree_irq(hp_sdc.irq, &hp_sdc);\n err1:\n\trelease_region(hp_sdc.data_io, 2);\n err0:\n\tprintk(KERN_WARNING PREFIX \": %s SDC IO=0x%p IRQ=0x%x NMI=0x%x\\n\",\n\t\terrstr, (void *)hp_sdc.base_io, hp_sdc.irq, hp_sdc.nmi);\n\thp_sdc.dev = NULL;\n\n\treturn hp_sdc.dev_err;\n}\n\n#if defined(__hppa__)\n\nstatic void request_module_delayed(struct work_struct *work)\n{\n\trequest_module(\"hp_sdc_mlc\");\n}\n\nstatic int __init hp_sdc_init_hppa(struct parisc_device *d)\n{\n\tint ret;\n\n\tif (!d)\n\t\treturn 1;\n\tif (hp_sdc.dev != NULL)\n\t\treturn 1;\t \n\n\thp_sdc.dev\t\t= d;\n\thp_sdc.irq\t\t= d->irq;\n\thp_sdc.nmi\t\t= d->aux_irq;\n\thp_sdc.base_io\t\t= d->hpa.start;\n\thp_sdc.data_io\t\t= d->hpa.start + 0x800;\n\thp_sdc.status_io\t= d->hpa.start + 0x801;\n\n\tINIT_DELAYED_WORK(&moduleloader_work, request_module_delayed);\n\n\tret = hp_sdc_init();\n\t \n\tif (!ret)\n\t\tschedule_delayed_work(&moduleloader_work,\n\t\t\tmsecs_to_jiffies(2000));\n\n\treturn ret;\n}\n\n#endif  \n\nstatic void hp_sdc_exit(void)\n{\n\t \n\tif (!hp_sdc.dev)\n\t\treturn;\n\n\twrite_lock_irq(&hp_sdc.lock);\n\n\t \n\thp_sdc_spin_ibf();\n\tsdc_writeb(HP_SDC_CMD_SET_IM | HP_SDC_IM_MASK, hp_sdc.status_io);\n\n\t \n\thp_sdc_spin_ibf();\n\n\tfree_irq(hp_sdc.nmi, &hp_sdc);\n\tfree_irq(hp_sdc.irq, &hp_sdc);\n\twrite_unlock_irq(&hp_sdc.lock);\n\n\tdel_timer_sync(&hp_sdc.kicker);\n\n\ttasklet_kill(&hp_sdc.task);\n\n#if defined(__hppa__)\n\tcancel_delayed_work_sync(&moduleloader_work);\n\tif (unregister_parisc_driver(&hp_sdc_driver))\n\t\tprintk(KERN_WARNING PREFIX \"Error unregistering HP SDC\");\n#endif\n}\n\nstatic int __init hp_sdc_register(void)\n{\n\thp_sdc_transaction tq_init;\n\tuint8_t tq_init_seq[5];\n\tstruct semaphore tq_init_sem;\n#if defined(__mc68000__)\n\tunsigned char i;\n#endif\n\n\tif (hp_sdc_disabled) {\n\t\tprintk(KERN_WARNING PREFIX \"HP SDC driver disabled by no_hpsdc=1.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thp_sdc.dev = NULL;\n\thp_sdc.dev_err = 0;\n#if defined(__hppa__)\n\tif (register_parisc_driver(&hp_sdc_driver)) {\n\t\tprintk(KERN_WARNING PREFIX \"Error registering SDC with system bus tree.\\n\");\n\t\treturn -ENODEV;\n\t}\n#elif defined(__mc68000__)\n\tif (!MACH_IS_HP300)\n\t    return -ENODEV;\n\n\thp_sdc.irq\t = 1;\n\thp_sdc.nmi\t = 7;\n\thp_sdc.base_io\t = (unsigned long) 0xf0428000;\n\thp_sdc.data_io\t = (unsigned long) hp_sdc.base_io + 1;\n\thp_sdc.status_io = (unsigned long) hp_sdc.base_io + 3;\n\tif (!copy_from_kernel_nofault(&i, (unsigned char *)hp_sdc.data_io, 1))\n\t\thp_sdc.dev = (void *)1;\n\thp_sdc.dev_err   = hp_sdc_init();\n#endif\n\tif (hp_sdc.dev == NULL) {\n\t\tprintk(KERN_WARNING PREFIX \"No SDC found.\\n\");\n\t\treturn hp_sdc.dev_err;\n\t}\n\n\tsema_init(&tq_init_sem, 0);\n\n\ttq_init.actidx\t\t= 0;\n\ttq_init.idx\t\t= 1;\n\ttq_init.endidx\t\t= 5;\n\ttq_init.seq\t\t= tq_init_seq;\n\ttq_init.act.semaphore\t= &tq_init_sem;\n\n\ttq_init_seq[0] =\n\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN | HP_SDC_ACT_SEMAPHORE;\n\ttq_init_seq[1] = HP_SDC_CMD_READ_KCC;\n\ttq_init_seq[2] = 1;\n\ttq_init_seq[3] = 0;\n\ttq_init_seq[4] = 0;\n\n\thp_sdc_enqueue_transaction(&tq_init);\n\n\tdown(&tq_init_sem);\n\tup(&tq_init_sem);\n\n\tif ((tq_init_seq[0] & HP_SDC_ACT_DEAD) == HP_SDC_ACT_DEAD) {\n\t\tprintk(KERN_WARNING PREFIX \"Error reading config byte.\\n\");\n\t\thp_sdc_exit();\n\t\treturn -ENODEV;\n\t}\n\thp_sdc.r11 = tq_init_seq[4];\n\tif (hp_sdc.r11 & HP_SDC_CFG_NEW) {\n\t\tconst char *str;\n\t\tprintk(KERN_INFO PREFIX \"New style SDC\\n\");\n\t\ttq_init_seq[1] = HP_SDC_CMD_READ_XTD;\n\t\ttq_init.actidx\t\t= 0;\n\t\ttq_init.idx\t\t= 1;\n\t\tdown(&tq_init_sem);\n\t\thp_sdc_enqueue_transaction(&tq_init);\n\t\tdown(&tq_init_sem);\n\t\tup(&tq_init_sem);\n\t\tif ((tq_init_seq[0] & HP_SDC_ACT_DEAD) == HP_SDC_ACT_DEAD) {\n\t\t\tprintk(KERN_WARNING PREFIX \"Error reading extended config byte.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\thp_sdc.r7e = tq_init_seq[4];\n\t\tHP_SDC_XTD_REV_STRINGS(hp_sdc.r7e & HP_SDC_XTD_REV, str)\n\t\tprintk(KERN_INFO PREFIX \"Revision: %s\\n\", str);\n\t\tif (hp_sdc.r7e & HP_SDC_XTD_BEEPER)\n\t\t\tprintk(KERN_INFO PREFIX \"TI SN76494 beeper present\\n\");\n\t\tif (hp_sdc.r7e & HP_SDC_XTD_BBRTC)\n\t\t\tprintk(KERN_INFO PREFIX \"OKI MSM-58321 BBRTC present\\n\");\n\t\tprintk(KERN_INFO PREFIX \"Spunking the self test register to force PUP \"\n\t\t       \"on next firmware reset.\\n\");\n\t\ttq_init_seq[0] = HP_SDC_ACT_PRECMD |\n\t\t\tHP_SDC_ACT_DATAOUT | HP_SDC_ACT_SEMAPHORE;\n\t\ttq_init_seq[1] = HP_SDC_CMD_SET_STR;\n\t\ttq_init_seq[2] = 1;\n\t\ttq_init_seq[3] = 0;\n\t\ttq_init.actidx\t\t= 0;\n\t\ttq_init.idx\t\t= 1;\n\t\ttq_init.endidx\t\t= 4;\n\t\tdown(&tq_init_sem);\n\t\thp_sdc_enqueue_transaction(&tq_init);\n\t\tdown(&tq_init_sem);\n\t\tup(&tq_init_sem);\n\t} else\n\t\tprintk(KERN_INFO PREFIX \"Old style SDC (1820-%s).\\n\",\n\t\t       (hp_sdc.r11 & HP_SDC_CFG_REV) ? \"3300\" : \"2564/3087\");\n\n        return 0;\n}\n\nmodule_init(hp_sdc_register);\nmodule_exit(hp_sdc_exit);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}