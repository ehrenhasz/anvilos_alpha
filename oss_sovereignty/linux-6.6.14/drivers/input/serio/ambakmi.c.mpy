{
  "module_name": "ambakmi.c",
  "hash_id": "e01ad452fe7b0b144cbf36d4a21ef7ed3ab296afdf521263795cab76ed724119",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/ambakmi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/amba/bus.h>\n#include <linux/amba/kmi.h>\n#include <linux/clk.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#define KMI_BASE\t(kmi->base)\n\nstruct amba_kmi_port {\n\tstruct serio\t\t*io;\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*base;\n\tunsigned int\t\tirq;\n\tunsigned int\t\tdivisor;\n\tunsigned int\t\topen;\n};\n\nstatic irqreturn_t amba_kmi_int(int irq, void *dev_id)\n{\n\tstruct amba_kmi_port *kmi = dev_id;\n\tunsigned int status = readb(KMIIR);\n\tint handled = IRQ_NONE;\n\n\twhile (status & KMIIR_RXINTR) {\n\t\tserio_interrupt(kmi->io, readb(KMIDATA), 0);\n\t\tstatus = readb(KMIIR);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\treturn handled;\n}\n\nstatic int amba_kmi_write(struct serio *io, unsigned char val)\n{\n\tstruct amba_kmi_port *kmi = io->port_data;\n\tunsigned int timeleft = 10000;  \n\n\twhile ((readb(KMISTAT) & KMISTAT_TXEMPTY) == 0 && --timeleft)\n\t\tudelay(10);\n\n\tif (timeleft)\n\t\twriteb(val, KMIDATA);\n\n\treturn timeleft ? 0 : SERIO_TIMEOUT;\n}\n\nstatic int amba_kmi_open(struct serio *io)\n{\n\tstruct amba_kmi_port *kmi = io->port_data;\n\tunsigned int divisor;\n\tint ret;\n\n\tret = clk_prepare_enable(kmi->clk);\n\tif (ret)\n\t\tgoto out;\n\n\tdivisor = clk_get_rate(kmi->clk) / 8000000 - 1;\n\twriteb(divisor, KMICLKDIV);\n\twriteb(KMICR_EN, KMICR);\n\n\tret = request_irq(kmi->irq, amba_kmi_int, IRQF_SHARED, \"kmi-pl050\",\n\t\t\t  kmi);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"kmi: failed to claim IRQ%d\\n\", kmi->irq);\n\t\twriteb(0, KMICR);\n\t\tgoto clk_disable;\n\t}\n\n\twriteb(KMICR_EN | KMICR_RXINTREN, KMICR);\n\n\treturn 0;\n\n clk_disable:\n\tclk_disable_unprepare(kmi->clk);\n out:\n\treturn ret;\n}\n\nstatic void amba_kmi_close(struct serio *io)\n{\n\tstruct amba_kmi_port *kmi = io->port_data;\n\n\twriteb(0, KMICR);\n\n\tfree_irq(kmi->irq, kmi);\n\tclk_disable_unprepare(kmi->clk);\n}\n\nstatic int amba_kmi_probe(struct amba_device *dev,\n\tconst struct amba_id *id)\n{\n\tstruct amba_kmi_port *kmi;\n\tstruct serio *io;\n\tint ret;\n\n\tret = amba_request_regions(dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tkmi = kzalloc(sizeof(struct amba_kmi_port), GFP_KERNEL);\n\tio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!kmi || !io) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\n\tio->id.type\t= SERIO_8042;\n\tio->write\t= amba_kmi_write;\n\tio->open\t= amba_kmi_open;\n\tio->close\t= amba_kmi_close;\n\tstrscpy(io->name, dev_name(&dev->dev), sizeof(io->name));\n\tstrscpy(io->phys, dev_name(&dev->dev), sizeof(io->phys));\n\tio->port_data\t= kmi;\n\tio->dev.parent\t= &dev->dev;\n\n\tkmi->io\t\t= io;\n\tkmi->base\t= ioremap(dev->res.start, resource_size(&dev->res));\n\tif (!kmi->base) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkmi->clk = clk_get(&dev->dev, \"KMIREFCLK\");\n\tif (IS_ERR(kmi->clk)) {\n\t\tret = PTR_ERR(kmi->clk);\n\t\tgoto unmap;\n\t}\n\n\tkmi->irq = dev->irq[0];\n\tamba_set_drvdata(dev, kmi);\n\n\tserio_register_port(kmi->io);\n\treturn 0;\n\n unmap:\n\tiounmap(kmi->base);\n out:\n\tkfree(kmi);\n\tkfree(io);\n\tamba_release_regions(dev);\n\treturn ret;\n}\n\nstatic void amba_kmi_remove(struct amba_device *dev)\n{\n\tstruct amba_kmi_port *kmi = amba_get_drvdata(dev);\n\n\tserio_unregister_port(kmi->io);\n\tclk_put(kmi->clk);\n\tiounmap(kmi->base);\n\tkfree(kmi);\n\tamba_release_regions(dev);\n}\n\nstatic int amba_kmi_resume(struct device *dev)\n{\n\tstruct amba_kmi_port *kmi = dev_get_drvdata(dev);\n\n\t \n\tserio_reconnect(kmi->io);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(amba_kmi_dev_pm_ops, NULL, amba_kmi_resume);\n\nstatic const struct amba_id amba_kmi_idtable[] = {\n\t{\n\t\t.id\t= 0x00041050,\n\t\t.mask\t= 0x000fffff,\n\t},\n\t{ 0, 0 }\n};\n\nMODULE_DEVICE_TABLE(amba, amba_kmi_idtable);\n\nstatic struct amba_driver ambakmi_driver = {\n\t.drv\t\t= {\n\t\t.name\t= \"kmi-pl050\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_sleep_ptr(&amba_kmi_dev_pm_ops),\n\t},\n\t.id_table\t= amba_kmi_idtable,\n\t.probe\t\t= amba_kmi_probe,\n\t.remove\t\t= amba_kmi_remove,\n};\n\nmodule_amba_driver(ambakmi_driver);\n\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"AMBA KMI controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}