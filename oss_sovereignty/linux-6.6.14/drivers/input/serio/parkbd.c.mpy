{
  "module_name": "parkbd.c",
  "hash_id": "f88764c4ace6986970f75aca207a33e078d7f54ab59dea2c7f03e192b3d95298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/parkbd.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/module.h>\n#include <linux/parport.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/serio.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Parallel port to Keyboard port adapter driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int parkbd_pp_no;\nmodule_param_named(port, parkbd_pp_no, int, 0);\nMODULE_PARM_DESC(port, \"Parallel port the adapter is connected to (default is 0)\");\n\nstatic unsigned int parkbd_mode = SERIO_8042;\nmodule_param_named(mode, parkbd_mode, uint, 0);\nMODULE_PARM_DESC(mode, \"Mode of operation: XT = 0/AT = 1 (default)\");\n\n#define PARKBD_CLOCK\t0x01\t \n#define PARKBD_DATA\t0x02\t \n\nstatic int parkbd_buffer;\nstatic int parkbd_counter;\nstatic unsigned long parkbd_last;\nstatic int parkbd_writing;\nstatic unsigned long parkbd_start;\n\nstatic struct pardevice *parkbd_dev;\nstatic struct serio *parkbd_port;\n\nstatic int parkbd_readlines(void)\n{\n\treturn (parport_read_status(parkbd_dev->port) >> 6) ^ 2;\n}\n\nstatic void parkbd_writelines(int data)\n{\n\tparport_write_control(parkbd_dev->port, (~data & 3) | 0x10);\n}\n\nstatic int parkbd_write(struct serio *port, unsigned char c)\n{\n\tunsigned char p;\n\n\tif (!parkbd_mode) return -1;\n\n        p = c ^ (c >> 4);\n\tp = p ^ (p >> 2);\n\tp = p ^ (p >> 1);\n\n\tparkbd_counter = 0;\n\tparkbd_writing = 1;\n\tparkbd_buffer = c | (((int) (~p & 1)) << 8) | 0x600;\n\n\tparkbd_writelines(2);\n\n\treturn 0;\n}\n\nstatic void parkbd_interrupt(void *dev_id)\n{\n\n\tif (parkbd_writing) {\n\n\t\tif (parkbd_counter && ((parkbd_counter == 11) || time_after(jiffies, parkbd_last + HZ/100))) {\n\t\t\tparkbd_counter = 0;\n\t\t\tparkbd_buffer = 0;\n\t\t\tparkbd_writing = 0;\n\t\t\tparkbd_writelines(3);\n\t\t\treturn;\n\t\t}\n\n\t\tparkbd_writelines(((parkbd_buffer >> parkbd_counter++) & 1) | 2);\n\n\t\tif (parkbd_counter == 11) {\n\t\t\tparkbd_counter = 0;\n\t\t\tparkbd_buffer = 0;\n\t\t\tparkbd_writing = 0;\n\t\t\tparkbd_writelines(3);\n\t\t}\n\n\t} else {\n\n\t\tif ((parkbd_counter == parkbd_mode + 10) || time_after(jiffies, parkbd_last + HZ/100)) {\n\t\t\tparkbd_counter = 0;\n\t\t\tparkbd_buffer = 0;\n\t\t}\n\n\t\tparkbd_buffer |= (parkbd_readlines() >> 1) << parkbd_counter++;\n\n\t\tif (parkbd_counter == parkbd_mode + 10)\n\t\t\tserio_interrupt(parkbd_port, (parkbd_buffer >> (2 - parkbd_mode)) & 0xff, 0);\n\t}\n\n\tparkbd_last = jiffies;\n}\n\nstatic int parkbd_getport(struct parport *pp)\n{\n\tstruct pardev_cb parkbd_parport_cb;\n\n\tmemset(&parkbd_parport_cb, 0, sizeof(parkbd_parport_cb));\n\tparkbd_parport_cb.irq_func = parkbd_interrupt;\n\tparkbd_parport_cb.flags = PARPORT_FLAG_EXCL;\n\n\tparkbd_dev = parport_register_dev_model(pp, \"parkbd\",\n\t\t\t\t\t\t&parkbd_parport_cb, 0);\n\n\tif (!parkbd_dev)\n\t\treturn -ENODEV;\n\n\tif (parport_claim(parkbd_dev)) {\n\t\tparport_unregister_device(parkbd_dev);\n\t\treturn -EBUSY;\n\t}\n\n\tparkbd_start = jiffies;\n\n\treturn 0;\n}\n\nstatic struct serio *parkbd_allocate_serio(void)\n{\n\tstruct serio *serio;\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (serio) {\n\t\tserio->id.type = parkbd_mode;\n\t\tserio->write = parkbd_write;\n\t\tstrscpy(serio->name, \"PARKBD AT/XT keyboard adapter\", sizeof(serio->name));\n\t\tsnprintf(serio->phys, sizeof(serio->phys), \"%s/serio0\", parkbd_dev->port->name);\n\t}\n\n\treturn serio;\n}\n\nstatic void parkbd_attach(struct parport *pp)\n{\n\tif (pp->number != parkbd_pp_no) {\n\t\tpr_debug(\"Not using parport%d.\\n\", pp->number);\n\t\treturn;\n\t}\n\n\tif (parkbd_getport(pp))\n\t\treturn;\n\n\tparkbd_port = parkbd_allocate_serio();\n\tif (!parkbd_port) {\n\t\tparport_release(parkbd_dev);\n\t\tparport_unregister_device(parkbd_dev);\n\t\treturn;\n\t}\n\n\tparkbd_writelines(3);\n\n\tserio_register_port(parkbd_port);\n\n\tprintk(KERN_INFO \"serio: PARKBD %s adapter on %s\\n\",\n                        parkbd_mode ? \"AT\" : \"XT\", parkbd_dev->port->name);\n\n\treturn;\n}\n\nstatic void parkbd_detach(struct parport *port)\n{\n\tif (!parkbd_port || port->number != parkbd_pp_no)\n\t\treturn;\n\n\tparport_release(parkbd_dev);\n\tserio_unregister_port(parkbd_port);\n\tparport_unregister_device(parkbd_dev);\n\tparkbd_port = NULL;\n}\n\nstatic struct parport_driver parkbd_parport_driver = {\n\t.name = \"parkbd\",\n\t.match_port = parkbd_attach,\n\t.detach = parkbd_detach,\n\t.devmodel = true,\n};\nmodule_parport_driver(parkbd_parport_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}