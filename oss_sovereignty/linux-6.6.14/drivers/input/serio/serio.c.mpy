{
  "module_name": "serio.c",
  "hash_id": "d7860230310a9b8035c92ea6cfc467b4185243be7822c8f65ab46783070578d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/serio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/stddef.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Serio abstraction core\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic DEFINE_MUTEX(serio_mutex);\n\nstatic LIST_HEAD(serio_list);\n\nstatic void serio_add_port(struct serio *serio);\nstatic int serio_reconnect_port(struct serio *serio);\nstatic void serio_disconnect_port(struct serio *serio);\nstatic void serio_reconnect_subtree(struct serio *serio);\nstatic void serio_attach_driver(struct serio_driver *drv);\n\nstatic int serio_connect_driver(struct serio *serio, struct serio_driver *drv)\n{\n\tint retval;\n\n\tmutex_lock(&serio->drv_mutex);\n\tretval = drv->connect(serio, drv);\n\tmutex_unlock(&serio->drv_mutex);\n\n\treturn retval;\n}\n\nstatic int serio_reconnect_driver(struct serio *serio)\n{\n\tint retval = -1;\n\n\tmutex_lock(&serio->drv_mutex);\n\tif (serio->drv && serio->drv->reconnect)\n\t\tretval = serio->drv->reconnect(serio);\n\tmutex_unlock(&serio->drv_mutex);\n\n\treturn retval;\n}\n\nstatic void serio_disconnect_driver(struct serio *serio)\n{\n\tmutex_lock(&serio->drv_mutex);\n\tif (serio->drv)\n\t\tserio->drv->disconnect(serio);\n\tmutex_unlock(&serio->drv_mutex);\n}\n\nstatic int serio_match_port(const struct serio_device_id *ids, struct serio *serio)\n{\n\twhile (ids->type || ids->proto) {\n\t\tif ((ids->type == SERIO_ANY || ids->type == serio->id.type) &&\n\t\t    (ids->proto == SERIO_ANY || ids->proto == serio->id.proto) &&\n\t\t    (ids->extra == SERIO_ANY || ids->extra == serio->id.extra) &&\n\t\t    (ids->id == SERIO_ANY || ids->id == serio->id.id))\n\t\t\treturn 1;\n\t\tids++;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int serio_bind_driver(struct serio *serio, struct serio_driver *drv)\n{\n\tint error;\n\n\tif (serio_match_port(drv->id_table, serio)) {\n\n\t\tserio->dev.driver = &drv->driver;\n\t\tif (serio_connect_driver(serio, drv)) {\n\t\t\tserio->dev.driver = NULL;\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\terror = device_bind_driver(&serio->dev);\n\t\tif (error) {\n\t\t\tdev_warn(&serio->dev,\n\t\t\t\t \"device_bind_driver() failed for %s (%s) and %s, error: %d\\n\",\n\t\t\t\t serio->phys, serio->name,\n\t\t\t\t drv->description, error);\n\t\t\tserio_disconnect_driver(serio);\n\t\t\tserio->dev.driver = NULL;\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void serio_find_driver(struct serio *serio)\n{\n\tint error;\n\n\terror = device_attach(&serio->dev);\n\tif (error < 0 && error != -EPROBE_DEFER)\n\t\tdev_warn(&serio->dev,\n\t\t\t \"device_attach() failed for %s (%s), error: %d\\n\",\n\t\t\t serio->phys, serio->name, error);\n}\n\n\n \n\nenum serio_event_type {\n\tSERIO_RESCAN_PORT,\n\tSERIO_RECONNECT_PORT,\n\tSERIO_RECONNECT_SUBTREE,\n\tSERIO_REGISTER_PORT,\n\tSERIO_ATTACH_DRIVER,\n};\n\nstruct serio_event {\n\tenum serio_event_type type;\n\tvoid *object;\n\tstruct module *owner;\n\tstruct list_head node;\n};\n\nstatic DEFINE_SPINLOCK(serio_event_lock);\t \nstatic LIST_HEAD(serio_event_list);\n\nstatic struct serio_event *serio_get_event(void)\n{\n\tstruct serio_event *event = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serio_event_lock, flags);\n\n\tif (!list_empty(&serio_event_list)) {\n\t\tevent = list_first_entry(&serio_event_list,\n\t\t\t\t\t struct serio_event, node);\n\t\tlist_del_init(&event->node);\n\t}\n\n\tspin_unlock_irqrestore(&serio_event_lock, flags);\n\treturn event;\n}\n\nstatic void serio_free_event(struct serio_event *event)\n{\n\tmodule_put(event->owner);\n\tkfree(event);\n}\n\nstatic void serio_remove_duplicate_events(void *object,\n\t\t\t\t\t  enum serio_event_type type)\n{\n\tstruct serio_event *e, *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serio_event_lock, flags);\n\n\tlist_for_each_entry_safe(e, next, &serio_event_list, node) {\n\t\tif (object == e->object) {\n\t\t\t \n\t\t\tif (type != e->type)\n\t\t\t\tbreak;\n\n\t\t\tlist_del_init(&e->node);\n\t\t\tserio_free_event(e);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&serio_event_lock, flags);\n}\n\nstatic void serio_handle_event(struct work_struct *work)\n{\n\tstruct serio_event *event;\n\n\tmutex_lock(&serio_mutex);\n\n\twhile ((event = serio_get_event())) {\n\n\t\tswitch (event->type) {\n\n\t\tcase SERIO_REGISTER_PORT:\n\t\t\tserio_add_port(event->object);\n\t\t\tbreak;\n\n\t\tcase SERIO_RECONNECT_PORT:\n\t\t\tserio_reconnect_port(event->object);\n\t\t\tbreak;\n\n\t\tcase SERIO_RESCAN_PORT:\n\t\t\tserio_disconnect_port(event->object);\n\t\t\tserio_find_driver(event->object);\n\t\t\tbreak;\n\n\t\tcase SERIO_RECONNECT_SUBTREE:\n\t\t\tserio_reconnect_subtree(event->object);\n\t\t\tbreak;\n\n\t\tcase SERIO_ATTACH_DRIVER:\n\t\t\tserio_attach_driver(event->object);\n\t\t\tbreak;\n\t\t}\n\n\t\tserio_remove_duplicate_events(event->object, event->type);\n\t\tserio_free_event(event);\n\t}\n\n\tmutex_unlock(&serio_mutex);\n}\n\nstatic DECLARE_WORK(serio_event_work, serio_handle_event);\n\nstatic int serio_queue_event(void *object, struct module *owner,\n\t\t\t     enum serio_event_type event_type)\n{\n\tunsigned long flags;\n\tstruct serio_event *event;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&serio_event_lock, flags);\n\n\t \n\tlist_for_each_entry_reverse(event, &serio_event_list, node) {\n\t\tif (event->object == object) {\n\t\t\tif (event->type == event_type)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tevent = kmalloc(sizeof(struct serio_event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"Not enough memory to queue event %d\\n\", event_type);\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!try_module_get(owner)) {\n\t\tpr_warn(\"Can't get module reference, dropping event %d\\n\",\n\t\t\tevent_type);\n\t\tkfree(event);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tevent->type = event_type;\n\tevent->object = object;\n\tevent->owner = owner;\n\n\tlist_add_tail(&event->node, &serio_event_list);\n\tqueue_work(system_long_wq, &serio_event_work);\n\nout:\n\tspin_unlock_irqrestore(&serio_event_lock, flags);\n\treturn retval;\n}\n\n \nstatic void serio_remove_pending_events(void *object)\n{\n\tstruct serio_event *event, *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serio_event_lock, flags);\n\n\tlist_for_each_entry_safe(event, next, &serio_event_list, node) {\n\t\tif (event->object == object) {\n\t\t\tlist_del_init(&event->node);\n\t\t\tserio_free_event(event);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&serio_event_lock, flags);\n}\n\n \nstatic struct serio *serio_get_pending_child(struct serio *parent)\n{\n\tstruct serio_event *event;\n\tstruct serio *serio, *child = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serio_event_lock, flags);\n\n\tlist_for_each_entry(event, &serio_event_list, node) {\n\t\tif (event->type == SERIO_REGISTER_PORT) {\n\t\t\tserio = event->object;\n\t\t\tif (serio->parent == parent) {\n\t\t\t\tchild = serio;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&serio_event_lock, flags);\n\treturn child;\n}\n\n \n\nstatic ssize_t serio_show_description(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\treturn sprintf(buf, \"%s\\n\", serio->name);\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\n\treturn sprintf(buf, \"serio:ty%02Xpr%02Xid%02Xex%02X\\n\",\n\t\t\tserio->id.type, serio->id.proto, serio->id.id, serio->id.extra);\n}\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\treturn sprintf(buf, \"%02x\\n\", serio->id.type);\n}\n\nstatic ssize_t proto_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\treturn sprintf(buf, \"%02x\\n\", serio->id.proto);\n}\n\nstatic ssize_t id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\treturn sprintf(buf, \"%02x\\n\", serio->id.id);\n}\n\nstatic ssize_t extra_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\treturn sprintf(buf, \"%02x\\n\", serio->id.extra);\n}\n\nstatic ssize_t drvctl_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct device_driver *drv;\n\tint error;\n\n\terror = mutex_lock_interruptible(&serio_mutex);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(buf, \"none\", count)) {\n\t\tserio_disconnect_port(serio);\n\t} else if (!strncmp(buf, \"reconnect\", count)) {\n\t\tserio_reconnect_subtree(serio);\n\t} else if (!strncmp(buf, \"rescan\", count)) {\n\t\tserio_disconnect_port(serio);\n\t\tserio_find_driver(serio);\n\t\tserio_remove_duplicate_events(serio, SERIO_RESCAN_PORT);\n\t} else if ((drv = driver_find(buf, &serio_bus)) != NULL) {\n\t\tserio_disconnect_port(serio);\n\t\terror = serio_bind_driver(serio, to_serio_driver(drv));\n\t\tserio_remove_duplicate_events(serio, SERIO_RESCAN_PORT);\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n\tmutex_unlock(&serio_mutex);\n\n\treturn error ? error : count;\n}\n\nstatic ssize_t serio_show_bind_mode(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\treturn sprintf(buf, \"%s\\n\", serio->manual_bind ? \"manual\" : \"auto\");\n}\n\nstatic ssize_t serio_set_bind_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tint retval;\n\n\tretval = count;\n\tif (!strncmp(buf, \"manual\", count)) {\n\t\tserio->manual_bind = true;\n\t} else if (!strncmp(buf, \"auto\", count)) {\n\t\tserio->manual_bind = false;\n\t} else {\n\t\tretval = -EINVAL;\n\t}\n\n\treturn retval;\n}\n\nstatic ssize_t firmware_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\n\treturn sprintf(buf, \"%s\\n\", serio->firmware_id);\n}\n\nstatic DEVICE_ATTR_RO(type);\nstatic DEVICE_ATTR_RO(proto);\nstatic DEVICE_ATTR_RO(id);\nstatic DEVICE_ATTR_RO(extra);\n\nstatic struct attribute *serio_device_id_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_proto.attr,\n\t&dev_attr_id.attr,\n\t&dev_attr_extra.attr,\n\tNULL\n};\n\nstatic const struct attribute_group serio_id_attr_group = {\n\t.name\t= \"id\",\n\t.attrs\t= serio_device_id_attrs,\n};\n\nstatic DEVICE_ATTR_RO(modalias);\nstatic DEVICE_ATTR_WO(drvctl);\nstatic DEVICE_ATTR(description, S_IRUGO, serio_show_description, NULL);\nstatic DEVICE_ATTR(bind_mode, S_IWUSR | S_IRUGO, serio_show_bind_mode, serio_set_bind_mode);\nstatic DEVICE_ATTR_RO(firmware_id);\n\nstatic struct attribute *serio_device_attrs[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_description.attr,\n\t&dev_attr_drvctl.attr,\n\t&dev_attr_bind_mode.attr,\n\t&dev_attr_firmware_id.attr,\n\tNULL\n};\n\nstatic const struct attribute_group serio_device_attr_group = {\n\t.attrs\t= serio_device_attrs,\n};\n\nstatic const struct attribute_group *serio_device_attr_groups[] = {\n\t&serio_id_attr_group,\n\t&serio_device_attr_group,\n\tNULL\n};\n\nstatic void serio_release_port(struct device *dev)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\n\tkfree(serio);\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic void serio_init_port(struct serio *serio)\n{\n\tstatic atomic_t serio_no = ATOMIC_INIT(-1);\n\n\t__module_get(THIS_MODULE);\n\n\tINIT_LIST_HEAD(&serio->node);\n\tINIT_LIST_HEAD(&serio->child_node);\n\tINIT_LIST_HEAD(&serio->children);\n\tspin_lock_init(&serio->lock);\n\tmutex_init(&serio->drv_mutex);\n\tdevice_initialize(&serio->dev);\n\tdev_set_name(&serio->dev, \"serio%lu\",\n\t\t     (unsigned long)atomic_inc_return(&serio_no));\n\tserio->dev.bus = &serio_bus;\n\tserio->dev.release = serio_release_port;\n\tserio->dev.groups = serio_device_attr_groups;\n\tif (serio->parent) {\n\t\tserio->dev.parent = &serio->parent->dev;\n\t\tserio->depth = serio->parent->depth + 1;\n\t} else\n\t\tserio->depth = 0;\n\tlockdep_set_subclass(&serio->lock, serio->depth);\n}\n\n \nstatic void serio_add_port(struct serio *serio)\n{\n\tstruct serio *parent = serio->parent;\n\tint error;\n\n\tif (parent) {\n\t\tserio_pause_rx(parent);\n\t\tlist_add_tail(&serio->child_node, &parent->children);\n\t\tserio_continue_rx(parent);\n\t}\n\n\tlist_add_tail(&serio->node, &serio_list);\n\n\tif (serio->start)\n\t\tserio->start(serio);\n\n\terror = device_add(&serio->dev);\n\tif (error)\n\t\tdev_err(&serio->dev,\n\t\t\t\"device_add() failed for %s (%s), error: %d\\n\",\n\t\t\tserio->phys, serio->name, error);\n}\n\n \nstatic void serio_destroy_port(struct serio *serio)\n{\n\tstruct serio *child;\n\n\twhile ((child = serio_get_pending_child(serio)) != NULL) {\n\t\tserio_remove_pending_events(child);\n\t\tput_device(&child->dev);\n\t}\n\n\tif (serio->stop)\n\t\tserio->stop(serio);\n\n\tif (serio->parent) {\n\t\tserio_pause_rx(serio->parent);\n\t\tlist_del_init(&serio->child_node);\n\t\tserio_continue_rx(serio->parent);\n\t\tserio->parent = NULL;\n\t}\n\n\tif (device_is_registered(&serio->dev))\n\t\tdevice_del(&serio->dev);\n\n\tlist_del_init(&serio->node);\n\tserio_remove_pending_events(serio);\n\tput_device(&serio->dev);\n}\n\n \nstatic int serio_reconnect_port(struct serio *serio)\n{\n\tint error = serio_reconnect_driver(serio);\n\n\tif (error) {\n\t\tserio_disconnect_port(serio);\n\t\tserio_find_driver(serio);\n\t}\n\n\treturn error;\n}\n\n \nstatic void serio_reconnect_subtree(struct serio *root)\n{\n\tstruct serio *s = root;\n\tint error;\n\n\tdo {\n\t\terror = serio_reconnect_port(s);\n\t\tif (!error) {\n\t\t\t \n\t\t\tif (!list_empty(&s->children)) {\n\t\t\t\ts = list_first_entry(&s->children,\n\t\t\t\t\t\t     struct serio, child_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twhile (s != root) {\n\t\t\tstruct serio *parent = s->parent;\n\n\t\t\tif (!list_is_last(&s->child_node, &parent->children)) {\n\t\t\t\ts = list_entry(s->child_node.next,\n\t\t\t\t\t       struct serio, child_node);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = parent;\n\t\t}\n\t} while (s != root);\n}\n\n \nstatic void serio_disconnect_port(struct serio *serio)\n{\n\tstruct serio *s = serio;\n\n\t \n\twhile (!list_empty(&serio->children)) {\n\n\t\t \n\t\twhile (!list_empty(&s->children))\n\t\t\ts = list_first_entry(&s->children,\n\t\t\t\t\t     struct serio, child_node);\n\n\t\t \n\t\tif (s != serio) {\n\t\t\tstruct serio *parent = s->parent;\n\n\t\t\tdevice_release_driver(&s->dev);\n\t\t\tserio_destroy_port(s);\n\n\t\t\ts = parent;\n\t\t}\n\t}\n\n\t \n\tdevice_release_driver(&serio->dev);\n}\n\nvoid serio_rescan(struct serio *serio)\n{\n\tserio_queue_event(serio, NULL, SERIO_RESCAN_PORT);\n}\nEXPORT_SYMBOL(serio_rescan);\n\nvoid serio_reconnect(struct serio *serio)\n{\n\tserio_queue_event(serio, NULL, SERIO_RECONNECT_SUBTREE);\n}\nEXPORT_SYMBOL(serio_reconnect);\n\n \nvoid __serio_register_port(struct serio *serio, struct module *owner)\n{\n\tserio_init_port(serio);\n\tserio_queue_event(serio, owner, SERIO_REGISTER_PORT);\n}\nEXPORT_SYMBOL(__serio_register_port);\n\n \nvoid serio_unregister_port(struct serio *serio)\n{\n\tmutex_lock(&serio_mutex);\n\tserio_disconnect_port(serio);\n\tserio_destroy_port(serio);\n\tmutex_unlock(&serio_mutex);\n}\nEXPORT_SYMBOL(serio_unregister_port);\n\n \nvoid serio_unregister_child_port(struct serio *serio)\n{\n\tstruct serio *s, *next;\n\n\tmutex_lock(&serio_mutex);\n\tlist_for_each_entry_safe(s, next, &serio->children, child_node) {\n\t\tserio_disconnect_port(s);\n\t\tserio_destroy_port(s);\n\t}\n\tmutex_unlock(&serio_mutex);\n}\nEXPORT_SYMBOL(serio_unregister_child_port);\n\n\n \n\nstatic ssize_t description_show(struct device_driver *drv, char *buf)\n{\n\tstruct serio_driver *driver = to_serio_driver(drv);\n\treturn sprintf(buf, \"%s\\n\", driver->description ? driver->description : \"(none)\");\n}\nstatic DRIVER_ATTR_RO(description);\n\nstatic ssize_t bind_mode_show(struct device_driver *drv, char *buf)\n{\n\tstruct serio_driver *serio_drv = to_serio_driver(drv);\n\treturn sprintf(buf, \"%s\\n\", serio_drv->manual_bind ? \"manual\" : \"auto\");\n}\n\nstatic ssize_t bind_mode_store(struct device_driver *drv, const char *buf, size_t count)\n{\n\tstruct serio_driver *serio_drv = to_serio_driver(drv);\n\tint retval;\n\n\tretval = count;\n\tif (!strncmp(buf, \"manual\", count)) {\n\t\tserio_drv->manual_bind = true;\n\t} else if (!strncmp(buf, \"auto\", count)) {\n\t\tserio_drv->manual_bind = false;\n\t} else {\n\t\tretval = -EINVAL;\n\t}\n\n\treturn retval;\n}\nstatic DRIVER_ATTR_RW(bind_mode);\n\nstatic struct attribute *serio_driver_attrs[] = {\n\t&driver_attr_description.attr,\n\t&driver_attr_bind_mode.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(serio_driver);\n\nstatic int serio_driver_probe(struct device *dev)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct serio_driver *drv = to_serio_driver(dev->driver);\n\n\treturn serio_connect_driver(serio, drv);\n}\n\nstatic void serio_driver_remove(struct device *dev)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\n\tserio_disconnect_driver(serio);\n}\n\nstatic void serio_cleanup(struct serio *serio)\n{\n\tmutex_lock(&serio->drv_mutex);\n\tif (serio->drv && serio->drv->cleanup)\n\t\tserio->drv->cleanup(serio);\n\tmutex_unlock(&serio->drv_mutex);\n}\n\nstatic void serio_shutdown(struct device *dev)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\n\tserio_cleanup(serio);\n}\n\nstatic void serio_attach_driver(struct serio_driver *drv)\n{\n\tint error;\n\n\terror = driver_attach(&drv->driver);\n\tif (error)\n\t\tpr_warn(\"driver_attach() failed for %s with error %d\\n\",\n\t\t\tdrv->driver.name, error);\n}\n\nint __serio_register_driver(struct serio_driver *drv, struct module *owner, const char *mod_name)\n{\n\tbool manual_bind = drv->manual_bind;\n\tint error;\n\n\tdrv->driver.bus = &serio_bus;\n\tdrv->driver.owner = owner;\n\tdrv->driver.mod_name = mod_name;\n\n\t \n\tdrv->manual_bind = true;\n\n\terror = driver_register(&drv->driver);\n\tif (error) {\n\t\tpr_err(\"driver_register() failed for %s, error: %d\\n\",\n\t\t\tdrv->driver.name, error);\n\t\treturn error;\n\t}\n\n\t \n\tif (!manual_bind) {\n\t\tdrv->manual_bind = false;\n\t\terror = serio_queue_event(drv, NULL, SERIO_ATTACH_DRIVER);\n\t\tif (error) {\n\t\t\tdriver_unregister(&drv->driver);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__serio_register_driver);\n\nvoid serio_unregister_driver(struct serio_driver *drv)\n{\n\tstruct serio *serio;\n\n\tmutex_lock(&serio_mutex);\n\n\tdrv->manual_bind = true;\t \n\tserio_remove_pending_events(drv);\n\nstart_over:\n\tlist_for_each_entry(serio, &serio_list, node) {\n\t\tif (serio->drv == drv) {\n\t\t\tserio_disconnect_port(serio);\n\t\t\tserio_find_driver(serio);\n\t\t\t \n\t\t\tgoto start_over;\n\t\t}\n\t}\n\n\tdriver_unregister(&drv->driver);\n\tmutex_unlock(&serio_mutex);\n}\nEXPORT_SYMBOL(serio_unregister_driver);\n\nstatic void serio_set_drv(struct serio *serio, struct serio_driver *drv)\n{\n\tserio_pause_rx(serio);\n\tserio->drv = drv;\n\tserio_continue_rx(serio);\n}\n\nstatic int serio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct serio_driver *serio_drv = to_serio_driver(drv);\n\n\tif (serio->manual_bind || serio_drv->manual_bind)\n\t\treturn 0;\n\n\treturn serio_match_port(serio_drv->id_table, serio);\n}\n\n#define SERIO_ADD_UEVENT_VAR(fmt, val...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = add_uevent_var(env, fmt, val);\t\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\nstatic int serio_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct serio *serio;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tserio = to_serio_port(dev);\n\n\tSERIO_ADD_UEVENT_VAR(\"SERIO_TYPE=%02x\", serio->id.type);\n\tSERIO_ADD_UEVENT_VAR(\"SERIO_PROTO=%02x\", serio->id.proto);\n\tSERIO_ADD_UEVENT_VAR(\"SERIO_ID=%02x\", serio->id.id);\n\tSERIO_ADD_UEVENT_VAR(\"SERIO_EXTRA=%02x\", serio->id.extra);\n\n\tSERIO_ADD_UEVENT_VAR(\"MODALIAS=serio:ty%02Xpr%02Xid%02Xex%02X\",\n\t\t\t\tserio->id.type, serio->id.proto, serio->id.id, serio->id.extra);\n\n\tif (serio->firmware_id[0])\n\t\tSERIO_ADD_UEVENT_VAR(\"SERIO_FIRMWARE_ID=%s\",\n\t\t\t\t     serio->firmware_id);\n\n\treturn 0;\n}\n#undef SERIO_ADD_UEVENT_VAR\n\n#ifdef CONFIG_PM\nstatic int serio_suspend(struct device *dev)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\n\tserio_cleanup(serio);\n\n\treturn 0;\n}\n\nstatic int serio_resume(struct device *dev)\n{\n\tstruct serio *serio = to_serio_port(dev);\n\tint error = -ENOENT;\n\n\tmutex_lock(&serio->drv_mutex);\n\tif (serio->drv && serio->drv->fast_reconnect) {\n\t\terror = serio->drv->fast_reconnect(serio);\n\t\tif (error && error != -ENOENT)\n\t\t\tdev_warn(dev, \"fast reconnect failed with error %d\\n\",\n\t\t\t\t error);\n\t}\n\tmutex_unlock(&serio->drv_mutex);\n\n\tif (error) {\n\t\t \n\t\tserio_queue_event(serio, NULL, SERIO_RECONNECT_PORT);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops serio_pm_ops = {\n\t.suspend\t= serio_suspend,\n\t.resume\t\t= serio_resume,\n\t.poweroff\t= serio_suspend,\n\t.restore\t= serio_resume,\n};\n#endif  \n\n \nint serio_open(struct serio *serio, struct serio_driver *drv)\n{\n\tserio_set_drv(serio, drv);\n\n\tif (serio->open && serio->open(serio)) {\n\t\tserio_set_drv(serio, NULL);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(serio_open);\n\n \nvoid serio_close(struct serio *serio)\n{\n\tif (serio->close)\n\t\tserio->close(serio);\n\n\tserio_set_drv(serio, NULL);\n}\nEXPORT_SYMBOL(serio_close);\n\nirqreturn_t serio_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int dfl)\n{\n\tunsigned long flags;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock_irqsave(&serio->lock, flags);\n\n        if (likely(serio->drv)) {\n                ret = serio->drv->interrupt(serio, data, dfl);\n\t} else if (!dfl && device_is_registered(&serio->dev)) {\n\t\tserio_rescan(serio);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&serio->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(serio_interrupt);\n\nstruct bus_type serio_bus = {\n\t.name\t\t= \"serio\",\n\t.drv_groups\t= serio_driver_groups,\n\t.match\t\t= serio_bus_match,\n\t.uevent\t\t= serio_uevent,\n\t.probe\t\t= serio_driver_probe,\n\t.remove\t\t= serio_driver_remove,\n\t.shutdown\t= serio_shutdown,\n#ifdef CONFIG_PM\n\t.pm\t\t= &serio_pm_ops,\n#endif\n};\nEXPORT_SYMBOL(serio_bus);\n\nstatic int __init serio_init(void)\n{\n\tint error;\n\n\terror = bus_register(&serio_bus);\n\tif (error) {\n\t\tpr_err(\"Failed to register serio bus, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit serio_exit(void)\n{\n\tbus_unregister(&serio_bus);\n\n\t \n\tcancel_work_sync(&serio_event_work);\n}\n\nsubsys_initcall(serio_init);\nmodule_exit(serio_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}