{
  "module_name": "ioc3kbd.c",
  "hash_id": "ab9e1319379f1ba1563bb4800896de26415915c877905443a2f169674d0d1916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/ioc3kbd.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/serio.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <asm/sn/ioc3.h>\n\nstruct ioc3kbd_data {\n\tstruct ioc3_serioregs __iomem *regs;\n\tstruct serio *kbd, *aux;\n\tbool kbd_exists, aux_exists;\n\tint irq;\n};\n\nstatic int ioc3kbd_wait(struct ioc3_serioregs __iomem *regs, u32 mask)\n{\n\tunsigned long timeout = 0;\n\n\twhile ((readl(&regs->km_csr) & mask) && (timeout < 250)) {\n\t\tudelay(50);\n\t\ttimeout++;\n\t}\n\treturn (timeout >= 250) ? -ETIMEDOUT : 0;\n}\n\nstatic int ioc3kbd_write(struct serio *dev, u8 val)\n{\n\tstruct ioc3kbd_data *d = dev->port_data;\n\tint ret;\n\n\tret = ioc3kbd_wait(d->regs, KM_CSR_K_WRT_PEND);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(val, &d->regs->k_wd);\n\n\treturn 0;\n}\n\nstatic int ioc3kbd_start(struct serio *dev)\n{\n\tstruct ioc3kbd_data *d = dev->port_data;\n\n\td->kbd_exists = true;\n\treturn 0;\n}\n\nstatic void ioc3kbd_stop(struct serio *dev)\n{\n\tstruct ioc3kbd_data *d = dev->port_data;\n\n\td->kbd_exists = false;\n}\n\nstatic int ioc3aux_write(struct serio *dev, u8 val)\n{\n\tstruct ioc3kbd_data *d = dev->port_data;\n\tint ret;\n\n\tret = ioc3kbd_wait(d->regs, KM_CSR_M_WRT_PEND);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(val, &d->regs->m_wd);\n\n\treturn 0;\n}\n\nstatic int ioc3aux_start(struct serio *dev)\n{\n\tstruct ioc3kbd_data *d = dev->port_data;\n\n\td->aux_exists = true;\n\treturn 0;\n}\n\nstatic void ioc3aux_stop(struct serio *dev)\n{\n\tstruct ioc3kbd_data *d = dev->port_data;\n\n\td->aux_exists = false;\n}\n\nstatic void ioc3kbd_process_data(struct serio *dev, u32 data)\n{\n\tif (data & KM_RD_VALID_0)\n\t\tserio_interrupt(dev, (data >> KM_RD_DATA_0_SHIFT) & 0xff, 0);\n\tif (data & KM_RD_VALID_1)\n\t\tserio_interrupt(dev, (data >> KM_RD_DATA_1_SHIFT) & 0xff, 0);\n\tif (data & KM_RD_VALID_2)\n\t\tserio_interrupt(dev, (data >> KM_RD_DATA_2_SHIFT) & 0xff, 0);\n}\n\nstatic irqreturn_t ioc3kbd_intr(int itq, void *dev_id)\n{\n\tstruct ioc3kbd_data *d = dev_id;\n\tu32 data_k, data_m;\n\n\tdata_k = readl(&d->regs->k_rd);\n\tif (d->kbd_exists)\n\t\tioc3kbd_process_data(d->kbd, data_k);\n\n\tdata_m = readl(&d->regs->m_rd);\n\tif (d->aux_exists)\n\t\tioc3kbd_process_data(d->aux, data_m);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ioc3kbd_probe(struct platform_device *pdev)\n{\n\tstruct ioc3_serioregs __iomem *regs;\n\tstruct device *dev = &pdev->dev;\n\tstruct ioc3kbd_data *d;\n\tstruct serio *sk, *sa;\n\tint irq, ret;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\td = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tsk = kzalloc(sizeof(*sk), GFP_KERNEL);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsa = kzalloc(sizeof(*sa), GFP_KERNEL);\n\tif (!sa) {\n\t\tkfree(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsk->id.type = SERIO_8042;\n\tsk->write = ioc3kbd_write;\n\tsk->start = ioc3kbd_start;\n\tsk->stop = ioc3kbd_stop;\n\tsnprintf(sk->name, sizeof(sk->name), \"IOC3 keyboard %d\", pdev->id);\n\tsnprintf(sk->phys, sizeof(sk->phys), \"ioc3/serio%dkbd\", pdev->id);\n\tsk->port_data = d;\n\tsk->dev.parent = dev;\n\n\tsa->id.type = SERIO_8042;\n\tsa->write = ioc3aux_write;\n\tsa->start = ioc3aux_start;\n\tsa->stop = ioc3aux_stop;\n\tsnprintf(sa->name, sizeof(sa->name), \"IOC3 auxiliary %d\", pdev->id);\n\tsnprintf(sa->phys, sizeof(sa->phys), \"ioc3/serio%daux\", pdev->id);\n\tsa->port_data = d;\n\tsa->dev.parent = dev;\n\n\td->regs = regs;\n\td->kbd = sk;\n\td->aux = sa;\n\td->irq = irq;\n\n\tplatform_set_drvdata(pdev, d);\n\tserio_register_port(d->kbd);\n\tserio_register_port(d->aux);\n\n\tret = request_irq(irq, ioc3kbd_intr, IRQF_SHARED, \"ioc3-kbd\", d);\n\tif (ret) {\n\t\tdev_err(dev, \"could not request IRQ %d\\n\", irq);\n\t\tserio_unregister_port(d->kbd);\n\t\tserio_unregister_port(d->aux);\n\t\treturn ret;\n\t}\n\n\t \n\twritel(KM_CSR_K_CLAMP_3 | KM_CSR_M_CLAMP_3, &regs->km_csr);\n\n\treturn 0;\n}\n\nstatic int ioc3kbd_remove(struct platform_device *pdev)\n{\n\tstruct ioc3kbd_data *d = platform_get_drvdata(pdev);\n\n\tfree_irq(d->irq, d);\n\n\tserio_unregister_port(d->kbd);\n\tserio_unregister_port(d->aux);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ioc3kbd_driver = {\n\t.probe          = ioc3kbd_probe,\n\t.remove         = ioc3kbd_remove,\n\t.driver = {\n\t\t.name = \"ioc3-kbd\",\n\t},\n};\nmodule_platform_driver(ioc3kbd_driver);\n\nMODULE_AUTHOR(\"Thomas Bogendoerfer <tbogendoerfer@suse.de>\");\nMODULE_DESCRIPTION(\"SGI IOC3 serio driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}