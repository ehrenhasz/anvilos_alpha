{
  "module_name": "hil_mlc.c",
  "hash_id": "50e0a832eadc8259bc47dce346ceb338ce16983e7708a31f26827242bc1be0a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/hil_mlc.c",
  "human_readable_source": " \n\n#include <linux/hil_mlc.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n\nMODULE_AUTHOR(\"Brian S. Julin <bri@calyx.com>\");\nMODULE_DESCRIPTION(\"HIL MLC serio\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nEXPORT_SYMBOL(hil_mlc_register);\nEXPORT_SYMBOL(hil_mlc_unregister);\n\n#define PREFIX \"HIL MLC: \"\n\nstatic LIST_HEAD(hil_mlcs);\nstatic DEFINE_RWLOCK(hil_mlcs_lock);\nstatic struct timer_list\thil_mlcs_kicker;\nstatic int\t\t\thil_mlcs_probe, hil_mlc_stop;\n\nstatic void hil_mlcs_process(unsigned long unused);\nstatic DECLARE_TASKLET_DISABLED_OLD(hil_mlcs_tasklet, hil_mlcs_process);\n\n\n \n\n \n\nstatic void hil_mlc_clear_di_map(hil_mlc *mlc, int val)\n{\n\tint j;\n\n\tfor (j = val; j < 7 ; j++)\n\t\tmlc->di_map[j] = -1;\n}\n\nstatic void hil_mlc_clear_di_scratch(hil_mlc *mlc)\n{\n\tmemset(&mlc->di_scratch, 0, sizeof(mlc->di_scratch));\n}\n\nstatic void hil_mlc_copy_di_scratch(hil_mlc *mlc, int idx)\n{\n\tmemcpy(&mlc->di[idx], &mlc->di_scratch, sizeof(mlc->di_scratch));\n}\n\nstatic int hil_mlc_match_di_scratch(hil_mlc *mlc)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {\n\t\tint j, found = 0;\n\n\t\t \n\t\tfor (j = 0; j < 7 ; j++)\n\t\t\tif (mlc->di_map[j] == idx)\n\t\t\t\tfound++;\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(mlc->di + idx, &mlc->di_scratch,\n\t\t\t\tsizeof(mlc->di_scratch)))\n\t\t\tbreak;\n\t}\n\treturn idx >= HIL_MLC_DEVMEM ? -1 : idx;\n}\n\nstatic int hil_mlc_find_free_di(hil_mlc *mlc)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {\n\t\tint j, found = 0;\n\n\t\tfor (j = 0; j < 7 ; j++)\n\t\t\tif (mlc->di_map[j] == idx)\n\t\t\t\tfound++;\n\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\n\treturn idx;  \n}\n\nstatic inline void hil_mlc_clean_serio_map(hil_mlc *mlc)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {\n\t\tint j, found = 0;\n\n\t\tfor (j = 0; j < 7 ; j++)\n\t\t\tif (mlc->di_map[j] == idx)\n\t\t\t\tfound++;\n\n\t\tif (!found)\n\t\t\tmlc->serio_map[idx].di_revmap = -1;\n\t}\n}\n\nstatic void hil_mlc_send_polls(hil_mlc *mlc)\n{\n\tint did, i, cnt;\n\tstruct serio *serio;\n\tstruct serio_driver *drv;\n\n\ti = cnt = 0;\n\tdid = (mlc->ipacket[0] & HIL_PKT_ADDR_MASK) >> 8;\n\tserio = did ? mlc->serio[mlc->di_map[did - 1]] : NULL;\n\tdrv = (serio != NULL) ? serio->drv : NULL;\n\n\twhile (mlc->icount < 15 - i) {\n\t\thil_packet p;\n\n\t\tp = mlc->ipacket[i];\n\t\tif (did != (p & HIL_PKT_ADDR_MASK) >> 8) {\n\t\t\tif (drv && drv->interrupt) {\n\t\t\t\tdrv->interrupt(serio, 0, 0);\n\t\t\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\t\t\tdrv->interrupt(serio, HIL_PKT_CMD >> 8,  0);\n\t\t\t\tdrv->interrupt(serio, HIL_CMD_POL + cnt, 0);\n\t\t\t}\n\n\t\t\tdid = (p & HIL_PKT_ADDR_MASK) >> 8;\n\t\t\tserio = did ? mlc->serio[mlc->di_map[did-1]] : NULL;\n\t\t\tdrv = (serio != NULL) ? serio->drv : NULL;\n\t\t\tcnt = 0;\n\t\t}\n\n\t\tcnt++;\n\t\ti++;\n\n\t\tif (drv && drv->interrupt) {\n\t\t\tdrv->interrupt(serio, (p >> 24), 0);\n\t\t\tdrv->interrupt(serio, (p >> 16) & 0xff, 0);\n\t\t\tdrv->interrupt(serio, (p >> 8) & ~HIL_PKT_ADDR_MASK, 0);\n\t\t\tdrv->interrupt(serio, p & 0xff, 0);\n\t\t}\n\t}\n}\n\n \n\n#define HILSEN_SCHED\t0x000100\t \n#define HILSEN_BREAK\t0x000200\t \n#define HILSEN_UP\t0x000400\t \n#define HILSEN_DOWN\t0x000800\t \n#define HILSEN_FOLLOW\t0x001000\t \n\n#define HILSEN_MASK\t0x0000ff\n#define HILSEN_START\t0\n#define HILSEN_RESTART\t1\n#define HILSEN_DHR\t9\n#define HILSEN_DHR2\t10\n#define HILSEN_IFC\t14\n#define HILSEN_HEAL0\t16\n#define HILSEN_HEAL\t18\n#define HILSEN_ACF      21\n#define HILSEN_ACF2\t22\n#define HILSEN_DISC0\t25\n#define HILSEN_DISC\t27\n#define HILSEN_MATCH\t40\n#define HILSEN_OPERATE\t41\n#define HILSEN_PROBE\t44\n#define HILSEN_DSR\t52\n#define HILSEN_REPOLL\t55\n#define HILSEN_IFCACF\t58\n#define HILSEN_END\t60\n\n#define HILSEN_NEXT\t(HILSEN_DOWN | 1)\n#define HILSEN_SAME\t(HILSEN_DOWN | 0)\n#define HILSEN_LAST\t(HILSEN_UP | 1)\n\n#define HILSEN_DOZE\t(HILSEN_SAME | HILSEN_SCHED | HILSEN_BREAK)\n#define HILSEN_SLEEP\t(HILSEN_SAME | HILSEN_BREAK)\n\nstatic int hilse_match(hil_mlc *mlc, int unused)\n{\n\tint rc;\n\n\trc = hil_mlc_match_di_scratch(mlc);\n\tif (rc == -1) {\n\t\trc = hil_mlc_find_free_di(mlc);\n\t\tif (rc == -1)\n\t\t\tgoto err;\n\n#ifdef HIL_MLC_DEBUG\n\t\tprintk(KERN_DEBUG PREFIX \"new in slot %i\\n\", rc);\n#endif\n\t\thil_mlc_copy_di_scratch(mlc, rc);\n\t\tmlc->di_map[mlc->ddi] = rc;\n\t\tmlc->serio_map[rc].di_revmap = mlc->ddi;\n\t\thil_mlc_clean_serio_map(mlc);\n\t\tserio_rescan(mlc->serio[rc]);\n\t\treturn -1;\n\t}\n\n\tmlc->di_map[mlc->ddi] = rc;\n#ifdef HIL_MLC_DEBUG\n\tprintk(KERN_DEBUG PREFIX \"same in slot %i\\n\", rc);\n#endif\n\tmlc->serio_map[rc].di_revmap = mlc->ddi;\n\thil_mlc_clean_serio_map(mlc);\n\treturn 0;\n\n err:\n\tprintk(KERN_ERR PREFIX \"Residual device slots exhausted, close some serios!\\n\");\n\treturn 1;\n}\n\n \nstatic int hilse_init_lcv(hil_mlc *mlc, int unused)\n{\n\ttime64_t now = ktime_get_seconds();\n\n\tif (mlc->lcv && (now - mlc->lcv_time) < 5)\n\t\treturn -1;\n\n\tmlc->lcv_time = now;\n\tmlc->lcv = 0;\n\n\treturn 0;\n}\n\nstatic int hilse_inc_lcv(hil_mlc *mlc, int lim)\n{\n\treturn mlc->lcv++ >= lim ? -1 : 0;\n}\n\n#if 0\nstatic int hilse_set_lcv(hil_mlc *mlc, int val)\n{\n\tmlc->lcv = val;\n\n\treturn 0;\n}\n#endif\n\n \nstatic int hilse_set_ddi(hil_mlc *mlc, int val)\n{\n\tmlc->ddi = val;\n\thil_mlc_clear_di_map(mlc, val + 1);\n\n\treturn 0;\n}\n\nstatic int hilse_dec_ddi(hil_mlc *mlc, int unused)\n{\n\tmlc->ddi--;\n\tif (mlc->ddi <= -1) {\n\t\tmlc->ddi = -1;\n\t\thil_mlc_clear_di_map(mlc, 0);\n\t\treturn -1;\n\t}\n\thil_mlc_clear_di_map(mlc, mlc->ddi + 1);\n\n\treturn 0;\n}\n\nstatic int hilse_inc_ddi(hil_mlc *mlc, int unused)\n{\n\tBUG_ON(mlc->ddi >= 6);\n\tmlc->ddi++;\n\n\treturn 0;\n}\n\nstatic int hilse_take_idd(hil_mlc *mlc, int unused)\n{\n\tint i;\n\n\t \n\tif (mlc->ipacket[0] & HIL_PKT_CMD)\n\t\tgoto bail;\n\n\t \n\tfor (i = 1; i < 16; i++) {\n\t\tif (((mlc->ipacket[i] & HIL_PKT_ADDR_MASK) ==\n\t\t     (mlc->ipacket[0] & HIL_PKT_ADDR_MASK)) &&\n\t\t    (mlc->ipacket[i] & HIL_PKT_CMD) &&\n\t\t    ((mlc->ipacket[i] & HIL_PKT_DATA_MASK) == HIL_CMD_IDD))\n\t\t\tbreak;\n\t}\n\tif (i > 15)\n\t\tgoto bail;\n\n\t \n\twhile (++i < 16)\n\t\tif (mlc->ipacket[i])\n\t\t\tbreak;\n\n\tif (i < 16)\n\t\tgoto bail;\n\n\tfor (i = 0; i < 16; i++)\n\t\tmlc->di_scratch.idd[i] =\n\t\t\tmlc->ipacket[i] & HIL_PKT_DATA_MASK;\n\n\t \n\tif (mlc->di_scratch.idd[1] & HIL_IDD_HEADER_RSC)\n\t\treturn HILSEN_NEXT;\n\n\tif (mlc->di_scratch.idd[1] & HIL_IDD_HEADER_EXD)\n\t\treturn HILSEN_DOWN | 4;\n\n\treturn 0;\n\n bail:\n\tmlc->ddi--;\n\n\treturn -1;  \n}\n\nstatic int hilse_take_rsc(hil_mlc *mlc, int unused)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tmlc->di_scratch.rsc[i] =\n\t\t\tmlc->ipacket[i] & HIL_PKT_DATA_MASK;\n\n\t \n\tif (mlc->di_scratch.idd[1] & HIL_IDD_HEADER_EXD)\n\t\treturn HILSEN_NEXT;\n\n\treturn 0;\n}\n\nstatic int hilse_take_exd(hil_mlc *mlc, int unused)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tmlc->di_scratch.exd[i] =\n\t\t\tmlc->ipacket[i] & HIL_PKT_DATA_MASK;\n\n\t \n\tif (mlc->di_scratch.exd[0] & HIL_EXD_HEADER_RNM)\n\t\treturn HILSEN_NEXT;\n\n\treturn 0;\n}\n\nstatic int hilse_take_rnm(hil_mlc *mlc, int unused)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tmlc->di_scratch.rnm[i] =\n\t\t\tmlc->ipacket[i] & HIL_PKT_DATA_MASK;\n\n\tprintk(KERN_INFO PREFIX \"Device name gotten: %16s\\n\",\n\t\t\tmlc->di_scratch.rnm);\n\n\treturn 0;\n}\n\nstatic int hilse_operate(hil_mlc *mlc, int repoll)\n{\n\n\tif (mlc->opercnt == 0)\n\t\thil_mlcs_probe = 0;\n\tmlc->opercnt = 1;\n\n\thil_mlc_send_polls(mlc);\n\n\tif (!hil_mlcs_probe)\n\t\treturn 0;\n\thil_mlcs_probe = 0;\n\tmlc->opercnt = 0;\n\treturn 1;\n}\n\n#define FUNC(funct, funct_arg, zero_rc, neg_rc, pos_rc) \\\n{ HILSE_FUNC,\t\t{ .func = funct }, funct_arg, zero_rc, neg_rc, pos_rc },\n#define OUT(pack) \\\n{ HILSE_OUT,\t\t{ .packet = pack }, 0, HILSEN_NEXT, HILSEN_DOZE, 0 },\n#define CTS \\\n{ HILSE_CTS,\t\t{ .packet = 0    }, 0, HILSEN_NEXT | HILSEN_SCHED | HILSEN_BREAK, HILSEN_DOZE, 0 },\n#define EXPECT(comp, to, got, got_wrong, timed_out) \\\n{ HILSE_EXPECT,\t\t{ .packet = comp }, to, got, got_wrong, timed_out },\n#define EXPECT_LAST(comp, to, got, got_wrong, timed_out) \\\n{ HILSE_EXPECT_LAST,\t{ .packet = comp }, to, got, got_wrong, timed_out },\n#define EXPECT_DISC(comp, to, got, got_wrong, timed_out) \\\n{ HILSE_EXPECT_DISC,\t{ .packet = comp }, to, got, got_wrong, timed_out },\n#define IN(to, got, got_error, timed_out) \\\n{ HILSE_IN,\t\t{ .packet = 0    }, to, got, got_error, timed_out },\n#define OUT_DISC(pack) \\\n{ HILSE_OUT_DISC,\t{ .packet = pack }, 0, 0, 0, 0 },\n#define OUT_LAST(pack) \\\n{ HILSE_OUT_LAST,\t{ .packet = pack }, 0, 0, 0, 0 },\n\nstatic const struct hilse_node hil_mlc_se[HILSEN_END] = {\n\n\t \n\tFUNC(hilse_init_lcv, 0,\tHILSEN_NEXT,\tHILSEN_SLEEP,\t0)\n\n\t \n\tFUNC(hilse_inc_lcv, 10,\tHILSEN_NEXT,\tHILSEN_START,  0)\n\tOUT(HIL_CTRL_ONLY)\t\t\t \n\tCTS\n\n#define TEST_PACKET(x) \\\n(HIL_PKT_CMD | (x << HIL_PKT_ADDR_SHIFT) | x << 4 | x)\n\n\tOUT(HIL_DO_ALTER_CTRL | HIL_CTRL_TEST | TEST_PACKET(0x5))\n\tEXPECT(HIL_ERR_INT | TEST_PACKET(0x5),\n\t       2000,\t\tHILSEN_NEXT,\tHILSEN_RESTART,\tHILSEN_RESTART)\n\tOUT(HIL_DO_ALTER_CTRL | HIL_CTRL_TEST | TEST_PACKET(0xa))\n\tEXPECT(HIL_ERR_INT | TEST_PACKET(0xa),\n\t       2000,\t\tHILSEN_NEXT,\tHILSEN_RESTART,\tHILSEN_RESTART)\n\tOUT(HIL_CTRL_ONLY | 0)\t\t\t \n\n\t \n\tFUNC(hilse_init_lcv, 0,\tHILSEN_NEXT,\tHILSEN_SLEEP,\t0)\n\n\t \n\tFUNC(hilse_inc_lcv, 10,\tHILSEN_NEXT,\tHILSEN_START,\t0)\n\tFUNC(hilse_set_ddi, -1,\tHILSEN_NEXT,\t0,\t\t0)\n\tOUT(HIL_PKT_CMD | HIL_CMD_DHR)\n\tIN(300000,\t\tHILSEN_DHR2,\tHILSEN_DHR2,\tHILSEN_NEXT)\n\n\t \n\tOUT(HIL_PKT_CMD | HIL_CMD_IFC)\n\tEXPECT(HIL_PKT_CMD | HIL_CMD_IFC | HIL_ERR_INT,\n\t       20000,\t\tHILSEN_DISC,\tHILSEN_DHR2,\tHILSEN_NEXT )\n\n\t \n\n\t \n\tFUNC(hilse_dec_ddi, 0,\tHILSEN_NEXT,\tHILSEN_ACF,\t0)\n\tFUNC(hilse_inc_ddi, 0,\tHILSEN_NEXT,\t0,\t\t0)\n\n\t \n\tOUT_LAST(HIL_CMD_ELB)\n\tEXPECT_LAST(HIL_CMD_ELB | HIL_ERR_INT,\n\t\t    20000,\tHILSEN_REPOLL,\tHILSEN_DSR,\tHILSEN_NEXT)\n\tFUNC(hilse_dec_ddi, 0,\tHILSEN_HEAL,\tHILSEN_NEXT,\t0)\n\n\t \n\tFUNC(hilse_init_lcv, 0,\tHILSEN_NEXT,\tHILSEN_DOZE,\t0)\n\n\t \n\tFUNC(hilse_inc_lcv, 10,\tHILSEN_NEXT,\tHILSEN_START,\t0)\n\tOUT(HIL_PKT_CMD | HIL_CMD_ACF | 1)\n\tIN(20000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_NEXT)\n\n\t \n\tOUT_DISC(HIL_PKT_CMD | HIL_CMD_ELB)\n\tEXPECT_DISC(HIL_PKT_CMD | HIL_CMD_ELB | HIL_ERR_INT,\n\t       20000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_DSR)\n\n\t \n\t \n\tOUT_DISC(HIL_PKT_CMD | HIL_CMD_IDD)\n\tEXPECT_DISC(HIL_PKT_CMD | HIL_CMD_IDD | HIL_ERR_INT,\n\t       20000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_START)\n\tFUNC(hilse_inc_ddi,  0,\tHILSEN_NEXT,\tHILSEN_START,\t0)\n\tFUNC(hilse_take_idd, 0,\tHILSEN_MATCH,\tHILSEN_IFCACF,\tHILSEN_FOLLOW)\n\tOUT_LAST(HIL_PKT_CMD | HIL_CMD_RSC)\n\tEXPECT_LAST(HIL_PKT_CMD | HIL_CMD_RSC | HIL_ERR_INT,\n\t       30000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_DSR)\n\tFUNC(hilse_take_rsc, 0,\tHILSEN_MATCH,\t0,\t\tHILSEN_FOLLOW)\n\tOUT_LAST(HIL_PKT_CMD | HIL_CMD_EXD)\n\tEXPECT_LAST(HIL_PKT_CMD | HIL_CMD_EXD | HIL_ERR_INT,\n\t       30000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_DSR)\n\tFUNC(hilse_take_exd, 0,\tHILSEN_MATCH,\t0,\t\tHILSEN_FOLLOW)\n\tOUT_LAST(HIL_PKT_CMD | HIL_CMD_RNM)\n\tEXPECT_LAST(HIL_PKT_CMD | HIL_CMD_RNM | HIL_ERR_INT,\n\t       30000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_DSR)\n\tFUNC(hilse_take_rnm, 0, HILSEN_MATCH,\t0,\t\t0)\n\n\t \n\tFUNC(hilse_match, 0,\tHILSEN_NEXT,\tHILSEN_NEXT,\t  0)\n\n\t \n\tOUT(HIL_PKT_CMD | HIL_CMD_POL)\n\tEXPECT(HIL_PKT_CMD | HIL_CMD_POL | HIL_ERR_INT,\n\t       20000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_NEXT)\n\tFUNC(hilse_operate, 0,\tHILSEN_OPERATE,\tHILSEN_IFC,\tHILSEN_NEXT)\n\n\t \n\tOUT_LAST(HIL_PKT_CMD | HIL_CMD_EPT)\n\tIN(10000,\t\tHILSEN_DISC,\tHILSEN_DSR,\tHILSEN_NEXT)\n\tOUT_DISC(HIL_PKT_CMD | HIL_CMD_ELB)\n\tIN(10000,\t\tHILSEN_DISC,\tHILSEN_DSR,\tHILSEN_NEXT)\n\tOUT(HIL_PKT_CMD | HIL_CMD_ACF | 1)\n\tIN(10000,\t\tHILSEN_DISC0,\tHILSEN_DSR,\tHILSEN_NEXT)\n\tOUT_LAST(HIL_PKT_CMD | HIL_CMD_ELB)\n\tIN(10000,\t\tHILSEN_OPERATE,\tHILSEN_DSR,\tHILSEN_DSR)\n\n\t \n\tFUNC(hilse_set_ddi, -1,\tHILSEN_NEXT,\t0,\t\t0)\n\tOUT(HIL_PKT_CMD | HIL_CMD_DSR)\n\tIN(20000,\t\tHILSEN_DHR,\tHILSEN_DHR,\tHILSEN_IFC)\n\n\t \n\tOUT(HIL_PKT_CMD | HIL_CMD_RPL)\n\tEXPECT(HIL_PKT_CMD | HIL_CMD_RPL | HIL_ERR_INT,\n\t       20000,\t\tHILSEN_NEXT,\tHILSEN_DSR,\tHILSEN_NEXT)\n\tFUNC(hilse_operate, 1,\tHILSEN_OPERATE,\tHILSEN_IFC,\tHILSEN_PROBE)\n\n\t \n\tOUT(HIL_PKT_CMD | HIL_CMD_IFC)\n\tEXPECT(HIL_PKT_CMD | HIL_CMD_IFC | HIL_ERR_INT,\n\t       20000,\t\tHILSEN_ACF2,\tHILSEN_DHR2,\tHILSEN_HEAL)\n\n\t \n};\n\nstatic inline void hilse_setup_input(hil_mlc *mlc, const struct hilse_node *node)\n{\n\n\tswitch (node->act) {\n\tcase HILSE_EXPECT_DISC:\n\t\tmlc->imatch = node->object.packet;\n\t\tmlc->imatch |= ((mlc->ddi + 2) << HIL_PKT_ADDR_SHIFT);\n\t\tbreak;\n\tcase HILSE_EXPECT_LAST:\n\t\tmlc->imatch = node->object.packet;\n\t\tmlc->imatch |= ((mlc->ddi + 1) << HIL_PKT_ADDR_SHIFT);\n\t\tbreak;\n\tcase HILSE_EXPECT:\n\t\tmlc->imatch = node->object.packet;\n\t\tbreak;\n\tcase HILSE_IN:\n\t\tmlc->imatch = 0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tmlc->istarted = 1;\n\tmlc->intimeout = usecs_to_jiffies(node->arg);\n\tmlc->instart = jiffies;\n\tmlc->icount = 15;\n\tmemset(mlc->ipacket, 0, 16 * sizeof(hil_packet));\n\tBUG_ON(down_trylock(&mlc->isem));\n}\n\n#ifdef HIL_MLC_DEBUG\nstatic int doze;\nstatic int seidx;  \n#endif\n\nstatic int hilse_donode(hil_mlc *mlc)\n{\n\tconst struct hilse_node *node;\n\tint nextidx = 0;\n\tint sched_long = 0;\n\tunsigned long flags;\n\n#ifdef HIL_MLC_DEBUG\n\tif (mlc->seidx && mlc->seidx != seidx &&\n\t    mlc->seidx != 41 && mlc->seidx != 42 && mlc->seidx != 43) {\n\t\tprintk(KERN_DEBUG PREFIX \"z%i \\n {%i}\", doze, mlc->seidx);\n\t\tdoze = 0;\n\t}\n\n\tseidx = mlc->seidx;\n#endif\n\tnode = hil_mlc_se + mlc->seidx;\n\n\tswitch (node->act) {\n\t\tint rc;\n\t\thil_packet pack;\n\n\tcase HILSE_FUNC:\n\t\tBUG_ON(node->object.func == NULL);\n\t\trc = node->object.func(mlc, node->arg);\n\t\tnextidx = (rc > 0) ? node->ugly :\n\t\t\t((rc < 0) ? node->bad : node->good);\n\t\tif (nextidx == HILSEN_FOLLOW)\n\t\t\tnextidx = rc;\n\t\tbreak;\n\n\tcase HILSE_EXPECT_LAST:\n\tcase HILSE_EXPECT_DISC:\n\tcase HILSE_EXPECT:\n\tcase HILSE_IN:\n\t\t \n\t\twrite_lock_irqsave(&mlc->lock, flags);\n\t\trc = mlc->in(mlc, node->arg);\n\t\tif (rc == 2)  {\n\t\t\tnextidx = HILSEN_DOZE;\n\t\t\tsched_long = 1;\n\t\t\twrite_unlock_irqrestore(&mlc->lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rc == 1)\n\t\t\tnextidx = node->ugly;\n\t\telse if (rc == 0)\n\t\t\tnextidx = node->good;\n\t\telse\n\t\t\tnextidx = node->bad;\n\t\tmlc->istarted = 0;\n\t\twrite_unlock_irqrestore(&mlc->lock, flags);\n\t\tbreak;\n\n\tcase HILSE_OUT_LAST:\n\t\twrite_lock_irqsave(&mlc->lock, flags);\n\t\tpack = node->object.packet;\n\t\tpack |= ((mlc->ddi + 1) << HIL_PKT_ADDR_SHIFT);\n\t\tgoto out;\n\n\tcase HILSE_OUT_DISC:\n\t\twrite_lock_irqsave(&mlc->lock, flags);\n\t\tpack = node->object.packet;\n\t\tpack |= ((mlc->ddi + 2) << HIL_PKT_ADDR_SHIFT);\n\t\tgoto out;\n\n\tcase HILSE_OUT:\n\t\twrite_lock_irqsave(&mlc->lock, flags);\n\t\tpack = node->object.packet;\n\tout:\n\t\tif (!mlc->istarted) {\n\t\t\t \n\t\t\tif ((node + 1)->act & HILSE_IN)\n\t\t\t\thilse_setup_input(mlc, node + 1);\n\t\t}\n\n\t\twrite_unlock_irqrestore(&mlc->lock, flags);\n\n\t\tif (down_trylock(&mlc->osem)) {\n\t\t\tnextidx = HILSEN_DOZE;\n\t\t\tbreak;\n\t\t}\n\t\tup(&mlc->osem);\n\n\t\twrite_lock_irqsave(&mlc->lock, flags);\n\t\tif (!mlc->ostarted) {\n\t\t\tmlc->ostarted = 1;\n\t\t\tmlc->opacket = pack;\n\t\t\trc = mlc->out(mlc);\n\t\t\tnextidx = HILSEN_DOZE;\n\t\t\twrite_unlock_irqrestore(&mlc->lock, flags);\n\t\t\tif (rc) {\n\t\t\t\thil_mlc_stop = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmlc->ostarted = 0;\n\t\tmlc->instart = jiffies;\n\t\twrite_unlock_irqrestore(&mlc->lock, flags);\n\t\tnextidx = HILSEN_NEXT;\n\t\tbreak;\n\n\tcase HILSE_CTS:\n\t\twrite_lock_irqsave(&mlc->lock, flags);\n\t\trc = mlc->cts(mlc);\n\t\tnextidx = rc ? node->bad : node->good;\n\t\twrite_unlock_irqrestore(&mlc->lock, flags);\n\t\tif (rc) {\n\t\t\thil_mlc_stop = 1;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n#ifdef HIL_MLC_DEBUG\n\tif (nextidx == HILSEN_DOZE)\n\t\tdoze++;\n#endif\n\n\twhile (nextidx & HILSEN_SCHED) {\n\t\tunsigned long now = jiffies;\n\n\t\tif (!sched_long)\n\t\t\tgoto sched;\n\n\t\tif (time_after(now, mlc->instart + mlc->intimeout))\n\t\t\t goto sched;\n\t\tmod_timer(&hil_mlcs_kicker, mlc->instart + mlc->intimeout);\n\t\tbreak;\n\tsched:\n\t\ttasklet_schedule(&hil_mlcs_tasklet);\n\t\tbreak;\n\t}\n\n\tif (nextidx & HILSEN_DOWN)\n\t\tmlc->seidx += nextidx & HILSEN_MASK;\n\telse if (nextidx & HILSEN_UP)\n\t\tmlc->seidx -= nextidx & HILSEN_MASK;\n\telse\n\t\tmlc->seidx = nextidx & HILSEN_MASK;\n\n\tif (nextidx & HILSEN_BREAK)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void hil_mlcs_process(unsigned long unused)\n{\n\tstruct list_head *tmp;\n\n\tread_lock(&hil_mlcs_lock);\n\tlist_for_each(tmp, &hil_mlcs) {\n\t\tstruct hil_mlc *mlc = list_entry(tmp, hil_mlc, list);\n\t\twhile (hilse_donode(mlc) == 0) {\n#ifdef HIL_MLC_DEBUG\n\t\t\tif (mlc->seidx != 41 &&\n\t\t\t    mlc->seidx != 42 &&\n\t\t\t    mlc->seidx != 43)\n\t\t\t\tprintk(KERN_DEBUG PREFIX \" + \");\n#endif\n\t\t}\n\t}\n\tread_unlock(&hil_mlcs_lock);\n}\n\n \n\nstatic void hil_mlcs_timer(struct timer_list *unused)\n{\n\tif (hil_mlc_stop) {\n\t\t \n\t\tpr_warn(PREFIX \"HIL seems stuck - Disabling HIL MLC.\\n\");\n\t\treturn;\n\t}\n\n\thil_mlcs_probe = 1;\n\ttasklet_schedule(&hil_mlcs_tasklet);\n\t \n\tif (!timer_pending(&hil_mlcs_kicker))\n\t\tmod_timer(&hil_mlcs_kicker, jiffies + HZ);\n}\n\n \n\nstatic int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t \n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}\n\nstatic int hil_mlc_serio_open(struct serio *serio)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\n\tif (serio_get_drvdata(serio) != NULL)\n\t\treturn -EBUSY;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\treturn 0;\n}\n\nstatic void hil_mlc_serio_close(struct serio *serio)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tserio_set_drvdata(serio, NULL);\n\tserio->drv = NULL;\n\t \n}\n\nstatic const struct serio_device_id hil_mlc_serio_id = {\n\t.type = SERIO_HIL_MLC,\n\t.proto = SERIO_HIL,\n\t.extra = SERIO_ANY,\n\t.id = SERIO_ANY,\n};\n\nint hil_mlc_register(hil_mlc *mlc)\n{\n\tint i;\n\tunsigned long flags;\n\n\tBUG_ON(mlc == NULL);\n\n\tmlc->istarted = 0;\n\tmlc->ostarted = 0;\n\n\trwlock_init(&mlc->lock);\n\tsema_init(&mlc->osem, 1);\n\n\tsema_init(&mlc->isem, 1);\n\tmlc->icount = -1;\n\tmlc->imatch = 0;\n\n\tmlc->opercnt = 0;\n\n\tsema_init(&(mlc->csem), 0);\n\n\thil_mlc_clear_di_scratch(mlc);\n\thil_mlc_clear_di_map(mlc, 0);\n\tfor (i = 0; i < HIL_MLC_DEVMEM; i++) {\n\t\tstruct serio *mlc_serio;\n\t\thil_mlc_copy_di_scratch(mlc, i);\n\t\tmlc_serio = kzalloc(sizeof(*mlc_serio), GFP_KERNEL);\n\t\tmlc->serio[i] = mlc_serio;\n\t\tif (!mlc->serio[i]) {\n\t\t\tfor (; i >= 0; i--)\n\t\t\t\tkfree(mlc->serio[i]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsnprintf(mlc_serio->name, sizeof(mlc_serio->name)-1, \"HIL_SERIO%d\", i);\n\t\tsnprintf(mlc_serio->phys, sizeof(mlc_serio->phys)-1, \"HIL%d\", i);\n\t\tmlc_serio->id\t\t\t= hil_mlc_serio_id;\n\t\tmlc_serio->id.id\t\t= i;  \n\t\tmlc_serio->write\t\t= hil_mlc_serio_write;\n\t\tmlc_serio->open\t\t\t= hil_mlc_serio_open;\n\t\tmlc_serio->close\t\t= hil_mlc_serio_close;\n\t\tmlc_serio->port_data\t\t= &(mlc->serio_map[i]);\n\t\tmlc->serio_map[i].mlc\t\t= mlc;\n\t\tmlc->serio_map[i].didx\t\t= i;\n\t\tmlc->serio_map[i].di_revmap\t= -1;\n\t\tmlc->serio_opacket[i]\t\t= 0;\n\t\tmlc->serio_oidx[i]\t\t= 0;\n\t\tserio_register_port(mlc_serio);\n\t}\n\n\tmlc->tasklet = &hil_mlcs_tasklet;\n\n\twrite_lock_irqsave(&hil_mlcs_lock, flags);\n\tlist_add_tail(&mlc->list, &hil_mlcs);\n\tmlc->seidx = HILSEN_START;\n\twrite_unlock_irqrestore(&hil_mlcs_lock, flags);\n\n\ttasklet_schedule(&hil_mlcs_tasklet);\n\treturn 0;\n}\n\nint hil_mlc_unregister(hil_mlc *mlc)\n{\n\tstruct list_head *tmp;\n\tunsigned long flags;\n\tint i;\n\n\tBUG_ON(mlc == NULL);\n\n\twrite_lock_irqsave(&hil_mlcs_lock, flags);\n\tlist_for_each(tmp, &hil_mlcs)\n\t\tif (list_entry(tmp, hil_mlc, list) == mlc)\n\t\t\tgoto found;\n\n\t \n\twrite_unlock_irqrestore(&hil_mlcs_lock, flags);\n\ttasklet_schedule(&hil_mlcs_tasklet);\n\treturn -ENODEV;\n\n found:\n\tlist_del(tmp);\n\twrite_unlock_irqrestore(&hil_mlcs_lock, flags);\n\n\tfor (i = 0; i < HIL_MLC_DEVMEM; i++) {\n\t\tserio_unregister_port(mlc->serio[i]);\n\t\tmlc->serio[i] = NULL;\n\t}\n\n\ttasklet_schedule(&hil_mlcs_tasklet);\n\treturn 0;\n}\n\n \n\nstatic int __init hil_mlc_init(void)\n{\n\ttimer_setup(&hil_mlcs_kicker, &hil_mlcs_timer, 0);\n\tmod_timer(&hil_mlcs_kicker, jiffies + HZ);\n\n\ttasklet_enable(&hil_mlcs_tasklet);\n\n\treturn 0;\n}\n\nstatic void __exit hil_mlc_exit(void)\n{\n\tdel_timer_sync(&hil_mlcs_kicker);\n\ttasklet_kill(&hil_mlcs_tasklet);\n}\n\nmodule_init(hil_mlc_init);\nmodule_exit(hil_mlc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}