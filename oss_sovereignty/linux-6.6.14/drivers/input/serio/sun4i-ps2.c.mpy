{
  "module_name": "sun4i-ps2.c",
  "hash_id": "8e7c1d03a1822a89bbd10e252af28b2782f7a001893743a5b2c60c6b809b011f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/sun4i-ps2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#define DRIVER_NAME\t\t\"sun4i-ps2\"\n\n \n#define PS2_REG_GCTL\t\t0x00\t \n#define PS2_REG_DATA\t\t0x04\t \n#define PS2_REG_LCTL\t\t0x08\t \n#define PS2_REG_LSTS\t\t0x0C\t \n#define PS2_REG_FCTL\t\t0x10\t \n#define PS2_REG_FSTS\t\t0x14\t \n#define PS2_REG_CLKDR\t\t0x18\t \n\n \n#define PS2_GCTL_INTFLAG\tBIT(4)\n#define PS2_GCTL_INTEN\t\tBIT(3)\n#define PS2_GCTL_RESET\t\tBIT(2)\n#define PS2_GCTL_MASTER\t\tBIT(1)\n#define PS2_GCTL_BUSEN\t\tBIT(0)\n\n \n#define PS2_LCTL_NOACK\t\tBIT(18)\n#define PS2_LCTL_TXDTOEN\tBIT(8)\n#define PS2_LCTL_STOPERREN\tBIT(3)\n#define PS2_LCTL_ACKERREN\tBIT(2)\n#define PS2_LCTL_PARERREN\tBIT(1)\n#define PS2_LCTL_RXDTOEN\tBIT(0)\n\n \n#define PS2_LSTS_TXTDO\t\tBIT(8)\n#define PS2_LSTS_STOPERR\tBIT(3)\n#define PS2_LSTS_ACKERR\t\tBIT(2)\n#define PS2_LSTS_PARERR\t\tBIT(1)\n#define PS2_LSTS_RXTDO\t\tBIT(0)\n\n#define PS2_LINE_ERROR_BIT \\\n\t(PS2_LSTS_TXTDO | PS2_LSTS_STOPERR | PS2_LSTS_ACKERR | \\\n\tPS2_LSTS_PARERR | PS2_LSTS_RXTDO)\n\n \n#define PS2_FCTL_TXRST\t\tBIT(17)\n#define PS2_FCTL_RXRST\t\tBIT(16)\n#define PS2_FCTL_TXUFIEN\tBIT(10)\n#define PS2_FCTL_TXOFIEN\tBIT(9)\n#define PS2_FCTL_TXRDYIEN\tBIT(8)\n#define PS2_FCTL_RXUFIEN\tBIT(2)\n#define PS2_FCTL_RXOFIEN\tBIT(1)\n#define PS2_FCTL_RXRDYIEN\tBIT(0)\n\n \n#define PS2_FSTS_TXUF\t\tBIT(10)\n#define PS2_FSTS_TXOF\t\tBIT(9)\n#define PS2_FSTS_TXRDY\t\tBIT(8)\n#define PS2_FSTS_RXUF\t\tBIT(2)\n#define PS2_FSTS_RXOF\t\tBIT(1)\n#define PS2_FSTS_RXRDY\t\tBIT(0)\n\n#define PS2_FIFO_ERROR_BIT \\\n\t(PS2_FSTS_TXUF | PS2_FSTS_TXOF | PS2_FSTS_RXUF | PS2_FSTS_RXOF)\n\n#define PS2_SAMPLE_CLK\t\t1000000\n#define PS2_SCLK\t\t125000\n\nstruct sun4i_ps2data {\n\tstruct serio *serio;\n\tstruct device *dev;\n\n\t \n\tvoid __iomem\t*reg_base;\n\n\t \n\tstruct clk\t*clk;\n\n\t \n\tspinlock_t\tlock;\n\tint\t\tirq;\n};\n\nstatic irqreturn_t sun4i_ps2_interrupt(int irq, void *dev_id)\n{\n\tstruct sun4i_ps2data *drvdata = dev_id;\n\tu32 intr_status;\n\tu32 fifo_status;\n\tunsigned char byte;\n\tunsigned int rxflags = 0;\n\tu32 rval;\n\n\tspin_lock(&drvdata->lock);\n\n\t \n\tintr_status  = readl(drvdata->reg_base + PS2_REG_LSTS);\n\tfifo_status  = readl(drvdata->reg_base + PS2_REG_FSTS);\n\n\t \n\tif (intr_status & PS2_LINE_ERROR_BIT) {\n\t\trxflags = (intr_status & PS2_LINE_ERROR_BIT) ? SERIO_FRAME : 0;\n\t\trxflags |= (intr_status & PS2_LSTS_PARERR) ? SERIO_PARITY : 0;\n\t\trxflags |= (intr_status & PS2_LSTS_PARERR) ? SERIO_TIMEOUT : 0;\n\n\t\trval = PS2_LSTS_TXTDO | PS2_LSTS_STOPERR | PS2_LSTS_ACKERR |\n\t\t\tPS2_LSTS_PARERR | PS2_LSTS_RXTDO;\n\t\twritel(rval, drvdata->reg_base + PS2_REG_LSTS);\n\t}\n\n\t \n\tif (fifo_status & PS2_FIFO_ERROR_BIT) {\n\t\trval = PS2_FSTS_TXUF | PS2_FSTS_TXOF | PS2_FSTS_TXRDY |\n\t\t\tPS2_FSTS_RXUF | PS2_FSTS_RXOF | PS2_FSTS_RXRDY;\n\t\twritel(rval, drvdata->reg_base + PS2_REG_FSTS);\n\t}\n\n\trval = (fifo_status >> 16) & 0x3;\n\twhile (rval--) {\n\t\tbyte = readl(drvdata->reg_base + PS2_REG_DATA) & 0xff;\n\t\tserio_interrupt(drvdata->serio, byte, rxflags);\n\t}\n\n\twritel(intr_status, drvdata->reg_base + PS2_REG_LSTS);\n\twritel(fifo_status, drvdata->reg_base + PS2_REG_FSTS);\n\n\tspin_unlock(&drvdata->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun4i_ps2_open(struct serio *serio)\n{\n\tstruct sun4i_ps2data *drvdata = serio->port_data;\n\tu32 src_clk = 0;\n\tu32 clk_scdf;\n\tu32 clk_pcdf;\n\tu32 rval;\n\tunsigned long flags;\n\n\t \n\trval = PS2_LCTL_STOPERREN | PS2_LCTL_ACKERREN\n\t\t| PS2_LCTL_PARERREN | PS2_LCTL_RXDTOEN;\n\twritel(rval, drvdata->reg_base + PS2_REG_LCTL);\n\n\t \n\trval = PS2_FCTL_TXRST | PS2_FCTL_RXRST | PS2_FCTL_TXUFIEN\n\t\t| PS2_FCTL_TXOFIEN | PS2_FCTL_RXUFIEN\n\t\t| PS2_FCTL_RXOFIEN | PS2_FCTL_RXRDYIEN;\n\n\twritel(rval, drvdata->reg_base + PS2_REG_FCTL);\n\n\tsrc_clk = clk_get_rate(drvdata->clk);\n\t \n\tclk_scdf = src_clk / PS2_SAMPLE_CLK - 1;\n\tclk_pcdf = PS2_SAMPLE_CLK / PS2_SCLK - 1;\n\trval = (clk_scdf << 8) | clk_pcdf;\n\twritel(rval, drvdata->reg_base + PS2_REG_CLKDR);\n\n\t \n\trval = PS2_GCTL_RESET | PS2_GCTL_INTEN | PS2_GCTL_MASTER\n\t\t| PS2_GCTL_BUSEN;\n\n\tspin_lock_irqsave(&drvdata->lock, flags);\n\twritel(rval, drvdata->reg_base + PS2_REG_GCTL);\n\tspin_unlock_irqrestore(&drvdata->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sun4i_ps2_close(struct serio *serio)\n{\n\tstruct sun4i_ps2data *drvdata = serio->port_data;\n\tu32 rval;\n\n\t \n\trval = readl(drvdata->reg_base + PS2_REG_GCTL);\n\twritel(rval & ~(PS2_GCTL_INTEN), drvdata->reg_base + PS2_REG_GCTL);\n\n\tsynchronize_irq(drvdata->irq);\n}\n\nstatic int sun4i_ps2_write(struct serio *serio, unsigned char val)\n{\n\tunsigned long expire = jiffies + msecs_to_jiffies(10000);\n\tstruct sun4i_ps2data *drvdata = serio->port_data;\n\n\tdo {\n\t\tif (readl(drvdata->reg_base + PS2_REG_FSTS) & PS2_FSTS_TXRDY) {\n\t\t\twritel(val, drvdata->reg_base + PS2_REG_DATA);\n\t\t\treturn 0;\n\t\t}\n\t} while (time_before(jiffies, expire));\n\n\treturn SERIO_TIMEOUT;\n}\n\nstatic int sun4i_ps2_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;  \n\tstruct sun4i_ps2data *drvdata;\n\tstruct serio *serio;\n\tstruct device *dev = &pdev->dev;\n\tint error;\n\n\tdrvdata = kzalloc(sizeof(struct sun4i_ps2data), GFP_KERNEL);\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!drvdata || !serio) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tspin_lock_init(&drvdata->lock);\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"failed to locate registers\\n\");\n\t\terror = -ENXIO;\n\t\tgoto err_free_mem;\n\t}\n\n\tdrvdata->reg_base = ioremap(res->start, resource_size(res));\n\tif (!drvdata->reg_base) {\n\t\tdev_err(dev, \"failed to map registers\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tdrvdata->clk = clk_get(dev, NULL);\n\tif (IS_ERR(drvdata->clk)) {\n\t\terror = PTR_ERR(drvdata->clk);\n\t\tdev_err(dev, \"couldn't get clock %d\\n\", error);\n\t\tgoto err_ioremap;\n\t}\n\n\terror = clk_prepare_enable(drvdata->clk);\n\tif (error) {\n\t\tdev_err(dev, \"failed to enable clock %d\\n\", error);\n\t\tgoto err_clk;\n\t}\n\n\tserio->id.type = SERIO_8042;\n\tserio->write = sun4i_ps2_write;\n\tserio->open = sun4i_ps2_open;\n\tserio->close = sun4i_ps2_close;\n\tserio->port_data = drvdata;\n\tserio->dev.parent = dev;\n\tstrscpy(serio->name, dev_name(dev), sizeof(serio->name));\n\tstrscpy(serio->phys, dev_name(dev), sizeof(serio->phys));\n\n\t \n\twritel(0, drvdata->reg_base + PS2_REG_GCTL);\n\n\t \n\tdrvdata->irq = platform_get_irq(pdev, 0);\n\tif (drvdata->irq < 0) {\n\t\terror = drvdata->irq;\n\t\tgoto err_disable_clk;\n\t}\n\n\tdrvdata->serio = serio;\n\tdrvdata->dev = dev;\n\n\terror = request_irq(drvdata->irq, sun4i_ps2_interrupt, 0,\n\t\t\t    DRIVER_NAME, drvdata);\n\tif (error) {\n\t\tdev_err(drvdata->dev, \"failed to allocate interrupt %d: %d\\n\",\n\t\t\tdrvdata->irq, error);\n\t\tgoto err_disable_clk;\n\t}\n\n\tserio_register_port(serio);\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\t \n\nerr_disable_clk:\n\tclk_disable_unprepare(drvdata->clk);\nerr_clk:\n\tclk_put(drvdata->clk);\nerr_ioremap:\n\tiounmap(drvdata->reg_base);\nerr_free_mem:\n\tkfree(serio);\n\tkfree(drvdata);\n\treturn error;\n}\n\nstatic int sun4i_ps2_remove(struct platform_device *pdev)\n{\n\tstruct sun4i_ps2data *drvdata = platform_get_drvdata(pdev);\n\n\tserio_unregister_port(drvdata->serio);\n\n\tfree_irq(drvdata->irq, drvdata);\n\n\tclk_disable_unprepare(drvdata->clk);\n\tclk_put(drvdata->clk);\n\n\tiounmap(drvdata->reg_base);\n\n\tkfree(drvdata);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun4i_ps2_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-ps2\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, sun4i_ps2_match);\n\nstatic struct platform_driver sun4i_ps2_driver = {\n\t.probe\t\t= sun4i_ps2_probe,\n\t.remove\t\t= sun4i_ps2_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = sun4i_ps2_match,\n\t},\n};\nmodule_platform_driver(sun4i_ps2_driver);\n\nMODULE_AUTHOR(\"Vishnu Patekar <vishnupatekar0510@gmail.com>\");\nMODULE_AUTHOR(\"Aaron.maoye <leafy.myeh@newbietech.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10/Sun4i PS/2 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}