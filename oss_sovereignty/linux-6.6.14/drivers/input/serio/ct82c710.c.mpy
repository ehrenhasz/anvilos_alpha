{
  "module_name": "ct82c710.c",
  "hash_id": "79b95845ad0c2e77aec84decdd51b406d713b4192eac341f31ba436410130e9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/ct82c710.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/serio.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"82C710 C&T mouse port chip driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define CT82C710_DEV_IDLE     0x01\t\t \n#define CT82C710_RX_FULL      0x02\t\t \n#define CT82C710_TX_IDLE      0x04\t\t \n#define CT82C710_RESET        0x08\t\t \n#define CT82C710_INTS_ON      0x10\t\t \n#define CT82C710_ERROR_FLAG   0x20\t\t \n#define CT82C710_CLEAR        0x40\t\t \n#define CT82C710_ENABLE       0x80\t\t \n\n#define CT82C710_IRQ          12\n\n#define CT82C710_DATA         ct82c710_iores.start\n#define CT82C710_STATUS       (ct82c710_iores.start + 1)\n\nstatic struct serio *ct82c710_port;\nstatic struct platform_device *ct82c710_device;\nstatic struct resource ct82c710_iores;\n\n \n\nstatic irqreturn_t ct82c710_interrupt(int cpl, void *dev_id)\n{\n\treturn serio_interrupt(ct82c710_port, inb(CT82C710_DATA), 0);\n}\n\n \n\nstatic int ct82c170_wait(void)\n{\n\tint timeout = 60000;\n\n\twhile ((inb(CT82C710_STATUS) & (CT82C710_RX_FULL | CT82C710_TX_IDLE | CT82C710_DEV_IDLE))\n\t\t       != (CT82C710_DEV_IDLE | CT82C710_TX_IDLE) && timeout) {\n\n\t\tif (inb_p(CT82C710_STATUS) & CT82C710_RX_FULL) inb_p(CT82C710_DATA);\n\n\t\tudelay(1);\n\t\ttimeout--;\n\t}\n\n\treturn !timeout;\n}\n\nstatic void ct82c710_close(struct serio *serio)\n{\n\tif (ct82c170_wait())\n\t\tprintk(KERN_WARNING \"ct82c710.c: Device busy in close()\\n\");\n\n\toutb_p(inb_p(CT82C710_STATUS) & ~(CT82C710_ENABLE | CT82C710_INTS_ON), CT82C710_STATUS);\n\n\tif (ct82c170_wait())\n\t\tprintk(KERN_WARNING \"ct82c710.c: Device busy in close()\\n\");\n\n\tfree_irq(CT82C710_IRQ, NULL);\n}\n\nstatic int ct82c710_open(struct serio *serio)\n{\n\tunsigned char status;\n\tint err;\n\n\terr = request_irq(CT82C710_IRQ, ct82c710_interrupt, 0, \"ct82c710\", NULL);\n\tif (err)\n\t\treturn err;\n\n\tstatus = inb_p(CT82C710_STATUS);\n\n\tstatus |= (CT82C710_ENABLE | CT82C710_RESET);\n\toutb_p(status, CT82C710_STATUS);\n\n\tstatus &= ~(CT82C710_RESET);\n\toutb_p(status, CT82C710_STATUS);\n\n\tstatus |= CT82C710_INTS_ON;\n\toutb_p(status, CT82C710_STATUS);\t \n\n\twhile (ct82c170_wait()) {\n\t\tprintk(KERN_ERR \"ct82c710: Device busy in open()\\n\");\n\t\tstatus &= ~(CT82C710_ENABLE | CT82C710_INTS_ON);\n\t\toutb_p(status, CT82C710_STATUS);\n\t\tfree_irq(CT82C710_IRQ, NULL);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int ct82c710_write(struct serio *port, unsigned char c)\n{\n\tif (ct82c170_wait()) return -1;\n\toutb_p(c, CT82C710_DATA);\n\treturn 0;\n}\n\n \n\nstatic int __init ct82c710_detect(void)\n{\n\toutb_p(0x55, 0x2fa);\t\t\t\t \n\toutb_p(0xaa, 0x3fa);\t\t\t\t \n\toutb_p(0x36, 0x3fa);\t\t\t\t \n\toutb_p(0xe4, 0x3fa);\t\t\t\t \n\toutb_p(0x1b, 0x2fa);\t\t\t\t \n\toutb_p(0x0f, 0x390);\t\t\t\t \n\tif (inb_p(0x391) != 0xe4)\t\t\t \n\t\treturn -ENODEV;\t\t\t\t \n\n\toutb_p(0x0d, 0x390);\t\t\t\t \n\tct82c710_iores.start = inb_p(0x391) << 2;\t \n\tct82c710_iores.end = ct82c710_iores.start + 1;\n\tct82c710_iores.flags = IORESOURCE_IO;\n\toutb_p(0x0f, 0x390);\n\toutb_p(0x0f, 0x391);\t\t\t\t \n\n\treturn 0;\n}\n\nstatic int ct82c710_probe(struct platform_device *dev)\n{\n\tct82c710_port = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!ct82c710_port)\n\t\treturn -ENOMEM;\n\n\tct82c710_port->id.type = SERIO_8042;\n\tct82c710_port->dev.parent = &dev->dev;\n\tct82c710_port->open = ct82c710_open;\n\tct82c710_port->close = ct82c710_close;\n\tct82c710_port->write = ct82c710_write;\n\tstrscpy(ct82c710_port->name, \"C&T 82c710 mouse port\",\n\t\tsizeof(ct82c710_port->name));\n\tsnprintf(ct82c710_port->phys, sizeof(ct82c710_port->phys),\n\t\t \"isa%16llx/serio0\", (unsigned long long)CT82C710_DATA);\n\n\tserio_register_port(ct82c710_port);\n\n\tprintk(KERN_INFO \"serio: C&T 82c710 mouse port at %#llx irq %d\\n\",\n\t\t(unsigned long long)CT82C710_DATA, CT82C710_IRQ);\n\n\treturn 0;\n}\n\nstatic int ct82c710_remove(struct platform_device *dev)\n{\n\tserio_unregister_port(ct82c710_port);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ct82c710_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ct82c710\",\n\t},\n\t.probe\t\t= ct82c710_probe,\n\t.remove\t\t= ct82c710_remove,\n};\n\n\nstatic int __init ct82c710_init(void)\n{\n\tint error;\n\n\terror = ct82c710_detect();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&ct82c710_driver);\n\tif (error)\n\t\treturn error;\n\n\tct82c710_device = platform_device_alloc(\"ct82c710\", -1);\n\tif (!ct82c710_device) {\n\t\terror = -ENOMEM;\n\t\tgoto err_unregister_driver;\n\t}\n\n\terror = platform_device_add_resources(ct82c710_device, &ct82c710_iores, 1);\n\tif (error)\n\t\tgoto err_free_device;\n\n\terror = platform_device_add(ct82c710_device);\n\tif (error)\n\t\tgoto err_free_device;\n\n\treturn 0;\n\n err_free_device:\n\tplatform_device_put(ct82c710_device);\n err_unregister_driver:\n\tplatform_driver_unregister(&ct82c710_driver);\n\treturn error;\n}\n\nstatic void __exit ct82c710_exit(void)\n{\n\tplatform_device_unregister(ct82c710_device);\n\tplatform_driver_unregister(&ct82c710_driver);\n}\n\nmodule_init(ct82c710_init);\nmodule_exit(ct82c710_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}