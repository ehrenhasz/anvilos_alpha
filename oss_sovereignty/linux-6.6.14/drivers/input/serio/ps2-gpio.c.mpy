{
  "module_name": "ps2-gpio.c",
  "hash_id": "88eb7b4c6464460f451733ae1fbcebc527a355ca7737cbc6e6b9086f2d5265cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/ps2-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/preempt.h>\n#include <linux/property.h>\n#include <linux/of.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/timekeeping.h>\n\n#define DRIVER_NAME\t\t\"ps2-gpio\"\n\n#define PS2_MODE_RX\t\t0\n#define PS2_MODE_TX\t\t1\n\n#define PS2_START_BIT\t\t0\n#define PS2_DATA_BIT0\t\t1\n#define PS2_DATA_BIT1\t\t2\n#define PS2_DATA_BIT2\t\t3\n#define PS2_DATA_BIT3\t\t4\n#define PS2_DATA_BIT4\t\t5\n#define PS2_DATA_BIT5\t\t6\n#define PS2_DATA_BIT6\t\t7\n#define PS2_DATA_BIT7\t\t8\n#define PS2_PARITY_BIT\t\t9\n#define PS2_STOP_BIT\t\t10\n#define PS2_ACK_BIT\t\t11\n\n#define PS2_DEV_RET_ACK\t\t0xfa\n#define PS2_DEV_RET_NACK\t0xfe\n\n#define PS2_CMD_RESEND\t\t0xfe\n\n \n#define PS2_CLK_FREQ_MIN_HZ\t\t10000\n#define PS2_CLK_FREQ_MAX_HZ\t\t16700\n#define PS2_CLK_MIN_INTERVAL_US\t\t((1000 * 1000) / PS2_CLK_FREQ_MAX_HZ)\n#define PS2_CLK_MAX_INTERVAL_US\t\t((1000 * 1000) / PS2_CLK_FREQ_MIN_HZ)\n#define PS2_IRQ_MIN_INTERVAL_US\t\t(PS2_CLK_MIN_INTERVAL_US - 20)\n#define PS2_IRQ_MAX_INTERVAL_US\t\t(PS2_CLK_MAX_INTERVAL_US + 20)\n\nstruct ps2_gpio_data {\n\tstruct device *dev;\n\tstruct serio *serio;\n\tunsigned char mode;\n\tstruct gpio_desc *gpio_clk;\n\tstruct gpio_desc *gpio_data;\n\tbool write_enable;\n\tint irq;\n\tktime_t t_irq_now;\n\tktime_t t_irq_last;\n\tstruct {\n\t\tunsigned char cnt;\n\t\tunsigned char byte;\n\t} rx;\n\tstruct {\n\t\tunsigned char cnt;\n\t\tunsigned char byte;\n\t\tktime_t t_xfer_start;\n\t\tktime_t t_xfer_end;\n\t\tstruct completion complete;\n\t\tstruct mutex mutex;\n\t\tstruct delayed_work work;\n\t} tx;\n};\n\nstatic int ps2_gpio_open(struct serio *serio)\n{\n\tstruct ps2_gpio_data *drvdata = serio->port_data;\n\n\tdrvdata->t_irq_last = 0;\n\tdrvdata->tx.t_xfer_end = 0;\n\n\tenable_irq(drvdata->irq);\n\treturn 0;\n}\n\nstatic void ps2_gpio_close(struct serio *serio)\n{\n\tstruct ps2_gpio_data *drvdata = serio->port_data;\n\n\tflush_delayed_work(&drvdata->tx.work);\n\tdisable_irq(drvdata->irq);\n}\n\nstatic int __ps2_gpio_write(struct serio *serio, unsigned char val)\n{\n\tstruct ps2_gpio_data *drvdata = serio->port_data;\n\n\tdisable_irq_nosync(drvdata->irq);\n\tgpiod_direction_output(drvdata->gpio_clk, 0);\n\n\tdrvdata->mode = PS2_MODE_TX;\n\tdrvdata->tx.byte = val;\n\n\tschedule_delayed_work(&drvdata->tx.work, usecs_to_jiffies(200));\n\n\treturn 0;\n}\n\nstatic int ps2_gpio_write(struct serio *serio, unsigned char val)\n{\n\tstruct ps2_gpio_data *drvdata = serio->port_data;\n\tint ret = 0;\n\n\tif (in_task()) {\n\t\tmutex_lock(&drvdata->tx.mutex);\n\t\t__ps2_gpio_write(serio, val);\n\t\tif (!wait_for_completion_timeout(&drvdata->tx.complete,\n\t\t\t\t\t\t msecs_to_jiffies(10000)))\n\t\t\tret = SERIO_TIMEOUT;\n\t\tmutex_unlock(&drvdata->tx.mutex);\n\t} else {\n\t\t__ps2_gpio_write(serio, val);\n\t}\n\n\treturn ret;\n}\n\nstatic void ps2_gpio_tx_work_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct ps2_gpio_data *drvdata = container_of(dwork,\n\t\t\t\t\t\t     struct ps2_gpio_data,\n\t\t\t\t\t\t     tx.work);\n\n\tdrvdata->tx.t_xfer_start = ktime_get();\n\tenable_irq(drvdata->irq);\n\tgpiod_direction_output(drvdata->gpio_data, 0);\n\tgpiod_direction_input(drvdata->gpio_clk);\n}\n\nstatic irqreturn_t ps2_gpio_irq_rx(struct ps2_gpio_data *drvdata)\n{\n\tunsigned char byte, cnt;\n\tint data;\n\tint rxflags = 0;\n\ts64 us_delta;\n\n\tbyte = drvdata->rx.byte;\n\tcnt = drvdata->rx.cnt;\n\n\tdrvdata->t_irq_now = ktime_get();\n\n\t \n\tus_delta = ktime_us_delta(drvdata->t_irq_now, drvdata->tx.t_xfer_end);\n\tif (unlikely(us_delta < PS2_IRQ_MIN_INTERVAL_US))\n\t\tgoto end;\n\n\tus_delta = ktime_us_delta(drvdata->t_irq_now, drvdata->t_irq_last);\n\tif (us_delta > PS2_IRQ_MAX_INTERVAL_US && cnt) {\n\t\tdev_err(drvdata->dev,\n\t\t\t\"RX: timeout, probably we missed an interrupt\\n\");\n\t\tgoto err;\n\t} else if (unlikely(us_delta < PS2_IRQ_MIN_INTERVAL_US)) {\n\t\t \n\t\tgoto end;\n\t}\n\tdrvdata->t_irq_last = drvdata->t_irq_now;\n\n\tdata = gpiod_get_value(drvdata->gpio_data);\n\tif (unlikely(data < 0)) {\n\t\tdev_err(drvdata->dev, \"RX: failed to get data gpio val: %d\\n\",\n\t\t\tdata);\n\t\tgoto err;\n\t}\n\n\tswitch (cnt) {\n\tcase PS2_START_BIT:\n\t\t \n\t\tif (unlikely(data)) {\n\t\t\tdev_err(drvdata->dev, \"RX: start bit should be low\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase PS2_DATA_BIT0:\n\tcase PS2_DATA_BIT1:\n\tcase PS2_DATA_BIT2:\n\tcase PS2_DATA_BIT3:\n\tcase PS2_DATA_BIT4:\n\tcase PS2_DATA_BIT5:\n\tcase PS2_DATA_BIT6:\n\tcase PS2_DATA_BIT7:\n\t\t \n\t\tif (data)\n\t\t\tbyte |= (data << (cnt - 1));\n\t\tbreak;\n\tcase PS2_PARITY_BIT:\n\t\t \n\t\tif (!((hweight8(byte) & 1) ^ data)) {\n\t\t\trxflags |= SERIO_PARITY;\n\t\t\tdev_warn(drvdata->dev, \"RX: parity error\\n\");\n\t\t\tif (!drvdata->write_enable)\n\t\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase PS2_STOP_BIT:\n\t\t \n\t\tif (unlikely(!data)) {\n\t\t\tdev_err(drvdata->dev, \"RX: stop bit should be high\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (!drvdata->write_enable) {\n\t\t\tif (byte == PS2_DEV_RET_NACK)\n\t\t\t\tgoto err;\n\t\t\telse if (byte == PS2_DEV_RET_ACK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tserio_interrupt(drvdata->serio, byte, rxflags);\n\t\tdev_dbg(drvdata->dev, \"RX: sending byte 0x%x\\n\", byte);\n\n\t\tcnt = byte = 0;\n\n\t\tgoto end;  \n\tdefault:\n\t\tdev_err(drvdata->dev, \"RX: got out of sync with the device\\n\");\n\t\tgoto err;\n\t}\n\n\tcnt++;\n\tgoto end;  \n\nerr:\n\tcnt = byte = 0;\n\t__ps2_gpio_write(drvdata->serio, PS2_CMD_RESEND);\nend:\n\tdrvdata->rx.cnt = cnt;\n\tdrvdata->rx.byte = byte;\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ps2_gpio_irq_tx(struct ps2_gpio_data *drvdata)\n{\n\tunsigned char byte, cnt;\n\tint data;\n\ts64 us_delta;\n\n\tcnt = drvdata->tx.cnt;\n\tbyte = drvdata->tx.byte;\n\n\tdrvdata->t_irq_now = ktime_get();\n\n\t \n\tus_delta = ktime_us_delta(drvdata->t_irq_now,\n\t\t\t\t  drvdata->tx.t_xfer_start);\n\tif (unlikely(us_delta < PS2_CLK_MIN_INTERVAL_US))\n\t\tgoto end;\n\n\tus_delta = ktime_us_delta(drvdata->t_irq_now, drvdata->t_irq_last);\n\tif (us_delta > PS2_IRQ_MAX_INTERVAL_US && cnt > 1) {\n\t\tdev_err(drvdata->dev,\n\t\t\t\"TX: timeout, probably we missed an interrupt\\n\");\n\t\tgoto err;\n\t} else if (unlikely(us_delta < PS2_IRQ_MIN_INTERVAL_US)) {\n\t\t \n\t\tgoto end;\n\t}\n\tdrvdata->t_irq_last = drvdata->t_irq_now;\n\n\tswitch (cnt) {\n\tcase PS2_START_BIT:\n\t\t \n\t\tdev_err(drvdata->dev,\n\t\t\t\"TX: start bit should have been sent already\\n\");\n\t\tgoto err;\n\tcase PS2_DATA_BIT0:\n\tcase PS2_DATA_BIT1:\n\tcase PS2_DATA_BIT2:\n\tcase PS2_DATA_BIT3:\n\tcase PS2_DATA_BIT4:\n\tcase PS2_DATA_BIT5:\n\tcase PS2_DATA_BIT6:\n\tcase PS2_DATA_BIT7:\n\t\tdata = byte & BIT(cnt - 1);\n\t\tgpiod_set_value(drvdata->gpio_data, data);\n\t\tbreak;\n\tcase PS2_PARITY_BIT:\n\t\t \n\t\tdata = !(hweight8(byte) & 1);\n\t\tgpiod_set_value(drvdata->gpio_data, data);\n\t\tbreak;\n\tcase PS2_STOP_BIT:\n\t\t \n\t\tgpiod_direction_input(drvdata->gpio_data);\n\t\tbreak;\n\tcase PS2_ACK_BIT:\n\t\tdata = gpiod_get_value(drvdata->gpio_data);\n\t\tif (data) {\n\t\t\tdev_warn(drvdata->dev, \"TX: received NACK, retry\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tdrvdata->tx.t_xfer_end = ktime_get();\n\t\tdrvdata->mode = PS2_MODE_RX;\n\t\tcomplete(&drvdata->tx.complete);\n\n\t\tcnt = 1;\n\t\tgoto end;  \n\tdefault:\n\t\t \n\t\tgpiod_direction_input(drvdata->gpio_data);\n\t\tdev_err(drvdata->dev, \"TX: got out of sync with the device\\n\");\n\t\tgoto err;\n\t}\n\n\tcnt++;\n\tgoto end;  \n\nerr:\n\tcnt = 1;\n\tgpiod_direction_input(drvdata->gpio_data);\n\t__ps2_gpio_write(drvdata->serio, drvdata->tx.byte);\nend:\n\tdrvdata->tx.cnt = cnt;\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ps2_gpio_irq(int irq, void *dev_id)\n{\n\tstruct ps2_gpio_data *drvdata = dev_id;\n\n\treturn drvdata->mode ? ps2_gpio_irq_tx(drvdata) :\n\t\tps2_gpio_irq_rx(drvdata);\n}\n\nstatic int ps2_gpio_get_props(struct device *dev,\n\t\t\t\t struct ps2_gpio_data *drvdata)\n{\n\tenum gpiod_flags gflags;\n\n\t \n\tgflags = GPIOD_IN | GPIOD_FLAGS_BIT_OPEN_DRAIN;\n\n\tdrvdata->gpio_data = devm_gpiod_get(dev, \"data\", gflags);\n\tif (IS_ERR(drvdata->gpio_data)) {\n\t\tdev_err(dev, \"failed to request data gpio: %ld\",\n\t\t\tPTR_ERR(drvdata->gpio_data));\n\t\treturn PTR_ERR(drvdata->gpio_data);\n\t}\n\n\tdrvdata->gpio_clk = devm_gpiod_get(dev, \"clk\", gflags);\n\tif (IS_ERR(drvdata->gpio_clk)) {\n\t\tdev_err(dev, \"failed to request clock gpio: %ld\",\n\t\t\tPTR_ERR(drvdata->gpio_clk));\n\t\treturn PTR_ERR(drvdata->gpio_clk);\n\t}\n\n\tdrvdata->write_enable = device_property_read_bool(dev,\n\t\t\t\t\"write-enable\");\n\n\treturn 0;\n}\n\nstatic int ps2_gpio_probe(struct platform_device *pdev)\n{\n\tstruct ps2_gpio_data *drvdata;\n\tstruct serio *serio;\n\tstruct device *dev = &pdev->dev;\n\tint error;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(struct ps2_gpio_data), GFP_KERNEL);\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!drvdata || !serio) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_serio;\n\t}\n\n\terror = ps2_gpio_get_props(dev, drvdata);\n\tif (error)\n\t\tgoto err_free_serio;\n\n\tif (gpiod_cansleep(drvdata->gpio_data) ||\n\t    gpiod_cansleep(drvdata->gpio_clk)) {\n\t\tdev_err(dev, \"GPIO data or clk are connected via slow bus\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_free_serio;\n\t}\n\n\tdrvdata->irq = platform_get_irq(pdev, 0);\n\tif (drvdata->irq < 0) {\n\t\terror = drvdata->irq;\n\t\tgoto err_free_serio;\n\t}\n\n\terror = devm_request_irq(dev, drvdata->irq, ps2_gpio_irq,\n\t\t\t\t IRQF_NO_THREAD, DRIVER_NAME, drvdata);\n\tif (error) {\n\t\tdev_err(dev, \"failed to request irq %d: %d\\n\",\n\t\t\tdrvdata->irq, error);\n\t\tgoto err_free_serio;\n\t}\n\n\t \n\tdisable_irq(drvdata->irq);\n\n\tserio->id.type = SERIO_8042;\n\tserio->open = ps2_gpio_open;\n\tserio->close = ps2_gpio_close;\n\t \n\tserio->write = drvdata->write_enable ? ps2_gpio_write : NULL;\n\tserio->port_data = drvdata;\n\tserio->dev.parent = dev;\n\tstrscpy(serio->name, dev_name(dev), sizeof(serio->name));\n\tstrscpy(serio->phys, dev_name(dev), sizeof(serio->phys));\n\n\tdrvdata->serio = serio;\n\tdrvdata->dev = dev;\n\tdrvdata->mode = PS2_MODE_RX;\n\n\t \n\tdrvdata->tx.cnt = 1;\n\n\tINIT_DELAYED_WORK(&drvdata->tx.work, ps2_gpio_tx_work_fn);\n\tinit_completion(&drvdata->tx.complete);\n\tmutex_init(&drvdata->tx.mutex);\n\n\tserio_register_port(serio);\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\t \n\nerr_free_serio:\n\tkfree(serio);\n\treturn error;\n}\n\nstatic int ps2_gpio_remove(struct platform_device *pdev)\n{\n\tstruct ps2_gpio_data *drvdata = platform_get_drvdata(pdev);\n\n\tserio_unregister_port(drvdata->serio);\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id ps2_gpio_match[] = {\n\t{ .compatible = \"ps2-gpio\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ps2_gpio_match);\n#endif\n\nstatic struct platform_driver ps2_gpio_driver = {\n\t.probe\t\t= ps2_gpio_probe,\n\t.remove\t\t= ps2_gpio_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(ps2_gpio_match),\n\t},\n};\nmodule_platform_driver(ps2_gpio_driver);\n\nMODULE_AUTHOR(\"Danilo Krummrich <danilokrummrich@dk-develop.de>\");\nMODULE_DESCRIPTION(\"GPIO PS2 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}