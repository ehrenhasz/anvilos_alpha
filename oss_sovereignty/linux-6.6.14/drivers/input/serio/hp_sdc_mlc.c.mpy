{
  "module_name": "hp_sdc_mlc.c",
  "hash_id": "4f455d42c8cb056c9d2c57f3581d496c18cf983f1ee608aa537d2ee2d8c87934",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/hp_sdc_mlc.c",
  "human_readable_source": " \n\n#include <linux/hil_mlc.h>\n#include <linux/hp_sdc.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/semaphore.h>\n\n#define PREFIX \"HP SDC MLC: \"\n\nstatic hil_mlc hp_sdc_mlc;\n\nMODULE_AUTHOR(\"Brian S. Julin <bri@calyx.com>\");\nMODULE_DESCRIPTION(\"Glue for onboard HIL MLC in HP-PARISC machines\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic struct hp_sdc_mlc_priv_s {\n\tint emtestmode;\n\thp_sdc_transaction trans;\n\tu8 tseq[16];\n\tint got5x;\n} hp_sdc_mlc_priv;\n\n \nstatic void hp_sdc_mlc_isr (int irq, void *dev_id,\n\t\t\t    uint8_t status, uint8_t data)\n{\n\tint idx;\n\thil_mlc *mlc = &hp_sdc_mlc;\n\n\twrite_lock(&mlc->lock);\n\tif (mlc->icount < 0) {\n\t\tprintk(KERN_WARNING PREFIX \"HIL Overflow!\\n\");\n\t\tup(&mlc->isem);\n\t\tgoto out;\n\t}\n\tidx = 15 - mlc->icount;\n\tif ((status & HP_SDC_STATUS_IRQMASK) == HP_SDC_STATUS_HILDATA) {\n\t\tmlc->ipacket[idx] |= data | HIL_ERR_INT;\n\t\tmlc->icount--;\n\t\tif (hp_sdc_mlc_priv.got5x || !idx)\n\t\t\tgoto check;\n\t\tif ((mlc->ipacket[idx - 1] & HIL_PKT_ADDR_MASK) !=\n\t\t    (mlc->ipacket[idx] & HIL_PKT_ADDR_MASK)) {\n\t\t\tmlc->ipacket[idx] &= ~HIL_PKT_ADDR_MASK;\n\t\t\tmlc->ipacket[idx] |= (mlc->ipacket[idx - 1]\n\t\t\t\t\t\t& HIL_PKT_ADDR_MASK);\n\t\t}\n\t\tgoto check;\n\t}\n\t \n\tif (data & HP_SDC_HIL_ISERR)\n\t\tgoto err;\n\tmlc->ipacket[idx] =\n\t\t(data & HP_SDC_HIL_R1MASK) << HIL_PKT_ADDR_SHIFT;\n\thp_sdc_mlc_priv.got5x = 1;\n\tgoto out;\n\n check:\n\thp_sdc_mlc_priv.got5x = 0;\n\tif (mlc->imatch == 0)\n\t\tgoto done;\n\tif ((mlc->imatch == (HIL_ERR_INT | HIL_PKT_CMD | HIL_CMD_POL))\n\t    && (mlc->ipacket[idx] == (mlc->imatch | idx)))\n\t\tgoto done;\n\tif (mlc->ipacket[idx] == mlc->imatch)\n\t\tgoto done;\n\tgoto out;\n\n err:\n\tprintk(KERN_DEBUG PREFIX \"err code %x\\n\", data);\n\n\tswitch (data) {\n\tcase HP_SDC_HIL_RC_DONE:\n\t\tprintk(KERN_WARNING PREFIX \"Bastard SDC reconfigured loop!\\n\");\n\t\tbreak;\n\n\tcase HP_SDC_HIL_ERR:\n\t\tmlc->ipacket[idx] |= HIL_ERR_INT | HIL_ERR_PERR |\n\t\t\t\t\tHIL_ERR_FERR | HIL_ERR_FOF;\n\t\tbreak;\n\n\tcase HP_SDC_HIL_TO:\n\t\tmlc->ipacket[idx] |= HIL_ERR_INT | HIL_ERR_LERR;\n\t\tbreak;\n\n\tcase HP_SDC_HIL_RC:\n\t\tprintk(KERN_WARNING PREFIX \"Bastard SDC decided to reconfigure loop!\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING PREFIX \"Unknown HIL Error status (%x)!\\n\", data);\n\t\tbreak;\n\t}\n\n\t \n done:\n\ttasklet_schedule(mlc->tasklet);\n\tup(&mlc->isem);\n out:\n\twrite_unlock(&mlc->lock);\n}\n\n\n \n\nstatic int hp_sdc_mlc_in(hil_mlc *mlc, suseconds_t timeout)\n{\n\tstruct hp_sdc_mlc_priv_s *priv;\n\tint rc = 2;\n\n\tpriv = mlc->priv;\n\n\t \n\tif (down_trylock(&mlc->isem)) {\n\t\tif (priv->emtestmode) {\n\t\t\tmlc->ipacket[0] =\n\t\t\t\tHIL_ERR_INT | (mlc->opacket &\n\t\t\t\t\t       (HIL_PKT_CMD |\n\t\t\t\t\t\tHIL_PKT_ADDR_MASK |\n\t\t\t\t\t\tHIL_PKT_DATA_MASK));\n\t\t\tmlc->icount = 14;\n\t\t\t \n\t\t\tgoto wasup;\n\t\t}\n\t\tif (time_after(jiffies, mlc->instart + mlc->intimeout)) {\n\t\t\t \n\t\t\trc = 1;\n\t\t\tup(&mlc->isem);\n\t\t}\n\t\tgoto done;\n\t}\n wasup:\n\tup(&mlc->isem);\n\trc = 0;\n done:\n\treturn rc;\n}\n\nstatic int hp_sdc_mlc_cts(hil_mlc *mlc)\n{\n\tstruct hp_sdc_mlc_priv_s *priv;\n\n\tpriv = mlc->priv;\n\n\t \n\tBUG_ON(down_trylock(&mlc->isem));\n\tBUG_ON(down_trylock(&mlc->osem));\n\n\tup(&mlc->isem);\n\tup(&mlc->osem);\n\n\tif (down_trylock(&mlc->csem)) {\n\t\tif (priv->trans.act.semaphore != &mlc->csem)\n\t\t\tgoto poll;\n\t\telse\n\t\t\tgoto busy;\n\t}\n\n\tif (!(priv->tseq[4] & HP_SDC_USE_LOOP))\n\t\tgoto done;\n\n poll:\n\tpriv->trans.act.semaphore = &mlc->csem;\n\tpriv->trans.actidx = 0;\n\tpriv->trans.idx = 1;\n\tpriv->trans.endidx = 5;\n\tpriv->tseq[0] =\n\t\tHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN | HP_SDC_ACT_SEMAPHORE;\n\tpriv->tseq[1] = HP_SDC_CMD_READ_USE;\n\tpriv->tseq[2] = 1;\n\tpriv->tseq[3] = 0;\n\tpriv->tseq[4] = 0;\n\treturn __hp_sdc_enqueue_transaction(&priv->trans);\n busy:\n\treturn 1;\n done:\n\tpriv->trans.act.semaphore = &mlc->osem;\n\tup(&mlc->csem);\n\treturn 0;\n}\n\nstatic int hp_sdc_mlc_out(hil_mlc *mlc)\n{\n\tstruct hp_sdc_mlc_priv_s *priv;\n\n\tpriv = mlc->priv;\n\n\t \n\tBUG_ON(down_trylock(&mlc->osem));\n\n\tif (mlc->opacket & HIL_DO_ALTER_CTRL)\n\t\tgoto do_control;\n\n do_data:\n\tif (priv->emtestmode) {\n\t\tup(&mlc->osem);\n\t\treturn 0;\n\t}\n\t \n\tBUG_ON(down_trylock(&mlc->csem));\n\tup(&mlc->csem);\n\n\tpriv->trans.actidx = 0;\n\tpriv->trans.idx = 1;\n\tpriv->trans.act.semaphore = &mlc->osem;\n\tpriv->trans.endidx = 6;\n\tpriv->tseq[0] =\n\t\tHP_SDC_ACT_DATAREG | HP_SDC_ACT_POSTCMD | HP_SDC_ACT_SEMAPHORE;\n\tpriv->tseq[1] = 0x7;\n\tpriv->tseq[2] =\n\t\t(mlc->opacket &\n\t\t (HIL_PKT_ADDR_MASK | HIL_PKT_CMD))\n\t\t   >> HIL_PKT_ADDR_SHIFT;\n\tpriv->tseq[3] =\n\t\t(mlc->opacket & HIL_PKT_DATA_MASK)\n\t\t  >> HIL_PKT_DATA_SHIFT;\n\tpriv->tseq[4] = 0;   \n\tif (priv->tseq[3] == HIL_CMD_DHR)\n\t\tpriv->tseq[4] = 1;\n\tpriv->tseq[5] = HP_SDC_CMD_DO_HIL;\n\tgoto enqueue;\n\n do_control:\n\tpriv->emtestmode = mlc->opacket & HIL_CTRL_TEST;\n\n\t \n\tBUG_ON((mlc->opacket & (HIL_CTRL_APE | HIL_CTRL_IPF)) == HIL_CTRL_APE);\n\n\tif ((mlc->opacket & HIL_CTRL_ONLY) == HIL_CTRL_ONLY)\n\t\tgoto control_only;\n\n\t \n\tBUG_ON(mlc->opacket & HIL_CTRL_APE);\n\n\t \n\tgoto do_data;\n\n control_only:\n\tpriv->trans.actidx = 0;\n\tpriv->trans.idx = 1;\n\tpriv->trans.act.semaphore = &mlc->osem;\n\tpriv->trans.endidx = 4;\n\tpriv->tseq[0] =\n\t  HP_SDC_ACT_PRECMD | HP_SDC_ACT_DATAOUT | HP_SDC_ACT_SEMAPHORE;\n\tpriv->tseq[1] = HP_SDC_CMD_SET_LPC;\n\tpriv->tseq[2] = 1;\n\t \n\tpriv->tseq[3] = 0;\n\tif (mlc->opacket & HIL_CTRL_APE) {\n\t\tpriv->tseq[3] |= HP_SDC_LPC_APE_IPF;\n\t\tBUG_ON(down_trylock(&mlc->csem));\n\t}\n enqueue:\n\treturn hp_sdc_enqueue_transaction(&priv->trans);\n}\n\nstatic int __init hp_sdc_mlc_init(void)\n{\n\thil_mlc *mlc = &hp_sdc_mlc;\n\tint err;\n\n#ifdef __mc68000__\n\tif (!MACH_IS_HP300)\n\t\treturn -ENODEV;\n#endif\n\n\tprintk(KERN_INFO PREFIX \"Registering the System Domain Controller's HIL MLC.\\n\");\n\n\thp_sdc_mlc_priv.emtestmode = 0;\n\thp_sdc_mlc_priv.trans.seq = hp_sdc_mlc_priv.tseq;\n\thp_sdc_mlc_priv.trans.act.semaphore = &mlc->osem;\n\thp_sdc_mlc_priv.got5x = 0;\n\n\tmlc->cts = &hp_sdc_mlc_cts;\n\tmlc->in\t= &hp_sdc_mlc_in;\n\tmlc->out = &hp_sdc_mlc_out;\n\tmlc->priv = &hp_sdc_mlc_priv;\n\n\terr = hil_mlc_register(mlc);\n\tif (err) {\n\t\tprintk(KERN_WARNING PREFIX \"Failed to register MLC structure with hil_mlc\\n\");\n\t\treturn err;\n\t}\n\n\tif (hp_sdc_request_hil_irq(&hp_sdc_mlc_isr)) {\n\t\tprintk(KERN_WARNING PREFIX \"Request for raw HIL ISR hook denied\\n\");\n\t\tif (hil_mlc_unregister(mlc))\n\t\t\tprintk(KERN_ERR PREFIX \"Failed to unregister MLC structure with hil_mlc.\\n\"\n\t\t\t\t\"This is bad.  Could cause an oops.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hp_sdc_mlc_exit(void)\n{\n\thil_mlc *mlc = &hp_sdc_mlc;\n\n\tif (hp_sdc_release_hil_irq(&hp_sdc_mlc_isr))\n\t\tprintk(KERN_ERR PREFIX \"Failed to release the raw HIL ISR hook.\\n\"\n\t\t\t\"This is bad.  Could cause an oops.\\n\");\n\n\tif (hil_mlc_unregister(mlc))\n\t\tprintk(KERN_ERR PREFIX \"Failed to unregister MLC structure with hil_mlc.\\n\"\n\t\t\t\"This is bad.  Could cause an oops.\\n\");\n}\n\nmodule_init(hp_sdc_mlc_init);\nmodule_exit(hp_sdc_mlc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}