{
  "module_name": "sa1111ps2.c",
  "hash_id": "cb0856e94bcdb7d2f7744a01cb143cbefe3aac58cb7e0b02a879141529dc7396",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/sa1111ps2.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <asm/io.h>\n\n#include <asm/hardware/sa1111.h>\n\n#define PS2CR\t\t0x0000\n#define PS2STAT\t\t0x0004\n#define PS2DATA\t\t0x0008\n#define PS2CLKDIV\t0x000c\n#define PS2PRECNT\t0x0010\n\n#define PS2CR_ENA\t0x08\n#define PS2CR_FKD\t0x02\n#define PS2CR_FKC\t0x01\n\n#define PS2STAT_STP\t0x0100\n#define PS2STAT_TXE\t0x0080\n#define PS2STAT_TXB\t0x0040\n#define PS2STAT_RXF\t0x0020\n#define PS2STAT_RXB\t0x0010\n#define PS2STAT_ENA\t0x0008\n#define PS2STAT_RXP\t0x0004\n#define PS2STAT_KBD\t0x0002\n#define PS2STAT_KBC\t0x0001\n\nstruct ps2if {\n\tstruct serio\t\t*io;\n\tstruct sa1111_dev\t*dev;\n\tvoid __iomem\t\t*base;\n\tint\t\t\trx_irq;\n\tint\t\t\ttx_irq;\n\tunsigned int\t\topen;\n\tspinlock_t\t\tlock;\n\tunsigned int\t\thead;\n\tunsigned int\t\ttail;\n\tunsigned char\t\tbuf[4];\n};\n\n \nstatic irqreturn_t ps2_rxint(int irq, void *dev_id)\n{\n\tstruct ps2if *ps2if = dev_id;\n\tunsigned int scancode, flag, status;\n\n\tstatus = readl_relaxed(ps2if->base + PS2STAT);\n\twhile (status & PS2STAT_RXF) {\n\t\tif (status & PS2STAT_STP)\n\t\t\twritel_relaxed(PS2STAT_STP, ps2if->base + PS2STAT);\n\n\t\tflag = (status & PS2STAT_STP ? SERIO_FRAME : 0) |\n\t\t       (status & PS2STAT_RXP ? 0 : SERIO_PARITY);\n\n\t\tscancode = readl_relaxed(ps2if->base + PS2DATA) & 0xff;\n\n\t\tif (hweight8(scancode) & 1)\n\t\t\tflag ^= SERIO_PARITY;\n\n\t\tserio_interrupt(ps2if->io, scancode, flag);\n\n\t\tstatus = readl_relaxed(ps2if->base + PS2STAT);\n        }\n\n        return IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ps2_txint(int irq, void *dev_id)\n{\n\tstruct ps2if *ps2if = dev_id;\n\tunsigned int status;\n\n\tspin_lock(&ps2if->lock);\n\tstatus = readl_relaxed(ps2if->base + PS2STAT);\n\tif (ps2if->head == ps2if->tail) {\n\t\tdisable_irq_nosync(irq);\n\t\t \n\t} else if (status & PS2STAT_TXE) {\n\t\twritel_relaxed(ps2if->buf[ps2if->tail], ps2if->base + PS2DATA);\n\t\tps2if->tail = (ps2if->tail + 1) & (sizeof(ps2if->buf) - 1);\n\t}\n\tspin_unlock(&ps2if->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ps2_write(struct serio *io, unsigned char val)\n{\n\tstruct ps2if *ps2if = io->port_data;\n\tunsigned long flags;\n\tunsigned int head;\n\n\tspin_lock_irqsave(&ps2if->lock, flags);\n\n\t \n\tif (readl_relaxed(ps2if->base + PS2STAT) & PS2STAT_TXE) {\n\t\twritel_relaxed(val, ps2if->base + PS2DATA);\n\t} else {\n\t\tif (ps2if->head == ps2if->tail)\n\t\t\tenable_irq(ps2if->tx_irq);\n\t\thead = (ps2if->head + 1) & (sizeof(ps2if->buf) - 1);\n\t\tif (head != ps2if->tail) {\n\t\t\tps2if->buf[ps2if->head] = val;\n\t\t\tps2if->head = head;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&ps2if->lock, flags);\n\treturn 0;\n}\n\nstatic int ps2_open(struct serio *io)\n{\n\tstruct ps2if *ps2if = io->port_data;\n\tint ret;\n\n\tret = sa1111_enable_device(ps2if->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = request_irq(ps2if->rx_irq, ps2_rxint, 0,\n\t\t\t  SA1111_DRIVER_NAME(ps2if->dev), ps2if);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"sa1111ps2: could not allocate IRQ%d: %d\\n\",\n\t\t\tps2if->rx_irq, ret);\n\t\tsa1111_disable_device(ps2if->dev);\n\t\treturn ret;\n\t}\n\n\tret = request_irq(ps2if->tx_irq, ps2_txint, 0,\n\t\t\t  SA1111_DRIVER_NAME(ps2if->dev), ps2if);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"sa1111ps2: could not allocate IRQ%d: %d\\n\",\n\t\t\tps2if->tx_irq, ret);\n\t\tfree_irq(ps2if->rx_irq, ps2if);\n\t\tsa1111_disable_device(ps2if->dev);\n\t\treturn ret;\n\t}\n\n\tps2if->open = 1;\n\n\tenable_irq_wake(ps2if->rx_irq);\n\n\twritel_relaxed(PS2CR_ENA, ps2if->base + PS2CR);\n\treturn 0;\n}\n\nstatic void ps2_close(struct serio *io)\n{\n\tstruct ps2if *ps2if = io->port_data;\n\n\twritel_relaxed(0, ps2if->base + PS2CR);\n\n\tdisable_irq_wake(ps2if->rx_irq);\n\n\tps2if->open = 0;\n\n\tfree_irq(ps2if->tx_irq, ps2if);\n\tfree_irq(ps2if->rx_irq, ps2if);\n\n\tsa1111_disable_device(ps2if->dev);\n}\n\n \nstatic void ps2_clear_input(struct ps2if *ps2if)\n{\n\tint maxread = 100;\n\n\twhile (maxread--) {\n\t\tif ((readl_relaxed(ps2if->base + PS2DATA) & 0xff) == 0xff)\n\t\t\tbreak;\n\t}\n}\n\nstatic unsigned int ps2_test_one(struct ps2if *ps2if,\n\t\t\t\t\t   unsigned int mask)\n{\n\tunsigned int val;\n\n\twritel_relaxed(PS2CR_ENA | mask, ps2if->base + PS2CR);\n\n\tudelay(10);\n\n\tval = readl_relaxed(ps2if->base + PS2STAT);\n\treturn val & (PS2STAT_KBC | PS2STAT_KBD);\n}\n\n \nstatic int ps2_test(struct ps2if *ps2if)\n{\n\tunsigned int stat;\n\tint ret = 0;\n\n\tstat = ps2_test_one(ps2if, PS2CR_FKC);\n\tif (stat != PS2STAT_KBD) {\n\t\tprintk(\"PS/2 interface test failed[1]: %02x\\n\", stat);\n\t\tret = -ENODEV;\n\t}\n\n\tstat = ps2_test_one(ps2if, 0);\n\tif (stat != (PS2STAT_KBC | PS2STAT_KBD)) {\n\t\tprintk(\"PS/2 interface test failed[2]: %02x\\n\", stat);\n\t\tret = -ENODEV;\n\t}\n\n\tstat = ps2_test_one(ps2if, PS2CR_FKD);\n\tif (stat != PS2STAT_KBC) {\n\t\tprintk(\"PS/2 interface test failed[3]: %02x\\n\", stat);\n\t\tret = -ENODEV;\n\t}\n\n\twritel_relaxed(0, ps2if->base + PS2CR);\n\n\treturn ret;\n}\n\n \nstatic int ps2_probe(struct sa1111_dev *dev)\n{\n\tstruct ps2if *ps2if;\n\tstruct serio *serio;\n\tint ret;\n\n\tps2if = kzalloc(sizeof(struct ps2if), GFP_KERNEL);\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!ps2if || !serio) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= ps2_write;\n\tserio->open\t\t= ps2_open;\n\tserio->close\t\t= ps2_close;\n\tstrscpy(serio->name, dev_name(&dev->dev), sizeof(serio->name));\n\tstrscpy(serio->phys, dev_name(&dev->dev), sizeof(serio->phys));\n\tserio->port_data\t= ps2if;\n\tserio->dev.parent\t= &dev->dev;\n\tps2if->io\t\t= serio;\n\tps2if->dev\t\t= dev;\n\tsa1111_set_drvdata(dev, ps2if);\n\n\tspin_lock_init(&ps2if->lock);\n\n\tps2if->rx_irq = sa1111_get_irq(dev, 0);\n\tif (ps2if->rx_irq <= 0) {\n\t\tret = ps2if->rx_irq ? : -ENXIO;\n\t\tgoto free;\n\t}\n\n\tps2if->tx_irq = sa1111_get_irq(dev, 1);\n\tif (ps2if->tx_irq <= 0) {\n\t\tret = ps2if->tx_irq ? : -ENXIO;\n\t\tgoto free;\n\t}\n\n\t \n\tif (!request_mem_region(dev->res.start,\n\t\t\t\tdev->res.end - dev->res.start + 1,\n\t\t\t\tSA1111_DRIVER_NAME(dev))) {\n\t\tret = -EBUSY;\n\t\tgoto free;\n\t}\n\n\t \n\tps2if->base = dev->mapbase;\n\n\tsa1111_enable_device(ps2if->dev);\n\n\t \n\twritel_relaxed(0, ps2if->base + PS2CLKDIV);\n\twritel_relaxed(127, ps2if->base + PS2PRECNT);\n\n\t \n\tps2_clear_input(ps2if);\n\n\t \n\tret = ps2_test(ps2if);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tps2_clear_input(ps2if);\n\n\tsa1111_disable_device(ps2if->dev);\n\tserio_register_port(ps2if->io);\n\treturn 0;\n\n out:\n\tsa1111_disable_device(ps2if->dev);\n\trelease_mem_region(dev->res.start, resource_size(&dev->res));\n free:\n\tsa1111_set_drvdata(dev, NULL);\n\tkfree(ps2if);\n\tkfree(serio);\n\treturn ret;\n}\n\n \nstatic void ps2_remove(struct sa1111_dev *dev)\n{\n\tstruct ps2if *ps2if = sa1111_get_drvdata(dev);\n\n\tserio_unregister_port(ps2if->io);\n\trelease_mem_region(dev->res.start, resource_size(&dev->res));\n\tsa1111_set_drvdata(dev, NULL);\n\n\tkfree(ps2if);\n}\n\n \nstatic struct sa1111_driver ps2_driver = {\n\t.drv = {\n\t\t.name\t= \"sa1111-ps2\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.devid\t\t= SA1111_DEVID_PS2,\n\t.probe\t\t= ps2_probe,\n\t.remove\t\t= ps2_remove,\n};\n\nstatic int __init ps2_init(void)\n{\n\treturn sa1111_driver_register(&ps2_driver);\n}\n\nstatic void __exit ps2_exit(void)\n{\n\tsa1111_driver_unregister(&ps2_driver);\n}\n\nmodule_init(ps2_init);\nmodule_exit(ps2_exit);\n\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"SA1111 PS2 controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}