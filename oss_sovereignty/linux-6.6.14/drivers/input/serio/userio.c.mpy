{
  "module_name": "userio.c",
  "hash_id": "632859c3f2c78acc8e2b0d7da7d6ffd21167f4c2e430d4c1942f23b5f3d1ab63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/userio.c",
  "human_readable_source": " \n\n#include <linux/circ_buf.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <uapi/linux/userio.h>\n\n#define USERIO_NAME\t\t\"userio\"\n#define USERIO_BUFSIZE\t\t16\n\nstatic struct miscdevice userio_misc;\n\nstruct userio_device {\n\tstruct serio *serio;\n\tstruct mutex mutex;\n\n\tbool running;\n\n\tu8 head;\n\tu8 tail;\n\n\tspinlock_t buf_lock;\n\tunsigned char buf[USERIO_BUFSIZE];\n\n\twait_queue_head_t waitq;\n};\n\n \nstatic int userio_device_write(struct serio *id, unsigned char val)\n{\n\tstruct userio_device *userio = id->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&userio->buf_lock, flags);\n\n\tuserio->buf[userio->head] = val;\n\tuserio->head = (userio->head + 1) % USERIO_BUFSIZE;\n\n\tif (userio->head == userio->tail)\n\t\tdev_warn(userio_misc.this_device,\n\t\t\t \"Buffer overflowed, userio client isn't keeping up\");\n\n\tspin_unlock_irqrestore(&userio->buf_lock, flags);\n\n\twake_up_interruptible(&userio->waitq);\n\n\treturn 0;\n}\n\nstatic int userio_char_open(struct inode *inode, struct file *file)\n{\n\tstruct userio_device *userio;\n\n\tuserio = kzalloc(sizeof(struct userio_device), GFP_KERNEL);\n\tif (!userio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&userio->mutex);\n\tspin_lock_init(&userio->buf_lock);\n\tinit_waitqueue_head(&userio->waitq);\n\n\tuserio->serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!userio->serio) {\n\t\tkfree(userio);\n\t\treturn -ENOMEM;\n\t}\n\n\tuserio->serio->write = userio_device_write;\n\tuserio->serio->port_data = userio;\n\n\tfile->private_data = userio;\n\n\treturn 0;\n}\n\nstatic int userio_char_release(struct inode *inode, struct file *file)\n{\n\tstruct userio_device *userio = file->private_data;\n\n\tif (userio->running) {\n\t\t \n\t\tserio_unregister_port(userio->serio);\n\t} else {\n\t\tkfree(userio->serio);\n\t}\n\n\tkfree(userio);\n\n\treturn 0;\n}\n\nstatic ssize_t userio_char_read(struct file *file, char __user *user_buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct userio_device *userio = file->private_data;\n\tint error;\n\tsize_t nonwrap_len, copylen;\n\tunsigned char buf[USERIO_BUFSIZE];\n\tunsigned long flags;\n\n\t \n\tfor (;;) {\n\t\tspin_lock_irqsave(&userio->buf_lock, flags);\n\n\t\tnonwrap_len = CIRC_CNT_TO_END(userio->head,\n\t\t\t\t\t      userio->tail,\n\t\t\t\t\t      USERIO_BUFSIZE);\n\t\tcopylen = min(nonwrap_len, count);\n\t\tif (copylen) {\n\t\t\tmemcpy(buf, &userio->buf[userio->tail], copylen);\n\t\t\tuserio->tail = (userio->tail + copylen) %\n\t\t\t\t\t\t\tUSERIO_BUFSIZE;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&userio->buf_lock, flags);\n\n\t\tif (nonwrap_len)\n\t\t\tbreak;\n\n\t\t \n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tif (count == 0)\n\t\t\treturn 0;\n\n\t\terror = wait_event_interruptible(userio->waitq,\n\t\t\t\t\t\t userio->head != userio->tail);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (copylen)\n\t\tif (copy_to_user(user_buffer, buf, copylen))\n\t\t\treturn -EFAULT;\n\n\treturn copylen;\n}\n\nstatic ssize_t userio_char_write(struct file *file, const char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct userio_device *userio = file->private_data;\n\tstruct userio_cmd cmd;\n\tint error;\n\n\tif (count != sizeof(cmd)) {\n\t\tdev_warn(userio_misc.this_device, \"Invalid payload size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&cmd, buffer, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\terror = mutex_lock_interruptible(&userio->mutex);\n\tif (error)\n\t\treturn error;\n\n\tswitch (cmd.type) {\n\tcase USERIO_CMD_REGISTER:\n\t\tif (!userio->serio->id.type) {\n\t\t\tdev_warn(userio_misc.this_device,\n\t\t\t\t \"No port type given on /dev/userio\\n\");\n\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (userio->running) {\n\t\t\tdev_warn(userio_misc.this_device,\n\t\t\t\t \"Begin command sent, but we're already running\\n\");\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tuserio->running = true;\n\t\tserio_register_port(userio->serio);\n\t\tbreak;\n\n\tcase USERIO_CMD_SET_PORT_TYPE:\n\t\tif (userio->running) {\n\t\t\tdev_warn(userio_misc.this_device,\n\t\t\t\t \"Can't change port type on an already running userio instance\\n\");\n\t\t\terror = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tuserio->serio->id.type = cmd.data;\n\t\tbreak;\n\n\tcase USERIO_CMD_SEND_INTERRUPT:\n\t\tif (!userio->running) {\n\t\t\tdev_warn(userio_misc.this_device,\n\t\t\t\t \"The device must be registered before sending interrupts\\n\");\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tserio_interrupt(userio->serio, cmd.data, 0);\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&userio->mutex);\n\treturn error ?: count;\n}\n\nstatic __poll_t userio_char_poll(struct file *file, poll_table *wait)\n{\n\tstruct userio_device *userio = file->private_data;\n\n\tpoll_wait(file, &userio->waitq, wait);\n\n\tif (userio->head != userio->tail)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\nstatic const struct file_operations userio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= userio_char_open,\n\t.release\t= userio_char_release,\n\t.read\t\t= userio_char_read,\n\t.write\t\t= userio_char_write,\n\t.poll\t\t= userio_char_poll,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice userio_misc = {\n\t.fops\t= &userio_fops,\n\t.minor\t= USERIO_MINOR,\n\t.name\t= USERIO_NAME,\n};\nmodule_driver(userio_misc, misc_register, misc_deregister);\n\nMODULE_ALIAS_MISCDEV(USERIO_MINOR);\nMODULE_ALIAS(\"devname:\" USERIO_NAME);\n\nMODULE_AUTHOR(\"Stephen Chandler Paul <thatslyude@gmail.com>\");\nMODULE_DESCRIPTION(\"Virtual Serio Device Support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}