{
  "module_name": "q40kbd.c",
  "hash_id": "b321dc36020d2a22f0590eb783652999689027d4a7522b72ea1fbbb5dba853a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/q40kbd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/q40_master.h>\n#include <asm/irq.h>\n#include <asm/q40ints.h>\n\n#define DRV_NAME\t\"q40kbd\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Q40 PS/2 keyboard controller driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n\nstruct q40kbd {\n\tstruct serio *port;\n\tspinlock_t lock;\n};\n\nstatic irqreturn_t q40kbd_interrupt(int irq, void *dev_id)\n{\n\tstruct q40kbd *q40kbd = dev_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q40kbd->lock, flags);\n\n\tif (Q40_IRQ_KEYB_MASK & master_inb(INTERRUPT_REG))\n\t\tserio_interrupt(q40kbd->port, master_inb(KEYCODE_REG), 0);\n\n\tmaster_outb(-1, KEYBOARD_UNLOCK_REG);\n\n\tspin_unlock_irqrestore(&q40kbd->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void q40kbd_flush(struct q40kbd *q40kbd)\n{\n\tint maxread = 100;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q40kbd->lock, flags);\n\n\twhile (maxread-- && (Q40_IRQ_KEYB_MASK & master_inb(INTERRUPT_REG)))\n\t\tmaster_inb(KEYCODE_REG);\n\n\tspin_unlock_irqrestore(&q40kbd->lock, flags);\n}\n\nstatic void q40kbd_stop(void)\n{\n\tmaster_outb(0, KEY_IRQ_ENABLE_REG);\n\tmaster_outb(-1, KEYBOARD_UNLOCK_REG);\n}\n\n \n\nstatic int q40kbd_open(struct serio *port)\n{\n\tstruct q40kbd *q40kbd = port->port_data;\n\n\tq40kbd_flush(q40kbd);\n\n\t \n\tmaster_outb(-1, KEYBOARD_UNLOCK_REG);\n\tmaster_outb(1, KEY_IRQ_ENABLE_REG);\n\n\treturn 0;\n}\n\nstatic void q40kbd_close(struct serio *port)\n{\n\tstruct q40kbd *q40kbd = port->port_data;\n\n\tq40kbd_stop();\n\tq40kbd_flush(q40kbd);\n}\n\nstatic int q40kbd_probe(struct platform_device *pdev)\n{\n\tstruct q40kbd *q40kbd;\n\tstruct serio *port;\n\tint error;\n\n\tq40kbd = kzalloc(sizeof(struct q40kbd), GFP_KERNEL);\n\tport = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!q40kbd || !port) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tq40kbd->port = port;\n\tspin_lock_init(&q40kbd->lock);\n\n\tport->id.type = SERIO_8042;\n\tport->open = q40kbd_open;\n\tport->close = q40kbd_close;\n\tport->port_data = q40kbd;\n\tport->dev.parent = &pdev->dev;\n\tstrscpy(port->name, \"Q40 Kbd Port\", sizeof(port->name));\n\tstrscpy(port->phys, \"Q40\", sizeof(port->phys));\n\n\tq40kbd_stop();\n\n\terror = request_irq(Q40_IRQ_KEYBOARD, q40kbd_interrupt, 0,\n\t\t\t    DRV_NAME, q40kbd);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Can't get irq %d.\\n\", Q40_IRQ_KEYBOARD);\n\t\tgoto err_free_mem;\n\t}\n\n\tserio_register_port(q40kbd->port);\n\n\tplatform_set_drvdata(pdev, q40kbd);\n\tprintk(KERN_INFO \"serio: Q40 kbd registered\\n\");\n\n\treturn 0;\n\nerr_free_mem:\n\tkfree(port);\n\tkfree(q40kbd);\n\treturn error;\n}\n\nstatic int q40kbd_remove(struct platform_device *pdev)\n{\n\tstruct q40kbd *q40kbd = platform_get_drvdata(pdev);\n\n\t \n\tserio_unregister_port(q40kbd->port);\n\tfree_irq(Q40_IRQ_KEYBOARD, q40kbd);\n\tkfree(q40kbd);\n\n\treturn 0;\n}\n\nstatic struct platform_driver q40kbd_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"q40kbd\",\n\t},\n\t.remove\t\t= q40kbd_remove,\n};\n\nmodule_platform_driver_probe(q40kbd_driver, q40kbd_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}