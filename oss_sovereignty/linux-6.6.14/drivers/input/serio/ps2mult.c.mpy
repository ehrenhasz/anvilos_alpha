{
  "module_name": "ps2mult.c",
  "hash_id": "17354bb3f2c212acbe5e0d2cad18ae2254470ad677465cc07561e44c34b97e13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/ps2mult.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n\nMODULE_AUTHOR(\"Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>\");\nMODULE_DESCRIPTION(\"TQC PS/2 Multiplexer driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define PS2MULT_KB_SELECTOR\t\t0xA0\n#define PS2MULT_MS_SELECTOR\t\t0xA1\n#define PS2MULT_ESCAPE\t\t\t0x7D\n#define PS2MULT_BSYNC\t\t\t0x7E\n#define PS2MULT_SESSION_START\t\t0x55\n#define PS2MULT_SESSION_END\t\t0x56\n\nstruct ps2mult_port {\n\tstruct serio *serio;\n\tunsigned char sel;\n\tbool registered;\n};\n\n#define PS2MULT_NUM_PORTS\t2\n#define PS2MULT_KBD_PORT\t0\n#define PS2MULT_MOUSE_PORT\t1\n\nstruct ps2mult {\n\tstruct serio *mx_serio;\n\tstruct ps2mult_port ports[PS2MULT_NUM_PORTS];\n\n\tspinlock_t lock;\n\tstruct ps2mult_port *in_port;\n\tstruct ps2mult_port *out_port;\n\tbool escape;\n};\n\n \nstatic const unsigned char ps2mult_controls[] = {\n\tPS2MULT_KB_SELECTOR, PS2MULT_MS_SELECTOR,\n\tPS2MULT_ESCAPE, PS2MULT_BSYNC,\n\tPS2MULT_SESSION_START, PS2MULT_SESSION_END,\n};\n\nstatic const struct serio_device_id ps2mult_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_PS2MULT,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, ps2mult_serio_ids);\n\nstatic void ps2mult_select_port(struct ps2mult *psm, struct ps2mult_port *port)\n{\n\tstruct serio *mx_serio = psm->mx_serio;\n\n\tserio_write(mx_serio, port->sel);\n\tpsm->out_port = port;\n\tdev_dbg(&mx_serio->dev, \"switched to sel %02x\\n\", port->sel);\n}\n\nstatic int ps2mult_serio_write(struct serio *serio, unsigned char data)\n{\n\tstruct serio *mx_port = serio->parent;\n\tstruct ps2mult *psm = serio_get_drvdata(mx_port);\n\tstruct ps2mult_port *port = serio->port_data;\n\tbool need_escape;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&psm->lock, flags);\n\n\tif (psm->out_port != port)\n\t\tps2mult_select_port(psm, port);\n\n\tneed_escape = memchr(ps2mult_controls, data, sizeof(ps2mult_controls));\n\n\tdev_dbg(&serio->dev,\n\t\t\"write: %s%02x\\n\", need_escape ? \"ESC \" : \"\", data);\n\n\tif (need_escape)\n\t\tserio_write(mx_port, PS2MULT_ESCAPE);\n\n\tserio_write(mx_port, data);\n\n\tspin_unlock_irqrestore(&psm->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ps2mult_serio_start(struct serio *serio)\n{\n\tstruct ps2mult *psm = serio_get_drvdata(serio->parent);\n\tstruct ps2mult_port *port = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&psm->lock, flags);\n\tport->registered = true;\n\tspin_unlock_irqrestore(&psm->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ps2mult_serio_stop(struct serio *serio)\n{\n\tstruct ps2mult *psm = serio_get_drvdata(serio->parent);\n\tstruct ps2mult_port *port = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&psm->lock, flags);\n\tport->registered = false;\n\tspin_unlock_irqrestore(&psm->lock, flags);\n}\n\nstatic int ps2mult_create_port(struct ps2mult *psm, int i)\n{\n\tstruct serio *mx_serio = psm->mx_serio;\n\tstruct serio *serio;\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tstrscpy(serio->name, \"TQC PS/2 Multiplexer\", sizeof(serio->name));\n\tsnprintf(serio->phys, sizeof(serio->phys),\n\t\t \"%s/port%d\", mx_serio->phys, i);\n\tserio->id.type = SERIO_8042;\n\tserio->write = ps2mult_serio_write;\n\tserio->start = ps2mult_serio_start;\n\tserio->stop = ps2mult_serio_stop;\n\tserio->parent = psm->mx_serio;\n\tserio->port_data = &psm->ports[i];\n\n\tpsm->ports[i].serio = serio;\n\n\treturn 0;\n}\n\nstatic void ps2mult_reset(struct ps2mult *psm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&psm->lock, flags);\n\n\tserio_write(psm->mx_serio, PS2MULT_SESSION_END);\n\tserio_write(psm->mx_serio, PS2MULT_SESSION_START);\n\n\tps2mult_select_port(psm, &psm->ports[PS2MULT_KBD_PORT]);\n\n\tspin_unlock_irqrestore(&psm->lock, flags);\n}\n\nstatic int ps2mult_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct ps2mult *psm;\n\tint i;\n\tint error;\n\n\tif (!serio->write)\n\t\treturn -EINVAL;\n\n\tpsm = kzalloc(sizeof(*psm), GFP_KERNEL);\n\tif (!psm)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&psm->lock);\n\tpsm->mx_serio = serio;\n\n\tfor (i = 0; i < PS2MULT_NUM_PORTS; i++) {\n\t\tpsm->ports[i].sel = ps2mult_controls[i];\n\t\terror = ps2mult_create_port(psm, i);\n\t\tif (error)\n\t\t\tgoto err_out;\n\t}\n\n\tpsm->in_port = psm->out_port = &psm->ports[PS2MULT_KBD_PORT];\n\n\tserio_set_drvdata(serio, psm);\n\terror = serio_open(serio, drv);\n\tif (error)\n\t\tgoto err_out;\n\n\tps2mult_reset(psm);\n\n\tfor (i = 0; i <  PS2MULT_NUM_PORTS; i++) {\n\t\tstruct serio *s = psm->ports[i].serio;\n\n\t\tdev_info(&serio->dev, \"%s port at %s\\n\", s->name, serio->phys);\n\t\tserio_register_port(s);\n\t}\n\n\treturn 0;\n\nerr_out:\n\twhile (--i >= 0)\n\t\tkfree(psm->ports[i].serio);\n\tkfree(psm);\n\treturn error;\n}\n\nstatic void ps2mult_disconnect(struct serio *serio)\n{\n\tstruct ps2mult *psm = serio_get_drvdata(serio);\n\n\t \n\tserio_write(serio, PS2MULT_SESSION_END);\n\tserio_close(serio);\n\tkfree(psm);\n\n\tserio_set_drvdata(serio, NULL);\n}\n\nstatic int ps2mult_reconnect(struct serio *serio)\n{\n\tstruct ps2mult *psm = serio_get_drvdata(serio);\n\n\tps2mult_reset(psm);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ps2mult_interrupt(struct serio *serio,\n\t\t\t\t     unsigned char data, unsigned int dfl)\n{\n\tstruct ps2mult *psm = serio_get_drvdata(serio);\n\tstruct ps2mult_port *in_port;\n\tunsigned long flags;\n\n\tdev_dbg(&serio->dev, \"Received %02x flags %02x\\n\", data, dfl);\n\n\tspin_lock_irqsave(&psm->lock, flags);\n\n\tif (psm->escape) {\n\t\tpsm->escape = false;\n\t\tin_port = psm->in_port;\n\t\tif (in_port->registered)\n\t\t\tserio_interrupt(in_port->serio, data, dfl);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\tcase PS2MULT_ESCAPE:\n\t\tdev_dbg(&serio->dev, \"ESCAPE\\n\");\n\t\tpsm->escape = true;\n\t\tbreak;\n\n\tcase PS2MULT_BSYNC:\n\t\tdev_dbg(&serio->dev, \"BSYNC\\n\");\n\t\tpsm->in_port = psm->out_port;\n\t\tbreak;\n\n\tcase PS2MULT_SESSION_START:\n\t\tdev_dbg(&serio->dev, \"SS\\n\");\n\t\tbreak;\n\n\tcase PS2MULT_SESSION_END:\n\t\tdev_dbg(&serio->dev, \"SE\\n\");\n\t\tbreak;\n\n\tcase PS2MULT_KB_SELECTOR:\n\t\tdev_dbg(&serio->dev, \"KB\\n\");\n\t\tpsm->in_port = &psm->ports[PS2MULT_KBD_PORT];\n\t\tbreak;\n\n\tcase PS2MULT_MS_SELECTOR:\n\t\tdev_dbg(&serio->dev, \"MS\\n\");\n\t\tpsm->in_port = &psm->ports[PS2MULT_MOUSE_PORT];\n\t\tbreak;\n\n\tdefault:\n\t\tin_port = psm->in_port;\n\t\tif (in_port->registered)\n\t\t\tserio_interrupt(in_port->serio, data, dfl);\n\t\tbreak;\n\t}\n\n out:\n\tspin_unlock_irqrestore(&psm->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct serio_driver ps2mult_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"ps2mult\",\n\t},\n\t.description\t= \"TQC PS/2 Multiplexer driver\",\n\t.id_table\t= ps2mult_serio_ids,\n\t.interrupt\t= ps2mult_interrupt,\n\t.connect\t= ps2mult_connect,\n\t.disconnect\t= ps2mult_disconnect,\n\t.reconnect\t= ps2mult_reconnect,\n};\n\nmodule_serio_driver(ps2mult_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}