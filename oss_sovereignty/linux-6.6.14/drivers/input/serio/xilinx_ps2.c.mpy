{
  "module_name": "xilinx_ps2.c",
  "hash_id": "e3d878b4115d247c541650d35c4a1136d81d059daa9358f3c2ad3acee567b1d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/xilinx_ps2.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#define DRIVER_NAME\t\t\"xilinx_ps2\"\n\n \n#define XPS2_SRST_OFFSET\t0x00000000  \n#define XPS2_STATUS_OFFSET\t0x00000004  \n#define XPS2_RX_DATA_OFFSET\t0x00000008  \n#define XPS2_TX_DATA_OFFSET\t0x0000000C  \n#define XPS2_GIER_OFFSET\t0x0000002C  \n#define XPS2_IPISR_OFFSET\t0x00000030  \n#define XPS2_IPIER_OFFSET\t0x00000038  \n\n \n#define XPS2_SRST_RESET\t\t0x0000000A  \n\n \n#define XPS2_STATUS_RX_FULL\t0x00000001  \n#define XPS2_STATUS_TX_FULL\t0x00000002  \n\n \n#define XPS2_IPIXR_WDT_TOUT\t0x00000001  \n#define XPS2_IPIXR_TX_NOACK\t0x00000002  \n#define XPS2_IPIXR_TX_ACK\t0x00000004  \n#define XPS2_IPIXR_RX_OVF\t0x00000008  \n#define XPS2_IPIXR_RX_ERR\t0x00000010  \n#define XPS2_IPIXR_RX_FULL\t0x00000020  \n\n \n#define XPS2_IPIXR_TX_ALL\t(XPS2_IPIXR_TX_NOACK | XPS2_IPIXR_TX_ACK)\n\n \n#define XPS2_IPIXR_RX_ALL\t(XPS2_IPIXR_RX_OVF | XPS2_IPIXR_RX_ERR |  \\\n\t\t\t\t XPS2_IPIXR_RX_FULL)\n\n \n#define XPS2_IPIXR_ALL\t\t(XPS2_IPIXR_TX_ALL | XPS2_IPIXR_RX_ALL |  \\\n\t\t\t\t XPS2_IPIXR_WDT_TOUT)\n\n \n#define XPS2_GIER_GIE_MASK\t0x80000000\n\nstruct xps2data {\n\tint irq;\n\tspinlock_t lock;\n\tvoid __iomem *base_address;\t \n\tunsigned int flags;\n\tstruct serio *serio;\t\t \n\tstruct device *dev;\n};\n\n \n \n \n\n \nstatic int xps2_recv(struct xps2data *drvdata, u8 *byte)\n{\n\tu32 sr;\n\tint status = -1;\n\n\t \n\tsr = in_be32(drvdata->base_address + XPS2_STATUS_OFFSET);\n\tif (sr & XPS2_STATUS_RX_FULL) {\n\t\t*byte = in_be32(drvdata->base_address + XPS2_RX_DATA_OFFSET);\n\t\tstatus = 0;\n\t}\n\n\treturn status;\n}\n\n \n \n \nstatic irqreturn_t xps2_interrupt(int irq, void *dev_id)\n{\n\tstruct xps2data *drvdata = dev_id;\n\tu32 intr_sr;\n\tu8 c;\n\tint status;\n\n\t \n\tintr_sr = in_be32(drvdata->base_address + XPS2_IPISR_OFFSET);\n\tout_be32(drvdata->base_address + XPS2_IPISR_OFFSET, intr_sr);\n\n\t \n\tif (intr_sr & XPS2_IPIXR_RX_OVF)\n\t\tdev_warn(drvdata->dev, \"receive overrun error\\n\");\n\n\tif (intr_sr & XPS2_IPIXR_RX_ERR)\n\t\tdrvdata->flags |= SERIO_PARITY;\n\n\tif (intr_sr & (XPS2_IPIXR_TX_NOACK | XPS2_IPIXR_WDT_TOUT))\n\t\tdrvdata->flags |= SERIO_TIMEOUT;\n\n\tif (intr_sr & XPS2_IPIXR_RX_FULL) {\n\t\tstatus = xps2_recv(drvdata, &c);\n\n\t\t \n\t\tif (status) {\n\t\t\tdev_err(drvdata->dev,\n\t\t\t\t\"wrong rcvd byte count (%d)\\n\", status);\n\t\t} else {\n\t\t\tserio_interrupt(drvdata->serio, c, drvdata->flags);\n\t\t\tdrvdata->flags = 0;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n \n \n\n \nstatic int sxps2_write(struct serio *pserio, unsigned char c)\n{\n\tstruct xps2data *drvdata = pserio->port_data;\n\tunsigned long flags;\n\tu32 sr;\n\tint status = -1;\n\n\tspin_lock_irqsave(&drvdata->lock, flags);\n\n\t \n\tsr = in_be32(drvdata->base_address + XPS2_STATUS_OFFSET);\n\tif (!(sr & XPS2_STATUS_TX_FULL)) {\n\t\tout_be32(drvdata->base_address + XPS2_TX_DATA_OFFSET, c);\n\t\tstatus = 0;\n\t}\n\n\tspin_unlock_irqrestore(&drvdata->lock, flags);\n\n\treturn status;\n}\n\n \nstatic int sxps2_open(struct serio *pserio)\n{\n\tstruct xps2data *drvdata = pserio->port_data;\n\tint error;\n\tu8 c;\n\n\terror = request_irq(drvdata->irq, &xps2_interrupt, 0,\n\t\t\t\tDRIVER_NAME, drvdata);\n\tif (error) {\n\t\tdev_err(drvdata->dev,\n\t\t\t\"Couldn't allocate interrupt %d\\n\", drvdata->irq);\n\t\treturn error;\n\t}\n\n\t \n\tout_be32(drvdata->base_address + XPS2_GIER_OFFSET, XPS2_GIER_GIE_MASK);\n\tout_be32(drvdata->base_address + XPS2_IPIER_OFFSET, XPS2_IPIXR_RX_ALL);\n\t(void)xps2_recv(drvdata, &c);\n\n\treturn 0;\t\t \n}\n\n \nstatic void sxps2_close(struct serio *pserio)\n{\n\tstruct xps2data *drvdata = pserio->port_data;\n\n\t \n\tout_be32(drvdata->base_address + XPS2_GIER_OFFSET, 0x00);\n\tout_be32(drvdata->base_address + XPS2_IPIER_OFFSET, 0x00);\n\tfree_irq(drvdata->irq, drvdata);\n}\n\n \nstatic int xps2_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource r_mem;  \n\tstruct xps2data *drvdata;\n\tstruct serio *serio;\n\tstruct device *dev = &ofdev->dev;\n\tresource_size_t remap_size, phys_addr;\n\tunsigned int irq;\n\tint error;\n\n\tdev_info(dev, \"Device Tree Probing \\'%pOFn\\'\\n\", dev->of_node);\n\n\t \n\terror = of_address_to_resource(dev->of_node, 0, &r_mem);\n\tif (error) {\n\t\tdev_err(dev, \"invalid address\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrvdata = kzalloc(sizeof(struct xps2data), GFP_KERNEL);\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!drvdata || !serio) {\n\t\terror = -ENOMEM;\n\t\tgoto failed1;\n\t}\n\n\tspin_lock_init(&drvdata->lock);\n\tdrvdata->irq = irq;\n\tdrvdata->serio = serio;\n\tdrvdata->dev = dev;\n\n\tphys_addr = r_mem.start;\n\tremap_size = resource_size(&r_mem);\n\tif (!request_mem_region(phys_addr, remap_size, DRIVER_NAME)) {\n\t\tdev_err(dev, \"Couldn't lock memory region at 0x%08llX\\n\",\n\t\t\t(unsigned long long)phys_addr);\n\t\terror = -EBUSY;\n\t\tgoto failed1;\n\t}\n\n\t \n\tdrvdata->base_address = ioremap(phys_addr, remap_size);\n\tif (drvdata->base_address == NULL) {\n\t\tdev_err(dev, \"Couldn't ioremap memory at 0x%08llX\\n\",\n\t\t\t(unsigned long long)phys_addr);\n\t\terror = -EFAULT;\n\t\tgoto failed2;\n\t}\n\n\t \n\tout_be32(drvdata->base_address + XPS2_IPIER_OFFSET, 0);\n\n\t \n\tout_be32(drvdata->base_address + XPS2_SRST_OFFSET, XPS2_SRST_RESET);\n\n\tdev_info(dev, \"Xilinx PS2 at 0x%08llX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long long)phys_addr, drvdata->base_address,\n\t\t drvdata->irq);\n\n\tserio->id.type = SERIO_8042;\n\tserio->write = sxps2_write;\n\tserio->open = sxps2_open;\n\tserio->close = sxps2_close;\n\tserio->port_data = drvdata;\n\tserio->dev.parent = dev;\n\tsnprintf(serio->name, sizeof(serio->name),\n\t\t \"Xilinx XPS PS/2 at %08llX\", (unsigned long long)phys_addr);\n\tsnprintf(serio->phys, sizeof(serio->phys),\n\t\t \"xilinxps2/serio at %08llX\", (unsigned long long)phys_addr);\n\n\tserio_register_port(serio);\n\n\tplatform_set_drvdata(ofdev, drvdata);\n\treturn 0;\t\t \n\nfailed2:\n\trelease_mem_region(phys_addr, remap_size);\nfailed1:\n\tkfree(serio);\n\tkfree(drvdata);\n\n\treturn error;\n}\n\n \nstatic int xps2_of_remove(struct platform_device *of_dev)\n{\n\tstruct xps2data *drvdata = platform_get_drvdata(of_dev);\n\tstruct resource r_mem;  \n\n\tserio_unregister_port(drvdata->serio);\n\tiounmap(drvdata->base_address);\n\n\t \n\tif (of_address_to_resource(of_dev->dev.of_node, 0, &r_mem))\n\t\tdev_err(drvdata->dev, \"invalid address\\n\");\n\telse\n\t\trelease_mem_region(r_mem.start, resource_size(&r_mem));\n\n\tkfree(drvdata);\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id xps2_of_match[] = {\n\t{ .compatible = \"xlnx,xps-ps2-1.00.a\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, xps2_of_match);\n\nstatic struct platform_driver xps2_of_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = xps2_of_match,\n\t},\n\t.probe\t\t= xps2_of_probe,\n\t.remove\t\t= xps2_of_remove,\n};\nmodule_platform_driver(xps2_of_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx XPS PS/2 driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}