{
  "module_name": "i8042-sparcio.h",
  "hash_id": "7d80c6b2646f57e724a9f4a112ad1a506fdf398c7840a5f2aa8381cd5d6037c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/i8042-sparcio.h",
  "human_readable_source": " \n#ifndef _I8042_SPARCIO_H\n#define _I8042_SPARCIO_H\n\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <asm/io.h>\n#include <asm/oplib.h>\n#include <asm/prom.h>\n\nstatic int i8042_kbd_irq = -1;\nstatic int i8042_aux_irq = -1;\n#define I8042_KBD_IRQ i8042_kbd_irq\n#define I8042_AUX_IRQ i8042_aux_irq\n\n#define I8042_KBD_PHYS_DESC \"sparcps2/serio0\"\n#define I8042_AUX_PHYS_DESC \"sparcps2/serio1\"\n#define I8042_MUX_PHYS_DESC \"sparcps2/serio%d\"\n\nstatic void __iomem *kbd_iobase;\n\n#define I8042_COMMAND_REG\t(kbd_iobase + 0x64UL)\n#define I8042_DATA_REG\t\t(kbd_iobase + 0x60UL)\n\nstatic inline int i8042_read_data(void)\n{\n\treturn readb(kbd_iobase + 0x60UL);\n}\n\nstatic inline int i8042_read_status(void)\n{\n\treturn readb(kbd_iobase + 0x64UL);\n}\n\nstatic inline void i8042_write_data(int val)\n{\n\twriteb(val, kbd_iobase + 0x60UL);\n}\n\nstatic inline void i8042_write_command(int val)\n{\n\twriteb(val, kbd_iobase + 0x64UL);\n}\n\n#ifdef CONFIG_PCI\n\nstatic struct resource *kbd_res;\n\n#define OBP_PS2KBD_NAME1\t\"kb_ps2\"\n#define OBP_PS2KBD_NAME2\t\"keyboard\"\n#define OBP_PS2MS_NAME1\t\t\"kdmouse\"\n#define OBP_PS2MS_NAME2\t\t\"mouse\"\n\nstatic int sparc_i8042_probe(struct platform_device *op)\n{\n\tstruct device_node *dp;\n\n\tfor_each_child_of_node(op->dev.of_node, dp) {\n\t\tif (of_node_name_eq(dp, OBP_PS2KBD_NAME1) ||\n\t\t    of_node_name_eq(dp, OBP_PS2KBD_NAME2)) {\n\t\t\tstruct platform_device *kbd = of_find_device_by_node(dp);\n\t\t\tunsigned int irq = kbd->archdata.irqs[0];\n\t\t\tif (irq == 0xffffffff)\n\t\t\t\tirq = op->archdata.irqs[0];\n\t\t\ti8042_kbd_irq = irq;\n\t\t\tkbd_iobase = of_ioremap(&kbd->resource[0],\n\t\t\t\t\t\t0, 8, \"kbd\");\n\t\t\tkbd_res = &kbd->resource[0];\n\t\t} else if (of_node_name_eq(dp, OBP_PS2MS_NAME1) ||\n\t\t\t   of_node_name_eq(dp, OBP_PS2MS_NAME2)) {\n\t\t\tstruct platform_device *ms = of_find_device_by_node(dp);\n\t\t\tunsigned int irq = ms->archdata.irqs[0];\n\t\t\tif (irq == 0xffffffff)\n\t\t\t\tirq = op->archdata.irqs[0];\n\t\t\ti8042_aux_irq = irq;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sparc_i8042_remove(struct platform_device *op)\n{\n\tof_iounmap(kbd_res, kbd_iobase, 8);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sparc_i8042_match[] = {\n\t{\n\t\t.name = \"8042\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sparc_i8042_match);\n\nstatic struct platform_driver sparc_i8042_driver = {\n\t.driver = {\n\t\t.name = \"i8042\",\n\t\t.of_match_table = sparc_i8042_match,\n\t},\n\t.probe\t\t= sparc_i8042_probe,\n\t.remove\t\t= sparc_i8042_remove,\n};\n\nstatic bool i8042_is_mr_coffee(void)\n{\n\tstruct device_node *root;\n\tconst char *name;\n\tbool is_mr_coffee;\n\n\troot = of_find_node_by_path(\"/\");\n\n\tname = of_get_property(root, \"name\", NULL);\n\tis_mr_coffee = name && !strcmp(name, \"SUNW,JavaStation-1\");\n\n\tof_node_put(root);\n\n\treturn is_mr_coffee;\n}\n\nstatic int __init i8042_platform_init(void)\n{\n\tif (i8042_is_mr_coffee()) {\n\t\t \n\t\ti8042_kbd_irq = i8042_aux_irq = 13 | 0x20;\n\t\tkbd_iobase = ioremap(0x71300060, 8);\n\t\tif (!kbd_iobase)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tint err = platform_driver_register(&sparc_i8042_driver);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (i8042_kbd_irq == -1 ||\n\t\t    i8042_aux_irq == -1) {\n\t\t\tif (kbd_iobase) {\n\t\t\t\tof_iounmap(kbd_res, kbd_iobase, 8);\n\t\t\t\tkbd_iobase = (void __iomem *) NULL;\n\t\t\t}\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\ti8042_reset = I8042_RESET_ALWAYS;\n\n\treturn 0;\n}\n\nstatic inline void i8042_platform_exit(void)\n{\n\tif (!i8042_is_mr_coffee())\n\t\tplatform_driver_unregister(&sparc_i8042_driver);\n}\n\n#else  \nstatic int __init i8042_platform_init(void)\n{\n\treturn -ENODEV;\n}\n\nstatic inline void i8042_platform_exit(void)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}