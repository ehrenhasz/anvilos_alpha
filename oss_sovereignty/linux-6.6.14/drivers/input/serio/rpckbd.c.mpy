{
  "module_name": "rpckbd.c",
  "hash_id": "4c41051e9651c3671c67750f1cc59c7974310f3b35eda16141d3a70b6c4f70a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/rpckbd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/serio.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <mach/hardware.h>\n#include <asm/hardware/iomd.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik, Russell King\");\nMODULE_DESCRIPTION(\"Acorn RiscPC PS/2 keyboard controller driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:kart\");\n\nstruct rpckbd_data {\n\tint tx_irq;\n\tint rx_irq;\n};\n\nstatic int rpckbd_write(struct serio *port, unsigned char val)\n{\n\twhile (!(iomd_readb(IOMD_KCTRL) & (1 << 7)))\n\t\tcpu_relax();\n\n\tiomd_writeb(val, IOMD_KARTTX);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rpckbd_rx(int irq, void *dev_id)\n{\n\tstruct serio *port = dev_id;\n\tunsigned int byte;\n\tint handled = IRQ_NONE;\n\n\twhile (iomd_readb(IOMD_KCTRL) & (1 << 5)) {\n\t\tbyte = iomd_readb(IOMD_KARTRX);\n\n\t\tserio_interrupt(port, byte, 0);\n\t\thandled = IRQ_HANDLED;\n\t}\n\treturn handled;\n}\n\nstatic irqreturn_t rpckbd_tx(int irq, void *dev_id)\n{\n\treturn IRQ_HANDLED;\n}\n\nstatic int rpckbd_open(struct serio *port)\n{\n\tstruct rpckbd_data *rpckbd = port->port_data;\n\n\t \n\tiomd_writeb(0, IOMD_KCTRL);\n\tiomd_writeb(8, IOMD_KCTRL);\n\tiomd_readb(IOMD_KARTRX);\n\n\tif (request_irq(rpckbd->rx_irq, rpckbd_rx, 0, \"rpckbd\", port) != 0) {\n\t\tprintk(KERN_ERR \"rpckbd.c: Could not allocate keyboard receive IRQ\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (request_irq(rpckbd->tx_irq, rpckbd_tx, 0, \"rpckbd\", port) != 0) {\n\t\tprintk(KERN_ERR \"rpckbd.c: Could not allocate keyboard transmit IRQ\\n\");\n\t\tfree_irq(rpckbd->rx_irq, port);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void rpckbd_close(struct serio *port)\n{\n\tstruct rpckbd_data *rpckbd = port->port_data;\n\n\tfree_irq(rpckbd->rx_irq, port);\n\tfree_irq(rpckbd->tx_irq, port);\n}\n\n \nstatic int rpckbd_probe(struct platform_device *dev)\n{\n\tstruct rpckbd_data *rpckbd;\n\tstruct serio *serio;\n\tint tx_irq, rx_irq;\n\n\trx_irq = platform_get_irq(dev, 0);\n\tif (rx_irq < 0)\n\t\treturn rx_irq;\n\n\ttx_irq = platform_get_irq(dev, 1);\n\tif (tx_irq < 0)\n\t\treturn tx_irq;\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\trpckbd = kzalloc(sizeof(*rpckbd), GFP_KERNEL);\n\tif (!serio || !rpckbd) {\n\t\tkfree(rpckbd);\n\t\tkfree(serio);\n\t\treturn -ENOMEM;\n\t}\n\n\trpckbd->rx_irq = rx_irq;\n\trpckbd->tx_irq = tx_irq;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= rpckbd_write;\n\tserio->open\t\t= rpckbd_open;\n\tserio->close\t\t= rpckbd_close;\n\tserio->dev.parent\t= &dev->dev;\n\tserio->port_data\t= rpckbd;\n\tstrscpy(serio->name, \"RiscPC PS/2 kbd port\", sizeof(serio->name));\n\tstrscpy(serio->phys, \"rpckbd/serio0\", sizeof(serio->phys));\n\n\tplatform_set_drvdata(dev, serio);\n\tserio_register_port(serio);\n\treturn 0;\n}\n\nstatic int rpckbd_remove(struct platform_device *dev)\n{\n\tstruct serio *serio = platform_get_drvdata(dev);\n\tstruct rpckbd_data *rpckbd = serio->port_data;\n\n\tserio_unregister_port(serio);\n\tkfree(rpckbd);\n\n\treturn 0;\n}\n\nstatic struct platform_driver rpckbd_driver = {\n\t.probe\t\t= rpckbd_probe,\n\t.remove\t\t= rpckbd_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"kart\",\n\t},\n};\nmodule_platform_driver(rpckbd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}