{
  "module_name": "serio_raw.c",
  "hash_id": "9ddd1530ed39f877852d3483fd6c7a1c7dcd5258a893b8c67d90ec8cf802a275",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/serio_raw.c",
  "human_readable_source": "\n \n\n#include <linux/kref.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/major.h>\n#include <linux/device.h>\n#include <linux/miscdevice.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n\n#define DRIVER_DESC\t\"Raw serio driver\"\n\nMODULE_AUTHOR(\"Dmitry Torokhov <dtor@mail.ru>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define SERIO_RAW_QUEUE_LEN\t64\nstruct serio_raw {\n\tunsigned char queue[SERIO_RAW_QUEUE_LEN];\n\tunsigned int tail, head;\n\n\tchar name[16];\n\tstruct kref kref;\n\tstruct serio *serio;\n\tstruct miscdevice dev;\n\twait_queue_head_t wait;\n\tstruct list_head client_list;\n\tstruct list_head node;\n\tbool dead;\n};\n\nstruct serio_raw_client {\n\tstruct fasync_struct *fasync;\n\tstruct serio_raw *serio_raw;\n\tstruct list_head node;\n};\n\nstatic DEFINE_MUTEX(serio_raw_mutex);\nstatic LIST_HEAD(serio_raw_list);\n\n \n\nstatic int serio_raw_fasync(int fd, struct file *file, int on)\n{\n\tstruct serio_raw_client *client = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &client->fasync);\n}\n\nstatic struct serio_raw *serio_raw_locate(int minor)\n{\n\tstruct serio_raw *serio_raw;\n\n\tlist_for_each_entry(serio_raw, &serio_raw_list, node) {\n\t\tif (serio_raw->dev.minor == minor)\n\t\t\treturn serio_raw;\n\t}\n\n\treturn NULL;\n}\n\nstatic int serio_raw_open(struct inode *inode, struct file *file)\n{\n\tstruct serio_raw *serio_raw;\n\tstruct serio_raw_client *client;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&serio_raw_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tserio_raw = serio_raw_locate(iminor(inode));\n\tif (!serio_raw) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (serio_raw->dead) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tclient = kzalloc(sizeof(struct serio_raw_client), GFP_KERNEL);\n\tif (!client) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tclient->serio_raw = serio_raw;\n\tfile->private_data = client;\n\n\tkref_get(&serio_raw->kref);\n\n\tserio_pause_rx(serio_raw->serio);\n\tlist_add_tail(&client->node, &serio_raw->client_list);\n\tserio_continue_rx(serio_raw->serio);\n\nout:\n\tmutex_unlock(&serio_raw_mutex);\n\treturn retval;\n}\n\nstatic void serio_raw_free(struct kref *kref)\n{\n\tstruct serio_raw *serio_raw =\n\t\t\tcontainer_of(kref, struct serio_raw, kref);\n\n\tput_device(&serio_raw->serio->dev);\n\tkfree(serio_raw);\n}\n\nstatic int serio_raw_release(struct inode *inode, struct file *file)\n{\n\tstruct serio_raw_client *client = file->private_data;\n\tstruct serio_raw *serio_raw = client->serio_raw;\n\n\tserio_pause_rx(serio_raw->serio);\n\tlist_del(&client->node);\n\tserio_continue_rx(serio_raw->serio);\n\n\tkfree(client);\n\n\tkref_put(&serio_raw->kref, serio_raw_free);\n\n\treturn 0;\n}\n\nstatic bool serio_raw_fetch_byte(struct serio_raw *serio_raw, char *c)\n{\n\tbool empty;\n\n\tserio_pause_rx(serio_raw->serio);\n\n\tempty = serio_raw->head == serio_raw->tail;\n\tif (!empty) {\n\t\t*c = serio_raw->queue[serio_raw->tail];\n\t\tserio_raw->tail = (serio_raw->tail + 1) % SERIO_RAW_QUEUE_LEN;\n\t}\n\n\tserio_continue_rx(serio_raw->serio);\n\n\treturn !empty;\n}\n\nstatic ssize_t serio_raw_read(struct file *file, char __user *buffer,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct serio_raw_client *client = file->private_data;\n\tstruct serio_raw *serio_raw = client->serio_raw;\n\tchar c;\n\tssize_t read = 0;\n\tint error;\n\n\tfor (;;) {\n\t\tif (serio_raw->dead)\n\t\t\treturn -ENODEV;\n\n\t\tif (serio_raw->head == serio_raw->tail &&\n\t\t    (file->f_flags & O_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\twhile (read < count && serio_raw_fetch_byte(serio_raw, &c)) {\n\t\t\tif (put_user(c, buffer++))\n\t\t\t\treturn -EFAULT;\n\t\t\tread++;\n\t\t}\n\n\t\tif (read)\n\t\t\tbreak;\n\n\t\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\t\terror = wait_event_interruptible(serio_raw->wait,\n\t\t\t\t\tserio_raw->head != serio_raw->tail ||\n\t\t\t\t\tserio_raw->dead);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn read;\n}\n\nstatic ssize_t serio_raw_write(struct file *file, const char __user *buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct serio_raw_client *client = file->private_data;\n\tstruct serio_raw *serio_raw = client->serio_raw;\n\tint retval = 0;\n\tunsigned char c;\n\n\tretval = mutex_lock_interruptible(&serio_raw_mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (serio_raw->dead) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (count > 32)\n\t\tcount = 32;\n\n\twhile (count--) {\n\t\tif (get_user(c, buffer++)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (serio_write(serio_raw->serio, c)) {\n\t\t\t \n\t\t\tif (retval == 0)\n\t\t\t\tretval = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tretval++;\n\t}\n\nout:\n\tmutex_unlock(&serio_raw_mutex);\n\treturn retval;\n}\n\nstatic __poll_t serio_raw_poll(struct file *file, poll_table *wait)\n{\n\tstruct serio_raw_client *client = file->private_data;\n\tstruct serio_raw *serio_raw = client->serio_raw;\n\t__poll_t mask;\n\n\tpoll_wait(file, &serio_raw->wait, wait);\n\n\tmask = serio_raw->dead ? EPOLLHUP | EPOLLERR : EPOLLOUT | EPOLLWRNORM;\n\tif (serio_raw->head != serio_raw->tail)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic const struct file_operations serio_raw_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= serio_raw_open,\n\t.release\t= serio_raw_release,\n\t.read\t\t= serio_raw_read,\n\t.write\t\t= serio_raw_write,\n\t.poll\t\t= serio_raw_poll,\n\t.fasync\t\t= serio_raw_fasync,\n\t.llseek\t\t= noop_llseek,\n};\n\n\n \n\nstatic irqreturn_t serio_raw_interrupt(struct serio *serio, unsigned char data,\n\t\t\t\t\tunsigned int dfl)\n{\n\tstruct serio_raw *serio_raw = serio_get_drvdata(serio);\n\tstruct serio_raw_client *client;\n\tunsigned int head = serio_raw->head;\n\n\t \n\tserio_raw->queue[head] = data;\n\thead = (head + 1) % SERIO_RAW_QUEUE_LEN;\n\tif (likely(head != serio_raw->tail)) {\n\t\tserio_raw->head = head;\n\t\tlist_for_each_entry(client, &serio_raw->client_list, node)\n\t\t\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n\t\twake_up_interruptible(&serio_raw->wait);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int serio_raw_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstatic atomic_t serio_raw_no = ATOMIC_INIT(-1);\n\tstruct serio_raw *serio_raw;\n\tint err;\n\n\tserio_raw = kzalloc(sizeof(struct serio_raw), GFP_KERNEL);\n\tif (!serio_raw) {\n\t\tdev_dbg(&serio->dev, \"can't allocate memory for a device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(serio_raw->name, sizeof(serio_raw->name),\n\t\t \"serio_raw%ld\", (long)atomic_inc_return(&serio_raw_no));\n\tkref_init(&serio_raw->kref);\n\tINIT_LIST_HEAD(&serio_raw->client_list);\n\tinit_waitqueue_head(&serio_raw->wait);\n\n\tserio_raw->serio = serio;\n\tget_device(&serio->dev);\n\n\tserio_set_drvdata(serio, serio_raw);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = mutex_lock_killable(&serio_raw_mutex);\n\tif (err)\n\t\tgoto err_close;\n\n\tlist_add_tail(&serio_raw->node, &serio_raw_list);\n\tmutex_unlock(&serio_raw_mutex);\n\n\tserio_raw->dev.minor = PSMOUSE_MINOR;\n\tserio_raw->dev.name = serio_raw->name;\n\tserio_raw->dev.parent = &serio->dev;\n\tserio_raw->dev.fops = &serio_raw_fops;\n\n\terr = misc_register(&serio_raw->dev);\n\tif (err) {\n\t\tserio_raw->dev.minor = MISC_DYNAMIC_MINOR;\n\t\terr = misc_register(&serio_raw->dev);\n\t}\n\n\tif (err) {\n\t\tdev_err(&serio->dev,\n\t\t\t\"failed to register raw access device for %s\\n\",\n\t\t\tserio->phys);\n\t\tgoto err_unlink;\n\t}\n\n\tdev_info(&serio->dev, \"raw access enabled on %s (%s, minor %d)\\n\",\n\t\t serio->phys, serio_raw->name, serio_raw->dev.minor);\n\treturn 0;\n\nerr_unlink:\n\tlist_del_init(&serio_raw->node);\nerr_close:\n\tserio_close(serio);\nerr_free:\n\tserio_set_drvdata(serio, NULL);\n\tkref_put(&serio_raw->kref, serio_raw_free);\n\treturn err;\n}\n\nstatic int serio_raw_reconnect(struct serio *serio)\n{\n\tstruct serio_raw *serio_raw = serio_get_drvdata(serio);\n\tstruct serio_driver *drv = serio->drv;\n\n\tif (!drv || !serio_raw) {\n\t\tdev_dbg(&serio->dev,\n\t\t\t\"reconnect request, but serio is disconnected, ignoring...\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic void serio_raw_hangup(struct serio_raw *serio_raw)\n{\n\tstruct serio_raw_client *client;\n\n\tserio_pause_rx(serio_raw->serio);\n\tlist_for_each_entry(client, &serio_raw->client_list, node)\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\tserio_continue_rx(serio_raw->serio);\n\n\twake_up_interruptible(&serio_raw->wait);\n}\n\n\nstatic void serio_raw_disconnect(struct serio *serio)\n{\n\tstruct serio_raw *serio_raw = serio_get_drvdata(serio);\n\n\tmisc_deregister(&serio_raw->dev);\n\n\tmutex_lock(&serio_raw_mutex);\n\tserio_raw->dead = true;\n\tlist_del_init(&serio_raw->node);\n\tmutex_unlock(&serio_raw_mutex);\n\n\tserio_raw_hangup(serio_raw);\n\n\tserio_close(serio);\n\tkref_put(&serio_raw->kref, serio_raw_free);\n\n\tserio_set_drvdata(serio, NULL);\n}\n\nstatic const struct serio_device_id serio_raw_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_8042,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{\n\t\t.type\t= SERIO_8042_XL,\n\t\t.proto\t= SERIO_ANY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, serio_raw_serio_ids);\n\nstatic struct serio_driver serio_raw_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"serio_raw\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= serio_raw_serio_ids,\n\t.interrupt\t= serio_raw_interrupt,\n\t.connect\t= serio_raw_connect,\n\t.reconnect\t= serio_raw_reconnect,\n\t.disconnect\t= serio_raw_disconnect,\n\t.manual_bind\t= true,\n};\n\nmodule_serio_driver(serio_raw_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}