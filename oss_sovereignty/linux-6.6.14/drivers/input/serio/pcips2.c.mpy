{
  "module_name": "pcips2.c",
  "hash_id": "8b70efd1ae7788fc92c3e4ed021f258904fc0fc176970a70d0df847416e26665",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/pcips2.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/input.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/serio.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#define PS2_CTRL\t\t(0)\n#define PS2_STATUS\t\t(1)\n#define PS2_DATA\t\t(2)\n\n#define PS2_CTRL_CLK\t\t(1<<0)\n#define PS2_CTRL_DAT\t\t(1<<1)\n#define PS2_CTRL_TXIRQ\t\t(1<<2)\n#define PS2_CTRL_ENABLE\t\t(1<<3)\n#define PS2_CTRL_RXIRQ\t\t(1<<4)\n\n#define PS2_STAT_CLK\t\t(1<<0)\n#define PS2_STAT_DAT\t\t(1<<1)\n#define PS2_STAT_PARITY\t\t(1<<2)\n#define PS2_STAT_RXFULL\t\t(1<<5)\n#define PS2_STAT_TXBUSY\t\t(1<<6)\n#define PS2_STAT_TXEMPTY\t(1<<7)\n\nstruct pcips2_data {\n\tstruct serio\t*io;\n\tunsigned int\tbase;\n\tstruct pci_dev\t*dev;\n};\n\nstatic int pcips2_write(struct serio *io, unsigned char val)\n{\n\tstruct pcips2_data *ps2if = io->port_data;\n\tunsigned int stat;\n\n\tdo {\n\t\tstat = inb(ps2if->base + PS2_STATUS);\n\t\tcpu_relax();\n\t} while (!(stat & PS2_STAT_TXEMPTY));\n\n\toutb(val, ps2if->base + PS2_DATA);\n\n\treturn 0;\n}\n\nstatic irqreturn_t pcips2_interrupt(int irq, void *devid)\n{\n\tstruct pcips2_data *ps2if = devid;\n\tunsigned char status, scancode;\n\tint handled = 0;\n\n\tdo {\n\t\tunsigned int flag;\n\n\t\tstatus = inb(ps2if->base + PS2_STATUS);\n\t\tif (!(status & PS2_STAT_RXFULL))\n\t\t\tbreak;\n\t\thandled = 1;\n\t\tscancode = inb(ps2if->base + PS2_DATA);\n\t\tif (status == 0xff && scancode == 0xff)\n\t\t\tbreak;\n\n\t\tflag = (status & PS2_STAT_PARITY) ? 0 : SERIO_PARITY;\n\n\t\tif (hweight8(scancode) & 1)\n\t\t\tflag ^= SERIO_PARITY;\n\n\t\tserio_interrupt(ps2if->io, scancode, flag);\n\t} while (1);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void pcips2_flush_input(struct pcips2_data *ps2if)\n{\n\tunsigned char status, scancode;\n\n\tdo {\n\t\tstatus = inb(ps2if->base + PS2_STATUS);\n\t\tif (!(status & PS2_STAT_RXFULL))\n\t\t\tbreak;\n\t\tscancode = inb(ps2if->base + PS2_DATA);\n\t\tif (status == 0xff && scancode == 0xff)\n\t\t\tbreak;\n\t} while (1);\n}\n\nstatic int pcips2_open(struct serio *io)\n{\n\tstruct pcips2_data *ps2if = io->port_data;\n\tint ret, val = 0;\n\n\toutb(PS2_CTRL_ENABLE, ps2if->base);\n\tpcips2_flush_input(ps2if);\n\n\tret = request_irq(ps2if->dev->irq, pcips2_interrupt, IRQF_SHARED,\n\t\t\t  \"pcips2\", ps2if);\n\tif (ret == 0)\n\t\tval = PS2_CTRL_ENABLE | PS2_CTRL_RXIRQ;\n\n\toutb(val, ps2if->base);\n\n\treturn ret;\n}\n\nstatic void pcips2_close(struct serio *io)\n{\n\tstruct pcips2_data *ps2if = io->port_data;\n\n\toutb(0, ps2if->base);\n\n\tfree_irq(ps2if->dev->irq, ps2if);\n}\n\nstatic int pcips2_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct pcips2_data *ps2if;\n\tstruct serio *serio;\n\tint ret;\n\n\tret = pci_enable_device(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = pci_request_regions(dev, \"pcips2\");\n\tif (ret)\n\t\tgoto disable;\n\n\tps2if = kzalloc(sizeof(struct pcips2_data), GFP_KERNEL);\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!ps2if || !serio) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= pcips2_write;\n\tserio->open\t\t= pcips2_open;\n\tserio->close\t\t= pcips2_close;\n\tstrscpy(serio->name, pci_name(dev), sizeof(serio->name));\n\tstrscpy(serio->phys, dev_name(&dev->dev), sizeof(serio->phys));\n\tserio->port_data\t= ps2if;\n\tserio->dev.parent\t= &dev->dev;\n\tps2if->io\t\t= serio;\n\tps2if->dev\t\t= dev;\n\tps2if->base\t\t= pci_resource_start(dev, 0);\n\n\tpci_set_drvdata(dev, ps2if);\n\n\tserio_register_port(ps2if->io);\n\treturn 0;\n\n release:\n\tkfree(ps2if);\n\tkfree(serio);\n\tpci_release_regions(dev);\n disable:\n\tpci_disable_device(dev);\n out:\n\treturn ret;\n}\n\nstatic void pcips2_remove(struct pci_dev *dev)\n{\n\tstruct pcips2_data *ps2if = pci_get_drvdata(dev);\n\n\tserio_unregister_port(ps2if->io);\n\tkfree(ps2if);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n}\n\nstatic const struct pci_device_id pcips2_ids[] = {\n\t{\n\t\t.vendor\t\t= 0x14f2,\t \n\t\t.device\t\t= 0x0123,\t \n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t\t.class\t\t= PCI_CLASS_INPUT_KEYBOARD << 8,\n\t\t.class_mask\t= 0xffff00,\n\t},\n\t{\n\t\t.vendor\t\t= 0x14f2,\t \n\t\t.device\t\t= 0x0124,\t \n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t\t.class\t\t= PCI_CLASS_INPUT_MOUSE << 8,\n\t\t.class_mask\t= 0xffff00,\n\t},\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, pcips2_ids);\n\nstatic struct pci_driver pcips2_driver = {\n\t.name\t\t\t= \"pcips2\",\n\t.id_table\t\t= pcips2_ids,\n\t.probe\t\t\t= pcips2_probe,\n\t.remove\t\t\t= pcips2_remove,\n};\n\nmodule_pci_driver(pcips2_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"PCI PS/2 keyboard/mouse driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}