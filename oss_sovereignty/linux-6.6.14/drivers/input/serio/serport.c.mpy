{
  "module_name": "serport.c",
  "hash_id": "d3e1cbc23a0f49c75ed9eb170ea2164c2d945f5c80f0a1ea556552526e1a44a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/serport.c",
  "human_readable_source": "\n \n\n\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/serio.h>\n#include <linux/tty.h>\n#include <linux/compat.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Input device TTY line discipline\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_MOUSE);\n\n#define SERPORT_BUSY\t1\n#define SERPORT_ACTIVE\t2\n#define SERPORT_DEAD\t3\n\nstruct serport {\n\tstruct tty_struct *tty;\n\twait_queue_head_t wait;\n\tstruct serio *serio;\n\tstruct serio_device_id id;\n\tspinlock_t lock;\n\tunsigned long flags;\n};\n\n \n\nstatic int serport_serio_write(struct serio *serio, unsigned char data)\n{\n\tstruct serport *serport = serio->port_data;\n\treturn -(serport->tty->ops->write(serport->tty, &data, 1) != 1);\n}\n\nstatic int serport_serio_open(struct serio *serio)\n{\n\tstruct serport *serport = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serport->lock, flags);\n\tset_bit(SERPORT_ACTIVE, &serport->flags);\n\tspin_unlock_irqrestore(&serport->lock, flags);\n\n\treturn 0;\n}\n\n\nstatic void serport_serio_close(struct serio *serio)\n{\n\tstruct serport *serport = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serport->lock, flags);\n\tclear_bit(SERPORT_ACTIVE, &serport->flags);\n\tspin_unlock_irqrestore(&serport->lock, flags);\n}\n\n \n\nstatic int serport_ldisc_open(struct tty_struct *tty)\n{\n\tstruct serport *serport;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tserport = kzalloc(sizeof(struct serport), GFP_KERNEL);\n\tif (!serport)\n\t\treturn -ENOMEM;\n\n\tserport->tty = tty;\n\tspin_lock_init(&serport->lock);\n\tinit_waitqueue_head(&serport->wait);\n\n\ttty->disc_data = serport;\n\ttty->receive_room = 256;\n\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\treturn 0;\n}\n\n \n\nstatic void serport_ldisc_close(struct tty_struct *tty)\n{\n\tstruct serport *serport = tty->disc_data;\n\n\tkfree(serport);\n}\n\n \n\nstatic void serport_ldisc_receive(struct tty_struct *tty, const u8 *cp,\n\t\t\t\t  const u8 *fp, size_t count)\n{\n\tstruct serport *serport = tty->disc_data;\n\tunsigned long flags;\n\tunsigned int ch_flags = 0;\n\tint i;\n\n\tspin_lock_irqsave(&serport->lock, flags);\n\n\tif (!test_bit(SERPORT_ACTIVE, &serport->flags))\n\t\tgoto out;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (fp) {\n\t\t\tswitch (fp[i]) {\n\t\t\tcase TTY_FRAME:\n\t\t\t\tch_flags = SERIO_FRAME;\n\t\t\t\tbreak;\n\n\t\t\tcase TTY_PARITY:\n\t\t\t\tch_flags = SERIO_PARITY;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tch_flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tserio_interrupt(serport->serio, cp[i], ch_flags);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&serport->lock, flags);\n}\n\n \n\nstatic ssize_t serport_ldisc_read(struct tty_struct * tty, struct file * file,\n\t\t\t\t  u8 *kbuf, size_t nr, void **cookie,\n\t\t\t\t  unsigned long offset)\n{\n\tstruct serport *serport = tty->disc_data;\n\tstruct serio *serio;\n\n\tif (test_and_set_bit(SERPORT_BUSY, &serport->flags))\n\t\treturn -EBUSY;\n\n\tserport->serio = serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tstrscpy(serio->name, \"Serial port\", sizeof(serio->name));\n\tsnprintf(serio->phys, sizeof(serio->phys), \"%s/serio0\", tty_name(tty));\n\tserio->id = serport->id;\n\tserio->id.type = SERIO_RS232;\n\tserio->write = serport_serio_write;\n\tserio->open = serport_serio_open;\n\tserio->close = serport_serio_close;\n\tserio->port_data = serport;\n\tserio->dev.parent = tty->dev;\n\n\tserio_register_port(serport->serio);\n\tprintk(KERN_INFO \"serio: Serial port %s\\n\", tty_name(tty));\n\n\twait_event_interruptible(serport->wait, test_bit(SERPORT_DEAD, &serport->flags));\n\tserio_unregister_port(serport->serio);\n\tserport->serio = NULL;\n\n\tclear_bit(SERPORT_DEAD, &serport->flags);\n\tclear_bit(SERPORT_BUSY, &serport->flags);\n\n\treturn 0;\n}\n\nstatic void serport_set_type(struct tty_struct *tty, unsigned long type)\n{\n\tstruct serport *serport = tty->disc_data;\n\n\tserport->id.proto = type & 0x000000ff;\n\tserport->id.id    = (type & 0x0000ff00) >> 8;\n\tserport->id.extra = (type & 0x00ff0000) >> 16;\n}\n\n \n\nstatic int serport_ldisc_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tif (cmd == SPIOCSTYPE) {\n\t\tunsigned long type;\n\n\t\tif (get_user(type, (unsigned long __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tserport_set_type(tty, type);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_COMPAT\n#define COMPAT_SPIOCSTYPE\t_IOW('q', 0x01, compat_ulong_t)\nstatic int serport_ldisc_compat_ioctl(struct tty_struct *tty,\n\t\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\tif (cmd == COMPAT_SPIOCSTYPE) {\n\t\tvoid __user *uarg = compat_ptr(arg);\n\t\tcompat_ulong_t compat_type;\n\n\t\tif (get_user(compat_type, (compat_ulong_t __user *)uarg))\n\t\t\treturn -EFAULT;\n\n\t\tserport_set_type(tty, compat_type);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n#endif\n\nstatic void serport_ldisc_hangup(struct tty_struct *tty)\n{\n\tstruct serport *serport = tty->disc_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serport->lock, flags);\n\tset_bit(SERPORT_DEAD, &serport->flags);\n\tspin_unlock_irqrestore(&serport->lock, flags);\n\n\twake_up_interruptible(&serport->wait);\n}\n\nstatic void serport_ldisc_write_wakeup(struct tty_struct * tty)\n{\n\tstruct serport *serport = tty->disc_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serport->lock, flags);\n\tif (test_bit(SERPORT_ACTIVE, &serport->flags))\n\t\tserio_drv_write_wakeup(serport->serio);\n\tspin_unlock_irqrestore(&serport->lock, flags);\n}\n\n \n\nstatic struct tty_ldisc_ops serport_ldisc = {\n\t.owner =\tTHIS_MODULE,\n\t.num =\t\tN_MOUSE,\n\t.name =\t\t\"input\",\n\t.open =\t\tserport_ldisc_open,\n\t.close =\tserport_ldisc_close,\n\t.read =\t\tserport_ldisc_read,\n\t.ioctl =\tserport_ldisc_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl =\tserport_ldisc_compat_ioctl,\n#endif\n\t.receive_buf =\tserport_ldisc_receive,\n\t.hangup =\tserport_ldisc_hangup,\n\t.write_wakeup =\tserport_ldisc_write_wakeup\n};\n\n \n\nstatic int __init serport_init(void)\n{\n\tint retval;\n\tretval = tty_register_ldisc(&serport_ldisc);\n\tif (retval)\n\t\tprintk(KERN_ERR \"serport.c: Error registering line discipline.\\n\");\n\n\treturn  retval;\n}\n\nstatic void __exit serport_exit(void)\n{\n\ttty_unregister_ldisc(&serport_ldisc);\n}\n\nmodule_init(serport_init);\nmodule_exit(serport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}