{
  "module_name": "olpc_apsp.c",
  "hash_id": "216801c137c624e1abf3e116298fe780f9bba556e4a9131acc34301d54c5dbe3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/olpc_apsp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/serio.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n \n\n \n#define SECURE_PROCESSOR_COMMAND\t0x40\n#define COMMAND_RETURN_STATUS\t\t0x80\n#define COMMAND_FIFO_STATUS\t\t0xc4\n#define PJ_RST_INTERRUPT\t\t0xc8\n#define PJ_INTERRUPT_MASK\t\t0xcc\n\n \n#define PORT_MASK\t0xff00\n#define DATA_MASK\t0x00ff\n#define PORT_SHIFT\t8\n#define KEYBOARD_PORT\t0\n#define TOUCHPAD_PORT\t1\n\n \n#define CMD_CNTR_MASK\t\t0x7  \n#define MAX_PENDING_CMDS\t4    \n\n \n#define SP_COMMAND_COMPLETE_RESET\t0x1\n\n \n#define INT_0\t(1 << 0)\n\n \n#define CMD_STS_MASK\t0x100\n\nstruct olpc_apsp {\n\tstruct device *dev;\n\tstruct serio *kbio;\n\tstruct serio *padio;\n\tvoid __iomem *base;\n\tint open_count;\n\tint irq;\n};\n\nstatic int olpc_apsp_write(struct serio *port, unsigned char val)\n{\n\tstruct olpc_apsp *priv = port->port_data;\n\tunsigned int i;\n\tu32 which = 0;\n\n\tif (port == priv->padio)\n\t\twhich = TOUCHPAD_PORT << PORT_SHIFT;\n\telse\n\t\twhich = KEYBOARD_PORT << PORT_SHIFT;\n\n\tdev_dbg(priv->dev, \"olpc_apsp_write which=%x val=%x\\n\", which, val);\n\tfor (i = 0; i < 50; i++) {\n\t\tu32 sts = readl(priv->base + COMMAND_FIFO_STATUS);\n\t\tif ((sts & CMD_CNTR_MASK) < MAX_PENDING_CMDS) {\n\t\t\twritel(which | val,\n\t\t\t       priv->base + SECURE_PROCESSOR_COMMAND);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tmdelay(1);\n\t}\n\n\tdev_dbg(priv->dev, \"olpc_apsp_write timeout, status=%x\\n\",\n\t\treadl(priv->base + COMMAND_FIFO_STATUS));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic irqreturn_t olpc_apsp_rx(int irq, void *dev_id)\n{\n\tstruct olpc_apsp *priv = dev_id;\n\tunsigned int w, tmp;\n\tstruct serio *serio;\n\n\t \n\ttmp = readl(priv->base + PJ_RST_INTERRUPT);\n\tif (!(tmp & SP_COMMAND_COMPLETE_RESET)) {\n\t\tdev_warn(priv->dev, \"spurious interrupt?\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tw = readl(priv->base + COMMAND_RETURN_STATUS);\n\tdev_dbg(priv->dev, \"olpc_apsp_rx %x\\n\", w);\n\n\tif (w >> PORT_SHIFT == KEYBOARD_PORT)\n\t\tserio = priv->kbio;\n\telse\n\t\tserio = priv->padio;\n\n\tserio_interrupt(serio, w & DATA_MASK, 0);\n\n\t \n\twritel(tmp | SP_COMMAND_COMPLETE_RESET, priv->base + PJ_RST_INTERRUPT);\n\twritel(PORT_MASK, priv->base + SECURE_PROCESSOR_COMMAND);\n\n\tpm_wakeup_event(priv->dev, 1000);\n\treturn IRQ_HANDLED;\n}\n\nstatic int olpc_apsp_open(struct serio *port)\n{\n\tstruct olpc_apsp *priv = port->port_data;\n\tunsigned int tmp;\n\tunsigned long l;\n\n\tif (priv->open_count++ == 0) {\n\t\tl = readl(priv->base + COMMAND_FIFO_STATUS);\n\t\tif (!(l & CMD_STS_MASK)) {\n\t\t\tdev_err(priv->dev, \"SP cannot accept commands.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\ttmp = readl(priv->base + PJ_INTERRUPT_MASK);\n\t\twritel(tmp & ~INT_0, priv->base + PJ_INTERRUPT_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic void olpc_apsp_close(struct serio *port)\n{\n\tstruct olpc_apsp *priv = port->port_data;\n\tunsigned int tmp;\n\n\tif (--priv->open_count == 0) {\n\t\t \n\t\ttmp = readl(priv->base + PJ_INTERRUPT_MASK);\n\t\twritel(tmp | INT_0, priv->base + PJ_INTERRUPT_MASK);\n\t}\n}\n\nstatic int olpc_apsp_probe(struct platform_device *pdev)\n{\n\tstruct serio *kb_serio, *pad_serio;\n\tstruct olpc_apsp *priv;\n\tint error;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct olpc_apsp), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\n\tpriv->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(&pdev->dev, \"Failed to map WTM registers\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\t \n\tkb_serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!kb_serio)\n\t\treturn -ENOMEM;\n\tkb_serio->id.type\t= SERIO_8042_XL;\n\tkb_serio->write\t\t= olpc_apsp_write;\n\tkb_serio->open\t\t= olpc_apsp_open;\n\tkb_serio->close\t\t= olpc_apsp_close;\n\tkb_serio->port_data\t= priv;\n\tkb_serio->dev.parent\t= &pdev->dev;\n\tstrscpy(kb_serio->name, \"sp keyboard\", sizeof(kb_serio->name));\n\tstrscpy(kb_serio->phys, \"sp/serio0\", sizeof(kb_serio->phys));\n\tpriv->kbio\t\t= kb_serio;\n\tserio_register_port(kb_serio);\n\n\t \n\tpad_serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!pad_serio) {\n\t\terror = -ENOMEM;\n\t\tgoto err_pad;\n\t}\n\tpad_serio->id.type\t= SERIO_8042;\n\tpad_serio->write\t= olpc_apsp_write;\n\tpad_serio->open\t\t= olpc_apsp_open;\n\tpad_serio->close\t= olpc_apsp_close;\n\tpad_serio->port_data\t= priv;\n\tpad_serio->dev.parent\t= &pdev->dev;\n\tstrscpy(pad_serio->name, \"sp touchpad\", sizeof(pad_serio->name));\n\tstrscpy(pad_serio->phys, \"sp/serio1\", sizeof(pad_serio->phys));\n\tpriv->padio\t\t= pad_serio;\n\tserio_register_port(pad_serio);\n\n\terror = request_irq(priv->irq, olpc_apsp_rx, 0, \"olpc-apsp\", priv);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tdevice_init_wakeup(priv->dev, 1);\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_dbg(&pdev->dev, \"probed successfully.\\n\");\n\treturn 0;\n\nerr_irq:\n\tserio_unregister_port(pad_serio);\nerr_pad:\n\tserio_unregister_port(kb_serio);\n\treturn error;\n}\n\nstatic int olpc_apsp_remove(struct platform_device *pdev)\n{\n\tstruct olpc_apsp *priv = platform_get_drvdata(pdev);\n\n\tfree_irq(priv->irq, priv);\n\n\tserio_unregister_port(priv->kbio);\n\tserio_unregister_port(priv->padio);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id olpc_apsp_dt_ids[] = {\n\t{ .compatible = \"olpc,ap-sp\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, olpc_apsp_dt_ids);\n\nstatic struct platform_driver olpc_apsp_driver = {\n\t.probe\t\t= olpc_apsp_probe,\n\t.remove\t\t= olpc_apsp_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"olpc-apsp\",\n\t\t.of_match_table = olpc_apsp_dt_ids,\n\t},\n};\n\nMODULE_DESCRIPTION(\"OLPC AP-SP serio driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_platform_driver(olpc_apsp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}