{
  "module_name": "arc_ps2.c",
  "hash_id": "3c01fadb69b49637841eea55a4233f3b0d9f8926cb40be7c5002572f3b747977",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/arc_ps2.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#define ARC_PS2_PORTS                   2\n\n#define ARC_ARC_PS2_ID                  0x0001f609\n\n#define STAT_TIMEOUT                    128\n\n#define PS2_STAT_RX_FRM_ERR             (1)\n#define PS2_STAT_RX_BUF_OVER            (1 << 1)\n#define PS2_STAT_RX_INT_EN              (1 << 2)\n#define PS2_STAT_RX_VAL                 (1 << 3)\n#define PS2_STAT_TX_ISNOT_FUL           (1 << 4)\n#define PS2_STAT_TX_INT_EN              (1 << 5)\n\nstruct arc_ps2_port {\n\tvoid __iomem *data_addr;\n\tvoid __iomem *status_addr;\n\tstruct serio *io;\n};\n\nstruct arc_ps2_data {\n\tstruct arc_ps2_port port[ARC_PS2_PORTS];\n\tvoid __iomem *addr;\n\tunsigned int frame_error;\n\tunsigned int buf_overflow;\n\tunsigned int total_int;\n};\n\nstatic void arc_ps2_check_rx(struct arc_ps2_data *arc_ps2,\n\t\t\t     struct arc_ps2_port *port)\n{\n\tunsigned int timeout = 1000;\n\tunsigned int flag, status;\n\tunsigned char data;\n\n\tdo {\n\t\tstatus = ioread32(port->status_addr);\n\t\tif (!(status & PS2_STAT_RX_VAL))\n\t\t\treturn;\n\n\t\tdata = ioread32(port->data_addr) & 0xff;\n\n\t\tflag = 0;\n\t\tarc_ps2->total_int++;\n\t\tif (status & PS2_STAT_RX_FRM_ERR) {\n\t\t\tarc_ps2->frame_error++;\n\t\t\tflag |= SERIO_PARITY;\n\t\t} else if (status & PS2_STAT_RX_BUF_OVER) {\n\t\t\tarc_ps2->buf_overflow++;\n\t\t\tflag |= SERIO_FRAME;\n\t\t}\n\n\t\tserio_interrupt(port->io, data, flag);\n\t} while (--timeout);\n\n\tdev_err(&port->io->dev, \"PS/2 hardware stuck\\n\");\n}\n\nstatic irqreturn_t arc_ps2_interrupt(int irq, void *dev)\n{\n\tstruct arc_ps2_data *arc_ps2 = dev;\n\tint i;\n\n\tfor (i = 0; i < ARC_PS2_PORTS; i++)\n\t\tarc_ps2_check_rx(arc_ps2, &arc_ps2->port[i]);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int arc_ps2_write(struct serio *io, unsigned char val)\n{\n\tunsigned status;\n\tstruct arc_ps2_port *port = io->port_data;\n\tint timeout = STAT_TIMEOUT;\n\n\tdo {\n\t\tstatus = ioread32(port->status_addr);\n\t\tcpu_relax();\n\n\t\tif (status & PS2_STAT_TX_ISNOT_FUL) {\n\t\t\tiowrite32(val & 0xff, port->data_addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} while (--timeout);\n\n\tdev_err(&io->dev, \"write timeout\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int arc_ps2_open(struct serio *io)\n{\n\tstruct arc_ps2_port *port = io->port_data;\n\n\tiowrite32(PS2_STAT_RX_INT_EN, port->status_addr);\n\n\treturn 0;\n}\n\nstatic void arc_ps2_close(struct serio *io)\n{\n\tstruct arc_ps2_port *port = io->port_data;\n\n\tiowrite32(ioread32(port->status_addr) & ~PS2_STAT_RX_INT_EN,\n\t\t  port->status_addr);\n}\n\nstatic void __iomem *arc_ps2_calc_addr(struct arc_ps2_data *arc_ps2,\n\t\t\t\t\t\t  int index, bool status)\n{\n\tvoid __iomem *addr;\n\n\taddr = arc_ps2->addr + 4 + 4 * index;\n\tif (status)\n\t\taddr += ARC_PS2_PORTS * 4;\n\n\treturn addr;\n}\n\nstatic void arc_ps2_inhibit_ports(struct arc_ps2_data *arc_ps2)\n{\n\tvoid __iomem *addr;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < ARC_PS2_PORTS; i++) {\n\t\taddr = arc_ps2_calc_addr(arc_ps2, i, true);\n\t\tval = ioread32(addr);\n\t\tval &= ~(PS2_STAT_RX_INT_EN | PS2_STAT_TX_INT_EN);\n\t\tiowrite32(val, addr);\n\t}\n}\n\nstatic int arc_ps2_create_port(struct platform_device *pdev,\n\t\t\t\t\t struct arc_ps2_data *arc_ps2,\n\t\t\t\t\t int index)\n{\n\tstruct arc_ps2_port *port = &arc_ps2->port[index];\n\tstruct serio *io;\n\n\tio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!io)\n\t\treturn -ENOMEM;\n\n\tio->id.type = SERIO_8042;\n\tio->write = arc_ps2_write;\n\tio->open = arc_ps2_open;\n\tio->close = arc_ps2_close;\n\tsnprintf(io->name, sizeof(io->name), \"ARC PS/2 port%d\", index);\n\tsnprintf(io->phys, sizeof(io->phys), \"arc/serio%d\", index);\n\tio->port_data = port;\n\n\tport->io = io;\n\n\tport->data_addr = arc_ps2_calc_addr(arc_ps2, index, false);\n\tport->status_addr = arc_ps2_calc_addr(arc_ps2, index, true);\n\n\tdev_dbg(&pdev->dev, \"port%d is allocated (data = 0x%p, status = 0x%p)\\n\",\n\t\tindex, port->data_addr, port->status_addr);\n\n\tserio_register_port(port->io);\n\treturn 0;\n}\n\nstatic int arc_ps2_probe(struct platform_device *pdev)\n{\n\tstruct arc_ps2_data *arc_ps2;\n\tint irq;\n\tint error, id, i;\n\n\tirq = platform_get_irq_byname(pdev, \"arc_ps2_irq\");\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tarc_ps2 = devm_kzalloc(&pdev->dev, sizeof(struct arc_ps2_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!arc_ps2) {\n\t\tdev_err(&pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tarc_ps2->addr = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(arc_ps2->addr))\n\t\treturn PTR_ERR(arc_ps2->addr);\n\n\tdev_info(&pdev->dev, \"irq = %d, address = 0x%p, ports = %i\\n\",\n\t\t irq, arc_ps2->addr, ARC_PS2_PORTS);\n\n\tid = ioread32(arc_ps2->addr);\n\tif (id != ARC_ARC_PS2_ID) {\n\t\tdev_err(&pdev->dev, \"device id does not match\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tarc_ps2_inhibit_ports(arc_ps2);\n\n\terror = devm_request_irq(&pdev->dev, irq, arc_ps2_interrupt,\n\t\t\t\t 0, \"arc_ps2\", arc_ps2);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"Could not allocate IRQ\\n\");\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i < ARC_PS2_PORTS; i++) {\n\t\terror = arc_ps2_create_port(pdev, arc_ps2, i);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tserio_unregister_port(arc_ps2->port[i].io);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, arc_ps2);\n\n\treturn 0;\n}\n\nstatic int arc_ps2_remove(struct platform_device *pdev)\n{\n\tstruct arc_ps2_data *arc_ps2 = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < ARC_PS2_PORTS; i++)\n\t\tserio_unregister_port(arc_ps2->port[i].io);\n\n\tdev_dbg(&pdev->dev, \"interrupt count = %i\\n\", arc_ps2->total_int);\n\tdev_dbg(&pdev->dev, \"frame error count = %i\\n\", arc_ps2->frame_error);\n\tdev_dbg(&pdev->dev, \"buffer overflow count = %i\\n\",\n\t\tarc_ps2->buf_overflow);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id arc_ps2_match[] = {\n\t{ .compatible = \"snps,arc_ps2\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, arc_ps2_match);\n#endif\n\nstatic struct platform_driver arc_ps2_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"arc_ps2\",\n\t\t.of_match_table\t= of_match_ptr(arc_ps2_match),\n\t},\n\t.probe\t= arc_ps2_probe,\n\t.remove\t= arc_ps2_remove,\n};\n\nmodule_platform_driver(arc_ps2_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pavel Sokolov <psokolov@synopsys.com>\");\nMODULE_DESCRIPTION(\"ARC PS/2 Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}