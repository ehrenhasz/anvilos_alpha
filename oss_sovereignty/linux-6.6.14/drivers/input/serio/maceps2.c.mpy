{
  "module_name": "maceps2.c",
  "hash_id": "02f06055d8d518bc1a9c37b21b137abcfaf7bf78ad7df2ddc1c684af629d8526",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/maceps2.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/serio.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/ip32/mace.h>\n#include <asm/ip32/ip32_ints.h>\n\nMODULE_AUTHOR(\"Vivien Chappelier <vivien.chappelier@linux-mips.org\");\nMODULE_DESCRIPTION(\"SGI O2 MACE PS2 controller driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define MACE_PS2_TIMEOUT 10000  \n\n#define PS2_STATUS_CLOCK_SIGNAL  BIT(0)  \n#define PS2_STATUS_CLOCK_INHIBIT BIT(1)  \n#define PS2_STATUS_TX_INPROGRESS BIT(2)  \n#define PS2_STATUS_TX_EMPTY      BIT(3)  \n#define PS2_STATUS_RX_FULL       BIT(4)  \n#define PS2_STATUS_RX_INPROGRESS BIT(5)  \n#define PS2_STATUS_ERROR_PARITY  BIT(6)  \n#define PS2_STATUS_ERROR_FRAMING BIT(7)  \n\n#define PS2_CONTROL_TX_CLOCK_DISABLE BIT(0)  \n#define PS2_CONTROL_TX_ENABLE        BIT(1)  \n#define PS2_CONTROL_TX_INT_ENABLE    BIT(2)  \n#define PS2_CONTROL_RX_INT_ENABLE    BIT(3)  \n#define PS2_CONTROL_RX_CLOCK_ENABLE  BIT(4)  \n#define PS2_CONTROL_RESET            BIT(5)  \n\nstruct maceps2_data {\n\tstruct mace_ps2port *port;\n\tint irq;\n};\n\nstatic struct maceps2_data port_data[2];\nstatic struct serio *maceps2_port[2];\nstatic struct platform_device *maceps2_device;\n\nstatic int maceps2_write(struct serio *dev, unsigned char val)\n{\n\tstruct mace_ps2port *port = ((struct maceps2_data *)dev->port_data)->port;\n\tunsigned int timeout = MACE_PS2_TIMEOUT;\n\n\tdo {\n\t\tif (port->status & PS2_STATUS_TX_EMPTY) {\n\t\t\tport->tx = val;\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(50);\n\t} while (timeout--);\n\n\treturn -1;\n}\n\nstatic irqreturn_t maceps2_interrupt(int irq, void *dev_id)\n{\n\tstruct serio *dev = dev_id;\n\tstruct mace_ps2port *port = ((struct maceps2_data *)dev->port_data)->port;\n\tunsigned long byte;\n\n\tif (port->status & PS2_STATUS_RX_FULL) {\n\t\tbyte = port->rx;\n\t\tserio_interrupt(dev, byte & 0xff, 0);\n        }\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int maceps2_open(struct serio *dev)\n{\n\tstruct maceps2_data *data = (struct maceps2_data *)dev->port_data;\n\n\tif (request_irq(data->irq, maceps2_interrupt, 0, \"PS2 port\", dev)) {\n\t\tprintk(KERN_ERR \"Could not allocate PS/2 IRQ\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdata->port->control = PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET;\n\tudelay(100);\n\n         \n\tdata->port->control = PS2_CONTROL_RX_CLOCK_ENABLE |\n\t\t\t      PS2_CONTROL_TX_ENABLE |\n\t\t\t      PS2_CONTROL_RX_INT_ENABLE;\n\n\treturn 0;\n}\n\nstatic void maceps2_close(struct serio *dev)\n{\n\tstruct maceps2_data *data = (struct maceps2_data *)dev->port_data;\n\n\tdata->port->control = PS2_CONTROL_TX_CLOCK_DISABLE | PS2_CONTROL_RESET;\n\tudelay(100);\n\tfree_irq(data->irq, dev);\n}\n\n\nstatic struct serio *maceps2_allocate_port(int idx)\n{\n\tstruct serio *serio;\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (serio) {\n\t\tserio->id.type\t\t= SERIO_8042;\n\t\tserio->write\t\t= maceps2_write;\n\t\tserio->open\t\t= maceps2_open;\n\t\tserio->close\t\t= maceps2_close;\n\t\tsnprintf(serio->name, sizeof(serio->name), \"MACE PS/2 port%d\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), \"mace/serio%d\", idx);\n\t\tserio->port_data\t= &port_data[idx];\n\t\tserio->dev.parent\t= &maceps2_device->dev;\n\t}\n\n\treturn serio;\n}\n\nstatic int maceps2_probe(struct platform_device *dev)\n{\n\tmaceps2_port[0] = maceps2_allocate_port(0);\n\tmaceps2_port[1] = maceps2_allocate_port(1);\n\tif (!maceps2_port[0] || !maceps2_port[1]) {\n\t\tkfree(maceps2_port[0]);\n\t\tkfree(maceps2_port[1]);\n\t\treturn -ENOMEM;\n\t}\n\n\tserio_register_port(maceps2_port[0]);\n\tserio_register_port(maceps2_port[1]);\n\n\treturn 0;\n}\n\nstatic int maceps2_remove(struct platform_device *dev)\n{\n\tserio_unregister_port(maceps2_port[0]);\n\tserio_unregister_port(maceps2_port[1]);\n\n\treturn 0;\n}\n\nstatic struct platform_driver maceps2_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"maceps2\",\n\t},\n\t.probe\t\t= maceps2_probe,\n\t.remove\t\t= maceps2_remove,\n};\n\nstatic int __init maceps2_init(void)\n{\n\tint error;\n\n\terror = platform_driver_register(&maceps2_driver);\n\tif (error)\n\t\treturn error;\n\n\tmaceps2_device = platform_device_alloc(\"maceps2\", -1);\n\tif (!maceps2_device) {\n\t\terror = -ENOMEM;\n\t\tgoto err_unregister_driver;\n\t}\n\n\tport_data[0].port = &mace->perif.ps2.keyb;\n\tport_data[0].irq  = MACEISA_KEYB_IRQ;\n\tport_data[1].port = &mace->perif.ps2.mouse;\n\tport_data[1].irq  = MACEISA_MOUSE_IRQ;\n\n\terror = platform_device_add(maceps2_device);\n\tif (error)\n\t\tgoto err_free_device;\n\n\treturn 0;\n\n err_free_device:\n\tplatform_device_put(maceps2_device);\n err_unregister_driver:\n\tplatform_driver_unregister(&maceps2_driver);\n\treturn error;\n}\n\nstatic void __exit maceps2_exit(void)\n{\n\tplatform_device_unregister(maceps2_device);\n\tplatform_driver_unregister(&maceps2_driver);\n}\n\nmodule_init(maceps2_init);\nmodule_exit(maceps2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}