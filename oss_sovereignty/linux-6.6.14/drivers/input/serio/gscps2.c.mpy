{
  "module_name": "gscps2.c",
  "hash_id": "c7fd864a658912595b78df538b5569823618011e193c6f76f7dab140100d458c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/gscps2.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/serio.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <asm/parisc-device.h>\n\nMODULE_AUTHOR(\"Laurent Canet <canetl@esiee.fr>, Thibaut Varene <varenet@parisc-linux.org>, Helge Deller <deller@gmx.de>\");\nMODULE_DESCRIPTION(\"HP GSC PS2 port driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define PFX \"gscps2.c: \"\n\n \n\n \n#define ENABLE\t\t\t1\n#define DISABLE\t\t\t0\n\n#define GSC_DINO_OFFSET\t\t0x0800\t \n\n \n#define GSC_ID\t\t\t0x00\t \n#define GSC_RESET\t\t0x00\t \n#define GSC_RCVDATA\t\t0x04\t \n#define GSC_XMTDATA\t\t0x04\t \n#define GSC_CONTROL\t\t0x08\t \n#define GSC_STATUS\t\t0x0C\t \n\n \n#define GSC_CTRL_ENBL\t\t0x01\t \n#define GSC_CTRL_LPBXR\t\t0x02\t \n#define GSC_CTRL_DIAG\t\t0x20\t \n#define GSC_CTRL_DATDIR\t\t0x40\t \n#define GSC_CTRL_CLKDIR\t\t0x80\t \n\n \n#define GSC_STAT_RBNE\t\t0x01\t \n#define GSC_STAT_TBNE\t\t0x02\t \n#define GSC_STAT_TERR\t\t0x04\t \n#define GSC_STAT_PERR\t\t0x08\t \n#define GSC_STAT_CMPINTR\t0x10\t \n#define GSC_STAT_DATSHD\t\t0x40\t \n#define GSC_STAT_CLKSHD\t\t0x80\t \n\n \n#define GSC_ID_KEYBOARD\t\t0\t \n#define GSC_ID_MOUSE\t\t1\n\n\nstatic irqreturn_t gscps2_interrupt(int irq, void *dev);\n\n#define BUFFER_SIZE 0x0f\n\n \nstruct gscps2port {\n\tstruct list_head node;\n\tstruct parisc_device *padev;\n\tstruct serio *port;\n\tspinlock_t lock;\n\tchar __iomem *addr;\n\tu8 act, append;  \n\tstruct {\n\t\tu8 data;\n\t\tu8 str;\n\t} buffer[BUFFER_SIZE+1];\n\tint id;\n};\n\n \n\n#define gscps2_readb_input(x)\t\treadb((x)+GSC_RCVDATA)\n#define gscps2_readb_control(x)\t\treadb((x)+GSC_CONTROL)\n#define gscps2_readb_status(x)\t\treadb((x)+GSC_STATUS)\n#define gscps2_writeb_control(x, y)\twriteb((x), (y)+GSC_CONTROL)\n\n\n \n\nstatic int wait_TBE(char __iomem *addr)\n{\n\tint timeout = 25000;  \n\twhile (gscps2_readb_status(addr) & GSC_STAT_TBNE) {\n\t\tif (!--timeout)\n\t\t\treturn 0;\t \n\t\tudelay(10);\n\t}\n\treturn 1;\n}\n\n\n \n\nstatic void gscps2_flush(struct gscps2port *ps2port)\n{\n\twhile (gscps2_readb_status(ps2port->addr) & GSC_STAT_RBNE)\n\t\tgscps2_readb_input(ps2port->addr);\n\tps2port->act = ps2port->append = 0;\n}\n\n \n\nstatic inline int gscps2_writeb_output(struct gscps2port *ps2port, u8 data)\n{\n\tunsigned long flags;\n\tchar __iomem *addr = ps2port->addr;\n\n\tif (!wait_TBE(addr)) {\n\t\tprintk(KERN_DEBUG PFX \"timeout - could not write byte %#x\\n\", data);\n\t\treturn 0;\n\t}\n\n\twhile (gscps2_readb_status(addr) & GSC_STAT_RBNE)\n\t\t ;\n\n\tspin_lock_irqsave(&ps2port->lock, flags);\n\twriteb(data, addr+GSC_XMTDATA);\n\tspin_unlock_irqrestore(&ps2port->lock, flags);\n\n\t \n\tmdelay(6);\n\n\t \n\t \n\tgscps2_interrupt(0, NULL);\n\n\treturn 1;\n}\n\n\n \n\nstatic void gscps2_enable(struct gscps2port *ps2port, int enable)\n{\n\tunsigned long flags;\n\tu8 data;\n\n\t \n\tspin_lock_irqsave(&ps2port->lock, flags);\n\tgscps2_flush(ps2port);\n\tdata = gscps2_readb_control(ps2port->addr);\n\tif (enable)\n\t\tdata |= GSC_CTRL_ENBL;\n\telse\n\t\tdata &= ~GSC_CTRL_ENBL;\n\tgscps2_writeb_control(data, ps2port->addr);\n\tspin_unlock_irqrestore(&ps2port->lock, flags);\n\twait_TBE(ps2port->addr);\n\tgscps2_flush(ps2port);\n}\n\n \n\nstatic void gscps2_reset(struct gscps2port *ps2port)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ps2port->lock, flags);\n\tgscps2_flush(ps2port);\n\twriteb(0xff, ps2port->addr + GSC_RESET);\n\tgscps2_flush(ps2port);\n\tspin_unlock_irqrestore(&ps2port->lock, flags);\n}\n\nstatic LIST_HEAD(ps2port_list);\n\n \n\nstatic irqreturn_t gscps2_interrupt(int irq, void *dev)\n{\n\tstruct gscps2port *ps2port;\n\n\tlist_for_each_entry(ps2port, &ps2port_list, node) {\n\n\t  unsigned long flags;\n\t  spin_lock_irqsave(&ps2port->lock, flags);\n\n\t  while ( (ps2port->buffer[ps2port->append].str =\n\t\t   gscps2_readb_status(ps2port->addr)) & GSC_STAT_RBNE ) {\n\t\tps2port->buffer[ps2port->append].data =\n\t\t\t\tgscps2_readb_input(ps2port->addr);\n\t\tps2port->append = ((ps2port->append+1) & BUFFER_SIZE);\n\t  }\n\n\t  spin_unlock_irqrestore(&ps2port->lock, flags);\n\n\t}  \n\n\t \n\n\tlist_for_each_entry(ps2port, &ps2port_list, node) {\n\n\t  while (ps2port->act != ps2port->append) {\n\n\t    unsigned int rxflags;\n\t    u8 data, status;\n\n\t     \n\t    if (gscps2_readb_status(ps2port->addr) & GSC_STAT_CMPINTR)\n\t\treturn IRQ_HANDLED;\n\n\t    status = ps2port->buffer[ps2port->act].str;\n\t    data   = ps2port->buffer[ps2port->act].data;\n\n\t    ps2port->act = ((ps2port->act+1) & BUFFER_SIZE);\n\t    rxflags =\t((status & GSC_STAT_TERR) ? SERIO_TIMEOUT : 0 ) |\n\t\t\t((status & GSC_STAT_PERR) ? SERIO_PARITY  : 0 );\n\n\t    serio_interrupt(ps2port->port, data, rxflags);\n\n\t  }  \n\n\t}  \n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic int gscps2_write(struct serio *port, unsigned char data)\n{\n\tstruct gscps2port *ps2port = port->port_data;\n\n\tif (!gscps2_writeb_output(ps2port, data)) {\n\t\tprintk(KERN_DEBUG PFX \"sending byte %#x failed.\\n\", data);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int gscps2_open(struct serio *port)\n{\n\tstruct gscps2port *ps2port = port->port_data;\n\n\tgscps2_reset(ps2port);\n\n\t \n\tgscps2_enable(ps2port, ENABLE);\n\n\tgscps2_interrupt(0, NULL);\n\n\treturn 0;\n}\n\n \n\nstatic void gscps2_close(struct serio *port)\n{\n\tstruct gscps2port *ps2port = port->port_data;\n\tgscps2_enable(ps2port, DISABLE);\n}\n\n \n\nstatic int __init gscps2_probe(struct parisc_device *dev)\n{\n\tstruct gscps2port *ps2port;\n\tstruct serio *serio;\n\tunsigned long hpa = dev->hpa.start;\n\tint ret;\n\n\tif (!dev->irq)\n\t\treturn -ENODEV;\n\n\t \n\tif (dev->id.sversion == 0x96)\n\t\thpa += GSC_DINO_OFFSET;\n\n\tps2port = kzalloc(sizeof(struct gscps2port), GFP_KERNEL);\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!ps2port || !serio) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_nomem;\n\t}\n\n\tdev_set_drvdata(&dev->dev, ps2port);\n\n\tps2port->port = serio;\n\tps2port->padev = dev;\n\tps2port->addr = ioremap(hpa, GSC_STATUS + 4);\n\tif (!ps2port->addr) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_nomem;\n\t}\n\tspin_lock_init(&ps2port->lock);\n\n\tgscps2_reset(ps2port);\n\tps2port->id = readb(ps2port->addr + GSC_ID) & 0x0f;\n\n\tsnprintf(serio->name, sizeof(serio->name), \"gsc-ps2-%s\",\n\t\t (ps2port->id == GSC_ID_KEYBOARD) ? \"keyboard\" : \"mouse\");\n\tstrscpy(serio->phys, dev_name(&dev->dev), sizeof(serio->phys));\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= gscps2_write;\n\tserio->open\t\t= gscps2_open;\n\tserio->close\t\t= gscps2_close;\n\tserio->port_data\t= ps2port;\n\tserio->dev.parent\t= &dev->dev;\n\n\tret = -EBUSY;\n\tif (request_irq(dev->irq, gscps2_interrupt, IRQF_SHARED, ps2port->port->name, ps2port))\n\t\tgoto fail_miserably;\n\n\tif (ps2port->id != GSC_ID_KEYBOARD && ps2port->id != GSC_ID_MOUSE) {\n\t\tprintk(KERN_WARNING PFX \"Unsupported PS/2 port at 0x%08lx (id=%d) ignored\\n\",\n\t\t\t\thpa, ps2port->id);\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n#if 0\n\tif (!request_mem_region(hpa, GSC_STATUS + 4, ps2port->port.name))\n\t\tgoto fail;\n#endif\n\n\tpr_info(\"serio: %s port at 0x%08lx irq %d @ %s\\n\",\n\t\tps2port->port->name,\n\t\thpa,\n\t\tps2port->padev->irq,\n\t\tps2port->port->phys);\n\n\tserio_register_port(ps2port->port);\n\n\tlist_add_tail(&ps2port->node, &ps2port_list);\n\n\treturn 0;\n\nfail:\n\tfree_irq(dev->irq, ps2port);\n\nfail_miserably:\n\tiounmap(ps2port->addr);\n\trelease_mem_region(dev->hpa.start, GSC_STATUS + 4);\n\nfail_nomem:\n\tkfree(ps2port);\n\tkfree(serio);\n\treturn ret;\n}\n\n \n\nstatic void __exit gscps2_remove(struct parisc_device *dev)\n{\n\tstruct gscps2port *ps2port = dev_get_drvdata(&dev->dev);\n\n\tserio_unregister_port(ps2port->port);\n\tfree_irq(dev->irq, ps2port);\n\tgscps2_flush(ps2port);\n\tlist_del(&ps2port->node);\n\tiounmap(ps2port->addr);\n#if 0\n\trelease_mem_region(dev->hpa, GSC_STATUS + 4);\n#endif\n\tdev_set_drvdata(&dev->dev, NULL);\n\tkfree(ps2port);\n}\n\n\nstatic const struct parisc_device_id gscps2_device_tbl[] __initconst = {\n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00084 },  \n#ifdef DINO_TESTED\n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00096 },  \n#endif\n\t{ 0, }\t \n};\nMODULE_DEVICE_TABLE(parisc, gscps2_device_tbl);\n\nstatic struct parisc_driver parisc_ps2_driver __refdata = {\n\t.name\t\t= \"gsc_ps2\",\n\t.id_table\t= gscps2_device_tbl,\n\t.probe\t\t= gscps2_probe,\n\t.remove\t\t= __exit_p(gscps2_remove),\n};\n\nstatic int __init gscps2_init(void)\n{\n\tregister_parisc_driver(&parisc_ps2_driver);\n\treturn 0;\n}\n\nstatic void __exit gscps2_exit(void)\n{\n\tunregister_parisc_driver(&parisc_ps2_driver);\n}\n\n\nmodule_init(gscps2_init);\nmodule_exit(gscps2_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}