{
  "module_name": "i8042.c",
  "hash_id": "c91790d5ba3e21488424a88df9398a9a3f2e7ca5e9b3490e13626025a21e4d12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/i8042.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/serio.h>\n#include <linux/err.h>\n#include <linux/rcupdate.h>\n#include <linux/platform_device.h>\n#include <linux/i8042.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/property.h>\n\n#include <asm/io.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"i8042 keyboard and mouse controller driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool i8042_nokbd;\nmodule_param_named(nokbd, i8042_nokbd, bool, 0);\nMODULE_PARM_DESC(nokbd, \"Do not probe or use KBD port.\");\n\nstatic bool i8042_noaux;\nmodule_param_named(noaux, i8042_noaux, bool, 0);\nMODULE_PARM_DESC(noaux, \"Do not probe or use AUX (mouse) port.\");\n\nstatic bool i8042_nomux;\nmodule_param_named(nomux, i8042_nomux, bool, 0);\nMODULE_PARM_DESC(nomux, \"Do not check whether an active multiplexing controller is present.\");\n\nstatic bool i8042_unlock;\nmodule_param_named(unlock, i8042_unlock, bool, 0);\nMODULE_PARM_DESC(unlock, \"Ignore keyboard lock.\");\n\nstatic bool i8042_probe_defer;\nmodule_param_named(probe_defer, i8042_probe_defer, bool, 0);\nMODULE_PARM_DESC(probe_defer, \"Allow deferred probing.\");\n\nenum i8042_controller_reset_mode {\n\tI8042_RESET_NEVER,\n\tI8042_RESET_ALWAYS,\n\tI8042_RESET_ON_S2RAM,\n#define I8042_RESET_DEFAULT\tI8042_RESET_ON_S2RAM\n};\nstatic enum i8042_controller_reset_mode i8042_reset = I8042_RESET_DEFAULT;\nstatic int i8042_set_reset(const char *val, const struct kernel_param *kp)\n{\n\tenum i8042_controller_reset_mode *arg = kp->arg;\n\tint error;\n\tbool reset;\n\n\tif (val) {\n\t\terror = kstrtobool(val, &reset);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\treset = true;\n\t}\n\n\t*arg = reset ? I8042_RESET_ALWAYS : I8042_RESET_NEVER;\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_reset_param = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = i8042_set_reset,\n};\n#define param_check_reset_param(name, p)\t\\\n\t__param_check(name, p, enum i8042_controller_reset_mode)\nmodule_param_named(reset, i8042_reset, reset_param, 0);\nMODULE_PARM_DESC(reset, \"Reset controller on resume, cleanup or both\");\n\nstatic bool i8042_direct;\nmodule_param_named(direct, i8042_direct, bool, 0);\nMODULE_PARM_DESC(direct, \"Put keyboard port into non-translated mode.\");\n\nstatic bool i8042_dumbkbd;\nmodule_param_named(dumbkbd, i8042_dumbkbd, bool, 0);\nMODULE_PARM_DESC(dumbkbd, \"Pretend that controller can only read data from keyboard\");\n\nstatic bool i8042_noloop;\nmodule_param_named(noloop, i8042_noloop, bool, 0);\nMODULE_PARM_DESC(noloop, \"Disable the AUX Loopback command while probing for the AUX port\");\n\nstatic bool i8042_notimeout;\nmodule_param_named(notimeout, i8042_notimeout, bool, 0);\nMODULE_PARM_DESC(notimeout, \"Ignore timeouts signalled by i8042\");\n\nstatic bool i8042_kbdreset;\nmodule_param_named(kbdreset, i8042_kbdreset, bool, 0);\nMODULE_PARM_DESC(kbdreset, \"Reset device connected to KBD port\");\n\n#ifdef CONFIG_X86\nstatic bool i8042_dritek;\nmodule_param_named(dritek, i8042_dritek, bool, 0);\nMODULE_PARM_DESC(dritek, \"Force enable the Dritek keyboard extension\");\n#endif\n\n#ifdef CONFIG_PNP\nstatic bool i8042_nopnp;\nmodule_param_named(nopnp, i8042_nopnp, bool, 0);\nMODULE_PARM_DESC(nopnp, \"Do not use PNP to detect controller settings\");\n#endif\n\n#define DEBUG\n#ifdef DEBUG\nstatic bool i8042_debug;\nmodule_param_named(debug, i8042_debug, bool, 0600);\nMODULE_PARM_DESC(debug, \"Turn i8042 debugging mode on and off\");\n\nstatic bool i8042_unmask_kbd_data;\nmodule_param_named(unmask_kbd_data, i8042_unmask_kbd_data, bool, 0600);\nMODULE_PARM_DESC(unmask_kbd_data, \"Unconditional enable (may reveal sensitive data) of normally sanitize-filtered kbd data traffic debug log [pre-condition: i8042.debug=1 enabled]\");\n#endif\n\nstatic bool i8042_present;\nstatic bool i8042_bypass_aux_irq_test;\nstatic char i8042_kbd_firmware_id[128];\nstatic char i8042_aux_firmware_id[128];\nstatic struct fwnode_handle *i8042_kbd_fwnode;\n\n#include \"i8042.h\"\n\n \nstatic DEFINE_SPINLOCK(i8042_lock);\n\n \nstatic DEFINE_MUTEX(i8042_mutex);\n\nstruct i8042_port {\n\tstruct serio *serio;\n\tint irq;\n\tbool exists;\n\tbool driver_bound;\n\tsigned char mux;\n};\n\n#define I8042_KBD_PORT_NO\t0\n#define I8042_AUX_PORT_NO\t1\n#define I8042_MUX_PORT_NO\t2\n#define I8042_NUM_PORTS\t\t(I8042_NUM_MUX_PORTS + 2)\n\nstatic struct i8042_port i8042_ports[I8042_NUM_PORTS];\n\nstatic unsigned char i8042_initial_ctr;\nstatic unsigned char i8042_ctr;\nstatic bool i8042_mux_present;\nstatic bool i8042_kbd_irq_registered;\nstatic bool i8042_aux_irq_registered;\nstatic unsigned char i8042_suppress_kbd_ack;\nstatic struct platform_device *i8042_platform_device;\nstatic struct notifier_block i8042_kbd_bind_notifier_block;\n\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id);\nstatic bool (*i8042_platform_filter)(unsigned char data, unsigned char str,\n\t\t\t\t     struct serio *serio);\n\nvoid i8042_lock_chip(void)\n{\n\tmutex_lock(&i8042_mutex);\n}\nEXPORT_SYMBOL(i8042_lock_chip);\n\nvoid i8042_unlock_chip(void)\n{\n\tmutex_unlock(&i8042_mutex);\n}\nEXPORT_SYMBOL(i8042_unlock_chip);\n\nint i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,\n\t\t\t\t\tstruct serio *serio))\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (i8042_platform_filter) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\ti8042_platform_filter = filter;\n\nout:\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(i8042_install_filter);\n\nint i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,\n\t\t\t\t       struct serio *port))\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (i8042_platform_filter != filter) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ti8042_platform_filter = NULL;\n\nout:\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(i8042_remove_filter);\n\n \n\nstatic int i8042_wait_read(void)\n{\n\tint i = 0;\n\n\twhile ((~i8042_read_status() & I8042_STR_OBF) && (i < I8042_CTL_TIMEOUT)) {\n\t\tudelay(50);\n\t\ti++;\n\t}\n\treturn -(i == I8042_CTL_TIMEOUT);\n}\n\nstatic int i8042_wait_write(void)\n{\n\tint i = 0;\n\n\twhile ((i8042_read_status() & I8042_STR_IBF) && (i < I8042_CTL_TIMEOUT)) {\n\t\tudelay(50);\n\t\ti++;\n\t}\n\treturn -(i == I8042_CTL_TIMEOUT);\n}\n\n \n\nstatic int i8042_flush(void)\n{\n\tunsigned long flags;\n\tunsigned char data, str;\n\tint count = 0;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\twhile ((str = i8042_read_status()) & I8042_STR_OBF) {\n\t\tif (count++ < I8042_BUFFER_SIZE) {\n\t\t\tudelay(50);\n\t\t\tdata = i8042_read_data();\n\t\t\tdbg(\"%02x <- i8042 (flush, %s)\\n\",\n\t\t\t    data, str & I8042_STR_AUXDATA ? \"aux\" : \"kbd\");\n\t\t} else {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\n\n \n\nstatic int __i8042_command(unsigned char *param, int command)\n{\n\tint i, error;\n\n\tif (i8042_noloop && command == I8042_CMD_AUX_LOOP)\n\t\treturn -1;\n\n\terror = i8042_wait_write();\n\tif (error)\n\t\treturn error;\n\n\tdbg(\"%02x -> i8042 (command)\\n\", command & 0xff);\n\ti8042_write_command(command & 0xff);\n\n\tfor (i = 0; i < ((command >> 12) & 0xf); i++) {\n\t\terror = i8042_wait_write();\n\t\tif (error) {\n\t\t\tdbg(\"     -- i8042 (wait write timeout)\\n\");\n\t\t\treturn error;\n\t\t}\n\t\tdbg(\"%02x -> i8042 (parameter)\\n\", param[i]);\n\t\ti8042_write_data(param[i]);\n\t}\n\n\tfor (i = 0; i < ((command >> 8) & 0xf); i++) {\n\t\terror = i8042_wait_read();\n\t\tif (error) {\n\t\t\tdbg(\"     -- i8042 (wait read timeout)\\n\");\n\t\t\treturn error;\n\t\t}\n\n\t\tif (command == I8042_CMD_AUX_LOOP &&\n\t\t    !(i8042_read_status() & I8042_STR_AUXDATA)) {\n\t\t\tdbg(\"     -- i8042 (auxerr)\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tparam[i] = i8042_read_data();\n\t\tdbg(\"%02x <- i8042 (return)\\n\", param[i]);\n\t}\n\n\treturn 0;\n}\n\nint i8042_command(unsigned char *param, int command)\n{\n\tunsigned long flags;\n\tint retval;\n\n\tif (!i8042_present)\n\t\treturn -1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tretval = __i8042_command(param, command);\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(i8042_command);\n\n \n\nstatic int i8042_kbd_write(struct serio *port, unsigned char c)\n{\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tif (!(retval = i8042_wait_write())) {\n\t\tdbg(\"%02x -> i8042 (kbd-data)\\n\", c);\n\t\ti8042_write_data(c);\n\t}\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn retval;\n}\n\n \n\nstatic int i8042_aux_write(struct serio *serio, unsigned char c)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\treturn i8042_command(&c, port->mux == -1 ?\n\t\t\t\t\tI8042_CMD_AUX_SEND :\n\t\t\t\t\tI8042_CMD_MUX_SEND + port->mux);\n}\n\n\n \n\nstatic void i8042_port_close(struct serio *serio)\n{\n\tint irq_bit;\n\tint disable_bit;\n\tconst char *port_name;\n\n\tif (serio == i8042_ports[I8042_AUX_PORT_NO].serio) {\n\t\tirq_bit = I8042_CTR_AUXINT;\n\t\tdisable_bit = I8042_CTR_AUXDIS;\n\t\tport_name = \"AUX\";\n\t} else {\n\t\tirq_bit = I8042_CTR_KBDINT;\n\t\tdisable_bit = I8042_CTR_KBDDIS;\n\t\tport_name = \"KBD\";\n\t}\n\n\ti8042_ctr &= ~irq_bit;\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't write CTR while closing %s port\\n\", port_name);\n\n\tudelay(50);\n\n\ti8042_ctr &= ~disable_bit;\n\ti8042_ctr |= irq_bit;\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_err(\"Can't reactivate %s port\\n\", port_name);\n\n\t \n\ti8042_interrupt(0, NULL);\n}\n\n \nstatic int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tdevice_set_wakeup_capable(&serio->dev, true);\n\n\t \n\tif (pm_suspend_default_s2idle() &&\n\t    serio == i8042_ports[I8042_KBD_PORT_NO].serio) {\n\t\tdevice_set_wakeup_enable(&serio->dev, true);\n\t}\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = true;\n\tspin_unlock_irq(&i8042_lock);\n\n\treturn 0;\n}\n\n \nstatic void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n\n\t \n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n}\n\n \nstatic bool i8042_filter(unsigned char data, unsigned char str,\n\t\t\t struct serio *serio)\n{\n\tif (unlikely(i8042_suppress_kbd_ack)) {\n\t\tif ((~str & I8042_STR_AUXDATA) &&\n\t\t    (data == 0xfa || data == 0xfe)) {\n\t\t\ti8042_suppress_kbd_ack--;\n\t\t\tdbg(\"Extra keyboard ACK - filtered out\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (i8042_platform_filter && i8042_platform_filter(data, str, serio)) {\n\t\tdbg(\"Filtered out by platform filter\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\tstruct i8042_port *port;\n\tstruct serio *serio;\n\tunsigned long flags;\n\tunsigned char str, data;\n\tunsigned int dfl;\n\tunsigned int port_no;\n\tbool filtered;\n\tint ret = 1;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tstr = i8042_read_status();\n\tif (unlikely(~str & I8042_STR_OBF)) {\n\t\tspin_unlock_irqrestore(&i8042_lock, flags);\n\t\tif (irq)\n\t\t\tdbg(\"Interrupt %d, without any data\\n\", irq);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdata = i8042_read_data();\n\n\tif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\t\tstatic unsigned long last_transmit;\n\t\tstatic unsigned char last_str;\n\n\t\tdfl = 0;\n\t\tif (str & I8042_STR_MUXERR) {\n\t\t\tdbg(\"MUX error, status is %02x, data is %02x\\n\",\n\t\t\t    str, data);\n \n\n\t\t\tswitch (data) {\n\t\t\t\tdefault:\n\t\t\t\t\tif (time_before(jiffies, last_transmit + HZ/10)) {\n\t\t\t\t\t\tstr = last_str;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfallthrough;\t \n\t\t\t\tcase 0xfc:\n\t\t\t\tcase 0xfd:\n\t\t\t\tcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\t\t\t\tcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\t\t\t}\n\t\t}\n\n\t\tport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\t\tlast_str = str;\n\t\tlast_transmit = jiffies;\n\t} else {\n\n\t\tdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\t\t      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\t\tport_no = (str & I8042_STR_AUXDATA) ?\n\t\t\t\tI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\t}\n\n\tport = &i8042_ports[port_no];\n\tserio = port->exists ? port->serio : NULL;\n\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(serio && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}\n\n \n\nstatic int i8042_enable_kbd_port(void)\n{\n\ti8042_ctr &= ~I8042_CTR_KBDDIS;\n\ti8042_ctr |= I8042_CTR_KBDINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\ti8042_ctr &= ~I8042_CTR_KBDINT;\n\t\ti8042_ctr |= I8042_CTR_KBDDIS;\n\t\tpr_err(\"Failed to enable KBD port\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int i8042_enable_aux_port(void)\n{\n\ti8042_ctr &= ~I8042_CTR_AUXDIS;\n\ti8042_ctr |= I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\t\ti8042_ctr |= I8042_CTR_AUXDIS;\n\t\tpr_err(\"Failed to enable AUX port\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int i8042_enable_mux_ports(void)\n{\n\tunsigned char param;\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\n\t\ti8042_command(&param, I8042_CMD_MUX_PFX + i);\n\t\ti8042_command(&param, I8042_CMD_AUX_ENABLE);\n\t}\n\n\treturn i8042_enable_aux_port();\n}\n\n \n\nstatic int i8042_set_mux_mode(bool multiplex, unsigned char *mux_version)\n{\n\n\tunsigned char param, val;\n \n\n\ti8042_flush();\n\n \n\n\tparam = val = 0xf0;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\n\t\treturn -1;\n\tparam = val = multiplex ? 0x56 : 0xf6;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\n\t\treturn -1;\n\tparam = val = multiplex ? 0xa4 : 0xa5;\n\tif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param == val)\n\t\treturn -1;\n\n \n\tif (param == 0xac)\n\t\treturn -1;\n\n\tif (mux_version)\n\t\t*mux_version = param;\n\n\treturn 0;\n}\n\n \n\nstatic int i8042_check_mux(void)\n{\n\tunsigned char mux_version;\n\n\tif (i8042_set_mux_mode(true, &mux_version))\n\t\treturn -1;\n\n\tpr_info(\"Detected active multiplexing controller, rev %d.%d\\n\",\n\t\t(mux_version >> 4) & 0xf, mux_version & 0xf);\n\n \n\ti8042_ctr |= I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_err(\"Failed to disable AUX port, can't use MUX\\n\");\n\t\treturn -EIO;\n\t}\n\n\ti8042_mux_present = true;\n\n\treturn 0;\n}\n\n \nstatic struct completion i8042_aux_irq_delivered;\nstatic bool i8042_irq_being_tested;\n\nstatic irqreturn_t i8042_aux_test_irq(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tunsigned char str, data;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tstr = i8042_read_status();\n\tif (str & I8042_STR_OBF) {\n\t\tdata = i8042_read_data();\n\t\tdbg(\"%02x <- i8042 (aux_test_irq, %s)\\n\",\n\t\t    data, str & I8042_STR_AUXDATA ? \"aux\" : \"kbd\");\n\t\tif (i8042_irq_being_tested &&\n\t\t    data == 0xa5 && (str & I8042_STR_AUXDATA))\n\t\t\tcomplete(&i8042_aux_irq_delivered);\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\treturn IRQ_RETVAL(ret);\n}\n\n \nstatic int i8042_toggle_aux(bool on)\n{\n\tunsigned char param;\n\tint i;\n\n\tif (i8042_command(&param,\n\t\t\ton ? I8042_CMD_AUX_ENABLE : I8042_CMD_AUX_DISABLE))\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tudelay(50);\n\n\t\tif (i8042_command(&param, I8042_CMD_CTL_RCTR))\n\t\t\treturn -1;\n\n\t\tif (!(param & I8042_CTR_AUXDIS) == on)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n \n\nstatic int i8042_check_aux(void)\n{\n\tint retval = -1;\n\tbool irq_registered = false;\n\tbool aux_loop_broken = false;\n\tunsigned long flags;\n\tunsigned char param;\n\n \n\n\ti8042_flush();\n\n \n\n\tparam = 0x5a;\n\tretval = i8042_command(&param, I8042_CMD_AUX_LOOP);\n\tif (retval || param != 0x5a) {\n\n \n\n\t\tif (i8042_command(&param, I8042_CMD_AUX_TEST) ||\n\t\t    (param && param != 0xfa && param != 0xff))\n\t\t\treturn -1;\n\n \n\t\tif (!retval)\n\t\t\taux_loop_broken = true;\n\t}\n\n \n\n\tif (i8042_toggle_aux(false)) {\n\t\tpr_warn(\"Failed to disable AUX port, but continuing anyway... Is this a SiS?\\n\");\n\t\tpr_warn(\"If AUX port is really absent please use the 'i8042.noaux' option\\n\");\n\t}\n\n\tif (i8042_toggle_aux(true))\n\t\treturn -1;\n\n \n\tif (i8042_kbdreset) {\n\t\tpr_warn(\"Attempting to reset device connected to KBD port\\n\");\n\t\ti8042_kbd_write(NULL, (unsigned char) 0xff);\n\t}\n\n \n\n\tif (i8042_noloop || i8042_bypass_aux_irq_test || aux_loop_broken) {\n \n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tif (request_irq(I8042_AUX_IRQ, i8042_aux_test_irq, IRQF_SHARED,\n\t\t\t\"i8042\", i8042_platform_device))\n\t\tgoto out;\n\n\tirq_registered = true;\n\n\tif (i8042_enable_aux_port())\n\t\tgoto out;\n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\n\tinit_completion(&i8042_aux_irq_delivered);\n\ti8042_irq_being_tested = true;\n\n\tparam = 0xa5;\n\tretval = __i8042_command(&param, I8042_CMD_AUX_LOOP & 0xf0ff);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (retval)\n\t\tgoto out;\n\n\tif (wait_for_completion_timeout(&i8042_aux_irq_delivered,\n\t\t\t\t\tmsecs_to_jiffies(250)) == 0) {\n \n\t\tdbg(\"     -- i8042 (aux irq test timeout)\\n\");\n\t\ti8042_flush();\n\t\tretval = -1;\n\t}\n\n out:\n\n \n\n\ti8042_ctr |= I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~I8042_CTR_AUXINT;\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tretval = -1;\n\n\tif (irq_registered)\n\t\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n\n\treturn retval;\n}\n\nstatic int i8042_controller_check(void)\n{\n\tif (i8042_flush()) {\n\t\tpr_info(\"No controller found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_controller_selftest(void)\n{\n\tunsigned char param;\n\tint i = 0;\n\n\t \n\tdo {\n\n\t\tif (i8042_command(&param, I8042_CMD_CTL_TEST)) {\n\t\t\tpr_err(\"i8042 controller selftest timeout\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (param == I8042_RET_CTL_TEST)\n\t\t\treturn 0;\n\n\t\tdbg(\"i8042 controller selftest: %#x != %#x\\n\",\n\t\t    param, I8042_RET_CTL_TEST);\n\t\tmsleep(50);\n\t} while (i++ < 5);\n\n#ifdef CONFIG_X86\n\t \n\tpr_info(\"giving up on controller selftest, continuing anyway...\\n\");\n\treturn 0;\n#else\n\tpr_err(\"i8042 controller selftest failed\\n\");\n\treturn -EIO;\n#endif\n}\n\n \n\nstatic int i8042_controller_init(void)\n{\n\tunsigned long flags;\n\tint n = 0;\n\tunsigned char ctr[2];\n\n \n\n\tdo {\n\t\tif (n >= 10) {\n\t\t\tpr_err(\"Unable to get stable CTR read\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (n != 0)\n\t\t\tudelay(50);\n\n\t\tif (i8042_command(&ctr[n++ % 2], I8042_CMD_CTL_RCTR)) {\n\t\t\tpr_err(\"Can't read CTR while initializing i8042\\n\");\n\t\t\treturn i8042_probe_defer ? -EPROBE_DEFER : -EIO;\n\t\t}\n\n\t} while (n < 2 || ctr[0] != ctr[1]);\n\n\ti8042_initial_ctr = i8042_ctr = ctr[0];\n\n \n\n\ti8042_ctr |= I8042_CTR_KBDDIS;\n\ti8042_ctr &= ~I8042_CTR_KBDINT;\n\n \n\n\tspin_lock_irqsave(&i8042_lock, flags);\n\tif (~i8042_read_status() & I8042_STR_KEYLOCK) {\n\t\tif (i8042_unlock)\n\t\t\ti8042_ctr |= I8042_CTR_IGNKEYLOCK;\n\t\telse\n\t\t\tpr_warn(\"Warning: Keylock active\\n\");\n\t}\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n \n\n\tif (~i8042_ctr & I8042_CTR_XLATE)\n\t\ti8042_direct = true;\n\n \n\n\tif (i8042_direct)\n\t\ti8042_ctr &= ~I8042_CTR_XLATE;\n\n \n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_err(\"Can't write CTR while initializing i8042\\n\");\n\t\treturn -EIO;\n\t}\n\n \n\n\ti8042_flush();\n\n\treturn 0;\n}\n\n\n \n\nstatic void i8042_controller_reset(bool s2r_wants_reset)\n{\n\ti8042_flush();\n\n \n\n\ti8042_ctr |= I8042_CTR_KBDDIS | I8042_CTR_AUXDIS;\n\ti8042_ctr &= ~(I8042_CTR_KBDINT | I8042_CTR_AUXINT);\n\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't write CTR while resetting\\n\");\n\n \n\n\tif (i8042_mux_present)\n\t\ti8042_set_mux_mode(false, NULL);\n\n \n\n\tif (i8042_reset == I8042_RESET_ALWAYS ||\n\t    (i8042_reset == I8042_RESET_ON_S2RAM && s2r_wants_reset)) {\n\t\ti8042_controller_selftest();\n\t}\n\n \n\n\tif (i8042_command(&i8042_initial_ctr, I8042_CMD_CTL_WCTR))\n\t\tpr_warn(\"Can't restore CTR\\n\");\n}\n\n\n \n\n#define DELAY do { mdelay(1); if (++delay > 10) return delay; } while(0)\n\nstatic long i8042_panic_blink(int state)\n{\n\tlong delay = 0;\n\tchar led;\n\n\tled = (state) ? 0x01 | 0x04 : 0;\n\twhile (i8042_read_status() & I8042_STR_IBF)\n\t\tDELAY;\n\tdbg(\"%02x -> i8042 (panic blink)\\n\", 0xed);\n\ti8042_suppress_kbd_ack = 2;\n\ti8042_write_data(0xed);  \n\tDELAY;\n\twhile (i8042_read_status() & I8042_STR_IBF)\n\t\tDELAY;\n\tDELAY;\n\tdbg(\"%02x -> i8042 (panic blink)\\n\", led);\n\ti8042_write_data(led);\n\tDELAY;\n\treturn delay;\n}\n\n#undef DELAY\n\n#ifdef CONFIG_X86\nstatic void i8042_dritek_enable(void)\n{\n\tunsigned char param = 0x90;\n\tint error;\n\n\terror = i8042_command(&param, 0x1059);\n\tif (error)\n\t\tpr_warn(\"Failed to enable DRITEK extension: %d\\n\", error);\n}\n#endif\n\n#ifdef CONFIG_PM\n\n \n\nstatic int i8042_controller_resume(bool s2r_wants_reset)\n{\n\tint error;\n\n\terror = i8042_controller_check();\n\tif (error)\n\t\treturn error;\n\n\tif (i8042_reset == I8042_RESET_ALWAYS ||\n\t    (i8042_reset == I8042_RESET_ON_S2RAM && s2r_wants_reset)) {\n\t\terror = i8042_controller_selftest();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n \n\n\ti8042_ctr = i8042_initial_ctr;\n\tif (i8042_direct)\n\t\ti8042_ctr &= ~I8042_CTR_XLATE;\n\ti8042_ctr |= I8042_CTR_AUXDIS | I8042_CTR_KBDDIS;\n\ti8042_ctr &= ~(I8042_CTR_AUXINT | I8042_CTR_KBDINT);\n\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\tpr_warn(\"Can't write CTR to resume, retrying...\\n\");\n\t\tmsleep(50);\n\t\tif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\n\t\t\tpr_err(\"CTR write retry failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\n#ifdef CONFIG_X86\n\tif (i8042_dritek)\n\t\ti8042_dritek_enable();\n#endif\n\n\tif (i8042_mux_present) {\n\t\tif (i8042_set_mux_mode(true, NULL) || i8042_enable_mux_ports())\n\t\t\tpr_warn(\"failed to resume active multiplexor, mouse won't work\\n\");\n\t} else if (i8042_ports[I8042_AUX_PORT_NO].serio)\n\t\ti8042_enable_aux_port();\n\n\tif (i8042_ports[I8042_KBD_PORT_NO].serio)\n\t\ti8042_enable_kbd_port();\n\n\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\n \n\nstatic int i8042_pm_suspend(struct device *dev)\n{\n\tint i;\n\n\tif (pm_suspend_via_firmware())\n\t\ti8042_controller_reset(true);\n\n\t \n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio && device_may_wakeup(&serio->dev))\n\t\t\tenable_irq_wake(i8042_ports[i].irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_pm_resume_noirq(struct device *dev)\n{\n\tif (!pm_resume_via_firmware())\n\t\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_resume(struct device *dev)\n{\n\tbool want_reset;\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio && device_may_wakeup(&serio->dev))\n\t\t\tdisable_irq_wake(i8042_ports[i].irq);\n\t}\n\n\t \n\tif (!pm_suspend_via_firmware())\n\t\treturn 0;\n\n\t \n\twant_reset = pm_resume_via_firmware();\n\n\treturn i8042_controller_resume(want_reset);\n}\n\nstatic int i8042_pm_thaw(struct device *dev)\n{\n\ti8042_interrupt(0, NULL);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_reset(struct device *dev)\n{\n\ti8042_controller_reset(false);\n\n\treturn 0;\n}\n\nstatic int i8042_pm_restore(struct device *dev)\n{\n\treturn i8042_controller_resume(false);\n}\n\nstatic const struct dev_pm_ops i8042_pm_ops = {\n\t.suspend\t= i8042_pm_suspend,\n\t.resume_noirq\t= i8042_pm_resume_noirq,\n\t.resume\t\t= i8042_pm_resume,\n\t.thaw\t\t= i8042_pm_thaw,\n\t.poweroff\t= i8042_pm_reset,\n\t.restore\t= i8042_pm_restore,\n};\n\n#endif  \n\n \n\nstatic void i8042_shutdown(struct platform_device *dev)\n{\n\ti8042_controller_reset(false);\n}\n\nstatic int i8042_create_kbd_port(void)\n{\n\tstruct serio *serio;\n\tstruct i8042_port *port = &i8042_ports[I8042_KBD_PORT_NO];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= i8042_direct ? SERIO_8042 : SERIO_8042_XL;\n\tserio->write\t\t= i8042_dumbkbd ? NULL : i8042_kbd_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->close\t\t= i8042_port_close;\n\tserio->ps2_cmd_mutex\t= &i8042_mutex;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tstrscpy(serio->name, \"i8042 KBD port\", sizeof(serio->name));\n\tstrscpy(serio->phys, I8042_KBD_PHYS_DESC, sizeof(serio->phys));\n\tstrscpy(serio->firmware_id, i8042_kbd_firmware_id,\n\t\tsizeof(serio->firmware_id));\n\tset_primary_fwnode(&serio->dev, i8042_kbd_fwnode);\n\n\tport->serio = serio;\n\tport->irq = I8042_KBD_IRQ;\n\n\treturn 0;\n}\n\nstatic int i8042_create_aux_port(int idx)\n{\n\tstruct serio *serio;\n\tint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\n\tstruct i8042_port *port = &i8042_ports[port_no];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= i8042_aux_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->ps2_cmd_mutex\t= &i8042_mutex;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tif (idx < 0) {\n\t\tstrscpy(serio->name, \"i8042 AUX port\", sizeof(serio->name));\n\t\tstrscpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\n\t\tstrscpy(serio->firmware_id, i8042_aux_firmware_id,\n\t\t\tsizeof(serio->firmware_id));\n\t\tserio->close = i8042_port_close;\n\t} else {\n\t\tsnprintf(serio->name, sizeof(serio->name), \"i8042 AUX%d port\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\n\t\tstrscpy(serio->firmware_id, i8042_aux_firmware_id,\n\t\t\tsizeof(serio->firmware_id));\n\t}\n\n\tport->serio = serio;\n\tport->mux = idx;\n\tport->irq = I8042_AUX_IRQ;\n\n\treturn 0;\n}\n\nstatic void i8042_free_kbd_port(void)\n{\n\tkfree(i8042_ports[I8042_KBD_PORT_NO].serio);\n\ti8042_ports[I8042_KBD_PORT_NO].serio = NULL;\n}\n\nstatic void i8042_free_aux_ports(void)\n{\n\tint i;\n\n\tfor (i = I8042_AUX_PORT_NO; i < I8042_NUM_PORTS; i++) {\n\t\tkfree(i8042_ports[i].serio);\n\t\ti8042_ports[i].serio = NULL;\n\t}\n}\n\nstatic void i8042_register_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (!serio)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_INFO \"serio: %s at %#lx,%#lx irq %d\\n\",\n\t\t\tserio->name,\n\t\t\t(unsigned long) I8042_DATA_REG,\n\t\t\t(unsigned long) I8042_COMMAND_REG,\n\t\t\ti8042_ports[i].irq);\n\t\tserio_register_port(serio);\n\t}\n}\n\nstatic void i8042_unregister_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tif (i8042_ports[i].serio) {\n\t\t\tserio_unregister_port(i8042_ports[i].serio);\n\t\t\ti8042_ports[i].serio = NULL;\n\t\t}\n\t}\n}\n\nstatic void i8042_free_irqs(void)\n{\n\tif (i8042_aux_irq_registered)\n\t\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n\tif (i8042_kbd_irq_registered)\n\t\tfree_irq(I8042_KBD_IRQ, i8042_platform_device);\n\n\ti8042_aux_irq_registered = i8042_kbd_irq_registered = false;\n}\n\nstatic int i8042_setup_aux(void)\n{\n\tint (*aux_enable)(void);\n\tint error;\n\tint i;\n\n\tif (i8042_check_aux())\n\t\treturn -ENODEV;\n\n\tif (i8042_nomux || i8042_check_mux()) {\n\t\terror = i8042_create_aux_port(-1);\n\t\tif (error)\n\t\t\tgoto err_free_ports;\n\t\taux_enable = i8042_enable_aux_port;\n\t} else {\n\t\tfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\n\t\t\terror = i8042_create_aux_port(i);\n\t\t\tif (error)\n\t\t\t\tgoto err_free_ports;\n\t\t}\n\t\taux_enable = i8042_enable_mux_ports;\n\t}\n\n\terror = request_irq(I8042_AUX_IRQ, i8042_interrupt, IRQF_SHARED,\n\t\t\t    \"i8042\", i8042_platform_device);\n\tif (error)\n\t\tgoto err_free_ports;\n\n\terror = aux_enable();\n\tif (error)\n\t\tgoto err_free_irq;\n\n\ti8042_aux_irq_registered = true;\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(I8042_AUX_IRQ, i8042_platform_device);\n err_free_ports:\n\ti8042_free_aux_ports();\n\treturn error;\n}\n\nstatic int i8042_setup_kbd(void)\n{\n\tint error;\n\n\terror = i8042_create_kbd_port();\n\tif (error)\n\t\treturn error;\n\n\terror = request_irq(I8042_KBD_IRQ, i8042_interrupt, IRQF_SHARED,\n\t\t\t    \"i8042\", i8042_platform_device);\n\tif (error)\n\t\tgoto err_free_port;\n\n\terror = i8042_enable_kbd_port();\n\tif (error)\n\t\tgoto err_free_irq;\n\n\ti8042_kbd_irq_registered = true;\n\treturn 0;\n\n err_free_irq:\n\tfree_irq(I8042_KBD_IRQ, i8042_platform_device);\n err_free_port:\n\ti8042_free_kbd_port();\n\treturn error;\n}\n\nstatic int i8042_kbd_bind_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct serio *serio = to_serio_port(dev);\n\tstruct i8042_port *port = serio->port_data;\n\n\tif (serio != i8042_ports[I8042_KBD_PORT_NO].serio)\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_BOUND_DRIVER:\n\t\tport->driver_bound = true;\n\t\tbreak;\n\n\tcase BUS_NOTIFY_UNBIND_DRIVER:\n\t\tport->driver_bound = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int i8042_probe(struct platform_device *dev)\n{\n\tint error;\n\n\tif (i8042_reset == I8042_RESET_ALWAYS) {\n\t\terror = i8042_controller_selftest();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = i8042_controller_init();\n\tif (error)\n\t\treturn error;\n\n#ifdef CONFIG_X86\n\tif (i8042_dritek)\n\t\ti8042_dritek_enable();\n#endif\n\n\tif (!i8042_noaux) {\n\t\terror = i8042_setup_aux();\n\t\tif (error && error != -ENODEV && error != -EBUSY)\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!i8042_nokbd) {\n\t\terror = i8042_setup_kbd();\n\t\tif (error)\n\t\t\tgoto out_fail;\n\t}\n \n\ti8042_register_ports();\n\n\treturn 0;\n\n out_fail:\n\ti8042_free_aux_ports();\t \n\ti8042_free_irqs();\n\ti8042_controller_reset(false);\n\n\treturn error;\n}\n\nstatic int i8042_remove(struct platform_device *dev)\n{\n\ti8042_unregister_ports();\n\ti8042_free_irqs();\n\ti8042_controller_reset(false);\n\n\treturn 0;\n}\n\nstatic struct platform_driver i8042_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"i8042\",\n#ifdef CONFIG_PM\n\t\t.pm\t= &i8042_pm_ops,\n#endif\n\t},\n\t.probe\t\t= i8042_probe,\n\t.remove\t\t= i8042_remove,\n\t.shutdown\t= i8042_shutdown,\n};\n\nstatic struct notifier_block i8042_kbd_bind_notifier_block = {\n\t.notifier_call = i8042_kbd_bind_notifier,\n};\n\nstatic int __init i8042_init(void)\n{\n\tint err;\n\n\tdbg_init();\n\n\terr = i8042_platform_init();\n\tif (err)\n\t\treturn (err == -ENODEV) ? 0 : err;\n\n\terr = i8042_controller_check();\n\tif (err)\n\t\tgoto err_platform_exit;\n\n\t \n\ti8042_present = true;\n\n\terr = platform_driver_register(&i8042_driver);\n\tif (err)\n\t\tgoto err_platform_exit;\n\n\ti8042_platform_device = platform_device_alloc(\"i8042\", -1);\n\tif (!i8042_platform_device) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unregister_driver;\n\t}\n\n\terr = platform_device_add(i8042_platform_device);\n\tif (err)\n\t\tgoto err_free_device;\n\n\tbus_register_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = i8042_panic_blink;\n\n\treturn 0;\n\nerr_free_device:\n\tplatform_device_put(i8042_platform_device);\nerr_unregister_driver:\n\tplatform_driver_unregister(&i8042_driver);\n err_platform_exit:\n\ti8042_platform_exit();\n\treturn err;\n}\n\nstatic void __exit i8042_exit(void)\n{\n\tif (!i8042_present)\n\t\treturn;\n\n\tplatform_device_unregister(i8042_platform_device);\n\tplatform_driver_unregister(&i8042_driver);\n\ti8042_platform_exit();\n\n\tbus_unregister_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = NULL;\n}\n\nmodule_init(i8042_init);\nmodule_exit(i8042_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}