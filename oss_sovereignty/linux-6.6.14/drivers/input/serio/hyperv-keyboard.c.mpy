{
  "module_name": "hyperv-keyboard.c",
  "hash_id": "8ed53580a0a1e0784453670d5ade7673bad042fe4781abb116e5a9a914ad90db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/hyperv-keyboard.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/completion.h>\n#include <linux/hyperv.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n\n \n#define SYNTH_KBD_VERSION_MAJOR 1\n#define SYNTH_KBD_VERSION_MINOR\t0\n#define SYNTH_KBD_VERSION\t\t(SYNTH_KBD_VERSION_MINOR | \\\n\t\t\t\t\t (SYNTH_KBD_VERSION_MAJOR << 16))\n\n\n \nenum synth_kbd_msg_type {\n\tSYNTH_KBD_PROTOCOL_REQUEST = 1,\n\tSYNTH_KBD_PROTOCOL_RESPONSE = 2,\n\tSYNTH_KBD_EVENT = 3,\n\tSYNTH_KBD_LED_INDICATORS = 4,\n};\n\n \nstruct synth_kbd_msg_hdr {\n\t__le32 type;\n};\n\nstruct synth_kbd_msg {\n\tstruct synth_kbd_msg_hdr header;\n\tchar data[];  \n};\n\nunion synth_kbd_version {\n\t__le32 version;\n};\n\n \nstruct synth_kbd_protocol_request {\n\tstruct synth_kbd_msg_hdr header;\n\tunion synth_kbd_version version_requested;\n};\n\n#define PROTOCOL_ACCEPTED\tBIT(0)\nstruct synth_kbd_protocol_response {\n\tstruct synth_kbd_msg_hdr header;\n\t__le32 proto_status;\n};\n\n#define IS_UNICODE\tBIT(0)\n#define IS_BREAK\tBIT(1)\n#define IS_E0\t\tBIT(2)\n#define IS_E1\t\tBIT(3)\nstruct synth_kbd_keystroke {\n\tstruct synth_kbd_msg_hdr header;\n\t__le16 make_code;\n\t__le16 reserved0;\n\t__le32 info;  \n};\n\n\n#define HK_MAXIMUM_MESSAGE_SIZE 256\n\n#define KBD_VSC_SEND_RING_BUFFER_SIZE\tVMBUS_RING_SIZE(36 * 1024)\n#define KBD_VSC_RECV_RING_BUFFER_SIZE\tVMBUS_RING_SIZE(36 * 1024)\n\n#define XTKBD_EMUL0     0xe0\n#define XTKBD_EMUL1     0xe1\n#define XTKBD_RELEASE   0x80\n\n\n \nstruct hv_kbd_dev {\n\tstruct hv_device *hv_dev;\n\tstruct serio *hv_serio;\n\tstruct synth_kbd_protocol_request protocol_req;\n\tstruct synth_kbd_protocol_response protocol_resp;\n\t \n\tstruct completion wait_event;\n\tspinlock_t lock;  \n\tbool started;\n};\n\nstatic void hv_kbd_on_receive(struct hv_device *hv_dev,\n\t\t\t      struct synth_kbd_msg *msg, u32 msg_length)\n{\n\tstruct hv_kbd_dev *kbd_dev = hv_get_drvdata(hv_dev);\n\tstruct synth_kbd_keystroke *ks_msg;\n\tunsigned long flags;\n\tu32 msg_type = __le32_to_cpu(msg->header.type);\n\tu32 info;\n\tu16 scan_code;\n\n\tswitch (msg_type) {\n\tcase SYNTH_KBD_PROTOCOL_RESPONSE:\n\t\t \n\t\tif (msg_length < sizeof(struct synth_kbd_protocol_response)) {\n\t\t\tdev_err(&hv_dev->device,\n\t\t\t\t\"Illegal protocol response packet (len: %d)\\n\",\n\t\t\t\tmsg_length);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&kbd_dev->protocol_resp, msg,\n\t\t\tsizeof(struct synth_kbd_protocol_response));\n\t\tcomplete(&kbd_dev->wait_event);\n\t\tbreak;\n\n\tcase SYNTH_KBD_EVENT:\n\t\t \n\t\tif (msg_length < sizeof(struct  synth_kbd_keystroke)) {\n\t\t\tdev_err(&hv_dev->device,\n\t\t\t\t\"Illegal keyboard event packet (len: %d)\\n\",\n\t\t\t\tmsg_length);\n\t\t\tbreak;\n\t\t}\n\n\t\tks_msg = (struct synth_kbd_keystroke *)msg;\n\t\tinfo = __le32_to_cpu(ks_msg->info);\n\n\t\t \n\t\tspin_lock_irqsave(&kbd_dev->lock, flags);\n\t\tif (kbd_dev->started) {\n\t\t\tif (info & IS_E0)\n\t\t\t\tserio_interrupt(kbd_dev->hv_serio,\n\t\t\t\t\t\tXTKBD_EMUL0, 0);\n\t\t\tif (info & IS_E1)\n\t\t\t\tserio_interrupt(kbd_dev->hv_serio,\n\t\t\t\t\t\tXTKBD_EMUL1, 0);\n\t\t\tscan_code = __le16_to_cpu(ks_msg->make_code);\n\t\t\tif (info & IS_BREAK)\n\t\t\t\tscan_code |= XTKBD_RELEASE;\n\n\t\t\tserio_interrupt(kbd_dev->hv_serio, scan_code, 0);\n\t\t}\n\t\tspin_unlock_irqrestore(&kbd_dev->lock, flags);\n\n\t\t \n\t\tif (!(info & IS_BREAK))\n\t\t\tpm_wakeup_hard_event(&hv_dev->device);\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&hv_dev->device,\n\t\t\t\"unhandled message type %d\\n\", msg_type);\n\t}\n}\n\nstatic void hv_kbd_handle_received_packet(struct hv_device *hv_dev,\n\t\t\t\t\t  struct vmpacket_descriptor *desc,\n\t\t\t\t\t  u32 bytes_recvd,\n\t\t\t\t\t  u64 req_id)\n{\n\tstruct synth_kbd_msg *msg;\n\tu32 msg_sz;\n\n\tswitch (desc->type) {\n\tcase VM_PKT_COMP:\n\t\tbreak;\n\n\tcase VM_PKT_DATA_INBAND:\n\t\t \n\n\t\tmsg_sz = bytes_recvd - (desc->offset8 << 3);\n\t\tif (msg_sz <= sizeof(struct synth_kbd_msg_hdr)) {\n\t\t\t \n\t\t\tdev_err(&hv_dev->device,\n\t\t\t\t\"Illegal packet (type: %d, tid: %llx, size: %d)\\n\",\n\t\t\t\tdesc->type, req_id, msg_sz);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (void *)desc + (desc->offset8 << 3);\n\t\thv_kbd_on_receive(hv_dev, msg, msg_sz);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&hv_dev->device,\n\t\t\t\"unhandled packet type %d, tid %llx len %d\\n\",\n\t\t\tdesc->type, req_id, bytes_recvd);\n\t\tbreak;\n\t}\n}\n\nstatic void hv_kbd_on_channel_callback(void *context)\n{\n\tstruct vmpacket_descriptor *desc;\n\tstruct hv_device *hv_dev = context;\n\tu32 bytes_recvd;\n\tu64 req_id;\n\n\tforeach_vmbus_pkt(desc, hv_dev->channel) {\n\t\tbytes_recvd = desc->len8 * 8;\n\t\treq_id = desc->trans_id;\n\n\t\thv_kbd_handle_received_packet(hv_dev, desc, bytes_recvd,\n\t\t\t\t\t      req_id);\n\t}\n}\n\nstatic int hv_kbd_connect_to_vsp(struct hv_device *hv_dev)\n{\n\tstruct hv_kbd_dev *kbd_dev = hv_get_drvdata(hv_dev);\n\tstruct synth_kbd_protocol_request *request;\n\tstruct synth_kbd_protocol_response *response;\n\tu32 proto_status;\n\tint error;\n\n\treinit_completion(&kbd_dev->wait_event);\n\n\trequest = &kbd_dev->protocol_req;\n\tmemset(request, 0, sizeof(struct synth_kbd_protocol_request));\n\trequest->header.type = __cpu_to_le32(SYNTH_KBD_PROTOCOL_REQUEST);\n\trequest->version_requested.version = __cpu_to_le32(SYNTH_KBD_VERSION);\n\n\terror = vmbus_sendpacket(hv_dev->channel, request,\n\t\t\t\t sizeof(struct synth_kbd_protocol_request),\n\t\t\t\t (unsigned long)request,\n\t\t\t\t VM_PKT_DATA_INBAND,\n\t\t\t\t VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (error)\n\t\treturn error;\n\n\tif (!wait_for_completion_timeout(&kbd_dev->wait_event, 10 * HZ))\n\t\treturn -ETIMEDOUT;\n\n\tresponse = &kbd_dev->protocol_resp;\n\tproto_status = __le32_to_cpu(response->proto_status);\n\tif (!(proto_status & PROTOCOL_ACCEPTED)) {\n\t\tdev_err(&hv_dev->device,\n\t\t\t\"synth_kbd protocol request failed (version %d)\\n\",\n\t\t        SYNTH_KBD_VERSION);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int hv_kbd_start(struct serio *serio)\n{\n\tstruct hv_kbd_dev *kbd_dev = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_dev->lock, flags);\n\tkbd_dev->started = true;\n\tspin_unlock_irqrestore(&kbd_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic void hv_kbd_stop(struct serio *serio)\n{\n\tstruct hv_kbd_dev *kbd_dev = serio->port_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kbd_dev->lock, flags);\n\tkbd_dev->started = false;\n\tspin_unlock_irqrestore(&kbd_dev->lock, flags);\n}\n\nstatic int hv_kbd_probe(struct hv_device *hv_dev,\n\t\t\tconst struct hv_vmbus_device_id *dev_id)\n{\n\tstruct hv_kbd_dev *kbd_dev;\n\tstruct serio *hv_serio;\n\tint error;\n\n\tkbd_dev = kzalloc(sizeof(struct hv_kbd_dev), GFP_KERNEL);\n\thv_serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!kbd_dev || !hv_serio) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tkbd_dev->hv_dev = hv_dev;\n\tkbd_dev->hv_serio = hv_serio;\n\tspin_lock_init(&kbd_dev->lock);\n\tinit_completion(&kbd_dev->wait_event);\n\thv_set_drvdata(hv_dev, kbd_dev);\n\n\thv_serio->dev.parent  = &hv_dev->device;\n\thv_serio->id.type = SERIO_8042_XL;\n\thv_serio->port_data = kbd_dev;\n\tstrscpy(hv_serio->name, dev_name(&hv_dev->device),\n\t\tsizeof(hv_serio->name));\n\tstrscpy(hv_serio->phys, dev_name(&hv_dev->device),\n\t\tsizeof(hv_serio->phys));\n\n\thv_serio->start = hv_kbd_start;\n\thv_serio->stop = hv_kbd_stop;\n\n\terror = vmbus_open(hv_dev->channel,\n\t\t\t   KBD_VSC_SEND_RING_BUFFER_SIZE,\n\t\t\t   KBD_VSC_RECV_RING_BUFFER_SIZE,\n\t\t\t   NULL, 0,\n\t\t\t   hv_kbd_on_channel_callback,\n\t\t\t   hv_dev);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\terror = hv_kbd_connect_to_vsp(hv_dev);\n\tif (error)\n\t\tgoto err_close_vmbus;\n\n\tserio_register_port(kbd_dev->hv_serio);\n\n\tdevice_init_wakeup(&hv_dev->device, true);\n\n\treturn 0;\n\nerr_close_vmbus:\n\tvmbus_close(hv_dev->channel);\nerr_free_mem:\n\tkfree(hv_serio);\n\tkfree(kbd_dev);\n\treturn error;\n}\n\nstatic void hv_kbd_remove(struct hv_device *hv_dev)\n{\n\tstruct hv_kbd_dev *kbd_dev = hv_get_drvdata(hv_dev);\n\n\tserio_unregister_port(kbd_dev->hv_serio);\n\tvmbus_close(hv_dev->channel);\n\tkfree(kbd_dev);\n\n\thv_set_drvdata(hv_dev, NULL);\n}\n\nstatic int hv_kbd_suspend(struct hv_device *hv_dev)\n{\n\tvmbus_close(hv_dev->channel);\n\n\treturn 0;\n}\n\nstatic int hv_kbd_resume(struct hv_device *hv_dev)\n{\n\tint ret;\n\n\tret = vmbus_open(hv_dev->channel,\n\t\t\t KBD_VSC_SEND_RING_BUFFER_SIZE,\n\t\t\t KBD_VSC_RECV_RING_BUFFER_SIZE,\n\t\t\t NULL, 0,\n\t\t\t hv_kbd_on_channel_callback,\n\t\t\t hv_dev);\n\tif (ret == 0)\n\t\tret = hv_kbd_connect_to_vsp(hv_dev);\n\n\treturn ret;\n}\n\nstatic const struct hv_vmbus_device_id id_table[] = {\n\t \n\t{ HV_KBD_GUID, },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(vmbus, id_table);\n\nstatic struct  hv_driver hv_kbd_drv = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = id_table,\n\t.probe = hv_kbd_probe,\n\t.remove = hv_kbd_remove,\n\t.suspend = hv_kbd_suspend,\n\t.resume = hv_kbd_resume,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init hv_kbd_init(void)\n{\n\treturn vmbus_driver_register(&hv_kbd_drv);\n}\n\nstatic void __exit hv_kbd_exit(void)\n{\n\tvmbus_driver_unregister(&hv_kbd_drv);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Microsoft Hyper-V Synthetic Keyboard Driver\");\n\nmodule_init(hv_kbd_init);\nmodule_exit(hv_kbd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}