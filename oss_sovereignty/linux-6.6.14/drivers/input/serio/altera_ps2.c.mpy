{
  "module_name": "altera_ps2.c",
  "hash_id": "f45b944da13501c88ad53eb2c378970c80185473e534141b5fd316b8feffa7c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/serio/altera_ps2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#define DRV_NAME \"altera_ps2\"\n\nstruct ps2if {\n\tstruct serio *io;\n\tvoid __iomem *base;\n};\n\n \nstatic irqreturn_t altera_ps2_rxint(int irq, void *dev_id)\n{\n\tstruct ps2if *ps2if = dev_id;\n\tunsigned int status;\n\tirqreturn_t handled = IRQ_NONE;\n\n\twhile ((status = readl(ps2if->base)) & 0xffff0000) {\n\t\tserio_interrupt(ps2if->io, status & 0xff, 0);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\treturn handled;\n}\n\n \nstatic int altera_ps2_write(struct serio *io, unsigned char val)\n{\n\tstruct ps2if *ps2if = io->port_data;\n\n\twritel(val, ps2if->base);\n\treturn 0;\n}\n\nstatic int altera_ps2_open(struct serio *io)\n{\n\tstruct ps2if *ps2if = io->port_data;\n\n\t \n\twhile (readl(ps2if->base) & 0xffff0000)\n\t\t ;\n\n\twritel(1, ps2if->base + 4);  \n\treturn 0;\n}\n\nstatic void altera_ps2_close(struct serio *io)\n{\n\tstruct ps2if *ps2if = io->port_data;\n\n\twritel(0, ps2if->base + 4);  \n}\n\n \nstatic int altera_ps2_probe(struct platform_device *pdev)\n{\n\tstruct ps2if *ps2if;\n\tstruct serio *serio;\n\tint error, irq;\n\n\tps2if = devm_kzalloc(&pdev->dev, sizeof(struct ps2if), GFP_KERNEL);\n\tif (!ps2if)\n\t\treturn -ENOMEM;\n\n\tps2if->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(ps2if->base))\n\t\treturn PTR_ERR(ps2if->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\terror = devm_request_irq(&pdev->dev, irq, altera_ps2_rxint, 0,\n\t\t\t\t pdev->name, ps2if);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"could not request IRQ %d\\n\", irq);\n\t\treturn error;\n\t}\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= altera_ps2_write;\n\tserio->open\t\t= altera_ps2_open;\n\tserio->close\t\t= altera_ps2_close;\n\tstrscpy(serio->name, dev_name(&pdev->dev), sizeof(serio->name));\n\tstrscpy(serio->phys, dev_name(&pdev->dev), sizeof(serio->phys));\n\tserio->port_data\t= ps2if;\n\tserio->dev.parent\t= &pdev->dev;\n\tps2if->io\t\t= serio;\n\n\tdev_info(&pdev->dev, \"base %p, irq %d\\n\", ps2if->base, irq);\n\n\tserio_register_port(ps2if->io);\n\tplatform_set_drvdata(pdev, ps2if);\n\n\treturn 0;\n}\n\n \nstatic int altera_ps2_remove(struct platform_device *pdev)\n{\n\tstruct ps2if *ps2if = platform_get_drvdata(pdev);\n\n\tserio_unregister_port(ps2if->io);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id altera_ps2_match[] = {\n\t{ .compatible = \"ALTR,ps2-1.0\", },\n\t{ .compatible = \"altr,ps2-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_ps2_match);\n#endif  \n\n \nstatic struct platform_driver altera_ps2_driver = {\n\t.probe\t\t= altera_ps2_probe,\n\t.remove\t\t= altera_ps2_remove,\n\t.driver\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = of_match_ptr(altera_ps2_match),\n\t},\n};\nmodule_platform_driver(altera_ps2_driver);\n\nMODULE_DESCRIPTION(\"Altera University Program PS2 controller driver\");\nMODULE_AUTHOR(\"Thomas Chou <thomas@wytron.com.tw>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}