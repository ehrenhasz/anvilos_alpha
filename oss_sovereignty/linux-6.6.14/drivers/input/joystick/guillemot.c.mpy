{
  "module_name": "guillemot.c",
  "hash_id": "93647843a4f4b4b03dc673af758070f283c66eaa737891390151cf7cbd9e3c04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/guillemot.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Guillemot Digital joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define GUILLEMOT_MAX_START\t600\t \n#define GUILLEMOT_MAX_STROBE\t60\t \n#define GUILLEMOT_MAX_LENGTH\t17\t \n\nstatic short guillemot_abs_pad[] =\n\t{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER, -1 };\n\nstatic short guillemot_btn_pad[] =\n\t{ BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_TL, BTN_TR, BTN_MODE, BTN_SELECT, -1 };\n\nstatic struct {\n        int x;\n        int y;\n} guillemot_hat_to_axis[16] = {{ 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};\n\nstruct guillemot_type {\n\tunsigned char id;\n\tshort *abs;\n\tshort *btn;\n\tint hat;\n\tchar *name;\n};\n\nstruct guillemot {\n\tstruct gameport *gameport;\n\tstruct input_dev *dev;\n\tint bads;\n\tint reads;\n\tstruct guillemot_type *type;\n\tunsigned char length;\n\tchar phys[32];\n};\n\nstatic struct guillemot_type guillemot_type[] = {\n\t{ 0x00, guillemot_abs_pad, guillemot_btn_pad, 1, \"Guillemot Pad\" },\n\t{ 0 }};\n\n \n\nstatic int guillemot_read_packet(struct gameport *gameport, u8 *data)\n{\n\tunsigned long flags;\n\tunsigned char u, v;\n\tunsigned int t, s;\n\tint i;\n\n\tfor (i = 0; i < GUILLEMOT_MAX_LENGTH; i++)\n\t\tdata[i] = 0;\n\n\ti = 0;\n\tt = gameport_time(gameport, GUILLEMOT_MAX_START);\n\ts = gameport_time(gameport, GUILLEMOT_MAX_STROBE);\n\n\tlocal_irq_save(flags);\n\tgameport_trigger(gameport);\n\tv = gameport_read(gameport);\n\n\twhile (t > 0 && i < GUILLEMOT_MAX_LENGTH * 8) {\n\t\tt--;\n\t\tu = v; v = gameport_read(gameport);\n\t\tif (v & ~u & 0x10) {\n\t\t\tdata[i >> 3] |= ((v >> 5) & 1) << (i & 7);\n\t\t\ti++;\n\t\t\tt = s;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn i;\n}\n\n \n\nstatic void guillemot_poll(struct gameport *gameport)\n{\n\tstruct guillemot *guillemot = gameport_get_drvdata(gameport);\n\tstruct input_dev *dev = guillemot->dev;\n\tu8 data[GUILLEMOT_MAX_LENGTH];\n\tint i;\n\n\tguillemot->reads++;\n\n\tif (guillemot_read_packet(guillemot->gameport, data) != GUILLEMOT_MAX_LENGTH * 8 ||\n\t\tdata[0] != 0x55 || data[16] != 0xaa) {\n\t\tguillemot->bads++;\n\t} else {\n\n\t\tfor (i = 0; i < 6 && guillemot->type->abs[i] >= 0; i++)\n\t\t\tinput_report_abs(dev, guillemot->type->abs[i], data[i + 5]);\n\n\t\tif (guillemot->type->hat) {\n\t\t\tinput_report_abs(dev, ABS_HAT0X, guillemot_hat_to_axis[data[4] >> 4].x);\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, guillemot_hat_to_axis[data[4] >> 4].y);\n\t\t}\n\n\t\tfor (i = 0; i < 16 && guillemot->type->btn[i] >= 0; i++)\n\t\t\tinput_report_key(dev, guillemot->type->btn[i], (data[2 + (i >> 3)] >> (i & 7)) & 1);\n\t}\n\n\tinput_sync(dev);\n}\n\n \n\nstatic int guillemot_open(struct input_dev *dev)\n{\n\tstruct guillemot *guillemot = input_get_drvdata(dev);\n\n\tgameport_start_polling(guillemot->gameport);\n\treturn 0;\n}\n\n \n\nstatic void guillemot_close(struct input_dev *dev)\n{\n\tstruct guillemot *guillemot = input_get_drvdata(dev);\n\n\tgameport_stop_polling(guillemot->gameport);\n}\n\n \n\nstatic int guillemot_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct guillemot *guillemot;\n\tstruct input_dev *input_dev;\n\tu8 data[GUILLEMOT_MAX_LENGTH];\n\tint i, t;\n\tint err;\n\n\tguillemot = kzalloc(sizeof(struct guillemot), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!guillemot || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tguillemot->gameport = gameport;\n\tguillemot->dev = input_dev;\n\n\tgameport_set_drvdata(gameport, guillemot);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\ti = guillemot_read_packet(gameport, data);\n\n\tif (i != GUILLEMOT_MAX_LENGTH * 8 || data[0] != 0x55 || data[16] != 0xaa) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tfor (i = 0; guillemot_type[i].name; i++)\n\t\tif (guillemot_type[i].id == data[11])\n\t\t\tbreak;\n\n\tif (!guillemot_type[i].name) {\n\t\tprintk(KERN_WARNING \"guillemot.c: Unknown joystick on %s. [ %02x%02x:%04x, ver %d.%02d ]\\n\",\n\t\t\tgameport->phys, data[12], data[13], data[11], data[14], data[15]);\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, guillemot_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tsnprintf(guillemot->phys, sizeof(guillemot->phys), \"%s/input0\", gameport->phys);\n\tguillemot->type = guillemot_type + i;\n\n\tinput_dev->name = guillemot_type[i].name;\n\tinput_dev->phys = guillemot->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_GUILLEMOT;\n\tinput_dev->id.product = guillemot_type[i].id;\n\tinput_dev->id.version = (int)data[14] << 8 | data[15];\n\tinput_dev->dev.parent = &gameport->dev;\n\n\tinput_set_drvdata(input_dev, guillemot);\n\n\tinput_dev->open = guillemot_open;\n\tinput_dev->close = guillemot_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = 0; (t = guillemot->type->abs[i]) >= 0; i++)\n\t\tinput_set_abs_params(input_dev, t, 0, 255, 0, 0);\n\n\tif (guillemot->type->hat) {\n\t\tinput_set_abs_params(input_dev, ABS_HAT0X, -1, 1, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_HAT0Y, -1, 1, 0, 0);\n\t}\n\n\tfor (i = 0; (t = guillemot->type->btn[i]) >= 0; i++)\n\t\tset_bit(t, input_dev->keybit);\n\n\terr = input_register_device(guillemot->dev);\n\tif (err)\n\t\tgoto fail2;\n\n\treturn 0;\n\nfail2:\tgameport_close(gameport);\nfail1:  gameport_set_drvdata(gameport, NULL);\n\tinput_free_device(input_dev);\n\tkfree(guillemot);\n\treturn err;\n}\n\nstatic void guillemot_disconnect(struct gameport *gameport)\n{\n\tstruct guillemot *guillemot = gameport_get_drvdata(gameport);\n\n\tprintk(KERN_INFO \"guillemot.c: Failed %d reads out of %d on %s\\n\", guillemot->reads, guillemot->bads, guillemot->phys);\n\tinput_unregister_device(guillemot->dev);\n\tgameport_close(gameport);\n\tkfree(guillemot);\n}\n\nstatic struct gameport_driver guillemot_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"guillemot\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= guillemot_connect,\n\t.disconnect\t= guillemot_disconnect,\n};\n\nmodule_gameport_driver(guillemot_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}