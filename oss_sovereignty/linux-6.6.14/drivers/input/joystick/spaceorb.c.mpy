{
  "module_name": "spaceorb.c",
  "hash_id": "811e71cec9b6e7281eb376a22eec7e0fd25ad9b26741dfd723d4dcc633c78f53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/spaceorb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"SpaceTec SpaceOrb 360 and Avenger 6dof controller driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define SPACEORB_MAX_LENGTH\t64\n\nstatic int spaceorb_buttons[] = { BTN_TL, BTN_TR, BTN_Y, BTN_X, BTN_B, BTN_A };\nstatic int spaceorb_axes[] = { ABS_X, ABS_Y, ABS_Z, ABS_RX, ABS_RY, ABS_RZ };\n\n \n\nstruct spaceorb {\n\tstruct input_dev *dev;\n\tint idx;\n\tunsigned char data[SPACEORB_MAX_LENGTH];\n\tchar phys[32];\n};\n\nstatic unsigned char spaceorb_xor[] = \"SpaceWare\";\n\nstatic unsigned char *spaceorb_errors[] = { \"EEPROM storing 0 failed\", \"Receive queue overflow\", \"Transmit queue timeout\",\n\t\t\"Bad packet\", \"Power brown-out\", \"EEPROM checksum error\", \"Hardware fault\" };\n\n \n\nstatic void spaceorb_process_packet(struct spaceorb *spaceorb)\n{\n\tstruct input_dev *dev = spaceorb->dev;\n\tunsigned char *data = spaceorb->data;\n\tunsigned char c = 0;\n\tint axes[6];\n\tint i;\n\n\tif (spaceorb->idx < 2) return;\n\tfor (i = 0; i < spaceorb->idx; i++) c ^= data[i];\n\tif (c) return;\n\n\tswitch (data[0]) {\n\n\t\tcase 'R':\t\t\t\t \n\t\t\tspaceorb->data[spaceorb->idx - 1] = 0;\n\t\t\tfor (i = 1; i < spaceorb->idx && spaceorb->data[i] == ' '; i++);\n\t\t\tprintk(KERN_INFO \"input: %s [%s] is %s\\n\",\n\t\t\t\t dev->name, spaceorb->data + i, spaceorb->phys);\n\t\t\tbreak;\n\n\t\tcase 'D':\t\t\t\t \n\t\t\tif (spaceorb->idx != 12) return;\n\t\t\tfor (i = 0; i < 9; i++) spaceorb->data[i+2] ^= spaceorb_xor[i];\n\t\t\taxes[0] = ( data[2]\t << 3) | (data[ 3] >> 4);\n\t\t\taxes[1] = ((data[3] & 0x0f) << 6) | (data[ 4] >> 1);\n\t\t\taxes[2] = ((data[4] & 0x01) << 9) | (data[ 5] << 2) | (data[4] >> 5);\n\t\t\taxes[3] = ((data[6] & 0x1f) << 5) | (data[ 7] >> 2);\n\t\t\taxes[4] = ((data[7] & 0x03) << 8) | (data[ 8] << 1) | (data[7] >> 6);\n\t\t\taxes[5] = ((data[9] & 0x3f) << 4) | (data[10] >> 3);\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tinput_report_abs(dev, spaceorb_axes[i], axes[i] - ((axes[i] & 0x200) ? 1024 : 0));\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tinput_report_key(dev, spaceorb_buttons[i], (data[1] >> i) & 1);\n\t\t\tbreak;\n\n\t\tcase 'K':\t\t\t\t \n\t\t\tif (spaceorb->idx != 5) return;\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tinput_report_key(dev, spaceorb_buttons[i], (data[2] >> i) & 1);\n\n\t\t\tbreak;\n\n\t\tcase 'E':\t\t\t\t \n\t\t\tif (spaceorb->idx != 4) return;\n\t\t\tprintk(KERN_ERR \"spaceorb: Device error. [ \");\n\t\t\tfor (i = 0; i < 7; i++) if (data[1] & (1 << i)) printk(\"%s \", spaceorb_errors[i]);\n\t\t\tprintk(\"]\\n\");\n\t\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n}\n\nstatic irqreturn_t spaceorb_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct spaceorb* spaceorb = serio_get_drvdata(serio);\n\n\tif (~data & 0x80) {\n\t\tif (spaceorb->idx) spaceorb_process_packet(spaceorb);\n\t\tspaceorb->idx = 0;\n\t}\n\tif (spaceorb->idx < SPACEORB_MAX_LENGTH)\n\t\tspaceorb->data[spaceorb->idx++] = data & 0x7f;\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void spaceorb_disconnect(struct serio *serio)\n{\n\tstruct spaceorb* spaceorb = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(spaceorb->dev);\n\tkfree(spaceorb);\n}\n\n \n\nstatic int spaceorb_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct spaceorb *spaceorb;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tspaceorb = kzalloc(sizeof(struct spaceorb), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!spaceorb || !input_dev)\n\t\tgoto fail1;\n\n\tspaceorb->dev = input_dev;\n\tsnprintf(spaceorb->phys, sizeof(spaceorb->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"SpaceTec SpaceOrb 360 / Avenger\";\n\tinput_dev->phys = spaceorb->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_SPACEORB;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = 0; i < 6; i++)\n\t\tset_bit(spaceorb_buttons[i], input_dev->keybit);\n\n\tfor (i = 0; i < 6; i++)\n\t\tinput_set_abs_params(input_dev, spaceorb_axes[i], -508, 508, 0, 0);\n\n\tserio_set_drvdata(serio, spaceorb);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(spaceorb->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(spaceorb);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id spaceorb_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_SPACEORB,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, spaceorb_serio_ids);\n\nstatic struct serio_driver spaceorb_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"spaceorb\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= spaceorb_serio_ids,\n\t.interrupt\t= spaceorb_interrupt,\n\t.connect\t= spaceorb_connect,\n\t.disconnect\t= spaceorb_disconnect,\n};\n\nmodule_serio_driver(spaceorb_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}