{
  "module_name": "adc-joystick.c",
  "hash_id": "38413a290b8de0fa04da76aee169f879a65dbd449224bc73cf08c75090d439f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/adc-joystick.c",
  "human_readable_source": "\n \n#include <linux/ctype.h>\n#include <linux/input.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/consumer.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include <asm/unaligned.h>\n\nstruct adc_joystick_axis {\n\tu32 code;\n\ts32 range[2];\n\ts32 fuzz;\n\ts32 flat;\n};\n\nstruct adc_joystick {\n\tstruct input_dev *input;\n\tstruct iio_cb_buffer *buffer;\n\tstruct adc_joystick_axis *axes;\n\tstruct iio_channel *chans;\n\tint num_chans;\n\tbool polled;\n};\n\nstatic void adc_joystick_poll(struct input_dev *input)\n{\n\tstruct adc_joystick *joy = input_get_drvdata(input);\n\tint i, val, ret;\n\n\tfor (i = 0; i < joy->num_chans; i++) {\n\t\tret = iio_read_channel_raw(&joy->chans[i], &val);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t\tinput_report_abs(input, joy->axes[i].code, val);\n\t}\n\tinput_sync(input);\n}\n\nstatic int adc_joystick_handle(const void *data, void *private)\n{\n\tstruct adc_joystick *joy = private;\n\tenum iio_endian endianness;\n\tint bytes, msb, val, idx, i;\n\tconst u16 *data_u16;\n\tbool sign;\n\n\tbytes = joy->chans[0].channel->scan_type.storagebits >> 3;\n\n\tfor (i = 0; i < joy->num_chans; ++i) {\n\t\tidx = joy->chans[i].channel->scan_index;\n\t\tendianness = joy->chans[i].channel->scan_type.endianness;\n\t\tmsb = joy->chans[i].channel->scan_type.realbits - 1;\n\t\tsign = tolower(joy->chans[i].channel->scan_type.sign) == 's';\n\n\t\tswitch (bytes) {\n\t\tcase 1:\n\t\t\tval = ((const u8 *)data)[idx];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata_u16 = (const u16 *)data + idx;\n\n\t\t\t \n\t\t\tif (endianness == IIO_BE)\n\t\t\t\tval = get_unaligned_be16(data_u16);\n\t\t\telse if (endianness == IIO_LE)\n\t\t\t\tval = get_unaligned_le16(data_u16);\n\t\t\telse  \n\t\t\t\tval = *data_u16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval >>= joy->chans[i].channel->scan_type.shift;\n\t\tif (sign)\n\t\t\tval = sign_extend32(val, msb);\n\t\telse\n\t\t\tval &= GENMASK(msb, 0);\n\t\tinput_report_abs(joy->input, joy->axes[i].code, val);\n\t}\n\n\tinput_sync(joy->input);\n\n\treturn 0;\n}\n\nstatic int adc_joystick_open(struct input_dev *dev)\n{\n\tstruct adc_joystick *joy = input_get_drvdata(dev);\n\tstruct device *devp = &dev->dev;\n\tint ret;\n\n\tret = iio_channel_start_all_cb(joy->buffer);\n\tif (ret)\n\t\tdev_err(devp, \"Unable to start callback buffer: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void adc_joystick_close(struct input_dev *dev)\n{\n\tstruct adc_joystick *joy = input_get_drvdata(dev);\n\n\tiio_channel_stop_all_cb(joy->buffer);\n}\n\nstatic void adc_joystick_cleanup(void *data)\n{\n\tiio_channel_release_all_cb(data);\n}\n\nstatic int adc_joystick_set_axes(struct device *dev, struct adc_joystick *joy)\n{\n\tstruct adc_joystick_axis *axes;\n\tstruct fwnode_handle *child;\n\tint num_axes, error, i;\n\n\tnum_axes = device_get_child_node_count(dev);\n\tif (!num_axes) {\n\t\tdev_err(dev, \"Unable to find child nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_axes != joy->num_chans) {\n\t\tdev_err(dev, \"Got %d child nodes for %d channels\\n\",\n\t\t\tnum_axes, joy->num_chans);\n\t\treturn -EINVAL;\n\t}\n\n\taxes = devm_kmalloc_array(dev, num_axes, sizeof(*axes), GFP_KERNEL);\n\tif (!axes)\n\t\treturn -ENOMEM;\n\n\tdevice_for_each_child_node(dev, child) {\n\t\terror = fwnode_property_read_u32(child, \"reg\", &i);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"reg invalid or missing\\n\");\n\t\t\tgoto err_fwnode_put;\n\t\t}\n\n\t\tif (i >= num_axes) {\n\t\t\terror = -EINVAL;\n\t\t\tdev_err(dev, \"No matching axis for reg %d\\n\", i);\n\t\t\tgoto err_fwnode_put;\n\t\t}\n\n\t\terror = fwnode_property_read_u32(child, \"linux,code\",\n\t\t\t\t\t\t &axes[i].code);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"linux,code invalid or missing\\n\");\n\t\t\tgoto err_fwnode_put;\n\t\t}\n\n\t\terror = fwnode_property_read_u32_array(child, \"abs-range\",\n\t\t\t\t\t\t       axes[i].range, 2);\n\t\tif (error) {\n\t\t\tdev_err(dev, \"abs-range invalid or missing\\n\");\n\t\t\tgoto err_fwnode_put;\n\t\t}\n\n\t\tfwnode_property_read_u32(child, \"abs-fuzz\", &axes[i].fuzz);\n\t\tfwnode_property_read_u32(child, \"abs-flat\", &axes[i].flat);\n\n\t\tinput_set_abs_params(joy->input, axes[i].code,\n\t\t\t\t     axes[i].range[0], axes[i].range[1],\n\t\t\t\t     axes[i].fuzz, axes[i].flat);\n\t\tinput_set_capability(joy->input, EV_ABS, axes[i].code);\n\t}\n\n\tjoy->axes = axes;\n\n\treturn 0;\n\nerr_fwnode_put:\n\tfwnode_handle_put(child);\n\treturn error;\n}\n\nstatic int adc_joystick_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct adc_joystick *joy;\n\tstruct input_dev *input;\n\tint error;\n\tint bits;\n\tint i;\n\tunsigned int poll_interval;\n\n\tjoy = devm_kzalloc(dev, sizeof(*joy), GFP_KERNEL);\n\tif (!joy)\n\t\treturn -ENOMEM;\n\n\tjoy->chans = devm_iio_channel_get_all(dev);\n\tif (IS_ERR(joy->chans)) {\n\t\terror = PTR_ERR(joy->chans);\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Unable to get IIO channels\");\n\t\treturn error;\n\t}\n\n\terror = device_property_read_u32(dev, \"poll-interval\", &poll_interval);\n\tif (error) {\n\t\t \n\t\tif (error != -EINVAL)\n\t\t\treturn error;\n\t} else if (poll_interval == 0) {\n\t\tdev_err(dev, \"Unable to get poll-interval\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tjoy->polled = true;\n\t}\n\n\t \n\tfor (i = 0; joy->chans[i].indio_dev; i++) {\n\t\tif (joy->polled)\n\t\t\tcontinue;\n\t\tbits = joy->chans[i].channel->scan_type.storagebits;\n\t\tif (!bits || bits > 16) {\n\t\t\tdev_err(dev, \"Unsupported channel storage size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (bits != joy->chans[0].channel->scan_type.storagebits) {\n\t\t\tdev_err(dev, \"Channels must have equal storage size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tjoy->num_chans = i;\n\n\tinput = devm_input_allocate_device(dev);\n\tif (!input) {\n\t\tdev_err(dev, \"Unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tjoy->input = input;\n\tinput->name = pdev->name;\n\tinput->id.bustype = BUS_HOST;\n\n\terror = adc_joystick_set_axes(dev, joy);\n\tif (error)\n\t\treturn error;\n\n\tif (joy->polled) {\n\t\tinput_setup_polling(input, adc_joystick_poll);\n\t\tinput_set_poll_interval(input, poll_interval);\n\t} else {\n\t\tinput->open = adc_joystick_open;\n\t\tinput->close = adc_joystick_close;\n\n\t\tjoy->buffer = iio_channel_get_all_cb(dev, adc_joystick_handle,\n\t\t\t\t\t\t     joy);\n\t\tif (IS_ERR(joy->buffer)) {\n\t\t\tdev_err(dev, \"Unable to allocate callback buffer\\n\");\n\t\t\treturn PTR_ERR(joy->buffer);\n\t\t}\n\n\t\terror = devm_add_action_or_reset(dev, adc_joystick_cleanup,\n\t\t\t\t\t\t joy->buffer);\n\t\tif (error)  {\n\t\t\tdev_err(dev, \"Unable to add action\\n\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tinput_set_drvdata(input, joy);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(dev, \"Unable to register input device\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id adc_joystick_of_match[] = {\n\t{ .compatible = \"adc-joystick\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adc_joystick_of_match);\n\nstatic struct platform_driver adc_joystick_driver = {\n\t.driver = {\n\t\t.name = \"adc-joystick\",\n\t\t.of_match_table = adc_joystick_of_match,\n\t},\n\t.probe = adc_joystick_probe,\n};\nmodule_platform_driver(adc_joystick_driver);\n\nMODULE_DESCRIPTION(\"Input driver for joysticks connected over ADC\");\nMODULE_AUTHOR(\"Artur Rojek <contact@artur-rojek.eu>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}