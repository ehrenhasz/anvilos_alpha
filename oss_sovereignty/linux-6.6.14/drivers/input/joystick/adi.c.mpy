{
  "module_name": "adi.c",
  "hash_id": "84a5f53ddd7deb3e1c3a7fc7f98bb678a9d165aec4e92e39fd414cfb7f4917fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/adi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/gameport.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Logitech ADI joystick family driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define ADI_MAX_START\t\t200\t \n#define ADI_MAX_STROBE\t\t40\t \n#define ADI_INIT_DELAY\t\t10\t \n#define ADI_DATA_DELAY\t\t4\t \n\n#define ADI_MAX_LENGTH\t\t256\n#define ADI_MIN_LENGTH\t\t8\n#define ADI_MIN_LEN_LENGTH\t10\n#define ADI_MIN_ID_LENGTH\t66\n#define ADI_MAX_NAME_LENGTH\t64\n#define ADI_MAX_CNAME_LENGTH\t16\n#define ADI_MAX_PHYS_LENGTH\t64\n\n#define ADI_FLAG_HAT\t\t0x04\n#define ADI_FLAG_10BIT\t\t0x08\n\n#define ADI_ID_TPD\t\t0x01\n#define ADI_ID_WGP\t\t0x06\n#define ADI_ID_WGPE\t\t0x08\n#define ADI_ID_MAX\t\t0x0a\n\n \n\nstatic char *adi_names[] = {\t\"WingMan Extreme Digital\", \"ThunderPad Digital\", \"SideCar\", \"CyberMan 2\",\n\t\t\t\t\"WingMan Interceptor\", \"WingMan Formula\", \"WingMan GamePad\",\n\t\t\t\t\"WingMan Extreme Digital 3D\", \"WingMan GamePad Extreme\",\n\t\t\t\t\"WingMan GamePad USB\", \"Unknown Device %#x\" };\n\nstatic char adi_wmgpe_abs[] =\t{ ABS_X, ABS_Y, ABS_HAT0X, ABS_HAT0Y };\nstatic char adi_wmi_abs[] =\t{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, ABS_HAT1X, ABS_HAT1Y, ABS_HAT2X, ABS_HAT2Y };\nstatic char adi_wmed3d_abs[] =\t{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_RZ, ABS_HAT0X, ABS_HAT0Y };\nstatic char adi_cm2_abs[] =\t{ ABS_X, ABS_Y, ABS_Z, ABS_RX, ABS_RY, ABS_RZ };\nstatic char adi_wmf_abs[] =\t{ ABS_WHEEL, ABS_GAS, ABS_BRAKE, ABS_HAT0X, ABS_HAT0Y, ABS_HAT1X, ABS_HAT1Y, ABS_HAT2X, ABS_HAT2Y };\n\nstatic short adi_wmgpe_key[] =\t{ BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z,  BTN_TL, BTN_TR, BTN_START, BTN_MODE, BTN_SELECT };\nstatic short adi_wmi_key[] =\t{ BTN_TRIGGER,  BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_EXTRA };\nstatic short adi_wmed3d_key[] =\t{ BTN_TRIGGER, BTN_THUMB, BTN_THUMB2, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2 };\nstatic short adi_cm2_key[] =\t{ BTN_1, BTN_2, BTN_3, BTN_4, BTN_5, BTN_6, BTN_7, BTN_8 };\n\nstatic char* adi_abs[] = { adi_wmi_abs, adi_wmgpe_abs, adi_wmf_abs, adi_cm2_abs, adi_wmi_abs, adi_wmf_abs,\n\t\t\t   adi_wmgpe_abs, adi_wmed3d_abs, adi_wmgpe_abs, adi_wmgpe_abs, adi_wmi_abs };\n\nstatic short* adi_key[] = { adi_wmi_key, adi_wmgpe_key, adi_cm2_key, adi_cm2_key, adi_wmi_key, adi_cm2_key,\n\t\t\t    adi_wmgpe_key, adi_wmed3d_key, adi_wmgpe_key, adi_wmgpe_key, adi_wmi_key };\n\n \n\nstatic struct {\n\tint x;\n\tint y;\n} adi_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};\n\n \n\nstruct adi {\n\tstruct input_dev *dev;\n\tint length;\n\tint ret;\n\tint idx;\n\tunsigned char id;\n\tchar buttons;\n\tchar axes10;\n\tchar axes8;\n\tsigned char pad;\n\tchar hats;\n\tchar *abs;\n\tshort *key;\n\tchar name[ADI_MAX_NAME_LENGTH];\n\tchar cname[ADI_MAX_CNAME_LENGTH];\n\tchar phys[ADI_MAX_PHYS_LENGTH];\n\tunsigned char data[ADI_MAX_LENGTH];\n};\n\nstruct adi_port {\n\tstruct gameport *gameport;\n\tstruct adi adi[2];\n\tint bad;\n\tint reads;\n};\n\n \n\nstatic void adi_read_packet(struct adi_port *port)\n{\n\tstruct adi *adi = port->adi;\n\tstruct gameport *gameport = port->gameport;\n\tunsigned char u, v, w, x;\n\tint t[2], s[2], i;\n\tunsigned long flags;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tadi[i].ret = -1;\n\t\tt[i] = gameport_time(gameport, ADI_MAX_START);\n\t\ts[i] = 0;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tgameport_trigger(gameport);\n\tv = gameport_read(gameport);\n\n\tdo {\n\t\tu = v;\n\t\tw = u ^ (v = x = gameport_read(gameport));\n\t\tfor (i = 0; i < 2; i++, w >>= 2, x >>= 2) {\n\t\t\tt[i]--;\n\t\t\tif ((w & 0x30) && s[i]) {\n\t\t\t\tif ((w & 0x30) < 0x30 && adi[i].ret < ADI_MAX_LENGTH && t[i] > 0) {\n\t\t\t\t\tadi[i].data[++adi[i].ret] = w;\n\t\t\t\t\tt[i] = gameport_time(gameport, ADI_MAX_STROBE);\n\t\t\t\t} else t[i] = 0;\n\t\t\t} else if (!(x & 0x30)) s[i] = 1;\n\t\t}\n\t} while (t[0] > 0 || t[1] > 0);\n\n\tlocal_irq_restore(flags);\n\n\treturn;\n}\n\n \n\nstatic void adi_move_bits(struct adi_port *port, int length)\n{\n\tint i;\n\tstruct adi *adi = port->adi;\n\n\tadi[0].idx = adi[1].idx = 0;\n\n\tif (adi[0].ret <= 0 || adi[1].ret <= 0) return;\n\tif (adi[0].data[0] & 0x20 || ~adi[1].data[0] & 0x20) return;\n\n\tfor (i = 1; i <= adi[1].ret; i++)\n\t\tadi[0].data[((length - 1) >> 1) + i + 1] = adi[1].data[i];\n\n\tadi[0].ret += adi[1].ret;\n\tadi[1].ret = -1;\n}\n\n \n\nstatic inline int adi_get_bits(struct adi *adi, int count)\n{\n\tint bits = 0;\n\tint i;\n\tif ((adi->idx += count) > adi->ret) return 0;\n\tfor (i = 0; i < count; i++)\n\t\tbits |= ((adi->data[adi->idx - i] >> 5) & 1) << i;\n\treturn bits;\n}\n\n \n\nstatic int adi_decode(struct adi *adi)\n{\n\tstruct input_dev *dev = adi->dev;\n\tchar *abs = adi->abs;\n\tshort *key = adi->key;\n\tint i, t;\n\n\tif (adi->ret < adi->length || adi->id != (adi_get_bits(adi, 4) | (adi_get_bits(adi, 4) << 4)))\n\t\treturn -1;\n\n\tfor (i = 0; i < adi->axes10; i++)\n\t\tinput_report_abs(dev, *abs++, adi_get_bits(adi, 10));\n\n\tfor (i = 0; i < adi->axes8; i++)\n\t\tinput_report_abs(dev, *abs++, adi_get_bits(adi, 8));\n\n\tfor (i = 0; i < adi->buttons && i < 63; i++) {\n\t\tif (i == adi->pad) {\n\t\t\tt = adi_get_bits(adi, 4);\n\t\t\tinput_report_abs(dev, *abs++, ((t >> 2) & 1) - ( t       & 1));\n\t\t\tinput_report_abs(dev, *abs++, ((t >> 1) & 1) - ((t >> 3) & 1));\n\t\t}\n\t\tinput_report_key(dev, *key++, adi_get_bits(adi, 1));\n\t}\n\n\tfor (i = 0; i < adi->hats; i++) {\n\t\tif ((t = adi_get_bits(adi, 4)) > 8) t = 0;\n\t\tinput_report_abs(dev, *abs++, adi_hat_to_axis[t].x);\n\t\tinput_report_abs(dev, *abs++, adi_hat_to_axis[t].y);\n\t}\n\n\tfor (i = 63; i < adi->buttons; i++)\n\t\tinput_report_key(dev, *key++, adi_get_bits(adi, 1));\n\n\tinput_sync(dev);\n\n\treturn 0;\n}\n\n \n\nstatic int adi_read(struct adi_port *port)\n{\n\tint i;\n\tint result = 0;\n\n\tadi_read_packet(port);\n\tadi_move_bits(port, port->adi[0].length);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (port->adi[i].length)\n\t\t\t result |= adi_decode(port->adi + i);\n\n\treturn result;\n}\n\n \n\nstatic void adi_poll(struct gameport *gameport)\n{\n\tstruct adi_port *port = gameport_get_drvdata(gameport);\n\n\tport->bad -= adi_read(port);\n\tport->reads++;\n}\n\n \n\nstatic int adi_open(struct input_dev *dev)\n{\n\tstruct adi_port *port = input_get_drvdata(dev);\n\n\tgameport_start_polling(port->gameport);\n\treturn 0;\n}\n\n \n\nstatic void adi_close(struct input_dev *dev)\n{\n\tstruct adi_port *port = input_get_drvdata(dev);\n\n\tgameport_stop_polling(port->gameport);\n}\n\n \n\nstatic void adi_init_digital(struct gameport *gameport)\n{\n\tstatic const int seq[] = { 4, -2, -3, 10, -6, -11, -7, -9, 11, 0 };\n\tint i;\n\n\tfor (i = 0; seq[i]; i++) {\n\t\tgameport_trigger(gameport);\n\t\tif (seq[i] > 0)\n\t\t\tmsleep(seq[i]);\n\t\tif (seq[i] < 0) {\n\t\t\tmdelay(-seq[i]);\n\t\t\tudelay(-seq[i]*14);\t \n\t\t}\n\t}\n}\n\nstatic void adi_id_decode(struct adi *adi, struct adi_port *port)\n{\n\tint i, t;\n\n\tif (adi->ret < ADI_MIN_ID_LENGTH)  \n\t\treturn;\n\n\tif (adi->ret < (t = adi_get_bits(adi, 10))) {\n\t\tprintk(KERN_WARNING \"adi: Short ID packet: reported: %d != read: %d\\n\", t, adi->ret);\n\t\treturn;\n\t}\n\n\tadi->id = adi_get_bits(adi, 4) | (adi_get_bits(adi, 4) << 4);\n\n\tif ((t = adi_get_bits(adi, 4)) & ADI_FLAG_HAT) adi->hats++;\n\n\tadi->length = adi_get_bits(adi, 10);\n\n\tif (adi->length >= ADI_MAX_LENGTH || adi->length < ADI_MIN_LENGTH) {\n\t\tprintk(KERN_WARNING \"adi: Bad data packet length (%d).\\n\", adi->length);\n\t\tadi->length = 0;\n\t\treturn;\n\t}\n\n\tadi->axes8 = adi_get_bits(adi, 4);\n\tadi->buttons = adi_get_bits(adi, 6);\n\n\tif (adi_get_bits(adi, 6) != 8 && adi->hats) {\n\t\tprintk(KERN_WARNING \"adi: Other than 8-dir POVs not supported yet.\\n\");\n\t\tadi->length = 0;\n\t\treturn;\n\t}\n\n\tadi->buttons += adi_get_bits(adi, 6);\n\tadi->hats += adi_get_bits(adi, 4);\n\n\ti = adi_get_bits(adi, 4);\n\n\tif (t & ADI_FLAG_10BIT) {\n\t\tadi->axes10 = adi->axes8 - i;\n\t\tadi->axes8 = i;\n\t}\n\n\tt = adi_get_bits(adi, 4);\n\n\tfor (i = 0; i < t; i++)\n\t\tadi->cname[i] = adi_get_bits(adi, 8);\n\tadi->cname[i] = 0;\n\n\tt = 8 + adi->buttons + adi->axes10 * 10 + adi->axes8 * 8 + adi->hats * 4;\n\tif (adi->length != t && adi->length != t + (t & 1)) {\n\t\tprintk(KERN_WARNING \"adi: Expected length %d != data length %d\\n\", t, adi->length);\n\t\tadi->length = 0;\n\t\treturn;\n\t}\n\n\tswitch (adi->id) {\n\t\tcase ADI_ID_TPD:\n\t\t\tadi->pad = 4;\n\t\t\tadi->buttons -= 4;\n\t\t\tbreak;\n\t\tcase ADI_ID_WGP:\n\t\t\tadi->pad = 0;\n\t\t\tadi->buttons -= 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tadi->pad = -1;\n\t\t\tbreak;\n\t}\n}\n\nstatic int adi_init_input(struct adi *adi, struct adi_port *port, int half)\n{\n\tstruct input_dev *input_dev;\n\tchar buf[ADI_MAX_NAME_LENGTH];\n\tint i, t;\n\n\tadi->dev = input_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tt = adi->id < ADI_ID_MAX ? adi->id : ADI_ID_MAX;\n\n\tsnprintf(buf, ADI_MAX_PHYS_LENGTH, adi_names[t], adi->id);\n\tsnprintf(adi->name, ADI_MAX_NAME_LENGTH, \"Logitech %s [%s]\", buf, adi->cname);\n\tsnprintf(adi->phys, ADI_MAX_PHYS_LENGTH, \"%s/input%d\", port->gameport->phys, half);\n\n\tadi->abs = adi_abs[t];\n\tadi->key = adi_key[t];\n\n\tinput_dev->name = adi->name;\n\tinput_dev->phys = adi->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_LOGITECH;\n\tinput_dev->id.product = adi->id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &port->gameport->dev;\n\n\tinput_set_drvdata(input_dev, port);\n\n\tinput_dev->open = adi_open;\n\tinput_dev->close = adi_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = 0; i < adi->axes10 + adi->axes8 + (adi->hats + (adi->pad != -1)) * 2; i++)\n\t\tset_bit(adi->abs[i], input_dev->absbit);\n\n\tfor (i = 0; i < adi->buttons; i++)\n\t\tset_bit(adi->key[i], input_dev->keybit);\n\n\treturn 0;\n}\n\nstatic void adi_init_center(struct adi *adi)\n{\n\tint i, t, x;\n\n\tif (!adi->length)\n\t\treturn;\n\n\tfor (i = 0; i < adi->axes10 + adi->axes8 + (adi->hats + (adi->pad != -1)) * 2; i++) {\n\n\t\tt = adi->abs[i];\n\t\tx = input_abs_get_val(adi->dev, t);\n\n\t\tif (t == ABS_THROTTLE || t == ABS_RUDDER || adi->id == ADI_ID_WGPE)\n\t\t\tx = i < adi->axes10 ? 512 : 128;\n\n\t\tif (i < adi->axes10)\n\t\t\tinput_set_abs_params(adi->dev, t, 64, x * 2 - 64, 2, 16);\n\t\telse if (i < adi->axes10 + adi->axes8)\n\t\t\tinput_set_abs_params(adi->dev, t, 48, x * 2 - 48, 1, 16);\n\t\telse\n\t\t\tinput_set_abs_params(adi->dev, t, -1, 1, 0, 0);\n\t}\n}\n\n \n\nstatic int adi_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct adi_port *port;\n\tint i;\n\tint err;\n\n\tport = kzalloc(sizeof(struct adi_port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, port);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tadi_init_digital(gameport);\n\tadi_read_packet(port);\n\n\tif (port->adi[0].ret >= ADI_MIN_LEN_LENGTH)\n\t\tadi_move_bits(port, adi_get_bits(port->adi, 10));\n\n\tfor (i = 0; i < 2; i++) {\n\t\tadi_id_decode(port->adi + i, port);\n\n\t\tif (!port->adi[i].length)\n\t\t\tcontinue;\n\n\t\terr = adi_init_input(port->adi + i, port, i);\n\t\tif (err)\n\t\t\tgoto fail2;\n\t}\n\n\tif (!port->adi[0].length && !port->adi[1].length) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, adi_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tmsleep(ADI_INIT_DELAY);\n\tif (adi_read(port)) {\n\t\tmsleep(ADI_DATA_DELAY);\n\t\tadi_read(port);\n\t}\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (port->adi[i].length > 0) {\n\t\t\tadi_init_center(port->adi + i);\n\t\t\terr = input_register_device(port->adi[i].dev);\n\t\t\tif (err)\n\t\t\t\tgoto fail3;\n\t\t}\n\n\treturn 0;\n\n fail3: while (--i >= 0) {\n\t\tif (port->adi[i].length > 0) {\n\t\t\tinput_unregister_device(port->adi[i].dev);\n\t\t\tport->adi[i].dev = NULL;\n\t\t}\n\t}\n fail2:\tfor (i = 0; i < 2; i++)\n\t\tinput_free_device(port->adi[i].dev);\n\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(port);\n\treturn err;\n}\n\nstatic void adi_disconnect(struct gameport *gameport)\n{\n\tint i;\n\tstruct adi_port *port = gameport_get_drvdata(gameport);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (port->adi[i].length > 0)\n\t\t\tinput_unregister_device(port->adi[i].dev);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(port);\n}\n\nstatic struct gameport_driver adi_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"adi\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= adi_connect,\n\t.disconnect\t= adi_disconnect,\n};\n\nmodule_gameport_driver(adi_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}