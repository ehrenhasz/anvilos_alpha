{
  "module_name": "interact.c",
  "hash_id": "19a18fc3e3c92e40efb82062fb8e8d0a7bcf9629ac2359a96ba8abd012837be9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/interact.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"InterAct digital joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define INTERACT_MAX_START\t600\t \n#define INTERACT_MAX_STROBE\t60\t \n#define INTERACT_MAX_LENGTH\t32\t \n\n#define INTERACT_TYPE_HHFX\t0\t \n#define INTERACT_TYPE_PP8D\t1\t \n\nstruct interact {\n\tstruct gameport *gameport;\n\tstruct input_dev *dev;\n\tint bads;\n\tint reads;\n\tunsigned char type;\n\tunsigned char length;\n\tchar phys[32];\n};\n\nstatic short interact_abs_hhfx[] =\n\t{ ABS_RX, ABS_RY, ABS_X, ABS_Y, ABS_HAT0X, ABS_HAT0Y, -1 };\nstatic short interact_abs_pp8d[] =\n\t{ ABS_X, ABS_Y, -1 };\n\nstatic short interact_btn_hhfx[] =\n\t{ BTN_TR, BTN_X, BTN_Y, BTN_Z, BTN_A, BTN_B, BTN_C, BTN_TL, BTN_TL2, BTN_TR2, BTN_MODE, BTN_SELECT, -1 };\nstatic short interact_btn_pp8d[] =\n\t{ BTN_C, BTN_TL, BTN_TR, BTN_A, BTN_B, BTN_Y, BTN_Z, BTN_X, -1 };\n\nstruct interact_type {\n\tint id;\n\tshort *abs;\n\tshort *btn;\n\tchar *name;\n\tunsigned char length;\n\tunsigned char b8;\n};\n\nstatic struct interact_type interact_type[] = {\n\t{ 0x6202, interact_abs_hhfx, interact_btn_hhfx, \"InterAct HammerHead/FX\",    32, 4 },\n\t{ 0x53f8, interact_abs_pp8d, interact_btn_pp8d, \"InterAct ProPad 8 Digital\", 16, 0 },\n\t{ 0 }};\n\n \n\nstatic int interact_read_packet(struct gameport *gameport, int length, u32 *data)\n{\n\tunsigned long flags;\n\tunsigned char u, v;\n\tunsigned int t, s;\n\tint i;\n\n\ti = 0;\n\tdata[0] = data[1] = data[2] = 0;\n\tt = gameport_time(gameport, INTERACT_MAX_START);\n\ts = gameport_time(gameport, INTERACT_MAX_STROBE);\n\n\tlocal_irq_save(flags);\n\tgameport_trigger(gameport);\n\tv = gameport_read(gameport);\n\n\twhile (t > 0 && i < length) {\n\t\tt--;\n\t\tu = v; v = gameport_read(gameport);\n\t\tif (v & ~u & 0x40) {\n\t\t\tdata[0] = (data[0] << 1) | ((v >> 4) & 1);\n\t\t\tdata[1] = (data[1] << 1) | ((v >> 5) & 1);\n\t\t\tdata[2] = (data[2] << 1) | ((v >> 7) & 1);\n\t\t\ti++;\n\t\t\tt = s;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn i;\n}\n\n \n\nstatic void interact_poll(struct gameport *gameport)\n{\n\tstruct interact *interact = gameport_get_drvdata(gameport);\n\tstruct input_dev *dev = interact->dev;\n\tu32 data[3];\n\tint i;\n\n\tinteract->reads++;\n\n\tif (interact_read_packet(interact->gameport, interact->length, data) < interact->length) {\n\t\tinteract->bads++;\n\t} else {\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tdata[i] <<= INTERACT_MAX_LENGTH - interact->length;\n\n\t\tswitch (interact->type) {\n\n\t\t\tcase INTERACT_TYPE_HHFX:\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tinput_report_abs(dev, interact_abs_hhfx[i], (data[i & 1] >> ((i >> 1) << 3)) & 0xff);\n\n\t\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\t\tinput_report_abs(dev, ABS_HAT0Y - i,\n\t\t\t\t\t\t((data[1] >> ((i << 1) + 17)) & 1)  - ((data[1] >> ((i << 1) + 16)) & 1));\n\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\tinput_report_key(dev, interact_btn_hhfx[i], (data[0] >> (i + 16)) & 1);\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tinput_report_key(dev, interact_btn_hhfx[i + 8], (data[1] >> (i + 20)) & 1);\n\n\t\t\t\tbreak;\n\n\t\t\tcase INTERACT_TYPE_PP8D:\n\n\t\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\t\tinput_report_abs(dev, interact_abs_pp8d[i],\n\t\t\t\t\t\t((data[0] >> ((i << 1) + 20)) & 1)  - ((data[0] >> ((i << 1) + 21)) & 1));\n\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\tinput_report_key(dev, interact_btn_pp8d[i], (data[1] >> (i + 16)) & 1);\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tinput_sync(dev);\n}\n\n \n\nstatic int interact_open(struct input_dev *dev)\n{\n\tstruct interact *interact = input_get_drvdata(dev);\n\n\tgameport_start_polling(interact->gameport);\n\treturn 0;\n}\n\n \n\nstatic void interact_close(struct input_dev *dev)\n{\n\tstruct interact *interact = input_get_drvdata(dev);\n\n\tgameport_stop_polling(interact->gameport);\n}\n\n \n\nstatic int interact_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct interact *interact;\n\tstruct input_dev *input_dev;\n\t__u32 data[3];\n\tint i, t;\n\tint err;\n\n\tinteract = kzalloc(sizeof(struct interact), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!interact || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tinteract->gameport = gameport;\n\tinteract->dev = input_dev;\n\n\tgameport_set_drvdata(gameport, interact);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\ti = interact_read_packet(gameport, INTERACT_MAX_LENGTH * 2, data);\n\n\tif (i != 32 || (data[0] >> 24) != 0x0c || (data[1] >> 24) != 0x02) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tfor (i = 0; interact_type[i].length; i++)\n\t\tif (interact_type[i].id == (data[2] >> 16))\n\t\t\tbreak;\n\n\tif (!interact_type[i].length) {\n\t\tprintk(KERN_WARNING \"interact.c: Unknown joystick on %s. [len %d d0 %08x d1 %08x i2 %08x]\\n\",\n\t\t\tgameport->phys, i, data[0], data[1], data[2]);\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, interact_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tsnprintf(interact->phys, sizeof(interact->phys), \"%s/input0\", gameport->phys);\n\n\tinteract->type = i;\n\tinteract->length = interact_type[i].length;\n\n\tinput_dev->name = interact_type[i].name;\n\tinput_dev->phys = interact->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_INTERACT;\n\tinput_dev->id.product = interact_type[i].id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &gameport->dev;\n\n\tinput_set_drvdata(input_dev, interact);\n\n\tinput_dev->open = interact_open;\n\tinput_dev->close = interact_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = 0; (t = interact_type[interact->type].abs[i]) >= 0; i++) {\n\t\tif (i < interact_type[interact->type].b8)\n\t\t\tinput_set_abs_params(input_dev, t, 0, 255, 0, 0);\n\t\telse\n\t\t\tinput_set_abs_params(input_dev, t, -1, 1, 0, 0);\n\t}\n\n\tfor (i = 0; (t = interact_type[interact->type].btn[i]) >= 0; i++)\n\t\t__set_bit(t, input_dev->keybit);\n\n\terr = input_register_device(interact->dev);\n\tif (err)\n\t\tgoto fail2;\n\n\treturn 0;\n\nfail2:\tgameport_close(gameport);\nfail1:  gameport_set_drvdata(gameport, NULL);\n\tinput_free_device(input_dev);\n\tkfree(interact);\n\treturn err;\n}\n\nstatic void interact_disconnect(struct gameport *gameport)\n{\n\tstruct interact *interact = gameport_get_drvdata(gameport);\n\n\tinput_unregister_device(interact->dev);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(interact);\n}\n\nstatic struct gameport_driver interact_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"interact\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= interact_connect,\n\t.disconnect\t= interact_disconnect,\n};\n\nmodule_gameport_driver(interact_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}