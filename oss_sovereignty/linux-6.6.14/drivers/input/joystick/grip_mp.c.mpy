{
  "module_name": "grip_mp.c",
  "hash_id": "48eab0e046dec4a7a4c3f7d70011cec00d55e2738ddaf6510b699b20cabf86c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/grip_mp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Gravis Grip Multiport driver\"\n\nMODULE_AUTHOR(\"Brian Bonnlander\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#ifdef GRIP_DEBUG\n#define dbg(format, arg...) printk(KERN_ERR __FILE__ \": \" format \"\\n\" , ## arg)\n#else\n#define dbg(format, arg...) do {} while (0)\n#endif\n\n#define GRIP_MAX_PORTS\t4\n \n\nstruct grip_port {\n\tstruct input_dev *dev;\n\tint mode;\n\tint registered;\n\n\t \n\tint buttons;\n\tint xaxes;\n\tint yaxes;\n\tint dirty;      \n};\n\nstruct grip_mp {\n\tstruct gameport *gameport;\n\tstruct grip_port *port[GRIP_MAX_PORTS];\n\tint reads;\n\tint bads;\n};\n\n \n\n#define PACKET_FULL          0x80000000        \n#define PACKET_IO_FAST       0x40000000        \n#define PACKET_IO_SLOW       0x20000000        \n#define PACKET_MP_MORE       0x04000000        \n#define PACKET_MP_DONE       0x02000000        \n\n \n\n#define IO_GOT_PACKET        0x0100            \n#define IO_MODE_FAST         0x0200            \n#define IO_SLOT_CHANGE       0x0800            \n#define IO_DONE              0x1000            \n#define IO_RETRY             0x4000            \n#define IO_RESET             0x8000            \n\n \n\n#define GRIP_INIT_DELAY         2000           \n\n#define GRIP_MODE_NONE\t\t0\n#define GRIP_MODE_RESET         1\n#define GRIP_MODE_GP\t\t2\n#define GRIP_MODE_C64\t\t3\n\nstatic const int grip_btn_gp[]  = { BTN_TR, BTN_TL, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, -1 };\nstatic const int grip_btn_c64[] = { BTN_JOYSTICK, -1 };\n\nstatic const int grip_abs_gp[]  = { ABS_X, ABS_Y, -1 };\nstatic const int grip_abs_c64[] = { ABS_X, ABS_Y, -1 };\n\nstatic const int *grip_abs[] = { NULL, NULL, grip_abs_gp, grip_abs_c64 };\nstatic const int *grip_btn[] = { NULL, NULL, grip_btn_gp, grip_btn_c64 };\n\nstatic const char *grip_name[] = { NULL, NULL, \"Gravis Grip Pad\", \"Commodore 64 Joystick\" };\n\nstatic const int init_seq[] = {\n\t1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n\t1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1,\n\t1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n\t0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1 };\n\n \n\nstatic const int axis_map[] = { 5, 9, 1, 5, 6, 10, 2, 6, 4, 8, 0, 4, 5, 9, 1, 5 };\n\nstatic int register_slot(int i, struct grip_mp *grip);\n\n \n\nstatic int bit_parity(u32 pkt)\n{\n\tint x = pkt ^ (pkt >> 16);\n\tx ^= x >> 8;\n\tx ^= x >> 4;\n\tx ^= x >> 2;\n\tx ^= x >> 1;\n\treturn x & 1;\n}\n\n \n\nstatic inline int poll_until(u8 onbits, u8 offbits, int u_sec, struct gameport* gp, u8 *data)\n{\n\tint i, nloops;\n\n\tnloops = gameport_time(gp, u_sec);\n\tfor (i = 0; i < nloops; i++) {\n\t\t*data = gameport_read(gp);\n\t\tif ((*data & onbits) == onbits &&\n\t\t    (~(*data) & offbits) == offbits)\n\t\t\treturn 1;\n\t}\n\tdbg(\"gameport timed out after %d microseconds.\\n\", u_sec);\n\treturn 0;\n}\n\n \n\nstatic int mp_io(struct gameport* gameport, int sendflags, int sendcode, u32 *packet)\n{\n\tu8  raw_data;             \n\tu8  data_mask;            \n\tu32 pkt;                  \n\tint bits_per_read;        \n\tint portvals = 0;         \n\tint i;\n\n\t \n\n\t*packet = 0;\n\traw_data = gameport_read(gameport);\n\tif (raw_data & 1)\n\t\treturn IO_RETRY;\n\n\tfor (i = 0; i < 64; i++) {\n\t\traw_data = gameport_read(gameport);\n\t\tportvals |= 1 << ((raw_data >> 4) & 3);  \n\t}\n\n\tif (portvals == 1) {                             \n\t\traw_data = gameport_read(gameport);\n\t\tportvals = raw_data & 0xf0;\n\n\t\tif (raw_data & 0x31)\n\t\t\treturn IO_RESET;\n\t\tgameport_trigger(gameport);\n\n\t\tif (!poll_until(0x10, 0, 308, gameport, &raw_data))\n\t\t\treturn IO_RESET;\n\t} else\n\t\treturn IO_RETRY;\n\n\t \n\n\tif (raw_data & 0x20) {                  \n\t\tportvals |= raw_data >> 4;      \n\n\t\tif (portvals != 0xb)\n\t\t\treturn 0;\n\t\tdata_mask = 7;\n\t\tbits_per_read = 3;\n\t\tpkt = (PACKET_FULL | PACKET_IO_FAST) >> 28;\n\t} else {                                  \n\t\tdata_mask = 1;\n\t\tbits_per_read = 1;\n\t\tpkt = (PACKET_FULL | PACKET_IO_SLOW) >> 28;\n\t}\n\n\t \n\n\twhile (1) {\n\t\tif (!poll_until(0, 0x10, 77, gameport, &raw_data))\n\t\t\treturn IO_RESET;\n\t\traw_data = (raw_data >> 5) & data_mask;\n\n\t\tif (pkt & PACKET_FULL)\n\t\t\tbreak;\n\t\tpkt = (pkt << bits_per_read) | raw_data;\n\n\t\tif (!poll_until(0x10, 0, 77, gameport, &raw_data))\n\t\t\treturn IO_RESET;\n\t}\n\n\tif (raw_data)\n\t\treturn IO_RESET;\n\n\t \n\n\tif (bits_per_read == 3) {\n\t\tpkt = (pkt & 0xffff0000) | ((pkt << 1) & 0xffff);\n\t\tpkt = (pkt >> 2) | 0xf0000000;\n\t}\n\n\tif (bit_parity(pkt) == 1)\n\t\treturn IO_RESET;\n\n\t \n\n\tif (!poll_until(0x30, 0, 77, gameport, &raw_data))\n\t\treturn IO_RESET;\n\n\traw_data = gameport_read(gameport);\n\n\tif (raw_data & 1)\n\t\treturn IO_RESET;\n\n\tgameport_trigger(gameport);\n\n\tif (!poll_until(0, 0x20, 77, gameport, &raw_data))\n\t\treturn IO_RESET;\n\n         \n\n\t*packet = pkt;\n\tif ((sendflags == 0) || ((sendflags & IO_RETRY) && !(pkt & PACKET_MP_DONE)))\n\t\treturn IO_GOT_PACKET;\n\n\tif (pkt & PACKET_MP_MORE)\n\t\treturn IO_GOT_PACKET | IO_RETRY;\n\n\t \n\n\tif (!poll_until(0x20, 0, 77, gameport, &raw_data))\n\t\treturn IO_GOT_PACKET | IO_RESET;\n\n\traw_data = gameport_read(gameport);\n\tif (raw_data & 1)\n\t\treturn IO_GOT_PACKET | IO_RESET;\n\n\t \n\n\tgameport_trigger(gameport);\n\tdo {\n\t\tif (!poll_until(0x20, 0x10, 116, gameport, &raw_data))\n\t\t\treturn IO_GOT_PACKET | IO_RESET;\n\n\t\tif (!poll_until(0x30, 0, 193, gameport, &raw_data))\n\t\t\treturn IO_GOT_PACKET | IO_RESET;\n\n\t\tif (raw_data & 1)\n\t\t\treturn IO_GOT_PACKET | IO_RESET;\n\n\t\tif (sendcode & 1)\n\t\t\tgameport_trigger(gameport);\n\n\t\tsendcode >>= 1;\n\t} while (sendcode);\n\n\treturn IO_GOT_PACKET | IO_MODE_FAST;\n}\n\n \n\nstatic int multiport_io(struct gameport* gameport, int sendflags, int sendcode, u32 *packet)\n{\n\tint status;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tstatus = mp_io(gameport, sendflags, sendcode, packet);\n\tlocal_irq_restore(flags);\n\n\treturn status;\n}\n\n \n\nstatic int dig_mode_start(struct gameport *gameport, u32 *packet)\n{\n\tint i;\n\tint flags, tries = 0, bads = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {      \n\t\tif (init_seq[i])\n\t\t\tgameport_trigger(gameport);\n\t\tudelay(GRIP_INIT_DELAY);\n\t}\n\n\tfor (i = 0; i < 16; i++)             \n\t\tudelay(GRIP_INIT_DELAY);\n\n\twhile (tries < 64 && bads < 8) {     \n\n\t\tflags = multiport_io(gameport, IO_RESET, 0x27, packet);\n\n\t\tif (flags & IO_MODE_FAST)\n\t\t\treturn 1;\n\n\t\tif (flags & IO_RETRY)\n\t\t\ttries++;\n\t\telse\n\t\t\tbads++;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int get_and_decode_packet(struct grip_mp *grip, int flags)\n{\n\tstruct grip_port *port;\n\tu32 packet;\n\tint joytype = 0;\n\tint slot;\n\n\t \n\n\tflags &= IO_RESET | IO_RETRY;\n\tflags = multiport_io(grip->gameport, flags, 0, &packet);\n\tgrip->reads++;\n\n\tif (packet & PACKET_MP_DONE)\n\t\tflags |= IO_DONE;\n\n\tif (flags && !(flags & IO_GOT_PACKET)) {\n\t\tgrip->bads++;\n\t\treturn flags;\n\t}\n\n\t \n\n\tslot = ((packet >> 21) & 0xf) - 1;\n\tif ((slot < 0) || (slot > 3))\n\t\treturn flags;\n\n\tport = grip->port[slot];\n\n\t \n\n\tjoytype = (packet >> 16) & 0x1f;\n\tif (!joytype) {\n\n\t\tif (port->registered) {\n\t\t\tprintk(KERN_INFO \"grip_mp: removing %s, slot %d\\n\",\n\t\t\t       grip_name[port->mode], slot);\n\t\t\tinput_unregister_device(port->dev);\n\t\t\tport->registered = 0;\n\t\t}\n\t\tdbg(\"Reset: grip multiport slot %d\\n\", slot);\n\t\tport->mode = GRIP_MODE_RESET;\n\t\tflags |= IO_SLOT_CHANGE;\n\t\treturn flags;\n\t}\n\n\t \n\n\tif (joytype == 0x1f) {\n\n\t\tint dir = (packet >> 8) & 0xf;           \n\t\tport->buttons = (~packet) & 0xff;\n\t\tport->yaxes = ((axis_map[dir] >> 2) & 3) - 1;\n\t\tport->xaxes = (axis_map[dir] & 3) - 1;\n\t\tport->dirty = 1;\n\n\t\tif (port->mode == GRIP_MODE_RESET)\n\t\t\tflags |= IO_SLOT_CHANGE;\n\n\t\tport->mode = GRIP_MODE_GP;\n\n\t\tif (!port->registered) {\n\t\t\tdbg(\"New Grip pad in multiport slot %d.\\n\", slot);\n\t\t\tif (register_slot(slot, grip)) {\n\t\t\t\tport->mode = GRIP_MODE_RESET;\n\t\t\t\tport->dirty = 0;\n\t\t\t}\n\t\t}\n\t\treturn flags;\n\t}\n\n\t \n\n\t{\n\t\tstatic int strange_code = 0;\n\t\tif (strange_code != joytype) {\n\t\t\tprintk(KERN_INFO \"Possible non-grip pad/joystick detected.\\n\");\n\t\t\tprintk(KERN_INFO \"Got joy type 0x%x and packet 0x%x.\\n\", joytype, packet);\n\t\t\tstrange_code = joytype;\n\t\t}\n\t}\n\treturn flags;\n}\n\n \n\nstatic int slots_valid(struct grip_mp *grip)\n{\n\tint flags, slot, invalid = 0, active = 0;\n\n\tflags = get_and_decode_packet(grip, 0);\n\tif (!(flags & IO_GOT_PACKET))\n\t\treturn 0;\n\n\tfor (slot = 0; slot < 4; slot++) {\n\t\tif (grip->port[slot]->mode == GRIP_MODE_RESET)\n\t\t\tinvalid = 1;\n\t\tif (grip->port[slot]->mode != GRIP_MODE_NONE)\n\t\t\tactive = 1;\n\t}\n\n\t \n\tif (!active)\n\t\treturn (flags & IO_DONE) ? 1 : 0;\n\n\t \n\treturn invalid ? 0 : 1;\n}\n\n \n\nstatic int multiport_init(struct grip_mp *grip)\n{\n\tint dig_mode, initialized = 0, tries = 0;\n\tu32 packet;\n\n\tdig_mode = dig_mode_start(grip->gameport, &packet);\n\twhile (!dig_mode && tries < 4) {\n\t\tdig_mode = dig_mode_start(grip->gameport, &packet);\n\t\ttries++;\n\t}\n\n\tif (dig_mode)\n\t\tdbg(\"multiport_init(): digital mode activated.\\n\");\n\telse {\n\t\tdbg(\"multiport_init(): unable to activate digital mode.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (tries = 0; tries < 4096; tries++) {\n\t\tif (slots_valid(grip)) {\n\t\t\tinitialized = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdbg(\"multiport_init(): initialized == %d\\n\", initialized);\n\treturn initialized;\n}\n\n \n\nstatic void report_slot(struct grip_mp *grip, int slot)\n{\n\tstruct grip_port *port = grip->port[slot];\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 8; i++)\n\t\tinput_report_key(port->dev, grip_btn_gp[i], (port->buttons >> i) & 1);\n\n\t \n\n\tinput_report_abs(port->dev, ABS_X, port->xaxes);\n\tinput_report_abs(port->dev, ABS_Y, port->yaxes);\n\n\t \n\n\tinput_sync(port->dev);\n\n\tport->dirty = 0;\n}\n\n \n\nstatic void grip_poll(struct gameport *gameport)\n{\n\tstruct grip_mp *grip = gameport_get_drvdata(gameport);\n\tint i, npkts, flags;\n\n\tfor (npkts = 0; npkts < 4; npkts++) {\n\t\tflags = IO_RETRY;\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tflags = get_and_decode_packet(grip, flags);\n\t\t\tif ((flags & IO_GOT_PACKET) || !(flags & IO_RETRY))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (flags & IO_DONE)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (grip->port[i]->dirty)\n\t\t\treport_slot(grip, i);\n}\n\n \n\nstatic int grip_open(struct input_dev *dev)\n{\n\tstruct grip_mp *grip = input_get_drvdata(dev);\n\n\tgameport_start_polling(grip->gameport);\n\treturn 0;\n}\n\n \n\nstatic void grip_close(struct input_dev *dev)\n{\n\tstruct grip_mp *grip = input_get_drvdata(dev);\n\n\tgameport_stop_polling(grip->gameport);\n}\n\n \n\nstatic int register_slot(int slot, struct grip_mp *grip)\n{\n\tstruct grip_port *port = grip->port[slot];\n\tstruct input_dev *input_dev;\n\tint j, t;\n\tint err;\n\n\tport->dev = input_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = grip_name[port->mode];\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;\n\tinput_dev->id.product = 0x0100 + port->mode;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &grip->gameport->dev;\n\n\tinput_set_drvdata(input_dev, grip);\n\n\tinput_dev->open = grip_open;\n\tinput_dev->close = grip_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (j = 0; (t = grip_abs[port->mode][j]) >= 0; j++)\n\t\tinput_set_abs_params(input_dev, t, -1, 1, 0, 0);\n\n\tfor (j = 0; (t = grip_btn[port->mode][j]) >= 0; j++)\n\t\tif (t > 0)\n\t\t\tset_bit(t, input_dev->keybit);\n\n\terr = input_register_device(port->dev);\n\tif (err) {\n\t\tinput_free_device(port->dev);\n\t\treturn err;\n\t}\n\n\tport->registered = 1;\n\n\tif (port->dirty)\t             \n\t\treport_slot(grip, slot);\n\n\treturn 0;\n}\n\nstatic int grip_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct grip_mp *grip;\n\tint err;\n\n\tif (!(grip = kzalloc(sizeof(struct grip_mp), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tgrip->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, grip);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tgameport_set_poll_handler(gameport, grip_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tif (!multiport_init(grip)) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tif (!grip->port[0]->mode && !grip->port[1]->mode && !grip->port[2]->mode && !grip->port[3]->mode) {\n\t\t \n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail2:\tgameport_close(gameport);\nfail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(grip);\n\treturn err;\n}\n\nstatic void grip_disconnect(struct gameport *gameport)\n{\n\tstruct grip_mp *grip = gameport_get_drvdata(gameport);\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (grip->port[i]->registered)\n\t\t\tinput_unregister_device(grip->port[i]->dev);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(grip);\n}\n\nstatic struct gameport_driver grip_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"grip_mp\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= grip_connect,\n\t.disconnect\t= grip_disconnect,\n};\n\nmodule_gameport_driver(grip_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}