{
  "module_name": "spaceball.c",
  "hash_id": "5031f1bea3d3cd645e90c6800b65ae98c704fa88e554c5da8004ba8d8d4a6d0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/spaceball.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <asm/unaligned.h>\n\n#define DRIVER_DESC\t\"SpaceTec SpaceBall 2003/3003/4000 FLX driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define SPACEBALL_MAX_LENGTH\t128\n#define SPACEBALL_MAX_ID\t9\n\n#define SPACEBALL_1003      1\n#define SPACEBALL_2003B     3\n#define SPACEBALL_2003C     4\n#define SPACEBALL_3003C     7\n#define SPACEBALL_4000FLX   8\n#define SPACEBALL_4000FLX_L 9\n\nstatic int spaceball_axes[] = { ABS_X, ABS_Z, ABS_Y, ABS_RX, ABS_RZ, ABS_RY };\nstatic char *spaceball_names[] = {\n\t\"?\", \"SpaceTec SpaceBall 1003\", \"SpaceTec SpaceBall 2003\", \"SpaceTec SpaceBall 2003B\",\n\t\"SpaceTec SpaceBall 2003C\", \"SpaceTec SpaceBall 3003\", \"SpaceTec SpaceBall SpaceController\",\n\t\"SpaceTec SpaceBall 3003C\", \"SpaceTec SpaceBall 4000FLX\", \"SpaceTec SpaceBall 4000FLX Lefty\" };\n\n \n\nstruct spaceball {\n\tstruct input_dev *dev;\n\tint idx;\n\tint escape;\n\tunsigned char data[SPACEBALL_MAX_LENGTH];\n\tchar phys[32];\n};\n\n \n\nstatic void spaceball_process_packet(struct spaceball* spaceball)\n{\n\tstruct input_dev *dev = spaceball->dev;\n\tunsigned char *data = spaceball->data;\n\tint i;\n\n\tif (spaceball->idx < 2) return;\n\n\tswitch (spaceball->data[0]) {\n\n\t\tcase 'D':\t\t\t\t\t \n\t\t\tif (spaceball->idx != 15) return;\n\t\t\t \n\t\t\tdata += 3;\n\t\t\tfor (i = 0; i < ARRAY_SIZE(spaceball_axes); i++) {\n\t\t\t\tinput_report_abs(dev, spaceball_axes[i],\n\t\t\t\t\t(__s16)get_unaligned_be16(&data[i * 2]));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'K':\t\t\t\t\t \n\t\t\tif (spaceball->idx != 3) return;\n\t\t\tinput_report_key(dev, BTN_1, (data[2] & 0x01) || (data[2] & 0x20));\n\t\t\tinput_report_key(dev, BTN_2, data[2] & 0x02);\n\t\t\tinput_report_key(dev, BTN_3, data[2] & 0x04);\n\t\t\tinput_report_key(dev, BTN_4, data[2] & 0x08);\n\t\t\tinput_report_key(dev, BTN_5, data[1] & 0x01);\n\t\t\tinput_report_key(dev, BTN_6, data[1] & 0x02);\n\t\t\tinput_report_key(dev, BTN_7, data[1] & 0x04);\n\t\t\tinput_report_key(dev, BTN_8, data[1] & 0x10);\n\t\t\tbreak;\n\n\t\tcase '.':\t\t\t\t\t \n\t\t\tif (spaceball->idx != 3) return;\n\t\t\tinput_report_key(dev, BTN_1, data[2] & 0x01);\n\t\t\tinput_report_key(dev, BTN_2, data[2] & 0x02);\n\t\t\tinput_report_key(dev, BTN_3, data[2] & 0x04);\n\t\t\tinput_report_key(dev, BTN_4, data[2] & 0x08);\n\t\t\tinput_report_key(dev, BTN_5, data[2] & 0x10);\n\t\t\tinput_report_key(dev, BTN_6, data[2] & 0x20);\n\t\t\tinput_report_key(dev, BTN_7, data[2] & 0x80);\n\t\t\tinput_report_key(dev, BTN_8, data[1] & 0x01);\n\t\t\tinput_report_key(dev, BTN_9, data[1] & 0x02);\n\t\t\tinput_report_key(dev, BTN_A, data[1] & 0x04);\n\t\t\tinput_report_key(dev, BTN_B, data[1] & 0x08);\n\t\t\tinput_report_key(dev, BTN_C, data[1] & 0x10);\n\t\t\tinput_report_key(dev, BTN_MODE, data[1] & 0x20);\n\t\t\tbreak;\n\n\t\tcase 'E':\t\t\t\t\t \n\t\t\tspaceball->data[spaceball->idx - 1] = 0;\n\t\t\tprintk(KERN_ERR \"spaceball: Device error. [%s]\\n\", spaceball->data + 1);\n\t\t\tbreak;\n\n\t\tcase '?':\t\t\t\t\t \n\t\t\tspaceball->data[spaceball->idx - 1] = 0;\n\t\t\tprintk(KERN_ERR \"spaceball: Bad command. [%s]\\n\", spaceball->data + 1);\n\t\t\tbreak;\n\t}\n\n\tinput_sync(dev);\n}\n\n \n\nstatic irqreturn_t spaceball_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct spaceball *spaceball = serio_get_drvdata(serio);\n\n\tswitch (data) {\n\t\tcase 0xd:\n\t\t\tspaceball_process_packet(spaceball);\n\t\t\tspaceball->idx = 0;\n\t\t\tspaceball->escape = 0;\n\t\t\tbreak;\n\t\tcase '^':\n\t\t\tif (!spaceball->escape) {\n\t\t\t\tspaceball->escape = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspaceball->escape = 0;\n\t\t\tfallthrough;\n\t\tcase 'M':\n\t\tcase 'Q':\n\t\tcase 'S':\n\t\t\tif (spaceball->escape) {\n\t\t\t\tspaceball->escape = 0;\n\t\t\t\tdata &= 0x1f;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (spaceball->escape)\n\t\t\t\tspaceball->escape = 0;\n\t\t\tif (spaceball->idx < SPACEBALL_MAX_LENGTH)\n\t\t\t\tspaceball->data[spaceball->idx++] = data;\n\t\t\tbreak;\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void spaceball_disconnect(struct serio *serio)\n{\n\tstruct spaceball* spaceball = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(spaceball->dev);\n\tkfree(spaceball);\n}\n\n \n\nstatic int spaceball_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct spaceball *spaceball;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i, id;\n\n\tif ((id = serio->id.id) > SPACEBALL_MAX_ID)\n\t\treturn -ENODEV;\n\n\tspaceball = kmalloc(sizeof(struct spaceball), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!spaceball || !input_dev)\n\t\tgoto fail1;\n\n\tspaceball->dev = input_dev;\n\tsnprintf(spaceball->phys, sizeof(spaceball->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = spaceball_names[id];\n\tinput_dev->phys = spaceball->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_SPACEBALL;\n\tinput_dev->id.product = id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tswitch (id) {\n\t\tcase SPACEBALL_4000FLX:\n\t\tcase SPACEBALL_4000FLX_L:\n\t\t\tinput_dev->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_9);\n\t\t\tinput_dev->keybit[BIT_WORD(BTN_A)] |= BIT_MASK(BTN_A) |\n\t\t\t\tBIT_MASK(BTN_B) | BIT_MASK(BTN_C) |\n\t\t\t\tBIT_MASK(BTN_MODE);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tinput_dev->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_2) |\n\t\t\t\tBIT_MASK(BTN_3) | BIT_MASK(BTN_4) |\n\t\t\t\tBIT_MASK(BTN_5) | BIT_MASK(BTN_6) |\n\t\t\t\tBIT_MASK(BTN_7) | BIT_MASK(BTN_8);\n\t\t\tfallthrough;\n\t\tcase SPACEBALL_3003C:\n\t\t\tinput_dev->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_1) |\n\t\t\t\tBIT_MASK(BTN_8);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tinput_set_abs_params(input_dev, ABS_X + i, -8000, 8000, 8, 40);\n\t\tinput_set_abs_params(input_dev, ABS_RX + i, -1600, 1600, 2, 8);\n\t}\n\n\tserio_set_drvdata(serio, spaceball);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(spaceball->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(spaceball);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id spaceball_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_SPACEBALL,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, spaceball_serio_ids);\n\nstatic struct serio_driver spaceball_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"spaceball\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= spaceball_serio_ids,\n\t.interrupt\t= spaceball_interrupt,\n\t.connect\t= spaceball_connect,\n\t.disconnect\t= spaceball_disconnect,\n};\n\nmodule_serio_driver(spaceball_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}