{
  "module_name": "gamecon.c",
  "hash_id": "fac73382c432ba5ebeb149ac4147691bc0690b63dabf8bca38344690e76c9eab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/gamecon.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/parport.h>\n#include <linux/input.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"NES, SNES, N64, MultiSystem, PSX gamepad driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define GC_MAX_PORTS\t\t3\n#define GC_MAX_DEVICES\t\t5\n\nstruct gc_config {\n\tint args[GC_MAX_DEVICES + 1];\n\tunsigned int nargs;\n};\n\nstatic struct gc_config gc_cfg[GC_MAX_PORTS];\n\nmodule_param_array_named(map, gc_cfg[0].args, int, &gc_cfg[0].nargs, 0);\nMODULE_PARM_DESC(map, \"Describes first set of devices (<parport#>,<pad1>,<pad2>,..<pad5>)\");\nmodule_param_array_named(map2, gc_cfg[1].args, int, &gc_cfg[1].nargs, 0);\nMODULE_PARM_DESC(map2, \"Describes second set of devices\");\nmodule_param_array_named(map3, gc_cfg[2].args, int, &gc_cfg[2].nargs, 0);\nMODULE_PARM_DESC(map3, \"Describes third set of devices\");\n\n \n\nenum gc_type {\n\tGC_NONE = 0,\n\tGC_SNES,\n\tGC_NES,\n\tGC_NES4,\n\tGC_MULTI,\n\tGC_MULTI2,\n\tGC_N64,\n\tGC_PSX,\n\tGC_DDR,\n\tGC_SNESMOUSE,\n\tGC_MAX\n};\n\n#define GC_REFRESH_TIME\tHZ/100\n\nstruct gc_pad {\n\tstruct input_dev *dev;\n\tenum gc_type type;\n\tchar phys[32];\n};\n\nstruct gc {\n\tstruct pardevice *pd;\n\tstruct gc_pad pads[GC_MAX_DEVICES];\n\tstruct timer_list timer;\n\tint pad_count[GC_MAX];\n\tint used;\n\tint parportno;\n\tstruct mutex mutex;\n};\n\nstruct gc_subdev {\n\tunsigned int idx;\n};\n\nstatic struct gc *gc_base[3];\n\nstatic const int gc_status_bit[] = { 0x40, 0x80, 0x20, 0x10, 0x08 };\n\nstatic const char *gc_names[] = {\n\tNULL, \"SNES pad\", \"NES pad\", \"NES FourPort\", \"Multisystem joystick\",\n\t\"Multisystem 2-button joystick\", \"N64 controller\", \"PSX controller\",\n\t\"PSX DDR controller\", \"SNES mouse\"\n};\n\n \n\nstatic const unsigned char gc_n64_bytes[] = { 0, 1, 13, 15, 14, 12, 10, 11, 2, 3 };\nstatic const short gc_n64_btn[] = {\n\tBTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z,\n\tBTN_TL, BTN_TR, BTN_TRIGGER, BTN_START\n};\n\n#define GC_N64_LENGTH\t\t32\t\t \n#define GC_N64_STOP_LENGTH\t5\t\t \n#define GC_N64_CMD_00\t\t0x11111111UL\n#define GC_N64_CMD_01\t\t0xd1111111UL\n#define GC_N64_CMD_03\t\t0xdd111111UL\n#define GC_N64_CMD_1b\t\t0xdd1dd111UL\n#define GC_N64_CMD_c0\t\t0x111111ddUL\n#define GC_N64_CMD_80\t\t0x1111111dUL\n#define GC_N64_STOP_BIT\t\t0x1d\t\t \n#define GC_N64_REQUEST_DATA\tGC_N64_CMD_01\t \n#define GC_N64_DELAY\t\t133\t\t \n#define GC_N64_DWS\t\t3\t\t \n\t\t\t\t\t\t \n#define GC_N64_POWER_W\t\t0xe2\t\t \n#define GC_N64_POWER_R\t\t0xfd\t\t \n#define GC_N64_OUT\t\t0x1d\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t \n#define GC_N64_CLOCK\t\t0x02\t\t \n\n \n\n \nstatic void gc_n64_send_command(struct gc *gc, unsigned long cmd,\n\t\t\t\tunsigned char target)\n{\n\tstruct parport *port = gc->pd->port;\n\tint i;\n\n\tfor (i = 0; i < GC_N64_LENGTH; i++) {\n\t\tunsigned char data = (cmd >> i) & 1 ? target : 0;\n\t\tparport_write_data(port, GC_N64_POWER_W | data);\n\t\tudelay(GC_N64_DWS);\n\t}\n}\n\n \nstatic void gc_n64_send_stop_bit(struct gc *gc, unsigned char target)\n{\n\tstruct parport *port = gc->pd->port;\n\tint i;\n\n\tfor (i = 0; i < GC_N64_STOP_LENGTH; i++) {\n\t\tunsigned char data = (GC_N64_STOP_BIT >> i) & 1 ? target : 0;\n\t\tparport_write_data(port, GC_N64_POWER_W | data);\n\t\tudelay(GC_N64_DWS);\n\t}\n}\n\n \n\nstatic void gc_n64_read_packet(struct gc *gc, unsigned char *data)\n{\n\tint i;\n\tunsigned long flags;\n\n \n\n\tlocal_irq_save(flags);\n\tgc_n64_send_command(gc, GC_N64_REQUEST_DATA, GC_N64_OUT);\n\tgc_n64_send_stop_bit(gc, GC_N64_OUT);\n\tlocal_irq_restore(flags);\n\n \n\n\tudelay(GC_N64_DELAY);\n\n \n\n\tfor (i = 0; i < GC_N64_LENGTH; i++) {\n\t\tparport_write_data(gc->pd->port, GC_N64_POWER_R);\n\t\tudelay(2);\n\t\tdata[i] = parport_read_status(gc->pd->port);\n\t\tparport_write_data(gc->pd->port, GC_N64_POWER_R | GC_N64_CLOCK);\n\t }\n\n \n\n}\n\nstatic void gc_n64_process_packet(struct gc *gc)\n{\n\tunsigned char data[GC_N64_LENGTH];\n\tstruct input_dev *dev;\n\tint i, j, s;\n\tsigned char x, y;\n\n\tgc_n64_read_packet(gc, data);\n\n\tfor (i = 0; i < GC_MAX_DEVICES; i++) {\n\n\t\tif (gc->pads[i].type != GC_N64)\n\t\t\tcontinue;\n\n\t\tdev = gc->pads[i].dev;\n\t\ts = gc_status_bit[i];\n\n\t\tif (s & ~(data[8] | data[9])) {\n\n\t\t\tx = y = 0;\n\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (data[23 - j] & s)\n\t\t\t\t\tx |= 1 << j;\n\t\t\t\tif (data[31 - j] & s)\n\t\t\t\t\ty |= 1 << j;\n\t\t\t}\n\n\t\t\tinput_report_abs(dev, ABS_X,  x);\n\t\t\tinput_report_abs(dev, ABS_Y, -y);\n\n\t\t\tinput_report_abs(dev, ABS_HAT0X,\n\t\t\t\t\t !(s & data[6]) - !(s & data[7]));\n\t\t\tinput_report_abs(dev, ABS_HAT0Y,\n\t\t\t\t\t !(s & data[4]) - !(s & data[5]));\n\n\t\t\tfor (j = 0; j < 10; j++)\n\t\t\t\tinput_report_key(dev, gc_n64_btn[j],\n\t\t\t\t\t\t s & data[gc_n64_bytes[j]]);\n\n\t\t\tinput_sync(dev);\n\t\t}\n\t}\n}\n\nstatic int gc_n64_play_effect(struct input_dev *dev, void *data,\n\t\t\t      struct ff_effect *effect)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct gc *gc = input_get_drvdata(dev);\n\tstruct gc_subdev *sdev = data;\n\tunsigned char target = 1 << sdev->idx;  \n\n\tif (effect->type == FF_RUMBLE) {\n\t\tstruct ff_rumble_effect *rumble = &effect->u.rumble;\n\t\tunsigned int cmd =\n\t\t\trumble->strong_magnitude || rumble->weak_magnitude ?\n\t\t\tGC_N64_CMD_01 : GC_N64_CMD_00;\n\n\t\tlocal_irq_save(flags);\n\n\t\t \n\t\tgc_n64_send_command(gc, GC_N64_CMD_03, target);\n\t\tgc_n64_send_command(gc, GC_N64_CMD_80, target);\n\t\tgc_n64_send_command(gc, GC_N64_CMD_01, target);\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tgc_n64_send_command(gc, GC_N64_CMD_80, target);\n\t\tgc_n64_send_stop_bit(gc, target);\n\n\t\tudelay(GC_N64_DELAY);\n\n\t\t \n\t\tgc_n64_send_command(gc, GC_N64_CMD_03, target);\n\t\tgc_n64_send_command(gc, GC_N64_CMD_c0, target);\n\t\tgc_n64_send_command(gc, GC_N64_CMD_1b, target);\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tgc_n64_send_command(gc, cmd, target);\n\t\tgc_n64_send_stop_bit(gc, target);\n\n\t\tlocal_irq_restore(flags);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int gc_n64_init_ff(struct input_dev *dev, int i)\n{\n\tstruct gc_subdev *sdev;\n\tint err;\n\n\tsdev = kmalloc(sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\tsdev->idx = i;\n\n\tinput_set_capability(dev, EV_FF, FF_RUMBLE);\n\n\terr = input_ff_create_memless(dev, sdev, gc_n64_play_effect);\n\tif (err) {\n\t\tkfree(sdev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define GC_NES_DELAY\t\t6\t \n#define GC_NES_LENGTH\t\t8\t \n#define GC_SNES_LENGTH\t\t12\t \n#define GC_SNESMOUSE_LENGTH\t32\t \n\n#define GC_NES_POWER\t0xfc\n#define GC_NES_CLOCK\t0x01\n#define GC_NES_LATCH\t0x02\n\nstatic const unsigned char gc_nes_bytes[] = { 0, 1, 2, 3 };\nstatic const unsigned char gc_snes_bytes[] = { 8, 0, 2, 3, 9, 1, 10, 11 };\nstatic const short gc_snes_btn[] = {\n\tBTN_A, BTN_B, BTN_SELECT, BTN_START, BTN_X, BTN_Y, BTN_TL, BTN_TR\n};\n\n \n\nstatic void gc_nes_read_packet(struct gc *gc, int length, unsigned char *data)\n{\n\tint i;\n\n\tparport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK | GC_NES_LATCH);\n\tudelay(GC_NES_DELAY * 2);\n\tparport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);\n\n\tfor (i = 0; i < length; i++) {\n\t\tudelay(GC_NES_DELAY);\n\t\tparport_write_data(gc->pd->port, GC_NES_POWER);\n\t\tdata[i] = parport_read_status(gc->pd->port) ^ 0x7f;\n\t\tudelay(GC_NES_DELAY);\n\t\tparport_write_data(gc->pd->port, GC_NES_POWER | GC_NES_CLOCK);\n\t}\n}\n\nstatic void gc_nes_process_packet(struct gc *gc)\n{\n\tunsigned char data[GC_SNESMOUSE_LENGTH];\n\tstruct gc_pad *pad;\n\tstruct input_dev *dev;\n\tint i, j, s, len;\n\tchar x_rel, y_rel;\n\n\tlen = gc->pad_count[GC_SNESMOUSE] ? GC_SNESMOUSE_LENGTH :\n\t\t\t(gc->pad_count[GC_SNES] ? GC_SNES_LENGTH : GC_NES_LENGTH);\n\n\tgc_nes_read_packet(gc, len, data);\n\n\tfor (i = 0; i < GC_MAX_DEVICES; i++) {\n\n\t\tpad = &gc->pads[i];\n\t\tdev = pad->dev;\n\t\ts = gc_status_bit[i];\n\n\t\tswitch (pad->type) {\n\n\t\tcase GC_NES:\n\n\t\t\tinput_report_abs(dev, ABS_X, !(s & data[6]) - !(s & data[7]));\n\t\t\tinput_report_abs(dev, ABS_Y, !(s & data[4]) - !(s & data[5]));\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tinput_report_key(dev, gc_snes_btn[j],\n\t\t\t\t\t\t s & data[gc_nes_bytes[j]]);\n\t\t\tinput_sync(dev);\n\t\t\tbreak;\n\n\t\tcase GC_SNES:\n\n\t\t\tinput_report_abs(dev, ABS_X, !(s & data[6]) - !(s & data[7]));\n\t\t\tinput_report_abs(dev, ABS_Y, !(s & data[4]) - !(s & data[5]));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tinput_report_key(dev, gc_snes_btn[j],\n\t\t\t\t\t\t s & data[gc_snes_bytes[j]]);\n\t\t\tinput_sync(dev);\n\t\t\tbreak;\n\n\t\tcase GC_SNESMOUSE:\n\t\t\t \n\t\t\tif (!(s & data[12]) && !(s & data[13]) &&\n\t\t\t    !(s & data[14]) && (s & data[15])) {\n\t\t\t\tinput_report_key(dev, BTN_LEFT, s & data[9]);\n\t\t\t\tinput_report_key(dev, BTN_RIGHT, s & data[8]);\n\n\t\t\t\tx_rel = y_rel = 0;\n\t\t\t\tfor (j = 0; j < 7; j++) {\n\t\t\t\t\tx_rel <<= 1;\n\t\t\t\t\tif (data[25 + j] & s)\n\t\t\t\t\t\tx_rel |= 1;\n\n\t\t\t\t\ty_rel <<= 1;\n\t\t\t\t\tif (data[17 + j] & s)\n\t\t\t\t\t\ty_rel |= 1;\n\t\t\t\t}\n\n\t\t\t\tif (x_rel) {\n\t\t\t\t\tif (data[24] & s)\n\t\t\t\t\t\tx_rel = -x_rel;\n\t\t\t\t\tinput_report_rel(dev, REL_X, x_rel);\n\t\t\t\t}\n\n\t\t\t\tif (y_rel) {\n\t\t\t\t\tif (data[16] & s)\n\t\t\t\t\t\ty_rel = -y_rel;\n\t\t\t\t\tinput_report_rel(dev, REL_Y, y_rel);\n\t\t\t\t}\n\n\t\t\t\tinput_sync(dev);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\n#define GC_MULTI_LENGTH\t\t5\t \n#define GC_MULTI2_LENGTH\t6\t \n\n \n\nstatic void gc_multi_read_packet(struct gc *gc, int length, unsigned char *data)\n{\n\tint i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tparport_write_data(gc->pd->port, ~(1 << i));\n\t\tdata[i] = parport_read_status(gc->pd->port) ^ 0x7f;\n\t}\n}\n\nstatic void gc_multi_process_packet(struct gc *gc)\n{\n\tunsigned char data[GC_MULTI2_LENGTH];\n\tint data_len = gc->pad_count[GC_MULTI2] ? GC_MULTI2_LENGTH : GC_MULTI_LENGTH;\n\tstruct gc_pad *pad;\n\tstruct input_dev *dev;\n\tint i, s;\n\n\tgc_multi_read_packet(gc, data_len, data);\n\n\tfor (i = 0; i < GC_MAX_DEVICES; i++) {\n\t\tpad = &gc->pads[i];\n\t\tdev = pad->dev;\n\t\ts = gc_status_bit[i];\n\n\t\tswitch (pad->type) {\n\t\tcase GC_MULTI2:\n\t\t\tinput_report_key(dev, BTN_THUMB, s & data[5]);\n\t\t\tfallthrough;\n\n\t\tcase GC_MULTI:\n\t\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t\t !(s & data[2]) - !(s & data[3]));\n\t\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t\t !(s & data[0]) - !(s & data[1]));\n\t\t\tinput_report_key(dev, BTN_TRIGGER, s & data[4]);\n\t\t\tinput_sync(dev);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\n#define GC_PSX_DELAY\t25\t\t \n#define GC_PSX_LENGTH\t8\t\t \n#define GC_PSX_BYTES\t6\t\t \n\n#define GC_PSX_MOUSE\t1\t\t \n#define GC_PSX_NEGCON\t2\t\t \n#define GC_PSX_NORMAL\t4\t\t \n#define GC_PSX_ANALOG\t5\t\t \n#define GC_PSX_RUMBLE\t7\t\t \n\n#define GC_PSX_CLOCK\t0x04\t\t \n#define GC_PSX_COMMAND\t0x01\t\t \n#define GC_PSX_POWER\t0xf8\t\t \n#define GC_PSX_SELECT\t0x02\t\t \n\n#define GC_PSX_ID(x)\t((x) >> 4)\t \n#define GC_PSX_LEN(x)\t(((x) & 0xf) << 1)\t \n\nstatic int gc_psx_delay = GC_PSX_DELAY;\nmodule_param_named(psx_delay, gc_psx_delay, uint, 0);\nMODULE_PARM_DESC(psx_delay, \"Delay when accessing Sony PSX controller (usecs)\");\n\nstatic const short gc_psx_abs[] = {\n\tABS_X, ABS_Y, ABS_RX, ABS_RY, ABS_HAT0X, ABS_HAT0Y\n};\nstatic const short gc_psx_btn[] = {\n\tBTN_TL, BTN_TR, BTN_TL2, BTN_TR2, BTN_A, BTN_B, BTN_X, BTN_Y,\n\tBTN_START, BTN_SELECT, BTN_THUMBL, BTN_THUMBR\n};\nstatic const short gc_psx_ddr_btn[] = { BTN_0, BTN_1, BTN_2, BTN_3 };\n\n \n\nstatic void gc_psx_command(struct gc *gc, int b, unsigned char *data)\n{\n\tstruct parport *port = gc->pd->port;\n\tint i, j, cmd, read;\n\n\tmemset(data, 0, GC_MAX_DEVICES);\n\n\tfor (i = 0; i < GC_PSX_LENGTH; i++, b >>= 1) {\n\t\tcmd = (b & 1) ? GC_PSX_COMMAND : 0;\n\t\tparport_write_data(port, cmd | GC_PSX_POWER);\n\t\tudelay(gc_psx_delay);\n\n\t\tread = parport_read_status(port) ^ 0x80;\n\n\t\tfor (j = 0; j < GC_MAX_DEVICES; j++) {\n\t\t\tstruct gc_pad *pad = &gc->pads[j];\n\n\t\t\tif (pad->type == GC_PSX || pad->type == GC_DDR)\n\t\t\t\tdata[j] |= (read & gc_status_bit[j]) ? (1 << i) : 0;\n\t\t}\n\n\t\tparport_write_data(gc->pd->port, cmd | GC_PSX_CLOCK | GC_PSX_POWER);\n\t\tudelay(gc_psx_delay);\n\t}\n}\n\n \n\nstatic void gc_psx_read_packet(struct gc *gc,\n\t\t\t       unsigned char data[GC_MAX_DEVICES][GC_PSX_BYTES],\n\t\t\t       unsigned char id[GC_MAX_DEVICES])\n{\n\tint i, j, max_len = 0;\n\tunsigned long flags;\n\tunsigned char data2[GC_MAX_DEVICES];\n\n\t \n\tparport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_SELECT | GC_PSX_POWER);\n\tudelay(gc_psx_delay);\n\t \n\tparport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_POWER);\n\tudelay(gc_psx_delay);\n\n\tlocal_irq_save(flags);\n\n\tgc_psx_command(gc, 0x01, data2);\t \n\tgc_psx_command(gc, 0x42, id);\t\t \n\tgc_psx_command(gc, 0, data2);\t\t \n\n\t \n\tfor (i = 0; i < GC_MAX_DEVICES; i++) {\n\t\tstruct gc_pad *pad = &gc->pads[i];\n\n\t\tif ((pad->type == GC_PSX || pad->type == GC_DDR) &&\n\t\t    GC_PSX_LEN(id[i]) > max_len &&\n\t\t    GC_PSX_LEN(id[i]) <= GC_PSX_BYTES) {\n\t\t\tmax_len = GC_PSX_LEN(id[i]);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < max_len; i++) {\n\t\tgc_psx_command(gc, 0, data2);\n\t\tfor (j = 0; j < GC_MAX_DEVICES; j++)\n\t\t\tdata[j][i] = data2[j];\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tparport_write_data(gc->pd->port, GC_PSX_CLOCK | GC_PSX_SELECT | GC_PSX_POWER);\n\n\t \n\tfor (i = 0; i < GC_MAX_DEVICES; i++)\n\t\tid[i] = GC_PSX_ID(id[i]);\n}\n\nstatic void gc_psx_report_one(struct gc_pad *pad, unsigned char psx_type,\n\t\t\t      unsigned char *data)\n{\n\tstruct input_dev *dev = pad->dev;\n\tint i;\n\n\tswitch (psx_type) {\n\n\tcase GC_PSX_RUMBLE:\n\n\t\tinput_report_key(dev, BTN_THUMBL, ~data[0] & 0x04);\n\t\tinput_report_key(dev, BTN_THUMBR, ~data[0] & 0x02);\n\t\tfallthrough;\n\n\tcase GC_PSX_NEGCON:\n\tcase GC_PSX_ANALOG:\n\n\t\tif (pad->type == GC_DDR) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tinput_report_key(dev, gc_psx_ddr_btn[i],\n\t\t\t\t\t\t ~data[0] & (0x10 << i));\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tinput_report_abs(dev, gc_psx_abs[i + 2],\n\t\t\t\t\t\t data[i + 2]);\n\n\t\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t!!(data[0] & 0x80) * 128 + !(data[0] & 0x20) * 127);\n\t\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t!!(data[0] & 0x10) * 128 + !(data[0] & 0x40) * 127);\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tinput_report_key(dev, gc_psx_btn[i], ~data[1] & (1 << i));\n\n\t\tinput_report_key(dev, BTN_START,  ~data[0] & 0x08);\n\t\tinput_report_key(dev, BTN_SELECT, ~data[0] & 0x01);\n\n\t\tinput_sync(dev);\n\n\t\tbreak;\n\n\tcase GC_PSX_NORMAL:\n\n\t\tif (pad->type == GC_DDR) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tinput_report_key(dev, gc_psx_ddr_btn[i],\n\t\t\t\t\t\t ~data[0] & (0x10 << i));\n\t\t} else {\n\t\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t!!(data[0] & 0x80) * 128 + !(data[0] & 0x20) * 127);\n\t\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t!!(data[0] & 0x10) * 128 + !(data[0] & 0x40) * 127);\n\n\t\t\t \n\t\t}\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tinput_report_key(dev, gc_psx_btn[i], ~data[1] & (1 << i));\n\n\t\tinput_report_key(dev, BTN_START,  ~data[0] & 0x08);\n\t\tinput_report_key(dev, BTN_SELECT, ~data[0] & 0x01);\n\n\t\tinput_sync(dev);\n\n\t\tbreak;\n\n\tdefault:  \n\t\tbreak;\n\t}\n}\n\nstatic void gc_psx_process_packet(struct gc *gc)\n{\n\tunsigned char data[GC_MAX_DEVICES][GC_PSX_BYTES];\n\tunsigned char id[GC_MAX_DEVICES];\n\tstruct gc_pad *pad;\n\tint i;\n\n\tgc_psx_read_packet(gc, data, id);\n\n\tfor (i = 0; i < GC_MAX_DEVICES; i++) {\n\t\tpad = &gc->pads[i];\n\t\tif (pad->type == GC_PSX || pad->type == GC_DDR)\n\t\t\tgc_psx_report_one(pad, id[i], data[i]);\n\t}\n}\n\n \n\nstatic void gc_timer(struct timer_list *t)\n{\n\tstruct gc *gc = from_timer(gc, t, timer);\n\n \n\n\tif (gc->pad_count[GC_N64])\n\t\tgc_n64_process_packet(gc);\n\n \n\n\tif (gc->pad_count[GC_NES] ||\n\t    gc->pad_count[GC_SNES] ||\n\t    gc->pad_count[GC_SNESMOUSE]) {\n\t\tgc_nes_process_packet(gc);\n\t}\n\n \n\n\tif (gc->pad_count[GC_MULTI] || gc->pad_count[GC_MULTI2])\n\t\tgc_multi_process_packet(gc);\n\n \n\n\tif (gc->pad_count[GC_PSX] || gc->pad_count[GC_DDR])\n\t\tgc_psx_process_packet(gc);\n\n\tmod_timer(&gc->timer, jiffies + GC_REFRESH_TIME);\n}\n\nstatic int gc_open(struct input_dev *dev)\n{\n\tstruct gc *gc = input_get_drvdata(dev);\n\tint err;\n\n\terr = mutex_lock_interruptible(&gc->mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (!gc->used++) {\n\t\tparport_claim(gc->pd);\n\t\tparport_write_control(gc->pd->port, 0x04);\n\t\tmod_timer(&gc->timer, jiffies + GC_REFRESH_TIME);\n\t}\n\n\tmutex_unlock(&gc->mutex);\n\treturn 0;\n}\n\nstatic void gc_close(struct input_dev *dev)\n{\n\tstruct gc *gc = input_get_drvdata(dev);\n\n\tmutex_lock(&gc->mutex);\n\tif (!--gc->used) {\n\t\tdel_timer_sync(&gc->timer);\n\t\tparport_write_control(gc->pd->port, 0x00);\n\t\tparport_release(gc->pd);\n\t}\n\tmutex_unlock(&gc->mutex);\n}\n\nstatic int gc_setup_pad(struct gc *gc, int idx, int pad_type)\n{\n\tstruct gc_pad *pad = &gc->pads[idx];\n\tstruct input_dev *input_dev;\n\tint i;\n\tint err;\n\n\tif (pad_type < 1 || pad_type >= GC_MAX) {\n\t\tpr_err(\"Pad type %d unknown\\n\", pad_type);\n\t\treturn -EINVAL;\n\t}\n\n\tpad->dev = input_dev = input_allocate_device();\n\tif (!input_dev) {\n\t\tpr_err(\"Not enough memory for input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpad->type = pad_type;\n\n\tsnprintf(pad->phys, sizeof(pad->phys),\n\t\t \"%s/input%d\", gc->pd->port->name, idx);\n\n\tinput_dev->name = gc_names[pad_type];\n\tinput_dev->phys = pad->phys;\n\tinput_dev->id.bustype = BUS_PARPORT;\n\tinput_dev->id.vendor = 0x0001;\n\tinput_dev->id.product = pad_type;\n\tinput_dev->id.version = 0x0100;\n\n\tinput_set_drvdata(input_dev, gc);\n\n\tinput_dev->open = gc_open;\n\tinput_dev->close = gc_close;\n\n\tif (pad_type != GC_SNESMOUSE) {\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinput_set_abs_params(input_dev, ABS_X + i, -1, 1, 0, 0);\n\t} else\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\n\tgc->pad_count[pad_type]++;\n\n\tswitch (pad_type) {\n\n\tcase GC_N64:\n\t\tfor (i = 0; i < 10; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, gc_n64_btn[i]);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tinput_set_abs_params(input_dev, ABS_X + i, -127, 126, 0, 2);\n\t\t\tinput_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);\n\t\t}\n\n\t\terr = gc_n64_init_ff(input_dev, idx);\n\t\tif (err) {\n\t\t\tpr_warn(\"Failed to initiate rumble for N64 device %d\\n\",\n\t\t\t\tidx);\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tbreak;\n\n\tcase GC_SNESMOUSE:\n\t\tinput_set_capability(input_dev, EV_KEY, BTN_LEFT);\n\t\tinput_set_capability(input_dev, EV_KEY, BTN_RIGHT);\n\t\tinput_set_capability(input_dev, EV_REL, REL_X);\n\t\tinput_set_capability(input_dev, EV_REL, REL_Y);\n\t\tbreak;\n\n\tcase GC_SNES:\n\t\tfor (i = 4; i < 8; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, gc_snes_btn[i]);\n\t\tfallthrough;\n\n\tcase GC_NES:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, gc_snes_btn[i]);\n\t\tbreak;\n\n\tcase GC_MULTI2:\n\t\tinput_set_capability(input_dev, EV_KEY, BTN_THUMB);\n\t\tfallthrough;\n\n\tcase GC_MULTI:\n\t\tinput_set_capability(input_dev, EV_KEY, BTN_TRIGGER);\n\t\tbreak;\n\n\tcase GC_PSX:\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tinput_set_abs_params(input_dev,\n\t\t\t\t\t     gc_psx_abs[i], 4, 252, 0, 2);\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, gc_psx_btn[i]);\n\t\tbreak;\n\n\t\tbreak;\n\n\tcase GC_DDR:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY,\n\t\t\t\t\t     gc_psx_ddr_btn[i]);\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, gc_psx_btn[i]);\n\n\t\tbreak;\n\t}\n\n\terr = input_register_device(pad->dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(pad->dev);\n\tpad->dev = NULL;\n\treturn err;\n}\n\nstatic void gc_attach(struct parport *pp)\n{\n\tstruct gc *gc;\n\tstruct pardevice *pd;\n\tint i, port_idx;\n\tint count = 0;\n\tint *pads, n_pads;\n\tstruct pardev_cb gc_parport_cb;\n\n\tfor (port_idx = 0; port_idx < GC_MAX_PORTS; port_idx++) {\n\t\tif (gc_cfg[port_idx].nargs == 0 || gc_cfg[port_idx].args[0] < 0)\n\t\t\tcontinue;\n\n\t\tif (gc_cfg[port_idx].args[0] == pp->number)\n\t\t\tbreak;\n\t}\n\n\tif (port_idx == GC_MAX_PORTS) {\n\t\tpr_debug(\"Not using parport%d.\\n\", pp->number);\n\t\treturn;\n\t}\n\tpads = gc_cfg[port_idx].args + 1;\n\tn_pads = gc_cfg[port_idx].nargs - 1;\n\n\tmemset(&gc_parport_cb, 0, sizeof(gc_parport_cb));\n\tgc_parport_cb.flags = PARPORT_FLAG_EXCL;\n\n\tpd = parport_register_dev_model(pp, \"gamecon\", &gc_parport_cb,\n\t\t\t\t\tport_idx);\n\tif (!pd) {\n\t\tpr_err(\"parport busy already - lp.o loaded?\\n\");\n\t\treturn;\n\t}\n\n\tgc = kzalloc(sizeof(struct gc), GFP_KERNEL);\n\tif (!gc) {\n\t\tpr_err(\"Not enough memory\\n\");\n\t\tgoto err_unreg_pardev;\n\t}\n\n\tmutex_init(&gc->mutex);\n\tgc->pd = pd;\n\tgc->parportno = pp->number;\n\ttimer_setup(&gc->timer, gc_timer, 0);\n\n\tfor (i = 0; i < n_pads && i < GC_MAX_DEVICES; i++) {\n\t\tif (!pads[i])\n\t\t\tcontinue;\n\n\t\tif (gc_setup_pad(gc, i, pads[i]))\n\t\t\tgoto err_unreg_devs;\n\n\t\tcount++;\n\t}\n\n\tif (count == 0) {\n\t\tpr_err(\"No valid devices specified\\n\");\n\t\tgoto err_free_gc;\n\t}\n\n\tgc_base[port_idx] = gc;\n\treturn;\n\n err_unreg_devs:\n\twhile (--i >= 0)\n\t\tif (gc->pads[i].dev)\n\t\t\tinput_unregister_device(gc->pads[i].dev);\n err_free_gc:\n\tkfree(gc);\n err_unreg_pardev:\n\tparport_unregister_device(pd);\n}\n\nstatic void gc_detach(struct parport *port)\n{\n\tint i;\n\tstruct gc *gc;\n\n\tfor (i = 0; i < GC_MAX_PORTS; i++) {\n\t\tif (gc_base[i] && gc_base[i]->parportno == port->number)\n\t\t\tbreak;\n\t}\n\n\tif (i == GC_MAX_PORTS)\n\t\treturn;\n\n\tgc = gc_base[i];\n\tgc_base[i] = NULL;\n\n\tfor (i = 0; i < GC_MAX_DEVICES; i++)\n\t\tif (gc->pads[i].dev)\n\t\t\tinput_unregister_device(gc->pads[i].dev);\n\tparport_unregister_device(gc->pd);\n\tkfree(gc);\n}\n\nstatic struct parport_driver gc_parport_driver = {\n\t.name = \"gamecon\",\n\t.match_port = gc_attach,\n\t.detach = gc_detach,\n\t.devmodel = true,\n};\n\nstatic int __init gc_init(void)\n{\n\tint i;\n\tint have_dev = 0;\n\n\tfor (i = 0; i < GC_MAX_PORTS; i++) {\n\t\tif (gc_cfg[i].nargs == 0 || gc_cfg[i].args[0] < 0)\n\t\t\tcontinue;\n\n\t\tif (gc_cfg[i].nargs < 2) {\n\t\t\tpr_err(\"at least one device must be specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thave_dev = 1;\n\t}\n\n\tif (!have_dev)\n\t\treturn -ENODEV;\n\n\treturn parport_register_driver(&gc_parport_driver);\n}\n\nstatic void __exit gc_exit(void)\n{\n\tparport_unregister_driver(&gc_parport_driver);\n}\n\nmodule_init(gc_init);\nmodule_exit(gc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}