{
  "module_name": "iforce-serio.c",
  "hash_id": "a5fa13f7bd8ad6ca616cc3bcc65ec78d15aa13ef32a374aeafed35d73f07f879",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/iforce/iforce-serio.c",
  "human_readable_source": "\n \n\n#include <linux/serio.h>\n#include \"iforce.h\"\n\nstruct iforce_serio {\n\tstruct iforce iforce;\n\n\tstruct serio *serio;\n\tint idx, pkt, len, id;\n\tu8 csum;\n\tu8 expect_packet;\n\tu8 cmd_response[IFORCE_MAX_LENGTH];\n\tu8 cmd_response_len;\n\tu8 data_in[IFORCE_MAX_LENGTH];\n};\n\nstatic void iforce_serio_xmit(struct iforce *iforce)\n{\n\tstruct iforce_serio *iforce_serio = container_of(iforce,\n\t\t\t\t\t\t\t struct iforce_serio,\n\t\t\t\t\t\t\t iforce);\n\tunsigned char cs;\n\tint i;\n\tunsigned long flags;\n\n\tif (test_and_set_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags)) {\n\t\tset_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&iforce->xmit_lock, flags);\n\nagain:\n\tif (iforce->xmit.head == iforce->xmit.tail) {\n\t\tiforce_clear_xmit_and_wake(iforce);\n\t\tspin_unlock_irqrestore(&iforce->xmit_lock, flags);\n\t\treturn;\n\t}\n\n\tcs = 0x2b;\n\n\tserio_write(iforce_serio->serio, 0x2b);\n\n\tserio_write(iforce_serio->serio, iforce->xmit.buf[iforce->xmit.tail]);\n\tcs ^= iforce->xmit.buf[iforce->xmit.tail];\n\tXMIT_INC(iforce->xmit.tail, 1);\n\n\tfor (i=iforce->xmit.buf[iforce->xmit.tail]; i >= 0; --i) {\n\t\tserio_write(iforce_serio->serio,\n\t\t\t    iforce->xmit.buf[iforce->xmit.tail]);\n\t\tcs ^= iforce->xmit.buf[iforce->xmit.tail];\n\t\tXMIT_INC(iforce->xmit.tail, 1);\n\t}\n\n\tserio_write(iforce_serio->serio, cs);\n\n\tif (test_and_clear_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags))\n\t\tgoto again;\n\n\tiforce_clear_xmit_and_wake(iforce);\n\n\tspin_unlock_irqrestore(&iforce->xmit_lock, flags);\n}\n\nstatic int iforce_serio_get_id(struct iforce *iforce, u8 id,\n\t\t\t       u8 *response_data, size_t *response_len)\n{\n\tstruct iforce_serio *iforce_serio = container_of(iforce,\n\t\t\t\t\t\t\t struct iforce_serio,\n\t\t\t\t\t\t\t iforce);\n\n\tiforce_serio->expect_packet = HI(FF_CMD_QUERY);\n\tiforce_serio->cmd_response_len = 0;\n\n\tiforce_send_packet(iforce, FF_CMD_QUERY, &id);\n\n\twait_event_interruptible_timeout(iforce->wait,\n\t\t\t\t\t !iforce_serio->expect_packet, HZ);\n\n\tif (iforce_serio->expect_packet) {\n\t\tiforce_serio->expect_packet = 0;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (iforce_serio->cmd_response[0] != id)\n\t\treturn -EIO;\n\n\tmemcpy(response_data, iforce_serio->cmd_response,\n\t       iforce_serio->cmd_response_len);\n\t*response_len = iforce_serio->cmd_response_len;\n\n\treturn 0;\n}\n\nstatic int iforce_serio_start_io(struct iforce *iforce)\n{\n\t \n\treturn 0;\n}\n\nstatic void iforce_serio_stop_io(struct iforce *iforce)\n{\n\t\n}\n\nstatic const struct iforce_xport_ops iforce_serio_xport_ops = {\n\t.xmit\t\t= iforce_serio_xmit,\n\t.get_id\t\t= iforce_serio_get_id,\n\t.start_io\t= iforce_serio_start_io,\n\t.stop_io\t= iforce_serio_stop_io,\n};\n\nstatic void iforce_serio_write_wakeup(struct serio *serio)\n{\n\tstruct iforce *iforce = serio_get_drvdata(serio);\n\n\tiforce_serio_xmit(iforce);\n}\n\nstatic irqreturn_t iforce_serio_irq(struct serio *serio,\n\t\t\t\t    unsigned char data, unsigned int flags)\n{\n\tstruct iforce_serio *iforce_serio = serio_get_drvdata(serio);\n\tstruct iforce *iforce = &iforce_serio->iforce;\n\n\tif (!iforce_serio->pkt) {\n\t\tif (data == 0x2b)\n\t\t\tiforce_serio->pkt = 1;\n\t\tgoto out;\n\t}\n\n\tif (!iforce_serio->id) {\n\t\tif (data > 3 && data != 0xff)\n\t\t\tiforce_serio->pkt = 0;\n\t\telse\n\t\t\tiforce_serio->id = data;\n\t\tgoto out;\n\t}\n\n\tif (!iforce_serio->len) {\n\t\tif (data > IFORCE_MAX_LENGTH) {\n\t\t\tiforce_serio->pkt = 0;\n\t\t\tiforce_serio->id = 0;\n\t\t} else {\n\t\t\tiforce_serio->len = data;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (iforce_serio->idx < iforce_serio->len) {\n\t\tiforce_serio->data_in[iforce_serio->idx++] = data;\n\t\tiforce_serio->csum += data;\n\t\tgoto out;\n\t}\n\n\tif (iforce_serio->idx == iforce_serio->len) {\n\t\t \n\t\tif (iforce_serio->expect_packet == iforce_serio->id) {\n\t\t\tiforce_serio->expect_packet = 0;\n\t\t\tmemcpy(iforce_serio->cmd_response,\n\t\t\t       iforce_serio->data_in, IFORCE_MAX_LENGTH);\n\t\t\tiforce_serio->cmd_response_len = iforce_serio->len;\n\n\t\t\t \n\t\t\twake_up_all(&iforce->wait);\n\t\t} else if (likely(iforce->type)) {\n\t\t\tiforce_process_packet(iforce, iforce_serio->id,\n\t\t\t\t\t      iforce_serio->data_in,\n\t\t\t\t\t      iforce_serio->len);\n\t\t}\n\n\t\tiforce_serio->pkt = 0;\n\t\tiforce_serio->id  = 0;\n\t\tiforce_serio->len = 0;\n\t\tiforce_serio->idx = 0;\n\t\tiforce_serio->csum = 0;\n\t}\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct iforce_serio *iforce_serio;\n\tint err;\n\n\tiforce_serio = kzalloc(sizeof(*iforce_serio), GFP_KERNEL);\n\tif (!iforce_serio)\n\t\treturn -ENOMEM;\n\n\tiforce_serio->iforce.xport_ops = &iforce_serio_xport_ops;\n\n\tiforce_serio->serio = serio;\n\tserio_set_drvdata(serio, iforce_serio);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail1;\n\n\terr = iforce_init_device(&serio->dev, BUS_RS232, &iforce_serio->iforce);\n\tif (err)\n\t\tgoto fail2;\n\n\treturn 0;\n\n fail2:\tserio_close(serio);\n fail1:\tserio_set_drvdata(serio, NULL);\n\tkfree(iforce_serio);\n\treturn err;\n}\n\nstatic void iforce_serio_disconnect(struct serio *serio)\n{\n\tstruct iforce_serio *iforce_serio = serio_get_drvdata(serio);\n\n\tinput_unregister_device(iforce_serio->iforce.dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(iforce_serio);\n}\n\nstatic const struct serio_device_id iforce_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_IFORCE,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, iforce_serio_ids);\n\nstruct serio_driver iforce_serio_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"iforce\",\n\t},\n\t.description\t= \"RS232 I-Force joysticks and wheels driver\",\n\t.id_table\t= iforce_serio_ids,\n\t.write_wakeup\t= iforce_serio_write_wakeup,\n\t.interrupt\t= iforce_serio_irq,\n\t.connect\t= iforce_serio_connect,\n\t.disconnect\t= iforce_serio_disconnect,\n};\n\nmodule_serio_driver(iforce_serio_drv);\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>, Johann Deneux <johann.deneux@gmail.com>\");\nMODULE_DESCRIPTION(\"RS232 I-Force joysticks and wheels driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}