{
  "module_name": "iforce-main.c",
  "hash_id": "4ccc79918d35fb479ad10ea8fe6b9b1ce8edd2e75ef32c490ec7b2d9b8ef9449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/iforce/iforce-main.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include \"iforce.h\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>, Johann Deneux <johann.deneux@gmail.com>\");\nMODULE_DESCRIPTION(\"Core I-Force joysticks and wheels driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic signed short btn_joystick[] =\n{ BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_TOP2, BTN_BASE,\n  BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_BASE5, BTN_A,\n  BTN_B, BTN_C, BTN_DEAD, -1 };\n\nstatic signed short btn_joystick_avb[] =\n{ BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE,\n  BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_DEAD, -1 };\n\nstatic signed short btn_wheel[] =\n{ BTN_GEAR_DOWN, BTN_GEAR_UP, BTN_BASE, BTN_BASE2, BTN_BASE3,\n  BTN_BASE4, BTN_BASE5, BTN_BASE6, -1 };\n\nstatic signed short abs_joystick[] =\n{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, -1 };\n\nstatic signed short abs_joystick_rudder[] =\n{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER, ABS_HAT0X, ABS_HAT0Y, -1 };\n\nstatic signed short abs_avb_pegasus[] =\n{ ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER, ABS_HAT0X, ABS_HAT0Y,\n  ABS_HAT1X, ABS_HAT1Y, -1 };\n\nstatic signed short abs_wheel[] =\n{ ABS_WHEEL, ABS_GAS, ABS_BRAKE, ABS_HAT0X, ABS_HAT0Y, -1 };\n\nstatic signed short ff_iforce[] =\n{ FF_PERIODIC, FF_CONSTANT, FF_SPRING, FF_DAMPER,\n  FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP, FF_SAW_DOWN, FF_GAIN,\n  FF_AUTOCENTER, -1 };\n\nstatic struct iforce_device iforce_device[] = {\n\t{ 0x044f, 0xa01c, \"Thrustmaster Motor Sport GT\",\t\tbtn_wheel, abs_wheel, ff_iforce },\n\t{ 0x046d, 0xc281, \"Logitech WingMan Force\",\t\t\tbtn_joystick, abs_joystick, ff_iforce },\n\t{ 0x046d, 0xc291, \"Logitech WingMan Formula Force\",\t\tbtn_wheel, abs_wheel, ff_iforce },\n\t{ 0x05ef, 0x020a, \"AVB Top Shot Pegasus\",\t\t\tbtn_joystick_avb, abs_avb_pegasus, ff_iforce },\n\t{ 0x05ef, 0x8884, \"AVB Mag Turbo Force\",\t\t\tbtn_wheel, abs_wheel, ff_iforce },\n\t{ 0x05ef, 0x8886, \"Boeder Force Feedback Wheel\",\t\tbtn_wheel, abs_wheel, ff_iforce },\n\t{ 0x05ef, 0x8888, \"AVB Top Shot Force Feedback Racing Wheel\",\tbtn_wheel, abs_wheel, ff_iforce }, \n\t{ 0x061c, 0xc0a4, \"ACT LABS Force RS\",                          btn_wheel, abs_wheel, ff_iforce }, \n\t{ 0x061c, 0xc084, \"ACT LABS Force RS\",\t\t\t\tbtn_wheel, abs_wheel, ff_iforce },\n\t{ 0x06a3, 0xff04, \"Saitek R440 Force Wheel\",\t\t\tbtn_wheel, abs_wheel, ff_iforce }, \n\t{ 0x06f8, 0x0001, \"Guillemot Race Leader Force Feedback\",\tbtn_wheel, abs_wheel, ff_iforce }, \n\t{ 0x06f8, 0x0001, \"Guillemot Jet Leader Force Feedback\",\tbtn_joystick, abs_joystick_rudder, ff_iforce },\n\t{ 0x06f8, 0x0004, \"Guillemot Force Feedback Racing Wheel\",\tbtn_wheel, abs_wheel, ff_iforce }, \n\t{ 0x06f8, 0xa302, \"Guillemot Jet Leader 3D\",\t\t\tbtn_joystick, abs_joystick, ff_iforce }, \n\t{ 0x06d6, 0x29bc, \"Trust Force Feedback Race Master\",\t\tbtn_wheel, abs_wheel, ff_iforce },\n\t{ 0x0000, 0x0000, \"Unknown I-Force Device [%04x:%04x]\",\t\tbtn_joystick, abs_joystick, ff_iforce }\n};\n\nstatic int iforce_playback(struct input_dev *dev, int effect_id, int value)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\tstruct iforce_core_effect *core_effect = &iforce->core_effects[effect_id];\n\n\tif (value > 0)\n\t\tset_bit(FF_CORE_SHOULD_PLAY, core_effect->flags);\n\telse\n\t\tclear_bit(FF_CORE_SHOULD_PLAY, core_effect->flags);\n\n\tiforce_control_playback(iforce, effect_id, value);\n\treturn 0;\n}\n\nstatic void iforce_set_gain(struct input_dev *dev, u16 gain)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\tunsigned char data[3];\n\n\tdata[0] = gain >> 9;\n\tiforce_send_packet(iforce, FF_CMD_GAIN, data);\n}\n\nstatic void iforce_set_autocenter(struct input_dev *dev, u16 magnitude)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\tunsigned char data[3];\n\n\tdata[0] = 0x03;\n\tdata[1] = magnitude >> 9;\n\tiforce_send_packet(iforce, FF_CMD_AUTOCENTER, data);\n\n\tdata[0] = 0x04;\n\tdata[1] = 0x01;\n\tiforce_send_packet(iforce, FF_CMD_AUTOCENTER, data);\n}\n\n \nstatic int iforce_upload_effect(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\tstruct iforce_core_effect *core_effect = &iforce->core_effects[effect->id];\n\tint ret;\n\n\tif (__test_and_set_bit(FF_CORE_IS_USED, core_effect->flags)) {\n\t\t \n\t\tif (test_bit(FF_CORE_UPDATE, core_effect->flags))\n\t\t\treturn -EAGAIN;\n\t}\n\n \n\tswitch (effect->type) {\n\tcase FF_PERIODIC:\n\t\tret = iforce_upload_periodic(iforce, effect, old);\n\t\tbreak;\n\n\tcase FF_CONSTANT:\n\t\tret = iforce_upload_constant(iforce, effect, old);\n\t\tbreak;\n\n\tcase FF_SPRING:\n\tcase FF_DAMPER:\n\t\tret = iforce_upload_condition(iforce, effect, old);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret == 0) {\n\t\t \n\t\tset_bit(FF_CORE_UPDATE, core_effect->flags);\n\t}\n\treturn ret;\n}\n\n \nstatic int iforce_erase_effect(struct input_dev *dev, int effect_id)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\tstruct iforce_core_effect *core_effect = &iforce->core_effects[effect_id];\n\tint err = 0;\n\n\tif (test_bit(FF_MOD1_IS_USED, core_effect->flags))\n\t\terr = release_resource(&core_effect->mod1_chunk);\n\n\tif (!err && test_bit(FF_MOD2_IS_USED, core_effect->flags))\n\t\terr = release_resource(&core_effect->mod2_chunk);\n\n\t \n\tcore_effect->flags[0] = 0;\n\n\treturn err;\n}\n\nstatic int iforce_open(struct input_dev *dev)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\n\tiforce->xport_ops->start_io(iforce);\n\n\tif (test_bit(EV_FF, dev->evbit)) {\n\t\t \n\t\tiforce_send_packet(iforce, FF_CMD_ENABLE, \"\\004\");\n\t}\n\n\treturn 0;\n}\n\nstatic void iforce_close(struct input_dev *dev)\n{\n\tstruct iforce *iforce = input_get_drvdata(dev);\n\tint i;\n\n\tif (test_bit(EV_FF, dev->evbit)) {\n\t\t \n\t\tfor (i = 0; i < dev->ff->max_effects; i++) {\n\t\t\tif (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags)) {\n\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t\"%s: Device still owns effects\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tiforce_send_packet(iforce, FF_CMD_ENABLE, \"\\001\");\n\t\t \n\t\twait_event_interruptible(iforce->wait,\n\t\t\t!test_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags));\n\t}\n\n\tiforce->xport_ops->stop_io(iforce);\n}\n\nint iforce_init_device(struct device *parent, u16 bustype,\n\t\t       struct iforce *iforce)\n{\n\tstruct input_dev *input_dev;\n\tstruct ff_device *ff;\n\tu8 c[] = \"CEOV\";\n\tu8 buf[IFORCE_MAX_LENGTH];\n\tsize_t len;\n\tint i, error;\n\tint ff_effects = 0;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&iforce->wait);\n\tspin_lock_init(&iforce->xmit_lock);\n\tmutex_init(&iforce->mem_mutex);\n\tiforce->xmit.buf = iforce->xmit_data;\n\tiforce->dev = input_dev;\n\n \n\n\tinput_dev->id.bustype = bustype;\n\tinput_dev->dev.parent = parent;\n\n\tinput_set_drvdata(input_dev, iforce);\n\n\tinput_dev->name = \"Unknown I-Force device\";\n\tinput_dev->open = iforce_open;\n\tinput_dev->close = iforce_close;\n\n \n\n\tiforce->device_memory.name = \"I-Force device effect memory\";\n\tiforce->device_memory.start = 0;\n\tiforce->device_memory.end = 200;\n\tiforce->device_memory.flags = IORESOURCE_MEM;\n\tiforce->device_memory.parent = NULL;\n\tiforce->device_memory.child = NULL;\n\tiforce->device_memory.sibling = NULL;\n\n \n\n\tfor (i = 0; i < 20; i++)\n\t\tif (!iforce_get_id_packet(iforce, 'O', buf, &len))\n\t\t\tbreak;\n\n\tif (i == 20) {  \n\t\tdev_err(&input_dev->dev,\n\t\t\t\"Timeout waiting for response from device.\\n\");\n\t\terror = -ENODEV;\n\t\tgoto fail;\n\t}\n\n \n\n\tif (!iforce_get_id_packet(iforce, 'M', buf, &len) && len >= 3)\n\t\tinput_dev->id.vendor = get_unaligned_le16(buf + 1);\n\telse\n\t\tdev_warn(&iforce->dev->dev, \"Device does not respond to id packet M\\n\");\n\n\tif (!iforce_get_id_packet(iforce, 'P', buf, &len) && len >= 3)\n\t\tinput_dev->id.product = get_unaligned_le16(buf + 1);\n\telse\n\t\tdev_warn(&iforce->dev->dev, \"Device does not respond to id packet P\\n\");\n\n\tif (!iforce_get_id_packet(iforce, 'B', buf, &len) && len >= 3)\n\t\tiforce->device_memory.end = get_unaligned_le16(buf + 1);\n\telse\n\t\tdev_warn(&iforce->dev->dev, \"Device does not respond to id packet B\\n\");\n\n\tif (!iforce_get_id_packet(iforce, 'N', buf, &len) && len >= 2)\n\t\tff_effects = buf[1];\n\telse\n\t\tdev_warn(&iforce->dev->dev, \"Device does not respond to id packet N\\n\");\n\n\t \n\tif (ff_effects > IFORCE_EFFECTS_MAX) {\n\t\tdev_warn(&iforce->dev->dev, \"Limiting number of effects to %d (device reports %d)\\n\",\n\t\t       IFORCE_EFFECTS_MAX, ff_effects);\n\t\tff_effects = IFORCE_EFFECTS_MAX;\n\t}\n\n \n\n\tfor (i = 0; c[i]; i++)\n\t\tif (!iforce_get_id_packet(iforce, c[i], buf, &len))\n\t\t\tiforce_dump_packet(iforce, \"info\",\n\t\t\t\t\t   (FF_CMD_QUERY & 0xff00) | len, buf);\n\n \n\tiforce_set_autocenter(input_dev, 0);\n\n \n\n\tfor (i = 0; iforce_device[i].idvendor; i++)\n\t\tif (iforce_device[i].idvendor == input_dev->id.vendor &&\n\t\t    iforce_device[i].idproduct == input_dev->id.product)\n\t\t\tbreak;\n\n\tiforce->type = iforce_device + i;\n\tinput_dev->name = iforce->type->name;\n\n \n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) |\n\t\tBIT_MASK(EV_FF_STATUS);\n\n\tfor (i = 0; iforce->type->btn[i] >= 0; i++)\n\t\tset_bit(iforce->type->btn[i], input_dev->keybit);\n\n\tfor (i = 0; iforce->type->abs[i] >= 0; i++) {\n\n\t\tsigned short t = iforce->type->abs[i];\n\n\t\tswitch (t) {\n\t\tcase ABS_X:\n\t\tcase ABS_Y:\n\t\tcase ABS_WHEEL:\n\t\t\tinput_set_abs_params(input_dev, t, -1920, 1920, 16, 128);\n\t\t\tset_bit(t, input_dev->ffbit);\n\t\t\tbreak;\n\n\t\tcase ABS_THROTTLE:\n\t\tcase ABS_GAS:\n\t\tcase ABS_BRAKE:\n\t\t\tinput_set_abs_params(input_dev, t, 0, 255, 0, 0);\n\t\t\tbreak;\n\n\t\tcase ABS_RUDDER:\n\t\t\tinput_set_abs_params(input_dev, t, -128, 127, 0, 0);\n\t\t\tbreak;\n\n\t\tcase ABS_HAT0X:\n\t\tcase ABS_HAT0Y:\n\t\tcase ABS_HAT1X:\n\t\tcase ABS_HAT1Y:\n\t\t\tinput_set_abs_params(input_dev, t, -1, 1, 0, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ff_effects) {\n\n\t\tfor (i = 0; iforce->type->ff[i] >= 0; i++)\n\t\t\tset_bit(iforce->type->ff[i], input_dev->ffbit);\n\n\t\terror = input_ff_create(input_dev, ff_effects);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tff = input_dev->ff;\n\t\tff->upload = iforce_upload_effect;\n\t\tff->erase = iforce_erase_effect;\n\t\tff->set_gain = iforce_set_gain;\n\t\tff->set_autocenter = iforce_set_autocenter;\n\t\tff->playback = iforce_playback;\n\t}\n \n\n\terror = input_register_device(iforce->dev);\n\tif (error)\n\t\tgoto fail;\n\n\treturn 0;\n\n fail:\tinput_free_device(input_dev);\n\treturn error;\n}\nEXPORT_SYMBOL(iforce_init_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}