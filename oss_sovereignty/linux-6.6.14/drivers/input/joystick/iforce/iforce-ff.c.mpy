{
  "module_name": "iforce-ff.c",
  "hash_id": "9ca6d6359742a009c6160a868c116259667662779dabf9d7d11c4878210699e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/iforce/iforce-ff.c",
  "human_readable_source": "\n \n\n#include \"iforce.h\"\n\n \n\nstatic int make_magnitude_modifier(struct iforce* iforce,\n\tstruct resource* mod_chunk, int no_alloc, __s16 level)\n{\n\tunsigned char data[3];\n\n\tif (!no_alloc) {\n\t\tmutex_lock(&iforce->mem_mutex);\n\t\tif (allocate_resource(&(iforce->device_memory), mod_chunk, 2,\n\t\t\tiforce->device_memory.start, iforce->device_memory.end, 2L,\n\t\t\tNULL, NULL)) {\n\t\t\tmutex_unlock(&iforce->mem_mutex);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmutex_unlock(&iforce->mem_mutex);\n\t}\n\n\tdata[0] = LO(mod_chunk->start);\n\tdata[1] = HI(mod_chunk->start);\n\tdata[2] = HIFIX80(level);\n\n\tiforce_send_packet(iforce, FF_CMD_MAGNITUDE, data);\n\n\tiforce_dump_packet(iforce, \"magnitude\", FF_CMD_MAGNITUDE, data);\n\treturn 0;\n}\n\n \n\nstatic int make_period_modifier(struct iforce* iforce,\n\tstruct resource* mod_chunk, int no_alloc,\n\t__s16 magnitude, __s16 offset, u16 period, u16 phase)\n{\n\tunsigned char data[7];\n\n\tperiod = TIME_SCALE(period);\n\n\tif (!no_alloc) {\n\t\tmutex_lock(&iforce->mem_mutex);\n\t\tif (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0c,\n\t\t\tiforce->device_memory.start, iforce->device_memory.end, 2L,\n\t\t\tNULL, NULL)) {\n\t\t\tmutex_unlock(&iforce->mem_mutex);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmutex_unlock(&iforce->mem_mutex);\n\t}\n\n\tdata[0] = LO(mod_chunk->start);\n\tdata[1] = HI(mod_chunk->start);\n\n\tdata[2] = HIFIX80(magnitude);\n\tdata[3] = HIFIX80(offset);\n\tdata[4] = HI(phase);\n\n\tdata[5] = LO(period);\n\tdata[6] = HI(period);\n\n\tiforce_send_packet(iforce, FF_CMD_PERIOD, data);\n\n\treturn 0;\n}\n\n \n\nstatic int make_envelope_modifier(struct iforce* iforce,\n\tstruct resource* mod_chunk, int no_alloc,\n\tu16 attack_duration, __s16 initial_level,\n\tu16 fade_duration, __s16 final_level)\n{\n\tunsigned char data[8];\n\n\tattack_duration = TIME_SCALE(attack_duration);\n\tfade_duration = TIME_SCALE(fade_duration);\n\n\tif (!no_alloc) {\n\t\tmutex_lock(&iforce->mem_mutex);\n\t\tif (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0e,\n\t\t\tiforce->device_memory.start, iforce->device_memory.end, 2L,\n\t\t\tNULL, NULL)) {\n\t\t\tmutex_unlock(&iforce->mem_mutex);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmutex_unlock(&iforce->mem_mutex);\n\t}\n\n\tdata[0] = LO(mod_chunk->start);\n\tdata[1] = HI(mod_chunk->start);\n\n\tdata[2] = LO(attack_duration);\n\tdata[3] = HI(attack_duration);\n\tdata[4] = HI(initial_level);\n\n\tdata[5] = LO(fade_duration);\n\tdata[6] = HI(fade_duration);\n\tdata[7] = HI(final_level);\n\n\tiforce_send_packet(iforce, FF_CMD_ENVELOPE, data);\n\n\treturn 0;\n}\n\n \n\nstatic int make_condition_modifier(struct iforce* iforce,\n\tstruct resource* mod_chunk, int no_alloc,\n\t__u16 rsat, __u16 lsat, __s16 rk, __s16 lk, u16 db, __s16 center)\n{\n\tunsigned char data[10];\n\n\tif (!no_alloc) {\n\t\tmutex_lock(&iforce->mem_mutex);\n\t\tif (allocate_resource(&(iforce->device_memory), mod_chunk, 8,\n\t\t\tiforce->device_memory.start, iforce->device_memory.end, 2L,\n\t\t\tNULL, NULL)) {\n\t\t\tmutex_unlock(&iforce->mem_mutex);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tmutex_unlock(&iforce->mem_mutex);\n\t}\n\n\tdata[0] = LO(mod_chunk->start);\n\tdata[1] = HI(mod_chunk->start);\n\n\tdata[2] = (100 * rk) >> 15;\t \n\tdata[3] = (100 * lk) >> 15;  \n\n\tcenter = (500 * center) >> 15;\n\tdata[4] = LO(center);\n\tdata[5] = HI(center);\n\n\tdb = (1000 * db) >> 16;\n\tdata[6] = LO(db);\n\tdata[7] = HI(db);\n\n\tdata[8] = (100 * rsat) >> 16;\n\tdata[9] = (100 * lsat) >> 16;\n\n\tiforce_send_packet(iforce, FF_CMD_CONDITION, data);\n\tiforce_dump_packet(iforce, \"condition\", FF_CMD_CONDITION, data);\n\n\treturn 0;\n}\n\nstatic unsigned char find_button(struct iforce *iforce, signed short button)\n{\n\tint i;\n\n\tfor (i = 1; iforce->type->btn[i] >= 0; i++)\n\t\tif (iforce->type->btn[i] == button)\n\t\t\treturn i + 1;\n\treturn 0;\n}\n\n \nstatic int need_condition_modifier(struct iforce *iforce,\n\t\t\t\t   struct ff_effect *old,\n\t\t\t\t   struct ff_effect *new)\n{\n\tint ret = 0;\n\tint i;\n\n\tif (new->type != FF_SPRING && new->type != FF_FRICTION) {\n\t\tdev_warn(&iforce->dev->dev, \"bad effect type in %s\\n\",\n\t\t\t __func__);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tret |= old->u.condition[i].right_saturation != new->u.condition[i].right_saturation\n\t\t\t|| old->u.condition[i].left_saturation != new->u.condition[i].left_saturation\n\t\t\t|| old->u.condition[i].right_coeff != new->u.condition[i].right_coeff\n\t\t\t|| old->u.condition[i].left_coeff != new->u.condition[i].left_coeff\n\t\t\t|| old->u.condition[i].deadband != new->u.condition[i].deadband\n\t\t\t|| old->u.condition[i].center != new->u.condition[i].center;\n\t}\n\treturn ret;\n}\n\n \nstatic int need_magnitude_modifier(struct iforce *iforce,\n\t\t\t\t   struct ff_effect *old,\n\t\t\t\t   struct ff_effect *effect)\n{\n\tif (effect->type != FF_CONSTANT) {\n\t\tdev_warn(&iforce->dev->dev, \"bad effect type in %s\\n\",\n\t\t\t __func__);\n\t\treturn 0;\n\t}\n\n\treturn old->u.constant.level != effect->u.constant.level;\n}\n\n \nstatic int need_envelope_modifier(struct iforce *iforce, struct ff_effect *old,\n\t\t\t\t  struct ff_effect *effect)\n{\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n\t\tif (old->u.constant.envelope.attack_length != effect->u.constant.envelope.attack_length\n\t\t|| old->u.constant.envelope.attack_level != effect->u.constant.envelope.attack_level\n\t\t|| old->u.constant.envelope.fade_length != effect->u.constant.envelope.fade_length\n\t\t|| old->u.constant.envelope.fade_level != effect->u.constant.envelope.fade_level)\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase FF_PERIODIC:\n\t\tif (old->u.periodic.envelope.attack_length != effect->u.periodic.envelope.attack_length\n\t\t|| old->u.periodic.envelope.attack_level != effect->u.periodic.envelope.attack_level\n\t\t|| old->u.periodic.envelope.fade_length != effect->u.periodic.envelope.fade_length\n\t\t|| old->u.periodic.envelope.fade_level != effect->u.periodic.envelope.fade_level)\n\t\t\treturn 1;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&iforce->dev->dev, \"bad effect type in %s\\n\",\n\t\t\t __func__);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int need_period_modifier(struct iforce *iforce, struct ff_effect *old,\n\t\t\t\tstruct ff_effect *new)\n{\n\tif (new->type != FF_PERIODIC) {\n\t\tdev_warn(&iforce->dev->dev, \"bad effect type in %s\\n\",\n\t\t\t __func__);\n\t\treturn 0;\n\t}\n\treturn (old->u.periodic.period != new->u.periodic.period\n\t\t|| old->u.periodic.magnitude != new->u.periodic.magnitude\n\t\t|| old->u.periodic.offset != new->u.periodic.offset\n\t\t|| old->u.periodic.phase != new->u.periodic.phase);\n}\n\n \nstatic int need_core(struct ff_effect *old, struct ff_effect *new)\n{\n\tif (old->direction != new->direction\n\t\t|| old->trigger.button != new->trigger.button\n\t\t|| old->trigger.interval != new->trigger.interval\n\t\t|| old->replay.length != new->replay.length\n\t\t|| old->replay.delay != new->replay.delay)\n\t\treturn 1;\n\n\treturn 0;\n}\n \nstatic int make_core(struct iforce* iforce, u16 id, u16 mod_id1, u16 mod_id2,\n\tu8 effect_type, u8 axes, u16 duration, u16 delay, u16 button,\n\tu16 interval, u16 direction)\n{\n\tunsigned char data[14];\n\n\tduration = TIME_SCALE(duration);\n\tdelay    = TIME_SCALE(delay);\n\tinterval = TIME_SCALE(interval);\n\n\tdata[0]  = LO(id);\n\tdata[1]  = effect_type;\n\tdata[2]  = LO(axes) | find_button(iforce, button);\n\n\tdata[3]  = LO(duration);\n\tdata[4]  = HI(duration);\n\n\tdata[5]  = HI(direction);\n\n\tdata[6]  = LO(interval);\n\tdata[7]  = HI(interval);\n\n\tdata[8]  = LO(mod_id1);\n\tdata[9]  = HI(mod_id1);\n\tdata[10] = LO(mod_id2);\n\tdata[11] = HI(mod_id2);\n\n\tdata[12] = LO(delay);\n\tdata[13] = HI(delay);\n\n\t \n \n\n\tiforce_send_packet(iforce, FF_CMD_EFFECT, data);\n\n\t \n\tif (test_bit(FF_CORE_SHOULD_PLAY, iforce->core_effects[id].flags)) {\n\t\t \n\t\tiforce_control_playback(iforce, id, 1);\n\t}\n\n\treturn 0;\n}\n\n \nint iforce_upload_periodic(struct iforce *iforce, struct ff_effect *effect, struct ff_effect *old)\n{\n\tu8 wave_code;\n\tint core_id = effect->id;\n\tstruct iforce_core_effect* core_effect = iforce->core_effects + core_id;\n\tstruct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);\n\tstruct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);\n\tint param1_err = 1;\n\tint param2_err = 1;\n\tint core_err = 0;\n\n\tif (!old || need_period_modifier(iforce, old, effect)) {\n\t\tparam1_err = make_period_modifier(iforce, mod1_chunk,\n\t\t\told != NULL,\n\t\t\teffect->u.periodic.magnitude, effect->u.periodic.offset,\n\t\t\teffect->u.periodic.period, effect->u.periodic.phase);\n\t\tif (param1_err)\n\t\t\treturn param1_err;\n\t\tset_bit(FF_MOD1_IS_USED, core_effect->flags);\n\t}\n\n\tif (!old || need_envelope_modifier(iforce, old, effect)) {\n\t\tparam2_err = make_envelope_modifier(iforce, mod2_chunk,\n\t\t\told !=NULL,\n\t\t\teffect->u.periodic.envelope.attack_length,\n\t\t\teffect->u.periodic.envelope.attack_level,\n\t\t\teffect->u.periodic.envelope.fade_length,\n\t\t\teffect->u.periodic.envelope.fade_level);\n\t\tif (param2_err)\n\t\t\treturn param2_err;\n\t\tset_bit(FF_MOD2_IS_USED, core_effect->flags);\n\t}\n\n\tswitch (effect->u.periodic.waveform) {\n\tcase FF_SQUARE:\t\twave_code = 0x20; break;\n\tcase FF_TRIANGLE:\twave_code = 0x21; break;\n\tcase FF_SINE:\t\twave_code = 0x22; break;\n\tcase FF_SAW_UP:\t\twave_code = 0x23; break;\n\tcase FF_SAW_DOWN:\twave_code = 0x24; break;\n\tdefault:\t\twave_code = 0x20; break;\n\t}\n\n\tif (!old || need_core(old, effect)) {\n\t\tcore_err = make_core(iforce, effect->id,\n\t\t\tmod1_chunk->start,\n\t\t\tmod2_chunk->start,\n\t\t\twave_code,\n\t\t\t0x20,\n\t\t\teffect->replay.length,\n\t\t\teffect->replay.delay,\n\t\t\teffect->trigger.button,\n\t\t\teffect->trigger.interval,\n\t\t\teffect->direction);\n\t}\n\n\t \n\treturn core_err < 0 ? core_err : (param1_err && param2_err);\n}\n\n \nint iforce_upload_constant(struct iforce *iforce, struct ff_effect *effect, struct ff_effect *old)\n{\n\tint core_id = effect->id;\n\tstruct iforce_core_effect* core_effect = iforce->core_effects + core_id;\n\tstruct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);\n\tstruct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);\n\tint param1_err = 1;\n\tint param2_err = 1;\n\tint core_err = 0;\n\n\tif (!old || need_magnitude_modifier(iforce, old, effect)) {\n\t\tparam1_err = make_magnitude_modifier(iforce, mod1_chunk,\n\t\t\told != NULL,\n\t\t\teffect->u.constant.level);\n\t\tif (param1_err)\n\t\t\treturn param1_err;\n\t\tset_bit(FF_MOD1_IS_USED, core_effect->flags);\n\t}\n\n\tif (!old || need_envelope_modifier(iforce, old, effect)) {\n\t\tparam2_err = make_envelope_modifier(iforce, mod2_chunk,\n\t\t\told != NULL,\n\t\t\teffect->u.constant.envelope.attack_length,\n\t\t\teffect->u.constant.envelope.attack_level,\n\t\t\teffect->u.constant.envelope.fade_length,\n\t\t\teffect->u.constant.envelope.fade_level);\n\t\tif (param2_err)\n\t\t\treturn param2_err;\n\t\tset_bit(FF_MOD2_IS_USED, core_effect->flags);\n\t}\n\n\tif (!old || need_core(old, effect)) {\n\t\tcore_err = make_core(iforce, effect->id,\n\t\t\tmod1_chunk->start,\n\t\t\tmod2_chunk->start,\n\t\t\t0x00,\n\t\t\t0x20,\n\t\t\teffect->replay.length,\n\t\t\teffect->replay.delay,\n\t\t\teffect->trigger.button,\n\t\t\teffect->trigger.interval,\n\t\t\teffect->direction);\n\t}\n\n\t \n\treturn core_err < 0 ? core_err : (param1_err && param2_err);\n}\n\n \nint iforce_upload_condition(struct iforce *iforce, struct ff_effect *effect, struct ff_effect *old)\n{\n\tint core_id = effect->id;\n\tstruct iforce_core_effect* core_effect = iforce->core_effects + core_id;\n\tstruct resource* mod1_chunk = &(core_effect->mod1_chunk);\n\tstruct resource* mod2_chunk = &(core_effect->mod2_chunk);\n\tu8 type;\n\tint param_err = 1;\n\tint core_err = 0;\n\n\tswitch (effect->type) {\n\tcase FF_SPRING:\ttype = 0x40; break;\n\tcase FF_DAMPER:\ttype = 0x41; break;\n\tdefault: return -1;\n\t}\n\n\tif (!old || need_condition_modifier(iforce, old, effect)) {\n\t\tparam_err = make_condition_modifier(iforce, mod1_chunk,\n\t\t\told != NULL,\n\t\t\teffect->u.condition[0].right_saturation,\n\t\t\teffect->u.condition[0].left_saturation,\n\t\t\teffect->u.condition[0].right_coeff,\n\t\t\teffect->u.condition[0].left_coeff,\n\t\t\teffect->u.condition[0].deadband,\n\t\t\teffect->u.condition[0].center);\n\t\tif (param_err)\n\t\t\treturn param_err;\n\t\tset_bit(FF_MOD1_IS_USED, core_effect->flags);\n\n\t\tparam_err = make_condition_modifier(iforce, mod2_chunk,\n\t\t\told != NULL,\n\t\t\teffect->u.condition[1].right_saturation,\n\t\t\teffect->u.condition[1].left_saturation,\n\t\t\teffect->u.condition[1].right_coeff,\n\t\t\teffect->u.condition[1].left_coeff,\n\t\t\teffect->u.condition[1].deadband,\n\t\t\teffect->u.condition[1].center);\n\t\tif (param_err)\n\t\t\treturn param_err;\n\t\tset_bit(FF_MOD2_IS_USED, core_effect->flags);\n\n\t}\n\n\tif (!old || need_core(old, effect)) {\n\t\tcore_err = make_core(iforce, effect->id,\n\t\t\tmod1_chunk->start, mod2_chunk->start,\n\t\t\ttype, 0xc0,\n\t\t\teffect->replay.length, effect->replay.delay,\n\t\t\teffect->trigger.button, effect->trigger.interval,\n\t\t\teffect->direction);\n\t}\n\n\t \n\treturn core_err < 0 ? core_err : param_err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}