{
  "module_name": "iforce-packets.c",
  "hash_id": "6508ab01eac977a8dbac1d9b5c13896a0f928de1f17ba4969d30aaff1548634b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/iforce/iforce-packets.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include \"iforce.h\"\n\nstatic struct {\n\t__s32 x;\n\t__s32 y;\n} iforce_hat_to_axis[16] = {{ 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};\n\n\nvoid iforce_dump_packet(struct iforce *iforce, char *msg, u16 cmd, unsigned char *data)\n{\n\tdev_dbg(iforce->dev->dev.parent, \"%s %s cmd = %04x, data = %*ph\\n\",\n\t\t__func__, msg, cmd, LO(cmd), data);\n}\n\n \nint iforce_send_packet(struct iforce *iforce, u16 cmd, unsigned char* data)\n{\n\t \n\tint n = LO(cmd);\n\tint c;\n\tint empty;\n\tint head, tail;\n\tunsigned long flags;\n\n \n\tspin_lock_irqsave(&iforce->xmit_lock, flags);\n\n\thead = iforce->xmit.head;\n\ttail = iforce->xmit.tail;\n\n\n\tif (CIRC_SPACE(head, tail, XMIT_SIZE) < n+2) {\n\t\tdev_warn(&iforce->dev->dev,\n\t\t\t \"not enough space in xmit buffer to send new packet\\n\");\n\t\tspin_unlock_irqrestore(&iforce->xmit_lock, flags);\n\t\treturn -1;\n\t}\n\n\tempty = head == tail;\n\tXMIT_INC(iforce->xmit.head, n+2);\n\n \n\tiforce->xmit.buf[head] = HI(cmd);\n\tXMIT_INC(head, 1);\n\tiforce->xmit.buf[head] = LO(cmd);\n\tXMIT_INC(head, 1);\n\n\tc = CIRC_SPACE_TO_END(head, tail, XMIT_SIZE);\n\tif (n < c) c=n;\n\n\tmemcpy(&iforce->xmit.buf[head],\n\t       data,\n\t       c);\n\tif (n != c) {\n\t\tmemcpy(&iforce->xmit.buf[0],\n\t\t       data + c,\n\t\t       n - c);\n\t}\n\tXMIT_INC(head, n);\n\n\tspin_unlock_irqrestore(&iforce->xmit_lock, flags);\n \n\tif (empty)\n\t\tiforce->xport_ops->xmit(iforce);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iforce_send_packet);\n\n \nint iforce_control_playback(struct iforce* iforce, u16 id, unsigned int value)\n{\n\tunsigned char data[3];\n\n\tdata[0] = LO(id);\n\tdata[1] = (value > 0) ? ((value > 1) ? 0x41 : 0x01) : 0;\n\tdata[2] = LO(value);\n\treturn iforce_send_packet(iforce, FF_CMD_PLAY, data);\n}\n\n \nstatic int mark_core_as_ready(struct iforce *iforce, unsigned short addr)\n{\n\tint i;\n\n\tif (!iforce->dev->ff)\n\t\treturn 0;\n\n\tfor (i = 0; i < iforce->dev->ff->max_effects; ++i) {\n\t\tif (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags) &&\n\t\t    (iforce->core_effects[i].mod1_chunk.start == addr ||\n\t\t     iforce->core_effects[i].mod2_chunk.start == addr)) {\n\t\t\tclear_bit(FF_CORE_UPDATE, iforce->core_effects[i].flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdev_warn(&iforce->dev->dev, \"unused effect %04x updated !!!\\n\", addr);\n\treturn -1;\n}\n\nstatic void iforce_report_hats_buttons(struct iforce *iforce, u8 *data)\n{\n\tstruct input_dev *dev = iforce->dev;\n\tint i;\n\n\tinput_report_abs(dev, ABS_HAT0X, iforce_hat_to_axis[data[6] >> 4].x);\n\tinput_report_abs(dev, ABS_HAT0Y, iforce_hat_to_axis[data[6] >> 4].y);\n\n\tfor (i = 0; iforce->type->btn[i] >= 0; i++)\n\t\tinput_report_key(dev, iforce->type->btn[i],\n\t\t\t\t data[(i >> 3) + 5] & (1 << (i & 7)));\n\n\t \n\tif (i <= 8) {\n\t\tu8 btns = data[6];\n\n\t\tif (test_bit(ABS_HAT1X, dev->absbit)) {\n\t\t\tif (btns & BIT(3))\n\t\t\t\tinput_report_abs(dev, ABS_HAT1X, -1);\n\t\t\telse if (btns & BIT(1))\n\t\t\t\tinput_report_abs(dev, ABS_HAT1X, 1);\n\t\t\telse\n\t\t\t\tinput_report_abs(dev, ABS_HAT1X, 0);\n\t\t}\n\n\t\tif (test_bit(ABS_HAT1Y, dev->absbit)) {\n\t\t\tif (btns & BIT(0))\n\t\t\t\tinput_report_abs(dev, ABS_HAT1Y, -1);\n\t\t\telse if (btns & BIT(2))\n\t\t\t\tinput_report_abs(dev, ABS_HAT1Y, 1);\n\t\t\telse\n\t\t\t\tinput_report_abs(dev, ABS_HAT1Y, 0);\n\t\t}\n\t}\n}\n\nvoid iforce_process_packet(struct iforce *iforce,\n\t\t\t   u8 packet_id, u8 *data, size_t len)\n{\n\tstruct input_dev *dev = iforce->dev;\n\tint i, j;\n\n\tswitch (packet_id) {\n\n\tcase 0x01:\t \n\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t (__s16) get_unaligned_le16(data));\n\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t (__s16) get_unaligned_le16(data + 2));\n\t\tinput_report_abs(dev, ABS_THROTTLE, 255 - data[4]);\n\n\t\tif (len >= 8 && test_bit(ABS_RUDDER ,dev->absbit))\n\t\t\tinput_report_abs(dev, ABS_RUDDER, (__s8)data[7]);\n\n\t\tiforce_report_hats_buttons(iforce, data);\n\n\t\tinput_sync(dev);\n\t\tbreak;\n\n\tcase 0x03:\t \n\t\tinput_report_abs(dev, ABS_WHEEL,\n\t\t\t\t (__s16) get_unaligned_le16(data));\n\t\tinput_report_abs(dev, ABS_GAS,   255 - data[2]);\n\t\tinput_report_abs(dev, ABS_BRAKE, 255 - data[3]);\n\n\t\tiforce_report_hats_buttons(iforce, data);\n\n\t\tinput_sync(dev);\n\t\tbreak;\n\n\tcase 0x02:\t \n\t\tinput_report_key(dev, BTN_DEAD, data[0] & 0x02);\n\t\tinput_sync(dev);\n\n\t\t \n\t\ti = data[1] & 0x7f;\n\t\tif (data[1] & 0x80) {\n\t\t\tif (!test_and_set_bit(FF_CORE_IS_PLAYED, iforce->core_effects[i].flags)) {\n\t\t\t\t \n\t\t\t\tinput_report_ff_status(dev, i, FF_STATUS_PLAYING);\n\t\t\t}\n\t\t} else if (test_and_clear_bit(FF_CORE_IS_PLAYED, iforce->core_effects[i].flags)) {\n\t\t\t \n\t\t\tinput_report_ff_status(dev, i, FF_STATUS_STOPPED);\n\t\t}\n\n\t\tfor (j = 3; j < len; j += 2)\n\t\t\tmark_core_as_ready(iforce, get_unaligned_le16(data + j));\n\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(iforce_process_packet);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}