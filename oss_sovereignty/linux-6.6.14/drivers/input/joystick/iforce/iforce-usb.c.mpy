{
  "module_name": "iforce-usb.c",
  "hash_id": "f6d1200126b55d1fa798ae5353f24f02e7cbca184f8fc8ded502c503b30b0c9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/iforce/iforce-usb.c",
  "human_readable_source": "\n  \n\n#include <linux/usb.h>\n#include \"iforce.h\"\n\nstruct iforce_usb {\n\tstruct iforce iforce;\n\n\tstruct usb_device *usbdev;\n\tstruct usb_interface *intf;\n\tstruct urb *irq, *out;\n\n\tu8 data_in[IFORCE_MAX_LENGTH] ____cacheline_aligned;\n\tu8 data_out[IFORCE_MAX_LENGTH] ____cacheline_aligned;\n};\n\nstatic void __iforce_usb_xmit(struct iforce *iforce)\n{\n\tstruct iforce_usb *iforce_usb = container_of(iforce, struct iforce_usb,\n\t\t\t\t\t\t     iforce);\n\tint n, c;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iforce->xmit_lock, flags);\n\n\tif (iforce->xmit.head == iforce->xmit.tail) {\n\t\tiforce_clear_xmit_and_wake(iforce);\n\t\tspin_unlock_irqrestore(&iforce->xmit_lock, flags);\n\t\treturn;\n\t}\n\n\t((char *)iforce_usb->out->transfer_buffer)[0] = iforce->xmit.buf[iforce->xmit.tail];\n\tXMIT_INC(iforce->xmit.tail, 1);\n\tn = iforce->xmit.buf[iforce->xmit.tail];\n\tXMIT_INC(iforce->xmit.tail, 1);\n\n\tiforce_usb->out->transfer_buffer_length = n + 1;\n\tiforce_usb->out->dev = iforce_usb->usbdev;\n\n\t \n\tc = CIRC_CNT_TO_END(iforce->xmit.head, iforce->xmit.tail, XMIT_SIZE);\n\tif (n < c) c=n;\n\n\tmemcpy(iforce_usb->out->transfer_buffer + 1,\n\t       &iforce->xmit.buf[iforce->xmit.tail],\n\t       c);\n\tif (n != c) {\n\t\tmemcpy(iforce_usb->out->transfer_buffer + 1 + c,\n\t\t       &iforce->xmit.buf[0],\n\t\t       n-c);\n\t}\n\tXMIT_INC(iforce->xmit.tail, n);\n\n\tif ( (n=usb_submit_urb(iforce_usb->out, GFP_ATOMIC)) ) {\n\t\tdev_warn(&iforce_usb->intf->dev,\n\t\t\t \"usb_submit_urb failed %d\\n\", n);\n\t\tiforce_clear_xmit_and_wake(iforce);\n\t}\n\n\t \n\tspin_unlock_irqrestore(&iforce->xmit_lock, flags);\n}\n\nstatic void iforce_usb_xmit(struct iforce *iforce)\n{\n\tif (!test_and_set_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags))\n\t\t__iforce_usb_xmit(iforce);\n}\n\nstatic int iforce_usb_get_id(struct iforce *iforce, u8 id,\n\t\t\t     u8 *response_data, size_t *response_len)\n{\n\tstruct iforce_usb *iforce_usb = container_of(iforce, struct iforce_usb,\n\t\t\t\t\t\t     iforce);\n\tu8 *buf;\n\tint status;\n\n\tbuf = kmalloc(IFORCE_MAX_LENGTH, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tstatus = usb_control_msg(iforce_usb->usbdev,\n\t\t\t\t usb_rcvctrlpipe(iforce_usb->usbdev, 0),\n\t\t\t\t id,\n\t\t\t\t USB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t\t 0, 0, buf, IFORCE_MAX_LENGTH, 1000);\n\tif (status < 0) {\n\t\tdev_err(&iforce_usb->intf->dev,\n\t\t\t\"usb_submit_urb failed: %d\\n\", status);\n\t} else if (buf[0] != id) {\n\t\tstatus = -EIO;\n\t} else {\n\t\tmemcpy(response_data, buf, status);\n\t\t*response_len = status;\n\t\tstatus = 0;\n\t}\n\n\tkfree(buf);\n\treturn status;\n}\n\nstatic int iforce_usb_start_io(struct iforce *iforce)\n{\n\tstruct iforce_usb *iforce_usb = container_of(iforce, struct iforce_usb,\n\t\t\t\t\t\t     iforce);\n\n\tif (usb_submit_urb(iforce_usb->irq, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void iforce_usb_stop_io(struct iforce *iforce)\n{\n\tstruct iforce_usb *iforce_usb = container_of(iforce, struct iforce_usb,\n\t\t\t\t\t\t     iforce);\n\n\tusb_kill_urb(iforce_usb->irq);\n\tusb_kill_urb(iforce_usb->out);\n}\n\nstatic const struct iforce_xport_ops iforce_usb_xport_ops = {\n\t.xmit\t\t= iforce_usb_xmit,\n\t.get_id\t\t= iforce_usb_get_id,\n\t.start_io\t= iforce_usb_start_io,\n\t.stop_io\t= iforce_usb_stop_io,\n};\n\nstatic void iforce_usb_irq(struct urb *urb)\n{\n\tstruct iforce_usb *iforce_usb = urb->context;\n\tstruct iforce *iforce = &iforce_usb->iforce;\n\tstruct device *dev = &iforce_usb->intf->dev;\n\tint status;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - urb has status of: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\tiforce_process_packet(iforce, iforce_usb->data_in[0],\n\t\t\t      iforce_usb->data_in + 1, urb->actual_length - 1);\n\nexit:\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, status);\n}\n\nstatic void iforce_usb_out(struct urb *urb)\n{\n\tstruct iforce_usb *iforce_usb = urb->context;\n\tstruct iforce *iforce = &iforce_usb->iforce;\n\n\tif (urb->status) {\n\t\tdev_dbg(&iforce_usb->intf->dev, \"urb->status %d, exiting\\n\",\n\t\t\turb->status);\n\t\tiforce_clear_xmit_and_wake(iforce);\n\t\treturn;\n\t}\n\n\t__iforce_usb_xmit(iforce);\n\n\twake_up_all(&iforce->wait);\n}\n\nstatic int iforce_usb_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *epirq, *epout;\n\tstruct iforce_usb *iforce_usb;\n\tint err = -ENOMEM;\n\n\tinterface = intf->cur_altsetting;\n\n\tif (interface->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\tepirq = &interface->endpoint[0].desc;\n\tif (!usb_endpoint_is_int_in(epirq))\n\t\treturn -ENODEV;\n\n\tepout = &interface->endpoint[1].desc;\n\tif (!usb_endpoint_is_int_out(epout))\n\t\treturn -ENODEV;\n\n\tiforce_usb = kzalloc(sizeof(*iforce_usb), GFP_KERNEL);\n\tif (!iforce_usb)\n\t\tgoto fail;\n\n\tiforce_usb->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!iforce_usb->irq)\n\t\tgoto fail;\n\n\tiforce_usb->out = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!iforce_usb->out)\n\t\tgoto fail;\n\n\tiforce_usb->iforce.xport_ops = &iforce_usb_xport_ops;\n\n\tiforce_usb->usbdev = dev;\n\tiforce_usb->intf = intf;\n\n\tusb_fill_int_urb(iforce_usb->irq, dev,\n\t\t\t usb_rcvintpipe(dev, epirq->bEndpointAddress),\n\t\t\t iforce_usb->data_in, sizeof(iforce_usb->data_in),\n\t\t\t iforce_usb_irq, iforce_usb, epirq->bInterval);\n\n\tusb_fill_int_urb(iforce_usb->out, dev,\n\t\t\t usb_sndintpipe(dev, epout->bEndpointAddress),\n\t\t\t iforce_usb->data_out, sizeof(iforce_usb->data_out),\n\t\t\t iforce_usb_out, iforce_usb, epout->bInterval);\n\n\terr = iforce_init_device(&intf->dev, BUS_USB, &iforce_usb->iforce);\n\tif (err)\n\t\tgoto fail;\n\n\tusb_set_intfdata(intf, iforce_usb);\n\treturn 0;\n\nfail:\n\tif (iforce_usb) {\n\t\tusb_free_urb(iforce_usb->irq);\n\t\tusb_free_urb(iforce_usb->out);\n\t\tkfree(iforce_usb);\n\t}\n\n\treturn err;\n}\n\nstatic void iforce_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct iforce_usb *iforce_usb = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tinput_unregister_device(iforce_usb->iforce.dev);\n\n\tusb_free_urb(iforce_usb->irq);\n\tusb_free_urb(iforce_usb->out);\n\n\tkfree(iforce_usb);\n}\n\nstatic const struct usb_device_id iforce_usb_ids[] = {\n\t{ USB_DEVICE(0x044f, 0xa01c) },\t\t \n\t{ USB_DEVICE(0x046d, 0xc281) },\t\t \n\t{ USB_DEVICE(0x046d, 0xc291) },\t\t \n\t{ USB_DEVICE(0x05ef, 0x020a) },\t\t \n\t{ USB_DEVICE(0x05ef, 0x8884) },\t\t \n\t{ USB_DEVICE(0x05ef, 0x8888) },\t\t \n\t{ USB_DEVICE(0x061c, 0xc0a4) },          \n\t{ USB_DEVICE(0x061c, 0xc084) },          \n\t{ USB_DEVICE(0x06a3, 0xff04) },\t\t \n\t{ USB_DEVICE(0x06f8, 0x0001) },\t\t \n\t{ USB_DEVICE(0x06f8, 0x0003) },\t\t \n\t{ USB_DEVICE(0x06f8, 0x0004) },\t\t \n\t{ USB_DEVICE(0x06f8, 0xa302) },\t\t \n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE (usb, iforce_usb_ids);\n\nstruct usb_driver iforce_usb_driver = {\n\t.name =\t\t\"iforce\",\n\t.probe =\tiforce_usb_probe,\n\t.disconnect =\tiforce_usb_disconnect,\n\t.id_table =\tiforce_usb_ids,\n};\n\nmodule_usb_driver(iforce_usb_driver);\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>, Johann Deneux <johann.deneux@gmail.com>\");\nMODULE_DESCRIPTION(\"USB I-Force joysticks and wheels driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}