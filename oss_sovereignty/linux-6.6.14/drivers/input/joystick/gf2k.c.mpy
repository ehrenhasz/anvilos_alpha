{
  "module_name": "gf2k.c",
  "hash_id": "90768ec3dc0ac2f162443b48f12d37c377705fbdc3afb9061dafe38031c4f82e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/gf2k.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/gameport.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Genius Flight 2000 joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define GF2K_START\t\t400\t \n#define GF2K_STROBE\t\t40\t \n#define GF2K_TIMEOUT\t\t4\t \n#define GF2K_LENGTH\t\t80\t \n\n \n\n#define GF2K_ID_G09\t\t1\n#define GF2K_ID_F30D\t\t2\n#define GF2K_ID_F30\t\t3\n#define GF2K_ID_F31D\t\t4\n#define GF2K_ID_F305\t\t5\n#define GF2K_ID_F23P\t\t6\n#define GF2K_ID_F31\t\t7\n#define GF2K_ID_MAX\t\t7\n\nstatic char gf2k_length[] = { 40, 40, 40, 40, 40, 40, 40, 40 };\nstatic char gf2k_hat_to_axis[][2] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};\n\nstatic char *gf2k_names[] = {\"\", \"Genius G-09D\", \"Genius F-30D\", \"Genius F-30\", \"Genius MaxFighter F-31D\",\n\t\t\t\t\"Genius F-30-5\", \"Genius Flight2000 F-23\", \"Genius F-31\"};\nstatic unsigned char gf2k_hats[] = { 0, 2, 0, 0, 2, 0, 2, 0 };\nstatic unsigned char gf2k_axes[] = { 0, 2, 0, 0, 4, 0, 4, 0 };\nstatic unsigned char gf2k_joys[] = { 0, 0, 0, 0,10, 0, 8, 0 };\nstatic unsigned char gf2k_pads[] = { 0, 6, 0, 0, 0, 0, 0, 0 };\nstatic unsigned char gf2k_lens[] = { 0,18, 0, 0,18, 0,18, 0 };\n\nstatic unsigned char gf2k_abs[] = { ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER, ABS_GAS, ABS_BRAKE };\nstatic short gf2k_btn_joy[] = { BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4 };\nstatic short gf2k_btn_pad[] = { BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_TL, BTN_TR, BTN_TL2, BTN_TR2, BTN_START, BTN_SELECT };\n\n\nstatic short gf2k_seq_reset[] = { 240, 340, 0 };\nstatic short gf2k_seq_digital[] = { 590, 320, 860, 0 };\n\nstruct gf2k {\n\tstruct gameport *gameport;\n\tstruct input_dev *dev;\n\tint reads;\n\tint bads;\n\tunsigned char id;\n\tunsigned char length;\n\tchar phys[32];\n};\n\n \n\nstatic int gf2k_read_packet(struct gameport *gameport, int length, char *data)\n{\n\tunsigned char u, v;\n\tint i;\n\tunsigned int t, p;\n\tunsigned long flags;\n\n\tt = gameport_time(gameport, GF2K_START);\n\tp = gameport_time(gameport, GF2K_STROBE);\n\n\ti = 0;\n\n\tlocal_irq_save(flags);\n\n\tgameport_trigger(gameport);\n\tv = gameport_read(gameport);\n\n\twhile (t > 0 && i < length) {\n\t\tt--; u = v;\n\t\tv = gameport_read(gameport);\n\t\tif (v & ~u & 0x10) {\n\t\t\tdata[i++] = v >> 5;\n\t\t\tt = p;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn i;\n}\n\n \n\nstatic void gf2k_trigger_seq(struct gameport *gameport, short *seq)\n{\n\n\tunsigned long flags;\n\tint i, t;\n\n        local_irq_save(flags);\n\n\ti = 0;\n        do {\n\t\tgameport_trigger(gameport);\n\t\tt = gameport_time(gameport, GF2K_TIMEOUT * 1000);\n\t\twhile ((gameport_read(gameport) & 1) && t) t--;\n                udelay(seq[i]);\n        } while (seq[++i]);\n\n\tgameport_trigger(gameport);\n\n\tlocal_irq_restore(flags);\n}\n\n \n\n#define GB(p,n,s)\tgf2k_get_bits(data, p, n, s)\n\nstatic int gf2k_get_bits(unsigned char *buf, int pos, int num, int shift)\n{\n\t__u64 data = 0;\n\tint i;\n\n\tfor (i = 0; i < num / 3 + 2; i++)\n\t\tdata |= buf[pos / 3 + i] << (i * 3);\n\tdata >>= pos % 3;\n\tdata &= (1 << num) - 1;\n\tdata <<= shift;\n\n\treturn data;\n}\n\nstatic void gf2k_read(struct gf2k *gf2k, unsigned char *data)\n{\n\tstruct input_dev *dev = gf2k->dev;\n\tint i, t;\n\n\tfor (i = 0; i < 4 && i < gf2k_axes[gf2k->id]; i++)\n\t\tinput_report_abs(dev, gf2k_abs[i], GB(i<<3,8,0) | GB(i+46,1,8) | GB(i+50,1,9));\n\n\tfor (i = 0; i < 2 && i < gf2k_axes[gf2k->id] - 4; i++)\n\t\tinput_report_abs(dev, gf2k_abs[i], GB(i*9+60,8,0) | GB(i+54,1,9));\n\n\tt = GB(40,4,0);\n\n\tfor (i = 0; i < gf2k_hats[gf2k->id]; i++)\n\t\tinput_report_abs(dev, ABS_HAT0X + i, gf2k_hat_to_axis[t][i]);\n\n\tt = GB(44,2,0) | GB(32,8,2) | GB(78,2,10);\n\n\tfor (i = 0; i < gf2k_joys[gf2k->id]; i++)\n\t\tinput_report_key(dev, gf2k_btn_joy[i], (t >> i) & 1);\n\n\tfor (i = 0; i < gf2k_pads[gf2k->id]; i++)\n\t\tinput_report_key(dev, gf2k_btn_pad[i], (t >> i) & 1);\n\n\tinput_sync(dev);\n}\n\n \n\nstatic void gf2k_poll(struct gameport *gameport)\n{\n\tstruct gf2k *gf2k = gameport_get_drvdata(gameport);\n\tunsigned char data[GF2K_LENGTH];\n\n\tgf2k->reads++;\n\n\tif (gf2k_read_packet(gf2k->gameport, gf2k_length[gf2k->id], data) < gf2k_length[gf2k->id])\n\t\tgf2k->bads++;\n\telse\n\t\tgf2k_read(gf2k, data);\n}\n\nstatic int gf2k_open(struct input_dev *dev)\n{\n\tstruct gf2k *gf2k = input_get_drvdata(dev);\n\n\tgameport_start_polling(gf2k->gameport);\n\treturn 0;\n}\n\nstatic void gf2k_close(struct input_dev *dev)\n{\n\tstruct gf2k *gf2k = input_get_drvdata(dev);\n\n\tgameport_stop_polling(gf2k->gameport);\n}\n\n \n\nstatic int gf2k_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct gf2k *gf2k;\n\tstruct input_dev *input_dev;\n\tunsigned char data[GF2K_LENGTH];\n\tint i, err;\n\n\tgf2k = kzalloc(sizeof(struct gf2k), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!gf2k || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tgf2k->gameport = gameport;\n\tgf2k->dev = input_dev;\n\n\tgameport_set_drvdata(gameport, gf2k);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tgf2k_trigger_seq(gameport, gf2k_seq_reset);\n\n\tmsleep(GF2K_TIMEOUT);\n\n\tgf2k_trigger_seq(gameport, gf2k_seq_digital);\n\n\tmsleep(GF2K_TIMEOUT);\n\n\tif (gf2k_read_packet(gameport, GF2K_LENGTH, data) < 12) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tif (!(gf2k->id = GB(7,2,0) | GB(3,3,2) | GB(0,3,5))) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n#ifdef RESET_WORKS\n\tif ((gf2k->id != (GB(19,2,0) | GB(15,3,2) | GB(12,3,5))) &&\n\t    (gf2k->id != (GB(31,2,0) | GB(27,3,2) | GB(24,3,5)))) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n#else\n\tgf2k->id = 6;\n#endif\n\n\tif (gf2k->id > GF2K_ID_MAX || !gf2k_axes[gf2k->id]) {\n\t\tprintk(KERN_WARNING \"gf2k.c: Not yet supported joystick on %s. [id: %d type:%s]\\n\",\n\t\t\tgameport->phys, gf2k->id, gf2k->id > GF2K_ID_MAX ? \"Unknown\" : gf2k_names[gf2k->id]);\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, gf2k_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tsnprintf(gf2k->phys, sizeof(gf2k->phys), \"%s/input0\", gameport->phys);\n\n\tgf2k->length = gf2k_lens[gf2k->id];\n\n\tinput_dev->name = gf2k_names[gf2k->id];\n\tinput_dev->phys = gf2k->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_GENIUS;\n\tinput_dev->id.product = gf2k->id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &gameport->dev;\n\n\tinput_set_drvdata(input_dev, gf2k);\n\n\tinput_dev->open = gf2k_open;\n\tinput_dev->close = gf2k_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = 0; i < gf2k_axes[gf2k->id]; i++)\n\t\tset_bit(gf2k_abs[i], input_dev->absbit);\n\n\tfor (i = 0; i < gf2k_hats[gf2k->id]; i++)\n\t\tinput_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);\n\n\tfor (i = 0; i < gf2k_joys[gf2k->id]; i++)\n\t\tset_bit(gf2k_btn_joy[i], input_dev->keybit);\n\n\tfor (i = 0; i < gf2k_pads[gf2k->id]; i++)\n\t\tset_bit(gf2k_btn_pad[i], input_dev->keybit);\n\n\tgf2k_read_packet(gameport, gf2k->length, data);\n\tgf2k_read(gf2k, data);\n\n\tfor (i = 0; i < gf2k_axes[gf2k->id]; i++) {\n\t\tint max = i < 2 ?\n\t\t\tinput_abs_get_val(input_dev, gf2k_abs[i]) * 2 :\n\t\t\tinput_abs_get_val(input_dev, gf2k_abs[0]) +\n\t\t\t\tinput_abs_get_val(input_dev, gf2k_abs[1]);\n\t\tint flat = i < 2 ? 24 : 0;\n\n\t\tinput_set_abs_params(input_dev, gf2k_abs[i],\n\t\t\t\t     32, max - 32, 8, flat);\n\t}\n\n\terr = input_register_device(gf2k->dev);\n\tif (err)\n\t\tgoto fail2;\n\n\treturn 0;\n\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tinput_free_device(input_dev);\n\tkfree(gf2k);\n\treturn err;\n}\n\nstatic void gf2k_disconnect(struct gameport *gameport)\n{\n\tstruct gf2k *gf2k = gameport_get_drvdata(gameport);\n\n\tinput_unregister_device(gf2k->dev);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(gf2k);\n}\n\nstatic struct gameport_driver gf2k_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"gf2k\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= gf2k_connect,\n\t.disconnect\t= gf2k_disconnect,\n};\n\nmodule_gameport_driver(gf2k_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}