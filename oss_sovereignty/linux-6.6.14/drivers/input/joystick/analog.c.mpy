{
  "module_name": "analog.c",
  "hash_id": "41414eb57587de2c436035da17fe56fb0c371a7f84e7c1638326ee34de5f8528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/analog.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/gameport.h>\n#include <linux/jiffies.h>\n#include <linux/seq_buf.h>\n#include <linux/timex.h>\n#include <linux/timekeeping.h>\n\n#define DRIVER_DESC\t\"Analog joystick and gamepad driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define ANALOG_PORTS\t\t16\n\nstatic char *js[ANALOG_PORTS];\nstatic unsigned int js_nargs;\nstatic int analog_options[ANALOG_PORTS];\nmodule_param_array_named(map, js, charp, &js_nargs, 0);\nMODULE_PARM_DESC(map, \"Describes analog joysticks type/capabilities\");\n\n \n\n#define ANALOG_RUDDER\t\t0x00004\n#define ANALOG_THROTTLE\t\t0x00008\n#define ANALOG_AXES_STD\t\t0x0000f\n#define ANALOG_BTNS_STD\t\t0x000f0\n\n#define ANALOG_BTNS_CHF\t\t0x00100\n#define ANALOG_HAT1_CHF\t\t0x00200\n#define ANALOG_HAT2_CHF\t\t0x00400\n#define ANALOG_HAT_FCS\t\t0x00800\n#define ANALOG_HATS_ALL\t\t0x00e00\n#define ANALOG_BTN_TL\t\t0x01000\n#define ANALOG_BTN_TR\t\t0x02000\n#define ANALOG_BTN_TL2\t\t0x04000\n#define ANALOG_BTN_TR2\t\t0x08000\n#define ANALOG_BTNS_TLR\t\t0x03000\n#define ANALOG_BTNS_TLR2\t0x0c000\n#define ANALOG_BTNS_GAMEPAD\t0x0f000\n\n#define ANALOG_HBTN_CHF\t\t0x10000\n#define ANALOG_ANY_CHF\t\t0x10700\n#define ANALOG_SAITEK\t\t0x20000\n#define ANALOG_EXTENSIONS\t0x7ff00\n#define ANALOG_GAMEPAD\t\t0x80000\n\n#define ANALOG_MAX_TIME\t\t3\t \n#define ANALOG_LOOP_TIME\t2000\t \n#define ANALOG_SAITEK_DELAY\t200\t \n#define ANALOG_SAITEK_TIME\t2000\t \n#define ANALOG_AXIS_TIME\t2\t \n#define ANALOG_INIT_RETRIES\t8\t \n#define ANALOG_FUZZ_BITS\t2\t \n#define ANALOG_FUZZ_MAGIC\t36\t \n\n#define ANALOG_MAX_NAME_LENGTH  128\n#define ANALOG_MAX_PHYS_LENGTH\t32\n\nstatic short analog_axes[] = { ABS_X, ABS_Y, ABS_RUDDER, ABS_THROTTLE };\nstatic short analog_hats[] = { ABS_HAT0X, ABS_HAT0Y, ABS_HAT1X, ABS_HAT1Y, ABS_HAT2X, ABS_HAT2Y };\nstatic short analog_pads[] = { BTN_Y, BTN_Z, BTN_TL, BTN_TR };\nstatic short analog_exts[] = { ANALOG_HAT1_CHF, ANALOG_HAT2_CHF, ANALOG_HAT_FCS };\nstatic short analog_pad_btn[] = { BTN_A, BTN_B, BTN_C, BTN_X, BTN_TL2, BTN_TR2, BTN_SELECT, BTN_START, BTN_MODE, BTN_BASE };\nstatic short analog_joy_btn[] = { BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2,\n\t\t\t\t  BTN_BASE3, BTN_BASE4, BTN_BASE5, BTN_BASE6 };\n\nstatic unsigned char analog_chf[] = { 0xf, 0x0, 0x1, 0x9, 0x2, 0x4, 0xc, 0x8, 0x3, 0x5, 0xb, 0x7, 0xd, 0xe, 0xa, 0x6 };\n\nstruct analog {\n\tstruct input_dev *dev;\n\tint mask;\n\tshort *buttons;\n\tchar name[ANALOG_MAX_NAME_LENGTH];\n\tchar phys[ANALOG_MAX_PHYS_LENGTH];\n};\n\nstruct analog_port {\n\tstruct gameport *gameport;\n\tstruct analog analog[2];\n\tunsigned char mask;\n\tchar saitek;\n\tchar cooked;\n\tint bads;\n\tint reads;\n\tint loop;\n\tint fuzz;\n\tint axes[4];\n\tint buttons;\n\tint initial[4];\n\tint axtime;\n};\n\n \n\nstatic void analog_decode(struct analog *analog, int *axes, int *initial, int buttons)\n{\n\tstruct input_dev *dev = analog->dev;\n\tint i, j;\n\n\tif (analog->mask & ANALOG_HAT_FCS)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (axes[3] < ((initial[3] * ((i << 1) + 1)) >> 3)) {\n\t\t\t\tbuttons |= 1 << (i + 14);\n\t\t\t\tbreak;\n\t\t\t}\n\n\tfor (i = j = 0; i < 6; i++)\n\t\tif (analog->mask & (0x10 << i))\n\t\t\tinput_report_key(dev, analog->buttons[j++], (buttons >> i) & 1);\n\n\tif (analog->mask & ANALOG_HBTN_CHF)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tinput_report_key(dev, analog->buttons[j++], (buttons >> (i + 10)) & 1);\n\n\tif (analog->mask & ANALOG_BTN_TL)\n\t\tinput_report_key(dev, analog_pads[0], axes[2] < (initial[2] >> 1));\n\tif (analog->mask & ANALOG_BTN_TR)\n\t\tinput_report_key(dev, analog_pads[1], axes[3] < (initial[3] >> 1));\n\tif (analog->mask & ANALOG_BTN_TL2)\n\t\tinput_report_key(dev, analog_pads[2], axes[2] > (initial[2] + (initial[2] >> 1)));\n\tif (analog->mask & ANALOG_BTN_TR2)\n\t\tinput_report_key(dev, analog_pads[3], axes[3] > (initial[3] + (initial[3] >> 1)));\n\n\tfor (i = j = 0; i < 4; i++)\n\t\tif (analog->mask & (1 << i))\n\t\t\tinput_report_abs(dev, analog_axes[j++], axes[i]);\n\n\tfor (i = j = 0; i < 3; i++)\n\t\tif (analog->mask & analog_exts[i]) {\n\t\t\tinput_report_abs(dev, analog_hats[j++],\n\t\t\t\t((buttons >> ((i << 2) + 7)) & 1) - ((buttons >> ((i << 2) + 9)) & 1));\n\t\t\tinput_report_abs(dev, analog_hats[j++],\n\t\t\t\t((buttons >> ((i << 2) + 8)) & 1) - ((buttons >> ((i << 2) + 6)) & 1));\n\t\t}\n\n\tinput_sync(dev);\n}\n\n \n\nstatic int analog_cooked_read(struct analog_port *port)\n{\n\tstruct gameport *gameport = port->gameport;\n\tktime_t time[4], start, loop, now;\n\tunsigned int loopout, timeout;\n\tunsigned char data[4], this, last;\n\tunsigned long flags;\n\tint i, j;\n\n\tloopout = (ANALOG_LOOP_TIME * port->loop) / 1000;\n\ttimeout = ANALOG_MAX_TIME * NSEC_PER_MSEC;\n\n\tlocal_irq_save(flags);\n\tgameport_trigger(gameport);\n\tnow = ktime_get();\n\tlocal_irq_restore(flags);\n\n\tstart = now;\n\tthis = port->mask;\n\ti = 0;\n\n\tdo {\n\t\tloop = now;\n\t\tlast = this;\n\n\t\tlocal_irq_disable();\n\t\tthis = gameport_read(gameport) & port->mask;\n\t\tnow = ktime_get();\n\t\tlocal_irq_restore(flags);\n\n\t\tif ((last ^ this) && (ktime_sub(now, loop) < loopout)) {\n\t\t\tdata[i] = last ^ this;\n\t\t\ttime[i] = now;\n\t\t\ti++;\n\t\t}\n\n\t} while (this && (i < 4) && (ktime_sub(now, start) < timeout));\n\n\tthis <<= 4;\n\n\tfor (--i; i >= 0; i--) {\n\t\tthis |= data[i];\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tif (data[i] & (1 << j))\n\t\t\t\tport->axes[j] = ((u32)ktime_sub(time[i], start) << ANALOG_FUZZ_BITS) / port->loop;\n\t}\n\n\treturn -(this != port->mask);\n}\n\nstatic int analog_button_read(struct analog_port *port, char saitek, char chf)\n{\n\tunsigned char u;\n\tint t = 1, i = 0;\n\tint strobe = gameport_time(port->gameport, ANALOG_SAITEK_TIME);\n\n\tu = gameport_read(port->gameport);\n\n\tif (!chf) {\n\t\tport->buttons = (~u >> 4) & 0xf;\n\t\treturn 0;\n\t}\n\n\tport->buttons = 0;\n\n\twhile ((~u & 0xf0) && (i < 16) && t) {\n\t\tport->buttons |= 1 << analog_chf[(~u >> 4) & 0xf];\n\t\tif (!saitek) return 0;\n\t\tudelay(ANALOG_SAITEK_DELAY);\n\t\tt = strobe;\n\t\tgameport_trigger(port->gameport);\n\t\twhile (((u = gameport_read(port->gameport)) & port->mask) && t) t--;\n\t\ti++;\n\t}\n\n\treturn -(!t || (i == 16));\n}\n\n \n\nstatic void analog_poll(struct gameport *gameport)\n{\n\tstruct analog_port *port = gameport_get_drvdata(gameport);\n\tint i;\n\n\tchar saitek = !!(port->analog[0].mask & ANALOG_SAITEK);\n\tchar chf = !!(port->analog[0].mask & ANALOG_ANY_CHF);\n\n\tif (port->cooked) {\n\t\tport->bads -= gameport_cooked_read(port->gameport, port->axes, &port->buttons);\n\t\tif (chf)\n\t\t\tport->buttons = port->buttons ? (1 << analog_chf[port->buttons]) : 0;\n\t\tport->reads++;\n\t} else {\n\t\tif (!port->axtime--) {\n\t\t\tport->bads -= analog_cooked_read(port);\n\t\t\tport->bads -= analog_button_read(port, saitek, chf);\n\t\t\tport->reads++;\n\t\t\tport->axtime = ANALOG_AXIS_TIME - 1;\n\t\t} else {\n\t\t\tif (!saitek)\n\t\t\t\tanalog_button_read(port, saitek, chf);\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (port->analog[i].mask)\n\t\t\tanalog_decode(port->analog + i, port->axes, port->initial, port->buttons);\n}\n\n \n\nstatic int analog_open(struct input_dev *dev)\n{\n\tstruct analog_port *port = input_get_drvdata(dev);\n\n\tgameport_start_polling(port->gameport);\n\treturn 0;\n}\n\n \n\nstatic void analog_close(struct input_dev *dev)\n{\n\tstruct analog_port *port = input_get_drvdata(dev);\n\n\tgameport_stop_polling(port->gameport);\n}\n\n \n\nstatic void analog_calibrate_timer(struct analog_port *port)\n{\n\tstruct gameport *gameport = port->gameport;\n\tunsigned int i, t, tx;\n\tktime_t t1, t2, t3;\n\tunsigned long flags;\n\n\ttx = ~0;\n\n\tfor (i = 0; i < 50; i++) {\n\t\tlocal_irq_save(flags);\n\t\tt1 = ktime_get();\n\t\tfor (t = 0; t < 50; t++) {\n\t\t\tgameport_read(gameport);\n\t\t\tt2 = ktime_get();\n\t\t}\n\t\tt3 = ktime_get();\n\t\tlocal_irq_restore(flags);\n\t\tudelay(i);\n\t\tt = ktime_sub(t2, t1) - ktime_sub(t3, t2);\n\t\tif (t < tx) tx = t;\n\t}\n\n        port->loop = tx / 50;\n}\n\n \n\nstatic void analog_name(struct analog *analog)\n{\n\tstruct seq_buf s;\n\n\tseq_buf_init(&s, analog->name, sizeof(analog->name));\n\tseq_buf_printf(&s, \"Analog %d-axis %d-button\",\n\t\t hweight8(analog->mask & ANALOG_AXES_STD),\n\t\t hweight8(analog->mask & ANALOG_BTNS_STD) + !!(analog->mask & ANALOG_BTNS_CHF) * 2 +\n\t\t hweight16(analog->mask & ANALOG_BTNS_GAMEPAD) + !!(analog->mask & ANALOG_HBTN_CHF) * 4);\n\n\tif (analog->mask & ANALOG_HATS_ALL)\n\t\tseq_buf_printf(&s, \" %d-hat\",\n\t\t\t       hweight16(analog->mask & ANALOG_HATS_ALL));\n\n\tif (analog->mask & ANALOG_HAT_FCS)\n\t\tseq_buf_printf(&s, \" FCS\");\n\tif (analog->mask & ANALOG_ANY_CHF)\n\t\tseq_buf_printf(&s, (analog->mask & ANALOG_SAITEK) ? \" Saitek\" : \" CHF\");\n\n\tseq_buf_printf(&s, (analog->mask & ANALOG_GAMEPAD) ? \" gamepad\" : \" joystick\");\n}\n\n \n\nstatic int analog_init_device(struct analog_port *port, struct analog *analog, int index)\n{\n\tstruct input_dev *input_dev;\n\tint i, j, t, v, w, x, y, z;\n\tint error;\n\n\tanalog_name(analog);\n\tsnprintf(analog->phys, sizeof(analog->phys),\n\t\t \"%s/input%d\", port->gameport->phys, index);\n\tanalog->buttons = (analog->mask & ANALOG_GAMEPAD) ? analog_pad_btn : analog_joy_btn;\n\n\tanalog->dev = input_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tinput_dev->name = analog->name;\n\tinput_dev->phys = analog->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_ANALOG;\n\tinput_dev->id.product = analog->mask >> 4;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &port->gameport->dev;\n\n\tinput_set_drvdata(input_dev, port);\n\n\tinput_dev->open = analog_open;\n\tinput_dev->close = analog_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = j = 0; i < 4; i++)\n\t\tif (analog->mask & (1 << i)) {\n\n\t\t\tt = analog_axes[j];\n\t\t\tx = port->axes[i];\n\t\t\ty = (port->axes[0] + port->axes[1]) >> 1;\n\t\t\tz = y - port->axes[i];\n\t\t\tz = z > 0 ? z : -z;\n\t\t\tv = (x >> 3);\n\t\t\tw = (x >> 3);\n\n\t\t\tif ((i == 2 || i == 3) && (j == 2 || j == 3) && (z > (y >> 3)))\n\t\t\t\tx = y;\n\n\t\t\tif (analog->mask & ANALOG_SAITEK) {\n\t\t\t\tif (i == 2) x = port->axes[i];\n\t\t\t\tv = x - (x >> 2);\n\t\t\t\tw = (x >> 4);\n\t\t\t}\n\n\t\t\tinput_set_abs_params(input_dev, t, v, (x << 1) - v, port->fuzz, w);\n\t\t\tj++;\n\t\t}\n\n\tfor (i = j = 0; i < 3; i++)\n\t\tif (analog->mask & analog_exts[i])\n\t\t\tfor (x = 0; x < 2; x++) {\n\t\t\t\tt = analog_hats[j++];\n\t\t\t\tinput_set_abs_params(input_dev, t, -1, 1, 0, 0);\n\t\t\t}\n\n\tfor (i = j = 0; i < 4; i++)\n\t\tif (analog->mask & (0x10 << i))\n\t\t\tset_bit(analog->buttons[j++], input_dev->keybit);\n\n\tif (analog->mask & ANALOG_BTNS_CHF)\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tset_bit(analog->buttons[j++], input_dev->keybit);\n\n\tif (analog->mask & ANALOG_HBTN_CHF)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tset_bit(analog->buttons[j++], input_dev->keybit);\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (analog->mask & (ANALOG_BTN_TL << i))\n\t\t\tset_bit(analog_pads[i], input_dev->keybit);\n\n\tanalog_decode(analog, port->axes, port->initial, port->buttons);\n\n\terror = input_register_device(analog->dev);\n\tif (error) {\n\t\tinput_free_device(analog->dev);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int analog_init_masks(struct analog_port *port)\n{\n\tint i;\n\tstruct analog *analog = port->analog;\n\tint max[4];\n\n\tif (!port->mask)\n\t\treturn -1;\n\n\tif ((port->mask & 3) != 3 && port->mask != 0xc) {\n\t\tprintk(KERN_WARNING \"analog.c: Unknown joystick device found  \"\n\t\t\t\"(data=%#x, %s), probably not analog joystick.\\n\",\n\t\t\tport->mask, port->gameport->phys);\n\t\treturn -1;\n\t}\n\n\n\ti = analog_options[0];  \n\n\tanalog[0].mask = i & 0xfffff;\n\n\tanalog[0].mask &= ~(ANALOG_AXES_STD | ANALOG_HAT_FCS | ANALOG_BTNS_GAMEPAD)\n\t\t\t| port->mask | ((port->mask << 8) & ANALOG_HAT_FCS)\n\t\t\t| ((port->mask << 10) & ANALOG_BTNS_TLR) | ((port->mask << 12) & ANALOG_BTNS_TLR2);\n\n\tanalog[0].mask &= ~(ANALOG_HAT2_CHF)\n\t\t\t| ((analog[0].mask & ANALOG_HBTN_CHF) ? 0 : ANALOG_HAT2_CHF);\n\n\tanalog[0].mask &= ~(ANALOG_THROTTLE | ANALOG_BTN_TR | ANALOG_BTN_TR2)\n\t\t\t| ((~analog[0].mask & ANALOG_HAT_FCS) >> 8)\n\t\t\t| ((~analog[0].mask & ANALOG_HAT_FCS) << 2)\n\t\t\t| ((~analog[0].mask & ANALOG_HAT_FCS) << 4);\n\n\tanalog[0].mask &= ~(ANALOG_THROTTLE | ANALOG_RUDDER)\n\t\t\t| (((~analog[0].mask & ANALOG_BTNS_TLR ) >> 10)\n\t\t\t&  ((~analog[0].mask & ANALOG_BTNS_TLR2) >> 12));\n\n\tanalog[1].mask = ((i >> 20) & 0xff) | ((i >> 12) & 0xf0000);\n\n\tanalog[1].mask &= (analog[0].mask & ANALOG_EXTENSIONS) ? ANALOG_GAMEPAD\n\t\t\t: (((ANALOG_BTNS_STD | port->mask) & ~analog[0].mask) | ANALOG_GAMEPAD);\n\n\tif (port->cooked) {\n\n\t\tfor (i = 0; i < 4; i++) max[i] = port->axes[i] << 1;\n\n\t\tif ((analog[0].mask & 0x7) == 0x7) max[2] = (max[0] + max[1]) >> 1;\n\t\tif ((analog[0].mask & 0xb) == 0xb) max[3] = (max[0] + max[1]) >> 1;\n\t\tif ((analog[0].mask & ANALOG_BTN_TL) && !(analog[0].mask & ANALOG_BTN_TL2)) max[2] >>= 1;\n\t\tif ((analog[0].mask & ANALOG_BTN_TR) && !(analog[0].mask & ANALOG_BTN_TR2)) max[3] >>= 1;\n\t\tif ((analog[0].mask & ANALOG_HAT_FCS)) max[3] >>= 1;\n\n\t\tgameport_calibrate(port->gameport, port->axes, max);\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tport->initial[i] = port->axes[i];\n\n\treturn -!(analog[0].mask || analog[1].mask);\n}\n\nstatic int analog_init_port(struct gameport *gameport, struct gameport_driver *drv, struct analog_port *port)\n{\n\tint i, t, u, v;\n\n\tport->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, port);\n\n\tif (!gameport_open(gameport, drv, GAMEPORT_MODE_RAW)) {\n\n\t\tanalog_calibrate_timer(port);\n\n\t\tgameport_trigger(gameport);\n\t\tt = gameport_read(gameport);\n\t\tmsleep(ANALOG_MAX_TIME);\n\t\tport->mask = (gameport_read(gameport) ^ t) & t & 0xf;\n\t\tport->fuzz = (NSEC_PER_MSEC * ANALOG_FUZZ_MAGIC) / port->loop / 1000 + ANALOG_FUZZ_BITS;\n\n\t\tfor (i = 0; i < ANALOG_INIT_RETRIES; i++) {\n\t\t\tif (!analog_cooked_read(port))\n\t\t\t\tbreak;\n\t\t\tmsleep(ANALOG_MAX_TIME);\n\t\t}\n\n\t\tu = v = 0;\n\n\t\tmsleep(ANALOG_MAX_TIME);\n\t\tt = gameport_time(gameport, ANALOG_MAX_TIME * 1000);\n\t\tgameport_trigger(gameport);\n\t\twhile ((gameport_read(port->gameport) & port->mask) && (u < t))\n\t\t\tu++;\n\t\tudelay(ANALOG_SAITEK_DELAY);\n\t\tt = gameport_time(gameport, ANALOG_SAITEK_TIME);\n\t\tgameport_trigger(gameport);\n\t\twhile ((gameport_read(port->gameport) & port->mask) && (v < t))\n\t\t\tv++;\n\n\t\tif (v < (u >> 1)) {  \n\t\t\tanalog_options[0] |=  \n\t\t\t\tANALOG_SAITEK | ANALOG_BTNS_CHF | ANALOG_HBTN_CHF | ANALOG_HAT1_CHF;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgameport_close(gameport);\n\t}\n\n\tif (!gameport_open(gameport, drv, GAMEPORT_MODE_COOKED)) {\n\n\t\tfor (i = 0; i < ANALOG_INIT_RETRIES; i++)\n\t\t\tif (!gameport_cooked_read(gameport, port->axes, &port->buttons))\n\t\t\t\tbreak;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (port->axes[i] != -1)\n\t\t\t\tport->mask |= 1 << i;\n\n\t\tport->fuzz = gameport->fuzz;\n\t\tport->cooked = 1;\n\t\treturn 0;\n\t}\n\n\treturn gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n}\n\nstatic int analog_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct analog_port *port;\n\tint i;\n\tint err;\n\n\tif (!(port = kzalloc(sizeof(struct analog_port), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\terr = analog_init_port(gameport, drv, port);\n\tif (err)\n\t\tgoto fail1;\n\n\terr = analog_init_masks(port);\n\tif (err)\n\t\tgoto fail2;\n\n\tgameport_set_poll_handler(gameport, analog_poll);\n\tgameport_set_poll_interval(gameport, 10);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (port->analog[i].mask) {\n\t\t\terr = analog_init_device(port, port->analog + i, i);\n\t\t\tif (err)\n\t\t\t\tgoto fail3;\n\t\t}\n\n\treturn 0;\n\n fail3: while (--i >= 0)\n\t\tif (port->analog[i].mask)\n\t\t\tinput_unregister_device(port->analog[i].dev);\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(port);\n\treturn err;\n}\n\nstatic void analog_disconnect(struct gameport *gameport)\n{\n\tstruct analog_port *port = gameport_get_drvdata(gameport);\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (port->analog[i].mask)\n\t\t\tinput_unregister_device(port->analog[i].dev);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tprintk(KERN_INFO \"analog.c: %d out of %d reads (%d%%) on %s failed\\n\",\n\t\tport->bads, port->reads, port->reads ? (port->bads * 100 / port->reads) : 0,\n\t\tport->gameport->phys);\n\tkfree(port);\n}\n\nstruct analog_types {\n\tchar *name;\n\tint value;\n};\n\nstatic struct analog_types analog_types[] = {\n\t{ \"none\",\t0x00000000 },\n\t{ \"auto\",\t0x000000ff },\n\t{ \"2btn\",\t0x0000003f },\n\t{ \"y-joy\",\t0x0cc00033 },\n\t{ \"y-pad\",\t0x8cc80033 },\n\t{ \"fcs\",\t0x000008f7 },\n\t{ \"chf\",\t0x000002ff },\n\t{ \"fullchf\",\t0x000007ff },\n\t{ \"gamepad\",\t0x000830f3 },\n\t{ \"gamepad8\",\t0x0008f0f3 },\n\t{ NULL, 0 }\n};\n\nstatic void analog_parse_options(void)\n{\n\tint i, j;\n\tchar *end;\n\n\tfor (i = 0; i < js_nargs; i++) {\n\n\t\tfor (j = 0; analog_types[j].name; j++)\n\t\t\tif (!strcmp(analog_types[j].name, js[i])) {\n\t\t\t\tanalog_options[i] = analog_types[j].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (analog_types[j].name) continue;\n\n\t\tanalog_options[i] = simple_strtoul(js[i], &end, 0);\n\t\tif (end != js[i]) continue;\n\n\t\tanalog_options[i] = 0xff;\n\t\tif (!strlen(js[i])) continue;\n\n\t\tprintk(KERN_WARNING \"analog.c: Bad config for port %d - \\\"%s\\\"\\n\", i, js[i]);\n\t}\n\n\tfor (; i < ANALOG_PORTS; i++)\n\t\tanalog_options[i] = 0xff;\n}\n\n \n\nstatic struct gameport_driver analog_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"analog\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= analog_connect,\n\t.disconnect\t= analog_disconnect,\n};\n\nstatic int __init analog_init(void)\n{\n\tanalog_parse_options();\n\treturn gameport_register_driver(&analog_drv);\n}\n\nstatic void __exit analog_exit(void)\n{\n\tgameport_unregister_driver(&analog_drv);\n}\n\nmodule_init(analog_init);\nmodule_exit(analog_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}