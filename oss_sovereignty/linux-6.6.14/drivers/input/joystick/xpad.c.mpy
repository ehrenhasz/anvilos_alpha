{
  "module_name": "xpad.c",
  "hash_id": "bd6b9eba49d412703639f082a370f33cb4d250e5a4618bc148c11c0689c15035",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/xpad.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n#include <linux/usb/quirks.h>\n\n#define XPAD_PKT_LEN 64\n\n \n#define MAP_DPAD_TO_BUTTONS\t\t(1 << 0)\n#define MAP_TRIGGERS_TO_BUTTONS\t\t(1 << 1)\n#define MAP_STICKS_TO_NULL\t\t(1 << 2)\n#define MAP_SELECT_BUTTON\t\t(1 << 3)\n#define MAP_PADDLES\t\t\t(1 << 4)\n#define MAP_PROFILE_BUTTON\t\t(1 << 5)\n\n#define DANCEPAD_MAP_CONFIG\t(MAP_DPAD_TO_BUTTONS |\t\t\t\\\n\t\t\t\tMAP_TRIGGERS_TO_BUTTONS | MAP_STICKS_TO_NULL)\n\n#define XTYPE_XBOX        0\n#define XTYPE_XBOX360     1\n#define XTYPE_XBOX360W    2\n#define XTYPE_XBOXONE     3\n#define XTYPE_UNKNOWN     4\n\n \n#define XPAD360W_POWEROFF_TIMEOUT 5\n\n#define PKT_XB              0\n#define PKT_XBE1            1\n#define PKT_XBE2_FW_OLD     2\n#define PKT_XBE2_FW_5_EARLY 3\n#define PKT_XBE2_FW_5_11    4\n\nstatic bool dpad_to_buttons;\nmodule_param(dpad_to_buttons, bool, S_IRUGO);\nMODULE_PARM_DESC(dpad_to_buttons, \"Map D-PAD to buttons rather than axes for unknown pads\");\n\nstatic bool triggers_to_buttons;\nmodule_param(triggers_to_buttons, bool, S_IRUGO);\nMODULE_PARM_DESC(triggers_to_buttons, \"Map triggers to buttons rather than axes for unknown pads\");\n\nstatic bool sticks_to_null;\nmodule_param(sticks_to_null, bool, S_IRUGO);\nMODULE_PARM_DESC(sticks_to_null, \"Do not map sticks at all for unknown pads\");\n\nstatic bool auto_poweroff = true;\nmodule_param(auto_poweroff, bool, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(auto_poweroff, \"Power off wireless controllers on suspend\");\n\nstatic const struct xpad_device {\n\tu16 idVendor;\n\tu16 idProduct;\n\tchar *name;\n\tu8 mapping;\n\tu8 xtype;\n} xpad_device[] = {\n\t{ 0x0079, 0x18d4, \"GPD Win 2 X-Box Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x03eb, 0xff01, \"Wooting One (Legacy)\", 0, XTYPE_XBOX360 },\n\t{ 0x03eb, 0xff02, \"Wooting Two (Legacy)\", 0, XTYPE_XBOX360 },\n\t{ 0x03f0, 0x0495, \"HyperX Clutch Gladiate\", 0, XTYPE_XBOXONE },\n\t{ 0x044f, 0x0f00, \"Thrustmaster Wheel\", 0, XTYPE_XBOX },\n\t{ 0x044f, 0x0f03, \"Thrustmaster Wheel\", 0, XTYPE_XBOX },\n\t{ 0x044f, 0x0f07, \"Thrustmaster, Inc. Controller\", 0, XTYPE_XBOX },\n\t{ 0x044f, 0x0f10, \"Thrustmaster Modena GT Wheel\", 0, XTYPE_XBOX },\n\t{ 0x044f, 0xb326, \"Thrustmaster Gamepad GP XID\", 0, XTYPE_XBOX360 },\n\t{ 0x045e, 0x0202, \"Microsoft X-Box pad v1 (US)\", 0, XTYPE_XBOX },\n\t{ 0x045e, 0x0285, \"Microsoft X-Box pad (Japan)\", 0, XTYPE_XBOX },\n\t{ 0x045e, 0x0287, \"Microsoft Xbox Controller S\", 0, XTYPE_XBOX },\n\t{ 0x045e, 0x0288, \"Microsoft Xbox Controller S v2\", 0, XTYPE_XBOX },\n\t{ 0x045e, 0x0289, \"Microsoft X-Box pad v2 (US)\", 0, XTYPE_XBOX },\n\t{ 0x045e, 0x028e, \"Microsoft X-Box 360 pad\", 0, XTYPE_XBOX360 },\n\t{ 0x045e, 0x028f, \"Microsoft X-Box 360 pad v2\", 0, XTYPE_XBOX360 },\n\t{ 0x045e, 0x0291, \"Xbox 360 Wireless Receiver (XBOX)\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },\n\t{ 0x045e, 0x02d1, \"Microsoft X-Box One pad\", 0, XTYPE_XBOXONE },\n\t{ 0x045e, 0x02dd, \"Microsoft X-Box One pad (Firmware 2015)\", 0, XTYPE_XBOXONE },\n\t{ 0x045e, 0x02e3, \"Microsoft X-Box One Elite pad\", MAP_PADDLES, XTYPE_XBOXONE },\n\t{ 0x045e, 0x0b00, \"Microsoft X-Box One Elite 2 pad\", MAP_PADDLES, XTYPE_XBOXONE },\n\t{ 0x045e, 0x02ea, \"Microsoft X-Box One S pad\", 0, XTYPE_XBOXONE },\n\t{ 0x045e, 0x0719, \"Xbox 360 Wireless Receiver\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },\n\t{ 0x045e, 0x0b0a, \"Microsoft X-Box Adaptive Controller\", MAP_PROFILE_BUTTON, XTYPE_XBOXONE },\n\t{ 0x045e, 0x0b12, \"Microsoft Xbox Series S|X Controller\", MAP_SELECT_BUTTON, XTYPE_XBOXONE },\n\t{ 0x046d, 0xc21d, \"Logitech Gamepad F310\", 0, XTYPE_XBOX360 },\n\t{ 0x046d, 0xc21e, \"Logitech Gamepad F510\", 0, XTYPE_XBOX360 },\n\t{ 0x046d, 0xc21f, \"Logitech Gamepad F710\", 0, XTYPE_XBOX360 },\n\t{ 0x046d, 0xc242, \"Logitech Chillstream Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x046d, 0xca84, \"Logitech Xbox Cordless Controller\", 0, XTYPE_XBOX },\n\t{ 0x046d, 0xca88, \"Logitech Compact Controller for Xbox\", 0, XTYPE_XBOX },\n\t{ 0x046d, 0xca8a, \"Logitech Precision Vibration Feedback Wheel\", 0, XTYPE_XBOX },\n\t{ 0x046d, 0xcaa3, \"Logitech DriveFx Racing Wheel\", 0, XTYPE_XBOX360 },\n\t{ 0x056e, 0x2004, \"Elecom JC-U3613M\", 0, XTYPE_XBOX360 },\n\t{ 0x05fd, 0x1007, \"Mad Catz Controller (unverified)\", 0, XTYPE_XBOX },\n\t{ 0x05fd, 0x107a, \"InterAct 'PowerPad Pro' X-Box pad (Germany)\", 0, XTYPE_XBOX },\n\t{ 0x05fe, 0x3030, \"Chic Controller\", 0, XTYPE_XBOX },\n\t{ 0x05fe, 0x3031, \"Chic Controller\", 0, XTYPE_XBOX },\n\t{ 0x062a, 0x0020, \"Logic3 Xbox GamePad\", 0, XTYPE_XBOX },\n\t{ 0x062a, 0x0033, \"Competition Pro Steering Wheel\", 0, XTYPE_XBOX },\n\t{ 0x06a3, 0x0200, \"Saitek Racing Wheel\", 0, XTYPE_XBOX },\n\t{ 0x06a3, 0x0201, \"Saitek Adrenalin\", 0, XTYPE_XBOX },\n\t{ 0x06a3, 0xf51a, \"Saitek P3600\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4506, \"Mad Catz 4506 Wireless Controller\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4516, \"Mad Catz Control Pad\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4520, \"Mad Catz Control Pad Pro\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4522, \"Mad Catz LumiCON\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4526, \"Mad Catz Control Pad Pro\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4530, \"Mad Catz Universal MC2 Racing Wheel and Pedals\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4536, \"Mad Catz MicroCON\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4540, \"Mad Catz Beat Pad\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x0738, 0x4556, \"Mad Catz Lynx Wireless Controller\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4586, \"Mad Catz MicroCon Wireless Controller\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x4588, \"Mad Catz Blaster\", 0, XTYPE_XBOX },\n\t{ 0x0738, 0x45ff, \"Mad Catz Beat Pad (w/ Handle)\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x0738, 0x4716, \"Mad Catz Wired Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4718, \"Mad Catz Street Fighter IV FightStick SE\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4726, \"Mad Catz Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4728, \"Mad Catz Street Fighter IV FightPad\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4736, \"Mad Catz MicroCon Gamepad\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4738, \"Mad Catz Wired Xbox 360 Controller (SFIV)\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4740, \"Mad Catz Beat Pad\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4743, \"Mad Catz Beat Pad Pro\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x0738, 0x4758, \"Mad Catz Arcade Game Stick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0738, 0x4a01, \"Mad Catz FightStick TE 2\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },\n\t{ 0x0738, 0x6040, \"Mad Catz Beat Pad Pro\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x0738, 0x9871, \"Mad Catz Portable Drum\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0xb726, \"Mad Catz Xbox controller - MW2\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0xb738, \"Mad Catz MVC2TE Stick 2\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0738, 0xbeef, \"Mad Catz JOYTECH NEO SE Advanced GamePad\", XTYPE_XBOX360 },\n\t{ 0x0738, 0xcb02, \"Saitek Cyborg Rumble Pad - PC/Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0xcb03, \"Saitek P3200 Rumble Pad - PC/Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0xcb29, \"Saitek Aviator Stick AV8R02\", 0, XTYPE_XBOX360 },\n\t{ 0x0738, 0xf738, \"Super SFIV FightStick TE S\", 0, XTYPE_XBOX360 },\n\t{ 0x07ff, 0xffff, \"Mad Catz GamePad\", 0, XTYPE_XBOX360 },\n\t{ 0x0c12, 0x0005, \"Intec wireless\", 0, XTYPE_XBOX },\n\t{ 0x0c12, 0x8801, \"Nyko Xbox Controller\", 0, XTYPE_XBOX },\n\t{ 0x0c12, 0x8802, \"Zeroplus Xbox Controller\", 0, XTYPE_XBOX },\n\t{ 0x0c12, 0x8809, \"RedOctane Xbox Dance Pad\", DANCEPAD_MAP_CONFIG, XTYPE_XBOX },\n\t{ 0x0c12, 0x880a, \"Pelican Eclipse PL-2023\", 0, XTYPE_XBOX },\n\t{ 0x0c12, 0x8810, \"Zeroplus Xbox Controller\", 0, XTYPE_XBOX },\n\t{ 0x0c12, 0x9902, \"HAMA VibraX - *FAULTY HARDWARE*\", 0, XTYPE_XBOX },\n\t{ 0x0d2f, 0x0002, \"Andamiro Pump It Up pad\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x0e4c, 0x1097, \"Radica Gamester Controller\", 0, XTYPE_XBOX },\n\t{ 0x0e4c, 0x1103, \"Radica Gamester Reflex\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x0e4c, 0x2390, \"Radica Games Jtech Controller\", 0, XTYPE_XBOX },\n\t{ 0x0e4c, 0x3510, \"Radica Gamester\", 0, XTYPE_XBOX },\n\t{ 0x0e6f, 0x0003, \"Logic3 Freebird wireless Controller\", 0, XTYPE_XBOX },\n\t{ 0x0e6f, 0x0005, \"Eclipse wireless Controller\", 0, XTYPE_XBOX },\n\t{ 0x0e6f, 0x0006, \"Edge wireless Controller\", 0, XTYPE_XBOX },\n\t{ 0x0e6f, 0x0008, \"After Glow Pro Controller\", 0, XTYPE_XBOX },\n\t{ 0x0e6f, 0x0105, \"HSM3 Xbox360 dancepad\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0113, \"Afterglow AX.1 Gamepad for Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x011f, \"Rock Candy Gamepad Wired Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0131, \"PDP EA Sports Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0133, \"Xbox 360 Wired Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0139, \"Afterglow Prismatic Wired Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x013a, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0146, \"Rock Candy Wired Controller for Xbox One\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0147, \"PDP Marvel Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x015c, \"PDP Xbox One Arcade Stick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0161, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0162, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0163, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0164, \"PDP Battlefield One\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0165, \"PDP Titanfall 2\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0201, \"Pelican PL-3601 'TSZ' Wired Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0213, \"Afterglow Gamepad for Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x021f, \"Rock Candy Gamepad for Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0246, \"Rock Candy Gamepad for Xbox One 2015\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a0, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a1, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a2, \"PDP Wired Controller for Xbox One - Crimson Red\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a4, \"PDP Wired Controller for Xbox One - Stealth Series\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a6, \"PDP Wired Controller for Xbox One - Camo Series\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a7, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02a8, \"PDP Xbox One Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02ab, \"PDP Controller for Xbox One\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02ad, \"PDP Wired Controller for Xbox One - Stealth Series\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02b3, \"Afterglow Prismatic Wired Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x02b8, \"Afterglow Prismatic Wired Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0301, \"Logic3 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0346, \"Rock Candy Gamepad for Xbox One 2016\", 0, XTYPE_XBOXONE },\n\t{ 0x0e6f, 0x0401, \"Logic3 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0413, \"Afterglow AX.1 Gamepad for Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0x0501, \"PDP Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x0e6f, 0xf900, \"PDP Afterglow AX.1\", 0, XTYPE_XBOX360 },\n\t{ 0x0e8f, 0x0201, \"SmartJoy Frag Xpad/PS2 adaptor\", 0, XTYPE_XBOX },\n\t{ 0x0e8f, 0x3008, \"Generic xbox control (dealextreme)\", 0, XTYPE_XBOX },\n\t{ 0x0f0d, 0x000a, \"Hori Co. DOA4 FightStick\", 0, XTYPE_XBOX360 },\n\t{ 0x0f0d, 0x000c, \"Hori PadEX Turbo\", 0, XTYPE_XBOX360 },\n\t{ 0x0f0d, 0x000d, \"Hori Fighting Stick EX2\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0f0d, 0x0016, \"Hori Real Arcade Pro.EX\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0f0d, 0x001b, \"Hori Real Arcade Pro VX\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0f0d, 0x0063, \"Hori Real Arcade Pro Hayabusa (USA) Xbox One\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },\n\t{ 0x0f0d, 0x0067, \"HORIPAD ONE\", 0, XTYPE_XBOXONE },\n\t{ 0x0f0d, 0x0078, \"Hori Real Arcade Pro V Kai Xbox One\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },\n\t{ 0x0f0d, 0x00c5, \"Hori Fighting Commander ONE\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },\n\t{ 0x0f0d, 0x00dc, \"HORIPAD FPS for Nintendo Switch\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x0f30, 0x010b, \"Philips Recoil\", 0, XTYPE_XBOX },\n\t{ 0x0f30, 0x0202, \"Joytech Advanced Controller\", 0, XTYPE_XBOX },\n\t{ 0x0f30, 0x8888, \"BigBen XBMiniPad Controller\", 0, XTYPE_XBOX },\n\t{ 0x102c, 0xff0c, \"Joytech Wireless Advanced Controller\", 0, XTYPE_XBOX },\n\t{ 0x1038, 0x1430, \"SteelSeries Stratus Duo\", 0, XTYPE_XBOX360 },\n\t{ 0x1038, 0x1431, \"SteelSeries Stratus Duo\", 0, XTYPE_XBOX360 },\n\t{ 0x11c9, 0x55f0, \"Nacon GC-100XF\", 0, XTYPE_XBOX360 },\n\t{ 0x11ff, 0x0511, \"PXN V900\", 0, XTYPE_XBOX360 },\n\t{ 0x1209, 0x2882, \"Ardwiino Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x12ab, 0x0004, \"Honey Bee Xbox360 dancepad\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x12ab, 0x0301, \"PDP AFTERGLOW AX.1\", 0, XTYPE_XBOX360 },\n\t{ 0x12ab, 0x0303, \"Mortal Kombat Klassic FightStick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x12ab, 0x8809, \"Xbox DDR dancepad\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x1430, 0x4748, \"RedOctane Guitar Hero X-plorer\", 0, XTYPE_XBOX360 },\n\t{ 0x1430, 0x8888, \"TX6500+ Dance Pad (first generation)\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },\n\t{ 0x1430, 0xf801, \"RedOctane Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x146b, 0x0601, \"BigBen Interactive XBOX 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x146b, 0x0604, \"Bigben Interactive DAIJA Arcade Stick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1532, 0x0a00, \"Razer Atrox Arcade Stick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },\n\t{ 0x1532, 0x0a03, \"Razer Wildcat\", 0, XTYPE_XBOXONE },\n\t{ 0x1532, 0x0a29, \"Razer Wolverine V2\", 0, XTYPE_XBOXONE },\n\t{ 0x15e4, 0x3f00, \"Power A Mini Pro Elite\", 0, XTYPE_XBOX360 },\n\t{ 0x15e4, 0x3f0a, \"Xbox Airflo wired controller\", 0, XTYPE_XBOX360 },\n\t{ 0x15e4, 0x3f10, \"Batarang Xbox 360 controller\", 0, XTYPE_XBOX360 },\n\t{ 0x162e, 0xbeef, \"Joytech Neo-Se Take2\", 0, XTYPE_XBOX360 },\n\t{ 0x1689, 0xfd00, \"Razer Onza Tournament Edition\", 0, XTYPE_XBOX360 },\n\t{ 0x1689, 0xfd01, \"Razer Onza Classic Edition\", 0, XTYPE_XBOX360 },\n\t{ 0x1689, 0xfe00, \"Razer Sabertooth\", 0, XTYPE_XBOX360 },\n\t{ 0x1949, 0x041a, \"Amazon Game Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0x0002, \"Harmonix Rock Band Guitar\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0x0003, \"Harmonix Rock Band Drumkit\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0x0130, \"Ion Drum Rocker\", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf016, \"Mad Catz Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf018, \"Mad Catz Street Fighter IV SE Fighting Stick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf019, \"Mad Catz Brawlstick for Xbox 360\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf021, \"Mad Cats Ghost Recon FS GamePad\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf023, \"MLG Pro Circuit Controller (Xbox)\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf025, \"Mad Catz Call Of Duty\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf027, \"Mad Catz FPS Pro\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf028, \"Street Fighter IV FightPad\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf02e, \"Mad Catz Fightpad\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf030, \"Mad Catz Xbox 360 MC2 MicroCon Racing Wheel\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf036, \"Mad Catz MicroCon GamePad Pro\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf038, \"Street Fighter IV FightStick TE\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf039, \"Mad Catz MvC2 TE\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf03a, \"Mad Catz SFxT Fightstick Pro\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf03d, \"Street Fighter IV Arcade Stick TE - Chun Li\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf03e, \"Mad Catz MLG FightStick TE\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf03f, \"Mad Catz FightStick SoulCaliber\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf042, \"Mad Catz FightStick TES+\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf080, \"Mad Catz FightStick TE2\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf501, \"HoriPad EX2 Turbo\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf502, \"Hori Real Arcade Pro.VX SA\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf503, \"Hori Fighting Stick VX\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf504, \"Hori Real Arcade Pro. EX\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf505, \"Hori Fighting Stick EX2B\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf506, \"Hori Real Arcade Pro.EX Premium VLX\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf900, \"Harmonix Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf901, \"Gamestop Xbox 360 Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf903, \"Tron Xbox 360 controller\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf904, \"PDP Versus Fighting Pad\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xf906, \"MortalKombat FightStick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xfa01, \"MadCatz GamePad\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xfd00, \"Razer Onza TE\", 0, XTYPE_XBOX360 },\n\t{ 0x1bad, 0xfd01, \"Razer Onza\", 0, XTYPE_XBOX360 },\n\t{ 0x20d6, 0x2001, \"BDA Xbox Series X Wired Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x20d6, 0x2009, \"PowerA Enhanced Wired Controller for Xbox Series X|S\", 0, XTYPE_XBOXONE },\n\t{ 0x20d6, 0x281f, \"PowerA Wired Controller For Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x2e24, 0x0652, \"Hyperkin Duke X-Box One pad\", 0, XTYPE_XBOXONE },\n\t{ 0x24c6, 0x5000, \"Razer Atrox Arcade Stick\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5300, \"PowerA MINI PROEX Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5303, \"Xbox Airflo wired controller\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x530a, \"Xbox 360 Pro EX Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x531a, \"PowerA Pro Ex\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5397, \"FUS1ON Tournament Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x541a, \"PowerA Xbox One Mini Wired Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x24c6, 0x542a, \"Xbox ONE spectra\", 0, XTYPE_XBOXONE },\n\t{ 0x24c6, 0x543a, \"PowerA Xbox One wired controller\", 0, XTYPE_XBOXONE },\n\t{ 0x24c6, 0x5500, \"Hori XBOX 360 EX 2 with Turbo\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5501, \"Hori Real Arcade Pro VX-SA\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5502, \"Hori Fighting Stick VX Alt\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5503, \"Hori Fighting Edge\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5506, \"Hori SOULCALIBUR V Stick\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5510, \"Hori Fighting Commander ONE (Xbox 360/PC Mode)\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x550d, \"Hori GEM Xbox controller\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x550e, \"Hori Real Arcade Pro V Kai 360\", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x551a, \"PowerA FUSION Pro Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x24c6, 0x561a, \"PowerA FUSION Controller\", 0, XTYPE_XBOXONE },\n\t{ 0x24c6, 0x5b00, \"ThrustMaster Ferrari 458 Racing Wheel\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5b02, \"Thrustmaster, Inc. GPX Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5b03, \"Thrustmaster Ferrari 458 Racing Wheel\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0x5d04, \"Razer Sabertooth\", 0, XTYPE_XBOX360 },\n\t{ 0x24c6, 0xfafe, \"Rock Candy Gamepad for Xbox 360\", 0, XTYPE_XBOX360 },\n\t{ 0x2563, 0x058d, \"OneXPlayer Gamepad\", 0, XTYPE_XBOX360 },\n\t{ 0x2dc8, 0x2000, \"8BitDo Pro 2 Wired Controller fox Xbox\", 0, XTYPE_XBOXONE },\n\t{ 0x2dc8, 0x3106, \"8BitDo Pro 2 Wired Controller\", 0, XTYPE_XBOX360 },\n\t{ 0x31e3, 0x1100, \"Wooting One\", 0, XTYPE_XBOX360 },\n\t{ 0x31e3, 0x1200, \"Wooting Two\", 0, XTYPE_XBOX360 },\n\t{ 0x31e3, 0x1210, \"Wooting Lekker\", 0, XTYPE_XBOX360 },\n\t{ 0x31e3, 0x1220, \"Wooting Two HE\", 0, XTYPE_XBOX360 },\n\t{ 0x31e3, 0x1300, \"Wooting 60HE (AVR)\", 0, XTYPE_XBOX360 },\n\t{ 0x31e3, 0x1310, \"Wooting 60HE (ARM)\", 0, XTYPE_XBOX360 },\n\t{ 0x3285, 0x0607, \"Nacon GC-100\", 0, XTYPE_XBOX360 },\n\t{ 0x3537, 0x1004, \"GameSir T4 Kaleid\", 0, XTYPE_XBOX360 },\n\t{ 0x3767, 0x0101, \"Fanatec Speedster 3 Forceshock Wheel\", 0, XTYPE_XBOX },\n\t{ 0xffff, 0xffff, \"Chinese-made Xbox Controller\", 0, XTYPE_XBOX },\n\t{ 0x0000, 0x0000, \"Generic X-Box pad\", 0, XTYPE_UNKNOWN }\n};\n\n \nstatic const signed short xpad_common_btn[] = {\n\tBTN_A, BTN_B, BTN_X, BTN_Y,\t\t\t \n\tBTN_START, BTN_SELECT, BTN_THUMBL, BTN_THUMBR,\t \n\t-1\t\t\t\t\t\t \n};\n\n \nstatic const signed short xpad_btn[] = {\n\tBTN_C, BTN_Z,\t\t \n\t-1\t\t\t \n};\n\n \nstatic const signed short xpad_btn_pad[] = {\n\tBTN_TRIGGER_HAPPY1, BTN_TRIGGER_HAPPY2,\t\t \n\tBTN_TRIGGER_HAPPY3, BTN_TRIGGER_HAPPY4,\t\t \n\t-1\t\t\t\t \n};\n\n \nstatic const signed short xpad_btn_triggers[] = {\n\tBTN_TL2, BTN_TR2,\t\t \n\t-1\n};\n\nstatic const signed short xpad360_btn[] = {   \n\tBTN_TL, BTN_TR,\t\t \n\tBTN_MODE,\t\t \n\t-1\n};\n\nstatic const signed short xpad_abs[] = {\n\tABS_X, ABS_Y,\t\t \n\tABS_RX, ABS_RY,\t\t \n\t-1\t\t\t \n};\n\n \nstatic const signed short xpad_abs_pad[] = {\n\tABS_HAT0X, ABS_HAT0Y,\t \n\t-1\t\t\t \n};\n\n \nstatic const signed short xpad_abs_triggers[] = {\n\tABS_Z, ABS_RZ,\t\t \n\t-1\n};\n\n \nstatic const signed short xpad_btn_paddles[] = {\n\tBTN_TRIGGER_HAPPY5, BTN_TRIGGER_HAPPY6,  \n\tBTN_TRIGGER_HAPPY7, BTN_TRIGGER_HAPPY8,  \n\t-1\t\t\t\t\t\t \n};\n\n \n#define XPAD_XBOX360_VENDOR_PROTOCOL(vend, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \\\n\t.bInterfaceSubClass = 93, \\\n\t.bInterfaceProtocol = (pr)\n#define XPAD_XBOX360_VENDOR(vend) \\\n\t{ XPAD_XBOX360_VENDOR_PROTOCOL((vend), 1) }, \\\n\t{ XPAD_XBOX360_VENDOR_PROTOCOL((vend), 129) }\n\n \n#define XPAD_XBOXONE_VENDOR_PROTOCOL(vend, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \\\n\t.bInterfaceSubClass = 71, \\\n\t.bInterfaceProtocol = (pr)\n#define XPAD_XBOXONE_VENDOR(vend) \\\n\t{ XPAD_XBOXONE_VENDOR_PROTOCOL((vend), 208) }\n\nstatic const struct usb_device_id xpad_table[] = {\n\t{ USB_INTERFACE_INFO('X', 'B', 0) },\t \n\tXPAD_XBOX360_VENDOR(0x0079),\t\t \n\tXPAD_XBOX360_VENDOR(0x03eb),\t\t \n\tXPAD_XBOXONE_VENDOR(0x03f0),\t\t \n\tXPAD_XBOX360_VENDOR(0x044f),\t\t \n\tXPAD_XBOX360_VENDOR(0x045e),\t\t \n\tXPAD_XBOXONE_VENDOR(0x045e),\t\t \n\tXPAD_XBOX360_VENDOR(0x046d),\t\t \n\tXPAD_XBOX360_VENDOR(0x056e),\t\t \n\tXPAD_XBOX360_VENDOR(0x06a3),\t\t \n\tXPAD_XBOX360_VENDOR(0x0738),\t\t \n\t{ USB_DEVICE(0x0738, 0x4540) },\t\t \n\tXPAD_XBOXONE_VENDOR(0x0738),\t\t \n\tXPAD_XBOX360_VENDOR(0x07ff),\t\t \n\tXPAD_XBOX360_VENDOR(0x0c12),\t\t \n\tXPAD_XBOX360_VENDOR(0x0e6f),\t\t \n\tXPAD_XBOXONE_VENDOR(0x0e6f),\t\t \n\tXPAD_XBOX360_VENDOR(0x0f0d),\t\t \n\tXPAD_XBOXONE_VENDOR(0x0f0d),\t\t \n\tXPAD_XBOX360_VENDOR(0x1038),\t\t \n\tXPAD_XBOXONE_VENDOR(0x10f5),\t\t \n\tXPAD_XBOX360_VENDOR(0x11c9),\t\t \n\tXPAD_XBOX360_VENDOR(0x11ff),\t\t \n\tXPAD_XBOX360_VENDOR(0x1209),\t\t \n\tXPAD_XBOX360_VENDOR(0x12ab),\t\t \n\tXPAD_XBOX360_VENDOR(0x1430),\t\t \n\tXPAD_XBOX360_VENDOR(0x146b),\t\t \n\tXPAD_XBOX360_VENDOR(0x1532),\t\t \n\tXPAD_XBOXONE_VENDOR(0x1532),\t\t \n\tXPAD_XBOX360_VENDOR(0x15e4),\t\t \n\tXPAD_XBOX360_VENDOR(0x162e),\t\t \n\tXPAD_XBOX360_VENDOR(0x1689),\t\t \n\tXPAD_XBOX360_VENDOR(0x1949),\t\t \n\tXPAD_XBOX360_VENDOR(0x1bad),\t\t \n\tXPAD_XBOX360_VENDOR(0x20d6),\t\t \n\tXPAD_XBOXONE_VENDOR(0x20d6),\t\t \n\tXPAD_XBOX360_VENDOR(0x24c6),\t\t \n\tXPAD_XBOXONE_VENDOR(0x24c6),\t\t \n\tXPAD_XBOX360_VENDOR(0x2563),\t\t \n\tXPAD_XBOX360_VENDOR(0x260d),\t\t \n\tXPAD_XBOX360_VENDOR(0x2c22),\t\t \n\tXPAD_XBOX360_VENDOR(0x2dc8),             \n\tXPAD_XBOXONE_VENDOR(0x2dc8),\t\t \n\tXPAD_XBOXONE_VENDOR(0x2e24),\t\t \n\tXPAD_XBOX360_VENDOR(0x2f24),\t\t \n\tXPAD_XBOX360_VENDOR(0x31e3),\t\t \n\tXPAD_XBOX360_VENDOR(0x3285),\t\t \n\tXPAD_XBOX360_VENDOR(0x3537),\t\t \n\tXPAD_XBOXONE_VENDOR(0x3537),\t\t \n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, xpad_table);\n\nstruct xboxone_init_packet {\n\tu16 idVendor;\n\tu16 idProduct;\n\tconst u8 *data;\n\tu8 len;\n};\n\n#define XBOXONE_INIT_PKT(_vid, _pid, _data)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.idVendor\t= (_vid),\t\t\\\n\t\t.idProduct\t= (_pid),\t\t\\\n\t\t.data\t\t= (_data),\t\t\\\n\t\t.len\t\t= ARRAY_SIZE(_data),\t\\\n\t}\n\n \n#define GIP_CMD_ACK      0x01\n#define GIP_CMD_IDENTIFY 0x04\n#define GIP_CMD_POWER    0x05\n#define GIP_CMD_AUTHENTICATE 0x06\n#define GIP_CMD_VIRTUAL_KEY  0x07\n#define GIP_CMD_RUMBLE   0x09\n#define GIP_CMD_LED      0x0a\n#define GIP_CMD_FIRMWARE 0x0c\n#define GIP_CMD_INPUT    0x20\n\n#define GIP_SEQ0 0x00\n\n#define GIP_OPT_ACK      0x10\n#define GIP_OPT_INTERNAL 0x20\n\n \n#define GIP_PL_LEN(N) (N)\n\n \n#define GIP_PWR_ON 0x00\n#define GIP_LED_ON 0x01\n\n#define GIP_MOTOR_R  BIT(0)\n#define GIP_MOTOR_L  BIT(1)\n#define GIP_MOTOR_RT BIT(2)\n#define GIP_MOTOR_LT BIT(3)\n#define GIP_MOTOR_ALL (GIP_MOTOR_R | GIP_MOTOR_L | GIP_MOTOR_RT | GIP_MOTOR_LT)\n\n#define GIP_WIRED_INTF_DATA 0\n#define GIP_WIRED_INTF_AUDIO 1\n\n \nstatic const u8 xboxone_power_on[] = {\n\tGIP_CMD_POWER, GIP_OPT_INTERNAL, GIP_SEQ0, GIP_PL_LEN(1), GIP_PWR_ON\n};\n\n \nstatic const u8 xboxone_s_init[] = {\n\tGIP_CMD_POWER, GIP_OPT_INTERNAL, GIP_SEQ0, 0x0f, 0x06\n};\n\n \nstatic const u8 extra_input_packet_init[] = {\n\t0x4d, 0x10, 0x01, 0x02, 0x07, 0x00\n};\n\n \nstatic const u8 xboxone_hori_ack_id[] = {\n\tGIP_CMD_ACK, GIP_OPT_INTERNAL, GIP_SEQ0, GIP_PL_LEN(9),\n\t0x00, GIP_CMD_IDENTIFY, GIP_OPT_INTERNAL, 0x3a, 0x00, 0x00, 0x00, 0x80, 0x00\n};\n\n \nstatic const u8 xboxone_pdp_led_on[] = {\n\tGIP_CMD_LED, GIP_OPT_INTERNAL, GIP_SEQ0, GIP_PL_LEN(3), 0x00, GIP_LED_ON, 0x14\n};\n\n \nstatic const u8 xboxone_pdp_auth[] = {\n\tGIP_CMD_AUTHENTICATE, GIP_OPT_INTERNAL, GIP_SEQ0, GIP_PL_LEN(2), 0x01, 0x00\n};\n\n \nstatic const u8 xboxone_rumblebegin_init[] = {\n\tGIP_CMD_RUMBLE, 0x00, GIP_SEQ0, GIP_PL_LEN(9),\n\t0x00, GIP_MOTOR_ALL, 0x00, 0x00, 0x1D, 0x1D, 0xFF, 0x00, 0x00\n};\n\n \nstatic const u8 xboxone_rumbleend_init[] = {\n\tGIP_CMD_RUMBLE, 0x00, GIP_SEQ0, GIP_PL_LEN(9),\n\t0x00, GIP_MOTOR_ALL, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n \nstatic const struct xboxone_init_packet xboxone_init_packets[] = {\n\tXBOXONE_INIT_PKT(0x0e6f, 0x0165, xboxone_hori_ack_id),\n\tXBOXONE_INIT_PKT(0x0f0d, 0x0067, xboxone_hori_ack_id),\n\tXBOXONE_INIT_PKT(0x0000, 0x0000, xboxone_power_on),\n\tXBOXONE_INIT_PKT(0x045e, 0x02ea, xboxone_s_init),\n\tXBOXONE_INIT_PKT(0x045e, 0x0b00, xboxone_s_init),\n\tXBOXONE_INIT_PKT(0x045e, 0x0b00, extra_input_packet_init),\n\tXBOXONE_INIT_PKT(0x0e6f, 0x0000, xboxone_pdp_led_on),\n\tXBOXONE_INIT_PKT(0x0e6f, 0x0000, xboxone_pdp_auth),\n\tXBOXONE_INIT_PKT(0x24c6, 0x541a, xboxone_rumblebegin_init),\n\tXBOXONE_INIT_PKT(0x24c6, 0x542a, xboxone_rumblebegin_init),\n\tXBOXONE_INIT_PKT(0x24c6, 0x543a, xboxone_rumblebegin_init),\n\tXBOXONE_INIT_PKT(0x24c6, 0x541a, xboxone_rumbleend_init),\n\tXBOXONE_INIT_PKT(0x24c6, 0x542a, xboxone_rumbleend_init),\n\tXBOXONE_INIT_PKT(0x24c6, 0x543a, xboxone_rumbleend_init),\n};\n\nstruct xpad_output_packet {\n\tu8 data[XPAD_PKT_LEN];\n\tu8 len;\n\tbool pending;\n};\n\n#define XPAD_OUT_CMD_IDX\t0\n#define XPAD_OUT_FF_IDX\t\t1\n#define XPAD_OUT_LED_IDX\t(1 + IS_ENABLED(CONFIG_JOYSTICK_XPAD_FF))\n#define XPAD_NUM_OUT_PACKETS\t(1 + \\\n\t\t\t\t IS_ENABLED(CONFIG_JOYSTICK_XPAD_FF) + \\\n\t\t\t\t IS_ENABLED(CONFIG_JOYSTICK_XPAD_LEDS))\n\nstruct usb_xpad {\n\tstruct input_dev *dev;\t\t \n\tstruct input_dev __rcu *x360w_dev;\n\tstruct usb_device *udev;\t \n\tstruct usb_interface *intf;\t \n\n\tbool pad_present;\n\tbool input_created;\n\n\tstruct urb *irq_in;\t\t \n\tunsigned char *idata;\t\t \n\tdma_addr_t idata_dma;\n\n\tstruct urb *irq_out;\t\t \n\tstruct usb_anchor irq_out_anchor;\n\tbool irq_out_active;\t\t \n\tu8 odata_serial;\t\t \n\tunsigned char *odata;\t\t \n\tdma_addr_t odata_dma;\n\tspinlock_t odata_lock;\n\n\tstruct xpad_output_packet out_packets[XPAD_NUM_OUT_PACKETS];\n\tint last_out_packet;\n\tint init_seq;\n\n#if defined(CONFIG_JOYSTICK_XPAD_LEDS)\n\tstruct xpad_led *led;\n#endif\n\n\tchar phys[64];\t\t\t \n\n\tint mapping;\t\t\t \n\tint xtype;\t\t\t \n\tint packet_type;\t\t \n\tint pad_nr;\t\t\t \n\tconst char *name;\t\t \n\tstruct work_struct work;\t \n\ttime64_t mode_btn_down_ts;\n};\n\nstatic int xpad_init_input(struct usb_xpad *xpad);\nstatic void xpad_deinit_input(struct usb_xpad *xpad);\nstatic void xpadone_ack_mode_report(struct usb_xpad *xpad, u8 seq_num);\nstatic void xpad360w_poweroff_controller(struct usb_xpad *xpad);\n\n \nstatic void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\n{\n\tstruct input_dev *dev = xpad->dev;\n\n\tif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\n\t\t \n\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t (__s16) le16_to_cpup((__le16 *)(data + 12)));\n\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t ~(__s16) le16_to_cpup((__le16 *)(data + 14)));\n\n\t\t \n\t\tinput_report_abs(dev, ABS_RX,\n\t\t\t\t (__s16) le16_to_cpup((__le16 *)(data + 16)));\n\t\tinput_report_abs(dev, ABS_RY,\n\t\t\t\t ~(__s16) le16_to_cpup((__le16 *)(data + 18)));\n\t}\n\n\t \n\tif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\n\t\tinput_report_key(dev, BTN_TL2, data[10]);\n\t\tinput_report_key(dev, BTN_TR2, data[11]);\n\t} else {\n\t\tinput_report_abs(dev, ABS_Z, data[10]);\n\t\tinput_report_abs(dev, ABS_RZ, data[11]);\n\t}\n\n\t \n\tif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\n\t\t \n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & BIT(2));\n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & BIT(3));\n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & BIT(0));\n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & BIT(1));\n\t} else {\n\t\tinput_report_abs(dev, ABS_HAT0X,\n\t\t\t\t !!(data[2] & 0x08) - !!(data[2] & 0x04));\n\t\tinput_report_abs(dev, ABS_HAT0Y,\n\t\t\t\t !!(data[2] & 0x02) - !!(data[2] & 0x01));\n\t}\n\n\t \n\tinput_report_key(dev, BTN_START,  data[2] & BIT(4));\n\tinput_report_key(dev, BTN_SELECT, data[2] & BIT(5));\n\tinput_report_key(dev, BTN_THUMBL, data[2] & BIT(6));\n\tinput_report_key(dev, BTN_THUMBR, data[2] & BIT(7));\n\n\t \n\tinput_report_key(dev, BTN_A, data[4]);\n\tinput_report_key(dev, BTN_B, data[5]);\n\tinput_report_key(dev, BTN_X, data[6]);\n\tinput_report_key(dev, BTN_Y, data[7]);\n\n\t \n\tinput_report_key(dev, BTN_C, data[8]);\n\tinput_report_key(dev, BTN_Z, data[9]);\n\n\n\tinput_sync(dev);\n}\n\n \n\nstatic void xpad360_process_packet(struct usb_xpad *xpad, struct input_dev *dev,\n\t\t\t\t   u16 cmd, unsigned char *data)\n{\n\t \n\tif (data[0] != 0x00)\n\t\treturn;\n\n\t \n\tif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\n\t\t \n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & BIT(2));\n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & BIT(3));\n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & BIT(0));\n\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & BIT(1));\n\t}\n\n\t \n\tif (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||\n\t    xpad->xtype == XTYPE_XBOX360W) {\n\t\tinput_report_abs(dev, ABS_HAT0X,\n\t\t\t\t !!(data[2] & 0x08) - !!(data[2] & 0x04));\n\t\tinput_report_abs(dev, ABS_HAT0Y,\n\t\t\t\t !!(data[2] & 0x02) - !!(data[2] & 0x01));\n\t}\n\n\t \n\tinput_report_key(dev, BTN_START,  data[2] & BIT(4));\n\tinput_report_key(dev, BTN_SELECT, data[2] & BIT(5));\n\n\t \n\tinput_report_key(dev, BTN_THUMBL, data[2] & BIT(6));\n\tinput_report_key(dev, BTN_THUMBR, data[2] & BIT(7));\n\n\t \n\tinput_report_key(dev, BTN_A,\tdata[3] & BIT(4));\n\tinput_report_key(dev, BTN_B,\tdata[3] & BIT(5));\n\tinput_report_key(dev, BTN_X,\tdata[3] & BIT(6));\n\tinput_report_key(dev, BTN_Y,\tdata[3] & BIT(7));\n\tinput_report_key(dev, BTN_TL,\tdata[3] & BIT(0));\n\tinput_report_key(dev, BTN_TR,\tdata[3] & BIT(1));\n\tinput_report_key(dev, BTN_MODE,\tdata[3] & BIT(2));\n\n\tif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\n\t\t \n\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t (__s16) le16_to_cpup((__le16 *)(data + 6)));\n\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t ~(__s16) le16_to_cpup((__le16 *)(data + 8)));\n\n\t\t \n\t\tinput_report_abs(dev, ABS_RX,\n\t\t\t\t (__s16) le16_to_cpup((__le16 *)(data + 10)));\n\t\tinput_report_abs(dev, ABS_RY,\n\t\t\t\t ~(__s16) le16_to_cpup((__le16 *)(data + 12)));\n\t}\n\n\t \n\tif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\n\t\tinput_report_key(dev, BTN_TL2, data[4]);\n\t\tinput_report_key(dev, BTN_TR2, data[5]);\n\t} else {\n\t\tinput_report_abs(dev, ABS_Z, data[4]);\n\t\tinput_report_abs(dev, ABS_RZ, data[5]);\n\t}\n\n\tinput_sync(dev);\n\n\t \n\tif (xpad->xtype == XTYPE_XBOX360W) {\n\t\tif (xpad->mode_btn_down_ts > 0 && xpad->pad_present &&\n\t\t    ((ktime_get_seconds() - xpad->mode_btn_down_ts) >=\n\t\t     XPAD360W_POWEROFF_TIMEOUT)) {\n\t\t\txpad360w_poweroff_controller(xpad);\n\t\t\txpad->mode_btn_down_ts = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (data[3] & BIT(2))\n\t\t\txpad->mode_btn_down_ts = ktime_get_seconds();\n\t\telse\n\t\t\txpad->mode_btn_down_ts = 0;\n\t}\n}\n\nstatic void xpad_presence_work(struct work_struct *work)\n{\n\tstruct usb_xpad *xpad = container_of(work, struct usb_xpad, work);\n\tint error;\n\n\tif (xpad->pad_present) {\n\t\terror = xpad_init_input(xpad);\n\t\tif (error) {\n\t\t\t \n\t\t\tdev_err(&xpad->dev->dev,\n\t\t\t\t\"unable to init device: %d\\n\", error);\n\t\t} else {\n\t\t\trcu_assign_pointer(xpad->x360w_dev, xpad->dev);\n\t\t}\n\t} else {\n\t\tRCU_INIT_POINTER(xpad->x360w_dev, NULL);\n\t\tsynchronize_rcu();\n\t\t \n\t\txpad_deinit_input(xpad);\n\t}\n}\n\n \nstatic void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\n{\n\tstruct input_dev *dev;\n\tbool present;\n\n\t \n\tif (data[0] & 0x08) {\n\t\tpresent = (data[1] & 0x80) != 0;\n\n\t\tif (xpad->pad_present != present) {\n\t\t\txpad->pad_present = present;\n\t\t\tschedule_work(&xpad->work);\n\t\t}\n\t}\n\n\t \n\tif (data[1] != 0x1)\n\t\treturn;\n\n\trcu_read_lock();\n\tdev = rcu_dereference(xpad->x360w_dev);\n\tif (dev)\n\t\txpad360_process_packet(xpad, dev, cmd, &data[4]);\n\trcu_read_unlock();\n}\n\n \nstatic void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\n{\n\tstruct input_dev *dev = xpad->dev;\n\tbool do_sync = false;\n\n\t \n\tif (data[0] == GIP_CMD_VIRTUAL_KEY) {\n\t\t \n\t\tif (data[1] == (GIP_OPT_ACK | GIP_OPT_INTERNAL))\n\t\t\txpadone_ack_mode_report(xpad, data[2]);\n\n\t\tinput_report_key(dev, BTN_MODE, data[4] & GENMASK(1, 0));\n\t\tinput_sync(dev);\n\n\t\tdo_sync = true;\n\t} else if (data[0] == GIP_CMD_FIRMWARE) {\n\t\t \n\t\tif (xpad->packet_type == PKT_XBE2_FW_5_11) {\n\t\t\t \n\t\t\tif (data[19] != 0)\n\t\t\t\tdata[18] = 0;\n\n\t\t\t \n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY5, data[18] & BIT(0));\n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY6, data[18] & BIT(1));\n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY7, data[18] & BIT(2));\n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY8, data[18] & BIT(3));\n\n\t\t\tdo_sync = true;\n\t\t}\n\t} else if (data[0] == GIP_CMD_INPUT) {  \n\t\t \n\t\tinput_report_key(dev, BTN_START,  data[4] & BIT(2));\n\t\tinput_report_key(dev, BTN_SELECT, data[4] & BIT(3));\n\t\tif (xpad->mapping & MAP_SELECT_BUTTON)\n\t\t\tinput_report_key(dev, KEY_RECORD, data[22] & BIT(0));\n\n\t\t \n\t\tinput_report_key(dev, BTN_A,\tdata[4] & BIT(4));\n\t\tinput_report_key(dev, BTN_B,\tdata[4] & BIT(5));\n\t\tinput_report_key(dev, BTN_X,\tdata[4] & BIT(6));\n\t\tinput_report_key(dev, BTN_Y,\tdata[4] & BIT(7));\n\n\t\t \n\t\tif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\n\t\t\t \n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY1, data[5] & BIT(2));\n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY2, data[5] & BIT(3));\n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY3, data[5] & BIT(0));\n\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY4, data[5] & BIT(1));\n\t\t} else {\n\t\t\tinput_report_abs(dev, ABS_HAT0X,\n\t\t\t\t\t!!(data[5] & 0x08) - !!(data[5] & 0x04));\n\t\t\tinput_report_abs(dev, ABS_HAT0Y,\n\t\t\t\t\t!!(data[5] & 0x02) - !!(data[5] & 0x01));\n\t\t}\n\n\t\t \n\t\tinput_report_key(dev, BTN_TL,\tdata[5] & BIT(4));\n\t\tinput_report_key(dev, BTN_TR,\tdata[5] & BIT(5));\n\n\t\t \n\t\tinput_report_key(dev, BTN_THUMBL, data[5] & BIT(6));\n\t\tinput_report_key(dev, BTN_THUMBR, data[5] & BIT(7));\n\n\t\tif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\n\t\t\t \n\t\t\tinput_report_abs(dev, ABS_X,\n\t\t\t\t\t(__s16) le16_to_cpup((__le16 *)(data + 10)));\n\t\t\tinput_report_abs(dev, ABS_Y,\n\t\t\t\t\t~(__s16) le16_to_cpup((__le16 *)(data + 12)));\n\n\t\t\t \n\t\t\tinput_report_abs(dev, ABS_RX,\n\t\t\t\t\t(__s16) le16_to_cpup((__le16 *)(data + 14)));\n\t\t\tinput_report_abs(dev, ABS_RY,\n\t\t\t\t\t~(__s16) le16_to_cpup((__le16 *)(data + 16)));\n\t\t}\n\n\t\t \n\t\tif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\n\t\t\tinput_report_key(dev, BTN_TL2,\n\t\t\t\t\t(__u16) le16_to_cpup((__le16 *)(data + 6)));\n\t\t\tinput_report_key(dev, BTN_TR2,\n\t\t\t\t\t(__u16) le16_to_cpup((__le16 *)(data + 8)));\n\t\t} else {\n\t\t\tinput_report_abs(dev, ABS_Z,\n\t\t\t\t\t(__u16) le16_to_cpup((__le16 *)(data + 6)));\n\t\t\tinput_report_abs(dev, ABS_RZ,\n\t\t\t\t\t(__u16) le16_to_cpup((__le16 *)(data + 8)));\n\t\t}\n\n\t\t \n\t\tif (xpad->mapping & MAP_PROFILE_BUTTON)\n\t\t\tinput_report_abs(dev, ABS_PROFILE, data[34]);\n\n\t\t \n\t\t \n\t\tif (xpad->mapping & MAP_PADDLES) {\n\t\t\tif (xpad->packet_type == PKT_XBE1) {\n\t\t\t\t \n\t\t\t\tif (memcmp(&data[4], &data[18], 2) != 0)\n\t\t\t\t\tdata[32] = 0;\n\n\t\t\t\t \n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY5, data[32] & BIT(1));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY6, data[32] & BIT(3));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY7, data[32] & BIT(0));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY8, data[32] & BIT(2));\n\t\t\t} else if (xpad->packet_type == PKT_XBE2_FW_OLD) {\n\t\t\t\t \n\t\t\t\tif (data[19] != 0)\n\t\t\t\t\tdata[18] = 0;\n\n\t\t\t\t \n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY5, data[18] & BIT(0));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY6, data[18] & BIT(1));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY7, data[18] & BIT(2));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY8, data[18] & BIT(3));\n\t\t\t} else if (xpad->packet_type == PKT_XBE2_FW_5_EARLY) {\n\t\t\t\t \n\t\t\t\tif (data[23] != 0)\n\t\t\t\t\tdata[22] = 0;\n\n\t\t\t\t \n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY5, data[22] & BIT(0));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY6, data[22] & BIT(1));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY7, data[22] & BIT(2));\n\t\t\t\tinput_report_key(dev, BTN_TRIGGER_HAPPY8, data[22] & BIT(3));\n\t\t\t}\n\t\t}\n\n\t\tdo_sync = true;\n\t}\n\n\tif (do_sync)\n\t\tinput_sync(dev);\n}\n\nstatic void xpad_irq_in(struct urb *urb)\n{\n\tstruct usb_xpad *xpad = urb->context;\n\tstruct device *dev = &xpad->intf->dev;\n\tint retval, status;\n\n\tstatus = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tswitch (xpad->xtype) {\n\tcase XTYPE_XBOX360:\n\t\txpad360_process_packet(xpad, xpad->dev, 0, xpad->idata);\n\t\tbreak;\n\tcase XTYPE_XBOX360W:\n\t\txpad360w_process_packet(xpad, 0, xpad->idata);\n\t\tbreak;\n\tcase XTYPE_XBOXONE:\n\t\txpadone_process_packet(xpad, 0, xpad->idata);\n\t\tbreak;\n\tdefault:\n\t\txpad_process_packet(xpad, 0, xpad->idata);\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n}\n\n \nstatic bool xpad_prepare_next_init_packet(struct usb_xpad *xpad)\n{\n\tconst struct xboxone_init_packet *init_packet;\n\n\tif (xpad->xtype != XTYPE_XBOXONE)\n\t\treturn false;\n\n\t \n\twhile (xpad->init_seq < ARRAY_SIZE(xboxone_init_packets)) {\n\t\tinit_packet = &xboxone_init_packets[xpad->init_seq++];\n\n\t\tif (init_packet->idVendor != 0 &&\n\t\t    init_packet->idVendor != xpad->dev->id.vendor)\n\t\t\tcontinue;\n\n\t\tif (init_packet->idProduct != 0 &&\n\t\t    init_packet->idProduct != xpad->dev->id.product)\n\t\t\tcontinue;\n\n\t\t \n\t\tmemcpy(xpad->odata, init_packet->data, init_packet->len);\n\t\txpad->irq_out->transfer_buffer_length = init_packet->len;\n\n\t\t \n\t\txpad->odata[2] = xpad->odata_serial++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool xpad_prepare_next_out_packet(struct usb_xpad *xpad)\n{\n\tstruct xpad_output_packet *pkt, *packet = NULL;\n\tint i;\n\n\t \n\tif (xpad_prepare_next_init_packet(xpad))\n\t\treturn true;\n\n\tfor (i = 0; i < XPAD_NUM_OUT_PACKETS; i++) {\n\t\tif (++xpad->last_out_packet >= XPAD_NUM_OUT_PACKETS)\n\t\t\txpad->last_out_packet = 0;\n\n\t\tpkt = &xpad->out_packets[xpad->last_out_packet];\n\t\tif (pkt->pending) {\n\t\t\tdev_dbg(&xpad->intf->dev,\n\t\t\t\t\"%s - found pending output packet %d\\n\",\n\t\t\t\t__func__, xpad->last_out_packet);\n\t\t\tpacket = pkt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (packet) {\n\t\tmemcpy(xpad->odata, packet->data, packet->len);\n\t\txpad->irq_out->transfer_buffer_length = packet->len;\n\t\tpacket->pending = false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int xpad_try_sending_next_out_packet(struct usb_xpad *xpad)\n{\n\tint error;\n\n\tif (!xpad->irq_out_active && xpad_prepare_next_out_packet(xpad)) {\n\t\tusb_anchor_urb(xpad->irq_out, &xpad->irq_out_anchor);\n\t\terror = usb_submit_urb(xpad->irq_out, GFP_ATOMIC);\n\t\tif (error) {\n\t\t\tdev_err(&xpad->intf->dev,\n\t\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\tusb_unanchor_urb(xpad->irq_out);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\txpad->irq_out_active = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void xpad_irq_out(struct urb *urb)\n{\n\tstruct usb_xpad *xpad = urb->context;\n\tstruct device *dev = &xpad->intf->dev;\n\tint status = urb->status;\n\tint error;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\txpad->irq_out_active = xpad_prepare_next_out_packet(xpad);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\txpad->irq_out_active = false;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tbreak;\n\t}\n\n\tif (xpad->irq_out_active) {\n\t\tusb_anchor_urb(urb, &xpad->irq_out_anchor);\n\t\terror = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (error) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\txpad->irq_out_active = false;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n}\n\nstatic int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad,\n\t\t\tstruct usb_endpoint_descriptor *ep_irq_out)\n{\n\tint error;\n\n\tif (xpad->xtype == XTYPE_UNKNOWN)\n\t\treturn 0;\n\n\tinit_usb_anchor(&xpad->irq_out_anchor);\n\n\txpad->odata = usb_alloc_coherent(xpad->udev, XPAD_PKT_LEN,\n\t\t\t\t\t GFP_KERNEL, &xpad->odata_dma);\n\tif (!xpad->odata)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&xpad->odata_lock);\n\n\txpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!xpad->irq_out) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_coherent;\n\t}\n\n\tusb_fill_int_urb(xpad->irq_out, xpad->udev,\n\t\t\t usb_sndintpipe(xpad->udev, ep_irq_out->bEndpointAddress),\n\t\t\t xpad->odata, XPAD_PKT_LEN,\n\t\t\t xpad_irq_out, xpad, ep_irq_out->bInterval);\n\txpad->irq_out->transfer_dma = xpad->odata_dma;\n\txpad->irq_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn 0;\n\nerr_free_coherent:\n\tusb_free_coherent(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);\n\treturn error;\n}\n\nstatic void xpad_stop_output(struct usb_xpad *xpad)\n{\n\tif (xpad->xtype != XTYPE_UNKNOWN) {\n\t\tif (!usb_wait_anchor_empty_timeout(&xpad->irq_out_anchor,\n\t\t\t\t\t\t   5000)) {\n\t\t\tdev_warn(&xpad->intf->dev,\n\t\t\t\t \"timed out waiting for output URB to complete, killing\\n\");\n\t\t\tusb_kill_anchored_urbs(&xpad->irq_out_anchor);\n\t\t}\n\t}\n}\n\nstatic void xpad_deinit_output(struct usb_xpad *xpad)\n{\n\tif (xpad->xtype != XTYPE_UNKNOWN) {\n\t\tusb_free_urb(xpad->irq_out);\n\t\tusb_free_coherent(xpad->udev, XPAD_PKT_LEN,\n\t\t\t\txpad->odata, xpad->odata_dma);\n\t}\n}\n\nstatic int xpad_inquiry_pad_presence(struct usb_xpad *xpad)\n{\n\tstruct xpad_output_packet *packet =\n\t\t\t&xpad->out_packets[XPAD_OUT_CMD_IDX];\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\tpacket->data[0] = 0x08;\n\tpacket->data[1] = 0x00;\n\tpacket->data[2] = 0x0F;\n\tpacket->data[3] = 0xC0;\n\tpacket->data[4] = 0x00;\n\tpacket->data[5] = 0x00;\n\tpacket->data[6] = 0x00;\n\tpacket->data[7] = 0x00;\n\tpacket->data[8] = 0x00;\n\tpacket->data[9] = 0x00;\n\tpacket->data[10] = 0x00;\n\tpacket->data[11] = 0x00;\n\tpacket->len = 12;\n\tpacket->pending = true;\n\n\t \n\txpad->last_out_packet = -1;\n\tretval = xpad_try_sending_next_out_packet(xpad);\n\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n\n\treturn retval;\n}\n\nstatic int xpad_start_xbox_one(struct usb_xpad *xpad)\n{\n\tunsigned long flags;\n\tint retval;\n\n\tif (usb_ifnum_to_if(xpad->udev, GIP_WIRED_INTF_AUDIO)) {\n\t\t \n\t\tretval = usb_set_interface(xpad->udev,\n\t\t\t\t\t   GIP_WIRED_INTF_AUDIO, 0);\n\t\tif (retval)\n\t\t\tdev_warn(&xpad->dev->dev,\n\t\t\t\t \"unable to disable audio interface: %d\\n\",\n\t\t\t\t retval);\n\t}\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\t \n\txpad->init_seq = 0;\n\tretval = xpad_try_sending_next_out_packet(xpad);\n\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n\n\treturn retval;\n}\n\nstatic void xpadone_ack_mode_report(struct usb_xpad *xpad, u8 seq_num)\n{\n\tunsigned long flags;\n\tstruct xpad_output_packet *packet =\n\t\t\t&xpad->out_packets[XPAD_OUT_CMD_IDX];\n\tstatic const u8 mode_report_ack[] = {\n\t\tGIP_CMD_ACK, GIP_OPT_INTERNAL, GIP_SEQ0, GIP_PL_LEN(9),\n\t\t0x00, GIP_CMD_VIRTUAL_KEY, GIP_OPT_INTERNAL, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\tpacket->len = sizeof(mode_report_ack);\n\tmemcpy(packet->data, mode_report_ack, packet->len);\n\tpacket->data[2] = seq_num;\n\tpacket->pending = true;\n\n\t \n\txpad->last_out_packet = -1;\n\txpad_try_sending_next_out_packet(xpad);\n\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n}\n\n#ifdef CONFIG_JOYSTICK_XPAD_FF\nstatic int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)\n{\n\tstruct usb_xpad *xpad = input_get_drvdata(dev);\n\tstruct xpad_output_packet *packet = &xpad->out_packets[XPAD_OUT_FF_IDX];\n\t__u16 strong;\n\t__u16 weak;\n\tint retval;\n\tunsigned long flags;\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\tstrong = effect->u.rumble.strong_magnitude;\n\tweak = effect->u.rumble.weak_magnitude;\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\tswitch (xpad->xtype) {\n\tcase XTYPE_XBOX:\n\t\tpacket->data[0] = 0x00;\n\t\tpacket->data[1] = 0x06;\n\t\tpacket->data[2] = 0x00;\n\t\tpacket->data[3] = strong / 256;\t \n\t\tpacket->data[4] = 0x00;\n\t\tpacket->data[5] = weak / 256;\t \n\t\tpacket->len = 6;\n\t\tpacket->pending = true;\n\t\tbreak;\n\n\tcase XTYPE_XBOX360:\n\t\tpacket->data[0] = 0x00;\n\t\tpacket->data[1] = 0x08;\n\t\tpacket->data[2] = 0x00;\n\t\tpacket->data[3] = strong / 256;   \n\t\tpacket->data[4] = weak / 256;\t \n\t\tpacket->data[5] = 0x00;\n\t\tpacket->data[6] = 0x00;\n\t\tpacket->data[7] = 0x00;\n\t\tpacket->len = 8;\n\t\tpacket->pending = true;\n\t\tbreak;\n\n\tcase XTYPE_XBOX360W:\n\t\tpacket->data[0] = 0x00;\n\t\tpacket->data[1] = 0x01;\n\t\tpacket->data[2] = 0x0F;\n\t\tpacket->data[3] = 0xC0;\n\t\tpacket->data[4] = 0x00;\n\t\tpacket->data[5] = strong / 256;\n\t\tpacket->data[6] = weak / 256;\n\t\tpacket->data[7] = 0x00;\n\t\tpacket->data[8] = 0x00;\n\t\tpacket->data[9] = 0x00;\n\t\tpacket->data[10] = 0x00;\n\t\tpacket->data[11] = 0x00;\n\t\tpacket->len = 12;\n\t\tpacket->pending = true;\n\t\tbreak;\n\n\tcase XTYPE_XBOXONE:\n\t\tpacket->data[0] = GIP_CMD_RUMBLE;  \n\t\tpacket->data[1] = 0x00;\n\t\tpacket->data[2] = xpad->odata_serial++;\n\t\tpacket->data[3] = GIP_PL_LEN(9);\n\t\tpacket->data[4] = 0x00;\n\t\tpacket->data[5] = GIP_MOTOR_ALL;\n\t\tpacket->data[6] = 0x00;  \n\t\tpacket->data[7] = 0x00;  \n\t\tpacket->data[8] = strong / 512;\t \n\t\tpacket->data[9] = weak / 512;\t \n\t\tpacket->data[10] = 0xFF;  \n\t\tpacket->data[11] = 0x00;  \n\t\tpacket->data[12] = 0xFF;  \n\t\tpacket->len = 13;\n\t\tpacket->pending = true;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&xpad->dev->dev,\n\t\t\t\"%s - rumble command sent to unsupported xpad type: %d\\n\",\n\t\t\t__func__, xpad->xtype);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = xpad_try_sending_next_out_packet(xpad);\n\nout:\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n\treturn retval;\n}\n\nstatic int xpad_init_ff(struct usb_xpad *xpad)\n{\n\tif (xpad->xtype == XTYPE_UNKNOWN)\n\t\treturn 0;\n\n\tinput_set_capability(xpad->dev, EV_FF, FF_RUMBLE);\n\n\treturn input_ff_create_memless(xpad->dev, NULL, xpad_play_effect);\n}\n\n#else\nstatic int xpad_init_ff(struct usb_xpad *xpad) { return 0; }\n#endif\n\n#if defined(CONFIG_JOYSTICK_XPAD_LEDS)\n#include <linux/leds.h>\n#include <linux/idr.h>\n\nstatic DEFINE_IDA(xpad_pad_seq);\n\nstruct xpad_led {\n\tchar name[16];\n\tstruct led_classdev led_cdev;\n\tstruct usb_xpad *xpad;\n};\n\n \nstatic void xpad_send_led_command(struct usb_xpad *xpad, int command)\n{\n\tstruct xpad_output_packet *packet =\n\t\t\t&xpad->out_packets[XPAD_OUT_LED_IDX];\n\tunsigned long flags;\n\n\tcommand %= 16;\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\tswitch (xpad->xtype) {\n\tcase XTYPE_XBOX360:\n\t\tpacket->data[0] = 0x01;\n\t\tpacket->data[1] = 0x03;\n\t\tpacket->data[2] = command;\n\t\tpacket->len = 3;\n\t\tpacket->pending = true;\n\t\tbreak;\n\n\tcase XTYPE_XBOX360W:\n\t\tpacket->data[0] = 0x00;\n\t\tpacket->data[1] = 0x00;\n\t\tpacket->data[2] = 0x08;\n\t\tpacket->data[3] = 0x40 + command;\n\t\tpacket->data[4] = 0x00;\n\t\tpacket->data[5] = 0x00;\n\t\tpacket->data[6] = 0x00;\n\t\tpacket->data[7] = 0x00;\n\t\tpacket->data[8] = 0x00;\n\t\tpacket->data[9] = 0x00;\n\t\tpacket->data[10] = 0x00;\n\t\tpacket->data[11] = 0x00;\n\t\tpacket->len = 12;\n\t\tpacket->pending = true;\n\t\tbreak;\n\t}\n\n\txpad_try_sending_next_out_packet(xpad);\n\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n}\n\n \nstatic void xpad_identify_controller(struct usb_xpad *xpad)\n{\n\tled_set_brightness(&xpad->led->led_cdev, (xpad->pad_nr % 4) + 2);\n}\n\nstatic void xpad_led_set(struct led_classdev *led_cdev,\n\t\t\t enum led_brightness value)\n{\n\tstruct xpad_led *xpad_led = container_of(led_cdev,\n\t\t\t\t\t\t struct xpad_led, led_cdev);\n\n\txpad_send_led_command(xpad_led->xpad, value);\n}\n\nstatic int xpad_led_probe(struct usb_xpad *xpad)\n{\n\tstruct xpad_led *led;\n\tstruct led_classdev *led_cdev;\n\tint error;\n\n\tif (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX360W)\n\t\treturn 0;\n\n\txpad->led = led = kzalloc(sizeof(struct xpad_led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\txpad->pad_nr = ida_simple_get(&xpad_pad_seq, 0, 0, GFP_KERNEL);\n\tif (xpad->pad_nr < 0) {\n\t\terror = xpad->pad_nr;\n\t\tgoto err_free_mem;\n\t}\n\n\tsnprintf(led->name, sizeof(led->name), \"xpad%d\", xpad->pad_nr);\n\tled->xpad = xpad;\n\n\tled_cdev = &led->led_cdev;\n\tled_cdev->name = led->name;\n\tled_cdev->brightness_set = xpad_led_set;\n\tled_cdev->flags = LED_CORE_SUSPENDRESUME;\n\n\terror = led_classdev_register(&xpad->udev->dev, led_cdev);\n\tif (error)\n\t\tgoto err_free_id;\n\n\txpad_identify_controller(xpad);\n\n\treturn 0;\n\nerr_free_id:\n\tida_simple_remove(&xpad_pad_seq, xpad->pad_nr);\nerr_free_mem:\n\tkfree(led);\n\txpad->led = NULL;\n\treturn error;\n}\n\nstatic void xpad_led_disconnect(struct usb_xpad *xpad)\n{\n\tstruct xpad_led *xpad_led = xpad->led;\n\n\tif (xpad_led) {\n\t\tled_classdev_unregister(&xpad_led->led_cdev);\n\t\tida_simple_remove(&xpad_pad_seq, xpad->pad_nr);\n\t\tkfree(xpad_led);\n\t}\n}\n#else\nstatic int xpad_led_probe(struct usb_xpad *xpad) { return 0; }\nstatic void xpad_led_disconnect(struct usb_xpad *xpad) { }\n#endif\n\nstatic int xpad_start_input(struct usb_xpad *xpad)\n{\n\tint error;\n\n\tif (usb_submit_urb(xpad->irq_in, GFP_KERNEL))\n\t\treturn -EIO;\n\n\tif (xpad->xtype == XTYPE_XBOXONE) {\n\t\terror = xpad_start_xbox_one(xpad);\n\t\tif (error) {\n\t\t\tusb_kill_urb(xpad->irq_in);\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (xpad->xtype == XTYPE_XBOX360) {\n\t\t \n\t\tu8 dummy[20];\n\n\t\terror = usb_control_msg_recv(xpad->udev, 0,\n\t\t\t\t\t       0x01,\n\t\t\t\t\t      \n\t\t\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t\t\t       0x100,\n\t\t\t\t\t       0x00,\n\t\t\t\t\t     dummy, sizeof(dummy),\n\t\t\t\t\t     25, GFP_KERNEL);\n\t\tif (error)\n\t\t\tdev_warn(&xpad->dev->dev,\n\t\t\t\t \"unable to receive magic message: %d\\n\",\n\t\t\t\t error);\n\t}\n\n\treturn 0;\n}\n\nstatic void xpad_stop_input(struct usb_xpad *xpad)\n{\n\tusb_kill_urb(xpad->irq_in);\n}\n\nstatic void xpad360w_poweroff_controller(struct usb_xpad *xpad)\n{\n\tunsigned long flags;\n\tstruct xpad_output_packet *packet =\n\t\t\t&xpad->out_packets[XPAD_OUT_CMD_IDX];\n\n\tspin_lock_irqsave(&xpad->odata_lock, flags);\n\n\tpacket->data[0] = 0x00;\n\tpacket->data[1] = 0x00;\n\tpacket->data[2] = 0x08;\n\tpacket->data[3] = 0xC0;\n\tpacket->data[4] = 0x00;\n\tpacket->data[5] = 0x00;\n\tpacket->data[6] = 0x00;\n\tpacket->data[7] = 0x00;\n\tpacket->data[8] = 0x00;\n\tpacket->data[9] = 0x00;\n\tpacket->data[10] = 0x00;\n\tpacket->data[11] = 0x00;\n\tpacket->len = 12;\n\tpacket->pending = true;\n\n\t \n\txpad->last_out_packet = -1;\n\txpad_try_sending_next_out_packet(xpad);\n\n\tspin_unlock_irqrestore(&xpad->odata_lock, flags);\n}\n\nstatic int xpad360w_start_input(struct usb_xpad *xpad)\n{\n\tint error;\n\n\terror = usb_submit_urb(xpad->irq_in, GFP_KERNEL);\n\tif (error)\n\t\treturn -EIO;\n\n\t \n\terror = xpad_inquiry_pad_presence(xpad);\n\tif (error) {\n\t\tusb_kill_urb(xpad->irq_in);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void xpad360w_stop_input(struct usb_xpad *xpad)\n{\n\tusb_kill_urb(xpad->irq_in);\n\n\t \n\tflush_work(&xpad->work);\n}\n\nstatic int xpad_open(struct input_dev *dev)\n{\n\tstruct usb_xpad *xpad = input_get_drvdata(dev);\n\n\treturn xpad_start_input(xpad);\n}\n\nstatic void xpad_close(struct input_dev *dev)\n{\n\tstruct usb_xpad *xpad = input_get_drvdata(dev);\n\n\txpad_stop_input(xpad);\n}\n\nstatic void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)\n{\n\tstruct usb_xpad *xpad = input_get_drvdata(input_dev);\n\n\tswitch (abs) {\n\tcase ABS_X:\n\tcase ABS_Y:\n\tcase ABS_RX:\n\tcase ABS_RY:\t \n\t\tinput_set_abs_params(input_dev, abs, -32768, 32767, 16, 128);\n\t\tbreak;\n\tcase ABS_Z:\n\tcase ABS_RZ:\t \n\t\tif (xpad->xtype == XTYPE_XBOXONE)\n\t\t\tinput_set_abs_params(input_dev, abs, 0, 1023, 0, 0);\n\t\telse\n\t\t\tinput_set_abs_params(input_dev, abs, 0, 255, 0, 0);\n\t\tbreak;\n\tcase ABS_HAT0X:\n\tcase ABS_HAT0Y:\t \n\t\tinput_set_abs_params(input_dev, abs, -1, 1, 0, 0);\n\t\tbreak;\n\tcase ABS_PROFILE:  \n\t\tinput_set_abs_params(input_dev, abs, 0, 4, 0, 0);\n\t\tbreak;\n\tdefault:\n\t\tinput_set_abs_params(input_dev, abs, 0, 0, 0, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void xpad_deinit_input(struct usb_xpad *xpad)\n{\n\tif (xpad->input_created) {\n\t\txpad->input_created = false;\n\t\txpad_led_disconnect(xpad);\n\t\tinput_unregister_device(xpad->dev);\n\t}\n}\n\nstatic int xpad_init_input(struct usb_xpad *xpad)\n{\n\tstruct input_dev *input_dev;\n\tint i, error;\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\txpad->dev = input_dev;\n\tinput_dev->name = xpad->name;\n\tinput_dev->phys = xpad->phys;\n\tusb_to_input_id(xpad->udev, &input_dev->id);\n\n\tif (xpad->xtype == XTYPE_XBOX360W) {\n\t\t \n\t\tinput_dev->id.product = 0x02a1;\n\t}\n\n\tinput_dev->dev.parent = &xpad->intf->dev;\n\n\tinput_set_drvdata(input_dev, xpad);\n\n\tif (xpad->xtype != XTYPE_XBOX360W) {\n\t\tinput_dev->open = xpad_open;\n\t\tinput_dev->close = xpad_close;\n\t}\n\n\tif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\n\t\t \n\t\tfor (i = 0; xpad_abs[i] >= 0; i++)\n\t\t\txpad_set_up_abs(input_dev, xpad_abs[i]);\n\t}\n\n\t \n\tfor (i = 0; xpad_common_btn[i] >= 0; i++)\n\t\tinput_set_capability(input_dev, EV_KEY, xpad_common_btn[i]);\n\n\t \n\tif (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W ||\n\t    xpad->xtype == XTYPE_XBOXONE) {\n\t\tfor (i = 0; xpad360_btn[i] >= 0; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, xpad360_btn[i]);\n\t\tif (xpad->mapping & MAP_SELECT_BUTTON)\n\t\t\tinput_set_capability(input_dev, EV_KEY, KEY_RECORD);\n\t} else {\n\t\tfor (i = 0; xpad_btn[i] >= 0; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, xpad_btn[i]);\n\t}\n\n\tif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\n\t\tfor (i = 0; xpad_btn_pad[i] >= 0; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY,\n\t\t\t\t\t     xpad_btn_pad[i]);\n\t}\n\n\t \n\tif (xpad->mapping & MAP_PADDLES) {\n\t\tfor (i = 0; xpad_btn_paddles[i] >= 0; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY, xpad_btn_paddles[i]);\n\t}\n\n\t \n\tif (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||\n\t    xpad->xtype == XTYPE_XBOX360W) {\n\t\tfor (i = 0; xpad_abs_pad[i] >= 0; i++)\n\t\t\txpad_set_up_abs(input_dev, xpad_abs_pad[i]);\n\t}\n\n\tif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\n\t\tfor (i = 0; xpad_btn_triggers[i] >= 0; i++)\n\t\t\tinput_set_capability(input_dev, EV_KEY,\n\t\t\t\t\t     xpad_btn_triggers[i]);\n\t} else {\n\t\tfor (i = 0; xpad_abs_triggers[i] >= 0; i++)\n\t\t\txpad_set_up_abs(input_dev, xpad_abs_triggers[i]);\n\t}\n\n\t \n\tif (xpad->mapping & MAP_PROFILE_BUTTON)\n\t\txpad_set_up_abs(input_dev, ABS_PROFILE);\n\n\terror = xpad_init_ff(xpad);\n\tif (error)\n\t\tgoto err_free_input;\n\n\terror = xpad_led_probe(xpad);\n\tif (error)\n\t\tgoto err_destroy_ff;\n\n\terror = input_register_device(xpad->dev);\n\tif (error)\n\t\tgoto err_disconnect_led;\n\n\txpad->input_created = true;\n\treturn 0;\n\nerr_disconnect_led:\n\txpad_led_disconnect(xpad);\nerr_destroy_ff:\n\tinput_ff_destroy(input_dev);\nerr_free_input:\n\tinput_free_device(input_dev);\n\treturn error;\n}\n\nstatic int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_xpad *xpad;\n\tstruct usb_endpoint_descriptor *ep_irq_in, *ep_irq_out;\n\tint i, error;\n\n\tif (intf->cur_altsetting->desc.bNumEndpoints != 2)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; xpad_device[i].idVendor; i++) {\n\t\tif ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&\n\t\t    (le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))\n\t\t\tbreak;\n\t}\n\n\txpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);\n\tif (!xpad)\n\t\treturn -ENOMEM;\n\n\tusb_make_path(udev, xpad->phys, sizeof(xpad->phys));\n\tstrlcat(xpad->phys, \"/input0\", sizeof(xpad->phys));\n\n\txpad->idata = usb_alloc_coherent(udev, XPAD_PKT_LEN,\n\t\t\t\t\t GFP_KERNEL, &xpad->idata_dma);\n\tif (!xpad->idata) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\txpad->irq_in = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!xpad->irq_in) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_idata;\n\t}\n\n\txpad->udev = udev;\n\txpad->intf = intf;\n\txpad->mapping = xpad_device[i].mapping;\n\txpad->xtype = xpad_device[i].xtype;\n\txpad->name = xpad_device[i].name;\n\txpad->packet_type = PKT_XB;\n\tINIT_WORK(&xpad->work, xpad_presence_work);\n\n\tif (xpad->xtype == XTYPE_UNKNOWN) {\n\t\tif (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {\n\t\t\tif (intf->cur_altsetting->desc.bInterfaceProtocol == 129)\n\t\t\t\txpad->xtype = XTYPE_XBOX360W;\n\t\t\telse if (intf->cur_altsetting->desc.bInterfaceProtocol == 208)\n\t\t\t\txpad->xtype = XTYPE_XBOXONE;\n\t\t\telse\n\t\t\t\txpad->xtype = XTYPE_XBOX360;\n\t\t} else {\n\t\t\txpad->xtype = XTYPE_XBOX;\n\t\t}\n\n\t\tif (dpad_to_buttons)\n\t\t\txpad->mapping |= MAP_DPAD_TO_BUTTONS;\n\t\tif (triggers_to_buttons)\n\t\t\txpad->mapping |= MAP_TRIGGERS_TO_BUTTONS;\n\t\tif (sticks_to_null)\n\t\t\txpad->mapping |= MAP_STICKS_TO_NULL;\n\t}\n\n\tif (xpad->xtype == XTYPE_XBOXONE &&\n\t    intf->cur_altsetting->desc.bInterfaceNumber != GIP_WIRED_INTF_DATA) {\n\t\t \n\t\terror = -ENODEV;\n\t\tgoto err_free_in_urb;\n\t}\n\n\tep_irq_in = ep_irq_out = NULL;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct usb_endpoint_descriptor *ep =\n\t\t\t\t&intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (usb_endpoint_xfer_int(ep)) {\n\t\t\tif (usb_endpoint_dir_in(ep))\n\t\t\t\tep_irq_in = ep;\n\t\t\telse\n\t\t\t\tep_irq_out = ep;\n\t\t}\n\t}\n\n\tif (!ep_irq_in || !ep_irq_out) {\n\t\terror = -ENODEV;\n\t\tgoto err_free_in_urb;\n\t}\n\n\terror = xpad_init_output(intf, xpad, ep_irq_out);\n\tif (error)\n\t\tgoto err_free_in_urb;\n\n\tusb_fill_int_urb(xpad->irq_in, udev,\n\t\t\t usb_rcvintpipe(udev, ep_irq_in->bEndpointAddress),\n\t\t\t xpad->idata, XPAD_PKT_LEN, xpad_irq_in,\n\t\t\t xpad, ep_irq_in->bInterval);\n\txpad->irq_in->transfer_dma = xpad->idata_dma;\n\txpad->irq_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tusb_set_intfdata(intf, xpad);\n\n\t \n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x045e) {  \n\t\tif (le16_to_cpu(udev->descriptor.idProduct) == 0x02e3) {\n\t\t\t \n\t\t\txpad->packet_type = PKT_XBE1;\n\t\t} else if (le16_to_cpu(udev->descriptor.idProduct) == 0x0b00) {\n\t\t\t \n\t\t\tif (le16_to_cpu(udev->descriptor.bcdDevice) < 0x0500) {\n\t\t\t\t \n\t\t\t\txpad->packet_type = PKT_XBE2_FW_OLD;\n\t\t\t} else if (le16_to_cpu(udev->descriptor.bcdDevice) <\n\t\t\t\t   0x050b) {\n\t\t\t\t \n\t\t\t\txpad->packet_type = PKT_XBE2_FW_5_EARLY;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\txpad->packet_type = PKT_XBE2_FW_5_11;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (xpad->xtype == XTYPE_XBOX360W) {\n\t\t \n\t\terror = xpad360w_start_input(xpad);\n\t\tif (error)\n\t\t\tgoto err_deinit_output;\n\t\t \n\t\tudev->quirks |= USB_QUIRK_RESET_RESUME;\n\t} else {\n\t\terror = xpad_init_input(xpad);\n\t\tif (error)\n\t\t\tgoto err_deinit_output;\n\t}\n\treturn 0;\n\nerr_deinit_output:\n\txpad_deinit_output(xpad);\nerr_free_in_urb:\n\tusb_free_urb(xpad->irq_in);\nerr_free_idata:\n\tusb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);\nerr_free_mem:\n\tkfree(xpad);\n\treturn error;\n}\n\nstatic void xpad_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_xpad *xpad = usb_get_intfdata(intf);\n\n\tif (xpad->xtype == XTYPE_XBOX360W)\n\t\txpad360w_stop_input(xpad);\n\n\txpad_deinit_input(xpad);\n\n\t \n\txpad_stop_output(xpad);\n\n\txpad_deinit_output(xpad);\n\n\tusb_free_urb(xpad->irq_in);\n\tusb_free_coherent(xpad->udev, XPAD_PKT_LEN,\n\t\t\txpad->idata, xpad->idata_dma);\n\n\tkfree(xpad);\n\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic int xpad_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usb_xpad *xpad = usb_get_intfdata(intf);\n\tstruct input_dev *input = xpad->dev;\n\n\tif (xpad->xtype == XTYPE_XBOX360W) {\n\t\t \n\t\txpad360w_stop_input(xpad);\n\n\t\t \n\t\tif (auto_poweroff && xpad->pad_present)\n\t\t\txpad360w_poweroff_controller(xpad);\n\t} else {\n\t\tmutex_lock(&input->mutex);\n\t\tif (input_device_enabled(input))\n\t\t\txpad_stop_input(xpad);\n\t\tmutex_unlock(&input->mutex);\n\t}\n\n\txpad_stop_output(xpad);\n\n\treturn 0;\n}\n\nstatic int xpad_resume(struct usb_interface *intf)\n{\n\tstruct usb_xpad *xpad = usb_get_intfdata(intf);\n\tstruct input_dev *input = xpad->dev;\n\tint retval = 0;\n\n\tif (xpad->xtype == XTYPE_XBOX360W) {\n\t\tretval = xpad360w_start_input(xpad);\n\t} else {\n\t\tmutex_lock(&input->mutex);\n\t\tif (input_device_enabled(input)) {\n\t\t\tretval = xpad_start_input(xpad);\n\t\t} else if (xpad->xtype == XTYPE_XBOXONE) {\n\t\t\t \n\t\t\tretval = xpad_start_xbox_one(xpad);\n\t\t}\n\t\tmutex_unlock(&input->mutex);\n\t}\n\n\treturn retval;\n}\n\nstatic struct usb_driver xpad_driver = {\n\t.name\t\t= \"xpad\",\n\t.probe\t\t= xpad_probe,\n\t.disconnect\t= xpad_disconnect,\n\t.suspend\t= xpad_suspend,\n\t.resume\t\t= xpad_resume,\n\t.id_table\t= xpad_table,\n};\n\nmodule_usb_driver(xpad_driver);\n\nMODULE_AUTHOR(\"Marko Friedemann <mfr@bmx-chemnitz.de>\");\nMODULE_DESCRIPTION(\"Xbox pad driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}