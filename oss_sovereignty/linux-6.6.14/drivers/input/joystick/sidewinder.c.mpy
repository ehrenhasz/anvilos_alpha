{
  "module_name": "sidewinder.c",
  "hash_id": "3c379c0b38fcbc7e1d16ecdcfb857f4c5cc51cfdd9f10b68a769577368632fbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/sidewinder.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/gameport.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Microsoft SideWinder joystick family driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#undef SW_DEBUG\n#undef SW_DEBUG_DATA\n\n#define SW_START\t600\t \n#define SW_STROBE\t60\t \n#define SW_TIMEOUT\t6\t \n#define SW_KICK\t\t45\t \n#define SW_END\t\t8\t \n#define SW_FAIL\t\t16\t \n#define SW_BAD\t\t2\t \n#define SW_OK\t\t64\t \n#define SW_LENGTH\t512\t \n\n#ifdef SW_DEBUG\n#define dbg(format, arg...) printk(KERN_DEBUG __FILE__ \": \" format \"\\n\" , ## arg)\n#else\n#define dbg(format, arg...) do {} while (0)\n#endif\n\n \n\n#define SW_ID_3DP\t0\n#define SW_ID_GP\t1\n#define SW_ID_PP\t2\n#define SW_ID_FFP\t3\n#define SW_ID_FSP\t4\n#define SW_ID_FFW\t5\n\n \n\nstatic char *sw_name[] = {\t\"3D Pro\", \"GamePad\", \"Precision Pro\", \"Force Feedback Pro\", \"FreeStyle Pro\",\n\t\t\t\t\"Force Feedback Wheel\" };\n\nstatic char sw_abs[][7] = {\n\t{ ABS_X, ABS_Y, ABS_RZ, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y },\n\t{ ABS_X, ABS_Y },\n\t{ ABS_X, ABS_Y, ABS_RZ, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y },\n\t{ ABS_X, ABS_Y, ABS_RZ, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y },\n\t{ ABS_X, ABS_Y,         ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y },\n\t{ ABS_RX, ABS_RUDDER,   ABS_THROTTLE }};\n\nstatic char sw_bit[][7] = {\n\t{ 10, 10,  9, 10,  1,  1 },\n\t{  1,  1                 },\n\t{ 10, 10,  6,  7,  1,  1 },\n\t{ 10, 10,  6,  7,  1,  1 },\n\t{ 10, 10,  6,  1,  1     },\n\t{ 10,  7,  7,  1,  1     }};\n\nstatic short sw_btn[][12] = {\n\t{ BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_THUMB2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_MODE },\n\t{ BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_TL, BTN_TR, BTN_START, BTN_MODE },\n\t{ BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_SELECT },\n\t{ BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_SELECT },\n\t{ BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_TL, BTN_TR, BTN_START, BTN_MODE, BTN_SELECT },\n\t{ BTN_TRIGGER, BTN_TOP, BTN_THUMB, BTN_THUMB2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4 }};\n\nstatic struct {\n\tint x;\n\tint y;\n} sw_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};\n\nstruct sw {\n\tstruct gameport *gameport;\n\tstruct input_dev *dev[4];\n\tchar name[64];\n\tchar phys[4][32];\n\tint length;\n\tint type;\n\tint bits;\n\tint number;\n\tint fail;\n\tint ok;\n\tint reads;\n\tint bads;\n};\n\n \n\nstatic int sw_read_packet(struct gameport *gameport, unsigned char *buf, int length, int id)\n{\n\tunsigned long flags;\n\tint timeout, bitout, sched, i, kick, start, strobe;\n\tunsigned char pending, u, v;\n\n\ti = -id;\t\t\t\t\t\t \n\ttimeout = id ? gameport_time(gameport, SW_TIMEOUT * 1000) : 0;  \n\tkick = id ? gameport_time(gameport, SW_KICK) : 0;\t \n\tstart = gameport_time(gameport, SW_START);\n\tstrobe = gameport_time(gameport, SW_STROBE);\n\tbitout = start;\n\tpending = 0;\n\tsched = 0;\n\n        local_irq_save(flags);\t\t\t\t\t \n\n\tgameport_trigger(gameport);\t\t\t\t \n\tv = gameport_read(gameport);\n\n\tdo {\n\t\tbitout--;\n\t\tu = v;\n\t\tv = gameport_read(gameport);\n\t} while (!(~v & u & 0x10) && (bitout > 0));\t\t \n\n\tif (bitout > 0)\n\t\tbitout = strobe;\t\t\t\t \n\n\twhile ((timeout > 0 || bitout > 0) && (i < length)) {\n\n\t\ttimeout--;\n\t\tbitout--;\t\t\t\t\t \n\t\tsched--;\n\n\t\tu = v;\n\t\tv = gameport_read(gameport);\n\n\t\tif ((~u & v & 0x10) && (bitout > 0)) {\t\t \n\t\t\tif (i >= 0)\t\t\t\t \n\t\t\t\tbuf[i] = v >> 5;\t\t \n\t\t\ti++;\t\t\t\t\t \n\t\t\tbitout = strobe;\t\t\t \n\t\t}\n\n\t\tif (kick && (~v & u & 0x01)) {\t\t\t \n\t\t\tsched = kick;\t\t\t\t \n\t\t\tkick = 0;\t\t\t\t \n\t\t\tpending = 1;\t\t\t\t \n\t\t}\n\n\t\tif (pending && sched < 0 && (i > -SW_END)) {\t \n\t\t\tgameport_trigger(gameport);\t\t \n\t\t\tbitout = start;\t\t\t\t \n\t\t\tpending = 0;\t\t\t\t \n\t\t\ttimeout = 0;\t\t\t\t \n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\t\t\t\t\t \n\n#ifdef SW_DEBUG_DATA\n\t{\n\t\tint j;\n\t\tprintk(KERN_DEBUG \"sidewinder.c: Read %d triplets. [\", i);\n\t\tfor (j = 0; j < i; j++) printk(\"%d\", buf[j]);\n\t\tprintk(\"]\\n\");\n\t}\n#endif\n\n\treturn i;\n}\n\n \n\n#define GB(pos,num) sw_get_bits(buf, pos, num, sw->bits)\n\nstatic __u64 sw_get_bits(unsigned char *buf, int pos, int num, char bits)\n{\n\t__u64 data = 0;\n\tint tri = pos % bits;\t\t\t\t\t\t \n\tint i   = pos / bits;\n\tint bit = 0;\n\n\twhile (num--) {\n\t\tdata |= (__u64)((buf[i] >> tri++) & 1) << bit++;\t \n\t\tif (tri == bits) {\n\t\t\ti++;\t\t\t\t\t\t \n\t\t\ttri = 0;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n \n\nstatic void sw_init_digital(struct gameport *gameport)\n{\n\tstatic const int seq[] = { 140, 140+725, 140+300, 0 };\n\tunsigned long flags;\n\tint i, t;\n\n        local_irq_save(flags);\n\n\ti = 0;\n        do {\n                gameport_trigger(gameport);\t\t\t \n\t\tt = gameport_time(gameport, SW_TIMEOUT * 1000);\n\t\twhile ((gameport_read(gameport) & 1) && t) t--;\t \n                udelay(seq[i]);\t\t\t\t\t \n        } while (seq[++i]);\n\n\tgameport_trigger(gameport);\t\t\t\t \n\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic int sw_parity(__u64 t)\n{\n\tint x = t ^ (t >> 32);\n\n\tx ^= x >> 16;\n\tx ^= x >> 8;\n\tx ^= x >> 4;\n\tx ^= x >> 2;\n\tx ^= x >> 1;\n\treturn x & 1;\n}\n\n \n\nstatic int sw_check(__u64 t)\n{\n\tunsigned char sum = 0;\n\n\tif ((t & 0x8080808080808080ULL) ^ 0x80)\t\t\t \n\t\treturn -1;\n\n\twhile (t) {\t\t\t\t\t\t \n\t\tsum += t & 0xf;\n\t\tt >>= 4;\n\t}\n\n\treturn sum & 0xf;\n}\n\n \n\nstatic int sw_parse(unsigned char *buf, struct sw *sw)\n{\n\tint hat, i, j;\n\tstruct input_dev *dev;\n\n\tswitch (sw->type) {\n\n\t\tcase SW_ID_3DP:\n\n\t\t\tif (sw_check(GB(0,64)) || (hat = (GB(6,1) << 3) | GB(60,3)) > 8)\n\t\t\t\treturn -1;\n\n\t\t\tdev = sw->dev[0];\n\n\t\t\tinput_report_abs(dev, ABS_X,        (GB( 3,3) << 7) | GB(16,7));\n\t\t\tinput_report_abs(dev, ABS_Y,        (GB( 0,3) << 7) | GB(24,7));\n\t\t\tinput_report_abs(dev, ABS_RZ,       (GB(35,2) << 7) | GB(40,7));\n\t\t\tinput_report_abs(dev, ABS_THROTTLE, (GB(32,3) << 7) | GB(48,7));\n\n\t\t\tinput_report_abs(dev, ABS_HAT0X, sw_hat_to_axis[hat].x);\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, sw_hat_to_axis[hat].y);\n\n\t\t\tfor (j = 0; j < 7; j++)\n\t\t\t\tinput_report_key(dev, sw_btn[SW_ID_3DP][j], !GB(j+8,1));\n\n\t\t\tinput_report_key(dev, BTN_BASE4, !GB(38,1));\n\t\t\tinput_report_key(dev, BTN_BASE5, !GB(37,1));\n\n\t\t\tinput_sync(dev);\n\n\t\t\treturn 0;\n\n\t\tcase SW_ID_GP:\n\n\t\t\tfor (i = 0; i < sw->number; i ++) {\n\n\t\t\t\tif (sw_parity(GB(i*15,15)))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tinput_report_abs(sw->dev[i], ABS_X, GB(i*15+3,1) - GB(i*15+2,1));\n\t\t\t\tinput_report_abs(sw->dev[i], ABS_Y, GB(i*15+0,1) - GB(i*15+1,1));\n\n\t\t\t\tfor (j = 0; j < 10; j++)\n\t\t\t\t\tinput_report_key(sw->dev[i], sw_btn[SW_ID_GP][j], !GB(i*15+j+4,1));\n\n\t\t\t\tinput_sync(sw->dev[i]);\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\tcase SW_ID_PP:\n\t\tcase SW_ID_FFP:\n\n\t\t\tif (!sw_parity(GB(0,48)) || (hat = GB(42,4)) > 8)\n\t\t\t\treturn -1;\n\n\t\t\tdev = sw->dev[0];\n\t\t\tinput_report_abs(dev, ABS_X,        GB( 9,10));\n\t\t\tinput_report_abs(dev, ABS_Y,        GB(19,10));\n\t\t\tinput_report_abs(dev, ABS_RZ,       GB(36, 6));\n\t\t\tinput_report_abs(dev, ABS_THROTTLE, GB(29, 7));\n\n\t\t\tinput_report_abs(dev, ABS_HAT0X, sw_hat_to_axis[hat].x);\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, sw_hat_to_axis[hat].y);\n\n\t\t\tfor (j = 0; j < 9; j++)\n\t\t\t\tinput_report_key(dev, sw_btn[SW_ID_PP][j], !GB(j,1));\n\n\t\t\tinput_sync(dev);\n\n\t\t\treturn 0;\n\n\t\tcase SW_ID_FSP:\n\n\t\t\tif (!sw_parity(GB(0,43)) || (hat = GB(28,4)) > 8)\n\t\t\t\treturn -1;\n\n\t\t\tdev = sw->dev[0];\n\t\t\tinput_report_abs(dev, ABS_X,        GB( 0,10));\n\t\t\tinput_report_abs(dev, ABS_Y,        GB(16,10));\n\t\t\tinput_report_abs(dev, ABS_THROTTLE, GB(32, 6));\n\n\t\t\tinput_report_abs(dev, ABS_HAT0X, sw_hat_to_axis[hat].x);\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, sw_hat_to_axis[hat].y);\n\n\t\t\tfor (j = 0; j < 6; j++)\n\t\t\t\tinput_report_key(dev, sw_btn[SW_ID_FSP][j], !GB(j+10,1));\n\n\t\t\tinput_report_key(dev, BTN_TR,     !GB(26,1));\n\t\t\tinput_report_key(dev, BTN_START,  !GB(27,1));\n\t\t\tinput_report_key(dev, BTN_MODE,   !GB(38,1));\n\t\t\tinput_report_key(dev, BTN_SELECT, !GB(39,1));\n\n\t\t\tinput_sync(dev);\n\n\t\t\treturn 0;\n\n\t\tcase SW_ID_FFW:\n\n\t\t\tif (!sw_parity(GB(0,33)))\n\t\t\t\treturn -1;\n\n\t\t\tdev = sw->dev[0];\n\t\t\tinput_report_abs(dev, ABS_RX,       GB( 0,10));\n\t\t\tinput_report_abs(dev, ABS_RUDDER,   GB(10, 6));\n\t\t\tinput_report_abs(dev, ABS_THROTTLE, GB(16, 6));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tinput_report_key(dev, sw_btn[SW_ID_FFW][j], !GB(j+22,1));\n\n\t\t\tinput_sync(dev);\n\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n \n\nstatic int sw_read(struct sw *sw)\n{\n\tunsigned char buf[SW_LENGTH];\n\tint i;\n\n\ti = sw_read_packet(sw->gameport, buf, sw->length, 0);\n\n\tif (sw->type == SW_ID_3DP && sw->length == 66 && i != 66) {\t\t \n\n\t\tif (i == 64 && !sw_check(sw_get_bits(buf,0,64,1))) {\t\t \n\t\t\tprintk(KERN_WARNING \"sidewinder.c: Joystick in wrong mode on %s\"\n\t\t\t\t\" - going to reinitialize.\\n\", sw->gameport->phys);\n\t\t\tsw->fail = SW_FAIL;\t\t\t\t\t \n\t\t\ti = 128;\t\t\t\t\t\t \n\t\t}\n\n\t\tif (i < 66 && GB(0,64) == GB(i*3-66,64))\t\t\t \n\t\t\ti = 66;\t\t\t\t\t\t\t \n\n\t\tif (i < 66 && GB(0,64) == GB(66,64))\t\t\t\t \n\t\t\ti = 66;\t\t\t\t\t\t\t \n\n\t\tif (i < 66 && GB(i*3-132,64) == GB(i*3-66,64)) {\t\t \n\t\t\tmemmove(buf, buf + i - 22, 22);\t\t\t\t \n\t\t\ti = 66;\t\t\t\t\t\t\t \n\t\t}\n\t}\n\n\tif (i == sw->length && !sw_parse(buf, sw)) {\t\t\t\t \n\n\t\tsw->fail = 0;\n\t\tsw->ok++;\n\n\t\tif (sw->type == SW_ID_3DP && sw->length == 66\t\t\t \n\t\t\t&& sw->ok > SW_OK) {\n\n\t\t\tprintk(KERN_INFO \"sidewinder.c: No more trouble on %s\"\n\t\t\t\t\" - enabling optimization again.\\n\", sw->gameport->phys);\n\t\t\tsw->length = 22;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tsw->ok = 0;\n\tsw->fail++;\n\n\tif (sw->type == SW_ID_3DP && sw->length == 22 && sw->fail > SW_BAD) {\t \n\n\t\tprintk(KERN_INFO \"sidewinder.c: Many bit errors on %s\"\n\t\t\t\" - disabling optimization.\\n\", sw->gameport->phys);\n\t\tsw->length = 66;\n\t}\n\n\tif (sw->fail < SW_FAIL)\n\t\treturn -1;\t\t\t\t\t\t\t \n\n\tprintk(KERN_WARNING \"sidewinder.c: Too many bit errors on %s\"\n\t\t\" - reinitializing joystick.\\n\", sw->gameport->phys);\n\n\tif (!i && sw->type == SW_ID_3DP) {\t\t\t\t\t \n\t\tmdelay(3 * SW_TIMEOUT);\n\t\tsw_init_digital(sw->gameport);\n\t}\n\n\tmdelay(SW_TIMEOUT);\n\ti = sw_read_packet(sw->gameport, buf, SW_LENGTH, 0);\t\t\t \n\tmdelay(SW_TIMEOUT);\n\tsw_read_packet(sw->gameport, buf, SW_LENGTH, i);\t\t\t \n\n\tsw->fail = SW_FAIL;\n\n\treturn -1;\n}\n\nstatic void sw_poll(struct gameport *gameport)\n{\n\tstruct sw *sw = gameport_get_drvdata(gameport);\n\n\tsw->reads++;\n\tif (sw_read(sw))\n\t\tsw->bads++;\n}\n\nstatic int sw_open(struct input_dev *dev)\n{\n\tstruct sw *sw = input_get_drvdata(dev);\n\n\tgameport_start_polling(sw->gameport);\n\treturn 0;\n}\n\nstatic void sw_close(struct input_dev *dev)\n{\n\tstruct sw *sw = input_get_drvdata(dev);\n\n\tgameport_stop_polling(sw->gameport);\n}\n\n \n\nstatic void sw_print_packet(char *name, int length, unsigned char *buf, char bits)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"sidewinder.c: %s packet, %d bits. [\", name, length);\n\tfor (i = (((length + 3) >> 2) - 1); i >= 0; i--)\n\t\tprintk(\"%x\", (int)sw_get_bits(buf, i << 2, 4, bits));\n\tprintk(\"]\\n\");\n}\n\n \n\nstatic void sw_3dp_id(unsigned char *buf, char *comment, size_t size)\n{\n\tint i;\n\tchar pnp[8], rev[9];\n\n\tfor (i = 0; i < 7; i++)\t\t\t\t\t\t \n\t\tpnp[i] = sw_get_bits(buf, 24+8*i, 8, 1);\n\n\tfor (i = 0; i < 8; i++)\t\t\t\t\t\t \n\t\trev[i] = sw_get_bits(buf, 88+8*i, 8, 1);\n\n\tpnp[7] = rev[8] = 0;\n\n\tsnprintf(comment, size, \" [PnP %d.%02d id %s rev %s]\",\n\t\t(int) ((sw_get_bits(buf, 8, 6, 1) << 6) |\t\t \n\t\t\tsw_get_bits(buf, 16, 6, 1)) / 100,\n\t\t(int) ((sw_get_bits(buf, 8, 6, 1) << 6) |\n\t\t\tsw_get_bits(buf, 16, 6, 1)) % 100,\n\t\t pnp, rev);\n}\n\n \n\nstatic int sw_guess_mode(unsigned char *buf, int len)\n{\n\tint i;\n\tunsigned char xor = 0;\n\n\tfor (i = 1; i < len; i++)\n\t\txor |= (buf[i - 1] ^ buf[i]) & 6;\n\n\treturn !!xor * 2 + 1;\n}\n\n \n\nstatic int sw_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct sw *sw;\n\tstruct input_dev *input_dev;\n\tint i, j, k, l;\n\tint err = 0;\n\tunsigned char *buf = NULL;\t \n\tunsigned char *idbuf = NULL;\t \n\tunsigned char m = 1;\n\tchar comment[40];\n\n\tcomment[0] = 0;\n\n\tsw = kzalloc(sizeof(struct sw), GFP_KERNEL);\n\tbuf = kmalloc(SW_LENGTH, GFP_KERNEL);\n\tidbuf = kmalloc(SW_LENGTH, GFP_KERNEL);\n\tif (!sw || !buf || !idbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tsw->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, sw);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tdbg(\"Init 0: Opened %s, io %#x, speed %d\",\n\t\tgameport->phys, gameport->io, gameport->speed);\n\n\ti = sw_read_packet(gameport, buf, SW_LENGTH, 0);\t\t \n\tmsleep(SW_TIMEOUT);\n\tdbg(\"Init 1: Mode %d. Length %d.\", m , i);\n\n\tif (!i) {\t\t\t\t\t\t\t \n\t\tsw_init_digital(gameport);\t\t\t\t \n\t\tmsleep(SW_TIMEOUT);\n\t\ti = sw_read_packet(gameport, buf, SW_LENGTH, 0);\t \n\t\tmsleep(SW_TIMEOUT);\n\t\tdbg(\"Init 1b: Length %d.\", i);\n\t\tif (!i) {\t\t\t\t\t\t \n\t\t\terr = -ENODEV;\n\t\t\tgoto fail2;\n\t\t}\n\t}\n\n\tj = sw_read_packet(gameport, idbuf, SW_LENGTH, i);\t\t \n\tm |= sw_guess_mode(idbuf, j);\t\t\t\t\t \n\tdbg(\"Init 2: Mode %d. ID Length %d.\", m, j);\n\n\tif (j <= 0) {\t\t\t\t\t\t\t \n\t\tmsleep(SW_TIMEOUT);\n\t\ti = sw_read_packet(gameport, buf, SW_LENGTH, 0);\t \n\t\tm |= sw_guess_mode(buf, i);\n\t\tdbg(\"Init 2b: Mode %d. Length %d.\", m, i);\n\t\tif (!i) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto fail2;\n\t\t}\n\t\tmsleep(SW_TIMEOUT);\n\t\tj = sw_read_packet(gameport, idbuf, SW_LENGTH, i);\t \n\t\tdbg(\"Init 2c: ID Length %d.\", j);\n\t}\n\n\tsw->type = -1;\n\tk = SW_FAIL;\t\t\t\t\t\t\t \n\tl = 0;\n\n\tdo {\n\t\tk--;\n\t\tmsleep(SW_TIMEOUT);\n\t\ti = sw_read_packet(gameport, buf, SW_LENGTH, 0);\t \n\t\tdbg(\"Init 3: Mode %d. Length %d. Last %d. Tries %d.\", m, i, l, k);\n\n\t\tif (i > l) {\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t \n\t\t\tl = i;\t\t\t\t\t\t \n\n\t\t\tsw->number = 1;\n\t\t\tsw->gameport = gameport;\n\t\t\tsw->length = i;\n\t\t\tsw->bits = m;\n\n\t\t\tdbg(\"Init 3a: Case %d.\\n\", i * m);\n\n\t\t\tswitch (i * m) {\n\t\t\t\tcase 60:\n\t\t\t\t\tsw->number++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 45:\t\t\t\t \n\t\t\t\t\tif (j <= 40) {\t\t\t \n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 43:\n\t\t\t\t\t\tsw->type = SW_ID_FSP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsw->number++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 30:\n\t\t\t\t\tsw->number++;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 15:\n\t\t\t\t\tsw->type = SW_ID_GP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 33:\n\t\t\t\tcase 31:\n\t\t\t\t\tsw->type = SW_ID_FFW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\t\t\t\t \n\t\t\t\t\tif (j == 14) {\t\t\t \n\t\t\t\t\t\tsw->type = SW_ID_FFP;\n\t\t\t\t\t\tsprintf(comment, \" [AC %s]\", sw_get_bits(idbuf,38,1,3) ? \"off\" : \"on\");\n\t\t\t\t\t} else\n\t\t\t\t\t\tsw->type = SW_ID_PP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 66:\n\t\t\t\t\tsw->bits = 3;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 198:\n\t\t\t\t\tsw->length = 22;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 64:\n\t\t\t\t\tsw->type = SW_ID_3DP;\n\t\t\t\t\tif (j == 160)\n\t\t\t\t\t\tsw_3dp_id(idbuf, comment, sizeof(comment));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} while (k && sw->type == -1);\n\n\tif (sw->type == -1) {\n\t\tprintk(KERN_WARNING \"sidewinder.c: unknown joystick device detected \"\n\t\t\t\"on %s, contact <vojtech@ucw.cz>\\n\", gameport->phys);\n\t\tsw_print_packet(\"ID\", j * 3, idbuf, 3);\n\t\tsw_print_packet(\"Data\", i * m, buf, m);\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n#ifdef SW_DEBUG\n\tsw_print_packet(\"ID\", j * 3, idbuf, 3);\n\tsw_print_packet(\"Data\", i * m, buf, m);\n#endif\n\n\tgameport_set_poll_handler(gameport, sw_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tk = i;\n\tl = j;\n\n\tfor (i = 0; i < sw->number; i++) {\n\t\tint bits, code;\n\n\t\tsnprintf(sw->name, sizeof(sw->name),\n\t\t\t \"Microsoft SideWinder %s\", sw_name[sw->type]);\n\t\tsnprintf(sw->phys[i], sizeof(sw->phys[i]),\n\t\t\t \"%s/input%d\", gameport->phys, i);\n\n\t\tsw->dev[i] = input_dev = input_allocate_device();\n\t\tif (!input_dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail3;\n\t\t}\n\n\t\tinput_dev->name = sw->name;\n\t\tinput_dev->phys = sw->phys[i];\n\t\tinput_dev->id.bustype = BUS_GAMEPORT;\n\t\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_MICROSOFT;\n\t\tinput_dev->id.product = sw->type;\n\t\tinput_dev->id.version = 0x0100;\n\t\tinput_dev->dev.parent = &gameport->dev;\n\n\t\tinput_set_drvdata(input_dev, sw);\n\n\t\tinput_dev->open = sw_open;\n\t\tinput_dev->close = sw_close;\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\t\tfor (j = 0; (bits = sw_bit[sw->type][j]); j++) {\n\t\t\tint min, max, fuzz, flat;\n\n\t\t\tcode = sw_abs[sw->type][j];\n\t\t\tmin = bits == 1 ? -1 : 0;\n\t\t\tmax = (1 << bits) - 1;\n\t\t\tfuzz = (bits >> 1) >= 2 ? 1 << ((bits >> 1) - 2) : 0;\n\t\t\tflat = code == ABS_THROTTLE || bits < 5 ?\n\t\t\t\t0 : 1 << (bits - 5);\n\n\t\t\tinput_set_abs_params(input_dev, code,\n\t\t\t\t\t     min, max, fuzz, flat);\n\t\t}\n\n\t\tfor (j = 0; (code = sw_btn[sw->type][j]); j++)\n\t\t\t__set_bit(code, input_dev->keybit);\n\n\t\tdbg(\"%s%s [%d-bit id %d data %d]\\n\", sw->name, comment, m, l, k);\n\n\t\terr = input_register_device(sw->dev[i]);\n\t\tif (err)\n\t\t\tgoto fail4;\n\t}\n\n out:\tkfree(buf);\n\tkfree(idbuf);\n\n\treturn err;\n\n fail4:\tinput_free_device(sw->dev[i]);\n fail3:\twhile (--i >= 0)\n\t\tinput_unregister_device(sw->dev[i]);\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(sw);\n\tgoto out;\n}\n\nstatic void sw_disconnect(struct gameport *gameport)\n{\n\tstruct sw *sw = gameport_get_drvdata(gameport);\n\tint i;\n\n\tfor (i = 0; i < sw->number; i++)\n\t\tinput_unregister_device(sw->dev[i]);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(sw);\n}\n\nstatic struct gameport_driver sw_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"sidewinder\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= sw_connect,\n\t.disconnect\t= sw_disconnect,\n};\n\nmodule_gameport_driver(sw_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}