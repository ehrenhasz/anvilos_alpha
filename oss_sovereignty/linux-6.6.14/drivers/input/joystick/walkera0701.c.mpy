{
  "module_name": "walkera0701.c",
  "hash_id": "24bf4df2a941720fcb3af5a6ab3ad3f0f14b49a698ae958f0191646e304a2af6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/walkera0701.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define RESERVE 20000\n#define SYNC_PULSE 1306000\n#define BIN0_PULSE 288000\n#define BIN1_PULSE 438000\n\n#define ANALOG_MIN_PULSE 318000\n#define ANALOG_MAX_PULSE 878000\n#define ANALOG_DELTA 80000\n\n#define BIN_SAMPLE ((BIN0_PULSE + BIN1_PULSE) / 2)\n\n#define NO_SYNC 25\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/parport.h>\n#include <linux/input.h>\n#include <linux/hrtimer.h>\n\nMODULE_AUTHOR(\"Peter Popovec <popovec@fei.tuke.sk>\");\nMODULE_DESCRIPTION(\"Walkera WK-0701 TX as joystick\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int walkera0701_pp_no;\nmodule_param_named(port, walkera0701_pp_no, int, 0);\nMODULE_PARM_DESC(port,\n\t\t \"Parallel port adapter for Walkera WK-0701 TX (default is 0)\");\n\n \n\nstruct walkera_dev {\n\tunsigned char buf[25];\n\tu64 irq_time, irq_lasttime;\n\tint counter;\n\tint ack;\n\n\tstruct input_dev *input_dev;\n\tstruct hrtimer timer;\n\n\tstruct parport *parport;\n\tstruct pardevice *pardevice;\n};\n\nstatic struct walkera_dev w_dev;\n\nstatic inline void walkera0701_parse_frame(struct walkera_dev *w)\n{\n\tint i;\n\tint val1, val2, val3, val4, val5, val6, val7, val8;\n\tint magic, magic_bit;\n\tint crc1, crc2;\n\n\tfor (crc1 = crc2 = i = 0; i < 10; i++) {\n\t\tcrc1 += w->buf[i] & 7;\n\t\tcrc2 += (w->buf[i] & 8) >> 3;\n\t}\n\tif ((w->buf[10] & 7) != (crc1 & 7))\n\t\treturn;\n\tif (((w->buf[10] & 8) >> 3) != (((crc1 >> 3) + crc2) & 1))\n\t\treturn;\n\tfor (crc1 = crc2 = 0, i = 11; i < 23; i++) {\n\t\tcrc1 += w->buf[i] & 7;\n\t\tcrc2 += (w->buf[i] & 8) >> 3;\n\t}\n\tif ((w->buf[23] & 7) != (crc1 & 7))\n\t\treturn;\n\tif (((w->buf[23] & 8) >> 3) != (((crc1 >> 3) + crc2) & 1))\n\t\treturn;\n\tval1 = ((w->buf[0] & 7) * 256 + w->buf[1] * 16 + w->buf[2]) >> 2;\n\tval1 *= ((w->buf[0] >> 2) & 2) - 1;\t \n\tval2 = (w->buf[2] & 1) << 8 | (w->buf[3] << 4) | w->buf[4];\n\tval2 *= (w->buf[2] & 2) - 1;\t \n\tval3 = ((w->buf[5] & 7) * 256 + w->buf[6] * 16 + w->buf[7]) >> 2;\n\tval3 *= ((w->buf[5] >> 2) & 2) - 1;\t \n\tval4 = (w->buf[7] & 1) << 8 | (w->buf[8] << 4) | w->buf[9];\n\tval4 *= (w->buf[7] & 2) - 1;\t \n\tval5 = ((w->buf[11] & 7) * 256 + w->buf[12] * 16 + w->buf[13]) >> 2;\n\tval5 *= ((w->buf[11] >> 2) & 2) - 1;\t \n\tval6 = (w->buf[13] & 1) << 8 | (w->buf[14] << 4) | w->buf[15];\n\tval6 *= (w->buf[13] & 2) - 1;\t \n\tval7 = ((w->buf[16] & 7) * 256 + w->buf[17] * 16 + w->buf[18]) >> 2;\n\tval7 *= ((w->buf[16] >> 2) & 2) - 1;\t \n\tval8 = (w->buf[18] & 1) << 8 | (w->buf[19] << 4) | w->buf[20];\n\tval8 *= (w->buf[18] & 2) - 1;\t \n\n\tmagic = (w->buf[21] << 4) | w->buf[22];\n\tmagic_bit = (w->buf[24] & 8) >> 3;\n\tpr_debug(\"%4d %4d %4d %4d  %4d %4d %4d %4d (magic %2x %d)\\n\",\n\t\t val1, val2, val3, val4, val5, val6, val7, val8,\n\t\t magic, magic_bit);\n\n\tinput_report_abs(w->input_dev, ABS_X, val2);\n\tinput_report_abs(w->input_dev, ABS_Y, val1);\n\tinput_report_abs(w->input_dev, ABS_Z, val6);\n\tinput_report_abs(w->input_dev, ABS_THROTTLE, val3);\n\tinput_report_abs(w->input_dev, ABS_RUDDER, val4);\n\tinput_report_abs(w->input_dev, ABS_MISC, val7);\n\tinput_report_key(w->input_dev, BTN_GEAR_DOWN, val5 > 0);\n}\n\nstatic inline int read_ack(struct pardevice *p)\n{\n\treturn parport_read_status(p->port) & 0x40;\n}\n\n \nstatic void walkera0701_irq_handler(void *handler_data)\n{\n\tu64 pulse_time;\n\tstruct walkera_dev *w = handler_data;\n\n\tw->irq_time = ktime_to_ns(ktime_get());\n\tpulse_time = w->irq_time - w->irq_lasttime;\n\tw->irq_lasttime = w->irq_time;\n\n\t \n\tif (unlikely(0 != hrtimer_try_to_cancel(&w->timer))) {\n\t\tw->counter = NO_SYNC;\n\t\treturn;\n\t}\n\n\tif (w->counter < NO_SYNC) {\n\t\tif (w->ack) {\n\t\t\tpulse_time -= BIN1_PULSE;\n\t\t\tw->buf[w->counter] = 8;\n\t\t} else {\n\t\t\tpulse_time -= BIN0_PULSE;\n\t\t\tw->buf[w->counter] = 0;\n\t\t}\n\t\tif (w->counter == 24) {\t \n\t\t\twalkera0701_parse_frame(w);\n\t\t\tw->counter = NO_SYNC;\n\t\t\tif (abs(pulse_time - SYNC_PULSE) < RESERVE)\t \n\t\t\t\tw->counter = 0;\n\t\t} else {\n\t\t\tif ((pulse_time > (ANALOG_MIN_PULSE - RESERVE)\n\t\t\t     && (pulse_time < (ANALOG_MAX_PULSE + RESERVE)))) {\n\t\t\t\tpulse_time -= (ANALOG_MIN_PULSE - RESERVE);\n\t\t\t\tpulse_time = (u32) pulse_time / ANALOG_DELTA;\t \n\t\t\t\tw->buf[w->counter++] |= (pulse_time & 7);\n\t\t\t} else\n\t\t\t\tw->counter = NO_SYNC;\n\t\t}\n\t} else if (abs(pulse_time - SYNC_PULSE - BIN0_PULSE) <\n\t\t\t\tRESERVE + BIN1_PULSE - BIN0_PULSE)\t \n\t\tw->counter = 0;\n\n\thrtimer_start(&w->timer, BIN_SAMPLE, HRTIMER_MODE_REL);\n}\n\nstatic enum hrtimer_restart timer_handler(struct hrtimer\n\t\t\t\t\t  *handle)\n{\n\tstruct walkera_dev *w;\n\n\tw = container_of(handle, struct walkera_dev, timer);\n\tw->ack = read_ack(w->pardevice);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int walkera0701_open(struct input_dev *dev)\n{\n\tstruct walkera_dev *w = input_get_drvdata(dev);\n\n\tif (parport_claim(w->pardevice))\n\t\treturn -EBUSY;\n\n\tparport_enable_irq(w->parport);\n\treturn 0;\n}\n\nstatic void walkera0701_close(struct input_dev *dev)\n{\n\tstruct walkera_dev *w = input_get_drvdata(dev);\n\n\tparport_disable_irq(w->parport);\n\thrtimer_cancel(&w->timer);\n\n\tparport_release(w->pardevice);\n}\n\nstatic void walkera0701_attach(struct parport *pp)\n{\n\tstruct pardev_cb walkera0701_parport_cb;\n\tstruct walkera_dev *w = &w_dev;\n\n\tif (pp->number != walkera0701_pp_no) {\n\t\tpr_debug(\"Not using parport%d.\\n\", pp->number);\n\t\treturn;\n\t}\n\n\tif (pp->irq == -1) {\n\t\tpr_err(\"parport %d does not have interrupt assigned\\n\",\n\t\t\tpp->number);\n\t\treturn;\n\t}\n\n\tw->parport = pp;\n\n\tmemset(&walkera0701_parport_cb, 0, sizeof(walkera0701_parport_cb));\n\twalkera0701_parport_cb.flags = PARPORT_FLAG_EXCL;\n\twalkera0701_parport_cb.irq_func = walkera0701_irq_handler;\n\twalkera0701_parport_cb.private = w;\n\n\tw->pardevice = parport_register_dev_model(pp, \"walkera0701\",\n\t\t\t\t\t\t  &walkera0701_parport_cb, 0);\n\n\tif (!w->pardevice) {\n\t\tpr_err(\"failed to register parport device\\n\");\n\t\treturn;\n\t}\n\n\tif (parport_negotiate(w->pardevice->port, IEEE1284_MODE_COMPAT)) {\n\t\tpr_err(\"failed to negotiate parport mode\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\n\thrtimer_init(&w->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tw->timer.function = timer_handler;\n\n\tw->input_dev = input_allocate_device();\n\tif (!w->input_dev) {\n\t\tpr_err(\"failed to allocate input device\\n\");\n\t\tgoto err_unregister_device;\n\t}\n\n\tinput_set_drvdata(w->input_dev, w);\n\tw->input_dev->name = \"Walkera WK-0701 TX\";\n\tw->input_dev->phys = w->parport->name;\n\tw->input_dev->id.bustype = BUS_PARPORT;\n\n\t \n\tw->input_dev->id.vendor = 0x0001;\n\tw->input_dev->id.product = 0x0001;\n\tw->input_dev->id.version = 0x0100;\n\tw->input_dev->dev.parent = w->parport->dev;\n\tw->input_dev->open = walkera0701_open;\n\tw->input_dev->close = walkera0701_close;\n\n\tw->input_dev->evbit[0] = BIT(EV_ABS) | BIT_MASK(EV_KEY);\n\tw->input_dev->keybit[BIT_WORD(BTN_GEAR_DOWN)] = BIT_MASK(BTN_GEAR_DOWN);\n\n\tinput_set_abs_params(w->input_dev, ABS_X, -512, 512, 0, 0);\n\tinput_set_abs_params(w->input_dev, ABS_Y, -512, 512, 0, 0);\n\tinput_set_abs_params(w->input_dev, ABS_Z, -512, 512, 0, 0);\n\tinput_set_abs_params(w->input_dev, ABS_THROTTLE, -512, 512, 0, 0);\n\tinput_set_abs_params(w->input_dev, ABS_RUDDER, -512, 512, 0, 0);\n\tinput_set_abs_params(w->input_dev, ABS_MISC, -512, 512, 0, 0);\n\n\tif (input_register_device(w->input_dev)) {\n\t\tpr_err(\"failed to register input device\\n\");\n\t\tgoto err_free_input_dev;\n\t}\n\n\treturn;\n\nerr_free_input_dev:\n\tinput_free_device(w->input_dev);\nerr_unregister_device:\n\tparport_unregister_device(w->pardevice);\n}\n\nstatic void walkera0701_detach(struct parport *port)\n{\n\tstruct walkera_dev *w = &w_dev;\n\n\tif (!w->pardevice || w->parport->number != port->number)\n\t\treturn;\n\n\tinput_unregister_device(w->input_dev);\n\tparport_unregister_device(w->pardevice);\n\tw->parport = NULL;\n}\n\nstatic struct parport_driver walkera0701_parport_driver = {\n\t.name = \"walkera0701\",\n\t.match_port = walkera0701_attach,\n\t.detach = walkera0701_detach,\n\t.devmodel = true,\n};\n\nstatic int __init walkera0701_init(void)\n{\n\treturn parport_register_driver(&walkera0701_parport_driver);\n}\n\nstatic void __exit walkera0701_exit(void)\n{\n\tparport_unregister_driver(&walkera0701_parport_driver);\n}\n\nmodule_init(walkera0701_init);\nmodule_exit(walkera0701_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}