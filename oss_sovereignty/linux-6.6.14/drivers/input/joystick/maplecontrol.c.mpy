{
  "module_name": "maplecontrol.c",
  "hash_id": "a8ae7d19905ea3eaf4d1dc74492a12e639294cea99e21c289032d2d86b1759aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/maplecontrol.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/maple.h>\n\nMODULE_AUTHOR(\"Adrian McMenamin <adrian@mcmen.demon.co.uk>\");\nMODULE_DESCRIPTION(\"SEGA Dreamcast controller driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct dc_pad {\n\tstruct input_dev *dev;\n\tstruct maple_device *mdev;\n};\n\nstatic void dc_pad_callback(struct mapleq *mq)\n{\n\tunsigned short buttons;\n\tstruct maple_device *mapledev = mq->dev;\n\tstruct dc_pad *pad = maple_get_drvdata(mapledev);\n\tstruct input_dev *dev = pad->dev;\n\tunsigned char *res = mq->recvbuf->buf;\n\n\tbuttons = ~le16_to_cpup((__le16 *)(res + 8));\n\n\tinput_report_abs(dev, ABS_HAT0Y,\n\t\t(buttons & 0x0010 ? -1 : 0) + (buttons & 0x0020 ? 1 : 0));\n\tinput_report_abs(dev, ABS_HAT0X,\n\t\t(buttons & 0x0040 ? -1 : 0) + (buttons & 0x0080 ? 1 : 0));\n\tinput_report_abs(dev, ABS_HAT1Y,\n\t\t(buttons & 0x1000 ? -1 : 0) + (buttons & 0x2000 ? 1 : 0));\n\tinput_report_abs(dev, ABS_HAT1X,\n\t\t(buttons & 0x4000 ? -1 : 0) + (buttons & 0x8000 ? 1 : 0));\n\n\tinput_report_key(dev, BTN_C,      buttons & 0x0001);\n\tinput_report_key(dev, BTN_B,      buttons & 0x0002);\n\tinput_report_key(dev, BTN_A,      buttons & 0x0004);\n\tinput_report_key(dev, BTN_START,  buttons & 0x0008);\n\tinput_report_key(dev, BTN_Z,      buttons & 0x0100);\n\tinput_report_key(dev, BTN_Y,      buttons & 0x0200);\n\tinput_report_key(dev, BTN_X,      buttons & 0x0400);\n\tinput_report_key(dev, BTN_SELECT, buttons & 0x0800);\n\n\tinput_report_abs(dev, ABS_GAS,    res[10]);\n\tinput_report_abs(dev, ABS_BRAKE,  res[11]);\n\tinput_report_abs(dev, ABS_X,      res[12]);\n\tinput_report_abs(dev, ABS_Y,      res[13]);\n\tinput_report_abs(dev, ABS_RX,     res[14]);\n\tinput_report_abs(dev, ABS_RY,     res[15]);\n}\n\nstatic int dc_pad_open(struct input_dev *dev)\n{\n\tstruct dc_pad *pad = dev_get_platdata(&dev->dev);\n\n\tmaple_getcond_callback(pad->mdev, dc_pad_callback, HZ/20,\n\t\tMAPLE_FUNC_CONTROLLER);\n\n\treturn 0;\n}\n\nstatic void dc_pad_close(struct input_dev *dev)\n{\n\tstruct dc_pad *pad = dev_get_platdata(&dev->dev);\n\n\tmaple_getcond_callback(pad->mdev, dc_pad_callback, 0,\n\t\tMAPLE_FUNC_CONTROLLER);\n}\n\n \nstatic int probe_maple_controller(struct device *dev)\n{\n\tstatic const short btn_bit[32] = {\n\t\tBTN_C, BTN_B, BTN_A, BTN_START, -1, -1, -1, -1,\n\t\tBTN_Z, BTN_Y, BTN_X, BTN_SELECT, -1, -1, -1, -1,\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t};\n\n\tstatic const short abs_bit[32] = {\n\t\t-1, -1, -1, -1, ABS_HAT0Y, ABS_HAT0Y, ABS_HAT0X, ABS_HAT0X,\n\t\t-1, -1, -1, -1, ABS_HAT1Y, ABS_HAT1Y, ABS_HAT1X, ABS_HAT1X,\n\t\tABS_GAS, ABS_BRAKE, ABS_X, ABS_Y, ABS_RX, ABS_RY, -1, -1,\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t};\n\n\tstruct maple_device *mdev = to_maple_dev(dev);\n\tstruct maple_driver *mdrv = to_maple_driver(dev->driver);\n\tint i, error;\n\tstruct dc_pad *pad;\n\tstruct input_dev *idev;\n\tunsigned long data = be32_to_cpu(mdev->devinfo.function_data[0]);\n\n\tpad = kzalloc(sizeof(struct dc_pad), GFP_KERNEL);\n\tidev = input_allocate_device();\n\tif (!pad || !idev) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tpad->dev = idev;\n\tpad->mdev = mdev;\n\n\tidev->open = dc_pad_open;\n\tidev->close = dc_pad_close;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (data & (1 << i)) {\n\t\t\tif (btn_bit[i] >= 0)\n\t\t\t\t__set_bit(btn_bit[i], idev->keybit);\n\t\t\telse if (abs_bit[i] >= 0)\n\t\t\t\t__set_bit(abs_bit[i], idev->absbit);\n\t\t}\n\t}\n\n\tif (idev->keybit[BIT_WORD(BTN_JOYSTICK)])\n\t\tidev->evbit[0] |= BIT_MASK(EV_KEY);\n\n\tif (idev->absbit[0])\n\t\tidev->evbit[0] |= BIT_MASK(EV_ABS);\n\n\tfor (i = ABS_X; i <= ABS_BRAKE; i++)\n\t\tinput_set_abs_params(idev, i, 0, 255, 0, 0);\n\n\tfor (i = ABS_HAT0X; i <= ABS_HAT3Y; i++)\n\t\tinput_set_abs_params(idev, i, 1, -1, 0, 0);\n\n\tidev->dev.platform_data = pad;\n\tidev->dev.parent = &mdev->dev;\n\tidev->name = mdev->product_name;\n\tidev->id.bustype = BUS_HOST;\n\n\terror = input_register_device(idev);\n\tif (error)\n\t\tgoto fail;\n\n\tmdev->driver = mdrv;\n\tmaple_set_drvdata(mdev, pad);\n\n\treturn 0;\n\nfail:\n\tinput_free_device(idev);\n\tkfree(pad);\n\tmaple_set_drvdata(mdev, NULL);\n\treturn error;\n}\n\nstatic int remove_maple_controller(struct device *dev)\n{\n\tstruct maple_device *mdev = to_maple_dev(dev);\n\tstruct dc_pad *pad = maple_get_drvdata(mdev);\n\n\tmdev->callback = NULL;\n\tinput_unregister_device(pad->dev);\n\tmaple_set_drvdata(mdev, NULL);\n\tkfree(pad);\n\n\treturn 0;\n}\n\nstatic struct maple_driver dc_pad_driver = {\n\t.function =\tMAPLE_FUNC_CONTROLLER,\n\t.drv = {\n\t\t.name\t= \"Dreamcast_controller\",\n\t\t.probe\t= probe_maple_controller,\n\t\t.remove\t= remove_maple_controller,\n\t},\n};\n\nstatic int __init dc_pad_init(void)\n{\n\treturn maple_driver_register(&dc_pad_driver);\n}\n\nstatic void __exit dc_pad_exit(void)\n{\n\tmaple_driver_unregister(&dc_pad_driver);\n}\n\nmodule_init(dc_pad_init);\nmodule_exit(dc_pad_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}