{
  "module_name": "as5011.c",
  "hash_id": "3c3d66a2b16865a2e08fc6fe064ee50cb15b76cda609c0ce7ea69a43f8386ec1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/as5011.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/input/as5011.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DRIVER_DESC \"Driver for Austria Microsystems AS5011 joystick\"\n#define MODULE_DEVICE_ALIAS \"as5011\"\n\nMODULE_AUTHOR(\"Fabien Marteau <fabien.marteau@armadeus.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n#define AS5011_CTRL1\t\t0x76\n#define AS5011_CTRL2\t\t0x75\n#define AS5011_XP\t\t0x43\n#define AS5011_XN\t\t0x44\n#define AS5011_YP\t\t0x53\n#define AS5011_YN\t\t0x54\n#define AS5011_X_REG\t\t0x41\n#define AS5011_Y_REG\t\t0x42\n#define AS5011_X_RES_INT\t0x51\n#define AS5011_Y_RES_INT\t0x52\n\n \n#define AS5011_CTRL1_LP_PULSED\t\t0x80\n#define AS5011_CTRL1_LP_ACTIVE\t\t0x40\n#define AS5011_CTRL1_LP_CONTINUE\t0x20\n#define AS5011_CTRL1_INT_WUP_EN\t\t0x10\n#define AS5011_CTRL1_INT_ACT_EN\t\t0x08\n#define AS5011_CTRL1_EXT_CLK_EN\t\t0x04\n#define AS5011_CTRL1_SOFT_RST\t\t0x02\n#define AS5011_CTRL1_DATA_VALID\t\t0x01\n\n \n#define AS5011_CTRL2_EXT_SAMPLE_EN\t0x08\n#define AS5011_CTRL2_RC_BIAS_ON\t\t0x04\n#define AS5011_CTRL2_INV_SPINNING\t0x02\n\n#define AS5011_MAX_AXIS\t80\n#define AS5011_MIN_AXIS\t(-80)\n#define AS5011_FUZZ\t8\n#define AS5011_FLAT\t40\n\nstruct as5011_device {\n\tstruct input_dev *input_dev;\n\tstruct i2c_client *i2c_client;\n\tunsigned int button_gpio;\n\tunsigned int button_irq;\n\tunsigned int axis_irq;\n};\n\nstatic int as5011_i2c_write(struct i2c_client *client,\n\t\t\t    uint8_t aregaddr,\n\t\t\t    uint8_t avalue)\n{\n\tuint8_t data[2] = { aregaddr, avalue };\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.flags = I2C_M_IGNORE_NAK,\n\t\t.len = 2,\n\t\t.buf = (uint8_t *)data\n\t};\n\tint error;\n\n\terror = i2c_transfer(client->adapter, &msg, 1);\n\treturn error < 0 ? error : 0;\n}\n\nstatic int as5011_i2c_read(struct i2c_client *client,\n\t\t\t   uint8_t aregaddr, signed char *value)\n{\n\tuint8_t data[2] = { aregaddr };\n\tstruct i2c_msg msg_set[2] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_REV_DIR_ADDR,\n\t\t\t.len = 1,\n\t\t\t.buf = (uint8_t *)data\n\t\t},\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD | I2C_M_NOSTART,\n\t\t\t.len = 1,\n\t\t\t.buf = (uint8_t *)data\n\t\t}\n\t};\n\tint error;\n\n\terror = i2c_transfer(client->adapter, msg_set, 2);\n\tif (error < 0)\n\t\treturn error;\n\n\t*value = data[0] & 0x80 ? -1 * (1 + ~data[0]) : data[0];\n\treturn 0;\n}\n\nstatic irqreturn_t as5011_button_interrupt(int irq, void *dev_id)\n{\n\tstruct as5011_device *as5011 = dev_id;\n\tint val = gpio_get_value_cansleep(as5011->button_gpio);\n\n\tinput_report_key(as5011->input_dev, BTN_JOYSTICK, !val);\n\tinput_sync(as5011->input_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t as5011_axis_interrupt(int irq, void *dev_id)\n{\n\tstruct as5011_device *as5011 = dev_id;\n\tint error;\n\tsigned char x, y;\n\n\terror = as5011_i2c_read(as5011->i2c_client, AS5011_X_RES_INT, &x);\n\tif (error < 0)\n\t\tgoto out;\n\n\terror = as5011_i2c_read(as5011->i2c_client, AS5011_Y_RES_INT, &y);\n\tif (error < 0)\n\t\tgoto out;\n\n\tinput_report_abs(as5011->input_dev, ABS_X, x);\n\tinput_report_abs(as5011->input_dev, ABS_Y, y);\n\tinput_sync(as5011->input_dev);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int as5011_configure_chip(struct as5011_device *as5011,\n\t\t\t\tconst struct as5011_platform_data *plat_dat)\n{\n\tstruct i2c_client *client = as5011->i2c_client;\n\tint error;\n\tsigned char value;\n\n\t \n\terror = as5011_i2c_write(client, AS5011_CTRL1,\n\t\t\t\t AS5011_CTRL1_SOFT_RST);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Soft reset failed\\n\");\n\t\treturn error;\n\t}\n\n\tmdelay(10);\n\n\terror = as5011_i2c_write(client, AS5011_CTRL1,\n\t\t\t\t AS5011_CTRL1_LP_PULSED |\n\t\t\t\t AS5011_CTRL1_LP_ACTIVE |\n\t\t\t\t AS5011_CTRL1_INT_ACT_EN);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Power config failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = as5011_i2c_write(client, AS5011_CTRL2,\n\t\t\t\t AS5011_CTRL2_INV_SPINNING);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Can't invert spinning\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = as5011_i2c_write(client, AS5011_XP, plat_dat->xp);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Can't write threshold\\n\");\n\t\treturn error;\n\t}\n\n\terror = as5011_i2c_write(client, AS5011_XN, plat_dat->xn);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Can't write threshold\\n\");\n\t\treturn error;\n\t}\n\n\terror = as5011_i2c_write(client, AS5011_YP, plat_dat->yp);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Can't write threshold\\n\");\n\t\treturn error;\n\t}\n\n\terror = as5011_i2c_write(client, AS5011_YN, plat_dat->yn);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Can't write threshold\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = as5011_i2c_read(client, AS5011_X_RES_INT, &value);\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Can't read i2c X resolution value\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int as5011_probe(struct i2c_client *client)\n{\n\tconst struct as5011_platform_data *plat_data;\n\tstruct as5011_device *as5011;\n\tstruct input_dev *input_dev;\n\tint irq;\n\tint error;\n\n\tplat_data = dev_get_platdata(&client->dev);\n\tif (!plat_data)\n\t\treturn -EINVAL;\n\n\tif (!plat_data->axis_irq) {\n\t\tdev_err(&client->dev, \"No axis IRQ?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_NOSTART |\n\t\t\t\t     I2C_FUNC_PROTOCOL_MANGLING)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"need i2c bus that supports protocol mangling\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tas5011 = kmalloc(sizeof(struct as5011_device), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!as5011 || !input_dev) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Can't allocate memory for device structure\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tas5011->i2c_client = client;\n\tas5011->input_dev = input_dev;\n\tas5011->button_gpio = plat_data->button_gpio;\n\tas5011->axis_irq = plat_data->axis_irq;\n\n\tinput_dev->name = \"Austria Microsystem as5011 joystick\";\n\tinput_dev->id.bustype = BUS_I2C;\n\tinput_dev->dev.parent = &client->dev;\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_JOYSTICK);\n\n\tinput_set_abs_params(input_dev, ABS_X,\n\t\tAS5011_MIN_AXIS, AS5011_MAX_AXIS, AS5011_FUZZ, AS5011_FLAT);\n\tinput_set_abs_params(as5011->input_dev, ABS_Y,\n\t\tAS5011_MIN_AXIS, AS5011_MAX_AXIS, AS5011_FUZZ, AS5011_FLAT);\n\n\terror = gpio_request(as5011->button_gpio, \"AS5011 button\");\n\tif (error < 0) {\n\t\tdev_err(&client->dev, \"Failed to request button gpio\\n\");\n\t\tgoto err_free_mem;\n\t}\n\n\tirq = gpio_to_irq(as5011->button_gpio);\n\tif (irq < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to get irq number for button gpio\\n\");\n\t\terror = irq;\n\t\tgoto err_free_button_gpio;\n\t}\n\n\tas5011->button_irq = irq;\n\n\terror = request_threaded_irq(as5011->button_irq,\n\t\t\t\t     NULL, as5011_button_interrupt,\n\t\t\t\t     IRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t     \"as5011_button\", as5011);\n\tif (error < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Can't allocate button irq %d\\n\", as5011->button_irq);\n\t\tgoto err_free_button_gpio;\n\t}\n\n\terror = as5011_configure_chip(as5011, plat_data);\n\tif (error)\n\t\tgoto err_free_button_irq;\n\n\terror = request_threaded_irq(as5011->axis_irq, NULL,\n\t\t\t\t     as5011_axis_interrupt,\n\t\t\t\t     plat_data->axis_irqflags | IRQF_ONESHOT,\n\t\t\t\t     \"as5011_joystick\", as5011);\n\tif (error) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Can't allocate axis irq %d\\n\", plat_data->axis_irq);\n\t\tgoto err_free_button_irq;\n\t}\n\n\terror = input_register_device(as5011->input_dev);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to register input device\\n\");\n\t\tgoto err_free_axis_irq;\n\t}\n\n\ti2c_set_clientdata(client, as5011);\n\n\treturn 0;\n\nerr_free_axis_irq:\n\tfree_irq(as5011->axis_irq, as5011);\nerr_free_button_irq:\n\tfree_irq(as5011->button_irq, as5011);\nerr_free_button_gpio:\n\tgpio_free(as5011->button_gpio);\nerr_free_mem:\n\tinput_free_device(input_dev);\n\tkfree(as5011);\n\n\treturn error;\n}\n\nstatic void as5011_remove(struct i2c_client *client)\n{\n\tstruct as5011_device *as5011 = i2c_get_clientdata(client);\n\n\tfree_irq(as5011->axis_irq, as5011);\n\tfree_irq(as5011->button_irq, as5011);\n\tgpio_free(as5011->button_gpio);\n\n\tinput_unregister_device(as5011->input_dev);\n\tkfree(as5011);\n}\n\nstatic const struct i2c_device_id as5011_id[] = {\n\t{ MODULE_DEVICE_ALIAS, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, as5011_id);\n\nstatic struct i2c_driver as5011_driver = {\n\t.driver = {\n\t\t.name = \"as5011\",\n\t},\n\t.probe\t\t= as5011_probe,\n\t.remove\t\t= as5011_remove,\n\t.id_table\t= as5011_id,\n};\n\nmodule_i2c_driver(as5011_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}