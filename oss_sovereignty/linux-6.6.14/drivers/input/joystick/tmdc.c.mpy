{
  "module_name": "tmdc.c",
  "hash_id": "5273bdff36940f9576f541ec688de6bf0dae420545d86b6412ab0d1b67714017",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/tmdc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"ThrustMaster DirectConnect joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define TMDC_MAX_START\t\t600\t \n#define TMDC_MAX_STROBE\t\t60\t \n#define TMDC_MAX_LENGTH\t\t13\n\n#define TMDC_MODE_M3DI\t\t1\n#define TMDC_MODE_3DRP\t\t3\n#define TMDC_MODE_AT\t\t4\n#define TMDC_MODE_FM\t\t8\n#define TMDC_MODE_FGP\t\t163\n\n#define TMDC_BYTE_ID\t\t10\n#define TMDC_BYTE_REV\t\t11\n#define TMDC_BYTE_DEF\t\t12\n\n#define TMDC_ABS\t\t7\n#define TMDC_ABS_HAT\t\t4\n#define TMDC_BTN\t\t16\n\nstatic const unsigned char tmdc_byte_a[16] = { 0, 1, 3, 4, 6, 7 };\nstatic const unsigned char tmdc_byte_d[16] = { 2, 5, 8, 9 };\n\nstatic const signed char tmdc_abs[TMDC_ABS] =\n\t{ ABS_X, ABS_Y, ABS_RUDDER, ABS_THROTTLE, ABS_RX, ABS_RY, ABS_RZ };\nstatic const signed char tmdc_abs_hat[TMDC_ABS_HAT] =\n\t{ ABS_HAT0X, ABS_HAT0Y, ABS_HAT1X, ABS_HAT1Y };\nstatic const signed char tmdc_abs_at[TMDC_ABS] =\n\t{ ABS_X, ABS_Y, ABS_RUDDER, -1, ABS_THROTTLE };\nstatic const signed char tmdc_abs_fm[TMDC_ABS] =\n\t{ ABS_RX, ABS_RY, ABS_X, ABS_Y };\n\nstatic const short tmdc_btn_pad[TMDC_BTN] =\n\t{ BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_START, BTN_SELECT, BTN_TL, BTN_TR };\nstatic const short tmdc_btn_joy[TMDC_BTN] =\n\t{ BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2, BTN_THUMB2, BTN_PINKIE,\n\t  BTN_BASE3, BTN_BASE4, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z };\nstatic const short tmdc_btn_fm[TMDC_BTN] =\n        { BTN_TRIGGER, BTN_C, BTN_B, BTN_A, BTN_THUMB, BTN_X, BTN_Y, BTN_Z, BTN_TOP, BTN_TOP2 };\nstatic const short tmdc_btn_at[TMDC_BTN] =\n        { BTN_TRIGGER, BTN_THUMB2, BTN_PINKIE, BTN_THUMB, BTN_BASE6, BTN_BASE5, BTN_BASE4,\n          BTN_BASE3, BTN_BASE2, BTN_BASE };\n\nstatic const struct {\n        int x;\n        int y;\n} tmdc_hat_to_axis[] = {{ 0, 0}, { 1, 0}, { 0,-1}, {-1, 0}, { 0, 1}};\n\nstatic const struct tmdc_model {\n\tunsigned char id;\n\tconst char *name;\n\tchar abs;\n\tchar hats;\n\tchar btnc[4];\n\tchar btno[4];\n\tconst signed char *axes;\n\tconst short *buttons;\n} tmdc_models[] = {\n\t{   1, \"ThrustMaster Millennium 3D Inceptor\",\t  6, 2, { 4, 2 }, { 4, 6 }, tmdc_abs, tmdc_btn_joy },\n\t{   3, \"ThrustMaster Rage 3D Gamepad\",\t\t  2, 0, { 8, 2 }, { 0, 0 }, tmdc_abs, tmdc_btn_pad },\n\t{   4, \"ThrustMaster Attack Throttle\",\t\t  5, 2, { 4, 6 }, { 4, 2 }, tmdc_abs_at, tmdc_btn_at },\n\t{   8, \"ThrustMaster FragMaster\",\t\t  4, 0, { 8, 2 }, { 0, 0 }, tmdc_abs_fm, tmdc_btn_fm },\n\t{ 163, \"Thrustmaster Fusion GamePad\",\t\t  2, 0, { 8, 2 }, { 0, 0 }, tmdc_abs, tmdc_btn_pad },\n\t{   0, \"Unknown %d-axis, %d-button TM device %d\", 0, 0, { 0, 0 }, { 0, 0 }, tmdc_abs, tmdc_btn_joy }\n};\n\n\nstruct tmdc_port {\n\tstruct input_dev *dev;\n\tchar name[64];\n\tchar phys[32];\n\tint mode;\n\tconst signed char *abs;\n\tconst short *btn;\n\tunsigned char absc;\n\tunsigned char btnc[4];\n\tunsigned char btno[4];\n};\n\nstruct tmdc {\n\tstruct gameport *gameport;\n\tstruct tmdc_port *port[2];\n#if 0\n\tstruct input_dev *dev[2];\n\tchar name[2][64];\n\tchar phys[2][32];\n\tint mode[2];\n\tsigned char *abs[2];\n\tshort *btn[2];\n\tunsigned char absc[2];\n\tunsigned char btnc[2][4];\n\tunsigned char btno[2][4];\n#endif\n\tint reads;\n\tint bads;\n\tunsigned char exists;\n};\n\n \n\nstatic int tmdc_read_packet(struct gameport *gameport, unsigned char data[2][TMDC_MAX_LENGTH])\n{\n\tunsigned char u, v, w, x;\n\tunsigned long flags;\n\tint i[2], j[2], t[2], p, k;\n\n\tp = gameport_time(gameport, TMDC_MAX_STROBE);\n\n\tfor (k = 0; k < 2; k++) {\n\t\tt[k] = gameport_time(gameport, TMDC_MAX_START);\n\t\ti[k] = j[k] = 0;\n\t}\n\n\tlocal_irq_save(flags);\n\tgameport_trigger(gameport);\n\n\tw = gameport_read(gameport) >> 4;\n\n\tdo {\n\t\tx = w;\n\t\tw = gameport_read(gameport) >> 4;\n\n\t\tfor (k = 0, v = w, u = x; k < 2; k++, v >>= 2, u >>= 2) {\n\t\t\tif (~v & u & 2) {\n\t\t\t\tif (t[k] <= 0 || i[k] >= TMDC_MAX_LENGTH) continue;\n\t\t\t\tt[k] = p;\n\t\t\t\tif (j[k] == 0) {\t\t\t\t  \n\t\t\t\t\tif (~v & 1) t[k] = 0;\n\t\t\t\t\tdata[k][i[k]] = 0; j[k]++; continue;\n\t\t\t\t}\n\t\t\t\tif (j[k] == 9) {\t\t\t\t \n\t\t\t\t\tif (v & 1) t[k] = 0;\n\t\t\t\t\tj[k] = 0; i[k]++; continue;\n\t\t\t\t}\n\t\t\t\tdata[k][i[k]] |= (~v & 1) << (j[k]++ - 1);\t \n\t\t\t}\n\t\t\tt[k]--;\n\t\t}\n\t} while (t[0] > 0 || t[1] > 0);\n\n\tlocal_irq_restore(flags);\n\n\treturn (i[0] == TMDC_MAX_LENGTH) | ((i[1] == TMDC_MAX_LENGTH) << 1);\n}\n\nstatic int tmdc_parse_packet(struct tmdc_port *port, unsigned char *data)\n{\n\tint i, k, l;\n\n\tif (data[TMDC_BYTE_ID] != port->mode)\n\t\treturn -1;\n\n\tfor (i = 0; i < port->absc; i++) {\n\t\tif (port->abs[i] < 0)\n\t\t\treturn 0;\n\n\t\tinput_report_abs(port->dev, port->abs[i], data[tmdc_byte_a[i]]);\n\t}\n\n\tswitch (port->mode) {\n\n\t\tcase TMDC_MODE_M3DI:\n\n\t\t\ti = tmdc_byte_d[0];\n\t\t\tinput_report_abs(port->dev, ABS_HAT0X, ((data[i] >> 3) & 1) - ((data[i] >> 1) & 1));\n\t\t\tinput_report_abs(port->dev, ABS_HAT0Y, ((data[i] >> 2) & 1) - ( data[i]       & 1));\n\t\t\tbreak;\n\n\t\tcase TMDC_MODE_AT:\n\n\t\t\ti = tmdc_byte_a[3];\n\t\t\tinput_report_abs(port->dev, ABS_HAT0X, tmdc_hat_to_axis[(data[i] - 141) / 25].x);\n\t\t\tinput_report_abs(port->dev, ABS_HAT0Y, tmdc_hat_to_axis[(data[i] - 141) / 25].y);\n\t\t\tbreak;\n\n\t}\n\n\tfor (k = l = 0; k < 4; k++) {\n\t\tfor (i = 0; i < port->btnc[k]; i++)\n\t\t\tinput_report_key(port->dev, port->btn[i + l],\n\t\t\t\t((data[tmdc_byte_d[k]] >> (i + port->btno[k])) & 1));\n\t\tl += port->btnc[k];\n\t}\n\n\tinput_sync(port->dev);\n\n\treturn 0;\n}\n\n \n\nstatic void tmdc_poll(struct gameport *gameport)\n{\n\tunsigned char data[2][TMDC_MAX_LENGTH];\n\tstruct tmdc *tmdc = gameport_get_drvdata(gameport);\n\tunsigned char r, bad = 0;\n\tint i;\n\n\ttmdc->reads++;\n\n\tif ((r = tmdc_read_packet(tmdc->gameport, data)) != tmdc->exists)\n\t\tbad = 1;\n\telse {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tif (r & (1 << i) & tmdc->exists) {\n\n\t\t\t\tif (tmdc_parse_packet(tmdc->port[i], data[i]))\n\t\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\ttmdc->bads += bad;\n}\n\nstatic int tmdc_open(struct input_dev *dev)\n{\n\tstruct tmdc *tmdc = input_get_drvdata(dev);\n\n\tgameport_start_polling(tmdc->gameport);\n\treturn 0;\n}\n\nstatic void tmdc_close(struct input_dev *dev)\n{\n\tstruct tmdc *tmdc = input_get_drvdata(dev);\n\n\tgameport_stop_polling(tmdc->gameport);\n}\n\nstatic int tmdc_setup_port(struct tmdc *tmdc, int idx, unsigned char *data)\n{\n\tconst struct tmdc_model *model;\n\tstruct tmdc_port *port;\n\tstruct input_dev *input_dev;\n\tint i, j, b = 0;\n\tint err;\n\n\ttmdc->port[idx] = port = kzalloc(sizeof (struct tmdc_port), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!port || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tport->mode = data[TMDC_BYTE_ID];\n\n\tfor (model = tmdc_models; model->id && model->id != port->mode; model++)\n\t\t ;\n\n\tport->abs = model->axes;\n\tport->btn = model->buttons;\n\n\tif (!model->id) {\n\t\tport->absc = data[TMDC_BYTE_DEF] >> 4;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tport->btnc[i] = i < (data[TMDC_BYTE_DEF] & 0xf) ? 8 : 0;\n\t} else {\n\t\tport->absc = model->abs;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tport->btnc[i] = model->btnc[i];\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tport->btno[i] = model->btno[i];\n\n\tsnprintf(port->name, sizeof(port->name), model->name,\n\t\t port->absc, (data[TMDC_BYTE_DEF] & 0xf) << 3, port->mode);\n\tsnprintf(port->phys, sizeof(port->phys), \"%s/input%d\", tmdc->gameport->phys, i);\n\n\tport->dev = input_dev;\n\n\tinput_dev->name = port->name;\n\tinput_dev->phys = port->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_THRUSTMASTER;\n\tinput_dev->id.product = model->id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &tmdc->gameport->dev;\n\n\tinput_set_drvdata(input_dev, tmdc);\n\n\tinput_dev->open = tmdc_open;\n\tinput_dev->close = tmdc_close;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\tfor (i = 0; i < port->absc && i < TMDC_ABS; i++)\n\t\tif (port->abs[i] >= 0)\n\t\t\tinput_set_abs_params(input_dev, port->abs[i], 8, 248, 2, 4);\n\n\tfor (i = 0; i < model->hats && i < TMDC_ABS_HAT; i++)\n\t\tinput_set_abs_params(input_dev, tmdc_abs_hat[i], -1, 1, 0, 0);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < port->btnc[i] && j < TMDC_BTN; j++)\n\t\t\tset_bit(port->btn[j + b], input_dev->keybit);\n\t\tb += port->btnc[i];\n\t}\n\n\terr = input_register_device(port->dev);\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\n fail:\tinput_free_device(input_dev);\n\tkfree(port);\n\treturn err;\n}\n\n \n\nstatic int tmdc_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tunsigned char data[2][TMDC_MAX_LENGTH];\n\tstruct tmdc *tmdc;\n\tint i;\n\tint err;\n\n\tif (!(tmdc = kzalloc(sizeof(struct tmdc), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\ttmdc->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, tmdc);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tif (!(tmdc->exists = tmdc_read_packet(gameport, data))) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, tmdc_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (tmdc->exists & (1 << i)) {\n\n\t\t\terr = tmdc_setup_port(tmdc, i, data[i]);\n\t\t\tif (err)\n\t\t\t\tgoto fail3;\n\t\t}\n\t}\n\n\treturn 0;\n\n fail3: while (--i >= 0) {\n\t\tif (tmdc->port[i]) {\n\t\t\tinput_unregister_device(tmdc->port[i]->dev);\n\t\t\tkfree(tmdc->port[i]);\n\t\t}\n\t}\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(tmdc);\n\treturn err;\n}\n\nstatic void tmdc_disconnect(struct gameport *gameport)\n{\n\tstruct tmdc *tmdc = gameport_get_drvdata(gameport);\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (tmdc->port[i]) {\n\t\t\tinput_unregister_device(tmdc->port[i]->dev);\n\t\t\tkfree(tmdc->port[i]);\n\t\t}\n\t}\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(tmdc);\n}\n\nstatic struct gameport_driver tmdc_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"tmdc\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= tmdc_connect,\n\t.disconnect\t= tmdc_disconnect,\n};\n\nmodule_gameport_driver(tmdc_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}