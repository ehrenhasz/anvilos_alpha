{
  "module_name": "n64joy.c",
  "hash_id": "d757f3bde6caaa448dc356fb25a1404b4c16f6ba69291bb339f29bc892c98fc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/n64joy.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/limits.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\nMODULE_AUTHOR(\"Lauri Kasanen <cand@gmx.com>\");\nMODULE_DESCRIPTION(\"Driver for N64 controllers\");\nMODULE_LICENSE(\"GPL\");\n\n#define PIF_RAM 0x1fc007c0\n\n#define SI_DRAM_REG 0\n#define SI_READ_REG 1\n#define SI_WRITE_REG 4\n#define SI_STATUS_REG 6\n\n#define SI_STATUS_DMA_BUSY  BIT(0)\n#define SI_STATUS_IO_BUSY   BIT(1)\n\n#define N64_CONTROLLER_ID 0x0500\n\n#define MAX_CONTROLLERS 4\n\nstatic const char *n64joy_phys[MAX_CONTROLLERS] = {\n\t\"n64joy/port0\",\n\t\"n64joy/port1\",\n\t\"n64joy/port2\",\n\t\"n64joy/port3\",\n};\n\nstruct n64joy_priv {\n\tu64 si_buf[8] ____cacheline_aligned;\n\tstruct timer_list timer;\n\tstruct mutex n64joy_mutex;\n\tstruct input_dev *n64joy_dev[MAX_CONTROLLERS];\n\tu32 __iomem *reg_base;\n\tu8 n64joy_opened;\n};\n\nstruct joydata {\n\tunsigned int: 16;  \n\tunsigned int err: 2;\n\tunsigned int: 14;  \n\n\tunion {\n\t\tu32 data;\n\n\t\tstruct {\n\t\t\tunsigned int a: 1;\n\t\t\tunsigned int b: 1;\n\t\t\tunsigned int z: 1;\n\t\t\tunsigned int start: 1;\n\t\t\tunsigned int up: 1;\n\t\t\tunsigned int down: 1;\n\t\t\tunsigned int left: 1;\n\t\t\tunsigned int right: 1;\n\t\t\tunsigned int: 2;  \n\t\t\tunsigned int l: 1;\n\t\t\tunsigned int r: 1;\n\t\t\tunsigned int c_up: 1;\n\t\t\tunsigned int c_down: 1;\n\t\t\tunsigned int c_left: 1;\n\t\t\tunsigned int c_right: 1;\n\t\t\tsigned int x: 8;\n\t\t\tsigned int y: 8;\n\t\t};\n\t};\n};\n\nstatic void n64joy_write_reg(u32 __iomem *reg_base, const u8 reg, const u32 value)\n{\n\twritel(value, reg_base + reg);\n}\n\nstatic u32 n64joy_read_reg(u32 __iomem *reg_base, const u8 reg)\n{\n\treturn readl(reg_base + reg);\n}\n\nstatic void n64joy_wait_si_dma(u32 __iomem *reg_base)\n{\n\twhile (n64joy_read_reg(reg_base, SI_STATUS_REG) &\n\t       (SI_STATUS_DMA_BUSY | SI_STATUS_IO_BUSY))\n\t\tcpu_relax();\n}\n\nstatic void n64joy_exec_pif(struct n64joy_priv *priv, const u64 in[8])\n{\n\tunsigned long flags;\n\n\tdma_cache_wback_inv((unsigned long) in, 8 * 8);\n\tdma_cache_inv((unsigned long) priv->si_buf, 8 * 8);\n\n\tlocal_irq_save(flags);\n\n\tn64joy_wait_si_dma(priv->reg_base);\n\n\tbarrier();\n\tn64joy_write_reg(priv->reg_base, SI_DRAM_REG, virt_to_phys(in));\n\tbarrier();\n\tn64joy_write_reg(priv->reg_base, SI_WRITE_REG, PIF_RAM);\n\tbarrier();\n\n\tn64joy_wait_si_dma(priv->reg_base);\n\n\tbarrier();\n\tn64joy_write_reg(priv->reg_base, SI_DRAM_REG, virt_to_phys(priv->si_buf));\n\tbarrier();\n\tn64joy_write_reg(priv->reg_base, SI_READ_REG, PIF_RAM);\n\tbarrier();\n\n\tn64joy_wait_si_dma(priv->reg_base);\n\n\tlocal_irq_restore(flags);\n}\n\nstatic const u64 polldata[] ____cacheline_aligned = {\n\t0xff010401ffffffff,\n\t0xff010401ffffffff,\n\t0xff010401ffffffff,\n\t0xff010401ffffffff,\n\t0xfe00000000000000,\n\t0,\n\t0,\n\t1\n};\n\nstatic void n64joy_poll(struct timer_list *t)\n{\n\tconst struct joydata *data;\n\tstruct n64joy_priv *priv = container_of(t, struct n64joy_priv, timer);\n\tstruct input_dev *dev;\n\tu32 i;\n\n\tn64joy_exec_pif(priv, polldata);\n\n\tdata = (struct joydata *) priv->si_buf;\n\n\tfor (i = 0; i < MAX_CONTROLLERS; i++) {\n\t\tif (!priv->n64joy_dev[i])\n\t\t\tcontinue;\n\n\t\tdev = priv->n64joy_dev[i];\n\n\t\t \n\t\tinput_report_key(dev, BTN_DPAD_UP, data[i].up);\n\t\tinput_report_key(dev, BTN_DPAD_DOWN, data[i].down);\n\t\tinput_report_key(dev, BTN_DPAD_LEFT, data[i].left);\n\t\tinput_report_key(dev, BTN_DPAD_RIGHT, data[i].right);\n\n\t\t \n\t\tinput_report_key(dev, BTN_FORWARD, data[i].c_up);\n\t\tinput_report_key(dev, BTN_BACK, data[i].c_down);\n\t\tinput_report_key(dev, BTN_LEFT, data[i].c_left);\n\t\tinput_report_key(dev, BTN_RIGHT, data[i].c_right);\n\n\t\t \n\t\tinput_report_key(dev, BTN_START, data[i].start);\n\t\tinput_report_key(dev, BTN_Z, data[i].z);\n\n\t\t \n\t\tinput_report_key(dev, BTN_0, data[i].a);\n\t\tinput_report_key(dev, BTN_1, data[i].b);\n\t\tinput_report_key(dev, BTN_2, data[i].l);\n\t\tinput_report_key(dev, BTN_3, data[i].r);\n\n\t\tinput_report_abs(dev, ABS_X, data[i].x);\n\t\tinput_report_abs(dev, ABS_Y, data[i].y);\n\n\t\tinput_sync(dev);\n\t}\n\n\tmod_timer(&priv->timer, jiffies + msecs_to_jiffies(16));\n}\n\nstatic int n64joy_open(struct input_dev *dev)\n{\n\tstruct n64joy_priv *priv = input_get_drvdata(dev);\n\tint err;\n\n\terr = mutex_lock_interruptible(&priv->n64joy_mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (!priv->n64joy_opened) {\n\t\t \n\t\ttimer_setup(&priv->timer, n64joy_poll, 0);\n\t\tmod_timer(&priv->timer, jiffies + msecs_to_jiffies(16));\n\t}\n\n\tpriv->n64joy_opened++;\n\n\tmutex_unlock(&priv->n64joy_mutex);\n\treturn err;\n}\n\nstatic void n64joy_close(struct input_dev *dev)\n{\n\tstruct n64joy_priv *priv = input_get_drvdata(dev);\n\n\tmutex_lock(&priv->n64joy_mutex);\n\tif (!--priv->n64joy_opened)\n\t\tdel_timer_sync(&priv->timer);\n\tmutex_unlock(&priv->n64joy_mutex);\n}\n\nstatic const u64 __initconst scandata[] ____cacheline_aligned = {\n\t0xff010300ffffffff,\n\t0xff010300ffffffff,\n\t0xff010300ffffffff,\n\t0xff010300ffffffff,\n\t0xfe00000000000000,\n\t0,\n\t0,\n\t1\n};\n\n \nstatic int __init n64joy_probe(struct platform_device *pdev)\n{\n\tconst struct joydata *data;\n\tstruct n64joy_priv *priv;\n\tstruct input_dev *dev;\n\tint err = 0;\n\tu32 i, j, found = 0;\n\n\tpriv = kzalloc(sizeof(struct n64joy_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tmutex_init(&priv->n64joy_mutex);\n\n\tpriv->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->reg_base)) {\n\t\terr = PTR_ERR(priv->reg_base);\n\t\tgoto fail;\n\t}\n\n\t \n\tn64joy_exec_pif(priv, scandata);\n\n\tdata = (struct joydata *) priv->si_buf;\n\n\tfor (i = 0; i < MAX_CONTROLLERS; i++) {\n\t\tif (!data[i].err && data[i].data >> 16 == N64_CONTROLLER_ID) {\n\t\t\tfound++;\n\n\t\t\tdev = priv->n64joy_dev[i] = input_allocate_device();\n\t\t\tif (!priv->n64joy_dev[i]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tinput_set_drvdata(dev, priv);\n\n\t\t\tdev->name = \"N64 controller\";\n\t\t\tdev->phys = n64joy_phys[i];\n\t\t\tdev->id.bustype = BUS_HOST;\n\t\t\tdev->id.vendor = 0;\n\t\t\tdev->id.product = data[i].data >> 16;\n\t\t\tdev->id.version = 0;\n\t\t\tdev->dev.parent = &pdev->dev;\n\n\t\t\tdev->open = n64joy_open;\n\t\t\tdev->close = n64joy_close;\n\n\t\t\t \n\t\t\tinput_set_capability(dev, EV_KEY, BTN_DPAD_UP);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_DPAD_DOWN);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_DPAD_LEFT);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_DPAD_RIGHT);\n\t\t\t \n\t\t\tinput_set_capability(dev, EV_KEY, BTN_LEFT);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_RIGHT);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_FORWARD);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_BACK);\n\t\t\t \n\t\t\tinput_set_capability(dev, EV_KEY, BTN_START);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_Z);\n\t\t\t \n\t\t\tinput_set_capability(dev, EV_KEY, BTN_0);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_1);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_2);\n\t\t\tinput_set_capability(dev, EV_KEY, BTN_3);\n\n\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\tinput_set_abs_params(dev, ABS_X + j,\n\t\t\t\t\t\t     S8_MIN, S8_MAX, 0, 0);\n\n\t\t\terr = input_register_device(dev);\n\t\t\tif (err) {\n\t\t\t\tinput_free_device(dev);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_info(\"%u controller(s) connected\\n\", found);\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\treturn 0;\nfail:\n\tfor (i = 0; i < MAX_CONTROLLERS; i++) {\n\t\tif (!priv->n64joy_dev[i])\n\t\t\tcontinue;\n\t\tinput_unregister_device(priv->n64joy_dev[i]);\n\t}\n\treturn err;\n}\n\nstatic struct platform_driver n64joy_driver = {\n\t.driver = {\n\t\t.name = \"n64joy\",\n\t},\n};\n\nstatic int __init n64joy_init(void)\n{\n\treturn platform_driver_probe(&n64joy_driver, n64joy_probe);\n}\n\nmodule_init(n64joy_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}