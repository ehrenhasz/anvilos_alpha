{
  "module_name": "cobra.c",
  "hash_id": "fa375e5a5f30242c6e374b2a72b78a6e32e9d538572cfa28c40d2d37f5412916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/cobra.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Creative Labs Blaster GamePad Cobra driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define COBRA_MAX_STROBE\t45\t \n#define COBRA_LENGTH\t\t36\n\nstatic int cobra_btn[] = { BTN_START, BTN_SELECT, BTN_TL, BTN_TR, BTN_X, BTN_Y, BTN_Z, BTN_A, BTN_B, BTN_C, BTN_TL2, BTN_TR2, 0 };\n\nstruct cobra {\n\tstruct gameport *gameport;\n\tstruct input_dev *dev[2];\n\tint reads;\n\tint bads;\n\tunsigned char exists;\n\tchar phys[2][32];\n};\n\nstatic unsigned char cobra_read_packet(struct gameport *gameport, unsigned int *data)\n{\n\tunsigned long flags;\n\tunsigned char u, v, w;\n\t__u64 buf[2];\n\tint r[2], t[2];\n\tint i, j, ret;\n\n\tint strobe = gameport_time(gameport, COBRA_MAX_STROBE);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tr[i] = buf[i] = 0;\n\t\tt[i] = COBRA_MAX_STROBE;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tu = gameport_read(gameport);\n\n\tdo {\n\t\tt[0]--; t[1]--;\n\t\tv = gameport_read(gameport);\n\t\tfor (i = 0, w = u ^ v; i < 2 && w; i++, w >>= 2)\n\t\t\tif (w & 0x30) {\n\t\t\t\tif ((w & 0x30) < 0x30 && r[i] < COBRA_LENGTH && t[i] > 0) {\n\t\t\t\t\tbuf[i] |= (__u64)((w >> 5) & 1) << r[i]++;\n\t\t\t\t\tt[i] = strobe;\n\t\t\t\t\tu = v;\n\t\t\t\t} else t[i] = 0;\n\t\t\t}\n\t} while (t[0] > 0 || t[1] > 0);\n\n\tlocal_irq_restore(flags);\n\n\tret = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\n\t\tif (r[i] != COBRA_LENGTH) continue;\n\n\t\tfor (j = 0; j < COBRA_LENGTH && (buf[i] & 0x04104107f) ^ 0x041041040; j++)\n\t\t\tbuf[i] = (buf[i] >> 1) | ((__u64)(buf[i] & 1) << (COBRA_LENGTH - 1));\n\n\t\tif (j < COBRA_LENGTH) ret |= (1 << i);\n\n\t\tdata[i] = ((buf[i] >>  7) & 0x000001f) | ((buf[i] >>  8) & 0x00003e0)\n\t\t\t| ((buf[i] >>  9) & 0x0007c00) | ((buf[i] >> 10) & 0x00f8000)\n\t\t\t| ((buf[i] >> 11) & 0x1f00000);\n\n\t}\n\n\treturn ret;\n}\n\nstatic void cobra_poll(struct gameport *gameport)\n{\n\tstruct cobra *cobra = gameport_get_drvdata(gameport);\n\tstruct input_dev *dev;\n\tunsigned int data[2];\n\tint i, j, r;\n\n\tcobra->reads++;\n\n\tif ((r = cobra_read_packet(gameport, data)) != cobra->exists) {\n\t\tcobra->bads++;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (cobra->exists & r & (1 << i)) {\n\n\t\t\tdev = cobra->dev[i];\n\n\t\t\tinput_report_abs(dev, ABS_X, ((data[i] >> 4) & 1) - ((data[i] >> 3) & 1));\n\t\t\tinput_report_abs(dev, ABS_Y, ((data[i] >> 2) & 1) - ((data[i] >> 1) & 1));\n\n\t\t\tfor (j = 0; cobra_btn[j]; j++)\n\t\t\t\tinput_report_key(dev, cobra_btn[j], data[i] & (0x20 << j));\n\n\t\t\tinput_sync(dev);\n\n\t\t}\n}\n\nstatic int cobra_open(struct input_dev *dev)\n{\n\tstruct cobra *cobra = input_get_drvdata(dev);\n\n\tgameport_start_polling(cobra->gameport);\n\treturn 0;\n}\n\nstatic void cobra_close(struct input_dev *dev)\n{\n\tstruct cobra *cobra = input_get_drvdata(dev);\n\n\tgameport_stop_polling(cobra->gameport);\n}\n\nstatic int cobra_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct cobra *cobra;\n\tstruct input_dev *input_dev;\n\tunsigned int data[2];\n\tint i, j;\n\tint err;\n\n\tcobra = kzalloc(sizeof(struct cobra), GFP_KERNEL);\n\tif (!cobra)\n\t\treturn -ENOMEM;\n\n\tcobra->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, cobra);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tcobra->exists = cobra_read_packet(gameport, data);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif ((cobra->exists >> i) & data[i] & 1) {\n\t\t\tprintk(KERN_WARNING \"cobra.c: Device %d on %s has the Ext bit set. ID is: %d\"\n\t\t\t\t\" Contact vojtech@ucw.cz\\n\", i, gameport->phys, (data[i] >> 2) & 7);\n\t\t\tcobra->exists &= ~(1 << i);\n\t\t}\n\n\tif (!cobra->exists) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, cobra_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (~(cobra->exists >> i) & 1)\n\t\t\tcontinue;\n\n\t\tcobra->dev[i] = input_dev = input_allocate_device();\n\t\tif (!input_dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail3;\n\t\t}\n\n\t\tsnprintf(cobra->phys[i], sizeof(cobra->phys[i]),\n\t\t\t \"%s/input%d\", gameport->phys, i);\n\n\t\tinput_dev->name = \"Creative Labs Blaster GamePad Cobra\";\n\t\tinput_dev->phys = cobra->phys[i];\n\t\tinput_dev->id.bustype = BUS_GAMEPORT;\n\t\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_CREATIVE;\n\t\tinput_dev->id.product = 0x0008;\n\t\tinput_dev->id.version = 0x0100;\n\t\tinput_dev->dev.parent = &gameport->dev;\n\n\t\tinput_set_drvdata(input_dev, cobra);\n\n\t\tinput_dev->open = cobra_open;\n\t\tinput_dev->close = cobra_close;\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput_set_abs_params(input_dev, ABS_X, -1, 1, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, -1, 1, 0, 0);\n\t\tfor (j = 0; cobra_btn[j]; j++)\n\t\t\tset_bit(cobra_btn[j], input_dev->keybit);\n\n\t\terr = input_register_device(cobra->dev[i]);\n\t\tif (err)\n\t\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\tinput_free_device(cobra->dev[i]);\n fail3:\twhile (--i >= 0)\n\t\tif (cobra->dev[i])\n\t\t\tinput_unregister_device(cobra->dev[i]);\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(cobra);\n\treturn err;\n}\n\nstatic void cobra_disconnect(struct gameport *gameport)\n{\n\tstruct cobra *cobra = gameport_get_drvdata(gameport);\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tif ((cobra->exists >> i) & 1)\n\t\t\tinput_unregister_device(cobra->dev[i]);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(cobra);\n}\n\nstatic struct gameport_driver cobra_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"cobra\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= cobra_connect,\n\t.disconnect\t= cobra_disconnect,\n};\n\nmodule_gameport_driver(cobra_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}