{
  "module_name": "db9.c",
  "hash_id": "570f4bd211829f467151835df6bbd9c1e6d135423627f7c35328f57088db700c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/db9.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/parport.h>\n#include <linux/input.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"Atari, Amstrad, Commodore, Amiga, Sega, etc. joystick driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct db9_config {\n\tint args[2];\n\tunsigned int nargs;\n};\n\n#define DB9_MAX_PORTS\t\t3\nstatic struct db9_config db9_cfg[DB9_MAX_PORTS];\n\nmodule_param_array_named(dev, db9_cfg[0].args, int, &db9_cfg[0].nargs, 0);\nMODULE_PARM_DESC(dev, \"Describes first attached device (<parport#>,<type>)\");\nmodule_param_array_named(dev2, db9_cfg[1].args, int, &db9_cfg[1].nargs, 0);\nMODULE_PARM_DESC(dev2, \"Describes second attached device (<parport#>,<type>)\");\nmodule_param_array_named(dev3, db9_cfg[2].args, int, &db9_cfg[2].nargs, 0);\nMODULE_PARM_DESC(dev3, \"Describes third attached device (<parport#>,<type>)\");\n\n#define DB9_ARG_PARPORT\t\t0\n#define DB9_ARG_MODE\t\t1\n\n#define DB9_MULTI_STICK\t\t0x01\n#define DB9_MULTI2_STICK\t0x02\n#define DB9_GENESIS_PAD\t\t0x03\n#define DB9_GENESIS5_PAD\t0x05\n#define DB9_GENESIS6_PAD\t0x06\n#define DB9_SATURN_PAD\t\t0x07\n#define DB9_MULTI_0802\t\t0x08\n#define DB9_MULTI_0802_2\t0x09\n#define DB9_CD32_PAD\t\t0x0A\n#define DB9_SATURN_DPP\t\t0x0B\n#define DB9_SATURN_DPP_2\t0x0C\n#define DB9_MAX_PAD\t\t0x0D\n\n#define DB9_UP\t\t\t0x01\n#define DB9_DOWN\t\t0x02\n#define DB9_LEFT\t\t0x04\n#define DB9_RIGHT\t\t0x08\n#define DB9_FIRE1\t\t0x10\n#define DB9_FIRE2\t\t0x20\n#define DB9_FIRE3\t\t0x40\n#define DB9_FIRE4\t\t0x80\n\n#define DB9_NORMAL\t\t0x0a\n#define DB9_NOSELECT\t\t0x08\n\n#define DB9_GENESIS6_DELAY\t14\n#define DB9_REFRESH_TIME\tHZ/100\n\n#define DB9_MAX_DEVICES\t\t2\n\nstruct db9_mode_data {\n\tconst char *name;\n\tconst short *buttons;\n\tint n_buttons;\n\tint n_pads;\n\tint n_axis;\n\tint bidirectional;\n\tint reverse;\n};\n\nstruct db9 {\n\tstruct input_dev *dev[DB9_MAX_DEVICES];\n\tstruct timer_list timer;\n\tstruct pardevice *pd;\n\tint mode;\n\tint used;\n\tint parportno;\n\tstruct mutex mutex;\n\tchar phys[DB9_MAX_DEVICES][32];\n};\n\nstatic struct db9 *db9_base[3];\n\nstatic const short db9_multi_btn[] = { BTN_TRIGGER, BTN_THUMB };\nstatic const short db9_genesis_btn[] = { BTN_START, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_MODE };\nstatic const short db9_cd32_btn[] = { BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_TL, BTN_TR, BTN_START };\nstatic const short db9_abs[] = { ABS_X, ABS_Y, ABS_RX, ABS_RY, ABS_RZ, ABS_Z, ABS_HAT0X, ABS_HAT0Y, ABS_HAT1X, ABS_HAT1Y };\n\nstatic const struct db9_mode_data db9_modes[] = {\n\t{ NULL,\t\t\t\t\t NULL,\t\t  0,  0,  0,  0,  0 },\n\t{ \"Multisystem joystick\",\t\t db9_multi_btn,\t  1,  1,  2,  1,  1 },\n\t{ \"Multisystem joystick (2 fire)\",\t db9_multi_btn,\t  2,  1,  2,  1,  1 },\n\t{ \"Genesis pad\",\t\t\t db9_genesis_btn, 4,  1,  2,  1,  1 },\n\t{ NULL,\t\t\t\t\t NULL,\t\t  0,  0,  0,  0,  0 },\n\t{ \"Genesis 5 pad\",\t\t\t db9_genesis_btn, 6,  1,  2,  1,  1 },\n\t{ \"Genesis 6 pad\",\t\t\t db9_genesis_btn, 8,  1,  2,  1,  1 },\n\t{ \"Saturn pad\",\t\t\t\t db9_cd32_btn,\t  9,  6,  7,  0,  1 },\n\t{ \"Multisystem (0.8.0.2) joystick\",\t db9_multi_btn,\t  1,  1,  2,  1,  1 },\n\t{ \"Multisystem (0.8.0.2-dual) joystick\", db9_multi_btn,\t  1,  2,  2,  1,  1 },\n\t{ \"Amiga CD-32 pad\",\t\t\t db9_cd32_btn,\t  7,  1,  2,  1,  1 },\n\t{ \"Saturn dpp\",\t\t\t\t db9_cd32_btn,\t  9,  6,  7,  0,  0 },\n\t{ \"Saturn dpp dual\",\t\t\t db9_cd32_btn,\t  9,  12, 7,  0,  0 },\n};\n\n \n#define DB9_SATURN_DELAY 300\nstatic const int db9_saturn_byte[] = { 1, 1, 1, 2, 2, 2, 2, 2, 1 };\nstatic const unsigned char db9_saturn_mask[] = { 0x04, 0x01, 0x02, 0x40, 0x20, 0x10, 0x08, 0x80, 0x08 };\n\n \nstatic void db9_saturn_write_sub(struct parport *port, int type, unsigned char data, int powered, int pwr_sub)\n{\n\tunsigned char c;\n\n\tswitch (type) {\n\tcase 1:  \n\t\tc = 0x80 | 0x30 | (powered ? 0x08 : 0) | (pwr_sub ? 0x04 : 0) | data;\n\t\tparport_write_data(port, c);\n\t\tbreak;\n\tcase 2:  \n\t\tc = 0x40 | data << 4 | (powered ? 0x08 : 0) | (pwr_sub ? 0x04 : 0) | 0x03;\n\t\tparport_write_data(port, c);\n\t\tbreak;\n\tcase 0:\t \n\t\tc = ((((data & 2) ? 2 : 0) | ((data & 1) ? 4 : 0)) ^ 0x02) | !powered;\n\t\tparport_write_control(port, c);\n\t\tbreak;\n\t}\n}\n\n \nstatic unsigned char db9_saturn_read_sub(struct parport *port, int type)\n{\n\tunsigned char data;\n\n\tif (type) {\n\t\t \n\t\tdata = parport_read_status(port) ^ 0x80;\n\t\treturn (data & 0x80 ? 1 : 0) | (data & 0x40 ? 2 : 0)\n\t\t     | (data & 0x20 ? 4 : 0) | (data & 0x10 ? 8 : 0);\n\t} else {\n\t\t \n\t\tdata = parport_read_data(port) & 0x0f;\n\t\treturn (data & 0x8 ? 1 : 0) | (data & 0x4 ? 2 : 0)\n\t\t     | (data & 0x2 ? 4 : 0) | (data & 0x1 ? 8 : 0);\n\t}\n}\n\n \nstatic unsigned char db9_saturn_read_analog(struct parport *port, int type, int powered)\n{\n\tunsigned char data;\n\n\tdb9_saturn_write_sub(port, type, 0, powered, 0);\n\tudelay(DB9_SATURN_DELAY);\n\tdata = db9_saturn_read_sub(port, type) << 4;\n\tdb9_saturn_write_sub(port, type, 2, powered, 0);\n\tudelay(DB9_SATURN_DELAY);\n\tdata |= db9_saturn_read_sub(port, type);\n\treturn data;\n}\n\n \nstatic unsigned char db9_saturn_read_packet(struct parport *port, unsigned char *data, int type, int powered)\n{\n\tint i, j;\n\tunsigned char tmp;\n\n\tdb9_saturn_write_sub(port, type, 3, powered, 0);\n\tdata[0] = db9_saturn_read_sub(port, type);\n\tswitch (data[0] & 0x0f) {\n\tcase 0xf:\n\t\t \n\t\treturn data[0] = 0xff;\n\tcase 0x4: case 0x4 | 0x8:\n\t\t \n\t\tdb9_saturn_write_sub(port, type, 0, powered, 1);\n\t\tdata[2] = db9_saturn_read_sub(port, type) << 4;\n\t\tdb9_saturn_write_sub(port, type, 2, powered, 1);\n\t\tdata[1] = db9_saturn_read_sub(port, type) << 4;\n\t\tdb9_saturn_write_sub(port, type, 1, powered, 1);\n\t\tdata[1] |= db9_saturn_read_sub(port, type);\n\t\tdb9_saturn_write_sub(port, type, 3, powered, 1);\n\t\t \n\t\tdata[2] |= data[0];\n\t\treturn data[0] = 0x02;\n\tcase 0x1:\n\t\t \n\t\tdb9_saturn_write_sub(port, type, 2, powered, 0);\n\t\tudelay(DB9_SATURN_DELAY);\n\t\tdata[0] = db9_saturn_read_analog(port, type, powered);\n\t\tif (data[0] != 0x41) {\n\t\t\t \n\t\t\tfor (i = 0; i < (data[0] & 0x0f); i++)\n\t\t\t\tdata[i + 1] = db9_saturn_read_analog(port, type, powered);\n\t\t\tdb9_saturn_write_sub(port, type, 3, powered, 0);\n\t\t\treturn data[0];\n\t\t} else {\n\t\t\t \n\t\t\tif (db9_saturn_read_analog(port, type, powered) != 0x60)\n\t\t\t\treturn data[0] = 0xff;\n\t\t\tfor (i = 0; i < 60; i += 10) {\n\t\t\t\tdata[i] = db9_saturn_read_analog(port, type, powered);\n\t\t\t\tif (data[i] != 0xff)\n\t\t\t\t\t \n\t\t\t\t\tfor (j = 0; j < (data[i] & 0x0f); j++)\n\t\t\t\t\t\tdata[i + j + 1] = db9_saturn_read_analog(port, type, powered);\n\t\t\t}\n\t\t\tdb9_saturn_write_sub(port, type, 3, powered, 0);\n\t\t\treturn 0x41;\n\t\t}\n\tcase 0x0:\n\t\t \n\t\tdb9_saturn_write_sub(port, type, 2, powered, 0);\n\t\tudelay(DB9_SATURN_DELAY);\n\t\ttmp = db9_saturn_read_analog(port, type, powered);\n\t\tif (tmp == 0xff) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdata[i + 1] = db9_saturn_read_analog(port, type, powered);\n\t\t\tdb9_saturn_write_sub(port, type, 3, powered, 0);\n\t\t\treturn data[0] = 0xe3;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn data[0];\n\t}\n}\n\n \nstatic int db9_saturn_report(unsigned char id, unsigned char data[60], struct input_dev *devs[], int n, int max_pads)\n{\n\tstruct input_dev *dev;\n\tint tmp, i, j;\n\n\ttmp = (id == 0x41) ? 60 : 10;\n\tfor (j = 0; j < tmp && n < max_pads; j += 10, n++) {\n\t\tdev = devs[n];\n\t\tswitch (data[j]) {\n\t\tcase 0x16:  \n\t\t\tinput_report_abs(dev, db9_abs[5], data[j + 6]);\n\t\t\tfallthrough;\n\t\tcase 0x15:  \n\t\t\tinput_report_abs(dev, db9_abs[3], data[j + 4]);\n\t\t\tinput_report_abs(dev, db9_abs[4], data[j + 5]);\n\t\t\tfallthrough;\n\t\tcase 0x13:  \n\t\t\tinput_report_abs(dev, db9_abs[2], data[j + 3]);\n\t\t\tfallthrough;\n\t\tcase 0x34:  \n\t\tcase 0x02:  \n\t\t\tinput_report_abs(dev, db9_abs[0], !(data[j + 1] & 128) - !(data[j + 1] & 64));\n\t\t\tinput_report_abs(dev, db9_abs[1], !(data[j + 1] & 32) - !(data[j + 1] & 16));\n\t\t\tfor (i = 0; i < 9; i++)\n\t\t\t\tinput_report_key(dev, db9_cd32_btn[i], ~data[j + db9_saturn_byte[i]] & db9_saturn_mask[i]);\n\t\t\tbreak;\n\t\tcase 0x19:  \n\t\t\tinput_report_abs(dev, db9_abs[0], !(data[j + 1] & 128) - !(data[j + 1] & 64));\n\t\t\tinput_report_abs(dev, db9_abs[1], !(data[j + 1] & 32) - !(data[j + 1] & 16));\n\t\t\tfor (i = 0; i < 9; i++)\n\t\t\t\tinput_report_key(dev, db9_cd32_btn[i], ~data[j + db9_saturn_byte[i]] & db9_saturn_mask[i]);\n\t\t\tinput_report_abs(dev, db9_abs[2], data[j + 3]);\n\t\t\tinput_report_abs(dev, db9_abs[3], data[j + 4]);\n\t\t\tinput_report_abs(dev, db9_abs[4], data[j + 5]);\n\t\t\t \n\t\t\tinput_report_abs(dev, db9_abs[6], data[j + 7]);\n\t\t\tinput_report_abs(dev, db9_abs[7], data[j + 8]);\n\t\t\tinput_report_abs(dev, db9_abs[5], data[j + 9]);\n\t\t\tbreak;\n\t\tcase 0xd3:  \n\t\t\tinput_report_key(dev, BTN_A, data[j + 3] & 0x80);\n\t\t\tinput_report_abs(dev, db9_abs[2], data[j + 3] & 0x7f);\n\t\t\tbreak;\n\t\tcase 0xe3:  \n\t\t\tinput_report_key(dev, BTN_START, data[j + 1] & 0x08);\n\t\t\tinput_report_key(dev, BTN_A, data[j + 1] & 0x04);\n\t\t\tinput_report_key(dev, BTN_C, data[j + 1] & 0x02);\n\t\t\tinput_report_key(dev, BTN_B, data[j + 1] & 0x01);\n\t\t\tinput_report_abs(dev, db9_abs[2], data[j + 2] ^ 0x80);\n\t\t\tinput_report_abs(dev, db9_abs[3], (0xff-(data[j + 3] ^ 0x80))+1);  \n\t\t\tbreak;\n\t\tcase 0xff:\n\t\tdefault:  \n\t\t\tinput_report_abs(dev, db9_abs[0], 0);\n\t\t\tinput_report_abs(dev, db9_abs[1], 0);\n\t\t\tfor (i = 0; i < 9; i++)\n\t\t\t\tinput_report_key(dev, db9_cd32_btn[i], 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}\n\nstatic int db9_saturn(int mode, struct parport *port, struct input_dev *devs[])\n{\n\tunsigned char id, data[60];\n\tint type, n, max_pads;\n\tint tmp, i;\n\n\tswitch (mode) {\n\tcase DB9_SATURN_PAD:\n\t\ttype = 0;\n\t\tn = 1;\n\t\tbreak;\n\tcase DB9_SATURN_DPP:\n\t\ttype = 1;\n\t\tn = 1;\n\t\tbreak;\n\tcase DB9_SATURN_DPP_2:\n\t\ttype = 1;\n\t\tn = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tmax_pads = min(db9_modes[mode].n_pads, DB9_MAX_DEVICES);\n\tfor (tmp = 0, i = 0; i < n; i++) {\n\t\tid = db9_saturn_read_packet(port, data, type + i, 1);\n\t\ttmp = db9_saturn_report(id, data, devs, tmp, max_pads);\n\t}\n\treturn 0;\n}\n\nstatic void db9_timer(struct timer_list *t)\n{\n\tstruct db9 *db9 = from_timer(db9, t, timer);\n\tstruct parport *port = db9->pd->port;\n\tstruct input_dev *dev = db9->dev[0];\n\tstruct input_dev *dev2 = db9->dev[1];\n\tint data, i;\n\n\tswitch (db9->mode) {\n\t\tcase DB9_MULTI_0802_2:\n\n\t\t\tdata = parport_read_data(port) >> 3;\n\n\t\t\tinput_report_abs(dev2, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev2, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev2, BTN_TRIGGER, ~data & DB9_FIRE1);\n\t\t\tfallthrough;\n\n\t\tcase DB9_MULTI_0802:\n\n\t\t\tdata = parport_read_status(port) >> 3;\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev, BTN_TRIGGER, data & DB9_FIRE1);\n\t\t\tbreak;\n\n\t\tcase DB9_MULTI_STICK:\n\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev, BTN_TRIGGER, ~data & DB9_FIRE1);\n\t\t\tbreak;\n\n\t\tcase DB9_MULTI2_STICK:\n\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev, BTN_TRIGGER, ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_THUMB,   ~data & DB9_FIRE2);\n\t\t\tbreak;\n\n\t\tcase DB9_GENESIS_PAD:\n\n\t\t\tparport_write_control(port, DB9_NOSELECT);\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev, BTN_B, ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_C, ~data & DB9_FIRE2);\n\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_key(dev, BTN_A,     ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_START, ~data & DB9_FIRE2);\n\t\t\tbreak;\n\n\t\tcase DB9_GENESIS5_PAD:\n\n\t\t\tparport_write_control(port, DB9_NOSELECT);\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev, BTN_B, ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_C, ~data & DB9_FIRE2);\n\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_key(dev, BTN_A,     ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_X,     ~data & DB9_FIRE2);\n\t\t\tinput_report_key(dev, BTN_Y,     ~data & DB9_LEFT);\n\t\t\tinput_report_key(dev, BTN_START, ~data & DB9_RIGHT);\n\t\t\tbreak;\n\n\t\tcase DB9_GENESIS6_PAD:\n\n\t\t\tparport_write_control(port, DB9_NOSELECT);  \n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\t\t\tinput_report_key(dev, BTN_B, ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_C, ~data & DB9_FIRE2);\n\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_key(dev, BTN_A, ~data & DB9_FIRE1);\n\t\t\tinput_report_key(dev, BTN_START, ~data & DB9_FIRE2);\n\n\t\t\tparport_write_control(port, DB9_NOSELECT);  \n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tparport_write_control(port, DB9_NOSELECT);  \n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tdata=parport_read_data(port);\n\n\t\t\tinput_report_key(dev, BTN_X,    ~data & DB9_LEFT);\n\t\t\tinput_report_key(dev, BTN_Y,    ~data & DB9_DOWN);\n\t\t\tinput_report_key(dev, BTN_Z,    ~data & DB9_UP);\n\t\t\tinput_report_key(dev, BTN_MODE, ~data & DB9_RIGHT);\n\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tparport_write_control(port, DB9_NOSELECT);  \n\t\t\tudelay(DB9_GENESIS6_DELAY);\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t\tbreak;\n\n\t\tcase DB9_SATURN_PAD:\n\t\tcase DB9_SATURN_DPP:\n\t\tcase DB9_SATURN_DPP_2:\n\n\t\t\tdb9_saturn(db9->mode, port, db9->dev);\n\t\t\tbreak;\n\n\t\tcase DB9_CD32_PAD:\n\n\t\t\tdata = parport_read_data(port);\n\n\t\t\tinput_report_abs(dev, ABS_X, (data & DB9_RIGHT ? 0 : 1) - (data & DB9_LEFT ? 0 : 1));\n\t\t\tinput_report_abs(dev, ABS_Y, (data & DB9_DOWN  ? 0 : 1) - (data & DB9_UP   ? 0 : 1));\n\n\t\t\tparport_write_control(port, 0x0a);\n\n\t\t\tfor (i = 0; i < 7; i++) {\n\t\t\t\tdata = parport_read_data(port);\n\t\t\t\tparport_write_control(port, 0x02);\n\t\t\t\tparport_write_control(port, 0x0a);\n\t\t\t\tinput_report_key(dev, db9_cd32_btn[i], ~data & DB9_FIRE2);\n\t\t\t}\n\n\t\t\tparport_write_control(port, 0x00);\n\t\t\tbreak;\n\t\t}\n\n\tinput_sync(dev);\n\n\tmod_timer(&db9->timer, jiffies + DB9_REFRESH_TIME);\n}\n\nstatic int db9_open(struct input_dev *dev)\n{\n\tstruct db9 *db9 = input_get_drvdata(dev);\n\tstruct parport *port = db9->pd->port;\n\tint err;\n\n\terr = mutex_lock_interruptible(&db9->mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (!db9->used++) {\n\t\tparport_claim(db9->pd);\n\t\tparport_write_data(port, 0xff);\n\t\tif (db9_modes[db9->mode].reverse) {\n\t\t\tparport_data_reverse(port);\n\t\t\tparport_write_control(port, DB9_NORMAL);\n\t\t}\n\t\tmod_timer(&db9->timer, jiffies + DB9_REFRESH_TIME);\n\t}\n\n\tmutex_unlock(&db9->mutex);\n\treturn 0;\n}\n\nstatic void db9_close(struct input_dev *dev)\n{\n\tstruct db9 *db9 = input_get_drvdata(dev);\n\tstruct parport *port = db9->pd->port;\n\n\tmutex_lock(&db9->mutex);\n\tif (!--db9->used) {\n\t\tdel_timer_sync(&db9->timer);\n\t\tparport_write_control(port, 0x00);\n\t\tparport_data_forward(port);\n\t\tparport_release(db9->pd);\n\t}\n\tmutex_unlock(&db9->mutex);\n}\n\nstatic void db9_attach(struct parport *pp)\n{\n\tstruct db9 *db9;\n\tconst struct db9_mode_data *db9_mode;\n\tstruct pardevice *pd;\n\tstruct input_dev *input_dev;\n\tint i, j, port_idx;\n\tint mode;\n\tstruct pardev_cb db9_parport_cb;\n\n\tfor (port_idx = 0; port_idx < DB9_MAX_PORTS; port_idx++) {\n\t\tif (db9_cfg[port_idx].nargs == 0 ||\n\t\t    db9_cfg[port_idx].args[DB9_ARG_PARPORT] < 0)\n\t\t\tcontinue;\n\n\t\tif (db9_cfg[port_idx].args[DB9_ARG_PARPORT] == pp->number)\n\t\t\tbreak;\n\t}\n\n\tif (port_idx == DB9_MAX_PORTS) {\n\t\tpr_debug(\"Not using parport%d.\\n\", pp->number);\n\t\treturn;\n\t}\n\n\tmode = db9_cfg[port_idx].args[DB9_ARG_MODE];\n\n\tif (mode < 1 || mode >= DB9_MAX_PAD || !db9_modes[mode].n_buttons) {\n\t\tprintk(KERN_ERR \"db9.c: Bad device type %d\\n\", mode);\n\t\treturn;\n\t}\n\n\tdb9_mode = &db9_modes[mode];\n\n\tif (db9_mode->bidirectional && !(pp->modes & PARPORT_MODE_TRISTATE)) {\n\t\tprintk(KERN_ERR \"db9.c: specified parport is not bidirectional\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&db9_parport_cb, 0, sizeof(db9_parport_cb));\n\tdb9_parport_cb.flags = PARPORT_FLAG_EXCL;\n\n\tpd = parport_register_dev_model(pp, \"db9\", &db9_parport_cb, port_idx);\n\tif (!pd) {\n\t\tprintk(KERN_ERR \"db9.c: parport busy already - lp.o loaded?\\n\");\n\t\treturn;\n\t}\n\n\tdb9 = kzalloc(sizeof(struct db9), GFP_KERNEL);\n\tif (!db9)\n\t\tgoto err_unreg_pardev;\n\n\tmutex_init(&db9->mutex);\n\tdb9->pd = pd;\n\tdb9->mode = mode;\n\tdb9->parportno = pp->number;\n\ttimer_setup(&db9->timer, db9_timer, 0);\n\n\tfor (i = 0; i < (min(db9_mode->n_pads, DB9_MAX_DEVICES)); i++) {\n\n\t\tdb9->dev[i] = input_dev = input_allocate_device();\n\t\tif (!input_dev) {\n\t\t\tprintk(KERN_ERR \"db9.c: Not enough memory for input device\\n\");\n\t\t\tgoto err_unreg_devs;\n\t\t}\n\n\t\tsnprintf(db9->phys[i], sizeof(db9->phys[i]),\n\t\t\t \"%s/input%d\", db9->pd->port->name, i);\n\n\t\tinput_dev->name = db9_mode->name;\n\t\tinput_dev->phys = db9->phys[i];\n\t\tinput_dev->id.bustype = BUS_PARPORT;\n\t\tinput_dev->id.vendor = 0x0002;\n\t\tinput_dev->id.product = mode;\n\t\tinput_dev->id.version = 0x0100;\n\n\t\tinput_set_drvdata(input_dev, db9);\n\n\t\tinput_dev->open = db9_open;\n\t\tinput_dev->close = db9_close;\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tfor (j = 0; j < db9_mode->n_buttons; j++)\n\t\t\tset_bit(db9_mode->buttons[j], input_dev->keybit);\n\t\tfor (j = 0; j < db9_mode->n_axis; j++) {\n\t\t\tif (j < 2)\n\t\t\t\tinput_set_abs_params(input_dev, db9_abs[j], -1, 1, 0, 0);\n\t\t\telse\n\t\t\t\tinput_set_abs_params(input_dev, db9_abs[j], 1, 255, 0, 0);\n\t\t}\n\n\t\tif (input_register_device(input_dev))\n\t\t\tgoto err_free_dev;\n\t}\n\n\tdb9_base[port_idx] = db9;\n\treturn;\n\n err_free_dev:\n\tinput_free_device(db9->dev[i]);\n err_unreg_devs:\n\twhile (--i >= 0)\n\t\tinput_unregister_device(db9->dev[i]);\n\tkfree(db9);\n err_unreg_pardev:\n\tparport_unregister_device(pd);\n}\n\nstatic void db9_detach(struct parport *port)\n{\n\tint i;\n\tstruct db9 *db9;\n\n\tfor (i = 0; i < DB9_MAX_PORTS; i++) {\n\t\tif (db9_base[i] && db9_base[i]->parportno == port->number)\n\t\t\tbreak;\n\t}\n\n\tif (i == DB9_MAX_PORTS)\n\t\treturn;\n\n\tdb9 = db9_base[i];\n\tdb9_base[i] = NULL;\n\n\tfor (i = 0; i < min(db9_modes[db9->mode].n_pads, DB9_MAX_DEVICES); i++)\n\t\tinput_unregister_device(db9->dev[i]);\n\tparport_unregister_device(db9->pd);\n\tkfree(db9);\n}\n\nstatic struct parport_driver db9_parport_driver = {\n\t.name = \"db9\",\n\t.match_port = db9_attach,\n\t.detach = db9_detach,\n\t.devmodel = true,\n};\n\nstatic int __init db9_init(void)\n{\n\tint i;\n\tint have_dev = 0;\n\n\tfor (i = 0; i < DB9_MAX_PORTS; i++) {\n\t\tif (db9_cfg[i].nargs == 0 || db9_cfg[i].args[DB9_ARG_PARPORT] < 0)\n\t\t\tcontinue;\n\n\t\tif (db9_cfg[i].nargs < 2) {\n\t\t\tprintk(KERN_ERR \"db9.c: Device type must be specified.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thave_dev = 1;\n\t}\n\n\tif (!have_dev)\n\t\treturn -ENODEV;\n\n\treturn parport_register_driver(&db9_parport_driver);\n}\n\nstatic void __exit db9_exit(void)\n{\n\tparport_unregister_driver(&db9_parport_driver);\n}\n\nmodule_init(db9_init);\nmodule_exit(db9_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}