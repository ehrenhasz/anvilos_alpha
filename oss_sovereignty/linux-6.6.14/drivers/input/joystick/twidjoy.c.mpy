{
  "module_name": "twidjoy.c",
  "hash_id": "3b436fb06b99a1bd8a2e2e686ed68bc9d0654415ad53fc75a7eca50e9c9aea7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/twidjoy.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"Handykey Twiddler keyboard as a joystick driver\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define TWIDJOY_MAX_LENGTH 5\n\nstatic struct twidjoy_button_spec {\n\tint bitshift;\n\tint bitmask;\n\tint buttons[3];\n}\ntwidjoy_buttons[] = {\n\t{  0, 3, { BTN_A,      BTN_B,     BTN_C    } },\n\t{  2, 3, { BTN_X,      BTN_Y,     BTN_Z    } },\n\t{  4, 3, { BTN_TL,     BTN_TR,    BTN_TR2  } },\n\t{  6, 3, { BTN_SELECT, BTN_START, BTN_MODE } },\n\t{  8, 1, { BTN_BASE5                       } },\n\t{  9, 1, { BTN_BASE                        } },\n\t{ 10, 1, { BTN_BASE3                       } },\n\t{ 11, 1, { BTN_BASE4                       } },\n\t{ 12, 1, { BTN_BASE2                       } },\n\t{ 13, 1, { BTN_BASE6                       } },\n\t{ 0,  0, { 0                               } }\n};\n\n \n\nstruct twidjoy {\n\tstruct input_dev *dev;\n\tint idx;\n\tunsigned char data[TWIDJOY_MAX_LENGTH];\n\tchar phys[32];\n};\n\n \n\nstatic void twidjoy_process_packet(struct twidjoy *twidjoy)\n{\n\tstruct input_dev *dev = twidjoy->dev;\n\tunsigned char *data = twidjoy->data;\n\tstruct twidjoy_button_spec *bp;\n\tint button_bits, abs_x, abs_y;\n\n\tbutton_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);\n\n\tfor (bp = twidjoy_buttons; bp->bitmask; bp++) {\n\t\tint value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;\n\t\tint i;\n\n\t\tfor (i = 0; i < bp->bitmask; i++)\n\t\t\tinput_report_key(dev, bp->buttons[i], i+1 == value);\n\t}\n\n\tabs_x = ((data[4] & 0x07) << 5) | ((data[3] & 0x7C) >> 2);\n\tif (data[4] & 0x08) abs_x -= 256;\n\n\tabs_y = ((data[3] & 0x01) << 7) | ((data[2] & 0x7F) >> 0);\n\tif (data[3] & 0x02) abs_y -= 256;\n\n\tinput_report_abs(dev, ABS_X, -abs_x);\n\tinput_report_abs(dev, ABS_Y, +abs_y);\n\n\tinput_sync(dev);\n}\n\n \n\nstatic irqreturn_t twidjoy_interrupt(struct serio *serio, unsigned char data, unsigned int flags)\n{\n\tstruct twidjoy *twidjoy = serio_get_drvdata(serio);\n\n\t \n\n\tif ((data & 0x80) == 0)\n\t\ttwidjoy->idx = 0;\t \n\telse if (twidjoy->idx == 0)\n\t\treturn IRQ_HANDLED;\t \n\n\tif (twidjoy->idx < TWIDJOY_MAX_LENGTH)\n\t\ttwidjoy->data[twidjoy->idx++] = data;\n\n\tif (twidjoy->idx == TWIDJOY_MAX_LENGTH) {\n\t\ttwidjoy_process_packet(twidjoy);\n\t\ttwidjoy->idx = 0;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void twidjoy_disconnect(struct serio *serio)\n{\n\tstruct twidjoy *twidjoy = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(twidjoy->dev);\n\tkfree(twidjoy);\n}\n\n \n\nstatic int twidjoy_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct twidjoy_button_spec *bp;\n\tstruct twidjoy *twidjoy;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\tint i;\n\n\ttwidjoy = kzalloc(sizeof(struct twidjoy), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!twidjoy || !input_dev)\n\t\tgoto fail1;\n\n\ttwidjoy->dev = input_dev;\n\tsnprintf(twidjoy->phys, sizeof(twidjoy->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"Handykey Twiddler\";\n\tinput_dev->phys = twidjoy->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_TWIDJOY;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_set_abs_params(input_dev, ABS_X, -50, 50, 4, 4);\n\tinput_set_abs_params(input_dev, ABS_Y, -50, 50, 4, 4);\n\n\tfor (bp = twidjoy_buttons; bp->bitmask; bp++)\n\t\tfor (i = 0; i < bp->bitmask; i++)\n\t\t\tset_bit(bp->buttons[i], input_dev->keybit);\n\n\tserio_set_drvdata(serio, twidjoy);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(twidjoy->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(twidjoy);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id twidjoy_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_TWIDJOY,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, twidjoy_serio_ids);\n\nstatic struct serio_driver twidjoy_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"twidjoy\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= twidjoy_serio_ids,\n\t.interrupt\t= twidjoy_interrupt,\n\t.connect\t= twidjoy_connect,\n\t.disconnect\t= twidjoy_disconnect,\n};\n\nmodule_serio_driver(twidjoy_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}