{
  "module_name": "psxpad-spi.c",
  "hash_id": "5c20aae21b4f405b3f1bd7816baa4a0f80e2ebf3d032044a3d0131d0469a0836",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/psxpad-spi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#define REVERSE_BIT(x) ((((x) & 0x80) >> 7) | (((x) & 0x40) >> 5) | \\\n\t(((x) & 0x20) >> 3) | (((x) & 0x10) >> 1) | (((x) & 0x08) << 1) | \\\n\t(((x) & 0x04) << 3) | (((x) & 0x02) << 5) | (((x) & 0x01) << 7))\n\n \n\n \nstatic const u8 PSX_CMD_POLL[] = {\n\t0x80, 0x42, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n#ifdef CONFIG_JOYSTICK_PSXPAD_SPI_FF\n \nstatic const u8 PSX_CMD_ENTER_CFG[] = {\n\t0x80, 0xC2, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n \nstatic const u8 PSX_CMD_EXIT_CFG[] = {\n\t0x80, 0xC2, 0x00, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A\n};\n \nstatic const u8 PSX_CMD_ENABLE_MOTOR[]\t= {\n\t0x80, 0xB2, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF\n};\n#endif  \n\nstruct psxpad {\n\tstruct spi_device *spi;\n\tstruct input_dev *idev;\n\tchar phys[0x20];\n\tbool motor1enable;\n\tbool motor2enable;\n\tu8 motor1level;\n\tu8 motor2level;\n\tu8 sendbuf[0x20] ____cacheline_aligned;\n\tu8 response[sizeof(PSX_CMD_POLL)] ____cacheline_aligned;\n};\n\nstatic int psxpad_command(struct psxpad *pad, const u8 sendcmdlen)\n{\n\tstruct spi_transfer xfers = {\n\t\t.tx_buf\t\t= pad->sendbuf,\n\t\t.rx_buf\t\t= pad->response,\n\t\t.len\t\t= sendcmdlen,\n\t};\n\tint err;\n\n\terr = spi_sync_transfer(pad->spi, &xfers, 1);\n\tif (err) {\n\t\tdev_err(&pad->spi->dev,\n\t\t\t\"%s: failed to SPI xfers mode: %d\\n\",\n\t\t\t__func__, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_JOYSTICK_PSXPAD_SPI_FF\nstatic void psxpad_control_motor(struct psxpad *pad,\n\t\t\t\t bool motor1enable, bool motor2enable)\n{\n\tint err;\n\n\tpad->motor1enable = motor1enable;\n\tpad->motor2enable = motor2enable;\n\n\tmemcpy(pad->sendbuf, PSX_CMD_ENTER_CFG, sizeof(PSX_CMD_ENTER_CFG));\n\terr = psxpad_command(pad, sizeof(PSX_CMD_ENTER_CFG));\n\tif (err) {\n\t\tdev_err(&pad->spi->dev,\n\t\t\t\"%s: failed to enter config mode: %d\\n\",\n\t\t\t__func__, err);\n\t\treturn;\n\t}\n\n\tmemcpy(pad->sendbuf, PSX_CMD_ENABLE_MOTOR,\n\t       sizeof(PSX_CMD_ENABLE_MOTOR));\n\tpad->sendbuf[3] = pad->motor1enable ? 0x00 : 0xFF;\n\tpad->sendbuf[4] = pad->motor2enable ? 0x80 : 0xFF;\n\terr = psxpad_command(pad, sizeof(PSX_CMD_ENABLE_MOTOR));\n\tif (err) {\n\t\tdev_err(&pad->spi->dev,\n\t\t\t\"%s: failed to enable motor mode: %d\\n\",\n\t\t\t__func__, err);\n\t\treturn;\n\t}\n\n\tmemcpy(pad->sendbuf, PSX_CMD_EXIT_CFG, sizeof(PSX_CMD_EXIT_CFG));\n\terr = psxpad_command(pad, sizeof(PSX_CMD_EXIT_CFG));\n\tif (err) {\n\t\tdev_err(&pad->spi->dev,\n\t\t\t\"%s: failed to exit config mode: %d\\n\",\n\t\t\t__func__, err);\n\t\treturn;\n\t}\n}\n\nstatic void psxpad_set_motor_level(struct psxpad *pad,\n\t\t\t\t   u8 motor1level, u8 motor2level)\n{\n\tpad->motor1level = motor1level ? 0xFF : 0x00;\n\tpad->motor2level = REVERSE_BIT(motor2level);\n}\n\nstatic int psxpad_spi_play_effect(struct input_dev *idev,\n\t\t\t\t  void *data, struct ff_effect *effect)\n{\n\tstruct psxpad *pad = input_get_drvdata(idev);\n\n\tswitch (effect->type) {\n\tcase FF_RUMBLE:\n\t\tpsxpad_set_motor_level(pad,\n\t\t\t(effect->u.rumble.weak_magnitude >> 8) & 0xFFU,\n\t\t\t(effect->u.rumble.strong_magnitude >> 8) & 0xFFU);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int psxpad_spi_init_ff(struct psxpad *pad)\n{\n\tint err;\n\n\tinput_set_capability(pad->idev, EV_FF, FF_RUMBLE);\n\n\terr = input_ff_create_memless(pad->idev, NULL, psxpad_spi_play_effect);\n\tif (err) {\n\t\tdev_err(&pad->spi->dev,\n\t\t\t\"input_ff_create_memless() failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#else\t \n\nstatic void psxpad_control_motor(struct psxpad *pad,\n\t\t\t\t bool motor1enable, bool motor2enable)\n{\n}\n\nstatic void psxpad_set_motor_level(struct psxpad *pad,\n\t\t\t\t   u8 motor1level, u8 motor2level)\n{\n}\n\nstatic inline int psxpad_spi_init_ff(struct psxpad *pad)\n{\n\treturn 0;\n}\n#endif\t \n\nstatic int psxpad_spi_poll_open(struct input_dev *input)\n{\n\tstruct psxpad *pad = input_get_drvdata(input);\n\n\tpm_runtime_get_sync(&pad->spi->dev);\n\n\treturn 0;\n}\n\nstatic void psxpad_spi_poll_close(struct input_dev *input)\n{\n\tstruct psxpad *pad = input_get_drvdata(input);\n\n\tpm_runtime_put_sync(&pad->spi->dev);\n}\n\nstatic void psxpad_spi_poll(struct input_dev *input)\n{\n\tstruct psxpad *pad = input_get_drvdata(input);\n\tu8 b_rsp3, b_rsp4;\n\tint err;\n\n\tpsxpad_control_motor(pad, true, true);\n\n\tmemcpy(pad->sendbuf, PSX_CMD_POLL, sizeof(PSX_CMD_POLL));\n\tpad->sendbuf[3] = pad->motor1enable ? pad->motor1level : 0x00;\n\tpad->sendbuf[4] = pad->motor2enable ? pad->motor2level : 0x00;\n\terr = psxpad_command(pad, sizeof(PSX_CMD_POLL));\n\tif (err) {\n\t\tdev_err(&pad->spi->dev,\n\t\t\t\"%s: poll command failed mode: %d\\n\", __func__, err);\n\t\treturn;\n\t}\n\n\tswitch (pad->response[1]) {\n\tcase 0xCE:\t \n\t\t \n\t\tb_rsp3 = ~pad->response[3];\n\t\tb_rsp4 = ~pad->response[4];\n\n\t\tinput_report_abs(input, ABS_X, REVERSE_BIT(pad->response[7]));\n\t\tinput_report_abs(input, ABS_Y, REVERSE_BIT(pad->response[8]));\n\t\tinput_report_abs(input, ABS_RX, REVERSE_BIT(pad->response[5]));\n\t\tinput_report_abs(input, ABS_RY, REVERSE_BIT(pad->response[6]));\n\t\tinput_report_key(input, BTN_DPAD_UP, b_rsp3 & BIT(3));\n\t\tinput_report_key(input, BTN_DPAD_DOWN, b_rsp3 & BIT(1));\n\t\tinput_report_key(input, BTN_DPAD_LEFT, b_rsp3 & BIT(0));\n\t\tinput_report_key(input, BTN_DPAD_RIGHT, b_rsp3 & BIT(2));\n\t\tinput_report_key(input, BTN_X, b_rsp4 & BIT(3));\n\t\tinput_report_key(input, BTN_A, b_rsp4 & BIT(2));\n\t\tinput_report_key(input, BTN_B, b_rsp4 & BIT(1));\n\t\tinput_report_key(input, BTN_Y, b_rsp4 & BIT(0));\n\t\tinput_report_key(input, BTN_TL, b_rsp4 & BIT(5));\n\t\tinput_report_key(input, BTN_TR, b_rsp4 & BIT(4));\n\t\tinput_report_key(input, BTN_TL2, b_rsp4 & BIT(7));\n\t\tinput_report_key(input, BTN_TR2, b_rsp4 & BIT(6));\n\t\tinput_report_key(input, BTN_THUMBL, b_rsp3 & BIT(6));\n\t\tinput_report_key(input, BTN_THUMBR, b_rsp3 & BIT(5));\n\t\tinput_report_key(input, BTN_SELECT, b_rsp3 & BIT(7));\n\t\tinput_report_key(input, BTN_START, b_rsp3 & BIT(4));\n\t\tbreak;\n\n\tcase 0x82:\t \n\t\t \n\t\tb_rsp3 = ~pad->response[3];\n\t\tb_rsp4 = ~pad->response[4];\n\n\t\tinput_report_abs(input, ABS_X, 0x80);\n\t\tinput_report_abs(input, ABS_Y, 0x80);\n\t\tinput_report_abs(input, ABS_RX, 0x80);\n\t\tinput_report_abs(input, ABS_RY, 0x80);\n\t\tinput_report_key(input, BTN_DPAD_UP, b_rsp3 & BIT(3));\n\t\tinput_report_key(input, BTN_DPAD_DOWN, b_rsp3 & BIT(1));\n\t\tinput_report_key(input, BTN_DPAD_LEFT, b_rsp3 & BIT(0));\n\t\tinput_report_key(input, BTN_DPAD_RIGHT, b_rsp3 & BIT(2));\n\t\tinput_report_key(input, BTN_X, b_rsp4 & BIT(3));\n\t\tinput_report_key(input, BTN_A, b_rsp4 & BIT(2));\n\t\tinput_report_key(input, BTN_B, b_rsp4 & BIT(1));\n\t\tinput_report_key(input, BTN_Y, b_rsp4 & BIT(0));\n\t\tinput_report_key(input, BTN_TL, b_rsp4 & BIT(5));\n\t\tinput_report_key(input, BTN_TR, b_rsp4 & BIT(4));\n\t\tinput_report_key(input, BTN_TL2, b_rsp4 & BIT(7));\n\t\tinput_report_key(input, BTN_TR2, b_rsp4 & BIT(6));\n\t\tinput_report_key(input, BTN_THUMBL, false);\n\t\tinput_report_key(input, BTN_THUMBR, false);\n\t\tinput_report_key(input, BTN_SELECT, b_rsp3 & BIT(7));\n\t\tinput_report_key(input, BTN_START, b_rsp3 & BIT(4));\n\t\tbreak;\n\t}\n\n\tinput_sync(input);\n}\n\nstatic int psxpad_spi_probe(struct spi_device *spi)\n{\n\tstruct psxpad *pad;\n\tstruct input_dev *idev;\n\tint err;\n\n\tpad = devm_kzalloc(&spi->dev, sizeof(struct psxpad), GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tidev = devm_input_allocate_device(&spi->dev);\n\tif (!idev) {\n\t\tdev_err(&spi->dev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpad->idev = idev;\n\tpad->spi = spi;\n\n\t \n\tinput_set_drvdata(idev, pad);\n\n\tidev->name = \"PlayStation 1/2 joypad\";\n\tsnprintf(pad->phys, sizeof(pad->phys), \"%s/input\", dev_name(&spi->dev));\n\tidev->id.bustype = BUS_SPI;\n\n\tidev->open = psxpad_spi_poll_open;\n\tidev->close = psxpad_spi_poll_close;\n\n\t \n\tinput_set_abs_params(idev, ABS_X, 0, 255, 0, 0);\n\tinput_set_abs_params(idev, ABS_Y, 0, 255, 0, 0);\n\tinput_set_abs_params(idev, ABS_RX, 0, 255, 0, 0);\n\tinput_set_abs_params(idev, ABS_RY, 0, 255, 0, 0);\n\tinput_set_capability(idev, EV_KEY, BTN_DPAD_UP);\n\tinput_set_capability(idev, EV_KEY, BTN_DPAD_DOWN);\n\tinput_set_capability(idev, EV_KEY, BTN_DPAD_LEFT);\n\tinput_set_capability(idev, EV_KEY, BTN_DPAD_RIGHT);\n\tinput_set_capability(idev, EV_KEY, BTN_A);\n\tinput_set_capability(idev, EV_KEY, BTN_B);\n\tinput_set_capability(idev, EV_KEY, BTN_X);\n\tinput_set_capability(idev, EV_KEY, BTN_Y);\n\tinput_set_capability(idev, EV_KEY, BTN_TL);\n\tinput_set_capability(idev, EV_KEY, BTN_TR);\n\tinput_set_capability(idev, EV_KEY, BTN_TL2);\n\tinput_set_capability(idev, EV_KEY, BTN_TR2);\n\tinput_set_capability(idev, EV_KEY, BTN_THUMBL);\n\tinput_set_capability(idev, EV_KEY, BTN_THUMBR);\n\tinput_set_capability(idev, EV_KEY, BTN_SELECT);\n\tinput_set_capability(idev, EV_KEY, BTN_START);\n\n\terr = psxpad_spi_init_ff(pad);\n\tif (err)\n\t\treturn err;\n\n\t \n\tspi->mode = SPI_MODE_3;\n\tspi->bits_per_word = 8;\n\t \n\tspi->master->min_speed_hz = 125000;\n\tspi->master->max_speed_hz = 125000;\n\tspi_setup(spi);\n\n\t \n\tpsxpad_set_motor_level(pad, 0, 0);\n\n\n\terr = input_setup_polling(idev, psxpad_spi_poll);\n\tif (err) {\n\t\tdev_err(&spi->dev, \"failed to set up polling: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tinput_set_poll_interval(idev, 16);\n\tinput_set_min_poll_interval(idev, 8);\n\tinput_set_max_poll_interval(idev, 32);\n\n\t \n\terr = input_register_device(idev);\n\tif (err) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"failed to register input device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(&spi->dev);\n\n\treturn 0;\n}\n\nstatic int psxpad_spi_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct psxpad *pad = spi_get_drvdata(spi);\n\n\tpsxpad_set_motor_level(pad, 0, 0);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(psxpad_spi_pm, psxpad_spi_suspend, NULL);\n\nstatic const struct spi_device_id psxpad_spi_id[] = {\n\t{ \"psxpad-spi\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, psxpad_spi_id);\n\nstatic struct spi_driver psxpad_spi_driver = {\n\t.driver = {\n\t\t.name = \"psxpad-spi\",\n\t\t.pm = pm_sleep_ptr(&psxpad_spi_pm),\n\t},\n\t.id_table = psxpad_spi_id,\n\t.probe   = psxpad_spi_probe,\n};\n\nmodule_spi_driver(psxpad_spi_driver);\n\nMODULE_AUTHOR(\"Tomohiro Yoshidomi <sylph23k@gmail.com>\");\nMODULE_DESCRIPTION(\"PlayStation 1/2 joypads via SPI interface Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}