{
  "module_name": "pxrc.c",
  "hash_id": "0909db914a53be6e30098a61288ac7f84f2b1228cf870b72f6d41b047fa657a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/pxrc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/input.h>\n#include <linux/mutex.h>\n#include <linux/input.h>\n\n#define PXRC_VENDOR_ID\t\t0x1781\n#define PXRC_PRODUCT_ID\t\t0x0898\n\nstruct pxrc {\n\tstruct input_dev\t*input;\n\tstruct usb_interface\t*intf;\n\tstruct urb\t\t*urb;\n\tstruct mutex\t\tpm_mutex;\n\tbool\t\t\tis_open;\n\tchar\t\t\tphys[64];\n};\n\nstatic void pxrc_usb_irq(struct urb *urb)\n{\n\tstruct pxrc *pxrc = urb->context;\n\tu8 *data = urb->transfer_buffer;\n\tint error;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ETIME:\n\t\t \n\t\tdev_dbg(&pxrc->intf->dev,\n\t\t\t\"%s - urb timed out - was the device unplugged?\\n\",\n\t\t\t__func__);\n\t\treturn;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EPIPE:\n\t\t \n\t\tdev_dbg(&pxrc->intf->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&pxrc->intf->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\tif (urb->actual_length == 8) {\n\t\tinput_report_abs(pxrc->input, ABS_X, data[0]);\n\t\tinput_report_abs(pxrc->input, ABS_Y, data[2]);\n\t\tinput_report_abs(pxrc->input, ABS_RX, data[3]);\n\t\tinput_report_abs(pxrc->input, ABS_RY, data[4]);\n\t\tinput_report_abs(pxrc->input, ABS_RUDDER, data[5]);\n\t\tinput_report_abs(pxrc->input, ABS_THROTTLE, data[6]);\n\t\tinput_report_abs(pxrc->input, ABS_MISC, data[7]);\n\n\t\tinput_report_key(pxrc->input, BTN_A, data[1]);\n\t}\n\nexit:\n\t \n\terror = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (error && error != -EPERM)\n\t\tdev_err(&pxrc->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result: %d\",\n\t\t\t__func__, error);\n}\n\nstatic int pxrc_open(struct input_dev *input)\n{\n\tstruct pxrc *pxrc = input_get_drvdata(input);\n\tint retval;\n\n\tmutex_lock(&pxrc->pm_mutex);\n\tretval = usb_submit_urb(pxrc->urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&pxrc->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed, error: %d\\n\",\n\t\t\t__func__, retval);\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tpxrc->is_open = true;\n\nout:\n\tmutex_unlock(&pxrc->pm_mutex);\n\treturn retval;\n}\n\nstatic void pxrc_close(struct input_dev *input)\n{\n\tstruct pxrc *pxrc = input_get_drvdata(input);\n\n\tmutex_lock(&pxrc->pm_mutex);\n\tusb_kill_urb(pxrc->urb);\n\tpxrc->is_open = false;\n\tmutex_unlock(&pxrc->pm_mutex);\n}\n\nstatic void pxrc_free_urb(void *_pxrc)\n{\n\tstruct pxrc *pxrc = _pxrc;\n\n\tusb_free_urb(pxrc->urb);\n}\n\nstatic int pxrc_probe(struct usb_interface *intf,\n\t\t      const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct pxrc *pxrc;\n\tstruct usb_endpoint_descriptor *epirq;\n\tsize_t xfer_size;\n\tvoid *xfer_buf;\n\tint error;\n\n\t \n\terror = usb_find_common_endpoints(intf->cur_altsetting,\n\t\t\t\t\t  NULL, NULL, &epirq, NULL);\n\tif (error) {\n\t\tdev_err(&intf->dev, \"Could not find endpoint\\n\");\n\t\treturn error;\n\t}\n\n\tpxrc = devm_kzalloc(&intf->dev, sizeof(*pxrc), GFP_KERNEL);\n\tif (!pxrc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&pxrc->pm_mutex);\n\tpxrc->intf = intf;\n\n\tusb_set_intfdata(pxrc->intf, pxrc);\n\n\txfer_size = usb_endpoint_maxp(epirq);\n\txfer_buf = devm_kmalloc(&intf->dev, xfer_size, GFP_KERNEL);\n\tif (!xfer_buf)\n\t\treturn -ENOMEM;\n\n\tpxrc->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pxrc->urb)\n\t\treturn -ENOMEM;\n\n\terror = devm_add_action_or_reset(&intf->dev, pxrc_free_urb, pxrc);\n\tif (error)\n\t\treturn error;\n\n\tusb_fill_int_urb(pxrc->urb, udev,\n\t\t\t usb_rcvintpipe(udev, epirq->bEndpointAddress),\n\t\t\t xfer_buf, xfer_size, pxrc_usb_irq, pxrc, 1);\n\n\tpxrc->input = devm_input_allocate_device(&intf->dev);\n\tif (!pxrc->input) {\n\t\tdev_err(&intf->dev, \"couldn't allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpxrc->input->name = \"PXRC Flight Controller Adapter\";\n\n\tusb_make_path(udev, pxrc->phys, sizeof(pxrc->phys));\n\tstrlcat(pxrc->phys, \"/input0\", sizeof(pxrc->phys));\n\tpxrc->input->phys = pxrc->phys;\n\n\tusb_to_input_id(udev, &pxrc->input->id);\n\n\tpxrc->input->open = pxrc_open;\n\tpxrc->input->close = pxrc_close;\n\n\tinput_set_capability(pxrc->input, EV_KEY, BTN_A);\n\tinput_set_abs_params(pxrc->input, ABS_X, 0, 255, 0, 0);\n\tinput_set_abs_params(pxrc->input, ABS_Y, 0, 255, 0, 0);\n\tinput_set_abs_params(pxrc->input, ABS_RX, 0, 255, 0, 0);\n\tinput_set_abs_params(pxrc->input, ABS_RY, 0, 255, 0, 0);\n\tinput_set_abs_params(pxrc->input, ABS_RUDDER, 0, 255, 0, 0);\n\tinput_set_abs_params(pxrc->input, ABS_THROTTLE, 0, 255, 0, 0);\n\tinput_set_abs_params(pxrc->input, ABS_MISC, 0, 255, 0, 0);\n\n\tinput_set_drvdata(pxrc->input, pxrc);\n\n\terror = input_register_device(pxrc->input);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic void pxrc_disconnect(struct usb_interface *intf)\n{\n\t \n}\n\nstatic int pxrc_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct pxrc *pxrc = usb_get_intfdata(intf);\n\n\tmutex_lock(&pxrc->pm_mutex);\n\tif (pxrc->is_open)\n\t\tusb_kill_urb(pxrc->urb);\n\tmutex_unlock(&pxrc->pm_mutex);\n\n\treturn 0;\n}\n\nstatic int pxrc_resume(struct usb_interface *intf)\n{\n\tstruct pxrc *pxrc = usb_get_intfdata(intf);\n\tint retval = 0;\n\n\tmutex_lock(&pxrc->pm_mutex);\n\tif (pxrc->is_open && usb_submit_urb(pxrc->urb, GFP_KERNEL) < 0)\n\t\tretval = -EIO;\n\n\tmutex_unlock(&pxrc->pm_mutex);\n\treturn retval;\n}\n\nstatic int pxrc_pre_reset(struct usb_interface *intf)\n{\n\tstruct pxrc *pxrc = usb_get_intfdata(intf);\n\n\tmutex_lock(&pxrc->pm_mutex);\n\tusb_kill_urb(pxrc->urb);\n\treturn 0;\n}\n\nstatic int pxrc_post_reset(struct usb_interface *intf)\n{\n\tstruct pxrc *pxrc = usb_get_intfdata(intf);\n\tint retval = 0;\n\n\tif (pxrc->is_open && usb_submit_urb(pxrc->urb, GFP_KERNEL) < 0)\n\t\tretval = -EIO;\n\n\tmutex_unlock(&pxrc->pm_mutex);\n\n\treturn retval;\n}\n\nstatic int pxrc_reset_resume(struct usb_interface *intf)\n{\n\treturn pxrc_resume(intf);\n}\n\nstatic const struct usb_device_id pxrc_table[] = {\n\t{ USB_DEVICE(PXRC_VENDOR_ID, PXRC_PRODUCT_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, pxrc_table);\n\nstatic struct usb_driver pxrc_driver = {\n\t.name =\t\t\"pxrc\",\n\t.probe =\tpxrc_probe,\n\t.disconnect =\tpxrc_disconnect,\n\t.id_table =\tpxrc_table,\n\t.suspend\t= pxrc_suspend,\n\t.resume\t\t= pxrc_resume,\n\t.pre_reset\t= pxrc_pre_reset,\n\t.post_reset\t= pxrc_post_reset,\n\t.reset_resume\t= pxrc_reset_resume,\n};\n\nmodule_usb_driver(pxrc_driver);\n\nMODULE_AUTHOR(\"Marcus Folkesson <marcus.folkesson@gmail.com>\");\nMODULE_DESCRIPTION(\"PhoenixRC Flight Controller Adapter\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}