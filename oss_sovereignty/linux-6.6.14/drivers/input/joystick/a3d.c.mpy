{
  "module_name": "a3d.c",
  "hash_id": "c392525edec3b48ccf855018e6419db64a5038fc92714ccbe91aa86ba0b59e8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/a3d.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"FP-Gaming Assassin 3D joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define A3D_MAX_START\t\t600\t \n#define A3D_MAX_STROBE\t\t80\t \n#define A3D_MAX_LENGTH\t\t40\t \n\n#define A3D_MODE_A3D\t\t1\t \n#define A3D_MODE_PAN\t\t2\t \n#define A3D_MODE_OEM\t\t3\t \n#define A3D_MODE_PXL\t\t4\t \n\nstatic char *a3d_names[] = { NULL, \"FP-Gaming Assassin 3D\", \"MadCatz Panther\", \"OEM Panther\",\n\t\t\t\"MadCatz Panther XL\", \"MadCatz Panther XL w/ rudder\" };\n\nstruct a3d {\n\tstruct gameport *gameport;\n\tstruct gameport *adc;\n\tstruct input_dev *dev;\n\tint axes[4];\n\tint buttons;\n\tint mode;\n\tint length;\n\tint reads;\n\tint bads;\n\tchar phys[32];\n};\n\n \n\nstatic int a3d_read_packet(struct gameport *gameport, int length, char *data)\n{\n\tunsigned long flags;\n\tunsigned char u, v;\n\tunsigned int t, s;\n\tint i;\n\n\ti = 0;\n\tt = gameport_time(gameport, A3D_MAX_START);\n\ts = gameport_time(gameport, A3D_MAX_STROBE);\n\n\tlocal_irq_save(flags);\n\tgameport_trigger(gameport);\n\tv = gameport_read(gameport);\n\n\twhile (t > 0 && i < length) {\n\t\tt--;\n\t\tu = v; v = gameport_read(gameport);\n\t\tif (~v & u & 0x10) {\n\t\t\tdata[i++] = v >> 5;\n\t\t\tt = s;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\treturn i;\n}\n\n \n\nstatic int a3d_csum(char *data, int count)\n{\n\tint i, csum = 0;\n\n\tfor (i = 0; i < count - 2; i++)\n\t\tcsum += data[i];\n\treturn (csum & 0x3f) != ((data[count - 2] << 3) | data[count - 1]);\n}\n\nstatic void a3d_read(struct a3d *a3d, unsigned char *data)\n{\n\tstruct input_dev *dev = a3d->dev;\n\n\tswitch (a3d->mode) {\n\n\t\tcase A3D_MODE_A3D:\n\t\tcase A3D_MODE_OEM:\n\t\tcase A3D_MODE_PAN:\n\n\t\t\tinput_report_rel(dev, REL_X, ((data[5] << 6) | (data[6] << 3) | data[ 7]) - ((data[5] & 4) << 7));\n\t\t\tinput_report_rel(dev, REL_Y, ((data[8] << 6) | (data[9] << 3) | data[10]) - ((data[8] & 4) << 7));\n\n\t\t\tinput_report_key(dev, BTN_RIGHT,  data[2] & 1);\n\t\t\tinput_report_key(dev, BTN_LEFT,   data[3] & 2);\n\t\t\tinput_report_key(dev, BTN_MIDDLE, data[3] & 4);\n\n\t\t\tinput_sync(dev);\n\n\t\t\ta3d->axes[0] = ((signed char)((data[11] << 6) | (data[12] << 3) | (data[13]))) + 128;\n\t\t\ta3d->axes[1] = ((signed char)((data[14] << 6) | (data[15] << 3) | (data[16]))) + 128;\n\t\t\ta3d->axes[2] = ((signed char)((data[17] << 6) | (data[18] << 3) | (data[19]))) + 128;\n\t\t\ta3d->axes[3] = ((signed char)((data[20] << 6) | (data[21] << 3) | (data[22]))) + 128;\n\n\t\t\ta3d->buttons = ((data[3] << 3) | data[4]) & 0xf;\n\n\t\t\tbreak;\n\n\t\tcase A3D_MODE_PXL:\n\n\t\t\tinput_report_rel(dev, REL_X, ((data[ 9] << 6) | (data[10] << 3) | data[11]) - ((data[ 9] & 4) << 7));\n\t\t\tinput_report_rel(dev, REL_Y, ((data[12] << 6) | (data[13] << 3) | data[14]) - ((data[12] & 4) << 7));\n\n\t\t\tinput_report_key(dev, BTN_RIGHT,  data[2] & 1);\n\t\t\tinput_report_key(dev, BTN_LEFT,   data[3] & 2);\n\t\t\tinput_report_key(dev, BTN_MIDDLE, data[3] & 4);\n\t\t\tinput_report_key(dev, BTN_SIDE,   data[7] & 2);\n\t\t\tinput_report_key(dev, BTN_EXTRA,  data[7] & 4);\n\n\t\t\tinput_report_abs(dev, ABS_X,        ((signed char)((data[15] << 6) | (data[16] << 3) | (data[17]))) + 128);\n\t\t\tinput_report_abs(dev, ABS_Y,        ((signed char)((data[18] << 6) | (data[19] << 3) | (data[20]))) + 128);\n\t\t\tinput_report_abs(dev, ABS_RUDDER,   ((signed char)((data[21] << 6) | (data[22] << 3) | (data[23]))) + 128);\n\t\t\tinput_report_abs(dev, ABS_THROTTLE, ((signed char)((data[24] << 6) | (data[25] << 3) | (data[26]))) + 128);\n\n\t\t\tinput_report_abs(dev, ABS_HAT0X, ( data[5]       & 1) - ((data[5] >> 2) & 1));\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, ((data[5] >> 1) & 1) - ((data[6] >> 2) & 1));\n\t\t\tinput_report_abs(dev, ABS_HAT1X, ((data[4] >> 1) & 1) - ( data[3]       & 1));\n\t\t\tinput_report_abs(dev, ABS_HAT1Y, ((data[4] >> 2) & 1) - ( data[4]       & 1));\n\n\t\t\tinput_report_key(dev, BTN_TRIGGER, data[8] & 1);\n\t\t\tinput_report_key(dev, BTN_THUMB,   data[8] & 2);\n\t\t\tinput_report_key(dev, BTN_TOP,     data[8] & 4);\n\t\t\tinput_report_key(dev, BTN_PINKIE,  data[7] & 1);\n\n\t\t\tinput_sync(dev);\n\n\t\t\tbreak;\n\t}\n}\n\n\n \n\nstatic void a3d_poll(struct gameport *gameport)\n{\n\tstruct a3d *a3d = gameport_get_drvdata(gameport);\n\tunsigned char data[A3D_MAX_LENGTH];\n\n\ta3d->reads++;\n\tif (a3d_read_packet(a3d->gameport, a3d->length, data) != a3d->length ||\n\t    data[0] != a3d->mode || a3d_csum(data, a3d->length))\n\t\ta3d->bads++;\n\telse\n\t\ta3d_read(a3d, data);\n}\n\n \n\nstatic int a3d_adc_cooked_read(struct gameport *gameport, int *axes, int *buttons)\n{\n\tstruct a3d *a3d = gameport->port_data;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\taxes[i] = (a3d->axes[i] < 254) ? a3d->axes[i] : -1;\n\t*buttons = a3d->buttons;\n\treturn 0;\n}\n\n \n\nstatic int a3d_adc_open(struct gameport *gameport, int mode)\n{\n\tstruct a3d *a3d = gameport->port_data;\n\n\tif (mode != GAMEPORT_MODE_COOKED)\n\t\treturn -1;\n\n\tgameport_start_polling(a3d->gameport);\n\treturn 0;\n}\n\n \n\nstatic void a3d_adc_close(struct gameport *gameport)\n{\n\tstruct a3d *a3d = gameport->port_data;\n\n\tgameport_stop_polling(a3d->gameport);\n}\n\n \n\nstatic int a3d_open(struct input_dev *dev)\n{\n\tstruct a3d *a3d = input_get_drvdata(dev);\n\n\tgameport_start_polling(a3d->gameport);\n\treturn 0;\n}\n\n \n\nstatic void a3d_close(struct input_dev *dev)\n{\n\tstruct a3d *a3d = input_get_drvdata(dev);\n\n\tgameport_stop_polling(a3d->gameport);\n}\n\n \n\nstatic int a3d_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct a3d *a3d;\n\tstruct input_dev *input_dev;\n\tstruct gameport *adc;\n\tunsigned char data[A3D_MAX_LENGTH];\n\tint i;\n\tint err;\n\n\ta3d = kzalloc(sizeof(struct a3d), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!a3d || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\ta3d->dev = input_dev;\n\ta3d->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, a3d);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\ti = a3d_read_packet(gameport, A3D_MAX_LENGTH, data);\n\n\tif (!i || a3d_csum(data, i)) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\ta3d->mode = data[0];\n\n\tif (!a3d->mode || a3d->mode > 5) {\n\t\tprintk(KERN_WARNING \"a3d.c: Unknown A3D device detected \"\n\t\t\t\"(%s, id=%d), contact <vojtech@ucw.cz>\\n\", gameport->phys, a3d->mode);\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, a3d_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tsnprintf(a3d->phys, sizeof(a3d->phys), \"%s/input0\", gameport->phys);\n\n\tinput_dev->name = a3d_names[a3d->mode];\n\tinput_dev->phys = a3d->phys;\n\tinput_dev->id.bustype = BUS_GAMEPORT;\n\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_MADCATZ;\n\tinput_dev->id.product = a3d->mode;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &gameport->dev;\n\tinput_dev->open = a3d_open;\n\tinput_dev->close = a3d_close;\n\n\tinput_set_drvdata(input_dev, a3d);\n\n\tif (a3d->mode == A3D_MODE_PXL) {\n\n\t\tint axes[] = { ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER };\n\n\t\ta3d->length = 33;\n\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY) |\n\t\t\tBIT_MASK(EV_REL);\n\t\tinput_dev->relbit[0] |= BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\t\tinput_dev->absbit[0] |= BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |\n\t\t\tBIT_MASK(ABS_THROTTLE) | BIT_MASK(ABS_RUDDER) |\n\t\t\tBIT_MASK(ABS_HAT0X) | BIT_MASK(ABS_HAT0Y) |\n\t\t\tBIT_MASK(ABS_HAT1X) | BIT_MASK(ABS_HAT1Y);\n\t\tinput_dev->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_RIGHT) |\n\t\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) |\n\t\t\tBIT_MASK(BTN_SIDE) | BIT_MASK(BTN_EXTRA);\n\t\tinput_dev->keybit[BIT_WORD(BTN_JOYSTICK)] |=\n\t\t\tBIT_MASK(BTN_TRIGGER) | BIT_MASK(BTN_THUMB) |\n\t\t\tBIT_MASK(BTN_TOP) | BIT_MASK(BTN_PINKIE);\n\n\t\ta3d_read(a3d, data);\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (i < 2)\n\t\t\t\tinput_set_abs_params(input_dev, axes[i],\n\t\t\t\t\t48, input_abs_get_val(input_dev, axes[i]) * 2 - 48, 0, 8);\n\t\t\telse\n\t\t\t\tinput_set_abs_params(input_dev, axes[i], 2, 253, 0, 0);\n\t\t\tinput_set_abs_params(input_dev, ABS_HAT0X + i, -1, 1, 0, 0);\n\t\t}\n\n\t} else {\n\t\ta3d->length = 29;\n\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\t\tinput_dev->relbit[0] |= BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n\t\tinput_dev->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_RIGHT) |\n\t\t\tBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE);\n\n\t\ta3d_read(a3d, data);\n\n\t\tif (!(a3d->adc = adc = gameport_allocate_port()))\n\t\t\tprintk(KERN_ERR \"a3d: Not enough memory for ADC port\\n\");\n\t\telse {\n\t\t\tadc->port_data = a3d;\n\t\t\tadc->open = a3d_adc_open;\n\t\t\tadc->close = a3d_adc_close;\n\t\t\tadc->cooked_read = a3d_adc_cooked_read;\n\t\t\tadc->fuzz = 1;\n\n\t\t\tgameport_set_name(adc, a3d_names[a3d->mode]);\n\t\t\tgameport_set_phys(adc, \"%s/gameport0\", gameport->phys);\n\t\t\tadc->dev.parent = &gameport->dev;\n\n\t\t\tgameport_register_port(adc);\n\t\t}\n\t}\n\n\terr = input_register_device(a3d->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tif (a3d->adc)\n\t\tgameport_unregister_port(a3d->adc);\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tinput_free_device(input_dev);\n\tkfree(a3d);\n\treturn err;\n}\n\nstatic void a3d_disconnect(struct gameport *gameport)\n{\n\tstruct a3d *a3d = gameport_get_drvdata(gameport);\n\n\tinput_unregister_device(a3d->dev);\n\tif (a3d->adc)\n\t\tgameport_unregister_port(a3d->adc);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(a3d);\n}\n\nstatic struct gameport_driver a3d_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"adc\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= a3d_connect,\n\t.disconnect\t= a3d_disconnect,\n};\n\nmodule_gameport_driver(a3d_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}