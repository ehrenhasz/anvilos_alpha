{
  "module_name": "grip.c",
  "hash_id": "0144d39bfe5a52195a8753710ed5037a1eea76ef82c3760919930fe7977952b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/grip.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/gameport.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n\n#define DRIVER_DESC\t\"Gravis GrIP protocol joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define GRIP_MODE_GPP\t\t1\n#define GRIP_MODE_BD\t\t2\n#define GRIP_MODE_XT\t\t3\n#define GRIP_MODE_DC\t\t4\n\n#define GRIP_LENGTH_GPP\t\t24\n#define GRIP_STROBE_GPP\t\t200\t \n#define GRIP_LENGTH_XT\t\t4\n#define GRIP_STROBE_XT\t\t64\t \n#define GRIP_MAX_CHUNKS_XT\t10\n#define GRIP_MAX_BITS_XT\t30\n\nstruct grip {\n\tstruct gameport *gameport;\n\tstruct input_dev *dev[2];\n\tunsigned char mode[2];\n\tint reads;\n\tint bads;\n\tchar phys[2][32];\n};\n\nstatic int grip_btn_gpp[] = { BTN_START, BTN_SELECT, BTN_TR2, BTN_Y, 0, BTN_TL2, BTN_A, BTN_B, BTN_X, 0, BTN_TL, BTN_TR, -1 };\nstatic int grip_btn_bd[] = { BTN_THUMB, BTN_THUMB2, BTN_TRIGGER, BTN_TOP, BTN_BASE, -1 };\nstatic int grip_btn_xt[] = { BTN_TRIGGER, BTN_THUMB, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, BTN_SELECT, BTN_START, BTN_MODE, -1 };\nstatic int grip_btn_dc[] = { BTN_TRIGGER, BTN_THUMB, BTN_TOP, BTN_TOP2, BTN_BASE, BTN_BASE2, BTN_BASE3, BTN_BASE4, BTN_BASE5, -1 };\n\nstatic int grip_abs_gpp[] = { ABS_X, ABS_Y, -1 };\nstatic int grip_abs_bd[] = { ABS_X, ABS_Y, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, -1 };\nstatic int grip_abs_xt[] = { ABS_X, ABS_Y, ABS_BRAKE, ABS_GAS, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, ABS_HAT1X, ABS_HAT1Y, -1 };\nstatic int grip_abs_dc[] = { ABS_X, ABS_Y, ABS_RX, ABS_RY, ABS_THROTTLE, ABS_HAT0X, ABS_HAT0Y, -1 };\n\nstatic char *grip_name[] = { NULL, \"Gravis GamePad Pro\", \"Gravis Blackhawk Digital\",\n\t\t\t\t\"Gravis Xterminator Digital\", \"Gravis Xterminator DualControl\" };\nstatic int *grip_abs[] = { NULL, grip_abs_gpp, grip_abs_bd, grip_abs_xt, grip_abs_dc };\nstatic int *grip_btn[] = { NULL, grip_btn_gpp, grip_btn_bd, grip_btn_xt, grip_btn_dc };\nstatic char grip_anx[] = { 0, 0, 3, 5, 5 };\nstatic char grip_cen[] = { 0, 0, 2, 2, 4 };\n\n \n\nstatic int grip_gpp_read_packet(struct gameport *gameport, int shift, unsigned int *data)\n{\n\tunsigned long flags;\n\tunsigned char u, v;\n\tunsigned int t;\n\tint i;\n\n\tint strobe = gameport_time(gameport, GRIP_STROBE_GPP);\n\n\tdata[0] = 0;\n\tt = strobe;\n\ti = 0;\n\n\tlocal_irq_save(flags);\n\n\tv = gameport_read(gameport) >> shift;\n\n\tdo {\n\t\tt--;\n\t\tu = v; v = (gameport_read(gameport) >> shift) & 3;\n\t\tif (~v & u & 1) {\n\t\t\tdata[0] |= (v >> 1) << i++;\n\t\t\tt = strobe;\n\t\t}\n\t} while (i < GRIP_LENGTH_GPP && t > 0);\n\n\tlocal_irq_restore(flags);\n\n\tif (i < GRIP_LENGTH_GPP) return -1;\n\n\tfor (i = 0; i < GRIP_LENGTH_GPP && (data[0] & 0xfe4210) ^ 0x7c0000; i++)\n\t\tdata[0] = data[0] >> 1 | (data[0] & 1) << (GRIP_LENGTH_GPP - 1);\n\n\treturn -(i == GRIP_LENGTH_GPP);\n}\n\n \n\nstatic int grip_xt_read_packet(struct gameport *gameport, int shift, unsigned int *data)\n{\n\tunsigned int i, j, buf, crc;\n\tunsigned char u, v, w;\n\tunsigned long flags;\n\tunsigned int t;\n\tchar status;\n\n\tint strobe = gameport_time(gameport, GRIP_STROBE_XT);\n\n\tdata[0] = data[1] = data[2] = data[3] = 0;\n\tstatus = buf = i = j = 0;\n\tt = strobe;\n\n\tlocal_irq_save(flags);\n\n\tv = w = (gameport_read(gameport) >> shift) & 3;\n\n\tdo {\n\t\tt--;\n\t\tu = (gameport_read(gameport) >> shift) & 3;\n\n\t\tif (u ^ v) {\n\n\t\t\tif ((u ^ v) & 1) {\n\t\t\t\tbuf = (buf << 1) | (u >> 1);\n\t\t\t\tt = strobe;\n\t\t\t\ti++;\n\t\t\t} else\n\n\t\t\tif ((((u ^ v) & (v ^ w)) >> 1) & ~(u | v | w) & 1) {\n\t\t\t\tif (i == 20) {\n\t\t\t\t\tcrc = buf ^ (buf >> 7) ^ (buf >> 14);\n\t\t\t\t\tif (!((crc ^ (0x25cb9e70 >> ((crc >> 2) & 0x1c))) & 0xf)) {\n\t\t\t\t\t\tdata[buf >> 18] = buf >> 4;\n\t\t\t\t\t\tstatus |= 1 << (buf >> 18);\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tt = strobe;\n\t\t\t\tbuf = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tw = v;\n\t\t\tv = u;\n\t\t}\n\n\t} while (status != 0xf && i < GRIP_MAX_BITS_XT && j < GRIP_MAX_CHUNKS_XT && t > 0);\n\n\tlocal_irq_restore(flags);\n\n\treturn -(status != 0xf);\n}\n\n \n\nstatic void grip_poll(struct gameport *gameport)\n{\n\tstruct grip *grip = gameport_get_drvdata(gameport);\n\tunsigned int data[GRIP_LENGTH_XT];\n\tstruct input_dev *dev;\n\tint i, j;\n\n\tfor (i = 0; i < 2; i++) {\n\n\t\tdev = grip->dev[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tgrip->reads++;\n\n\t\tswitch (grip->mode[i]) {\n\n\t\t\tcase GRIP_MODE_GPP:\n\n\t\t\t\tif (grip_gpp_read_packet(grip->gameport, (i << 1) + 4, data)) {\n\t\t\t\t\tgrip->bads++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinput_report_abs(dev, ABS_X, ((*data >> 15) & 1) - ((*data >> 16) & 1));\n\t\t\t\tinput_report_abs(dev, ABS_Y, ((*data >> 13) & 1) - ((*data >> 12) & 1));\n\n\t\t\t\tfor (j = 0; j < 12; j++)\n\t\t\t\t\tif (grip_btn_gpp[j])\n\t\t\t\t\t\tinput_report_key(dev, grip_btn_gpp[j], (*data >> j) & 1);\n\n\t\t\t\tbreak;\n\n\t\t\tcase GRIP_MODE_BD:\n\n\t\t\t\tif (grip_xt_read_packet(grip->gameport, (i << 1) + 4, data)) {\n\t\t\t\t\tgrip->bads++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinput_report_abs(dev, ABS_X,        (data[0] >> 2) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_Y,  63 - ((data[0] >> 8) & 0x3f));\n\t\t\t\tinput_report_abs(dev, ABS_THROTTLE, (data[2] >> 8) & 0x3f);\n\n\t\t\t\tinput_report_abs(dev, ABS_HAT0X, ((data[2] >> 1) & 1) - ( data[2]       & 1));\n\t\t\t\tinput_report_abs(dev, ABS_HAT0Y, ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1));\n\n\t\t\t\tfor (j = 0; j < 5; j++)\n\t\t\t\t\tinput_report_key(dev, grip_btn_bd[j], (data[3] >> (j + 4)) & 1);\n\n\t\t\t\tbreak;\n\n\t\t\tcase GRIP_MODE_XT:\n\n\t\t\t\tif (grip_xt_read_packet(grip->gameport, (i << 1) + 4, data)) {\n\t\t\t\t\tgrip->bads++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinput_report_abs(dev, ABS_X,        (data[0] >> 2) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_Y,  63 - ((data[0] >> 8) & 0x3f));\n\t\t\t\tinput_report_abs(dev, ABS_BRAKE,    (data[1] >> 2) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_GAS,\t    (data[1] >> 8) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_THROTTLE, (data[2] >> 8) & 0x3f);\n\n\t\t\t\tinput_report_abs(dev, ABS_HAT0X, ((data[2] >> 1) & 1) - ( data[2]       & 1));\n\t\t\t\tinput_report_abs(dev, ABS_HAT0Y, ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1));\n\t\t\t\tinput_report_abs(dev, ABS_HAT1X, ((data[2] >> 5) & 1) - ((data[2] >> 4) & 1));\n\t\t\t\tinput_report_abs(dev, ABS_HAT1Y, ((data[2] >> 6) & 1) - ((data[2] >> 7) & 1));\n\n\t\t\t\tfor (j = 0; j < 11; j++)\n\t\t\t\t\tinput_report_key(dev, grip_btn_xt[j], (data[3] >> (j + 3)) & 1);\n\t\t\t\tbreak;\n\n\t\t\tcase GRIP_MODE_DC:\n\n\t\t\t\tif (grip_xt_read_packet(grip->gameport, (i << 1) + 4, data)) {\n\t\t\t\t\tgrip->bads++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinput_report_abs(dev, ABS_X,        (data[0] >> 2) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_Y,        (data[0] >> 8) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_RX,       (data[1] >> 2) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_RY,\t    (data[1] >> 8) & 0x3f);\n\t\t\t\tinput_report_abs(dev, ABS_THROTTLE, (data[2] >> 8) & 0x3f);\n\n\t\t\t\tinput_report_abs(dev, ABS_HAT0X, ((data[2] >> 1) & 1) - ( data[2]       & 1));\n\t\t\t\tinput_report_abs(dev, ABS_HAT0Y, ((data[2] >> 2) & 1) - ((data[2] >> 3) & 1));\n\n\t\t\t\tfor (j = 0; j < 9; j++)\n\t\t\t\t\tinput_report_key(dev, grip_btn_dc[j], (data[3] >> (j + 3)) & 1);\n\t\t\t\tbreak;\n\n\n\t\t}\n\n\t\tinput_sync(dev);\n\t}\n}\n\nstatic int grip_open(struct input_dev *dev)\n{\n\tstruct grip *grip = input_get_drvdata(dev);\n\n\tgameport_start_polling(grip->gameport);\n\treturn 0;\n}\n\nstatic void grip_close(struct input_dev *dev)\n{\n\tstruct grip *grip = input_get_drvdata(dev);\n\n\tgameport_stop_polling(grip->gameport);\n}\n\nstatic int grip_connect(struct gameport *gameport, struct gameport_driver *drv)\n{\n\tstruct grip *grip;\n\tstruct input_dev *input_dev;\n\tunsigned int data[GRIP_LENGTH_XT];\n\tint i, j, t;\n\tint err;\n\n\tif (!(grip = kzalloc(sizeof(struct grip), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tgrip->gameport = gameport;\n\n\tgameport_set_drvdata(gameport, grip);\n\n\terr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\n\tif (err)\n\t\tgoto fail1;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!grip_gpp_read_packet(gameport, (i << 1) + 4, data)) {\n\t\t\tgrip->mode[i] = GRIP_MODE_GPP;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!grip_xt_read_packet(gameport, (i << 1) + 4, data)) {\n\t\t\tif (!(data[3] & 7)) {\n\t\t\t\tgrip->mode[i] = GRIP_MODE_BD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(data[2] & 0xf0)) {\n\t\t\t\tgrip->mode[i] = GRIP_MODE_XT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgrip->mode[i] = GRIP_MODE_DC;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!grip->mode[0] && !grip->mode[1]) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tgameport_set_poll_handler(gameport, grip_poll);\n\tgameport_set_poll_interval(gameport, 20);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!grip->mode[i])\n\t\t\tcontinue;\n\n\t\tgrip->dev[i] = input_dev = input_allocate_device();\n\t\tif (!input_dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail3;\n\t\t}\n\n\t\tsnprintf(grip->phys[i], sizeof(grip->phys[i]),\n\t\t\t \"%s/input%d\", gameport->phys, i);\n\n\t\tinput_dev->name = grip_name[grip->mode[i]];\n\t\tinput_dev->phys = grip->phys[i];\n\t\tinput_dev->id.bustype = BUS_GAMEPORT;\n\t\tinput_dev->id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;\n\t\tinput_dev->id.product = grip->mode[i];\n\t\tinput_dev->id.version = 0x0100;\n\t\tinput_dev->dev.parent = &gameport->dev;\n\n\t\tinput_set_drvdata(input_dev, grip);\n\n\t\tinput_dev->open = grip_open;\n\t\tinput_dev->close = grip_close;\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\t\tfor (j = 0; (t = grip_abs[grip->mode[i]][j]) >= 0; j++) {\n\n\t\t\tif (j < grip_cen[grip->mode[i]])\n\t\t\t\tinput_set_abs_params(input_dev, t, 14, 52, 1, 2);\n\t\t\telse if (j < grip_anx[grip->mode[i]])\n\t\t\t\tinput_set_abs_params(input_dev, t, 3, 57, 1, 0);\n\t\t\telse\n\t\t\t\tinput_set_abs_params(input_dev, t, -1, 1, 0, 0);\n\t\t}\n\n\t\tfor (j = 0; (t = grip_btn[grip->mode[i]][j]) >= 0; j++)\n\t\t\tif (t > 0)\n\t\t\t\tset_bit(t, input_dev->keybit);\n\n\t\terr = input_register_device(grip->dev[i]);\n\t\tif (err)\n\t\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\tinput_free_device(grip->dev[i]);\n fail3:\twhile (--i >= 0)\n\t\tif (grip->dev[i])\n\t\t\tinput_unregister_device(grip->dev[i]);\n fail2:\tgameport_close(gameport);\n fail1:\tgameport_set_drvdata(gameport, NULL);\n\tkfree(grip);\n\treturn err;\n}\n\nstatic void grip_disconnect(struct gameport *gameport)\n{\n\tstruct grip *grip = gameport_get_drvdata(gameport);\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (grip->dev[i])\n\t\t\tinput_unregister_device(grip->dev[i]);\n\tgameport_close(gameport);\n\tgameport_set_drvdata(gameport, NULL);\n\tkfree(grip);\n}\n\nstatic struct gameport_driver grip_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"grip\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.description\t= DRIVER_DESC,\n\t.connect\t= grip_connect,\n\t.disconnect\t= grip_disconnect,\n};\n\nmodule_gameport_driver(grip_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}