{
  "module_name": "fsia6b.c",
  "hash_id": "d6efa70b040e0908101270aabc02ac3eef67d653aace7305c38228493783b460",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/fsia6b.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/serio.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define DRIVER_DESC\t\t\"FS-iA6B iBus RC receiver\"\n\nMODULE_AUTHOR(\"Markus Koch <markus@notsyncing.net>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define IBUS_SERVO_COUNT\t14\n\nstatic char *switch_config = \"00000022320000\";\nmodule_param(switch_config, charp, 0444);\nMODULE_PARM_DESC(switch_config,\n\t\t \"Amount of switch positions per channel (14 characters, 0-3)\");\n\nstatic int fsia6b_axes[IBUS_SERVO_COUNT] = {\n\tABS_X, ABS_Y,\n\tABS_Z, ABS_RX,\n\tABS_RY, ABS_RZ,\n\tABS_HAT0X, ABS_HAT0Y,\n\tABS_HAT1X, ABS_HAT1Y,\n\tABS_HAT2X, ABS_HAT2Y,\n\tABS_HAT3X, ABS_HAT3Y\n};\n\nenum ibus_state { SYNC, COLLECT, PROCESS };\n\nstruct ibus_packet {\n\tenum ibus_state state;\n\n\tint offset;\n\tu16 ibuf;\n\tu16 channel[IBUS_SERVO_COUNT];\n};\n\nstruct fsia6b {\n\tstruct input_dev *dev;\n\tstruct ibus_packet packet;\n\n\tchar phys[32];\n};\n\nstatic irqreturn_t fsia6b_serio_irq(struct serio *serio,\n\t\t\t\t    unsigned char data, unsigned int flags)\n{\n\tstruct fsia6b *fsia6b = serio_get_drvdata(serio);\n\tint i;\n\tint sw_state;\n\tint sw_id = BTN_0;\n\n\tfsia6b->packet.ibuf = (data << 8) | ((fsia6b->packet.ibuf >> 8) & 0xFF);\n\n\tswitch (fsia6b->packet.state) {\n\tcase SYNC:\n\t\tif (fsia6b->packet.ibuf == 0x4020)\n\t\t\tfsia6b->packet.state = COLLECT;\n\t\tbreak;\n\n\tcase COLLECT:\n\t\tfsia6b->packet.state = PROCESS;\n\t\tbreak;\n\n\tcase PROCESS:\n\t\tfsia6b->packet.channel[fsia6b->packet.offset] =\n\t\t\t\tfsia6b->packet.ibuf;\n\t\tfsia6b->packet.offset++;\n\n\t\tif (fsia6b->packet.offset == IBUS_SERVO_COUNT) {\n\t\t\tfsia6b->packet.offset = 0;\n\t\t\tfsia6b->packet.state = SYNC;\n\t\t\tfor (i = 0; i < IBUS_SERVO_COUNT; ++i) {\n\t\t\t\tinput_report_abs(fsia6b->dev, fsia6b_axes[i],\n\t\t\t\t\t\t fsia6b->packet.channel[i]);\n\n\t\t\t\tsw_state = 0;\n\t\t\t\tif (fsia6b->packet.channel[i] > 1900)\n\t\t\t\t\tsw_state = 1;\n\t\t\t\telse if (fsia6b->packet.channel[i] < 1100)\n\t\t\t\t\tsw_state = 2;\n\n\t\t\t\tswitch (switch_config[i]) {\n\t\t\t\tcase '3':\n\t\t\t\t\tinput_report_key(fsia6b->dev,\n\t\t\t\t\t\t\t sw_id++,\n\t\t\t\t\t\t\t sw_state == 0);\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase '2':\n\t\t\t\t\tinput_report_key(fsia6b->dev,\n\t\t\t\t\t\t\t sw_id++,\n\t\t\t\t\t\t\t sw_state == 1);\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase '1':\n\t\t\t\t\tinput_report_key(fsia6b->dev,\n\t\t\t\t\t\t\t sw_id++,\n\t\t\t\t\t\t\t sw_state == 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinput_sync(fsia6b->dev);\n\t\t} else {\n\t\t\tfsia6b->packet.state = COLLECT;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsia6b_serio_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct fsia6b *fsia6b;\n\tstruct input_dev *input_dev;\n\tint err;\n\tint i, j;\n\tint sw_id = 0;\n\n\tfsia6b = kzalloc(sizeof(*fsia6b), GFP_KERNEL);\n\tif (!fsia6b)\n\t\treturn -ENOMEM;\n\n\tfsia6b->packet.ibuf = 0;\n\tfsia6b->packet.offset = 0;\n\tfsia6b->packet.state = SYNC;\n\n\tserio_set_drvdata(serio, fsia6b);\n\n\tinput_dev = input_allocate_device();\n\tif (!input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\tfsia6b->dev = input_dev;\n\n\tsnprintf(fsia6b->phys, sizeof(fsia6b->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = DRIVER_DESC;\n\tinput_dev->phys = fsia6b->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_FSIA6B;\n\tinput_dev->id.product = serio->id.id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tfor (i = 0; i < IBUS_SERVO_COUNT; i++)\n\t\tinput_set_abs_params(input_dev, fsia6b_axes[i],\n\t\t\t\t     1000, 2000, 2, 2);\n\n\t \n\tfor (i = 0; i < IBUS_SERVO_COUNT; i++) {\n\t\tif (switch_config[i] < '0' || switch_config[i] > '3') {\n\t\t\tdev_err(&fsia6b->dev->dev,\n\t\t\t\t\"Invalid switch configuration supplied for fsia6b.\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tfor (j = '1'; j <= switch_config[i]; j++) {\n\t\t\tinput_set_capability(input_dev, EV_KEY, BTN_0 + sw_id);\n\t\t\tsw_id++;\n\t\t}\n\t}\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(fsia6b->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\nfail3:\tserio_close(serio);\nfail2:\tinput_free_device(input_dev);\nfail1:\tserio_set_drvdata(serio, NULL);\n\tkfree(fsia6b);\n\treturn err;\n}\n\nstatic void fsia6b_serio_disconnect(struct serio *serio)\n{\n\tstruct fsia6b *fsia6b = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(fsia6b->dev);\n\tkfree(fsia6b);\n}\n\nstatic const struct serio_device_id fsia6b_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_FSIA6B,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, fsia6b_serio_ids);\n\nstatic struct serio_driver fsia6b_serio_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"fsia6b\"\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= fsia6b_serio_ids,\n\t.interrupt\t= fsia6b_serio_irq,\n\t.connect\t= fsia6b_serio_connect,\n\t.disconnect\t= fsia6b_serio_disconnect\n};\n\nmodule_serio_driver(fsia6b_serio_drv)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}