{
  "module_name": "warrior.c",
  "hash_id": "3db1481155b7bfc5cba26320f8f27043d041f9392ce2f1e69bc506b9c0c1690d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/warrior.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n\n#define DRIVER_DESC\t\"Logitech WingMan Warrior joystick driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#define WARRIOR_MAX_LENGTH\t16\nstatic char warrior_lengths[] = { 0, 4, 12, 3, 4, 4, 0, 0 };\n\n \n\nstruct warrior {\n\tstruct input_dev *dev;\n\tint idx, len;\n\tunsigned char data[WARRIOR_MAX_LENGTH];\n\tchar phys[32];\n};\n\n \n\nstatic void warrior_process_packet(struct warrior *warrior)\n{\n\tstruct input_dev *dev = warrior->dev;\n\tunsigned char *data = warrior->data;\n\n\tif (!warrior->idx) return;\n\n\tswitch ((data[0] >> 4) & 7) {\n\t\tcase 1:\t\t\t\t\t \n\t\t\tinput_report_key(dev, BTN_TRIGGER,  data[3]       & 1);\n\t\t\tinput_report_key(dev, BTN_THUMB,   (data[3] >> 1) & 1);\n\t\t\tinput_report_key(dev, BTN_TOP,     (data[3] >> 2) & 1);\n\t\t\tinput_report_key(dev, BTN_TOP2,    (data[3] >> 3) & 1);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t\t\t \n\t\t\tinput_report_abs(dev, ABS_X, ((data[0] & 8) << 5) - (data[2] | ((data[0] & 4) << 5)));\n\t\t\tinput_report_abs(dev, ABS_Y, (data[1] | ((data[0] & 1) << 7)) - ((data[0] & 2) << 7));\n\t\t\tbreak;\n\t\tcase 5:\t\t\t\t\t \n\t\t\tinput_report_abs(dev, ABS_THROTTLE, (data[1] | ((data[0] & 1) << 7)) - ((data[0] & 2) << 7));\n\t\t\tinput_report_abs(dev, ABS_HAT0X, (data[3] & 2 ? 1 : 0) - (data[3] & 1 ? 1 : 0));\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, (data[3] & 8 ? 1 : 0) - (data[3] & 4 ? 1 : 0));\n\t\t\tinput_report_rel(dev, REL_DIAL,  (data[2] | ((data[0] & 4) << 5)) - ((data[0] & 8) << 5));\n\t\t\tbreak;\n\t}\n\tinput_sync(dev);\n}\n\n \n\nstatic irqreturn_t warrior_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct warrior *warrior = serio_get_drvdata(serio);\n\n\tif (data & 0x80) {\n\t\tif (warrior->idx) warrior_process_packet(warrior);\n\t\twarrior->idx = 0;\n\t\twarrior->len = warrior_lengths[(data >> 4) & 7];\n\t}\n\n\tif (warrior->idx < warrior->len)\n\t\twarrior->data[warrior->idx++] = data;\n\n\tif (warrior->idx == warrior->len) {\n\t\tif (warrior->idx) warrior_process_packet(warrior);\n\t\twarrior->idx = 0;\n\t\twarrior->len = 0;\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void warrior_disconnect(struct serio *serio)\n{\n\tstruct warrior *warrior = serio_get_drvdata(serio);\n\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_unregister_device(warrior->dev);\n\tkfree(warrior);\n}\n\n \n\nstatic int warrior_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct warrior *warrior;\n\tstruct input_dev *input_dev;\n\tint err = -ENOMEM;\n\n\twarrior = kzalloc(sizeof(struct warrior), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!warrior || !input_dev)\n\t\tgoto fail1;\n\n\twarrior->dev = input_dev;\n\tsnprintf(warrior->phys, sizeof(warrior->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"Logitech WingMan Warrior\";\n\tinput_dev->phys = warrior->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_WARRIOR;\n\tinput_dev->id.product = 0x0001;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |\n\t\tBIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TRIGGER)] = BIT_MASK(BTN_TRIGGER) |\n\t\tBIT_MASK(BTN_THUMB) | BIT_MASK(BTN_TOP) | BIT_MASK(BTN_TOP2);\n\tinput_dev->relbit[0] = BIT_MASK(REL_DIAL);\n\tinput_set_abs_params(input_dev, ABS_X, -64, 64, 0, 8);\n\tinput_set_abs_params(input_dev, ABS_Y, -64, 64, 0, 8);\n\tinput_set_abs_params(input_dev, ABS_THROTTLE, -112, 112, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_HAT0X, -1, 1, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_HAT0Y, -1, 1, 0, 0);\n\n\tserio_set_drvdata(serio, warrior);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\terr = input_register_device(warrior->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tserio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(warrior);\n\treturn err;\n}\n\n \n\nstatic const struct serio_device_id warrior_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_WARRIOR,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, warrior_serio_ids);\n\nstatic struct serio_driver warrior_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"warrior\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= warrior_serio_ids,\n\t.interrupt\t= warrior_interrupt,\n\t.connect\t= warrior_connect,\n\t.disconnect\t= warrior_disconnect,\n};\n\nmodule_serio_driver(warrior_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}