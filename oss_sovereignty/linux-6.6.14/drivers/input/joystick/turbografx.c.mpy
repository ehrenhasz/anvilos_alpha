{
  "module_name": "turbografx.c",
  "hash_id": "7dd48d3a297d903604d7d376eddf18d554cfaf98a036a4dfa8c58e08054ee658",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/joystick/turbografx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/parport.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(\"TurboGraFX parallel port interface driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define TGFX_MAX_PORTS\t\t3\n#define TGFX_MAX_DEVICES\t7\n\nstruct tgfx_config {\n\tint args[TGFX_MAX_DEVICES + 1];\n\tunsigned int nargs;\n};\n\nstatic struct tgfx_config tgfx_cfg[TGFX_MAX_PORTS];\n\nmodule_param_array_named(map, tgfx_cfg[0].args, int, &tgfx_cfg[0].nargs, 0);\nMODULE_PARM_DESC(map, \"Describes first set of devices (<parport#>,<js1>,<js2>,..<js7>\");\nmodule_param_array_named(map2, tgfx_cfg[1].args, int, &tgfx_cfg[1].nargs, 0);\nMODULE_PARM_DESC(map2, \"Describes second set of devices\");\nmodule_param_array_named(map3, tgfx_cfg[2].args, int, &tgfx_cfg[2].nargs, 0);\nMODULE_PARM_DESC(map3, \"Describes third set of devices\");\n\n#define TGFX_REFRESH_TIME\tHZ/100\t \n\n#define TGFX_TRIGGER\t\t0x08\n#define TGFX_UP\t\t\t0x10\n#define TGFX_DOWN\t\t0x20\n#define TGFX_LEFT\t\t0x40\n#define TGFX_RIGHT\t\t0x80\n\n#define TGFX_THUMB\t\t0x02\n#define TGFX_THUMB2\t\t0x04\n#define TGFX_TOP\t\t0x01\n#define TGFX_TOP2\t\t0x08\n\nstatic int tgfx_buttons[] = { BTN_TRIGGER, BTN_THUMB, BTN_THUMB2, BTN_TOP, BTN_TOP2 };\n\nstatic struct tgfx {\n\tstruct pardevice *pd;\n\tstruct timer_list timer;\n\tstruct input_dev *dev[TGFX_MAX_DEVICES];\n\tchar name[TGFX_MAX_DEVICES][64];\n\tchar phys[TGFX_MAX_DEVICES][32];\n\tint sticks;\n\tint used;\n\tint parportno;\n\tstruct mutex sem;\n} *tgfx_base[TGFX_MAX_PORTS];\n\n \n\nstatic void tgfx_timer(struct timer_list *t)\n{\n\tstruct tgfx *tgfx = from_timer(tgfx, t, timer);\n\tstruct input_dev *dev;\n\tint data1, data2, i;\n\n\tfor (i = 0; i < 7; i++)\n\t\tif (tgfx->sticks & (1 << i)) {\n\n\t\t\tdev = tgfx->dev[i];\n\n\t\t\tparport_write_data(tgfx->pd->port, ~(1 << i));\n\t\t\tdata1 = parport_read_status(tgfx->pd->port) ^ 0x7f;\n\t\t\tdata2 = parport_read_control(tgfx->pd->port) ^ 0x04;\t \n\n\t\t\tinput_report_abs(dev, ABS_X, !!(data1 & TGFX_RIGHT) - !!(data1 & TGFX_LEFT));\n\t\t\tinput_report_abs(dev, ABS_Y, !!(data1 & TGFX_DOWN ) - !!(data1 & TGFX_UP  ));\n\n\t\t\tinput_report_key(dev, BTN_TRIGGER, (data1 & TGFX_TRIGGER));\n\t\t\tinput_report_key(dev, BTN_THUMB,   (data2 & TGFX_THUMB  ));\n\t\t\tinput_report_key(dev, BTN_THUMB2,  (data2 & TGFX_THUMB2 ));\n\t\t\tinput_report_key(dev, BTN_TOP,     (data2 & TGFX_TOP    ));\n\t\t\tinput_report_key(dev, BTN_TOP2,    (data2 & TGFX_TOP2   ));\n\n\t\t\tinput_sync(dev);\n\t\t}\n\n\tmod_timer(&tgfx->timer, jiffies + TGFX_REFRESH_TIME);\n}\n\nstatic int tgfx_open(struct input_dev *dev)\n{\n\tstruct tgfx *tgfx = input_get_drvdata(dev);\n\tint err;\n\n\terr = mutex_lock_interruptible(&tgfx->sem);\n\tif (err)\n\t\treturn err;\n\n\tif (!tgfx->used++) {\n\t\tparport_claim(tgfx->pd);\n\t\tparport_write_control(tgfx->pd->port, 0x04);\n\t\tmod_timer(&tgfx->timer, jiffies + TGFX_REFRESH_TIME);\n\t}\n\n\tmutex_unlock(&tgfx->sem);\n\treturn 0;\n}\n\nstatic void tgfx_close(struct input_dev *dev)\n{\n\tstruct tgfx *tgfx = input_get_drvdata(dev);\n\n\tmutex_lock(&tgfx->sem);\n\tif (!--tgfx->used) {\n\t\tdel_timer_sync(&tgfx->timer);\n\t\tparport_write_control(tgfx->pd->port, 0x00);\n\t\tparport_release(tgfx->pd);\n\t}\n\tmutex_unlock(&tgfx->sem);\n}\n\n\n\n \n\nstatic void tgfx_attach(struct parport *pp)\n{\n\tstruct tgfx *tgfx;\n\tstruct input_dev *input_dev;\n\tstruct pardevice *pd;\n\tint i, j, port_idx;\n\tint *n_buttons, n_devs;\n\tstruct pardev_cb tgfx_parport_cb;\n\n\tfor (port_idx = 0; port_idx < TGFX_MAX_PORTS; port_idx++) {\n\t\tif (tgfx_cfg[port_idx].nargs == 0 ||\n\t\t    tgfx_cfg[port_idx].args[0] < 0)\n\t\t\tcontinue;\n\t\tif (tgfx_cfg[port_idx].args[0] == pp->number)\n\t\t\tbreak;\n\t}\n\n\tif (port_idx == TGFX_MAX_PORTS) {\n\t\tpr_debug(\"Not using parport%d.\\n\", pp->number);\n\t\treturn;\n\t}\n\tn_buttons = tgfx_cfg[port_idx].args + 1;\n\tn_devs = tgfx_cfg[port_idx].nargs - 1;\n\n\tmemset(&tgfx_parport_cb, 0, sizeof(tgfx_parport_cb));\n\ttgfx_parport_cb.flags = PARPORT_FLAG_EXCL;\n\n\tpd = parport_register_dev_model(pp, \"turbografx\", &tgfx_parport_cb,\n\t\t\t\t\tport_idx);\n\tif (!pd) {\n\t\tpr_err(\"parport busy already - lp.o loaded?\\n\");\n\t\treturn;\n\t}\n\n\ttgfx = kzalloc(sizeof(struct tgfx), GFP_KERNEL);\n\tif (!tgfx) {\n\t\tprintk(KERN_ERR \"turbografx.c: Not enough memory\\n\");\n\t\tgoto err_unreg_pardev;\n\t}\n\n\tmutex_init(&tgfx->sem);\n\ttgfx->pd = pd;\n\ttgfx->parportno = pp->number;\n\ttimer_setup(&tgfx->timer, tgfx_timer, 0);\n\n\tfor (i = 0; i < n_devs; i++) {\n\t\tif (n_buttons[i] < 1)\n\t\t\tcontinue;\n\n\t\tif (n_buttons[i] > ARRAY_SIZE(tgfx_buttons)) {\n\t\t\tprintk(KERN_ERR \"turbografx.c: Invalid number of buttons %d\\n\", n_buttons[i]);\n\t\t\tgoto err_unreg_devs;\n\t\t}\n\n\t\ttgfx->dev[i] = input_dev = input_allocate_device();\n\t\tif (!input_dev) {\n\t\t\tprintk(KERN_ERR \"turbografx.c: Not enough memory for input device\\n\");\n\t\t\tgoto err_unreg_devs;\n\t\t}\n\n\t\ttgfx->sticks |= (1 << i);\n\t\tsnprintf(tgfx->name[i], sizeof(tgfx->name[i]),\n\t\t\t \"TurboGraFX %d-button Multisystem joystick\", n_buttons[i]);\n\t\tsnprintf(tgfx->phys[i], sizeof(tgfx->phys[i]),\n\t\t\t \"%s/input%d\", tgfx->pd->port->name, i);\n\n\t\tinput_dev->name = tgfx->name[i];\n\t\tinput_dev->phys = tgfx->phys[i];\n\t\tinput_dev->id.bustype = BUS_PARPORT;\n\t\tinput_dev->id.vendor = 0x0003;\n\t\tinput_dev->id.product = n_buttons[i];\n\t\tinput_dev->id.version = 0x0100;\n\n\t\tinput_set_drvdata(input_dev, tgfx);\n\n\t\tinput_dev->open = tgfx_open;\n\t\tinput_dev->close = tgfx_close;\n\n\t\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t\tinput_set_abs_params(input_dev, ABS_X, -1, 1, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, -1, 1, 0, 0);\n\n\t\tfor (j = 0; j < n_buttons[i]; j++)\n\t\t\tset_bit(tgfx_buttons[j], input_dev->keybit);\n\n\t\tif (input_register_device(tgfx->dev[i]))\n\t\t\tgoto err_free_dev;\n\t}\n\n        if (!tgfx->sticks) {\n\t\tprintk(KERN_ERR \"turbografx.c: No valid devices specified\\n\");\n\t\tgoto err_free_tgfx;\n        }\n\n\ttgfx_base[port_idx] = tgfx;\n\treturn;\n\n err_free_dev:\n\tinput_free_device(tgfx->dev[i]);\n err_unreg_devs:\n\twhile (--i >= 0)\n\t\tif (tgfx->dev[i])\n\t\t\tinput_unregister_device(tgfx->dev[i]);\n err_free_tgfx:\n\tkfree(tgfx);\n err_unreg_pardev:\n\tparport_unregister_device(pd);\n}\n\nstatic void tgfx_detach(struct parport *port)\n{\n\tint i;\n\tstruct tgfx *tgfx;\n\n\tfor (i = 0; i < TGFX_MAX_PORTS; i++) {\n\t\tif (tgfx_base[i] && tgfx_base[i]->parportno == port->number)\n\t\t\tbreak;\n\t}\n\n\tif (i == TGFX_MAX_PORTS)\n\t\treturn;\n\n\ttgfx = tgfx_base[i];\n\ttgfx_base[i] = NULL;\n\n\tfor (i = 0; i < TGFX_MAX_DEVICES; i++)\n\t\tif (tgfx->dev[i])\n\t\t\tinput_unregister_device(tgfx->dev[i]);\n\tparport_unregister_device(tgfx->pd);\n\tkfree(tgfx);\n}\n\nstatic struct parport_driver tgfx_parport_driver = {\n\t.name = \"turbografx\",\n\t.match_port = tgfx_attach,\n\t.detach = tgfx_detach,\n\t.devmodel = true,\n};\n\nstatic int __init tgfx_init(void)\n{\n\tint i;\n\tint have_dev = 0;\n\n\tfor (i = 0; i < TGFX_MAX_PORTS; i++) {\n\t\tif (tgfx_cfg[i].nargs == 0 || tgfx_cfg[i].args[0] < 0)\n\t\t\tcontinue;\n\n\t\tif (tgfx_cfg[i].nargs < 2) {\n\t\t\tprintk(KERN_ERR \"turbografx.c: at least one joystick must be specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thave_dev = 1;\n\t}\n\n\tif (!have_dev)\n\t\treturn -ENODEV;\n\n\treturn parport_register_driver(&tgfx_parport_driver);\n}\n\nstatic void __exit tgfx_exit(void)\n{\n\tparport_unregister_driver(&tgfx_parport_driver);\n}\n\nmodule_init(tgfx_init);\nmodule_exit(tgfx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}