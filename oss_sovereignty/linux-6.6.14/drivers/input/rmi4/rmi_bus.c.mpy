{
  "module_name": "rmi_bus.c",
  "hash_id": "2e4d4ace2ac822d5c526acda9c9166a741aa9903b55eae74f3955d56c5c07cf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_bus.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/list.h>\n#include <linux/pm.h>\n#include <linux/rmi.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/of.h>\n#include \"rmi_bus.h\"\n#include \"rmi_driver.h\"\n\nstatic int debug_flags;\nmodule_param(debug_flags, int, 0644);\nMODULE_PARM_DESC(debug_flags, \"control debugging information\");\n\nvoid rmi_dbg(int flags, struct device *dev, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (flags & debug_flags) {\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tdev_printk(KERN_DEBUG, dev, \"%pV\", &vaf);\n\n\t\tva_end(args);\n\t}\n}\nEXPORT_SYMBOL_GPL(rmi_dbg);\n\n \n\nstatic void rmi_release_device(struct device *dev)\n{\n\tstruct rmi_device *rmi_dev = to_rmi_device(dev);\n\n\tkfree(rmi_dev);\n}\n\nstatic const struct device_type rmi_device_type = {\n\t.name\t\t= \"rmi4_sensor\",\n\t.release\t= rmi_release_device,\n};\n\nbool rmi_is_physical_device(struct device *dev)\n{\n\treturn dev->type == &rmi_device_type;\n}\n\n \nint rmi_register_transport_device(struct rmi_transport_dev *xport)\n{\n\tstatic atomic_t transport_device_count = ATOMIC_INIT(0);\n\tstruct rmi_device *rmi_dev;\n\tint error;\n\n\trmi_dev = kzalloc(sizeof(struct rmi_device), GFP_KERNEL);\n\tif (!rmi_dev)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(&rmi_dev->dev);\n\n\trmi_dev->xport = xport;\n\trmi_dev->number = atomic_inc_return(&transport_device_count) - 1;\n\n\tdev_set_name(&rmi_dev->dev, \"rmi4-%02d\", rmi_dev->number);\n\n\trmi_dev->dev.bus = &rmi_bus_type;\n\trmi_dev->dev.type = &rmi_device_type;\n\trmi_dev->dev.parent = xport->dev;\n\n\txport->rmi_dev = rmi_dev;\n\n\terror = device_add(&rmi_dev->dev);\n\tif (error)\n\t\tgoto err_put_device;\n\n\trmi_dbg(RMI_DEBUG_CORE, xport->dev,\n\t\t\"%s: Registered %s as %s.\\n\", __func__,\n\t\tdev_name(rmi_dev->xport->dev), dev_name(&rmi_dev->dev));\n\n\treturn 0;\n\nerr_put_device:\n\tput_device(&rmi_dev->dev);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(rmi_register_transport_device);\n\n \nvoid rmi_unregister_transport_device(struct rmi_transport_dev *xport)\n{\n\tstruct rmi_device *rmi_dev = xport->rmi_dev;\n\n\tdevice_del(&rmi_dev->dev);\n\tput_device(&rmi_dev->dev);\n}\nEXPORT_SYMBOL(rmi_unregister_transport_device);\n\n\n \n\nstatic void rmi_release_function(struct device *dev)\n{\n\tstruct rmi_function *fn = to_rmi_function(dev);\n\n\tkfree(fn);\n}\n\nstatic const struct device_type rmi_function_type = {\n\t.name\t\t= \"rmi4_function\",\n\t.release\t= rmi_release_function,\n};\n\nbool rmi_is_function_device(struct device *dev)\n{\n\treturn dev->type == &rmi_function_type;\n}\n\nstatic int rmi_function_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct rmi_function_handler *handler = to_rmi_function_handler(drv);\n\tstruct rmi_function *fn = to_rmi_function(dev);\n\n\treturn fn->fd.function_number == handler->func;\n}\n\n#ifdef CONFIG_OF\nstatic void rmi_function_of_probe(struct rmi_function *fn)\n{\n\tchar of_name[9];\n\tstruct device_node *node = fn->rmi_dev->xport->dev->of_node;\n\n\tsnprintf(of_name, sizeof(of_name), \"rmi4-f%02x\",\n\t\tfn->fd.function_number);\n\tfn->dev.of_node = of_get_child_by_name(node, of_name);\n}\n#else\nstatic inline void rmi_function_of_probe(struct rmi_function *fn)\n{}\n#endif\n\nstatic struct irq_chip rmi_irq_chip = {\n\t.name = \"rmi4\",\n};\n\nstatic int rmi_create_function_irq(struct rmi_function *fn,\n\t\t\t\t   struct rmi_function_handler *handler)\n{\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&fn->rmi_dev->dev);\n\tint i, error;\n\n\tfor (i = 0; i < fn->num_of_irqs; i++) {\n\t\tset_bit(fn->irq_pos + i, fn->irq_mask);\n\n\t\tfn->irq[i] = irq_create_mapping(drvdata->irqdomain,\n\t\t\t\t\t\tfn->irq_pos + i);\n\n\t\tirq_set_chip_data(fn->irq[i], fn);\n\t\tirq_set_chip_and_handler(fn->irq[i], &rmi_irq_chip,\n\t\t\t\t\t handle_simple_irq);\n\t\tirq_set_nested_thread(fn->irq[i], 1);\n\n\t\terror = devm_request_threaded_irq(&fn->dev, fn->irq[i], NULL,\n\t\t\t\t\thandler->attention, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&fn->dev), fn);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev, \"Error %d registering IRQ\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_function_probe(struct device *dev)\n{\n\tstruct rmi_function *fn = to_rmi_function(dev);\n\tstruct rmi_function_handler *handler =\n\t\t\t\t\tto_rmi_function_handler(dev->driver);\n\tint error;\n\n\trmi_function_of_probe(fn);\n\n\tif (handler->probe) {\n\t\terror = handler->probe(fn);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (fn->num_of_irqs && handler->attention) {\n\t\terror = rmi_create_function_irq(fn, handler);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_function_remove(struct device *dev)\n{\n\tstruct rmi_function *fn = to_rmi_function(dev);\n\tstruct rmi_function_handler *handler =\n\t\t\t\t\tto_rmi_function_handler(dev->driver);\n\n\tif (handler->remove)\n\t\thandler->remove(fn);\n\n\treturn 0;\n}\n\nint rmi_register_function(struct rmi_function *fn)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint error;\n\n\tdevice_initialize(&fn->dev);\n\n\tdev_set_name(&fn->dev, \"%s.fn%02x\",\n\t\t     dev_name(&rmi_dev->dev), fn->fd.function_number);\n\n\tfn->dev.parent = &rmi_dev->dev;\n\tfn->dev.type = &rmi_function_type;\n\tfn->dev.bus = &rmi_bus_type;\n\n\terror = device_add(&fn->dev);\n\tif (error) {\n\t\tdev_err(&rmi_dev->dev,\n\t\t\t\"Failed device_register function device %s\\n\",\n\t\t\tdev_name(&fn->dev));\n\t\tgoto err_put_device;\n\t}\n\n\trmi_dbg(RMI_DEBUG_CORE, &rmi_dev->dev, \"Registered F%02X.\\n\",\n\t\t\tfn->fd.function_number);\n\n\treturn 0;\n\nerr_put_device:\n\tput_device(&fn->dev);\n\treturn error;\n}\n\nvoid rmi_unregister_function(struct rmi_function *fn)\n{\n\tint i;\n\n\trmi_dbg(RMI_DEBUG_CORE, &fn->dev, \"Unregistering F%02X.\\n\",\n\t\t\tfn->fd.function_number);\n\n\tdevice_del(&fn->dev);\n\tof_node_put(fn->dev.of_node);\n\n\tfor (i = 0; i < fn->num_of_irqs; i++)\n\t\tirq_dispose_mapping(fn->irq[i]);\n\n\tput_device(&fn->dev);\n}\n\n \nint __rmi_register_function_handler(struct rmi_function_handler *handler,\n\t\t\t\t     struct module *owner,\n\t\t\t\t     const char *mod_name)\n{\n\tstruct device_driver *driver = &handler->driver;\n\tint error;\n\n\tdriver->bus = &rmi_bus_type;\n\tdriver->owner = owner;\n\tdriver->mod_name = mod_name;\n\tdriver->probe = rmi_function_probe;\n\tdriver->remove = rmi_function_remove;\n\n\terror = driver_register(driver);\n\tif (error) {\n\t\tpr_err(\"driver_register() failed for %s, error: %d\\n\",\n\t\t\tdriver->name, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rmi_register_function_handler);\n\n \nvoid rmi_unregister_function_handler(struct rmi_function_handler *handler)\n{\n\tdriver_unregister(&handler->driver);\n}\nEXPORT_SYMBOL_GPL(rmi_unregister_function_handler);\n\n \n\nstatic int rmi_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tbool physical = rmi_is_physical_device(dev);\n\n\t \n\tif (physical != rmi_is_physical_driver(drv))\n\t\treturn 0;\n\n\treturn physical || rmi_function_match(dev, drv);\n}\n\nstruct bus_type rmi_bus_type = {\n\t.match\t\t= rmi_bus_match,\n\t.name\t\t= \"rmi4\",\n};\n\nstatic struct rmi_function_handler *fn_handlers[] = {\n\t&rmi_f01_handler,\n#ifdef CONFIG_RMI4_F03\n\t&rmi_f03_handler,\n#endif\n#ifdef CONFIG_RMI4_F11\n\t&rmi_f11_handler,\n#endif\n#ifdef CONFIG_RMI4_F12\n\t&rmi_f12_handler,\n#endif\n#ifdef CONFIG_RMI4_F30\n\t&rmi_f30_handler,\n#endif\n#ifdef CONFIG_RMI4_F34\n\t&rmi_f34_handler,\n#endif\n#ifdef CONFIG_RMI4_F3A\n\t&rmi_f3a_handler,\n#endif\n#ifdef CONFIG_RMI4_F54\n\t&rmi_f54_handler,\n#endif\n#ifdef CONFIG_RMI4_F55\n\t&rmi_f55_handler,\n#endif\n};\n\nstatic void __rmi_unregister_function_handlers(int start_idx)\n{\n\tint i;\n\n\tfor (i = start_idx; i >= 0; i--)\n\t\trmi_unregister_function_handler(fn_handlers[i]);\n}\n\nstatic void rmi_unregister_function_handlers(void)\n{\n\t__rmi_unregister_function_handlers(ARRAY_SIZE(fn_handlers) - 1);\n}\n\nstatic int rmi_register_function_handlers(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fn_handlers); i++)\t{\n\t\tret = rmi_register_function_handler(fn_handlers[i]);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: error registering the RMI F%02x handler: %d\\n\",\n\t\t\t\t__func__, fn_handlers[i]->func, ret);\n\t\t\tgoto err_unregister_function_handlers;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_unregister_function_handlers:\n\t__rmi_unregister_function_handlers(i - 1);\n\treturn ret;\n}\n\nint rmi_of_property_read_u32(struct device *dev, u32 *result,\n\t\t\t\tconst char *prop, bool optional)\n{\n\tint retval;\n\tu32 val = 0;\n\n\tretval = of_property_read_u32(dev->of_node, prop, &val);\n\tif (retval && (!optional && retval == -EINVAL)) {\n\t\tdev_err(dev, \"Failed to get %s value: %d\\n\",\n\t\t\tprop, retval);\n\t\treturn retval;\n\t}\n\t*result = val;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rmi_of_property_read_u32);\n\nstatic int __init rmi_bus_init(void)\n{\n\tint error;\n\n\terror = bus_register(&rmi_bus_type);\n\tif (error) {\n\t\tpr_err(\"%s: error registering the RMI bus: %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\terror = rmi_register_function_handlers();\n\tif (error)\n\t\tgoto err_unregister_bus;\n\n\terror = rmi_register_physical_driver();\n\tif (error) {\n\t\tpr_err(\"%s: error registering the RMI physical driver: %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto err_unregister_bus;\n\t}\n\n\treturn 0;\n\nerr_unregister_bus:\n\tbus_unregister(&rmi_bus_type);\n\treturn error;\n}\nmodule_init(rmi_bus_init);\n\nstatic void __exit rmi_bus_exit(void)\n{\n\t \n\n\trmi_unregister_physical_driver();\n\trmi_unregister_function_handlers();\n\tbus_unregister(&rmi_bus_type);\n}\nmodule_exit(rmi_bus_exit);\n\nMODULE_AUTHOR(\"Christopher Heiny <cheiny@synaptics.com\");\nMODULE_AUTHOR(\"Andrew Duggan <aduggan@synaptics.com\");\nMODULE_DESCRIPTION(\"RMI bus\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}