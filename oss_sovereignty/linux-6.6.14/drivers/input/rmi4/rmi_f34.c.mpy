{
  "module_name": "rmi_f34.c",
  "hash_id": "e35c06bb6bdddaa0824dcb274d5446bcbe82d93e573691fd992bd8b447d8944b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f34.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/firmware.h>\n#include <asm/unaligned.h>\n#include <linux/bitops.h>\n\n#include \"rmi_driver.h\"\n#include \"rmi_f34.h\"\n\nstatic int rmi_f34_write_bootloader_id(struct f34_data *f34)\n{\n\tstruct rmi_function *fn = f34->fn;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tu8 bootloader_id[F34_BOOTLOADER_ID_LEN];\n\tint ret;\n\n\tret = rmi_read_block(rmi_dev, fn->fd.query_base_addr,\n\t\t\t     bootloader_id, sizeof(bootloader_id));\n\tif (ret) {\n\t\tdev_err(&fn->dev, \"%s: Reading bootloader ID failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"%s: writing bootloader id '%c%c'\\n\",\n\t\t\t__func__, bootloader_id[0], bootloader_id[1]);\n\n\tret = rmi_write_block(rmi_dev,\n\t\t\t      fn->fd.data_base_addr + F34_BLOCK_DATA_OFFSET,\n\t\t\t      bootloader_id, sizeof(bootloader_id));\n\tif (ret) {\n\t\tdev_err(&fn->dev, \"Failed to write bootloader ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34_command(struct f34_data *f34, u8 command,\n\t\t\t   unsigned int timeout, bool write_bl_id)\n{\n\tstruct rmi_function *fn = f34->fn;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint ret;\n\n\tif (write_bl_id) {\n\t\tret = rmi_f34_write_bootloader_id(f34);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinit_completion(&f34->v5.cmd_done);\n\n\tret = rmi_read(rmi_dev, f34->v5.ctrl_address, &f34->v5.status);\n\tif (ret) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"%s: Failed to read cmd register: %d (command %#02x)\\n\",\n\t\t\t__func__, ret, command);\n\t\treturn ret;\n\t}\n\n\tf34->v5.status |= command & 0x0f;\n\n\tret = rmi_write(rmi_dev, f34->v5.ctrl_address, f34->v5.status);\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"Failed to write F34 command %#02x: %d\\n\",\n\t\t\tcommand, ret);\n\t\treturn ret;\n\t}\n\n\tif (!wait_for_completion_timeout(&f34->v5.cmd_done,\n\t\t\t\tmsecs_to_jiffies(timeout))) {\n\n\t\tret = rmi_read(rmi_dev, f34->v5.ctrl_address, &f34->v5.status);\n\t\tif (ret) {\n\t\t\tdev_err(&f34->fn->dev,\n\t\t\t\t\"%s: cmd %#02x timed out: %d\\n\",\n\t\t\t\t__func__, command, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (f34->v5.status & 0x7f) {\n\t\t\tdev_err(&f34->fn->dev,\n\t\t\t\t\"%s: cmd %#02x timed out, status: %#02x\\n\",\n\t\t\t\t__func__, command, f34->v5.status);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t rmi_f34_attention(int irq, void *ctx)\n{\n\tstruct rmi_function *fn = ctx;\n\tstruct f34_data *f34 = dev_get_drvdata(&fn->dev);\n\tint ret;\n\tu8 status;\n\n\tif (f34->bl_version == 5) {\n\t\tret = rmi_read(f34->fn->rmi_dev, f34->v5.ctrl_address,\n\t\t\t       &status);\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"%s: status: %#02x, ret: %d\\n\",\n\t\t\t__func__, status, ret);\n\n\t\tif (!ret && !(status & 0x7f))\n\t\t\tcomplete(&f34->v5.cmd_done);\n\t} else {\n\t\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\t\t\tf34->fn->fd.data_base_addr +\n\t\t\t\t\t\tV7_COMMAND_OFFSET,\n\t\t\t\t\t&status, sizeof(status));\n\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"%s: cmd: %#02x, ret: %d\\n\",\n\t\t\t__func__, status, ret);\n\n\t\tif (!ret && status == CMD_V7_IDLE)\n\t\t\tcomplete(&f34->v7.cmd_done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rmi_f34_write_blocks(struct f34_data *f34, const void *data,\n\t\t\t\tint block_count, u8 command)\n{\n\tstruct rmi_function *fn = f34->fn;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tu16 address = fn->fd.data_base_addr + F34_BLOCK_DATA_OFFSET;\n\tu8 start_address[] = { 0, 0 };\n\tint i;\n\tint ret;\n\n\tret = rmi_write_block(rmi_dev, fn->fd.data_base_addr,\n\t\t\t      start_address, sizeof(start_address));\n\tif (ret) {\n\t\tdev_err(&fn->dev, \"Failed to write initial zeros: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < block_count; i++) {\n\t\tret = rmi_write_block(rmi_dev, address,\n\t\t\t\t      data, f34->v5.block_size);\n\t\tif (ret) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"failed to write block #%d: %d\\n\", i, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rmi_f34_command(f34, command, F34_IDLE_WAIT_MS, false);\n\t\tif (ret) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"Failed to write command for block #%d: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"wrote block %d of %d\\n\",\n\t\t\ti + 1, block_count);\n\n\t\tdata += f34->v5.block_size;\n\t\tf34->update_progress += f34->v5.block_size;\n\t\tf34->update_status = (f34->update_progress * 100) /\n\t\t\tf34->update_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34_write_firmware(struct f34_data *f34, const void *data)\n{\n\treturn rmi_f34_write_blocks(f34, data, f34->v5.fw_blocks,\n\t\t\t\t    F34_WRITE_FW_BLOCK);\n}\n\nstatic int rmi_f34_write_config(struct f34_data *f34, const void *data)\n{\n\treturn rmi_f34_write_blocks(f34, data, f34->v5.config_blocks,\n\t\t\t\t    F34_WRITE_CONFIG_BLOCK);\n}\n\nstatic int rmi_f34_enable_flash(struct f34_data *f34)\n{\n\treturn rmi_f34_command(f34, F34_ENABLE_FLASH_PROG,\n\t\t\t       F34_ENABLE_WAIT_MS, true);\n}\n\nstatic int rmi_f34_flash_firmware(struct f34_data *f34,\n\t\t\t\t  const struct rmi_f34_firmware *syn_fw)\n{\n\tstruct rmi_function *fn = f34->fn;\n\tu32 image_size = le32_to_cpu(syn_fw->image_size);\n\tu32 config_size = le32_to_cpu(syn_fw->config_size);\n\tint ret;\n\n\tf34->update_progress = 0;\n\tf34->update_size = image_size + config_size;\n\n\tif (image_size) {\n\t\tdev_info(&fn->dev, \"Erasing firmware...\\n\");\n\t\tret = rmi_f34_command(f34, F34_ERASE_ALL,\n\t\t\t\t      F34_ERASE_WAIT_MS, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_info(&fn->dev, \"Writing firmware (%d bytes)...\\n\",\n\t\t\t image_size);\n\t\tret = rmi_f34_write_firmware(f34, syn_fw->data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (config_size) {\n\t\t \n\t\tif (!image_size) {\n\t\t\tdev_info(&fn->dev, \"Erasing config...\\n\");\n\t\t\tret = rmi_f34_command(f34, F34_ERASE_CONFIG,\n\t\t\t\t\t      F34_ERASE_WAIT_MS, true);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tdev_info(&fn->dev, \"Writing config (%d bytes)...\\n\",\n\t\t\t config_size);\n\t\tret = rmi_f34_write_config(f34, &syn_fw->data[image_size]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34_update_firmware(struct f34_data *f34,\n\t\t\t\t   const struct firmware *fw)\n{\n\tconst struct rmi_f34_firmware *syn_fw =\n\t\t\t\t(const struct rmi_f34_firmware *)fw->data;\n\tu32 image_size = le32_to_cpu(syn_fw->image_size);\n\tu32 config_size = le32_to_cpu(syn_fw->config_size);\n\tint ret;\n\n\tBUILD_BUG_ON(offsetof(struct rmi_f34_firmware, data) !=\n\t\t\tF34_FW_IMAGE_OFFSET);\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\"FW size:%zd, checksum:%08x, image_size:%d, config_size:%d\\n\",\n\t\tfw->size,\n\t\tle32_to_cpu(syn_fw->checksum),\n\t\timage_size, config_size);\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\"FW bootloader_id:%02x, product_id:%.*s, info: %02x%02x\\n\",\n\t\tsyn_fw->bootloader_version,\n\t\t(int)sizeof(syn_fw->product_id), syn_fw->product_id,\n\t\tsyn_fw->product_info[0], syn_fw->product_info[1]);\n\n\tif (image_size && image_size != f34->v5.fw_blocks * f34->v5.block_size) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"Bad firmware image: fw size %d, expected %d\\n\",\n\t\t\timage_size, f34->v5.fw_blocks * f34->v5.block_size);\n\t\tret = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tif (config_size &&\n\t    config_size != f34->v5.config_blocks * f34->v5.block_size) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"Bad firmware image: config size %d, expected %d\\n\",\n\t\t\tconfig_size,\n\t\t\tf34->v5.config_blocks * f34->v5.block_size);\n\t\tret = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tif (image_size && !config_size) {\n\t\tdev_err(&f34->fn->dev, \"Bad firmware image: no config data\\n\");\n\t\tret = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tdev_info(&f34->fn->dev, \"Firmware image OK\\n\");\n\tmutex_lock(&f34->v5.flash_mutex);\n\n\tret = rmi_f34_flash_firmware(f34, syn_fw);\n\n\tmutex_unlock(&f34->v5.flash_mutex);\n\nout:\n\treturn ret;\n}\n\nstatic int rmi_f34_status(struct rmi_function *fn)\n{\n\tstruct f34_data *f34 = dev_get_drvdata(&fn->dev);\n\n\t \n\treturn f34->update_status;\n}\n\nstatic ssize_t rmi_driver_bootloader_id_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *dattr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct rmi_function *fn = data->f34_container;\n\tstruct f34_data *f34;\n\n\tif (fn) {\n\t\tf34 = dev_get_drvdata(&fn->dev);\n\n\t\tif (f34->bl_version == 5)\n\t\t\treturn sysfs_emit(buf, \"%c%c\\n\",\n\t\t\t\t\t  f34->bootloader_id[0],\n\t\t\t\t\t  f34->bootloader_id[1]);\n\t\telse\n\t\t\treturn sysfs_emit(buf, \"V%d.%d\\n\",\n\t\t\t\t\t  f34->bootloader_id[1],\n\t\t\t\t\t  f34->bootloader_id[0]);\n\t}\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR(bootloader_id, 0444, rmi_driver_bootloader_id_show, NULL);\n\nstatic ssize_t rmi_driver_configuration_id_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *dattr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct rmi_function *fn = data->f34_container;\n\tstruct f34_data *f34;\n\n\tif (fn) {\n\t\tf34 = dev_get_drvdata(&fn->dev);\n\n\t\treturn sysfs_emit(buf, \"%s\\n\", f34->configuration_id);\n\t}\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR(configuration_id, 0444,\n\t\t   rmi_driver_configuration_id_show, NULL);\n\nstatic int rmi_firmware_update(struct rmi_driver_data *data,\n\t\t\t       const struct firmware *fw)\n{\n\tstruct rmi_device *rmi_dev = data->rmi_dev;\n\tstruct device *dev = &rmi_dev->dev;\n\tstruct f34_data *f34;\n\tint ret;\n\n\tif (!data->f34_container) {\n\t\tdev_warn(dev, \"%s: No F34 present!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tf34 = dev_get_drvdata(&data->f34_container->dev);\n\n\tif (f34->bl_version >= 7) {\n\t\tif (data->pdt_props & HAS_BSR) {\n\t\t\tdev_err(dev, \"%s: LTS not supported\\n\", __func__);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (f34->bl_version != 5) {\n\t\tdev_warn(dev, \"F34 V%d not supported!\\n\",\n\t\t\t data->f34_container->fd.function_version);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (f34->bl_version >= 7)\n\t\tret = rmi_f34v7_start_reflash(f34, fw);\n\telse\n\t\tret = rmi_f34_enable_flash(f34);\n\tif (ret)\n\t\treturn ret;\n\n\trmi_disable_irq(rmi_dev, false);\n\n\t \n\trmi_free_function_list(rmi_dev);\n\n\tret = rmi_probe_interrupts(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rmi_init_functions(data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!data->bootloader_mode || !data->f34_container) {\n\t\tdev_warn(dev, \"%s: No F34 present or not in bootloader!\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\trmi_enable_irq(rmi_dev, false);\n\n\tf34 = dev_get_drvdata(&data->f34_container->dev);\n\n\t \n\tif (f34->bl_version >= 7)\n\t\tret = rmi_f34v7_do_reflash(f34, fw);\n\telse\n\t\tret = rmi_f34_update_firmware(f34, fw);\n\n\tif (ret) {\n\t\tf34->update_status = ret;\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"Firmware update failed, status: %d\\n\", ret);\n\t} else {\n\t\tdev_info(&f34->fn->dev, \"Firmware update complete\\n\");\n\t}\n\n\trmi_disable_irq(rmi_dev, false);\n\n\t \n\trmi_dbg(RMI_DEBUG_FN, dev, \"Re-probing device\\n\");\n\trmi_free_function_list(rmi_dev);\n\n\tret = rmi_scan_pdt(rmi_dev, NULL, rmi_initial_reset);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"RMI reset failed!\\n\");\n\n\tret = rmi_probe_interrupts(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rmi_init_functions(data);\n\tif (ret)\n\t\treturn ret;\n\n\trmi_enable_irq(rmi_dev, false);\n\n\tif (data->f01_container->dev.driver)\n\t\t \n\t\treturn rmi_enable_sensor(rmi_dev);\n\n\trmi_dbg(RMI_DEBUG_FN, dev, \"%s complete\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic ssize_t rmi_driver_update_fw_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *dattr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tchar fw_name[NAME_MAX];\n\tconst struct firmware *fw;\n\tsize_t copy_count = count;\n\tint ret;\n\n\tif (count == 0 || count >= NAME_MAX)\n\t\treturn -EINVAL;\n\n\tif (buf[count - 1] == '\\0' || buf[count - 1] == '\\n')\n\t\tcopy_count -= 1;\n\n\tstrncpy(fw_name, buf, copy_count);\n\tfw_name[copy_count] = '\\0';\n\n\tret = request_firmware(&fw, fw_name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"Flashing %s\\n\", fw_name);\n\n\tret = rmi_firmware_update(data, fw);\n\n\trelease_firmware(fw);\n\n\treturn ret ?: count;\n}\n\nstatic DEVICE_ATTR(update_fw, 0200, NULL, rmi_driver_update_fw_store);\n\nstatic ssize_t rmi_driver_update_fw_status_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *dattr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tint update_status = 0;\n\n\tif (data->f34_container)\n\t\tupdate_status = rmi_f34_status(data->f34_container);\n\n\treturn sysfs_emit(buf, \"%d\\n\", update_status);\n}\n\nstatic DEVICE_ATTR(update_fw_status, 0444,\n\t\t   rmi_driver_update_fw_status_show, NULL);\n\nstatic struct attribute *rmi_firmware_attrs[] = {\n\t&dev_attr_bootloader_id.attr,\n\t&dev_attr_configuration_id.attr,\n\t&dev_attr_update_fw.attr,\n\t&dev_attr_update_fw_status.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rmi_firmware_attr_group = {\n\t.attrs = rmi_firmware_attrs,\n};\n\nstatic int rmi_f34_probe(struct rmi_function *fn)\n{\n\tstruct f34_data *f34;\n\tunsigned char f34_queries[9];\n\tbool has_config_id;\n\tu8 version = fn->fd.function_version;\n\tint ret;\n\n\tf34 = devm_kzalloc(&fn->dev, sizeof(struct f34_data), GFP_KERNEL);\n\tif (!f34)\n\t\treturn -ENOMEM;\n\n\tf34->fn = fn;\n\tdev_set_drvdata(&fn->dev, f34);\n\n\t \n\tif (version > 0)\n\t\treturn rmi_f34v7_probe(f34);\n\n\tf34->bl_version = 5;\n\n\tret = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr,\n\t\t\t     f34_queries, sizeof(f34_queries));\n\tif (ret) {\n\t\tdev_err(&fn->dev, \"%s: Failed to query properties\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tsnprintf(f34->bootloader_id, sizeof(f34->bootloader_id),\n\t\t \"%c%c\", f34_queries[0], f34_queries[1]);\n\n\tmutex_init(&f34->v5.flash_mutex);\n\tinit_completion(&f34->v5.cmd_done);\n\n\tf34->v5.block_size = get_unaligned_le16(&f34_queries[3]);\n\tf34->v5.fw_blocks = get_unaligned_le16(&f34_queries[5]);\n\tf34->v5.config_blocks = get_unaligned_le16(&f34_queries[7]);\n\tf34->v5.ctrl_address = fn->fd.data_base_addr + F34_BLOCK_DATA_OFFSET +\n\t\tf34->v5.block_size;\n\thas_config_id = f34_queries[2] & (1 << 2);\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"Bootloader ID: %s\\n\",\n\t\tf34->bootloader_id);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"Block size: %d\\n\",\n\t\tf34->v5.block_size);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"FW blocks: %d\\n\",\n\t\tf34->v5.fw_blocks);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"CFG blocks: %d\\n\",\n\t\tf34->v5.config_blocks);\n\n\tif (has_config_id) {\n\t\tret = rmi_read_block(fn->rmi_dev, fn->fd.control_base_addr,\n\t\t\t\t     f34_queries, sizeof(f34_queries));\n\t\tif (ret) {\n\t\t\tdev_err(&fn->dev, \"Failed to read F34 config ID\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsnprintf(f34->configuration_id, sizeof(f34->configuration_id),\n\t\t\t \"%02x%02x%02x%02x\",\n\t\t\t f34_queries[0], f34_queries[1],\n\t\t\t f34_queries[2], f34_queries[3]);\n\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"Configuration ID: %s\\n\",\n\t\t\t f34->configuration_id);\n\t}\n\n\treturn 0;\n}\n\nint rmi_f34_create_sysfs(struct rmi_device *rmi_dev)\n{\n\treturn sysfs_create_group(&rmi_dev->dev.kobj, &rmi_firmware_attr_group);\n}\n\nvoid rmi_f34_remove_sysfs(struct rmi_device *rmi_dev)\n{\n\tsysfs_remove_group(&rmi_dev->dev.kobj, &rmi_firmware_attr_group);\n}\n\nstruct rmi_function_handler rmi_f34_handler = {\n\t.driver = {\n\t\t.name = \"rmi4_f34\",\n\t},\n\t.func = 0x34,\n\t.probe = rmi_f34_probe,\n\t.attention = rmi_f34_attention,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}