{
  "module_name": "rmi_driver.c",
  "hash_id": "7d5ab33b3fa6fd4489f07e5cdc2983248cc71f80a51a40c84cb8231d0c63ffe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_driver.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/irq.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/irqdomain.h>\n#include <uapi/linux/input.h>\n#include <linux/rmi.h>\n#include \"rmi_bus.h\"\n#include \"rmi_driver.h\"\n\n#define HAS_NONSTANDARD_PDT_MASK 0x40\n#define RMI4_MAX_PAGE 0xff\n#define RMI4_PAGE_SIZE 0x100\n#define RMI4_PAGE_MASK 0xFF00\n\n#define RMI_DEVICE_RESET_CMD\t0x01\n#define DEFAULT_RESET_DELAY_MS\t100\n\nvoid rmi_free_function_list(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_function *fn, *tmp;\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\n\trmi_dbg(RMI_DEBUG_CORE, &rmi_dev->dev, \"Freeing function list\\n\");\n\n\t \n\tlist_for_each_entry_safe_reverse(fn, tmp,\n\t\t\t\t\t &data->function_list, node) {\n\t\tlist_del(&fn->node);\n\t\trmi_unregister_function(fn);\n\t}\n\n\tdevm_kfree(&rmi_dev->dev, data->irq_memory);\n\tdata->irq_memory = NULL;\n\tdata->irq_status = NULL;\n\tdata->fn_irq_bits = NULL;\n\tdata->current_irq_mask = NULL;\n\tdata->new_irq_mask = NULL;\n\n\tdata->f01_container = NULL;\n\tdata->f34_container = NULL;\n}\n\nstatic int reset_one_function(struct rmi_function *fn)\n{\n\tstruct rmi_function_handler *fh;\n\tint retval = 0;\n\n\tif (!fn || !fn->dev.driver)\n\t\treturn 0;\n\n\tfh = to_rmi_function_handler(fn->dev.driver);\n\tif (fh->reset) {\n\t\tretval = fh->reset(fn);\n\t\tif (retval < 0)\n\t\t\tdev_err(&fn->dev, \"Reset failed with code %d.\\n\",\n\t\t\t\tretval);\n\t}\n\n\treturn retval;\n}\n\nstatic int configure_one_function(struct rmi_function *fn)\n{\n\tstruct rmi_function_handler *fh;\n\tint retval = 0;\n\n\tif (!fn || !fn->dev.driver)\n\t\treturn 0;\n\n\tfh = to_rmi_function_handler(fn->dev.driver);\n\tif (fh->config) {\n\t\tretval = fh->config(fn);\n\t\tif (retval < 0)\n\t\t\tdev_err(&fn->dev, \"Config failed with code %d.\\n\",\n\t\t\t\tretval);\n\t}\n\n\treturn retval;\n}\n\nstatic int rmi_driver_process_reset_requests(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_function *entry;\n\tint retval;\n\n\tlist_for_each_entry(entry, &data->function_list, node) {\n\t\tretval = reset_one_function(entry);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_driver_process_config_requests(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_function *entry;\n\tint retval;\n\n\tlist_for_each_entry(entry, &data->function_list, node) {\n\t\tretval = configure_one_function(entry);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_process_interrupt_requests(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct device *dev = &rmi_dev->dev;\n\tint i;\n\tint error;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (!data->attn_data.data) {\n\t\terror = rmi_read_block(rmi_dev,\n\t\t\t\tdata->f01_container->fd.data_base_addr + 1,\n\t\t\t\tdata->irq_status, data->num_of_irq_regs);\n\t\tif (error < 0) {\n\t\t\tdev_err(dev, \"Failed to read irqs, code=%d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tmutex_lock(&data->irq_mutex);\n\tbitmap_and(data->irq_status, data->irq_status, data->fn_irq_bits,\n\t       data->irq_count);\n\t \n\tmutex_unlock(&data->irq_mutex);\n\n\tfor_each_set_bit(i, data->irq_status, data->irq_count)\n\t\thandle_nested_irq(irq_find_mapping(data->irqdomain, i));\n\n\tif (data->input)\n\t\tinput_sync(data->input);\n\n\treturn 0;\n}\n\nvoid rmi_set_attn_data(struct rmi_device *rmi_dev, unsigned long irq_status,\n\t\t       void *data, size_t size)\n{\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi4_attn_data attn_data;\n\tvoid *fifo_data;\n\n\tif (!drvdata->enabled)\n\t\treturn;\n\n\tfifo_data = kmemdup(data, size, GFP_ATOMIC);\n\tif (!fifo_data)\n\t\treturn;\n\n\tattn_data.irq_status = irq_status;\n\tattn_data.size = size;\n\tattn_data.data = fifo_data;\n\n\tkfifo_put(&drvdata->attn_fifo, attn_data);\n}\nEXPORT_SYMBOL_GPL(rmi_set_attn_data);\n\nstatic irqreturn_t rmi_irq_fn(int irq, void *dev_id)\n{\n\tstruct rmi_device *rmi_dev = dev_id;\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi4_attn_data attn_data = {0};\n\tint ret, count;\n\n\tcount = kfifo_get(&drvdata->attn_fifo, &attn_data);\n\tif (count) {\n\t\t*(drvdata->irq_status) = attn_data.irq_status;\n\t\tdrvdata->attn_data = attn_data;\n\t}\n\n\tret = rmi_process_interrupt_requests(rmi_dev);\n\tif (ret)\n\t\trmi_dbg(RMI_DEBUG_CORE, &rmi_dev->dev,\n\t\t\t\"Failed to process interrupt request: %d\\n\", ret);\n\n\tif (count) {\n\t\tkfree(attn_data.data);\n\t\tdrvdata->attn_data.data = NULL;\n\t}\n\n\tif (!kfifo_is_empty(&drvdata->attn_fifo))\n\t\treturn rmi_irq_fn(irq, dev_id);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rmi_irq_init(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tint irq_flags = irq_get_trigger_type(pdata->irq);\n\tint ret;\n\n\tif (!irq_flags)\n\t\tirq_flags = IRQF_TRIGGER_LOW;\n\n\tret = devm_request_threaded_irq(&rmi_dev->dev, pdata->irq, NULL,\n\t\t\t\t\trmi_irq_fn, irq_flags | IRQF_ONESHOT,\n\t\t\t\t\tdev_driver_string(rmi_dev->xport->dev),\n\t\t\t\t\trmi_dev);\n\tif (ret < 0) {\n\t\tdev_err(&rmi_dev->dev, \"Failed to register interrupt %d\\n\",\n\t\t\tpdata->irq);\n\n\t\treturn ret;\n\t}\n\n\tdata->enabled = true;\n\n\treturn 0;\n}\n\nstruct rmi_function *rmi_find_function(struct rmi_device *rmi_dev, u8 number)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_function *entry;\n\n\tlist_for_each_entry(entry, &data->function_list, node) {\n\t\tif (entry->fd.function_number == number)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic int suspend_one_function(struct rmi_function *fn)\n{\n\tstruct rmi_function_handler *fh;\n\tint retval = 0;\n\n\tif (!fn || !fn->dev.driver)\n\t\treturn 0;\n\n\tfh = to_rmi_function_handler(fn->dev.driver);\n\tif (fh->suspend) {\n\t\tretval = fh->suspend(fn);\n\t\tif (retval < 0)\n\t\t\tdev_err(&fn->dev, \"Suspend failed with code %d.\\n\",\n\t\t\t\tretval);\n\t}\n\n\treturn retval;\n}\n\nstatic int rmi_suspend_functions(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_function *entry;\n\tint retval;\n\n\tlist_for_each_entry(entry, &data->function_list, node) {\n\t\tretval = suspend_one_function(entry);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic int resume_one_function(struct rmi_function *fn)\n{\n\tstruct rmi_function_handler *fh;\n\tint retval = 0;\n\n\tif (!fn || !fn->dev.driver)\n\t\treturn 0;\n\n\tfh = to_rmi_function_handler(fn->dev.driver);\n\tif (fh->resume) {\n\t\tretval = fh->resume(fn);\n\t\tif (retval < 0)\n\t\t\tdev_err(&fn->dev, \"Resume failed with code %d.\\n\",\n\t\t\t\tretval);\n\t}\n\n\treturn retval;\n}\n\nstatic int rmi_resume_functions(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_function *entry;\n\tint retval;\n\n\tlist_for_each_entry(entry, &data->function_list, node) {\n\t\tretval = resume_one_function(entry);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nint rmi_enable_sensor(struct rmi_device *rmi_dev)\n{\n\tint retval = 0;\n\n\tretval = rmi_driver_process_config_requests(rmi_dev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn rmi_process_interrupt_requests(rmi_dev);\n}\n\n \nstatic int rmi_driver_set_input_params(struct rmi_device *rmi_dev,\n\t\t\t\tstruct input_dev *input)\n{\n\tinput->name = SYNAPTICS_INPUT_DEVICE_NAME;\n\tinput->id.vendor  = SYNAPTICS_VENDOR_ID;\n\tinput->id.bustype = BUS_RMI;\n\treturn 0;\n}\n\nstatic void rmi_driver_set_input_name(struct rmi_device *rmi_dev,\n\t\t\t\tstruct input_dev *input)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tconst char *device_name = rmi_f01_get_product_ID(data->f01_container);\n\tchar *name;\n\n\tname = devm_kasprintf(&rmi_dev->dev, GFP_KERNEL,\n\t\t\t      \"Synaptics %s\", device_name);\n\tif (!name)\n\t\treturn;\n\n\tinput->name = name;\n}\n\nstatic int rmi_driver_set_irq_bits(struct rmi_device *rmi_dev,\n\t\t\t\t   unsigned long *mask)\n{\n\tint error = 0;\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct device *dev = &rmi_dev->dev;\n\n\tmutex_lock(&data->irq_mutex);\n\tbitmap_or(data->new_irq_mask,\n\t\t  data->current_irq_mask, mask, data->irq_count);\n\n\terror = rmi_write_block(rmi_dev,\n\t\t\tdata->f01_container->fd.control_base_addr + 1,\n\t\t\tdata->new_irq_mask, data->num_of_irq_regs);\n\tif (error < 0) {\n\t\tdev_err(dev, \"%s: Failed to change enabled interrupts!\",\n\t\t\t\t\t\t\t__func__);\n\t\tgoto error_unlock;\n\t}\n\tbitmap_copy(data->current_irq_mask, data->new_irq_mask,\n\t\t    data->num_of_irq_regs);\n\n\tbitmap_or(data->fn_irq_bits, data->fn_irq_bits, mask, data->irq_count);\n\nerror_unlock:\n\tmutex_unlock(&data->irq_mutex);\n\treturn error;\n}\n\nstatic int rmi_driver_clear_irq_bits(struct rmi_device *rmi_dev,\n\t\t\t\t     unsigned long *mask)\n{\n\tint error = 0;\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct device *dev = &rmi_dev->dev;\n\n\tmutex_lock(&data->irq_mutex);\n\tbitmap_andnot(data->fn_irq_bits,\n\t\t      data->fn_irq_bits, mask, data->irq_count);\n\tbitmap_andnot(data->new_irq_mask,\n\t\t  data->current_irq_mask, mask, data->irq_count);\n\n\terror = rmi_write_block(rmi_dev,\n\t\t\tdata->f01_container->fd.control_base_addr + 1,\n\t\t\tdata->new_irq_mask, data->num_of_irq_regs);\n\tif (error < 0) {\n\t\tdev_err(dev, \"%s: Failed to change enabled interrupts!\",\n\t\t\t\t\t\t\t__func__);\n\t\tgoto error_unlock;\n\t}\n\tbitmap_copy(data->current_irq_mask, data->new_irq_mask,\n\t\t    data->num_of_irq_regs);\n\nerror_unlock:\n\tmutex_unlock(&data->irq_mutex);\n\treturn error;\n}\n\nstatic int rmi_driver_reset_handler(struct rmi_device *rmi_dev)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tint error;\n\n\t \n\tif (!data || !data->f01_container) {\n\t\tdev_warn(&rmi_dev->dev,\n\t\t\t \"Not ready to handle reset yet!\\n\");\n\t\treturn 0;\n\t}\n\n\terror = rmi_read_block(rmi_dev,\n\t\t\t       data->f01_container->fd.control_base_addr + 1,\n\t\t\t       data->current_irq_mask, data->num_of_irq_regs);\n\tif (error < 0) {\n\t\tdev_err(&rmi_dev->dev, \"%s: Failed to read current IRQ mask.\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\n\terror = rmi_driver_process_reset_requests(rmi_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = rmi_driver_process_config_requests(rmi_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int rmi_read_pdt_entry(struct rmi_device *rmi_dev,\n\t\t\t      struct pdt_entry *entry, u16 pdt_address)\n{\n\tu8 buf[RMI_PDT_ENTRY_SIZE];\n\tint error;\n\n\terror = rmi_read_block(rmi_dev, pdt_address, buf, RMI_PDT_ENTRY_SIZE);\n\tif (error) {\n\t\tdev_err(&rmi_dev->dev, \"Read PDT entry at %#06x failed, code: %d.\\n\",\n\t\t\t\tpdt_address, error);\n\t\treturn error;\n\t}\n\n\tentry->page_start = pdt_address & RMI4_PAGE_MASK;\n\tentry->query_base_addr = buf[0];\n\tentry->command_base_addr = buf[1];\n\tentry->control_base_addr = buf[2];\n\tentry->data_base_addr = buf[3];\n\tentry->interrupt_source_count = buf[4] & RMI_PDT_INT_SOURCE_COUNT_MASK;\n\tentry->function_version = (buf[4] & RMI_PDT_FUNCTION_VERSION_MASK) >> 5;\n\tentry->function_number = buf[5];\n\n\treturn 0;\n}\n\nstatic void rmi_driver_copy_pdt_to_fd(const struct pdt_entry *pdt,\n\t\t\t\t      struct rmi_function_descriptor *fd)\n{\n\tfd->query_base_addr = pdt->query_base_addr + pdt->page_start;\n\tfd->command_base_addr = pdt->command_base_addr + pdt->page_start;\n\tfd->control_base_addr = pdt->control_base_addr + pdt->page_start;\n\tfd->data_base_addr = pdt->data_base_addr + pdt->page_start;\n\tfd->function_number = pdt->function_number;\n\tfd->interrupt_source_count = pdt->interrupt_source_count;\n\tfd->function_version = pdt->function_version;\n}\n\n#define RMI_SCAN_CONTINUE\t0\n#define RMI_SCAN_DONE\t\t1\n\nstatic int rmi_scan_pdt_page(struct rmi_device *rmi_dev,\n\t\t\t     int page,\n\t\t\t     int *empty_pages,\n\t\t\t     void *ctx,\n\t\t\t     int (*callback)(struct rmi_device *rmi_dev,\n\t\t\t\t\t     void *ctx,\n\t\t\t\t\t     const struct pdt_entry *entry))\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct pdt_entry pdt_entry;\n\tu16 page_start = RMI4_PAGE_SIZE * page;\n\tu16 pdt_start = page_start + PDT_START_SCAN_LOCATION;\n\tu16 pdt_end = page_start + PDT_END_SCAN_LOCATION;\n\tu16 addr;\n\tint error;\n\tint retval;\n\n\tfor (addr = pdt_start; addr >= pdt_end; addr -= RMI_PDT_ENTRY_SIZE) {\n\t\terror = rmi_read_pdt_entry(rmi_dev, &pdt_entry, addr);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (RMI4_END_OF_PDT(pdt_entry.function_number))\n\t\t\tbreak;\n\n\t\tretval = callback(rmi_dev, ctx, &pdt_entry);\n\t\tif (retval != RMI_SCAN_CONTINUE)\n\t\t\treturn retval;\n\t}\n\n\t \n\tif (addr == pdt_start)\n\t\t++*empty_pages;\n\telse\n\t\t*empty_pages = 0;\n\n\treturn (data->bootloader_mode || *empty_pages >= 2) ?\n\t\t\t\t\tRMI_SCAN_DONE : RMI_SCAN_CONTINUE;\n}\n\nint rmi_scan_pdt(struct rmi_device *rmi_dev, void *ctx,\n\t\t int (*callback)(struct rmi_device *rmi_dev,\n\t\t void *ctx, const struct pdt_entry *entry))\n{\n\tint page;\n\tint empty_pages = 0;\n\tint retval = RMI_SCAN_DONE;\n\n\tfor (page = 0; page <= RMI4_MAX_PAGE; page++) {\n\t\tretval = rmi_scan_pdt_page(rmi_dev, page, &empty_pages,\n\t\t\t\t\t   ctx, callback);\n\t\tif (retval != RMI_SCAN_CONTINUE)\n\t\t\tbreak;\n\t}\n\n\treturn retval < 0 ? retval : 0;\n}\n\nint rmi_read_register_desc(struct rmi_device *d, u16 addr,\n\t\t\t\tstruct rmi_register_descriptor *rdesc)\n{\n\tint ret;\n\tu8 size_presence_reg;\n\tu8 buf[35];\n\tint presense_offset = 1;\n\tu8 *struct_buf;\n\tint reg;\n\tint offset = 0;\n\tint map_offset = 0;\n\tint i;\n\tint b;\n\n\t \n\tret = rmi_read(d, addr, &size_presence_reg);\n\tif (ret)\n\t\treturn ret;\n\t++addr;\n\n\tif (size_presence_reg < 0 || size_presence_reg > 35)\n\t\treturn -EIO;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\t \n\tret = rmi_read_block(d, addr, buf, size_presence_reg);\n\tif (ret)\n\t\treturn ret;\n\t++addr;\n\n\tif (buf[0] == 0) {\n\t\tpresense_offset = 3;\n\t\trdesc->struct_size = buf[1] | (buf[2] << 8);\n\t} else {\n\t\trdesc->struct_size = buf[0];\n\t}\n\n\tfor (i = presense_offset; i < size_presence_reg; i++) {\n\t\tfor (b = 0; b < 8; b++) {\n\t\t\tif (buf[i] & (0x1 << b))\n\t\t\t\tbitmap_set(rdesc->presense_map, map_offset, 1);\n\t\t\t++map_offset;\n\t\t}\n\t}\n\n\trdesc->num_registers = bitmap_weight(rdesc->presense_map,\n\t\t\t\t\t\tRMI_REG_DESC_PRESENSE_BITS);\n\n\trdesc->registers = devm_kcalloc(&d->dev,\n\t\t\t\t\trdesc->num_registers,\n\t\t\t\t\tsizeof(struct rmi_register_desc_item),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rdesc->registers)\n\t\treturn -ENOMEM;\n\n\t \n\tstruct_buf = kzalloc(rdesc->struct_size, GFP_KERNEL);\n\tif (!struct_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = rmi_read_block(d, addr, struct_buf, rdesc->struct_size);\n\tif (ret)\n\t\tgoto free_struct_buff;\n\n\treg = find_first_bit(rdesc->presense_map, RMI_REG_DESC_PRESENSE_BITS);\n\tfor (i = 0; i < rdesc->num_registers; i++) {\n\t\tstruct rmi_register_desc_item *item = &rdesc->registers[i];\n\t\tint reg_size = struct_buf[offset];\n\n\t\t++offset;\n\t\tif (reg_size == 0) {\n\t\t\treg_size = struct_buf[offset] |\n\t\t\t\t\t(struct_buf[offset + 1] << 8);\n\t\t\toffset += 2;\n\t\t}\n\n\t\tif (reg_size == 0) {\n\t\t\treg_size = struct_buf[offset] |\n\t\t\t\t\t(struct_buf[offset + 1] << 8) |\n\t\t\t\t\t(struct_buf[offset + 2] << 16) |\n\t\t\t\t\t(struct_buf[offset + 3] << 24);\n\t\t\toffset += 4;\n\t\t}\n\n\t\titem->reg = reg;\n\t\titem->reg_size = reg_size;\n\n\t\tmap_offset = 0;\n\n\t\tdo {\n\t\t\tfor (b = 0; b < 7; b++) {\n\t\t\t\tif (struct_buf[offset] & (0x1 << b))\n\t\t\t\t\tbitmap_set(item->subpacket_map,\n\t\t\t\t\t\tmap_offset, 1);\n\t\t\t\t++map_offset;\n\t\t\t}\n\t\t} while (struct_buf[offset++] & 0x80);\n\n\t\titem->num_subpackets = bitmap_weight(item->subpacket_map,\n\t\t\t\t\t\tRMI_REG_DESC_SUBPACKET_BITS);\n\n\t\trmi_dbg(RMI_DEBUG_CORE, &d->dev,\n\t\t\t\"%s: reg: %d reg size: %ld subpackets: %d\\n\", __func__,\n\t\t\titem->reg, item->reg_size, item->num_subpackets);\n\n\t\treg = find_next_bit(rdesc->presense_map,\n\t\t\t\tRMI_REG_DESC_PRESENSE_BITS, reg + 1);\n\t}\n\nfree_struct_buff:\n\tkfree(struct_buf);\n\treturn ret;\n}\n\nconst struct rmi_register_desc_item *rmi_get_register_desc_item(\n\t\t\t\tstruct rmi_register_descriptor *rdesc, u16 reg)\n{\n\tconst struct rmi_register_desc_item *item;\n\tint i;\n\n\tfor (i = 0; i < rdesc->num_registers; i++) {\n\t\titem = &rdesc->registers[i];\n\t\tif (item->reg == reg)\n\t\t\treturn item;\n\t}\n\n\treturn NULL;\n}\n\nsize_t rmi_register_desc_calc_size(struct rmi_register_descriptor *rdesc)\n{\n\tconst struct rmi_register_desc_item *item;\n\tint i;\n\tsize_t size = 0;\n\n\tfor (i = 0; i < rdesc->num_registers; i++) {\n\t\titem = &rdesc->registers[i];\n\t\tsize += item->reg_size;\n\t}\n\treturn size;\n}\n\n \nint rmi_register_desc_calc_reg_offset(\n\t\tstruct rmi_register_descriptor *rdesc, u16 reg)\n{\n\tconst struct rmi_register_desc_item *item;\n\tint offset = 0;\n\tint i;\n\n\tfor (i = 0; i < rdesc->num_registers; i++) {\n\t\titem = &rdesc->registers[i];\n\t\tif (item->reg == reg)\n\t\t\treturn offset;\n\t\t++offset;\n\t}\n\treturn -1;\n}\n\nbool rmi_register_desc_has_subpacket(const struct rmi_register_desc_item *item,\n\tu8 subpacket)\n{\n\treturn find_next_bit(item->subpacket_map, RMI_REG_DESC_PRESENSE_BITS,\n\t\t\t\tsubpacket) == subpacket;\n}\n\nstatic int rmi_check_bootloader_mode(struct rmi_device *rmi_dev,\n\t\t\t\t     const struct pdt_entry *pdt)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tint ret;\n\tu8 status;\n\n\tif (pdt->function_number == 0x34 && pdt->function_version > 1) {\n\t\tret = rmi_read(rmi_dev, pdt->data_base_addr, &status);\n\t\tif (ret) {\n\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\"Failed to read F34 status: %d.\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (status & BIT(7))\n\t\t\tdata->bootloader_mode = true;\n\t} else if (pdt->function_number == 0x01) {\n\t\tret = rmi_read(rmi_dev, pdt->data_base_addr, &status);\n\t\tif (ret) {\n\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\"Failed to read F01 status: %d.\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (status & BIT(6))\n\t\t\tdata->bootloader_mode = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_count_irqs(struct rmi_device *rmi_dev,\n\t\t\t void *ctx, const struct pdt_entry *pdt)\n{\n\tint *irq_count = ctx;\n\tint ret;\n\n\t*irq_count += pdt->interrupt_source_count;\n\n\tret = rmi_check_bootloader_mode(rmi_dev, pdt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn RMI_SCAN_CONTINUE;\n}\n\nint rmi_initial_reset(struct rmi_device *rmi_dev, void *ctx,\n\t\t      const struct pdt_entry *pdt)\n{\n\tint error;\n\n\tif (pdt->function_number == 0x01) {\n\t\tu16 cmd_addr = pdt->page_start + pdt->command_base_addr;\n\t\tu8 cmd_buf = RMI_DEVICE_RESET_CMD;\n\t\tconst struct rmi_device_platform_data *pdata =\n\t\t\t\trmi_get_platform_data(rmi_dev);\n\n\t\tif (rmi_dev->xport->ops->reset) {\n\t\t\terror = rmi_dev->xport->ops->reset(rmi_dev->xport,\n\t\t\t\t\t\t\t\tcmd_addr);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\treturn RMI_SCAN_DONE;\n\t\t}\n\n\t\trmi_dbg(RMI_DEBUG_CORE, &rmi_dev->dev, \"Sending reset\\n\");\n\t\terror = rmi_write_block(rmi_dev, cmd_addr, &cmd_buf, 1);\n\t\tif (error) {\n\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\"Initial reset failed. Code = %d.\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\tmdelay(pdata->reset_delay_ms ?: DEFAULT_RESET_DELAY_MS);\n\n\t\treturn RMI_SCAN_DONE;\n\t}\n\n\t \n\treturn pdt->page_start == 0 ? RMI_SCAN_CONTINUE : -ENODEV;\n}\n\nstatic int rmi_create_function(struct rmi_device *rmi_dev,\n\t\t\t       void *ctx, const struct pdt_entry *pdt)\n{\n\tstruct device *dev = &rmi_dev->dev;\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tint *current_irq_count = ctx;\n\tstruct rmi_function *fn;\n\tint i;\n\tint error;\n\n\trmi_dbg(RMI_DEBUG_CORE, dev, \"Initializing F%02X.\\n\",\n\t\t\tpdt->function_number);\n\n\tfn = kzalloc(sizeof(struct rmi_function) +\n\t\t\tBITS_TO_LONGS(data->irq_count) * sizeof(unsigned long),\n\t\t     GFP_KERNEL);\n\tif (!fn) {\n\t\tdev_err(dev, \"Failed to allocate memory for F%02X\\n\",\n\t\t\tpdt->function_number);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&fn->node);\n\trmi_driver_copy_pdt_to_fd(pdt, &fn->fd);\n\n\tfn->rmi_dev = rmi_dev;\n\n\tfn->num_of_irqs = pdt->interrupt_source_count;\n\tfn->irq_pos = *current_irq_count;\n\t*current_irq_count += fn->num_of_irqs;\n\n\tfor (i = 0; i < fn->num_of_irqs; i++)\n\t\tset_bit(fn->irq_pos + i, fn->irq_mask);\n\n\terror = rmi_register_function(fn);\n\tif (error)\n\t\treturn error;\n\n\tif (pdt->function_number == 0x01)\n\t\tdata->f01_container = fn;\n\telse if (pdt->function_number == 0x34)\n\t\tdata->f34_container = fn;\n\n\tlist_add_tail(&fn->node, &data->function_list);\n\n\treturn RMI_SCAN_CONTINUE;\n}\n\nvoid rmi_enable_irq(struct rmi_device *rmi_dev, bool clear_wake)\n{\n\tstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tint irq = pdata->irq;\n\tint irq_flags;\n\tint retval;\n\n\tmutex_lock(&data->enabled_mutex);\n\n\tif (data->enabled)\n\t\tgoto out;\n\n\tenable_irq(irq);\n\tdata->enabled = true;\n\tif (clear_wake && device_may_wakeup(rmi_dev->xport->dev)) {\n\t\tretval = disable_irq_wake(irq);\n\t\tif (retval)\n\t\t\tdev_warn(&rmi_dev->dev,\n\t\t\t\t \"Failed to disable irq for wake: %d\\n\",\n\t\t\t\t retval);\n\t}\n\n\t \n\tirq_flags = irq_get_trigger_type(pdata->irq);\n\tif (irq_flags & IRQ_TYPE_EDGE_BOTH)\n\t\trmi_process_interrupt_requests(rmi_dev);\n\nout:\n\tmutex_unlock(&data->enabled_mutex);\n}\n\nvoid rmi_disable_irq(struct rmi_device *rmi_dev, bool enable_wake)\n{\n\tstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi4_attn_data attn_data = {0};\n\tint irq = pdata->irq;\n\tint retval, count;\n\n\tmutex_lock(&data->enabled_mutex);\n\n\tif (!data->enabled)\n\t\tgoto out;\n\n\tdata->enabled = false;\n\tdisable_irq(irq);\n\tif (enable_wake && device_may_wakeup(rmi_dev->xport->dev)) {\n\t\tretval = enable_irq_wake(irq);\n\t\tif (retval)\n\t\t\tdev_warn(&rmi_dev->dev,\n\t\t\t\t \"Failed to enable irq for wake: %d\\n\",\n\t\t\t\t retval);\n\t}\n\n\t \n\twhile (!kfifo_is_empty(&data->attn_fifo)) {\n\t\tcount = kfifo_get(&data->attn_fifo, &attn_data);\n\t\tif (count)\n\t\t\tkfree(attn_data.data);\n\t}\n\nout:\n\tmutex_unlock(&data->enabled_mutex);\n}\n\nint rmi_driver_suspend(struct rmi_device *rmi_dev, bool enable_wake)\n{\n\tint retval;\n\n\tretval = rmi_suspend_functions(rmi_dev);\n\tif (retval)\n\t\tdev_warn(&rmi_dev->dev, \"Failed to suspend functions: %d\\n\",\n\t\t\tretval);\n\n\trmi_disable_irq(rmi_dev, enable_wake);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rmi_driver_suspend);\n\nint rmi_driver_resume(struct rmi_device *rmi_dev, bool clear_wake)\n{\n\tint retval;\n\n\trmi_enable_irq(rmi_dev, clear_wake);\n\n\tretval = rmi_resume_functions(rmi_dev);\n\tif (retval)\n\t\tdev_warn(&rmi_dev->dev, \"Failed to suspend functions: %d\\n\",\n\t\t\tretval);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rmi_driver_resume);\n\nstatic int rmi_driver_remove(struct device *dev)\n{\n\tstruct rmi_device *rmi_dev = to_rmi_device(dev);\n\tstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\n\n\trmi_disable_irq(rmi_dev, false);\n\n\tirq_domain_remove(data->irqdomain);\n\tdata->irqdomain = NULL;\n\n\trmi_f34_remove_sysfs(rmi_dev);\n\trmi_free_function_list(rmi_dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic int rmi_driver_of_probe(struct device *dev,\n\t\t\t\tstruct rmi_device_platform_data *pdata)\n{\n\tint retval;\n\n\tretval = rmi_of_property_read_u32(dev, &pdata->reset_delay_ms,\n\t\t\t\t\t\"syna,reset-delay-ms\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}\n#else\nstatic inline int rmi_driver_of_probe(struct device *dev,\n\t\t\t\t\tstruct rmi_device_platform_data *pdata)\n{\n\treturn -ENODEV;\n}\n#endif\n\nint rmi_probe_interrupts(struct rmi_driver_data *data)\n{\n\tstruct rmi_device *rmi_dev = data->rmi_dev;\n\tstruct device *dev = &rmi_dev->dev;\n\tstruct fwnode_handle *fwnode = rmi_dev->xport->dev->fwnode;\n\tint irq_count = 0;\n\tsize_t size;\n\tint retval;\n\n\t \n\trmi_dbg(RMI_DEBUG_CORE, dev, \"%s: Counting IRQs.\\n\", __func__);\n\tdata->bootloader_mode = false;\n\n\tretval = rmi_scan_pdt(rmi_dev, &irq_count, rmi_count_irqs);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"IRQ counting failed with code %d.\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tif (data->bootloader_mode)\n\t\tdev_warn(dev, \"Device in bootloader mode.\\n\");\n\n\t \n\tdata->irqdomain = irq_domain_create_linear(fwnode, irq_count,\n\t\t\t\t\t\t   &irq_domain_simple_ops,\n\t\t\t\t\t\t   data);\n\tif (!data->irqdomain) {\n\t\tdev_err(&rmi_dev->dev, \"Failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->irq_count = irq_count;\n\tdata->num_of_irq_regs = (data->irq_count + 7) / 8;\n\n\tsize = BITS_TO_LONGS(data->irq_count) * sizeof(unsigned long);\n\tdata->irq_memory = devm_kcalloc(dev, size, 4, GFP_KERNEL);\n\tif (!data->irq_memory) {\n\t\tdev_err(dev, \"Failed to allocate memory for irq masks.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->irq_status\t= data->irq_memory + size * 0;\n\tdata->fn_irq_bits\t= data->irq_memory + size * 1;\n\tdata->current_irq_mask\t= data->irq_memory + size * 2;\n\tdata->new_irq_mask\t= data->irq_memory + size * 3;\n\n\treturn retval;\n}\n\nint rmi_init_functions(struct rmi_driver_data *data)\n{\n\tstruct rmi_device *rmi_dev = data->rmi_dev;\n\tstruct device *dev = &rmi_dev->dev;\n\tint irq_count = 0;\n\tint retval;\n\n\trmi_dbg(RMI_DEBUG_CORE, dev, \"%s: Creating functions.\\n\", __func__);\n\tretval = rmi_scan_pdt(rmi_dev, &irq_count, rmi_create_function);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"Function creation failed with code %d.\\n\",\n\t\t\tretval);\n\t\tgoto err_destroy_functions;\n\t}\n\n\tif (!data->f01_container) {\n\t\tdev_err(dev, \"Missing F01 container!\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err_destroy_functions;\n\t}\n\n\tretval = rmi_read_block(rmi_dev,\n\t\t\t\tdata->f01_container->fd.control_base_addr + 1,\n\t\t\t\tdata->current_irq_mask, data->num_of_irq_regs);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"%s: Failed to read current IRQ mask.\\n\",\n\t\t\t__func__);\n\t\tgoto err_destroy_functions;\n\t}\n\n\treturn 0;\n\nerr_destroy_functions:\n\trmi_free_function_list(rmi_dev);\n\treturn retval;\n}\n\nstatic int rmi_driver_probe(struct device *dev)\n{\n\tstruct rmi_driver *rmi_driver;\n\tstruct rmi_driver_data *data;\n\tstruct rmi_device_platform_data *pdata;\n\tstruct rmi_device *rmi_dev;\n\tint retval;\n\n\trmi_dbg(RMI_DEBUG_CORE, dev, \"%s: Starting probe.\\n\",\n\t\t\t__func__);\n\n\tif (!rmi_is_physical_device(dev)) {\n\t\trmi_dbg(RMI_DEBUG_CORE, dev, \"Not a physical device.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trmi_dev = to_rmi_device(dev);\n\trmi_driver = to_rmi_driver(dev->driver);\n\trmi_dev->driver = rmi_driver;\n\n\tpdata = rmi_get_platform_data(rmi_dev);\n\n\tif (rmi_dev->xport->dev->of_node) {\n\t\tretval = rmi_driver_of_probe(rmi_dev->xport->dev, pdata);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(struct rmi_driver_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&data->function_list);\n\tdata->rmi_dev = rmi_dev;\n\tdev_set_drvdata(&rmi_dev->dev, data);\n\n\t \n\tretval = rmi_scan_pdt(rmi_dev, NULL, rmi_initial_reset);\n\tif (retval < 0)\n\t\tdev_warn(dev, \"RMI initial reset failed! Continuing in spite of this.\\n\");\n\n\tretval = rmi_read(rmi_dev, PDT_PROPERTIES_LOCATION, &data->pdt_props);\n\tif (retval < 0) {\n\t\t \n\t\tdev_warn(dev, \"Could not read PDT properties from %#06x (code %d). Assuming 0x00.\\n\",\n\t\t\t PDT_PROPERTIES_LOCATION, retval);\n\t}\n\n\tmutex_init(&data->irq_mutex);\n\tmutex_init(&data->enabled_mutex);\n\n\tretval = rmi_probe_interrupts(data);\n\tif (retval)\n\t\tgoto err;\n\n\tif (rmi_dev->xport->input) {\n\t\t \n\t\tdata->input = rmi_dev->xport->input;\n\t} else {\n\t\tdata->input = devm_input_allocate_device(dev);\n\t\tif (!data->input) {\n\t\t\tdev_err(dev, \"%s: Failed to allocate input device.\\n\",\n\t\t\t\t__func__);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\trmi_driver_set_input_params(rmi_dev, data->input);\n\t\tdata->input->phys = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\"%s/input0\", dev_name(dev));\n\t}\n\n\tretval = rmi_init_functions(data);\n\tif (retval)\n\t\tgoto err;\n\n\tretval = rmi_f34_create_sysfs(rmi_dev);\n\tif (retval)\n\t\tgoto err;\n\n\tif (data->input) {\n\t\trmi_driver_set_input_name(rmi_dev, data->input);\n\t\tif (!rmi_dev->xport->input) {\n\t\t\tretval = input_register_device(data->input);\n\t\t\tif (retval) {\n\t\t\t\tdev_err(dev, \"%s: Failed to register input device.\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tgoto err_destroy_functions;\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = rmi_irq_init(rmi_dev);\n\tif (retval < 0)\n\t\tgoto err_destroy_functions;\n\n\tif (data->f01_container->dev.driver) {\n\t\t \n\t\tretval = rmi_enable_sensor(rmi_dev);\n\t\tif (retval)\n\t\t\tgoto err_disable_irq;\n\t}\n\n\treturn 0;\n\nerr_disable_irq:\n\trmi_disable_irq(rmi_dev, false);\nerr_destroy_functions:\n\trmi_free_function_list(rmi_dev);\nerr:\n\treturn retval;\n}\n\nstatic struct rmi_driver rmi_physical_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"rmi4_physical\",\n\t\t.bus\t= &rmi_bus_type,\n\t\t.probe = rmi_driver_probe,\n\t\t.remove = rmi_driver_remove,\n\t},\n\t.reset_handler = rmi_driver_reset_handler,\n\t.clear_irq_bits = rmi_driver_clear_irq_bits,\n\t.set_irq_bits = rmi_driver_set_irq_bits,\n\t.set_input_params = rmi_driver_set_input_params,\n};\n\nbool rmi_is_physical_driver(struct device_driver *drv)\n{\n\treturn drv == &rmi_physical_driver.driver;\n}\n\nint __init rmi_register_physical_driver(void)\n{\n\tint error;\n\n\terror = driver_register(&rmi_physical_driver.driver);\n\tif (error) {\n\t\tpr_err(\"%s: driver register failed, code=%d.\\n\", __func__,\n\t\t       error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nvoid __exit rmi_unregister_physical_driver(void)\n{\n\tdriver_unregister(&rmi_physical_driver.driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}