{
  "module_name": "rmi_f30.c",
  "hash_id": "33e164fb298cb405cefb6ee3ea8b8689c97ae60c211ffe3ee3d7a2851b0ac4f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f30.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include \"rmi_driver.h\"\n\n#define RMI_F30_QUERY_SIZE\t\t\t2\n\n \n#define RMI_F30_EXTENDED_PATTERNS\t\t0x01\n#define RMI_F30_HAS_MAPPABLE_BUTTONS\t\tBIT(1)\n#define RMI_F30_HAS_LED\t\t\t\tBIT(2)\n#define RMI_F30_HAS_GPIO\t\t\tBIT(3)\n#define RMI_F30_HAS_HAPTIC\t\t\tBIT(4)\n#define RMI_F30_HAS_GPIO_DRV_CTL\t\tBIT(5)\n#define RMI_F30_HAS_MECH_MOUSE_BTNS\t\tBIT(6)\n\n \n#define RMI_F30_GPIO_LED_COUNT\t\t\t0x1F\n\n \n#define RMI_F30_CTRL_1_GPIO_DEBOUNCE\t\t0x01\n#define RMI_F30_CTRL_1_HALT\t\t\tBIT(4)\n#define RMI_F30_CTRL_1_HALTED\t\t\tBIT(5)\n#define RMI_F30_CTRL_10_NUM_MECH_MOUSE_BTNS\t0x03\n\n#define RMI_F30_CTRL_MAX_REGS\t\t32\n#define RMI_F30_CTRL_MAX_BYTES\t\tDIV_ROUND_UP(RMI_F30_CTRL_MAX_REGS, 8)\n#define RMI_F30_CTRL_MAX_REG_BLOCKS\t11\n\n#define RMI_F30_CTRL_REGS_MAX_SIZE (RMI_F30_CTRL_MAX_BYTES\t\t\\\n\t\t\t\t\t+ 1\t\t\t\t\\\n\t\t\t\t\t+ RMI_F30_CTRL_MAX_BYTES\t\\\n\t\t\t\t\t+ RMI_F30_CTRL_MAX_BYTES\t\\\n\t\t\t\t\t+ RMI_F30_CTRL_MAX_BYTES\t\\\n\t\t\t\t\t+ 6\t\t\t\t\\\n\t\t\t\t\t+ RMI_F30_CTRL_MAX_REGS\t\t\\\n\t\t\t\t\t+ RMI_F30_CTRL_MAX_REGS\t\t\\\n\t\t\t\t\t+ RMI_F30_CTRL_MAX_BYTES\t\\\n\t\t\t\t\t+ 1\t\t\t\t\\\n\t\t\t\t\t+ 1)\n\n#define TRACKSTICK_RANGE_START\t\t3\n#define TRACKSTICK_RANGE_END\t\t6\n\nstruct rmi_f30_ctrl_data {\n\tint address;\n\tint length;\n\tu8 *regs;\n};\n\nstruct f30_data {\n\t \n\tbool has_extended_pattern;\n\tbool has_mappable_buttons;\n\tbool has_led;\n\tbool has_gpio;\n\tbool has_haptic;\n\tbool has_gpio_driver_control;\n\tbool has_mech_mouse_btns;\n\tu8 gpioled_count;\n\n\tu8 register_count;\n\n\t \n\tstruct rmi_f30_ctrl_data ctrl[RMI_F30_CTRL_MAX_REG_BLOCKS];\n\tu8 ctrl_regs[RMI_F30_CTRL_REGS_MAX_SIZE];\n\tu32 ctrl_regs_size;\n\n\tu8 data_regs[RMI_F30_CTRL_MAX_BYTES];\n\tu16 *gpioled_key_map;\n\n\tstruct input_dev *input;\n\n\tstruct rmi_function *f03;\n\tbool trackstick_buttons;\n};\n\nstatic int rmi_f30_read_control_parameters(struct rmi_function *fn,\n\t\t\t\t\t\tstruct f30_data *f30)\n{\n\tint error;\n\n\terror = rmi_read_block(fn->rmi_dev, fn->fd.control_base_addr,\n\t\t\t       f30->ctrl_regs, f30->ctrl_regs_size);\n\tif (error) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"%s: Could not read control registers at 0x%x: %d\\n\",\n\t\t\t__func__, fn->fd.control_base_addr, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void rmi_f30_report_button(struct rmi_function *fn,\n\t\t\t\t  struct f30_data *f30, unsigned int button)\n{\n\tunsigned int reg_num = button >> 3;\n\tunsigned int bit_num = button & 0x07;\n\tu16 key_code = f30->gpioled_key_map[button];\n\tbool key_down = !(f30->data_regs[reg_num] & BIT(bit_num));\n\n\tif (f30->trackstick_buttons &&\n\t    button >= TRACKSTICK_RANGE_START &&\n\t    button <= TRACKSTICK_RANGE_END) {\n\t\trmi_f03_overwrite_button(f30->f03, key_code, key_down);\n\t} else {\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev,\n\t\t\t\"%s: call input report key (0x%04x) value (0x%02x)\",\n\t\t\t__func__, key_code, key_down);\n\n\t\tinput_report_key(f30->input, key_code, key_down);\n\t}\n}\n\nstatic irqreturn_t rmi_f30_attention(int irq, void *ctx)\n{\n\tstruct rmi_function *fn = ctx;\n\tstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&fn->rmi_dev->dev);\n\tint error;\n\tint i;\n\n\t \n\tif (drvdata->attn_data.data) {\n\t\tif (drvdata->attn_data.size < f30->register_count) {\n\t\t\tdev_warn(&fn->dev,\n\t\t\t\t \"F30 interrupted, but data is missing\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tmemcpy(f30->data_regs, drvdata->attn_data.data,\n\t\t\tf30->register_count);\n\t\tdrvdata->attn_data.data += f30->register_count;\n\t\tdrvdata->attn_data.size -= f30->register_count;\n\t} else {\n\t\terror = rmi_read_block(fn->rmi_dev, fn->fd.data_base_addr,\n\t\t\t\t       f30->data_regs, f30->register_count);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"%s: Failed to read F30 data registers: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\treturn IRQ_RETVAL(error);\n\t\t}\n\t}\n\n\tif (f30->has_gpio) {\n\t\tfor (i = 0; i < f30->gpioled_count; i++)\n\t\t\tif (f30->gpioled_key_map[i] != KEY_RESERVED)\n\t\t\t\trmi_f30_report_button(fn, f30, i);\n\t\tif (f30->trackstick_buttons)\n\t\t\trmi_f03_commit_buttons(f30->f03);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rmi_f30_config(struct rmi_function *fn)\n{\n\tstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\n\tstruct rmi_driver *drv = fn->rmi_dev->driver;\n\tconst struct rmi_device_platform_data *pdata =\n\t\t\t\trmi_get_platform_data(fn->rmi_dev);\n\tint error;\n\n\t \n\tif (!f30)\n\t\treturn 0;\n\n\tif (pdata->gpio_data.trackstick_buttons) {\n\t\t \n\t\tf30->f03 = rmi_find_function(fn->rmi_dev, 0x03);\n\t\tf30->trackstick_buttons = f30->f03 != NULL;\n\t}\n\n\tif (pdata->gpio_data.disable) {\n\t\tdrv->clear_irq_bits(fn->rmi_dev, fn->irq_mask);\n\t} else {\n\t\t \n\t\terror = rmi_write_block(fn->rmi_dev, fn->fd.control_base_addr,\n\t\t\t\t\tf30->ctrl_regs, f30->ctrl_regs_size);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"%s: Could not write control registers at 0x%x: %d\\n\",\n\t\t\t\t__func__, fn->fd.control_base_addr, error);\n\t\t\treturn error;\n\t\t}\n\n\t\tdrv->set_irq_bits(fn->rmi_dev, fn->irq_mask);\n\t}\n\n\treturn 0;\n}\n\nstatic void rmi_f30_set_ctrl_data(struct rmi_f30_ctrl_data *ctrl,\n\t\t\t\t  int *ctrl_addr, int len, u8 **reg)\n{\n\tctrl->address = *ctrl_addr;\n\tctrl->length = len;\n\tctrl->regs = *reg;\n\t*ctrl_addr += len;\n\t*reg += len;\n}\n\nstatic bool rmi_f30_is_valid_button(int button, struct rmi_f30_ctrl_data *ctrl)\n{\n\tint byte_position = button >> 3;\n\tint bit_position = button & 0x07;\n\n\t \n\treturn !(ctrl[2].regs[byte_position] & BIT(bit_position)) &&\n\t\t(ctrl[3].regs[byte_position] & BIT(bit_position));\n}\n\nstatic int rmi_f30_map_gpios(struct rmi_function *fn,\n\t\t\t     struct f30_data *f30)\n{\n\tconst struct rmi_device_platform_data *pdata =\n\t\t\t\t\trmi_get_platform_data(fn->rmi_dev);\n\tstruct input_dev *input = f30->input;\n\tunsigned int button = BTN_LEFT;\n\tunsigned int trackstick_button = BTN_LEFT;\n\tbool button_mapped = false;\n\tint i;\n\tint button_count = min_t(u8, f30->gpioled_count, TRACKSTICK_RANGE_END);\n\n\tf30->gpioled_key_map = devm_kcalloc(&fn->dev,\n\t\t\t\t\t    button_count,\n\t\t\t\t\t    sizeof(f30->gpioled_key_map[0]),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!f30->gpioled_key_map) {\n\t\tdev_err(&fn->dev, \"Failed to allocate gpioled map memory.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < button_count; i++) {\n\t\tif (!rmi_f30_is_valid_button(i, f30->ctrl))\n\t\t\tcontinue;\n\n\t\tif (pdata->gpio_data.trackstick_buttons &&\n\t\t    i >= TRACKSTICK_RANGE_START && i < TRACKSTICK_RANGE_END) {\n\t\t\tf30->gpioled_key_map[i] = trackstick_button++;\n\t\t} else if (!pdata->gpio_data.buttonpad || !button_mapped) {\n\t\t\tf30->gpioled_key_map[i] = button;\n\t\t\tinput_set_capability(input, EV_KEY, button++);\n\t\t\tbutton_mapped = true;\n\t\t}\n\t}\n\n\tinput->keycode = f30->gpioled_key_map;\n\tinput->keycodesize = sizeof(f30->gpioled_key_map[0]);\n\tinput->keycodemax = f30->gpioled_count;\n\n\t \n\tif (pdata->gpio_data.buttonpad || (button - BTN_LEFT == 1))\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\treturn 0;\n}\n\nstatic int rmi_f30_initialize(struct rmi_function *fn, struct f30_data *f30)\n{\n\tu8 *ctrl_reg = f30->ctrl_regs;\n\tint control_address = fn->fd.control_base_addr;\n\tu8 buf[RMI_F30_QUERY_SIZE];\n\tint error;\n\n\terror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr,\n\t\t\t       buf, RMI_F30_QUERY_SIZE);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to read query register\\n\");\n\t\treturn error;\n\t}\n\n\tf30->has_extended_pattern = buf[0] & RMI_F30_EXTENDED_PATTERNS;\n\tf30->has_mappable_buttons = buf[0] & RMI_F30_HAS_MAPPABLE_BUTTONS;\n\tf30->has_led = buf[0] & RMI_F30_HAS_LED;\n\tf30->has_gpio = buf[0] & RMI_F30_HAS_GPIO;\n\tf30->has_haptic = buf[0] & RMI_F30_HAS_HAPTIC;\n\tf30->has_gpio_driver_control = buf[0] & RMI_F30_HAS_GPIO_DRV_CTL;\n\tf30->has_mech_mouse_btns = buf[0] & RMI_F30_HAS_MECH_MOUSE_BTNS;\n\tf30->gpioled_count = buf[1] & RMI_F30_GPIO_LED_COUNT;\n\n\tf30->register_count = DIV_ROUND_UP(f30->gpioled_count, 8);\n\n\tif (f30->has_gpio && f30->has_led)\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[0], &control_address,\n\t\t\t\t      f30->register_count, &ctrl_reg);\n\n\trmi_f30_set_ctrl_data(&f30->ctrl[1], &control_address,\n\t\t\t      sizeof(u8), &ctrl_reg);\n\n\tif (f30->has_gpio) {\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[2], &control_address,\n\t\t\t\t      f30->register_count, &ctrl_reg);\n\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[3], &control_address,\n\t\t\t\t      f30->register_count, &ctrl_reg);\n\t}\n\n\tif (f30->has_led) {\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[4], &control_address,\n\t\t\t\t      f30->register_count, &ctrl_reg);\n\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[5], &control_address,\n\t\t\t\t      f30->has_extended_pattern ? 6 : 2,\n\t\t\t\t      &ctrl_reg);\n\t}\n\n\tif (f30->has_led || f30->has_gpio_driver_control) {\n\t\t \n\t\trmi_f30_set_ctrl_data(&f30->ctrl[6], &control_address,\n\t\t\t\t      f30->gpioled_count, &ctrl_reg);\n\t}\n\n\tif (f30->has_mappable_buttons) {\n\t\t \n\t\trmi_f30_set_ctrl_data(&f30->ctrl[7], &control_address,\n\t\t\t\t      f30->gpioled_count, &ctrl_reg);\n\t}\n\n\tif (f30->has_haptic) {\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[8], &control_address,\n\t\t\t\t      f30->register_count, &ctrl_reg);\n\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[9], &control_address,\n\t\t\t\t      sizeof(u8), &ctrl_reg);\n\t}\n\n\tif (f30->has_mech_mouse_btns)\n\t\trmi_f30_set_ctrl_data(&f30->ctrl[10], &control_address,\n\t\t\t\t      sizeof(u8), &ctrl_reg);\n\n\tf30->ctrl_regs_size = ctrl_reg -\n\t\t\t\tf30->ctrl_regs ?: RMI_F30_CTRL_REGS_MAX_SIZE;\n\n\terror = rmi_f30_read_control_parameters(fn, f30);\n\tif (error) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to initialize F30 control params: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tif (f30->has_gpio) {\n\t\terror = rmi_f30_map_gpios(fn, f30);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f30_probe(struct rmi_function *fn)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tconst struct rmi_device_platform_data *pdata =\n\t\t\t\t\trmi_get_platform_data(rmi_dev);\n\tstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct f30_data *f30;\n\tint error;\n\n\tif (pdata->gpio_data.disable)\n\t\treturn 0;\n\n\tif (!drv_data->input) {\n\t\tdev_info(&fn->dev, \"F30: no input device found, ignoring\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tf30 = devm_kzalloc(&fn->dev, sizeof(*f30), GFP_KERNEL);\n\tif (!f30)\n\t\treturn -ENOMEM;\n\n\tf30->input = drv_data->input;\n\n\terror = rmi_f30_initialize(fn, f30);\n\tif (error)\n\t\treturn error;\n\n\tdev_set_drvdata(&fn->dev, f30);\n\treturn 0;\n}\n\nstruct rmi_function_handler rmi_f30_handler = {\n\t.driver = {\n\t\t.name = \"rmi4_f30\",\n\t},\n\t.func = 0x30,\n\t.probe = rmi_f30_probe,\n\t.config = rmi_f30_config,\n\t.attention = rmi_f30_attention,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}