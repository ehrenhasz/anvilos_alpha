{
  "module_name": "rmi_f55.c",
  "hash_id": "19046e2d3d29f1092d861469a958fdd89bc5447edb2dc1d7414e38a6a2ffa2f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f55.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/slab.h>\n#include \"rmi_driver.h\"\n\n#define F55_NAME\t\t\"rmi4_f55\"\n\n \n#define F55_NUM_RX_OFFSET\t0\n#define F55_NUM_TX_OFFSET\t1\n#define F55_PHYS_CHAR_OFFSET\t2\n\n \n#define F55_QUERY_LEN\t\t3\n\n \n#define F55_CAP_SENSOR_ASSIGN\tBIT(0)\n\nstruct f55_data {\n\tstruct rmi_function *fn;\n\n\tu8 qry[F55_QUERY_LEN];\n\tu8 num_rx_electrodes;\n\tu8 cfg_num_rx_electrodes;\n\tu8 num_tx_electrodes;\n\tu8 cfg_num_tx_electrodes;\n};\n\nstatic int rmi_f55_detect(struct rmi_function *fn)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct f55_data *f55;\n\tint error;\n\n\tf55 = dev_get_drvdata(&fn->dev);\n\n\terror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr,\n\t\t\t       &f55->qry, sizeof(f55->qry));\n\tif (error) {\n\t\tdev_err(&fn->dev, \"%s: Failed to query F55 properties\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\n\tf55->num_rx_electrodes = f55->qry[F55_NUM_RX_OFFSET];\n\tf55->num_tx_electrodes = f55->qry[F55_NUM_TX_OFFSET];\n\n\tf55->cfg_num_rx_electrodes = f55->num_rx_electrodes;\n\tf55->cfg_num_tx_electrodes = f55->num_rx_electrodes;\n\n\tdrv_data->num_rx_electrodes = f55->cfg_num_rx_electrodes;\n\tdrv_data->num_tx_electrodes = f55->cfg_num_rx_electrodes;\n\n\tif (f55->qry[F55_PHYS_CHAR_OFFSET] & F55_CAP_SENSOR_ASSIGN) {\n\t\tint i, total;\n\t\tu8 buf[256];\n\n\t\t \n\t\terror = rmi_read_block(fn->rmi_dev,\n\t\t\t\t       fn->fd.control_base_addr + 1,\n\t\t\t\t       buf, f55->num_rx_electrodes);\n\t\tif (!error) {\n\t\t\ttotal = 0;\n\t\t\tfor (i = 0; i < f55->num_rx_electrodes; i++) {\n\t\t\t\tif (buf[i] != 0xff)\n\t\t\t\t\ttotal++;\n\t\t\t}\n\t\t\tf55->cfg_num_rx_electrodes = total;\n\t\t\tdrv_data->num_rx_electrodes = total;\n\t\t}\n\n\t\terror = rmi_read_block(fn->rmi_dev,\n\t\t\t\t       fn->fd.control_base_addr + 2,\n\t\t\t\t       buf, f55->num_tx_electrodes);\n\t\tif (!error) {\n\t\t\ttotal = 0;\n\t\t\tfor (i = 0; i < f55->num_tx_electrodes; i++) {\n\t\t\t\tif (buf[i] != 0xff)\n\t\t\t\t\ttotal++;\n\t\t\t}\n\t\t\tf55->cfg_num_tx_electrodes = total;\n\t\t\tdrv_data->num_tx_electrodes = total;\n\t\t}\n\t}\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F55 num_rx_electrodes: %d (raw %d)\\n\",\n\t\tf55->cfg_num_rx_electrodes, f55->num_rx_electrodes);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F55 num_tx_electrodes: %d (raw %d)\\n\",\n\t\tf55->cfg_num_tx_electrodes, f55->num_tx_electrodes);\n\n\treturn 0;\n}\n\nstatic int rmi_f55_probe(struct rmi_function *fn)\n{\n\tstruct f55_data *f55;\n\n\tf55 = devm_kzalloc(&fn->dev, sizeof(struct f55_data), GFP_KERNEL);\n\tif (!f55)\n\t\treturn -ENOMEM;\n\n\tf55->fn = fn;\n\tdev_set_drvdata(&fn->dev, f55);\n\n\treturn rmi_f55_detect(fn);\n}\n\nstruct rmi_function_handler rmi_f55_handler = {\n\t.driver = {\n\t\t.name = F55_NAME,\n\t},\n\t.func = 0x55,\n\t.probe = rmi_f55_probe,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}