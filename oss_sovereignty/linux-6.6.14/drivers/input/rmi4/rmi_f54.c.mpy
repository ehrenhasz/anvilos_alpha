{
  "module_name": "rmi_f54.c",
  "hash_id": "52934d9c90ff10361fc7e0326a27075fcce7db6a98aa3e0cecc8e36d94c8d845",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f54.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ioctl.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-vmalloc.h>\n#include \"rmi_driver.h\"\n\n#define F54_NAME\t\t\"rmi4_f54\"\n\n \n#define F54_REPORT_DATA_OFFSET  3\n#define F54_FIFO_OFFSET         1\n#define F54_NUM_TX_OFFSET       1\n#define F54_NUM_RX_OFFSET       0\n\n \n#define F54_REPORT_DATA_SIZE\t32\n\n \n#define F54_GET_REPORT          1\n#define F54_FORCE_CAL           2\n\n \n#define F54_CAP_BASELINE\t(1 << 2)\n#define F54_CAP_IMAGE8\t\t(1 << 3)\n#define F54_CAP_IMAGE16\t\t(1 << 6)\n\n \nenum rmi_f54_report_type {\n\tF54_REPORT_NONE = 0,\n\tF54_8BIT_IMAGE = 1,\n\tF54_16BIT_IMAGE = 2,\n\tF54_RAW_16BIT_IMAGE = 3,\n\tF54_TRUE_BASELINE = 9,\n\tF54_FULL_RAW_CAP = 19,\n\tF54_FULL_RAW_CAP_RX_OFFSET_REMOVED = 20,\n\tF54_MAX_REPORT_TYPE,\n};\n\nstatic const char * const rmi_f54_report_type_names[] = {\n\t[F54_REPORT_NONE]\t\t= \"Unknown\",\n\t[F54_8BIT_IMAGE]\t\t= \"Normalized 8-Bit Image\",\n\t[F54_16BIT_IMAGE]\t\t= \"Normalized 16-Bit Image\",\n\t[F54_RAW_16BIT_IMAGE]\t\t= \"Raw 16-Bit Image\",\n\t[F54_TRUE_BASELINE]\t\t= \"True Baseline\",\n\t[F54_FULL_RAW_CAP]\t\t= \"Full Raw Capacitance\",\n\t[F54_FULL_RAW_CAP_RX_OFFSET_REMOVED]\n\t\t\t\t\t= \"Full Raw Capacitance RX Offset Removed\",\n};\n\nstruct f54_data {\n\tstruct rmi_function *fn;\n\n\tu8 num_rx_electrodes;\n\tu8 num_tx_electrodes;\n\tu8 capabilities;\n\tu16 clock_rate;\n\tu8 family;\n\n\tenum rmi_f54_report_type report_type;\n\tu8 *report_data;\n\tint report_size;\n\n\tbool is_busy;\n\tstruct mutex status_mutex;\n\tstruct mutex data_mutex;\n\n\tstruct workqueue_struct *workqueue;\n\tstruct delayed_work work;\n\tunsigned long timeout;\n\n\tstruct completion cmd_done;\n\n\t \n\tstruct v4l2_device v4l2;\n\tstruct v4l2_pix_format format;\n\tstruct video_device vdev;\n\tstruct vb2_queue queue;\n\tstruct mutex lock;\n\tu32 sequence;\n\tint input;\n\tenum rmi_f54_report_type inputs[F54_MAX_REPORT_TYPE];\n};\n\n \nstatic bool is_f54_report_type_valid(struct f54_data *f54,\n\t\t\t\t     enum rmi_f54_report_type reptype)\n{\n\tswitch (reptype) {\n\tcase F54_8BIT_IMAGE:\n\t\treturn f54->capabilities & F54_CAP_IMAGE8;\n\tcase F54_16BIT_IMAGE:\n\tcase F54_RAW_16BIT_IMAGE:\n\t\treturn f54->capabilities & F54_CAP_IMAGE16;\n\tcase F54_TRUE_BASELINE:\n\t\treturn f54->capabilities & F54_CAP_IMAGE16;\n\tcase F54_FULL_RAW_CAP:\n\tcase F54_FULL_RAW_CAP_RX_OFFSET_REMOVED:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic enum rmi_f54_report_type rmi_f54_get_reptype(struct f54_data *f54,\n\t\t\t\t\t\tunsigned int i)\n{\n\tif (i >= F54_MAX_REPORT_TYPE)\n\t\treturn F54_REPORT_NONE;\n\n\treturn f54->inputs[i];\n}\n\nstatic void rmi_f54_create_input_map(struct f54_data *f54)\n{\n\tint i = 0;\n\tenum rmi_f54_report_type reptype;\n\n\tfor (reptype = 1; reptype < F54_MAX_REPORT_TYPE; reptype++) {\n\t\tif (!is_f54_report_type_valid(f54, reptype))\n\t\t\tcontinue;\n\n\t\tf54->inputs[i++] = reptype;\n\t}\n\n\t \n}\n\nstatic int rmi_f54_request_report(struct rmi_function *fn, u8 report_type)\n{\n\tstruct f54_data *f54 = dev_get_drvdata(&fn->dev);\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint error;\n\n\t \n\tif (f54->report_type != report_type) {\n\t\terror = rmi_write(rmi_dev, f54->fn->fd.data_base_addr,\n\t\t\t\t  report_type);\n\t\tif (error)\n\t\t\treturn error;\n\t\tf54->report_type = report_type;\n\t}\n\n\t \n\tusleep_range(2000, 3000);\n\n\tmutex_lock(&f54->data_mutex);\n\n\terror = rmi_write(rmi_dev, fn->fd.command_base_addr, F54_GET_REPORT);\n\tif (error < 0)\n\t\tgoto unlock;\n\n\tinit_completion(&f54->cmd_done);\n\n\tf54->is_busy = 1;\n\tf54->timeout = jiffies + msecs_to_jiffies(100);\n\n\tqueue_delayed_work(f54->workqueue, &f54->work, 0);\n\nunlock:\n\tmutex_unlock(&f54->data_mutex);\n\n\treturn error;\n}\n\nstatic size_t rmi_f54_get_report_size(struct f54_data *f54)\n{\n\tstruct rmi_device *rmi_dev = f54->fn->rmi_dev;\n\tstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\n\tu8 rx = drv_data->num_rx_electrodes ? : f54->num_rx_electrodes;\n\tu8 tx = drv_data->num_tx_electrodes ? : f54->num_tx_electrodes;\n\tsize_t size;\n\n\tswitch (rmi_f54_get_reptype(f54, f54->input)) {\n\tcase F54_8BIT_IMAGE:\n\t\tsize = rx * tx;\n\t\tbreak;\n\tcase F54_16BIT_IMAGE:\n\tcase F54_RAW_16BIT_IMAGE:\n\tcase F54_TRUE_BASELINE:\n\tcase F54_FULL_RAW_CAP:\n\tcase F54_FULL_RAW_CAP_RX_OFFSET_REMOVED:\n\t\tsize = sizeof(u16) * rx * tx;\n\t\tbreak;\n\tdefault:\n\t\tsize = 0;\n\t}\n\n\treturn size;\n}\n\nstatic int rmi_f54_get_pixel_fmt(enum rmi_f54_report_type reptype, u32 *pixfmt)\n{\n\tint ret = 0;\n\n\tswitch (reptype) {\n\tcase F54_8BIT_IMAGE:\n\t\t*pixfmt = V4L2_TCH_FMT_DELTA_TD08;\n\t\tbreak;\n\n\tcase F54_16BIT_IMAGE:\n\t\t*pixfmt = V4L2_TCH_FMT_DELTA_TD16;\n\t\tbreak;\n\n\tcase F54_RAW_16BIT_IMAGE:\n\tcase F54_TRUE_BASELINE:\n\tcase F54_FULL_RAW_CAP:\n\tcase F54_FULL_RAW_CAP_RX_OFFSET_REMOVED:\n\t\t*pixfmt = V4L2_TCH_FMT_TU16;\n\t\tbreak;\n\n\tcase F54_REPORT_NONE:\n\tcase F54_MAX_REPORT_TYPE:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct v4l2_file_operations rmi_f54_video_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll,\n};\n\nstatic int rmi_f54_queue_setup(struct vb2_queue *q, unsigned int *nbuffers,\n\t\t\t       unsigned int *nplanes, unsigned int sizes[],\n\t\t\t       struct device *alloc_devs[])\n{\n\tstruct f54_data *f54 = q->drv_priv;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < rmi_f54_get_report_size(f54) ? -EINVAL : 0;\n\n\t*nplanes = 1;\n\tsizes[0] = rmi_f54_get_report_size(f54);\n\n\treturn 0;\n}\n\nstatic void rmi_f54_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct f54_data *f54 = vb2_get_drv_priv(vb->vb2_queue);\n\tu16 *ptr;\n\tenum vb2_buffer_state state;\n\tenum rmi_f54_report_type reptype;\n\tint ret;\n\n\tmutex_lock(&f54->status_mutex);\n\n\tvb2_set_plane_payload(vb, 0, 0);\n\treptype = rmi_f54_get_reptype(f54, f54->input);\n\tif (reptype == F54_REPORT_NONE) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\tgoto done;\n\t}\n\n\tif (f54->is_busy) {\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\tgoto done;\n\t}\n\n\tret = rmi_f54_request_report(f54->fn, reptype);\n\tif (ret) {\n\t\tdev_err(&f54->fn->dev, \"Error requesting F54 report\\n\");\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\tgoto done;\n\t}\n\n\t \n\tmutex_lock(&f54->data_mutex);\n\n\twhile (f54->is_busy) {\n\t\tmutex_unlock(&f54->data_mutex);\n\t\tif (!wait_for_completion_timeout(&f54->cmd_done,\n\t\t\t\t\t\t msecs_to_jiffies(1000))) {\n\t\t\tdev_err(&f54->fn->dev, \"Timed out\\n\");\n\t\t\tstate = VB2_BUF_STATE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t\tmutex_lock(&f54->data_mutex);\n\t}\n\n\tptr = vb2_plane_vaddr(vb, 0);\n\tif (!ptr) {\n\t\tdev_err(&f54->fn->dev, \"Error acquiring frame ptr\\n\");\n\t\tstate = VB2_BUF_STATE_ERROR;\n\t\tgoto data_done;\n\t}\n\n\tmemcpy(ptr, f54->report_data, f54->report_size);\n\tvb2_set_plane_payload(vb, 0, rmi_f54_get_report_size(f54));\n\tstate = VB2_BUF_STATE_DONE;\n\ndata_done:\n\tmutex_unlock(&f54->data_mutex);\ndone:\n\tvb->timestamp = ktime_get_ns();\n\tvbuf->field = V4L2_FIELD_NONE;\n\tvbuf->sequence = f54->sequence++;\n\tvb2_buffer_done(vb, state);\n\tmutex_unlock(&f54->status_mutex);\n}\n\nstatic void rmi_f54_stop_streaming(struct vb2_queue *q)\n{\n\tstruct f54_data *f54 = vb2_get_drv_priv(q);\n\n\tf54->sequence = 0;\n}\n\n \nstatic const struct vb2_ops rmi_f54_queue_ops = {\n\t.queue_setup            = rmi_f54_queue_setup,\n\t.buf_queue              = rmi_f54_buffer_queue,\n\t.stop_streaming\t\t= rmi_f54_stop_streaming,\n\t.wait_prepare           = vb2_ops_wait_prepare,\n\t.wait_finish            = vb2_ops_wait_finish,\n};\n\nstatic const struct vb2_queue rmi_f54_queue = {\n\t.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\n\t.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ,\n\t.buf_struct_size = sizeof(struct vb2_v4l2_buffer),\n\t.ops = &rmi_f54_queue_ops,\n\t.mem_ops = &vb2_vmalloc_memops,\n\t.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC,\n};\n\nstatic int rmi_f54_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct f54_data *f54 = video_drvdata(file);\n\n\tstrscpy(cap->driver, F54_NAME, sizeof(cap->driver));\n\tstrscpy(cap->card, SYNAPTICS_INPUT_DEVICE_NAME, sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t\"rmi4:%s\", dev_name(&f54->fn->dev));\n\n\treturn 0;\n}\n\nstatic int rmi_f54_vidioc_enum_input(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_input *i)\n{\n\tstruct f54_data *f54 = video_drvdata(file);\n\tenum rmi_f54_report_type reptype;\n\n\treptype = rmi_f54_get_reptype(f54, i->index);\n\tif (reptype == F54_REPORT_NONE)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_TOUCH;\n\n\tstrscpy(i->name, rmi_f54_report_type_names[reptype], sizeof(i->name));\n\treturn 0;\n}\n\nstatic int rmi_f54_set_input(struct f54_data *f54, unsigned int i)\n{\n\tstruct rmi_device *rmi_dev = f54->fn->rmi_dev;\n\tstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\n\tu8 rx = drv_data->num_rx_electrodes ? : f54->num_rx_electrodes;\n\tu8 tx = drv_data->num_tx_electrodes ? : f54->num_tx_electrodes;\n\tstruct v4l2_pix_format *f = &f54->format;\n\tenum rmi_f54_report_type reptype;\n\tint ret;\n\n\treptype = rmi_f54_get_reptype(f54, i);\n\tif (reptype == F54_REPORT_NONE)\n\t\treturn -EINVAL;\n\n\tret = rmi_f54_get_pixel_fmt(reptype, &f->pixelformat);\n\tif (ret)\n\t\treturn ret;\n\n\tf54->input = i;\n\n\tf->width = rx;\n\tf->height = tx;\n\tf->field = V4L2_FIELD_NONE;\n\tf->colorspace = V4L2_COLORSPACE_RAW;\n\tf->bytesperline = f->width * sizeof(u16);\n\tf->sizeimage = f->width * f->height * sizeof(u16);\n\n\treturn 0;\n}\n\nstatic int rmi_f54_vidioc_s_input(struct file *file, void *priv, unsigned int i)\n{\n\treturn rmi_f54_set_input(video_drvdata(file), i);\n}\n\nstatic int rmi_f54_vidioc_g_input(struct file *file, void *priv,\n\t\t\t\t  unsigned int *i)\n{\n\tstruct f54_data *f54 = video_drvdata(file);\n\n\t*i = f54->input;\n\n\treturn 0;\n}\n\nstatic int rmi_f54_vidioc_fmt(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct f54_data *f54 = video_drvdata(file);\n\n\tf->fmt.pix = f54->format;\n\n\treturn 0;\n}\n\nstatic int rmi_f54_vidioc_enum_fmt(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *fmt)\n{\n\tstruct f54_data *f54 = video_drvdata(file);\n\n\tif (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\tif (fmt->index)\n\t\treturn -EINVAL;\n\n\tfmt->pixelformat = f54->format.pixelformat;\n\n\treturn 0;\n}\n\nstatic int rmi_f54_vidioc_g_parm(struct file *file, void *fh,\n\t\t\t\t struct v4l2_streamparm *a)\n{\n\tif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\treturn -EINVAL;\n\n\ta->parm.capture.readbuffers = 1;\n\ta->parm.capture.timeperframe.numerator = 1;\n\ta->parm.capture.timeperframe.denominator = 10;\n\treturn 0;\n}\n\nstatic const struct v4l2_ioctl_ops rmi_f54_video_ioctl_ops = {\n\t.vidioc_querycap\t= rmi_f54_vidioc_querycap,\n\n\t.vidioc_enum_fmt_vid_cap = rmi_f54_vidioc_enum_fmt,\n\t.vidioc_s_fmt_vid_cap\t= rmi_f54_vidioc_fmt,\n\t.vidioc_g_fmt_vid_cap\t= rmi_f54_vidioc_fmt,\n\t.vidioc_try_fmt_vid_cap\t= rmi_f54_vidioc_fmt,\n\t.vidioc_g_parm\t\t= rmi_f54_vidioc_g_parm,\n\n\t.vidioc_enum_input\t= rmi_f54_vidioc_enum_input,\n\t.vidioc_g_input\t\t= rmi_f54_vidioc_g_input,\n\t.vidioc_s_input\t\t= rmi_f54_vidioc_s_input,\n\n\t.vidioc_reqbufs\t\t= vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs\t= vb2_ioctl_create_bufs,\n\t.vidioc_querybuf\t= vb2_ioctl_querybuf,\n\t.vidioc_qbuf\t\t= vb2_ioctl_qbuf,\n\t.vidioc_dqbuf\t\t= vb2_ioctl_dqbuf,\n\t.vidioc_expbuf\t\t= vb2_ioctl_expbuf,\n\n\t.vidioc_streamon\t= vb2_ioctl_streamon,\n\t.vidioc_streamoff\t= vb2_ioctl_streamoff,\n};\n\nstatic const struct video_device rmi_f54_video_device = {\n\t.name = \"Synaptics RMI4\",\n\t.fops = &rmi_f54_video_fops,\n\t.ioctl_ops = &rmi_f54_video_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TOUCH |\n\t\t       V4L2_CAP_READWRITE | V4L2_CAP_STREAMING,\n};\n\nstatic void rmi_f54_work(struct work_struct *work)\n{\n\tstruct f54_data *f54 = container_of(work, struct f54_data, work.work);\n\tstruct rmi_function *fn = f54->fn;\n\tu8 fifo[2];\n\tint report_size;\n\tu8 command;\n\tint error;\n\tint i;\n\n\treport_size = rmi_f54_get_report_size(f54);\n\tif (report_size == 0) {\n\t\tdev_err(&fn->dev, \"Bad report size, report type=%d\\n\",\n\t\t\t\tf54->report_type);\n\t\terror = -EINVAL;\n\t\tgoto error;      \n\t}\n\n\tmutex_lock(&f54->data_mutex);\n\n\t \n\terror = rmi_read(fn->rmi_dev, f54->fn->fd.command_base_addr,\n\t\t\t &command);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to read back command\\n\");\n\t\tgoto error;\n\t}\n\tif (command & F54_GET_REPORT) {\n\t\tif (time_after(jiffies, f54->timeout)) {\n\t\t\tdev_err(&fn->dev, \"Get report command timed out\\n\");\n\t\t\terror = -ETIMEDOUT;\n\t\t}\n\t\treport_size = 0;\n\t\tgoto error;\n\t}\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"Get report command completed, reading data\\n\");\n\n\tfor (i = 0; i < report_size; i += F54_REPORT_DATA_SIZE) {\n\t\tint size = min(F54_REPORT_DATA_SIZE, report_size - i);\n\n\t\tfifo[0] = i & 0xff;\n\t\tfifo[1] = i >> 8;\n\t\terror = rmi_write_block(fn->rmi_dev,\n\t\t\t\t\tfn->fd.data_base_addr + F54_FIFO_OFFSET,\n\t\t\t\t\tfifo, sizeof(fifo));\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev, \"Failed to set fifo start offset\\n\");\n\t\t\tgoto abort;\n\t\t}\n\n\t\terror = rmi_read_block(fn->rmi_dev, fn->fd.data_base_addr +\n\t\t\t\t       F54_REPORT_DATA_OFFSET,\n\t\t\t\t       f54->report_data + i, size);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev, \"%s: read [%d bytes] returned %d\\n\",\n\t\t\t\t__func__, size, error);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\nabort:\n\tf54->report_size = error ? 0 : report_size;\nerror:\n\tif (error)\n\t\treport_size = 0;\n\n\tif (report_size == 0 && !error) {\n\t\tqueue_delayed_work(f54->workqueue, &f54->work,\n\t\t\t\t   msecs_to_jiffies(1));\n\t} else {\n\t\tf54->is_busy = false;\n\t\tcomplete(&f54->cmd_done);\n\t}\n\n\tmutex_unlock(&f54->data_mutex);\n}\n\nstatic int rmi_f54_config(struct rmi_function *fn)\n{\n\tstruct rmi_driver *drv = fn->rmi_dev->driver;\n\n\tdrv->clear_irq_bits(fn->rmi_dev, fn->irq_mask);\n\n\treturn 0;\n}\n\nstatic int rmi_f54_detect(struct rmi_function *fn)\n{\n\tint error;\n\tstruct f54_data *f54;\n\tu8 buf[6];\n\n\tf54 = dev_get_drvdata(&fn->dev);\n\n\terror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr,\n\t\t\t       buf, sizeof(buf));\n\tif (error) {\n\t\tdev_err(&fn->dev, \"%s: Failed to query F54 properties\\n\",\n\t\t\t__func__);\n\t\treturn error;\n\t}\n\n\tf54->num_rx_electrodes = buf[0];\n\tf54->num_tx_electrodes = buf[1];\n\tf54->capabilities = buf[2];\n\tf54->clock_rate = buf[3] | (buf[4] << 8);\n\tf54->family = buf[5];\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F54 num_rx_electrodes: %d\\n\",\n\t\tf54->num_rx_electrodes);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F54 num_tx_electrodes: %d\\n\",\n\t\tf54->num_tx_electrodes);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F54 capabilities: 0x%x\\n\",\n\t\tf54->capabilities);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F54 clock rate: 0x%x\\n\",\n\t\tf54->clock_rate);\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"F54 family: 0x%x\\n\",\n\t\tf54->family);\n\n\tf54->is_busy = false;\n\n\treturn 0;\n}\n\nstatic int rmi_f54_probe(struct rmi_function *fn)\n{\n\tstruct f54_data *f54;\n\tint ret;\n\tu8 rx, tx;\n\n\tf54 = devm_kzalloc(&fn->dev, sizeof(struct f54_data), GFP_KERNEL);\n\tif (!f54)\n\t\treturn -ENOMEM;\n\n\tf54->fn = fn;\n\tdev_set_drvdata(&fn->dev, f54);\n\n\tret = rmi_f54_detect(fn);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&f54->data_mutex);\n\tmutex_init(&f54->status_mutex);\n\n\trx = f54->num_rx_electrodes;\n\ttx = f54->num_tx_electrodes;\n\tf54->report_data = devm_kzalloc(&fn->dev,\n\t\t\t\t\tarray3_size(tx, rx, sizeof(u16)),\n\t\t\t\t\tGFP_KERNEL);\n\tif (f54->report_data == NULL)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&f54->work, rmi_f54_work);\n\n\tf54->workqueue = create_singlethread_workqueue(\"rmi4-poller\");\n\tif (!f54->workqueue)\n\t\treturn -ENOMEM;\n\n\trmi_f54_create_input_map(f54);\n\trmi_f54_set_input(f54, 0);\n\n\t \n\tstrscpy(f54->v4l2.name, F54_NAME, sizeof(f54->v4l2.name));\n\tret = v4l2_device_register(&fn->dev, &f54->v4l2);\n\tif (ret) {\n\t\tdev_err(&fn->dev, \"Unable to register video dev.\\n\");\n\t\tgoto remove_wq;\n\t}\n\n\t \n\tmutex_init(&f54->lock);\n\tf54->queue = rmi_f54_queue;\n\tf54->queue.drv_priv = f54;\n\tf54->queue.lock = &f54->lock;\n\tf54->queue.dev = &fn->dev;\n\n\tret = vb2_queue_init(&f54->queue);\n\tif (ret)\n\t\tgoto remove_v4l2;\n\n\tf54->vdev = rmi_f54_video_device;\n\tf54->vdev.v4l2_dev = &f54->v4l2;\n\tf54->vdev.lock = &f54->lock;\n\tf54->vdev.vfl_dir = VFL_DIR_RX;\n\tf54->vdev.queue = &f54->queue;\n\tvideo_set_drvdata(&f54->vdev, f54);\n\n\tret = video_register_device(&f54->vdev, VFL_TYPE_TOUCH, -1);\n\tif (ret) {\n\t\tdev_err(&fn->dev, \"Unable to register video subdevice.\");\n\t\tgoto remove_v4l2;\n\t}\n\n\treturn 0;\n\nremove_v4l2:\n\tv4l2_device_unregister(&f54->v4l2);\nremove_wq:\n\tcancel_delayed_work_sync(&f54->work);\n\tdestroy_workqueue(f54->workqueue);\n\treturn ret;\n}\n\nstatic void rmi_f54_remove(struct rmi_function *fn)\n{\n\tstruct f54_data *f54 = dev_get_drvdata(&fn->dev);\n\n\tvideo_unregister_device(&f54->vdev);\n\tv4l2_device_unregister(&f54->v4l2);\n\tdestroy_workqueue(f54->workqueue);\n}\n\nstruct rmi_function_handler rmi_f54_handler = {\n\t.driver = {\n\t\t.name = F54_NAME,\n\t},\n\t.func = 0x54,\n\t.probe = rmi_f54_probe,\n\t.config = rmi_f54_config,\n\t.remove = rmi_f54_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}