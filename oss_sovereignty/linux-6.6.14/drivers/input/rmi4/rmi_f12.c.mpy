{
  "module_name": "rmi_f12.c",
  "hash_id": "026c074ba2f6dbfa3be6ff789cfa5f2b48ae41a19ec72e2405e4d9dee338d23f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f12.c",
  "human_readable_source": "\n \n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/rmi.h>\n#include \"rmi_driver.h\"\n#include \"rmi_2d_sensor.h\"\n\nenum rmi_f12_object_type {\n\tRMI_F12_OBJECT_NONE\t\t\t= 0x00,\n\tRMI_F12_OBJECT_FINGER\t\t\t= 0x01,\n\tRMI_F12_OBJECT_STYLUS\t\t\t= 0x02,\n\tRMI_F12_OBJECT_PALM\t\t\t= 0x03,\n\tRMI_F12_OBJECT_UNCLASSIFIED\t\t= 0x04,\n\tRMI_F12_OBJECT_GLOVED_FINGER\t\t= 0x06,\n\tRMI_F12_OBJECT_NARROW_OBJECT\t\t= 0x07,\n\tRMI_F12_OBJECT_HAND_EDGE\t\t= 0x08,\n\tRMI_F12_OBJECT_COVER\t\t\t= 0x0A,\n\tRMI_F12_OBJECT_STYLUS_2\t\t\t= 0x0B,\n\tRMI_F12_OBJECT_ERASER\t\t\t= 0x0C,\n\tRMI_F12_OBJECT_SMALL_OBJECT\t\t= 0x0D,\n};\n\n#define F12_DATA1_BYTES_PER_OBJ\t\t\t8\n\nstruct f12_data {\n\tstruct rmi_2d_sensor sensor;\n\tstruct rmi_2d_sensor_platform_data sensor_pdata;\n\tbool has_dribble;\n\n\tu16 data_addr;\n\n\tstruct rmi_register_descriptor query_reg_desc;\n\tstruct rmi_register_descriptor control_reg_desc;\n\tstruct rmi_register_descriptor data_reg_desc;\n\n\t \n\tconst struct rmi_register_desc_item *data1;\n\tu16 data1_offset;\n\n\t \n\tconst struct rmi_register_desc_item *data5;\n\tu16 data5_offset;\n\n\t \n\tconst struct rmi_register_desc_item *data6;\n\tu16 data6_offset;\n\n\n\t \n\tconst struct rmi_register_desc_item *data9;\n\tu16 data9_offset;\n\n\tconst struct rmi_register_desc_item *data15;\n\tu16 data15_offset;\n\n\tunsigned long *abs_mask;\n\tunsigned long *rel_mask;\n};\n\nstatic int rmi_f12_read_sensor_tuning(struct f12_data *f12)\n{\n\tconst struct rmi_register_desc_item *item;\n\tstruct rmi_2d_sensor *sensor = &f12->sensor;\n\tstruct rmi_function *fn = sensor->fn;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint ret;\n\tint offset;\n\tu8 buf[15];\n\tint pitch_x = 0;\n\tint pitch_y = 0;\n\tint rx_receivers = 0;\n\tint tx_receivers = 0;\n\n\titem = rmi_get_register_desc_item(&f12->control_reg_desc, 8);\n\tif (!item) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"F12 does not have the sensor tuning control register\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\toffset = rmi_register_desc_calc_reg_offset(&f12->control_reg_desc, 8);\n\n\tif (item->reg_size > sizeof(buf)) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"F12 control8 should be no bigger than %zd bytes, not: %ld\\n\",\n\t\t\tsizeof(buf), item->reg_size);\n\t\treturn -ENODEV;\n\t}\n\n\tret = rmi_read_block(rmi_dev, fn->fd.control_base_addr + offset, buf,\n\t\t\t\titem->reg_size);\n\tif (ret)\n\t\treturn ret;\n\n\toffset = 0;\n\tif (rmi_register_desc_has_subpacket(item, 0)) {\n\t\tsensor->max_x = (buf[offset + 1] << 8) | buf[offset];\n\t\tsensor->max_y = (buf[offset + 3] << 8) | buf[offset + 2];\n\t\toffset += 4;\n\t}\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"%s: max_x: %d max_y: %d\\n\", __func__,\n\t\tsensor->max_x, sensor->max_y);\n\n\tif (rmi_register_desc_has_subpacket(item, 1)) {\n\t\tpitch_x = (buf[offset + 1] << 8) | buf[offset];\n\t\tpitch_y\t= (buf[offset + 3] << 8) | buf[offset + 2];\n\t\toffset += 4;\n\t}\n\n\tif (rmi_register_desc_has_subpacket(item, 2)) {\n\t\t \n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev,\n\t\t\t\"%s: Inactive Border xlo:%d xhi:%d ylo:%d yhi:%d\\n\",\n\t\t\t__func__,\n\t\t\tbuf[offset], buf[offset + 1],\n\t\t\tbuf[offset + 2], buf[offset + 3]);\n\n\t\toffset += 4;\n\t}\n\n\tif (rmi_register_desc_has_subpacket(item, 3)) {\n\t\trx_receivers = buf[offset];\n\t\ttx_receivers = buf[offset + 1];\n\t\toffset += 2;\n\t}\n\n\t \n\tif (rmi_register_desc_has_subpacket(item, 4))\n\t\toffset += 1;\n\n\tsensor->x_mm = (pitch_x * rx_receivers) >> 12;\n\tsensor->y_mm = (pitch_y * tx_receivers) >> 12;\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"%s: x_mm: %d y_mm: %d\\n\", __func__,\n\t\tsensor->x_mm, sensor->y_mm);\n\n\treturn 0;\n}\n\nstatic void rmi_f12_process_objects(struct f12_data *f12, u8 *data1, int size)\n{\n\tint i;\n\tstruct rmi_2d_sensor *sensor = &f12->sensor;\n\tint objects = f12->data1->num_subpackets;\n\n\tif ((f12->data1->num_subpackets * F12_DATA1_BYTES_PER_OBJ) > size)\n\t\tobjects = size / F12_DATA1_BYTES_PER_OBJ;\n\n\tfor (i = 0; i < objects; i++) {\n\t\tstruct rmi_2d_sensor_abs_object *obj = &sensor->objs[i];\n\n\t\tobj->type = RMI_2D_OBJECT_NONE;\n\t\tobj->mt_tool = MT_TOOL_FINGER;\n\n\t\tswitch (data1[0]) {\n\t\tcase RMI_F12_OBJECT_FINGER:\n\t\t\tobj->type = RMI_2D_OBJECT_FINGER;\n\t\t\tbreak;\n\t\tcase RMI_F12_OBJECT_STYLUS:\n\t\t\tobj->type = RMI_2D_OBJECT_STYLUS;\n\t\t\tobj->mt_tool = MT_TOOL_PEN;\n\t\t\tbreak;\n\t\tcase RMI_F12_OBJECT_PALM:\n\t\t\tobj->type = RMI_2D_OBJECT_PALM;\n\t\t\tobj->mt_tool = MT_TOOL_PALM;\n\t\t\tbreak;\n\t\tcase RMI_F12_OBJECT_UNCLASSIFIED:\n\t\t\tobj->type = RMI_2D_OBJECT_UNCLASSIFIED;\n\t\t\tbreak;\n\t\t}\n\n\t\tobj->x = (data1[2] << 8) | data1[1];\n\t\tobj->y = (data1[4] << 8) | data1[3];\n\t\tobj->z = data1[5];\n\t\tobj->wx = data1[6];\n\t\tobj->wy = data1[7];\n\n\t\trmi_2d_sensor_abs_process(sensor, obj, i);\n\n\t\tdata1 += F12_DATA1_BYTES_PER_OBJ;\n\t}\n\n\tif (sensor->kernel_tracking)\n\t\tinput_mt_assign_slots(sensor->input,\n\t\t\t\t      sensor->tracking_slots,\n\t\t\t\t      sensor->tracking_pos,\n\t\t\t\t      sensor->nbr_fingers,\n\t\t\t\t      sensor->dmax);\n\n\tfor (i = 0; i < objects; i++)\n\t\trmi_2d_sensor_abs_report(sensor, &sensor->objs[i], i);\n}\n\nstatic irqreturn_t rmi_f12_attention(int irq, void *ctx)\n{\n\tint retval;\n\tstruct rmi_function *fn = ctx;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tstruct f12_data *f12 = dev_get_drvdata(&fn->dev);\n\tstruct rmi_2d_sensor *sensor = &f12->sensor;\n\tint valid_bytes = sensor->pkt_size;\n\n\tif (drvdata->attn_data.data) {\n\t\tif (sensor->attn_size > drvdata->attn_data.size)\n\t\t\tvalid_bytes = drvdata->attn_data.size;\n\t\telse\n\t\t\tvalid_bytes = sensor->attn_size;\n\t\tmemcpy(sensor->data_pkt, drvdata->attn_data.data,\n\t\t\tvalid_bytes);\n\t\tdrvdata->attn_data.data += valid_bytes;\n\t\tdrvdata->attn_data.size -= valid_bytes;\n\t} else {\n\t\tretval = rmi_read_block(rmi_dev, f12->data_addr,\n\t\t\t\t\tsensor->data_pkt, sensor->pkt_size);\n\t\tif (retval < 0) {\n\t\t\tdev_err(&fn->dev, \"Failed to read object data. Code: %d.\\n\",\n\t\t\t\tretval);\n\t\t\treturn IRQ_RETVAL(retval);\n\t\t}\n\t}\n\n\tif (f12->data1)\n\t\trmi_f12_process_objects(f12,\n\t\t\t&sensor->data_pkt[f12->data1_offset], valid_bytes);\n\n\tinput_mt_sync_frame(sensor->input);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rmi_f12_write_control_regs(struct rmi_function *fn)\n{\n\tint ret;\n\tconst struct rmi_register_desc_item *item;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct f12_data *f12 = dev_get_drvdata(&fn->dev);\n\tint control_size;\n\tchar buf[3];\n\tu16 control_offset = 0;\n\tu8 subpacket_offset = 0;\n\n\tif (f12->has_dribble\n\t    && (f12->sensor.dribble != RMI_REG_STATE_DEFAULT)) {\n\t\titem = rmi_get_register_desc_item(&f12->control_reg_desc, 20);\n\t\tif (item) {\n\t\t\tcontrol_offset = rmi_register_desc_calc_reg_offset(\n\t\t\t\t\t\t&f12->control_reg_desc, 20);\n\n\t\t\t \n\t\t\tcontrol_size = min(item->reg_size, 3UL);\n\n\t\t\tret = rmi_read_block(rmi_dev, fn->fd.control_base_addr\n\t\t\t\t\t+ control_offset, buf, control_size);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (rmi_register_desc_has_subpacket(item, 0))\n\t\t\t\tsubpacket_offset += 1;\n\n\t\t\tswitch (f12->sensor.dribble) {\n\t\t\tcase RMI_REG_STATE_OFF:\n\t\t\t\tbuf[subpacket_offset] &= ~BIT(2);\n\t\t\t\tbreak;\n\t\t\tcase RMI_REG_STATE_ON:\n\t\t\t\tbuf[subpacket_offset] |= BIT(2);\n\t\t\t\tbreak;\n\t\t\tcase RMI_REG_STATE_DEFAULT:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = rmi_write_block(rmi_dev,\n\t\t\t\tfn->fd.control_base_addr + control_offset,\n\t\t\t\tbuf, control_size);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nstatic int rmi_f12_config(struct rmi_function *fn)\n{\n\tstruct rmi_driver *drv = fn->rmi_dev->driver;\n\tstruct f12_data *f12 = dev_get_drvdata(&fn->dev);\n\tstruct rmi_2d_sensor *sensor;\n\tint ret;\n\n\tsensor = &f12->sensor;\n\n\tif (!sensor->report_abs)\n\t\tdrv->clear_irq_bits(fn->rmi_dev, f12->abs_mask);\n\telse\n\t\tdrv->set_irq_bits(fn->rmi_dev, f12->abs_mask);\n\n\tdrv->clear_irq_bits(fn->rmi_dev, f12->rel_mask);\n\n\tret = rmi_f12_write_control_regs(fn);\n\tif (ret)\n\t\tdev_warn(&fn->dev,\n\t\t\t\"Failed to write F12 control registers: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic int rmi_f12_probe(struct rmi_function *fn)\n{\n\tstruct f12_data *f12;\n\tint ret;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tchar buf;\n\tu16 query_addr = fn->fd.query_base_addr;\n\tconst struct rmi_register_desc_item *item;\n\tstruct rmi_2d_sensor *sensor;\n\tstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tu16 data_offset = 0;\n\tint mask_size;\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"%s\\n\", __func__);\n\n\tmask_size = BITS_TO_LONGS(drvdata->irq_count) * sizeof(unsigned long);\n\n\tret = rmi_read(fn->rmi_dev, query_addr, &buf);\n\tif (ret < 0) {\n\t\tdev_err(&fn->dev, \"Failed to read general info register: %d\\n\",\n\t\t\tret);\n\t\treturn -ENODEV;\n\t}\n\t++query_addr;\n\n\tif (!(buf & BIT(0))) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Behavior of F12 without register descriptors is undefined.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tf12 = devm_kzalloc(&fn->dev, sizeof(struct f12_data) + mask_size * 2,\n\t\t\tGFP_KERNEL);\n\tif (!f12)\n\t\treturn -ENOMEM;\n\n\tf12->abs_mask = (unsigned long *)((char *)f12\n\t\t\t+ sizeof(struct f12_data));\n\tf12->rel_mask = (unsigned long *)((char *)f12\n\t\t\t+ sizeof(struct f12_data) + mask_size);\n\n\tset_bit(fn->irq_pos, f12->abs_mask);\n\tset_bit(fn->irq_pos + 1, f12->rel_mask);\n\n\tf12->has_dribble = !!(buf & BIT(3));\n\n\tif (fn->dev.of_node) {\n\t\tret = rmi_2d_sensor_of_probe(&fn->dev, &f12->sensor_pdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tf12->sensor_pdata = pdata->sensor_pdata;\n\t}\n\n\tret = rmi_read_register_desc(rmi_dev, query_addr,\n\t\t\t\t\t&f12->query_reg_desc);\n\tif (ret) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to read the Query Register Descriptor: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tquery_addr += 3;\n\n\tret = rmi_read_register_desc(rmi_dev, query_addr,\n\t\t\t\t\t\t&f12->control_reg_desc);\n\tif (ret) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to read the Control Register Descriptor: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tquery_addr += 3;\n\n\tret = rmi_read_register_desc(rmi_dev, query_addr,\n\t\t\t\t\t\t&f12->data_reg_desc);\n\tif (ret) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to read the Data Register Descriptor: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tquery_addr += 3;\n\n\tsensor = &f12->sensor;\n\tsensor->fn = fn;\n\tf12->data_addr = fn->fd.data_base_addr;\n\tsensor->pkt_size = rmi_register_desc_calc_size(&f12->data_reg_desc);\n\n\tsensor->axis_align =\n\t\tf12->sensor_pdata.axis_align;\n\n\tsensor->x_mm = f12->sensor_pdata.x_mm;\n\tsensor->y_mm = f12->sensor_pdata.y_mm;\n\tsensor->dribble = f12->sensor_pdata.dribble;\n\n\tif (sensor->sensor_type == rmi_sensor_default)\n\t\tsensor->sensor_type =\n\t\t\tf12->sensor_pdata.sensor_type;\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"%s: data packet size: %d\\n\", __func__,\n\t\tsensor->pkt_size);\n\tsensor->data_pkt = devm_kzalloc(&fn->dev, sensor->pkt_size, GFP_KERNEL);\n\tif (!sensor->data_pkt)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&fn->dev, f12);\n\n\tret = rmi_f12_read_sensor_tuning(f12);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 0);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 1);\n\tif (item) {\n\t\tf12->data1 = item;\n\t\tf12->data1_offset = data_offset;\n\t\tdata_offset += item->reg_size;\n\t\tsensor->nbr_fingers = item->num_subpackets;\n\t\tsensor->report_abs = 1;\n\t\tsensor->attn_size += item->reg_size;\n\t}\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 2);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 3);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 4);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 5);\n\tif (item) {\n\t\tf12->data5 = item;\n\t\tf12->data5_offset = data_offset;\n\t\tdata_offset += item->reg_size;\n\t\tsensor->attn_size += item->reg_size;\n\t}\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 6);\n\tif (item && !drvdata->attn_data.data) {\n\t\tf12->data6 = item;\n\t\tf12->data6_offset = data_offset;\n\t\tdata_offset += item->reg_size;\n\t}\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 7);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 8);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 9);\n\tif (item && !drvdata->attn_data.data) {\n\t\tf12->data9 = item;\n\t\tf12->data9_offset = data_offset;\n\t\tdata_offset += item->reg_size;\n\t\tif (!sensor->report_abs)\n\t\t\tsensor->report_rel = 1;\n\t}\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 10);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 11);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 12);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 13);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 14);\n\tif (item && !drvdata->attn_data.data)\n\t\tdata_offset += item->reg_size;\n\n\titem = rmi_get_register_desc_item(&f12->data_reg_desc, 15);\n\tif (item && !drvdata->attn_data.data) {\n\t\tf12->data15 = item;\n\t\tf12->data15_offset = data_offset;\n\t\tdata_offset += item->reg_size;\n\t}\n\n\t \n\tsensor->tracking_pos = devm_kcalloc(&fn->dev,\n\t\t\tsensor->nbr_fingers, sizeof(struct input_mt_pos),\n\t\t\tGFP_KERNEL);\n\tsensor->tracking_slots = devm_kcalloc(&fn->dev,\n\t\t\tsensor->nbr_fingers, sizeof(int), GFP_KERNEL);\n\tsensor->objs = devm_kcalloc(&fn->dev,\n\t\t\tsensor->nbr_fingers,\n\t\t\tsizeof(struct rmi_2d_sensor_abs_object),\n\t\t\tGFP_KERNEL);\n\tif (!sensor->tracking_pos || !sensor->tracking_slots || !sensor->objs)\n\t\treturn -ENOMEM;\n\n\tret = rmi_2d_sensor_configure_input(fn, sensor);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstruct rmi_function_handler rmi_f12_handler = {\n\t.driver = {\n\t\t.name = \"rmi4_f12\",\n\t},\n\t.func = 0x12,\n\t.probe = rmi_f12_probe,\n\t.config = rmi_f12_config,\n\t.attention = rmi_f12_attention,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}