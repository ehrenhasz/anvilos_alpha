{
  "module_name": "rmi_f34v7.c",
  "hash_id": "4244c7be9963544f97824d67eac7947974c385afd9326b33bf8326ff65af98d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f34v7.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <asm/unaligned.h>\n\n#include \"rmi_driver.h\"\n#include \"rmi_f34.h\"\n\nstatic int rmi_f34v7_read_flash_status(struct f34_data *f34)\n{\n\tu8 status;\n\tu8 command;\n\tint ret;\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tf34->fn->fd.data_base_addr + V7_FLASH_STATUS_OFFSET,\n\t\t\t&status,\n\t\t\tsizeof(status));\n\tif (ret < 0) {\n\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\"%s: Error %d reading flash status\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tf34->v7.in_bl_mode = status >> 7;\n\tf34->v7.flash_status = status & 0x1f;\n\n\tif (f34->v7.flash_status != 0x00) {\n\t\tdev_err(&f34->fn->dev, \"%s: status=%d, command=0x%02x\\n\",\n\t\t\t__func__, f34->v7.flash_status, f34->v7.command);\n\t}\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tf34->fn->fd.data_base_addr + V7_COMMAND_OFFSET,\n\t\t\t&command,\n\t\t\tsizeof(command));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to read flash command\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tf34->v7.command = command;\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_wait_for_idle(struct f34_data *f34, int timeout_ms)\n{\n\tunsigned long timeout;\n\n\ttimeout = msecs_to_jiffies(timeout_ms);\n\n\tif (!wait_for_completion_timeout(&f34->v7.cmd_done, timeout)) {\n\t\tdev_warn(&f34->fn->dev, \"%s: Timed out waiting for idle status\\n\",\n\t\t\t __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_check_command_status(struct f34_data *f34, int timeout_ms)\n{\n\tint ret;\n\n\tret = rmi_f34v7_wait_for_idle(f34, timeout_ms);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_read_flash_status(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (f34->v7.flash_status != 0x00)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_command_single_transaction(struct f34_data *f34,\n\t\t\t\t\t\t      u8 cmd)\n{\n\tint ret;\n\tu8 base;\n\tstruct f34v7_data_1_5 data_1_5;\n\n\tbase = f34->fn->fd.data_base_addr;\n\n\tmemset(&data_1_5, 0, sizeof(data_1_5));\n\n\tswitch (cmd) {\n\tcase v7_CMD_ERASE_ALL:\n\t\tdata_1_5.partition_id = CORE_CODE_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE_AP;\n\t\tbreak;\n\tcase v7_CMD_ERASE_UI_FIRMWARE:\n\t\tdata_1_5.partition_id = CORE_CODE_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ERASE_BL_CONFIG:\n\t\tdata_1_5.partition_id = GLOBAL_PARAMETERS_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ERASE_UI_CONFIG:\n\t\tdata_1_5.partition_id = CORE_CONFIG_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ERASE_DISP_CONFIG:\n\t\tdata_1_5.partition_id = DISPLAY_CONFIG_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ERASE_FLASH_CONFIG:\n\t\tdata_1_5.partition_id = FLASH_CONFIG_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ERASE_GUEST_CODE:\n\t\tdata_1_5.partition_id = GUEST_CODE_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ENABLE_FLASH_PROG:\n\t\tdata_1_5.partition_id = BOOTLOADER_PARTITION;\n\t\tdata_1_5.command = CMD_V7_ENTER_BL;\n\t\tbreak;\n\t}\n\n\tdata_1_5.payload[0] = f34->bootloader_id[0];\n\tdata_1_5.payload[1] = f34->bootloader_id[1];\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_PARTITION_ID_OFFSET,\n\t\t\t&data_1_5, sizeof(data_1_5));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"%s: Failed to write single transaction command\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_command(struct f34_data *f34, u8 cmd)\n{\n\tint ret;\n\tu8 base;\n\tu8 command;\n\n\tbase = f34->fn->fd.data_base_addr;\n\n\tswitch (cmd) {\n\tcase v7_CMD_WRITE_FW:\n\tcase v7_CMD_WRITE_CONFIG:\n\tcase v7_CMD_WRITE_GUEST_CODE:\n\t\tcommand = CMD_V7_WRITE;\n\t\tbreak;\n\tcase v7_CMD_READ_CONFIG:\n\t\tcommand = CMD_V7_READ;\n\t\tbreak;\n\tcase v7_CMD_ERASE_ALL:\n\t\tcommand = CMD_V7_ERASE_AP;\n\t\tbreak;\n\tcase v7_CMD_ERASE_UI_FIRMWARE:\n\tcase v7_CMD_ERASE_BL_CONFIG:\n\tcase v7_CMD_ERASE_UI_CONFIG:\n\tcase v7_CMD_ERASE_DISP_CONFIG:\n\tcase v7_CMD_ERASE_FLASH_CONFIG:\n\tcase v7_CMD_ERASE_GUEST_CODE:\n\t\tcommand = CMD_V7_ERASE;\n\t\tbreak;\n\tcase v7_CMD_ENABLE_FLASH_PROG:\n\t\tcommand = CMD_V7_ENTER_BL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&f34->fn->dev, \"%s: Invalid command 0x%02x\\n\",\n\t\t\t__func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tf34->v7.command = command;\n\n\tswitch (cmd) {\n\tcase v7_CMD_ERASE_ALL:\n\tcase v7_CMD_ERASE_UI_FIRMWARE:\n\tcase v7_CMD_ERASE_BL_CONFIG:\n\tcase v7_CMD_ERASE_UI_CONFIG:\n\tcase v7_CMD_ERASE_DISP_CONFIG:\n\tcase v7_CMD_ERASE_FLASH_CONFIG:\n\tcase v7_CMD_ERASE_GUEST_CODE:\n\tcase v7_CMD_ENABLE_FLASH_PROG:\n\t\tret = rmi_f34v7_write_command_single_transaction(f34, cmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"%s: writing cmd %02X\\n\",\n\t\t__func__, command);\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_COMMAND_OFFSET,\n\t\t\t&command, sizeof(command));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write flash command\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_partition_id(struct f34_data *f34, u8 cmd)\n{\n\tint ret;\n\tu8 base;\n\tu8 partition;\n\n\tbase = f34->fn->fd.data_base_addr;\n\n\tswitch (cmd) {\n\tcase v7_CMD_WRITE_FW:\n\t\tpartition = CORE_CODE_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_WRITE_CONFIG:\n\tcase v7_CMD_READ_CONFIG:\n\t\tif (f34->v7.config_area == v7_UI_CONFIG_AREA)\n\t\t\tpartition = CORE_CONFIG_PARTITION;\n\t\telse if (f34->v7.config_area == v7_DP_CONFIG_AREA)\n\t\t\tpartition = DISPLAY_CONFIG_PARTITION;\n\t\telse if (f34->v7.config_area == v7_PM_CONFIG_AREA)\n\t\t\tpartition = GUEST_SERIALIZATION_PARTITION;\n\t\telse if (f34->v7.config_area == v7_BL_CONFIG_AREA)\n\t\t\tpartition = GLOBAL_PARAMETERS_PARTITION;\n\t\telse if (f34->v7.config_area == v7_FLASH_CONFIG_AREA)\n\t\t\tpartition = FLASH_CONFIG_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_WRITE_GUEST_CODE:\n\t\tpartition = GUEST_CODE_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ERASE_ALL:\n\t\tpartition = CORE_CODE_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ERASE_BL_CONFIG:\n\t\tpartition = GLOBAL_PARAMETERS_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ERASE_UI_CONFIG:\n\t\tpartition = CORE_CONFIG_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ERASE_DISP_CONFIG:\n\t\tpartition = DISPLAY_CONFIG_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ERASE_FLASH_CONFIG:\n\t\tpartition = FLASH_CONFIG_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ERASE_GUEST_CODE:\n\t\tpartition = GUEST_CODE_PARTITION;\n\t\tbreak;\n\tcase v7_CMD_ENABLE_FLASH_PROG:\n\t\tpartition = BOOTLOADER_PARTITION;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&f34->fn->dev, \"%s: Invalid command 0x%02x\\n\",\n\t\t\t__func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_PARTITION_ID_OFFSET,\n\t\t\t&partition, sizeof(partition));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write partition ID\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_read_partition_table(struct f34_data *f34)\n{\n\tint ret;\n\tunsigned long timeout;\n\tu8 base;\n\t__le16 length;\n\tu16 block_number = 0;\n\n\tbase = f34->fn->fd.data_base_addr;\n\n\tf34->v7.config_area = v7_FLASH_CONFIG_AREA;\n\n\tret = rmi_f34v7_write_partition_id(f34, v7_CMD_READ_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_BLOCK_NUMBER_OFFSET,\n\t\t\t&block_number, sizeof(block_number));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write block number\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tput_unaligned_le16(f34->v7.flash_config_length, &length);\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_TRANSFER_LENGTH_OFFSET,\n\t\t\t&length, sizeof(length));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write transfer length\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&f34->v7.cmd_done);\n\n\tret = rmi_f34v7_write_command(f34, v7_CMD_READ_CONFIG);\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write command\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\ttimeout = msecs_to_jiffies(F34_WRITE_WAIT_MS);\n\twhile (time_before(jiffies, timeout)) {\n\t\tusleep_range(5000, 6000);\n\t\trmi_f34v7_read_flash_status(f34);\n\n\t\tif (f34->v7.command == v7_CMD_IDLE &&\n\t\t    f34->v7.flash_status == 0x00) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_PAYLOAD_OFFSET,\n\t\t\tf34->v7.read_config_buf,\n\t\t\tf34->v7.partition_table_bytes);\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to read block data\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rmi_f34v7_parse_partition_table(struct f34_data *f34,\n\t\t\t\t\t    const void *partition_table,\n\t\t\t\t\t    struct block_count *blkcount,\n\t\t\t\t\t    struct physical_address *phyaddr)\n{\n\tint i;\n\tint index;\n\tu16 partition_length;\n\tu16 physical_address;\n\tconst struct partition_table *ptable;\n\n\tfor (i = 0; i < f34->v7.partitions; i++) {\n\t\tindex = i * 8 + 2;\n\t\tptable = partition_table + index;\n\t\tpartition_length = le16_to_cpu(ptable->partition_length);\n\t\tphysical_address = le16_to_cpu(ptable->start_physical_address);\n\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\"%s: Partition entry %d: %*ph\\n\",\n\t\t\t__func__, i, sizeof(struct partition_table), ptable);\n\t\tswitch (ptable->partition_id & 0x1f) {\n\t\tcase CORE_CODE_PARTITION:\n\t\t\tblkcount->ui_firmware = partition_length;\n\t\t\tphyaddr->ui_firmware = physical_address;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Core code block count: %d\\n\",\n\t\t\t\t__func__, blkcount->ui_firmware);\n\t\t\tbreak;\n\t\tcase CORE_CONFIG_PARTITION:\n\t\t\tblkcount->ui_config = partition_length;\n\t\t\tphyaddr->ui_config = physical_address;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Core config block count: %d\\n\",\n\t\t\t\t__func__, blkcount->ui_config);\n\t\t\tbreak;\n\t\tcase DISPLAY_CONFIG_PARTITION:\n\t\t\tblkcount->dp_config = partition_length;\n\t\t\tphyaddr->dp_config = physical_address;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Display config block count: %d\\n\",\n\t\t\t\t__func__, blkcount->dp_config);\n\t\t\tbreak;\n\t\tcase FLASH_CONFIG_PARTITION:\n\t\t\tblkcount->fl_config = partition_length;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Flash config block count: %d\\n\",\n\t\t\t\t__func__, blkcount->fl_config);\n\t\t\tbreak;\n\t\tcase GUEST_CODE_PARTITION:\n\t\t\tblkcount->guest_code = partition_length;\n\t\t\tphyaddr->guest_code = physical_address;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Guest code block count: %d\\n\",\n\t\t\t\t__func__, blkcount->guest_code);\n\t\t\tbreak;\n\t\tcase GUEST_SERIALIZATION_PARTITION:\n\t\t\tblkcount->pm_config = partition_length;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Guest serialization block count: %d\\n\",\n\t\t\t\t__func__, blkcount->pm_config);\n\t\t\tbreak;\n\t\tcase GLOBAL_PARAMETERS_PARTITION:\n\t\t\tblkcount->bl_config = partition_length;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Global parameters block count: %d\\n\",\n\t\t\t\t__func__, blkcount->bl_config);\n\t\t\tbreak;\n\t\tcase DEVICE_CONFIG_PARTITION:\n\t\t\tblkcount->lockdown = partition_length;\n\t\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\t\"%s: Device config block count: %d\\n\",\n\t\t\t\t__func__, blkcount->lockdown);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int rmi_f34v7_read_queries_bl_version(struct f34_data *f34)\n{\n\tint ret;\n\tu8 base;\n\tint offset;\n\tu8 query_0;\n\tstruct f34v7_query_1_7 query_1_7;\n\n\tbase = f34->fn->fd.query_base_addr;\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tbase,\n\t\t\t&query_0,\n\t\t\tsizeof(query_0));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"%s: Failed to read query 0\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\toffset = (query_0 & 0x7) + 1;\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tbase + offset,\n\t\t\t&query_1_7,\n\t\t\tsizeof(query_1_7));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to read queries 1 to 7\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tf34->bootloader_id[0] = query_1_7.bl_minor_revision;\n\tf34->bootloader_id[1] = query_1_7.bl_major_revision;\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"Bootloader V%d.%d\\n\",\n\t\tf34->bootloader_id[1], f34->bootloader_id[0]);\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_read_queries(struct f34_data *f34)\n{\n\tint ret;\n\tint i;\n\tu8 base;\n\tint offset;\n\tu8 *ptable;\n\tu8 query_0;\n\tstruct f34v7_query_1_7 query_1_7;\n\n\tbase = f34->fn->fd.query_base_addr;\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tbase,\n\t\t\t&query_0,\n\t\t\tsizeof(query_0));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"%s: Failed to read query 0\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\toffset = (query_0 & 0x07) + 1;\n\n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tbase + offset,\n\t\t\t&query_1_7,\n\t\t\tsizeof(query_1_7));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to read queries 1 to 7\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tf34->bootloader_id[0] = query_1_7.bl_minor_revision;\n\tf34->bootloader_id[1] = query_1_7.bl_major_revision;\n\n\tf34->v7.block_size = le16_to_cpu(query_1_7.block_size);\n\tf34->v7.flash_config_length =\n\t\t\tle16_to_cpu(query_1_7.flash_config_length);\n\tf34->v7.payload_length = le16_to_cpu(query_1_7.payload_length);\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"%s: f34->v7.block_size = %d\\n\",\n\t\t __func__, f34->v7.block_size);\n\n\tf34->v7.has_display_cfg = query_1_7.partition_support[1] & HAS_DISP_CFG;\n\tf34->v7.has_guest_code =\n\t\t\tquery_1_7.partition_support[1] & HAS_GUEST_CODE;\n\n\tif (query_0 & HAS_CONFIG_ID) {\n\t\tu8 f34_ctrl[CONFIG_ID_SIZE];\n\n\t\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\t\tf34->fn->fd.control_base_addr,\n\t\t\t\tf34_ctrl,\n\t\t\t\tsizeof(f34_ctrl));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < sizeof(f34_ctrl) - 1 && !f34_ctrl[i]; i++)\n\t\t\t ;\n\n\t\tsnprintf(f34->configuration_id, sizeof(f34->configuration_id),\n\t\t\t \"%*phN\", (int)sizeof(f34_ctrl) - i, f34_ctrl + i);\n\n\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"Configuration ID: %s\\n\",\n\t\t\tf34->configuration_id);\n\t}\n\n\tf34->v7.partitions = 0;\n\tfor (i = 0; i < sizeof(query_1_7.partition_support); i++)\n\t\tf34->v7.partitions += hweight8(query_1_7.partition_support[i]);\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"%s: Supported partitions: %*ph\\n\",\n\t\t__func__, sizeof(query_1_7.partition_support),\n\t\tquery_1_7.partition_support);\n\n\n\tf34->v7.partition_table_bytes = f34->v7.partitions * 8 + 2;\n\n\tf34->v7.read_config_buf = devm_kzalloc(&f34->fn->dev,\n\t\t\tf34->v7.partition_table_bytes,\n\t\t\tGFP_KERNEL);\n\tif (!f34->v7.read_config_buf) {\n\t\tf34->v7.read_config_buf_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tf34->v7.read_config_buf_size = f34->v7.partition_table_bytes;\n\tptable = f34->v7.read_config_buf;\n\n\tret = rmi_f34v7_read_partition_table(f34);\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to read partition table\\n\",\n\t\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\trmi_f34v7_parse_partition_table(f34, ptable,\n\t\t\t\t\t&f34->v7.blkcount, &f34->v7.phyaddr);\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_check_bl_config_size(struct f34_data *f34)\n{\n\tu16 block_count;\n\n\tblock_count = f34->v7.img.bl_config.size / f34->v7.block_size;\n\tf34->update_size += block_count;\n\n\tif (block_count != f34->v7.blkcount.bl_config) {\n\t\tdev_err(&f34->fn->dev, \"Bootloader config size mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_erase_all(struct f34_data *f34)\n{\n\tint ret;\n\n\tdev_info(&f34->fn->dev, \"Erasing firmware...\\n\");\n\n\tinit_completion(&f34->v7.cmd_done);\n\n\tret = rmi_f34v7_write_command(f34, v7_CMD_ERASE_ALL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_check_command_status(f34, F34_ERASE_WAIT_MS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_read_blocks(struct f34_data *f34,\n\t\t\t\t u16 block_cnt, u8 command)\n{\n\tint ret;\n\tu8 base;\n\t__le16 length;\n\tu16 transfer;\n\tu16 max_transfer;\n\tu16 remaining = block_cnt;\n\tu16 block_number = 0;\n\tu16 index = 0;\n\n\tbase = f34->fn->fd.data_base_addr;\n\n\tret = rmi_f34v7_write_partition_id(f34, command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_BLOCK_NUMBER_OFFSET,\n\t\t\t&block_number, sizeof(block_number));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write block number\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tmax_transfer = min(f34->v7.payload_length,\n\t\t\t   (u16)(PAGE_SIZE / f34->v7.block_size));\n\n\tdo {\n\t\ttransfer = min(remaining, max_transfer);\n\t\tput_unaligned_le16(transfer, &length);\n\n\t\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\t\tbase + V7_TRANSFER_LENGTH_OFFSET,\n\t\t\t\t&length, sizeof(length));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&f34->fn->dev,\n\t\t\t\t\"%s: Write transfer length fail (%d remaining)\\n\",\n\t\t\t\t__func__, remaining);\n\t\t\treturn ret;\n\t\t}\n\n\t\tinit_completion(&f34->v7.cmd_done);\n\n\t\tret = rmi_f34v7_write_command(f34, command);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = rmi_f34v7_check_command_status(f34, F34_ENABLE_WAIT_MS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\t\tbase + V7_PAYLOAD_OFFSET,\n\t\t\t\t&f34->v7.read_config_buf[index],\n\t\t\t\ttransfer * f34->v7.block_size);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&f34->fn->dev,\n\t\t\t\t\"%s: Read block failed (%d blks remaining)\\n\",\n\t\t\t\t__func__, remaining);\n\t\t\treturn ret;\n\t\t}\n\n\t\tindex += (transfer * f34->v7.block_size);\n\t\tremaining -= transfer;\n\t} while (remaining);\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_f34v7_blocks(struct f34_data *f34,\n\t\t\t\t\tconst void *block_ptr, u16 block_cnt,\n\t\t\t\t\tu8 command)\n{\n\tint ret;\n\tu8 base;\n\t__le16 length;\n\tu16 transfer;\n\tu16 max_transfer;\n\tu16 remaining = block_cnt;\n\tu16 block_number = 0;\n\n\tbase = f34->fn->fd.data_base_addr;\n\n\tret = rmi_f34v7_write_partition_id(f34, command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\tbase + V7_BLOCK_NUMBER_OFFSET,\n\t\t\t&block_number, sizeof(block_number));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to write block number\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif (f34->v7.payload_length > (PAGE_SIZE / f34->v7.block_size))\n\t\tmax_transfer = PAGE_SIZE / f34->v7.block_size;\n\telse\n\t\tmax_transfer = f34->v7.payload_length;\n\n\tdo {\n\t\ttransfer = min(remaining, max_transfer);\n\t\tput_unaligned_le16(transfer, &length);\n\n\t\tinit_completion(&f34->v7.cmd_done);\n\n\t\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\t\tbase + V7_TRANSFER_LENGTH_OFFSET,\n\t\t\t\t&length, sizeof(length));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&f34->fn->dev,\n\t\t\t\t\"%s: Write transfer length fail (%d remaining)\\n\",\n\t\t\t\t__func__, remaining);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rmi_f34v7_write_command(f34, command);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = rmi_write_block(f34->fn->rmi_dev,\n\t\t\t\tbase + V7_PAYLOAD_OFFSET,\n\t\t\t\tblock_ptr, transfer * f34->v7.block_size);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&f34->fn->dev,\n\t\t\t\t\"%s: Failed writing data (%d blks remaining)\\n\",\n\t\t\t\t__func__, remaining);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rmi_f34v7_check_command_status(f34, F34_ENABLE_WAIT_MS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tblock_ptr += (transfer * f34->v7.block_size);\n\t\tremaining -= transfer;\n\t\tf34->update_progress += transfer;\n\t\tf34->update_status = (f34->update_progress * 100) /\n\t\t\t\t     f34->update_size;\n\t} while (remaining);\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_config(struct f34_data *f34)\n{\n\treturn rmi_f34v7_write_f34v7_blocks(f34, f34->v7.config_data,\n\t\t\t\t\t    f34->v7.config_block_count,\n\t\t\t\t\t    v7_CMD_WRITE_CONFIG);\n}\n\nstatic int rmi_f34v7_write_ui_config(struct f34_data *f34)\n{\n\tf34->v7.config_area = v7_UI_CONFIG_AREA;\n\tf34->v7.config_data = f34->v7.img.ui_config.data;\n\tf34->v7.config_size = f34->v7.img.ui_config.size;\n\tf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\n\n\treturn rmi_f34v7_write_config(f34);\n}\n\nstatic int rmi_f34v7_write_dp_config(struct f34_data *f34)\n{\n\tf34->v7.config_area = v7_DP_CONFIG_AREA;\n\tf34->v7.config_data = f34->v7.img.dp_config.data;\n\tf34->v7.config_size = f34->v7.img.dp_config.size;\n\tf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\n\n\treturn rmi_f34v7_write_config(f34);\n}\n\nstatic int rmi_f34v7_write_guest_code(struct f34_data *f34)\n{\n\treturn rmi_f34v7_write_f34v7_blocks(f34, f34->v7.img.guest_code.data,\n\t\t\t\t\t    f34->v7.img.guest_code.size /\n\t\t\t\t\t\t\tf34->v7.block_size,\n\t\t\t\t\t    v7_CMD_WRITE_GUEST_CODE);\n}\n\nstatic int rmi_f34v7_write_flash_config(struct f34_data *f34)\n{\n\tint ret;\n\n\tf34->v7.config_area = v7_FLASH_CONFIG_AREA;\n\tf34->v7.config_data = f34->v7.img.fl_config.data;\n\tf34->v7.config_size = f34->v7.img.fl_config.size;\n\tf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\n\n\tif (f34->v7.config_block_count != f34->v7.blkcount.fl_config) {\n\t\tdev_err(&f34->fn->dev, \"%s: Flash config size mismatch\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tinit_completion(&f34->v7.cmd_done);\n\n\tret = rmi_f34v7_write_config(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_partition_table(struct f34_data *f34)\n{\n\tu16 block_count;\n\tint ret;\n\n\tblock_count = f34->v7.blkcount.bl_config;\n\tf34->v7.config_area = v7_BL_CONFIG_AREA;\n\tf34->v7.config_size = f34->v7.block_size * block_count;\n\tdevm_kfree(&f34->fn->dev, f34->v7.read_config_buf);\n\tf34->v7.read_config_buf = devm_kzalloc(&f34->fn->dev,\n\t\t\t\t\t       f34->v7.config_size, GFP_KERNEL);\n\tif (!f34->v7.read_config_buf) {\n\t\tf34->v7.read_config_buf_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tf34->v7.read_config_buf_size = f34->v7.config_size;\n\n\tret = rmi_f34v7_read_blocks(f34, block_count, v7_CMD_READ_CONFIG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_write_flash_config(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tf34->v7.config_area = v7_BL_CONFIG_AREA;\n\tf34->v7.config_data = f34->v7.read_config_buf;\n\tf34->v7.config_size = f34->v7.img.bl_config.size;\n\tf34->v7.config_block_count = f34->v7.config_size / f34->v7.block_size;\n\n\tret = rmi_f34v7_write_config(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_write_firmware(struct f34_data *f34)\n{\n\tu16 blk_count;\n\n\tblk_count = f34->v7.img.ui_firmware.size / f34->v7.block_size;\n\n\treturn rmi_f34v7_write_f34v7_blocks(f34, f34->v7.img.ui_firmware.data,\n\t\t\t\t\t    blk_count, v7_CMD_WRITE_FW);\n}\n\nstatic void rmi_f34v7_parse_img_header_10_bl_container(struct f34_data *f34,\n\t\t\t\t\t\t       const void *image)\n{\n\tint i;\n\tint num_of_containers;\n\tunsigned int addr;\n\tunsigned int container_id;\n\tunsigned int length;\n\tconst void *content;\n\tconst struct container_descriptor *descriptor;\n\n\tnum_of_containers = f34->v7.img.bootloader.size / 4 - 1;\n\n\tfor (i = 1; i <= num_of_containers; i++) {\n\t\taddr = get_unaligned_le32(f34->v7.img.bootloader.data + i * 4);\n\t\tdescriptor = image + addr;\n\t\tcontainer_id = le16_to_cpu(descriptor->container_id);\n\t\tcontent = image + le32_to_cpu(descriptor->content_address);\n\t\tlength = le32_to_cpu(descriptor->content_length);\n\t\tswitch (container_id) {\n\t\tcase BL_CONFIG_CONTAINER:\n\t\tcase GLOBAL_PARAMETERS_CONTAINER:\n\t\t\tf34->v7.img.bl_config.data = content;\n\t\t\tf34->v7.img.bl_config.size = length;\n\t\t\tbreak;\n\t\tcase BL_LOCKDOWN_INFO_CONTAINER:\n\t\tcase DEVICE_CONFIG_CONTAINER:\n\t\t\tf34->v7.img.lockdown.data = content;\n\t\t\tf34->v7.img.lockdown.size = length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void rmi_f34v7_parse_image_header_10(struct f34_data *f34)\n{\n\tunsigned int i;\n\tunsigned int num_of_containers;\n\tunsigned int addr;\n\tunsigned int offset;\n\tunsigned int container_id;\n\tunsigned int length;\n\tconst void *image = f34->v7.image;\n\tconst u8 *content;\n\tconst struct container_descriptor *descriptor;\n\tconst struct image_header_10 *header = image;\n\n\tf34->v7.img.checksum = le32_to_cpu(header->checksum);\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev, \"%s: f34->v7.img.checksum=%X\\n\",\n\t\t__func__, f34->v7.img.checksum);\n\n\t \n\toffset = le32_to_cpu(header->top_level_container_start_addr);\n\tdescriptor = image + offset;\n\n\t \n\toffset = le32_to_cpu(descriptor->content_address);\n\tnum_of_containers = le32_to_cpu(descriptor->content_length) / 4;\n\n\tfor (i = 0; i < num_of_containers; i++) {\n\t\taddr = get_unaligned_le32(image + offset);\n\t\toffset += 4;\n\t\tdescriptor = image + addr;\n\t\tcontainer_id = le16_to_cpu(descriptor->container_id);\n\t\tcontent = image + le32_to_cpu(descriptor->content_address);\n\t\tlength = le32_to_cpu(descriptor->content_length);\n\n\t\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\t\"%s: container_id=%d, length=%d\\n\", __func__,\n\t\t\tcontainer_id, length);\n\n\t\tswitch (container_id) {\n\t\tcase UI_CONTAINER:\n\t\tcase CORE_CODE_CONTAINER:\n\t\t\tf34->v7.img.ui_firmware.data = content;\n\t\t\tf34->v7.img.ui_firmware.size = length;\n\t\t\tbreak;\n\t\tcase UI_CONFIG_CONTAINER:\n\t\tcase CORE_CONFIG_CONTAINER:\n\t\t\tf34->v7.img.ui_config.data = content;\n\t\t\tf34->v7.img.ui_config.size = length;\n\t\t\tbreak;\n\t\tcase BL_CONTAINER:\n\t\t\tf34->v7.img.bl_version = *content;\n\t\t\tf34->v7.img.bootloader.data = content;\n\t\t\tf34->v7.img.bootloader.size = length;\n\t\t\trmi_f34v7_parse_img_header_10_bl_container(f34, image);\n\t\t\tbreak;\n\t\tcase GUEST_CODE_CONTAINER:\n\t\t\tf34->v7.img.contains_guest_code = true;\n\t\t\tf34->v7.img.guest_code.data = content;\n\t\t\tf34->v7.img.guest_code.size = length;\n\t\t\tbreak;\n\t\tcase DISPLAY_CONFIG_CONTAINER:\n\t\t\tf34->v7.img.contains_display_cfg = true;\n\t\t\tf34->v7.img.dp_config.data = content;\n\t\t\tf34->v7.img.dp_config.size = length;\n\t\t\tbreak;\n\t\tcase FLASH_CONFIG_CONTAINER:\n\t\t\tf34->v7.img.contains_flash_config = true;\n\t\t\tf34->v7.img.fl_config.data = content;\n\t\t\tf34->v7.img.fl_config.size = length;\n\t\t\tbreak;\n\t\tcase GENERAL_INFORMATION_CONTAINER:\n\t\t\tf34->v7.img.contains_firmware_id = true;\n\t\t\tf34->v7.img.firmware_id =\n\t\t\t\tget_unaligned_le32(content + 4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int rmi_f34v7_parse_image_info(struct f34_data *f34)\n{\n\tconst struct image_header_10 *header = f34->v7.image;\n\n\tmemset(&f34->v7.img, 0x00, sizeof(f34->v7.img));\n\n\trmi_dbg(RMI_DEBUG_FN, &f34->fn->dev,\n\t\t\"%s: header->major_header_version = %d\\n\",\n\t\t__func__, header->major_header_version);\n\n\tswitch (header->major_header_version) {\n\tcase IMAGE_HEADER_VERSION_10:\n\t\trmi_f34v7_parse_image_header_10(f34);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&f34->fn->dev, \"Unsupported image file format %02X\\n\",\n\t\t\theader->major_header_version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!f34->v7.img.contains_flash_config) {\n\t\tdev_err(&f34->fn->dev, \"%s: No flash config in fw image\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\trmi_f34v7_parse_partition_table(f34, f34->v7.img.fl_config.data,\n\t\t\t&f34->v7.img.blkcount, &f34->v7.img.phyaddr);\n\n\treturn 0;\n}\n\nint rmi_f34v7_do_reflash(struct f34_data *f34, const struct firmware *fw)\n{\n\tint ret;\n\n\tf34->fn->rmi_dev->driver->set_irq_bits(f34->fn->rmi_dev,\n\t\t\t\t\t       f34->fn->irq_mask);\n\n\trmi_f34v7_read_queries_bl_version(f34);\n\n\tf34->v7.image = fw->data;\n\tf34->update_progress = 0;\n\tf34->update_size = 0;\n\n\tret = rmi_f34v7_parse_image_info(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_check_bl_config_size(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_erase_all(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_write_partition_table(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_info(&f34->fn->dev, \"%s: Partition table programmed\\n\", __func__);\n\n\t \n\tret = rmi_scan_pdt(f34->fn->rmi_dev, NULL, rmi_initial_reset);\n\tif (ret < 0)\n\t\tdev_warn(&f34->fn->dev, \"RMI reset failed!\\n\");\n\n\tdev_info(&f34->fn->dev, \"Writing firmware (%d bytes)...\\n\",\n\t\t f34->v7.img.ui_firmware.size);\n\n\tret = rmi_f34v7_write_firmware(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(&f34->fn->dev, \"Writing config (%d bytes)...\\n\",\n\t\t f34->v7.img.ui_config.size);\n\n\tf34->v7.config_area = v7_UI_CONFIG_AREA;\n\tret = rmi_f34v7_write_ui_config(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (f34->v7.has_display_cfg && f34->v7.img.contains_display_cfg) {\n\t\tdev_info(&f34->fn->dev, \"Writing display config...\\n\");\n\n\t\tret = rmi_f34v7_write_dp_config(f34);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (f34->v7.has_guest_code && f34->v7.img.contains_guest_code) {\n\t\tdev_info(&f34->fn->dev, \"Writing guest code...\\n\");\n\n\t\tret = rmi_f34v7_write_guest_code(f34);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f34v7_enter_flash_prog(struct f34_data *f34)\n{\n\tint ret;\n\n\tf34->fn->rmi_dev->driver->set_irq_bits(f34->fn->rmi_dev, f34->fn->irq_mask);\n\n\tret = rmi_f34v7_read_flash_status(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (f34->v7.in_bl_mode) {\n\t\tdev_info(&f34->fn->dev, \"%s: Device in bootloader mode\\n\",\n\t\t\t __func__);\n\t\treturn 0;\n\t}\n\n\tinit_completion(&f34->v7.cmd_done);\n\n\tret = rmi_f34v7_write_command(f34, v7_CMD_ENABLE_FLASH_PROG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rmi_f34v7_check_command_status(f34, F34_ENABLE_WAIT_MS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint rmi_f34v7_start_reflash(struct f34_data *f34, const struct firmware *fw)\n{\n\tint ret = 0;\n\n\tf34->v7.config_area = v7_UI_CONFIG_AREA;\n\tf34->v7.image = fw->data;\n\n\tret = rmi_f34v7_parse_image_info(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(&f34->fn->dev, \"Firmware image OK\\n\");\n\n\treturn rmi_f34v7_enter_flash_prog(f34);\n}\n\nint rmi_f34v7_probe(struct f34_data *f34)\n{\n\tint ret;\n\n\t \n\tret = rmi_read_block(f34->fn->rmi_dev,\n\t\t\tf34->fn->fd.query_base_addr + V7_BOOTLOADER_ID_OFFSET,\n\t\t\tf34->bootloader_id,\n\t\t\tsizeof(f34->bootloader_id));\n\tif (ret < 0) {\n\t\tdev_err(&f34->fn->dev, \"%s: Failed to read bootloader ID\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif (f34->bootloader_id[1] == '5') {\n\t\tf34->bl_version = 5;\n\t} else if (f34->bootloader_id[1] == '6') {\n\t\tf34->bl_version = 6;\n\t} else if (f34->bootloader_id[1] == 7) {\n\t\tf34->bl_version = 7;\n\t} else if (f34->bootloader_id[1] == 8) {\n\t\tf34->bl_version = 8;\n\t} else {\n\t\tdev_err(&f34->fn->dev,\n\t\t\t\"%s: Unrecognized bootloader version: %d (%c) %d (%c)\\n\",\n\t\t\t__func__,\n\t\t\tf34->bootloader_id[0], f34->bootloader_id[0],\n\t\t\tf34->bootloader_id[1], f34->bootloader_id[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&f34->v7.blkcount, 0x00, sizeof(f34->v7.blkcount));\n\tmemset(&f34->v7.phyaddr, 0x00, sizeof(f34->v7.phyaddr));\n\n\tinit_completion(&f34->v7.cmd_done);\n\n\tret = rmi_f34v7_read_queries(f34);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}