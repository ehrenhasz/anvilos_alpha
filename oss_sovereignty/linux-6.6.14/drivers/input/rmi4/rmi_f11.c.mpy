{
  "module_name": "rmi_f11.c",
  "hash_id": "627cbe3a593bdd70a7eeebb7a2e9653933117339c3bc3031d92117b5a5c9828a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f11.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/rmi.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include \"rmi_driver.h\"\n#include \"rmi_2d_sensor.h\"\n\n#define F11_MAX_NUM_OF_FINGERS\t\t10\n#define F11_MAX_NUM_OF_TOUCH_SHAPES\t16\n\n#define FINGER_STATE_MASK\t0x03\n\n#define F11_CTRL_SENSOR_MAX_X_POS_OFFSET\t6\n#define F11_CTRL_SENSOR_MAX_Y_POS_OFFSET\t8\n\n#define DEFAULT_XY_MAX 9999\n#define DEFAULT_MAX_ABS_MT_PRESSURE 255\n#define DEFAULT_MAX_ABS_MT_TOUCH 15\n#define DEFAULT_MAX_ABS_MT_ORIENTATION 1\n#define DEFAULT_MIN_ABS_MT_TRACKING_ID 1\n#define DEFAULT_MAX_ABS_MT_TRACKING_ID 10\n\n \n\n \n#define DMAX 10\n\n \n#define RMI_F11_REZERO  0x01\n\n#define RMI_F11_HAS_QUERY9              (1 << 3)\n#define RMI_F11_HAS_QUERY11             (1 << 4)\n#define RMI_F11_HAS_QUERY12             (1 << 5)\n#define RMI_F11_HAS_QUERY27             (1 << 6)\n#define RMI_F11_HAS_QUERY28             (1 << 7)\n\n \n\n#define RMI_F11_NR_FINGERS_MASK 0x07\n#define RMI_F11_HAS_REL                 (1 << 3)\n#define RMI_F11_HAS_ABS                 (1 << 4)\n#define RMI_F11_HAS_GESTURES            (1 << 5)\n#define RMI_F11_HAS_SENSITIVITY_ADJ     (1 << 6)\n#define RMI_F11_CONFIGURABLE            (1 << 7)\n\n \n#define RMI_F11_NR_ELECTRODES_MASK      0x7F\n\n \n\n#define RMI_F11_ABS_DATA_SIZE_MASK      0x03\n#define RMI_F11_HAS_ANCHORED_FINGER     (1 << 2)\n#define RMI_F11_HAS_ADJ_HYST            (1 << 3)\n#define RMI_F11_HAS_DRIBBLE             (1 << 4)\n#define RMI_F11_HAS_BENDING_CORRECTION  (1 << 5)\n#define RMI_F11_HAS_LARGE_OBJECT_SUPPRESSION    (1 << 6)\n#define RMI_F11_HAS_JITTER_FILTER       (1 << 7)\n\n \n#define RMI_F11_HAS_SINGLE_TAP                  (1 << 0)\n#define RMI_F11_HAS_TAP_AND_HOLD                (1 << 1)\n#define RMI_F11_HAS_DOUBLE_TAP                  (1 << 2)\n#define RMI_F11_HAS_EARLY_TAP                   (1 << 3)\n#define RMI_F11_HAS_FLICK                       (1 << 4)\n#define RMI_F11_HAS_PRESS                       (1 << 5)\n#define RMI_F11_HAS_PINCH                       (1 << 6)\n#define RMI_F11_HAS_CHIRAL                      (1 << 7)\n\n \n#define RMI_F11_HAS_PALM_DET                    (1 << 0)\n#define RMI_F11_HAS_ROTATE                      (1 << 1)\n#define RMI_F11_HAS_TOUCH_SHAPES                (1 << 2)\n#define RMI_F11_HAS_SCROLL_ZONES                (1 << 3)\n#define RMI_F11_HAS_INDIVIDUAL_SCROLL_ZONES     (1 << 4)\n#define RMI_F11_HAS_MF_SCROLL                   (1 << 5)\n#define RMI_F11_HAS_MF_EDGE_MOTION              (1 << 6)\n#define RMI_F11_HAS_MF_SCROLL_INERTIA           (1 << 7)\n\n \n#define RMI_F11_HAS_PEN                         (1 << 0)\n#define RMI_F11_HAS_PROXIMITY                   (1 << 1)\n#define RMI_F11_HAS_PALM_DET_SENSITIVITY        (1 << 2)\n#define RMI_F11_HAS_SUPPRESS_ON_PALM_DETECT     (1 << 3)\n#define RMI_F11_HAS_TWO_PEN_THRESHOLDS          (1 << 4)\n#define RMI_F11_HAS_CONTACT_GEOMETRY            (1 << 5)\n#define RMI_F11_HAS_PEN_HOVER_DISCRIMINATION    (1 << 6)\n#define RMI_F11_HAS_PEN_FILTERS                 (1 << 7)\n\n \n#define RMI_F11_NR_TOUCH_SHAPES_MASK            0x1F\n\n \n\n#define RMI_F11_HAS_Z_TUNING                    (1 << 0)\n#define RMI_F11_HAS_ALGORITHM_SELECTION         (1 << 1)\n#define RMI_F11_HAS_W_TUNING                    (1 << 2)\n#define RMI_F11_HAS_PITCH_INFO                  (1 << 3)\n#define RMI_F11_HAS_FINGER_SIZE                 (1 << 4)\n#define RMI_F11_HAS_SEGMENTATION_AGGRESSIVENESS (1 << 5)\n#define RMI_F11_HAS_XY_CLIP                     (1 << 6)\n#define RMI_F11_HAS_DRUMMING_FILTER             (1 << 7)\n\n \n\n#define RMI_F11_HAS_GAPLESS_FINGER              (1 << 0)\n#define RMI_F11_HAS_GAPLESS_FINGER_TUNING       (1 << 1)\n#define RMI_F11_HAS_8BIT_W                      (1 << 2)\n#define RMI_F11_HAS_ADJUSTABLE_MAPPING          (1 << 3)\n#define RMI_F11_HAS_INFO2                       (1 << 4)\n#define RMI_F11_HAS_PHYSICAL_PROPS              (1 << 5)\n#define RMI_F11_HAS_FINGER_LIMIT                (1 << 6)\n#define RMI_F11_HAS_LINEAR_COEFF                (1 << 7)\n\n \n\n#define RMI_F11_JITTER_WINDOW_MASK              0x1F\n#define RMI_F11_JITTER_FILTER_MASK              0x60\n#define RMI_F11_JITTER_FILTER_SHIFT             5\n\n \n#define RMI_F11_LIGHT_CONTROL_MASK              0x03\n#define RMI_F11_IS_CLEAR                        (1 << 2)\n#define RMI_F11_CLICKPAD_PROPS_MASK             0x18\n#define RMI_F11_CLICKPAD_PROPS_SHIFT            3\n#define RMI_F11_MOUSE_BUTTONS_MASK              0x60\n#define RMI_F11_MOUSE_BUTTONS_SHIFT             5\n#define RMI_F11_HAS_ADVANCED_GESTURES           (1 << 7)\n\n#define RMI_F11_QUERY_SIZE                      4\n#define RMI_F11_QUERY_GESTURE_SIZE              2\n\n#define F11_LIGHT_CTL_NONE 0x00\n#define F11_LUXPAD\t   0x01\n#define F11_DUAL_MODE      0x02\n\n#define F11_NOT_CLICKPAD     0x00\n#define F11_HINGED_CLICKPAD  0x01\n#define F11_UNIFORM_CLICKPAD 0x02\n\n \nstruct f11_2d_sensor_queries {\n\t \n\tu8 nr_fingers;\n\tbool has_rel;\n\tbool has_abs;\n\tbool has_gestures;\n\tbool has_sensitivity_adjust;\n\tbool configurable;\n\n\t \n\tu8 nr_x_electrodes;\n\n\t \n\tu8 nr_y_electrodes;\n\n\t \n\tu8 max_electrodes;\n\n\t \n\tu8 abs_data_size;\n\tbool has_anchored_finger;\n\tbool has_adj_hyst;\n\tbool has_dribble;\n\tbool has_bending_correction;\n\tbool has_large_object_suppression;\n\tbool has_jitter_filter;\n\n\tu8 f11_2d_query6;\n\n\t \n\tbool has_single_tap;\n\tbool has_tap_n_hold;\n\tbool has_double_tap;\n\tbool has_early_tap;\n\tbool has_flick;\n\tbool has_press;\n\tbool has_pinch;\n\tbool has_chiral;\n\n\tbool query7_nonzero;\n\n\t \n\tbool has_palm_det;\n\tbool has_rotate;\n\tbool has_touch_shapes;\n\tbool has_scroll_zones;\n\tbool has_individual_scroll_zones;\n\tbool has_mf_scroll;\n\tbool has_mf_edge_motion;\n\tbool has_mf_scroll_inertia;\n\n\tbool query8_nonzero;\n\n\t \n\tbool has_pen;\n\tbool has_proximity;\n\tbool has_palm_det_sensitivity;\n\tbool has_suppress_on_palm_detect;\n\tbool has_two_pen_thresholds;\n\tbool has_contact_geometry;\n\tbool has_pen_hover_discrimination;\n\tbool has_pen_filters;\n\n\t \n\tu8 nr_touch_shapes;\n\n\t \n\tbool has_z_tuning;\n\tbool has_algorithm_selection;\n\tbool has_w_tuning;\n\tbool has_pitch_info;\n\tbool has_finger_size;\n\tbool has_segmentation_aggressiveness;\n\tbool has_XY_clip;\n\tbool has_drumming_filter;\n\n\t \n\tbool has_gapless_finger;\n\tbool has_gapless_finger_tuning;\n\tbool has_8bit_w;\n\tbool has_adjustable_mapping;\n\tbool has_info2;\n\tbool has_physical_props;\n\tbool has_finger_limit;\n\tbool has_linear_coeff_2;\n\n\t \n\tu8 jitter_window_size;\n\tu8 jitter_filter_type;\n\n\t \n\tu8 light_control;\n\tbool is_clear;\n\tu8 clickpad_props;\n\tu8 mouse_buttons;\n\tbool has_advanced_gestures;\n\n\t \n\tu16 x_sensor_size_mm;\n\tu16 y_sensor_size_mm;\n};\n\n \n#define RMI_F11_REPORT_MODE_MASK        0x07\n#define RMI_F11_REPORT_MODE_CONTINUOUS  (0 << 0)\n#define RMI_F11_REPORT_MODE_REDUCED     (1 << 0)\n#define RMI_F11_REPORT_MODE_FS_CHANGE   (2 << 0)\n#define RMI_F11_REPORT_MODE_FP_CHANGE   (3 << 0)\n#define RMI_F11_ABS_POS_FILT            (1 << 3)\n#define RMI_F11_REL_POS_FILT            (1 << 4)\n#define RMI_F11_REL_BALLISTICS          (1 << 5)\n#define RMI_F11_DRIBBLE                 (1 << 6)\n#define RMI_F11_REPORT_BEYOND_CLIP      (1 << 7)\n\n \n#define RMI_F11_PALM_DETECT_THRESH_MASK 0x0F\n#define RMI_F11_MOTION_SENSITIVITY_MASK 0x30\n#define RMI_F11_MANUAL_TRACKING         (1 << 6)\n#define RMI_F11_MANUAL_TRACKED_FINGER   (1 << 7)\n\n#define RMI_F11_DELTA_X_THRESHOLD       2\n#define RMI_F11_DELTA_Y_THRESHOLD       3\n\n#define RMI_F11_CTRL_REG_COUNT          12\n\nstruct f11_2d_ctrl {\n\tu8              ctrl0_11[RMI_F11_CTRL_REG_COUNT];\n\tu16             ctrl0_11_address;\n};\n\n#define RMI_F11_ABS_BYTES 5\n#define RMI_F11_REL_BYTES 2\n\n \n\n#define RMI_F11_SINGLE_TAP              (1 << 0)\n#define RMI_F11_TAP_AND_HOLD            (1 << 1)\n#define RMI_F11_DOUBLE_TAP              (1 << 2)\n#define RMI_F11_EARLY_TAP               (1 << 3)\n#define RMI_F11_FLICK                   (1 << 4)\n#define RMI_F11_PRESS                   (1 << 5)\n#define RMI_F11_PINCH                   (1 << 6)\n\n \n\n#define RMI_F11_PALM_DETECT                     (1 << 0)\n#define RMI_F11_ROTATE                          (1 << 1)\n#define RMI_F11_SHAPE                           (1 << 2)\n#define RMI_F11_SCROLLZONE                      (1 << 3)\n#define RMI_F11_GESTURE_FINGER_COUNT_MASK       0x70\n\n \nstruct f11_2d_data {\n\tu8\t*f_state;\n\tu8\t*abs_pos;\n\ts8\t*rel_pos;\n\tu8\t*gest_1;\n\tu8\t*gest_2;\n\ts8\t*pinch;\n\tu8\t*flick;\n\tu8\t*rotate;\n\tu8\t*shapes;\n\ts8\t*multi_scroll;\n\ts8\t*scroll_zones;\n};\n\n \nstruct f11_data {\n\tbool has_query9;\n\tbool has_query11;\n\tbool has_query12;\n\tbool has_query27;\n\tbool has_query28;\n\tbool has_acm;\n\tstruct f11_2d_ctrl dev_controls;\n\tstruct mutex dev_controls_mutex;\n\tu16 rezero_wait_ms;\n\tstruct rmi_2d_sensor sensor;\n\tstruct f11_2d_sensor_queries sens_query;\n\tstruct f11_2d_data data;\n\tstruct rmi_2d_sensor_platform_data sensor_pdata;\n\tunsigned long *abs_mask;\n\tunsigned long *rel_mask;\n};\n\nenum f11_finger_state {\n\tF11_NO_FINGER\t= 0x00,\n\tF11_PRESENT\t= 0x01,\n\tF11_INACCURATE\t= 0x02,\n\tF11_RESERVED\t= 0x03\n};\n\nstatic void rmi_f11_rel_pos_report(struct f11_data *f11, u8 n_finger)\n{\n\tstruct rmi_2d_sensor *sensor = &f11->sensor;\n\tstruct f11_2d_data *data = &f11->data;\n\ts8 x, y;\n\n\tx = data->rel_pos[n_finger * RMI_F11_REL_BYTES];\n\ty = data->rel_pos[n_finger * RMI_F11_REL_BYTES + 1];\n\n\trmi_2d_sensor_rel_report(sensor, x, y);\n}\n\nstatic void rmi_f11_abs_pos_process(struct f11_data *f11,\n\t\t\t\t   struct rmi_2d_sensor *sensor,\n\t\t\t\t   struct rmi_2d_sensor_abs_object *obj,\n\t\t\t\t   enum f11_finger_state finger_state,\n\t\t\t\t   u8 n_finger)\n{\n\tstruct f11_2d_data *data = &f11->data;\n\tu8 *pos_data = &data->abs_pos[n_finger * RMI_F11_ABS_BYTES];\n\tint tool_type = MT_TOOL_FINGER;\n\n\tswitch (finger_state) {\n\tcase F11_PRESENT:\n\t\tobj->type = RMI_2D_OBJECT_FINGER;\n\t\tbreak;\n\tdefault:\n\t\tobj->type = RMI_2D_OBJECT_NONE;\n\t}\n\n\tobj->mt_tool = tool_type;\n\tobj->x = (pos_data[0] << 4) | (pos_data[2] & 0x0F);\n\tobj->y = (pos_data[1] << 4) | (pos_data[2] >> 4);\n\tobj->z = pos_data[4];\n\tobj->wx = pos_data[3] & 0x0f;\n\tobj->wy = pos_data[3] >> 4;\n\n\trmi_2d_sensor_abs_process(sensor, obj, n_finger);\n}\n\nstatic inline u8 rmi_f11_parse_finger_state(const u8 *f_state, u8 n_finger)\n{\n\treturn (f_state[n_finger / 4] >> (2 * (n_finger % 4))) &\n\t\t\t\t\t\t\tFINGER_STATE_MASK;\n}\n\nstatic void rmi_f11_finger_handler(struct f11_data *f11,\n\t\t\t\t   struct rmi_2d_sensor *sensor, int size)\n{\n\tconst u8 *f_state = f11->data.f_state;\n\tu8 finger_state;\n\tu8 i;\n\tint abs_fingers;\n\tint rel_fingers;\n\tint abs_size = sensor->nbr_fingers * RMI_F11_ABS_BYTES;\n\n\tif (sensor->report_abs) {\n\t\tif (abs_size > size)\n\t\t\tabs_fingers = size / RMI_F11_ABS_BYTES;\n\t\telse\n\t\t\tabs_fingers = sensor->nbr_fingers;\n\n\t\tfor (i = 0; i < abs_fingers; i++) {\n\t\t\t \n\t\t\tfinger_state = rmi_f11_parse_finger_state(f_state, i);\n\t\t\tif (finger_state == F11_RESERVED) {\n\t\t\t\tpr_err(\"Invalid finger state[%d]: 0x%02x\", i,\n\t\t\t\t\tfinger_state);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trmi_f11_abs_pos_process(f11, sensor, &sensor->objs[i],\n\t\t\t\t\t\t\tfinger_state, i);\n\t\t}\n\n\t\t \n\t\tif (sensor->kernel_tracking)\n\t\t\tinput_mt_assign_slots(sensor->input,\n\t\t\t\t\t      sensor->tracking_slots,\n\t\t\t\t\t      sensor->tracking_pos,\n\t\t\t\t\t      sensor->nbr_fingers,\n\t\t\t\t\t      sensor->dmax);\n\n\t\tfor (i = 0; i < abs_fingers; i++) {\n\t\t\tfinger_state = rmi_f11_parse_finger_state(f_state, i);\n\t\t\tif (finger_state == F11_RESERVED)\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\trmi_2d_sensor_abs_report(sensor, &sensor->objs[i], i);\n\t\t}\n\n\t\tinput_mt_sync_frame(sensor->input);\n\t} else if (sensor->report_rel) {\n\t\tif ((abs_size + sensor->nbr_fingers * RMI_F11_REL_BYTES) > size)\n\t\t\trel_fingers = (size - abs_size) / RMI_F11_REL_BYTES;\n\t\telse\n\t\t\trel_fingers = sensor->nbr_fingers;\n\n\t\tfor (i = 0; i < rel_fingers; i++)\n\t\t\trmi_f11_rel_pos_report(f11, i);\n\t}\n\n}\n\nstatic int f11_2d_construct_data(struct f11_data *f11)\n{\n\tstruct rmi_2d_sensor *sensor = &f11->sensor;\n\tstruct f11_2d_sensor_queries *query = &f11->sens_query;\n\tstruct f11_2d_data *data = &f11->data;\n\tint i;\n\n\tsensor->nbr_fingers = (query->nr_fingers == 5 ? 10 :\n\t\t\t\tquery->nr_fingers + 1);\n\n\tsensor->pkt_size = DIV_ROUND_UP(sensor->nbr_fingers, 4);\n\n\tif (query->has_abs) {\n\t\tsensor->pkt_size += (sensor->nbr_fingers * 5);\n\t\tsensor->attn_size = sensor->pkt_size;\n\t}\n\n\tif (query->has_rel)\n\t\tsensor->pkt_size +=  (sensor->nbr_fingers * 2);\n\n\t \n\tif (query->query7_nonzero)\n\t\tsensor->pkt_size += sizeof(u8);\n\n\t \n\tif (query->query7_nonzero || query->query8_nonzero)\n\t\tsensor->pkt_size += sizeof(u8);\n\n\tif (query->has_pinch || query->has_flick || query->has_rotate) {\n\t\tsensor->pkt_size += 3;\n\t\tif (!query->has_flick)\n\t\t\tsensor->pkt_size--;\n\t\tif (!query->has_rotate)\n\t\t\tsensor->pkt_size--;\n\t}\n\n\tif (query->has_touch_shapes)\n\t\tsensor->pkt_size +=\n\t\t\tDIV_ROUND_UP(query->nr_touch_shapes + 1, 8);\n\n\tsensor->data_pkt = devm_kzalloc(&sensor->fn->dev, sensor->pkt_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!sensor->data_pkt)\n\t\treturn -ENOMEM;\n\n\tdata->f_state = sensor->data_pkt;\n\ti = DIV_ROUND_UP(sensor->nbr_fingers, 4);\n\n\tif (query->has_abs) {\n\t\tdata->abs_pos = &sensor->data_pkt[i];\n\t\ti += (sensor->nbr_fingers * RMI_F11_ABS_BYTES);\n\t}\n\n\tif (query->has_rel) {\n\t\tdata->rel_pos = &sensor->data_pkt[i];\n\t\ti += (sensor->nbr_fingers * RMI_F11_REL_BYTES);\n\t}\n\n\tif (query->query7_nonzero) {\n\t\tdata->gest_1 = &sensor->data_pkt[i];\n\t\ti++;\n\t}\n\n\tif (query->query7_nonzero || query->query8_nonzero) {\n\t\tdata->gest_2 = &sensor->data_pkt[i];\n\t\ti++;\n\t}\n\n\tif (query->has_pinch) {\n\t\tdata->pinch = &sensor->data_pkt[i];\n\t\ti++;\n\t}\n\n\tif (query->has_flick) {\n\t\tif (query->has_pinch) {\n\t\t\tdata->flick = data->pinch;\n\t\t\ti += 2;\n\t\t} else {\n\t\t\tdata->flick = &sensor->data_pkt[i];\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\tif (query->has_rotate) {\n\t\tif (query->has_flick) {\n\t\t\tdata->rotate = data->flick + 1;\n\t\t} else {\n\t\t\tdata->rotate = &sensor->data_pkt[i];\n\t\t\ti += 2;\n\t\t}\n\t}\n\n\tif (query->has_touch_shapes)\n\t\tdata->shapes = &sensor->data_pkt[i];\n\n\treturn 0;\n}\n\nstatic int f11_read_control_regs(struct rmi_function *fn,\n\t\t\t\tstruct f11_2d_ctrl *ctrl, u16 ctrl_base_addr) {\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint error = 0;\n\n\tctrl->ctrl0_11_address = ctrl_base_addr;\n\terror = rmi_read_block(rmi_dev, ctrl_base_addr, ctrl->ctrl0_11,\n\t\t\t\tRMI_F11_CTRL_REG_COUNT);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev, \"Failed to read ctrl0, code: %d.\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int f11_write_control_regs(struct rmi_function *fn,\n\t\t\t\t\tstruct f11_2d_sensor_queries *query,\n\t\t\t\t\tstruct f11_2d_ctrl *ctrl,\n\t\t\t\t\tu16 ctrl_base_addr)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint error;\n\n\terror = rmi_write_block(rmi_dev, ctrl_base_addr, ctrl->ctrl0_11,\n\t\t\t\tRMI_F11_CTRL_REG_COUNT);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int rmi_f11_get_query_parameters(struct rmi_device *rmi_dev,\n\t\t\tstruct f11_data *f11,\n\t\t\tstruct f11_2d_sensor_queries *sensor_query,\n\t\t\tu16 query_base_addr)\n{\n\tint query_size;\n\tint rc;\n\tu8 query_buf[RMI_F11_QUERY_SIZE];\n\tbool has_query36 = false;\n\n\trc = rmi_read_block(rmi_dev, query_base_addr, query_buf,\n\t\t\t\tRMI_F11_QUERY_SIZE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsensor_query->nr_fingers = query_buf[0] & RMI_F11_NR_FINGERS_MASK;\n\tsensor_query->has_rel = !!(query_buf[0] & RMI_F11_HAS_REL);\n\tsensor_query->has_abs = !!(query_buf[0] & RMI_F11_HAS_ABS);\n\tsensor_query->has_gestures = !!(query_buf[0] & RMI_F11_HAS_GESTURES);\n\tsensor_query->has_sensitivity_adjust =\n\t\t!!(query_buf[0] & RMI_F11_HAS_SENSITIVITY_ADJ);\n\tsensor_query->configurable = !!(query_buf[0] & RMI_F11_CONFIGURABLE);\n\n\tsensor_query->nr_x_electrodes =\n\t\t\t\tquery_buf[1] & RMI_F11_NR_ELECTRODES_MASK;\n\tsensor_query->nr_y_electrodes =\n\t\t\t\tquery_buf[2] & RMI_F11_NR_ELECTRODES_MASK;\n\tsensor_query->max_electrodes =\n\t\t\t\tquery_buf[3] & RMI_F11_NR_ELECTRODES_MASK;\n\n\tquery_size = RMI_F11_QUERY_SIZE;\n\n\tif (sensor_query->has_abs) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->abs_data_size =\n\t\t\tquery_buf[0] & RMI_F11_ABS_DATA_SIZE_MASK;\n\t\tsensor_query->has_anchored_finger =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_ANCHORED_FINGER);\n\t\tsensor_query->has_adj_hyst =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_ADJ_HYST);\n\t\tsensor_query->has_dribble =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_DRIBBLE);\n\t\tsensor_query->has_bending_correction =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_BENDING_CORRECTION);\n\t\tsensor_query->has_large_object_suppression =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_LARGE_OBJECT_SUPPRESSION);\n\t\tsensor_query->has_jitter_filter =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_JITTER_FILTER);\n\t\tquery_size++;\n\t}\n\n\tif (sensor_query->has_rel) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size,\n\t\t\t\t\t&sensor_query->f11_2d_query6);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tquery_size++;\n\t}\n\n\tif (sensor_query->has_gestures) {\n\t\trc = rmi_read_block(rmi_dev, query_base_addr + query_size,\n\t\t\t\t\tquery_buf, RMI_F11_QUERY_GESTURE_SIZE);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->has_single_tap =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_SINGLE_TAP);\n\t\tsensor_query->has_tap_n_hold =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_TAP_AND_HOLD);\n\t\tsensor_query->has_double_tap =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_DOUBLE_TAP);\n\t\tsensor_query->has_early_tap =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_EARLY_TAP);\n\t\tsensor_query->has_flick =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_FLICK);\n\t\tsensor_query->has_press =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PRESS);\n\t\tsensor_query->has_pinch =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PINCH);\n\t\tsensor_query->has_chiral =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_CHIRAL);\n\n\t\t \n\t\tsensor_query->has_palm_det =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_PALM_DET);\n\t\tsensor_query->has_rotate =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_ROTATE);\n\t\tsensor_query->has_touch_shapes =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_TOUCH_SHAPES);\n\t\tsensor_query->has_scroll_zones =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_SCROLL_ZONES);\n\t\tsensor_query->has_individual_scroll_zones =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_INDIVIDUAL_SCROLL_ZONES);\n\t\tsensor_query->has_mf_scroll =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_MF_SCROLL);\n\t\tsensor_query->has_mf_edge_motion =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_MF_EDGE_MOTION);\n\t\tsensor_query->has_mf_scroll_inertia =\n\t\t\t!!(query_buf[1] & RMI_F11_HAS_MF_SCROLL_INERTIA);\n\n\t\tsensor_query->query7_nonzero = !!(query_buf[0]);\n\t\tsensor_query->query8_nonzero = !!(query_buf[1]);\n\n\t\tquery_size += 2;\n\t}\n\n\tif (f11->has_query9) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->has_pen =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PEN);\n\t\tsensor_query->has_proximity =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PROXIMITY);\n\t\tsensor_query->has_palm_det_sensitivity =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PALM_DET_SENSITIVITY);\n\t\tsensor_query->has_suppress_on_palm_detect =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_SUPPRESS_ON_PALM_DETECT);\n\t\tsensor_query->has_two_pen_thresholds =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_TWO_PEN_THRESHOLDS);\n\t\tsensor_query->has_contact_geometry =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_CONTACT_GEOMETRY);\n\t\tsensor_query->has_pen_hover_discrimination =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PEN_HOVER_DISCRIMINATION);\n\t\tsensor_query->has_pen_filters =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PEN_FILTERS);\n\n\t\tquery_size++;\n\t}\n\n\tif (sensor_query->has_touch_shapes) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->nr_touch_shapes = query_buf[0] &\n\t\t\t\tRMI_F11_NR_TOUCH_SHAPES_MASK;\n\n\t\tquery_size++;\n\t}\n\n\tif (f11->has_query11) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->has_z_tuning =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_Z_TUNING);\n\t\tsensor_query->has_algorithm_selection =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_ALGORITHM_SELECTION);\n\t\tsensor_query->has_w_tuning =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_W_TUNING);\n\t\tsensor_query->has_pitch_info =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PITCH_INFO);\n\t\tsensor_query->has_finger_size =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_FINGER_SIZE);\n\t\tsensor_query->has_segmentation_aggressiveness =\n\t\t\t!!(query_buf[0] &\n\t\t\t\tRMI_F11_HAS_SEGMENTATION_AGGRESSIVENESS);\n\t\tsensor_query->has_XY_clip =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_XY_CLIP);\n\t\tsensor_query->has_drumming_filter =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_DRUMMING_FILTER);\n\n\t\tquery_size++;\n\t}\n\n\tif (f11->has_query12) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->has_gapless_finger =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_GAPLESS_FINGER);\n\t\tsensor_query->has_gapless_finger_tuning =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_GAPLESS_FINGER_TUNING);\n\t\tsensor_query->has_8bit_w =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_8BIT_W);\n\t\tsensor_query->has_adjustable_mapping =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_ADJUSTABLE_MAPPING);\n\t\tsensor_query->has_info2 =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_INFO2);\n\t\tsensor_query->has_physical_props =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_PHYSICAL_PROPS);\n\t\tsensor_query->has_finger_limit =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_FINGER_LIMIT);\n\t\tsensor_query->has_linear_coeff_2 =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_LINEAR_COEFF);\n\n\t\tquery_size++;\n\t}\n\n\tif (sensor_query->has_jitter_filter) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->jitter_window_size = query_buf[0] &\n\t\t\tRMI_F11_JITTER_WINDOW_MASK;\n\t\tsensor_query->jitter_filter_type = (query_buf[0] &\n\t\t\tRMI_F11_JITTER_FILTER_MASK) >>\n\t\t\tRMI_F11_JITTER_FILTER_SHIFT;\n\n\t\tquery_size++;\n\t}\n\n\tif (sensor_query->has_info2) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size, query_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->light_control =\n\t\t\tquery_buf[0] & RMI_F11_LIGHT_CONTROL_MASK;\n\t\tsensor_query->is_clear =\n\t\t\t!!(query_buf[0] & RMI_F11_IS_CLEAR);\n\t\tsensor_query->clickpad_props =\n\t\t\t(query_buf[0] & RMI_F11_CLICKPAD_PROPS_MASK) >>\n\t\t\tRMI_F11_CLICKPAD_PROPS_SHIFT;\n\t\tsensor_query->mouse_buttons =\n\t\t\t(query_buf[0] & RMI_F11_MOUSE_BUTTONS_MASK) >>\n\t\t\tRMI_F11_MOUSE_BUTTONS_SHIFT;\n\t\tsensor_query->has_advanced_gestures =\n\t\t\t!!(query_buf[0] & RMI_F11_HAS_ADVANCED_GESTURES);\n\n\t\tquery_size++;\n\t}\n\n\tif (sensor_query->has_physical_props) {\n\t\trc = rmi_read_block(rmi_dev, query_base_addr\n\t\t\t+ query_size, query_buf, 4);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsensor_query->x_sensor_size_mm =\n\t\t\t(query_buf[0] | (query_buf[1] << 8)) / 10;\n\t\tsensor_query->y_sensor_size_mm =\n\t\t\t(query_buf[2] | (query_buf[3] << 8)) / 10;\n\n\t\t \n\t\tquery_size += 12;\n\t}\n\n\tif (f11->has_query27)\n\t\t++query_size;\n\n\tif (f11->has_query28) {\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size,\n\t\t\t\tquery_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\thas_query36 = !!(query_buf[0] & BIT(6));\n\t}\n\n\tif (has_query36) {\n\t\tquery_size += 2;\n\t\trc = rmi_read(rmi_dev, query_base_addr + query_size,\n\t\t\t\tquery_buf);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (!!(query_buf[0] & BIT(5)))\n\t\t\tf11->has_acm = true;\n\t}\n\n\treturn query_size;\n}\n\nstatic int rmi_f11_initialize(struct rmi_function *fn)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct f11_data *f11;\n\tstruct f11_2d_ctrl *ctrl;\n\tu8 query_offset;\n\tu16 query_base_addr;\n\tu16 control_base_addr;\n\tu16 max_x_pos, max_y_pos;\n\tint rc;\n\tconst struct rmi_device_platform_data *pdata =\n\t\t\t\trmi_get_platform_data(rmi_dev);\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_2d_sensor *sensor;\n\tu8 buf;\n\tint mask_size;\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"Initializing F11 values.\\n\");\n\n\tmask_size = BITS_TO_LONGS(drvdata->irq_count) * sizeof(unsigned long);\n\n\t \n\tf11 = devm_kzalloc(&fn->dev, sizeof(struct f11_data) + mask_size * 2,\n\t\t\tGFP_KERNEL);\n\tif (!f11)\n\t\treturn -ENOMEM;\n\n\tif (fn->dev.of_node) {\n\t\trc = rmi_2d_sensor_of_probe(&fn->dev, &f11->sensor_pdata);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tf11->sensor_pdata = pdata->sensor_pdata;\n\t}\n\n\tf11->rezero_wait_ms = f11->sensor_pdata.rezero_wait;\n\n\tf11->abs_mask = (unsigned long *)((char *)f11\n\t\t\t+ sizeof(struct f11_data));\n\tf11->rel_mask = (unsigned long *)((char *)f11\n\t\t\t+ sizeof(struct f11_data) + mask_size);\n\n\tset_bit(fn->irq_pos, f11->abs_mask);\n\tset_bit(fn->irq_pos + 1, f11->rel_mask);\n\n\tquery_base_addr = fn->fd.query_base_addr;\n\tcontrol_base_addr = fn->fd.control_base_addr;\n\n\trc = rmi_read(rmi_dev, query_base_addr, &buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tf11->has_query9 = !!(buf & RMI_F11_HAS_QUERY9);\n\tf11->has_query11 = !!(buf & RMI_F11_HAS_QUERY11);\n\tf11->has_query12 = !!(buf & RMI_F11_HAS_QUERY12);\n\tf11->has_query27 = !!(buf & RMI_F11_HAS_QUERY27);\n\tf11->has_query28 = !!(buf & RMI_F11_HAS_QUERY28);\n\n\tquery_offset = (query_base_addr + 1);\n\tsensor = &f11->sensor;\n\tsensor->fn = fn;\n\n\trc = rmi_f11_get_query_parameters(rmi_dev, f11,\n\t\t\t&f11->sens_query, query_offset);\n\tif (rc < 0)\n\t\treturn rc;\n\tquery_offset += rc;\n\n\trc = f11_read_control_regs(fn, &f11->dev_controls,\n\t\t\tcontrol_base_addr);\n\tif (rc < 0) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to read F11 control params.\\n\");\n\t\treturn rc;\n\t}\n\n\tif (f11->sens_query.has_info2) {\n\t\tif (f11->sens_query.is_clear)\n\t\t\tf11->sensor.sensor_type = rmi_sensor_touchscreen;\n\t\telse\n\t\t\tf11->sensor.sensor_type = rmi_sensor_touchpad;\n\t}\n\n\tsensor->report_abs = f11->sens_query.has_abs;\n\n\tsensor->axis_align =\n\t\tf11->sensor_pdata.axis_align;\n\n\tsensor->topbuttonpad = f11->sensor_pdata.topbuttonpad;\n\tsensor->kernel_tracking = f11->sensor_pdata.kernel_tracking;\n\tsensor->dmax = f11->sensor_pdata.dmax;\n\tsensor->dribble = f11->sensor_pdata.dribble;\n\tsensor->palm_detect = f11->sensor_pdata.palm_detect;\n\n\tif (f11->sens_query.has_physical_props) {\n\t\tsensor->x_mm = f11->sens_query.x_sensor_size_mm;\n\t\tsensor->y_mm = f11->sens_query.y_sensor_size_mm;\n\t} else {\n\t\tsensor->x_mm = f11->sensor_pdata.x_mm;\n\t\tsensor->y_mm = f11->sensor_pdata.y_mm;\n\t}\n\n\tif (sensor->sensor_type == rmi_sensor_default)\n\t\tsensor->sensor_type =\n\t\t\tf11->sensor_pdata.sensor_type;\n\n\tsensor->report_abs = sensor->report_abs\n\t\t&& !(f11->sensor_pdata.disable_report_mask\n\t\t\t& RMI_F11_DISABLE_ABS_REPORT);\n\n\tif (!sensor->report_abs)\n\t\t \n\t\tsensor->report_rel = f11->sens_query.has_rel;\n\n\trc = rmi_read_block(rmi_dev,\n\t\tcontrol_base_addr + F11_CTRL_SENSOR_MAX_X_POS_OFFSET,\n\t\t(u8 *)&max_x_pos, sizeof(max_x_pos));\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = rmi_read_block(rmi_dev,\n\t\tcontrol_base_addr + F11_CTRL_SENSOR_MAX_Y_POS_OFFSET,\n\t\t(u8 *)&max_y_pos, sizeof(max_y_pos));\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsensor->max_x = max_x_pos;\n\tsensor->max_y = max_y_pos;\n\n\trc = f11_2d_construct_data(f11);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (f11->has_acm)\n\t\tf11->sensor.attn_size += f11->sensor.nbr_fingers * 2;\n\n\t \n\tsensor->tracking_pos = devm_kcalloc(&fn->dev,\n\t\t\tsensor->nbr_fingers, sizeof(struct input_mt_pos),\n\t\t\tGFP_KERNEL);\n\tsensor->tracking_slots = devm_kcalloc(&fn->dev,\n\t\t\tsensor->nbr_fingers, sizeof(int), GFP_KERNEL);\n\tsensor->objs = devm_kcalloc(&fn->dev,\n\t\t\tsensor->nbr_fingers,\n\t\t\tsizeof(struct rmi_2d_sensor_abs_object),\n\t\t\tGFP_KERNEL);\n\tif (!sensor->tracking_pos || !sensor->tracking_slots || !sensor->objs)\n\t\treturn -ENOMEM;\n\n\tctrl = &f11->dev_controls;\n\tif (sensor->axis_align.delta_x_threshold)\n\t\tctrl->ctrl0_11[RMI_F11_DELTA_X_THRESHOLD] =\n\t\t\tsensor->axis_align.delta_x_threshold;\n\n\tif (sensor->axis_align.delta_y_threshold)\n\t\tctrl->ctrl0_11[RMI_F11_DELTA_Y_THRESHOLD] =\n\t\t\tsensor->axis_align.delta_y_threshold;\n\n\t \n\tif (sensor->axis_align.delta_x_threshold ||\n\t    sensor->axis_align.delta_y_threshold) {\n\t\tctrl->ctrl0_11[0] &= ~RMI_F11_REPORT_MODE_MASK;\n\t\tctrl->ctrl0_11[0] |= RMI_F11_REPORT_MODE_REDUCED;\n\t}\n\n\tif (f11->sens_query.has_dribble) {\n\t\tswitch (sensor->dribble) {\n\t\tcase RMI_REG_STATE_OFF:\n\t\t\tctrl->ctrl0_11[0] &= ~BIT(6);\n\t\t\tbreak;\n\t\tcase RMI_REG_STATE_ON:\n\t\t\tctrl->ctrl0_11[0] |= BIT(6);\n\t\t\tbreak;\n\t\tcase RMI_REG_STATE_DEFAULT:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (f11->sens_query.has_palm_det) {\n\t\tswitch (sensor->palm_detect) {\n\t\tcase RMI_REG_STATE_OFF:\n\t\t\tctrl->ctrl0_11[11] &= ~BIT(0);\n\t\t\tbreak;\n\t\tcase RMI_REG_STATE_ON:\n\t\t\tctrl->ctrl0_11[11] |= BIT(0);\n\t\t\tbreak;\n\t\tcase RMI_REG_STATE_DEFAULT:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = f11_write_control_regs(fn, &f11->sens_query,\n\t\t\t   &f11->dev_controls, fn->fd.control_base_addr);\n\tif (rc)\n\t\tdev_warn(&fn->dev, \"Failed to write control registers\\n\");\n\n\tmutex_init(&f11->dev_controls_mutex);\n\n\tdev_set_drvdata(&fn->dev, f11);\n\n\treturn 0;\n}\n\nstatic int rmi_f11_config(struct rmi_function *fn)\n{\n\tstruct f11_data *f11 = dev_get_drvdata(&fn->dev);\n\tstruct rmi_driver *drv = fn->rmi_dev->driver;\n\tstruct rmi_2d_sensor *sensor = &f11->sensor;\n\tint rc;\n\n\tif (!sensor->report_abs)\n\t\tdrv->clear_irq_bits(fn->rmi_dev, f11->abs_mask);\n\telse\n\t\tdrv->set_irq_bits(fn->rmi_dev, f11->abs_mask);\n\n\tif (!sensor->report_rel)\n\t\tdrv->clear_irq_bits(fn->rmi_dev, f11->rel_mask);\n\telse\n\t\tdrv->set_irq_bits(fn->rmi_dev, f11->rel_mask);\n\n\trc = f11_write_control_regs(fn, &f11->sens_query,\n\t\t\t   &f11->dev_controls, fn->fd.query_base_addr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic irqreturn_t rmi_f11_attention(int irq, void *ctx)\n{\n\tstruct rmi_function *fn = ctx;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tstruct f11_data *f11 = dev_get_drvdata(&fn->dev);\n\tu16 data_base_addr = fn->fd.data_base_addr;\n\tint error;\n\tint valid_bytes = f11->sensor.pkt_size;\n\n\tif (drvdata->attn_data.data) {\n\t\t \n\t\tif (f11->sensor.attn_size > drvdata->attn_data.size)\n\t\t\tvalid_bytes = drvdata->attn_data.size;\n\t\telse\n\t\t\tvalid_bytes = f11->sensor.attn_size;\n\t\tmemcpy(f11->sensor.data_pkt, drvdata->attn_data.data,\n\t\t\tvalid_bytes);\n\t\tdrvdata->attn_data.data += valid_bytes;\n\t\tdrvdata->attn_data.size -= valid_bytes;\n\t} else {\n\t\terror = rmi_read_block(rmi_dev,\n\t\t\t\tdata_base_addr, f11->sensor.data_pkt,\n\t\t\t\tf11->sensor.pkt_size);\n\t\tif (error < 0)\n\t\t\treturn IRQ_RETVAL(error);\n\t}\n\n\trmi_f11_finger_handler(f11, &f11->sensor, valid_bytes);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rmi_f11_resume(struct rmi_function *fn)\n{\n\tstruct f11_data *f11 = dev_get_drvdata(&fn->dev);\n\tint error;\n\n\trmi_dbg(RMI_DEBUG_FN, &fn->dev, \"Resuming...\\n\");\n\tif (!f11->rezero_wait_ms)\n\t\treturn 0;\n\n\tmdelay(f11->rezero_wait_ms);\n\n\terror = rmi_write(fn->rmi_dev, fn->fd.command_base_addr,\n\t\t\t\tRMI_F11_REZERO);\n\tif (error) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"%s: failed to issue rezero command, error = %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f11_probe(struct rmi_function *fn)\n{\n\tint error;\n\tstruct f11_data *f11;\n\n\terror = rmi_f11_initialize(fn);\n\tif (error)\n\t\treturn error;\n\n\tf11 = dev_get_drvdata(&fn->dev);\n\terror = rmi_2d_sensor_configure_input(fn, &f11->sensor);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstruct rmi_function_handler rmi_f11_handler = {\n\t.driver = {\n\t\t.name\t= \"rmi4_f11\",\n\t},\n\t.func\t\t= 0x11,\n\t.probe\t\t= rmi_f11_probe,\n\t.config\t\t= rmi_f11_config,\n\t.attention\t= rmi_f11_attention,\n\t.resume\t\t= rmi_f11_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}