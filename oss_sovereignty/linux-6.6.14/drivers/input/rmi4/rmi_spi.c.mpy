{
  "module_name": "rmi_spi.c",
  "hash_id": "ba74cab7e6b902c2a0259dd199fb34cb511d4853b643e44dbbdced2df8c7670e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_spi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rmi.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n#include \"rmi_driver.h\"\n\n#define RMI_SPI_DEFAULT_XFER_BUF_SIZE\t64\n\n#define RMI_PAGE_SELECT_REGISTER\t0x00FF\n#define RMI_SPI_PAGE(addr)\t\t(((addr) >> 8) & 0x80)\n#define RMI_SPI_XFER_SIZE_LIMIT\t\t255\n\n#define BUFFER_SIZE_INCREMENT 32\n\nenum rmi_spi_op {\n\tRMI_SPI_WRITE = 0,\n\tRMI_SPI_READ,\n\tRMI_SPI_V2_READ_UNIFIED,\n\tRMI_SPI_V2_READ_SPLIT,\n\tRMI_SPI_V2_WRITE,\n};\n\nstruct rmi_spi_cmd {\n\tenum rmi_spi_op op;\n\tu16 addr;\n};\n\nstruct rmi_spi_xport {\n\tstruct rmi_transport_dev xport;\n\tstruct spi_device *spi;\n\n\tstruct mutex page_mutex;\n\tint page;\n\n\tu8 *rx_buf;\n\tu8 *tx_buf;\n\tint xfer_buf_size;\n\n\tstruct spi_transfer *rx_xfers;\n\tstruct spi_transfer *tx_xfers;\n\tint rx_xfer_count;\n\tint tx_xfer_count;\n};\n\nstatic int rmi_spi_manage_pools(struct rmi_spi_xport *rmi_spi, int len)\n{\n\tstruct spi_device *spi = rmi_spi->spi;\n\tint buf_size = rmi_spi->xfer_buf_size\n\t\t? rmi_spi->xfer_buf_size : RMI_SPI_DEFAULT_XFER_BUF_SIZE;\n\tstruct spi_transfer *xfer_buf;\n\tvoid *buf;\n\tvoid *tmp;\n\n\twhile (buf_size < len)\n\t\tbuf_size *= 2;\n\n\tif (buf_size > RMI_SPI_XFER_SIZE_LIMIT)\n\t\tbuf_size = RMI_SPI_XFER_SIZE_LIMIT;\n\n\ttmp = rmi_spi->rx_buf;\n\tbuf = devm_kcalloc(&spi->dev, buf_size, 2,\n\t\t\t\tGFP_KERNEL | GFP_DMA);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trmi_spi->rx_buf = buf;\n\trmi_spi->tx_buf = &rmi_spi->rx_buf[buf_size];\n\trmi_spi->xfer_buf_size = buf_size;\n\n\tif (tmp)\n\t\tdevm_kfree(&spi->dev, tmp);\n\n\tif (rmi_spi->xport.pdata.spi_data.read_delay_us)\n\t\trmi_spi->rx_xfer_count = buf_size;\n\telse\n\t\trmi_spi->rx_xfer_count = 1;\n\n\tif (rmi_spi->xport.pdata.spi_data.write_delay_us)\n\t\trmi_spi->tx_xfer_count = buf_size;\n\telse\n\t\trmi_spi->tx_xfer_count = 1;\n\n\t \n\ttmp = rmi_spi->rx_xfers;\n\txfer_buf = devm_kcalloc(&spi->dev,\n\t\trmi_spi->rx_xfer_count + rmi_spi->tx_xfer_count,\n\t\tsizeof(struct spi_transfer),\n\t\tGFP_KERNEL);\n\tif (!xfer_buf)\n\t\treturn -ENOMEM;\n\n\trmi_spi->rx_xfers = xfer_buf;\n\trmi_spi->tx_xfers = &xfer_buf[rmi_spi->rx_xfer_count];\n\n\tif (tmp)\n\t\tdevm_kfree(&spi->dev, tmp);\n\n\treturn 0;\n}\n\nstatic int rmi_spi_xfer(struct rmi_spi_xport *rmi_spi,\n\t\t\tconst struct rmi_spi_cmd *cmd, const u8 *tx_buf,\n\t\t\tint tx_len, u8 *rx_buf, int rx_len)\n{\n\tstruct spi_device *spi = rmi_spi->spi;\n\tstruct rmi_device_platform_data_spi *spi_data =\n\t\t\t\t\t&rmi_spi->xport.pdata.spi_data;\n\tstruct spi_message msg;\n\tstruct spi_transfer *xfer;\n\tint ret = 0;\n\tint len;\n\tint cmd_len = 0;\n\tint total_tx_len;\n\tint i;\n\tu16 addr = cmd->addr;\n\n\tspi_message_init(&msg);\n\n\tswitch (cmd->op) {\n\tcase RMI_SPI_WRITE:\n\tcase RMI_SPI_READ:\n\t\tcmd_len += 2;\n\t\tbreak;\n\tcase RMI_SPI_V2_READ_UNIFIED:\n\tcase RMI_SPI_V2_READ_SPLIT:\n\tcase RMI_SPI_V2_WRITE:\n\t\tcmd_len += 4;\n\t\tbreak;\n\t}\n\n\ttotal_tx_len = cmd_len + tx_len;\n\tlen = max(total_tx_len, rx_len);\n\n\tif (len > RMI_SPI_XFER_SIZE_LIMIT)\n\t\treturn -EINVAL;\n\n\tif (rmi_spi->xfer_buf_size < len) {\n\t\tret = rmi_spi_manage_pools(rmi_spi, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (addr == 0)\n\t\t \n\t\taddr = 0x7FF;\n\n\tswitch (cmd->op) {\n\tcase RMI_SPI_WRITE:\n\t\trmi_spi->tx_buf[0] = (addr >> 8);\n\t\trmi_spi->tx_buf[1] = addr & 0xFF;\n\t\tbreak;\n\tcase RMI_SPI_READ:\n\t\trmi_spi->tx_buf[0] = (addr >> 8) | 0x80;\n\t\trmi_spi->tx_buf[1] = addr & 0xFF;\n\t\tbreak;\n\tcase RMI_SPI_V2_READ_UNIFIED:\n\t\tbreak;\n\tcase RMI_SPI_V2_READ_SPLIT:\n\t\tbreak;\n\tcase RMI_SPI_V2_WRITE:\n\t\trmi_spi->tx_buf[0] = 0x40;\n\t\trmi_spi->tx_buf[1] = (addr >> 8) & 0xFF;\n\t\trmi_spi->tx_buf[2] = addr & 0xFF;\n\t\trmi_spi->tx_buf[3] = tx_len;\n\t\tbreak;\n\t}\n\n\tif (tx_buf)\n\t\tmemcpy(&rmi_spi->tx_buf[cmd_len], tx_buf, tx_len);\n\n\tif (rmi_spi->tx_xfer_count > 1) {\n\t\tfor (i = 0; i < total_tx_len; i++) {\n\t\t\txfer = &rmi_spi->tx_xfers[i];\n\t\t\tmemset(xfer, 0,\tsizeof(struct spi_transfer));\n\t\t\txfer->tx_buf = &rmi_spi->tx_buf[i];\n\t\t\txfer->len = 1;\n\t\t\txfer->delay.value = spi_data->write_delay_us;\n\t\t\txfer->delay.unit = SPI_DELAY_UNIT_USECS;\n\t\t\tspi_message_add_tail(xfer, &msg);\n\t\t}\n\t} else {\n\t\txfer = rmi_spi->tx_xfers;\n\t\tmemset(xfer, 0, sizeof(struct spi_transfer));\n\t\txfer->tx_buf = rmi_spi->tx_buf;\n\t\txfer->len = total_tx_len;\n\t\tspi_message_add_tail(xfer, &msg);\n\t}\n\n\trmi_dbg(RMI_DEBUG_XPORT, &spi->dev, \"%s: cmd: %s tx_buf len: %d tx_buf: %*ph\\n\",\n\t\t__func__, cmd->op == RMI_SPI_WRITE ? \"WRITE\" : \"READ\",\n\t\ttotal_tx_len, total_tx_len, rmi_spi->tx_buf);\n\n\tif (rx_buf) {\n\t\tif (rmi_spi->rx_xfer_count > 1) {\n\t\t\tfor (i = 0; i < rx_len; i++) {\n\t\t\t\txfer = &rmi_spi->rx_xfers[i];\n\t\t\t\tmemset(xfer, 0, sizeof(struct spi_transfer));\n\t\t\t\txfer->rx_buf = &rmi_spi->rx_buf[i];\n\t\t\t\txfer->len = 1;\n\t\t\t\txfer->delay.value = spi_data->read_delay_us;\n\t\t\t\txfer->delay.unit = SPI_DELAY_UNIT_USECS;\n\t\t\t\tspi_message_add_tail(xfer, &msg);\n\t\t\t}\n\t\t} else {\n\t\t\txfer = rmi_spi->rx_xfers;\n\t\t\tmemset(xfer, 0, sizeof(struct spi_transfer));\n\t\t\txfer->rx_buf = rmi_spi->rx_buf;\n\t\t\txfer->len = rx_len;\n\t\t\tspi_message_add_tail(xfer, &msg);\n\t\t}\n\t}\n\n\tret = spi_sync(spi, &msg);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"spi xfer failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (rx_buf) {\n\t\tmemcpy(rx_buf, rmi_spi->rx_buf, rx_len);\n\t\trmi_dbg(RMI_DEBUG_XPORT, &spi->dev, \"%s: (%d) %*ph\\n\",\n\t\t\t__func__, rx_len, rx_len, rx_buf);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rmi_set_page(struct rmi_spi_xport *rmi_spi, u8 page)\n{\n\tstruct rmi_spi_cmd cmd;\n\tint ret;\n\n\tcmd.op = RMI_SPI_WRITE;\n\tcmd.addr = RMI_PAGE_SELECT_REGISTER;\n\n\tret = rmi_spi_xfer(rmi_spi, &cmd, &page, 1, NULL, 0);\n\n\tif (ret)\n\t\trmi_spi->page = page;\n\n\treturn ret;\n}\n\nstatic int rmi_spi_write_block(struct rmi_transport_dev *xport, u16 addr,\n\t\t\t       const void *buf, size_t len)\n{\n\tstruct rmi_spi_xport *rmi_spi =\n\t\tcontainer_of(xport, struct rmi_spi_xport, xport);\n\tstruct rmi_spi_cmd cmd;\n\tint ret;\n\n\tmutex_lock(&rmi_spi->page_mutex);\n\n\tif (RMI_SPI_PAGE(addr) != rmi_spi->page) {\n\t\tret = rmi_set_page(rmi_spi, RMI_SPI_PAGE(addr));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tcmd.op = RMI_SPI_WRITE;\n\tcmd.addr = addr;\n\n\tret = rmi_spi_xfer(rmi_spi, &cmd, buf, len, NULL, 0);\n\nexit:\n\tmutex_unlock(&rmi_spi->page_mutex);\n\treturn ret;\n}\n\nstatic int rmi_spi_read_block(struct rmi_transport_dev *xport, u16 addr,\n\t\t\t      void *buf, size_t len)\n{\n\tstruct rmi_spi_xport *rmi_spi =\n\t\tcontainer_of(xport, struct rmi_spi_xport, xport);\n\tstruct rmi_spi_cmd cmd;\n\tint ret;\n\n\tmutex_lock(&rmi_spi->page_mutex);\n\n\tif (RMI_SPI_PAGE(addr) != rmi_spi->page) {\n\t\tret = rmi_set_page(rmi_spi, RMI_SPI_PAGE(addr));\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tcmd.op = RMI_SPI_READ;\n\tcmd.addr = addr;\n\n\tret = rmi_spi_xfer(rmi_spi, &cmd, NULL, 0, buf, len);\n\nexit:\n\tmutex_unlock(&rmi_spi->page_mutex);\n\treturn ret;\n}\n\nstatic const struct rmi_transport_ops rmi_spi_ops = {\n\t.write_block\t= rmi_spi_write_block,\n\t.read_block\t= rmi_spi_read_block,\n};\n\n#ifdef CONFIG_OF\nstatic int rmi_spi_of_probe(struct spi_device *spi,\n\t\t\tstruct rmi_device_platform_data *pdata)\n{\n\tstruct device *dev = &spi->dev;\n\tint retval;\n\n\tretval = rmi_of_property_read_u32(dev,\n\t\t\t&pdata->spi_data.read_delay_us,\n\t\t\t\"spi-rx-delay-us\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rmi_of_property_read_u32(dev,\n\t\t\t&pdata->spi_data.write_delay_us,\n\t\t\t\"spi-tx-delay-us\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rmi_spi_of_match[] = {\n\t{ .compatible = \"syna,rmi4-spi\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rmi_spi_of_match);\n#else\nstatic inline int rmi_spi_of_probe(struct spi_device *spi,\n\t\t\t\tstruct rmi_device_platform_data *pdata)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic void rmi_spi_unregister_transport(void *data)\n{\n\tstruct rmi_spi_xport *rmi_spi = data;\n\n\trmi_unregister_transport_device(&rmi_spi->xport);\n}\n\nstatic int rmi_spi_probe(struct spi_device *spi)\n{\n\tstruct rmi_spi_xport *rmi_spi;\n\tstruct rmi_device_platform_data *pdata;\n\tstruct rmi_device_platform_data *spi_pdata = spi->dev.platform_data;\n\tint error;\n\n\tif (spi->master->flags & SPI_MASTER_HALF_DUPLEX)\n\t\treturn -EINVAL;\n\n\trmi_spi = devm_kzalloc(&spi->dev, sizeof(struct rmi_spi_xport),\n\t\t\tGFP_KERNEL);\n\tif (!rmi_spi)\n\t\treturn -ENOMEM;\n\n\tpdata = &rmi_spi->xport.pdata;\n\n\tif (spi->dev.of_node) {\n\t\terror = rmi_spi_of_probe(spi, pdata);\n\t\tif (error)\n\t\t\treturn error;\n\t} else if (spi_pdata) {\n\t\t*pdata = *spi_pdata;\n\t}\n\n\tif (pdata->spi_data.bits_per_word)\n\t\tspi->bits_per_word = pdata->spi_data.bits_per_word;\n\n\tif (pdata->spi_data.mode)\n\t\tspi->mode = pdata->spi_data.mode;\n\n\terror = spi_setup(spi);\n\tif (error < 0) {\n\t\tdev_err(&spi->dev, \"spi_setup failed!\\n\");\n\t\treturn error;\n\t}\n\n\tpdata->irq = spi->irq;\n\n\trmi_spi->spi = spi;\n\tmutex_init(&rmi_spi->page_mutex);\n\n\trmi_spi->xport.dev = &spi->dev;\n\trmi_spi->xport.proto_name = \"spi\";\n\trmi_spi->xport.ops = &rmi_spi_ops;\n\n\tspi_set_drvdata(spi, rmi_spi);\n\n\terror = rmi_spi_manage_pools(rmi_spi, RMI_SPI_DEFAULT_XFER_BUF_SIZE);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = rmi_set_page(rmi_spi, 0);\n\tif (error) {\n\t\tdev_err(&spi->dev, \"Failed to set page select to 0.\\n\");\n\t\treturn error;\n\t}\n\n\tdev_info(&spi->dev, \"registering SPI-connected sensor\\n\");\n\n\terror = rmi_register_transport_device(&rmi_spi->xport);\n\tif (error) {\n\t\tdev_err(&spi->dev, \"failed to register sensor: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&spi->dev,\n\t\t\t\t\t  rmi_spi_unregister_transport,\n\t\t\t\t\t  rmi_spi);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int rmi_spi_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct rmi_spi_xport *rmi_spi = spi_get_drvdata(spi);\n\tint ret;\n\n\tret = rmi_driver_suspend(rmi_spi->xport.rmi_dev, true);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rmi_spi_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct rmi_spi_xport *rmi_spi = spi_get_drvdata(spi);\n\tint ret;\n\n\tret = rmi_driver_resume(rmi_spi->xport.rmi_dev, true);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rmi_spi_runtime_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct rmi_spi_xport *rmi_spi = spi_get_drvdata(spi);\n\tint ret;\n\n\tret = rmi_driver_suspend(rmi_spi->xport.rmi_dev, false);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic int rmi_spi_runtime_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct rmi_spi_xport *rmi_spi = spi_get_drvdata(spi);\n\tint ret;\n\n\tret = rmi_driver_resume(rmi_spi->xport.rmi_dev, false);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rmi_spi_pm = {\n\tSYSTEM_SLEEP_PM_OPS(rmi_spi_suspend, rmi_spi_resume)\n\tRUNTIME_PM_OPS(rmi_spi_runtime_suspend, rmi_spi_runtime_resume, NULL)\n};\n\nstatic const struct spi_device_id rmi_id[] = {\n\t{ \"rmi4-spi\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, rmi_id);\n\nstatic struct spi_driver rmi_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"rmi4_spi\",\n\t\t.pm\t= pm_ptr(&rmi_spi_pm),\n\t\t.of_match_table = of_match_ptr(rmi_spi_of_match),\n\t},\n\t.id_table\t= rmi_id,\n\t.probe\t\t= rmi_spi_probe,\n};\n\nmodule_spi_driver(rmi_spi_driver);\n\nMODULE_AUTHOR(\"Christopher Heiny <cheiny@synaptics.com>\");\nMODULE_AUTHOR(\"Andrew Duggan <aduggan@synaptics.com>\");\nMODULE_DESCRIPTION(\"RMI SPI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}