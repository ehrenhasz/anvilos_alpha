{
  "module_name": "rmi_f03.c",
  "hash_id": "4bec5e7917c2d62a28261aaf657d346e0bab61864d7b664d72208e21766fa368",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f03.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/serio.h>\n#include <linux/notifier.h>\n#include \"rmi_driver.h\"\n\n#define RMI_F03_RX_DATA_OFB\t\t0x01\n#define RMI_F03_OB_SIZE\t\t\t2\n\n#define RMI_F03_OB_OFFSET\t\t2\n#define RMI_F03_OB_DATA_OFFSET\t\t1\n#define RMI_F03_OB_FLAG_TIMEOUT\t\tBIT(6)\n#define RMI_F03_OB_FLAG_PARITY\t\tBIT(7)\n\n#define RMI_F03_DEVICE_COUNT\t\t0x07\n#define RMI_F03_BYTES_PER_DEVICE\t0x07\n#define RMI_F03_BYTES_PER_DEVICE_SHIFT\t4\n#define RMI_F03_QUEUE_LENGTH\t\t0x0F\n\n#define PSMOUSE_OOB_EXTRA_BTNS\t\t0x01\n\nstruct f03_data {\n\tstruct rmi_function *fn;\n\n\tstruct serio *serio;\n\tbool serio_registered;\n\n\tunsigned int overwrite_buttons;\n\n\tu8 device_count;\n\tu8 rx_queue_length;\n};\n\nint rmi_f03_overwrite_button(struct rmi_function *fn, unsigned int button,\n\t\t\t     int value)\n{\n\tstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\n\tunsigned int bit;\n\n\tif (button < BTN_LEFT || button > BTN_MIDDLE)\n\t\treturn -EINVAL;\n\n\tbit = BIT(button - BTN_LEFT);\n\n\tif (value)\n\t\tf03->overwrite_buttons |= bit;\n\telse\n\t\tf03->overwrite_buttons &= ~bit;\n\n\treturn 0;\n}\n\nvoid rmi_f03_commit_buttons(struct rmi_function *fn)\n{\n\tstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\n\tstruct serio *serio = f03->serio;\n\n\tserio_pause_rx(serio);\n\tif (serio->drv) {\n\t\tserio->drv->interrupt(serio, PSMOUSE_OOB_EXTRA_BTNS,\n\t\t\t\t      SERIO_OOB_DATA);\n\t\tserio->drv->interrupt(serio, f03->overwrite_buttons,\n\t\t\t\t      SERIO_OOB_DATA);\n\t}\n\tserio_continue_rx(serio);\n}\n\nstatic int rmi_f03_pt_write(struct serio *id, unsigned char val)\n{\n\tstruct f03_data *f03 = id->port_data;\n\tint error;\n\n\trmi_dbg(RMI_DEBUG_FN, &f03->fn->dev,\n\t\t\"%s: Wrote %.2hhx to PS/2 passthrough address\",\n\t\t__func__, val);\n\n\terror = rmi_write(f03->fn->rmi_dev, f03->fn->fd.data_base_addr, val);\n\tif (error) {\n\t\tdev_err(&f03->fn->dev,\n\t\t\t\"%s: Failed to write to F03 TX register (%d).\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f03_initialize(struct f03_data *f03)\n{\n\tstruct rmi_function *fn = f03->fn;\n\tstruct device *dev = &fn->dev;\n\tint error;\n\tu8 bytes_per_device;\n\tu8 query1;\n\tu8 query2[RMI_F03_DEVICE_COUNT * RMI_F03_BYTES_PER_DEVICE];\n\tsize_t query2_len;\n\n\terror = rmi_read(fn->rmi_dev, fn->fd.query_base_addr, &query1);\n\tif (error) {\n\t\tdev_err(dev, \"Failed to read query register (%d).\\n\", error);\n\t\treturn error;\n\t}\n\n\tf03->device_count = query1 & RMI_F03_DEVICE_COUNT;\n\tbytes_per_device = (query1 >> RMI_F03_BYTES_PER_DEVICE_SHIFT) &\n\t\t\t\tRMI_F03_BYTES_PER_DEVICE;\n\n\tquery2_len = f03->device_count * bytes_per_device;\n\n\t \n\tif (query2_len < 1) {\n\t\tf03->device_count = 1;\n\t\tf03->rx_queue_length = 7;\n\t} else {\n\t\terror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr + 1,\n\t\t\t\t       query2, query2_len);\n\t\tif (error) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to read second set of query registers (%d).\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\n\t\tf03->rx_queue_length = query2[0] & RMI_F03_QUEUE_LENGTH;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f03_pt_open(struct serio *serio)\n{\n\tstruct f03_data *f03 = serio->port_data;\n\tstruct rmi_function *fn = f03->fn;\n\tconst u8 ob_len = f03->rx_queue_length * RMI_F03_OB_SIZE;\n\tconst u16 data_addr = fn->fd.data_base_addr + RMI_F03_OB_OFFSET;\n\tu8 obs[RMI_F03_QUEUE_LENGTH * RMI_F03_OB_SIZE];\n\tint error;\n\n\t \n\terror = rmi_read_block(fn->rmi_dev, data_addr, &obs, ob_len);\n\tif (!error)\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev,\n\t\t\t\"%s: Consumed %*ph (%d) from PS2 guest\\n\",\n\t\t\t__func__, ob_len, obs, ob_len);\n\n\treturn fn->rmi_dev->driver->set_irq_bits(fn->rmi_dev, fn->irq_mask);\n}\n\nstatic void rmi_f03_pt_close(struct serio *serio)\n{\n\tstruct f03_data *f03 = serio->port_data;\n\tstruct rmi_function *fn = f03->fn;\n\n\tfn->rmi_dev->driver->clear_irq_bits(fn->rmi_dev, fn->irq_mask);\n}\n\nstatic int rmi_f03_register_pt(struct f03_data *f03)\n{\n\tstruct serio *serio;\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type = SERIO_PS_PSTHRU;\n\tserio->write = rmi_f03_pt_write;\n\tserio->open = rmi_f03_pt_open;\n\tserio->close = rmi_f03_pt_close;\n\tserio->port_data = f03;\n\n\tstrscpy(serio->name, \"RMI4 PS/2 pass-through\", sizeof(serio->name));\n\tsnprintf(serio->phys, sizeof(serio->phys), \"%s/serio0\",\n\t\t dev_name(&f03->fn->dev));\n\tserio->dev.parent = &f03->fn->dev;\n\n\tf03->serio = serio;\n\n\tprintk(KERN_INFO \"serio: %s port at %s\\n\",\n\t\tserio->name, dev_name(&f03->fn->dev));\n\tserio_register_port(serio);\n\n\treturn 0;\n}\n\nstatic int rmi_f03_probe(struct rmi_function *fn)\n{\n\tstruct device *dev = &fn->dev;\n\tstruct f03_data *f03;\n\tint error;\n\n\tf03 = devm_kzalloc(dev, sizeof(struct f03_data), GFP_KERNEL);\n\tif (!f03)\n\t\treturn -ENOMEM;\n\n\tf03->fn = fn;\n\n\terror = rmi_f03_initialize(f03);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (f03->device_count != 1)\n\t\tdev_warn(dev, \"found %d devices on PS/2 passthrough\",\n\t\t\t f03->device_count);\n\n\tdev_set_drvdata(dev, f03);\n\treturn 0;\n}\n\nstatic int rmi_f03_config(struct rmi_function *fn)\n{\n\tstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\n\tint error;\n\n\tif (!f03->serio_registered) {\n\t\terror = rmi_f03_register_pt(f03);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tf03->serio_registered = true;\n\t} else {\n\t\t \n\t\tfn->rmi_dev->driver->set_irq_bits(fn->rmi_dev, fn->irq_mask);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t rmi_f03_attention(int irq, void *ctx)\n{\n\tstruct rmi_function *fn = ctx;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\n\tstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\n\tconst u16 data_addr = fn->fd.data_base_addr + RMI_F03_OB_OFFSET;\n\tconst u8 ob_len = f03->rx_queue_length * RMI_F03_OB_SIZE;\n\tu8 obs[RMI_F03_QUEUE_LENGTH * RMI_F03_OB_SIZE];\n\tu8 ob_status;\n\tu8 ob_data;\n\tunsigned int serio_flags;\n\tint i;\n\tint error;\n\n\tif (drvdata->attn_data.data) {\n\t\t \n\t\tif (drvdata->attn_data.size < ob_len) {\n\t\t\tdev_warn(&fn->dev, \"F03 interrupted, but data is missing!\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tmemcpy(obs, drvdata->attn_data.data, ob_len);\n\n\t\tdrvdata->attn_data.data += ob_len;\n\t\tdrvdata->attn_data.size -= ob_len;\n\t} else {\n\t\t \n\t\terror = rmi_read_block(fn->rmi_dev, data_addr, &obs, ob_len);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"%s: Failed to read F03 output buffers: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\tserio_interrupt(f03->serio, 0, SERIO_TIMEOUT);\n\t\t\treturn IRQ_RETVAL(error);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ob_len; i += RMI_F03_OB_SIZE) {\n\t\tob_status = obs[i];\n\t\tob_data = obs[i + RMI_F03_OB_DATA_OFFSET];\n\t\tserio_flags = 0;\n\n\t\tif (!(ob_status & RMI_F03_RX_DATA_OFB))\n\t\t\tcontinue;\n\n\t\tif (ob_status & RMI_F03_OB_FLAG_TIMEOUT)\n\t\t\tserio_flags |= SERIO_TIMEOUT;\n\t\tif (ob_status & RMI_F03_OB_FLAG_PARITY)\n\t\t\tserio_flags |= SERIO_PARITY;\n\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev,\n\t\t\t\"%s: Received %.2hhx from PS2 guest T: %c P: %c\\n\",\n\t\t\t__func__, ob_data,\n\t\t\tserio_flags & SERIO_TIMEOUT ?  'Y' : 'N',\n\t\t\tserio_flags & SERIO_PARITY ? 'Y' : 'N');\n\n\t\tserio_interrupt(f03->serio, ob_data, serio_flags);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rmi_f03_remove(struct rmi_function *fn)\n{\n\tstruct f03_data *f03 = dev_get_drvdata(&fn->dev);\n\n\tif (f03->serio_registered)\n\t\tserio_unregister_port(f03->serio);\n}\n\nstruct rmi_function_handler rmi_f03_handler = {\n\t.driver = {\n\t\t.name = \"rmi4_f03\",\n\t},\n\t.func = 0x03,\n\t.probe = rmi_f03_probe,\n\t.config = rmi_f03_config,\n\t.attention = rmi_f03_attention,\n\t.remove = rmi_f03_remove,\n};\n\nMODULE_AUTHOR(\"Lyude Paul <thatslyude@gmail.com>\");\nMODULE_DESCRIPTION(\"RMI F03 module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}