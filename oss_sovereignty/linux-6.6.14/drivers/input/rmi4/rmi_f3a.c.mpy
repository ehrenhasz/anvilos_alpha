{
  "module_name": "rmi_f3a.c",
  "hash_id": "5481fe61b5fd5b50fa0a34b207e3737e2f1090be2b883b3fdae55876d38cde5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f3a.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include \"rmi_driver.h\"\n\n#define RMI_F3A_MAX_GPIO_COUNT\t\t128\n#define RMI_F3A_MAX_REG_SIZE\t\tDIV_ROUND_UP(RMI_F3A_MAX_GPIO_COUNT, 8)\n\n \n#define RMI_F3A_GPIO_COUNT\t\t0x7F\n\n#define RMI_F3A_DATA_REGS_MAX_SIZE\tRMI_F3A_MAX_REG_SIZE\n\n#define TRACKSTICK_RANGE_START\t\t3\n#define TRACKSTICK_RANGE_END\t\t6\n\nstruct f3a_data {\n\t \n\tu8 gpio_count;\n\n\tu8 register_count;\n\n\tu8 data_regs[RMI_F3A_DATA_REGS_MAX_SIZE];\n\tu16 *gpio_key_map;\n\n\tstruct input_dev *input;\n\n\tstruct rmi_function *f03;\n\tbool trackstick_buttons;\n};\n\nstatic void rmi_f3a_report_button(struct rmi_function *fn,\n\t\t\t\t  struct f3a_data *f3a, unsigned int button)\n{\n\tu16 key_code = f3a->gpio_key_map[button];\n\tbool key_down = !(f3a->data_regs[0] & BIT(button));\n\n\tif (f3a->trackstick_buttons &&\n\t\tbutton >= TRACKSTICK_RANGE_START &&\n\t\tbutton <= TRACKSTICK_RANGE_END) {\n\t\trmi_f03_overwrite_button(f3a->f03, key_code, key_down);\n\t} else {\n\t\trmi_dbg(RMI_DEBUG_FN, &fn->dev,\n\t\t\t\"%s: call input report key (0x%04x) value (0x%02x)\",\n\t\t\t__func__, key_code, key_down);\n\t\tinput_report_key(f3a->input, key_code, key_down);\n\t}\n}\n\nstatic irqreturn_t rmi_f3a_attention(int irq, void *ctx)\n{\n\tstruct rmi_function *fn = ctx;\n\tstruct f3a_data *f3a = dev_get_drvdata(&fn->dev);\n\tstruct rmi_driver_data *drvdata = dev_get_drvdata(&fn->rmi_dev->dev);\n\tint error;\n\tint i;\n\n\tif (drvdata->attn_data.data) {\n\t\tif (drvdata->attn_data.size < f3a->register_count) {\n\t\t\tdev_warn(&fn->dev,\n\t\t\t\t \"F3A interrupted, but data is missing\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tmemcpy(f3a->data_regs, drvdata->attn_data.data,\n\t\t\tf3a->register_count);\n\t\tdrvdata->attn_data.data += f3a->register_count;\n\t\tdrvdata->attn_data.size -= f3a->register_count;\n\t} else {\n\t\terror = rmi_read_block(fn->rmi_dev, fn->fd.data_base_addr,\n\t\t\t\t\tf3a->data_regs, f3a->register_count);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"%s: Failed to read F3a data registers: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\treturn IRQ_RETVAL(error);\n\t\t}\n\t}\n\n\tfor (i = 0; i < f3a->gpio_count; i++)\n\t\tif (f3a->gpio_key_map[i] != KEY_RESERVED)\n\t\t\trmi_f3a_report_button(fn, f3a, i);\n\tif (f3a->trackstick_buttons)\n\t\trmi_f03_commit_buttons(f3a->f03);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rmi_f3a_config(struct rmi_function *fn)\n{\n\tstruct f3a_data *f3a = dev_get_drvdata(&fn->dev);\n\tstruct rmi_driver *drv = fn->rmi_dev->driver;\n\tconst struct rmi_device_platform_data *pdata =\n\t\t\trmi_get_platform_data(fn->rmi_dev);\n\n\tif (!f3a)\n\t\treturn 0;\n\n\tif (pdata->gpio_data.trackstick_buttons) {\n\t\t \n\t\tf3a->f03 = rmi_find_function(fn->rmi_dev, 0x03);\n\t\tf3a->trackstick_buttons = f3a->f03 != NULL;\n\t}\n\n\tdrv->set_irq_bits(fn->rmi_dev, fn->irq_mask);\n\n\treturn 0;\n}\n\nstatic bool rmi_f3a_is_valid_button(int button, struct f3a_data *f3a,\n\t\t\t\t\tu8 *query1_regs, u8 *ctrl1_regs)\n{\n\t \n\treturn (query1_regs[0] & BIT(button)) && !(ctrl1_regs[0] & BIT(button));\n}\n\nstatic int rmi_f3a_map_gpios(struct rmi_function *fn, struct f3a_data *f3a,\n\t\t\t\tu8 *query1_regs, u8 *ctrl1_regs)\n{\n\tconst struct rmi_device_platform_data *pdata =\n\t\t\trmi_get_platform_data(fn->rmi_dev);\n\tstruct input_dev *input = f3a->input;\n\tunsigned int button = BTN_LEFT;\n\tunsigned int trackstick_button = BTN_LEFT;\n\tbool button_mapped = false;\n\tint i;\n\tint button_count = min_t(u8, f3a->gpio_count, TRACKSTICK_RANGE_END);\n\n\tf3a->gpio_key_map = devm_kcalloc(&fn->dev,\n\t\t\t\t\t\tbutton_count,\n\t\t\t\t\t\tsizeof(f3a->gpio_key_map[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!f3a->gpio_key_map) {\n\t\tdev_err(&fn->dev, \"Failed to allocate gpio map memory.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < button_count; i++) {\n\t\tif (!rmi_f3a_is_valid_button(i, f3a, query1_regs, ctrl1_regs))\n\t\t\tcontinue;\n\n\t\tif (pdata->gpio_data.trackstick_buttons &&\n\t\t\ti >= TRACKSTICK_RANGE_START &&\n\t\t\ti < TRACKSTICK_RANGE_END) {\n\t\t\tf3a->gpio_key_map[i] = trackstick_button++;\n\t\t} else if (!pdata->gpio_data.buttonpad || !button_mapped) {\n\t\t\tf3a->gpio_key_map[i] = button;\n\t\t\tinput_set_capability(input, EV_KEY, button++);\n\t\t\tbutton_mapped = true;\n\t\t}\n\t}\n\tinput->keycode = f3a->gpio_key_map;\n\tinput->keycodesize = sizeof(f3a->gpio_key_map[0]);\n\tinput->keycodemax = f3a->gpio_count;\n\n\tif (pdata->gpio_data.buttonpad || (button - BTN_LEFT == 1))\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\treturn 0;\n}\n\nstatic int rmi_f3a_initialize(struct rmi_function *fn, struct f3a_data *f3a)\n{\n\tu8 query1[RMI_F3A_MAX_REG_SIZE];\n\tu8 ctrl1[RMI_F3A_MAX_REG_SIZE];\n\tu8 buf;\n\tint error;\n\n\terror = rmi_read(fn->rmi_dev, fn->fd.query_base_addr, &buf);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev, \"Failed to read general info register: %d\\n\",\n\t\t\terror);\n\t\treturn -ENODEV;\n\t}\n\n\tf3a->gpio_count = buf & RMI_F3A_GPIO_COUNT;\n\tf3a->register_count = DIV_ROUND_UP(f3a->gpio_count, 8);\n\n\t \n\terror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr + 1,\n\t\t\t\tquery1, f3a->register_count);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to read query1 register\\n\");\n\t\treturn error;\n\t}\n\n\t \n\terror = rmi_read_block(fn->rmi_dev, fn->fd.control_base_addr + 1,\n\t\t\t\tctrl1, f3a->register_count);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to read control1 register\\n\");\n\t\treturn error;\n\t}\n\n\terror = rmi_f3a_map_gpios(fn, f3a, query1, ctrl1);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int rmi_f3a_probe(struct rmi_function *fn)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct f3a_data *f3a;\n\tint error;\n\n\tif (!drv_data->input) {\n\t\tdev_info(&fn->dev, \"F3A: no input device found, ignoring\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tf3a = devm_kzalloc(&fn->dev, sizeof(*f3a), GFP_KERNEL);\n\tif (!f3a)\n\t\treturn -ENOMEM;\n\n\tf3a->input = drv_data->input;\n\n\terror = rmi_f3a_initialize(fn, f3a);\n\tif (error)\n\t\treturn error;\n\n\tdev_set_drvdata(&fn->dev, f3a);\n\treturn 0;\n}\n\nstruct rmi_function_handler rmi_f3a_handler = {\n\t.driver = {\n\t\t.name = \"rmi4_f3a\",\n\t},\n\t.func = 0x3a,\n\t.probe = rmi_f3a_probe,\n\t.config = rmi_f3a_config,\n\t.attention = rmi_f3a_attention,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}