{
  "module_name": "rmi_i2c.c",
  "hash_id": "893c92ce341bc68db5f76576b17fbd78458d46aac3d88a2f6905c9ac54cb5cc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/rmi.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include \"rmi_driver.h\"\n\n#define BUFFER_SIZE_INCREMENT 32\n\n \nstruct rmi_i2c_xport {\n\tstruct rmi_transport_dev xport;\n\tstruct i2c_client *client;\n\n\tstruct mutex page_mutex;\n\tint page;\n\n\tu8 *tx_buf;\n\tsize_t tx_buf_size;\n\n\tstruct regulator_bulk_data supplies[2];\n\tu32 startup_delay;\n};\n\n#define RMI_PAGE_SELECT_REGISTER 0xff\n#define RMI_I2C_PAGE(addr) (((addr) >> 8) & 0xff)\n\n \nstatic int rmi_set_page(struct rmi_i2c_xport *rmi_i2c, u8 page)\n{\n\tstruct i2c_client *client = rmi_i2c->client;\n\tu8 txbuf[2] = {RMI_PAGE_SELECT_REGISTER, page};\n\tint retval;\n\n\tretval = i2c_master_send(client, txbuf, sizeof(txbuf));\n\tif (retval != sizeof(txbuf)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s: set page failed: %d.\", __func__, retval);\n\t\treturn (retval < 0) ? retval : -EIO;\n\t}\n\n\trmi_i2c->page = page;\n\treturn 0;\n}\n\nstatic int rmi_i2c_write_block(struct rmi_transport_dev *xport, u16 addr,\n\t\t\t       const void *buf, size_t len)\n{\n\tstruct rmi_i2c_xport *rmi_i2c =\n\t\tcontainer_of(xport, struct rmi_i2c_xport, xport);\n\tstruct i2c_client *client = rmi_i2c->client;\n\tsize_t tx_size = len + 1;\n\tint retval;\n\n\tmutex_lock(&rmi_i2c->page_mutex);\n\n\tif (!rmi_i2c->tx_buf || rmi_i2c->tx_buf_size < tx_size) {\n\t\tif (rmi_i2c->tx_buf)\n\t\t\tdevm_kfree(&client->dev, rmi_i2c->tx_buf);\n\t\trmi_i2c->tx_buf_size = tx_size + BUFFER_SIZE_INCREMENT;\n\t\trmi_i2c->tx_buf = devm_kzalloc(&client->dev,\n\t\t\t\t\t       rmi_i2c->tx_buf_size,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!rmi_i2c->tx_buf) {\n\t\t\trmi_i2c->tx_buf_size = 0;\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trmi_i2c->tx_buf[0] = addr & 0xff;\n\tmemcpy(rmi_i2c->tx_buf + 1, buf, len);\n\n\tif (RMI_I2C_PAGE(addr) != rmi_i2c->page) {\n\t\tretval = rmi_set_page(rmi_i2c, RMI_I2C_PAGE(addr));\n\t\tif (retval)\n\t\t\tgoto exit;\n\t}\n\n\tretval = i2c_master_send(client, rmi_i2c->tx_buf, tx_size);\n\tif (retval == tx_size)\n\t\tretval = 0;\n\telse if (retval >= 0)\n\t\tretval = -EIO;\n\nexit:\n\trmi_dbg(RMI_DEBUG_XPORT, &client->dev,\n\t\t\"write %zd bytes at %#06x: %d (%*ph)\\n\",\n\t\tlen, addr, retval, (int)len, buf);\n\n\tmutex_unlock(&rmi_i2c->page_mutex);\n\treturn retval;\n}\n\nstatic int rmi_i2c_read_block(struct rmi_transport_dev *xport, u16 addr,\n\t\t\t      void *buf, size_t len)\n{\n\tstruct rmi_i2c_xport *rmi_i2c =\n\t\tcontainer_of(xport, struct rmi_i2c_xport, xport);\n\tstruct i2c_client *client = rmi_i2c->client;\n\tu8 addr_offset = addr & 0xff;\n\tint retval;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.len\t= sizeof(addr_offset),\n\t\t\t.buf\t= &addr_offset,\n\t\t},\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= len,\n\t\t\t.buf\t= buf,\n\t\t},\n\t};\n\n\tmutex_lock(&rmi_i2c->page_mutex);\n\n\tif (RMI_I2C_PAGE(addr) != rmi_i2c->page) {\n\t\tretval = rmi_set_page(rmi_i2c, RMI_I2C_PAGE(addr));\n\t\tif (retval)\n\t\t\tgoto exit;\n\t}\n\n\tretval = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (retval == ARRAY_SIZE(msgs))\n\t\tretval = 0;  \n\telse if (retval >= 0)\n\t\tretval = -EIO;\n\nexit:\n\trmi_dbg(RMI_DEBUG_XPORT, &client->dev,\n\t\t\"read %zd bytes at %#06x: %d (%*ph)\\n\",\n\t\tlen, addr, retval, (int)len, buf);\n\n\tmutex_unlock(&rmi_i2c->page_mutex);\n\treturn retval;\n}\n\nstatic const struct rmi_transport_ops rmi_i2c_ops = {\n\t.write_block\t= rmi_i2c_write_block,\n\t.read_block\t= rmi_i2c_read_block,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id rmi_i2c_of_match[] = {\n\t{ .compatible = \"syna,rmi4-i2c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rmi_i2c_of_match);\n#endif\n\nstatic void rmi_i2c_regulator_bulk_disable(void *data)\n{\n\tstruct rmi_i2c_xport *rmi_i2c = data;\n\n\tregulator_bulk_disable(ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t       rmi_i2c->supplies);\n}\n\nstatic void rmi_i2c_unregister_transport(void *data)\n{\n\tstruct rmi_i2c_xport *rmi_i2c = data;\n\n\trmi_unregister_transport_device(&rmi_i2c->xport);\n}\n\nstatic int rmi_i2c_probe(struct i2c_client *client)\n{\n\tstruct rmi_device_platform_data *pdata;\n\tstruct rmi_device_platform_data *client_pdata =\n\t\t\t\t\tdev_get_platdata(&client->dev);\n\tstruct rmi_i2c_xport *rmi_i2c;\n\tint error;\n\n\trmi_i2c = devm_kzalloc(&client->dev, sizeof(struct rmi_i2c_xport),\n\t\t\t\tGFP_KERNEL);\n\tif (!rmi_i2c)\n\t\treturn -ENOMEM;\n\n\tpdata = &rmi_i2c->xport.pdata;\n\n\tif (!client->dev.of_node && client_pdata)\n\t\t*pdata = *client_pdata;\n\n\tpdata->irq = client->irq;\n\n\trmi_dbg(RMI_DEBUG_XPORT, &client->dev, \"Probing %s.\\n\",\n\t\t\tdev_name(&client->dev));\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"adapter does not support required functionality\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trmi_i2c->supplies[0].supply = \"vdd\";\n\trmi_i2c->supplies[1].supply = \"vio\";\n\terror = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t\t ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t\t\t rmi_i2c->supplies);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = regulator_bulk_enable(ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t\t       rmi_i2c->supplies);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t  rmi_i2c_regulator_bulk_disable,\n\t\t\t\t\t  rmi_i2c);\n\tif (error)\n\t\treturn error;\n\n\tof_property_read_u32(client->dev.of_node, \"syna,startup-delay-ms\",\n\t\t\t     &rmi_i2c->startup_delay);\n\n\tmsleep(rmi_i2c->startup_delay);\n\n\trmi_i2c->client = client;\n\tmutex_init(&rmi_i2c->page_mutex);\n\n\trmi_i2c->xport.dev = &client->dev;\n\trmi_i2c->xport.proto_name = \"i2c\";\n\trmi_i2c->xport.ops = &rmi_i2c_ops;\n\n\ti2c_set_clientdata(client, rmi_i2c);\n\n\t \n\terror = rmi_set_page(rmi_i2c, 0);\n\tif (error) {\n\t\tdev_err(&client->dev, \"Failed to set page select to 0\\n\");\n\t\treturn error;\n\t}\n\n\tdev_info(&client->dev, \"registering I2C-connected sensor\\n\");\n\n\terror = rmi_register_transport_device(&rmi_i2c->xport);\n\tif (error) {\n\t\tdev_err(&client->dev, \"failed to register sensor: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = devm_add_action_or_reset(&client->dev,\n\t\t\t\t\t  rmi_i2c_unregister_transport,\n\t\t\t\t\t  rmi_i2c);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int rmi_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = rmi_driver_suspend(rmi_i2c->xport.rmi_dev, true);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\tregulator_bulk_disable(ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t       rmi_i2c->supplies);\n\n\treturn ret;\n}\n\nstatic int rmi_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t\t    rmi_i2c->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(rmi_i2c->startup_delay);\n\n\tret = rmi_driver_resume(rmi_i2c->xport.rmi_dev, true);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rmi_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = rmi_driver_suspend(rmi_i2c->xport.rmi_dev, false);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\tregulator_bulk_disable(ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t       rmi_i2c->supplies);\n\n\treturn 0;\n}\n\nstatic int rmi_i2c_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(rmi_i2c->supplies),\n\t\t\t\t    rmi_i2c->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(rmi_i2c->startup_delay);\n\n\tret = rmi_driver_resume(rmi_i2c->xport.rmi_dev, false);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to resume device: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rmi_i2c_pm = {\n\tSYSTEM_SLEEP_PM_OPS(rmi_i2c_suspend, rmi_i2c_resume)\n\tRUNTIME_PM_OPS(rmi_i2c_runtime_suspend, rmi_i2c_runtime_resume, NULL)\n};\n\nstatic const struct i2c_device_id rmi_id[] = {\n\t{ \"rmi4_i2c\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rmi_id);\n\nstatic struct i2c_driver rmi_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"rmi4_i2c\",\n\t\t.pm\t= pm_ptr(&rmi_i2c_pm),\n\t\t.of_match_table = of_match_ptr(rmi_i2c_of_match),\n\t},\n\t.id_table\t= rmi_id,\n\t.probe\t\t= rmi_i2c_probe,\n};\n\nmodule_i2c_driver(rmi_i2c_driver);\n\nMODULE_AUTHOR(\"Christopher Heiny <cheiny@synaptics.com>\");\nMODULE_AUTHOR(\"Andrew Duggan <aduggan@synaptics.com>\");\nMODULE_DESCRIPTION(\"RMI I2C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}