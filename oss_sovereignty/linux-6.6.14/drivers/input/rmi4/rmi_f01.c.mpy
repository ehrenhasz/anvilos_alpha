{
  "module_name": "rmi_f01.c",
  "hash_id": "5bc5eecca37e263ed288c99304e2d04377f844020b3f6ab66f4ad9080ad2cfe2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_f01.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/rmi.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/of.h>\n#include <asm/unaligned.h>\n#include \"rmi_driver.h\"\n\n#define RMI_PRODUCT_ID_LENGTH    10\n#define RMI_PRODUCT_INFO_LENGTH   2\n\n#define RMI_DATE_CODE_LENGTH      3\n\n#define PRODUCT_ID_OFFSET 0x10\n#define PRODUCT_INFO_OFFSET 0x1E\n\n\n \n#define RMI_F01_CMD_DEVICE_RESET\t1\n\n \n\n#define RMI_F01_QRY1_CUSTOM_MAP\t\tBIT(0)\n#define RMI_F01_QRY1_NON_COMPLIANT\tBIT(1)\n#define RMI_F01_QRY1_HAS_LTS\t\tBIT(2)\n#define RMI_F01_QRY1_HAS_SENSOR_ID\tBIT(3)\n#define RMI_F01_QRY1_HAS_CHARGER_INP\tBIT(4)\n#define RMI_F01_QRY1_HAS_ADJ_DOZE\tBIT(5)\n#define RMI_F01_QRY1_HAS_ADJ_DOZE_HOFF\tBIT(6)\n#define RMI_F01_QRY1_HAS_QUERY42\tBIT(7)\n\n#define RMI_F01_QRY5_YEAR_MASK\t\t0x1f\n#define RMI_F01_QRY6_MONTH_MASK\t\t0x0f\n#define RMI_F01_QRY7_DAY_MASK\t\t0x1f\n\n#define RMI_F01_QRY2_PRODINFO_MASK\t0x7f\n\n#define RMI_F01_BASIC_QUERY_LEN\t\t21  \n\nstruct f01_basic_properties {\n\tu8 manufacturer_id;\n\tbool has_lts;\n\tbool has_adjustable_doze;\n\tbool has_adjustable_doze_holdoff;\n\tchar dom[11];  \n\tu8 product_id[RMI_PRODUCT_ID_LENGTH + 1];\n\tu16 productinfo;\n\tu32 firmware_id;\n\tu32 package_id;\n};\n\n \n\n \n#define RMI_F01_STATUS_CODE(status)\t\t((status) & 0x0f)\n \n#define RMI_F01_STATUS_UNCONFIGURED(status)\t(!!((status) & 0x80))\n \n#define RMI_F01_STATUS_BOOTLOADER(status)\t((status) & 0x40)\n\n \n\n \n#define RMI_F01_CTRL0_SLEEP_MODE_MASK\t0x03\n\n#define RMI_SLEEP_MODE_NORMAL\t\t0x00\n#define RMI_SLEEP_MODE_SENSOR_SLEEP\t0x01\n#define RMI_SLEEP_MODE_RESERVED0\t0x02\n#define RMI_SLEEP_MODE_RESERVED1\t0x03\n\n \n#define RMI_F01_CTRL0_NOSLEEP_BIT\tBIT(2)\n\n \n#define RMI_F01_CTRL0_CHARGER_BIT\tBIT(5)\n\n \n#define RMI_F01_CTRL0_REPORTRATE_BIT\tBIT(6)\n\n \n#define RMI_F01_CTRL0_CONFIGURED_BIT\tBIT(7)\n\n \nstruct f01_device_control {\n\tu8 ctrl0;\n\tu8 doze_interval;\n\tu8 wakeup_threshold;\n\tu8 doze_holdoff;\n};\n\nstruct f01_data {\n\tstruct f01_basic_properties properties;\n\tstruct f01_device_control device_control;\n\n\tu16 doze_interval_addr;\n\tu16 wakeup_threshold_addr;\n\tu16 doze_holdoff_addr;\n\n\tbool suspended;\n\tbool old_nosleep;\n\n\tunsigned int num_of_irq_regs;\n};\n\nstatic int rmi_f01_read_properties(struct rmi_device *rmi_dev,\n\t\t\t\t   u16 query_base_addr,\n\t\t\t\t   struct f01_basic_properties *props)\n{\n\tu8 queries[RMI_F01_BASIC_QUERY_LEN];\n\tint ret;\n\tint query_offset = query_base_addr;\n\tbool has_ds4_queries = false;\n\tbool has_query42 = false;\n\tbool has_sensor_id = false;\n\tbool has_package_id_query = false;\n\tbool has_build_id_query = false;\n\tu16 prod_info_addr;\n\tu8 ds4_query_len;\n\n\tret = rmi_read_block(rmi_dev, query_offset,\n\t\t\t       queries, RMI_F01_BASIC_QUERY_LEN);\n\tif (ret) {\n\t\tdev_err(&rmi_dev->dev,\n\t\t\t\"Failed to read device query registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tprod_info_addr = query_offset + 17;\n\tquery_offset += RMI_F01_BASIC_QUERY_LEN;\n\n\t \n\tprops->manufacturer_id = queries[0];\n\n\tprops->has_lts = queries[1] & RMI_F01_QRY1_HAS_LTS;\n\tprops->has_adjustable_doze =\n\t\t\tqueries[1] & RMI_F01_QRY1_HAS_ADJ_DOZE;\n\tprops->has_adjustable_doze_holdoff =\n\t\t\tqueries[1] & RMI_F01_QRY1_HAS_ADJ_DOZE_HOFF;\n\thas_query42 = queries[1] & RMI_F01_QRY1_HAS_QUERY42;\n\thas_sensor_id = queries[1] & RMI_F01_QRY1_HAS_SENSOR_ID;\n\n\tsnprintf(props->dom, sizeof(props->dom), \"20%02d/%02d/%02d\",\n\t\t queries[5] & RMI_F01_QRY5_YEAR_MASK,\n\t\t queries[6] & RMI_F01_QRY6_MONTH_MASK,\n\t\t queries[7] & RMI_F01_QRY7_DAY_MASK);\n\n\tmemcpy(props->product_id, &queries[11],\n\t\tRMI_PRODUCT_ID_LENGTH);\n\tprops->product_id[RMI_PRODUCT_ID_LENGTH] = '\\0';\n\n\tprops->productinfo =\n\t\t\t((queries[2] & RMI_F01_QRY2_PRODINFO_MASK) << 7) |\n\t\t\t(queries[3] & RMI_F01_QRY2_PRODINFO_MASK);\n\n\tif (has_sensor_id)\n\t\tquery_offset++;\n\n\tif (has_query42) {\n\t\tret = rmi_read(rmi_dev, query_offset, queries);\n\t\tif (ret) {\n\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\"Failed to read query 42 register: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\thas_ds4_queries = !!(queries[0] & BIT(0));\n\t\tquery_offset++;\n\t}\n\n\tif (has_ds4_queries) {\n\t\tret = rmi_read(rmi_dev, query_offset, &ds4_query_len);\n\t\tif (ret) {\n\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\"Failed to read DS4 queries length: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tquery_offset++;\n\n\t\tif (ds4_query_len > 0) {\n\t\t\tret = rmi_read(rmi_dev, query_offset, queries);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\t\"Failed to read DS4 queries: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\thas_package_id_query = !!(queries[0] & BIT(0));\n\t\t\thas_build_id_query = !!(queries[0] & BIT(1));\n\t\t}\n\n\t\tif (has_package_id_query) {\n\t\t\tret = rmi_read_block(rmi_dev, prod_info_addr,\n\t\t\t\t\t     queries, sizeof(__le64));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\t\"Failed to read package info: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tprops->package_id = get_unaligned_le64(queries);\n\t\t\tprod_info_addr++;\n\t\t}\n\n\t\tif (has_build_id_query) {\n\t\t\tret = rmi_read_block(rmi_dev, prod_info_addr, queries,\n\t\t\t\t\t    3);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&rmi_dev->dev,\n\t\t\t\t\t\"Failed to read product info: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tprops->firmware_id = queries[1] << 8 | queries[0];\n\t\t\tprops->firmware_id += queries[2] * 65536;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nconst char *rmi_f01_get_product_ID(struct rmi_function *fn)\n{\n\tstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\n\n\treturn f01->properties.product_id;\n}\n\nstatic ssize_t rmi_driver_manufacturer_id_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *dattr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct f01_data *f01 = dev_get_drvdata(&data->f01_container->dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t f01->properties.manufacturer_id);\n}\n\nstatic DEVICE_ATTR(manufacturer_id, 0444,\n\t\t   rmi_driver_manufacturer_id_show, NULL);\n\nstatic ssize_t rmi_driver_dom_show(struct device *dev,\n\t\t\t\t   struct device_attribute *dattr, char *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct f01_data *f01 = dev_get_drvdata(&data->f01_container->dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", f01->properties.dom);\n}\n\nstatic DEVICE_ATTR(date_of_manufacture, 0444, rmi_driver_dom_show, NULL);\n\nstatic ssize_t rmi_driver_product_id_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *dattr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct f01_data *f01 = dev_get_drvdata(&data->f01_container->dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", f01->properties.product_id);\n}\n\nstatic DEVICE_ATTR(product_id, 0444, rmi_driver_product_id_show, NULL);\n\nstatic ssize_t rmi_driver_firmware_id_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *dattr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct f01_data *f01 = dev_get_drvdata(&data->f01_container->dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", f01->properties.firmware_id);\n}\n\nstatic DEVICE_ATTR(firmware_id, 0444, rmi_driver_firmware_id_show, NULL);\n\nstatic ssize_t rmi_driver_package_id_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *dattr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct rmi_driver_data *data = dev_get_drvdata(dev);\n\tstruct f01_data *f01 = dev_get_drvdata(&data->f01_container->dev);\n\n\tu32 package_id = f01->properties.package_id;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%04x.%04x\\n\",\n\t\t\t package_id & 0xffff, (package_id >> 16) & 0xffff);\n}\n\nstatic DEVICE_ATTR(package_id, 0444, rmi_driver_package_id_show, NULL);\n\nstatic struct attribute *rmi_f01_attrs[] = {\n\t&dev_attr_manufacturer_id.attr,\n\t&dev_attr_date_of_manufacture.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_firmware_id.attr,\n\t&dev_attr_package_id.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rmi_f01_attr_group = {\n\t.attrs = rmi_f01_attrs,\n};\n\n#ifdef CONFIG_OF\nstatic int rmi_f01_of_probe(struct device *dev,\n\t\t\t\tstruct rmi_device_platform_data *pdata)\n{\n\tint retval;\n\tu32 val;\n\n\tretval = rmi_of_property_read_u32(dev,\n\t\t\t(u32 *)&pdata->power_management.nosleep,\n\t\t\t\"syna,nosleep-mode\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rmi_of_property_read_u32(dev, &val,\n\t\t\t\"syna,wakeup-threshold\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->power_management.wakeup_threshold = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val,\n\t\t\t\"syna,doze-holdoff-ms\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->power_management.doze_holdoff = val * 100;\n\n\tretval = rmi_of_property_read_u32(dev, &val,\n\t\t\t\"syna,doze-interval-ms\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->power_management.doze_interval = val / 10;\n\n\treturn 0;\n}\n#else\nstatic inline int rmi_f01_of_probe(struct device *dev,\n\t\t\t\t\tstruct rmi_device_platform_data *pdata)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int rmi_f01_probe(struct rmi_function *fn)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *driver_data = dev_get_drvdata(&rmi_dev->dev);\n\tstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\n\tstruct f01_data *f01;\n\tint error;\n\tu16 ctrl_base_addr = fn->fd.control_base_addr;\n\tu8 device_status;\n\tu8 temp;\n\n\tif (fn->dev.of_node) {\n\t\terror = rmi_f01_of_probe(&fn->dev, pdata);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tf01 = devm_kzalloc(&fn->dev, sizeof(struct f01_data), GFP_KERNEL);\n\tif (!f01)\n\t\treturn -ENOMEM;\n\n\tf01->num_of_irq_regs = driver_data->num_of_irq_regs;\n\n\t \n\n\terror = rmi_read(rmi_dev, fn->fd.control_base_addr,\n\t\t\t &f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to read F01 control: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tswitch (pdata->power_management.nosleep) {\n\tcase RMI_REG_STATE_DEFAULT:\n\t\tbreak;\n\tcase RMI_REG_STATE_OFF:\n\t\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_NOSLEEP_BIT;\n\t\tbreak;\n\tcase RMI_REG_STATE_ON:\n\t\tf01->device_control.ctrl0 |= RMI_F01_CTRL0_NOSLEEP_BIT;\n\t\tbreak;\n\t}\n\n\t \n\tif ((f01->device_control.ctrl0 & RMI_F01_CTRL0_SLEEP_MODE_MASK) !=\n\t\t\tRMI_SLEEP_MODE_NORMAL) {\n\t\tdev_warn(&fn->dev,\n\t\t\t \"WARNING: Non-zero sleep mode found. Clearing...\\n\");\n\t\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\n\t}\n\n\tf01->device_control.ctrl0 |= RMI_F01_CTRL0_CONFIGURED_BIT;\n\n\terror = rmi_write(rmi_dev, fn->fd.control_base_addr,\n\t\t\t  f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to write F01 control: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\terror = rmi_read(rmi_dev, fn->fd.data_base_addr + 1, &temp);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev, \"Failed to read Interrupt Status.\\n\");\n\t\treturn error;\n\t}\n\n\terror = rmi_f01_read_properties(rmi_dev, fn->fd.query_base_addr,\n\t\t\t\t\t&f01->properties);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev, \"Failed to read F01 properties.\\n\");\n\t\treturn error;\n\t}\n\n\tdev_info(&fn->dev, \"found RMI device, manufacturer: %s, product: %s, fw id: %d\\n\",\n\t\t f01->properties.manufacturer_id == 1 ? \"Synaptics\" : \"unknown\",\n\t\t f01->properties.product_id, f01->properties.firmware_id);\n\n\t \n\tctrl_base_addr++;\n\tctrl_base_addr += f01->num_of_irq_regs;\n\n\t \n\tif (f01->properties.has_adjustable_doze) {\n\t\tf01->doze_interval_addr = ctrl_base_addr;\n\t\tctrl_base_addr++;\n\n\t\tif (pdata->power_management.doze_interval) {\n\t\t\tf01->device_control.doze_interval =\n\t\t\t\tpdata->power_management.doze_interval;\n\t\t\terror = rmi_write(rmi_dev, f01->doze_interval_addr,\n\t\t\t\t\t  f01->device_control.doze_interval);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&fn->dev,\n\t\t\t\t\t\"Failed to configure F01 doze interval register: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else {\n\t\t\terror = rmi_read(rmi_dev, f01->doze_interval_addr,\n\t\t\t\t\t &f01->device_control.doze_interval);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&fn->dev,\n\t\t\t\t\t\"Failed to read F01 doze interval register: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tf01->wakeup_threshold_addr = ctrl_base_addr;\n\t\tctrl_base_addr++;\n\n\t\tif (pdata->power_management.wakeup_threshold) {\n\t\t\tf01->device_control.wakeup_threshold =\n\t\t\t\tpdata->power_management.wakeup_threshold;\n\t\t\terror = rmi_write(rmi_dev, f01->wakeup_threshold_addr,\n\t\t\t\t\t  f01->device_control.wakeup_threshold);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&fn->dev,\n\t\t\t\t\t\"Failed to configure F01 wakeup threshold register: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else {\n\t\t\terror = rmi_read(rmi_dev, f01->wakeup_threshold_addr,\n\t\t\t\t\t &f01->device_control.wakeup_threshold);\n\t\t\tif (error < 0) {\n\t\t\t\tdev_err(&fn->dev,\n\t\t\t\t\t\"Failed to read F01 wakeup threshold register: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (f01->properties.has_lts)\n\t\tctrl_base_addr++;\n\n\tif (f01->properties.has_adjustable_doze_holdoff) {\n\t\tf01->doze_holdoff_addr = ctrl_base_addr;\n\t\tctrl_base_addr++;\n\n\t\tif (pdata->power_management.doze_holdoff) {\n\t\t\tf01->device_control.doze_holdoff =\n\t\t\t\tpdata->power_management.doze_holdoff;\n\t\t\terror = rmi_write(rmi_dev, f01->doze_holdoff_addr,\n\t\t\t\t\t  f01->device_control.doze_holdoff);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&fn->dev,\n\t\t\t\t\t\"Failed to configure F01 doze holdoff register: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else {\n\t\t\terror = rmi_read(rmi_dev, f01->doze_holdoff_addr,\n\t\t\t\t\t &f01->device_control.doze_holdoff);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&fn->dev,\n\t\t\t\t\t\"Failed to read F01 doze holdoff register: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\terror = rmi_read(rmi_dev, fn->fd.data_base_addr, &device_status);\n\tif (error < 0) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to read device status: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (RMI_F01_STATUS_UNCONFIGURED(device_status)) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Device was reset during configuration process, status: %#02x!\\n\",\n\t\t\tRMI_F01_STATUS_CODE(device_status));\n\t\treturn -EINVAL;\n\t}\n\n\tdev_set_drvdata(&fn->dev, f01);\n\n\terror = sysfs_create_group(&fn->rmi_dev->dev.kobj, &rmi_f01_attr_group);\n\tif (error)\n\t\tdev_warn(&fn->dev, \"Failed to create sysfs group: %d\\n\", error);\n\n\treturn 0;\n}\n\nstatic void rmi_f01_remove(struct rmi_function *fn)\n{\n\t \n\tsysfs_remove_group(&fn->rmi_dev->dev.kobj, &rmi_f01_attr_group);\n}\n\nstatic int rmi_f01_config(struct rmi_function *fn)\n{\n\tstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\n\tint error;\n\n\terror = rmi_write(fn->rmi_dev, fn->fd.control_base_addr,\n\t\t\t  f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to write device_control register: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (f01->properties.has_adjustable_doze) {\n\t\terror = rmi_write(fn->rmi_dev, f01->doze_interval_addr,\n\t\t\t\t  f01->device_control.doze_interval);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"Failed to write doze interval: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = rmi_write_block(fn->rmi_dev,\n\t\t\t\t\t f01->wakeup_threshold_addr,\n\t\t\t\t\t &f01->device_control.wakeup_threshold,\n\t\t\t\t\t sizeof(u8));\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"Failed to write wakeup threshold: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (f01->properties.has_adjustable_doze_holdoff) {\n\t\terror = rmi_write(fn->rmi_dev, f01->doze_holdoff_addr,\n\t\t\t\t  f01->device_control.doze_holdoff);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev,\n\t\t\t\t\"Failed to write doze holdoff: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f01_suspend(struct rmi_function *fn)\n{\n\tstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\n\tint error;\n\n\tf01->old_nosleep =\n\t\tf01->device_control.ctrl0 & RMI_F01_CTRL0_NOSLEEP_BIT;\n\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_NOSLEEP_BIT;\n\n\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\n\tif (device_may_wakeup(fn->rmi_dev->xport->dev))\n\t\tf01->device_control.ctrl0 |= RMI_SLEEP_MODE_RESERVED1;\n\telse\n\t\tf01->device_control.ctrl0 |= RMI_SLEEP_MODE_SENSOR_SLEEP;\n\n\terror = rmi_write(fn->rmi_dev, fn->fd.control_base_addr,\n\t\t\t  f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev, \"Failed to write sleep mode: %d.\\n\", error);\n\t\tif (f01->old_nosleep)\n\t\t\tf01->device_control.ctrl0 |= RMI_F01_CTRL0_NOSLEEP_BIT;\n\t\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\n\t\tf01->device_control.ctrl0 |= RMI_SLEEP_MODE_NORMAL;\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_f01_resume(struct rmi_function *fn)\n{\n\tstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\n\tint error;\n\n\tif (f01->old_nosleep)\n\t\tf01->device_control.ctrl0 |= RMI_F01_CTRL0_NOSLEEP_BIT;\n\n\tf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\n\tf01->device_control.ctrl0 |= RMI_SLEEP_MODE_NORMAL;\n\n\terror = rmi_write(fn->rmi_dev, fn->fd.control_base_addr,\n\t\t\t  f01->device_control.ctrl0);\n\tif (error) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to restore normal operation: %d.\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t rmi_f01_attention(int irq, void *ctx)\n{\n\tstruct rmi_function *fn = ctx;\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tint error;\n\tu8 device_status;\n\n\terror = rmi_read(rmi_dev, fn->fd.data_base_addr, &device_status);\n\tif (error) {\n\t\tdev_err(&fn->dev,\n\t\t\t\"Failed to read device status: %d.\\n\", error);\n\t\treturn IRQ_RETVAL(error);\n\t}\n\n\tif (RMI_F01_STATUS_BOOTLOADER(device_status))\n\t\tdev_warn(&fn->dev,\n\t\t\t \"Device in bootloader mode, please update firmware\\n\");\n\n\tif (RMI_F01_STATUS_UNCONFIGURED(device_status)) {\n\t\tdev_warn(&fn->dev, \"Device reset detected.\\n\");\n\t\terror = rmi_dev->driver->reset_handler(rmi_dev);\n\t\tif (error) {\n\t\t\tdev_err(&fn->dev, \"Device reset failed: %d\\n\", error);\n\t\t\treturn IRQ_RETVAL(error);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstruct rmi_function_handler rmi_f01_handler = {\n\t.driver = {\n\t\t.name\t= \"rmi4_f01\",\n\t\t \n\t\t.suppress_bind_attrs = true,\n\t},\n\t.func\t\t= 0x01,\n\t.probe\t\t= rmi_f01_probe,\n\t.remove\t\t= rmi_f01_remove,\n\t.config\t\t= rmi_f01_config,\n\t.attention\t= rmi_f01_attention,\n\t.suspend\t= rmi_f01_suspend,\n\t.resume\t\t= rmi_f01_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}