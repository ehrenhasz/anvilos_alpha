{
  "module_name": "rmi_2d_sensor.c",
  "hash_id": "726783ed8324b489551ae6251949dc5fa1e795c86a6d27014904a2e11e0ec0d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/input/rmi4/rmi_2d_sensor.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/rmi.h>\n#include \"rmi_driver.h\"\n#include \"rmi_2d_sensor.h\"\n\n#define RMI_2D_REL_POS_MIN\t\t-128\n#define RMI_2D_REL_POS_MAX\t\t127\n\n \n#define DMAX 10\n\nvoid rmi_2d_sensor_abs_process(struct rmi_2d_sensor *sensor,\n\t\t\t\tstruct rmi_2d_sensor_abs_object *obj,\n\t\t\t\tint slot)\n{\n\tstruct rmi_2d_axis_alignment *axis_align = &sensor->axis_align;\n\n\t \n\tif (obj->type == RMI_2D_OBJECT_NONE)\n\t\treturn;\n\n\tif (axis_align->flip_x)\n\t\tobj->x = sensor->max_x - obj->x;\n\n\tif (axis_align->flip_y)\n\t\tobj->y = sensor->max_y - obj->y;\n\n\tif (axis_align->swap_axes)\n\t\tswap(obj->x, obj->y);\n\n\t \n\tobj->x += axis_align->offset_x;\n\tobj->y += axis_align->offset_y;\n\n\tobj->x =  max(axis_align->clip_x_low, obj->x);\n\tobj->y =  max(axis_align->clip_y_low, obj->y);\n\n\tif (axis_align->clip_x_high)\n\t\tobj->x = min(sensor->max_x, obj->x);\n\n\tif (axis_align->clip_y_high)\n\t\tobj->y =  min(sensor->max_y, obj->y);\n\n\tsensor->tracking_pos[slot].x = obj->x;\n\tsensor->tracking_pos[slot].y = obj->y;\n}\nEXPORT_SYMBOL_GPL(rmi_2d_sensor_abs_process);\n\nvoid rmi_2d_sensor_abs_report(struct rmi_2d_sensor *sensor,\n\t\t\t\tstruct rmi_2d_sensor_abs_object *obj,\n\t\t\t\tint slot)\n{\n\tstruct rmi_2d_axis_alignment *axis_align = &sensor->axis_align;\n\tstruct input_dev *input = sensor->input;\n\tint wide, major, minor;\n\n\tif (sensor->kernel_tracking)\n\t\tinput_mt_slot(input, sensor->tracking_slots[slot]);\n\telse\n\t\tinput_mt_slot(input, slot);\n\n\tinput_mt_report_slot_state(input, obj->mt_tool,\n\t\t\t\t   obj->type != RMI_2D_OBJECT_NONE);\n\n\tif (obj->type != RMI_2D_OBJECT_NONE) {\n\t\tobj->x = sensor->tracking_pos[slot].x;\n\t\tobj->y = sensor->tracking_pos[slot].y;\n\n\t\tif (axis_align->swap_axes)\n\t\t\tswap(obj->wx, obj->wy);\n\n\t\twide = (obj->wx > obj->wy);\n\t\tmajor = max(obj->wx, obj->wy);\n\t\tminor = min(obj->wx, obj->wy);\n\n\t\tif (obj->type == RMI_2D_OBJECT_STYLUS) {\n\t\t\tmajor = max(1, major);\n\t\t\tminor = max(1, minor);\n\t\t}\n\n\t\tinput_event(sensor->input, EV_ABS, ABS_MT_POSITION_X, obj->x);\n\t\tinput_event(sensor->input, EV_ABS, ABS_MT_POSITION_Y, obj->y);\n\t\tinput_event(sensor->input, EV_ABS, ABS_MT_ORIENTATION, wide);\n\t\tinput_event(sensor->input, EV_ABS, ABS_MT_PRESSURE, obj->z);\n\t\tinput_event(sensor->input, EV_ABS, ABS_MT_TOUCH_MAJOR, major);\n\t\tinput_event(sensor->input, EV_ABS, ABS_MT_TOUCH_MINOR, minor);\n\n\t\trmi_dbg(RMI_DEBUG_2D_SENSOR, &sensor->input->dev,\n\t\t\t\"%s: obj[%d]: type: 0x%02x X: %d Y: %d Z: %d WX: %d WY: %d\\n\",\n\t\t\t__func__, slot, obj->type, obj->x, obj->y, obj->z,\n\t\t\tobj->wx, obj->wy);\n\t}\n}\nEXPORT_SYMBOL_GPL(rmi_2d_sensor_abs_report);\n\nvoid rmi_2d_sensor_rel_report(struct rmi_2d_sensor *sensor, int x, int y)\n{\n\tstruct rmi_2d_axis_alignment *axis_align = &sensor->axis_align;\n\n\tx = min(RMI_2D_REL_POS_MAX, max(RMI_2D_REL_POS_MIN, (int)x));\n\ty = min(RMI_2D_REL_POS_MAX, max(RMI_2D_REL_POS_MIN, (int)y));\n\n\tif (axis_align->flip_x)\n\t\tx = min(RMI_2D_REL_POS_MAX, -x);\n\n\tif (axis_align->flip_y)\n\t\ty = min(RMI_2D_REL_POS_MAX, -y);\n\n\tif (axis_align->swap_axes)\n\t\tswap(x, y);\n\n\tif (x || y) {\n\t\tinput_report_rel(sensor->input, REL_X, x);\n\t\tinput_report_rel(sensor->input, REL_Y, y);\n\t}\n}\nEXPORT_SYMBOL_GPL(rmi_2d_sensor_rel_report);\n\nstatic void rmi_2d_sensor_set_input_params(struct rmi_2d_sensor *sensor)\n{\n\tstruct input_dev *input = sensor->input;\n\tint res_x;\n\tint res_y;\n\tint max_x, max_y;\n\tint input_flags = 0;\n\n\tif (sensor->report_abs) {\n\t\tsensor->min_x = sensor->axis_align.clip_x_low;\n\t\tif (sensor->axis_align.clip_x_high)\n\t\t\tsensor->max_x = min(sensor->max_x,\n\t\t\t\tsensor->axis_align.clip_x_high);\n\n\t\tsensor->min_y = sensor->axis_align.clip_y_low;\n\t\tif (sensor->axis_align.clip_y_high)\n\t\t\tsensor->max_y = min(sensor->max_y,\n\t\t\t\tsensor->axis_align.clip_y_high);\n\n\t\tset_bit(EV_ABS, input->evbit);\n\n\t\tmax_x = sensor->max_x;\n\t\tmax_y = sensor->max_y;\n\t\tif (sensor->axis_align.swap_axes)\n\t\t\tswap(max_x, max_y);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, max_x, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\n\n\t\tif (sensor->x_mm && sensor->y_mm) {\n\t\t\tres_x = (sensor->max_x - sensor->min_x) / sensor->x_mm;\n\t\t\tres_y = (sensor->max_y - sensor->min_y) / sensor->y_mm;\n\t\t\tif (sensor->axis_align.swap_axes)\n\t\t\t\tswap(res_x, res_y);\n\n\t\t\tinput_abs_set_res(input, ABS_X, res_x);\n\t\t\tinput_abs_set_res(input, ABS_Y, res_y);\n\n\t\t\tinput_abs_set_res(input, ABS_MT_POSITION_X, res_x);\n\t\t\tinput_abs_set_res(input, ABS_MT_POSITION_Y, res_y);\n\n\t\t\tif (!sensor->dmax)\n\t\t\t\tsensor->dmax = DMAX * res_x;\n\t\t}\n\n\t\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xff, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 0x0f, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 0x0f, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_TOOL_TYPE,\n\t\t\t\t     0, MT_TOOL_MAX, 0, 0);\n\n\t\tif (sensor->sensor_type == rmi_sensor_touchpad)\n\t\t\tinput_flags = INPUT_MT_POINTER;\n\t\telse\n\t\t\tinput_flags = INPUT_MT_DIRECT;\n\n\t\tif (sensor->kernel_tracking)\n\t\t\tinput_flags |= INPUT_MT_TRACK;\n\n\t\tinput_mt_init_slots(input, sensor->nbr_fingers, input_flags);\n\t}\n\n\tif (sensor->report_rel) {\n\t\tset_bit(EV_REL, input->evbit);\n\t\tset_bit(REL_X, input->relbit);\n\t\tset_bit(REL_Y, input->relbit);\n\t}\n\n\tif (sensor->topbuttonpad)\n\t\tset_bit(INPUT_PROP_TOPBUTTONPAD, input->propbit);\n}\n\nint rmi_2d_sensor_configure_input(struct rmi_function *fn,\n\t\t\t\t\tstruct rmi_2d_sensor *sensor)\n{\n\tstruct rmi_device *rmi_dev = fn->rmi_dev;\n\tstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\n\n\tif (!drv_data->input)\n\t\treturn -ENODEV;\n\n\tsensor->input = drv_data->input;\n\trmi_2d_sensor_set_input_params(sensor);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rmi_2d_sensor_configure_input);\n\n#ifdef CONFIG_OF\nint rmi_2d_sensor_of_probe(struct device *dev,\n\t\t\tstruct rmi_2d_sensor_platform_data *pdata)\n{\n\tint retval;\n\tu32 val;\n\n\tpdata->axis_align.swap_axes = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\"touchscreen-swapped-x-y\");\n\n\tpdata->axis_align.flip_x = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\"touchscreen-inverted-x\");\n\n\tpdata->axis_align.flip_y = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\"touchscreen-inverted-y\");\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,clip-x-low\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.clip_x_low = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,clip-y-low\",\t1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.clip_y_low = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,clip-x-high\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.clip_x_high = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,clip-y-high\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.clip_y_high = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,offset-x\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.offset_x = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,offset-y\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.offset_y = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,delta-x-threshold\",\n\t\t\t\t\t\t1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.delta_x_threshold = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,delta-y-threshold\",\n\t\t\t\t\t\t1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->axis_align.delta_y_threshold = val;\n\n\tretval = rmi_of_property_read_u32(dev, (u32 *)&pdata->sensor_type,\n\t\t\t\"syna,sensor-type\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"touchscreen-x-mm\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->x_mm = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"touchscreen-y-mm\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->y_mm = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val,\n\t\t\t\t\"syna,disable-report-mask\", 1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->disable_report_mask = val;\n\n\tretval = rmi_of_property_read_u32(dev, &val, \"syna,rezero-wait-ms\",\n\t\t\t\t\t\t1);\n\tif (retval)\n\t\treturn retval;\n\n\tpdata->rezero_wait = val;\n\n\treturn 0;\n}\n#else\ninline int rmi_2d_sensor_of_probe(struct device *dev,\n\t\t\tstruct rmi_2d_sensor_platform_data *pdata)\n{\n\treturn -ENODEV;\n}\n#endif\nEXPORT_SYMBOL_GPL(rmi_2d_sensor_of_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}