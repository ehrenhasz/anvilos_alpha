{
  "module_name": "spmi-mtk-pmif.c",
  "hash_id": "074e35846c729b093cf1e7e8a667451ebe1a864f970002209201813da32d0143",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spmi/spmi-mtk-pmif.c",
  "human_readable_source": "\n\n\n\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/spmi.h>\n\n#define SWINF_IDLE\t0x00\n#define SWINF_WFVLDCLR\t0x06\n\n#define GET_SWINF(x)\t(((x) >> 1) & 0x7)\n\n#define PMIF_CMD_REG_0\t\t0\n#define PMIF_CMD_REG\t\t1\n#define PMIF_CMD_EXT_REG\t2\n#define PMIF_CMD_EXT_REG_LONG\t3\n\n#define PMIF_DELAY_US   10\n#define PMIF_TIMEOUT_US (10 * 1000)\n\n#define PMIF_CHAN_OFFSET 0x5\n\n#define PMIF_MAX_CLKS\t3\n\n#define SPMI_OP_ST_BUSY 1\n\nstruct ch_reg {\n\tu32 ch_sta;\n\tu32 wdata;\n\tu32 rdata;\n\tu32 ch_send;\n\tu32 ch_rdy;\n};\n\nstruct pmif_data {\n\tconst u32\t*regs;\n\tconst u32\t*spmimst_regs;\n\tu32\tsoc_chan;\n};\n\nstruct pmif {\n\tvoid __iomem\t*base;\n\tvoid __iomem\t*spmimst_base;\n\tstruct ch_reg\tchan;\n\tstruct clk_bulk_data clks[PMIF_MAX_CLKS];\n\tsize_t nclks;\n\tconst struct pmif_data *data;\n\traw_spinlock_t lock;\n};\n\nstatic const char * const pmif_clock_names[] = {\n\t\"pmif_sys_ck\", \"pmif_tmr_ck\", \"spmimst_clk_mux\",\n};\n\nenum pmif_regs {\n\tPMIF_INIT_DONE,\n\tPMIF_INF_EN,\n\tPMIF_ARB_EN,\n\tPMIF_CMDISSUE_EN,\n\tPMIF_TIMER_CTRL,\n\tPMIF_SPI_MODE_CTRL,\n\tPMIF_IRQ_EVENT_EN_0,\n\tPMIF_IRQ_FLAG_0,\n\tPMIF_IRQ_CLR_0,\n\tPMIF_IRQ_EVENT_EN_1,\n\tPMIF_IRQ_FLAG_1,\n\tPMIF_IRQ_CLR_1,\n\tPMIF_IRQ_EVENT_EN_2,\n\tPMIF_IRQ_FLAG_2,\n\tPMIF_IRQ_CLR_2,\n\tPMIF_IRQ_EVENT_EN_3,\n\tPMIF_IRQ_FLAG_3,\n\tPMIF_IRQ_CLR_3,\n\tPMIF_IRQ_EVENT_EN_4,\n\tPMIF_IRQ_FLAG_4,\n\tPMIF_IRQ_CLR_4,\n\tPMIF_WDT_EVENT_EN_0,\n\tPMIF_WDT_FLAG_0,\n\tPMIF_WDT_EVENT_EN_1,\n\tPMIF_WDT_FLAG_1,\n\tPMIF_SWINF_0_STA,\n\tPMIF_SWINF_0_WDATA_31_0,\n\tPMIF_SWINF_0_RDATA_31_0,\n\tPMIF_SWINF_0_ACC,\n\tPMIF_SWINF_0_VLD_CLR,\n\tPMIF_SWINF_1_STA,\n\tPMIF_SWINF_1_WDATA_31_0,\n\tPMIF_SWINF_1_RDATA_31_0,\n\tPMIF_SWINF_1_ACC,\n\tPMIF_SWINF_1_VLD_CLR,\n\tPMIF_SWINF_2_STA,\n\tPMIF_SWINF_2_WDATA_31_0,\n\tPMIF_SWINF_2_RDATA_31_0,\n\tPMIF_SWINF_2_ACC,\n\tPMIF_SWINF_2_VLD_CLR,\n\tPMIF_SWINF_3_STA,\n\tPMIF_SWINF_3_WDATA_31_0,\n\tPMIF_SWINF_3_RDATA_31_0,\n\tPMIF_SWINF_3_ACC,\n\tPMIF_SWINF_3_VLD_CLR,\n};\n\nstatic const u32 mt6873_regs[] = {\n\t[PMIF_INIT_DONE] = 0x0000,\n\t[PMIF_INF_EN] = 0x0024,\n\t[PMIF_ARB_EN] = 0x0150,\n\t[PMIF_CMDISSUE_EN] = 0x03B4,\n\t[PMIF_TIMER_CTRL] = 0x03E0,\n\t[PMIF_SPI_MODE_CTRL] = 0x0400,\n\t[PMIF_IRQ_EVENT_EN_0] = 0x0418,\n\t[PMIF_IRQ_FLAG_0] = 0x0420,\n\t[PMIF_IRQ_CLR_0] = 0x0424,\n\t[PMIF_IRQ_EVENT_EN_1] = 0x0428,\n\t[PMIF_IRQ_FLAG_1] = 0x0430,\n\t[PMIF_IRQ_CLR_1] = 0x0434,\n\t[PMIF_IRQ_EVENT_EN_2] = 0x0438,\n\t[PMIF_IRQ_FLAG_2] = 0x0440,\n\t[PMIF_IRQ_CLR_2] = 0x0444,\n\t[PMIF_IRQ_EVENT_EN_3] = 0x0448,\n\t[PMIF_IRQ_FLAG_3] = 0x0450,\n\t[PMIF_IRQ_CLR_3] = 0x0454,\n\t[PMIF_IRQ_EVENT_EN_4] = 0x0458,\n\t[PMIF_IRQ_FLAG_4] = 0x0460,\n\t[PMIF_IRQ_CLR_4] = 0x0464,\n\t[PMIF_WDT_EVENT_EN_0] = 0x046C,\n\t[PMIF_WDT_FLAG_0] = 0x0470,\n\t[PMIF_WDT_EVENT_EN_1] = 0x0474,\n\t[PMIF_WDT_FLAG_1] = 0x0478,\n\t[PMIF_SWINF_0_ACC] = 0x0C00,\n\t[PMIF_SWINF_0_WDATA_31_0] = 0x0C04,\n\t[PMIF_SWINF_0_RDATA_31_0] = 0x0C14,\n\t[PMIF_SWINF_0_VLD_CLR] = 0x0C24,\n\t[PMIF_SWINF_0_STA] = 0x0C28,\n\t[PMIF_SWINF_1_ACC] = 0x0C40,\n\t[PMIF_SWINF_1_WDATA_31_0] = 0x0C44,\n\t[PMIF_SWINF_1_RDATA_31_0] = 0x0C54,\n\t[PMIF_SWINF_1_VLD_CLR] = 0x0C64,\n\t[PMIF_SWINF_1_STA] = 0x0C68,\n\t[PMIF_SWINF_2_ACC] = 0x0C80,\n\t[PMIF_SWINF_2_WDATA_31_0] = 0x0C84,\n\t[PMIF_SWINF_2_RDATA_31_0] = 0x0C94,\n\t[PMIF_SWINF_2_VLD_CLR] = 0x0CA4,\n\t[PMIF_SWINF_2_STA] = 0x0CA8,\n\t[PMIF_SWINF_3_ACC] = 0x0CC0,\n\t[PMIF_SWINF_3_WDATA_31_0] = 0x0CC4,\n\t[PMIF_SWINF_3_RDATA_31_0] = 0x0CD4,\n\t[PMIF_SWINF_3_VLD_CLR] = 0x0CE4,\n\t[PMIF_SWINF_3_STA] = 0x0CE8,\n};\n\nstatic const u32 mt8195_regs[] = {\n\t[PMIF_INIT_DONE] = 0x0000,\n\t[PMIF_INF_EN] = 0x0024,\n\t[PMIF_ARB_EN] = 0x0150,\n\t[PMIF_CMDISSUE_EN] = 0x03B8,\n\t[PMIF_TIMER_CTRL] = 0x03E4,\n\t[PMIF_SPI_MODE_CTRL] = 0x0408,\n\t[PMIF_IRQ_EVENT_EN_0] = 0x0420,\n\t[PMIF_IRQ_FLAG_0] = 0x0428,\n\t[PMIF_IRQ_CLR_0] = 0x042C,\n\t[PMIF_IRQ_EVENT_EN_1] = 0x0430,\n\t[PMIF_IRQ_FLAG_1] = 0x0438,\n\t[PMIF_IRQ_CLR_1] = 0x043C,\n\t[PMIF_IRQ_EVENT_EN_2] = 0x0440,\n\t[PMIF_IRQ_FLAG_2] = 0x0448,\n\t[PMIF_IRQ_CLR_2] = 0x044C,\n\t[PMIF_IRQ_EVENT_EN_3] = 0x0450,\n\t[PMIF_IRQ_FLAG_3] = 0x0458,\n\t[PMIF_IRQ_CLR_3] = 0x045C,\n\t[PMIF_IRQ_EVENT_EN_4] = 0x0460,\n\t[PMIF_IRQ_FLAG_4] = 0x0468,\n\t[PMIF_IRQ_CLR_4] = 0x046C,\n\t[PMIF_WDT_EVENT_EN_0] = 0x0474,\n\t[PMIF_WDT_FLAG_0] = 0x0478,\n\t[PMIF_WDT_EVENT_EN_1] = 0x047C,\n\t[PMIF_WDT_FLAG_1] = 0x0480,\n\t[PMIF_SWINF_0_ACC] = 0x0800,\n\t[PMIF_SWINF_0_WDATA_31_0] = 0x0804,\n\t[PMIF_SWINF_0_RDATA_31_0] = 0x0814,\n\t[PMIF_SWINF_0_VLD_CLR] = 0x0824,\n\t[PMIF_SWINF_0_STA] = 0x0828,\n\t[PMIF_SWINF_1_ACC] = 0x0840,\n\t[PMIF_SWINF_1_WDATA_31_0] = 0x0844,\n\t[PMIF_SWINF_1_RDATA_31_0] = 0x0854,\n\t[PMIF_SWINF_1_VLD_CLR] = 0x0864,\n\t[PMIF_SWINF_1_STA] = 0x0868,\n\t[PMIF_SWINF_2_ACC] = 0x0880,\n\t[PMIF_SWINF_2_WDATA_31_0] = 0x0884,\n\t[PMIF_SWINF_2_RDATA_31_0] = 0x0894,\n\t[PMIF_SWINF_2_VLD_CLR] = 0x08A4,\n\t[PMIF_SWINF_2_STA] = 0x08A8,\n\t[PMIF_SWINF_3_ACC] = 0x08C0,\n\t[PMIF_SWINF_3_WDATA_31_0] = 0x08C4,\n\t[PMIF_SWINF_3_RDATA_31_0] = 0x08D4,\n\t[PMIF_SWINF_3_VLD_CLR] = 0x08E4,\n\t[PMIF_SWINF_3_STA] = 0x08E8,\n};\n\nenum spmi_regs {\n\tSPMI_OP_ST_CTRL,\n\tSPMI_GRP_ID_EN,\n\tSPMI_OP_ST_STA,\n\tSPMI_MST_SAMPL,\n\tSPMI_MST_REQ_EN,\n\tSPMI_REC_CTRL,\n\tSPMI_REC0,\n\tSPMI_REC1,\n\tSPMI_REC2,\n\tSPMI_REC3,\n\tSPMI_REC4,\n\tSPMI_MST_DBG,\n\n\t \n\tSPMI_MST_RCS_CTRL,\n\tSPMI_SLV_3_0_EINT,\n\tSPMI_SLV_7_4_EINT,\n\tSPMI_SLV_B_8_EINT,\n\tSPMI_SLV_F_C_EINT,\n\tSPMI_REC_CMD_DEC,\n\tSPMI_DEC_DBG,\n};\n\nstatic const u32 mt6873_spmi_regs[] = {\n\t[SPMI_OP_ST_CTRL] = 0x0000,\n\t[SPMI_GRP_ID_EN] = 0x0004,\n\t[SPMI_OP_ST_STA] = 0x0008,\n\t[SPMI_MST_SAMPL] = 0x000c,\n\t[SPMI_MST_REQ_EN] = 0x0010,\n\t[SPMI_REC_CTRL] = 0x0040,\n\t[SPMI_REC0] = 0x0044,\n\t[SPMI_REC1] = 0x0048,\n\t[SPMI_REC2] = 0x004c,\n\t[SPMI_REC3] = 0x0050,\n\t[SPMI_REC4] = 0x0054,\n\t[SPMI_MST_DBG] = 0x00fc,\n};\n\nstatic const u32 mt8195_spmi_regs[] = {\n\t[SPMI_OP_ST_CTRL] = 0x0000,\n\t[SPMI_GRP_ID_EN] = 0x0004,\n\t[SPMI_OP_ST_STA] = 0x0008,\n\t[SPMI_MST_SAMPL] = 0x000C,\n\t[SPMI_MST_REQ_EN] = 0x0010,\n\t[SPMI_MST_RCS_CTRL] = 0x0014,\n\t[SPMI_SLV_3_0_EINT] = 0x0020,\n\t[SPMI_SLV_7_4_EINT] = 0x0024,\n\t[SPMI_SLV_B_8_EINT] = 0x0028,\n\t[SPMI_SLV_F_C_EINT] = 0x002C,\n\t[SPMI_REC_CTRL] = 0x0040,\n\t[SPMI_REC0] = 0x0044,\n\t[SPMI_REC1] = 0x0048,\n\t[SPMI_REC2] = 0x004C,\n\t[SPMI_REC3] = 0x0050,\n\t[SPMI_REC4] = 0x0054,\n\t[SPMI_REC_CMD_DEC] = 0x005C,\n\t[SPMI_DEC_DBG] = 0x00F8,\n\t[SPMI_MST_DBG] = 0x00FC,\n};\n\nstatic u32 pmif_readl(struct pmif *arb, enum pmif_regs reg)\n{\n\treturn readl(arb->base + arb->data->regs[reg]);\n}\n\nstatic void pmif_writel(struct pmif *arb, u32 val, enum pmif_regs reg)\n{\n\twritel(val, arb->base + arb->data->regs[reg]);\n}\n\nstatic void mtk_spmi_writel(struct pmif *arb, u32 val, enum spmi_regs reg)\n{\n\twritel(val, arb->spmimst_base + arb->data->spmimst_regs[reg]);\n}\n\nstatic bool pmif_is_fsm_vldclr(struct pmif *arb)\n{\n\tu32 reg_rdata;\n\n\treg_rdata = pmif_readl(arb, arb->chan.ch_sta);\n\n\treturn GET_SWINF(reg_rdata) == SWINF_WFVLDCLR;\n}\n\nstatic int pmif_arb_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid)\n{\n\tstruct pmif *arb = spmi_controller_get_drvdata(ctrl);\n\tu32 rdata, cmd;\n\tint ret;\n\n\t \n\tif (opc < SPMI_CMD_RESET || opc > SPMI_CMD_WAKEUP)\n\t\treturn -EINVAL;\n\n\tcmd = opc - SPMI_CMD_RESET;\n\n\tmtk_spmi_writel(arb, (cmd << 0x4) | sid, SPMI_OP_ST_CTRL);\n\tret = readl_poll_timeout_atomic(arb->spmimst_base + arb->data->spmimst_regs[SPMI_OP_ST_STA],\n\t\t\t\t\trdata, (rdata & SPMI_OP_ST_BUSY) == SPMI_OP_ST_BUSY,\n\t\t\t\t\tPMIF_DELAY_US, PMIF_TIMEOUT_US);\n\tif (ret < 0)\n\t\tdev_err(&ctrl->dev, \"timeout, err = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int pmif_spmi_read_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,\n\t\t\t      u16 addr, u8 *buf, size_t len)\n{\n\tstruct pmif *arb = spmi_controller_get_drvdata(ctrl);\n\tstruct ch_reg *inf_reg;\n\tint ret;\n\tu32 data, cmd;\n\tunsigned long flags;\n\n\t \n\tif (sid & ~0xf) {\n\t\tdev_err(&ctrl->dev, \"exceed the max slv id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (len > 4) {\n\t\tdev_err(&ctrl->dev, \"pmif supports 1..4 bytes per trans, but:%zu requested\", len);\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (opc >= 0x60 && opc <= 0x7f)\n\t\topc = PMIF_CMD_REG;\n\telse if ((opc >= 0x20 && opc <= 0x2f) || (opc >= 0x38 && opc <= 0x3f))\n\t\topc = PMIF_CMD_EXT_REG_LONG;\n\telse\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&arb->lock, flags);\n\t \n\tinf_reg = &arb->chan;\n\tret = readl_poll_timeout_atomic(arb->base + arb->data->regs[inf_reg->ch_sta],\n\t\t\t\t\tdata, GET_SWINF(data) == SWINF_IDLE,\n\t\t\t\t\tPMIF_DELAY_US, PMIF_TIMEOUT_US);\n\tif (ret < 0) {\n\t\t \n\t\tif (pmif_is_fsm_vldclr(arb))\n\t\t\tpmif_writel(arb, 1, inf_reg->ch_rdy);\n\t\traw_spin_unlock_irqrestore(&arb->lock, flags);\n\t\tdev_err(&ctrl->dev, \"failed to wait for SWINF_IDLE\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcmd = (opc << 30) | (sid << 24) | ((len - 1) << 16) | addr;\n\tpmif_writel(arb, cmd, inf_reg->ch_send);\n\traw_spin_unlock_irqrestore(&arb->lock, flags);\n\n\t \n\tret = readl_poll_timeout_atomic(arb->base + arb->data->regs[inf_reg->ch_sta],\n\t\t\t\t\tdata, GET_SWINF(data) == SWINF_WFVLDCLR,\n\t\t\t\t\tPMIF_DELAY_US, PMIF_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(&ctrl->dev, \"failed to wait for SWINF_WFVLDCLR\\n\");\n\t\treturn ret;\n\t}\n\n\tdata = pmif_readl(arb, inf_reg->rdata);\n\tmemcpy(buf, &data, len);\n\tpmif_writel(arb, 1, inf_reg->ch_rdy);\n\n\treturn 0;\n}\n\nstatic int pmif_spmi_write_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,\n\t\t\t       u16 addr, const u8 *buf, size_t len)\n{\n\tstruct pmif *arb = spmi_controller_get_drvdata(ctrl);\n\tstruct ch_reg *inf_reg;\n\tint ret;\n\tu32 data, wdata, cmd;\n\tunsigned long flags;\n\n\tif (len > 4) {\n\t\tdev_err(&ctrl->dev, \"pmif supports 1..4 bytes per trans, but:%zu requested\", len);\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (opc >= 0x40 && opc <= 0x5F)\n\t\topc = PMIF_CMD_REG;\n\telse if ((opc <= 0xF) || (opc >= 0x30 && opc <= 0x37))\n\t\topc = PMIF_CMD_EXT_REG_LONG;\n\telse if (opc >= 0x80)\n\t\topc = PMIF_CMD_REG_0;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(&wdata, buf, len);\n\n\traw_spin_lock_irqsave(&arb->lock, flags);\n\t \n\tinf_reg = &arb->chan;\n\tret = readl_poll_timeout_atomic(arb->base + arb->data->regs[inf_reg->ch_sta],\n\t\t\t\t\tdata, GET_SWINF(data) == SWINF_IDLE,\n\t\t\t\t\tPMIF_DELAY_US, PMIF_TIMEOUT_US);\n\tif (ret < 0) {\n\t\t \n\t\tif (pmif_is_fsm_vldclr(arb))\n\t\t\tpmif_writel(arb, 1, inf_reg->ch_rdy);\n\t\traw_spin_unlock_irqrestore(&arb->lock, flags);\n\t\tdev_err(&ctrl->dev, \"failed to wait for SWINF_IDLE\\n\");\n\t\treturn ret;\n\t}\n\n\tpmif_writel(arb, wdata, inf_reg->wdata);\n\n\t \n\tcmd = (opc << 30) | BIT(29) | (sid << 24) | ((len - 1) << 16) | addr;\n\tpmif_writel(arb, cmd, inf_reg->ch_send);\n\traw_spin_unlock_irqrestore(&arb->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pmif_data mt6873_pmif_arb = {\n\t.regs = mt6873_regs,\n\t.spmimst_regs = mt6873_spmi_regs,\n\t.soc_chan = 2,\n};\n\nstatic const struct pmif_data mt8195_pmif_arb = {\n\t.regs = mt8195_regs,\n\t.spmimst_regs = mt8195_spmi_regs,\n\t.soc_chan = 2,\n};\n\nstatic int mtk_spmi_probe(struct platform_device *pdev)\n{\n\tstruct pmif *arb;\n\tstruct spmi_controller *ctrl;\n\tint err, i;\n\tu32 chan_offset;\n\n\tctrl = spmi_controller_alloc(&pdev->dev, sizeof(*arb));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tarb = spmi_controller_get_drvdata(ctrl);\n\tarb->data = device_get_match_data(&pdev->dev);\n\tif (!arb->data) {\n\t\terr = -EINVAL;\n\t\tdev_err(&pdev->dev, \"Cannot get drv_data\\n\");\n\t\tgoto err_put_ctrl;\n\t}\n\n\tarb->base = devm_platform_ioremap_resource_byname(pdev, \"pmif\");\n\tif (IS_ERR(arb->base)) {\n\t\terr = PTR_ERR(arb->base);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tarb->spmimst_base = devm_platform_ioremap_resource_byname(pdev, \"spmimst\");\n\tif (IS_ERR(arb->spmimst_base)) {\n\t\terr = PTR_ERR(arb->spmimst_base);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tarb->nclks = ARRAY_SIZE(pmif_clock_names);\n\tfor (i = 0; i < arb->nclks; i++)\n\t\tarb->clks[i].id = pmif_clock_names[i];\n\n\terr = devm_clk_bulk_get(&pdev->dev, arb->nclks, arb->clks);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get clocks: %d\\n\", err);\n\t\tgoto err_put_ctrl;\n\t}\n\n\terr = clk_bulk_prepare_enable(arb->nclks, arb->clks);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable clocks: %d\\n\", err);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tctrl->cmd = pmif_arb_cmd;\n\tctrl->read_cmd = pmif_spmi_read_cmd;\n\tctrl->write_cmd = pmif_spmi_write_cmd;\n\n\tchan_offset = PMIF_CHAN_OFFSET * arb->data->soc_chan;\n\tarb->chan.ch_sta = PMIF_SWINF_0_STA + chan_offset;\n\tarb->chan.wdata = PMIF_SWINF_0_WDATA_31_0 + chan_offset;\n\tarb->chan.rdata = PMIF_SWINF_0_RDATA_31_0 + chan_offset;\n\tarb->chan.ch_send = PMIF_SWINF_0_ACC + chan_offset;\n\tarb->chan.ch_rdy = PMIF_SWINF_0_VLD_CLR + chan_offset;\n\n\traw_spin_lock_init(&arb->lock);\n\n\tplatform_set_drvdata(pdev, ctrl);\n\n\terr = spmi_controller_add(ctrl);\n\tif (err)\n\t\tgoto err_domain_remove;\n\n\treturn 0;\n\nerr_domain_remove:\n\tclk_bulk_disable_unprepare(arb->nclks, arb->clks);\nerr_put_ctrl:\n\tspmi_controller_put(ctrl);\n\treturn err;\n}\n\nstatic void mtk_spmi_remove(struct platform_device *pdev)\n{\n\tstruct spmi_controller *ctrl = platform_get_drvdata(pdev);\n\tstruct pmif *arb = spmi_controller_get_drvdata(ctrl);\n\n\tclk_bulk_disable_unprepare(arb->nclks, arb->clks);\n\tspmi_controller_remove(ctrl);\n\tspmi_controller_put(ctrl);\n}\n\nstatic const struct of_device_id mtk_spmi_match_table[] = {\n\t{\n\t\t.compatible = \"mediatek,mt6873-spmi\",\n\t\t.data = &mt6873_pmif_arb,\n\t}, {\n\t\t.compatible = \"mediatek,mt8195-spmi\",\n\t\t.data = &mt8195_pmif_arb,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, mtk_spmi_match_table);\n\nstatic struct platform_driver mtk_spmi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"spmi-mtk\",\n\t\t.of_match_table = mtk_spmi_match_table,\n\t},\n\t.probe\t\t= mtk_spmi_probe,\n\t.remove_new\t= mtk_spmi_remove,\n};\nmodule_platform_driver(mtk_spmi_driver);\n\nMODULE_AUTHOR(\"Hsin-Hsiung Wang <hsin-hsiung.wang@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek SPMI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}