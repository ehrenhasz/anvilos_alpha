{
  "module_name": "hisi-spmi-controller.c",
  "hash_id": "2e3fe7132565c2ae0b961be48acfebc638dfab03c191851dde09ede657082ca8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spmi/hisi-spmi-controller.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spmi.h>\n\n \n#define SPMI_CHANNEL_OFFSET\t\t\t\t0x0300\n#define SPMI_SLAVE_OFFSET\t\t\t\t0x20\n\n#define SPMI_APB_SPMI_CMD_BASE_ADDR\t\t\t0x0100\n\n#define SPMI_APB_SPMI_WDATA0_BASE_ADDR\t\t\t0x0104\n#define SPMI_APB_SPMI_WDATA1_BASE_ADDR\t\t\t0x0108\n#define SPMI_APB_SPMI_WDATA2_BASE_ADDR\t\t\t0x010c\n#define SPMI_APB_SPMI_WDATA3_BASE_ADDR\t\t\t0x0110\n\n#define SPMI_APB_SPMI_STATUS_BASE_ADDR\t\t\t0x0200\n\n#define SPMI_APB_SPMI_RDATA0_BASE_ADDR\t\t\t0x0204\n#define SPMI_APB_SPMI_RDATA1_BASE_ADDR\t\t\t0x0208\n#define SPMI_APB_SPMI_RDATA2_BASE_ADDR\t\t\t0x020c\n#define SPMI_APB_SPMI_RDATA3_BASE_ADDR\t\t\t0x0210\n\n#define SPMI_PER_DATAREG_BYTE\t\t\t\t4\n \n#define SPMI_APB_SPMI_CMD_EN\t\t\t\tBIT(31)\n#define SPMI_APB_SPMI_CMD_TYPE_OFFSET\t\t\t24\n#define SPMI_APB_SPMI_CMD_LENGTH_OFFSET\t\t\t20\n#define SPMI_APB_SPMI_CMD_SLAVEID_OFFSET\t\t16\n#define SPMI_APB_SPMI_CMD_ADDR_OFFSET\t\t\t0\n\n \n\nenum spmi_controller_cmd_op_code {\n\tSPMI_CMD_REG_ZERO_WRITE = 0,\n\tSPMI_CMD_REG_WRITE = 1,\n\tSPMI_CMD_REG_READ = 2,\n\tSPMI_CMD_EXT_REG_WRITE = 3,\n\tSPMI_CMD_EXT_REG_READ = 4,\n\tSPMI_CMD_EXT_REG_WRITE_L = 5,\n\tSPMI_CMD_EXT_REG_READ_L = 6,\n\tSPMI_CMD_REG_RESET = 7,\n\tSPMI_CMD_REG_SLEEP = 8,\n\tSPMI_CMD_REG_SHUTDOWN = 9,\n\tSPMI_CMD_REG_WAKEUP = 10,\n};\n\n \n#define SPMI_APB_TRANS_DONE\t\t\tBIT(0)\n#define SPMI_APB_TRANS_FAIL\t\t\tBIT(2)\n\n \n#define SPMI_CONTROLLER_CMD_MAX_BYTE_COUNT\t16\n\n \n#define SPMI_CONTROLLER_TIMEOUT_US\t\t1000\n#define SPMI_CONTROLLER_MAX_TRANS_BYTES\t\t16\n\nstruct spmi_controller_dev {\n\tstruct spmi_controller\t*controller;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tspinlock_t\t\tlock;\n\tu32\t\t\tchannel;\n};\n\nstatic int spmi_controller_wait_for_done(struct device *dev,\n\t\t\t\t\t struct spmi_controller_dev *ctrl_dev,\n\t\t\t\t\t void __iomem *base, u8 sid, u16 addr)\n{\n\tu32 timeout = SPMI_CONTROLLER_TIMEOUT_US;\n\tu32 status, offset;\n\n\toffset  = SPMI_APB_SPMI_STATUS_BASE_ADDR;\n\toffset += SPMI_CHANNEL_OFFSET * ctrl_dev->channel + SPMI_SLAVE_OFFSET * sid;\n\n\tdo {\n\t\tstatus = readl(base + offset);\n\n\t\tif (status & SPMI_APB_TRANS_DONE) {\n\t\t\tif (status & SPMI_APB_TRANS_FAIL) {\n\t\t\t\tdev_err(dev, \"%s: transaction failed (0x%x)\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tdev_dbg(dev, \"%s: status 0x%x\\n\", __func__, status);\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t} while (timeout--);\n\n\tdev_err(dev, \"%s: timeout, status 0x%x\\n\", __func__, status);\n\treturn -ETIMEDOUT;\n}\n\nstatic int spmi_read_cmd(struct spmi_controller *ctrl,\n\t\t\t u8 opc, u8 slave_id, u16 slave_addr, u8 *__buf, size_t bc)\n{\n\tstruct spmi_controller_dev *spmi_controller = dev_get_drvdata(&ctrl->dev);\n\tu32 chnl_ofst = SPMI_CHANNEL_OFFSET * spmi_controller->channel;\n\tunsigned long flags;\n\tu8 *buf = __buf;\n\tu32 cmd, data;\n\tint rc;\n\tu8 op_code, i;\n\n\tif (bc > SPMI_CONTROLLER_MAX_TRANS_BYTES) {\n\t\tdev_err(&ctrl->dev,\n\t\t\t\"spmi_controller supports 1..%d bytes per trans, but:%zu requested\\n\",\n\t\t\tSPMI_CONTROLLER_MAX_TRANS_BYTES, bc);\n\t\treturn  -EINVAL;\n\t}\n\n\tswitch (opc) {\n\tcase SPMI_CMD_READ:\n\t\top_code = SPMI_CMD_REG_READ;\n\t\tbreak;\n\tcase SPMI_CMD_EXT_READ:\n\t\top_code = SPMI_CMD_EXT_REG_READ;\n\t\tbreak;\n\tcase SPMI_CMD_EXT_READL:\n\t\top_code = SPMI_CMD_EXT_REG_READ_L;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ctrl->dev, \"invalid read cmd 0x%x\\n\", opc);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = SPMI_APB_SPMI_CMD_EN |\n\t     (op_code << SPMI_APB_SPMI_CMD_TYPE_OFFSET) |\n\t     ((bc - 1) << SPMI_APB_SPMI_CMD_LENGTH_OFFSET) |\n\t     ((slave_id & 0xf) << SPMI_APB_SPMI_CMD_SLAVEID_OFFSET) |   \n\t     ((slave_addr & 0xffff)  << SPMI_APB_SPMI_CMD_ADDR_OFFSET);  \n\n\tspin_lock_irqsave(&spmi_controller->lock, flags);\n\n\twritel(cmd, spmi_controller->base + chnl_ofst + SPMI_APB_SPMI_CMD_BASE_ADDR);\n\n\trc = spmi_controller_wait_for_done(&ctrl->dev, spmi_controller,\n\t\t\t\t\t   spmi_controller->base, slave_id, slave_addr);\n\tif (rc)\n\t\tgoto done;\n\n\tfor (i = 0; bc > i * SPMI_PER_DATAREG_BYTE; i++) {\n\t\tdata = readl(spmi_controller->base + chnl_ofst +\n\t\t\t     SPMI_SLAVE_OFFSET * slave_id +\n\t\t\t     SPMI_APB_SPMI_RDATA0_BASE_ADDR +\n\t\t\t     i * SPMI_PER_DATAREG_BYTE);\n\t\tdata = be32_to_cpu((__be32 __force)data);\n\t\tif ((bc - i * SPMI_PER_DATAREG_BYTE) >> 2) {\n\t\t\tmemcpy(buf, &data, sizeof(data));\n\t\t\tbuf += sizeof(data);\n\t\t} else {\n\t\t\tmemcpy(buf, &data, bc % SPMI_PER_DATAREG_BYTE);\n\t\t\tbuf += (bc % SPMI_PER_DATAREG_BYTE);\n\t\t}\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&spmi_controller->lock, flags);\n\tif (rc)\n\t\tdev_err(&ctrl->dev,\n\t\t\t\"spmi read wait timeout op:0x%x slave_id:%d slave_addr:0x%x bc:%zu\\n\",\n\t\t\topc, slave_id, slave_addr, bc + 1);\n\telse\n\t\tdev_dbg(&ctrl->dev, \"%s: id:%d slave_addr:0x%x, read value: %*ph\\n\",\n\t\t\t__func__, slave_id, slave_addr, (int)bc, __buf);\n\n\treturn rc;\n}\n\nstatic int spmi_write_cmd(struct spmi_controller *ctrl,\n\t\t\t  u8 opc, u8 slave_id, u16 slave_addr, const u8 *__buf, size_t bc)\n{\n\tstruct spmi_controller_dev *spmi_controller = dev_get_drvdata(&ctrl->dev);\n\tu32 chnl_ofst = SPMI_CHANNEL_OFFSET * spmi_controller->channel;\n\tconst u8 *buf = __buf;\n\tunsigned long flags;\n\tu32 cmd, data;\n\tint rc;\n\tu8 op_code, i;\n\n\tif (bc > SPMI_CONTROLLER_MAX_TRANS_BYTES) {\n\t\tdev_err(&ctrl->dev,\n\t\t\t\"spmi_controller supports 1..%d bytes per trans, but:%zu requested\\n\",\n\t\t\tSPMI_CONTROLLER_MAX_TRANS_BYTES, bc);\n\t\treturn  -EINVAL;\n\t}\n\n\tswitch (opc) {\n\tcase SPMI_CMD_WRITE:\n\t\top_code = SPMI_CMD_REG_WRITE;\n\t\tbreak;\n\tcase SPMI_CMD_EXT_WRITE:\n\t\top_code = SPMI_CMD_EXT_REG_WRITE;\n\t\tbreak;\n\tcase SPMI_CMD_EXT_WRITEL:\n\t\top_code = SPMI_CMD_EXT_REG_WRITE_L;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ctrl->dev, \"invalid write cmd 0x%x\\n\", opc);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = SPMI_APB_SPMI_CMD_EN |\n\t      (op_code << SPMI_APB_SPMI_CMD_TYPE_OFFSET) |\n\t      ((bc - 1) << SPMI_APB_SPMI_CMD_LENGTH_OFFSET) |\n\t      ((slave_id & 0xf) << SPMI_APB_SPMI_CMD_SLAVEID_OFFSET) |\n\t      ((slave_addr & 0xffff)  << SPMI_APB_SPMI_CMD_ADDR_OFFSET);\n\n\t \n\tspin_lock_irqsave(&spmi_controller->lock, flags);\n\n\tfor (i = 0; bc > i * SPMI_PER_DATAREG_BYTE; i++) {\n\t\tdata = 0;\n\t\tif ((bc - i * SPMI_PER_DATAREG_BYTE) >> 2) {\n\t\t\tmemcpy(&data, buf, sizeof(data));\n\t\t\tbuf += sizeof(data);\n\t\t} else {\n\t\t\tmemcpy(&data, buf, bc % SPMI_PER_DATAREG_BYTE);\n\t\t\tbuf += (bc % SPMI_PER_DATAREG_BYTE);\n\t\t}\n\n\t\twritel((u32 __force)cpu_to_be32(data),\n\t\t       spmi_controller->base + chnl_ofst +\n\t\t       SPMI_APB_SPMI_WDATA0_BASE_ADDR +\n\t\t       SPMI_PER_DATAREG_BYTE * i);\n\t}\n\n\t \n\twritel(cmd, spmi_controller->base + chnl_ofst + SPMI_APB_SPMI_CMD_BASE_ADDR);\n\n\trc = spmi_controller_wait_for_done(&ctrl->dev, spmi_controller,\n\t\t\t\t\t   spmi_controller->base, slave_id,\n\t\t\t\t\t   slave_addr);\n\tspin_unlock_irqrestore(&spmi_controller->lock, flags);\n\n\tif (rc)\n\t\tdev_err(&ctrl->dev, \"spmi write wait timeout op:0x%x slave_id:%d slave_addr:0x%x bc:%zu\\n\",\n\t\t\topc, slave_id, slave_addr, bc);\n\telse\n\t\tdev_dbg(&ctrl->dev, \"%s: id:%d slave_addr:0x%x, wrote value: %*ph\\n\",\n\t\t\t__func__, slave_id, slave_addr, (int)bc, __buf);\n\n\treturn rc;\n}\n\nstatic int spmi_controller_probe(struct platform_device *pdev)\n{\n\tstruct spmi_controller_dev *spmi_controller;\n\tstruct spmi_controller *ctrl;\n\tstruct resource *iores;\n\tint ret;\n\n\tctrl = spmi_controller_alloc(&pdev->dev, sizeof(*spmi_controller));\n\tif (!ctrl) {\n\t\tdev_err(&pdev->dev, \"can not allocate spmi_controller data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspmi_controller = spmi_controller_get_drvdata(ctrl);\n\tspmi_controller->controller = ctrl;\n\n\tiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iores) {\n\t\tdev_err(&pdev->dev, \"can not get resource!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_put_controller;\n\t}\n\n\tspmi_controller->base = devm_ioremap(&pdev->dev, iores->start,\n\t\t\t\t\t     resource_size(iores));\n\tif (!spmi_controller->base) {\n\t\tdev_err(&pdev->dev, \"can not remap base addr!\\n\");\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto err_put_controller;\n\t}\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"hisilicon,spmi-channel\",\n\t\t\t\t   &spmi_controller->channel);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can not get channel\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_put_controller;\n\t}\n\n\tplatform_set_drvdata(pdev, spmi_controller);\n\tdev_set_drvdata(&ctrl->dev, spmi_controller);\n\n\tspin_lock_init(&spmi_controller->lock);\n\n\tctrl->nr = spmi_controller->channel;\n\tctrl->dev.parent = pdev->dev.parent;\n\tctrl->dev.of_node = of_node_get(pdev->dev.of_node);\n\n\t \n\tctrl->read_cmd = spmi_read_cmd;\n\tctrl->write_cmd = spmi_write_cmd;\n\n\tret = spmi_controller_add(ctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"spmi_controller_add failed with error %d!\\n\", ret);\n\t\tgoto err_put_controller;\n\t}\n\n\treturn 0;\n\nerr_put_controller:\n\tspmi_controller_put(ctrl);\n\treturn ret;\n}\n\nstatic void spmi_del_controller(struct platform_device *pdev)\n{\n\tstruct spmi_controller *ctrl = platform_get_drvdata(pdev);\n\n\tspmi_controller_remove(ctrl);\n\tspmi_controller_put(ctrl);\n}\n\nstatic const struct of_device_id spmi_controller_match_table[] = {\n\t{\n\t\t.compatible = \"hisilicon,kirin970-spmi-controller\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spmi_controller_match_table);\n\nstatic struct platform_driver spmi_controller_driver = {\n\t.probe\t\t= spmi_controller_probe,\n\t.remove_new\t= spmi_del_controller,\n\t.driver\t\t= {\n\t\t.name\t= \"hisi_spmi_controller\",\n\t\t.of_match_table = spmi_controller_match_table,\n\t},\n};\n\nstatic int __init spmi_controller_init(void)\n{\n\treturn platform_driver_register(&spmi_controller_driver);\n}\npostcore_initcall(spmi_controller_init);\n\nstatic void __exit spmi_controller_exit(void)\n{\n\tplatform_driver_unregister(&spmi_controller_driver);\n}\nmodule_exit(spmi_controller_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"1.0\");\nMODULE_ALIAS(\"platform:spmi_controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}