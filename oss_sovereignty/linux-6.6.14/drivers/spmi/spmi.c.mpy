{
  "module_name": "spmi.c",
  "hash_id": "f4baf3c5de3ffff9257a32d22241c633e26536ae6aed8fe4609fa9a879382ba8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spmi/spmi.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/spmi.h>\n#include <linux/pm_runtime.h>\n\n#include <dt-bindings/spmi/spmi.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/spmi.h>\n\nstatic bool is_registered;\nstatic DEFINE_IDA(ctrl_ida);\n\nstatic void spmi_dev_release(struct device *dev)\n{\n\tstruct spmi_device *sdev = to_spmi_device(dev);\n\n\tkfree(sdev);\n}\n\nstatic const struct device_type spmi_dev_type = {\n\t.release\t= spmi_dev_release,\n};\n\nstatic void spmi_ctrl_release(struct device *dev)\n{\n\tstruct spmi_controller *ctrl = to_spmi_controller(dev);\n\n\tida_free(&ctrl_ida, ctrl->nr);\n\tkfree(ctrl);\n}\n\nstatic const struct device_type spmi_ctrl_type = {\n\t.release\t= spmi_ctrl_release,\n};\n\nstatic int spmi_device_match(struct device *dev, struct device_driver *drv)\n{\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (drv->name)\n\t\treturn strncmp(dev_name(dev), drv->name,\n\t\t\t       SPMI_NAME_SIZE) == 0;\n\n\treturn 0;\n}\n\n \nint spmi_device_add(struct spmi_device *sdev)\n{\n\tstruct spmi_controller *ctrl = sdev->ctrl;\n\tint err;\n\n\tdev_set_name(&sdev->dev, \"%d-%02x\", ctrl->nr, sdev->usid);\n\n\terr = device_add(&sdev->dev);\n\tif (err < 0) {\n\t\tdev_err(&sdev->dev, \"Can't add %s, status %d\\n\",\n\t\t\tdev_name(&sdev->dev), err);\n\t\tgoto err_device_add;\n\t}\n\n\tdev_dbg(&sdev->dev, \"device %s registered\\n\", dev_name(&sdev->dev));\n\nerr_device_add:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(spmi_device_add);\n\n \nvoid spmi_device_remove(struct spmi_device *sdev)\n{\n\tdevice_unregister(&sdev->dev);\n}\nEXPORT_SYMBOL_GPL(spmi_device_remove);\n\nstatic inline int\nspmi_cmd(struct spmi_controller *ctrl, u8 opcode, u8 sid)\n{\n\tint ret;\n\n\tif (!ctrl || !ctrl->cmd || ctrl->dev.type != &spmi_ctrl_type)\n\t\treturn -EINVAL;\n\n\tret = ctrl->cmd(ctrl, opcode, sid);\n\ttrace_spmi_cmd(opcode, sid, ret);\n\treturn ret;\n}\n\nstatic inline int spmi_read_cmd(struct spmi_controller *ctrl, u8 opcode,\n\t\t\t\tu8 sid, u16 addr, u8 *buf, size_t len)\n{\n\tint ret;\n\n\tif (!ctrl || !ctrl->read_cmd || ctrl->dev.type != &spmi_ctrl_type)\n\t\treturn -EINVAL;\n\n\ttrace_spmi_read_begin(opcode, sid, addr);\n\tret = ctrl->read_cmd(ctrl, opcode, sid, addr, buf, len);\n\ttrace_spmi_read_end(opcode, sid, addr, ret, len, buf);\n\treturn ret;\n}\n\nstatic inline int spmi_write_cmd(struct spmi_controller *ctrl, u8 opcode,\n\t\t\t\t u8 sid, u16 addr, const u8 *buf, size_t len)\n{\n\tint ret;\n\n\tif (!ctrl || !ctrl->write_cmd || ctrl->dev.type != &spmi_ctrl_type)\n\t\treturn -EINVAL;\n\n\ttrace_spmi_write_begin(opcode, sid, addr, len, buf);\n\tret = ctrl->write_cmd(ctrl, opcode, sid, addr, buf, len);\n\ttrace_spmi_write_end(opcode, sid, addr, ret);\n\treturn ret;\n}\n\n \nint spmi_register_read(struct spmi_device *sdev, u8 addr, u8 *buf)\n{\n\t \n\tif (addr > 0x1F)\n\t\treturn -EINVAL;\n\n\treturn spmi_read_cmd(sdev->ctrl, SPMI_CMD_READ, sdev->usid, addr,\n\t\t\t     buf, 1);\n}\nEXPORT_SYMBOL_GPL(spmi_register_read);\n\n \nint spmi_ext_register_read(struct spmi_device *sdev, u8 addr, u8 *buf,\n\t\t\t   size_t len)\n{\n\t \n\tif (len == 0 || len > 16)\n\t\treturn -EINVAL;\n\n\treturn spmi_read_cmd(sdev->ctrl, SPMI_CMD_EXT_READ, sdev->usid, addr,\n\t\t\t     buf, len);\n}\nEXPORT_SYMBOL_GPL(spmi_ext_register_read);\n\n \nint spmi_ext_register_readl(struct spmi_device *sdev, u16 addr, u8 *buf,\n\t\t\t    size_t len)\n{\n\t \n\tif (len == 0 || len > 8)\n\t\treturn -EINVAL;\n\n\treturn spmi_read_cmd(sdev->ctrl, SPMI_CMD_EXT_READL, sdev->usid, addr,\n\t\t\t     buf, len);\n}\nEXPORT_SYMBOL_GPL(spmi_ext_register_readl);\n\n \nint spmi_register_write(struct spmi_device *sdev, u8 addr, u8 data)\n{\n\t \n\tif (addr > 0x1F)\n\t\treturn -EINVAL;\n\n\treturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_WRITE, sdev->usid, addr,\n\t\t\t      &data, 1);\n}\nEXPORT_SYMBOL_GPL(spmi_register_write);\n\n \nint spmi_register_zero_write(struct spmi_device *sdev, u8 data)\n{\n\treturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_ZERO_WRITE, sdev->usid, 0,\n\t\t\t      &data, 1);\n}\nEXPORT_SYMBOL_GPL(spmi_register_zero_write);\n\n \nint spmi_ext_register_write(struct spmi_device *sdev, u8 addr, const u8 *buf,\n\t\t\t    size_t len)\n{\n\t \n\tif (len == 0 || len > 16)\n\t\treturn -EINVAL;\n\n\treturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_EXT_WRITE, sdev->usid, addr,\n\t\t\t      buf, len);\n}\nEXPORT_SYMBOL_GPL(spmi_ext_register_write);\n\n \nint spmi_ext_register_writel(struct spmi_device *sdev, u16 addr, const u8 *buf,\n\t\t\t     size_t len)\n{\n\t \n\tif (len == 0 || len > 8)\n\t\treturn -EINVAL;\n\n\treturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_EXT_WRITEL, sdev->usid,\n\t\t\t      addr, buf, len);\n}\nEXPORT_SYMBOL_GPL(spmi_ext_register_writel);\n\n \nint spmi_command_reset(struct spmi_device *sdev)\n{\n\treturn spmi_cmd(sdev->ctrl, SPMI_CMD_RESET, sdev->usid);\n}\nEXPORT_SYMBOL_GPL(spmi_command_reset);\n\n \nint spmi_command_sleep(struct spmi_device *sdev)\n{\n\treturn spmi_cmd(sdev->ctrl, SPMI_CMD_SLEEP, sdev->usid);\n}\nEXPORT_SYMBOL_GPL(spmi_command_sleep);\n\n \nint spmi_command_wakeup(struct spmi_device *sdev)\n{\n\treturn spmi_cmd(sdev->ctrl, SPMI_CMD_WAKEUP, sdev->usid);\n}\nEXPORT_SYMBOL_GPL(spmi_command_wakeup);\n\n \nint spmi_command_shutdown(struct spmi_device *sdev)\n{\n\treturn spmi_cmd(sdev->ctrl, SPMI_CMD_SHUTDOWN, sdev->usid);\n}\nEXPORT_SYMBOL_GPL(spmi_command_shutdown);\n\nstatic int spmi_drv_probe(struct device *dev)\n{\n\tconst struct spmi_driver *sdrv = to_spmi_driver(dev->driver);\n\tstruct spmi_device *sdev = to_spmi_device(dev);\n\tint err;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\terr = sdrv->probe(sdev);\n\tif (err)\n\t\tgoto fail_probe;\n\n\treturn 0;\n\nfail_probe:\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\treturn err;\n}\n\nstatic void spmi_drv_remove(struct device *dev)\n{\n\tconst struct spmi_driver *sdrv = to_spmi_driver(dev->driver);\n\n\tpm_runtime_get_sync(dev);\n\tif (sdrv->remove)\n\t\tsdrv->remove(to_spmi_device(dev));\n\tpm_runtime_put_noidle(dev);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n}\n\nstatic void spmi_drv_shutdown(struct device *dev)\n{\n\tconst struct spmi_driver *sdrv = to_spmi_driver(dev->driver);\n\n\tif (sdrv && sdrv->shutdown)\n\t\tsdrv->shutdown(to_spmi_device(dev));\n}\n\nstatic int spmi_drv_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint ret;\n\n\tret = of_device_uevent_modalias(dev, env);\n\tif (ret != -ENODEV)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct bus_type spmi_bus_type = {\n\t.name\t\t= \"spmi\",\n\t.match\t\t= spmi_device_match,\n\t.probe\t\t= spmi_drv_probe,\n\t.remove\t\t= spmi_drv_remove,\n\t.shutdown\t= spmi_drv_shutdown,\n\t.uevent\t\t= spmi_drv_uevent,\n};\n\n \nstruct spmi_device *spmi_device_from_of(struct device_node *np)\n{\n\tstruct device *dev = bus_find_device_by_of_node(&spmi_bus_type, np);\n\n\tif (dev)\n\t\treturn to_spmi_device(dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(spmi_device_from_of);\n\n \nstruct spmi_device *spmi_device_alloc(struct spmi_controller *ctrl)\n{\n\tstruct spmi_device *sdev;\n\n\tsdev = kzalloc(sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn NULL;\n\n\tsdev->ctrl = ctrl;\n\tdevice_initialize(&sdev->dev);\n\tsdev->dev.parent = &ctrl->dev;\n\tsdev->dev.bus = &spmi_bus_type;\n\tsdev->dev.type = &spmi_dev_type;\n\treturn sdev;\n}\nEXPORT_SYMBOL_GPL(spmi_device_alloc);\n\n \nstruct spmi_controller *spmi_controller_alloc(struct device *parent,\n\t\t\t\t\t      size_t size)\n{\n\tstruct spmi_controller *ctrl;\n\tint id;\n\n\tif (WARN_ON(!parent))\n\t\treturn NULL;\n\n\tctrl = kzalloc(sizeof(*ctrl) + size, GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn NULL;\n\n\tdevice_initialize(&ctrl->dev);\n\tctrl->dev.type = &spmi_ctrl_type;\n\tctrl->dev.bus = &spmi_bus_type;\n\tctrl->dev.parent = parent;\n\tctrl->dev.of_node = parent->of_node;\n\tspmi_controller_set_drvdata(ctrl, &ctrl[1]);\n\n\tid = ida_alloc(&ctrl_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(parent,\n\t\t\t\"unable to allocate SPMI controller identifier.\\n\");\n\t\tspmi_controller_put(ctrl);\n\t\treturn NULL;\n\t}\n\n\tctrl->nr = id;\n\tdev_set_name(&ctrl->dev, \"spmi-%d\", id);\n\n\tdev_dbg(&ctrl->dev, \"allocated controller 0x%p id %d\\n\", ctrl, id);\n\treturn ctrl;\n}\nEXPORT_SYMBOL_GPL(spmi_controller_alloc);\n\nstatic void of_spmi_register_devices(struct spmi_controller *ctrl)\n{\n\tstruct device_node *node;\n\tint err;\n\n\tif (!ctrl->dev.of_node)\n\t\treturn;\n\n\tfor_each_available_child_of_node(ctrl->dev.of_node, node) {\n\t\tstruct spmi_device *sdev;\n\t\tu32 reg[2];\n\n\t\tdev_dbg(&ctrl->dev, \"adding child %pOF\\n\", node);\n\n\t\terr = of_property_read_u32_array(node, \"reg\", reg, 2);\n\t\tif (err) {\n\t\t\tdev_err(&ctrl->dev,\n\t\t\t\t\"node %pOF err (%d) does not have 'reg' property\\n\",\n\t\t\t\tnode, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (reg[1] != SPMI_USID) {\n\t\t\tdev_err(&ctrl->dev,\n\t\t\t\t\"node %pOF contains unsupported 'reg' entry\\n\",\n\t\t\t\tnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (reg[0] >= SPMI_MAX_SLAVE_ID) {\n\t\t\tdev_err(&ctrl->dev, \"invalid usid on node %pOF\\n\", node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(&ctrl->dev, \"read usid %02x\\n\", reg[0]);\n\n\t\tsdev = spmi_device_alloc(ctrl);\n\t\tif (!sdev)\n\t\t\tcontinue;\n\n\t\tsdev->dev.of_node = node;\n\t\tsdev->usid = (u8)reg[0];\n\n\t\terr = spmi_device_add(sdev);\n\t\tif (err) {\n\t\t\tdev_err(&sdev->dev,\n\t\t\t\t\"failure adding device. status %d\\n\", err);\n\t\t\tspmi_device_put(sdev);\n\t\t}\n\t}\n}\n\n \nint spmi_controller_add(struct spmi_controller *ctrl)\n{\n\tint ret;\n\n\t \n\tif (WARN_ON(!is_registered))\n\t\treturn -EAGAIN;\n\n\tret = device_add(&ctrl->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_ENABLED(CONFIG_OF))\n\t\tof_spmi_register_devices(ctrl);\n\n\tdev_dbg(&ctrl->dev, \"spmi-%d registered: dev:%p\\n\",\n\t\tctrl->nr, &ctrl->dev);\n\n\treturn 0;\n};\nEXPORT_SYMBOL_GPL(spmi_controller_add);\n\n \nstatic int spmi_ctrl_remove_device(struct device *dev, void *data)\n{\n\tstruct spmi_device *spmidev = to_spmi_device(dev);\n\n\tif (dev->type == &spmi_dev_type)\n\t\tspmi_device_remove(spmidev);\n\treturn 0;\n}\n\n \nvoid spmi_controller_remove(struct spmi_controller *ctrl)\n{\n\tif (!ctrl)\n\t\treturn;\n\n\tdevice_for_each_child(&ctrl->dev, NULL, spmi_ctrl_remove_device);\n\tdevice_del(&ctrl->dev);\n}\nEXPORT_SYMBOL_GPL(spmi_controller_remove);\n\n \nint __spmi_driver_register(struct spmi_driver *sdrv, struct module *owner)\n{\n\tsdrv->driver.bus = &spmi_bus_type;\n\tsdrv->driver.owner = owner;\n\treturn driver_register(&sdrv->driver);\n}\nEXPORT_SYMBOL_GPL(__spmi_driver_register);\n\nstatic void __exit spmi_exit(void)\n{\n\tbus_unregister(&spmi_bus_type);\n}\nmodule_exit(spmi_exit);\n\nstatic int __init spmi_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&spmi_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tis_registered = true;\n\treturn 0;\n}\npostcore_initcall(spmi_init);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SPMI module\");\nMODULE_ALIAS(\"platform:spmi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}