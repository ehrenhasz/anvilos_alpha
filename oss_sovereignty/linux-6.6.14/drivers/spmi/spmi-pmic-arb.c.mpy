{
  "module_name": "spmi-pmic-arb.c",
  "hash_id": "ed45d2b61b63e41700d96a5f9c7aa07f940b0c7babb7c6b12bdb19216136bb4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/spmi/spmi-pmic-arb.c",
  "human_readable_source": "\n \n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spmi.h>\n\n \n#define PMIC_ARB_VERSION\t\t0x0000\n#define PMIC_ARB_VERSION_V2_MIN\t\t0x20010000\n#define PMIC_ARB_VERSION_V3_MIN\t\t0x30000000\n#define PMIC_ARB_VERSION_V5_MIN\t\t0x50000000\n#define PMIC_ARB_VERSION_V7_MIN\t\t0x70000000\n#define PMIC_ARB_INT_EN\t\t\t0x0004\n\n#define PMIC_ARB_FEATURES\t\t0x0004\n#define PMIC_ARB_FEATURES_PERIPH_MASK\tGENMASK(10, 0)\n\n#define PMIC_ARB_FEATURES1\t\t0x0008\n\n \n#define PMIC_ARB_CMD\t\t\t0x00\n#define PMIC_ARB_CONFIG\t\t\t0x04\n#define PMIC_ARB_STATUS\t\t\t0x08\n#define PMIC_ARB_WDATA0\t\t\t0x10\n#define PMIC_ARB_WDATA1\t\t\t0x14\n#define PMIC_ARB_RDATA0\t\t\t0x18\n#define PMIC_ARB_RDATA1\t\t\t0x1C\n\n \n#define SPMI_MAPPING_TABLE_REG(N)\t(0x0B00 + (4 * (N)))\n#define SPMI_MAPPING_BIT_INDEX(X)\t(((X) >> 18) & 0xF)\n#define SPMI_MAPPING_BIT_IS_0_FLAG(X)\t(((X) >> 17) & 0x1)\n#define SPMI_MAPPING_BIT_IS_0_RESULT(X)\t(((X) >> 9) & 0xFF)\n#define SPMI_MAPPING_BIT_IS_1_FLAG(X)\t(((X) >> 8) & 0x1)\n#define SPMI_MAPPING_BIT_IS_1_RESULT(X)\t(((X) >> 0) & 0xFF)\n\n#define SPMI_MAPPING_TABLE_TREE_DEPTH\t16\t \n#define PMIC_ARB_MAX_PPID\t\tBIT(12)  \n#define PMIC_ARB_APID_VALID\t\tBIT(15)\n#define PMIC_ARB_CHAN_IS_IRQ_OWNER(reg)\t((reg) & BIT(24))\n#define INVALID_EE\t\t\t\t0xFF\n\n \n#define SPMI_OWNERSHIP_PERIPH2OWNER(X)\t((X) & 0x7)\n\n \nenum pmic_arb_chnl_status {\n\tPMIC_ARB_STATUS_DONE\t= BIT(0),\n\tPMIC_ARB_STATUS_FAILURE\t= BIT(1),\n\tPMIC_ARB_STATUS_DENIED\t= BIT(2),\n\tPMIC_ARB_STATUS_DROPPED\t= BIT(3),\n};\n\n \n#define PMIC_ARB_CMD_MAX_BYTE_COUNT\t8\n\n \nenum pmic_arb_cmd_op_code {\n\tPMIC_ARB_OP_EXT_WRITEL = 0,\n\tPMIC_ARB_OP_EXT_READL = 1,\n\tPMIC_ARB_OP_EXT_WRITE = 2,\n\tPMIC_ARB_OP_RESET = 3,\n\tPMIC_ARB_OP_SLEEP = 4,\n\tPMIC_ARB_OP_SHUTDOWN = 5,\n\tPMIC_ARB_OP_WAKEUP = 6,\n\tPMIC_ARB_OP_AUTHENTICATE = 7,\n\tPMIC_ARB_OP_MSTR_READ = 8,\n\tPMIC_ARB_OP_MSTR_WRITE = 9,\n\tPMIC_ARB_OP_EXT_READ = 13,\n\tPMIC_ARB_OP_WRITE = 14,\n\tPMIC_ARB_OP_READ = 15,\n\tPMIC_ARB_OP_ZERO_WRITE = 16,\n};\n\n \nenum pmic_arb_channel {\n\tPMIC_ARB_CHANNEL_RW,\n\tPMIC_ARB_CHANNEL_OBS,\n};\n\n \n#define PMIC_ARB_MAX_PERIPHS\t\t512\n#define PMIC_ARB_MAX_PERIPHS_V7\t\t1024\n#define PMIC_ARB_TIMEOUT_US\t\t1000\n#define PMIC_ARB_MAX_TRANS_BYTES\t(8)\n\n#define PMIC_ARB_APID_MASK\t\t0xFF\n#define PMIC_ARB_PPID_MASK\t\t0xFFF\n\n \n#define SPMI_PIC_ACC_ENABLE_BIT\t\tBIT(0)\n\n#define spec_to_hwirq(slave_id, periph_id, irq_id, apid) \\\n\t((((slave_id) & 0xF)   << 28) | \\\n\t(((periph_id) & 0xFF)  << 20) | \\\n\t(((irq_id)    & 0x7)   << 16) | \\\n\t(((apid)      & 0x3FF) << 0))\n\n#define hwirq_to_sid(hwirq)  (((hwirq) >> 28) & 0xF)\n#define hwirq_to_per(hwirq)  (((hwirq) >> 20) & 0xFF)\n#define hwirq_to_irq(hwirq)  (((hwirq) >> 16) & 0x7)\n#define hwirq_to_apid(hwirq) (((hwirq) >> 0)  & 0x3FF)\n\nstruct pmic_arb_ver_ops;\n\nstruct apid_data {\n\tu16\t\tppid;\n\tu8\t\twrite_ee;\n\tu8\t\tirq_ee;\n};\n\n \nstruct spmi_pmic_arb {\n\tvoid __iomem\t\t*rd_base;\n\tvoid __iomem\t\t*wr_base;\n\tvoid __iomem\t\t*intr;\n\tvoid __iomem\t\t*cnfg;\n\tvoid __iomem\t\t*core;\n\tresource_size_t\t\tcore_size;\n\traw_spinlock_t\t\tlock;\n\tu8\t\t\tchannel;\n\tint\t\t\tirq;\n\tu8\t\t\tee;\n\tu32\t\t\tbus_instance;\n\tu16\t\t\tmin_apid;\n\tu16\t\t\tmax_apid;\n\tu16\t\t\tbase_apid;\n\tint\t\t\tapid_count;\n\tu32\t\t\t*mapping_table;\n\tDECLARE_BITMAP(mapping_table_valid, PMIC_ARB_MAX_PERIPHS);\n\tstruct irq_domain\t*domain;\n\tstruct spmi_controller\t*spmic;\n\tconst struct pmic_arb_ver_ops *ver_ops;\n\tu16\t\t\t*ppid_to_apid;\n\tu16\t\t\tlast_apid;\n\tstruct apid_data\t*apid_data;\n\tint\t\t\tmax_periphs;\n};\n\n \nstruct pmic_arb_ver_ops {\n\tconst char *ver_str;\n\tint (*ppid_to_apid)(struct spmi_pmic_arb *pmic_arb, u16 ppid);\n\t \n\tint (*offset)(struct spmi_pmic_arb *pmic_arb, u8 sid, u16 addr,\n\t\t\tenum pmic_arb_channel ch_type);\n\tu32 (*fmt_cmd)(u8 opc, u8 sid, u16 addr, u8 bc);\n\tint (*non_data_cmd)(struct spmi_controller *ctrl, u8 opc, u8 sid);\n\t \n\tvoid __iomem *(*owner_acc_status)(struct spmi_pmic_arb *pmic_arb, u8 m,\n\t\t\t\t\t  u16 n);\n\tvoid __iomem *(*acc_enable)(struct spmi_pmic_arb *pmic_arb, u16 n);\n\tvoid __iomem *(*irq_status)(struct spmi_pmic_arb *pmic_arb, u16 n);\n\tvoid __iomem *(*irq_clear)(struct spmi_pmic_arb *pmic_arb, u16 n);\n\tu32 (*apid_map_offset)(u16 n);\n\tvoid __iomem *(*apid_owner)(struct spmi_pmic_arb *pmic_arb, u16 n);\n};\n\nstatic inline void pmic_arb_base_write(struct spmi_pmic_arb *pmic_arb,\n\t\t\t\t       u32 offset, u32 val)\n{\n\twritel_relaxed(val, pmic_arb->wr_base + offset);\n}\n\nstatic inline void pmic_arb_set_rd_cmd(struct spmi_pmic_arb *pmic_arb,\n\t\t\t\t       u32 offset, u32 val)\n{\n\twritel_relaxed(val, pmic_arb->rd_base + offset);\n}\n\n \nstatic void\npmic_arb_read_data(struct spmi_pmic_arb *pmic_arb, u8 *buf, u32 reg, u8 bc)\n{\n\tu32 data = __raw_readl(pmic_arb->rd_base + reg);\n\n\tmemcpy(buf, &data, (bc & 3) + 1);\n}\n\n \nstatic void pmic_arb_write_data(struct spmi_pmic_arb *pmic_arb, const u8 *buf,\n\t\t\t\tu32 reg, u8 bc)\n{\n\tu32 data = 0;\n\n\tmemcpy(&data, buf, (bc & 3) + 1);\n\t__raw_writel(data, pmic_arb->wr_base + reg);\n}\n\nstatic int pmic_arb_wait_for_done(struct spmi_controller *ctrl,\n\t\t\t\t  void __iomem *base, u8 sid, u16 addr,\n\t\t\t\t  enum pmic_arb_channel ch_type)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tu32 status = 0;\n\tu32 timeout = PMIC_ARB_TIMEOUT_US;\n\tu32 offset;\n\tint rc;\n\n\trc = pmic_arb->ver_ops->offset(pmic_arb, sid, addr, ch_type);\n\tif (rc < 0)\n\t\treturn rc;\n\n\toffset = rc;\n\toffset += PMIC_ARB_STATUS;\n\n\twhile (timeout--) {\n\t\tstatus = readl_relaxed(base + offset);\n\n\t\tif (status & PMIC_ARB_STATUS_DONE) {\n\t\t\tif (status & PMIC_ARB_STATUS_DENIED) {\n\t\t\t\tdev_err(&ctrl->dev, \"%s: %#x %#x: transaction denied (%#x)\\n\",\n\t\t\t\t\t__func__, sid, addr, status);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\n\t\t\tif (status & PMIC_ARB_STATUS_FAILURE) {\n\t\t\t\tdev_err(&ctrl->dev, \"%s: %#x %#x: transaction failed (%#x)\\n\",\n\t\t\t\t\t__func__, sid, addr, status);\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif (status & PMIC_ARB_STATUS_DROPPED) {\n\t\t\t\tdev_err(&ctrl->dev, \"%s: %#x %#x: transaction dropped (%#x)\\n\",\n\t\t\t\t\t__func__, sid, addr, status);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tdev_err(&ctrl->dev, \"%s: %#x %#x: timeout, status %#x\\n\",\n\t\t__func__, sid, addr, status);\n\treturn -ETIMEDOUT;\n}\n\nstatic int\npmic_arb_non_data_cmd_v1(struct spmi_controller *ctrl, u8 opc, u8 sid)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tunsigned long flags;\n\tu32 cmd;\n\tint rc;\n\tu32 offset;\n\n\trc = pmic_arb->ver_ops->offset(pmic_arb, sid, 0, PMIC_ARB_CHANNEL_RW);\n\tif (rc < 0)\n\t\treturn rc;\n\n\toffset = rc;\n\tcmd = ((opc | 0x40) << 27) | ((sid & 0xf) << 20);\n\n\traw_spin_lock_irqsave(&pmic_arb->lock, flags);\n\tpmic_arb_base_write(pmic_arb, offset + PMIC_ARB_CMD, cmd);\n\trc = pmic_arb_wait_for_done(ctrl, pmic_arb->wr_base, sid, 0,\n\t\t\t\t    PMIC_ARB_CHANNEL_RW);\n\traw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\n\n\treturn rc;\n}\n\nstatic int\npmic_arb_non_data_cmd_v2(struct spmi_controller *ctrl, u8 opc, u8 sid)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int pmic_arb_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\n\tdev_dbg(&ctrl->dev, \"cmd op:0x%x sid:%d\\n\", opc, sid);\n\n\t \n\tif (opc < SPMI_CMD_RESET || opc > SPMI_CMD_WAKEUP)\n\t\treturn -EINVAL;\n\n\treturn pmic_arb->ver_ops->non_data_cmd(ctrl, opc, sid);\n}\n\nstatic int pmic_arb_fmt_read_cmd(struct spmi_pmic_arb *pmic_arb, u8 opc, u8 sid,\n\t\t\t\t u16 addr, size_t len, u32 *cmd, u32 *offset)\n{\n\tu8 bc = len - 1;\n\tint rc;\n\n\trc = pmic_arb->ver_ops->offset(pmic_arb, sid, addr,\n\t\t\t\t       PMIC_ARB_CHANNEL_OBS);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*offset = rc;\n\tif (bc >= PMIC_ARB_MAX_TRANS_BYTES) {\n\t\tdev_err(&pmic_arb->spmic->dev, \"pmic-arb supports 1..%d bytes per trans, but:%zu requested\",\n\t\t\tPMIC_ARB_MAX_TRANS_BYTES, len);\n\t\treturn  -EINVAL;\n\t}\n\n\t \n\tif (opc >= 0x60 && opc <= 0x7F)\n\t\topc = PMIC_ARB_OP_READ;\n\telse if (opc >= 0x20 && opc <= 0x2F)\n\t\topc = PMIC_ARB_OP_EXT_READ;\n\telse if (opc >= 0x38 && opc <= 0x3F)\n\t\topc = PMIC_ARB_OP_EXT_READL;\n\telse\n\t\treturn -EINVAL;\n\n\t*cmd = pmic_arb->ver_ops->fmt_cmd(opc, sid, addr, bc);\n\n\treturn 0;\n}\n\nstatic int pmic_arb_read_cmd_unlocked(struct spmi_controller *ctrl, u32 cmd,\n\t\t\t\t      u32 offset, u8 sid, u16 addr, u8 *buf,\n\t\t\t\t      size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tu8 bc = len - 1;\n\tint rc;\n\n\tpmic_arb_set_rd_cmd(pmic_arb, offset + PMIC_ARB_CMD, cmd);\n\trc = pmic_arb_wait_for_done(ctrl, pmic_arb->rd_base, sid, addr,\n\t\t\t\t    PMIC_ARB_CHANNEL_OBS);\n\tif (rc)\n\t\treturn rc;\n\n\tpmic_arb_read_data(pmic_arb, buf, offset + PMIC_ARB_RDATA0,\n\t\t     min_t(u8, bc, 3));\n\n\tif (bc > 3)\n\t\tpmic_arb_read_data(pmic_arb, buf + 4, offset + PMIC_ARB_RDATA1,\n\t\t\t\t\tbc - 4);\n\treturn 0;\n}\n\nstatic int pmic_arb_read_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,\n\t\t\t     u16 addr, u8 *buf, size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tunsigned long flags;\n\tu32 cmd, offset;\n\tint rc;\n\n\trc = pmic_arb_fmt_read_cmd(pmic_arb, opc, sid, addr, len, &cmd,\n\t\t\t\t   &offset);\n\tif (rc)\n\t\treturn rc;\n\n\traw_spin_lock_irqsave(&pmic_arb->lock, flags);\n\trc = pmic_arb_read_cmd_unlocked(ctrl, cmd, offset, sid, addr, buf, len);\n\traw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\n\n\treturn rc;\n}\n\nstatic int pmic_arb_fmt_write_cmd(struct spmi_pmic_arb *pmic_arb, u8 opc,\n\t\t\t\t  u8 sid, u16 addr, size_t len, u32 *cmd,\n\t\t\t\t  u32 *offset)\n{\n\tu8 bc = len - 1;\n\tint rc;\n\n\trc = pmic_arb->ver_ops->offset(pmic_arb, sid, addr,\n\t\t\t\t\tPMIC_ARB_CHANNEL_RW);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*offset = rc;\n\tif (bc >= PMIC_ARB_MAX_TRANS_BYTES) {\n\t\tdev_err(&pmic_arb->spmic->dev, \"pmic-arb supports 1..%d bytes per trans, but:%zu requested\",\n\t\t\tPMIC_ARB_MAX_TRANS_BYTES, len);\n\t\treturn  -EINVAL;\n\t}\n\n\t \n\tif (opc >= 0x40 && opc <= 0x5F)\n\t\topc = PMIC_ARB_OP_WRITE;\n\telse if (opc <= 0x0F)\n\t\topc = PMIC_ARB_OP_EXT_WRITE;\n\telse if (opc >= 0x30 && opc <= 0x37)\n\t\topc = PMIC_ARB_OP_EXT_WRITEL;\n\telse if (opc >= 0x80)\n\t\topc = PMIC_ARB_OP_ZERO_WRITE;\n\telse\n\t\treturn -EINVAL;\n\n\t*cmd = pmic_arb->ver_ops->fmt_cmd(opc, sid, addr, bc);\n\n\treturn 0;\n}\n\nstatic int pmic_arb_write_cmd_unlocked(struct spmi_controller *ctrl, u32 cmd,\n\t\t\t\t      u32 offset, u8 sid, u16 addr,\n\t\t\t\t      const u8 *buf, size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tu8 bc = len - 1;\n\n\t \n\tpmic_arb_write_data(pmic_arb, buf, offset + PMIC_ARB_WDATA0,\n\t\t\t\tmin_t(u8, bc, 3));\n\tif (bc > 3)\n\t\tpmic_arb_write_data(pmic_arb, buf + 4, offset + PMIC_ARB_WDATA1,\n\t\t\t\t\tbc - 4);\n\n\t \n\tpmic_arb_base_write(pmic_arb, offset + PMIC_ARB_CMD, cmd);\n\treturn pmic_arb_wait_for_done(ctrl, pmic_arb->wr_base, sid, addr,\n\t\t\t\t      PMIC_ARB_CHANNEL_RW);\n}\n\nstatic int pmic_arb_write_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,\n\t\t\t      u16 addr, const u8 *buf, size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tunsigned long flags;\n\tu32 cmd, offset;\n\tint rc;\n\n\trc = pmic_arb_fmt_write_cmd(pmic_arb, opc, sid, addr, len, &cmd,\n\t\t\t\t    &offset);\n\tif (rc)\n\t\treturn rc;\n\n\traw_spin_lock_irqsave(&pmic_arb->lock, flags);\n\trc = pmic_arb_write_cmd_unlocked(ctrl, cmd, offset, sid, addr, buf,\n\t\t\t\t\t len);\n\traw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\n\n\treturn rc;\n}\n\nstatic int pmic_arb_masked_write(struct spmi_controller *ctrl, u8 sid, u16 addr,\n\t\t\t\t const u8 *buf, const u8 *mask, size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tu32 read_cmd, read_offset, write_cmd, write_offset;\n\tu8 temp[PMIC_ARB_MAX_TRANS_BYTES];\n\tunsigned long flags;\n\tint rc, i;\n\n\trc = pmic_arb_fmt_read_cmd(pmic_arb, SPMI_CMD_EXT_READL, sid, addr, len,\n\t\t\t\t   &read_cmd, &read_offset);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pmic_arb_fmt_write_cmd(pmic_arb, SPMI_CMD_EXT_WRITEL, sid, addr,\n\t\t\t\t    len, &write_cmd, &write_offset);\n\tif (rc)\n\t\treturn rc;\n\n\traw_spin_lock_irqsave(&pmic_arb->lock, flags);\n\trc = pmic_arb_read_cmd_unlocked(ctrl, read_cmd, read_offset, sid, addr,\n\t\t\t\t\ttemp, len);\n\tif (rc)\n\t\tgoto done;\n\n\tfor (i = 0; i < len; i++)\n\t\ttemp[i] = (temp[i] & ~mask[i]) | (buf[i] & mask[i]);\n\n\trc = pmic_arb_write_cmd_unlocked(ctrl, write_cmd, write_offset, sid,\n\t\t\t\t\t addr, temp, len);\ndone:\n\traw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\n\n\treturn rc;\n}\n\nenum qpnpint_regs {\n\tQPNPINT_REG_RT_STS\t\t= 0x10,\n\tQPNPINT_REG_SET_TYPE\t\t= 0x11,\n\tQPNPINT_REG_POLARITY_HIGH\t= 0x12,\n\tQPNPINT_REG_POLARITY_LOW\t= 0x13,\n\tQPNPINT_REG_LATCHED_CLR\t\t= 0x14,\n\tQPNPINT_REG_EN_SET\t\t= 0x15,\n\tQPNPINT_REG_EN_CLR\t\t= 0x16,\n\tQPNPINT_REG_LATCHED_STS\t\t= 0x18,\n};\n\nstruct spmi_pmic_arb_qpnpint_type {\n\tu8 type;  \n\tu8 polarity_high;\n\tu8 polarity_low;\n} __packed;\n\n \nstatic void qpnpint_spmi_write(struct irq_data *d, u8 reg, void *buf,\n\t\t\t       size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\tu8 sid = hwirq_to_sid(d->hwirq);\n\tu8 per = hwirq_to_per(d->hwirq);\n\n\tif (pmic_arb_write_cmd(pmic_arb->spmic, SPMI_CMD_EXT_WRITEL, sid,\n\t\t\t       (per << 8) + reg, buf, len))\n\t\tdev_err_ratelimited(&pmic_arb->spmic->dev, \"failed irqchip transaction on %x\\n\",\n\t\t\t\t    d->irq);\n}\n\nstatic void qpnpint_spmi_read(struct irq_data *d, u8 reg, void *buf, size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\tu8 sid = hwirq_to_sid(d->hwirq);\n\tu8 per = hwirq_to_per(d->hwirq);\n\n\tif (pmic_arb_read_cmd(pmic_arb->spmic, SPMI_CMD_EXT_READL, sid,\n\t\t\t      (per << 8) + reg, buf, len))\n\t\tdev_err_ratelimited(&pmic_arb->spmic->dev, \"failed irqchip transaction on %x\\n\",\n\t\t\t\t    d->irq);\n}\n\nstatic int qpnpint_spmi_masked_write(struct irq_data *d, u8 reg,\n\t\t\t\t     const void *buf, const void *mask,\n\t\t\t\t     size_t len)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\tu8 sid = hwirq_to_sid(d->hwirq);\n\tu8 per = hwirq_to_per(d->hwirq);\n\tint rc;\n\n\trc = pmic_arb_masked_write(pmic_arb->spmic, sid, (per << 8) + reg, buf,\n\t\t\t\t   mask, len);\n\tif (rc)\n\t\tdev_err_ratelimited(&pmic_arb->spmic->dev, \"failed irqchip transaction on %x rc=%d\\n\",\n\t\t\t\t    d->irq, rc);\n\treturn rc;\n}\n\nstatic void cleanup_irq(struct spmi_pmic_arb *pmic_arb, u16 apid, int id)\n{\n\tu16 ppid = pmic_arb->apid_data[apid].ppid;\n\tu8 sid = ppid >> 8;\n\tu8 per = ppid & 0xFF;\n\tu8 irq_mask = BIT(id);\n\n\tdev_err_ratelimited(&pmic_arb->spmic->dev, \"%s apid=%d sid=0x%x per=0x%x irq=%d\\n\",\n\t\t\t__func__, apid, sid, per, id);\n\twritel_relaxed(irq_mask, pmic_arb->ver_ops->irq_clear(pmic_arb, apid));\n}\n\nstatic int periph_interrupt(struct spmi_pmic_arb *pmic_arb, u16 apid)\n{\n\tunsigned int irq;\n\tu32 status, id;\n\tint handled = 0;\n\tu8 sid = (pmic_arb->apid_data[apid].ppid >> 8) & 0xF;\n\tu8 per = pmic_arb->apid_data[apid].ppid & 0xFF;\n\n\tstatus = readl_relaxed(pmic_arb->ver_ops->irq_status(pmic_arb, apid));\n\twhile (status) {\n\t\tid = ffs(status) - 1;\n\t\tstatus &= ~BIT(id);\n\t\tirq = irq_find_mapping(pmic_arb->domain,\n\t\t\t\t\tspec_to_hwirq(sid, per, id, apid));\n\t\tif (irq == 0) {\n\t\t\tcleanup_irq(pmic_arb, apid, id);\n\t\t\tcontinue;\n\t\t}\n\t\tgeneric_handle_irq(irq);\n\t\thandled++;\n\t}\n\n\treturn handled;\n}\n\nstatic void pmic_arb_chained_irq(struct irq_desc *desc)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_desc_get_handler_data(desc);\n\tconst struct pmic_arb_ver_ops *ver_ops = pmic_arb->ver_ops;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint first = pmic_arb->min_apid;\n\tint last = pmic_arb->max_apid;\n\t \n\tint acc_offset = pmic_arb->base_apid >> 5;\n\tu8 ee = pmic_arb->ee;\n\tu32 status, enable, handled = 0;\n\tint i, id, apid;\n\t \n\tbool acc_valid = false;\n\tu32 irq_status = 0;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = first >> 5; i <= last >> 5; ++i) {\n\t\tstatus = readl_relaxed(ver_ops->owner_acc_status(pmic_arb, ee, i - acc_offset));\n\t\tif (status)\n\t\t\tacc_valid = true;\n\n\t\twhile (status) {\n\t\t\tid = ffs(status) - 1;\n\t\t\tstatus &= ~BIT(id);\n\t\t\tapid = id + i * 32;\n\t\t\tif (apid < first || apid > last) {\n\t\t\t\tWARN_ONCE(true, \"spurious spmi irq received for apid=%d\\n\",\n\t\t\t\t\tapid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tenable = readl_relaxed(\n\t\t\t\t\tver_ops->acc_enable(pmic_arb, apid));\n\t\t\tif (enable & SPMI_PIC_ACC_ENABLE_BIT)\n\t\t\t\tif (periph_interrupt(pmic_arb, apid) != 0)\n\t\t\t\t\thandled++;\n\t\t}\n\t}\n\n\t \n\tif (!acc_valid) {\n\t\tfor (i = first; i <= last; i++) {\n\t\t\t \n\t\t\tif (pmic_arb->apid_data[i].irq_ee != pmic_arb->ee)\n\t\t\t\tcontinue;\n\n\t\t\tirq_status = readl_relaxed(\n\t\t\t\t\t     ver_ops->irq_status(pmic_arb, i));\n\t\t\tif (irq_status) {\n\t\t\t\tenable = readl_relaxed(\n\t\t\t\t\t     ver_ops->acc_enable(pmic_arb, i));\n\t\t\t\tif (enable & SPMI_PIC_ACC_ENABLE_BIT) {\n\t\t\t\t\tdev_dbg(&pmic_arb->spmic->dev,\n\t\t\t\t\t\t\"Dispatching IRQ for apid=%d status=%x\\n\",\n\t\t\t\t\t\ti, irq_status);\n\t\t\t\t\tif (periph_interrupt(pmic_arb, i) != 0)\n\t\t\t\t\t\thandled++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (handled == 0)\n\t\thandle_bad_irq(desc);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void qpnpint_irq_ack(struct irq_data *d)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\tu8 irq = hwirq_to_irq(d->hwirq);\n\tu16 apid = hwirq_to_apid(d->hwirq);\n\tu8 data;\n\n\twritel_relaxed(BIT(irq), pmic_arb->ver_ops->irq_clear(pmic_arb, apid));\n\n\tdata = BIT(irq);\n\tqpnpint_spmi_write(d, QPNPINT_REG_LATCHED_CLR, &data, 1);\n}\n\nstatic void qpnpint_irq_mask(struct irq_data *d)\n{\n\tu8 irq = hwirq_to_irq(d->hwirq);\n\tu8 data = BIT(irq);\n\n\tqpnpint_spmi_write(d, QPNPINT_REG_EN_CLR, &data, 1);\n}\n\nstatic void qpnpint_irq_unmask(struct irq_data *d)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\tconst struct pmic_arb_ver_ops *ver_ops = pmic_arb->ver_ops;\n\tu8 irq = hwirq_to_irq(d->hwirq);\n\tu16 apid = hwirq_to_apid(d->hwirq);\n\tu8 buf[2];\n\n\twritel_relaxed(SPMI_PIC_ACC_ENABLE_BIT,\n\t\t\tver_ops->acc_enable(pmic_arb, apid));\n\n\tqpnpint_spmi_read(d, QPNPINT_REG_EN_SET, &buf[0], 1);\n\tif (!(buf[0] & BIT(irq))) {\n\t\t \n\t\tbuf[0] = BIT(irq);\n\t\tbuf[1] = BIT(irq);\n\t\tqpnpint_spmi_write(d, QPNPINT_REG_LATCHED_CLR, &buf, 2);\n\t}\n}\n\nstatic int qpnpint_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct spmi_pmic_arb_qpnpint_type type = {0};\n\tstruct spmi_pmic_arb_qpnpint_type mask;\n\tirq_flow_handler_t flow_handler;\n\tu8 irq_bit = BIT(hwirq_to_irq(d->hwirq));\n\tint rc;\n\n\tif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\n\t\ttype.type = irq_bit;\n\t\tif (flow_type & IRQF_TRIGGER_RISING)\n\t\t\ttype.polarity_high = irq_bit;\n\t\tif (flow_type & IRQF_TRIGGER_FALLING)\n\t\t\ttype.polarity_low = irq_bit;\n\n\t\tflow_handler = handle_edge_irq;\n\t} else {\n\t\tif ((flow_type & (IRQF_TRIGGER_HIGH)) &&\n\t\t    (flow_type & (IRQF_TRIGGER_LOW)))\n\t\t\treturn -EINVAL;\n\n\t\tif (flow_type & IRQF_TRIGGER_HIGH)\n\t\t\ttype.polarity_high = irq_bit;\n\t\telse\n\t\t\ttype.polarity_low = irq_bit;\n\n\t\tflow_handler = handle_level_irq;\n\t}\n\n\tmask.type = irq_bit;\n\tmask.polarity_high = irq_bit;\n\tmask.polarity_low = irq_bit;\n\n\trc = qpnpint_spmi_masked_write(d, QPNPINT_REG_SET_TYPE, &type, &mask,\n\t\t\t\t       sizeof(type));\n\tirq_set_handler_locked(d, flow_handler);\n\n\treturn rc;\n}\n\nstatic int qpnpint_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\n\treturn irq_set_irq_wake(pmic_arb->irq, on);\n}\n\nstatic int qpnpint_get_irqchip_state(struct irq_data *d,\n\t\t\t\t     enum irqchip_irq_state which,\n\t\t\t\t     bool *state)\n{\n\tu8 irq = hwirq_to_irq(d->hwirq);\n\tu8 status = 0;\n\n\tif (which != IRQCHIP_STATE_LINE_LEVEL)\n\t\treturn -EINVAL;\n\n\tqpnpint_spmi_read(d, QPNPINT_REG_RT_STS, &status, 1);\n\t*state = !!(status & BIT(irq));\n\n\treturn 0;\n}\n\nstatic int qpnpint_irq_domain_activate(struct irq_domain *domain,\n\t\t\t\t       struct irq_data *d, bool reserve)\n{\n\tstruct spmi_pmic_arb *pmic_arb = irq_data_get_irq_chip_data(d);\n\tu16 periph = hwirq_to_per(d->hwirq);\n\tu16 apid = hwirq_to_apid(d->hwirq);\n\tu16 sid = hwirq_to_sid(d->hwirq);\n\tu16 irq = hwirq_to_irq(d->hwirq);\n\tu8 buf;\n\n\tif (pmic_arb->apid_data[apid].irq_ee != pmic_arb->ee) {\n\t\tdev_err(&pmic_arb->spmic->dev, \"failed to xlate sid = %#x, periph = %#x, irq = %u: ee=%u but owner=%u\\n\",\n\t\t\tsid, periph, irq, pmic_arb->ee,\n\t\t\tpmic_arb->apid_data[apid].irq_ee);\n\t\treturn -ENODEV;\n\t}\n\n\tbuf = BIT(irq);\n\tqpnpint_spmi_write(d, QPNPINT_REG_EN_CLR, &buf, 1);\n\tqpnpint_spmi_write(d, QPNPINT_REG_LATCHED_CLR, &buf, 1);\n\n\treturn 0;\n}\n\nstatic struct irq_chip pmic_arb_irqchip = {\n\t.name\t\t= \"pmic_arb\",\n\t.irq_ack\t= qpnpint_irq_ack,\n\t.irq_mask\t= qpnpint_irq_mask,\n\t.irq_unmask\t= qpnpint_irq_unmask,\n\t.irq_set_type\t= qpnpint_irq_set_type,\n\t.irq_set_wake\t= qpnpint_irq_set_wake,\n\t.irq_get_irqchip_state\t= qpnpint_get_irqchip_state,\n\t.flags\t\t= IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic int qpnpint_irq_domain_translate(struct irq_domain *d,\n\t\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\t\tunsigned long *out_hwirq,\n\t\t\t\t\tunsigned int *out_type)\n{\n\tstruct spmi_pmic_arb *pmic_arb = d->host_data;\n\tu32 *intspec = fwspec->param;\n\tu16 apid, ppid;\n\tint rc;\n\n\tdev_dbg(&pmic_arb->spmic->dev, \"intspec[0] 0x%1x intspec[1] 0x%02x intspec[2] 0x%02x\\n\",\n\t\tintspec[0], intspec[1], intspec[2]);\n\n\tif (irq_domain_get_of_node(d) != pmic_arb->spmic->dev.of_node)\n\t\treturn -EINVAL;\n\tif (fwspec->param_count != 4)\n\t\treturn -EINVAL;\n\tif (intspec[0] > 0xF || intspec[1] > 0xFF || intspec[2] > 0x7)\n\t\treturn -EINVAL;\n\n\tppid = intspec[0] << 8 | intspec[1];\n\trc = pmic_arb->ver_ops->ppid_to_apid(pmic_arb, ppid);\n\tif (rc < 0) {\n\t\tdev_err(&pmic_arb->spmic->dev, \"failed to xlate sid = %#x, periph = %#x, irq = %u rc = %d\\n\",\n\t\tintspec[0], intspec[1], intspec[2], rc);\n\t\treturn rc;\n\t}\n\n\tapid = rc;\n\t \n\tif (apid > pmic_arb->max_apid)\n\t\tpmic_arb->max_apid = apid;\n\tif (apid < pmic_arb->min_apid)\n\t\tpmic_arb->min_apid = apid;\n\n\t*out_hwirq = spec_to_hwirq(intspec[0], intspec[1], intspec[2], apid);\n\t*out_type  = intspec[3] & IRQ_TYPE_SENSE_MASK;\n\n\tdev_dbg(&pmic_arb->spmic->dev, \"out_hwirq = %lu\\n\", *out_hwirq);\n\n\treturn 0;\n}\n\nstatic struct lock_class_key qpnpint_irq_lock_class, qpnpint_irq_request_class;\n\nstatic void qpnpint_irq_domain_map(struct spmi_pmic_arb *pmic_arb,\n\t\t\t\t   struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   irq_hw_number_t hwirq, unsigned int type)\n{\n\tirq_flow_handler_t handler;\n\n\tdev_dbg(&pmic_arb->spmic->dev, \"virq = %u, hwirq = %lu, type = %u\\n\",\n\t\tvirq, hwirq, type);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\thandler = handle_edge_irq;\n\telse\n\t\thandler = handle_level_irq;\n\n\n\tirq_set_lockdep_class(virq, &qpnpint_irq_lock_class,\n\t\t\t      &qpnpint_irq_request_class);\n\tirq_domain_set_info(domain, virq, hwirq, &pmic_arb_irqchip, pmic_arb,\n\t\t\t    handler, NULL, NULL);\n}\n\nstatic int qpnpint_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t    void *data)\n{\n\tstruct spmi_pmic_arb *pmic_arb = domain->host_data;\n\tstruct irq_fwspec *fwspec = data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret, i;\n\n\tret = qpnpint_irq_domain_translate(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tqpnpint_irq_domain_map(pmic_arb, domain, virq + i, hwirq + i,\n\t\t\t\t       type);\n\n\treturn 0;\n}\n\nstatic int pmic_arb_ppid_to_apid_v1(struct spmi_pmic_arb *pmic_arb, u16 ppid)\n{\n\tu32 *mapping_table = pmic_arb->mapping_table;\n\tint index = 0, i;\n\tu16 apid_valid;\n\tu16 apid;\n\tu32 data;\n\n\tapid_valid = pmic_arb->ppid_to_apid[ppid];\n\tif (apid_valid & PMIC_ARB_APID_VALID) {\n\t\tapid = apid_valid & ~PMIC_ARB_APID_VALID;\n\t\treturn apid;\n\t}\n\n\tfor (i = 0; i < SPMI_MAPPING_TABLE_TREE_DEPTH; ++i) {\n\t\tif (!test_and_set_bit(index, pmic_arb->mapping_table_valid))\n\t\t\tmapping_table[index] = readl_relaxed(pmic_arb->cnfg +\n\t\t\t\t\t\tSPMI_MAPPING_TABLE_REG(index));\n\n\t\tdata = mapping_table[index];\n\n\t\tif (ppid & BIT(SPMI_MAPPING_BIT_INDEX(data))) {\n\t\t\tif (SPMI_MAPPING_BIT_IS_1_FLAG(data)) {\n\t\t\t\tindex = SPMI_MAPPING_BIT_IS_1_RESULT(data);\n\t\t\t} else {\n\t\t\t\tapid = SPMI_MAPPING_BIT_IS_1_RESULT(data);\n\t\t\t\tpmic_arb->ppid_to_apid[ppid]\n\t\t\t\t\t= apid | PMIC_ARB_APID_VALID;\n\t\t\t\tpmic_arb->apid_data[apid].ppid = ppid;\n\t\t\t\treturn apid;\n\t\t\t}\n\t\t} else {\n\t\t\tif (SPMI_MAPPING_BIT_IS_0_FLAG(data)) {\n\t\t\t\tindex = SPMI_MAPPING_BIT_IS_0_RESULT(data);\n\t\t\t} else {\n\t\t\t\tapid = SPMI_MAPPING_BIT_IS_0_RESULT(data);\n\t\t\t\tpmic_arb->ppid_to_apid[ppid]\n\t\t\t\t\t= apid | PMIC_ARB_APID_VALID;\n\t\t\t\tpmic_arb->apid_data[apid].ppid = ppid;\n\t\t\t\treturn apid;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int pmic_arb_offset_v1(struct spmi_pmic_arb *pmic_arb, u8 sid, u16 addr,\n\t\t\tenum pmic_arb_channel ch_type)\n{\n\treturn 0x800 + 0x80 * pmic_arb->channel;\n}\n\nstatic u16 pmic_arb_find_apid(struct spmi_pmic_arb *pmic_arb, u16 ppid)\n{\n\tstruct apid_data *apidd = &pmic_arb->apid_data[pmic_arb->last_apid];\n\tu32 regval, offset;\n\tu16 id, apid;\n\n\tfor (apid = pmic_arb->last_apid; ; apid++, apidd++) {\n\t\toffset = pmic_arb->ver_ops->apid_map_offset(apid);\n\t\tif (offset >= pmic_arb->core_size)\n\t\t\tbreak;\n\n\t\tregval = readl_relaxed(pmic_arb->ver_ops->apid_owner(pmic_arb,\n\t\t\t\t\t\t\t\t     apid));\n\t\tapidd->irq_ee = SPMI_OWNERSHIP_PERIPH2OWNER(regval);\n\t\tapidd->write_ee = apidd->irq_ee;\n\n\t\tregval = readl_relaxed(pmic_arb->core + offset);\n\t\tif (!regval)\n\t\t\tcontinue;\n\n\t\tid = (regval >> 8) & PMIC_ARB_PPID_MASK;\n\t\tpmic_arb->ppid_to_apid[id] = apid | PMIC_ARB_APID_VALID;\n\t\tapidd->ppid = id;\n\t\tif (id == ppid) {\n\t\t\tapid |= PMIC_ARB_APID_VALID;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpmic_arb->last_apid = apid & ~PMIC_ARB_APID_VALID;\n\n\treturn apid;\n}\n\nstatic int pmic_arb_ppid_to_apid_v2(struct spmi_pmic_arb *pmic_arb, u16 ppid)\n{\n\tu16 apid_valid;\n\n\tapid_valid = pmic_arb->ppid_to_apid[ppid];\n\tif (!(apid_valid & PMIC_ARB_APID_VALID))\n\t\tapid_valid = pmic_arb_find_apid(pmic_arb, ppid);\n\tif (!(apid_valid & PMIC_ARB_APID_VALID))\n\t\treturn -ENODEV;\n\n\treturn apid_valid & ~PMIC_ARB_APID_VALID;\n}\n\nstatic int pmic_arb_read_apid_map_v5(struct spmi_pmic_arb *pmic_arb)\n{\n\tstruct apid_data *apidd;\n\tstruct apid_data *prev_apidd;\n\tu16 i, apid, ppid, apid_max;\n\tbool valid, is_irq_ee;\n\tu32 regval, offset;\n\n\t \n\tapidd = &pmic_arb->apid_data[pmic_arb->base_apid];\n\tapid_max = pmic_arb->base_apid + pmic_arb->apid_count;\n\tfor (i = pmic_arb->base_apid; i < apid_max; i++, apidd++) {\n\t\toffset = pmic_arb->ver_ops->apid_map_offset(i);\n\t\tif (offset >= pmic_arb->core_size)\n\t\t\tbreak;\n\n\t\tregval = readl_relaxed(pmic_arb->core + offset);\n\t\tif (!regval)\n\t\t\tcontinue;\n\t\tppid = (regval >> 8) & PMIC_ARB_PPID_MASK;\n\t\tis_irq_ee = PMIC_ARB_CHAN_IS_IRQ_OWNER(regval);\n\n\t\tregval = readl_relaxed(pmic_arb->ver_ops->apid_owner(pmic_arb,\n\t\t\t\t\t\t\t\t     i));\n\t\tapidd->write_ee = SPMI_OWNERSHIP_PERIPH2OWNER(regval);\n\n\t\tapidd->irq_ee = is_irq_ee ? apidd->write_ee : INVALID_EE;\n\n\t\tvalid = pmic_arb->ppid_to_apid[ppid] & PMIC_ARB_APID_VALID;\n\t\tapid = pmic_arb->ppid_to_apid[ppid] & ~PMIC_ARB_APID_VALID;\n\t\tprev_apidd = &pmic_arb->apid_data[apid];\n\n\t\tif (!valid || apidd->write_ee == pmic_arb->ee) {\n\t\t\t \n\t\t\tpmic_arb->ppid_to_apid[ppid] = i | PMIC_ARB_APID_VALID;\n\t\t} else if (valid && is_irq_ee &&\n\t\t\t   prev_apidd->write_ee == pmic_arb->ee) {\n\t\t\t \n\t\t\tprev_apidd->irq_ee = apidd->irq_ee;\n\t\t}\n\n\t\tapidd->ppid = ppid;\n\t\tpmic_arb->last_apid = i;\n\t}\n\n\t \n\tdev_dbg(&pmic_arb->spmic->dev, \"PPID APID Write-EE IRQ-EE\\n\");\n\tfor (ppid = 0; ppid < PMIC_ARB_MAX_PPID; ppid++) {\n\t\tapid = pmic_arb->ppid_to_apid[ppid];\n\t\tif (apid & PMIC_ARB_APID_VALID) {\n\t\t\tapid &= ~PMIC_ARB_APID_VALID;\n\t\t\tapidd = &pmic_arb->apid_data[apid];\n\t\t\tdev_dbg(&pmic_arb->spmic->dev, \"%#03X %3u %2u %2u\\n\",\n\t\t\t      ppid, apid, apidd->write_ee, apidd->irq_ee);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pmic_arb_ppid_to_apid_v5(struct spmi_pmic_arb *pmic_arb, u16 ppid)\n{\n\tif (!(pmic_arb->ppid_to_apid[ppid] & PMIC_ARB_APID_VALID))\n\t\treturn -ENODEV;\n\n\treturn pmic_arb->ppid_to_apid[ppid] & ~PMIC_ARB_APID_VALID;\n}\n\n \nstatic int pmic_arb_offset_v2(struct spmi_pmic_arb *pmic_arb, u8 sid, u16 addr,\n\t\t\t   enum pmic_arb_channel ch_type)\n{\n\tu16 apid;\n\tu16 ppid;\n\tint rc;\n\n\tppid = sid << 8 | ((addr >> 8) & 0xFF);\n\trc = pmic_arb_ppid_to_apid_v2(pmic_arb, ppid);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tapid = rc;\n\treturn 0x1000 * pmic_arb->ee + 0x8000 * apid;\n}\n\n \nstatic int pmic_arb_offset_v5(struct spmi_pmic_arb *pmic_arb, u8 sid, u16 addr,\n\t\t\t   enum pmic_arb_channel ch_type)\n{\n\tu16 apid;\n\tint rc;\n\tu32 offset = 0;\n\tu16 ppid = (sid << 8) | (addr >> 8);\n\n\trc = pmic_arb_ppid_to_apid_v5(pmic_arb, ppid);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tapid = rc;\n\tswitch (ch_type) {\n\tcase PMIC_ARB_CHANNEL_OBS:\n\t\toffset = 0x10000 * pmic_arb->ee + 0x80 * apid;\n\t\tbreak;\n\tcase PMIC_ARB_CHANNEL_RW:\n\t\tif (pmic_arb->apid_data[apid].write_ee != pmic_arb->ee) {\n\t\t\tdev_err(&pmic_arb->spmic->dev, \"disallowed SPMI write to sid=%u, addr=0x%04X\\n\",\n\t\t\t\tsid, addr);\n\t\t\treturn -EPERM;\n\t\t}\n\t\toffset = 0x10000 * apid;\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n \nstatic int pmic_arb_offset_v7(struct spmi_pmic_arb *pmic_arb, u8 sid, u16 addr,\n\t\t\t   enum pmic_arb_channel ch_type)\n{\n\tu16 apid;\n\tint rc;\n\tu32 offset = 0;\n\tu16 ppid = (sid << 8) | (addr >> 8);\n\n\trc = pmic_arb->ver_ops->ppid_to_apid(pmic_arb, ppid);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tapid = rc;\n\tswitch (ch_type) {\n\tcase PMIC_ARB_CHANNEL_OBS:\n\t\toffset = 0x8000 * pmic_arb->ee + 0x20 * apid;\n\t\tbreak;\n\tcase PMIC_ARB_CHANNEL_RW:\n\t\tif (pmic_arb->apid_data[apid].write_ee != pmic_arb->ee) {\n\t\t\tdev_err(&pmic_arb->spmic->dev, \"disallowed SPMI write to sid=%u, addr=0x%04X\\n\",\n\t\t\t\tsid, addr);\n\t\t\treturn -EPERM;\n\t\t}\n\t\toffset = 0x1000 * apid;\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\nstatic u32 pmic_arb_fmt_cmd_v1(u8 opc, u8 sid, u16 addr, u8 bc)\n{\n\treturn (opc << 27) | ((sid & 0xf) << 20) | (addr << 4) | (bc & 0x7);\n}\n\nstatic u32 pmic_arb_fmt_cmd_v2(u8 opc, u8 sid, u16 addr, u8 bc)\n{\n\treturn (opc << 27) | ((addr & 0xff) << 4) | (bc & 0x7);\n}\n\nstatic void __iomem *\npmic_arb_owner_acc_status_v1(struct spmi_pmic_arb *pmic_arb, u8 m, u16 n)\n{\n\treturn pmic_arb->intr + 0x20 * m + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_owner_acc_status_v2(struct spmi_pmic_arb *pmic_arb, u8 m, u16 n)\n{\n\treturn pmic_arb->intr + 0x100000 + 0x1000 * m + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_owner_acc_status_v3(struct spmi_pmic_arb *pmic_arb, u8 m, u16 n)\n{\n\treturn pmic_arb->intr + 0x200000 + 0x1000 * m + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_owner_acc_status_v5(struct spmi_pmic_arb *pmic_arb, u8 m, u16 n)\n{\n\treturn pmic_arb->intr + 0x10000 * m + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_owner_acc_status_v7(struct spmi_pmic_arb *pmic_arb, u8 m, u16 n)\n{\n\treturn pmic_arb->intr + 0x1000 * m + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_acc_enable_v1(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->intr + 0x200 + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_acc_enable_v2(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->intr + 0x1000 * n;\n}\n\nstatic void __iomem *\npmic_arb_acc_enable_v5(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->wr_base + 0x100 + 0x10000 * n;\n}\n\nstatic void __iomem *\npmic_arb_acc_enable_v7(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->wr_base + 0x100 + 0x1000 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_status_v1(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->intr + 0x600 + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_status_v2(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->intr + 0x4 + 0x1000 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_status_v5(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->wr_base + 0x104 + 0x10000 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_status_v7(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->wr_base + 0x104 + 0x1000 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_clear_v1(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->intr + 0xA00 + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_clear_v2(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->intr + 0x8 + 0x1000 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_clear_v5(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->wr_base + 0x108 + 0x10000 * n;\n}\n\nstatic void __iomem *\npmic_arb_irq_clear_v7(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->wr_base + 0x108 + 0x1000 * n;\n}\n\nstatic u32 pmic_arb_apid_map_offset_v2(u16 n)\n{\n\treturn 0x800 + 0x4 * n;\n}\n\nstatic u32 pmic_arb_apid_map_offset_v5(u16 n)\n{\n\treturn 0x900 + 0x4 * n;\n}\n\nstatic u32 pmic_arb_apid_map_offset_v7(u16 n)\n{\n\treturn 0x2000 + 0x4 * n;\n}\n\nstatic void __iomem *\npmic_arb_apid_owner_v2(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->cnfg + 0x700 + 0x4 * n;\n}\n\n \nstatic void __iomem *\npmic_arb_apid_owner_v7(struct spmi_pmic_arb *pmic_arb, u16 n)\n{\n\treturn pmic_arb->cnfg + 0x4 * (n - pmic_arb->base_apid);\n}\n\nstatic const struct pmic_arb_ver_ops pmic_arb_v1 = {\n\t.ver_str\t\t= \"v1\",\n\t.ppid_to_apid\t\t= pmic_arb_ppid_to_apid_v1,\n\t.non_data_cmd\t\t= pmic_arb_non_data_cmd_v1,\n\t.offset\t\t\t= pmic_arb_offset_v1,\n\t.fmt_cmd\t\t= pmic_arb_fmt_cmd_v1,\n\t.owner_acc_status\t= pmic_arb_owner_acc_status_v1,\n\t.acc_enable\t\t= pmic_arb_acc_enable_v1,\n\t.irq_status\t\t= pmic_arb_irq_status_v1,\n\t.irq_clear\t\t= pmic_arb_irq_clear_v1,\n\t.apid_map_offset\t= pmic_arb_apid_map_offset_v2,\n\t.apid_owner\t\t= pmic_arb_apid_owner_v2,\n};\n\nstatic const struct pmic_arb_ver_ops pmic_arb_v2 = {\n\t.ver_str\t\t= \"v2\",\n\t.ppid_to_apid\t\t= pmic_arb_ppid_to_apid_v2,\n\t.non_data_cmd\t\t= pmic_arb_non_data_cmd_v2,\n\t.offset\t\t\t= pmic_arb_offset_v2,\n\t.fmt_cmd\t\t= pmic_arb_fmt_cmd_v2,\n\t.owner_acc_status\t= pmic_arb_owner_acc_status_v2,\n\t.acc_enable\t\t= pmic_arb_acc_enable_v2,\n\t.irq_status\t\t= pmic_arb_irq_status_v2,\n\t.irq_clear\t\t= pmic_arb_irq_clear_v2,\n\t.apid_map_offset\t= pmic_arb_apid_map_offset_v2,\n\t.apid_owner\t\t= pmic_arb_apid_owner_v2,\n};\n\nstatic const struct pmic_arb_ver_ops pmic_arb_v3 = {\n\t.ver_str\t\t= \"v3\",\n\t.ppid_to_apid\t\t= pmic_arb_ppid_to_apid_v2,\n\t.non_data_cmd\t\t= pmic_arb_non_data_cmd_v2,\n\t.offset\t\t\t= pmic_arb_offset_v2,\n\t.fmt_cmd\t\t= pmic_arb_fmt_cmd_v2,\n\t.owner_acc_status\t= pmic_arb_owner_acc_status_v3,\n\t.acc_enable\t\t= pmic_arb_acc_enable_v2,\n\t.irq_status\t\t= pmic_arb_irq_status_v2,\n\t.irq_clear\t\t= pmic_arb_irq_clear_v2,\n\t.apid_map_offset\t= pmic_arb_apid_map_offset_v2,\n\t.apid_owner\t\t= pmic_arb_apid_owner_v2,\n};\n\nstatic const struct pmic_arb_ver_ops pmic_arb_v5 = {\n\t.ver_str\t\t= \"v5\",\n\t.ppid_to_apid\t\t= pmic_arb_ppid_to_apid_v5,\n\t.non_data_cmd\t\t= pmic_arb_non_data_cmd_v2,\n\t.offset\t\t\t= pmic_arb_offset_v5,\n\t.fmt_cmd\t\t= pmic_arb_fmt_cmd_v2,\n\t.owner_acc_status\t= pmic_arb_owner_acc_status_v5,\n\t.acc_enable\t\t= pmic_arb_acc_enable_v5,\n\t.irq_status\t\t= pmic_arb_irq_status_v5,\n\t.irq_clear\t\t= pmic_arb_irq_clear_v5,\n\t.apid_map_offset\t= pmic_arb_apid_map_offset_v5,\n\t.apid_owner\t\t= pmic_arb_apid_owner_v2,\n};\n\nstatic const struct pmic_arb_ver_ops pmic_arb_v7 = {\n\t.ver_str\t\t= \"v7\",\n\t.ppid_to_apid\t\t= pmic_arb_ppid_to_apid_v5,\n\t.non_data_cmd\t\t= pmic_arb_non_data_cmd_v2,\n\t.offset\t\t\t= pmic_arb_offset_v7,\n\t.fmt_cmd\t\t= pmic_arb_fmt_cmd_v2,\n\t.owner_acc_status\t= pmic_arb_owner_acc_status_v7,\n\t.acc_enable\t\t= pmic_arb_acc_enable_v7,\n\t.irq_status\t\t= pmic_arb_irq_status_v7,\n\t.irq_clear\t\t= pmic_arb_irq_clear_v7,\n\t.apid_map_offset\t= pmic_arb_apid_map_offset_v7,\n\t.apid_owner\t\t= pmic_arb_apid_owner_v7,\n};\n\nstatic const struct irq_domain_ops pmic_arb_irq_domain_ops = {\n\t.activate = qpnpint_irq_domain_activate,\n\t.alloc = qpnpint_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_common,\n\t.translate = qpnpint_irq_domain_translate,\n};\n\nstatic int spmi_pmic_arb_probe(struct platform_device *pdev)\n{\n\tstruct spmi_pmic_arb *pmic_arb;\n\tstruct spmi_controller *ctrl;\n\tstruct resource *res;\n\tvoid __iomem *core;\n\tu32 *mapping_table;\n\tu32 channel, ee, hw_ver;\n\tint err;\n\n\tctrl = spmi_controller_alloc(&pdev->dev, sizeof(*pmic_arb));\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tpmic_arb = spmi_controller_get_drvdata(ctrl);\n\tpmic_arb->spmic = ctrl;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"core\");\n\tcore = devm_ioremap(&ctrl->dev, res->start, resource_size(res));\n\tif (IS_ERR(core)) {\n\t\terr = PTR_ERR(core);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tpmic_arb->core_size = resource_size(res);\n\n\tpmic_arb->ppid_to_apid = devm_kcalloc(&ctrl->dev, PMIC_ARB_MAX_PPID,\n\t\t\t\t\t      sizeof(*pmic_arb->ppid_to_apid),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!pmic_arb->ppid_to_apid) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put_ctrl;\n\t}\n\n\thw_ver = readl_relaxed(core + PMIC_ARB_VERSION);\n\n\tif (hw_ver < PMIC_ARB_VERSION_V2_MIN) {\n\t\tpmic_arb->ver_ops = &pmic_arb_v1;\n\t\tpmic_arb->wr_base = core;\n\t\tpmic_arb->rd_base = core;\n\t} else {\n\t\tpmic_arb->core = core;\n\n\t\tif (hw_ver < PMIC_ARB_VERSION_V3_MIN)\n\t\t\tpmic_arb->ver_ops = &pmic_arb_v2;\n\t\telse if (hw_ver < PMIC_ARB_VERSION_V5_MIN)\n\t\t\tpmic_arb->ver_ops = &pmic_arb_v3;\n\t\telse if (hw_ver < PMIC_ARB_VERSION_V7_MIN)\n\t\t\tpmic_arb->ver_ops = &pmic_arb_v5;\n\t\telse\n\t\t\tpmic_arb->ver_ops = &pmic_arb_v7;\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"obsrvr\");\n\t\tpmic_arb->rd_base = devm_ioremap(&ctrl->dev, res->start,\n\t\t\t\t\t\t resource_size(res));\n\t\tif (IS_ERR(pmic_arb->rd_base)) {\n\t\t\terr = PTR_ERR(pmic_arb->rd_base);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"chnls\");\n\t\tpmic_arb->wr_base = devm_ioremap(&ctrl->dev, res->start,\n\t\t\t\t\t\t resource_size(res));\n\t\tif (IS_ERR(pmic_arb->wr_base)) {\n\t\t\terr = PTR_ERR(pmic_arb->wr_base);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\t}\n\n\tpmic_arb->max_periphs = PMIC_ARB_MAX_PERIPHS;\n\n\tif (hw_ver >= PMIC_ARB_VERSION_V7_MIN) {\n\t\tpmic_arb->max_periphs = PMIC_ARB_MAX_PERIPHS_V7;\n\t\t \n\t\tof_property_read_u32(pdev->dev.of_node, \"qcom,bus-id\",\n\t\t\t\t\t&pmic_arb->bus_instance);\n\t\tif (pmic_arb->bus_instance > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_err(&pdev->dev, \"invalid bus instance (%u) specified\\n\",\n\t\t\t\tpmic_arb->bus_instance);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\n\t\tif (pmic_arb->bus_instance == 0) {\n\t\t\tpmic_arb->base_apid = 0;\n\t\t\tpmic_arb->apid_count =\n\t\t\t\treadl_relaxed(core + PMIC_ARB_FEATURES) &\n\t\t\t\tPMIC_ARB_FEATURES_PERIPH_MASK;\n\t\t} else {\n\t\t\tpmic_arb->base_apid =\n\t\t\t\treadl_relaxed(core + PMIC_ARB_FEATURES) &\n\t\t\t\tPMIC_ARB_FEATURES_PERIPH_MASK;\n\t\t\tpmic_arb->apid_count =\n\t\t\t\treadl_relaxed(core + PMIC_ARB_FEATURES1) &\n\t\t\t\tPMIC_ARB_FEATURES_PERIPH_MASK;\n\t\t}\n\n\t\tif (pmic_arb->base_apid + pmic_arb->apid_count > pmic_arb->max_periphs) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_err(&pdev->dev, \"Unsupported APID count %d detected\\n\",\n\t\t\t\tpmic_arb->base_apid + pmic_arb->apid_count);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\t} else if (hw_ver >= PMIC_ARB_VERSION_V5_MIN) {\n\t\tpmic_arb->base_apid = 0;\n\t\tpmic_arb->apid_count = readl_relaxed(core + PMIC_ARB_FEATURES) &\n\t\t\t\t\tPMIC_ARB_FEATURES_PERIPH_MASK;\n\n\t\tif (pmic_arb->apid_count > pmic_arb->max_periphs) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_err(&pdev->dev, \"Unsupported APID count %d detected\\n\",\n\t\t\t\tpmic_arb->apid_count);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\t}\n\n\tpmic_arb->apid_data = devm_kcalloc(&ctrl->dev, pmic_arb->max_periphs,\n\t\t\t\t\t   sizeof(*pmic_arb->apid_data),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!pmic_arb->apid_data) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tdev_info(&ctrl->dev, \"PMIC arbiter version %s (0x%x)\\n\",\n\t\t pmic_arb->ver_ops->ver_str, hw_ver);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"intr\");\n\tpmic_arb->intr = devm_ioremap_resource(&ctrl->dev, res);\n\tif (IS_ERR(pmic_arb->intr)) {\n\t\terr = PTR_ERR(pmic_arb->intr);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cnfg\");\n\tpmic_arb->cnfg = devm_ioremap_resource(&ctrl->dev, res);\n\tif (IS_ERR(pmic_arb->cnfg)) {\n\t\terr = PTR_ERR(pmic_arb->cnfg);\n\t\tgoto err_put_ctrl;\n\t}\n\n\tpmic_arb->irq = platform_get_irq_byname(pdev, \"periph_irq\");\n\tif (pmic_arb->irq < 0) {\n\t\terr = pmic_arb->irq;\n\t\tgoto err_put_ctrl;\n\t}\n\n\terr = of_property_read_u32(pdev->dev.of_node, \"qcom,channel\", &channel);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"channel unspecified.\\n\");\n\t\tgoto err_put_ctrl;\n\t}\n\n\tif (channel > 5) {\n\t\tdev_err(&pdev->dev, \"invalid channel (%u) specified.\\n\",\n\t\t\tchannel);\n\t\terr = -EINVAL;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tpmic_arb->channel = channel;\n\n\terr = of_property_read_u32(pdev->dev.of_node, \"qcom,ee\", &ee);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"EE unspecified.\\n\");\n\t\tgoto err_put_ctrl;\n\t}\n\n\tif (ee > 5) {\n\t\tdev_err(&pdev->dev, \"invalid EE (%u) specified\\n\", ee);\n\t\terr = -EINVAL;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tpmic_arb->ee = ee;\n\tmapping_table = devm_kcalloc(&ctrl->dev, pmic_arb->max_periphs,\n\t\t\t\t\tsizeof(*mapping_table), GFP_KERNEL);\n\tif (!mapping_table) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tpmic_arb->mapping_table = mapping_table;\n\t \n\tpmic_arb->max_apid = 0;\n\tpmic_arb->min_apid = pmic_arb->max_periphs - 1;\n\n\tplatform_set_drvdata(pdev, ctrl);\n\traw_spin_lock_init(&pmic_arb->lock);\n\n\tctrl->cmd = pmic_arb_cmd;\n\tctrl->read_cmd = pmic_arb_read_cmd;\n\tctrl->write_cmd = pmic_arb_write_cmd;\n\n\tif (hw_ver >= PMIC_ARB_VERSION_V5_MIN) {\n\t\terr = pmic_arb_read_apid_map_v5(pmic_arb);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"could not read APID->PPID mapping table, rc= %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto err_put_ctrl;\n\t\t}\n\t}\n\n\tdev_dbg(&pdev->dev, \"adding irq domain\\n\");\n\tpmic_arb->domain = irq_domain_add_tree(pdev->dev.of_node,\n\t\t\t\t\t &pmic_arb_irq_domain_ops, pmic_arb);\n\tif (!pmic_arb->domain) {\n\t\tdev_err(&pdev->dev, \"unable to create irq_domain\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_put_ctrl;\n\t}\n\n\tirq_set_chained_handler_and_data(pmic_arb->irq, pmic_arb_chained_irq,\n\t\t\t\t\tpmic_arb);\n\terr = spmi_controller_add(ctrl);\n\tif (err)\n\t\tgoto err_domain_remove;\n\n\treturn 0;\n\nerr_domain_remove:\n\tirq_set_chained_handler_and_data(pmic_arb->irq, NULL, NULL);\n\tirq_domain_remove(pmic_arb->domain);\nerr_put_ctrl:\n\tspmi_controller_put(ctrl);\n\treturn err;\n}\n\nstatic void spmi_pmic_arb_remove(struct platform_device *pdev)\n{\n\tstruct spmi_controller *ctrl = platform_get_drvdata(pdev);\n\tstruct spmi_pmic_arb *pmic_arb = spmi_controller_get_drvdata(ctrl);\n\tspmi_controller_remove(ctrl);\n\tirq_set_chained_handler_and_data(pmic_arb->irq, NULL, NULL);\n\tirq_domain_remove(pmic_arb->domain);\n\tspmi_controller_put(ctrl);\n}\n\nstatic const struct of_device_id spmi_pmic_arb_match_table[] = {\n\t{ .compatible = \"qcom,spmi-pmic-arb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, spmi_pmic_arb_match_table);\n\nstatic struct platform_driver spmi_pmic_arb_driver = {\n\t.probe\t\t= spmi_pmic_arb_probe,\n\t.remove_new\t= spmi_pmic_arb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"spmi_pmic_arb\",\n\t\t.of_match_table = spmi_pmic_arb_match_table,\n\t},\n};\nmodule_platform_driver(spmi_pmic_arb_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:spmi_pmic_arb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}