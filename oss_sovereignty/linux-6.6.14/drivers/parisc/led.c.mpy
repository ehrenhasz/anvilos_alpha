{
  "module_name": "led.c",
  "hash_id": "467346bd09bdf1d9a755d59317349fd044923c2e67c47943b5a6fcb620e61122",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/led.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/utsname.h>\n#include <linux/capability.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/uaccess.h>\n#include <linux/leds.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <asm/hardware.h>\n#include <asm/param.h>\t\t \n#include <asm/led.h>\n#include <asm/pdc.h>\n\n#define LED_HAS_LCD 1\n#define LED_HAS_LED 2\n\nstatic unsigned char led_type;\t\t \nstatic unsigned char lastleds;\t\t \nstatic unsigned char lcd_new_text;\nstatic unsigned char lcd_text[20];\nstatic unsigned char lcd_text_default[20];\nstatic unsigned char lcd_no_led_support;  \n\nstruct lcd_block {\n\tunsigned char command;\t \n\tunsigned char on;\t \n\tunsigned char off;\t \n};\n\n \n \nstruct pdc_chassis_lcd_info_ret_block {\n\tunsigned long model:16;\t\t \n\tunsigned long lcd_width:16;\t \n\tunsigned long lcd_cmd_reg_addr;\t \n\tunsigned long lcd_data_reg_addr;  \n\tunsigned int min_cmd_delay;\t \n\tunsigned char reset_cmd1;\t \n\tunsigned char reset_cmd2;\t \n\tunsigned char act_enable;\t \n\tstruct lcd_block heartbeat;\n\tstruct lcd_block disk_io;\n\tstruct lcd_block lan_rcv;\n\tstruct lcd_block lan_tx;\n\tchar _pad;\n};\n\n\n \n#define KITTYHAWK_LCD_CMD  F_EXTEND(0xf0190000UL)\n#define KITTYHAWK_LCD_DATA (KITTYHAWK_LCD_CMD + 1)\n\n \nstatic struct pdc_chassis_lcd_info_ret_block\nlcd_info __attribute__((aligned(8)))  =\n{\n\t.model =\t\tDISPLAY_MODEL_NONE,\n\t.lcd_width =\t\t16,\n\t.lcd_cmd_reg_addr =\tKITTYHAWK_LCD_CMD,\n\t.lcd_data_reg_addr =\tKITTYHAWK_LCD_DATA,\n\t.min_cmd_delay =\t80,\n\t.reset_cmd1 =\t\t0x80,\n\t.reset_cmd2 =\t\t0xc0,\n};\n\n \n#define LCD_CMD_REG\tlcd_info.lcd_cmd_reg_addr\n#define LCD_DATA_REG\tlcd_info.lcd_data_reg_addr\n#define LED_DATA_REG\tlcd_info.lcd_cmd_reg_addr\t \n\n \nstatic void (*led_func_ptr) (unsigned char);\n\n\nstatic void lcd_print_now(void)\n{\n\tint i;\n\tchar *str = lcd_text;\n\n\tif (lcd_info.model != DISPLAY_MODEL_LCD)\n\t\treturn;\n\n\tif (!lcd_new_text)\n\t\treturn;\n\tlcd_new_text = 0;\n\n\t \n\tgsc_writeb(lcd_info.reset_cmd1, LCD_CMD_REG);\n\tudelay(lcd_info.min_cmd_delay);\n\n\t \n\tfor (i = 0; i < lcd_info.lcd_width; i++) {\n\t\tgsc_writeb(*str ? *str++ : ' ', LCD_DATA_REG);\n\t\tudelay(lcd_info.min_cmd_delay);\n\t}\n}\n\n \nvoid lcd_print(const char *str)\n{\n\t \n\tif (str)\n\t\tstrscpy(lcd_text, str, sizeof(lcd_text));\n\tlcd_new_text = 1;\n\n\t \n\tif (led_type == LED_HAS_LCD)\n\t\tlcd_print_now();\n}\n\n#define\tLED_DATA\t0x01\t \n#define\tLED_STROBE\t0x02\t \n\n \nstatic void led_ASP_driver(unsigned char leds)\n{\n\tint i;\n\n\tleds = ~leds;\n\tfor (i = 0; i < 8; i++) {\n\t\tunsigned char value;\n\t\tvalue = (leds & 0x80) >> 7;\n\t\tgsc_writeb( value,\t\t LED_DATA_REG );\n\t\tgsc_writeb( value | LED_STROBE,\t LED_DATA_REG );\n\t\tleds <<= 1;\n\t}\n}\n\n \nstatic void led_LASI_driver(unsigned char leds)\n{\n\tleds = ~leds;\n\tgsc_writeb( leds, LED_DATA_REG );\n}\n\n \nstatic void led_LCD_driver(unsigned char leds)\n{\n\tstatic const unsigned char mask[4] = {\n\t\tLED_HEARTBEAT, LED_DISK_IO,\n\t\tLED_LAN_RCV, LED_LAN_TX };\n\n\tstatic struct lcd_block * const blockp[4] = {\n\t\t&lcd_info.heartbeat,\n\t\t&lcd_info.disk_io,\n\t\t&lcd_info.lan_rcv,\n\t\t&lcd_info.lan_tx\n\t};\n\tstatic unsigned char latest_leds;\n\tint i;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif ((leds & mask[i]) == (latest_leds & mask[i]))\n\t\t\tcontinue;\n\n\t\tgsc_writeb( blockp[i]->command, LCD_CMD_REG );\n\t\tudelay(lcd_info.min_cmd_delay);\n\n\t\tgsc_writeb( leds & mask[i] ? blockp[i]->on :\n\t\t\t\tblockp[i]->off, LCD_DATA_REG );\n\t\tudelay(lcd_info.min_cmd_delay);\n\t}\n\tlatest_leds = leds;\n\n\tlcd_print_now();\n}\n\n\n \nstatic int lcd_system_halt(struct notifier_block *nb, unsigned long event, void *buf)\n{\n\tconst char *txt;\n\n\tswitch (event) {\n\tcase SYS_RESTART:\ttxt = \"SYSTEM RESTART\";\n\t\t\t\tbreak;\n\tcase SYS_HALT:\t\ttxt = \"SYSTEM HALT\";\n\t\t\t\tbreak;\n\tcase SYS_POWER_OFF:\ttxt = \"SYSTEM POWER OFF\";\n\t\t\t\tbreak;\n\tdefault:\t\treturn NOTIFY_DONE;\n\t}\n\n\tlcd_print(txt);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block lcd_system_halt_notifier = {\n\t.notifier_call = lcd_system_halt,\n};\n\nstatic void set_led(struct led_classdev *led_cdev, enum led_brightness brightness);\n\nstruct hppa_led {\n\tstruct led_classdev\tled_cdev;\n\tunsigned char\t\tled_bit;\n};\n#define to_hppa_led(d) container_of(d, struct hppa_led, led_cdev)\n\ntypedef void (*set_handler)(struct led_classdev *, enum led_brightness);\nstruct led_type {\n\tconst char\t*name;\n\tset_handler\thandler;\n\tconst char\t*default_trigger;\n};\n\n#define NUM_LEDS_PER_BOARD\t8\nstruct hppa_drvdata {\n\tstruct hppa_led\tleds[NUM_LEDS_PER_BOARD];\n};\n\nstatic void set_led(struct led_classdev *led_cdev, enum led_brightness brightness)\n{\n\tstruct hppa_led *p = to_hppa_led(led_cdev);\n\tunsigned char led_bit = p->led_bit;\n\n\tif (brightness == LED_OFF)\n\t\tlastleds &= ~led_bit;\n\telse\n\t\tlastleds |= led_bit;\n\n\tif (led_func_ptr)\n\t\tled_func_ptr(lastleds);\n}\n\n\nstatic int hppa_led_generic_probe(struct platform_device *pdev,\n\t\t\t\t  struct led_type *types)\n{\n\tstruct hppa_drvdata *p;\n\tint i, err;\n\n\tp = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < NUM_LEDS_PER_BOARD; i++) {\n\t\tstruct led_classdev *lp = &p->leds[i].led_cdev;\n\n\t\tp->leds[i].led_bit = BIT(i);\n\t\tlp->name = types[i].name;\n\t\tlp->brightness = LED_FULL;\n\t\tlp->brightness_set = types[i].handler;\n\t\tlp->default_trigger = types[i].default_trigger;\n\t\terr = led_classdev_register(&pdev->dev, lp);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Could not register %s LED\\n\",\n\t\t\t       lp->name);\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tled_classdev_unregister(&p->leds[i].led_cdev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, p);\n\n\treturn 0;\n}\n\nstatic int platform_led_remove(struct platform_device *pdev)\n{\n\tstruct hppa_drvdata *p = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < NUM_LEDS_PER_BOARD; i++)\n\t\tled_classdev_unregister(&p->leds[i].led_cdev);\n\n\treturn 0;\n}\n\nstatic struct led_type mainboard_led_types[NUM_LEDS_PER_BOARD] = {\n\t{\n\t\t.name\t\t= \"platform-lan-tx\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"tx\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-lan-rx\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"rx\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-disk\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"disk-activity\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-heartbeat\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"heartbeat\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-LED4\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"panic\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-LED5\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"panic\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-LED6\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"panic\",\n\t},\n\t{\n\t\t.name\t\t= \"platform-LED7\",\n\t\t.handler\t= set_led,\n\t\t.default_trigger = \"panic\",\n\t},\n};\n\nstatic int platform_led_probe(struct platform_device *pdev)\n{\n\treturn hppa_led_generic_probe(pdev, mainboard_led_types);\n}\n\nMODULE_ALIAS(\"platform:platform-leds\");\n\nstatic struct platform_driver hppa_mainboard_led_driver = {\n\t.probe\t\t= platform_led_probe,\n\t.remove\t\t= platform_led_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"platform-leds\",\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&hppa_mainboard_led_driver,\n};\n\nstatic struct platform_device platform_leds = {\n\t.name = \"platform-leds\",\n};\n\n \nint __init register_led_driver(int model, unsigned long cmd_reg, unsigned long data_reg)\n{\n\tif (led_func_ptr || !data_reg)\n\t\treturn 1;\n\n\t \n\tif (running_on_qemu)\n\t\treturn 1;\n\n\tlcd_info.model = model;\t\t \n\tLCD_CMD_REG = (cmd_reg == LED_CMD_REG_NONE) ? 0 : cmd_reg;\n\n\tswitch (lcd_info.model) {\n\tcase DISPLAY_MODEL_LCD:\n\t\tLCD_DATA_REG = data_reg;\n\t\tpr_info(\"led: LCD display at %#lx and %#lx\\n\",\n\t\t\tLCD_CMD_REG , LCD_DATA_REG);\n\t\tled_func_ptr = led_LCD_driver;\n\t\tif (lcd_no_led_support)\n\t\t\tled_type = LED_HAS_LCD;\n\t\telse\n\t\t\tled_type = LED_HAS_LCD | LED_HAS_LED;\n\t\tbreak;\n\n\tcase DISPLAY_MODEL_LASI:\n\t\tLED_DATA_REG = data_reg;\n\t\tled_func_ptr = led_LASI_driver;\n\t\tpr_info(\"led: LED display at %#lx\\n\", LED_DATA_REG);\n\t\tled_type = LED_HAS_LED;\n\t\tbreak;\n\n\tcase DISPLAY_MODEL_OLD_ASP:\n\t\tLED_DATA_REG = data_reg;\n\t\tled_func_ptr = led_ASP_driver;\n\t\tpr_info(\"led: LED (ASP-style) display at %#lx\\n\",\n\t\t    LED_DATA_REG);\n\t\tled_type = LED_HAS_LED;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"led: Unknown LCD/LED model type %d\\n\", lcd_info.model);\n\t\treturn 1;\n\t}\n\n\tplatform_register_drivers(drivers, ARRAY_SIZE(drivers));\n\n\treturn register_reboot_notifier(&lcd_system_halt_notifier);\n}\n\n \nstatic int __init early_led_init(void)\n{\n\tstruct pdc_chassis_info chassis_info;\n\tint ret;\n\n\tsnprintf(lcd_text_default, sizeof(lcd_text_default),\n\t\t\"Linux %s\", init_utsname()->release);\n\tstrcpy(lcd_text, lcd_text_default);\n\tlcd_new_text = 1;\n\n\t \n\tswitch (CPU_HVERSION) {\n\tcase 0x580:\t\t \n\tcase 0x581:\t\t \n\tcase 0x582:\t\t \n\tcase 0x583:\t\t \n\tcase 0x58B:\t\t \n\t\tpr_info(\"LCD on KittyHawk-Machine found.\\n\");\n\t\tlcd_info.model = DISPLAY_MODEL_LCD;\n\t\t \n\t\tlcd_no_led_support = 1;\n\t\tgoto found;\t \n\t}\n\n\t \n\tchassis_info.actcnt = chassis_info.maxcnt = 0;\n\n\tret = pdc_chassis_info(&chassis_info, &lcd_info, sizeof(lcd_info));\n\tif (ret != PDC_OK) {\nnot_found:\n\t\tlcd_info.model = DISPLAY_MODEL_NONE;\n\t\treturn 1;\n\t}\n\n\t \n\tif (chassis_info.actcnt <= 0 || chassis_info.actcnt != chassis_info.maxcnt)\n\t\tgoto not_found;\n\n\tswitch (lcd_info.model) {\n\tcase DISPLAY_MODEL_LCD:\t\t \n\t\tif (chassis_info.actcnt <\n\t\t\toffsetof(struct pdc_chassis_lcd_info_ret_block, _pad)-1)\n\t\t\tgoto not_found;\n\t\tif (!lcd_info.act_enable) {\n\t\t\t \n\t\t\tgoto not_found;\n\t\t}\n\t\tbreak;\n\n\tcase DISPLAY_MODEL_NONE:\t \n\t\tgoto not_found;\n\n\tcase DISPLAY_MODEL_LASI:\t \n\t\tif (chassis_info.actcnt != 8 && chassis_info.actcnt != 32)\n\t\t\tgoto not_found;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"PDC reported unknown LCD/LED model %d\\n\",\n\t\t       lcd_info.model);\n\t\tgoto not_found;\n\t}\n\nfound:\n\t \n\treturn register_led_driver(lcd_info.model, LCD_CMD_REG, LCD_DATA_REG);\n}\narch_initcall(early_led_init);\n\n \nstatic void __init register_led_regions(void)\n{\n\tswitch (lcd_info.model) {\n\tcase DISPLAY_MODEL_LCD:\n\t\trequest_mem_region((unsigned long)LCD_CMD_REG,  1, \"lcd_cmd\");\n\t\trequest_mem_region((unsigned long)LCD_DATA_REG, 1, \"lcd_data\");\n\t\tbreak;\n\tcase DISPLAY_MODEL_LASI:\n\tcase DISPLAY_MODEL_OLD_ASP:\n\t\trequest_mem_region((unsigned long)LED_DATA_REG, 1, \"led_data\");\n\t\tbreak;\n\t}\n}\n\nstatic int __init startup_leds(void)\n{\n\tif (platform_device_register(&platform_leds))\n                printk(KERN_INFO \"LED: failed to register LEDs\\n\");\n\tregister_led_regions();\n\treturn 0;\n}\ndevice_initcall(startup_leds);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}