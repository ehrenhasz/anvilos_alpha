{
  "module_name": "lasi.c",
  "hash_id": "5c83d5e8b835f99e725479e4d8cc987cd62e26fa7016ae31765eb077a7d7afa9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/lasi.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/types.h>\n#include <linux/reboot.h>\n\n#include <asm/io.h>\n#include <asm/hardware.h>\n#include <asm/led.h>\n\n#include \"gsc.h\"\n\n\n#define LASI_VER\t0xC008\t \n\n#define LASI_IO_CONF\t0x7FFFE\t \n#define LASI_IO_CONF2\t0x7FFFF\t \n\nstatic void lasi_choose_irq(struct parisc_device *dev, void *ctrl)\n{\n\tint irq;\n\n\tswitch (dev->id.sversion) {\n\t\tcase 0x74:\tirq =  7; break;  \n\t\tcase 0x7B:\tirq = 13; break;  \n\t\tcase 0x81:\tirq = 14; break;  \n\t\tcase 0x82:\tirq =  9; break;  \n\t\tcase 0x83:\tirq = 20; break;  \n\t\tcase 0x84:\tirq = 26; break;  \n\t\tcase 0x87:\tirq = 18; break;  \n\t\tcase 0x8A:\tirq =  8; break;  \n\t\tcase 0x8C:\tirq =  5; break;  \n\t\tcase 0x8D:\tirq = (dev->hw_path == 13) ? 16 : 17; break;\n\t\t\t\t\t\t  \n\t\tdefault: \treturn;\t\t  \n\t}\n\n\tgsc_asic_assign_irq(ctrl, irq, &dev->irq);\n}\n\nstatic void __init\nlasi_init_irq(struct gsc_asic *this_lasi)\n{\n\tunsigned long lasi_base = this_lasi->hpa;\n\n\t \n\tgsc_writel(0x00000000, lasi_base+OFFSET_IMR);\n\n\t \n\tgsc_readl(lasi_base+OFFSET_IRR);\n\n\t \n\n\t \n\t \t \n\tif(pdc_add_valid(lasi_base+0x4004) == PDC_OK)\n\t\tgsc_writel(0xFFFFFFFF, lasi_base+0x4004);\t \n\t \t  \n\t \t \n\tgsc_writel(0xFFFFFFFF, lasi_base+0x7000);\t \n\tgsc_writel(0xFFFFFFFF, lasi_base+0x8000);\t \n\tgsc_writel(0xFFFFFFFF, lasi_base+0xA000);\t \n\t\n\t \n\t \n}\n\n\n \n\n#ifndef CONFIG_CHASSIS_LCD_LED\n\n#define lasi_led_init(x)\t \n\n#else\n\nstatic void __init lasi_led_init(unsigned long lasi_hpa)\n{\n\tunsigned long datareg;\n\n\tswitch (CPU_HVERSION) {\n\t  \n\tcase 0x600:\t\t \n\tcase 0x601:\t\t \n\tcase 0x602:\t\t \n\tcase 0x603:\t\t \n\tcase 0x604:\t\t \n\tcase 0x605:\t\t \n\t\tdatareg = lasi_hpa + 0x0000C000;\n\t\tgsc_writeb(0, datareg);\n\t\treturn;    \n\n\t \n\tcase 0x60A:\t\t \n\tcase 0x60B:\t\t \n\tcase 0x60C:\t\t \n\tcase 0x60D:\t\t \n\tcase 0x60E:\t\t \n\t\tdatareg = lasi_hpa - 0x00020000;\n\t\tbreak;\n\n\tdefault:\n\t\tdatareg = lasi_hpa + 0x0000C000;\n\t\tbreak;\n\t}\n\n\tregister_led_driver(DISPLAY_MODEL_LASI, LED_CMD_REG_NONE, datareg);\n}\n#endif\n\n \nstatic int lasi_power_off(struct sys_off_data *data)\n{\n\tstruct gsc_asic *lasi = data->cb_data;\n\n\t \n\tgsc_writel(0x02, lasi->hpa + 0x0000C000);\n\n\t \n\treturn NOTIFY_DONE;\n}\n\nstatic int __init lasi_init_chip(struct parisc_device *dev)\n{\n\tstruct gsc_asic *lasi;\n\tint ret;\n\n\tlasi = kzalloc(sizeof(*lasi), GFP_KERNEL);\n\tif (!lasi)\n\t\treturn -ENOMEM;\n\n\tlasi->name = \"Lasi\";\n\tlasi->hpa = dev->hpa.start;\n\n\t \n\tlasi->version = gsc_readl(lasi->hpa + LASI_VER) & 0xf;\n\tprintk(KERN_INFO \"%s version %d at 0x%lx found.\\n\",\n\t\tlasi->name, lasi->version, lasi->hpa);\n\n\t  \n\tlasi_led_init(lasi->hpa);\n\n\t \n\tlasi_init_irq(lasi);\n\n\t \n\tdev->irq = gsc_alloc_irq(&lasi->gsc_irq);\n\tif (dev->irq < 0) {\n\t\tprintk(KERN_ERR \"%s(): cannot get GSC irq\\n\",\n\t\t\t\t__func__);\n\t\tkfree(lasi);\n\t\treturn -EBUSY;\n\t}\n\n\tlasi->eim = ((u32) lasi->gsc_irq.txn_addr) | lasi->gsc_irq.txn_data;\n\n\tret = request_irq(lasi->gsc_irq.irq, gsc_asic_intr, 0, \"lasi\", lasi);\n\tif (ret < 0) {\n\t\tkfree(lasi);\n\t\treturn ret;\n\t}\n\n\t \n\tgsc_writel(lasi->eim, lasi->hpa + OFFSET_IAR);\n\n\t \n\tret = gsc_common_setup(dev, lasi);\n\tif (ret) {\n\t\tkfree(lasi);\n\t\treturn ret;\n\t}    \n\n\tgsc_fixup_irqs(dev, lasi, lasi_choose_irq);\n\n\t \n\tregister_sys_off_handler(SYS_OFF_MODE_POWER_OFF,\n\t\tSYS_OFF_PRIO_DEFAULT, lasi_power_off, lasi);\n\n\treturn ret;\n}\n\nstatic struct parisc_device_id lasi_tbl[] __initdata = {\n\t{ HPHW_BA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00081 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(parisc, lasi_tbl);\n\nstatic struct parisc_driver lasi_driver __refdata = {\n\t.name =\t\t\"lasi\",\n\t.id_table =\tlasi_tbl,\n\t.probe =\tlasi_init_chip,\n};\n\nstatic int __init lasi_init(void)\n{\n\treturn register_parisc_driver(&lasi_driver);\n}\narch_initcall(lasi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}