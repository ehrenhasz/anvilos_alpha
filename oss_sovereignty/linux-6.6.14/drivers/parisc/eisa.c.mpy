{
  "module_name": "eisa.c",
  "hash_id": "fb50a64cd964c3ca18feab720fda849c151a628cd9fc97ce50a680a86b65ab51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/eisa.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/eisa.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <asm/hardware.h>\n#include <asm/processor.h>\n#include <asm/parisc-device.h>\n#include <asm/delay.h>\n#include <asm/eisa_bus.h>\n#include <asm/eisa_eeprom.h>\n\n#include \"iommu.h\"\n\n#if 0\n#define EISA_DBG(msg, arg...) printk(KERN_DEBUG \"eisa: \" msg, ## arg)\n#else\n#define EISA_DBG(msg, arg...)\n#endif\n\n#define SNAKES_EEPROM_BASE_ADDR 0xF0810400\n#define MIRAGE_EEPROM_BASE_ADDR 0xF00C0400\n\nstatic DEFINE_SPINLOCK(eisa_irq_lock);\n\nvoid __iomem *eisa_eeprom_addr __read_mostly;\n\n \nstatic struct eisa_ba {\n\tstruct pci_hba_data\thba;\n\tunsigned long eeprom_addr;\n\tstruct eisa_root_device root;\n} eisa_dev;\n\n \n\nstatic inline unsigned long eisa_permute(unsigned short port)\n{\n\tif (port & 0x300) {\n\t\treturn 0xfc000000 | ((port & 0xfc00) >> 6)\n\t\t\t| ((port & 0x3f8) << 9) | (port & 7);\n\t} else {\n\t\treturn 0xfc000000 | port;\n\t}\n}\n\nunsigned char eisa_in8(unsigned short port)\n{\n\tif (EISA_bus)\n\t\treturn gsc_readb(eisa_permute(port));\n\treturn 0xff;\n}\n\nunsigned short eisa_in16(unsigned short port)\n{\n\tif (EISA_bus)\n\t\treturn le16_to_cpu(gsc_readw(eisa_permute(port)));\n\treturn 0xffff;\n}\n\nunsigned int eisa_in32(unsigned short port)\n{\n\tif (EISA_bus)\n\t\treturn le32_to_cpu(gsc_readl(eisa_permute(port)));\n\treturn 0xffffffff;\n}\n\nvoid eisa_out8(unsigned char data, unsigned short port)\n{\n\tif (EISA_bus)\n\t\tgsc_writeb(data, eisa_permute(port));\n}\n\nvoid eisa_out16(unsigned short data, unsigned short port)\n{\n\tif (EISA_bus)\n\t\tgsc_writew(cpu_to_le16(data), eisa_permute(port));\n}\n\nvoid eisa_out32(unsigned int data, unsigned short port)\n{\n\tif (EISA_bus)\n\t\tgsc_writel(cpu_to_le32(data), eisa_permute(port));\n}\n\n#ifndef CONFIG_PCI\n \nEXPORT_SYMBOL(eisa_in8);\nEXPORT_SYMBOL(eisa_in16);\nEXPORT_SYMBOL(eisa_in32);\nEXPORT_SYMBOL(eisa_out8);\nEXPORT_SYMBOL(eisa_out16);\nEXPORT_SYMBOL(eisa_out32);\n#endif\n\n \n\n \nstatic int master_mask;\nstatic int slave_mask;\n\n \n \nstatic unsigned int eisa_irq_level __read_mostly;  \n\n\n \nstatic void eisa_mask_irq(struct irq_data *d)\n{\n\tunsigned int irq = d->irq;\n\tunsigned long flags;\n\n\tEISA_DBG(\"disable irq %d\\n\", irq);\n\t \n\tspin_lock_irqsave(&eisa_irq_lock, flags);\n        if (irq & 8) {\n\t\tslave_mask |= (1 << (irq&7));\n\t\teisa_out8(slave_mask, 0xa1);\n\t} else {\n\t\tmaster_mask |= (1 << (irq&7));\n\t\teisa_out8(master_mask, 0x21);\n\t}\n\tspin_unlock_irqrestore(&eisa_irq_lock, flags);\n\tEISA_DBG(\"pic0 mask %02x\\n\", eisa_in8(0x21));\n\tEISA_DBG(\"pic1 mask %02x\\n\", eisa_in8(0xa1));\n}\n\n \nstatic void eisa_unmask_irq(struct irq_data *d)\n{\n\tunsigned int irq = d->irq;\n\tunsigned long flags;\n\tEISA_DBG(\"enable irq %d\\n\", irq);\n\n\tspin_lock_irqsave(&eisa_irq_lock, flags);\n        if (irq & 8) {\n\t\tslave_mask &= ~(1 << (irq&7));\n\t\teisa_out8(slave_mask, 0xa1);\n\t} else {\n\t\tmaster_mask &= ~(1 << (irq&7));\n\t\teisa_out8(master_mask, 0x21);\n\t}\n\tspin_unlock_irqrestore(&eisa_irq_lock, flags);\n\tEISA_DBG(\"pic0 mask %02x\\n\", eisa_in8(0x21));\n\tEISA_DBG(\"pic1 mask %02x\\n\", eisa_in8(0xa1));\n}\n\nstatic struct irq_chip eisa_interrupt_type = {\n\t.name\t\t=\t\"EISA\",\n\t.irq_unmask\t=\teisa_unmask_irq,\n\t.irq_mask\t=\teisa_mask_irq,\n};\n\nstatic irqreturn_t eisa_irq(int wax_irq, void *intr_dev)\n{\n\tint irq = gsc_readb(0xfc01f000);  \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&eisa_irq_lock, flags);\n\t \n\teisa_out8(0x0a, 0x20);\n\teisa_out8(0x0a, 0xa0);\n\n\tEISA_DBG(\"irq IAR %02x 8259-1 irr %02x 8259-2 irr %02x\\n\",\n\t\t   irq, eisa_in8(0x20), eisa_in8(0xa0));\n\n\t \n\teisa_out8(0x0a, 0x20);\n\teisa_out8(0x0a, 0xa0);\n\tEISA_DBG(\"irq 8259-1 isr %02x imr %02x 8259-2 isr %02x imr %02x\\n\",\n\t\t eisa_in8(0x20), eisa_in8(0x21), eisa_in8(0xa0), eisa_in8(0xa1));\n\n\tirq &= 0xf;\n\n\t \n\tif (irq & 8) {\n\t\tslave_mask |= (1 << (irq&7));\n\t\teisa_out8(slave_mask, 0xa1);\n\t\teisa_out8(0x60 | (irq&7),0xa0); \n\t\teisa_out8(0x62, 0x20);\t \n\n\t} else {\n\t\tmaster_mask |= (1 << (irq&7));\n\t\teisa_out8(master_mask, 0x21);\n\t\teisa_out8(0x60|irq, 0x20);\t \n\t}\n\tspin_unlock_irqrestore(&eisa_irq_lock, flags);\n\n\tgeneric_handle_irq(irq);\n\n\tspin_lock_irqsave(&eisa_irq_lock, flags);\n\t \n        if (irq & 8) {\n\t\tslave_mask &= ~(1 << (irq&7));\n\t\teisa_out8(slave_mask, 0xa1);\n\t} else {\n\t\tmaster_mask &= ~(1 << (irq&7));\n\t\teisa_out8(master_mask, 0x21);\n\t}\n\tspin_unlock_irqrestore(&eisa_irq_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dummy_irq2_handler(int _, void *dev)\n{\n\tprintk(KERN_ALERT \"eisa: uhh, irq2?\\n\");\n\treturn IRQ_HANDLED;\n}\n\nstatic void init_eisa_pic(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&eisa_irq_lock, flags);\n\n\teisa_out8(0xff, 0x21);  \n\teisa_out8(0xff, 0xa1);  \n\n\t \n\teisa_out8(0x11, 0x20);  \n\teisa_out8(0x00, 0x21);  \n\teisa_out8(0x04, 0x21);  \n\teisa_out8(0x01, 0x21);  \n\teisa_out8(0x40, 0x20);  \n\n\t \n\teisa_out8(0x11, 0xa0);  \n\teisa_out8(0x08, 0xa1);  \n\teisa_out8(0x02, 0xa1);  \n\teisa_out8(0x01, 0xa1);  \n\teisa_out8(0x40, 0xa0);  \n\n\tudelay(100);\n\n\tslave_mask = 0xff;\n\tmaster_mask = 0xfb;\n\teisa_out8(slave_mask, 0xa1);  \n\teisa_out8(master_mask, 0x21);  \n\n\t \n\tEISA_DBG(\"EISA edge/level %04x\\n\", eisa_irq_level);\n\n\teisa_out8(eisa_irq_level&0xff, 0x4d0);  \n\teisa_out8((eisa_irq_level >> 8) & 0xff, 0x4d1);\n\n\tEISA_DBG(\"pic0 mask %02x\\n\", eisa_in8(0x21));\n\tEISA_DBG(\"pic1 mask %02x\\n\", eisa_in8(0xa1));\n\tEISA_DBG(\"pic0 edge/level %02x\\n\", eisa_in8(0x4d0));\n\tEISA_DBG(\"pic1 edge/level %02x\\n\", eisa_in8(0x4d1));\n\n\tspin_unlock_irqrestore(&eisa_irq_lock, flags);\n}\n\n \n\n#define is_mongoose(dev) (dev->id.sversion == 0x00076)\n\nstatic int __init eisa_probe(struct parisc_device *dev)\n{\n\tint i, result;\n\n\tchar *name = is_mongoose(dev) ? \"Mongoose\" : \"Wax\";\n\n\tprintk(KERN_INFO \"%s EISA Adapter found at 0x%08lx\\n\",\n\t\tname, (unsigned long)dev->hpa.start);\n\n\teisa_dev.hba.dev = dev;\n\teisa_dev.hba.iommu = ccio_get_iommu(dev);\n\n\teisa_dev.hba.lmmio_space.name = \"EISA\";\n\teisa_dev.hba.lmmio_space.start = F_EXTEND(0xfc000000);\n\teisa_dev.hba.lmmio_space.end = F_EXTEND(0xffbfffff);\n\teisa_dev.hba.lmmio_space.flags = IORESOURCE_MEM;\n\tresult = ccio_request_resource(dev, &eisa_dev.hba.lmmio_space);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"EISA: failed to claim EISA Bus address space!\\n\");\n\t\treturn result;\n\t}\n\teisa_dev.hba.io_space.name = \"EISA\";\n\teisa_dev.hba.io_space.start = 0;\n\teisa_dev.hba.io_space.end = 0xffff;\n\teisa_dev.hba.lmmio_space.flags = IORESOURCE_IO;\n\tresult = request_resource(&ioport_resource, &eisa_dev.hba.io_space);\n\tif (result < 0) {\n\t\tprintk(KERN_ERR \"EISA: failed to claim EISA Bus port space!\\n\");\n\t\treturn result;\n\t}\n\tpcibios_register_hba(&eisa_dev.hba);\n\n\tresult = request_irq(dev->irq, eisa_irq, IRQF_SHARED, \"EISA\", &eisa_dev);\n\tif (result) {\n\t\tprintk(KERN_ERR \"EISA: request_irq failed!\\n\");\n\t\tgoto error_release;\n\t}\n\n\t \n\tif (request_irq(2, dummy_irq2_handler, 0, \"cascade\", NULL))\n\t\tpr_err(\"Failed to request irq 2 (cascade)\\n\");\n\tfor (i = 0; i < 16; i++) {\n\t\tirq_set_chip_and_handler(i, &eisa_interrupt_type,\n\t\t\t\t\t handle_simple_irq);\n\t}\n\n\tEISA_bus = 1;\n\n\tif (dev->num_addrs) {\n\t\t \n\t\teisa_dev.eeprom_addr = dev->addr[0];\n\t} else {\n\t\t \n\t\tif (is_mongoose(dev)) {\n\t\t\teisa_dev.eeprom_addr = SNAKES_EEPROM_BASE_ADDR;\n\t\t} else {\n\t\t\teisa_dev.eeprom_addr = MIRAGE_EEPROM_BASE_ADDR;\n\t\t}\n\t}\n\teisa_eeprom_addr = ioremap(eisa_dev.eeprom_addr, HPEE_MAX_LENGTH);\n\tif (!eisa_eeprom_addr) {\n\t\tresult = -ENOMEM;\n\t\tprintk(KERN_ERR \"EISA: ioremap failed!\\n\");\n\t\tgoto error_free_irq;\n\t}\n\tresult = eisa_enumerator(eisa_dev.eeprom_addr, &eisa_dev.hba.io_space,\n\t\t\t&eisa_dev.hba.lmmio_space);\n\tinit_eisa_pic();\n\n\tif (result >= 0) {\n\t\t \n\t\teisa_dev.root.dev = &dev->dev;\n\t\tdev_set_drvdata(&dev->dev, &eisa_dev.root);\n\t\teisa_dev.root.bus_base_addr = 0;\n\t\teisa_dev.root.res = &eisa_dev.hba.io_space;\n\t\teisa_dev.root.slots = result;\n\t\teisa_dev.root.dma_mask = 0xffffffff;  \n\t\tif (eisa_root_register (&eisa_dev.root)) {\n\t\t\tprintk(KERN_ERR \"EISA: Failed to register EISA root\\n\");\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto error_iounmap;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_iounmap:\n\tiounmap(eisa_eeprom_addr);\nerror_free_irq:\n\tfree_irq(dev->irq, &eisa_dev);\nerror_release:\n\trelease_resource(&eisa_dev.hba.io_space);\n\treturn result;\n}\n\nstatic const struct parisc_device_id eisa_tbl[] __initconst = {\n\t{ HPHW_BA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00076 },  \n\t{ HPHW_BA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x00090 },  \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, eisa_tbl);\n\nstatic struct parisc_driver eisa_driver __refdata = {\n\t.name =\t\t\"eisa_ba\",\n\t.id_table =\teisa_tbl,\n\t.probe =\teisa_probe,\n};\n\nstatic int __init parisc_eisa_init(void)\n{\n\treturn register_parisc_driver(&eisa_driver);\n}\narch_initcall(parisc_eisa_init);\n\n\nstatic unsigned int eisa_irq_configured;\nvoid eisa_make_irq_level(int num)\n{\n\tif (eisa_irq_configured& (1<<num)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"IRQ %d polarity configured twice (last to level)\\n\",\n\t\t       num);\n\t}\n\teisa_irq_level |= (1<<num);  \n\teisa_irq_configured |= (1<<num);  \n}\n\nvoid eisa_make_irq_edge(int num)\n{\n\tif (eisa_irq_configured& (1<<num)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"IRQ %d polarity configured twice (last to edge)\\n\",\n\t\t       num);\n\t}\n\teisa_irq_level &= ~(1<<num);  \n\teisa_irq_configured |= (1<<num);  \n}\n\nstatic int __init eisa_irq_setup(char *str)\n{\n\tchar *cur = str;\n\tint val;\n\n\tEISA_DBG(\"IRQ setup\\n\");\n\twhile (cur != NULL) {\n\t\tchar *pe;\n\n\t\tval = (int) simple_strtoul(cur, &pe, 0);\n\t\tif (val > 15 || val < 0) {\n\t\t\tprintk(KERN_ERR \"eisa: EISA irq value are 0-15\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (val == 2) {\n\t\t\tval = 9;\n\t\t}\n\t\teisa_make_irq_edge(val);  \n\t\tEISA_DBG(\"setting IRQ %d to edge-triggered mode\\n\", val);\n\n\t\tif ((cur = strchr(cur, ','))) {\n\t\t\tcur++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"eisa_irq_edge=\", eisa_irq_setup);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}