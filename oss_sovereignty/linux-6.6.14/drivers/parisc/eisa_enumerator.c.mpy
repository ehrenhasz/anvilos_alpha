{
  "module_name": "eisa_enumerator.c",
  "hash_id": "62c7e53cfbf64e39de3aec68a2e03edb2d425afb48181df818ce455aabc345a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/eisa_enumerator.c",
  "human_readable_source": "\n \n\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n#include <asm/eisa_bus.h>\n#include <asm/eisa_eeprom.h>\n\n\n \n\n#define EPI 0xc80\n#define NUM_SLOT 16\n#define SLOT2PORT(x) (x<<12)\n\n\n \n#define get_8(x) (*(u_int8_t*)(x))\n\nstatic inline u_int16_t get_16(const unsigned char *x)\n{ \n\treturn (x[1] << 8) | x[0];\n}\n\nstatic inline u_int32_t get_32(const unsigned char *x)\n{\n\treturn (x[3] << 24) | (x[2] << 16) | (x[1] << 8) | x[0];\n}\n\nstatic inline u_int32_t get_24(const unsigned char *x)\n{\n\treturn (x[2] << 24) | (x[1] << 16) | (x[0] << 8);\n}\n\nstatic void print_eisa_id(char *s, u_int32_t id)\n{\n\tchar vendor[4];\n\tint rev;\n\tint device;\n\t\n\trev = id & 0xff;\n\tid >>= 8;\n\tdevice = id & 0xff;\n\tid >>= 8;\n\tvendor[3] = '\\0';\n\tvendor[2] = '@' + (id & 0x1f);\n\tid >>= 5;\t\n\tvendor[1] = '@' + (id & 0x1f);\n\tid >>= 5;\t\n\tvendor[0] = '@' + (id & 0x1f);\n\tid >>= 5;\t\n\t\n\tsprintf(s, \"%s%02X%02X\", vendor, device, rev);\n}\n       \nstatic int configure_memory(const unsigned char *buf, \n\t\t       struct resource *mem_parent,\n\t\t       char *name)\n{\n\tint len;\n\tu_int8_t c;\n\tint i;\n\tstruct resource *res;\n\t\n\tlen=0;\n\t\n\tfor (i=0;i<HPEE_MEMORY_MAX_ENT;i++) {\n\t\tc = get_8(buf+len);\n\t\t\n\t\tif (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {\n\t\t\tint result;\n\t\t\t\n\t\t\tres->name = name;\n\t\t\tres->start = mem_parent->start + get_24(buf+len+2);\n\t\t\tres->end = res->start + get_16(buf+len+5)*1024;\n\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\tpr_cont(\"memory %pR \", res);\n\t\t\tresult = request_resource(mem_parent, res);\n\t\t\tif (result < 0) {\n\t\t\t\tprintk(KERN_ERR \"EISA Enumerator: failed to claim EISA Bus address space!\\n\");\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t \t\n\t\tlen+=7;      \n\t\n\t\tif (!(c & HPEE_MEMORY_MORE)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn len;\n}\n\n\nstatic int configure_irq(const unsigned char *buf)\n{\n\tint len;\n\tu_int8_t c;\n\tint i;\n\t\n\tlen=0;\n\t\n\tfor (i=0;i<HPEE_IRQ_MAX_ENT;i++) {\n\t\tc = get_8(buf+len);\n\t\t\n\t\tpr_cont(\"IRQ %d \", c & HPEE_IRQ_CHANNEL_MASK);\n\t\tif (c & HPEE_IRQ_TRIG_LEVEL) {\n\t\t\teisa_make_irq_level(c & HPEE_IRQ_CHANNEL_MASK);\n\t\t} else {\n\t\t\teisa_make_irq_edge(c & HPEE_IRQ_CHANNEL_MASK);\n\t\t}\n\t\t\n\t\tlen+=2; \n\t\t \n\t\tif  (!(c & HPEE_IRQ_MORE)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn len;\n}\n\n\nstatic int configure_dma(const unsigned char *buf)\n{\n\tint len;\n\tu_int8_t c;\n\tint i;\n\t\n\tlen=0;\n\t\n\tfor (i=0;i<HPEE_DMA_MAX_ENT;i++) {\n\t\tc = get_8(buf+len);\n\t\tpr_cont(\"DMA %d \", c&HPEE_DMA_CHANNEL_MASK);\n\t\t \n\t\tlen+=2;      \n\t\tif (!(c & HPEE_DMA_MORE)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn len;\n}\n\nstatic int configure_port(const unsigned char *buf, struct resource *io_parent,\n\t\t     char *board)\n{\n\tint len;\n\tu_int8_t c;\n\tint i;\n\tstruct resource *res;\n\tint result;\n\t\n\tlen=0;\n\t\n\tfor (i=0;i<HPEE_PORT_MAX_ENT;i++) {\n\t\tc = get_8(buf+len);\n\t\t\n\t\tif (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {\n\t\t\tres->name = board;\n\t\t\tres->start = get_16(buf+len+1);\n\t\t\tres->end = get_16(buf+len+1)+(c&HPEE_PORT_SIZE_MASK)+1;\n\t\t\tres->flags = IORESOURCE_IO;\n\t\t\tpr_cont(\"ioports %pR \", res);\n\t\t\tresult = request_resource(io_parent, res);\n\t\t\tif (result < 0) {\n\t\t\t\tprintk(KERN_ERR \"EISA Enumerator: failed to claim EISA Bus address space!\\n\");\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tlen+=3;      \n\t\tif (!(c & HPEE_PORT_MORE)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn len;\n}\n\n\n \nstatic int configure_port_init(const unsigned char *buf)\n{\n\tint len=0;\n\tu_int8_t c;\n\t\n\twhile (len<HPEE_PORT_INIT_MAX_LEN) {\n\t\tint s=0;\n\t\tc = get_8(buf+len);\n\t\t\n\t\tswitch (c & HPEE_PORT_INIT_WIDTH_MASK)  {\n\t\t case HPEE_PORT_INIT_WIDTH_BYTE:\n\t\t\ts=1;\n\t\t\tif (c & HPEE_PORT_INIT_MASK) {\n\t\t\t\tprintk(KERN_WARNING \"port_init: unverified mask attribute\\n\");\n\t\t\t\toutb((inb(get_16(buf+len+1) & \n\t\t\t\t\t  get_8(buf+len+3)) | \n\t\t\t\t      get_8(buf+len+4)), get_16(buf+len+1));\n\t\t\t\t      \n\t\t\t} else {\n\t\t\t\toutb(get_8(buf+len+3), get_16(buf+len+1));\n\t\t\t\t      \n\t\t\t}\n\t\t\tbreak;\n\t\t case HPEE_PORT_INIT_WIDTH_WORD:\n\t\t\ts=2;\n\t\t\tif (c & HPEE_PORT_INIT_MASK) {\n \t\t\t\tprintk(KERN_WARNING \"port_init: unverified mask attribute\\n\");\n\t\t\t\t       outw((inw(get_16(buf+len+1)) &\n\t\t\t\t\t     get_16(buf+len+3)) |\n\t\t\t\t\t    get_16(buf+len+5), \n\t\t\t\t\t    get_16(buf+len+1));\n\t\t\t} else {\n\t\t\t\toutw(cpu_to_le16(get_16(buf+len+3)), get_16(buf+len+1));\n\t\t\t}\n\t\t\tbreak;\n\t\t case HPEE_PORT_INIT_WIDTH_DWORD:\n\t\t\ts=4;\n\t\t\tif (c & HPEE_PORT_INIT_MASK) {\n \t\t\t\tprintk(KERN_WARNING \"port_init: unverified mask attribute\\n\");\n\t\t\t\toutl((inl(get_16(buf+len+1) &\n\t\t\t\t\t  get_32(buf+len+3)) |\n\t\t\t\t      get_32(buf+len+7)), get_16(buf+len+1));\n\t\t\t} else {\n\t\t\t\toutl(cpu_to_le32(get_32(buf+len+3)), get_16(buf+len+1));\n\t\t\t}\n\n\t\t\tbreak;\n\t\t default:\n\t\t\tprintk(KERN_ERR \"Invalid port init word %02x\\n\", c);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (c & HPEE_PORT_INIT_MASK) {   \n\t\t\ts*=2;\n\t\t}\n\t\t\n\t\tlen+=s+3;\n\t\tif (!(c & HPEE_PORT_INIT_MORE)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn len;\n}\n\nstatic int configure_choise(const unsigned char *buf, u_int8_t *info)\n{\n\tint len;\n\t\n\t \n\tlen = get_8(buf);\n\t*info=get_8(buf+len+1);\n\t \n\treturn len+2;\n}\n\nstatic int configure_type_string(const unsigned char *buf) \n{\n\tint len;\n\t\n\t \n\tlen = get_8(buf);\n\tif (len > 80) {\n\t\tprintk(KERN_ERR \"eisa_enumerator: type info field too long (%d, max is 80)\\n\", len);\n\t}\n\t\n\treturn 1+len;\n}\n\nstatic int configure_function(const unsigned char *buf, int *more) \n{\n\t \n\t*more = get_16(buf);\n\t\n\treturn 2;\n}\n\nstatic int parse_slot_config(int slot,\n\t\t\t     const unsigned char *buf,\n\t\t\t     struct eeprom_eisa_slot_info *es, \n\t\t\t     struct resource *io_parent,\n\t\t\t     struct resource *mem_parent)\n{\n\tint res=0;\n\tint function_len;\n\tunsigned int pos=0;\n\tunsigned int maxlen;\n\tint num_func=0;\n\tu_int8_t flags;\n\tint p0;\n\t\n\tchar *board;\n\tint id_string_used=0;\n\t\n\tif (NULL == (board = kmalloc(8, GFP_KERNEL))) {\n\t\treturn -1;\n\t}\n\tprint_eisa_id(board, es->eisa_slot_id);\n\tprintk(KERN_INFO \"EISA slot %d: %s %s \", \n\t       slot, board, es->flags&HPEE_FLAG_BOARD_IS_ISA ? \"ISA\" : \"EISA\");\n\t\n\tmaxlen = es->config_data_length < HPEE_MAX_LENGTH ?\n\t\t\t es->config_data_length : HPEE_MAX_LENGTH;\n\twhile ((pos < maxlen) && (num_func <= es->num_functions)) {\n\t\tpos+=configure_function(buf+pos, &function_len); \n\t\t\n\t\tif (!function_len) {\n\t\t\tbreak;\n\t\t}\n\t\tnum_func++;\n\t\tp0 = pos;\n\t\tpos += configure_choise(buf+pos, &flags);\n\n\t\tif (flags & HPEE_FUNCTION_INFO_F_DISABLED) {\n\t\t\t \n\t\t\tpos = p0 + function_len;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & HPEE_FUNCTION_INFO_CFG_FREE_FORM) {\n\t\t\t \n\t\t\tprintk(\"function %d have free-form configuration, skipping \",\n\t\t\t\tnum_func);\n\t\t\tpos = p0 + function_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tif (flags & HPEE_FUNCTION_INFO_HAVE_TYPE) {\n\t\t\tpos += configure_type_string(buf+pos);\n\t\t}\n\t\t\n\t\tif (flags & HPEE_FUNCTION_INFO_HAVE_MEMORY) {\n\t\t\tid_string_used=1;\n\t\t\tpos += configure_memory(buf+pos, mem_parent, board);\n\t\t} \n\t\t\n\t\tif (flags & HPEE_FUNCTION_INFO_HAVE_IRQ) {\n\t\t\tpos += configure_irq(buf+pos);\n\t\t} \n\t\t\n\t\tif (flags & HPEE_FUNCTION_INFO_HAVE_DMA) {\n\t\t\tpos += configure_dma(buf+pos);\n\t\t} \n\t\t\n\t\tif (flags & HPEE_FUNCTION_INFO_HAVE_PORT) {\n\t\t\tid_string_used=1;\n\t\t\tpos += configure_port(buf+pos, io_parent, board);\n\t\t} \n\t\t\n\t\tif (flags &  HPEE_FUNCTION_INFO_HAVE_PORT_INIT) {\n\t\t\tpos += configure_port_init(buf+pos);\n\t\t}\n\t\t\n\t\tif (p0 + function_len < pos) {\n\t\t\tprintk(KERN_ERR \"eisa_enumerator: function %d length mismatch \"\n\t\t\t       \"got %d, expected %d\\n\",\n\t\t\t       num_func, pos-p0, function_len);\n\t\t\tres=-1;\n\t\t\tbreak;\n\t\t}\n\t\tpos = p0 + function_len;\n\t}\n\tpr_cont(\"\\n\");\n\tif (!id_string_used) {\n\t\tkfree(board);\n\t}\n\t\n\tif (pos != es->config_data_length) {\n\t\tprintk(KERN_ERR \"eisa_enumerator: config data length mismatch got %d, expected %d\\n\",\n\t\t\tpos, es->config_data_length);\n\t\tres=-1;\n\t}\n\t\n\tif (num_func != es->num_functions) {\n\t\tprintk(KERN_ERR \"eisa_enumerator: number of functions mismatch got %d, expected %d\\n\",\n\t\t\tnum_func, es->num_functions);\n\t\tres=-2;\n\t}\n\t\n\treturn res;\n\t\n}\n\nstatic int init_slot(int slot, struct eeprom_eisa_slot_info *es)\n{\n\tunsigned int id;\n\t\n\tchar id_string[8];\n\t\n\tif (!(es->slot_info&HPEE_SLOT_INFO_NO_READID)) {\n\t\t \n\t\tid = le32_to_cpu(inl(SLOT2PORT(slot)+EPI));\n\t\t\n\t\tif (0xffffffff == id) {\n\t\t\t \n\t\t\tif (es->eisa_slot_id == 0xffffffff)\n\t\t\t\treturn -1;\n\t\t\t\n\t\t\t \n\t\t\tprintk(KERN_ERR \"EISA slot %d a configured board was not detected (\", \n\t\t\t       slot);\n\t\t\t\n\t\t\tprint_eisa_id(id_string, es->eisa_slot_id);\n\t\t\tprintk(\" expected %s)\\n\", id_string);\n\t\t\n\t\t\treturn -1;\t\n\n\t\t}\n\t\tif (es->eisa_slot_id != id) {\n\t\t\tprint_eisa_id(id_string, id);\n\t\t\tprintk(KERN_ERR \"EISA slot %d id mismatch: got %s\",\n\t\t\t       slot, id_string);\n\t\t\t\n\t\t\tprint_eisa_id(id_string, es->eisa_slot_id);\n\t\t\tprintk(\" expected %s\\n\", id_string);\n\t\t\n\t\t\treturn -1;\t\n\t\t\t\n\t\t}\n\t}\n\t\n\t \n\tif (es->slot_features & HPEE_SLOT_FEATURES_ENABLE) {\n\t\t \n\t\toutb(0x01| inb(SLOT2PORT(slot)+EPI+4),\n\t\t     SLOT2PORT(slot)+EPI+4);\n\t}\n\t\n\treturn 0;\n}\n\n\nint eisa_enumerator(unsigned long eeprom_addr,\n\t\t    struct resource *io_parent, struct resource *mem_parent) \n{\n\tint i;\n\tstruct eeprom_header *eh;\n\tstatic char eeprom_buf[HPEE_MAX_LENGTH];\n\t\n\tfor (i=0; i < HPEE_MAX_LENGTH; i++) {\n\t\teeprom_buf[i] = gsc_readb(eeprom_addr+i);\n\t}\n\t\n\tprintk(KERN_INFO \"Enumerating EISA bus\\n\");\n\t\t    \t\n\teh = (struct eeprom_header*)(eeprom_buf);\n\tfor (i=0;i<eh->num_slots;i++) {\n\t\tstruct eeprom_eisa_slot_info *es;\n\t\t\n\t\tes = (struct eeprom_eisa_slot_info*)\n\t\t\t(&eeprom_buf[HPEE_SLOT_INFO(i)]);\n\t        \n\t\tif (-1==init_slot(i+1, es)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (es->config_data_offset < HPEE_MAX_LENGTH) {\n\t\t\tif (parse_slot_config(i+1, &eeprom_buf[es->config_data_offset],\n\t\t\t\t\t      es, io_parent, mem_parent)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintk (KERN_WARNING \"EISA EEPROM offset 0x%x out of range\\n\",es->config_data_offset);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn eh->num_slots;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}