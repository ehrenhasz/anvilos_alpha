{
  "module_name": "dino.c",
  "hash_id": "effcc7966b8bde1745ee36f454eda162a369550577761726acf660197269d91d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/dino.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\t \n#include <linux/spinlock.h>\t \n\n#include <asm/pdc.h>\n#include <asm/page.h>\n#include <asm/io.h>\n#include <asm/hardware.h>\n\n#include \"gsc.h\"\n#include \"iommu.h\"\n\n#undef DINO_DEBUG\n\n#ifdef DINO_DEBUG\n#define DBG(x...) printk(x)\n#else\n#define DBG(x...)\n#endif\n\n \n\n#define is_card_dino(id)\t((id)->hw_type == HPHW_A_DMA)\n#define is_cujo(id)\t\t((id)->hversion == 0x682)\n\n#define DINO_IAR0\t\t0x004\n#define DINO_IODC_ADDR\t\t0x008\n#define DINO_IODC_DATA_0\t0x008\n#define DINO_IODC_DATA_1\t0x008\n#define DINO_IRR0\t\t0x00C\n#define DINO_IAR1\t\t0x010\n#define DINO_IRR1\t\t0x014\n#define DINO_IMR\t\t0x018\n#define DINO_IPR\t\t0x01C\n#define DINO_TOC_ADDR\t\t0x020\n#define DINO_ICR\t\t0x024\n#define DINO_ILR\t\t0x028\n#define DINO_IO_COMMAND\t\t0x030\n#define DINO_IO_STATUS\t\t0x034\n#define DINO_IO_CONTROL\t\t0x038\n#define DINO_IO_GSC_ERR_RESP\t0x040\n#define DINO_IO_ERR_INFO\t0x044\n#define DINO_IO_PCI_ERR_RESP\t0x048\n#define DINO_IO_FBB_EN\t\t0x05c\n#define DINO_IO_ADDR_EN\t\t0x060\n#define DINO_PCI_ADDR\t\t0x064\n#define DINO_CONFIG_DATA\t0x068\n#define DINO_IO_DATA\t\t0x06c\n#define DINO_MEM_DATA\t\t0x070\t \n#define DINO_GSC2X_CONFIG\t0x7b4\n#define DINO_GMASK\t\t0x800\n#define DINO_PAMR\t\t0x804\n#define DINO_PAPR\t\t0x808\n#define DINO_DAMODE\t\t0x80c\n#define DINO_PCICMD\t\t0x810\n#define DINO_PCISTS\t\t0x814\n#define DINO_MLTIM\t\t0x81c\n#define DINO_BRDG_FEAT\t\t0x820\n#define DINO_PCIROR\t\t0x824\n#define DINO_PCIWOR\t\t0x828\n#define DINO_TLTIM\t\t0x830\n\n#define DINO_IRQS 11\t\t \n#define DINO_IRR_MASK\t0x5ff\t \n#define DINO_LOCAL_IRQS (DINO_IRQS+1)\n\n#define DINO_MASK_IRQ(x)\t(1<<(x))\n\n#define PCIINTA   0x001\n#define PCIINTB   0x002\n#define PCIINTC   0x004\n#define PCIINTD   0x008\n#define PCIINTE   0x010\n#define PCIINTF   0x020\n#define GSCEXTINT 0x040\n \n \n \n#define RS232INT  0x400\n\nstruct dino_device\n{\n\tstruct pci_hba_data\thba;\t \n\tspinlock_t\t\tdinosaur_pen;\n\tu32 \t\t\timr;\t    \n\tstruct gsc_irq\t\tgsc_irq;\n\tint\t\t\tglobal_irq[DINO_LOCAL_IRQS];  \n#ifdef DINO_DEBUG\n\tunsigned int\t\tdino_irr0;  \n#endif\n};\n\nstatic inline struct dino_device *DINO_DEV(struct pci_hba_data *hba)\n{\n\treturn container_of(hba, struct dino_device, hba);\n}\n\n \n\n#define DINO_CFG_TOK(bus,dfn,pos) ((u32) ((bus)<<16 | (dfn)<<8 | (pos)))\n\n \nstatic int dino_current_bus = 0;\n\nstatic int dino_cfg_read(struct pci_bus *bus, unsigned int devfn, int where,\n\t\tint size, u32 *val)\n{\n\tstruct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));\n\tu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\n\tu32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);\n\tvoid __iomem *base_addr = d->hba.base_addr;\n\tunsigned long flags;\n\n\tDBG(\"%s: %p, %d, %d, %d\\n\", __func__, base_addr, devfn, where,\n\t\t\t\t\t\t\t\t\tsize);\n\tspin_lock_irqsave(&d->dinosaur_pen, flags);\n\n\t \n\t__raw_writel(v, base_addr + DINO_PCI_ADDR);\n\n\t \n\tif (size == 1) {\n\t\t*val = readb(base_addr + DINO_CONFIG_DATA + (where & 3));\n\t} else if (size == 2) {\n\t\t*val = readw(base_addr + DINO_CONFIG_DATA + (where & 2));\n\t} else if (size == 4) {\n\t\t*val = readl(base_addr + DINO_CONFIG_DATA);\n\t}\n\n\tspin_unlock_irqrestore(&d->dinosaur_pen, flags);\n\treturn 0;\n}\n\n \nstatic int dino_cfg_write(struct pci_bus *bus, unsigned int devfn, int where,\n\tint size, u32 val)\n{\n\tstruct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));\n\tu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\n\tu32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);\n\tvoid __iomem *base_addr = d->hba.base_addr;\n\tunsigned long flags;\n\n\tDBG(\"%s: %p, %d, %d, %d\\n\", __func__, base_addr, devfn, where,\n\t\t\t\t\t\t\t\t\tsize);\n\tspin_lock_irqsave(&d->dinosaur_pen, flags);\n\n\t \n\t__raw_writel(v & 0xffffff00, base_addr + DINO_PCI_ADDR);\n\t__raw_readl(base_addr + DINO_CONFIG_DATA);\n\n\t \n\t__raw_writel(v, base_addr + DINO_PCI_ADDR);\n\t \n\tif (size == 1) {\n\t\twriteb(val, base_addr + DINO_CONFIG_DATA + (where & 3));\n\t} else if (size == 2) {\n\t\twritew(val, base_addr + DINO_CONFIG_DATA + (where & 2));\n\t} else if (size == 4) {\n\t\twritel(val, base_addr + DINO_CONFIG_DATA);\n\t}\n\n\tspin_unlock_irqrestore(&d->dinosaur_pen, flags);\n\treturn 0;\n}\n\nstatic struct pci_ops dino_cfg_ops = {\n\t.read =\t\tdino_cfg_read,\n\t.write =\tdino_cfg_write,\n};\n\n\n \n\n#define DINO_PORT_IN(type, size, mask) \\\nstatic u##size dino_in##size (struct pci_hba_data *d, u16 addr) \\\n{ \\\n\tu##size v; \\\n\tunsigned long flags; \\\n\tspin_lock_irqsave(&(DINO_DEV(d)->dinosaur_pen), flags); \\\n\t  \\\n\t__raw_writel((u32) addr, d->base_addr + DINO_PCI_ADDR); \\\n\t  \\\n\tv = read##type(d->base_addr+DINO_IO_DATA+(addr&mask)); \\\n\tspin_unlock_irqrestore(&(DINO_DEV(d)->dinosaur_pen), flags); \\\n\treturn v; \\\n}\n\nDINO_PORT_IN(b,  8, 3)\nDINO_PORT_IN(w, 16, 2)\nDINO_PORT_IN(l, 32, 0)\n\n#define DINO_PORT_OUT(type, size, mask) \\\nstatic void dino_out##size (struct pci_hba_data *d, u16 addr, u##size val) \\\n{ \\\n\tunsigned long flags; \\\n\tspin_lock_irqsave(&(DINO_DEV(d)->dinosaur_pen), flags); \\\n\t  \\\n\t__raw_writel((u32) addr, d->base_addr + DINO_PCI_ADDR); \\\n\t  \\\n\twrite##type(val, d->base_addr+DINO_IO_DATA+(addr&mask)); \\\n\tspin_unlock_irqrestore(&(DINO_DEV(d)->dinosaur_pen), flags); \\\n}\n\nDINO_PORT_OUT(b,  8, 3)\nDINO_PORT_OUT(w, 16, 2)\nDINO_PORT_OUT(l, 32, 0)\n\nstatic struct pci_port_ops dino_port_ops = {\n\t.inb\t= dino_in8,\n\t.inw\t= dino_in16,\n\t.inl\t= dino_in32,\n\t.outb\t= dino_out8,\n\t.outw\t= dino_out16,\n\t.outl\t= dino_out32\n};\n\nstatic void dino_mask_irq(struct irq_data *d)\n{\n\tstruct dino_device *dino_dev = irq_data_get_irq_chip_data(d);\n\tint local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);\n\n\tDBG(KERN_WARNING \"%s(0x%px, %d)\\n\", __func__, dino_dev, d->irq);\n\n\t \n\tdino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));\n\t__raw_writel(dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);\n}\n\nstatic void dino_unmask_irq(struct irq_data *d)\n{\n\tstruct dino_device *dino_dev = irq_data_get_irq_chip_data(d);\n\tint local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);\n\tu32 tmp;\n\n\tDBG(KERN_WARNING \"%s(0x%px, %d)\\n\", __func__, dino_dev, d->irq);\n\n\t \n\t__raw_readl(dino_dev->hba.base_addr+DINO_IPR);\n\n\t \n\tdino_dev->imr |= DINO_MASK_IRQ(local_irq);\t \n\t__raw_writel( dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);\n\n\t \n\ttmp = __raw_readl(dino_dev->hba.base_addr+DINO_ILR);\n\tif (tmp & DINO_MASK_IRQ(local_irq)) {\n\t\tDBG(KERN_WARNING \"%s(): IRQ asserted! (ILR 0x%x)\\n\",\n\t\t\t\t__func__, tmp);\n\t\tgsc_writel(dino_dev->gsc_irq.txn_data, dino_dev->gsc_irq.txn_addr);\n\t}\n}\n\n#ifdef CONFIG_SMP\nstatic int dino_set_affinity_irq(struct irq_data *d, const struct cpumask *dest,\n\t\t\t\tbool force)\n{\n\tstruct dino_device *dino_dev = irq_data_get_irq_chip_data(d);\n\tstruct cpumask tmask;\n\tint cpu_irq;\n\tu32 eim;\n\n\tif (!cpumask_and(&tmask, dest, cpu_online_mask))\n\t\treturn -EINVAL;\n\n\tcpu_irq = cpu_check_affinity(d, &tmask);\n\tif (cpu_irq < 0)\n\t\treturn cpu_irq;\n\n\tdino_dev->gsc_irq.txn_addr = txn_affinity_addr(d->irq, cpu_irq);\n\teim = ((u32) dino_dev->gsc_irq.txn_addr) | dino_dev->gsc_irq.txn_data;\n\t__raw_writel(eim, dino_dev->hba.base_addr+DINO_IAR0);\n\n\tirq_data_update_effective_affinity(d, &tmask);\n\n\treturn IRQ_SET_MASK_OK;\n}\n#endif\n\nstatic struct irq_chip dino_interrupt_type = {\n\t.name\t\t= \"GSC-PCI\",\n\t.irq_unmask\t= dino_unmask_irq,\n\t.irq_mask\t= dino_mask_irq,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity = dino_set_affinity_irq,\n#endif\n};\n\n\n \nstatic irqreturn_t dino_isr(int irq, void *intr_dev)\n{\n\tstruct dino_device *dino_dev = intr_dev;\n\tu32 mask;\n\tint ilr_loop = 100;\n\n\t \n#ifdef DINO_DEBUG\n\tdino_dev->dino_irr0 =\n#endif\n\tmask = __raw_readl(dino_dev->hba.base_addr+DINO_IRR0) & DINO_IRR_MASK;\n\n\tif (mask == 0)\n\t\treturn IRQ_NONE;\n\nilr_again:\n\tdo {\n\t\tint local_irq = __ffs(mask);\n\t\tint irq = dino_dev->global_irq[local_irq];\n\t\tDBG(KERN_DEBUG \"%s(%d, %p) mask 0x%x\\n\",\n\t\t\t__func__, irq, intr_dev, mask);\n\t\tgeneric_handle_irq(irq);\n\t\tmask &= ~DINO_MASK_IRQ(local_irq);\n\t} while (mask);\n\n\t \n\tmask = __raw_readl(dino_dev->hba.base_addr+DINO_ILR) & dino_dev->imr;\n\tif (mask) {\n\t\tif (--ilr_loop > 0)\n\t\t\tgoto ilr_again;\n\t\tpr_warn_ratelimited(\"Dino 0x%px: stuck interrupt %d\\n\",\n\t\t       dino_dev->hba.base_addr, mask);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void dino_assign_irq(struct dino_device *dino, int local_irq, int *irqp)\n{\n\tint irq = gsc_assign_irq(&dino_interrupt_type, dino);\n\tif (irq == NO_IRQ)\n\t\treturn;\n\n\t*irqp = irq;\n\tdino->global_irq[local_irq] = irq;\n}\n\nstatic void dino_choose_irq(struct parisc_device *dev, void *ctrl)\n{\n\tint irq;\n\tstruct dino_device *dino = ctrl;\n\n\tswitch (dev->id.sversion) {\n\t\tcase 0x00084:\tirq =  8; break;  \n\t\tcase 0x0008c:\tirq = 10; break;  \n\t\tcase 0x00096:\tirq =  8; break;  \n\t\tdefault:\treturn;\t\t  \n\t}\n\n\tdino_assign_irq(dino, irq, &dev->irq);\n}\n\n\n \nstatic void quirk_cirrus_cardbus(struct pci_dev *dev)\n{\n\tu8 new_irq = dev->irq - 1;\n\tprintk(KERN_INFO \"PCI: Cirrus Cardbus IRQ fixup for %s, from %d to %d\\n\",\n\t\t\tpci_name(dev), dev->irq, new_irq);\n\tdev->irq = new_irq;\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_CIRRUS, PCI_DEVICE_ID_CIRRUS_6832, quirk_cirrus_cardbus );\n\n#ifdef CONFIG_TULIP\n \nstatic int pci_dev_is_behind_card_dino(struct pci_dev *dev)\n{\n\tstruct dino_device *dino_dev;\n\n\tdino_dev = DINO_DEV(parisc_walk_tree(dev->bus->bridge));\n\treturn is_card_dino(&dino_dev->hba.dev->id);\n}\n\nstatic void pci_fixup_tulip(struct pci_dev *dev)\n{\n\tif (!pci_dev_is_behind_card_dino(dev))\n\t\treturn;\n\tif (!(pci_resource_flags(dev, 1) & IORESOURCE_MEM))\n\t\treturn;\n\tpr_warn(\"%s: HP HSC-PCI Cards with card-mode Dino not yet supported.\\n\",\n\t\tpci_name(dev));\n\t \n\tmemset(&dev->resource[0], 0, sizeof(dev->resource[0]));\n\tmemset(&dev->resource[1], 0, sizeof(dev->resource[1]));\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_DEC, PCI_ANY_ID, pci_fixup_tulip);\n#endif  \n\nstatic void __init\ndino_bios_init(void)\n{\n\tDBG(\"dino_bios_init\\n\");\n}\n\n \n#define _8MB 0x00800000UL\nstatic void __init\ndino_card_setup(struct pci_bus *bus, void __iomem *base_addr)\n{\n\tint i;\n\tstruct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));\n\tstruct resource *res;\n\tchar name[128];\n\tint size;\n\n\tres = &dino_dev->hba.lmmio_space;\n\tres->flags = IORESOURCE_MEM;\n\tsize = scnprintf(name, sizeof(name), \"Dino LMMIO (%s)\", \n\t\t\t dev_name(bus->bridge));\n\tres->name = kmalloc(size+1, GFP_KERNEL);\n\tif(res->name)\n\t\tstrcpy((char *)res->name, name);\n\telse\n\t\tres->name = dino_dev->hba.lmmio_space.name;\n\t\n\n\tif (ccio_allocate_resource(dino_dev->hba.dev, res, _8MB,\n\t\t\t\tF_EXTEND(0xf0000000UL) | _8MB,\n\t\t\t\tF_EXTEND(0xffffffffUL) &~ _8MB, _8MB) < 0) {\n\t\tstruct pci_dev *dev, *tmp;\n\n\t\tprintk(KERN_ERR \"Dino: cannot attach bus %s\\n\",\n\t\t       dev_name(bus->bridge));\n\t\t \n\t\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\n\t\t\tlist_del(&dev->bus_list);\n\t\t}\n\t\t\t\n\t\treturn;\n\t}\n\tbus->resource[1] = res;\n\tbus->resource[0] = &(dino_dev->hba.io_space);\n\n\t \n\tfor (i = 1; i < 31; i++) {\n\t\tif (res->start == F_EXTEND(0xf0000000UL | (i * _8MB)))\n\t\t\tbreak;\n\t}\n\tDBG(\"DINO GSC WRITE i=%d, start=%lx, dino addr = %p\\n\",\n\t    i, res->start, base_addr + DINO_IO_ADDR_EN);\n\t__raw_writel(1 << i, base_addr + DINO_IO_ADDR_EN);\n}\n\nstatic void __init\ndino_card_fixup(struct pci_dev *dev)\n{\n\tu32 irq_pin;\n\n\t \n\tif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {\n\t\tpanic(\"Card-Mode Dino: PCI-PCI Bridge not supported\\n\");\n\t}\n\n\t \n\tdino_cfg_write(dev->bus, dev->devfn, \n\t\t       PCI_CACHE_LINE_SIZE, 2, 0xff00 | L1_CACHE_BYTES/4); \n\n\t \n\tdino_cfg_read(dev->bus, dev->devfn, PCI_INTERRUPT_PIN, 1, &irq_pin); \n\tdev->irq = pci_swizzle_interrupt_pin(dev, irq_pin) - 1;\n\n\t \n\tdino_cfg_write(dev->bus, dev->devfn, PCI_INTERRUPT_LINE, 1, dev->irq); \n}\n\n \n#define DINO_BRIDGE_ALIGN 0x100000\n\n\nstatic void __init\ndino_fixup_bus(struct pci_bus *bus)\n{\n        struct pci_dev *dev;\n        struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));\n\n\tDBG(KERN_WARNING \"%s(0x%px) bus %d platform_data 0x%px\\n\",\n\t    __func__, bus, bus->busn_res.start,\n\t    bus->bridge->platform_data);\n\n\t \n\tif (is_card_dino(&dino_dev->hba.dev->id)) {\n\t\tdino_card_setup(bus, dino_dev->hba.base_addr);\n\t} else if (bus->parent) {\n\t\tint i;\n\n\t\tpci_read_bridge_bases(bus);\n\n\n\t\tfor(i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tif((bus->self->resource[i].flags & \n\t\t\t    (IORESOURCE_IO | IORESOURCE_MEM)) == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(bus->self->resource[i].flags & IORESOURCE_MEM) {\n\t\t\t\t \n\t\t\t\tbus->self->resource[i].end = bus->self->resource[i].end - bus->self->resource[i].start + DINO_BRIDGE_ALIGN;\n\t\t\t\tbus->self->resource[i].start = DINO_BRIDGE_ALIGN;\n\t\t\t\t\n\t\t\t}\n\t\t\t\t\t\n\t\t\tDBG(\"DEBUG %s assigning %d [%pR]\\n\",\n\t\t\t    dev_name(&bus->self->dev), i,\n\t\t\t    &bus->self->resource[i]);\n\t\t\tWARN_ON(pci_assign_resource(bus->self, i));\n\t\t\tDBG(\"DEBUG %s after assign %d [%pR]\\n\",\n\t\t\t    dev_name(&bus->self->dev), i,\n\t\t\t    &bus->self->resource[i]);\n\t\t}\n\t}\n\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (is_card_dino(&dino_dev->hba.dev->id))\n\t\t\tdino_card_fixup(dev);\n\n\t\t \n\t\tif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)  {\n\t\t\tpcibios_init_bridge(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdev->resource[PCI_ROM_RESOURCE].flags = 0;\n\t\t\t\t\n\t\tif(dev->irq == 255) {\n\n#define DINO_FIX_UNASSIGNED_INTERRUPTS\n#ifdef DINO_FIX_UNASSIGNED_INTERRUPTS\n\n\t\t\t \n\n\t\t\tu32 irq_pin;\n\t\t\t\n\t\t\tdino_cfg_read(dev->bus, dev->devfn, \n\t\t\t\t      PCI_INTERRUPT_PIN, 1, &irq_pin);\n\t\t\tirq_pin = pci_swizzle_interrupt_pin(dev, irq_pin) - 1;\n\t\t\tprintk(KERN_WARNING \"Device %s has undefined IRQ, \"\n\t\t\t\t\t\"setting to %d\\n\", pci_name(dev), irq_pin);\n\t\t\tdino_cfg_write(dev->bus, dev->devfn, \n\t\t\t\t       PCI_INTERRUPT_LINE, 1, irq_pin);\n\t\t\tdino_assign_irq(dino_dev, irq_pin, &dev->irq);\n#else\n\t\t\tdev->irq = 65535;\n\t\t\tprintk(KERN_WARNING \"Device %s has unassigned IRQ\\n\", pci_name(dev));\n#endif\n\t\t} else {\n\t\t\t \n\t\t\tdino_assign_irq(dino_dev, dev->irq, &dev->irq);\n\t\t}\n\t}\n}\n\n\nstatic struct pci_bios_ops dino_bios_ops = {\n\t.init\t\t= dino_bios_init,\n\t.fixup_bus\t= dino_fixup_bus\n};\n\n\n \nstatic void __init\ndino_card_init(struct dino_device *dino_dev)\n{\n\tu32 brdg_feat = 0x00784e05;\n\tunsigned long status;\n\n\tstatus = __raw_readl(dino_dev->hba.base_addr+DINO_IO_STATUS);\n\tif (status & 0x0000ff80) {\n\t\t__raw_writel(0x00000005,\n\t\t\t\tdino_dev->hba.base_addr+DINO_IO_COMMAND);\n\t\tudelay(1);\n\t}\n\n\t__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_GMASK);\n\t__raw_writel(0x00000001, dino_dev->hba.base_addr+DINO_IO_FBB_EN);\n\t__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_ICR);\n\n#if 1\n \n\t \n\tbrdg_feat &= ~0x4;\t \n#endif\n\t__raw_writel( brdg_feat, dino_dev->hba.base_addr+DINO_BRDG_FEAT);\n\n\t \n\t__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_IO_ADDR_EN);\n\n\t__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_DAMODE);\n\t__raw_writel(0x00222222, dino_dev->hba.base_addr+DINO_PCIROR);\n\t__raw_writel(0x00222222, dino_dev->hba.base_addr+DINO_PCIWOR);\n\n\t__raw_writel(0x00000040, dino_dev->hba.base_addr+DINO_MLTIM);\n\t__raw_writel(0x00000080, dino_dev->hba.base_addr+DINO_IO_CONTROL);\n\t__raw_writel(0x0000008c, dino_dev->hba.base_addr+DINO_TLTIM);\n\n\t \n\t__raw_writel(0x0000007e, dino_dev->hba.base_addr+DINO_PAMR);\n\t__raw_writel(0x0000007f, dino_dev->hba.base_addr+DINO_PAPR);\n\t__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_PAMR);\n\n\t \n\t__raw_writel(0x0000004f, dino_dev->hba.base_addr+DINO_PCICMD);\n\n\t \n\tmdelay(pci_post_reset_delay);\n}\n\nstatic int __init\ndino_bridge_init(struct dino_device *dino_dev, const char *name)\n{\n\tunsigned long io_addr;\n\tint result, i, count=0;\n\tstruct resource *res, *prevres = NULL;\n\t \n\n\tio_addr = __raw_readl(dino_dev->hba.base_addr + DINO_IO_ADDR_EN);\n\tif (io_addr == 0) {\n\t\tprintk(KERN_WARNING \"%s: No PCI devices enabled.\\n\", name);\n\t\treturn -ENODEV;\n\t}\n\n\tres = &dino_dev->hba.lmmio_space;\n\tfor (i = 0; i < 32; i++) {\n\t\tunsigned long start, end;\n\n\t\tif((io_addr & (1 << i)) == 0)\n\t\t\tcontinue;\n\n\t\tstart = F_EXTEND(0xf0000000UL) | (i << 23);\n\t\tend = start + 8 * 1024 * 1024 - 1;\n\n\t\tDBG(\"DINO RANGE %d is at 0x%lx-0x%lx\\n\", count,\n\t\t    start, end);\n\n\t\tif(prevres && prevres->end + 1 == start) {\n\t\t\tprevres->end = end;\n\t\t} else {\n\t\t\tif(count >= DINO_MAX_LMMIO_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"%s is out of resource windows for range %d (0x%lx-0x%lx)\\n\", name, count, start, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevres = res;\n\t\t\tres->start = start;\n\t\t\tres->end = end;\n\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\tres->name = kmalloc(64, GFP_KERNEL);\n\t\t\tif(res->name)\n\t\t\t\tsnprintf((char *)res->name, 64, \"%s LMMIO %d\",\n\t\t\t\t\t name, count);\n\t\t\tres++;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tres = &dino_dev->hba.lmmio_space;\n\n\tfor(i = 0; i < DINO_MAX_LMMIO_RESOURCES; i++) {\n\t\tif(res[i].flags == 0)\n\t\t\tbreak;\n\n\t\tresult = ccio_request_resource(dino_dev->hba.dev, &res[i]);\n\t\tif (result < 0) {\n\t\t\tprintk(KERN_ERR \"%s: failed to claim PCI Bus address \"\n\t\t\t       \"space %d (%pR)!\\n\", name, i, &res[i]);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __init dino_common_init(struct parisc_device *dev,\n\t\tstruct dino_device *dino_dev, const char *name)\n{\n\tint status;\n\tu32 eim;\n\tstruct resource *res;\n\n\tpcibios_register_hba(&dino_dev->hba);\n\n\tpci_bios = &dino_bios_ops;    \n\tpci_port = &dino_port_ops;\n\n\t \n\tdev->irq = gsc_alloc_irq(&dino_dev->gsc_irq);\n\teim = ((u32) dino_dev->gsc_irq.txn_addr) | dino_dev->gsc_irq.txn_data;\n\n\t \n\tif (dev->irq < 0) {\n\t\tprintk(KERN_WARNING \"%s: gsc_alloc_irq() failed\\n\", name);\n\t\treturn 1;\n\t}\n\n\tstatus = request_irq(dev->irq, dino_isr, 0, name, dino_dev);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"%s: request_irq() failed with %d\\n\", \n\t\t\tname, status);\n\t\treturn 1;\n\t}\n\n\t \n\n\tgsc_fixup_irqs(dev, dino_dev, dino_choose_irq);\n\n\t \n\t__raw_writel(eim, dino_dev->hba.base_addr+DINO_IAR0);\n\n\t \n\t__raw_readl(dino_dev->hba.base_addr+DINO_IRR0);\n\n\t \n\tres = &dino_dev->hba.io_space;\n\tif (!is_cujo(&dev->id)) {\n\t\tres->name = \"Dino I/O Port\";\n\t} else {\n\t\tres->name = \"Cujo I/O Port\";\n\t}\n\tres->start = HBA_PORT_BASE(dino_dev->hba.hba_num);\n\tres->end = res->start + (HBA_PORT_SPACE_SIZE - 1);\n\tres->flags = IORESOURCE_IO;  \n\tif (request_resource(&ioport_resource, res) < 0) {\n\t\tprintk(KERN_ERR \"%s: request I/O Port region failed \"\n\t\t       \"0x%lx/%lx (hpa 0x%px)\\n\",\n\t\t       name, (unsigned long)res->start, (unsigned long)res->end,\n\t\t       dino_dev->hba.base_addr);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#define CUJO_RAVEN_ADDR\t\tF_EXTEND(0xf1000000UL)\n#define CUJO_FIREHAWK_ADDR\tF_EXTEND(0xf1604000UL)\n#define CUJO_RAVEN_BADPAGE\t0x01003000UL\n#define CUJO_FIREHAWK_BADPAGE\t0x01607000UL\n\nstatic const char dino_vers[][4] = {\n\t\"2.0\",\n\t\"2.1\",\n\t\"3.0\",\n\t\"3.1\"\n};\n\nstatic const char cujo_vers[][4] = {\n\t\"1.0\",\n\t\"2.0\"\n};\n\n \nstatic int __init dino_probe(struct parisc_device *dev)\n{\n\tstruct dino_device *dino_dev;\t \n\tconst char *version = \"unknown\";\n\tchar *name;\n\tint is_cujo = 0;\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tunsigned long hpa = dev->hpa.start;\n\tint max;\n\n\tname = \"Dino\";\n\tif (is_card_dino(&dev->id)) {\n\t\tversion = \"3.x (card mode)\";\n\t} else {\n\t\tif (!is_cujo(&dev->id)) {\n\t\t\tif (dev->id.hversion_rev < 4) {\n\t\t\t\tversion = dino_vers[dev->id.hversion_rev];\n\t\t\t}\n\t\t} else {\n\t\t\tname = \"Cujo\";\n\t\t\tis_cujo = 1;\n\t\t\tif (dev->id.hversion_rev < 2) {\n\t\t\t\tversion = cujo_vers[dev->id.hversion_rev];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintk(\"%s version %s found at 0x%lx\\n\", name, version, hpa);\n\n\tif (!request_mem_region(hpa, PAGE_SIZE, name)) {\n\t\tprintk(KERN_ERR \"DINO: Hey! Someone took my MMIO space (0x%lx)!\\n\",\n\t\t\thpa);\n\t\treturn 1;\n\t}\n\n\t \n\tif (is_cujo && dev->id.hversion_rev == 1) {\n#ifdef CONFIG_IOMMU_CCIO\n\t\tprintk(KERN_WARNING \"Enabling Cujo 2.0 bug workaround\\n\");\n\t\tif (hpa == (unsigned long)CUJO_RAVEN_ADDR) {\n\t\t\tccio_cujo20_fixup(dev, CUJO_RAVEN_BADPAGE);\n\t\t} else if (hpa == (unsigned long)CUJO_FIREHAWK_ADDR) {\n\t\t\tccio_cujo20_fixup(dev, CUJO_FIREHAWK_BADPAGE);\n\t\t} else {\n\t\t\tprintk(\"Don't recognise Cujo at address 0x%lx, not enabling workaround\\n\", hpa);\n\t\t}\n#endif\n\t} else if (!is_cujo && !is_card_dino(&dev->id) &&\n\t\t\tdev->id.hversion_rev < 3) {\n\t\tprintk(KERN_WARNING\n\"The GSCtoPCI (Dino hrev %d) bus converter found may exhibit\\n\"\n\"data corruption.  See Service Note Numbers: A4190A-01, A4191A-01.\\n\"\n\"Systems shipped after Aug 20, 1997 will not exhibit this problem.\\n\"\n\"Models affected: C180, C160, C160L, B160L, and B132L workstations.\\n\\n\",\n\t\t\tdev->id.hversion_rev);\n \n\t}\n\n\tdino_dev = kzalloc(sizeof(struct dino_device), GFP_KERNEL);\n\tif (!dino_dev) {\n\t\tprintk(\"dino_init_chip - couldn't alloc dino_device\\n\");\n\t\treturn 1;\n\t}\n\n\tdino_dev->hba.dev = dev;\n\tdino_dev->hba.base_addr = ioremap(hpa, 4096);\n\tdino_dev->hba.lmmio_space_offset = PCI_F_EXTEND;\n\tspin_lock_init(&dino_dev->dinosaur_pen);\n\tdino_dev->hba.iommu = ccio_get_iommu(dev);\n\n\tif (is_card_dino(&dev->id)) {\n\t\tdino_card_init(dino_dev);\n\t} else {\n\t\tdino_bridge_init(dino_dev, name);\n\t}\n\n\tif (dino_common_init(dev, dino_dev, name))\n\t\treturn 1;\n\n\tdev->dev.platform_data = dino_dev;\n\n\tpci_add_resource_offset(&resources, &dino_dev->hba.io_space,\n\t\t\t\tHBA_PORT_BASE(dino_dev->hba.hba_num));\n\tif (dino_dev->hba.lmmio_space.flags)\n\t\tpci_add_resource_offset(&resources, &dino_dev->hba.lmmio_space,\n\t\t\t\t\tdino_dev->hba.lmmio_space_offset);\n\tif (dino_dev->hba.elmmio_space.flags)\n\t\tpci_add_resource_offset(&resources, &dino_dev->hba.elmmio_space,\n\t\t\t\t\tdino_dev->hba.lmmio_space_offset);\n\tif (dino_dev->hba.gmmio_space.flags)\n\t\tpci_add_resource(&resources, &dino_dev->hba.gmmio_space);\n\n\tdino_dev->hba.bus_num.start = dino_current_bus;\n\tdino_dev->hba.bus_num.end = 255;\n\tdino_dev->hba.bus_num.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &dino_dev->hba.bus_num);\n\t \n\tdino_dev->hba.hba_bus = bus = pci_create_root_bus(&dev->dev,\n\t\t\t dino_current_bus, &dino_cfg_ops, NULL, &resources);\n\tif (!bus) {\n\t\tprintk(KERN_ERR \"ERROR: failed to scan PCI bus on %s (duplicate bus number %d?)\\n\",\n\t\t       dev_name(&dev->dev), dino_current_bus);\n\t\tpci_free_resource_list(&resources);\n\t\t \n\t\tdino_current_bus++;\n\t\treturn 0;\n\t}\n\n\tmax = pci_scan_child_bus(bus);\n\tpci_bus_update_busn_res_end(bus, max);\n\n\t \n\tdino_current_bus = max + 1;\n\tpci_bus_assign_resources(bus);\n\tpci_bus_add_devices(bus);\n\treturn 0;\n}\n\n \nstatic const struct parisc_device_id dino_tbl[] __initconst = {\n\t{ HPHW_A_DMA, HVERSION_REV_ANY_ID, 0x004, 0x0009D }, \n\t{ HPHW_A_DMA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x08080 },  \n\t{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x680, 0xa },  \n\t{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x682, 0xa },  \n\t{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x05d, 0xa },  \n\t{ 0, }\n};\n\nstatic struct parisc_driver dino_driver __refdata = {\n\t.name =\t\t\"dino\",\n\t.id_table =\tdino_tbl,\n\t.probe =\tdino_probe,\n};\n\n \nstatic int __init dino_init(void)\n{\n\treturn register_parisc_driver(&dino_driver);\n}\narch_initcall(dino_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}