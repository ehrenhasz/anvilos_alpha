{
  "module_name": "power.c",
  "hash_id": "d2e9e0f1ccb8b9767dd01fb30f505613ea276404bfd24d0483b98e1d0a4e7b65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/power.c",
  "human_readable_source": "  \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/panic_notifier.h>\n#include <linux/reboot.h>\n#include <linux/sched/signal.h>\n#include <linux/kthread.h>\n#include <linux/pm.h>\n\n#include <asm/pdc.h>\n#include <asm/io.h>\n#include <asm/led.h>\n\n#define DRIVER_NAME  \"powersw\"\n#define KTHREAD_NAME \"kpowerswd\"\n\n \n#define POWERSWITCH_POLL_PER_SEC 2\n\n \n#define POWERSWITCH_DOWN_SEC 2\n\n \n \n#define DIAG_CODE(code)\t\t(0x14000000 + ((code)<<5))\n\n#define MFCPU_X(rDiagReg, t_ch, t_th, code) \\\n\t(DIAG_CODE(code) + ((rDiagReg)<<21) + ((t_ch)<<16) + ((t_th)<<0) )\n\t\n#define MTCPU(dr, gr)\t\tMFCPU_X(dr, gr,  0, 0x12)        \n#define MFCPU_C(dr, gr)\t\tMFCPU_X(dr, gr,  0, 0x30)\t \n#define MFCPU_T(dr, gr)\t\tMFCPU_X(dr,  0, gr, 0xa0)\t \n\t\n#define __getDIAG(dr) ( { \t\t\t\\\n        register unsigned long __res asm(\"r28\");\\\n\t __asm__ __volatile__ (\t\t\t\\\n\t\t\".word %1\" : \"=&r\" (__res) : \"i\" (MFCPU_T(dr,28) ) \\\n\t);\t\t\t\t\t\\\n\t__res;\t\t\t\t\t\\\n} )\n\n \nstatic int shutdown_timer __read_mostly;\n\n \nstatic void process_shutdown(void)\n{\n\tif (shutdown_timer == 0)\n\t\tprintk(KERN_ALERT KTHREAD_NAME \": Shutdown requested...\\n\");\n\n\tshutdown_timer++;\n\t\n\t \n\tif (shutdown_timer == (POWERSWITCH_DOWN_SEC*POWERSWITCH_POLL_PER_SEC)) {\n\t\tstatic const char msg[] = \"Shutting down...\";\n\t\tprintk(KERN_INFO KTHREAD_NAME \": %s\\n\", msg);\n\t\tlcd_print(msg);\n\n\t\t \n\t\tif (kill_cad_pid(SIGINT, 1)) {\n\t\t\t \n\t\t\tmachine_power_off();\n\t\t}\n\t}\n}\n\n\n \nstatic struct task_struct *power_task;\n\n \n#define SYSCTL_FILENAME\t\"sys/kernel/power\"\n\n \nint pwrsw_enabled __read_mostly = 1;\n\n \nstatic int kpowerswd(void *param)\n{\n\t__set_current_state(TASK_RUNNING);\n\n\tdo {\n\t\tint button_not_pressed;\n\t\tunsigned long soft_power_reg = (unsigned long) param;\n\n\t\tschedule_timeout_interruptible(pwrsw_enabled ? HZ : HZ/POWERSWITCH_POLL_PER_SEC);\n\n\t\tif (unlikely(!pwrsw_enabled))\n\t\t\tcontinue;\n\n\t\tif (soft_power_reg) {\n\t\t\t \n\t\t\tbutton_not_pressed = (gsc_readl(soft_power_reg) & 0x1);\n\t\t} else {\n\t\t\t \n\t\t\tbutton_not_pressed = (__getDIAG(25) & 0x80000000);\n\t\t}\n\n\t\tif (likely(button_not_pressed)) {\n\t\t\tif (unlikely(shutdown_timer &&  \n\t\t\t\tshutdown_timer < (POWERSWITCH_DOWN_SEC*POWERSWITCH_POLL_PER_SEC))) {\n\t\t\t\tshutdown_timer = 0;\n\t\t\t\tprintk(KERN_INFO KTHREAD_NAME \": Shutdown request aborted.\\n\");\n\t\t\t}\n\t\t} else\n\t\t\tprocess_shutdown();\n\n\n\t} while (!kthread_should_stop());\n\n\treturn 0;\n}\n\n\n \n#if 0\nstatic void powerfail_interrupt(int code, void *x)\n{\n\tprintk(KERN_CRIT \"POWERFAIL INTERRUPTION !\\n\");\n\tpoweroff();\n}\n#endif\n\n\n\n\n \nstatic int parisc_panic_event(struct notifier_block *this,\n\t\tunsigned long event, void *ptr)\n{\n\t \n\tpdc_soft_power_button_panic(0);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block parisc_panic_block = {\n\t.notifier_call\t= parisc_panic_event,\n\t.priority\t= INT_MAX,\n};\n\n \nstatic int qemu_power_off(struct sys_off_data *data)\n{\n\t \n\tgsc_writel(0, (unsigned long) data->cb_data);\n\tpdc_soft_power_button(1);\n\treturn NOTIFY_DONE;\n}\n\nstatic int __init power_init(void)\n{\n\tunsigned long ret;\n\tunsigned long soft_power_reg;\n\n#if 0\n\trequest_irq( IRQ_FROM_REGION(CPU_IRQ_REGION)+2, &powerfail_interrupt,\n\t\t0, \"powerfail\", NULL);\n#endif\n\n\t \n\tret = pdc_soft_power_info(&soft_power_reg);\n\tif (ret == PDC_OK)\n\t\tret = pdc_soft_power_button(1);\n\tif (ret != PDC_OK)\n\t\tsoft_power_reg = -1UL;\n\t\n\tswitch (soft_power_reg) {\n\tcase 0:\t\tprintk(KERN_INFO DRIVER_NAME \": Gecko-style soft power switch enabled.\\n\");\n\t\t\tbreak;\n\t\t\t\n\tcase -1UL:\tprintk(KERN_INFO DRIVER_NAME \": Soft power switch support not available.\\n\");\n\t\t\treturn -ENODEV;\n\t\n\tdefault:\tprintk(KERN_INFO DRIVER_NAME \": Soft power switch at 0x%08lx enabled.\\n\",\n\t\t\t\tsoft_power_reg);\n\t}\n\n\tpower_task = NULL;\n\tif (running_on_qemu && soft_power_reg)\n\t\tregister_sys_off_handler(SYS_OFF_MODE_POWER_OFF, SYS_OFF_PRIO_DEFAULT,\n\t\t\t\t\tqemu_power_off, (void *)soft_power_reg);\n\telse\n\t\tpower_task = kthread_run(kpowerswd, (void*)soft_power_reg,\n\t\t\t\t\tKTHREAD_NAME);\n\tif (IS_ERR(power_task)) {\n\t\tprintk(KERN_ERR DRIVER_NAME \": thread creation failed.  Driver not loaded.\\n\");\n\t\tpdc_soft_power_button(0);\n\t\treturn -EIO;\n\t}\n\n\t \n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t&parisc_panic_block);\n\n\treturn 0;\n}\n\nstatic void __exit power_exit(void)\n{\n\tkthread_stop(power_task);\n\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t&parisc_panic_block);\n\n\tpdc_soft_power_button(0);\n}\n\narch_initcall(power_init);\nmodule_exit(power_exit);\n\n\nMODULE_AUTHOR(\"Helge Deller <deller@gmx.de>\");\nMODULE_DESCRIPTION(\"Soft power switch driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}