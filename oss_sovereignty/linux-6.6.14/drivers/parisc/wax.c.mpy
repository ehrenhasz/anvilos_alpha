{
  "module_name": "wax.c",
  "hash_id": "e70ff3a61822c1c1326bab6bea5ff3aca870054f3216e4b511845e889f9b8cbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/wax.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include <asm/io.h>\n#include <asm/hardware.h>\n\n#include \"gsc.h\"\n\n#define WAX_GSC_IRQ\t7\t \n\nstatic void wax_choose_irq(struct parisc_device *dev, void *ctrl)\n{\n\tint irq;\n\n\tswitch (dev->id.sversion) {\n\t\tcase 0x73:\tirq =  1; break;  \n\t\tcase 0x8c:\tirq =  6; break;  \n\t\tcase 0x90:\tirq = 10; break;  \n\t\tdefault:\treturn;\t\t  \n\t}\n\n\tgsc_asic_assign_irq(ctrl, irq, &dev->irq);\n\n\tswitch (dev->id.sversion) {\n\t\tcase 0x73:\tirq =  2; break;  \n\t\tcase 0x90:\tirq =  0; break;  \n\t\tdefault:\treturn;\t\t  \n\t}\n\n\tgsc_asic_assign_irq(ctrl, irq, &dev->aux_irq);\n}\n\nstatic void __init\nwax_init_irq(struct gsc_asic *wax)\n{\n\tunsigned long base = wax->hpa;\n\n\t \n\tgsc_writel(0x00000000, base+OFFSET_IMR);\n\n\t \n\tgsc_readl(base+OFFSET_IRR);\n\n\t \n\n\t \n \n \n}\n\nstatic int __init wax_init_chip(struct parisc_device *dev)\n{\n\tstruct gsc_asic *wax;\n\tstruct parisc_device *parent;\n\tint ret;\n\n\twax = kzalloc(sizeof(*wax), GFP_KERNEL);\n\tif (!wax)\n\t\treturn -ENOMEM;\n\n\twax->name = \"wax\";\n\twax->hpa = dev->hpa.start;\n\n\twax->version = 0;    \n\tprintk(KERN_INFO \"%s at 0x%lx found.\\n\", wax->name, wax->hpa);\n\n\t \n\twax_init_irq(wax);\n\n\t \n\tdev->irq = gsc_claim_irq(&wax->gsc_irq, WAX_GSC_IRQ);\n\tif (dev->irq < 0) {\n\t\tprintk(KERN_ERR \"%s(): cannot get GSC irq\\n\",\n\t\t\t\t__func__);\n\t\tkfree(wax);\n\t\treturn -EBUSY;\n\t}\n\n\twax->eim = ((u32) wax->gsc_irq.txn_addr) | wax->gsc_irq.txn_data;\n\n\tret = request_irq(wax->gsc_irq.irq, gsc_asic_intr, 0, \"wax\", wax);\n\tif (ret < 0) {\n\t\tkfree(wax);\n\t\treturn ret;\n\t}\n\n\t \n\tgsc_writel(wax->eim, wax->hpa + OFFSET_IAR);\n\n\t \n\tret = gsc_common_setup(dev, wax);\n\tif (ret) {\n\t\tkfree(wax);\n\t\treturn ret;\n\t}\n\n\tgsc_fixup_irqs(dev, wax, wax_choose_irq);\n\t \n\tparent = parisc_parent(dev);\n\tif (parent->id.hw_type != HPHW_IOA) {\n\t\tgsc_fixup_irqs(parent, wax, wax_choose_irq);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct parisc_device_id wax_tbl[] __initconst = {\n\t{ HPHW_BA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0008e },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, wax_tbl);\n\nstatic struct parisc_driver wax_driver __refdata = {\n\t.name =\t\t\"wax\",\n\t.id_table =\twax_tbl,\n\t.probe =\twax_init_chip,\n};\n\nstatic int __init wax_init(void)\n{\n\treturn register_parisc_driver(&wax_driver);\n}\narch_initcall(wax_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}