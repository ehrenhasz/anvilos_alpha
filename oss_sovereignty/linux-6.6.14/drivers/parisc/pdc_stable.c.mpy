{
  "module_name": "pdc_stable.c",
  "hash_id": "6a4dc2f9f2dfcfa2344be1baf0826e106bed54df12fec6b23ef5862599af9eb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/pdc_stable.c",
  "human_readable_source": "\n \n\n#undef PDCS_DEBUG\n#ifdef PDCS_DEBUG\n#define DPRINTK(fmt, args...)\tprintk(KERN_DEBUG fmt, ## args)\n#else\n#define DPRINTK(fmt, args...)\n#endif\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n\n#include <asm/pdc.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <asm/hardware.h>\n\n#define PDCS_VERSION\t\"0.30\"\n#define PDCS_PREFIX\t\"PDC Stable Storage\"\n\n#define PDCS_ADDR_PPRI\t0x00\n#define PDCS_ADDR_OSID\t0x40\n#define PDCS_ADDR_OSD1\t0x48\n#define PDCS_ADDR_DIAG\t0x58\n#define PDCS_ADDR_FSIZ\t0x5C\n#define PDCS_ADDR_PCON\t0x60\n#define PDCS_ADDR_PALT\t0x80\n#define PDCS_ADDR_PKBD\t0xA0\n#define PDCS_ADDR_OSD2\t0xE0\n\nMODULE_AUTHOR(\"Thibaut VARENE <varenet@parisc-linux.org>\");\nMODULE_DESCRIPTION(\"sysfs interface to HP PDC Stable Storage data\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PDCS_VERSION);\n\n \nstatic unsigned long pdcs_size __read_mostly;\n\n \nstatic u16 pdcs_osid __read_mostly;\n\n \nstruct pdcspath_entry {\n\trwlock_t rw_lock;\t\t \n\tshort ready;\t\t\t \n\tunsigned long addr;\t\t \n\tchar *name;\t\t\t \n\tstruct pdc_module_path devpath;\t \n\tstruct device *dev;\t\t \n\tstruct kobject kobj;\n};\n\nstruct pdcspath_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct pdcspath_entry *entry, char *buf);\n\tssize_t (*store)(struct pdcspath_entry *entry, const char *buf, size_t count);\n};\n\n#define PDCSPATH_ENTRY(_addr, _name) \\\nstruct pdcspath_entry pdcspath_entry_##_name = { \\\n\t.ready = 0, \\\n\t.addr = _addr, \\\n\t.name = __stringify(_name), \\\n};\n\n#define PDCS_ATTR(_name, _mode, _show, _store) \\\nstruct kobj_attribute pdcs_attr_##_name = { \\\n\t.attr = {.name = __stringify(_name), .mode = _mode}, \\\n\t.show = _show, \\\n\t.store = _store, \\\n};\n\n#define PATHS_ATTR(_name, _mode, _show, _store) \\\nstruct pdcspath_attribute paths_attr_##_name = { \\\n\t.attr = {.name = __stringify(_name), .mode = _mode}, \\\n\t.show = _show, \\\n\t.store = _store, \\\n};\n\n#define to_pdcspath_attribute(_attr) container_of(_attr, struct pdcspath_attribute, attr)\n#define to_pdcspath_entry(obj)  container_of(obj, struct pdcspath_entry, kobj)\n\n \nstatic int\npdcspath_fetch(struct pdcspath_entry *entry)\n{\n\tstruct pdc_module_path *devpath;\n\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tdevpath = &entry->devpath;\n\t\n\tDPRINTK(\"%s: fetch: 0x%p, 0x%p, addr: 0x%lx\\n\", __func__,\n\t\t\tentry, devpath, entry->addr);\n\n\t \n\tif (pdc_stable_read(entry->addr, devpath, sizeof(*devpath)) != PDC_OK)\n\t\treturn -EIO;\n\t\t\n\t \n\tentry->dev = hwpath_to_device((struct hardware_path *)devpath);\n\n\tentry->ready = 1;\n\t\n\tDPRINTK(\"%s: device: 0x%p\\n\", __func__, entry->dev);\n\t\n\treturn 0;\n}\n\n \nstatic void\npdcspath_store(struct pdcspath_entry *entry)\n{\n\tstruct pdc_module_path *devpath;\n\n\tBUG_ON(!entry);\n\n\tdevpath = &entry->devpath;\n\t\n\t \n\tif (!entry->ready) {\n\t\t \n\t\tBUG_ON(!entry->dev);\n\t\tdevice_to_hwpath(entry->dev, (struct hardware_path *)devpath);\n\t}\n\t \n\t\n\tDPRINTK(\"%s: store: 0x%p, 0x%p, addr: 0x%lx\\n\", __func__,\n\t\t\tentry, devpath, entry->addr);\n\n\t \n\tif (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK)\n\t\tWARN(1, KERN_ERR \"%s: an error occurred when writing to PDC.\\n\"\n\t\t\t\t\"It is likely that the Stable Storage data has been corrupted.\\n\"\n\t\t\t\t\"Please check it carefully upon next reboot.\\n\", __func__);\n\t\t\n\t \n\tentry->ready = 2;\n\t\n\tDPRINTK(\"%s: device: 0x%p\\n\", __func__, entry->dev);\n}\n\n \nstatic ssize_t\npdcspath_hwpath_read(struct pdcspath_entry *entry, char *buf)\n{\n\tchar *out = buf;\n\tstruct pdc_module_path *devpath;\n\tshort i;\n\n\tif (!entry || !buf)\n\t\treturn -EINVAL;\n\n\tread_lock(&entry->rw_lock);\n\tdevpath = &entry->devpath;\n\ti = entry->ready;\n\tread_unlock(&entry->rw_lock);\n\n\tif (!i)\t \n\t\treturn -ENODATA;\n\t\n\tfor (i = 0; i < 6; i++) {\n\t\tif (devpath->path.bc[i] < 0)\n\t\t\tcontinue;\n\t\tout += sprintf(out, \"%d/\", devpath->path.bc[i]);\n\t}\n\tout += sprintf(out, \"%u\\n\", (unsigned char)devpath->path.mod);\n\t\n\treturn out - buf;\n}\n\n \nstatic ssize_t\npdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t count)\n{\n\tstruct hardware_path hwpath;\n\tunsigned short i;\n\tchar in[64], *temp;\n\tstruct device *dev;\n\tint ret;\n\n\tif (!entry || !buf || !count)\n\t\treturn -EINVAL;\n\n\t \n\tcount = min_t(size_t, count, sizeof(in)-1);\n\tstrscpy(in, buf, count + 1);\n\t\n\t \n\tmemset(&hwpath, 0xff, sizeof(hwpath));\n\t\n\t \n\tif (!(temp = strrchr(in, '/')))\n\t\treturn -EINVAL;\n\t\t\t\n\thwpath.mod = simple_strtoul(temp+1, NULL, 10);\n\tin[temp-in] = '\\0';\t \n\tDPRINTK(\"%s: mod: %d\\n\", __func__, hwpath.mod);\n\t\n\t \n\tfor (i=5; ((temp = strrchr(in, '/'))) && (temp-in > 0) && (likely(i)); i--) {\n\t\thwpath.bc[i] = simple_strtoul(temp+1, NULL, 10);\n\t\tin[temp-in] = '\\0';\n\t\tDPRINTK(\"%s: bc[%d]: %d\\n\", __func__, i, hwpath.path.bc[i]);\n\t}\n\t\n\t \t\t\n\thwpath.bc[i] = simple_strtoul(in, NULL, 10);\n\tDPRINTK(\"%s: bc[%d]: %d\\n\", __func__, i, hwpath.path.bc[i]);\n\t\n\t \n\tif (!(dev = hwpath_to_device((struct hardware_path *)&hwpath))) {\n\t\tprintk(KERN_WARNING \"%s: attempt to set invalid \\\"%s\\\" \"\n\t\t\t\"hardware path: %s\\n\", __func__, entry->name, buf);\n\t\treturn -EINVAL;\n\t}\n\t\n\t \n\twrite_lock(&entry->rw_lock);\n\tentry->ready = 0;\n\tentry->dev = dev;\n\t\n\t \n\tpdcspath_store(entry);\n\t\n\t \n\tsysfs_remove_link(&entry->kobj, \"device\");\n\twrite_unlock(&entry->rw_lock);\n\n\tret = sysfs_create_link(&entry->kobj, &entry->dev->kobj, \"device\");\n\tWARN_ON(ret);\n\n\tprintk(KERN_INFO PDCS_PREFIX \": changed \\\"%s\\\" path to \\\"%s\\\"\\n\",\n\t\tentry->name, buf);\n\t\n\treturn count;\n}\n\n \nstatic ssize_t\npdcspath_layer_read(struct pdcspath_entry *entry, char *buf)\n{\n\tchar *out = buf;\n\tstruct pdc_module_path *devpath;\n\tshort i;\n\n\tif (!entry || !buf)\n\t\treturn -EINVAL;\n\t\n\tread_lock(&entry->rw_lock);\n\tdevpath = &entry->devpath;\n\ti = entry->ready;\n\tread_unlock(&entry->rw_lock);\n\n\tif (!i)\t \n\t\treturn -ENODATA;\n\t\n\tfor (i = 0; i < 6 && devpath->layers[i]; i++)\n\t\tout += sprintf(out, \"%u \", devpath->layers[i]);\n\n\tout += sprintf(out, \"\\n\");\n\t\n\treturn out - buf;\n}\n\n \nstatic ssize_t\npdcspath_layer_write(struct pdcspath_entry *entry, const char *buf, size_t count)\n{\n\tunsigned int layers[6];  \n\tunsigned short i;\n\tchar in[64], *temp;\n\n\tif (!entry || !buf || !count)\n\t\treturn -EINVAL;\n\n\t \n\tcount = min_t(size_t, count, sizeof(in)-1);\n\tstrscpy(in, buf, count + 1);\n\t\n\t \n\tmemset(&layers, 0, sizeof(layers));\n\t\n\t \n\tif (unlikely(!isdigit(*in)))\n\t\treturn -EINVAL;\n\tlayers[0] = simple_strtoul(in, NULL, 10);\n\tDPRINTK(\"%s: layer[0]: %d\\n\", __func__, layers[0]);\n\t\n\ttemp = in;\n\tfor (i=1; ((temp = strchr(temp, '.'))) && (likely(i<6)); i++) {\n\t\tif (unlikely(!isdigit(*(++temp))))\n\t\t\treturn -EINVAL;\n\t\tlayers[i] = simple_strtoul(temp, NULL, 10);\n\t\tDPRINTK(\"%s: layer[%d]: %d\\n\", __func__, i, layers[i]);\n\t}\n\t\t\n\t \n\twrite_lock(&entry->rw_lock);\n\t\n\t \n\tmemcpy(&entry->devpath.layers, &layers, sizeof(layers));\n\t\n\t \n\tpdcspath_store(entry);\n\twrite_unlock(&entry->rw_lock);\n\t\n\tprintk(KERN_INFO PDCS_PREFIX \": changed \\\"%s\\\" layers to \\\"%s\\\"\\n\",\n\t\tentry->name, buf);\n\t\n\treturn count;\n}\n\n \nstatic ssize_t\npdcspath_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tstruct pdcspath_entry *entry = to_pdcspath_entry(kobj);\n\tstruct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);\n\tssize_t ret = 0;\n\n\tif (pdcs_attr->show)\n\t\tret = pdcs_attr->show(entry, buf);\n\n\treturn ret;\n}\n\n \nstatic ssize_t\npdcspath_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct pdcspath_entry *entry = to_pdcspath_entry(kobj);\n\tstruct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);\n\tssize_t ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (pdcs_attr->store)\n\t\tret = pdcs_attr->store(entry, buf, count);\n\n\treturn ret;\n}\n\nstatic const struct sysfs_ops pdcspath_attr_ops = {\n\t.show = pdcspath_attr_show,\n\t.store = pdcspath_attr_store,\n};\n\n \nstatic PATHS_ATTR(hwpath, 0644, pdcspath_hwpath_read, pdcspath_hwpath_write);\nstatic PATHS_ATTR(layer, 0644, pdcspath_layer_read, pdcspath_layer_write);\n\nstatic struct attribute *paths_subsys_attrs[] = {\n\t&paths_attr_hwpath.attr,\n\t&paths_attr_layer.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(paths_subsys);\n\n \nstatic struct kobj_type ktype_pdcspath = {\n\t.sysfs_ops = &pdcspath_attr_ops,\n\t.default_groups = paths_subsys_groups,\n};\n\n \nstatic PDCSPATH_ENTRY(PDCS_ADDR_PPRI, primary);\nstatic PDCSPATH_ENTRY(PDCS_ADDR_PCON, console);\nstatic PDCSPATH_ENTRY(PDCS_ADDR_PALT, alternative);\nstatic PDCSPATH_ENTRY(PDCS_ADDR_PKBD, keyboard);\n\n \nstatic struct pdcspath_entry *pdcspath_entries[] = {\n\t&pdcspath_entry_primary,\n\t&pdcspath_entry_alternative,\n\t&pdcspath_entry_console,\n\t&pdcspath_entry_keyboard,\n\tNULL,\n};\n\n\n \n\n \nstatic ssize_t pdcs_size_read(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tchar *out = buf;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\tout += sprintf(out, \"%ld\\n\", pdcs_size);\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_auto_read(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf, int knob)\n{\n\tchar *out = buf;\n\tstruct pdcspath_entry *pathentry;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\tpathentry = &pdcspath_entry_primary;\n\n\tread_lock(&pathentry->rw_lock);\n\tout += sprintf(out, \"%s\\n\", (pathentry->devpath.path.flags & knob) ?\n\t\t\t\t\t\"On\" : \"Off\");\n\tread_unlock(&pathentry->rw_lock);\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_autoboot_read(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn pdcs_auto_read(kobj, attr, buf, PF_AUTOBOOT);\n}\n\n \nstatic ssize_t pdcs_autosearch_read(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\treturn pdcs_auto_read(kobj, attr, buf, PF_AUTOSEARCH);\n}\n\n \nstatic ssize_t pdcs_timer_read(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tchar *out = buf;\n\tstruct pdcspath_entry *pathentry;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\tpathentry = &pdcspath_entry_primary;\n\n\t \n\tread_lock(&pathentry->rw_lock);\n\tout += sprintf(out, \"%u\\n\", (pathentry->devpath.path.flags & PF_TIMER) ?\n\t\t\t\t(1 << (pathentry->devpath.path.flags & PF_TIMER)) : 0);\n\tread_unlock(&pathentry->rw_lock);\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_osid_read(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\tchar *out = buf;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tout += sprintf(out, \"%s dependent data (0x%.4x)\\n\",\n\t\tos_id_to_string(pdcs_osid), pdcs_osid);\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_osdep1_read(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tchar *out = buf;\n\tu32 result[4];\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (pdc_stable_read(PDCS_ADDR_OSD1, &result, sizeof(result)) != PDC_OK)\n\t\treturn -EIO;\n\n\tout += sprintf(out, \"0x%.8x\\n\", result[0]);\n\tout += sprintf(out, \"0x%.8x\\n\", result[1]);\n\tout += sprintf(out, \"0x%.8x\\n\", result[2]);\n\tout += sprintf(out, \"0x%.8x\\n\", result[3]);\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_diagnostic_read(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tchar *out = buf;\n\tu32 result;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\tif (pdc_stable_read(PDCS_ADDR_DIAG, &result, sizeof(result)) != PDC_OK)\n\t\treturn -EIO;\n\n\tout += sprintf(out, \"0x%.4x\\n\", (result >> 16));\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_fastsize_read(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\tchar *out = buf;\n\tu32 result;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\t \n\tif (pdc_stable_read(PDCS_ADDR_FSIZ, &result, sizeof(result)) != PDC_OK)\n\t\treturn -EIO;\n\n\tif ((result & 0x0F) < 0x0E)\n\t\tout += sprintf(out, \"%d kB\", (1<<(result & 0x0F))*256);\n\telse\n\t\tout += sprintf(out, \"All\");\n\tout += sprintf(out, \"\\n\");\n\t\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_osdep2_read(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tchar *out = buf;\n\tunsigned long size;\n\tunsigned short i;\n\tu32 result;\n\n\tif (unlikely(pdcs_size <= 224))\n\t\treturn -ENODATA;\n\n\tsize = pdcs_size - 224;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tfor (i=0; i<size; i+=4) {\n\t\tif (unlikely(pdc_stable_read(PDCS_ADDR_OSD2 + i, &result,\n\t\t\t\t\tsizeof(result)) != PDC_OK))\n\t\t\treturn -EIO;\n\t\tout += sprintf(out, \"0x%.8x\\n\", result);\n\t}\n\n\treturn out - buf;\n}\n\n \nstatic ssize_t pdcs_auto_write(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, const char *buf,\n\t\t\t       size_t count, int knob)\n{\n\tstruct pdcspath_entry *pathentry;\n\tunsigned char flags;\n\tchar in[8], *temp;\n\tchar c;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!buf || !count)\n\t\treturn -EINVAL;\n\n\t \n\tcount = min_t(size_t, count, sizeof(in)-1);\n\tstrscpy(in, buf, count + 1);\n\n\t \n\tpathentry = &pdcspath_entry_primary;\n\t\n\t \n\tread_lock(&pathentry->rw_lock);\n\tflags = pathentry->devpath.path.flags;\n\tread_unlock(&pathentry->rw_lock);\n\t\n\tDPRINTK(\"%s: flags before: 0x%X\\n\", __func__, flags);\n\n\ttemp = skip_spaces(in);\n\n\tc = *temp++ - '0';\n\tif ((c != 0) && (c != 1))\n\t\tgoto parse_error;\n\tif (c == 0)\n\t\tflags &= ~knob;\n\telse\n\t\tflags |= knob;\n\t\n\tDPRINTK(\"%s: flags after: 0x%X\\n\", __func__, flags);\n\t\t\n\t \n\twrite_lock(&pathentry->rw_lock);\n\t\n\t \n\tpathentry->devpath.path.flags = flags;\n\t\t\n\t \n\tpdcspath_store(pathentry);\n\twrite_unlock(&pathentry->rw_lock);\n\t\n\tprintk(KERN_INFO PDCS_PREFIX \": changed \\\"%s\\\" to \\\"%s\\\"\\n\",\n\t\t(knob & PF_AUTOBOOT) ? \"autoboot\" : \"autosearch\",\n\t\t(flags & knob) ? \"On\" : \"Off\");\n\t\n\treturn count;\n\nparse_error:\n\tprintk(KERN_WARNING \"%s: Parse error: expect \\\"n\\\" (n == 0 or 1)\\n\", __func__);\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t pdcs_autoboot_write(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\treturn pdcs_auto_write(kobj, attr, buf, count, PF_AUTOBOOT);\n}\n\n \nstatic ssize_t pdcs_autosearch_write(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn pdcs_auto_write(kobj, attr, buf, count, PF_AUTOSEARCH);\n}\n\n \nstatic ssize_t pdcs_osdep1_write(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tu8 in[16];\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!buf || !count)\n\t\treturn -EINVAL;\n\n\tif (unlikely(pdcs_osid != OS_ID_LINUX))\n\t\treturn -EPERM;\n\n\tif (count > 16)\n\t\treturn -EMSGSIZE;\n\n\t \n\tmemset(in, 0, 16);\n\tmemcpy(in, buf, count);\n\n\tif (pdc_stable_write(PDCS_ADDR_OSD1, &in, sizeof(in)) != PDC_OK)\n\t\treturn -EIO;\n\n\treturn count;\n}\n\n \nstatic ssize_t pdcs_osdep2_write(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned long size;\n\tunsigned short i;\n\tu8 in[4];\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!buf || !count)\n\t\treturn -EINVAL;\n\n\tif (unlikely(pdcs_size <= 224))\n\t\treturn -ENOSYS;\n\n\tif (unlikely(pdcs_osid != OS_ID_LINUX))\n\t\treturn -EPERM;\n\n\tsize = pdcs_size - 224;\n\n\tif (count > size)\n\t\treturn -EMSGSIZE;\n\n\t \n\n\tfor (i=0; i<count; i+=4) {\n\t\tmemset(in, 0, 4);\n\t\tmemcpy(in, buf+i, (count-i < 4) ? count-i : 4);\n\t\tif (unlikely(pdc_stable_write(PDCS_ADDR_OSD2 + i, &in,\n\t\t\t\t\tsizeof(in)) != PDC_OK))\n\t\t\treturn -EIO;\n\t}\n\n\treturn count;\n}\n\n \nstatic PDCS_ATTR(size, 0444, pdcs_size_read, NULL);\nstatic PDCS_ATTR(autoboot, 0644, pdcs_autoboot_read, pdcs_autoboot_write);\nstatic PDCS_ATTR(autosearch, 0644, pdcs_autosearch_read, pdcs_autosearch_write);\nstatic PDCS_ATTR(timer, 0444, pdcs_timer_read, NULL);\nstatic PDCS_ATTR(osid, 0444, pdcs_osid_read, NULL);\nstatic PDCS_ATTR(osdep1, 0600, pdcs_osdep1_read, pdcs_osdep1_write);\nstatic PDCS_ATTR(diagnostic, 0400, pdcs_diagnostic_read, NULL);\nstatic PDCS_ATTR(fastsize, 0400, pdcs_fastsize_read, NULL);\nstatic PDCS_ATTR(osdep2, 0600, pdcs_osdep2_read, pdcs_osdep2_write);\n\nstatic struct attribute *pdcs_subsys_attrs[] = {\n\t&pdcs_attr_size.attr,\n\t&pdcs_attr_autoboot.attr,\n\t&pdcs_attr_autosearch.attr,\n\t&pdcs_attr_timer.attr,\n\t&pdcs_attr_osid.attr,\n\t&pdcs_attr_osdep1.attr,\n\t&pdcs_attr_diagnostic.attr,\n\t&pdcs_attr_fastsize.attr,\n\t&pdcs_attr_osdep2.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pdcs_attr_group = {\n\t.attrs = pdcs_subsys_attrs,\n};\n\nstatic struct kobject *stable_kobj;\nstatic struct kset *paths_kset;\n\n \nstatic inline int __init\npdcs_register_pathentries(void)\n{\n\tunsigned short i;\n\tstruct pdcspath_entry *entry;\n\tint err;\n\t\n\t \n\tfor (i = 0; (entry = pdcspath_entries[i]); i++)\n\t\trwlock_init(&entry->rw_lock);\n\n\tfor (i = 0; (entry = pdcspath_entries[i]); i++) {\n\t\twrite_lock(&entry->rw_lock);\n\t\terr = pdcspath_fetch(entry);\n\t\twrite_unlock(&entry->rw_lock);\n\n\t\tif (err < 0)\n\t\t\tcontinue;\n\n\t\tentry->kobj.kset = paths_kset;\n\t\terr = kobject_init_and_add(&entry->kobj, &ktype_pdcspath, NULL,\n\t\t\t\t\t   \"%s\", entry->name);\n\t\tif (err) {\n\t\t\tkobject_put(&entry->kobj);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\twrite_lock(&entry->rw_lock);\n\t\tentry->ready = 2;\n\t\twrite_unlock(&entry->rw_lock);\n\t\t\n\t\t \n\t\tif (entry->dev) {\n\t\t\terr = sysfs_create_link(&entry->kobj, &entry->dev->kobj, \"device\");\n\t\t\tWARN_ON(err);\n\t\t}\n\n\t\tkobject_uevent(&entry->kobj, KOBJ_ADD);\n\t}\n\t\n\treturn 0;\n}\n\n \nstatic inline void\npdcs_unregister_pathentries(void)\n{\n\tunsigned short i;\n\tstruct pdcspath_entry *entry;\n\t\n\tfor (i = 0; (entry = pdcspath_entries[i]); i++) {\n\t\tread_lock(&entry->rw_lock);\n\t\tif (entry->ready >= 2)\n\t\t\tkobject_put(&entry->kobj);\n\t\tread_unlock(&entry->rw_lock);\n\t}\n}\n\n \nstatic int __init\npdc_stable_init(void)\n{\n\tint rc = 0, error;\n\tu32 result;\n\n\t \n\tif (pdc_stable_get_size(&pdcs_size) != PDC_OK) \n\t\treturn -ENODEV;\n\n\t \n\tif (pdcs_size < 96)\n\t\treturn -ENODATA;\n\n\tprintk(KERN_INFO PDCS_PREFIX \" facility v%s\\n\", PDCS_VERSION);\n\n\t \n\tif (pdc_stable_read(PDCS_ADDR_OSID, &result, sizeof(result)) != PDC_OK)\n\t\treturn -EIO;\n\n\t \n\tpdcs_osid = (u16)(result >> 16);\n\n\t \n\tstable_kobj = kobject_create_and_add(\"stable\", firmware_kobj);\n\tif (!stable_kobj) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_firmreg;\n\t}\n\n\t \n\terror = sysfs_create_group(stable_kobj, &pdcs_attr_group);\n\tif (error) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_ksetreg;\n\t}\n\n\t \n\tpaths_kset = kset_create_and_add(\"paths\", NULL, stable_kobj);\n\tif (!paths_kset) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_ksetreg;\n\t}\n\n\t \n\tif ((rc = pdcs_register_pathentries()))\n\t\tgoto fail_pdcsreg;\n\n\treturn rc;\n\t\nfail_pdcsreg:\n\tpdcs_unregister_pathentries();\n\tkset_unregister(paths_kset);\n\t\nfail_ksetreg:\n\tkobject_put(stable_kobj);\n\t\nfail_firmreg:\n\tprintk(KERN_INFO PDCS_PREFIX \" bailing out\\n\");\n\treturn rc;\n}\n\nstatic void __exit\npdc_stable_exit(void)\n{\n\tpdcs_unregister_pathentries();\n\tkset_unregister(paths_kset);\n\tkobject_put(stable_kobj);\n}\n\n\nmodule_init(pdc_stable_init);\nmodule_exit(pdc_stable_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}