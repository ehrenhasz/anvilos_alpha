{
  "module_name": "superio.c",
  "hash_id": "3bb2d1f495a402d2766e689b4d55f20e7d75a7000d7ce9b961970ff81ed41e2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/superio.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/serial.h>\n#include <linux/pci.h>\n#include <linux/parport.h>\n#include <linux/parport_pc.h>\n#include <linux/termios.h>\n#include <linux/tty.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/delay.h>\n\n#include <asm/io.h>\n#include <asm/hardware.h>\n#include <asm/superio.h>\n\nstatic struct superio_device sio_dev;\n\n\n#undef DEBUG_SUPERIO_INIT\n\n#ifdef DEBUG_SUPERIO_INIT\n#define DBG_INIT(x...)  printk(x)\n#else\n#define DBG_INIT(x...)\n#endif\n\n#define SUPERIO\t\"SuperIO\"\n#define PFX\tSUPERIO \": \"\n\nstatic irqreturn_t\nsuperio_interrupt(int parent_irq, void *devp)\n{\n\tu8 results;\n\tu8 local_irq;\n\n\t \n\toutb (OCW3_POLL,IC_PIC1+0);\n\n\tresults = inb(IC_PIC1+0);\n\n\t \n\tif ((results & 0x80) == 0) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tlocal_irq = results & 0x0f;\n\n\tif (local_irq == 2 || local_irq > 7) {\n\t\tprintk(KERN_ERR PFX \"slave interrupted!\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (local_irq == 7) {\n\n\t\t \n\n\t\toutb(OCW3_ISR,IC_PIC1+0);\n\t\tresults = inb(IC_PIC1+0);\n\t\tif ((results & 0x80) == 0) {  \n\t\t\tprintk(KERN_WARNING PFX \"spurious interrupt!\\n\");\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tgeneric_handle_irq(local_irq);\n\n\t \n\toutb((OCW2_SEOI|local_irq),IC_PIC1 + 0);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\nsuperio_init(struct pci_dev *pcidev)\n{\n\tstruct superio_device *sio = &sio_dev;\n\tstruct pci_dev *pdev = sio->lio_pdev;\n\tu16 word;\n\tint ret;\n\n\tif (sio->suckyio_irq_enabled)\n\t\treturn;\n\n\tBUG_ON(!pdev);\n\tBUG_ON(!sio->usb_pdev);\n\n\t \n\tpdev->irq = sio->usb_pdev->irq;\n\n\t \n\tsio->usb_pdev->irq = superio_fixup_irq(sio->usb_pdev);\n\n\tprintk(KERN_INFO PFX \"Found NS87560 Legacy I/O device at %s (IRQ %i)\\n\",\n\t       pci_name(pdev), pdev->irq);\n\n\tpci_read_config_dword (pdev, SIO_SP1BAR, &sio->sp1_base);\n\tsio->sp1_base &= ~1;\n\tprintk(KERN_INFO PFX \"Serial port 1 at 0x%x\\n\", sio->sp1_base);\n\n\tpci_read_config_dword (pdev, SIO_SP2BAR, &sio->sp2_base);\n\tsio->sp2_base &= ~1;\n\tprintk(KERN_INFO PFX \"Serial port 2 at 0x%x\\n\", sio->sp2_base);\n\n\tpci_read_config_dword (pdev, SIO_PPBAR, &sio->pp_base);\n\tsio->pp_base &= ~1;\n\tprintk(KERN_INFO PFX \"Parallel port at 0x%x\\n\", sio->pp_base);\n\n\tpci_read_config_dword (pdev, SIO_FDCBAR, &sio->fdc_base);\n\tsio->fdc_base &= ~1;\n\tprintk(KERN_INFO PFX \"Floppy controller at 0x%x\\n\", sio->fdc_base);\n\tpci_read_config_dword (pdev, SIO_ACPIBAR, &sio->acpi_base);\n\tsio->acpi_base &= ~1;\n\tprintk(KERN_INFO PFX \"ACPI at 0x%x\\n\", sio->acpi_base);\n\n\trequest_region (IC_PIC1, 0x1f, \"pic1\");\n\trequest_region (IC_PIC2, 0x1f, \"pic2\");\n\trequest_region (sio->acpi_base, 0x1f, \"acpi\");\n\n\t \n\tpci_read_config_word (pdev, PCI_COMMAND, &word);\n\tword |= PCI_COMMAND_SERR | PCI_COMMAND_PARITY | PCI_COMMAND_IO;\n\tpci_write_config_word (pdev, PCI_COMMAND, word);\n\n\tpci_set_master (pdev);\n\tret = pci_enable_device(pdev);\n\tBUG_ON(ret < 0);\t \n\n\t \n\n\t \n\tpci_write_config_dword (pdev, 0x64,         0x82000000U);\n\n\t \n\tpci_write_config_dword (pdev, TRIGGER_2,    0x07654300U);\n\n\t \n\tpci_write_config_dword (pdev, CFG_IR_INTAB, 0x00001000U);\n\n\t \n\tpci_write_config_dword (pdev, CFG_IR_USB, 0x4c880000U);\n\n\t \n\toutb (0x11,IC_PIC1+0);\t \n\toutb (0x00,IC_PIC1+1);\t \n\toutb (0x04,IC_PIC1+1);\t \n\toutb (0x01,IC_PIC1+1);\t \n\n\t \n\toutb (0xff,IC_PIC1+1);\t \n\toutb (0xc2,IC_PIC1+0);   \n\n\t \n\toutb (0x11,IC_PIC2+0);\t \n\toutb (0x00,IC_PIC2+1);\t \n\toutb (0x02,IC_PIC2+1);\t \n\toutb (0x01,IC_PIC2+1);\t \n\t\t\n\t \n\toutb (0xff,IC_PIC1+1);\t \n\toutb (0x68,IC_PIC1+0);\t \n\n\t \n\toutb (0xff,IC_PIC1+1);\n\n\t \n\toutb(1, sio->acpi_base + USB_REG_CR);\n\tif (inb(sio->acpi_base + USB_REG_CR) & 1)\n\t\tprintk(KERN_INFO PFX \"USB regulator enabled\\n\");\n\telse\n\t\tprintk(KERN_ERR PFX \"USB regulator not initialized!\\n\");\n\n\tif (request_irq(pdev->irq, superio_interrupt, 0,\n\t\t\tSUPERIO, (void *)sio)) {\n\n\t\tprintk(KERN_ERR PFX \"could not get irq\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tsio->suckyio_irq_enabled = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_87560_LIO, superio_init);\n\nstatic void superio_mask_irq(struct irq_data *d)\n{\n\tunsigned int irq = d->irq;\n\tu8 r8;\n\n\tif ((irq < 1) || (irq == 2) || (irq > 7)) {\n\t\tprintk(KERN_ERR PFX \"Illegal irq number.\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t \n\n\tr8 = inb(IC_PIC1+1);\n\tr8 |= (1 << irq);\n\toutb (r8,IC_PIC1+1);\n}\n\nstatic void superio_unmask_irq(struct irq_data *d)\n{\n\tunsigned int irq = d->irq;\n\tu8 r8;\n\n\tif ((irq < 1) || (irq == 2) || (irq > 7)) {\n\t\tprintk(KERN_ERR PFX \"Illegal irq number (%d).\\n\", irq);\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t \n\tr8 = inb(IC_PIC1+1);\n\tr8 &= ~(1 << irq);\n\toutb (r8,IC_PIC1+1);\n}\n\nstatic struct irq_chip superio_interrupt_type = {\n\t.name\t\t=\tSUPERIO,\n\t.irq_unmask\t=\tsuperio_unmask_irq,\n\t.irq_mask\t=\tsuperio_mask_irq,\n};\n\n#ifdef DEBUG_SUPERIO_INIT\nstatic unsigned short expected_device[3] = {\n\tPCI_DEVICE_ID_NS_87415,\n\tPCI_DEVICE_ID_NS_87560_LIO,\n\tPCI_DEVICE_ID_NS_87560_USB\n};\n#endif\n\nint superio_fixup_irq(struct pci_dev *pcidev)\n{\n\tint local_irq, i;\n\n#ifdef DEBUG_SUPERIO_INIT\n\tint fn;\n\tfn = PCI_FUNC(pcidev->devfn);\n\n\t \n\tif (expected_device[fn] != pcidev->device) {\n\t\tBUG();\n\t\treturn -1;\n\t}\n\tprintk(KERN_DEBUG \"superio_fixup_irq(%s) ven 0x%x dev 0x%x from %ps\\n\",\n\t\tpci_name(pcidev),\n\t\tpcidev->vendor, pcidev->device,\n\t\t__builtin_return_address(0));\n#endif\n\n\tfor (i = 0; i < 16; i++) {\n\t\tirq_set_chip_and_handler(i, &superio_interrupt_type,\n\t\t\t\t\t handle_simple_irq);\n\t}\n\n\t \n\n\tswitch(pcidev->device) {\n\tcase PCI_DEVICE_ID_NS_87415:\t\t \n\t\tlocal_irq = IDE_IRQ;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NS_87560_LIO:\t \n\t\tsio_dev.lio_pdev = pcidev;\t \n\t\treturn -1;\n\tcase PCI_DEVICE_ID_NS_87560_USB:\t \n\t\tsio_dev.usb_pdev = pcidev;\t \n\t\tlocal_irq = USB_IRQ;\n\t\tbreak;\n\tdefault:\n\t\tlocal_irq = -1;\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\treturn local_irq;\n}\n\nstatic void __init superio_serial_init(void)\n{\n#ifdef CONFIG_SERIAL_8250\n\tint retval;\n\tstruct uart_port serial_port;\n\n\tmemset(&serial_port, 0, sizeof(serial_port));\n\tserial_port.iotype\t= UPIO_PORT;\n\tserial_port.type\t= PORT_16550A;\n\tserial_port.uartclk\t= 115200*16;\n\tserial_port.flags\t= UPF_FIXED_PORT | UPF_FIXED_TYPE |\n\t\t\t\t  UPF_BOOT_AUTOCONF;\n\n\t \n\tserial_port.iobase\t= sio_dev.sp1_base;\n\tserial_port.irq\t\t= SP1_IRQ;\n\tserial_port.line\t= 0;\n\tretval = early_serial_setup(&serial_port);\n\tif (retval < 0) {\n\t\tprintk(KERN_WARNING PFX \"Register Serial #0 failed.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tserial_port.iobase\t= sio_dev.sp2_base;\n\tserial_port.irq\t\t= SP2_IRQ;\n\tserial_port.line\t= 1;\n\tretval = early_serial_setup(&serial_port);\n\tif (retval < 0)\n\t\tprintk(KERN_WARNING PFX \"Register Serial #1 failed.\\n\");\n#endif  \n}\n\n\nstatic void __init superio_parport_init(void)\n{\n#ifdef CONFIG_PARPORT_PC\n\tif (!parport_pc_probe_port(sio_dev.pp_base,\n\t\t\t0  ,\n\t\t\tPAR_IRQ, \n\t\t\tPARPORT_DMA_NONE  ,\n\t\t\tNULL  ,\n\t\t\t0  ))\n\n\t\tprintk(KERN_WARNING PFX \"Probing parallel port failed.\\n\");\n#endif\t \n}\n\n\nstatic void superio_fixup_pci(struct pci_dev *pdev)\n{\n\tu8 prog;\n\n\tpdev->class |= 0x5;\n\tpci_write_config_byte(pdev, PCI_CLASS_PROG, pdev->class);\n\n\tpci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);\n\tprintk(\"PCI: Enabled native mode for NS87415 (pif=0x%x)\\n\", prog);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_87415, superio_fixup_pci);\n\n\nstatic int __init\nsuperio_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct superio_device *sio = &sio_dev;\n\n\t \n\tDBG_INIT(\"superio_probe(%s) ven 0x%x dev 0x%x sv 0x%x sd 0x%x class 0x%x\\n\",\n\t\tpci_name(dev),\n\t\tdev->vendor, dev->device,\n\t\tdev->subsystem_vendor, dev->subsystem_device,\n\t\tdev->class);\n\n\tBUG_ON(!sio->suckyio_irq_enabled);\t \n\n\tif (dev->device == PCI_DEVICE_ID_NS_87560_LIO) {\t \n\t\tsuperio_parport_init();\n\t\tsuperio_serial_init();\n\t\t \n\t\treturn 0;\n\t} else if (dev->device == PCI_DEVICE_ID_NS_87415) {\t \n\t\tDBG_INIT(\"superio_probe: ignoring IDE 87415\\n\");\n\t} else if (dev->device == PCI_DEVICE_ID_NS_87560_USB) {\t \n\t\tDBG_INIT(\"superio_probe: ignoring USB OHCI controller\\n\");\n\t} else {\n\t\tDBG_INIT(\"superio_probe: WTF? Fire Extinguisher?\\n\");\n\t}\n\n\t \n\treturn -ENODEV;\n}\n\nstatic const struct pci_device_id superio_tbl[] __initconst = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_87560_LIO) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_87560_USB) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_87415) },\n\t{ 0, }\n};\n\nstatic struct pci_driver superio_driver __refdata = {\n\t.name =         SUPERIO,\n\t.id_table =     superio_tbl,\n\t.probe =        superio_probe,\n};\n\nmodule_pci_driver(superio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}