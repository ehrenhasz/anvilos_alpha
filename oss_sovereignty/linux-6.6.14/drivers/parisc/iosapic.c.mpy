{
  "module_name": "iosapic.c",
  "hash_id": "e737f0e56ab4db7cd45c9fb9614d55affc1694d15d548021b0bc7f08c5851d49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/iosapic.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n\n#include <asm/pdc.h>\n#include <asm/pdcpat.h>\n#ifdef CONFIG_SUPERIO\n#include <asm/superio.h>\n#endif\n\n#include <asm/ropes.h>\n#include \"iosapic_private.h\"\n\n#define MODULE_NAME \"iosapic\"\n\n \n#undef PCI_BRIDGE_FUNCS\n#undef DEBUG_IOSAPIC\n#undef DEBUG_IOSAPIC_IRT\n\n\n#ifdef DEBUG_IOSAPIC\n#define DBG(x...) printk(x)\n#else  \n#define DBG(x...)\n#endif  \n\n#ifdef DEBUG_IOSAPIC_IRT\n#define DBG_IRT(x...) printk(x)\n#else\n#define DBG_IRT(x...)\n#endif\n\n#ifdef CONFIG_64BIT\n#define COMPARE_IRTE_ADDR(irte, hpa)\t((irte)->dest_iosapic_addr == (hpa))\n#else\n#define COMPARE_IRTE_ADDR(irte, hpa)\t\\\n\t\t((irte)->dest_iosapic_addr == ((hpa) | 0xffffffff00000000ULL))\n#endif\n\n#define IOSAPIC_REG_SELECT              0x00\n#define IOSAPIC_REG_WINDOW              0x10\n#define IOSAPIC_REG_EOI                 0x40\n\n#define IOSAPIC_REG_VERSION\t\t0x1\n\n#define IOSAPIC_IRDT_ENTRY(idx)\t\t(0x10+(idx)*2)\n#define IOSAPIC_IRDT_ENTRY_HI(idx)\t(0x11+(idx)*2)\n\nstatic inline unsigned int iosapic_read(void __iomem *iosapic, unsigned int reg)\n{\n\twritel(reg, iosapic + IOSAPIC_REG_SELECT);\n\treturn readl(iosapic + IOSAPIC_REG_WINDOW);\n}\n\nstatic inline void iosapic_write(void __iomem *iosapic, unsigned int reg, u32 val)\n{\n\twritel(reg, iosapic + IOSAPIC_REG_SELECT);\n\twritel(val, iosapic + IOSAPIC_REG_WINDOW);\n}\n\n#define IOSAPIC_VERSION_MASK\t0x000000ff\n#define\tIOSAPIC_VERSION(ver)\t((int) (ver & IOSAPIC_VERSION_MASK))\n\n#define IOSAPIC_MAX_ENTRY_MASK          0x00ff0000\n#define IOSAPIC_MAX_ENTRY_SHIFT         0x10\n#define\tIOSAPIC_IRDT_MAX_ENTRY(ver)\t\\\n\t(int) (((ver) & IOSAPIC_MAX_ENTRY_MASK) >> IOSAPIC_MAX_ENTRY_SHIFT)\n\n \n#define IOSAPIC_IRDT_ENABLE       0x10000\n#define IOSAPIC_IRDT_PO_LOW       0x02000\n#define IOSAPIC_IRDT_LEVEL_TRIG   0x08000\n#define IOSAPIC_IRDT_MODE_LPRI    0x00100\n\n \n#define IOSAPIC_IRDT_ID_EID_SHIFT              0x10\n\n\nstatic DEFINE_SPINLOCK(iosapic_lock);\n\nstatic inline void iosapic_eoi(__le32 __iomem *addr, __le32 data)\n{\n\t__raw_writel((__force u32)data, addr);\n}\n\n \nstatic struct irt_entry *irt_cell;\nstatic size_t irt_num_entry;\n\nstatic struct irt_entry *iosapic_alloc_irt(int num_entries)\n{\n\treturn kcalloc(num_entries, sizeof(struct irt_entry), GFP_KERNEL);\n}\n\n \n\n\nstatic int __init\niosapic_load_irt(unsigned long cell_num, struct irt_entry **irt)\n{\n\tlong status;               \n\tstruct irt_entry *table;   \n\tunsigned long num_entries = 0UL;\n\n\tBUG_ON(!irt);\n\n\tif (is_pdc_pat()) {\n\t\t \n\t\tDBG(\"calling get_irt_size (cell %ld)\\n\", cell_num);\n\t\tstatus = pdc_pat_get_irt_size(&num_entries, cell_num);\n\t\tDBG(\"get_irt_size: %ld\\n\", status);\n\n\t\tBUG_ON(status != PDC_OK);\n\t\tBUG_ON(num_entries == 0);\n\n\t\t \n\t\ttable = iosapic_alloc_irt(num_entries);\n\t\tif (table == NULL) {\n\t\t\tprintk(KERN_WARNING MODULE_NAME \": read_irt : can \"\n\t\t\t\t\t\"not alloc mem for IRT\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tstatus = pdc_pat_get_irt(table, cell_num);\n\t\tDBG(\"pdc_pat_get_irt: %ld\\n\", status);\n\t\tWARN_ON(status != PDC_OK);\n\t} else {\n\t\t \n\t\tif (irt_cell)\n\t\t\treturn 0;\n\n\t\t \n\t\tstatus = pdc_pci_irt_size(&num_entries, 0);\n\t\tDBG(\"pdc_pci_irt_size: %ld\\n\", status);\n\n\t\tif (status != PDC_OK) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tBUG_ON(num_entries == 0);\n\n\t\ttable = iosapic_alloc_irt(num_entries);\n\t\tif (!table) {\n\t\t\tprintk(KERN_WARNING MODULE_NAME \": read_irt : can \"\n\t\t\t\t\t\"not alloc mem for IRT\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tstatus = pdc_pci_irt(num_entries, 0, table);\n\t\tBUG_ON(status != PDC_OK);\n\t}\n\n\t \n\t*irt = table;\n\n#ifdef DEBUG_IOSAPIC_IRT\n{\n\tstruct irt_entry *p = table;\n\tint i;\n\n\tprintk(MODULE_NAME \" Interrupt Routing Table (cell %ld)\\n\", cell_num);\n\tprintk(MODULE_NAME \" start = 0x%p num_entries %ld entry_size %d\\n\",\n\t\ttable,\n\t\tnum_entries,\n\t\t(int) sizeof(struct irt_entry));\n\n\tfor (i = 0 ; i < num_entries ; i++, p++) {\n\t\tprintk(MODULE_NAME \" %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x\\n\",\n\t\tp->entry_type, p->entry_length, p->interrupt_type,\n\t\tp->polarity_trigger, p->src_bus_irq_devno, p->src_bus_id,\n\t\tp->src_seg_id, p->dest_iosapic_intin,\n\t\t((u32 *) p)[2],\n\t\t((u32 *) p)[3]\n\t\t);\n\t}\n}\n#endif  \n\n\treturn num_entries;\n}\n\n\nstatic int __init iosapic_init(void)\n{\n\tunsigned long cell = 0;\n\n#ifdef __LP64__\n\tif (is_pdc_pat()) {\n\t\tint status;\n\t\tstruct pdc_pat_cell_num cell_info;\n\n\t\tstatus = pdc_pat_cell_get_number(&cell_info);\n\t\tif (status == PDC_OK) {\n\t\t\tcell = cell_info.cell_num;\n\t\t}\n\t}\n#endif\n\n\t \n\tirt_num_entry = iosapic_load_irt(cell, &irt_cell);\n\tif (irt_num_entry == 0)\n\t\tirt_cell = NULL;\t \n\n\treturn 0;\n}\narch_initcall(iosapic_init);\n\n\n \nstatic struct irt_entry *\nirt_find_irqline(struct iosapic_info *isi, u8 slot, u8 intr_pin)\n{\n\tstruct irt_entry *i = irt_cell;\n\tint cnt;\t \n\tu8 irq_devno = (slot << IRT_DEV_SHIFT) | (intr_pin-1);\n\n\tDBG_IRT(\"irt_find_irqline() SLOT %d pin %d\\n\", slot, intr_pin);\n\n\tfor (cnt=0; cnt < irt_num_entry; cnt++, i++) {\n\n\t\t \n\t\tif (i->entry_type != IRT_IOSAPIC_TYPE) {\n\t\t\tDBG_IRT(KERN_WARNING MODULE_NAME \":find_irqline(0x%p): skipping entry %d type %d\\n\", i, cnt, i->entry_type);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (i->entry_length != IRT_IOSAPIC_LENGTH) {\n\t\t\tDBG_IRT(KERN_WARNING MODULE_NAME \":find_irqline(0x%p): skipping entry %d  length %d\\n\", i, cnt, i->entry_length);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i->interrupt_type != IRT_VECTORED_INTR) {\n\t\t\tDBG_IRT(KERN_WARNING MODULE_NAME \":find_irqline(0x%p): skipping entry  %d interrupt_type %d\\n\", i, cnt, i->interrupt_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!COMPARE_IRTE_ADDR(i, isi->isi_hpa))\n\t\t\tcontinue;\n\n\t\tif ((i->src_bus_irq_devno & IRT_IRQ_DEVNO_MASK) != irq_devno)\n\t\t\tcontinue;\n\n\t\t \n\n\t\t \n\t\treturn i;\n\t}\n\n\tprintk(KERN_WARNING MODULE_NAME \": 0x%lx : no IRT entry for slot %d, pin %d\\n\",\n\t\t\tisi->isi_hpa, slot, intr_pin);\n\treturn NULL;\n}\n\n\n \nstatic struct irt_entry *\niosapic_xlate_pin(struct iosapic_info *isi, struct pci_dev *pcidev)\n{\n\tu8 intr_pin, intr_slot;\n\n\tpci_read_config_byte(pcidev, PCI_INTERRUPT_PIN, &intr_pin);\n\n\tDBG_IRT(\"iosapic_xlate_pin(%s) SLOT %d pin %d\\n\",\n\t\tpcidev->slot_name, PCI_SLOT(pcidev->devfn), intr_pin);\n\n\tif (intr_pin == 0) {\n\t\t \n\t\treturn NULL;\n\t}\n\n\t \n\tif (pcidev->bus->parent) {\n\t\t \n#ifdef PCI_BRIDGE_FUNCS\n\t\t \n\t\tif (pci_bridge_funcs->xlate_intr_line) {\n\t\t\tintr_pin = pci_bridge_funcs->xlate_intr_line(pcidev);\n\t\t}\n#else\t \n\t\tstruct pci_bus *p = pcidev->bus;\n\t\t \n\t\tintr_pin = pci_swizzle_interrupt_pin(pcidev, intr_pin);\n#endif  \n\n\t\t \n\t\twhile (p->parent->parent)\n\t\t\tp = p->parent;\n\n\t\tintr_slot = PCI_SLOT(p->self->devfn);\n\t} else {\n\t\tintr_slot = PCI_SLOT(pcidev->devfn);\n\t}\n\tDBG_IRT(\"iosapic_xlate_pin:  bus %d slot %d pin %d\\n\",\n\t\t\tpcidev->bus->busn_res.start, intr_slot, intr_pin);\n\n\treturn irt_find_irqline(isi, intr_slot, intr_pin);\n}\n\nstatic void iosapic_rd_irt_entry(struct vector_info *vi , u32 *dp0, u32 *dp1)\n{\n\tstruct iosapic_info *isp = vi->iosapic;\n\tu8 idx = vi->irqline;\n\n\t*dp0 = iosapic_read(isp->addr, IOSAPIC_IRDT_ENTRY(idx));\n\t*dp1 = iosapic_read(isp->addr, IOSAPIC_IRDT_ENTRY_HI(idx));\n}\n\n\nstatic void iosapic_wr_irt_entry(struct vector_info *vi, u32 dp0, u32 dp1)\n{\n\tstruct iosapic_info *isp = vi->iosapic;\n\n\tDBG_IRT(\"iosapic_wr_irt_entry(): irq %d hpa %lx 0x%x 0x%x\\n\",\n\t\tvi->irqline, isp->isi_hpa, dp0, dp1);\n\n\tiosapic_write(isp->addr, IOSAPIC_IRDT_ENTRY(vi->irqline), dp0);\n\n\t \n\tdp0 = readl(isp->addr+IOSAPIC_REG_WINDOW);\n\n\tiosapic_write(isp->addr, IOSAPIC_IRDT_ENTRY_HI(vi->irqline), dp1);\n\n\t \n\tdp1 = readl(isp->addr+IOSAPIC_REG_WINDOW);\n}\n\n \nstatic void\niosapic_set_irt_data( struct vector_info *vi, u32 *dp0, u32 *dp1)\n{\n\tu32 mode = 0;\n\tstruct irt_entry *p = vi->irte;\n\n\tif ((p->polarity_trigger & IRT_PO_MASK) == IRT_ACTIVE_LO)\n\t\tmode |= IOSAPIC_IRDT_PO_LOW;\n\n\tif (((p->polarity_trigger >> IRT_EL_SHIFT) & IRT_EL_MASK) == IRT_LEVEL_TRIG)\n\t\tmode |= IOSAPIC_IRDT_LEVEL_TRIG;\n\n\t \n\n\t*dp0 = mode | (u32) vi->txn_data;\n\n\t \n\tif (is_pdc_pat()) {\n\t\t \n\t\t*dp1 = (u32) (vi->txn_addr);\n\t} else {\n\t\t \n\t\t*dp1 = (((u32)vi->txn_addr & 0x0ff00000) >> 4) |\n\t\t\t(((u32)vi->txn_addr & 0x000ff000) << 12);\n\t}\n\tDBG_IRT(\"iosapic_set_irt_data(): 0x%x 0x%x\\n\", *dp0, *dp1);\n}\n\n\nstatic void iosapic_mask_irq(struct irq_data *d)\n{\n\tunsigned long flags;\n\tstruct vector_info *vi = irq_data_get_irq_chip_data(d);\n\tu32 d0, d1;\n\n\tspin_lock_irqsave(&iosapic_lock, flags);\n\tiosapic_rd_irt_entry(vi, &d0, &d1);\n\td0 |= IOSAPIC_IRDT_ENABLE;\n\tiosapic_wr_irt_entry(vi, d0, d1);\n\tspin_unlock_irqrestore(&iosapic_lock, flags);\n}\n\nstatic void iosapic_unmask_irq(struct irq_data *d)\n{\n\tstruct vector_info *vi = irq_data_get_irq_chip_data(d);\n\tu32 d0, d1;\n\n\t \n\tWARN_ON(vi->txn_irq  == 0);\n\n\tiosapic_set_irt_data(vi, &d0, &d1);\n\tiosapic_wr_irt_entry(vi, d0, d1);\n\n#ifdef DEBUG_IOSAPIC_IRT\n{\n\tu32 *t = (u32 *) ((ulong) vi->eoi_addr & ~0xffUL);\n\tprintk(\"iosapic_enable_irq(): regs %p\", vi->eoi_addr);\n\tfor ( ; t < vi->eoi_addr; t++)\n\t\tprintk(\" %x\", readl(t));\n\tprintk(\"\\n\");\n}\n\nprintk(\"iosapic_enable_irq(): sel \");\n{\n\tstruct iosapic_info *isp = vi->iosapic;\n\n\tfor (d0=0x10; d0<0x1e; d0++) {\n\t\td1 = iosapic_read(isp->addr, d0);\n\t\tprintk(\" %x\", d1);\n\t}\n}\nprintk(\"\\n\");\n#endif\n\n\t \n\tDBG(KERN_DEBUG \"enable_irq(%d): eoi(%p, 0x%x)\\n\", d->irq,\n\t\t\tvi->eoi_addr, vi->eoi_data);\n\tiosapic_eoi(vi->eoi_addr, vi->eoi_data);\n}\n\nstatic void iosapic_eoi_irq(struct irq_data *d)\n{\n\tstruct vector_info *vi = irq_data_get_irq_chip_data(d);\n\n\tiosapic_eoi(vi->eoi_addr, vi->eoi_data);\n\tcpu_eoi_irq(d);\n}\n\n#ifdef CONFIG_SMP\nstatic int iosapic_set_affinity_irq(struct irq_data *d,\n\t\t\t\t    const struct cpumask *dest, bool force)\n{\n\tstruct vector_info *vi = irq_data_get_irq_chip_data(d);\n\tu32 d0, d1, dummy_d0;\n\tunsigned long flags;\n\tint dest_cpu;\n\n\tdest_cpu = cpu_check_affinity(d, dest);\n\tif (dest_cpu < 0)\n\t\treturn -1;\n\n\tirq_data_update_affinity(d, cpumask_of(dest_cpu));\n\tvi->txn_addr = txn_affinity_addr(d->irq, dest_cpu);\n\n\tspin_lock_irqsave(&iosapic_lock, flags);\n\t \n\tiosapic_rd_irt_entry(vi, &d0, &d1);\n\tiosapic_set_irt_data(vi, &dummy_d0, &d1);\n\tiosapic_wr_irt_entry(vi, d0, d1);\n\tspin_unlock_irqrestore(&iosapic_lock, flags);\n\n\treturn 0;\n}\n#endif\n\nstatic struct irq_chip iosapic_interrupt_type = {\n\t.name\t\t=\t\"IO-SAPIC-level\",\n\t.irq_unmask\t=\tiosapic_unmask_irq,\n\t.irq_mask\t=\tiosapic_mask_irq,\n\t.irq_ack\t=\tcpu_ack_irq,\n\t.irq_eoi\t=\tiosapic_eoi_irq,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity =\tiosapic_set_affinity_irq,\n#endif\n};\n\nint iosapic_fixup_irq(void *isi_obj, struct pci_dev *pcidev)\n{\n\tstruct iosapic_info *isi = isi_obj;\n\tstruct irt_entry *irte = NULL;   \n\tstruct vector_info *vi;\n\tint isi_line;\t \n\n\tif (!isi) {\n\t\tprintk(KERN_WARNING MODULE_NAME \": hpa not registered for %s\\n\",\n\t\t\tpci_name(pcidev));\n\t\treturn -1;\n\t}\n\n#ifdef CONFIG_SUPERIO\n\t \n\tif (is_superio_device(pcidev)) {\n\t\t \n\t\tpcidev->irq = superio_fixup_irq(pcidev);\n\n\t\t \n\t\tif (PCI_FUNC(pcidev->devfn) != SUPERIO_USB_FN)\n\t\t\treturn pcidev->irq;\n\t}\n#endif  \n\n\t \n\tirte = iosapic_xlate_pin(isi, pcidev);\n\tif (!irte) {\n\t\tprintk(\"iosapic: no IRTE for %s (IRQ not connected?)\\n\",\n\t\t\t\tpci_name(pcidev));\n\t\treturn -1;\n\t}\n\tDBG_IRT(\"iosapic_fixup_irq(): irte %p %x %x %x %x %x %x %x %x\\n\",\n\t\tirte,\n\t\tirte->entry_type,\n\t\tirte->entry_length,\n\t\tirte->polarity_trigger,\n\t\tirte->src_bus_irq_devno,\n\t\tirte->src_bus_id,\n\t\tirte->src_seg_id,\n\t\tirte->dest_iosapic_intin,\n\t\t(u32) irte->dest_iosapic_addr);\n\tisi_line = irte->dest_iosapic_intin;\n\n\t \n\tvi = isi->isi_vector + isi_line;\n\tDBG_IRT(\"iosapic_fixup_irq:  line %d vi 0x%p\\n\", isi_line, vi);\n\n\t \n\tif (vi->irte)\n\t\tgoto out;\n\n\tvi->irte = irte;\n\n\t \n\tvi->txn_irq = txn_alloc_irq(8);\n\n\tif (vi->txn_irq < 0)\n\t\tpanic(\"I/O sapic: couldn't get TXN IRQ\\n\");\n\n\t \n\tvi->txn_addr = txn_alloc_addr(vi->txn_irq);\n\tvi->txn_data = txn_alloc_data(vi->txn_irq);\n\n\tvi->eoi_addr = isi->addr + IOSAPIC_REG_EOI;\n\tvi->eoi_data = cpu_to_le32(vi->txn_data);\n\n\tcpu_claim_irq(vi->txn_irq, &iosapic_interrupt_type, vi);\n\n out:\n\tpcidev->irq = vi->txn_irq;\n\n\tDBG_IRT(\"iosapic_fixup_irq() %d:%d %x %x line %d irq %d\\n\",\n\t\tPCI_SLOT(pcidev->devfn), PCI_FUNC(pcidev->devfn),\n\t\tpcidev->vendor, pcidev->device, isi_line, pcidev->irq);\n\n\treturn pcidev->irq;\n}\n\nstatic struct iosapic_info *iosapic_list;\n\n#ifdef CONFIG_64BIT\nint iosapic_serial_irq(struct parisc_device *dev)\n{\n\tstruct iosapic_info *isi;\n\tstruct irt_entry *irte;\n\tstruct vector_info *vi;\n\tint cnt;\n\tint intin;\n\n\tintin = (dev->mod_info >> 24) & 15;\n\n\t \n\tfor (cnt = 0; cnt < irt_num_entry; cnt++) {\n\t\tirte = &irt_cell[cnt];\n\t\tif (COMPARE_IRTE_ADDR(irte, dev->mod0) &&\n\t\t    irte->dest_iosapic_intin == intin)\n\t\t\tbreak;\n\t}\n\tif (cnt >= irt_num_entry)\n\t\treturn 0;  \n\n\tDBG_IRT(\"iosapic_serial_irq(): irte %p %x %x %x %x %x %x %x %x\\n\",\n\t\tirte,\n\t\tirte->entry_type,\n\t\tirte->entry_length,\n\t\tirte->polarity_trigger,\n\t\tirte->src_bus_irq_devno,\n\t\tirte->src_bus_id,\n\t\tirte->src_seg_id,\n\t\tirte->dest_iosapic_intin,\n\t\t(u32) irte->dest_iosapic_addr);\n\n\t \n\tfor (isi = iosapic_list; isi; isi = isi->isi_next)\n\t\tif (isi->isi_hpa == dev->mod0)\n\t\t\tbreak;\n\tif (!isi)\n\t\treturn 0;  \n\n\t \n\tvi = isi->isi_vector + intin;\n\tDBG_IRT(\"iosapic_serial_irq:  line %d vi 0x%p\\n\", iosapic_intin, vi);\n\n\t \n\tif (vi->irte)\n\t\tgoto out;\n\n\tvi->irte = irte;\n\n\t \n\tvi->txn_irq = txn_alloc_irq(8);\n\n\tif (vi->txn_irq < 0)\n\t\tpanic(\"I/O sapic: couldn't get TXN IRQ\\n\");\n\n\t \n\tvi->txn_addr = txn_alloc_addr(vi->txn_irq);\n\tvi->txn_data = txn_alloc_data(vi->txn_irq);\n\n\tvi->eoi_addr = isi->addr + IOSAPIC_REG_EOI;\n\tvi->eoi_data = cpu_to_le32(vi->txn_data);\n\n\tcpu_claim_irq(vi->txn_irq, &iosapic_interrupt_type, vi);\n\n out:\n\n\treturn vi->txn_irq;\n}\nEXPORT_SYMBOL(iosapic_serial_irq);\n#endif\n\n\n \nstatic unsigned int\niosapic_rd_version(struct iosapic_info *isi)\n{\n\treturn iosapic_read(isi->addr, IOSAPIC_REG_VERSION);\n}\n\n\n \nvoid *iosapic_register(unsigned long hpa, void __iomem *vaddr)\n{\n\tstruct iosapic_info *isi = NULL;\n\tstruct irt_entry *irte = irt_cell;\n\tstruct vector_info *vip;\n\tint cnt;\t \n\n\t \n\tfor (cnt=0; cnt < irt_num_entry; cnt++, irte++) {\n\t\tWARN_ON(IRT_IOSAPIC_TYPE != irte->entry_type);\n\t\tif (COMPARE_IRTE_ADDR(irte, hpa))\n\t\t\tbreak;\n\t}\n\n\tif (cnt >= irt_num_entry) {\n\t\tDBG(\"iosapic_register() ignoring 0x%lx (NOT FOUND)\\n\", hpa);\n\t\treturn NULL;\n\t}\n\n\tisi = kzalloc(sizeof(struct iosapic_info), GFP_KERNEL);\n\tif (!isi) {\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tisi->addr = vaddr;\n\tisi->isi_hpa = hpa;\n\tisi->isi_version = iosapic_rd_version(isi);\n\tisi->isi_num_vectors = IOSAPIC_IRDT_MAX_ENTRY(isi->isi_version) + 1;\n\n\tvip = isi->isi_vector = kcalloc(isi->isi_num_vectors,\n\t\t\t\t\tsizeof(struct vector_info), GFP_KERNEL);\n\tif (vip == NULL) {\n\t\tkfree(isi);\n\t\treturn NULL;\n\t}\n\n\tfor (cnt=0; cnt < isi->isi_num_vectors; cnt++, vip++) {\n\t\tvip->irqline = (unsigned char) cnt;\n\t\tvip->iosapic = isi;\n\t}\n\tisi->isi_next = iosapic_list;\n\tiosapic_list = isi;\n\treturn isi;\n}\n\n\n#ifdef DEBUG_IOSAPIC\n\nstatic void\niosapic_prt_irt(void *irt, long num_entry)\n{\n\tunsigned int i, *irp = (unsigned int *) irt;\n\n\n\tprintk(KERN_DEBUG MODULE_NAME \": Interrupt Routing Table (%lx entries)\\n\", num_entry);\n\n\tfor (i=0; i<num_entry; i++, irp += 4) {\n\t\tprintk(KERN_DEBUG \"%p : %2d %.8x %.8x %.8x %.8x\\n\",\n\t\t\t\t\tirp, i, irp[0], irp[1], irp[2], irp[3]);\n\t}\n}\n\n\nstatic void\niosapic_prt_vi(struct vector_info *vi)\n{\n\tprintk(KERN_DEBUG MODULE_NAME \": vector_info[%d] is at %p\\n\", vi->irqline, vi);\n\tprintk(KERN_DEBUG \"\\t\\tstatus:\t %.4x\\n\", vi->status);\n\tprintk(KERN_DEBUG \"\\t\\ttxn_irq:  %d\\n\",  vi->txn_irq);\n\tprintk(KERN_DEBUG \"\\t\\ttxn_addr: %lx\\n\", vi->txn_addr);\n\tprintk(KERN_DEBUG \"\\t\\ttxn_data: %lx\\n\", vi->txn_data);\n\tprintk(KERN_DEBUG \"\\t\\teoi_addr: %p\\n\",  vi->eoi_addr);\n\tprintk(KERN_DEBUG \"\\t\\teoi_data: %x\\n\",  vi->eoi_data);\n}\n\n\nstatic void\niosapic_prt_isi(struct iosapic_info *isi)\n{\n\tprintk(KERN_DEBUG MODULE_NAME \": io_sapic_info at %p\\n\", isi);\n\tprintk(KERN_DEBUG \"\\t\\tisi_hpa:       %lx\\n\", isi->isi_hpa);\n\tprintk(KERN_DEBUG \"\\t\\tisi_status:    %x\\n\", isi->isi_status);\n\tprintk(KERN_DEBUG \"\\t\\tisi_version:   %x\\n\", isi->isi_version);\n\tprintk(KERN_DEBUG \"\\t\\tisi_vector:    %p\\n\", isi->isi_vector);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}