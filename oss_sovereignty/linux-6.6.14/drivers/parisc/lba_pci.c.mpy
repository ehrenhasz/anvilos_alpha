{
  "module_name": "lba_pci.c",
  "hash_id": "d6bc59730cd55bd381988c5fe505463223ce1f798ee574bd63554db80a6487bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/lba_pci.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\t\t \n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n\n#include <asm/byteorder.h>\n#include <asm/pdc.h>\n#include <asm/pdcpat.h>\n#include <asm/page.h>\n\n#include <asm/ropes.h>\n#include <asm/hardware.h>\t \n#include <asm/parisc-device.h>\n#include <asm/io.h>\t\t \n\n#include \"iommu.h\"\n\n#undef DEBUG_LBA\t \n#undef DEBUG_LBA_PORT\t \n#undef DEBUG_LBA_CFG\t \n#undef DEBUG_LBA_PAT\t \n\n#undef FBB_SUPPORT\t \n\n\n#ifdef DEBUG_LBA\n#define DBG(x...)\tprintk(x)\n#else\n#define DBG(x...)\n#endif\n\n#ifdef DEBUG_LBA_PORT\n#define DBG_PORT(x...)\tprintk(x)\n#else\n#define DBG_PORT(x...)\n#endif\n\n#ifdef DEBUG_LBA_CFG\n#define DBG_CFG(x...)\tprintk(x)\n#else\n#define DBG_CFG(x...)\n#endif\n\n#ifdef DEBUG_LBA_PAT\n#define DBG_PAT(x...)\tprintk(x)\n#else\n#define DBG_PAT(x...)\n#endif\n\n\n \n\n#define MODULE_NAME \"LBA\"\n\n \n#define LBA_PORT_BASE\t(PCI_F_EXTEND | 0xfee00000UL)\nstatic void __iomem *astro_iop_base __read_mostly;\n\nstatic u32 lba_t32;\n\n \n#define LBA_FLAG_SKIP_PROBE\t0x10\n\n#define LBA_SKIP_PROBE(d) ((d)->flags & LBA_FLAG_SKIP_PROBE)\n\nstatic inline struct lba_device *LBA_DEV(struct pci_hba_data *hba)\n{\n\treturn container_of(hba, struct lba_device, hba);\n}\n\n \n#define LBA_MAX_NUM_BUSES 8\n\n \n#define READ_U8(addr)  __raw_readb(addr)\n#define READ_U16(addr) __raw_readw(addr)\n#define READ_U32(addr) __raw_readl(addr)\n#define WRITE_U8(value, addr)  __raw_writeb(value, addr)\n#define WRITE_U16(value, addr) __raw_writew(value, addr)\n#define WRITE_U32(value, addr) __raw_writel(value, addr)\n\n#define READ_REG8(addr)  readb(addr)\n#define READ_REG16(addr) readw(addr)\n#define READ_REG32(addr) readl(addr)\n#define READ_REG64(addr) readq(addr)\n#define WRITE_REG8(value, addr)  writeb(value, addr)\n#define WRITE_REG16(value, addr) writew(value, addr)\n#define WRITE_REG32(value, addr) writel(value, addr)\n\n\n#define LBA_CFG_TOK(bus,dfn) ((u32) ((bus)<<16 | (dfn)<<8))\n#define LBA_CFG_BUS(tok)  ((u8) ((tok)>>16))\n#define LBA_CFG_DEV(tok)  ((u8) ((tok)>>11) & 0x1f)\n#define LBA_CFG_FUNC(tok) ((u8) ((tok)>>8 ) & 0x7)\n\n\n \n#define ROPES_PER_IOC\t8\n#define LBA_NUM(x)    ((((unsigned long) x) >> 13) & (ROPES_PER_IOC-1))\n\n\nstatic void\nlba_dump_res(struct resource *r, int d)\n{\n\tint i;\n\n\tif (NULL == r)\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"(%p)\", r->parent);\n\tfor (i = d; i ; --i) printk(\" \");\n\tprintk(KERN_DEBUG \"%p [%lx,%lx]/%lx\\n\", r,\n\t\t(long)r->start, (long)r->end, r->flags);\n\tlba_dump_res(r->child, d+2);\n\tlba_dump_res(r->sibling, d);\n}\n\n\n \n\nstatic int lba_device_present(u8 bus, u8 dfn, struct lba_device *d)\n{\n\tu8 first_bus = d->hba.hba_bus->busn_res.start;\n\tu8 last_sub_bus = d->hba.hba_bus->busn_res.end;\n\n\tif ((bus < first_bus) ||\n\t    (bus > last_sub_bus) ||\n\t    ((bus - first_bus) >= LBA_MAX_NUM_BUSES)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n\n#define LBA_CFG_SETUP(d, tok) {\t\t\t\t\\\n     \t\t\t\\\n    error_config = READ_REG32(d->hba.base_addr + LBA_ERROR_CONFIG);\t\t\\\n\\\n     \t\t\t\\\n    status_control = READ_REG32(d->hba.base_addr + LBA_STAT_CTL);\t\t\\\n\\\n     \t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tarb_mask = READ_REG32(d->hba.base_addr + LBA_ARB_MASK);\t\t\\\n\\\n\t \t\t\t\t\t\t\t\t\\\n\tWRITE_REG32(0x1, d->hba.base_addr + LBA_ARB_MASK);\t\t\\\n\\\n     \t\t\t\t\t\t\t\t\t\\\n    WRITE_REG32(error_config | LBA_SMART_MODE, d->hba.base_addr + LBA_ERROR_CONFIG);\t\\\n}\n\n\n#define LBA_CFG_PROBE(d, tok) {\t\t\t\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    WRITE_REG32(tok | PCI_VENDOR_ID, (d)->hba.base_addr + LBA_PCI_CFG_ADDR);\\\n     \t\t\t\t\t\t\t\t\t\\\n    lba_t32 = READ_REG32((d)->hba.base_addr + LBA_PCI_CFG_ADDR);\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    WRITE_REG32(~0, (d)->hba.base_addr + LBA_PCI_CFG_DATA);\t\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    lba_t32 = READ_REG32((d)->hba.base_addr + LBA_PCI_CFG_ADDR);\t\\\n}\n\n\n \n\n#define LBA_MASTER_ABORT_ERROR 0xc\n#define LBA_FATAL_ERROR 0x10\n\n#define LBA_CFG_MASTER_ABORT_CHECK(d, base, tok, error) {\t\t\\\n    u32 error_status = 0;\t\t\t\t\t\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    WRITE_REG32(status_control | CLEAR_ERRLOG_ENABLE, base + LBA_STAT_CTL); \\\n    error_status = READ_REG32(base + LBA_ERROR_STATUS);\t\t\\\n    if ((error_status & 0x1f) != 0) {\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\terror = 1;\t\t\t\t\t\t\t\\\n\tif ((error_status & LBA_FATAL_ERROR) == 0) {\t\t\t\\\n\t     \t\t\t\t\t\t\t\t\\\n\t    WRITE_REG32(status_control | CLEAR_ERRLOG, base + LBA_STAT_CTL); \\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#define LBA_CFG_TR4_ADDR_SETUP(d, addr)\t\t\t\t\t\\\n\tWRITE_REG32(((addr) & ~3), (d)->hba.base_addr + LBA_PCI_CFG_ADDR);\n\n#define LBA_CFG_ADDR_SETUP(d, addr) {\t\t\t\t\t\\\n    WRITE_REG32(((addr) & ~3), (d)->hba.base_addr + LBA_PCI_CFG_ADDR);\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    lba_t32 = READ_REG32((d)->hba.base_addr + LBA_PCI_CFG_ADDR);\t\\\n}\n\n\n#define LBA_CFG_RESTORE(d, base) {\t\t\t\t\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    WRITE_REG32(status_control, base + LBA_STAT_CTL);\t\t\t\\\n     \t\t\t\t\t\t\t\t\t\\\n    WRITE_REG32(error_config, base + LBA_ERROR_CONFIG);\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tWRITE_REG32(arb_mask, base + LBA_ARB_MASK);\t\t\t\\\n}\n\n\n\nstatic unsigned int\nlba_rd_cfg(struct lba_device *d, u32 tok, u8 reg, u32 size)\n{\n\tu32 data = ~0U;\n\tint error = 0;\n\tu32 arb_mask = 0;\t \n\tu32 error_config = 0;\t \n\tu32 status_control = 0;\t \n\n\tLBA_CFG_SETUP(d, tok);\n\tLBA_CFG_PROBE(d, tok);\n\tLBA_CFG_MASTER_ABORT_CHECK(d, d->hba.base_addr, tok, error);\n\tif (!error) {\n\t\tvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\n\n\t\tLBA_CFG_ADDR_SETUP(d, tok | reg);\n\t\tswitch (size) {\n\t\tcase 1: data = (u32) READ_REG8(data_reg + (reg & 3)); break;\n\t\tcase 2: data = (u32) READ_REG16(data_reg+ (reg & 2)); break;\n\t\tcase 4: data = READ_REG32(data_reg); break;\n\t\t}\n\t}\n\tLBA_CFG_RESTORE(d, d->hba.base_addr);\n\treturn(data);\n}\n\n\nstatic int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)\n{\n\tstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\n\tu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\n\tu32 tok = LBA_CFG_TOK(local_bus, devfn);\n\tvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\n\n\tif ((pos > 255) || (devfn > 255))\n\t\treturn -EINVAL;\n\n \n\t  {\n\t\t \n\t\t*data = lba_rd_cfg(d, tok, pos, size);\n\t\tDBG_CFG(\"%s(%x+%2x) -> 0x%x (a)\\n\", __func__, tok, pos, *data);\n\t\treturn 0;\n\t}\n\n\tif (LBA_SKIP_PROBE(d) && !lba_device_present(bus->busn_res.start, devfn, d)) {\n\t\tDBG_CFG(\"%s(%x+%2x) -> -1 (b)\\n\", __func__, tok, pos);\n\t\t \n\t\t*data = ~0U;\n\t\treturn(0);\n\t}\n\n\t \n\tLBA_CFG_ADDR_SETUP(d, tok | pos);\n\tswitch(size) {\n\tcase 1: *data = READ_REG8 (data_reg + (pos & 3)); break;\n\tcase 2: *data = READ_REG16(data_reg + (pos & 2)); break;\n\tcase 4: *data = READ_REG32(data_reg); break;\n\t}\n\tDBG_CFG(\"%s(%x+%2x) -> 0x%x (c)\\n\", __func__, tok, pos, *data);\n\treturn 0;\n}\n\n\nstatic void\nlba_wr_cfg(struct lba_device *d, u32 tok, u8 reg, u32 data, u32 size)\n{\n\tint error __maybe_unused = 0;\n\tu32 arb_mask = 0;\n\tu32 error_config = 0;\n\tu32 status_control = 0;\n\tvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\n\n\tLBA_CFG_SETUP(d, tok);\n\tLBA_CFG_ADDR_SETUP(d, tok | reg);\n\tswitch (size) {\n\tcase 1: WRITE_REG8 (data, data_reg + (reg & 3)); break;\n\tcase 2: WRITE_REG16(data, data_reg + (reg & 2)); break;\n\tcase 4: WRITE_REG32(data, data_reg);             break;\n\t}\n\tLBA_CFG_MASTER_ABORT_CHECK(d, d->hba.base_addr, tok, error);\n\tLBA_CFG_RESTORE(d, d->hba.base_addr);\n}\n\n\n \n\nstatic int elroy_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)\n{\n\tstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\n\tu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\n\tu32 tok = LBA_CFG_TOK(local_bus,devfn);\n\n\tif ((pos > 255) || (devfn > 255))\n\t\treturn -EINVAL;\n\n\tif (!LBA_SKIP_PROBE(d)) {\n\t\t \n\t\tlba_wr_cfg(d, tok, pos, (u32) data, size);\n\t\tDBG_CFG(\"%s(%x+%2x) = 0x%x (a)\\n\", __func__, tok, pos,data);\n\t\treturn 0;\n\t}\n\n\tif (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->busn_res.start, devfn, d))) {\n\t\tDBG_CFG(\"%s(%x+%2x) = 0x%x (b)\\n\", __func__, tok, pos,data);\n\t\treturn 1;  \n\t}\n\n\tDBG_CFG(\"%s(%x+%2x) = 0x%x (c)\\n\", __func__, tok, pos, data);\n\n\t \n\tLBA_CFG_ADDR_SETUP(d, tok | pos);\n\tswitch(size) {\n\tcase 1: WRITE_REG8 (data, d->hba.base_addr + LBA_PCI_CFG_DATA + (pos & 3));\n\t\t   break;\n\tcase 2: WRITE_REG16(data, d->hba.base_addr + LBA_PCI_CFG_DATA + (pos & 2));\n\t\t   break;\n\tcase 4: WRITE_REG32(data, d->hba.base_addr + LBA_PCI_CFG_DATA);\n\t\t   break;\n\t}\n\t \n\tlba_t32 = READ_REG32(d->hba.base_addr + LBA_PCI_CFG_ADDR);\n\treturn 0;\n}\n\n\nstatic struct pci_ops elroy_cfg_ops = {\n\t.read =\t\telroy_cfg_read,\n\t.write =\telroy_cfg_write,\n};\n\n \n\nstatic int mercury_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)\n{\n\tstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\n\tu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\n\tu32 tok = LBA_CFG_TOK(local_bus, devfn);\n\tvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\n\n\tif ((pos > 255) || (devfn > 255))\n\t\treturn -EINVAL;\n\n\tLBA_CFG_TR4_ADDR_SETUP(d, tok | pos);\n\tswitch(size) {\n\tcase 1:\n\t\t*data = READ_REG8(data_reg + (pos & 3));\n\t\tbreak;\n\tcase 2:\n\t\t*data = READ_REG16(data_reg + (pos & 2));\n\t\tbreak;\n\tcase 4:\n\t\t*data = READ_REG32(data_reg);             break;\n\t\tbreak;\n\t}\n\n\tDBG_CFG(\"mercury_cfg_read(%x+%2x) -> 0x%x\\n\", tok, pos, *data);\n\treturn 0;\n}\n\n \n\nstatic int mercury_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)\n{\n\tstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\n\tvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\n\tu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\n\tu32 tok = LBA_CFG_TOK(local_bus,devfn);\n\n\tif ((pos > 255) || (devfn > 255))\n\t\treturn -EINVAL;\n\n\tDBG_CFG(\"%s(%x+%2x) <- 0x%x (c)\\n\", __func__, tok, pos, data);\n\n\tLBA_CFG_TR4_ADDR_SETUP(d, tok | pos);\n\tswitch(size) {\n\tcase 1:\n\t\tWRITE_REG8 (data, data_reg + (pos & 3));\n\t\tbreak;\n\tcase 2:\n\t\tWRITE_REG16(data, data_reg + (pos & 2));\n\t\tbreak;\n\tcase 4:\n\t\tWRITE_REG32(data, data_reg);\n\t\tbreak;\n\t}\n\n\t \n\tlba_t32 = READ_U32(d->hba.base_addr + LBA_PCI_CFG_ADDR);\n\treturn 0;\n}\n\nstatic struct pci_ops mercury_cfg_ops = {\n\t.read =\t\tmercury_cfg_read,\n\t.write =\tmercury_cfg_write,\n};\n\n\nstatic void\nlba_bios_init(void)\n{\n\tDBG(MODULE_NAME \": lba_bios_init\\n\");\n}\n\n\n#ifdef CONFIG_64BIT\n\n \nstatic unsigned long\ntruncate_pat_collision(struct resource *root, struct resource *new)\n{\n\tunsigned long start = new->start;\n\tunsigned long end = new->end;\n\tstruct resource *tmp = root->child;\n\n\tif (end <= start || start < root->start || !tmp)\n\t\treturn 0;\n\n\t \n\twhile (tmp && tmp->end < start)\n\t\ttmp = tmp->sibling;\n\n\t \n\tif (!tmp)  return 0;\n\n\t \n\tif (tmp->start >= end) return 0;\n\n\tif (tmp->start <= start) {\n\t\t \n\t\tnew->start = tmp->end + 1;\n\n\t\tif (tmp->end >= end) {\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t} \n\n\tif (tmp->end < end ) {\n\t\t \n\t\tnew->end = tmp->start - 1;\n\t}\n\n\tprintk(KERN_WARNING \"LBA: Truncating lmmio_space [%lx/%lx] \"\n\t\t\t\t\t\"to [%lx,%lx]\\n\",\n\t\t\tstart, end,\n\t\t\t(long)new->start, (long)new->end );\n\n\treturn 0;\t \n}\n\n \nstatic unsigned long\nextend_lmmio_len(unsigned long start, unsigned long end, unsigned long lba_len)\n{\n\tstruct resource *tmp;\n\n\t \n\tif (boot_cpu_data.cpu_type < mako)\n\t\treturn end;\n\n\tpr_debug(\"LMMIO mismatch: PAT length = 0x%lx, MASK register = 0x%lx\\n\",\n\t\tend - start, lba_len);\n\n\tlba_len = min(lba_len+1, 256UL*1024*1024);  \n\n\tpr_debug(\"LBA: lmmio_space [0x%lx-0x%lx] - original\\n\", start, end);\n\n\n\tend += lba_len;\n\tif (end < start)  \n\t\tend = -1ULL;\n\n\tpr_debug(\"LBA: lmmio_space [0x%lx-0x%lx] - current\\n\", start, end);\n\n\t \n\tfor (tmp = iomem_resource.child; tmp; tmp = tmp->sibling) {\n\t\tpr_debug(\"LBA: testing %pR\\n\", tmp);\n\t\tif (tmp->start == start)\n\t\t\tcontinue;  \n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\tif (tmp->start > end)\n\t\t\tcontinue;\n\t\tif (end >= tmp->start)\n\t\t\tend = tmp->start - 1;\n\t}\n\n\tpr_info(\"LBA: lmmio_space [0x%lx-0x%lx] - new\\n\", start, end);\n\n\t \n\treturn end;\n}\n\n#else\n#define truncate_pat_collision(r,n)  (0)\n#endif\n\nstatic void pcibios_allocate_bridge_resources(struct pci_dev *dev)\n{\n\tint idx;\n\tstruct resource *r;\n\n\tfor (idx = PCI_BRIDGE_RESOURCES; idx < PCI_NUM_RESOURCES; idx++) {\n\t\tr = &dev->resource[idx];\n\t\tif (!r->flags)\n\t\t\tcontinue;\n\t\tif (r->parent)\t \n\t\t\tcontinue;\n\t\tif (!r->start || pci_claim_bridge_resource(dev, idx) < 0) {\n\t\t\t \n\t\t\tr->start = r->end = 0;\n\t\t\tr->flags = 0;\n\t\t}\n\t}\n}\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *child;\n\n\t \n\tif (bus->self)\n\t\tpcibios_allocate_bridge_resources(bus->self);\n\tlist_for_each_entry(child, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(child);\n}\n\n\n \nstatic void\nlba_fixup_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n#ifdef FBB_SUPPORT\n\tu16 status;\n#endif\n\tstruct lba_device *ldev = LBA_DEV(parisc_walk_tree(bus->bridge));\n\n\tDBG(\"lba_fixup_bus(0x%p) bus %d platform_data 0x%p\\n\",\n\t\tbus, (int)bus->busn_res.start, bus->bridge->platform_data);\n\n\t \n\tif (bus->parent) {\n\t\t \n\t\tpci_read_bridge_bases(bus);\n\n\t\t \n\t\tpcibios_allocate_bus_resources(bus);\n\t} else {\n\t\t \n\t\tint err;\n\n\t\tDBG(\"lba_fixup_bus() %s [%lx/%lx]/%lx\\n\",\n\t\t\tldev->hba.io_space.name,\n\t\t\tldev->hba.io_space.start, ldev->hba.io_space.end,\n\t\t\tldev->hba.io_space.flags);\n\t\tDBG(\"lba_fixup_bus() %s [%lx/%lx]/%lx\\n\",\n\t\t\tldev->hba.lmmio_space.name,\n\t\t\tldev->hba.lmmio_space.start, ldev->hba.lmmio_space.end,\n\t\t\tldev->hba.lmmio_space.flags);\n\n\t\terr = request_resource(&ioport_resource, &(ldev->hba.io_space));\n\t\tif (err < 0) {\n\t\t\tlba_dump_res(&ioport_resource, 2);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (ldev->hba.elmmio_space.flags) {\n\t\t\terr = request_resource(&iomem_resource,\n\t\t\t\t\t&(ldev->hba.elmmio_space));\n\t\t\tif (err < 0) {\n\n\t\t\t\tprintk(\"FAILED: lba_fixup_bus() request for \"\n\t\t\t\t\t\t\"elmmio_space [%lx/%lx]\\n\",\n\t\t\t\t\t\t(long)ldev->hba.elmmio_space.start,\n\t\t\t\t\t\t(long)ldev->hba.elmmio_space.end);\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t}\n\t\t}\n\n\t\tif (ldev->hba.lmmio_space.flags) {\n\t\t\terr = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));\n\t\t\tif (err < 0) {\n\t\t\t\tprintk(KERN_ERR \"FAILED: lba_fixup_bus() request for \"\n\t\t\t\t\t\"lmmio_space [%lx/%lx]\\n\",\n\t\t\t\t\t(long)ldev->hba.lmmio_space.start,\n\t\t\t\t\t(long)ldev->hba.lmmio_space.end);\n\t\t\t}\n\t\t}\n\n#ifdef CONFIG_64BIT\n\t\t \n\t\tif (ldev->hba.gmmio_space.flags) {\n\t\t\terr = request_resource(&iomem_resource, &(ldev->hba.gmmio_space));\n\t\t\tif (err < 0) {\n\t\t\t\tprintk(\"FAILED: lba_fixup_bus() request for \"\n\t\t\t\t\t\"gmmio_space [%lx/%lx]\\n\",\n\t\t\t\t\t(long)ldev->hba.gmmio_space.start,\n\t\t\t\t\t(long)ldev->hba.gmmio_space.end);\n\t\t\t\tlba_dump_res(&iomem_resource, 2);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tDBG(\"lba_fixup_bus() %s\\n\", pci_name(dev));\n\n\t\t \n\t\tfor (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {\n\t\t\tstruct resource *res = &dev->resource[i];\n\n\t\t\t \n\t\t\tif (!res->start)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tpci_claim_resource(dev, i);\n\t\t}\n\n#ifdef FBB_SUPPORT\n\t\t \n\t\t(void) pci_read_config_word(dev, PCI_STATUS, &status);\n\t\tbus->bridge_ctl &= ~(status & PCI_STATUS_FAST_BACK);\n#endif\n\n                 \n\t\tif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {\n\t\t\tpcibios_init_bridge(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tiosapic_fixup_irq(ldev->iosapic_obj, dev);\n\t}\n\n#ifdef FBB_SUPPORT\n \n\tif (fbb_enable) {\n\t\tif (bus->parent) {\n\t\t\tu8 control;\n\t\t\t \n\t\t\t(void) pci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &control);\n\t\t\t(void) pci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, control | PCI_STATUS_FAST_BACK);\n\n\t\t} else {\n\t\t\t \n\t\t}\n\t\tfbb_enable = PCI_COMMAND_FAST_BACK;\n\t}\n\n\t \n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t(void) pci_read_config_word(dev, PCI_COMMAND, &status);\n\t\tstatus |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR | fbb_enable;\n\t\t(void) pci_write_config_word(dev, PCI_COMMAND, status);\n\t}\n#endif\n}\n\n\nstatic struct pci_bios_ops lba_bios_ops = {\n\t.init =\t\tlba_bios_init,\n\t.fixup_bus =\tlba_fixup_bus,\n};\n\n\n\n\n \n\n#define LBA_PORT_IN(size, mask) \\\nstatic u##size lba_astro_in##size (struct pci_hba_data *d, u16 addr) \\\n{ \\\n\tu##size t; \\\n\tt = READ_REG##size(astro_iop_base + addr); \\\n\tDBG_PORT(\" 0x%x\\n\", t); \\\n\treturn (t); \\\n}\n\nLBA_PORT_IN( 8, 3)\nLBA_PORT_IN(16, 2)\nLBA_PORT_IN(32, 0)\n\n\n\n \n#define LBA_PORT_OUT(size, mask) \\\nstatic void lba_astro_out##size (struct pci_hba_data *d, u16 addr, u##size val) \\\n{ \\\n\tDBG_PORT(\"%s(0x%p, 0x%x, 0x%x)\\n\", __func__, d, addr, val); \\\n\tWRITE_REG##size(val, astro_iop_base + addr); \\\n\tif (LBA_DEV(d)->hw_rev < 3) \\\n\t\tlba_t32 = READ_U32(d->base_addr + LBA_FUNC_ID); \\\n}\n\nLBA_PORT_OUT( 8, 3)\nLBA_PORT_OUT(16, 2)\nLBA_PORT_OUT(32, 0)\n\n\nstatic struct pci_port_ops lba_astro_port_ops = {\n\t.inb =\tlba_astro_in8,\n\t.inw =\tlba_astro_in16,\n\t.inl =\tlba_astro_in32,\n\t.outb =\tlba_astro_out8,\n\t.outw =\tlba_astro_out16,\n\t.outl =\tlba_astro_out32\n};\n\n\n#ifdef CONFIG_64BIT\n#define PIOP_TO_GMMIO(lba, addr) \\\n\t((lba)->iop_base + (((addr)&0xFFFC)<<10) + ((addr)&3))\n\n \n#undef LBA_PORT_IN\n#define LBA_PORT_IN(size, mask) \\\nstatic u##size lba_pat_in##size (struct pci_hba_data *l, u16 addr) \\\n{ \\\n\tu##size t; \\\n\tDBG_PORT(\"%s(0x%p, 0x%x) ->\", __func__, l, addr); \\\n\tt = READ_REG##size(PIOP_TO_GMMIO(LBA_DEV(l), addr)); \\\n\tDBG_PORT(\" 0x%x\\n\", t); \\\n\treturn (t); \\\n}\n\nLBA_PORT_IN( 8, 3)\nLBA_PORT_IN(16, 2)\nLBA_PORT_IN(32, 0)\n\n\n#undef LBA_PORT_OUT\n#define LBA_PORT_OUT(size, mask) \\\nstatic void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) \\\n{ \\\n\tvoid __iomem *where = PIOP_TO_GMMIO(LBA_DEV(l), addr); \\\n\tDBG_PORT(\"%s(0x%p, 0x%x, 0x%x)\\n\", __func__, l, addr, val); \\\n\tWRITE_REG##size(val, where); \\\n\t  \\\n\tlba_t32 = READ_U32(l->base_addr + LBA_FUNC_ID); \\\n}\n\nLBA_PORT_OUT( 8, 3)\nLBA_PORT_OUT(16, 2)\nLBA_PORT_OUT(32, 0)\n\n\nstatic struct pci_port_ops lba_pat_port_ops = {\n\t.inb =\tlba_pat_in8,\n\t.inw =\tlba_pat_in16,\n\t.inl =\tlba_pat_in32,\n\t.outb =\tlba_pat_out8,\n\t.outw =\tlba_pat_out16,\n\t.outl =\tlba_pat_out32\n};\n\n\n\n \nstatic void\nlba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)\n{\n\tunsigned long bytecnt;\n\tlong io_count __maybe_unused;\n\tlong status;\t \n\tlong pa_count;\n\tpdc_pat_cell_mod_maddr_block_t *pa_pdc_cell;\t \n\tpdc_pat_cell_mod_maddr_block_t *io_pdc_cell;\t \n\tint i;\n\n\tpa_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);\n\tif (!pa_pdc_cell)\n\t\treturn;\n\n\tio_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);\n\tif (!io_pdc_cell) {\n\t\tkfree(pa_pdc_cell);\n\t\treturn;\n\t}\n\n\t \n\tstatus = pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,\n\t\t\t\tPA_VIEW, pa_pdc_cell);\n\tpa_count = pa_pdc_cell->mod[1];\n\n\tstatus |= pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,\n\t\t\t\tIO_VIEW, io_pdc_cell);\n\tio_count = io_pdc_cell->mod[1];\n\n\t \n\tif (status != PDC_OK) {\n\t\tpanic(\"pdc_pat_cell_module() call failed for LBA!\\n\");\n\t}\n\n\tif (PAT_GET_ENTITY(pa_pdc_cell->mod_info) != PAT_ENTITY_LBA) {\n\t\tpanic(\"pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < pa_count; i++) {\n\t\tstruct {\n\t\t\tunsigned long type;\n\t\t\tunsigned long start;\n\t\t\tunsigned long end;\t \n\t\t} *p, *io;\n\t\tstruct resource *r;\n\n\t\tp = (void *) &(pa_pdc_cell->mod[2+i*3]);\n\t\tio = (void *) &(io_pdc_cell->mod[2+i*3]);\n\n\t\t \n\t\tswitch(p->type & 0xff) {\n\t\tcase PAT_PBNUM:\n\t\t\tlba_dev->hba.bus_num.start = p->start;\n\t\t\tlba_dev->hba.bus_num.end   = p->end;\n\t\t\tlba_dev->hba.bus_num.flags = IORESOURCE_BUS;\n\t\t\tbreak;\n\n\t\tcase PAT_LMMIO:\n\t\t\t \n\t\t\tif (!lba_dev->hba.lmmio_space.flags) {\n\t\t\t\tunsigned long lba_len;\n\n\t\t\t\tlba_len = ~READ_REG32(lba_dev->hba.base_addr\n\t\t\t\t\t\t+ LBA_LMMIO_MASK);\n\t\t\t\tif ((p->end - p->start) != lba_len)\n\t\t\t\t\tp->end = extend_lmmio_len(p->start,\n\t\t\t\t\t\tp->end, lba_len);\n\n\t\t\t\tsprintf(lba_dev->hba.lmmio_name,\n\t\t\t\t\t\t\"PCI%02x LMMIO\",\n\t\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\t\t\t\tlba_dev->hba.lmmio_space_offset = p->start -\n\t\t\t\t\tio->start;\n\t\t\t\tr = &lba_dev->hba.lmmio_space;\n\t\t\t\tr->name = lba_dev->hba.lmmio_name;\n\t\t\t} else if (!lba_dev->hba.elmmio_space.flags) {\n\t\t\t\tsprintf(lba_dev->hba.elmmio_name,\n\t\t\t\t\t\t\"PCI%02x ELMMIO\",\n\t\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\t\t\t\tr = &lba_dev->hba.elmmio_space;\n\t\t\t\tr->name = lba_dev->hba.elmmio_name;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING MODULE_NAME\n\t\t\t\t\t\" only supports 2 LMMIO resources!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tr->start  = p->start;\n\t\t\tr->end    = p->end;\n\t\t\tr->flags  = IORESOURCE_MEM;\n\t\t\tr->parent = r->sibling = r->child = NULL;\n\t\t\tbreak;\n\n\t\tcase PAT_GMMIO:\n\t\t\t \n\t\t\tsprintf(lba_dev->hba.gmmio_name, \"PCI%02x GMMIO\",\n\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\t\t\tr = &lba_dev->hba.gmmio_space;\n\t\t\tr->name  = lba_dev->hba.gmmio_name;\n\t\t\tr->start  = p->start;\n\t\t\tr->end    = p->end;\n\t\t\tr->flags  = IORESOURCE_MEM;\n\t\t\tr->parent = r->sibling = r->child = NULL;\n\t\t\tbreak;\n\n\t\tcase PAT_NPIOP:\n\t\t\tprintk(KERN_WARNING MODULE_NAME\n\t\t\t\t\" range[%d] : ignoring NPIOP (0x%lx)\\n\",\n\t\t\t\ti, p->start);\n\t\t\tbreak;\n\n\t\tcase PAT_PIOP:\n\t\t\t \n\t\t\tlba_dev->iop_base = ioremap(p->start, 64 * 1024 * 1024);\n\n\t\t\tsprintf(lba_dev->hba.io_name, \"PCI%02x Ports\",\n\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\t\t\tr = &lba_dev->hba.io_space;\n\t\t\tr->name  = lba_dev->hba.io_name;\n\t\t\tr->start  = HBA_PORT_BASE(lba_dev->hba.hba_num);\n\t\t\tr->end    = r->start + HBA_PORT_SPACE_SIZE - 1;\n\t\t\tr->flags  = IORESOURCE_IO;\n\t\t\tr->parent = r->sibling = r->child = NULL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING MODULE_NAME\n\t\t\t\t\" range[%d] : unknown pat range type (0x%lx)\\n\",\n\t\t\t\ti, p->type & 0xff);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(pa_pdc_cell);\n\tkfree(io_pdc_cell);\n}\n#else\n \n#define lba_pat_port_ops lba_astro_port_ops\n#define lba_pat_resources(pa_dev, lba_dev)\n#endif\t \n\n\nstatic void\nlba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)\n{\n\tstruct resource *r;\n\tint lba_num;\n\n\tlba_dev->hba.lmmio_space_offset = PCI_F_EXTEND;\n\n\t \n\tlba_num = READ_REG32(lba_dev->hba.base_addr + LBA_FW_SCRATCH);\n\tr = &(lba_dev->hba.bus_num);\n\tr->name = \"LBA PCI Busses\";\n\tr->start = lba_num & 0xff;\n\tr->end = (lba_num>>8) & 0xff;\n\tr->flags = IORESOURCE_BUS;\n\n\t \n\tr = &(lba_dev->hba.lmmio_space);\n\tsprintf(lba_dev->hba.lmmio_name, \"PCI%02x LMMIO\",\n\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\tr->name  = lba_dev->hba.lmmio_name;\n\n#if 1\n\t \n\tsba_distributed_lmmio(pa_dev, r);\n#else\n\t \n\tr->start = READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_BASE);\n\tif (r->start & 1) {\n\t\tunsigned long rsize;\n\n\t\tr->flags = IORESOURCE_MEM;\n\t\t \n\t\tr->start &= mmio_mask;\n\t\tr->start = PCI_HOST_ADDR(&lba_dev->hba, r->start);\n\t\trsize = ~ READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_MASK);\n\n\t\t \n\t\trsize /= ROPES_PER_IOC;\n\t\tr->start += (rsize + 1) * LBA_NUM(pa_dev->hpa.start);\n\t\tr->end = r->start + rsize;\n\t} else {\n\t\tr->end = r->start = 0;\t \n\t}\n#endif\n\n\t \n\tr = &(lba_dev->hba.elmmio_space);\n\tsprintf(lba_dev->hba.elmmio_name, \"PCI%02x ELMMIO\",\n\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\tr->name  = lba_dev->hba.elmmio_name;\n\n#if 1\n\t \n\tsba_directed_lmmio(pa_dev, r);\n#else\n\tr->start = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_BASE);\n\n\tif (r->start & 1) {\n\t\tunsigned long rsize;\n\t\tr->flags = IORESOURCE_MEM;\n\t\t \n\t\tr->start &= mmio_mask;\n\t\tr->start = PCI_HOST_ADDR(&lba_dev->hba, r->start);\n\t\trsize = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_MASK);\n\t\tr->end = r->start + ~rsize;\n\t}\n#endif\n\n\tr = &(lba_dev->hba.io_space);\n\tsprintf(lba_dev->hba.io_name, \"PCI%02x Ports\",\n\t\t\t\t\t(int)lba_dev->hba.bus_num.start);\n\tr->name  = lba_dev->hba.io_name;\n\tr->flags = IORESOURCE_IO;\n\tr->start = READ_REG32(lba_dev->hba.base_addr + LBA_IOS_BASE) & ~1L;\n\tr->end   = r->start + (READ_REG32(lba_dev->hba.base_addr + LBA_IOS_MASK) ^ (HBA_PORT_SPACE_SIZE - 1));\n\n\t \n\tlba_num = HBA_PORT_BASE(lba_dev->hba.hba_num);\n\tr->start |= lba_num;\n\tr->end   |= lba_num;\n}\n\n\n \n\nstatic int __init\nlba_hw_init(struct lba_device *d)\n{\n\tu32 stat;\n\tu32 bus_reset;\t \n\n#if 0\n\tprintk(KERN_DEBUG \"LBA %lx  STAT_CTL %Lx  ERROR_CFG %Lx  STATUS %Lx DMA_CTL %Lx\\n\",\n\t\td->hba.base_addr,\n\t\tREAD_REG64(d->hba.base_addr + LBA_STAT_CTL),\n\t\tREAD_REG64(d->hba.base_addr + LBA_ERROR_CONFIG),\n\t\tREAD_REG64(d->hba.base_addr + LBA_ERROR_STATUS),\n\t\tREAD_REG64(d->hba.base_addr + LBA_DMA_CTL) );\n\tprintk(KERN_DEBUG \"\tARB mask %Lx  pri %Lx  mode %Lx  mtlt %Lx\\n\",\n\t\tREAD_REG64(d->hba.base_addr + LBA_ARB_MASK),\n\t\tREAD_REG64(d->hba.base_addr + LBA_ARB_PRI),\n\t\tREAD_REG64(d->hba.base_addr + LBA_ARB_MODE),\n\t\tREAD_REG64(d->hba.base_addr + LBA_ARB_MTLT) );\n\tprintk(KERN_DEBUG \"\tHINT cfg 0x%Lx\\n\",\n\t\tREAD_REG64(d->hba.base_addr + LBA_HINT_CFG));\n\tprintk(KERN_DEBUG \"\tHINT reg \");\n\t{ int i;\n\tfor (i=LBA_HINT_BASE; i< (14*8 + LBA_HINT_BASE); i+=8)\n\t\tprintk(\" %Lx\", READ_REG64(d->hba.base_addr + i));\n\t}\n\tprintk(\"\\n\");\n#endif\t \n\n#ifdef CONFIG_64BIT\n \n#endif\n\n\t \n\tbus_reset = READ_REG32(d->hba.base_addr + LBA_STAT_CTL + 4) & 1;\n\tif (bus_reset) {\n\t\tprintk(KERN_DEBUG \"NOTICE: PCI bus reset still asserted! (clearing)\\n\");\n\t}\n\n\tstat = READ_REG32(d->hba.base_addr + LBA_ERROR_CONFIG);\n\tif (stat & LBA_SMART_MODE) {\n\t\tprintk(KERN_DEBUG \"NOTICE: LBA in SMART mode! (cleared)\\n\");\n\t\tstat &= ~LBA_SMART_MODE;\n\t\tWRITE_REG32(stat, d->hba.base_addr + LBA_ERROR_CONFIG);\n\t}\n\n\n\t \n        stat = READ_REG32(d->hba.base_addr + LBA_STAT_CTL);\n#if defined(ENABLE_HARDFAIL)\n\tWRITE_REG32(stat | HF_ENABLE, d->hba.base_addr + LBA_STAT_CTL);\n#else\n\tWRITE_REG32(stat & ~HF_ENABLE, d->hba.base_addr + LBA_STAT_CTL);\n#endif\n\n\t \n\tif (bus_reset)\n\t\tmdelay(pci_post_reset_delay);\n\n\tif (0 == READ_REG32(d->hba.base_addr + LBA_ARB_MASK)) {\n\t\t \n\t\tprintk(KERN_DEBUG \"NOTICE: Enabling PCI Arbitration\\n\");\n\t\tWRITE_REG32(0x3, d->hba.base_addr + LBA_ARB_MASK);\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic unsigned int lba_next_bus = 0;\n\n \nstatic int __init\nlba_driver_probe(struct parisc_device *dev)\n{\n\tstruct lba_device *lba_dev;\n\tLIST_HEAD(resources);\n\tstruct pci_bus *lba_bus;\n\tstruct pci_ops *cfg_ops;\n\tu32 func_class;\n\tvoid *tmp_obj;\n\tchar *version;\n\tvoid __iomem *addr;\n\tint max;\n\n\taddr = ioremap(dev->hpa.start, 4096);\n\tif (addr == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tfunc_class = READ_REG32(addr + LBA_FCLASS);\n\n\tif (IS_ELROY(dev)) {\t\n\t\tfunc_class &= 0xf;\n\t\tswitch (func_class) {\n\t\tcase 0:\tversion = \"TR1.0\"; break;\n\t\tcase 1:\tversion = \"TR2.0\"; break;\n\t\tcase 2:\tversion = \"TR2.1\"; break;\n\t\tcase 3:\tversion = \"TR2.2\"; break;\n\t\tcase 4:\tversion = \"TR3.0\"; break;\n\t\tcase 5:\tversion = \"TR4.0\"; break;\n\t\tdefault: version = \"TR4+\";\n\t\t}\n\n\t\tprintk(KERN_INFO \"Elroy version %s (0x%x) found at 0x%lx\\n\",\n\t\t       version, func_class & 0xf, (long)dev->hpa.start);\n\n\t\tif (func_class < 2) {\n\t\t\tprintk(KERN_WARNING \"Can't support LBA older than \"\n\t\t\t\t\"TR2.1 - continuing under adversity.\\n\");\n\t\t}\n\n#if 0\n \n\t\tif (func_class > 4) {\n\t\t\tcfg_ops = &mercury_cfg_ops;\n\t\t} else\n#endif\n\t\t{\n\t\t\tcfg_ops = &elroy_cfg_ops;\n\t\t}\n\n\t} else if (IS_MERCURY(dev) || IS_QUICKSILVER(dev)) {\n\t\tint major, minor;\n\n\t\tfunc_class &= 0xff;\n\t\tmajor = func_class >> 4, minor = func_class & 0xf;\n\n\t\t  \n\t\tprintk(KERN_INFO \"%s version TR%d.%d (0x%x) found at 0x%lx\\n\",\n\t\t       IS_MERCURY(dev) ? \"Mercury\" : \"Quicksilver\", major,\n\t\t       minor, func_class, (long)dev->hpa.start);\n\n\t\tcfg_ops = &mercury_cfg_ops;\n\t} else {\n\t\tprintk(KERN_ERR \"Unknown LBA found at 0x%lx\\n\",\n\t\t\t(long)dev->hpa.start);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\ttmp_obj = iosapic_register(dev->hpa.start + LBA_IOSAPIC_BASE,\n\t\t\t\t\t\taddr + LBA_IOSAPIC_BASE);\n\n\t \n\t\n\tlba_dev = kzalloc(sizeof(struct lba_device), GFP_KERNEL);\n\tif (!lba_dev) {\n\t\tprintk(KERN_ERR \"lba_init_chip - couldn't alloc lba_device\\n\");\n\t\treturn(1);\n\t}\n\n\n\t \n\n\tlba_dev->hw_rev = func_class;\n\tlba_dev->hba.base_addr = addr;\n\tlba_dev->hba.dev = dev;\n\tlba_dev->iosapic_obj = tmp_obj;   \n\tlba_dev->hba.iommu = sba_get_iommu(dev);   \n\tparisc_set_drvdata(dev, lba_dev);\n\n\t \n\tpci_bios = &lba_bios_ops;\n\tpcibios_register_hba(&lba_dev->hba);\n\tspin_lock_init(&lba_dev->lba_lock);\n\n\tif (lba_hw_init(lba_dev))\n\t\treturn(1);\n\n\t \n\n\tif (is_pdc_pat()) {\n\t\t \n\t\tpci_port = &lba_pat_port_ops;\n\t\t \n\t\tlba_pat_resources(dev, lba_dev);\n\t} else {\n\t\tif (!astro_iop_base) {\n\t\t\t \n\t\t\tastro_iop_base = ioremap(LBA_PORT_BASE, 64 * 1024);\n\t\t\tpci_port = &lba_astro_port_ops;\n\t\t}\n\n\t\t \n\t\tlba_legacy_resources(dev, lba_dev);\n\t}\n\n\tif (lba_dev->hba.bus_num.start < lba_next_bus)\n\t\tlba_dev->hba.bus_num.start = lba_next_bus;\n\n\t \n\tif (truncate_pat_collision(&iomem_resource,\n\t\t\t\t   &(lba_dev->hba.lmmio_space))) {\n\t\tprintk(KERN_WARNING \"LBA: lmmio_space [%lx/%lx] duplicate!\\n\",\n\t\t\t\t(long)lba_dev->hba.lmmio_space.start,\n\t\t\t\t(long)lba_dev->hba.lmmio_space.end);\n\t\tlba_dev->hba.lmmio_space.flags = 0;\n\t}\n\n\tpci_add_resource_offset(&resources, &lba_dev->hba.io_space,\n\t\t\t\tHBA_PORT_BASE(lba_dev->hba.hba_num));\n\tif (lba_dev->hba.elmmio_space.flags)\n\t\tpci_add_resource_offset(&resources, &lba_dev->hba.elmmio_space,\n\t\t\t\t\tlba_dev->hba.lmmio_space_offset);\n\tif (lba_dev->hba.lmmio_space.flags)\n\t\tpci_add_resource_offset(&resources, &lba_dev->hba.lmmio_space,\n\t\t\t\t\tlba_dev->hba.lmmio_space_offset);\n\tif (lba_dev->hba.gmmio_space.flags) {\n\t\t \n\t\t \n\t}\n\n\tpci_add_resource(&resources, &lba_dev->hba.bus_num);\n\n\tdev->dev.platform_data = lba_dev;\n\tlba_bus = lba_dev->hba.hba_bus =\n\t\tpci_create_root_bus(&dev->dev, lba_dev->hba.bus_num.start,\n\t\t\t\t    cfg_ops, NULL, &resources);\n\tif (!lba_bus) {\n\t\tpci_free_resource_list(&resources);\n\t\treturn 0;\n\t}\n\n\tmax = pci_scan_child_bus(lba_bus);\n\n\t \n\tif (is_pdc_pat()) {\n\t\t \n\n\t\tDBG_PAT(\"LBA pci_bus_size_bridges()\\n\");\n\t\tpci_bus_size_bridges(lba_bus);\n\n\t\tDBG_PAT(\"LBA pci_bus_assign_resources()\\n\");\n\t\tpci_bus_assign_resources(lba_bus);\n\n#ifdef DEBUG_LBA_PAT\n\t\tDBG_PAT(\"\\nLBA PIOP resource tree\\n\");\n\t\tlba_dump_res(&lba_dev->hba.io_space, 2);\n\t\tDBG_PAT(\"\\nLBA LMMIO resource tree\\n\");\n\t\tlba_dump_res(&lba_dev->hba.lmmio_space, 2);\n#endif\n\t}\n\n\t \n\tif (cfg_ops == &elroy_cfg_ops) {\n\t\tlba_dev->flags |= LBA_FLAG_SKIP_PROBE;\n\t}\n\n\tlba_next_bus = max + 1;\n\tpci_bus_add_devices(lba_bus);\n\n\t \n\treturn 0;\n}\n\nstatic const struct parisc_device_id lba_tbl[] __initconst = {\n\t{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, ELROY_HVERS, 0xa },\n\t{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, MERCURY_HVERS, 0xa },\n\t{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, QUICKSILVER_HVERS, 0xa },\n\t{ 0, }\n};\n\nstatic struct parisc_driver lba_driver __refdata = {\n\t.name =\t\tMODULE_NAME,\n\t.id_table =\tlba_tbl,\n\t.probe =\tlba_driver_probe,\n};\n\n \nstatic int __init lba_init(void)\n{\n\treturn register_parisc_driver(&lba_driver);\n}\narch_initcall(lba_init);\n\n \nvoid lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)\n{\n\tvoid __iomem * base_addr = ioremap(lba->hpa.start, 4096);\n\n\timask <<= 2;\t \n\n\t \n\tWARN_ON((ibase & 0x001fffff) != 0);\n\tWARN_ON((imask & 0x001fffff) != 0);\n\t\n\tDBG(\"%s() ibase 0x%x imask 0x%x\\n\", __func__, ibase, imask);\n\tWRITE_REG32( imask, base_addr + LBA_IMASK);\n\tWRITE_REG32( ibase, base_addr + LBA_IBASE);\n\tiounmap(base_addr);\n}\n\n\n \nstatic void quirk_diva_ati_card(struct pci_dev *dev)\n{\n\tif (dev->subsystem_vendor != PCI_VENDOR_ID_HP ||\n\t    dev->subsystem_device != 0x1292)\n\t\treturn;\n\n\tdev_info(&dev->dev, \"Hiding Diva built-in ATI card\");\n\tdev->device = 0;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_QY,\n\tquirk_diva_ati_card);\n\nstatic void quirk_diva_aux_disable(struct pci_dev *dev)\n{\n\tif (dev->subsystem_vendor != PCI_VENDOR_ID_HP ||\n\t    dev->subsystem_device != 0x1291)\n\t\treturn;\n\n\tdev_info(&dev->dev, \"Hiding Diva built-in AUX serial device\");\n\tdev->device = 0;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA_AUX,\n\tquirk_diva_aux_disable);\n\nstatic void quirk_tosca_aux_disable(struct pci_dev *dev)\n{\n\tif (dev->subsystem_vendor != PCI_VENDOR_ID_HP ||\n\t    dev->subsystem_device != 0x104a)\n\t\treturn;\n\n\tdev_info(&dev->dev, \"Hiding Tosca secondary built-in AUX serial device\");\n\tdev->device = 0;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA,\n\tquirk_tosca_aux_disable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}