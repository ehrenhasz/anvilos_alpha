{
  "module_name": "gsc.c",
  "hash_id": "87dfc5270aecb56d104c6aa4614e19c4b833a62a70661b6c8007389a9148f853",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parisc/gsc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include <asm/hardware.h>\n#include <asm/io.h>\n\n#include \"gsc.h\"\n\n#undef DEBUG\n\n#ifdef DEBUG\n#define DEBPRINTK printk\n#else\n#define DEBPRINTK(x,...)\n#endif\n\nint gsc_alloc_irq(struct gsc_irq *i)\n{\n\tint irq = txn_alloc_irq(GSC_EIM_WIDTH);\n\tif (irq < 0) {\n\t\tprintk(\"cannot get irq\\n\");\n\t\treturn irq;\n\t}\n\n\ti->txn_addr = txn_alloc_addr(irq);\n\ti->txn_data = txn_alloc_data(irq);\n\ti->irq = irq;\n\n\treturn irq;\n}\n\nint gsc_claim_irq(struct gsc_irq *i, int irq)\n{\n\tint c = irq;\n\n\tirq += CPU_IRQ_BASE;  \n\n\tirq = txn_claim_irq(irq);\n\tif (irq < 0) {\n\t\tprintk(\"cannot claim irq %d\\n\", c);\n\t\treturn irq;\n\t}\n\n\ti->txn_addr = txn_alloc_addr(irq);\n\ti->txn_data = txn_alloc_data(irq);\n\ti->irq = irq;\n\n\treturn irq;\n}\n\nEXPORT_SYMBOL(gsc_alloc_irq);\nEXPORT_SYMBOL(gsc_claim_irq);\n\n \nirqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev)\n{\n\tunsigned long irr;\n\tstruct gsc_asic *gsc_asic = dev;\n\n\tirr = gsc_readl(gsc_asic->hpa + OFFSET_IRR);\n\tif (irr == 0)\n\t\treturn IRQ_NONE;\n\n\tDEBPRINTK(\"%s intr, mask=0x%x\\n\", gsc_asic->name, irr);\n\n\tdo {\n\t\tint local_irq = __ffs(irr);\n\t\tunsigned int irq = gsc_asic->global_irq[local_irq];\n\t\tgeneric_handle_irq(irq);\n\t\tirr &= ~(1 << local_irq);\n\t} while (irr);\n\n\treturn IRQ_HANDLED;\n}\n\nint gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)\n{\n\tint local_irq;\n\n\tfor (local_irq = 0; local_irq < limit; local_irq++) {\n\t\tif (global_irqs[local_irq] == irq)\n\t\t\treturn local_irq;\n\t}\n\n\treturn NO_IRQ;\n}\n\nstatic void gsc_asic_mask_irq(struct irq_data *d)\n{\n\tstruct gsc_asic *irq_dev = irq_data_get_irq_chip_data(d);\n\tint local_irq = gsc_find_local_irq(d->irq, irq_dev->global_irq, 32);\n\tu32 imr;\n\n\tDEBPRINTK(KERN_DEBUG \"%s(%d) %s: IMR 0x%x\\n\", __func__, d->irq,\n\t\t\tirq_dev->name, imr);\n\n\t \n\timr = gsc_readl(irq_dev->hpa + OFFSET_IMR);\n\timr &= ~(1 << local_irq);\n\tgsc_writel(imr, irq_dev->hpa + OFFSET_IMR);\n}\n\nstatic void gsc_asic_unmask_irq(struct irq_data *d)\n{\n\tstruct gsc_asic *irq_dev = irq_data_get_irq_chip_data(d);\n\tint local_irq = gsc_find_local_irq(d->irq, irq_dev->global_irq, 32);\n\tu32 imr;\n\n\tDEBPRINTK(KERN_DEBUG \"%s(%d) %s: IMR 0x%x\\n\", __func__, d->irq,\n\t\t\tirq_dev->name, imr);\n\n\t \n\timr = gsc_readl(irq_dev->hpa + OFFSET_IMR);\n\timr |= 1 << local_irq;\n\tgsc_writel(imr, irq_dev->hpa + OFFSET_IMR);\n\t \n}\n\n#ifdef CONFIG_SMP\nstatic int gsc_set_affinity_irq(struct irq_data *d, const struct cpumask *dest,\n\t\t\t\tbool force)\n{\n\tstruct gsc_asic *gsc_dev = irq_data_get_irq_chip_data(d);\n\tstruct cpumask tmask;\n\tint cpu_irq;\n\n\tif (!cpumask_and(&tmask, dest, cpu_online_mask))\n\t\treturn -EINVAL;\n\n\tcpu_irq = cpu_check_affinity(d, &tmask);\n\tif (cpu_irq < 0)\n\t\treturn cpu_irq;\n\n\tgsc_dev->gsc_irq.txn_addr = txn_affinity_addr(d->irq, cpu_irq);\n\tgsc_dev->eim = ((u32) gsc_dev->gsc_irq.txn_addr) | gsc_dev->gsc_irq.txn_data;\n\n\t \n\tgsc_writel(gsc_dev->eim, gsc_dev->hpa + OFFSET_IAR);\n\n\tirq_data_update_effective_affinity(d, &tmask);\n\n\treturn IRQ_SET_MASK_OK;\n}\n#endif\n\n\nstatic struct irq_chip gsc_asic_interrupt_type = {\n\t.name\t\t=\t\"GSC-ASIC\",\n\t.irq_unmask\t=\tgsc_asic_unmask_irq,\n\t.irq_mask\t=\tgsc_asic_mask_irq,\n#ifdef CONFIG_SMP\n\t.irq_set_affinity =\tgsc_set_affinity_irq,\n#endif\n};\n\nint gsc_assign_irq(struct irq_chip *type, void *data)\n{\n\tstatic int irq = GSC_IRQ_BASE;\n\n\tif (irq > GSC_IRQ_MAX)\n\t\treturn NO_IRQ;\n\n\tirq_set_chip_and_handler(irq, type, handle_simple_irq);\n\tirq_set_chip_data(irq, data);\n\n\treturn irq++;\n}\n\nvoid gsc_asic_assign_irq(struct gsc_asic *asic, int local_irq, int *irqp)\n{\n\tint irq = asic->global_irq[local_irq];\n\t\n\tif (irq <= 0) {\n\t\tirq = gsc_assign_irq(&gsc_asic_interrupt_type, asic);\n\t\tif (irq == NO_IRQ)\n\t\t\treturn;\n\n\t\tasic->global_irq[local_irq] = irq;\n\t}\n\t*irqp = irq;\n}\n\nstruct gsc_fixup_struct {\n\tvoid (*choose_irq)(struct parisc_device *, void *);\n\tvoid *ctrl;\n};\n\nstatic int gsc_fixup_irqs_callback(struct device *dev, void *data)\n{\n\tstruct parisc_device *padev = to_parisc_device(dev);\n\tstruct gsc_fixup_struct *gf = data;\n\n\t \n\tif (padev->id.hw_type == HPHW_FAULTY)\n\t\tgsc_fixup_irqs(padev, gf->ctrl, gf->choose_irq);\n\tgf->choose_irq(padev, gf->ctrl);\n\n\treturn 0;\n}\n\nvoid gsc_fixup_irqs(struct parisc_device *parent, void *ctrl,\n\t\t\tvoid (*choose_irq)(struct parisc_device *, void *))\n{\n\tstruct gsc_fixup_struct data = {\n\t\t.choose_irq\t= choose_irq,\n\t\t.ctrl\t\t= ctrl,\n\t};\n\n\tdevice_for_each_child(&parent->dev, &data, gsc_fixup_irqs_callback);\n}\n\nint gsc_common_setup(struct parisc_device *parent, struct gsc_asic *gsc_asic)\n{\n\tstruct resource *res;\n\tint i;\n\n\tgsc_asic->gsc = parent;\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tgsc_asic->global_irq[i] = NO_IRQ;\n\t}\n\n\t \n\tres = request_mem_region(gsc_asic->hpa, 0x100000, gsc_asic->name);\n\tif (res) {\n\t\tres->flags = IORESOURCE_MEM; \t \n\t}\n\n#if 0\n\tprintk(KERN_WARNING \"%s IRQ %d EIM 0x%x\", gsc_asic->name,\n\t\t\tparent->irq, gsc_asic->eim);\n\tif (gsc_readl(gsc_asic->hpa + OFFSET_IMR))\n\t\tprintk(\"  IMR is non-zero! (0x%x)\",\n\t\t\t\tgsc_readl(gsc_asic->hpa + OFFSET_IMR));\n\tprintk(\"\\n\");\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}