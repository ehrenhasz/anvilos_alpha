{
  "module_name": "brcmstb_dpfe.c",
  "hash_id": "05592200f6019862159cf2021f31aac2150655f4e75e0f698cac3e2adf7d37dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/brcmstb_dpfe.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define DRVNAME\t\t\t\"brcmstb-dpfe\"\n\n \n#define REG_DCPU_RESET\t\t0x0\n#define REG_TO_DCPU_MBOX\t0x10\n#define REG_TO_HOST_MBOX\t0x14\n\n \n#define DRAM_MSG_ADDR_OFFSET\t0x0\n#define DRAM_MSG_TYPE_OFFSET\t0x1c\n#define DRAM_MSG_ADDR_MASK\t((1UL << DRAM_MSG_TYPE_OFFSET) - 1)\n#define DRAM_MSG_TYPE_MASK\t((1UL << \\\n\t\t\t\t (BITS_PER_LONG - DRAM_MSG_TYPE_OFFSET)) - 1)\n\n \n#define DCPU_MSG_RAM_START\t0x100\n#define DCPU_MSG_RAM(x)\t\t(DCPU_MSG_RAM_START + (x) * sizeof(u32))\n\n \n#define DRAM_INFO_INTERVAL\t0x0\n#define DRAM_INFO_MR4\t\t0x4\n#define DRAM_INFO_ERROR\t\t0x8\n#define DRAM_INFO_MR4_MASK\t0xff\n#define DRAM_INFO_MR4_SHIFT\t24\t \n\n \n#define DRAM_MR4_REFRESH\t0x0\t \n#define DRAM_MR4_SR_ABORT\t0x3\t \n#define DRAM_MR4_PPRE\t\t0x4\t \n#define DRAM_MR4_TH_OFFS\t0x5\t \n#define DRAM_MR4_TUF\t\t0x7\t \n\n#define DRAM_MR4_REFRESH_MASK\t0x7\n#define DRAM_MR4_SR_ABORT_MASK\t0x1\n#define DRAM_MR4_PPRE_MASK\t0x1\n#define DRAM_MR4_TH_OFFS_MASK\t0x3\n#define DRAM_MR4_TUF_MASK\t0x1\n\n \n#define DRAM_VENDOR_MR5\t\t0x0\n#define DRAM_VENDOR_MR6\t\t0x4\n#define DRAM_VENDOR_MR7\t\t0x8\n#define DRAM_VENDOR_MR8\t\t0xc\n#define DRAM_VENDOR_ERROR\t0x10\n#define DRAM_VENDOR_MASK\t0xff\n#define DRAM_VENDOR_SHIFT\t24\t \n\n \n#define DRAM_DDR_INFO_MR4\t0x0\n#define DRAM_DDR_INFO_MR5\t0x4\n#define DRAM_DDR_INFO_MR6\t0x8\n#define DRAM_DDR_INFO_MR7\t0xc\n#define DRAM_DDR_INFO_MR8\t0x10\n#define DRAM_DDR_INFO_ERROR\t0x14\n#define DRAM_DDR_INFO_MASK\t0xff\n\n \n#define DCPU_RESET_SHIFT\t0x0\n#define DCPU_RESET_MASK\t\t0x1\n#define DCPU_CLK_DISABLE_SHIFT\t0x2\n\n \n#define DCPU_RET_ERROR_BIT\tBIT(31)\n#define DCPU_RET_SUCCESS\t0x1\n#define DCPU_RET_ERR_HEADER\t(DCPU_RET_ERROR_BIT | BIT(0))\n#define DCPU_RET_ERR_INVAL\t(DCPU_RET_ERROR_BIT | BIT(1))\n#define DCPU_RET_ERR_CHKSUM\t(DCPU_RET_ERROR_BIT | BIT(2))\n#define DCPU_RET_ERR_COMMAND\t(DCPU_RET_ERROR_BIT | BIT(3))\n \n#define DCPU_RET_ERR_TIMEDOUT\t(DCPU_RET_ERROR_BIT | BIT(4))\n\n \n#define DPFE_BE_MAGIC\t\t0xfe1010fe\n#define DPFE_LE_MAGIC\t\t0xfe0101fe\n\n \n#define ERR_INVALID_MAGIC\t-1\n#define ERR_INVALID_SIZE\t-2\n#define ERR_INVALID_CHKSUM\t-3\n\n \n#define DPFE_MSG_TYPE_COMMAND\t1\n#define DPFE_MSG_TYPE_RESPONSE\t2\n\n#define DELAY_LOOP_MAX\t\t1000\n\nenum dpfe_msg_fields {\n\tMSG_HEADER,\n\tMSG_COMMAND,\n\tMSG_ARG_COUNT,\n\tMSG_ARG0,\n\tMSG_FIELD_MAX\t= 16  \n};\n\nenum dpfe_commands {\n\tDPFE_CMD_GET_INFO,\n\tDPFE_CMD_GET_REFRESH,\n\tDPFE_CMD_GET_VENDOR,\n\tDPFE_CMD_MAX  \n};\n\n \nstruct dpfe_firmware_header {\n\tu32 magic;\n\tu32 sequence;\n\tu32 version;\n\tu32 imem_size;\n\tu32 dmem_size;\n};\n\n \nstruct init_data {\n\tunsigned int dmem_len;\n\tunsigned int imem_len;\n\tunsigned int chksum;\n\tbool is_big_endian;\n};\n\n \nstruct dpfe_api {\n\tint version;\n\tconst char *fw_name;\n\tconst struct attribute_group **sysfs_attrs;\n\tu32 command[DPFE_CMD_MAX][MSG_FIELD_MAX];\n};\n\n \nstruct brcmstb_dpfe_priv {\n\tvoid __iomem *regs;\n\tvoid __iomem *dmem;\n\tvoid __iomem *imem;\n\tstruct device *dev;\n\tconst struct dpfe_api *dpfe_api;\n\tstruct mutex lock;\n};\n\n \nstatic ssize_t show_info(struct device *, struct device_attribute *, char *);\nstatic ssize_t show_refresh(struct device *, struct device_attribute *, char *);\nstatic ssize_t store_refresh(struct device *, struct device_attribute *,\n\t\t\t  const char *, size_t);\nstatic ssize_t show_vendor(struct device *, struct device_attribute *, char *);\nstatic ssize_t show_dram(struct device *, struct device_attribute *, char *);\n\n \nstatic DEVICE_ATTR(dpfe_info, 0444, show_info, NULL);\nstatic DEVICE_ATTR(dpfe_refresh, 0644, show_refresh, store_refresh);\nstatic DEVICE_ATTR(dpfe_vendor, 0444, show_vendor, NULL);\nstatic DEVICE_ATTR(dpfe_dram, 0444, show_dram, NULL);\n\n \nstatic struct attribute *dpfe_v2_attrs[] = {\n\t&dev_attr_dpfe_info.attr,\n\t&dev_attr_dpfe_refresh.attr,\n\t&dev_attr_dpfe_vendor.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(dpfe_v2);\n\n \nstatic struct attribute *dpfe_v3_attrs[] = {\n\t&dev_attr_dpfe_info.attr,\n\t&dev_attr_dpfe_dram.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(dpfe_v3);\n\n \nstatic const struct dpfe_api dpfe_api_old_v2 = {\n\t.version = 1,\n\t.fw_name = \"dpfe.bin\",\n\t.sysfs_attrs = dpfe_v2_groups,\n\t.command = {\n\t\t[DPFE_CMD_GET_INFO] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 1,\n\t\t\t[MSG_ARG_COUNT] = 1,\n\t\t\t[MSG_ARG0] = 1,\n\t\t},\n\t\t[DPFE_CMD_GET_REFRESH] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 2,\n\t\t\t[MSG_ARG_COUNT] = 1,\n\t\t\t[MSG_ARG0] = 1,\n\t\t},\n\t\t[DPFE_CMD_GET_VENDOR] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 2,\n\t\t\t[MSG_ARG_COUNT] = 1,\n\t\t\t[MSG_ARG0] = 2,\n\t\t},\n\t}\n};\n\n \nstatic const struct dpfe_api dpfe_api_new_v2 = {\n\t.version = 2,\n\t.fw_name = NULL,  \n\t.sysfs_attrs = dpfe_v2_groups,\n\t.command = {\n\t\t[DPFE_CMD_GET_INFO] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 0x101,\n\t\t},\n\t\t[DPFE_CMD_GET_REFRESH] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 0x201,\n\t\t},\n\t\t[DPFE_CMD_GET_VENDOR] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 0x202,\n\t\t},\n\t}\n};\n\n \nstatic const struct dpfe_api dpfe_api_v3 = {\n\t.version = 3,\n\t.fw_name = NULL,  \n\t.sysfs_attrs = dpfe_v3_groups,\n\t.command = {\n\t\t[DPFE_CMD_GET_INFO] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 0x0101,\n\t\t\t[MSG_ARG_COUNT] = 1,\n\t\t\t[MSG_ARG0] = 1,\n\t\t},\n\t\t[DPFE_CMD_GET_REFRESH] = {\n\t\t\t[MSG_HEADER] = DPFE_MSG_TYPE_COMMAND,\n\t\t\t[MSG_COMMAND] = 0x0202,\n\t\t\t[MSG_ARG_COUNT] = 0,\n\t\t},\n\t\t \n\t},\n};\n\nstatic const char *get_error_text(unsigned int i)\n{\n\tstatic const char * const error_text[] = {\n\t\t\"Success\", \"Header code incorrect\",\n\t\t\"Unknown command or argument\", \"Incorrect checksum\",\n\t\t\"Malformed command\", \"Timed out\", \"Unknown error\",\n\t};\n\n\tif (unlikely(i >= ARRAY_SIZE(error_text)))\n\t\ti = ARRAY_SIZE(error_text) - 1;\n\n\treturn error_text[i];\n}\n\nstatic bool is_dcpu_enabled(struct brcmstb_dpfe_priv *priv)\n{\n\tu32 val;\n\n\tmutex_lock(&priv->lock);\n\tval = readl_relaxed(priv->regs + REG_DCPU_RESET);\n\tmutex_unlock(&priv->lock);\n\n\treturn !(val & DCPU_RESET_MASK);\n}\n\nstatic void __disable_dcpu(struct brcmstb_dpfe_priv *priv)\n{\n\tu32 val;\n\n\tif (!is_dcpu_enabled(priv))\n\t\treturn;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tval = readl_relaxed(priv->regs + REG_DCPU_RESET);\n\tval |= (1 << DCPU_RESET_SHIFT);\n\twritel_relaxed(val, priv->regs + REG_DCPU_RESET);\n\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void __enable_dcpu(struct brcmstb_dpfe_priv *priv)\n{\n\tvoid __iomem *regs = priv->regs;\n\tu32 val;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\twritel_relaxed(0, regs + REG_TO_DCPU_MBOX);\n\twritel_relaxed(0, regs + REG_TO_HOST_MBOX);\n\n\t \n\tval = readl_relaxed(regs + REG_DCPU_RESET);\n\tval &= ~(1 << DCPU_CLK_DISABLE_SHIFT);\n\twritel_relaxed(val, regs + REG_DCPU_RESET);\n\n\t \n\tval = readl_relaxed(regs + REG_DCPU_RESET);\n\tval &= ~(1 << DCPU_RESET_SHIFT);\n\twritel_relaxed(val, regs + REG_DCPU_RESET);\n\n\tmutex_unlock(&priv->lock);\n}\n\nstatic unsigned int get_msg_chksum(const u32 msg[], unsigned int max)\n{\n\tunsigned int sum = 0;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < max; i++)\n\t\tsum += msg[i];\n\n\treturn sum;\n}\n\nstatic void __iomem *get_msg_ptr(struct brcmstb_dpfe_priv *priv, u32 response,\n\t\t\t\t char *buf, ssize_t *size)\n{\n\tunsigned int msg_type;\n\tunsigned int offset;\n\tvoid __iomem *ptr = NULL;\n\n\t \n\tif (unlikely(priv->dpfe_api->version >= 3))\n\t\treturn NULL;\n\n\tmsg_type = (response >> DRAM_MSG_TYPE_OFFSET) & DRAM_MSG_TYPE_MASK;\n\toffset = (response >> DRAM_MSG_ADDR_OFFSET) & DRAM_MSG_ADDR_MASK;\n\n\t \n\tswitch (msg_type) {\n\tcase 1:\n\t\tptr = priv->regs + DCPU_MSG_RAM_START + offset;\n\t\tbreak;\n\tcase 0:\n\t\tptr = priv->dmem + offset;\n\t\tbreak;\n\tdefault:\n\t\tdev_emerg(priv->dev, \"invalid message reply from DCPU: %#x\\n\",\n\t\t\tresponse);\n\t\tif (buf && size)\n\t\t\t*size = sprintf(buf,\n\t\t\t\t\"FATAL: communication error with DCPU\\n\");\n\t}\n\n\treturn ptr;\n}\n\nstatic void __finalize_command(struct brcmstb_dpfe_priv *priv)\n{\n\tunsigned int release_mbox;\n\n\t \n\trelease_mbox = (priv->dpfe_api->version < 2)\n\t\t\t? REG_TO_HOST_MBOX : REG_TO_DCPU_MBOX;\n\twritel_relaxed(0, priv->regs + release_mbox);\n}\n\nstatic int __send_command(struct brcmstb_dpfe_priv *priv, unsigned int cmd,\n\t\t\t  u32 result[])\n{\n\tvoid __iomem *regs = priv->regs;\n\tunsigned int i, chksum, chksum_idx;\n\tconst u32 *msg;\n\tint ret = 0;\n\tu32 resp;\n\n\tif (cmd >= DPFE_CMD_MAX)\n\t\treturn -1;\n\n\tmsg = priv->dpfe_api->command[cmd];\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tfor (i = 0; i < DELAY_LOOP_MAX; i++) {\n\t\tresp = readl_relaxed(regs + REG_TO_HOST_MBOX);\n\t\tif (resp == 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\tif (resp != 0) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn -ffs(DCPU_RET_ERR_TIMEDOUT);\n\t}\n\n\t \n\tchksum_idx = msg[MSG_ARG_COUNT] + MSG_ARG_COUNT + 1;\n\tchksum = get_msg_chksum(msg, chksum_idx);\n\n\t \n\tfor (i = 0; i < MSG_FIELD_MAX; i++) {\n\t\tif (i == chksum_idx)\n\t\t\twritel_relaxed(chksum, regs + DCPU_MSG_RAM(i));\n\t\telse\n\t\t\twritel_relaxed(msg[i], regs + DCPU_MSG_RAM(i));\n\t}\n\n\t \n\twritel_relaxed(1, regs + REG_TO_DCPU_MBOX);\n\n\t \n\tfor (i = 0; i < DELAY_LOOP_MAX; i++) {\n\t\t \n\t\tresp = readl_relaxed(regs + REG_TO_HOST_MBOX);\n\t\tif (resp > 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (i == DELAY_LOOP_MAX) {\n\t\tresp = (DCPU_RET_ERR_TIMEDOUT & ~DCPU_RET_ERROR_BIT);\n\t\tret = -ffs(resp);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < MSG_FIELD_MAX; i++)\n\t\t\tresult[i] = readl_relaxed(regs + DCPU_MSG_RAM(i));\n\t\tchksum_idx = result[MSG_ARG_COUNT] + MSG_ARG_COUNT + 1;\n\t}\n\n\t \n\t__finalize_command(priv);\n\n\tmutex_unlock(&priv->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tchksum = get_msg_chksum(result, chksum_idx);\n\tif (chksum != result[chksum_idx])\n\t\tresp = DCPU_RET_ERR_CHKSUM;\n\n\tif (resp != DCPU_RET_SUCCESS) {\n\t\tresp &= ~DCPU_RET_ERROR_BIT;\n\t\tret = -ffs(resp);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int __verify_firmware(struct init_data *init,\n\t\t\t     const struct firmware *fw)\n{\n\tconst struct dpfe_firmware_header *header = (void *)fw->data;\n\tunsigned int dmem_size, imem_size, total_size;\n\tbool is_big_endian = false;\n\tconst u32 *chksum_ptr;\n\n\tif (header->magic == DPFE_BE_MAGIC)\n\t\tis_big_endian = true;\n\telse if (header->magic != DPFE_LE_MAGIC)\n\t\treturn ERR_INVALID_MAGIC;\n\n\tif (is_big_endian) {\n\t\tdmem_size = be32_to_cpu(header->dmem_size);\n\t\timem_size = be32_to_cpu(header->imem_size);\n\t} else {\n\t\tdmem_size = le32_to_cpu(header->dmem_size);\n\t\timem_size = le32_to_cpu(header->imem_size);\n\t}\n\n\t \n\tif ((dmem_size % sizeof(u32)) != 0 || (imem_size % sizeof(u32)) != 0)\n\t\treturn ERR_INVALID_SIZE;\n\n\t \n\ttotal_size = dmem_size + imem_size + sizeof(*header) +\n\t\tsizeof(*chksum_ptr);\n\tif (total_size != fw->size)\n\t\treturn ERR_INVALID_SIZE;\n\n\t \n\tchksum_ptr = (void *)fw->data + sizeof(*header) + dmem_size + imem_size;\n\n\tinit->is_big_endian = is_big_endian;\n\tinit->dmem_len = dmem_size;\n\tinit->imem_len = imem_size;\n\tinit->chksum = (is_big_endian)\n\t\t? be32_to_cpu(*chksum_ptr) : le32_to_cpu(*chksum_ptr);\n\n\treturn 0;\n}\n\n \nstatic int __verify_fw_checksum(struct init_data *init,\n\t\t\t\tstruct brcmstb_dpfe_priv *priv,\n\t\t\t\tconst struct dpfe_firmware_header *header,\n\t\t\t\tu32 checksum)\n{\n\tu32 magic, sequence, version, sum;\n\tu32 __iomem *dmem = priv->dmem;\n\tu32 __iomem *imem = priv->imem;\n\tunsigned int i;\n\n\tif (init->is_big_endian) {\n\t\tmagic = be32_to_cpu(header->magic);\n\t\tsequence = be32_to_cpu(header->sequence);\n\t\tversion = be32_to_cpu(header->version);\n\t} else {\n\t\tmagic = le32_to_cpu(header->magic);\n\t\tsequence = le32_to_cpu(header->sequence);\n\t\tversion = le32_to_cpu(header->version);\n\t}\n\n\tsum = magic + sequence + version + init->dmem_len + init->imem_len;\n\n\tfor (i = 0; i < init->dmem_len / sizeof(u32); i++)\n\t\tsum += readl_relaxed(dmem + i);\n\n\tfor (i = 0; i < init->imem_len / sizeof(u32); i++)\n\t\tsum += readl_relaxed(imem + i);\n\n\treturn (sum == checksum) ? 0 : -1;\n}\n\nstatic int __write_firmware(u32 __iomem *mem, const u32 *fw,\n\t\t\t    unsigned int size, bool is_big_endian)\n{\n\tunsigned int i;\n\n\t \n\tsize /= sizeof(u32);\n\n\t \n\tfor (i = 0; i < size; i++)\n\t\twritel_relaxed(0, mem + i);\n\n\t \n\tif (is_big_endian) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\twritel_relaxed(be32_to_cpu(fw[i]), mem + i);\n\t} else {\n\t\tfor (i = 0; i < size; i++)\n\t\t\twritel_relaxed(le32_to_cpu(fw[i]), mem + i);\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmstb_dpfe_download_firmware(struct brcmstb_dpfe_priv *priv)\n{\n\tconst struct dpfe_firmware_header *header;\n\tunsigned int dmem_size, imem_size;\n\tstruct device *dev = priv->dev;\n\tbool is_big_endian = false;\n\tconst struct firmware *fw;\n\tconst u32 *dmem, *imem;\n\tstruct init_data init;\n\tconst void *fw_blob;\n\tint ret;\n\n\t \n\tif (is_dcpu_enabled(priv)) {\n\t\tu32 response[MSG_FIELD_MAX];\n\n\t\tret = __send_command(priv, DPFE_CMD_GET_INFO, response);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!priv->dpfe_api->fw_name)\n\t\treturn -ENODEV;\n\n\tret = firmware_request_nowarn(&fw, priv->dpfe_api->fw_name, dev);\n\t \n\tif (ret)\n\t\treturn (ret == -ENOENT) ? -EPROBE_DEFER : ret;\n\n\tret = __verify_firmware(&init, fw);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto release_fw;\n\t}\n\n\t__disable_dcpu(priv);\n\n\tis_big_endian = init.is_big_endian;\n\tdmem_size = init.dmem_len;\n\timem_size = init.imem_len;\n\n\t \n\theader = (struct dpfe_firmware_header *)fw->data;\n\t \n\tfw_blob = fw->data + sizeof(*header);\n\t \n\timem = fw_blob;\n\t \n\tdmem = fw_blob + imem_size;\n\n\tret = __write_firmware(priv->dmem, dmem, dmem_size, is_big_endian);\n\tif (ret)\n\t\tgoto release_fw;\n\tret = __write_firmware(priv->imem, imem, imem_size, is_big_endian);\n\tif (ret)\n\t\tgoto release_fw;\n\n\tret = __verify_fw_checksum(&init, priv, header, init.chksum);\n\tif (ret)\n\t\tgoto release_fw;\n\n\t__enable_dcpu(priv);\n\nrelease_fw:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic ssize_t generic_show(unsigned int command, u32 response[],\n\t\t\t    struct brcmstb_dpfe_priv *priv, char *buf)\n{\n\tint ret;\n\n\tif (!priv)\n\t\treturn sprintf(buf, \"ERROR: driver private data not set\\n\");\n\n\tret = __send_command(priv, command, response);\n\tif (ret < 0)\n\t\treturn sprintf(buf, \"ERROR: %s\\n\", get_error_text(-ret));\n\n\treturn 0;\n}\n\nstatic ssize_t show_info(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tu32 response[MSG_FIELD_MAX];\n\tstruct brcmstb_dpfe_priv *priv;\n\tunsigned int info;\n\tssize_t ret;\n\n\tpriv = dev_get_drvdata(dev);\n\tret = generic_show(DPFE_CMD_GET_INFO, response, priv, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = response[MSG_ARG0];\n\n\treturn sprintf(buf, \"%u.%u.%u.%u\\n\",\n\t\t       (info >> 24) & 0xff,\n\t\t       (info >> 16) & 0xff,\n\t\t       (info >> 8) & 0xff,\n\t\t       info & 0xff);\n}\n\nstatic ssize_t show_refresh(struct device *dev,\n\t\t\t    struct device_attribute *devattr, char *buf)\n{\n\tu32 response[MSG_FIELD_MAX];\n\tvoid __iomem *info;\n\tstruct brcmstb_dpfe_priv *priv;\n\tu8 refresh, sr_abort, ppre, thermal_offs, tuf;\n\tu32 mr4;\n\tssize_t ret;\n\n\tpriv = dev_get_drvdata(dev);\n\tret = generic_show(DPFE_CMD_GET_REFRESH, response, priv, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = get_msg_ptr(priv, response[MSG_ARG0], buf, &ret);\n\tif (!info)\n\t\treturn ret;\n\n\tmr4 = (readl_relaxed(info + DRAM_INFO_MR4) >> DRAM_INFO_MR4_SHIFT) &\n\t       DRAM_INFO_MR4_MASK;\n\n\trefresh = (mr4 >> DRAM_MR4_REFRESH) & DRAM_MR4_REFRESH_MASK;\n\tsr_abort = (mr4 >> DRAM_MR4_SR_ABORT) & DRAM_MR4_SR_ABORT_MASK;\n\tppre = (mr4 >> DRAM_MR4_PPRE) & DRAM_MR4_PPRE_MASK;\n\tthermal_offs = (mr4 >> DRAM_MR4_TH_OFFS) & DRAM_MR4_TH_OFFS_MASK;\n\ttuf = (mr4 >> DRAM_MR4_TUF) & DRAM_MR4_TUF_MASK;\n\n\treturn sprintf(buf, \"%#x %#x %#x %#x %#x %#x %#x\\n\",\n\t\t       readl_relaxed(info + DRAM_INFO_INTERVAL),\n\t\t       refresh, sr_abort, ppre, thermal_offs, tuf,\n\t\t       readl_relaxed(info + DRAM_INFO_ERROR));\n}\n\nstatic ssize_t store_refresh(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tu32 response[MSG_FIELD_MAX];\n\tstruct brcmstb_dpfe_priv *priv;\n\tvoid __iomem *info;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tpriv = dev_get_drvdata(dev);\n\tret = __send_command(priv, DPFE_CMD_GET_REFRESH, response);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = get_msg_ptr(priv, response[MSG_ARG0], NULL, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\twritel_relaxed(val, info + DRAM_INFO_INTERVAL);\n\n\treturn count;\n}\n\nstatic ssize_t show_vendor(struct device *dev, struct device_attribute *devattr,\n\t\t\t   char *buf)\n{\n\tu32 response[MSG_FIELD_MAX];\n\tstruct brcmstb_dpfe_priv *priv;\n\tvoid __iomem *info;\n\tssize_t ret;\n\tu32 mr5, mr6, mr7, mr8, err;\n\n\tpriv = dev_get_drvdata(dev);\n\tret = generic_show(DPFE_CMD_GET_VENDOR, response, priv, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = get_msg_ptr(priv, response[MSG_ARG0], buf, &ret);\n\tif (!info)\n\t\treturn ret;\n\n\tmr5 = (readl_relaxed(info + DRAM_VENDOR_MR5) >> DRAM_VENDOR_SHIFT) &\n\t\tDRAM_VENDOR_MASK;\n\tmr6 = (readl_relaxed(info + DRAM_VENDOR_MR6) >> DRAM_VENDOR_SHIFT) &\n\t\tDRAM_VENDOR_MASK;\n\tmr7 = (readl_relaxed(info + DRAM_VENDOR_MR7) >> DRAM_VENDOR_SHIFT) &\n\t\tDRAM_VENDOR_MASK;\n\tmr8 = (readl_relaxed(info + DRAM_VENDOR_MR8) >> DRAM_VENDOR_SHIFT) &\n\t\tDRAM_VENDOR_MASK;\n\terr = readl_relaxed(info + DRAM_VENDOR_ERROR) & DRAM_VENDOR_MASK;\n\n\treturn sprintf(buf, \"%#x %#x %#x %#x %#x\\n\", mr5, mr6, mr7, mr8, err);\n}\n\nstatic ssize_t show_dram(struct device *dev, struct device_attribute *devattr,\n\t\t\t char *buf)\n{\n\tu32 response[MSG_FIELD_MAX];\n\tstruct brcmstb_dpfe_priv *priv;\n\tssize_t ret;\n\tu32 mr4, mr5, mr6, mr7, mr8, err;\n\n\tpriv = dev_get_drvdata(dev);\n\tret = generic_show(DPFE_CMD_GET_REFRESH, response, priv, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tmr4 = response[MSG_ARG0 + 0] & DRAM_INFO_MR4_MASK;\n\tmr5 = response[MSG_ARG0 + 1] & DRAM_DDR_INFO_MASK;\n\tmr6 = response[MSG_ARG0 + 2] & DRAM_DDR_INFO_MASK;\n\tmr7 = response[MSG_ARG0 + 3] & DRAM_DDR_INFO_MASK;\n\tmr8 = response[MSG_ARG0 + 4] & DRAM_DDR_INFO_MASK;\n\terr = response[MSG_ARG0 + 5] & DRAM_DDR_INFO_MASK;\n\n\treturn sprintf(buf, \"%#x %#x %#x %#x %#x %#x\\n\", mr4, mr5, mr6, mr7,\n\t\t\tmr8, err);\n}\n\nstatic int brcmstb_dpfe_resume(struct platform_device *pdev)\n{\n\tstruct brcmstb_dpfe_priv *priv = platform_get_drvdata(pdev);\n\n\treturn brcmstb_dpfe_download_firmware(priv);\n}\n\nstatic int brcmstb_dpfe_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct brcmstb_dpfe_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tmutex_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->regs = devm_platform_ioremap_resource_byname(pdev, \"dpfe-cpu\");\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"couldn't map DCPU registers\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->dmem = devm_platform_ioremap_resource_byname(pdev, \"dpfe-dmem\");\n\tif (IS_ERR(priv->dmem)) {\n\t\tdev_err(dev, \"Couldn't map DCPU data memory\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpriv->imem = devm_platform_ioremap_resource_byname(pdev, \"dpfe-imem\");\n\tif (IS_ERR(priv->imem)) {\n\t\tdev_err(dev, \"Couldn't map DCPU instruction memory\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpriv->dpfe_api = of_device_get_match_data(dev);\n\tif (unlikely(!priv->dpfe_api)) {\n\t\t \n\t\tdev_err(dev, \"Couldn't determine API\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = brcmstb_dpfe_download_firmware(priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Couldn't download firmware\\n\");\n\n\tret = sysfs_create_groups(&pdev->dev.kobj, priv->dpfe_api->sysfs_attrs);\n\tif (!ret)\n\t\tdev_info(dev, \"registered with API v%d.\\n\",\n\t\t\t priv->dpfe_api->version);\n\n\treturn ret;\n}\n\nstatic int brcmstb_dpfe_remove(struct platform_device *pdev)\n{\n\tstruct brcmstb_dpfe_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tsysfs_remove_groups(&pdev->dev.kobj, priv->dpfe_api->sysfs_attrs);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id brcmstb_dpfe_of_match[] = {\n\t \n\t{ .compatible = \"brcm,bcm7268-dpfe-cpu\", .data = &dpfe_api_old_v2 },\n\t{ .compatible = \"brcm,bcm7271-dpfe-cpu\", .data = &dpfe_api_old_v2 },\n\t{ .compatible = \"brcm,bcm7278-dpfe-cpu\", .data = &dpfe_api_old_v2 },\n\t{ .compatible = \"brcm,bcm7211-dpfe-cpu\", .data = &dpfe_api_new_v2 },\n\t \n\t{ .compatible = \"brcm,dpfe-cpu\", .data = &dpfe_api_v3 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, brcmstb_dpfe_of_match);\n\nstatic struct platform_driver brcmstb_dpfe_driver = {\n\t.driver\t= {\n\t\t.name = DRVNAME,\n\t\t.of_match_table = brcmstb_dpfe_of_match,\n\t},\n\t.probe = brcmstb_dpfe_probe,\n\t.remove\t= brcmstb_dpfe_remove,\n\t.resume = brcmstb_dpfe_resume,\n};\n\nmodule_platform_driver(brcmstb_dpfe_driver);\n\nMODULE_AUTHOR(\"Markus Mayer <mmayer@broadcom.com>\");\nMODULE_DESCRIPTION(\"BRCMSTB DDR PHY Front End Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}