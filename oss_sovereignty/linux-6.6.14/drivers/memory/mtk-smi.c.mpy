{
  "module_name": "mtk-smi.c",
  "hash_id": "103d543f065d0b85d5644c6e701cce93e819bdcadabd8fcf34c504df6c09ef05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/mtk-smi.c",
  "human_readable_source": "\n \n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/soc/mediatek/mtk_sip_svc.h>\n#include <soc/mediatek/smi.h>\n#include <dt-bindings/memory/mt2701-larb-port.h>\n#include <dt-bindings/memory/mtk-memory-port.h>\n\n \n#define SMI_L1LEN\t\t\t0x100\n\n#define SMI_L1_ARB\t\t\t0x200\n#define SMI_BUS_SEL\t\t\t0x220\n#define SMI_BUS_LARB_SHIFT(larbid)\t((larbid) << 1)\n \n#define F_MMU1_LARB(larbid)\t\t(0x1 << SMI_BUS_LARB_SHIFT(larbid))\n\n#define SMI_READ_FIFO_TH\t\t0x230\n#define SMI_M4U_TH\t\t\t0x234\n#define SMI_FIFO_TH1\t\t\t0x238\n#define SMI_FIFO_TH2\t\t\t0x23c\n#define SMI_DCM\t\t\t\t0x300\n#define SMI_DUMMY\t\t\t0x444\n\n \n#define SMI_LARB_SLP_CON                0xc\n#define SLP_PROT_EN                     BIT(0)\n#define SLP_PROT_RDY                    BIT(16)\n\n#define SMI_LARB_CMD_THRT_CON\t\t0x24\n#define SMI_LARB_THRT_RD_NU_LMT_MSK\tGENMASK(7, 4)\n#define SMI_LARB_THRT_RD_NU_LMT\t\t(5 << 4)\n\n#define SMI_LARB_SW_FLAG\t\t0x40\n#define SMI_LARB_SW_FLAG_1\t\t0x1\n\n#define SMI_LARB_OSTDL_PORT\t\t0x200\n#define SMI_LARB_OSTDL_PORTx(id)\t(SMI_LARB_OSTDL_PORT + (((id) & 0x1f) << 2))\n\n \n \n#define REG_SMI_SECUR_CON_BASE\t\t0x5c0\n\n \n#define REG_SMI_SECUR_CON_OFFSET(id)\t(((id) >> 3) << 2)\n#define REG_SMI_SECUR_CON_ADDR(id)\t\\\n\t(REG_SMI_SECUR_CON_BASE + REG_SMI_SECUR_CON_OFFSET(id))\n\n \n#define SMI_SECUR_CON_VAL_MSK(id)\t(~(0xf << (((id) & 0x7) << 2)))\n#define SMI_SECUR_CON_VAL_VIRT(id)\tBIT((((id) & 0x7) << 2) + 3)\n \n#define SMI_SECUR_CON_VAL_DOMAIN(id)\t(0x3 << ((((id) & 0x7) << 2) + 1))\n\n \n \n#define MT8167_SMI_LARB_MMU_EN\t\t0xfc0\n\n \n#define MT8173_SMI_LARB_MMU_EN\t\t0xf00\n\n \n#define SMI_LARB_NONSEC_CON(id)\t\t(0x380 + ((id) * 4))\n#define F_MMU_EN\t\t\tBIT(0)\n#define BANK_SEL(id)\t\t\t({\t\t\\\n\tu32 _id = (id) & 0x3;\t\t\t\t\\\n\t(_id << 8 | _id << 10 | _id << 12 | _id << 14);\t\\\n})\n\n#define SMI_COMMON_INIT_REGS_NR\t\t6\n#define SMI_LARB_PORT_NR_MAX\t\t32\n\n#define MTK_SMI_FLAG_THRT_UPDATE\tBIT(0)\n#define MTK_SMI_FLAG_SW_FLAG\t\tBIT(1)\n#define MTK_SMI_FLAG_SLEEP_CTL\t\tBIT(2)\n#define MTK_SMI_FLAG_CFG_PORT_SEC_CTL\tBIT(3)\n#define MTK_SMI_CAPS(flags, _x)\t\t(!!((flags) & (_x)))\n\nstruct mtk_smi_reg_pair {\n\tunsigned int\t\toffset;\n\tu32\t\t\tvalue;\n};\n\nenum mtk_smi_type {\n\tMTK_SMI_GEN1,\n\tMTK_SMI_GEN2,\t\t \n\tMTK_SMI_GEN2_SUB_COMM,\t \n};\n\n \nstatic const char * const mtk_smi_larb_clks[] = {\"apb\", \"smi\", \"gals\"};\n#define MTK_SMI_LARB_REQ_CLK_NR\t\t2\n#define MTK_SMI_LARB_OPT_CLK_NR\t\t1\n\n \nstatic const char * const mtk_smi_common_clks[] = {\"apb\", \"smi\", \"gals0\", \"gals1\"};\n#define MTK_SMI_CLK_NR_MAX\t\tARRAY_SIZE(mtk_smi_common_clks)\n#define MTK_SMI_COM_REQ_CLK_NR\t\t2\n#define MTK_SMI_COM_GALS_REQ_CLK_NR\tMTK_SMI_CLK_NR_MAX\n#define MTK_SMI_SUB_COM_GALS_REQ_CLK_NR 3\n\nstruct mtk_smi_common_plat {\n\tenum mtk_smi_type\ttype;\n\tbool\t\t\thas_gals;\n\tu32\t\t\tbus_sel;  \n\n\tconst struct mtk_smi_reg_pair\t*init;\n};\n\nstruct mtk_smi_larb_gen {\n\tint port_in_larb[MTK_LARB_NR_MAX + 1];\n\tint\t\t\t\t(*config_port)(struct device *dev);\n\tunsigned int\t\t\tlarb_direct_to_common_mask;\n\tunsigned int\t\t\tflags_general;\n\tconst u8\t\t\t(*ostd)[SMI_LARB_PORT_NR_MAX];\n};\n\nstruct mtk_smi {\n\tstruct device\t\t\t*dev;\n\tunsigned int\t\t\tclk_num;\n\tstruct clk_bulk_data\t\tclks[MTK_SMI_CLK_NR_MAX];\n\tstruct clk\t\t\t*clk_async;  \n\tunion {\n\t\tvoid __iomem\t\t*smi_ao_base;  \n\t\tvoid __iomem\t\t*base;\t       \n\t};\n\tstruct device\t\t\t*smi_common_dev;  \n\tconst struct mtk_smi_common_plat *plat;\n};\n\nstruct mtk_smi_larb {  \n\tstruct mtk_smi\t\t\tsmi;\n\tvoid __iomem\t\t\t*base;\n\tstruct device\t\t\t*smi_common_dev;  \n\tconst struct mtk_smi_larb_gen\t*larb_gen;\n\tint\t\t\t\tlarbid;\n\tu32\t\t\t\t*mmu;\n\tunsigned char\t\t\t*bank;\n};\n\nstatic int\nmtk_smi_larb_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\tstruct mtk_smi_larb_iommu *larb_mmu = data;\n\tunsigned int         i;\n\n\tfor (i = 0; i < MTK_LARB_NR_MAX; i++) {\n\t\tif (dev == larb_mmu[i].dev) {\n\t\t\tlarb->larbid = i;\n\t\t\tlarb->mmu = &larb_mmu[i].mmu;\n\t\t\tlarb->bank = larb_mmu[i].bank;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic void\nmtk_smi_larb_unbind(struct device *dev, struct device *master, void *data)\n{\n\t \n}\n\nstatic const struct component_ops mtk_smi_larb_component_ops = {\n\t.bind = mtk_smi_larb_bind,\n\t.unbind = mtk_smi_larb_unbind,\n};\n\nstatic int mtk_smi_larb_config_port_gen1(struct device *dev)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\tconst struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;\n\tstruct mtk_smi *common = dev_get_drvdata(larb->smi_common_dev);\n\tint i, m4u_port_id, larb_port_num;\n\tu32 sec_con_val, reg_val;\n\n\tm4u_port_id = larb_gen->port_in_larb[larb->larbid];\n\tlarb_port_num = larb_gen->port_in_larb[larb->larbid + 1]\n\t\t\t- larb_gen->port_in_larb[larb->larbid];\n\n\tfor (i = 0; i < larb_port_num; i++, m4u_port_id++) {\n\t\tif (*larb->mmu & BIT(i)) {\n\t\t\t \n\t\t\tsec_con_val = SMI_SECUR_CON_VAL_VIRT(m4u_port_id);\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\treg_val = readl(common->smi_ao_base\n\t\t\t+ REG_SMI_SECUR_CON_ADDR(m4u_port_id));\n\t\treg_val &= SMI_SECUR_CON_VAL_MSK(m4u_port_id);\n\t\treg_val |= sec_con_val;\n\t\treg_val |= SMI_SECUR_CON_VAL_DOMAIN(m4u_port_id);\n\t\twritel(reg_val,\n\t\t\tcommon->smi_ao_base\n\t\t\t+ REG_SMI_SECUR_CON_ADDR(m4u_port_id));\n\t}\n\treturn 0;\n}\n\nstatic int mtk_smi_larb_config_port_mt8167(struct device *dev)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\n\twritel(*larb->mmu, larb->base + MT8167_SMI_LARB_MMU_EN);\n\treturn 0;\n}\n\nstatic int mtk_smi_larb_config_port_mt8173(struct device *dev)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\n\twritel(*larb->mmu, larb->base + MT8173_SMI_LARB_MMU_EN);\n\treturn 0;\n}\n\nstatic int mtk_smi_larb_config_port_gen2_general(struct device *dev)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\tu32 reg, flags_general = larb->larb_gen->flags_general;\n\tconst u8 *larbostd = larb->larb_gen->ostd ? larb->larb_gen->ostd[larb->larbid] : NULL;\n\tstruct arm_smccc_res res;\n\tint i;\n\n\tif (BIT(larb->larbid) & larb->larb_gen->larb_direct_to_common_mask)\n\t\treturn 0;\n\n\tif (MTK_SMI_CAPS(flags_general, MTK_SMI_FLAG_THRT_UPDATE)) {\n\t\treg = readl_relaxed(larb->base + SMI_LARB_CMD_THRT_CON);\n\t\treg &= ~SMI_LARB_THRT_RD_NU_LMT_MSK;\n\t\treg |= SMI_LARB_THRT_RD_NU_LMT;\n\t\twritel_relaxed(reg, larb->base + SMI_LARB_CMD_THRT_CON);\n\t}\n\n\tif (MTK_SMI_CAPS(flags_general, MTK_SMI_FLAG_SW_FLAG))\n\t\twritel_relaxed(SMI_LARB_SW_FLAG_1, larb->base + SMI_LARB_SW_FLAG);\n\n\tfor (i = 0; i < SMI_LARB_PORT_NR_MAX && larbostd && !!larbostd[i]; i++)\n\t\twritel_relaxed(larbostd[i], larb->base + SMI_LARB_OSTDL_PORTx(i));\n\n\t \n\tif (MTK_SMI_CAPS(flags_general, MTK_SMI_FLAG_CFG_PORT_SEC_CTL)) {\n\t\tarm_smccc_smc(MTK_SIP_KERNEL_IOMMU_CONTROL, IOMMU_ATF_CMD_CONFIG_SMI_LARB,\n\t\t\t      larb->larbid, *larb->mmu, 0, 0, 0, 0, &res);\n\t\tif (res.a0 != 0) {\n\t\t\tdev_err(dev, \"Enable iommu fail, ret %ld\\n\", res.a0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor_each_set_bit(i, (unsigned long *)larb->mmu, 32) {\n\t\treg = readl_relaxed(larb->base + SMI_LARB_NONSEC_CON(i));\n\t\treg |= F_MMU_EN;\n\t\treg |= BANK_SEL(larb->bank[i]);\n\t\twritel(reg, larb->base + SMI_LARB_NONSEC_CON(i));\n\t}\n\treturn 0;\n}\n\nstatic const u8 mtk_smi_larb_mt8188_ostd[][SMI_LARB_PORT_NR_MAX] = {\n\t[0] = {0x02, 0x18, 0x22, 0x22, 0x01, 0x02, 0x0a,},\n\t[1] = {0x12, 0x02, 0x14, 0x14, 0x01, 0x18, 0x0a,},\n\t[2] = {0x12, 0x12, 0x12, 0x12, 0x0a,},\n\t[3] = {0x12, 0x12, 0x12, 0x12, 0x28, 0x28, 0x0a,},\n\t[4] = {0x06, 0x01, 0x17, 0x06, 0x0a, 0x07, 0x07,},\n\t[5] = {0x02, 0x01, 0x04, 0x02, 0x06, 0x01, 0x06, 0x0a,},\n\t[6] = {0x06, 0x01, 0x06, 0x0a,},\n\t[7] = {0x0c, 0x0c, 0x12,},\n\t[8] = {0x0c, 0x01, 0x0a, 0x05, 0x02, 0x03, 0x01, 0x01, 0x14, 0x14,\n\t       0x0a, 0x14, 0x1e, 0x01, 0x0c, 0x0a, 0x05, 0x02, 0x02, 0x05,\n\t       0x03, 0x01, 0x1e, 0x01, 0x05,},\n\t[9] = {0x1e, 0x01, 0x0a, 0x0a, 0x01, 0x01, 0x03, 0x1e, 0x1e, 0x10,\n\t       0x07, 0x01, 0x0a, 0x06, 0x03, 0x03, 0x0e, 0x01, 0x04, 0x28,},\n\t[10] = {0x03, 0x20, 0x01, 0x20, 0x01, 0x01, 0x14, 0x0a, 0x0a, 0x0c,\n\t\t0x0a, 0x05, 0x02, 0x03, 0x02, 0x14, 0x0a, 0x0a, 0x14, 0x14,\n\t\t0x14, 0x01, 0x01, 0x14, 0x1e, 0x01, 0x05, 0x03, 0x02, 0x28,},\n\t[11] = {0x03, 0x20, 0x01, 0x20, 0x01, 0x01, 0x14, 0x0a, 0x0a, 0x0c,\n\t\t0x0a, 0x05, 0x02, 0x03, 0x02, 0x14, 0x0a, 0x0a, 0x14, 0x14,\n\t\t0x14, 0x01, 0x01, 0x14, 0x1e, 0x01, 0x05, 0x03, 0x02, 0x28,},\n\t[12] = {0x03, 0x20, 0x01, 0x20, 0x01, 0x01, 0x14, 0x0a, 0x0a, 0x0c,\n\t\t0x0a, 0x05, 0x02, 0x03, 0x02, 0x14, 0x0a, 0x0a, 0x14, 0x14,\n\t\t0x14, 0x01, 0x01, 0x14, 0x1e, 0x01, 0x05, 0x03, 0x02, 0x28,},\n\t[13] = {0x07, 0x02, 0x04, 0x02, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t\t0x07, 0x02, 0x04, 0x02, 0x05, 0x05,},\n\t[14] = {0x02, 0x02, 0x0c, 0x0c, 0x0c, 0x0c, 0x01, 0x01, 0x02, 0x02,\n\t\t0x02, 0x02, 0x0c, 0x0c, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n\t\t0x02, 0x02, 0x01, 0x01,},\n\t[15] = {0x0c, 0x0c, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x0c, 0x0c,\n\t\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02,\n\t\t0x0c, 0x01, 0x01,},\n\t[16] = {0x28, 0x28, 0x03, 0x01, 0x01, 0x03, 0x14, 0x14, 0x0a, 0x0d,\n\t\t0x03, 0x05, 0x0e, 0x01, 0x01, 0x05, 0x06, 0x0d, 0x01,},\n\t[17] = {0x28, 0x02, 0x02, 0x12, 0x02, 0x12, 0x10, 0x02, 0x02, 0x0a,\n\t\t0x12, 0x02, 0x02, 0x0a, 0x16, 0x02, 0x04,},\n\t[18] = {0x28, 0x02, 0x02, 0x12, 0x02, 0x12, 0x10, 0x02, 0x02, 0x0a,\n\t\t0x12, 0x02, 0x02, 0x0a, 0x16, 0x02, 0x04,},\n\t[19] = {0x1a, 0x0e, 0x0a, 0x0a, 0x0c, 0x0e, 0x10,},\n\t[20] = {0x1a, 0x0e, 0x0a, 0x0a, 0x0c, 0x0e, 0x10,},\n\t[21] = {0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01,\n\t\t0x01, 0x01, 0x04, 0x0a, 0x06, 0x01, 0x01, 0x01, 0x0a, 0x06,\n\t\t0x01, 0x01, 0x05, 0x03, 0x03, 0x04, 0x01,},\n\t[22] = {0x28, 0x19, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,\n\t\t0x01,},\n\t[23] = {0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x18, 0x01, 0x01,},\n\t[24] = {0x12, 0x06, 0x12, 0x06,},\n\t[25] = {0x01},\n};\n\nstatic const u8 mtk_smi_larb_mt8195_ostd[][SMI_LARB_PORT_NR_MAX] = {\n\t[0] = {0x0a, 0xc, 0x22, 0x22, 0x01, 0x0a,},  \n\t[1] = {0x0a, 0xc, 0x22, 0x22, 0x01, 0x0a,},  \n\t[2] = {0x12, 0x12, 0x12, 0x12, 0x0a,},       \n\t[3] = {0x12, 0x12, 0x12, 0x12, 0x28, 0x28, 0x0a,},\n\t[4] = {0x06, 0x01, 0x17, 0x06, 0x0a,},\n\t[5] = {0x06, 0x01, 0x17, 0x06, 0x06, 0x01, 0x06, 0x0a,},\n\t[6] = {0x06, 0x01, 0x06, 0x0a,},\n\t[7] = {0x0c, 0x0c, 0x12,},\n\t[8] = {0x0c, 0x0c, 0x12,},\n\t[9] = {0x0a, 0x08, 0x04, 0x06, 0x01, 0x01, 0x10, 0x18, 0x11, 0x0a,\n\t\t0x08, 0x04, 0x11, 0x06, 0x02, 0x06, 0x01, 0x11, 0x11, 0x06,},\n\t[10] = {0x18, 0x08, 0x01, 0x01, 0x20, 0x12, 0x18, 0x06, 0x05, 0x10,\n\t\t0x08, 0x08, 0x10, 0x08, 0x08, 0x18, 0x0c, 0x09, 0x0b, 0x0d,\n\t\t0x0d, 0x06, 0x10, 0x10,},\n\t[11] = {0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x01, 0x01, 0x01, 0x01,},\n\t[12] = {0x09, 0x09, 0x05, 0x05, 0x0c, 0x18, 0x02, 0x02, 0x04, 0x02,},\n\t[13] = {0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 0x08, 0x01,},\n\t[14] = {0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 0x16, 0x01, 0x16, 0x01,\n\t\t0x01, 0x02, 0x02, 0x08, 0x02,},\n\t[15] = {},\n\t[16] = {0x28, 0x02, 0x02, 0x12, 0x02, 0x12, 0x10, 0x02, 0x02, 0x0a,\n\t\t0x12, 0x02, 0x0a, 0x16, 0x02, 0x04,},\n\t[17] = {0x1a, 0x0e, 0x0a, 0x0a, 0x0c, 0x0e, 0x10,},\n\t[18] = {0x12, 0x06, 0x12, 0x06,},\n\t[19] = {0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01,\n\t\t0x01, 0x01, 0x04, 0x0a, 0x06, 0x01, 0x01, 0x01, 0x0a, 0x06,\n\t\t0x01, 0x01, 0x05, 0x03, 0x03, 0x04, 0x01,},\n\t[20] = {0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01,\n\t\t0x01, 0x01, 0x04, 0x0a, 0x06, 0x01, 0x01, 0x01, 0x0a, 0x06,\n\t\t0x01, 0x01, 0x05, 0x03, 0x03, 0x04, 0x01,},\n\t[21] = {0x28, 0x19, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,},\n\t[22] = {0x28, 0x19, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,},\n\t[23] = {0x18, 0x01,},\n\t[24] = {0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01,\n\t\t0x01, 0x01,},\n\t[25] = {0x02, 0x02, 0x02, 0x28, 0x16, 0x02, 0x02, 0x02, 0x12, 0x16,\n\t\t0x02, 0x01,},\n\t[26] = {0x02, 0x02, 0x02, 0x28, 0x16, 0x02, 0x02, 0x02, 0x12, 0x16,\n\t\t0x02, 0x01,},\n\t[27] = {0x02, 0x02, 0x02, 0x28, 0x16, 0x02, 0x02, 0x02, 0x12, 0x16,\n\t\t0x02, 0x01,},\n\t[28] = {0x1a, 0x0e, 0x0a, 0x0a, 0x0c, 0x0e, 0x10,},\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt2701 = {\n\t.port_in_larb = {\n\t\tLARB0_PORT_OFFSET, LARB1_PORT_OFFSET,\n\t\tLARB2_PORT_OFFSET, LARB3_PORT_OFFSET\n\t},\n\t.config_port = mtk_smi_larb_config_port_gen1,\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt2712 = {\n\t.config_port                = mtk_smi_larb_config_port_gen2_general,\n\t.larb_direct_to_common_mask = BIT(8) | BIT(9),       \n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt6779 = {\n\t.config_port  = mtk_smi_larb_config_port_gen2_general,\n\t.larb_direct_to_common_mask =\n\t\tBIT(4) | BIT(6) | BIT(11) | BIT(12) | BIT(13),\n\t\t \n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8167 = {\n\t \n\t.config_port = mtk_smi_larb_config_port_mt8167,\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8173 = {\n\t \n\t.config_port = mtk_smi_larb_config_port_mt8173,\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8183 = {\n\t.config_port                = mtk_smi_larb_config_port_gen2_general,\n\t.larb_direct_to_common_mask = BIT(2) | BIT(3) | BIT(7),\n\t\t\t\t       \n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8186 = {\n\t.config_port                = mtk_smi_larb_config_port_gen2_general,\n\t.flags_general\t            = MTK_SMI_FLAG_SLEEP_CTL,\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8188 = {\n\t.config_port                = mtk_smi_larb_config_port_gen2_general,\n\t.flags_general\t            = MTK_SMI_FLAG_THRT_UPDATE | MTK_SMI_FLAG_SW_FLAG |\n\t\t\t\t      MTK_SMI_FLAG_SLEEP_CTL | MTK_SMI_FLAG_CFG_PORT_SEC_CTL,\n\t.ostd\t\t            = mtk_smi_larb_mt8188_ostd,\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8192 = {\n\t.config_port                = mtk_smi_larb_config_port_gen2_general,\n};\n\nstatic const struct mtk_smi_larb_gen mtk_smi_larb_mt8195 = {\n\t.config_port                = mtk_smi_larb_config_port_gen2_general,\n\t.flags_general\t            = MTK_SMI_FLAG_THRT_UPDATE | MTK_SMI_FLAG_SW_FLAG |\n\t\t\t\t      MTK_SMI_FLAG_SLEEP_CTL,\n\t.ostd\t\t            = mtk_smi_larb_mt8195_ostd,\n};\n\nstatic const struct of_device_id mtk_smi_larb_of_ids[] = {\n\t{.compatible = \"mediatek,mt2701-smi-larb\", .data = &mtk_smi_larb_mt2701},\n\t{.compatible = \"mediatek,mt2712-smi-larb\", .data = &mtk_smi_larb_mt2712},\n\t{.compatible = \"mediatek,mt6779-smi-larb\", .data = &mtk_smi_larb_mt6779},\n\t{.compatible = \"mediatek,mt6795-smi-larb\", .data = &mtk_smi_larb_mt8173},\n\t{.compatible = \"mediatek,mt8167-smi-larb\", .data = &mtk_smi_larb_mt8167},\n\t{.compatible = \"mediatek,mt8173-smi-larb\", .data = &mtk_smi_larb_mt8173},\n\t{.compatible = \"mediatek,mt8183-smi-larb\", .data = &mtk_smi_larb_mt8183},\n\t{.compatible = \"mediatek,mt8186-smi-larb\", .data = &mtk_smi_larb_mt8186},\n\t{.compatible = \"mediatek,mt8188-smi-larb\", .data = &mtk_smi_larb_mt8188},\n\t{.compatible = \"mediatek,mt8192-smi-larb\", .data = &mtk_smi_larb_mt8192},\n\t{.compatible = \"mediatek,mt8195-smi-larb\", .data = &mtk_smi_larb_mt8195},\n\t{}\n};\n\nstatic int mtk_smi_larb_sleep_ctrl_enable(struct mtk_smi_larb *larb)\n{\n\tint ret;\n\tu32 tmp;\n\n\twritel_relaxed(SLP_PROT_EN, larb->base + SMI_LARB_SLP_CON);\n\tret = readl_poll_timeout_atomic(larb->base + SMI_LARB_SLP_CON,\n\t\t\t\t\ttmp, !!(tmp & SLP_PROT_RDY), 10, 1000);\n\tif (ret) {\n\t\t \n\t\tdev_err(larb->smi.dev, \"sleep ctrl is not ready(0x%x).\\n\", tmp);\n\t}\n\treturn ret;\n}\n\nstatic void mtk_smi_larb_sleep_ctrl_disable(struct mtk_smi_larb *larb)\n{\n\twritel_relaxed(0, larb->base + SMI_LARB_SLP_CON);\n}\n\nstatic int mtk_smi_device_link_common(struct device *dev, struct device **com_dev)\n{\n\tstruct platform_device *smi_com_pdev;\n\tstruct device_node *smi_com_node;\n\tstruct device *smi_com_dev;\n\tstruct device_link *link;\n\n\tsmi_com_node = of_parse_phandle(dev->of_node, \"mediatek,smi\", 0);\n\tif (!smi_com_node)\n\t\treturn -EINVAL;\n\n\tsmi_com_pdev = of_find_device_by_node(smi_com_node);\n\tof_node_put(smi_com_node);\n\tif (smi_com_pdev) {\n\t\t \n\t\tif (!platform_get_drvdata(smi_com_pdev)) {\n\t\t\tput_device(&smi_com_pdev->dev);\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t\tsmi_com_dev = &smi_com_pdev->dev;\n\t\tlink = device_link_add(dev, smi_com_dev,\n\t\t\t\t       DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);\n\t\tif (!link) {\n\t\t\tdev_err(dev, \"Unable to link smi-common dev\\n\");\n\t\t\tput_device(&smi_com_pdev->dev);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t*com_dev = smi_com_dev;\n\t} else {\n\t\tdev_err(dev, \"Failed to get the smi_common device\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int mtk_smi_dts_clk_init(struct device *dev, struct mtk_smi *smi,\n\t\t\t\tconst char * const clks[],\n\t\t\t\tunsigned int clk_nr_required,\n\t\t\t\tunsigned int clk_nr_optional)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < clk_nr_required; i++)\n\t\tsmi->clks[i].id = clks[i];\n\tret = devm_clk_bulk_get(dev, clk_nr_required, smi->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = clk_nr_required; i < clk_nr_required + clk_nr_optional; i++)\n\t\tsmi->clks[i].id = clks[i];\n\tret = devm_clk_bulk_get_optional(dev, clk_nr_optional,\n\t\t\t\t\t smi->clks + clk_nr_required);\n\tsmi->clk_num = clk_nr_required + clk_nr_optional;\n\treturn ret;\n}\n\nstatic int mtk_smi_larb_probe(struct platform_device *pdev)\n{\n\tstruct mtk_smi_larb *larb;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tlarb = devm_kzalloc(dev, sizeof(*larb), GFP_KERNEL);\n\tif (!larb)\n\t\treturn -ENOMEM;\n\n\tlarb->larb_gen = of_device_get_match_data(dev);\n\tlarb->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(larb->base))\n\t\treturn PTR_ERR(larb->base);\n\n\tret = mtk_smi_dts_clk_init(dev, &larb->smi, mtk_smi_larb_clks,\n\t\t\t\t   MTK_SMI_LARB_REQ_CLK_NR, MTK_SMI_LARB_OPT_CLK_NR);\n\tif (ret)\n\t\treturn ret;\n\n\tlarb->smi.dev = dev;\n\n\tret = mtk_smi_device_link_common(dev, &larb->smi_common_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tplatform_set_drvdata(pdev, larb);\n\tret = component_add(dev, &mtk_smi_larb_component_ops);\n\tif (ret)\n\t\tgoto err_pm_disable;\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(dev);\n\tdevice_link_remove(dev, larb->smi_common_dev);\n\treturn ret;\n}\n\nstatic int mtk_smi_larb_remove(struct platform_device *pdev)\n{\n\tstruct mtk_smi_larb *larb = platform_get_drvdata(pdev);\n\n\tdevice_link_remove(&pdev->dev, larb->smi_common_dev);\n\tpm_runtime_disable(&pdev->dev);\n\tcomponent_del(&pdev->dev, &mtk_smi_larb_component_ops);\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk_smi_larb_resume(struct device *dev)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\tconst struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(larb->smi.clk_num, larb->smi.clks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (MTK_SMI_CAPS(larb->larb_gen->flags_general, MTK_SMI_FLAG_SLEEP_CTL))\n\t\tmtk_smi_larb_sleep_ctrl_disable(larb);\n\n\t \n\treturn larb_gen->config_port(dev);\n}\n\nstatic int __maybe_unused mtk_smi_larb_suspend(struct device *dev)\n{\n\tstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (MTK_SMI_CAPS(larb->larb_gen->flags_general, MTK_SMI_FLAG_SLEEP_CTL)) {\n\t\tret = mtk_smi_larb_sleep_ctrl_enable(larb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tclk_bulk_disable_unprepare(larb->smi.clk_num, larb->smi.clks);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops smi_larb_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mtk_smi_larb_suspend, mtk_smi_larb_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver mtk_smi_larb_driver = {\n\t.probe\t= mtk_smi_larb_probe,\n\t.remove\t= mtk_smi_larb_remove,\n\t.driver\t= {\n\t\t.name = \"mtk-smi-larb\",\n\t\t.of_match_table = mtk_smi_larb_of_ids,\n\t\t.pm             = &smi_larb_pm_ops,\n\t}\n};\n\nstatic const struct mtk_smi_reg_pair mtk_smi_common_mt6795_init[SMI_COMMON_INIT_REGS_NR] = {\n\t{SMI_L1_ARB, 0x1b},\n\t{SMI_M4U_TH, 0xce810c85},\n\t{SMI_FIFO_TH1, 0x43214c8},\n\t{SMI_READ_FIFO_TH, 0x191f},\n};\n\nstatic const struct mtk_smi_reg_pair mtk_smi_common_mt8195_init[SMI_COMMON_INIT_REGS_NR] = {\n\t{SMI_L1LEN, 0xb},\n\t{SMI_M4U_TH, 0xe100e10},\n\t{SMI_FIFO_TH1, 0x506090a},\n\t{SMI_FIFO_TH2, 0x506090a},\n\t{SMI_DCM, 0x4f1},\n\t{SMI_DUMMY, 0x1},\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_gen1 = {\n\t.type     = MTK_SMI_GEN1,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_gen2 = {\n\t.type\t  = MTK_SMI_GEN2,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt6779 = {\n\t.type\t  = MTK_SMI_GEN2,\n\t.has_gals = true,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(4) |\n\t\t    F_MMU1_LARB(5) | F_MMU1_LARB(6) | F_MMU1_LARB(7),\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt6795 = {\n\t.type\t  = MTK_SMI_GEN2,\n\t.bus_sel  = F_MMU1_LARB(0),\n\t.init     = mtk_smi_common_mt6795_init,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8183 = {\n\t.type     = MTK_SMI_GEN2,\n\t.has_gals = true,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(5) |\n\t\t    F_MMU1_LARB(7),\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8186 = {\n\t.type     = MTK_SMI_GEN2,\n\t.has_gals = true,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(4) | F_MMU1_LARB(7),\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8188_vdo = {\n\t.type     = MTK_SMI_GEN2,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(5) | F_MMU1_LARB(7),\n\t.init     = mtk_smi_common_mt8195_init,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8188_vpp = {\n\t.type     = MTK_SMI_GEN2,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(7),\n\t.init     = mtk_smi_common_mt8195_init,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8192 = {\n\t.type     = MTK_SMI_GEN2,\n\t.has_gals = true,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(5) |\n\t\t    F_MMU1_LARB(6),\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8195_vdo = {\n\t.type     = MTK_SMI_GEN2,\n\t.has_gals = true,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(3) | F_MMU1_LARB(5) |\n\t\t    F_MMU1_LARB(7),\n\t.init     = mtk_smi_common_mt8195_init,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8195_vpp = {\n\t.type     = MTK_SMI_GEN2,\n\t.has_gals = true,\n\t.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(7),\n\t.init     = mtk_smi_common_mt8195_init,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_sub_common_mt8195 = {\n\t.type     = MTK_SMI_GEN2_SUB_COMM,\n\t.has_gals = true,\n};\n\nstatic const struct mtk_smi_common_plat mtk_smi_common_mt8365 = {\n\t.type     = MTK_SMI_GEN2,\n\t.bus_sel  = F_MMU1_LARB(2) | F_MMU1_LARB(4),\n};\n\nstatic const struct of_device_id mtk_smi_common_of_ids[] = {\n\t{.compatible = \"mediatek,mt2701-smi-common\", .data = &mtk_smi_common_gen1},\n\t{.compatible = \"mediatek,mt2712-smi-common\", .data = &mtk_smi_common_gen2},\n\t{.compatible = \"mediatek,mt6779-smi-common\", .data = &mtk_smi_common_mt6779},\n\t{.compatible = \"mediatek,mt6795-smi-common\", .data = &mtk_smi_common_mt6795},\n\t{.compatible = \"mediatek,mt8167-smi-common\", .data = &mtk_smi_common_gen2},\n\t{.compatible = \"mediatek,mt8173-smi-common\", .data = &mtk_smi_common_gen2},\n\t{.compatible = \"mediatek,mt8183-smi-common\", .data = &mtk_smi_common_mt8183},\n\t{.compatible = \"mediatek,mt8186-smi-common\", .data = &mtk_smi_common_mt8186},\n\t{.compatible = \"mediatek,mt8188-smi-common-vdo\", .data = &mtk_smi_common_mt8188_vdo},\n\t{.compatible = \"mediatek,mt8188-smi-common-vpp\", .data = &mtk_smi_common_mt8188_vpp},\n\t{.compatible = \"mediatek,mt8192-smi-common\", .data = &mtk_smi_common_mt8192},\n\t{.compatible = \"mediatek,mt8195-smi-common-vdo\", .data = &mtk_smi_common_mt8195_vdo},\n\t{.compatible = \"mediatek,mt8195-smi-common-vpp\", .data = &mtk_smi_common_mt8195_vpp},\n\t{.compatible = \"mediatek,mt8195-smi-sub-common\", .data = &mtk_smi_sub_common_mt8195},\n\t{.compatible = \"mediatek,mt8365-smi-common\", .data = &mtk_smi_common_mt8365},\n\t{}\n};\n\nstatic int mtk_smi_common_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_smi *common;\n\tint ret, clk_required = MTK_SMI_COM_REQ_CLK_NR;\n\n\tcommon = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);\n\tif (!common)\n\t\treturn -ENOMEM;\n\tcommon->dev = dev;\n\tcommon->plat = of_device_get_match_data(dev);\n\n\tif (common->plat->has_gals) {\n\t\tif (common->plat->type == MTK_SMI_GEN2)\n\t\t\tclk_required = MTK_SMI_COM_GALS_REQ_CLK_NR;\n\t\telse if (common->plat->type == MTK_SMI_GEN2_SUB_COMM)\n\t\t\tclk_required = MTK_SMI_SUB_COM_GALS_REQ_CLK_NR;\n\t}\n\tret = mtk_smi_dts_clk_init(dev, common, mtk_smi_common_clks, clk_required, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (common->plat->type == MTK_SMI_GEN1) {\n\t\tcommon->smi_ao_base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(common->smi_ao_base))\n\t\t\treturn PTR_ERR(common->smi_ao_base);\n\n\t\tcommon->clk_async = devm_clk_get(dev, \"async\");\n\t\tif (IS_ERR(common->clk_async))\n\t\t\treturn PTR_ERR(common->clk_async);\n\n\t\tret = clk_prepare_enable(common->clk_async);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tcommon->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(common->base))\n\t\t\treturn PTR_ERR(common->base);\n\t}\n\n\t \n\tif (common->plat->type == MTK_SMI_GEN2_SUB_COMM) {\n\t\tret = mtk_smi_device_link_common(dev, &common->smi_common_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\tplatform_set_drvdata(pdev, common);\n\treturn 0;\n}\n\nstatic int mtk_smi_common_remove(struct platform_device *pdev)\n{\n\tstruct mtk_smi *common = dev_get_drvdata(&pdev->dev);\n\n\tif (common->plat->type == MTK_SMI_GEN2_SUB_COMM)\n\t\tdevice_link_remove(&pdev->dev, common->smi_common_dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk_smi_common_resume(struct device *dev)\n{\n\tstruct mtk_smi *common = dev_get_drvdata(dev);\n\tconst struct mtk_smi_reg_pair *init = common->plat->init;\n\tu32 bus_sel = common->plat->bus_sel;  \n\tint ret, i;\n\n\tret = clk_bulk_prepare_enable(common->clk_num, common->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (common->plat->type != MTK_SMI_GEN2)\n\t\treturn 0;\n\n\tfor (i = 0; i < SMI_COMMON_INIT_REGS_NR && init && init[i].offset; i++)\n\t\twritel_relaxed(init[i].value, common->base + init[i].offset);\n\n\twritel(bus_sel, common->base + SMI_BUS_SEL);\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk_smi_common_suspend(struct device *dev)\n{\n\tstruct mtk_smi *common = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(common->clk_num, common->clks);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops smi_common_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mtk_smi_common_suspend, mtk_smi_common_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic struct platform_driver mtk_smi_common_driver = {\n\t.probe\t= mtk_smi_common_probe,\n\t.remove = mtk_smi_common_remove,\n\t.driver\t= {\n\t\t.name = \"mtk-smi-common\",\n\t\t.of_match_table = mtk_smi_common_of_ids,\n\t\t.pm             = &smi_common_pm_ops,\n\t}\n};\n\nstatic struct platform_driver * const smidrivers[] = {\n\t&mtk_smi_common_driver,\n\t&mtk_smi_larb_driver,\n};\n\nstatic int __init mtk_smi_init(void)\n{\n\treturn platform_register_drivers(smidrivers, ARRAY_SIZE(smidrivers));\n}\nmodule_init(mtk_smi_init);\n\nstatic void __exit mtk_smi_exit(void)\n{\n\tplatform_unregister_drivers(smidrivers, ARRAY_SIZE(smidrivers));\n}\nmodule_exit(mtk_smi_exit);\n\nMODULE_DESCRIPTION(\"MediaTek SMI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}