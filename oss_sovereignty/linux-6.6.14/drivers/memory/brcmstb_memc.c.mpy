{
  "module_name": "brcmstb_memc.c",
  "hash_id": "c139f5a0ce48e2629fef323fd7b46d46620de9bf6a709c41a24d3ff07e76529c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/brcmstb_memc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n\n#define REG_MEMC_CNTRLR_CONFIG\t\t0x00\n#define  CNTRLR_CONFIG_LPDDR4_SHIFT\t5\n#define  CNTRLR_CONFIG_MASK\t\t0xf\n#define REG_MEMC_SRPD_CFG_21\t\t0x20\n#define REG_MEMC_SRPD_CFG_20\t\t0x34\n#define REG_MEMC_SRPD_CFG_1x\t\t0x3c\n#define INACT_COUNT_SHIFT\t\t0\n#define INACT_COUNT_MASK\t\t0xffff\n#define SRPD_EN_SHIFT\t\t\t16\n\nstruct brcmstb_memc_data {\n\tu32 srpd_offset;\n};\n\nstruct brcmstb_memc {\n\tstruct device *dev;\n\tvoid __iomem *ddr_ctrl;\n\tunsigned int timeout_cycles;\n\tu32 frequency;\n\tu32 srpd_offset;\n};\n\nstatic int brcmstb_memc_uses_lpddr4(struct brcmstb_memc *memc)\n{\n\tvoid __iomem *config = memc->ddr_ctrl + REG_MEMC_CNTRLR_CONFIG;\n\tu32 reg;\n\n\treg = readl_relaxed(config) & CNTRLR_CONFIG_MASK;\n\n\treturn reg == CNTRLR_CONFIG_LPDDR4_SHIFT;\n}\n\nstatic int brcmstb_memc_srpd_config(struct brcmstb_memc *memc,\n\t\t\t\t    unsigned int cycles)\n{\n\tvoid __iomem *cfg = memc->ddr_ctrl + memc->srpd_offset;\n\tu32 val;\n\n\t \n\tif (cycles > INACT_COUNT_MASK)\n\t\treturn -EINVAL;\n\n\tmemc->timeout_cycles = cycles;\n\n\tval = (cycles << INACT_COUNT_SHIFT) & INACT_COUNT_MASK;\n\tif (cycles)\n\t\tval |= BIT(SRPD_EN_SHIFT);\n\n\twritel_relaxed(val, cfg);\n\t \n\t(void)readl_relaxed(cfg);\n\n\treturn 0;\n}\n\nstatic ssize_t frequency_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct brcmstb_memc *memc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", memc->frequency);\n}\n\nstatic ssize_t srpd_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct brcmstb_memc *memc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", memc->timeout_cycles);\n}\n\nstatic ssize_t srpd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct brcmstb_memc *memc = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (brcmstb_memc_uses_lpddr4(memc))\n\t\treturn -EOPNOTSUPP;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = brcmstb_memc_srpd_config(memc, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(frequency);\nstatic DEVICE_ATTR_RW(srpd);\n\nstatic struct attribute *dev_attrs[] = {\n\t&dev_attr_frequency.attr,\n\t&dev_attr_srpd.attr,\n\tNULL,\n};\n\nstatic struct attribute_group dev_attr_group = {\n\t.attrs = dev_attrs,\n};\n\nstatic const struct of_device_id brcmstb_memc_of_match[];\n\nstatic int brcmstb_memc_probe(struct platform_device *pdev)\n{\n\tconst struct brcmstb_memc_data *memc_data;\n\tconst struct of_device_id *of_id;\n\tstruct device *dev = &pdev->dev;\n\tstruct brcmstb_memc *memc;\n\tint ret;\n\n\tmemc = devm_kzalloc(dev, sizeof(*memc), GFP_KERNEL);\n\tif (!memc)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, memc);\n\n\tof_id = of_match_device(brcmstb_memc_of_match, dev);\n\tmemc_data = of_id->data;\n\tmemc->srpd_offset = memc_data->srpd_offset;\n\n\tmemc->ddr_ctrl = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(memc->ddr_ctrl))\n\t\treturn PTR_ERR(memc->ddr_ctrl);\n\n\tof_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t     &memc->frequency);\n\n\tret = sysfs_create_group(&dev->kobj, &dev_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int brcmstb_memc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tsysfs_remove_group(&dev->kobj, &dev_attr_group);\n\n\treturn 0;\n}\n\nenum brcmstb_memc_hwtype {\n\tBRCMSTB_MEMC_V21,\n\tBRCMSTB_MEMC_V20,\n\tBRCMSTB_MEMC_V1X,\n};\n\nstatic const struct brcmstb_memc_data brcmstb_memc_versions[] = {\n\t{ .srpd_offset = REG_MEMC_SRPD_CFG_21 },\n\t{ .srpd_offset = REG_MEMC_SRPD_CFG_20 },\n\t{ .srpd_offset = REG_MEMC_SRPD_CFG_1x },\n};\n\nstatic const struct of_device_id brcmstb_memc_of_match[] = {\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.1.x\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V1X]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.0\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V20]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.1\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.2\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.3\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.5\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.6\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.7\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.2.8\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.3.0\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-b.3.1\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-c.1.0\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-c.1.1\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-c.1.2\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-c.1.3\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr-rev-c.1.4\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V21]\n\t},\n\t \n\t{\n\t\t.compatible = \"brcm,brcmstb-memc-ddr\",\n\t\t.data = &brcmstb_memc_versions[BRCMSTB_MEMC_V1X]\n\t},\n\t{}\n};\n\nstatic int brcmstb_memc_suspend(struct device *dev)\n{\n\tstruct brcmstb_memc *memc = dev_get_drvdata(dev);\n\tvoid __iomem *cfg = memc->ddr_ctrl + memc->srpd_offset;\n\tu32 val;\n\n\tif (memc->timeout_cycles == 0)\n\t\treturn 0;\n\n\t \n\tval = readl_relaxed(cfg);\n\tval &= ~BIT(SRPD_EN_SHIFT);\n\twritel_relaxed(val, cfg);\n\t \n\t(void)readl_relaxed(cfg);\n\n\treturn 0;\n}\n\nstatic int brcmstb_memc_resume(struct device *dev)\n{\n\tstruct brcmstb_memc *memc = dev_get_drvdata(dev);\n\n\tif (memc->timeout_cycles == 0)\n\t\treturn 0;\n\n\treturn brcmstb_memc_srpd_config(memc, memc->timeout_cycles);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(brcmstb_memc_pm_ops, brcmstb_memc_suspend,\n\t\t\t\tbrcmstb_memc_resume);\n\nstatic struct platform_driver brcmstb_memc_driver = {\n\t.probe = brcmstb_memc_probe,\n\t.remove = brcmstb_memc_remove,\n\t.driver = {\n\t\t.name\t\t= \"brcmstb_memc\",\n\t\t.of_match_table\t= brcmstb_memc_of_match,\n\t\t.pm\t\t= pm_ptr(&brcmstb_memc_pm_ops),\n\t},\n};\nmodule_platform_driver(brcmstb_memc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"DDR SRPD driver for Broadcom STB chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}