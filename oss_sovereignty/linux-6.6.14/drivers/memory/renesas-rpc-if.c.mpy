{
  "module_name": "renesas-rpc-if.c",
  "hash_id": "64762a41acf00e2708e7aa35799bb1983de01b3c47869122a6c9dbe0c66ba497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/renesas-rpc-if.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <memory/renesas-rpc-if.h>\n\n#define RPCIF_CMNCR\t\t0x0000\t \n#define RPCIF_CMNCR_MD\t\tBIT(31)\n#define RPCIF_CMNCR_MOIIO3(val)\t(((val) & 0x3) << 22)\n#define RPCIF_CMNCR_MOIIO2(val)\t(((val) & 0x3) << 20)\n#define RPCIF_CMNCR_MOIIO1(val)\t(((val) & 0x3) << 18)\n#define RPCIF_CMNCR_MOIIO0(val)\t(((val) & 0x3) << 16)\n#define RPCIF_CMNCR_MOIIO(val)\t(RPCIF_CMNCR_MOIIO0(val) | RPCIF_CMNCR_MOIIO1(val) | \\\n\t\t\t\t RPCIF_CMNCR_MOIIO2(val) | RPCIF_CMNCR_MOIIO3(val))\n#define RPCIF_CMNCR_IO3FV(val)\t(((val) & 0x3) << 14)  \n#define RPCIF_CMNCR_IO2FV(val)\t(((val) & 0x3) << 12)  \n#define RPCIF_CMNCR_IO0FV(val)\t(((val) & 0x3) << 8)\n#define RPCIF_CMNCR_IOFV(val)\t(RPCIF_CMNCR_IO0FV(val) | RPCIF_CMNCR_IO2FV(val) | \\\n\t\t\t\t RPCIF_CMNCR_IO3FV(val))\n#define RPCIF_CMNCR_BSZ(val)\t(((val) & 0x3) << 0)\n\n#define RPCIF_SSLDR\t\t0x0004\t \n#define RPCIF_SSLDR_SPNDL(d)\t(((d) & 0x7) << 16)\n#define RPCIF_SSLDR_SLNDL(d)\t(((d) & 0x7) << 8)\n#define RPCIF_SSLDR_SCKDL(d)\t(((d) & 0x7) << 0)\n\n#define RPCIF_DRCR\t\t0x000C\t \n#define RPCIF_DRCR_SSLN\t\tBIT(24)\n#define RPCIF_DRCR_RBURST(v)\t((((v) - 1) & 0x1F) << 16)\n#define RPCIF_DRCR_RCF\t\tBIT(9)\n#define RPCIF_DRCR_RBE\t\tBIT(8)\n#define RPCIF_DRCR_SSLE\t\tBIT(0)\n\n#define RPCIF_DRCMR\t\t0x0010\t \n#define RPCIF_DRCMR_CMD(c)\t(((c) & 0xFF) << 16)\n#define RPCIF_DRCMR_OCMD(c)\t(((c) & 0xFF) << 0)\n\n#define RPCIF_DREAR\t\t0x0014\t \n#define RPCIF_DREAR_EAV(c)\t(((c) & 0xF) << 16)\n#define RPCIF_DREAR_EAC(c)\t(((c) & 0x7) << 0)\n\n#define RPCIF_DROPR\t\t0x0018\t \n\n#define RPCIF_DRENR\t\t0x001C\t \n#define RPCIF_DRENR_CDB(o)\t(u32)((((o) & 0x3) << 30))\n#define RPCIF_DRENR_OCDB(o)\t(((o) & 0x3) << 28)\n#define RPCIF_DRENR_ADB(o)\t(((o) & 0x3) << 24)\n#define RPCIF_DRENR_OPDB(o)\t(((o) & 0x3) << 20)\n#define RPCIF_DRENR_DRDB(o)\t(((o) & 0x3) << 16)\n#define RPCIF_DRENR_DME\t\tBIT(15)\n#define RPCIF_DRENR_CDE\t\tBIT(14)\n#define RPCIF_DRENR_OCDE\tBIT(12)\n#define RPCIF_DRENR_ADE(v)\t(((v) & 0xF) << 8)\n#define RPCIF_DRENR_OPDE(v)\t(((v) & 0xF) << 4)\n\n#define RPCIF_SMCR\t\t0x0020\t \n#define RPCIF_SMCR_SSLKP\tBIT(8)\n#define RPCIF_SMCR_SPIRE\tBIT(2)\n#define RPCIF_SMCR_SPIWE\tBIT(1)\n#define RPCIF_SMCR_SPIE\t\tBIT(0)\n\n#define RPCIF_SMCMR\t\t0x0024\t \n#define RPCIF_SMCMR_CMD(c)\t(((c) & 0xFF) << 16)\n#define RPCIF_SMCMR_OCMD(c)\t(((c) & 0xFF) << 0)\n\n#define RPCIF_SMADR\t\t0x0028\t \n\n#define RPCIF_SMOPR\t\t0x002C\t \n#define RPCIF_SMOPR_OPD3(o)\t(((o) & 0xFF) << 24)\n#define RPCIF_SMOPR_OPD2(o)\t(((o) & 0xFF) << 16)\n#define RPCIF_SMOPR_OPD1(o)\t(((o) & 0xFF) << 8)\n#define RPCIF_SMOPR_OPD0(o)\t(((o) & 0xFF) << 0)\n\n#define RPCIF_SMENR\t\t0x0030\t \n#define RPCIF_SMENR_CDB(o)\t(((o) & 0x3) << 30)\n#define RPCIF_SMENR_OCDB(o)\t(((o) & 0x3) << 28)\n#define RPCIF_SMENR_ADB(o)\t(((o) & 0x3) << 24)\n#define RPCIF_SMENR_OPDB(o)\t(((o) & 0x3) << 20)\n#define RPCIF_SMENR_SPIDB(o)\t(((o) & 0x3) << 16)\n#define RPCIF_SMENR_DME\t\tBIT(15)\n#define RPCIF_SMENR_CDE\t\tBIT(14)\n#define RPCIF_SMENR_OCDE\tBIT(12)\n#define RPCIF_SMENR_ADE(v)\t(((v) & 0xF) << 8)\n#define RPCIF_SMENR_OPDE(v)\t(((v) & 0xF) << 4)\n#define RPCIF_SMENR_SPIDE(v)\t(((v) & 0xF) << 0)\n\n#define RPCIF_SMRDR0\t\t0x0038\t \n#define RPCIF_SMRDR1\t\t0x003C\t \n#define RPCIF_SMWDR0\t\t0x0040\t \n#define RPCIF_SMWDR1\t\t0x0044\t \n\n#define RPCIF_CMNSR\t\t0x0048\t \n#define RPCIF_CMNSR_SSLF\tBIT(1)\n#define RPCIF_CMNSR_TEND\tBIT(0)\n\n#define RPCIF_DRDMCR\t\t0x0058\t \n#define RPCIF_DMDMCR_DMCYC(v)\t((((v) - 1) & 0x1F) << 0)\n\n#define RPCIF_DRDRENR\t\t0x005C\t \n#define RPCIF_DRDRENR_HYPE(v)\t(((v) & 0x7) << 12)\n#define RPCIF_DRDRENR_ADDRE\tBIT(8)\n#define RPCIF_DRDRENR_OPDRE\tBIT(4)\n#define RPCIF_DRDRENR_DRDRE\tBIT(0)\n\n#define RPCIF_SMDMCR\t\t0x0060\t \n#define RPCIF_SMDMCR_DMCYC(v)\t((((v) - 1) & 0x1F) << 0)\n\n#define RPCIF_SMDRENR\t\t0x0064\t \n#define RPCIF_SMDRENR_HYPE(v)\t(((v) & 0x7) << 12)\n#define RPCIF_SMDRENR_ADDRE\tBIT(8)\n#define RPCIF_SMDRENR_OPDRE\tBIT(4)\n#define RPCIF_SMDRENR_SPIDRE\tBIT(0)\n\n#define RPCIF_PHYADD\t\t0x0070\t \n#define RPCIF_PHYWR\t\t0x0074\t \n\n#define RPCIF_PHYCNT\t\t0x007C\t \n#define RPCIF_PHYCNT_CAL\tBIT(31)\n#define RPCIF_PHYCNT_OCTA(v)\t(((v) & 0x3) << 22)\n#define RPCIF_PHYCNT_EXDS\tBIT(21)\n#define RPCIF_PHYCNT_OCT\tBIT(20)\n#define RPCIF_PHYCNT_DDRCAL\tBIT(19)\n#define RPCIF_PHYCNT_HS\t\tBIT(18)\n#define RPCIF_PHYCNT_CKSEL(v)\t(((v) & 0x3) << 16)  \n#define RPCIF_PHYCNT_STRTIM(v)\t(((v) & 0x7) << 15 | ((v) & 0x8) << 24)  \n\n#define RPCIF_PHYCNT_WBUF2\tBIT(4)\n#define RPCIF_PHYCNT_WBUF\tBIT(2)\n#define RPCIF_PHYCNT_PHYMEM(v)\t(((v) & 0x3) << 0)\n#define RPCIF_PHYCNT_PHYMEM_MASK GENMASK(1, 0)\n\n#define RPCIF_PHYOFFSET1\t0x0080\t \n#define RPCIF_PHYOFFSET1_DDRTMG(v) (((v) & 0x3) << 28)\n\n#define RPCIF_PHYOFFSET2\t0x0084\t \n#define RPCIF_PHYOFFSET2_OCTTMG(v) (((v) & 0x7) << 8)\n\n#define RPCIF_PHYINT\t\t0x0088\t \n#define RPCIF_PHYINT_WPVAL\tBIT(1)\n\nstatic const struct regmap_range rpcif_volatile_ranges[] = {\n\tregmap_reg_range(RPCIF_SMRDR0, RPCIF_SMRDR1),\n\tregmap_reg_range(RPCIF_SMWDR0, RPCIF_SMWDR1),\n\tregmap_reg_range(RPCIF_CMNSR, RPCIF_CMNSR),\n};\n\nstatic const struct regmap_access_table rpcif_volatile_table = {\n\t.yes_ranges\t= rpcif_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(rpcif_volatile_ranges),\n};\n\nstruct rpcif_info {\n\tenum rpcif_type type;\n\tu8 strtim;\n};\n\nstruct rpcif_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *dirmap;\n\tstruct regmap *regmap;\n\tstruct reset_control *rstc;\n\tstruct platform_device *vdev;\n\tsize_t size;\n\tconst struct rpcif_info *info;\n\tenum rpcif_data_dir dir;\n\tu8 bus_size;\n\tu8 xfer_size;\n\tvoid *buffer;\n\tu32 xferlen;\n\tu32 smcr;\n\tu32 smadr;\n\tu32 command;\t\t \n\tu32 option;\t\t \n\tu32 enable;\t\t \n\tu32 dummy;\t\t \n\tu32 ddr;\t\t \n};\n\nstatic const struct rpcif_info rpcif_info_r8a7796 = {\n\t.type = RPCIF_RCAR_GEN3,\n\t.strtim = 6,\n};\n\nstatic const struct rpcif_info rpcif_info_gen3 = {\n\t.type = RPCIF_RCAR_GEN3,\n\t.strtim = 7,\n};\n\nstatic const struct rpcif_info rpcif_info_rz_g2l = {\n\t.type = RPCIF_RZ_G2L,\n\t.strtim = 7,\n};\n\nstatic const struct rpcif_info rpcif_info_gen4 = {\n\t.type = RPCIF_RCAR_GEN4,\n\t.strtim = 15,\n};\n\n \nstatic int rpcif_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct rpcif_priv *rpc = context;\n\n\tswitch (reg) {\n\tcase RPCIF_SMRDR0:\n\tcase RPCIF_SMWDR0:\n\t\tswitch (rpc->xfer_size) {\n\t\tcase 1:\n\t\t\t*val = readb(rpc->base + reg);\n\t\t\treturn 0;\n\n\t\tcase 2:\n\t\t\t*val = readw(rpc->base + reg);\n\t\t\treturn 0;\n\n\t\tcase 4:\n\t\tcase 8:\n\t\t\t*val = readl(rpc->base + reg);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EILSEQ;\n\t\t}\n\n\tcase RPCIF_SMRDR1:\n\tcase RPCIF_SMWDR1:\n\t\tif (rpc->xfer_size != 8)\n\t\t\treturn -EILSEQ;\n\t\tbreak;\n\t}\n\n\t*val = readl(rpc->base + reg);\n\treturn 0;\n}\n\nstatic int rpcif_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct rpcif_priv *rpc = context;\n\n\tswitch (reg) {\n\tcase RPCIF_SMWDR0:\n\t\tswitch (rpc->xfer_size) {\n\t\tcase 1:\n\t\t\twriteb(val, rpc->base + reg);\n\t\t\treturn 0;\n\n\t\tcase 2:\n\t\t\twritew(val, rpc->base + reg);\n\t\t\treturn 0;\n\n\t\tcase 4:\n\t\tcase 8:\n\t\t\twritel(val, rpc->base + reg);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EILSEQ;\n\t\t}\n\n\tcase RPCIF_SMWDR1:\n\t\tif (rpc->xfer_size != 8)\n\t\t\treturn -EILSEQ;\n\t\tbreak;\n\n\tcase RPCIF_SMRDR0:\n\tcase RPCIF_SMRDR1:\n\t\treturn -EPERM;\n\t}\n\n\twritel(val, rpc->base + reg);\n\treturn 0;\n}\n\nstatic const struct regmap_config rpcif_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.reg_read\t= rpcif_reg_read,\n\t.reg_write\t= rpcif_reg_write,\n\t.fast_io\t= true,\n\t.max_register\t= RPCIF_PHYINT,\n\t.volatile_table\t= &rpcif_volatile_table,\n};\n\nint rpcif_sw_init(struct rpcif *rpcif, struct device *dev)\n{\n\tstruct rpcif_priv *rpc = dev_get_drvdata(dev);\n\n\trpcif->dev = dev;\n\trpcif->dirmap = rpc->dirmap;\n\trpcif->size = rpc->size;\n\treturn 0;\n}\nEXPORT_SYMBOL(rpcif_sw_init);\n\nstatic void rpcif_rzg2l_timing_adjust_sdr(struct rpcif_priv *rpc)\n{\n\tregmap_write(rpc->regmap, RPCIF_PHYWR, 0xa5390000);\n\tregmap_write(rpc->regmap, RPCIF_PHYADD, 0x80000000);\n\tregmap_write(rpc->regmap, RPCIF_PHYWR, 0x00008080);\n\tregmap_write(rpc->regmap, RPCIF_PHYADD, 0x80000022);\n\tregmap_write(rpc->regmap, RPCIF_PHYWR, 0x00008080);\n\tregmap_write(rpc->regmap, RPCIF_PHYADD, 0x80000024);\n\tregmap_update_bits(rpc->regmap, RPCIF_PHYCNT, RPCIF_PHYCNT_CKSEL(3),\n\t\t\t   RPCIF_PHYCNT_CKSEL(3));\n\tregmap_write(rpc->regmap, RPCIF_PHYWR, 0x00000030);\n\tregmap_write(rpc->regmap, RPCIF_PHYADD, 0x80000032);\n}\n\nint rpcif_hw_init(struct device *dev, bool hyperflash)\n{\n\tstruct rpcif_priv *rpc = dev_get_drvdata(dev);\n\tu32 dummy;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rpc->info->type == RPCIF_RZ_G2L) {\n\t\tret = reset_control_reset(rpc->rstc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tusleep_range(200, 300);\n\t\trpcif_rzg2l_timing_adjust_sdr(rpc);\n\t}\n\n\tregmap_update_bits(rpc->regmap, RPCIF_PHYCNT, RPCIF_PHYCNT_PHYMEM_MASK,\n\t\t\t   RPCIF_PHYCNT_PHYMEM(hyperflash ? 3 : 0));\n\n\t \n\tregmap_update_bits(rpc->regmap, RPCIF_PHYCNT, RPCIF_PHYCNT_HS, 0);\n\n\tregmap_update_bits(rpc->regmap, RPCIF_PHYCNT,\n\t\t\t    \n\t\t\t   RPCIF_PHYCNT_STRTIM(BIT(fls(rpc->info->strtim)) - 1),\n\t\t\t   RPCIF_PHYCNT_STRTIM(rpc->info->strtim));\n\n\tregmap_update_bits(rpc->regmap, RPCIF_PHYOFFSET1, RPCIF_PHYOFFSET1_DDRTMG(3),\n\t\t\t   RPCIF_PHYOFFSET1_DDRTMG(3));\n\tregmap_update_bits(rpc->regmap, RPCIF_PHYOFFSET2, RPCIF_PHYOFFSET2_OCTTMG(7),\n\t\t\t   RPCIF_PHYOFFSET2_OCTTMG(4));\n\n\tif (hyperflash)\n\t\tregmap_update_bits(rpc->regmap, RPCIF_PHYINT,\n\t\t\t\t   RPCIF_PHYINT_WPVAL, 0);\n\n\tif (rpc->info->type == RPCIF_RZ_G2L)\n\t\tregmap_update_bits(rpc->regmap, RPCIF_CMNCR,\n\t\t\t\t   RPCIF_CMNCR_MOIIO(3) | RPCIF_CMNCR_IOFV(3) |\n\t\t\t\t   RPCIF_CMNCR_BSZ(3),\n\t\t\t\t   RPCIF_CMNCR_MOIIO(1) | RPCIF_CMNCR_IOFV(2) |\n\t\t\t\t   RPCIF_CMNCR_BSZ(hyperflash ? 1 : 0));\n\telse\n\t\tregmap_update_bits(rpc->regmap, RPCIF_CMNCR,\n\t\t\t\t   RPCIF_CMNCR_MOIIO(3) | RPCIF_CMNCR_BSZ(3),\n\t\t\t\t   RPCIF_CMNCR_MOIIO(3) |\n\t\t\t\t   RPCIF_CMNCR_BSZ(hyperflash ? 1 : 0));\n\n\t \n\tregmap_write(rpc->regmap, RPCIF_DRCR, RPCIF_DRCR_RCF);\n\t \n\tregmap_read(rpc->regmap, RPCIF_DRCR, &dummy);\n\tregmap_write(rpc->regmap, RPCIF_SSLDR, RPCIF_SSLDR_SPNDL(7) |\n\t\t     RPCIF_SSLDR_SLNDL(7) | RPCIF_SSLDR_SCKDL(7));\n\n\tpm_runtime_put(dev);\n\n\trpc->bus_size = hyperflash ? 2 : 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rpcif_hw_init);\n\nstatic int wait_msg_xfer_end(struct rpcif_priv *rpc)\n{\n\tu32 sts;\n\n\treturn regmap_read_poll_timeout(rpc->regmap, RPCIF_CMNSR, sts,\n\t\t\t\t\tsts & RPCIF_CMNSR_TEND, 0,\n\t\t\t\t\tUSEC_PER_SEC);\n}\n\nstatic u8 rpcif_bits_set(struct rpcif_priv *rpc, u32 nbytes)\n{\n\tif (rpc->bus_size == 2)\n\t\tnbytes /= 2;\n\tnbytes = clamp(nbytes, 1U, 4U);\n\treturn GENMASK(3, 4 - nbytes);\n}\n\nstatic u8 rpcif_bit_size(u8 buswidth)\n{\n\treturn buswidth > 4 ? 2 : ilog2(buswidth);\n}\n\nvoid rpcif_prepare(struct device *dev, const struct rpcif_op *op, u64 *offs,\n\t\t   size_t *len)\n{\n\tstruct rpcif_priv *rpc = dev_get_drvdata(dev);\n\n\trpc->smcr = 0;\n\trpc->smadr = 0;\n\trpc->enable = 0;\n\trpc->command = 0;\n\trpc->option = 0;\n\trpc->dummy = 0;\n\trpc->ddr = 0;\n\trpc->xferlen = 0;\n\n\tif (op->cmd.buswidth) {\n\t\trpc->enable  = RPCIF_SMENR_CDE |\n\t\t\tRPCIF_SMENR_CDB(rpcif_bit_size(op->cmd.buswidth));\n\t\trpc->command = RPCIF_SMCMR_CMD(op->cmd.opcode);\n\t\tif (op->cmd.ddr)\n\t\t\trpc->ddr = RPCIF_SMDRENR_HYPE(0x5);\n\t}\n\tif (op->ocmd.buswidth) {\n\t\trpc->enable  |= RPCIF_SMENR_OCDE |\n\t\t\tRPCIF_SMENR_OCDB(rpcif_bit_size(op->ocmd.buswidth));\n\t\trpc->command |= RPCIF_SMCMR_OCMD(op->ocmd.opcode);\n\t}\n\n\tif (op->addr.buswidth) {\n\t\trpc->enable |=\n\t\t\tRPCIF_SMENR_ADB(rpcif_bit_size(op->addr.buswidth));\n\t\tif (op->addr.nbytes == 4)\n\t\t\trpc->enable |= RPCIF_SMENR_ADE(0xF);\n\t\telse\n\t\t\trpc->enable |= RPCIF_SMENR_ADE(GENMASK(\n\t\t\t\t\t\t2, 3 - op->addr.nbytes));\n\t\tif (op->addr.ddr)\n\t\t\trpc->ddr |= RPCIF_SMDRENR_ADDRE;\n\n\t\tif (offs && len)\n\t\t\trpc->smadr = *offs;\n\t\telse\n\t\t\trpc->smadr = op->addr.val;\n\t}\n\n\tif (op->dummy.buswidth) {\n\t\trpc->enable |= RPCIF_SMENR_DME;\n\t\trpc->dummy = RPCIF_SMDMCR_DMCYC(op->dummy.ncycles);\n\t}\n\n\tif (op->option.buswidth) {\n\t\trpc->enable |= RPCIF_SMENR_OPDE(\n\t\t\trpcif_bits_set(rpc, op->option.nbytes)) |\n\t\t\tRPCIF_SMENR_OPDB(rpcif_bit_size(op->option.buswidth));\n\t\tif (op->option.ddr)\n\t\t\trpc->ddr |= RPCIF_SMDRENR_OPDRE;\n\t\trpc->option = op->option.val;\n\t}\n\n\trpc->dir = op->data.dir;\n\tif (op->data.buswidth) {\n\t\tu32 nbytes;\n\n\t\trpc->buffer = op->data.buf.in;\n\t\tswitch (op->data.dir) {\n\t\tcase RPCIF_DATA_IN:\n\t\t\trpc->smcr = RPCIF_SMCR_SPIRE;\n\t\t\tbreak;\n\t\tcase RPCIF_DATA_OUT:\n\t\t\trpc->smcr = RPCIF_SMCR_SPIWE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (op->data.ddr)\n\t\t\trpc->ddr |= RPCIF_SMDRENR_SPIDRE;\n\n\t\tif (offs && len)\n\t\t\tnbytes = *len;\n\t\telse\n\t\t\tnbytes = op->data.nbytes;\n\t\trpc->xferlen = nbytes;\n\n\t\trpc->enable |= RPCIF_SMENR_SPIDB(rpcif_bit_size(op->data.buswidth));\n\t}\n}\nEXPORT_SYMBOL(rpcif_prepare);\n\nint rpcif_manual_xfer(struct device *dev)\n{\n\tstruct rpcif_priv *rpc = dev_get_drvdata(dev);\n\tu32 smenr, smcr, pos = 0, max = rpc->bus_size == 2 ? 8 : 4;\n\tint ret = 0;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_update_bits(rpc->regmap, RPCIF_PHYCNT,\n\t\t\t   RPCIF_PHYCNT_CAL, RPCIF_PHYCNT_CAL);\n\tregmap_update_bits(rpc->regmap, RPCIF_CMNCR,\n\t\t\t   RPCIF_CMNCR_MD, RPCIF_CMNCR_MD);\n\tregmap_write(rpc->regmap, RPCIF_SMCMR, rpc->command);\n\tregmap_write(rpc->regmap, RPCIF_SMOPR, rpc->option);\n\tregmap_write(rpc->regmap, RPCIF_SMDMCR, rpc->dummy);\n\tregmap_write(rpc->regmap, RPCIF_SMDRENR, rpc->ddr);\n\tregmap_write(rpc->regmap, RPCIF_SMADR, rpc->smadr);\n\tsmenr = rpc->enable;\n\n\tswitch (rpc->dir) {\n\tcase RPCIF_DATA_OUT:\n\t\twhile (pos < rpc->xferlen) {\n\t\t\tu32 bytes_left = rpc->xferlen - pos;\n\t\t\tu32 nbytes, data[2], *p = data;\n\n\t\t\tsmcr = rpc->smcr | RPCIF_SMCR_SPIE;\n\n\t\t\t \n\t\t\tnbytes = bytes_left >= max ? max : (1 << ilog2(bytes_left));\n\t\t\tif (bytes_left > nbytes)\n\t\t\t\tsmcr |= RPCIF_SMCR_SSLKP;\n\n\t\t\tsmenr |= RPCIF_SMENR_SPIDE(rpcif_bits_set(rpc, nbytes));\n\t\t\tregmap_write(rpc->regmap, RPCIF_SMENR, smenr);\n\t\t\trpc->xfer_size = nbytes;\n\n\t\t\tmemcpy(data, rpc->buffer + pos, nbytes);\n\t\t\tif (nbytes == 8)\n\t\t\t\tregmap_write(rpc->regmap, RPCIF_SMWDR1, *p++);\n\t\t\tregmap_write(rpc->regmap, RPCIF_SMWDR0, *p);\n\n\t\t\tregmap_write(rpc->regmap, RPCIF_SMCR, smcr);\n\t\t\tret = wait_msg_xfer_end(rpc);\n\t\t\tif (ret)\n\t\t\t\tgoto err_out;\n\n\t\t\tpos += nbytes;\n\t\t\tsmenr = rpc->enable &\n\t\t\t\t~RPCIF_SMENR_CDE & ~RPCIF_SMENR_ADE(0xF);\n\t\t}\n\t\tbreak;\n\tcase RPCIF_DATA_IN:\n\t\t \n\t\tif (!(smenr & RPCIF_SMENR_ADE(0xF)) && rpc->dirmap) {\n\t\t\tu32 dummy;\n\n\t\t\tregmap_update_bits(rpc->regmap, RPCIF_CMNCR,\n\t\t\t\t\t   RPCIF_CMNCR_MD, 0);\n\t\t\tregmap_write(rpc->regmap, RPCIF_DRCR,\n\t\t\t\t     RPCIF_DRCR_RBURST(32) | RPCIF_DRCR_RBE);\n\t\t\tregmap_write(rpc->regmap, RPCIF_DRCMR, rpc->command);\n\t\t\tregmap_write(rpc->regmap, RPCIF_DREAR,\n\t\t\t\t     RPCIF_DREAR_EAC(1));\n\t\t\tregmap_write(rpc->regmap, RPCIF_DROPR, rpc->option);\n\t\t\tregmap_write(rpc->regmap, RPCIF_DRENR,\n\t\t\t\t     smenr & ~RPCIF_SMENR_SPIDE(0xF));\n\t\t\tregmap_write(rpc->regmap, RPCIF_DRDMCR,  rpc->dummy);\n\t\t\tregmap_write(rpc->regmap, RPCIF_DRDRENR, rpc->ddr);\n\t\t\tmemcpy_fromio(rpc->buffer, rpc->dirmap, rpc->xferlen);\n\t\t\tregmap_write(rpc->regmap, RPCIF_DRCR, RPCIF_DRCR_RCF);\n\t\t\t \n\t\t\tregmap_read(rpc->regmap, RPCIF_DRCR, &dummy);\n\t\t\tbreak;\n\t\t}\n\t\twhile (pos < rpc->xferlen) {\n\t\t\tu32 bytes_left = rpc->xferlen - pos;\n\t\t\tu32 nbytes, data[2], *p = data;\n\n\t\t\t \n\t\t\tnbytes = bytes_left >= max ? max : (1 << ilog2(bytes_left));\n\n\t\t\tregmap_write(rpc->regmap, RPCIF_SMADR,\n\t\t\t\t     rpc->smadr + pos);\n\t\t\tsmenr &= ~RPCIF_SMENR_SPIDE(0xF);\n\t\t\tsmenr |= RPCIF_SMENR_SPIDE(rpcif_bits_set(rpc, nbytes));\n\t\t\tregmap_write(rpc->regmap, RPCIF_SMENR, smenr);\n\t\t\tregmap_write(rpc->regmap, RPCIF_SMCR,\n\t\t\t\t     rpc->smcr | RPCIF_SMCR_SPIE);\n\t\t\trpc->xfer_size = nbytes;\n\t\t\tret = wait_msg_xfer_end(rpc);\n\t\t\tif (ret)\n\t\t\t\tgoto err_out;\n\n\t\t\tif (nbytes == 8)\n\t\t\t\tregmap_read(rpc->regmap, RPCIF_SMRDR1, p++);\n\t\t\tregmap_read(rpc->regmap, RPCIF_SMRDR0, p);\n\t\t\tmemcpy(rpc->buffer + pos, data, nbytes);\n\n\t\t\tpos += nbytes;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tregmap_write(rpc->regmap, RPCIF_SMENR, rpc->enable);\n\t\tregmap_write(rpc->regmap, RPCIF_SMCR,\n\t\t\t     rpc->smcr | RPCIF_SMCR_SPIE);\n\t\tret = wait_msg_xfer_end(rpc);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t}\n\nexit:\n\tpm_runtime_put(dev);\n\treturn ret;\n\nerr_out:\n\tif (reset_control_reset(rpc->rstc))\n\t\tdev_err(dev, \"Failed to reset HW\\n\");\n\trpcif_hw_init(dev, rpc->bus_size == 2);\n\tgoto exit;\n}\nEXPORT_SYMBOL(rpcif_manual_xfer);\n\nstatic void memcpy_fromio_readw(void *to,\n\t\t\t\tconst void __iomem *from,\n\t\t\t\tsize_t count)\n{\n\tconst int maxw = (IS_ENABLED(CONFIG_64BIT)) ? 8 : 4;\n\tu8 buf[2];\n\n\tif (count && ((unsigned long)from & 1)) {\n\t\t*(u16 *)buf = __raw_readw((void __iomem *)((unsigned long)from & ~1));\n\t\t*(u8 *)to = buf[1];\n\t\tfrom++;\n\t\tto++;\n\t\tcount--;\n\t}\n\twhile (count >= 2 && !IS_ALIGNED((unsigned long)from, maxw)) {\n\t\t*(u16 *)to = __raw_readw(from);\n\t\tfrom += 2;\n\t\tto += 2;\n\t\tcount -= 2;\n\t}\n\twhile (count >= maxw) {\n#ifdef CONFIG_64BIT\n\t\t*(u64 *)to = __raw_readq(from);\n#else\n\t\t*(u32 *)to = __raw_readl(from);\n#endif\n\t\tfrom += maxw;\n\t\tto += maxw;\n\t\tcount -= maxw;\n\t}\n\twhile (count >= 2) {\n\t\t*(u16 *)to = __raw_readw(from);\n\t\tfrom += 2;\n\t\tto += 2;\n\t\tcount -= 2;\n\t}\n\tif (count) {\n\t\t*(u16 *)buf = __raw_readw(from);\n\t\t*(u8 *)to = buf[0];\n\t}\n}\n\nssize_t rpcif_dirmap_read(struct device *dev, u64 offs, size_t len, void *buf)\n{\n\tstruct rpcif_priv *rpc = dev_get_drvdata(dev);\n\tloff_t from = offs & (rpc->size - 1);\n\tsize_t size = rpc->size - from;\n\tint ret;\n\n\tif (len > size)\n\t\tlen = size;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_update_bits(rpc->regmap, RPCIF_CMNCR, RPCIF_CMNCR_MD, 0);\n\tregmap_write(rpc->regmap, RPCIF_DRCR, 0);\n\tregmap_write(rpc->regmap, RPCIF_DRCMR, rpc->command);\n\tregmap_write(rpc->regmap, RPCIF_DREAR,\n\t\t     RPCIF_DREAR_EAV(offs >> 25) | RPCIF_DREAR_EAC(1));\n\tregmap_write(rpc->regmap, RPCIF_DROPR, rpc->option);\n\tregmap_write(rpc->regmap, RPCIF_DRENR,\n\t\t     rpc->enable & ~RPCIF_SMENR_SPIDE(0xF));\n\tregmap_write(rpc->regmap, RPCIF_DRDMCR, rpc->dummy);\n\tregmap_write(rpc->regmap, RPCIF_DRDRENR, rpc->ddr);\n\n\tif (rpc->bus_size == 2)\n\t\tmemcpy_fromio_readw(buf, rpc->dirmap + from, len);\n\telse\n\t\tmemcpy_fromio(buf, rpc->dirmap + from, len);\n\n\tpm_runtime_put(dev);\n\n\treturn len;\n}\nEXPORT_SYMBOL(rpcif_dirmap_read);\n\nstatic int rpcif_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct platform_device *vdev;\n\tstruct device_node *flash;\n\tstruct rpcif_priv *rpc;\n\tstruct resource *res;\n\tconst char *name;\n\tint ret;\n\n\tflash = of_get_next_child(dev->of_node, NULL);\n\tif (!flash) {\n\t\tdev_warn(dev, \"no flash node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_device_is_compatible(flash, \"jedec,spi-nor\")) {\n\t\tname = \"rpc-if-spi\";\n\t} else if (of_device_is_compatible(flash, \"cfi-flash\")) {\n\t\tname = \"rpc-if-hyperflash\";\n\t} else\t{\n\t\tof_node_put(flash);\n\t\tdev_warn(dev, \"unknown flash type\\n\");\n\t\treturn -ENODEV;\n\t}\n\tof_node_put(flash);\n\n\trpc = devm_kzalloc(dev, sizeof(*rpc), GFP_KERNEL);\n\tif (!rpc)\n\t\treturn -ENOMEM;\n\n\trpc->base = devm_platform_ioremap_resource_byname(pdev, \"regs\");\n\tif (IS_ERR(rpc->base))\n\t\treturn PTR_ERR(rpc->base);\n\n\trpc->regmap = devm_regmap_init(dev, NULL, rpc, &rpcif_regmap_config);\n\tif (IS_ERR(rpc->regmap)) {\n\t\tdev_err(dev, \"failed to init regmap for rpcif, error %ld\\n\",\n\t\t\tPTR_ERR(rpc->regmap));\n\t\treturn\tPTR_ERR(rpc->regmap);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dirmap\");\n\trpc->dirmap = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(rpc->dirmap))\n\t\treturn PTR_ERR(rpc->dirmap);\n\n\trpc->size = resource_size(res);\n\trpc->info = of_device_get_match_data(dev);\n\trpc->rstc = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rpc->rstc))\n\t\treturn PTR_ERR(rpc->rstc);\n\n\tvdev = platform_device_alloc(name, pdev->id);\n\tif (!vdev)\n\t\treturn -ENOMEM;\n\tvdev->dev.parent = dev;\n\n\trpc->dev = dev;\n\trpc->vdev = vdev;\n\tplatform_set_drvdata(pdev, rpc);\n\n\tret = platform_device_add(vdev);\n\tif (ret) {\n\t\tplatform_device_put(vdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rpcif_remove(struct platform_device *pdev)\n{\n\tstruct rpcif_priv *rpc = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(rpc->vdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rpcif_of_match[] = {\n\t{ .compatible = \"renesas,r8a7796-rpc-if\", .data = &rpcif_info_r8a7796 },\n\t{ .compatible = \"renesas,rcar-gen3-rpc-if\", .data = &rpcif_info_gen3 },\n\t{ .compatible = \"renesas,rcar-gen4-rpc-if\", .data = &rpcif_info_gen4 },\n\t{ .compatible = \"renesas,rzg2l-rpc-if\", .data = &rpcif_info_rz_g2l },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rpcif_of_match);\n\nstatic struct platform_driver rpcif_driver = {\n\t.probe\t= rpcif_probe,\n\t.remove\t= rpcif_remove,\n\t.driver = {\n\t\t.name =\t\"rpc-if\",\n\t\t.of_match_table = rpcif_of_match,\n\t},\n};\nmodule_platform_driver(rpcif_driver);\n\nMODULE_DESCRIPTION(\"Renesas RPC-IF core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}