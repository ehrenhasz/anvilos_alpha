{
  "module_name": "da8xx-ddrctl.c",
  "hash_id": "90f8afd8fb39d56dd15cb0480078d6a8f8e7da7cb9d5ad716db72e0029ca3ddf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/da8xx-ddrctl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n\n \n\nstruct da8xx_ddrctl_config_knob {\n\tconst char *name;\n\tu32 reg;\n\tu32 mask;\n\tu32 shift;\n};\n\nstatic const struct da8xx_ddrctl_config_knob da8xx_ddrctl_knobs[] = {\n\t{\n\t\t.name = \"da850-pbbpr\",\n\t\t.reg = 0x20,\n\t\t.mask = 0xffffff00,\n\t\t.shift = 0,\n\t},\n};\n\nstruct da8xx_ddrctl_setting {\n\tconst char *name;\n\tu32 val;\n};\n\nstruct da8xx_ddrctl_board_settings {\n\tconst char *board;\n\tconst struct da8xx_ddrctl_setting *settings;\n};\n\nstatic const struct da8xx_ddrctl_setting da850_lcdk_ddrctl_settings[] = {\n\t{\n\t\t.name = \"da850-pbbpr\",\n\t\t.val = 0x20,\n\t},\n\t{ }\n};\n\nstatic const struct da8xx_ddrctl_board_settings da8xx_ddrctl_board_confs[] = {\n\t{\n\t\t.board = \"ti,da850-lcdk\",\n\t\t.settings = da850_lcdk_ddrctl_settings,\n\t},\n};\n\nstatic const struct da8xx_ddrctl_config_knob *\nda8xx_ddrctl_match_knob(const struct da8xx_ddrctl_setting *setting)\n{\n\tconst struct da8xx_ddrctl_config_knob *knob;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(da8xx_ddrctl_knobs); i++) {\n\t\tknob = &da8xx_ddrctl_knobs[i];\n\n\t\tif (strcmp(knob->name, setting->name) == 0)\n\t\t\treturn knob;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct da8xx_ddrctl_setting *da8xx_ddrctl_get_board_settings(void)\n{\n\tconst struct da8xx_ddrctl_board_settings *board_settings;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(da8xx_ddrctl_board_confs); i++) {\n\t\tboard_settings = &da8xx_ddrctl_board_confs[i];\n\n\t\tif (of_machine_is_compatible(board_settings->board))\n\t\t\treturn board_settings->settings;\n\t}\n\n\treturn NULL;\n}\n\nstatic int da8xx_ddrctl_probe(struct platform_device *pdev)\n{\n\tconst struct da8xx_ddrctl_config_knob *knob;\n\tconst struct da8xx_ddrctl_setting *setting;\n\tstruct resource *res;\n\tvoid __iomem *ddrctl;\n\tstruct device *dev;\n\tu32 reg;\n\n\tdev = &pdev->dev;\n\n\tsetting = da8xx_ddrctl_get_board_settings();\n\tif (!setting) {\n\t\tdev_err(dev, \"no settings defined for this board\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tddrctl = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ddrctl)) {\n\t\tdev_err(dev, \"unable to map memory controller registers\\n\");\n\t\treturn PTR_ERR(ddrctl);\n\t}\n\n\tfor (; setting->name; setting++) {\n\t\tknob = da8xx_ddrctl_match_knob(setting);\n\t\tif (!knob) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"no such config option: %s\\n\", setting->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (knob->reg + sizeof(u32) > resource_size(res)) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"register offset of '%s' exceeds mapped memory size\\n\",\n\t\t\t\t knob->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\treg = readl(ddrctl + knob->reg);\n\t\treg &= knob->mask;\n\t\treg |= setting->val << knob->shift;\n\n\t\tdev_dbg(dev, \"writing 0x%08x to %s\\n\", reg, setting->name);\n\n\t\twritel(reg, ddrctl + knob->reg);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id da8xx_ddrctl_of_match[] = {\n\t{ .compatible = \"ti,da850-ddr-controller\", },\n\t{ },\n};\n\nstatic struct platform_driver da8xx_ddrctl_driver = {\n\t.probe = da8xx_ddrctl_probe,\n\t.driver = {\n\t\t.name = \"da850-ddr-controller\",\n\t\t.of_match_table = da8xx_ddrctl_of_match,\n\t},\n};\nmodule_platform_driver(da8xx_ddrctl_driver);\n\nMODULE_AUTHOR(\"Bartosz Golaszewski <bgolaszewski@baylibre.com>\");\nMODULE_DESCRIPTION(\"TI da8xx DDR2/mDDR controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}