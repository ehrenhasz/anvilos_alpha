{
  "module_name": "pl172.c",
  "hash_id": "9ef3e2df16e080585fccd85781071b0beffb1a783c535f1350f9a60fa620350d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/pl172.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/time.h>\n\n#define MPMC_STATIC_CFG(n)\t\t(0x200 + 0x20 * (n))\n#define  MPMC_STATIC_CFG_MW_8BIT\t0x0\n#define  MPMC_STATIC_CFG_MW_16BIT\t0x1\n#define  MPMC_STATIC_CFG_MW_32BIT\t0x2\n#define  MPMC_STATIC_CFG_PM\t\tBIT(3)\n#define  MPMC_STATIC_CFG_PC\t\tBIT(6)\n#define  MPMC_STATIC_CFG_PB\t\tBIT(7)\n#define  MPMC_STATIC_CFG_EW\t\tBIT(8)\n#define  MPMC_STATIC_CFG_B\t\tBIT(19)\n#define  MPMC_STATIC_CFG_P\t\tBIT(20)\n#define MPMC_STATIC_WAIT_WEN(n)\t\t(0x204 + 0x20 * (n))\n#define  MPMC_STATIC_WAIT_WEN_MAX\t0x0f\n#define MPMC_STATIC_WAIT_OEN(n)\t\t(0x208 + 0x20 * (n))\n#define  MPMC_STATIC_WAIT_OEN_MAX\t0x0f\n#define MPMC_STATIC_WAIT_RD(n)\t\t(0x20c + 0x20 * (n))\n#define  MPMC_STATIC_WAIT_RD_MAX\t0x1f\n#define MPMC_STATIC_WAIT_PAGE(n)\t(0x210 + 0x20 * (n))\n#define  MPMC_STATIC_WAIT_PAGE_MAX\t0x1f\n#define MPMC_STATIC_WAIT_WR(n)\t\t(0x214 + 0x20 * (n))\n#define  MPMC_STATIC_WAIT_WR_MAX\t0x1f\n#define MPMC_STATIC_WAIT_TURN(n)\t(0x218 + 0x20 * (n))\n#define  MPMC_STATIC_WAIT_TURN_MAX\t0x0f\n\n \n#define PL172_MAX_CS\t\t4\n\nstruct pl172_data {\n\tvoid __iomem *base;\n\tunsigned long rate;\n\tstruct clk *clk;\n};\n\nstatic int pl172_timing_prop(struct amba_device *adev,\n\t\t\t     const struct device_node *np, const char *name,\n\t\t\t     u32 reg_offset, u32 max, int start)\n{\n\tstruct pl172_data *pl172 = amba_get_drvdata(adev);\n\tint cycles;\n\tu32 val;\n\n\tif (!of_property_read_u32(np, name, &val)) {\n\t\tcycles = DIV_ROUND_UP(val * pl172->rate, NSEC_PER_MSEC) - start;\n\t\tif (cycles < 0) {\n\t\t\tcycles = 0;\n\t\t} else if (cycles > max) {\n\t\t\tdev_err(&adev->dev, \"%s timing too tight\\n\", name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twritel(cycles, pl172->base + reg_offset);\n\t}\n\n\tdev_dbg(&adev->dev, \"%s: %u cycle(s)\\n\", name, start +\n\t\t\t\treadl(pl172->base + reg_offset));\n\n\treturn 0;\n}\n\nstatic int pl172_setup_static(struct amba_device *adev,\n\t\t\t      struct device_node *np, u32 cs)\n{\n\tstruct pl172_data *pl172 = amba_get_drvdata(adev);\n\tu32 cfg;\n\tint ret;\n\n\t \n\tif (!of_property_read_u32(np, \"mpmc,memory-width\", &cfg)) {\n\t\tif (cfg == 8) {\n\t\t\tcfg = MPMC_STATIC_CFG_MW_8BIT;\n\t\t} else if (cfg == 16) {\n\t\t\tcfg = MPMC_STATIC_CFG_MW_16BIT;\n\t\t} else if (cfg == 32) {\n\t\t\tcfg = MPMC_STATIC_CFG_MW_32BIT;\n\t\t} else {\n\t\t\tdev_err(&adev->dev, \"invalid memory width cs%u\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tdev_err(&adev->dev, \"memory-width property required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(np, \"mpmc,async-page-mode\"))\n\t\tcfg |= MPMC_STATIC_CFG_PM;\n\n\tif (of_property_read_bool(np, \"mpmc,cs-active-high\"))\n\t\tcfg |= MPMC_STATIC_CFG_PC;\n\n\tif (of_property_read_bool(np, \"mpmc,byte-lane-low\"))\n\t\tcfg |= MPMC_STATIC_CFG_PB;\n\n\tif (of_property_read_bool(np, \"mpmc,extended-wait\"))\n\t\tcfg |= MPMC_STATIC_CFG_EW;\n\n\tif (amba_part(adev) == 0x172 &&\n\t    of_property_read_bool(np, \"mpmc,buffer-enable\"))\n\t\tcfg |= MPMC_STATIC_CFG_B;\n\n\tif (of_property_read_bool(np, \"mpmc,write-protect\"))\n\t\tcfg |= MPMC_STATIC_CFG_P;\n\n\twritel(cfg, pl172->base + MPMC_STATIC_CFG(cs));\n\tdev_dbg(&adev->dev, \"mpmc static config cs%u: 0x%08x\\n\", cs, cfg);\n\n\t \n\tret = pl172_timing_prop(adev, np, \"mpmc,write-enable-delay\",\n\t\t\t\tMPMC_STATIC_WAIT_WEN(cs),\n\t\t\t\tMPMC_STATIC_WAIT_WEN_MAX, 1);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pl172_timing_prop(adev, np, \"mpmc,output-enable-delay\",\n\t\t\t\tMPMC_STATIC_WAIT_OEN(cs),\n\t\t\t\tMPMC_STATIC_WAIT_OEN_MAX, 0);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pl172_timing_prop(adev, np, \"mpmc,read-access-delay\",\n\t\t\t\tMPMC_STATIC_WAIT_RD(cs),\n\t\t\t\tMPMC_STATIC_WAIT_RD_MAX, 1);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pl172_timing_prop(adev, np, \"mpmc,page-mode-read-delay\",\n\t\t\t\tMPMC_STATIC_WAIT_PAGE(cs),\n\t\t\t\tMPMC_STATIC_WAIT_PAGE_MAX, 1);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pl172_timing_prop(adev, np, \"mpmc,write-access-delay\",\n\t\t\t\tMPMC_STATIC_WAIT_WR(cs),\n\t\t\t\tMPMC_STATIC_WAIT_WR_MAX, 2);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pl172_timing_prop(adev, np, \"mpmc,turn-round-delay\",\n\t\t\t\tMPMC_STATIC_WAIT_TURN(cs),\n\t\t\t\tMPMC_STATIC_WAIT_TURN_MAX, 1);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdev_err(&adev->dev, \"failed to configure cs%u\\n\", cs);\n\treturn ret;\n}\n\nstatic int pl172_parse_cs_config(struct amba_device *adev,\n\t\t\t\t struct device_node *np)\n{\n\tu32 cs;\n\n\tif (!of_property_read_u32(np, \"mpmc,cs\", &cs)) {\n\t\tif (cs >= PL172_MAX_CS) {\n\t\t\tdev_err(&adev->dev, \"cs%u invalid\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn pl172_setup_static(adev, np, cs);\n\t}\n\n\tdev_err(&adev->dev, \"cs property required\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic const char * const pl172_revisions[] = {\"r1\", \"r2\", \"r2p3\", \"r2p4\"};\nstatic const char * const pl175_revisions[] = {\"r1\"};\nstatic const char * const pl176_revisions[] = {\"r0\"};\n\nstatic int pl172_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct device_node *child_np, *np = adev->dev.of_node;\n\tstruct device *dev = &adev->dev;\n\tstatic const char *rev = \"?\";\n\tstruct pl172_data *pl172;\n\tint ret;\n\n\tif (amba_part(adev) == 0x172) {\n\t\tif (amba_rev(adev) < ARRAY_SIZE(pl172_revisions))\n\t\t\trev = pl172_revisions[amba_rev(adev)];\n\t} else if (amba_part(adev) == 0x175) {\n\t\tif (amba_rev(adev) < ARRAY_SIZE(pl175_revisions))\n\t\t\trev = pl175_revisions[amba_rev(adev)];\n\t} else if (amba_part(adev) == 0x176) {\n\t\tif (amba_rev(adev) < ARRAY_SIZE(pl176_revisions))\n\t\t\trev = pl176_revisions[amba_rev(adev)];\n\t}\n\n\tdev_info(dev, \"ARM PL%x revision %s\\n\", amba_part(adev), rev);\n\n\tpl172 = devm_kzalloc(dev, sizeof(*pl172), GFP_KERNEL);\n\tif (!pl172)\n\t\treturn -ENOMEM;\n\n\tpl172->clk = devm_clk_get(dev, \"mpmcclk\");\n\tif (IS_ERR(pl172->clk)) {\n\t\tdev_err(dev, \"no mpmcclk provided clock\\n\");\n\t\treturn PTR_ERR(pl172->clk);\n\t}\n\n\tret = clk_prepare_enable(pl172->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to mpmcclk enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpl172->rate = clk_get_rate(pl172->clk) / MSEC_PER_SEC;\n\tif (!pl172->rate) {\n\t\tdev_err(dev, \"unable to get mpmcclk clock rate\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk_enable;\n\t}\n\n\tret = amba_request_regions(adev, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request AMBA regions\\n\");\n\t\tgoto err_clk_enable;\n\t}\n\n\tpl172->base = devm_ioremap(dev, adev->res.start,\n\t\t\t\t   resource_size(&adev->res));\n\tif (!pl172->base) {\n\t\tdev_err(dev, \"ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_no_ioremap;\n\t}\n\n\tamba_set_drvdata(adev, pl172);\n\n\t \n\tfor_each_available_child_of_node(np, child_np) {\n\t\tret = pl172_parse_cs_config(adev, child_np);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tof_platform_populate(child_np, NULL, NULL, dev);\n\t}\n\n\treturn 0;\n\nerr_no_ioremap:\n\tamba_release_regions(adev);\nerr_clk_enable:\n\tclk_disable_unprepare(pl172->clk);\n\treturn ret;\n}\n\nstatic void pl172_remove(struct amba_device *adev)\n{\n\tstruct pl172_data *pl172 = amba_get_drvdata(adev);\n\n\tclk_disable_unprepare(pl172->clk);\n\tamba_release_regions(adev);\n}\n\nstatic const struct amba_id pl172_ids[] = {\n\t \n\t{\n\t\t.id\t= 0x07041172,\n\t\t.mask\t= 0x3f0fffff,\n\t},\n\t \n\t{\n\t\t.id\t= 0x07041175,\n\t\t.mask\t= 0x3f0fffff,\n\t},\n\t \n\t{\n\t\t.id\t= 0x89041176,\n\t\t.mask\t= 0xff0fffff,\n\t},\n\t{ 0, 0 },\n};\nMODULE_DEVICE_TABLE(amba, pl172_ids);\n\nstatic struct amba_driver pl172_driver = {\n\t.drv = {\n\t\t.name\t= \"memory-pl172\",\n\t},\n\t.probe\t\t= pl172_probe,\n\t.remove\t\t= pl172_remove,\n\t.id_table\t= pl172_ids,\n};\nmodule_amba_driver(pl172_driver);\n\nMODULE_AUTHOR(\"Joachim Eastwood <manabian@gmail.com>\");\nMODULE_DESCRIPTION(\"PL172 Memory Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}