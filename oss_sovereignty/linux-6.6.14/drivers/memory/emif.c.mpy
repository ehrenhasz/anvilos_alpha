{
  "module_name": "emif.c",
  "hash_id": "2b6d186d43be77006df524bd33496942432a779c18c623a8cff2cbd8355dda86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/emif.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/reboot.h>\n#include <linux/platform_data/emif_plat.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/pm.h>\n\n#include \"emif.h\"\n#include \"jedec_ddr.h\"\n#include \"of_memory.h\"\n\n \nstruct emif_data {\n\tu8\t\t\t\tduplicate;\n\tu8\t\t\t\ttemperature_level;\n\tu8\t\t\t\tlpmode;\n\tstruct list_head\t\tnode;\n\tunsigned long\t\t\tirq_state;\n\tvoid __iomem\t\t\t*base;\n\tstruct device\t\t\t*dev;\n\tstruct emif_regs\t\t*regs_cache[EMIF_MAX_NUM_FREQUENCIES];\n\tstruct emif_regs\t\t*curr_regs;\n\tstruct emif_platform_data\t*plat_data;\n\tstruct dentry\t\t\t*debugfs_root;\n\tstruct device_node\t\t*np_ddr;\n};\n\nstatic struct emif_data *emif1;\nstatic DEFINE_SPINLOCK(emif_lock);\nstatic unsigned long\tirq_state;\nstatic LIST_HEAD(device_list);\n\n#ifdef CONFIG_DEBUG_FS\nstatic void do_emif_regdump_show(struct seq_file *s, struct emif_data *emif,\n\tstruct emif_regs *regs)\n{\n\tu32 type = emif->plat_data->device_info->type;\n\tu32 ip_rev = emif->plat_data->ip_rev;\n\n\tseq_printf(s, \"EMIF register cache dump for %dMHz\\n\",\n\t\tregs->freq/1000000);\n\n\tseq_printf(s, \"ref_ctrl_shdw\\t: 0x%08x\\n\", regs->ref_ctrl_shdw);\n\tseq_printf(s, \"sdram_tim1_shdw\\t: 0x%08x\\n\", regs->sdram_tim1_shdw);\n\tseq_printf(s, \"sdram_tim2_shdw\\t: 0x%08x\\n\", regs->sdram_tim2_shdw);\n\tseq_printf(s, \"sdram_tim3_shdw\\t: 0x%08x\\n\", regs->sdram_tim3_shdw);\n\n\tif (ip_rev == EMIF_4D) {\n\t\tseq_printf(s, \"read_idle_ctrl_shdw_normal\\t: 0x%08x\\n\",\n\t\t\tregs->read_idle_ctrl_shdw_normal);\n\t\tseq_printf(s, \"read_idle_ctrl_shdw_volt_ramp\\t: 0x%08x\\n\",\n\t\t\tregs->read_idle_ctrl_shdw_volt_ramp);\n\t} else if (ip_rev == EMIF_4D5) {\n\t\tseq_printf(s, \"dll_calib_ctrl_shdw_normal\\t: 0x%08x\\n\",\n\t\t\tregs->dll_calib_ctrl_shdw_normal);\n\t\tseq_printf(s, \"dll_calib_ctrl_shdw_volt_ramp\\t: 0x%08x\\n\",\n\t\t\tregs->dll_calib_ctrl_shdw_volt_ramp);\n\t}\n\n\tif (type == DDR_TYPE_LPDDR2_S2 || type == DDR_TYPE_LPDDR2_S4) {\n\t\tseq_printf(s, \"ref_ctrl_shdw_derated\\t: 0x%08x\\n\",\n\t\t\tregs->ref_ctrl_shdw_derated);\n\t\tseq_printf(s, \"sdram_tim1_shdw_derated\\t: 0x%08x\\n\",\n\t\t\tregs->sdram_tim1_shdw_derated);\n\t\tseq_printf(s, \"sdram_tim3_shdw_derated\\t: 0x%08x\\n\",\n\t\t\tregs->sdram_tim3_shdw_derated);\n\t}\n}\n\nstatic int emif_regdump_show(struct seq_file *s, void *unused)\n{\n\tstruct emif_data\t*emif\t= s->private;\n\tstruct emif_regs\t**regs_cache;\n\tint\t\t\ti;\n\n\tif (emif->duplicate)\n\t\tregs_cache = emif1->regs_cache;\n\telse\n\t\tregs_cache = emif->regs_cache;\n\n\tfor (i = 0; i < EMIF_MAX_NUM_FREQUENCIES && regs_cache[i]; i++) {\n\t\tdo_emif_regdump_show(s, emif, regs_cache[i]);\n\t\tseq_putc(s, '\\n');\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(emif_regdump);\n\nstatic int emif_mr4_show(struct seq_file *s, void *unused)\n{\n\tstruct emif_data *emif = s->private;\n\n\tseq_printf(s, \"MR4=%d\\n\", emif->temperature_level);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(emif_mr4);\n\nstatic int __init_or_module emif_debugfs_init(struct emif_data *emif)\n{\n\temif->debugfs_root = debugfs_create_dir(dev_name(emif->dev), NULL);\n\tdebugfs_create_file(\"regcache_dump\", S_IRUGO, emif->debugfs_root, emif,\n\t\t\t    &emif_regdump_fops);\n\tdebugfs_create_file(\"mr4\", S_IRUGO, emif->debugfs_root, emif,\n\t\t\t    &emif_mr4_fops);\n\treturn 0;\n}\n\nstatic void __exit emif_debugfs_exit(struct emif_data *emif)\n{\n\tdebugfs_remove_recursive(emif->debugfs_root);\n\temif->debugfs_root = NULL;\n}\n#else\nstatic inline int __init_or_module emif_debugfs_init(struct emif_data *emif)\n{\n\treturn 0;\n}\n\nstatic inline void __exit emif_debugfs_exit(struct emif_data *emif)\n{\n}\n#endif\n\n \nstatic u32 get_emif_bus_width(struct emif_data *emif)\n{\n\tu32\t\twidth;\n\tvoid __iomem\t*base = emif->base;\n\n\twidth = (readl(base + EMIF_SDRAM_CONFIG) & NARROW_MODE_MASK)\n\t\t\t>> NARROW_MODE_SHIFT;\n\twidth = width == 0 ? 32 : 16;\n\n\treturn width;\n}\n\nstatic void set_lpmode(struct emif_data *emif, u8 lpmode)\n{\n\tu32 temp;\n\tvoid __iomem *base = emif->base;\n\n\t \n\tif ((emif->plat_data->ip_rev == EMIF_4D) &&\n\t    (lpmode == EMIF_LP_MODE_PWR_DN)) {\n\t\tWARN_ONCE(1,\n\t\t\t  \"REG_LP_MODE = LP_MODE_PWR_DN(4) is prohibited by erratum i743 switch to LP_MODE_SELF_REFRESH(2)\\n\");\n\t\t \n\t\tlpmode = EMIF_LP_MODE_SELF_REFRESH;\n\t}\n\n\ttemp = readl(base + EMIF_POWER_MANAGEMENT_CONTROL);\n\ttemp &= ~LP_MODE_MASK;\n\ttemp |= (lpmode << LP_MODE_SHIFT);\n\twritel(temp, base + EMIF_POWER_MANAGEMENT_CONTROL);\n}\n\nstatic void do_freq_update(void)\n{\n\tstruct emif_data *emif;\n\n\t \n\tlist_for_each_entry(emif, &device_list, node) {\n\t\tif (emif->lpmode == EMIF_LP_MODE_SELF_REFRESH)\n\t\t\tset_lpmode(emif, EMIF_LP_MODE_DISABLE);\n\t}\n\n\t \n\n\tlist_for_each_entry(emif, &device_list, node) {\n\t\tif (emif->lpmode == EMIF_LP_MODE_SELF_REFRESH)\n\t\t\tset_lpmode(emif, EMIF_LP_MODE_SELF_REFRESH);\n\t}\n}\n\n \nstatic const struct lpddr2_addressing *get_addressing_table(\n\tconst struct ddr_device_info *device_info)\n{\n\tu32\t\tindex, type, density;\n\n\ttype = device_info->type;\n\tdensity = device_info->density;\n\n\tswitch (type) {\n\tcase DDR_TYPE_LPDDR2_S4:\n\t\tindex = density - 1;\n\t\tbreak;\n\tcase DDR_TYPE_LPDDR2_S2:\n\t\tswitch (density) {\n\t\tcase DDR_DENSITY_1Gb:\n\t\tcase DDR_DENSITY_2Gb:\n\t\t\tindex = density + 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tindex = density - 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &lpddr2_jedec_addressing_table[index];\n}\n\nstatic u32 get_zq_config_reg(const struct lpddr2_addressing *addressing,\n\t\tbool cs1_used, bool cal_resistors_per_cs)\n{\n\tu32 zq = 0, val = 0;\n\n\tval = EMIF_ZQCS_INTERVAL_US * 1000 / addressing->tREFI_ns;\n\tzq |= val << ZQ_REFINTERVAL_SHIFT;\n\n\tval = DIV_ROUND_UP(T_ZQCL_DEFAULT_NS, T_ZQCS_DEFAULT_NS) - 1;\n\tzq |= val << ZQ_ZQCL_MULT_SHIFT;\n\n\tval = DIV_ROUND_UP(T_ZQINIT_DEFAULT_NS, T_ZQCL_DEFAULT_NS) - 1;\n\tzq |= val << ZQ_ZQINIT_MULT_SHIFT;\n\n\tzq |= ZQ_SFEXITEN_ENABLE << ZQ_SFEXITEN_SHIFT;\n\n\tif (cal_resistors_per_cs)\n\t\tzq |= ZQ_DUALCALEN_ENABLE << ZQ_DUALCALEN_SHIFT;\n\telse\n\t\tzq |= ZQ_DUALCALEN_DISABLE << ZQ_DUALCALEN_SHIFT;\n\n\tzq |= ZQ_CS0EN_MASK;  \n\n\tval = cs1_used ? 1 : 0;\n\tzq |= val << ZQ_CS1EN_SHIFT;\n\n\treturn zq;\n}\n\nstatic u32 get_temp_alert_config(const struct lpddr2_addressing *addressing,\n\t\tconst struct emif_custom_configs *custom_configs, bool cs1_used,\n\t\tu32 sdram_io_width, u32 emif_bus_width)\n{\n\tu32 alert = 0, interval, devcnt;\n\n\tif (custom_configs && (custom_configs->mask &\n\t\t\t\tEMIF_CUSTOM_CONFIG_TEMP_ALERT_POLL_INTERVAL))\n\t\tinterval = custom_configs->temp_alert_poll_interval_ms;\n\telse\n\t\tinterval = TEMP_ALERT_POLL_INTERVAL_DEFAULT_MS;\n\n\tinterval *= 1000000;\t\t\t \n\tinterval /= addressing->tREFI_ns;\t \n\talert |= (interval << TA_REFINTERVAL_SHIFT);\n\n\t \n\temif_bus_width = __fls(emif_bus_width) - 1;\n\tdevcnt = emif_bus_width - sdram_io_width;\n\talert |= devcnt << TA_DEVCNT_SHIFT;\n\n\t \n\talert |= (sdram_io_width - 2) << TA_DEVWDT_SHIFT;\n\n\talert |= 1 << TA_SFEXITEN_SHIFT;\n\talert |= 1 << TA_CS0EN_SHIFT;\n\talert |= (cs1_used ? 1 : 0) << TA_CS1EN_SHIFT;\n\n\treturn alert;\n}\n\nstatic u32 get_pwr_mgmt_ctrl(u32 freq, struct emif_data *emif, u32 ip_rev)\n{\n\tu32 pwr_mgmt_ctrl\t= 0, timeout;\n\tu32 lpmode\t\t= EMIF_LP_MODE_SELF_REFRESH;\n\tu32 timeout_perf\t= EMIF_LP_MODE_TIMEOUT_PERFORMANCE;\n\tu32 timeout_pwr\t\t= EMIF_LP_MODE_TIMEOUT_POWER;\n\tu32 freq_threshold\t= EMIF_LP_MODE_FREQ_THRESHOLD;\n\tu32 mask;\n\tu8 shift;\n\n\tstruct emif_custom_configs *cust_cfgs = emif->plat_data->custom_configs;\n\n\tif (cust_cfgs && (cust_cfgs->mask & EMIF_CUSTOM_CONFIG_LPMODE)) {\n\t\tlpmode\t\t= cust_cfgs->lpmode;\n\t\ttimeout_perf\t= cust_cfgs->lpmode_timeout_performance;\n\t\ttimeout_pwr\t= cust_cfgs->lpmode_timeout_power;\n\t\tfreq_threshold  = cust_cfgs->lpmode_freq_threshold;\n\t}\n\n\t \n\ttimeout = freq >= freq_threshold ? timeout_perf : timeout_pwr;\n\n\t \n\tif (timeout < 16) {\n\t\ttimeout = 0;\n\t} else {\n\t\tif (timeout & (timeout - 1))\n\t\t\ttimeout <<= 1;\n\t\ttimeout = __fls(timeout) - 3;\n\t}\n\n\tswitch (lpmode) {\n\tcase EMIF_LP_MODE_CLOCK_STOP:\n\t\tshift = CS_TIM_SHIFT;\n\t\tmask = CS_TIM_MASK;\n\t\tbreak;\n\tcase EMIF_LP_MODE_SELF_REFRESH:\n\t\t \n\t\tif (timeout < 6)\n\t\t\ttimeout = 6;\n\n\t\tshift = SR_TIM_SHIFT;\n\t\tmask = SR_TIM_MASK;\n\t\tbreak;\n\tcase EMIF_LP_MODE_PWR_DN:\n\t\tshift = PD_TIM_SHIFT;\n\t\tmask = PD_TIM_MASK;\n\t\tbreak;\n\tcase EMIF_LP_MODE_DISABLE:\n\tdefault:\n\t\tmask = 0;\n\t\tshift = 0;\n\t\tbreak;\n\t}\n\t \n\tif (lpmode != EMIF_LP_MODE_DISABLE && timeout > mask >> shift) {\n\t\tpr_err(\"TIMEOUT Overflow - lpmode=%d perf=%d pwr=%d freq=%d\\n\",\n\t\t       lpmode,\n\t\t       timeout_perf,\n\t\t       timeout_pwr,\n\t\t       freq_threshold);\n\t\tWARN(1, \"timeout=0x%02x greater than 0x%02x. Using max\\n\",\n\t\t     timeout, mask >> shift);\n\t\ttimeout = mask >> shift;\n\t}\n\n\t \n\tpwr_mgmt_ctrl = (timeout << shift) & mask;\n\t \n\tpwr_mgmt_ctrl |= (SR_TIM_MASK | CS_TIM_MASK | PD_TIM_MASK) &\n\t\t\t  ~mask;\n\n\t \n\tif (ip_rev == EMIF_4D5)\n\t\tpwr_mgmt_ctrl &= ~CS_TIM_MASK;\n\n\tpwr_mgmt_ctrl |= lpmode << LP_MODE_SHIFT;\n\n\treturn pwr_mgmt_ctrl;\n}\n\n \nstatic void get_temperature_level(struct emif_data *emif)\n{\n\tu32\t\ttemp, temperature_level;\n\tvoid __iomem\t*base;\n\n\tbase = emif->base;\n\n\t \n\twritel(DDR_MR4, base + EMIF_LPDDR2_MODE_REG_CONFIG);\n\ttemperature_level = readl(base + EMIF_LPDDR2_MODE_REG_DATA);\n\ttemperature_level = (temperature_level & MR4_SDRAM_REF_RATE_MASK) >>\n\t\t\t\tMR4_SDRAM_REF_RATE_SHIFT;\n\n\tif (emif->plat_data->device_info->cs1_used) {\n\t\twritel(DDR_MR4 | CS_MASK, base + EMIF_LPDDR2_MODE_REG_CONFIG);\n\t\ttemp = readl(base + EMIF_LPDDR2_MODE_REG_DATA);\n\t\ttemp = (temp & MR4_SDRAM_REF_RATE_MASK)\n\t\t\t\t>> MR4_SDRAM_REF_RATE_SHIFT;\n\t\ttemperature_level = max(temp, temperature_level);\n\t}\n\n\t \n\tif (unlikely(temperature_level < SDRAM_TEMP_NOMINAL))\n\t\ttemperature_level = SDRAM_TEMP_NOMINAL;\n\n\t \n\tif (likely(temperature_level != SDRAM_TEMP_RESERVED_4))\n\t\temif->temperature_level = temperature_level;\n}\n\n \nstatic void setup_temperature_sensitive_regs(struct emif_data *emif,\n\t\tstruct emif_regs *regs)\n{\n\tu32\t\ttim1, tim3, ref_ctrl, type;\n\tvoid __iomem\t*base = emif->base;\n\tu32\t\ttemperature;\n\n\ttype = emif->plat_data->device_info->type;\n\n\ttim1 = regs->sdram_tim1_shdw;\n\ttim3 = regs->sdram_tim3_shdw;\n\tref_ctrl = regs->ref_ctrl_shdw;\n\n\t \n\tif (type != DDR_TYPE_LPDDR2_S2 && type != DDR_TYPE_LPDDR2_S4)\n\t\tgoto out;\n\n\ttemperature = emif->temperature_level;\n\tif (temperature == SDRAM_TEMP_HIGH_DERATE_REFRESH) {\n\t\tref_ctrl = regs->ref_ctrl_shdw_derated;\n\t} else if (temperature == SDRAM_TEMP_HIGH_DERATE_REFRESH_AND_TIMINGS) {\n\t\ttim1 = regs->sdram_tim1_shdw_derated;\n\t\ttim3 = regs->sdram_tim3_shdw_derated;\n\t\tref_ctrl = regs->ref_ctrl_shdw_derated;\n\t}\n\nout:\n\twritel(tim1, base + EMIF_SDRAM_TIMING_1_SHDW);\n\twritel(tim3, base + EMIF_SDRAM_TIMING_3_SHDW);\n\twritel(ref_ctrl, base + EMIF_SDRAM_REFRESH_CTRL_SHDW);\n}\n\nstatic irqreturn_t handle_temp_alert(void __iomem *base, struct emif_data *emif)\n{\n\tu32\t\told_temp_level;\n\tirqreturn_t\tret = IRQ_HANDLED;\n\tstruct emif_custom_configs *custom_configs;\n\n\tspin_lock_irqsave(&emif_lock, irq_state);\n\told_temp_level = emif->temperature_level;\n\tget_temperature_level(emif);\n\n\tif (unlikely(emif->temperature_level == old_temp_level)) {\n\t\tgoto out;\n\t} else if (!emif->curr_regs) {\n\t\tdev_err(emif->dev, \"temperature alert before registers are calculated, not de-rating timings\\n\");\n\t\tgoto out;\n\t}\n\n\tcustom_configs = emif->plat_data->custom_configs;\n\n\t \n\tif (custom_configs && !(custom_configs->mask &\n\t\t\t\tEMIF_CUSTOM_CONFIG_EXTENDED_TEMP_PART)) {\n\t\tif (emif->temperature_level >= SDRAM_TEMP_HIGH_DERATE_REFRESH) {\n\t\t\tdev_err(emif->dev,\n\t\t\t\t\"%s:NOT Extended temperature capable memory. Converting MR4=0x%02x as shutdown event\\n\",\n\t\t\t\t__func__, emif->temperature_level);\n\t\t\t \n\t\t\temif->temperature_level = SDRAM_TEMP_VERY_HIGH_SHUTDOWN;\n\t\t\tret = IRQ_WAKE_THREAD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (emif->temperature_level < old_temp_level ||\n\t\temif->temperature_level == SDRAM_TEMP_VERY_HIGH_SHUTDOWN) {\n\t\t \n\t\tret = IRQ_WAKE_THREAD;\n\t} else {\n\t\t \n\t\tsetup_temperature_sensitive_regs(emif, emif->curr_regs);\n\t\tdo_freq_update();\n\t}\n\nout:\n\tspin_unlock_irqrestore(&emif_lock, irq_state);\n\treturn ret;\n}\n\nstatic irqreturn_t emif_interrupt_handler(int irq, void *dev_id)\n{\n\tu32\t\t\tinterrupts;\n\tstruct emif_data\t*emif = dev_id;\n\tvoid __iomem\t\t*base = emif->base;\n\tstruct device\t\t*dev = emif->dev;\n\tirqreturn_t\t\tret = IRQ_HANDLED;\n\n\t \n\tinterrupts = readl(base + EMIF_SYSTEM_OCP_INTERRUPT_STATUS);\n\twritel(interrupts, base + EMIF_SYSTEM_OCP_INTERRUPT_STATUS);\n\n\t \n\tif (interrupts & TA_SYS_MASK)\n\t\tret = handle_temp_alert(base, emif);\n\n\tif (interrupts & ERR_SYS_MASK)\n\t\tdev_err(dev, \"Access error from SYS port - %x\\n\", interrupts);\n\n\tif (emif->plat_data->hw_caps & EMIF_HW_CAPS_LL_INTERFACE) {\n\t\t \n\t\tinterrupts = readl(base + EMIF_LL_OCP_INTERRUPT_STATUS);\n\t\twritel(interrupts, base + EMIF_LL_OCP_INTERRUPT_STATUS);\n\n\t\tif (interrupts & ERR_LL_MASK)\n\t\t\tdev_err(dev, \"Access error from LL port - %x\\n\",\n\t\t\t\tinterrupts);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t emif_threaded_isr(int irq, void *dev_id)\n{\n\tstruct emif_data\t*emif = dev_id;\n\n\tif (emif->temperature_level == SDRAM_TEMP_VERY_HIGH_SHUTDOWN) {\n\t\tdev_emerg(emif->dev, \"SDRAM temperature exceeds operating limit.. Needs shut down!!!\\n\");\n\n\t\t \n\t\tif (kernel_can_power_off()) {\n\t\t\tkernel_power_off();\n\t\t} else {\n\t\t\tWARN(1, \"FIXME: NO pm_power_off!!! trying restart\\n\");\n\t\t\tkernel_restart(\"SDRAM Over-temp Emergency restart\");\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock_irqsave(&emif_lock, irq_state);\n\n\tif (emif->curr_regs) {\n\t\tsetup_temperature_sensitive_regs(emif, emif->curr_regs);\n\t\tdo_freq_update();\n\t} else {\n\t\tdev_err(emif->dev, \"temperature alert before registers are calculated, not de-rating timings\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&emif_lock, irq_state);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void clear_all_interrupts(struct emif_data *emif)\n{\n\tvoid __iomem\t*base = emif->base;\n\n\twritel(readl(base + EMIF_SYSTEM_OCP_INTERRUPT_STATUS),\n\t\tbase + EMIF_SYSTEM_OCP_INTERRUPT_STATUS);\n\tif (emif->plat_data->hw_caps & EMIF_HW_CAPS_LL_INTERFACE)\n\t\twritel(readl(base + EMIF_LL_OCP_INTERRUPT_STATUS),\n\t\t\tbase + EMIF_LL_OCP_INTERRUPT_STATUS);\n}\n\nstatic void disable_and_clear_all_interrupts(struct emif_data *emif)\n{\n\tvoid __iomem\t\t*base = emif->base;\n\n\t \n\twritel(readl(base + EMIF_SYSTEM_OCP_INTERRUPT_ENABLE_SET),\n\t\tbase + EMIF_SYSTEM_OCP_INTERRUPT_ENABLE_CLEAR);\n\tif (emif->plat_data->hw_caps & EMIF_HW_CAPS_LL_INTERFACE)\n\t\twritel(readl(base + EMIF_LL_OCP_INTERRUPT_ENABLE_SET),\n\t\t\tbase + EMIF_LL_OCP_INTERRUPT_ENABLE_CLEAR);\n\n\t \n\tclear_all_interrupts(emif);\n}\n\nstatic int __init_or_module setup_interrupts(struct emif_data *emif, u32 irq)\n{\n\tu32\t\tinterrupts, type;\n\tvoid __iomem\t*base = emif->base;\n\n\ttype = emif->plat_data->device_info->type;\n\n\tclear_all_interrupts(emif);\n\n\t \n\tinterrupts = EN_ERR_SYS_MASK;\n\tif (type == DDR_TYPE_LPDDR2_S2 || type == DDR_TYPE_LPDDR2_S4)\n\t\tinterrupts |= EN_TA_SYS_MASK;\n\twritel(interrupts, base + EMIF_SYSTEM_OCP_INTERRUPT_ENABLE_SET);\n\n\t \n\tif (emif->plat_data->hw_caps & EMIF_HW_CAPS_LL_INTERFACE) {\n\t\t \n\t\tinterrupts = EN_ERR_LL_MASK;\n\t\twritel(interrupts, base + EMIF_LL_OCP_INTERRUPT_ENABLE_SET);\n\t}\n\n\t \n\treturn devm_request_threaded_irq(emif->dev, irq,\n\t\t\t\t    emif_interrupt_handler,\n\t\t\t\t    emif_threaded_isr,\n\t\t\t\t    0, dev_name(emif->dev),\n\t\t\t\t    emif);\n\n}\n\nstatic void __init_or_module emif_onetime_settings(struct emif_data *emif)\n{\n\tu32\t\t\t\tpwr_mgmt_ctrl, zq, temp_alert_cfg;\n\tvoid __iomem\t\t\t*base = emif->base;\n\tconst struct lpddr2_addressing\t*addressing;\n\tconst struct ddr_device_info\t*device_info;\n\n\tdevice_info = emif->plat_data->device_info;\n\taddressing = get_addressing_table(device_info);\n\n\t \n\tpwr_mgmt_ctrl = get_pwr_mgmt_ctrl(1000000000, emif,\n\t\t\temif->plat_data->ip_rev);\n\temif->lpmode = (pwr_mgmt_ctrl & LP_MODE_MASK) >> LP_MODE_SHIFT;\n\twritel(pwr_mgmt_ctrl, base + EMIF_POWER_MANAGEMENT_CONTROL);\n\n\t \n\tzq = get_zq_config_reg(addressing, device_info->cs1_used,\n\t\tdevice_info->cal_resistors_per_cs);\n\twritel(zq, base + EMIF_SDRAM_OUTPUT_IMPEDANCE_CALIBRATION_CONFIG);\n\n\t \n\tget_temperature_level(emif);\n\tif (emif->temperature_level == SDRAM_TEMP_VERY_HIGH_SHUTDOWN)\n\t\tdev_emerg(emif->dev, \"SDRAM temperature exceeds operating limit.. Needs shut down!!!\\n\");\n\n\t \n\ttemp_alert_cfg = get_temp_alert_config(addressing,\n\t\temif->plat_data->custom_configs, device_info->cs1_used,\n\t\tdevice_info->io_width, get_emif_bus_width(emif));\n\twritel(temp_alert_cfg, base + EMIF_TEMPERATURE_ALERT_CONFIG);\n\n\t \n\tif (emif->plat_data->phy_type != EMIF_PHY_TYPE_INTELLIPHY)\n\t\treturn;\n\twritel(EMIF_EXT_PHY_CTRL_1_VAL, base + EMIF_EXT_PHY_CTRL_1_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_5_VAL, base + EMIF_EXT_PHY_CTRL_5_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_6_VAL, base + EMIF_EXT_PHY_CTRL_6_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_7_VAL, base + EMIF_EXT_PHY_CTRL_7_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_8_VAL, base + EMIF_EXT_PHY_CTRL_8_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_9_VAL, base + EMIF_EXT_PHY_CTRL_9_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_10_VAL, base + EMIF_EXT_PHY_CTRL_10_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_11_VAL, base + EMIF_EXT_PHY_CTRL_11_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_12_VAL, base + EMIF_EXT_PHY_CTRL_12_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_13_VAL, base + EMIF_EXT_PHY_CTRL_13_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_14_VAL, base + EMIF_EXT_PHY_CTRL_14_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_15_VAL, base + EMIF_EXT_PHY_CTRL_15_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_16_VAL, base + EMIF_EXT_PHY_CTRL_16_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_17_VAL, base + EMIF_EXT_PHY_CTRL_17_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_18_VAL, base + EMIF_EXT_PHY_CTRL_18_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_19_VAL, base + EMIF_EXT_PHY_CTRL_19_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_20_VAL, base + EMIF_EXT_PHY_CTRL_20_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_21_VAL, base + EMIF_EXT_PHY_CTRL_21_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_22_VAL, base + EMIF_EXT_PHY_CTRL_22_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_23_VAL, base + EMIF_EXT_PHY_CTRL_23_SHDW);\n\twritel(EMIF_EXT_PHY_CTRL_24_VAL, base + EMIF_EXT_PHY_CTRL_24_SHDW);\n}\n\nstatic void get_default_timings(struct emif_data *emif)\n{\n\tstruct emif_platform_data *pd = emif->plat_data;\n\n\tpd->timings\t\t= lpddr2_jedec_timings;\n\tpd->timings_arr_size\t= ARRAY_SIZE(lpddr2_jedec_timings);\n\n\tdev_warn(emif->dev, \"%s: using default timings\\n\", __func__);\n}\n\nstatic int is_dev_data_valid(u32 type, u32 density, u32 io_width, u32 phy_type,\n\t\tu32 ip_rev, struct device *dev)\n{\n\tint valid;\n\n\tvalid = (type == DDR_TYPE_LPDDR2_S4 ||\n\t\t\ttype == DDR_TYPE_LPDDR2_S2)\n\t\t&& (density >= DDR_DENSITY_64Mb\n\t\t\t&& density <= DDR_DENSITY_8Gb)\n\t\t&& (io_width >= DDR_IO_WIDTH_8\n\t\t\t&& io_width <= DDR_IO_WIDTH_32);\n\n\t \n\tswitch (ip_rev) {\n\tcase EMIF_4D:\n\t\tvalid = valid && (phy_type == EMIF_PHY_TYPE_ATTILAPHY);\n\t\tbreak;\n\tcase EMIF_4D5:\n\t\tvalid = valid && (phy_type == EMIF_PHY_TYPE_INTELLIPHY);\n\t\tbreak;\n\tdefault:\n\t\tvalid = 0;\n\t}\n\n\tif (!valid)\n\t\tdev_err(dev, \"%s: invalid DDR details\\n\", __func__);\n\treturn valid;\n}\n\nstatic int is_custom_config_valid(struct emif_custom_configs *cust_cfgs,\n\t\tstruct device *dev)\n{\n\tint valid = 1;\n\n\tif ((cust_cfgs->mask & EMIF_CUSTOM_CONFIG_LPMODE) &&\n\t\t(cust_cfgs->lpmode != EMIF_LP_MODE_DISABLE))\n\t\tvalid = cust_cfgs->lpmode_freq_threshold &&\n\t\t\tcust_cfgs->lpmode_timeout_performance &&\n\t\t\tcust_cfgs->lpmode_timeout_power;\n\n\tif (cust_cfgs->mask & EMIF_CUSTOM_CONFIG_TEMP_ALERT_POLL_INTERVAL)\n\t\tvalid = valid && cust_cfgs->temp_alert_poll_interval_ms;\n\n\tif (!valid)\n\t\tdev_warn(dev, \"%s: invalid custom configs\\n\", __func__);\n\n\treturn valid;\n}\n\n#if defined(CONFIG_OF)\nstatic void __init_or_module of_get_custom_configs(struct device_node *np_emif,\n\t\tstruct emif_data *emif)\n{\n\tstruct emif_custom_configs\t*cust_cfgs = NULL;\n\tint\t\t\t\tlen;\n\tconst __be32\t\t\t*lpmode, *poll_intvl;\n\n\tlpmode = of_get_property(np_emif, \"low-power-mode\", &len);\n\tpoll_intvl = of_get_property(np_emif, \"temp-alert-poll-interval\", &len);\n\n\tif (lpmode || poll_intvl)\n\t\tcust_cfgs = devm_kzalloc(emif->dev, sizeof(*cust_cfgs),\n\t\t\tGFP_KERNEL);\n\n\tif (!cust_cfgs)\n\t\treturn;\n\n\tif (lpmode) {\n\t\tcust_cfgs->mask |= EMIF_CUSTOM_CONFIG_LPMODE;\n\t\tcust_cfgs->lpmode = be32_to_cpup(lpmode);\n\t\tof_property_read_u32(np_emif,\n\t\t\t\t\"low-power-mode-timeout-performance\",\n\t\t\t\t&cust_cfgs->lpmode_timeout_performance);\n\t\tof_property_read_u32(np_emif,\n\t\t\t\t\"low-power-mode-timeout-power\",\n\t\t\t\t&cust_cfgs->lpmode_timeout_power);\n\t\tof_property_read_u32(np_emif,\n\t\t\t\t\"low-power-mode-freq-threshold\",\n\t\t\t\t&cust_cfgs->lpmode_freq_threshold);\n\t}\n\n\tif (poll_intvl) {\n\t\tcust_cfgs->mask |=\n\t\t\t\tEMIF_CUSTOM_CONFIG_TEMP_ALERT_POLL_INTERVAL;\n\t\tcust_cfgs->temp_alert_poll_interval_ms =\n\t\t\t\t\t\tbe32_to_cpup(poll_intvl);\n\t}\n\n\tif (of_find_property(np_emif, \"extended-temp-part\", &len))\n\t\tcust_cfgs->mask |= EMIF_CUSTOM_CONFIG_EXTENDED_TEMP_PART;\n\n\tif (!is_custom_config_valid(cust_cfgs, emif->dev)) {\n\t\tdevm_kfree(emif->dev, cust_cfgs);\n\t\treturn;\n\t}\n\n\temif->plat_data->custom_configs = cust_cfgs;\n}\n\nstatic void __init_or_module of_get_ddr_info(struct device_node *np_emif,\n\t\tstruct device_node *np_ddr,\n\t\tstruct ddr_device_info *dev_info)\n{\n\tu32 density = 0, io_width = 0;\n\tint len;\n\n\tif (of_find_property(np_emif, \"cs1-used\", &len))\n\t\tdev_info->cs1_used = true;\n\n\tif (of_find_property(np_emif, \"cal-resistor-per-cs\", &len))\n\t\tdev_info->cal_resistors_per_cs = true;\n\n\tif (of_device_is_compatible(np_ddr, \"jedec,lpddr2-s4\"))\n\t\tdev_info->type = DDR_TYPE_LPDDR2_S4;\n\telse if (of_device_is_compatible(np_ddr, \"jedec,lpddr2-s2\"))\n\t\tdev_info->type = DDR_TYPE_LPDDR2_S2;\n\n\tof_property_read_u32(np_ddr, \"density\", &density);\n\tof_property_read_u32(np_ddr, \"io-width\", &io_width);\n\n\t \n\tif (density & (density - 1))\n\t\tdev_info->density = 0;\n\telse\n\t\tdev_info->density = __fls(density) - 5;\n\n\t \n\tif (io_width & (io_width - 1))\n\t\tdev_info->io_width = 0;\n\telse\n\t\tdev_info->io_width = __fls(io_width) - 1;\n}\n\nstatic struct emif_data * __init_or_module of_get_memory_device_details(\n\t\tstruct device_node *np_emif, struct device *dev)\n{\n\tstruct emif_data\t\t*emif = NULL;\n\tstruct ddr_device_info\t\t*dev_info = NULL;\n\tstruct emif_platform_data\t*pd = NULL;\n\tstruct device_node\t\t*np_ddr;\n\tint\t\t\t\tlen;\n\n\tnp_ddr = of_parse_phandle(np_emif, \"device-handle\", 0);\n\tif (!np_ddr)\n\t\tgoto error;\n\temif\t= devm_kzalloc(dev, sizeof(struct emif_data), GFP_KERNEL);\n\tpd\t= devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\tdev_info = devm_kzalloc(dev, sizeof(*dev_info), GFP_KERNEL);\n\n\tif (!emif || !pd || !dev_info) {\n\t\tdev_err(dev, \"%s: Out of memory!!\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\temif->plat_data\t\t= pd;\n\tpd->device_info\t\t= dev_info;\n\temif->dev\t\t= dev;\n\temif->np_ddr\t\t= np_ddr;\n\temif->temperature_level\t= SDRAM_TEMP_NOMINAL;\n\n\tif (of_device_is_compatible(np_emif, \"ti,emif-4d\"))\n\t\temif->plat_data->ip_rev = EMIF_4D;\n\telse if (of_device_is_compatible(np_emif, \"ti,emif-4d5\"))\n\t\temif->plat_data->ip_rev = EMIF_4D5;\n\n\tof_property_read_u32(np_emif, \"phy-type\", &pd->phy_type);\n\n\tif (of_find_property(np_emif, \"hw-caps-ll-interface\", &len))\n\t\tpd->hw_caps |= EMIF_HW_CAPS_LL_INTERFACE;\n\n\tof_get_ddr_info(np_emif, np_ddr, dev_info);\n\tif (!is_dev_data_valid(pd->device_info->type, pd->device_info->density,\n\t\t\tpd->device_info->io_width, pd->phy_type, pd->ip_rev,\n\t\t\temif->dev)) {\n\t\tdev_err(dev, \"%s: invalid device data!!\\n\", __func__);\n\t\tgoto error;\n\t}\n\t \n\tif (emif1 && emif1->np_ddr == np_ddr) {\n\t\temif->duplicate = true;\n\t\tgoto out;\n\t} else if (emif1) {\n\t\tdev_warn(emif->dev, \"%s: Non-symmetric DDR geometry\\n\",\n\t\t\t__func__);\n\t}\n\n\tof_get_custom_configs(np_emif, emif);\n\temif->plat_data->timings = of_get_ddr_timings(np_ddr, emif->dev,\n\t\t\t\t\temif->plat_data->device_info->type,\n\t\t\t\t\t&emif->plat_data->timings_arr_size);\n\n\temif->plat_data->min_tck = of_get_min_tck(np_ddr, emif->dev);\n\tgoto out;\n\nerror:\n\treturn NULL;\nout:\n\treturn emif;\n}\n\n#else\n\nstatic struct emif_data * __init_or_module of_get_memory_device_details(\n\t\tstruct device_node *np_emif, struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic struct emif_data *__init_or_module get_device_details(\n\t\tstruct platform_device *pdev)\n{\n\tu32\t\t\t\tsize;\n\tstruct emif_data\t\t*emif = NULL;\n\tstruct ddr_device_info\t\t*dev_info;\n\tstruct emif_custom_configs\t*cust_cfgs;\n\tstruct emif_platform_data\t*pd;\n\tstruct device\t\t\t*dev;\n\tvoid\t\t\t\t*temp;\n\n\tpd = pdev->dev.platform_data;\n\tdev = &pdev->dev;\n\n\tif (!(pd && pd->device_info && is_dev_data_valid(pd->device_info->type,\n\t\t\tpd->device_info->density, pd->device_info->io_width,\n\t\t\tpd->phy_type, pd->ip_rev, dev))) {\n\t\tdev_err(dev, \"%s: invalid device data\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\temif\t= devm_kzalloc(dev, sizeof(*emif), GFP_KERNEL);\n\ttemp\t= devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\tdev_info = devm_kzalloc(dev, sizeof(*dev_info), GFP_KERNEL);\n\n\tif (!emif || !temp || !dev_info)\n\t\tgoto error;\n\n\tmemcpy(temp, pd, sizeof(*pd));\n\tpd = temp;\n\tmemcpy(dev_info, pd->device_info, sizeof(*dev_info));\n\n\tpd->device_info\t\t= dev_info;\n\temif->plat_data\t\t= pd;\n\temif->dev\t\t= dev;\n\temif->temperature_level\t= SDRAM_TEMP_NOMINAL;\n\n\t \n\temif->duplicate = emif1 && (memcmp(dev_info,\n\t\temif1->plat_data->device_info,\n\t\tsizeof(struct ddr_device_info)) == 0);\n\n\tif (emif->duplicate) {\n\t\tpd->timings = NULL;\n\t\tpd->min_tck = NULL;\n\t\tgoto out;\n\t} else if (emif1) {\n\t\tdev_warn(emif->dev, \"%s: Non-symmetric DDR geometry\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tcust_cfgs = pd->custom_configs;\n\tif (cust_cfgs && is_custom_config_valid(cust_cfgs, dev)) {\n\t\ttemp = devm_kzalloc(dev, sizeof(*cust_cfgs), GFP_KERNEL);\n\t\tif (temp)\n\t\t\tmemcpy(temp, cust_cfgs, sizeof(*cust_cfgs));\n\t\tpd->custom_configs = temp;\n\t}\n\n\t \n\tsize = sizeof(struct lpddr2_timings) * pd->timings_arr_size;\n\tif (pd->timings) {\n\t\ttemp = devm_kzalloc(dev, size, GFP_KERNEL);\n\t\tif (temp) {\n\t\t\tmemcpy(temp, pd->timings, size);\n\t\t\tpd->timings = temp;\n\t\t} else {\n\t\t\tget_default_timings(emif);\n\t\t}\n\t} else {\n\t\tget_default_timings(emif);\n\t}\n\n\tif (pd->min_tck) {\n\t\ttemp = devm_kzalloc(dev, sizeof(*pd->min_tck), GFP_KERNEL);\n\t\tif (temp) {\n\t\t\tmemcpy(temp, pd->min_tck, sizeof(*pd->min_tck));\n\t\t\tpd->min_tck = temp;\n\t\t} else {\n\t\t\tpd->min_tck = &lpddr2_jedec_min_tck;\n\t\t}\n\t} else {\n\t\tpd->min_tck = &lpddr2_jedec_min_tck;\n\t}\n\nout:\n\treturn emif;\n\nerror:\n\treturn NULL;\n}\n\nstatic int __init_or_module emif_probe(struct platform_device *pdev)\n{\n\tstruct emif_data\t*emif;\n\tint\t\t\tirq, ret;\n\n\tif (pdev->dev.of_node)\n\t\temif = of_get_memory_device_details(pdev->dev.of_node, &pdev->dev);\n\telse\n\t\temif = get_device_details(pdev);\n\n\tif (!emif) {\n\t\tpr_err(\"%s: error getting device data\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tlist_add(&emif->node, &device_list);\n\n\t \n\temif->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, emif);\n\n\temif->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(emif->base))\n\t\tgoto error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\tgoto error;\n\n\temif_onetime_settings(emif);\n\temif_debugfs_init(emif);\n\tdisable_and_clear_all_interrupts(emif);\n\tret = setup_interrupts(emif, irq);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (!emif1) {\n\t\temif1 = emif;\n\n\t\t \n\t}\n\n\tdev_info(&pdev->dev, \"%s: device configured with addr = %p and IRQ%d\\n\",\n\t\t__func__, emif->base, irq);\n\n\treturn 0;\nerror:\n\treturn -ENODEV;\n}\n\nstatic int __exit emif_remove(struct platform_device *pdev)\n{\n\tstruct emif_data *emif = platform_get_drvdata(pdev);\n\n\temif_debugfs_exit(emif);\n\n\treturn 0;\n}\n\nstatic void emif_shutdown(struct platform_device *pdev)\n{\n\tstruct emif_data\t*emif = platform_get_drvdata(pdev);\n\n\tdisable_and_clear_all_interrupts(emif);\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id emif_of_match[] = {\n\t\t{ .compatible = \"ti,emif-4d\" },\n\t\t{ .compatible = \"ti,emif-4d5\" },\n\t\t{},\n};\nMODULE_DEVICE_TABLE(of, emif_of_match);\n#endif\n\nstatic struct platform_driver emif_driver = {\n\t.remove\t\t= __exit_p(emif_remove),\n\t.shutdown\t= emif_shutdown,\n\t.driver = {\n\t\t.name = \"emif\",\n\t\t.of_match_table = of_match_ptr(emif_of_match),\n\t},\n};\n\nmodule_platform_driver_probe(emif_driver, emif_probe);\n\nMODULE_DESCRIPTION(\"TI EMIF SDRAM Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:emif\");\nMODULE_AUTHOR(\"Texas Instruments Inc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}