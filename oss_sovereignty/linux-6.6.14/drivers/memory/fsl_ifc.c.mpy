{
  "module_name": "fsl_ifc.c",
  "hash_id": "b3c17223f82ffec7d57b5c2932ceabd61b6bc24746f58fe899936eb88e143cb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/fsl_ifc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/fsl_ifc.h>\n#include <linux/irqdomain.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\nstruct fsl_ifc_ctrl *fsl_ifc_ctrl_dev;\nEXPORT_SYMBOL(fsl_ifc_ctrl_dev);\n\n \nunsigned int convert_ifc_address(phys_addr_t addr_base)\n{\n\treturn addr_base & CSPR_BA;\n}\nEXPORT_SYMBOL(convert_ifc_address);\n\n \nint fsl_ifc_find(phys_addr_t addr_base)\n{\n\tint i = 0;\n\n\tif (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->gregs)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < fsl_ifc_ctrl_dev->banks; i++) {\n\t\tu32 cspr = ifc_in32(&fsl_ifc_ctrl_dev->gregs->cspr_cs[i].cspr);\n\n\t\tif (cspr & CSPR_V && (cspr & CSPR_BA) ==\n\t\t\t\tconvert_ifc_address(addr_base))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(fsl_ifc_find);\n\nstatic int fsl_ifc_ctrl_init(struct fsl_ifc_ctrl *ctrl)\n{\n\tstruct fsl_ifc_global __iomem *ifc = ctrl->gregs;\n\n\t \n\tif (ifc_in32(&ifc->cm_evter_stat) & IFC_CM_EVTER_STAT_CSER)\n\t\tifc_out32(IFC_CM_EVTER_STAT_CSER, &ifc->cm_evter_stat);\n\n\t \n\tifc_out32(IFC_CM_EVTER_EN_CSEREN, &ifc->cm_evter_en);\n\n\t \n\tifc_out32(IFC_CM_EVTER_INTR_EN_CSERIREN, &ifc->cm_evter_intr_en);\n\tifc_out32(0x0, &ifc->cm_erattr0);\n\tifc_out32(0x0, &ifc->cm_erattr1);\n\n\treturn 0;\n}\n\nstatic int fsl_ifc_ctrl_remove(struct platform_device *dev)\n{\n\tstruct fsl_ifc_ctrl *ctrl = dev_get_drvdata(&dev->dev);\n\n\tof_platform_depopulate(&dev->dev);\n\tfree_irq(ctrl->nand_irq, ctrl);\n\tfree_irq(ctrl->irq, ctrl);\n\n\tirq_dispose_mapping(ctrl->nand_irq);\n\tirq_dispose_mapping(ctrl->irq);\n\n\tiounmap(ctrl->gregs);\n\n\tdev_set_drvdata(&dev->dev, NULL);\n\n\treturn 0;\n}\n\n \nstatic DEFINE_SPINLOCK(nand_irq_lock);\n\nstatic u32 check_nand_stat(struct fsl_ifc_ctrl *ctrl)\n{\n\tstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\n\tunsigned long flags;\n\tu32 stat;\n\n\tspin_lock_irqsave(&nand_irq_lock, flags);\n\n\tstat = ifc_in32(&ifc->ifc_nand.nand_evter_stat);\n\tif (stat) {\n\t\tifc_out32(stat, &ifc->ifc_nand.nand_evter_stat);\n\t\tctrl->nand_stat = stat;\n\t\twake_up(&ctrl->nand_wait);\n\t}\n\n\tspin_unlock_irqrestore(&nand_irq_lock, flags);\n\n\treturn stat;\n}\n\nstatic irqreturn_t fsl_ifc_nand_irq(int irqno, void *data)\n{\n\tstruct fsl_ifc_ctrl *ctrl = data;\n\n\tif (check_nand_stat(ctrl))\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\n\n \nstatic irqreturn_t fsl_ifc_ctrl_irq(int irqno, void *data)\n{\n\tstruct fsl_ifc_ctrl *ctrl = data;\n\tstruct fsl_ifc_global __iomem *ifc = ctrl->gregs;\n\tu32 err_axiid, err_srcid, status, cs_err, err_addr;\n\tirqreturn_t ret = IRQ_NONE;\n\n\t \n\tcs_err = ifc_in32(&ifc->cm_evter_stat);\n\tif (cs_err) {\n\t\tdev_err(ctrl->dev, \"transaction sent to IFC is not mapped to any memory bank 0x%08X\\n\",\n\t\t\tcs_err);\n\t\t \n\t\tifc_out32(IFC_CM_EVTER_STAT_CSER, &ifc->cm_evter_stat);\n\n\t\t \n\t\tstatus = ifc_in32(&ifc->cm_erattr0);\n\t\terr_addr = ifc_in32(&ifc->cm_erattr1);\n\n\t\tif (status & IFC_CM_ERATTR0_ERTYP_READ)\n\t\t\tdev_err(ctrl->dev, \"Read transaction error CM_ERATTR0 0x%08X\\n\",\n\t\t\t\tstatus);\n\t\telse\n\t\t\tdev_err(ctrl->dev, \"Write transaction error CM_ERATTR0 0x%08X\\n\",\n\t\t\t\tstatus);\n\n\t\terr_axiid = (status & IFC_CM_ERATTR0_ERAID) >>\n\t\t\t\t\tIFC_CM_ERATTR0_ERAID_SHIFT;\n\t\tdev_err(ctrl->dev, \"AXI ID of the error transaction 0x%08X\\n\",\n\t\t\terr_axiid);\n\n\t\terr_srcid = (status & IFC_CM_ERATTR0_ESRCID) >>\n\t\t\t\t\tIFC_CM_ERATTR0_ESRCID_SHIFT;\n\t\tdev_err(ctrl->dev, \"SRC ID of the error transaction 0x%08X\\n\",\n\t\t\terr_srcid);\n\n\t\tdev_err(ctrl->dev, \"Transaction Address corresponding to error ERADDR 0x%08X\\n\",\n\t\t\terr_addr);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (check_nand_stat(ctrl))\n\t\tret = IRQ_HANDLED;\n\n\treturn ret;\n}\n\n \nstatic int fsl_ifc_ctrl_probe(struct platform_device *dev)\n{\n\tint ret = 0;\n\tint version, banks;\n\tvoid __iomem *addr;\n\n\tdev_info(&dev->dev, \"Freescale Integrated Flash Controller\\n\");\n\n\tfsl_ifc_ctrl_dev = devm_kzalloc(&dev->dev, sizeof(*fsl_ifc_ctrl_dev),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!fsl_ifc_ctrl_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&dev->dev, fsl_ifc_ctrl_dev);\n\n\t \n\tfsl_ifc_ctrl_dev->gregs = of_iomap(dev->dev.of_node, 0);\n\tif (!fsl_ifc_ctrl_dev->gregs) {\n\t\tdev_err(&dev->dev, \"failed to get memory region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_property_read_bool(dev->dev.of_node, \"little-endian\")) {\n\t\tfsl_ifc_ctrl_dev->little_endian = true;\n\t\tdev_dbg(&dev->dev, \"IFC REGISTERS are LITTLE endian\\n\");\n\t} else {\n\t\tfsl_ifc_ctrl_dev->little_endian = false;\n\t\tdev_dbg(&dev->dev, \"IFC REGISTERS are BIG endian\\n\");\n\t}\n\n\tversion = ifc_in32(&fsl_ifc_ctrl_dev->gregs->ifc_rev) &\n\t\t\tFSL_IFC_VERSION_MASK;\n\n\tbanks = (version == FSL_IFC_VERSION_1_0_0) ? 4 : 8;\n\tdev_info(&dev->dev, \"IFC version %d.%d, %d banks\\n\",\n\t\tversion >> 24, (version >> 16) & 0xf, banks);\n\n\tfsl_ifc_ctrl_dev->version = version;\n\tfsl_ifc_ctrl_dev->banks = banks;\n\n\taddr = fsl_ifc_ctrl_dev->gregs;\n\tif (version >= FSL_IFC_VERSION_2_0_0)\n\t\taddr += PGOFFSET_64K;\n\telse\n\t\taddr += PGOFFSET_4K;\n\tfsl_ifc_ctrl_dev->rregs = addr;\n\n\t \n\tfsl_ifc_ctrl_dev->irq = irq_of_parse_and_map(dev->dev.of_node, 0);\n\tif (fsl_ifc_ctrl_dev->irq == 0) {\n\t\tdev_err(&dev->dev, \"failed to get irq resource for IFC\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tfsl_ifc_ctrl_dev->nand_irq =\n\t\t\tirq_of_parse_and_map(dev->dev.of_node, 1);\n\n\tfsl_ifc_ctrl_dev->dev = &dev->dev;\n\n\tret = fsl_ifc_ctrl_init(fsl_ifc_ctrl_dev);\n\tif (ret < 0)\n\t\tgoto err_unmap_nandirq;\n\n\tinit_waitqueue_head(&fsl_ifc_ctrl_dev->nand_wait);\n\n\tret = request_irq(fsl_ifc_ctrl_dev->irq, fsl_ifc_ctrl_irq, IRQF_SHARED,\n\t\t\t  \"fsl-ifc\", fsl_ifc_ctrl_dev);\n\tif (ret != 0) {\n\t\tdev_err(&dev->dev, \"failed to install irq (%d)\\n\",\n\t\t\tfsl_ifc_ctrl_dev->irq);\n\t\tgoto err_unmap_nandirq;\n\t}\n\n\tif (fsl_ifc_ctrl_dev->nand_irq) {\n\t\tret = request_irq(fsl_ifc_ctrl_dev->nand_irq, fsl_ifc_nand_irq,\n\t\t\t\t0, \"fsl-ifc-nand\", fsl_ifc_ctrl_dev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&dev->dev, \"failed to install irq (%d)\\n\",\n\t\t\t\tfsl_ifc_ctrl_dev->nand_irq);\n\t\t\tgoto err_free_irq;\n\t\t}\n\t}\n\n\t \n\tret = of_platform_default_populate(dev->dev.of_node, NULL, &dev->dev);\n\tif (ret)\n\t\tgoto err_free_nandirq;\n\n\treturn 0;\n\nerr_free_nandirq:\n\tfree_irq(fsl_ifc_ctrl_dev->nand_irq, fsl_ifc_ctrl_dev);\nerr_free_irq:\n\tfree_irq(fsl_ifc_ctrl_dev->irq, fsl_ifc_ctrl_dev);\nerr_unmap_nandirq:\n\tirq_dispose_mapping(fsl_ifc_ctrl_dev->nand_irq);\n\tirq_dispose_mapping(fsl_ifc_ctrl_dev->irq);\nerr:\n\tiounmap(fsl_ifc_ctrl_dev->gregs);\n\treturn ret;\n}\n\nstatic const struct of_device_id fsl_ifc_match[] = {\n\t{\n\t\t.compatible = \"fsl,ifc\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver fsl_ifc_ctrl_driver = {\n\t.driver = {\n\t\t.name\t= \"fsl-ifc\",\n\t\t.of_match_table = fsl_ifc_match,\n\t},\n\t.probe       = fsl_ifc_ctrl_probe,\n\t.remove      = fsl_ifc_ctrl_remove,\n};\n\nstatic int __init fsl_ifc_init(void)\n{\n\treturn platform_driver_register(&fsl_ifc_ctrl_driver);\n}\nsubsys_initcall(fsl_ifc_init);\n\nMODULE_AUTHOR(\"Freescale Semiconductor\");\nMODULE_DESCRIPTION(\"Freescale Integrated Flash Controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}