{
  "module_name": "ti-aemif.c",
  "hash_id": "7e55143ebe25baf978a67e9c298b15963e27ed5b57f0c8e82630901e281c65fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/ti-aemif.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/ti-aemif.h>\n\n#define TA_SHIFT\t2\n#define RHOLD_SHIFT\t4\n#define RSTROBE_SHIFT\t7\n#define RSETUP_SHIFT\t13\n#define WHOLD_SHIFT\t17\n#define WSTROBE_SHIFT\t20\n#define WSETUP_SHIFT\t26\n#define EW_SHIFT\t30\n#define SSTROBE_SHIFT\t31\n\n#define TA(x)\t\t((x) << TA_SHIFT)\n#define RHOLD(x)\t((x) << RHOLD_SHIFT)\n#define RSTROBE(x)\t((x) << RSTROBE_SHIFT)\n#define RSETUP(x)\t((x) << RSETUP_SHIFT)\n#define WHOLD(x)\t((x) << WHOLD_SHIFT)\n#define WSTROBE(x)\t((x) << WSTROBE_SHIFT)\n#define WSETUP(x)\t((x) << WSETUP_SHIFT)\n#define EW(x)\t\t((x) << EW_SHIFT)\n#define SSTROBE(x)\t((x) << SSTROBE_SHIFT)\n\n#define ASIZE_MAX\t0x1\n#define TA_MAX\t\t0x3\n#define RHOLD_MAX\t0x7\n#define RSTROBE_MAX\t0x3f\n#define RSETUP_MAX\t0xf\n#define WHOLD_MAX\t0x7\n#define WSTROBE_MAX\t0x3f\n#define WSETUP_MAX\t0xf\n#define EW_MAX\t\t0x1\n#define SSTROBE_MAX\t0x1\n#define NUM_CS\t\t4\n\n#define TA_VAL(x)\t(((x) & TA(TA_MAX)) >> TA_SHIFT)\n#define RHOLD_VAL(x)\t(((x) & RHOLD(RHOLD_MAX)) >> RHOLD_SHIFT)\n#define RSTROBE_VAL(x)\t(((x) & RSTROBE(RSTROBE_MAX)) >> RSTROBE_SHIFT)\n#define RSETUP_VAL(x)\t(((x) & RSETUP(RSETUP_MAX)) >> RSETUP_SHIFT)\n#define WHOLD_VAL(x)\t(((x) & WHOLD(WHOLD_MAX)) >> WHOLD_SHIFT)\n#define WSTROBE_VAL(x)\t(((x) & WSTROBE(WSTROBE_MAX)) >> WSTROBE_SHIFT)\n#define WSETUP_VAL(x)\t(((x) & WSETUP(WSETUP_MAX)) >> WSETUP_SHIFT)\n#define EW_VAL(x)\t(((x) & EW(EW_MAX)) >> EW_SHIFT)\n#define SSTROBE_VAL(x)\t(((x) & SSTROBE(SSTROBE_MAX)) >> SSTROBE_SHIFT)\n\n#define NRCSR_OFFSET\t0x00\n#define AWCCR_OFFSET\t0x04\n#define A1CR_OFFSET\t0x10\n\n#define ACR_ASIZE_MASK\t0x3\n#define ACR_EW_MASK\tBIT(30)\n#define ACR_SSTROBE_MASK\tBIT(31)\n#define ASIZE_16BIT\t1\n\n#define CONFIG_MASK\t(TA(TA_MAX) | \\\n\t\t\t\tRHOLD(RHOLD_MAX) | \\\n\t\t\t\tRSTROBE(RSTROBE_MAX) |\t\\\n\t\t\t\tRSETUP(RSETUP_MAX) | \\\n\t\t\t\tWHOLD(WHOLD_MAX) | \\\n\t\t\t\tWSTROBE(WSTROBE_MAX) | \\\n\t\t\t\tWSETUP(WSETUP_MAX) | \\\n\t\t\t\tEW(EW_MAX) | SSTROBE(SSTROBE_MAX) | \\\n\t\t\t\tASIZE_MAX)\n\n \nstruct aemif_cs_data {\n\tu8\tcs;\n\tu16\twstrobe;\n\tu16\trstrobe;\n\tu8\twsetup;\n\tu8\twhold;\n\tu8\trsetup;\n\tu8\trhold;\n\tu8\tta;\n\tu8\tenable_ss;\n\tu8\tenable_ew;\n\tu8\tasize;\n};\n\n \nstruct aemif_device {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tunsigned long clk_rate;\n\tu8 num_cs;\n\tint cs_offset;\n\tstruct aemif_cs_data cs_data[NUM_CS];\n};\n\n \nstatic int aemif_calc_rate(struct platform_device *pdev, int wanted,\n\t\t\t   unsigned long clk, int max)\n{\n\tint result;\n\n\tresult = DIV_ROUND_UP((wanted * clk), NSEC_PER_MSEC) - 1;\n\n\tdev_dbg(&pdev->dev, \"%s: result %d from %ld, %d\\n\", __func__, result,\n\t\tclk, wanted);\n\n\t \n\tif (result < 0)\n\t\tresult = 0;\n\n\t \n\telse if (result > max)\n\t\tresult = -EINVAL;\n\n\treturn result;\n}\n\n \nstatic int aemif_config_abus(struct platform_device *pdev, int csnum)\n{\n\tstruct aemif_device *aemif = platform_get_drvdata(pdev);\n\tstruct aemif_cs_data *data = &aemif->cs_data[csnum];\n\tint ta, rhold, rstrobe, rsetup, whold, wstrobe, wsetup;\n\tunsigned long clk_rate = aemif->clk_rate;\n\tunsigned offset;\n\tu32 set, val;\n\n\toffset = A1CR_OFFSET + (data->cs - aemif->cs_offset) * 4;\n\n\tta\t= aemif_calc_rate(pdev, data->ta, clk_rate, TA_MAX);\n\trhold\t= aemif_calc_rate(pdev, data->rhold, clk_rate, RHOLD_MAX);\n\trstrobe\t= aemif_calc_rate(pdev, data->rstrobe, clk_rate, RSTROBE_MAX);\n\trsetup\t= aemif_calc_rate(pdev, data->rsetup, clk_rate, RSETUP_MAX);\n\twhold\t= aemif_calc_rate(pdev, data->whold, clk_rate, WHOLD_MAX);\n\twstrobe\t= aemif_calc_rate(pdev, data->wstrobe, clk_rate, WSTROBE_MAX);\n\twsetup\t= aemif_calc_rate(pdev, data->wsetup, clk_rate, WSETUP_MAX);\n\n\tif (ta < 0 || rhold < 0 || rstrobe < 0 || rsetup < 0 ||\n\t    whold < 0 || wstrobe < 0 || wsetup < 0) {\n\t\tdev_err(&pdev->dev, \"%s: cannot get suitable timings\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tset = TA(ta) | RHOLD(rhold) | RSTROBE(rstrobe) | RSETUP(rsetup) |\n\t\tWHOLD(whold) | WSTROBE(wstrobe) | WSETUP(wsetup);\n\n\tset |= (data->asize & ACR_ASIZE_MASK);\n\tif (data->enable_ew)\n\t\tset |= ACR_EW_MASK;\n\tif (data->enable_ss)\n\t\tset |= ACR_SSTROBE_MASK;\n\n\tval = readl(aemif->base + offset);\n\tval &= ~CONFIG_MASK;\n\tval |= set;\n\twritel(val, aemif->base + offset);\n\n\treturn 0;\n}\n\nstatic inline int aemif_cycles_to_nsec(int val, unsigned long clk_rate)\n{\n\treturn ((val + 1) * NSEC_PER_MSEC) / clk_rate;\n}\n\n \nstatic void aemif_get_hw_params(struct platform_device *pdev, int csnum)\n{\n\tstruct aemif_device *aemif = platform_get_drvdata(pdev);\n\tstruct aemif_cs_data *data = &aemif->cs_data[csnum];\n\tunsigned long clk_rate = aemif->clk_rate;\n\tu32 val, offset;\n\n\toffset = A1CR_OFFSET + (data->cs - aemif->cs_offset) * 4;\n\tval = readl(aemif->base + offset);\n\n\tdata->ta = aemif_cycles_to_nsec(TA_VAL(val), clk_rate);\n\tdata->rhold = aemif_cycles_to_nsec(RHOLD_VAL(val), clk_rate);\n\tdata->rstrobe = aemif_cycles_to_nsec(RSTROBE_VAL(val), clk_rate);\n\tdata->rsetup = aemif_cycles_to_nsec(RSETUP_VAL(val), clk_rate);\n\tdata->whold = aemif_cycles_to_nsec(WHOLD_VAL(val), clk_rate);\n\tdata->wstrobe = aemif_cycles_to_nsec(WSTROBE_VAL(val), clk_rate);\n\tdata->wsetup = aemif_cycles_to_nsec(WSETUP_VAL(val), clk_rate);\n\tdata->enable_ew = EW_VAL(val);\n\tdata->enable_ss = SSTROBE_VAL(val);\n\tdata->asize = val & ASIZE_MAX;\n}\n\n \nstatic int of_aemif_parse_abus_config(struct platform_device *pdev,\n\t\t\t\t      struct device_node *np)\n{\n\tstruct aemif_device *aemif = platform_get_drvdata(pdev);\n\tstruct aemif_cs_data *data;\n\tu32 cs;\n\tu32 val;\n\n\tif (of_property_read_u32(np, \"ti,cs-chipselect\", &cs)) {\n\t\tdev_dbg(&pdev->dev, \"cs property is required\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cs - aemif->cs_offset >= NUM_CS || cs < aemif->cs_offset) {\n\t\tdev_dbg(&pdev->dev, \"cs number is incorrect %d\", cs);\n\t\treturn -EINVAL;\n\t}\n\n\tif (aemif->num_cs >= NUM_CS) {\n\t\tdev_dbg(&pdev->dev, \"cs count is more than %d\", NUM_CS);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = &aemif->cs_data[aemif->num_cs];\n\tdata->cs = cs;\n\n\t \n\taemif_get_hw_params(pdev, aemif->num_cs++);\n\n\t \n\tif (!of_property_read_u32(np, \"ti,cs-min-turnaround-ns\", &val))\n\t\tdata->ta = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-read-hold-ns\", &val))\n\t\tdata->rhold = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-read-strobe-ns\", &val))\n\t\tdata->rstrobe = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-read-setup-ns\", &val))\n\t\tdata->rsetup = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-write-hold-ns\", &val))\n\t\tdata->whold = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-write-strobe-ns\", &val))\n\t\tdata->wstrobe = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-write-setup-ns\", &val))\n\t\tdata->wsetup = val;\n\n\tif (!of_property_read_u32(np, \"ti,cs-bus-width\", &val))\n\t\tif (val == 16)\n\t\t\tdata->asize = 1;\n\tdata->enable_ew = of_property_read_bool(np, \"ti,cs-extended-wait-mode\");\n\tdata->enable_ss = of_property_read_bool(np, \"ti,cs-select-strobe-mode\");\n\treturn 0;\n}\n\nstatic const struct of_device_id aemif_of_match[] = {\n\t{ .compatible = \"ti,davinci-aemif\", },\n\t{ .compatible = \"ti,da850-aemif\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, aemif_of_match);\n\nstatic int aemif_probe(struct platform_device *pdev)\n{\n\tint i;\n\tint ret = -ENODEV;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child_np;\n\tstruct aemif_device *aemif;\n\tstruct aemif_platform_data *pdata;\n\tstruct of_dev_auxdata *dev_lookup;\n\n\taemif = devm_kzalloc(dev, sizeof(*aemif), GFP_KERNEL);\n\tif (!aemif)\n\t\treturn -ENOMEM;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tdev_lookup = pdata ? pdata->dev_lookup : NULL;\n\n\tplatform_set_drvdata(pdev, aemif);\n\n\taemif->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(aemif->clk)) {\n\t\tdev_err(dev, \"cannot get clock 'aemif'\\n\");\n\t\treturn PTR_ERR(aemif->clk);\n\t}\n\n\tret = clk_prepare_enable(aemif->clk);\n\tif (ret)\n\t\treturn ret;\n\n\taemif->clk_rate = clk_get_rate(aemif->clk) / MSEC_PER_SEC;\n\n\tif (np && of_device_is_compatible(np, \"ti,da850-aemif\"))\n\t\taemif->cs_offset = 2;\n\telse if (pdata)\n\t\taemif->cs_offset = pdata->cs_offset;\n\n\taemif->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(aemif->base)) {\n\t\tret = PTR_ERR(aemif->base);\n\t\tgoto error;\n\t}\n\n\tif (np) {\n\t\t \n\t\tfor_each_available_child_of_node(np, child_np) {\n\t\t\tret = of_aemif_parse_abus_config(pdev, child_np);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(child_np);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} else if (pdata && pdata->num_abus_data > 0) {\n\t\tfor (i = 0; i < pdata->num_abus_data; i++, aemif->num_cs++) {\n\t\t\taemif->cs_data[i].cs = pdata->abus_data[i].cs;\n\t\t\taemif_get_hw_params(pdev, i);\n\t\t}\n\t}\n\n\tfor (i = 0; i < aemif->num_cs; i++) {\n\t\tret = aemif_config_abus(pdev, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Error configuring chip select %d\\n\",\n\t\t\t\taemif->cs_data[i].cs);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (np) {\n\t\tfor_each_available_child_of_node(np, child_np) {\n\t\t\tret = of_platform_populate(child_np, NULL,\n\t\t\t\t\t\t   dev_lookup, dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(child_np);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} else if (pdata) {\n\t\tfor (i = 0; i < pdata->num_sub_devices; i++) {\n\t\t\tpdata->sub_devices[i].dev.parent = dev;\n\t\t\tret = platform_device_register(&pdata->sub_devices[i]);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(dev, \"Error register sub device %s\\n\",\n\t\t\t\t\t pdata->sub_devices[i].name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tclk_disable_unprepare(aemif->clk);\n\treturn ret;\n}\n\nstatic int aemif_remove(struct platform_device *pdev)\n{\n\tstruct aemif_device *aemif = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(aemif->clk);\n\treturn 0;\n}\n\nstatic struct platform_driver aemif_driver = {\n\t.probe = aemif_probe,\n\t.remove = aemif_remove,\n\t.driver = {\n\t\t.name = \"ti-aemif\",\n\t\t.of_match_table = of_match_ptr(aemif_of_match),\n\t},\n};\n\nmodule_platform_driver(aemif_driver);\n\nMODULE_AUTHOR(\"Murali Karicheri <m-karicheri2@ti.com>\");\nMODULE_AUTHOR(\"Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments AEMIF driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}