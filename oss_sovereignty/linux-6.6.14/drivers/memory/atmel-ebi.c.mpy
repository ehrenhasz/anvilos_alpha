{
  "module_name": "atmel-ebi.c",
  "hash_id": "9f3901f8e27ab804d72830e97132b3477259a2ea300cdba84d061b8b1d09820e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/atmel-ebi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/atmel-matrix.h>\n#include <linux/mfd/syscon/atmel-smc.h>\n#include <linux/init.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <soc/at91/atmel-sfr.h>\n\n#define AT91_EBI_NUM_CS\t\t8\n\nstruct atmel_ebi_dev_config {\n\tint cs;\n\tstruct atmel_smc_cs_conf smcconf;\n};\n\nstruct atmel_ebi;\n\nstruct atmel_ebi_dev {\n\tstruct list_head node;\n\tstruct atmel_ebi *ebi;\n\tu32 mode;\n\tint numcs;\n\tstruct atmel_ebi_dev_config configs[];\n};\n\nstruct atmel_ebi_caps {\n\tunsigned int available_cs;\n\tunsigned int ebi_csa_offs;\n\tconst char *regmap_name;\n\tvoid (*get_config)(struct atmel_ebi_dev *ebid,\n\t\t\t   struct atmel_ebi_dev_config *conf);\n\tint (*xlate_config)(struct atmel_ebi_dev *ebid,\n\t\t\t    struct device_node *configs_np,\n\t\t\t    struct atmel_ebi_dev_config *conf);\n\tvoid (*apply_config)(struct atmel_ebi_dev *ebid,\n\t\t\t     struct atmel_ebi_dev_config *conf);\n};\n\nstruct atmel_ebi {\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tstruct  {\n\t\tstruct regmap *regmap;\n\t\tstruct clk *clk;\n\t\tconst struct atmel_hsmc_reg_layout *layout;\n\t} smc;\n\n\tstruct device *dev;\n\tconst struct atmel_ebi_caps *caps;\n\tstruct list_head devs;\n};\n\nstruct atmel_smc_timing_xlate {\n\tconst char *name;\n\tint (*converter)(struct atmel_smc_cs_conf *conf,\n\t\t\t unsigned int shift, unsigned int nycles);\n\tunsigned int shift;\n};\n\n#define ATMEL_SMC_SETUP_XLATE(nm, pos)\t\\\n\t{ .name = nm, .converter = atmel_smc_cs_conf_set_setup, .shift = pos}\n\n#define ATMEL_SMC_PULSE_XLATE(nm, pos)\t\\\n\t{ .name = nm, .converter = atmel_smc_cs_conf_set_pulse, .shift = pos}\n\n#define ATMEL_SMC_CYCLE_XLATE(nm, pos)\t\\\n\t{ .name = nm, .converter = atmel_smc_cs_conf_set_cycle, .shift = pos}\n\nstatic void at91sam9_ebi_get_config(struct atmel_ebi_dev *ebid,\n\t\t\t\t    struct atmel_ebi_dev_config *conf)\n{\n\tatmel_smc_cs_conf_get(ebid->ebi->smc.regmap, conf->cs,\n\t\t\t      &conf->smcconf);\n}\n\nstatic void sama5_ebi_get_config(struct atmel_ebi_dev *ebid,\n\t\t\t\t struct atmel_ebi_dev_config *conf)\n{\n\tatmel_hsmc_cs_conf_get(ebid->ebi->smc.regmap, ebid->ebi->smc.layout,\n\t\t\t       conf->cs, &conf->smcconf);\n}\n\nstatic const struct atmel_smc_timing_xlate timings_xlate_table[] = {\n\tATMEL_SMC_SETUP_XLATE(\"atmel,smc-ncs-rd-setup-ns\",\n\t\t\t      ATMEL_SMC_NCS_RD_SHIFT),\n\tATMEL_SMC_SETUP_XLATE(\"atmel,smc-ncs-wr-setup-ns\",\n\t\t\t      ATMEL_SMC_NCS_WR_SHIFT),\n\tATMEL_SMC_SETUP_XLATE(\"atmel,smc-nrd-setup-ns\", ATMEL_SMC_NRD_SHIFT),\n\tATMEL_SMC_SETUP_XLATE(\"atmel,smc-nwe-setup-ns\", ATMEL_SMC_NWE_SHIFT),\n\tATMEL_SMC_PULSE_XLATE(\"atmel,smc-ncs-rd-pulse-ns\",\n\t\t\t      ATMEL_SMC_NCS_RD_SHIFT),\n\tATMEL_SMC_PULSE_XLATE(\"atmel,smc-ncs-wr-pulse-ns\",\n\t\t\t      ATMEL_SMC_NCS_WR_SHIFT),\n\tATMEL_SMC_PULSE_XLATE(\"atmel,smc-nrd-pulse-ns\", ATMEL_SMC_NRD_SHIFT),\n\tATMEL_SMC_PULSE_XLATE(\"atmel,smc-nwe-pulse-ns\", ATMEL_SMC_NWE_SHIFT),\n\tATMEL_SMC_CYCLE_XLATE(\"atmel,smc-nrd-cycle-ns\", ATMEL_SMC_NRD_SHIFT),\n\tATMEL_SMC_CYCLE_XLATE(\"atmel,smc-nwe-cycle-ns\", ATMEL_SMC_NWE_SHIFT),\n};\n\nstatic int atmel_ebi_xslate_smc_timings(struct atmel_ebi_dev *ebid,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tstruct atmel_smc_cs_conf *smcconf)\n{\n\tunsigned int clk_rate = clk_get_rate(ebid->ebi->clk);\n\tunsigned int clk_period_ns = NSEC_PER_SEC / clk_rate;\n\tbool required = false;\n\tunsigned int ncycles;\n\tint ret, i;\n\tu32 val;\n\n\tret = of_property_read_u32(np, \"atmel,smc-tdf-ns\", &val);\n\tif (!ret) {\n\t\trequired = true;\n\t\tncycles = DIV_ROUND_UP(val, clk_period_ns);\n\t\tif (ncycles > ATMEL_SMC_MODE_TDF_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ncycles < ATMEL_SMC_MODE_TDF_MIN)\n\t\t\tncycles = ATMEL_SMC_MODE_TDF_MIN;\n\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_TDF(ncycles);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(timings_xlate_table); i++) {\n\t\tconst struct atmel_smc_timing_xlate *xlate;\n\n\t\txlate = &timings_xlate_table[i];\n\n\t\tret = of_property_read_u32(np, xlate->name, &val);\n\t\tif (ret) {\n\t\t\tif (!required)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!required) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tncycles = DIV_ROUND_UP(val, clk_period_ns);\n\t\tret = xlate->converter(smcconf, xlate->shift, ncycles);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tdev_err(ebid->ebi->dev,\n\t\t\t\"missing or invalid timings definition in %pOF\",\n\t\t\tnp);\n\t\treturn ret;\n\t}\n\n\treturn required;\n}\n\nstatic int atmel_ebi_xslate_smc_config(struct atmel_ebi_dev *ebid,\n\t\t\t\t       struct device_node *np,\n\t\t\t\t       struct atmel_ebi_dev_config *conf)\n{\n\tstruct atmel_smc_cs_conf *smcconf = &conf->smcconf;\n\tbool required = false;\n\tconst char *tmp_str;\n\tu32 tmp;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"atmel,smc-bus-width\", &tmp);\n\tif (!ret) {\n\t\tswitch (tmp) {\n\t\tcase 8:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_DBW_8;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_DBW_16;\n\t\t\tbreak;\n\n\t\tcase 32:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_DBW_32;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trequired = true;\n\t}\n\n\tif (of_property_read_bool(np, \"atmel,smc-tdf-optimized\")) {\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_TDFMODE_OPTIMIZED;\n\t\trequired = true;\n\t}\n\n\ttmp_str = NULL;\n\tof_property_read_string(np, \"atmel,smc-byte-access-type\", &tmp_str);\n\tif (tmp_str && !strcmp(tmp_str, \"write\")) {\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_BAT_WRITE;\n\t\trequired = true;\n\t}\n\n\ttmp_str = NULL;\n\tof_property_read_string(np, \"atmel,smc-read-mode\", &tmp_str);\n\tif (tmp_str && !strcmp(tmp_str, \"nrd\")) {\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_READMODE_NRD;\n\t\trequired = true;\n\t}\n\n\ttmp_str = NULL;\n\tof_property_read_string(np, \"atmel,smc-write-mode\", &tmp_str);\n\tif (tmp_str && !strcmp(tmp_str, \"nwe\")) {\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_WRITEMODE_NWE;\n\t\trequired = true;\n\t}\n\n\ttmp_str = NULL;\n\tof_property_read_string(np, \"atmel,smc-exnw-mode\", &tmp_str);\n\tif (tmp_str) {\n\t\tif (!strcmp(tmp_str, \"frozen\"))\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_EXNWMODE_FROZEN;\n\t\telse if (!strcmp(tmp_str, \"ready\"))\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_EXNWMODE_READY;\n\t\telse if (strcmp(tmp_str, \"disabled\"))\n\t\t\treturn -EINVAL;\n\n\t\trequired = true;\n\t}\n\n\tret = of_property_read_u32(np, \"atmel,smc-page-mode\", &tmp);\n\tif (!ret) {\n\t\tswitch (tmp) {\n\t\tcase 4:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_PS_4;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_PS_8;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_PS_16;\n\t\t\tbreak;\n\n\t\tcase 32:\n\t\t\tsmcconf->mode |= ATMEL_SMC_MODE_PS_32;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_PMEN;\n\t\trequired = true;\n\t}\n\n\tret = atmel_ebi_xslate_smc_timings(ebid, np, &conf->smcconf);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tif ((ret > 0 && !required) || (!ret && required)) {\n\t\tdev_err(ebid->ebi->dev, \"missing atmel,smc- properties in %pOF\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn required;\n}\n\nstatic void at91sam9_ebi_apply_config(struct atmel_ebi_dev *ebid,\n\t\t\t\t      struct atmel_ebi_dev_config *conf)\n{\n\tatmel_smc_cs_conf_apply(ebid->ebi->smc.regmap, conf->cs,\n\t\t\t\t&conf->smcconf);\n}\n\nstatic void sama5_ebi_apply_config(struct atmel_ebi_dev *ebid,\n\t\t\t\t   struct atmel_ebi_dev_config *conf)\n{\n\tatmel_hsmc_cs_conf_apply(ebid->ebi->smc.regmap, ebid->ebi->smc.layout,\n\t\t\t\t conf->cs, &conf->smcconf);\n}\n\nstatic int atmel_ebi_dev_setup(struct atmel_ebi *ebi, struct device_node *np,\n\t\t\t       int reg_cells)\n{\n\tconst struct atmel_ebi_caps *caps = ebi->caps;\n\tstruct atmel_ebi_dev_config conf = { };\n\tstruct device *dev = ebi->dev;\n\tstruct atmel_ebi_dev *ebid;\n\tunsigned long cslines = 0;\n\tint ret, numcs = 0, nentries, i;\n\tbool apply = false;\n\tu32 cs;\n\n\tnentries = of_property_count_elems_of_size(np, \"reg\",\n\t\t\t\t\t\t   reg_cells * sizeof(u32));\n\tfor (i = 0; i < nentries; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i * reg_cells,\n\t\t\t\t\t\t &cs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (cs >= AT91_EBI_NUM_CS ||\n\t\t    !(ebi->caps->available_cs & BIT(cs))) {\n\t\t\tdev_err(dev, \"invalid reg property in %pOF\\n\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!test_and_set_bit(cs, &cslines))\n\t\t\tnumcs++;\n\t}\n\n\tif (!numcs) {\n\t\tdev_err(dev, \"invalid reg property in %pOF\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tebid = devm_kzalloc(ebi->dev, struct_size(ebid, configs, numcs),\n\t\t\t    GFP_KERNEL);\n\tif (!ebid)\n\t\treturn -ENOMEM;\n\n\tebid->ebi = ebi;\n\tebid->numcs = numcs;\n\n\tret = caps->xlate_config(ebid, np, &conf);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret)\n\t\tapply = true;\n\n\ti = 0;\n\tfor_each_set_bit(cs, &cslines, AT91_EBI_NUM_CS) {\n\t\tebid->configs[i].cs = cs;\n\n\t\tif (apply) {\n\t\t\tconf.cs = cs;\n\t\t\tcaps->apply_config(ebid, &conf);\n\t\t}\n\n\t\tcaps->get_config(ebid, &ebid->configs[i]);\n\n\t\t \n\t\tif (ebi->caps->ebi_csa_offs && apply)\n\t\t\tregmap_update_bits(ebi->regmap,\n\t\t\t\t\t   ebi->caps->ebi_csa_offs,\n\t\t\t\t\t   BIT(cs), 0);\n\n\t\ti++;\n\t}\n\n\tlist_add_tail(&ebid->node, &ebi->devs);\n\n\treturn 0;\n}\n\nstatic const struct atmel_ebi_caps at91sam9260_ebi_caps = {\n\t.available_cs = 0xff,\n\t.ebi_csa_offs = AT91SAM9260_MATRIX_EBICSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps at91sam9261_ebi_caps = {\n\t.available_cs = 0xff,\n\t.ebi_csa_offs = AT91SAM9261_MATRIX_EBICSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps at91sam9263_ebi0_caps = {\n\t.available_cs = 0x3f,\n\t.ebi_csa_offs = AT91SAM9263_MATRIX_EBI0CSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps at91sam9263_ebi1_caps = {\n\t.available_cs = 0x7,\n\t.ebi_csa_offs = AT91SAM9263_MATRIX_EBI1CSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps at91sam9rl_ebi_caps = {\n\t.available_cs = 0x3f,\n\t.ebi_csa_offs = AT91SAM9RL_MATRIX_EBICSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps at91sam9g45_ebi_caps = {\n\t.available_cs = 0x3f,\n\t.ebi_csa_offs = AT91SAM9G45_MATRIX_EBICSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps at91sam9x5_ebi_caps = {\n\t.available_cs = 0x3f,\n\t.ebi_csa_offs = AT91SAM9X5_MATRIX_EBICSA,\n\t.regmap_name = \"atmel,matrix\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps sama5d3_ebi_caps = {\n\t.available_cs = 0xf,\n\t.get_config = sama5_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = sama5_ebi_apply_config,\n};\n\nstatic const struct atmel_ebi_caps sam9x60_ebi_caps = {\n\t.available_cs = 0x3f,\n\t.ebi_csa_offs = AT91_SFR_CCFG_EBICSA,\n\t.regmap_name = \"microchip,sfr\",\n\t.get_config = at91sam9_ebi_get_config,\n\t.xlate_config = atmel_ebi_xslate_smc_config,\n\t.apply_config = at91sam9_ebi_apply_config,\n};\n\nstatic const struct of_device_id atmel_ebi_id_table[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9260-ebi\",\n\t\t.data = &at91sam9260_ebi_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9261-ebi\",\n\t\t.data = &at91sam9261_ebi_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9263-ebi0\",\n\t\t.data = &at91sam9263_ebi0_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9263-ebi1\",\n\t\t.data = &at91sam9263_ebi1_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9rl-ebi\",\n\t\t.data = &at91sam9rl_ebi_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9g45-ebi\",\n\t\t.data = &at91sam9g45_ebi_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9x5-ebi\",\n\t\t.data = &at91sam9x5_ebi_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d3-ebi\",\n\t\t.data = &sama5d3_ebi_caps,\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-ebi\",\n\t\t.data = &sam9x60_ebi_caps,\n\t},\n\t{   }\n};\n\nstatic int atmel_ebi_dev_disable(struct atmel_ebi *ebi, struct device_node *np)\n{\n\tstruct device *dev = ebi->dev;\n\tstruct property *newprop;\n\n\tnewprop = devm_kzalloc(dev, sizeof(*newprop), GFP_KERNEL);\n\tif (!newprop)\n\t\treturn -ENOMEM;\n\n\tnewprop->name = devm_kstrdup(dev, \"status\", GFP_KERNEL);\n\tif (!newprop->name)\n\t\treturn -ENOMEM;\n\n\tnewprop->value = devm_kstrdup(dev, \"disabled\", GFP_KERNEL);\n\tif (!newprop->value)\n\t\treturn -ENOMEM;\n\n\tnewprop->length = sizeof(\"disabled\");\n\n\treturn of_update_property(np, newprop);\n}\n\nstatic int atmel_ebi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *np = dev->of_node, *smc_np;\n\tconst struct of_device_id *match;\n\tstruct atmel_ebi *ebi;\n\tint ret, reg_cells;\n\tstruct clk *clk;\n\tu32 val;\n\n\tmatch = of_match_device(atmel_ebi_id_table, dev);\n\tif (!match || !match->data)\n\t\treturn -EINVAL;\n\n\tebi = devm_kzalloc(dev, sizeof(*ebi), GFP_KERNEL);\n\tif (!ebi)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ebi);\n\n\tINIT_LIST_HEAD(&ebi->devs);\n\tebi->caps = match->data;\n\tebi->dev = dev;\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tebi->clk = clk;\n\n\tsmc_np = of_parse_phandle(dev->of_node, \"atmel,smc\", 0);\n\n\tebi->smc.regmap = syscon_node_to_regmap(smc_np);\n\tif (IS_ERR(ebi->smc.regmap)) {\n\t\tret = PTR_ERR(ebi->smc.regmap);\n\t\tgoto put_node;\n\t}\n\n\tebi->smc.layout = atmel_hsmc_get_reg_layout(smc_np);\n\tif (IS_ERR(ebi->smc.layout)) {\n\t\tret = PTR_ERR(ebi->smc.layout);\n\t\tgoto put_node;\n\t}\n\n\tebi->smc.clk = of_clk_get(smc_np, 0);\n\tif (IS_ERR(ebi->smc.clk)) {\n\t\tif (PTR_ERR(ebi->smc.clk) != -ENOENT) {\n\t\t\tret = PTR_ERR(ebi->smc.clk);\n\t\t\tgoto put_node;\n\t\t}\n\n\t\tebi->smc.clk = NULL;\n\t}\n\tof_node_put(smc_np);\n\tret = clk_prepare_enable(ebi->smc.clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ebi->caps->ebi_csa_offs) {\n\t\tebi->regmap =\n\t\t\tsyscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t\tebi->caps->regmap_name);\n\t\tif (IS_ERR(ebi->regmap))\n\t\t\treturn PTR_ERR(ebi->regmap);\n\t}\n\n\tret = of_property_read_u32(np, \"#address-cells\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"missing #address-cells property\\n\");\n\t\treturn ret;\n\t}\n\n\treg_cells = val;\n\n\tret = of_property_read_u32(np, \"#size-cells\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"missing #address-cells property\\n\");\n\t\treturn ret;\n\t}\n\n\treg_cells += val;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (!of_property_present(child, \"reg\"))\n\t\t\tcontinue;\n\n\t\tret = atmel_ebi_dev_setup(ebi, child, reg_cells);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to configure EBI bus for %pOF, disabling the device\",\n\t\t\t\tchild);\n\n\t\t\tret = atmel_ebi_dev_disable(ebi, child);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn of_platform_populate(np, NULL, NULL, dev);\n\nput_node:\n\tof_node_put(smc_np);\n\treturn ret;\n}\n\nstatic __maybe_unused int atmel_ebi_resume(struct device *dev)\n{\n\tstruct atmel_ebi *ebi = dev_get_drvdata(dev);\n\tstruct atmel_ebi_dev *ebid;\n\n\tlist_for_each_entry(ebid, &ebi->devs, node) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ebid->numcs; i++)\n\t\t\tebid->ebi->caps->apply_config(ebid, &ebid->configs[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(atmel_ebi_pm_ops, NULL, atmel_ebi_resume);\n\nstatic struct platform_driver atmel_ebi_driver = {\n\t.driver = {\n\t\t.name = \"atmel-ebi\",\n\t\t.of_match_table\t= atmel_ebi_id_table,\n\t\t.pm = &atmel_ebi_pm_ops,\n\t},\n};\nbuiltin_platform_driver_probe(atmel_ebi_driver, atmel_ebi_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}