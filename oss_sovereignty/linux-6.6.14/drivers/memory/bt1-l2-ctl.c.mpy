{
  "module_name": "bt1-l2-ctl.c",
  "hash_id": "1e9e0a8b2a6eccdaf352768fb2a9d793ee345bab60e604412a8ac81bcb3a8dea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/bt1-l2-ctl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/bitfield.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/sysfs.h>\n#include <linux/of.h>\n\n#define L2_CTL_REG\t\t\t0x028\n#define L2_CTL_DATA_STALL_FLD\t\t0\n#define L2_CTL_DATA_STALL_MASK\t\tGENMASK(1, L2_CTL_DATA_STALL_FLD)\n#define L2_CTL_TAG_STALL_FLD\t\t2\n#define L2_CTL_TAG_STALL_MASK\t\tGENMASK(3, L2_CTL_TAG_STALL_FLD)\n#define L2_CTL_WS_STALL_FLD\t\t4\n#define L2_CTL_WS_STALL_MASK\t\tGENMASK(5, L2_CTL_WS_STALL_FLD)\n#define L2_CTL_SET_CLKRATIO\t\tBIT(13)\n#define L2_CTL_CLKRATIO_LOCK\t\tBIT(31)\n\n#define L2_CTL_STALL_MIN\t\t0\n#define L2_CTL_STALL_MAX\t\t3\n#define L2_CTL_STALL_SET_DELAY_US\t1\n#define L2_CTL_STALL_SET_TOUT_US\t1000\n\n \nstruct l2_ctl {\n\tstruct device *dev;\n\n\tstruct regmap *sys_regs;\n};\n\n \nenum l2_ctl_stall {\n\tL2_WS_STALL,\n\tL2_TAG_STALL,\n\tL2_DATA_STALL\n};\n\n \nstruct l2_ctl_device_attribute {\n\tstruct device_attribute dev_attr;\n\tenum l2_ctl_stall id;\n};\n\n#define to_l2_ctl_dev_attr(_dev_attr) \\\n\tcontainer_of(_dev_attr, struct l2_ctl_device_attribute, dev_attr)\n\n#define L2_CTL_ATTR_RW(_name, _prefix, _id) \\\n\tstruct l2_ctl_device_attribute l2_ctl_attr_##_name = \\\n\t\t{ __ATTR(_name, 0644, _prefix##_show, _prefix##_store),\t_id }\n\nstatic int l2_ctl_get_latency(struct l2_ctl *l2, enum l2_ctl_stall id, u32 *val)\n{\n\tu32 data = 0;\n\tint ret;\n\n\tret = regmap_read(l2->sys_regs, L2_CTL_REG, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (id) {\n\tcase L2_WS_STALL:\n\t\t*val = FIELD_GET(L2_CTL_WS_STALL_MASK, data);\n\t\tbreak;\n\tcase L2_TAG_STALL:\n\t\t*val = FIELD_GET(L2_CTL_TAG_STALL_MASK, data);\n\t\tbreak;\n\tcase L2_DATA_STALL:\n\t\t*val = FIELD_GET(L2_CTL_DATA_STALL_MASK, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int l2_ctl_set_latency(struct l2_ctl *l2, enum l2_ctl_stall id, u32 val)\n{\n\tu32 mask = 0, data = 0;\n\tint ret;\n\n\tval = clamp_val(val, L2_CTL_STALL_MIN, L2_CTL_STALL_MAX);\n\n\tswitch (id) {\n\tcase L2_WS_STALL:\n\t\tdata = FIELD_PREP(L2_CTL_WS_STALL_MASK, val);\n\t\tmask = L2_CTL_WS_STALL_MASK;\n\t\tbreak;\n\tcase L2_TAG_STALL:\n\t\tdata = FIELD_PREP(L2_CTL_TAG_STALL_MASK, val);\n\t\tmask = L2_CTL_TAG_STALL_MASK;\n\t\tbreak;\n\tcase L2_DATA_STALL:\n\t\tdata = FIELD_PREP(L2_CTL_DATA_STALL_MASK, val);\n\t\tmask = L2_CTL_DATA_STALL_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdata |= L2_CTL_SET_CLKRATIO;\n\tmask |= L2_CTL_SET_CLKRATIO;\n\n\tret = regmap_update_bits(l2->sys_regs, L2_CTL_REG, mask, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_read_poll_timeout(l2->sys_regs, L2_CTL_REG, data,\n\t\t\t\t\tdata & L2_CTL_CLKRATIO_LOCK,\n\t\t\t\t\tL2_CTL_STALL_SET_DELAY_US,\n\t\t\t\t\tL2_CTL_STALL_SET_TOUT_US);\n}\n\nstatic void l2_ctl_clear_data(void *data)\n{\n\tstruct l2_ctl *l2 = data;\n\tstruct platform_device *pdev = to_platform_device(l2->dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic struct l2_ctl *l2_ctl_create_data(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct l2_ctl *l2;\n\tint ret;\n\n\tl2 = devm_kzalloc(dev, sizeof(*l2), GFP_KERNEL);\n\tif (!l2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = devm_add_action(dev, l2_ctl_clear_data, l2);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't add L2 CTL data clear action\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tl2->dev = dev;\n\tplatform_set_drvdata(pdev, l2);\n\n\treturn l2;\n}\n\nstatic int l2_ctl_find_sys_regs(struct l2_ctl *l2)\n{\n\tl2->sys_regs = syscon_node_to_regmap(l2->dev->of_node->parent);\n\tif (IS_ERR(l2->sys_regs)) {\n\t\tdev_err(l2->dev, \"Couldn't get L2 CTL register map\\n\");\n\t\treturn PTR_ERR(l2->sys_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic int l2_ctl_of_parse_property(struct l2_ctl *l2, enum l2_ctl_stall id,\n\t\t\t\t    const char *propname)\n{\n\tint ret = 0;\n\tu32 data;\n\n\tif (!of_property_read_u32(l2->dev->of_node, propname, &data)) {\n\t\tret = l2_ctl_set_latency(l2, id, data);\n\t\tif (ret)\n\t\t\tdev_err(l2->dev, \"Invalid value of '%s'\\n\", propname);\n\t}\n\n\treturn ret;\n}\n\nstatic int l2_ctl_of_parse(struct l2_ctl *l2)\n{\n\tint ret;\n\n\tret = l2_ctl_of_parse_property(l2, L2_WS_STALL, \"baikal,l2-ws-latency\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = l2_ctl_of_parse_property(l2, L2_TAG_STALL, \"baikal,l2-tag-latency\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn l2_ctl_of_parse_property(l2, L2_DATA_STALL,\n\t\t\t\t\t\"baikal,l2-data-latency\");\n}\n\nstatic ssize_t l2_ctl_latency_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct l2_ctl_device_attribute *devattr = to_l2_ctl_dev_attr(attr);\n\tstruct l2_ctl *l2 = dev_get_drvdata(dev);\n\tu32 data;\n\tint ret;\n\n\tret = l2_ctl_get_latency(l2, devattr->id, &data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", data);\n}\n\nstatic ssize_t l2_ctl_latency_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct l2_ctl_device_attribute *devattr = to_l2_ctl_dev_attr(attr);\n\tstruct l2_ctl *l2 = dev_get_drvdata(dev);\n\tu32 data;\n\tint ret;\n\n\tif (kstrtouint(buf, 0, &data) < 0)\n\t\treturn -EINVAL;\n\n\tret = l2_ctl_set_latency(l2, devattr->id, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic L2_CTL_ATTR_RW(l2_ws_latency, l2_ctl_latency, L2_WS_STALL);\nstatic L2_CTL_ATTR_RW(l2_tag_latency, l2_ctl_latency, L2_TAG_STALL);\nstatic L2_CTL_ATTR_RW(l2_data_latency, l2_ctl_latency, L2_DATA_STALL);\n\nstatic struct attribute *l2_ctl_sysfs_attrs[] = {\n\t&l2_ctl_attr_l2_ws_latency.dev_attr.attr,\n\t&l2_ctl_attr_l2_tag_latency.dev_attr.attr,\n\t&l2_ctl_attr_l2_data_latency.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(l2_ctl_sysfs);\n\nstatic void l2_ctl_remove_sysfs(void *data)\n{\n\tstruct l2_ctl *l2 = data;\n\n\tdevice_remove_groups(l2->dev, l2_ctl_sysfs_groups);\n}\n\nstatic int l2_ctl_init_sysfs(struct l2_ctl *l2)\n{\n\tint ret;\n\n\tret = device_add_groups(l2->dev, l2_ctl_sysfs_groups);\n\tif (ret) {\n\t\tdev_err(l2->dev, \"Failed to create L2 CTL sysfs nodes\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(l2->dev, l2_ctl_remove_sysfs, l2);\n\tif (ret)\n\t\tdev_err(l2->dev, \"Can't add L2 CTL sysfs remove action\\n\");\n\n\treturn ret;\n}\n\nstatic int l2_ctl_probe(struct platform_device *pdev)\n{\n\tstruct l2_ctl *l2;\n\tint ret;\n\n\tl2 = l2_ctl_create_data(pdev);\n\tif (IS_ERR(l2))\n\t\treturn PTR_ERR(l2);\n\n\tret = l2_ctl_find_sys_regs(l2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = l2_ctl_of_parse(l2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = l2_ctl_init_sysfs(l2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id l2_ctl_of_match[] = {\n\t{ .compatible = \"baikal,bt1-l2-ctl\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, l2_ctl_of_match);\n\nstatic struct platform_driver l2_ctl_driver = {\n\t.probe = l2_ctl_probe,\n\t.driver = {\n\t\t.name = \"bt1-l2-ctl\",\n\t\t.of_match_table = l2_ctl_of_match\n\t}\n};\nmodule_platform_driver(l2_ctl_driver);\n\nMODULE_AUTHOR(\"Serge Semin <Sergey.Semin@baikalelectronics.ru>\");\nMODULE_DESCRIPTION(\"Baikal-T1 L2-cache driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}