{
  "module_name": "pl353-smc.c",
  "hash_id": "62351057217df1992c74748a983e452e72c640823c905e1542f5b044792df985",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/pl353-smc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/amba/bus.h>\n\n \nstruct pl353_smc_data {\n\tstruct clk\t\t*memclk;\n\tstruct clk\t\t*aclk;\n};\n\nstatic int __maybe_unused pl353_smc_suspend(struct device *dev)\n{\n\tstruct pl353_smc_data *pl353_smc = dev_get_drvdata(dev);\n\n\tclk_disable(pl353_smc->memclk);\n\tclk_disable(pl353_smc->aclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pl353_smc_resume(struct device *dev)\n{\n\tstruct pl353_smc_data *pl353_smc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(pl353_smc->aclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable axi domain clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_enable(pl353_smc->memclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable memory clock.\\n\");\n\t\tclk_disable(pl353_smc->aclk);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pl353_smc_dev_pm_ops, pl353_smc_suspend,\n\t\t\t pl353_smc_resume);\n\nstatic const struct of_device_id pl353_smc_supported_children[] = {\n\t{\n\t\t.compatible = \"cfi-flash\"\n\t},\n\t{\n\t\t.compatible = \"arm,pl353-nand-r2p1\",\n\t},\n\t{}\n};\n\nstatic int pl353_smc_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct device_node *of_node = adev->dev.of_node;\n\tconst struct of_device_id *match = NULL;\n\tstruct pl353_smc_data *pl353_smc;\n\tstruct device_node *child;\n\tint err;\n\n\tpl353_smc = devm_kzalloc(&adev->dev, sizeof(*pl353_smc), GFP_KERNEL);\n\tif (!pl353_smc)\n\t\treturn -ENOMEM;\n\n\tpl353_smc->aclk = devm_clk_get(&adev->dev, \"apb_pclk\");\n\tif (IS_ERR(pl353_smc->aclk)) {\n\t\tdev_err(&adev->dev, \"aclk clock not found.\\n\");\n\t\treturn PTR_ERR(pl353_smc->aclk);\n\t}\n\n\tpl353_smc->memclk = devm_clk_get(&adev->dev, \"memclk\");\n\tif (IS_ERR(pl353_smc->memclk)) {\n\t\tdev_err(&adev->dev, \"memclk clock not found.\\n\");\n\t\treturn PTR_ERR(pl353_smc->memclk);\n\t}\n\n\terr = clk_prepare_enable(pl353_smc->aclk);\n\tif (err) {\n\t\tdev_err(&adev->dev, \"Unable to enable AXI clock.\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(pl353_smc->memclk);\n\tif (err) {\n\t\tdev_err(&adev->dev, \"Unable to enable memory clock.\\n\");\n\t\tgoto disable_axi_clk;\n\t}\n\n\tamba_set_drvdata(adev, pl353_smc);\n\n\t \n\tfor_each_available_child_of_node(of_node, child) {\n\t\tmatch = of_match_node(pl353_smc_supported_children, child);\n\t\tif (!match) {\n\t\t\tdev_warn(&adev->dev, \"unsupported child node\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!match) {\n\t\terr = -ENODEV;\n\t\tdev_err(&adev->dev, \"no matching children\\n\");\n\t\tgoto disable_mem_clk;\n\t}\n\n\tof_platform_device_create(child, NULL, &adev->dev);\n\tof_node_put(child);\n\n\treturn 0;\n\ndisable_mem_clk:\n\tclk_disable_unprepare(pl353_smc->memclk);\ndisable_axi_clk:\n\tclk_disable_unprepare(pl353_smc->aclk);\n\n\treturn err;\n}\n\nstatic void pl353_smc_remove(struct amba_device *adev)\n{\n\tstruct pl353_smc_data *pl353_smc = amba_get_drvdata(adev);\n\n\tclk_disable_unprepare(pl353_smc->memclk);\n\tclk_disable_unprepare(pl353_smc->aclk);\n}\n\nstatic const struct amba_id pl353_ids[] = {\n\t{\n\t\t.id = 0x00041353,\n\t\t.mask = 0x000fffff,\n\t},\n\t{ 0, 0 },\n};\nMODULE_DEVICE_TABLE(amba, pl353_ids);\n\nstatic struct amba_driver pl353_smc_driver = {\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"pl353-smc\",\n\t\t.pm = &pl353_smc_dev_pm_ops,\n\t},\n\t.id_table = pl353_ids,\n\t.probe = pl353_smc_probe,\n\t.remove = pl353_smc_remove,\n};\n\nmodule_amba_driver(pl353_smc_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"ARM PL353 SMC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}