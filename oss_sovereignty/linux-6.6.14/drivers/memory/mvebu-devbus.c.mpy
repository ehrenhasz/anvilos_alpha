{
  "module_name": "mvebu-devbus.c",
  "hash_id": "bb4f4b527e244c3d448d77c2f489cc67bd83b6b7ff3c1a81606b26cb6f8bbf04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/mvebu-devbus.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/mbus.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n \n#define ARMADA_DEV_WIDTH_SHIFT\t\t30\n#define ARMADA_BADR_SKEW_SHIFT\t\t28\n#define ARMADA_RD_HOLD_SHIFT\t\t23\n#define ARMADA_ACC_NEXT_SHIFT\t\t17\n#define ARMADA_RD_SETUP_SHIFT\t\t12\n#define ARMADA_ACC_FIRST_SHIFT\t\t6\n\n#define ARMADA_SYNC_ENABLE_SHIFT\t24\n#define ARMADA_WR_HIGH_SHIFT\t\t16\n#define ARMADA_WR_LOW_SHIFT\t\t8\n\n#define ARMADA_READ_PARAM_OFFSET\t0x0\n#define ARMADA_WRITE_PARAM_OFFSET\t0x4\n\n#define ORION_RESERVED\t\t\t(0x2 << 30)\n#define ORION_BADR_SKEW_SHIFT\t\t28\n#define ORION_WR_HIGH_EXT_BIT\t\tBIT(27)\n#define ORION_WR_HIGH_EXT_MASK\t\t0x8\n#define ORION_WR_LOW_EXT_BIT\t\tBIT(26)\n#define ORION_WR_LOW_EXT_MASK\t\t0x8\n#define ORION_ALE_WR_EXT_BIT\t\tBIT(25)\n#define ORION_ALE_WR_EXT_MASK\t\t0x8\n#define ORION_ACC_NEXT_EXT_BIT\t\tBIT(24)\n#define ORION_ACC_NEXT_EXT_MASK\t\t0x10\n#define ORION_ACC_FIRST_EXT_BIT\t\tBIT(23)\n#define ORION_ACC_FIRST_EXT_MASK\t0x10\n#define ORION_TURN_OFF_EXT_BIT\t\tBIT(22)\n#define ORION_TURN_OFF_EXT_MASK\t\t0x8\n#define ORION_DEV_WIDTH_SHIFT\t\t20\n#define ORION_WR_HIGH_SHIFT\t\t17\n#define ORION_WR_HIGH_MASK\t\t0x7\n#define ORION_WR_LOW_SHIFT\t\t14\n#define ORION_WR_LOW_MASK\t\t0x7\n#define ORION_ALE_WR_SHIFT\t\t11\n#define ORION_ALE_WR_MASK\t\t0x7\n#define ORION_ACC_NEXT_SHIFT\t\t7\n#define ORION_ACC_NEXT_MASK\t\t0xF\n#define ORION_ACC_FIRST_SHIFT\t\t3\n#define ORION_ACC_FIRST_MASK\t\t0xF\n#define ORION_TURN_OFF_SHIFT\t\t0\n#define ORION_TURN_OFF_MASK\t\t0x7\n\nstruct devbus_read_params {\n\tu32 bus_width;\n\tu32 badr_skew;\n\tu32 turn_off;\n\tu32 acc_first;\n\tu32 acc_next;\n\tu32 rd_setup;\n\tu32 rd_hold;\n};\n\nstruct devbus_write_params {\n\tu32 sync_enable;\n\tu32 wr_high;\n\tu32 wr_low;\n\tu32 ale_wr;\n};\n\nstruct devbus {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned long tick_ps;\n};\n\nstatic int get_timing_param_ps(struct devbus *devbus,\n\t\t\t       struct device_node *node,\n\t\t\t       const char *name,\n\t\t\t       u32 *ticks)\n{\n\tu32 time_ps;\n\tint err;\n\n\terr = of_property_read_u32(node, name, &time_ps);\n\tif (err < 0) {\n\t\tdev_err(devbus->dev, \"%pOF has no '%s' property\\n\",\n\t\t\tnode, name);\n\t\treturn err;\n\t}\n\n\t*ticks = (time_ps + devbus->tick_ps - 1) / devbus->tick_ps;\n\n\tdev_dbg(devbus->dev, \"%s: %u ps -> 0x%x\\n\",\n\t\tname, time_ps, *ticks);\n\treturn 0;\n}\n\nstatic int devbus_get_timing_params(struct devbus *devbus,\n\t\t\t\t    struct device_node *node,\n\t\t\t\t    struct devbus_read_params *r,\n\t\t\t\t    struct devbus_write_params *w)\n{\n\tint err;\n\n\terr = of_property_read_u32(node, \"devbus,bus-width\", &r->bus_width);\n\tif (err < 0) {\n\t\tdev_err(devbus->dev,\n\t\t\t\"%pOF has no 'devbus,bus-width' property\\n\",\n\t\t\tnode);\n\t\treturn err;\n\t}\n\n\t \n\tif (r->bus_width == 8) {\n\t\tr->bus_width = 0;\n\t} else if (r->bus_width == 16) {\n\t\tr->bus_width = 1;\n\t} else {\n\t\tdev_err(devbus->dev, \"invalid bus width %d\\n\", r->bus_width);\n\t\treturn -EINVAL;\n\t}\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,badr-skew-ps\",\n\t\t\t\t  &r->badr_skew);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,turn-off-ps\",\n\t\t\t\t  &r->turn_off);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,acc-first-ps\",\n\t\t\t\t  &r->acc_first);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,acc-next-ps\",\n\t\t\t\t  &r->acc_next);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (of_device_is_compatible(devbus->dev->of_node, \"marvell,mvebu-devbus\")) {\n\t\terr = get_timing_param_ps(devbus, node, \"devbus,rd-setup-ps\",\n\t\t\t\t\t  &r->rd_setup);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = get_timing_param_ps(devbus, node, \"devbus,rd-hold-ps\",\n\t\t\t\t\t  &r->rd_hold);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = of_property_read_u32(node, \"devbus,sync-enable\",\n\t\t\t\t\t   &w->sync_enable);\n\t\tif (err < 0) {\n\t\t\tdev_err(devbus->dev,\n\t\t\t\t\"%pOF has no 'devbus,sync-enable' property\\n\",\n\t\t\t\tnode);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,ale-wr-ps\",\n\t\t\t\t  &w->ale_wr);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,wr-low-ps\",\n\t\t\t\t  &w->wr_low);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = get_timing_param_ps(devbus, node, \"devbus,wr-high-ps\",\n\t\t\t\t  &w->wr_high);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void devbus_orion_set_timing_params(struct devbus *devbus,\n\t\t\t\t\t  struct device_node *node,\n\t\t\t\t\t  struct devbus_read_params *r,\n\t\t\t\t\t  struct devbus_write_params *w)\n{\n\tu32 value;\n\n\t \n\tvalue =\t(r->turn_off   & ORION_TURN_OFF_MASK)  << ORION_TURN_OFF_SHIFT  |\n\t\t(r->acc_first  & ORION_ACC_FIRST_MASK) << ORION_ACC_FIRST_SHIFT |\n\t\t(r->acc_next   & ORION_ACC_NEXT_MASK)  << ORION_ACC_NEXT_SHIFT  |\n\t\t(w->ale_wr     & ORION_ALE_WR_MASK)    << ORION_ALE_WR_SHIFT    |\n\t\t(w->wr_low     & ORION_WR_LOW_MASK)    << ORION_WR_LOW_SHIFT    |\n\t\t(w->wr_high    & ORION_WR_HIGH_MASK)   << ORION_WR_HIGH_SHIFT   |\n\t\tr->bus_width                           << ORION_DEV_WIDTH_SHIFT |\n\t\t((r->turn_off  & ORION_TURN_OFF_EXT_MASK)  ? ORION_TURN_OFF_EXT_BIT  : 0) |\n\t\t((r->acc_first & ORION_ACC_FIRST_EXT_MASK) ? ORION_ACC_FIRST_EXT_BIT : 0) |\n\t\t((r->acc_next  & ORION_ACC_NEXT_EXT_MASK)  ? ORION_ACC_NEXT_EXT_BIT  : 0) |\n\t\t((w->ale_wr    & ORION_ALE_WR_EXT_MASK)    ? ORION_ALE_WR_EXT_BIT    : 0) |\n\t\t((w->wr_low    & ORION_WR_LOW_EXT_MASK)    ? ORION_WR_LOW_EXT_BIT    : 0) |\n\t\t((w->wr_high   & ORION_WR_HIGH_EXT_MASK)   ? ORION_WR_HIGH_EXT_BIT   : 0) |\n\t\t(r->badr_skew << ORION_BADR_SKEW_SHIFT) |\n\t\tORION_RESERVED;\n\n\twritel(value, devbus->base);\n}\n\nstatic void devbus_armada_set_timing_params(struct devbus *devbus,\n\t\t\t\t\t   struct device_node *node,\n\t\t\t\t\t   struct devbus_read_params *r,\n\t\t\t\t\t   struct devbus_write_params *w)\n{\n\tu32 value;\n\n\t \n\tvalue = r->bus_width << ARMADA_DEV_WIDTH_SHIFT |\n\t\tr->badr_skew << ARMADA_BADR_SKEW_SHIFT |\n\t\tr->rd_hold   << ARMADA_RD_HOLD_SHIFT   |\n\t\tr->acc_next  << ARMADA_ACC_NEXT_SHIFT  |\n\t\tr->rd_setup  << ARMADA_RD_SETUP_SHIFT  |\n\t\tr->acc_first << ARMADA_ACC_FIRST_SHIFT |\n\t\tr->turn_off;\n\n\tdev_dbg(devbus->dev, \"read parameters register 0x%p = 0x%x\\n\",\n\t\tdevbus->base + ARMADA_READ_PARAM_OFFSET,\n\t\tvalue);\n\n\twritel(value, devbus->base + ARMADA_READ_PARAM_OFFSET);\n\n\t \n\tvalue = w->sync_enable  << ARMADA_SYNC_ENABLE_SHIFT |\n\t\tw->wr_low       << ARMADA_WR_LOW_SHIFT      |\n\t\tw->wr_high      << ARMADA_WR_HIGH_SHIFT     |\n\t\tw->ale_wr;\n\n\tdev_dbg(devbus->dev, \"write parameters register: 0x%p = 0x%x\\n\",\n\t\tdevbus->base + ARMADA_WRITE_PARAM_OFFSET,\n\t\tvalue);\n\n\twritel(value, devbus->base + ARMADA_WRITE_PARAM_OFFSET);\n}\n\nstatic int mvebu_devbus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct devbus_read_params r;\n\tstruct devbus_write_params w;\n\tstruct devbus *devbus;\n\tstruct clk *clk;\n\tunsigned long rate;\n\tint err;\n\n\tdevbus = devm_kzalloc(&pdev->dev, sizeof(struct devbus), GFP_KERNEL);\n\tif (!devbus)\n\t\treturn -ENOMEM;\n\n\tdevbus->dev = dev;\n\tdevbus->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(devbus->base))\n\t\treturn PTR_ERR(devbus->base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\t \n\trate = clk_get_rate(clk) / 1000;\n\tdevbus->tick_ps = 1000000000 / rate;\n\n\tdev_dbg(devbus->dev, \"Setting timing parameter, tick is %lu ps\\n\",\n\t\tdevbus->tick_ps);\n\n\tif (!of_property_read_bool(node, \"devbus,keep-config\")) {\n\t\t \n\t\terr = devbus_get_timing_params(devbus, node, &r, &w);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif (of_device_is_compatible(node, \"marvell,orion-devbus\"))\n\t\t\tdevbus_orion_set_timing_params(devbus, node, &r, &w);\n\t\telse\n\t\t\tdevbus_armada_set_timing_params(devbus, node, &r, &w);\n\t}\n\n\t \n\terr = of_platform_populate(node, NULL, NULL, dev);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mvebu_devbus_of_match[] = {\n\t{ .compatible = \"marvell,mvebu-devbus\" },\n\t{ .compatible = \"marvell,orion-devbus\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mvebu_devbus_of_match);\n\nstatic struct platform_driver mvebu_devbus_driver = {\n\t.probe\t\t= mvebu_devbus_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mvebu-devbus\",\n\t\t.of_match_table = mvebu_devbus_of_match,\n\t},\n};\n\nstatic int __init mvebu_devbus_init(void)\n{\n\treturn platform_driver_register(&mvebu_devbus_driver);\n}\nmodule_init(mvebu_devbus_init);\n\nMODULE_AUTHOR(\"Ezequiel Garcia <ezequiel.garcia@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Marvell EBU SoC Device Bus controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}