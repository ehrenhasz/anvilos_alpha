{
  "module_name": "mc.c",
  "hash_id": "17417af0c2baa84a32748da9ac3905ed6ae7c380fe72817d35698ad98a5a08d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/mc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/tegra-icc.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"mc.h\"\n\nstatic const struct of_device_id tegra_mc_of_match[] = {\n#ifdef CONFIG_ARCH_TEGRA_2x_SOC\n\t{ .compatible = \"nvidia,tegra20-mc-gart\", .data = &tegra20_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_3x_SOC\n\t{ .compatible = \"nvidia,tegra30-mc\", .data = &tegra30_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_114_SOC\n\t{ .compatible = \"nvidia,tegra114-mc\", .data = &tegra114_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_124_SOC\n\t{ .compatible = \"nvidia,tegra124-mc\", .data = &tegra124_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_132_SOC\n\t{ .compatible = \"nvidia,tegra132-mc\", .data = &tegra132_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_210_SOC\n\t{ .compatible = \"nvidia,tegra210-mc\", .data = &tegra210_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_186_SOC\n\t{ .compatible = \"nvidia,tegra186-mc\", .data = &tegra186_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_194_SOC\n\t{ .compatible = \"nvidia,tegra194-mc\", .data = &tegra194_mc_soc },\n#endif\n#ifdef CONFIG_ARCH_TEGRA_234_SOC\n\t{ .compatible = \"nvidia,tegra234-mc\", .data = &tegra234_mc_soc },\n#endif\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tegra_mc_of_match);\n\nstatic void tegra_mc_devm_action_put_device(void *data)\n{\n\tstruct tegra_mc *mc = data;\n\n\tput_device(mc->dev);\n}\n\n \nstruct tegra_mc *devm_tegra_memory_controller_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct tegra_mc *mc;\n\tint err;\n\n\tnp = of_parse_phandle(dev->of_node, \"nvidia,memory-controller\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmc = platform_get_drvdata(pdev);\n\tif (!mc) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\terr = devm_add_action_or_reset(dev, tegra_mc_devm_action_put_device, mc);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn mc;\n}\nEXPORT_SYMBOL_GPL(devm_tegra_memory_controller_get);\n\nint tegra_mc_probe_device(struct tegra_mc *mc, struct device *dev)\n{\n\tif (mc->soc->ops && mc->soc->ops->probe_device)\n\t\treturn mc->soc->ops->probe_device(mc, dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_mc_probe_device);\n\nint tegra_mc_get_carveout_info(struct tegra_mc *mc, unsigned int id,\n                               phys_addr_t *base, u64 *size)\n{\n\tu32 offset;\n\n\tif (id < 1 || id >= mc->soc->num_carveouts)\n\t\treturn -EINVAL;\n\n\tif (id < 6)\n\t\toffset = 0xc0c + 0x50 * (id - 1);\n\telse\n\t\toffset = 0x2004 + 0x50 * (id - 6);\n\n\t*base = mc_ch_readl(mc, MC_BROADCAST_CHANNEL, offset + 0x0);\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n\t*base |= (phys_addr_t)mc_ch_readl(mc, MC_BROADCAST_CHANNEL, offset + 0x4) << 32;\n#endif\n\n\tif (size)\n\t\t*size = mc_ch_readl(mc, MC_BROADCAST_CHANNEL, offset + 0x8) << 17;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_mc_get_carveout_info);\n\nstatic int tegra_mc_block_dma_common(struct tegra_mc *mc,\n\t\t\t\t     const struct tegra_mc_reset *rst)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&mc->lock, flags);\n\n\tvalue = mc_readl(mc, rst->control) | BIT(rst->bit);\n\tmc_writel(mc, value, rst->control);\n\n\tspin_unlock_irqrestore(&mc->lock, flags);\n\n\treturn 0;\n}\n\nstatic bool tegra_mc_dma_idling_common(struct tegra_mc *mc,\n\t\t\t\t       const struct tegra_mc_reset *rst)\n{\n\treturn (mc_readl(mc, rst->status) & BIT(rst->bit)) != 0;\n}\n\nstatic int tegra_mc_unblock_dma_common(struct tegra_mc *mc,\n\t\t\t\t       const struct tegra_mc_reset *rst)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&mc->lock, flags);\n\n\tvalue = mc_readl(mc, rst->control) & ~BIT(rst->bit);\n\tmc_writel(mc, value, rst->control);\n\n\tspin_unlock_irqrestore(&mc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tegra_mc_reset_status_common(struct tegra_mc *mc,\n\t\t\t\t\tconst struct tegra_mc_reset *rst)\n{\n\treturn (mc_readl(mc, rst->control) & BIT(rst->bit)) != 0;\n}\n\nconst struct tegra_mc_reset_ops tegra_mc_reset_ops_common = {\n\t.block_dma = tegra_mc_block_dma_common,\n\t.dma_idling = tegra_mc_dma_idling_common,\n\t.unblock_dma = tegra_mc_unblock_dma_common,\n\t.reset_status = tegra_mc_reset_status_common,\n};\n\nstatic inline struct tegra_mc *reset_to_mc(struct reset_controller_dev *rcdev)\n{\n\treturn container_of(rcdev, struct tegra_mc, reset);\n}\n\nstatic const struct tegra_mc_reset *tegra_mc_reset_find(struct tegra_mc *mc,\n\t\t\t\t\t\t\tunsigned long id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < mc->soc->num_resets; i++)\n\t\tif (mc->soc->resets[i].id == id)\n\t\t\treturn &mc->soc->resets[i];\n\n\treturn NULL;\n}\n\nstatic int tegra_mc_hotreset_assert(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct tegra_mc *mc = reset_to_mc(rcdev);\n\tconst struct tegra_mc_reset_ops *rst_ops;\n\tconst struct tegra_mc_reset *rst;\n\tint retries = 500;\n\tint err;\n\n\trst = tegra_mc_reset_find(mc, id);\n\tif (!rst)\n\t\treturn -ENODEV;\n\n\trst_ops = mc->soc->reset_ops;\n\tif (!rst_ops)\n\t\treturn -ENODEV;\n\n\t \n\tif (rst_ops->reset_status) {\n\t\t \n\t\tif (rst_ops->reset_status(mc, rst))\n\t\t\treturn 0;\n\t}\n\n\tif (rst_ops->block_dma) {\n\t\t \n\t\terr = rst_ops->block_dma(mc, rst);\n\t\tif (err) {\n\t\t\tdev_err(mc->dev, \"failed to block %s DMA: %d\\n\",\n\t\t\t\trst->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (rst_ops->dma_idling) {\n\t\t \n\t\twhile (!rst_ops->dma_idling(mc, rst)) {\n\t\t\tif (!retries--) {\n\t\t\t\tdev_err(mc->dev, \"failed to flush %s DMA\\n\",\n\t\t\t\t\trst->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\tusleep_range(10, 100);\n\t\t}\n\t}\n\n\tif (rst_ops->hotreset_assert) {\n\t\t \n\t\terr = rst_ops->hotreset_assert(mc, rst);\n\t\tif (err) {\n\t\t\tdev_err(mc->dev, \"failed to hot reset %s: %d\\n\",\n\t\t\t\trst->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_mc_hotreset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t      unsigned long id)\n{\n\tstruct tegra_mc *mc = reset_to_mc(rcdev);\n\tconst struct tegra_mc_reset_ops *rst_ops;\n\tconst struct tegra_mc_reset *rst;\n\tint err;\n\n\trst = tegra_mc_reset_find(mc, id);\n\tif (!rst)\n\t\treturn -ENODEV;\n\n\trst_ops = mc->soc->reset_ops;\n\tif (!rst_ops)\n\t\treturn -ENODEV;\n\n\tif (rst_ops->hotreset_deassert) {\n\t\t \n\t\terr = rst_ops->hotreset_deassert(mc, rst);\n\t\tif (err) {\n\t\t\tdev_err(mc->dev, \"failed to deassert hot reset %s: %d\\n\",\n\t\t\t\trst->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (rst_ops->unblock_dma) {\n\t\t \n\t\terr = rst_ops->unblock_dma(mc, rst);\n\t\tif (err) {\n\t\t\tdev_err(mc->dev, \"failed to unblock %s DMA : %d\\n\",\n\t\t\t\trst->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_mc_hotreset_status(struct reset_controller_dev *rcdev,\n\t\t\t\t    unsigned long id)\n{\n\tstruct tegra_mc *mc = reset_to_mc(rcdev);\n\tconst struct tegra_mc_reset_ops *rst_ops;\n\tconst struct tegra_mc_reset *rst;\n\n\trst = tegra_mc_reset_find(mc, id);\n\tif (!rst)\n\t\treturn -ENODEV;\n\n\trst_ops = mc->soc->reset_ops;\n\tif (!rst_ops)\n\t\treturn -ENODEV;\n\n\treturn rst_ops->reset_status(mc, rst);\n}\n\nstatic const struct reset_control_ops tegra_mc_reset_ops = {\n\t.assert = tegra_mc_hotreset_assert,\n\t.deassert = tegra_mc_hotreset_deassert,\n\t.status = tegra_mc_hotreset_status,\n};\n\nstatic int tegra_mc_reset_setup(struct tegra_mc *mc)\n{\n\tint err;\n\n\tmc->reset.ops = &tegra_mc_reset_ops;\n\tmc->reset.owner = THIS_MODULE;\n\tmc->reset.of_node = mc->dev->of_node;\n\tmc->reset.of_reset_n_cells = 1;\n\tmc->reset.nr_resets = mc->soc->num_resets;\n\n\terr = reset_controller_register(&mc->reset);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint tegra_mc_write_emem_configuration(struct tegra_mc *mc, unsigned long rate)\n{\n\tunsigned int i;\n\tstruct tegra_mc_timing *timing = NULL;\n\n\tfor (i = 0; i < mc->num_timings; i++) {\n\t\tif (mc->timings[i].rate == rate) {\n\t\t\ttiming = &mc->timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timing) {\n\t\tdev_err(mc->dev, \"no memory timing registered for rate %lu\\n\",\n\t\t\trate);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < mc->soc->num_emem_regs; ++i)\n\t\tmc_writel(mc, timing->emem_data[i], mc->soc->emem_regs[i]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_mc_write_emem_configuration);\n\nunsigned int tegra_mc_get_emem_device_count(struct tegra_mc *mc)\n{\n\tu8 dram_count;\n\n\tdram_count = mc_readl(mc, MC_EMEM_ADR_CFG);\n\tdram_count &= MC_EMEM_ADR_CFG_EMEM_NUMDEV;\n\tdram_count++;\n\n\treturn dram_count;\n}\nEXPORT_SYMBOL_GPL(tegra_mc_get_emem_device_count);\n\n#if defined(CONFIG_ARCH_TEGRA_3x_SOC) || \\\n    defined(CONFIG_ARCH_TEGRA_114_SOC) || \\\n    defined(CONFIG_ARCH_TEGRA_124_SOC) || \\\n    defined(CONFIG_ARCH_TEGRA_132_SOC) || \\\n    defined(CONFIG_ARCH_TEGRA_210_SOC)\nstatic int tegra_mc_setup_latency_allowance(struct tegra_mc *mc)\n{\n\tunsigned long long tick;\n\tunsigned int i;\n\tu32 value;\n\n\t \n\ttick = (unsigned long long)mc->tick * clk_get_rate(mc->clk);\n\tdo_div(tick, NSEC_PER_SEC);\n\n\tvalue = mc_readl(mc, MC_EMEM_ARB_CFG);\n\tvalue &= ~MC_EMEM_ARB_CFG_CYCLES_PER_UPDATE_MASK;\n\tvalue |= MC_EMEM_ARB_CFG_CYCLES_PER_UPDATE(tick);\n\tmc_writel(mc, value, MC_EMEM_ARB_CFG);\n\n\t \n\tfor (i = 0; i < mc->soc->num_clients; i++) {\n\t\tconst struct tegra_mc_client *client = &mc->soc->clients[i];\n\t\tu32 value;\n\n\t\tvalue = mc_readl(mc, client->regs.la.reg);\n\t\tvalue &= ~(client->regs.la.mask << client->regs.la.shift);\n\t\tvalue |= (client->regs.la.def & client->regs.la.mask) << client->regs.la.shift;\n\t\tmc_writel(mc, value, client->regs.la.reg);\n\t}\n\n\t \n\tmc_writel(mc, MC_TIMING_UPDATE, MC_TIMING_CONTROL);\n\n\treturn 0;\n}\n\nstatic int load_one_timing(struct tegra_mc *mc,\n\t\t\t   struct tegra_mc_timing *timing,\n\t\t\t   struct device_node *node)\n{\n\tint err;\n\tu32 tmp;\n\n\terr = of_property_read_u32(node, \"clock-frequency\", &tmp);\n\tif (err) {\n\t\tdev_err(mc->dev,\n\t\t\t\"timing %pOFn: failed to read rate\\n\", node);\n\t\treturn err;\n\t}\n\n\ttiming->rate = tmp;\n\ttiming->emem_data = devm_kcalloc(mc->dev, mc->soc->num_emem_regs,\n\t\t\t\t\t sizeof(u32), GFP_KERNEL);\n\tif (!timing->emem_data)\n\t\treturn -ENOMEM;\n\n\terr = of_property_read_u32_array(node, \"nvidia,emem-configuration\",\n\t\t\t\t\t timing->emem_data,\n\t\t\t\t\t mc->soc->num_emem_regs);\n\tif (err) {\n\t\tdev_err(mc->dev,\n\t\t\t\"timing %pOFn: failed to read EMEM configuration\\n\",\n\t\t\tnode);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int load_timings(struct tegra_mc *mc, struct device_node *node)\n{\n\tstruct device_node *child;\n\tstruct tegra_mc_timing *timing;\n\tint child_count = of_get_child_count(node);\n\tint i = 0, err;\n\n\tmc->timings = devm_kcalloc(mc->dev, child_count, sizeof(*timing),\n\t\t\t\t   GFP_KERNEL);\n\tif (!mc->timings)\n\t\treturn -ENOMEM;\n\n\tmc->num_timings = child_count;\n\n\tfor_each_child_of_node(node, child) {\n\t\ttiming = &mc->timings[i++];\n\n\t\terr = load_one_timing(mc, timing, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_mc_setup_timings(struct tegra_mc *mc)\n{\n\tstruct device_node *node;\n\tu32 ram_code, node_ram_code;\n\tint err;\n\n\tram_code = tegra_read_ram_code();\n\n\tmc->num_timings = 0;\n\n\tfor_each_child_of_node(mc->dev->of_node, node) {\n\t\terr = of_property_read_u32(node, \"nvidia,ram-code\",\n\t\t\t\t\t   &node_ram_code);\n\t\tif (err || (node_ram_code != ram_code))\n\t\t\tcontinue;\n\n\t\terr = load_timings(mc, node);\n\t\tof_node_put(node);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\tif (mc->num_timings == 0)\n\t\tdev_warn(mc->dev,\n\t\t\t \"no memory timings for RAM code %u registered\\n\",\n\t\t\t ram_code);\n\n\treturn 0;\n}\n\nint tegra30_mc_probe(struct tegra_mc *mc)\n{\n\tint err;\n\n\tmc->clk = devm_clk_get_optional(mc->dev, \"mc\");\n\tif (IS_ERR(mc->clk)) {\n\t\tdev_err(mc->dev, \"failed to get MC clock: %ld\\n\", PTR_ERR(mc->clk));\n\t\treturn PTR_ERR(mc->clk);\n\t}\n\n\t \n\tmc_writel(mc, 0x00000000, MC_TIMING_CONTROL_DBG);\n\n\terr = tegra_mc_setup_latency_allowance(mc);\n\tif (err < 0) {\n\t\tdev_err(mc->dev, \"failed to setup latency allowance: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_mc_setup_timings(mc);\n\tif (err < 0) {\n\t\tdev_err(mc->dev, \"failed to setup timings: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nconst struct tegra_mc_ops tegra30_mc_ops = {\n\t.probe = tegra30_mc_probe,\n\t.handle_irq = tegra30_mc_handle_irq,\n};\n#endif\n\nstatic int mc_global_intstatus_to_channel(const struct tegra_mc *mc, u32 status,\n\t\t\t\t\t  unsigned int *mc_channel)\n{\n\tif ((status & mc->soc->ch_intmask) == 0)\n\t\treturn -EINVAL;\n\n\t*mc_channel = __ffs((status & mc->soc->ch_intmask) >>\n\t\t\t    mc->soc->global_intstatus_channel_shift);\n\n\treturn 0;\n}\n\nstatic u32 mc_channel_to_global_intstatus(const struct tegra_mc *mc,\n\t\t\t\t\t  unsigned int channel)\n{\n\treturn BIT(channel) << mc->soc->global_intstatus_channel_shift;\n}\n\nirqreturn_t tegra30_mc_handle_irq(int irq, void *data)\n{\n\tstruct tegra_mc *mc = data;\n\tunsigned int bit, channel;\n\tunsigned long status;\n\n\tif (mc->soc->num_channels) {\n\t\tu32 global_status;\n\t\tint err;\n\n\t\tglobal_status = mc_ch_readl(mc, MC_BROADCAST_CHANNEL, MC_GLOBAL_INTSTATUS);\n\t\terr = mc_global_intstatus_to_channel(mc, global_status, &channel);\n\t\tif (err < 0) {\n\t\t\tdev_err_ratelimited(mc->dev, \"unknown interrupt channel 0x%08x\\n\",\n\t\t\t\t\t    global_status);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\n\t\t \n\t\tstatus = mc_ch_readl(mc, channel, MC_INTSTATUS) & mc->soc->intmask;\n\t} else {\n\t\tstatus = mc_readl(mc, MC_INTSTATUS) & mc->soc->intmask;\n\t}\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(bit, &status, 32) {\n\t\tconst char *error = tegra_mc_status_names[bit] ?: \"unknown\";\n\t\tconst char *client = \"unknown\", *desc;\n\t\tconst char *direction, *secure;\n\t\tu32 status_reg, addr_reg;\n\t\tu32 intmask = BIT(bit);\n\t\tphys_addr_t addr = 0;\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n\t\tu32 addr_hi_reg = 0;\n#endif\n\t\tunsigned int i;\n\t\tchar perm[7];\n\t\tu8 id, type;\n\t\tu32 value;\n\n\t\tswitch (intmask) {\n\t\tcase MC_INT_DECERR_VPR:\n\t\t\tstatus_reg = MC_ERR_VPR_STATUS;\n\t\t\taddr_reg = MC_ERR_VPR_ADR;\n\t\t\tbreak;\n\n\t\tcase MC_INT_SECERR_SEC:\n\t\t\tstatus_reg = MC_ERR_SEC_STATUS;\n\t\t\taddr_reg = MC_ERR_SEC_ADR;\n\t\t\tbreak;\n\n\t\tcase MC_INT_DECERR_MTS:\n\t\t\tstatus_reg = MC_ERR_MTS_STATUS;\n\t\t\taddr_reg = MC_ERR_MTS_ADR;\n\t\t\tbreak;\n\n\t\tcase MC_INT_DECERR_GENERALIZED_CARVEOUT:\n\t\t\tstatus_reg = MC_ERR_GENERALIZED_CARVEOUT_STATUS;\n\t\t\taddr_reg = MC_ERR_GENERALIZED_CARVEOUT_ADR;\n\t\t\tbreak;\n\n\t\tcase MC_INT_DECERR_ROUTE_SANITY:\n\t\t\tstatus_reg = MC_ERR_ROUTE_SANITY_STATUS;\n\t\t\taddr_reg = MC_ERR_ROUTE_SANITY_ADR;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstatus_reg = MC_ERR_STATUS;\n\t\t\taddr_reg = MC_ERR_ADR;\n\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n\t\t\tif (mc->soc->has_addr_hi_reg)\n\t\t\t\taddr_hi_reg = MC_ERR_ADR_HI;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mc->soc->num_channels)\n\t\t\tvalue = mc_ch_readl(mc, channel, status_reg);\n\t\telse\n\t\t\tvalue = mc_readl(mc, status_reg);\n\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\n\t\tif (mc->soc->num_address_bits > 32) {\n\t\t\tif (addr_hi_reg) {\n\t\t\t\tif (mc->soc->num_channels)\n\t\t\t\t\taddr = mc_ch_readl(mc, channel, addr_hi_reg);\n\t\t\t\telse\n\t\t\t\t\taddr = mc_readl(mc, addr_hi_reg);\n\t\t\t} else {\n\t\t\t\taddr = ((value >> MC_ERR_STATUS_ADR_HI_SHIFT) &\n\t\t\t\t\tMC_ERR_STATUS_ADR_HI_MASK);\n\t\t\t}\n\t\t\taddr <<= 32;\n\t\t}\n#endif\n\n\t\tif (value & MC_ERR_STATUS_RW)\n\t\t\tdirection = \"write\";\n\t\telse\n\t\t\tdirection = \"read\";\n\n\t\tif (value & MC_ERR_STATUS_SECURITY)\n\t\t\tsecure = \"secure \";\n\t\telse\n\t\t\tsecure = \"\";\n\n\t\tid = value & mc->soc->client_id_mask;\n\n\t\tfor (i = 0; i < mc->soc->num_clients; i++) {\n\t\t\tif (mc->soc->clients[i].id == id) {\n\t\t\t\tclient = mc->soc->clients[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttype = (value & MC_ERR_STATUS_TYPE_MASK) >>\n\t\t       MC_ERR_STATUS_TYPE_SHIFT;\n\t\tdesc = tegra_mc_error_names[type];\n\n\t\tswitch (value & MC_ERR_STATUS_TYPE_MASK) {\n\t\tcase MC_ERR_STATUS_TYPE_INVALID_SMMU_PAGE:\n\t\t\tperm[0] = ' ';\n\t\t\tperm[1] = '[';\n\n\t\t\tif (value & MC_ERR_STATUS_READABLE)\n\t\t\t\tperm[2] = 'R';\n\t\t\telse\n\t\t\t\tperm[2] = '-';\n\n\t\t\tif (value & MC_ERR_STATUS_WRITABLE)\n\t\t\t\tperm[3] = 'W';\n\t\t\telse\n\t\t\t\tperm[3] = '-';\n\n\t\t\tif (value & MC_ERR_STATUS_NONSECURE)\n\t\t\t\tperm[4] = '-';\n\t\t\telse\n\t\t\t\tperm[4] = 'S';\n\n\t\t\tperm[5] = ']';\n\t\t\tperm[6] = '\\0';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tperm[0] = '\\0';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mc->soc->num_channels)\n\t\t\tvalue = mc_ch_readl(mc, channel, addr_reg);\n\t\telse\n\t\t\tvalue = mc_readl(mc, addr_reg);\n\t\taddr |= value;\n\n\t\tdev_err_ratelimited(mc->dev, \"%s: %s%s @%pa: %s (%s%s)\\n\",\n\t\t\t\t    client, secure, direction, &addr, error,\n\t\t\t\t    desc, perm);\n\t}\n\n\t \n\tif (mc->soc->num_channels) {\n\t\tmc_ch_writel(mc, channel, status, MC_INTSTATUS);\n\t\tmc_ch_writel(mc, MC_BROADCAST_CHANNEL,\n\t\t\t     mc_channel_to_global_intstatus(mc, channel),\n\t\t\t     MC_GLOBAL_INTSTATUS);\n\t} else {\n\t\tmc_writel(mc, status, MC_INTSTATUS);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nconst char *const tegra_mc_status_names[32] = {\n\t[ 1] = \"External interrupt\",\n\t[ 6] = \"EMEM address decode error\",\n\t[ 7] = \"GART page fault\",\n\t[ 8] = \"Security violation\",\n\t[ 9] = \"EMEM arbitration error\",\n\t[10] = \"Page fault\",\n\t[11] = \"Invalid APB ASID update\",\n\t[12] = \"VPR violation\",\n\t[13] = \"Secure carveout violation\",\n\t[16] = \"MTS carveout violation\",\n\t[17] = \"Generalized carveout violation\",\n\t[20] = \"Route Sanity error\",\n};\n\nconst char *const tegra_mc_error_names[8] = {\n\t[2] = \"EMEM decode error\",\n\t[3] = \"TrustZone violation\",\n\t[4] = \"Carveout violation\",\n\t[6] = \"SMMU translation error\",\n};\n\nstruct icc_node *tegra_mc_icc_xlate(struct of_phandle_args *spec, void *data)\n{\n\tstruct tegra_mc *mc = icc_provider_to_tegra_mc(data);\n\tstruct icc_node *node;\n\n\tlist_for_each_entry(node, &mc->provider.nodes, node_list) {\n\t\tif (node->id == spec->args[0])\n\t\t\treturn node;\n\t}\n\n\t \n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic int tegra_mc_icc_get(struct icc_node *node, u32 *average, u32 *peak)\n{\n\t*average = 0;\n\t*peak = 0;\n\n\treturn 0;\n}\n\nstatic int tegra_mc_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\treturn 0;\n}\n\nconst struct tegra_mc_icc_ops tegra_mc_icc_ops = {\n\t.xlate = tegra_mc_icc_xlate,\n\t.aggregate = icc_std_aggregate,\n\t.get_bw = tegra_mc_icc_get,\n\t.set = tegra_mc_icc_set,\n};\n\n \nstatic int tegra_mc_interconnect_setup(struct tegra_mc *mc)\n{\n\tstruct icc_node *node;\n\tunsigned int i;\n\tint err;\n\n\t \n\tif (!device_property_present(mc->dev, \"#interconnect-cells\") ||\n\t    !mc->soc->icc_ops)\n\t\treturn 0;\n\n\tmc->provider.dev = mc->dev;\n\tmc->provider.data = &mc->provider;\n\tmc->provider.set = mc->soc->icc_ops->set;\n\tmc->provider.aggregate = mc->soc->icc_ops->aggregate;\n\tmc->provider.get_bw = mc->soc->icc_ops->get_bw;\n\tmc->provider.xlate = mc->soc->icc_ops->xlate;\n\tmc->provider.xlate_extended = mc->soc->icc_ops->xlate_extended;\n\n\ticc_provider_init(&mc->provider);\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_MC);\n\tif (IS_ERR(node))\n\t\treturn PTR_ERR(node);\n\n\tnode->name = \"Memory Controller\";\n\ticc_node_add(node, &mc->provider);\n\n\t \n\terr = icc_link_create(node, TEGRA_ICC_EMC);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\tfor (i = 0; i < mc->soc->num_clients; i++) {\n\t\t \n\t\tnode = icc_node_create(mc->soc->clients[i].id);\n\t\tif (IS_ERR(node)) {\n\t\t\terr = PTR_ERR(node);\n\t\t\tgoto remove_nodes;\n\t\t}\n\n\t\tnode->name = mc->soc->clients[i].name;\n\t\ticc_node_add(node, &mc->provider);\n\n\t\t \n\t\terr = icc_link_create(node, TEGRA_ICC_MC);\n\t\tif (err)\n\t\t\tgoto remove_nodes;\n\n\t\tnode->data = (struct tegra_mc_client *)&(mc->soc->clients[i]);\n\t}\n\n\terr = icc_provider_register(&mc->provider);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\treturn 0;\n\nremove_nodes:\n\ticc_nodes_remove(&mc->provider);\n\n\treturn err;\n}\n\nstatic void tegra_mc_num_channel_enabled(struct tegra_mc *mc)\n{\n\tunsigned int i;\n\tu32 value;\n\n\tvalue = mc_ch_readl(mc, 0, MC_EMEM_ADR_CFG_CHANNEL_ENABLE);\n\tif (value <= 0) {\n\t\tmc->num_channels = mc->soc->num_channels;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (value & BIT(i))\n\t\t\tmc->num_channels++;\n\t}\n}\n\nstatic int tegra_mc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_mc *mc;\n\tu64 mask;\n\tint err;\n\n\tmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mc);\n\tspin_lock_init(&mc->lock);\n\tmc->soc = of_device_get_match_data(&pdev->dev);\n\tmc->dev = &pdev->dev;\n\n\tmask = DMA_BIT_MASK(mc->soc->num_address_bits);\n\n\terr = dma_coerce_mask_and_coherent(&pdev->dev, mask);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tmc->tick = 30;\n\n\tmc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mc->regs))\n\t\treturn PTR_ERR(mc->regs);\n\n\tmc->debugfs.root = debugfs_create_dir(\"mc\", NULL);\n\n\tif (mc->soc->ops && mc->soc->ops->probe) {\n\t\terr = mc->soc->ops->probe(mc);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttegra_mc_num_channel_enabled(mc);\n\n\tif (mc->soc->ops && mc->soc->ops->handle_irq) {\n\t\tmc->irq = platform_get_irq(pdev, 0);\n\t\tif (mc->irq < 0)\n\t\t\treturn mc->irq;\n\n\t\tWARN(!mc->soc->client_id_mask, \"missing client ID mask for this SoC\\n\");\n\n\t\tif (mc->soc->num_channels)\n\t\t\tmc_ch_writel(mc, MC_BROADCAST_CHANNEL, mc->soc->intmask,\n\t\t\t\t     MC_INTMASK);\n\t\telse\n\t\t\tmc_writel(mc, mc->soc->intmask, MC_INTMASK);\n\n\t\terr = devm_request_irq(&pdev->dev, mc->irq, mc->soc->ops->handle_irq, 0,\n\t\t\t\t       dev_name(&pdev->dev), mc);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to request IRQ#%u: %d\\n\", mc->irq,\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (mc->soc->reset_ops) {\n\t\terr = tegra_mc_reset_setup(mc);\n\t\tif (err < 0)\n\t\t\tdev_err(&pdev->dev, \"failed to register reset controller: %d\\n\", err);\n\t}\n\n\terr = tegra_mc_interconnect_setup(mc);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to initialize interconnect: %d\\n\",\n\t\t\terr);\n\n\tif (IS_ENABLED(CONFIG_TEGRA_IOMMU_SMMU) && mc->soc->smmu) {\n\t\tmc->smmu = tegra_smmu_probe(&pdev->dev, mc->soc->smmu, mc);\n\t\tif (IS_ERR(mc->smmu)) {\n\t\t\tdev_err(&pdev->dev, \"failed to probe SMMU: %ld\\n\",\n\t\t\t\tPTR_ERR(mc->smmu));\n\t\t\tmc->smmu = NULL;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_TEGRA_IOMMU_GART) && !mc->soc->smmu) {\n\t\tmc->gart = tegra_gart_probe(&pdev->dev, mc);\n\t\tif (IS_ERR(mc->gart)) {\n\t\t\tdev_err(&pdev->dev, \"failed to probe GART: %ld\\n\",\n\t\t\t\tPTR_ERR(mc->gart));\n\t\t\tmc->gart = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_mc_suspend(struct device *dev)\n{\n\tstruct tegra_mc *mc = dev_get_drvdata(dev);\n\n\tif (mc->soc->ops && mc->soc->ops->suspend)\n\t\treturn mc->soc->ops->suspend(mc);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_mc_resume(struct device *dev)\n{\n\tstruct tegra_mc *mc = dev_get_drvdata(dev);\n\n\tif (mc->soc->ops && mc->soc->ops->resume)\n\t\treturn mc->soc->ops->resume(mc);\n\n\treturn 0;\n}\n\nstatic void tegra_mc_sync_state(struct device *dev)\n{\n\tstruct tegra_mc *mc = dev_get_drvdata(dev);\n\n\t \n\tif (mc->provider.dev == dev)\n\t\ticc_sync_state(dev);\n}\n\nstatic const struct dev_pm_ops tegra_mc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_mc_suspend, tegra_mc_resume)\n};\n\nstatic struct platform_driver tegra_mc_driver = {\n\t.driver = {\n\t\t.name = \"tegra-mc\",\n\t\t.of_match_table = tegra_mc_of_match,\n\t\t.pm = &tegra_mc_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t\t.sync_state = tegra_mc_sync_state,\n\t},\n\t.prevent_deferred_probe = true,\n\t.probe = tegra_mc_probe,\n};\n\nstatic int tegra_mc_init(void)\n{\n\treturn platform_driver_register(&tegra_mc_driver);\n}\narch_initcall(tegra_mc_init);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra Memory Controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}