{
  "module_name": "tegra186-emc.c",
  "hash_id": "1a7218285643e3ec5047ad7eeb300e8a81a934e17178d3eae89a9e83d038b92f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/tegra186-emc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include <soc/tegra/bpmp.h>\n#include \"mc.h\"\n\nstruct tegra186_emc_dvfs {\n\tunsigned long latency;\n\tunsigned long rate;\n};\n\nstruct tegra186_emc {\n\tstruct tegra_bpmp *bpmp;\n\tstruct device *dev;\n\tstruct clk *clk;\n\n\tstruct tegra186_emc_dvfs *dvfs;\n\tunsigned int num_dvfs;\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tunsigned long min_rate;\n\t\tunsigned long max_rate;\n\t} debugfs;\n\n\tstruct icc_provider provider;\n};\n\nstatic inline struct tegra186_emc *to_tegra186_emc(struct icc_provider *provider)\n{\n\treturn container_of(provider, struct tegra186_emc, provider);\n}\n\n \n\nstatic bool tegra186_emc_validate_rate(struct tegra186_emc *emc,\n\t\t\t\t       unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_dvfs; i++)\n\t\tif (rate == emc->dvfs[i].rate)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra186_emc_debug_available_rates_show(struct seq_file *s,\n\t\t\t\t\t\t   void *data)\n{\n\tstruct tegra186_emc *emc = s->private;\n\tconst char *prefix = \"\";\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_dvfs; i++) {\n\t\tseq_printf(s, \"%s%lu\", prefix, emc->dvfs[i].rate);\n\t\tprefix = \" \";\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tegra186_emc_debug_available_rates);\n\nstatic int tegra186_emc_debug_min_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra186_emc *emc = data;\n\n\t*rate = emc->debugfs.min_rate;\n\n\treturn 0;\n}\n\nstatic int tegra186_emc_debug_min_rate_set(void *data, u64 rate)\n{\n\tstruct tegra186_emc *emc = data;\n\tint err;\n\n\tif (!tegra186_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = clk_set_min_rate(emc->clk, rate);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.min_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra186_emc_debug_min_rate_fops,\n\t\t\t  tegra186_emc_debug_min_rate_get,\n\t\t\t  tegra186_emc_debug_min_rate_set, \"%llu\\n\");\n\nstatic int tegra186_emc_debug_max_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra186_emc *emc = data;\n\n\t*rate = emc->debugfs.max_rate;\n\n\treturn 0;\n}\n\nstatic int tegra186_emc_debug_max_rate_set(void *data, u64 rate)\n{\n\tstruct tegra186_emc *emc = data;\n\tint err;\n\n\tif (!tegra186_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = clk_set_max_rate(emc->clk, rate);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.max_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra186_emc_debug_max_rate_fops,\n\t\t\t  tegra186_emc_debug_max_rate_get,\n\t\t\t  tegra186_emc_debug_max_rate_set, \"%llu\\n\");\n\nstatic int tegra186_emc_get_emc_dvfs_latency(struct tegra186_emc *emc)\n{\n\tstruct mrq_emc_dvfs_latency_response response;\n\tstruct tegra_bpmp_message msg;\n\tunsigned int i;\n\tint err;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_EMC_DVFS_LATENCY;\n\tmsg.tx.data = NULL;\n\tmsg.tx.size = 0;\n\tmsg.rx.data = &response;\n\tmsg.rx.size = sizeof(response);\n\n\terr = tegra_bpmp_transfer(emc->bpmp, &msg);\n\tif (err < 0) {\n\t\tdev_err(emc->dev, \"failed to EMC DVFS pairs: %d\\n\", err);\n\t\treturn err;\n\t}\n\tif (msg.rx.ret < 0) {\n\t\tdev_err(emc->dev, \"EMC DVFS MRQ failed: %d (BPMP error code)\\n\", msg.rx.ret);\n\t\treturn -EINVAL;\n\t}\n\n\temc->debugfs.min_rate = ULONG_MAX;\n\temc->debugfs.max_rate = 0;\n\n\temc->num_dvfs = response.num_pairs;\n\n\temc->dvfs = devm_kmalloc_array(emc->dev, emc->num_dvfs, sizeof(*emc->dvfs), GFP_KERNEL);\n\tif (!emc->dvfs)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(emc->dev, \"%u DVFS pairs:\\n\", emc->num_dvfs);\n\n\tfor (i = 0; i < emc->num_dvfs; i++) {\n\t\temc->dvfs[i].rate = response.pairs[i].freq * 1000;\n\t\temc->dvfs[i].latency = response.pairs[i].latency;\n\n\t\tif (emc->dvfs[i].rate < emc->debugfs.min_rate)\n\t\t\temc->debugfs.min_rate = emc->dvfs[i].rate;\n\n\t\tif (emc->dvfs[i].rate > emc->debugfs.max_rate)\n\t\t\temc->debugfs.max_rate = emc->dvfs[i].rate;\n\n\t\tdev_dbg(emc->dev, \"  %2u: %lu Hz -> %lu us\\n\", i,\n\t\t\temc->dvfs[i].rate, emc->dvfs[i].latency);\n\t}\n\n\terr = clk_set_rate_range(emc->clk, emc->debugfs.min_rate, emc->debugfs.max_rate);\n\tif (err < 0) {\n\t\tdev_err(emc->dev, \"failed to set rate range [%lu-%lu] for %pC\\n\",\n\t\t\temc->debugfs.min_rate, emc->debugfs.max_rate, emc->clk);\n\t\treturn err;\n\t}\n\n\temc->debugfs.root = debugfs_create_dir(\"emc\", NULL);\n\tdebugfs_create_file(\"available_rates\", 0444, emc->debugfs.root, emc,\n\t\t\t    &tegra186_emc_debug_available_rates_fops);\n\tdebugfs_create_file(\"min_rate\", 0644, emc->debugfs.root, emc,\n\t\t\t    &tegra186_emc_debug_min_rate_fops);\n\tdebugfs_create_file(\"max_rate\", 0644, emc->debugfs.root, emc,\n\t\t\t    &tegra186_emc_debug_max_rate_fops);\n\n\treturn 0;\n}\n\n \nstatic int tegra_emc_icc_set_bw(struct icc_node *src, struct icc_node *dst)\n{\n\treturn 0;\n}\n\nstatic struct icc_node *\ntegra_emc_of_icc_xlate(struct of_phandle_args *spec, void *data)\n{\n\tstruct icc_provider *provider = data;\n\tstruct icc_node *node;\n\n\t \n\tlist_for_each_entry(node, &provider->nodes, node_list) {\n\t\tif (node->id != TEGRA_ICC_EMEM)\n\t\t\tcontinue;\n\n\t\treturn node;\n\t}\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic int tegra_emc_icc_get_init_bw(struct icc_node *node, u32 *avg, u32 *peak)\n{\n\t*avg = 0;\n\t*peak = 0;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_interconnect_init(struct tegra186_emc *emc)\n{\n\tstruct tegra_mc *mc = dev_get_drvdata(emc->dev->parent);\n\tconst struct tegra_mc_soc *soc = mc->soc;\n\tstruct icc_node *node;\n\tint err;\n\n\temc->provider.dev = emc->dev;\n\temc->provider.set = tegra_emc_icc_set_bw;\n\temc->provider.data = &emc->provider;\n\temc->provider.aggregate = soc->icc_ops->aggregate;\n\temc->provider.xlate = tegra_emc_of_icc_xlate;\n\temc->provider.get_bw = tegra_emc_icc_get_init_bw;\n\n\ticc_provider_init(&emc->provider);\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMC);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto err_msg;\n\t}\n\n\tnode->name = \"External Memory Controller\";\n\ticc_node_add(node, &emc->provider);\n\n\t \n\terr = icc_link_create(node, TEGRA_ICC_EMEM);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMEM);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto remove_nodes;\n\t}\n\n\tnode->name = \"External Memory (DRAM)\";\n\ticc_node_add(node, &emc->provider);\n\n\terr = icc_provider_register(&emc->provider);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\treturn 0;\n\nremove_nodes:\n\ticc_nodes_remove(&emc->provider);\nerr_msg:\n\tdev_err(emc->dev, \"failed to initialize ICC: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int tegra186_emc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_mc *mc = dev_get_drvdata(pdev->dev.parent);\n\tstruct tegra186_emc *emc;\n\tint err;\n\n\temc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn -ENOMEM;\n\n\temc->bpmp = tegra_bpmp_get(&pdev->dev);\n\tif (IS_ERR(emc->bpmp))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(emc->bpmp), \"failed to get BPMP\\n\");\n\n\temc->clk = devm_clk_get(&pdev->dev, \"emc\");\n\tif (IS_ERR(emc->clk)) {\n\t\terr = PTR_ERR(emc->clk);\n\t\tdev_err(&pdev->dev, \"failed to get EMC clock: %d\\n\", err);\n\t\tgoto put_bpmp;\n\t}\n\n\tplatform_set_drvdata(pdev, emc);\n\temc->dev = &pdev->dev;\n\n\tif (tegra_bpmp_mrq_is_supported(emc->bpmp, MRQ_EMC_DVFS_LATENCY)) {\n\t\terr = tegra186_emc_get_emc_dvfs_latency(emc);\n\t\tif (err)\n\t\t\tgoto put_bpmp;\n\t}\n\n\tif (mc && mc->soc->icc_ops) {\n\t\tif (tegra_bpmp_mrq_is_supported(emc->bpmp, MRQ_BWMGR_INT)) {\n\t\t\tmc->bwmgr_mrq_supported = true;\n\n\t\t\t \n\t\t\tmc->bpmp = emc->bpmp;\n\t\t\tbarrier();\n\t\t}\n\n\t\t \n\t\terr = tegra_emc_interconnect_init(emc);\n\t\tif (err) {\n\t\t\tmc->bpmp = NULL;\n\t\t\tgoto put_bpmp;\n\t\t}\n\t}\n\n\treturn 0;\n\nput_bpmp:\n\ttegra_bpmp_put(emc->bpmp);\n\treturn err;\n}\n\nstatic int tegra186_emc_remove(struct platform_device *pdev)\n{\n\tstruct tegra_mc *mc = dev_get_drvdata(pdev->dev.parent);\n\tstruct tegra186_emc *emc = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(emc->debugfs.root);\n\n\tmc->bpmp = NULL;\n\ttegra_bpmp_put(emc->bpmp);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra186_emc_of_match[] = {\n#if defined(CONFIG_ARCH_TEGRA_186_SOC)\n\t{ .compatible = \"nvidia,tegra186-emc\" },\n#endif\n#if defined(CONFIG_ARCH_TEGRA_194_SOC)\n\t{ .compatible = \"nvidia,tegra194-emc\" },\n#endif\n#if defined(CONFIG_ARCH_TEGRA_234_SOC)\n\t{ .compatible = \"nvidia,tegra234-emc\" },\n#endif\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tegra186_emc_of_match);\n\nstatic struct platform_driver tegra186_emc_driver = {\n\t.driver = {\n\t\t.name = \"tegra186-emc\",\n\t\t.of_match_table = tegra186_emc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.sync_state = icc_sync_state,\n\t},\n\t.probe = tegra186_emc_probe,\n\t.remove = tegra186_emc_remove,\n};\nmodule_platform_driver(tegra186_emc_driver);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra186 External Memory Controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}