{
  "module_name": "tegra124-emc.c",
  "hash_id": "28cc922c2fca7c1294e26488204d36f354a88d7c580ab9ebccb260a0707c44dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/tegra124-emc.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk/tegra.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/interconnect-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/sort.h>\n#include <linux/string.h>\n\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/mc.h>\n\n#include \"mc.h\"\n\n#define EMC_FBIO_CFG5\t\t\t\t0x104\n#define\tEMC_FBIO_CFG5_DRAM_TYPE_MASK\t\t0x3\n#define\tEMC_FBIO_CFG5_DRAM_TYPE_SHIFT\t\t0\n#define EMC_FBIO_CFG5_DRAM_WIDTH_X64\t\tBIT(4)\n\n#define EMC_INTSTATUS\t\t\t\t0x0\n#define EMC_INTSTATUS_CLKCHANGE_COMPLETE\tBIT(4)\n\n#define EMC_CFG\t\t\t\t\t0xc\n#define EMC_CFG_DRAM_CLKSTOP_PD\t\t\tBIT(31)\n#define EMC_CFG_DRAM_CLKSTOP_SR\t\t\tBIT(30)\n#define EMC_CFG_DRAM_ACPD\t\t\tBIT(29)\n#define EMC_CFG_DYN_SREF\t\t\tBIT(28)\n#define EMC_CFG_PWR_MASK\t\t\t((0xF << 28) | BIT(18))\n#define EMC_CFG_DSR_VTTGEN_DRV_EN\t\tBIT(18)\n\n#define EMC_REFCTRL\t\t\t\t0x20\n#define EMC_REFCTRL_DEV_SEL_SHIFT\t\t0\n#define EMC_REFCTRL_ENABLE\t\t\tBIT(31)\n\n#define EMC_TIMING_CONTROL\t\t\t0x28\n#define EMC_RC\t\t\t\t\t0x2c\n#define EMC_RFC\t\t\t\t\t0x30\n#define EMC_RAS\t\t\t\t\t0x34\n#define EMC_RP\t\t\t\t\t0x38\n#define EMC_R2W\t\t\t\t\t0x3c\n#define EMC_W2R\t\t\t\t\t0x40\n#define EMC_R2P\t\t\t\t\t0x44\n#define EMC_W2P\t\t\t\t\t0x48\n#define EMC_RD_RCD\t\t\t\t0x4c\n#define EMC_WR_RCD\t\t\t\t0x50\n#define EMC_RRD\t\t\t\t\t0x54\n#define EMC_REXT\t\t\t\t0x58\n#define EMC_WDV\t\t\t\t\t0x5c\n#define EMC_QUSE\t\t\t\t0x60\n#define EMC_QRST\t\t\t\t0x64\n#define EMC_QSAFE\t\t\t\t0x68\n#define EMC_RDV\t\t\t\t\t0x6c\n#define EMC_REFRESH\t\t\t\t0x70\n#define EMC_BURST_REFRESH_NUM\t\t\t0x74\n#define EMC_PDEX2WR\t\t\t\t0x78\n#define EMC_PDEX2RD\t\t\t\t0x7c\n#define EMC_PCHG2PDEN\t\t\t\t0x80\n#define EMC_ACT2PDEN\t\t\t\t0x84\n#define EMC_AR2PDEN\t\t\t\t0x88\n#define EMC_RW2PDEN\t\t\t\t0x8c\n#define EMC_TXSR\t\t\t\t0x90\n#define EMC_TCKE\t\t\t\t0x94\n#define EMC_TFAW\t\t\t\t0x98\n#define EMC_TRPAB\t\t\t\t0x9c\n#define EMC_TCLKSTABLE\t\t\t\t0xa0\n#define EMC_TCLKSTOP\t\t\t\t0xa4\n#define EMC_TREFBW\t\t\t\t0xa8\n#define EMC_ODT_WRITE\t\t\t\t0xb0\n#define EMC_ODT_READ\t\t\t\t0xb4\n#define EMC_WEXT\t\t\t\t0xb8\n#define EMC_CTT\t\t\t\t\t0xbc\n#define EMC_RFC_SLR\t\t\t\t0xc0\n#define EMC_MRS_WAIT_CNT2\t\t\t0xc4\n\n#define EMC_MRS_WAIT_CNT\t\t\t0xc8\n#define EMC_MRS_WAIT_CNT_SHORT_WAIT_SHIFT\t0\n#define EMC_MRS_WAIT_CNT_SHORT_WAIT_MASK\t\\\n\t(0x3FF << EMC_MRS_WAIT_CNT_SHORT_WAIT_SHIFT)\n#define EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT\t16\n#define EMC_MRS_WAIT_CNT_LONG_WAIT_MASK\t\t\\\n\t(0x3FF << EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT)\n\n#define EMC_MRS\t\t\t\t\t0xcc\n#define EMC_MODE_SET_DLL_RESET\t\t\tBIT(8)\n#define EMC_MODE_SET_LONG_CNT\t\t\tBIT(26)\n#define EMC_EMRS\t\t\t\t0xd0\n#define EMC_REF\t\t\t\t\t0xd4\n#define EMC_PRE\t\t\t\t\t0xd8\n\n#define EMC_SELF_REF\t\t\t\t0xe0\n#define EMC_SELF_REF_CMD_ENABLED\t\tBIT(0)\n#define EMC_SELF_REF_DEV_SEL_SHIFT\t\t30\n\n#define EMC_MRW\t\t\t\t\t0xe8\n\n#define EMC_MRR\t\t\t\t\t0xec\n#define EMC_MRR_MA_SHIFT\t\t\t16\n#define LPDDR2_MR4_TEMP_SHIFT\t\t\t0\n\n#define EMC_XM2DQSPADCTRL3\t\t\t0xf8\n#define EMC_FBIO_SPARE\t\t\t\t0x100\n\n#define EMC_FBIO_CFG6\t\t\t\t0x114\n#define EMC_EMRS2\t\t\t\t0x12c\n#define EMC_MRW2\t\t\t\t0x134\n#define EMC_MRW4\t\t\t\t0x13c\n#define EMC_EINPUT\t\t\t\t0x14c\n#define EMC_EINPUT_DURATION\t\t\t0x150\n#define EMC_PUTERM_EXTRA\t\t\t0x154\n#define EMC_TCKESR\t\t\t\t0x158\n#define EMC_TPD\t\t\t\t\t0x15c\n\n#define EMC_AUTO_CAL_CONFIG\t\t\t0x2a4\n#define EMC_AUTO_CAL_CONFIG_AUTO_CAL_START\tBIT(31)\n#define EMC_AUTO_CAL_INTERVAL\t\t\t0x2a8\n#define EMC_AUTO_CAL_STATUS\t\t\t0x2ac\n#define EMC_AUTO_CAL_STATUS_ACTIVE\t\tBIT(31)\n#define EMC_STATUS\t\t\t\t0x2b4\n#define EMC_STATUS_TIMING_UPDATE_STALLED\tBIT(23)\n\n#define EMC_CFG_2\t\t\t\t0x2b8\n#define EMC_CFG_2_MODE_SHIFT\t\t\t0\n#define EMC_CFG_2_DIS_STP_OB_CLK_DURING_NON_WR\tBIT(6)\n\n#define EMC_CFG_DIG_DLL\t\t\t\t0x2bc\n#define EMC_CFG_DIG_DLL_PERIOD\t\t\t0x2c0\n#define EMC_RDV_MASK\t\t\t\t0x2cc\n#define EMC_WDV_MASK\t\t\t\t0x2d0\n#define EMC_CTT_DURATION\t\t\t0x2d8\n#define EMC_CTT_TERM_CTRL\t\t\t0x2dc\n#define EMC_ZCAL_INTERVAL\t\t\t0x2e0\n#define EMC_ZCAL_WAIT_CNT\t\t\t0x2e4\n\n#define EMC_ZQ_CAL\t\t\t\t0x2ec\n#define EMC_ZQ_CAL_CMD\t\t\t\tBIT(0)\n#define EMC_ZQ_CAL_LONG\t\t\t\tBIT(4)\n#define EMC_ZQ_CAL_LONG_CMD_DEV0\t\t\\\n\t(DRAM_DEV_SEL_0 | EMC_ZQ_CAL_LONG | EMC_ZQ_CAL_CMD)\n#define EMC_ZQ_CAL_LONG_CMD_DEV1\t\t\\\n\t(DRAM_DEV_SEL_1 | EMC_ZQ_CAL_LONG | EMC_ZQ_CAL_CMD)\n\n#define EMC_XM2CMDPADCTRL\t\t\t0x2f0\n#define EMC_XM2DQSPADCTRL\t\t\t0x2f8\n#define EMC_XM2DQSPADCTRL2\t\t\t0x2fc\n#define EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE\tBIT(0)\n#define EMC_XM2DQSPADCTRL2_VREF_ENABLE\t\tBIT(5)\n#define EMC_XM2DQPADCTRL\t\t\t0x300\n#define EMC_XM2DQPADCTRL2\t\t\t0x304\n#define EMC_XM2CLKPADCTRL\t\t\t0x308\n#define EMC_XM2COMPPADCTRL\t\t\t0x30c\n#define EMC_XM2VTTGENPADCTRL\t\t\t0x310\n#define EMC_XM2VTTGENPADCTRL2\t\t\t0x314\n#define EMC_XM2VTTGENPADCTRL3\t\t\t0x318\n#define EMC_XM2DQSPADCTRL4\t\t\t0x320\n#define EMC_DLL_XFORM_DQS0\t\t\t0x328\n#define EMC_DLL_XFORM_DQS1\t\t\t0x32c\n#define EMC_DLL_XFORM_DQS2\t\t\t0x330\n#define EMC_DLL_XFORM_DQS3\t\t\t0x334\n#define EMC_DLL_XFORM_DQS4\t\t\t0x338\n#define EMC_DLL_XFORM_DQS5\t\t\t0x33c\n#define EMC_DLL_XFORM_DQS6\t\t\t0x340\n#define EMC_DLL_XFORM_DQS7\t\t\t0x344\n#define EMC_DLL_XFORM_QUSE0\t\t\t0x348\n#define EMC_DLL_XFORM_QUSE1\t\t\t0x34c\n#define EMC_DLL_XFORM_QUSE2\t\t\t0x350\n#define EMC_DLL_XFORM_QUSE3\t\t\t0x354\n#define EMC_DLL_XFORM_QUSE4\t\t\t0x358\n#define EMC_DLL_XFORM_QUSE5\t\t\t0x35c\n#define EMC_DLL_XFORM_QUSE6\t\t\t0x360\n#define EMC_DLL_XFORM_QUSE7\t\t\t0x364\n#define EMC_DLL_XFORM_DQ0\t\t\t0x368\n#define EMC_DLL_XFORM_DQ1\t\t\t0x36c\n#define EMC_DLL_XFORM_DQ2\t\t\t0x370\n#define EMC_DLL_XFORM_DQ3\t\t\t0x374\n#define EMC_DLI_TRIM_TXDQS0\t\t\t0x3a8\n#define EMC_DLI_TRIM_TXDQS1\t\t\t0x3ac\n#define EMC_DLI_TRIM_TXDQS2\t\t\t0x3b0\n#define EMC_DLI_TRIM_TXDQS3\t\t\t0x3b4\n#define EMC_DLI_TRIM_TXDQS4\t\t\t0x3b8\n#define EMC_DLI_TRIM_TXDQS5\t\t\t0x3bc\n#define EMC_DLI_TRIM_TXDQS6\t\t\t0x3c0\n#define EMC_DLI_TRIM_TXDQS7\t\t\t0x3c4\n#define EMC_STALL_THEN_EXE_AFTER_CLKCHANGE\t0x3cc\n#define EMC_SEL_DPD_CTRL\t\t\t0x3d8\n#define EMC_SEL_DPD_CTRL_DATA_SEL_DPD\t\tBIT(8)\n#define EMC_SEL_DPD_CTRL_ODT_SEL_DPD\t\tBIT(5)\n#define EMC_SEL_DPD_CTRL_RESET_SEL_DPD\t\tBIT(4)\n#define EMC_SEL_DPD_CTRL_CA_SEL_DPD\t\tBIT(3)\n#define EMC_SEL_DPD_CTRL_CLK_SEL_DPD\t\tBIT(2)\n#define EMC_SEL_DPD_CTRL_DDR3_MASK\t\\\n\t((0xf << 2) | BIT(8))\n#define EMC_SEL_DPD_CTRL_MASK \\\n\t((0x3 << 2) | BIT(5) | BIT(8))\n#define EMC_PRE_REFRESH_REQ_CNT\t\t\t0x3dc\n#define EMC_DYN_SELF_REF_CONTROL\t\t0x3e0\n#define EMC_TXSRDLL\t\t\t\t0x3e4\n#define EMC_CCFIFO_ADDR\t\t\t\t0x3e8\n#define EMC_CCFIFO_DATA\t\t\t\t0x3ec\n#define EMC_CCFIFO_STATUS\t\t\t0x3f0\n#define EMC_CDB_CNTL_1\t\t\t\t0x3f4\n#define EMC_CDB_CNTL_2\t\t\t\t0x3f8\n#define EMC_XM2CLKPADCTRL2\t\t\t0x3fc\n#define EMC_AUTO_CAL_CONFIG2\t\t\t0x458\n#define EMC_AUTO_CAL_CONFIG3\t\t\t0x45c\n#define EMC_IBDLY\t\t\t\t0x468\n#define EMC_DLL_XFORM_ADDR0\t\t\t0x46c\n#define EMC_DLL_XFORM_ADDR1\t\t\t0x470\n#define EMC_DLL_XFORM_ADDR2\t\t\t0x474\n#define EMC_DSR_VTTGEN_DRV\t\t\t0x47c\n#define EMC_TXDSRVTTGEN\t\t\t\t0x480\n#define EMC_XM2CMDPADCTRL4\t\t\t0x484\n#define EMC_XM2CMDPADCTRL5\t\t\t0x488\n#define EMC_DLL_XFORM_DQS8\t\t\t0x4a0\n#define EMC_DLL_XFORM_DQS9\t\t\t0x4a4\n#define EMC_DLL_XFORM_DQS10\t\t\t0x4a8\n#define EMC_DLL_XFORM_DQS11\t\t\t0x4ac\n#define EMC_DLL_XFORM_DQS12\t\t\t0x4b0\n#define EMC_DLL_XFORM_DQS13\t\t\t0x4b4\n#define EMC_DLL_XFORM_DQS14\t\t\t0x4b8\n#define EMC_DLL_XFORM_DQS15\t\t\t0x4bc\n#define EMC_DLL_XFORM_QUSE8\t\t\t0x4c0\n#define EMC_DLL_XFORM_QUSE9\t\t\t0x4c4\n#define EMC_DLL_XFORM_QUSE10\t\t\t0x4c8\n#define EMC_DLL_XFORM_QUSE11\t\t\t0x4cc\n#define EMC_DLL_XFORM_QUSE12\t\t\t0x4d0\n#define EMC_DLL_XFORM_QUSE13\t\t\t0x4d4\n#define EMC_DLL_XFORM_QUSE14\t\t\t0x4d8\n#define EMC_DLL_XFORM_QUSE15\t\t\t0x4dc\n#define EMC_DLL_XFORM_DQ4\t\t\t0x4e0\n#define EMC_DLL_XFORM_DQ5\t\t\t0x4e4\n#define EMC_DLL_XFORM_DQ6\t\t\t0x4e8\n#define EMC_DLL_XFORM_DQ7\t\t\t0x4ec\n#define EMC_DLI_TRIM_TXDQS8\t\t\t0x520\n#define EMC_DLI_TRIM_TXDQS9\t\t\t0x524\n#define EMC_DLI_TRIM_TXDQS10\t\t\t0x528\n#define EMC_DLI_TRIM_TXDQS11\t\t\t0x52c\n#define EMC_DLI_TRIM_TXDQS12\t\t\t0x530\n#define EMC_DLI_TRIM_TXDQS13\t\t\t0x534\n#define EMC_DLI_TRIM_TXDQS14\t\t\t0x538\n#define EMC_DLI_TRIM_TXDQS15\t\t\t0x53c\n#define EMC_CDB_CNTL_3\t\t\t\t0x540\n#define EMC_XM2DQSPADCTRL5\t\t\t0x544\n#define EMC_XM2DQSPADCTRL6\t\t\t0x548\n#define EMC_XM2DQPADCTRL3\t\t\t0x54c\n#define EMC_DLL_XFORM_ADDR3\t\t\t0x550\n#define EMC_DLL_XFORM_ADDR4\t\t\t0x554\n#define EMC_DLL_XFORM_ADDR5\t\t\t0x558\n#define EMC_CFG_PIPE\t\t\t\t0x560\n#define EMC_QPOP\t\t\t\t0x564\n#define EMC_QUSE_WIDTH\t\t\t\t0x568\n#define EMC_PUTERM_WIDTH\t\t\t0x56c\n#define EMC_BGBIAS_CTL0\t\t\t\t0x570\n#define EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX BIT(3)\n#define EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_VTTGEN BIT(2)\n#define EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD\tBIT(1)\n#define EMC_PUTERM_ADJ\t\t\t\t0x574\n\n#define DRAM_DEV_SEL_ALL\t\t\t0\n#define DRAM_DEV_SEL_0\t\t\t\tBIT(31)\n#define DRAM_DEV_SEL_1\t\t\t\tBIT(30)\n\n#define EMC_CFG_POWER_FEATURES_MASK\t\t\\\n\t(EMC_CFG_DYN_SREF | EMC_CFG_DRAM_ACPD | EMC_CFG_DRAM_CLKSTOP_SR | \\\n\tEMC_CFG_DRAM_CLKSTOP_PD | EMC_CFG_DSR_VTTGEN_DRV_EN)\n#define EMC_REFCTRL_DEV_SEL(n) (((n > 1) ? 0 : 2) << EMC_REFCTRL_DEV_SEL_SHIFT)\n#define EMC_DRAM_DEV_SEL(n) ((n > 1) ? DRAM_DEV_SEL_ALL : DRAM_DEV_SEL_0)\n\n \n#define EMC_STATUS_UPDATE_TIMEOUT\t\t1000\n\nenum emc_dram_type {\n\tDRAM_TYPE_DDR3 = 0,\n\tDRAM_TYPE_DDR1 = 1,\n\tDRAM_TYPE_LPDDR3 = 2,\n\tDRAM_TYPE_DDR2 = 3\n};\n\nenum emc_dll_change {\n\tDLL_CHANGE_NONE,\n\tDLL_CHANGE_ON,\n\tDLL_CHANGE_OFF\n};\n\nstatic const unsigned long emc_burst_regs[] = {\n\tEMC_RC,\n\tEMC_RFC,\n\tEMC_RFC_SLR,\n\tEMC_RAS,\n\tEMC_RP,\n\tEMC_R2W,\n\tEMC_W2R,\n\tEMC_R2P,\n\tEMC_W2P,\n\tEMC_RD_RCD,\n\tEMC_WR_RCD,\n\tEMC_RRD,\n\tEMC_REXT,\n\tEMC_WEXT,\n\tEMC_WDV,\n\tEMC_WDV_MASK,\n\tEMC_QUSE,\n\tEMC_QUSE_WIDTH,\n\tEMC_IBDLY,\n\tEMC_EINPUT,\n\tEMC_EINPUT_DURATION,\n\tEMC_PUTERM_EXTRA,\n\tEMC_PUTERM_WIDTH,\n\tEMC_PUTERM_ADJ,\n\tEMC_CDB_CNTL_1,\n\tEMC_CDB_CNTL_2,\n\tEMC_CDB_CNTL_3,\n\tEMC_QRST,\n\tEMC_QSAFE,\n\tEMC_RDV,\n\tEMC_RDV_MASK,\n\tEMC_REFRESH,\n\tEMC_BURST_REFRESH_NUM,\n\tEMC_PRE_REFRESH_REQ_CNT,\n\tEMC_PDEX2WR,\n\tEMC_PDEX2RD,\n\tEMC_PCHG2PDEN,\n\tEMC_ACT2PDEN,\n\tEMC_AR2PDEN,\n\tEMC_RW2PDEN,\n\tEMC_TXSR,\n\tEMC_TXSRDLL,\n\tEMC_TCKE,\n\tEMC_TCKESR,\n\tEMC_TPD,\n\tEMC_TFAW,\n\tEMC_TRPAB,\n\tEMC_TCLKSTABLE,\n\tEMC_TCLKSTOP,\n\tEMC_TREFBW,\n\tEMC_FBIO_CFG6,\n\tEMC_ODT_WRITE,\n\tEMC_ODT_READ,\n\tEMC_FBIO_CFG5,\n\tEMC_CFG_DIG_DLL,\n\tEMC_CFG_DIG_DLL_PERIOD,\n\tEMC_DLL_XFORM_DQS0,\n\tEMC_DLL_XFORM_DQS1,\n\tEMC_DLL_XFORM_DQS2,\n\tEMC_DLL_XFORM_DQS3,\n\tEMC_DLL_XFORM_DQS4,\n\tEMC_DLL_XFORM_DQS5,\n\tEMC_DLL_XFORM_DQS6,\n\tEMC_DLL_XFORM_DQS7,\n\tEMC_DLL_XFORM_DQS8,\n\tEMC_DLL_XFORM_DQS9,\n\tEMC_DLL_XFORM_DQS10,\n\tEMC_DLL_XFORM_DQS11,\n\tEMC_DLL_XFORM_DQS12,\n\tEMC_DLL_XFORM_DQS13,\n\tEMC_DLL_XFORM_DQS14,\n\tEMC_DLL_XFORM_DQS15,\n\tEMC_DLL_XFORM_QUSE0,\n\tEMC_DLL_XFORM_QUSE1,\n\tEMC_DLL_XFORM_QUSE2,\n\tEMC_DLL_XFORM_QUSE3,\n\tEMC_DLL_XFORM_QUSE4,\n\tEMC_DLL_XFORM_QUSE5,\n\tEMC_DLL_XFORM_QUSE6,\n\tEMC_DLL_XFORM_QUSE7,\n\tEMC_DLL_XFORM_ADDR0,\n\tEMC_DLL_XFORM_ADDR1,\n\tEMC_DLL_XFORM_ADDR2,\n\tEMC_DLL_XFORM_ADDR3,\n\tEMC_DLL_XFORM_ADDR4,\n\tEMC_DLL_XFORM_ADDR5,\n\tEMC_DLL_XFORM_QUSE8,\n\tEMC_DLL_XFORM_QUSE9,\n\tEMC_DLL_XFORM_QUSE10,\n\tEMC_DLL_XFORM_QUSE11,\n\tEMC_DLL_XFORM_QUSE12,\n\tEMC_DLL_XFORM_QUSE13,\n\tEMC_DLL_XFORM_QUSE14,\n\tEMC_DLL_XFORM_QUSE15,\n\tEMC_DLI_TRIM_TXDQS0,\n\tEMC_DLI_TRIM_TXDQS1,\n\tEMC_DLI_TRIM_TXDQS2,\n\tEMC_DLI_TRIM_TXDQS3,\n\tEMC_DLI_TRIM_TXDQS4,\n\tEMC_DLI_TRIM_TXDQS5,\n\tEMC_DLI_TRIM_TXDQS6,\n\tEMC_DLI_TRIM_TXDQS7,\n\tEMC_DLI_TRIM_TXDQS8,\n\tEMC_DLI_TRIM_TXDQS9,\n\tEMC_DLI_TRIM_TXDQS10,\n\tEMC_DLI_TRIM_TXDQS11,\n\tEMC_DLI_TRIM_TXDQS12,\n\tEMC_DLI_TRIM_TXDQS13,\n\tEMC_DLI_TRIM_TXDQS14,\n\tEMC_DLI_TRIM_TXDQS15,\n\tEMC_DLL_XFORM_DQ0,\n\tEMC_DLL_XFORM_DQ1,\n\tEMC_DLL_XFORM_DQ2,\n\tEMC_DLL_XFORM_DQ3,\n\tEMC_DLL_XFORM_DQ4,\n\tEMC_DLL_XFORM_DQ5,\n\tEMC_DLL_XFORM_DQ6,\n\tEMC_DLL_XFORM_DQ7,\n\tEMC_XM2CMDPADCTRL,\n\tEMC_XM2CMDPADCTRL4,\n\tEMC_XM2CMDPADCTRL5,\n\tEMC_XM2DQPADCTRL2,\n\tEMC_XM2DQPADCTRL3,\n\tEMC_XM2CLKPADCTRL,\n\tEMC_XM2CLKPADCTRL2,\n\tEMC_XM2COMPPADCTRL,\n\tEMC_XM2VTTGENPADCTRL,\n\tEMC_XM2VTTGENPADCTRL2,\n\tEMC_XM2VTTGENPADCTRL3,\n\tEMC_XM2DQSPADCTRL3,\n\tEMC_XM2DQSPADCTRL4,\n\tEMC_XM2DQSPADCTRL5,\n\tEMC_XM2DQSPADCTRL6,\n\tEMC_DSR_VTTGEN_DRV,\n\tEMC_TXDSRVTTGEN,\n\tEMC_FBIO_SPARE,\n\tEMC_ZCAL_WAIT_CNT,\n\tEMC_MRS_WAIT_CNT2,\n\tEMC_CTT,\n\tEMC_CTT_DURATION,\n\tEMC_CFG_PIPE,\n\tEMC_DYN_SELF_REF_CONTROL,\n\tEMC_QPOP\n};\n\nstruct emc_timing {\n\tunsigned long rate;\n\n\tu32 emc_burst_data[ARRAY_SIZE(emc_burst_regs)];\n\n\tu32 emc_auto_cal_config;\n\tu32 emc_auto_cal_config2;\n\tu32 emc_auto_cal_config3;\n\tu32 emc_auto_cal_interval;\n\tu32 emc_bgbias_ctl0;\n\tu32 emc_cfg;\n\tu32 emc_cfg_2;\n\tu32 emc_ctt_term_ctrl;\n\tu32 emc_mode_1;\n\tu32 emc_mode_2;\n\tu32 emc_mode_4;\n\tu32 emc_mode_reset;\n\tu32 emc_mrs_wait_cnt;\n\tu32 emc_sel_dpd_ctrl;\n\tu32 emc_xm2dqspadctrl2;\n\tu32 emc_zcal_cnt_long;\n\tu32 emc_zcal_interval;\n};\n\nenum emc_rate_request_type {\n\tEMC_RATE_DEBUG,\n\tEMC_RATE_ICC,\n\tEMC_RATE_TYPE_MAX,\n};\n\nstruct emc_rate_request {\n\tunsigned long min_rate;\n\tunsigned long max_rate;\n};\n\nstruct tegra_emc {\n\tstruct device *dev;\n\n\tstruct tegra_mc *mc;\n\n\tvoid __iomem *regs;\n\n\tstruct clk *clk;\n\n\tenum emc_dram_type dram_type;\n\tunsigned int dram_bus_width;\n\tunsigned int dram_num;\n\n\tstruct emc_timing last_timing;\n\tstruct emc_timing *timings;\n\tunsigned int num_timings;\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tunsigned long min_rate;\n\t\tunsigned long max_rate;\n\t} debugfs;\n\n\tstruct icc_provider provider;\n\n\t \n\tstruct emc_rate_request requested_rate[EMC_RATE_TYPE_MAX];\n\n\t \n\tstruct mutex rate_lock;\n};\n\n \n\nstatic void emc_ccfifo_writel(struct tegra_emc *emc, u32 value,\n\t\t\t      unsigned long offset)\n{\n\twritel(value, emc->regs + EMC_CCFIFO_DATA);\n\twritel(offset, emc->regs + EMC_CCFIFO_ADDR);\n}\n\nstatic void emc_seq_update_timing(struct tegra_emc *emc)\n{\n\tunsigned int i;\n\tu32 value;\n\n\twritel(1, emc->regs + EMC_TIMING_CONTROL);\n\n\tfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; ++i) {\n\t\tvalue = readl(emc->regs + EMC_STATUS);\n\t\tif ((value & EMC_STATUS_TIMING_UPDATE_STALLED) == 0)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\n\tdev_err(emc->dev, \"timing update timed out\\n\");\n}\n\nstatic void emc_seq_disable_auto_cal(struct tegra_emc *emc)\n{\n\tunsigned int i;\n\tu32 value;\n\n\twritel(0, emc->regs + EMC_AUTO_CAL_INTERVAL);\n\n\tfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; ++i) {\n\t\tvalue = readl(emc->regs + EMC_AUTO_CAL_STATUS);\n\t\tif ((value & EMC_AUTO_CAL_STATUS_ACTIVE) == 0)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\n\tdev_err(emc->dev, \"auto cal disable timed out\\n\");\n}\n\nstatic void emc_seq_wait_clkchange(struct tegra_emc *emc)\n{\n\tunsigned int i;\n\tu32 value;\n\n\tfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; ++i) {\n\t\tvalue = readl(emc->regs + EMC_INTSTATUS);\n\t\tif (value & EMC_INTSTATUS_CLKCHANGE_COMPLETE)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\n\tdev_err(emc->dev, \"clock change timed out\\n\");\n}\n\nstatic struct emc_timing *tegra_emc_find_timing(struct tegra_emc *emc,\n\t\t\t\t\t\tunsigned long rate)\n{\n\tstruct emc_timing *timing = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate == rate) {\n\t\t\ttiming = &emc->timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timing) {\n\t\tdev_err(emc->dev, \"no timing for rate %lu\\n\", rate);\n\t\treturn NULL;\n\t}\n\n\treturn timing;\n}\n\nstatic int tegra_emc_prepare_timing_change(struct tegra_emc *emc,\n\t\t\t\t\t   unsigned long rate)\n{\n\tstruct emc_timing *timing = tegra_emc_find_timing(emc, rate);\n\tstruct emc_timing *last = &emc->last_timing;\n\tenum emc_dll_change dll_change;\n\tunsigned int pre_wait = 0;\n\tu32 val, val2, mask;\n\tbool update = false;\n\tunsigned int i;\n\n\tif (!timing)\n\t\treturn -ENOENT;\n\n\tif ((last->emc_mode_1 & 0x1) == (timing->emc_mode_1 & 0x1))\n\t\tdll_change = DLL_CHANGE_NONE;\n\telse if (timing->emc_mode_1 & 0x1)\n\t\tdll_change = DLL_CHANGE_ON;\n\telse\n\t\tdll_change = DLL_CHANGE_OFF;\n\n\t \n\twritel(EMC_INTSTATUS_CLKCHANGE_COMPLETE, emc->regs + EMC_INTSTATUS);\n\n\t \n\tval = readl(emc->regs + EMC_CFG);\n\tif (val & EMC_CFG_PWR_MASK) {\n\t\tval &= ~EMC_CFG_POWER_FEATURES_MASK;\n\t\twritel(val, emc->regs + EMC_CFG);\n\n\t\tpre_wait = 5;\n\t}\n\n\t \n\tif (emc->dram_type == DRAM_TYPE_DDR3)\n\t\tmask = EMC_SEL_DPD_CTRL_DDR3_MASK;\n\telse\n\t\tmask = EMC_SEL_DPD_CTRL_MASK;\n\n\tval = readl(emc->regs + EMC_SEL_DPD_CTRL);\n\tif (val & mask) {\n\t\tval &= ~mask;\n\t\twritel(val, emc->regs + EMC_SEL_DPD_CTRL);\n\t}\n\n\t \n\tval = readl(emc->regs + EMC_BGBIAS_CTL0);\n\tval2 = last->emc_bgbias_ctl0;\n\tif (!(timing->emc_bgbias_ctl0 &\n\t      EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX) &&\n\t    (val & EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX)) {\n\t\tval2 &= ~EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX;\n\t\tupdate = true;\n\t}\n\n\tif ((val & EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD) ||\n\t    (val & EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_VTTGEN)) {\n\t\tupdate = true;\n\t}\n\n\tif (update) {\n\t\twritel(val2, emc->regs + EMC_BGBIAS_CTL0);\n\t\tif (pre_wait < 5)\n\t\t\tpre_wait = 5;\n\t}\n\n\tupdate = false;\n\tval = readl(emc->regs + EMC_XM2DQSPADCTRL2);\n\tif (timing->emc_xm2dqspadctrl2 & EMC_XM2DQSPADCTRL2_VREF_ENABLE &&\n\t    !(val & EMC_XM2DQSPADCTRL2_VREF_ENABLE)) {\n\t\tval |= EMC_XM2DQSPADCTRL2_VREF_ENABLE;\n\t\tupdate = true;\n\t}\n\n\tif (timing->emc_xm2dqspadctrl2 & EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE &&\n\t    !(val & EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE)) {\n\t\tval |= EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE;\n\t\tupdate = true;\n\t}\n\n\tif (update) {\n\t\twritel(val, emc->regs + EMC_XM2DQSPADCTRL2);\n\t\tif (pre_wait < 30)\n\t\t\tpre_wait = 30;\n\t}\n\n\t \n\tif (pre_wait) {\n\t\temc_seq_update_timing(emc);\n\t\tudelay(pre_wait);\n\t}\n\n\t \n\tif (last->emc_ctt_term_ctrl != timing->emc_ctt_term_ctrl) {\n\t\temc_seq_disable_auto_cal(emc);\n\t\twritel(timing->emc_ctt_term_ctrl,\n\t\t       emc->regs + EMC_CTT_TERM_CTRL);\n\t\temc_seq_update_timing(emc);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(timing->emc_burst_data); ++i)\n\t\twritel(timing->emc_burst_data[i],\n\t\t       emc->regs + emc_burst_regs[i]);\n\n\twritel(timing->emc_xm2dqspadctrl2, emc->regs + EMC_XM2DQSPADCTRL2);\n\twritel(timing->emc_zcal_interval, emc->regs + EMC_ZCAL_INTERVAL);\n\n\ttegra_mc_write_emem_configuration(emc->mc, timing->rate);\n\n\tval = timing->emc_cfg & ~EMC_CFG_POWER_FEATURES_MASK;\n\temc_ccfifo_writel(emc, val, EMC_CFG);\n\n\t \n\tif (timing->emc_auto_cal_config2 != last->emc_auto_cal_config2)\n\t\temc_ccfifo_writel(emc, timing->emc_auto_cal_config2,\n\t\t\t\t  EMC_AUTO_CAL_CONFIG2);\n\n\tif (timing->emc_auto_cal_config3 != last->emc_auto_cal_config3)\n\t\temc_ccfifo_writel(emc, timing->emc_auto_cal_config3,\n\t\t\t\t  EMC_AUTO_CAL_CONFIG3);\n\n\tif (timing->emc_auto_cal_config != last->emc_auto_cal_config) {\n\t\tval = timing->emc_auto_cal_config;\n\t\tval &= EMC_AUTO_CAL_CONFIG_AUTO_CAL_START;\n\t\temc_ccfifo_writel(emc, val, EMC_AUTO_CAL_CONFIG);\n\t}\n\n\t \n\tif (emc->dram_type == DRAM_TYPE_DDR3 &&\n\t    dll_change == DLL_CHANGE_ON) {\n\t\tu32 cnt = 512;\n\n\t\tif (timing->emc_zcal_interval != 0 &&\n\t\t    last->emc_zcal_interval == 0)\n\t\t\tcnt -= emc->dram_num * 256;\n\n\t\tval = (timing->emc_mrs_wait_cnt\n\t\t\t& EMC_MRS_WAIT_CNT_SHORT_WAIT_MASK)\n\t\t\t>> EMC_MRS_WAIT_CNT_SHORT_WAIT_SHIFT;\n\t\tif (cnt < val)\n\t\t\tcnt = val;\n\n\t\tval = timing->emc_mrs_wait_cnt\n\t\t\t& ~EMC_MRS_WAIT_CNT_LONG_WAIT_MASK;\n\t\tval |= (cnt << EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT)\n\t\t\t& EMC_MRS_WAIT_CNT_LONG_WAIT_MASK;\n\n\t\twritel(val, emc->regs + EMC_MRS_WAIT_CNT);\n\t}\n\n\tval = timing->emc_cfg_2;\n\tval &= ~EMC_CFG_2_DIS_STP_OB_CLK_DURING_NON_WR;\n\temc_ccfifo_writel(emc, val, EMC_CFG_2);\n\n\t \n\tif (emc->dram_type == DRAM_TYPE_DDR3 && dll_change == DLL_CHANGE_OFF)\n\t\temc_ccfifo_writel(emc, timing->emc_mode_1, EMC_EMRS);\n\n\t \n\temc_ccfifo_writel(emc, EMC_REFCTRL_DEV_SEL(emc->dram_num),\n\t\t\t  EMC_REFCTRL);\n\tif (emc->dram_type == DRAM_TYPE_DDR3)\n\t\temc_ccfifo_writel(emc, EMC_DRAM_DEV_SEL(emc->dram_num) |\n\t\t\t\t       EMC_SELF_REF_CMD_ENABLED,\n\t\t\t\t  EMC_SELF_REF);\n\n\t \n\temc_ccfifo_writel(emc, 1, EMC_STALL_THEN_EXE_AFTER_CLKCHANGE);\n\n\t \n\tif (emc->dram_type == DRAM_TYPE_DDR3)\n\t\temc_ccfifo_writel(emc, EMC_DRAM_DEV_SEL(emc->dram_num),\n\t\t\t\t  EMC_SELF_REF);\n\temc_ccfifo_writel(emc, EMC_REFCTRL_DEV_SEL(emc->dram_num) |\n\t\t\t       EMC_REFCTRL_ENABLE,\n\t\t\t  EMC_REFCTRL);\n\n\t \n\tif (emc->dram_type == DRAM_TYPE_DDR3) {\n\t\tif (timing->emc_mode_1 != last->emc_mode_1)\n\t\t\temc_ccfifo_writel(emc, timing->emc_mode_1, EMC_EMRS);\n\t\tif (timing->emc_mode_2 != last->emc_mode_2)\n\t\t\temc_ccfifo_writel(emc, timing->emc_mode_2, EMC_EMRS2);\n\n\t\tif ((timing->emc_mode_reset != last->emc_mode_reset) ||\n\t\t    dll_change == DLL_CHANGE_ON) {\n\t\t\tval = timing->emc_mode_reset;\n\t\t\tif (dll_change == DLL_CHANGE_ON) {\n\t\t\t\tval |= EMC_MODE_SET_DLL_RESET;\n\t\t\t\tval |= EMC_MODE_SET_LONG_CNT;\n\t\t\t} else {\n\t\t\t\tval &= ~EMC_MODE_SET_DLL_RESET;\n\t\t\t}\n\t\t\temc_ccfifo_writel(emc, val, EMC_MRS);\n\t\t}\n\t} else {\n\t\tif (timing->emc_mode_2 != last->emc_mode_2)\n\t\t\temc_ccfifo_writel(emc, timing->emc_mode_2, EMC_MRW2);\n\t\tif (timing->emc_mode_1 != last->emc_mode_1)\n\t\t\temc_ccfifo_writel(emc, timing->emc_mode_1, EMC_MRW);\n\t\tif (timing->emc_mode_4 != last->emc_mode_4)\n\t\t\temc_ccfifo_writel(emc, timing->emc_mode_4, EMC_MRW4);\n\t}\n\n\t \n\tif (timing->emc_zcal_interval != 0 && last->emc_zcal_interval == 0) {\n\t\temc_ccfifo_writel(emc, EMC_ZQ_CAL_LONG_CMD_DEV0, EMC_ZQ_CAL);\n\t\tif (emc->dram_num > 1)\n\t\t\temc_ccfifo_writel(emc, EMC_ZQ_CAL_LONG_CMD_DEV1,\n\t\t\t\t\t  EMC_ZQ_CAL);\n\t}\n\n\t \n\temc_ccfifo_writel(emc, 0, EMC_CCFIFO_STATUS);\n\n\tif (timing->emc_cfg_2 & EMC_CFG_2_DIS_STP_OB_CLK_DURING_NON_WR)\n\t\temc_ccfifo_writel(emc, timing->emc_cfg_2, EMC_CFG_2);\n\n\t \n\temc_seq_disable_auto_cal(emc);\n\n\t \n\treadl(emc->regs + EMC_INTSTATUS);\n\n\treturn 0;\n}\n\nstatic void tegra_emc_complete_timing_change(struct tegra_emc *emc,\n\t\t\t\t\t     unsigned long rate)\n{\n\tstruct emc_timing *timing = tegra_emc_find_timing(emc, rate);\n\tstruct emc_timing *last = &emc->last_timing;\n\tu32 val;\n\n\tif (!timing)\n\t\treturn;\n\n\t \n\temc_seq_wait_clkchange(emc);\n\n\t \n\tif (timing->emc_ctt_term_ctrl != last->emc_ctt_term_ctrl)\n\t\twritel(timing->emc_auto_cal_interval,\n\t\t       emc->regs + EMC_AUTO_CAL_INTERVAL);\n\n\t \n\tif (timing->emc_cfg & EMC_CFG_PWR_MASK)\n\t\twritel(timing->emc_cfg, emc->regs + EMC_CFG);\n\n\t \n\twritel(timing->emc_zcal_cnt_long, emc->regs + EMC_ZCAL_WAIT_CNT);\n\n\t \n\tif (emc->dram_type == DRAM_TYPE_LPDDR3 &&\n\t    timing->emc_bgbias_ctl0 &\n\t      EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX) {\n\t\tval = timing->emc_bgbias_ctl0;\n\t\tval |= EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_VTTGEN;\n\t\tval |= EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD;\n\t\twritel(val, emc->regs + EMC_BGBIAS_CTL0);\n\t} else {\n\t\tif (emc->dram_type == DRAM_TYPE_DDR3 &&\n\t\t    readl(emc->regs + EMC_BGBIAS_CTL0) !=\n\t\t      timing->emc_bgbias_ctl0) {\n\t\t\twritel(timing->emc_bgbias_ctl0,\n\t\t\t       emc->regs + EMC_BGBIAS_CTL0);\n\t\t}\n\n\t\twritel(timing->emc_auto_cal_interval,\n\t\t       emc->regs + EMC_AUTO_CAL_INTERVAL);\n\t}\n\n\t \n\tudelay(2);\n\n\t \n\twritel(timing->emc_sel_dpd_ctrl, emc->regs + EMC_SEL_DPD_CTRL);\n\temc_seq_update_timing(emc);\n\n\temc->last_timing = *timing;\n}\n\n \n\nstatic void emc_read_current_timing(struct tegra_emc *emc,\n\t\t\t\t    struct emc_timing *timing)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(emc_burst_regs); ++i)\n\t\ttiming->emc_burst_data[i] =\n\t\t\treadl(emc->regs + emc_burst_regs[i]);\n\n\ttiming->emc_cfg = readl(emc->regs + EMC_CFG);\n\n\ttiming->emc_auto_cal_interval = 0;\n\ttiming->emc_zcal_cnt_long = 0;\n\ttiming->emc_mode_1 = 0;\n\ttiming->emc_mode_2 = 0;\n\ttiming->emc_mode_4 = 0;\n\ttiming->emc_mode_reset = 0;\n}\n\nstatic int emc_init(struct tegra_emc *emc)\n{\n\temc->dram_type = readl(emc->regs + EMC_FBIO_CFG5);\n\n\tif (emc->dram_type & EMC_FBIO_CFG5_DRAM_WIDTH_X64)\n\t\temc->dram_bus_width = 64;\n\telse\n\t\temc->dram_bus_width = 32;\n\n\tdev_info_once(emc->dev, \"%ubit DRAM bus\\n\", emc->dram_bus_width);\n\n\temc->dram_type &= EMC_FBIO_CFG5_DRAM_TYPE_MASK;\n\temc->dram_type >>= EMC_FBIO_CFG5_DRAM_TYPE_SHIFT;\n\n\temc->dram_num = tegra_mc_get_emem_device_count(emc->mc);\n\n\temc_read_current_timing(emc, &emc->last_timing);\n\n\treturn 0;\n}\n\nstatic int load_one_timing_from_dt(struct tegra_emc *emc,\n\t\t\t\t   struct emc_timing *timing,\n\t\t\t\t   struct device_node *node)\n{\n\tu32 value;\n\tint err;\n\n\terr = of_property_read_u32(node, \"clock-frequency\", &value);\n\tif (err) {\n\t\tdev_err(emc->dev, \"timing %pOFn: failed to read rate: %d\\n\",\n\t\t\tnode, err);\n\t\treturn err;\n\t}\n\n\ttiming->rate = value;\n\n\terr = of_property_read_u32_array(node, \"nvidia,emc-configuration\",\n\t\t\t\t\t timing->emc_burst_data,\n\t\t\t\t\t ARRAY_SIZE(timing->emc_burst_data));\n\tif (err) {\n\t\tdev_err(emc->dev,\n\t\t\t\"timing %pOFn: failed to read emc burst data: %d\\n\",\n\t\t\tnode, err);\n\t\treturn err;\n\t}\n\n#define EMC_READ_PROP(prop, dtprop) { \\\n\terr = of_property_read_u32(node, dtprop, &timing->prop); \\\n\tif (err) { \\\n\t\tdev_err(emc->dev, \"timing %pOFn: failed to read \" #prop \": %d\\n\", \\\n\t\t\tnode, err); \\\n\t\treturn err; \\\n\t} \\\n}\n\n\tEMC_READ_PROP(emc_auto_cal_config, \"nvidia,emc-auto-cal-config\")\n\tEMC_READ_PROP(emc_auto_cal_config2, \"nvidia,emc-auto-cal-config2\")\n\tEMC_READ_PROP(emc_auto_cal_config3, \"nvidia,emc-auto-cal-config3\")\n\tEMC_READ_PROP(emc_auto_cal_interval, \"nvidia,emc-auto-cal-interval\")\n\tEMC_READ_PROP(emc_bgbias_ctl0, \"nvidia,emc-bgbias-ctl0\")\n\tEMC_READ_PROP(emc_cfg, \"nvidia,emc-cfg\")\n\tEMC_READ_PROP(emc_cfg_2, \"nvidia,emc-cfg-2\")\n\tEMC_READ_PROP(emc_ctt_term_ctrl, \"nvidia,emc-ctt-term-ctrl\")\n\tEMC_READ_PROP(emc_mode_1, \"nvidia,emc-mode-1\")\n\tEMC_READ_PROP(emc_mode_2, \"nvidia,emc-mode-2\")\n\tEMC_READ_PROP(emc_mode_4, \"nvidia,emc-mode-4\")\n\tEMC_READ_PROP(emc_mode_reset, \"nvidia,emc-mode-reset\")\n\tEMC_READ_PROP(emc_mrs_wait_cnt, \"nvidia,emc-mrs-wait-cnt\")\n\tEMC_READ_PROP(emc_sel_dpd_ctrl, \"nvidia,emc-sel-dpd-ctrl\")\n\tEMC_READ_PROP(emc_xm2dqspadctrl2, \"nvidia,emc-xm2dqspadctrl2\")\n\tEMC_READ_PROP(emc_zcal_cnt_long, \"nvidia,emc-zcal-cnt-long\")\n\tEMC_READ_PROP(emc_zcal_interval, \"nvidia,emc-zcal-interval\")\n\n#undef EMC_READ_PROP\n\n\treturn 0;\n}\n\nstatic int cmp_timings(const void *_a, const void *_b)\n{\n\tconst struct emc_timing *a = _a;\n\tconst struct emc_timing *b = _b;\n\n\tif (a->rate < b->rate)\n\t\treturn -1;\n\telse if (a->rate == b->rate)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int tegra_emc_load_timings_from_dt(struct tegra_emc *emc,\n\t\t\t\t\t  struct device_node *node)\n{\n\tint child_count = of_get_child_count(node);\n\tstruct device_node *child;\n\tstruct emc_timing *timing;\n\tunsigned int i = 0;\n\tint err;\n\n\temc->timings = devm_kcalloc(emc->dev, child_count, sizeof(*timing),\n\t\t\t\t    GFP_KERNEL);\n\tif (!emc->timings)\n\t\treturn -ENOMEM;\n\n\temc->num_timings = child_count;\n\n\tfor_each_child_of_node(node, child) {\n\t\ttiming = &emc->timings[i++];\n\n\t\terr = load_one_timing_from_dt(emc, timing, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tsort(emc->timings, emc->num_timings, sizeof(*timing), cmp_timings,\n\t     NULL);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_emc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-emc\" },\n\t{ .compatible = \"nvidia,tegra132-emc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_emc_of_match);\n\nstatic struct device_node *\ntegra_emc_find_node_by_ram_code(struct device_node *node, u32 ram_code)\n{\n\tstruct device_node *np;\n\tint err;\n\n\tfor_each_child_of_node(node, np) {\n\t\tu32 value;\n\n\t\terr = of_property_read_u32(np, \"nvidia,ram-code\", &value);\n\t\tif (err || (value != ram_code))\n\t\t\tcontinue;\n\n\t\treturn np;\n\t}\n\n\treturn NULL;\n}\n\nstatic void tegra_emc_rate_requests_init(struct tegra_emc *emc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < EMC_RATE_TYPE_MAX; i++) {\n\t\temc->requested_rate[i].min_rate = 0;\n\t\temc->requested_rate[i].max_rate = ULONG_MAX;\n\t}\n}\n\nstatic int emc_request_rate(struct tegra_emc *emc,\n\t\t\t    unsigned long new_min_rate,\n\t\t\t    unsigned long new_max_rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = emc->requested_rate;\n\tunsigned long min_rate = 0, max_rate = ULONG_MAX;\n\tunsigned int i;\n\tint err;\n\n\t \n\tfor (i = 0; i < EMC_RATE_TYPE_MAX; i++, req++) {\n\t\tif (i == type) {\n\t\t\tmin_rate = max(new_min_rate, min_rate);\n\t\t\tmax_rate = min(new_max_rate, max_rate);\n\t\t} else {\n\t\t\tmin_rate = max(req->min_rate, min_rate);\n\t\t\tmax_rate = min(req->max_rate, max_rate);\n\t\t}\n\t}\n\n\tif (min_rate > max_rate) {\n\t\tdev_err_ratelimited(emc->dev, \"%s: type %u: out of range: %lu %lu\\n\",\n\t\t\t\t    __func__, type, min_rate, max_rate);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\terr = dev_pm_opp_set_rate(emc->dev, min_rate);\n\tif (err)\n\t\treturn err;\n\n\temc->requested_rate[type].min_rate = new_min_rate;\n\temc->requested_rate[type].max_rate = new_max_rate;\n\n\treturn 0;\n}\n\nstatic int emc_set_min_rate(struct tegra_emc *emc, unsigned long rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = &emc->requested_rate[type];\n\tint ret;\n\n\tmutex_lock(&emc->rate_lock);\n\tret = emc_request_rate(emc, rate, req->max_rate, type);\n\tmutex_unlock(&emc->rate_lock);\n\n\treturn ret;\n}\n\nstatic int emc_set_max_rate(struct tegra_emc *emc, unsigned long rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = &emc->requested_rate[type];\n\tint ret;\n\n\tmutex_lock(&emc->rate_lock);\n\tret = emc_request_rate(emc, req->min_rate, rate, type);\n\tmutex_unlock(&emc->rate_lock);\n\n\treturn ret;\n}\n\n \n\nstatic bool tegra_emc_validate_rate(struct tegra_emc *emc, unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++)\n\t\tif (rate == emc->timings[i].rate)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra_emc_debug_available_rates_show(struct seq_file *s,\n\t\t\t\t\t\tvoid *data)\n{\n\tstruct tegra_emc *emc = s->private;\n\tconst char *prefix = \"\";\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tseq_printf(s, \"%s%lu\", prefix, emc->timings[i].rate);\n\t\tprefix = \" \";\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(tegra_emc_debug_available_rates);\n\nstatic int tegra_emc_debug_min_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra_emc *emc = data;\n\n\t*rate = emc->debugfs.min_rate;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_debug_min_rate_set(void *data, u64 rate)\n{\n\tstruct tegra_emc *emc = data;\n\tint err;\n\n\tif (!tegra_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = emc_set_min_rate(emc, rate, EMC_RATE_DEBUG);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.min_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra_emc_debug_min_rate_fops,\n\t\t\ttegra_emc_debug_min_rate_get,\n\t\t\ttegra_emc_debug_min_rate_set, \"%llu\\n\");\n\nstatic int tegra_emc_debug_max_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra_emc *emc = data;\n\n\t*rate = emc->debugfs.max_rate;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_debug_max_rate_set(void *data, u64 rate)\n{\n\tstruct tegra_emc *emc = data;\n\tint err;\n\n\tif (!tegra_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = emc_set_max_rate(emc, rate, EMC_RATE_DEBUG);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.max_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra_emc_debug_max_rate_fops,\n\t\t\ttegra_emc_debug_max_rate_get,\n\t\t\ttegra_emc_debug_max_rate_set, \"%llu\\n\");\n\nstatic void emc_debugfs_init(struct device *dev, struct tegra_emc *emc)\n{\n\tunsigned int i;\n\tint err;\n\n\temc->debugfs.min_rate = ULONG_MAX;\n\temc->debugfs.max_rate = 0;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate < emc->debugfs.min_rate)\n\t\t\temc->debugfs.min_rate = emc->timings[i].rate;\n\n\t\tif (emc->timings[i].rate > emc->debugfs.max_rate)\n\t\t\temc->debugfs.max_rate = emc->timings[i].rate;\n\t}\n\n\tif (!emc->num_timings) {\n\t\temc->debugfs.min_rate = clk_get_rate(emc->clk);\n\t\temc->debugfs.max_rate = emc->debugfs.min_rate;\n\t}\n\n\terr = clk_set_rate_range(emc->clk, emc->debugfs.min_rate,\n\t\t\t\t emc->debugfs.max_rate);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to set rate range [%lu-%lu] for %pC\\n\",\n\t\t\temc->debugfs.min_rate, emc->debugfs.max_rate,\n\t\t\temc->clk);\n\t\treturn;\n\t}\n\n\temc->debugfs.root = debugfs_create_dir(\"emc\", NULL);\n\n\tdebugfs_create_file(\"available_rates\", 0444, emc->debugfs.root, emc,\n\t\t\t    &tegra_emc_debug_available_rates_fops);\n\tdebugfs_create_file(\"min_rate\", 0644, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_min_rate_fops);\n\tdebugfs_create_file(\"max_rate\", 0644, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_max_rate_fops);\n}\n\nstatic inline struct tegra_emc *\nto_tegra_emc_provider(struct icc_provider *provider)\n{\n\treturn container_of(provider, struct tegra_emc, provider);\n}\n\nstatic struct icc_node_data *\nemc_of_icc_xlate_extended(struct of_phandle_args *spec, void *data)\n{\n\tstruct icc_provider *provider = data;\n\tstruct icc_node_data *ndata;\n\tstruct icc_node *node;\n\n\t \n\tlist_for_each_entry(node, &provider->nodes, node_list) {\n\t\tif (node->id != TEGRA_ICC_EMEM)\n\t\t\tcontinue;\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_KERNEL);\n\t\tif (!ndata)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t \n\t\tndata->tag = TEGRA_MC_ICC_TAG_ISO;\n\t\tndata->node = node;\n\n\t\treturn ndata;\n\t}\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic int emc_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct tegra_emc *emc = to_tegra_emc_provider(dst->provider);\n\tunsigned long long peak_bw = icc_units_to_bps(dst->peak_bw);\n\tunsigned long long avg_bw = icc_units_to_bps(dst->avg_bw);\n\tunsigned long long rate = max(avg_bw, peak_bw);\n\tunsigned int dram_data_bus_width_bytes;\n\tconst unsigned int ddr = 2;\n\tint err;\n\n\t \n\tdram_data_bus_width_bytes = emc->dram_bus_width / 8;\n\tdo_div(rate, ddr * dram_data_bus_width_bytes);\n\trate = min_t(u64, rate, U32_MAX);\n\n\terr = emc_set_min_rate(emc, rate, EMC_RATE_ICC);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_interconnect_init(struct tegra_emc *emc)\n{\n\tconst struct tegra_mc_soc *soc = emc->mc->soc;\n\tstruct icc_node *node;\n\tint err;\n\n\temc->provider.dev = emc->dev;\n\temc->provider.set = emc_icc_set;\n\temc->provider.data = &emc->provider;\n\temc->provider.aggregate = soc->icc_ops->aggregate;\n\temc->provider.xlate_extended = emc_of_icc_xlate_extended;\n\n\ticc_provider_init(&emc->provider);\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMC);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto err_msg;\n\t}\n\n\tnode->name = \"External Memory Controller\";\n\ticc_node_add(node, &emc->provider);\n\n\t \n\terr = icc_link_create(node, TEGRA_ICC_EMEM);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMEM);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto remove_nodes;\n\t}\n\n\tnode->name = \"External Memory (DRAM)\";\n\ticc_node_add(node, &emc->provider);\n\n\terr = icc_provider_register(&emc->provider);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\treturn 0;\n\nremove_nodes:\n\ticc_nodes_remove(&emc->provider);\nerr_msg:\n\tdev_err(emc->dev, \"failed to initialize ICC: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int tegra_emc_opp_table_init(struct tegra_emc *emc)\n{\n\tu32 hw_version = BIT(tegra_sku_info.soc_speedo_id);\n\tint opp_token, err;\n\n\terr = dev_pm_opp_set_supported_hw(emc->dev, &hw_version, 1);\n\tif (err < 0) {\n\t\tdev_err(emc->dev, \"failed to set OPP supported HW: %d\\n\", err);\n\t\treturn err;\n\t}\n\topp_token = err;\n\n\terr = dev_pm_opp_of_add_table(emc->dev);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tdev_err(emc->dev, \"OPP table not found, please update your device tree\\n\");\n\t\telse\n\t\t\tdev_err(emc->dev, \"failed to add OPP table: %d\\n\", err);\n\n\t\tgoto put_hw_table;\n\t}\n\n\tdev_info_once(emc->dev, \"OPP HW ver. 0x%x, current clock rate %lu MHz\\n\",\n\t\t      hw_version, clk_get_rate(emc->clk) / 1000000);\n\n\t \n\terr = dev_pm_opp_set_rate(emc->dev, clk_get_rate(emc->clk));\n\tif (err) {\n\t\tdev_err(emc->dev, \"failed to initialize OPP clock: %d\\n\", err);\n\t\tgoto remove_table;\n\t}\n\n\treturn 0;\n\nremove_table:\n\tdev_pm_opp_of_remove_table(emc->dev);\nput_hw_table:\n\tdev_pm_opp_put_supported_hw(opp_token);\n\n\treturn err;\n}\n\nstatic void devm_tegra_emc_unset_callback(void *data)\n{\n\ttegra124_clk_set_emc_callbacks(NULL, NULL);\n}\n\nstatic int tegra_emc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tstruct tegra_emc *emc;\n\tu32 ram_code;\n\tint err;\n\n\temc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&emc->rate_lock);\n\temc->dev = &pdev->dev;\n\n\temc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(emc->regs))\n\t\treturn PTR_ERR(emc->regs);\n\n\temc->mc = devm_tegra_memory_controller_get(&pdev->dev);\n\tif (IS_ERR(emc->mc))\n\t\treturn PTR_ERR(emc->mc);\n\n\tram_code = tegra_read_ram_code();\n\n\tnp = tegra_emc_find_node_by_ram_code(pdev->dev.of_node, ram_code);\n\tif (np) {\n\t\terr = tegra_emc_load_timings_from_dt(emc, np);\n\t\tof_node_put(np);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tdev_info_once(&pdev->dev,\n\t\t\t      \"no memory timings for RAM code %u found in DT\\n\",\n\t\t\t      ram_code);\n\t}\n\n\terr = emc_init(emc);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"EMC initialization failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, emc);\n\n\ttegra124_clk_set_emc_callbacks(tegra_emc_prepare_timing_change,\n\t\t\t\t       tegra_emc_complete_timing_change);\n\n\terr = devm_add_action_or_reset(&pdev->dev, devm_tegra_emc_unset_callback,\n\t\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\n\temc->clk = devm_clk_get(&pdev->dev, \"emc\");\n\tif (IS_ERR(emc->clk)) {\n\t\terr = PTR_ERR(emc->clk);\n\t\tdev_err(&pdev->dev, \"failed to get EMC clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_emc_opp_table_init(emc);\n\tif (err)\n\t\treturn err;\n\n\ttegra_emc_rate_requests_init(emc);\n\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\temc_debugfs_init(&pdev->dev, emc);\n\n\ttegra_emc_interconnect_init(emc);\n\n\t \n\ttry_module_get(THIS_MODULE);\n\n\treturn 0;\n};\n\nstatic struct platform_driver tegra_emc_driver = {\n\t.probe = tegra_emc_probe,\n\t.driver = {\n\t\t.name = \"tegra-emc\",\n\t\t.of_match_table = tegra_emc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.sync_state = icc_sync_state,\n\t},\n};\nmodule_platform_driver(tegra_emc_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra124 EMC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}