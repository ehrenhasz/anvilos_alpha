{
  "module_name": "tegra20.c",
  "hash_id": "14f567ed640cbea3ddae29482cb03527b5785c7148b3ee9f2729acbbdaefbeb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/tegra20.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <dt-bindings/memory/tegra20-mc.h>\n\n#include \"mc.h\"\n\n#define MC_STAT_CONTROL\t\t\t\t0x90\n#define MC_STAT_EMC_CLOCK_LIMIT\t\t\t0xa0\n#define MC_STAT_EMC_CLOCKS\t\t\t0xa4\n#define MC_STAT_EMC_CONTROL_0\t\t\t0xa8\n#define MC_STAT_EMC_CONTROL_1\t\t\t0xac\n#define MC_STAT_EMC_COUNT_0\t\t\t0xb8\n#define MC_STAT_EMC_COUNT_1\t\t\t0xbc\n\n#define MC_STAT_CONTROL_CLIENT_ID\t\tGENMASK(13,  8)\n#define MC_STAT_CONTROL_EVENT\t\t\tGENMASK(23, 16)\n#define MC_STAT_CONTROL_PRI_EVENT\t\tGENMASK(25, 24)\n#define MC_STAT_CONTROL_FILTER_CLIENT_ENABLE\tGENMASK(26, 26)\n#define MC_STAT_CONTROL_FILTER_PRI\t\tGENMASK(29, 28)\n\n#define MC_STAT_CONTROL_PRI_EVENT_HP\t\t0\n#define MC_STAT_CONTROL_PRI_EVENT_TM\t\t1\n#define MC_STAT_CONTROL_PRI_EVENT_BW\t\t2\n\n#define MC_STAT_CONTROL_FILTER_PRI_DISABLE\t0\n#define MC_STAT_CONTROL_FILTER_PRI_NO\t\t1\n#define MC_STAT_CONTROL_FILTER_PRI_YES\t\t2\n\n#define MC_STAT_CONTROL_EVENT_QUALIFIED\t\t0\n#define MC_STAT_CONTROL_EVENT_ANY_READ\t\t1\n#define MC_STAT_CONTROL_EVENT_ANY_WRITE\t\t2\n#define MC_STAT_CONTROL_EVENT_RD_WR_CHANGE\t3\n#define MC_STAT_CONTROL_EVENT_SUCCESSIVE\t4\n#define MC_STAT_CONTROL_EVENT_ARB_BANK_AA\t5\n#define MC_STAT_CONTROL_EVENT_ARB_BANK_BB\t6\n#define MC_STAT_CONTROL_EVENT_PAGE_MISS\t\t7\n#define MC_STAT_CONTROL_EVENT_AUTO_PRECHARGE\t8\n\n#define EMC_GATHER_RST\t\t\t\t(0 << 8)\n#define EMC_GATHER_CLEAR\t\t\t(1 << 8)\n#define EMC_GATHER_DISABLE\t\t\t(2 << 8)\n#define EMC_GATHER_ENABLE\t\t\t(3 << 8)\n\n#define MC_STAT_SAMPLE_TIME_USEC\t\t16000\n\n \n#define MC_FX_FRAC_SCALE\t\t\t100\n\nstatic DEFINE_MUTEX(tegra20_mc_stat_lock);\n\nstruct tegra20_mc_stat_gather {\n\tunsigned int pri_filter;\n\tunsigned int pri_event;\n\tunsigned int result;\n\tunsigned int client;\n\tunsigned int event;\n\tbool client_enb;\n};\n\nstruct tegra20_mc_stat {\n\tstruct tegra20_mc_stat_gather gather0;\n\tstruct tegra20_mc_stat_gather gather1;\n\tunsigned int sample_time_usec;\n\tconst struct tegra_mc *mc;\n};\n\nstruct tegra20_mc_client_stat {\n\tunsigned int events;\n\tunsigned int arb_high_prio;\n\tunsigned int arb_timeout;\n\tunsigned int arb_bandwidth;\n\tunsigned int rd_wr_change;\n\tunsigned int successive;\n\tunsigned int page_miss;\n\tunsigned int auto_precharge;\n\tunsigned int arb_bank_aa;\n\tunsigned int arb_bank_bb;\n};\n\nstatic const struct tegra_mc_client tegra20_mc_clients[] = {\n\t{\n\t\t.id = 0x00,\n\t\t.name = \"display0a\",\n\t}, {\n\t\t.id = 0x01,\n\t\t.name = \"display0ab\",\n\t}, {\n\t\t.id = 0x02,\n\t\t.name = \"display0b\",\n\t}, {\n\t\t.id = 0x03,\n\t\t.name = \"display0bb\",\n\t}, {\n\t\t.id = 0x04,\n\t\t.name = \"display0c\",\n\t}, {\n\t\t.id = 0x05,\n\t\t.name = \"display0cb\",\n\t}, {\n\t\t.id = 0x06,\n\t\t.name = \"display1b\",\n\t}, {\n\t\t.id = 0x07,\n\t\t.name = \"display1bb\",\n\t}, {\n\t\t.id = 0x08,\n\t\t.name = \"eppup\",\n\t}, {\n\t\t.id = 0x09,\n\t\t.name = \"g2pr\",\n\t}, {\n\t\t.id = 0x0a,\n\t\t.name = \"g2sr\",\n\t}, {\n\t\t.id = 0x0b,\n\t\t.name = \"mpeunifbr\",\n\t}, {\n\t\t.id = 0x0c,\n\t\t.name = \"viruv\",\n\t}, {\n\t\t.id = 0x0d,\n\t\t.name = \"avpcarm7r\",\n\t}, {\n\t\t.id = 0x0e,\n\t\t.name = \"displayhc\",\n\t}, {\n\t\t.id = 0x0f,\n\t\t.name = \"displayhcb\",\n\t}, {\n\t\t.id = 0x10,\n\t\t.name = \"fdcdrd\",\n\t}, {\n\t\t.id = 0x11,\n\t\t.name = \"g2dr\",\n\t}, {\n\t\t.id = 0x12,\n\t\t.name = \"host1xdmar\",\n\t}, {\n\t\t.id = 0x13,\n\t\t.name = \"host1xr\",\n\t}, {\n\t\t.id = 0x14,\n\t\t.name = \"idxsrd\",\n\t}, {\n\t\t.id = 0x15,\n\t\t.name = \"mpcorer\",\n\t}, {\n\t\t.id = 0x16,\n\t\t.name = \"mpe_ipred\",\n\t}, {\n\t\t.id = 0x17,\n\t\t.name = \"mpeamemrd\",\n\t}, {\n\t\t.id = 0x18,\n\t\t.name = \"mpecsrd\",\n\t}, {\n\t\t.id = 0x19,\n\t\t.name = \"ppcsahbdmar\",\n\t}, {\n\t\t.id = 0x1a,\n\t\t.name = \"ppcsahbslvr\",\n\t}, {\n\t\t.id = 0x1b,\n\t\t.name = \"texsrd\",\n\t}, {\n\t\t.id = 0x1c,\n\t\t.name = \"vdebsevr\",\n\t}, {\n\t\t.id = 0x1d,\n\t\t.name = \"vdember\",\n\t}, {\n\t\t.id = 0x1e,\n\t\t.name = \"vdemcer\",\n\t}, {\n\t\t.id = 0x1f,\n\t\t.name = \"vdetper\",\n\t}, {\n\t\t.id = 0x20,\n\t\t.name = \"eppu\",\n\t}, {\n\t\t.id = 0x21,\n\t\t.name = \"eppv\",\n\t}, {\n\t\t.id = 0x22,\n\t\t.name = \"eppy\",\n\t}, {\n\t\t.id = 0x23,\n\t\t.name = \"mpeunifbw\",\n\t}, {\n\t\t.id = 0x24,\n\t\t.name = \"viwsb\",\n\t}, {\n\t\t.id = 0x25,\n\t\t.name = \"viwu\",\n\t}, {\n\t\t.id = 0x26,\n\t\t.name = \"viwv\",\n\t}, {\n\t\t.id = 0x27,\n\t\t.name = \"viwy\",\n\t}, {\n\t\t.id = 0x28,\n\t\t.name = \"g2dw\",\n\t}, {\n\t\t.id = 0x29,\n\t\t.name = \"avpcarm7w\",\n\t}, {\n\t\t.id = 0x2a,\n\t\t.name = \"fdcdwr\",\n\t}, {\n\t\t.id = 0x2b,\n\t\t.name = \"host1xw\",\n\t}, {\n\t\t.id = 0x2c,\n\t\t.name = \"ispw\",\n\t}, {\n\t\t.id = 0x2d,\n\t\t.name = \"mpcorew\",\n\t}, {\n\t\t.id = 0x2e,\n\t\t.name = \"mpecswr\",\n\t}, {\n\t\t.id = 0x2f,\n\t\t.name = \"ppcsahbdmaw\",\n\t}, {\n\t\t.id = 0x30,\n\t\t.name = \"ppcsahbslvw\",\n\t}, {\n\t\t.id = 0x31,\n\t\t.name = \"vdebsevw\",\n\t}, {\n\t\t.id = 0x32,\n\t\t.name = \"vdembew\",\n\t}, {\n\t\t.id = 0x33,\n\t\t.name = \"vdetpmw\",\n\t},\n};\n\n#define TEGRA20_MC_RESET(_name, _control, _status, _reset, _bit)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.id = TEGRA20_MC_RESET_##_name,\t\t\t\t\\\n\t\t.control = _control,\t\t\t\t\t\\\n\t\t.status = _status,\t\t\t\t\t\\\n\t\t.reset = _reset,\t\t\t\t\t\\\n\t\t.bit = _bit,\t\t\t\t\t\t\\\n\t}\n\nstatic const struct tegra_mc_reset tegra20_mc_resets[] = {\n\tTEGRA20_MC_RESET(AVPC,   0x100, 0x140, 0x104,  0),\n\tTEGRA20_MC_RESET(DC,     0x100, 0x144, 0x104,  1),\n\tTEGRA20_MC_RESET(DCB,    0x100, 0x148, 0x104,  2),\n\tTEGRA20_MC_RESET(EPP,    0x100, 0x14c, 0x104,  3),\n\tTEGRA20_MC_RESET(2D,     0x100, 0x150, 0x104,  4),\n\tTEGRA20_MC_RESET(HC,     0x100, 0x154, 0x104,  5),\n\tTEGRA20_MC_RESET(ISP,    0x100, 0x158, 0x104,  6),\n\tTEGRA20_MC_RESET(MPCORE, 0x100, 0x15c, 0x104,  7),\n\tTEGRA20_MC_RESET(MPEA,   0x100, 0x160, 0x104,  8),\n\tTEGRA20_MC_RESET(MPEB,   0x100, 0x164, 0x104,  9),\n\tTEGRA20_MC_RESET(MPEC,   0x100, 0x168, 0x104, 10),\n\tTEGRA20_MC_RESET(3D,     0x100, 0x16c, 0x104, 11),\n\tTEGRA20_MC_RESET(PPCS,   0x100, 0x170, 0x104, 12),\n\tTEGRA20_MC_RESET(VDE,    0x100, 0x174, 0x104, 13),\n\tTEGRA20_MC_RESET(VI,     0x100, 0x178, 0x104, 14),\n};\n\nstatic int tegra20_mc_hotreset_assert(struct tegra_mc *mc,\n\t\t\t\t      const struct tegra_mc_reset *rst)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&mc->lock, flags);\n\n\tvalue = mc_readl(mc, rst->reset);\n\tmc_writel(mc, value & ~BIT(rst->bit), rst->reset);\n\n\tspin_unlock_irqrestore(&mc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tegra20_mc_hotreset_deassert(struct tegra_mc *mc,\n\t\t\t\t\tconst struct tegra_mc_reset *rst)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&mc->lock, flags);\n\n\tvalue = mc_readl(mc, rst->reset);\n\tmc_writel(mc, value | BIT(rst->bit), rst->reset);\n\n\tspin_unlock_irqrestore(&mc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tegra20_mc_block_dma(struct tegra_mc *mc,\n\t\t\t\tconst struct tegra_mc_reset *rst)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&mc->lock, flags);\n\n\tvalue = mc_readl(mc, rst->control) & ~BIT(rst->bit);\n\tmc_writel(mc, value, rst->control);\n\n\tspin_unlock_irqrestore(&mc->lock, flags);\n\n\treturn 0;\n}\n\nstatic bool tegra20_mc_dma_idling(struct tegra_mc *mc,\n\t\t\t\t  const struct tegra_mc_reset *rst)\n{\n\treturn mc_readl(mc, rst->status) == 0;\n}\n\nstatic int tegra20_mc_reset_status(struct tegra_mc *mc,\n\t\t\t\t   const struct tegra_mc_reset *rst)\n{\n\treturn (mc_readl(mc, rst->reset) & BIT(rst->bit)) == 0;\n}\n\nstatic int tegra20_mc_unblock_dma(struct tegra_mc *mc,\n\t\t\t\t  const struct tegra_mc_reset *rst)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&mc->lock, flags);\n\n\tvalue = mc_readl(mc, rst->control) | BIT(rst->bit);\n\tmc_writel(mc, value, rst->control);\n\n\tspin_unlock_irqrestore(&mc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct tegra_mc_reset_ops tegra20_mc_reset_ops = {\n\t.hotreset_assert = tegra20_mc_hotreset_assert,\n\t.hotreset_deassert = tegra20_mc_hotreset_deassert,\n\t.block_dma = tegra20_mc_block_dma,\n\t.dma_idling = tegra20_mc_dma_idling,\n\t.unblock_dma = tegra20_mc_unblock_dma,\n\t.reset_status = tegra20_mc_reset_status,\n};\n\nstatic int tegra20_mc_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\t \n\treturn 0;\n}\n\nstatic int tegra20_mc_icc_aggreate(struct icc_node *node, u32 tag, u32 avg_bw,\n\t\t\t\t   u32 peak_bw, u32 *agg_avg, u32 *agg_peak)\n{\n\t \n\tif (tag & TEGRA_MC_ICC_TAG_ISO)\n\t\tpeak_bw = tegra_mc_scale_percents(peak_bw, 300);\n\n\t*agg_avg += avg_bw;\n\t*agg_peak = max(*agg_peak, peak_bw);\n\n\treturn 0;\n}\n\nstatic struct icc_node_data *\ntegra20_mc_of_icc_xlate_extended(struct of_phandle_args *spec, void *data)\n{\n\tstruct tegra_mc *mc = icc_provider_to_tegra_mc(data);\n\tunsigned int i, idx = spec->args[0];\n\tstruct icc_node_data *ndata;\n\tstruct icc_node *node;\n\n\tlist_for_each_entry(node, &mc->provider.nodes, node_list) {\n\t\tif (node->id != idx)\n\t\t\tcontinue;\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_KERNEL);\n\t\tif (!ndata)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tndata->node = node;\n\n\t\t \n\t\tif (strstarts(node->name, \"display\") ||\n\t\t    strstarts(node->name, \"vi\"))\n\t\t\tndata->tag = TEGRA_MC_ICC_TAG_ISO;\n\t\telse\n\t\t\tndata->tag = TEGRA_MC_ICC_TAG_DEFAULT;\n\n\t\treturn ndata;\n\t}\n\n\tfor (i = 0; i < mc->soc->num_clients; i++) {\n\t\tif (mc->soc->clients[i].id == idx)\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tdev_err(mc->dev, \"invalid ICC client ID %u\\n\", idx);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic const struct tegra_mc_icc_ops tegra20_mc_icc_ops = {\n\t.xlate_extended = tegra20_mc_of_icc_xlate_extended,\n\t.aggregate = tegra20_mc_icc_aggreate,\n\t.set = tegra20_mc_icc_set,\n};\n\nstatic u32 tegra20_mc_stat_gather_control(const struct tegra20_mc_stat_gather *g)\n{\n\tu32 control;\n\n\tcontrol  = FIELD_PREP(MC_STAT_CONTROL_EVENT, g->event);\n\tcontrol |= FIELD_PREP(MC_STAT_CONTROL_CLIENT_ID, g->client);\n\tcontrol |= FIELD_PREP(MC_STAT_CONTROL_PRI_EVENT, g->pri_event);\n\tcontrol |= FIELD_PREP(MC_STAT_CONTROL_FILTER_PRI, g->pri_filter);\n\tcontrol |= FIELD_PREP(MC_STAT_CONTROL_FILTER_CLIENT_ENABLE, g->client_enb);\n\n\treturn control;\n}\n\nstatic void tegra20_mc_stat_gather(struct tegra20_mc_stat *stat)\n{\n\tu32 clocks, count0, count1, control_0, control_1;\n\tconst struct tegra_mc *mc = stat->mc;\n\n\tcontrol_0 = tegra20_mc_stat_gather_control(&stat->gather0);\n\tcontrol_1 = tegra20_mc_stat_gather_control(&stat->gather1);\n\n\t \n\tmc_writel(mc, 0x00000000, MC_STAT_CONTROL);\n\tmc_writel(mc,  control_0, MC_STAT_EMC_CONTROL_0);\n\tmc_writel(mc,  control_1, MC_STAT_EMC_CONTROL_1);\n\tmc_writel(mc, 0xffffffff, MC_STAT_EMC_CLOCK_LIMIT);\n\n\tmc_writel(mc, EMC_GATHER_ENABLE, MC_STAT_CONTROL);\n\tfsleep(stat->sample_time_usec);\n\tmc_writel(mc, EMC_GATHER_DISABLE, MC_STAT_CONTROL);\n\n\tcount0 = mc_readl(mc, MC_STAT_EMC_COUNT_0);\n\tcount1 = mc_readl(mc, MC_STAT_EMC_COUNT_1);\n\tclocks = mc_readl(mc, MC_STAT_EMC_CLOCKS);\n\tclocks = max(clocks / 100 / MC_FX_FRAC_SCALE, 1u);\n\n\tstat->gather0.result = DIV_ROUND_UP(count0, clocks);\n\tstat->gather1.result = DIV_ROUND_UP(count1, clocks);\n}\n\nstatic void tegra20_mc_stat_events(const struct tegra_mc *mc,\n\t\t\t\t   const struct tegra_mc_client *client0,\n\t\t\t\t   const struct tegra_mc_client *client1,\n\t\t\t\t   unsigned int pri_filter,\n\t\t\t\t   unsigned int pri_event,\n\t\t\t\t   unsigned int event,\n\t\t\t\t   unsigned int *result0,\n\t\t\t\t   unsigned int *result1)\n{\n\tstruct tegra20_mc_stat stat = {};\n\n\tstat.gather0.client = client0 ? client0->id : 0;\n\tstat.gather0.pri_filter = pri_filter;\n\tstat.gather0.client_enb = !!client0;\n\tstat.gather0.pri_event = pri_event;\n\tstat.gather0.event = event;\n\n\tstat.gather1.client = client1 ? client1->id : 0;\n\tstat.gather1.pri_filter = pri_filter;\n\tstat.gather1.client_enb = !!client1;\n\tstat.gather1.pri_event = pri_event;\n\tstat.gather1.event = event;\n\n\tstat.sample_time_usec = MC_STAT_SAMPLE_TIME_USEC;\n\tstat.mc = mc;\n\n\ttegra20_mc_stat_gather(&stat);\n\n\t*result0 = stat.gather0.result;\n\t*result1 = stat.gather1.result;\n}\n\nstatic void tegra20_mc_collect_stats(const struct tegra_mc *mc,\n\t\t\t\t     struct tegra20_mc_client_stat *stats)\n{\n\tconst struct tegra_mc_client *client0, *client1;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < mc->soc->num_clients; i += 2) {\n\t\tclient0 = &mc->soc->clients[i];\n\t\tclient1 = &mc->soc->clients[i + 1];\n\n\t\tif (i + 1 == mc->soc->num_clients)\n\t\t\tclient1 = NULL;\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_DISABLE,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_HP,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_QUALIFIED,\n\t\t\t\t       &stats[i + 0].events,\n\t\t\t\t       &stats[i + 1].events);\n\t}\n\n\t \n\tfor (i = 0; i < mc->soc->num_clients; i++) {\n\t\tunsigned int clienta, clientb = mc->soc->num_clients;\n\n\t\tfor (client0 = NULL; i < mc->soc->num_clients; i++) {\n\t\t\tif (stats[i].events) {\n\t\t\t\tclient0 = &mc->soc->clients[i];\n\t\t\t\tclienta = i++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (client1 = NULL; i < mc->soc->num_clients; i++) {\n\t\t\tif (stats[i].events) {\n\t\t\t\tclient1 = &mc->soc->clients[i];\n\t\t\t\tclientb = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!client0 && !client1)\n\t\t\tbreak;\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_YES,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_HP,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_QUALIFIED,\n\t\t\t\t       &stats[clienta].arb_high_prio,\n\t\t\t\t       &stats[clientb].arb_high_prio);\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_YES,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_TM,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_QUALIFIED,\n\t\t\t\t       &stats[clienta].arb_timeout,\n\t\t\t\t       &stats[clientb].arb_timeout);\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_YES,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_BW,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_QUALIFIED,\n\t\t\t\t       &stats[clienta].arb_bandwidth,\n\t\t\t\t       &stats[clientb].arb_bandwidth);\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_DISABLE,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_HP,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_RD_WR_CHANGE,\n\t\t\t\t       &stats[clienta].rd_wr_change,\n\t\t\t\t       &stats[clientb].rd_wr_change);\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_DISABLE,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_HP,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_SUCCESSIVE,\n\t\t\t\t       &stats[clienta].successive,\n\t\t\t\t       &stats[clientb].successive);\n\n\t\ttegra20_mc_stat_events(mc, client0, client1,\n\t\t\t\t       MC_STAT_CONTROL_FILTER_PRI_DISABLE,\n\t\t\t\t       MC_STAT_CONTROL_PRI_EVENT_HP,\n\t\t\t\t       MC_STAT_CONTROL_EVENT_PAGE_MISS,\n\t\t\t\t       &stats[clienta].page_miss,\n\t\t\t\t       &stats[clientb].page_miss);\n\t}\n}\n\nstatic void tegra20_mc_printf_percents(struct seq_file *s,\n\t\t\t\t       const char *fmt,\n\t\t\t\t       unsigned int percents_fx)\n{\n\tchar percents_str[8];\n\n\tsnprintf(percents_str, ARRAY_SIZE(percents_str), \"%3u.%02u%%\",\n\t\t percents_fx / MC_FX_FRAC_SCALE, percents_fx % MC_FX_FRAC_SCALE);\n\n\tseq_printf(s, fmt, percents_str);\n}\n\nstatic int tegra20_mc_stats_show(struct seq_file *s, void *unused)\n{\n\tconst struct tegra_mc *mc = dev_get_drvdata(s->private);\n\tstruct tegra20_mc_client_stat *stats;\n\tunsigned int i;\n\n\tstats = kcalloc(mc->soc->num_clients + 1, sizeof(*stats), GFP_KERNEL);\n\tif (!stats)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&tegra20_mc_stat_lock);\n\n\ttegra20_mc_collect_stats(mc, stats);\n\n\tmutex_unlock(&tegra20_mc_stat_lock);\n\n\tseq_puts(s, \"Memory client   Events   Timeout   High priority   Bandwidth ARB   RW change   Successive   Page miss\\n\");\n\tseq_puts(s, \"-----------------------------------------------------------------------------------------------------\\n\");\n\n\tfor (i = 0; i < mc->soc->num_clients; i++) {\n\t\tseq_printf(s, \"%-14s  \", mc->soc->clients[i].name);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s,  \"%-9s\", stats[i].events);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s, \"%-10s\", stats[i].arb_timeout);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s, \"%-16s\", stats[i].arb_high_prio);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s, \"%-16s\", stats[i].arb_bandwidth);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s, \"%-12s\", stats[i].rd_wr_change);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s, \"%-13s\", stats[i].successive);\n\n\t\t \n\t\ttegra20_mc_printf_percents(s, \"%-12s\\n\", stats[i].page_miss);\n\t}\n\n\tkfree(stats);\n\n\treturn 0;\n}\n\nstatic int tegra20_mc_probe(struct tegra_mc *mc)\n{\n\tdebugfs_create_devm_seqfile(mc->dev, \"stats\", mc->debugfs.root,\n\t\t\t\t    tegra20_mc_stats_show);\n\n\treturn 0;\n}\n\nstatic int tegra20_mc_suspend(struct tegra_mc *mc)\n{\n\tint err;\n\n\tif (IS_ENABLED(CONFIG_TEGRA_IOMMU_GART) && mc->gart) {\n\t\terr = tegra_gart_suspend(mc->gart);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra20_mc_resume(struct tegra_mc *mc)\n{\n\tint err;\n\n\tif (IS_ENABLED(CONFIG_TEGRA_IOMMU_GART) && mc->gart) {\n\t\terr = tegra_gart_resume(mc->gart);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra20_mc_handle_irq(int irq, void *data)\n{\n\tstruct tegra_mc *mc = data;\n\tunsigned long status;\n\tunsigned int bit;\n\n\t \n\tstatus = mc_readl(mc, MC_INTSTATUS) & mc->soc->intmask;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(bit, &status, 32) {\n\t\tconst char *error = tegra_mc_status_names[bit];\n\t\tconst char *direction = \"read\", *secure = \"\";\n\t\tconst char *client, *desc;\n\t\tphys_addr_t addr;\n\t\tu32 value, reg;\n\t\tu8 id, type;\n\n\t\tswitch (BIT(bit)) {\n\t\tcase MC_INT_DECERR_EMEM:\n\t\t\treg = MC_DECERR_EMEM_OTHERS_STATUS;\n\t\t\tvalue = mc_readl(mc, reg);\n\n\t\t\tid = value & mc->soc->client_id_mask;\n\t\t\tdesc = tegra_mc_error_names[2];\n\n\t\t\tif (value & BIT(31))\n\t\t\t\tdirection = \"write\";\n\t\t\tbreak;\n\n\t\tcase MC_INT_INVALID_GART_PAGE:\n\t\t\treg = MC_GART_ERROR_REQ;\n\t\t\tvalue = mc_readl(mc, reg);\n\n\t\t\tid = (value >> 1) & mc->soc->client_id_mask;\n\t\t\tdesc = tegra_mc_error_names[2];\n\n\t\t\tif (value & BIT(0))\n\t\t\t\tdirection = \"write\";\n\t\t\tbreak;\n\n\t\tcase MC_INT_SECURITY_VIOLATION:\n\t\t\treg = MC_SECURITY_VIOLATION_STATUS;\n\t\t\tvalue = mc_readl(mc, reg);\n\n\t\t\tid = value & mc->soc->client_id_mask;\n\t\t\ttype = (value & BIT(30)) ? 4 : 3;\n\t\t\tdesc = tegra_mc_error_names[type];\n\t\t\tsecure = \"secure \";\n\n\t\t\tif (value & BIT(31))\n\t\t\t\tdirection = \"write\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tclient = mc->soc->clients[id].name;\n\t\taddr = mc_readl(mc, reg + sizeof(u32));\n\n\t\tdev_err_ratelimited(mc->dev, \"%s: %s%s @%pa: %s (%s)\\n\",\n\t\t\t\t    client, secure, direction, &addr, error,\n\t\t\t\t    desc);\n\t}\n\n\t \n\tmc_writel(mc, status, MC_INTSTATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct tegra_mc_ops tegra20_mc_ops = {\n\t.probe = tegra20_mc_probe,\n\t.suspend = tegra20_mc_suspend,\n\t.resume = tegra20_mc_resume,\n\t.handle_irq = tegra20_mc_handle_irq,\n};\n\nconst struct tegra_mc_soc tegra20_mc_soc = {\n\t.clients = tegra20_mc_clients,\n\t.num_clients = ARRAY_SIZE(tegra20_mc_clients),\n\t.num_address_bits = 32,\n\t.client_id_mask = 0x3f,\n\t.intmask = MC_INT_SECURITY_VIOLATION | MC_INT_INVALID_GART_PAGE |\n\t\t   MC_INT_DECERR_EMEM,\n\t.reset_ops = &tegra20_mc_reset_ops,\n\t.resets = tegra20_mc_resets,\n\t.num_resets = ARRAY_SIZE(tegra20_mc_resets),\n\t.icc_ops = &tegra20_mc_icc_ops,\n\t.ops = &tegra20_mc_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}