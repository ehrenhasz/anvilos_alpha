{
  "module_name": "tegra30-emc.c",
  "hash_id": "2743ce2efb126011aee69fe1aa72f848eadf24347abbaec70dded0b0a608589d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/tegra30-emc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk/tegra.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interconnect-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/types.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/fuse.h>\n\n#include \"../jedec_ddr.h\"\n#include \"../of_memory.h\"\n\n#include \"mc.h\"\n\n#define EMC_INTSTATUS\t\t\t\t0x000\n#define EMC_INTMASK\t\t\t\t0x004\n#define EMC_DBG\t\t\t\t\t0x008\n#define EMC_ADR_CFG\t\t\t\t0x010\n#define EMC_CFG\t\t\t\t\t0x00c\n#define EMC_REFCTRL\t\t\t\t0x020\n#define EMC_TIMING_CONTROL\t\t\t0x028\n#define EMC_RC\t\t\t\t\t0x02c\n#define EMC_RFC\t\t\t\t\t0x030\n#define EMC_RAS\t\t\t\t\t0x034\n#define EMC_RP\t\t\t\t\t0x038\n#define EMC_R2W\t\t\t\t\t0x03c\n#define EMC_W2R\t\t\t\t\t0x040\n#define EMC_R2P\t\t\t\t\t0x044\n#define EMC_W2P\t\t\t\t\t0x048\n#define EMC_RD_RCD\t\t\t\t0x04c\n#define EMC_WR_RCD\t\t\t\t0x050\n#define EMC_RRD\t\t\t\t\t0x054\n#define EMC_REXT\t\t\t\t0x058\n#define EMC_WDV\t\t\t\t\t0x05c\n#define EMC_QUSE\t\t\t\t0x060\n#define EMC_QRST\t\t\t\t0x064\n#define EMC_QSAFE\t\t\t\t0x068\n#define EMC_RDV\t\t\t\t\t0x06c\n#define EMC_REFRESH\t\t\t\t0x070\n#define EMC_BURST_REFRESH_NUM\t\t\t0x074\n#define EMC_PDEX2WR\t\t\t\t0x078\n#define EMC_PDEX2RD\t\t\t\t0x07c\n#define EMC_PCHG2PDEN\t\t\t\t0x080\n#define EMC_ACT2PDEN\t\t\t\t0x084\n#define EMC_AR2PDEN\t\t\t\t0x088\n#define EMC_RW2PDEN\t\t\t\t0x08c\n#define EMC_TXSR\t\t\t\t0x090\n#define EMC_TCKE\t\t\t\t0x094\n#define EMC_TFAW\t\t\t\t0x098\n#define EMC_TRPAB\t\t\t\t0x09c\n#define EMC_TCLKSTABLE\t\t\t\t0x0a0\n#define EMC_TCLKSTOP\t\t\t\t0x0a4\n#define EMC_TREFBW\t\t\t\t0x0a8\n#define EMC_QUSE_EXTRA\t\t\t\t0x0ac\n#define EMC_ODT_WRITE\t\t\t\t0x0b0\n#define EMC_ODT_READ\t\t\t\t0x0b4\n#define EMC_WEXT\t\t\t\t0x0b8\n#define EMC_CTT\t\t\t\t\t0x0bc\n#define EMC_MRS_WAIT_CNT\t\t\t0x0c8\n#define EMC_MRS\t\t\t\t\t0x0cc\n#define EMC_EMRS\t\t\t\t0x0d0\n#define EMC_SELF_REF\t\t\t\t0x0e0\n#define EMC_MRW\t\t\t\t\t0x0e8\n#define EMC_MRR\t\t\t\t\t0x0ec\n#define EMC_XM2DQSPADCTRL3\t\t\t0x0f8\n#define EMC_FBIO_SPARE\t\t\t\t0x100\n#define EMC_FBIO_CFG5\t\t\t\t0x104\n#define EMC_FBIO_CFG6\t\t\t\t0x114\n#define EMC_CFG_RSV\t\t\t\t0x120\n#define EMC_AUTO_CAL_CONFIG\t\t\t0x2a4\n#define EMC_AUTO_CAL_INTERVAL\t\t\t0x2a8\n#define EMC_AUTO_CAL_STATUS\t\t\t0x2ac\n#define EMC_STATUS\t\t\t\t0x2b4\n#define EMC_CFG_2\t\t\t\t0x2b8\n#define EMC_CFG_DIG_DLL\t\t\t\t0x2bc\n#define EMC_CFG_DIG_DLL_PERIOD\t\t\t0x2c0\n#define EMC_CTT_DURATION\t\t\t0x2d8\n#define EMC_CTT_TERM_CTRL\t\t\t0x2dc\n#define EMC_ZCAL_INTERVAL\t\t\t0x2e0\n#define EMC_ZCAL_WAIT_CNT\t\t\t0x2e4\n#define EMC_ZQ_CAL\t\t\t\t0x2ec\n#define EMC_XM2CMDPADCTRL\t\t\t0x2f0\n#define EMC_XM2DQSPADCTRL2\t\t\t0x2fc\n#define EMC_XM2DQPADCTRL2\t\t\t0x304\n#define EMC_XM2CLKPADCTRL\t\t\t0x308\n#define EMC_XM2COMPPADCTRL\t\t\t0x30c\n#define EMC_XM2VTTGENPADCTRL\t\t\t0x310\n#define EMC_XM2VTTGENPADCTRL2\t\t\t0x314\n#define EMC_XM2QUSEPADCTRL\t\t\t0x318\n#define EMC_DLL_XFORM_DQS0\t\t\t0x328\n#define EMC_DLL_XFORM_DQS1\t\t\t0x32c\n#define EMC_DLL_XFORM_DQS2\t\t\t0x330\n#define EMC_DLL_XFORM_DQS3\t\t\t0x334\n#define EMC_DLL_XFORM_DQS4\t\t\t0x338\n#define EMC_DLL_XFORM_DQS5\t\t\t0x33c\n#define EMC_DLL_XFORM_DQS6\t\t\t0x340\n#define EMC_DLL_XFORM_DQS7\t\t\t0x344\n#define EMC_DLL_XFORM_QUSE0\t\t\t0x348\n#define EMC_DLL_XFORM_QUSE1\t\t\t0x34c\n#define EMC_DLL_XFORM_QUSE2\t\t\t0x350\n#define EMC_DLL_XFORM_QUSE3\t\t\t0x354\n#define EMC_DLL_XFORM_QUSE4\t\t\t0x358\n#define EMC_DLL_XFORM_QUSE5\t\t\t0x35c\n#define EMC_DLL_XFORM_QUSE6\t\t\t0x360\n#define EMC_DLL_XFORM_QUSE7\t\t\t0x364\n#define EMC_DLL_XFORM_DQ0\t\t\t0x368\n#define EMC_DLL_XFORM_DQ1\t\t\t0x36c\n#define EMC_DLL_XFORM_DQ2\t\t\t0x370\n#define EMC_DLL_XFORM_DQ3\t\t\t0x374\n#define EMC_DLI_TRIM_TXDQS0\t\t\t0x3a8\n#define EMC_DLI_TRIM_TXDQS1\t\t\t0x3ac\n#define EMC_DLI_TRIM_TXDQS2\t\t\t0x3b0\n#define EMC_DLI_TRIM_TXDQS3\t\t\t0x3b4\n#define EMC_DLI_TRIM_TXDQS4\t\t\t0x3b8\n#define EMC_DLI_TRIM_TXDQS5\t\t\t0x3bc\n#define EMC_DLI_TRIM_TXDQS6\t\t\t0x3c0\n#define EMC_DLI_TRIM_TXDQS7\t\t\t0x3c4\n#define EMC_STALL_THEN_EXE_BEFORE_CLKCHANGE\t0x3c8\n#define EMC_STALL_THEN_EXE_AFTER_CLKCHANGE\t0x3cc\n#define EMC_UNSTALL_RW_AFTER_CLKCHANGE\t\t0x3d0\n#define EMC_SEL_DPD_CTRL\t\t\t0x3d8\n#define EMC_PRE_REFRESH_REQ_CNT\t\t\t0x3dc\n#define EMC_DYN_SELF_REF_CONTROL\t\t0x3e0\n#define EMC_TXSRDLL\t\t\t\t0x3e4\n\n#define EMC_STATUS_TIMING_UPDATE_STALLED\tBIT(23)\n\n#define EMC_MODE_SET_DLL_RESET\t\t\tBIT(8)\n#define EMC_MODE_SET_LONG_CNT\t\t\tBIT(26)\n\n#define EMC_SELF_REF_CMD_ENABLED\t\tBIT(0)\n\n#define DRAM_DEV_SEL_ALL\t\t\t(0 << 30)\n#define DRAM_DEV_SEL_0\t\t\t\tBIT(31)\n#define DRAM_DEV_SEL_1\t\t\t\tBIT(30)\n#define DRAM_BROADCAST(num) \\\n\t((num) > 1 ? DRAM_DEV_SEL_ALL : DRAM_DEV_SEL_0)\n\n#define EMC_ZQ_CAL_CMD\t\t\t\tBIT(0)\n#define EMC_ZQ_CAL_LONG\t\t\t\tBIT(4)\n#define EMC_ZQ_CAL_LONG_CMD_DEV0 \\\n\t(DRAM_DEV_SEL_0 | EMC_ZQ_CAL_LONG | EMC_ZQ_CAL_CMD)\n#define EMC_ZQ_CAL_LONG_CMD_DEV1 \\\n\t(DRAM_DEV_SEL_1 | EMC_ZQ_CAL_LONG | EMC_ZQ_CAL_CMD)\n\n#define EMC_DBG_READ_MUX_ASSEMBLY\t\tBIT(0)\n#define EMC_DBG_WRITE_MUX_ACTIVE\t\tBIT(1)\n#define EMC_DBG_FORCE_UPDATE\t\t\tBIT(2)\n#define EMC_DBG_CFG_PRIORITY\t\t\tBIT(24)\n\n#define EMC_CFG5_QUSE_MODE_SHIFT\t\t13\n#define EMC_CFG5_QUSE_MODE_MASK\t\t\t(7 << EMC_CFG5_QUSE_MODE_SHIFT)\n\n#define EMC_CFG5_QUSE_MODE_INTERNAL_LPBK\t2\n#define EMC_CFG5_QUSE_MODE_PULSE_INTERN\t\t3\n\n#define EMC_SEL_DPD_CTRL_QUSE_DPD_ENABLE\tBIT(9)\n\n#define EMC_XM2COMPPADCTRL_VREF_CAL_ENABLE\tBIT(10)\n\n#define EMC_XM2QUSEPADCTRL_IVREF_ENABLE\t\tBIT(4)\n\n#define EMC_XM2DQSPADCTRL2_VREF_ENABLE\t\tBIT(5)\n#define EMC_XM2DQSPADCTRL3_VREF_ENABLE\t\tBIT(5)\n\n#define EMC_AUTO_CAL_STATUS_ACTIVE\t\tBIT(31)\n\n#define\tEMC_FBIO_CFG5_DRAM_TYPE_MASK\t\t0x3\n\n#define EMC_MRS_WAIT_CNT_SHORT_WAIT_MASK\t0x3ff\n#define EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT\t16\n#define EMC_MRS_WAIT_CNT_LONG_WAIT_MASK \\\n\t(0x3ff << EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT)\n\n#define EMC_REFCTRL_DEV_SEL_MASK\t\t0x3\n#define EMC_REFCTRL_ENABLE\t\t\tBIT(31)\n#define EMC_REFCTRL_ENABLE_ALL(num) \\\n\t(((num) > 1 ? 0 : 2) | EMC_REFCTRL_ENABLE)\n#define EMC_REFCTRL_DISABLE_ALL(num)\t\t((num) > 1 ? 0 : 2)\n\n#define EMC_CFG_PERIODIC_QRST\t\t\tBIT(21)\n#define EMC_CFG_DYN_SREF_ENABLE\t\t\tBIT(28)\n\n#define EMC_CLKCHANGE_REQ_ENABLE\t\tBIT(0)\n#define EMC_CLKCHANGE_PD_ENABLE\t\t\tBIT(1)\n#define EMC_CLKCHANGE_SR_ENABLE\t\t\tBIT(2)\n\n#define EMC_TIMING_UPDATE\t\t\tBIT(0)\n\n#define EMC_REFRESH_OVERFLOW_INT\t\tBIT(3)\n#define EMC_CLKCHANGE_COMPLETE_INT\t\tBIT(4)\n#define EMC_MRR_DIVLD_INT\t\t\tBIT(5)\n\n#define EMC_MRR_DEV_SELECTN\t\t\tGENMASK(31, 30)\n#define EMC_MRR_MRR_MA\t\t\t\tGENMASK(23, 16)\n#define EMC_MRR_MRR_DATA\t\t\tGENMASK(15, 0)\n\n#define EMC_ADR_CFG_EMEM_NUMDEV\t\t\tBIT(0)\n\nenum emc_dram_type {\n\tDRAM_TYPE_DDR3,\n\tDRAM_TYPE_DDR1,\n\tDRAM_TYPE_LPDDR2,\n\tDRAM_TYPE_DDR2,\n};\n\nenum emc_dll_change {\n\tDLL_CHANGE_NONE,\n\tDLL_CHANGE_ON,\n\tDLL_CHANGE_OFF\n};\n\nstatic const u16 emc_timing_registers[] = {\n\t[0] = EMC_RC,\n\t[1] = EMC_RFC,\n\t[2] = EMC_RAS,\n\t[3] = EMC_RP,\n\t[4] = EMC_R2W,\n\t[5] = EMC_W2R,\n\t[6] = EMC_R2P,\n\t[7] = EMC_W2P,\n\t[8] = EMC_RD_RCD,\n\t[9] = EMC_WR_RCD,\n\t[10] = EMC_RRD,\n\t[11] = EMC_REXT,\n\t[12] = EMC_WEXT,\n\t[13] = EMC_WDV,\n\t[14] = EMC_QUSE,\n\t[15] = EMC_QRST,\n\t[16] = EMC_QSAFE,\n\t[17] = EMC_RDV,\n\t[18] = EMC_REFRESH,\n\t[19] = EMC_BURST_REFRESH_NUM,\n\t[20] = EMC_PRE_REFRESH_REQ_CNT,\n\t[21] = EMC_PDEX2WR,\n\t[22] = EMC_PDEX2RD,\n\t[23] = EMC_PCHG2PDEN,\n\t[24] = EMC_ACT2PDEN,\n\t[25] = EMC_AR2PDEN,\n\t[26] = EMC_RW2PDEN,\n\t[27] = EMC_TXSR,\n\t[28] = EMC_TXSRDLL,\n\t[29] = EMC_TCKE,\n\t[30] = EMC_TFAW,\n\t[31] = EMC_TRPAB,\n\t[32] = EMC_TCLKSTABLE,\n\t[33] = EMC_TCLKSTOP,\n\t[34] = EMC_TREFBW,\n\t[35] = EMC_QUSE_EXTRA,\n\t[36] = EMC_FBIO_CFG6,\n\t[37] = EMC_ODT_WRITE,\n\t[38] = EMC_ODT_READ,\n\t[39] = EMC_FBIO_CFG5,\n\t[40] = EMC_CFG_DIG_DLL,\n\t[41] = EMC_CFG_DIG_DLL_PERIOD,\n\t[42] = EMC_DLL_XFORM_DQS0,\n\t[43] = EMC_DLL_XFORM_DQS1,\n\t[44] = EMC_DLL_XFORM_DQS2,\n\t[45] = EMC_DLL_XFORM_DQS3,\n\t[46] = EMC_DLL_XFORM_DQS4,\n\t[47] = EMC_DLL_XFORM_DQS5,\n\t[48] = EMC_DLL_XFORM_DQS6,\n\t[49] = EMC_DLL_XFORM_DQS7,\n\t[50] = EMC_DLL_XFORM_QUSE0,\n\t[51] = EMC_DLL_XFORM_QUSE1,\n\t[52] = EMC_DLL_XFORM_QUSE2,\n\t[53] = EMC_DLL_XFORM_QUSE3,\n\t[54] = EMC_DLL_XFORM_QUSE4,\n\t[55] = EMC_DLL_XFORM_QUSE5,\n\t[56] = EMC_DLL_XFORM_QUSE6,\n\t[57] = EMC_DLL_XFORM_QUSE7,\n\t[58] = EMC_DLI_TRIM_TXDQS0,\n\t[59] = EMC_DLI_TRIM_TXDQS1,\n\t[60] = EMC_DLI_TRIM_TXDQS2,\n\t[61] = EMC_DLI_TRIM_TXDQS3,\n\t[62] = EMC_DLI_TRIM_TXDQS4,\n\t[63] = EMC_DLI_TRIM_TXDQS5,\n\t[64] = EMC_DLI_TRIM_TXDQS6,\n\t[65] = EMC_DLI_TRIM_TXDQS7,\n\t[66] = EMC_DLL_XFORM_DQ0,\n\t[67] = EMC_DLL_XFORM_DQ1,\n\t[68] = EMC_DLL_XFORM_DQ2,\n\t[69] = EMC_DLL_XFORM_DQ3,\n\t[70] = EMC_XM2CMDPADCTRL,\n\t[71] = EMC_XM2DQSPADCTRL2,\n\t[72] = EMC_XM2DQPADCTRL2,\n\t[73] = EMC_XM2CLKPADCTRL,\n\t[74] = EMC_XM2COMPPADCTRL,\n\t[75] = EMC_XM2VTTGENPADCTRL,\n\t[76] = EMC_XM2VTTGENPADCTRL2,\n\t[77] = EMC_XM2QUSEPADCTRL,\n\t[78] = EMC_XM2DQSPADCTRL3,\n\t[79] = EMC_CTT_TERM_CTRL,\n\t[80] = EMC_ZCAL_INTERVAL,\n\t[81] = EMC_ZCAL_WAIT_CNT,\n\t[82] = EMC_MRS_WAIT_CNT,\n\t[83] = EMC_AUTO_CAL_CONFIG,\n\t[84] = EMC_CTT,\n\t[85] = EMC_CTT_DURATION,\n\t[86] = EMC_DYN_SELF_REF_CONTROL,\n\t[87] = EMC_FBIO_SPARE,\n\t[88] = EMC_CFG_RSV,\n};\n\nstruct emc_timing {\n\tunsigned long rate;\n\n\tu32 data[ARRAY_SIZE(emc_timing_registers)];\n\n\tu32 emc_auto_cal_interval;\n\tu32 emc_mode_1;\n\tu32 emc_mode_2;\n\tu32 emc_mode_reset;\n\tu32 emc_zcal_cnt_long;\n\tbool emc_cfg_periodic_qrst;\n\tbool emc_cfg_dyn_self_ref;\n};\n\nenum emc_rate_request_type {\n\tEMC_RATE_DEBUG,\n\tEMC_RATE_ICC,\n\tEMC_RATE_TYPE_MAX,\n};\n\nstruct emc_rate_request {\n\tunsigned long min_rate;\n\tunsigned long max_rate;\n};\n\nstruct tegra_emc {\n\tstruct device *dev;\n\tstruct tegra_mc *mc;\n\tstruct icc_provider provider;\n\tstruct notifier_block clk_nb;\n\tstruct clk *clk;\n\tvoid __iomem *regs;\n\tunsigned int irq;\n\tbool bad_state;\n\n\tstruct emc_timing *new_timing;\n\tstruct emc_timing *timings;\n\tunsigned int num_timings;\n\n\tu32 mc_override;\n\tu32 emc_cfg;\n\n\tu32 emc_mode_1;\n\tu32 emc_mode_2;\n\tu32 emc_mode_reset;\n\n\tbool vref_cal_toggle : 1;\n\tbool zcal_long : 1;\n\tbool dll_on : 1;\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tunsigned long min_rate;\n\t\tunsigned long max_rate;\n\t} debugfs;\n\n\t \n\tstruct emc_rate_request requested_rate[EMC_RATE_TYPE_MAX];\n\n\t \n\tstruct mutex rate_lock;\n\n\tbool mrr_error;\n};\n\nstatic int emc_seq_update_timing(struct tegra_emc *emc)\n{\n\tu32 val;\n\tint err;\n\n\twritel_relaxed(EMC_TIMING_UPDATE, emc->regs + EMC_TIMING_CONTROL);\n\n\terr = readl_relaxed_poll_timeout_atomic(emc->regs + EMC_STATUS, val,\n\t\t\t\t!(val & EMC_STATUS_TIMING_UPDATE_STALLED),\n\t\t\t\t1, 200);\n\tif (err) {\n\t\tdev_err(emc->dev, \"failed to update timing: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra_emc_isr(int irq, void *data)\n{\n\tstruct tegra_emc *emc = data;\n\tu32 intmask = EMC_REFRESH_OVERFLOW_INT;\n\tu32 status;\n\n\tstatus = readl_relaxed(emc->regs + EMC_INTSTATUS) & intmask;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & EMC_REFRESH_OVERFLOW_INT)\n\t\tdev_err_ratelimited(emc->dev,\n\t\t\t\t    \"refresh request overflow timeout\\n\");\n\n\t \n\twritel_relaxed(status, emc->regs + EMC_INTSTATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct emc_timing *emc_find_timing(struct tegra_emc *emc,\n\t\t\t\t\t  unsigned long rate)\n{\n\tstruct emc_timing *timing = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate >= rate) {\n\t\t\ttiming = &emc->timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timing) {\n\t\tdev_err(emc->dev, \"no timing for rate %lu\\n\", rate);\n\t\treturn NULL;\n\t}\n\n\treturn timing;\n}\n\nstatic bool emc_dqs_preset(struct tegra_emc *emc, struct emc_timing *timing,\n\t\t\t   bool *schmitt_to_vref)\n{\n\tbool preset = false;\n\tu32 val;\n\n\tif (timing->data[71] & EMC_XM2DQSPADCTRL2_VREF_ENABLE) {\n\t\tval = readl_relaxed(emc->regs + EMC_XM2DQSPADCTRL2);\n\n\t\tif (!(val & EMC_XM2DQSPADCTRL2_VREF_ENABLE)) {\n\t\t\tval |= EMC_XM2DQSPADCTRL2_VREF_ENABLE;\n\t\t\twritel_relaxed(val, emc->regs + EMC_XM2DQSPADCTRL2);\n\n\t\t\tpreset = true;\n\t\t}\n\t}\n\n\tif (timing->data[78] & EMC_XM2DQSPADCTRL3_VREF_ENABLE) {\n\t\tval = readl_relaxed(emc->regs + EMC_XM2DQSPADCTRL3);\n\n\t\tif (!(val & EMC_XM2DQSPADCTRL3_VREF_ENABLE)) {\n\t\t\tval |= EMC_XM2DQSPADCTRL3_VREF_ENABLE;\n\t\t\twritel_relaxed(val, emc->regs + EMC_XM2DQSPADCTRL3);\n\n\t\t\tpreset = true;\n\t\t}\n\t}\n\n\tif (timing->data[77] & EMC_XM2QUSEPADCTRL_IVREF_ENABLE) {\n\t\tval = readl_relaxed(emc->regs + EMC_XM2QUSEPADCTRL);\n\n\t\tif (!(val & EMC_XM2QUSEPADCTRL_IVREF_ENABLE)) {\n\t\t\tval |= EMC_XM2QUSEPADCTRL_IVREF_ENABLE;\n\t\t\twritel_relaxed(val, emc->regs + EMC_XM2QUSEPADCTRL);\n\n\t\t\t*schmitt_to_vref = true;\n\t\t\tpreset = true;\n\t\t}\n\t}\n\n\treturn preset;\n}\n\nstatic int emc_prepare_mc_clk_cfg(struct tegra_emc *emc, unsigned long rate)\n{\n\tstruct tegra_mc *mc = emc->mc;\n\tunsigned int misc0_index = 16;\n\tunsigned int i;\n\tbool same;\n\n\tfor (i = 0; i < mc->num_timings; i++) {\n\t\tif (mc->timings[i].rate != rate)\n\t\t\tcontinue;\n\n\t\tif (mc->timings[i].emem_data[misc0_index] & BIT(27))\n\t\t\tsame = true;\n\t\telse\n\t\t\tsame = false;\n\n\t\treturn tegra20_clk_prepare_emc_mc_same_freq(emc->clk, same);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int emc_prepare_timing_change(struct tegra_emc *emc, unsigned long rate)\n{\n\tstruct emc_timing *timing = emc_find_timing(emc, rate);\n\tenum emc_dll_change dll_change;\n\tenum emc_dram_type dram_type;\n\tbool schmitt_to_vref = false;\n\tunsigned int pre_wait = 0;\n\tbool qrst_used = false;\n\tunsigned int dram_num;\n\tunsigned int i;\n\tu32 fbio_cfg5;\n\tu32 emc_dbg;\n\tu32 val;\n\tint err;\n\n\tif (!timing || emc->bad_state)\n\t\treturn -EINVAL;\n\n\tdev_dbg(emc->dev, \"%s: using timing rate %lu for requested rate %lu\\n\",\n\t\t__func__, timing->rate, rate);\n\n\temc->bad_state = true;\n\n\terr = emc_prepare_mc_clk_cfg(emc, rate);\n\tif (err) {\n\t\tdev_err(emc->dev, \"mc clock preparation failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\temc->vref_cal_toggle = false;\n\temc->mc_override = mc_readl(emc->mc, MC_EMEM_ARB_OVERRIDE);\n\temc->emc_cfg = readl_relaxed(emc->regs + EMC_CFG);\n\temc_dbg = readl_relaxed(emc->regs + EMC_DBG);\n\n\tif (emc->dll_on == !!(timing->emc_mode_1 & 0x1))\n\t\tdll_change = DLL_CHANGE_NONE;\n\telse if (timing->emc_mode_1 & 0x1)\n\t\tdll_change = DLL_CHANGE_ON;\n\telse\n\t\tdll_change = DLL_CHANGE_OFF;\n\n\temc->dll_on = !!(timing->emc_mode_1 & 0x1);\n\n\tif (timing->data[80] && !readl_relaxed(emc->regs + EMC_ZCAL_INTERVAL))\n\t\temc->zcal_long = true;\n\telse\n\t\temc->zcal_long = false;\n\n\tfbio_cfg5 = readl_relaxed(emc->regs + EMC_FBIO_CFG5);\n\tdram_type = fbio_cfg5 & EMC_FBIO_CFG5_DRAM_TYPE_MASK;\n\n\tdram_num = tegra_mc_get_emem_device_count(emc->mc);\n\n\t \n\tif (emc->emc_cfg & EMC_CFG_DYN_SREF_ENABLE) {\n\t\temc->emc_cfg &= ~EMC_CFG_DYN_SREF_ENABLE;\n\t\twritel_relaxed(emc->emc_cfg, emc->regs + EMC_CFG);\n\n\t\tpre_wait = 5;\n\t}\n\n\t \n\tval = mc_readl(emc->mc, MC_EMEM_ARB_OUTSTANDING_REQ);\n\tif (!(val & MC_EMEM_ARB_OUTSTANDING_REQ_HOLDOFF_OVERRIDE) ||\n\t    ((val & MC_EMEM_ARB_OUTSTANDING_REQ_MAX_MASK) > 0x50)) {\n\n\t\tval = MC_EMEM_ARB_OUTSTANDING_REQ_LIMIT_ENABLE |\n\t\t      MC_EMEM_ARB_OUTSTANDING_REQ_HOLDOFF_OVERRIDE | 0x50;\n\t\tmc_writel(emc->mc, val, MC_EMEM_ARB_OUTSTANDING_REQ);\n\t\tmc_writel(emc->mc, MC_TIMING_UPDATE, MC_TIMING_CONTROL);\n\t}\n\n\tif (emc->mc_override & MC_EMEM_ARB_OVERRIDE_EACK_MASK)\n\t\tmc_writel(emc->mc,\n\t\t\t  emc->mc_override & ~MC_EMEM_ARB_OVERRIDE_EACK_MASK,\n\t\t\t  MC_EMEM_ARB_OVERRIDE);\n\n\t \n\tif (emc_dqs_preset(emc, timing, &schmitt_to_vref)) {\n\t\tif (pre_wait < 3)\n\t\t\tpre_wait = 3;\n\t}\n\n\tif (pre_wait) {\n\t\terr = emc_seq_update_timing(emc);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tudelay(pre_wait);\n\t}\n\n\t \n\tif (timing->emc_auto_cal_interval) {\n\t\tval = readl_relaxed(emc->regs + EMC_XM2COMPPADCTRL);\n\t\tval ^= timing->data[74];\n\n\t\tif (val & EMC_XM2COMPPADCTRL_VREF_CAL_ENABLE) {\n\t\t\twritel_relaxed(0, emc->regs + EMC_AUTO_CAL_INTERVAL);\n\n\t\t\terr = readl_relaxed_poll_timeout_atomic(\n\t\t\t\temc->regs + EMC_AUTO_CAL_STATUS, val,\n\t\t\t\t!(val & EMC_AUTO_CAL_STATUS_ACTIVE), 1, 300);\n\t\t\tif (err) {\n\t\t\t\tdev_err(emc->dev,\n\t\t\t\t\t\"auto-cal finish timeout: %d\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\temc->vref_cal_toggle = true;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(timing->data); i++) {\n\t\t \n\t\tif (i != 73)\n\t\t\twritel_relaxed(timing->data[i],\n\t\t\t\t       emc->regs + emc_timing_registers[i]);\n\t}\n\n\terr = tegra_mc_write_emem_configuration(emc->mc, timing->rate);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dram_type == DRAM_TYPE_DDR3 && dll_change == DLL_CHANGE_ON) {\n\t\tu32 cnt = 512;\n\n\t\tif (emc->zcal_long)\n\t\t\tcnt -= dram_num * 256;\n\n\t\tval = timing->data[82] & EMC_MRS_WAIT_CNT_SHORT_WAIT_MASK;\n\t\tif (cnt < val)\n\t\t\tcnt = val;\n\n\t\tval = timing->data[82] & ~EMC_MRS_WAIT_CNT_LONG_WAIT_MASK;\n\t\tval |= (cnt << EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT) &\n\t\t\tEMC_MRS_WAIT_CNT_LONG_WAIT_MASK;\n\n\t\twritel_relaxed(val, emc->regs + EMC_MRS_WAIT_CNT);\n\t}\n\n\t \n\tval = readl_relaxed(emc->regs + EMC_SEL_DPD_CTRL);\n\n\tif (!(val & EMC_SEL_DPD_CTRL_QUSE_DPD_ENABLE) && schmitt_to_vref) {\n\t\tu32 cur_mode, new_mode;\n\n\t\tcur_mode = fbio_cfg5 & EMC_CFG5_QUSE_MODE_MASK;\n\t\tcur_mode >>= EMC_CFG5_QUSE_MODE_SHIFT;\n\n\t\tnew_mode = timing->data[39] & EMC_CFG5_QUSE_MODE_MASK;\n\t\tnew_mode >>= EMC_CFG5_QUSE_MODE_SHIFT;\n\n\t\tif ((cur_mode != EMC_CFG5_QUSE_MODE_PULSE_INTERN &&\n\t\t     cur_mode != EMC_CFG5_QUSE_MODE_INTERNAL_LPBK) ||\n\t\t    (new_mode != EMC_CFG5_QUSE_MODE_PULSE_INTERN &&\n\t\t     new_mode != EMC_CFG5_QUSE_MODE_INTERNAL_LPBK))\n\t\t\tqrst_used = true;\n\t}\n\n\t \n\twritel_relaxed(0x1, emc->regs + EMC_STALL_THEN_EXE_BEFORE_CLKCHANGE);\n\n\t \n\tif (qrst_used) {\n\t\twritel_relaxed(emc_dbg | EMC_DBG_WRITE_MUX_ACTIVE,\n\t\t\t       emc->regs + EMC_DBG);\n\t\twritel_relaxed(emc->emc_cfg | EMC_CFG_PERIODIC_QRST,\n\t\t\t       emc->regs + EMC_CFG);\n\t\twritel_relaxed(emc_dbg, emc->regs + EMC_DBG);\n\t}\n\n\t \n\twritel_relaxed(EMC_REFCTRL_DISABLE_ALL(dram_num),\n\t\t       emc->regs + EMC_REFCTRL);\n\n\t \n\tif (dram_type == DRAM_TYPE_DDR3) {\n\t\tif (dll_change == DLL_CHANGE_OFF)\n\t\t\twritel_relaxed(timing->emc_mode_1,\n\t\t\t\t       emc->regs + EMC_EMRS);\n\n\t\twritel_relaxed(DRAM_BROADCAST(dram_num) |\n\t\t\t       EMC_SELF_REF_CMD_ENABLED,\n\t\t\t       emc->regs + EMC_SELF_REF);\n\t}\n\n\t \n\twritel_relaxed(0x1, emc->regs + EMC_STALL_THEN_EXE_AFTER_CLKCHANGE);\n\n\t \n\twritel_relaxed(emc_dbg | EMC_DBG_WRITE_MUX_ACTIVE, emc->regs + EMC_DBG);\n\twritel_relaxed(timing->data[73], emc->regs + EMC_XM2CLKPADCTRL);\n\n\t \n\tval = !!(emc->emc_cfg & EMC_CFG_PERIODIC_QRST);\n\tif (qrst_used || timing->emc_cfg_periodic_qrst != val) {\n\t\tif (timing->emc_cfg_periodic_qrst)\n\t\t\temc->emc_cfg |= EMC_CFG_PERIODIC_QRST;\n\t\telse\n\t\t\temc->emc_cfg &= ~EMC_CFG_PERIODIC_QRST;\n\n\t\twritel_relaxed(emc->emc_cfg, emc->regs + EMC_CFG);\n\t}\n\twritel_relaxed(emc_dbg, emc->regs + EMC_DBG);\n\n\t \n\tif (dram_type == DRAM_TYPE_DDR3)\n\t\twritel_relaxed(DRAM_BROADCAST(dram_num),\n\t\t\t       emc->regs + EMC_SELF_REF);\n\n\t \n\tif (dram_type == DRAM_TYPE_DDR3) {\n\t\tif (timing->emc_mode_1 != emc->emc_mode_1)\n\t\t\twritel_relaxed(timing->emc_mode_1,\n\t\t\t\t       emc->regs + EMC_EMRS);\n\n\t\tif (timing->emc_mode_2 != emc->emc_mode_2)\n\t\t\twritel_relaxed(timing->emc_mode_2,\n\t\t\t\t       emc->regs + EMC_EMRS);\n\n\t\tif (timing->emc_mode_reset != emc->emc_mode_reset ||\n\t\t    dll_change == DLL_CHANGE_ON) {\n\t\t\tval = timing->emc_mode_reset;\n\t\t\tif (dll_change == DLL_CHANGE_ON) {\n\t\t\t\tval |= EMC_MODE_SET_DLL_RESET;\n\t\t\t\tval |= EMC_MODE_SET_LONG_CNT;\n\t\t\t} else {\n\t\t\t\tval &= ~EMC_MODE_SET_DLL_RESET;\n\t\t\t}\n\t\t\twritel_relaxed(val, emc->regs + EMC_MRS);\n\t\t}\n\t} else {\n\t\tif (timing->emc_mode_2 != emc->emc_mode_2)\n\t\t\twritel_relaxed(timing->emc_mode_2,\n\t\t\t\t       emc->regs + EMC_MRW);\n\n\t\tif (timing->emc_mode_1 != emc->emc_mode_1)\n\t\t\twritel_relaxed(timing->emc_mode_1,\n\t\t\t\t       emc->regs + EMC_MRW);\n\t}\n\n\temc->emc_mode_1 = timing->emc_mode_1;\n\temc->emc_mode_2 = timing->emc_mode_2;\n\temc->emc_mode_reset = timing->emc_mode_reset;\n\n\t \n\tif (emc->zcal_long) {\n\t\twritel_relaxed(EMC_ZQ_CAL_LONG_CMD_DEV0,\n\t\t\t       emc->regs + EMC_ZQ_CAL);\n\n\t\tif (dram_num > 1)\n\t\t\twritel_relaxed(EMC_ZQ_CAL_LONG_CMD_DEV1,\n\t\t\t\t       emc->regs + EMC_ZQ_CAL);\n\t}\n\n\t \n\twritel_relaxed(0x1, emc->regs + EMC_UNSTALL_RW_AFTER_CLKCHANGE);\n\n\t \n\tmc_readl(emc->mc, MC_EMEM_ARB_OVERRIDE);\n\n\treturn 0;\n}\n\nstatic int emc_complete_timing_change(struct tegra_emc *emc,\n\t\t\t\t      unsigned long rate)\n{\n\tstruct emc_timing *timing = emc_find_timing(emc, rate);\n\tunsigned int dram_num;\n\tint err;\n\tu32 v;\n\n\terr = readl_relaxed_poll_timeout_atomic(emc->regs + EMC_INTSTATUS, v,\n\t\t\t\t\t\tv & EMC_CLKCHANGE_COMPLETE_INT,\n\t\t\t\t\t\t1, 100);\n\tif (err) {\n\t\tdev_err(emc->dev, \"emc-car handshake timeout: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tdram_num = tegra_mc_get_emem_device_count(emc->mc);\n\twritel_relaxed(EMC_REFCTRL_ENABLE_ALL(dram_num),\n\t\t       emc->regs + EMC_REFCTRL);\n\n\t \n\tif (emc->vref_cal_toggle)\n\t\twritel_relaxed(timing->emc_auto_cal_interval,\n\t\t\t       emc->regs + EMC_AUTO_CAL_INTERVAL);\n\n\t \n\tif (timing->emc_cfg_dyn_self_ref) {\n\t\temc->emc_cfg |= EMC_CFG_DYN_SREF_ENABLE;\n\t\twritel_relaxed(emc->emc_cfg, emc->regs + EMC_CFG);\n\t}\n\n\t \n\tif (emc->zcal_long)\n\t\twritel_relaxed(timing->emc_zcal_cnt_long,\n\t\t\t       emc->regs + EMC_ZCAL_WAIT_CNT);\n\n\t \n\tudelay(2);\n\n\t \n\terr = emc_seq_update_timing(emc);\n\tif (!err)\n\t\temc->bad_state = false;\n\n\t \n\tmc_writel(emc->mc, emc->mc_override, MC_EMEM_ARB_OVERRIDE);\n\n\treturn err;\n}\n\nstatic int emc_unprepare_timing_change(struct tegra_emc *emc,\n\t\t\t\t       unsigned long rate)\n{\n\tif (!emc->bad_state) {\n\t\t \n\t\tdev_err(emc->dev, \"timing configuration can't be reverted\\n\");\n\t\temc->bad_state = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int emc_clk_change_notify(struct notifier_block *nb,\n\t\t\t\t unsigned long msg, void *data)\n{\n\tstruct tegra_emc *emc = container_of(nb, struct tegra_emc, clk_nb);\n\tstruct clk_notifier_data *cnd = data;\n\tint err;\n\n\tswitch (msg) {\n\tcase PRE_RATE_CHANGE:\n\t\t \n\t\tdisable_irq(emc->irq);\n\t\terr = emc_prepare_timing_change(emc, cnd->new_rate);\n\t\tenable_irq(emc->irq);\n\t\tbreak;\n\n\tcase ABORT_RATE_CHANGE:\n\t\terr = emc_unprepare_timing_change(emc, cnd->old_rate);\n\t\tbreak;\n\n\tcase POST_RATE_CHANGE:\n\t\terr = emc_complete_timing_change(emc, cnd->new_rate);\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic int load_one_timing_from_dt(struct tegra_emc *emc,\n\t\t\t\t   struct emc_timing *timing,\n\t\t\t\t   struct device_node *node)\n{\n\tu32 value;\n\tint err;\n\n\terr = of_property_read_u32(node, \"clock-frequency\", &value);\n\tif (err) {\n\t\tdev_err(emc->dev, \"timing %pOF: failed to read rate: %d\\n\",\n\t\t\tnode, err);\n\t\treturn err;\n\t}\n\n\ttiming->rate = value;\n\n\terr = of_property_read_u32_array(node, \"nvidia,emc-configuration\",\n\t\t\t\t\t timing->data,\n\t\t\t\t\t ARRAY_SIZE(emc_timing_registers));\n\tif (err) {\n\t\tdev_err(emc->dev,\n\t\t\t\"timing %pOF: failed to read emc timing data: %d\\n\",\n\t\t\tnode, err);\n\t\treturn err;\n\t}\n\n#define EMC_READ_BOOL(prop, dtprop) \\\n\ttiming->prop = of_property_read_bool(node, dtprop);\n\n#define EMC_READ_U32(prop, dtprop) \\\n\terr = of_property_read_u32(node, dtprop, &timing->prop); \\\n\tif (err) { \\\n\t\tdev_err(emc->dev, \\\n\t\t\t\"timing %pOFn: failed to read \" #prop \": %d\\n\", \\\n\t\t\tnode, err); \\\n\t\treturn err; \\\n\t}\n\n\tEMC_READ_U32(emc_auto_cal_interval, \"nvidia,emc-auto-cal-interval\")\n\tEMC_READ_U32(emc_mode_1, \"nvidia,emc-mode-1\")\n\tEMC_READ_U32(emc_mode_2, \"nvidia,emc-mode-2\")\n\tEMC_READ_U32(emc_mode_reset, \"nvidia,emc-mode-reset\")\n\tEMC_READ_U32(emc_zcal_cnt_long, \"nvidia,emc-zcal-cnt-long\")\n\tEMC_READ_BOOL(emc_cfg_dyn_self_ref, \"nvidia,emc-cfg-dyn-self-ref\")\n\tEMC_READ_BOOL(emc_cfg_periodic_qrst, \"nvidia,emc-cfg-periodic-qrst\")\n\n#undef EMC_READ_U32\n#undef EMC_READ_BOOL\n\n\tdev_dbg(emc->dev, \"%s: %pOF: rate %lu\\n\", __func__, node, timing->rate);\n\n\treturn 0;\n}\n\nstatic int cmp_timings(const void *_a, const void *_b)\n{\n\tconst struct emc_timing *a = _a;\n\tconst struct emc_timing *b = _b;\n\n\tif (a->rate < b->rate)\n\t\treturn -1;\n\n\tif (a->rate > b->rate)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int emc_check_mc_timings(struct tegra_emc *emc)\n{\n\tstruct tegra_mc *mc = emc->mc;\n\tunsigned int i;\n\n\tif (emc->num_timings != mc->num_timings) {\n\t\tdev_err(emc->dev, \"emc/mc timings number mismatch: %u %u\\n\",\n\t\t\temc->num_timings, mc->num_timings);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < mc->num_timings; i++) {\n\t\tif (emc->timings[i].rate != mc->timings[i].rate) {\n\t\t\tdev_err(emc->dev,\n\t\t\t\t\"emc/mc timing rate mismatch: %lu %lu\\n\",\n\t\t\t\temc->timings[i].rate, mc->timings[i].rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int emc_load_timings_from_dt(struct tegra_emc *emc,\n\t\t\t\t    struct device_node *node)\n{\n\tstruct device_node *child;\n\tstruct emc_timing *timing;\n\tint child_count;\n\tint err;\n\n\tchild_count = of_get_child_count(node);\n\tif (!child_count) {\n\t\tdev_err(emc->dev, \"no memory timings in: %pOF\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\temc->timings = devm_kcalloc(emc->dev, child_count, sizeof(*timing),\n\t\t\t\t    GFP_KERNEL);\n\tif (!emc->timings)\n\t\treturn -ENOMEM;\n\n\temc->num_timings = child_count;\n\ttiming = emc->timings;\n\n\tfor_each_child_of_node(node, child) {\n\t\terr = load_one_timing_from_dt(emc, timing++, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tsort(emc->timings, emc->num_timings, sizeof(*timing), cmp_timings,\n\t     NULL);\n\n\terr = emc_check_mc_timings(emc);\n\tif (err)\n\t\treturn err;\n\n\tdev_info_once(emc->dev,\n\t\t      \"got %u timings for RAM code %u (min %luMHz max %luMHz)\\n\",\n\t\t      emc->num_timings,\n\t\t      tegra_read_ram_code(),\n\t\t      emc->timings[0].rate / 1000000,\n\t\t      emc->timings[emc->num_timings - 1].rate / 1000000);\n\n\treturn 0;\n}\n\nstatic struct device_node *emc_find_node_by_ram_code(struct tegra_emc *emc)\n{\n\tstruct device *dev = emc->dev;\n\tstruct device_node *np;\n\tu32 value, ram_code;\n\tint err;\n\n\tif (emc->mrr_error) {\n\t\tdev_warn(dev, \"memory timings skipped due to MRR error\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (of_get_child_count(dev->of_node) == 0) {\n\t\tdev_info_once(dev, \"device-tree doesn't have memory timings\\n\");\n\t\treturn NULL;\n\t}\n\n\tram_code = tegra_read_ram_code();\n\n\tfor_each_child_of_node(dev->of_node, np) {\n\t\terr = of_property_read_u32(np, \"nvidia,ram-code\", &value);\n\t\tif (err || value != ram_code)\n\t\t\tcontinue;\n\n\t\treturn np;\n\t}\n\n\tdev_err(dev, \"no memory timings for RAM code %u found in device-tree\\n\",\n\t\tram_code);\n\n\treturn NULL;\n}\n\nstatic int emc_read_lpddr_mode_register(struct tegra_emc *emc,\n\t\t\t\t\tunsigned int emem_dev,\n\t\t\t\t\tunsigned int register_addr,\n\t\t\t\t\tunsigned int *register_data)\n{\n\tu32 memory_dev = emem_dev ? 1 : 2;\n\tu32 val, mr_mask = 0xff;\n\tint err;\n\n\t \n\twritel_relaxed(EMC_MRR_DIVLD_INT, emc->regs + EMC_INTSTATUS);\n\n\t \n\tval  = FIELD_PREP(EMC_MRR_DEV_SELECTN, memory_dev);\n\tval |= FIELD_PREP(EMC_MRR_MRR_MA, register_addr);\n\n\twritel_relaxed(val, emc->regs + EMC_MRR);\n\n\t \n\terr = readl_relaxed_poll_timeout_atomic(emc->regs + EMC_INTSTATUS, val,\n\t\t\t\t\t\tval & EMC_MRR_DIVLD_INT,\n\t\t\t\t\t\t1, 100);\n\tif (err) {\n\t\tdev_err(emc->dev, \"mode register %u read failed: %d\\n\",\n\t\t\tregister_addr, err);\n\t\temc->mrr_error = true;\n\t\treturn err;\n\t}\n\n\t \n\tval = readl_relaxed(emc->regs + EMC_MRR);\n\t*register_data = FIELD_GET(EMC_MRR_MRR_DATA, val) & mr_mask;\n\n\treturn 0;\n}\n\nstatic void emc_read_lpddr_sdram_info(struct tegra_emc *emc,\n\t\t\t\t      unsigned int emem_dev)\n{\n\tunion lpddr2_basic_config4 basic_conf4;\n\tunsigned int manufacturer_id;\n\tunsigned int revision_id1;\n\tunsigned int revision_id2;\n\n\t \n\temc_read_lpddr_mode_register(emc, emem_dev, 5, &manufacturer_id);\n\temc_read_lpddr_mode_register(emc, emem_dev, 6, &revision_id1);\n\temc_read_lpddr_mode_register(emc, emem_dev, 7, &revision_id2);\n\temc_read_lpddr_mode_register(emc, emem_dev, 8, &basic_conf4.value);\n\n\tdev_info(emc->dev, \"SDRAM[dev%u]: manufacturer: 0x%x (%s) rev1: 0x%x rev2: 0x%x prefetch: S%u density: %uMbit iowidth: %ubit\\n\",\n\t\t emem_dev, manufacturer_id,\n\t\t lpddr2_jedec_manufacturer(manufacturer_id),\n\t\t revision_id1, revision_id2,\n\t\t 4 >> basic_conf4.arch_type,\n\t\t 64 << basic_conf4.density,\n\t\t 32 >> basic_conf4.io_width);\n}\n\nstatic int emc_setup_hw(struct tegra_emc *emc)\n{\n\tu32 fbio_cfg5, emc_cfg, emc_dbg, emc_adr_cfg;\n\tu32 intmask = EMC_REFRESH_OVERFLOW_INT;\n\tstatic bool print_sdram_info_once;\n\tenum emc_dram_type dram_type;\n\tconst char *dram_type_str;\n\tunsigned int emem_numdev;\n\n\tfbio_cfg5 = readl_relaxed(emc->regs + EMC_FBIO_CFG5);\n\tdram_type = fbio_cfg5 & EMC_FBIO_CFG5_DRAM_TYPE_MASK;\n\n\temc_cfg = readl_relaxed(emc->regs + EMC_CFG_2);\n\n\t \n\temc_cfg |= EMC_CLKCHANGE_REQ_ENABLE;\n\n\t \n\tswitch (dram_type) {\n\tcase DRAM_TYPE_LPDDR2:\n\t\temc_cfg |= EMC_CLKCHANGE_PD_ENABLE;\n\t\temc_cfg &= ~EMC_CLKCHANGE_SR_ENABLE;\n\t\tbreak;\n\n\tdefault:\n\t\temc_cfg &= ~EMC_CLKCHANGE_SR_ENABLE;\n\t\temc_cfg &= ~EMC_CLKCHANGE_PD_ENABLE;\n\t\tbreak;\n\t}\n\n\twritel_relaxed(emc_cfg, emc->regs + EMC_CFG_2);\n\n\t \n\twritel_relaxed(intmask, emc->regs + EMC_INTMASK);\n\twritel_relaxed(0xffffffff, emc->regs + EMC_INTSTATUS);\n\n\t \n\temc_dbg = readl_relaxed(emc->regs + EMC_DBG);\n\temc_dbg |= EMC_DBG_CFG_PRIORITY;\n\temc_dbg &= ~EMC_DBG_READ_MUX_ASSEMBLY;\n\temc_dbg &= ~EMC_DBG_WRITE_MUX_ACTIVE;\n\temc_dbg &= ~EMC_DBG_FORCE_UPDATE;\n\twritel_relaxed(emc_dbg, emc->regs + EMC_DBG);\n\n\tswitch (dram_type) {\n\tcase DRAM_TYPE_DDR1:\n\t\tdram_type_str = \"DDR1\";\n\t\tbreak;\n\tcase DRAM_TYPE_LPDDR2:\n\t\tdram_type_str = \"LPDDR2\";\n\t\tbreak;\n\tcase DRAM_TYPE_DDR2:\n\t\tdram_type_str = \"DDR2\";\n\t\tbreak;\n\tcase DRAM_TYPE_DDR3:\n\t\tdram_type_str = \"DDR3\";\n\t\tbreak;\n\t}\n\n\temc_adr_cfg = readl_relaxed(emc->regs + EMC_ADR_CFG);\n\temem_numdev = FIELD_GET(EMC_ADR_CFG_EMEM_NUMDEV, emc_adr_cfg) + 1;\n\n\tdev_info_once(emc->dev, \"%u %s %s attached\\n\", emem_numdev,\n\t\t      dram_type_str, emem_numdev == 2 ? \"devices\" : \"device\");\n\n\tif (dram_type == DRAM_TYPE_LPDDR2 && !print_sdram_info_once) {\n\t\twhile (emem_numdev--)\n\t\t\temc_read_lpddr_sdram_info(emc, emem_numdev);\n\n\t\tprint_sdram_info_once = true;\n\t}\n\n\treturn 0;\n}\n\nstatic long emc_round_rate(unsigned long rate,\n\t\t\t   unsigned long min_rate,\n\t\t\t   unsigned long max_rate,\n\t\t\t   void *arg)\n{\n\tstruct emc_timing *timing = NULL;\n\tstruct tegra_emc *emc = arg;\n\tunsigned int i;\n\n\tif (!emc->num_timings)\n\t\treturn clk_get_rate(emc->clk);\n\n\tmin_rate = min(min_rate, emc->timings[emc->num_timings - 1].rate);\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate < rate && i != emc->num_timings - 1)\n\t\t\tcontinue;\n\n\t\tif (emc->timings[i].rate > max_rate) {\n\t\t\ti = max(i, 1u) - 1;\n\n\t\t\tif (emc->timings[i].rate < min_rate)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (emc->timings[i].rate < min_rate)\n\t\t\tcontinue;\n\n\t\ttiming = &emc->timings[i];\n\t\tbreak;\n\t}\n\n\tif (!timing) {\n\t\tdev_err(emc->dev, \"no timing for rate %lu min %lu max %lu\\n\",\n\t\t\trate, min_rate, max_rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn timing->rate;\n}\n\nstatic void tegra_emc_rate_requests_init(struct tegra_emc *emc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < EMC_RATE_TYPE_MAX; i++) {\n\t\temc->requested_rate[i].min_rate = 0;\n\t\temc->requested_rate[i].max_rate = ULONG_MAX;\n\t}\n}\n\nstatic int emc_request_rate(struct tegra_emc *emc,\n\t\t\t    unsigned long new_min_rate,\n\t\t\t    unsigned long new_max_rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = emc->requested_rate;\n\tunsigned long min_rate = 0, max_rate = ULONG_MAX;\n\tunsigned int i;\n\tint err;\n\n\t \n\tfor (i = 0; i < EMC_RATE_TYPE_MAX; i++, req++) {\n\t\tif (i == type) {\n\t\t\tmin_rate = max(new_min_rate, min_rate);\n\t\t\tmax_rate = min(new_max_rate, max_rate);\n\t\t} else {\n\t\t\tmin_rate = max(req->min_rate, min_rate);\n\t\t\tmax_rate = min(req->max_rate, max_rate);\n\t\t}\n\t}\n\n\tif (min_rate > max_rate) {\n\t\tdev_err_ratelimited(emc->dev, \"%s: type %u: out of range: %lu %lu\\n\",\n\t\t\t\t    __func__, type, min_rate, max_rate);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\terr = dev_pm_opp_set_rate(emc->dev, min_rate);\n\tif (err)\n\t\treturn err;\n\n\temc->requested_rate[type].min_rate = new_min_rate;\n\temc->requested_rate[type].max_rate = new_max_rate;\n\n\treturn 0;\n}\n\nstatic int emc_set_min_rate(struct tegra_emc *emc, unsigned long rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = &emc->requested_rate[type];\n\tint ret;\n\n\tmutex_lock(&emc->rate_lock);\n\tret = emc_request_rate(emc, rate, req->max_rate, type);\n\tmutex_unlock(&emc->rate_lock);\n\n\treturn ret;\n}\n\nstatic int emc_set_max_rate(struct tegra_emc *emc, unsigned long rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = &emc->requested_rate[type];\n\tint ret;\n\n\tmutex_lock(&emc->rate_lock);\n\tret = emc_request_rate(emc, req->min_rate, rate, type);\n\tmutex_unlock(&emc->rate_lock);\n\n\treturn ret;\n}\n\n \n\nstatic bool tegra_emc_validate_rate(struct tegra_emc *emc, unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++)\n\t\tif (rate == emc->timings[i].rate)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra_emc_debug_available_rates_show(struct seq_file *s, void *data)\n{\n\tstruct tegra_emc *emc = s->private;\n\tconst char *prefix = \"\";\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tseq_printf(s, \"%s%lu\", prefix, emc->timings[i].rate);\n\t\tprefix = \" \";\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tegra_emc_debug_available_rates);\n\nstatic int tegra_emc_debug_min_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra_emc *emc = data;\n\n\t*rate = emc->debugfs.min_rate;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_debug_min_rate_set(void *data, u64 rate)\n{\n\tstruct tegra_emc *emc = data;\n\tint err;\n\n\tif (!tegra_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = emc_set_min_rate(emc, rate, EMC_RATE_DEBUG);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.min_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra_emc_debug_min_rate_fops,\n\t\t\ttegra_emc_debug_min_rate_get,\n\t\t\ttegra_emc_debug_min_rate_set, \"%llu\\n\");\n\nstatic int tegra_emc_debug_max_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra_emc *emc = data;\n\n\t*rate = emc->debugfs.max_rate;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_debug_max_rate_set(void *data, u64 rate)\n{\n\tstruct tegra_emc *emc = data;\n\tint err;\n\n\tif (!tegra_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = emc_set_max_rate(emc, rate, EMC_RATE_DEBUG);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.max_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra_emc_debug_max_rate_fops,\n\t\t\ttegra_emc_debug_max_rate_get,\n\t\t\ttegra_emc_debug_max_rate_set, \"%llu\\n\");\n\nstatic void tegra_emc_debugfs_init(struct tegra_emc *emc)\n{\n\tstruct device *dev = emc->dev;\n\tunsigned int i;\n\tint err;\n\n\temc->debugfs.min_rate = ULONG_MAX;\n\temc->debugfs.max_rate = 0;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate < emc->debugfs.min_rate)\n\t\t\temc->debugfs.min_rate = emc->timings[i].rate;\n\n\t\tif (emc->timings[i].rate > emc->debugfs.max_rate)\n\t\t\temc->debugfs.max_rate = emc->timings[i].rate;\n\t}\n\n\tif (!emc->num_timings) {\n\t\temc->debugfs.min_rate = clk_get_rate(emc->clk);\n\t\temc->debugfs.max_rate = emc->debugfs.min_rate;\n\t}\n\n\terr = clk_set_rate_range(emc->clk, emc->debugfs.min_rate,\n\t\t\t\t emc->debugfs.max_rate);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to set rate range [%lu-%lu] for %pC\\n\",\n\t\t\temc->debugfs.min_rate, emc->debugfs.max_rate,\n\t\t\temc->clk);\n\t}\n\n\temc->debugfs.root = debugfs_create_dir(\"emc\", NULL);\n\n\tdebugfs_create_file(\"available_rates\", 0444, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_available_rates_fops);\n\tdebugfs_create_file(\"min_rate\", 0644, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_min_rate_fops);\n\tdebugfs_create_file(\"max_rate\", 0644, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_max_rate_fops);\n}\n\nstatic inline struct tegra_emc *\nto_tegra_emc_provider(struct icc_provider *provider)\n{\n\treturn container_of(provider, struct tegra_emc, provider);\n}\n\nstatic struct icc_node_data *\nemc_of_icc_xlate_extended(struct of_phandle_args *spec, void *data)\n{\n\tstruct icc_provider *provider = data;\n\tstruct icc_node_data *ndata;\n\tstruct icc_node *node;\n\n\t \n\tlist_for_each_entry(node, &provider->nodes, node_list) {\n\t\tif (node->id != TEGRA_ICC_EMEM)\n\t\t\tcontinue;\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_KERNEL);\n\t\tif (!ndata)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t \n\t\tndata->tag = TEGRA_MC_ICC_TAG_ISO;\n\t\tndata->node = node;\n\n\t\treturn ndata;\n\t}\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic int emc_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct tegra_emc *emc = to_tegra_emc_provider(dst->provider);\n\tunsigned long long peak_bw = icc_units_to_bps(dst->peak_bw);\n\tunsigned long long avg_bw = icc_units_to_bps(dst->avg_bw);\n\tunsigned long long rate = max(avg_bw, peak_bw);\n\tconst unsigned int dram_data_bus_width_bytes = 4;\n\tconst unsigned int ddr = 2;\n\tint err;\n\n\t \n\tdo_div(rate, ddr * dram_data_bus_width_bytes);\n\trate = min_t(u64, rate, U32_MAX);\n\n\terr = emc_set_min_rate(emc, rate, EMC_RATE_ICC);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_interconnect_init(struct tegra_emc *emc)\n{\n\tconst struct tegra_mc_soc *soc = emc->mc->soc;\n\tstruct icc_node *node;\n\tint err;\n\n\temc->provider.dev = emc->dev;\n\temc->provider.set = emc_icc_set;\n\temc->provider.data = &emc->provider;\n\temc->provider.aggregate = soc->icc_ops->aggregate;\n\temc->provider.xlate_extended = emc_of_icc_xlate_extended;\n\n\ticc_provider_init(&emc->provider);\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMC);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto err_msg;\n\t}\n\n\tnode->name = \"External Memory Controller\";\n\ticc_node_add(node, &emc->provider);\n\n\t \n\terr = icc_link_create(node, TEGRA_ICC_EMEM);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMEM);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto remove_nodes;\n\t}\n\n\tnode->name = \"External Memory (DRAM)\";\n\ticc_node_add(node, &emc->provider);\n\n\terr = icc_provider_register(&emc->provider);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\treturn 0;\n\nremove_nodes:\n\ticc_nodes_remove(&emc->provider);\nerr_msg:\n\tdev_err(emc->dev, \"failed to initialize ICC: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void devm_tegra_emc_unset_callback(void *data)\n{\n\ttegra20_clk_set_emc_round_callback(NULL, NULL);\n}\n\nstatic void devm_tegra_emc_unreg_clk_notifier(void *data)\n{\n\tstruct tegra_emc *emc = data;\n\n\tclk_notifier_unregister(emc->clk, &emc->clk_nb);\n}\n\nstatic int tegra_emc_init_clk(struct tegra_emc *emc)\n{\n\tint err;\n\n\ttegra20_clk_set_emc_round_callback(emc_round_rate, emc);\n\n\terr = devm_add_action_or_reset(emc->dev, devm_tegra_emc_unset_callback,\n\t\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\n\temc->clk = devm_clk_get(emc->dev, NULL);\n\tif (IS_ERR(emc->clk)) {\n\t\tdev_err(emc->dev, \"failed to get EMC clock: %pe\\n\", emc->clk);\n\t\treturn PTR_ERR(emc->clk);\n\t}\n\n\terr = clk_notifier_register(emc->clk, &emc->clk_nb);\n\tif (err) {\n\t\tdev_err(emc->dev, \"failed to register clk notifier: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(emc->dev,\n\t\t\t\t       devm_tegra_emc_unreg_clk_notifier, emc);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_core_opp_params opp_params = {};\n\tstruct device_node *np;\n\tstruct tegra_emc *emc;\n\tint err;\n\n\temc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn -ENOMEM;\n\n\temc->mc = devm_tegra_memory_controller_get(&pdev->dev);\n\tif (IS_ERR(emc->mc))\n\t\treturn PTR_ERR(emc->mc);\n\n\tmutex_init(&emc->rate_lock);\n\temc->clk_nb.notifier_call = emc_clk_change_notify;\n\temc->dev = &pdev->dev;\n\n\temc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(emc->regs))\n\t\treturn PTR_ERR(emc->regs);\n\n\terr = emc_setup_hw(emc);\n\tif (err)\n\t\treturn err;\n\n\tnp = emc_find_node_by_ram_code(emc);\n\tif (np) {\n\t\terr = emc_load_timings_from_dt(emc, np);\n\t\tof_node_put(np);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->irq = err;\n\n\terr = devm_request_irq(&pdev->dev, emc->irq, tegra_emc_isr, 0,\n\t\t\t       dev_name(&pdev->dev), emc);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to request irq: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_emc_init_clk(emc);\n\tif (err)\n\t\treturn err;\n\n\topp_params.init_state = true;\n\n\terr = devm_tegra_core_dev_init_opp_table(&pdev->dev, &opp_params);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, emc);\n\ttegra_emc_rate_requests_init(emc);\n\ttegra_emc_debugfs_init(emc);\n\ttegra_emc_interconnect_init(emc);\n\n\t \n\ttry_module_get(THIS_MODULE);\n\n\treturn 0;\n}\n\nstatic int tegra_emc_suspend(struct device *dev)\n{\n\tstruct tegra_emc *emc = dev_get_drvdata(dev);\n\tint err;\n\n\t \n\terr = clk_rate_exclusive_get(emc->clk);\n\tif (err) {\n\t\tdev_err(emc->dev, \"failed to acquire clk: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (WARN(emc->bad_state, \"hardware in a bad state\\n\"))\n\t\treturn -EINVAL;\n\n\temc->bad_state = true;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_resume(struct device *dev)\n{\n\tstruct tegra_emc *emc = dev_get_drvdata(dev);\n\n\temc_setup_hw(emc);\n\temc->bad_state = false;\n\n\tclk_rate_exclusive_put(emc->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_emc_pm_ops = {\n\t.suspend = tegra_emc_suspend,\n\t.resume = tegra_emc_resume,\n};\n\nstatic const struct of_device_id tegra_emc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra30-emc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra_emc_of_match);\n\nstatic struct platform_driver tegra_emc_driver = {\n\t.probe = tegra_emc_probe,\n\t.driver = {\n\t\t.name = \"tegra30-emc\",\n\t\t.of_match_table = tegra_emc_of_match,\n\t\t.pm = &tegra_emc_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t\t.sync_state = icc_sync_state,\n\t},\n};\nmodule_platform_driver(tegra_emc_driver);\n\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra30 EMC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}