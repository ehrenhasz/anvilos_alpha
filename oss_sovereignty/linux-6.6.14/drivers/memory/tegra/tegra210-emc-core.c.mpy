{
  "module_name": "tegra210-emc-core.c",
  "hash_id": "bfae4bfc9f29171f10502d1d5ff20ba83eed41916f6999af8c73e77fd36cdfef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/tegra210-emc-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk/tegra.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/mc.h>\n\n#include \"tegra210-emc.h\"\n#include \"tegra210-mc.h\"\n\n \n#define EMC_CLK_EMC_2X_CLK_SRC_SHIFT\t\t\t29\n#define EMC_CLK_EMC_2X_CLK_SRC_MASK\t\t\t\\\n\t(0x7 << EMC_CLK_EMC_2X_CLK_SRC_SHIFT)\n#define EMC_CLK_SOURCE_PLLM_LJ\t\t\t\t0x4\n#define EMC_CLK_SOURCE_PLLMB_LJ\t\t\t\t0x5\n#define EMC_CLK_FORCE_CC_TRIGGER\t\t\tBIT(27)\n#define EMC_CLK_MC_EMC_SAME_FREQ\t\t\tBIT(16)\n#define EMC_CLK_EMC_2X_CLK_DIVISOR_SHIFT\t\t0\n#define EMC_CLK_EMC_2X_CLK_DIVISOR_MASK\t\t\t\\\n\t(0xff << EMC_CLK_EMC_2X_CLK_DIVISOR_SHIFT)\n\n \n#define DLL_CLK_EMC_DLL_CLK_SRC_SHIFT\t\t\t29\n#define DLL_CLK_EMC_DLL_CLK_SRC_MASK\t\t\t\\\n\t(0x7 << DLL_CLK_EMC_DLL_CLK_SRC_SHIFT)\n#define DLL_CLK_EMC_DLL_DDLL_CLK_SEL_SHIFT\t\t10\n#define DLL_CLK_EMC_DLL_DDLL_CLK_SEL_MASK\t\t\\\n\t(0x3 << DLL_CLK_EMC_DLL_DDLL_CLK_SEL_SHIFT)\n#define PLLM_VCOA\t\t\t\t\t0\n#define PLLM_VCOB\t\t\t\t\t1\n#define EMC_DLL_SWITCH_OUT\t\t\t\t2\n#define DLL_CLK_EMC_DLL_CLK_DIVISOR_SHIFT\t\t0\n#define DLL_CLK_EMC_DLL_CLK_DIVISOR_MASK\t\t\\\n\t(0xff << DLL_CLK_EMC_DLL_CLK_DIVISOR_SHIFT)\n\n \n#define MC_EMEM_ARB_MISC0_EMC_SAME_FREQ\t\t\tBIT(27)\n\n \n#define EMC0_EMC_DATA_BRLSHFT_0_INDEX\t2\n#define EMC1_EMC_DATA_BRLSHFT_0_INDEX\t3\n#define EMC0_EMC_DATA_BRLSHFT_1_INDEX\t4\n#define EMC1_EMC_DATA_BRLSHFT_1_INDEX\t5\n\n#define TRIM_REG(chan, rank, reg, byte)\t\t\t\t\t\\\n\t(((EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ## rank ## _ ## reg ##\t\\\n\t   _OB_DDLL_LONG_DQ_RANK ## rank ## _BYTE ## byte ## _MASK &\t\\\n\t   next->trim_regs[EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ##\t\t\\\n\t\t\t\t rank ## _ ## reg ## _INDEX]) >>\t\\\n\t  EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ## rank ## _ ## reg ##\t\\\n\t  _OB_DDLL_LONG_DQ_RANK ## rank ## _BYTE ## byte ## _SHIFT)\t\\\n\t +\t\t\t\t\t\t\t\t\\\n\t (((EMC_DATA_BRLSHFT_ ## rank ## _RANK ## rank ## _BYTE ##\t\\\n\t    byte ## _DATA_BRLSHFT_MASK &\t\t\t\t\\\n\t    next->trim_perch_regs[EMC ## chan ##\t\t\t\\\n\t\t\t      _EMC_DATA_BRLSHFT_ ## rank ## _INDEX]) >>\t\\\n\t   EMC_DATA_BRLSHFT_ ## rank ## _RANK ## rank ## _BYTE ##\t\\\n\t   byte ## _DATA_BRLSHFT_SHIFT) * 64))\n\n#define CALC_TEMP(rank, reg, byte1, byte2, n)\t\t\t\t\\\n\t(((new[n] << EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ## rank ## _ ##\t\\\n\t   reg ## _OB_DDLL_LONG_DQ_RANK ## rank ## _BYTE ## byte1 ## _SHIFT) & \\\n\t  EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ## rank ## _ ## reg ##\t\\\n\t  _OB_DDLL_LONG_DQ_RANK ## rank ## _BYTE ## byte1 ## _MASK)\t\\\n\t |\t\t\t\t\t\t\t\t\\\n\t ((new[n + 1] << EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ## rank ## _ ##\\\n\t   reg ## _OB_DDLL_LONG_DQ_RANK ## rank ## _BYTE ## byte2 ## _SHIFT) & \\\n\t  EMC_PMACRO_OB_DDLL_LONG_DQ_RANK ## rank ## _ ## reg ##\t\\\n\t  _OB_DDLL_LONG_DQ_RANK ## rank ## _BYTE ## byte2 ## _MASK))\n\n#define REFRESH_SPEEDUP(value, speedup) \\\n\t\t(((value) & 0xffff0000) | ((value) & 0xffff) * (speedup))\n\n#define LPDDR2_MR4_SRR GENMASK(2, 0)\n\nstatic const struct tegra210_emc_sequence *tegra210_emc_sequences[] = {\n\t&tegra210_emc_r21021,\n};\n\nstatic const struct tegra210_emc_table_register_offsets\ntegra210_emc_table_register_offsets = {\n\t.burst = {\n\t\tEMC_RC,\n\t\tEMC_RFC,\n\t\tEMC_RFCPB,\n\t\tEMC_REFCTRL2,\n\t\tEMC_RFC_SLR,\n\t\tEMC_RAS,\n\t\tEMC_RP,\n\t\tEMC_R2W,\n\t\tEMC_W2R,\n\t\tEMC_R2P,\n\t\tEMC_W2P,\n\t\tEMC_R2R,\n\t\tEMC_TPPD,\n\t\tEMC_CCDMW,\n\t\tEMC_RD_RCD,\n\t\tEMC_WR_RCD,\n\t\tEMC_RRD,\n\t\tEMC_REXT,\n\t\tEMC_WEXT,\n\t\tEMC_WDV_CHK,\n\t\tEMC_WDV,\n\t\tEMC_WSV,\n\t\tEMC_WEV,\n\t\tEMC_WDV_MASK,\n\t\tEMC_WS_DURATION,\n\t\tEMC_WE_DURATION,\n\t\tEMC_QUSE,\n\t\tEMC_QUSE_WIDTH,\n\t\tEMC_IBDLY,\n\t\tEMC_OBDLY,\n\t\tEMC_EINPUT,\n\t\tEMC_MRW6,\n\t\tEMC_EINPUT_DURATION,\n\t\tEMC_PUTERM_EXTRA,\n\t\tEMC_PUTERM_WIDTH,\n\t\tEMC_QRST,\n\t\tEMC_QSAFE,\n\t\tEMC_RDV,\n\t\tEMC_RDV_MASK,\n\t\tEMC_RDV_EARLY,\n\t\tEMC_RDV_EARLY_MASK,\n\t\tEMC_REFRESH,\n\t\tEMC_BURST_REFRESH_NUM,\n\t\tEMC_PRE_REFRESH_REQ_CNT,\n\t\tEMC_PDEX2WR,\n\t\tEMC_PDEX2RD,\n\t\tEMC_PCHG2PDEN,\n\t\tEMC_ACT2PDEN,\n\t\tEMC_AR2PDEN,\n\t\tEMC_RW2PDEN,\n\t\tEMC_CKE2PDEN,\n\t\tEMC_PDEX2CKE,\n\t\tEMC_PDEX2MRR,\n\t\tEMC_TXSR,\n\t\tEMC_TXSRDLL,\n\t\tEMC_TCKE,\n\t\tEMC_TCKESR,\n\t\tEMC_TPD,\n\t\tEMC_TFAW,\n\t\tEMC_TRPAB,\n\t\tEMC_TCLKSTABLE,\n\t\tEMC_TCLKSTOP,\n\t\tEMC_MRW7,\n\t\tEMC_TREFBW,\n\t\tEMC_ODT_WRITE,\n\t\tEMC_FBIO_CFG5,\n\t\tEMC_FBIO_CFG7,\n\t\tEMC_CFG_DIG_DLL,\n\t\tEMC_CFG_DIG_DLL_PERIOD,\n\t\tEMC_PMACRO_IB_RXRT,\n\t\tEMC_CFG_PIPE_1,\n\t\tEMC_CFG_PIPE_2,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK0_4,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK0_5,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK1_4,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK1_5,\n\t\tEMC_MRW8,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_4,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_5,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_0,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_1,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_2,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_3,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_4,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_5,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_0,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_1,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_2,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_3,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_4,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_5,\n\t\tEMC_PMACRO_DDLL_LONG_CMD_0,\n\t\tEMC_PMACRO_DDLL_LONG_CMD_1,\n\t\tEMC_PMACRO_DDLL_LONG_CMD_2,\n\t\tEMC_PMACRO_DDLL_LONG_CMD_3,\n\t\tEMC_PMACRO_DDLL_LONG_CMD_4,\n\t\tEMC_PMACRO_DDLL_SHORT_CMD_0,\n\t\tEMC_PMACRO_DDLL_SHORT_CMD_1,\n\t\tEMC_PMACRO_DDLL_SHORT_CMD_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_3,\n\t\tEMC_TXDSRVTTGEN,\n\t\tEMC_FDPD_CTRL_DQ,\n\t\tEMC_FDPD_CTRL_CMD,\n\t\tEMC_FBIO_SPARE,\n\t\tEMC_ZCAL_INTERVAL,\n\t\tEMC_ZCAL_WAIT_CNT,\n\t\tEMC_MRS_WAIT_CNT,\n\t\tEMC_MRS_WAIT_CNT2,\n\t\tEMC_AUTO_CAL_CHANNEL,\n\t\tEMC_DLL_CFG_0,\n\t\tEMC_DLL_CFG_1,\n\t\tEMC_PMACRO_AUTOCAL_CFG_COMMON,\n\t\tEMC_PMACRO_ZCTRL,\n\t\tEMC_CFG,\n\t\tEMC_CFG_PIPE,\n\t\tEMC_DYN_SELF_REF_CONTROL,\n\t\tEMC_QPOP,\n\t\tEMC_DQS_BRLSHFT_0,\n\t\tEMC_DQS_BRLSHFT_1,\n\t\tEMC_CMD_BRLSHFT_2,\n\t\tEMC_CMD_BRLSHFT_3,\n\t\tEMC_PMACRO_PAD_CFG_CTRL,\n\t\tEMC_PMACRO_DATA_PAD_RX_CTRL,\n\t\tEMC_PMACRO_CMD_PAD_RX_CTRL,\n\t\tEMC_PMACRO_DATA_RX_TERM_MODE,\n\t\tEMC_PMACRO_CMD_RX_TERM_MODE,\n\t\tEMC_PMACRO_CMD_PAD_TX_CTRL,\n\t\tEMC_PMACRO_DATA_PAD_TX_CTRL,\n\t\tEMC_PMACRO_COMMON_PAD_TX_CTRL,\n\t\tEMC_PMACRO_VTTGEN_CTRL_0,\n\t\tEMC_PMACRO_VTTGEN_CTRL_1,\n\t\tEMC_PMACRO_VTTGEN_CTRL_2,\n\t\tEMC_PMACRO_BRICK_CTRL_RFU1,\n\t\tEMC_PMACRO_CMD_BRICK_CTRL_FDPD,\n\t\tEMC_PMACRO_BRICK_CTRL_RFU2,\n\t\tEMC_PMACRO_DATA_BRICK_CTRL_FDPD,\n\t\tEMC_PMACRO_BG_BIAS_CTRL_0,\n\t\tEMC_CFG_3,\n\t\tEMC_PMACRO_TX_PWRD_0,\n\t\tEMC_PMACRO_TX_PWRD_1,\n\t\tEMC_PMACRO_TX_PWRD_2,\n\t\tEMC_PMACRO_TX_PWRD_3,\n\t\tEMC_PMACRO_TX_PWRD_4,\n\t\tEMC_PMACRO_TX_PWRD_5,\n\t\tEMC_CONFIG_SAMPLE_DELAY,\n\t\tEMC_PMACRO_TX_SEL_CLK_SRC_0,\n\t\tEMC_PMACRO_TX_SEL_CLK_SRC_1,\n\t\tEMC_PMACRO_TX_SEL_CLK_SRC_2,\n\t\tEMC_PMACRO_TX_SEL_CLK_SRC_3,\n\t\tEMC_PMACRO_TX_SEL_CLK_SRC_4,\n\t\tEMC_PMACRO_TX_SEL_CLK_SRC_5,\n\t\tEMC_PMACRO_DDLL_BYPASS,\n\t\tEMC_PMACRO_DDLL_PWRD_0,\n\t\tEMC_PMACRO_DDLL_PWRD_1,\n\t\tEMC_PMACRO_DDLL_PWRD_2,\n\t\tEMC_PMACRO_CMD_CTRL_0,\n\t\tEMC_PMACRO_CMD_CTRL_1,\n\t\tEMC_PMACRO_CMD_CTRL_2,\n\t\tEMC_TR_TIMING_0,\n\t\tEMC_TR_DVFS,\n\t\tEMC_TR_CTRL_1,\n\t\tEMC_TR_RDV,\n\t\tEMC_TR_QPOP,\n\t\tEMC_TR_RDV_MASK,\n\t\tEMC_MRW14,\n\t\tEMC_TR_QSAFE,\n\t\tEMC_TR_QRST,\n\t\tEMC_TRAINING_CTRL,\n\t\tEMC_TRAINING_SETTLE,\n\t\tEMC_TRAINING_VREF_SETTLE,\n\t\tEMC_TRAINING_CA_FINE_CTRL,\n\t\tEMC_TRAINING_CA_CTRL_MISC,\n\t\tEMC_TRAINING_CA_CTRL_MISC1,\n\t\tEMC_TRAINING_CA_VREF_CTRL,\n\t\tEMC_TRAINING_QUSE_CORS_CTRL,\n\t\tEMC_TRAINING_QUSE_FINE_CTRL,\n\t\tEMC_TRAINING_QUSE_CTRL_MISC,\n\t\tEMC_TRAINING_QUSE_VREF_CTRL,\n\t\tEMC_TRAINING_READ_FINE_CTRL,\n\t\tEMC_TRAINING_READ_CTRL_MISC,\n\t\tEMC_TRAINING_READ_VREF_CTRL,\n\t\tEMC_TRAINING_WRITE_FINE_CTRL,\n\t\tEMC_TRAINING_WRITE_CTRL_MISC,\n\t\tEMC_TRAINING_WRITE_VREF_CTRL,\n\t\tEMC_TRAINING_MPC,\n\t\tEMC_MRW15,\n\t},\n\t.trim = {\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_0,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_1,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_2,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_3,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_0,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_1,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_2,\n\t\tEMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_3,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE4_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE4_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE4_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE5_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE5_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE5_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE6_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE6_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE6_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE7_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE7_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE7_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE4_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE4_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE4_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE5_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE5_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE5_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE6_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE6_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE6_2,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE7_0,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE7_1,\n\t\tEMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE7_2,\n\t\tEMC_PMACRO_IB_VREF_DQS_0,\n\t\tEMC_PMACRO_IB_VREF_DQS_1,\n\t\tEMC_PMACRO_IB_VREF_DQ_0,\n\t\tEMC_PMACRO_IB_VREF_DQ_1,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_0,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_1,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_2,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_3,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_4,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_5,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_0,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_1,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_2,\n\t\tEMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_3,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_2,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_0,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_1,\n\t\tEMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_2,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK0_0,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK0_1,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK0_2,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK0_3,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK1_0,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK1_1,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK1_2,\n\t\tEMC_PMACRO_QUSE_DDLL_RANK1_3\n\t},\n\t.burst_mc = {\n\t\tMC_EMEM_ARB_CFG,\n\t\tMC_EMEM_ARB_OUTSTANDING_REQ,\n\t\tMC_EMEM_ARB_REFPB_HP_CTRL,\n\t\tMC_EMEM_ARB_REFPB_BANK_CTRL,\n\t\tMC_EMEM_ARB_TIMING_RCD,\n\t\tMC_EMEM_ARB_TIMING_RP,\n\t\tMC_EMEM_ARB_TIMING_RC,\n\t\tMC_EMEM_ARB_TIMING_RAS,\n\t\tMC_EMEM_ARB_TIMING_FAW,\n\t\tMC_EMEM_ARB_TIMING_RRD,\n\t\tMC_EMEM_ARB_TIMING_RAP2PRE,\n\t\tMC_EMEM_ARB_TIMING_WAP2PRE,\n\t\tMC_EMEM_ARB_TIMING_R2R,\n\t\tMC_EMEM_ARB_TIMING_W2W,\n\t\tMC_EMEM_ARB_TIMING_R2W,\n\t\tMC_EMEM_ARB_TIMING_CCDMW,\n\t\tMC_EMEM_ARB_TIMING_W2R,\n\t\tMC_EMEM_ARB_TIMING_RFCPB,\n\t\tMC_EMEM_ARB_DA_TURNS,\n\t\tMC_EMEM_ARB_DA_COVERS,\n\t\tMC_EMEM_ARB_MISC0,\n\t\tMC_EMEM_ARB_MISC1,\n\t\tMC_EMEM_ARB_MISC2,\n\t\tMC_EMEM_ARB_RING1_THROTTLE,\n\t\tMC_EMEM_ARB_DHYST_CTRL,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_0,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_1,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_2,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_3,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_4,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_5,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_6,\n\t\tMC_EMEM_ARB_DHYST_TIMEOUT_UTIL_7,\n\t},\n\t.la_scale = {\n\t\tMC_MLL_MPCORER_PTSA_RATE,\n\t\tMC_FTOP_PTSA_RATE,\n\t\tMC_PTSA_GRANT_DECREMENT,\n\t\tMC_LATENCY_ALLOWANCE_XUSB_0,\n\t\tMC_LATENCY_ALLOWANCE_XUSB_1,\n\t\tMC_LATENCY_ALLOWANCE_TSEC_0,\n\t\tMC_LATENCY_ALLOWANCE_SDMMCA_0,\n\t\tMC_LATENCY_ALLOWANCE_SDMMCAA_0,\n\t\tMC_LATENCY_ALLOWANCE_SDMMC_0,\n\t\tMC_LATENCY_ALLOWANCE_SDMMCAB_0,\n\t\tMC_LATENCY_ALLOWANCE_PPCS_0,\n\t\tMC_LATENCY_ALLOWANCE_PPCS_1,\n\t\tMC_LATENCY_ALLOWANCE_MPCORE_0,\n\t\tMC_LATENCY_ALLOWANCE_HC_0,\n\t\tMC_LATENCY_ALLOWANCE_HC_1,\n\t\tMC_LATENCY_ALLOWANCE_AVPC_0,\n\t\tMC_LATENCY_ALLOWANCE_GPU_0,\n\t\tMC_LATENCY_ALLOWANCE_GPU2_0,\n\t\tMC_LATENCY_ALLOWANCE_NVENC_0,\n\t\tMC_LATENCY_ALLOWANCE_NVDEC_0,\n\t\tMC_LATENCY_ALLOWANCE_VIC_0,\n\t\tMC_LATENCY_ALLOWANCE_VI2_0,\n\t\tMC_LATENCY_ALLOWANCE_ISP2_0,\n\t\tMC_LATENCY_ALLOWANCE_ISP2_1,\n\t},\n\t.burst_per_channel = {\n\t\t{ .bank = 0, .offset = EMC_MRW10, },\n\t\t{ .bank = 1, .offset = EMC_MRW10, },\n\t\t{ .bank = 0, .offset = EMC_MRW11, },\n\t\t{ .bank = 1, .offset = EMC_MRW11, },\n\t\t{ .bank = 0, .offset = EMC_MRW12, },\n\t\t{ .bank = 1, .offset = EMC_MRW12, },\n\t\t{ .bank = 0, .offset = EMC_MRW13, },\n\t\t{ .bank = 1, .offset = EMC_MRW13, },\n\t},\n\t.trim_per_channel = {\n\t\t{ .bank = 0, .offset = EMC_CMD_BRLSHFT_0, },\n\t\t{ .bank = 1, .offset = EMC_CMD_BRLSHFT_1, },\n\t\t{ .bank = 0, .offset = EMC_DATA_BRLSHFT_0, },\n\t\t{ .bank = 1, .offset = EMC_DATA_BRLSHFT_0, },\n\t\t{ .bank = 0, .offset = EMC_DATA_BRLSHFT_1, },\n\t\t{ .bank = 1, .offset = EMC_DATA_BRLSHFT_1, },\n\t\t{ .bank = 0, .offset = EMC_QUSE_BRLSHFT_0, },\n\t\t{ .bank = 1, .offset = EMC_QUSE_BRLSHFT_1, },\n\t\t{ .bank = 0, .offset = EMC_QUSE_BRLSHFT_2, },\n\t\t{ .bank = 1, .offset = EMC_QUSE_BRLSHFT_3, },\n\t},\n\t.vref_per_channel = {\n\t\t{\n\t\t\t.bank = 0,\n\t\t\t.offset = EMC_TRAINING_OPT_DQS_IB_VREF_RANK0,\n\t\t}, {\n\t\t\t.bank = 1,\n\t\t\t.offset = EMC_TRAINING_OPT_DQS_IB_VREF_RANK0,\n\t\t}, {\n\t\t\t.bank = 0,\n\t\t\t.offset = EMC_TRAINING_OPT_DQS_IB_VREF_RANK1,\n\t\t}, {\n\t\t\t.bank = 1,\n\t\t\t.offset = EMC_TRAINING_OPT_DQS_IB_VREF_RANK1,\n\t\t},\n\t},\n};\n\nstatic void tegra210_emc_train(struct timer_list *timer)\n{\n\tstruct tegra210_emc *emc = from_timer(emc, timer, training);\n\tunsigned long flags;\n\n\tif (!emc->last)\n\t\treturn;\n\n\tspin_lock_irqsave(&emc->lock, flags);\n\n\tif (emc->sequence->periodic_compensation)\n\t\temc->sequence->periodic_compensation(emc);\n\n\tspin_unlock_irqrestore(&emc->lock, flags);\n\n\tmod_timer(&emc->training,\n\t\t  jiffies + msecs_to_jiffies(emc->training_interval));\n}\n\nstatic void tegra210_emc_training_start(struct tegra210_emc *emc)\n{\n\tmod_timer(&emc->training,\n\t\t  jiffies + msecs_to_jiffies(emc->training_interval));\n}\n\nstatic void tegra210_emc_training_stop(struct tegra210_emc *emc)\n{\n\tdel_timer(&emc->training);\n}\n\nstatic unsigned int tegra210_emc_get_temperature(struct tegra210_emc *emc)\n{\n\tunsigned long flags;\n\tu32 value, max = 0;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&emc->lock, flags);\n\n\tfor (i = 0; i < emc->num_devices; i++) {\n\t\tvalue = tegra210_emc_mrr_read(emc, i, 4);\n\n\t\tif (value & BIT(7))\n\t\t\tdev_dbg(emc->dev,\n\t\t\t\t\"sensor reading changed for device %u: %08x\\n\",\n\t\t\t\ti, value);\n\n\t\tvalue = FIELD_GET(LPDDR2_MR4_SRR, value);\n\t\tif (value > max)\n\t\t\tmax = value;\n\t}\n\n\tspin_unlock_irqrestore(&emc->lock, flags);\n\n\treturn max;\n}\n\nstatic void tegra210_emc_poll_refresh(struct timer_list *timer)\n{\n\tstruct tegra210_emc *emc = from_timer(emc, timer, refresh_timer);\n\tunsigned int temperature;\n\n\tif (!emc->debugfs.temperature)\n\t\ttemperature = tegra210_emc_get_temperature(emc);\n\telse\n\t\ttemperature = emc->debugfs.temperature;\n\n\tif (temperature == emc->temperature)\n\t\tgoto reset;\n\n\tswitch (temperature) {\n\tcase 0 ... 3:\n\t\t \n\t\tdev_dbg(emc->dev, \"switching to nominal refresh...\\n\");\n\t\ttegra210_emc_set_refresh(emc, TEGRA210_EMC_REFRESH_NOMINAL);\n\t\tbreak;\n\n\tcase 4:\n\t\tdev_dbg(emc->dev, \"switching to 2x refresh...\\n\");\n\t\ttegra210_emc_set_refresh(emc, TEGRA210_EMC_REFRESH_2X);\n\t\tbreak;\n\n\tcase 5:\n\t\tdev_dbg(emc->dev, \"switching to 4x refresh...\\n\");\n\t\ttegra210_emc_set_refresh(emc, TEGRA210_EMC_REFRESH_4X);\n\t\tbreak;\n\n\tcase 6 ... 7:\n\t\tdev_dbg(emc->dev, \"switching to throttle refresh...\\n\");\n\t\ttegra210_emc_set_refresh(emc, TEGRA210_EMC_REFRESH_THROTTLE);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"invalid DRAM temperature state %u\\n\", temperature);\n\t\treturn;\n\t}\n\n\temc->temperature = temperature;\n\nreset:\n\tif (atomic_read(&emc->refresh_poll) > 0) {\n\t\tunsigned int interval = emc->refresh_poll_interval;\n\t\tunsigned int timeout = msecs_to_jiffies(interval);\n\n\t\tmod_timer(&emc->refresh_timer, jiffies + timeout);\n\t}\n}\n\nstatic void tegra210_emc_poll_refresh_stop(struct tegra210_emc *emc)\n{\n\tatomic_set(&emc->refresh_poll, 0);\n\tdel_timer_sync(&emc->refresh_timer);\n}\n\nstatic void tegra210_emc_poll_refresh_start(struct tegra210_emc *emc)\n{\n\tatomic_set(&emc->refresh_poll, 1);\n\n\tmod_timer(&emc->refresh_timer,\n\t\t  jiffies + msecs_to_jiffies(emc->refresh_poll_interval));\n}\n\nstatic int tegra210_emc_cd_max_state(struct thermal_cooling_device *cd,\n\t\t\t\t     unsigned long *state)\n{\n\t*state = 1;\n\n\treturn 0;\n}\n\nstatic int tegra210_emc_cd_get_state(struct thermal_cooling_device *cd,\n\t\t\t\t     unsigned long *state)\n{\n\tstruct tegra210_emc *emc = cd->devdata;\n\n\t*state = atomic_read(&emc->refresh_poll);\n\n\treturn 0;\n}\n\nstatic int tegra210_emc_cd_set_state(struct thermal_cooling_device *cd,\n\t\t\t\t     unsigned long state)\n{\n\tstruct tegra210_emc *emc = cd->devdata;\n\n\tif (state == atomic_read(&emc->refresh_poll))\n\t\treturn 0;\n\n\tif (state)\n\t\ttegra210_emc_poll_refresh_start(emc);\n\telse\n\t\ttegra210_emc_poll_refresh_stop(emc);\n\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops tegra210_emc_cd_ops = {\n\t.get_max_state = tegra210_emc_cd_max_state,\n\t.get_cur_state = tegra210_emc_cd_get_state,\n\t.set_cur_state = tegra210_emc_cd_set_state,\n};\n\nstatic void tegra210_emc_set_clock(struct tegra210_emc *emc, u32 clksrc)\n{\n\temc->sequence->set_clock(emc, clksrc);\n\n\tif (emc->next->periodic_training)\n\t\ttegra210_emc_training_start(emc);\n\telse\n\t\ttegra210_emc_training_stop(emc);\n}\n\nstatic void tegra210_change_dll_src(struct tegra210_emc *emc,\n\t\t\t\t    u32 clksrc)\n{\n\tu32 dll_setting = emc->next->dll_clk_src;\n\tu32 emc_clk_src;\n\tu32 emc_clk_div;\n\n\temc_clk_src = (clksrc & EMC_CLK_EMC_2X_CLK_SRC_MASK) >>\n\t\t       EMC_CLK_EMC_2X_CLK_SRC_SHIFT;\n\temc_clk_div = (clksrc & EMC_CLK_EMC_2X_CLK_DIVISOR_MASK) >>\n\t\t       EMC_CLK_EMC_2X_CLK_DIVISOR_SHIFT;\n\n\tdll_setting &= ~(DLL_CLK_EMC_DLL_CLK_SRC_MASK |\n\t\t\t DLL_CLK_EMC_DLL_CLK_DIVISOR_MASK);\n\tdll_setting |= emc_clk_src << DLL_CLK_EMC_DLL_CLK_SRC_SHIFT;\n\tdll_setting |= emc_clk_div << DLL_CLK_EMC_DLL_CLK_DIVISOR_SHIFT;\n\n\tdll_setting &= ~DLL_CLK_EMC_DLL_DDLL_CLK_SEL_MASK;\n\tif (emc_clk_src == EMC_CLK_SOURCE_PLLMB_LJ)\n\t\tdll_setting |= (PLLM_VCOB <<\n\t\t\t\tDLL_CLK_EMC_DLL_DDLL_CLK_SEL_SHIFT);\n\telse if (emc_clk_src == EMC_CLK_SOURCE_PLLM_LJ)\n\t\tdll_setting |= (PLLM_VCOA <<\n\t\t\t\tDLL_CLK_EMC_DLL_DDLL_CLK_SEL_SHIFT);\n\telse\n\t\tdll_setting |= (EMC_DLL_SWITCH_OUT <<\n\t\t\t\tDLL_CLK_EMC_DLL_DDLL_CLK_SEL_SHIFT);\n\n\ttegra210_clk_emc_dll_update_setting(dll_setting);\n\n\tif (emc->next->clk_out_enb_x_0_clk_enb_emc_dll)\n\t\ttegra210_clk_emc_dll_enable(true);\n\telse\n\t\ttegra210_clk_emc_dll_enable(false);\n}\n\nint tegra210_emc_set_refresh(struct tegra210_emc *emc,\n\t\t\t     enum tegra210_emc_refresh refresh)\n{\n\tstruct tegra210_emc_timing *timings;\n\tunsigned long flags;\n\n\tif ((emc->dram_type != DRAM_TYPE_LPDDR2 &&\n\t     emc->dram_type != DRAM_TYPE_LPDDR4) ||\n\t    !emc->last)\n\t\treturn -ENODEV;\n\n\tif (refresh > TEGRA210_EMC_REFRESH_THROTTLE)\n\t\treturn -EINVAL;\n\n\tif (refresh == emc->refresh)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&emc->lock, flags);\n\n\tif (refresh == TEGRA210_EMC_REFRESH_THROTTLE && emc->derated)\n\t\ttimings = emc->derated;\n\telse\n\t\ttimings = emc->nominal;\n\n\tif (timings != emc->timings) {\n\t\tunsigned int index = emc->last - emc->timings;\n\t\tu32 clksrc;\n\n\t\tclksrc = emc->provider.configs[index].value |\n\t\t\t EMC_CLK_FORCE_CC_TRIGGER;\n\n\t\temc->next = &timings[index];\n\t\temc->timings = timings;\n\n\t\ttegra210_emc_set_clock(emc, clksrc);\n\t} else {\n\t\ttegra210_emc_adjust_timing(emc, emc->last);\n\t\ttegra210_emc_timing_update(emc);\n\n\t\tif (refresh != TEGRA210_EMC_REFRESH_NOMINAL)\n\t\t\temc_writel(emc, EMC_REF_REF_CMD, EMC_REF);\n\t}\n\n\tspin_unlock_irqrestore(&emc->lock, flags);\n\n\treturn 0;\n}\n\nu32 tegra210_emc_mrr_read(struct tegra210_emc *emc, unsigned int chip,\n\t\t\t  unsigned int address)\n{\n\tu32 value, ret = 0;\n\tunsigned int i;\n\n\tvalue = (chip & EMC_MRR_DEV_SEL_MASK) << EMC_MRR_DEV_SEL_SHIFT |\n\t\t(address & EMC_MRR_MA_MASK) << EMC_MRR_MA_SHIFT;\n\temc_writel(emc, value, EMC_MRR);\n\n\tfor (i = 0; i < emc->num_channels; i++)\n\t\tWARN(tegra210_emc_wait_for_update(emc, i, EMC_EMC_STATUS,\n\t\t\t\t\t\t  EMC_EMC_STATUS_MRR_DIVLD, 1),\n\t\t     \"Timed out waiting for MRR %u (ch=%u)\\n\", address, i);\n\n\tfor (i = 0; i < emc->num_channels; i++) {\n\t\tvalue = emc_channel_readl(emc, i, EMC_MRR);\n\t\tvalue &= EMC_MRR_DATA_MASK;\n\n\t\tret = (ret << 16) | value;\n\t}\n\n\treturn ret;\n}\n\nvoid tegra210_emc_do_clock_change(struct tegra210_emc *emc, u32 clksrc)\n{\n\tint err;\n\n\tmc_readl(emc->mc, MC_EMEM_ADR_CFG);\n\temc_readl(emc, EMC_INTSTATUS);\n\n\ttegra210_clk_emc_update_setting(clksrc);\n\n\terr = tegra210_emc_wait_for_update(emc, 0, EMC_INTSTATUS,\n\t\t\t\t\t   EMC_INTSTATUS_CLKCHANGE_COMPLETE,\n\t\t\t\t\t   true);\n\tif (err)\n\t\tdev_warn(emc->dev, \"clock change completion error: %d\\n\", err);\n}\n\nstruct tegra210_emc_timing *tegra210_emc_find_timing(struct tegra210_emc *emc,\n\t\t\t\t\t\t     unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++)\n\t\tif (emc->timings[i].rate * 1000UL == rate)\n\t\t\treturn &emc->timings[i];\n\n\treturn NULL;\n}\n\nint tegra210_emc_wait_for_update(struct tegra210_emc *emc, unsigned int channel,\n\t\t\t\t unsigned int offset, u32 bit_mask, bool state)\n{\n\tunsigned int i;\n\tu32 value;\n\n\tfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; i++) {\n\t\tvalue = emc_channel_readl(emc, channel, offset);\n\t\tif (!!(value & bit_mask) == state)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nvoid tegra210_emc_set_shadow_bypass(struct tegra210_emc *emc, int set)\n{\n\tu32 emc_dbg = emc_readl(emc, EMC_DBG);\n\n\tif (set)\n\t\temc_writel(emc, emc_dbg | EMC_DBG_WRITE_MUX_ACTIVE, EMC_DBG);\n\telse\n\t\temc_writel(emc, emc_dbg & ~EMC_DBG_WRITE_MUX_ACTIVE, EMC_DBG);\n}\n\nu32 tegra210_emc_get_dll_state(struct tegra210_emc_timing *next)\n{\n\tif (next->emc_emrs & 0x1)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid tegra210_emc_timing_update(struct tegra210_emc *emc)\n{\n\tunsigned int i;\n\tint err = 0;\n\n\temc_writel(emc, 0x1, EMC_TIMING_CONTROL);\n\n\tfor (i = 0; i < emc->num_channels; i++) {\n\t\terr |= tegra210_emc_wait_for_update(emc, i, EMC_EMC_STATUS,\n\t\t\t\t\t\t    EMC_EMC_STATUS_TIMING_UPDATE_STALLED,\n\t\t\t\t\t\t    false);\n\t}\n\n\tif (err)\n\t\tdev_warn(emc->dev, \"timing update error: %d\\n\", err);\n}\n\nunsigned long tegra210_emc_actual_osc_clocks(u32 in)\n{\n\tif (in < 0x40)\n\t\treturn in * 16;\n\telse if (in < 0x80)\n\t\treturn 2048;\n\telse if (in < 0xc0)\n\t\treturn 4096;\n\telse\n\t\treturn 8192;\n}\n\nvoid tegra210_emc_start_periodic_compensation(struct tegra210_emc *emc)\n{\n\tu32 mpc_req = 0x4b;\n\n\temc_writel(emc, mpc_req, EMC_MPC);\n\tmpc_req = emc_readl(emc, EMC_MPC);\n}\n\nu32 tegra210_emc_compensate(struct tegra210_emc_timing *next, u32 offset)\n{\n\tu32 temp = 0, rate = next->rate / 1000;\n\ts32 delta[4], delta_taps[4];\n\ts32 new[] = {\n\t\tTRIM_REG(0, 0, 0, 0),\n\t\tTRIM_REG(0, 0, 0, 1),\n\t\tTRIM_REG(0, 0, 1, 2),\n\t\tTRIM_REG(0, 0, 1, 3),\n\n\t\tTRIM_REG(1, 0, 2, 4),\n\t\tTRIM_REG(1, 0, 2, 5),\n\t\tTRIM_REG(1, 0, 3, 6),\n\t\tTRIM_REG(1, 0, 3, 7),\n\n\t\tTRIM_REG(0, 1, 0, 0),\n\t\tTRIM_REG(0, 1, 0, 1),\n\t\tTRIM_REG(0, 1, 1, 2),\n\t\tTRIM_REG(0, 1, 1, 3),\n\n\t\tTRIM_REG(1, 1, 2, 4),\n\t\tTRIM_REG(1, 1, 2, 5),\n\t\tTRIM_REG(1, 1, 3, 6),\n\t\tTRIM_REG(1, 1, 3, 7)\n\t};\n\tunsigned i;\n\n\tswitch (offset) {\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_0:\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_1:\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_2:\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_3:\n\tcase EMC_DATA_BRLSHFT_0:\n\t\tdelta[0] = 128 * (next->current_dram_clktree[C0D0U0] -\n\t\t\t\t  next->trained_dram_clktree[C0D0U0]);\n\t\tdelta[1] = 128 * (next->current_dram_clktree[C0D0U1] -\n\t\t\t\t  next->trained_dram_clktree[C0D0U1]);\n\t\tdelta[2] = 128 * (next->current_dram_clktree[C1D0U0] -\n\t\t\t\t  next->trained_dram_clktree[C1D0U0]);\n\t\tdelta[3] = 128 * (next->current_dram_clktree[C1D0U1] -\n\t\t\t\t  next->trained_dram_clktree[C1D0U1]);\n\n\t\tdelta_taps[0] = (delta[0] * (s32)rate) / 1000000;\n\t\tdelta_taps[1] = (delta[1] * (s32)rate) / 1000000;\n\t\tdelta_taps[2] = (delta[2] * (s32)rate) / 1000000;\n\t\tdelta_taps[3] = (delta[3] * (s32)rate) / 1000000;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif ((delta_taps[i] > next->tree_margin) ||\n\t\t\t    (delta_taps[i] < (-1 * next->tree_margin))) {\n\t\t\t\tnew[i * 2] = new[i * 2] + delta_taps[i];\n\t\t\t\tnew[i * 2 + 1] = new[i * 2 + 1] +\n\t\t\t\t\t\t\tdelta_taps[i];\n\t\t\t}\n\t\t}\n\n\t\tif (offset == EMC_DATA_BRLSHFT_0) {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tnew[i] = new[i] / 64;\n\t\t} else {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tnew[i] = new[i] % 64;\n\t\t}\n\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_0:\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_1:\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_2:\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_3:\n\tcase EMC_DATA_BRLSHFT_1:\n\t\tdelta[0] = 128 * (next->current_dram_clktree[C0D1U0] -\n\t\t\t\t  next->trained_dram_clktree[C0D1U0]);\n\t\tdelta[1] = 128 * (next->current_dram_clktree[C0D1U1] -\n\t\t\t\t  next->trained_dram_clktree[C0D1U1]);\n\t\tdelta[2] = 128 * (next->current_dram_clktree[C1D1U0] -\n\t\t\t\t  next->trained_dram_clktree[C1D1U0]);\n\t\tdelta[3] = 128 * (next->current_dram_clktree[C1D1U1] -\n\t\t\t\t  next->trained_dram_clktree[C1D1U1]);\n\n\t\tdelta_taps[0] = (delta[0] * (s32)rate) / 1000000;\n\t\tdelta_taps[1] = (delta[1] * (s32)rate) / 1000000;\n\t\tdelta_taps[2] = (delta[2] * (s32)rate) / 1000000;\n\t\tdelta_taps[3] = (delta[3] * (s32)rate) / 1000000;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif ((delta_taps[i] > next->tree_margin) ||\n\t\t\t    (delta_taps[i] < (-1 * next->tree_margin))) {\n\t\t\t\tnew[8 + i * 2] = new[8 + i * 2] +\n\t\t\t\t\t\t\tdelta_taps[i];\n\t\t\t\tnew[8 + i * 2 + 1] = new[8 + i * 2 + 1] +\n\t\t\t\t\t\t\tdelta_taps[i];\n\t\t\t}\n\t\t}\n\n\t\tif (offset == EMC_DATA_BRLSHFT_1) {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tnew[i + 8] = new[i + 8] / 64;\n\t\t} else {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tnew[i + 8] = new[i + 8] % 64;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tswitch (offset) {\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_0:\n\t\ttemp = CALC_TEMP(0, 0, 0, 1, 0);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_1:\n\t\ttemp = CALC_TEMP(0, 1, 2, 3, 2);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_2:\n\t\ttemp = CALC_TEMP(0, 2, 4, 5, 4);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_3:\n\t\ttemp = CALC_TEMP(0, 3, 6, 7, 6);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_0:\n\t\ttemp = CALC_TEMP(1, 0, 0, 1, 8);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_1:\n\t\ttemp = CALC_TEMP(1, 1, 2, 3, 10);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_2:\n\t\ttemp = CALC_TEMP(1, 2, 4, 5, 12);\n\t\tbreak;\n\n\tcase EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_3:\n\t\ttemp = CALC_TEMP(1, 3, 6, 7, 14);\n\t\tbreak;\n\n\tcase EMC_DATA_BRLSHFT_0:\n\t\ttemp = ((new[0] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE0_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE0_DATA_BRLSHFT_MASK) |\n\t\t       ((new[1] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE1_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE1_DATA_BRLSHFT_MASK) |\n\t\t       ((new[2] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE2_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE2_DATA_BRLSHFT_MASK) |\n\t\t       ((new[3] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE3_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE3_DATA_BRLSHFT_MASK) |\n\t\t       ((new[4] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE4_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE4_DATA_BRLSHFT_MASK) |\n\t\t       ((new[5] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE5_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE5_DATA_BRLSHFT_MASK) |\n\t\t       ((new[6] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE6_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE6_DATA_BRLSHFT_MASK) |\n\t\t       ((new[7] <<\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE7_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_0_RANK0_BYTE7_DATA_BRLSHFT_MASK);\n\t\tbreak;\n\n\tcase EMC_DATA_BRLSHFT_1:\n\t\ttemp = ((new[8] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE0_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE0_DATA_BRLSHFT_MASK) |\n\t\t       ((new[9] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE1_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE1_DATA_BRLSHFT_MASK) |\n\t\t       ((new[10] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE2_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE2_DATA_BRLSHFT_MASK) |\n\t\t       ((new[11] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE3_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE3_DATA_BRLSHFT_MASK) |\n\t\t       ((new[12] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE4_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE4_DATA_BRLSHFT_MASK) |\n\t\t       ((new[13] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE5_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE5_DATA_BRLSHFT_MASK) |\n\t\t       ((new[14] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE6_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE6_DATA_BRLSHFT_MASK) |\n\t\t       ((new[15] <<\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE7_DATA_BRLSHFT_SHIFT) &\n\t\t\t EMC_DATA_BRLSHFT_1_RANK1_BYTE7_DATA_BRLSHFT_MASK);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn temp;\n}\n\nu32 tegra210_emc_dll_prelock(struct tegra210_emc *emc, u32 clksrc)\n{\n\tunsigned int i;\n\tu32 value;\n\n\tvalue = emc_readl(emc, EMC_CFG_DIG_DLL);\n\tvalue &= ~EMC_CFG_DIG_DLL_CFG_DLL_LOCK_LIMIT_MASK;\n\tvalue |= (3 << EMC_CFG_DIG_DLL_CFG_DLL_LOCK_LIMIT_SHIFT);\n\tvalue &= ~EMC_CFG_DIG_DLL_CFG_DLL_EN;\n\tvalue &= ~EMC_CFG_DIG_DLL_CFG_DLL_MODE_MASK;\n\tvalue |= (3 << EMC_CFG_DIG_DLL_CFG_DLL_MODE_SHIFT);\n\tvalue |= EMC_CFG_DIG_DLL_CFG_DLL_STALL_ALL_TRAFFIC;\n\tvalue &= ~EMC_CFG_DIG_DLL_CFG_DLL_STALL_RW_UNTIL_LOCK;\n\tvalue &= ~EMC_CFG_DIG_DLL_CFG_DLL_STALL_ALL_UNTIL_LOCK;\n\temc_writel(emc, value, EMC_CFG_DIG_DLL);\n\temc_writel(emc, 1, EMC_TIMING_CONTROL);\n\n\tfor (i = 0; i < emc->num_channels; i++)\n\t\ttegra210_emc_wait_for_update(emc, i, EMC_EMC_STATUS,\n\t\t\t\t\t     EMC_EMC_STATUS_TIMING_UPDATE_STALLED,\n\t\t\t\t\t     0);\n\n\tfor (i = 0; i < emc->num_channels; i++) {\n\t\twhile (true) {\n\t\t\tvalue = emc_channel_readl(emc, i, EMC_CFG_DIG_DLL);\n\t\t\tif ((value & EMC_CFG_DIG_DLL_CFG_DLL_EN) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvalue = emc->next->burst_regs[EMC_DLL_CFG_0_INDEX];\n\temc_writel(emc, value, EMC_DLL_CFG_0);\n\n\tvalue = emc_readl(emc, EMC_DLL_CFG_1);\n\tvalue &= EMC_DLL_CFG_1_DDLLCAL_CTRL_START_TRIM_MASK;\n\n\tif (emc->next->rate >= 400000 && emc->next->rate < 600000)\n\t\tvalue |= 150;\n\telse if (emc->next->rate >= 600000 && emc->next->rate < 800000)\n\t\tvalue |= 100;\n\telse if (emc->next->rate >= 800000 && emc->next->rate < 1000000)\n\t\tvalue |= 70;\n\telse if (emc->next->rate >= 1000000 && emc->next->rate < 1200000)\n\t\tvalue |= 30;\n\telse\n\t\tvalue |= 20;\n\n\temc_writel(emc, value, EMC_DLL_CFG_1);\n\n\ttegra210_change_dll_src(emc, clksrc);\n\n\tvalue = emc_readl(emc, EMC_CFG_DIG_DLL);\n\tvalue |= EMC_CFG_DIG_DLL_CFG_DLL_EN;\n\temc_writel(emc, value, EMC_CFG_DIG_DLL);\n\n\ttegra210_emc_timing_update(emc);\n\n\tfor (i = 0; i < emc->num_channels; i++) {\n\t\twhile (true) {\n\t\t\tvalue = emc_channel_readl(emc, 0, EMC_CFG_DIG_DLL);\n\t\t\tif (value & EMC_CFG_DIG_DLL_CFG_DLL_EN)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tvalue = emc_readl(emc, EMC_DIG_DLL_STATUS);\n\n\t\tif ((value & EMC_DIG_DLL_STATUS_DLL_PRIV_UPDATED) == 0)\n\t\t\tcontinue;\n\n\t\tif ((value & EMC_DIG_DLL_STATUS_DLL_LOCK) == 0)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tvalue = emc_readl(emc, EMC_DIG_DLL_STATUS);\n\n\treturn value & EMC_DIG_DLL_STATUS_DLL_OUT_MASK;\n}\n\nu32 tegra210_emc_dvfs_power_ramp_up(struct tegra210_emc *emc, u32 clk,\n\t\t\t\t    bool flip_backward)\n{\n\tu32 cmd_pad, dq_pad, rfu1, cfg5, common_tx, ramp_up_wait = 0;\n\tconst struct tegra210_emc_timing *timing;\n\n\tif (flip_backward)\n\t\ttiming = emc->last;\n\telse\n\t\ttiming = emc->next;\n\n\tcmd_pad = timing->burst_regs[EMC_PMACRO_CMD_PAD_TX_CTRL_INDEX];\n\tdq_pad = timing->burst_regs[EMC_PMACRO_DATA_PAD_TX_CTRL_INDEX];\n\trfu1 = timing->burst_regs[EMC_PMACRO_BRICK_CTRL_RFU1_INDEX];\n\tcfg5 = timing->burst_regs[EMC_FBIO_CFG5_INDEX];\n\tcommon_tx = timing->burst_regs[EMC_PMACRO_COMMON_PAD_TX_CTRL_INDEX];\n\n\tcmd_pad |= EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_DRVFORCEON;\n\n\tif (clk < 1000000 / DVFS_FGCG_MID_SPEED_THRESHOLD) {\n\t\tccfifo_writel(emc, common_tx & 0xa,\n\t\t\t      EMC_PMACRO_COMMON_PAD_TX_CTRL, 0);\n\t\tccfifo_writel(emc, common_tx & 0xf,\n\t\t\t      EMC_PMACRO_COMMON_PAD_TX_CTRL,\n\t\t\t      (100000 / clk) + 1);\n\t\tramp_up_wait += 100000;\n\t} else {\n\t\tccfifo_writel(emc, common_tx | 0x8,\n\t\t\t      EMC_PMACRO_COMMON_PAD_TX_CTRL, 0);\n\t}\n\n\tif (clk < 1000000 / DVFS_FGCG_HIGH_SPEED_THRESHOLD) {\n\t\tif (clk < 1000000 / IOBRICK_DCC_THRESHOLD) {\n\t\t\tcmd_pad |=\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSN_TX_E_DCC;\n\t\t\tcmd_pad &=\n\t\t\t\t~(EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_E_DCC |\n\t\t\t\t  EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_CMD_TX_E_DCC);\n\t\t\tccfifo_writel(emc, cmd_pad,\n\t\t\t\t      EMC_PMACRO_CMD_PAD_TX_CTRL,\n\t\t\t\t      (100000 / clk) + 1);\n\t\t\tramp_up_wait += 100000;\n\n\t\t\tdq_pad |=\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSN_TX_E_DCC;\n\t\t\tdq_pad &=\n\t\t\t       ~(EMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQ_TX_E_DCC |\n\t\t\t\t EMC_PMACRO_DATA_PAD_TX_CTRL_DATA_CMD_TX_E_DCC);\n\t\t\tccfifo_writel(emc, dq_pad,\n\t\t\t\t      EMC_PMACRO_DATA_PAD_TX_CTRL, 0);\n\t\t\tccfifo_writel(emc, rfu1 & 0xfe40fe40,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, 0);\n\t\t} else {\n\t\t\tccfifo_writel(emc, rfu1 & 0xfe40fe40,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1,\n\t\t\t\t      (100000 / clk) + 1);\n\t\t\tramp_up_wait += 100000;\n\t\t}\n\n\t\tccfifo_writel(emc, rfu1 & 0xfeedfeed,\n\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, (100000 / clk) + 1);\n\t\tramp_up_wait += 100000;\n\n\t\tif (clk < 1000000 / IOBRICK_DCC_THRESHOLD) {\n\t\t\tcmd_pad |=\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSN_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_CMD_TX_E_DCC;\n\t\t\tccfifo_writel(emc, cmd_pad,\n\t\t\t\t      EMC_PMACRO_CMD_PAD_TX_CTRL,\n\t\t\t\t      (100000 / clk) + 1);\n\t\t\tramp_up_wait += 100000;\n\n\t\t\tdq_pad |=\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSN_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQ_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_CMD_TX_E_DCC;\n\t\t\tccfifo_writel(emc, dq_pad,\n\t\t\t\t      EMC_PMACRO_DATA_PAD_TX_CTRL, 0);\n\t\t\tccfifo_writel(emc, rfu1,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, 0);\n\t\t} else {\n\t\t\tccfifo_writel(emc, rfu1,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1,\n\t\t\t\t      (100000 / clk) + 1);\n\t\t\tramp_up_wait += 100000;\n\t\t}\n\n\t\tccfifo_writel(emc, cfg5 & ~EMC_FBIO_CFG5_CMD_TX_DIS,\n\t\t\t      EMC_FBIO_CFG5, (100000 / clk) + 10);\n\t\tramp_up_wait += 100000 + (10 * clk);\n\t} else if (clk < 1000000 / DVFS_FGCG_MID_SPEED_THRESHOLD) {\n\t\tccfifo_writel(emc, rfu1 | 0x06000600,\n\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, (100000 / clk) + 1);\n\t\tccfifo_writel(emc, cfg5 & ~EMC_FBIO_CFG5_CMD_TX_DIS,\n\t\t\t      EMC_FBIO_CFG5, (100000 / clk) + 10);\n\t\tramp_up_wait += 100000 + 10 * clk;\n\t} else {\n\t\tccfifo_writel(emc, rfu1 | 0x00000600,\n\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, 0);\n\t\tccfifo_writel(emc, cfg5 & ~EMC_FBIO_CFG5_CMD_TX_DIS,\n\t\t\t      EMC_FBIO_CFG5, 12);\n\t\tramp_up_wait += 12 * clk;\n\t}\n\n\tcmd_pad &= ~EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_DRVFORCEON;\n\tccfifo_writel(emc, cmd_pad, EMC_PMACRO_CMD_PAD_TX_CTRL, 5);\n\n\treturn ramp_up_wait;\n}\n\nu32 tegra210_emc_dvfs_power_ramp_down(struct tegra210_emc *emc, u32 clk,\n\t\t\t\t      bool flip_backward)\n{\n\tu32 ramp_down_wait = 0, cmd_pad, dq_pad, rfu1, cfg5, common_tx;\n\tconst struct tegra210_emc_timing *entry;\n\tu32 seq_wait;\n\n\tif (flip_backward)\n\t\tentry = emc->next;\n\telse\n\t\tentry = emc->last;\n\n\tcmd_pad = entry->burst_regs[EMC_PMACRO_CMD_PAD_TX_CTRL_INDEX];\n\tdq_pad = entry->burst_regs[EMC_PMACRO_DATA_PAD_TX_CTRL_INDEX];\n\trfu1 = entry->burst_regs[EMC_PMACRO_BRICK_CTRL_RFU1_INDEX];\n\tcfg5 = entry->burst_regs[EMC_FBIO_CFG5_INDEX];\n\tcommon_tx = entry->burst_regs[EMC_PMACRO_COMMON_PAD_TX_CTRL_INDEX];\n\n\tcmd_pad |= EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_DRVFORCEON;\n\n\tccfifo_writel(emc, cmd_pad, EMC_PMACRO_CMD_PAD_TX_CTRL, 0);\n\tccfifo_writel(emc, cfg5 | EMC_FBIO_CFG5_CMD_TX_DIS,\n\t\t      EMC_FBIO_CFG5, 12);\n\tramp_down_wait = 12 * clk;\n\n\tseq_wait = (100000 / clk) + 1;\n\n\tif (clk < (1000000 / DVFS_FGCG_HIGH_SPEED_THRESHOLD)) {\n\t\tif (clk < (1000000 / IOBRICK_DCC_THRESHOLD)) {\n\t\t\tcmd_pad &=\n\t\t\t\t~(EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_E_DCC |\n\t\t\t\t  EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_CMD_TX_E_DCC);\n\t\t\tcmd_pad |=\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSN_TX_E_DCC;\n\t\t\tccfifo_writel(emc, cmd_pad,\n\t\t\t\t      EMC_PMACRO_CMD_PAD_TX_CTRL, seq_wait);\n\t\t\tramp_down_wait += 100000;\n\n\t\t\tdq_pad &=\n\t\t\t      ~(EMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQ_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_CMD_TX_E_DCC);\n\t\t\tdq_pad |=\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSN_TX_E_DCC;\n\t\t\tccfifo_writel(emc, dq_pad,\n\t\t\t\t      EMC_PMACRO_DATA_PAD_TX_CTRL, 0);\n\t\t\tccfifo_writel(emc, rfu1 & ~0x01120112,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, 0);\n\t\t} else {\n\t\t\tccfifo_writel(emc, rfu1 & ~0x01120112,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, seq_wait);\n\t\t\tramp_down_wait += 100000;\n\t\t}\n\n\t\tccfifo_writel(emc, rfu1 & ~0x01bf01bf,\n\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, seq_wait);\n\t\tramp_down_wait += 100000;\n\n\t\tif (clk < (1000000 / IOBRICK_DCC_THRESHOLD)) {\n\t\t\tcmd_pad &=\n\t\t\t\t~(EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQ_TX_E_DCC |\n\t\t\t\t  EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_CMD_TX_E_DCC |\n\t\t\t\t  EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSP_TX_E_DCC |\n\t\t\t\t  EMC_PMACRO_CMD_PAD_TX_CTRL_CMD_DQSN_TX_E_DCC);\n\t\t\tccfifo_writel(emc, cmd_pad,\n\t\t\t\t      EMC_PMACRO_CMD_PAD_TX_CTRL, seq_wait);\n\t\t\tramp_down_wait += 100000;\n\n\t\t\tdq_pad &=\n\t\t\t      ~(EMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQ_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_CMD_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSP_TX_E_DCC |\n\t\t\t\tEMC_PMACRO_DATA_PAD_TX_CTRL_DATA_DQSN_TX_E_DCC);\n\t\t\tccfifo_writel(emc, dq_pad,\n\t\t\t\t      EMC_PMACRO_DATA_PAD_TX_CTRL, 0);\n\t\t\tccfifo_writel(emc, rfu1 & ~0x07ff07ff,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, 0);\n\t\t} else {\n\t\t\tccfifo_writel(emc, rfu1 & ~0x07ff07ff,\n\t\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, seq_wait);\n\t\t\tramp_down_wait += 100000;\n\t\t}\n\t} else {\n\t\tccfifo_writel(emc, rfu1 & ~0xffff07ff,\n\t\t\t      EMC_PMACRO_BRICK_CTRL_RFU1, seq_wait + 19);\n\t\tramp_down_wait += 100000 + (20 * clk);\n\t}\n\n\tif (clk < (1000000 / DVFS_FGCG_MID_SPEED_THRESHOLD)) {\n\t\tramp_down_wait += 100000;\n\t\tccfifo_writel(emc, common_tx & ~0x5,\n\t\t\t      EMC_PMACRO_COMMON_PAD_TX_CTRL, seq_wait);\n\t\tramp_down_wait += 100000;\n\t\tccfifo_writel(emc, common_tx & ~0xf,\n\t\t\t      EMC_PMACRO_COMMON_PAD_TX_CTRL, seq_wait);\n\t\tramp_down_wait += 100000;\n\t\tccfifo_writel(emc, 0, 0, seq_wait);\n\t\tramp_down_wait += 100000;\n\t} else {\n\t\tccfifo_writel(emc, common_tx & ~0xf,\n\t\t\t      EMC_PMACRO_COMMON_PAD_TX_CTRL, seq_wait);\n\t}\n\n\treturn ramp_down_wait;\n}\n\nvoid tegra210_emc_reset_dram_clktree_values(struct tegra210_emc_timing *timing)\n{\n\ttiming->current_dram_clktree[C0D0U0] =\n\t\ttiming->trained_dram_clktree[C0D0U0];\n\ttiming->current_dram_clktree[C0D0U1] =\n\t\ttiming->trained_dram_clktree[C0D0U1];\n\ttiming->current_dram_clktree[C1D0U0] =\n\t\ttiming->trained_dram_clktree[C1D0U0];\n\ttiming->current_dram_clktree[C1D0U1] =\n\t\ttiming->trained_dram_clktree[C1D0U1];\n\ttiming->current_dram_clktree[C1D1U0] =\n\t\ttiming->trained_dram_clktree[C1D1U0];\n\ttiming->current_dram_clktree[C1D1U1] =\n\t\ttiming->trained_dram_clktree[C1D1U1];\n}\n\nstatic void update_dll_control(struct tegra210_emc *emc, u32 value, bool state)\n{\n\tunsigned int i;\n\n\temc_writel(emc, value, EMC_CFG_DIG_DLL);\n\ttegra210_emc_timing_update(emc);\n\n\tfor (i = 0; i < emc->num_channels; i++)\n\t\ttegra210_emc_wait_for_update(emc, i, EMC_CFG_DIG_DLL,\n\t\t\t\t\t     EMC_CFG_DIG_DLL_CFG_DLL_EN,\n\t\t\t\t\t     state);\n}\n\nvoid tegra210_emc_dll_disable(struct tegra210_emc *emc)\n{\n\tu32 value;\n\n\tvalue = emc_readl(emc, EMC_CFG_DIG_DLL);\n\tvalue &= ~EMC_CFG_DIG_DLL_CFG_DLL_EN;\n\n\tupdate_dll_control(emc, value, false);\n}\n\nvoid tegra210_emc_dll_enable(struct tegra210_emc *emc)\n{\n\tu32 value;\n\n\tvalue = emc_readl(emc, EMC_CFG_DIG_DLL);\n\tvalue |= EMC_CFG_DIG_DLL_CFG_DLL_EN;\n\n\tupdate_dll_control(emc, value, true);\n}\n\nvoid tegra210_emc_adjust_timing(struct tegra210_emc *emc,\n\t\t\t\tstruct tegra210_emc_timing *timing)\n{\n\tu32 dsr_cntrl = timing->burst_regs[EMC_DYN_SELF_REF_CONTROL_INDEX];\n\tu32 pre_ref = timing->burst_regs[EMC_PRE_REFRESH_REQ_CNT_INDEX];\n\tu32 ref = timing->burst_regs[EMC_REFRESH_INDEX];\n\n\tswitch (emc->refresh) {\n\tcase TEGRA210_EMC_REFRESH_NOMINAL:\n\tcase TEGRA210_EMC_REFRESH_THROTTLE:\n\t\tbreak;\n\n\tcase TEGRA210_EMC_REFRESH_2X:\n\t\tref = REFRESH_SPEEDUP(ref, 2);\n\t\tpre_ref = REFRESH_SPEEDUP(pre_ref, 2);\n\t\tdsr_cntrl = REFRESH_SPEEDUP(dsr_cntrl, 2);\n\t\tbreak;\n\n\tcase TEGRA210_EMC_REFRESH_4X:\n\t\tref = REFRESH_SPEEDUP(ref, 4);\n\t\tpre_ref = REFRESH_SPEEDUP(pre_ref, 4);\n\t\tdsr_cntrl = REFRESH_SPEEDUP(dsr_cntrl, 4);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(emc->dev, \"failed to set refresh: %d\\n\", emc->refresh);\n\t\treturn;\n\t}\n\n\temc_writel(emc, ref, emc->offsets->burst[EMC_REFRESH_INDEX]);\n\temc_writel(emc, pre_ref,\n\t\t   emc->offsets->burst[EMC_PRE_REFRESH_REQ_CNT_INDEX]);\n\temc_writel(emc, dsr_cntrl,\n\t\t   emc->offsets->burst[EMC_DYN_SELF_REF_CONTROL_INDEX]);\n}\n\nstatic int tegra210_emc_set_rate(struct device *dev,\n\t\t\t\t const struct tegra210_clk_emc_config *config)\n{\n\tstruct tegra210_emc *emc = dev_get_drvdata(dev);\n\tstruct tegra210_emc_timing *timing = NULL;\n\tunsigned long rate = config->rate;\n\ts64 last_change_delay;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (rate == emc->last->rate * 1000UL)\n\t\treturn 0;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate * 1000UL == rate) {\n\t\t\ttiming = &emc->timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timing)\n\t\treturn -EINVAL;\n\n\tif (rate > 204000000 && !timing->trained)\n\t\treturn -EINVAL;\n\n\temc->next = timing;\n\tlast_change_delay = ktime_us_delta(ktime_get(), emc->clkchange_time);\n\n\t \n\tif ((last_change_delay >= 0) &&\n\t    (last_change_delay < emc->clkchange_delay))\n\t\tudelay(emc->clkchange_delay - (int)last_change_delay);\n\n\tspin_lock_irqsave(&emc->lock, flags);\n\ttegra210_emc_set_clock(emc, config->value);\n\temc->clkchange_time = ktime_get();\n\temc->last = timing;\n\tspin_unlock_irqrestore(&emc->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic bool tegra210_emc_validate_rate(struct tegra210_emc *emc,\n\t\t\t\t       unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++)\n\t\tif (rate == emc->timings[i].rate * 1000UL)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra210_emc_debug_available_rates_show(struct seq_file *s,\n\t\t\t\t\t\t   void *data)\n{\n\tstruct tegra210_emc *emc = s->private;\n\tconst char *prefix = \"\";\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tseq_printf(s, \"%s%u\", prefix, emc->timings[i].rate * 1000);\n\t\tprefix = \" \";\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tegra210_emc_debug_available_rates);\n\nstatic int tegra210_emc_debug_min_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra210_emc *emc = data;\n\n\t*rate = emc->debugfs.min_rate;\n\n\treturn 0;\n}\n\nstatic int tegra210_emc_debug_min_rate_set(void *data, u64 rate)\n{\n\tstruct tegra210_emc *emc = data;\n\tint err;\n\n\tif (!tegra210_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = clk_set_min_rate(emc->clk, rate);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.min_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra210_emc_debug_min_rate_fops,\n\t\t\ttegra210_emc_debug_min_rate_get,\n\t\t\ttegra210_emc_debug_min_rate_set, \"%llu\\n\");\n\nstatic int tegra210_emc_debug_max_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra210_emc *emc = data;\n\n\t*rate = emc->debugfs.max_rate;\n\n\treturn 0;\n}\n\nstatic int tegra210_emc_debug_max_rate_set(void *data, u64 rate)\n{\n\tstruct tegra210_emc *emc = data;\n\tint err;\n\n\tif (!tegra210_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = clk_set_max_rate(emc->clk, rate);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.max_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra210_emc_debug_max_rate_fops,\n\t\t\ttegra210_emc_debug_max_rate_get,\n\t\t\ttegra210_emc_debug_max_rate_set, \"%llu\\n\");\n\nstatic int tegra210_emc_debug_temperature_get(void *data, u64 *temperature)\n{\n\tstruct tegra210_emc *emc = data;\n\tunsigned int value;\n\n\tif (!emc->debugfs.temperature)\n\t\tvalue = tegra210_emc_get_temperature(emc);\n\telse\n\t\tvalue = emc->debugfs.temperature;\n\n\t*temperature = value;\n\n\treturn 0;\n}\n\nstatic int tegra210_emc_debug_temperature_set(void *data, u64 temperature)\n{\n\tstruct tegra210_emc *emc = data;\n\n\tif (temperature > 7)\n\t\treturn -EINVAL;\n\n\temc->debugfs.temperature = temperature;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(tegra210_emc_debug_temperature_fops,\n\t\t\ttegra210_emc_debug_temperature_get,\n\t\t\ttegra210_emc_debug_temperature_set, \"%llu\\n\");\n\nstatic void tegra210_emc_debugfs_init(struct tegra210_emc *emc)\n{\n\tstruct device *dev = emc->dev;\n\tunsigned int i;\n\tint err;\n\n\temc->debugfs.min_rate = ULONG_MAX;\n\temc->debugfs.max_rate = 0;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate * 1000UL < emc->debugfs.min_rate)\n\t\t\temc->debugfs.min_rate = emc->timings[i].rate * 1000UL;\n\n\t\tif (emc->timings[i].rate * 1000UL > emc->debugfs.max_rate)\n\t\t\temc->debugfs.max_rate = emc->timings[i].rate * 1000UL;\n\t}\n\n\tif (!emc->num_timings) {\n\t\temc->debugfs.min_rate = clk_get_rate(emc->clk);\n\t\temc->debugfs.max_rate = emc->debugfs.min_rate;\n\t}\n\n\terr = clk_set_rate_range(emc->clk, emc->debugfs.min_rate,\n\t\t\t\t emc->debugfs.max_rate);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to set rate range [%lu-%lu] for %pC\\n\",\n\t\t\temc->debugfs.min_rate, emc->debugfs.max_rate,\n\t\t\temc->clk);\n\t\treturn;\n\t}\n\n\temc->debugfs.root = debugfs_create_dir(\"emc\", NULL);\n\n\tdebugfs_create_file(\"available_rates\", 0444, emc->debugfs.root, emc,\n\t\t\t    &tegra210_emc_debug_available_rates_fops);\n\tdebugfs_create_file(\"min_rate\", 0644, emc->debugfs.root, emc,\n\t\t\t    &tegra210_emc_debug_min_rate_fops);\n\tdebugfs_create_file(\"max_rate\", 0644, emc->debugfs.root, emc,\n\t\t\t    &tegra210_emc_debug_max_rate_fops);\n\tdebugfs_create_file(\"temperature\", 0644, emc->debugfs.root, emc,\n\t\t\t    &tegra210_emc_debug_temperature_fops);\n}\n\nstatic void tegra210_emc_detect(struct tegra210_emc *emc)\n{\n\tu32 value;\n\n\t \n\tvalue = mc_readl(emc->mc, MC_EMEM_ADR_CFG);\n\n\tif (value & MC_EMEM_ADR_CFG_EMEM_NUMDEV)\n\t\temc->num_devices = 2;\n\telse\n\t\temc->num_devices = 1;\n\n\t \n\tvalue = emc_readl(emc, EMC_FBIO_CFG5);\n\temc->dram_type = value & 0x3;\n\n\t \n\tvalue = emc_readl(emc, EMC_FBIO_CFG7);\n\n\tif ((value & EMC_FBIO_CFG7_CH1_ENABLE) &&\n\t    (value & EMC_FBIO_CFG7_CH0_ENABLE))\n\t\temc->num_channels = 2;\n\telse\n\t\temc->num_channels = 1;\n}\n\nstatic int tegra210_emc_validate_timings(struct tegra210_emc *emc,\n\t\t\t\t\t struct tegra210_emc_timing *timings,\n\t\t\t\t\t unsigned int num_timings)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_timings; i++) {\n\t\tu32 min_volt = timings[i].min_volt;\n\t\tu32 rate = timings[i].rate;\n\n\t\tif (!rate)\n\t\t\treturn -EINVAL;\n\n\t\tif ((i > 0) && ((rate <= timings[i - 1].rate) ||\n\t\t    (min_volt < timings[i - 1].min_volt)))\n\t\t\treturn -EINVAL;\n\n\t\tif (timings[i].revision != timings[0].revision)\n\t\t\tcontinue;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_emc_probe(struct platform_device *pdev)\n{\n\tstruct thermal_cooling_device *cd;\n\tunsigned long current_rate;\n\tstruct tegra210_emc *emc;\n\tstruct device_node *np;\n\tunsigned int i;\n\tint err;\n\n\temc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn -ENOMEM;\n\n\temc->clk = devm_clk_get(&pdev->dev, \"emc\");\n\tif (IS_ERR(emc->clk))\n\t\treturn PTR_ERR(emc->clk);\n\n\tplatform_set_drvdata(pdev, emc);\n\tspin_lock_init(&emc->lock);\n\temc->dev = &pdev->dev;\n\n\temc->mc = devm_tegra_memory_controller_get(&pdev->dev);\n\tif (IS_ERR(emc->mc))\n\t\treturn PTR_ERR(emc->mc);\n\n\temc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(emc->regs))\n\t\treturn PTR_ERR(emc->regs);\n\n\tfor (i = 0; i < 2; i++) {\n\t\temc->channel[i] = devm_platform_ioremap_resource(pdev, 1 + i);\n\t\tif (IS_ERR(emc->channel[i]))\n\t\t\treturn PTR_ERR(emc->channel[i]);\n\n\t}\n\n\ttegra210_emc_detect(emc);\n\tnp = pdev->dev.of_node;\n\n\t \n\terr = of_reserved_mem_device_init_by_name(emc->dev, np, \"nominal\");\n\tif (err < 0) {\n\t\tdev_err(emc->dev, \"failed to get nominal EMC table: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = of_reserved_mem_device_init_by_name(emc->dev, np, \"derated\");\n\tif (err < 0 && err != -ENODEV) {\n\t\tdev_err(emc->dev, \"failed to get derated EMC table: %d\\n\", err);\n\t\tgoto release;\n\t}\n\n\t \n\tif (emc->nominal) {\n\t\terr = tegra210_emc_validate_timings(emc, emc->nominal,\n\t\t\t\t\t\t    emc->num_timings);\n\t\tif (err < 0)\n\t\t\tgoto release;\n\t}\n\n\tif (emc->derated) {\n\t\terr = tegra210_emc_validate_timings(emc, emc->derated,\n\t\t\t\t\t\t    emc->num_timings);\n\t\tif (err < 0)\n\t\t\tgoto release;\n\t}\n\n\t \n\temc->timings = emc->nominal;\n\n\t \n\tcurrent_rate = clk_get_rate(emc->clk) / 1000;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate == current_rate) {\n\t\t\temc->last = &emc->timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == emc->num_timings) {\n\t\tdev_err(emc->dev, \"no EMC table entry found for %lu kHz\\n\",\n\t\t\tcurrent_rate);\n\t\terr = -ENOENT;\n\t\tgoto release;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tegra210_emc_sequences); i++) {\n\t\tconst struct tegra210_emc_sequence *sequence =\n\t\t\t\ttegra210_emc_sequences[i];\n\n\t\tif (emc->timings[0].revision == sequence->revision) {\n\t\t\temc->sequence = sequence;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!emc->sequence) {\n\t\tdev_err(&pdev->dev, \"sequence %u not supported\\n\",\n\t\t\temc->timings[0].revision);\n\t\terr = -ENOTSUPP;\n\t\tgoto release;\n\t}\n\n\temc->offsets = &tegra210_emc_table_register_offsets;\n\temc->refresh = TEGRA210_EMC_REFRESH_NOMINAL;\n\n\temc->provider.owner = THIS_MODULE;\n\temc->provider.dev = &pdev->dev;\n\temc->provider.set_rate = tegra210_emc_set_rate;\n\n\temc->provider.configs = devm_kcalloc(&pdev->dev, emc->num_timings,\n\t\t\t\t\t     sizeof(*emc->provider.configs),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!emc->provider.configs) {\n\t\terr = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\temc->provider.num_configs = emc->num_timings;\n\n\tfor (i = 0; i < emc->provider.num_configs; i++) {\n\t\tstruct tegra210_emc_timing *timing = &emc->timings[i];\n\t\tstruct tegra210_clk_emc_config *config =\n\t\t\t\t&emc->provider.configs[i];\n\t\tu32 value;\n\n\t\tconfig->rate = timing->rate * 1000UL;\n\t\tconfig->value = timing->clk_src_emc;\n\n\t\tvalue = timing->burst_mc_regs[MC_EMEM_ARB_MISC0_INDEX];\n\n\t\tif ((value & MC_EMEM_ARB_MISC0_EMC_SAME_FREQ) == 0)\n\t\t\tconfig->same_freq = false;\n\t\telse\n\t\t\tconfig->same_freq = true;\n\t}\n\n\terr = tegra210_clk_emc_attach(emc->clk, &emc->provider);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to attach to EMC clock: %d\\n\", err);\n\t\tgoto release;\n\t}\n\n\temc->clkchange_delay = 100;\n\temc->training_interval = 100;\n\tdev_set_drvdata(emc->dev, emc);\n\n\ttimer_setup(&emc->refresh_timer, tegra210_emc_poll_refresh,\n\t\t    TIMER_DEFERRABLE);\n\tatomic_set(&emc->refresh_poll, 0);\n\temc->refresh_poll_interval = 1000;\n\n\ttimer_setup(&emc->training, tegra210_emc_train, 0);\n\n\ttegra210_emc_debugfs_init(emc);\n\n\tcd = devm_thermal_of_cooling_device_register(emc->dev, np, \"emc\", emc,\n\t\t\t\t\t\t     &tegra210_emc_cd_ops);\n\tif (IS_ERR(cd)) {\n\t\terr = PTR_ERR(cd);\n\t\tdev_err(emc->dev, \"failed to register cooling device: %d\\n\",\n\t\t\terr);\n\t\tgoto detach;\n\t}\n\n\treturn 0;\n\ndetach:\n\tdebugfs_remove_recursive(emc->debugfs.root);\n\ttegra210_clk_emc_detach(emc->clk);\nrelease:\n\tof_reserved_mem_device_release(emc->dev);\n\n\treturn err;\n}\n\nstatic int tegra210_emc_remove(struct platform_device *pdev)\n{\n\tstruct tegra210_emc *emc = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(emc->debugfs.root);\n\ttegra210_clk_emc_detach(emc->clk);\n\tof_reserved_mem_device_release(emc->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_emc_suspend(struct device *dev)\n{\n\tstruct tegra210_emc *emc = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_rate_exclusive_get(emc->clk);\n\tif (err < 0) {\n\t\tdev_err(emc->dev, \"failed to acquire clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\temc->resume_rate = clk_get_rate(emc->clk);\n\n\tclk_set_rate(emc->clk, 204000000);\n\ttegra210_clk_emc_detach(emc->clk);\n\n\tdev_dbg(dev, \"suspending at %lu Hz\\n\", clk_get_rate(emc->clk));\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_emc_resume(struct device *dev)\n{\n\tstruct tegra210_emc *emc = dev_get_drvdata(dev);\n\tint err;\n\n\terr = tegra210_clk_emc_attach(emc->clk, &emc->provider);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to attach to EMC clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tclk_set_rate(emc->clk, emc->resume_rate);\n\tclk_rate_exclusive_put(emc->clk);\n\n\tdev_dbg(dev, \"resuming at %lu Hz\\n\", clk_get_rate(emc->clk));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra210_emc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra210_emc_suspend, tegra210_emc_resume)\n};\n\nstatic const struct of_device_id tegra210_emc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-emc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra210_emc_of_match);\n\nstatic struct platform_driver tegra210_emc_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-emc\",\n\t\t.of_match_table = tegra210_emc_of_match,\n\t\t.pm = &tegra210_emc_pm_ops,\n\t},\n\t.probe = tegra210_emc_probe,\n\t.remove = tegra210_emc_remove,\n};\n\nmodule_platform_driver(tegra210_emc_driver);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_AUTHOR(\"Joseph Lo <josephl@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra210 EMC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}