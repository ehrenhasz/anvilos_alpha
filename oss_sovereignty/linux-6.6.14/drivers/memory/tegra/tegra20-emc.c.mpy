{
  "module_name": "tegra20-emc.c",
  "hash_id": "f043cad8d01a4338d9fb27b10b76da4cc21ee3cc9bdfb81ccb4a608a9b84eeae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/tegra/tegra20-emc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk/tegra.h>\n#include <linux/debugfs.h>\n#include <linux/devfreq.h>\n#include <linux/err.h>\n#include <linux/interconnect-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/types.h>\n\n#include <soc/tegra/common.h>\n#include <soc/tegra/fuse.h>\n\n#include \"../jedec_ddr.h\"\n#include \"../of_memory.h\"\n\n#include \"mc.h\"\n\n#define EMC_INTSTATUS\t\t\t\t0x000\n#define EMC_INTMASK\t\t\t\t0x004\n#define EMC_DBG\t\t\t\t\t0x008\n#define EMC_ADR_CFG_0\t\t\t\t0x010\n#define EMC_TIMING_CONTROL\t\t\t0x028\n#define EMC_RC\t\t\t\t\t0x02c\n#define EMC_RFC\t\t\t\t\t0x030\n#define EMC_RAS\t\t\t\t\t0x034\n#define EMC_RP\t\t\t\t\t0x038\n#define EMC_R2W\t\t\t\t\t0x03c\n#define EMC_W2R\t\t\t\t\t0x040\n#define EMC_R2P\t\t\t\t\t0x044\n#define EMC_W2P\t\t\t\t\t0x048\n#define EMC_RD_RCD\t\t\t\t0x04c\n#define EMC_WR_RCD\t\t\t\t0x050\n#define EMC_RRD\t\t\t\t\t0x054\n#define EMC_REXT\t\t\t\t0x058\n#define EMC_WDV\t\t\t\t\t0x05c\n#define EMC_QUSE\t\t\t\t0x060\n#define EMC_QRST\t\t\t\t0x064\n#define EMC_QSAFE\t\t\t\t0x068\n#define EMC_RDV\t\t\t\t\t0x06c\n#define EMC_REFRESH\t\t\t\t0x070\n#define EMC_BURST_REFRESH_NUM\t\t\t0x074\n#define EMC_PDEX2WR\t\t\t\t0x078\n#define EMC_PDEX2RD\t\t\t\t0x07c\n#define EMC_PCHG2PDEN\t\t\t\t0x080\n#define EMC_ACT2PDEN\t\t\t\t0x084\n#define EMC_AR2PDEN\t\t\t\t0x088\n#define EMC_RW2PDEN\t\t\t\t0x08c\n#define EMC_TXSR\t\t\t\t0x090\n#define EMC_TCKE\t\t\t\t0x094\n#define EMC_TFAW\t\t\t\t0x098\n#define EMC_TRPAB\t\t\t\t0x09c\n#define EMC_TCLKSTABLE\t\t\t\t0x0a0\n#define EMC_TCLKSTOP\t\t\t\t0x0a4\n#define EMC_TREFBW\t\t\t\t0x0a8\n#define EMC_QUSE_EXTRA\t\t\t\t0x0ac\n#define EMC_ODT_WRITE\t\t\t\t0x0b0\n#define EMC_ODT_READ\t\t\t\t0x0b4\n#define EMC_MRR\t\t\t\t\t0x0ec\n#define EMC_FBIO_CFG5\t\t\t\t0x104\n#define EMC_FBIO_CFG6\t\t\t\t0x114\n#define EMC_STAT_CONTROL\t\t\t0x160\n#define EMC_STAT_LLMC_CONTROL\t\t\t0x178\n#define EMC_STAT_PWR_CLOCK_LIMIT\t\t0x198\n#define EMC_STAT_PWR_CLOCKS\t\t\t0x19c\n#define EMC_STAT_PWR_COUNT\t\t\t0x1a0\n#define EMC_AUTO_CAL_INTERVAL\t\t\t0x2a8\n#define EMC_CFG_2\t\t\t\t0x2b8\n#define EMC_CFG_DIG_DLL\t\t\t\t0x2bc\n#define EMC_DLL_XFORM_DQS\t\t\t0x2c0\n#define EMC_DLL_XFORM_QUSE\t\t\t0x2c4\n#define EMC_ZCAL_REF_CNT\t\t\t0x2e0\n#define EMC_ZCAL_WAIT_CNT\t\t\t0x2e4\n#define EMC_CFG_CLKTRIM_0\t\t\t0x2d0\n#define EMC_CFG_CLKTRIM_1\t\t\t0x2d4\n#define EMC_CFG_CLKTRIM_2\t\t\t0x2d8\n\n#define EMC_CLKCHANGE_REQ_ENABLE\t\tBIT(0)\n#define EMC_CLKCHANGE_PD_ENABLE\t\t\tBIT(1)\n#define EMC_CLKCHANGE_SR_ENABLE\t\t\tBIT(2)\n\n#define EMC_TIMING_UPDATE\t\t\tBIT(0)\n\n#define EMC_REFRESH_OVERFLOW_INT\t\tBIT(3)\n#define EMC_CLKCHANGE_COMPLETE_INT\t\tBIT(4)\n#define EMC_MRR_DIVLD_INT\t\t\tBIT(5)\n\n#define EMC_DBG_READ_MUX_ASSEMBLY\t\tBIT(0)\n#define EMC_DBG_WRITE_MUX_ACTIVE\t\tBIT(1)\n#define EMC_DBG_FORCE_UPDATE\t\t\tBIT(2)\n#define EMC_DBG_READ_DQM_CTRL\t\t\tBIT(9)\n#define EMC_DBG_CFG_PRIORITY\t\t\tBIT(24)\n\n#define EMC_FBIO_CFG5_DRAM_WIDTH_X16\t\tBIT(4)\n#define EMC_FBIO_CFG5_DRAM_TYPE\t\t\tGENMASK(1, 0)\n\n#define EMC_MRR_DEV_SELECTN\t\t\tGENMASK(31, 30)\n#define EMC_MRR_MRR_MA\t\t\t\tGENMASK(23, 16)\n#define EMC_MRR_MRR_DATA\t\t\tGENMASK(15, 0)\n\n#define EMC_ADR_CFG_0_EMEM_NUMDEV\t\tGENMASK(25, 24)\n\n#define EMC_PWR_GATHER_CLEAR\t\t\t(1 << 8)\n#define EMC_PWR_GATHER_DISABLE\t\t\t(2 << 8)\n#define EMC_PWR_GATHER_ENABLE\t\t\t(3 << 8)\n\nenum emc_dram_type {\n\tDRAM_TYPE_RESERVED,\n\tDRAM_TYPE_DDR1,\n\tDRAM_TYPE_LPDDR2,\n\tDRAM_TYPE_DDR2,\n};\n\nstatic const u16 emc_timing_registers[] = {\n\tEMC_RC,\n\tEMC_RFC,\n\tEMC_RAS,\n\tEMC_RP,\n\tEMC_R2W,\n\tEMC_W2R,\n\tEMC_R2P,\n\tEMC_W2P,\n\tEMC_RD_RCD,\n\tEMC_WR_RCD,\n\tEMC_RRD,\n\tEMC_REXT,\n\tEMC_WDV,\n\tEMC_QUSE,\n\tEMC_QRST,\n\tEMC_QSAFE,\n\tEMC_RDV,\n\tEMC_REFRESH,\n\tEMC_BURST_REFRESH_NUM,\n\tEMC_PDEX2WR,\n\tEMC_PDEX2RD,\n\tEMC_PCHG2PDEN,\n\tEMC_ACT2PDEN,\n\tEMC_AR2PDEN,\n\tEMC_RW2PDEN,\n\tEMC_TXSR,\n\tEMC_TCKE,\n\tEMC_TFAW,\n\tEMC_TRPAB,\n\tEMC_TCLKSTABLE,\n\tEMC_TCLKSTOP,\n\tEMC_TREFBW,\n\tEMC_QUSE_EXTRA,\n\tEMC_FBIO_CFG6,\n\tEMC_ODT_WRITE,\n\tEMC_ODT_READ,\n\tEMC_FBIO_CFG5,\n\tEMC_CFG_DIG_DLL,\n\tEMC_DLL_XFORM_DQS,\n\tEMC_DLL_XFORM_QUSE,\n\tEMC_ZCAL_REF_CNT,\n\tEMC_ZCAL_WAIT_CNT,\n\tEMC_AUTO_CAL_INTERVAL,\n\tEMC_CFG_CLKTRIM_0,\n\tEMC_CFG_CLKTRIM_1,\n\tEMC_CFG_CLKTRIM_2,\n};\n\nstruct emc_timing {\n\tunsigned long rate;\n\tu32 data[ARRAY_SIZE(emc_timing_registers)];\n};\n\nenum emc_rate_request_type {\n\tEMC_RATE_DEVFREQ,\n\tEMC_RATE_DEBUG,\n\tEMC_RATE_ICC,\n\tEMC_RATE_TYPE_MAX,\n};\n\nstruct emc_rate_request {\n\tunsigned long min_rate;\n\tunsigned long max_rate;\n};\n\nstruct tegra_emc {\n\tstruct device *dev;\n\tstruct tegra_mc *mc;\n\tstruct icc_provider provider;\n\tstruct notifier_block clk_nb;\n\tstruct clk *clk;\n\tvoid __iomem *regs;\n\tunsigned int dram_bus_width;\n\n\tstruct emc_timing *timings;\n\tunsigned int num_timings;\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tunsigned long min_rate;\n\t\tunsigned long max_rate;\n\t} debugfs;\n\n\t \n\tstruct emc_rate_request requested_rate[EMC_RATE_TYPE_MAX];\n\n\t \n\tstruct mutex rate_lock;\n\n\tstruct devfreq_simple_ondemand_data ondemand_data;\n\n\t \n\tunion lpddr2_basic_config4 basic_conf4;\n\tunsigned int manufacturer_id;\n\tunsigned int revision_id1;\n\tunsigned int revision_id2;\n\n\tbool mrr_error;\n};\n\nstatic irqreturn_t tegra_emc_isr(int irq, void *data)\n{\n\tstruct tegra_emc *emc = data;\n\tu32 intmask = EMC_REFRESH_OVERFLOW_INT;\n\tu32 status;\n\n\tstatus = readl_relaxed(emc->regs + EMC_INTSTATUS) & intmask;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & EMC_REFRESH_OVERFLOW_INT)\n\t\tdev_err_ratelimited(emc->dev,\n\t\t\t\t    \"refresh request overflow timeout\\n\");\n\n\t \n\twritel_relaxed(status, emc->regs + EMC_INTSTATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct emc_timing *tegra_emc_find_timing(struct tegra_emc *emc,\n\t\t\t\t\t\tunsigned long rate)\n{\n\tstruct emc_timing *timing = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate >= rate) {\n\t\t\ttiming = &emc->timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timing) {\n\t\tdev_err(emc->dev, \"no timing for rate %lu\\n\", rate);\n\t\treturn NULL;\n\t}\n\n\treturn timing;\n}\n\nstatic int emc_prepare_timing_change(struct tegra_emc *emc, unsigned long rate)\n{\n\tstruct emc_timing *timing = tegra_emc_find_timing(emc, rate);\n\tunsigned int i;\n\n\tif (!timing)\n\t\treturn -EINVAL;\n\n\tdev_dbg(emc->dev, \"%s: using timing rate %lu for requested rate %lu\\n\",\n\t\t__func__, timing->rate, rate);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(timing->data); i++)\n\t\twritel_relaxed(timing->data[i],\n\t\t\t       emc->regs + emc_timing_registers[i]);\n\n\t \n\treadl_relaxed(emc->regs + emc_timing_registers[i - 1]);\n\n\treturn 0;\n}\n\nstatic int emc_complete_timing_change(struct tegra_emc *emc, bool flush)\n{\n\tint err;\n\tu32 v;\n\n\tdev_dbg(emc->dev, \"%s: flush %d\\n\", __func__, flush);\n\n\tif (flush) {\n\t\t \n\t\twritel_relaxed(EMC_TIMING_UPDATE,\n\t\t\t       emc->regs + EMC_TIMING_CONTROL);\n\t\treturn 0;\n\t}\n\n\terr = readl_relaxed_poll_timeout_atomic(emc->regs + EMC_INTSTATUS, v,\n\t\t\t\t\t\tv & EMC_CLKCHANGE_COMPLETE_INT,\n\t\t\t\t\t\t1, 100);\n\tif (err) {\n\t\tdev_err(emc->dev, \"emc-car handshake timeout: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_emc_clk_change_notify(struct notifier_block *nb,\n\t\t\t\t       unsigned long msg, void *data)\n{\n\tstruct tegra_emc *emc = container_of(nb, struct tegra_emc, clk_nb);\n\tstruct clk_notifier_data *cnd = data;\n\tint err;\n\n\tswitch (msg) {\n\tcase PRE_RATE_CHANGE:\n\t\terr = emc_prepare_timing_change(emc, cnd->new_rate);\n\t\tbreak;\n\n\tcase ABORT_RATE_CHANGE:\n\t\terr = emc_prepare_timing_change(emc, cnd->old_rate);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = emc_complete_timing_change(emc, true);\n\t\tbreak;\n\n\tcase POST_RATE_CHANGE:\n\t\terr = emc_complete_timing_change(emc, false);\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic int load_one_timing_from_dt(struct tegra_emc *emc,\n\t\t\t\t   struct emc_timing *timing,\n\t\t\t\t   struct device_node *node)\n{\n\tu32 rate;\n\tint err;\n\n\tif (!of_device_is_compatible(node, \"nvidia,tegra20-emc-table\")) {\n\t\tdev_err(emc->dev, \"incompatible DT node: %pOF\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\terr = of_property_read_u32(node, \"clock-frequency\", &rate);\n\tif (err) {\n\t\tdev_err(emc->dev, \"timing %pOF: failed to read rate: %d\\n\",\n\t\t\tnode, err);\n\t\treturn err;\n\t}\n\n\terr = of_property_read_u32_array(node, \"nvidia,emc-registers\",\n\t\t\t\t\t timing->data,\n\t\t\t\t\t ARRAY_SIZE(emc_timing_registers));\n\tif (err) {\n\t\tdev_err(emc->dev,\n\t\t\t\"timing %pOF: failed to read emc timing data: %d\\n\",\n\t\t\tnode, err);\n\t\treturn err;\n\t}\n\n\t \n\ttiming->rate = rate * 2 * 1000;\n\n\tdev_dbg(emc->dev, \"%s: %pOF: EMC rate %lu\\n\",\n\t\t__func__, node, timing->rate);\n\n\treturn 0;\n}\n\nstatic int cmp_timings(const void *_a, const void *_b)\n{\n\tconst struct emc_timing *a = _a;\n\tconst struct emc_timing *b = _b;\n\n\tif (a->rate < b->rate)\n\t\treturn -1;\n\n\tif (a->rate > b->rate)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_load_timings_from_dt(struct tegra_emc *emc,\n\t\t\t\t\t  struct device_node *node)\n{\n\tstruct device_node *child;\n\tstruct emc_timing *timing;\n\tint child_count;\n\tint err;\n\n\tchild_count = of_get_child_count(node);\n\tif (!child_count) {\n\t\tdev_err(emc->dev, \"no memory timings in DT node: %pOF\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\temc->timings = devm_kcalloc(emc->dev, child_count, sizeof(*timing),\n\t\t\t\t    GFP_KERNEL);\n\tif (!emc->timings)\n\t\treturn -ENOMEM;\n\n\ttiming = emc->timings;\n\n\tfor_each_child_of_node(node, child) {\n\t\tif (of_node_name_eq(child, \"lpddr2\"))\n\t\t\tcontinue;\n\n\t\terr = load_one_timing_from_dt(emc, timing++, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\n\t\temc->num_timings++;\n\t}\n\n\tsort(emc->timings, emc->num_timings, sizeof(*timing), cmp_timings,\n\t     NULL);\n\n\tdev_info_once(emc->dev,\n\t\t      \"got %u timings for RAM code %u (min %luMHz max %luMHz)\\n\",\n\t\t      emc->num_timings,\n\t\t      tegra_read_ram_code(),\n\t\t      emc->timings[0].rate / 1000000,\n\t\t      emc->timings[emc->num_timings - 1].rate / 1000000);\n\n\treturn 0;\n}\n\nstatic struct device_node *\ntegra_emc_find_node_by_ram_code(struct tegra_emc *emc)\n{\n\tstruct device *dev = emc->dev;\n\tstruct device_node *np;\n\tu32 value, ram_code;\n\tint err;\n\n\tif (emc->mrr_error) {\n\t\tdev_warn(dev, \"memory timings skipped due to MRR error\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (of_get_child_count(dev->of_node) == 0) {\n\t\tdev_info_once(dev, \"device-tree doesn't have memory timings\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!of_property_read_bool(dev->of_node, \"nvidia,use-ram-code\"))\n\t\treturn of_node_get(dev->of_node);\n\n\tram_code = tegra_read_ram_code();\n\n\tfor (np = of_find_node_by_name(dev->of_node, \"emc-tables\"); np;\n\t     np = of_find_node_by_name(np, \"emc-tables\")) {\n\t\terr = of_property_read_u32(np, \"nvidia,ram-code\", &value);\n\t\tif (err || value != ram_code) {\n\t\t\tstruct device_node *lpddr2_np;\n\t\t\tbool cfg_mismatches = false;\n\n\t\t\tlpddr2_np = of_find_node_by_name(np, \"lpddr2\");\n\t\t\tif (lpddr2_np) {\n\t\t\t\tconst struct lpddr2_info *info;\n\n\t\t\t\tinfo = of_lpddr2_get_info(lpddr2_np, dev);\n\t\t\t\tif (info) {\n\t\t\t\t\tif (info->manufacturer_id >= 0 &&\n\t\t\t\t\t    info->manufacturer_id != emc->manufacturer_id)\n\t\t\t\t\t\tcfg_mismatches = true;\n\n\t\t\t\t\tif (info->revision_id1 >= 0 &&\n\t\t\t\t\t    info->revision_id1 != emc->revision_id1)\n\t\t\t\t\t\tcfg_mismatches = true;\n\n\t\t\t\t\tif (info->revision_id2 >= 0 &&\n\t\t\t\t\t    info->revision_id2 != emc->revision_id2)\n\t\t\t\t\t\tcfg_mismatches = true;\n\n\t\t\t\t\tif (info->density != emc->basic_conf4.density)\n\t\t\t\t\t\tcfg_mismatches = true;\n\n\t\t\t\t\tif (info->io_width != emc->basic_conf4.io_width)\n\t\t\t\t\t\tcfg_mismatches = true;\n\n\t\t\t\t\tif (info->arch_type != emc->basic_conf4.arch_type)\n\t\t\t\t\t\tcfg_mismatches = true;\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(dev, \"failed to parse %pOF\\n\", lpddr2_np);\n\t\t\t\t\tcfg_mismatches = true;\n\t\t\t\t}\n\n\t\t\t\tof_node_put(lpddr2_np);\n\t\t\t} else {\n\t\t\t\tcfg_mismatches = true;\n\t\t\t}\n\n\t\t\tif (cfg_mismatches) {\n\t\t\t\tof_node_put(np);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn np;\n\t}\n\n\tdev_err(dev, \"no memory timings for RAM code %u found in device tree\\n\",\n\t\tram_code);\n\n\treturn NULL;\n}\n\nstatic int emc_read_lpddr_mode_register(struct tegra_emc *emc,\n\t\t\t\t\tunsigned int emem_dev,\n\t\t\t\t\tunsigned int register_addr,\n\t\t\t\t\tunsigned int *register_data)\n{\n\tu32 memory_dev = emem_dev ? 1 : 2;\n\tu32 val, mr_mask = 0xff;\n\tint err;\n\n\t \n\twritel_relaxed(EMC_MRR_DIVLD_INT, emc->regs + EMC_INTSTATUS);\n\n\t \n\tval  = FIELD_PREP(EMC_MRR_DEV_SELECTN, memory_dev);\n\tval |= FIELD_PREP(EMC_MRR_MRR_MA, register_addr);\n\n\twritel_relaxed(val, emc->regs + EMC_MRR);\n\n\t \n\terr = readl_relaxed_poll_timeout_atomic(emc->regs + EMC_INTSTATUS, val,\n\t\t\t\t\t\tval & EMC_MRR_DIVLD_INT,\n\t\t\t\t\t\t1, 100);\n\tif (err) {\n\t\tdev_err(emc->dev, \"mode register %u read failed: %d\\n\",\n\t\t\tregister_addr, err);\n\t\temc->mrr_error = true;\n\t\treturn err;\n\t}\n\n\t \n\tval = readl_relaxed(emc->regs + EMC_MRR);\n\t*register_data = FIELD_GET(EMC_MRR_MRR_DATA, val) & mr_mask;\n\n\treturn 0;\n}\n\nstatic void emc_read_lpddr_sdram_info(struct tegra_emc *emc,\n\t\t\t\t      unsigned int emem_dev,\n\t\t\t\t      bool print_out)\n{\n\t \n\temc_read_lpddr_mode_register(emc, emem_dev, 5, &emc->manufacturer_id);\n\temc_read_lpddr_mode_register(emc, emem_dev, 6, &emc->revision_id1);\n\temc_read_lpddr_mode_register(emc, emem_dev, 7, &emc->revision_id2);\n\temc_read_lpddr_mode_register(emc, emem_dev, 8, &emc->basic_conf4.value);\n\n\tif (!print_out)\n\t\treturn;\n\n\tdev_info(emc->dev, \"SDRAM[dev%u]: manufacturer: 0x%x (%s) rev1: 0x%x rev2: 0x%x prefetch: S%u density: %uMbit iowidth: %ubit\\n\",\n\t\t emem_dev, emc->manufacturer_id,\n\t\t lpddr2_jedec_manufacturer(emc->manufacturer_id),\n\t\t emc->revision_id1, emc->revision_id2,\n\t\t 4 >> emc->basic_conf4.arch_type,\n\t\t 64 << emc->basic_conf4.density,\n\t\t 32 >> emc->basic_conf4.io_width);\n}\n\nstatic int emc_setup_hw(struct tegra_emc *emc)\n{\n\tu32 emc_cfg, emc_dbg, emc_fbio, emc_adr_cfg;\n\tu32 intmask = EMC_REFRESH_OVERFLOW_INT;\n\tstatic bool print_sdram_info_once;\n\tenum emc_dram_type dram_type;\n\tconst char *dram_type_str;\n\tunsigned int emem_numdev;\n\n\temc_cfg = readl_relaxed(emc->regs + EMC_CFG_2);\n\n\t \n\tif (!(emc_cfg & EMC_CLKCHANGE_PD_ENABLE) &&\n\t    !(emc_cfg & EMC_CLKCHANGE_SR_ENABLE)) {\n\t\tdev_err(emc->dev,\n\t\t\t\"bootloader didn't specify DRAM auto-suspend mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\temc_cfg |= EMC_CLKCHANGE_REQ_ENABLE;\n\twritel_relaxed(emc_cfg, emc->regs + EMC_CFG_2);\n\n\t \n\twritel_relaxed(intmask, emc->regs + EMC_INTMASK);\n\twritel_relaxed(intmask, emc->regs + EMC_INTSTATUS);\n\n\t \n\temc_dbg = readl_relaxed(emc->regs + EMC_DBG);\n\temc_dbg |= EMC_DBG_CFG_PRIORITY;\n\temc_dbg &= ~EMC_DBG_READ_MUX_ASSEMBLY;\n\temc_dbg &= ~EMC_DBG_WRITE_MUX_ACTIVE;\n\temc_dbg &= ~EMC_DBG_FORCE_UPDATE;\n\twritel_relaxed(emc_dbg, emc->regs + EMC_DBG);\n\n\temc_fbio = readl_relaxed(emc->regs + EMC_FBIO_CFG5);\n\n\tif (emc_fbio & EMC_FBIO_CFG5_DRAM_WIDTH_X16)\n\t\temc->dram_bus_width = 16;\n\telse\n\t\temc->dram_bus_width = 32;\n\n\tdram_type = FIELD_GET(EMC_FBIO_CFG5_DRAM_TYPE, emc_fbio);\n\n\tswitch (dram_type) {\n\tcase DRAM_TYPE_RESERVED:\n\t\tdram_type_str = \"INVALID\";\n\t\tbreak;\n\tcase DRAM_TYPE_DDR1:\n\t\tdram_type_str = \"DDR1\";\n\t\tbreak;\n\tcase DRAM_TYPE_LPDDR2:\n\t\tdram_type_str = \"LPDDR2\";\n\t\tbreak;\n\tcase DRAM_TYPE_DDR2:\n\t\tdram_type_str = \"DDR2\";\n\t\tbreak;\n\t}\n\n\temc_adr_cfg = readl_relaxed(emc->regs + EMC_ADR_CFG_0);\n\temem_numdev = FIELD_GET(EMC_ADR_CFG_0_EMEM_NUMDEV, emc_adr_cfg) + 1;\n\n\tdev_info_once(emc->dev, \"%ubit DRAM bus, %u %s %s attached\\n\",\n\t\t      emc->dram_bus_width, emem_numdev, dram_type_str,\n\t\t      emem_numdev == 2 ? \"devices\" : \"device\");\n\n\tif (dram_type == DRAM_TYPE_LPDDR2) {\n\t\twhile (emem_numdev--)\n\t\t\temc_read_lpddr_sdram_info(emc, emem_numdev,\n\t\t\t\t\t\t  !print_sdram_info_once);\n\t\tprint_sdram_info_once = true;\n\t}\n\n\treturn 0;\n}\n\nstatic long emc_round_rate(unsigned long rate,\n\t\t\t   unsigned long min_rate,\n\t\t\t   unsigned long max_rate,\n\t\t\t   void *arg)\n{\n\tstruct emc_timing *timing = NULL;\n\tstruct tegra_emc *emc = arg;\n\tunsigned int i;\n\n\tif (!emc->num_timings)\n\t\treturn clk_get_rate(emc->clk);\n\n\tmin_rate = min(min_rate, emc->timings[emc->num_timings - 1].rate);\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate < rate && i != emc->num_timings - 1)\n\t\t\tcontinue;\n\n\t\tif (emc->timings[i].rate > max_rate) {\n\t\t\ti = max(i, 1u) - 1;\n\n\t\t\tif (emc->timings[i].rate < min_rate)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (emc->timings[i].rate < min_rate)\n\t\t\tcontinue;\n\n\t\ttiming = &emc->timings[i];\n\t\tbreak;\n\t}\n\n\tif (!timing) {\n\t\tdev_err(emc->dev, \"no timing for rate %lu min %lu max %lu\\n\",\n\t\t\trate, min_rate, max_rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn timing->rate;\n}\n\nstatic void tegra_emc_rate_requests_init(struct tegra_emc *emc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < EMC_RATE_TYPE_MAX; i++) {\n\t\temc->requested_rate[i].min_rate = 0;\n\t\temc->requested_rate[i].max_rate = ULONG_MAX;\n\t}\n}\n\nstatic int emc_request_rate(struct tegra_emc *emc,\n\t\t\t    unsigned long new_min_rate,\n\t\t\t    unsigned long new_max_rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = emc->requested_rate;\n\tunsigned long min_rate = 0, max_rate = ULONG_MAX;\n\tunsigned int i;\n\tint err;\n\n\t \n\tfor (i = 0; i < EMC_RATE_TYPE_MAX; i++, req++) {\n\t\tif (i == type) {\n\t\t\tmin_rate = max(new_min_rate, min_rate);\n\t\t\tmax_rate = min(new_max_rate, max_rate);\n\t\t} else {\n\t\t\tmin_rate = max(req->min_rate, min_rate);\n\t\t\tmax_rate = min(req->max_rate, max_rate);\n\t\t}\n\t}\n\n\tif (min_rate > max_rate) {\n\t\tdev_err_ratelimited(emc->dev, \"%s: type %u: out of range: %lu %lu\\n\",\n\t\t\t\t    __func__, type, min_rate, max_rate);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\terr = dev_pm_opp_set_rate(emc->dev, min_rate);\n\tif (err)\n\t\treturn err;\n\n\temc->requested_rate[type].min_rate = new_min_rate;\n\temc->requested_rate[type].max_rate = new_max_rate;\n\n\treturn 0;\n}\n\nstatic int emc_set_min_rate(struct tegra_emc *emc, unsigned long rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = &emc->requested_rate[type];\n\tint ret;\n\n\tmutex_lock(&emc->rate_lock);\n\tret = emc_request_rate(emc, rate, req->max_rate, type);\n\tmutex_unlock(&emc->rate_lock);\n\n\treturn ret;\n}\n\nstatic int emc_set_max_rate(struct tegra_emc *emc, unsigned long rate,\n\t\t\t    enum emc_rate_request_type type)\n{\n\tstruct emc_rate_request *req = &emc->requested_rate[type];\n\tint ret;\n\n\tmutex_lock(&emc->rate_lock);\n\tret = emc_request_rate(emc, req->min_rate, rate, type);\n\tmutex_unlock(&emc->rate_lock);\n\n\treturn ret;\n}\n\n \n\nstatic bool tegra_emc_validate_rate(struct tegra_emc *emc, unsigned long rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++)\n\t\tif (rate == emc->timings[i].rate)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra_emc_debug_available_rates_show(struct seq_file *s, void *data)\n{\n\tstruct tegra_emc *emc = s->private;\n\tconst char *prefix = \"\";\n\tunsigned int i;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tseq_printf(s, \"%s%lu\", prefix, emc->timings[i].rate);\n\t\tprefix = \" \";\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tegra_emc_debug_available_rates);\n\nstatic int tegra_emc_debug_min_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra_emc *emc = data;\n\n\t*rate = emc->debugfs.min_rate;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_debug_min_rate_set(void *data, u64 rate)\n{\n\tstruct tegra_emc *emc = data;\n\tint err;\n\n\tif (!tegra_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = emc_set_min_rate(emc, rate, EMC_RATE_DEBUG);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.min_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(tegra_emc_debug_min_rate_fops,\n\t\t\ttegra_emc_debug_min_rate_get,\n\t\t\ttegra_emc_debug_min_rate_set, \"%llu\\n\");\n\nstatic int tegra_emc_debug_max_rate_get(void *data, u64 *rate)\n{\n\tstruct tegra_emc *emc = data;\n\n\t*rate = emc->debugfs.max_rate;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_debug_max_rate_set(void *data, u64 rate)\n{\n\tstruct tegra_emc *emc = data;\n\tint err;\n\n\tif (!tegra_emc_validate_rate(emc, rate))\n\t\treturn -EINVAL;\n\n\terr = emc_set_max_rate(emc, rate, EMC_RATE_DEBUG);\n\tif (err < 0)\n\t\treturn err;\n\n\temc->debugfs.max_rate = rate;\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(tegra_emc_debug_max_rate_fops,\n\t\t\ttegra_emc_debug_max_rate_get,\n\t\t\ttegra_emc_debug_max_rate_set, \"%llu\\n\");\n\nstatic void tegra_emc_debugfs_init(struct tegra_emc *emc)\n{\n\tstruct device *dev = emc->dev;\n\tunsigned int i;\n\tint err;\n\n\temc->debugfs.min_rate = ULONG_MAX;\n\temc->debugfs.max_rate = 0;\n\n\tfor (i = 0; i < emc->num_timings; i++) {\n\t\tif (emc->timings[i].rate < emc->debugfs.min_rate)\n\t\t\temc->debugfs.min_rate = emc->timings[i].rate;\n\n\t\tif (emc->timings[i].rate > emc->debugfs.max_rate)\n\t\t\temc->debugfs.max_rate = emc->timings[i].rate;\n\t}\n\n\tif (!emc->num_timings) {\n\t\temc->debugfs.min_rate = clk_get_rate(emc->clk);\n\t\temc->debugfs.max_rate = emc->debugfs.min_rate;\n\t}\n\n\terr = clk_set_rate_range(emc->clk, emc->debugfs.min_rate,\n\t\t\t\t emc->debugfs.max_rate);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to set rate range [%lu-%lu] for %pC\\n\",\n\t\t\temc->debugfs.min_rate, emc->debugfs.max_rate,\n\t\t\temc->clk);\n\t}\n\n\temc->debugfs.root = debugfs_create_dir(\"emc\", NULL);\n\n\tdebugfs_create_file(\"available_rates\", 0444, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_available_rates_fops);\n\tdebugfs_create_file(\"min_rate\", 0644, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_min_rate_fops);\n\tdebugfs_create_file(\"max_rate\", 0644, emc->debugfs.root,\n\t\t\t    emc, &tegra_emc_debug_max_rate_fops);\n}\n\nstatic inline struct tegra_emc *\nto_tegra_emc_provider(struct icc_provider *provider)\n{\n\treturn container_of(provider, struct tegra_emc, provider);\n}\n\nstatic struct icc_node_data *\nemc_of_icc_xlate_extended(struct of_phandle_args *spec, void *data)\n{\n\tstruct icc_provider *provider = data;\n\tstruct icc_node_data *ndata;\n\tstruct icc_node *node;\n\n\t \n\tlist_for_each_entry(node, &provider->nodes, node_list) {\n\t\tif (node->id != TEGRA_ICC_EMEM)\n\t\t\tcontinue;\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_KERNEL);\n\t\tif (!ndata)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t \n\t\tndata->tag = TEGRA_MC_ICC_TAG_ISO;\n\t\tndata->node = node;\n\n\t\treturn ndata;\n\t}\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic int emc_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct tegra_emc *emc = to_tegra_emc_provider(dst->provider);\n\tunsigned long long peak_bw = icc_units_to_bps(dst->peak_bw);\n\tunsigned long long avg_bw = icc_units_to_bps(dst->avg_bw);\n\tunsigned long long rate = max(avg_bw, peak_bw);\n\tunsigned int dram_data_bus_width_bytes;\n\tint err;\n\n\t \n\tdram_data_bus_width_bytes = emc->dram_bus_width / 8;\n\tdo_div(rate, dram_data_bus_width_bytes);\n\trate = min_t(u64, rate, U32_MAX);\n\n\terr = emc_set_min_rate(emc, rate, EMC_RATE_ICC);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_interconnect_init(struct tegra_emc *emc)\n{\n\tconst struct tegra_mc_soc *soc;\n\tstruct icc_node *node;\n\tint err;\n\n\temc->mc = devm_tegra_memory_controller_get(emc->dev);\n\tif (IS_ERR(emc->mc))\n\t\treturn PTR_ERR(emc->mc);\n\n\tsoc = emc->mc->soc;\n\n\temc->provider.dev = emc->dev;\n\temc->provider.set = emc_icc_set;\n\temc->provider.data = &emc->provider;\n\temc->provider.aggregate = soc->icc_ops->aggregate;\n\temc->provider.xlate_extended = emc_of_icc_xlate_extended;\n\n\ticc_provider_init(&emc->provider);\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMC);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto err_msg;\n\t}\n\n\tnode->name = \"External Memory Controller\";\n\ticc_node_add(node, &emc->provider);\n\n\t \n\terr = icc_link_create(node, TEGRA_ICC_EMEM);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\t \n\tnode = icc_node_create(TEGRA_ICC_EMEM);\n\tif (IS_ERR(node)) {\n\t\terr = PTR_ERR(node);\n\t\tgoto remove_nodes;\n\t}\n\n\tnode->name = \"External Memory (DRAM)\";\n\ticc_node_add(node, &emc->provider);\n\n\terr = icc_provider_register(&emc->provider);\n\tif (err)\n\t\tgoto remove_nodes;\n\n\treturn 0;\n\nremove_nodes:\n\ticc_nodes_remove(&emc->provider);\nerr_msg:\n\tdev_err(emc->dev, \"failed to initialize ICC: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void devm_tegra_emc_unset_callback(void *data)\n{\n\ttegra20_clk_set_emc_round_callback(NULL, NULL);\n}\n\nstatic void devm_tegra_emc_unreg_clk_notifier(void *data)\n{\n\tstruct tegra_emc *emc = data;\n\n\tclk_notifier_unregister(emc->clk, &emc->clk_nb);\n}\n\nstatic int tegra_emc_init_clk(struct tegra_emc *emc)\n{\n\tint err;\n\n\ttegra20_clk_set_emc_round_callback(emc_round_rate, emc);\n\n\terr = devm_add_action_or_reset(emc->dev, devm_tegra_emc_unset_callback,\n\t\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\n\temc->clk = devm_clk_get(emc->dev, NULL);\n\tif (IS_ERR(emc->clk)) {\n\t\tdev_err(emc->dev, \"failed to get EMC clock: %pe\\n\", emc->clk);\n\t\treturn PTR_ERR(emc->clk);\n\t}\n\n\terr = clk_notifier_register(emc->clk, &emc->clk_nb);\n\tif (err) {\n\t\tdev_err(emc->dev, \"failed to register clk notifier: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(emc->dev,\n\t\t\t\t       devm_tegra_emc_unreg_clk_notifier, emc);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_emc_devfreq_target(struct device *dev, unsigned long *freq,\n\t\t\t\t    u32 flags)\n{\n\tstruct tegra_emc *emc = dev_get_drvdata(dev);\n\tstruct dev_pm_opp *opp;\n\tunsigned long rate;\n\n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(dev, \"failed to find opp for %lu Hz\\n\", *freq);\n\t\treturn PTR_ERR(opp);\n\t}\n\n\trate = dev_pm_opp_get_freq(opp);\n\tdev_pm_opp_put(opp);\n\n\treturn emc_set_min_rate(emc, rate, EMC_RATE_DEVFREQ);\n}\n\nstatic int tegra_emc_devfreq_get_dev_status(struct device *dev,\n\t\t\t\t\t    struct devfreq_dev_status *stat)\n{\n\tstruct tegra_emc *emc = dev_get_drvdata(dev);\n\n\t \n\twritel_relaxed(EMC_PWR_GATHER_DISABLE, emc->regs + EMC_STAT_CONTROL);\n\n\t \n\tstat->busy_time = readl_relaxed(emc->regs + EMC_STAT_PWR_COUNT);\n\tstat->total_time = readl_relaxed(emc->regs + EMC_STAT_PWR_CLOCKS);\n\tstat->current_frequency = clk_get_rate(emc->clk);\n\n\t \n\twritel_relaxed(EMC_PWR_GATHER_CLEAR, emc->regs + EMC_STAT_CONTROL);\n\twritel_relaxed(EMC_PWR_GATHER_ENABLE, emc->regs + EMC_STAT_CONTROL);\n\n\treturn 0;\n}\n\nstatic struct devfreq_dev_profile tegra_emc_devfreq_profile = {\n\t.polling_ms = 30,\n\t.target = tegra_emc_devfreq_target,\n\t.get_dev_status = tegra_emc_devfreq_get_dev_status,\n};\n\nstatic int tegra_emc_devfreq_init(struct tegra_emc *emc)\n{\n\tstruct devfreq *devfreq;\n\n\t \n\temc->ondemand_data.upthreshold = 20;\n\n\t \n\twritel_relaxed(0x00000000, emc->regs + EMC_STAT_CONTROL);\n\twritel_relaxed(0x00000000, emc->regs + EMC_STAT_LLMC_CONTROL);\n\twritel_relaxed(0xffffffff, emc->regs + EMC_STAT_PWR_CLOCK_LIMIT);\n\n\tdevfreq = devm_devfreq_add_device(emc->dev, &tegra_emc_devfreq_profile,\n\t\t\t\t\t  DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t  &emc->ondemand_data);\n\tif (IS_ERR(devfreq)) {\n\t\tdev_err(emc->dev, \"failed to initialize devfreq: %pe\", devfreq);\n\t\treturn PTR_ERR(devfreq);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_emc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_core_opp_params opp_params = {};\n\tstruct device_node *np;\n\tstruct tegra_emc *emc;\n\tint irq, err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_err(&pdev->dev, \"please update your device tree\\n\");\n\t\treturn irq;\n\t}\n\n\temc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);\n\tif (!emc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&emc->rate_lock);\n\temc->clk_nb.notifier_call = tegra_emc_clk_change_notify;\n\temc->dev = &pdev->dev;\n\n\temc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(emc->regs))\n\t\treturn PTR_ERR(emc->regs);\n\n\terr = emc_setup_hw(emc);\n\tif (err)\n\t\treturn err;\n\n\tnp = tegra_emc_find_node_by_ram_code(emc);\n\tif (np) {\n\t\terr = tegra_emc_load_timings_from_dt(emc, np);\n\t\tof_node_put(np);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = devm_request_irq(&pdev->dev, irq, tegra_emc_isr, 0,\n\t\t\t       dev_name(&pdev->dev), emc);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_emc_init_clk(emc);\n\tif (err)\n\t\treturn err;\n\n\topp_params.init_state = true;\n\n\terr = devm_tegra_core_dev_init_opp_table(&pdev->dev, &opp_params);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, emc);\n\ttegra_emc_rate_requests_init(emc);\n\ttegra_emc_debugfs_init(emc);\n\ttegra_emc_interconnect_init(emc);\n\ttegra_emc_devfreq_init(emc);\n\n\t \n\ttry_module_get(THIS_MODULE);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_emc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra20-emc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra_emc_of_match);\n\nstatic struct platform_driver tegra_emc_driver = {\n\t.probe = tegra_emc_probe,\n\t.driver = {\n\t\t.name = \"tegra20-emc\",\n\t\t.of_match_table = tegra_emc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.sync_state = icc_sync_state,\n\t},\n};\nmodule_platform_driver(tegra_emc_driver);\n\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra20 EMC driver\");\nMODULE_SOFTDEP(\"pre: governor_simpleondemand\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}