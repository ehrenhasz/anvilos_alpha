{
  "module_name": "exynos5422-dmc.c",
  "hash_id": "e3919008ce3a07078e9fae2af942c1ed0e016aa42dbde54b493ec5f1de26eb52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/samsung/exynos5422-dmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/devfreq.h>\n#include <linux/devfreq-event.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include \"../jedec_ddr.h\"\n#include \"../of_memory.h\"\n\nstatic int irqmode;\nmodule_param(irqmode, int, 0644);\nMODULE_PARM_DESC(irqmode, \"Enable IRQ mode (0=off [default], 1=on)\");\n\n#define EXYNOS5_DREXI_TIMINGAREF\t\t(0x0030)\n#define EXYNOS5_DREXI_TIMINGROW0\t\t(0x0034)\n#define EXYNOS5_DREXI_TIMINGDATA0\t\t(0x0038)\n#define EXYNOS5_DREXI_TIMINGPOWER0\t\t(0x003C)\n#define EXYNOS5_DREXI_TIMINGROW1\t\t(0x00E4)\n#define EXYNOS5_DREXI_TIMINGDATA1\t\t(0x00E8)\n#define EXYNOS5_DREXI_TIMINGPOWER1\t\t(0x00EC)\n#define CDREX_PAUSE\t\t\t\t(0x2091c)\n#define CDREX_LPDDR3PHY_CON3\t\t\t(0x20a20)\n#define CDREX_LPDDR3PHY_CLKM_SRC\t\t(0x20700)\n#define EXYNOS5_TIMING_SET_SWI\t\t\tBIT(28)\n#define USE_MX_MSPLL_TIMINGS\t\t\t(1)\n#define USE_BPLL_TIMINGS\t\t\t(0)\n#define EXYNOS5_AREF_NORMAL\t\t\t(0x2e)\n\n#define DREX_PPCCLKCON\t\t(0x0130)\n#define DREX_PEREV2CONFIG\t(0x013c)\n#define DREX_PMNC_PPC\t\t(0xE000)\n#define DREX_CNTENS_PPC\t\t(0xE010)\n#define DREX_CNTENC_PPC\t\t(0xE020)\n#define DREX_INTENS_PPC\t\t(0xE030)\n#define DREX_INTENC_PPC\t\t(0xE040)\n#define DREX_FLAG_PPC\t\t(0xE050)\n#define DREX_PMCNT2_PPC\t\t(0xE130)\n\n \n#define CC_RESET\t\tBIT(2)\n\n \n#define PPC_COUNTER_RESET\tBIT(1)\n\n \n#define PPC_ENABLE\t\tBIT(0)\n\n \n#define PEREV_CLK_EN\t\tBIT(0)\n\n \n#define PERF_CNT2\t\tBIT(2)\n#define PERF_CCNT\t\tBIT(31)\n\n \n#define READ_TRANSFER_CH0\t(0x6d)\n#define READ_TRANSFER_CH1\t(0x6f)\n\n#define PERF_COUNTER_START_VALUE 0xff000000\n#define PERF_EVENT_UP_DOWN_THRESHOLD 900000000ULL\n\n \nstruct dmc_opp_table {\n\tu32 freq_hz;\n\tu32 volt_uv;\n};\n\n \nstruct exynos5_dmc {\n\tstruct device *dev;\n\tstruct devfreq *df;\n\tstruct devfreq_simple_ondemand_data gov_data;\n\tvoid __iomem *base_drexi0;\n\tvoid __iomem *base_drexi1;\n\tstruct regmap *clk_regmap;\n\t \n\tstruct mutex lock;\n\tunsigned long curr_rate;\n\tunsigned long curr_volt;\n\tstruct dmc_opp_table *opp;\n\tint opp_count;\n\tu32 timings_arr_size;\n\tu32 *timing_row;\n\tu32 *timing_data;\n\tu32 *timing_power;\n\tconst struct lpddr3_timings *timings;\n\tconst struct lpddr3_min_tck *min_tck;\n\tu32 bypass_timing_row;\n\tu32 bypass_timing_data;\n\tu32 bypass_timing_power;\n\tstruct regulator *vdd_mif;\n\tstruct clk *fout_spll;\n\tstruct clk *fout_bpll;\n\tstruct clk *mout_spll;\n\tstruct clk *mout_bpll;\n\tstruct clk *mout_mclk_cdrex;\n\tstruct clk *mout_mx_mspll_ccore;\n\tstruct devfreq_event_dev **counter;\n\tint num_counters;\n\tu64 last_overflow_ts[2];\n\tunsigned long load;\n\tunsigned long total;\n\tbool in_irq_mode;\n};\n\n#define TIMING_FIELD(t_name, t_bit_beg, t_bit_end) \\\n\t{ .name = t_name, .bit_beg = t_bit_beg, .bit_end = t_bit_end }\n\n#define TIMING_VAL2REG(timing, t_val)\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\t\tu32 __val;\t\t\t\t\\\n\t\t__val = (t_val) << (timing)->bit_beg;\t\\\n\t\t__val;\t\t\t\t\t\\\n})\n\nstruct timing_reg {\n\tchar *name;\n\tint bit_beg;\n\tint bit_end;\n\tunsigned int val;\n};\n\nstatic const struct timing_reg timing_row_reg_fields[] = {\n\tTIMING_FIELD(\"tRFC\", 24, 31),\n\tTIMING_FIELD(\"tRRD\", 20, 23),\n\tTIMING_FIELD(\"tRP\", 16, 19),\n\tTIMING_FIELD(\"tRCD\", 12, 15),\n\tTIMING_FIELD(\"tRC\", 6, 11),\n\tTIMING_FIELD(\"tRAS\", 0, 5),\n};\n\nstatic const struct timing_reg timing_data_reg_fields[] = {\n\tTIMING_FIELD(\"tWTR\", 28, 31),\n\tTIMING_FIELD(\"tWR\", 24, 27),\n\tTIMING_FIELD(\"tRTP\", 20, 23),\n\tTIMING_FIELD(\"tW2W-C2C\", 14, 14),\n\tTIMING_FIELD(\"tR2R-C2C\", 12, 12),\n\tTIMING_FIELD(\"WL\", 8, 11),\n\tTIMING_FIELD(\"tDQSCK\", 4, 7),\n\tTIMING_FIELD(\"RL\", 0, 3),\n};\n\nstatic const struct timing_reg timing_power_reg_fields[] = {\n\tTIMING_FIELD(\"tFAW\", 26, 31),\n\tTIMING_FIELD(\"tXSR\", 16, 25),\n\tTIMING_FIELD(\"tXP\", 8, 15),\n\tTIMING_FIELD(\"tCKE\", 4, 7),\n\tTIMING_FIELD(\"tMRD\", 0, 3),\n};\n\n#define TIMING_COUNT (ARRAY_SIZE(timing_row_reg_fields) + \\\n\t\t      ARRAY_SIZE(timing_data_reg_fields) + \\\n\t\t      ARRAY_SIZE(timing_power_reg_fields))\n\nstatic int exynos5_counters_set_event(struct exynos5_dmc *dmc)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < dmc->num_counters; i++) {\n\t\tif (!dmc->counter[i])\n\t\t\tcontinue;\n\t\tret = devfreq_event_set_event(dmc->counter[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int exynos5_counters_enable_edev(struct exynos5_dmc *dmc)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < dmc->num_counters; i++) {\n\t\tif (!dmc->counter[i])\n\t\t\tcontinue;\n\t\tret = devfreq_event_enable_edev(dmc->counter[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int exynos5_counters_disable_edev(struct exynos5_dmc *dmc)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < dmc->num_counters; i++) {\n\t\tif (!dmc->counter[i])\n\t\t\tcontinue;\n\t\tret = devfreq_event_disable_edev(dmc->counter[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int find_target_freq_idx(struct exynos5_dmc *dmc,\n\t\t\t\tunsigned long target_rate)\n{\n\tint i;\n\n\tfor (i = dmc->opp_count - 1; i >= 0; i--)\n\t\tif (dmc->opp[i].freq_hz <= target_rate)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\n \nstatic int exynos5_switch_timing_regs(struct exynos5_dmc *dmc, bool set)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(dmc->clk_regmap, CDREX_LPDDR3PHY_CON3, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\treg |= EXYNOS5_TIMING_SET_SWI;\n\telse\n\t\treg &= ~EXYNOS5_TIMING_SET_SWI;\n\n\tregmap_write(dmc->clk_regmap, CDREX_LPDDR3PHY_CON3, reg);\n\n\treturn 0;\n}\n\n \nstatic int exynos5_init_freq_table(struct exynos5_dmc *dmc,\n\t\t\t\t   struct devfreq_dev_profile *profile)\n{\n\tint i, ret;\n\tint idx;\n\tunsigned long freq;\n\n\tret = devm_pm_opp_of_add_table(dmc->dev);\n\tif (ret < 0) {\n\t\tdev_err(dmc->dev, \"Failed to get OPP table\\n\");\n\t\treturn ret;\n\t}\n\n\tdmc->opp_count = dev_pm_opp_get_opp_count(dmc->dev);\n\n\tdmc->opp = devm_kmalloc_array(dmc->dev, dmc->opp_count,\n\t\t\t\t      sizeof(struct dmc_opp_table), GFP_KERNEL);\n\tif (!dmc->opp)\n\t\treturn -ENOMEM;\n\n\tidx = dmc->opp_count - 1;\n\tfor (i = 0, freq = ULONG_MAX; i < dmc->opp_count; i++, freq--) {\n\t\tstruct dev_pm_opp *opp;\n\n\t\topp = dev_pm_opp_find_freq_floor(dmc->dev, &freq);\n\t\tif (IS_ERR(opp))\n\t\t\treturn PTR_ERR(opp);\n\n\t\tdmc->opp[idx - i].freq_hz = freq;\n\t\tdmc->opp[idx - i].volt_uv = dev_pm_opp_get_voltage(opp);\n\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void exynos5_set_bypass_dram_timings(struct exynos5_dmc *dmc)\n{\n\twritel(EXYNOS5_AREF_NORMAL,\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGAREF);\n\n\twritel(dmc->bypass_timing_row,\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGROW1);\n\twritel(dmc->bypass_timing_row,\n\t       dmc->base_drexi1 + EXYNOS5_DREXI_TIMINGROW1);\n\twritel(dmc->bypass_timing_data,\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGDATA1);\n\twritel(dmc->bypass_timing_data,\n\t       dmc->base_drexi1 + EXYNOS5_DREXI_TIMINGDATA1);\n\twritel(dmc->bypass_timing_power,\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGPOWER1);\n\twritel(dmc->bypass_timing_power,\n\t       dmc->base_drexi1 + EXYNOS5_DREXI_TIMINGPOWER1);\n}\n\n \nstatic int exynos5_dram_change_timings(struct exynos5_dmc *dmc,\n\t\t\t\t       unsigned long target_rate)\n{\n\tint idx;\n\n\tfor (idx = dmc->opp_count - 1; idx >= 0; idx--)\n\t\tif (dmc->opp[idx].freq_hz <= target_rate)\n\t\t\tbreak;\n\n\tif (idx < 0)\n\t\treturn -EINVAL;\n\n\twritel(EXYNOS5_AREF_NORMAL,\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGAREF);\n\n\twritel(dmc->timing_row[idx],\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGROW0);\n\twritel(dmc->timing_row[idx],\n\t       dmc->base_drexi1 + EXYNOS5_DREXI_TIMINGROW0);\n\twritel(dmc->timing_data[idx],\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGDATA0);\n\twritel(dmc->timing_data[idx],\n\t       dmc->base_drexi1 + EXYNOS5_DREXI_TIMINGDATA0);\n\twritel(dmc->timing_power[idx],\n\t       dmc->base_drexi0 + EXYNOS5_DREXI_TIMINGPOWER0);\n\twritel(dmc->timing_power[idx],\n\t       dmc->base_drexi1 + EXYNOS5_DREXI_TIMINGPOWER0);\n\n\treturn 0;\n}\n\n \nstatic int exynos5_dmc_align_target_voltage(struct exynos5_dmc *dmc,\n\t\t\t\t\t    unsigned long target_volt)\n{\n\tint ret = 0;\n\n\tif (dmc->curr_volt <= target_volt)\n\t\treturn 0;\n\n\tret = regulator_set_voltage(dmc->vdd_mif, target_volt,\n\t\t\t\t    target_volt);\n\tif (!ret)\n\t\tdmc->curr_volt = target_volt;\n\n\treturn ret;\n}\n\n \nstatic int exynos5_dmc_align_bypass_voltage(struct exynos5_dmc *dmc,\n\t\t\t\t\t    unsigned long target_volt)\n{\n\tint ret = 0;\n\n\tif (dmc->curr_volt >= target_volt)\n\t\treturn 0;\n\n\tret = regulator_set_voltage(dmc->vdd_mif, target_volt,\n\t\t\t\t    target_volt);\n\tif (!ret)\n\t\tdmc->curr_volt = target_volt;\n\n\treturn ret;\n}\n\n \nstatic int exynos5_dmc_align_bypass_dram_timings(struct exynos5_dmc *dmc,\n\t\t\t\t\t\t unsigned long target_rate)\n{\n\tint idx = find_target_freq_idx(dmc, target_rate);\n\n\tif (idx < 0)\n\t\treturn -EINVAL;\n\n\texynos5_set_bypass_dram_timings(dmc);\n\n\treturn 0;\n}\n\n \nstatic int\nexynos5_dmc_switch_to_bypass_configuration(struct exynos5_dmc *dmc,\n\t\t\t\t\t   unsigned long target_rate,\n\t\t\t\t\t   unsigned long target_volt)\n{\n\tint ret;\n\n\t \n\tret = exynos5_dmc_align_bypass_voltage(dmc, target_volt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = exynos5_dmc_align_bypass_dram_timings(dmc, target_rate);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = exynos5_switch_timing_regs(dmc, USE_MX_MSPLL_TIMINGS);\n\n\treturn ret;\n}\n\n \nstatic int\nexynos5_dmc_change_freq_and_volt(struct exynos5_dmc *dmc,\n\t\t\t\t unsigned long target_rate,\n\t\t\t\t unsigned long target_volt)\n{\n\tint ret;\n\n\tret = exynos5_dmc_switch_to_bypass_configuration(dmc, target_rate,\n\t\t\t\t\t\t\t target_volt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk_prepare_enable(dmc->fout_spll);\n\tclk_prepare_enable(dmc->mout_spll);\n\tclk_prepare_enable(dmc->mout_mx_mspll_ccore);\n\n\tret = clk_set_parent(dmc->mout_mclk_cdrex, dmc->mout_mx_mspll_ccore);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\t \n\texynos5_dram_change_timings(dmc, target_rate);\n\n\tclk_set_rate(dmc->fout_bpll, target_rate);\n\n\tret = exynos5_switch_timing_regs(dmc, USE_BPLL_TIMINGS);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\tret = clk_set_parent(dmc->mout_mclk_cdrex, dmc->mout_bpll);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\t \n\tret = exynos5_dmc_align_target_voltage(dmc, target_volt);\n\ndisable_clocks:\n\tclk_disable_unprepare(dmc->mout_mx_mspll_ccore);\n\tclk_disable_unprepare(dmc->mout_spll);\n\tclk_disable_unprepare(dmc->fout_spll);\n\n\treturn ret;\n}\n\n \nstatic int exynos5_dmc_get_volt_freq(struct exynos5_dmc *dmc,\n\t\t\t\t     unsigned long *freq,\n\t\t\t\t     unsigned long *target_rate,\n\t\t\t\t     unsigned long *target_volt, u32 flags)\n{\n\tstruct dev_pm_opp *opp;\n\n\topp = devfreq_recommended_opp(dmc->dev, freq, flags);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\t*target_rate = dev_pm_opp_get_freq(opp);\n\t*target_volt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\treturn 0;\n}\n\n \nstatic int exynos5_dmc_target(struct device *dev, unsigned long *freq,\n\t\t\t      u32 flags)\n{\n\tstruct exynos5_dmc *dmc = dev_get_drvdata(dev);\n\tunsigned long target_rate = 0;\n\tunsigned long target_volt = 0;\n\tint ret;\n\n\tret = exynos5_dmc_get_volt_freq(dmc, freq, &target_rate, &target_volt,\n\t\t\t\t\tflags);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (target_rate == dmc->curr_rate)\n\t\treturn 0;\n\n\tmutex_lock(&dmc->lock);\n\n\tret = exynos5_dmc_change_freq_and_volt(dmc, target_rate, target_volt);\n\n\tif (ret) {\n\t\tmutex_unlock(&dmc->lock);\n\t\treturn ret;\n\t}\n\n\tdmc->curr_rate = target_rate;\n\n\tmutex_unlock(&dmc->lock);\n\treturn 0;\n}\n\n \nstatic int exynos5_counters_get(struct exynos5_dmc *dmc,\n\t\t\t\tunsigned long *load_count,\n\t\t\t\tunsigned long *total_count)\n{\n\tunsigned long total = 0;\n\tstruct devfreq_event_data event;\n\tint ret, i;\n\n\t*load_count = 0;\n\n\t \n\tfor (i = 0; i < dmc->num_counters; i++) {\n\t\tif (!dmc->counter[i])\n\t\t\tcontinue;\n\n\t\tret = devfreq_event_get_event(dmc->counter[i], &event);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*load_count += event.load_count;\n\n\t\tif (total < event.total_count)\n\t\t\ttotal = event.total_count;\n\t}\n\n\t*total_count = total;\n\n\treturn 0;\n}\n\n \nstatic void exynos5_dmc_start_perf_events(struct exynos5_dmc *dmc,\n\t\t\t\t\t  u32 beg_value)\n{\n\t \n\twritel(PERF_CNT2, dmc->base_drexi0 + DREX_INTENS_PPC);\n\twritel(PERF_CNT2, dmc->base_drexi1 + DREX_INTENS_PPC);\n\n\t \n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi0 + DREX_CNTENS_PPC);\n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi1 + DREX_CNTENS_PPC);\n\n\t \n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi0 + DREX_FLAG_PPC);\n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi1 + DREX_FLAG_PPC);\n\n\t \n\twritel(CC_RESET | PPC_COUNTER_RESET, dmc->base_drexi0 + DREX_PMNC_PPC);\n\twritel(CC_RESET | PPC_COUNTER_RESET, dmc->base_drexi1 + DREX_PMNC_PPC);\n\n\t \n\twritel(beg_value, dmc->base_drexi0 + DREX_PMCNT2_PPC);\n\twritel(beg_value, dmc->base_drexi1 + DREX_PMCNT2_PPC);\n\n\t \n\twritel(PPC_ENABLE, dmc->base_drexi0 + DREX_PMNC_PPC);\n\twritel(PPC_ENABLE, dmc->base_drexi1 + DREX_PMNC_PPC);\n}\n\n \nstatic void exynos5_dmc_perf_events_calc(struct exynos5_dmc *dmc, u64 diff_ts)\n{\n\t \n\tif (diff_ts < PERF_EVENT_UP_DOWN_THRESHOLD) {\n\t\t \n\t\tdmc->load = 70;\n\t\tdmc->total = 100;\n\t} else {\n\t\t \n\t\tdmc->load = 35;\n\t\tdmc->total = 100;\n\t}\n\n\tdev_dbg(dmc->dev, \"diff_ts=%llu\\n\", diff_ts);\n}\n\n \nstatic void exynos5_dmc_perf_events_check(struct exynos5_dmc *dmc)\n{\n\tu32 val;\n\tu64 diff_ts, ts;\n\n\tts = ktime_get_ns();\n\n\t \n\twritel(0, dmc->base_drexi0 + DREX_PMNC_PPC);\n\twritel(0, dmc->base_drexi1 + DREX_PMNC_PPC);\n\n\t \n\tval = readl(dmc->base_drexi0 + DREX_FLAG_PPC);\n\tif (val) {\n\t\tdiff_ts = ts - dmc->last_overflow_ts[0];\n\t\tdmc->last_overflow_ts[0] = ts;\n\t\tdev_dbg(dmc->dev, \"drex0 0xE050 val= 0x%08x\\n\",  val);\n\t} else {\n\t\tval = readl(dmc->base_drexi1 + DREX_FLAG_PPC);\n\t\tdiff_ts = ts - dmc->last_overflow_ts[1];\n\t\tdmc->last_overflow_ts[1] = ts;\n\t\tdev_dbg(dmc->dev, \"drex1 0xE050 val= 0x%08x\\n\",  val);\n\t}\n\n\texynos5_dmc_perf_events_calc(dmc, diff_ts);\n\n\texynos5_dmc_start_perf_events(dmc, PERF_COUNTER_START_VALUE);\n}\n\n \nstatic void exynos5_dmc_enable_perf_events(struct exynos5_dmc *dmc)\n{\n\tu64 ts;\n\n\t \n\twritel(PEREV_CLK_EN, dmc->base_drexi0 + DREX_PPCCLKCON);\n\twritel(PEREV_CLK_EN, dmc->base_drexi1 + DREX_PPCCLKCON);\n\n\t \n\twritel(READ_TRANSFER_CH0, dmc->base_drexi0 + DREX_PEREV2CONFIG);\n\twritel(READ_TRANSFER_CH1, dmc->base_drexi1 + DREX_PEREV2CONFIG);\n\n\tts = ktime_get_ns();\n\tdmc->last_overflow_ts[0] = ts;\n\tdmc->last_overflow_ts[1] = ts;\n\n\t \n\tdmc->load = 99;\n\tdmc->total = 100;\n}\n\n \nstatic void exynos5_dmc_disable_perf_events(struct exynos5_dmc *dmc)\n{\n\t \n\twritel(0, dmc->base_drexi0 + DREX_PMNC_PPC);\n\twritel(0, dmc->base_drexi1 + DREX_PMNC_PPC);\n\n\t \n\twritel(PERF_CNT2, dmc->base_drexi0 + DREX_INTENC_PPC);\n\twritel(PERF_CNT2, dmc->base_drexi1 + DREX_INTENC_PPC);\n\n\t \n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi0 + DREX_CNTENC_PPC);\n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi1 + DREX_CNTENC_PPC);\n\n\t \n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi0 + DREX_FLAG_PPC);\n\twritel(PERF_CNT2 | PERF_CCNT, dmc->base_drexi1 + DREX_FLAG_PPC);\n}\n\n \nstatic int exynos5_dmc_get_status(struct device *dev,\n\t\t\t\t  struct devfreq_dev_status *stat)\n{\n\tstruct exynos5_dmc *dmc = dev_get_drvdata(dev);\n\tunsigned long load, total;\n\tint ret;\n\n\tif (dmc->in_irq_mode) {\n\t\tmutex_lock(&dmc->lock);\n\t\tstat->current_frequency = dmc->curr_rate;\n\t\tmutex_unlock(&dmc->lock);\n\n\t\tstat->busy_time = dmc->load;\n\t\tstat->total_time = dmc->total;\n\t} else {\n\t\tret = exynos5_counters_get(dmc, &load, &total);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tstat->busy_time = load >> 10;\n\t\tstat->total_time = total >> 10;\n\n\t\tret = exynos5_counters_set_event(dmc);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"could not set event counter\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int exynos5_dmc_get_cur_freq(struct device *dev, unsigned long *freq)\n{\n\tstruct exynos5_dmc *dmc = dev_get_drvdata(dev);\n\n\tmutex_lock(&dmc->lock);\n\t*freq = dmc->curr_rate;\n\tmutex_unlock(&dmc->lock);\n\n\treturn 0;\n}\n\n \nstatic struct devfreq_dev_profile exynos5_dmc_df_profile = {\n\t.timer = DEVFREQ_TIMER_DELAYED,\n\t.target = exynos5_dmc_target,\n\t.get_dev_status = exynos5_dmc_get_status,\n\t.get_cur_freq = exynos5_dmc_get_cur_freq,\n};\n\n \nstatic unsigned long\nexynos5_dmc_align_init_freq(struct exynos5_dmc *dmc,\n\t\t\t    unsigned long bootloader_init_freq)\n{\n\tunsigned long aligned_freq;\n\tint idx;\n\n\tidx = find_target_freq_idx(dmc, bootloader_init_freq);\n\tif (idx >= 0)\n\t\taligned_freq = dmc->opp[idx].freq_hz;\n\telse\n\t\taligned_freq = dmc->opp[dmc->opp_count - 1].freq_hz;\n\n\treturn aligned_freq;\n}\n\n \nstatic int create_timings_aligned(struct exynos5_dmc *dmc, u32 *reg_timing_row,\n\t\t\t\t  u32 *reg_timing_data, u32 *reg_timing_power,\n\t\t\t\t  u32 clk_period_ps)\n{\n\tu32 val;\n\tconst struct timing_reg *reg;\n\n\tif (clk_period_ps == 0)\n\t\treturn -EINVAL;\n\n\t*reg_timing_row = 0;\n\t*reg_timing_data = 0;\n\t*reg_timing_power = 0;\n\n\tval = dmc->timings->tRFC / clk_period_ps;\n\tval += dmc->timings->tRFC % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRFC);\n\treg = &timing_row_reg_fields[0];\n\t*reg_timing_row |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRRD / clk_period_ps;\n\tval += dmc->timings->tRRD % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRRD);\n\treg = &timing_row_reg_fields[1];\n\t*reg_timing_row |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRPab / clk_period_ps;\n\tval += dmc->timings->tRPab % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRPab);\n\treg = &timing_row_reg_fields[2];\n\t*reg_timing_row |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRCD / clk_period_ps;\n\tval += dmc->timings->tRCD % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRCD);\n\treg = &timing_row_reg_fields[3];\n\t*reg_timing_row |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRC / clk_period_ps;\n\tval += dmc->timings->tRC % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRC);\n\treg = &timing_row_reg_fields[4];\n\t*reg_timing_row |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRAS / clk_period_ps;\n\tval += dmc->timings->tRAS % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRAS);\n\treg = &timing_row_reg_fields[5];\n\t*reg_timing_row |= TIMING_VAL2REG(reg, val);\n\n\t \n\tval = dmc->timings->tWTR / clk_period_ps;\n\tval += dmc->timings->tWTR % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tWTR);\n\treg = &timing_data_reg_fields[0];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tWR / clk_period_ps;\n\tval += dmc->timings->tWR % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tWR);\n\treg = &timing_data_reg_fields[1];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRTP / clk_period_ps;\n\tval += dmc->timings->tRTP % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRTP);\n\treg = &timing_data_reg_fields[2];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tW2W_C2C / clk_period_ps;\n\tval += dmc->timings->tW2W_C2C % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tW2W_C2C);\n\treg = &timing_data_reg_fields[3];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tR2R_C2C / clk_period_ps;\n\tval += dmc->timings->tR2R_C2C % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tR2R_C2C);\n\treg = &timing_data_reg_fields[4];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tWL / clk_period_ps;\n\tval += dmc->timings->tWL % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tWL);\n\treg = &timing_data_reg_fields[5];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tDQSCK / clk_period_ps;\n\tval += dmc->timings->tDQSCK % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tDQSCK);\n\treg = &timing_data_reg_fields[6];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tRL / clk_period_ps;\n\tval += dmc->timings->tRL % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tRL);\n\treg = &timing_data_reg_fields[7];\n\t*reg_timing_data |= TIMING_VAL2REG(reg, val);\n\n\t \n\tval = dmc->timings->tFAW / clk_period_ps;\n\tval += dmc->timings->tFAW % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tFAW);\n\treg = &timing_power_reg_fields[0];\n\t*reg_timing_power |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tXSR / clk_period_ps;\n\tval += dmc->timings->tXSR % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tXSR);\n\treg = &timing_power_reg_fields[1];\n\t*reg_timing_power |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tXP / clk_period_ps;\n\tval += dmc->timings->tXP % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tXP);\n\treg = &timing_power_reg_fields[2];\n\t*reg_timing_power |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tCKE / clk_period_ps;\n\tval += dmc->timings->tCKE % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tCKE);\n\treg = &timing_power_reg_fields[3];\n\t*reg_timing_power |= TIMING_VAL2REG(reg, val);\n\n\tval = dmc->timings->tMRD / clk_period_ps;\n\tval += dmc->timings->tMRD % clk_period_ps ? 1 : 0;\n\tval = max(val, dmc->min_tck->tMRD);\n\treg = &timing_power_reg_fields[4];\n\t*reg_timing_power |= TIMING_VAL2REG(reg, val);\n\n\treturn 0;\n}\n\n \nstatic int of_get_dram_timings(struct exynos5_dmc *dmc)\n{\n\tint ret = 0;\n\tint idx;\n\tstruct device_node *np_ddr;\n\tu32 freq_mhz, clk_period_ps;\n\n\tnp_ddr = of_parse_phandle(dmc->dev->of_node, \"device-handle\", 0);\n\tif (!np_ddr) {\n\t\tdev_warn(dmc->dev, \"could not find 'device-handle' in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdmc->timing_row = devm_kmalloc_array(dmc->dev, TIMING_COUNT,\n\t\t\t\t\t     sizeof(u32), GFP_KERNEL);\n\tif (!dmc->timing_row) {\n\t\tret = -ENOMEM;\n\t\tgoto put_node;\n\t}\n\n\tdmc->timing_data = devm_kmalloc_array(dmc->dev, TIMING_COUNT,\n\t\t\t\t\t      sizeof(u32), GFP_KERNEL);\n\tif (!dmc->timing_data) {\n\t\tret = -ENOMEM;\n\t\tgoto put_node;\n\t}\n\n\tdmc->timing_power = devm_kmalloc_array(dmc->dev, TIMING_COUNT,\n\t\t\t\t\t       sizeof(u32), GFP_KERNEL);\n\tif (!dmc->timing_power) {\n\t\tret = -ENOMEM;\n\t\tgoto put_node;\n\t}\n\n\tdmc->timings = of_lpddr3_get_ddr_timings(np_ddr, dmc->dev,\n\t\t\t\t\t\t DDR_TYPE_LPDDR3,\n\t\t\t\t\t\t &dmc->timings_arr_size);\n\tif (!dmc->timings) {\n\t\tdev_warn(dmc->dev, \"could not get timings from DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_node;\n\t}\n\n\tdmc->min_tck = of_lpddr3_get_min_tck(np_ddr, dmc->dev);\n\tif (!dmc->min_tck) {\n\t\tdev_warn(dmc->dev, \"could not get tck from DT\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_node;\n\t}\n\n\t \n\tfor (idx = 0; idx < dmc->opp_count; idx++) {\n\t\tfreq_mhz = dmc->opp[idx].freq_hz / 1000000;\n\t\tclk_period_ps = 1000000 / freq_mhz;\n\n\t\tret = create_timings_aligned(dmc, &dmc->timing_row[idx],\n\t\t\t\t\t     &dmc->timing_data[idx],\n\t\t\t\t\t     &dmc->timing_power[idx],\n\t\t\t\t\t     clk_period_ps);\n\t}\n\n\n\t \n\tdmc->bypass_timing_row = dmc->timing_row[idx - 1];\n\tdmc->bypass_timing_data = dmc->timing_data[idx - 1];\n\tdmc->bypass_timing_power = dmc->timing_power[idx - 1];\n\nput_node:\n\tof_node_put(np_ddr);\n\treturn ret;\n}\n\n \nstatic int exynos5_dmc_init_clks(struct exynos5_dmc *dmc)\n{\n\tint ret;\n\tunsigned long target_volt = 0;\n\tunsigned long target_rate = 0;\n\tunsigned int tmp;\n\n\tdmc->fout_spll = devm_clk_get(dmc->dev, \"fout_spll\");\n\tif (IS_ERR(dmc->fout_spll))\n\t\treturn PTR_ERR(dmc->fout_spll);\n\n\tdmc->fout_bpll = devm_clk_get(dmc->dev, \"fout_bpll\");\n\tif (IS_ERR(dmc->fout_bpll))\n\t\treturn PTR_ERR(dmc->fout_bpll);\n\n\tdmc->mout_mclk_cdrex = devm_clk_get(dmc->dev, \"mout_mclk_cdrex\");\n\tif (IS_ERR(dmc->mout_mclk_cdrex))\n\t\treturn PTR_ERR(dmc->mout_mclk_cdrex);\n\n\tdmc->mout_bpll = devm_clk_get(dmc->dev, \"mout_bpll\");\n\tif (IS_ERR(dmc->mout_bpll))\n\t\treturn PTR_ERR(dmc->mout_bpll);\n\n\tdmc->mout_mx_mspll_ccore = devm_clk_get(dmc->dev,\n\t\t\t\t\t\t\"mout_mx_mspll_ccore\");\n\tif (IS_ERR(dmc->mout_mx_mspll_ccore))\n\t\treturn PTR_ERR(dmc->mout_mx_mspll_ccore);\n\n\tdmc->mout_spll = devm_clk_get(dmc->dev, \"ff_dout_spll2\");\n\tif (IS_ERR(dmc->mout_spll)) {\n\t\tdmc->mout_spll = devm_clk_get(dmc->dev, \"mout_sclk_spll\");\n\t\tif (IS_ERR(dmc->mout_spll))\n\t\t\treturn PTR_ERR(dmc->mout_spll);\n\t}\n\n\t \n\tdmc->curr_rate = clk_get_rate(dmc->mout_mclk_cdrex);\n\tdmc->curr_rate = exynos5_dmc_align_init_freq(dmc, dmc->curr_rate);\n\texynos5_dmc_df_profile.initial_freq = dmc->curr_rate;\n\n\tret = exynos5_dmc_get_volt_freq(dmc, &dmc->curr_rate, &target_rate,\n\t\t\t\t\t&target_volt, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdmc->curr_volt = target_volt;\n\n\tret = clk_set_parent(dmc->mout_mx_mspll_ccore, dmc->mout_spll);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_prepare_enable(dmc->fout_bpll);\n\tclk_prepare_enable(dmc->mout_bpll);\n\n\t \n\tregmap_read(dmc->clk_regmap, CDREX_LPDDR3PHY_CLKM_SRC, &tmp);\n\ttmp &= ~(BIT(1) | BIT(0));\n\tregmap_write(dmc->clk_regmap, CDREX_LPDDR3PHY_CLKM_SRC, tmp);\n\n\treturn 0;\n}\n\n \nstatic int exynos5_performance_counters_init(struct exynos5_dmc *dmc)\n{\n\tint ret, i;\n\n\tdmc->num_counters = devfreq_event_get_edev_count(dmc->dev,\n\t\t\t\t\t\t\t\"devfreq-events\");\n\tif (dmc->num_counters < 0) {\n\t\tdev_err(dmc->dev, \"could not get devfreq-event counters\\n\");\n\t\treturn dmc->num_counters;\n\t}\n\n\tdmc->counter = devm_kcalloc(dmc->dev, dmc->num_counters,\n\t\t\t\t    sizeof(*dmc->counter), GFP_KERNEL);\n\tif (!dmc->counter)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dmc->num_counters; i++) {\n\t\tdmc->counter[i] =\n\t\t\tdevfreq_event_get_edev_by_phandle(dmc->dev,\n\t\t\t\t\t\t\"devfreq-events\", i);\n\t\tif (IS_ERR_OR_NULL(dmc->counter[i]))\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tret = exynos5_counters_enable_edev(dmc);\n\tif (ret < 0) {\n\t\tdev_err(dmc->dev, \"could not enable event counter\\n\");\n\t\treturn ret;\n\t}\n\n\tret = exynos5_counters_set_event(dmc);\n\tif (ret < 0) {\n\t\texynos5_counters_disable_edev(dmc);\n\t\tdev_err(dmc->dev, \"could not set event counter\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int exynos5_dmc_set_pause_on_switching(struct exynos5_dmc *dmc)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(dmc->clk_regmap, CDREX_PAUSE, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval |= 1UL;\n\tregmap_write(dmc->clk_regmap, CDREX_PAUSE, val);\n\n\treturn 0;\n}\n\nstatic irqreturn_t dmc_irq_thread(int irq, void *priv)\n{\n\tint res;\n\tstruct exynos5_dmc *dmc = priv;\n\n\tmutex_lock(&dmc->df->lock);\n\texynos5_dmc_perf_events_check(dmc);\n\tres = update_devfreq(dmc->df);\n\tmutex_unlock(&dmc->df->lock);\n\n\tif (res)\n\t\tdev_warn(dmc->dev, \"devfreq failed with %d\\n\", res);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int exynos5_dmc_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct exynos5_dmc *dmc;\n\tint irq[2];\n\n\tdmc = devm_kzalloc(dev, sizeof(*dmc), GFP_KERNEL);\n\tif (!dmc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dmc->lock);\n\n\tdmc->dev = dev;\n\tplatform_set_drvdata(pdev, dmc);\n\n\tdmc->base_drexi0 = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dmc->base_drexi0))\n\t\treturn PTR_ERR(dmc->base_drexi0);\n\n\tdmc->base_drexi1 = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(dmc->base_drexi1))\n\t\treturn PTR_ERR(dmc->base_drexi1);\n\n\tdmc->clk_regmap = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t\t  \"samsung,syscon-clk\");\n\tif (IS_ERR(dmc->clk_regmap))\n\t\treturn PTR_ERR(dmc->clk_regmap);\n\n\tret = exynos5_init_freq_table(dmc, &exynos5_dmc_df_profile);\n\tif (ret) {\n\t\tdev_warn(dev, \"couldn't initialize frequency settings\\n\");\n\t\treturn ret;\n\t}\n\n\tdmc->vdd_mif = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(dmc->vdd_mif)) {\n\t\tret = PTR_ERR(dmc->vdd_mif);\n\t\treturn ret;\n\t}\n\n\tret = exynos5_dmc_init_clks(dmc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_get_dram_timings(dmc);\n\tif (ret) {\n\t\tdev_warn(dev, \"couldn't initialize timings settings\\n\");\n\t\tgoto remove_clocks;\n\t}\n\n\tret = exynos5_dmc_set_pause_on_switching(dmc);\n\tif (ret) {\n\t\tdev_warn(dev, \"couldn't get access to PAUSE register\\n\");\n\t\tgoto remove_clocks;\n\t}\n\n\t \n\tirq[0] = platform_get_irq_byname(pdev, \"drex_0\");\n\tirq[1] = platform_get_irq_byname(pdev, \"drex_1\");\n\tif (irq[0] > 0 && irq[1] > 0 && irqmode) {\n\t\tret = devm_request_threaded_irq(dev, irq[0], NULL,\n\t\t\t\t\t\tdmc_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), dmc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"couldn't grab IRQ\\n\");\n\t\t\tgoto remove_clocks;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, irq[1], NULL,\n\t\t\t\t\t\tdmc_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), dmc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"couldn't grab IRQ\\n\");\n\t\t\tgoto remove_clocks;\n\t\t}\n\n\t\t \n\t\tdmc->gov_data.upthreshold = 55;\n\t\tdmc->gov_data.downdifferential = 5;\n\n\t\texynos5_dmc_enable_perf_events(dmc);\n\n\t\tdmc->in_irq_mode = 1;\n\t} else {\n\t\tret = exynos5_performance_counters_init(dmc);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"couldn't probe performance counters\\n\");\n\t\t\tgoto remove_clocks;\n\t\t}\n\n\t\t \n\t\tdmc->gov_data.upthreshold = 10;\n\t\tdmc->gov_data.downdifferential = 5;\n\n\t\texynos5_dmc_df_profile.polling_ms = 100;\n\t}\n\n\tdmc->df = devm_devfreq_add_device(dev, &exynos5_dmc_df_profile,\n\t\t\t\t\t  DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t  &dmc->gov_data);\n\n\tif (IS_ERR(dmc->df)) {\n\t\tret = PTR_ERR(dmc->df);\n\t\tgoto err_devfreq_add;\n\t}\n\n\tif (dmc->in_irq_mode)\n\t\texynos5_dmc_start_perf_events(dmc, PERF_COUNTER_START_VALUE);\n\n\tdev_info(dev, \"DMC initialized, in irq mode: %d\\n\", dmc->in_irq_mode);\n\n\treturn 0;\n\nerr_devfreq_add:\n\tif (dmc->in_irq_mode)\n\t\texynos5_dmc_disable_perf_events(dmc);\n\telse\n\t\texynos5_counters_disable_edev(dmc);\nremove_clocks:\n\tclk_disable_unprepare(dmc->mout_bpll);\n\tclk_disable_unprepare(dmc->fout_bpll);\n\n\treturn ret;\n}\n\n \nstatic int exynos5_dmc_remove(struct platform_device *pdev)\n{\n\tstruct exynos5_dmc *dmc = dev_get_drvdata(&pdev->dev);\n\n\tif (dmc->in_irq_mode)\n\t\texynos5_dmc_disable_perf_events(dmc);\n\telse\n\t\texynos5_counters_disable_edev(dmc);\n\n\tclk_disable_unprepare(dmc->mout_bpll);\n\tclk_disable_unprepare(dmc->fout_bpll);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id exynos5_dmc_of_match[] = {\n\t{ .compatible = \"samsung,exynos5422-dmc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos5_dmc_of_match);\n\nstatic struct platform_driver exynos5_dmc_platdrv = {\n\t.probe\t= exynos5_dmc_probe,\n\t.remove = exynos5_dmc_remove,\n\t.driver = {\n\t\t.name\t= \"exynos5-dmc\",\n\t\t.of_match_table = exynos5_dmc_of_match,\n\t},\n};\nmodule_platform_driver(exynos5_dmc_platdrv);\nMODULE_DESCRIPTION(\"Driver for Exynos5422 Dynamic Memory Controller dynamic frequency and voltage change\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Lukasz Luba\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}