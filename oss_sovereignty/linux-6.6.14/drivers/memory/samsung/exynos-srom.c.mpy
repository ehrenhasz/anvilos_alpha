{
  "module_name": "exynos-srom.c",
  "hash_id": "d9ba5167d2c9a018cab31370cf3823961f9054f5fe77612923604f9f83090705",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/samsung/exynos-srom.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"exynos-srom.h\"\n\nstatic const unsigned long exynos_srom_offsets[] = {\n\t \n\tEXYNOS_SROM_BW,\n\tEXYNOS_SROM_BC0,\n\tEXYNOS_SROM_BC1,\n\tEXYNOS_SROM_BC2,\n\tEXYNOS_SROM_BC3,\n};\n\n \nstruct exynos_srom_reg_dump {\n\tu32     offset;\n\tu32     value;\n};\n\n \nstruct exynos_srom {\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tstruct exynos_srom_reg_dump *reg_offset;\n};\n\nstatic struct exynos_srom_reg_dump *\nexynos_srom_alloc_reg_dump(const unsigned long *rdump,\n\t\t\t   unsigned long nr_rdump)\n{\n\tstruct exynos_srom_reg_dump *rd;\n\tunsigned int i;\n\n\trd = kcalloc(nr_rdump, sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_rdump; ++i)\n\t\trd[i].offset = rdump[i];\n\n\treturn rd;\n}\n\nstatic int exynos_srom_configure_bank(struct exynos_srom *srom,\n\t\t\t\t      struct device_node *np)\n{\n\tu32 bank, width, pmc = 0;\n\tu32 timing[6];\n\tu32 cs, bw;\n\n\tif (of_property_read_u32(np, \"reg\", &bank))\n\t\treturn -EINVAL;\n\tif (of_property_read_u32(np, \"reg-io-width\", &width))\n\t\twidth = 1;\n\tif (of_property_read_bool(np, \"samsung,srom-page-mode\"))\n\t\tpmc = 1 << EXYNOS_SROM_BCX__PMC__SHIFT;\n\tif (of_property_read_u32_array(np, \"samsung,srom-timing\", timing,\n\t\t\t\t       ARRAY_SIZE(timing)))\n\t\treturn -EINVAL;\n\n\tbank *= 4;  \n\n\tcs = 1 << EXYNOS_SROM_BW__BYTEENABLE__SHIFT;\n\tif (width == 2)\n\t\tcs |= 1 << EXYNOS_SROM_BW__DATAWIDTH__SHIFT;\n\n\tbw = readl_relaxed(srom->reg_base + EXYNOS_SROM_BW);\n\tbw = (bw & ~(EXYNOS_SROM_BW__CS_MASK << bank)) | (cs << bank);\n\twritel_relaxed(bw, srom->reg_base + EXYNOS_SROM_BW);\n\n\twritel_relaxed(pmc | (timing[0] << EXYNOS_SROM_BCX__TACP__SHIFT) |\n\t\t       (timing[1] << EXYNOS_SROM_BCX__TCAH__SHIFT) |\n\t\t       (timing[2] << EXYNOS_SROM_BCX__TCOH__SHIFT) |\n\t\t       (timing[3] << EXYNOS_SROM_BCX__TACC__SHIFT) |\n\t\t       (timing[4] << EXYNOS_SROM_BCX__TCOS__SHIFT) |\n\t\t       (timing[5] << EXYNOS_SROM_BCX__TACS__SHIFT),\n\t\t       srom->reg_base + EXYNOS_SROM_BC0 + bank);\n\n\treturn 0;\n}\n\nstatic int exynos_srom_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np, *child;\n\tstruct exynos_srom *srom;\n\tstruct device *dev = &pdev->dev;\n\tbool bad_bank_config = false;\n\n\tnp = dev->of_node;\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"could not find device info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsrom = devm_kzalloc(&pdev->dev,\n\t\t\t    sizeof(struct exynos_srom), GFP_KERNEL);\n\tif (!srom)\n\t\treturn -ENOMEM;\n\n\tsrom->dev = dev;\n\tsrom->reg_base = of_iomap(np, 0);\n\tif (!srom->reg_base) {\n\t\tdev_err(&pdev->dev, \"iomap of exynos srom controller failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, srom);\n\n\tsrom->reg_offset = exynos_srom_alloc_reg_dump(exynos_srom_offsets,\n\t\t\t\t\t\t      ARRAY_SIZE(exynos_srom_offsets));\n\tif (!srom->reg_offset) {\n\t\tiounmap(srom->reg_base);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (exynos_srom_configure_bank(srom, child)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Could not decode bank configuration for %pOFn\\n\",\n\t\t\t\tchild);\n\t\t\tbad_bank_config = true;\n\t\t}\n\t}\n\n\t \n\tif (bad_bank_config)\n\t\treturn 0;\n\n\treturn of_platform_populate(np, NULL, NULL, dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void exynos_srom_save(void __iomem *base,\n\t\t\t     struct exynos_srom_reg_dump *rd,\n\t\t\t     unsigned int num_regs)\n{\n\tfor (; num_regs > 0; --num_regs, ++rd)\n\t\trd->value = readl(base + rd->offset);\n}\n\nstatic void exynos_srom_restore(void __iomem *base,\n\t\t\t\tconst struct exynos_srom_reg_dump *rd,\n\t\t\t\tunsigned int num_regs)\n{\n\tfor (; num_regs > 0; --num_regs, ++rd)\n\t\twritel(rd->value, base + rd->offset);\n}\n\nstatic int exynos_srom_suspend(struct device *dev)\n{\n\tstruct exynos_srom *srom = dev_get_drvdata(dev);\n\n\texynos_srom_save(srom->reg_base, srom->reg_offset,\n\t\t\t ARRAY_SIZE(exynos_srom_offsets));\n\treturn 0;\n}\n\nstatic int exynos_srom_resume(struct device *dev)\n{\n\tstruct exynos_srom *srom = dev_get_drvdata(dev);\n\n\texynos_srom_restore(srom->reg_base, srom->reg_offset,\n\t\t\t    ARRAY_SIZE(exynos_srom_offsets));\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id of_exynos_srom_ids[] = {\n\t{\n\t\t.compatible\t= \"samsung,exynos4210-srom\",\n\t},\n\t{},\n};\n\nstatic SIMPLE_DEV_PM_OPS(exynos_srom_pm_ops, exynos_srom_suspend, exynos_srom_resume);\n\nstatic struct platform_driver exynos_srom_driver = {\n\t.probe = exynos_srom_probe,\n\t.driver = {\n\t\t.name = \"exynos-srom\",\n\t\t.of_match_table = of_exynos_srom_ids,\n\t\t.pm = &exynos_srom_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(exynos_srom_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}