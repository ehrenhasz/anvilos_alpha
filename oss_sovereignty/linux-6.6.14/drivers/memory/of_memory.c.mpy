{
  "module_name": "of_memory.c",
  "hash_id": "1af3279beb0b34064b9b81d59531fb4ed7cad76454686490704fa856758bd699",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/of_memory.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n\n#include \"jedec_ddr.h\"\n#include \"of_memory.h\"\n\n \nconst struct lpddr2_min_tck *of_get_min_tck(struct device_node *np,\n\t\t\t\t\t    struct device *dev)\n{\n\tint\t\t\tret = 0;\n\tstruct lpddr2_min_tck\t*min;\n\n\tmin = devm_kzalloc(dev, sizeof(*min), GFP_KERNEL);\n\tif (!min)\n\t\tgoto default_min_tck;\n\n\tret |= of_property_read_u32(np, \"tRPab-min-tck\", &min->tRPab);\n\tret |= of_property_read_u32(np, \"tRCD-min-tck\", &min->tRCD);\n\tret |= of_property_read_u32(np, \"tWR-min-tck\", &min->tWR);\n\tret |= of_property_read_u32(np, \"tRASmin-min-tck\", &min->tRASmin);\n\tret |= of_property_read_u32(np, \"tRRD-min-tck\", &min->tRRD);\n\tret |= of_property_read_u32(np, \"tWTR-min-tck\", &min->tWTR);\n\tret |= of_property_read_u32(np, \"tXP-min-tck\", &min->tXP);\n\tret |= of_property_read_u32(np, \"tRTP-min-tck\", &min->tRTP);\n\tret |= of_property_read_u32(np, \"tCKE-min-tck\", &min->tCKE);\n\tret |= of_property_read_u32(np, \"tCKESR-min-tck\", &min->tCKESR);\n\tret |= of_property_read_u32(np, \"tFAW-min-tck\", &min->tFAW);\n\n\tif (ret) {\n\t\tdevm_kfree(dev, min);\n\t\tgoto default_min_tck;\n\t}\n\n\treturn min;\n\ndefault_min_tck:\n\tdev_warn(dev, \"Using default min-tck values\\n\");\n\treturn &lpddr2_jedec_min_tck;\n}\nEXPORT_SYMBOL(of_get_min_tck);\n\nstatic int of_do_get_timings(struct device_node *np,\n\t\t\t     struct lpddr2_timings *tim)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"max-freq\", &tim->max_freq);\n\tret |= of_property_read_u32(np, \"min-freq\", &tim->min_freq);\n\tret |= of_property_read_u32(np, \"tRPab\", &tim->tRPab);\n\tret |= of_property_read_u32(np, \"tRCD\", &tim->tRCD);\n\tret |= of_property_read_u32(np, \"tWR\", &tim->tWR);\n\tret |= of_property_read_u32(np, \"tRAS-min\", &tim->tRAS_min);\n\tret |= of_property_read_u32(np, \"tRRD\", &tim->tRRD);\n\tret |= of_property_read_u32(np, \"tWTR\", &tim->tWTR);\n\tret |= of_property_read_u32(np, \"tXP\", &tim->tXP);\n\tret |= of_property_read_u32(np, \"tRTP\", &tim->tRTP);\n\tret |= of_property_read_u32(np, \"tCKESR\", &tim->tCKESR);\n\tret |= of_property_read_u32(np, \"tDQSCK-max\", &tim->tDQSCK_max);\n\tret |= of_property_read_u32(np, \"tFAW\", &tim->tFAW);\n\tret |= of_property_read_u32(np, \"tZQCS\", &tim->tZQCS);\n\tret |= of_property_read_u32(np, \"tZQCL\", &tim->tZQCL);\n\tret |= of_property_read_u32(np, \"tZQinit\", &tim->tZQinit);\n\tret |= of_property_read_u32(np, \"tRAS-max-ns\", &tim->tRAS_max_ns);\n\tret |= of_property_read_u32(np, \"tDQSCK-max-derated\",\n\t\t\t\t    &tim->tDQSCK_max_derated);\n\n\treturn ret;\n}\n\n \nconst struct lpddr2_timings *of_get_ddr_timings(struct device_node *np_ddr,\n\t\t\t\t\t\tstruct device *dev,\n\t\t\t\t\t\tu32 device_type,\n\t\t\t\t\t\tu32 *nr_frequencies)\n{\n\tstruct lpddr2_timings\t*timings = NULL;\n\tu32\t\t\tarr_sz = 0, i = 0;\n\tstruct device_node\t*np_tim;\n\tchar\t\t\t*tim_compat = NULL;\n\n\tswitch (device_type) {\n\tcase DDR_TYPE_LPDDR2_S2:\n\tcase DDR_TYPE_LPDDR2_S4:\n\t\ttim_compat = \"jedec,lpddr2-timings\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unsupported memory type\\n\");\n\t}\n\n\tfor_each_child_of_node(np_ddr, np_tim)\n\t\tif (of_device_is_compatible(np_tim, tim_compat))\n\t\t\tarr_sz++;\n\n\tif (arr_sz)\n\t\ttimings = devm_kcalloc(dev, arr_sz, sizeof(*timings),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!timings)\n\t\tgoto default_timings;\n\n\tfor_each_child_of_node(np_ddr, np_tim) {\n\t\tif (of_device_is_compatible(np_tim, tim_compat)) {\n\t\t\tif (of_do_get_timings(np_tim, &timings[i])) {\n\t\t\t\tof_node_put(np_tim);\n\t\t\t\tdevm_kfree(dev, timings);\n\t\t\t\tgoto default_timings;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\t*nr_frequencies = arr_sz;\n\n\treturn timings;\n\ndefault_timings:\n\tdev_warn(dev, \"Using default memory timings\\n\");\n\t*nr_frequencies = ARRAY_SIZE(lpddr2_jedec_timings);\n\treturn lpddr2_jedec_timings;\n}\nEXPORT_SYMBOL(of_get_ddr_timings);\n\n \nconst struct lpddr3_min_tck *of_lpddr3_get_min_tck(struct device_node *np,\n\t\t\t\t\t\t   struct device *dev)\n{\n\tint\t\t\tret = 0;\n\tstruct lpddr3_min_tck\t*min;\n\n\tmin = devm_kzalloc(dev, sizeof(*min), GFP_KERNEL);\n\tif (!min)\n\t\tgoto default_min_tck;\n\n\tret |= of_property_read_u32(np, \"tRFC-min-tck\", &min->tRFC);\n\tret |= of_property_read_u32(np, \"tRRD-min-tck\", &min->tRRD);\n\tret |= of_property_read_u32(np, \"tRPab-min-tck\", &min->tRPab);\n\tret |= of_property_read_u32(np, \"tRPpb-min-tck\", &min->tRPpb);\n\tret |= of_property_read_u32(np, \"tRCD-min-tck\", &min->tRCD);\n\tret |= of_property_read_u32(np, \"tRC-min-tck\", &min->tRC);\n\tret |= of_property_read_u32(np, \"tRAS-min-tck\", &min->tRAS);\n\tret |= of_property_read_u32(np, \"tWTR-min-tck\", &min->tWTR);\n\tret |= of_property_read_u32(np, \"tWR-min-tck\", &min->tWR);\n\tret |= of_property_read_u32(np, \"tRTP-min-tck\", &min->tRTP);\n\tret |= of_property_read_u32(np, \"tW2W-C2C-min-tck\", &min->tW2W_C2C);\n\tret |= of_property_read_u32(np, \"tR2R-C2C-min-tck\", &min->tR2R_C2C);\n\tret |= of_property_read_u32(np, \"tWL-min-tck\", &min->tWL);\n\tret |= of_property_read_u32(np, \"tDQSCK-min-tck\", &min->tDQSCK);\n\tret |= of_property_read_u32(np, \"tRL-min-tck\", &min->tRL);\n\tret |= of_property_read_u32(np, \"tFAW-min-tck\", &min->tFAW);\n\tret |= of_property_read_u32(np, \"tXSR-min-tck\", &min->tXSR);\n\tret |= of_property_read_u32(np, \"tXP-min-tck\", &min->tXP);\n\tret |= of_property_read_u32(np, \"tCKE-min-tck\", &min->tCKE);\n\tret |= of_property_read_u32(np, \"tCKESR-min-tck\", &min->tCKESR);\n\tret |= of_property_read_u32(np, \"tMRD-min-tck\", &min->tMRD);\n\n\tif (ret) {\n\t\tdev_warn(dev, \"Errors while parsing min-tck values\\n\");\n\t\tdevm_kfree(dev, min);\n\t\tgoto default_min_tck;\n\t}\n\n\treturn min;\n\ndefault_min_tck:\n\tdev_warn(dev, \"Using default min-tck values\\n\");\n\treturn NULL;\n}\nEXPORT_SYMBOL(of_lpddr3_get_min_tck);\n\nstatic int of_lpddr3_do_get_timings(struct device_node *np,\n\t\t\t\t    struct lpddr3_timings *tim)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"max-freq\", &tim->max_freq);\n\tif (ret)\n\t\t \n\t\tret = of_property_read_u32(np, \"reg\", &tim->max_freq);\n\tret |= of_property_read_u32(np, \"min-freq\", &tim->min_freq);\n\tret |= of_property_read_u32(np, \"tRFC\", &tim->tRFC);\n\tret |= of_property_read_u32(np, \"tRRD\", &tim->tRRD);\n\tret |= of_property_read_u32(np, \"tRPab\", &tim->tRPab);\n\tret |= of_property_read_u32(np, \"tRPpb\", &tim->tRPpb);\n\tret |= of_property_read_u32(np, \"tRCD\", &tim->tRCD);\n\tret |= of_property_read_u32(np, \"tRC\", &tim->tRC);\n\tret |= of_property_read_u32(np, \"tRAS\", &tim->tRAS);\n\tret |= of_property_read_u32(np, \"tWTR\", &tim->tWTR);\n\tret |= of_property_read_u32(np, \"tWR\", &tim->tWR);\n\tret |= of_property_read_u32(np, \"tRTP\", &tim->tRTP);\n\tret |= of_property_read_u32(np, \"tW2W-C2C\", &tim->tW2W_C2C);\n\tret |= of_property_read_u32(np, \"tR2R-C2C\", &tim->tR2R_C2C);\n\tret |= of_property_read_u32(np, \"tFAW\", &tim->tFAW);\n\tret |= of_property_read_u32(np, \"tXSR\", &tim->tXSR);\n\tret |= of_property_read_u32(np, \"tXP\", &tim->tXP);\n\tret |= of_property_read_u32(np, \"tCKE\", &tim->tCKE);\n\tret |= of_property_read_u32(np, \"tCKESR\", &tim->tCKESR);\n\tret |= of_property_read_u32(np, \"tMRD\", &tim->tMRD);\n\n\treturn ret;\n}\n\n \nconst struct lpddr3_timings\n*of_lpddr3_get_ddr_timings(struct device_node *np_ddr, struct device *dev,\n\t\t\t   u32 device_type, u32 *nr_frequencies)\n{\n\tstruct lpddr3_timings\t*timings = NULL;\n\tu32\t\t\tarr_sz = 0, i = 0;\n\tstruct device_node\t*np_tim;\n\tchar\t\t\t*tim_compat = NULL;\n\n\tswitch (device_type) {\n\tcase DDR_TYPE_LPDDR3:\n\t\ttim_compat = \"jedec,lpddr3-timings\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unsupported memory type\\n\");\n\t}\n\n\tfor_each_child_of_node(np_ddr, np_tim)\n\t\tif (of_device_is_compatible(np_tim, tim_compat))\n\t\t\tarr_sz++;\n\n\tif (arr_sz)\n\t\ttimings = devm_kcalloc(dev, arr_sz, sizeof(*timings),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!timings)\n\t\tgoto default_timings;\n\n\tfor_each_child_of_node(np_ddr, np_tim) {\n\t\tif (of_device_is_compatible(np_tim, tim_compat)) {\n\t\t\tif (of_lpddr3_do_get_timings(np_tim, &timings[i])) {\n\t\t\t\tdevm_kfree(dev, timings);\n\t\t\t\tof_node_put(np_tim);\n\t\t\t\tgoto default_timings;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\t*nr_frequencies = arr_sz;\n\n\treturn timings;\n\ndefault_timings:\n\tdev_warn(dev, \"Failed to get timings\\n\");\n\t*nr_frequencies = 0;\n\treturn NULL;\n}\nEXPORT_SYMBOL(of_lpddr3_get_ddr_timings);\n\n \nconst struct lpddr2_info\n*of_lpddr2_get_info(struct device_node *np, struct device *dev)\n{\n\tstruct lpddr2_info *ret_info, info = {};\n\tstruct property *prop;\n\tconst char *cp;\n\tint err;\n\tu32 revision_id[2];\n\n\terr = of_property_read_u32_array(np, \"revision-id\", revision_id, 2);\n\tif (!err) {\n\t\tinfo.revision_id1 = revision_id[0];\n\t\tinfo.revision_id2 = revision_id[1];\n\t} else {\n\t\terr = of_property_read_u32(np, \"revision-id1\", &info.revision_id1);\n\t\tif (err)\n\t\t\tinfo.revision_id1 = -ENOENT;\n\n\t\terr = of_property_read_u32(np, \"revision-id2\", &info.revision_id2);\n\t\tif (err)\n\t\t\tinfo.revision_id2 = -ENOENT;\n\t}\n\n\terr = of_property_read_u32(np, \"io-width\", &info.io_width);\n\tif (err)\n\t\treturn NULL;\n\n\tinfo.io_width = 32 / info.io_width - 1;\n\n\terr = of_property_read_u32(np, \"density\", &info.density);\n\tif (err)\n\t\treturn NULL;\n\n\tinfo.density = ffs(info.density) - 7;\n\n\tif (of_device_is_compatible(np, \"jedec,lpddr2-s4\"))\n\t\tinfo.arch_type = LPDDR2_TYPE_S4;\n\telse if (of_device_is_compatible(np, \"jedec,lpddr2-s2\"))\n\t\tinfo.arch_type = LPDDR2_TYPE_S2;\n\telse if (of_device_is_compatible(np, \"jedec,lpddr2-nvm\"))\n\t\tinfo.arch_type = LPDDR2_TYPE_NVM;\n\telse\n\t\treturn NULL;\n\n\tprop = of_find_property(np, \"compatible\", NULL);\n\tfor (cp = of_prop_next_string(prop, NULL); cp;\n\t     cp = of_prop_next_string(prop, cp)) {\n\n#define OF_LPDDR2_VENDOR_CMP(compat, ID) \\\n\t\tif (!of_compat_cmp(cp, compat \",\", strlen(compat \",\"))) { \\\n\t\t\tinfo.manufacturer_id = LPDDR2_MANID_##ID; \\\n\t\t\tbreak; \\\n\t\t}\n\n\t\tOF_LPDDR2_VENDOR_CMP(\"samsung\", SAMSUNG)\n\t\tOF_LPDDR2_VENDOR_CMP(\"qimonda\", QIMONDA)\n\t\tOF_LPDDR2_VENDOR_CMP(\"elpida\", ELPIDA)\n\t\tOF_LPDDR2_VENDOR_CMP(\"etron\", ETRON)\n\t\tOF_LPDDR2_VENDOR_CMP(\"nanya\", NANYA)\n\t\tOF_LPDDR2_VENDOR_CMP(\"hynix\", HYNIX)\n\t\tOF_LPDDR2_VENDOR_CMP(\"mosel\", MOSEL)\n\t\tOF_LPDDR2_VENDOR_CMP(\"winbond\", WINBOND)\n\t\tOF_LPDDR2_VENDOR_CMP(\"esmt\", ESMT)\n\t\tOF_LPDDR2_VENDOR_CMP(\"spansion\", SPANSION)\n\t\tOF_LPDDR2_VENDOR_CMP(\"sst\", SST)\n\t\tOF_LPDDR2_VENDOR_CMP(\"zmos\", ZMOS)\n\t\tOF_LPDDR2_VENDOR_CMP(\"intel\", INTEL)\n\t\tOF_LPDDR2_VENDOR_CMP(\"numonyx\", NUMONYX)\n\t\tOF_LPDDR2_VENDOR_CMP(\"micron\", MICRON)\n\n#undef OF_LPDDR2_VENDOR_CMP\n\t}\n\n\tif (!info.manufacturer_id)\n\t\tinfo.manufacturer_id = -ENOENT;\n\n\tret_info = devm_kzalloc(dev, sizeof(*ret_info), GFP_KERNEL);\n\tif (ret_info)\n\t\t*ret_info = info;\n\n\treturn ret_info;\n}\nEXPORT_SYMBOL(of_lpddr2_get_info);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}