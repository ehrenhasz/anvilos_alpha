{
  "module_name": "stm32-fmc2-ebi.c",
  "hash_id": "2264d60b8af442bf2121c882eaee51752f4c78f325b8416d4ff20dc411c89898",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/stm32-fmc2-ebi.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define FMC2_BCR1\t\t\t0x0\n#define FMC2_BTR1\t\t\t0x4\n#define FMC2_BCR(x)\t\t\t((x) * 0x8 + FMC2_BCR1)\n#define FMC2_BTR(x)\t\t\t((x) * 0x8 + FMC2_BTR1)\n#define FMC2_PCSCNTR\t\t\t0x20\n#define FMC2_BWTR1\t\t\t0x104\n#define FMC2_BWTR(x)\t\t\t((x) * 0x8 + FMC2_BWTR1)\n\n \n#define FMC2_BCR1_CCLKEN\t\tBIT(20)\n#define FMC2_BCR1_FMC2EN\t\tBIT(31)\n\n \n#define FMC2_BCR_MBKEN\t\t\tBIT(0)\n#define FMC2_BCR_MUXEN\t\t\tBIT(1)\n#define FMC2_BCR_MTYP\t\t\tGENMASK(3, 2)\n#define FMC2_BCR_MWID\t\t\tGENMASK(5, 4)\n#define FMC2_BCR_FACCEN\t\t\tBIT(6)\n#define FMC2_BCR_BURSTEN\t\tBIT(8)\n#define FMC2_BCR_WAITPOL\t\tBIT(9)\n#define FMC2_BCR_WAITCFG\t\tBIT(11)\n#define FMC2_BCR_WREN\t\t\tBIT(12)\n#define FMC2_BCR_WAITEN\t\t\tBIT(13)\n#define FMC2_BCR_EXTMOD\t\t\tBIT(14)\n#define FMC2_BCR_ASYNCWAIT\t\tBIT(15)\n#define FMC2_BCR_CPSIZE\t\t\tGENMASK(18, 16)\n#define FMC2_BCR_CBURSTRW\t\tBIT(19)\n#define FMC2_BCR_NBLSET\t\t\tGENMASK(23, 22)\n\n \n#define FMC2_BXTR_ADDSET\t\tGENMASK(3, 0)\n#define FMC2_BXTR_ADDHLD\t\tGENMASK(7, 4)\n#define FMC2_BXTR_DATAST\t\tGENMASK(15, 8)\n#define FMC2_BXTR_BUSTURN\t\tGENMASK(19, 16)\n#define FMC2_BTR_CLKDIV\t\t\tGENMASK(23, 20)\n#define FMC2_BTR_DATLAT\t\t\tGENMASK(27, 24)\n#define FMC2_BXTR_ACCMOD\t\tGENMASK(29, 28)\n#define FMC2_BXTR_DATAHLD\t\tGENMASK(31, 30)\n\n \n#define FMC2_PCSCNTR_CSCOUNT\t\tGENMASK(15, 0)\n#define FMC2_PCSCNTR_CNTBEN(x)\t\tBIT((x) + 16)\n\n#define FMC2_MAX_EBI_CE\t\t\t4\n#define FMC2_MAX_BANKS\t\t\t5\n\n#define FMC2_BCR_CPSIZE_0\t\t0x0\n#define FMC2_BCR_CPSIZE_128\t\t0x1\n#define FMC2_BCR_CPSIZE_256\t\t0x2\n#define FMC2_BCR_CPSIZE_512\t\t0x3\n#define FMC2_BCR_CPSIZE_1024\t\t0x4\n\n#define FMC2_BCR_MWID_8\t\t\t0x0\n#define FMC2_BCR_MWID_16\t\t0x1\n\n#define FMC2_BCR_MTYP_SRAM\t\t0x0\n#define FMC2_BCR_MTYP_PSRAM\t\t0x1\n#define FMC2_BCR_MTYP_NOR\t\t0x2\n\n#define FMC2_BXTR_EXTMOD_A\t\t0x0\n#define FMC2_BXTR_EXTMOD_B\t\t0x1\n#define FMC2_BXTR_EXTMOD_C\t\t0x2\n#define FMC2_BXTR_EXTMOD_D\t\t0x3\n\n#define FMC2_BCR_NBLSET_MAX\t\t0x3\n#define FMC2_BXTR_ADDSET_MAX\t\t0xf\n#define FMC2_BXTR_ADDHLD_MAX\t\t0xf\n#define FMC2_BXTR_DATAST_MAX\t\t0xff\n#define FMC2_BXTR_BUSTURN_MAX\t\t0xf\n#define FMC2_BXTR_DATAHLD_MAX\t\t0x3\n#define FMC2_BTR_CLKDIV_MAX\t\t0xf\n#define FMC2_BTR_DATLAT_MAX\t\t0xf\n#define FMC2_PCSCNTR_CSCOUNT_MAX\t0xff\n\nenum stm32_fmc2_ebi_bank {\n\tFMC2_EBI1 = 0,\n\tFMC2_EBI2,\n\tFMC2_EBI3,\n\tFMC2_EBI4,\n\tFMC2_NAND\n};\n\nenum stm32_fmc2_ebi_register_type {\n\tFMC2_REG_BCR = 1,\n\tFMC2_REG_BTR,\n\tFMC2_REG_BWTR,\n\tFMC2_REG_PCSCNTR\n};\n\nenum stm32_fmc2_ebi_transaction_type {\n\tFMC2_ASYNC_MODE_1_SRAM = 0,\n\tFMC2_ASYNC_MODE_1_PSRAM,\n\tFMC2_ASYNC_MODE_A_SRAM,\n\tFMC2_ASYNC_MODE_A_PSRAM,\n\tFMC2_ASYNC_MODE_2_NOR,\n\tFMC2_ASYNC_MODE_B_NOR,\n\tFMC2_ASYNC_MODE_C_NOR,\n\tFMC2_ASYNC_MODE_D_NOR,\n\tFMC2_SYNC_READ_SYNC_WRITE_PSRAM,\n\tFMC2_SYNC_READ_ASYNC_WRITE_PSRAM,\n\tFMC2_SYNC_READ_SYNC_WRITE_NOR,\n\tFMC2_SYNC_READ_ASYNC_WRITE_NOR\n};\n\nenum stm32_fmc2_ebi_buswidth {\n\tFMC2_BUSWIDTH_8 = 8,\n\tFMC2_BUSWIDTH_16 = 16\n};\n\nenum stm32_fmc2_ebi_cpsize {\n\tFMC2_CPSIZE_0 = 0,\n\tFMC2_CPSIZE_128 = 128,\n\tFMC2_CPSIZE_256 = 256,\n\tFMC2_CPSIZE_512 = 512,\n\tFMC2_CPSIZE_1024 = 1024\n};\n\nstruct stm32_fmc2_ebi {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tu8 bank_assigned;\n\n\tu32 bcr[FMC2_MAX_EBI_CE];\n\tu32 btr[FMC2_MAX_EBI_CE];\n\tu32 bwtr[FMC2_MAX_EBI_CE];\n\tu32 pcscntr;\n};\n\n \nstruct stm32_fmc2_prop {\n\tconst char *name;\n\tbool bprop;\n\tbool mprop;\n\tint reg_type;\n\tu32 reg_mask;\n\tu32 reset_val;\n\tint (*check)(struct stm32_fmc2_ebi *ebi,\n\t\t     const struct stm32_fmc2_prop *prop, int cs);\n\tu32 (*calculate)(struct stm32_fmc2_ebi *ebi, int cs, u32 setup);\n\tint (*set)(struct stm32_fmc2_ebi *ebi,\n\t\t   const struct stm32_fmc2_prop *prop,\n\t\t   int cs, u32 setup);\n};\n\nstatic int stm32_fmc2_ebi_check_mux(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t    const struct stm32_fmc2_prop *prop,\n\t\t\t\t    int cs)\n{\n\tu32 bcr;\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\n\tif (bcr & FMC2_BCR_MTYP)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_waitcfg(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\tconst struct stm32_fmc2_prop *prop,\n\t\t\t\t\tint cs)\n{\n\tu32 bcr, val = FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\n\tif ((bcr & FMC2_BCR_MTYP) == val && bcr & FMC2_BCR_BURSTEN)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_sync_trans(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t   const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t   int cs)\n{\n\tu32 bcr;\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\n\tif (bcr & FMC2_BCR_BURSTEN)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_async_trans(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t    const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t    int cs)\n{\n\tu32 bcr;\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\n\tif (!(bcr & FMC2_BCR_BURSTEN) || !(bcr & FMC2_BCR_CBURSTRW))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_cpsize(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t       const struct stm32_fmc2_prop *prop,\n\t\t\t\t       int cs)\n{\n\tu32 bcr, val = FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_PSRAM);\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\n\tif ((bcr & FMC2_BCR_MTYP) == val && bcr & FMC2_BCR_BURSTEN)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_address_hold(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t     const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t     int cs)\n{\n\tu32 bcr, bxtr, val = FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_D);\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\tif (prop->reg_type == FMC2_REG_BWTR)\n\t\tregmap_read(ebi->regmap, FMC2_BWTR(cs), &bxtr);\n\telse\n\t\tregmap_read(ebi->regmap, FMC2_BTR(cs), &bxtr);\n\n\tif ((!(bcr & FMC2_BCR_BURSTEN) || !(bcr & FMC2_BCR_CBURSTRW)) &&\n\t    ((bxtr & FMC2_BXTR_ACCMOD) == val || bcr & FMC2_BCR_MUXEN))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_clk_period(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t   const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t   int cs)\n{\n\tu32 bcr, bcr1;\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\tif (cs)\n\t\tregmap_read(ebi->regmap, FMC2_BCR1, &bcr1);\n\telse\n\t\tbcr1 = bcr;\n\n\tif (bcr & FMC2_BCR_BURSTEN && (!cs || !(bcr1 & FMC2_BCR1_CCLKEN)))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_fmc2_ebi_check_cclk(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t     const struct stm32_fmc2_prop *prop,\n\t\t\t\t     int cs)\n{\n\tif (cs)\n\t\treturn -EINVAL;\n\n\treturn stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);\n}\n\nstatic u32 stm32_fmc2_ebi_ns_to_clock_cycles(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t     int cs, u32 setup)\n{\n\tunsigned long hclk = clk_get_rate(ebi->clk);\n\tunsigned long hclkp = NSEC_PER_SEC / (hclk / 1000);\n\n\treturn DIV_ROUND_UP(setup * 1000, hclkp);\n}\n\nstatic u32 stm32_fmc2_ebi_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t   int cs, u32 setup)\n{\n\tu32 nb_clk_cycles = stm32_fmc2_ebi_ns_to_clock_cycles(ebi, cs, setup);\n\tu32 bcr, btr, clk_period;\n\n\tregmap_read(ebi->regmap, FMC2_BCR1, &bcr);\n\tif (bcr & FMC2_BCR1_CCLKEN || !cs)\n\t\tregmap_read(ebi->regmap, FMC2_BTR1, &btr);\n\telse\n\t\tregmap_read(ebi->regmap, FMC2_BTR(cs), &btr);\n\n\tclk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;\n\n\treturn DIV_ROUND_UP(nb_clk_cycles, clk_period);\n}\n\nstatic int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)\n{\n\tswitch (reg_type) {\n\tcase FMC2_REG_BCR:\n\t\t*reg = FMC2_BCR(cs);\n\t\tbreak;\n\tcase FMC2_REG_BTR:\n\t\t*reg = FMC2_BTR(cs);\n\t\tbreak;\n\tcase FMC2_REG_BWTR:\n\t\t*reg = FMC2_BWTR(cs);\n\t\tbreak;\n\tcase FMC2_REG_PCSCNTR:\n\t\t*reg = FMC2_PCSCNTR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_bit_field(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\tconst struct stm32_fmc2_prop *prop,\n\t\t\t\t\tint cs, u32 setup)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = stm32_fmc2_ebi_get_reg(prop->reg_type, cs, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(ebi->regmap, reg, prop->reg_mask,\n\t\t\t   setup ? prop->reg_mask : 0);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_trans_type(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t int cs, u32 setup)\n{\n\tu32 bcr_mask, bcr = FMC2_BCR_WREN;\n\tu32 btr_mask, btr = 0;\n\tu32 bwtr_mask, bwtr = 0;\n\n\tbwtr_mask = FMC2_BXTR_ACCMOD;\n\tbtr_mask = FMC2_BXTR_ACCMOD;\n\tbcr_mask = FMC2_BCR_MUXEN | FMC2_BCR_MTYP | FMC2_BCR_FACCEN |\n\t\t   FMC2_BCR_WREN | FMC2_BCR_WAITEN | FMC2_BCR_BURSTEN |\n\t\t   FMC2_BCR_EXTMOD | FMC2_BCR_CBURSTRW;\n\n\tswitch (setup) {\n\tcase FMC2_ASYNC_MODE_1_SRAM:\n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_SRAM);\n\t\t \n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_1_PSRAM:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_PSRAM);\n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_A_SRAM:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_SRAM);\n\t\tbcr |= FMC2_BCR_EXTMOD;\n\t\tbtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_A);\n\t\tbwtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_A);\n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_A_PSRAM:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_PSRAM);\n\t\tbcr |= FMC2_BCR_EXTMOD;\n\t\tbtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_A);\n\t\tbwtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_A);\n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_2_NOR:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\t\tbcr |= FMC2_BCR_FACCEN;\n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_B_NOR:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\t\tbcr |= FMC2_BCR_FACCEN | FMC2_BCR_EXTMOD;\n\t\tbtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_B);\n\t\tbwtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_B);\n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_C_NOR:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\t\tbcr |= FMC2_BCR_FACCEN | FMC2_BCR_EXTMOD;\n\t\tbtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_C);\n\t\tbwtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_C);\n\t\tbreak;\n\tcase FMC2_ASYNC_MODE_D_NOR:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\t\tbcr |= FMC2_BCR_FACCEN | FMC2_BCR_EXTMOD;\n\t\tbtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_D);\n\t\tbwtr |= FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_D);\n\t\tbreak;\n\tcase FMC2_SYNC_READ_SYNC_WRITE_PSRAM:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_PSRAM);\n\t\tbcr |= FMC2_BCR_BURSTEN | FMC2_BCR_CBURSTRW;\n\t\tbreak;\n\tcase FMC2_SYNC_READ_ASYNC_WRITE_PSRAM:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_PSRAM);\n\t\tbcr |= FMC2_BCR_BURSTEN;\n\t\tbreak;\n\tcase FMC2_SYNC_READ_SYNC_WRITE_NOR:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\t\tbcr |= FMC2_BCR_FACCEN | FMC2_BCR_BURSTEN | FMC2_BCR_CBURSTRW;\n\t\tbreak;\n\tcase FMC2_SYNC_READ_ASYNC_WRITE_NOR:\n\t\t \n\t\tbcr |= FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);\n\t\tbcr |= FMC2_BCR_FACCEN | FMC2_BCR_BURSTEN;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (bcr & FMC2_BCR_EXTMOD)\n\t\tregmap_update_bits(ebi->regmap, FMC2_BWTR(cs),\n\t\t\t\t   bwtr_mask, bwtr);\n\tregmap_update_bits(ebi->regmap, FMC2_BTR(cs), btr_mask, btr);\n\tregmap_update_bits(ebi->regmap, FMC2_BCR(cs), bcr_mask, bcr);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_buswidth(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t       const struct stm32_fmc2_prop *prop,\n\t\t\t\t       int cs, u32 setup)\n{\n\tu32 val;\n\n\tswitch (setup) {\n\tcase FMC2_BUSWIDTH_8:\n\t\tval = FIELD_PREP(FMC2_BCR_MWID, FMC2_BCR_MWID_8);\n\t\tbreak;\n\tcase FMC2_BUSWIDTH_16:\n\t\tval = FIELD_PREP(FMC2_BCR_MWID, FMC2_BCR_MWID_16);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(ebi->regmap, FMC2_BCR(cs), FMC2_BCR_MWID, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_cpsize(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t     const struct stm32_fmc2_prop *prop,\n\t\t\t\t     int cs, u32 setup)\n{\n\tu32 val;\n\n\tswitch (setup) {\n\tcase FMC2_CPSIZE_0:\n\t\tval = FIELD_PREP(FMC2_BCR_CPSIZE, FMC2_BCR_CPSIZE_0);\n\t\tbreak;\n\tcase FMC2_CPSIZE_128:\n\t\tval = FIELD_PREP(FMC2_BCR_CPSIZE, FMC2_BCR_CPSIZE_128);\n\t\tbreak;\n\tcase FMC2_CPSIZE_256:\n\t\tval = FIELD_PREP(FMC2_BCR_CPSIZE, FMC2_BCR_CPSIZE_256);\n\t\tbreak;\n\tcase FMC2_CPSIZE_512:\n\t\tval = FIELD_PREP(FMC2_BCR_CPSIZE, FMC2_BCR_CPSIZE_512);\n\t\tbreak;\n\tcase FMC2_CPSIZE_1024:\n\t\tval = FIELD_PREP(FMC2_BCR_CPSIZE, FMC2_BCR_CPSIZE_1024);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(ebi->regmap, FMC2_BCR(cs), FMC2_BCR_CPSIZE, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_bl_setup(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t       const struct stm32_fmc2_prop *prop,\n\t\t\t\t       int cs, u32 setup)\n{\n\tu32 val;\n\n\tval = min_t(u32, setup, FMC2_BCR_NBLSET_MAX);\n\tval = FIELD_PREP(FMC2_BCR_NBLSET, val);\n\tregmap_update_bits(ebi->regmap, FMC2_BCR(cs), FMC2_BCR_NBLSET, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_address_setup(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t    const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t    int cs, u32 setup)\n{\n\tu32 bcr, bxtr, reg;\n\tu32 val = FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_D);\n\tint ret;\n\n\tret = stm32_fmc2_ebi_get_reg(prop->reg_type, cs, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\tif (prop->reg_type == FMC2_REG_BWTR)\n\t\tregmap_read(ebi->regmap, FMC2_BWTR(cs), &bxtr);\n\telse\n\t\tregmap_read(ebi->regmap, FMC2_BTR(cs), &bxtr);\n\n\tif ((bxtr & FMC2_BXTR_ACCMOD) == val || bcr & FMC2_BCR_MUXEN)\n\t\tval = clamp_val(setup, 1, FMC2_BXTR_ADDSET_MAX);\n\telse\n\t\tval = min_t(u32, setup, FMC2_BXTR_ADDSET_MAX);\n\tval = FIELD_PREP(FMC2_BXTR_ADDSET, val);\n\tregmap_update_bits(ebi->regmap, reg, FMC2_BXTR_ADDSET, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_address_hold(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t   const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t   int cs, u32 setup)\n{\n\tu32 val, reg;\n\tint ret;\n\n\tret = stm32_fmc2_ebi_get_reg(prop->reg_type, cs, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(setup, 1, FMC2_BXTR_ADDHLD_MAX);\n\tval = FIELD_PREP(FMC2_BXTR_ADDHLD, val);\n\tregmap_update_bits(ebi->regmap, reg, FMC2_BXTR_ADDHLD, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_data_setup(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t int cs, u32 setup)\n{\n\tu32 val, reg;\n\tint ret;\n\n\tret = stm32_fmc2_ebi_get_reg(prop->reg_type, cs, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval = clamp_val(setup, 1, FMC2_BXTR_DATAST_MAX);\n\tval = FIELD_PREP(FMC2_BXTR_DATAST, val);\n\tregmap_update_bits(ebi->regmap, reg, FMC2_BXTR_DATAST, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_bus_turnaround(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t     const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t     int cs, u32 setup)\n{\n\tu32 val, reg;\n\tint ret;\n\n\tret = stm32_fmc2_ebi_get_reg(prop->reg_type, cs, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tval = setup ? min_t(u32, setup - 1, FMC2_BXTR_BUSTURN_MAX) : 0;\n\tval = FIELD_PREP(FMC2_BXTR_BUSTURN, val);\n\tregmap_update_bits(ebi->regmap, reg, FMC2_BXTR_BUSTURN, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_data_hold(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\tconst struct stm32_fmc2_prop *prop,\n\t\t\t\t\tint cs, u32 setup)\n{\n\tu32 val, reg;\n\tint ret;\n\n\tret = stm32_fmc2_ebi_get_reg(prop->reg_type, cs, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (prop->reg_type == FMC2_REG_BWTR)\n\t\tval = setup ? min_t(u32, setup - 1, FMC2_BXTR_DATAHLD_MAX) : 0;\n\telse\n\t\tval = min_t(u32, setup, FMC2_BXTR_DATAHLD_MAX);\n\tval = FIELD_PREP(FMC2_BXTR_DATAHLD, val);\n\tregmap_update_bits(ebi->regmap, reg, FMC2_BXTR_DATAHLD, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_clk_period(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t int cs, u32 setup)\n{\n\tu32 val;\n\n\tval = setup ? clamp_val(setup - 1, 1, FMC2_BTR_CLKDIV_MAX) : 1;\n\tval = FIELD_PREP(FMC2_BTR_CLKDIV, val);\n\tregmap_update_bits(ebi->regmap, FMC2_BTR(cs), FMC2_BTR_CLKDIV, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_data_latency(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t   const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t   int cs, u32 setup)\n{\n\tu32 val;\n\n\tval = setup > 1 ? min_t(u32, setup - 2, FMC2_BTR_DATLAT_MAX) : 0;\n\tval = FIELD_PREP(FMC2_BTR_DATLAT, val);\n\tregmap_update_bits(ebi->regmap, FMC2_BTR(cs), FMC2_BTR_DATLAT, val);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t\t    const struct stm32_fmc2_prop *prop,\n\t\t\t\t\t    int cs, u32 setup)\n{\n\tu32 old_val, new_val, pcscntr;\n\n\tif (setup < 1)\n\t\treturn 0;\n\n\tregmap_read(ebi->regmap, FMC2_PCSCNTR, &pcscntr);\n\n\t \n\tregmap_update_bits(ebi->regmap, FMC2_PCSCNTR,\n\t\t\t   FMC2_PCSCNTR_CNTBEN(cs),\n\t\t\t   FMC2_PCSCNTR_CNTBEN(cs));\n\n\tnew_val = min_t(u32, setup - 1, FMC2_PCSCNTR_CSCOUNT_MAX);\n\told_val = FIELD_GET(FMC2_PCSCNTR_CSCOUNT, pcscntr);\n\tif (old_val && new_val > old_val)\n\t\t \n\t\treturn 0;\n\n\tnew_val = FIELD_PREP(FMC2_PCSCNTR_CSCOUNT, new_val);\n\tregmap_update_bits(ebi->regmap, FMC2_PCSCNTR,\n\t\t\t   FMC2_PCSCNTR_CSCOUNT, new_val);\n\n\treturn 0;\n}\n\nstatic const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {\n\t \n\t{\n\t\t.name = \"st,fmc2-ebi-cs-transaction-type\",\n\t\t.mprop = true,\n\t\t.set = stm32_fmc2_ebi_set_trans_type,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-cclk-enable\",\n\t\t.bprop = true,\n\t\t.reg_type = FMC2_REG_BCR,\n\t\t.reg_mask = FMC2_BCR1_CCLKEN,\n\t\t.check = stm32_fmc2_ebi_check_cclk,\n\t\t.set = stm32_fmc2_ebi_set_bit_field,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-mux-enable\",\n\t\t.bprop = true,\n\t\t.reg_type = FMC2_REG_BCR,\n\t\t.reg_mask = FMC2_BCR_MUXEN,\n\t\t.check = stm32_fmc2_ebi_check_mux,\n\t\t.set = stm32_fmc2_ebi_set_bit_field,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-buswidth\",\n\t\t.reset_val = FMC2_BUSWIDTH_16,\n\t\t.set = stm32_fmc2_ebi_set_buswidth,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-waitpol-high\",\n\t\t.bprop = true,\n\t\t.reg_type = FMC2_REG_BCR,\n\t\t.reg_mask = FMC2_BCR_WAITPOL,\n\t\t.set = stm32_fmc2_ebi_set_bit_field,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-waitcfg-enable\",\n\t\t.bprop = true,\n\t\t.reg_type = FMC2_REG_BCR,\n\t\t.reg_mask = FMC2_BCR_WAITCFG,\n\t\t.check = stm32_fmc2_ebi_check_waitcfg,\n\t\t.set = stm32_fmc2_ebi_set_bit_field,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-wait-enable\",\n\t\t.bprop = true,\n\t\t.reg_type = FMC2_REG_BCR,\n\t\t.reg_mask = FMC2_BCR_WAITEN,\n\t\t.check = stm32_fmc2_ebi_check_sync_trans,\n\t\t.set = stm32_fmc2_ebi_set_bit_field,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-asyncwait-enable\",\n\t\t.bprop = true,\n\t\t.reg_type = FMC2_REG_BCR,\n\t\t.reg_mask = FMC2_BCR_ASYNCWAIT,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.set = stm32_fmc2_ebi_set_bit_field,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-cpsize\",\n\t\t.check = stm32_fmc2_ebi_check_cpsize,\n\t\t.set = stm32_fmc2_ebi_set_cpsize,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-byte-lane-setup-ns\",\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_bl_setup,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-address-setup-ns\",\n\t\t.reg_type = FMC2_REG_BTR,\n\t\t.reset_val = FMC2_BXTR_ADDSET_MAX,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_address_setup,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-address-hold-ns\",\n\t\t.reg_type = FMC2_REG_BTR,\n\t\t.reset_val = FMC2_BXTR_ADDHLD_MAX,\n\t\t.check = stm32_fmc2_ebi_check_address_hold,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_address_hold,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-data-setup-ns\",\n\t\t.reg_type = FMC2_REG_BTR,\n\t\t.reset_val = FMC2_BXTR_DATAST_MAX,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_data_setup,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-bus-turnaround-ns\",\n\t\t.reg_type = FMC2_REG_BTR,\n\t\t.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_bus_turnaround,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-data-hold-ns\",\n\t\t.reg_type = FMC2_REG_BTR,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_data_hold,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-clk-period-ns\",\n\t\t.reset_val = FMC2_BTR_CLKDIV_MAX + 1,\n\t\t.check = stm32_fmc2_ebi_check_clk_period,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_clk_period,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-data-latency-ns\",\n\t\t.check = stm32_fmc2_ebi_check_sync_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clk_period,\n\t\t.set = stm32_fmc2_ebi_set_data_latency,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-write-address-setup-ns\",\n\t\t.reg_type = FMC2_REG_BWTR,\n\t\t.reset_val = FMC2_BXTR_ADDSET_MAX,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_address_setup,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-write-address-hold-ns\",\n\t\t.reg_type = FMC2_REG_BWTR,\n\t\t.reset_val = FMC2_BXTR_ADDHLD_MAX,\n\t\t.check = stm32_fmc2_ebi_check_address_hold,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_address_hold,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-write-data-setup-ns\",\n\t\t.reg_type = FMC2_REG_BWTR,\n\t\t.reset_val = FMC2_BXTR_DATAST_MAX,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_data_setup,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-write-bus-turnaround-ns\",\n\t\t.reg_type = FMC2_REG_BWTR,\n\t\t.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_bus_turnaround,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-write-data-hold-ns\",\n\t\t.reg_type = FMC2_REG_BWTR,\n\t\t.check = stm32_fmc2_ebi_check_async_trans,\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_data_hold,\n\t},\n\t{\n\t\t.name = \"st,fmc2-ebi-cs-max-low-pulse-ns\",\n\t\t.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,\n\t\t.set = stm32_fmc2_ebi_set_max_low_pulse,\n\t},\n};\n\nstatic int stm32_fmc2_ebi_parse_prop(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t     struct device_node *dev_node,\n\t\t\t\t     const struct stm32_fmc2_prop *prop,\n\t\t\t\t     int cs)\n{\n\tstruct device *dev = ebi->dev;\n\tu32 setup = 0;\n\n\tif (!prop->set) {\n\t\tdev_err(dev, \"property %s is not well defined\\n\", prop->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (prop->check && prop->check(ebi, prop, cs))\n\t\t \n\t\treturn 0;\n\n\tif (prop->bprop) {\n\t\tbool bprop;\n\n\t\tbprop = of_property_read_bool(dev_node, prop->name);\n\t\tif (prop->mprop && !bprop) {\n\t\t\tdev_err(dev, \"mandatory property %s not defined in the device tree\\n\",\n\t\t\t\tprop->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bprop)\n\t\t\tsetup = 1;\n\t} else {\n\t\tu32 val;\n\t\tint ret;\n\n\t\tret = of_property_read_u32(dev_node, prop->name, &val);\n\t\tif (prop->mprop && ret) {\n\t\t\tdev_err(dev, \"mandatory property %s not defined in the device tree\\n\",\n\t\t\t\tprop->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret)\n\t\t\tsetup = prop->reset_val;\n\t\telse if (prop->calculate)\n\t\t\tsetup = prop->calculate(ebi, cs, val);\n\t\telse\n\t\t\tsetup = val;\n\t}\n\n\treturn prop->set(ebi, prop, cs, setup);\n}\n\nstatic void stm32_fmc2_ebi_enable_bank(struct stm32_fmc2_ebi *ebi, int cs)\n{\n\tregmap_update_bits(ebi->regmap, FMC2_BCR(cs),\n\t\t\t   FMC2_BCR_MBKEN, FMC2_BCR_MBKEN);\n}\n\nstatic void stm32_fmc2_ebi_disable_bank(struct stm32_fmc2_ebi *ebi, int cs)\n{\n\tregmap_update_bits(ebi->regmap, FMC2_BCR(cs), FMC2_BCR_MBKEN, 0);\n}\n\nstatic void stm32_fmc2_ebi_save_setup(struct stm32_fmc2_ebi *ebi)\n{\n\tunsigned int cs;\n\n\tfor (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {\n\t\tregmap_read(ebi->regmap, FMC2_BCR(cs), &ebi->bcr[cs]);\n\t\tregmap_read(ebi->regmap, FMC2_BTR(cs), &ebi->btr[cs]);\n\t\tregmap_read(ebi->regmap, FMC2_BWTR(cs), &ebi->bwtr[cs]);\n\t}\n\n\tregmap_read(ebi->regmap, FMC2_PCSCNTR, &ebi->pcscntr);\n}\n\nstatic void stm32_fmc2_ebi_set_setup(struct stm32_fmc2_ebi *ebi)\n{\n\tunsigned int cs;\n\n\tfor (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {\n\t\tregmap_write(ebi->regmap, FMC2_BCR(cs), ebi->bcr[cs]);\n\t\tregmap_write(ebi->regmap, FMC2_BTR(cs), ebi->btr[cs]);\n\t\tregmap_write(ebi->regmap, FMC2_BWTR(cs), ebi->bwtr[cs]);\n\t}\n\n\tregmap_write(ebi->regmap, FMC2_PCSCNTR, ebi->pcscntr);\n}\n\nstatic void stm32_fmc2_ebi_disable_banks(struct stm32_fmc2_ebi *ebi)\n{\n\tunsigned int cs;\n\n\tfor (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {\n\t\tif (!(ebi->bank_assigned & BIT(cs)))\n\t\t\tcontinue;\n\n\t\tstm32_fmc2_ebi_disable_bank(ebi, cs);\n\t}\n}\n\n \nstatic bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)\n{\n\tunsigned int cs;\n\tu32 bcr;\n\n\tfor (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {\n\t\tif (!(ebi->bank_assigned & BIT(cs)))\n\t\t\tcontinue;\n\n\t\tregmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);\n\t\tif ((bcr & FMC2_BCR_WAITEN || bcr & FMC2_BCR_ASYNCWAIT) &&\n\t\t    ebi->bank_assigned & BIT(FMC2_NAND))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void stm32_fmc2_ebi_enable(struct stm32_fmc2_ebi *ebi)\n{\n\tregmap_update_bits(ebi->regmap, FMC2_BCR1,\n\t\t\t   FMC2_BCR1_FMC2EN, FMC2_BCR1_FMC2EN);\n}\n\nstatic void stm32_fmc2_ebi_disable(struct stm32_fmc2_ebi *ebi)\n{\n\tregmap_update_bits(ebi->regmap, FMC2_BCR1, FMC2_BCR1_FMC2EN, 0);\n}\n\nstatic int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,\n\t\t\t\t   struct device_node *dev_node,\n\t\t\t\t   u32 cs)\n{\n\tunsigned int i;\n\tint ret;\n\n\tstm32_fmc2_ebi_disable_bank(ebi, cs);\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32_fmc2_child_props); i++) {\n\t\tconst struct stm32_fmc2_prop *p = &stm32_fmc2_child_props[i];\n\n\t\tret = stm32_fmc2_ebi_parse_prop(ebi, dev_node, p, cs);\n\t\tif (ret) {\n\t\t\tdev_err(ebi->dev, \"property %s could not be set: %d\\n\",\n\t\t\t\tp->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tstm32_fmc2_ebi_enable_bank(ebi, cs);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_ebi_parse_dt(struct stm32_fmc2_ebi *ebi)\n{\n\tstruct device *dev = ebi->dev;\n\tstruct device_node *child;\n\tbool child_found = false;\n\tu32 bank;\n\tint ret;\n\n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\tret = of_property_read_u32(child, \"reg\", &bank);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"could not retrieve reg property: %d\\n\",\n\t\t\t\tret);\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (bank >= FMC2_MAX_BANKS) {\n\t\t\tdev_err(dev, \"invalid reg value: %d\\n\", bank);\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ebi->bank_assigned & BIT(bank)) {\n\t\t\tdev_err(dev, \"bank already assigned: %d\\n\", bank);\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bank < FMC2_MAX_EBI_CE) {\n\t\t\tret = stm32_fmc2_ebi_setup_cs(ebi, child, bank);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"setup chip select %d failed: %d\\n\",\n\t\t\t\t\tbank, ret);\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tebi->bank_assigned |= BIT(bank);\n\t\tchild_found = true;\n\t}\n\n\tif (!child_found) {\n\t\tdev_warn(dev, \"no subnodes found, disable the driver.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (stm32_fmc2_ebi_nwait_used_by_ctrls(ebi)) {\n\t\tdev_err(dev, \"NWAIT signal connected to EBI and NAND controllers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstm32_fmc2_ebi_enable(ebi);\n\n\treturn of_platform_populate(dev->of_node, NULL, NULL, dev);\n}\n\nstatic int stm32_fmc2_ebi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_fmc2_ebi *ebi;\n\tstruct reset_control *rstc;\n\tint ret;\n\n\tebi = devm_kzalloc(&pdev->dev, sizeof(*ebi), GFP_KERNEL);\n\tif (!ebi)\n\t\treturn -ENOMEM;\n\n\tebi->dev = dev;\n\n\tebi->regmap = device_node_to_regmap(dev->of_node);\n\tif (IS_ERR(ebi->regmap))\n\t\treturn PTR_ERR(ebi->regmap);\n\n\tebi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ebi->clk))\n\t\treturn PTR_ERR(ebi->clk);\n\n\trstc = devm_reset_control_get(dev, NULL);\n\tif (PTR_ERR(rstc) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tret = clk_prepare_enable(ebi->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR(rstc)) {\n\t\treset_control_assert(rstc);\n\t\treset_control_deassert(rstc);\n\t}\n\n\tret = stm32_fmc2_ebi_parse_dt(ebi);\n\tif (ret)\n\t\tgoto err_release;\n\n\tstm32_fmc2_ebi_save_setup(ebi);\n\tplatform_set_drvdata(pdev, ebi);\n\n\treturn 0;\n\nerr_release:\n\tstm32_fmc2_ebi_disable_banks(ebi);\n\tstm32_fmc2_ebi_disable(ebi);\n\tclk_disable_unprepare(ebi->clk);\n\n\treturn ret;\n}\n\nstatic int stm32_fmc2_ebi_remove(struct platform_device *pdev)\n{\n\tstruct stm32_fmc2_ebi *ebi = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(&pdev->dev);\n\tstm32_fmc2_ebi_disable_banks(ebi);\n\tstm32_fmc2_ebi_disable(ebi);\n\tclk_disable_unprepare(ebi->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_fmc2_ebi_suspend(struct device *dev)\n{\n\tstruct stm32_fmc2_ebi *ebi = dev_get_drvdata(dev);\n\n\tstm32_fmc2_ebi_disable(ebi);\n\tclk_disable_unprepare(ebi->clk);\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_fmc2_ebi_resume(struct device *dev)\n{\n\tstruct stm32_fmc2_ebi *ebi = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = clk_prepare_enable(ebi->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32_fmc2_ebi_set_setup(ebi);\n\tstm32_fmc2_ebi_enable(ebi);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(stm32_fmc2_ebi_pm_ops, stm32_fmc2_ebi_suspend,\n\t\t\t stm32_fmc2_ebi_resume);\n\nstatic const struct of_device_id stm32_fmc2_ebi_match[] = {\n\t{.compatible = \"st,stm32mp1-fmc2-ebi\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_fmc2_ebi_match);\n\nstatic struct platform_driver stm32_fmc2_ebi_driver = {\n\t.probe\t= stm32_fmc2_ebi_probe,\n\t.remove\t= stm32_fmc2_ebi_remove,\n\t.driver\t= {\n\t\t.name = \"stm32_fmc2_ebi\",\n\t\t.of_match_table = stm32_fmc2_ebi_match,\n\t\t.pm = &stm32_fmc2_ebi_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_fmc2_ebi_driver);\n\nMODULE_ALIAS(\"platform:stm32_fmc2_ebi\");\nMODULE_AUTHOR(\"Christophe Kerello <christophe.kerello@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 FMC2 ebi driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}