{
  "module_name": "jz4780-nemc.c",
  "hash_id": "ce2f4ffe94eceafcdebacc6455a4b52d5878fc12053cacadca5026d7a37a33e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/jz4780-nemc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/jz4780-nemc.h>\n\n#define NEMC_SMCRn(n)\t\t(0x14 + (((n) - 1) * 4))\n#define NEMC_NFCSR\t\t0x50\n\n#define NEMC_REG_LEN\t\t0x54\n\n#define NEMC_SMCR_SMT\t\tBIT(0)\n#define NEMC_SMCR_BW_SHIFT\t6\n#define NEMC_SMCR_BW_MASK\t(0x3 << NEMC_SMCR_BW_SHIFT)\n#define NEMC_SMCR_BW_8\t\t(0 << 6)\n#define NEMC_SMCR_TAS_SHIFT\t8\n#define NEMC_SMCR_TAS_MASK\t(0xf << NEMC_SMCR_TAS_SHIFT)\n#define NEMC_SMCR_TAH_SHIFT\t12\n#define NEMC_SMCR_TAH_MASK\t(0xf << NEMC_SMCR_TAH_SHIFT)\n#define NEMC_SMCR_TBP_SHIFT\t16\n#define NEMC_SMCR_TBP_MASK\t(0xf << NEMC_SMCR_TBP_SHIFT)\n#define NEMC_SMCR_TAW_SHIFT\t20\n#define NEMC_SMCR_TAW_MASK\t(0xf << NEMC_SMCR_TAW_SHIFT)\n#define NEMC_SMCR_TSTRV_SHIFT\t24\n#define NEMC_SMCR_TSTRV_MASK\t(0x3f << NEMC_SMCR_TSTRV_SHIFT)\n\n#define NEMC_NFCSR_NFEn(n)\tBIT(((n) - 1) << 1)\n#define NEMC_NFCSR_NFCEn(n)\tBIT((((n) - 1) << 1) + 1)\n#define NEMC_NFCSR_TNFEn(n)\tBIT(16 + (n) - 1)\n\nstruct jz_soc_info {\n\tu8 tas_tah_cycles_max;\n};\n\nstruct jz4780_nemc {\n\tspinlock_t lock;\n\tstruct device *dev;\n\tconst struct jz_soc_info *soc_info;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tuint32_t clk_period;\n\tunsigned long banks_present;\n};\n\n \nunsigned int jz4780_nemc_num_banks(struct device *dev)\n{\n\tconst __be32 *prop;\n\tunsigned int bank, count = 0;\n\tunsigned long referenced = 0;\n\tint i = 0;\n\n\twhile ((prop = of_get_address(dev->of_node, i++, NULL, NULL))) {\n\t\tbank = of_read_number(prop, 1);\n\t\tif (!(referenced & BIT(bank))) {\n\t\t\treferenced |= BIT(bank);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(jz4780_nemc_num_banks);\n\n \nvoid jz4780_nemc_set_type(struct device *dev, unsigned int bank,\n\t\t\t  enum jz4780_nemc_bank_type type)\n{\n\tstruct jz4780_nemc *nemc = dev_get_drvdata(dev->parent);\n\tuint32_t nfcsr;\n\n\tnfcsr = readl(nemc->base + NEMC_NFCSR);\n\n\t \n\tswitch (type) {\n\tcase JZ4780_NEMC_BANK_SRAM:\n\t\tnfcsr &= ~(NEMC_NFCSR_TNFEn(bank) | NEMC_NFCSR_NFEn(bank));\n\t\tbreak;\n\tcase JZ4780_NEMC_BANK_NAND:\n\t\tnfcsr &= ~NEMC_NFCSR_TNFEn(bank);\n\t\tnfcsr |= NEMC_NFCSR_NFEn(bank);\n\t\tbreak;\n\t}\n\n\twritel(nfcsr, nemc->base + NEMC_NFCSR);\n}\nEXPORT_SYMBOL(jz4780_nemc_set_type);\n\n \nvoid jz4780_nemc_assert(struct device *dev, unsigned int bank, bool assert)\n{\n\tstruct jz4780_nemc *nemc = dev_get_drvdata(dev->parent);\n\tuint32_t nfcsr;\n\n\tnfcsr = readl(nemc->base + NEMC_NFCSR);\n\n\tif (assert)\n\t\tnfcsr |= NEMC_NFCSR_NFCEn(bank);\n\telse\n\t\tnfcsr &= ~NEMC_NFCSR_NFCEn(bank);\n\n\twritel(nfcsr, nemc->base + NEMC_NFCSR);\n}\nEXPORT_SYMBOL(jz4780_nemc_assert);\n\nstatic uint32_t jz4780_nemc_clk_period(struct jz4780_nemc *nemc)\n{\n\tunsigned long rate;\n\n\trate = clk_get_rate(nemc->clk);\n\tif (!rate)\n\t\treturn 0;\n\n\t \n\treturn div64_ul(1000000000000ull, rate);\n}\n\nstatic uint32_t jz4780_nemc_ns_to_cycles(struct jz4780_nemc *nemc, uint32_t ns)\n{\n\treturn ((ns * 1000) + nemc->clk_period - 1) / nemc->clk_period;\n}\n\nstatic bool jz4780_nemc_configure_bank(struct jz4780_nemc *nemc,\n\t\t\t\t       unsigned int bank,\n\t\t\t\t       struct device_node *node)\n{\n\tuint32_t smcr, val, cycles;\n\n\t \n\tstatic const u8 convert_tBP_tAW[] = {\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n\n\t\t \n\t\t11, 11,\n\n\t\t \n\t\t12, 12, 12,\n\n\t\t \n\t\t13, 13, 13, 13, 13,\n\n\t\t \n\t\t14, 14, 14, 14, 14,\n\n\t\t \n\t\t15, 15, 15, 15, 15, 15\n\t};\n\n\tsmcr = readl(nemc->base + NEMC_SMCRn(bank));\n\tsmcr &= ~NEMC_SMCR_SMT;\n\n\tif (!of_property_read_u32(node, \"ingenic,nemc-bus-width\", &val)) {\n\t\tsmcr &= ~NEMC_SMCR_BW_MASK;\n\t\tswitch (val) {\n\t\tcase 8:\n\t\t\tsmcr |= NEMC_SMCR_BW_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_err(nemc->dev, \"unsupported bus width: %u\\n\", val);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (of_property_read_u32(node, \"ingenic,nemc-tAS\", &val) == 0) {\n\t\tsmcr &= ~NEMC_SMCR_TAS_MASK;\n\t\tcycles = jz4780_nemc_ns_to_cycles(nemc, val);\n\t\tif (cycles > nemc->soc_info->tas_tah_cycles_max) {\n\t\t\tdev_err(nemc->dev, \"tAS %u is too high (%u cycles)\\n\",\n\t\t\t\tval, cycles);\n\t\t\treturn false;\n\t\t}\n\n\t\tsmcr |= cycles << NEMC_SMCR_TAS_SHIFT;\n\t}\n\n\tif (of_property_read_u32(node, \"ingenic,nemc-tAH\", &val) == 0) {\n\t\tsmcr &= ~NEMC_SMCR_TAH_MASK;\n\t\tcycles = jz4780_nemc_ns_to_cycles(nemc, val);\n\t\tif (cycles > nemc->soc_info->tas_tah_cycles_max) {\n\t\t\tdev_err(nemc->dev, \"tAH %u is too high (%u cycles)\\n\",\n\t\t\t\tval, cycles);\n\t\t\treturn false;\n\t\t}\n\n\t\tsmcr |= cycles << NEMC_SMCR_TAH_SHIFT;\n\t}\n\n\tif (of_property_read_u32(node, \"ingenic,nemc-tBP\", &val) == 0) {\n\t\tsmcr &= ~NEMC_SMCR_TBP_MASK;\n\t\tcycles = jz4780_nemc_ns_to_cycles(nemc, val);\n\t\tif (cycles > 31) {\n\t\t\tdev_err(nemc->dev, \"tBP %u is too high (%u cycles)\\n\",\n\t\t\t\tval, cycles);\n\t\t\treturn false;\n\t\t}\n\n\t\tsmcr |= convert_tBP_tAW[cycles] << NEMC_SMCR_TBP_SHIFT;\n\t}\n\n\tif (of_property_read_u32(node, \"ingenic,nemc-tAW\", &val) == 0) {\n\t\tsmcr &= ~NEMC_SMCR_TAW_MASK;\n\t\tcycles = jz4780_nemc_ns_to_cycles(nemc, val);\n\t\tif (cycles > 31) {\n\t\t\tdev_err(nemc->dev, \"tAW %u is too high (%u cycles)\\n\",\n\t\t\t\tval, cycles);\n\t\t\treturn false;\n\t\t}\n\n\t\tsmcr |= convert_tBP_tAW[cycles] << NEMC_SMCR_TAW_SHIFT;\n\t}\n\n\tif (of_property_read_u32(node, \"ingenic,nemc-tSTRV\", &val) == 0) {\n\t\tsmcr &= ~NEMC_SMCR_TSTRV_MASK;\n\t\tcycles = jz4780_nemc_ns_to_cycles(nemc, val);\n\t\tif (cycles > 63) {\n\t\t\tdev_err(nemc->dev, \"tSTRV %u is too high (%u cycles)\\n\",\n\t\t\t\tval, cycles);\n\t\t\treturn false;\n\t\t}\n\n\t\tsmcr |= cycles << NEMC_SMCR_TSTRV_SHIFT;\n\t}\n\n\twritel(smcr, nemc->base + NEMC_SMCRn(bank));\n\treturn true;\n}\n\nstatic int jz4780_nemc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct jz4780_nemc *nemc;\n\tstruct resource *res;\n\tstruct device_node *child;\n\tconst __be32 *prop;\n\tunsigned int bank;\n\tunsigned long referenced;\n\tint i, ret;\n\n\tnemc = devm_kzalloc(dev, sizeof(*nemc), GFP_KERNEL);\n\tif (!nemc)\n\t\treturn -ENOMEM;\n\n\tnemc->soc_info = device_get_match_data(dev);\n\tif (!nemc->soc_info)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&nemc->lock);\n\tnemc->dev = dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\t \n\tif (!devm_request_mem_region(dev, res->start, NEMC_REG_LEN, dev_name(dev))) {\n\t\tdev_err(dev, \"unable to request I/O memory region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tnemc->base = devm_ioremap(dev, res->start, NEMC_REG_LEN);\n\tif (!nemc->base) {\n\t\tdev_err(dev, \"failed to get I/O memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(0, nemc->base + NEMC_NFCSR);\n\n\tnemc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(nemc->clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(nemc->clk);\n\t}\n\n\tret = clk_prepare_enable(nemc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnemc->clk_period = jz4780_nemc_clk_period(nemc);\n\tif (!nemc->clk_period) {\n\t\tdev_err(dev, \"failed to calculate clock period\\n\");\n\t\tclk_disable_unprepare(nemc->clk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_child_of_node(nemc->dev->of_node, child) {\n\t\treferenced = 0;\n\t\ti = 0;\n\t\twhile ((prop = of_get_address(child, i++, NULL, NULL))) {\n\t\t\tbank = of_read_number(prop, 1);\n\t\t\tif (bank < 1 || bank >= JZ4780_NEMC_NUM_BANKS) {\n\t\t\t\tdev_err(nemc->dev,\n\t\t\t\t\t\"%pOF requests invalid bank %u\\n\",\n\t\t\t\t\tchild, bank);\n\n\t\t\t\t \n\t\t\t\treferenced = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treferenced |= BIT(bank);\n\t\t}\n\n\t\tif (!referenced) {\n\t\t\tdev_err(nemc->dev, \"%pOF has no addresses\\n\",\n\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t} else if (nemc->banks_present & referenced) {\n\t\t\tdev_err(nemc->dev, \"%pOF conflicts with another node\\n\",\n\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor_each_set_bit(bank, &referenced, JZ4780_NEMC_NUM_BANKS) {\n\t\t\tif (!jz4780_nemc_configure_bank(nemc, bank, child)) {\n\t\t\t\treferenced = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (referenced) {\n\t\t\tif (of_platform_device_create(child, NULL, nemc->dev))\n\t\t\t\tnemc->banks_present |= referenced;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, nemc);\n\tdev_info(dev, \"JZ4780 NEMC initialised\\n\");\n\treturn 0;\n}\n\nstatic int jz4780_nemc_remove(struct platform_device *pdev)\n{\n\tstruct jz4780_nemc *nemc = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(nemc->clk);\n\treturn 0;\n}\n\nstatic const struct jz_soc_info jz4740_soc_info = {\n\t.tas_tah_cycles_max = 7,\n};\n\nstatic const struct jz_soc_info jz4780_soc_info = {\n\t.tas_tah_cycles_max = 15,\n};\n\nstatic const struct of_device_id jz4780_nemc_dt_match[] = {\n\t{ .compatible = \"ingenic,jz4740-nemc\", .data = &jz4740_soc_info, },\n\t{ .compatible = \"ingenic,jz4780-nemc\", .data = &jz4780_soc_info, },\n\t{},\n};\n\nstatic struct platform_driver jz4780_nemc_driver = {\n\t.probe\t\t= jz4780_nemc_probe,\n\t.remove\t\t= jz4780_nemc_remove,\n\t.driver\t= {\n\t\t.name\t= \"jz4780-nemc\",\n\t\t.of_match_table = of_match_ptr(jz4780_nemc_dt_match),\n\t},\n};\n\nstatic int __init jz4780_nemc_init(void)\n{\n\treturn platform_driver_register(&jz4780_nemc_driver);\n}\nsubsys_initcall(jz4780_nemc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}