{
  "module_name": "fsl-corenet-cf.c",
  "hash_id": "bd0d7b7d92863f5480a2678fd36bde7a4c3f0cb62c38760c2147a8f3a4487c24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/fsl-corenet-cf.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\nenum ccf_version {\n\tCCF1,\n\tCCF2,\n};\n\nstruct ccf_info {\n\tenum ccf_version version;\n\tint err_reg_offs;\n\tbool has_brr;\n};\n\nstatic const struct ccf_info ccf1_info = {\n\t.version = CCF1,\n\t.err_reg_offs = 0xa00,\n\t.has_brr = false,\n};\n\nstatic const struct ccf_info ccf2_info = {\n\t.version = CCF2,\n\t.err_reg_offs = 0xe40,\n\t.has_brr = true,\n};\n\n \n#define CCF_BRR\t\t\t0xbf8\n#define CCF_BRR_IPID\t\t0xffff0000\n#define CCF_BRR_IPID_T1040\t0x09310000\n\nstatic const struct of_device_id ccf_matches[] = {\n\t{\n\t\t.compatible = \"fsl,corenet1-cf\",\n\t\t.data = &ccf1_info,\n\t},\n\t{\n\t\t.compatible = \"fsl,corenet2-cf\",\n\t\t.data = &ccf2_info,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ccf_matches);\n\nstruct ccf_err_regs {\n\tu32 errdet;\t\t \n\t \n\tu32 errdis;\n\t \n\tu32 errinten;\n\tu32 cecar;\t\t \n\tu32 cecaddrh;\t\t \n\tu32 cecaddrl;\t\t \n\tu32 cecar2;\t\t \n};\n\n \n#define ERRDET_LAE\t\t(1 << 0)   \n#define ERRDET_CV\t\t(1 << 1)   \n#define ERRDET_UTID\t\t(1 << 2)   \n#define ERRDET_MCST\t\t(1 << 3)   \n#define ERRDET_CTYPE_SHIFT\t26\t   \n#define ERRDET_CTYPE_MASK\t(0x1f << ERRDET_CTYPE_SHIFT)\n#define ERRDET_CAP\t\t(1 << 31)  \n\n#define CECAR_VAL\t\t(1 << 0)   \n#define CECAR_UVT\t\t(1 << 15)  \n#define CECAR_SRCID_SHIFT_CCF1\t24\n#define CECAR_SRCID_MASK_CCF1\t(0xff << CECAR_SRCID_SHIFT_CCF1)\n#define CECAR_SRCID_SHIFT_CCF2\t18\n#define CECAR_SRCID_MASK_CCF2\t(0xff << CECAR_SRCID_SHIFT_CCF2)\n\n#define CECADDRH_ADDRH\t\t0xff\n\nstruct ccf_private {\n\tconst struct ccf_info *info;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct ccf_err_regs __iomem *err_regs;\n\tbool t1040;\n};\n\nstatic irqreturn_t ccf_irq(int irq, void *dev_id)\n{\n\tstruct ccf_private *ccf = dev_id;\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tu32 errdet, cecar, cecar2;\n\tu64 addr;\n\tu32 src_id;\n\tbool uvt = false;\n\tbool cap_valid = false;\n\n\terrdet = ioread32be(&ccf->err_regs->errdet);\n\tcecar = ioread32be(&ccf->err_regs->cecar);\n\tcecar2 = ioread32be(&ccf->err_regs->cecar2);\n\taddr = ioread32be(&ccf->err_regs->cecaddrl);\n\taddr |= ((u64)(ioread32be(&ccf->err_regs->cecaddrh) &\n\t\t       CECADDRH_ADDRH)) << 32;\n\n\tif (!__ratelimit(&ratelimit))\n\t\tgoto out;\n\n\tswitch (ccf->info->version) {\n\tcase CCF1:\n\t\tif (cecar & CECAR_VAL) {\n\t\t\tif (cecar & CECAR_UVT)\n\t\t\t\tuvt = true;\n\n\t\t\tsrc_id = (cecar & CECAR_SRCID_MASK_CCF1) >>\n\t\t\t\t CECAR_SRCID_SHIFT_CCF1;\n\t\t\tcap_valid = true;\n\t\t}\n\n\t\tbreak;\n\tcase CCF2:\n\t\tif (errdet & ERRDET_CAP) {\n\t\t\tsrc_id = (cecar & CECAR_SRCID_MASK_CCF2) >>\n\t\t\t\t CECAR_SRCID_SHIFT_CCF2;\n\t\t\tcap_valid = true;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdev_crit(ccf->dev, \"errdet 0x%08x cecar 0x%08x cecar2 0x%08x\\n\",\n\t\t errdet, cecar, cecar2);\n\n\tif (errdet & ERRDET_LAE) {\n\t\tif (uvt)\n\t\t\tdev_crit(ccf->dev, \"LAW Unavailable Target ID\\n\");\n\t\telse\n\t\t\tdev_crit(ccf->dev, \"Local Access Window Error\\n\");\n\t}\n\n\tif (errdet & ERRDET_CV)\n\t\tdev_crit(ccf->dev, \"Coherency Violation\\n\");\n\n\tif (errdet & ERRDET_UTID)\n\t\tdev_crit(ccf->dev, \"Unavailable Target ID\\n\");\n\n\tif (errdet & ERRDET_MCST)\n\t\tdev_crit(ccf->dev, \"Multicast Stash\\n\");\n\n\tif (cap_valid) {\n\t\tdev_crit(ccf->dev, \"address 0x%09llx, src id 0x%x\\n\",\n\t\t\t addr, src_id);\n\t}\n\nout:\n\tiowrite32be(errdet, &ccf->err_regs->errdet);\n\treturn errdet ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int ccf_probe(struct platform_device *pdev)\n{\n\tstruct ccf_private *ccf;\n\tconst struct of_device_id *match;\n\tu32 errinten;\n\tint ret, irq;\n\n\tmatch = of_match_device(ccf_matches, &pdev->dev);\n\tif (WARN_ON(!match))\n\t\treturn -ENODEV;\n\n\tccf = devm_kzalloc(&pdev->dev, sizeof(*ccf), GFP_KERNEL);\n\tif (!ccf)\n\t\treturn -ENOMEM;\n\n\tccf->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ccf->regs))\n\t\treturn PTR_ERR(ccf->regs);\n\n\tccf->dev = &pdev->dev;\n\tccf->info = match->data;\n\tccf->err_regs = ccf->regs + ccf->info->err_reg_offs;\n\n\tif (ccf->info->has_brr) {\n\t\tu32 brr = ioread32be(ccf->regs + CCF_BRR);\n\n\t\tif ((brr & CCF_BRR_IPID) == CCF_BRR_IPID_T1040)\n\t\t\tccf->t1040 = true;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ccf);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, ccf_irq, 0, pdev->name, ccf);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: can't request irq\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\terrinten = ERRDET_LAE | ERRDET_CV;\n\tif (ccf->t1040)\n\t\terrinten |= ERRDET_UTID | ERRDET_MCST;\n\n\tswitch (ccf->info->version) {\n\tcase CCF1:\n\t\t \n\t\tiowrite32be(errinten, &ccf->err_regs->errdis);\n\t\tbreak;\n\n\tcase CCF2:\n\t\tiowrite32be(0, &ccf->err_regs->errdis);\n\t\tiowrite32be(errinten, &ccf->err_regs->errinten);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccf_remove(struct platform_device *pdev)\n{\n\tstruct ccf_private *ccf = dev_get_drvdata(&pdev->dev);\n\n\tswitch (ccf->info->version) {\n\tcase CCF1:\n\t\tiowrite32be(0, &ccf->err_regs->errdis);\n\t\tbreak;\n\n\tcase CCF2:\n\t\t \n\t\tiowrite32be(0, &ccf->err_regs->errinten);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ccf_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = ccf_matches,\n\t},\n\t.probe = ccf_probe,\n\t.remove = ccf_remove,\n};\n\nmodule_platform_driver(ccf_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Freescale Semiconductor\");\nMODULE_DESCRIPTION(\"Freescale CoreNet Coherency Fabric error reporting\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}