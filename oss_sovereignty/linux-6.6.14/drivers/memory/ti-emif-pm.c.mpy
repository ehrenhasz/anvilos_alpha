{
  "module_name": "ti-emif-pm.c",
  "hash_id": "ef549e9aca4d384ceb47a4c85bde58c0e7623be980e73f684603c71885204f8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/ti-emif-pm.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sram.h>\n#include <linux/ti-emif-sram.h>\n\n#include \"emif.h\"\n\n#define TI_EMIF_SRAM_SYMBOL_OFFSET(sym) ((unsigned long)(sym) - \\\n\t\t\t\t\t (unsigned long)&ti_emif_sram)\n\n#define EMIF_POWER_MGMT_WAIT_SELF_REFRESH_8192_CYCLES\t\t0x00a0\n\nstruct ti_emif_data {\n\tphys_addr_t ti_emif_sram_phys;\n\tphys_addr_t ti_emif_sram_data_phys;\n\tunsigned long ti_emif_sram_virt;\n\tunsigned long ti_emif_sram_data_virt;\n\tstruct gen_pool *sram_pool_code;\n\tstruct gen_pool\t*sram_pool_data;\n\tstruct ti_emif_pm_data pm_data;\n\tstruct ti_emif_pm_functions pm_functions;\n};\n\nstatic struct ti_emif_data *emif_instance;\n\nstatic u32 sram_suspend_address(struct ti_emif_data *emif_data,\n\t\t\t\tunsigned long addr)\n{\n\treturn (emif_data->ti_emif_sram_virt +\n\t\tTI_EMIF_SRAM_SYMBOL_OFFSET(addr));\n}\n\nstatic phys_addr_t sram_resume_address(struct ti_emif_data *emif_data,\n\t\t\t\t       unsigned long addr)\n{\n\treturn ((unsigned long)emif_data->ti_emif_sram_phys +\n\t\tTI_EMIF_SRAM_SYMBOL_OFFSET(addr));\n}\n\nstatic void ti_emif_free_sram(struct ti_emif_data *emif_data)\n{\n\tgen_pool_free(emif_data->sram_pool_code, emif_data->ti_emif_sram_virt,\n\t\t      ti_emif_sram_sz);\n\tgen_pool_free(emif_data->sram_pool_data,\n\t\t      emif_data->ti_emif_sram_data_virt,\n\t\t      sizeof(struct emif_regs_amx3));\n}\n\nstatic int ti_emif_alloc_sram(struct device *dev,\n\t\t\t      struct ti_emif_data *emif_data)\n{\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\temif_data->sram_pool_code = of_gen_pool_get(np, \"sram\", 0);\n\tif (!emif_data->sram_pool_code) {\n\t\tdev_err(dev, \"Unable to get sram pool for ocmcram code\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\temif_data->ti_emif_sram_virt =\n\t\t\tgen_pool_alloc(emif_data->sram_pool_code,\n\t\t\t\t       ti_emif_sram_sz);\n\tif (!emif_data->ti_emif_sram_virt) {\n\t\tdev_err(dev, \"Unable to allocate code memory from ocmcram\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\temif_data->ti_emif_sram_phys =\n\t\t\tgen_pool_virt_to_phys(emif_data->sram_pool_code,\n\t\t\t\t\t      emif_data->ti_emif_sram_virt);\n\n\t \n\temif_data->sram_pool_data = of_gen_pool_get(np, \"sram\", 1);\n\tif (!emif_data->sram_pool_data) {\n\t\tdev_err(dev, \"Unable to get sram pool for ocmcram data\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free_sram_code;\n\t}\n\n\temif_data->ti_emif_sram_data_virt =\n\t\t\t\tgen_pool_alloc(emif_data->sram_pool_data,\n\t\t\t\t\t       sizeof(struct emif_regs_amx3));\n\tif (!emif_data->ti_emif_sram_data_virt) {\n\t\tdev_err(dev, \"Unable to allocate data memory from ocmcram\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_sram_code;\n\t}\n\n\t \n\temif_data->ti_emif_sram_data_phys =\n\t\tgen_pool_virt_to_phys(emif_data->sram_pool_data,\n\t\t\t\t      emif_data->ti_emif_sram_data_virt);\n\t \n\temif_data->pm_functions.save_context =\n\t\tsram_suspend_address(emif_data,\n\t\t\t\t     (unsigned long)ti_emif_save_context);\n\temif_data->pm_functions.enter_sr =\n\t\tsram_suspend_address(emif_data,\n\t\t\t\t     (unsigned long)ti_emif_enter_sr);\n\temif_data->pm_functions.abort_sr =\n\t\tsram_suspend_address(emif_data,\n\t\t\t\t     (unsigned long)ti_emif_abort_sr);\n\n\t \n\temif_data->pm_functions.restore_context =\n\t\tsram_resume_address(emif_data,\n\t\t\t\t    (unsigned long)ti_emif_restore_context);\n\temif_data->pm_functions.exit_sr =\n\t\tsram_resume_address(emif_data,\n\t\t\t\t    (unsigned long)ti_emif_exit_sr);\n\temif_data->pm_functions.run_hw_leveling =\n\t\tsram_resume_address(emif_data,\n\t\t\t\t    (unsigned long)ti_emif_run_hw_leveling);\n\n\temif_data->pm_data.regs_virt =\n\t\t(struct emif_regs_amx3 *)emif_data->ti_emif_sram_data_virt;\n\temif_data->pm_data.regs_phys = emif_data->ti_emif_sram_data_phys;\n\n\treturn 0;\n\nerr_free_sram_code:\n\tgen_pool_free(emif_data->sram_pool_code, emif_data->ti_emif_sram_virt,\n\t\t      ti_emif_sram_sz);\n\treturn ret;\n}\n\nstatic int ti_emif_push_sram(struct device *dev, struct ti_emif_data *emif_data)\n{\n\tvoid *copy_addr;\n\tu32 data_addr;\n\n\tcopy_addr = sram_exec_copy(emif_data->sram_pool_code,\n\t\t\t\t   (void *)emif_data->ti_emif_sram_virt,\n\t\t\t\t   &ti_emif_sram, ti_emif_sram_sz);\n\tif (!copy_addr) {\n\t\tdev_err(dev, \"Cannot copy emif code to sram\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata_addr = sram_suspend_address(emif_data,\n\t\t\t\t\t (unsigned long)&ti_emif_pm_sram_data);\n\tcopy_addr = sram_exec_copy(emif_data->sram_pool_code,\n\t\t\t\t   (void *)data_addr,\n\t\t\t\t   &emif_data->pm_data,\n\t\t\t\t   sizeof(emif_data->pm_data));\n\tif (!copy_addr) {\n\t\tdev_err(dev, \"Cannot copy emif data to code sram\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ti_emif_configure_sr_delay(struct ti_emif_data *emif_data)\n{\n\twritel(EMIF_POWER_MGMT_WAIT_SELF_REFRESH_8192_CYCLES,\n\t       (emif_data->pm_data.ti_emif_base_addr_virt +\n\t\tEMIF_POWER_MANAGEMENT_CONTROL));\n\n\twritel(EMIF_POWER_MGMT_WAIT_SELF_REFRESH_8192_CYCLES,\n\t       (emif_data->pm_data.ti_emif_base_addr_virt +\n\t\tEMIF_POWER_MANAGEMENT_CTRL_SHDW));\n}\n\n \nint ti_emif_copy_pm_function_table(struct gen_pool *sram_pool, void *dst)\n{\n\tvoid *copy_addr;\n\n\tif (!emif_instance)\n\t\treturn -ENODEV;\n\n\tcopy_addr = sram_exec_copy(sram_pool, dst,\n\t\t\t\t   &emif_instance->pm_functions,\n\t\t\t\t   sizeof(emif_instance->pm_functions));\n\tif (!copy_addr)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ti_emif_copy_pm_function_table);\n\n \nint ti_emif_get_mem_type(void)\n{\n\tunsigned long temp;\n\n\tif (!emif_instance)\n\t\treturn -ENODEV;\n\n\ttemp = readl(emif_instance->pm_data.ti_emif_base_addr_virt +\n\t\t     EMIF_SDRAM_CONFIG);\n\n\ttemp = (temp & SDRAM_TYPE_MASK) >> SDRAM_TYPE_SHIFT;\n\treturn temp;\n}\nEXPORT_SYMBOL_GPL(ti_emif_get_mem_type);\n\nstatic const struct of_device_id ti_emif_of_match[] = {\n\t{ .compatible = \"ti,emif-am3352\", .data =\n\t\t\t\t\t(void *)EMIF_SRAM_AM33_REG_LAYOUT, },\n\t{ .compatible = \"ti,emif-am4372\", .data =\n\t\t\t\t\t(void *)EMIF_SRAM_AM43_REG_LAYOUT, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ti_emif_of_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ti_emif_resume(struct device *dev)\n{\n\tunsigned long tmp =\n\t\t\t__raw_readl((void __iomem *)emif_instance->ti_emif_sram_virt);\n\n\t \n\tif (tmp != ti_emif_sram)\n\t\tti_emif_push_sram(dev, emif_instance);\n\n\treturn 0;\n}\n\nstatic int ti_emif_suspend(struct device *dev)\n{\n\t \n\treturn 0;\n}\n#endif  \n\nstatic int ti_emif_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct ti_emif_data *emif_data;\n\n\temif_data = devm_kzalloc(dev, sizeof(*emif_data), GFP_KERNEL);\n\tif (!emif_data)\n\t\treturn -ENOMEM;\n\n\temif_data->pm_data.ti_emif_sram_config = (unsigned long) device_get_match_data(&pdev->dev);\n\n\temif_data->pm_data.ti_emif_base_addr_virt = devm_platform_get_and_ioremap_resource(pdev,\n\t\t\t\t\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t\t\t\t\t   &res);\n\tif (IS_ERR(emif_data->pm_data.ti_emif_base_addr_virt)) {\n\t\tret = PTR_ERR(emif_data->pm_data.ti_emif_base_addr_virt);\n\t\treturn ret;\n\t}\n\n\temif_data->pm_data.ti_emif_base_addr_phys = res->start;\n\n\tti_emif_configure_sr_delay(emif_data);\n\n\tret = ti_emif_alloc_sram(dev, emif_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_emif_push_sram(dev, emif_data);\n\tif (ret)\n\t\tgoto fail_free_sram;\n\n\temif_instance = emif_data;\n\n\treturn 0;\n\nfail_free_sram:\n\tti_emif_free_sram(emif_data);\n\n\treturn ret;\n}\n\nstatic int ti_emif_remove(struct platform_device *pdev)\n{\n\tstruct ti_emif_data *emif_data = emif_instance;\n\n\temif_instance = NULL;\n\n\tti_emif_free_sram(emif_data);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ti_emif_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ti_emif_suspend, ti_emif_resume)\n};\n\nstatic struct platform_driver ti_emif_driver = {\n\t.probe = ti_emif_probe,\n\t.remove = ti_emif_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = ti_emif_of_match,\n\t\t.pm = &ti_emif_pm_ops,\n\t},\n};\nmodule_platform_driver(ti_emif_driver);\n\nMODULE_AUTHOR(\"Dave Gerlach <d-gerlach@ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments SRAM EMIF driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}