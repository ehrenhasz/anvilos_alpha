{
  "module_name": "dfl-emif.c",
  "hash_id": "40cc56ba4205fc58f7906b956152fd9521c9122eefdc13b707a8f49f7cb77c28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/dfl-emif.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/dfl.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#define FME_FEATURE_ID_EMIF\t\t0x9\n\n#define EMIF_STAT\t\t\t0x8\n#define EMIF_STAT_INIT_DONE_SFT\t\t0\n#define EMIF_STAT_CALC_FAIL_SFT\t\t8\n#define EMIF_STAT_CLEAR_BUSY_SFT\t16\n#define EMIF_CTRL\t\t\t0x10\n#define EMIF_CTRL_CLEAR_EN_SFT\t\t0\n#define EMIF_CTRL_CLEAR_EN_MSK\t\tGENMASK_ULL(7, 0)\n\n#define EMIF_POLL_INVL\t\t\t10000  \n#define EMIF_POLL_TIMEOUT\t\t5000000  \n\n \n#define EMIF_CAPABILITY_BASE\t\t0x10\n#define EMIF_CAPABILITY_CHN_MSK_V0\tGENMASK_ULL(3, 0)\n#define EMIF_CAPABILITY_CHN_MSK\t\tGENMASK_ULL(7, 0)\n\nstruct dfl_emif {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tspinlock_t lock;\t \n};\n\nstruct emif_attr {\n\tstruct device_attribute attr;\n\tu32 shift;\n\tu32 index;\n};\n\n#define to_emif_attr(dev_attr) \\\n\tcontainer_of(dev_attr, struct emif_attr, attr)\n\nstatic ssize_t emif_state_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct emif_attr *eattr = to_emif_attr(attr);\n\tstruct dfl_emif *de = dev_get_drvdata(dev);\n\tu64 val;\n\n\tval = readq(de->base + EMIF_STAT);\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  !!(val & BIT_ULL(eattr->shift + eattr->index)));\n}\n\nstatic ssize_t emif_clear_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct emif_attr *eattr = to_emif_attr(attr);\n\tstruct dfl_emif *de = dev_get_drvdata(dev);\n\tu64 clear_busy_msk, clear_en_msk, val;\n\tvoid __iomem *base = de->base;\n\n\tif (!sysfs_streq(buf, \"1\"))\n\t\treturn -EINVAL;\n\n\tclear_busy_msk = BIT_ULL(EMIF_STAT_CLEAR_BUSY_SFT + eattr->index);\n\tclear_en_msk = BIT_ULL(EMIF_CTRL_CLEAR_EN_SFT + eattr->index);\n\n\tspin_lock(&de->lock);\n\t \n\tval = readq(base + EMIF_CTRL);\n\tval &= ~EMIF_CTRL_CLEAR_EN_MSK;\n\tval |= clear_en_msk;\n\twriteq(val, base + EMIF_CTRL);\n\tspin_unlock(&de->lock);\n\n\tif (readq_poll_timeout(base + EMIF_STAT, val,\n\t\t\t       !(val & clear_busy_msk),\n\t\t\t       EMIF_POLL_INVL, EMIF_POLL_TIMEOUT)) {\n\t\tdev_err(de->dev, \"timeout, fail to clear\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn count;\n}\n\n#define emif_state_attr(_name, _shift, _index)\t\t\t\t\\\n\tstatic struct emif_attr emif_attr_##inf##_index##_##_name =\t\\\n\t\t{ .attr = __ATTR(inf##_index##_##_name, 0444,\t\t\\\n\t\t\t\t emif_state_show, NULL),\t\t\\\n\t\t  .shift = (_shift), .index = (_index) }\n\n#define emif_clear_attr(_index)\t\t\t\t\t\t\\\n\tstatic struct emif_attr emif_attr_##inf##_index##_clear =\t\\\n\t\t{ .attr = __ATTR(inf##_index##_clear, 0200,\t\t\\\n\t\t\t\t NULL, emif_clear_store),\t\t\\\n\t\t  .index = (_index) }\n\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 0);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 1);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 2);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 3);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 4);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 5);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 6);\nemif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 7);\n\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 0);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 1);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 2);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 3);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 4);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 5);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 6);\nemif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 7);\n\n\nemif_clear_attr(0);\nemif_clear_attr(1);\nemif_clear_attr(2);\nemif_clear_attr(3);\nemif_clear_attr(4);\nemif_clear_attr(5);\nemif_clear_attr(6);\nemif_clear_attr(7);\n\n\nstatic struct attribute *dfl_emif_attrs[] = {\n\t&emif_attr_inf0_init_done.attr.attr,\n\t&emif_attr_inf0_cal_fail.attr.attr,\n\t&emif_attr_inf0_clear.attr.attr,\n\n\t&emif_attr_inf1_init_done.attr.attr,\n\t&emif_attr_inf1_cal_fail.attr.attr,\n\t&emif_attr_inf1_clear.attr.attr,\n\n\t&emif_attr_inf2_init_done.attr.attr,\n\t&emif_attr_inf2_cal_fail.attr.attr,\n\t&emif_attr_inf2_clear.attr.attr,\n\n\t&emif_attr_inf3_init_done.attr.attr,\n\t&emif_attr_inf3_cal_fail.attr.attr,\n\t&emif_attr_inf3_clear.attr.attr,\n\n\t&emif_attr_inf4_init_done.attr.attr,\n\t&emif_attr_inf4_cal_fail.attr.attr,\n\t&emif_attr_inf4_clear.attr.attr,\n\n\t&emif_attr_inf5_init_done.attr.attr,\n\t&emif_attr_inf5_cal_fail.attr.attr,\n\t&emif_attr_inf5_clear.attr.attr,\n\n\t&emif_attr_inf6_init_done.attr.attr,\n\t&emif_attr_inf6_cal_fail.attr.attr,\n\t&emif_attr_inf6_clear.attr.attr,\n\n\t&emif_attr_inf7_init_done.attr.attr,\n\t&emif_attr_inf7_cal_fail.attr.attr,\n\t&emif_attr_inf7_clear.attr.attr,\n\n\tNULL,\n};\n\nstatic umode_t dfl_emif_visible(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, int n)\n{\n\tstruct dfl_emif *de = dev_get_drvdata(kobj_to_dev(kobj));\n\tstruct emif_attr *eattr = container_of(attr, struct emif_attr,\n\t\t\t\t\t       attr.attr);\n\tstruct dfl_device *ddev = to_dfl_dev(de->dev);\n\tu64 val;\n\n\t \n\tif (ddev->revision > 0 && strstr(attr->name, \"_clear\"))\n\t\treturn 0;\n\n\tif (ddev->revision == 0)\n\t\tval = FIELD_GET(EMIF_CAPABILITY_CHN_MSK_V0,\n\t\t\t\treadq(de->base + EMIF_CAPABILITY_BASE));\n\telse\n\t\tval = FIELD_GET(EMIF_CAPABILITY_CHN_MSK,\n\t\t\t\treadq(de->base + EMIF_CAPABILITY_BASE));\n\n\treturn (val & BIT_ULL(eattr->index)) ? attr->mode : 0;\n}\n\nstatic const struct attribute_group dfl_emif_group = {\n\t.is_visible = dfl_emif_visible,\n\t.attrs = dfl_emif_attrs,\n};\n\nstatic const struct attribute_group *dfl_emif_groups[] = {\n\t&dfl_emif_group,\n\tNULL,\n};\n\nstatic int dfl_emif_probe(struct dfl_device *ddev)\n{\n\tstruct device *dev = &ddev->dev;\n\tstruct dfl_emif *de;\n\n\tde = devm_kzalloc(dev, sizeof(*de), GFP_KERNEL);\n\tif (!de)\n\t\treturn -ENOMEM;\n\n\tde->base = devm_ioremap_resource(dev, &ddev->mmio_res);\n\tif (IS_ERR(de->base))\n\t\treturn PTR_ERR(de->base);\n\n\tde->dev = dev;\n\tspin_lock_init(&de->lock);\n\tdev_set_drvdata(dev, de);\n\n\treturn 0;\n}\n\nstatic const struct dfl_device_id dfl_emif_ids[] = {\n\t{ FME_ID, FME_FEATURE_ID_EMIF },\n\t{ }\n};\nMODULE_DEVICE_TABLE(dfl, dfl_emif_ids);\n\nstatic struct dfl_driver dfl_emif_driver = {\n\t.drv\t= {\n\t\t.name       = \"dfl-emif\",\n\t\t.dev_groups = dfl_emif_groups,\n\t},\n\t.id_table = dfl_emif_ids,\n\t.probe   = dfl_emif_probe,\n};\nmodule_dfl_driver(dfl_emif_driver);\n\nMODULE_DESCRIPTION(\"DFL EMIF driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}