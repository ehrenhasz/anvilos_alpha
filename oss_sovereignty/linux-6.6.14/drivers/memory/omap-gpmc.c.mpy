{
  "module_name": "omap-gpmc.c",
  "hash_id": "59dccb0e8c821b973bfa967685625b43ca5228d0c4c51848713a98b6f2a76590",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memory/omap-gpmc.c",
  "human_readable_source": "\n \n#include <linux/cpu_pm.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/ioport.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/consumer.h>  \n#include <linux/gpio/machine.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/omap-gpmc.h>\n#include <linux/pm_runtime.h>\n#include <linux/sizes.h>\n\n#include <linux/platform_data/mtd-nand-omap2.h>\n\n#define\tDEVICE_NAME\t\t\"omap-gpmc\"\n\n \n#define GPMC_REVISION\t\t0x00\n#define GPMC_SYSCONFIG\t\t0x10\n#define GPMC_SYSSTATUS\t\t0x14\n#define GPMC_IRQSTATUS\t\t0x18\n#define GPMC_IRQENABLE\t\t0x1c\n#define GPMC_TIMEOUT_CONTROL\t0x40\n#define GPMC_ERR_ADDRESS\t0x44\n#define GPMC_ERR_TYPE\t\t0x48\n#define GPMC_CONFIG\t\t0x50\n#define GPMC_STATUS\t\t0x54\n#define GPMC_PREFETCH_CONFIG1\t0x1e0\n#define GPMC_PREFETCH_CONFIG2\t0x1e4\n#define GPMC_PREFETCH_CONTROL\t0x1ec\n#define GPMC_PREFETCH_STATUS\t0x1f0\n#define GPMC_ECC_CONFIG\t\t0x1f4\n#define GPMC_ECC_CONTROL\t0x1f8\n#define GPMC_ECC_SIZE_CONFIG\t0x1fc\n#define GPMC_ECC1_RESULT        0x200\n#define GPMC_ECC_BCH_RESULT_0   0x240    \n#define\tGPMC_ECC_BCH_RESULT_1\t0x244\t \n#define\tGPMC_ECC_BCH_RESULT_2\t0x248\t \n#define\tGPMC_ECC_BCH_RESULT_3\t0x24c\t \n#define\tGPMC_ECC_BCH_RESULT_4\t0x300\t \n#define\tGPMC_ECC_BCH_RESULT_5\t0x304\t \n#define\tGPMC_ECC_BCH_RESULT_6\t0x308\t \n\n \n#define GPMC_ECC_CTRL_ECCCLEAR\t\t0x100\n#define GPMC_ECC_CTRL_ECCDISABLE\t0x000\n#define GPMC_ECC_CTRL_ECCREG1\t\t0x001\n#define GPMC_ECC_CTRL_ECCREG2\t\t0x002\n#define GPMC_ECC_CTRL_ECCREG3\t\t0x003\n#define GPMC_ECC_CTRL_ECCREG4\t\t0x004\n#define GPMC_ECC_CTRL_ECCREG5\t\t0x005\n#define GPMC_ECC_CTRL_ECCREG6\t\t0x006\n#define GPMC_ECC_CTRL_ECCREG7\t\t0x007\n#define GPMC_ECC_CTRL_ECCREG8\t\t0x008\n#define GPMC_ECC_CTRL_ECCREG9\t\t0x009\n\n#define GPMC_CONFIG_LIMITEDADDRESS\t\tBIT(1)\n\n#define GPMC_STATUS_EMPTYWRITEBUFFERSTATUS\tBIT(0)\n\n#define\tGPMC_CONFIG2_CSEXTRADELAY\t\tBIT(7)\n#define\tGPMC_CONFIG3_ADVEXTRADELAY\t\tBIT(7)\n#define\tGPMC_CONFIG4_OEEXTRADELAY\t\tBIT(7)\n#define\tGPMC_CONFIG4_WEEXTRADELAY\t\tBIT(23)\n#define\tGPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN\tBIT(6)\n#define\tGPMC_CONFIG6_CYCLE2CYCLESAMECSEN\tBIT(7)\n\n#define GPMC_CS0_OFFSET\t\t0x60\n#define GPMC_CS_SIZE\t\t0x30\n#define\tGPMC_BCH_SIZE\t\t0x10\n\n \n#define GPMC_MEM_START\t\t0x1000000\n#define GPMC_MEM_END\t\t0x3FFFFFFF\n\n#define GPMC_CHUNK_SHIFT\t24\t\t \n#define GPMC_SECTION_SHIFT\t28\t\t \n\n#define CS_NUM_SHIFT\t\t24\n#define ENABLE_PREFETCH\t\t(0x1 << 7)\n#define DMA_MPU_MODE\t\t2\n\n#define\tGPMC_REVISION_MAJOR(l)\t\t(((l) >> 4) & 0xf)\n#define\tGPMC_REVISION_MINOR(l)\t\t((l) & 0xf)\n\n#define\tGPMC_HAS_WR_ACCESS\t\t0x1\n#define\tGPMC_HAS_WR_DATA_MUX_BUS\t0x2\n#define\tGPMC_HAS_MUX_AAD\t\t0x4\n\n#define GPMC_NR_WAITPINS\t\t4\n\n#define GPMC_CS_CONFIG1\t\t0x00\n#define GPMC_CS_CONFIG2\t\t0x04\n#define GPMC_CS_CONFIG3\t\t0x08\n#define GPMC_CS_CONFIG4\t\t0x0c\n#define GPMC_CS_CONFIG5\t\t0x10\n#define GPMC_CS_CONFIG6\t\t0x14\n#define GPMC_CS_CONFIG7\t\t0x18\n#define GPMC_CS_NAND_COMMAND\t0x1c\n#define GPMC_CS_NAND_ADDRESS\t0x20\n#define GPMC_CS_NAND_DATA\t0x24\n\n \n#define GPMC_CONFIG_RDY_BSY\t0x00000001\n#define GPMC_CONFIG_DEV_SIZE\t0x00000002\n#define GPMC_CONFIG_DEV_TYPE\t0x00000003\n\n#define GPMC_CONFIG_WAITPINPOLARITY(pin)\t(BIT(pin) << 8)\n#define GPMC_CONFIG1_WRAPBURST_SUPP     (1 << 31)\n#define GPMC_CONFIG1_READMULTIPLE_SUPP  (1 << 30)\n#define GPMC_CONFIG1_READTYPE_ASYNC     (0 << 29)\n#define GPMC_CONFIG1_READTYPE_SYNC      (1 << 29)\n#define GPMC_CONFIG1_WRITEMULTIPLE_SUPP (1 << 28)\n#define GPMC_CONFIG1_WRITETYPE_ASYNC    (0 << 27)\n#define GPMC_CONFIG1_WRITETYPE_SYNC     (1 << 27)\n#define GPMC_CONFIG1_CLKACTIVATIONTIME(val) (((val) & 3) << 25)\n \n#define GPMC_CONFIG1_CLKACTIVATIONTIME_MAX 2\n#define GPMC_CONFIG1_PAGE_LEN(val)      (((val) & 3) << 23)\n \n#define GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_MAX 2\n#define GPMC_CONFIG1_WAIT_READ_MON      (1 << 22)\n#define GPMC_CONFIG1_WAIT_WRITE_MON     (1 << 21)\n#define GPMC_CONFIG1_WAIT_MON_TIME(val) (((val) & 3) << 18)\n \n#define GPMC_CONFIG1_WAITMONITORINGTIME_MAX  2\n#define GPMC_CONFIG1_WAIT_PIN_SEL(val)  (((val) & 3) << 16)\n#define GPMC_CONFIG1_DEVICESIZE(val)    (((val) & 3) << 12)\n#define GPMC_CONFIG1_DEVICESIZE_16      GPMC_CONFIG1_DEVICESIZE(1)\n \n#define GPMC_CONFIG1_DEVICESIZE_MAX     1\n#define GPMC_CONFIG1_DEVICETYPE(val)    (((val) & 3) << 10)\n#define GPMC_CONFIG1_DEVICETYPE_NOR     GPMC_CONFIG1_DEVICETYPE(0)\n#define GPMC_CONFIG1_MUXTYPE(val)       (((val) & 3) << 8)\n#define GPMC_CONFIG1_TIME_PARA_GRAN     (1 << 4)\n#define GPMC_CONFIG1_FCLK_DIV(val)      ((val) & 3)\n#define GPMC_CONFIG1_FCLK_DIV2          (GPMC_CONFIG1_FCLK_DIV(1))\n#define GPMC_CONFIG1_FCLK_DIV3          (GPMC_CONFIG1_FCLK_DIV(2))\n#define GPMC_CONFIG1_FCLK_DIV4          (GPMC_CONFIG1_FCLK_DIV(3))\n#define GPMC_CONFIG7_CSVALID\t\t(1 << 6)\n\n#define GPMC_CONFIG7_BASEADDRESS_MASK\t0x3f\n#define GPMC_CONFIG7_CSVALID_MASK\tBIT(6)\n#define GPMC_CONFIG7_MASKADDRESS_OFFSET\t8\n#define GPMC_CONFIG7_MASKADDRESS_MASK\t(0xf << GPMC_CONFIG7_MASKADDRESS_OFFSET)\n \n#define GPMC_CONFIG7_MASK\t\t(GPMC_CONFIG7_BASEADDRESS_MASK | \\\n\t\t\t\t\t GPMC_CONFIG7_CSVALID_MASK |     \\\n\t\t\t\t\t GPMC_CONFIG7_MASKADDRESS_MASK)\n\n#define GPMC_DEVICETYPE_NOR\t\t0\n#define GPMC_DEVICETYPE_NAND\t\t2\n#define GPMC_CONFIG_WRITEPROTECT\t0x00000010\n#define WR_RD_PIN_MONITORING\t\t0x00600000\n\n \n#define GPMC_ECC_READ\t\t0  \n#define GPMC_ECC_WRITE\t\t1  \n#define GPMC_ECC_READSYN\t2  \n\n#define\tGPMC_NR_NAND_IRQS\t2  \n\nenum gpmc_clk_domain {\n\tGPMC_CD_FCLK,\n\tGPMC_CD_CLK\n};\n\nstruct gpmc_cs_data {\n\tconst char *name;\n\n#define GPMC_CS_RESERVED\t(1 << 0)\n\tu32 flags;\n\n\tstruct resource mem;\n};\n\n \nstruct gpmc_cs_config {\n\tu32 config1;\n\tu32 config2;\n\tu32 config3;\n\tu32 config4;\n\tu32 config5;\n\tu32 config6;\n\tu32 config7;\n\tint is_valid;\n};\n\n \nstruct omap3_gpmc_regs {\n\tu32 sysconfig;\n\tu32 irqenable;\n\tu32 timeout_ctrl;\n\tu32 config;\n\tu32 prefetch_config1;\n\tu32 prefetch_config2;\n\tu32 prefetch_control;\n\tstruct gpmc_cs_config cs_context[GPMC_CS_NUM];\n};\n\nstruct gpmc_waitpin {\n\tu32 pin;\n\tu32 polarity;\n\tstruct gpio_desc *desc;\n};\n\nstruct gpmc_device {\n\tstruct device *dev;\n\tint irq;\n\tstruct irq_chip irq_chip;\n\tstruct gpio_chip gpio_chip;\n\tstruct notifier_block nb;\n\tstruct omap3_gpmc_regs context;\n\tstruct gpmc_waitpin *waitpins;\n\tint nirqs;\n\tunsigned int is_suspended:1;\n\tstruct resource *data;\n};\n\nstatic struct irq_domain *gpmc_irq_domain;\n\nstatic struct resource\tgpmc_mem_root;\nstatic struct gpmc_cs_data gpmc_cs[GPMC_CS_NUM];\nstatic DEFINE_SPINLOCK(gpmc_mem_lock);\n \nstatic unsigned int gpmc_cs_num = GPMC_CS_NUM;\nstatic unsigned int gpmc_nr_waitpins;\nstatic unsigned int gpmc_capability;\nstatic void __iomem *gpmc_base;\n\nstatic struct clk *gpmc_l3_clk;\n\nstatic irqreturn_t gpmc_handle_irq(int irq, void *dev);\n\nstatic void gpmc_write_reg(int idx, u32 val)\n{\n\twritel_relaxed(val, gpmc_base + idx);\n}\n\nstatic u32 gpmc_read_reg(int idx)\n{\n\treturn readl_relaxed(gpmc_base + idx);\n}\n\nvoid gpmc_cs_write_reg(int cs, int idx, u32 val)\n{\n\tvoid __iomem *reg_addr;\n\n\treg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\n\twritel_relaxed(val, reg_addr);\n}\n\nstatic u32 gpmc_cs_read_reg(int cs, int idx)\n{\n\tvoid __iomem *reg_addr;\n\n\treg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\n\treturn readl_relaxed(reg_addr);\n}\n\n \nstatic unsigned long gpmc_get_fclk_period(void)\n{\n\tunsigned long rate = clk_get_rate(gpmc_l3_clk);\n\n\trate /= 1000;\n\trate = 1000000000 / rate;\t \n\n\treturn rate;\n}\n\n \nstatic unsigned long gpmc_get_clk_period(int cs, enum gpmc_clk_domain cd)\n{\n\tunsigned long tick_ps = gpmc_get_fclk_period();\n\tu32 l;\n\tint div;\n\n\tswitch (cd) {\n\tcase GPMC_CD_CLK:\n\t\t \n\t\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\n\t\tdiv = (l & 0x03) + 1;\n\t\t \n\t\ttick_ps *= div;\n\t\tbreak;\n\tcase GPMC_CD_FCLK:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn tick_ps;\n}\n\nstatic unsigned int gpmc_ns_to_clk_ticks(unsigned int time_ns, int cs,\n\t\t\t\t\t enum gpmc_clk_domain cd)\n{\n\tunsigned long tick_ps;\n\n\t \n\ttick_ps = gpmc_get_clk_period(cs, cd);\n\n\treturn (time_ns * 1000 + tick_ps - 1) / tick_ps;\n}\n\nstatic unsigned int gpmc_ns_to_ticks(unsigned int time_ns)\n{\n\treturn gpmc_ns_to_clk_ticks(time_ns,   0, GPMC_CD_FCLK);\n}\n\nstatic unsigned int gpmc_ps_to_ticks(unsigned int time_ps)\n{\n\tunsigned long tick_ps;\n\n\t \n\ttick_ps = gpmc_get_fclk_period();\n\n\treturn (time_ps + tick_ps - 1) / tick_ps;\n}\n\nstatic unsigned int gpmc_clk_ticks_to_ns(unsigned int ticks, int cs,\n\t\t\t\t\t enum gpmc_clk_domain cd)\n{\n\treturn ticks * gpmc_get_clk_period(cs, cd) / 1000;\n}\n\nunsigned int gpmc_ticks_to_ns(unsigned int ticks)\n{\n\treturn gpmc_clk_ticks_to_ns(ticks,   0, GPMC_CD_FCLK);\n}\n\nstatic unsigned int gpmc_ticks_to_ps(unsigned int ticks)\n{\n\treturn ticks * gpmc_get_fclk_period();\n}\n\nstatic unsigned int gpmc_round_ps_to_ticks(unsigned int time_ps)\n{\n\tunsigned long ticks = gpmc_ps_to_ticks(time_ps);\n\n\treturn ticks * gpmc_get_fclk_period();\n}\n\nstatic inline void gpmc_cs_modify_reg(int cs, int reg, u32 mask, bool value)\n{\n\tu32 l;\n\n\tl = gpmc_cs_read_reg(cs, reg);\n\tif (value)\n\t\tl |= mask;\n\telse\n\t\tl &= ~mask;\n\tgpmc_cs_write_reg(cs, reg, l);\n}\n\nstatic void gpmc_cs_bool_timings(int cs, const struct gpmc_bool_timings *p)\n{\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG1,\n\t\t\t   GPMC_CONFIG1_TIME_PARA_GRAN,\n\t\t\t   p->time_para_granularity);\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG2,\n\t\t\t   GPMC_CONFIG2_CSEXTRADELAY, p->cs_extra_delay);\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG3,\n\t\t\t   GPMC_CONFIG3_ADVEXTRADELAY, p->adv_extra_delay);\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG4,\n\t\t\t   GPMC_CONFIG4_OEEXTRADELAY, p->oe_extra_delay);\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG4,\n\t\t\t   GPMC_CONFIG4_WEEXTRADELAY, p->we_extra_delay);\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG6,\n\t\t\t   GPMC_CONFIG6_CYCLE2CYCLESAMECSEN,\n\t\t\t   p->cycle2cyclesamecsen);\n\tgpmc_cs_modify_reg(cs, GPMC_CS_CONFIG6,\n\t\t\t   GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN,\n\t\t\t   p->cycle2cyclediffcsen);\n}\n\n#ifdef CONFIG_OMAP_GPMC_DEBUG\n \nstatic int get_gpmc_timing_reg(\n\t \n\tint cs, int reg, int st_bit, int end_bit, int max,\n\tconst char *name, const enum gpmc_clk_domain cd,\n\t \n\tint shift,\n\t \n\tbool raw, bool noval)\n{\n\tu32 l;\n\tint nr_bits;\n\tint mask;\n\tbool invalid;\n\n\tl = gpmc_cs_read_reg(cs, reg);\n\tnr_bits = end_bit - st_bit + 1;\n\tmask = (1 << nr_bits) - 1;\n\tl = (l >> st_bit) & mask;\n\tif (!max)\n\t\tmax = mask;\n\tinvalid = l > max;\n\tif (shift)\n\t\tl = (shift << l);\n\tif (noval && (l == 0))\n\t\treturn 0;\n\tif (!raw) {\n\t\t \n\t\tunsigned int time_ns;\n\t\tunsigned int time_ns_min = 0;\n\n\t\tif (l)\n\t\t\ttime_ns_min = gpmc_clk_ticks_to_ns(l - 1, cs, cd) + 1;\n\t\ttime_ns = gpmc_clk_ticks_to_ns(l, cs, cd);\n\t\tpr_info(\"gpmc,%s = <%u>; /* %u ns - %u ns; %i ticks%s*/\\n\",\n\t\t\tname, time_ns, time_ns_min, time_ns, l,\n\t\t\tinvalid ? \"; invalid \" : \" \");\n\t} else {\n\t\t \n\t\tpr_info(\"gpmc,%s = <%u>;%s\\n\", name, l,\n\t\t\tinvalid ? \" /* invalid */\" : \"\");\n\t}\n\n\treturn l;\n}\n\n#define GPMC_PRINT_CONFIG(cs, config) \\\n\tpr_info(\"cs%i %s: 0x%08x\\n\", cs, #config, \\\n\t\tgpmc_cs_read_reg(cs, config))\n#define GPMC_GET_RAW(reg, st, end, field) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), 0, field, GPMC_CD_FCLK, 0, 1, 0)\n#define GPMC_GET_RAW_MAX(reg, st, end, max, field) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), (max), field, GPMC_CD_FCLK, 0, 1, 0)\n#define GPMC_GET_RAW_BOOL(reg, st, end, field) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), 0, field, GPMC_CD_FCLK, 0, 1, 1)\n#define GPMC_GET_RAW_SHIFT_MAX(reg, st, end, shift, max, field) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), (max), field, GPMC_CD_FCLK, (shift), 1, 1)\n#define GPMC_GET_TICKS(reg, st, end, field) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), 0, field, GPMC_CD_FCLK, 0, 0, 0)\n#define GPMC_GET_TICKS_CD(reg, st, end, field, cd) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), 0, field, (cd), 0, 0, 0)\n#define GPMC_GET_TICKS_CD_MAX(reg, st, end, max, field, cd) \\\n\tget_gpmc_timing_reg(cs, (reg), (st), (end), (max), field, (cd), 0, 0, 0)\n\nstatic void gpmc_show_regs(int cs, const char *desc)\n{\n\tpr_info(\"gpmc cs%i %s:\\n\", cs, desc);\n\tGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG1);\n\tGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG2);\n\tGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG3);\n\tGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG4);\n\tGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG5);\n\tGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG6);\n}\n\n \nstatic void gpmc_cs_show_timings(int cs, const char *desc)\n{\n\tgpmc_show_regs(cs, desc);\n\n\tpr_info(\"gpmc cs%i access configuration:\\n\", cs);\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1,  4,  4, \"time-para-granularity\");\n\tGPMC_GET_RAW(GPMC_CS_CONFIG1,  8,  9, \"mux-add-data\");\n\tGPMC_GET_RAW_SHIFT_MAX(GPMC_CS_CONFIG1, 12, 13, 1,\n\t\t\t       GPMC_CONFIG1_DEVICESIZE_MAX, \"device-width\");\n\tGPMC_GET_RAW(GPMC_CS_CONFIG1, 16, 17, \"wait-pin\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 21, 21, \"wait-on-write\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 22, 22, \"wait-on-read\");\n\tGPMC_GET_RAW_SHIFT_MAX(GPMC_CS_CONFIG1, 23, 24, 4,\n\t\t\t       GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_MAX,\n\t\t\t       \"burst-length\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 27, 27, \"sync-write\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 28, 28, \"burst-write\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 29, 29, \"gpmc,sync-read\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 30, 30, \"burst-read\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 31, 31, \"burst-wrap\");\n\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG2,  7,  7, \"cs-extra-delay\");\n\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG3,  7,  7, \"adv-extra-delay\");\n\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG4, 23, 23, \"we-extra-delay\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG4,  7,  7, \"oe-extra-delay\");\n\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG6,  7,  7, \"cycle2cycle-samecsen\");\n\tGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG6,  6,  6, \"cycle2cycle-diffcsen\");\n\n\tpr_info(\"gpmc cs%i timings configuration:\\n\", cs);\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG2,  0,  3, \"cs-on-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG2,  8, 12, \"cs-rd-off-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG2, 16, 20, \"cs-wr-off-ns\");\n\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG3,  0,  3, \"adv-on-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG3,  8, 12, \"adv-rd-off-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG3, 16, 20, \"adv-wr-off-ns\");\n\tif (gpmc_capability & GPMC_HAS_MUX_AAD) {\n\t\tGPMC_GET_TICKS(GPMC_CS_CONFIG3, 4, 6, \"adv-aad-mux-on-ns\");\n\t\tGPMC_GET_TICKS(GPMC_CS_CONFIG3, 24, 26,\n\t\t\t\t\"adv-aad-mux-rd-off-ns\");\n\t\tGPMC_GET_TICKS(GPMC_CS_CONFIG3, 28, 30,\n\t\t\t\t\"adv-aad-mux-wr-off-ns\");\n\t}\n\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG4,  0,  3, \"oe-on-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG4,  8, 12, \"oe-off-ns\");\n\tif (gpmc_capability & GPMC_HAS_MUX_AAD) {\n\t\tGPMC_GET_TICKS(GPMC_CS_CONFIG4,  4,  6, \"oe-aad-mux-on-ns\");\n\t\tGPMC_GET_TICKS(GPMC_CS_CONFIG4, 13, 15, \"oe-aad-mux-off-ns\");\n\t}\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG4, 16, 19, \"we-on-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG4, 24, 28, \"we-off-ns\");\n\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG5,  0,  4, \"rd-cycle-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG5,  8, 12, \"wr-cycle-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG5, 16, 20, \"access-ns\");\n\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG5, 24, 27, \"page-burst-access-ns\");\n\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG6, 0, 3, \"bus-turnaround-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG6, 8, 11, \"cycle2cycle-delay-ns\");\n\n\tGPMC_GET_TICKS_CD_MAX(GPMC_CS_CONFIG1, 18, 19,\n\t\t\t      GPMC_CONFIG1_WAITMONITORINGTIME_MAX,\n\t\t\t      \"wait-monitoring-ns\", GPMC_CD_CLK);\n\tGPMC_GET_TICKS_CD_MAX(GPMC_CS_CONFIG1, 25, 26,\n\t\t\t      GPMC_CONFIG1_CLKACTIVATIONTIME_MAX,\n\t\t\t      \"clk-activation-ns\", GPMC_CD_FCLK);\n\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG6, 16, 19, \"wr-data-mux-bus-ns\");\n\tGPMC_GET_TICKS(GPMC_CS_CONFIG6, 24, 28, \"wr-access-ns\");\n}\n#else\nstatic inline void gpmc_cs_show_timings(int cs, const char *desc)\n{\n}\n#endif\n\n \nstatic int set_gpmc_timing_reg(int cs, int reg, int st_bit, int end_bit, int max,\n\t\t\t       int time, enum gpmc_clk_domain cd, const char *name)\n{\n\tu32 l;\n\tint ticks, mask, nr_bits;\n\n\tif (time == 0)\n\t\tticks = 0;\n\telse\n\t\tticks = gpmc_ns_to_clk_ticks(time, cs, cd);\n\tnr_bits = end_bit - st_bit + 1;\n\tmask = (1 << nr_bits) - 1;\n\n\tif (!max)\n\t\tmax = mask;\n\n\tif (ticks > max) {\n\t\tpr_err(\"%s: GPMC CS%d: %s %d ns, %d ticks > %d ticks\\n\",\n\t\t       __func__, cs, name, time, ticks, max);\n\n\t\treturn -1;\n\t}\n\n\tl = gpmc_cs_read_reg(cs, reg);\n#ifdef CONFIG_OMAP_GPMC_DEBUG\n\tpr_info(\"GPMC CS%d: %-17s: %3d ticks, %3lu ns (was %3i ticks) %3d ns\\n\",\n\t\tcs, name, ticks, gpmc_get_clk_period(cs, cd) * ticks / 1000,\n\t\t\t(l >> st_bit) & mask, time);\n#endif\n\tl &= ~(mask << st_bit);\n\tl |= ticks << st_bit;\n\tgpmc_cs_write_reg(cs, reg, l);\n\n\treturn 0;\n}\n\n \nstatic int gpmc_calc_waitmonitoring_divider(unsigned int wait_monitoring)\n{\n\tint div = gpmc_ns_to_ticks(wait_monitoring);\n\n\tdiv += GPMC_CONFIG1_WAITMONITORINGTIME_MAX - 1;\n\tdiv /= GPMC_CONFIG1_WAITMONITORINGTIME_MAX;\n\n\tif (div > 4)\n\t\treturn -1;\n\tif (div <= 0)\n\t\tdiv = 1;\n\n\treturn div;\n}\n\n \nint gpmc_calc_divider(unsigned int sync_clk)\n{\n\tint div = gpmc_ps_to_ticks(sync_clk);\n\n\tif (div > 4)\n\t\treturn -1;\n\tif (div <= 0)\n\t\tdiv = 1;\n\n\treturn div;\n}\n\n \nint gpmc_cs_set_timings(int cs, const struct gpmc_timings *t,\n\t\t\tconst struct gpmc_settings *s)\n{\n\tint div, ret;\n\tu32 l;\n\n\tdiv = gpmc_calc_divider(t->sync_clk);\n\tif (div < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!s->sync_read && !s->sync_write &&\n\t    (s->wait_on_read || s->wait_on_write)\n\t   ) {\n\t\tdiv = gpmc_calc_waitmonitoring_divider(t->wait_monitoring);\n\t\tif (div < 0) {\n\t\t\tpr_err(\"%s: waitmonitoringtime %3d ns too large for greatest gpmcfclkdivider.\\n\",\n\t\t\t       __func__,\n\t\t\t       t->wait_monitoring\n\t\t\t       );\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tret = 0;\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG2, 0, 3, 0, t->cs_on,\n\t\t\t\t   GPMC_CD_FCLK, \"cs_on\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG2, 8, 12, 0, t->cs_rd_off,\n\t\t\t\t   GPMC_CD_FCLK, \"cs_rd_off\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG2, 16, 20, 0, t->cs_wr_off,\n\t\t\t\t   GPMC_CD_FCLK, \"cs_wr_off\");\n\tif (ret)\n\t\treturn -ENXIO;\n\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG3, 0, 3, 0, t->adv_on,\n\t\t\t\t   GPMC_CD_FCLK, \"adv_on\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG3, 8, 12, 0, t->adv_rd_off,\n\t\t\t\t   GPMC_CD_FCLK, \"adv_rd_off\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG3, 16, 20, 0, t->adv_wr_off,\n\t\t\t\t   GPMC_CD_FCLK, \"adv_wr_off\");\n\tif (ret)\n\t\treturn -ENXIO;\n\n\tif (gpmc_capability & GPMC_HAS_MUX_AAD) {\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG3, 4, 6, 0,\n\t\t\t\t\t   t->adv_aad_mux_on, GPMC_CD_FCLK,\n\t\t\t\t\t   \"adv_aad_mux_on\");\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG3, 24, 26, 0,\n\t\t\t\t\t   t->adv_aad_mux_rd_off, GPMC_CD_FCLK,\n\t\t\t\t\t   \"adv_aad_mux_rd_off\");\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG3, 28, 30, 0,\n\t\t\t\t\t   t->adv_aad_mux_wr_off, GPMC_CD_FCLK,\n\t\t\t\t\t   \"adv_aad_mux_wr_off\");\n\t\tif (ret)\n\t\t\treturn -ENXIO;\n\t}\n\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG4, 0, 3, 0, t->oe_on,\n\t\t\t\t   GPMC_CD_FCLK, \"oe_on\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG4, 8, 12, 0, t->oe_off,\n\t\t\t\t   GPMC_CD_FCLK, \"oe_off\");\n\tif (gpmc_capability & GPMC_HAS_MUX_AAD) {\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG4, 4, 6, 0,\n\t\t\t\t\t   t->oe_aad_mux_on, GPMC_CD_FCLK,\n\t\t\t\t\t   \"oe_aad_mux_on\");\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG4, 13, 15, 0,\n\t\t\t\t\t   t->oe_aad_mux_off, GPMC_CD_FCLK,\n\t\t\t\t\t   \"oe_aad_mux_off\");\n\t}\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG4, 16, 19, 0, t->we_on,\n\t\t\t\t   GPMC_CD_FCLK, \"we_on\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG4, 24, 28, 0, t->we_off,\n\t\t\t\t   GPMC_CD_FCLK, \"we_off\");\n\tif (ret)\n\t\treturn -ENXIO;\n\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG5, 0, 4, 0, t->rd_cycle,\n\t\t\t\t   GPMC_CD_FCLK, \"rd_cycle\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG5, 8, 12, 0, t->wr_cycle,\n\t\t\t\t   GPMC_CD_FCLK, \"wr_cycle\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG5, 16, 20, 0, t->access,\n\t\t\t\t   GPMC_CD_FCLK, \"access\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG5, 24, 27, 0,\n\t\t\t\t   t->page_burst_access, GPMC_CD_FCLK,\n\t\t\t\t   \"page_burst_access\");\n\tif (ret)\n\t\treturn -ENXIO;\n\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG6, 0, 3, 0,\n\t\t\t\t   t->bus_turnaround, GPMC_CD_FCLK,\n\t\t\t\t   \"bus_turnaround\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG6, 8, 11, 0,\n\t\t\t\t   t->cycle2cycle_delay, GPMC_CD_FCLK,\n\t\t\t\t   \"cycle2cycle_delay\");\n\tif (ret)\n\t\treturn -ENXIO;\n\n\tif (gpmc_capability & GPMC_HAS_WR_DATA_MUX_BUS) {\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG6, 16, 19, 0,\n\t\t\t\t\t   t->wr_data_mux_bus, GPMC_CD_FCLK,\n\t\t\t\t\t   \"wr_data_mux_bus\");\n\t\tif (ret)\n\t\t\treturn -ENXIO;\n\t}\n\tif (gpmc_capability & GPMC_HAS_WR_ACCESS) {\n\t\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG6, 24, 28, 0,\n\t\t\t\t\t   t->wr_access, GPMC_CD_FCLK,\n\t\t\t\t\t   \"wr_access\");\n\t\tif (ret)\n\t\t\treturn -ENXIO;\n\t}\n\n\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\n\tl &= ~0x03;\n\tl |= (div - 1);\n\tgpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, l);\n\n\tret = 0;\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG1, 18, 19,\n\t\t\t\t   GPMC_CONFIG1_WAITMONITORINGTIME_MAX,\n\t\t\t\t   t->wait_monitoring, GPMC_CD_CLK,\n\t\t\t\t   \"wait_monitoring\");\n\tret |= set_gpmc_timing_reg(cs, GPMC_CS_CONFIG1, 25, 26,\n\t\t\t\t   GPMC_CONFIG1_CLKACTIVATIONTIME_MAX,\n\t\t\t\t   t->clk_activation, GPMC_CD_FCLK,\n\t\t\t\t   \"clk_activation\");\n\tif (ret)\n\t\treturn -ENXIO;\n\n#ifdef CONFIG_OMAP_GPMC_DEBUG\n\tpr_info(\"GPMC CS%d CLK period is %lu ns (div %d)\\n\",\n\t\t\tcs, (div * gpmc_get_fclk_period()) / 1000, div);\n#endif\n\n\tgpmc_cs_bool_timings(cs, &t->bool_timings);\n\tgpmc_cs_show_timings(cs, \"after gpmc_cs_set_timings\");\n\n\treturn 0;\n}\n\nstatic int gpmc_cs_set_memconf(int cs, u32 base, u32 size)\n{\n\tu32 l;\n\tu32 mask;\n\n\t \n\tif (base & (size - 1))\n\t\treturn -EINVAL;\n\n\tbase >>= GPMC_CHUNK_SHIFT;\n\tmask = (1 << GPMC_SECTION_SHIFT) - size;\n\tmask >>= GPMC_CHUNK_SHIFT;\n\tmask <<= GPMC_CONFIG7_MASKADDRESS_OFFSET;\n\n\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\n\tl &= ~GPMC_CONFIG7_MASK;\n\tl |= base & GPMC_CONFIG7_BASEADDRESS_MASK;\n\tl |= mask & GPMC_CONFIG7_MASKADDRESS_MASK;\n\tl |= GPMC_CONFIG7_CSVALID;\n\tgpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\n\n\treturn 0;\n}\n\nstatic void gpmc_cs_enable_mem(int cs)\n{\n\tu32 l;\n\n\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\n\tl |= GPMC_CONFIG7_CSVALID;\n\tgpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\n}\n\nstatic void gpmc_cs_disable_mem(int cs)\n{\n\tu32 l;\n\n\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\n\tl &= ~GPMC_CONFIG7_CSVALID;\n\tgpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\n}\n\nstatic void gpmc_cs_get_memconf(int cs, u32 *base, u32 *size)\n{\n\tu32 l;\n\tu32 mask;\n\n\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\n\t*base = (l & 0x3f) << GPMC_CHUNK_SHIFT;\n\tmask = (l >> 8) & 0x0f;\n\t*size = (1 << GPMC_SECTION_SHIFT) - (mask << GPMC_CHUNK_SHIFT);\n}\n\nstatic int gpmc_cs_mem_enabled(int cs)\n{\n\tu32 l;\n\n\tl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\n\treturn l & GPMC_CONFIG7_CSVALID;\n}\n\nstatic void gpmc_cs_set_reserved(int cs, int reserved)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\n\tgpmc->flags |= GPMC_CS_RESERVED;\n}\n\nstatic bool gpmc_cs_reserved(int cs)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\n\treturn gpmc->flags & GPMC_CS_RESERVED;\n}\n\nstatic unsigned long gpmc_mem_align(unsigned long size)\n{\n\tint order;\n\n\tsize = (size - 1) >> (GPMC_CHUNK_SHIFT - 1);\n\torder = GPMC_CHUNK_SHIFT - 1;\n\tdo {\n\t\tsize >>= 1;\n\t\torder++;\n\t} while (size);\n\tsize = 1 << order;\n\treturn size;\n}\n\nstatic int gpmc_cs_insert_mem(int cs, unsigned long base, unsigned long size)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\tstruct resource *res = &gpmc->mem;\n\tint r;\n\n\tsize = gpmc_mem_align(size);\n\tspin_lock(&gpmc_mem_lock);\n\tres->start = base;\n\tres->end = base + size - 1;\n\tr = request_resource(&gpmc_mem_root, res);\n\tspin_unlock(&gpmc_mem_lock);\n\n\treturn r;\n}\n\nstatic int gpmc_cs_delete_mem(int cs)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\tstruct resource *res = &gpmc->mem;\n\tint r;\n\n\tspin_lock(&gpmc_mem_lock);\n\tr = release_resource(res);\n\tres->start = 0;\n\tres->end = 0;\n\tspin_unlock(&gpmc_mem_lock);\n\n\treturn r;\n}\n\nint gpmc_cs_request(int cs, unsigned long size, unsigned long *base)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\tstruct resource *res = &gpmc->mem;\n\tint r = -1;\n\n\tif (cs >= gpmc_cs_num) {\n\t\tpr_err(\"%s: requested chip-select is disabled\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tsize = gpmc_mem_align(size);\n\tif (size > (1 << GPMC_SECTION_SHIFT))\n\t\treturn -ENOMEM;\n\n\tspin_lock(&gpmc_mem_lock);\n\tif (gpmc_cs_reserved(cs)) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (gpmc_cs_mem_enabled(cs))\n\t\tr = adjust_resource(res, res->start & ~(size - 1), size);\n\tif (r < 0)\n\t\tr = allocate_resource(&gpmc_mem_root, res, size, 0, ~0,\n\t\t\t\t      size, NULL, NULL);\n\tif (r < 0)\n\t\tgoto out;\n\n\t \n\tgpmc_cs_disable_mem(cs);\n\n\tr = gpmc_cs_set_memconf(cs, res->start, resource_size(res));\n\tif (r < 0) {\n\t\trelease_resource(res);\n\t\tgoto out;\n\t}\n\n\t \n\tgpmc_cs_enable_mem(cs);\n\t*base = res->start;\n\tgpmc_cs_set_reserved(cs, 1);\nout:\n\tspin_unlock(&gpmc_mem_lock);\n\treturn r;\n}\nEXPORT_SYMBOL(gpmc_cs_request);\n\nvoid gpmc_cs_free(int cs)\n{\n\tstruct gpmc_cs_data *gpmc;\n\tstruct resource *res;\n\n\tspin_lock(&gpmc_mem_lock);\n\tif (cs >= gpmc_cs_num || cs < 0 || !gpmc_cs_reserved(cs)) {\n\t\tWARN(1, \"Trying to free non-reserved GPMC CS%d\\n\", cs);\n\t\tspin_unlock(&gpmc_mem_lock);\n\t\treturn;\n\t}\n\tgpmc = &gpmc_cs[cs];\n\tres = &gpmc->mem;\n\n\tgpmc_cs_disable_mem(cs);\n\tif (res->flags)\n\t\trelease_resource(res);\n\tgpmc_cs_set_reserved(cs, 0);\n\tspin_unlock(&gpmc_mem_lock);\n}\nEXPORT_SYMBOL(gpmc_cs_free);\n\nstatic bool gpmc_is_valid_waitpin(u32 waitpin)\n{\n\treturn waitpin < gpmc_nr_waitpins;\n}\n\nstatic int gpmc_alloc_waitpin(struct gpmc_device *gpmc,\n\t\t\t      struct gpmc_settings *p)\n{\n\tint ret;\n\tstruct gpmc_waitpin *waitpin;\n\tstruct gpio_desc *waitpin_desc;\n\n\tif (!gpmc_is_valid_waitpin(p->wait_pin))\n\t\treturn -EINVAL;\n\n\twaitpin = &gpmc->waitpins[p->wait_pin];\n\n\tif (!waitpin->desc) {\n\t\t \n\t\twaitpin_desc = gpiochip_request_own_desc(&gpmc->gpio_chip,\n\t\t\t\t\t\t\t p->wait_pin, \"WAITPIN\",\n\t\t\t\t\t\t\t GPIO_ACTIVE_HIGH,\n\t\t\t\t\t\t\t GPIOD_IN);\n\n\t\tret = PTR_ERR(waitpin_desc);\n\t\tif (IS_ERR(waitpin_desc) && ret != -EBUSY)\n\t\t\treturn ret;\n\n\t\t \n\t\twaitpin->desc = waitpin_desc;\n\t\twaitpin->pin = p->wait_pin;\n\t\twaitpin->polarity = p->wait_pin_polarity;\n\t} else {\n\t\t \n\t\tif (p->wait_pin_polarity != waitpin->polarity ||\n\t\t    p->wait_pin != waitpin->pin) {\n\t\t\tdev_err(gpmc->dev,\n\t\t\t\t\"shared-wait-pin: invalid configuration\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_info(gpmc->dev, \"shared wait-pin: %d\\n\", waitpin->pin);\n\t}\n\n\treturn 0;\n}\n\nstatic void gpmc_free_waitpin(struct gpmc_device *gpmc,\n\t\t\t      int wait_pin)\n{\n\tif (gpmc_is_valid_waitpin(wait_pin))\n\t\tgpiochip_free_own_desc(gpmc->waitpins[wait_pin].desc);\n}\n\n \nint gpmc_configure(int cmd, int wval)\n{\n\tu32 regval;\n\n\tswitch (cmd) {\n\tcase GPMC_CONFIG_WP:\n\t\tregval = gpmc_read_reg(GPMC_CONFIG);\n\t\tif (wval)\n\t\t\tregval &= ~GPMC_CONFIG_WRITEPROTECT;  \n\t\telse\n\t\t\tregval |= GPMC_CONFIG_WRITEPROTECT;   \n\t\tgpmc_write_reg(GPMC_CONFIG, regval);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: command not supported\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(gpmc_configure);\n\nstatic bool gpmc_nand_writebuffer_empty(void)\n{\n\tif (gpmc_read_reg(GPMC_STATUS) & GPMC_STATUS_EMPTYWRITEBUFFERSTATUS)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct gpmc_nand_ops nand_ops = {\n\t.nand_writebuffer_empty = gpmc_nand_writebuffer_empty,\n};\n\n \nstruct gpmc_nand_ops *gpmc_omap_get_nand_ops(struct gpmc_nand_regs *reg, int cs)\n{\n\tint i;\n\n\tif (cs >= gpmc_cs_num)\n\t\treturn NULL;\n\n\treg->gpmc_nand_command = gpmc_base + GPMC_CS0_OFFSET +\n\t\t\t\tGPMC_CS_NAND_COMMAND + GPMC_CS_SIZE * cs;\n\treg->gpmc_nand_address = gpmc_base + GPMC_CS0_OFFSET +\n\t\t\t\tGPMC_CS_NAND_ADDRESS + GPMC_CS_SIZE * cs;\n\treg->gpmc_nand_data = gpmc_base + GPMC_CS0_OFFSET +\n\t\t\t\tGPMC_CS_NAND_DATA + GPMC_CS_SIZE * cs;\n\treg->gpmc_prefetch_config1 = gpmc_base + GPMC_PREFETCH_CONFIG1;\n\treg->gpmc_prefetch_config2 = gpmc_base + GPMC_PREFETCH_CONFIG2;\n\treg->gpmc_prefetch_control = gpmc_base + GPMC_PREFETCH_CONTROL;\n\treg->gpmc_prefetch_status = gpmc_base + GPMC_PREFETCH_STATUS;\n\treg->gpmc_ecc_config = gpmc_base + GPMC_ECC_CONFIG;\n\treg->gpmc_ecc_control = gpmc_base + GPMC_ECC_CONTROL;\n\treg->gpmc_ecc_size_config = gpmc_base + GPMC_ECC_SIZE_CONFIG;\n\treg->gpmc_ecc1_result = gpmc_base + GPMC_ECC1_RESULT;\n\n\tfor (i = 0; i < GPMC_BCH_NUM_REMAINDER; i++) {\n\t\treg->gpmc_bch_result0[i] = gpmc_base + GPMC_ECC_BCH_RESULT_0 +\n\t\t\t\t\t   GPMC_BCH_SIZE * i;\n\t\treg->gpmc_bch_result1[i] = gpmc_base + GPMC_ECC_BCH_RESULT_1 +\n\t\t\t\t\t   GPMC_BCH_SIZE * i;\n\t\treg->gpmc_bch_result2[i] = gpmc_base + GPMC_ECC_BCH_RESULT_2 +\n\t\t\t\t\t   GPMC_BCH_SIZE * i;\n\t\treg->gpmc_bch_result3[i] = gpmc_base + GPMC_ECC_BCH_RESULT_3 +\n\t\t\t\t\t   GPMC_BCH_SIZE * i;\n\t\treg->gpmc_bch_result4[i] = gpmc_base + GPMC_ECC_BCH_RESULT_4 +\n\t\t\t\t\t   i * GPMC_BCH_SIZE;\n\t\treg->gpmc_bch_result5[i] = gpmc_base + GPMC_ECC_BCH_RESULT_5 +\n\t\t\t\t\t   i * GPMC_BCH_SIZE;\n\t\treg->gpmc_bch_result6[i] = gpmc_base + GPMC_ECC_BCH_RESULT_6 +\n\t\t\t\t\t   i * GPMC_BCH_SIZE;\n\t}\n\n\treturn &nand_ops;\n}\nEXPORT_SYMBOL_GPL(gpmc_omap_get_nand_ops);\n\nstatic void gpmc_omap_onenand_calc_sync_timings(struct gpmc_timings *t,\n\t\t\t\t\t\tstruct gpmc_settings *s,\n\t\t\t\t\t\tint freq, int latency)\n{\n\tstruct gpmc_device_timings dev_t;\n\tconst int t_cer  = 15;\n\tconst int t_avdp = 12;\n\tconst int t_cez  = 20;  \n\tconst int t_wpl  = 40;\n\tconst int t_wph  = 30;\n\tint min_gpmc_clk_period, t_ces, t_avds, t_avdh, t_ach, t_aavdh, t_rdyo;\n\n\tswitch (freq) {\n\tcase 104:\n\t\tmin_gpmc_clk_period = 9600;  \n\t\tt_ces   = 3;\n\t\tt_avds  = 4;\n\t\tt_avdh  = 2;\n\t\tt_ach   = 3;\n\t\tt_aavdh = 6;\n\t\tt_rdyo  = 6;\n\t\tbreak;\n\tcase 83:\n\t\tmin_gpmc_clk_period = 12000;  \n\t\tt_ces   = 5;\n\t\tt_avds  = 4;\n\t\tt_avdh  = 2;\n\t\tt_ach   = 6;\n\t\tt_aavdh = 6;\n\t\tt_rdyo  = 9;\n\t\tbreak;\n\tcase 66:\n\t\tmin_gpmc_clk_period = 15000;  \n\t\tt_ces   = 6;\n\t\tt_avds  = 5;\n\t\tt_avdh  = 2;\n\t\tt_ach   = 6;\n\t\tt_aavdh = 6;\n\t\tt_rdyo  = 11;\n\t\tbreak;\n\tdefault:\n\t\tmin_gpmc_clk_period = 18500;  \n\t\tt_ces   = 7;\n\t\tt_avds  = 7;\n\t\tt_avdh  = 7;\n\t\tt_ach   = 9;\n\t\tt_aavdh = 7;\n\t\tt_rdyo  = 15;\n\t\tbreak;\n\t}\n\n\t \n\tmemset(&dev_t, 0, sizeof(dev_t));\n\n\tif (!s->sync_write) {\n\t\tdev_t.t_avdp_w = max(t_avdp, t_cer) * 1000;\n\t\tdev_t.t_wpl = t_wpl * 1000;\n\t\tdev_t.t_wph = t_wph * 1000;\n\t\tdev_t.t_aavdh = t_aavdh * 1000;\n\t}\n\tdev_t.ce_xdelay = true;\n\tdev_t.avd_xdelay = true;\n\tdev_t.oe_xdelay = true;\n\tdev_t.we_xdelay = true;\n\tdev_t.clk = min_gpmc_clk_period;\n\tdev_t.t_bacc = dev_t.clk;\n\tdev_t.t_ces = t_ces * 1000;\n\tdev_t.t_avds = t_avds * 1000;\n\tdev_t.t_avdh = t_avdh * 1000;\n\tdev_t.t_ach = t_ach * 1000;\n\tdev_t.cyc_iaa = (latency + 1);\n\tdev_t.t_cez_r = t_cez * 1000;\n\tdev_t.t_cez_w = dev_t.t_cez_r;\n\tdev_t.cyc_aavdh_oe = 1;\n\tdev_t.t_rdyo = t_rdyo * 1000 + min_gpmc_clk_period;\n\n\tgpmc_calc_timings(t, s, &dev_t);\n}\n\nint gpmc_omap_onenand_set_timings(struct device *dev, int cs, int freq,\n\t\t\t\t  int latency,\n\t\t\t\t  struct gpmc_onenand_info *info)\n{\n\tint ret;\n\tstruct gpmc_timings gpmc_t;\n\tstruct gpmc_settings gpmc_s;\n\n\tgpmc_read_settings_dt(dev->of_node, &gpmc_s);\n\n\tinfo->sync_read = gpmc_s.sync_read;\n\tinfo->sync_write = gpmc_s.sync_write;\n\tinfo->burst_len = gpmc_s.burst_len;\n\n\tif (!gpmc_s.sync_read && !gpmc_s.sync_write)\n\t\treturn 0;\n\n\tgpmc_omap_onenand_calc_sync_timings(&gpmc_t, &gpmc_s, freq, latency);\n\n\tret = gpmc_cs_program_settings(cs, &gpmc_s);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn gpmc_cs_set_timings(cs, &gpmc_t, &gpmc_s);\n}\nEXPORT_SYMBOL_GPL(gpmc_omap_onenand_set_timings);\n\nint gpmc_get_client_irq(unsigned int irq_config)\n{\n\tif (!gpmc_irq_domain) {\n\t\tpr_warn(\"%s called before GPMC IRQ domain available\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\t \n\tif (irq_config >= GPMC_NR_NAND_IRQS)\n\t\treturn 0;\n\n\treturn irq_create_mapping(gpmc_irq_domain, irq_config);\n}\n\nstatic int gpmc_irq_endis(unsigned long hwirq, bool endis)\n{\n\tu32 regval;\n\n\t \n\tif (hwirq >= GPMC_NR_NAND_IRQS)\n\t\thwirq += 8 - GPMC_NR_NAND_IRQS;\n\n\tregval = gpmc_read_reg(GPMC_IRQENABLE);\n\tif (endis)\n\t\tregval |= BIT(hwirq);\n\telse\n\t\tregval &= ~BIT(hwirq);\n\tgpmc_write_reg(GPMC_IRQENABLE, regval);\n\n\treturn 0;\n}\n\nstatic void gpmc_irq_disable(struct irq_data *p)\n{\n\tgpmc_irq_endis(p->hwirq, false);\n}\n\nstatic void gpmc_irq_enable(struct irq_data *p)\n{\n\tgpmc_irq_endis(p->hwirq, true);\n}\n\nstatic void gpmc_irq_mask(struct irq_data *d)\n{\n\tgpmc_irq_endis(d->hwirq, false);\n}\n\nstatic void gpmc_irq_unmask(struct irq_data *d)\n{\n\tgpmc_irq_endis(d->hwirq, true);\n}\n\nstatic void gpmc_irq_edge_config(unsigned long hwirq, bool rising_edge)\n{\n\tu32 regval;\n\n\t \n\tif (hwirq < GPMC_NR_NAND_IRQS)\n\t\treturn;\n\n\t \n\thwirq += 8 - GPMC_NR_NAND_IRQS;\n\n\tregval = gpmc_read_reg(GPMC_CONFIG);\n\tif (rising_edge)\n\t\tregval &= ~BIT(hwirq);\n\telse\n\t\tregval |= BIT(hwirq);\n\n\tgpmc_write_reg(GPMC_CONFIG, regval);\n}\n\nstatic void gpmc_irq_ack(struct irq_data *d)\n{\n\tunsigned int hwirq = d->hwirq;\n\n\t \n\tif (hwirq >= GPMC_NR_NAND_IRQS)\n\t\thwirq += 8 - GPMC_NR_NAND_IRQS;\n\n\t \n\tgpmc_write_reg(GPMC_IRQSTATUS, BIT(hwirq));\n}\n\nstatic int gpmc_irq_set_type(struct irq_data *d, unsigned int trigger)\n{\n\t \n\tif (d->hwirq < GPMC_NR_NAND_IRQS)\n\t\treturn -EINVAL;\n\n\t \n\tif (trigger == IRQ_TYPE_EDGE_FALLING)\n\t\tgpmc_irq_edge_config(d->hwirq, false);\n\telse if (trigger == IRQ_TYPE_EDGE_RISING)\n\t\tgpmc_irq_edge_config(d->hwirq, true);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int gpmc_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\tirq_hw_number_t hw)\n{\n\tstruct gpmc_device *gpmc = d->host_data;\n\n\tirq_set_chip_data(virq, gpmc);\n\tif (hw < GPMC_NR_NAND_IRQS) {\n\t\tirq_modify_status(virq, IRQ_NOREQUEST, IRQ_NOAUTOEN);\n\t\tirq_set_chip_and_handler(virq, &gpmc->irq_chip,\n\t\t\t\t\t handle_simple_irq);\n\t} else {\n\t\tirq_set_chip_and_handler(virq, &gpmc->irq_chip,\n\t\t\t\t\t handle_edge_irq);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops gpmc_irq_domain_ops = {\n\t.map    = gpmc_irq_map,\n\t.xlate  = irq_domain_xlate_twocell,\n};\n\nstatic irqreturn_t gpmc_handle_irq(int irq, void *data)\n{\n\tint hwirq, virq;\n\tu32 regval, regvalx;\n\tstruct gpmc_device *gpmc = data;\n\n\tregval = gpmc_read_reg(GPMC_IRQSTATUS);\n\tregvalx = regval;\n\n\tif (!regval)\n\t\treturn IRQ_NONE;\n\n\tfor (hwirq = 0; hwirq < gpmc->nirqs; hwirq++) {\n\t\t \n\t\tif (hwirq == GPMC_NR_NAND_IRQS)\n\t\t\tregvalx >>= 8 - GPMC_NR_NAND_IRQS;\n\n\t\tif (regvalx & BIT(hwirq)) {\n\t\t\tvirq = irq_find_mapping(gpmc_irq_domain, hwirq);\n\t\t\tif (!virq) {\n\t\t\t\tdev_warn(gpmc->dev,\n\t\t\t\t\t \"spurious irq detected hwirq %d, virq %d\\n\",\n\t\t\t\t\t hwirq, virq);\n\t\t\t}\n\n\t\t\tgeneric_handle_irq(virq);\n\t\t}\n\t}\n\n\tgpmc_write_reg(GPMC_IRQSTATUS, regval);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gpmc_setup_irq(struct gpmc_device *gpmc)\n{\n\tu32 regval;\n\tint rc;\n\n\t \n\tgpmc_write_reg(GPMC_IRQENABLE, 0);\n\n\t \n\tregval = gpmc_read_reg(GPMC_IRQSTATUS);\n\tgpmc_write_reg(GPMC_IRQSTATUS, regval);\n\n\tgpmc->irq_chip.name = \"gpmc\";\n\tgpmc->irq_chip.irq_enable = gpmc_irq_enable;\n\tgpmc->irq_chip.irq_disable = gpmc_irq_disable;\n\tgpmc->irq_chip.irq_ack = gpmc_irq_ack;\n\tgpmc->irq_chip.irq_mask = gpmc_irq_mask;\n\tgpmc->irq_chip.irq_unmask = gpmc_irq_unmask;\n\tgpmc->irq_chip.irq_set_type = gpmc_irq_set_type;\n\n\tgpmc_irq_domain = irq_domain_add_linear(gpmc->dev->of_node,\n\t\t\t\t\t\tgpmc->nirqs,\n\t\t\t\t\t\t&gpmc_irq_domain_ops,\n\t\t\t\t\t\tgpmc);\n\tif (!gpmc_irq_domain) {\n\t\tdev_err(gpmc->dev, \"IRQ domain add failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = request_irq(gpmc->irq, gpmc_handle_irq, 0, \"gpmc\", gpmc);\n\tif (rc) {\n\t\tdev_err(gpmc->dev, \"failed to request irq %d: %d\\n\",\n\t\t\tgpmc->irq, rc);\n\t\tirq_domain_remove(gpmc_irq_domain);\n\t\tgpmc_irq_domain = NULL;\n\t}\n\n\treturn rc;\n}\n\nstatic int gpmc_free_irq(struct gpmc_device *gpmc)\n{\n\tint hwirq;\n\n\tfree_irq(gpmc->irq, gpmc);\n\n\tfor (hwirq = 0; hwirq < gpmc->nirqs; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(gpmc_irq_domain, hwirq));\n\n\tirq_domain_remove(gpmc_irq_domain);\n\tgpmc_irq_domain = NULL;\n\n\treturn 0;\n}\n\nstatic void gpmc_mem_exit(void)\n{\n\tint cs;\n\n\tfor (cs = 0; cs < gpmc_cs_num; cs++) {\n\t\tif (!gpmc_cs_mem_enabled(cs))\n\t\t\tcontinue;\n\t\tgpmc_cs_delete_mem(cs);\n\t}\n}\n\nstatic void gpmc_mem_init(struct gpmc_device *gpmc)\n{\n\tint cs;\n\n\tif (!gpmc->data) {\n\t\t \n\t\tgpmc_mem_root.start = GPMC_MEM_START;\n\t\tgpmc_mem_root.end = GPMC_MEM_END;\n\t} else {\n\t\tgpmc_mem_root.start = gpmc->data->start;\n\t\tgpmc_mem_root.end = gpmc->data->end;\n\t}\n\n\t \n\tfor (cs = 0; cs < gpmc_cs_num; cs++) {\n\t\tu32 base, size;\n\n\t\tif (!gpmc_cs_mem_enabled(cs))\n\t\t\tcontinue;\n\t\tgpmc_cs_get_memconf(cs, &base, &size);\n\t\tif (gpmc_cs_insert_mem(cs, base, size)) {\n\t\t\tpr_warn(\"%s: disabling cs %d mapped at 0x%x-0x%x\\n\",\n\t\t\t\t__func__, cs, base, base + size);\n\t\t\tgpmc_cs_disable_mem(cs);\n\t\t}\n\t}\n}\n\nstatic u32 gpmc_round_ps_to_sync_clk(u32 time_ps, u32 sync_clk)\n{\n\tu32 temp;\n\tint div;\n\n\tdiv = gpmc_calc_divider(sync_clk);\n\ttemp = gpmc_ps_to_ticks(time_ps);\n\ttemp = (temp + div - 1) / div;\n\treturn gpmc_ticks_to_ps(temp * div);\n}\n\n \nstatic int gpmc_calc_sync_read_timings(struct gpmc_timings *gpmc_t,\n\t\t\t\t       struct gpmc_device_timings *dev_t,\n\t\t\t\t       bool mux)\n{\n\tu32 temp;\n\n\t \n\ttemp = dev_t->t_avdp_r;\n\t \n\tif (mux) {\n\t\t \n\t\ttemp = max_t(u32, temp,\tgpmc_t->clk_activation + dev_t->t_avdh);\n\t\ttemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\n\t}\n\tgpmc_t->adv_rd_off = gpmc_round_ps_to_ticks(temp);\n\n\t \n\ttemp = dev_t->t_oeasu;  \n\tif (mux) {\n\t\ttemp = max_t(u32, temp,\tgpmc_t->clk_activation + dev_t->t_ach);\n\t\ttemp = max_t(u32, temp, gpmc_t->adv_rd_off +\n\t\t\t\tgpmc_ticks_to_ps(dev_t->cyc_aavdh_oe));\n\t}\n\tgpmc_t->oe_on = gpmc_round_ps_to_ticks(temp);\n\n\t \n\t \n\ttemp = max_t(u32, dev_t->t_iaa,\tdev_t->cyc_iaa * gpmc_t->sync_clk);\n\ttemp += gpmc_t->clk_activation;\n\tif (dev_t->cyc_oe)\n\t\ttemp = max_t(u32, temp, gpmc_t->oe_on +\n\t\t\t\tgpmc_ticks_to_ps(dev_t->cyc_oe));\n\tgpmc_t->access = gpmc_round_ps_to_ticks(temp);\n\n\tgpmc_t->oe_off = gpmc_t->access + gpmc_ticks_to_ps(1);\n\tgpmc_t->cs_rd_off = gpmc_t->oe_off;\n\n\t \n\ttemp = max_t(u32, dev_t->t_cez_r, dev_t->t_oez);\n\ttemp = gpmc_round_ps_to_sync_clk(temp, gpmc_t->sync_clk) +\n\t\t\t\t\t\t\tgpmc_t->access;\n\t \n\tif (dev_t->t_ce_rdyz)\n\t\ttemp = max_t(u32, temp,\tgpmc_t->cs_rd_off + dev_t->t_ce_rdyz);\n\tgpmc_t->rd_cycle = gpmc_round_ps_to_ticks(temp);\n\n\treturn 0;\n}\n\nstatic int gpmc_calc_sync_write_timings(struct gpmc_timings *gpmc_t,\n\t\t\t\t\tstruct gpmc_device_timings *dev_t,\n\t\t\t\t\tbool mux)\n{\n\tu32 temp;\n\n\t \n\ttemp = dev_t->t_avdp_w;\n\tif (mux) {\n\t\ttemp = max_t(u32, temp,\n\t\t\tgpmc_t->clk_activation + dev_t->t_avdh);\n\t\ttemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\n\t}\n\tgpmc_t->adv_wr_off = gpmc_round_ps_to_ticks(temp);\n\n\t \n\ttemp = max_t(u32, dev_t->t_weasu,\n\t\t\tgpmc_t->clk_activation + dev_t->t_rdyo);\n\t \n\tif (mux) {\n\t\ttemp = max_t(u32, temp,\n\t\t\tgpmc_t->adv_wr_off + dev_t->t_aavdh);\n\t\ttemp = max_t(u32, temp, gpmc_t->adv_wr_off +\n\t\t\t\tgpmc_ticks_to_ps(dev_t->cyc_aavdh_we));\n\t}\n\tgpmc_t->wr_data_mux_bus = gpmc_round_ps_to_ticks(temp);\n\n\t \n\tif (gpmc_capability & GPMC_HAS_WR_DATA_MUX_BUS)\n\t\tgpmc_t->we_on = gpmc_round_ps_to_ticks(dev_t->t_weasu);\n\telse\n\t\tgpmc_t->we_on = gpmc_t->wr_data_mux_bus;\n\n\t \n\t \n\tgpmc_t->wr_access = gpmc_t->access;\n\n\t \n\ttemp = gpmc_t->we_on + dev_t->t_wpl;\n\ttemp = max_t(u32, temp,\n\t\t\tgpmc_t->wr_access + gpmc_ticks_to_ps(1));\n\ttemp = max_t(u32, temp,\n\t\tgpmc_t->we_on + gpmc_ticks_to_ps(dev_t->cyc_wpl));\n\tgpmc_t->we_off = gpmc_round_ps_to_ticks(temp);\n\n\tgpmc_t->cs_wr_off = gpmc_round_ps_to_ticks(gpmc_t->we_off +\n\t\t\t\t\t\t\tdev_t->t_wph);\n\n\t \n\ttemp = gpmc_round_ps_to_sync_clk(dev_t->t_cez_w, gpmc_t->sync_clk);\n\ttemp += gpmc_t->wr_access;\n\t \n\tif (dev_t->t_ce_rdyz)\n\t\ttemp = max_t(u32, temp,\n\t\t\t\t gpmc_t->cs_wr_off + dev_t->t_ce_rdyz);\n\tgpmc_t->wr_cycle = gpmc_round_ps_to_ticks(temp);\n\n\treturn 0;\n}\n\nstatic int gpmc_calc_async_read_timings(struct gpmc_timings *gpmc_t,\n\t\t\t\t\tstruct gpmc_device_timings *dev_t,\n\t\t\t\t\tbool mux)\n{\n\tu32 temp;\n\n\t \n\ttemp = dev_t->t_avdp_r;\n\tif (mux)\n\t\ttemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\n\tgpmc_t->adv_rd_off = gpmc_round_ps_to_ticks(temp);\n\n\t \n\ttemp = dev_t->t_oeasu;\n\tif (mux)\n\t\ttemp = max_t(u32, temp, gpmc_t->adv_rd_off + dev_t->t_aavdh);\n\tgpmc_t->oe_on = gpmc_round_ps_to_ticks(temp);\n\n\t \n\ttemp = max_t(u32, dev_t->t_iaa,  \n\t\t     gpmc_t->oe_on + dev_t->t_oe);\n\ttemp = max_t(u32, temp, gpmc_t->cs_on + dev_t->t_ce);\n\ttemp = max_t(u32, temp, gpmc_t->adv_on + dev_t->t_aa);\n\tgpmc_t->access = gpmc_round_ps_to_ticks(temp);\n\n\tgpmc_t->oe_off = gpmc_t->access + gpmc_ticks_to_ps(1);\n\tgpmc_t->cs_rd_off = gpmc_t->oe_off;\n\n\t \n\ttemp = max_t(u32, dev_t->t_rd_cycle,\n\t\t\tgpmc_t->cs_rd_off + dev_t->t_cez_r);\n\ttemp = max_t(u32, temp, gpmc_t->oe_off + dev_t->t_oez);\n\tgpmc_t->rd_cycle = gpmc_round_ps_to_ticks(temp);\n\n\treturn 0;\n}\n\nstatic int gpmc_calc_async_write_timings(struct gpmc_timings *gpmc_t,\n\t\t\t\t\t struct gpmc_device_timings *dev_t,\n\t\t\t\t\t bool mux)\n{\n\tu32 temp;\n\n\t \n\ttemp = dev_t->t_avdp_w;\n\tif (mux)\n\t\ttemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\n\tgpmc_t->adv_wr_off = gpmc_round_ps_to_ticks(temp);\n\n\t \n\ttemp = dev_t->t_weasu;\n\tif (mux) {\n\t\ttemp = max_t(u32, temp,\tgpmc_t->adv_wr_off + dev_t->t_aavdh);\n\t\ttemp = max_t(u32, temp, gpmc_t->adv_wr_off +\n\t\t\t\tgpmc_ticks_to_ps(dev_t->cyc_aavdh_we));\n\t}\n\tgpmc_t->wr_data_mux_bus = gpmc_round_ps_to_ticks(temp);\n\n\t \n\tif (gpmc_capability & GPMC_HAS_WR_DATA_MUX_BUS)\n\t\tgpmc_t->we_on = gpmc_round_ps_to_ticks(dev_t->t_weasu);\n\telse\n\t\tgpmc_t->we_on = gpmc_t->wr_data_mux_bus;\n\n\t \n\ttemp = gpmc_t->we_on + dev_t->t_wpl;\n\tgpmc_t->we_off = gpmc_round_ps_to_ticks(temp);\n\n\tgpmc_t->cs_wr_off = gpmc_round_ps_to_ticks(gpmc_t->we_off +\n\t\t\t\t\t\t\tdev_t->t_wph);\n\n\t \n\ttemp = max_t(u32, dev_t->t_wr_cycle,\n\t\t\t\tgpmc_t->cs_wr_off + dev_t->t_cez_w);\n\tgpmc_t->wr_cycle = gpmc_round_ps_to_ticks(temp);\n\n\treturn 0;\n}\n\nstatic int gpmc_calc_sync_common_timings(struct gpmc_timings *gpmc_t,\n\t\t\tstruct gpmc_device_timings *dev_t)\n{\n\tu32 temp;\n\n\tgpmc_t->sync_clk = gpmc_calc_divider(dev_t->clk) *\n\t\t\t\t\t\tgpmc_get_fclk_period();\n\n\tgpmc_t->page_burst_access = gpmc_round_ps_to_sync_clk(\n\t\t\t\t\tdev_t->t_bacc,\n\t\t\t\t\tgpmc_t->sync_clk);\n\n\ttemp = max_t(u32, dev_t->t_ces, dev_t->t_avds);\n\tgpmc_t->clk_activation = gpmc_round_ps_to_ticks(temp);\n\n\tif (gpmc_calc_divider(gpmc_t->sync_clk) != 1)\n\t\treturn 0;\n\n\tif (dev_t->ce_xdelay)\n\t\tgpmc_t->bool_timings.cs_extra_delay = true;\n\tif (dev_t->avd_xdelay)\n\t\tgpmc_t->bool_timings.adv_extra_delay = true;\n\tif (dev_t->oe_xdelay)\n\t\tgpmc_t->bool_timings.oe_extra_delay = true;\n\tif (dev_t->we_xdelay)\n\t\tgpmc_t->bool_timings.we_extra_delay = true;\n\n\treturn 0;\n}\n\nstatic int gpmc_calc_common_timings(struct gpmc_timings *gpmc_t,\n\t\t\t\t    struct gpmc_device_timings *dev_t,\n\t\t\t\t    bool sync)\n{\n\tu32 temp;\n\n\t \n\tgpmc_t->cs_on = gpmc_round_ps_to_ticks(dev_t->t_ceasu);\n\n\t \n\ttemp = dev_t->t_avdasu;\n\tif (dev_t->t_ce_avd)\n\t\ttemp = max_t(u32, temp,\n\t\t\t\tgpmc_t->cs_on + dev_t->t_ce_avd);\n\tgpmc_t->adv_on = gpmc_round_ps_to_ticks(temp);\n\n\tif (sync)\n\t\tgpmc_calc_sync_common_timings(gpmc_t, dev_t);\n\n\treturn 0;\n}\n\n \nstatic void gpmc_convert_ps_to_ns(struct gpmc_timings *t)\n{\n\tt->cs_on /= 1000;\n\tt->cs_rd_off /= 1000;\n\tt->cs_wr_off /= 1000;\n\tt->adv_on /= 1000;\n\tt->adv_rd_off /= 1000;\n\tt->adv_wr_off /= 1000;\n\tt->we_on /= 1000;\n\tt->we_off /= 1000;\n\tt->oe_on /= 1000;\n\tt->oe_off /= 1000;\n\tt->page_burst_access /= 1000;\n\tt->access /= 1000;\n\tt->rd_cycle /= 1000;\n\tt->wr_cycle /= 1000;\n\tt->bus_turnaround /= 1000;\n\tt->cycle2cycle_delay /= 1000;\n\tt->wait_monitoring /= 1000;\n\tt->clk_activation /= 1000;\n\tt->wr_access /= 1000;\n\tt->wr_data_mux_bus /= 1000;\n}\n\nint gpmc_calc_timings(struct gpmc_timings *gpmc_t,\n\t\t      struct gpmc_settings *gpmc_s,\n\t\t      struct gpmc_device_timings *dev_t)\n{\n\tbool mux = false, sync = false;\n\n\tif (gpmc_s) {\n\t\tmux = gpmc_s->mux_add_data ? true : false;\n\t\tsync = (gpmc_s->sync_read || gpmc_s->sync_write);\n\t}\n\n\tmemset(gpmc_t, 0, sizeof(*gpmc_t));\n\n\tgpmc_calc_common_timings(gpmc_t, dev_t, sync);\n\n\tif (gpmc_s && gpmc_s->sync_read)\n\t\tgpmc_calc_sync_read_timings(gpmc_t, dev_t, mux);\n\telse\n\t\tgpmc_calc_async_read_timings(gpmc_t, dev_t, mux);\n\n\tif (gpmc_s && gpmc_s->sync_write)\n\t\tgpmc_calc_sync_write_timings(gpmc_t, dev_t, mux);\n\telse\n\t\tgpmc_calc_async_write_timings(gpmc_t, dev_t, mux);\n\n\t \n\tgpmc_convert_ps_to_ns(gpmc_t);\n\n\treturn 0;\n}\n\n \nint gpmc_cs_program_settings(int cs, struct gpmc_settings *p)\n{\n\tu32 config1;\n\n\tif ((!p->device_width) || (p->device_width > GPMC_DEVWIDTH_16BIT)) {\n\t\tpr_err(\"%s: invalid width %d!\", __func__, p->device_width);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (p->device_nand && p->mux_add_data) {\n\t\tpr_err(\"%s: invalid configuration!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((p->mux_add_data > GPMC_MUX_AD) ||\n\t    ((p->mux_add_data == GPMC_MUX_AAD) &&\n\t     !(gpmc_capability & GPMC_HAS_MUX_AAD))) {\n\t\tpr_err(\"%s: invalid multiplex configuration!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (p->burst_read || p->burst_write) {\n\t\tswitch (p->burst_len) {\n\t\tcase GPMC_BURST_4:\n\t\tcase GPMC_BURST_8:\n\t\tcase GPMC_BURST_16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: invalid page/burst-length (%d)\\n\",\n\t\t\t       __func__, p->burst_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (p->wait_pin != GPMC_WAITPIN_INVALID &&\n\t    p->wait_pin > gpmc_nr_waitpins) {\n\t\tpr_err(\"%s: invalid wait-pin (%d)\\n\", __func__, p->wait_pin);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig1 = GPMC_CONFIG1_DEVICESIZE((p->device_width - 1));\n\n\tif (p->sync_read)\n\t\tconfig1 |= GPMC_CONFIG1_READTYPE_SYNC;\n\tif (p->sync_write)\n\t\tconfig1 |= GPMC_CONFIG1_WRITETYPE_SYNC;\n\tif (p->wait_on_read)\n\t\tconfig1 |= GPMC_CONFIG1_WAIT_READ_MON;\n\tif (p->wait_on_write)\n\t\tconfig1 |= GPMC_CONFIG1_WAIT_WRITE_MON;\n\tif (p->wait_on_read || p->wait_on_write)\n\t\tconfig1 |= GPMC_CONFIG1_WAIT_PIN_SEL(p->wait_pin);\n\tif (p->device_nand)\n\t\tconfig1\t|= GPMC_CONFIG1_DEVICETYPE(GPMC_DEVICETYPE_NAND);\n\tif (p->mux_add_data)\n\t\tconfig1\t|= GPMC_CONFIG1_MUXTYPE(p->mux_add_data);\n\tif (p->burst_read)\n\t\tconfig1 |= GPMC_CONFIG1_READMULTIPLE_SUPP;\n\tif (p->burst_write)\n\t\tconfig1 |= GPMC_CONFIG1_WRITEMULTIPLE_SUPP;\n\tif (p->burst_read || p->burst_write) {\n\t\tconfig1 |= GPMC_CONFIG1_PAGE_LEN(p->burst_len >> 3);\n\t\tconfig1 |= p->burst_wrap ? GPMC_CONFIG1_WRAPBURST_SUPP : 0;\n\t}\n\n\tgpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, config1);\n\n\tif (p->wait_pin_polarity != GPMC_WAITPINPOLARITY_INVALID) {\n\t\tconfig1 = gpmc_read_reg(GPMC_CONFIG);\n\n\t\tif (p->wait_pin_polarity == GPMC_WAITPINPOLARITY_ACTIVE_LOW)\n\t\t\tconfig1 &= ~GPMC_CONFIG_WAITPINPOLARITY(p->wait_pin);\n\t\telse if (p->wait_pin_polarity == GPMC_WAITPINPOLARITY_ACTIVE_HIGH)\n\t\t\tconfig1 |= GPMC_CONFIG_WAITPINPOLARITY(p->wait_pin);\n\n\t\tgpmc_write_reg(GPMC_CONFIG, config1);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic void gpmc_cs_set_name(int cs, const char *name)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\n\tgpmc->name = name;\n}\n\nstatic const char *gpmc_cs_get_name(int cs)\n{\n\tstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\n\n\treturn gpmc->name;\n}\n\n \nstatic int gpmc_cs_remap(int cs, u32 base)\n{\n\tint ret;\n\tu32 old_base, size;\n\n\tif (cs >= gpmc_cs_num) {\n\t\tpr_err(\"%s: requested chip-select is disabled\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tbase &= ~(SZ_16M - 1);\n\n\tgpmc_cs_get_memconf(cs, &old_base, &size);\n\tif (base == old_base)\n\t\treturn 0;\n\n\tret = gpmc_cs_delete_mem(cs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gpmc_cs_insert_mem(cs, base, size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gpmc_cs_set_memconf(cs, base, size);\n\n\treturn ret;\n}\n\n \nvoid gpmc_read_settings_dt(struct device_node *np, struct gpmc_settings *p)\n{\n\tmemset(p, 0, sizeof(struct gpmc_settings));\n\n\tp->sync_read = of_property_read_bool(np, \"gpmc,sync-read\");\n\tp->sync_write = of_property_read_bool(np, \"gpmc,sync-write\");\n\tof_property_read_u32(np, \"gpmc,device-width\", &p->device_width);\n\tof_property_read_u32(np, \"gpmc,mux-add-data\", &p->mux_add_data);\n\n\tif (!of_property_read_u32(np, \"gpmc,burst-length\", &p->burst_len)) {\n\t\tp->burst_wrap = of_property_read_bool(np, \"gpmc,burst-wrap\");\n\t\tp->burst_read = of_property_read_bool(np, \"gpmc,burst-read\");\n\t\tp->burst_write = of_property_read_bool(np, \"gpmc,burst-write\");\n\t\tif (!p->burst_read && !p->burst_write)\n\t\t\tpr_warn(\"%s: page/burst-length set but not used!\\n\",\n\t\t\t\t__func__);\n\t}\n\n\tp->wait_pin = GPMC_WAITPIN_INVALID;\n\tp->wait_pin_polarity = GPMC_WAITPINPOLARITY_INVALID;\n\n\tif (!of_property_read_u32(np, \"gpmc,wait-pin\", &p->wait_pin)) {\n\t\tif (!gpmc_is_valid_waitpin(p->wait_pin)) {\n\t\t\tpr_err(\"%s: Invalid wait-pin (%d)\\n\", __func__, p->wait_pin);\n\t\t\tp->wait_pin = GPMC_WAITPIN_INVALID;\n\t\t}\n\n\t\tif (!of_property_read_u32(np, \"ti,wait-pin-polarity\",\n\t\t\t\t\t  &p->wait_pin_polarity)) {\n\t\t\tif (p->wait_pin_polarity != GPMC_WAITPINPOLARITY_ACTIVE_HIGH &&\n\t\t\t    p->wait_pin_polarity != GPMC_WAITPINPOLARITY_ACTIVE_LOW) {\n\t\t\t\tpr_err(\"%s: Invalid wait-pin-polarity (%d)\\n\",\n\t\t\t\t       __func__, p->wait_pin_polarity);\n\t\t\t\tp->wait_pin_polarity = GPMC_WAITPINPOLARITY_INVALID;\n\t\t\t\t}\n\t\t}\n\n\t\tp->wait_on_read = of_property_read_bool(np,\n\t\t\t\t\t\t\t\"gpmc,wait-on-read\");\n\t\tp->wait_on_write = of_property_read_bool(np,\n\t\t\t\t\t\t\t \"gpmc,wait-on-write\");\n\t\tif (!p->wait_on_read && !p->wait_on_write)\n\t\t\tpr_debug(\"%s: rd/wr wait monitoring not enabled!\\n\",\n\t\t\t\t __func__);\n\t}\n}\n\nstatic void __maybe_unused gpmc_read_timings_dt(struct device_node *np,\n\t\t\t\t\t\tstruct gpmc_timings *gpmc_t)\n{\n\tstruct gpmc_bool_timings *p;\n\n\tif (!np || !gpmc_t)\n\t\treturn;\n\n\tmemset(gpmc_t, 0, sizeof(*gpmc_t));\n\n\t \n\tof_property_read_u32(np, \"gpmc,sync-clk-ps\", &gpmc_t->sync_clk);\n\n\t \n\tof_property_read_u32(np, \"gpmc,cs-on-ns\", &gpmc_t->cs_on);\n\tof_property_read_u32(np, \"gpmc,cs-rd-off-ns\", &gpmc_t->cs_rd_off);\n\tof_property_read_u32(np, \"gpmc,cs-wr-off-ns\", &gpmc_t->cs_wr_off);\n\n\t \n\tof_property_read_u32(np, \"gpmc,adv-on-ns\", &gpmc_t->adv_on);\n\tof_property_read_u32(np, \"gpmc,adv-rd-off-ns\", &gpmc_t->adv_rd_off);\n\tof_property_read_u32(np, \"gpmc,adv-wr-off-ns\", &gpmc_t->adv_wr_off);\n\tof_property_read_u32(np, \"gpmc,adv-aad-mux-on-ns\",\n\t\t\t     &gpmc_t->adv_aad_mux_on);\n\tof_property_read_u32(np, \"gpmc,adv-aad-mux-rd-off-ns\",\n\t\t\t     &gpmc_t->adv_aad_mux_rd_off);\n\tof_property_read_u32(np, \"gpmc,adv-aad-mux-wr-off-ns\",\n\t\t\t     &gpmc_t->adv_aad_mux_wr_off);\n\n\t \n\tof_property_read_u32(np, \"gpmc,we-on-ns\", &gpmc_t->we_on);\n\tof_property_read_u32(np, \"gpmc,we-off-ns\", &gpmc_t->we_off);\n\n\t \n\tof_property_read_u32(np, \"gpmc,oe-on-ns\", &gpmc_t->oe_on);\n\tof_property_read_u32(np, \"gpmc,oe-off-ns\", &gpmc_t->oe_off);\n\tof_property_read_u32(np, \"gpmc,oe-aad-mux-on-ns\",\n\t\t\t     &gpmc_t->oe_aad_mux_on);\n\tof_property_read_u32(np, \"gpmc,oe-aad-mux-off-ns\",\n\t\t\t     &gpmc_t->oe_aad_mux_off);\n\n\t \n\tof_property_read_u32(np, \"gpmc,page-burst-access-ns\",\n\t\t\t     &gpmc_t->page_burst_access);\n\tof_property_read_u32(np, \"gpmc,access-ns\", &gpmc_t->access);\n\tof_property_read_u32(np, \"gpmc,rd-cycle-ns\", &gpmc_t->rd_cycle);\n\tof_property_read_u32(np, \"gpmc,wr-cycle-ns\", &gpmc_t->wr_cycle);\n\tof_property_read_u32(np, \"gpmc,bus-turnaround-ns\",\n\t\t\t     &gpmc_t->bus_turnaround);\n\tof_property_read_u32(np, \"gpmc,cycle2cycle-delay-ns\",\n\t\t\t     &gpmc_t->cycle2cycle_delay);\n\tof_property_read_u32(np, \"gpmc,wait-monitoring-ns\",\n\t\t\t     &gpmc_t->wait_monitoring);\n\tof_property_read_u32(np, \"gpmc,clk-activation-ns\",\n\t\t\t     &gpmc_t->clk_activation);\n\n\t \n\tof_property_read_u32(np, \"gpmc,wr-access-ns\", &gpmc_t->wr_access);\n\tof_property_read_u32(np, \"gpmc,wr-data-mux-bus-ns\",\n\t\t\t     &gpmc_t->wr_data_mux_bus);\n\n\t \n\tp = &gpmc_t->bool_timings;\n\n\tp->cycle2cyclediffcsen =\n\t\tof_property_read_bool(np, \"gpmc,cycle2cycle-diffcsen\");\n\tp->cycle2cyclesamecsen =\n\t\tof_property_read_bool(np, \"gpmc,cycle2cycle-samecsen\");\n\tp->we_extra_delay = of_property_read_bool(np, \"gpmc,we-extra-delay\");\n\tp->oe_extra_delay = of_property_read_bool(np, \"gpmc,oe-extra-delay\");\n\tp->adv_extra_delay = of_property_read_bool(np, \"gpmc,adv-extra-delay\");\n\tp->cs_extra_delay = of_property_read_bool(np, \"gpmc,cs-extra-delay\");\n\tp->time_para_granularity =\n\t\tof_property_read_bool(np, \"gpmc,time-para-granularity\");\n}\n\n \nstatic int gpmc_probe_generic_child(struct platform_device *pdev,\n\t\t\t\tstruct device_node *child)\n{\n\tstruct gpmc_settings gpmc_s;\n\tstruct gpmc_timings gpmc_t;\n\tstruct resource res;\n\tunsigned long base;\n\tconst char *name;\n\tint ret, cs;\n\tu32 val;\n\tstruct gpmc_device *gpmc = platform_get_drvdata(pdev);\n\n\tif (of_property_read_u32(child, \"reg\", &cs) < 0) {\n\t\tdev_err(&pdev->dev, \"%pOF has no 'reg' property\\n\",\n\t\t\tchild);\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_address_to_resource(child, 0, &res) < 0) {\n\t\tdev_err(&pdev->dev, \"%pOF has malformed 'reg' property\\n\",\n\t\t\tchild);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tname = gpmc_cs_get_name(cs);\n\tif (name && of_node_name_eq(child, name))\n\t\tgoto no_timings;\n\n\tret = gpmc_cs_request(cs, resource_size(&res), &base);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"cannot request GPMC CS %d\\n\", cs);\n\t\treturn ret;\n\t}\n\tgpmc_cs_set_name(cs, child->full_name);\n\n\tgpmc_read_settings_dt(child, &gpmc_s);\n\tgpmc_read_timings_dt(child, &gpmc_t);\n\n\t \n\tif (!gpmc_t.cs_rd_off) {\n\t\tWARN(1, \"enable GPMC debug to configure .dts timings for CS%i\\n\",\n\t\t\tcs);\n\t\tgpmc_cs_show_timings(cs,\n\t\t\t\t     \"please add GPMC bootloader timings to .dts\");\n\t\tgoto no_timings;\n\t}\n\n\t \n\tgpmc_cs_disable_mem(cs);\n\n\t \n\tret = gpmc_cs_remap(cs, res.start);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"cannot remap GPMC CS %d to %pa\\n\",\n\t\t\tcs, &res.start);\n\t\tif (res.start < GPMC_MEM_START) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"GPMC CS %d start cannot be lesser than 0x%x\\n\",\n\t\t\t\t cs, GPMC_MEM_START);\n\t\t} else if (res.end > GPMC_MEM_END) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"GPMC CS %d end cannot be greater than 0x%x\\n\",\n\t\t\t\t cs, GPMC_MEM_END);\n\t\t}\n\t\tgoto err;\n\t}\n\n\tif (of_node_name_eq(child, \"nand\")) {\n\t\t \n\t\tif (!of_property_read_bool(child, \"compatible\")) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Incompatible NAND node: missing compatible\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (of_node_name_eq(child, \"onenand\")) {\n\t\t \n\t\tif (!of_property_read_bool(child, \"compatible\")) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Incompatible OneNAND node: missing compatible\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (of_match_node(omap_nand_ids, child)) {\n\t\t \n\t\tval = 8;\n\t\tof_property_read_u32(child, \"nand-bus-width\", &val);\n\t\tswitch (val) {\n\t\tcase 8:\n\t\t\tgpmc_s.device_width = GPMC_DEVWIDTH_8BIT;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tgpmc_s.device_width = GPMC_DEVWIDTH_16BIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"%pOFn: invalid 'nand-bus-width'\\n\",\n\t\t\t\tchild);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tgpmc_configure(GPMC_CONFIG_WP, 0);\n\t\tgpmc_s.device_nand = true;\n\t} else {\n\t\tret = of_property_read_u32(child, \"bank-width\",\n\t\t\t\t\t   &gpmc_s.device_width);\n\t\tif (ret < 0 && !gpmc_s.device_width) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%pOF has no 'gpmc,device-width' property\\n\",\n\t\t\t\tchild);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tif (gpmc_s.wait_on_read || gpmc_s.wait_on_write) {\n\t\tret = gpmc_alloc_waitpin(gpmc, &gpmc_s);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tgpmc_cs_show_timings(cs, \"before gpmc_cs_program_settings\");\n\n\tret = gpmc_cs_program_settings(cs, &gpmc_s);\n\tif (ret < 0)\n\t\tgoto err_cs;\n\n\tret = gpmc_cs_set_timings(cs, &gpmc_t, &gpmc_s);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to set gpmc timings for: %pOFn\\n\",\n\t\t\tchild);\n\t\tgoto err_cs;\n\t}\n\n\t \n\tval = gpmc_read_reg(GPMC_CONFIG);\n\tval &= ~GPMC_CONFIG_LIMITEDADDRESS;\n\tgpmc_write_reg(GPMC_CONFIG, val);\n\n\t \n\tgpmc_cs_enable_mem(cs);\n\nno_timings:\n\n\t \n\tif (!of_platform_device_create(child, NULL, &pdev->dev))\n\t\tgoto err_child_fail;\n\n\t \n\tif (of_platform_default_populate(child, NULL, &pdev->dev))\n\t\tgoto err_child_fail;\n\n\treturn 0;\n\nerr_child_fail:\n\n\tdev_err(&pdev->dev, \"failed to create gpmc child %pOFn\\n\", child);\n\tret = -ENODEV;\n\nerr_cs:\n\tgpmc_free_waitpin(gpmc, gpmc_s.wait_pin);\nerr:\n\tgpmc_cs_free(cs);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id gpmc_dt_ids[];\n\nstatic int gpmc_probe_dt(struct platform_device *pdev)\n{\n\tint ret;\n\tconst struct of_device_id *of_id =\n\t\tof_match_device(gpmc_dt_ids, &pdev->dev);\n\n\tif (!of_id)\n\t\treturn 0;\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"gpmc,num-cs\",\n\t\t\t\t   &gpmc_cs_num);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: number of chip-selects not defined\\n\", __func__);\n\t\treturn ret;\n\t} else if (gpmc_cs_num < 1) {\n\t\tpr_err(\"%s: all chip-selects are disabled\\n\", __func__);\n\t\treturn -EINVAL;\n\t} else if (gpmc_cs_num > GPMC_CS_NUM) {\n\t\tpr_err(\"%s: number of supported chip-selects cannot be > %d\\n\",\n\t\t\t\t\t __func__, GPMC_CS_NUM);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"gpmc,num-waitpins\",\n\t\t\t\t   &gpmc_nr_waitpins);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: number of wait pins not found!\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void gpmc_probe_dt_children(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device_node *child;\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, child) {\n\t\tret = gpmc_probe_generic_child(pdev, child);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to probe DT child '%pOFn': %d\\n\",\n\t\t\t\tchild, ret);\n\t\t}\n\t}\n}\n#else\nvoid gpmc_read_settings_dt(struct device_node *np, struct gpmc_settings *p)\n{\n\tmemset(p, 0, sizeof(*p));\n}\nstatic int gpmc_probe_dt(struct platform_device *pdev)\n{\n\treturn 0;\n}\n\nstatic void gpmc_probe_dt_children(struct platform_device *pdev)\n{\n}\n#endif  \n\nstatic int gpmc_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn 1;\t \n}\n\nstatic int gpmc_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\treturn 0;\t \n}\n\nstatic int gpmc_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int value)\n{\n\treturn -EINVAL;\t \n}\n\nstatic void gpmc_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t  int value)\n{\n}\n\nstatic int gpmc_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tu32 reg;\n\n\toffset += 8;\n\n\treg = gpmc_read_reg(GPMC_STATUS) & BIT(offset);\n\n\treturn !!reg;\n}\n\nstatic int gpmc_gpio_init(struct gpmc_device *gpmc)\n{\n\tint ret;\n\n\tgpmc->gpio_chip.parent = gpmc->dev;\n\tgpmc->gpio_chip.owner = THIS_MODULE;\n\tgpmc->gpio_chip.label = DEVICE_NAME;\n\tgpmc->gpio_chip.ngpio = gpmc_nr_waitpins;\n\tgpmc->gpio_chip.get_direction = gpmc_gpio_get_direction;\n\tgpmc->gpio_chip.direction_input = gpmc_gpio_direction_input;\n\tgpmc->gpio_chip.direction_output = gpmc_gpio_direction_output;\n\tgpmc->gpio_chip.set = gpmc_gpio_set;\n\tgpmc->gpio_chip.get = gpmc_gpio_get;\n\tgpmc->gpio_chip.base = -1;\n\n\tret = devm_gpiochip_add_data(gpmc->dev, &gpmc->gpio_chip, NULL);\n\tif (ret < 0) {\n\t\tdev_err(gpmc->dev, \"could not register gpio chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void omap3_gpmc_save_context(struct gpmc_device *gpmc)\n{\n\tstruct omap3_gpmc_regs *gpmc_context;\n\tint i;\n\n\tif (!gpmc || !gpmc_base)\n\t\treturn;\n\n\tgpmc_context = &gpmc->context;\n\n\tgpmc_context->sysconfig = gpmc_read_reg(GPMC_SYSCONFIG);\n\tgpmc_context->irqenable = gpmc_read_reg(GPMC_IRQENABLE);\n\tgpmc_context->timeout_ctrl = gpmc_read_reg(GPMC_TIMEOUT_CONTROL);\n\tgpmc_context->config = gpmc_read_reg(GPMC_CONFIG);\n\tgpmc_context->prefetch_config1 = gpmc_read_reg(GPMC_PREFETCH_CONFIG1);\n\tgpmc_context->prefetch_config2 = gpmc_read_reg(GPMC_PREFETCH_CONFIG2);\n\tgpmc_context->prefetch_control = gpmc_read_reg(GPMC_PREFETCH_CONTROL);\n\tfor (i = 0; i < gpmc_cs_num; i++) {\n\t\tgpmc_context->cs_context[i].is_valid = gpmc_cs_mem_enabled(i);\n\t\tif (gpmc_context->cs_context[i].is_valid) {\n\t\t\tgpmc_context->cs_context[i].config1 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG1);\n\t\t\tgpmc_context->cs_context[i].config2 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG2);\n\t\t\tgpmc_context->cs_context[i].config3 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG3);\n\t\t\tgpmc_context->cs_context[i].config4 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG4);\n\t\t\tgpmc_context->cs_context[i].config5 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG5);\n\t\t\tgpmc_context->cs_context[i].config6 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG6);\n\t\t\tgpmc_context->cs_context[i].config7 =\n\t\t\t\tgpmc_cs_read_reg(i, GPMC_CS_CONFIG7);\n\t\t}\n\t}\n}\n\nstatic void omap3_gpmc_restore_context(struct gpmc_device *gpmc)\n{\n\tstruct omap3_gpmc_regs *gpmc_context;\n\tint i;\n\n\tif (!gpmc || !gpmc_base)\n\t\treturn;\n\n\tgpmc_context = &gpmc->context;\n\n\tgpmc_write_reg(GPMC_SYSCONFIG, gpmc_context->sysconfig);\n\tgpmc_write_reg(GPMC_IRQENABLE, gpmc_context->irqenable);\n\tgpmc_write_reg(GPMC_TIMEOUT_CONTROL, gpmc_context->timeout_ctrl);\n\tgpmc_write_reg(GPMC_CONFIG, gpmc_context->config);\n\tgpmc_write_reg(GPMC_PREFETCH_CONFIG1, gpmc_context->prefetch_config1);\n\tgpmc_write_reg(GPMC_PREFETCH_CONFIG2, gpmc_context->prefetch_config2);\n\tgpmc_write_reg(GPMC_PREFETCH_CONTROL, gpmc_context->prefetch_control);\n\tfor (i = 0; i < gpmc_cs_num; i++) {\n\t\tif (gpmc_context->cs_context[i].is_valid) {\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG1,\n\t\t\t\t\t  gpmc_context->cs_context[i].config1);\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG2,\n\t\t\t\t\t  gpmc_context->cs_context[i].config2);\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG3,\n\t\t\t\t\t  gpmc_context->cs_context[i].config3);\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG4,\n\t\t\t\t\t  gpmc_context->cs_context[i].config4);\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG5,\n\t\t\t\t\t  gpmc_context->cs_context[i].config5);\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG6,\n\t\t\t\t\t  gpmc_context->cs_context[i].config6);\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG7,\n\t\t\t\t\t  gpmc_context->cs_context[i].config7);\n\t\t} else {\n\t\t\tgpmc_cs_write_reg(i, GPMC_CS_CONFIG7, 0);\n\t\t}\n\t}\n}\n\nstatic int omap_gpmc_context_notifier(struct notifier_block *nb,\n\t\t\t\t      unsigned long cmd, void *v)\n{\n\tstruct gpmc_device *gpmc;\n\n\tgpmc = container_of(nb, struct gpmc_device, nb);\n\tif (gpmc->is_suspended || pm_runtime_suspended(gpmc->dev))\n\t\treturn NOTIFY_OK;\n\n\tswitch (cmd) {\n\tcase CPU_CLUSTER_PM_ENTER:\n\t\tomap3_gpmc_save_context(gpmc);\n\t\tbreak;\n\tcase CPU_CLUSTER_PM_ENTER_FAILED:\t \n\t\tbreak;\n\tcase CPU_CLUSTER_PM_EXIT:\n\t\tomap3_gpmc_restore_context(gpmc);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int gpmc_probe(struct platform_device *pdev)\n{\n\tint rc, i;\n\tu32 l;\n\tstruct resource *res;\n\tstruct gpmc_device *gpmc;\n\n\tgpmc = devm_kzalloc(&pdev->dev, sizeof(*gpmc), GFP_KERNEL);\n\tif (!gpmc)\n\t\treturn -ENOMEM;\n\n\tgpmc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, gpmc);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cfg\");\n\tif (!res) {\n\t\t \n\t\tgpmc_base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(gpmc_base))\n\t\t\treturn PTR_ERR(gpmc_base);\n\t} else {\n\t\tgpmc_base = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(gpmc_base))\n\t\t\treturn PTR_ERR(gpmc_base);\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"data\");\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"couldn't get data reg resource\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tgpmc->data = res;\n\t}\n\n\tgpmc->irq = platform_get_irq(pdev, 0);\n\tif (gpmc->irq < 0)\n\t\treturn gpmc->irq;\n\n\tgpmc_l3_clk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(gpmc_l3_clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get GPMC fck\\n\");\n\t\treturn PTR_ERR(gpmc_l3_clk);\n\t}\n\n\tif (!clk_get_rate(gpmc_l3_clk)) {\n\t\tdev_err(&pdev->dev, \"Invalid GPMC fck clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdev->dev.of_node) {\n\t\trc = gpmc_probe_dt(pdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tgpmc_cs_num = GPMC_CS_NUM;\n\t\tgpmc_nr_waitpins = GPMC_NR_WAITPINS;\n\t}\n\n\tgpmc->waitpins = devm_kzalloc(&pdev->dev,\n\t\t\t\t      gpmc_nr_waitpins * sizeof(struct gpmc_waitpin),\n\t\t\t\t      GFP_KERNEL);\n\tif (!gpmc->waitpins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < gpmc_nr_waitpins; i++)\n\t\tgpmc->waitpins[i].pin = GPMC_WAITPIN_INVALID;\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tl = gpmc_read_reg(GPMC_REVISION);\n\n\t \n\tif (GPMC_REVISION_MAJOR(l) > 0x4)\n\t\tgpmc_capability = GPMC_HAS_WR_ACCESS | GPMC_HAS_WR_DATA_MUX_BUS;\n\tif (GPMC_REVISION_MAJOR(l) > 0x5)\n\t\tgpmc_capability |= GPMC_HAS_MUX_AAD;\n\tdev_info(gpmc->dev, \"GPMC revision %d.%d\\n\", GPMC_REVISION_MAJOR(l),\n\t\t GPMC_REVISION_MINOR(l));\n\n\tgpmc_mem_init(gpmc);\n\trc = gpmc_gpio_init(gpmc);\n\tif (rc)\n\t\tgoto gpio_init_failed;\n\n\tgpmc->nirqs = GPMC_NR_NAND_IRQS + gpmc_nr_waitpins;\n\trc = gpmc_setup_irq(gpmc);\n\tif (rc) {\n\t\tdev_err(gpmc->dev, \"gpmc_setup_irq failed\\n\");\n\t\tgoto gpio_init_failed;\n\t}\n\n\tgpmc_probe_dt_children(pdev);\n\n\tgpmc->nb.notifier_call = omap_gpmc_context_notifier;\n\tcpu_pm_register_notifier(&gpmc->nb);\n\n\treturn 0;\n\ngpio_init_failed:\n\tgpmc_mem_exit();\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn rc;\n}\n\nstatic int gpmc_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct gpmc_device *gpmc = platform_get_drvdata(pdev);\n\n\tcpu_pm_unregister_notifier(&gpmc->nb);\n\tfor (i = 0; i < gpmc_nr_waitpins; i++)\n\t\tgpmc_free_waitpin(gpmc, i);\n\tgpmc_free_irq(gpmc);\n\tgpmc_mem_exit();\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gpmc_suspend(struct device *dev)\n{\n\tstruct gpmc_device *gpmc = dev_get_drvdata(dev);\n\n\tomap3_gpmc_save_context(gpmc);\n\tpm_runtime_put_sync(dev);\n\tgpmc->is_suspended = 1;\n\n\treturn 0;\n}\n\nstatic int gpmc_resume(struct device *dev)\n{\n\tstruct gpmc_device *gpmc = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\tomap3_gpmc_restore_context(gpmc);\n\tgpmc->is_suspended = 0;\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(gpmc_pm_ops, gpmc_suspend, gpmc_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id gpmc_dt_ids[] = {\n\t{ .compatible = \"ti,omap2420-gpmc\" },\n\t{ .compatible = \"ti,omap2430-gpmc\" },\n\t{ .compatible = \"ti,omap3430-gpmc\" },\t \n\t{ .compatible = \"ti,omap4430-gpmc\" },\t \n\t{ .compatible = \"ti,am3352-gpmc\" },\t \n\t{ .compatible = \"ti,am64-gpmc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gpmc_dt_ids);\n#endif\n\nstatic struct platform_driver gpmc_driver = {\n\t.probe\t\t= gpmc_probe,\n\t.remove\t\t= gpmc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DEVICE_NAME,\n\t\t.of_match_table = of_match_ptr(gpmc_dt_ids),\n\t\t.pm\t= &gpmc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(gpmc_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments GPMC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}