{
  "module_name": "device.c",
  "hash_id": "d24ab9ec7d667cd3f810d27ede83285732b50dcb94804d01c87c3dbf259e5e91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/peci/device.c",
  "human_readable_source": "\n\n\n#include <linux/bitfield.h>\n#include <linux/peci.h>\n#include <linux/peci-cpu.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\n \nstatic DEFINE_MUTEX(peci_device_del_lock);\n\n#define REVISION_NUM_MASK GENMASK(15, 8)\nstatic int peci_get_revision(struct peci_device *device, u8 *revision)\n{\n\tstruct peci_request *req;\n\tu64 dib;\n\n\treq = peci_xfer_get_dib(device);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t \n\tdib = peci_request_dib_read(req);\n\tif (dib == 0) {\n\t\tpeci_request_free(req);\n\t\treturn -EIO;\n\t}\n\n\t*revision = FIELD_GET(REVISION_NUM_MASK, dib);\n\n\tpeci_request_free(req);\n\n\treturn 0;\n}\n\nstatic int peci_get_cpu_id(struct peci_device *device, u32 *cpu_id)\n{\n\tstruct peci_request *req;\n\tint ret;\n\n\treq = peci_xfer_pkg_cfg_readl(device, PECI_PCS_PKG_ID, PECI_PKG_ID_CPU_ID);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = peci_request_status(req);\n\tif (ret)\n\t\tgoto out_req_free;\n\n\t*cpu_id = peci_request_data_readl(req);\nout_req_free:\n\tpeci_request_free(req);\n\n\treturn ret;\n}\n\nstatic unsigned int peci_x86_cpu_family(unsigned int sig)\n{\n\tunsigned int x86;\n\n\tx86 = (sig >> 8) & 0xf;\n\n\tif (x86 == 0xf)\n\t\tx86 += (sig >> 20) & 0xff;\n\n\treturn x86;\n}\n\nstatic unsigned int peci_x86_cpu_model(unsigned int sig)\n{\n\tunsigned int fam, model;\n\n\tfam = peci_x86_cpu_family(sig);\n\n\tmodel = (sig >> 4) & 0xf;\n\n\tif (fam >= 0x6)\n\t\tmodel += ((sig >> 16) & 0xf) << 4;\n\n\treturn model;\n}\n\nstatic int peci_device_info_init(struct peci_device *device)\n{\n\tu8 revision;\n\tu32 cpu_id;\n\tint ret;\n\n\tret = peci_get_cpu_id(device, &cpu_id);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice->info.family = peci_x86_cpu_family(cpu_id);\n\tdevice->info.model = peci_x86_cpu_model(cpu_id);\n\n\tret = peci_get_revision(device, &revision);\n\tif (ret)\n\t\treturn ret;\n\tdevice->info.peci_revision = revision;\n\n\tdevice->info.socket_id = device->addr - PECI_BASE_ADDR;\n\n\treturn 0;\n}\n\nstatic int peci_detect(struct peci_controller *controller, u8 addr)\n{\n\t \n\tstruct peci_request req = { 0 };\n\tint ret;\n\n\tmutex_lock(&controller->bus_lock);\n\tret = controller->ops->xfer(controller, addr, &req);\n\tmutex_unlock(&controller->bus_lock);\n\n\treturn ret;\n}\n\nstatic bool peci_addr_valid(u8 addr)\n{\n\treturn addr >= PECI_BASE_ADDR && addr < PECI_BASE_ADDR + PECI_DEVICE_NUM_MAX;\n}\n\nstatic int peci_dev_exists(struct device *dev, void *data)\n{\n\tstruct peci_device *device = to_peci_device(dev);\n\tu8 *addr = data;\n\n\tif (device->addr == *addr)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nint peci_device_create(struct peci_controller *controller, u8 addr)\n{\n\tstruct peci_device *device;\n\tint ret;\n\n\tif (!peci_addr_valid(addr))\n\t\treturn -EINVAL;\n\n\t \n\tret = device_for_each_child(&controller->dev, &addr, peci_dev_exists);\n\tif (ret)\n\t\treturn 0;\n\n\tret = peci_detect(controller, addr);\n\tif (ret) {\n\t\t \n\t\tif (ret == -EIO || ret == -ETIMEDOUT)\n\t\t\treturn 0;\n\n\t\treturn ret;\n\t}\n\n\tdevice = kzalloc(sizeof(*device), GFP_KERNEL);\n\tif (!device)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(&device->dev);\n\n\tdevice->addr = addr;\n\tdevice->dev.parent = &controller->dev;\n\tdevice->dev.bus = &peci_bus_type;\n\tdevice->dev.type = &peci_device_type;\n\n\tret = peci_device_info_init(device);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = dev_set_name(&device->dev, \"%d-%02x\", controller->id, device->addr);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = device_add(&device->dev);\n\tif (ret)\n\t\tgoto err_put;\n\n\treturn 0;\n\nerr_put:\n\tput_device(&device->dev);\n\n\treturn ret;\n}\n\nvoid peci_device_destroy(struct peci_device *device)\n{\n\tmutex_lock(&peci_device_del_lock);\n\tif (!device->deleted) {\n\t\tdevice_unregister(&device->dev);\n\t\tdevice->deleted = true;\n\t}\n\tmutex_unlock(&peci_device_del_lock);\n}\n\nint __peci_driver_register(struct peci_driver *driver, struct module *owner,\n\t\t\t   const char *mod_name)\n{\n\tdriver->driver.bus = &peci_bus_type;\n\tdriver->driver.owner = owner;\n\tdriver->driver.mod_name = mod_name;\n\n\tif (!driver->probe) {\n\t\tpr_err(\"peci: trying to register driver without probe callback\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!driver->id_table) {\n\t\tpr_err(\"peci: trying to register driver without device id table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn driver_register(&driver->driver);\n}\nEXPORT_SYMBOL_NS_GPL(__peci_driver_register, PECI);\n\nvoid peci_driver_unregister(struct peci_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL_NS_GPL(peci_driver_unregister, PECI);\n\nstatic void peci_device_release(struct device *dev)\n{\n\tstruct peci_device *device = to_peci_device(dev);\n\n\tkfree(device);\n}\n\nstruct device_type peci_device_type = {\n\t.groups\t\t= peci_device_groups,\n\t.release\t= peci_device_release,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}