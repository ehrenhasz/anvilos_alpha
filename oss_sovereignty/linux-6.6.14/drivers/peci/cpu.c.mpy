{
  "module_name": "cpu.c",
  "hash_id": "7e842f1e1b6774d060387b520b9f46c0cd4aafca310550a07d40116413183ea6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/peci/cpu.c",
  "human_readable_source": "\n\n\n#include <linux/auxiliary_bus.h>\n#include <linux/module.h>\n#include <linux/peci.h>\n#include <linux/peci-cpu.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\n \nint peci_temp_read(struct peci_device *device, s16 *temp_raw)\n{\n\tstruct peci_request *req;\n\n\treq = peci_xfer_get_temp(device);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t*temp_raw = peci_request_temp_read(req);\n\n\tpeci_request_free(req);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(peci_temp_read, PECI_CPU);\n\n \nint peci_pcs_read(struct peci_device *device, u8 index, u16 param, u32 *data)\n{\n\tstruct peci_request *req;\n\tint ret;\n\n\treq = peci_xfer_pkg_cfg_readl(device, index, param);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = peci_request_status(req);\n\tif (ret)\n\t\tgoto out_req_free;\n\n\t*data = peci_request_data_readl(req);\nout_req_free:\n\tpeci_request_free(req);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(peci_pcs_read, PECI_CPU);\n\n \nint peci_pci_local_read(struct peci_device *device, u8 bus, u8 dev, u8 func,\n\t\t\tu16 reg, u32 *data)\n{\n\tstruct peci_request *req;\n\tint ret;\n\n\treq = peci_xfer_pci_cfg_local_readl(device, bus, dev, func, reg);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = peci_request_status(req);\n\tif (ret)\n\t\tgoto out_req_free;\n\n\t*data = peci_request_data_readl(req);\nout_req_free:\n\tpeci_request_free(req);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(peci_pci_local_read, PECI_CPU);\n\n \nint peci_ep_pci_local_read(struct peci_device *device, u8 seg,\n\t\t\t   u8 bus, u8 dev, u8 func, u16 reg, u32 *data)\n{\n\tstruct peci_request *req;\n\tint ret;\n\n\treq = peci_xfer_ep_pci_cfg_local_readl(device, seg, bus, dev, func, reg);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = peci_request_status(req);\n\tif (ret)\n\t\tgoto out_req_free;\n\n\t*data = peci_request_data_readl(req);\nout_req_free:\n\tpeci_request_free(req);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(peci_ep_pci_local_read, PECI_CPU);\n\n \nint peci_mmio_read(struct peci_device *device, u8 bar, u8 seg,\n\t\t   u8 bus, u8 dev, u8 func, u64 address, u32 *data)\n{\n\tstruct peci_request *req;\n\tint ret;\n\n\treq = peci_xfer_ep_mmio64_readl(device, bar, seg, bus, dev, func, address);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = peci_request_status(req);\n\tif (ret)\n\t\tgoto out_req_free;\n\n\t*data = peci_request_data_readl(req);\nout_req_free:\n\tpeci_request_free(req);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(peci_mmio_read, PECI_CPU);\n\nstatic const char * const peci_adev_types[] = {\n\t\"cputemp\",\n\t\"dimmtemp\",\n};\n\nstruct peci_cpu {\n\tstruct peci_device *device;\n\tconst struct peci_device_id *id;\n};\n\nstatic void adev_release(struct device *dev)\n{\n\tstruct auxiliary_device *adev = to_auxiliary_dev(dev);\n\n\tkfree(adev->name);\n\tkfree(adev);\n}\n\nstatic struct auxiliary_device *adev_alloc(struct peci_cpu *priv, int idx)\n{\n\tstruct peci_controller *controller = to_peci_controller(priv->device->dev.parent);\n\tstruct auxiliary_device *adev;\n\tconst char *name;\n\tint ret;\n\n\tadev = kzalloc(sizeof(*adev), GFP_KERNEL);\n\tif (!adev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tname = kasprintf(GFP_KERNEL, \"%s.%s\", peci_adev_types[idx], (const char *)priv->id->data);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto free_adev;\n\t}\n\n\tadev->name = name;\n\tadev->dev.parent = &priv->device->dev;\n\tadev->dev.release = adev_release;\n\tadev->id = (controller->id << 16) | (priv->device->addr);\n\n\tret = auxiliary_device_init(adev);\n\tif (ret)\n\t\tgoto free_name;\n\n\treturn adev;\n\nfree_name:\n\tkfree(name);\nfree_adev:\n\tkfree(adev);\n\treturn ERR_PTR(ret);\n}\n\nstatic void unregister_adev(void *_adev)\n{\n\tstruct auxiliary_device *adev = _adev;\n\n\tauxiliary_device_delete(adev);\n\tauxiliary_device_uninit(adev);\n}\n\nstatic int devm_adev_add(struct device *dev, int idx)\n{\n\tstruct peci_cpu *priv = dev_get_drvdata(dev);\n\tstruct auxiliary_device *adev;\n\tint ret;\n\n\tadev = adev_alloc(priv, idx);\n\tif (IS_ERR(adev))\n\t\treturn PTR_ERR(adev);\n\n\tret = auxiliary_device_add(adev);\n\tif (ret) {\n\t\tauxiliary_device_uninit(adev);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&priv->device->dev, unregister_adev, adev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void peci_cpu_add_adevices(struct peci_cpu *priv)\n{\n\tstruct device *dev = &priv->device->dev;\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(peci_adev_types); i++) {\n\t\tret = devm_adev_add(dev, i);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Failed to register PECI auxiliary: %s, ret = %d\\n\",\n\t\t\t\t peci_adev_types[i], ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic int\npeci_cpu_probe(struct peci_device *device, const struct peci_device_id *id)\n{\n\tstruct device *dev = &device->dev;\n\tstruct peci_cpu *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\tpriv->device = device;\n\tpriv->id = id;\n\n\tpeci_cpu_add_adevices(priv);\n\n\treturn 0;\n}\n\nstatic const struct peci_device_id peci_cpu_device_ids[] = {\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_HASWELL_X,\n\t\t.data\t= \"hsx\",\n\t},\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_BROADWELL_X,\n\t\t.data\t= \"bdx\",\n\t},\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_BROADWELL_D,\n\t\t.data\t= \"bdxd\",\n\t},\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_SKYLAKE_X,\n\t\t.data\t= \"skx\",\n\t},\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_ICELAKE_X,\n\t\t.data\t= \"icx\",\n\t},\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_ICELAKE_D,\n\t\t.data\t= \"icxd\",\n\t},\n\t{  \n\t\t.family\t= 6,\n\t\t.model\t= INTEL_FAM6_SAPPHIRERAPIDS_X,\n\t\t.data\t= \"spr\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(peci, peci_cpu_device_ids);\n\nstatic struct peci_driver peci_cpu_driver = {\n\t.probe\t\t= peci_cpu_probe,\n\t.id_table\t= peci_cpu_device_ids,\n\t.driver\t\t= {\n\t\t.name\t\t= \"peci-cpu\",\n\t},\n};\nmodule_peci_driver(peci_cpu_driver);\n\nMODULE_AUTHOR(\"Iwona Winiarska <iwona.winiarska@intel.com>\");\nMODULE_DESCRIPTION(\"PECI CPU driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PECI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}