{
  "module_name": "core.c",
  "hash_id": "1da2ec49cb59a3fc2829c459b57eb91222235dbd22d76cc19a7717aeb535ccf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/peci/core.c",
  "human_readable_source": "\n\n\n#include <linux/bug.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/peci.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstatic DEFINE_IDA(peci_controller_ida);\n\nstatic void peci_controller_dev_release(struct device *dev)\n{\n\tstruct peci_controller *controller = to_peci_controller(dev);\n\n\tmutex_destroy(&controller->bus_lock);\n\tida_free(&peci_controller_ida, controller->id);\n\tkfree(controller);\n}\n\nstruct device_type peci_controller_type = {\n\t.release\t= peci_controller_dev_release,\n};\n\nint peci_controller_scan_devices(struct peci_controller *controller)\n{\n\tint ret;\n\tu8 addr;\n\n\tfor (addr = PECI_BASE_ADDR; addr < PECI_BASE_ADDR + PECI_DEVICE_NUM_MAX; addr++) {\n\t\tret = peci_device_create(controller, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct peci_controller *peci_controller_alloc(struct device *dev,\n\t\t\t\t\t\t     const struct peci_controller_ops *ops)\n{\n\tstruct peci_controller *controller;\n\tint ret;\n\n\tif (!ops->xfer)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\n\tif (!controller)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ida_alloc_max(&peci_controller_ida, U8_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err;\n\tcontroller->id = ret;\n\n\tcontroller->ops = ops;\n\n\tcontroller->dev.parent = dev;\n\tcontroller->dev.bus = &peci_bus_type;\n\tcontroller->dev.type = &peci_controller_type;\n\n\tdevice_initialize(&controller->dev);\n\n\tmutex_init(&controller->bus_lock);\n\n\treturn controller;\n\nerr:\n\tkfree(controller);\n\treturn ERR_PTR(ret);\n}\n\nstatic int unregister_child(struct device *dev, void *dummy)\n{\n\tpeci_device_destroy(to_peci_device(dev));\n\n\treturn 0;\n}\n\nstatic void unregister_controller(void *_controller)\n{\n\tstruct peci_controller *controller = _controller;\n\n\t \n\tdevice_for_each_child_reverse(&controller->dev, NULL, unregister_child);\n\n\tdevice_unregister(&controller->dev);\n\n\tfwnode_handle_put(controller->dev.fwnode);\n\n\tpm_runtime_disable(&controller->dev);\n}\n\n \nstruct peci_controller *devm_peci_controller_add(struct device *dev,\n\t\t\t\t\t\t const struct peci_controller_ops *ops)\n{\n\tstruct peci_controller *controller;\n\tint ret;\n\n\tcontroller = peci_controller_alloc(dev, ops);\n\tif (IS_ERR(controller))\n\t\treturn controller;\n\n\tret = dev_set_name(&controller->dev, \"peci-%d\", controller->id);\n\tif (ret)\n\t\tgoto err_put;\n\n\tpm_runtime_no_callbacks(&controller->dev);\n\tpm_suspend_ignore_children(&controller->dev, true);\n\tpm_runtime_enable(&controller->dev);\n\n\tdevice_set_node(&controller->dev, fwnode_handle_get(dev_fwnode(dev)));\n\n\tret = device_add(&controller->dev);\n\tif (ret)\n\t\tgoto err_fwnode;\n\n\tret = devm_add_action_or_reset(dev, unregister_controller, controller);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tpeci_controller_scan_devices(controller);\n\n\treturn controller;\n\nerr_fwnode:\n\tfwnode_handle_put(controller->dev.fwnode);\n\n\tpm_runtime_disable(&controller->dev);\n\nerr_put:\n\tput_device(&controller->dev);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_NS_GPL(devm_peci_controller_add, PECI);\n\nstatic const struct peci_device_id *\npeci_bus_match_device_id(const struct peci_device_id *id, struct peci_device *device)\n{\n\twhile (id->family != 0) {\n\t\tif (id->family == device->info.family &&\n\t\t    id->model == device->info.model)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int peci_bus_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct peci_device *device = to_peci_device(dev);\n\tstruct peci_driver *peci_drv = to_peci_driver(drv);\n\n\tif (dev->type != &peci_device_type)\n\t\treturn 0;\n\n\treturn !!peci_bus_match_device_id(peci_drv->id_table, device);\n}\n\nstatic int peci_bus_device_probe(struct device *dev)\n{\n\tstruct peci_device *device = to_peci_device(dev);\n\tstruct peci_driver *driver = to_peci_driver(dev->driver);\n\n\treturn driver->probe(device, peci_bus_match_device_id(driver->id_table, device));\n}\n\nstatic void peci_bus_device_remove(struct device *dev)\n{\n\tstruct peci_device *device = to_peci_device(dev);\n\tstruct peci_driver *driver = to_peci_driver(dev->driver);\n\n\tif (driver->remove)\n\t\tdriver->remove(device);\n}\n\nstruct bus_type peci_bus_type = {\n\t.name\t\t= \"peci\",\n\t.match\t\t= peci_bus_device_match,\n\t.probe\t\t= peci_bus_device_probe,\n\t.remove\t\t= peci_bus_device_remove,\n\t.bus_groups\t= peci_bus_groups,\n};\n\nstatic int __init peci_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&peci_bus_type);\n\tif (ret < 0) {\n\t\tpr_err(\"peci: failed to register PECI bus type!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(peci_init);\n\nstatic void __exit peci_exit(void)\n{\n\tbus_unregister(&peci_bus_type);\n}\nmodule_exit(peci_exit);\n\nMODULE_AUTHOR(\"Jason M Bills <jason.m.bills@linux.intel.com>\");\nMODULE_AUTHOR(\"Jae Hyun Yoo <jae.hyun.yoo@linux.intel.com>\");\nMODULE_AUTHOR(\"Iwona Winiarska <iwona.winiarska@intel.com>\");\nMODULE_DESCRIPTION(\"PECI bus core module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}