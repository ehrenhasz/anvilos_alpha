{
  "module_name": "peci-aspeed.c",
  "hash_id": "79579c6311376555edea4390eaf67a4d6e605156bfd92b42e185e399e4fd3b15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/peci/controller/peci-aspeed.c",
  "human_readable_source": "\n\n\n\n#include <asm/unaligned.h>\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/jiffies.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/peci.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n \n \n#define ASPEED_PECI_CTRL\t\t\t0x00\n#define   ASPEED_PECI_CTRL_SAMPLING_MASK\tGENMASK(19, 16)\n#define   ASPEED_PECI_CTRL_RD_MODE_MASK\t\tGENMASK(13, 12)\n#define     ASPEED_PECI_CTRL_RD_MODE_DBG\tBIT(13)\n#define     ASPEED_PECI_CTRL_RD_MODE_COUNT\tBIT(12)\n#define   ASPEED_PECI_CTRL_CLK_SRC_HCLK\t\tBIT(11)\n#define   ASPEED_PECI_CTRL_CLK_DIV_MASK\t\tGENMASK(10, 8)\n#define   ASPEED_PECI_CTRL_INVERT_OUT\t\tBIT(7)\n#define   ASPEED_PECI_CTRL_INVERT_IN\t\tBIT(6)\n#define   ASPEED_PECI_CTRL_BUS_CONTENTION_EN\tBIT(5)\n#define   ASPEED_PECI_CTRL_PECI_EN\t\tBIT(4)\n#define   ASPEED_PECI_CTRL_PECI_CLK_EN\t\tBIT(0)\n\n \n#define ASPEED_PECI_TIMING_NEGOTIATION\t\t0x04\n#define   ASPEED_PECI_T_NEGO_MSG_MASK\t\tGENMASK(15, 8)\n#define   ASPEED_PECI_T_NEGO_ADDR_MASK\t\tGENMASK(7, 0)\n\n \n#define ASPEED_PECI_CMD\t\t\t\t0x08\n#define   ASPEED_PECI_CMD_PIN_MONITORING\tBIT(31)\n#define   ASPEED_PECI_CMD_STS_MASK\t\tGENMASK(27, 24)\n#define     ASPEED_PECI_CMD_STS_ADDR_T_NEGO\t0x3\n#define   ASPEED_PECI_CMD_IDLE_MASK\t\t\\\n\t  (ASPEED_PECI_CMD_STS_MASK | ASPEED_PECI_CMD_PIN_MONITORING)\n#define   ASPEED_PECI_CMD_FIRE\t\t\tBIT(0)\n\n \n#define ASPEED_PECI_RW_LENGTH\t\t\t0x0c\n#define   ASPEED_PECI_AW_FCS_EN\t\t\tBIT(31)\n#define   ASPEED_PECI_RD_LEN_MASK\t\tGENMASK(23, 16)\n#define   ASPEED_PECI_WR_LEN_MASK\t\tGENMASK(15, 8)\n#define   ASPEED_PECI_TARGET_ADDR_MASK\t\tGENMASK(7, 0)\n\n \n#define ASPEED_PECI_EXPECTED_FCS\t\t0x10\n#define   ASPEED_PECI_EXPECTED_RD_FCS_MASK\tGENMASK(23, 16)\n#define   ASPEED_PECI_EXPECTED_AW_FCS_AUTO_MASK\tGENMASK(15, 8)\n#define   ASPEED_PECI_EXPECTED_WR_FCS_MASK\tGENMASK(7, 0)\n\n \n#define ASPEED_PECI_CAPTURED_FCS\t\t0x14\n#define   ASPEED_PECI_CAPTURED_RD_FCS_MASK\tGENMASK(23, 16)\n#define   ASPEED_PECI_CAPTURED_WR_FCS_MASK\tGENMASK(7, 0)\n\n \n#define ASPEED_PECI_INT_CTRL\t\t\t0x18\n#define   ASPEED_PECI_TIMING_NEGO_SEL_MASK\tGENMASK(31, 30)\n#define     ASPEED_PECI_1ST_BIT_OF_ADDR_NEGO\t0\n#define     ASPEED_PECI_2ND_BIT_OF_ADDR_NEGO\t1\n#define     ASPEED_PECI_MESSAGE_NEGO\t\t2\n#define   ASPEED_PECI_INT_MASK\t\t\tGENMASK(4, 0)\n#define     ASPEED_PECI_INT_BUS_TIMEOUT\t\tBIT(4)\n#define     ASPEED_PECI_INT_BUS_CONTENTION\tBIT(3)\n#define     ASPEED_PECI_INT_WR_FCS_BAD\t\tBIT(2)\n#define     ASPEED_PECI_INT_WR_FCS_ABORT\tBIT(1)\n#define     ASPEED_PECI_INT_CMD_DONE\t\tBIT(0)\n\n \n#define ASPEED_PECI_INT_STS\t\t\t0x1c\n#define   ASPEED_PECI_INT_TIMING_RESULT_MASK\tGENMASK(29, 16)\n\t   \n\n \n#define ASPEED_PECI_WR_DATA0\t\t\t0x20\n#define ASPEED_PECI_WR_DATA1\t\t\t0x24\n#define ASPEED_PECI_WR_DATA2\t\t\t0x28\n#define ASPEED_PECI_WR_DATA3\t\t\t0x2c\n#define ASPEED_PECI_RD_DATA0\t\t\t0x30\n#define ASPEED_PECI_RD_DATA1\t\t\t0x34\n#define ASPEED_PECI_RD_DATA2\t\t\t0x38\n#define ASPEED_PECI_RD_DATA3\t\t\t0x3c\n#define ASPEED_PECI_WR_DATA4\t\t\t0x40\n#define ASPEED_PECI_WR_DATA5\t\t\t0x44\n#define ASPEED_PECI_WR_DATA6\t\t\t0x48\n#define ASPEED_PECI_WR_DATA7\t\t\t0x4c\n#define ASPEED_PECI_RD_DATA4\t\t\t0x50\n#define ASPEED_PECI_RD_DATA5\t\t\t0x54\n#define ASPEED_PECI_RD_DATA6\t\t\t0x58\n#define ASPEED_PECI_RD_DATA7\t\t\t0x5c\n#define   ASPEED_PECI_DATA_BUF_SIZE_MAX\t\t32\n\n \n#define ASPEED_PECI_CLK_FREQUENCY_MIN\t\t2000\n#define ASPEED_PECI_CLK_FREQUENCY_DEFAULT\t1000000\n#define ASPEED_PECI_CLK_FREQUENCY_MAX\t\t2000000\n#define ASPEED_PECI_RD_SAMPLING_POINT_DEFAULT\t8\n \n#define ASPEED_PECI_IDLE_CHECK_TIMEOUT_US\t(50 * USEC_PER_MSEC)\n#define ASPEED_PECI_IDLE_CHECK_INTERVAL_US\t(10 * USEC_PER_MSEC)\n#define ASPEED_PECI_CMD_TIMEOUT_MS_DEFAULT\t1000\n#define ASPEED_PECI_CMD_TIMEOUT_MS_MAX\t\t1000\n\n#define ASPEED_PECI_CLK_DIV1(msg_timing) (4 * (msg_timing) + 1)\n#define ASPEED_PECI_CLK_DIV2(clk_div_exp) BIT(clk_div_exp)\n#define ASPEED_PECI_CLK_DIV(msg_timing, clk_div_exp) \\\n\t(4 * ASPEED_PECI_CLK_DIV1(msg_timing) * ASPEED_PECI_CLK_DIV2(clk_div_exp))\n\nstruct aspeed_peci {\n\tstruct peci_controller *controller;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct reset_control *rst;\n\tint irq;\n\tspinlock_t lock;  \n\tstruct completion xfer_complete;\n\tstruct clk *clk;\n\tu32 clk_frequency;\n\tu32 status;\n\tu32 cmd_timeout_ms;\n};\n\nstruct clk_aspeed_peci {\n\tstruct clk_hw hw;\n\tstruct aspeed_peci *aspeed_peci;\n};\n\nstatic void aspeed_peci_controller_enable(struct aspeed_peci *priv)\n{\n\tu32 val = readl(priv->base + ASPEED_PECI_CTRL);\n\n\tval |= ASPEED_PECI_CTRL_PECI_CLK_EN;\n\tval |= ASPEED_PECI_CTRL_PECI_EN;\n\n\twritel(val, priv->base + ASPEED_PECI_CTRL);\n}\n\nstatic void aspeed_peci_init_regs(struct aspeed_peci *priv)\n{\n\tu32 val;\n\n\t \n\twritel(ASPEED_PECI_INT_MASK, priv->base + ASPEED_PECI_INT_STS);\n\n\t \n\tval = FIELD_PREP(ASPEED_PECI_TIMING_NEGO_SEL_MASK, ASPEED_PECI_1ST_BIT_OF_ADDR_NEGO);\n\tval |= ASPEED_PECI_INT_MASK;\n\twritel(val, priv->base + ASPEED_PECI_INT_CTRL);\n\n\tval = FIELD_PREP(ASPEED_PECI_CTRL_SAMPLING_MASK, ASPEED_PECI_RD_SAMPLING_POINT_DEFAULT);\n\twritel(val, priv->base + ASPEED_PECI_CTRL);\n}\n\nstatic int aspeed_peci_check_idle(struct aspeed_peci *priv)\n{\n\tu32 cmd_sts = readl(priv->base + ASPEED_PECI_CMD);\n\tint ret;\n\n\t \n\tif (FIELD_GET(ASPEED_PECI_CMD_STS_MASK, cmd_sts)) {\n\t\tret = reset_control_assert(priv->rst);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"cannot assert reset control\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = reset_control_deassert(priv->rst);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"cannot deassert reset control\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\taspeed_peci_init_regs(priv);\n\n\t\tret = clk_set_rate(priv->clk, priv->clk_frequency);\n\t\tif (ret < 0) {\n\t\t\tdev_err(priv->dev, \"cannot set clock frequency\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\taspeed_peci_controller_enable(priv);\n\t}\n\n\treturn readl_poll_timeout(priv->base + ASPEED_PECI_CMD,\n\t\t\t\t  cmd_sts,\n\t\t\t\t  !(cmd_sts & ASPEED_PECI_CMD_IDLE_MASK),\n\t\t\t\t  ASPEED_PECI_IDLE_CHECK_INTERVAL_US,\n\t\t\t\t  ASPEED_PECI_IDLE_CHECK_TIMEOUT_US);\n}\n\nstatic int aspeed_peci_xfer(struct peci_controller *controller,\n\t\t\t    u8 addr, struct peci_request *req)\n{\n\tstruct aspeed_peci *priv = dev_get_drvdata(controller->dev.parent);\n\tunsigned long timeout = msecs_to_jiffies(priv->cmd_timeout_ms);\n\tu32 peci_head;\n\tint ret, i;\n\n\tif (req->tx.len > ASPEED_PECI_DATA_BUF_SIZE_MAX ||\n\t    req->rx.len > ASPEED_PECI_DATA_BUF_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tret = aspeed_peci_check_idle(priv);\n\tif (ret)\n\t\treturn ret;  \n\n\tspin_lock_irq(&priv->lock);\n\treinit_completion(&priv->xfer_complete);\n\n\tpeci_head = FIELD_PREP(ASPEED_PECI_TARGET_ADDR_MASK, addr) |\n\t\t    FIELD_PREP(ASPEED_PECI_WR_LEN_MASK, req->tx.len) |\n\t\t    FIELD_PREP(ASPEED_PECI_RD_LEN_MASK, req->rx.len);\n\n\twritel(peci_head, priv->base + ASPEED_PECI_RW_LENGTH);\n\n\tfor (i = 0; i < req->tx.len; i += 4) {\n\t\tu32 reg = (i < 16 ? ASPEED_PECI_WR_DATA0 : ASPEED_PECI_WR_DATA4) + i % 16;\n\n\t\twritel(get_unaligned_le32(&req->tx.buf[i]), priv->base + reg);\n\t}\n\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG)\n\tdev_dbg(priv->dev, \"HEAD : %#08x\\n\", peci_head);\n\tprint_hex_dump_bytes(\"TX : \", DUMP_PREFIX_NONE, req->tx.buf, req->tx.len);\n#endif\n\n\tpriv->status = 0;\n\twritel(ASPEED_PECI_CMD_FIRE, priv->base + ASPEED_PECI_CMD);\n\tspin_unlock_irq(&priv->lock);\n\n\tret = wait_for_completion_interruptible_timeout(&priv->xfer_complete, timeout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tdev_dbg(priv->dev, \"timeout waiting for a response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tspin_lock_irq(&priv->lock);\n\n\tif (priv->status != ASPEED_PECI_INT_CMD_DONE) {\n\t\tspin_unlock_irq(&priv->lock);\n\t\tdev_dbg(priv->dev, \"no valid response, status: %#02x\\n\", priv->status);\n\t\treturn -EIO;\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\n\t \n\tBUILD_BUG_ON(PECI_REQUEST_MAX_BUF_SIZE % 4);\n\n\tfor (i = 0; i < req->rx.len; i += 4) {\n\t\tu32 reg = (i < 16 ? ASPEED_PECI_RD_DATA0 : ASPEED_PECI_RD_DATA4) + i % 16;\n\t\tu32 rx_data = readl(priv->base + reg);\n\n\t\tput_unaligned_le32(rx_data, &req->rx.buf[i]);\n\t}\n\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG)\n\tprint_hex_dump_bytes(\"RX : \", DUMP_PREFIX_NONE, req->rx.buf, req->rx.len);\n#endif\n\treturn 0;\n}\n\nstatic irqreturn_t aspeed_peci_irq_handler(int irq, void *arg)\n{\n\tstruct aspeed_peci *priv = arg;\n\tu32 status;\n\n\tspin_lock(&priv->lock);\n\tstatus = readl(priv->base + ASPEED_PECI_INT_STS);\n\twritel(status, priv->base + ASPEED_PECI_INT_STS);\n\tpriv->status |= (status & ASPEED_PECI_INT_MASK);\n\n\t \n\tif (status & ASPEED_PECI_INT_CMD_DONE)\n\t\tcomplete(&priv->xfer_complete);\n\n\twritel(0, priv->base + ASPEED_PECI_CMD);\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void clk_aspeed_peci_find_div_values(unsigned long rate, int *msg_timing, int *clk_div_exp)\n{\n\tunsigned long best_diff = ~0ul, diff;\n\tint msg_timing_temp, clk_div_exp_temp, i, j;\n\n\tfor (i = 1; i <= 255; i++)\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tdiff = abs(rate - ASPEED_PECI_CLK_DIV1(i) * ASPEED_PECI_CLK_DIV2(j));\n\t\t\tif (diff < best_diff) {\n\t\t\t\tmsg_timing_temp = i;\n\t\t\t\tclk_div_exp_temp = j;\n\t\t\t\tbest_diff = diff;\n\t\t\t}\n\t\t}\n\n\t*msg_timing = msg_timing_temp;\n\t*clk_div_exp = clk_div_exp_temp;\n}\n\nstatic int clk_aspeed_peci_get_div(unsigned long rate, const unsigned long *prate)\n{\n\tunsigned long this_rate = *prate / (4 * rate);\n\tint msg_timing, clk_div_exp;\n\n\tclk_aspeed_peci_find_div_values(this_rate, &msg_timing, &clk_div_exp);\n\n\treturn ASPEED_PECI_CLK_DIV(msg_timing, clk_div_exp);\n}\n\nstatic int clk_aspeed_peci_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long prate)\n{\n\tstruct clk_aspeed_peci *peci_clk = container_of(hw, struct clk_aspeed_peci, hw);\n\tstruct aspeed_peci *aspeed_peci = peci_clk->aspeed_peci;\n\tunsigned long this_rate = prate / (4 * rate);\n\tint clk_div_exp, msg_timing;\n\tu32 val;\n\n\tclk_aspeed_peci_find_div_values(this_rate, &msg_timing, &clk_div_exp);\n\n\tval = readl(aspeed_peci->base + ASPEED_PECI_CTRL);\n\tval |= FIELD_PREP(ASPEED_PECI_CTRL_CLK_DIV_MASK, clk_div_exp);\n\twritel(val, aspeed_peci->base + ASPEED_PECI_CTRL);\n\n\tval = FIELD_PREP(ASPEED_PECI_T_NEGO_MSG_MASK, msg_timing);\n\tval |= FIELD_PREP(ASPEED_PECI_T_NEGO_ADDR_MASK, msg_timing);\n\twritel(val, aspeed_peci->base + ASPEED_PECI_TIMING_NEGOTIATION);\n\n\treturn 0;\n}\n\nstatic long clk_aspeed_peci_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\tint div = clk_aspeed_peci_get_div(rate, prate);\n\n\treturn DIV_ROUND_UP_ULL(*prate, div);\n}\n\nstatic unsigned long clk_aspeed_peci_recalc_rate(struct clk_hw *hw, unsigned long prate)\n{\n\tstruct clk_aspeed_peci *peci_clk = container_of(hw, struct clk_aspeed_peci, hw);\n\tstruct aspeed_peci *aspeed_peci = peci_clk->aspeed_peci;\n\tint div, msg_timing, addr_timing, clk_div_exp;\n\tu32 reg;\n\n\treg = readl(aspeed_peci->base + ASPEED_PECI_TIMING_NEGOTIATION);\n\tmsg_timing = FIELD_GET(ASPEED_PECI_T_NEGO_MSG_MASK, reg);\n\taddr_timing = FIELD_GET(ASPEED_PECI_T_NEGO_ADDR_MASK, reg);\n\n\tif (msg_timing != addr_timing)\n\t\treturn 0;\n\n\treg = readl(aspeed_peci->base + ASPEED_PECI_CTRL);\n\tclk_div_exp = FIELD_GET(ASPEED_PECI_CTRL_CLK_DIV_MASK, reg);\n\n\tdiv = ASPEED_PECI_CLK_DIV(msg_timing, clk_div_exp);\n\n\treturn DIV_ROUND_UP_ULL(prate, div);\n}\n\nstatic const struct clk_ops clk_aspeed_peci_ops = {\n\t.set_rate = clk_aspeed_peci_set_rate,\n\t.round_rate = clk_aspeed_peci_round_rate,\n\t.recalc_rate = clk_aspeed_peci_recalc_rate,\n};\n\n \nstatic struct clk *devm_aspeed_peci_register_clk_div(struct device *dev, struct clk *parent,\n\t\t\t\t\t\t     struct aspeed_peci *priv)\n{\n\tstruct clk_aspeed_peci *peci_clk;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tchar name[32];\n\tint ret;\n\n\tsnprintf(name, sizeof(name), \"%s_div\", dev_name(dev));\n\n\tparent_name = __clk_get_name(parent);\n\n\tinit.ops = &clk_aspeed_peci_ops;\n\tinit.name = name;\n\tinit.parent_names = (const char* []) { parent_name };\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tpeci_clk = devm_kzalloc(dev, sizeof(struct clk_aspeed_peci), GFP_KERNEL);\n\tif (!peci_clk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpeci_clk->hw.init = &init;\n\tpeci_clk->aspeed_peci = priv;\n\n\tret = devm_clk_hw_register(dev, &peci_clk->hw);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn peci_clk->hw.clk;\n}\n\nstatic void aspeed_peci_property_sanitize(struct device *dev, const char *propname,\n\t\t\t\t\t  u32 min, u32 max, u32 default_val, u32 *propval)\n{\n\tu32 val;\n\tint ret;\n\n\tret = device_property_read_u32(dev, propname, &val);\n\tif (ret) {\n\t\tval = default_val;\n\t} else if (val > max || val < min) {\n\t\tdev_warn(dev, \"invalid %s: %u, falling back to: %u\\n\",\n\t\t\t propname, val, default_val);\n\n\t\tval = default_val;\n\t}\n\n\t*propval = val;\n}\n\nstatic void aspeed_peci_property_setup(struct aspeed_peci *priv)\n{\n\taspeed_peci_property_sanitize(priv->dev, \"clock-frequency\",\n\t\t\t\t      ASPEED_PECI_CLK_FREQUENCY_MIN, ASPEED_PECI_CLK_FREQUENCY_MAX,\n\t\t\t\t      ASPEED_PECI_CLK_FREQUENCY_DEFAULT, &priv->clk_frequency);\n\taspeed_peci_property_sanitize(priv->dev, \"cmd-timeout-ms\",\n\t\t\t\t      1, ASPEED_PECI_CMD_TIMEOUT_MS_MAX,\n\t\t\t\t      ASPEED_PECI_CMD_TIMEOUT_MS_DEFAULT, &priv->cmd_timeout_ms);\n}\n\nstatic const struct peci_controller_ops aspeed_ops = {\n\t.xfer = aspeed_peci_xfer,\n};\n\nstatic void aspeed_peci_reset_control_release(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int devm_aspeed_peci_reset_control_deassert(struct device *dev, struct reset_control *rst)\n{\n\tint ret;\n\n\tret = reset_control_deassert(rst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, aspeed_peci_reset_control_release, rst);\n}\n\nstatic void aspeed_peci_clk_release(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int devm_aspeed_peci_clk_enable(struct device *dev, struct clk *clk)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, aspeed_peci_clk_release, clk);\n}\n\nstatic int aspeed_peci_probe(struct platform_device *pdev)\n{\n\tstruct peci_controller *controller;\n\tstruct aspeed_peci *priv;\n\tstruct clk *ref_clk;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tdev_set_drvdata(priv->dev, priv);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tret = devm_request_irq(&pdev->dev, priv->irq, aspeed_peci_irq_handler,\n\t\t\t       0, \"peci-aspeed\", priv);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_completion(&priv->xfer_complete);\n\tspin_lock_init(&priv->lock);\n\n\tpriv->rst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rst))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(priv->rst),\n\t\t\t\t     \"failed to get reset control\\n\");\n\n\tret = devm_aspeed_peci_reset_control_deassert(priv->dev, priv->rst);\n\tif (ret)\n\t\treturn dev_err_probe(priv->dev, ret, \"cannot deassert reset control\\n\");\n\n\taspeed_peci_property_setup(priv);\n\n\taspeed_peci_init_regs(priv);\n\n\tref_clk = devm_clk_get(priv->dev, NULL);\n\tif (IS_ERR(ref_clk))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(ref_clk), \"failed to get ref clock\\n\");\n\n\tpriv->clk = devm_aspeed_peci_register_clk_div(priv->dev, ref_clk, priv);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(priv->clk), \"cannot register clock\\n\");\n\n\tret = clk_set_rate(priv->clk, priv->clk_frequency);\n\tif (ret < 0)\n\t\treturn dev_err_probe(priv->dev, ret, \"cannot set clock frequency\\n\");\n\n\tret = devm_aspeed_peci_clk_enable(priv->dev, priv->clk);\n\tif (ret)\n\t\treturn dev_err_probe(priv->dev, ret, \"failed to enable clock\\n\");\n\n\taspeed_peci_controller_enable(priv);\n\n\tcontroller = devm_peci_controller_add(priv->dev, &aspeed_ops);\n\tif (IS_ERR(controller))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(controller),\n\t\t\t\t     \"failed to add aspeed peci controller\\n\");\n\n\tpriv->controller = controller;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id aspeed_peci_of_table[] = {\n\t{ .compatible = \"aspeed,ast2400-peci\", },\n\t{ .compatible = \"aspeed,ast2500-peci\", },\n\t{ .compatible = \"aspeed,ast2600-peci\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, aspeed_peci_of_table);\n\nstatic struct platform_driver aspeed_peci_driver = {\n\t.probe  = aspeed_peci_probe,\n\t.driver = {\n\t\t.name           = \"peci-aspeed\",\n\t\t.of_match_table = aspeed_peci_of_table,\n\t},\n};\nmodule_platform_driver(aspeed_peci_driver);\n\nMODULE_AUTHOR(\"Ryan Chen <ryan_chen@aspeedtech.com>\");\nMODULE_AUTHOR(\"Jae Hyun Yoo <jae.hyun.yoo@linux.intel.com>\");\nMODULE_DESCRIPTION(\"ASPEED PECI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PECI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}