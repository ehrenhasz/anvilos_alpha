{
  "module_name": "peci-npcm.c",
  "hash_id": "a27a41a4ebb68b81999ae0439f4e10817e95d67a259faca3dc7a82b58f824fa1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/peci/controller/peci-npcm.c",
  "human_readable_source": "\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/peci.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define NPCM_INTCR3_OFFSET\t0x9C\n#define NPCM_INTCR3_PECIVSEL\tBIT(19)\n\n \n#define NPCM_PECI_CTL_STS\t0x00\n#define NPCM_PECI_RD_LENGTH\t0x04\n#define NPCM_PECI_ADDR\t\t0x08\n#define NPCM_PECI_CMD\t\t0x0C\n#define NPCM_PECI_CTL2\t\t0x10\n#define NPCM_PECI_WR_LENGTH\t0x1C\n#define NPCM_PECI_PDDR\t\t0x2C\n#define NPCM_PECI_DAT_INOUT(n)\t(0x100 + ((n) * 4))\n\n#define NPCM_PECI_MAX_REG\t0x200\n\n \n#define NPCM_PECI_CTRL_DONE_INT_EN\tBIT(6)\n#define NPCM_PECI_CTRL_ABRT_ERR\t\tBIT(4)\n#define NPCM_PECI_CTRL_CRC_ERR\t\tBIT(3)\n#define NPCM_PECI_CTRL_DONE\t\tBIT(1)\n#define NPCM_PECI_CTRL_START_BUSY\tBIT(0)\n\n \n#define NPCM_PECI_RD_LEN_MASK\t\tGENMASK(6, 0)\n\n \n#define NPCM_PECI_CTL2_MASK\t\tGENMASK(7, 6)\n\n \n#define NPCM_PECI_WR_LEN_MASK\t\tGENMASK(6, 0)\n\n \n#define NPCM_PECI_PDDR_MASK\t\tGENMASK(4, 0)\n\n#define NPCM_PECI_INT_MASK\t\t(NPCM_PECI_CTRL_ABRT_ERR | \\\n\t\t\t\t\t NPCM_PECI_CTRL_CRC_ERR  | \\\n\t\t\t\t\t NPCM_PECI_CTRL_DONE)\n\n#define NPCM_PECI_IDLE_CHECK_TIMEOUT_USEC\t(50 * USEC_PER_MSEC)\n#define NPCM_PECI_IDLE_CHECK_INTERVAL_USEC\t(10 * USEC_PER_MSEC)\n#define NPCM_PECI_CMD_TIMEOUT_MS_DEFAULT\t1000\n#define NPCM_PECI_CMD_TIMEOUT_MS_MAX\t\t60000\n#define NPCM_PECI_HOST_NEG_BIT_RATE_DEFAULT\t15\n#define NPCM_PECI_PULL_DOWN_DEFAULT\t\t0\n\nstruct npcm_peci {\n\tu32\t\t\tcmd_timeout_ms;\n\tstruct completion\txfer_complete;\n\tstruct regmap\t\t*regmap;\n\tu32\t\t\tstatus;\n\tspinlock_t\t\tlock;  \n\tstruct peci_controller *controller;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tint\t\t\tirq;\n};\n\nstatic int npcm_peci_xfer(struct peci_controller *controller, u8 addr, struct peci_request *req)\n{\n\tstruct npcm_peci *priv = dev_get_drvdata(controller->dev.parent);\n\tunsigned long timeout = msecs_to_jiffies(priv->cmd_timeout_ms);\n\tunsigned int msg_rd;\n\tu32 cmd_sts;\n\tint i, ret;\n\n\t \n\tret = regmap_read_poll_timeout(priv->regmap, NPCM_PECI_CTL_STS, cmd_sts,\n\t\t\t\t       !(cmd_sts & NPCM_PECI_CTRL_START_BUSY),\n\t\t\t\t       NPCM_PECI_IDLE_CHECK_INTERVAL_USEC,\n\t\t\t\t       NPCM_PECI_IDLE_CHECK_TIMEOUT_USEC);\n\tif (ret)\n\t\treturn ret;  \n\n\tspin_lock_irq(&priv->lock);\n\treinit_completion(&priv->xfer_complete);\n\n\tregmap_write(priv->regmap, NPCM_PECI_ADDR, addr);\n\tregmap_write(priv->regmap, NPCM_PECI_RD_LENGTH, NPCM_PECI_WR_LEN_MASK & req->rx.len);\n\tregmap_write(priv->regmap, NPCM_PECI_WR_LENGTH, NPCM_PECI_WR_LEN_MASK & req->tx.len);\n\n\tif (req->tx.len) {\n\t\tregmap_write(priv->regmap, NPCM_PECI_CMD, req->tx.buf[0]);\n\n\t\tfor (i = 0; i < (req->tx.len - 1); i++)\n\t\t\tregmap_write(priv->regmap, NPCM_PECI_DAT_INOUT(i), req->tx.buf[i + 1]);\n\t}\n\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG)\n\tdev_dbg(priv->dev, \"addr : %#02x, tx.len : %#02x, rx.len : %#02x\\n\",\n\t\taddr, req->tx.len, req->rx.len);\n\tprint_hex_dump_bytes(\"TX : \", DUMP_PREFIX_NONE, req->tx.buf, req->tx.len);\n#endif\n\n\tpriv->status = 0;\n\tregmap_update_bits(priv->regmap, NPCM_PECI_CTL_STS, NPCM_PECI_CTRL_START_BUSY,\n\t\t\t   NPCM_PECI_CTRL_START_BUSY);\n\n\tspin_unlock_irq(&priv->lock);\n\n\tret = wait_for_completion_interruptible_timeout(&priv->xfer_complete, timeout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tdev_dbg(priv->dev, \"timeout waiting for a response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tspin_lock_irq(&priv->lock);\n\n\tif (priv->status != NPCM_PECI_CTRL_DONE) {\n\t\tspin_unlock_irq(&priv->lock);\n\t\tdev_dbg(priv->dev, \"no valid response, status: %#02x\\n\", priv->status);\n\t\treturn -EIO;\n\t}\n\n\tregmap_write(priv->regmap, NPCM_PECI_CMD, 0);\n\n\tfor (i = 0; i < req->rx.len; i++) {\n\t\tregmap_read(priv->regmap, NPCM_PECI_DAT_INOUT(i), &msg_rd);\n\t\treq->rx.buf[i] = (u8)msg_rd;\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG)\n\tprint_hex_dump_bytes(\"RX : \", DUMP_PREFIX_NONE, req->rx.buf, req->rx.len);\n#endif\n\treturn 0;\n}\n\nstatic irqreturn_t npcm_peci_irq_handler(int irq, void *arg)\n{\n\tstruct npcm_peci *priv = arg;\n\tu32 status_ack = 0;\n\tu32 status;\n\n\tspin_lock(&priv->lock);\n\tregmap_read(priv->regmap, NPCM_PECI_CTL_STS, &status);\n\tpriv->status |= (status & NPCM_PECI_INT_MASK);\n\n\tif (status & NPCM_PECI_CTRL_CRC_ERR)\n\t\tstatus_ack |= NPCM_PECI_CTRL_CRC_ERR;\n\n\tif (status & NPCM_PECI_CTRL_ABRT_ERR)\n\t\tstatus_ack |= NPCM_PECI_CTRL_ABRT_ERR;\n\n\t \n\tif (status & NPCM_PECI_CTRL_DONE) {\n\t\tstatus_ack |= NPCM_PECI_CTRL_DONE;\n\t\tcomplete(&priv->xfer_complete);\n\t}\n\n\tregmap_write_bits(priv->regmap, NPCM_PECI_CTL_STS, NPCM_PECI_INT_MASK, status_ack);\n\n\tspin_unlock(&priv->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int npcm_peci_init_ctrl(struct npcm_peci *priv)\n{\n\tu32 cmd_sts;\n\tint ret;\n\n\tpriv->clk = devm_clk_get_enabled(priv->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(priv->dev, \"failed to get ref clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tret = device_property_read_u32(priv->dev, \"cmd-timeout-ms\", &priv->cmd_timeout_ms);\n\tif (ret) {\n\t\tpriv->cmd_timeout_ms = NPCM_PECI_CMD_TIMEOUT_MS_DEFAULT;\n\t} else if (priv->cmd_timeout_ms > NPCM_PECI_CMD_TIMEOUT_MS_MAX ||\n\t\t   priv->cmd_timeout_ms == 0) {\n\t\tdev_warn(priv->dev, \"invalid cmd-timeout-ms: %u, falling back to: %u\\n\",\n\t\t\t priv->cmd_timeout_ms, NPCM_PECI_CMD_TIMEOUT_MS_DEFAULT);\n\n\t\tpriv->cmd_timeout_ms = NPCM_PECI_CMD_TIMEOUT_MS_DEFAULT;\n\t}\n\n\tregmap_update_bits(priv->regmap, NPCM_PECI_CTL2, NPCM_PECI_CTL2_MASK,\n\t\t\t   NPCM_PECI_PULL_DOWN_DEFAULT << 6);\n\n\tregmap_update_bits(priv->regmap, NPCM_PECI_PDDR, NPCM_PECI_PDDR_MASK,\n\t\t\t   NPCM_PECI_HOST_NEG_BIT_RATE_DEFAULT);\n\n\tret = regmap_read_poll_timeout(priv->regmap, NPCM_PECI_CTL_STS, cmd_sts,\n\t\t\t\t       !(cmd_sts & NPCM_PECI_CTRL_START_BUSY),\n\t\t\t\t       NPCM_PECI_IDLE_CHECK_INTERVAL_USEC,\n\t\t\t\t       NPCM_PECI_IDLE_CHECK_TIMEOUT_USEC);\n\tif (ret)\n\t\treturn ret;  \n\n\t \n\tregmap_update_bits(priv->regmap, NPCM_PECI_CTL_STS, NPCM_PECI_CTRL_DONE_INT_EN,\n\t\t\t   NPCM_PECI_CTRL_DONE_INT_EN);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config npcm_peci_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = NPCM_PECI_MAX_REG,\n\t.fast_io = true,\n};\n\nstatic struct peci_controller_ops npcm_ops = {\n\t.xfer = npcm_peci_xfer,\n};\n\nstatic int npcm_peci_probe(struct platform_device *pdev)\n{\n\tstruct peci_controller *controller;\n\tstruct npcm_peci *priv;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap = devm_regmap_init_mmio(&pdev->dev, base, &npcm_peci_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\n\tret = devm_request_irq(&pdev->dev, priv->irq, npcm_peci_irq_handler,\n\t\t\t       0, \"peci-npcm-irq\", priv);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_completion(&priv->xfer_complete);\n\tspin_lock_init(&priv->lock);\n\n\tret = npcm_peci_init_ctrl(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tcontroller = devm_peci_controller_add(priv->dev, &npcm_ops);\n\tif (IS_ERR(controller))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(controller),\n\t\t\t\t     \"failed to add npcm peci controller\\n\");\n\n\tpriv->controller = controller;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id npcm_peci_of_table[] = {\n\t{ .compatible = \"nuvoton,npcm750-peci\", },\n\t{ .compatible = \"nuvoton,npcm845-peci\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, npcm_peci_of_table);\n\nstatic struct platform_driver npcm_peci_driver = {\n\t.probe  = npcm_peci_probe,\n\t.driver = {\n\t\t.name           = KBUILD_MODNAME,\n\t\t.of_match_table = npcm_peci_of_table,\n\t},\n};\nmodule_platform_driver(npcm_peci_driver);\n\nMODULE_AUTHOR(\"Tomer Maimon <tomer.maimon@nuvoton.com>\");\nMODULE_DESCRIPTION(\"NPCM PECI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(PECI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}