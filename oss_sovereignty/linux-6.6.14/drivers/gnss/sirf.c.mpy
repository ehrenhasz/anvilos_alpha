{
  "module_name": "sirf.c",
  "hash_id": "75c0164df68f0a20359df5706dd4aa9856b4116cef72d18cb00198a428468825",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gnss/sirf.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gnss.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sched.h>\n#include <linux/serdev.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#define SIRF_BOOT_DELAY\t\t\t500\n#define SIRF_ON_OFF_PULSE_TIME\t\t100\n#define SIRF_ACTIVATE_TIMEOUT\t\t200\n#define SIRF_HIBERNATE_TIMEOUT\t\t200\n \n#define SIRF_REPORT_CYCLE\t2000\n\nstruct sirf_data {\n\tstruct gnss_device *gdev;\n\tstruct serdev_device *serdev;\n\tspeed_t\tspeed;\n\tstruct regulator *vcc;\n\tstruct regulator *lna;\n\tstruct gpio_desc *on_off;\n\tstruct gpio_desc *wakeup;\n\tint irq;\n\tbool active;\n\n\tstruct mutex gdev_mutex;\n\tbool open;\n\n\tstruct mutex serdev_mutex;\n\tint serdev_count;\n\n\twait_queue_head_t power_wait;\n};\n\nstatic int sirf_serdev_open(struct sirf_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->serdev_mutex);\n\tif (++data->serdev_count == 1) {\n\t\tret = serdev_device_open(data->serdev);\n\t\tif (ret) {\n\t\t\tdata->serdev_count--;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tserdev_device_set_baudrate(data->serdev, data->speed);\n\t\tserdev_device_set_flow_control(data->serdev, false);\n\t}\n\nout_unlock:\n\tmutex_unlock(&data->serdev_mutex);\n\n\treturn ret;\n}\n\nstatic void sirf_serdev_close(struct sirf_data *data)\n{\n\tmutex_lock(&data->serdev_mutex);\n\tif (--data->serdev_count == 0)\n\t\tserdev_device_close(data->serdev);\n\tmutex_unlock(&data->serdev_mutex);\n}\n\nstatic int sirf_open(struct gnss_device *gdev)\n{\n\tstruct sirf_data *data = gnss_get_drvdata(gdev);\n\tstruct serdev_device *serdev = data->serdev;\n\tint ret;\n\n\tmutex_lock(&data->gdev_mutex);\n\tdata->open = true;\n\tmutex_unlock(&data->gdev_mutex);\n\n\tret = sirf_serdev_open(data);\n\tif (ret) {\n\t\tmutex_lock(&data->gdev_mutex);\n\t\tdata->open = false;\n\t\tmutex_unlock(&data->gdev_mutex);\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_get_sync(&serdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&gdev->dev, \"failed to runtime resume: %d\\n\", ret);\n\t\tpm_runtime_put_noidle(&serdev->dev);\n\t\tgoto err_close;\n\t}\n\n\treturn 0;\n\nerr_close:\n\tsirf_serdev_close(data);\n\n\tmutex_lock(&data->gdev_mutex);\n\tdata->open = false;\n\tmutex_unlock(&data->gdev_mutex);\n\n\treturn ret;\n}\n\nstatic void sirf_close(struct gnss_device *gdev)\n{\n\tstruct sirf_data *data = gnss_get_drvdata(gdev);\n\tstruct serdev_device *serdev = data->serdev;\n\n\tsirf_serdev_close(data);\n\n\tpm_runtime_put(&serdev->dev);\n\n\tmutex_lock(&data->gdev_mutex);\n\tdata->open = false;\n\tmutex_unlock(&data->gdev_mutex);\n}\n\nstatic int sirf_write_raw(struct gnss_device *gdev, const unsigned char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct sirf_data *data = gnss_get_drvdata(gdev);\n\tstruct serdev_device *serdev = data->serdev;\n\tint ret;\n\n\t \n\tret = serdev_device_write(serdev, buf, count, MAX_SCHEDULE_TIMEOUT);\n\tif (ret < 0 || ret < count)\n\t\treturn ret;\n\n\t \n\tserdev_device_wait_until_sent(serdev, 0);\n\n\treturn count;\n}\n\nstatic const struct gnss_operations sirf_gnss_ops = {\n\t.open\t\t= sirf_open,\n\t.close\t\t= sirf_close,\n\t.write_raw\t= sirf_write_raw,\n};\n\nstatic int sirf_receive_buf(struct serdev_device *serdev,\n\t\t\t\tconst unsigned char *buf, size_t count)\n{\n\tstruct sirf_data *data = serdev_device_get_drvdata(serdev);\n\tstruct gnss_device *gdev = data->gdev;\n\tint ret = 0;\n\n\tif (!data->wakeup && !data->active) {\n\t\tdata->active = true;\n\t\twake_up_interruptible(&data->power_wait);\n\t}\n\n\tmutex_lock(&data->gdev_mutex);\n\tif (data->open)\n\t\tret = gnss_insert_raw(gdev, buf, count);\n\tmutex_unlock(&data->gdev_mutex);\n\n\treturn ret;\n}\n\nstatic const struct serdev_device_ops sirf_serdev_ops = {\n\t.receive_buf\t= sirf_receive_buf,\n\t.write_wakeup\t= serdev_device_write_wakeup,\n};\n\nstatic irqreturn_t sirf_wakeup_handler(int irq, void *dev_id)\n{\n\tstruct sirf_data *data = dev_id;\n\tstruct device *dev = &data->serdev->dev;\n\tint ret;\n\n\tret = gpiod_get_value_cansleep(data->wakeup);\n\tdev_dbg(dev, \"%s - wakeup = %d\\n\", __func__, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata->active = ret;\n\twake_up_interruptible(&data->power_wait);\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int sirf_wait_for_power_state_nowakeup(struct sirf_data *data,\n\t\t\t\t\t\tbool active,\n\t\t\t\t\t\tunsigned long timeout)\n{\n\tint ret;\n\n\t \n\tmsleep(timeout);\n\n\t \n\tdata->active = false;\n\tret = wait_event_interruptible_timeout(data->power_wait,\n\t\t\tdata->active, msecs_to_jiffies(SIRF_REPORT_CYCLE));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret > 0 && !active)\n\t\treturn -ETIMEDOUT;\n\n\tif (ret == 0 && active)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int sirf_wait_for_power_state(struct sirf_data *data, bool active,\n\t\t\t\t\tunsigned long timeout)\n{\n\tint ret;\n\n\tif (!data->wakeup)\n\t\treturn sirf_wait_for_power_state_nowakeup(data, active, timeout);\n\n\tret = wait_event_interruptible_timeout(data->power_wait,\n\t\t\tdata->active == active, msecs_to_jiffies(timeout));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tdev_warn(&data->serdev->dev, \"timeout waiting for active state = %d\\n\",\n\t\t\t\tactive);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void sirf_pulse_on_off(struct sirf_data *data)\n{\n\tgpiod_set_value_cansleep(data->on_off, 1);\n\tmsleep(SIRF_ON_OFF_PULSE_TIME);\n\tgpiod_set_value_cansleep(data->on_off, 0);\n}\n\nstatic int sirf_set_active(struct sirf_data *data, bool active)\n{\n\tunsigned long timeout;\n\tint retries = 3;\n\tint ret;\n\n\tif (active)\n\t\ttimeout = SIRF_ACTIVATE_TIMEOUT;\n\telse\n\t\ttimeout = SIRF_HIBERNATE_TIMEOUT;\n\n\tif (!data->wakeup) {\n\t\tret = sirf_serdev_open(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdo {\n\t\tsirf_pulse_on_off(data);\n\t\tret = sirf_wait_for_power_state(data, active, timeout);\n\t} while (ret == -ETIMEDOUT && retries--);\n\n\tif (!data->wakeup)\n\t\tsirf_serdev_close(data);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sirf_runtime_suspend(struct device *dev)\n{\n\tstruct sirf_data *data = dev_get_drvdata(dev);\n\tint ret2;\n\tint ret;\n\n\tif (data->on_off)\n\t\tret = sirf_set_active(data, false);\n\telse\n\t\tret = regulator_disable(data->vcc);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_disable(data->lna);\n\tif (ret)\n\t\tgoto err_reenable;\n\n\treturn 0;\n\nerr_reenable:\n\tif (data->on_off)\n\t\tret2 = sirf_set_active(data, true);\n\telse\n\t\tret2 = regulator_enable(data->vcc);\n\n\tif (ret2)\n\t\tdev_err(dev,\n\t\t\t\"failed to reenable power on failed suspend: %d\\n\",\n\t\t\tret2);\n\n\treturn ret;\n}\n\nstatic int sirf_runtime_resume(struct device *dev)\n{\n\tstruct sirf_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_enable(data->lna);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->on_off)\n\t\tret = sirf_set_active(data, true);\n\telse\n\t\tret = regulator_enable(data->vcc);\n\n\tif (ret)\n\t\tgoto err_disable_lna;\n\n\treturn 0;\n\nerr_disable_lna:\n\tregulator_disable(data->lna);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused sirf_suspend(struct device *dev)\n{\n\tstruct sirf_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tret = sirf_runtime_suspend(dev);\n\n\tif (data->wakeup)\n\t\tdisable_irq(data->irq);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused sirf_resume(struct device *dev)\n{\n\tstruct sirf_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (data->wakeup)\n\t\tenable_irq(data->irq);\n\n\tif (!pm_runtime_suspended(dev))\n\t\tret = sirf_runtime_resume(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops sirf_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sirf_suspend, sirf_resume)\n\tSET_RUNTIME_PM_OPS(sirf_runtime_suspend, sirf_runtime_resume, NULL)\n};\n\nstatic int sirf_parse_dt(struct serdev_device *serdev)\n{\n\tstruct sirf_data *data = serdev_device_get_drvdata(serdev);\n\tstruct device_node *node = serdev->dev.of_node;\n\tu32 speed = 9600;\n\n\tof_property_read_u32(node, \"current-speed\", &speed);\n\n\tdata->speed = speed;\n\n\treturn 0;\n}\n\nstatic int sirf_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct gnss_device *gdev;\n\tstruct sirf_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tgdev = gnss_allocate_device(dev);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tgdev->type = GNSS_TYPE_SIRF;\n\tgdev->ops = &sirf_gnss_ops;\n\tgnss_set_drvdata(gdev, data);\n\n\tdata->serdev = serdev;\n\tdata->gdev = gdev;\n\n\tmutex_init(&data->gdev_mutex);\n\tmutex_init(&data->serdev_mutex);\n\tinit_waitqueue_head(&data->power_wait);\n\n\tserdev_device_set_drvdata(serdev, data);\n\tserdev_device_set_client_ops(serdev, &sirf_serdev_ops);\n\n\tret = sirf_parse_dt(serdev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tdata->vcc = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(data->vcc)) {\n\t\tret = PTR_ERR(data->vcc);\n\t\tgoto err_put_device;\n\t}\n\n\tdata->lna = devm_regulator_get(dev, \"lna\");\n\tif (IS_ERR(data->lna)) {\n\t\tret = PTR_ERR(data->lna);\n\t\tgoto err_put_device;\n\t}\n\n\tdata->on_off = devm_gpiod_get_optional(dev, \"sirf,onoff\",\n\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(data->on_off)) {\n\t\tret = PTR_ERR(data->on_off);\n\t\tgoto err_put_device;\n\t}\n\n\tif (data->on_off) {\n\t\tdata->wakeup = devm_gpiod_get_optional(dev, \"sirf,wakeup\",\n\t\t\t\tGPIOD_IN);\n\t\tif (IS_ERR(data->wakeup)) {\n\t\t\tret = PTR_ERR(data->wakeup);\n\t\t\tgoto err_put_device;\n\t\t}\n\n\t\tret = regulator_enable(data->vcc);\n\t\tif (ret)\n\t\t\tgoto err_put_device;\n\n\t\t \n\t\tmsleep(SIRF_BOOT_DELAY);\n\t}\n\n\tif (data->wakeup) {\n\t\tret = gpiod_get_value_cansleep(data->wakeup);\n\t\tif (ret < 0)\n\t\t\tgoto err_disable_vcc;\n\t\tdata->active = ret;\n\n\t\tret = gpiod_to_irq(data->wakeup);\n\t\tif (ret < 0)\n\t\t\tgoto err_disable_vcc;\n\t\tdata->irq = ret;\n\n\t\tret = request_threaded_irq(data->irq, NULL, sirf_wakeup_handler,\n\t\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\"wakeup\", data);\n\t\tif (ret)\n\t\t\tgoto err_disable_vcc;\n\t}\n\n\tif (data->on_off) {\n\t\tif (!data->wakeup) {\n\t\t\tdata->active = false;\n\n\t\t\tret = sirf_serdev_open(data);\n\t\t\tif (ret)\n\t\t\t\tgoto err_disable_vcc;\n\n\t\t\tmsleep(SIRF_REPORT_CYCLE);\n\t\t\tsirf_serdev_close(data);\n\t\t}\n\n\t\t \n\t\tif (data->active) {\n\t\t\tret = sirf_set_active(data, false);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"failed to set hibernate mode: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\tgoto err_free_irq;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_PM)) {\n\t\tpm_runtime_set_suspended(dev);\t \n\t\tpm_runtime_enable(dev);\n\t} else {\n\t\tret = sirf_runtime_resume(dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_free_irq;\n\t}\n\n\tret = gnss_register_device(gdev);\n\tif (ret)\n\t\tgoto err_disable_rpm;\n\n\treturn 0;\n\nerr_disable_rpm:\n\tif (IS_ENABLED(CONFIG_PM))\n\t\tpm_runtime_disable(dev);\n\telse\n\t\tsirf_runtime_suspend(dev);\nerr_free_irq:\n\tif (data->wakeup)\n\t\tfree_irq(data->irq, data);\nerr_disable_vcc:\n\tif (data->on_off)\n\t\tregulator_disable(data->vcc);\nerr_put_device:\n\tgnss_put_device(data->gdev);\n\n\treturn ret;\n}\n\nstatic void sirf_remove(struct serdev_device *serdev)\n{\n\tstruct sirf_data *data = serdev_device_get_drvdata(serdev);\n\n\tgnss_deregister_device(data->gdev);\n\n\tif (IS_ENABLED(CONFIG_PM))\n\t\tpm_runtime_disable(&serdev->dev);\n\telse\n\t\tsirf_runtime_suspend(&serdev->dev);\n\n\tif (data->wakeup)\n\t\tfree_irq(data->irq, data);\n\n\tif (data->on_off)\n\t\tregulator_disable(data->vcc);\n\n\tgnss_put_device(data->gdev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sirf_of_match[] = {\n\t{ .compatible = \"fastrax,uc430\" },\n\t{ .compatible = \"linx,r4\" },\n\t{ .compatible = \"wi2wi,w2sg0004\" },\n\t{ .compatible = \"wi2wi,w2sg0008i\" },\n\t{ .compatible = \"wi2wi,w2sg0084i\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sirf_of_match);\n#endif\n\nstatic struct serdev_device_driver sirf_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gnss-sirf\",\n\t\t.of_match_table\t= of_match_ptr(sirf_of_match),\n\t\t.pm\t\t= &sirf_pm_ops,\n\t},\n\t.probe\t= sirf_probe,\n\t.remove\t= sirf_remove,\n};\nmodule_serdev_device_driver(sirf_driver);\n\nMODULE_AUTHOR(\"Johan Hovold <johan@kernel.org>\");\nMODULE_DESCRIPTION(\"SiRFstar GNSS receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}