{
  "module_name": "mtk.c",
  "hash_id": "0ed9663d12068381d964515f7ac6efa94845a6d5a67b5eecf97f334e6c4d5e9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gnss/mtk.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gnss.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/serdev.h>\n\n#include \"serial.h\"\n\nstruct mtk_data {\n\tstruct regulator *vbackup;\n\tstruct regulator *vcc;\n};\n\nstatic int mtk_set_active(struct gnss_serial *gserial)\n{\n\tstruct mtk_data *data = gnss_serial_get_drvdata(gserial);\n\tint ret;\n\n\tret = regulator_enable(data->vcc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mtk_set_standby(struct gnss_serial *gserial)\n{\n\tstruct mtk_data *data = gnss_serial_get_drvdata(gserial);\n\tint ret;\n\n\tret = regulator_disable(data->vcc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mtk_set_power(struct gnss_serial *gserial,\n\t\t\t enum gnss_serial_pm_state state)\n{\n\tswitch (state) {\n\tcase GNSS_SERIAL_ACTIVE:\n\t\treturn mtk_set_active(gserial);\n\tcase GNSS_SERIAL_OFF:\n\tcase GNSS_SERIAL_STANDBY:\n\t\treturn mtk_set_standby(gserial);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct gnss_serial_ops mtk_gserial_ops = {\n\t.set_power = mtk_set_power,\n};\n\nstatic int mtk_probe(struct serdev_device *serdev)\n{\n\tstruct gnss_serial *gserial;\n\tstruct mtk_data *data;\n\tint ret;\n\n\tgserial = gnss_serial_allocate(serdev, sizeof(*data));\n\tif (IS_ERR(gserial)) {\n\t\tret = PTR_ERR(gserial);\n\t\treturn ret;\n\t}\n\n\tgserial->ops = &mtk_gserial_ops;\n\n\tgserial->gdev->type = GNSS_TYPE_MTK;\n\n\tdata = gnss_serial_get_drvdata(gserial);\n\n\tdata->vcc = devm_regulator_get(&serdev->dev, \"vcc\");\n\tif (IS_ERR(data->vcc)) {\n\t\tret = PTR_ERR(data->vcc);\n\t\tgoto err_free_gserial;\n\t}\n\n\tdata->vbackup = devm_regulator_get_optional(&serdev->dev, \"vbackup\");\n\tif (IS_ERR(data->vbackup)) {\n\t\tret = PTR_ERR(data->vbackup);\n\t\tif (ret == -ENODEV)\n\t\t\tdata->vbackup = NULL;\n\t\telse\n\t\t\tgoto err_free_gserial;\n\t}\n\n\tif (data->vbackup) {\n\t\tret = regulator_enable(data->vbackup);\n\t\tif (ret)\n\t\t\tgoto err_free_gserial;\n\t}\n\n\tret = gnss_serial_register(gserial);\n\tif (ret)\n\t\tgoto err_disable_vbackup;\n\n\treturn 0;\n\nerr_disable_vbackup:\n\tif (data->vbackup)\n\t\tregulator_disable(data->vbackup);\nerr_free_gserial:\n\tgnss_serial_free(gserial);\n\n\treturn ret;\n}\n\nstatic void mtk_remove(struct serdev_device *serdev)\n{\n\tstruct gnss_serial *gserial = serdev_device_get_drvdata(serdev);\n\tstruct mtk_data *data = gnss_serial_get_drvdata(gserial);\n\n\tgnss_serial_deregister(gserial);\n\tif (data->vbackup)\n\t\tregulator_disable(data->vbackup);\n\tgnss_serial_free(gserial);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mtk_of_match[] = {\n\t{ .compatible = \"globaltop,pa6h\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_of_match);\n#endif\n\nstatic struct serdev_device_driver mtk_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gnss-mtk\",\n\t\t.of_match_table\t= of_match_ptr(mtk_of_match),\n\t\t.pm\t\t= &gnss_serial_pm_ops,\n\t},\n\t.probe\t= mtk_probe,\n\t.remove\t= mtk_remove,\n};\nmodule_serdev_device_driver(mtk_driver);\n\nMODULE_AUTHOR(\"Loys Ollivier <lollivier@baylibre.com>\");\nMODULE_DESCRIPTION(\"Mediatek GNSS receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}