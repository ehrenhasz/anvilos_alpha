{
  "module_name": "serial.c",
  "hash_id": "95b71b04cd8b68c7d64e1bc86dae2fa174dc639039eb4af9ce74741c48f6ba40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gnss/serial.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gnss.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/serdev.h>\n#include <linux/slab.h>\n\n#include \"serial.h\"\n\nstatic int gnss_serial_open(struct gnss_device *gdev)\n{\n\tstruct gnss_serial *gserial = gnss_get_drvdata(gdev);\n\tstruct serdev_device *serdev = gserial->serdev;\n\tint ret;\n\n\tret = serdev_device_open(serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tserdev_device_set_baudrate(serdev, gserial->speed);\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = pm_runtime_get_sync(&serdev->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(&serdev->dev);\n\t\tgoto err_close;\n\t}\n\n\treturn 0;\n\nerr_close:\n\tserdev_device_close(serdev);\n\n\treturn ret;\n}\n\nstatic void gnss_serial_close(struct gnss_device *gdev)\n{\n\tstruct gnss_serial *gserial = gnss_get_drvdata(gdev);\n\tstruct serdev_device *serdev = gserial->serdev;\n\n\tserdev_device_close(serdev);\n\n\tpm_runtime_put(&serdev->dev);\n}\n\nstatic int gnss_serial_write_raw(struct gnss_device *gdev,\n\t\tconst unsigned char *buf, size_t count)\n{\n\tstruct gnss_serial *gserial = gnss_get_drvdata(gdev);\n\tstruct serdev_device *serdev = gserial->serdev;\n\tint ret;\n\n\t \n\tret = serdev_device_write(serdev, buf, count, MAX_SCHEDULE_TIMEOUT);\n\tif (ret < 0 || ret < count)\n\t\treturn ret;\n\n\t \n\tserdev_device_wait_until_sent(serdev, 0);\n\n\treturn count;\n}\n\nstatic const struct gnss_operations gnss_serial_gnss_ops = {\n\t.open\t\t= gnss_serial_open,\n\t.close\t\t= gnss_serial_close,\n\t.write_raw\t= gnss_serial_write_raw,\n};\n\nstatic int gnss_serial_receive_buf(struct serdev_device *serdev,\n\t\t\t\t\tconst unsigned char *buf, size_t count)\n{\n\tstruct gnss_serial *gserial = serdev_device_get_drvdata(serdev);\n\tstruct gnss_device *gdev = gserial->gdev;\n\n\treturn gnss_insert_raw(gdev, buf, count);\n}\n\nstatic const struct serdev_device_ops gnss_serial_serdev_ops = {\n\t.receive_buf\t= gnss_serial_receive_buf,\n\t.write_wakeup\t= serdev_device_write_wakeup,\n};\n\nstatic int gnss_serial_set_power(struct gnss_serial *gserial,\n\t\t\t\t\tenum gnss_serial_pm_state state)\n{\n\tif (!gserial->ops || !gserial->ops->set_power)\n\t\treturn 0;\n\n\treturn gserial->ops->set_power(gserial, state);\n}\n\n \nstatic int gnss_serial_parse_dt(struct serdev_device *serdev)\n{\n\tstruct gnss_serial *gserial = serdev_device_get_drvdata(serdev);\n\tstruct device_node *node = serdev->dev.of_node;\n\tu32 speed = 4800;\n\n\tof_property_read_u32(node, \"current-speed\", &speed);\n\n\tgserial->speed = speed;\n\n\treturn 0;\n}\n\nstruct gnss_serial *gnss_serial_allocate(struct serdev_device *serdev,\n\t\t\t\t\t\tsize_t data_size)\n{\n\tstruct gnss_serial *gserial;\n\tstruct gnss_device *gdev;\n\tint ret;\n\n\tgserial = kzalloc(sizeof(*gserial) + data_size, GFP_KERNEL);\n\tif (!gserial)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgdev = gnss_allocate_device(&serdev->dev);\n\tif (!gdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_gserial;\n\t}\n\n\tgdev->ops = &gnss_serial_gnss_ops;\n\tgnss_set_drvdata(gdev, gserial);\n\n\tgserial->serdev = serdev;\n\tgserial->gdev = gdev;\n\n\tserdev_device_set_drvdata(serdev, gserial);\n\tserdev_device_set_client_ops(serdev, &gnss_serial_serdev_ops);\n\n\tret = gnss_serial_parse_dt(serdev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\treturn gserial;\n\nerr_put_device:\n\tgnss_put_device(gserial->gdev);\nerr_free_gserial:\n\tkfree(gserial);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(gnss_serial_allocate);\n\nvoid gnss_serial_free(struct gnss_serial *gserial)\n{\n\tgnss_put_device(gserial->gdev);\n\tkfree(gserial);\n}\nEXPORT_SYMBOL_GPL(gnss_serial_free);\n\nint gnss_serial_register(struct gnss_serial *gserial)\n{\n\tstruct serdev_device *serdev = gserial->serdev;\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PM)) {\n\t\tpm_runtime_enable(&serdev->dev);\n\t} else {\n\t\tret = gnss_serial_set_power(gserial, GNSS_SERIAL_ACTIVE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = gnss_register_device(gserial->gdev);\n\tif (ret)\n\t\tgoto err_disable_rpm;\n\n\treturn 0;\n\nerr_disable_rpm:\n\tif (IS_ENABLED(CONFIG_PM))\n\t\tpm_runtime_disable(&serdev->dev);\n\telse\n\t\tgnss_serial_set_power(gserial, GNSS_SERIAL_OFF);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gnss_serial_register);\n\nvoid gnss_serial_deregister(struct gnss_serial *gserial)\n{\n\tstruct serdev_device *serdev = gserial->serdev;\n\n\tgnss_deregister_device(gserial->gdev);\n\n\tif (IS_ENABLED(CONFIG_PM))\n\t\tpm_runtime_disable(&serdev->dev);\n\telse\n\t\tgnss_serial_set_power(gserial, GNSS_SERIAL_OFF);\n}\nEXPORT_SYMBOL_GPL(gnss_serial_deregister);\n\n#ifdef CONFIG_PM\nstatic int gnss_serial_runtime_suspend(struct device *dev)\n{\n\tstruct gnss_serial *gserial = dev_get_drvdata(dev);\n\n\treturn gnss_serial_set_power(gserial, GNSS_SERIAL_STANDBY);\n}\n\nstatic int gnss_serial_runtime_resume(struct device *dev)\n{\n\tstruct gnss_serial *gserial = dev_get_drvdata(dev);\n\n\treturn gnss_serial_set_power(gserial, GNSS_SERIAL_ACTIVE);\n}\n#endif  \n\nstatic int gnss_serial_prepare(struct device *dev)\n{\n\tif (pm_runtime_suspended(dev))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gnss_serial_suspend(struct device *dev)\n{\n\tstruct gnss_serial *gserial = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\t \n\n\tif (!pm_runtime_suspended(dev))\n\t\tret = gnss_serial_set_power(gserial, GNSS_SERIAL_STANDBY);\n\n\treturn ret;\n}\n\nstatic int gnss_serial_resume(struct device *dev)\n{\n\tstruct gnss_serial *gserial = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!pm_runtime_suspended(dev))\n\t\tret = gnss_serial_set_power(gserial, GNSS_SERIAL_ACTIVE);\n\n\treturn ret;\n}\n#endif  \n\nconst struct dev_pm_ops gnss_serial_pm_ops = {\n\t.prepare\t= gnss_serial_prepare,\n\tSET_SYSTEM_SLEEP_PM_OPS(gnss_serial_suspend, gnss_serial_resume)\n\tSET_RUNTIME_PM_OPS(gnss_serial_runtime_suspend, gnss_serial_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_GPL(gnss_serial_pm_ops);\n\nMODULE_AUTHOR(\"Johan Hovold <johan@kernel.org>\");\nMODULE_DESCRIPTION(\"Generic serial GNSS receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}