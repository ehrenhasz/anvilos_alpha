{
  "module_name": "core.c",
  "hash_id": "6af7e03289f6169a6c9cccbe63313ef8d830a15ce077c4aca85caed7ed42fefc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gnss/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cdev.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/gnss.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n\n#define GNSS_FLAG_HAS_WRITE_RAW\t\tBIT(0)\n\n#define GNSS_MINORS\t16\n\nstatic DEFINE_IDA(gnss_minors);\nstatic dev_t gnss_first;\n\n \n#define GNSS_READ_FIFO_SIZE\t4096\n#define GNSS_WRITE_BUF_SIZE\t1024\n\n#define to_gnss_device(d) container_of((d), struct gnss_device, dev)\n\nstatic int gnss_open(struct inode *inode, struct file *file)\n{\n\tstruct gnss_device *gdev;\n\tint ret = 0;\n\n\tgdev = container_of(inode->i_cdev, struct gnss_device, cdev);\n\n\tget_device(&gdev->dev);\n\n\tstream_open(inode, file);\n\tfile->private_data = gdev;\n\n\tdown_write(&gdev->rwsem);\n\tif (gdev->disconnected) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (gdev->count++ == 0) {\n\t\tret = gdev->ops->open(gdev);\n\t\tif (ret)\n\t\t\tgdev->count--;\n\t}\nunlock:\n\tup_write(&gdev->rwsem);\n\n\tif (ret)\n\t\tput_device(&gdev->dev);\n\n\treturn ret;\n}\n\nstatic int gnss_release(struct inode *inode, struct file *file)\n{\n\tstruct gnss_device *gdev = file->private_data;\n\n\tdown_write(&gdev->rwsem);\n\tif (gdev->disconnected)\n\t\tgoto unlock;\n\n\tif (--gdev->count == 0) {\n\t\tgdev->ops->close(gdev);\n\t\tkfifo_reset(&gdev->read_fifo);\n\t}\nunlock:\n\tup_write(&gdev->rwsem);\n\n\tput_device(&gdev->dev);\n\n\treturn 0;\n}\n\nstatic ssize_t gnss_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct gnss_device *gdev = file->private_data;\n\tunsigned int copied;\n\tint ret;\n\n\tmutex_lock(&gdev->read_mutex);\n\twhile (kfifo_is_empty(&gdev->read_fifo)) {\n\t\tmutex_unlock(&gdev->read_mutex);\n\n\t\tif (gdev->disconnected)\n\t\t\treturn 0;\n\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(gdev->read_queue,\n\t\t\t\tgdev->disconnected ||\n\t\t\t\t!kfifo_is_empty(&gdev->read_fifo));\n\t\tif (ret)\n\t\t\treturn -ERESTARTSYS;\n\n\t\tmutex_lock(&gdev->read_mutex);\n\t}\n\n\tret = kfifo_to_user(&gdev->read_fifo, buf, count, &copied);\n\tif (ret == 0)\n\t\tret = copied;\n\n\tmutex_unlock(&gdev->read_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t gnss_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct gnss_device *gdev = file->private_data;\n\tsize_t written = 0;\n\tint ret;\n\n\tif (gdev->disconnected)\n\t\treturn -EIO;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!(gdev->flags & GNSS_FLAG_HAS_WRITE_RAW))\n\t\treturn -EIO;\n\n\t \n\n\tret = mutex_lock_interruptible(&gdev->write_mutex);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\n\tfor (;;) {\n\t\tsize_t n = count - written;\n\n\t\tif (n > GNSS_WRITE_BUF_SIZE)\n\t\t\tn = GNSS_WRITE_BUF_SIZE;\n\n\t\tif (copy_from_user(gdev->write_buf, buf, n)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tdown_read(&gdev->rwsem);\n\t\tif (!gdev->disconnected)\n\t\t\tret = gdev->ops->write_raw(gdev, gdev->write_buf, n);\n\t\telse\n\t\t\tret = -EIO;\n\t\tup_read(&gdev->rwsem);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\twritten += ret;\n\t\tbuf += ret;\n\n\t\tif (written == count)\n\t\t\tbreak;\n\t}\n\n\tif (written)\n\t\tret = written;\nout_unlock:\n\tmutex_unlock(&gdev->write_mutex);\n\n\treturn ret;\n}\n\nstatic __poll_t gnss_poll(struct file *file, poll_table *wait)\n{\n\tstruct gnss_device *gdev = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &gdev->read_queue, wait);\n\n\tif (!kfifo_is_empty(&gdev->read_fifo))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (gdev->disconnected)\n\t\tmask |= EPOLLHUP;\n\n\treturn mask;\n}\n\nstatic const struct file_operations gnss_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= gnss_open,\n\t.release\t= gnss_release,\n\t.read\t\t= gnss_read,\n\t.write\t\t= gnss_write,\n\t.poll\t\t= gnss_poll,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct class *gnss_class;\n\nstatic void gnss_device_release(struct device *dev)\n{\n\tstruct gnss_device *gdev = to_gnss_device(dev);\n\n\tkfree(gdev->write_buf);\n\tkfifo_free(&gdev->read_fifo);\n\tida_free(&gnss_minors, gdev->id);\n\tkfree(gdev);\n}\n\nstruct gnss_device *gnss_allocate_device(struct device *parent)\n{\n\tstruct gnss_device *gdev;\n\tstruct device *dev;\n\tint id;\n\tint ret;\n\n\tgdev = kzalloc(sizeof(*gdev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn NULL;\n\n\tid = ida_alloc_max(&gnss_minors, GNSS_MINORS - 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tkfree(gdev);\n\t\treturn NULL;\n\t}\n\n\tgdev->id = id;\n\n\tdev = &gdev->dev;\n\tdevice_initialize(dev);\n\tdev->devt = gnss_first + id;\n\tdev->class = gnss_class;\n\tdev->parent = parent;\n\tdev->release = gnss_device_release;\n\tdev_set_drvdata(dev, gdev);\n\tdev_set_name(dev, \"gnss%d\", id);\n\n\tinit_rwsem(&gdev->rwsem);\n\tmutex_init(&gdev->read_mutex);\n\tmutex_init(&gdev->write_mutex);\n\tinit_waitqueue_head(&gdev->read_queue);\n\n\tret = kfifo_alloc(&gdev->read_fifo, GNSS_READ_FIFO_SIZE, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tgdev->write_buf = kzalloc(GNSS_WRITE_BUF_SIZE, GFP_KERNEL);\n\tif (!gdev->write_buf)\n\t\tgoto err_put_device;\n\n\tcdev_init(&gdev->cdev, &gnss_fops);\n\tgdev->cdev.owner = THIS_MODULE;\n\n\treturn gdev;\n\nerr_put_device:\n\tput_device(dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(gnss_allocate_device);\n\nvoid gnss_put_device(struct gnss_device *gdev)\n{\n\tput_device(&gdev->dev);\n}\nEXPORT_SYMBOL_GPL(gnss_put_device);\n\nint gnss_register_device(struct gnss_device *gdev)\n{\n\tint ret;\n\n\t \n\tif (gdev->ops->write_raw != NULL)\n\t\tgdev->flags |= GNSS_FLAG_HAS_WRITE_RAW;\n\n\tret = cdev_device_add(&gdev->cdev, &gdev->dev);\n\tif (ret) {\n\t\tdev_err(&gdev->dev, \"failed to add device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gnss_register_device);\n\nvoid gnss_deregister_device(struct gnss_device *gdev)\n{\n\tdown_write(&gdev->rwsem);\n\tgdev->disconnected = true;\n\tif (gdev->count) {\n\t\twake_up_interruptible(&gdev->read_queue);\n\t\tgdev->ops->close(gdev);\n\t}\n\tup_write(&gdev->rwsem);\n\n\tcdev_device_del(&gdev->cdev, &gdev->dev);\n}\nEXPORT_SYMBOL_GPL(gnss_deregister_device);\n\n \nint gnss_insert_raw(struct gnss_device *gdev, const unsigned char *buf,\n\t\t\t\tsize_t count)\n{\n\tint ret;\n\n\tret = kfifo_in(&gdev->read_fifo, buf, count);\n\n\twake_up_interruptible(&gdev->read_queue);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gnss_insert_raw);\n\nstatic const char * const gnss_type_names[GNSS_TYPE_COUNT] = {\n\t[GNSS_TYPE_NMEA]\t= \"NMEA\",\n\t[GNSS_TYPE_SIRF]\t= \"SiRF\",\n\t[GNSS_TYPE_UBX]\t\t= \"UBX\",\n\t[GNSS_TYPE_MTK]\t\t= \"MTK\",\n};\n\nstatic const char *gnss_type_name(const struct gnss_device *gdev)\n{\n\tconst char *name = NULL;\n\n\tif (gdev->type < GNSS_TYPE_COUNT)\n\t\tname = gnss_type_names[gdev->type];\n\n\tif (!name)\n\t\tdev_WARN(&gdev->dev, \"type name not defined\\n\");\n\n\treturn name;\n}\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct gnss_device *gdev = to_gnss_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", gnss_type_name(gdev));\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic struct attribute *gnss_attrs[] = {\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(gnss);\n\nstatic int gnss_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct gnss_device *gdev = to_gnss_device(dev);\n\tint ret;\n\n\tret = add_uevent_var(env, \"GNSS_TYPE=%s\", gnss_type_name(gdev));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int __init gnss_module_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&gnss_first, 0, GNSS_MINORS, \"gnss\");\n\tif (ret < 0) {\n\t\tpr_err(\"failed to allocate device numbers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgnss_class = class_create(\"gnss\");\n\tif (IS_ERR(gnss_class)) {\n\t\tret = PTR_ERR(gnss_class);\n\t\tpr_err(\"failed to create class: %d\\n\", ret);\n\t\tgoto err_unregister_chrdev;\n\t}\n\n\tgnss_class->dev_groups = gnss_groups;\n\tgnss_class->dev_uevent = gnss_uevent;\n\n\tpr_info(\"GNSS driver registered with major %d\\n\", MAJOR(gnss_first));\n\n\treturn 0;\n\nerr_unregister_chrdev:\n\tunregister_chrdev_region(gnss_first, GNSS_MINORS);\n\n\treturn ret;\n}\nmodule_init(gnss_module_init);\n\nstatic void __exit gnss_module_exit(void)\n{\n\tclass_destroy(gnss_class);\n\tunregister_chrdev_region(gnss_first, GNSS_MINORS);\n\tida_destroy(&gnss_minors);\n}\nmodule_exit(gnss_module_exit);\n\nMODULE_AUTHOR(\"Johan Hovold <johan@kernel.org>\");\nMODULE_DESCRIPTION(\"GNSS receiver core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}