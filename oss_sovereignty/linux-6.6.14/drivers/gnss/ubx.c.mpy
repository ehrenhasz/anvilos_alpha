{
  "module_name": "ubx.c",
  "hash_id": "6b8ddc219b85b2267f707d95a9cddc51b7a6d41fd63f3550d5c78c3ad351c435",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gnss/ubx.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gnss.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/serdev.h>\n\n#include \"serial.h\"\n\nstruct ubx_data {\n\tstruct regulator *v_bckp;\n\tstruct regulator *vcc;\n};\n\nstatic int ubx_set_active(struct gnss_serial *gserial)\n{\n\tstruct ubx_data *data = gnss_serial_get_drvdata(gserial);\n\tint ret;\n\n\tret = regulator_enable(data->vcc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ubx_set_standby(struct gnss_serial *gserial)\n{\n\tstruct ubx_data *data = gnss_serial_get_drvdata(gserial);\n\tint ret;\n\n\tret = regulator_disable(data->vcc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ubx_set_power(struct gnss_serial *gserial,\n\t\t\t\tenum gnss_serial_pm_state state)\n{\n\tswitch (state) {\n\tcase GNSS_SERIAL_ACTIVE:\n\t\treturn ubx_set_active(gserial);\n\tcase GNSS_SERIAL_OFF:\n\tcase GNSS_SERIAL_STANDBY:\n\t\treturn ubx_set_standby(gserial);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct gnss_serial_ops ubx_gserial_ops = {\n\t.set_power = ubx_set_power,\n};\n\nstatic int ubx_probe(struct serdev_device *serdev)\n{\n\tstruct gnss_serial *gserial;\n\tstruct ubx_data *data;\n\tint ret;\n\n\tgserial = gnss_serial_allocate(serdev, sizeof(*data));\n\tif (IS_ERR(gserial)) {\n\t\tret = PTR_ERR(gserial);\n\t\treturn ret;\n\t}\n\n\tgserial->ops = &ubx_gserial_ops;\n\n\tgserial->gdev->type = GNSS_TYPE_UBX;\n\n\tdata = gnss_serial_get_drvdata(gserial);\n\n\tdata->vcc = devm_regulator_get(&serdev->dev, \"vcc\");\n\tif (IS_ERR(data->vcc)) {\n\t\tret = PTR_ERR(data->vcc);\n\t\tgoto err_free_gserial;\n\t}\n\n\tdata->v_bckp = devm_regulator_get_optional(&serdev->dev, \"v-bckp\");\n\tif (IS_ERR(data->v_bckp)) {\n\t\tret = PTR_ERR(data->v_bckp);\n\t\tif (ret == -ENODEV)\n\t\t\tdata->v_bckp = NULL;\n\t\telse\n\t\t\tgoto err_free_gserial;\n\t}\n\n\tif (data->v_bckp) {\n\t\tret = regulator_enable(data->v_bckp);\n\t\tif (ret)\n\t\t\tgoto err_free_gserial;\n\t}\n\n\tret = gnss_serial_register(gserial);\n\tif (ret)\n\t\tgoto err_disable_v_bckp;\n\n\treturn 0;\n\nerr_disable_v_bckp:\n\tif (data->v_bckp)\n\t\tregulator_disable(data->v_bckp);\nerr_free_gserial:\n\tgnss_serial_free(gserial);\n\n\treturn ret;\n}\n\nstatic void ubx_remove(struct serdev_device *serdev)\n{\n\tstruct gnss_serial *gserial = serdev_device_get_drvdata(serdev);\n\tstruct ubx_data *data = gnss_serial_get_drvdata(gserial);\n\n\tgnss_serial_deregister(gserial);\n\tif (data->v_bckp)\n\t\tregulator_disable(data->v_bckp);\n\tgnss_serial_free(gserial);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ubx_of_match[] = {\n\t{ .compatible = \"u-blox,neo-6m\" },\n\t{ .compatible = \"u-blox,neo-8\" },\n\t{ .compatible = \"u-blox,neo-m8\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ubx_of_match);\n#endif\n\nstatic struct serdev_device_driver ubx_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gnss-ubx\",\n\t\t.of_match_table\t= of_match_ptr(ubx_of_match),\n\t\t.pm\t\t= &gnss_serial_pm_ops,\n\t},\n\t.probe\t= ubx_probe,\n\t.remove\t= ubx_remove,\n};\nmodule_serdev_device_driver(ubx_driver);\n\nMODULE_AUTHOR(\"Johan Hovold <johan@kernel.org>\");\nMODULE_DESCRIPTION(\"u-blox GNSS receiver driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}