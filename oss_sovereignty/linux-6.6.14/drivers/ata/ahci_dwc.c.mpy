{
  "module_name": "ahci_dwc.c",
  "hash_id": "b7b0c3119c934f155a370ea0a670a333f76832b28c82f42aad5069ed47b512a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_dwc.c",
  "human_readable_source": "\n \n\n#include <linux/ahci_platform.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/log2.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n\n#include \"ahci.h\"\n\n#define DRV_NAME \"ahci-dwc\"\n\n#define AHCI_DWC_FBS_PMPN_MAX\t\t15\n\n \n#define AHCI_DWC_HOST_OOBR\t\t0xbc\n#define AHCI_DWC_HOST_OOB_WE\t\tBIT(31)\n#define AHCI_DWC_HOST_CWMIN_MASK\tGENMASK(30, 24)\n#define AHCI_DWC_HOST_CWMAX_MASK\tGENMASK(23, 16)\n#define AHCI_DWC_HOST_CIMIN_MASK\tGENMASK(15, 8)\n#define AHCI_DWC_HOST_CIMAX_MASK\tGENMASK(7, 0)\n\n#define AHCI_DWC_HOST_GPCR\t\t0xd0\n#define AHCI_DWC_HOST_GPSR\t\t0xd4\n\n#define AHCI_DWC_HOST_TIMER1MS\t\t0xe0\n#define AHCI_DWC_HOST_TIMV_MASK\t\tGENMASK(19, 0)\n\n#define AHCI_DWC_HOST_GPARAM1R\t\t0xe8\n#define AHCI_DWC_HOST_ALIGN_M\t\tBIT(31)\n#define AHCI_DWC_HOST_RX_BUFFER\t\tBIT(30)\n#define AHCI_DWC_HOST_PHY_DATA_MASK\tGENMASK(29, 28)\n#define AHCI_DWC_HOST_PHY_RST\t\tBIT(27)\n#define AHCI_DWC_HOST_PHY_CTRL_MASK\tGENMASK(26, 21)\n#define AHCI_DWC_HOST_PHY_STAT_MASK\tGENMASK(20, 15)\n#define AHCI_DWC_HOST_LATCH_M\t\tBIT(14)\n#define AHCI_DWC_HOST_PHY_TYPE_MASK\tGENMASK(13, 11)\n#define AHCI_DWC_HOST_RET_ERR\t\tBIT(10)\n#define AHCI_DWC_HOST_AHB_ENDIAN_MASK\tGENMASK(9, 8)\n#define AHCI_DWC_HOST_S_HADDR\t\tBIT(7)\n#define AHCI_DWC_HOST_M_HADDR\t\tBIT(6)\n#define AHCI_DWC_HOST_S_HDATA_MASK\tGENMASK(5, 3)\n#define AHCI_DWC_HOST_M_HDATA_MASK\tGENMASK(2, 0)\n\n#define AHCI_DWC_HOST_GPARAM2R\t\t0xec\n#define AHCI_DWC_HOST_FBS_MEM_S\t\tBIT(19)\n#define AHCI_DWC_HOST_FBS_PMPN_MASK\tGENMASK(17, 16)\n#define AHCI_DWC_HOST_FBS_SUP\t\tBIT(15)\n#define AHCI_DWC_HOST_DEV_CP\t\tBIT(14)\n#define AHCI_DWC_HOST_DEV_MP\t\tBIT(13)\n#define AHCI_DWC_HOST_ENCODE_M\t\tBIT(12)\n#define AHCI_DWC_HOST_RXOOB_CLK_M\tBIT(11)\n#define AHCI_DWC_HOST_RXOOB_M\t\tBIT(10)\n#define AHCI_DWC_HOST_TXOOB_M\t\tBIT(9)\n#define AHCI_DWC_HOST_RXOOB_M\t\tBIT(10)\n#define AHCI_DWC_HOST_RXOOB_CLK_MASK\tGENMASK(8, 0)\n\n#define AHCI_DWC_HOST_PPARAMR\t\t0xf0\n#define AHCI_DWC_HOST_TX_MEM_M\t\tBIT(11)\n#define AHCI_DWC_HOST_TX_MEM_S\t\tBIT(10)\n#define AHCI_DWC_HOST_RX_MEM_M\t\tBIT(9)\n#define AHCI_DWC_HOST_RX_MEM_S\t\tBIT(8)\n#define AHCI_DWC_HOST_TXFIFO_DEPTH\tGENMASK(7, 4)\n#define AHCI_DWC_HOST_RXFIFO_DEPTH\tGENMASK(3, 0)\n\n#define AHCI_DWC_HOST_TESTR\t\t0xf4\n#define AHCI_DWC_HOST_PSEL_MASK\t\tGENMASK(18, 16)\n#define AHCI_DWC_HOST_TEST_IF\t\tBIT(0)\n\n#define AHCI_DWC_HOST_VERSIONR\t\t0xf8\n#define AHCI_DWC_HOST_IDR\t\t0xfc\n\n#define AHCI_DWC_PORT_DMACR\t\t0x70\n#define AHCI_DWC_PORT_RXABL_MASK\tGENMASK(15, 12)\n#define AHCI_DWC_PORT_TXABL_MASK\tGENMASK(11, 8)\n#define AHCI_DWC_PORT_RXTS_MASK\t\tGENMASK(7, 4)\n#define AHCI_DWC_PORT_TXTS_MASK\t\tGENMASK(3, 0)\n#define AHCI_DWC_PORT_PHYCR\t\t0x74\n#define AHCI_DWC_PORT_PHYSR\t\t0x78\n\n \n#define AHCI_BT1_HOST_PHYCR\t\tAHCI_DWC_HOST_GPCR\n#define AHCI_BT1_HOST_MPLM_MASK\t\tGENMASK(29, 23)\n#define AHCI_BT1_HOST_LOSDT_MASK\tGENMASK(22, 20)\n#define AHCI_BT1_HOST_CRR\t\tBIT(19)\n#define AHCI_BT1_HOST_CRW\t\tBIT(18)\n#define AHCI_BT1_HOST_CRCD\t\tBIT(17)\n#define AHCI_BT1_HOST_CRCA\t\tBIT(16)\n#define AHCI_BT1_HOST_CRDI_MASK\t\tGENMASK(15, 0)\n\n#define AHCI_BT1_HOST_PHYSR\t\tAHCI_DWC_HOST_GPSR\n#define AHCI_BT1_HOST_CRA\t\tBIT(16)\n#define AHCI_BT1_HOST_CRDO_MASK\t\tGENMASK(15, 0)\n\nstruct ahci_dwc_plat_data {\n\tunsigned int pflags;\n\tunsigned int hflags;\n\tint (*init)(struct ahci_host_priv *hpriv);\n\tint (*reinit)(struct ahci_host_priv *hpriv);\n\tvoid (*clear)(struct ahci_host_priv *hpriv);\n};\n\nstruct ahci_dwc_host_priv {\n\tconst struct ahci_dwc_plat_data *pdata;\n\tstruct platform_device *pdev;\n\n\tu32 timv;\n\tu32 dmacr[AHCI_MAX_PORTS];\n};\n\nstatic int ahci_bt1_init(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\tint ret;\n\n\t \n\tif (!ahci_platform_find_clk(hpriv, \"pclk\") ||\n\t    !ahci_platform_find_clk(hpriv, \"aclk\") ||\n\t    !ahci_platform_find_clk(hpriv, \"ref\")) {\n\t\tdev_err(&dpriv->pdev->dev, \"No system clocks specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = ahci_platform_assert_rsts(hpriv);\n\tif (ret) {\n\t\tdev_err(&dpriv->pdev->dev, \"Couldn't assert the resets\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ahci_platform_deassert_rsts(hpriv);\n\tif (ret) {\n\t\tdev_err(&dpriv->pdev->dev, \"Couldn't de-assert the resets\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ahci_host_priv *ahci_dwc_get_resources(struct platform_device *pdev)\n{\n\tstruct ahci_dwc_host_priv *dpriv;\n\tstruct ahci_host_priv *hpriv;\n\n\tdpriv = devm_kzalloc(&pdev->dev, sizeof(*dpriv), GFP_KERNEL);\n\tif (!dpriv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdpriv->pdev = pdev;\n\tdpriv->pdata = device_get_match_data(&pdev->dev);\n\tif (!dpriv->pdata)\n\t\treturn ERR_PTR(-EINVAL);\n\n\thpriv = ahci_platform_get_resources(pdev, dpriv->pdata->pflags);\n\tif (IS_ERR(hpriv))\n\t\treturn hpriv;\n\n\thpriv->flags |= dpriv->pdata->hflags;\n\thpriv->plat_data = (void *)dpriv;\n\n\treturn hpriv;\n}\n\nstatic void ahci_dwc_check_cap(struct ahci_host_priv *hpriv)\n{\n\tunsigned long port_map = hpriv->saved_port_map | hpriv->mask_port_map;\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\tbool dev_mp, dev_cp, fbs_sup;\n\tunsigned int fbs_pmp;\n\tu32 param;\n\tint i;\n\n\tparam = readl(hpriv->mmio + AHCI_DWC_HOST_GPARAM2R);\n\tdev_mp = !!(param & AHCI_DWC_HOST_DEV_MP);\n\tdev_cp = !!(param & AHCI_DWC_HOST_DEV_CP);\n\tfbs_sup = !!(param & AHCI_DWC_HOST_FBS_SUP);\n\tfbs_pmp = 5 * FIELD_GET(AHCI_DWC_HOST_FBS_PMPN_MASK, param);\n\n\tif (!dev_mp && hpriv->saved_cap & HOST_CAP_MPS) {\n\t\tdev_warn(&dpriv->pdev->dev, \"MPS is unsupported\\n\");\n\t\thpriv->saved_cap &= ~HOST_CAP_MPS;\n\t}\n\n\n\tif (fbs_sup && fbs_pmp < AHCI_DWC_FBS_PMPN_MAX) {\n\t\tdev_warn(&dpriv->pdev->dev, \"PMPn is limited up to %u ports\\n\",\n\t\t\t fbs_pmp);\n\t}\n\n\tfor_each_set_bit(i, &port_map, AHCI_MAX_PORTS) {\n\t\tif (!dev_mp && hpriv->saved_port_cap[i] & PORT_CMD_MPSP) {\n\t\t\tdev_warn(&dpriv->pdev->dev, \"MPS incapable port %d\\n\", i);\n\t\t\thpriv->saved_port_cap[i] &= ~PORT_CMD_MPSP;\n\t\t}\n\n\t\tif (!dev_cp && hpriv->saved_port_cap[i] & PORT_CMD_CPD) {\n\t\t\tdev_warn(&dpriv->pdev->dev, \"CPD incapable port %d\\n\", i);\n\t\t\thpriv->saved_port_cap[i] &= ~PORT_CMD_CPD;\n\t\t}\n\n\t\tif (!fbs_sup && hpriv->saved_port_cap[i] & PORT_CMD_FBSCP) {\n\t\t\tdev_warn(&dpriv->pdev->dev, \"FBS incapable port %d\\n\", i);\n\t\t\thpriv->saved_port_cap[i] &= ~PORT_CMD_FBSCP;\n\t\t}\n\t}\n}\n\nstatic void ahci_dwc_init_timer(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\tunsigned long rate;\n\tstruct clk *aclk;\n\tu32 cap, cap2;\n\n\t \n\tcap = readl(hpriv->mmio + HOST_CAP);\n\tcap2 = readl(hpriv->mmio + HOST_CAP2);\n\tif (!(cap & HOST_CAP_CCC) && !(cap2 & HOST_CAP2_SDS))\n\t\treturn;\n\n\t \n\taclk = ahci_platform_find_clk(hpriv, \"aclk\");\n\tif (!aclk)\n\t\treturn;\n\n\t \n\tdpriv->timv = readl(hpriv->mmio + AHCI_DWC_HOST_TIMER1MS);\n\tdpriv->timv = FIELD_GET(AHCI_DWC_HOST_TIMV_MASK, dpriv->timv);\n\trate = clk_get_rate(aclk) / 1000UL;\n\tif (rate == dpriv->timv)\n\t\treturn;\n\n\tdev_info(&dpriv->pdev->dev, \"Update CCC/DevSlp timer for Fapp %lu MHz\\n\",\n\t\t rate / 1000UL);\n\tdpriv->timv = FIELD_PREP(AHCI_DWC_HOST_TIMV_MASK, rate);\n\twritel(dpriv->timv, hpriv->mmio + AHCI_DWC_HOST_TIMER1MS);\n}\n\nstatic int ahci_dwc_init_dmacr(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\tstruct device_node *child;\n\tvoid __iomem *port_mmio;\n\tu32 port, dmacr, ts;\n\n\t \n\tfor_each_child_of_node(dpriv->pdev->dev.of_node, child) {\n\t\tif (!of_device_is_available(child))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(child, \"reg\", &port)) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tport_mmio = __ahci_port_base(hpriv, port);\n\t\tdmacr = readl(port_mmio + AHCI_DWC_PORT_DMACR);\n\n\t\tif (!of_property_read_u32(child, \"snps,tx-ts-max\", &ts)) {\n\t\t\tts = ilog2(ts);\n\t\t\tdmacr &= ~AHCI_DWC_PORT_TXTS_MASK;\n\t\t\tdmacr |= FIELD_PREP(AHCI_DWC_PORT_TXTS_MASK, ts);\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"snps,rx-ts-max\", &ts)) {\n\t\t\tts = ilog2(ts);\n\t\t\tdmacr &= ~AHCI_DWC_PORT_RXTS_MASK;\n\t\t\tdmacr |= FIELD_PREP(AHCI_DWC_PORT_RXTS_MASK, ts);\n\t\t}\n\n\t\twritel(dmacr, port_mmio + AHCI_DWC_PORT_DMACR);\n\t\tdpriv->dmacr[port] = dmacr;\n\t}\n\n\treturn 0;\n}\n\nstatic int ahci_dwc_init_host(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\tint rc;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\tif (dpriv->pdata->init) {\n\t\trc = dpriv->pdata->init(hpriv);\n\t\tif (rc)\n\t\t\tgoto err_disable_resources;\n\t}\n\n\tahci_dwc_check_cap(hpriv);\n\n\tahci_dwc_init_timer(hpriv);\n\n\trc = ahci_dwc_init_dmacr(hpriv);\n\tif (rc)\n\t\tgoto err_clear_platform;\n\n\treturn 0;\n\nerr_clear_platform:\n\tif (dpriv->pdata->clear)\n\t\tdpriv->pdata->clear(hpriv);\n\nerr_disable_resources:\n\tahci_platform_disable_resources(hpriv);\n\n\treturn rc;\n}\n\nstatic int ahci_dwc_reinit_host(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\tunsigned long port_map = hpriv->port_map;\n\tvoid __iomem *port_mmio;\n\tint i, rc;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\tif (dpriv->pdata->reinit) {\n\t\trc = dpriv->pdata->reinit(hpriv);\n\t\tif (rc)\n\t\t\tgoto err_disable_resources;\n\t}\n\n\twritel(dpriv->timv, hpriv->mmio + AHCI_DWC_HOST_TIMER1MS);\n\n\tfor_each_set_bit(i, &port_map, AHCI_MAX_PORTS) {\n\t\tport_mmio = __ahci_port_base(hpriv, i);\n\t\twritel(dpriv->dmacr[i], port_mmio + AHCI_DWC_PORT_DMACR);\n\t}\n\n\treturn 0;\n\nerr_disable_resources:\n\tahci_platform_disable_resources(hpriv);\n\n\treturn rc;\n}\n\nstatic void ahci_dwc_clear_host(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_dwc_host_priv *dpriv = hpriv->plat_data;\n\n\tif (dpriv->pdata->clear)\n\t\tdpriv->pdata->clear(hpriv);\n\n\tahci_platform_disable_resources(hpriv);\n}\n\nstatic void ahci_dwc_stop_host(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\tahci_dwc_clear_host(hpriv);\n}\n\nstatic struct ata_port_operations ahci_dwc_port_ops = {\n\t.inherits\t= &ahci_platform_ops,\n\t.host_stop\t= ahci_dwc_stop_host,\n};\n\nstatic const struct ata_port_info ahci_dwc_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_dwc_port_ops,\n};\n\nstatic const struct scsi_host_template ahci_dwc_scsi_info = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int ahci_dwc_probe(struct platform_device *pdev)\n{\n\tstruct ahci_host_priv *hpriv;\n\tint rc;\n\n\thpriv = ahci_dwc_get_resources(pdev);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\trc = ahci_dwc_init_host(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_platform_init_host(pdev, hpriv, &ahci_dwc_port_info,\n\t\t\t\t     &ahci_dwc_scsi_info);\n\tif (rc)\n\t\tgoto err_clear_host;\n\n\treturn 0;\n\nerr_clear_host:\n\tahci_dwc_clear_host(hpriv);\n\n\treturn rc;\n}\n\nstatic int ahci_dwc_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_platform_suspend_host(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tahci_dwc_clear_host(hpriv);\n\n\treturn 0;\n}\n\nstatic int ahci_dwc_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_dwc_reinit_host(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\treturn ahci_platform_resume_host(dev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ahci_dwc_pm_ops, ahci_dwc_suspend,\n\t\t\t\tahci_dwc_resume);\n\nstatic struct ahci_dwc_plat_data ahci_dwc_plat = {\n\t.pflags = AHCI_PLATFORM_GET_RESETS,\n};\n\nstatic struct ahci_dwc_plat_data ahci_bt1_plat = {\n\t.pflags = AHCI_PLATFORM_GET_RESETS | AHCI_PLATFORM_RST_TRIGGER,\n\t.init = ahci_bt1_init,\n};\n\nstatic const struct of_device_id ahci_dwc_of_match[] = {\n\t{ .compatible = \"snps,dwc-ahci\", &ahci_dwc_plat },\n\t{ .compatible = \"snps,spear-ahci\", &ahci_dwc_plat },\n\t{ .compatible = \"baikal,bt1-ahci\", &ahci_bt1_plat },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ahci_dwc_of_match);\n\nstatic struct platform_driver ahci_dwc_driver = {\n\t.probe = ahci_dwc_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.shutdown = ahci_platform_shutdown,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_dwc_of_match,\n\t\t.pm = &ahci_dwc_pm_ops,\n\t},\n};\nmodule_platform_driver(ahci_dwc_driver);\n\nMODULE_DESCRIPTION(\"DWC AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Serge Semin <Sergey.Semin@baikalelectronics.ru>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}