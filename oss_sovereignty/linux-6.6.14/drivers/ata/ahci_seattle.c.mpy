{
  "module_name": "ahci_seattle.c",
  "hash_id": "1728bb0c1c87193139845ae0bf19d60056529979d76ecb315f1dc78098bbaff9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_seattle.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/libata.h>\n#include <linux/ahci_platform.h>\n#include <linux/acpi.h>\n#include <linux/pci_ids.h>\n#include \"ahci.h\"\n\n \n#define ACTIVITY_BIT_POS(x)\t\t(8 + (3 * x))\n#define LOCATE_BIT_POS(x)\t\t(ACTIVITY_BIT_POS(x) + 1)\n#define FAULT_BIT_POS(x)\t\t(LOCATE_BIT_POS(x) + 1)\n\n#define ACTIVITY_MASK\t\t\t0x00010000\n#define LOCATE_MASK\t\t\t0x00080000\n#define FAULT_MASK\t\t\t0x00400000\n\n#define DRV_NAME \"ahci-seattle\"\n\nstatic ssize_t seattle_transmit_led_message(struct ata_port *ap, u32 state,\n\t\t\t\t\t    ssize_t size);\n\nstruct seattle_plat_data {\n\tvoid __iomem *sgpio_ctrl;\n};\n\nstatic struct ata_port_operations ahci_port_ops = {\n\t.inherits\t\t= &ahci_ops,\n};\n\nstatic const struct ata_port_info ahci_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_port_ops,\n};\n\nstatic struct ata_port_operations ahci_seattle_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.transmit_led_message   = seattle_transmit_led_message,\n};\n\nstatic const struct ata_port_info ahci_port_seattle_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON | ATA_FLAG_EM | ATA_FLAG_SW_ACTIVITY,\n\t.link_flags\t= ATA_LFLAG_SW_ACTIVITY,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_seattle_ops,\n};\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic ssize_t seattle_transmit_led_message(struct ata_port *ap, u32 state,\n\t\t\t\t\t    ssize_t size)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct seattle_plat_data *plat_data = hpriv->plat_data;\n\tunsigned long flags;\n\tint pmp;\n\tstruct ahci_em_priv *emp;\n\tu32 val;\n\n\t \n\tpmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\n\tif (pmp >= EM_MAX_SLOTS)\n\t\treturn -EINVAL;\n\temp = &pp->em_priv[pmp];\n\n\tval = ioread32(plat_data->sgpio_ctrl);\n\tif (state & ACTIVITY_MASK)\n\t\tval |= 1 << ACTIVITY_BIT_POS((ap->port_no));\n\telse\n\t\tval &= ~(1 << ACTIVITY_BIT_POS((ap->port_no)));\n\n\tif (state & LOCATE_MASK)\n\t\tval |= 1 << LOCATE_BIT_POS((ap->port_no));\n\telse\n\t\tval &= ~(1 << LOCATE_BIT_POS((ap->port_no)));\n\n\tif (state & FAULT_MASK)\n\t\tval |= 1 << FAULT_BIT_POS((ap->port_no));\n\telse\n\t\tval &= ~(1 << FAULT_BIT_POS((ap->port_no)));\n\n\tiowrite32(val, plat_data->sgpio_ctrl);\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\temp->led_state = state;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn size;\n}\n\nstatic const struct ata_port_info *ahci_seattle_get_port_info(\n\t\tstruct platform_device *pdev, struct ahci_host_priv *hpriv)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct seattle_plat_data *plat_data;\n\tu32 val;\n\n\tplat_data = devm_kzalloc(dev, sizeof(*plat_data), GFP_KERNEL);\n\tif (!plat_data)\n\t\treturn &ahci_port_info;\n\n\tplat_data->sgpio_ctrl = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(plat_data->sgpio_ctrl))\n\t\treturn &ahci_port_info;\n\n\tval = ioread32(plat_data->sgpio_ctrl);\n\n\tif (!(val & 0xf))\n\t\treturn &ahci_port_info;\n\n\thpriv->em_loc = 0;\n\thpriv->em_buf_sz = 4;\n\thpriv->em_msg_type = EM_MSG_TYPE_LED;\n\thpriv->plat_data = plat_data;\n\n\tdev_info(dev, \"SGPIO LED control is enabled.\\n\");\n\treturn &ahci_port_seattle_info;\n}\n\nstatic int ahci_seattle_probe(struct platform_device *pdev)\n{\n\tint rc;\n\tstruct ahci_host_priv *hpriv;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_platform_init_host(pdev, hpriv,\n\t\t\t\t     ahci_seattle_get_port_info(pdev, hpriv),\n\t\t\t\t     &ahci_platform_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,\n\t\t\t ahci_platform_resume);\n\nstatic const struct acpi_device_id ahci_acpi_match[] = {\n\t{ \"AMDI0600\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, ahci_acpi_match);\n\nstatic struct platform_driver ahci_seattle_driver = {\n\t.probe = ahci_seattle_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.acpi_match_table = ahci_acpi_match,\n\t\t.pm = &ahci_pm_ops,\n\t},\n};\nmodule_platform_driver(ahci_seattle_driver);\n\nMODULE_DESCRIPTION(\"Seattle AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Brijesh Singh <brijesh.singh@amd.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}