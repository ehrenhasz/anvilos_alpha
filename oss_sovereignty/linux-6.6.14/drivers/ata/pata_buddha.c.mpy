{
  "module_name": "pata_buddha.c",
  "hash_id": "2a5eb90dae75490fb898a8289739d049c65cc3289c95df7ac1c74e22292843bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_buddha.c",
  "human_readable_source": "\n\n \n\n#include <linux/ata.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/zorro.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/setup.h>\n\n#define DRV_NAME \"pata_buddha\"\n#define DRV_VERSION \"0.1.1\"\n\n#define BUDDHA_BASE1\t0x800\n#define BUDDHA_BASE2\t0xa00\n#define BUDDHA_BASE3\t0xc00\n#define XSURF_BASE1\t0xb000  \n#define XSURF_BASE2\t0xd000  \n#define BUDDHA_CONTROL\t0x11a\n#define BUDDHA_IRQ\t0xf00\n#define XSURF_IRQ\t0x7e\n#define BUDDHA_IRQ_MR\t0xfc0\t \n\nenum {\n\tBOARD_BUDDHA = 0,\n\tBOARD_CATWEASEL,\n\tBOARD_XSURF\n};\n\nstatic unsigned int buddha_bases[3] = {\n\tBUDDHA_BASE1, BUDDHA_BASE2, BUDDHA_BASE3\n};\n\nstatic unsigned int xsurf_bases[2] = {\n\tXSURF_BASE1, XSURF_BASE2\n};\n\nstatic const struct scsi_host_template pata_buddha_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\n \nstatic unsigned int pata_buddha_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\t\t unsigned char *buf,\n\t\t\t\t\t unsigned int buflen, int rw)\n{\n\tstruct ata_device *dev = qc->dev;\n\tstruct ata_port *ap = dev->link->ap;\n\tvoid __iomem *data_addr = ap->ioaddr.data_addr;\n\tunsigned int words = buflen >> 1;\n\n\t \n\tif (rw == READ)\n\t\traw_insw((u16 *)data_addr, (u16 *)buf, words);\n\telse\n\t\traw_outsw((u16 *)data_addr, (u16 *)buf, words);\n\n\t \n\tif (unlikely(buflen & 0x01)) {\n\t\tunsigned char pad[2] = { };\n\n\t\t \n\t\tbuf += buflen - 1;\n\n\t\tif (rw == READ) {\n\t\t\traw_insw((u16 *)data_addr, (u16 *)pad, 1);\n\t\t\t*buf = pad[0];\n\t\t} else {\n\t\t\tpad[0] = *buf;\n\t\t\traw_outsw((u16 *)data_addr, (u16 *)pad, 1);\n\t\t}\n\t\twords++;\n\t}\n\n\treturn words << 1;\n}\n\n \nstatic int pata_buddha_set_mode(struct ata_link *link,\n\t\t\t\tstruct ata_device **unused)\n{\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\t \n\t\tdev->pio_mode = dev->xfer_mode = XFER_PIO_0;\n\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\tdev->flags |= ATA_DFLAG_PIO;\n\t\tata_dev_info(dev, \"configured for PIO\\n\");\n\t}\n\treturn 0;\n}\n\nstatic bool pata_buddha_irq_check(struct ata_port *ap)\n{\n\tu8 ch;\n\n\tch = z_readb((unsigned long)ap->private_data);\n\n\treturn !!(ch & 0x80);\n}\n\nstatic void pata_xsurf_irq_clear(struct ata_port *ap)\n{\n\tz_writeb(0, (unsigned long)ap->private_data);\n}\n\nstatic struct ata_port_operations pata_buddha_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t= pata_buddha_data_xfer,\n\t.sff_irq_check\t= pata_buddha_irq_check,\n\t.cable_detect\t= ata_cable_unknown,\n\t.set_mode\t= pata_buddha_set_mode,\n};\n\nstatic struct ata_port_operations pata_xsurf_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t= pata_buddha_data_xfer,\n\t.sff_irq_check\t= pata_buddha_irq_check,\n\t.sff_irq_clear\t= pata_xsurf_irq_clear,\n\t.cable_detect\t= ata_cable_unknown,\n\t.set_mode\t= pata_buddha_set_mode,\n};\n\nstatic int pata_buddha_probe(struct zorro_dev *z,\n\t\t\t     const struct zorro_device_id *ent)\n{\n\tstatic const char * const board_name[] = {\n\t\t\"Buddha\", \"Catweasel\", \"X-Surf\"\n\t};\n\tstruct ata_host *host;\n\tvoid __iomem *buddha_board;\n\tunsigned long board;\n\tunsigned int type = ent->driver_data;\n\tunsigned int nr_ports = (type == BOARD_CATWEASEL) ? 3 : 2;\n\tvoid *old_drvdata;\n\tint i;\n\n\tdev_info(&z->dev, \"%s IDE controller\\n\", board_name[type]);\n\n\tboard = z->resource.start;\n\n\tif (type != BOARD_XSURF) {\n\t\tif (!devm_request_mem_region(&z->dev,\n\t\t\t\t\t     board + BUDDHA_BASE1,\n\t\t\t\t\t     0x800, DRV_NAME))\n\t\t\treturn -ENXIO;\n\t} else {\n\t\tif (!devm_request_mem_region(&z->dev,\n\t\t\t\t\t     board + XSURF_BASE1,\n\t\t\t\t\t     0x1000, DRV_NAME))\n\t\t\treturn -ENXIO;\n\t\tif (!devm_request_mem_region(&z->dev,\n\t\t\t\t\t     board + XSURF_BASE2,\n\t\t\t\t\t     0x1000, DRV_NAME)) {\n\t\t}\n\t}\n\n\t \n\tif (type == BOARD_XSURF)\n\t\told_drvdata = dev_get_drvdata(&z->dev);\n\n\t \n\thost = ata_host_alloc(&z->dev, nr_ports);\n\tif (type == BOARD_XSURF)\n\t\tdev_set_drvdata(&z->dev, old_drvdata);\n\tif (!host)\n\t\treturn -ENXIO;\n\n\tbuddha_board = ZTWO_VADDR(board);\n\n\t \n\tif (type != BOARD_XSURF)\n\t\tz_writeb(0, buddha_board + BUDDHA_IRQ_MR);\n\n\tfor (i = 0; i < nr_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tvoid __iomem *base, *irqport;\n\t\tunsigned long ctl = 0;\n\n\t\tif (type != BOARD_XSURF) {\n\t\t\tap->ops = &pata_buddha_ops;\n\t\t\tbase = buddha_board + buddha_bases[i];\n\t\t\tctl = BUDDHA_CONTROL;\n\t\t\tirqport = buddha_board + BUDDHA_IRQ + i * 0x40;\n\t\t} else {\n\t\t\tap->ops = &pata_xsurf_ops;\n\t\t\tbase = buddha_board + xsurf_bases[i];\n\t\t\t \n\t\t\tirqport = buddha_board + XSURF_IRQ;\n\t\t}\n\n\t\tap->pio_mask = ATA_PIO4;\n\t\tap->flags |= ATA_FLAG_SLAVE_POSS | ATA_FLAG_NO_IORDY;\n\n\t\tap->ioaddr.data_addr\t\t= base;\n\t\tap->ioaddr.error_addr\t\t= base + 2 + 1 * 4;\n\t\tap->ioaddr.feature_addr\t\t= base + 2 + 1 * 4;\n\t\tap->ioaddr.nsect_addr\t\t= base + 2 + 2 * 4;\n\t\tap->ioaddr.lbal_addr\t\t= base + 2 + 3 * 4;\n\t\tap->ioaddr.lbam_addr\t\t= base + 2 + 4 * 4;\n\t\tap->ioaddr.lbah_addr\t\t= base + 2 + 5 * 4;\n\t\tap->ioaddr.device_addr\t\t= base + 2 + 6 * 4;\n\t\tap->ioaddr.status_addr\t\t= base + 2 + 7 * 4;\n\t\tap->ioaddr.command_addr\t\t= base + 2 + 7 * 4;\n\n\t\tif (ctl) {\n\t\t\tap->ioaddr.altstatus_addr = base + ctl;\n\t\t\tap->ioaddr.ctl_addr\t  = base + ctl;\n\t\t}\n\n\t\tap->private_data = (void *)irqport;\n\n\t\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\", board,\n\t\t\t      ctl ? board + buddha_bases[i] + ctl : 0);\n\t}\n\n\tata_host_activate(host, IRQ_AMIGA_PORTS, ata_sff_interrupt,\n\t\t\t  IRQF_SHARED, &pata_buddha_sht);\n\n\treturn 0;\n}\n\nstatic void pata_buddha_remove(struct zorro_dev *z)\n{\n\tstruct ata_host *host = dev_get_drvdata(&z->dev);\n\n\tata_host_detach(host);\n}\n\nstatic const struct zorro_device_id pata_buddha_zorro_tbl[] = {\n\t{ ZORRO_PROD_INDIVIDUAL_COMPUTERS_BUDDHA, BOARD_BUDDHA},\n\t{ ZORRO_PROD_INDIVIDUAL_COMPUTERS_CATWEASEL, BOARD_CATWEASEL},\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, pata_buddha_zorro_tbl);\n\nstatic struct zorro_driver pata_buddha_driver = {\n\t.name           = \"pata_buddha\",\n\t.id_table       = pata_buddha_zorro_tbl,\n\t.probe          = pata_buddha_probe,\n\t.remove         = pata_buddha_remove,\n};\n\n \nstatic int __init pata_buddha_late_init(void)\n{\n\tstruct zorro_dev *z = NULL;\n\n\t \n\tzorro_register_driver(&pata_buddha_driver);\n\n\t \n\twhile ((z = zorro_find_device(ZORRO_PROD_INDIVIDUAL_COMPUTERS_X_SURF, z))) {\n\t\tstatic struct zorro_device_id xsurf_ent = {\n\t\t\tZORRO_PROD_INDIVIDUAL_COMPUTERS_X_SURF, BOARD_XSURF\n\t\t};\n\n\t\tpata_buddha_probe(z, &xsurf_ent);\n\t}\n\n\treturn 0;\n}\nlate_initcall(pata_buddha_late_init);\n\nMODULE_AUTHOR(\"Bartlomiej Zolnierkiewicz\");\nMODULE_DESCRIPTION(\"low-level driver for Buddha/Catweasel/X-Surf PATA\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}