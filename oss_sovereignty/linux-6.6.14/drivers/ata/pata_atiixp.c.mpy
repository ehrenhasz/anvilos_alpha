{
  "module_name": "pata_atiixp.c",
  "hash_id": "5e6836075b8cec29163779668086173df270eb46da10a814b4985d88643eed1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_atiixp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n\n#define DRV_NAME \"pata_atiixp\"\n#define DRV_VERSION \"0.4.6\"\n\nenum {\n\tATIIXP_IDE_PIO_TIMING\t= 0x40,\n\tATIIXP_IDE_MWDMA_TIMING\t= 0x44,\n\tATIIXP_IDE_PIO_CONTROL\t= 0x48,\n\tATIIXP_IDE_PIO_MODE\t= 0x4a,\n\tATIIXP_IDE_UDMA_CONTROL\t= 0x54,\n\tATIIXP_IDE_UDMA_MODE \t= 0x56\n};\n\nstatic const struct dmi_system_id attixp_cable_override_dmi_table[] = {\n\t{\n\t\t \n\t\t.ident = \"MSI E350DM-E33\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"MSI\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"E350DM-E33(MS-7720)\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int atiixp_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 udma;\n\n\tif (dmi_check_system(attixp_cable_override_dmi_table))\n\t\treturn ATA_CBL_PATA40_SHORT;\n\n\t \n\tpci_read_config_byte(pdev, ATIIXP_IDE_UDMA_MODE + ap->port_no, &udma);\n\tif ((udma & 0x07) >= 0x04 || (udma & 0x70) >= 0x40)\n\t\treturn  ATA_CBL_PATA80;\n\treturn ATA_CBL_PATA40;\n}\n\nstatic DEFINE_SPINLOCK(atiixp_lock);\n\n \n\nstatic int atiixp_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstatic const struct pci_bits atiixp_enable_bits[] = {\n\t\t{ 0x48, 1, 0x01, 0x00 },\n\t\t{ 0x48, 1, 0x08, 0x00 }\n\t};\n\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tif (!pci_test_config_bits(pdev, &atiixp_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic void atiixp_set_pio_timing(struct ata_port *ap, struct ata_device *adev, int pio)\n{\n\tstatic const u8 pio_timings[5] = { 0x5D, 0x47, 0x34, 0x22, 0x20 };\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint dn = 2 * ap->port_no + adev->devno;\n\tint timing_shift = (16 * ap->port_no) + 8 * (adev->devno ^ 1);\n\tu32 pio_timing_data;\n\tu16 pio_mode_data;\n\n\tpci_read_config_word(pdev, ATIIXP_IDE_PIO_MODE, &pio_mode_data);\n\tpio_mode_data &= ~(0x7 << (4 * dn));\n\tpio_mode_data |= pio << (4 * dn);\n\tpci_write_config_word(pdev, ATIIXP_IDE_PIO_MODE, pio_mode_data);\n\n\tpci_read_config_dword(pdev, ATIIXP_IDE_PIO_TIMING, &pio_timing_data);\n\tpio_timing_data &= ~(0xFF << timing_shift);\n\tpio_timing_data |= (pio_timings[pio] << timing_shift);\n\tpci_write_config_dword(pdev, ATIIXP_IDE_PIO_TIMING, pio_timing_data);\n}\n\n \n\nstatic void atiixp_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&atiixp_lock, flags);\n\tatiixp_set_pio_timing(ap, adev, adev->pio_mode - XFER_PIO_0);\n\tspin_unlock_irqrestore(&atiixp_lock, flags);\n}\n\n \n\nstatic void atiixp_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 mwdma_timings[5] = { 0x77, 0x21, 0x20 };\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint dma = adev->dma_mode;\n\tint dn = 2 * ap->port_no + adev->devno;\n\tint wanted_pio;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&atiixp_lock, flags);\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tu16 udma_mode_data;\n\n\t\tdma -= XFER_UDMA_0;\n\n\t\tpci_read_config_word(pdev, ATIIXP_IDE_UDMA_MODE, &udma_mode_data);\n\t\tudma_mode_data &= ~(0x7 << (4 * dn));\n\t\tudma_mode_data |= dma << (4 * dn);\n\t\tpci_write_config_word(pdev, ATIIXP_IDE_UDMA_MODE, udma_mode_data);\n\t} else {\n\t\tint timing_shift = (16 * ap->port_no) + 8 * (adev->devno ^ 1);\n\t\tu32 mwdma_timing_data;\n\n\t\tdma -= XFER_MW_DMA_0;\n\n\t\tpci_read_config_dword(pdev, ATIIXP_IDE_MWDMA_TIMING,\n\t\t\t\t      &mwdma_timing_data);\n\t\tmwdma_timing_data &= ~(0xFF << timing_shift);\n\t\tmwdma_timing_data |= (mwdma_timings[dma] << timing_shift);\n\t\tpci_write_config_dword(pdev, ATIIXP_IDE_MWDMA_TIMING,\n\t\t\t\t       mwdma_timing_data);\n\t}\n\t \n\tif (adev->dma_mode >= XFER_MW_DMA_2)\n\t\twanted_pio = 4;\n\telse if (adev->dma_mode == XFER_MW_DMA_1)\n\t\twanted_pio = 3;\n\telse if (adev->dma_mode == XFER_MW_DMA_0)\n\t\twanted_pio = 0;\n\telse BUG();\n\n\tif (adev->pio_mode != wanted_pio)\n\t\tatiixp_set_pio_timing(ap, adev, wanted_pio);\n\tspin_unlock_irqrestore(&atiixp_lock, flags);\n}\n\n \n\nstatic void atiixp_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint dn = (2 * ap->port_no) + adev->devno;\n\tu16 tmp16;\n\n\tpci_read_config_word(pdev, ATIIXP_IDE_UDMA_CONTROL, &tmp16);\n\tif (ata_using_udma(adev))\n\t\ttmp16 |= (1 << dn);\n\telse\n\t\ttmp16 &= ~(1 << dn);\n\tpci_write_config_word(pdev, ATIIXP_IDE_UDMA_CONTROL, tmp16);\n\tata_bmdma_start(qc);\n}\n\n \n\nstatic void atiixp_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint dn = (2 * ap->port_no) + qc->dev->devno;\n\tu16 tmp16;\n\n\tpci_read_config_word(pdev, ATIIXP_IDE_UDMA_CONTROL, &tmp16);\n\ttmp16 &= ~(1 << dn);\n\tpci_write_config_word(pdev, ATIIXP_IDE_UDMA_CONTROL, tmp16);\n\tata_bmdma_stop(qc);\n}\n\nstatic const struct scsi_host_template atiixp_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= LIBATA_DUMB_MAX_PRD,\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations atiixp_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.qc_prep \t= ata_bmdma_dumb_qc_prep,\n\t.bmdma_start \t= atiixp_bmdma_start,\n\t.bmdma_stop\t= atiixp_bmdma_stop,\n\n\t.prereset\t= atiixp_prereset,\n\t.cable_detect\t= atiixp_cable_detect,\n\t.set_piomode\t= atiixp_set_piomode,\n\t.set_dmamode\t= atiixp_set_dmamode,\n};\n\nstatic int atiixp_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA12_ONLY,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &atiixp_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, &info };\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_ATI_IXP600_IDE)\n\t\tppi[1] = &ata_dummy_port_info;\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &atiixp_sht, NULL,\n\t\t\t\t      ATA_HOST_PARALLEL_SCAN);\n}\n\nstatic const struct pci_device_id atiixp[] = {\n\t{ PCI_VDEVICE(ATI, PCI_DEVICE_ID_ATI_IXP200_IDE), },\n\t{ PCI_VDEVICE(ATI, PCI_DEVICE_ID_ATI_IXP300_IDE), },\n\t{ PCI_VDEVICE(ATI, PCI_DEVICE_ID_ATI_IXP400_IDE), },\n\t{ PCI_VDEVICE(ATI, PCI_DEVICE_ID_ATI_IXP600_IDE), },\n\t{ PCI_VDEVICE(ATI, PCI_DEVICE_ID_ATI_IXP700_IDE), },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_HUDSON2_IDE), },\n\n\t{ },\n};\n\nstatic struct pci_driver atiixp_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= atiixp,\n\t.probe \t\t= atiixp_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.resume\t\t= ata_pci_device_resume,\n\t.suspend\t= ata_pci_device_suspend,\n#endif\n};\n\nmodule_pci_driver(atiixp_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for ATI IXP200/300/400\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, atiixp);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}