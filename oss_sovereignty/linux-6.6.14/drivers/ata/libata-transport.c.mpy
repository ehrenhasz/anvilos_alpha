{
  "module_name": "libata-transport.c",
  "hash_id": "8aaa72bab9d6dcc0a4a6698f02e3e8a6f4ed3afe9f409b6d20513748a776013d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-transport.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <scsi/scsi_transport.h>\n#include <linux/libata.h>\n#include <linux/hdreg.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n\n#include \"libata.h\"\n#include \"libata-transport.h\"\n\n#define ATA_PORT_ATTRS\t\t3\n#define ATA_LINK_ATTRS\t\t3\n#define ATA_DEV_ATTRS\t\t9\n\nstruct scsi_transport_template;\nstruct scsi_transport_template *ata_scsi_transport_template;\n\nstruct ata_internal {\n\tstruct scsi_transport_template t;\n\n\tstruct device_attribute private_port_attrs[ATA_PORT_ATTRS];\n\tstruct device_attribute private_link_attrs[ATA_LINK_ATTRS];\n\tstruct device_attribute private_dev_attrs[ATA_DEV_ATTRS];\n\n\tstruct transport_container link_attr_cont;\n\tstruct transport_container dev_attr_cont;\n\n\t \n\tstruct device_attribute *link_attrs[ATA_LINK_ATTRS + 1];\n\tstruct device_attribute *port_attrs[ATA_PORT_ATTRS + 1];\n\tstruct device_attribute *dev_attrs[ATA_DEV_ATTRS + 1];\n};\n#define to_ata_internal(tmpl)\tcontainer_of(tmpl, struct ata_internal, t)\n\n\n#define tdev_to_device(d)\t\t\t\t\t\\\n\tcontainer_of((d), struct ata_device, tdev)\n#define transport_class_to_dev(dev)\t\t\t\t\\\n\ttdev_to_device((dev)->parent)\n\n#define tdev_to_link(d)\t\t\t\t\t\t\\\n\tcontainer_of((d), struct ata_link, tdev)\n#define transport_class_to_link(dev)\t\t\t\t\\\n\ttdev_to_link((dev)->parent)\n\n#define tdev_to_port(d)\t\t\t\t\t\t\\\n\tcontainer_of((d), struct ata_port, tdev)\n#define transport_class_to_port(dev)\t\t\t\t\\\n\ttdev_to_port((dev)->parent)\n\n\n \nstatic int ata_tdev_add(struct ata_device *dev);\nstatic void ata_tdev_delete(struct ata_device *dev);\n\n\n \n#define ATA_DEVICE_ATTR(_prefix,_name,_mode,_show,_store) \\\n\tstruct device_attribute device_attr_##_prefix##_##_name = \\\n\t__ATTR(_name,_mode,_show,_store)\n\n#define ata_bitfield_name_match(title, table)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nget_ata_##title##_names(u32 table_key, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tchar *prefix = \"\";\t\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\\\n\t\tif (table[i].value & table_key) {\t\t\\\n\t\t\tlen += sprintf(buf + len, \"%s%s\",\t\\\n\t\t\t\tprefix, table[i].name);\t\t\\\n\t\t\tprefix = \", \";\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlen += sprintf(buf + len, \"\\n\");\t\t\t\\\n\treturn len;\t\t\t\t\t\t\\\n}\n\n#define ata_bitfield_name_search(title, table)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\\\nget_ata_##title##_names(u32 table_key, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(table); i++) {\t\t\\\n\t\tif (table[i].value == table_key) {\t\t\\\n\t\t\tlen += sprintf(buf + len, \"%s\",\t\t\\\n\t\t\t\ttable[i].name);\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tlen += sprintf(buf + len, \"\\n\");\t\t\t\\\n\treturn len;\t\t\t\t\t\t\\\n}\n\nstatic struct {\n\tu32\t\tvalue;\n\tchar\t\t*name;\n} ata_class_names[] = {\n\t{ ATA_DEV_UNKNOWN,\t\t\"unknown\" },\n\t{ ATA_DEV_ATA,\t\t\t\"ata\" },\n\t{ ATA_DEV_ATA_UNSUP,\t\t\"ata\" },\n\t{ ATA_DEV_ATAPI,\t\t\"atapi\" },\n\t{ ATA_DEV_ATAPI_UNSUP,\t\t\"atapi\" },\n\t{ ATA_DEV_PMP,\t\t\t\"pmp\" },\n\t{ ATA_DEV_PMP_UNSUP,\t\t\"pmp\" },\n\t{ ATA_DEV_SEMB,\t\t\t\"semb\" },\n\t{ ATA_DEV_SEMB_UNSUP,\t\t\"semb\" },\n\t{ ATA_DEV_ZAC,\t\t\t\"zac\" },\n\t{ ATA_DEV_NONE,\t\t\t\"none\" }\n};\nata_bitfield_name_search(class, ata_class_names)\n\n\nstatic struct {\n\tu32\t\tvalue;\n\tchar\t\t*name;\n} ata_err_names[] = {\n\t{ AC_ERR_DEV,\t\t\t\"DeviceError\" },\n\t{ AC_ERR_HSM,\t\t\t\"HostStateMachineError\" },\n\t{ AC_ERR_TIMEOUT,\t\t\"Timeout\" },\n\t{ AC_ERR_MEDIA,\t\t\t\"MediaError\" },\n\t{ AC_ERR_ATA_BUS,\t\t\"BusError\" },\n\t{ AC_ERR_HOST_BUS,\t\t\"HostBusError\" },\n\t{ AC_ERR_SYSTEM,\t\t\"SystemError\" },\n\t{ AC_ERR_INVALID,\t\t\"InvalidArg\" },\n\t{ AC_ERR_OTHER,\t\t\t\"Unknown\" },\n\t{ AC_ERR_NODEV_HINT,\t\t\"NoDeviceHint\" },\n\t{ AC_ERR_NCQ,\t\t\t\"NCQError\" }\n};\nata_bitfield_name_match(err, ata_err_names)\n\nstatic struct {\n\tu32\t\tvalue;\n\tchar\t\t*name;\n} ata_xfer_names[] = {\n\t{ XFER_UDMA_7,\t\t\t\"XFER_UDMA_7\" },\n\t{ XFER_UDMA_6,\t\t\t\"XFER_UDMA_6\" },\n\t{ XFER_UDMA_5,\t\t\t\"XFER_UDMA_5\" },\n\t{ XFER_UDMA_4,\t\t\t\"XFER_UDMA_4\" },\n\t{ XFER_UDMA_3,\t\t\t\"XFER_UDMA_3\" },\n\t{ XFER_UDMA_2,\t\t\t\"XFER_UDMA_2\" },\n\t{ XFER_UDMA_1,\t\t\t\"XFER_UDMA_1\" },\n\t{ XFER_UDMA_0,\t\t\t\"XFER_UDMA_0\" },\n\t{ XFER_MW_DMA_4,\t\t\"XFER_MW_DMA_4\" },\n\t{ XFER_MW_DMA_3,\t\t\"XFER_MW_DMA_3\" },\n\t{ XFER_MW_DMA_2,\t\t\"XFER_MW_DMA_2\" },\n\t{ XFER_MW_DMA_1,\t\t\"XFER_MW_DMA_1\" },\n\t{ XFER_MW_DMA_0,\t\t\"XFER_MW_DMA_0\" },\n\t{ XFER_SW_DMA_2,\t\t\"XFER_SW_DMA_2\" },\n\t{ XFER_SW_DMA_1,\t\t\"XFER_SW_DMA_1\" },\n\t{ XFER_SW_DMA_0,\t\t\"XFER_SW_DMA_0\" },\n\t{ XFER_PIO_6,\t\t\t\"XFER_PIO_6\" },\n\t{ XFER_PIO_5,\t\t\t\"XFER_PIO_5\" },\n\t{ XFER_PIO_4,\t\t\t\"XFER_PIO_4\" },\n\t{ XFER_PIO_3,\t\t\t\"XFER_PIO_3\" },\n\t{ XFER_PIO_2,\t\t\t\"XFER_PIO_2\" },\n\t{ XFER_PIO_1,\t\t\t\"XFER_PIO_1\" },\n\t{ XFER_PIO_0,\t\t\t\"XFER_PIO_0\" },\n\t{ XFER_PIO_SLOW,\t\t\"XFER_PIO_SLOW\" }\n};\nata_bitfield_name_search(xfer, ata_xfer_names)\n\n \n#define ata_port_show_simple(field, name, format_string, cast)\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_ata_port_##name(struct device *dev,\t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ata_port *ap = transport_class_to_port(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, 20, format_string, cast ap->field);\t\\\n}\n\n#define ata_port_simple_attr(field, name, format_string, type)\t\t\\\n\tata_port_show_simple(field, name, format_string, (type))\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_ata_port_##name, NULL)\n\nata_port_simple_attr(nr_pmp_links, nr_pmp_links, \"%d\\n\", int);\nata_port_simple_attr(stats.idle_irq, idle_irq, \"%ld\\n\", unsigned long);\nata_port_simple_attr(local_port_no, port_no, \"%u\\n\", unsigned int);\n\nstatic DECLARE_TRANSPORT_CLASS(ata_port_class,\n\t\t\t       \"ata_port\", NULL, NULL, NULL);\n\nstatic void ata_tport_release(struct device *dev)\n{\n\tstruct ata_port *ap = tdev_to_port(dev);\n\tata_host_put(ap->host);\n}\n\n \nstatic int ata_is_port(const struct device *dev)\n{\n\treturn dev->release == ata_tport_release;\n}\n\nstatic int ata_tport_match(struct attribute_container *cont,\n\t\t\t   struct device *dev)\n{\n\tif (!ata_is_port(dev))\n\t\treturn 0;\n\treturn &ata_scsi_transport_template->host_attrs.ac == cont;\n}\n\n \nvoid ata_tport_delete(struct ata_port *ap)\n{\n\tstruct device *dev = &ap->tdev;\n\n\tata_tlink_delete(&ap->link);\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\tput_device(dev);\n}\n\nstatic const struct device_type ata_port_sas_type = {\n\t.name = ATA_PORT_TYPE_NAME,\n};\n\n \nint ata_tport_add(struct device *parent,\n\t\t  struct ata_port *ap)\n{\n\tint error;\n\tstruct device *dev = &ap->tdev;\n\n\tdevice_initialize(dev);\n\tif (ap->flags & ATA_FLAG_SAS_HOST)\n\t\tdev->type = &ata_port_sas_type;\n\telse\n\t\tdev->type = &ata_port_type;\n\n\tdev->parent = parent;\n\tata_host_get(ap->host);\n\tdev->release = ata_tport_release;\n\tdev_set_name(dev, \"ata%d\", ap->print_id);\n\ttransport_setup_device(dev);\n\tata_acpi_bind_port(ap);\n\terror = device_add(dev);\n\tif (error) {\n\t\tgoto tport_err;\n\t}\n\n\tdevice_enable_async_suspend(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_forbid(dev);\n\n\terror = transport_add_device(dev);\n\tif (error)\n\t\tgoto tport_transport_add_err;\n\ttransport_configure_device(dev);\n\n\terror = ata_tlink_add(&ap->link);\n\tif (error) {\n\t\tgoto tport_link_err;\n\t}\n\treturn 0;\n\n tport_link_err:\n\ttransport_remove_device(dev);\n tport_transport_add_err:\n\tdevice_del(dev);\n\n tport_err:\n\ttransport_destroy_device(dev);\n\tput_device(dev);\n\treturn error;\n}\n\n \nunsigned int ata_port_classify(struct ata_port *ap,\n\t\t\t       const struct ata_taskfile *tf)\n{\n\tint i;\n\tunsigned int class = ata_dev_classify(tf);\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(ata_class_names); i++) {\n\t\tif (ata_class_names[i].value == class) {\n\t\t\tata_port_dbg(ap, \"found %s device by sig\\n\",\n\t\t\t\t     ata_class_names[i].name);\n\t\t\treturn class;\n\t\t}\n\t}\n\n\tata_port_info(ap, \"found unknown device (class %u)\\n\", class);\n\treturn class;\n}\nEXPORT_SYMBOL_GPL(ata_port_classify);\n\n \nstatic int noop(int x) { return x; }\n\n#define ata_link_show_linkspeed(field, format)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_ata_link_##field(struct device *dev,\t\t\t\t\\\n\t\t      struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ata_link *link = transport_class_to_link(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%s\\n\", sata_spd_string(format(link->field))); \\\n}\n\n#define ata_link_linkspeed_attr(field, format)\t\t\t\t\\\n\tata_link_show_linkspeed(field, format)\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, show_ata_link_##field, NULL)\n\nata_link_linkspeed_attr(hw_sata_spd_limit, fls);\nata_link_linkspeed_attr(sata_spd_limit, fls);\nata_link_linkspeed_attr(sata_spd, noop);\n\n\nstatic DECLARE_TRANSPORT_CLASS(ata_link_class,\n\t\t\"ata_link\", NULL, NULL, NULL);\n\nstatic void ata_tlink_release(struct device *dev)\n{\n}\n\n \nstatic int ata_is_link(const struct device *dev)\n{\n\treturn dev->release == ata_tlink_release;\n}\n\nstatic int ata_tlink_match(struct attribute_container *cont,\n\t\t\t   struct device *dev)\n{\n\tstruct ata_internal* i = to_ata_internal(ata_scsi_transport_template);\n\tif (!ata_is_link(dev))\n\t\treturn 0;\n\treturn &i->link_attr_cont.ac == cont;\n}\n\n \nvoid ata_tlink_delete(struct ata_link *link)\n{\n\tstruct device *dev = &link->tdev;\n\tstruct ata_device *ata_dev;\n\n\tata_for_each_dev(ata_dev, link, ALL) {\n\t\tata_tdev_delete(ata_dev);\n\t}\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\tput_device(dev);\n}\n\n \nint ata_tlink_add(struct ata_link *link)\n{\n\tstruct device *dev = &link->tdev;\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *ata_dev;\n\tint error;\n\n\tdevice_initialize(dev);\n\tdev->parent = &ap->tdev;\n\tdev->release = ata_tlink_release;\n\tif (ata_is_host_link(link))\n\t\tdev_set_name(dev, \"link%d\", ap->print_id);\n\telse\n\t\tdev_set_name(dev, \"link%d.%d\", ap->print_id, link->pmp);\n\n\ttransport_setup_device(dev);\n\n\terror = device_add(dev);\n\tif (error) {\n\t\tgoto tlink_err;\n\t}\n\n\terror = transport_add_device(dev);\n\tif (error)\n\t\tgoto tlink_transport_err;\n\ttransport_configure_device(dev);\n\n\tata_for_each_dev(ata_dev, link, ALL) {\n\t\terror = ata_tdev_add(ata_dev);\n\t\tif (error) {\n\t\t\tgoto tlink_dev_err;\n\t\t}\n\t}\n\treturn 0;\n  tlink_dev_err:\n\twhile (--ata_dev >= link->device) {\n\t\tata_tdev_delete(ata_dev);\n\t}\n\ttransport_remove_device(dev);\n  tlink_transport_err:\n\tdevice_del(dev);\n  tlink_err:\n\ttransport_destroy_device(dev);\n\tput_device(dev);\n\treturn error;\n}\n\n \n\n#define ata_dev_show_class(title, field)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_ata_dev_##field(struct device *dev,\t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ata_device *ata_dev = transport_class_to_dev(dev);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn get_ata_##title##_names(ata_dev->field, buf);\t\t\\\n}\n\n#define ata_dev_attr(title, field)\t\t\t\t\t\\\n\tata_dev_show_class(title, field)\t\t\t\t\\\nstatic DEVICE_ATTR(field, S_IRUGO, show_ata_dev_##field, NULL)\n\nata_dev_attr(class, class);\nata_dev_attr(xfer, pio_mode);\nata_dev_attr(xfer, dma_mode);\nata_dev_attr(xfer, xfer_mode);\n\n\n#define ata_dev_show_simple(field, format_string, cast)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nshow_ata_dev_##field(struct device *dev,\t\t\t\t\\\n\t\t     struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ata_device *ata_dev = transport_class_to_dev(dev);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, 20, format_string, cast ata_dev->field);\t\\\n}\n\n#define ata_dev_simple_attr(field, format_string, type)\t\t\\\n\tata_dev_show_simple(field, format_string, (type))\t\\\n\tstatic DEVICE_ATTR(field, S_IRUGO,\t\t\t\\\n\t\t   show_ata_dev_##field, NULL)\n\nata_dev_simple_attr(spdn_cnt, \"%d\\n\", int);\n\nstruct ata_show_ering_arg {\n\tchar* buf;\n\tint written;\n};\n\nstatic int ata_show_ering(struct ata_ering_entry *ent, void *void_arg)\n{\n\tstruct ata_show_ering_arg* arg = void_arg;\n\tu64 seconds;\n\tu32 rem;\n\n\tseconds = div_u64_rem(ent->timestamp, HZ, &rem);\n\targ->written += sprintf(arg->buf + arg->written,\n\t\t\t\t\"[%5llu.%09lu]\", seconds,\n\t\t\t\trem * NSEC_PER_SEC / HZ);\n\targ->written += get_ata_err_names(ent->err_mask,\n\t\t\t\t\t  arg->buf + arg->written);\n\treturn 0;\n}\n\nstatic ssize_t\nshow_ata_dev_ering(struct device *dev,\n\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ata_device *ata_dev = transport_class_to_dev(dev);\n\tstruct ata_show_ering_arg arg = { buf, 0 };\n\n\tata_ering_map(&ata_dev->ering, ata_show_ering, &arg);\n\treturn arg.written;\n}\n\n\nstatic DEVICE_ATTR(ering, S_IRUGO, show_ata_dev_ering, NULL);\n\nstatic ssize_t\nshow_ata_dev_id(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ata_device *ata_dev = transport_class_to_dev(dev);\n\tint written = 0, i = 0;\n\n\tif (ata_dev->class == ATA_DEV_PMP)\n\t\treturn 0;\n\tfor(i=0;i<ATA_ID_WORDS;i++)  {\n\t\twritten += scnprintf(buf+written, 20, \"%04x%c\",\n\t\t\t\t    ata_dev->id[i],\n\t\t\t\t    ((i+1) & 7) ? ' ' : '\\n');\n\t}\n\treturn written;\n}\n\nstatic DEVICE_ATTR(id, S_IRUGO, show_ata_dev_id, NULL);\n\nstatic ssize_t\nshow_ata_dev_gscr(struct device *dev,\n\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ata_device *ata_dev = transport_class_to_dev(dev);\n\tint written = 0, i = 0;\n\n\tif (ata_dev->class != ATA_DEV_PMP)\n\t\treturn 0;\n\tfor(i=0;i<SATA_PMP_GSCR_DWORDS;i++)  {\n\t\twritten += scnprintf(buf+written, 20, \"%08x%c\",\n\t\t\t\t    ata_dev->gscr[i],\n\t\t\t\t    ((i+1) & 3) ? ' ' : '\\n');\n\t}\n\tif (SATA_PMP_GSCR_DWORDS & 3)\n\t\tbuf[written-1] = '\\n';\n\treturn written;\n}\n\nstatic DEVICE_ATTR(gscr, S_IRUGO, show_ata_dev_gscr, NULL);\n\nstatic ssize_t\nshow_ata_dev_trim(struct device *dev,\n\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ata_device *ata_dev = transport_class_to_dev(dev);\n\tunsigned char *mode;\n\n\tif (!ata_id_has_trim(ata_dev->id))\n\t\tmode = \"unsupported\";\n\telse if (ata_dev->horkage & ATA_HORKAGE_NOTRIM)\n\t\tmode = \"forced_unsupported\";\n\telse if (ata_dev->horkage & ATA_HORKAGE_NO_NCQ_TRIM)\n\t\t\tmode = \"forced_unqueued\";\n\telse if (ata_fpdma_dsm_supported(ata_dev))\n\t\tmode = \"queued\";\n\telse\n\t\tmode = \"unqueued\";\n\n\treturn scnprintf(buf, 20, \"%s\\n\", mode);\n}\n\nstatic DEVICE_ATTR(trim, S_IRUGO, show_ata_dev_trim, NULL);\n\nstatic DECLARE_TRANSPORT_CLASS(ata_dev_class,\n\t\t\t       \"ata_device\", NULL, NULL, NULL);\n\nstatic void ata_tdev_release(struct device *dev)\n{\n}\n\n \nstatic int ata_is_ata_dev(const struct device *dev)\n{\n\treturn dev->release == ata_tdev_release;\n}\n\nstatic int ata_tdev_match(struct attribute_container *cont,\n\t\t\t  struct device *dev)\n{\n\tstruct ata_internal* i = to_ata_internal(ata_scsi_transport_template);\n\tif (!ata_is_ata_dev(dev))\n\t\treturn 0;\n\treturn &i->dev_attr_cont.ac == cont;\n}\n\n \nstatic void ata_tdev_free(struct ata_device *dev)\n{\n\ttransport_destroy_device(&dev->tdev);\n\tput_device(&dev->tdev);\n}\n\n \nstatic void ata_tdev_delete(struct ata_device *ata_dev)\n{\n\tstruct device *dev = &ata_dev->tdev;\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\tata_tdev_free(ata_dev);\n}\n\n\n \nstatic int ata_tdev_add(struct ata_device *ata_dev)\n{\n\tstruct device *dev = &ata_dev->tdev;\n\tstruct ata_link *link = ata_dev->link;\n\tstruct ata_port *ap = link->ap;\n\tint error;\n\n\tdevice_initialize(dev);\n\tdev->parent = &link->tdev;\n\tdev->release = ata_tdev_release;\n\tif (ata_is_host_link(link))\n\t\tdev_set_name(dev, \"dev%d.%d\", ap->print_id,ata_dev->devno);\n\telse\n\t\tdev_set_name(dev, \"dev%d.%d.0\", ap->print_id, link->pmp);\n\n\ttransport_setup_device(dev);\n\tata_acpi_bind_dev(ata_dev);\n\terror = device_add(dev);\n\tif (error) {\n\t\tata_tdev_free(ata_dev);\n\t\treturn error;\n\t}\n\n\terror = transport_add_device(dev);\n\tif (error) {\n\t\tdevice_del(dev);\n\t\tata_tdev_free(ata_dev);\n\t\treturn error;\n\t}\n\n\ttransport_configure_device(dev);\n\treturn 0;\n}\n\n\n \n\n#define SETUP_TEMPLATE(attrb, field, perm, test)\t\t\t\\\n\ti->private_##attrb[count] = dev_attr_##field;\t\t\t\\\n\ti->private_##attrb[count].attr.mode = perm;\t\t\t\\\n\ti->attrb[count] = &i->private_##attrb[count];\t\t\t\\\n\tif (test)\t\t\t\t\t\t\t\\\n\t\tcount++\n\n#define SETUP_LINK_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(link_attrs, field, S_IRUGO, 1)\n\n#define SETUP_PORT_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(port_attrs, field, S_IRUGO, 1)\n\n#define SETUP_DEV_ATTRIBUTE(field)\t\t\t\t\t\\\n\tSETUP_TEMPLATE(dev_attrs, field, S_IRUGO, 1)\n\n \nstruct scsi_transport_template *ata_attach_transport(void)\n{\n\tstruct ata_internal *i;\n\tint count;\n\n\ti = kzalloc(sizeof(struct ata_internal), GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\ti->t.eh_strategy_handler\t= ata_scsi_error;\n\ti->t.user_scan\t\t\t= ata_scsi_user_scan;\n\n\ti->t.host_attrs.ac.attrs = &i->port_attrs[0];\n\ti->t.host_attrs.ac.class = &ata_port_class.class;\n\ti->t.host_attrs.ac.match = ata_tport_match;\n\ttransport_container_register(&i->t.host_attrs);\n\n\ti->link_attr_cont.ac.class = &ata_link_class.class;\n\ti->link_attr_cont.ac.attrs = &i->link_attrs[0];\n\ti->link_attr_cont.ac.match = ata_tlink_match;\n\ttransport_container_register(&i->link_attr_cont);\n\n\ti->dev_attr_cont.ac.class = &ata_dev_class.class;\n\ti->dev_attr_cont.ac.attrs = &i->dev_attrs[0];\n\ti->dev_attr_cont.ac.match = ata_tdev_match;\n\ttransport_container_register(&i->dev_attr_cont);\n\n\tcount = 0;\n\tSETUP_PORT_ATTRIBUTE(nr_pmp_links);\n\tSETUP_PORT_ATTRIBUTE(idle_irq);\n\tSETUP_PORT_ATTRIBUTE(port_no);\n\tBUG_ON(count > ATA_PORT_ATTRS);\n\ti->port_attrs[count] = NULL;\n\n\tcount = 0;\n\tSETUP_LINK_ATTRIBUTE(hw_sata_spd_limit);\n\tSETUP_LINK_ATTRIBUTE(sata_spd_limit);\n\tSETUP_LINK_ATTRIBUTE(sata_spd);\n\tBUG_ON(count > ATA_LINK_ATTRS);\n\ti->link_attrs[count] = NULL;\n\n\tcount = 0;\n\tSETUP_DEV_ATTRIBUTE(class);\n\tSETUP_DEV_ATTRIBUTE(pio_mode);\n\tSETUP_DEV_ATTRIBUTE(dma_mode);\n\tSETUP_DEV_ATTRIBUTE(xfer_mode);\n\tSETUP_DEV_ATTRIBUTE(spdn_cnt);\n\tSETUP_DEV_ATTRIBUTE(ering);\n\tSETUP_DEV_ATTRIBUTE(id);\n\tSETUP_DEV_ATTRIBUTE(gscr);\n\tSETUP_DEV_ATTRIBUTE(trim);\n\tBUG_ON(count > ATA_DEV_ATTRS);\n\ti->dev_attrs[count] = NULL;\n\n\treturn &i->t;\n}\n\n \nvoid ata_release_transport(struct scsi_transport_template *t)\n{\n\tstruct ata_internal *i = to_ata_internal(t);\n\n\ttransport_container_unregister(&i->t.host_attrs);\n\ttransport_container_unregister(&i->link_attr_cont);\n\ttransport_container_unregister(&i->dev_attr_cont);\n\n\tkfree(i);\n}\n\n__init int libata_transport_init(void)\n{\n\tint error;\n\n\terror = transport_class_register(&ata_link_class);\n\tif (error)\n\t\tgoto out_unregister_transport;\n\terror = transport_class_register(&ata_port_class);\n\tif (error)\n\t\tgoto out_unregister_link;\n\terror = transport_class_register(&ata_dev_class);\n\tif (error)\n\t\tgoto out_unregister_port;\n\treturn 0;\n\n out_unregister_port:\n\ttransport_class_unregister(&ata_port_class);\n out_unregister_link:\n\ttransport_class_unregister(&ata_link_class);\n out_unregister_transport:\n\treturn error;\n\n}\n\nvoid __exit libata_transport_exit(void)\n{\n\ttransport_class_unregister(&ata_link_class);\n\ttransport_class_unregister(&ata_port_class);\n\ttransport_class_unregister(&ata_dev_class);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}