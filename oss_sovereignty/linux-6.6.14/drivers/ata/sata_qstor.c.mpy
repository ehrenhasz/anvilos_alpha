{
  "module_name": "sata_qstor.c",
  "hash_id": "8bb35adbc99d7c7b7dd0fe4f327e66754c163d398e5368418efb5916a56a3bdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_qstor.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"sata_qstor\"\n#define DRV_VERSION\t\"0.09\"\n\nenum {\n\tQS_MMIO_BAR\t\t= 4,\n\n\tQS_PORTS\t\t= 4,\n\tQS_MAX_PRD\t\t= LIBATA_MAX_PRD,\n\tQS_CPB_ORDER\t\t= 6,\n\tQS_CPB_BYTES\t\t= (1 << QS_CPB_ORDER),\n\tQS_PRD_BYTES\t\t= QS_MAX_PRD * 16,\n\tQS_PKT_BYTES\t\t= QS_CPB_BYTES + QS_PRD_BYTES,\n\n\t \n\tQS_HCF_CNFG3\t\t= 0x0003,  \n\tQS_HID_HPHY\t\t= 0x0004,  \n\tQS_HCT_CTRL\t\t= 0x00e4,  \n\tQS_HST_SFF\t\t= 0x0100,  \n\tQS_HVS_SERD3\t\t= 0x0393,  \n\n\t \n\tQS_HPHY_64BIT\t\t= (1 << 1),  \n\tQS_CNFG3_GSRST\t\t= 0x01,      \n\tQS_SERD3_PHY_ENA\t= 0xf0,      \n\n\t \n\tQS_CCF_CPBA\t\t= 0x0710,  \n\tQS_CCF_CSEP\t\t= 0x0718,  \n\tQS_CFC_HUFT\t\t= 0x0800,  \n\tQS_CFC_HDFT\t\t= 0x0804,  \n\tQS_CFC_DUFT\t\t= 0x0808,  \n\tQS_CFC_DDFT\t\t= 0x080c,  \n\tQS_CCT_CTR0\t\t= 0x0900,  \n\tQS_CCT_CTR1\t\t= 0x0901,  \n\tQS_CCT_CFF\t\t= 0x0a00,  \n\n\t \n\tQS_CTR0_REG\t\t= (1 << 1),    \n\tQS_CTR0_CLER\t\t= (1 << 2),    \n\tQS_CTR1_RDEV\t\t= (1 << 1),    \n\tQS_CTR1_RCHN\t\t= (1 << 4),    \n\tQS_CCF_RUN_PKT\t\t= 0x107,       \n\n\t \n\tQS_HCB_HDR\t\t= 0x01,    \n\tQS_DCB_HDR\t\t= 0x02,    \n\n\t \n\tQS_HF_DIRO\t\t= (1 << 0),    \n\tQS_HF_DAT\t\t= (1 << 3),    \n\tQS_HF_IEN\t\t= (1 << 4),    \n\tQS_HF_VLD\t\t= (1 << 5),    \n\n\t \n\tQS_DF_PORD\t\t= (1 << 2),    \n\tQS_DF_ELBA\t\t= (1 << 3),    \n\n\t \n\tboard_2068_idx\t\t= 0,\t \n};\n\nenum {\n\tQS_DMA_BOUNDARY\t\t= ~0UL\n};\n\ntypedef enum { qs_state_mmio, qs_state_pkt } qs_state_t;\n\nstruct qs_port_priv {\n\tu8\t\t\t*pkt;\n\tdma_addr_t\t\tpkt_dma;\n\tqs_state_t\t\tstate;\n};\n\nstatic int qs_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);\nstatic int qs_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);\nstatic int qs_ata_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic int qs_port_start(struct ata_port *ap);\nstatic void qs_host_stop(struct ata_host *host);\nstatic enum ata_completion_errors qs_qc_prep(struct ata_queued_cmd *qc);\nstatic unsigned int qs_qc_issue(struct ata_queued_cmd *qc);\nstatic int qs_check_atapi_dma(struct ata_queued_cmd *qc);\nstatic void qs_freeze(struct ata_port *ap);\nstatic void qs_thaw(struct ata_port *ap);\nstatic int qs_prereset(struct ata_link *link, unsigned long deadline);\nstatic void qs_error_handler(struct ata_port *ap);\n\nstatic const struct scsi_host_template qs_ata_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= QS_MAX_PRD,\n\t.dma_boundary\t\t= QS_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations qs_ata_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\n\t.check_atapi_dma\t= qs_check_atapi_dma,\n\t.qc_prep\t\t= qs_qc_prep,\n\t.qc_issue\t\t= qs_qc_issue,\n\n\t.freeze\t\t\t= qs_freeze,\n\t.thaw\t\t\t= qs_thaw,\n\t.prereset\t\t= qs_prereset,\n\t.softreset\t\t= ATA_OP_NULL,\n\t.error_handler\t\t= qs_error_handler,\n\t.lost_interrupt\t\t= ATA_OP_NULL,\n\n\t.scr_read\t\t= qs_scr_read,\n\t.scr_write\t\t= qs_scr_write,\n\n\t.port_start\t\t= qs_port_start,\n\t.host_stop\t\t= qs_host_stop,\n};\n\nstatic const struct ata_port_info qs_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA | ATA_FLAG_PIO_POLLING,\n\t\t.pio_mask\t= ATA_PIO4_ONLY,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &qs_ata_ops,\n\t},\n};\n\nstatic const struct pci_device_id qs_ata_pci_tbl[] = {\n\t{ PCI_VDEVICE(PDC, 0x2068), board_2068_idx },\n\n\t{ }\t \n};\n\nstatic struct pci_driver qs_ata_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= qs_ata_pci_tbl,\n\t.probe\t\t\t= qs_ata_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\nstatic void __iomem *qs_mmio_base(struct ata_host *host)\n{\n\treturn host->iomap[QS_MMIO_BAR];\n}\n\nstatic int qs_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn 1;\t \n}\n\nstatic inline void qs_enter_reg_mode(struct ata_port *ap)\n{\n\tu8 __iomem *chan = qs_mmio_base(ap->host) + (ap->port_no * 0x4000);\n\tstruct qs_port_priv *pp = ap->private_data;\n\n\tpp->state = qs_state_mmio;\n\twriteb(QS_CTR0_REG, chan + QS_CCT_CTR0);\n\treadb(chan + QS_CCT_CTR0);         \n}\n\nstatic inline void qs_reset_channel_logic(struct ata_port *ap)\n{\n\tu8 __iomem *chan = qs_mmio_base(ap->host) + (ap->port_no * 0x4000);\n\n\twriteb(QS_CTR1_RCHN, chan + QS_CCT_CTR1);\n\treadb(chan + QS_CCT_CTR0);         \n\tqs_enter_reg_mode(ap);\n}\n\nstatic void qs_freeze(struct ata_port *ap)\n{\n\tu8 __iomem *mmio_base = qs_mmio_base(ap->host);\n\n\twriteb(0, mmio_base + QS_HCT_CTRL);  \n\tqs_enter_reg_mode(ap);\n}\n\nstatic void qs_thaw(struct ata_port *ap)\n{\n\tu8 __iomem *mmio_base = qs_mmio_base(ap->host);\n\n\tqs_enter_reg_mode(ap);\n\twriteb(1, mmio_base + QS_HCT_CTRL);  \n}\n\nstatic int qs_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\n\tqs_reset_channel_logic(ap);\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic int qs_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\t*val = readl(link->ap->ioaddr.scr_addr + (sc_reg * 8));\n\treturn 0;\n}\n\nstatic void qs_error_handler(struct ata_port *ap)\n{\n\tqs_enter_reg_mode(ap);\n\tata_sff_error_handler(ap);\n}\n\nstatic int qs_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\twritel(val, link->ap->ioaddr.scr_addr + (sc_reg * 8));\n\treturn 0;\n}\n\nstatic unsigned int qs_fill_sg(struct ata_queued_cmd *qc)\n{\n\tstruct scatterlist *sg;\n\tstruct ata_port *ap = qc->ap;\n\tstruct qs_port_priv *pp = ap->private_data;\n\tu8 *prd = pp->pkt + QS_CPB_BYTES;\n\tunsigned int si;\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tu64 addr;\n\t\tu32 len;\n\n\t\taddr = sg_dma_address(sg);\n\t\t*(__le64 *)prd = cpu_to_le64(addr);\n\t\tprd += sizeof(u64);\n\n\t\tlen = sg_dma_len(sg);\n\t\t*(__le32 *)prd = cpu_to_le32(len);\n\t\tprd += sizeof(u64);\n\t}\n\n\treturn si;\n}\n\nstatic enum ata_completion_errors qs_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct qs_port_priv *pp = qc->ap->private_data;\n\tu8 dflags = QS_DF_PORD, *buf = pp->pkt;\n\tu8 hflags = QS_HF_DAT | QS_HF_IEN | QS_HF_VLD;\n\tu64 addr;\n\tunsigned int nelem;\n\n\tqs_enter_reg_mode(qc->ap);\n\tif (qc->tf.protocol != ATA_PROT_DMA)\n\t\treturn AC_ERR_OK;\n\n\tnelem = qs_fill_sg(qc);\n\n\tif ((qc->tf.flags & ATA_TFLAG_WRITE))\n\t\thflags |= QS_HF_DIRO;\n\tif ((qc->tf.flags & ATA_TFLAG_LBA48))\n\t\tdflags |= QS_DF_ELBA;\n\n\t \n\tbuf[ 0] = QS_HCB_HDR;\n\tbuf[ 1] = hflags;\n\t*(__le32 *)(&buf[ 4]) = cpu_to_le32(qc->nbytes);\n\t*(__le32 *)(&buf[ 8]) = cpu_to_le32(nelem);\n\taddr = ((u64)pp->pkt_dma) + QS_CPB_BYTES;\n\t*(__le64 *)(&buf[16]) = cpu_to_le64(addr);\n\n\t \n\tbuf[24] = QS_DCB_HDR;\n\tbuf[28] = dflags;\n\n\t \n\tata_tf_to_fis(&qc->tf, 0, 1, &buf[32]);\n\n\treturn AC_ERR_OK;\n}\n\nstatic inline void qs_packet_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tu8 __iomem *chan = qs_mmio_base(ap->host) + (ap->port_no * 0x4000);\n\n\twriteb(QS_CTR0_CLER, chan + QS_CCT_CTR0);\n\twmb();                              \n\twritel(QS_CCF_RUN_PKT, chan + QS_CCT_CFF);\n\treadl(chan + QS_CCT_CFF);           \n}\n\nstatic unsigned int qs_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct qs_port_priv *pp = qc->ap->private_data;\n\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\t\tpp->state = qs_state_pkt;\n\t\tqs_packet_start(qc);\n\t\treturn 0;\n\n\tcase ATAPI_PROT_DMA:\n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpp->state = qs_state_mmio;\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic void qs_do_or_die(struct ata_queued_cmd *qc, u8 status)\n{\n\tqc->err_mask |= ac_err_mask(status);\n\n\tif (!qc->err_mask) {\n\t\tata_qc_complete(qc);\n\t} else {\n\t\tstruct ata_port    *ap  = qc->ap;\n\t\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\n\t\tata_ehi_clear_desc(ehi);\n\t\tata_ehi_push_desc(ehi, \"status 0x%02X\", status);\n\n\t\tif (qc->err_mask == AC_ERR_DEV)\n\t\t\tata_port_abort(ap);\n\t\telse\n\t\t\tata_port_freeze(ap);\n\t}\n}\n\nstatic inline unsigned int qs_intr_pkt(struct ata_host *host)\n{\n\tunsigned int handled = 0;\n\tu8 sFFE;\n\tu8 __iomem *mmio_base = qs_mmio_base(host);\n\n\tdo {\n\t\tu32 sff0 = readl(mmio_base + QS_HST_SFF);\n\t\tu32 sff1 = readl(mmio_base + QS_HST_SFF + 4);\n\t\tu8 sEVLD = (sff1 >> 30) & 0x01;\t \n\t\tsFFE  = sff1 >> 31;\t\t \n\n\t\tif (sEVLD) {\n\t\t\tu8 sDST = sff0 >> 16;\t \n\t\t\tu8 sHST = sff1 & 0x3f;\t \n\t\t\tunsigned int port_no = (sff1 >> 8) & 0x03;\n\t\t\tstruct ata_port *ap = host->ports[port_no];\n\t\t\tstruct qs_port_priv *pp = ap->private_data;\n\t\t\tstruct ata_queued_cmd *qc;\n\n\t\t\tdev_dbg(host->dev, \"SFF=%08x%08x: sHST=%d sDST=%02x\\n\",\n\t\t\t\tsff1, sff0, sHST, sDST);\n\t\t\thandled = 1;\n\t\t\tif (!pp || pp->state != qs_state_pkt)\n\t\t\t\tcontinue;\n\t\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\t\t\tif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING))) {\n\t\t\t\tswitch (sHST) {\n\t\t\t\tcase 0:  \n\t\t\t\tcase 3:  \n\t\t\t\t\tqs_enter_reg_mode(qc->ap);\n\t\t\t\t\tqs_do_or_die(qc, sDST);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (!sFFE);\n\treturn handled;\n}\n\nstatic inline unsigned int qs_intr_mmio(struct ata_host *host)\n{\n\tunsigned int handled = 0, port_no;\n\n\tfor (port_no = 0; port_no < host->n_ports; ++port_no) {\n\t\tstruct ata_port *ap = host->ports[port_no];\n\t\tstruct qs_port_priv *pp = ap->private_data;\n\t\tstruct ata_queued_cmd *qc;\n\n\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\t\tif (!qc) {\n\t\t\t \n\t\t\tata_sff_check_status(ap);\n\t\t\thandled = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pp || pp->state != qs_state_mmio)\n\t\t\tcontinue;\n\t\tif (!(qc->tf.flags & ATA_TFLAG_POLLING))\n\t\t\thandled |= ata_sff_port_intr(ap, qc);\n\t}\n\treturn handled;\n}\n\nstatic irqreturn_t qs_intr(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tunsigned int handled = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\thandled  = qs_intr_pkt(host) | qs_intr_mmio(host);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void qs_ata_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t=\n\tport->data_addr\t\t= base + 0x400;\n\tport->error_addr\t=\n\tport->feature_addr\t= base + 0x408;  \n\tport->nsect_addr\t= base + 0x410;  \n\tport->lbal_addr\t\t= base + 0x418;  \n\tport->lbam_addr\t\t= base + 0x420;  \n\tport->lbah_addr\t\t= base + 0x428;  \n\tport->device_addr\t= base + 0x430;\n\tport->status_addr\t=\n\tport->command_addr\t= base + 0x438;\n\tport->altstatus_addr\t=\n\tport->ctl_addr\t\t= base + 0x440;\n\tport->scr_addr\t\t= base + 0xc00;\n}\n\nstatic int qs_port_start(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct qs_port_priv *pp;\n\tvoid __iomem *mmio_base = qs_mmio_base(ap->host);\n\tvoid __iomem *chan = mmio_base + (ap->port_no * 0x4000);\n\tu64 addr;\n\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\tpp->pkt = dmam_alloc_coherent(dev, QS_PKT_BYTES, &pp->pkt_dma,\n\t\t\t\t      GFP_KERNEL);\n\tif (!pp->pkt)\n\t\treturn -ENOMEM;\n\tap->private_data = pp;\n\n\tqs_enter_reg_mode(ap);\n\taddr = (u64)pp->pkt_dma;\n\twritel((u32) addr,        chan + QS_CCF_CPBA);\n\twritel((u32)(addr >> 32), chan + QS_CCF_CPBA + 4);\n\treturn 0;\n}\n\nstatic void qs_host_stop(struct ata_host *host)\n{\n\tvoid __iomem *mmio_base = qs_mmio_base(host);\n\n\twriteb(0, mmio_base + QS_HCT_CTRL);  \n\twriteb(QS_CNFG3_GSRST, mmio_base + QS_HCF_CNFG3);  \n}\n\nstatic void qs_host_init(struct ata_host *host, unsigned int chip_id)\n{\n\tvoid __iomem *mmio_base = host->iomap[QS_MMIO_BAR];\n\tunsigned int port_no;\n\n\twriteb(0, mmio_base + QS_HCT_CTRL);  \n\twriteb(QS_CNFG3_GSRST, mmio_base + QS_HCF_CNFG3);  \n\n\t \n\tfor (port_no = 0; port_no < host->n_ports; ++port_no) {\n\t\tu8 __iomem *chan = mmio_base + (port_no * 0x4000);\n\t\twriteb(QS_CTR1_RDEV|QS_CTR1_RCHN, chan + QS_CCT_CTR1);\n\t\twriteb(QS_CTR0_REG, chan + QS_CCT_CTR0);\n\t\treadb(chan + QS_CCT_CTR0);         \n\t}\n\twriteb(QS_SERD3_PHY_ENA, mmio_base + QS_HVS_SERD3);  \n\n\tfor (port_no = 0; port_no < host->n_ports; ++port_no) {\n\t\tu8 __iomem *chan = mmio_base + (port_no * 0x4000);\n\t\t \n\t\twritew(32, chan + QS_CFC_HUFT);\n\t\twritew(32, chan + QS_CFC_HDFT);\n\t\twritew(10, chan + QS_CFC_DUFT);\n\t\twritew( 8, chan + QS_CFC_DDFT);\n\t\t \n\t\twriteb(QS_CPB_ORDER,    chan + QS_CCF_CSEP);\n\t}\n\twriteb(1, mmio_base + QS_HCT_CTRL);  \n}\n\n \nstatic int qs_set_dma_masks(struct pci_dev *pdev, void __iomem *mmio_base)\n{\n\tu32 bus_info = readl(mmio_base + QS_HID_HPHY);\n\tint dma_bits = (bus_info & QS_HPHY_64BIT) ? 64 : 32;\n\tint rc;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(dma_bits));\n\tif (rc)\n\t\tdev_err(&pdev->dev, \"%d-bit DMA enable failed\\n\", dma_bits);\n\treturn rc;\n}\n\nstatic int qs_ata_init_one(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tunsigned int board_idx = (unsigned int) ent->driver_data;\n\tconst struct ata_port_info *ppi[] = { &qs_port_info[board_idx], NULL };\n\tstruct ata_host *host;\n\tint rc, port_no;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, QS_PORTS);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((pci_resource_flags(pdev, QS_MMIO_BAR) & IORESOURCE_MEM) == 0)\n\t\treturn -ENODEV;\n\n\trc = pcim_iomap_regions(pdev, 1 << QS_MMIO_BAR, DRV_NAME);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\trc = qs_set_dma_masks(pdev, host->iomap[QS_MMIO_BAR]);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (port_no = 0; port_no < host->n_ports; ++port_no) {\n\t\tstruct ata_port *ap = host->ports[port_no];\n\t\tunsigned int offset = port_no * 0x4000;\n\t\tvoid __iomem *chan = host->iomap[QS_MMIO_BAR] + offset;\n\n\t\tqs_ata_setup_port(&ap->ioaddr, chan);\n\n\t\tata_port_pbar_desc(ap, QS_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, QS_MMIO_BAR, offset, \"port\");\n\t}\n\n\t \n\tqs_host_init(host, board_idx);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, qs_intr, IRQF_SHARED,\n\t\t\t\t &qs_ata_sht);\n}\n\nmodule_pci_driver(qs_ata_pci_driver);\n\nMODULE_AUTHOR(\"Mark Lord\");\nMODULE_DESCRIPTION(\"Pacific Digital Corporation QStor SATA low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, qs_ata_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}