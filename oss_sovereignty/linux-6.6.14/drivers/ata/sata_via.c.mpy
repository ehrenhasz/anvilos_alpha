{
  "module_name": "sata_via.c",
  "hash_id": "c9b3474e17fffc52d85a20d91f06e3cb710a95a6cd312777d47be79398b1215e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_via.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"sata_via\"\n#define DRV_VERSION\t\"2.6\"\n\n \nenum board_ids_enum {\n\tvt6420,\n\tvt6421,\n\tvt8251,\n};\n\nenum {\n\tSATA_CHAN_ENAB\t\t= 0x40,  \n\tSATA_INT_GATE\t\t= 0x41,  \n\tSATA_NATIVE_MODE\t= 0x42,  \n\tSVIA_MISC_3\t\t= 0x46,\t \n\tPATA_UDMA_TIMING\t= 0xB3,  \n\tPATA_PIO_TIMING\t\t= 0xAB,  \n\n\tPORT0\t\t\t= (1 << 1),\n\tPORT1\t\t\t= (1 << 0),\n\tALL_PORTS\t\t= PORT0 | PORT1,\n\n\tNATIVE_MODE_ALL\t\t= (1 << 7) | (1 << 6) | (1 << 5) | (1 << 4),\n\n\tSATA_EXT_PHY\t\t= (1 << 6),  \n\n\tSATA_HOTPLUG\t\t= (1 << 5),  \n};\n\nstruct svia_priv {\n\tbool\t\t\twd_workaround;\n};\n\nstatic int vt6420_hotplug;\nmodule_param_named(vt6420_hotplug, vt6420_hotplug, int, 0644);\nMODULE_PARM_DESC(vt6420_hotplug, \"Enable hot-plug support for VT6420 (0=Don't support, 1=support)\");\n\nstatic int svia_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\n#ifdef CONFIG_PM_SLEEP\nstatic int svia_pci_device_resume(struct pci_dev *pdev);\n#endif\nstatic int svia_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);\nstatic int svia_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);\nstatic int vt8251_scr_read(struct ata_link *link, unsigned int scr, u32 *val);\nstatic int vt8251_scr_write(struct ata_link *link, unsigned int scr, u32 val);\nstatic void svia_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);\nstatic void svia_noop_freeze(struct ata_port *ap);\nstatic int vt6420_prereset(struct ata_link *link, unsigned long deadline);\nstatic void vt6420_bmdma_start(struct ata_queued_cmd *qc);\nstatic int vt6421_pata_cable_detect(struct ata_port *ap);\nstatic void vt6421_set_pio_mode(struct ata_port *ap, struct ata_device *adev);\nstatic void vt6421_set_dma_mode(struct ata_port *ap, struct ata_device *adev);\nstatic void vt6421_error_handler(struct ata_port *ap);\n\nstatic const struct pci_device_id svia_pci_tbl[] = {\n\t{ PCI_VDEVICE(VIA, 0x5337), vt6420 },\n\t{ PCI_VDEVICE(VIA, 0x0591), vt6420 },  \n\t{ PCI_VDEVICE(VIA, 0x3149), vt6420 },  \n\t{ PCI_VDEVICE(VIA, 0x3249), vt6421 },  \n\t{ PCI_VDEVICE(VIA, 0x5372), vt6420 },\n\t{ PCI_VDEVICE(VIA, 0x7372), vt6420 },\n\t{ PCI_VDEVICE(VIA, 0x5287), vt8251 },  \n\t{ PCI_VDEVICE(VIA, 0x9000), vt8251 },\n\n\t{ }\t \n};\n\nstatic struct pci_driver svia_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= svia_pci_tbl,\n\t.probe\t\t\t= svia_init_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= svia_pci_device_resume,\n#endif\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\nstatic const struct scsi_host_template svia_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations svia_base_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.sff_tf_load\t\t= svia_tf_load,\n};\n\nstatic struct ata_port_operations vt6420_sata_ops = {\n\t.inherits\t\t= &svia_base_ops,\n\t.freeze\t\t\t= svia_noop_freeze,\n\t.prereset\t\t= vt6420_prereset,\n\t.bmdma_start\t\t= vt6420_bmdma_start,\n};\n\nstatic struct ata_port_operations vt6421_pata_ops = {\n\t.inherits\t\t= &svia_base_ops,\n\t.cable_detect\t\t= vt6421_pata_cable_detect,\n\t.set_piomode\t\t= vt6421_set_pio_mode,\n\t.set_dmamode\t\t= vt6421_set_dma_mode,\n};\n\nstatic struct ata_port_operations vt6421_sata_ops = {\n\t.inherits\t\t= &svia_base_ops,\n\t.scr_read\t\t= svia_scr_read,\n\t.scr_write\t\t= svia_scr_write,\n\t.error_handler\t\t= vt6421_error_handler,\n};\n\nstatic struct ata_port_operations vt8251_ops = {\n\t.inherits\t\t= &svia_base_ops,\n\t.hardreset\t\t= sata_std_hardreset,\n\t.scr_read\t\t= vt8251_scr_read,\n\t.scr_write\t\t= vt8251_scr_write,\n};\n\nstatic const struct ata_port_info vt6420_port_info = {\n\t.flags\t\t= ATA_FLAG_SATA,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &vt6420_sata_ops,\n};\n\nstatic const struct ata_port_info vt6421_sport_info = {\n\t.flags\t\t= ATA_FLAG_SATA,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &vt6421_sata_ops,\n};\n\nstatic const struct ata_port_info vt6421_pport_info = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t \n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &vt6421_pata_ops,\n};\n\nstatic const struct ata_port_info vt8251_port_info = {\n\t.flags\t\t= ATA_FLAG_SATA | ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &vt8251_ops,\n};\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for VIA SATA controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, svia_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n\nstatic int svia_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\t*val = ioread32(link->ap->ioaddr.scr_addr + (4 * sc_reg));\n\treturn 0;\n}\n\nstatic int svia_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\tiowrite32(val, link->ap->ioaddr.scr_addr + (4 * sc_reg));\n\treturn 0;\n}\n\nstatic int vt8251_scr_read(struct ata_link *link, unsigned int scr, u32 *val)\n{\n\tstatic const u8 ipm_tbl[] = { 1, 2, 6, 0 };\n\tstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\n\tint slot = 2 * link->ap->port_no + link->pmp;\n\tu32 v = 0;\n\tu8 raw;\n\n\tswitch (scr) {\n\tcase SCR_STATUS:\n\t\tpci_read_config_byte(pdev, 0xA0 + slot, &raw);\n\n\t\t \n\t\tv |= raw & 0x03;\n\n\t\t \n\t\tif (raw & (1 << 4))\n\t\t\tv |= 0x02 << 4;\n\t\telse\n\t\t\tv |= 0x01 << 4;\n\n\t\t \n\t\tv |= ipm_tbl[(raw >> 2) & 0x3];\n\t\tbreak;\n\n\tcase SCR_ERROR:\n\t\t \n\t\tWARN_ON(pdev->device != 0x5287);\n\t\tpci_read_config_dword(pdev, 0xB0 + slot * 4, &v);\n\t\tbreak;\n\n\tcase SCR_CONTROL:\n\t\tpci_read_config_byte(pdev, 0xA4 + slot, &raw);\n\n\t\t \n\t\tv |= ((raw & 0x02) << 1) | (raw & 0x01);\n\n\t\t \n\t\tv |= ((raw >> 2) & 0x03) << 8;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*val = v;\n\treturn 0;\n}\n\nstatic int vt8251_scr_write(struct ata_link *link, unsigned int scr, u32 val)\n{\n\tstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\n\tint slot = 2 * link->ap->port_no + link->pmp;\n\tu32 v = 0;\n\n\tswitch (scr) {\n\tcase SCR_ERROR:\n\t\t \n\t\tWARN_ON(pdev->device != 0x5287);\n\t\tpci_write_config_dword(pdev, 0xB0 + slot * 4, val);\n\t\treturn 0;\n\n\tcase SCR_CONTROL:\n\t\t \n\t\tv |= ((val & 0x4) >> 1) | (val & 0x1);\n\n\t\t \n\t\tv |= ((val >> 8) & 0x3) << 2;\n\n\t\tpci_write_config_byte(pdev, 0xA4 + slot, v);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic void svia_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tstruct ata_taskfile ttf;\n\n\tif (tf->ctl != ap->last_ctl)  {\n\t\tttf = *tf;\n\t\tttf.flags |= ATA_TFLAG_DEVICE;\n\t\ttf = &ttf;\n\t}\n\tata_sff_tf_load(ap, tf);\n}\n\nstatic void svia_noop_freeze(struct ata_port *ap)\n{\n\t \n\tap->ops->sff_check_status(ap);\n\tata_bmdma_irq_clear(ap);\n}\n\n \nstatic int vt6420_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &ap->link.eh_context;\n\tunsigned long timeout = jiffies + (HZ * 5);\n\tu32 sstatus, scontrol;\n\tint online;\n\n\t \n\tif (!(ap->pflags & ATA_PFLAG_LOADING))\n\t\tgoto skip_scr;\n\n\t \n\tsvia_scr_write(link, SCR_CONTROL, 0x300);\n\tsvia_scr_read(link, SCR_CONTROL, &scontrol);  \n\n\t \n\tdo {\n\t\tata_msleep(link->ap, 200);\n\t\tsvia_scr_read(link, SCR_STATUS, &sstatus);\n\t\tif ((sstatus & 0xf) != 1)\n\t\t\tbreak;\n\t} while (time_before(jiffies, timeout));\n\n\t \n\tsvia_scr_read(link, SCR_STATUS, &sstatus);\n\tsvia_scr_read(link, SCR_CONTROL, &scontrol);\n\n\tonline = (sstatus & 0xf) == 0x3;\n\n\tata_port_info(ap,\n\t\t      \"SATA link %s 1.5 Gbps (SStatus %X SControl %X)\\n\",\n\t\t      online ? \"up\" : \"down\", sstatus, scontrol);\n\n\t \n\tsvia_scr_read(link, SCR_STATUS, &sstatus);\n\n\tif (!online) {\n\t\t \n\t\tehc->i.action &= ~ATA_EH_RESET;\n\t\treturn 0;\n\t}\n\n skip_scr:\n\t \n\tata_sff_wait_ready(link, deadline);\n\n\treturn 0;\n}\n\nstatic void vt6420_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tif ((qc->tf.command == ATA_CMD_PACKET) &&\n\t    (qc->scsicmd->sc_data_direction == DMA_TO_DEVICE)) {\n\t\t \n\t\tata_sff_pause(ap);\n\t}\n\tata_bmdma_start(qc);\n}\n\nstatic int vt6421_pata_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 tmp;\n\n\tpci_read_config_byte(pdev, PATA_UDMA_TIMING, &tmp);\n\tif (tmp & 0x10)\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\nstatic void vt6421_set_pio_mode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic const u8 pio_bits[] = { 0xA8, 0x65, 0x65, 0x31, 0x20 };\n\tpci_write_config_byte(pdev, PATA_PIO_TIMING - adev->devno,\n\t\t\t      pio_bits[adev->pio_mode - XFER_PIO_0]);\n}\n\nstatic void vt6421_set_dma_mode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic const u8 udma_bits[] = { 0xEE, 0xE8, 0xE6, 0xE4, 0xE2, 0xE1, 0xE0, 0xE0 };\n\tpci_write_config_byte(pdev, PATA_UDMA_TIMING - adev->devno,\n\t\t\t      udma_bits[adev->dma_mode - XFER_UDMA_0]);\n}\n\nstatic const unsigned int svia_bar_sizes[] = {\n\t8, 4, 8, 4, 16, 256\n};\n\nstatic const unsigned int vt6421_bar_sizes[] = {\n\t16, 16, 16, 16, 32, 128\n};\n\nstatic void __iomem *svia_scr_addr(void __iomem *addr, unsigned int port)\n{\n\treturn addr + (port * 128);\n}\n\nstatic void __iomem *vt6421_scr_addr(void __iomem *addr, unsigned int port)\n{\n\treturn addr + (port * 64);\n}\n\nstatic void vt6421_init_addrs(struct ata_port *ap)\n{\n\tvoid __iomem * const * iomap = ap->host->iomap;\n\tvoid __iomem *reg_addr = iomap[ap->port_no];\n\tvoid __iomem *bmdma_addr = iomap[4] + (ap->port_no * 8);\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\tioaddr->cmd_addr = reg_addr;\n\tioaddr->altstatus_addr =\n\tioaddr->ctl_addr = (void __iomem *)\n\t\t((unsigned long)(reg_addr + 8) | ATA_PCI_CTL_OFS);\n\tioaddr->bmdma_addr = bmdma_addr;\n\tioaddr->scr_addr = vt6421_scr_addr(iomap[5], ap->port_no);\n\n\tata_sff_std_ports(ioaddr);\n\n\tata_port_pbar_desc(ap, ap->port_no, -1, \"port\");\n\tata_port_pbar_desc(ap, 4, ap->port_no * 8, \"bmdma\");\n}\n\nstatic int vt6420_prepare_host(struct pci_dev *pdev, struct ata_host **r_host)\n{\n\tconst struct ata_port_info *ppi[] = { &vt6420_port_info, NULL };\n\tstruct ata_host *host;\n\tint rc;\n\n\tif (vt6420_hotplug) {\n\t\tppi[0]->port_ops->scr_read = svia_scr_read;\n\t\tppi[0]->port_ops->scr_write = svia_scr_write;\n\t}\n\n\trc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\n\tif (rc)\n\t\treturn rc;\n\t*r_host = host;\n\n\trc = pcim_iomap_regions(pdev, 1 << 5, DRV_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to iomap PCI BAR 5\\n\");\n\t\treturn rc;\n\t}\n\n\thost->ports[0]->ioaddr.scr_addr = svia_scr_addr(host->iomap[5], 0);\n\thost->ports[1]->ioaddr.scr_addr = svia_scr_addr(host->iomap[5], 1);\n\n\treturn 0;\n}\n\nstatic int vt6421_prepare_host(struct pci_dev *pdev, struct ata_host **r_host)\n{\n\tconst struct ata_port_info *ppi[] =\n\t\t{ &vt6421_sport_info, &vt6421_sport_info, &vt6421_pport_info };\n\tstruct ata_host *host;\n\tint i, rc;\n\n\t*r_host = host = ata_host_alloc_pinfo(&pdev->dev, ppi, ARRAY_SIZE(ppi));\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"failed to allocate host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = pcim_iomap_regions(pdev, 0x3f, DRV_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to request/iomap PCI BARs (errno=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\thost->iomap = pcim_iomap_table(pdev);\n\n\tfor (i = 0; i < host->n_ports; i++)\n\t\tvt6421_init_addrs(host->ports[i]);\n\n\treturn dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n}\n\nstatic int vt8251_prepare_host(struct pci_dev *pdev, struct ata_host **r_host)\n{\n\tconst struct ata_port_info *ppi[] = { &vt8251_port_info, NULL };\n\tstruct ata_host *host;\n\tint i, rc;\n\n\trc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\n\tif (rc)\n\t\treturn rc;\n\t*r_host = host;\n\n\trc = pcim_iomap_regions(pdev, 1 << 5, DRV_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to iomap PCI BAR 5\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tfor (i = 0; i < host->n_ports; i++)\n\t\tata_slave_link_init(host->ports[i]);\n\n\treturn 0;\n}\n\nstatic void svia_wd_fix(struct pci_dev *pdev)\n{\n\tu8 tmp8;\n\n\tpci_read_config_byte(pdev, 0x52, &tmp8);\n\tpci_write_config_byte(pdev, 0x52, tmp8 | BIT(2));\n}\n\nstatic irqreturn_t vt642x_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tirqreturn_t rc = ata_bmdma_interrupt(irq, dev_instance);\n\n\t \n\tif (rc != IRQ_HANDLED) {\n\t\tu32 serror;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t\t \n\t\tsvia_scr_read(&host->ports[0]->link, SCR_ERROR, &serror);\n\t\tif (serror & SERR_PHYRDY_CHG) {\n\t\t\tata_ehi_hotplugged(&host->ports[0]->link.eh_info);\n\t\t\tata_port_freeze(host->ports[0]);\n\t\t\trc = IRQ_HANDLED;\n\t\t}\n\t\t \n\t\tsvia_scr_read(&host->ports[1]->link, SCR_ERROR, &serror);\n\t\tif (serror & SERR_PHYRDY_CHG) {\n\t\t\tata_ehi_hotplugged(&host->ports[1]->link.eh_info);\n\t\t\tata_port_freeze(host->ports[1]);\n\t\t\trc = IRQ_HANDLED;\n\t\t}\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t}\n\n\treturn rc;\n}\n\nstatic void vt6421_error_handler(struct ata_port *ap)\n{\n\tstruct svia_priv *hpriv = ap->host->private_data;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 serror;\n\n\t \n\tif (!hpriv->wd_workaround) {\n\t\tsvia_scr_read(&ap->link, SCR_ERROR, &serror);\n\t\tif (serror == 0x1000500) {\n\t\t\tata_port_warn(ap, \"Incompatible drive: enabling workaround. This slows down transfer rate to ~60 MB/s\");\n\t\t\tsvia_wd_fix(pdev);\n\t\t\thpriv->wd_workaround = true;\n\t\t\tap->link.eh_context.i.flags |= ATA_EHI_QUIET;\n\t\t}\n\t}\n\n\tata_sff_error_handler(ap);\n}\n\nstatic void svia_configure(struct pci_dev *pdev, int board_id,\n\t\t\t   struct svia_priv *hpriv)\n{\n\tu8 tmp8;\n\n\tpci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &tmp8);\n\tdev_info(&pdev->dev, \"routed to hard irq line %d\\n\",\n\t\t (int) (tmp8 & 0xf0) == 0xf0 ? 0 : tmp8 & 0x0f);\n\n\t \n\tpci_read_config_byte(pdev, SATA_CHAN_ENAB, &tmp8);\n\tif ((tmp8 & ALL_PORTS) != ALL_PORTS) {\n\t\tdev_dbg(&pdev->dev, \"enabling SATA channels (0x%x)\\n\",\n\t\t\t(int)tmp8);\n\t\ttmp8 |= ALL_PORTS;\n\t\tpci_write_config_byte(pdev, SATA_CHAN_ENAB, tmp8);\n\t}\n\n\t \n\tpci_read_config_byte(pdev, SATA_INT_GATE, &tmp8);\n\tif ((tmp8 & ALL_PORTS) != ALL_PORTS) {\n\t\tdev_dbg(&pdev->dev, \"enabling SATA channel interrupts (0x%x)\\n\",\n\t\t\t(int) tmp8);\n\t\ttmp8 |= ALL_PORTS;\n\t\tpci_write_config_byte(pdev, SATA_INT_GATE, tmp8);\n\t}\n\n\t \n\tpci_read_config_byte(pdev, SATA_NATIVE_MODE, &tmp8);\n\tif ((tmp8 & NATIVE_MODE_ALL) != NATIVE_MODE_ALL) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"enabling SATA channel native mode (0x%x)\\n\",\n\t\t\t(int) tmp8);\n\t\ttmp8 |= NATIVE_MODE_ALL;\n\t\tpci_write_config_byte(pdev, SATA_NATIVE_MODE, tmp8);\n\t}\n\n\tif ((board_id == vt6420 && vt6420_hotplug) || board_id == vt6421) {\n\t\t \n\t\tpci_read_config_byte(pdev, SVIA_MISC_3, &tmp8);\n\t\tif ((tmp8 & SATA_HOTPLUG) != SATA_HOTPLUG) {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"enabling SATA hotplug (0x%x)\\n\",\n\t\t\t\t(int) tmp8);\n\t\t\ttmp8 |= SATA_HOTPLUG;\n\t\t\tpci_write_config_byte(pdev, SVIA_MISC_3, tmp8);\n\t\t}\n\t}\n\n\t \n\tif (board_id == vt6420) {\n\t\tsvia_wd_fix(pdev);\n\t\thpriv->wd_workaround = true;\n\t}\n}\n\nstatic int svia_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned int i;\n\tint rc;\n\tstruct ata_host *host = NULL;\n\tint board_id = (int) ent->driver_data;\n\tconst unsigned *bar_sizes;\n\tstruct svia_priv *hpriv;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (board_id == vt6421)\n\t\tbar_sizes = &vt6421_bar_sizes[0];\n\telse\n\t\tbar_sizes = &svia_bar_sizes[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(svia_bar_sizes); i++)\n\t\tif ((pci_resource_start(pdev, i) == 0) ||\n\t\t    (pci_resource_len(pdev, i) < bar_sizes[i])) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"invalid PCI BAR %u (sz 0x%llx, val 0x%llx)\\n\",\n\t\t\t\ti,\n\t\t\t\t(unsigned long long)pci_resource_start(pdev, i),\n\t\t\t\t(unsigned long long)pci_resource_len(pdev, i));\n\t\t\treturn -ENODEV;\n\t\t}\n\n\tswitch (board_id) {\n\tcase vt6420:\n\t\trc = vt6420_prepare_host(pdev, &host);\n\t\tbreak;\n\tcase vt6421:\n\t\trc = vt6421_prepare_host(pdev, &host);\n\t\tbreak;\n\tcase vt8251:\n\t\trc = vt8251_prepare_host(pdev, &host);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\thpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\thost->private_data = hpriv;\n\n\tsvia_configure(pdev, board_id, hpriv);\n\n\tpci_set_master(pdev);\n\tif ((board_id == vt6420 && vt6420_hotplug) || board_id == vt6421)\n\t\treturn ata_host_activate(host, pdev->irq, vt642x_interrupt,\n\t\t\t\t\t IRQF_SHARED, &svia_sht);\n\telse\n\t\treturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\t\t IRQF_SHARED, &svia_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int svia_pci_device_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tstruct svia_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (hpriv->wd_workaround)\n\t\tsvia_wd_fix(pdev);\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nmodule_pci_driver(svia_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}