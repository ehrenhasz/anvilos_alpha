{
  "module_name": "pata_pdc202xx_old.c",
  "hash_id": "cba3aebae34756ac2cf53bb9dd1c8faf0a4ae5b28d27180e8e582fc5e57c6b47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_pdc202xx_old.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_pdc202xx_old\"\n#define DRV_VERSION \"0.4.3\"\n\nstatic int pdc2026x_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu16 cis;\n\n\tpci_read_config_word(pdev, 0x50, &cis);\n\tif (cis & (1 << (10 + ap->port_no)))\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\nstatic void pdc202xx_exec_command(struct ata_port *ap,\n\t\t\t\t  const struct ata_taskfile *tf)\n{\n\tiowrite8(tf->command, ap->ioaddr.command_addr);\n\tndelay(400);\n}\n\nstatic bool pdc202xx_irq_check(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tunsigned long master\t= pci_resource_start(pdev, 4);\n\tu8 sc1d\t\t\t= inb(master + 0x1d);\n\n\tif (ap->port_no) {\n\t\t \n\t\treturn sc1d & 0x40;\n\t} else\t{\n\t\t \n\t\treturn sc1d & 0x04;\n\t}\n}\n\n \n\nstatic void pdc202xx_configure_piomode(struct ata_port *ap, struct ata_device *adev, int pio)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port = 0x60 + 8 * ap->port_no + 4 * adev->devno;\n\tstatic const u16 pio_timing[5] = {\n\t\t0x0913, 0x050C , 0x0308, 0x0206, 0x0104\n\t};\n\tu8 r_ap, r_bp;\n\n\tpci_read_config_byte(pdev, port, &r_ap);\n\tpci_read_config_byte(pdev, port + 1, &r_bp);\n\tr_ap &= ~0x3F;\t \n\tr_bp &= ~0x1F;\n\tr_ap |= (pio_timing[pio] >> 8);\n\tr_bp |= (pio_timing[pio] & 0xFF);\n\n\tif (ata_pio_need_iordy(adev))\n\t\tr_ap |= 0x20;\t \n\tif (adev->class == ATA_DEV_ATA)\n\t\tr_ap |= 0x10;\t \n\tpci_write_config_byte(pdev, port, r_ap);\n\tpci_write_config_byte(pdev, port + 1, r_bp);\n}\n\n \n\nstatic void pdc202xx_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tpdc202xx_configure_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);\n}\n\n \n\nstatic void pdc202xx_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port = 0x60 + 8 * ap->port_no + 4 * adev->devno;\n\tstatic u8 udma_timing[6][2] = {\n\t\t{ 0x60, 0x03 },\t \n\t\t{ 0x40, 0x02 },\n\t\t{ 0x20, 0x01 },\n\t\t{ 0x40, 0x02 },\t \n\t\t{ 0x20, 0x01 },\n\t\t{ 0x20, 0x01 }\n\t};\n\tstatic u8 mdma_timing[3][2] = {\n\t\t{ 0xe0, 0x0f },\n\t\t{ 0x60, 0x04 },\n\t\t{ 0x60, 0x03 },\n\t};\n\tu8 r_bp, r_cp;\n\n\tpci_read_config_byte(pdev, port + 1, &r_bp);\n\tpci_read_config_byte(pdev, port + 2, &r_cp);\n\n\tr_bp &= ~0xE0;\n\tr_cp &= ~0x0F;\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tint speed = adev->dma_mode - XFER_UDMA_0;\n\t\tr_bp |= udma_timing[speed][0];\n\t\tr_cp |= udma_timing[speed][1];\n\n\t} else {\n\t\tint speed = adev->dma_mode - XFER_MW_DMA_0;\n\t\tr_bp |= mdma_timing[speed][0];\n\t\tr_cp |= mdma_timing[speed][1];\n\t}\n\tpci_write_config_byte(pdev, port + 1, r_bp);\n\tpci_write_config_byte(pdev, port + 2, r_cp);\n\n}\n\n \n\nstatic void pdc2026x_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct ata_taskfile *tf = &qc->tf;\n\tint sel66 = ap->port_no ? 0x08: 0x02;\n\n\tvoid __iomem *master = ap->host->ports[0]->ioaddr.bmdma_addr;\n\tvoid __iomem *clock = master + 0x11;\n\tvoid __iomem *atapi_reg = master + 0x20 + (4 * ap->port_no);\n\n\tu32 len;\n\n\t \n\tif (adev->dma_mode > XFER_UDMA_2)\n\t\tiowrite8(ioread8(clock) | sel66, clock);\n\telse\n\t\tiowrite8(ioread8(clock) & ~sel66, clock);\n\n\t \n\tpdc202xx_set_dmamode(ap, qc->dev);\n\n\t \n\tif ((tf->flags & ATA_TFLAG_LBA48) ||  tf->protocol == ATAPI_PROT_DMA) {\n\t\tlen = qc->nbytes / 2;\n\n\t\tif (tf->flags & ATA_TFLAG_WRITE)\n\t\t\tlen |= 0x06000000;\n\t\telse\n\t\t\tlen |= 0x05000000;\n\n\t\tiowrite32(len, atapi_reg);\n\t}\n\n\t \n\tata_bmdma_start(qc);\n}\n\n \n\nstatic void pdc2026x_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct ata_taskfile *tf = &qc->tf;\n\n\tint sel66 = ap->port_no ? 0x08: 0x02;\n\t \n\tvoid __iomem *master = ap->host->ports[0]->ioaddr.bmdma_addr;\n\tvoid __iomem *clock = master + 0x11;\n\tvoid __iomem *atapi_reg = master + 0x20 + (4 * ap->port_no);\n\n\t \n\tif (tf->protocol == ATAPI_PROT_DMA || (tf->flags & ATA_TFLAG_LBA48)) {\n\t\tiowrite32(0, atapi_reg);\n\t\tiowrite8(ioread8(clock) & ~sel66, clock);\n\t}\n\t \n\tif (adev->dma_mode > XFER_UDMA_2)\n\t\tiowrite8(ioread8(clock) & ~sel66, clock);\n\tata_bmdma_stop(qc);\n\tpdc202xx_set_piomode(ap, adev);\n}\n\n \n\nstatic void pdc2026x_dev_config(struct ata_device *adev)\n{\n\tadev->max_sectors = 256;\n}\n\nstatic int pdc2026x_port_start(struct ata_port *ap)\n{\n\tvoid __iomem *bmdma = ap->ioaddr.bmdma_addr;\n\tif (bmdma) {\n\t\t \n\t\tu8 burst = ioread8(bmdma + 0x1f);\n\t\tiowrite8(burst | 0x01, bmdma + 0x1f);\n\t}\n\treturn ata_bmdma_port_start(ap);\n}\n\n \n\nstatic int pdc2026x_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn 1;\n}\n\nstatic const struct scsi_host_template pdc202xx_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations pdc2024x_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= pdc202xx_set_piomode,\n\t.set_dmamode\t\t= pdc202xx_set_dmamode,\n\n\t.sff_exec_command\t= pdc202xx_exec_command,\n\t.sff_irq_check\t\t= pdc202xx_irq_check,\n};\n\nstatic struct ata_port_operations pdc2026x_port_ops = {\n\t.inherits\t\t= &pdc2024x_port_ops,\n\n\t.check_atapi_dma\t= pdc2026x_check_atapi_dma,\n\t.bmdma_start\t\t= pdc2026x_bmdma_start,\n\t.bmdma_stop\t\t= pdc2026x_bmdma_stop,\n\n\t.cable_detect\t\t= pdc2026x_cable_detect,\n\t.dev_config\t\t= pdc2026x_dev_config,\n\n\t.port_start\t\t= pdc2026x_port_start,\n\n\t.sff_exec_command\t= pdc202xx_exec_command,\n\t.sff_irq_check\t\t= pdc202xx_irq_check,\n};\n\nstatic int pdc202xx_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info[3] = {\n\t\t{\n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA2,\n\t\t\t.port_ops = &pdc2024x_port_ops\n\t\t},\n\t\t{\n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA4,\n\t\t\t.port_ops = &pdc2026x_port_ops\n\t\t},\n\t\t{\n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA5,\n\t\t\t.port_ops = &pdc2026x_port_ops\n\t\t}\n\n\t};\n\tconst struct ata_port_info *ppi[] = { &info[id->driver_data], NULL };\n\n\tif (dev->device == PCI_DEVICE_ID_PROMISE_20265) {\n\t\tstruct pci_dev *bridge = dev->bus->self;\n\t\t \n\t\tif (bridge && bridge->vendor == PCI_VENDOR_ID_INTEL) {\n\t\t\tif (bridge->device == PCI_DEVICE_ID_INTEL_I960)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (bridge->device == PCI_DEVICE_ID_INTEL_I960RM)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn ata_pci_bmdma_init_one(dev, ppi, &pdc202xx_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id pdc202xx[] = {\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20246), 0 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20262), 1 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20263), 1 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20265), 2 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20267), 2 },\n\n\t{ },\n};\n\nstatic struct pci_driver pdc202xx_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= pdc202xx,\n\t.probe \t\t= pdc202xx_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(pdc202xx_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Promise 2024x and 20262-20267\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pdc202xx);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}