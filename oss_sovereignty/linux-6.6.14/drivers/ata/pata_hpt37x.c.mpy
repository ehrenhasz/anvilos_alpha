{
  "module_name": "pata_hpt37x.c",
  "hash_id": "4598e4ba734ebb172da8b1a9000a4722b2ffa8437af1a52648a28be14784712d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_hpt37x.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_hpt37x\"\n#define DRV_VERSION\t\"0.6.30\"\n\nstruct hpt_clock {\n\tu8\txfer_speed;\n\tu32\ttiming;\n};\n\nstruct hpt_chip {\n\tconst char *name;\n\tunsigned int base;\n\tstruct hpt_clock const *clocks[4];\n};\n\n \n\nstatic struct hpt_clock hpt37x_timings_33[] = {\n\t{ XFER_UDMA_6,\t\t0x12446231 },\t \n\t{ XFER_UDMA_5,\t\t0x12446231 },\n\t{ XFER_UDMA_4,\t\t0x12446231 },\n\t{ XFER_UDMA_3,\t\t0x126c6231 },\n\t{ XFER_UDMA_2,\t\t0x12486231 },\n\t{ XFER_UDMA_1,\t\t0x124c6233 },\n\t{ XFER_UDMA_0,\t\t0x12506297 },\n\n\t{ XFER_MW_DMA_2,\t0x22406c31 },\n\t{ XFER_MW_DMA_1,\t0x22406c33 },\n\t{ XFER_MW_DMA_0,\t0x22406c97 },\n\n\t{ XFER_PIO_4,\t\t0x06414e31 },\n\t{ XFER_PIO_3,\t\t0x06414e42 },\n\t{ XFER_PIO_2,\t\t0x06414e53 },\n\t{ XFER_PIO_1,\t\t0x06814e93 },\n\t{ XFER_PIO_0,\t\t0x06814ea7 }\n};\n\nstatic struct hpt_clock hpt37x_timings_50[] = {\n\t{ XFER_UDMA_6,\t\t0x12848242 },\n\t{ XFER_UDMA_5,\t\t0x12848242 },\n\t{ XFER_UDMA_4,\t\t0x12ac8242 },\n\t{ XFER_UDMA_3,\t\t0x128c8242 },\n\t{ XFER_UDMA_2,\t\t0x120c8242 },\n\t{ XFER_UDMA_1,\t\t0x12148254 },\n\t{ XFER_UDMA_0,\t\t0x121882ea },\n\n\t{ XFER_MW_DMA_2,\t0x22808242 },\n\t{ XFER_MW_DMA_1,\t0x22808254 },\n\t{ XFER_MW_DMA_0,\t0x228082ea },\n\n\t{ XFER_PIO_4,\t\t0x0a81f442 },\n\t{ XFER_PIO_3,\t\t0x0a81f443 },\n\t{ XFER_PIO_2,\t\t0x0a81f454 },\n\t{ XFER_PIO_1,\t\t0x0ac1f465 },\n\t{ XFER_PIO_0,\t\t0x0ac1f48a }\n};\n\nstatic struct hpt_clock hpt37x_timings_66[] = {\n\t{ XFER_UDMA_6,\t\t0x1c869c62 },\n\t{ XFER_UDMA_5,\t\t0x1cae9c62 },\t \n\t{ XFER_UDMA_4,\t\t0x1c8a9c62 },\n\t{ XFER_UDMA_3,\t\t0x1c8e9c62 },\n\t{ XFER_UDMA_2,\t\t0x1c929c62 },\n\t{ XFER_UDMA_1,\t\t0x1c9a9c62 },\n\t{ XFER_UDMA_0,\t\t0x1c829c62 },\n\n\t{ XFER_MW_DMA_2,\t0x2c829c62 },\n\t{ XFER_MW_DMA_1,\t0x2c829c66 },\n\t{ XFER_MW_DMA_0,\t0x2c829d2e },\n\n\t{ XFER_PIO_4,\t\t0x0c829c62 },\n\t{ XFER_PIO_3,\t\t0x0c829c84 },\n\t{ XFER_PIO_2,\t\t0x0c829ca6 },\n\t{ XFER_PIO_1,\t\t0x0d029d26 },\n\t{ XFER_PIO_0,\t\t0x0d029d5e }\n};\n\n\nstatic const struct hpt_chip hpt370 = {\n\t\"HPT370\",\n\t48,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL\n\t}\n};\n\nstatic const struct hpt_chip hpt370a = {\n\t\"HPT370A\",\n\t48,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\thpt37x_timings_50,\n\t\tNULL\n\t}\n};\n\nstatic const struct hpt_chip hpt372 = {\n\t\"HPT372\",\n\t55,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\thpt37x_timings_50,\n\t\thpt37x_timings_66\n\t}\n};\n\nstatic const struct hpt_chip hpt302 = {\n\t\"HPT302\",\n\t66,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\thpt37x_timings_50,\n\t\thpt37x_timings_66\n\t}\n};\n\nstatic const struct hpt_chip hpt371 = {\n\t\"HPT371\",\n\t66,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\thpt37x_timings_50,\n\t\thpt37x_timings_66\n\t}\n};\n\nstatic const struct hpt_chip hpt372a = {\n\t\"HPT372A\",\n\t66,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\thpt37x_timings_50,\n\t\thpt37x_timings_66\n\t}\n};\n\nstatic const struct hpt_chip hpt374 = {\n\t\"HPT374\",\n\t48,\n\t{\n\t\thpt37x_timings_33,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL\n\t}\n};\n\n \n\nstatic u32 hpt37x_find_mode(struct ata_port *ap, int speed)\n{\n\tstruct hpt_clock *clocks = ap->host->private_data;\n\n\twhile (clocks->xfer_speed) {\n\t\tif (clocks->xfer_speed == speed)\n\t\t\treturn clocks->timing;\n\t\tclocks++;\n\t}\n\tBUG();\n\treturn 0xffffffffU;\t \n}\n\nstatic int hpt_dma_blacklisted(const struct ata_device *dev, char *modestr,\n\t\t\t       const char * const list[])\n{\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\tint i;\n\n\tata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\n\ti = match_string(list, -1, model_num);\n\tif (i >= 0) {\n\t\tata_dev_warn(dev, \"%s is not supported for %s\\n\",\n\t\t\t     modestr, list[i]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic const char * const bad_ata33[] = {\n\t\"Maxtor 92720U8\", \"Maxtor 92040U6\", \"Maxtor 91360U4\", \"Maxtor 91020U3\",\n\t\"Maxtor 90845U3\", \"Maxtor 90650U2\",\n\t\"Maxtor 91360D8\", \"Maxtor 91190D7\", \"Maxtor 91020D6\", \"Maxtor 90845D5\",\n\t\"Maxtor 90680D4\", \"Maxtor 90510D3\", \"Maxtor 90340D2\",\n\t\"Maxtor 91152D8\", \"Maxtor 91008D7\", \"Maxtor 90845D6\", \"Maxtor 90840D6\",\n\t\"Maxtor 90720D5\", \"Maxtor 90648D5\", \"Maxtor 90576D4\",\n\t\"Maxtor 90510D4\",\n\t\"Maxtor 90432D3\", \"Maxtor 90288D2\", \"Maxtor 90256D2\",\n\t\"Maxtor 91000D8\", \"Maxtor 90910D8\", \"Maxtor 90875D7\", \"Maxtor 90840D7\",\n\t\"Maxtor 90750D6\", \"Maxtor 90625D5\", \"Maxtor 90500D4\",\n\t\"Maxtor 91728D8\", \"Maxtor 91512D7\", \"Maxtor 91303D6\", \"Maxtor 91080D5\",\n\t\"Maxtor 90845D4\", \"Maxtor 90680D4\", \"Maxtor 90648D3\", \"Maxtor 90432D2\",\n\tNULL\n};\n\nstatic const char * const bad_ata100_5[] = {\n\t\"IBM-DTLA-307075\",\n\t\"IBM-DTLA-307060\",\n\t\"IBM-DTLA-307045\",\n\t\"IBM-DTLA-307030\",\n\t\"IBM-DTLA-307020\",\n\t\"IBM-DTLA-307015\",\n\t\"IBM-DTLA-305040\",\n\t\"IBM-DTLA-305030\",\n\t\"IBM-DTLA-305020\",\n\t\"IC35L010AVER07-0\",\n\t\"IC35L020AVER07-0\",\n\t\"IC35L030AVER07-0\",\n\t\"IC35L040AVER07-0\",\n\t\"IC35L060AVER07-0\",\n\t\"WDC AC310200R\",\n\tNULL\n};\n\n \n\nstatic unsigned int hpt370_filter(struct ata_device *adev, unsigned int mask)\n{\n\tif (adev->class == ATA_DEV_ATA) {\n\t\tif (hpt_dma_blacklisted(adev, \"UDMA\", bad_ata33))\n\t\t\tmask &= ~ATA_MASK_UDMA;\n\t\tif (hpt_dma_blacklisted(adev, \"UDMA100\", bad_ata100_5))\n\t\t\tmask &= ~(0xE0 << ATA_SHIFT_UDMA);\n\t}\n\treturn mask;\n}\n\n \n\nstatic unsigned int hpt370a_filter(struct ata_device *adev, unsigned int mask)\n{\n\tif (adev->class == ATA_DEV_ATA) {\n\t\tif (hpt_dma_blacklisted(adev, \"UDMA100\", bad_ata100_5))\n\t\t\tmask &= ~(0xE0 << ATA_SHIFT_UDMA);\n\t}\n\treturn mask;\n}\n\n \nstatic unsigned int hpt372_filter(struct ata_device *adev, unsigned int mask)\n{\n\tif (ata_id_is_sata(adev->id))\n\t\tmask &= ~((0xE << ATA_SHIFT_UDMA) | ATA_MASK_MWDMA);\n\n\treturn mask;\n}\n\n \n\nstatic int hpt37x_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 scr2, ata66;\n\n\tpci_read_config_byte(pdev, 0x5B, &scr2);\n\tpci_write_config_byte(pdev, 0x5B, scr2 & ~0x01);\n\n\tudelay(10);  \n\n\t \n\tpci_read_config_byte(pdev, 0x5A, &ata66);\n\t \n\tpci_write_config_byte(pdev, 0x5B, scr2);\n\n\tif (ata66 & (2 >> ap->port_no))\n\t\treturn ATA_CBL_PATA40;\n\telse\n\t\treturn ATA_CBL_PATA80;\n}\n\n \n\nstatic int hpt374_fn1_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tunsigned int mcrbase = 0x50 + 4 * ap->port_no;\n\tu16 mcr3;\n\tu8 ata66;\n\n\t \n\tpci_read_config_word(pdev, mcrbase + 2, &mcr3);\n\t \n\tpci_write_config_word(pdev, mcrbase + 2, mcr3 | 0x8000);\n\tpci_read_config_byte(pdev, 0x5A, &ata66);\n\t \n\tpci_write_config_word(pdev, mcrbase + 2, mcr3);\n\n\tif (ata66 & (2 >> ap->port_no))\n\t\treturn ATA_CBL_PATA40;\n\telse\n\t\treturn ATA_CBL_PATA80;\n}\n\n \n\nstatic int hpt37x_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic const struct pci_bits hpt37x_enable_bits[] = {\n\t\t{ 0x50, 1, 0x04, 0x04 },\n\t\t{ 0x54, 1, 0x04, 0x04 }\n\t};\n\tu8 mcr2;\n\n\tif (!pci_test_config_bits(pdev, &hpt37x_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\n\t \n\tpci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\n\tudelay(100);\n\n\t \n\tpci_read_config_byte(pdev, 0x51 + 4 * ap->port_no, &mcr2);\n\t \n\tif (pdev->device == PCI_DEVICE_ID_TTI_HPT366 && pdev->revision < 5) {\n\t\tmcr2 &= ~0x02;\n\t\tmcr2 |= 0x01;\n\t} else {\n\t\tmcr2 &= ~0x07;\n\t}\n\tpci_write_config_byte(pdev, 0x51 + 4 * ap->port_no, mcr2);\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic void hpt37x_set_mode(struct ata_port *ap, struct ata_device *adev,\n\t\t\t    u8 mode)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint addr = 0x40 + 4 * (adev->devno + 2 * ap->port_no);\n\tu32 reg, timing, mask;\n\n\t \n\tif (mode < XFER_MW_DMA_0)\n\t\tmask = 0xcfc3ffff;\n\telse if (mode < XFER_UDMA_0)\n\t\tmask = 0x31c001ff;\n\telse\n\t\tmask = 0x303c0000;\n\n\ttiming = hpt37x_find_mode(ap, mode);\n\n\tpci_read_config_dword(pdev, addr, &reg);\n\treg = (reg & ~mask) | (timing & mask);\n\tpci_write_config_dword(pdev, addr, reg);\n}\n \n\nstatic void hpt37x_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\thpt37x_set_mode(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void hpt37x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\thpt37x_set_mode(ap, adev, adev->dma_mode);\n}\n\n \n\nstatic void hpt370_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tvoid __iomem *bmdma = ap->ioaddr.bmdma_addr;\n\tu8 dma_stat = ioread8(bmdma + ATA_DMA_STATUS);\n\tu8 dma_cmd;\n\n\tif (dma_stat & ATA_DMA_ACTIVE) {\n\t\tudelay(20);\n\t\tdma_stat = ioread8(bmdma + ATA_DMA_STATUS);\n\t}\n\tif (dma_stat & ATA_DMA_ACTIVE) {\n\t\t \n\t\tpci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\n\t\tudelay(10);\n\t\t \n\t\tdma_cmd = ioread8(bmdma + ATA_DMA_CMD);\n\t\tiowrite8(dma_cmd & ~ATA_DMA_START, bmdma + ATA_DMA_CMD);\n\t\t \n\t\tdma_stat = ioread8(bmdma + ATA_DMA_STATUS);\n\t\tiowrite8(dma_stat | ATA_DMA_INTR | ATA_DMA_ERR,\n\t\t\t bmdma + ATA_DMA_STATUS);\n\t\t \n\t\tpci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\n\t\tudelay(10);\n\t}\n\tata_bmdma_stop(qc);\n}\n\n \n\nstatic void hpt37x_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint mscreg = 0x50 + 4 * ap->port_no;\n\tu8 bwsr_stat, msc_stat;\n\n\tpci_read_config_byte(pdev, 0x6A, &bwsr_stat);\n\tpci_read_config_byte(pdev, mscreg, &msc_stat);\n\tif (bwsr_stat & (1 << ap->port_no))\n\t\tpci_write_config_byte(pdev, mscreg, msc_stat | 0x30);\n\tata_bmdma_stop(qc);\n}\n\n\nstatic const struct scsi_host_template hpt37x_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n \n\nstatic struct ata_port_operations hpt370_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.bmdma_stop\t= hpt370_bmdma_stop,\n\n\t.mode_filter\t= hpt370_filter,\n\t.cable_detect\t= hpt37x_cable_detect,\n\t.set_piomode\t= hpt37x_set_piomode,\n\t.set_dmamode\t= hpt37x_set_dmamode,\n\t.prereset\t= hpt37x_pre_reset,\n};\n\n \n\nstatic struct ata_port_operations hpt370a_port_ops = {\n\t.inherits\t= &hpt370_port_ops,\n\t.mode_filter\t= hpt370a_filter,\n};\n\n \n\nstatic struct ata_port_operations hpt302_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.bmdma_stop\t= hpt37x_bmdma_stop,\n\n\t.cable_detect\t= hpt37x_cable_detect,\n\t.set_piomode\t= hpt37x_set_piomode,\n\t.set_dmamode\t= hpt37x_set_dmamode,\n\t.prereset\t= hpt37x_pre_reset,\n};\n\n \n\nstatic struct ata_port_operations hpt372_port_ops = {\n\t.inherits\t= &hpt302_port_ops,\n\t.mode_filter\t= hpt372_filter,\n};\n\n \n\nstatic struct ata_port_operations hpt374_fn1_port_ops = {\n\t.inherits\t= &hpt372_port_ops,\n\t.cable_detect\t= hpt374_fn1_cable_detect,\n};\n\n \n\nstatic int hpt37x_clock_slot(unsigned int freq)\n{\n\tif (freq < 40)\n\t\treturn 0;\t \n\tif (freq < 45)\n\t\treturn 1;\t \n\tif (freq < 55)\n\t\treturn 2;\t \n\treturn 3;\t\t \n}\n\n \n\nstatic int hpt37x_calibrate_dpll(struct pci_dev *dev)\n{\n\tu8 reg5b;\n\tu32 reg5c;\n\tint tries;\n\n\tfor (tries = 0; tries < 0x5000; tries++) {\n\t\tudelay(50);\n\t\tpci_read_config_byte(dev, 0x5b, &reg5b);\n\t\tif (reg5b & 0x80) {\n\t\t\t \n\t\t\tfor (tries = 0; tries < 0x1000; tries++) {\n\t\t\t\tpci_read_config_byte(dev, 0x5b, &reg5b);\n\t\t\t\t \n\t\t\t\tif ((reg5b & 0x80) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tpci_read_config_dword(dev, 0x5c, &reg5c);\n\t\t\tpci_write_config_dword(dev, 0x5c, reg5c & ~0x100);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\nstatic int hpt37x_pci_clock(struct pci_dev *pdev, unsigned int base)\n{\n\tunsigned int freq;\n\tu32 fcnt;\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_TTI_HPT374 &&\n\t    (PCI_FUNC(pdev->devfn) & 1)) {\n\t\tstruct pci_dev *pdev_fn0;\n\n\t\tpdev_fn0 = pci_get_slot(pdev->bus, pdev->devfn - 1);\n\t\t \n\t\tif (!pdev_fn0)\n\t\t\treturn 0;\n\t\tfcnt = inl(pci_resource_start(pdev_fn0, 4) + 0x90);\n\t\tpci_dev_put(pdev_fn0);\n\t} else\t{\n\t\tfcnt = inl(pci_resource_start(pdev, 4) + 0x90);\n\t}\n\n\tif ((fcnt >> 12) != 0xABCDE) {\n\t\tu32 total = 0;\n\t\tint i;\n\t\tu16 sr;\n\n\t\tdev_warn(&pdev->dev, \"BIOS clock data not set\\n\");\n\n\t\t \n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tpci_read_config_word(pdev, 0x78, &sr);\n\t\t\ttotal += sr & 0x1FF;\n\t\t\tudelay(15);\n\t\t}\n\t\tfcnt = total / 128;\n\t}\n\tfcnt &= 0x1FF;\n\n\tfreq = (fcnt * base) / 192;\t \n\n\t \n\tif (freq < 40)\n\t\treturn 33;\n\tif (freq < 45)\n\t\treturn 40;\n\tif (freq < 55)\n\t\treturn 50;\n\treturn 66;\n}\n\n \n\nstatic int hpt37x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\t \n\tstatic const struct ata_port_info info_hpt370 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &hpt370_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt370a = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &hpt370a_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt370_33 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA4,\n\t\t.port_ops = &hpt370_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt370a_33 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA4,\n\t\t.port_ops = &hpt370a_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt372 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &hpt372_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt302 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &hpt302_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt374_fn0 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &hpt372_port_ops\n\t};\n\tstatic const struct ata_port_info info_hpt374_fn1 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &hpt374_fn1_port_ops\n\t};\n\n\tstatic const int MHz[4] = { 33, 40, 50, 66 };\n\tvoid *private_data = NULL;\n\tconst struct ata_port_info *ppi[] = { NULL, NULL };\n\tu8 rev = dev->revision;\n\tu8 irqmask;\n\tu8 mcr1;\n\tunsigned int freq;  \n\tint prefer_dpll = 1;\n\n\tunsigned long iobase = pci_resource_start(dev, 4);\n\n\tconst struct hpt_chip *chip_table;\n\tint clock_slot;\n\tint rc;\n\n\trc = pcim_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (dev->device) {\n\tcase PCI_DEVICE_ID_TTI_HPT366:\n\t\t \n\t\t \n\t\tif (rev < 3)\n\t\t\treturn -ENODEV;\n\t\t \n\t\tif (rev == 6)\n\t\t\treturn -ENODEV;\n\n\t\tswitch (rev) {\n\t\tcase 3:\n\t\t\tppi[0] = &info_hpt370;\n\t\t\tchip_table = &hpt370;\n\t\t\tprefer_dpll = 0;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tppi[0] = &info_hpt370a;\n\t\t\tchip_table = &hpt370a;\n\t\t\tprefer_dpll = 0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tppi[0] = &info_hpt372;\n\t\t\tchip_table = &hpt372;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"Unknown HPT366 subtype, please report (%d)\\n\",\n\t\t\t       rev);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TTI_HPT372:\n\t\t \n\t\tif (rev >= 2)\n\t\t\treturn -ENODEV;\n\t\tppi[0] = &info_hpt372;\n\t\tchip_table = &hpt372a;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TTI_HPT302:\n\t\t \n\t\tif (rev > 1)\n\t\t\treturn -ENODEV;\n\t\tppi[0] = &info_hpt302;\n\t\t \n\t\tchip_table = &hpt302;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TTI_HPT371:\n\t\tif (rev > 1)\n\t\t\treturn -ENODEV;\n\t\tppi[0] = &info_hpt302;\n\t\tchip_table = &hpt371;\n\t\t \n\t\tpci_read_config_byte(dev, 0x50, &mcr1);\n\t\tmcr1 &= ~0x04;\n\t\tpci_write_config_byte(dev, 0x50, mcr1);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TTI_HPT374:\n\t\tchip_table = &hpt374;\n\t\tif (!(PCI_FUNC(dev->devfn) & 1))\n\t\t\t*ppi = &info_hpt374_fn0;\n\t\telse\n\t\t\t*ppi = &info_hpt374_fn1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"PCI table is bogus, please report (%d)\\n\",\n\t\t\tdev->device);\n\t\treturn -ENODEV;\n\t}\n\t \n\n\tpci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\n\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\n\tpci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\n\tpci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\n\n\tpci_read_config_byte(dev, 0x5A, &irqmask);\n\tirqmask &= ~0x10;\n\tpci_write_config_byte(dev, 0x5a, irqmask);\n\n\t \n\tif (dev->device == PCI_DEVICE_ID_TTI_HPT371) {\n\t\tu8 mcr1;\n\n\t\tpci_read_config_byte(dev, 0x50, &mcr1);\n\t\tmcr1 &= ~0x04;\n\t\tpci_write_config_byte(dev, 0x50, mcr1);\n\t}\n\n\t \n\n\tpci_write_config_byte(dev, 0x5b, 0x23);\n\n\t \n\tif (chip_table == &hpt372a)\n\t\toutb(0x0e, iobase + 0x9c);\n\n\tfreq = hpt37x_pci_clock(dev, chip_table->base);\n\tif (!freq)\n\t\treturn -ENODEV;\n\n\t \n\n\tclock_slot = hpt37x_clock_slot(freq);\n\tif (chip_table->clocks[clock_slot] == NULL || prefer_dpll) {\n\t\t \n\t\tunsigned int f_low, f_high;\n\t\tint dpll, adjust;\n\n\t\t \n\t\tdpll = (ppi[0]->udma_mask & 0xC0) ? 3 : 2;\n\n\t\tf_low = (MHz[clock_slot] * 48) / MHz[dpll];\n\t\tf_high = f_low + 2;\n\t\tif (clock_slot > 1)\n\t\t\tf_high += 2;\n\n\t\t \n\t\tpci_write_config_byte(dev, 0x5b, 0x21);\n\t\tpci_write_config_dword(dev, 0x5C,\n\t\t\t\t       (f_high << 16) | f_low | 0x100);\n\n\t\tfor (adjust = 0; adjust < 8; adjust++) {\n\t\t\tif (hpt37x_calibrate_dpll(dev))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (adjust & 1)\n\t\t\t\tf_low -= adjust >> 1;\n\t\t\telse\n\t\t\t\tf_high += adjust >> 1;\n\t\t\tpci_write_config_dword(dev, 0x5C,\n\t\t\t\t\t       (f_high << 16) | f_low | 0x100);\n\t\t}\n\t\tif (adjust == 8) {\n\t\t\tdev_err(&dev->dev, \"DPLL did not stabilize!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (dpll == 3)\n\t\t\tprivate_data = (void *)hpt37x_timings_66;\n\t\telse\n\t\t\tprivate_data = (void *)hpt37x_timings_50;\n\n\t\tdev_info(&dev->dev, \"bus clock %dMHz, using %dMHz DPLL\\n\",\n\t\t\tMHz[clock_slot], MHz[dpll]);\n\t} else {\n\t\tprivate_data = (void *)chip_table->clocks[clock_slot];\n\t\t \n\n\t\tif (clock_slot < 2 && ppi[0] == &info_hpt370)\n\t\t\tppi[0] = &info_hpt370_33;\n\t\tif (clock_slot < 2 && ppi[0] == &info_hpt370a)\n\t\t\tppi[0] = &info_hpt370a_33;\n\n\t\tdev_info(&dev->dev, \"%s using %dMHz bus clock\\n\",\n\t\t\tchip_table->name, MHz[clock_slot]);\n\t}\n\n\t \n\treturn ata_pci_bmdma_init_one(dev, ppi, &hpt37x_sht, private_data, 0);\n}\n\nstatic const struct pci_device_id hpt37x[] = {\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT366), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT371), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT372), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT374), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT302), },\n\n\t{ },\n};\n\nstatic struct pci_driver hpt37x_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= hpt37x,\n\t.probe\t\t= hpt37x_init_one,\n\t.remove\t\t= ata_pci_remove_one\n};\n\nmodule_pci_driver(hpt37x_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the Highpoint HPT37x/30x\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, hpt37x);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}