{
  "module_name": "sata_promise.h",
  "hash_id": "a12a676ecd1dd6f68932d68e406d726f3a145e79a9996ecb3d4ecfcd3df006fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_promise.h",
  "human_readable_source": " \n \n\n#ifndef __SATA_PROMISE_H__\n#define __SATA_PROMISE_H__\n\n#include <linux/ata.h>\n\nenum pdc_packet_bits {\n\tPDC_PKT_READ\t\t= (1 << 2),\n\tPDC_PKT_NODATA\t\t= (1 << 3),\n\n\tPDC_PKT_SIZEMASK\t= (1 << 7) | (1 << 6) | (1 << 5),\n\tPDC_PKT_CLEAR_BSY\t= (1 << 4),\n\tPDC_PKT_WAIT_DRDY\t= (1 << 3) | (1 << 4),\n\tPDC_LAST_REG\t\t= (1 << 3),\n\n\tPDC_REG_DEVCTL\t\t= (1 << 3) | (1 << 2) | (1 << 1),\n};\n\nstatic inline unsigned int pdc_pkt_header(struct ata_taskfile *tf,\n\t\t\t\t\t  dma_addr_t sg_table,\n\t\t\t\t\t  unsigned int devno, u8 *buf)\n{\n\tu8 dev_reg;\n\t__le32 *buf32 = (__le32 *) buf;\n\n\t \n\tswitch (tf->protocol) {\n\tcase ATA_PROT_DMA:\n\t\tif (!(tf->flags & ATA_TFLAG_WRITE))\n\t\t\tbuf32[0] = cpu_to_le32(PDC_PKT_READ);\n\t\telse\n\t\t\tbuf32[0] = 0;\n\t\tbreak;\n\n\tcase ATA_PROT_NODATA:\n\t\tbuf32[0] = cpu_to_le32(PDC_PKT_NODATA);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tbuf32[1] = cpu_to_le32(sg_table);\t \n\tbuf32[2] = 0;\t\t\t\t \n\n\tif (devno == 0)\n\t\tdev_reg = ATA_DEVICE_OBS;\n\telse\n\t\tdev_reg = ATA_DEVICE_OBS | ATA_DEV1;\n\n\t \n\tbuf[12] = (1 << 5) | PDC_PKT_CLEAR_BSY | ATA_REG_DEVICE;\n\tbuf[13] = dev_reg;\n\n\t \n\tbuf[14] = (1 << 5) | PDC_REG_DEVCTL;\n\tbuf[15] = tf->ctl;\n\n\treturn 16; \t \n}\n\nstatic inline unsigned int pdc_pkt_footer(struct ata_taskfile *tf, u8 *buf,\n\t\t\t\t  unsigned int i)\n{\n\tif (tf->flags & ATA_TFLAG_DEVICE) {\n\t\tbuf[i++] = (1 << 5) | ATA_REG_DEVICE;\n\t\tbuf[i++] = tf->device;\n\t}\n\n\t \n\tbuf[i++] = (1 << 5) | PDC_LAST_REG | ATA_REG_CMD;\n\tbuf[i++] = tf->command;\n\n\treturn i;\n}\n\nstatic inline unsigned int pdc_prep_lba28(struct ata_taskfile *tf, u8 *buf, unsigned int i)\n{\n\t \n\n\t \n\tbuf[i++] = (1 << 5) | ATA_REG_FEATURE;\n\tbuf[i++] = tf->feature;\n\n\tbuf[i++] = (1 << 5) | ATA_REG_NSECT;\n\tbuf[i++] = tf->nsect;\n\n\tbuf[i++] = (1 << 5) | ATA_REG_LBAL;\n\tbuf[i++] = tf->lbal;\n\n\tbuf[i++] = (1 << 5) | ATA_REG_LBAM;\n\tbuf[i++] = tf->lbam;\n\n\tbuf[i++] = (1 << 5) | ATA_REG_LBAH;\n\tbuf[i++] = tf->lbah;\n\n\treturn i;\n}\n\nstatic inline unsigned int pdc_prep_lba48(struct ata_taskfile *tf, u8 *buf, unsigned int i)\n{\n\t \n\n\t \n\tbuf[i++] = (2 << 5) | ATA_REG_FEATURE;\n\tbuf[i++] = tf->hob_feature;\n\tbuf[i++] = tf->feature;\n\n\tbuf[i++] = (2 << 5) | ATA_REG_NSECT;\n\tbuf[i++] = tf->hob_nsect;\n\tbuf[i++] = tf->nsect;\n\n\tbuf[i++] = (2 << 5) | ATA_REG_LBAL;\n\tbuf[i++] = tf->hob_lbal;\n\tbuf[i++] = tf->lbal;\n\n\tbuf[i++] = (2 << 5) | ATA_REG_LBAM;\n\tbuf[i++] = tf->hob_lbam;\n\tbuf[i++] = tf->lbam;\n\n\tbuf[i++] = (2 << 5) | ATA_REG_LBAH;\n\tbuf[i++] = tf->hob_lbah;\n\tbuf[i++] = tf->lbah;\n\n\treturn i;\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}