{
  "module_name": "pata_pcmcia.c",
  "hash_id": "92d555f391963b7289dd7c305d2fb43b34a3cad27dbdf749573388d0dddad9ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_pcmcia.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <scsi/scsi_host.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ciscode.h>\n\n\n#define DRV_NAME \"pata_pcmcia\"\n#define DRV_VERSION \"0.3.5\"\n\n \n\nstatic int pcmcia_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)\n{\n\tstruct ata_device *master = &link->device[0];\n\tstruct ata_device *slave = &link->device[1];\n\n\tif (!ata_dev_enabled(master) || !ata_dev_enabled(slave))\n\t\treturn ata_do_set_mode(link, r_failed_dev);\n\n\tif (memcmp(master->id + ATA_ID_FW_REV,  slave->id + ATA_ID_FW_REV,\n\t\t\t   ATA_ID_FW_REV_LEN + ATA_ID_PROD_LEN) == 0) {\n\t\t \n\t\tif (memcmp(master->id + ATA_ID_SERNO, slave->id + ATA_ID_SERNO,\n\t\t\t   ATA_ID_SERNO_LEN) == 0 && master->id[ATA_ID_SERNO] >> 8) {\n\t\t\tata_dev_warn(slave, \"is a ghost device, ignoring\\n\");\n\t\t\tata_dev_disable(slave);\n\t\t}\n\t}\n\treturn ata_do_set_mode(link, r_failed_dev);\n}\n\n \n\nstatic int pcmcia_set_mode_8bit(struct ata_link *link,\n\t\t\t\tstruct ata_device **r_failed_dev)\n{\n\treturn 0;\n}\n\n \n\nstatic unsigned int ata_data_xfer_8bit(struct ata_queued_cmd *qc,\n\t\t\t\tunsigned char *buf, unsigned int buflen, int rw)\n{\n\tstruct ata_port *ap = qc->dev->link->ap;\n\n\tif (rw == READ)\n\t\tioread8_rep(ap->ioaddr.data_addr, buf, buflen);\n\telse\n\t\tiowrite8_rep(ap->ioaddr.data_addr, buf, buflen);\n\n\treturn buflen;\n}\n\n \n\nstatic void pcmcia_8bit_drain_fifo(struct ata_queued_cmd *qc)\n{\n\tint count;\n\tstruct ata_port *ap;\n\n\t \n\tif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\n\t\treturn;\n\n\tap = qc->ap;\n\n\t \n\tfor (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ)\n\t\t\t\t\t\t\t&& count++ < 65536;)\n\t\tioread8(ap->ioaddr.data_addr);\n\n\tif (count)\n\t\tata_port_warn(ap, \"drained %d bytes to clear DRQ\\n\", count);\n\n}\n\nstatic const struct scsi_host_template pcmcia_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations pcmcia_port_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t= ata_sff_data_xfer32,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_mode\t= pcmcia_set_mode,\n};\n\nstatic struct ata_port_operations pcmcia_8bit_port_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t= ata_data_xfer_8bit,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_mode\t= pcmcia_set_mode_8bit,\n\t.sff_drain_fifo\t= pcmcia_8bit_drain_fifo,\n};\n\n\nstatic int pcmcia_check_one_config(struct pcmcia_device *pdev, void *priv_data)\n{\n\tint *is_kme = priv_data;\n\n\tif ((pdev->resource[0]->flags & IO_DATA_PATH_WIDTH)\n\t    != IO_DATA_PATH_WIDTH_8) {\n\t\tpdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\t\tpdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\t}\n\tpdev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n\tpdev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\n\tif (pdev->resource[1]->end) {\n\t\tpdev->resource[0]->end = 8;\n\t\tpdev->resource[1]->end = (*is_kme) ? 2 : 1;\n\t} else {\n\t\tif (pdev->resource[0]->end < 16)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn pcmcia_request_io(pdev);\n}\n\n \n\nstatic int pcmcia_init_one(struct pcmcia_device *pdev)\n{\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tint is_kme = 0, ret = -ENOMEM, p;\n\tunsigned long io_base, ctl_base;\n\tvoid __iomem *io_addr, *ctl_addr;\n\tint n_ports = 1;\n\tstruct ata_port_operations *ops = &pcmcia_port_ops;\n\n\t \n\tpdev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO |\n\t\tCONF_AUTO_SET_VPP | CONF_AUTO_CHECK_VCC;\n\n\t \n\tis_kme = ((pdev->manf_id == MANFID_KME) &&\n\t\t  ((pdev->card_id == PRODID_KME_KXLC005_A) ||\n\t\t   (pdev->card_id == PRODID_KME_KXLC005_B)));\n\n\tif (pcmcia_loop_config(pdev, pcmcia_check_one_config, &is_kme)) {\n\t\tpdev->config_flags &= ~CONF_AUTO_CHECK_VCC;\n\t\tif (pcmcia_loop_config(pdev, pcmcia_check_one_config, &is_kme))\n\t\t\tgoto failed;  \n\t}\n\tio_base = pdev->resource[0]->start;\n\tif (pdev->resource[1]->end)\n\t\tctl_base = pdev->resource[1]->start;\n\telse\n\t\tctl_base = pdev->resource[0]->start + 0x0e;\n\n\tif (!pdev->irq)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(pdev);\n\tif (ret)\n\t\tgoto failed;\n\n\t \n\tret = -ENOMEM;\n\tio_addr = devm_ioport_map(&pdev->dev, io_base, 8);\n\tctl_addr = devm_ioport_map(&pdev->dev, ctl_base, 1);\n\tif (!io_addr || !ctl_addr)\n\t\tgoto failed;\n\n\t \n\tiowrite8(0x02, ctl_addr);\n\tif (is_kme)\n\t\tiowrite8(0x81, ctl_addr + 0x01);\n\n\t \n\tif (resource_size(pdev->resource[0]) >= 0x20)\n\t\tn_ports = 2;\n\n\tif (pdev->manf_id == 0x0097 && pdev->card_id == 0x1620)\n\t\tops = &pcmcia_8bit_port_ops;\n\t \n\tret = -ENOMEM;\n\thost = ata_host_alloc(&pdev->dev, n_ports);\n\tif (!host)\n\t\tgoto failed;\n\n\tfor (p = 0; p < n_ports; p++) {\n\t\tap = host->ports[p];\n\n\t\tap->ops = ops;\n\t\tap->pio_mask = ATA_PIO0;\t \n\t\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\t\tap->ioaddr.cmd_addr = io_addr + 0x10 * p;\n\t\tap->ioaddr.altstatus_addr = ctl_addr + 0x10 * p;\n\t\tap->ioaddr.ctl_addr = ctl_addr + 0x10 * p;\n\t\tata_sff_std_ports(&ap->ioaddr);\n\n\t\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\", io_base, ctl_base);\n\t}\n\n\t \n\tret = ata_host_activate(host, pdev->irq, ata_sff_interrupt,\n\t\t\t\tIRQF_SHARED, &pcmcia_sht);\n\tif (ret)\n\t\tgoto failed;\n\n\tpdev->priv = host;\n\treturn 0;\n\nfailed:\n\tpcmcia_disable_device(pdev);\n\treturn ret;\n}\n\n \n\nstatic void pcmcia_remove_one(struct pcmcia_device *pdev)\n{\n\tstruct ata_host *host = pdev->priv;\n\n\tif (host)\n\t\tata_host_detach(host);\n\n\tpcmcia_disable_device(pdev);\n}\n\nstatic const struct pcmcia_device_id pcmcia_devices[] = {\n\tPCMCIA_DEVICE_FUNC_ID(4),\n\tPCMCIA_DEVICE_MANF_CARD(0x0000, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x0007, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x000a, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x001c, 0x0001),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x0032, 0x0704),\n\tPCMCIA_DEVICE_MANF_CARD(0x0032, 0x2904),\n\tPCMCIA_DEVICE_MANF_CARD(0x0045, 0x0401),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x004f, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x0097, 0x1620), \t \n\tPCMCIA_DEVICE_MANF_CARD(0x0098, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x00a4, 0x002d),\n\tPCMCIA_DEVICE_MANF_CARD(0x00ce, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x00f1, 0x0101),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x0319, 0x0000),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x2080, 0x0001),\n\tPCMCIA_DEVICE_MANF_CARD(0x4e01, 0x0100),\t \n\tPCMCIA_DEVICE_MANF_CARD(0x4e01, 0x0200),\t \n\tPCMCIA_DEVICE_PROD_ID123(\"Caravelle\", \"PSC-IDE \", \"PSC000\", 0x8c36137c, 0xd0693ab8, 0x2768a9f0),\n\tPCMCIA_DEVICE_PROD_ID123(\"CDROM\", \"IDE\", \"MCD-601p\", 0x1b9179ca, 0xede88951, 0x0d902f74),\n\tPCMCIA_DEVICE_PROD_ID123(\"PCMCIA\", \"IDE CARD\", \"F1\", 0x281f1c5d, 0x1907960c, 0xf7fde8b9),\n\tPCMCIA_DEVICE_PROD_ID12(\"ARGOSY\", \"CD-ROM\", 0x78f308dc, 0x66536591),\n\tPCMCIA_DEVICE_PROD_ID12(\"ARGOSY\", \"PnPIDE\", 0x78f308dc, 0x0c694728),\n\tPCMCIA_DEVICE_PROD_ID12(\"CNF   \", \"CD-ROM\", 0x46d7db81, 0x66536591),\n\tPCMCIA_DEVICE_PROD_ID12(\"CNF CD-M\", \"CD-ROM\", 0x7d93b852, 0x66536591),\n\tPCMCIA_DEVICE_PROD_ID12(\"Creative Technology Ltd.\", \"PCMCIA CD-ROM Interface Card\", 0xff8c8a45, 0xfe8020c4),\n\tPCMCIA_DEVICE_PROD_ID12(\"Digital Equipment Corporation.\", \"Digital Mobile Media CD-ROM\", 0x17692a66, 0xef1dcbde),\n\tPCMCIA_DEVICE_PROD_ID12(\"EXP\", \"CD+GAME\", 0x6f58c983, 0x63c13aaf),\n\tPCMCIA_DEVICE_PROD_ID12(\"EXP   \", \"CD-ROM\", 0x0a5c52fd, 0x66536591),\n\tPCMCIA_DEVICE_PROD_ID12(\"EXP   \", \"PnPIDE\", 0x0a5c52fd, 0x0c694728),\n\tPCMCIA_DEVICE_PROD_ID12(\"FREECOM\", \"PCCARD-IDE\", 0x5714cbf7, 0x48e0ab8e),\n\tPCMCIA_DEVICE_PROD_ID12(\"HITACHI\", \"FLASH\", 0xf4f43949, 0x9eb86aae),\n\tPCMCIA_DEVICE_PROD_ID12(\"HITACHI\", \"microdrive\", 0xf4f43949, 0xa6d76178),\n\tPCMCIA_DEVICE_PROD_ID12(\"Hyperstone\", \"Model1\", 0x3d5b9ef5, 0xca6ab420),\n\tPCMCIA_DEVICE_PROD_ID12(\"IBM\", \"microdrive\", 0xb569a6e5, 0xa6d76178),\n\tPCMCIA_DEVICE_PROD_ID12(\"IBM\", \"IBM17JSSFP20\", 0xb569a6e5, 0xf2508753),\n\tPCMCIA_DEVICE_PROD_ID12(\"KINGSTON\", \"CF CARD 1GB\", 0x2e6d1829, 0x55d5bffb),\n\tPCMCIA_DEVICE_PROD_ID12(\"KINGSTON\", \"CF CARD 4GB\", 0x2e6d1829, 0x531e7d10),\n\tPCMCIA_DEVICE_PROD_ID12(\"KINGSTON\", \"CF8GB\", 0x2e6d1829, 0xacbe682e),\n\tPCMCIA_DEVICE_PROD_ID12(\"IO DATA\", \"CBIDE2      \", 0x547e66dc, 0x8671043b),\n\tPCMCIA_DEVICE_PROD_ID12(\"IO DATA\", \"PCIDE\", 0x547e66dc, 0x5c5ab149),\n\tPCMCIA_DEVICE_PROD_ID12(\"IO DATA\", \"PCIDEII\", 0x547e66dc, 0xb3662674),\n\tPCMCIA_DEVICE_PROD_ID12(\"LOOKMEET\", \"CBIDE2      \", 0xe37be2b5, 0x8671043b),\n\tPCMCIA_DEVICE_PROD_ID12(\"M-Systems\", \"CF300\", 0x7ed2ad87, 0x7e9e78ee),\n\tPCMCIA_DEVICE_PROD_ID12(\"M-Systems\", \"CF500\", 0x7ed2ad87, 0x7a13045c),\n\tPCMCIA_DEVICE_PROD_ID2(\"NinjaATA-\", 0xebe0bd79),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"CD-ROM\", 0x281f1c5d, 0x66536591),\n\tPCMCIA_DEVICE_PROD_ID12(\"PCMCIA\", \"PnPIDE\", 0x281f1c5d, 0x0c694728),\n\tPCMCIA_DEVICE_PROD_ID12(\"SHUTTLE TECHNOLOGY LTD.\", \"PCCARD-IDE/ATAPI Adapter\", 0x4a3f0ba0, 0x322560e1),\n\tPCMCIA_DEVICE_PROD_ID12(\"SEAGATE\", \"ST1\", 0x87c1b330, 0xe1f30883),\n\tPCMCIA_DEVICE_PROD_ID12(\"SAMSUNG\", \"04/05/06\", 0x43d74cb4, 0x6a22777d),\n\tPCMCIA_DEVICE_PROD_ID12(\"SMI VENDOR\", \"SMI PRODUCT\", 0x30896c92, 0x703cc5f6),\n\tPCMCIA_DEVICE_PROD_ID12(\"TOSHIBA\", \"MK2001MPL\", 0xb4585a1a, 0x3489e003),\n\tPCMCIA_DEVICE_PROD_ID1(\"TRANSCEND    512M   \", 0xd0909443),\n\tPCMCIA_DEVICE_PROD_ID12(\"TRANSCEND\", \"TS1GCF45\", 0x709b1bf1, 0xf68b6f32),\n\tPCMCIA_DEVICE_PROD_ID12(\"TRANSCEND\", \"TS1GCF80\", 0x709b1bf1, 0x2a54d4b1),\n\tPCMCIA_DEVICE_PROD_ID12(\"TRANSCEND\", \"TS2GCF120\", 0x709b1bf1, 0x969aa4f2),\n\tPCMCIA_DEVICE_PROD_ID12(\"TRANSCEND\", \"TS4GCF120\", 0x709b1bf1, 0xf54a91c8),\n\tPCMCIA_DEVICE_PROD_ID12(\"TRANSCEND\", \"TS4GCF133\", 0x709b1bf1, 0x7558f133),\n\tPCMCIA_DEVICE_PROD_ID12(\"TRANSCEND\", \"TS8GCF133\", 0x709b1bf1, 0xb2f89b47),\n\tPCMCIA_DEVICE_PROD_ID12(\"WIT\", \"IDE16\", 0x244e5994, 0x3e232852),\n\tPCMCIA_DEVICE_PROD_ID12(\"WEIDA\", \"TWTTI\", 0xcc7cf69c, 0x212bb918),\n\tPCMCIA_DEVICE_PROD_ID1(\"STI Flash\", 0xe4a13209),\n\tPCMCIA_DEVICE_PROD_ID12(\"STI\", \"Flash 5.0\", 0xbf2df18d, 0x8cb57a0e),\n\tPCMCIA_MFC_DEVICE_PROD_ID12(1, \"SanDisk\", \"ConnectPlus\", 0x7a954bd9, 0x74be00c6),\n\tPCMCIA_DEVICE_PROD_ID2(\"Flash Card\", 0x5a362506),\n\tPCMCIA_DEVICE_NULL,\n};\n\nMODULE_DEVICE_TABLE(pcmcia, pcmcia_devices);\n\nstatic struct pcmcia_driver pcmcia_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= pcmcia_devices,\n\t.probe\t\t= pcmcia_init_one,\n\t.remove\t\t= pcmcia_remove_one,\n};\nmodule_pcmcia_driver(pcmcia_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for PCMCIA ATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}