{
  "module_name": "pata_platform.c",
  "hash_id": "5e65eb884eff4dd77dba0a8b7b74cbbb121c5b27c557ee06454bf5cd09c74318",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_platform.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <scsi/scsi_host.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n#include <linux/platform_device.h>\n#include <linux/ata_platform.h>\n\n#define DRV_NAME \"pata_platform\"\n#define DRV_VERSION \"1.2\"\n\nstatic int pio_mask = 1;\nmodule_param(pio_mask, int, 0);\nMODULE_PARM_DESC(pio_mask, \"PIO modes supported, mode 0 only by default\");\n\n \nstatic int pata_platform_set_mode(struct ata_link *link, struct ata_device **unused)\n{\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\t \n\t\tdev->pio_mode = dev->xfer_mode = XFER_PIO_0;\n\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\tdev->flags |= ATA_DFLAG_PIO;\n\t\tata_dev_info(dev, \"configured for PIO\\n\");\n\t}\n\treturn 0;\n}\n\nstatic const struct scsi_host_template pata_platform_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic void pata_platform_setup_port(struct ata_ioports *ioaddr,\n\t\t\t\t     unsigned int shift)\n{\n\t \n\tioaddr->data_addr\t= ioaddr->cmd_addr + (ATA_REG_DATA    << shift);\n\tioaddr->error_addr\t= ioaddr->cmd_addr + (ATA_REG_ERR     << shift);\n\tioaddr->feature_addr\t= ioaddr->cmd_addr + (ATA_REG_FEATURE << shift);\n\tioaddr->nsect_addr\t= ioaddr->cmd_addr + (ATA_REG_NSECT   << shift);\n\tioaddr->lbal_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAL    << shift);\n\tioaddr->lbam_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAM    << shift);\n\tioaddr->lbah_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAH    << shift);\n\tioaddr->device_addr\t= ioaddr->cmd_addr + (ATA_REG_DEVICE  << shift);\n\tioaddr->status_addr\t= ioaddr->cmd_addr + (ATA_REG_STATUS  << shift);\n\tioaddr->command_addr\t= ioaddr->cmd_addr + (ATA_REG_CMD     << shift);\n}\n\n \nint __pata_platform_probe(struct device *dev, struct resource *io_res,\n\t\t\t  struct resource *ctl_res, struct resource *irq_res,\n\t\t\t  unsigned int ioport_shift, int __pio_mask,\n\t\t\t  const struct scsi_host_template *sht, bool use16bit)\n{\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tunsigned int mmio;\n\tint irq = 0;\n\tint irq_flags = 0;\n\n\t \n\tmmio = (( io_res->flags == IORESOURCE_MEM) &&\n\t\t(ctl_res->flags == IORESOURCE_MEM));\n\n\t \n\tif (irq_res && irq_res->start > 0) {\n\t\tirq = irq_res->start;\n\t\tirq_flags = (irq_res->flags & IRQF_TRIGGER_MASK) | IRQF_SHARED;\n\t}\n\n\t \n\thost = ata_host_alloc(dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\tap = host->ports[0];\n\n\tap->ops = devm_kzalloc(dev, sizeof(*ap->ops), GFP_KERNEL);\n\tif (!ap->ops)\n\t\treturn -ENOMEM;\n\tap->ops->inherits = &ata_sff_port_ops;\n\tap->ops->cable_detect = ata_cable_unknown;\n\tap->ops->set_mode = pata_platform_set_mode;\n\tif (use16bit)\n\t\tap->ops->sff_data_xfer = ata_sff_data_xfer;\n\telse\n\t\tap->ops->sff_data_xfer = ata_sff_data_xfer32;\n\n\tap->pio_mask = __pio_mask;\n\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\n\t \n\tif (!irq) {\n\t\tap->flags |= ATA_FLAG_PIO_POLLING;\n\t\tata_port_desc(ap, \"no IRQ, using PIO polling\");\n\t}\n\n\t \n\tif (mmio) {\n\t\tap->ioaddr.cmd_addr = devm_ioremap(dev, io_res->start,\n\t\t\t\tresource_size(io_res));\n\t\tap->ioaddr.ctl_addr = devm_ioremap(dev, ctl_res->start,\n\t\t\t\tresource_size(ctl_res));\n\t} else {\n\t\tap->ioaddr.cmd_addr = devm_ioport_map(dev, io_res->start,\n\t\t\t\tresource_size(io_res));\n\t\tap->ioaddr.ctl_addr = devm_ioport_map(dev, ctl_res->start,\n\t\t\t\tresource_size(ctl_res));\n\t}\n\tif (!ap->ioaddr.cmd_addr || !ap->ioaddr.ctl_addr) {\n\t\tdev_err(dev, \"failed to map IO/CTL base\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\n\n\tpata_platform_setup_port(&ap->ioaddr, ioport_shift);\n\n\tata_port_desc(ap, \"%s cmd 0x%llx ctl 0x%llx\", mmio ? \"mmio\" : \"ioport\",\n\t\t      (unsigned long long)io_res->start,\n\t\t      (unsigned long long)ctl_res->start);\n\n\t \n\treturn ata_host_activate(host, irq, irq ? ata_sff_interrupt : NULL,\n\t\t\t\t irq_flags, sht);\n}\nEXPORT_SYMBOL_GPL(__pata_platform_probe);\n\nstatic int pata_platform_probe(struct platform_device *pdev)\n{\n\tstruct resource *io_res;\n\tstruct resource *ctl_res;\n\tstruct resource *irq_res;\n\tstruct pata_platform_info *pp_info = dev_get_platdata(&pdev->dev);\n\n\t \n\tif ((pdev->num_resources != 3) && (pdev->num_resources != 2)) {\n\t\tdev_err(&pdev->dev, \"invalid number of resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tio_res = platform_get_mem_or_io(pdev, 0);\n\tif (!io_res)\n\t\treturn -EINVAL;\n\n\t \n\tctl_res = platform_get_mem_or_io(pdev, 1);\n\tif (!ctl_res)\n\t\treturn -EINVAL;\n\n\t \n\tirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\n\treturn __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,\n\t\t\t\t     pp_info ? pp_info->ioport_shift : 0,\n\t\t\t\t     pio_mask, &pata_platform_sht, false);\n}\n\nstatic struct platform_driver pata_platform_driver = {\n\t.probe\t\t= pata_platform_probe,\n\t.remove_new\t= ata_platform_remove_one,\n\t.driver = {\n\t\t.name\t\t= DRV_NAME,\n\t},\n};\n\nmodule_platform_driver(pata_platform_driver);\n\nMODULE_AUTHOR(\"Paul Mundt\");\nMODULE_DESCRIPTION(\"low-level driver for platform device ATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}