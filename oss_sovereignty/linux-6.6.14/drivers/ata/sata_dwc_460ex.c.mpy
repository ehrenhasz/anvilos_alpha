{
  "module_name": "sata_dwc_460ex.c",
  "hash_id": "c7c53aefc42653d9a51dd4ec73342a54f1d2dcf2c0ab79e9961bbedb29a416d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_dwc_460ex.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/libata.h>\n#include <linux/slab.h>\n#include <trace/events/libata.h>\n\n#include \"libata.h\"\n\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n\n \n#undef\tDRV_NAME\n#undef\tDRV_VERSION\n\n#define DRV_NAME        \"sata-dwc\"\n#define DRV_VERSION     \"1.3\"\n\n#define sata_dwc_writel(a, v)\twritel_relaxed(v, a)\n#define sata_dwc_readl(a)\treadl_relaxed(a)\n\n#define AHB_DMA_BRST_DFLT\t64\t \n\nenum {\n\tSATA_DWC_MAX_PORTS = 1,\n\n\tSATA_DWC_SCR_OFFSET = 0x24,\n\tSATA_DWC_REG_OFFSET = 0x64,\n};\n\n \nstruct sata_dwc_regs {\n\tu32 fptagr;\t\t \n\tu32 fpbor;\t\t \n\tu32 fptcr;\t\t \n\tu32 dmacr;\t\t \n\tu32 dbtsr;\t\t \n\tu32 intpr;\t\t \n\tu32 intmr;\t\t \n\tu32 errmr;\t\t \n\tu32 llcr;\t\t \n\tu32 phycr;\t\t \n\tu32 physr;\t\t \n\tu32 rxbistpd;\t\t \n\tu32 rxbistpd1;\t\t \n\tu32 rxbistpd2;\t\t \n\tu32 txbistpd;\t\t \n\tu32 txbistpd1;\t\t \n\tu32 txbistpd2;\t\t \n\tu32 bistcr;\t\t \n\tu32 bistfctr;\t\t \n\tu32 bistsr;\t\t \n\tu32 bistdecr;\t\t \n\tu32 res[15];\t\t \n\tu32 testr;\t\t \n\tu32 versionr;\t\t \n\tu32 idr;\t\t \n\tu32 unimpl[192];\t \n\tu32 dmadr[256];\t\t \n};\n\nenum {\n\tSCR_SCONTROL_DET_ENABLE\t=\t0x00000001,\n\tSCR_SSTATUS_DET_PRESENT\t=\t0x00000001,\n\tSCR_SERROR_DIAG_X\t=\t0x04000000,\n \n\tSATA_DWC_TXFIFO_DEPTH\t=\t0x01FF,\n\tSATA_DWC_RXFIFO_DEPTH\t=\t0x01FF,\n\tSATA_DWC_DMACR_TMOD_TXCHEN =\t0x00000004,\n\tSATA_DWC_DMACR_TXCHEN\t= (0x00000001 | SATA_DWC_DMACR_TMOD_TXCHEN),\n\tSATA_DWC_DMACR_RXCHEN\t= (0x00000002 | SATA_DWC_DMACR_TMOD_TXCHEN),\n\tSATA_DWC_DMACR_TXRXCH_CLEAR =\tSATA_DWC_DMACR_TMOD_TXCHEN,\n\tSATA_DWC_INTPR_DMAT\t=\t0x00000001,\n\tSATA_DWC_INTPR_NEWFP\t=\t0x00000002,\n\tSATA_DWC_INTPR_PMABRT\t=\t0x00000004,\n\tSATA_DWC_INTPR_ERR\t=\t0x00000008,\n\tSATA_DWC_INTPR_NEWBIST\t=\t0x00000010,\n\tSATA_DWC_INTPR_IPF\t=\t0x10000000,\n\tSATA_DWC_INTMR_DMATM\t=\t0x00000001,\n\tSATA_DWC_INTMR_NEWFPM\t=\t0x00000002,\n\tSATA_DWC_INTMR_PMABRTM\t=\t0x00000004,\n\tSATA_DWC_INTMR_ERRM\t=\t0x00000008,\n\tSATA_DWC_INTMR_NEWBISTM\t=\t0x00000010,\n\tSATA_DWC_LLCR_SCRAMEN\t=\t0x00000001,\n\tSATA_DWC_LLCR_DESCRAMEN\t=\t0x00000002,\n\tSATA_DWC_LLCR_RPDEN\t=\t0x00000004,\n \n\tSATA_DWC_SERROR_ERR_BITS =\t0x0FFF0F03\n};\n\n#define SATA_DWC_SCR0_SPD_GET(v)\t(((v) >> 4) & 0x0000000F)\n#define SATA_DWC_DMACR_TX_CLEAR(v)\t(((v) & ~SATA_DWC_DMACR_TXCHEN) |\\\n\t\t\t\t\t\t SATA_DWC_DMACR_TMOD_TXCHEN)\n#define SATA_DWC_DMACR_RX_CLEAR(v)\t(((v) & ~SATA_DWC_DMACR_RXCHEN) |\\\n\t\t\t\t\t\t SATA_DWC_DMACR_TMOD_TXCHEN)\n#define SATA_DWC_DBTSR_MWR(size)\t(((size)/4) & SATA_DWC_TXFIFO_DEPTH)\n#define SATA_DWC_DBTSR_MRD(size)\t((((size)/4) & SATA_DWC_RXFIFO_DEPTH)\\\n\t\t\t\t\t\t << 16)\nstruct sata_dwc_device {\n\tstruct device\t\t*dev;\t\t \n\tstruct ata_probe_ent\t*pe;\t\t \n\tstruct ata_host\t\t*host;\n\tstruct sata_dwc_regs __iomem *sata_dwc_regs;\t \n\tu32\t\t\tsactive_issued;\n\tu32\t\t\tsactive_queued;\n\tstruct phy\t\t*phy;\n\tphys_addr_t\t\tdmadr;\n#ifdef CONFIG_SATA_DWC_OLD_DMA\n\tstruct dw_dma_chip\t*dma;\n#endif\n};\n\n \n#define SATA_DWC_QCMD_MAX\t(ATA_MAX_QUEUE + 1)\n\nstruct sata_dwc_device_port {\n\tstruct sata_dwc_device\t*hsdev;\n\tint\t\t\tcmd_issued[SATA_DWC_QCMD_MAX];\n\tint\t\t\tdma_pending[SATA_DWC_QCMD_MAX];\n\n\t \n\tstruct dma_chan\t\t\t*chan;\n\tstruct dma_async_tx_descriptor\t*desc[SATA_DWC_QCMD_MAX];\n\tu32\t\t\t\tdma_interrupt_count;\n};\n\n \n#define HSDEV_FROM_HOST(host)\t((struct sata_dwc_device *)(host)->private_data)\n#define HSDEV_FROM_AP(ap)\t((struct sata_dwc_device *)(ap)->host->private_data)\n#define HSDEVP_FROM_AP(ap)\t((struct sata_dwc_device_port *)(ap)->private_data)\n#define HSDEV_FROM_QC(qc)\t((struct sata_dwc_device *)(qc)->ap->host->private_data)\n#define HSDEV_FROM_HSDEVP(p)\t((struct sata_dwc_device *)(p)->hsdev)\n\nenum {\n\tSATA_DWC_CMD_ISSUED_NOT\t\t= 0,\n\tSATA_DWC_CMD_ISSUED_PEND\t= 1,\n\tSATA_DWC_CMD_ISSUED_EXEC\t= 2,\n\tSATA_DWC_CMD_ISSUED_NODATA\t= 3,\n\n\tSATA_DWC_DMA_PENDING_NONE\t= 0,\n\tSATA_DWC_DMA_PENDING_TX\t\t= 1,\n\tSATA_DWC_DMA_PENDING_RX\t\t= 2,\n};\n\n \nstatic void sata_dwc_bmdma_start_by_tag(struct ata_queued_cmd *qc, u8 tag);\nstatic int sata_dwc_qc_complete(struct ata_port *ap, struct ata_queued_cmd *qc);\nstatic void sata_dwc_dma_xfer_complete(struct ata_port *ap);\nstatic void sata_dwc_clear_dmacr(struct sata_dwc_device_port *hsdevp, u8 tag);\n\n#ifdef CONFIG_SATA_DWC_OLD_DMA\n\n#include <linux/platform_data/dma-dw.h>\n#include <linux/dma/dw.h>\n\nstatic struct dw_dma_slave sata_dwc_dma_dws = {\n\t.src_id = 0,\n\t.dst_id = 0,\n\t.m_master = 1,\n\t.p_master = 0,\n};\n\nstatic bool sata_dwc_dma_filter(struct dma_chan *chan, void *param)\n{\n\tstruct dw_dma_slave *dws = &sata_dwc_dma_dws;\n\n\tif (dws->dma_dev != chan->device->dev)\n\t\treturn false;\n\n\tchan->private = dws;\n\treturn true;\n}\n\nstatic int sata_dwc_dma_get_channel_old(struct sata_dwc_device_port *hsdevp)\n{\n\tstruct sata_dwc_device *hsdev = hsdevp->hsdev;\n\tstruct dw_dma_slave *dws = &sata_dwc_dma_dws;\n\tstruct device *dev = hsdev->dev;\n\tdma_cap_mask_t mask;\n\n\tdws->dma_dev = dev;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\t \n\thsdevp->chan = dma_request_channel(mask, sata_dwc_dma_filter, hsdevp);\n\tif (!hsdevp->chan) {\n\t\tdev_err(dev, \"%s: dma channel unavailable\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int sata_dwc_dma_init_old(struct platform_device *pdev,\n\t\t\t\t struct sata_dwc_device *hsdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\thsdev->dma = devm_kzalloc(dev, sizeof(*hsdev->dma), GFP_KERNEL);\n\tif (!hsdev->dma)\n\t\treturn -ENOMEM;\n\n\thsdev->dma->dev = dev;\n\thsdev->dma->id = pdev->id;\n\n\t \n\thsdev->dma->irq = irq_of_parse_and_map(np, 1);\n\tif (!hsdev->dma->irq) {\n\t\tdev_err(dev, \"no SATA DMA irq\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thsdev->dma->regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(hsdev->dma->regs))\n\t\treturn PTR_ERR(hsdev->dma->regs);\n\n\t \n\treturn dw_dma_probe(hsdev->dma);\n}\n\nstatic void sata_dwc_dma_exit_old(struct sata_dwc_device *hsdev)\n{\n\tif (!hsdev->dma)\n\t\treturn;\n\n\tdw_dma_remove(hsdev->dma);\n}\n\n#endif\n\nstatic const char *get_prot_descript(u8 protocol)\n{\n\tswitch (protocol) {\n\tcase ATA_PROT_NODATA:\n\t\treturn \"ATA no data\";\n\tcase ATA_PROT_PIO:\n\t\treturn \"ATA PIO\";\n\tcase ATA_PROT_DMA:\n\t\treturn \"ATA DMA\";\n\tcase ATA_PROT_NCQ:\n\t\treturn \"ATA NCQ\";\n\tcase ATA_PROT_NCQ_NODATA:\n\t\treturn \"ATA NCQ no data\";\n\tcase ATAPI_PROT_NODATA:\n\t\treturn \"ATAPI no data\";\n\tcase ATAPI_PROT_PIO:\n\t\treturn \"ATAPI PIO\";\n\tcase ATAPI_PROT_DMA:\n\t\treturn \"ATAPI DMA\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void dma_dwc_xfer_done(void *hsdev_instance)\n{\n\tunsigned long flags;\n\tstruct sata_dwc_device *hsdev = hsdev_instance;\n\tstruct ata_host *host = (struct ata_host *)hsdev->host;\n\tstruct ata_port *ap;\n\tstruct sata_dwc_device_port *hsdevp;\n\tu8 tag = 0;\n\tunsigned int port = 0;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tap = host->ports[port];\n\thsdevp = HSDEVP_FROM_AP(ap);\n\ttag = ap->link.active_tag;\n\n\t \n\thsdevp->dma_interrupt_count++;\n\tsata_dwc_clear_dmacr(hsdevp, tag);\n\n\tif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_NONE) {\n\t\tdev_err(ap->dev, \"DMA not pending tag=0x%02x pending=%d\\n\",\n\t\t\ttag, hsdevp->dma_pending[tag]);\n\t}\n\n\tif ((hsdevp->dma_interrupt_count % 2) == 0)\n\t\tsata_dwc_dma_xfer_complete(ap);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic struct dma_async_tx_descriptor *dma_dwc_xfer_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\n\tstruct dma_slave_config sconf;\n\tstruct dma_async_tx_descriptor *desc;\n\n\tif (qc->dma_dir == DMA_DEV_TO_MEM) {\n\t\tsconf.src_addr = hsdev->dmadr;\n\t\tsconf.device_fc = false;\n\t} else {\t \n\t\tsconf.dst_addr = hsdev->dmadr;\n\t\tsconf.device_fc = false;\n\t}\n\n\tsconf.direction = qc->dma_dir;\n\tsconf.src_maxburst = AHB_DMA_BRST_DFLT / 4;\t \n\tsconf.dst_maxburst = AHB_DMA_BRST_DFLT / 4;\t \n\tsconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tsconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tdmaengine_slave_config(hsdevp->chan, &sconf);\n\n\t \n\tdesc = dmaengine_prep_slave_sg(hsdevp->chan, qc->sg, qc->n_elem,\n\t\t\t\t       qc->dma_dir,\n\t\t\t\t       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->callback = dma_dwc_xfer_done;\n\tdesc->callback_param = hsdev;\n\n\tdev_dbg(hsdev->dev, \"%s sg: 0x%p, count: %d addr: %pa\\n\", __func__,\n\t\tqc->sg, qc->n_elem, &hsdev->dmadr);\n\n\treturn desc;\n}\n\nstatic int sata_dwc_scr_read(struct ata_link *link, unsigned int scr, u32 *val)\n{\n\tif (scr > SCR_NOTIFICATION) {\n\t\tdev_err(link->ap->dev, \"%s: Incorrect SCR offset 0x%02x\\n\",\n\t\t\t__func__, scr);\n\t\treturn -EINVAL;\n\t}\n\n\t*val = sata_dwc_readl(link->ap->ioaddr.scr_addr + (scr * 4));\n\tdev_dbg(link->ap->dev, \"%s: id=%d reg=%d val=0x%08x\\n\", __func__,\n\t\tlink->ap->print_id, scr, *val);\n\n\treturn 0;\n}\n\nstatic int sata_dwc_scr_write(struct ata_link *link, unsigned int scr, u32 val)\n{\n\tdev_dbg(link->ap->dev, \"%s: id=%d reg=%d val=0x%08x\\n\", __func__,\n\t\tlink->ap->print_id, scr, val);\n\tif (scr > SCR_NOTIFICATION) {\n\t\tdev_err(link->ap->dev, \"%s: Incorrect SCR offset 0x%02x\\n\",\n\t\t\t __func__, scr);\n\t\treturn -EINVAL;\n\t}\n\tsata_dwc_writel(link->ap->ioaddr.scr_addr + (scr * 4), val);\n\n\treturn 0;\n}\n\nstatic void clear_serror(struct ata_port *ap)\n{\n\tu32 val;\n\tsata_dwc_scr_read(&ap->link, SCR_ERROR, &val);\n\tsata_dwc_scr_write(&ap->link, SCR_ERROR, val);\n}\n\nstatic void clear_interrupt_bit(struct sata_dwc_device *hsdev, u32 bit)\n{\n\tsata_dwc_writel(&hsdev->sata_dwc_regs->intpr,\n\t\t\tsata_dwc_readl(&hsdev->sata_dwc_regs->intpr));\n}\n\nstatic u32 qcmd_tag_to_mask(u8 tag)\n{\n\treturn 0x00000001 << (tag & 0x1f);\n}\n\n \nstatic void sata_dwc_error_intr(struct ata_port *ap,\n\t\t\t\tstruct sata_dwc_device *hsdev, uint intpr)\n{\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tunsigned int err_mask = 0, action = 0;\n\tstruct ata_queued_cmd *qc;\n\tu32 serror;\n\tu8 status, tag;\n\n\tata_ehi_clear_desc(ehi);\n\n\tsata_dwc_scr_read(&ap->link, SCR_ERROR, &serror);\n\tstatus = ap->ops->sff_check_status(ap);\n\n\ttag = ap->link.active_tag;\n\n\tdev_err(ap->dev,\n\t\t\"%s SCR_ERROR=0x%08x intpr=0x%08x status=0x%08x dma_intp=%d pending=%d issued=%d\",\n\t\t__func__, serror, intpr, status, hsdevp->dma_interrupt_count,\n\t\thsdevp->dma_pending[tag], hsdevp->cmd_issued[tag]);\n\n\t \n\tclear_serror(ap);\n\tclear_interrupt_bit(hsdev, SATA_DWC_INTPR_ERR);\n\n\t \n\n\terr_mask |= AC_ERR_HOST_BUS;\n\taction |= ATA_EH_RESET;\n\n\t \n\tehi->serror |= serror;\n\tehi->action |= action;\n\n\tqc = ata_qc_from_tag(ap, tag);\n\tif (qc)\n\t\tqc->err_mask |= err_mask;\n\telse\n\t\tehi->err_mask |= err_mask;\n\n\tata_port_abort(ap);\n}\n\n \nstatic irqreturn_t sata_dwc_isr(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = (struct ata_host *)dev_instance;\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_HOST(host);\n\tstruct ata_port *ap;\n\tstruct ata_queued_cmd *qc;\n\tunsigned long flags;\n\tu8 status, tag;\n\tint handled, port = 0;\n\tuint intpr, sactive, sactive2, tag_mask;\n\tstruct sata_dwc_device_port *hsdevp;\n\thsdev->sactive_issued = 0;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\t \n\tintpr = sata_dwc_readl(&hsdev->sata_dwc_regs->intpr);\n\n\tap = host->ports[port];\n\thsdevp = HSDEVP_FROM_AP(ap);\n\n\tdev_dbg(ap->dev, \"%s intpr=0x%08x active_tag=%d\\n\", __func__, intpr,\n\t\tap->link.active_tag);\n\n\t \n\tif (intpr & SATA_DWC_INTPR_ERR) {\n\t\tsata_dwc_error_intr(ap, hsdev, intpr);\n\t\thandled = 1;\n\t\tgoto DONE;\n\t}\n\n\t \n\tif (intpr & SATA_DWC_INTPR_NEWFP) {\n\t\tclear_interrupt_bit(hsdev, SATA_DWC_INTPR_NEWFP);\n\n\t\ttag = (u8)(sata_dwc_readl(&hsdev->sata_dwc_regs->fptagr));\n\t\tdev_dbg(ap->dev, \"%s: NEWFP tag=%d\\n\", __func__, tag);\n\t\tif (hsdevp->cmd_issued[tag] != SATA_DWC_CMD_ISSUED_PEND)\n\t\t\tdev_warn(ap->dev, \"CMD tag=%d not pending?\\n\", tag);\n\n\t\thsdev->sactive_issued |= qcmd_tag_to_mask(tag);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (unlikely(!qc)) {\n\t\t\tdev_err(ap->dev, \"failed to get qc\");\n\t\t\thandled = 1;\n\t\t\tgoto DONE;\n\t\t}\n\t\t \n\t\ttrace_ata_bmdma_start(ap, &qc->tf, tag);\n\t\tqc->ap->link.active_tag = tag;\n\t\tsata_dwc_bmdma_start_by_tag(qc, tag);\n\n\t\thandled = 1;\n\t\tgoto DONE;\n\t}\n\tsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive);\n\ttag_mask = (hsdev->sactive_issued | sactive) ^ sactive;\n\n\t \n\tif (hsdev->sactive_issued == 0 && tag_mask == 0) {\n\t\tif (ap->link.active_tag == ATA_TAG_POISON)\n\t\t\ttag = 0;\n\t\telse\n\t\t\ttag = ap->link.active_tag;\n\t\tqc = ata_qc_from_tag(ap, tag);\n\n\t\t \n\t\tif (unlikely(!qc || (qc->tf.flags & ATA_TFLAG_POLLING))) {\n\t\t\tdev_err(ap->dev,\n\t\t\t\t\"%s interrupt with no active qc qc=%p\\n\",\n\t\t\t\t__func__, qc);\n\t\t\tap->ops->sff_check_status(ap);\n\t\t\thandled = 1;\n\t\t\tgoto DONE;\n\t\t}\n\t\tstatus = ap->ops->sff_check_status(ap);\n\n\t\tqc->ap->link.active_tag = tag;\n\t\thsdevp->cmd_issued[tag] = SATA_DWC_CMD_ISSUED_NOT;\n\n\t\tif (status & ATA_ERR) {\n\t\t\tdev_dbg(ap->dev, \"interrupt ATA_ERR (0x%x)\\n\", status);\n\t\t\tsata_dwc_qc_complete(ap, qc);\n\t\t\thandled = 1;\n\t\t\tgoto DONE;\n\t\t}\n\n\t\tdev_dbg(ap->dev, \"%s non-NCQ cmd interrupt, protocol: %s\\n\",\n\t\t\t__func__, get_prot_descript(qc->tf.protocol));\nDRVSTILLBUSY:\n\t\tif (ata_is_dma(qc->tf.protocol)) {\n\t\t\t \n\t\t\thsdevp->dma_interrupt_count++;\n\t\t\tif (hsdevp->dma_pending[tag] == \\\n\t\t\t\t\tSATA_DWC_DMA_PENDING_NONE) {\n\t\t\t\tdev_err(ap->dev,\n\t\t\t\t\t\"%s: DMA not pending intpr=0x%08x status=0x%08x pending=%d\\n\",\n\t\t\t\t\t__func__, intpr, status,\n\t\t\t\t\thsdevp->dma_pending[tag]);\n\t\t\t}\n\n\t\t\tif ((hsdevp->dma_interrupt_count % 2) == 0)\n\t\t\t\tsata_dwc_dma_xfer_complete(ap);\n\t\t} else if (ata_is_pio(qc->tf.protocol)) {\n\t\t\tata_sff_hsm_move(ap, qc, status, 0);\n\t\t\thandled = 1;\n\t\t\tgoto DONE;\n\t\t} else {\n\t\t\tif (unlikely(sata_dwc_qc_complete(ap, qc)))\n\t\t\t\tgoto DRVSTILLBUSY;\n\t\t}\n\n\t\thandled = 1;\n\t\tgoto DONE;\n\t}\n\n\t \n\n\t  \n\tsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive);\n\ttag_mask = (hsdev->sactive_issued | sactive) ^ sactive;\n\n\tif (sactive != 0 || hsdev->sactive_issued > 1 || tag_mask > 1) {\n\t\tdev_dbg(ap->dev,\n\t\t\t\"%s NCQ:sactive=0x%08x  sactive_issued=0x%08x tag_mask=0x%08x\\n\",\n\t\t\t__func__, sactive, hsdev->sactive_issued, tag_mask);\n\t}\n\n\tif ((tag_mask | hsdev->sactive_issued) != hsdev->sactive_issued) {\n\t\tdev_warn(ap->dev,\n\t\t\t \"Bad tag mask?  sactive=0x%08x sactive_issued=0x%08x  tag_mask=0x%08x\\n\",\n\t\t\t sactive, hsdev->sactive_issued, tag_mask);\n\t}\n\n\t \n\tstatus = ap->ops->sff_check_status(ap);\n\tdev_dbg(ap->dev, \"%s ATA status register=0x%x\\n\", __func__, status);\n\n\ttag = 0;\n\twhile (tag_mask) {\n\t\twhile (!(tag_mask & 0x00000001)) {\n\t\t\ttag++;\n\t\t\ttag_mask <<= 1;\n\t\t}\n\n\t\ttag_mask &= (~0x00000001);\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (unlikely(!qc)) {\n\t\t\tdev_err(ap->dev, \"failed to get qc\");\n\t\t\thandled = 1;\n\t\t\tgoto DONE;\n\t\t}\n\n\t\t \n\t\tqc->ap->link.active_tag = tag;\n\t\thsdevp->cmd_issued[tag] = SATA_DWC_CMD_ISSUED_NOT;\n\n\t\t \n\t\tif (status & ATA_ERR) {\n\t\t\tdev_dbg(ap->dev, \"%s ATA_ERR (0x%x)\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tsata_dwc_qc_complete(ap, qc);\n\t\t\thandled = 1;\n\t\t\tgoto DONE;\n\t\t}\n\n\t\t \n\t\tdev_dbg(ap->dev, \"%s NCQ command, protocol: %s\\n\", __func__,\n\t\t\tget_prot_descript(qc->tf.protocol));\n\t\tif (ata_is_dma(qc->tf.protocol)) {\n\t\t\thsdevp->dma_interrupt_count++;\n\t\t\tif (hsdevp->dma_pending[tag] == \\\n\t\t\t\t\tSATA_DWC_DMA_PENDING_NONE)\n\t\t\t\tdev_warn(ap->dev, \"%s: DMA not pending?\\n\",\n\t\t\t\t\t__func__);\n\t\t\tif ((hsdevp->dma_interrupt_count % 2) == 0)\n\t\t\t\tsata_dwc_dma_xfer_complete(ap);\n\t\t} else {\n\t\t\tif (unlikely(sata_dwc_qc_complete(ap, qc)))\n\t\t\t\tgoto STILLBUSY;\n\t\t}\n\t\tcontinue;\n\nSTILLBUSY:\n\t\tap->stats.idle_irq++;\n\t\tdev_warn(ap->dev, \"STILL BUSY IRQ ata%d: irq trap\\n\",\n\t\t\tap->print_id);\n\t}  \n\n\t \n\tsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive2);\n\tif (sactive2 != sactive) {\n\t\tdev_dbg(ap->dev,\n\t\t\t\"More completed - sactive=0x%x sactive2=0x%x\\n\",\n\t\t\tsactive, sactive2);\n\t}\n\thandled = 1;\n\nDONE:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void sata_dwc_clear_dmacr(struct sata_dwc_device_port *hsdevp, u8 tag)\n{\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_HSDEVP(hsdevp);\n\tu32 dmacr = sata_dwc_readl(&hsdev->sata_dwc_regs->dmacr);\n\n\tif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_RX) {\n\t\tdmacr = SATA_DWC_DMACR_RX_CLEAR(dmacr);\n\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr, dmacr);\n\t} else if (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_TX) {\n\t\tdmacr = SATA_DWC_DMACR_TX_CLEAR(dmacr);\n\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr, dmacr);\n\t} else {\n\t\t \n\t\tdev_err(hsdev->dev,\n\t\t\t\"%s DMA protocol RX and TX DMA not pending tag=0x%02x pending=%d dmacr: 0x%08x\\n\",\n\t\t\t__func__, tag, hsdevp->dma_pending[tag], dmacr);\n\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\n\t\t\t\tSATA_DWC_DMACR_TXRXCH_CLEAR);\n\t}\n}\n\nstatic void sata_dwc_dma_xfer_complete(struct ata_port *ap)\n{\n\tstruct ata_queued_cmd *qc;\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\n\tu8 tag = 0;\n\n\ttag = ap->link.active_tag;\n\tqc = ata_qc_from_tag(ap, tag);\n\tif (!qc) {\n\t\tdev_err(ap->dev, \"failed to get qc\");\n\t\treturn;\n\t}\n\n\tif (ata_is_dma(qc->tf.protocol)) {\n\t\tif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_NONE) {\n\t\t\tdev_err(ap->dev,\n\t\t\t\t\"%s DMA protocol RX and TX DMA not pending dmacr: 0x%08x\\n\",\n\t\t\t\t__func__,\n\t\t\t\tsata_dwc_readl(&hsdev->sata_dwc_regs->dmacr));\n\t\t}\n\n\t\thsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_NONE;\n\t\tsata_dwc_qc_complete(ap, qc);\n\t\tap->link.active_tag = ATA_TAG_POISON;\n\t} else {\n\t\tsata_dwc_qc_complete(ap, qc);\n\t}\n}\n\nstatic int sata_dwc_qc_complete(struct ata_port *ap, struct ata_queued_cmd *qc)\n{\n\tu8 status = 0;\n\tu32 mask = 0x0;\n\tu8 tag = qc->hw_tag;\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\thsdev->sactive_queued = 0;\n\n\tif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_TX)\n\t\tdev_err(ap->dev, \"TX DMA PENDING\\n\");\n\telse if (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_RX)\n\t\tdev_err(ap->dev, \"RX DMA PENDING\\n\");\n\tdev_dbg(ap->dev,\n\t\t\"QC complete cmd=0x%02x status=0x%02x ata%u: protocol=%d\\n\",\n\t\tqc->tf.command, status, ap->print_id, qc->tf.protocol);\n\n\t \n\tmask = (~(qcmd_tag_to_mask(tag)));\n\thsdev->sactive_queued = hsdev->sactive_queued & mask;\n\thsdev->sactive_issued = hsdev->sactive_issued & mask;\n\tata_qc_complete(qc);\n\treturn 0;\n}\n\nstatic void sata_dwc_enable_interrupts(struct sata_dwc_device *hsdev)\n{\n\t \n\tsata_dwc_writel(&hsdev->sata_dwc_regs->intmr,\n\t\t\tSATA_DWC_INTMR_ERRM |\n\t\t\tSATA_DWC_INTMR_NEWFPM |\n\t\t\tSATA_DWC_INTMR_PMABRTM |\n\t\t\tSATA_DWC_INTMR_DMATM);\n\t \n\tsata_dwc_writel(&hsdev->sata_dwc_regs->errmr, SATA_DWC_SERROR_ERR_BITS);\n\n\tdev_dbg(hsdev->dev, \"%s: INTMR = 0x%08x, ERRMR = 0x%08x\\n\",\n\t\t __func__, sata_dwc_readl(&hsdev->sata_dwc_regs->intmr),\n\t\tsata_dwc_readl(&hsdev->sata_dwc_regs->errmr));\n}\n\nstatic void sata_dwc_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t= base + 0x00;\n\tport->data_addr\t\t= base + 0x00;\n\n\tport->error_addr\t= base + 0x04;\n\tport->feature_addr\t= base + 0x04;\n\n\tport->nsect_addr\t= base + 0x08;\n\n\tport->lbal_addr\t\t= base + 0x0c;\n\tport->lbam_addr\t\t= base + 0x10;\n\tport->lbah_addr\t\t= base + 0x14;\n\n\tport->device_addr\t= base + 0x18;\n\tport->command_addr\t= base + 0x1c;\n\tport->status_addr\t= base + 0x1c;\n\n\tport->altstatus_addr\t= base + 0x20;\n\tport->ctl_addr\t\t= base + 0x20;\n}\n\nstatic int sata_dwc_dma_get_channel(struct sata_dwc_device_port *hsdevp)\n{\n\tstruct sata_dwc_device *hsdev = hsdevp->hsdev;\n\tstruct device *dev = hsdev->dev;\n\n#ifdef CONFIG_SATA_DWC_OLD_DMA\n\tif (!of_property_present(dev->of_node, \"dmas\"))\n\t\treturn sata_dwc_dma_get_channel_old(hsdevp);\n#endif\n\n\thsdevp->chan = dma_request_chan(dev, \"sata-dma\");\n\tif (IS_ERR(hsdevp->chan)) {\n\t\tdev_err(dev, \"failed to allocate dma channel: %ld\\n\",\n\t\t\tPTR_ERR(hsdevp->chan));\n\t\treturn PTR_ERR(hsdevp->chan);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sata_dwc_port_start(struct ata_port *ap)\n{\n\tint err = 0;\n\tstruct sata_dwc_device *hsdev;\n\tstruct sata_dwc_device_port *hsdevp = NULL;\n\tstruct device *pdev;\n\tint i;\n\n\thsdev = HSDEV_FROM_AP(ap);\n\n\tdev_dbg(ap->dev, \"%s: port_no=%d\\n\", __func__, ap->port_no);\n\n\thsdev->host = ap->host;\n\tpdev = ap->host->dev;\n\tif (!pdev) {\n\t\tdev_err(ap->dev, \"%s: no ap->host->dev\\n\", __func__);\n\t\terr = -ENODEV;\n\t\tgoto CLEANUP;\n\t}\n\n\t \n\thsdevp = kzalloc(sizeof(*hsdevp), GFP_KERNEL);\n\tif (!hsdevp) {\n\t\terr = -ENOMEM;\n\t\tgoto CLEANUP;\n\t}\n\thsdevp->hsdev = hsdev;\n\n\terr = sata_dwc_dma_get_channel(hsdevp);\n\tif (err)\n\t\tgoto CLEANUP_ALLOC;\n\n\terr = phy_power_on(hsdev->phy);\n\tif (err)\n\t\tgoto CLEANUP_ALLOC;\n\n\tfor (i = 0; i < SATA_DWC_QCMD_MAX; i++)\n\t\thsdevp->cmd_issued[i] = SATA_DWC_CMD_ISSUED_NOT;\n\n\tap->bmdma_prd = NULL;\t \n\tap->bmdma_prd_dma = 0;\n\n\tif (ap->port_no == 0)  {\n\t\tdev_dbg(ap->dev, \"%s: clearing TXCHEN, RXCHEN in DMAC\\n\",\n\t\t\t__func__);\n\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\n\t\t\t\tSATA_DWC_DMACR_TXRXCH_CLEAR);\n\n\t\tdev_dbg(ap->dev, \"%s: setting burst size in DBTSR\\n\",\n\t\t\t __func__);\n\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dbtsr,\n\t\t\t\t(SATA_DWC_DBTSR_MWR(AHB_DMA_BRST_DFLT) |\n\t\t\t\t SATA_DWC_DBTSR_MRD(AHB_DMA_BRST_DFLT)));\n\t}\n\n\t \n\tclear_serror(ap);\n\tap->private_data = hsdevp;\n\tdev_dbg(ap->dev, \"%s: done\\n\", __func__);\n\treturn 0;\n\nCLEANUP_ALLOC:\n\tkfree(hsdevp);\nCLEANUP:\n\tdev_dbg(ap->dev, \"%s: fail. ap->id = %d\\n\", __func__, ap->print_id);\n\treturn err;\n}\n\nstatic void sata_dwc_port_stop(struct ata_port *ap)\n{\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\n\n\tdev_dbg(ap->dev, \"%s: ap->id = %d\\n\", __func__, ap->print_id);\n\n\tdmaengine_terminate_sync(hsdevp->chan);\n\tdma_release_channel(hsdevp->chan);\n\tphy_power_off(hsdev->phy);\n\n\tkfree(hsdevp);\n\tap->private_data = NULL;\n}\n\n \nstatic void sata_dwc_exec_command_by_tag(struct ata_port *ap,\n\t\t\t\t\t struct ata_taskfile *tf,\n\t\t\t\t\t u8 tag, u32 cmd_issued)\n{\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\n\thsdevp->cmd_issued[tag] = cmd_issued;\n\n\t \n\tclear_serror(ap);\n\tata_sff_exec_command(ap, tf);\n}\n\nstatic void sata_dwc_bmdma_setup_by_tag(struct ata_queued_cmd *qc, u8 tag)\n{\n\tsata_dwc_exec_command_by_tag(qc->ap, &qc->tf, tag,\n\t\t\t\t     SATA_DWC_CMD_ISSUED_PEND);\n}\n\nstatic void sata_dwc_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tu8 tag = qc->hw_tag;\n\n\tif (!ata_is_ncq(qc->tf.protocol))\n\t\ttag = 0;\n\n\tsata_dwc_bmdma_setup_by_tag(qc, tag);\n}\n\nstatic void sata_dwc_bmdma_start_by_tag(struct ata_queued_cmd *qc, u8 tag)\n{\n\tint start_dma;\n\tu32 reg;\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_QC(qc);\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\tstruct dma_async_tx_descriptor *desc = hsdevp->desc[tag];\n\tint dir = qc->dma_dir;\n\n\tif (hsdevp->cmd_issued[tag] != SATA_DWC_CMD_ISSUED_NOT) {\n\t\tstart_dma = 1;\n\t\tif (dir == DMA_TO_DEVICE)\n\t\t\thsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_TX;\n\t\telse\n\t\t\thsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_RX;\n\t} else {\n\t\tdev_err(ap->dev,\n\t\t\t\"%s: Command not pending cmd_issued=%d (tag=%d) DMA NOT started\\n\",\n\t\t\t__func__, hsdevp->cmd_issued[tag], tag);\n\t\tstart_dma = 0;\n\t}\n\n\tif (start_dma) {\n\t\tsata_dwc_scr_read(&ap->link, SCR_ERROR, &reg);\n\t\tif (reg & SATA_DWC_SERROR_ERR_BITS) {\n\t\t\tdev_err(ap->dev, \"%s: ****** SError=0x%08x ******\\n\",\n\t\t\t\t__func__, reg);\n\t\t}\n\n\t\tif (dir == DMA_TO_DEVICE)\n\t\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\n\t\t\t\t\tSATA_DWC_DMACR_TXCHEN);\n\t\telse\n\t\t\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\n\t\t\t\t\tSATA_DWC_DMACR_RXCHEN);\n\n\t\t \n\t\tdmaengine_submit(desc);\n\t\tdma_async_issue_pending(hsdevp->chan);\n\t}\n}\n\nstatic void sata_dwc_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tu8 tag = qc->hw_tag;\n\n\tif (!ata_is_ncq(qc->tf.protocol))\n\t\ttag = 0;\n\n\tsata_dwc_bmdma_start_by_tag(qc, tag);\n}\n\nstatic unsigned int sata_dwc_qc_issue(struct ata_queued_cmd *qc)\n{\n\tu32 sactive;\n\tu8 tag = qc->hw_tag;\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\n\n\tif (!ata_is_ncq(qc->tf.protocol))\n\t\ttag = 0;\n\n\tif (ata_is_dma(qc->tf.protocol)) {\n\t\thsdevp->desc[tag] = dma_dwc_xfer_setup(qc);\n\t\tif (!hsdevp->desc[tag])\n\t\t\treturn AC_ERR_SYSTEM;\n\t} else {\n\t\thsdevp->desc[tag] = NULL;\n\t}\n\n\tif (ata_is_ncq(qc->tf.protocol)) {\n\t\tsata_dwc_scr_read(&ap->link, SCR_ACTIVE, &sactive);\n\t\tsactive |= (0x00000001 << tag);\n\t\tsata_dwc_scr_write(&ap->link, SCR_ACTIVE, sactive);\n\n\t\ttrace_ata_tf_load(ap, &qc->tf);\n\t\tap->ops->sff_tf_load(ap, &qc->tf);\n\t\ttrace_ata_exec_command(ap, &qc->tf, tag);\n\t\tsata_dwc_exec_command_by_tag(ap, &qc->tf, tag,\n\t\t\t\t\t     SATA_DWC_CMD_ISSUED_PEND);\n\t} else {\n\t\treturn ata_bmdma_qc_issue(qc);\n\t}\n\treturn 0;\n}\n\nstatic void sata_dwc_error_handler(struct ata_port *ap)\n{\n\tata_sff_error_handler(ap);\n}\n\nstatic int sata_dwc_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(link->ap);\n\tint ret;\n\n\tret = sata_sff_hardreset(link, class, deadline);\n\n\tsata_dwc_enable_interrupts(hsdev);\n\n\t \n\tsata_dwc_writel(&hsdev->sata_dwc_regs->dmacr,\n\t\t\tSATA_DWC_DMACR_TXRXCH_CLEAR);\n\n\t \n\tsata_dwc_writel(&hsdev->sata_dwc_regs->dbtsr,\n\t\t\tSATA_DWC_DBTSR_MWR(AHB_DMA_BRST_DFLT) |\n\t\t\tSATA_DWC_DBTSR_MRD(AHB_DMA_BRST_DFLT));\n\n\treturn ret;\n}\n\nstatic void sata_dwc_dev_select(struct ata_port *ap, unsigned int device)\n{\n\t \n}\n\n \nstatic const struct scsi_host_template sata_dwc_sht = {\n\tATA_NCQ_SHT(DRV_NAME),\n\t \n\t.sg_tablesize\t\t= LIBATA_MAX_PRD,\n\t \n\t \n\t.dma_boundary\t\t= 0x1fff  ,\n};\n\nstatic struct ata_port_operations sata_dwc_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\n\t.error_handler\t\t= sata_dwc_error_handler,\n\t.hardreset\t\t= sata_dwc_hardreset,\n\n\t.qc_issue\t\t= sata_dwc_qc_issue,\n\n\t.scr_read\t\t= sata_dwc_scr_read,\n\t.scr_write\t\t= sata_dwc_scr_write,\n\n\t.port_start\t\t= sata_dwc_port_start,\n\t.port_stop\t\t= sata_dwc_port_stop,\n\n\t.sff_dev_select\t\t= sata_dwc_dev_select,\n\n\t.bmdma_setup\t\t= sata_dwc_bmdma_setup,\n\t.bmdma_start\t\t= sata_dwc_bmdma_start,\n};\n\nstatic const struct ata_port_info sata_dwc_port_info[] = {\n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA | ATA_FLAG_NCQ,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &sata_dwc_ops,\n\t},\n};\n\nstatic int sata_dwc_probe(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sata_dwc_device *hsdev;\n\tu32 idr, versionr;\n\tchar *ver = (char *)&versionr;\n\tvoid __iomem *base;\n\tint err = 0;\n\tint irq;\n\tstruct ata_host *host;\n\tstruct ata_port_info pi = sata_dwc_port_info[0];\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct resource *res;\n\n\t \n\thost = ata_host_alloc_pinfo(dev, ppi, SATA_DWC_MAX_PORTS);\n\thsdev = devm_kzalloc(dev, sizeof(*hsdev), GFP_KERNEL);\n\tif (!host || !hsdev)\n\t\treturn -ENOMEM;\n\n\thost->private_data = hsdev;\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(ofdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tdev_dbg(dev, \"ioremap done for SATA register address\\n\");\n\n\t \n\thsdev->sata_dwc_regs = base + SATA_DWC_REG_OFFSET;\n\thsdev->dmadr = res->start + SATA_DWC_REG_OFFSET + offsetof(struct sata_dwc_regs, dmadr);\n\n\t \n\thost->ports[0]->ioaddr.cmd_addr = base;\n\thost->ports[0]->ioaddr.scr_addr = base + SATA_DWC_SCR_OFFSET;\n\tsata_dwc_setup_port(&host->ports[0]->ioaddr, base);\n\n\t \n\tidr = sata_dwc_readl(&hsdev->sata_dwc_regs->idr);\n\tversionr = sata_dwc_readl(&hsdev->sata_dwc_regs->versionr);\n\tdev_notice(dev, \"id %d, controller version %c.%c%c\\n\", idr, ver[0], ver[1], ver[2]);\n\n\t \n\thsdev->dev = dev;\n\n\t \n\tsata_dwc_enable_interrupts(hsdev);\n\n\t \n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"no SATA DMA irq\\n\");\n\t\treturn -ENODEV;\n\t}\n\n#ifdef CONFIG_SATA_DWC_OLD_DMA\n\tif (!of_property_present(np, \"dmas\")) {\n\t\terr = sata_dwc_dma_init_old(ofdev, hsdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n\n\thsdev->phy = devm_phy_optional_get(dev, \"sata-phy\");\n\tif (IS_ERR(hsdev->phy))\n\t\treturn PTR_ERR(hsdev->phy);\n\n\terr = phy_init(hsdev->phy);\n\tif (err)\n\t\tgoto error_out;\n\n\t \n\terr = ata_host_activate(host, irq, sata_dwc_isr, 0, &sata_dwc_sht);\n\tif (err)\n\t\tdev_err(dev, \"failed to activate host\");\n\n\treturn 0;\n\nerror_out:\n\tphy_exit(hsdev->phy);\n\treturn err;\n}\n\nstatic void sata_dwc_remove(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct sata_dwc_device *hsdev = host->private_data;\n\n\tata_host_detach(host);\n\n\tphy_exit(hsdev->phy);\n\n#ifdef CONFIG_SATA_DWC_OLD_DMA\n\t \n\tsata_dwc_dma_exit_old(hsdev);\n#endif\n\n\tdev_dbg(dev, \"done\\n\");\n}\n\nstatic const struct of_device_id sata_dwc_match[] = {\n\t{ .compatible = \"amcc,sata-460ex\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sata_dwc_match);\n\nstatic struct platform_driver sata_dwc_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = sata_dwc_match,\n\t},\n\t.probe = sata_dwc_probe,\n\t.remove_new = sata_dwc_remove,\n};\n\nmodule_platform_driver(sata_dwc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mark Miesfeld <mmiesfeld@amcc.com>\");\nMODULE_DESCRIPTION(\"DesignWare Cores SATA controller low level driver\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}