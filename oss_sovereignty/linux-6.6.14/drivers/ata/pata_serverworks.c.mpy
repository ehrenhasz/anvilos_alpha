{
  "module_name": "pata_serverworks.c",
  "hash_id": "28c735c22f7f9f6910f00380a08752ff80f8bc670a89e90aa536b5b183c80e83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_serverworks.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_serverworks\"\n#define DRV_VERSION \"0.4.3\"\n\n#define SVWKS_CSB5_REVISION_NEW\t0x92  \n#define SVWKS_CSB6_REVISION\t0xa0  \n\n \n\nstatic const char *csb_bad_ata100[] = {\n\t\"ST320011A\",\n\t\"ST340016A\",\n\t\"ST360021A\",\n\t\"ST380021A\",\n\tNULL\n};\n\n \n\nstatic int oem_cable(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tif (pdev->subsystem_device & (1 << (ap->port_no + 14)))\n\t\treturn ATA_CBL_PATA80;\n\treturn ATA_CBL_PATA40;\n}\n\nstruct sv_cable_table {\n\tint device;\n\tint subvendor;\n\tint (*cable_detect)(struct ata_port *ap);\n};\n\nstatic struct sv_cable_table cable_detect[] = {\n\t{ PCI_DEVICE_ID_SERVERWORKS_CSB5IDE,   PCI_VENDOR_ID_DELL, oem_cable },\n\t{ PCI_DEVICE_ID_SERVERWORKS_CSB6IDE,   PCI_VENDOR_ID_DELL, oem_cable },\n\t{ PCI_DEVICE_ID_SERVERWORKS_CSB5IDE,   PCI_VENDOR_ID_SUN,  oem_cable },\n\t{ PCI_DEVICE_ID_SERVERWORKS_OSB4IDE,   PCI_ANY_ID, ata_cable_40wire  },\n\t{ PCI_DEVICE_ID_SERVERWORKS_CSB5IDE,   PCI_ANY_ID, ata_cable_unknown },\n\t{ PCI_DEVICE_ID_SERVERWORKS_CSB6IDE,   PCI_ANY_ID, ata_cable_unknown },\n\t{ PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2,  PCI_ANY_ID, ata_cable_unknown },\n\t{ PCI_DEVICE_ID_SERVERWORKS_HT1000IDE, PCI_ANY_ID, ata_cable_unknown },\n\t{ }\n};\n\n \n\nstatic int serverworks_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct sv_cable_table *cb = cable_detect;\n\n\twhile(cb->device) {\n\t\tif (cb->device == pdev->device &&\n\t\t    (cb->subvendor == pdev->subsystem_vendor ||\n\t\t      cb->subvendor == PCI_ANY_ID)) {\n\t\t\treturn cb->cable_detect(ap);\n\t\t}\n\t\tcb++;\n\t}\n\n\tBUG();\n\treturn -1;\t \n}\n\n \n\nstatic u8 serverworks_is_csb(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\t\tcase PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:\n\t\tcase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:\n\t\tcase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:\n\t\tcase PCI_DEVICE_ID_SERVERWORKS_HT1000IDE:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \n\nstatic unsigned int serverworks_osb4_filter(struct ata_device *adev, unsigned int mask)\n{\n\tif (adev->class == ATA_DEV_ATA)\n\t\tmask &= ~ATA_MASK_UDMA;\n\treturn mask;\n}\n\n\n \n\nstatic unsigned int serverworks_csb_filter(struct ata_device *adev, unsigned int mask)\n{\n\tconst char *p;\n\tchar model_num[ATA_ID_PROD_LEN + 1];\n\tint i;\n\n\t \n\tif (adev->class != ATA_DEV_ATA)\n\t\treturn mask;\n\n\t \n\tata_id_c_string(adev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\n\tfor (i = 0; (p = csb_bad_ata100[i]) != NULL; i++) {\n\t\tif (!strcmp(p, model_num))\n\t\t\tmask &= ~(0xE0 << ATA_SHIFT_UDMA);\n\t}\n\treturn mask;\n}\n\n \nstatic void serverworks_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 pio_mode[] = { 0x5d, 0x47, 0x34, 0x22, 0x20 };\n\tint offset = 1 + 2 * ap->port_no - adev->devno;\n\tint devbits = (2 * ap->port_no + adev->devno) * 4;\n\tu16 csb5_pio;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint pio = adev->pio_mode - XFER_PIO_0;\n\n\tpci_write_config_byte(pdev, 0x40 + offset, pio_mode[pio]);\n\n\t \n\tif (serverworks_is_csb(pdev)) {\n\t\tpci_read_config_word(pdev, 0x4A, &csb5_pio);\n\t\tcsb5_pio &= ~(0x0F << devbits);\n\t\tpci_write_config_word(pdev, 0x4A, csb5_pio | (pio << devbits));\n\t}\n}\n\n \n\nstatic void serverworks_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 dma_mode[] = { 0x77, 0x21, 0x20 };\n\tint offset = 1 + 2 * ap->port_no - adev->devno;\n\tint devbits = 2 * ap->port_no + adev->devno;\n\tu8 ultra;\n\tu8 ultra_cfg;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tpci_read_config_byte(pdev, 0x54, &ultra_cfg);\n\tpci_read_config_byte(pdev, 0x56 + ap->port_no, &ultra);\n\tultra &= ~(0x0F << (adev->devno * 4));\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tpci_write_config_byte(pdev, 0x44 + offset,  0x20);\n\n\t\tultra |= (adev->dma_mode - XFER_UDMA_0)\n\t\t\t\t\t<< (adev->devno * 4);\n\t\tultra_cfg |=  (1 << devbits);\n\t} else {\n\t\tpci_write_config_byte(pdev, 0x44 + offset,\n\t\t\tdma_mode[adev->dma_mode - XFER_MW_DMA_0]);\n\t\tultra_cfg &= ~(1 << devbits);\n\t}\n\tpci_write_config_byte(pdev, 0x56 + ap->port_no, ultra);\n\tpci_write_config_byte(pdev, 0x54, ultra_cfg);\n}\n\nstatic const struct scsi_host_template serverworks_osb4_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t= LIBATA_DUMB_MAX_PRD,\n\t.dma_boundary\t= ATA_DMA_BOUNDARY,\n};\n\nstatic const struct scsi_host_template serverworks_csb_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations serverworks_osb4_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.qc_prep\t= ata_bmdma_dumb_qc_prep,\n\t.cable_detect\t= serverworks_cable_detect,\n\t.mode_filter\t= serverworks_osb4_filter,\n\t.set_piomode\t= serverworks_set_piomode,\n\t.set_dmamode\t= serverworks_set_dmamode,\n};\n\nstatic struct ata_port_operations serverworks_csb_port_ops = {\n\t.inherits\t= &serverworks_osb4_port_ops,\n\t.qc_prep\t= ata_bmdma_qc_prep,\n\t.mode_filter\t= serverworks_csb_filter,\n};\n\nstatic int serverworks_fixup_osb4(struct pci_dev *pdev)\n{\n\tu32 reg;\n\tstruct pci_dev *isa_dev = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\n\t\t  PCI_DEVICE_ID_SERVERWORKS_OSB4, NULL);\n\tif (isa_dev) {\n\t\tpci_read_config_dword(isa_dev, 0x64, &reg);\n\t\treg &= ~0x00002000;  \n\t\tif (!(reg & 0x00004000))\n\t\t\tdev_info(&pdev->dev, \"UDMA not BIOS enabled.\\n\");\n\t\treg |=  0x00004000;  \n\t\tpci_write_config_dword(isa_dev, 0x64, reg);\n\t\tpci_dev_put(isa_dev);\n\t\treturn 0;\n\t}\n\tdev_warn(&pdev->dev, \"Unable to find bridge.\\n\");\n\treturn -ENODEV;\n}\n\nstatic int serverworks_fixup_csb(struct pci_dev *pdev)\n{\n\tu8 btr;\n\n\t \n\tif (!(PCI_FUNC(pdev->devfn) & 1)) {\n\t\tstruct pci_dev * findev = NULL;\n\t\tu32 reg4c = 0;\n\t\tfindev = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\n\t\t\tPCI_DEVICE_ID_SERVERWORKS_CSB5, NULL);\n\t\tif (findev) {\n\t\t\tpci_read_config_dword(findev, 0x4C, &reg4c);\n\t\t\treg4c &= ~0x000007FF;\n\t\t\treg4c |=  0x00000040;\n\t\t\treg4c |=  0x00000020;\n\t\t\tpci_write_config_dword(findev, 0x4C, reg4c);\n\t\t\tpci_dev_put(findev);\n\t\t}\n\t} else {\n\t\tstruct pci_dev * findev = NULL;\n\t\tu8 reg41 = 0;\n\n\t\tfindev = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\n\t\t\t\tPCI_DEVICE_ID_SERVERWORKS_CSB6, NULL);\n\t\tif (findev) {\n\t\t\tpci_read_config_byte(findev, 0x41, &reg41);\n\t\t\treg41 &= ~0x40;\n\t\t\tpci_write_config_byte(findev, 0x41, reg41);\n\t\t\tpci_dev_put(findev);\n\t\t}\n\t}\n\t \n\tpci_read_config_byte(pdev, 0x5A, &btr);\n\tbtr &= ~0x40;\n\tif (!(PCI_FUNC(pdev->devfn) & 1))\n\t\tbtr |= 0x2;\n\telse\n\t\tbtr |= (pdev->revision >= SVWKS_CSB5_REVISION_NEW) ? 0x3 : 0x2;\n\tpci_write_config_byte(pdev, 0x5A, btr);\n\n\treturn btr;\n}\n\nstatic void serverworks_fixup_ht1000(struct pci_dev *pdev)\n{\n\tu8 btr;\n\t \n\tpci_read_config_byte(pdev, 0x5A, &btr);\n\tbtr &= ~0x40;\n\tbtr |= 0x3;\n\tpci_write_config_byte(pdev, 0x5A, btr);\n}\n\nstatic int serverworks_fixup(struct pci_dev *pdev)\n{\n\tint rc = 0;\n\n\t \n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x40);\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_SERVERWORKS_OSB4IDE:\n\t\trc = serverworks_fixup_osb4(pdev);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:\n\t\tata_pci_bmdma_clear_simplex(pdev);\n\t\tfallthrough;\n\tcase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:\n\tcase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:\n\t\trc = serverworks_fixup_csb(pdev);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_SERVERWORKS_HT1000IDE:\n\t\tserverworks_fixup_ht1000(pdev);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int serverworks_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info[4] = {\n\t\t{  \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA2,\n\t\t\t.port_ops = &serverworks_osb4_port_ops\n\t\t}, {  \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t \n\t\t\t.port_ops = &serverworks_osb4_port_ops\n\t\t}, {  \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA4,\n\t\t\t.port_ops = &serverworks_csb_port_ops\n\t\t}, {  \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA5,\n\t\t\t.port_ops = &serverworks_csb_port_ops\n\t\t}\n\t};\n\tconst struct ata_port_info *ppi[] = { &info[id->driver_data], NULL };\n\tconst struct scsi_host_template *sht = &serverworks_csb_sht;\n\tint rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = serverworks_fixup(pdev);\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_SERVERWORKS_OSB4IDE) {\n\t\t \n\t\tif (rc < 0)\n\t\t\tppi[0] = &info[1];\n\t\tsht = &serverworks_osb4_sht;\n\t}\n\t \n\telse if ((pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB5IDE) ||\n\t\t (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE) ||\n\t\t (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)) {\n\n\t\t  \n\t\t if (rc == 3)\n\t\t \tppi[0] = &info[3];\n\n\t\t \n\t\tif (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)\n\t\t\tppi[1] = &ata_dummy_port_info;\n\t}\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int serverworks_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t(void)serverworks_fixup(pdev);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id serverworks[] = {\n\t{ PCI_VDEVICE(SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_OSB4IDE), 0},\n\t{ PCI_VDEVICE(SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB5IDE), 2},\n\t{ PCI_VDEVICE(SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB6IDE), 2},\n\t{ PCI_VDEVICE(SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2), 2},\n\t{ PCI_VDEVICE(SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_HT1000IDE), 2},\n\n\t{ },\n};\n\nstatic struct pci_driver serverworks_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= serverworks,\n\t.probe \t\t= serverworks_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= serverworks_reinit_one,\n#endif\n};\n\nmodule_pci_driver(serverworks_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Serverworks OSB4/CSB5/CSB6\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, serverworks);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}