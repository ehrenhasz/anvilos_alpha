{
  "module_name": "libahci_platform.c",
  "hash_id": "a371cb2009f5e8d8989a7a044bd7618b6e4319ce4f7b5432c019f65dfb597345",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libahci_platform.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/libata.h>\n#include <linux/ahci_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/reset.h>\n#include \"ahci.h\"\n\nstatic void ahci_host_stop(struct ata_host *host);\n\nstruct ata_port_operations ahci_platform_ops = {\n\t.inherits\t= &ahci_ops,\n\t.host_stop\t= ahci_host_stop,\n};\nEXPORT_SYMBOL_GPL(ahci_platform_ops);\n\n \nint ahci_platform_enable_phys(struct ahci_host_priv *hpriv)\n{\n\tint rc, i;\n\n\tfor (i = 0; i < hpriv->nports; i++) {\n\t\trc = phy_init(hpriv->phys[i]);\n\t\tif (rc)\n\t\t\tgoto disable_phys;\n\n\t\trc = phy_set_mode(hpriv->phys[i], PHY_MODE_SATA);\n\t\tif (rc) {\n\t\t\tphy_exit(hpriv->phys[i]);\n\t\t\tgoto disable_phys;\n\t\t}\n\n\t\trc = phy_power_on(hpriv->phys[i]);\n\t\tif (rc) {\n\t\t\tphy_exit(hpriv->phys[i]);\n\t\t\tgoto disable_phys;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_phys:\n\twhile (--i >= 0) {\n\t\tphy_power_off(hpriv->phys[i]);\n\t\tphy_exit(hpriv->phys[i]);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_enable_phys);\n\n \nvoid ahci_platform_disable_phys(struct ahci_host_priv *hpriv)\n{\n\tint i;\n\n\tfor (i = 0; i < hpriv->nports; i++) {\n\t\tphy_power_off(hpriv->phys[i]);\n\t\tphy_exit(hpriv->phys[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(ahci_platform_disable_phys);\n\n \nstruct clk *ahci_platform_find_clk(struct ahci_host_priv *hpriv, const char *con_id)\n{\n\tint i;\n\n\tfor (i = 0; i < hpriv->n_clks; i++) {\n\t\tif (hpriv->clks[i].id && !strcmp(hpriv->clks[i].id, con_id))\n\t\t\treturn hpriv->clks[i].clk;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_find_clk);\n\n \nint ahci_platform_enable_clks(struct ahci_host_priv *hpriv)\n{\n\treturn clk_bulk_prepare_enable(hpriv->n_clks, hpriv->clks);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_enable_clks);\n\n \nvoid ahci_platform_disable_clks(struct ahci_host_priv *hpriv)\n{\n\tclk_bulk_disable_unprepare(hpriv->n_clks, hpriv->clks);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_disable_clks);\n\n \nint ahci_platform_deassert_rsts(struct ahci_host_priv *hpriv)\n{\n\tif (hpriv->f_rsts & AHCI_PLATFORM_RST_TRIGGER)\n\t\treturn reset_control_reset(hpriv->rsts);\n\n\treturn reset_control_deassert(hpriv->rsts);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_deassert_rsts);\n\n \nint ahci_platform_assert_rsts(struct ahci_host_priv *hpriv)\n{\n\tif (hpriv->f_rsts & AHCI_PLATFORM_RST_TRIGGER)\n\t\treturn reset_control_rearm(hpriv->rsts);\n\n\treturn reset_control_assert(hpriv->rsts);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_assert_rsts);\n\n \nint ahci_platform_enable_regulators(struct ahci_host_priv *hpriv)\n{\n\tint rc, i;\n\n\trc = regulator_enable(hpriv->ahci_regulator);\n\tif (rc)\n\t\treturn rc;\n\n\trc = regulator_enable(hpriv->phy_regulator);\n\tif (rc)\n\t\tgoto disable_ahci_pwrs;\n\n\tfor (i = 0; i < hpriv->nports; i++) {\n\t\tif (!hpriv->target_pwrs[i])\n\t\t\tcontinue;\n\n\t\trc = regulator_enable(hpriv->target_pwrs[i]);\n\t\tif (rc)\n\t\t\tgoto disable_target_pwrs;\n\t}\n\n\treturn 0;\n\ndisable_target_pwrs:\n\twhile (--i >= 0)\n\t\tif (hpriv->target_pwrs[i])\n\t\t\tregulator_disable(hpriv->target_pwrs[i]);\n\n\tregulator_disable(hpriv->phy_regulator);\ndisable_ahci_pwrs:\n\tregulator_disable(hpriv->ahci_regulator);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_enable_regulators);\n\n \nvoid ahci_platform_disable_regulators(struct ahci_host_priv *hpriv)\n{\n\tint i;\n\n\tfor (i = 0; i < hpriv->nports; i++) {\n\t\tif (!hpriv->target_pwrs[i])\n\t\t\tcontinue;\n\t\tregulator_disable(hpriv->target_pwrs[i]);\n\t}\n\n\tregulator_disable(hpriv->ahci_regulator);\n\tregulator_disable(hpriv->phy_regulator);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_disable_regulators);\n \nint ahci_platform_enable_resources(struct ahci_host_priv *hpriv)\n{\n\tint rc;\n\n\trc = ahci_platform_enable_regulators(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_platform_enable_clks(hpriv);\n\tif (rc)\n\t\tgoto disable_regulator;\n\n\trc = ahci_platform_deassert_rsts(hpriv);\n\tif (rc)\n\t\tgoto disable_clks;\n\n\trc = ahci_platform_enable_phys(hpriv);\n\tif (rc)\n\t\tgoto disable_rsts;\n\n\treturn 0;\n\ndisable_rsts:\n\tahci_platform_assert_rsts(hpriv);\n\ndisable_clks:\n\tahci_platform_disable_clks(hpriv);\n\ndisable_regulator:\n\tahci_platform_disable_regulators(hpriv);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_enable_resources);\n\n \nvoid ahci_platform_disable_resources(struct ahci_host_priv *hpriv)\n{\n\tahci_platform_disable_phys(hpriv);\n\n\tahci_platform_assert_rsts(hpriv);\n\n\tahci_platform_disable_clks(hpriv);\n\n\tahci_platform_disable_regulators(hpriv);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_disable_resources);\n\nstatic void ahci_platform_put_resources(struct device *dev, void *res)\n{\n\tstruct ahci_host_priv *hpriv = res;\n\tint c;\n\n\tif (hpriv->got_runtime_pm) {\n\t\tpm_runtime_put_sync(dev);\n\t\tpm_runtime_disable(dev);\n\t}\n\n\t \n\tfor (c = 0; c < hpriv->nports; c++)\n\t\tif (hpriv->target_pwrs && hpriv->target_pwrs[c])\n\t\t\tregulator_put(hpriv->target_pwrs[c]);\n\n\tkfree(hpriv->target_pwrs);\n}\n\nstatic int ahci_platform_get_phy(struct ahci_host_priv *hpriv, u32 port,\n\t\t\t\tstruct device *dev, struct device_node *node)\n{\n\tint rc;\n\n\thpriv->phys[port] = devm_of_phy_get(dev, node, NULL);\n\n\tif (!IS_ERR(hpriv->phys[port]))\n\t\treturn 0;\n\n\trc = PTR_ERR(hpriv->phys[port]);\n\tswitch (rc) {\n\tcase -ENOSYS:\n\t\t \n\t\tif (of_property_present(node, \"phys\")) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"couldn't get PHY in node %pOFn: ENOSYS\\n\",\n\t\t\t\tnode);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase -ENODEV:\n\t\t \n\t\thpriv->phys[port] = NULL;\n\t\trc = 0;\n\t\tbreak;\n\tcase -EPROBE_DEFER:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev,\n\t\t\t\"couldn't get PHY in node %pOFn: %d\\n\",\n\t\t\tnode, rc);\n\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int ahci_platform_get_regulator(struct ahci_host_priv *hpriv, u32 port,\n\t\t\t\tstruct device *dev)\n{\n\tstruct regulator *target_pwr;\n\tint rc = 0;\n\n\ttarget_pwr = regulator_get(dev, \"target\");\n\n\tif (!IS_ERR(target_pwr))\n\t\thpriv->target_pwrs[port] = target_pwr;\n\telse\n\t\trc = PTR_ERR(target_pwr);\n\n\treturn rc;\n}\n\nstatic int ahci_platform_get_firmware(struct ahci_host_priv *hpriv,\n\t\t\t\t      struct device *dev)\n{\n\tstruct device_node *child;\n\tu32 port;\n\n\tif (!of_property_read_u32(dev->of_node, \"hba-cap\", &hpriv->saved_cap))\n\t\thpriv->saved_cap &= (HOST_CAP_SSS | HOST_CAP_MPS);\n\n\tof_property_read_u32(dev->of_node,\n\t\t\t     \"ports-implemented\", &hpriv->saved_port_map);\n\n\tfor_each_child_of_node(dev->of_node, child) {\n\t\tif (!of_device_is_available(child))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(child, \"reg\", &port)) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!of_property_read_u32(child, \"hba-port-cap\", &hpriv->saved_port_cap[port]))\n\t\t\thpriv->saved_port_cap[port] &= PORT_CMD_CAP;\n\t}\n\n\treturn 0;\n}\n\n \nstruct ahci_host_priv *ahci_platform_get_resources(struct platform_device *pdev,\n\t\t\t\t\t\t   unsigned int flags)\n{\n\tint child_nodes, rc = -ENOMEM, enabled_ports = 0;\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct device_node *child;\n\tu32 mask_port_map = 0;\n\n\tif (!devres_open_group(dev, NULL, GFP_KERNEL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thpriv = devres_alloc(ahci_platform_put_resources, sizeof(*hpriv),\n\t\t\t     GFP_KERNEL);\n\tif (!hpriv)\n\t\tgoto err_out;\n\n\tdevres_add(dev, hpriv);\n\n\t \n\tif (platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ahci\"))\n\t\thpriv->mmio = devm_platform_ioremap_resource_byname(pdev, \"ahci\");\n\telse\n\t\thpriv->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hpriv->mmio)) {\n\t\trc = PTR_ERR(hpriv->mmio);\n\t\tgoto err_out;\n\t}\n\n\t \n\trc = devm_clk_bulk_get_all(dev, &hpriv->clks);\n\tif (rc < 0)\n\t\tgoto err_out;\n\n\tif (rc > 0) {\n\t\t \n\t\thpriv->n_clks = rc;\n\t} else {\n\t\t \n\t\thpriv->clks = devm_kzalloc(dev, sizeof(*hpriv->clks), GFP_KERNEL);\n\t\tif (!hpriv->clks) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\thpriv->clks->clk = devm_clk_get_optional(dev, NULL);\n\t\tif (IS_ERR(hpriv->clks->clk)) {\n\t\t\trc = PTR_ERR(hpriv->clks->clk);\n\t\t\tgoto err_out;\n\t\t} else if (hpriv->clks->clk) {\n\t\t\thpriv->clks->id = \"ahci\";\n\t\t\thpriv->n_clks = 1;\n\t\t}\n\t}\n\n\thpriv->ahci_regulator = devm_regulator_get(dev, \"ahci\");\n\tif (IS_ERR(hpriv->ahci_regulator)) {\n\t\trc = PTR_ERR(hpriv->ahci_regulator);\n\t\tif (rc != 0)\n\t\t\tgoto err_out;\n\t}\n\n\thpriv->phy_regulator = devm_regulator_get(dev, \"phy\");\n\tif (IS_ERR(hpriv->phy_regulator)) {\n\t\trc = PTR_ERR(hpriv->phy_regulator);\n\t\tgoto err_out;\n\t}\n\n\tif (flags & AHCI_PLATFORM_GET_RESETS) {\n\t\thpriv->rsts = devm_reset_control_array_get_optional_shared(dev);\n\t\tif (IS_ERR(hpriv->rsts)) {\n\t\t\trc = PTR_ERR(hpriv->rsts);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\thpriv->f_rsts = flags & AHCI_PLATFORM_RST_TRIGGER;\n\t}\n\n\t \n\tchild_nodes = of_get_child_count(dev->of_node);\n\tif (child_nodes > AHCI_MAX_PORTS) {\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (child_nodes)\n\t\thpriv->nports = child_nodes;\n\telse\n\t\thpriv->nports = 1;\n\n\thpriv->phys = devm_kcalloc(dev, hpriv->nports, sizeof(*hpriv->phys), GFP_KERNEL);\n\tif (!hpriv->phys) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t \n\thpriv->target_pwrs = kcalloc(hpriv->nports, sizeof(*hpriv->target_pwrs), GFP_KERNEL);\n\tif (!hpriv->target_pwrs) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tif (child_nodes) {\n\t\tfor_each_child_of_node(dev->of_node, child) {\n\t\t\tu32 port;\n\t\t\tstruct platform_device *port_dev __maybe_unused;\n\n\t\t\tif (!of_device_is_available(child))\n\t\t\t\tcontinue;\n\n\t\t\tif (of_property_read_u32(child, \"reg\", &port)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tof_node_put(child);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (port >= hpriv->nports) {\n\t\t\t\tdev_warn(dev, \"invalid port number %d\\n\", port);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmask_port_map |= BIT(port);\n\n#ifdef CONFIG_OF_ADDRESS\n\t\t\tof_platform_device_create(child, NULL, NULL);\n\n\t\t\tport_dev = of_find_device_by_node(child);\n\n\t\t\tif (port_dev) {\n\t\t\t\trc = ahci_platform_get_regulator(hpriv, port,\n\t\t\t\t\t\t\t\t&port_dev->dev);\n\t\t\t\tif (rc == -EPROBE_DEFER) {\n\t\t\t\t\tof_node_put(child);\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\trc = ahci_platform_get_phy(hpriv, port, dev, child);\n\t\t\tif (rc) {\n\t\t\t\tof_node_put(child);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tenabled_ports++;\n\t\t}\n\t\tif (!enabled_ports) {\n\t\t\tdev_warn(dev, \"No port enabled\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!hpriv->mask_port_map)\n\t\t\thpriv->mask_port_map = mask_port_map;\n\t} else {\n\t\t \n\t\trc = ahci_platform_get_phy(hpriv, 0, dev, dev->of_node);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\n\t\trc = ahci_platform_get_regulator(hpriv, 0, dev);\n\t\tif (rc == -EPROBE_DEFER)\n\t\t\tgoto err_out;\n\t}\n\n\t \n\trc = ahci_platform_get_firmware(hpriv, dev);\n\tif (rc)\n\t\tgoto err_out;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\thpriv->got_runtime_pm = true;\n\n\tdevres_remove_group(dev, NULL);\n\treturn hpriv;\n\nerr_out:\n\tdevres_release_group(dev, NULL);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_get_resources);\n\n \nint ahci_platform_init_host(struct platform_device *pdev,\n\t\t\t    struct ahci_host_priv *hpriv,\n\t\t\t    const struct ata_port_info *pi_template,\n\t\t\t    const struct scsi_host_template *sht)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ata_port_info pi = *pi_template;\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct ata_host *host;\n\tint i, irq, n_ports, rc;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\thpriv->irq = irq;\n\n\t \n\tpi.private_data = (void *)(unsigned long)hpriv->flags;\n\n\tahci_save_initial_config(dev, hpriv);\n\n\tif (hpriv->cap & HOST_CAP_NCQ)\n\t\tpi.flags |= ATA_FLAG_NCQ;\n\n\tif (hpriv->cap & HOST_CAP_PMP)\n\t\tpi.flags |= ATA_FLAG_PMP;\n\n\tahci_set_em_messages(hpriv, &pi);\n\n\t \n\tn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\n\n\thost = ata_host_alloc_pinfo(dev, ppi, n_ports);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->private_data = hpriv;\n\n\tif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\n\t\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n\telse\n\t\tdev_info(dev, \"SSS flag set, parallel bus scan disabled\\n\");\n\n\tif (pi.flags & ATA_FLAG_EM)\n\t\tahci_reset_em(host);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tata_port_desc(ap, \"mmio %pR\",\n\t\t\t      platform_get_resource(pdev, IORESOURCE_MEM, 0));\n\t\tata_port_desc(ap, \"port 0x%x\", 0x100 + ap->port_no * 0x80);\n\n\t\t \n\t\tif (ap->flags & ATA_FLAG_EM)\n\t\t\tap->em_message_type = hpriv->em_msg_type;\n\n\t\t \n\t\tif (!(hpriv->port_map & (1 << i)))\n\t\t\tap->ops = &ata_dummy_port_ops;\n\t}\n\n\tif (hpriv->cap & HOST_CAP_64) {\n\t\trc = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Failed to enable 64-bit DMA.\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ahci_reset_controller(host);\n\tif (rc)\n\t\treturn rc;\n\n\tahci_init_controller(host);\n\tahci_print_info(host, \"platform\");\n\n\treturn ahci_host_activate(host, sht);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_init_host);\n\nstatic void ahci_host_stop(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\tahci_platform_disable_resources(hpriv);\n}\n\n \nvoid ahci_platform_shutdown(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tint i;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\t \n\t\tif (ap->ops->freeze)\n\t\t\tap->ops->freeze(ap);\n\n\t\t \n\t\tif (ap->ops->port_stop)\n\t\t\tap->ops->port_stop(ap);\n\t}\n\n\t \n\twritel(readl(mmio + HOST_CTL) & ~HOST_IRQ_EN, mmio + HOST_CTL);\n\treadl(mmio + HOST_CTL);  \n\twritel(GENMASK(host->n_ports, 0), mmio + HOST_IRQ_STAT);\n}\nEXPORT_SYMBOL_GPL(ahci_platform_shutdown);\n\n#ifdef CONFIG_PM_SLEEP\n \nint ahci_platform_suspend_host(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 ctl;\n\n\tif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\n\t\tdev_err(dev, \"firmware update required for suspend/resume\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tctl = readl(mmio + HOST_CTL);\n\tctl &= ~HOST_IRQ_EN;\n\twritel(ctl, mmio + HOST_CTL);\n\treadl(mmio + HOST_CTL);  \n\n\tif (hpriv->flags & AHCI_HFLAG_SUSPEND_PHYS)\n\t\tahci_platform_disable_phys(hpriv);\n\n\tata_host_suspend(host, PMSG_SUSPEND);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_suspend_host);\n\n \nint ahci_platform_resume_host(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\tif (dev->power.power_state.event == PM_EVENT_SUSPEND) {\n\t\trc = ahci_reset_controller(host);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tahci_init_controller(host);\n\t}\n\n\tif (hpriv->flags & AHCI_HFLAG_SUSPEND_PHYS)\n\t\tahci_platform_enable_phys(hpriv);\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_resume_host);\n\n \nint ahci_platform_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_platform_suspend_host(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tahci_platform_disable_resources(hpriv);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_suspend);\n\n \nint ahci_platform_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_platform_resume_host(dev);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\t \n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_platform_resume);\n#endif\n\nMODULE_DESCRIPTION(\"AHCI SATA platform library\");\nMODULE_AUTHOR(\"Anton Vorontsov <avorontsov@ru.mvista.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}