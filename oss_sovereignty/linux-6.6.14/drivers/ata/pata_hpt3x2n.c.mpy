{
  "module_name": "pata_hpt3x2n.c",
  "hash_id": "4c762e7d7d79a06f17d747f152134a1d5b00d6899afa9f955957e3e6e24bd436",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_hpt3x2n.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_hpt3x2n\"\n#define DRV_VERSION\t\"0.3.19\"\n\nenum {\n\tPCI66\t\t=\t(1 << 1),\n\tUSE_DPLL\t=\t(1 << 0)\n};\n\nstruct hpt_clock {\n\tu8\txfer_speed;\n\tu32\ttiming;\n};\n\n \n\n \n\nstatic struct hpt_clock hpt3x2n_clocks[] = {\n\t{\tXFER_UDMA_7,\t0x1c869c62\t},\n\t{\tXFER_UDMA_6,\t0x1c869c62\t},\n\t{\tXFER_UDMA_5,\t0x1c8a9c62\t},\n\t{\tXFER_UDMA_4,\t0x1c8a9c62\t},\n\t{\tXFER_UDMA_3,\t0x1c8e9c62\t},\n\t{\tXFER_UDMA_2,\t0x1c929c62\t},\n\t{\tXFER_UDMA_1,\t0x1c9a9c62\t},\n\t{\tXFER_UDMA_0,\t0x1c829c62\t},\n\n\t{\tXFER_MW_DMA_2,\t0x2c829c62\t},\n\t{\tXFER_MW_DMA_1,\t0x2c829c66\t},\n\t{\tXFER_MW_DMA_0,\t0x2c829d2e\t},\n\n\t{\tXFER_PIO_4,\t0x0c829c62\t},\n\t{\tXFER_PIO_3,\t0x0c829c84\t},\n\t{\tXFER_PIO_2,\t0x0c829ca6\t},\n\t{\tXFER_PIO_1,\t0x0d029d26\t},\n\t{\tXFER_PIO_0,\t0x0d029d5e\t},\n};\n\n \n\nstatic u32 hpt3x2n_find_mode(struct ata_port *ap, int speed)\n{\n\tstruct hpt_clock *clocks = hpt3x2n_clocks;\n\n\twhile (clocks->xfer_speed) {\n\t\tif (clocks->xfer_speed == speed)\n\t\t\treturn clocks->timing;\n\t\tclocks++;\n\t}\n\tBUG();\n\treturn 0xffffffffU;\t \n}\n\n \nstatic unsigned int hpt372n_filter(struct ata_device *adev, unsigned int mask)\n{\n\tif (ata_id_is_sata(adev->id))\n\t\tmask &= ~((0xE << ATA_SHIFT_UDMA) | ATA_MASK_MWDMA);\n\n\treturn mask;\n}\n\n \n\nstatic int hpt3x2n_cable_detect(struct ata_port *ap)\n{\n\tu8 scr2, ata66;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tpci_read_config_byte(pdev, 0x5B, &scr2);\n\tpci_write_config_byte(pdev, 0x5B, scr2 & ~0x01);\n\n\tudelay(10);  \n\n\t \n\tpci_read_config_byte(pdev, 0x5A, &ata66);\n\t \n\tpci_write_config_byte(pdev, 0x5B, scr2);\n\n\tif (ata66 & (2 >> ap->port_no))\n\t\treturn ATA_CBL_PATA40;\n\telse\n\t\treturn ATA_CBL_PATA80;\n}\n\n \n\nstatic int hpt3x2n_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic const struct pci_bits hpt3x2n_enable_bits[] = {\n\t\t{ 0x50, 1, 0x04, 0x04 },\n\t\t{ 0x54, 1, 0x04, 0x04 }\n\t};\n\tu8 mcr2;\n\n\tif (!pci_test_config_bits(pdev, &hpt3x2n_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\n\t \n\tpci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\n\tudelay(100);\n\n\t \n\tpci_read_config_byte(pdev, 0x51 + 4 * ap->port_no, &mcr2);\n\tmcr2 &= ~0x07;\n\tpci_write_config_byte(pdev, 0x51 + 4 * ap->port_no, mcr2);\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic void hpt3x2n_set_mode(struct ata_port *ap, struct ata_device *adev,\n\t\t\t     u8 mode)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint addr = 0x40 + 4 * (adev->devno + 2 * ap->port_no);\n\tu32 reg, timing, mask;\n\n\t \n\tif (mode < XFER_MW_DMA_0)\n\t\tmask = 0xcfc3ffff;\n\telse if (mode < XFER_UDMA_0)\n\t\tmask = 0x31c001ff;\n\telse\n\t\tmask = 0x303c0000;\n\n\ttiming = hpt3x2n_find_mode(ap, mode);\n\n\tpci_read_config_dword(pdev, addr, &reg);\n\treg = (reg & ~mask) | (timing & mask);\n\tpci_write_config_dword(pdev, addr, reg);\n}\n\n \n\nstatic void hpt3x2n_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\thpt3x2n_set_mode(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void hpt3x2n_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\thpt3x2n_set_mode(ap, adev, adev->dma_mode);\n}\n\n \n\nstatic void hpt3x2n_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint mscreg = 0x50 + 4 * ap->port_no;\n\tu8 bwsr_stat, msc_stat;\n\n\tpci_read_config_byte(pdev, 0x6A, &bwsr_stat);\n\tpci_read_config_byte(pdev, mscreg, &msc_stat);\n\tif (bwsr_stat & (1 << ap->port_no))\n\t\tpci_write_config_byte(pdev, mscreg, msc_stat | 0x30);\n\tata_bmdma_stop(qc);\n}\n\n \n\nstatic void hpt3x2n_set_clock(struct ata_port *ap, int source)\n{\n\tvoid __iomem *bmdma = ap->ioaddr.bmdma_addr - ap->port_no * 8;\n\n\t \n\tiowrite8(0x80, bmdma+0x73);\n\tiowrite8(0x80, bmdma+0x77);\n\n\t \n\tiowrite8(source, bmdma+0x7B);\n\tiowrite8(0xC0, bmdma+0x79);\n\n\t \n\tiowrite8(ioread8(bmdma+0x70) | 0x32, bmdma+0x70);\n\tiowrite8(ioread8(bmdma+0x74) | 0x32, bmdma+0x74);\n\n\t \n\tiowrite8(0x00, bmdma+0x79);\n\n\t \n\tiowrite8(0x00, bmdma+0x73);\n\tiowrite8(0x00, bmdma+0x77);\n}\n\nstatic int hpt3x2n_use_dpll(struct ata_port *ap, int writing)\n{\n\tlong flags = (long)ap->host->private_data;\n\n\t \n\tif (writing)\n\t\treturn USE_DPLL;\t \n\tif (flags & PCI66)\n\t\treturn USE_DPLL;\t \n\treturn 0;\n}\n\nstatic int hpt3x2n_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_port *alt = ap->host->ports[ap->port_no ^ 1];\n\tint rc, flags = (long)ap->host->private_data;\n\tint dpll = hpt3x2n_use_dpll(ap, qc->tf.flags & ATA_TFLAG_WRITE);\n\n\t \n\trc = ata_std_qc_defer(qc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif ((flags & USE_DPLL) != dpll && alt->qc_active)\n\t\treturn ATA_DEFER_PORT;\n\treturn 0;\n}\n\nstatic unsigned int hpt3x2n_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tint flags = (long)ap->host->private_data;\n\tint dpll = hpt3x2n_use_dpll(ap, qc->tf.flags & ATA_TFLAG_WRITE);\n\n\tif ((flags & USE_DPLL) != dpll) {\n\t\tflags &= ~USE_DPLL;\n\t\tflags |= dpll;\n\t\tap->host->private_data = (void *)(long)flags;\n\n\t\thpt3x2n_set_clock(ap, dpll ? 0x21 : 0x23);\n\t}\n\treturn ata_bmdma_qc_issue(qc);\n}\n\nstatic const struct scsi_host_template hpt3x2n_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n \n\nstatic struct ata_port_operations hpt3xxn_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.bmdma_stop\t= hpt3x2n_bmdma_stop,\n\n\t.qc_defer\t= hpt3x2n_qc_defer,\n\t.qc_issue\t= hpt3x2n_qc_issue,\n\n\t.cable_detect\t= hpt3x2n_cable_detect,\n\t.set_piomode\t= hpt3x2n_set_piomode,\n\t.set_dmamode\t= hpt3x2n_set_dmamode,\n\t.prereset\t= hpt3x2n_pre_reset,\n};\n\n \n\nstatic struct ata_port_operations hpt372n_port_ops = {\n\t.inherits\t= &hpt3xxn_port_ops,\n\t.mode_filter\t= &hpt372n_filter,\n};\n\n \n\nstatic int hpt3xn_calibrate_dpll(struct pci_dev *dev)\n{\n\tu8 reg5b;\n\tu32 reg5c;\n\tint tries;\n\n\tfor (tries = 0; tries < 0x5000; tries++) {\n\t\tudelay(50);\n\t\tpci_read_config_byte(dev, 0x5b, &reg5b);\n\t\tif (reg5b & 0x80) {\n\t\t\t \n\t\t\tfor (tries = 0; tries < 0x1000; tries++) {\n\t\t\t\tpci_read_config_byte(dev, 0x5b, &reg5b);\n\t\t\t\t \n\t\t\t\tif ((reg5b & 0x80) == 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tpci_read_config_dword(dev, 0x5c, &reg5c);\n\t\t\tpci_write_config_dword(dev, 0x5c, reg5c & ~0x100);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\nstatic int hpt3x2n_pci_clock(struct pci_dev *pdev, unsigned int base)\n{\n\tunsigned int freq;\n\tu32 fcnt;\n\n\t \n\tfcnt = inl(pci_resource_start(pdev, 4) + 0x90);\n\tif ((fcnt >> 12) != 0xABCDE) {\n\t\tu32 total = 0;\n\t\tint i;\n\t\tu16 sr;\n\n\t\tdev_warn(&pdev->dev, \"BIOS clock data not set\\n\");\n\n\t\t \n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tpci_read_config_word(pdev, 0x78, &sr);\n\t\t\ttotal += sr & 0x1FF;\n\t\t\tudelay(15);\n\t\t}\n\t\tfcnt = total / 128;\n\t}\n\tfcnt &= 0x1FF;\n\n\tfreq = (fcnt * base) / 192;\t \n\n\t \n\tif (freq < 40)\n\t\treturn 33;\n\tif (freq < 45)\n\t\treturn 40;\n\tif (freq < 55)\n\t\treturn 50;\n\treturn 66;\n}\n\n \n\nstatic int hpt3x2n_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\t \n\tstatic const struct ata_port_info info_hpt372n = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &hpt372n_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_hpt3xxn = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &hpt3xxn_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info_hpt3xxn, NULL };\n\tu8 rev = dev->revision;\n\tu8 irqmask;\n\tunsigned int pci_mhz;\n\tunsigned int f_low, f_high;\n\tint adjust;\n\tunsigned long iobase = pci_resource_start(dev, 4);\n\tvoid *hpriv = (void *)USE_DPLL;\n\tint rc;\n\n\trc = pcim_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (dev->device) {\n\tcase PCI_DEVICE_ID_TTI_HPT366:\n\t\t \n\t\tif (rev < 6)\n\t\t\treturn -ENODEV;\n\t\tgoto hpt372n;\n\tcase PCI_DEVICE_ID_TTI_HPT371:\n\t\t \n\t\tif (rev < 2)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TTI_HPT372:\n\t\t \n\t\tif (rev < 2)\n\t\t\treturn -ENODEV;\n\t\tgoto hpt372n;\n\tcase PCI_DEVICE_ID_TTI_HPT302:\n\t\t \n\t\tif (rev < 2)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_TTI_HPT372N:\nhpt372n:\n\t\tppi[0] = &info_hpt372n;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev,\"PCI table is bogus, please report (%d)\\n\",\n\t\t\tdev->device);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tpci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\n\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\n\tpci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\n\tpci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\n\n\tpci_read_config_byte(dev, 0x5A, &irqmask);\n\tirqmask &= ~0x10;\n\tpci_write_config_byte(dev, 0x5a, irqmask);\n\n\t \n\tif (dev->device == PCI_DEVICE_ID_TTI_HPT371) {\n\t\tu8 mcr1;\n\t\tpci_read_config_byte(dev, 0x50, &mcr1);\n\t\tmcr1 &= ~0x04;\n\t\tpci_write_config_byte(dev, 0x50, mcr1);\n\t}\n\n\t \n\n\tpci_mhz = hpt3x2n_pci_clock(dev, 77);\n\n\tf_low = (pci_mhz * 48) / 66;\t \n\tf_high = f_low + 2;\t\t \n\n\tpci_write_config_dword(dev, 0x5C, (f_high << 16) | f_low | 0x100);\n\t \n\tpci_write_config_byte(dev, 0x5B, 0x21);\n\n\t \n\tfor (adjust = 0; adjust < 8; adjust++) {\n\t\tif (hpt3xn_calibrate_dpll(dev))\n\t\t\tbreak;\n\t\tpci_write_config_dword(dev, 0x5C, (f_high << 16) | f_low);\n\t}\n\tif (adjust == 8) {\n\t\tdev_err(&dev->dev, \"DPLL did not stabilize!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&dev->dev, \"bus clock %dMHz, using 66MHz DPLL\\n\", pci_mhz);\n\n\t \n\tif (pci_mhz > 60)\n\t\thpriv = (void *)(PCI66 | USE_DPLL);\n\n\t \n\tif (dev->device == PCI_DEVICE_ID_TTI_HPT371)\n\t\toutb(inb(iobase + 0x9c) | 0x04, iobase + 0x9c);\n\n\t \n\treturn ata_pci_bmdma_init_one(dev, ppi, &hpt3x2n_sht, hpriv, 0);\n}\n\nstatic const struct pci_device_id hpt3x2n[] = {\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT366), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT371), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT372), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT302), },\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT372N), },\n\n\t{ },\n};\n\nstatic struct pci_driver hpt3x2n_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= hpt3x2n,\n\t.probe\t\t= hpt3x2n_init_one,\n\t.remove\t\t= ata_pci_remove_one\n};\n\nmodule_pci_driver(hpt3x2n_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the Highpoint HPT3xxN\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, hpt3x2n);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}