{
  "module_name": "pata_macio.c",
  "hash_id": "18430730cdb9cc472c899b1b2128c98d4a79a5c1b21dcc5f819a68a4c0e6e012",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_macio.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#undef DEBUG_DMA\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n#include <linux/adb.h>\n#include <linux/pmu.h>\n#include <linux/scatterlist.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n\n#include <asm/macio.h>\n#include <asm/io.h>\n#include <asm/dbdma.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include <asm/mediabay.h>\n\n#ifdef DEBUG_DMA\n#define dev_dbgdma(dev, format, arg...)\t\t\\\n\tdev_printk(KERN_DEBUG , dev , format , ## arg)\n#else\n#define dev_dbgdma(dev, format, arg...)\t\t\\\n\t({ if (0) dev_printk(KERN_DEBUG, dev, format, ##arg); 0; })\n#endif\n\n#define DRV_NAME\t\"pata_macio\"\n#define DRV_VERSION\t\"0.9\"\n\n \nenum {\n\tcontroller_ohare,\t \n\tcontroller_heathrow,\t \n\tcontroller_kl_ata3,\t \n\tcontroller_kl_ata4,\t \n\tcontroller_un_ata6,\t \n\tcontroller_k2_ata6,\t \n\tcontroller_sh_ata6,\t \n};\n\nstatic const char* macio_ata_names[] = {\n\t\"OHare ATA\",\t\t \n\t\"Heathrow ATA\",\t\t \n\t\"KeyLargo ATA-3\",\t \n\t\"KeyLargo ATA-4\",\t \n\t\"UniNorth ATA-6\",\t \n\t\"K2 ATA-6\",\t\t \n\t\"Shasta ATA-6\",\t\t \n};\n\n \n#define IDE_TIMING_CONFIG\t0x200\n#define IDE_INTERRUPT\t\t0x300\n\n \n#define IDE_KAUAI_PIO_CONFIG\t0x200\n#define IDE_KAUAI_ULTRA_CONFIG\t0x210\n#define IDE_KAUAI_POLL_CONFIG\t0x220\n\n \n\n \n#define SYSCLK_TICKS(t)\t\t(((t) + IDE_SYSCLK_NS - 1) / IDE_SYSCLK_NS)\n#define SYSCLK_TICKS_66(t)\t(((t) + IDE_SYSCLK_66_NS - 1) / IDE_SYSCLK_66_NS)\n#define IDE_SYSCLK_NS\t\t30\t \n#define IDE_SYSCLK_66_NS\t15\t \n\n \n#define TR_133_PIOREG_PIO_MASK\t\t0xff000fff\n#define TR_133_PIOREG_MDMA_MASK\t\t0x00fff800\n#define TR_133_UDMAREG_UDMA_MASK\t0x0003ffff\n#define TR_133_UDMAREG_UDMA_EN\t\t0x00000001\n\n \n#define TR_100_PIO_ADDRSETUP_MASK\t0xff000000  \n#define TR_100_PIO_ADDRSETUP_SHIFT\t24\n#define TR_100_MDMA_MASK\t\t0x00fff000\n#define TR_100_MDMA_RECOVERY_MASK\t0x00fc0000\n#define TR_100_MDMA_RECOVERY_SHIFT\t18\n#define TR_100_MDMA_ACCESS_MASK\t\t0x0003f000\n#define TR_100_MDMA_ACCESS_SHIFT\t12\n#define TR_100_PIO_MASK\t\t\t0xff000fff\n#define TR_100_PIO_RECOVERY_MASK\t0x00000fc0\n#define TR_100_PIO_RECOVERY_SHIFT\t6\n#define TR_100_PIO_ACCESS_MASK\t\t0x0000003f\n#define TR_100_PIO_ACCESS_SHIFT\t\t0\n\n#define TR_100_UDMAREG_UDMA_MASK\t0x0000ffff\n#define TR_100_UDMAREG_UDMA_EN\t\t0x00000001\n\n\n \n#define TR_66_UDMA_MASK\t\t\t0xfff00000\n#define TR_66_UDMA_EN\t\t\t0x00100000  \n#define TR_66_PIO_ADDRSETUP_MASK\t0xe0000000  \n#define TR_66_PIO_ADDRSETUP_SHIFT\t29\n#define TR_66_UDMA_RDY2PAUS_MASK\t0x1e000000  \n#define TR_66_UDMA_RDY2PAUS_SHIFT\t25\n#define TR_66_UDMA_WRDATASETUP_MASK\t0x01e00000  \n#define TR_66_UDMA_WRDATASETUP_SHIFT\t21\n#define TR_66_MDMA_MASK\t\t\t0x000ffc00\n#define TR_66_MDMA_RECOVERY_MASK\t0x000f8000\n#define TR_66_MDMA_RECOVERY_SHIFT\t15\n#define TR_66_MDMA_ACCESS_MASK\t\t0x00007c00\n#define TR_66_MDMA_ACCESS_SHIFT\t\t10\n#define TR_66_PIO_MASK\t\t\t0xe00003ff\n#define TR_66_PIO_RECOVERY_MASK\t\t0x000003e0\n#define TR_66_PIO_RECOVERY_SHIFT\t5\n#define TR_66_PIO_ACCESS_MASK\t\t0x0000001f\n#define TR_66_PIO_ACCESS_SHIFT\t\t0\n\n \n#define TR_33_MDMA_MASK\t\t\t0x003ff800\n#define TR_33_MDMA_RECOVERY_MASK\t0x001f0000\n#define TR_33_MDMA_RECOVERY_SHIFT\t16\n#define TR_33_MDMA_ACCESS_MASK\t\t0x0000f800\n#define TR_33_MDMA_ACCESS_SHIFT\t\t11\n#define TR_33_MDMA_HALFTICK\t\t0x00200000\n#define TR_33_PIO_MASK\t\t\t0x000007ff\n#define TR_33_PIO_E\t\t\t0x00000400\n#define TR_33_PIO_RECOVERY_MASK\t\t0x000003e0\n#define TR_33_PIO_RECOVERY_SHIFT\t5\n#define TR_33_PIO_ACCESS_MASK\t\t0x0000001f\n#define TR_33_PIO_ACCESS_SHIFT\t\t0\n\n \n#define IDE_INTR_DMA\t\t\t0x80000000\n#define IDE_INTR_DEVICE\t\t\t0x40000000\n\n \n#define KAUAI_FCR_UATA_MAGIC\t\t0x00000004\n#define KAUAI_FCR_UATA_RESET_N\t\t0x00000002\n#define KAUAI_FCR_UATA_ENABLE\t\t0x00000001\n\n\n \n#define MAX_DCMDS\t\t256\n\n \n#define MAX_DBDMA_SEG\t\t0xff00\n\n\n \n#define IDE_WAKEUP_DELAY_MS\t1000\n\nstruct pata_macio_timing;\n\nstruct pata_macio_priv {\n\tint\t\t\t\tkind;\n\tint\t\t\t\taapl_bus_id;\n\tint\t\t\t\tmediabay : 1;\n\tstruct device_node\t\t*node;\n\tstruct macio_dev\t\t*mdev;\n\tstruct pci_dev\t\t\t*pdev;\n\tstruct device\t\t\t*dev;\n\tint\t\t\t\tirq;\n\tu32\t\t\t\ttreg[2][2];\n\tvoid __iomem\t\t\t*tfregs;\n\tvoid __iomem\t\t\t*kauai_fcr;\n\tstruct dbdma_cmd *\t\tdma_table_cpu;\n\tdma_addr_t\t\t\tdma_table_dma;\n\tstruct ata_host\t\t\t*host;\n\tconst struct pata_macio_timing\t*timings;\n};\n\n \nstruct pata_macio_timing {\n\tint\tmode;\n\tu32\treg1;\t \n\tu32\treg2;\t \n};\n\nstatic const struct pata_macio_timing pata_macio_ohare_timings[] = {\n\t{ XFER_PIO_0,\t\t0x00000526,\t0, },\n\t{ XFER_PIO_1,\t\t0x00000085,\t0, },\n\t{ XFER_PIO_2,\t\t0x00000025,\t0, },\n\t{ XFER_PIO_3,\t\t0x00000025,\t0, },\n\t{ XFER_PIO_4,\t\t0x00000025,\t0, },\n\t{ XFER_MW_DMA_0,\t0x00074000,\t0, },\n\t{ XFER_MW_DMA_1,\t0x00221000,\t0, },\n\t{ XFER_MW_DMA_2,\t0x00211000,\t0, },\n\t{ -1, 0, 0 }\n};\n\nstatic const struct pata_macio_timing pata_macio_heathrow_timings[] = {\n\t{ XFER_PIO_0,\t\t0x00000526,\t0, },\n\t{ XFER_PIO_1,\t\t0x00000085,\t0, },\n\t{ XFER_PIO_2,\t\t0x00000025,\t0, },\n\t{ XFER_PIO_3,\t\t0x00000025,\t0, },\n\t{ XFER_PIO_4,\t\t0x00000025,\t0, },\n\t{ XFER_MW_DMA_0,\t0x00074000,\t0, },\n\t{ XFER_MW_DMA_1,\t0x00221000,\t0, },\n\t{ XFER_MW_DMA_2,\t0x00211000,\t0, },\n\t{ -1, 0, 0 }\n};\n\nstatic const struct pata_macio_timing pata_macio_kl33_timings[] = {\n\t{ XFER_PIO_0,\t\t0x00000526,\t0, },\n\t{ XFER_PIO_1,\t\t0x00000085,\t0, },\n\t{ XFER_PIO_2,\t\t0x00000025,\t0, },\n\t{ XFER_PIO_3,\t\t0x00000025,\t0, },\n\t{ XFER_PIO_4,\t\t0x00000025,\t0, },\n\t{ XFER_MW_DMA_0,\t0x00084000,\t0, },\n\t{ XFER_MW_DMA_1,\t0x00021800,\t0, },\n\t{ XFER_MW_DMA_2,\t0x00011800,\t0, },\n\t{ -1, 0, 0 }\n};\n\nstatic const struct pata_macio_timing pata_macio_kl66_timings[] = {\n\t{ XFER_PIO_0,\t\t0x0000038c,\t0, },\n\t{ XFER_PIO_1,\t\t0x0000020a,\t0, },\n\t{ XFER_PIO_2,\t\t0x00000127,\t0, },\n\t{ XFER_PIO_3,\t\t0x000000c6,\t0, },\n\t{ XFER_PIO_4,\t\t0x00000065,\t0, },\n\t{ XFER_MW_DMA_0,\t0x00084000,\t0, },\n\t{ XFER_MW_DMA_1,\t0x00029800,\t0, },\n\t{ XFER_MW_DMA_2,\t0x00019400,\t0, },\n\t{ XFER_UDMA_0,\t\t0x19100000,\t0, },\n\t{ XFER_UDMA_1,\t\t0x14d00000,\t0, },\n\t{ XFER_UDMA_2,\t\t0x10900000,\t0, },\n\t{ XFER_UDMA_3,\t\t0x0c700000,\t0, },\n\t{ XFER_UDMA_4,\t\t0x0c500000,\t0, },\n\t{ -1, 0, 0 }\n};\n\nstatic const struct pata_macio_timing pata_macio_kauai_timings[] = {\n\t{ XFER_PIO_0,\t\t0x08000a92,\t0, },\n\t{ XFER_PIO_1,\t\t0x0800060f,\t0, },\n\t{ XFER_PIO_2,\t\t0x0800038b,\t0, },\n\t{ XFER_PIO_3,\t\t0x05000249,\t0, },\n\t{ XFER_PIO_4,\t\t0x04000148,\t0, },\n\t{ XFER_MW_DMA_0,\t0x00618000,\t0, },\n\t{ XFER_MW_DMA_1,\t0x00209000,\t0, },\n\t{ XFER_MW_DMA_2,\t0x00148000,\t0, },\n\t{ XFER_UDMA_0,\t\t         0,\t0x000070c1, },\n\t{ XFER_UDMA_1,\t\t         0,\t0x00005d81, },\n\t{ XFER_UDMA_2,\t\t         0,\t0x00004a61, },\n\t{ XFER_UDMA_3,\t\t         0,\t0x00003a51, },\n\t{ XFER_UDMA_4,\t\t         0,\t0x00002a31, },\n\t{ XFER_UDMA_5,\t\t         0,\t0x00002921, },\n\t{ -1, 0, 0 }\n};\n\nstatic const struct pata_macio_timing pata_macio_shasta_timings[] = {\n\t{ XFER_PIO_0,\t\t0x0a000c97,\t0, },\n\t{ XFER_PIO_1,\t\t0x07000712,\t0, },\n\t{ XFER_PIO_2,\t\t0x040003cd,\t0, },\n\t{ XFER_PIO_3,\t\t0x0500028b,\t0, },\n\t{ XFER_PIO_4,\t\t0x0400010a,\t0, },\n\t{ XFER_MW_DMA_0,\t0x00820800,\t0, },\n\t{ XFER_MW_DMA_1,\t0x0028b000,\t0, },\n\t{ XFER_MW_DMA_2,\t0x001ca000,\t0, },\n\t{ XFER_UDMA_0,\t\t         0,\t0x00035901, },\n\t{ XFER_UDMA_1,\t\t         0,\t0x000348b1, },\n\t{ XFER_UDMA_2,\t\t         0,\t0x00033881, },\n\t{ XFER_UDMA_3,\t\t         0,\t0x00033861, },\n\t{ XFER_UDMA_4,\t\t         0,\t0x00033841, },\n\t{ XFER_UDMA_5,\t\t         0,\t0x00033031, },\n\t{ XFER_UDMA_6,\t\t         0,\t0x00033021, },\n\t{ -1, 0, 0 }\n};\n\nstatic const struct pata_macio_timing *pata_macio_find_timing(\n\t\t\t\t\t    struct pata_macio_priv *priv,\n\t\t\t\t\t    int mode)\n{\n\tint i;\n\n\tfor (i = 0; priv->timings[i].mode > 0; i++) {\n\t\tif (priv->timings[i].mode == mode)\n\t\t\treturn &priv->timings[i];\n\t}\n\treturn NULL;\n}\n\n\nstatic void pata_macio_apply_timings(struct ata_port *ap, unsigned int device)\n{\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tvoid __iomem *rbase = ap->ioaddr.cmd_addr;\n\n\tif (priv->kind == controller_sh_ata6 ||\n\t    priv->kind == controller_un_ata6 ||\n\t    priv->kind == controller_k2_ata6) {\n\t\twritel(priv->treg[device][0], rbase + IDE_KAUAI_PIO_CONFIG);\n\t\twritel(priv->treg[device][1], rbase + IDE_KAUAI_ULTRA_CONFIG);\n\t} else\n\t\twritel(priv->treg[device][0], rbase + IDE_TIMING_CONFIG);\n}\n\nstatic void pata_macio_dev_select(struct ata_port *ap, unsigned int device)\n{\n\tata_sff_dev_select(ap, device);\n\n\t \n\tpata_macio_apply_timings(ap, device);\n}\n\nstatic void pata_macio_set_timings(struct ata_port *ap,\n\t\t\t\t   struct ata_device *adev)\n{\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tconst struct pata_macio_timing *t;\n\n\tdev_dbg(priv->dev, \"Set timings: DEV=%d,PIO=0x%x (%s),DMA=0x%x (%s)\\n\",\n\t\tadev->devno,\n\t\tadev->pio_mode,\n\t\tata_mode_string(ata_xfer_mode2mask(adev->pio_mode)),\n\t\tadev->dma_mode,\n\t\tata_mode_string(ata_xfer_mode2mask(adev->dma_mode)));\n\n\t \n\tpriv->treg[adev->devno][0] = priv->treg[adev->devno][1] = 0;\n\n\t \n\tt = pata_macio_find_timing(priv, adev->pio_mode);\n\tif (t == NULL) {\n\t\tdev_warn(priv->dev, \"Invalid PIO timing requested: 0x%x\\n\",\n\t\t\t adev->pio_mode);\n\t\tt = pata_macio_find_timing(priv, XFER_PIO_0);\n\t}\n\tBUG_ON(t == NULL);\n\n\t \n\tpriv->treg[adev->devno][0] |= t->reg1;\n\n\t \n\tt = pata_macio_find_timing(priv, adev->dma_mode);\n\tif (t == NULL || (t->reg1 == 0 && t->reg2 == 0)) {\n\t\tdev_dbg(priv->dev, \"DMA timing not set yet, using MW_DMA_0\\n\");\n\t\tt = pata_macio_find_timing(priv, XFER_MW_DMA_0);\n\t}\n\tBUG_ON(t == NULL);\n\n\t \n\tpriv->treg[adev->devno][0] |= t->reg1;\n\tpriv->treg[adev->devno][1] |= t->reg2;\n\n\tdev_dbg(priv->dev, \" -> %08x %08x\\n\",\n\t\tpriv->treg[adev->devno][0],\n\t\tpriv->treg[adev->devno][1]);\n\n\t \n\tpata_macio_apply_timings(ap, adev->devno);\n}\n\n \nstatic void pata_macio_default_timings(struct pata_macio_priv *priv)\n{\n\tunsigned int value, value2 = 0;\n\n\tswitch(priv->kind) {\n\t\tcase controller_sh_ata6:\n\t\t\tvalue = 0x0a820c97;\n\t\t\tvalue2 = 0x00033031;\n\t\t\tbreak;\n\t\tcase controller_un_ata6:\n\t\tcase controller_k2_ata6:\n\t\t\tvalue = 0x08618a92;\n\t\t\tvalue2 = 0x00002921;\n\t\t\tbreak;\n\t\tcase controller_kl_ata4:\n\t\t\tvalue = 0x0008438c;\n\t\t\tbreak;\n\t\tcase controller_kl_ata3:\n\t\t\tvalue = 0x00084526;\n\t\t\tbreak;\n\t\tcase controller_heathrow:\n\t\tcase controller_ohare:\n\t\tdefault:\n\t\t\tvalue = 0x00074526;\n\t\t\tbreak;\n\t}\n\tpriv->treg[0][0] = priv->treg[1][0] = value;\n\tpriv->treg[0][1] = priv->treg[1][1] = value2;\n}\n\nstatic int pata_macio_cable_detect(struct ata_port *ap)\n{\n\tstruct pata_macio_priv *priv = ap->private_data;\n\n\t \n\tif (priv->kind == controller_kl_ata4 ||\n\t    priv->kind == controller_un_ata6 ||\n\t    priv->kind == controller_k2_ata6 ||\n\t    priv->kind == controller_sh_ata6) {\n\t\tconst char* cable = of_get_property(priv->node, \"cable-type\",\n\t\t\t\t\t\t    NULL);\n\t\tstruct device_node *root = of_find_node_by_path(\"/\");\n\t\tconst char *model = of_get_property(root, \"model\", NULL);\n\n\t\tof_node_put(root);\n\n\t\tif (cable && !strncmp(cable, \"80-\", 3)) {\n\t\t\t \n\t\t\tif (!strncmp(model, \"PowerBook\", 9))\n\t\t\t\treturn ATA_CBL_PATA40_SHORT;\n\t\t\telse\n\t\t\t\treturn ATA_CBL_PATA80;\n\t\t}\n\t}\n\n\t \n\tif (of_device_is_compatible(priv->node, \"K2-UATA\") ||\n\t    of_device_is_compatible(priv->node, \"shasta-ata\"))\n\t\treturn ATA_CBL_PATA80;\n\n\t \n\treturn ATA_CBL_PATA40;\n}\n\nstatic enum ata_completion_errors pata_macio_qc_prep(struct ata_queued_cmd *qc)\n{\n\tunsigned int write = (qc->tf.flags & ATA_TFLAG_WRITE);\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tstruct scatterlist *sg;\n\tstruct dbdma_cmd *table;\n\tunsigned int si, pi;\n\n\tdev_dbgdma(priv->dev, \"%s: qc %p flags %lx, write %d dev %d\\n\",\n\t\t   __func__, qc, qc->flags, write, qc->dev->devno);\n\n\tif (!(qc->flags & ATA_QCFLAG_DMAMAP))\n\t\treturn AC_ERR_OK;\n\n\ttable = (struct dbdma_cmd *) priv->dma_table_cpu;\n\n\tpi = 0;\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tu32 addr, sg_len, len;\n\n\t\t \n\t\taddr = (u32) sg_dma_address(sg);\n\t\tsg_len = sg_dma_len(sg);\n\n\t\twhile (sg_len) {\n\t\t\t \n\t\t\tBUG_ON (pi++ >= MAX_DCMDS);\n\n\t\t\tlen = (sg_len < MAX_DBDMA_SEG) ? sg_len : MAX_DBDMA_SEG;\n\t\t\ttable->command = cpu_to_le16(write ? OUTPUT_MORE: INPUT_MORE);\n\t\t\ttable->req_count = cpu_to_le16(len);\n\t\t\ttable->phy_addr = cpu_to_le32(addr);\n\t\t\ttable->cmd_dep = 0;\n\t\t\ttable->xfer_status = 0;\n\t\t\ttable->res_count = 0;\n\t\t\taddr += len;\n\t\t\tsg_len -= len;\n\t\t\t++table;\n\t\t}\n\t}\n\n\t \n\tBUG_ON(!pi);\n\n\t \n\ttable--;\n\ttable->command = cpu_to_le16(write ? OUTPUT_LAST: INPUT_LAST);\n\ttable++;\n\n\t \n\tmemset(table, 0, sizeof(struct dbdma_cmd));\n\ttable->command = cpu_to_le16(DBDMA_STOP);\n\n\tdev_dbgdma(priv->dev, \"%s: %d DMA list entries\\n\", __func__, pi);\n\n\treturn AC_ERR_OK;\n}\n\n\nstatic void pata_macio_freeze(struct ata_port *ap)\n{\n\tstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\n\n\tif (dma_regs) {\n\t\tunsigned int timeout = 1000000;\n\n\t\t \n\t\twritel((RUN|PAUSE|FLUSH|WAKE|DEAD) << 16, &dma_regs->control);\n\t\twhile (--timeout && (readl(&dma_regs->status) & RUN))\n\t\t\tudelay(1);\n\t}\n\n\tata_sff_freeze(ap);\n}\n\n\nstatic void pata_macio_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\n\tint dev = qc->dev->devno;\n\n\tdev_dbgdma(priv->dev, \"%s: qc %p\\n\", __func__, qc);\n\n\t \n\twritel(priv->dma_table_dma, &dma_regs->cmdptr);\n\n\t \n\tif (priv->kind == controller_kl_ata4 &&\n\t    (priv->treg[dev][0] & TR_66_UDMA_EN)) {\n\t\tvoid __iomem *rbase = ap->ioaddr.cmd_addr;\n\t\tu32 reg = priv->treg[dev][0];\n\n\t\tif (!(qc->tf.flags & ATA_TFLAG_WRITE))\n\t\t\treg += 0x00800000;\n\t\twritel(reg, rbase + IDE_TIMING_CONFIG);\n\t}\n\n\t \n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\nstatic void pata_macio_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\n\n\tdev_dbgdma(priv->dev, \"%s: qc %p\\n\", __func__, qc);\n\n\twritel((RUN << 16) | RUN, &dma_regs->control);\n\t \n\t(void)readl(&dma_regs->control);\n}\n\nstatic void pata_macio_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\n\tunsigned int timeout = 1000000;\n\n\tdev_dbgdma(priv->dev, \"%s: qc %p\\n\", __func__, qc);\n\n\t \n\twritel (((RUN|WAKE|DEAD) << 16), &dma_regs->control);\n\twhile (--timeout && (readl(&dma_regs->status) & RUN))\n\t\tudelay(1);\n}\n\nstatic u8 pata_macio_bmdma_status(struct ata_port *ap)\n{\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\n\tu32 dstat, rstat = ATA_DMA_INTR;\n\tunsigned long timeout = 0;\n\n\tdstat = readl(&dma_regs->status);\n\n\tdev_dbgdma(priv->dev, \"%s: dstat=%x\\n\", __func__, dstat);\n\n\t \n\n\t \n\tif ((dstat & (RUN|DEAD)) != RUN)\n\t\trstat |= ATA_DMA_ERR;\n\n\t \n\tif ((dstat & ACTIVE) == 0)\n\t\treturn rstat;\n\n\tdev_dbgdma(priv->dev, \"%s: DMA still active, flushing...\\n\", __func__);\n\n\t \n\tudelay(1);\n\twritel((FLUSH << 16) | FLUSH, &dma_regs->control);\n\tfor (;;) {\n\t\tudelay(1);\n\t\tdstat = readl(&dma_regs->status);\n\t\tif ((dstat & FLUSH) == 0)\n\t\t\tbreak;\n\t\tif (++timeout > 1000) {\n\t\t\tdev_warn(priv->dev, \"timeout flushing DMA\\n\");\n\t\t\trstat |= ATA_DMA_ERR;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rstat;\n}\n\n \nstatic int pata_macio_port_start(struct ata_port *ap)\n{\n\tstruct pata_macio_priv *priv = ap->private_data;\n\n\tif (ap->ioaddr.bmdma_addr == NULL)\n\t\treturn 0;\n\n\t \n\tpriv->dma_table_cpu =\n\t\tdmam_alloc_coherent(priv->dev,\n\t\t\t\t    (MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),\n\t\t\t\t    &priv->dma_table_dma, GFP_KERNEL);\n\tif (priv->dma_table_cpu == NULL) {\n\t\tdev_err(priv->dev, \"Unable to allocate DMA command list\\n\");\n\t\tap->ioaddr.bmdma_addr = NULL;\n\t\tap->mwdma_mask = 0;\n\t\tap->udma_mask = 0;\n\t}\n\treturn 0;\n}\n\nstatic void pata_macio_irq_clear(struct ata_port *ap)\n{\n\tstruct pata_macio_priv *priv = ap->private_data;\n\n\t \n\n\tdev_dbgdma(priv->dev, \"%s\\n\", __func__);\n}\n\nstatic void pata_macio_reset_hw(struct pata_macio_priv *priv, int resume)\n{\n\tdev_dbg(priv->dev, \"Enabling & resetting... \\n\");\n\n\tif (priv->mediabay)\n\t\treturn;\n\n\tif (priv->kind == controller_ohare && !resume) {\n\t\t \n\t\tppc_md.feature_call(PMAC_FTR_IDE_ENABLE, priv->node, 0, 1);\n\t} else {\n\t\tint rc;\n\n \t\t \n\t\trc = ppc_md.feature_call(PMAC_FTR_IDE_RESET,\n\t\t\t\t\t priv->node, priv->aapl_bus_id, 1);\n\t\tppc_md.feature_call(PMAC_FTR_IDE_ENABLE,\n\t\t\t\t    priv->node, priv->aapl_bus_id, 1);\n\t\tmsleep(10);\n\t\t \n\t\tif (rc == 0) {\n\t\t\tppc_md.feature_call(PMAC_FTR_IDE_RESET,\n\t\t\t\t\t    priv->node, priv->aapl_bus_id, 0);\n\t\t\tmsleep(IDE_WAKEUP_DELAY_MS);\n\t\t}\n\t}\n\n\t \n\tif (priv->pdev && resume) {\n\t\tint rc;\n\n\t\tpci_restore_state(priv->pdev);\n\t\trc = pcim_enable_device(priv->pdev);\n\t\tif (rc)\n\t\t\tdev_err(&priv->pdev->dev,\n\t\t\t\t\"Failed to enable device after resume (%d)\\n\",\n\t\t\t\trc);\n\t\telse\n\t\t\tpci_set_master(priv->pdev);\n\t}\n\n\t \n\tif (priv->kauai_fcr)\n\t\twritel(KAUAI_FCR_UATA_MAGIC |\n\t\t       KAUAI_FCR_UATA_RESET_N |\n\t\t       KAUAI_FCR_UATA_ENABLE, priv->kauai_fcr);\n}\n\n \nstatic int pata_macio_slave_config(struct scsi_device *sdev)\n{\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct pata_macio_priv *priv = ap->private_data;\n\tstruct ata_device *dev;\n\tu16 cmd;\n\tint rc;\n\n\t \n\trc = ata_scsi_slave_config(sdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tdev = &ap->link.device[sdev->id];\n\n\t \n\tif (priv->kind == controller_ohare) {\n\t\tblk_queue_update_dma_alignment(sdev->request_queue, 31);\n\t\tblk_queue_update_dma_pad(sdev->request_queue, 31);\n\n\t\t \n\t\tata_dev_info(dev, \"OHare alignment limits applied\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (dev->class != ATA_DEV_ATAPI)\n\t\treturn 0;\n\n\t \n\tif (priv->kind == controller_sh_ata6 || priv->kind == controller_k2_ata6) {\n\t\t \n\t\tblk_queue_update_dma_alignment(sdev->request_queue, 15);\n\t\tblk_queue_update_dma_pad(sdev->request_queue, 15);\n\n\t\t \n\t\tBUG_ON(!priv->pdev);\n\t\tpci_write_config_byte(priv->pdev, PCI_CACHE_LINE_SIZE, 0x08);\n\t\tpci_read_config_word(priv->pdev, PCI_COMMAND, &cmd);\n\t\tpci_write_config_word(priv->pdev, PCI_COMMAND,\n\t\t\t\t      cmd | PCI_COMMAND_INVALIDATE);\n\n\t\t \n\t\tata_dev_info(dev, \"K2/Shasta alignment limits applied\\n\");\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pata_macio_do_suspend(struct pata_macio_priv *priv, pm_message_t mesg)\n{\n\t \n\tata_host_suspend(priv->host, mesg);\n\n\t \n\tpata_macio_default_timings(priv);\n\n\t \n\tdisable_irq(priv->irq);\n\n\t \n\tif (priv->mediabay)\n\t\treturn 0;\n\n\t \n\tif (priv->kauai_fcr) {\n\t\tu32 fcr = readl(priv->kauai_fcr);\n\t\tfcr &= ~(KAUAI_FCR_UATA_RESET_N | KAUAI_FCR_UATA_ENABLE);\n\t\twritel(fcr, priv->kauai_fcr);\n\t}\n\n\t \n\tif (priv->pdev) {\n\t\tpci_save_state(priv->pdev);\n\t\tpci_disable_device(priv->pdev);\n\t}\n\n\t \n\tppc_md.feature_call(PMAC_FTR_IDE_ENABLE, priv->node,\n\t\t\t    priv->aapl_bus_id, 0);\n\n\treturn 0;\n}\n\nstatic int pata_macio_do_resume(struct pata_macio_priv *priv)\n{\n\t \n\tpata_macio_reset_hw(priv, 1);\n\n\t \n\tpata_macio_apply_timings(priv->host->ports[0], 0);\n\n\t \n\tenable_irq(priv->irq);\n\n\t \n\tata_host_resume(priv->host);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct scsi_host_template pata_macio_sht = {\n\t__ATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= MAX_DCMDS,\n\t \n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY,\n\t \n\t.max_segment_size\t= MAX_DBDMA_SEG,\n\t.slave_configure\t= pata_macio_slave_config,\n\t.sdev_groups\t\t= ata_common_sdev_groups,\n\t.can_queue\t\t= ATA_DEF_QUEUE,\n\t.tag_alloc_policy\t= BLK_TAG_ALLOC_RR,\n};\n\nstatic struct ata_port_operations pata_macio_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\n\t.freeze\t\t\t= pata_macio_freeze,\n\t.set_piomode\t\t= pata_macio_set_timings,\n\t.set_dmamode\t\t= pata_macio_set_timings,\n\t.cable_detect\t\t= pata_macio_cable_detect,\n\t.sff_dev_select\t\t= pata_macio_dev_select,\n\t.qc_prep\t\t= pata_macio_qc_prep,\n\t.bmdma_setup\t\t= pata_macio_bmdma_setup,\n\t.bmdma_start\t\t= pata_macio_bmdma_start,\n\t.bmdma_stop\t\t= pata_macio_bmdma_stop,\n\t.bmdma_status\t\t= pata_macio_bmdma_status,\n\t.port_start\t\t= pata_macio_port_start,\n\t.sff_irq_clear\t\t= pata_macio_irq_clear,\n};\n\nstatic void pata_macio_invariants(struct pata_macio_priv *priv)\n{\n\tconst int *bidp;\n\n\t \n\tif (of_device_is_compatible(priv->node, \"shasta-ata\")) {\n\t\tpriv->kind = controller_sh_ata6;\n\t        priv->timings = pata_macio_shasta_timings;\n\t} else if (of_device_is_compatible(priv->node, \"kauai-ata\")) {\n\t\tpriv->kind = controller_un_ata6;\n\t        priv->timings = pata_macio_kauai_timings;\n\t} else if (of_device_is_compatible(priv->node, \"K2-UATA\")) {\n\t\tpriv->kind = controller_k2_ata6;\n\t        priv->timings = pata_macio_kauai_timings;\n\t} else if (of_device_is_compatible(priv->node, \"keylargo-ata\")) {\n\t\tif (of_node_name_eq(priv->node, \"ata-4\")) {\n\t\t\tpriv->kind = controller_kl_ata4;\n\t\t\tpriv->timings = pata_macio_kl66_timings;\n\t\t} else {\n\t\t\tpriv->kind = controller_kl_ata3;\n\t\t\tpriv->timings = pata_macio_kl33_timings;\n\t\t}\n\t} else if (of_device_is_compatible(priv->node, \"heathrow-ata\")) {\n\t\tpriv->kind = controller_heathrow;\n\t\tpriv->timings = pata_macio_heathrow_timings;\n\t} else {\n\t\tpriv->kind = controller_ohare;\n\t\tpriv->timings = pata_macio_ohare_timings;\n\t}\n\n\t \n\n\t \n\tbidp = of_get_property(priv->node, \"AAPL,bus-id\", NULL);\n\tpriv->aapl_bus_id =  bidp ? *bidp : 0;\n\n\t \n\tif (priv->mediabay && !bidp)\n\t\tpriv->aapl_bus_id = 1;\n}\n\nstatic void pata_macio_setup_ios(struct ata_ioports *ioaddr,\n\t\t\t\t void __iomem * base, void __iomem * dma)\n{\n\t \n\tioaddr->cmd_addr\t= base;\n\n\t \n\tioaddr->data_addr\t= base + (ATA_REG_DATA    << 4);\n\tioaddr->error_addr\t= base + (ATA_REG_ERR     << 4);\n\tioaddr->feature_addr\t= base + (ATA_REG_FEATURE << 4);\n\tioaddr->nsect_addr\t= base + (ATA_REG_NSECT   << 4);\n\tioaddr->lbal_addr\t= base + (ATA_REG_LBAL    << 4);\n\tioaddr->lbam_addr\t= base + (ATA_REG_LBAM    << 4);\n\tioaddr->lbah_addr\t= base + (ATA_REG_LBAH    << 4);\n\tioaddr->device_addr\t= base + (ATA_REG_DEVICE  << 4);\n\tioaddr->status_addr\t= base + (ATA_REG_STATUS  << 4);\n\tioaddr->command_addr\t= base + (ATA_REG_CMD     << 4);\n\tioaddr->altstatus_addr\t= base + 0x160;\n\tioaddr->ctl_addr\t= base + 0x160;\n\tioaddr->bmdma_addr\t= dma;\n}\n\nstatic void pmac_macio_calc_timing_masks(struct pata_macio_priv *priv,\n\t\t\t\t\t struct ata_port_info *pinfo)\n{\n\tint i = 0;\n\n\tpinfo->pio_mask\t\t= 0;\n\tpinfo->mwdma_mask\t= 0;\n\tpinfo->udma_mask\t= 0;\n\n\twhile (priv->timings[i].mode > 0) {\n\t\tunsigned int mask = 1U << (priv->timings[i].mode & 0x0f);\n\t\tswitch(priv->timings[i].mode & 0xf0) {\n\t\tcase 0x00:  \n\t\t\tpinfo->pio_mask |= (mask >> 8);\n\t\t\tbreak;\n\t\tcase 0x20:  \n\t\t\tpinfo->mwdma_mask |= mask;\n\t\t\tbreak;\n\t\tcase 0x40:  \n\t\t\tpinfo->udma_mask |= mask;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tdev_dbg(priv->dev, \"Supported masks: PIO=%x, MWDMA=%x, UDMA=%x\\n\",\n\t\tpinfo->pio_mask, pinfo->mwdma_mask, pinfo->udma_mask);\n}\n\nstatic int pata_macio_common_init(struct pata_macio_priv *priv,\n\t\t\t\t  resource_size_t tfregs,\n\t\t\t\t  resource_size_t dmaregs,\n\t\t\t\t  resource_size_t fcregs,\n\t\t\t\t  unsigned long irq)\n{\n\tstruct ata_port_info\t\tpinfo;\n\tconst struct ata_port_info\t*ppi[] = { &pinfo, NULL };\n\tvoid __iomem\t\t\t*dma_regs = NULL;\n\n\t \n\tpata_macio_invariants(priv);\n\n\t \n\tpata_macio_default_timings(priv);\n\n\t \n\tmemset(&pinfo, 0, sizeof(struct ata_port_info));\n\tpmac_macio_calc_timing_masks(priv, &pinfo);\n\tpinfo.flags\t\t= ATA_FLAG_SLAVE_POSS;\n\tpinfo.port_ops\t\t= &pata_macio_ops;\n\tpinfo.private_data\t= priv;\n\n\tpriv->host = ata_host_alloc_pinfo(priv->dev, ppi, 1);\n\tif (priv->host == NULL) {\n\t\tdev_err(priv->dev, \"Failed to allocate ATA port structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpriv->host->private_data = priv;\n\n\t \n\tpriv->tfregs = devm_ioremap(priv->dev, tfregs, 0x100);\n\tif (priv->tfregs == NULL) {\n\t\tdev_err(priv->dev, \"Failed to map ATA ports\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv->host->iomap = &priv->tfregs;\n\n\t \n\tif (dmaregs != 0) {\n\t\tdma_regs = devm_ioremap(priv->dev, dmaregs,\n\t\t\t\t\tsizeof(struct dbdma_regs));\n\t\tif (dma_regs == NULL)\n\t\t\tdev_warn(priv->dev, \"Failed to map ATA DMA registers\\n\");\n\t}\n\n\t \n\tif (fcregs != 0) {\n\t\tpriv->kauai_fcr = devm_ioremap(priv->dev, fcregs, 4);\n\t\tif (priv->kauai_fcr == NULL) {\n\t\t\tdev_err(priv->dev, \"Failed to map ATA FCR register\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tpata_macio_setup_ios(&priv->host->ports[0]->ioaddr,\n\t\t\t     priv->tfregs, dma_regs);\n\tpriv->host->ports[0]->private_data = priv;\n\n\t \n\tpata_macio_reset_hw(priv, 0);\n\tpata_macio_apply_timings(priv->host->ports[0], 0);\n\n\t \n\tif (priv->pdev && dma_regs)\n\t\tpci_set_master(priv->pdev);\n\n\tdev_info(priv->dev, \"Activating pata-macio chipset %s, Apple bus ID %d\\n\",\n\t\t macio_ata_names[priv->kind], priv->aapl_bus_id);\n\n\t \n\tpriv->irq = irq;\n\treturn ata_host_activate(priv->host, irq, ata_bmdma_interrupt, 0,\n\t\t\t\t &pata_macio_sht);\n}\n\nstatic int pata_macio_attach(struct macio_dev *mdev,\n\t\t\t     const struct of_device_id *match)\n{\n\tstruct pata_macio_priv\t*priv;\n\tresource_size_t\t\ttfregs, dmaregs = 0;\n\tunsigned long\t\tirq;\n\tint\t\t\trc;\n\n\t \n\tif (macio_resource_count(mdev) == 0) {\n\t\tdev_err(&mdev->ofdev.dev,\n\t\t\t\"No addresses for controller\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tmacio_enable_devres(mdev);\n\n\t \n\tpriv = devm_kzalloc(&mdev->ofdev.dev,\n\t\t\t    sizeof(struct pata_macio_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->node = of_node_get(mdev->ofdev.dev.of_node);\n\tpriv->mdev = mdev;\n\tpriv->dev = &mdev->ofdev.dev;\n\n\t \n\tif (macio_request_resource(mdev, 0, \"pata-macio\")) {\n\t\tdev_err(&mdev->ofdev.dev,\n\t\t\t\"Cannot obtain taskfile resource\\n\");\n\t\treturn -EBUSY;\n\t}\n\ttfregs = macio_resource_start(mdev, 0);\n\n\t \n\tif (macio_resource_count(mdev) >= 2) {\n\t\tif (macio_request_resource(mdev, 1, \"pata-macio-dma\"))\n\t\t\tdev_err(&mdev->ofdev.dev,\n\t\t\t\t\"Cannot obtain DMA resource\\n\");\n\t\telse\n\t\t\tdmaregs = macio_resource_start(mdev, 1);\n\t}\n\n\t \n\tif (macio_irq_count(mdev) == 0) {\n\t\tdev_warn(&mdev->ofdev.dev,\n\t\t\t \"No interrupts for controller, using 13\\n\");\n\t\tirq = irq_create_mapping(NULL, 13);\n\t} else\n\t\tirq = macio_irq(mdev, 0);\n\n\t \n\tlock_media_bay(priv->mdev->media_bay);\n\n\t \n\trc = pata_macio_common_init(priv,\n\t\t\t\t    tfregs,\t\t \n\t\t\t\t    dmaregs,\t\t \n\t\t\t\t    0,\t\t\t \n\t\t\t\t    irq);\n\tunlock_media_bay(priv->mdev->media_bay);\n\n\treturn rc;\n}\n\nstatic int pata_macio_detach(struct macio_dev *mdev)\n{\n\tstruct ata_host *host = macio_get_drvdata(mdev);\n\tstruct pata_macio_priv *priv = host->private_data;\n\n\tlock_media_bay(priv->mdev->media_bay);\n\n\t \n\tpriv->host->private_data = NULL;\n\n\tata_host_detach(host);\n\n\tunlock_media_bay(priv->mdev->media_bay);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pata_macio_suspend(struct macio_dev *mdev, pm_message_t mesg)\n{\n\tstruct ata_host *host = macio_get_drvdata(mdev);\n\n\treturn pata_macio_do_suspend(host->private_data, mesg);\n}\n\nstatic int pata_macio_resume(struct macio_dev *mdev)\n{\n\tstruct ata_host *host = macio_get_drvdata(mdev);\n\n\treturn pata_macio_do_resume(host->private_data);\n}\n#endif  \n\n#ifdef CONFIG_PMAC_MEDIABAY\nstatic void pata_macio_mb_event(struct macio_dev* mdev, int mb_state)\n{\n\tstruct ata_host *host = macio_get_drvdata(mdev);\n\tstruct ata_port *ap;\n\tstruct ata_eh_info *ehi;\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\n\tif (!host || !host->private_data)\n\t\treturn;\n\tap = host->ports[0];\n\tspin_lock_irqsave(ap->lock, flags);\n\tehi = &ap->link.eh_info;\n\tif (mb_state == MB_CD) {\n\t\tata_ehi_push_desc(ehi, \"mediabay plug\");\n\t\tata_ehi_hotplugged(ehi);\n\t\tata_port_freeze(ap);\n\t} else {\n\t\tata_ehi_push_desc(ehi, \"mediabay unplug\");\n\t\tata_for_each_dev(dev, &ap->link, ALL)\n\t\t\tdev->flags |= ATA_DFLAG_DETACH;\n\t\tata_port_abort(ap);\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n}\n#endif  \n\n\nstatic int pata_macio_pci_attach(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\tstruct pata_macio_priv\t*priv;\n\tstruct device_node\t*np;\n\tresource_size_t\t\trbase;\n\n\t \n\tnp = pci_device_to_OF_node(pdev);\n\tif (np == NULL) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot find OF device node for controller\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (pcim_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot enable controller PCI device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev,\n\t\t\t    sizeof(struct pata_macio_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->node = of_node_get(np);\n\tpriv->pdev = pdev;\n\tpriv->dev = &pdev->dev;\n\n\t \n\tif (pci_request_regions(pdev, \"pata-macio\")) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot obtain PCI resources\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trbase = pci_resource_start(pdev, 0);\n\tif (pata_macio_common_init(priv,\n\t\t\t\t   rbase + 0x2000,\t \n\t\t\t\t   rbase + 0x1000,\t \n\t\t\t\t   rbase,\t\t \n\t\t\t\t   pdev->irq))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic void pata_macio_pci_detach(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\tata_host_detach(host);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pata_macio_pci_suspend(struct pci_dev *pdev, pm_message_t mesg)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\treturn pata_macio_do_suspend(host->private_data, mesg);\n}\n\nstatic int pata_macio_pci_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\treturn pata_macio_do_resume(host->private_data);\n}\n#endif  \n\nstatic const struct of_device_id pata_macio_match[] =\n{\n\t{ .name = \"IDE\", },\n\t{ .name = \"ATA\", },\n\t{ .type = \"ide\", },\n\t{ .type = \"ata\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pata_macio_match);\n\nstatic struct macio_driver pata_macio_driver =\n{\n\t.driver = {\n\t\t.name \t\t= \"pata-macio\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= pata_macio_match,\n\t},\n\t.probe\t\t= pata_macio_attach,\n\t.remove\t\t= pata_macio_detach,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= pata_macio_suspend,\n\t.resume\t\t= pata_macio_resume,\n#endif\n#ifdef CONFIG_PMAC_MEDIABAY\n\t.mediabay_event\t= pata_macio_mb_event,\n#endif\n};\n\nstatic const struct pci_device_id pata_macio_pci_match[] = {\n\t{ PCI_VDEVICE(APPLE, PCI_DEVICE_ID_APPLE_UNI_N_ATA),\t0 },\n\t{ PCI_VDEVICE(APPLE, PCI_DEVICE_ID_APPLE_IPID_ATA100),\t0 },\n\t{ PCI_VDEVICE(APPLE, PCI_DEVICE_ID_APPLE_K2_ATA100),\t0 },\n\t{ PCI_VDEVICE(APPLE, PCI_DEVICE_ID_APPLE_SH_ATA),\t0 },\n\t{ PCI_VDEVICE(APPLE, PCI_DEVICE_ID_APPLE_IPID2_ATA),\t0 },\n\t{},\n};\n\nstatic struct pci_driver pata_macio_pci_driver = {\n\t.name\t\t= \"pata-pci-macio\",\n\t.id_table\t= pata_macio_pci_match,\n\t.probe\t\t= pata_macio_pci_attach,\n\t.remove\t\t= pata_macio_pci_detach,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= pata_macio_pci_suspend,\n\t.resume\t\t= pata_macio_pci_resume,\n#endif\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n};\nMODULE_DEVICE_TABLE(pci, pata_macio_pci_match);\n\n\nstatic int __init pata_macio_init(void)\n{\n\tint rc;\n\n\tif (!machine_is(powermac))\n\t\treturn -ENODEV;\n\n\trc = pci_register_driver(&pata_macio_pci_driver);\n\tif (rc)\n\t\treturn rc;\n\trc = macio_register_driver(&pata_macio_driver);\n\tif (rc) {\n\t\tpci_unregister_driver(&pata_macio_pci_driver);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void __exit pata_macio_exit(void)\n{\n\tmacio_unregister_driver(&pata_macio_driver);\n\tpci_unregister_driver(&pata_macio_pci_driver);\n}\n\nmodule_init(pata_macio_init);\nmodule_exit(pata_macio_exit);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt\");\nMODULE_DESCRIPTION(\"Apple MacIO PATA driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}