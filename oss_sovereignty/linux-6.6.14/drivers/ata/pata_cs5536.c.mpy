{
  "module_name": "pata_cs5536.c",
  "hash_id": "3bc8c880e7d3be5721dbb94ed2d251345c3464f2b5487989c0a751400026aca1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_cs5536.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/libata.h>\n#include <scsi/scsi_host.h>\n#include <linux/dmi.h>\n\n#ifdef CONFIG_X86_32\n#include <asm/msr.h>\nstatic int use_msr;\nmodule_param_named(msr, use_msr, int, 0644);\nMODULE_PARM_DESC(msr, \"Force using MSR to configure IDE function (Default: 0)\");\n#else\n#undef rdmsr\t \n#undef wrmsr\n#define rdmsr(x, y, z) do { } while (0)\n#define wrmsr(x, y, z) do { } while (0)\n#define use_msr 0\n#endif\n\n#define DRV_NAME\t\"pata_cs5536\"\n#define DRV_VERSION\t\"0.0.8\"\n\nenum {\n\tMSR_IDE_CFG\t\t= 0x51300010,\n\tPCI_IDE_CFG\t\t= 0x40,\n\n\tCFG\t\t\t= 0,\n\tDTC\t\t\t= 2,\n\tCAST\t\t\t= 3,\n\tETC\t\t\t= 4,\n\n\tIDE_CFG_CHANEN\t\t= (1 << 1),\n\tIDE_CFG_CABLE\t\t= (1 << 17) | (1 << 16),\n\n\tIDE_D0_SHIFT\t\t= 24,\n\tIDE_D1_SHIFT\t\t= 16,\n\tIDE_DRV_MASK\t\t= 0xff,\n\n\tIDE_CAST_D0_SHIFT\t= 6,\n\tIDE_CAST_D1_SHIFT\t= 4,\n\tIDE_CAST_DRV_MASK\t= 0x3,\n\tIDE_CAST_CMD_MASK\t= 0xff,\n\tIDE_CAST_CMD_SHIFT\t= 24,\n\n\tIDE_ETC_UDMA_MASK\t= 0xc0,\n};\n\n \nstatic const struct dmi_system_id udma_quirk_dmi_table[] = {\n\t{\n\t\t.ident = \"Bachmann electronic OT200\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Bachmann electronic\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OT200\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"1\")\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int cs5536_read(struct pci_dev *pdev, int reg, u32 *val)\n{\n\tif (unlikely(use_msr)) {\n\t\tu32 dummy __maybe_unused;\n\n\t\trdmsr(MSR_IDE_CFG + reg, *val, dummy);\n\t\treturn 0;\n\t}\n\n\treturn pci_read_config_dword(pdev, PCI_IDE_CFG + reg * 4, val);\n}\n\nstatic int cs5536_write(struct pci_dev *pdev, int reg, int val)\n{\n\tif (unlikely(use_msr)) {\n\t\twrmsr(MSR_IDE_CFG + reg, val, 0);\n\t\treturn 0;\n\t}\n\n\treturn pci_write_config_dword(pdev, PCI_IDE_CFG + reg * 4, val);\n}\n\nstatic void cs5536_program_dtc(struct ata_device *adev, u8 tim)\n{\n\tstruct pci_dev *pdev = to_pci_dev(adev->link->ap->host->dev);\n\tint dshift = adev->devno ? IDE_D1_SHIFT : IDE_D0_SHIFT;\n\tu32 dtc;\n\n\tcs5536_read(pdev, DTC, &dtc);\n\tdtc &= ~(IDE_DRV_MASK << dshift);\n\tdtc |= tim << dshift;\n\tcs5536_write(pdev, DTC, dtc);\n}\n\n \n\nstatic int cs5536_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 cfg;\n\n\tcs5536_read(pdev, CFG, &cfg);\n\n\tif (cfg & IDE_CFG_CABLE)\n\t\treturn ATA_CBL_PATA80;\n\telse\n\t\treturn ATA_CBL_PATA40;\n}\n\n \n\nstatic void cs5536_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 drv_timings[5] = {\n\t\t0x98, 0x55, 0x32, 0x21, 0x20,\n\t};\n\n\tstatic const u8 addr_timings[5] = {\n\t\t0x2, 0x1, 0x0, 0x0, 0x0,\n\t};\n\n\tstatic const u8 cmd_timings[5] = {\n\t\t0x99, 0x92, 0x90, 0x22, 0x20,\n\t};\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tint mode = adev->pio_mode - XFER_PIO_0;\n\tint cmdmode = mode;\n\tint cshift = adev->devno ? IDE_CAST_D1_SHIFT : IDE_CAST_D0_SHIFT;\n\tu32 cast;\n\n\tif (pair)\n\t\tcmdmode = min(mode, pair->pio_mode - XFER_PIO_0);\n\n\tcs5536_program_dtc(adev, drv_timings[mode]);\n\n\tcs5536_read(pdev, CAST, &cast);\n\n\tcast &= ~(IDE_CAST_DRV_MASK << cshift);\n\tcast |= addr_timings[mode] << cshift;\n\n\tcast &= ~(IDE_CAST_CMD_MASK << IDE_CAST_CMD_SHIFT);\n\tcast |= cmd_timings[cmdmode] << IDE_CAST_CMD_SHIFT;\n\n\tcs5536_write(pdev, CAST, cast);\n}\n\n \n\nstatic void cs5536_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 udma_timings[6] = {\n\t\t0xc2, 0xc1, 0xc0, 0xc4, 0xc5, 0xc6,\n\t};\n\n\tstatic const u8 mwdma_timings[3] = {\n\t\t0x67, 0x21, 0x20,\n\t};\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 etc;\n\tint mode = adev->dma_mode;\n\tint dshift = adev->devno ? IDE_D1_SHIFT : IDE_D0_SHIFT;\n\n\tcs5536_read(pdev, ETC, &etc);\n\n\tif (mode >= XFER_UDMA_0) {\n\t\tetc &= ~(IDE_DRV_MASK << dshift);\n\t\tetc |= udma_timings[mode - XFER_UDMA_0] << dshift;\n\t} else {  \n\t\tetc &= ~(IDE_ETC_UDMA_MASK << dshift);\n\t\tcs5536_program_dtc(adev, mwdma_timings[mode - XFER_MW_DMA_0]);\n\t}\n\n\tcs5536_write(pdev, ETC, etc);\n}\n\nstatic const struct scsi_host_template cs5536_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations cs5536_port_ops = {\n\t.inherits\t\t= &ata_bmdma32_port_ops,\n\t.cable_detect\t\t= cs5536_cable_detect,\n\t.set_piomode\t\t= cs5536_set_piomode,\n\t.set_dmamode\t\t= cs5536_set_dmamode,\n};\n\n \n\nstatic int cs5536_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &cs5536_port_ops,\n\t};\n\n\tstatic const struct ata_port_info no_udma_info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.port_ops = &cs5536_port_ops,\n\t};\n\n\n\tconst struct ata_port_info *ppi[2];\n\tu32 cfg;\n\n\tif (dmi_check_system(udma_quirk_dmi_table))\n\t\tppi[0] = &no_udma_info;\n\telse\n\t\tppi[0] = &info;\n\n\tppi[1] = &ata_dummy_port_info;\n\n\tif (use_msr)\n\t\tdev_err(&dev->dev, DRV_NAME \": Using MSR regs instead of PCI\\n\");\n\n\tcs5536_read(dev, CFG, &cfg);\n\n\tif ((cfg & IDE_CFG_CHANEN) == 0) {\n\t\tdev_err(&dev->dev, DRV_NAME \": disabled by BIOS\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn ata_pci_bmdma_init_one(dev, ppi, &cs5536_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id cs5536[] = {\n\t{ PCI_VDEVICE(AMD,\tPCI_DEVICE_ID_AMD_CS5536_IDE), },\n\t{ PCI_VDEVICE(AMD,\tPCI_DEVICE_ID_AMD_CS5536_DEV_IDE), },\n\t{ },\n};\n\nstatic struct pci_driver cs5536_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= cs5536,\n\t.probe\t\t= cs5536_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(cs5536_pci_driver);\n\nMODULE_AUTHOR(\"Martin K. Petersen\");\nMODULE_DESCRIPTION(\"low-level driver for the CS5536 IDE controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, cs5536);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}