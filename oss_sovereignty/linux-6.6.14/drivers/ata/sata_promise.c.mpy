{
  "module_name": "sata_promise.c",
  "hash_id": "9568422701d5e28f87847ba4c888b29649d69477ca4ae3b24fff8a994f8f6343",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_promise.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n#include \"sata_promise.h\"\n\n#define DRV_NAME\t\"sata_promise\"\n#define DRV_VERSION\t\"2.12\"\n\nenum {\n\tPDC_MAX_PORTS\t\t= 4,\n\tPDC_MMIO_BAR\t\t= 3,\n\tPDC_MAX_PRD\t\t= LIBATA_MAX_PRD - 1,  \n\n\t \n\tPDC_INT_SEQMASK\t\t= 0x40,\t \n\tPDC_FLASH_CTL\t\t= 0x44,  \n\tPDC_PCI_CTL\t\t= 0x48,  \n\tPDC_SATA_PLUG_CSR\t= 0x6C,  \n\tPDC2_SATA_PLUG_CSR\t= 0x60,  \n\tPDC_TBG_MODE\t\t= 0x41C,  \n\tPDC_SLEW_CTL\t\t= 0x470,  \n\n\t \n\tPDC_FEATURE\t\t= 0x04,  \n\tPDC_SECTOR_COUNT\t= 0x08,  \n\tPDC_SECTOR_NUMBER\t= 0x0C,  \n\tPDC_CYLINDER_LOW\t= 0x10,  \n\tPDC_CYLINDER_HIGH\t= 0x14,  \n\tPDC_DEVICE\t\t= 0x18,  \n\tPDC_COMMAND\t\t= 0x1C,  \n\tPDC_ALTSTATUS\t\t= 0x38,  \n\tPDC_PKT_SUBMIT\t\t= 0x40,  \n\tPDC_GLOBAL_CTL\t\t= 0x48,  \n\tPDC_CTLSTAT\t\t= 0x60,\t \n\n\t \n\tPDC_SATA_ERROR\t\t= 0x04,\n\tPDC_PHYMODE4\t\t= 0x14,\n\tPDC_LINK_LAYER_ERRORS\t= 0x6C,\n\tPDC_FPDMA_CTLSTAT\t= 0xD8,\n\tPDC_INTERNAL_DEBUG_1\t= 0xF8,\t \n\tPDC_INTERNAL_DEBUG_2\t= 0xFC,\t \n\n\t \n\tPDC_FPDMA_CTLSTAT_RESET\t\t\t= 1 << 3,\n\tPDC_FPDMA_CTLSTAT_DMASETUP_INT_FLAG\t= 1 << 10,\n\tPDC_FPDMA_CTLSTAT_SETDB_INT_FLAG\t= 1 << 11,\n\n\t \n\tPDC_PH_ERR\t\t= (1 <<  8),  \n\tPDC_SH_ERR\t\t= (1 <<  9),  \n\tPDC_DH_ERR\t\t= (1 << 10),  \n\tPDC2_HTO_ERR\t\t= (1 << 12),  \n\tPDC2_ATA_HBA_ERR\t= (1 << 13),  \n\tPDC2_ATA_DMA_CNT_ERR\t= (1 << 14),  \n\tPDC_OVERRUN_ERR\t\t= (1 << 19),  \n\tPDC_UNDERRUN_ERR\t= (1 << 20),  \n\tPDC_DRIVE_ERR\t\t= (1 << 21),  \n\tPDC_PCI_SYS_ERR\t\t= (1 << 22),  \n\tPDC1_PCI_PARITY_ERR\t= (1 << 23),  \n\tPDC1_ERR_MASK\t\t= PDC1_PCI_PARITY_ERR,\n\tPDC2_ERR_MASK\t\t= PDC2_HTO_ERR | PDC2_ATA_HBA_ERR |\n\t\t\t\t  PDC2_ATA_DMA_CNT_ERR,\n\tPDC_ERR_MASK\t\t= PDC_PH_ERR | PDC_SH_ERR | PDC_DH_ERR |\n\t\t\t\t  PDC_OVERRUN_ERR | PDC_UNDERRUN_ERR |\n\t\t\t\t  PDC_DRIVE_ERR | PDC_PCI_SYS_ERR |\n\t\t\t\t  PDC1_ERR_MASK | PDC2_ERR_MASK,\n\n\tboard_2037x\t\t= 0,\t \n\tboard_2037x_pata\t= 1,\t \n\tboard_20319\t\t= 2,\t \n\tboard_20619\t\t= 3,\t \n\tboard_2057x\t\t= 4,\t \n\tboard_2057x_pata\t= 5,\t \n\tboard_40518\t\t= 6,\t \n\n\tPDC_HAS_PATA\t\t= (1 << 1),  \n\n\t \n\tPDC_SEQCNTRL_INT_MASK\t= (1 << 5),  \n\n\t \n\tPDC_FEATURE_ATAPI_PIO\t= 0x00,  \n\tPDC_FEATURE_ATAPI_DMA\t= 0x01,  \n\n\t \n\tPDC_DEVICE_SATA\t\t= 0xE0,  \n\n\t \n\tPDC_DMA_ENABLE\t\t= (1 << 7),\n\tPDC_IRQ_DISABLE\t\t= (1 << 10),\n\tPDC_RESET\t\t= (1 << 11),  \n\n\tPDC_COMMON_FLAGS\t= ATA_FLAG_PIO_POLLING,\n\n\t \n\tPDC_FLAG_GEN_II\t\t= (1 << 24),\n\tPDC_FLAG_SATA_PATA\t= (1 << 25),  \n\tPDC_FLAG_4_PORTS\t= (1 << 26),  \n};\n\nstruct pdc_port_priv {\n\tu8\t\t\t*pkt;\n\tdma_addr_t\t\tpkt_dma;\n};\n\nstruct pdc_host_priv {\n\tspinlock_t hard_reset_lock;\n};\n\nstatic int pdc_sata_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);\nstatic int pdc_sata_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);\nstatic int pdc_ata_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic int pdc_common_port_start(struct ata_port *ap);\nstatic int pdc_sata_port_start(struct ata_port *ap);\nstatic enum ata_completion_errors pdc_qc_prep(struct ata_queued_cmd *qc);\nstatic void pdc_tf_load_mmio(struct ata_port *ap, const struct ata_taskfile *tf);\nstatic void pdc_exec_command_mmio(struct ata_port *ap, const struct ata_taskfile *tf);\nstatic int pdc_check_atapi_dma(struct ata_queued_cmd *qc);\nstatic int pdc_old_sata_check_atapi_dma(struct ata_queued_cmd *qc);\nstatic void pdc_irq_clear(struct ata_port *ap);\nstatic unsigned int pdc_qc_issue(struct ata_queued_cmd *qc);\nstatic void pdc_freeze(struct ata_port *ap);\nstatic void pdc_sata_freeze(struct ata_port *ap);\nstatic void pdc_thaw(struct ata_port *ap);\nstatic void pdc_sata_thaw(struct ata_port *ap);\nstatic int pdc_pata_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline);\nstatic int pdc_sata_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline);\nstatic void pdc_error_handler(struct ata_port *ap);\nstatic void pdc_post_internal_cmd(struct ata_queued_cmd *qc);\nstatic int pdc_pata_cable_detect(struct ata_port *ap);\n\nstatic const struct scsi_host_template pdc_ata_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= PDC_MAX_PRD,\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY,\n};\n\nstatic const struct ata_port_operations pdc_common_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\n\t.sff_tf_load\t\t= pdc_tf_load_mmio,\n\t.sff_exec_command\t= pdc_exec_command_mmio,\n\t.check_atapi_dma\t= pdc_check_atapi_dma,\n\t.qc_prep\t\t= pdc_qc_prep,\n\t.qc_issue\t\t= pdc_qc_issue,\n\n\t.sff_irq_clear\t\t= pdc_irq_clear,\n\t.lost_interrupt\t\t= ATA_OP_NULL,\n\n\t.post_internal_cmd\t= pdc_post_internal_cmd,\n\t.error_handler\t\t= pdc_error_handler,\n};\n\nstatic struct ata_port_operations pdc_sata_ops = {\n\t.inherits\t\t= &pdc_common_ops,\n\t.cable_detect\t\t= ata_cable_sata,\n\t.freeze\t\t\t= pdc_sata_freeze,\n\t.thaw\t\t\t= pdc_sata_thaw,\n\t.scr_read\t\t= pdc_sata_scr_read,\n\t.scr_write\t\t= pdc_sata_scr_write,\n\t.port_start\t\t= pdc_sata_port_start,\n\t.hardreset\t\t= pdc_sata_hardreset,\n};\n\n \nstatic struct ata_port_operations pdc_old_sata_ops = {\n\t.inherits\t\t= &pdc_sata_ops,\n\t.freeze\t\t\t= pdc_freeze,\n\t.thaw\t\t\t= pdc_thaw,\n\t.check_atapi_dma\t= pdc_old_sata_check_atapi_dma,\n};\n\nstatic struct ata_port_operations pdc_pata_ops = {\n\t.inherits\t\t= &pdc_common_ops,\n\t.cable_detect\t\t= pdc_pata_cable_detect,\n\t.freeze\t\t\t= pdc_freeze,\n\t.thaw\t\t\t= pdc_thaw,\n\t.port_start\t\t= pdc_common_port_start,\n\t.softreset\t\t= pdc_pata_softreset,\n};\n\nstatic const struct ata_port_info pdc_port_info[] = {\n\t[board_2037x] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SATA |\n\t\t\t\t  PDC_FLAG_SATA_PATA,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_old_sata_ops,\n\t},\n\n\t[board_2037x_pata] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_pata_ops,\n\t},\n\n\t[board_20319] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SATA |\n\t\t\t\t  PDC_FLAG_4_PORTS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_old_sata_ops,\n\t},\n\n\t[board_20619] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SLAVE_POSS |\n\t\t\t\t  PDC_FLAG_4_PORTS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_pata_ops,\n\t},\n\n\t[board_2057x] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SATA |\n\t\t\t\t  PDC_FLAG_GEN_II | PDC_FLAG_SATA_PATA,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_sata_ops,\n\t},\n\n\t[board_2057x_pata] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SLAVE_POSS |\n\t\t\t\t  PDC_FLAG_GEN_II,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_pata_ops,\n\t},\n\n\t[board_40518] =\n\t{\n\t\t.flags\t\t= PDC_COMMON_FLAGS | ATA_FLAG_SATA |\n\t\t\t\t  PDC_FLAG_GEN_II | PDC_FLAG_4_PORTS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_sata_ops,\n\t},\n};\n\nstatic const struct pci_device_id pdc_ata_pci_tbl[] = {\n\t{ PCI_VDEVICE(PROMISE, 0x3371), board_2037x },\n\t{ PCI_VDEVICE(PROMISE, 0x3373), board_2037x },\n\t{ PCI_VDEVICE(PROMISE, 0x3375), board_2037x },\n\t{ PCI_VDEVICE(PROMISE, 0x3376), board_2037x },\n\t{ PCI_VDEVICE(PROMISE, 0x3570), board_2057x },\n\t{ PCI_VDEVICE(PROMISE, 0x3571), board_2057x },\n\t{ PCI_VDEVICE(PROMISE, 0x3574), board_2057x },\n\t{ PCI_VDEVICE(PROMISE, 0x3577), board_2057x },\n\t{ PCI_VDEVICE(PROMISE, 0x3d73), board_2057x },\n\t{ PCI_VDEVICE(PROMISE, 0x3d75), board_2057x },\n\n\t{ PCI_VDEVICE(PROMISE, 0x3318), board_20319 },\n\t{ PCI_VDEVICE(PROMISE, 0x3319), board_20319 },\n\t{ PCI_VDEVICE(PROMISE, 0x3515), board_40518 },\n\t{ PCI_VDEVICE(PROMISE, 0x3519), board_40518 },\n\t{ PCI_VDEVICE(PROMISE, 0x3d17), board_40518 },\n\t{ PCI_VDEVICE(PROMISE, 0x3d18), board_40518 },\n\n\t{ PCI_VDEVICE(PROMISE, 0x6629), board_20619 },\n\n\t{ }\t \n};\n\nstatic struct pci_driver pdc_ata_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= pdc_ata_pci_tbl,\n\t.probe\t\t\t= pdc_ata_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\nstatic int pdc_common_port_start(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct pdc_port_priv *pp;\n\tint rc;\n\n\t \n\trc = ata_bmdma_port_start(ap);\n\tif (rc)\n\t\treturn rc;\n\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tpp->pkt = dmam_alloc_coherent(dev, 128, &pp->pkt_dma, GFP_KERNEL);\n\tif (!pp->pkt)\n\t\treturn -ENOMEM;\n\n\tap->private_data = pp;\n\n\treturn 0;\n}\n\nstatic int pdc_sata_port_start(struct ata_port *ap)\n{\n\tint rc;\n\n\trc = pdc_common_port_start(ap);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (ap->flags & PDC_FLAG_GEN_II) {\n\t\tvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\n\t\tunsigned int tmp;\n\n\t\ttmp = readl(sata_mmio + PDC_PHYMODE4);\n\t\ttmp = (tmp & ~3) | 1;\t \n\t\twritel(tmp, sata_mmio + PDC_PHYMODE4);\n\t}\n\n\treturn 0;\n}\n\nstatic void pdc_fpdma_clear_interrupt_flag(struct ata_port *ap)\n{\n\tvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\n\tu32 tmp;\n\n\ttmp = readl(sata_mmio + PDC_FPDMA_CTLSTAT);\n\ttmp |= PDC_FPDMA_CTLSTAT_DMASETUP_INT_FLAG;\n\ttmp |= PDC_FPDMA_CTLSTAT_SETDB_INT_FLAG;\n\n\t \n\twriteb(tmp >> 8, sata_mmio + PDC_FPDMA_CTLSTAT + 1);\n\treadb(sata_mmio + PDC_FPDMA_CTLSTAT + 1);  \n}\n\nstatic void pdc_fpdma_reset(struct ata_port *ap)\n{\n\tvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\n\tu8 tmp;\n\n\ttmp = (u8)readl(sata_mmio + PDC_FPDMA_CTLSTAT);\n\ttmp &= 0x7F;\n\ttmp |= PDC_FPDMA_CTLSTAT_RESET;\n\twriteb(tmp, sata_mmio + PDC_FPDMA_CTLSTAT);\n\treadl(sata_mmio + PDC_FPDMA_CTLSTAT);  \n\tudelay(100);\n\ttmp &= ~PDC_FPDMA_CTLSTAT_RESET;\n\twriteb(tmp, sata_mmio + PDC_FPDMA_CTLSTAT);\n\treadl(sata_mmio + PDC_FPDMA_CTLSTAT);  \n\n\tpdc_fpdma_clear_interrupt_flag(ap);\n}\n\nstatic void pdc_not_at_command_packet_phase(struct ata_port *ap)\n{\n\tvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\n\tunsigned int i;\n\tu32 tmp;\n\n\t \n\tfor (i = 0; i < 100; ++i) {\n\t\twritel(0, sata_mmio + PDC_INTERNAL_DEBUG_1);\n\t\ttmp = readl(sata_mmio + PDC_INTERNAL_DEBUG_2);\n\t\tif ((tmp & 0xF) != 1)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n}\n\nstatic void pdc_clear_internal_debug_record_error_register(struct ata_port *ap)\n{\n\tvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\n\n\twritel(0xffffffff, sata_mmio + PDC_SATA_ERROR);\n\twritel(0xffff0000, sata_mmio + PDC_LINK_LAYER_ERRORS);\n}\n\nstatic void pdc_reset_port(struct ata_port *ap)\n{\n\tvoid __iomem *ata_ctlstat_mmio = ap->ioaddr.cmd_addr + PDC_CTLSTAT;\n\tunsigned int i;\n\tu32 tmp;\n\n\tif (ap->flags & PDC_FLAG_GEN_II)\n\t\tpdc_not_at_command_packet_phase(ap);\n\n\ttmp = readl(ata_ctlstat_mmio);\n\ttmp |= PDC_RESET;\n\twritel(tmp, ata_ctlstat_mmio);\n\n\tfor (i = 11; i > 0; i--) {\n\t\ttmp = readl(ata_ctlstat_mmio);\n\t\tif (tmp & PDC_RESET)\n\t\t\tbreak;\n\n\t\tudelay(100);\n\n\t\ttmp |= PDC_RESET;\n\t\twritel(tmp, ata_ctlstat_mmio);\n\t}\n\n\ttmp &= ~PDC_RESET;\n\twritel(tmp, ata_ctlstat_mmio);\n\treadl(ata_ctlstat_mmio);\t \n\n\tif (sata_scr_valid(&ap->link) && (ap->flags & PDC_FLAG_GEN_II)) {\n\t\tpdc_fpdma_reset(ap);\n\t\tpdc_clear_internal_debug_record_error_register(ap);\n\t}\n}\n\nstatic int pdc_pata_cable_detect(struct ata_port *ap)\n{\n\tu8 tmp;\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\n\ttmp = readb(ata_mmio + PDC_CTLSTAT + 3);\n\tif (tmp & 0x01)\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\nstatic int pdc_sata_scr_read(struct ata_link *link,\n\t\t\t     unsigned int sc_reg, u32 *val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\t*val = readl(link->ap->ioaddr.scr_addr + (sc_reg * 4));\n\treturn 0;\n}\n\nstatic int pdc_sata_scr_write(struct ata_link *link,\n\t\t\t      unsigned int sc_reg, u32 val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\twritel(val, link->ap->ioaddr.scr_addr + (sc_reg * 4));\n\treturn 0;\n}\n\nstatic void pdc_atapi_pkt(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tdma_addr_t sg_table = ap->bmdma_prd_dma;\n\tunsigned int cdb_len = qc->dev->cdb_len;\n\tu8 *cdb = qc->cdb;\n\tstruct pdc_port_priv *pp = ap->private_data;\n\tu8 *buf = pp->pkt;\n\t__le32 *buf32 = (__le32 *) buf;\n\tunsigned int dev_sel, feature;\n\n\t \n\tswitch (qc->tf.protocol) {\n\tcase ATAPI_PROT_DMA:\n\t\tif (!(qc->tf.flags & ATA_TFLAG_WRITE))\n\t\t\tbuf32[0] = cpu_to_le32(PDC_PKT_READ);\n\t\telse\n\t\t\tbuf32[0] = 0;\n\t\tbreak;\n\tcase ATAPI_PROT_NODATA:\n\t\tbuf32[0] = cpu_to_le32(PDC_PKT_NODATA);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\tbuf32[1] = cpu_to_le32(sg_table);\t \n\tbuf32[2] = 0;\t\t\t\t \n\n\t \n\tif (sata_scr_valid(&ap->link))\n\t\tdev_sel = PDC_DEVICE_SATA;\n\telse\n\t\tdev_sel = qc->tf.device;\n\n\tbuf[12] = (1 << 5) | ATA_REG_DEVICE;\n\tbuf[13] = dev_sel;\n\tbuf[14] = (1 << 5) | ATA_REG_DEVICE | PDC_PKT_CLEAR_BSY;\n\tbuf[15] = dev_sel;  \n\n\tbuf[16] = (1 << 5) | ATA_REG_NSECT;\n\tbuf[17] = qc->tf.nsect;\n\tbuf[18] = (1 << 5) | ATA_REG_LBAL;\n\tbuf[19] = qc->tf.lbal;\n\n\t \n\tif (qc->tf.protocol != ATAPI_PROT_DMA)\n\t\tfeature = PDC_FEATURE_ATAPI_PIO;\n\telse\n\t\tfeature = PDC_FEATURE_ATAPI_DMA;\n\n\tbuf[20] = (1 << 5) | ATA_REG_FEATURE;\n\tbuf[21] = feature;\n\tbuf[22] = (1 << 5) | ATA_REG_BYTEL;\n\tbuf[23] = qc->tf.lbam;\n\tbuf[24] = (1 << 5) | ATA_REG_BYTEH;\n\tbuf[25] = qc->tf.lbah;\n\n\t \n\tbuf[26] = (1 << 5) | ATA_REG_CMD;\n\tbuf[27] = qc->tf.command;\n\n\t \n\tbuf[28] = (1 << 5) | ATA_REG_DEVICE | PDC_PKT_WAIT_DRDY;\n\tbuf[29] = dev_sel;\n\n\t \n\tBUG_ON(cdb_len & ~0x1E);\n\n\t \n\tbuf[30] = (((cdb_len >> 1) & 7) << 5) | ATA_REG_DATA | PDC_LAST_REG;\n\tmemcpy(buf+31, cdb, cdb_len);\n}\n\n \nstatic void pdc_fill_sg(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_bmdma_prd *prd = ap->bmdma_prd;\n\tstruct scatterlist *sg;\n\tconst u32 SG_COUNT_ASIC_BUG = 41*4;\n\tunsigned int si, idx;\n\tu32 len;\n\n\tif (!(qc->flags & ATA_QCFLAG_DMAMAP))\n\t\treturn;\n\n\tidx = 0;\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tu32 addr, offset;\n\t\tu32 sg_len;\n\n\t\t \n\t\taddr = (u32) sg_dma_address(sg);\n\t\tsg_len = sg_dma_len(sg);\n\n\t\twhile (sg_len) {\n\t\t\toffset = addr & 0xffff;\n\t\t\tlen = sg_len;\n\t\t\tif ((offset + sg_len) > 0x10000)\n\t\t\t\tlen = 0x10000 - offset;\n\n\t\t\tprd[idx].addr = cpu_to_le32(addr);\n\t\t\tprd[idx].flags_len = cpu_to_le32(len & 0xffff);\n\t\t\tata_port_dbg(ap, \"PRD[%u] = (0x%X, 0x%X)\\n\",\n\t\t\t\t     idx, addr, len);\n\n\t\t\tidx++;\n\t\t\tsg_len -= len;\n\t\t\taddr += len;\n\t\t}\n\t}\n\n\tlen = le32_to_cpu(prd[idx - 1].flags_len);\n\n\tif (len > SG_COUNT_ASIC_BUG) {\n\t\tu32 addr;\n\n\t\taddr = le32_to_cpu(prd[idx - 1].addr);\n\t\tprd[idx - 1].flags_len = cpu_to_le32(len - SG_COUNT_ASIC_BUG);\n\t\tata_port_dbg(ap, \"PRD[%u] = (0x%X, 0x%X)\\n\",\n\t\t\t     idx - 1, addr, SG_COUNT_ASIC_BUG);\n\n\t\taddr = addr + len - SG_COUNT_ASIC_BUG;\n\t\tlen = SG_COUNT_ASIC_BUG;\n\t\tprd[idx].addr = cpu_to_le32(addr);\n\t\tprd[idx].flags_len = cpu_to_le32(len);\n\t\tata_port_dbg(ap, \"PRD[%u] = (0x%X, 0x%X)\\n\", idx, addr, len);\n\n\t\tidx++;\n\t}\n\n\tprd[idx - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);\n}\n\nstatic enum ata_completion_errors pdc_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct pdc_port_priv *pp = qc->ap->private_data;\n\tunsigned int i;\n\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\t\tpdc_fill_sg(qc);\n\t\tfallthrough;\n\tcase ATA_PROT_NODATA:\n\t\ti = pdc_pkt_header(&qc->tf, qc->ap->bmdma_prd_dma,\n\t\t\t\t   qc->dev->devno, pp->pkt);\n\t\tif (qc->tf.flags & ATA_TFLAG_LBA48)\n\t\t\ti = pdc_prep_lba48(&qc->tf, pp->pkt, i);\n\t\telse\n\t\t\ti = pdc_prep_lba28(&qc->tf, pp->pkt, i);\n\t\tpdc_pkt_footer(&qc->tf, pp->pkt, i);\n\t\tbreak;\n\tcase ATAPI_PROT_PIO:\n\t\tpdc_fill_sg(qc);\n\t\tbreak;\n\tcase ATAPI_PROT_DMA:\n\t\tpdc_fill_sg(qc);\n\t\tfallthrough;\n\tcase ATAPI_PROT_NODATA:\n\t\tpdc_atapi_pkt(qc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn AC_ERR_OK;\n}\n\nstatic int pdc_is_sataii_tx4(unsigned long flags)\n{\n\tconst unsigned long mask = PDC_FLAG_GEN_II | PDC_FLAG_4_PORTS;\n\treturn (flags & mask) == mask;\n}\n\nstatic unsigned int pdc_port_no_to_ata_no(unsigned int port_no,\n\t\t\t\t\t  int is_sataii_tx4)\n{\n\tstatic const unsigned char sataii_tx4_port_remap[4] = { 3, 1, 0, 2};\n\treturn is_sataii_tx4 ? sataii_tx4_port_remap[port_no] : port_no;\n}\n\nstatic unsigned int pdc_sata_nr_ports(const struct ata_port *ap)\n{\n\treturn (ap->flags & PDC_FLAG_4_PORTS) ? 4 : 2;\n}\n\nstatic unsigned int pdc_sata_ata_port_to_ata_no(const struct ata_port *ap)\n{\n\tconst struct ata_host *host = ap->host;\n\tunsigned int nr_ports = pdc_sata_nr_ports(ap);\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_ports && host->ports[i] != ap; ++i)\n\t\t;\n\tBUG_ON(i >= nr_ports);\n\treturn pdc_port_no_to_ata_no(i, pdc_is_sataii_tx4(ap->flags));\n}\n\nstatic void pdc_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\tu32 tmp;\n\n\ttmp = readl(ata_mmio + PDC_CTLSTAT);\n\ttmp |= PDC_IRQ_DISABLE;\n\ttmp &= ~PDC_DMA_ENABLE;\n\twritel(tmp, ata_mmio + PDC_CTLSTAT);\n\treadl(ata_mmio + PDC_CTLSTAT);  \n}\n\nstatic void pdc_sata_freeze(struct ata_port *ap)\n{\n\tstruct ata_host *host = ap->host;\n\tvoid __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];\n\tunsigned int hotplug_offset = PDC2_SATA_PLUG_CSR;\n\tunsigned int ata_no = pdc_sata_ata_port_to_ata_no(ap);\n\tu32 hotplug_status;\n\n\t \n\thotplug_status = readl(host_mmio + hotplug_offset);\n\thotplug_status |= 0x11 << (ata_no + 16);\n\twritel(hotplug_status, host_mmio + hotplug_offset);\n\treadl(host_mmio + hotplug_offset);  \n\n\tpdc_freeze(ap);\n}\n\nstatic void pdc_thaw(struct ata_port *ap)\n{\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\tu32 tmp;\n\n\t \n\treadl(ata_mmio + PDC_COMMAND);\n\n\t \n\ttmp = readl(ata_mmio + PDC_CTLSTAT);\n\ttmp &= ~PDC_IRQ_DISABLE;\n\twritel(tmp, ata_mmio + PDC_CTLSTAT);\n\treadl(ata_mmio + PDC_CTLSTAT);  \n}\n\nstatic void pdc_sata_thaw(struct ata_port *ap)\n{\n\tstruct ata_host *host = ap->host;\n\tvoid __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];\n\tunsigned int hotplug_offset = PDC2_SATA_PLUG_CSR;\n\tunsigned int ata_no = pdc_sata_ata_port_to_ata_no(ap);\n\tu32 hotplug_status;\n\n\tpdc_thaw(ap);\n\n\t \n\thotplug_status = readl(host_mmio + hotplug_offset);\n\thotplug_status |= 0x11 << ata_no;\n\thotplug_status &= ~(0x11 << (ata_no + 16));\n\twritel(hotplug_status, host_mmio + hotplug_offset);\n\treadl(host_mmio + hotplug_offset);  \n}\n\nstatic int pdc_pata_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tpdc_reset_port(link->ap);\n\treturn ata_sff_softreset(link, class, deadline);\n}\n\nstatic unsigned int pdc_ata_port_to_ata_no(const struct ata_port *ap)\n{\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\tvoid __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];\n\n\t \n\treturn (ata_mmio - host_mmio - 0x200) / 0x80;\n}\n\nstatic void pdc_hard_reset_port(struct ata_port *ap)\n{\n\tvoid __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];\n\tvoid __iomem *pcictl_b1_mmio = host_mmio + PDC_PCI_CTL + 1;\n\tunsigned int ata_no = pdc_ata_port_to_ata_no(ap);\n\tstruct pdc_host_priv *hpriv = ap->host->private_data;\n\tu8 tmp;\n\n\tspin_lock(&hpriv->hard_reset_lock);\n\n\ttmp = readb(pcictl_b1_mmio);\n\ttmp &= ~(0x10 << ata_no);\n\twriteb(tmp, pcictl_b1_mmio);\n\treadb(pcictl_b1_mmio);  \n\tudelay(100);\n\ttmp |= (0x10 << ata_no);\n\twriteb(tmp, pcictl_b1_mmio);\n\treadb(pcictl_b1_mmio);  \n\n\tspin_unlock(&hpriv->hard_reset_lock);\n}\n\nstatic int pdc_sata_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tif (link->ap->flags & PDC_FLAG_GEN_II)\n\t\tpdc_not_at_command_packet_phase(link->ap);\n\t \n\tpdc_hard_reset_port(link->ap);\n\tpdc_reset_port(link->ap);\n\n\t \n\treturn sata_std_hardreset(link, class, deadline);\n}\n\nstatic void pdc_error_handler(struct ata_port *ap)\n{\n\tif (!ata_port_is_frozen(ap))\n\t\tpdc_reset_port(ap);\n\n\tata_sff_error_handler(ap);\n}\n\nstatic void pdc_post_internal_cmd(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\t \n\tif (qc->flags & ATA_QCFLAG_EH)\n\t\tpdc_reset_port(ap);\n}\n\nstatic void pdc_error_intr(struct ata_port *ap, struct ata_queued_cmd *qc,\n\t\t\t   u32 port_status, u32 err_mask)\n{\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tunsigned int ac_err_mask = 0;\n\n\tata_ehi_clear_desc(ehi);\n\tata_ehi_push_desc(ehi, \"port_status 0x%08x\", port_status);\n\tport_status &= err_mask;\n\n\tif (port_status & PDC_DRIVE_ERR)\n\t\tac_err_mask |= AC_ERR_DEV;\n\tif (port_status & (PDC_OVERRUN_ERR | PDC_UNDERRUN_ERR))\n\t\tac_err_mask |= AC_ERR_OTHER;\n\tif (port_status & (PDC2_ATA_HBA_ERR | PDC2_ATA_DMA_CNT_ERR))\n\t\tac_err_mask |= AC_ERR_ATA_BUS;\n\tif (port_status & (PDC_PH_ERR | PDC_SH_ERR | PDC_DH_ERR | PDC2_HTO_ERR\n\t\t\t   | PDC_PCI_SYS_ERR | PDC1_PCI_PARITY_ERR))\n\t\tac_err_mask |= AC_ERR_HOST_BUS;\n\n\tif (sata_scr_valid(&ap->link)) {\n\t\tu32 serror;\n\n\t\tpdc_sata_scr_read(&ap->link, SCR_ERROR, &serror);\n\t\tehi->serror |= serror;\n\t}\n\n\tqc->err_mask |= ac_err_mask;\n\n\tpdc_reset_port(ap);\n\n\tata_port_abort(ap);\n}\n\nstatic unsigned int pdc_host_intr(struct ata_port *ap,\n\t\t\t\t  struct ata_queued_cmd *qc)\n{\n\tunsigned int handled = 0;\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\tu32 port_status, err_mask;\n\n\terr_mask = PDC_ERR_MASK;\n\tif (ap->flags & PDC_FLAG_GEN_II)\n\t\terr_mask &= ~PDC1_ERR_MASK;\n\telse\n\t\terr_mask &= ~PDC2_ERR_MASK;\n\tport_status = readl(ata_mmio + PDC_GLOBAL_CTL);\n\tif (unlikely(port_status & err_mask)) {\n\t\tpdc_error_intr(ap, qc, port_status, err_mask);\n\t\treturn 1;\n\t}\n\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\tcase ATA_PROT_NODATA:\n\tcase ATAPI_PROT_DMA:\n\tcase ATAPI_PROT_NODATA:\n\t\tqc->err_mask |= ac_err_mask(ata_wait_idle(ap));\n\t\tata_qc_complete(qc);\n\t\thandled = 1;\n\t\tbreak;\n\tdefault:\n\t\tap->stats.idle_irq++;\n\t\tbreak;\n\t}\n\n\treturn handled;\n}\n\nstatic void pdc_irq_clear(struct ata_port *ap)\n{\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\n\treadl(ata_mmio + PDC_COMMAND);\n}\n\nstatic irqreturn_t pdc_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct ata_port *ap;\n\tu32 mask = 0;\n\tunsigned int i, tmp;\n\tunsigned int handled = 0;\n\tvoid __iomem *host_mmio;\n\tunsigned int hotplug_offset, ata_no;\n\tu32 hotplug_status;\n\tint is_sataii_tx4;\n\n\tif (!host || !host->iomap[PDC_MMIO_BAR])\n\t\treturn IRQ_NONE;\n\n\thost_mmio = host->iomap[PDC_MMIO_BAR];\n\n\tspin_lock(&host->lock);\n\n\t \n\tif (host->ports[0]->flags & PDC_FLAG_GEN_II) {\n\t\thotplug_offset = PDC2_SATA_PLUG_CSR;\n\t\thotplug_status = readl(host_mmio + hotplug_offset);\n\t\tif (hotplug_status & 0xff)\n\t\t\twritel(hotplug_status | 0xff, host_mmio + hotplug_offset);\n\t\thotplug_status &= 0xff;\t \n\t} else\n\t\thotplug_status = 0;\n\n\t \n\tmask = readl(host_mmio + PDC_INT_SEQMASK);\n\n\tif (mask == 0xffffffff && hotplug_status == 0)\n\t\tgoto done_irq;\n\n\tmask &= 0xffff;\t\t \n\tif (mask == 0 && hotplug_status == 0)\n\t\tgoto done_irq;\n\n\twritel(mask, host_mmio + PDC_INT_SEQMASK);\n\n\tis_sataii_tx4 = pdc_is_sataii_tx4(host->ports[0]->flags);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tap = host->ports[i];\n\n\t\t \n\t\tata_no = pdc_port_no_to_ata_no(i, is_sataii_tx4);\n\t\ttmp = hotplug_status & (0x11 << ata_no);\n\t\tif (tmp) {\n\t\t\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\t\t\tata_ehi_clear_desc(ehi);\n\t\t\tata_ehi_hotplugged(ehi);\n\t\t\tata_ehi_push_desc(ehi, \"hotplug_status %#x\", tmp);\n\t\t\tata_port_freeze(ap);\n\t\t\t++handled;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttmp = mask & (1 << (i + 1));\n\t\tif (tmp) {\n\t\t\tstruct ata_queued_cmd *qc;\n\n\t\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\t\t\tif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)))\n\t\t\t\thandled += pdc_host_intr(ap, qc);\n\t\t}\n\t}\n\ndone_irq:\n\tspin_unlock(&host->lock);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void pdc_packet_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pdc_port_priv *pp = ap->private_data;\n\tvoid __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];\n\tvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\n\tunsigned int port_no = ap->port_no;\n\tu8 seq = (u8) (port_no + 1);\n\n\twritel(0x00000001, host_mmio + (seq * 4));\n\treadl(host_mmio + (seq * 4));\t \n\n\tpp->pkt[2] = seq;\n\twmb();\t\t\t \n\twritel(pp->pkt_dma, ata_mmio + PDC_PKT_SUBMIT);\n\treadl(ata_mmio + PDC_PKT_SUBMIT);  \n}\n\nstatic unsigned int pdc_qc_issue(struct ata_queued_cmd *qc)\n{\n\tswitch (qc->tf.protocol) {\n\tcase ATAPI_PROT_NODATA:\n\t\tif (qc->dev->flags & ATA_DFLAG_CDB_INTR)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase ATA_PROT_NODATA:\n\t\tif (qc->tf.flags & ATA_TFLAG_POLLING)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase ATAPI_PROT_DMA:\n\tcase ATA_PROT_DMA:\n\t\tpdc_packet_start(qc);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic void pdc_tf_load_mmio(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tWARN_ON(tf->protocol == ATA_PROT_DMA || tf->protocol == ATAPI_PROT_DMA);\n\tata_sff_tf_load(ap, tf);\n}\n\nstatic void pdc_exec_command_mmio(struct ata_port *ap,\n\t\t\t\t  const struct ata_taskfile *tf)\n{\n\tWARN_ON(tf->protocol == ATA_PROT_DMA || tf->protocol == ATAPI_PROT_DMA);\n\tata_sff_exec_command(ap, tf);\n}\n\nstatic int pdc_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\tu8 *scsicmd = qc->scsicmd->cmnd;\n\tint pio = 1;  \n\n\t \n\tswitch (scsicmd[0]) {\n\tcase WRITE_12:\n\tcase WRITE_10:\n\tcase WRITE_6:\n\tcase READ_12:\n\tcase READ_10:\n\tcase READ_6:\n\tcase 0xad:  \n\tcase 0xbe:  \n\t\tpio = 0;\n\t}\n\t \n\tif (scsicmd[0] == WRITE_10) {\n\t\tunsigned int lba =\n\t\t\t(scsicmd[2] << 24) |\n\t\t\t(scsicmd[3] << 16) |\n\t\t\t(scsicmd[4] << 8) |\n\t\t\tscsicmd[5];\n\t\tif (lba >= 0xFFFF4FA2)\n\t\t\tpio = 1;\n\t}\n\treturn pio;\n}\n\nstatic int pdc_old_sata_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\t \n\treturn 1;\n}\n\nstatic void pdc_ata_setup_port(struct ata_port *ap,\n\t\t\t       void __iomem *base, void __iomem *scr_addr)\n{\n\tap->ioaddr.cmd_addr\t\t= base;\n\tap->ioaddr.data_addr\t\t= base;\n\tap->ioaddr.feature_addr\t\t=\n\tap->ioaddr.error_addr\t\t= base + 0x4;\n\tap->ioaddr.nsect_addr\t\t= base + 0x8;\n\tap->ioaddr.lbal_addr\t\t= base + 0xc;\n\tap->ioaddr.lbam_addr\t\t= base + 0x10;\n\tap->ioaddr.lbah_addr\t\t= base + 0x14;\n\tap->ioaddr.device_addr\t\t= base + 0x18;\n\tap->ioaddr.command_addr\t\t=\n\tap->ioaddr.status_addr\t\t= base + 0x1c;\n\tap->ioaddr.altstatus_addr\t=\n\tap->ioaddr.ctl_addr\t\t= base + 0x38;\n\tap->ioaddr.scr_addr\t\t= scr_addr;\n}\n\nstatic void pdc_host_init(struct ata_host *host)\n{\n\tvoid __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];\n\tint is_gen2 = host->ports[0]->flags & PDC_FLAG_GEN_II;\n\tint hotplug_offset;\n\tu32 tmp;\n\n\tif (is_gen2)\n\t\thotplug_offset = PDC2_SATA_PLUG_CSR;\n\telse\n\t\thotplug_offset = PDC_SATA_PLUG_CSR;\n\n\t \n\n\t \n\ttmp = readl(host_mmio + PDC_FLASH_CTL);\n\ttmp |= 0x02000;\t \n\tif (!is_gen2)\n\t\ttmp |= 0x10000;\t \n\twritel(tmp, host_mmio + PDC_FLASH_CTL);\n\n\t \n\ttmp = readl(host_mmio + hotplug_offset);\n\twritel(tmp | 0xff, host_mmio + hotplug_offset);\n\n\ttmp = readl(host_mmio + hotplug_offset);\n\tif (is_gen2)\t \n\t\twritel(tmp & ~0xff0000, host_mmio + hotplug_offset);\n\telse\t\t \n\t\twritel(tmp | 0xff0000, host_mmio + hotplug_offset);\n\n\t \n\tif (is_gen2)\n\t\treturn;\n\n\t \n\ttmp = readl(host_mmio + PDC_TBG_MODE);\n\ttmp &= ~0x30000;  \n\ttmp |= 0x10000;   \n\twritel(tmp, host_mmio + PDC_TBG_MODE);\n\n\treadl(host_mmio + PDC_TBG_MODE);\t \n\tmsleep(10);\n\n\t \n\ttmp = readl(host_mmio + PDC_SLEW_CTL);\n\ttmp &= 0xFFFFF03F;  \n\ttmp  |= 0x00000900;  \n\twritel(tmp, host_mmio + PDC_SLEW_CTL);\n}\n\nstatic int pdc_ata_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tconst struct ata_port_info *pi = &pdc_port_info[ent->driver_data];\n\tconst struct ata_port_info *ppi[PDC_MAX_PORTS];\n\tstruct ata_host *host;\n\tstruct pdc_host_priv *hpriv;\n\tvoid __iomem *host_mmio;\n\tint n_ports, i, rc;\n\tint is_sataii_tx4;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev, 1 << PDC_MMIO_BAR, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost_mmio = pcim_iomap_table(pdev)[PDC_MMIO_BAR];\n\n\t \n\tn_ports = 2;\n\tif (pi->flags & PDC_FLAG_4_PORTS)\n\t\tn_ports = 4;\n\tfor (i = 0; i < n_ports; i++)\n\t\tppi[i] = pi;\n\n\tif (pi->flags & PDC_FLAG_SATA_PATA) {\n\t\tu8 tmp = readb(host_mmio + PDC_FLASH_CTL + 1);\n\t\tif (!(tmp & 0x80))\n\t\t\tppi[n_ports++] = pi + 1;\n\t}\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"failed to allocate host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thpriv = devm_kzalloc(&pdev->dev, sizeof *hpriv, GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&hpriv->hard_reset_lock);\n\thost->private_data = hpriv;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\tis_sataii_tx4 = pdc_is_sataii_tx4(pi->flags);\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tunsigned int ata_no = pdc_port_no_to_ata_no(i, is_sataii_tx4);\n\t\tunsigned int ata_offset = 0x200 + ata_no * 0x80;\n\t\tunsigned int scr_offset = 0x400 + ata_no * 0x100;\n\n\t\tpdc_ata_setup_port(ap, host_mmio + ata_offset, host_mmio + scr_offset);\n\n\t\tata_port_pbar_desc(ap, PDC_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, PDC_MMIO_BAR, ata_offset, \"ata\");\n\t}\n\n\t \n\tpdc_host_init(host);\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, pdc_interrupt, IRQF_SHARED,\n\t\t\t\t &pdc_ata_sht);\n}\n\nmodule_pci_driver(pdc_ata_pci_driver);\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"Promise ATA TX2/TX4/TX4000 low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pdc_ata_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}