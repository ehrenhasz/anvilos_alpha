{
  "module_name": "pata_octeon_cf.c",
  "hash_id": "495b007b03dffa9a14e3f4d36b46560855c318ac9fd3d6d7d4e9e0b68d7ee34d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_octeon_cf.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/libata.h>\n#include <linux/hrtimer.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <scsi/scsi_host.h>\n#include <trace/events/libata.h>\n#include <asm/byteorder.h>\n#include <asm/octeon/octeon.h>\n\n \n\n#define DRV_NAME\t\"pata_octeon_cf\"\n#define DRV_VERSION\t\"2.2\"\n\n \n#define OCTEON_CF_BUSY_POLL_INTERVAL 500000\n\n#define DMA_CFG 0\n#define DMA_TIM 0x20\n#define DMA_INT 0x38\n#define DMA_INT_EN 0x50\n\nstruct octeon_cf_port {\n\tstruct hrtimer delayed_finish;\n\tstruct ata_port *ap;\n\tint dma_finished;\n\tvoid\t\t*c0;\n\tunsigned int cs0;\n\tunsigned int cs1;\n\tbool is_true_ide;\n\tu64 dma_base;\n};\n\nstatic const struct scsi_host_template octeon_cf_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic int enable_dma;\nmodule_param(enable_dma, int, 0444);\nMODULE_PARM_DESC(enable_dma,\n\t\t \"Enable use of DMA on interfaces that support it (0=no dma [default], 1=use dma)\");\n\n \nstatic unsigned int ns_to_tim_reg(unsigned int tim_mult, unsigned int nsecs)\n{\n\t \n\treturn DIV_ROUND_UP(nsecs * (octeon_get_io_clock_rate() / 1000000),\n\t\t\t  1000 * tim_mult);\n}\n\nstatic void octeon_cf_set_boot_reg_cfg(int cs, unsigned int multiplier)\n{\n\tunion cvmx_mio_boot_reg_cfgx reg_cfg;\n\tunsigned int tim_mult;\n\n\tswitch (multiplier) {\n\tcase 8:\n\t\ttim_mult = 3;\n\t\tbreak;\n\tcase 4:\n\t\ttim_mult = 0;\n\t\tbreak;\n\tcase 2:\n\t\ttim_mult = 2;\n\t\tbreak;\n\tdefault:\n\t\ttim_mult = 1;\n\t\tbreak;\n\t}\n\n\treg_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(cs));\n\treg_cfg.s.dmack = 0;\t \n\treg_cfg.s.tim_mult = tim_mult;\t \n\treg_cfg.s.rd_dly = 0;\t \n\treg_cfg.s.sam = 0;\t \n\treg_cfg.s.we_ext = 0;\t \n\treg_cfg.s.oe_ext = 0;\t \n\treg_cfg.s.en = 1;\t \n\treg_cfg.s.orbit = 0;\t \n\treg_cfg.s.ale = 0;\t \n\tcvmx_write_csr(CVMX_MIO_BOOT_REG_CFGX(cs), reg_cfg.u64);\n}\n\n \nstatic void octeon_cf_set_piomode(struct ata_port *ap, struct ata_device *dev)\n{\n\tstruct octeon_cf_port *cf_port = ap->private_data;\n\tunion cvmx_mio_boot_reg_timx reg_tim;\n\tint T;\n\tstruct ata_timing timing;\n\n\tunsigned int div;\n\tint use_iordy;\n\tint trh;\n\tint pause;\n\t \n\tint t2;\n\n\t \n\tif (octeon_get_io_clock_rate() <= 800000000)\n\t\tdiv = 4;\n\telse\n\t\tdiv = 8;\n\tT = (int)((1000000000000LL * div) / octeon_get_io_clock_rate());\n\n\tBUG_ON(ata_timing_compute(dev, dev->pio_mode, &timing, T, T));\n\n\tt2 = timing.active;\n\tif (t2)\n\t\tt2--;\n\n\ttrh = ns_to_tim_reg(div, 20);\n\tif (trh)\n\t\ttrh--;\n\n\tpause = (int)timing.cycle - (int)timing.active -\n\t\t(int)timing.setup - trh;\n\tif (pause < 0)\n\t\tpause = 0;\n\tif (pause)\n\t\tpause--;\n\n\tocteon_cf_set_boot_reg_cfg(cf_port->cs0, div);\n\tif (cf_port->is_true_ide)\n\t\t \n\t\tocteon_cf_set_boot_reg_cfg(cf_port->cs1, div);\n\n\n\tuse_iordy = ata_pio_need_iordy(dev);\n\n\treg_tim.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs0));\n\t \n\treg_tim.s.pagem = 0;\n\t \n\treg_tim.s.waitm = use_iordy;\n\t \n\treg_tim.s.pages = 0;\n\t \n\treg_tim.s.ale = 0;\n\t \n\treg_tim.s.page = 0;\n\t \n\treg_tim.s.wait = 0;\n\t \n\treg_tim.s.pause = pause;\n\t \n\treg_tim.s.wr_hld = trh;\n\t \n\treg_tim.s.rd_hld = trh;\n\t \n\treg_tim.s.we = t2;\n\t \n\treg_tim.s.oe = t2;\n\t \n\treg_tim.s.ce = ns_to_tim_reg(div, 5);\n\t \n\treg_tim.s.adr = 0;\n\n\t \n\tcvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs0), reg_tim.u64);\n\tif (cf_port->is_true_ide)\n\t\t \n\t\tcvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs1),\n\t\t\t       reg_tim.u64);\n}\n\nstatic void octeon_cf_set_dmamode(struct ata_port *ap, struct ata_device *dev)\n{\n\tstruct octeon_cf_port *cf_port = ap->private_data;\n\tunion cvmx_mio_boot_pin_defs pin_defs;\n\tunion cvmx_mio_boot_dma_timx dma_tim;\n\tunsigned int oe_a;\n\tunsigned int oe_n;\n\tunsigned int dma_ackh;\n\tunsigned int dma_arq;\n\tunsigned int pause;\n\tunsigned int T0, Tkr, Td;\n\tunsigned int tim_mult;\n\tint c;\n\n\tconst struct ata_timing *timing;\n\n\ttiming = ata_timing_find_mode(dev->dma_mode);\n\tT0\t= timing->cycle;\n\tTd\t= timing->active;\n\tTkr\t= timing->recover;\n\tdma_ackh = timing->dmack_hold;\n\n\tdma_tim.u64 = 0;\n\t \n\ttim_mult = 4;\n\n\t \n\tdma_arq = 8;\n\tpause = 25 - dma_arq * 1000 /\n\t\t(octeon_get_io_clock_rate() / 1000000);  \n\n\toe_a = Td;\n\t \n\toe_n = max(T0 - oe_a, Tkr);\n\n\tpin_defs.u64 = cvmx_read_csr(CVMX_MIO_BOOT_PIN_DEFS);\n\n\t \n\tc = (cf_port->dma_base & 8) >> 3;\n\n\t \n\tdma_tim.s.dmack_pi = (pin_defs.u64 & (1ull << (11 + c))) ? 0 : 1;\n\n\tdma_tim.s.oe_n = ns_to_tim_reg(tim_mult, oe_n);\n\tdma_tim.s.oe_a = ns_to_tim_reg(tim_mult, oe_a);\n\n\t \n\tdma_tim.s.dmack_s = ns_to_tim_reg(tim_mult, 20);\n\tdma_tim.s.dmack_h = ns_to_tim_reg(tim_mult, dma_ackh);\n\n\tdma_tim.s.dmarq = dma_arq;\n\tdma_tim.s.pause = ns_to_tim_reg(tim_mult, pause);\n\n\tdma_tim.s.rd_dly = 0;\t \n\n\t \n\tdma_tim.s.we_n = ns_to_tim_reg(tim_mult, oe_n);\n\tdma_tim.s.we_a = ns_to_tim_reg(tim_mult, oe_a);\n\n\tata_dev_dbg(dev, \"ns to ticks (mult %d) of %d is: %d\\n\", tim_mult, 60,\n\t\t ns_to_tim_reg(tim_mult, 60));\n\tata_dev_dbg(dev, \"oe_n: %d, oe_a: %d, dmack_s: %d, dmack_h: %d, dmarq: %d, pause: %d\\n\",\n\t\t dma_tim.s.oe_n, dma_tim.s.oe_a, dma_tim.s.dmack_s,\n\t\t dma_tim.s.dmack_h, dma_tim.s.dmarq, dma_tim.s.pause);\n\n\tcvmx_write_csr(cf_port->dma_base + DMA_TIM, dma_tim.u64);\n}\n\n \nstatic unsigned int octeon_cf_data_xfer8(struct ata_queued_cmd *qc,\n\t\t\t\t\t unsigned char *buffer,\n\t\t\t\t\t unsigned int buflen,\n\t\t\t\t\t int rw)\n{\n\tstruct ata_port *ap\t\t= qc->dev->link->ap;\n\tvoid __iomem *data_addr\t\t= ap->ioaddr.data_addr;\n\tunsigned long words;\n\tint count;\n\n\twords = buflen;\n\tif (rw) {\n\t\tcount = 16;\n\t\twhile (words--) {\n\t\t\tiowrite8(*buffer, data_addr);\n\t\t\tbuffer++;\n\t\t\t \n\t\t\tif (--count == 0) {\n\t\t\t\tioread8(ap->ioaddr.altstatus_addr);\n\t\t\t\tcount = 16;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tioread8_rep(data_addr, buffer, words);\n\t}\n\treturn buflen;\n}\n\n \nstatic unsigned int octeon_cf_data_xfer16(struct ata_queued_cmd *qc,\n\t\t\t\t\t  unsigned char *buffer,\n\t\t\t\t\t  unsigned int buflen,\n\t\t\t\t\t  int rw)\n{\n\tstruct ata_port *ap\t\t= qc->dev->link->ap;\n\tvoid __iomem *data_addr\t\t= ap->ioaddr.data_addr;\n\tunsigned long words;\n\tint count;\n\n\twords = buflen / 2;\n\tif (rw) {\n\t\tcount = 16;\n\t\twhile (words--) {\n\t\t\tiowrite16(*(uint16_t *)buffer, data_addr);\n\t\t\tbuffer += sizeof(uint16_t);\n\t\t\t \n\t\t\tif (--count == 0) {\n\t\t\t\tioread8(ap->ioaddr.altstatus_addr);\n\t\t\t\tcount = 16;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (words--) {\n\t\t\t*(uint16_t *)buffer = ioread16(data_addr);\n\t\t\tbuffer += sizeof(uint16_t);\n\t\t}\n\t}\n\t \n\tif (unlikely(buflen & 0x01)) {\n\t\t__le16 align_buf[1] = { 0 };\n\n\t\tif (rw == READ) {\n\t\t\talign_buf[0] = cpu_to_le16(ioread16(data_addr));\n\t\t\tmemcpy(buffer, align_buf, 1);\n\t\t} else {\n\t\t\tmemcpy(align_buf, buffer, 1);\n\t\t\tiowrite16(le16_to_cpu(align_buf[0]), data_addr);\n\t\t}\n\t\twords++;\n\t}\n\treturn buflen;\n}\n\n \nstatic void octeon_cf_tf_read16(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tu16 blob;\n\t \n\tvoid __iomem *base = ap->ioaddr.data_addr;\n\n\tblob = __raw_readw(base + 0xc);\n\ttf->error = blob >> 8;\n\n\tblob = __raw_readw(base + 2);\n\ttf->nsect = blob & 0xff;\n\ttf->lbal = blob >> 8;\n\n\tblob = __raw_readw(base + 4);\n\ttf->lbam = blob & 0xff;\n\ttf->lbah = blob >> 8;\n\n\tblob = __raw_readw(base + 6);\n\ttf->device = blob & 0xff;\n\ttf->status = blob >> 8;\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\tif (likely(ap->ioaddr.ctl_addr)) {\n\t\t\tiowrite8(tf->ctl | ATA_HOB, ap->ioaddr.ctl_addr);\n\n\t\t\tblob = __raw_readw(base + 0xc);\n\t\t\ttf->hob_feature = blob >> 8;\n\n\t\t\tblob = __raw_readw(base + 2);\n\t\t\ttf->hob_nsect = blob & 0xff;\n\t\t\ttf->hob_lbal = blob >> 8;\n\n\t\t\tblob = __raw_readw(base + 4);\n\t\t\ttf->hob_lbam = blob & 0xff;\n\t\t\ttf->hob_lbah = blob >> 8;\n\n\t\t\tiowrite8(tf->ctl, ap->ioaddr.ctl_addr);\n\t\t\tap->last_ctl = tf->ctl;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n}\n\nstatic u8 octeon_cf_check_status16(struct ata_port *ap)\n{\n\tu16 blob;\n\tvoid __iomem *base = ap->ioaddr.data_addr;\n\n\tblob = __raw_readw(base + 6);\n\treturn blob >> 8;\n}\n\nstatic int octeon_cf_softreset16(struct ata_link *link, unsigned int *classes,\n\t\t\t\t unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *base = ap->ioaddr.data_addr;\n\tint rc;\n\tu8 err;\n\n\t__raw_writew(ap->ctl, base + 0xe);\n\tudelay(20);\n\t__raw_writew(ap->ctl | ATA_SRST, base + 0xe);\n\tudelay(20);\n\t__raw_writew(ap->ctl, base + 0xe);\n\n\trc = ata_sff_wait_after_reset(link, 1, deadline);\n\tif (rc) {\n\t\tata_link_err(link, \"SRST failed (errno=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tclasses[0] = ata_sff_dev_classify(&link->device[0], 1, &err);\n\treturn 0;\n}\n\n \nstatic void octeon_cf_tf_load16(struct ata_port *ap,\n\t\t\t\tconst struct ata_taskfile *tf)\n{\n\tunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\n\t \n\tvoid __iomem *base = ap->ioaddr.data_addr;\n\n\tif (tf->ctl != ap->last_ctl) {\n\t\tiowrite8(tf->ctl, ap->ioaddr.ctl_addr);\n\t\tap->last_ctl = tf->ctl;\n\t\tata_wait_idle(ap);\n\t}\n\tif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\n\t\t__raw_writew(tf->hob_feature << 8, base + 0xc);\n\t\t__raw_writew(tf->hob_nsect | tf->hob_lbal << 8, base + 2);\n\t\t__raw_writew(tf->hob_lbam | tf->hob_lbah << 8, base + 4);\n\t}\n\tif (is_addr) {\n\t\t__raw_writew(tf->feature << 8, base + 0xc);\n\t\t__raw_writew(tf->nsect | tf->lbal << 8, base + 2);\n\t\t__raw_writew(tf->lbam | tf->lbah << 8, base + 4);\n\t}\n\tata_wait_idle(ap);\n}\n\n\nstatic void octeon_cf_dev_select(struct ata_port *ap, unsigned int device)\n{\n \n\treturn;\n}\n\n \nstatic void octeon_cf_exec_command16(struct ata_port *ap,\n\t\t\t\tconst struct ata_taskfile *tf)\n{\n\t \n\tvoid __iomem *base = ap->ioaddr.data_addr;\n\tu16 blob = 0;\n\n\tif (tf->flags & ATA_TFLAG_DEVICE)\n\t\tblob = tf->device;\n\n\tblob |= (tf->command << 8);\n\t__raw_writew(blob, base + 6);\n\n\tata_wait_idle(ap);\n}\n\nstatic void octeon_cf_ata_port_noaction(struct ata_port *ap)\n{\n}\n\nstatic void octeon_cf_dma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct octeon_cf_port *cf_port;\n\n\tcf_port = ap->private_data;\n\t \n\tqc->cursg = qc->sg;\n\tcf_port->dma_finished = 0;\n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\n \nstatic void octeon_cf_dma_start(struct ata_queued_cmd *qc)\n{\n\tstruct octeon_cf_port *cf_port = qc->ap->private_data;\n\tunion cvmx_mio_boot_dma_cfgx mio_boot_dma_cfg;\n\tunion cvmx_mio_boot_dma_intx mio_boot_dma_int;\n\tstruct scatterlist *sg;\n\n\t \n\tsg = qc->cursg;\n\tBUG_ON(!sg);\n\n\t \n\tmio_boot_dma_int.u64 = 0;\n\tmio_boot_dma_int.s.done = 1;\n\tcvmx_write_csr(cf_port->dma_base + DMA_INT, mio_boot_dma_int.u64);\n\n\t \n\tcvmx_write_csr(cf_port->dma_base + DMA_INT_EN, mio_boot_dma_int.u64);\n\n\t \n\tmio_boot_dma_cfg.u64 = 0;\n#ifdef __LITTLE_ENDIAN\n\tmio_boot_dma_cfg.s.endian = 1;\n#endif\n\tmio_boot_dma_cfg.s.en = 1;\n\tmio_boot_dma_cfg.s.rw = ((qc->tf.flags & ATA_TFLAG_WRITE) != 0);\n\n\t \n\tmio_boot_dma_cfg.s.clr = 0;\n\n\t \n\tmio_boot_dma_cfg.s.size = sg_dma_len(sg) / 2 - 1;\n\n\t \n\tmio_boot_dma_cfg.s.swap8 = 1;\n\n\tmio_boot_dma_cfg.s.adr = sg_dma_address(sg);\n\n\tcvmx_write_csr(cf_port->dma_base + DMA_CFG, mio_boot_dma_cfg.u64);\n}\n\n \nstatic unsigned int octeon_cf_dma_finished(struct ata_port *ap,\n\t\t\t\t\tstruct ata_queued_cmd *qc)\n{\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tstruct octeon_cf_port *cf_port = ap->private_data;\n\tunion cvmx_mio_boot_dma_cfgx dma_cfg;\n\tunion cvmx_mio_boot_dma_intx dma_int;\n\tu8 status;\n\n\ttrace_ata_bmdma_stop(ap, &qc->tf, qc->tag);\n\n\tif (ap->hsm_task_state != HSM_ST_LAST)\n\t\treturn 0;\n\n\tdma_cfg.u64 = cvmx_read_csr(cf_port->dma_base + DMA_CFG);\n\tif (dma_cfg.s.size != 0xfffff) {\n\t\t \n\t\tqc->err_mask |= AC_ERR_HOST_BUS;\n\t\tap->hsm_task_state = HSM_ST_ERR;\n\t}\n\n\t \n\tdma_cfg.u64 = 0;\n\tdma_cfg.s.size = -1;\n\tcvmx_write_csr(cf_port->dma_base + DMA_CFG, dma_cfg.u64);\n\n\t \n\tdma_int.u64 = 0;\n\tcvmx_write_csr(cf_port->dma_base + DMA_INT_EN, dma_int.u64);\n\n\t \n\tdma_int.s.done = 1;\n\tcvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);\n\n\tstatus = ap->ops->sff_check_status(ap);\n\n\tata_sff_hsm_move(ap, qc, status, 0);\n\n\tif (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA))\n\t\tata_ehi_push_desc(ehi, \"DMA stat 0x%x\", status);\n\n\treturn 1;\n}\n\n \nstatic irqreturn_t octeon_cf_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct octeon_cf_port *cf_port;\n\tint i;\n\tunsigned int handled = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tu8 status;\n\t\tstruct ata_port *ap;\n\t\tstruct ata_queued_cmd *qc;\n\t\tunion cvmx_mio_boot_dma_intx dma_int;\n\t\tunion cvmx_mio_boot_dma_cfgx dma_cfg;\n\n\t\tap = host->ports[i];\n\t\tcf_port = ap->private_data;\n\n\t\tdma_int.u64 = cvmx_read_csr(cf_port->dma_base + DMA_INT);\n\t\tdma_cfg.u64 = cvmx_read_csr(cf_port->dma_base + DMA_CFG);\n\n\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\n\t\tif (!qc || (qc->tf.flags & ATA_TFLAG_POLLING))\n\t\t\tcontinue;\n\n\t\tif (dma_int.s.done && !dma_cfg.s.en) {\n\t\t\tif (!sg_is_last(qc->cursg)) {\n\t\t\t\tqc->cursg = sg_next(qc->cursg);\n\t\t\t\thandled = 1;\n\t\t\t\ttrace_ata_bmdma_start(ap, &qc->tf, qc->tag);\n\t\t\t\tocteon_cf_dma_start(qc);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcf_port->dma_finished = 1;\n\t\t\t}\n\t\t}\n\t\tif (!cf_port->dma_finished)\n\t\t\tcontinue;\n\t\tstatus = ioread8(ap->ioaddr.altstatus_addr);\n\t\tif (status & (ATA_BUSY | ATA_DRQ)) {\n\t\t\t \n\t\t\t \n\t\t\tdma_int.u64 = 0;\n\t\t\tdma_int.s.done = 1;\n\t\t\tcvmx_write_csr(cf_port->dma_base + DMA_INT,\n\t\t\t\t       dma_int.u64);\n\t\t\thrtimer_start_range_ns(&cf_port->delayed_finish,\n\t\t\t\t\t       ns_to_ktime(OCTEON_CF_BUSY_POLL_INTERVAL),\n\t\t\t\t\t       OCTEON_CF_BUSY_POLL_INTERVAL / 5,\n\t\t\t\t\t       HRTIMER_MODE_REL);\n\t\t\thandled = 1;\n\t\t} else {\n\t\t\thandled |= octeon_cf_dma_finished(ap, qc);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&host->lock, flags);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic enum hrtimer_restart octeon_cf_delayed_finish(struct hrtimer *hrt)\n{\n\tstruct octeon_cf_port *cf_port = container_of(hrt,\n\t\t\t\t\t\t      struct octeon_cf_port,\n\t\t\t\t\t\t      delayed_finish);\n\tstruct ata_port *ap = cf_port->ap;\n\tstruct ata_host *host = ap->host;\n\tstruct ata_queued_cmd *qc;\n\tunsigned long flags;\n\tu8 status;\n\tenum hrtimer_restart rv = HRTIMER_NORESTART;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\t \n\tif (ap->hsm_task_state != HSM_ST_LAST || !cf_port->dma_finished)\n\t\tgoto out;\n\n\tstatus = ioread8(ap->ioaddr.altstatus_addr);\n\tif (status & (ATA_BUSY | ATA_DRQ)) {\n\t\t \n\t\thrtimer_forward_now(hrt,\n\t\t\t\t    ns_to_ktime(OCTEON_CF_BUSY_POLL_INTERVAL));\n\t\trv = HRTIMER_RESTART;\n\t\tgoto out;\n\t}\n\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\tif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)))\n\t\tocteon_cf_dma_finished(ap, qc);\nout:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\treturn rv;\n}\n\nstatic void octeon_cf_dev_config(struct ata_device *dev)\n{\n\t \n\tdev->max_sectors = min(dev->max_sectors, 4095U);\n}\n\n \nstatic int octeon_cf_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn 0;\n}\n\nstatic unsigned int octeon_cf_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\t\tWARN_ON(qc->tf.flags & ATA_TFLAG_POLLING);\n\n\t\ttrace_ata_tf_load(ap, &qc->tf);\n\t\tap->ops->sff_tf_load(ap, &qc->tf);   \n\t\ttrace_ata_bmdma_setup(ap, &qc->tf, qc->tag);\n\t\tocteon_cf_dma_setup(qc);\t     \n\t\ttrace_ata_bmdma_start(ap, &qc->tf, qc->tag);\n\t\tocteon_cf_dma_start(qc);\t     \n\t\tap->hsm_task_state = HSM_ST_LAST;\n\t\tbreak;\n\n\tcase ATAPI_PROT_DMA:\n\t\tdev_err(ap->dev, \"Error, ATAPI not supported\\n\");\n\t\tBUG();\n\n\tdefault:\n\t\treturn ata_sff_qc_issue(qc);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ata_port_operations octeon_cf_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\t.check_atapi_dma\t= octeon_cf_check_atapi_dma,\n\t.qc_prep\t\t= ata_noop_qc_prep,\n\t.qc_issue\t\t= octeon_cf_qc_issue,\n\t.sff_dev_select\t\t= octeon_cf_dev_select,\n\t.sff_irq_on\t\t= octeon_cf_ata_port_noaction,\n\t.sff_irq_clear\t\t= octeon_cf_ata_port_noaction,\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= octeon_cf_set_piomode,\n\t.set_dmamode\t\t= octeon_cf_set_dmamode,\n\t.dev_config\t\t= octeon_cf_dev_config,\n};\n\nstatic int octeon_cf_probe(struct platform_device *pdev)\n{\n\tstruct resource *res_cs0, *res_cs1;\n\n\tbool is_16bit;\n\tu64 reg;\n\tstruct device_node *node;\n\tvoid __iomem *cs0;\n\tvoid __iomem *cs1 = NULL;\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tint irq = 0;\n\tirq_handler_t irq_handler = NULL;\n\tvoid __iomem *base;\n\tstruct octeon_cf_port *cf_port;\n\tu32 bus_width;\n\tint rv;\n\n\tnode = pdev->dev.of_node;\n\tif (node == NULL)\n\t\treturn -EINVAL;\n\n\tcf_port = devm_kzalloc(&pdev->dev, sizeof(*cf_port), GFP_KERNEL);\n\tif (!cf_port)\n\t\treturn -ENOMEM;\n\n\tcf_port->is_true_ide = of_property_read_bool(node, \"cavium,true-ide\");\n\n\tif (of_property_read_u32(node, \"cavium,bus-width\", &bus_width) == 0)\n\t\tis_16bit = (bus_width == 16);\n\telse\n\t\tis_16bit = false;\n\n\trv = of_property_read_reg(node, 0, &reg, NULL);\n\tif (rv < 0)\n\t\treturn rv;\n\tcf_port->cs0 = upper_32_bits(reg);\n\n\tif (cf_port->is_true_ide) {\n\t\tstruct device_node *dma_node;\n\t\tdma_node = of_parse_phandle(node,\n\t\t\t\t\t    \"cavium,dma-engine-handle\", 0);\n\t\tif (dma_node) {\n\t\t\tstruct platform_device *dma_dev;\n\t\t\tdma_dev = of_find_device_by_node(dma_node);\n\t\t\tif (dma_dev) {\n\t\t\t\tstruct resource *res_dma;\n\t\t\t\tint i;\n\t\t\t\tres_dma = platform_get_resource(dma_dev, IORESOURCE_MEM, 0);\n\t\t\t\tif (!res_dma) {\n\t\t\t\t\tput_device(&dma_dev->dev);\n\t\t\t\t\tof_node_put(dma_node);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tcf_port->dma_base = (u64)devm_ioremap(&pdev->dev, res_dma->start,\n\t\t\t\t\t\t\t\t\t resource_size(res_dma));\n\t\t\t\tif (!cf_port->dma_base) {\n\t\t\t\t\tput_device(&dma_dev->dev);\n\t\t\t\t\tof_node_put(dma_node);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\ti = platform_get_irq(dma_dev, 0);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tirq = i;\n\t\t\t\t\tirq_handler = octeon_cf_interrupt;\n\t\t\t\t}\n\t\t\t\tput_device(&dma_dev->dev);\n\t\t\t}\n\t\t\tof_node_put(dma_node);\n\t\t}\n\t\tres_cs1 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\tif (!res_cs1)\n\t\t\treturn -EINVAL;\n\n\t\tcs1 = devm_ioremap(&pdev->dev, res_cs1->start,\n\t\t\t\t\t   resource_size(res_cs1));\n\t\tif (!cs1)\n\t\t\treturn -EINVAL;\n\n\t\trv = of_property_read_reg(node, 1, &reg, NULL);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\tcf_port->cs1 = upper_32_bits(reg);\n\t}\n\n\tres_cs0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_cs0)\n\t\treturn -EINVAL;\n\n\tcs0 = devm_ioremap(&pdev->dev, res_cs0->start,\n\t\t\t\t   resource_size(res_cs0));\n\tif (!cs0)\n\t\treturn -ENOMEM;\n\n\t \n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tap = host->ports[0];\n\tap->private_data = cf_port;\n\tpdev->dev.platform_data = cf_port;\n\tcf_port->ap = ap;\n\tap->ops = &octeon_cf_ops;\n\tap->pio_mask = ATA_PIO6;\n\tap->flags |= ATA_FLAG_NO_ATAPI | ATA_FLAG_PIO_POLLING;\n\n\tif (!is_16bit) {\n\t\tbase = cs0 + 0x800;\n\t\tap->ioaddr.cmd_addr\t= base;\n\t\tata_sff_std_ports(&ap->ioaddr);\n\n\t\tap->ioaddr.altstatus_addr = base + 0xe;\n\t\tap->ioaddr.ctl_addr\t= base + 0xe;\n\t\tocteon_cf_ops.sff_data_xfer = octeon_cf_data_xfer8;\n\t} else if (cf_port->is_true_ide) {\n\t\tbase = cs0;\n\t\tap->ioaddr.cmd_addr\t= base + (ATA_REG_CMD << 1) + 1;\n\t\tap->ioaddr.data_addr\t= base + (ATA_REG_DATA << 1);\n\t\tap->ioaddr.error_addr\t= base + (ATA_REG_ERR << 1) + 1;\n\t\tap->ioaddr.feature_addr\t= base + (ATA_REG_FEATURE << 1) + 1;\n\t\tap->ioaddr.nsect_addr\t= base + (ATA_REG_NSECT << 1) + 1;\n\t\tap->ioaddr.lbal_addr\t= base + (ATA_REG_LBAL << 1) + 1;\n\t\tap->ioaddr.lbam_addr\t= base + (ATA_REG_LBAM << 1) + 1;\n\t\tap->ioaddr.lbah_addr\t= base + (ATA_REG_LBAH << 1) + 1;\n\t\tap->ioaddr.device_addr\t= base + (ATA_REG_DEVICE << 1) + 1;\n\t\tap->ioaddr.status_addr\t= base + (ATA_REG_STATUS << 1) + 1;\n\t\tap->ioaddr.command_addr\t= base + (ATA_REG_CMD << 1) + 1;\n\t\tap->ioaddr.altstatus_addr = cs1 + (6 << 1) + 1;\n\t\tap->ioaddr.ctl_addr\t= cs1 + (6 << 1) + 1;\n\t\tocteon_cf_ops.sff_data_xfer = octeon_cf_data_xfer16;\n\n\t\tap->mwdma_mask\t= enable_dma ? ATA_MWDMA4 : 0;\n\n\t\t \n\t\thrtimer_init(&cf_port->delayed_finish, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL);\n\t\tcf_port->delayed_finish.function = octeon_cf_delayed_finish;\n\t} else {\n\t\t \n\t\tbase = cs0 + 0x800;\n\t\tocteon_cf_ops.sff_data_xfer\t= octeon_cf_data_xfer16;\n\t\tocteon_cf_ops.softreset\t\t= octeon_cf_softreset16;\n\t\tocteon_cf_ops.sff_check_status\t= octeon_cf_check_status16;\n\t\tocteon_cf_ops.sff_tf_read\t= octeon_cf_tf_read16;\n\t\tocteon_cf_ops.sff_tf_load\t= octeon_cf_tf_load16;\n\t\tocteon_cf_ops.sff_exec_command\t= octeon_cf_exec_command16;\n\n\t\tap->ioaddr.data_addr\t= base + ATA_REG_DATA;\n\t\tap->ioaddr.nsect_addr\t= base + ATA_REG_NSECT;\n\t\tap->ioaddr.lbal_addr\t= base + ATA_REG_LBAL;\n\t\tap->ioaddr.ctl_addr\t= base + 0xe;\n\t\tap->ioaddr.altstatus_addr = base + 0xe;\n\t}\n\tcf_port->c0 = ap->ioaddr.ctl_addr;\n\n\trv = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rv)\n\t\treturn rv;\n\n\tata_port_desc(ap, \"cmd %p ctl %p\", base, ap->ioaddr.ctl_addr);\n\n\tdev_info(&pdev->dev, \"version \" DRV_VERSION\" %d bit%s.\\n\",\n\t\t is_16bit ? 16 : 8,\n\t\t cf_port->is_true_ide ? \", True IDE\" : \"\");\n\n\treturn ata_host_activate(host, irq, irq_handler,\n\t\t\t\t IRQF_SHARED, &octeon_cf_sht);\n}\n\nstatic void octeon_cf_shutdown(struct device *dev)\n{\n\tunion cvmx_mio_boot_dma_cfgx dma_cfg;\n\tunion cvmx_mio_boot_dma_intx dma_int;\n\n\tstruct octeon_cf_port *cf_port = dev_get_platdata(dev);\n\n\tif (cf_port->dma_base) {\n\t\t \n\t\tdma_cfg.u64 = 0;\n\t\tdma_cfg.s.size = -1;\n\t\tcvmx_write_csr(cf_port->dma_base + DMA_CFG, dma_cfg.u64);\n\n\t\t \n\t\tdma_int.u64 = 0;\n\t\tcvmx_write_csr(cf_port->dma_base + DMA_INT_EN, dma_int.u64);\n\n\t\t \n\t\tdma_int.s.done = 1;\n\t\tcvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);\n\n\t\t__raw_writeb(0, cf_port->c0);\n\t\tudelay(20);\n\t\t__raw_writeb(ATA_SRST, cf_port->c0);\n\t\tudelay(20);\n\t\t__raw_writeb(0, cf_port->c0);\n\t\tmdelay(100);\n\t}\n}\n\nstatic const struct of_device_id octeon_cf_match[] = {\n\t{ .compatible = \"cavium,ebt3000-compact-flash\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, octeon_cf_match);\n\nstatic struct platform_driver octeon_cf_driver = {\n\t.probe\t\t= octeon_cf_probe,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = octeon_cf_match,\n\t\t.shutdown = octeon_cf_shutdown\n\t},\n};\n\nstatic int __init octeon_cf_init(void)\n{\n\treturn platform_driver_register(&octeon_cf_driver);\n}\n\n\nMODULE_AUTHOR(\"David Daney <ddaney@caviumnetworks.com>\");\nMODULE_DESCRIPTION(\"low-level driver for Cavium OCTEON Compact Flash PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n\nmodule_init(octeon_cf_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}