{
  "module_name": "pata_mpc52xx.c",
  "hash_id": "341a7fd0f16d30b6dacbc50ce4cff5e79cd15f0964b0d5e7093a16d8b2aa8cc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_mpc52xx.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/libata.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <asm/cacheflush.h>\n#include <asm/mpc52xx.h>\n\n#include <linux/fsl/bestcomm/bestcomm.h>\n#include <linux/fsl/bestcomm/bestcomm_priv.h>\n#include <linux/fsl/bestcomm/ata.h>\n\n#define DRV_NAME\t\"mpc52xx_ata\"\n\n \nstruct mpc52xx_ata_timings {\n\tu32\tpio1;\n\tu32\tpio2;\n\tu32\tmdma1;\n\tu32\tmdma2;\n\tu32\tudma1;\n\tu32\tudma2;\n\tu32\tudma3;\n\tu32\tudma4;\n\tu32\tudma5;\n\tint\tusing_udma;\n};\n\nstruct mpc52xx_ata_priv {\n\tunsigned int\t\t\tipb_period;\n\tstruct mpc52xx_ata __iomem\t*ata_regs;\n\tphys_addr_t\t\t\tata_regs_pa;\n\tint\t\t\t\tata_irq;\n\tstruct mpc52xx_ata_timings\ttimings[2];\n\tint\t\t\t\tcsel;\n\n\t \n\tstruct bcom_task\t\t*dmatsk;\n\tconst struct udmaspec\t\t*udmaspec;\n\tconst struct mdmaspec\t\t*mdmaspec;\n\tint \t\t\t\tmpc52xx_ata_dma_last_write;\n\tint\t\t\t\twaiting_for_dma;\n};\n\n\n \nstatic const u16 ataspec_t0[5]\t\t= {600, 383, 240, 180, 120};\nstatic const u16 ataspec_t1[5]\t\t= { 70,  50,  30,  30,  25};\nstatic const u16 ataspec_t2_8[5]\t= {290, 290, 290,  80,  70};\nstatic const u16 ataspec_t2_16[5]\t= {165, 125, 100,  80,  70};\nstatic const u16 ataspec_t2i[5]\t\t= {  0,   0,   0,  70,  25};\nstatic const u16 ataspec_t4[5]\t\t= { 30,  20,  15,  10,  10};\nstatic const u16 ataspec_ta[5]\t\t= { 35,  35,  35,  35,  35};\n\n#define CALC_CLKCYC(c,v) ((((v)+(c)-1)/(c)))\n\n \n\n \nstruct mdmaspec {\n\tu8 t0M;\n\tu8 td;\n\tu8 th;\n\tu8 tj;\n\tu8 tkw;\n\tu8 tm;\n\tu8 tn;\n};\n\nstatic const struct mdmaspec mdmaspec66[3] = {\n\t{ .t0M = 32, .td = 15, .th = 2, .tj = 2, .tkw = 15, .tm = 4, .tn = 1 },\n\t{ .t0M = 10, .td = 6,  .th = 1, .tj = 1, .tkw = 4,  .tm = 2, .tn = 1 },\n\t{ .t0M = 8,  .td = 5,  .th = 1, .tj = 1, .tkw = 2,  .tm = 2, .tn = 1 },\n};\n\nstatic const struct mdmaspec mdmaspec132[3] = {\n\t{ .t0M = 64, .td = 29, .th = 3, .tj = 3, .tkw = 29, .tm = 7, .tn = 2 },\n\t{ .t0M = 20, .td = 11, .th = 2, .tj = 1, .tkw = 7,  .tm = 4, .tn = 1 },\n\t{ .t0M = 16, .td = 10, .th = 2, .tj = 1, .tkw = 4,  .tm = 4, .tn = 1 },\n};\n\n \nstruct udmaspec {\n\tu8 tcyc;\n\tu8 t2cyc;\n\tu8 tds;\n\tu8 tdh;\n\tu8 tdvs;\n\tu8 tdvh;\n\tu8 tfs;\n\tu8 tli;\n\tu8 tmli;\n\tu8 taz;\n\tu8 tzah;\n\tu8 tenv;\n\tu8 tsr;\n\tu8 trfs;\n\tu8 trp;\n\tu8 tack;\n\tu8 tss;\n};\n\nstatic const struct udmaspec udmaspec66[6] = {\n\t{ .tcyc = 8,  .t2cyc = 16, .tds  = 1,  .tdh  = 1, .tdvs = 5,  .tdvh = 1,\n\t  .tfs  = 16, .tli   = 10, .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 3,  .trfs  = 5,  .trp  = 11, .tack = 2, .tss  = 4,\n\t},\n\t{ .tcyc = 5,  .t2cyc = 11, .tds  = 1,  .tdh  = 1, .tdvs = 4,  .tdvh = 1,\n\t  .tfs  = 14, .tli   = 10, .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 2,  .trfs  = 5,  .trp  = 9,  .tack = 2, .tss  = 4,\n\t},\n\t{ .tcyc = 4,  .t2cyc = 8,  .tds  = 1,  .tdh  = 1, .tdvs = 3,  .tdvh = 1,\n\t  .tfs  = 12, .tli   = 10, .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 2,  .trfs  = 4,  .trp  = 7,  .tack = 2, .tss  = 4,\n\t},\n\t{ .tcyc = 3,  .t2cyc = 6,  .tds  = 1,  .tdh  = 1, .tdvs = 2,  .tdvh = 1,\n\t  .tfs  = 9,  .tli   = 7,  .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 2,  .trfs  = 4,  .trp  = 7,  .tack = 2, .tss  = 4,\n\t},\n\t{ .tcyc = 2,  .t2cyc = 4,  .tds  = 1,  .tdh  = 1, .tdvs = 1,  .tdvh = 1,\n\t  .tfs  = 8,  .tli   = 8,  .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 2,  .trfs  = 4,  .trp  = 7,  .tack = 2, .tss  = 4,\n\t},\n\t{ .tcyc = 2,  .t2cyc = 2,  .tds  = 1,  .tdh  = 1, .tdvs = 1,  .tdvh = 1,\n\t  .tfs  = 6,  .tli   = 5,  .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 2,  .trfs  = 4,  .trp  = 6,  .tack = 2, .tss  = 4,\n\t},\n};\n\nstatic const struct udmaspec udmaspec132[6] = {\n\t{ .tcyc = 15, .t2cyc = 31, .tds  = 2,  .tdh  = 1, .tdvs = 10, .tdvh = 1,\n\t  .tfs  = 30, .tli   = 20, .tmli = 3,  .taz  = 2, .tzah = 3,  .tenv = 3,\n\t  .tsr  = 7,  .trfs  = 10, .trp  = 22, .tack = 3, .tss  = 7,\n\t},\n\t{ .tcyc = 10, .t2cyc = 21, .tds  = 2,  .tdh  = 1, .tdvs = 7,  .tdvh = 1,\n\t  .tfs  = 27, .tli   = 20, .tmli = 3,  .taz  = 2, .tzah = 3,  .tenv = 3,\n\t  .tsr  = 4,  .trfs  = 10, .trp  = 17, .tack = 3, .tss  = 7,\n\t},\n\t{ .tcyc = 6,  .t2cyc = 12, .tds  = 1,  .tdh  = 1, .tdvs = 5,  .tdvh = 1,\n\t  .tfs  = 23, .tli   = 20, .tmli = 3,  .taz  = 2, .tzah = 3,  .tenv = 3,\n\t  .tsr  = 3,  .trfs  = 8,  .trp  = 14, .tack = 3, .tss  = 7,\n\t},\n\t{ .tcyc = 7,  .t2cyc = 12, .tds  = 1,  .tdh  = 1, .tdvs = 3,  .tdvh = 1,\n\t  .tfs  = 15, .tli   = 13, .tmli = 3,  .taz  = 2, .tzah = 3,  .tenv = 3,\n\t  .tsr  = 3,  .trfs  = 8,  .trp  = 14, .tack = 3, .tss  = 7,\n\t},\n\t{ .tcyc = 2,  .t2cyc = 5,  .tds  = 0,  .tdh  = 0, .tdvs = 1,  .tdvh = 1,\n\t  .tfs  = 16, .tli   = 14, .tmli = 2,  .taz  = 1, .tzah = 2,  .tenv = 2,\n\t  .tsr  = 2,  .trfs  = 7,  .trp  = 13, .tack = 2, .tss  = 6,\n\t},\n\t{ .tcyc = 3,  .t2cyc = 6,  .tds  = 1,  .tdh  = 1, .tdvs = 1,  .tdvh = 1,\n\t  .tfs  = 12, .tli   = 10, .tmli = 3,  .taz  = 2, .tzah = 3,  .tenv = 3,\n\t  .tsr  = 3,  .trfs  = 7,  .trp  = 12, .tack = 3, .tss  = 7,\n\t},\n};\n\n \n\n \n#define MPC52xx_ATA_HOSTCONF_SMR\t0x80000000UL  \n#define MPC52xx_ATA_HOSTCONF_FR\t\t0x40000000UL  \n#define MPC52xx_ATA_HOSTCONF_IE\t\t0x02000000UL  \n#define MPC52xx_ATA_HOSTCONF_IORDY\t0x01000000UL  \n\n#define MPC52xx_ATA_HOSTSTAT_TIP\t0x80000000UL  \n#define MPC52xx_ATA_HOSTSTAT_UREP\t0x40000000UL  \n#define MPC52xx_ATA_HOSTSTAT_RERR\t0x02000000UL  \n#define MPC52xx_ATA_HOSTSTAT_WERR\t0x01000000UL  \n\n#define MPC52xx_ATA_FIFOSTAT_EMPTY\t0x01  \n#define MPC52xx_ATA_FIFOSTAT_ERROR\t0x40  \n\n#define MPC52xx_ATA_DMAMODE_WRITE\t0x01  \n#define MPC52xx_ATA_DMAMODE_READ\t0x02  \n#define MPC52xx_ATA_DMAMODE_UDMA\t0x04  \n#define MPC52xx_ATA_DMAMODE_IE\t\t0x08  \n#define MPC52xx_ATA_DMAMODE_FE\t\t0x10  \n#define MPC52xx_ATA_DMAMODE_FR\t\t0x20  \n#define MPC52xx_ATA_DMAMODE_HUT\t\t0x40  \n\n#define MAX_DMA_BUFFERS 128\n#define MAX_DMA_BUFFER_SIZE 0x20000u\n\n \nstruct mpc52xx_ata {\n\n\t \n\tu32 config;\t\t \n\tu32 host_status;\t \n\tu32 pio1;\t\t \n\tu32 pio2;\t\t \n\tu32 mdma1;\t\t \n\tu32 mdma2;\t\t \n\tu32 udma1;\t\t \n\tu32 udma2;\t\t \n\tu32 udma3;\t\t \n\tu32 udma4;\t\t \n\tu32 udma5;\t\t \n\tu32 share_cnt;\t\t \n\tu32 reserved0[3];\n\n\t \n\tu32 fifo_data;\t\t \n\tu8  fifo_status_frame;\t \n\tu8  fifo_status;\t \n\tu16 reserved7[1];\n\tu8  fifo_control;\t \n\tu8  reserved8[5];\n\tu16 fifo_alarm;\t\t \n\tu16 reserved9;\n\tu16 fifo_rdp;\t\t \n\tu16 reserved10;\n\tu16 fifo_wrp;\t\t \n\tu16 reserved11;\n\tu16 fifo_lfrdp;\t\t \n\tu16 reserved12;\n\tu16 fifo_lfwrp;\t\t \n\n\t \n\tu8  tf_control;\t\t \n\tu8  reserved13[3];\n\tu16 tf_data;\t\t \n\tu16 reserved14;\n\tu8  tf_features;\t \n\tu8  reserved15[3];\n\tu8  tf_sec_count;\t \n\tu8  reserved16[3];\n\tu8  tf_sec_num;\t\t \n\tu8  reserved17[3];\n\tu8  tf_cyl_low;\t\t \n\tu8  reserved18[3];\n\tu8  tf_cyl_high;\t \n\tu8  reserved19[3];\n\tu8  tf_dev_head;\t \n\tu8  reserved20[3];\n\tu8  tf_command;\t\t \n\tu8  dma_mode;\t\t \n\tu8  reserved21[2];\n};\n\n\n \n \n \n\n\n \nstatic int\nmpc52xx_ata_compute_pio_timings(struct mpc52xx_ata_priv *priv, int dev, int pio)\n{\n\tstruct mpc52xx_ata_timings *timing = &priv->timings[dev];\n\tunsigned int ipb_period = priv->ipb_period;\n\tu32 t0, t1, t2_8, t2_16, t2i, t4, ta;\n\n\tif ((pio < 0) || (pio > 4))\n\t\treturn -EINVAL;\n\n\tt0\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_t0[pio]);\n\tt1\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_t1[pio]);\n\tt2_8\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_t2_8[pio]);\n\tt2_16\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_t2_16[pio]);\n\tt2i\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_t2i[pio]);\n\tt4\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_t4[pio]);\n\tta\t= CALC_CLKCYC(ipb_period, 1000 * ataspec_ta[pio]);\n\n\ttiming->pio1 = (t0 << 24) | (t2_8 << 16) | (t2_16 << 8) | (t2i);\n\ttiming->pio2 = (t4 << 24) | (t1 << 16) | (ta << 8);\n\n\treturn 0;\n}\n\nstatic int\nmpc52xx_ata_compute_mdma_timings(struct mpc52xx_ata_priv *priv, int dev,\n\t\t\t\t int speed)\n{\n\tstruct mpc52xx_ata_timings *t = &priv->timings[dev];\n\tconst struct mdmaspec *s = &priv->mdmaspec[speed];\n\n\tif (speed < 0 || speed > 2)\n\t\treturn -EINVAL;\n\n\tt->mdma1 = ((u32)s->t0M << 24) | ((u32)s->td << 16) | ((u32)s->tkw << 8) | s->tm;\n\tt->mdma2 = ((u32)s->th << 24) | ((u32)s->tj << 16) | ((u32)s->tn << 8);\n\tt->using_udma = 0;\n\n\treturn 0;\n}\n\nstatic int\nmpc52xx_ata_compute_udma_timings(struct mpc52xx_ata_priv *priv, int dev,\n\t\t\t\t int speed)\n{\n\tstruct mpc52xx_ata_timings *t = &priv->timings[dev];\n\tconst struct udmaspec *s = &priv->udmaspec[speed];\n\n\tif (speed < 0 || speed > 2)\n\t\treturn -EINVAL;\n\n\tt->udma1 = ((u32)s->t2cyc << 24) | ((u32)s->tcyc << 16) | ((u32)s->tds << 8) | s->tdh;\n\tt->udma2 = ((u32)s->tdvs << 24) | ((u32)s->tdvh << 16) | ((u32)s->tfs << 8) | s->tli;\n\tt->udma3 = ((u32)s->tmli << 24) | ((u32)s->taz << 16) | ((u32)s->tenv << 8) | s->tsr;\n\tt->udma4 = ((u32)s->tss << 24) | ((u32)s->trfs << 16) | ((u32)s->trp << 8) | s->tack;\n\tt->udma5 = (u32)s->tzah << 24;\n\tt->using_udma = 1;\n\n\treturn 0;\n}\n\nstatic void\nmpc52xx_ata_apply_timings(struct mpc52xx_ata_priv *priv, int device)\n{\n\tstruct mpc52xx_ata __iomem *regs = priv->ata_regs;\n\tstruct mpc52xx_ata_timings *timing = &priv->timings[device];\n\n\tout_be32(&regs->pio1,  timing->pio1);\n\tout_be32(&regs->pio2,  timing->pio2);\n\tout_be32(&regs->mdma1, timing->mdma1);\n\tout_be32(&regs->mdma2, timing->mdma2);\n\tout_be32(&regs->udma1, timing->udma1);\n\tout_be32(&regs->udma2, timing->udma2);\n\tout_be32(&regs->udma3, timing->udma3);\n\tout_be32(&regs->udma4, timing->udma4);\n\tout_be32(&regs->udma5, timing->udma5);\n\tpriv->csel = device;\n}\n\nstatic int\nmpc52xx_ata_hw_init(struct mpc52xx_ata_priv *priv)\n{\n\tstruct mpc52xx_ata __iomem *regs = priv->ata_regs;\n\tint tslot;\n\n\t \n\tout_be32(&regs->share_cnt, 0);\n\n\t \n\tout_be32(&regs->config,\n\t\t\tMPC52xx_ATA_HOSTCONF_IE |\n\t\t\tMPC52xx_ATA_HOSTCONF_IORDY |\n\t\t\tMPC52xx_ATA_HOSTCONF_SMR |\n\t\t\tMPC52xx_ATA_HOSTCONF_FR);\n\n\tudelay(10);\n\n\tout_be32(&regs->config,\n\t\t\tMPC52xx_ATA_HOSTCONF_IE |\n\t\t\tMPC52xx_ATA_HOSTCONF_IORDY);\n\n\t \n\ttslot = CALC_CLKCYC(priv->ipb_period, 1000000);\n\tout_be32(&regs->share_cnt, tslot << 16);\n\n\t \n\tmemset(priv->timings, 0x00, 2*sizeof(struct mpc52xx_ata_timings));\n\n\tmpc52xx_ata_compute_pio_timings(priv, 0, 0);\n\tmpc52xx_ata_compute_pio_timings(priv, 1, 0);\n\n\tmpc52xx_ata_apply_timings(priv, 0);\n\n\treturn 0;\n}\n\n\n \n \n \n\nstatic void\nmpc52xx_ata_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\tint pio, rv;\n\n\tpio = adev->pio_mode - XFER_PIO_0;\n\n\trv = mpc52xx_ata_compute_pio_timings(priv, adev->devno, pio);\n\n\tif (rv) {\n\t\tdev_err(ap->dev, \"error: invalid PIO mode: %d\\n\", pio);\n\t\treturn;\n\t}\n\n\tmpc52xx_ata_apply_timings(priv, adev->devno);\n}\n\nstatic void\nmpc52xx_ata_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\tint rv;\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tint dma = adev->dma_mode - XFER_UDMA_0;\n\t\trv = mpc52xx_ata_compute_udma_timings(priv, adev->devno, dma);\n\t} else {\n\t\tint dma = adev->dma_mode - XFER_MW_DMA_0;\n\t\trv = mpc52xx_ata_compute_mdma_timings(priv, adev->devno, dma);\n\t}\n\n\tif (rv) {\n\t\tdev_alert(ap->dev,\n\t\t\t\"Trying to select invalid DMA mode %d\\n\",\n\t\t\tadev->dma_mode);\n\t\treturn;\n\t}\n\n\tmpc52xx_ata_apply_timings(priv, adev->devno);\n}\n\nstatic void\nmpc52xx_ata_dev_select(struct ata_port *ap, unsigned int device)\n{\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\n\tif (device != priv->csel)\n\t\tmpc52xx_ata_apply_timings(priv, device);\n\n\tata_sff_dev_select(ap, device);\n}\n\nstatic int\nmpc52xx_ata_build_dmatable(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\tstruct bcom_ata_bd *bd;\n\tunsigned int read = !(qc->tf.flags & ATA_TFLAG_WRITE), si;\n\tstruct scatterlist *sg;\n\tint count = 0;\n\n\tif (read)\n\t\tbcom_ata_rx_prepare(priv->dmatsk);\n\telse\n\t\tbcom_ata_tx_prepare(priv->dmatsk);\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tdma_addr_t cur_addr = sg_dma_address(sg);\n\t\tu32 cur_len = sg_dma_len(sg);\n\n\t\twhile (cur_len) {\n\t\t\tunsigned int tc = min(cur_len, MAX_DMA_BUFFER_SIZE);\n\t\t\tbd = (struct bcom_ata_bd *)\n\t\t\t\tbcom_prepare_next_buffer(priv->dmatsk);\n\n\t\t\tif (read) {\n\t\t\t\tbd->status = tc;\n\t\t\t\tbd->src_pa = (__force u32) priv->ata_regs_pa +\n\t\t\t\t\toffsetof(struct mpc52xx_ata, fifo_data);\n\t\t\t\tbd->dst_pa = (__force u32) cur_addr;\n\t\t\t} else {\n\t\t\t\tbd->status = tc;\n\t\t\t\tbd->src_pa = (__force u32) cur_addr;\n\t\t\t\tbd->dst_pa = (__force u32) priv->ata_regs_pa +\n\t\t\t\t\toffsetof(struct mpc52xx_ata, fifo_data);\n\t\t\t}\n\n\t\t\tbcom_submit_next_buffer(priv->dmatsk, NULL);\n\n\t\t\tcur_addr += tc;\n\t\t\tcur_len -= tc;\n\t\t\tcount++;\n\n\t\t\tif (count > MAX_DMA_BUFFERS) {\n\t\t\t\tdev_alert(ap->dev, \"dma table\"\n\t\t\t\t\t\"too small\\n\");\n\t\t\t\tgoto use_pio_instead;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n\n use_pio_instead:\n\tbcom_ata_reset_bd(priv->dmatsk);\n\treturn 0;\n}\n\nstatic void\nmpc52xx_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\tstruct mpc52xx_ata __iomem *regs = priv->ata_regs;\n\n\tunsigned int read = !(qc->tf.flags & ATA_TFLAG_WRITE);\n\tu8 dma_mode;\n\n\tif (!mpc52xx_ata_build_dmatable(qc))\n\t\tdev_alert(ap->dev, \"%s: %i, return 1?\\n\",\n\t\t\t__func__, __LINE__);\n\n\t \n\tif (in_8(&priv->ata_regs->fifo_status) & MPC52xx_ATA_FIFOSTAT_ERROR)\n\t\tdev_alert(ap->dev, \"%s: FIFO error detected: 0x%02x!\\n\",\n\t\t\t__func__, in_8(&priv->ata_regs->fifo_status));\n\n\tif (read) {\n\t\tdma_mode = MPC52xx_ATA_DMAMODE_IE | MPC52xx_ATA_DMAMODE_READ |\n\t\t\t\tMPC52xx_ATA_DMAMODE_FE;\n\n\t\t \n\t\tif (priv->mpc52xx_ata_dma_last_write != 0) {\n\t\t\tpriv->mpc52xx_ata_dma_last_write = 0;\n\n\t\t\t \n\t\t\tout_8(&regs->fifo_control, 7);\n\t\t\tout_be16(&regs->fifo_alarm, 128);\n\n\t\t\t \n\t\t\tout_8(&regs->dma_mode, MPC52xx_ATA_DMAMODE_FR);\n\t\t}\n\t} else {\n\t\tdma_mode = MPC52xx_ATA_DMAMODE_IE | MPC52xx_ATA_DMAMODE_WRITE;\n\n\t\t \n\t\tif (priv->mpc52xx_ata_dma_last_write != 1) {\n\t\t\tpriv->mpc52xx_ata_dma_last_write = 1;\n\n\t\t\t \n\t\t\tout_8(&regs->fifo_control, 4);\n\t\t\tout_be16(&regs->fifo_alarm, 128);\n\t\t}\n\t}\n\n\tif (priv->timings[qc->dev->devno].using_udma)\n\t\tdma_mode |= MPC52xx_ATA_DMAMODE_UDMA;\n\n\tout_8(&regs->dma_mode, dma_mode);\n\tpriv->waiting_for_dma = ATA_DMA_ACTIVE;\n\n\tata_wait_idle(ap);\n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\nstatic void\nmpc52xx_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\n\tbcom_set_task_auto_start(priv->dmatsk->tasknum, priv->dmatsk->tasknum);\n\tbcom_enable(priv->dmatsk);\n}\n\nstatic void\nmpc52xx_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\n\tbcom_disable(priv->dmatsk);\n\tbcom_ata_reset_bd(priv->dmatsk);\n\tpriv->waiting_for_dma = 0;\n\n\t \n\tif (in_8(&priv->ata_regs->fifo_status) & MPC52xx_ATA_FIFOSTAT_ERROR)\n\t\tdev_alert(ap->dev, \"%s: FIFO error detected: 0x%02x!\\n\",\n\t\t\t__func__, in_8(&priv->ata_regs->fifo_status));\n}\n\nstatic u8\nmpc52xx_bmdma_status(struct ata_port *ap)\n{\n\tstruct mpc52xx_ata_priv *priv = ap->host->private_data;\n\n\t \n\tif (in_8(&priv->ata_regs->fifo_status) & MPC52xx_ATA_FIFOSTAT_ERROR) {\n\t\tdev_alert(ap->dev, \"%s: FIFO error detected: 0x%02x!\\n\",\n\t\t\t__func__, in_8(&priv->ata_regs->fifo_status));\n\t\treturn priv->waiting_for_dma | ATA_DMA_ERR;\n\t}\n\n\treturn priv->waiting_for_dma;\n}\n\nstatic irqreturn_t\nmpc52xx_ata_task_irq(int irq, void *vpriv)\n{\n\tstruct mpc52xx_ata_priv *priv = vpriv;\n\twhile (bcom_buffer_done(priv->dmatsk))\n\t\tbcom_retrieve_buffer(priv->dmatsk, NULL, NULL);\n\n\tpriv->waiting_for_dma |= ATA_DMA_INTR;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct scsi_host_template mpc52xx_ata_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations mpc52xx_ata_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.sff_dev_select\t\t= mpc52xx_ata_dev_select,\n\t.set_piomode\t\t= mpc52xx_ata_set_piomode,\n\t.set_dmamode\t\t= mpc52xx_ata_set_dmamode,\n\t.bmdma_setup\t\t= mpc52xx_bmdma_setup,\n\t.bmdma_start\t\t= mpc52xx_bmdma_start,\n\t.bmdma_stop\t\t= mpc52xx_bmdma_stop,\n\t.bmdma_status\t\t= mpc52xx_bmdma_status,\n\t.qc_prep\t\t= ata_noop_qc_prep,\n};\n\nstatic int mpc52xx_ata_init_one(struct device *dev,\n\t\t\t\tstruct mpc52xx_ata_priv *priv,\n\t\t\t\tunsigned long raw_ata_regs,\n\t\t\t\tint mwdma_mask, int udma_mask)\n{\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tstruct ata_ioports *aio;\n\n\thost = ata_host_alloc(dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tap = host->ports[0];\n\tap->flags\t\t|= ATA_FLAG_SLAVE_POSS;\n\tap->pio_mask\t\t= ATA_PIO4;\n\tap->mwdma_mask\t\t= mwdma_mask;\n\tap->udma_mask\t\t= udma_mask;\n\tap->ops\t\t\t= &mpc52xx_ata_port_ops;\n\thost->private_data\t= priv;\n\n\taio = &ap->ioaddr;\n\taio->cmd_addr\t\t= NULL;\t \n\taio->altstatus_addr\t= &priv->ata_regs->tf_control;\n\taio->ctl_addr\t\t= &priv->ata_regs->tf_control;\n\taio->data_addr\t\t= &priv->ata_regs->tf_data;\n\taio->error_addr\t\t= &priv->ata_regs->tf_features;\n\taio->feature_addr\t= &priv->ata_regs->tf_features;\n\taio->nsect_addr\t\t= &priv->ata_regs->tf_sec_count;\n\taio->lbal_addr\t\t= &priv->ata_regs->tf_sec_num;\n\taio->lbam_addr\t\t= &priv->ata_regs->tf_cyl_low;\n\taio->lbah_addr\t\t= &priv->ata_regs->tf_cyl_high;\n\taio->device_addr\t= &priv->ata_regs->tf_dev_head;\n\taio->status_addr\t= &priv->ata_regs->tf_command;\n\taio->command_addr\t= &priv->ata_regs->tf_command;\n\n\tata_port_desc(ap, \"ata_regs 0x%lx\", raw_ata_regs);\n\n\t \n\treturn ata_host_activate(host, priv->ata_irq, ata_bmdma_interrupt, 0,\n\t\t\t\t &mpc52xx_ata_sht);\n}\n\n \n \n \n\nstatic int mpc52xx_ata_probe(struct platform_device *op)\n{\n\tunsigned int ipb_freq;\n\tstruct resource res_mem;\n\tint ata_irq = 0;\n\tstruct mpc52xx_ata __iomem *ata_regs;\n\tstruct mpc52xx_ata_priv *priv = NULL;\n\tint rv, task_irq;\n\tint mwdma_mask = 0, udma_mask = 0;\n\tconst __be32 *prop;\n\tint proplen;\n\tstruct bcom_task *dmatsk;\n\n\t \n\tipb_freq = mpc5xxx_get_bus_frequency(&op->dev);\n\tif (!ipb_freq) {\n\t\tdev_err(&op->dev, \"could not determine IPB bus frequency\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trv = of_address_to_resource(op->dev.of_node, 0, &res_mem);\n\tif (rv) {\n\t\tdev_err(&op->dev, \"could not determine device base address\\n\");\n\t\treturn rv;\n\t}\n\n\tif (!devm_request_mem_region(&op->dev, res_mem.start,\n\t\t\t\t     sizeof(*ata_regs), DRV_NAME)) {\n\t\tdev_err(&op->dev, \"error requesting register region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tata_regs = devm_ioremap(&op->dev, res_mem.start, sizeof(*ata_regs));\n\tif (!ata_regs) {\n\t\tdev_err(&op->dev, \"error mapping device registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tprop = of_get_property(op->dev.of_node, \"mwdma-mode\", &proplen);\n\tif ((prop) && (proplen >= 4))\n\t\tmwdma_mask = ATA_MWDMA2 & ((1 << (*prop + 1)) - 1);\n\tprop = of_get_property(op->dev.of_node, \"udma-mode\", &proplen);\n\tif ((prop) && (proplen >= 4))\n\t\tudma_mask = ATA_UDMA2 & ((1 << (*prop + 1)) - 1);\n\n\tata_irq = irq_of_parse_and_map(op->dev.of_node, 0);\n\tif (!ata_irq) {\n\t\tdev_err(&op->dev, \"error mapping irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv = devm_kzalloc(&op->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\trv = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tpriv->ipb_period = 1000000000 / (ipb_freq / 1000);\n\tpriv->ata_regs = ata_regs;\n\tpriv->ata_regs_pa = res_mem.start;\n\tpriv->ata_irq = ata_irq;\n\tpriv->csel = -1;\n\tpriv->mpc52xx_ata_dma_last_write = -1;\n\n\tif (ipb_freq/1000000 == 66) {\n\t\tpriv->mdmaspec = mdmaspec66;\n\t\tpriv->udmaspec = udmaspec66;\n\t} else {\n\t\tpriv->mdmaspec = mdmaspec132;\n\t\tpriv->udmaspec = udmaspec132;\n\t}\n\n\t \n\tdmatsk = bcom_ata_init(MAX_DMA_BUFFERS, MAX_DMA_BUFFER_SIZE);\n\tif (!dmatsk) {\n\t\tdev_err(&op->dev, \"bestcomm initialization failed\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\ttask_irq = bcom_get_task_irq(dmatsk);\n\trv = devm_request_irq(&op->dev, task_irq, &mpc52xx_ata_task_irq, 0,\n\t\t\t\t\"ATA task\", priv);\n\tif (rv) {\n\t\tdev_err(&op->dev, \"error requesting DMA IRQ\\n\");\n\t\tgoto err2;\n\t}\n\tpriv->dmatsk = dmatsk;\n\n\t \n\trv = mpc52xx_ata_hw_init(priv);\n\tif (rv) {\n\t\tdev_err(&op->dev, \"error initializing hardware\\n\");\n\t\tgoto err2;\n\t}\n\n\t \n\trv = mpc52xx_ata_init_one(&op->dev, priv, res_mem.start,\n\t\t\t\t  mwdma_mask, udma_mask);\n\tif (rv) {\n\t\tdev_err(&op->dev, \"error registering with ATA layer\\n\");\n\t\tgoto err2;\n\t}\n\n\treturn 0;\n\n err2:\n\tirq_dispose_mapping(task_irq);\n\tbcom_ata_release(dmatsk);\n err1:\n\tirq_dispose_mapping(ata_irq);\n\treturn rv;\n}\n\nstatic void mpc52xx_ata_remove(struct platform_device *op)\n{\n\tstruct ata_host *host = platform_get_drvdata(op);\n\tstruct mpc52xx_ata_priv *priv = host->private_data;\n\tint task_irq;\n\n\t \n\tata_platform_remove_one(op);\n\n\t \n\ttask_irq = bcom_get_task_irq(priv->dmatsk);\n\tirq_dispose_mapping(task_irq);\n\tbcom_ata_release(priv->dmatsk);\n\tirq_dispose_mapping(priv->ata_irq);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int\nmpc52xx_ata_suspend(struct platform_device *op, pm_message_t state)\n{\n\tstruct ata_host *host = platform_get_drvdata(op);\n\n\tata_host_suspend(host, state);\n\treturn 0;\n}\n\nstatic int\nmpc52xx_ata_resume(struct platform_device *op)\n{\n\tstruct ata_host *host = platform_get_drvdata(op);\n\tstruct mpc52xx_ata_priv *priv = host->private_data;\n\tint rv;\n\n\trv = mpc52xx_ata_hw_init(priv);\n\tif (rv) {\n\t\tdev_err(host->dev, \"error initializing hardware\\n\");\n\t\treturn rv;\n\t}\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id mpc52xx_ata_of_match[] = {\n\t{ .compatible = \"fsl,mpc5200-ata\", },\n\t{ .compatible = \"mpc5200-ata\", },\n\t{   }\n};\n\n\nstatic struct platform_driver mpc52xx_ata_of_platform_driver = {\n\t.probe\t\t= mpc52xx_ata_probe,\n\t.remove_new\t= mpc52xx_ata_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= mpc52xx_ata_suspend,\n\t.resume\t\t= mpc52xx_ata_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = mpc52xx_ata_of_match,\n\t},\n};\n\nmodule_platform_driver(mpc52xx_ata_of_platform_driver);\n\nMODULE_AUTHOR(\"Sylvain Munaut <tnt@246tNt.com>\");\nMODULE_DESCRIPTION(\"Freescale MPC52xx IDE/ATA libata driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, mpc52xx_ata_of_match);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}