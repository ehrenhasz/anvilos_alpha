{
  "module_name": "pata_cypress.c",
  "hash_id": "62e9f1d95bcc5fd6b768d795330c2664214a318fa9bce8471e2feb4c2f0c47ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_cypress.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_cypress\"\n#define DRV_VERSION \"0.1.5\"\n\n \n\nenum {\n\tCY82_IDE_CMDREG\t\t= 0x04,\n\tCY82_IDE_ADDRSETUP\t= 0x48,\n\tCY82_IDE_MASTER_IOR\t= 0x4C,\n\tCY82_IDE_MASTER_IOW\t= 0x4D,\n\tCY82_IDE_SLAVE_IOR\t= 0x4E,\n\tCY82_IDE_SLAVE_IOW\t= 0x4F,\n\tCY82_IDE_MASTER_8BIT\t= 0x50,\n\tCY82_IDE_SLAVE_8BIT\t= 0x51,\n\n\tCY82_INDEX_PORT\t\t= 0x22,\n\tCY82_DATA_PORT\t\t= 0x23,\n\n\tCY82_INDEX_CTRLREG1\t= 0x01,\n\tCY82_INDEX_CHANNEL0\t= 0x30,\n\tCY82_INDEX_CHANNEL1\t= 0x31,\n\tCY82_INDEX_TIMEOUT\t= 0x32\n};\n\nstatic bool enable_dma = true;\nmodule_param(enable_dma, bool, 0);\nMODULE_PARM_DESC(enable_dma, \"Enable bus master DMA operations\");\n\n \n\nstatic void cy82c693_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct ata_timing t;\n\tconst unsigned long T = 1000000 / 33;\n\tshort time_16, time_8;\n\tu32 addr;\n\n\tif (ata_timing_compute(adev, adev->pio_mode, &t, T, 1) < 0) {\n\t\tata_dev_err(adev, DRV_NAME \": mome computation failed.\\n\");\n\t\treturn;\n\t}\n\n\ttime_16 = clamp_val(t.recover - 1, 0, 15) |\n\t\t  (clamp_val(t.active - 1, 0, 15) << 4);\n\ttime_8 = clamp_val(t.act8b - 1, 0, 15) |\n\t\t (clamp_val(t.rec8b - 1, 0, 15) << 4);\n\n\tif (adev->devno == 0) {\n\t\tpci_read_config_dword(pdev, CY82_IDE_ADDRSETUP, &addr);\n\n\t\taddr &= ~0x0F;\t \n\t\taddr |= clamp_val(t.setup - 1, 0, 15);\n\n\t\tpci_write_config_dword(pdev, CY82_IDE_ADDRSETUP, addr);\n\t\tpci_write_config_byte(pdev, CY82_IDE_MASTER_IOR, time_16);\n\t\tpci_write_config_byte(pdev, CY82_IDE_MASTER_IOW, time_16);\n\t\tpci_write_config_byte(pdev, CY82_IDE_MASTER_8BIT, time_8);\n\t} else {\n\t\tpci_read_config_dword(pdev, CY82_IDE_ADDRSETUP, &addr);\n\n\t\taddr &= ~0xF0;\t \n\t\taddr |= (clamp_val(t.setup - 1, 0, 15) << 4);\n\n\t\tpci_write_config_dword(pdev, CY82_IDE_ADDRSETUP, addr);\n\t\tpci_write_config_byte(pdev, CY82_IDE_SLAVE_IOR, time_16);\n\t\tpci_write_config_byte(pdev, CY82_IDE_SLAVE_IOW, time_16);\n\t\tpci_write_config_byte(pdev, CY82_IDE_SLAVE_8BIT, time_8);\n\t}\n}\n\n \n\nstatic void cy82c693_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tint reg = CY82_INDEX_CHANNEL0 + ap->port_no;\n\n\t \n\toutb(reg, 0x22);\n\toutb(adev->dma_mode - XFER_MW_DMA_0, 0x23);\n\n\t \n\toutb(CY82_INDEX_TIMEOUT, 0x22);\n\toutb(0x50, 0x23);\n}\n\nstatic const struct scsi_host_template cy82c693_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations cy82c693_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= cy82c693_set_piomode,\n\t.set_dmamode\t= cy82c693_set_dmamode,\n};\n\nstatic int cy82c693_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.port_ops = &cy82c693_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, &ata_dummy_port_info };\n\n\tif (enable_dma)\n\t\tinfo.mwdma_mask = ATA_MWDMA2;\n\n\t \n\n\tif (PCI_FUNC(pdev->devfn) != 1)\n\t\treturn -ENODEV;\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &cy82c693_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id cy82c693[] = {\n\t{ PCI_VDEVICE(CONTAQ, PCI_DEVICE_ID_CONTAQ_82C693), },\n\n\t{ },\n};\n\nstatic struct pci_driver cy82c693_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= cy82c693,\n\t.probe \t\t= cy82c693_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(cy82c693_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the CY82C693 PATA controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, cy82c693);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}