{
  "module_name": "ahci.c",
  "hash_id": "dae730ecdb6c26c34f12d4910742ada419d874c649384fe6614dfa0ef62b8d88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n#include <linux/ahci-remap.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include \"ahci.h\"\n\n#define DRV_NAME\t\"ahci\"\n#define DRV_VERSION\t\"3.0\"\n\nenum {\n\tAHCI_PCI_BAR_STA2X11\t= 0,\n\tAHCI_PCI_BAR_CAVIUM\t= 0,\n\tAHCI_PCI_BAR_LOONGSON\t= 0,\n\tAHCI_PCI_BAR_ENMOTUS\t= 2,\n\tAHCI_PCI_BAR_CAVIUM_GEN5\t= 4,\n\tAHCI_PCI_BAR_STANDARD\t= 5,\n};\n\nenum board_ids {\n\t \n\tboard_ahci,\n\tboard_ahci_ign_iferr,\n\tboard_ahci_low_power,\n\tboard_ahci_no_debounce_delay,\n\tboard_ahci_nomsi,\n\tboard_ahci_noncq,\n\tboard_ahci_nosntf,\n\tboard_ahci_yes_fbs,\n\n\t \n\tboard_ahci_al,\n\tboard_ahci_avn,\n\tboard_ahci_mcp65,\n\tboard_ahci_mcp77,\n\tboard_ahci_mcp89,\n\tboard_ahci_mv,\n\tboard_ahci_sb600,\n\tboard_ahci_sb700,\t \n\tboard_ahci_vt8251,\n\n\t \n\tboard_ahci_pcs7,\n\n\t \n\tboard_ahci_mcp_linux\t= board_ahci_mcp65,\n\tboard_ahci_mcp67\t= board_ahci_mcp65,\n\tboard_ahci_mcp73\t= board_ahci_mcp65,\n\tboard_ahci_mcp79\t= board_ahci_mcp77,\n};\n\nstatic int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void ahci_remove_one(struct pci_dev *dev);\nstatic void ahci_shutdown_one(struct pci_dev *dev);\nstatic void ahci_intel_pcs_quirk(struct pci_dev *pdev, struct ahci_host_priv *hpriv);\nstatic int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\t unsigned long deadline);\nstatic int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline);\nstatic void ahci_mcp89_apple_enable(struct pci_dev *pdev);\nstatic bool is_mcp89_apple(struct pci_dev *pdev);\nstatic int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\tunsigned long deadline);\n#ifdef CONFIG_PM\nstatic int ahci_pci_device_runtime_suspend(struct device *dev);\nstatic int ahci_pci_device_runtime_resume(struct device *dev);\n#ifdef CONFIG_PM_SLEEP\nstatic int ahci_pci_device_suspend(struct device *dev);\nstatic int ahci_pci_device_resume(struct device *dev);\n#endif\n#endif  \n\nstatic const struct scsi_host_template ahci_sht = {\n\tAHCI_SHT(\"ahci\"),\n};\n\nstatic struct ata_port_operations ahci_vt8251_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.hardreset\t\t= ahci_vt8251_hardreset,\n};\n\nstatic struct ata_port_operations ahci_p5wdh_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.hardreset\t\t= ahci_p5wdh_hardreset,\n};\n\nstatic struct ata_port_operations ahci_avn_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.hardreset\t\t= ahci_avn_hardreset,\n};\n\nstatic const struct ata_port_info ahci_port_info[] = {\n\t \n\t[board_ahci] = {\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_ign_iferr] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_IGN_IRQ_IF_ERR),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_low_power] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_USE_LPM_POLICY),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_no_debounce_delay] = {\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.link_flags\t= ATA_LFLAG_NO_DEBOUNCE_DELAY,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_nomsi] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_MSI),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_noncq] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_NCQ),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_nosntf] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_SNTF),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_yes_fbs] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_YES_FBS),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t \n\t[board_ahci_al] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_PMP | AHCI_HFLAG_NO_MSI),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_avn] = {\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_avn_ops,\n\t},\n\t[board_ahci_mcp65] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |\n\t\t\t\t AHCI_HFLAG_YES_NCQ),\n\t\t.flags\t\t= AHCI_FLAG_COMMON | ATA_FLAG_NO_DIPM,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_mcp77] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_mcp89] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_FPDMA_AA),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_mv] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_NCQ | AHCI_HFLAG_NO_MSI |\n\t\t\t\t AHCI_HFLAG_MV_PATA | AHCI_HFLAG_NO_PMP),\n\t\t.flags\t\t= ATA_FLAG_SATA | ATA_FLAG_PIO_DMA,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n\t[board_ahci_sb600] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_IGN_SERR_INTERNAL |\n\t\t\t\t AHCI_HFLAG_NO_MSI | AHCI_HFLAG_SECT255 |\n\t\t\t\t AHCI_HFLAG_32BIT_ONLY),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_pmp_retry_srst_ops,\n\t},\n\t[board_ahci_sb700] = {\t \n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_IGN_SERR_INTERNAL),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_pmp_retry_srst_ops,\n\t},\n\t[board_ahci_vt8251] = {\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_NCQ | AHCI_HFLAG_NO_PMP),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_vt8251_ops,\n\t},\n\t[board_ahci_pcs7] = {\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &ahci_ops,\n\t},\n};\n\nstatic const struct pci_device_id ahci_pci_tbl[] = {\n\t \n\t{ PCI_VDEVICE(INTEL, 0x06d6), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2652), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2653), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x27c1), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x27c5), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x27c3), board_ahci },  \n\t{ PCI_VDEVICE(AL, 0x5288), board_ahci_ign_iferr },  \n\t{ PCI_VDEVICE(INTEL, 0x2681), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2682), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2683), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x27c6), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2821), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2822), board_ahci_nosntf },  \n\t{ PCI_VDEVICE(INTEL, 0x2824), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2829), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x282a), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2922), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2923), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2924), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2925), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2927), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2929), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x292a), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x292b), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x292c), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x292f), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x294d), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x294e), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x502a), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x502b), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3a05), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3a22), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3a25), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3b22), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3b23), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3b24), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3b25), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3b29), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x3b2b), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x3b2f), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x19b0), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b1), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b2), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b3), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b4), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b5), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b6), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19b7), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19bE), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19bF), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c0), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c1), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c2), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c3), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c4), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c5), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c6), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19c7), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19cE), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x19cF), board_ahci_pcs7 },  \n\t{ PCI_VDEVICE(INTEL, 0x1c02), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x1c04), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1c05), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x1c06), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1c07), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1d02), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1d04), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1d06), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2323), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1e02), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1e03), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x1e04), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1e05), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1e06), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1e07), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x1e0e), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c02), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c03), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c04), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c05), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c06), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c07), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c0e), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c0f), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c02), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c03), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c04), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c05), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c06), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c07), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c0e), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c0f), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9dd3), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x1f22), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f23), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f24), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f25), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f26), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f27), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f2e), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f2f), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci_avn },  \n\t{ PCI_VDEVICE(INTEL, 0x2823), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2826), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x2827), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x282f), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x43d4), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x43d5), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x43d6), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x43d7), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d02), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d04), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d06), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d0e), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d62), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d64), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d66), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8d6e), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x23a3), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x9c83), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c85), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c87), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9c8f), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c82), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c83), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c84), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c85), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c86), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c87), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x8c8e), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x8c8f), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9d03), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9d05), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x9d07), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0xa102), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa103), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0xa105), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa106), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa107), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0xa10f), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa182), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa186), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa1d2), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa1d6), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa202), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa206), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa252), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa256), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa356), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x06d7), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0xa386), board_ahci },  \n\t{ PCI_VDEVICE(INTEL, 0x0f22), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x0f23), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x22a3), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x5ae3), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x34d3), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x02d3), board_ahci_low_power },  \n\t{ PCI_VDEVICE(INTEL, 0x02d7), board_ahci_low_power },  \n\t \n\n\t \n\t{ PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci_ign_iferr },\n\t \n\t{ PCI_VDEVICE(JMICRON, 0x2362), board_ahci_ign_iferr },\n\t{ PCI_VDEVICE(JMICRON, 0x236f), board_ahci_ign_iferr },\n\t \n\n\t \n\t{ PCI_VDEVICE(ATI, 0x4380), board_ahci_sb600 },  \n\t{ PCI_VDEVICE(ATI, 0x4390), board_ahci_sb700 },  \n\t{ PCI_VDEVICE(ATI, 0x4391), board_ahci_sb700 },  \n\t{ PCI_VDEVICE(ATI, 0x4392), board_ahci_sb700 },  \n\t{ PCI_VDEVICE(ATI, 0x4393), board_ahci_sb700 },  \n\t{ PCI_VDEVICE(ATI, 0x4394), board_ahci_sb700 },  \n\t{ PCI_VDEVICE(ATI, 0x4395), board_ahci_sb700 },  \n\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS, 0x0031),\n\t\t.class = PCI_CLASS_STORAGE_SATA_AHCI,\n\t\t.class_mask = 0xffffff,\n\t\tboard_ahci_al },\n\t \n\t{ PCI_VDEVICE(AMD, 0x7800), board_ahci },  \n\t{ PCI_VDEVICE(AMD, 0x7801), board_ahci_no_debounce_delay },  \n\t{ PCI_VDEVICE(AMD, 0x7900), board_ahci },  \n\t{ PCI_VDEVICE(AMD, 0x7901), board_ahci_low_power },  \n\t \n\t{ PCI_VENDOR_ID_AMD, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_RAID << 8, 0xffffff, board_ahci },\n\n\t \n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_SUBVENDOR_ID_DELL, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_RAID << 8, 0xffffff, board_ahci },\n\n\t \n\t{ PCI_VDEVICE(VIA, 0x3349), board_ahci_vt8251 },  \n\t{ PCI_VDEVICE(VIA, 0x6287), board_ahci_vt8251 },  \n\n\t \n\t{ PCI_VDEVICE(NVIDIA, 0x044c), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x044d), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x044e), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x044f), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x045c), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x045d), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x045e), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x045f), board_ahci_mcp65 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0550), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0551), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0552), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0553), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0554), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0555), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0556), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0557), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0558), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0559), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x055a), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x055b), board_ahci_mcp67 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0580), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0581), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0582), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0583), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0584), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0585), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0586), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0587), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0588), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0589), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x058a), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x058b), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x058c), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x058d), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x058e), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x058f), board_ahci_mcp_linux },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f0), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f1), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f2), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f3), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f4), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f5), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f6), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f7), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f8), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07f9), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07fa), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x07fb), board_ahci_mcp73 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad0), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad1), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad2), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad3), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad4), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad5), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad6), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad7), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad8), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ad9), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ada), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0adb), board_ahci_mcp77 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ab4), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ab5), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ab6), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ab7), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ab8), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0ab9), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0aba), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0abb), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0abc), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0abd), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0abe), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0abf), board_ahci_mcp79 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d84), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d85), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d86), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d87), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d88), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d89), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d8a), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d8b), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d8c), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d8d), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d8e), board_ahci_mcp89 },\t \n\t{ PCI_VDEVICE(NVIDIA, 0x0d8f), board_ahci_mcp89 },\t \n\n\t \n\t{ PCI_VDEVICE(SI, 0x1184), board_ahci },\t\t \n\t{ PCI_VDEVICE(SI, 0x1185), board_ahci },\t\t \n\t{ PCI_VDEVICE(SI, 0x0186), board_ahci },\t\t \n\n\t \n\t{ PCI_VDEVICE(STMICRO, 0xCC06), board_ahci },\t\t \n\n\t \n\t{ PCI_VDEVICE(MARVELL, 0x6145), board_ahci_mv },\t \n\t{ PCI_VDEVICE(MARVELL, 0x6121), board_ahci_mv },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9123),\n\t  .class = PCI_CLASS_STORAGE_SATA_AHCI,\n\t  .class_mask = 0xffffff,\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9125),\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_MARVELL_EXT, 0x9178,\n\t\t\t PCI_VENDOR_ID_MARVELL_EXT, 0x9170),\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x917a),\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9172),\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9182),\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9192),\n\t  .driver_data = board_ahci_yes_fbs },\t\t\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x91a0),\n\t  .driver_data = board_ahci_yes_fbs },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x91a2), \t \n\t  .driver_data = board_ahci_yes_fbs },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x91a3),\n\t  .driver_data = board_ahci_yes_fbs },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9230),\n\t  .driver_data = board_ahci_yes_fbs },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL_EXT, 0x9235),\n\t  .driver_data = board_ahci_no_debounce_delay },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TTI, 0x0642),  \n\t  .driver_data = board_ahci_yes_fbs },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TTI, 0x0645),  \n\t  .driver_data = board_ahci_yes_fbs },\n\n\t \n\t{ PCI_VDEVICE(PROMISE, 0x3f20), board_ahci },\t \n\t{ PCI_VDEVICE(PROMISE, 0x3781), board_ahci },    \n\n\t \n\t{ PCI_VDEVICE(ASMEDIA, 0x0601), board_ahci },\t \n\t{ PCI_VDEVICE(ASMEDIA, 0x0602), board_ahci },\t \n\t{ PCI_VDEVICE(ASMEDIA, 0x0611), board_ahci },\t \n\t{ PCI_VDEVICE(ASMEDIA, 0x0612), board_ahci },\t \n\t{ PCI_VDEVICE(ASMEDIA, 0x0621), board_ahci },    \n\t{ PCI_VDEVICE(ASMEDIA, 0x0622), board_ahci },    \n\t{ PCI_VDEVICE(ASMEDIA, 0x0624), board_ahci },    \n\n\t \n\t{ PCI_VDEVICE(SAMSUNG, 0x1600), board_ahci_nomsi },\n\t{ PCI_VDEVICE(SAMSUNG, 0xa800), board_ahci_nomsi },\n\n\t \n\t{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },\n\n\t \n\t{ PCI_VDEVICE(LOONGSON, 0x7a08), board_ahci },\n\n\t \n\t{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },\n\n\t{ }\t \n};\n\nstatic const struct dev_pm_ops ahci_pci_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ahci_pci_device_suspend, ahci_pci_device_resume)\n\tSET_RUNTIME_PM_OPS(ahci_pci_device_runtime_suspend,\n\t\t\t   ahci_pci_device_runtime_resume, NULL)\n};\n\nstatic struct pci_driver ahci_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= ahci_pci_tbl,\n\t.probe\t\t\t= ahci_init_one,\n\t.remove\t\t\t= ahci_remove_one,\n\t.shutdown\t\t= ahci_shutdown_one,\n\t.driver = {\n\t\t.pm\t\t= &ahci_pci_pm_ops,\n\t},\n};\n\n#if IS_ENABLED(CONFIG_PATA_MARVELL)\nstatic int marvell_enable;\n#else\nstatic int marvell_enable = 1;\n#endif\nmodule_param(marvell_enable, int, 0644);\nMODULE_PARM_DESC(marvell_enable, \"Marvell SATA via AHCI (1 = enabled)\");\n\nstatic int mobile_lpm_policy = -1;\nmodule_param(mobile_lpm_policy, int, 0644);\nMODULE_PARM_DESC(mobile_lpm_policy, \"Default LPM policy for mobile chipsets\");\n\nstatic void ahci_pci_save_initial_config(struct pci_dev *pdev,\n\t\t\t\t\t struct ahci_host_priv *hpriv)\n{\n\tif (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361) {\n\t\tdev_info(&pdev->dev, \"JMB361 has only one port\\n\");\n\t\thpriv->saved_port_map = 1;\n\t}\n\n\t \n\tif (hpriv->flags & AHCI_HFLAG_MV_PATA) {\n\t\tif (pdev->device == 0x6121)\n\t\t\thpriv->mask_port_map = 0x3;\n\t\telse\n\t\t\thpriv->mask_port_map = 0xf;\n\t\tdev_info(&pdev->dev,\n\t\t\t  \"Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\\n\");\n\t}\n\n\tahci_save_initial_config(&pdev->dev, hpriv);\n}\n\nstatic int ahci_pci_reset_controller(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_reset_controller(host);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tahci_intel_pcs_quirk(pdev, hpriv);\n\n\treturn 0;\n}\n\nstatic void ahci_pci_init_controller(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tvoid __iomem *port_mmio;\n\tu32 tmp;\n\tint mv;\n\n\tif (hpriv->flags & AHCI_HFLAG_MV_PATA) {\n\t\tif (pdev->device == 0x6121)\n\t\t\tmv = 2;\n\t\telse\n\t\t\tmv = 4;\n\t\tport_mmio = __ahci_port_base(hpriv, mv);\n\n\t\twritel(0, port_mmio + PORT_IRQ_MASK);\n\n\t\t \n\t\ttmp = readl(port_mmio + PORT_IRQ_STAT);\n\t\tdev_dbg(&pdev->dev, \"PORT_IRQ_STAT 0x%x\\n\", tmp);\n\t\tif (tmp)\n\t\t\twritel(tmp, port_mmio + PORT_IRQ_STAT);\n\t}\n\n\tahci_init_controller(host);\n}\n\nstatic int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\t unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tbool online;\n\tint rc;\n\n\thpriv->stop_engine(ap);\n\n\trc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),\n\t\t\t\t deadline, &online, NULL);\n\n\thpriv->start_engine(ap);\n\n\t \n\treturn online ? -EAGAIN : rc;\n}\n\nstatic int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\tunsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tint rc;\n\n\thpriv->stop_engine(ap);\n\n\t \n\tata_tf_init(link->device, &tf);\n\ttf.status = ATA_BUSY;\n\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\trc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),\n\t\t\t\t deadline, &online, NULL);\n\n\thpriv->start_engine(ap);\n\n\t \n\tif (online) {\n\t\trc = ata_wait_after_reset(link, jiffies + 2 * HZ,\n\t\t\t\t\t  ahci_check_ready);\n\t\tif (rc)\n\t\t\tahci_kick_engine(ap);\n\t}\n\treturn rc;\n}\n\n \nstatic int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tconst unsigned int *timing = sata_ehc_deb_timing(&link->eh_context);\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tunsigned long tmo = deadline - jiffies;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tint rc, i;\n\n\thpriv->stop_engine(ap);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tu16 val;\n\t\tu32 sstatus;\n\t\tint port = ap->port_no;\n\t\tstruct ata_host *host = ap->host;\n\t\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\n\t\t \n\t\tata_tf_init(link->device, &tf);\n\t\ttf.status = ATA_BUSY;\n\t\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\t\trc = sata_link_hardreset(link, timing, deadline, &online,\n\t\t\t\tahci_check_ready);\n\n\t\tif (sata_scr_read(link, SCR_STATUS, &sstatus) != 0 ||\n\t\t\t\t(sstatus & 0xf) != 1)\n\t\t\tbreak;\n\n\t\tata_link_info(link,  \"avn bounce port%d\\n\", port);\n\n\t\tpci_read_config_word(pdev, 0x92, &val);\n\t\tval &= ~(1 << port);\n\t\tpci_write_config_word(pdev, 0x92, val);\n\t\tata_msleep(ap, 1000);\n\t\tval |= 1 << port;\n\t\tpci_write_config_word(pdev, 0x92, val);\n\t\tdeadline += tmo;\n\t}\n\n\thpriv->start_engine(ap);\n\n\tif (online)\n\t\t*class = ahci_dev_classify(ap);\n\n\treturn rc;\n}\n\n\n#ifdef CONFIG_PM\nstatic void ahci_pci_disable_interrupts(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 ctl;\n\n\t \n\tctl = readl(mmio + HOST_CTL);\n\tctl &= ~HOST_IRQ_EN;\n\twritel(ctl, mmio + HOST_CTL);\n\treadl(mmio + HOST_CTL);  \n}\n\nstatic int ahci_pci_device_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\tahci_pci_disable_interrupts(host);\n\treturn 0;\n}\n\nstatic int ahci_pci_device_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ahci_pci_reset_controller(host);\n\tif (rc)\n\t\treturn rc;\n\tahci_pci_init_controller(host);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ahci_pci_device_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\tif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"BIOS update required for suspend/resume\\n\");\n\t\treturn -EIO;\n\t}\n\n\tahci_pci_disable_interrupts(host);\n\tata_host_suspend(host, PMSG_SUSPEND);\n\treturn 0;\n}\n\nstatic int ahci_pci_device_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\t \n\tif (is_mcp89_apple(pdev))\n\t\tahci_mcp89_apple_enable(pdev);\n\n\tif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\n\t\trc = ahci_pci_reset_controller(host);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tahci_pci_init_controller(host);\n\t}\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\n#endif  \n\nstatic int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)\n{\n\tconst int dma_bits = using_dac ? 64 : 32;\n\tint rc;\n\n\t \n\tif (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))\n\t\treturn 0;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(dma_bits));\n\tif (rc)\n\t\tdev_err(&pdev->dev, \"DMA enable failed\\n\");\n\treturn rc;\n}\n\nstatic void ahci_pci_print_info(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tu16 cc;\n\tconst char *scc_s;\n\n\tpci_read_config_word(pdev, 0x0a, &cc);\n\tif (cc == PCI_CLASS_STORAGE_IDE)\n\t\tscc_s = \"IDE\";\n\telse if (cc == PCI_CLASS_STORAGE_SATA)\n\t\tscc_s = \"SATA\";\n\telse if (cc == PCI_CLASS_STORAGE_RAID)\n\t\tscc_s = \"RAID\";\n\telse\n\t\tscc_s = \"unknown\";\n\n\tahci_print_info(host, scc_s);\n}\n\n \nstatic void ahci_p5wdh_workaround(struct ata_host *host)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t{\n\t\t\t.ident = \"P5W DH Deluxe\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t  \"ASUSTEK COMPUTER INC\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"P5W DH Deluxe\"),\n\t\t\t},\n\t\t},\n\t\t{ }\n\t};\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\n\tif (pdev->bus->number == 0 && pdev->devfn == PCI_DEVFN(0x1f, 2) &&\n\t    dmi_check_system(sysids)) {\n\t\tstruct ata_port *ap = host->ports[1];\n\n\t\tdev_info(&pdev->dev,\n\t\t\t \"enabling ASUS P5W DH Deluxe on-board SIMG4726 workaround\\n\");\n\n\t\tap->ops = &ahci_p5wdh_ops;\n\t\tap->link.flags |= ATA_LFLAG_NO_SRST | ATA_LFLAG_ASSUME_ATA;\n\t}\n}\n\n \nstatic void ahci_mcp89_apple_enable(struct pci_dev *pdev)\n{\n\tu32 val;\n\n\tprintk(KERN_INFO \"ahci: enabling MCP89 AHCI mode\\n\");\n\n\tpci_read_config_dword(pdev, 0xf8, &val);\n\tval |= 1 << 0x1b;\n\t \n\t \n\tpci_write_config_dword(pdev, 0xf8, val);\n\n\tpci_read_config_dword(pdev, 0x54c, &val);\n\tval |= 1 << 0xc;\n\tpci_write_config_dword(pdev, 0x54c, val);\n\n\tpci_read_config_dword(pdev, 0x4a4, &val);\n\tval &= 0xff;\n\tval |= 0x01060100;\n\tpci_write_config_dword(pdev, 0x4a4, val);\n\n\tpci_read_config_dword(pdev, 0x54c, &val);\n\tval &= ~(1 << 0xc);\n\tpci_write_config_dword(pdev, 0x54c, val);\n\n\tpci_read_config_dword(pdev, 0xf8, &val);\n\tval &= ~(1 << 0x1b);\n\tpci_write_config_dword(pdev, 0xf8, val);\n}\n\nstatic bool is_mcp89_apple(struct pci_dev *pdev)\n{\n\treturn pdev->vendor == PCI_VENDOR_ID_NVIDIA &&\n\t\tpdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA &&\n\t\tpdev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&\n\t\tpdev->subsystem_device == 0xcb89;\n}\n\n \nstatic bool ahci_sb600_enable_64bit(struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t \n\t\t{\n\t\t\t.ident = \"ASUS M2A-VM\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t  \"ASUSTeK Computer INC.\"),\n\t\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M2A-VM\"),\n\t\t\t},\n\t\t\t.driver_data = \"20071026\",\t \n\t\t},\n\t\t \n\t\t{\n\t\t\t.ident = \"MSI K9A2 Platinum\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t  \"MICRO-STAR INTER\"),\n\t\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-7376\"),\n\t\t\t},\n\t\t},\n\t\t \n\t\t{\n\t\t\t.ident = \"MSI K9AGM2\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t  \"MICRO-STAR INTER\"),\n\t\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"MS-7327\"),\n\t\t\t},\n\t\t},\n\t\t \n\t\t{\n\t\t\t.ident = \"ASUS M3A\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t  \"ASUSTeK Computer INC.\"),\n\t\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M3A\"),\n\t\t\t},\n\t\t},\n\t\t{ }\n\t};\n\tconst struct dmi_system_id *match;\n\tint year, month, date;\n\tchar buf[9];\n\n\tmatch = dmi_first_match(sysids);\n\tif (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||\n\t    !match)\n\t\treturn false;\n\n\tif (!match->driver_data)\n\t\tgoto enable_64bit;\n\n\tdmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\n\tsnprintf(buf, sizeof(buf), \"%04d%02d%02d\", year, month, date);\n\n\tif (strcmp(buf, match->driver_data) >= 0)\n\t\tgoto enable_64bit;\n\telse {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"%s: BIOS too old, forcing 32bit DMA, update BIOS\\n\",\n\t\t\t match->ident);\n\t\treturn false;\n\t}\n\nenable_64bit:\n\tdev_warn(&pdev->dev, \"%s: enabling 64bit DMA\\n\", match->ident);\n\treturn true;\n}\n\nstatic bool ahci_broken_system_poweroff(struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id broken_systems[] = {\n\t\t{\n\t\t\t.ident = \"HP Compaq nx6310\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq nx6310\"),\n\t\t\t},\n\t\t\t \n\t\t\t.driver_data = (void *)0x1FUL,\n\t\t},\n\t\t{\n\t\t\t.ident = \"HP Compaq 6720s\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq 6720s\"),\n\t\t\t},\n\t\t\t \n\t\t\t.driver_data = (void *)0x1FUL,\n\t\t},\n\n\t\t{ }\t \n\t};\n\tconst struct dmi_system_id *dmi = dmi_first_match(broken_systems);\n\n\tif (dmi) {\n\t\tunsigned long slot = (unsigned long)dmi->driver_data;\n\t\t \n\t\treturn slot == PCI_SLOT(pdev->devfn);\n\t}\n\n\treturn false;\n}\n\nstatic bool ahci_broken_suspend(struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t \n\t\t{\n\t\t\t.ident = \"dv4\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME,\n\t\t\t\t\t  \"HP Pavilion dv4 Notebook PC\"),\n\t\t\t},\n\t\t\t.driver_data = \"20090105\",\t \n\t\t},\n\t\t{\n\t\t\t.ident = \"dv5\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME,\n\t\t\t\t\t  \"HP Pavilion dv5 Notebook PC\"),\n\t\t\t},\n\t\t\t.driver_data = \"20090506\",\t \n\t\t},\n\t\t{\n\t\t\t.ident = \"dv6\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME,\n\t\t\t\t\t  \"HP Pavilion dv6 Notebook PC\"),\n\t\t\t},\n\t\t\t.driver_data = \"20090423\",\t \n\t\t},\n\t\t{\n\t\t\t.ident = \"HDX18\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME,\n\t\t\t\t\t  \"HP HDX18 Notebook PC\"),\n\t\t\t},\n\t\t\t.driver_data = \"20090430\",\t \n\t\t},\n\t\t \n\t\t{\n\t\t\t.ident = \"G725\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"eMachines\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"eMachines G725\"),\n\t\t\t},\n\t\t\t.driver_data = \"20091216\",\t \n\t\t},\n\t\t{ }\t \n\t};\n\tconst struct dmi_system_id *dmi = dmi_first_match(sysids);\n\tint year, month, date;\n\tchar buf[9];\n\n\tif (!dmi || pdev->bus->number || pdev->devfn != PCI_DEVFN(0x1f, 2))\n\t\treturn false;\n\n\tdmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\n\tsnprintf(buf, sizeof(buf), \"%04d%02d%02d\", year, month, date);\n\n\treturn strcmp(buf, dmi->driver_data) < 0;\n}\n\nstatic bool ahci_broken_lpm(struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t \n\t\t{\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"ThinkPad X250\"),\n\t\t\t},\n\t\t\t.driver_data = \"20180406\",  \n\t\t},\n\t\t{\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"ThinkPad L450\"),\n\t\t\t},\n\t\t\t.driver_data = \"20180420\",  \n\t\t},\n\t\t{\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"ThinkPad T450s\"),\n\t\t\t},\n\t\t\t.driver_data = \"20180315\",  \n\t\t},\n\t\t{\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"ThinkPad W541\"),\n\t\t\t},\n\t\t\t \n\t\t\t.driver_data = \"20180310\",  \n\t\t},\n\t\t{ }\t \n\t};\n\tconst struct dmi_system_id *dmi = dmi_first_match(sysids);\n\tint year, month, date;\n\tchar buf[9];\n\n\tif (!dmi)\n\t\treturn false;\n\n\tdmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\n\tsnprintf(buf, sizeof(buf), \"%04d%02d%02d\", year, month, date);\n\n\treturn strcmp(buf, dmi->driver_data) < 0;\n}\n\nstatic bool ahci_broken_online(struct pci_dev *pdev)\n{\n#define ENCODE_BUSDEVFN(bus, slot, func)\t\t\t\\\n\t(void *)(unsigned long)(((bus) << 8) | PCI_DEVFN((slot), (func)))\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t \n\t\t{\n\t\t\t.ident = \"EP45-DQ6\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t  \"Gigabyte Technology Co., Ltd.\"),\n\t\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"EP45-DQ6\"),\n\t\t\t},\n\t\t\t.driver_data = ENCODE_BUSDEVFN(0x0a, 0x00, 0),\n\t\t},\n\t\t{\n\t\t\t.ident = \"EP45-DS5\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t  \"Gigabyte Technology Co., Ltd.\"),\n\t\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"EP45-DS5\"),\n\t\t\t},\n\t\t\t.driver_data = ENCODE_BUSDEVFN(0x03, 0x00, 0),\n\t\t},\n\t\t{ }\t \n\t};\n#undef ENCODE_BUSDEVFN\n\tconst struct dmi_system_id *dmi = dmi_first_match(sysids);\n\tunsigned int val;\n\n\tif (!dmi)\n\t\treturn false;\n\n\tval = (unsigned long)dmi->driver_data;\n\n\treturn pdev->bus->number == (val >> 8) && pdev->devfn == (val & 0xff);\n}\n\nstatic bool ahci_broken_devslp(struct pci_dev *pdev)\n{\n\t \n\tstatic const struct pci_device_id ids[] = {\n\t\t{ PCI_VDEVICE(INTEL, 0x0f23)},  \n\t\t{}\n\t};\n\n\treturn pci_match_id(ids, pdev);\n}\n\n#ifdef CONFIG_ATA_ACPI\nstatic void ahci_gtf_filter_workaround(struct ata_host *host)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t \n\t\t{\n\t\t\t.ident = \"Aspire 3810T\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 3810T\"),\n\t\t\t},\n\t\t\t.driver_data = (void *)ATA_ACPI_FILTER_FPDMA_OFFSET,\n\t\t},\n\t\t{ }\n\t};\n\tconst struct dmi_system_id *dmi = dmi_first_match(sysids);\n\tunsigned int filter;\n\tint i;\n\n\tif (!dmi)\n\t\treturn;\n\n\tfilter = (unsigned long)dmi->driver_data;\n\tdev_info(host->dev, \"applying extra ACPI _GTF filter 0x%x for %s\\n\",\n\t\t filter, dmi->ident);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tstruct ata_link *link;\n\t\tstruct ata_device *dev;\n\n\t\tata_for_each_link(link, ap, EDGE)\n\t\t\tata_for_each_dev(dev, link, ALL)\n\t\t\t\tdev->gtf_filter |= filter;\n\t}\n}\n#else\nstatic inline void ahci_gtf_filter_workaround(struct ata_host *host)\n{}\n#endif\n\n \nstatic void acer_sa5_271_workaround(struct ahci_host_priv *hpriv,\n\t\t\t\t    struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t{\n\t\t\t.ident = \"Acer Switch Alpha 12\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Switch SA5-271\")\n\t\t\t},\n\t\t},\n\t\t{ }\n\t};\n\n\tif (dmi_check_system(sysids)) {\n\t\tdev_info(&pdev->dev, \"enabling Acer Switch Alpha 12 workaround\\n\");\n\t\tif ((hpriv->saved_cap & 0xC734FF00) == 0xC734FF00) {\n\t\t\thpriv->port_map = 0x7;\n\t\t\thpriv->cap = 0xC734FF02;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_ARM64\n \nstatic irqreturn_t ahci_thunderx_irq_handler(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct ahci_host_priv *hpriv;\n\tunsigned int rc = 0;\n\tvoid __iomem *mmio;\n\tu32 irq_stat, irq_masked;\n\tunsigned int handled = 1;\n\n\thpriv = host->private_data;\n\tmmio = hpriv->mmio;\n\tirq_stat = readl(mmio + HOST_IRQ_STAT);\n\tif (!irq_stat)\n\t\treturn IRQ_NONE;\n\n\tdo {\n\t\tirq_masked = irq_stat & hpriv->port_map;\n\t\tspin_lock(&host->lock);\n\t\trc = ahci_handle_port_intr(host, irq_masked);\n\t\tif (!rc)\n\t\t\thandled = 0;\n\t\twritel(irq_stat, mmio + HOST_IRQ_STAT);\n\t\tirq_stat = readl(mmio + HOST_IRQ_STAT);\n\t\tspin_unlock(&host->lock);\n\t} while (irq_stat);\n\n\treturn IRQ_RETVAL(handled);\n}\n#endif\n\nstatic void ahci_remap_check(struct pci_dev *pdev, int bar,\n\t\tstruct ahci_host_priv *hpriv)\n{\n\tint i;\n\tu32 cap;\n\n\t \n\tif (pdev->vendor != PCI_VENDOR_ID_INTEL ||\n\t    pci_resource_len(pdev, bar) < SZ_512K ||\n\t    bar != AHCI_PCI_BAR_STANDARD ||\n\t    !(readl(hpriv->mmio + AHCI_VSCAP) & 1))\n\t\treturn;\n\n\tcap = readq(hpriv->mmio + AHCI_REMAP_CAP);\n\tfor (i = 0; i < AHCI_MAX_REMAP; i++) {\n\t\tif ((cap & (1 << i)) == 0)\n\t\t\tcontinue;\n\t\tif (readl(hpriv->mmio + ahci_remap_dcc(i))\n\t\t\t\t!= PCI_CLASS_STORAGE_EXPRESS)\n\t\t\tcontinue;\n\n\t\t \n\t\thpriv->remapped_nvme++;\n\t}\n\n\tif (!hpriv->remapped_nvme)\n\t\treturn;\n\n\tdev_warn(&pdev->dev, \"Found %u remapped NVMe devices.\\n\",\n\t\t hpriv->remapped_nvme);\n\tdev_warn(&pdev->dev,\n\t\t \"Switch your BIOS from RAID to AHCI mode to use them.\\n\");\n\n\t \n\thpriv->flags |= AHCI_HFLAG_NO_MSI;\n}\n\nstatic int ahci_get_irq_vector(struct ata_host *host, int port)\n{\n\treturn pci_irq_vector(to_pci_dev(host->dev), port);\n}\n\nstatic int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,\n\t\t\tstruct ahci_host_priv *hpriv)\n{\n\tint nvec;\n\n\tif (hpriv->flags & AHCI_HFLAG_NO_MSI)\n\t\treturn -ENODEV;\n\n\t \n\tif (n_ports > 1) {\n\t\tnvec = pci_alloc_irq_vectors(pdev, n_ports, INT_MAX,\n\t\t\t\tPCI_IRQ_MSIX | PCI_IRQ_MSI);\n\t\tif (nvec > 0) {\n\t\t\tif (!(readl(hpriv->mmio + HOST_CTL) & HOST_MRSM)) {\n\t\t\t\thpriv->get_irq_vector = ahci_get_irq_vector;\n\t\t\t\thpriv->flags |= AHCI_HFLAG_MULTI_MSI;\n\t\t\t\treturn nvec;\n\t\t\t}\n\n\t\t\t \n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"ahci: MRSM is on, fallback to single MSI\\n\");\n\t\t\tpci_free_irq_vectors(pdev);\n\t\t}\n\t}\n\n\t \n\tnvec = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (nvec == 1)\n\t\treturn nvec;\n\treturn pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSIX);\n}\n\nstatic void ahci_update_initial_lpm_policy(struct ata_port *ap,\n\t\t\t\t\t   struct ahci_host_priv *hpriv)\n{\n\tint policy = CONFIG_SATA_MOBILE_LPM_POLICY;\n\n\n\t \n\tif (!(hpriv->flags & AHCI_HFLAG_USE_LPM_POLICY))\n\t\treturn;\n\n\t \n\tif (mobile_lpm_policy != -1) {\n\t\tpolicy = mobile_lpm_policy;\n\t\tgoto update_policy;\n\t}\n\n\tif (policy > ATA_LPM_MED_POWER && pm_suspend_default_s2idle()) {\n\t\tif (hpriv->cap & HOST_CAP_PART)\n\t\t\tpolicy = ATA_LPM_MIN_POWER_WITH_PARTIAL;\n\t\telse if (hpriv->cap & HOST_CAP_SSC)\n\t\t\tpolicy = ATA_LPM_MIN_POWER;\n\t}\n\nupdate_policy:\n\tif (policy >= ATA_LPM_UNKNOWN && policy <= ATA_LPM_MIN_POWER)\n\t\tap->target_lpm_policy = policy;\n}\n\nstatic void ahci_intel_pcs_quirk(struct pci_dev *pdev, struct ahci_host_priv *hpriv)\n{\n\tconst struct pci_device_id *id = pci_match_id(ahci_pci_tbl, pdev);\n\tu16 tmp16;\n\n\t \n\tif (!id || id->vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn;\n\n\t \n\tif (((enum board_ids) id->driver_data) >= board_ahci_pcs7)\n\t\treturn;\n\n\t \n\tpci_read_config_word(pdev, PCS_6, &tmp16);\n\tif ((tmp16 & hpriv->port_map) != hpriv->port_map) {\n\t\ttmp16 |= hpriv->port_map;\n\t\tpci_write_config_word(pdev, PCS_6, tmp16);\n\t}\n}\n\nstatic ssize_t remapped_nvme_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\treturn sysfs_emit(buf, \"%u\\n\", hpriv->remapped_nvme);\n}\n\nstatic DEVICE_ATTR_RO(remapped_nvme);\n\nstatic int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned int board_id = ent->driver_data;\n\tstruct ata_port_info pi = ahci_port_info[board_id];\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct ata_host *host;\n\tint n_ports, i, rc;\n\tint ahci_pci_bar = AHCI_PCI_BAR_STANDARD;\n\n\tWARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)\n\t\treturn -ENODEV;\n\n\t \n\tif (is_mcp89_apple(pdev))\n\t\tahci_mcp89_apple_enable(pdev);\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_PROMISE)\n\t\tdev_info(&pdev->dev,\n\t\t\t \"PDC42819 can only drive SATA devices with this driver\\n\");\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_STMICRO && pdev->device == 0xCC06)\n\t\tahci_pci_bar = AHCI_PCI_BAR_STA2X11;\n\telse if (pdev->vendor == 0x1c44 && pdev->device == 0x8000)\n\t\tahci_pci_bar = AHCI_PCI_BAR_ENMOTUS;\n\telse if (pdev->vendor == PCI_VENDOR_ID_CAVIUM) {\n\t\tif (pdev->device == 0xa01c)\n\t\t\tahci_pci_bar = AHCI_PCI_BAR_CAVIUM;\n\t\tif (pdev->device == 0xa084)\n\t\t\tahci_pci_bar = AHCI_PCI_BAR_CAVIUM_GEN5;\n\t} else if (pdev->vendor == PCI_VENDOR_ID_LOONGSON) {\n\t\tif (pdev->device == 0x7a08)\n\t\t\tahci_pci_bar = AHCI_PCI_BAR_LOONGSON;\n\t}\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    (pdev->device == 0x2652 || pdev->device == 0x2653)) {\n\t\tu8 map;\n\n\t\t \n\t\tpci_read_config_byte(pdev, ICH_MAP, &map);\n\t\tif (map & 0x3) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"controller is in combined mode, can't enable AHCI mode\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\trc = pcim_iomap_regions_request_all(pdev, 1 << ahci_pci_bar, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\thpriv->flags |= (unsigned long)pi.private_data;\n\n\t \n\tif (board_id == board_ahci_mcp65 &&\n\t    (pdev->revision == 0xa1 || pdev->revision == 0xa2))\n\t\thpriv->flags |= AHCI_HFLAG_NO_MSI;\n\n\t \n\tif (board_id == board_ahci_sb700 && pdev->revision >= 0x40)\n\t\thpriv->flags &= ~AHCI_HFLAG_IGN_SERR_INTERNAL;\n\n\t \n\tif (ahci_sb600_enable_64bit(pdev))\n\t\thpriv->flags &= ~AHCI_HFLAG_32BIT_ONLY;\n\n\thpriv->mmio = pcim_iomap_table(pdev)[ahci_pci_bar];\n\n\t \n\tahci_remap_check(pdev, ahci_pci_bar, hpriv);\n\n\tsysfs_add_file_to_group(&pdev->dev.kobj,\n\t\t\t\t&dev_attr_remapped_nvme.attr,\n\t\t\t\tNULL);\n\n\t \n\tif (ahci_broken_devslp(pdev))\n\t\thpriv->flags |= AHCI_HFLAG_NO_DEVSLP;\n\n#ifdef CONFIG_ARM64\n\tif (pdev->vendor == PCI_VENDOR_ID_HUAWEI &&\n\t    pdev->device == 0xa235 &&\n\t    pdev->revision < 0x30)\n\t\thpriv->flags |= AHCI_HFLAG_NO_SXS;\n\n\tif (pdev->vendor == 0x177d && pdev->device == 0xa01c)\n\t\thpriv->irq_handler = ahci_thunderx_irq_handler;\n#endif\n\n\t \n\tahci_pci_save_initial_config(pdev, hpriv);\n\n\t \n\tif (hpriv->cap & HOST_CAP_NCQ) {\n\t\tpi.flags |= ATA_FLAG_NCQ;\n\t\t \n\t\tif (!(hpriv->flags & AHCI_HFLAG_NO_FPDMA_AA))\n\t\t\tpi.flags |= ATA_FLAG_FPDMA_AA;\n\n\t\t \n\t\tpi.flags |= ATA_FLAG_FPDMA_AUX;\n\t}\n\n\tif (hpriv->cap & HOST_CAP_PMP)\n\t\tpi.flags |= ATA_FLAG_PMP;\n\n\tahci_set_em_messages(hpriv, &pi);\n\n\tif (ahci_broken_system_poweroff(pdev)) {\n\t\tpi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN;\n\t\tdev_info(&pdev->dev,\n\t\t\t\"quirky BIOS, skipping spindown on poweroff\\n\");\n\t}\n\n\tif (ahci_broken_lpm(pdev)) {\n\t\tpi.flags |= ATA_FLAG_NO_LPM;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"BIOS update required for Link Power Management support\\n\");\n\t}\n\n\tif (ahci_broken_suspend(pdev)) {\n\t\thpriv->flags |= AHCI_HFLAG_NO_SUSPEND;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"BIOS update required for suspend/resume\\n\");\n\t}\n\n\tif (ahci_broken_online(pdev)) {\n\t\thpriv->flags |= AHCI_HFLAG_SRST_TOUT_IS_OFFLINE;\n\t\tdev_info(&pdev->dev,\n\t\t\t \"online status unreliable, applying workaround\\n\");\n\t}\n\n\n\t \n\tacer_sa5_271_workaround(hpriv, pdev);\n\n\t \n\tn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\n\tif (!host)\n\t\treturn -ENOMEM;\n\thost->private_data = hpriv;\n\n\tif (ahci_init_msi(pdev, n_ports, hpriv) < 0) {\n\t\t \n\t\tpci_intx(pdev, 1);\n\t}\n\thpriv->irq = pci_irq_vector(pdev, 0);\n\n\tif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\n\t\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n\telse\n\t\tdev_info(&pdev->dev, \"SSS flag set, parallel bus scan disabled\\n\");\n\n\tif (!(hpriv->cap & HOST_CAP_PART))\n\t\thost->flags |= ATA_HOST_NO_PART;\n\n\tif (!(hpriv->cap & HOST_CAP_SSC))\n\t\thost->flags |= ATA_HOST_NO_SSC;\n\n\tif (!(hpriv->cap2 & HOST_CAP2_SDS))\n\t\thost->flags |= ATA_HOST_NO_DEVSLP;\n\n\tif (pi.flags & ATA_FLAG_EM)\n\t\tahci_reset_em(host);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tata_port_pbar_desc(ap, ahci_pci_bar, -1, \"abar\");\n\t\tata_port_pbar_desc(ap, ahci_pci_bar,\n\t\t\t\t   0x100 + ap->port_no * 0x80, \"port\");\n\n\t\t \n\t\tif (ap->flags & ATA_FLAG_EM)\n\t\t\tap->em_message_type = hpriv->em_msg_type;\n\n\t\tahci_update_initial_lpm_policy(ap, hpriv);\n\n\t\t \n\t\tif (!(hpriv->port_map & (1 << i)))\n\t\t\tap->ops = &ata_dummy_port_ops;\n\t}\n\n\t \n\tahci_p5wdh_workaround(host);\n\n\t \n\tahci_gtf_filter_workaround(host);\n\n\t \n\trc = ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_pci_reset_controller(host);\n\tif (rc)\n\t\treturn rc;\n\n\tahci_pci_init_controller(host);\n\tahci_pci_print_info(host);\n\n\tpci_set_master(pdev);\n\n\trc = ahci_host_activate(host, &ahci_sht);\n\tif (rc)\n\t\treturn rc;\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\treturn 0;\n}\n\nstatic void ahci_shutdown_one(struct pci_dev *pdev)\n{\n\tata_pci_shutdown_one(pdev);\n}\n\nstatic void ahci_remove_one(struct pci_dev *pdev)\n{\n\tsysfs_remove_file_from_group(&pdev->dev.kobj,\n\t\t\t\t     &dev_attr_remapped_nvme.attr,\n\t\t\t\t     NULL);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tata_pci_remove_one(pdev);\n}\n\nmodule_pci_driver(ahci_pci_driver);\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"AHCI SATA low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, ahci_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}