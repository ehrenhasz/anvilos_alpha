{
  "module_name": "pata_sc1200.c",
  "hash_id": "ec0b75c9493a5a4ed281511b50120aef61046459bca6ac093827ec171904152d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_sc1200.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_sc1200\"\n#define DRV_VERSION\t\"0.2.6\"\n\n#define SC1200_REV_A\t0x00\n#define SC1200_REV_B1\t0x01\n#define SC1200_REV_B3\t0x02\n#define SC1200_REV_C1\t0x03\n#define SC1200_REV_D1\t0x04\n\n \n\nstatic int sc1200_clock(void)\n{\n\t \n\tu8 chip_id = inb(0x903C);\n\tu8 silicon_rev = inb(0x903D);\n\tu16 pci_clock;\n\n\tif (chip_id == 0x04 && silicon_rev < SC1200_REV_B1)\n\t\treturn 0;\t \n\n\t \n\n\tpci_clock = inw(0x901E);\n\tpci_clock >>= 8;\n\tpci_clock &= 0x03;\n\tif (pci_clock == 3)\n\t\tpci_clock = 0;\n\treturn pci_clock;\n}\n\n \n\nstatic void sc1200_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u32 pio_timings[4][5] = {\n\t\t \n\t\t{ 0x00009172, 0x00012171, 0x00020080, 0x00032010, 0x00040010 },\n\t\t \n\t\t{ 0xd1329172, 0x71212171, 0x30200080, 0x20102010, 0x00100010 },\n\t\t \n\t\t{ 0xfaa3f4f3, 0xc23232b2, 0x513101c1, 0x31213121, 0x10211021 },\n\t\t \n\t\t{ 0xfff4fff4, 0xf35353d3, 0x814102f1, 0x42314231, 0x11311131 }\n\t};\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 format;\n\tunsigned int reg = 0x40 + 0x10 * ap->port_no;\n\tint mode = adev->pio_mode - XFER_PIO_0;\n\n\tpci_read_config_dword(pdev, reg + 4, &format);\n\tformat >>= 31;\n\tformat += sc1200_clock();\n\tpci_write_config_dword(pdev, reg + 8 * adev->devno,\n\t\t\t\tpio_timings[format][mode]);\n}\n\n \n\nstatic void sc1200_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u32 udma_timing[3][3] = {\n\t\t{ 0x00921250, 0x00911140, 0x00911030 },\n\t\t{ 0x00932470, 0x00922260, 0x00922140 },\n\t\t{ 0x009436A1, 0x00933481, 0x00923261 }\n\t};\n\n\tstatic const u32 mwdma_timing[3][3] = {\n\t\t{ 0x00077771, 0x00012121, 0x00002020 },\n\t\t{ 0x000BBBB2, 0x00024241, 0x00013131 },\n\t\t{ 0x000FFFF3, 0x00035352, 0x00015151 }\n\t};\n\n\tint clock = sc1200_clock();\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tunsigned int reg = 0x40 + 0x10 * ap->port_no;\n\tint mode = adev->dma_mode;\n\tu32 format;\n\n\tif (mode >= XFER_UDMA_0)\n\t\tformat = udma_timing[clock][mode - XFER_UDMA_0];\n\telse\n\t\tformat = mwdma_timing[clock][mode - XFER_MW_DMA_0];\n\n\tif (adev->devno == 0) {\n\t\tu32 timings;\n\n\t\tpci_read_config_dword(pdev, reg + 4, &timings);\n\t\ttimings &= 0x80000000UL;\n\t\ttimings |= format;\n\t\tpci_write_config_dword(pdev, reg + 4, timings);\n\t} else\n\t\tpci_write_config_dword(pdev, reg + 12, format);\n}\n\n \n\nstatic unsigned int sc1200_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct ata_device *prev = ap->private_data;\n\n\t \n\tif (ata_dma_enabled(adev) && adev != prev && prev != NULL) {\n\t\t \n\t\tif ((ata_using_udma(adev) && !ata_using_udma(prev)) ||\n\t\t    (ata_using_udma(prev) && !ata_using_udma(adev)))\n\t\t    \t \n\t\t    \tsc1200_set_dmamode(ap, adev);\n\t}\n\n\treturn ata_bmdma_qc_issue(qc);\n}\n\n \n\nstatic int sc1200_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_host *host = qc->ap->host;\n\tstruct ata_port *alt = host->ports[1 ^ qc->ap->port_no];\n\tint rc;\n\n\t \n\trc = ata_std_qc_defer(qc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\tif (alt && alt->qc_active)\n\t\treturn\tATA_DEFER_PORT;\n\treturn 0;\n}\n\nstatic const struct scsi_host_template sc1200_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t= LIBATA_DUMB_MAX_PRD,\n\t.dma_boundary\t= ATA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations sc1200_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.qc_prep \t= ata_bmdma_dumb_qc_prep,\n\t.qc_issue\t= sc1200_qc_issue,\n\t.qc_defer\t= sc1200_qc_defer,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= sc1200_set_piomode,\n\t.set_dmamode\t= sc1200_set_dmamode,\n};\n\n \n\nstatic int sc1200_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA2,\n\t\t.port_ops = &sc1200_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\n\treturn ata_pci_bmdma_init_one(dev, ppi, &sc1200_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id sc1200[] = {\n\t{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_SCx200_IDE), },\n\n\t{ },\n};\n\nstatic struct pci_driver sc1200_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= sc1200,\n\t.probe \t\t= sc1200_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(sc1200_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox, Mark Lord\");\nMODULE_DESCRIPTION(\"low-level driver for the NS/AMD SC1200\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sc1200);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}