{
  "module_name": "ata_generic.c",
  "hash_id": "736b77f9d8f055de7460c4e8cbbe448cdbd0c4f86902aef5e079dc11a308fe80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ata_generic.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"ata_generic\"\n#define DRV_VERSION \"0.2.15\"\n\n \n\nenum {\n\tATA_GEN_CLASS_MATCH\t\t= (1 << 0),\n\tATA_GEN_FORCE_DMA\t\t= (1 << 1),\n\tATA_GEN_INTEL_IDER\t\t= (1 << 2),\n};\n\n \n\nstatic int generic_set_mode(struct ata_link *link, struct ata_device **unused)\n{\n\tstruct ata_port *ap = link->ap;\n\tconst struct pci_device_id *id = ap->host->private_data;\n\tint dma_enabled = 0;\n\tstruct ata_device *dev;\n\n\tif (id->driver_data & ATA_GEN_FORCE_DMA) {\n\t\tdma_enabled = 0xff;\n\t} else if (ap->ioaddr.bmdma_addr) {\n\t\t \n\t\tdma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);\n\t}\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\t \n\t\tdev->pio_mode = XFER_PIO_0;\n\t\tdev->dma_mode = XFER_MW_DMA_0;\n\t\t \n\t\tif (dma_enabled & (1 << (5 + dev->devno))) {\n\t\t\tunsigned int xfer_mask = ata_id_xfermask(dev->id);\n\t\t\tconst char *name;\n\n\t\t\tif (xfer_mask & (ATA_MASK_MWDMA | ATA_MASK_UDMA))\n\t\t\t\tname = ata_mode_string(xfer_mask);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tname = \"DMA\";\n\t\t\t\txfer_mask |= ata_xfer_mode2mask(XFER_MW_DMA_0);\n\t\t\t}\n\n\t\t\tata_dev_info(dev, \"configured for %s\\n\", name);\n\n\t\t\tdev->xfer_mode = ata_xfer_mask2mode(xfer_mask);\n\t\t\tdev->xfer_shift = ata_xfer_mode2shift(dev->xfer_mode);\n\t\t\tdev->flags &= ~ATA_DFLAG_PIO;\n\t\t} else {\n\t\t\tata_dev_info(dev, \"configured for PIO\\n\");\n\t\t\tdev->xfer_mode = XFER_PIO_0;\n\t\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\t\tdev->flags |= ATA_DFLAG_PIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct scsi_host_template generic_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations generic_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.cable_detect\t= ata_cable_unknown,\n\t.set_mode\t= generic_set_mode,\n};\n\nstatic int all_generic_ide;\t\t \n\n \n\nstatic int is_intel_ider(struct pci_dev *dev)\n{\n\t \n\tu32 r;\n\tu16 t;\n\n\t \n\tpci_read_config_dword(dev, 0xF8, &r);\n\t \n\tif (r != 0)\n\t\treturn 0;\n\t \n\tpci_read_config_word(dev, 0x40, &t);\n\tif (t != 0)\n\t\treturn 0;\n\t \n\tpci_write_config_word(dev, 0x40, 1);\n\tpci_read_config_word(dev, 0x40, &t);\n\tif (t) {\n\t\tpci_write_config_word(dev, 0x40, 0);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \n\nstatic int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tu16 command;\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &generic_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\n\t \n\tif ((id->driver_data & ATA_GEN_CLASS_MATCH) && all_generic_ide == 0)\n\t\treturn -ENODEV;\n\n\tif ((id->driver_data & ATA_GEN_INTEL_IDER) && !all_generic_ide)\n\t\tif (!is_intel_ider(dev))\n\t\t\treturn -ENODEV;\n\n\t \n\tif (dev->vendor == PCI_VENDOR_ID_UMC &&\n\t    dev->device == PCI_DEVICE_ID_UMC_UM8886A &&\n\t    (!(PCI_FUNC(dev->devfn) & 1)))\n\t\treturn -ENODEV;\n\n\tif (dev->vendor == PCI_VENDOR_ID_OPTI &&\n\t    dev->device == PCI_DEVICE_ID_OPTI_82C558 &&\n\t    (!(PCI_FUNC(dev->devfn) & 1)))\n\t\treturn -ENODEV;\n\n\t \n\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\tif (!(command & PCI_COMMAND_IO))\n\t\treturn -ENODEV;\n\n\tif (dev->vendor == PCI_VENDOR_ID_AL)\n\t\tata_pci_bmdma_clear_simplex(dev);\n\n\tif (dev->vendor == PCI_VENDOR_ID_ATI) {\n\t\tint rc = pcim_enable_device(dev);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tpcim_pin_device(dev);\n\t}\n\treturn ata_pci_bmdma_init_one(dev, ppi, &generic_sht, (void *)id, 0);\n}\n\nstatic struct pci_device_id ata_generic[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PCTECH, PCI_DEVICE_ID_PCTECH_SAMURAI_IDE), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HOLTEK, PCI_DEVICE_ID_HOLTEK_6565), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8673F), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8886A), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8886BF), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HINT,   PCI_DEVICE_ID_HINT_VXPROII_IDE), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE),\n\t  .driver_data = ATA_GEN_FORCE_DMA },\n#if !defined(CONFIG_PATA_TOSHIBA) && !defined(CONFIG_PATA_TOSHIBA_MODULE)\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_3),  },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_5),  },\n#endif\n\t \n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL,\n\t  .driver_data = ATA_GEN_INTEL_IDER },\n\t \n\t{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL),\n\t  .driver_data = ATA_GEN_CLASS_MATCH },\n\t{ 0, },\n};\n\nstatic struct pci_driver ata_generic_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= ata_generic,\n\t.probe \t\t= ata_generic_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(ata_generic_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for generic ATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, ata_generic);\nMODULE_VERSION(DRV_VERSION);\n\nmodule_param(all_generic_ide, int, 0);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}