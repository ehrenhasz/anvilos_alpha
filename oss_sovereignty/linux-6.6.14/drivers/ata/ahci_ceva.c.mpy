{
  "module_name": "ahci_ceva.c",
  "hash_id": "9c84c7f13f788fb1a7a243999c014c4c1211956aacd26a2e047ab45395e6f641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_ceva.c",
  "human_readable_source": "\n \n\n#include <linux/ahci_platform.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include \"ahci.h\"\n\n \n#define AHCI_VEND_PCFG  0xA4\n#define AHCI_VEND_PPCFG 0xA8\n#define AHCI_VEND_PP2C  0xAC\n#define AHCI_VEND_PP3C  0xB0\n#define AHCI_VEND_PP4C  0xB4\n#define AHCI_VEND_PP5C  0xB8\n#define AHCI_VEND_AXICC 0xBC\n#define AHCI_VEND_PAXIC 0xC0\n#define AHCI_VEND_PTC   0xC8\n\n \n#define PAXIC_ADBW_BW64 0x1\n#define PAXIC_MAWID(i)\t(((i) * 2) << 4)\n#define PAXIC_MARID(i)\t(((i) * 2) << 12)\n#define PAXIC_MARIDD(i)\t((((i) * 2) + 1) << 16)\n#define PAXIC_MAWIDD(i)\t((((i) * 2) + 1) << 8)\n#define PAXIC_OTL\t(0x4 << 20)\n\n \n#define AXICC_ARCA_VAL  (0xF << 0)\n#define AXICC_ARCF_VAL  (0xF << 4)\n#define AXICC_ARCH_VAL  (0xF << 8)\n#define AXICC_ARCP_VAL  (0xF << 12)\n#define AXICC_AWCFD_VAL (0xF << 16)\n#define AXICC_AWCD_VAL  (0xF << 20)\n#define AXICC_AWCF_VAL  (0xF << 24)\n\n#define PCFG_TPSS_VAL\t(0x32 << 16)\n#define PCFG_TPRS_VAL\t(0x2 << 12)\n#define PCFG_PAD_VAL\t0x2\n\n#define PPCFG_TTA\t0x1FFFE\n#define PPCFG_PSSO_EN\t(1 << 28)\n#define PPCFG_PSS_EN\t(1 << 29)\n#define PPCFG_ESDF_EN\t(1 << 31)\n\n#define PP5C_RIT\t0x60216\n#define PP5C_RCT\t(0x7f0 << 20)\n\n#define PTC_RX_WM_VAL\t0x40\n#define PTC_RSVD\t(1 << 27)\n\n#define PORT0_BASE\t0x100\n#define PORT1_BASE\t0x180\n\n \n#define PORT_SCTL_SPD_GEN3\t(0x3 << 4)\n#define PORT_SCTL_SPD_GEN2\t(0x2 << 4)\n#define PORT_SCTL_SPD_GEN1\t(0x1 << 4)\n#define PORT_SCTL_IPM\t\t(0x3 << 8)\n\n#define PORT_BASE\t0x100\n#define PORT_OFFSET\t0x80\n#define NR_PORTS\t2\n#define DRV_NAME\t\"ahci-ceva\"\n#define CEVA_FLAG_BROKEN_GEN2\t1\n\nstatic unsigned int rx_watermark = PTC_RX_WM_VAL;\nmodule_param(rx_watermark, uint, 0644);\nMODULE_PARM_DESC(rx_watermark, \"RxWaterMark value (0 - 0x80)\");\n\nstruct ceva_ahci_priv {\n\tstruct platform_device *ahci_pdev;\n\t \n\tu32 pp2c[NR_PORTS];\n\tu32 pp3c[NR_PORTS];\n\tu32 pp4c[NR_PORTS];\n\tu32 pp5c[NR_PORTS];\n\t \n\tu32 axicc;\n\tbool is_cci_enabled;\n\tint flags;\n\tstruct reset_control *rst;\n};\n\nstatic unsigned int ceva_ahci_read_id(struct ata_device *dev,\n\t\t\t\t      struct ata_taskfile *tf, __le16 *id)\n{\n\tu32 err_mask;\n\n\terr_mask = ata_do_dev_read_id(dev, tf, id);\n\tif (err_mask)\n\t\treturn err_mask;\n\t \n\tid[ATA_ID_FEATURE_SUPP] &= cpu_to_le16(~(1 << 8));\n\n\treturn 0;\n}\n\nstatic struct ata_port_operations ahci_ceva_ops = {\n\t.inherits = &ahci_platform_ops,\n\t.read_id = ceva_ahci_read_id,\n};\n\nstatic const struct ata_port_info ahci_ceva_port_info = {\n\t.flags          = AHCI_FLAG_COMMON,\n\t.pio_mask       = ATA_PIO4,\n\t.udma_mask      = ATA_UDMA6,\n\t.port_ops\t= &ahci_ceva_ops,\n};\n\nstatic void ahci_ceva_setup(struct ahci_host_priv *hpriv)\n{\n\tvoid __iomem *mmio = hpriv->mmio;\n\tstruct ceva_ahci_priv *cevapriv = hpriv->plat_data;\n\tu32 tmp;\n\tint i;\n\n\t \n\ttmp = readl(mmio + HOST_CTL);\n\ttmp |= HOST_AHCI_EN;\n\twritel(tmp, mmio + HOST_CTL);\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\t \n\t\ttmp = PCFG_TPSS_VAL | PCFG_TPRS_VAL | (PCFG_PAD_VAL + i);\n\t\twritel(tmp, mmio + AHCI_VEND_PCFG);\n\n\t\t \n\t\ttmp = PAXIC_ADBW_BW64 | PAXIC_MAWIDD(i) | PAXIC_MARIDD(i) |\n\t\t\tPAXIC_MAWID(i) | PAXIC_MARID(i) | PAXIC_OTL;\n\t\twritel(tmp, mmio + AHCI_VEND_PAXIC);\n\n\t\t \n\t\tif (cevapriv->is_cci_enabled) {\n\t\t\ttmp = readl(mmio + AHCI_VEND_AXICC);\n\t\t\ttmp |= AXICC_ARCA_VAL | AXICC_ARCF_VAL |\n\t\t\t\tAXICC_ARCH_VAL | AXICC_ARCP_VAL |\n\t\t\t\tAXICC_AWCFD_VAL | AXICC_AWCD_VAL |\n\t\t\t\tAXICC_AWCF_VAL;\n\t\t\twritel(tmp, mmio + AHCI_VEND_AXICC);\n\t\t}\n\n\t\t \n\t\ttmp = PPCFG_TTA | PPCFG_PSS_EN | PPCFG_ESDF_EN;\n\t\twritel(tmp, mmio + AHCI_VEND_PPCFG);\n\n\t\t \n\t\twritel(cevapriv->pp2c[i], mmio + AHCI_VEND_PP2C);\n\n\t\t \n\t\twritel(cevapriv->pp3c[i], mmio + AHCI_VEND_PP3C);\n\n\t\t \n\t\twritel(cevapriv->pp4c[i], mmio + AHCI_VEND_PP4C);\n\n\t\t \n\t\twritel(cevapriv->pp5c[i], mmio + AHCI_VEND_PP5C);\n\n\t\t \n\t\ttmp = rx_watermark | PTC_RSVD;\n\t\twritel(tmp, mmio + AHCI_VEND_PTC);\n\n\t\t \n\t\ttmp = PORT_SCTL_SPD_GEN3 | PORT_SCTL_IPM;\n\t\tif (cevapriv->flags & CEVA_FLAG_BROKEN_GEN2)\n\t\t\ttmp = PORT_SCTL_SPD_GEN1 | PORT_SCTL_IPM;\n\t\twritel(tmp, mmio + PORT_SCR_CTL + PORT_BASE + PORT_OFFSET * i);\n\t}\n}\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int ceva_ahci_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct ceva_ahci_priv *cevapriv;\n\tenum dev_dma_attr attr;\n\tint rc;\n\n\tcevapriv = devm_kzalloc(dev, sizeof(*cevapriv), GFP_KERNEL);\n\tif (!cevapriv)\n\t\treturn -ENOMEM;\n\n\tcevapriv->ahci_pdev = pdev;\n\n\tcevapriv->rst = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t  NULL);\n\tif (IS_ERR(cevapriv->rst))\n\t\tdev_err_probe(&pdev->dev, PTR_ERR(cevapriv->rst),\n\t\t\t      \"failed to get reset\\n\");\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\tif (!cevapriv->rst) {\n\t\trc = ahci_platform_enable_resources(hpriv);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tint i;\n\n\t\trc = ahci_platform_enable_clks(hpriv);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t \n\t\treset_control_assert(cevapriv->rst);\n\n\t\tfor (i = 0; i < hpriv->nports; i++) {\n\t\t\trc = phy_init(hpriv->phys[i]);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\treset_control_deassert(cevapriv->rst);\n\n\t\tfor (i = 0; i < hpriv->nports; i++) {\n\t\t\trc = phy_power_on(hpriv->phys[i]);\n\t\t\tif (rc) {\n\t\t\t\tphy_exit(hpriv->phys[i]);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (of_property_read_bool(np, \"ceva,broken-gen2\"))\n\t\tcevapriv->flags = CEVA_FLAG_BROKEN_GEN2;\n\n\t \n\tif (of_property_read_u8_array(np, \"ceva,p0-cominit-params\",\n\t\t\t\t\t(u8 *)&cevapriv->pp2c[0], 4) < 0) {\n\t\tdev_warn(dev, \"ceva,p0-cominit-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u8_array(np, \"ceva,p1-cominit-params\",\n\t\t\t\t\t(u8 *)&cevapriv->pp2c[1], 4) < 0) {\n\t\tdev_warn(dev, \"ceva,p1-cominit-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (of_property_read_u8_array(np, \"ceva,p0-comwake-params\",\n\t\t\t\t\t(u8 *)&cevapriv->pp3c[0], 4) < 0) {\n\t\tdev_warn(dev, \"ceva,p0-comwake-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u8_array(np, \"ceva,p1-comwake-params\",\n\t\t\t\t\t(u8 *)&cevapriv->pp3c[1], 4) < 0) {\n\t\tdev_warn(dev, \"ceva,p1-comwake-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (of_property_read_u8_array(np, \"ceva,p0-burst-params\",\n\t\t\t\t\t(u8 *)&cevapriv->pp4c[0], 4) < 0) {\n\t\tdev_warn(dev, \"ceva,p0-burst-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u8_array(np, \"ceva,p1-burst-params\",\n\t\t\t\t\t(u8 *)&cevapriv->pp4c[1], 4) < 0) {\n\t\tdev_warn(dev, \"ceva,p1-burst-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (of_property_read_u16_array(np, \"ceva,p0-retry-params\",\n\t\t\t\t\t(u16 *)&cevapriv->pp5c[0], 2) < 0) {\n\t\tdev_warn(dev, \"ceva,p0-retry-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u16_array(np, \"ceva,p1-retry-params\",\n\t\t\t\t\t(u16 *)&cevapriv->pp5c[1], 2) < 0) {\n\t\tdev_warn(dev, \"ceva,p1-retry-params property not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tattr = device_get_dma_attr(dev);\n\tcevapriv->is_cci_enabled = (attr == DEV_DMA_COHERENT);\n\n\thpriv->plat_data = cevapriv;\n\n\t \n\tahci_ceva_setup(hpriv);\n\n\trc = ahci_platform_init_host(pdev, hpriv, &ahci_ceva_port_info,\n\t\t\t\t\t&ahci_platform_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n\nstatic int __maybe_unused ceva_ahci_suspend(struct device *dev)\n{\n\treturn ahci_platform_suspend(dev);\n}\n\nstatic int __maybe_unused ceva_ahci_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tahci_ceva_setup(hpriv);\n\n\trc = ahci_platform_resume_host(dev);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\t \n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\n\treturn rc;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahci_ceva_pm_ops, ceva_ahci_suspend, ceva_ahci_resume);\n\nstatic const struct of_device_id ceva_ahci_of_match[] = {\n\t{ .compatible = \"ceva,ahci-1v84\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ceva_ahci_of_match);\n\nstatic struct platform_driver ceva_ahci_driver = {\n\t.probe = ceva_ahci_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ceva_ahci_of_match,\n\t\t.pm = &ahci_ceva_pm_ops,\n\t},\n};\nmodule_platform_driver(ceva_ahci_driver);\n\nMODULE_DESCRIPTION(\"CEVA AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}