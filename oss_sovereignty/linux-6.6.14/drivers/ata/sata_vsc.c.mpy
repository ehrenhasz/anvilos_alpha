{
  "module_name": "sata_vsc.c",
  "hash_id": "a24544d465cd6f171663ef8f3b9b72f485200e59b040dd1fb831d487d48a4c77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_vsc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"sata_vsc\"\n#define DRV_VERSION\t\"2.3\"\n\nenum {\n\tVSC_MMIO_BAR\t\t\t= 0,\n\n\t \n\tVSC_SATA_INT_STAT_OFFSET\t= 0x00,\n\tVSC_SATA_INT_MASK_OFFSET\t= 0x04,\n\n\t \n\tVSC_SATA_TF_CMD_OFFSET\t\t= 0x00,\n\tVSC_SATA_TF_DATA_OFFSET\t\t= 0x00,\n\tVSC_SATA_TF_ERROR_OFFSET\t= 0x04,\n\tVSC_SATA_TF_FEATURE_OFFSET\t= 0x06,\n\tVSC_SATA_TF_NSECT_OFFSET\t= 0x08,\n\tVSC_SATA_TF_LBAL_OFFSET\t\t= 0x0c,\n\tVSC_SATA_TF_LBAM_OFFSET\t\t= 0x10,\n\tVSC_SATA_TF_LBAH_OFFSET\t\t= 0x14,\n\tVSC_SATA_TF_DEVICE_OFFSET\t= 0x18,\n\tVSC_SATA_TF_STATUS_OFFSET\t= 0x1c,\n\tVSC_SATA_TF_COMMAND_OFFSET\t= 0x1d,\n\tVSC_SATA_TF_ALTSTATUS_OFFSET\t= 0x28,\n\tVSC_SATA_TF_CTL_OFFSET\t\t= 0x29,\n\n\t \n\tVSC_SATA_UP_DESCRIPTOR_OFFSET\t= 0x64,\n\tVSC_SATA_UP_DATA_BUFFER_OFFSET\t= 0x6C,\n\tVSC_SATA_DMA_CMD_OFFSET\t\t= 0x70,\n\n\t \n\tVSC_SATA_SCR_STATUS_OFFSET\t= 0x100,\n\tVSC_SATA_SCR_ERROR_OFFSET\t= 0x104,\n\tVSC_SATA_SCR_CONTROL_OFFSET\t= 0x108,\n\n\t \n\tVSC_SATA_PORT_OFFSET\t\t= 0x200,\n\n\t \n\tVSC_SATA_INT_ERROR_CRC\t\t= 0x40,\n\tVSC_SATA_INT_ERROR_T\t\t= 0x20,\n\tVSC_SATA_INT_ERROR_P\t\t= 0x10,\n\tVSC_SATA_INT_ERROR_R\t\t= 0x8,\n\tVSC_SATA_INT_ERROR_E\t\t= 0x4,\n\tVSC_SATA_INT_ERROR_M\t\t= 0x2,\n\tVSC_SATA_INT_PHY_CHANGE\t\t= 0x1,\n\tVSC_SATA_INT_ERROR = (VSC_SATA_INT_ERROR_CRC  | VSC_SATA_INT_ERROR_T | \\\n\t\t\t      VSC_SATA_INT_ERROR_P    | VSC_SATA_INT_ERROR_R | \\\n\t\t\t      VSC_SATA_INT_ERROR_E    | VSC_SATA_INT_ERROR_M | \\\n\t\t\t      VSC_SATA_INT_PHY_CHANGE),\n};\n\nstatic int vsc_sata_scr_read(struct ata_link *link,\n\t\t\t     unsigned int sc_reg, u32 *val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\t*val = readl(link->ap->ioaddr.scr_addr + (sc_reg * 4));\n\treturn 0;\n}\n\n\nstatic int vsc_sata_scr_write(struct ata_link *link,\n\t\t\t      unsigned int sc_reg, u32 val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\twritel(val, link->ap->ioaddr.scr_addr + (sc_reg * 4));\n\treturn 0;\n}\n\n\nstatic void vsc_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *mask_addr;\n\n\tmask_addr = ap->host->iomap[VSC_MMIO_BAR] +\n\t\tVSC_SATA_INT_MASK_OFFSET + ap->port_no;\n\n\twriteb(0, mask_addr);\n}\n\n\nstatic void vsc_thaw(struct ata_port *ap)\n{\n\tvoid __iomem *mask_addr;\n\n\tmask_addr = ap->host->iomap[VSC_MMIO_BAR] +\n\t\tVSC_SATA_INT_MASK_OFFSET + ap->port_no;\n\n\twriteb(0xff, mask_addr);\n}\n\n\nstatic void vsc_intr_mask_update(struct ata_port *ap, u8 ctl)\n{\n\tvoid __iomem *mask_addr;\n\tu8 mask;\n\n\tmask_addr = ap->host->iomap[VSC_MMIO_BAR] +\n\t\tVSC_SATA_INT_MASK_OFFSET + ap->port_no;\n\tmask = readb(mask_addr);\n\tif (ctl & ATA_NIEN)\n\t\tmask |= 0x80;\n\telse\n\t\tmask &= 0x7F;\n\twriteb(mask, mask_addr);\n}\n\n\nstatic void vsc_sata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\n\n\t \n\tif ((tf->ctl & ATA_NIEN) != (ap->last_ctl & ATA_NIEN)) {\n\t\tap->last_ctl = tf->ctl;\n\t\tvsc_intr_mask_update(ap, tf->ctl & ATA_NIEN);\n\t}\n\tif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\n\t\twritew(tf->feature | (((u16)tf->hob_feature) << 8),\n\t\t       ioaddr->feature_addr);\n\t\twritew(tf->nsect | (((u16)tf->hob_nsect) << 8),\n\t\t       ioaddr->nsect_addr);\n\t\twritew(tf->lbal | (((u16)tf->hob_lbal) << 8),\n\t\t       ioaddr->lbal_addr);\n\t\twritew(tf->lbam | (((u16)tf->hob_lbam) << 8),\n\t\t       ioaddr->lbam_addr);\n\t\twritew(tf->lbah | (((u16)tf->hob_lbah) << 8),\n\t\t       ioaddr->lbah_addr);\n\t} else if (is_addr) {\n\t\twritew(tf->feature, ioaddr->feature_addr);\n\t\twritew(tf->nsect, ioaddr->nsect_addr);\n\t\twritew(tf->lbal, ioaddr->lbal_addr);\n\t\twritew(tf->lbam, ioaddr->lbam_addr);\n\t\twritew(tf->lbah, ioaddr->lbah_addr);\n\t}\n\n\tif (tf->flags & ATA_TFLAG_DEVICE)\n\t\twriteb(tf->device, ioaddr->device_addr);\n\n\tata_wait_idle(ap);\n}\n\n\nstatic void vsc_sata_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tu16 nsect, lbal, lbam, lbah, error;\n\n\ttf->status = ata_sff_check_status(ap);\n\ttf->device = readw(ioaddr->device_addr);\n\terror = readw(ioaddr->error_addr);\n\tnsect = readw(ioaddr->nsect_addr);\n\tlbal = readw(ioaddr->lbal_addr);\n\tlbam = readw(ioaddr->lbam_addr);\n\tlbah = readw(ioaddr->lbah_addr);\n\n\ttf->error = error;\n\ttf->nsect = nsect;\n\ttf->lbal = lbal;\n\ttf->lbam = lbam;\n\ttf->lbah = lbah;\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\ttf->hob_feature = error >> 8;\n\t\ttf->hob_nsect = nsect >> 8;\n\t\ttf->hob_lbal = lbal >> 8;\n\t\ttf->hob_lbam = lbam >> 8;\n\t\ttf->hob_lbah = lbah >> 8;\n\t}\n}\n\nstatic inline void vsc_error_intr(u8 port_status, struct ata_port *ap)\n{\n\tif (port_status & (VSC_SATA_INT_PHY_CHANGE | VSC_SATA_INT_ERROR_M))\n\t\tata_port_freeze(ap);\n\telse\n\t\tata_port_abort(ap);\n}\n\nstatic void vsc_port_intr(u8 port_status, struct ata_port *ap)\n{\n\tstruct ata_queued_cmd *qc;\n\tint handled = 0;\n\n\tif (unlikely(port_status & VSC_SATA_INT_ERROR)) {\n\t\tvsc_error_intr(port_status, ap);\n\t\treturn;\n\t}\n\n\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\tif (qc && likely(!(qc->tf.flags & ATA_TFLAG_POLLING)))\n\t\thandled = ata_bmdma_port_intr(ap, qc);\n\n\t \n\tif (unlikely(!handled))\n\t\tap->ops->sff_check_status(ap);\n}\n\n \nstatic irqreturn_t vsc_sata_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tunsigned int i;\n\tunsigned int handled = 0;\n\tu32 status;\n\n\tstatus = readl(host->iomap[VSC_MMIO_BAR] + VSC_SATA_INT_STAT_OFFSET);\n\n\tif (unlikely(status == 0xffffffff || status == 0)) {\n\t\tif (status)\n\t\t\tdev_err(host->dev,\n\t\t\t\t\": IRQ status == 0xffffffff, PCI fault or device removal?\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock(&host->lock);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tu8 port_status = (status >> (8 * i)) & 0xff;\n\t\tif (port_status) {\n\t\t\tvsc_port_intr(port_status, host->ports[i]);\n\t\t\thandled++;\n\t\t}\n\t}\n\n\tspin_unlock(&host->lock);\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n\nstatic const struct scsi_host_template vsc_sata_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n\nstatic struct ata_port_operations vsc_sata_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t \n\t.lost_interrupt\t\t= ATA_OP_NULL,\n\t.sff_tf_load\t\t= vsc_sata_tf_load,\n\t.sff_tf_read\t\t= vsc_sata_tf_read,\n\t.freeze\t\t\t= vsc_freeze,\n\t.thaw\t\t\t= vsc_thaw,\n\t.scr_read\t\t= vsc_sata_scr_read,\n\t.scr_write\t\t= vsc_sata_scr_write,\n};\n\nstatic void vsc_sata_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t= base + VSC_SATA_TF_CMD_OFFSET;\n\tport->data_addr\t\t= base + VSC_SATA_TF_DATA_OFFSET;\n\tport->error_addr\t= base + VSC_SATA_TF_ERROR_OFFSET;\n\tport->feature_addr\t= base + VSC_SATA_TF_FEATURE_OFFSET;\n\tport->nsect_addr\t= base + VSC_SATA_TF_NSECT_OFFSET;\n\tport->lbal_addr\t\t= base + VSC_SATA_TF_LBAL_OFFSET;\n\tport->lbam_addr\t\t= base + VSC_SATA_TF_LBAM_OFFSET;\n\tport->lbah_addr\t\t= base + VSC_SATA_TF_LBAH_OFFSET;\n\tport->device_addr\t= base + VSC_SATA_TF_DEVICE_OFFSET;\n\tport->status_addr\t= base + VSC_SATA_TF_STATUS_OFFSET;\n\tport->command_addr\t= base + VSC_SATA_TF_COMMAND_OFFSET;\n\tport->altstatus_addr\t= base + VSC_SATA_TF_ALTSTATUS_OFFSET;\n\tport->ctl_addr\t\t= base + VSC_SATA_TF_CTL_OFFSET;\n\tport->bmdma_addr\t= base + VSC_SATA_DMA_CMD_OFFSET;\n\tport->scr_addr\t\t= base + VSC_SATA_SCR_STATUS_OFFSET;\n\twritel(0, base + VSC_SATA_UP_DESCRIPTOR_OFFSET);\n\twritel(0, base + VSC_SATA_UP_DATA_BUFFER_OFFSET);\n}\n\n\nstatic int vsc_sata_init_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstatic const struct ata_port_info pi = {\n\t\t.flags\t\t= ATA_FLAG_SATA,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &vsc_sata_ops,\n\t};\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct ata_host *host;\n\tvoid __iomem *mmio_base;\n\tint i, rc;\n\tu8 cls;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, 4);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (pci_resource_len(pdev, 0) == 0)\n\t\treturn -ENODEV;\n\n\t \n\trc = pcim_iomap_regions(pdev, 1 << VSC_MMIO_BAR, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\tmmio_base = host->iomap[VSC_MMIO_BAR];\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tunsigned int offset = (i + 1) * VSC_SATA_PORT_OFFSET;\n\n\t\tvsc_sata_setup_port(&ap->ioaddr, mmio_base + offset);\n\n\t\tata_port_pbar_desc(ap, VSC_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, VSC_MMIO_BAR, offset, \"port\");\n\t}\n\n\t \n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &cls);\n\tif (cls == 0x00)\n\t\tpci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, 0x80);\n\n\tif (pci_enable_msi(pdev) == 0)\n\t\tpci_intx(pdev, 0);\n\n\t \n\tpci_write_config_dword(pdev, 0x98, 0);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, vsc_sata_interrupt,\n\t\t\t\t IRQF_SHARED, &vsc_sata_sht);\n}\n\nstatic const struct pci_device_id vsc_sata_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_VITESSE, 0x7174,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0x10600, 0xFFFFFF, 0 },\n\t{ PCI_VENDOR_ID_INTEL, 0x3200,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0x10600, 0xFFFFFF, 0 },\n\n\t{ }\t \n};\n\nstatic struct pci_driver vsc_sata_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= vsc_sata_pci_tbl,\n\t.probe\t\t\t= vsc_sata_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\nmodule_pci_driver(vsc_sata_pci_driver);\n\nMODULE_AUTHOR(\"Jeremy Higdon\");\nMODULE_DESCRIPTION(\"low-level driver for Vitesse VSC7174 SATA controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, vsc_sata_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}