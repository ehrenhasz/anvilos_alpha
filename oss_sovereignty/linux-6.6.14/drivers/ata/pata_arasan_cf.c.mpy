{
  "module_name": "pata_arasan_cf.c",
  "hash_id": "372de4d5dc0b6624b94c1acf2e6e056dba042a34e849f0d1861cb4f489b69dfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_arasan_cf.c",
  "human_readable_source": " \n\n \n\n#include <linux/ata.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pata_arasan_cf_data.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <trace/events/libata.h>\n\n#define DRIVER_NAME\t\"arasan_cf\"\n#define TIMEOUT\t\tmsecs_to_jiffies(3000)\n\n \n \n#define CFI_STS\t\t\t0x000\n\t#define STS_CHG\t\t\t\t(1)\n\t#define BIN_AUDIO_OUT\t\t\t(1 << 1)\n\t#define CARD_DETECT1\t\t\t(1 << 2)\n\t#define CARD_DETECT2\t\t\t(1 << 3)\n\t#define INP_ACK\t\t\t\t(1 << 4)\n\t#define CARD_READY\t\t\t(1 << 5)\n\t#define IO_READY\t\t\t(1 << 6)\n\t#define B16_IO_PORT_SEL\t\t\t(1 << 7)\n \n#define IRQ_STS\t\t\t0x004\n \n#define IRQ_EN\t\t\t0x008\n\t#define CARD_DETECT_IRQ\t\t\t(1)\n\t#define STATUS_CHNG_IRQ\t\t\t(1 << 1)\n\t#define MEM_MODE_IRQ\t\t\t(1 << 2)\n\t#define IO_MODE_IRQ\t\t\t(1 << 3)\n\t#define TRUE_IDE_MODE_IRQ\t\t(1 << 8)\n\t#define PIO_XFER_ERR_IRQ\t\t(1 << 9)\n\t#define BUF_AVAIL_IRQ\t\t\t(1 << 10)\n\t#define XFER_DONE_IRQ\t\t\t(1 << 11)\n\t#define IGNORED_IRQS\t(STATUS_CHNG_IRQ | MEM_MODE_IRQ | IO_MODE_IRQ |\\\n\t\t\t\t\tTRUE_IDE_MODE_IRQ)\n\t#define TRUE_IDE_IRQS\t(CARD_DETECT_IRQ | PIO_XFER_ERR_IRQ |\\\n\t\t\t\t\tBUF_AVAIL_IRQ | XFER_DONE_IRQ)\n \n#define OP_MODE\t\t\t0x00C\n\t#define CARD_MODE_MASK\t\t\t(0x3)\n\t#define MEM_MODE\t\t\t(0x0)\n\t#define IO_MODE\t\t\t\t(0x1)\n\t#define TRUE_IDE_MODE\t\t\t(0x2)\n\n\t#define CARD_TYPE_MASK\t\t\t(1 << 2)\n\t#define CF_CARD\t\t\t\t(0)\n\t#define CF_PLUS_CARD\t\t\t(1 << 2)\n\n\t#define CARD_RESET\t\t\t(1 << 3)\n\t#define CFHOST_ENB\t\t\t(1 << 4)\n\t#define OUTPUTS_TRISTATE\t\t(1 << 5)\n\t#define ULTRA_DMA_ENB\t\t\t(1 << 8)\n\t#define MULTI_WORD_DMA_ENB\t\t(1 << 9)\n\t#define DRQ_BLOCK_SIZE_MASK\t\t(0x3 << 11)\n\t#define DRQ_BLOCK_SIZE_512\t\t(0)\n\t#define DRQ_BLOCK_SIZE_1024\t\t(1 << 11)\n\t#define DRQ_BLOCK_SIZE_2048\t\t(2 << 11)\n\t#define DRQ_BLOCK_SIZE_4096\t\t(3 << 11)\n \n#define CLK_CFG\t\t\t0x010\n\t#define CF_IF_CLK_MASK\t\t\t(0XF)\n \n#define TM_CFG\t\t\t0x014\n\t#define MEM_MODE_TIMING_MASK\t\t(0x3)\n\t#define MEM_MODE_TIMING_250NS\t\t(0x0)\n\t#define MEM_MODE_TIMING_120NS\t\t(0x1)\n\t#define MEM_MODE_TIMING_100NS\t\t(0x2)\n\t#define MEM_MODE_TIMING_80NS\t\t(0x3)\n\n\t#define IO_MODE_TIMING_MASK\t\t(0x3 << 2)\n\t#define IO_MODE_TIMING_250NS\t\t(0x0 << 2)\n\t#define IO_MODE_TIMING_120NS\t\t(0x1 << 2)\n\t#define IO_MODE_TIMING_100NS\t\t(0x2 << 2)\n\t#define IO_MODE_TIMING_80NS\t\t(0x3 << 2)\n\n\t#define TRUEIDE_PIO_TIMING_MASK\t\t(0x7 << 4)\n\t#define TRUEIDE_PIO_TIMING_SHIFT\t4\n\n\t#define TRUEIDE_MWORD_DMA_TIMING_MASK\t(0x7 << 7)\n\t#define TRUEIDE_MWORD_DMA_TIMING_SHIFT\t7\n\n\t#define ULTRA_DMA_TIMING_MASK\t\t(0x7 << 10)\n\t#define ULTRA_DMA_TIMING_SHIFT\t\t10\n \n#define XFER_ADDR\t\t0x014\n\t#define XFER_ADDR_MASK\t\t\t(0x7FF)\n\t#define MAX_XFER_COUNT\t\t\t0x20000u\n \n#define XFER_CTR\t\t0x01C\n\t#define XFER_COUNT_MASK\t\t\t(0x3FFFF)\n\t#define ADDR_INC_DISABLE\t\t(1 << 24)\n\t#define XFER_WIDTH_MASK\t\t\t(1 << 25)\n\t#define XFER_WIDTH_8B\t\t\t(0)\n\t#define XFER_WIDTH_16B\t\t\t(1 << 25)\n\n\t#define MEM_TYPE_MASK\t\t\t(1 << 26)\n\t#define MEM_TYPE_COMMON\t\t\t(0)\n\t#define MEM_TYPE_ATTRIBUTE\t\t(1 << 26)\n\n\t#define MEM_IO_XFER_MASK\t\t(1 << 27)\n\t#define MEM_XFER\t\t\t(0)\n\t#define IO_XFER\t\t\t\t(1 << 27)\n\n\t#define DMA_XFER_MODE\t\t\t(1 << 28)\n\n\t#define AHB_BUS_NORMAL_PIO_OPRTN\t(~(1 << 29))\n\t#define XFER_DIR_MASK\t\t\t(1 << 30)\n\t#define XFER_READ\t\t\t(0)\n\t#define XFER_WRITE\t\t\t(1 << 30)\n\n\t#define XFER_START\t\t\t(1 << 31)\n \n#define WRITE_PORT\t\t0x024\n \n#define READ_PORT\t\t0x028\n \n#define ATA_DATA_PORT\t\t0x030\n\t#define ATA_DATA_PORT_MASK\t\t(0xFFFF)\n \n#define ATA_ERR_FTR\t\t0x034\n \n#define ATA_SC\t\t\t0x038\n \n#define ATA_SN\t\t\t0x03C\n \n#define ATA_CL\t\t\t0x040\n \n#define ATA_CH\t\t\t0x044\n \n#define ATA_SH\t\t\t0x048\n \n#define ATA_STS_CMD\t\t0x04C\n \n#define ATA_ASTS_DCTR\t\t0x050\n \n#define EXT_WRITE_PORT\t\t0x200\n \n#define EXT_READ_PORT\t\t0x400\n\t#define FIFO_SIZE\t0x200u\n \n#define GIRQ_STS\t\t0x800\n \n#define GIRQ_STS_EN\t\t0x804\n \n#define GIRQ_SGN_EN\t\t0x808\n\t#define GIRQ_CF\t\t(1)\n\t#define GIRQ_XD\t\t(1 << 1)\n\n \nstruct arasan_cf_dev {\n\t \n\tstruct ata_host *host;\n\t \n\tstruct clk *clk;\n\n\t \n\tdma_addr_t pbase;\n\t \n\tvoid __iomem *vbase;\n\t \n\tint irq;\n\n\t \n\tu8 dma_status;\n\t \n\tu8 card_present;\n\n\t \n\t \n\tstruct completion cf_completion;\n\t \n\tstruct completion dma_completion;\n\t \n\tstruct dma_chan *dma_chan;\n\t \n\tdma_cap_mask_t mask;\n\t \n\tstruct work_struct work;\n\t \n\tstruct delayed_work dwork;\n\t \n\tstruct ata_queued_cmd *qc;\n};\n\nstatic const struct scsi_host_template arasan_cf_sht = {\n\tATA_BASE_SHT(DRIVER_NAME),\n\t.dma_boundary = 0xFFFFFFFFUL,\n};\n\nstatic void cf_dumpregs(struct arasan_cf_dev *acdev)\n{\n\tstruct device *dev = acdev->host->dev;\n\n\tdev_dbg(dev, \": =========== REGISTER DUMP ===========\");\n\tdev_dbg(dev, \": CFI_STS: %x\", readl(acdev->vbase + CFI_STS));\n\tdev_dbg(dev, \": IRQ_STS: %x\", readl(acdev->vbase + IRQ_STS));\n\tdev_dbg(dev, \": IRQ_EN: %x\", readl(acdev->vbase + IRQ_EN));\n\tdev_dbg(dev, \": OP_MODE: %x\", readl(acdev->vbase + OP_MODE));\n\tdev_dbg(dev, \": CLK_CFG: %x\", readl(acdev->vbase + CLK_CFG));\n\tdev_dbg(dev, \": TM_CFG: %x\", readl(acdev->vbase + TM_CFG));\n\tdev_dbg(dev, \": XFER_CTR: %x\", readl(acdev->vbase + XFER_CTR));\n\tdev_dbg(dev, \": GIRQ_STS: %x\", readl(acdev->vbase + GIRQ_STS));\n\tdev_dbg(dev, \": GIRQ_STS_EN: %x\", readl(acdev->vbase + GIRQ_STS_EN));\n\tdev_dbg(dev, \": GIRQ_SGN_EN: %x\", readl(acdev->vbase + GIRQ_SGN_EN));\n\tdev_dbg(dev, \": =====================================\");\n}\n\n \nstatic void cf_ginterrupt_enable(struct arasan_cf_dev *acdev, bool enable)\n{\n\t \n\twritel(enable, acdev->vbase + GIRQ_STS_EN);\n\twritel(enable, acdev->vbase + GIRQ_SGN_EN);\n}\n\n \nstatic inline void\ncf_interrupt_enable(struct arasan_cf_dev *acdev, u32 mask, bool enable)\n{\n\tu32 val = readl(acdev->vbase + IRQ_EN);\n\t \n\tif (enable) {\n\t\twritel(mask, acdev->vbase + IRQ_STS);\n\t\twritel(val | mask, acdev->vbase + IRQ_EN);\n\t} else\n\t\twritel(val & ~mask, acdev->vbase + IRQ_EN);\n}\n\nstatic inline void cf_card_reset(struct arasan_cf_dev *acdev)\n{\n\tu32 val = readl(acdev->vbase + OP_MODE);\n\n\twritel(val | CARD_RESET, acdev->vbase + OP_MODE);\n\tudelay(200);\n\twritel(val & ~CARD_RESET, acdev->vbase + OP_MODE);\n}\n\nstatic inline void cf_ctrl_reset(struct arasan_cf_dev *acdev)\n{\n\twritel(readl(acdev->vbase + OP_MODE) & ~CFHOST_ENB,\n\t\t\tacdev->vbase + OP_MODE);\n\twritel(readl(acdev->vbase + OP_MODE) | CFHOST_ENB,\n\t\t\tacdev->vbase + OP_MODE);\n}\n\nstatic void cf_card_detect(struct arasan_cf_dev *acdev, bool hotplugged)\n{\n\tstruct ata_port *ap = acdev->host->ports[0];\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tu32 val = readl(acdev->vbase + CFI_STS);\n\n\t \n\tif (!(val & (CARD_DETECT1 | CARD_DETECT2))) {\n\t\tif (acdev->card_present)\n\t\t\treturn;\n\t\tacdev->card_present = 1;\n\t\tcf_card_reset(acdev);\n\t} else {\n\t\tif (!acdev->card_present)\n\t\t\treturn;\n\t\tacdev->card_present = 0;\n\t}\n\n\tif (hotplugged) {\n\t\tata_ehi_hotplugged(ehi);\n\t\tata_port_freeze(ap);\n\t}\n}\n\nstatic int cf_init(struct arasan_cf_dev *acdev)\n{\n\tstruct arasan_cf_pdata *pdata = dev_get_platdata(acdev->host->dev);\n\tunsigned int if_clk;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tret = clk_prepare_enable(acdev->clk);\n\tif (ret) {\n\t\tdev_dbg(acdev->host->dev, \"clock enable failed\");\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(acdev->clk, 166000000);\n\tif (ret) {\n\t\tdev_warn(acdev->host->dev, \"clock set rate failed\");\n\t\tclk_disable_unprepare(acdev->clk);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\t \n\t \n\tif_clk = CF_IF_CLK_166M;\n\tif (pdata && pdata->cf_if_clk <= CF_IF_CLK_200M)\n\t\tif_clk = pdata->cf_if_clk;\n\n\twritel(if_clk, acdev->vbase + CLK_CFG);\n\n\twritel(TRUE_IDE_MODE | CFHOST_ENB, acdev->vbase + OP_MODE);\n\tcf_interrupt_enable(acdev, CARD_DETECT_IRQ, 1);\n\tcf_ginterrupt_enable(acdev, 1);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\n\treturn ret;\n}\n\nstatic void cf_exit(struct arasan_cf_dev *acdev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\tcf_ginterrupt_enable(acdev, 0);\n\tcf_interrupt_enable(acdev, TRUE_IDE_IRQS, 0);\n\tcf_card_reset(acdev);\n\twritel(readl(acdev->vbase + OP_MODE) & ~CFHOST_ENB,\n\t\t\tacdev->vbase + OP_MODE);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\tclk_disable_unprepare(acdev->clk);\n}\n\nstatic void dma_callback(void *dev)\n{\n\tstruct arasan_cf_dev *acdev = dev;\n\n\tcomplete(&acdev->dma_completion);\n}\n\nstatic inline void dma_complete(struct arasan_cf_dev *acdev)\n{\n\tstruct ata_queued_cmd *qc = acdev->qc;\n\tunsigned long flags;\n\n\tacdev->qc = NULL;\n\tata_sff_interrupt(acdev->irq, acdev->host);\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\tif (unlikely(qc->err_mask) && ata_is_dma(qc->tf.protocol))\n\t\tata_ehi_push_desc(&qc->ap->link.eh_info, \"DMA Failed: Timeout\");\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n}\n\nstatic inline int wait4buf(struct arasan_cf_dev *acdev)\n{\n\tif (!wait_for_completion_timeout(&acdev->cf_completion, TIMEOUT)) {\n\t\tu32 rw = acdev->qc->tf.flags & ATA_TFLAG_WRITE;\n\n\t\tdev_err(acdev->host->dev, \"%s TimeOut\", rw ? \"write\" : \"read\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (acdev->dma_status & ATA_DMA_ERR)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int\ndma_xfer(struct arasan_cf_dev *acdev, dma_addr_t src, dma_addr_t dest, u32 len)\n{\n\tstruct dma_async_tx_descriptor *tx;\n\tstruct dma_chan *chan = acdev->dma_chan;\n\tdma_cookie_t cookie;\n\tunsigned long flags = DMA_PREP_INTERRUPT;\n\tint ret = 0;\n\n\ttx = chan->device->device_prep_dma_memcpy(chan, dest, src, len, flags);\n\tif (!tx) {\n\t\tdev_err(acdev->host->dev, \"device_prep_dma_memcpy failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\ttx->callback = dma_callback;\n\ttx->callback_param = acdev;\n\tcookie = tx->tx_submit(tx);\n\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(acdev->host->dev, \"dma_submit_error\\n\");\n\t\treturn ret;\n\t}\n\n\tchan->device->device_issue_pending(chan);\n\n\t \n\tif (!wait_for_completion_timeout(&acdev->dma_completion, TIMEOUT)) {\n\t\tdmaengine_terminate_all(chan);\n\t\tdev_err(acdev->host->dev, \"wait_for_completion_timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nstatic int sg_xfer(struct arasan_cf_dev *acdev, struct scatterlist *sg)\n{\n\tdma_addr_t dest = 0, src = 0;\n\tu32 xfer_cnt, sglen, dma_len, xfer_ctr;\n\tu32 write = acdev->qc->tf.flags & ATA_TFLAG_WRITE;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tsglen = sg_dma_len(sg);\n\tif (write) {\n\t\tsrc = sg_dma_address(sg);\n\t\tdest = acdev->pbase + EXT_WRITE_PORT;\n\t} else {\n\t\tdest = sg_dma_address(sg);\n\t\tsrc = acdev->pbase + EXT_READ_PORT;\n\t}\n\n\t \n\twhile (sglen) {\n\t\txfer_cnt = min(sglen, MAX_XFER_COUNT);\n\t\tspin_lock_irqsave(&acdev->host->lock, flags);\n\t\txfer_ctr = readl(acdev->vbase + XFER_CTR) &\n\t\t\t~XFER_COUNT_MASK;\n\t\twritel(xfer_ctr | xfer_cnt | XFER_START,\n\t\t\t\tacdev->vbase + XFER_CTR);\n\t\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\n\t\t \n\t\twhile (xfer_cnt) {\n\t\t\t \n\t\t\tif (!write) {\n\t\t\t\tret = wait4buf(acdev);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t \n\t\t\tdma_len = min(xfer_cnt, FIFO_SIZE);\n\t\t\tret = dma_xfer(acdev, src, dest, dma_len);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(acdev->host->dev, \"dma failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (write)\n\t\t\t\tsrc += dma_len;\n\t\t\telse\n\t\t\t\tdest += dma_len;\n\n\t\t\tsglen -= dma_len;\n\t\t\txfer_cnt -= dma_len;\n\n\t\t\t \n\t\t\tif (write) {\n\t\t\t\tret = wait4buf(acdev);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\nfail:\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\twritel(readl(acdev->vbase + XFER_CTR) & ~XFER_START,\n\t\t\tacdev->vbase + XFER_CTR);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic void data_xfer(struct work_struct *work)\n{\n\tstruct arasan_cf_dev *acdev = container_of(work, struct arasan_cf_dev,\n\t\t\twork);\n\tstruct ata_queued_cmd *qc = acdev->qc;\n\tstruct scatterlist *sg;\n\tunsigned long flags;\n\tu32 temp;\n\tint ret = 0;\n\n\t \n\t \n\tacdev->dma_chan = dma_request_chan(acdev->host->dev, \"data\");\n\tif (IS_ERR(acdev->dma_chan)) {\n\t\tdev_err_probe(acdev->host->dev, PTR_ERR(acdev->dma_chan),\n\t\t\t      \"Unable to get dma_chan\\n\");\n\t\tacdev->dma_chan = NULL;\n\t\tgoto chan_request_fail;\n\t}\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, temp) {\n\t\tret = sg_xfer(acdev, sg);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tdma_release_channel(acdev->dma_chan);\n\tacdev->dma_chan = NULL;\n\n\t \n\tif (!ret) {\n\t\tu32 status;\n\n\t\tspin_lock_irqsave(&acdev->host->lock, flags);\n\t\tstatus = ioread8(qc->ap->ioaddr.altstatus_addr);\n\t\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\t\tif (status & (ATA_BUSY | ATA_DRQ)) {\n\t\t\tata_sff_queue_delayed_work(&acdev->dwork, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tgoto sff_intr;\n\t}\n\n\tcf_dumpregs(acdev);\n\nchan_request_fail:\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\t \n\tqc->err_mask |= AC_ERR_HOST_BUS;\n\tqc->ap->hsm_task_state = HSM_ST_ERR;\n\n\tcf_ctrl_reset(acdev);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\nsff_intr:\n\tdma_complete(acdev);\n}\n\nstatic void delayed_finish(struct work_struct *work)\n{\n\tstruct arasan_cf_dev *acdev = container_of(work, struct arasan_cf_dev,\n\t\t\tdwork.work);\n\tstruct ata_queued_cmd *qc = acdev->qc;\n\tunsigned long flags;\n\tu8 status;\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\tstatus = ioread8(qc->ap->ioaddr.altstatus_addr);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\n\tif (status & (ATA_BUSY | ATA_DRQ))\n\t\tata_sff_queue_delayed_work(&acdev->dwork, 1);\n\telse\n\t\tdma_complete(acdev);\n}\n\nstatic irqreturn_t arasan_cf_interrupt(int irq, void *dev)\n{\n\tstruct arasan_cf_dev *acdev = ((struct ata_host *)dev)->private_data;\n\tunsigned long flags;\n\tu32 irqsts;\n\n\tirqsts = readl(acdev->vbase + GIRQ_STS);\n\tif (!(irqsts & GIRQ_CF))\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\tirqsts = readl(acdev->vbase + IRQ_STS);\n\twritel(irqsts, acdev->vbase + IRQ_STS);\t\t \n\twritel(GIRQ_CF, acdev->vbase + GIRQ_STS);\t \n\n\t \n\tirqsts &= ~IGNORED_IRQS;\n\n\tif (irqsts & CARD_DETECT_IRQ) {\n\t\tcf_card_detect(acdev, 1);\n\t\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (irqsts & PIO_XFER_ERR_IRQ) {\n\t\tacdev->dma_status = ATA_DMA_ERR;\n\t\twritel(readl(acdev->vbase + XFER_CTR) & ~XFER_START,\n\t\t\t\tacdev->vbase + XFER_CTR);\n\t\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\t\tcomplete(&acdev->cf_completion);\n\t\tdev_err(acdev->host->dev, \"pio xfer err irq\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\n\tif (irqsts & BUF_AVAIL_IRQ) {\n\t\tcomplete(&acdev->cf_completion);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (irqsts & XFER_DONE_IRQ) {\n\t\tstruct ata_queued_cmd *qc = acdev->qc;\n\n\t\t \n\t\tif (qc->tf.flags & ATA_TFLAG_WRITE)\n\t\t\tcomplete(&acdev->cf_completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void arasan_cf_freeze(struct ata_port *ap)\n{\n\tstruct arasan_cf_dev *acdev = ap->host->private_data;\n\n\t \n\twritel(readl(acdev->vbase + XFER_CTR) & ~XFER_START,\n\t\t\tacdev->vbase + XFER_CTR);\n\tcf_ctrl_reset(acdev);\n\tacdev->dma_status = ATA_DMA_ERR;\n\n\tata_sff_dma_pause(ap);\n\tata_sff_freeze(ap);\n}\n\nstatic void arasan_cf_error_handler(struct ata_port *ap)\n{\n\tstruct arasan_cf_dev *acdev = ap->host->private_data;\n\n\t \n\tcancel_work_sync(&acdev->work);\n\tcancel_delayed_work_sync(&acdev->dwork);\n\treturn ata_sff_error_handler(ap);\n}\n\nstatic void arasan_cf_dma_start(struct arasan_cf_dev *acdev)\n{\n\tstruct ata_queued_cmd *qc = acdev->qc;\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_taskfile *tf = &qc->tf;\n\tu32 xfer_ctr = readl(acdev->vbase + XFER_CTR) & ~XFER_DIR_MASK;\n\tu32 write = tf->flags & ATA_TFLAG_WRITE;\n\n\txfer_ctr |= write ? XFER_WRITE : XFER_READ;\n\twritel(xfer_ctr, acdev->vbase + XFER_CTR);\n\n\tap->ops->sff_exec_command(ap, tf);\n\tata_sff_queue_work(&acdev->work);\n}\n\nstatic unsigned int arasan_cf_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct arasan_cf_dev *acdev = ap->host->private_data;\n\n\t \n\tif (!ata_is_dma(qc->tf.protocol))\n\t\treturn ata_sff_qc_issue(qc);\n\n\t \n\tata_wait_idle(ap);\n\tata_sff_dev_select(ap, qc->dev->devno);\n\tata_wait_idle(ap);\n\n\t \n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\t\tWARN_ON_ONCE(qc->tf.flags & ATA_TFLAG_POLLING);\n\n\t\ttrace_ata_tf_load(ap, &qc->tf);\n\t\tap->ops->sff_tf_load(ap, &qc->tf);\n\t\tacdev->dma_status = 0;\n\t\tacdev->qc = qc;\n\t\ttrace_ata_bmdma_start(ap, &qc->tf, qc->tag);\n\t\tarasan_cf_dma_start(acdev);\n\t\tap->hsm_task_state = HSM_ST_LAST;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn AC_ERR_SYSTEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void arasan_cf_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct arasan_cf_dev *acdev = ap->host->private_data;\n\tu8 pio = adev->pio_mode - XFER_PIO_0;\n\tunsigned long flags;\n\tu32 val;\n\n\t \n\tif (pio > 6) {\n\t\tdev_err(ap->dev, \"Unknown PIO mode\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\tval = readl(acdev->vbase + OP_MODE) &\n\t\t~(ULTRA_DMA_ENB | MULTI_WORD_DMA_ENB | DRQ_BLOCK_SIZE_MASK);\n\twritel(val, acdev->vbase + OP_MODE);\n\tval = readl(acdev->vbase + TM_CFG) & ~TRUEIDE_PIO_TIMING_MASK;\n\tval |= pio << TRUEIDE_PIO_TIMING_SHIFT;\n\twritel(val, acdev->vbase + TM_CFG);\n\n\tcf_interrupt_enable(acdev, BUF_AVAIL_IRQ | XFER_DONE_IRQ, 0);\n\tcf_interrupt_enable(acdev, PIO_XFER_ERR_IRQ, 1);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n}\n\nstatic void arasan_cf_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct arasan_cf_dev *acdev = ap->host->private_data;\n\tu32 opmode, tmcfg, dma_mode = adev->dma_mode;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&acdev->host->lock, flags);\n\topmode = readl(acdev->vbase + OP_MODE) &\n\t\t~(MULTI_WORD_DMA_ENB | ULTRA_DMA_ENB);\n\ttmcfg = readl(acdev->vbase + TM_CFG);\n\n\tif ((dma_mode >= XFER_UDMA_0) && (dma_mode <= XFER_UDMA_6)) {\n\t\topmode |= ULTRA_DMA_ENB;\n\t\ttmcfg &= ~ULTRA_DMA_TIMING_MASK;\n\t\ttmcfg |= (dma_mode - XFER_UDMA_0) << ULTRA_DMA_TIMING_SHIFT;\n\t} else if ((dma_mode >= XFER_MW_DMA_0) && (dma_mode <= XFER_MW_DMA_4)) {\n\t\topmode |= MULTI_WORD_DMA_ENB;\n\t\ttmcfg &= ~TRUEIDE_MWORD_DMA_TIMING_MASK;\n\t\ttmcfg |= (dma_mode - XFER_MW_DMA_0) <<\n\t\t\tTRUEIDE_MWORD_DMA_TIMING_SHIFT;\n\t} else {\n\t\tdev_err(ap->dev, \"Unknown DMA mode\\n\");\n\t\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n\t\treturn;\n\t}\n\n\twritel(opmode, acdev->vbase + OP_MODE);\n\twritel(tmcfg, acdev->vbase + TM_CFG);\n\twritel(DMA_XFER_MODE, acdev->vbase + XFER_CTR);\n\n\tcf_interrupt_enable(acdev, PIO_XFER_ERR_IRQ, 0);\n\tcf_interrupt_enable(acdev, BUF_AVAIL_IRQ | XFER_DONE_IRQ, 1);\n\tspin_unlock_irqrestore(&acdev->host->lock, flags);\n}\n\nstatic struct ata_port_operations arasan_cf_ops = {\n\t.inherits = &ata_sff_port_ops,\n\t.freeze = arasan_cf_freeze,\n\t.error_handler = arasan_cf_error_handler,\n\t.qc_issue = arasan_cf_qc_issue,\n\t.set_piomode = arasan_cf_set_piomode,\n\t.set_dmamode = arasan_cf_set_dmamode,\n};\n\nstatic int arasan_cf_probe(struct platform_device *pdev)\n{\n\tstruct arasan_cf_dev *acdev;\n\tstruct arasan_cf_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tstruct resource *res;\n\tu32 quirk;\n\tirq_handler_t irq_handler = NULL;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),\n\t\t\t\tDRIVER_NAME)) {\n\t\tdev_warn(&pdev->dev, \"Failed to get memory region resource\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tacdev = devm_kzalloc(&pdev->dev, sizeof(*acdev), GFP_KERNEL);\n\tif (!acdev)\n\t\treturn -ENOMEM;\n\n\tif (pdata)\n\t\tquirk = pdata->quirk;\n\telse\n\t\tquirk = CF_BROKEN_UDMA;  \n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret > 0) {\n\t\tacdev->irq = ret;\n\t\tirq_handler = arasan_cf_interrupt;\n\t} else\tif (ret == -EPROBE_DEFER) {\n\t\treturn ret;\n\t} else\t{\n\t\tquirk |= CF_BROKEN_MWDMA | CF_BROKEN_UDMA;\n\t}\n\n\tacdev->pbase = res->start;\n\tacdev->vbase = devm_ioremap(&pdev->dev, res->start,\n\t\t\tresource_size(res));\n\tif (!acdev->vbase) {\n\t\tdev_warn(&pdev->dev, \"ioremap fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tacdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(acdev->clk)) {\n\t\tdev_warn(&pdev->dev, \"Clock not found\\n\");\n\t\treturn PTR_ERR(acdev->clk);\n\t}\n\n\t \n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host) {\n\t\tdev_warn(&pdev->dev, \"alloc host fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tap = host->ports[0];\n\thost->private_data = acdev;\n\tacdev->host = host;\n\tap->ops = &arasan_cf_ops;\n\tap->pio_mask = ATA_PIO6;\n\tap->mwdma_mask = ATA_MWDMA4;\n\tap->udma_mask = ATA_UDMA6;\n\n\tinit_completion(&acdev->cf_completion);\n\tinit_completion(&acdev->dma_completion);\n\tINIT_WORK(&acdev->work, data_xfer);\n\tINIT_DELAYED_WORK(&acdev->dwork, delayed_finish);\n\tdma_cap_set(DMA_MEMCPY, acdev->mask);\n\n\t \n\tif (quirk) {\n\t\tif (quirk & CF_BROKEN_PIO) {\n\t\t\tap->ops->set_piomode = NULL;\n\t\t\tap->pio_mask = 0;\n\t\t}\n\t\tif (quirk & CF_BROKEN_MWDMA)\n\t\t\tap->mwdma_mask = 0;\n\t\tif (quirk & CF_BROKEN_UDMA)\n\t\t\tap->udma_mask = 0;\n\t}\n\tap->flags |= ATA_FLAG_PIO_POLLING | ATA_FLAG_NO_ATAPI;\n\n\tap->ioaddr.cmd_addr = acdev->vbase + ATA_DATA_PORT;\n\tap->ioaddr.data_addr = acdev->vbase + ATA_DATA_PORT;\n\tap->ioaddr.error_addr = acdev->vbase + ATA_ERR_FTR;\n\tap->ioaddr.feature_addr = acdev->vbase + ATA_ERR_FTR;\n\tap->ioaddr.nsect_addr = acdev->vbase + ATA_SC;\n\tap->ioaddr.lbal_addr = acdev->vbase + ATA_SN;\n\tap->ioaddr.lbam_addr = acdev->vbase + ATA_CL;\n\tap->ioaddr.lbah_addr = acdev->vbase + ATA_CH;\n\tap->ioaddr.device_addr = acdev->vbase + ATA_SH;\n\tap->ioaddr.status_addr = acdev->vbase + ATA_STS_CMD;\n\tap->ioaddr.command_addr = acdev->vbase + ATA_STS_CMD;\n\tap->ioaddr.altstatus_addr = acdev->vbase + ATA_ASTS_DCTR;\n\tap->ioaddr.ctl_addr = acdev->vbase + ATA_ASTS_DCTR;\n\n\tata_port_desc(ap, \"phy_addr %llx virt_addr %p\",\n\t\t      (unsigned long long) res->start, acdev->vbase);\n\n\tret = cf_init(acdev);\n\tif (ret)\n\t\treturn ret;\n\n\tcf_card_detect(acdev, 0);\n\n\tret = ata_host_activate(host, acdev->irq, irq_handler, 0,\n\t\t\t\t&arasan_cf_sht);\n\tif (!ret)\n\t\treturn 0;\n\n\tcf_exit(acdev);\n\n\treturn ret;\n}\n\nstatic void arasan_cf_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct arasan_cf_dev *acdev = host->ports[0]->private_data;\n\n\tata_host_detach(host);\n\tcf_exit(acdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int arasan_cf_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct arasan_cf_dev *acdev = host->ports[0]->private_data;\n\n\tif (acdev->dma_chan)\n\t\tdmaengine_terminate_all(acdev->dma_chan);\n\n\tcf_exit(acdev);\n\tata_host_suspend(host, PMSG_SUSPEND);\n\treturn 0;\n}\n\nstatic int arasan_cf_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct arasan_cf_dev *acdev = host->ports[0]->private_data;\n\n\tcf_init(acdev);\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(arasan_cf_pm_ops, arasan_cf_suspend, arasan_cf_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id arasan_cf_id_table[] = {\n\t{ .compatible = \"arasan,cf-spear1340\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, arasan_cf_id_table);\n#endif\n\nstatic struct platform_driver arasan_cf_driver = {\n\t.probe\t\t= arasan_cf_probe,\n\t.remove_new\t= arasan_cf_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &arasan_cf_pm_ops,\n\t\t.of_match_table = of_match_ptr(arasan_cf_id_table),\n\t},\n};\n\nmodule_platform_driver(arasan_cf_driver);\n\nMODULE_AUTHOR(\"Viresh Kumar <vireshk@kernel.org>\");\nMODULE_DESCRIPTION(\"Arasan ATA Compact Flash driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}