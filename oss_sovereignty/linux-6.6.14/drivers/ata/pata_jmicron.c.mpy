{
  "module_name": "pata_jmicron.c",
  "hash_id": "5cbeb1231191bebad0db62cc2b6f000bcac232c67b67ea06492be861dfe0f4b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_jmicron.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/ata.h>\n\n#define DRV_NAME\t\"pata_jmicron\"\n#define DRV_VERSION\t\"0.1.5\"\n\ntypedef enum {\n\tPORT_PATA0 = 0,\n\tPORT_PATA1 = 1,\n\tPORT_SATA = 2,\n} port_type;\n\n \nstatic int jmicron_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 control;\n\tu32 control5;\n\tint port_mask = 1<< (4 * ap->port_no);\n\tint port = ap->port_no;\n\tport_type port_map[2];\n\n\t \n\tpci_read_config_dword(pdev, 0x40, &control);\n\tif ((control & port_mask) == 0)\n\t\treturn -ENOENT;\n\n\t \n\tif (control & (1 << 23)) {\n\t\tport_map[0] = PORT_SATA;\n\t\tport_map[1] = PORT_PATA0;\n\t} else {\n\t\tport_map[0] = PORT_SATA;\n\t\tport_map[1] = PORT_SATA;\n\t}\n\n\t \n\tpci_read_config_dword(pdev, 0x80, &control5);\n\tif (control5 & (1<<24))\n\t\tport_map[0] = PORT_PATA1;\n\n\t \n\tif (control & (1 << 22))\n\t\tport = port ^ 1;\n\n\t \n\tswitch (port_map[port]) {\n\tcase PORT_PATA0:\n\t\tif ((control & (1 << 5)) == 0)\n\t\t\treturn -ENOENT;\n\t\tif (control & (1 << 3))\t \n\t\t\tap->cbl = ATA_CBL_PATA40;\n\t\telse\n\t\t\tap->cbl = ATA_CBL_PATA80;\n\t\tbreak;\n\tcase PORT_PATA1:\n\t\t \n\t\tif ((control5 & (1 << 21)) == 0)\n\t\t\treturn -ENOENT;\n\t\tif (control5 & (1 << 19))\t \n\t\t\tap->cbl = ATA_CBL_PATA40;\n\t\telse\n\t\t\tap->cbl = ATA_CBL_PATA80;\n\t\tbreak;\n\tcase PORT_SATA:\n\t\tap->cbl = ATA_CBL_SATA;\n\t\tbreak;\n\t}\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic const struct scsi_host_template jmicron_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations jmicron_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.prereset\t\t= jmicron_pre_reset,\n};\n\n\n \n\nstatic int jmicron_init_one (struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags\t= ATA_FLAG_SLAVE_POSS,\n\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask \t= ATA_UDMA5,\n\n\t\t.port_ops\t= &jmicron_ops,\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &jmicron_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id jmicron_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_IDE << 8, 0xffff00, 0 },\n\t{ }\t \n};\n\nstatic struct pci_driver jmicron_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= jmicron_pci_tbl,\n\t.probe\t\t\t= jmicron_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(jmicron_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for Jmicron PATA ports\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, jmicron_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}