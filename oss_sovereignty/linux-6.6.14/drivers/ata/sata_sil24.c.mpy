{
  "module_name": "sata_sil24.c",
  "hash_id": "4beb602a9d8deadf2b61c4f851ba5f4575104074576c90c4c66b665e05f33847",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_sil24.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"sata_sil24\"\n#define DRV_VERSION\t\"1.1\"\n\n \nstruct sil24_prb {\n\t__le16\tctrl;\n\t__le16\tprot;\n\t__le32\trx_cnt;\n\tu8\tfis[6 * 4];\n};\n\n \nstruct sil24_sge {\n\t__le64\taddr;\n\t__le32\tcnt;\n\t__le32\tflags;\n};\n\n\nenum {\n\tSIL24_HOST_BAR\t\t= 0,\n\tSIL24_PORT_BAR\t\t= 2,\n\n\t \n\tSIL24_PRB_SZ\t\t= sizeof(struct sil24_prb)\n\t\t\t\t  + 2 * sizeof(struct sil24_sge),\n\tSIL24_MAX_SGT\t\t= (PAGE_SIZE - SIL24_PRB_SZ)\n\t\t\t\t  / (4 * sizeof(struct sil24_sge)),\n\n\t \n\tSIL24_MAX_SGE\t\t= 4 * SIL24_MAX_SGT + 1,\n\n\t \n\t\t \n\tHOST_SLOT_STAT\t\t= 0x00,  \n\tHOST_CTRL\t\t= 0x40,\n\tHOST_IRQ_STAT\t\t= 0x44,\n\tHOST_PHY_CFG\t\t= 0x48,\n\tHOST_BIST_CTRL\t\t= 0x50,\n\tHOST_BIST_PTRN\t\t= 0x54,\n\tHOST_BIST_STAT\t\t= 0x58,\n\tHOST_MEM_BIST_STAT\t= 0x5c,\n\tHOST_FLASH_CMD\t\t= 0x70,\n\t\t \n\tHOST_FLASH_DATA\t\t= 0x74,\n\tHOST_TRANSITION_DETECT\t= 0x75,\n\tHOST_GPIO_CTRL\t\t= 0x76,\n\tHOST_I2C_ADDR\t\t= 0x78,  \n\tHOST_I2C_DATA\t\t= 0x7c,\n\tHOST_I2C_XFER_CNT\t= 0x7e,\n\tHOST_I2C_CTRL\t\t= 0x7f,\n\n\t \n\tHOST_SSTAT_ATTN\t\t= (1 << 31),\n\n\t \n\tHOST_CTRL_M66EN\t\t= (1 << 16),  \n\tHOST_CTRL_TRDY\t\t= (1 << 17),  \n\tHOST_CTRL_STOP\t\t= (1 << 18),  \n\tHOST_CTRL_DEVSEL\t= (1 << 19),  \n\tHOST_CTRL_REQ64\t\t= (1 << 20),  \n\tHOST_CTRL_GLOBAL_RST\t= (1 << 31),  \n\n\t \n\tPORT_REGS_SIZE\t\t= 0x2000,\n\n\tPORT_LRAM\t\t= 0x0000,  \n\tPORT_LRAM_SLOT_SZ\t= 0x0080,  \n\n\tPORT_PMP\t\t= 0x0f80,  \n\tPORT_PMP_STATUS\t\t= 0x0000,  \n\tPORT_PMP_QACTIVE\t= 0x0004,  \n\tPORT_PMP_SIZE\t\t= 0x0008,  \n\n\t\t \n\tPORT_CTRL_STAT\t\t= 0x1000,  \n\tPORT_CTRL_CLR\t\t= 0x1004,  \n\tPORT_IRQ_STAT\t\t= 0x1008,  \n\tPORT_IRQ_ENABLE_SET\t= 0x1010,  \n\tPORT_IRQ_ENABLE_CLR\t= 0x1014,  \n\tPORT_ACTIVATE_UPPER_ADDR= 0x101c,\n\tPORT_EXEC_FIFO\t\t= 0x1020,  \n\tPORT_CMD_ERR\t\t= 0x1024,  \n\tPORT_FIS_CFG\t\t= 0x1028,\n\tPORT_FIFO_THRES\t\t= 0x102c,\n\t\t \n\tPORT_DECODE_ERR_CNT\t= 0x1040,\n\tPORT_DECODE_ERR_THRESH\t= 0x1042,\n\tPORT_CRC_ERR_CNT\t= 0x1044,\n\tPORT_CRC_ERR_THRESH\t= 0x1046,\n\tPORT_HSHK_ERR_CNT\t= 0x1048,\n\tPORT_HSHK_ERR_THRESH\t= 0x104a,\n\t\t \n\tPORT_PHY_CFG\t\t= 0x1050,\n\tPORT_SLOT_STAT\t\t= 0x1800,\n\tPORT_CMD_ACTIVATE\t= 0x1c00,  \n\tPORT_CONTEXT\t\t= 0x1e04,\n\tPORT_EXEC_DIAG\t\t= 0x1e00,  \n\tPORT_PSD_DIAG\t\t= 0x1e40,  \n\tPORT_SCONTROL\t\t= 0x1f00,\n\tPORT_SSTATUS\t\t= 0x1f04,\n\tPORT_SERROR\t\t= 0x1f08,\n\tPORT_SACTIVE\t\t= 0x1f0c,\n\n\t \n\tPORT_CS_PORT_RST\t= (1 << 0),  \n\tPORT_CS_DEV_RST\t\t= (1 << 1),  \n\tPORT_CS_INIT\t\t= (1 << 2),  \n\tPORT_CS_IRQ_WOC\t\t= (1 << 3),  \n\tPORT_CS_CDB16\t\t= (1 << 5),  \n\tPORT_CS_PMP_RESUME\t= (1 << 6),  \n\tPORT_CS_32BIT_ACTV\t= (1 << 10),  \n\tPORT_CS_PMP_EN\t\t= (1 << 13),  \n\tPORT_CS_RDY\t\t= (1 << 31),  \n\n\t \n\t \n\tPORT_IRQ_COMPLETE\t= (1 << 0),  \n\tPORT_IRQ_ERROR\t\t= (1 << 1),  \n\tPORT_IRQ_PORTRDY_CHG\t= (1 << 2),  \n\tPORT_IRQ_PWR_CHG\t= (1 << 3),  \n\tPORT_IRQ_PHYRDY_CHG\t= (1 << 4),  \n\tPORT_IRQ_COMWAKE\t= (1 << 5),  \n\tPORT_IRQ_UNK_FIS\t= (1 << 6),  \n\tPORT_IRQ_DEV_XCHG\t= (1 << 7),  \n\tPORT_IRQ_8B10B\t\t= (1 << 8),  \n\tPORT_IRQ_CRC\t\t= (1 << 9),  \n\tPORT_IRQ_HANDSHAKE\t= (1 << 10),  \n\tPORT_IRQ_SDB_NOTIFY\t= (1 << 11),  \n\n\tDEF_PORT_IRQ\t\t= PORT_IRQ_COMPLETE | PORT_IRQ_ERROR |\n\t\t\t\t  PORT_IRQ_PHYRDY_CHG | PORT_IRQ_DEV_XCHG |\n\t\t\t\t  PORT_IRQ_UNK_FIS | PORT_IRQ_SDB_NOTIFY,\n\n\t \n\tPORT_IRQ_RAW_SHIFT\t= 16,\n\tPORT_IRQ_MASKED_MASK\t= 0x7ff,\n\tPORT_IRQ_RAW_MASK\t= (0x7ff << PORT_IRQ_RAW_SHIFT),\n\n\t \n\tPORT_IRQ_STEER_SHIFT\t= 30,\n\tPORT_IRQ_STEER_MASK\t= (3 << PORT_IRQ_STEER_SHIFT),\n\n\t \n\tPORT_CERR_DEV\t\t= 1,  \n\tPORT_CERR_SDB\t\t= 2,  \n\tPORT_CERR_DATA\t\t= 3,  \n\tPORT_CERR_SEND\t\t= 4,  \n\tPORT_CERR_INCONSISTENT\t= 5,  \n\tPORT_CERR_DIRECTION\t= 6,  \n\tPORT_CERR_UNDERRUN\t= 7,  \n\tPORT_CERR_OVERRUN\t= 8,  \n\tPORT_CERR_PKT_PROT\t= 11,  \n\tPORT_CERR_SGT_BOUNDARY\t= 16,  \n\tPORT_CERR_SGT_TGTABRT\t= 17,  \n\tPORT_CERR_SGT_MSTABRT\t= 18,  \n\tPORT_CERR_SGT_PCIPERR\t= 19,  \n\tPORT_CERR_CMD_BOUNDARY\t= 24,  \n\tPORT_CERR_CMD_TGTABRT\t= 25,  \n\tPORT_CERR_CMD_MSTABRT\t= 26,  \n\tPORT_CERR_CMD_PCIPERR\t= 27,  \n\tPORT_CERR_XFR_UNDEF\t= 32,  \n\tPORT_CERR_XFR_TGTABRT\t= 33,  \n\tPORT_CERR_XFR_MSTABRT\t= 34,  \n\tPORT_CERR_XFR_PCIPERR\t= 35,  \n\tPORT_CERR_SENDSERVICE\t= 36,  \n\n\t \n\tPRB_CTRL_PROTOCOL\t= (1 << 0),  \n\tPRB_CTRL_PACKET_READ\t= (1 << 4),  \n\tPRB_CTRL_PACKET_WRITE\t= (1 << 5),  \n\tPRB_CTRL_NIEN\t\t= (1 << 6),  \n\tPRB_CTRL_SRST\t\t= (1 << 7),  \n\n\t \n\tPRB_PROT_PACKET\t\t= (1 << 0),\n\tPRB_PROT_TCQ\t\t= (1 << 1),\n\tPRB_PROT_NCQ\t\t= (1 << 2),\n\tPRB_PROT_READ\t\t= (1 << 3),\n\tPRB_PROT_WRITE\t\t= (1 << 4),\n\tPRB_PROT_TRANSPARENT\t= (1 << 5),\n\n\t \n\tSGE_TRM\t\t\t= (1 << 31),  \n\tSGE_LNK\t\t\t= (1 << 30),  \n\tSGE_DRD\t\t\t= (1 << 29),  \n\n\tSIL24_MAX_CMDS\t\t= 31,\n\n\t \n\tBID_SIL3124\t\t= 0,\n\tBID_SIL3132\t\t= 1,\n\tBID_SIL3131\t\t= 2,\n\n\t \n\tSIL24_COMMON_FLAGS\t= ATA_FLAG_SATA | ATA_FLAG_PIO_DMA |\n\t\t\t\t  ATA_FLAG_NCQ | ATA_FLAG_ACPI_SATA |\n\t\t\t\t  ATA_FLAG_AN | ATA_FLAG_PMP,\n\tSIL24_FLAG_PCIX_IRQ_WOC\t= (1 << 24),  \n\n\tIRQ_STAT_4PORTS\t\t= 0xf,\n};\n\nstruct sil24_ata_block {\n\tstruct sil24_prb prb;\n\tstruct sil24_sge sge[SIL24_MAX_SGE];\n};\n\nstruct sil24_atapi_block {\n\tstruct sil24_prb prb;\n\tu8 cdb[16];\n\tstruct sil24_sge sge[SIL24_MAX_SGE];\n};\n\nunion sil24_cmd_block {\n\tstruct sil24_ata_block ata;\n\tstruct sil24_atapi_block atapi;\n};\n\nstatic const struct sil24_cerr_info {\n\tunsigned int err_mask, action;\n\tconst char *desc;\n} sil24_cerr_db[] = {\n\t[0]\t\t\t= { AC_ERR_DEV, 0,\n\t\t\t\t    \"device error\" },\n\t[PORT_CERR_DEV]\t\t= { AC_ERR_DEV, 0,\n\t\t\t\t    \"device error via D2H FIS\" },\n\t[PORT_CERR_SDB]\t\t= { AC_ERR_DEV, 0,\n\t\t\t\t    \"device error via SDB FIS\" },\n\t[PORT_CERR_DATA]\t= { AC_ERR_ATA_BUS, ATA_EH_RESET,\n\t\t\t\t    \"error in data FIS\" },\n\t[PORT_CERR_SEND]\t= { AC_ERR_ATA_BUS, ATA_EH_RESET,\n\t\t\t\t    \"failed to transmit command FIS\" },\n\t[PORT_CERR_INCONSISTENT] = { AC_ERR_HSM, ATA_EH_RESET,\n\t\t\t\t     \"protocol mismatch\" },\n\t[PORT_CERR_DIRECTION]\t= { AC_ERR_HSM, ATA_EH_RESET,\n\t\t\t\t    \"data direction mismatch\" },\n\t[PORT_CERR_UNDERRUN]\t= { AC_ERR_HSM, ATA_EH_RESET,\n\t\t\t\t    \"ran out of SGEs while writing\" },\n\t[PORT_CERR_OVERRUN]\t= { AC_ERR_HSM, ATA_EH_RESET,\n\t\t\t\t    \"ran out of SGEs while reading\" },\n\t[PORT_CERR_PKT_PROT]\t= { AC_ERR_HSM, ATA_EH_RESET,\n\t\t\t\t    \"invalid data direction for ATAPI CDB\" },\n\t[PORT_CERR_SGT_BOUNDARY] = { AC_ERR_SYSTEM, ATA_EH_RESET,\n\t\t\t\t     \"SGT not on qword boundary\" },\n\t[PORT_CERR_SGT_TGTABRT]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI target abort while fetching SGT\" },\n\t[PORT_CERR_SGT_MSTABRT]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI master abort while fetching SGT\" },\n\t[PORT_CERR_SGT_PCIPERR]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI parity error while fetching SGT\" },\n\t[PORT_CERR_CMD_BOUNDARY] = { AC_ERR_SYSTEM, ATA_EH_RESET,\n\t\t\t\t     \"PRB not on qword boundary\" },\n\t[PORT_CERR_CMD_TGTABRT]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI target abort while fetching PRB\" },\n\t[PORT_CERR_CMD_MSTABRT]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI master abort while fetching PRB\" },\n\t[PORT_CERR_CMD_PCIPERR]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI parity error while fetching PRB\" },\n\t[PORT_CERR_XFR_UNDEF]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"undefined error while transferring data\" },\n\t[PORT_CERR_XFR_TGTABRT]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI target abort while transferring data\" },\n\t[PORT_CERR_XFR_MSTABRT]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI master abort while transferring data\" },\n\t[PORT_CERR_XFR_PCIPERR]\t= { AC_ERR_HOST_BUS, ATA_EH_RESET,\n\t\t\t\t    \"PCI parity error while transferring data\" },\n\t[PORT_CERR_SENDSERVICE]\t= { AC_ERR_HSM, ATA_EH_RESET,\n\t\t\t\t    \"FIS received while sending service FIS\" },\n};\n\n \nstruct sil24_port_priv {\n\tunion sil24_cmd_block *cmd_block;\t \n\tdma_addr_t cmd_block_dma;\t\t \n\tint do_port_rst;\n};\n\nstatic void sil24_dev_config(struct ata_device *dev);\nstatic int sil24_scr_read(struct ata_link *link, unsigned sc_reg, u32 *val);\nstatic int sil24_scr_write(struct ata_link *link, unsigned sc_reg, u32 val);\nstatic int sil24_qc_defer(struct ata_queued_cmd *qc);\nstatic enum ata_completion_errors sil24_qc_prep(struct ata_queued_cmd *qc);\nstatic unsigned int sil24_qc_issue(struct ata_queued_cmd *qc);\nstatic void sil24_qc_fill_rtf(struct ata_queued_cmd *qc);\nstatic void sil24_pmp_attach(struct ata_port *ap);\nstatic void sil24_pmp_detach(struct ata_port *ap);\nstatic void sil24_freeze(struct ata_port *ap);\nstatic void sil24_thaw(struct ata_port *ap);\nstatic int sil24_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t   unsigned long deadline);\nstatic int sil24_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t   unsigned long deadline);\nstatic int sil24_pmp_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t       unsigned long deadline);\nstatic void sil24_error_handler(struct ata_port *ap);\nstatic void sil24_post_internal_cmd(struct ata_queued_cmd *qc);\nstatic int sil24_port_start(struct ata_port *ap);\nstatic int sil24_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\n#ifdef CONFIG_PM_SLEEP\nstatic int sil24_pci_device_resume(struct pci_dev *pdev);\n#endif\n#ifdef CONFIG_PM\nstatic int sil24_port_resume(struct ata_port *ap);\n#endif\n\nstatic const struct pci_device_id sil24_pci_tbl[] = {\n\t{ PCI_VDEVICE(CMD, 0x3124), BID_SIL3124 },\n\t{ PCI_VDEVICE(INTEL, 0x3124), BID_SIL3124 },\n\t{ PCI_VDEVICE(CMD, 0x3132), BID_SIL3132 },\n\t{ PCI_VDEVICE(CMD, 0x0242), BID_SIL3132 },\n\t{ PCI_VDEVICE(CMD, 0x0244), BID_SIL3132 },\n\t{ PCI_VDEVICE(CMD, 0x3131), BID_SIL3131 },\n\t{ PCI_VDEVICE(CMD, 0x3531), BID_SIL3131 },\n\n\t{ }  \n};\n\nstatic struct pci_driver sil24_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= sil24_pci_tbl,\n\t.probe\t\t\t= sil24_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= sil24_pci_device_resume,\n#endif\n};\n\nstatic const struct scsi_host_template sil24_sht = {\n\t__ATA_BASE_SHT(DRV_NAME),\n\t.can_queue\t\t= SIL24_MAX_CMDS,\n\t.sg_tablesize\t\t= SIL24_MAX_SGE,\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY,\n\t.tag_alloc_policy\t= BLK_TAG_ALLOC_FIFO,\n\t.sdev_groups\t\t= ata_ncq_sdev_groups,\n\t.change_queue_depth\t= ata_scsi_change_queue_depth,\n\t.slave_configure\t= ata_scsi_slave_config\n};\n\nstatic struct ata_port_operations sil24_ops = {\n\t.inherits\t\t= &sata_pmp_port_ops,\n\n\t.qc_defer\t\t= sil24_qc_defer,\n\t.qc_prep\t\t= sil24_qc_prep,\n\t.qc_issue\t\t= sil24_qc_issue,\n\t.qc_fill_rtf\t\t= sil24_qc_fill_rtf,\n\n\t.freeze\t\t\t= sil24_freeze,\n\t.thaw\t\t\t= sil24_thaw,\n\t.softreset\t\t= sil24_softreset,\n\t.hardreset\t\t= sil24_hardreset,\n\t.pmp_softreset\t\t= sil24_softreset,\n\t.pmp_hardreset\t\t= sil24_pmp_hardreset,\n\t.error_handler\t\t= sil24_error_handler,\n\t.post_internal_cmd\t= sil24_post_internal_cmd,\n\t.dev_config\t\t= sil24_dev_config,\n\n\t.scr_read\t\t= sil24_scr_read,\n\t.scr_write\t\t= sil24_scr_write,\n\t.pmp_attach\t\t= sil24_pmp_attach,\n\t.pmp_detach\t\t= sil24_pmp_detach,\n\n\t.port_start\t\t= sil24_port_start,\n#ifdef CONFIG_PM\n\t.port_resume\t\t= sil24_port_resume,\n#endif\n};\n\nstatic bool sata_sil24_msi;     \nmodule_param_named(msi, sata_sil24_msi, bool, S_IRUGO);\nMODULE_PARM_DESC(msi, \"Enable MSI (Default: false)\");\n\n \n#define SIL24_NPORTS2FLAG(nports)\t((((unsigned)(nports) - 1) & 0x3) << 30)\n#define SIL24_FLAG2NPORTS(flag)\t\t((((flag) >> 30) & 0x3) + 1)\n\nstatic const struct ata_port_info sil24_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= SIL24_COMMON_FLAGS | SIL24_NPORTS2FLAG(4) |\n\t\t\t\t  SIL24_FLAG_PCIX_IRQ_WOC,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil24_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= SIL24_COMMON_FLAGS | SIL24_NPORTS2FLAG(2),\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil24_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= SIL24_COMMON_FLAGS | SIL24_NPORTS2FLAG(1),\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil24_ops,\n\t},\n};\n\nstatic int sil24_tag(int tag)\n{\n\tif (unlikely(ata_tag_internal(tag)))\n\t\treturn 0;\n\treturn tag;\n}\n\nstatic unsigned long sil24_port_offset(struct ata_port *ap)\n{\n\treturn ap->port_no * PORT_REGS_SIZE;\n}\n\nstatic void __iomem *sil24_port_base(struct ata_port *ap)\n{\n\treturn ap->host->iomap[SIL24_PORT_BAR] + sil24_port_offset(ap);\n}\n\nstatic void sil24_dev_config(struct ata_device *dev)\n{\n\tvoid __iomem *port = sil24_port_base(dev->link->ap);\n\n\tif (dev->cdb_len == 16)\n\t\twritel(PORT_CS_CDB16, port + PORT_CTRL_STAT);\n\telse\n\t\twritel(PORT_CS_CDB16, port + PORT_CTRL_CLR);\n}\n\nstatic void sil24_read_tf(struct ata_port *ap, int tag, struct ata_taskfile *tf)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tstruct sil24_prb __iomem *prb;\n\tu8 fis[6 * 4];\n\n\tprb = port + PORT_LRAM + sil24_tag(tag) * PORT_LRAM_SLOT_SZ;\n\tmemcpy_fromio(fis, prb->fis, sizeof(fis));\n\tata_tf_from_fis(fis, tf);\n}\n\nstatic int sil24_scr_map[] = {\n\t[SCR_CONTROL]\t= 0,\n\t[SCR_STATUS]\t= 1,\n\t[SCR_ERROR]\t= 2,\n\t[SCR_ACTIVE]\t= 3,\n};\n\nstatic int sil24_scr_read(struct ata_link *link, unsigned sc_reg, u32 *val)\n{\n\tvoid __iomem *scr_addr = sil24_port_base(link->ap) + PORT_SCONTROL;\n\n\tif (sc_reg < ARRAY_SIZE(sil24_scr_map)) {\n\t\t*val = readl(scr_addr + sil24_scr_map[sc_reg] * 4);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int sil24_scr_write(struct ata_link *link, unsigned sc_reg, u32 val)\n{\n\tvoid __iomem *scr_addr = sil24_port_base(link->ap) + PORT_SCONTROL;\n\n\tif (sc_reg < ARRAY_SIZE(sil24_scr_map)) {\n\t\twritel(val, scr_addr + sil24_scr_map[sc_reg] * 4);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void sil24_config_port(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\n\t \n\tif (ap->flags & SIL24_FLAG_PCIX_IRQ_WOC)\n\t\twritel(PORT_CS_IRQ_WOC, port + PORT_CTRL_STAT);\n\telse\n\t\twritel(PORT_CS_IRQ_WOC, port + PORT_CTRL_CLR);\n\n\t \n\twritew(0x8000, port + PORT_DECODE_ERR_THRESH);\n\twritew(0x8000, port + PORT_CRC_ERR_THRESH);\n\twritew(0x8000, port + PORT_HSHK_ERR_THRESH);\n\twritew(0x0000, port + PORT_DECODE_ERR_CNT);\n\twritew(0x0000, port + PORT_CRC_ERR_CNT);\n\twritew(0x0000, port + PORT_HSHK_ERR_CNT);\n\n\t \n\twritel(PORT_CS_32BIT_ACTV, port + PORT_CTRL_CLR);\n\n\t \n\twritel(PORT_CS_PMP_EN | PORT_CS_PMP_RESUME, port + PORT_CTRL_CLR);\n}\n\nstatic void sil24_config_pmp(struct ata_port *ap, int attached)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\n\tif (attached)\n\t\twritel(PORT_CS_PMP_EN, port + PORT_CTRL_STAT);\n\telse\n\t\twritel(PORT_CS_PMP_EN, port + PORT_CTRL_CLR);\n}\n\nstatic void sil24_clear_pmp(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tint i;\n\n\twritel(PORT_CS_PMP_RESUME, port + PORT_CTRL_CLR);\n\n\tfor (i = 0; i < SATA_PMP_MAX_PORTS; i++) {\n\t\tvoid __iomem *pmp_base = port + PORT_PMP + i * PORT_PMP_SIZE;\n\n\t\twritel(0, pmp_base + PORT_PMP_STATUS);\n\t\twritel(0, pmp_base + PORT_PMP_QACTIVE);\n\t}\n}\n\nstatic int sil24_init_port(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tstruct sil24_port_priv *pp = ap->private_data;\n\tu32 tmp;\n\n\t \n\tif (sata_pmp_attached(ap))\n\t\tsil24_clear_pmp(ap);\n\n\twritel(PORT_CS_INIT, port + PORT_CTRL_STAT);\n\tata_wait_register(ap, port + PORT_CTRL_STAT,\n\t\t\t  PORT_CS_INIT, PORT_CS_INIT, 10, 100);\n\ttmp = ata_wait_register(ap, port + PORT_CTRL_STAT,\n\t\t\t\tPORT_CS_RDY, 0, 10, 100);\n\n\tif ((tmp & (PORT_CS_INIT | PORT_CS_RDY)) != PORT_CS_RDY) {\n\t\tpp->do_port_rst = 1;\n\t\tap->link.eh_context.i.action |= ATA_EH_RESET;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sil24_exec_polled_cmd(struct ata_port *ap, int pmp,\n\t\t\t\t const struct ata_taskfile *tf,\n\t\t\t\t int is_cmd, u32 ctrl,\n\t\t\t\t unsigned int timeout_msec)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tstruct sil24_port_priv *pp = ap->private_data;\n\tstruct sil24_prb *prb = &pp->cmd_block[0].ata.prb;\n\tdma_addr_t paddr = pp->cmd_block_dma;\n\tu32 irq_enabled, irq_mask, irq_stat;\n\tint rc;\n\n\tprb->ctrl = cpu_to_le16(ctrl);\n\tata_tf_to_fis(tf, pmp, is_cmd, prb->fis);\n\n\t \n\tirq_enabled = readl(port + PORT_IRQ_ENABLE_SET);\n\twritel(PORT_IRQ_COMPLETE | PORT_IRQ_ERROR, port + PORT_IRQ_ENABLE_CLR);\n\n\t \n\twmb();\n\twritel((u32)paddr, port + PORT_CMD_ACTIVATE);\n\twritel((u64)paddr >> 32, port + PORT_CMD_ACTIVATE + 4);\n\n\tirq_mask = (PORT_IRQ_COMPLETE | PORT_IRQ_ERROR) << PORT_IRQ_RAW_SHIFT;\n\tirq_stat = ata_wait_register(ap, port + PORT_IRQ_STAT, irq_mask, 0x0,\n\t\t\t\t     10, timeout_msec);\n\n\twritel(irq_mask, port + PORT_IRQ_STAT);  \n\tirq_stat >>= PORT_IRQ_RAW_SHIFT;\n\n\tif (irq_stat & PORT_IRQ_COMPLETE)\n\t\trc = 0;\n\telse {\n\t\t \n\t\tsil24_init_port(ap);\n\n\t\tif (irq_stat & PORT_IRQ_ERROR)\n\t\t\trc = -EIO;\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\n\t \n\twritel(irq_enabled, port + PORT_IRQ_ENABLE_SET);\n\n\treturn rc;\n}\n\nstatic int sil24_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t   unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tint pmp = sata_srst_pmp(link);\n\tunsigned int timeout_msec = 0;\n\tstruct ata_taskfile tf;\n\tconst char *reason;\n\tint rc;\n\n\t \n\tif (sil24_init_port(ap)) {\n\t\treason = \"port not ready\";\n\t\tgoto err;\n\t}\n\n\t \n\tif (time_after(deadline, jiffies))\n\t\ttimeout_msec = jiffies_to_msecs(deadline - jiffies);\n\n\tata_tf_init(link->device, &tf);\t \n\trc = sil24_exec_polled_cmd(ap, pmp, &tf, 0, PRB_CTRL_SRST,\n\t\t\t\t   timeout_msec);\n\tif (rc == -EBUSY) {\n\t\treason = \"timeout\";\n\t\tgoto err;\n\t} else if (rc) {\n\t\treason = \"SRST command error\";\n\t\tgoto err;\n\t}\n\n\tsil24_read_tf(ap, 0, &tf);\n\t*class = ata_port_classify(ap, &tf);\n\n\treturn 0;\n\n err:\n\tata_link_err(link, \"softreset failed (%s)\\n\", reason);\n\treturn -EIO;\n}\n\nstatic int sil24_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t   unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *port = sil24_port_base(ap);\n\tstruct sil24_port_priv *pp = ap->private_data;\n\tint did_port_rst = 0;\n\tconst char *reason;\n\tint tout_msec, rc;\n\tu32 tmp;\n\n retry:\n\t \n\tif (pp->do_port_rst) {\n\t\tata_port_warn(ap,\n\t\t\t      \"controller in dubious state, performing PORT_RST\\n\");\n\n\t\twritel(PORT_CS_PORT_RST, port + PORT_CTRL_STAT);\n\t\tata_msleep(ap, 10);\n\t\twritel(PORT_CS_PORT_RST, port + PORT_CTRL_CLR);\n\t\tata_wait_register(ap, port + PORT_CTRL_STAT, PORT_CS_RDY, 0,\n\t\t\t\t  10, 5000);\n\n\t\t \n\t\tsil24_config_port(ap);\n\t\tsil24_config_pmp(ap, ap->nr_pmp_links);\n\n\t\tpp->do_port_rst = 0;\n\t\tdid_port_rst = 1;\n\t}\n\n\t \n\tsata_set_spd(link);\n\n\ttout_msec = 100;\n\tif (ata_link_online(link))\n\t\ttout_msec = 5000;\n\n\twritel(PORT_CS_DEV_RST, port + PORT_CTRL_STAT);\n\ttmp = ata_wait_register(ap, port + PORT_CTRL_STAT,\n\t\t\t\tPORT_CS_DEV_RST, PORT_CS_DEV_RST, 10,\n\t\t\t\ttout_msec);\n\n\t \n\trc = sata_link_debounce(link, sata_deb_timing_long, deadline);\n\tif (rc) {\n\t\treason = \"PHY debouncing failed\";\n\t\tgoto err;\n\t}\n\n\tif (tmp & PORT_CS_DEV_RST) {\n\t\tif (ata_link_offline(link))\n\t\t\treturn 0;\n\t\treason = \"link not ready\";\n\t\tgoto err;\n\t}\n\n\t \n\treturn -EAGAIN;\n\n err:\n\tif (!did_port_rst) {\n\t\tpp->do_port_rst = 1;\n\t\tgoto retry;\n\t}\n\n\tata_link_err(link, \"hardreset failed (%s)\\n\", reason);\n\treturn -EIO;\n}\n\nstatic inline void sil24_fill_sg(struct ata_queued_cmd *qc,\n\t\t\t\t struct sil24_sge *sge)\n{\n\tstruct scatterlist *sg;\n\tstruct sil24_sge *last_sge = NULL;\n\tunsigned int si;\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tsge->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tsge->cnt = cpu_to_le32(sg_dma_len(sg));\n\t\tsge->flags = 0;\n\n\t\tlast_sge = sge;\n\t\tsge++;\n\t}\n\n\tlast_sge->flags = cpu_to_le32(SGE_TRM);\n}\n\nstatic int sil24_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_link *link = qc->dev->link;\n\tstruct ata_port *ap = link->ap;\n\tu8 prot = qc->tf.protocol;\n\n\t \n\tint is_excl = (ata_is_atapi(prot) ||\n\t\t       (qc->flags & ATA_QCFLAG_RESULT_TF));\n\n\tif (unlikely(ap->excl_link)) {\n\t\tif (link == ap->excl_link) {\n\t\t\tif (ap->nr_active_links)\n\t\t\t\treturn ATA_DEFER_PORT;\n\t\t\tqc->flags |= ATA_QCFLAG_CLEAR_EXCL;\n\t\t} else\n\t\t\treturn ATA_DEFER_PORT;\n\t} else if (unlikely(is_excl)) {\n\t\tap->excl_link = link;\n\t\tif (ap->nr_active_links)\n\t\t\treturn ATA_DEFER_PORT;\n\t\tqc->flags |= ATA_QCFLAG_CLEAR_EXCL;\n\t}\n\n\treturn ata_std_qc_defer(qc);\n}\n\nstatic enum ata_completion_errors sil24_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sil24_port_priv *pp = ap->private_data;\n\tunion sil24_cmd_block *cb;\n\tstruct sil24_prb *prb;\n\tstruct sil24_sge *sge;\n\tu16 ctrl = 0;\n\n\tcb = &pp->cmd_block[sil24_tag(qc->hw_tag)];\n\n\tif (!ata_is_atapi(qc->tf.protocol)) {\n\t\tprb = &cb->ata.prb;\n\t\tsge = cb->ata.sge;\n\t\tif (ata_is_data(qc->tf.protocol)) {\n\t\t\tu16 prot = 0;\n\t\t\tctrl = PRB_CTRL_PROTOCOL;\n\t\t\tif (ata_is_ncq(qc->tf.protocol))\n\t\t\t\tprot |= PRB_PROT_NCQ;\n\t\t\tif (qc->tf.flags & ATA_TFLAG_WRITE)\n\t\t\t\tprot |= PRB_PROT_WRITE;\n\t\t\telse\n\t\t\t\tprot |= PRB_PROT_READ;\n\t\t\tprb->prot = cpu_to_le16(prot);\n\t\t}\n\t} else {\n\t\tprb = &cb->atapi.prb;\n\t\tsge = cb->atapi.sge;\n\t\tmemset(cb->atapi.cdb, 0, sizeof(cb->atapi.cdb));\n\t\tmemcpy(cb->atapi.cdb, qc->cdb, qc->dev->cdb_len);\n\n\t\tif (ata_is_data(qc->tf.protocol)) {\n\t\t\tif (qc->tf.flags & ATA_TFLAG_WRITE)\n\t\t\t\tctrl = PRB_CTRL_PACKET_WRITE;\n\t\t\telse\n\t\t\t\tctrl = PRB_CTRL_PACKET_READ;\n\t\t}\n\t}\n\n\tprb->ctrl = cpu_to_le16(ctrl);\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, prb->fis);\n\n\tif (qc->flags & ATA_QCFLAG_DMAMAP)\n\t\tsil24_fill_sg(qc, sge);\n\n\treturn AC_ERR_OK;\n}\n\nstatic unsigned int sil24_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sil24_port_priv *pp = ap->private_data;\n\tvoid __iomem *port = sil24_port_base(ap);\n\tunsigned int tag = sil24_tag(qc->hw_tag);\n\tdma_addr_t paddr;\n\tvoid __iomem *activate;\n\n\tpaddr = pp->cmd_block_dma + tag * sizeof(*pp->cmd_block);\n\tactivate = port + PORT_CMD_ACTIVATE + tag * 8;\n\n\t \n\twmb();\n\twritel((u32)paddr, activate);\n\twritel((u64)paddr >> 32, activate + 4);\n\n\treturn 0;\n}\n\nstatic void sil24_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tsil24_read_tf(qc->ap, qc->hw_tag, &qc->result_tf);\n}\n\nstatic void sil24_pmp_attach(struct ata_port *ap)\n{\n\tu32 *gscr = ap->link.device->gscr;\n\n\tsil24_config_pmp(ap, 1);\n\tsil24_init_port(ap);\n\n\tif (sata_pmp_gscr_vendor(gscr) == 0x11ab &&\n\t    sata_pmp_gscr_devid(gscr) == 0x4140) {\n\t\tata_port_info(ap,\n\t\t\t\"disabling NCQ support due to sil24-mv4140 quirk\\n\");\n\t\tap->flags &= ~ATA_FLAG_NCQ;\n\t}\n}\n\nstatic void sil24_pmp_detach(struct ata_port *ap)\n{\n\tsil24_init_port(ap);\n\tsil24_config_pmp(ap, 0);\n\n\tap->flags |= ATA_FLAG_NCQ;\n}\n\nstatic int sil24_pmp_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t       unsigned long deadline)\n{\n\tint rc;\n\n\trc = sil24_init_port(link->ap);\n\tif (rc) {\n\t\tata_link_err(link, \"hardreset failed (port not ready)\\n\");\n\t\treturn rc;\n\t}\n\n\treturn sata_std_hardreset(link, class, deadline);\n}\n\nstatic void sil24_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\n\t \n\twritel(0xffff, port + PORT_IRQ_ENABLE_CLR);\n}\n\nstatic void sil24_thaw(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tu32 tmp;\n\n\t \n\ttmp = readl(port + PORT_IRQ_STAT);\n\twritel(tmp, port + PORT_IRQ_STAT);\n\n\t \n\twritel(DEF_PORT_IRQ, port + PORT_IRQ_ENABLE_SET);\n}\n\nstatic void sil24_error_intr(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tstruct sil24_port_priv *pp = ap->private_data;\n\tstruct ata_queued_cmd *qc = NULL;\n\tstruct ata_link *link;\n\tstruct ata_eh_info *ehi;\n\tint abort = 0, freeze = 0;\n\tu32 irq_stat;\n\n\t \n\tirq_stat = readl(port + PORT_IRQ_STAT);\n\twritel(irq_stat, port + PORT_IRQ_STAT);\n\n\t \n\tlink = &ap->link;\n\tehi = &link->eh_info;\n\tata_ehi_clear_desc(ehi);\n\n\tata_ehi_push_desc(ehi, \"irq_stat 0x%08x\", irq_stat);\n\n\tif (irq_stat & PORT_IRQ_SDB_NOTIFY) {\n\t\tata_ehi_push_desc(ehi, \"SDB notify\");\n\t\tsata_async_notification(ap);\n\t}\n\n\tif (irq_stat & (PORT_IRQ_PHYRDY_CHG | PORT_IRQ_DEV_XCHG)) {\n\t\tata_ehi_hotplugged(ehi);\n\t\tata_ehi_push_desc(ehi, \"%s\",\n\t\t\t\t  irq_stat & PORT_IRQ_PHYRDY_CHG ?\n\t\t\t\t  \"PHY RDY changed\" : \"device exchanged\");\n\t\tfreeze = 1;\n\t}\n\n\tif (irq_stat & PORT_IRQ_UNK_FIS) {\n\t\tehi->err_mask |= AC_ERR_HSM;\n\t\tehi->action |= ATA_EH_RESET;\n\t\tata_ehi_push_desc(ehi, \"unknown FIS\");\n\t\tfreeze = 1;\n\t}\n\n\t \n\tif (irq_stat & PORT_IRQ_ERROR) {\n\t\tconst struct sil24_cerr_info *ci = NULL;\n\t\tunsigned int err_mask = 0, action = 0;\n\t\tu32 context, cerr;\n\t\tint pmp;\n\n\t\tabort = 1;\n\n\t\t \n\t\tif (ap->nr_active_links >= 3) {\n\t\t\tehi->err_mask |= AC_ERR_OTHER;\n\t\t\tehi->action |= ATA_EH_RESET;\n\t\t\tata_ehi_push_desc(ehi, \"PMP DMA CS errata\");\n\t\t\tpp->do_port_rst = 1;\n\t\t\tfreeze = 1;\n\t\t}\n\n\t\t \n\t\tif (sata_pmp_attached(ap)) {\n\t\t\tcontext = readl(port + PORT_CONTEXT);\n\t\t\tpmp = (context >> 5) & 0xf;\n\n\t\t\tif (pmp < ap->nr_pmp_links) {\n\t\t\t\tlink = &ap->pmp_link[pmp];\n\t\t\t\tehi = &link->eh_info;\n\t\t\t\tqc = ata_qc_from_tag(ap, link->active_tag);\n\n\t\t\t\tata_ehi_clear_desc(ehi);\n\t\t\t\tata_ehi_push_desc(ehi, \"irq_stat 0x%08x\",\n\t\t\t\t\t\t  irq_stat);\n\t\t\t} else {\n\t\t\t\terr_mask |= AC_ERR_HSM;\n\t\t\t\taction |= ATA_EH_RESET;\n\t\t\t\tfreeze = 1;\n\t\t\t}\n\t\t} else\n\t\t\tqc = ata_qc_from_tag(ap, link->active_tag);\n\n\t\t \n\t\tcerr = readl(port + PORT_CMD_ERR);\n\t\tif (cerr < ARRAY_SIZE(sil24_cerr_db))\n\t\t\tci = &sil24_cerr_db[cerr];\n\n\t\tif (ci && ci->desc) {\n\t\t\terr_mask |= ci->err_mask;\n\t\t\taction |= ci->action;\n\t\t\tif (action & ATA_EH_RESET)\n\t\t\t\tfreeze = 1;\n\t\t\tata_ehi_push_desc(ehi, \"%s\", ci->desc);\n\t\t} else {\n\t\t\terr_mask |= AC_ERR_OTHER;\n\t\t\taction |= ATA_EH_RESET;\n\t\t\tfreeze = 1;\n\t\t\tata_ehi_push_desc(ehi, \"unknown command error %d\",\n\t\t\t\t\t  cerr);\n\t\t}\n\n\t\t \n\t\tif (qc)\n\t\t\tqc->err_mask |= err_mask;\n\t\telse\n\t\t\tehi->err_mask |= err_mask;\n\n\t\tehi->action |= action;\n\n\t\t \n\t\tif (sata_pmp_attached(ap))\n\t\t\twritel(PORT_CS_PMP_RESUME, port + PORT_CTRL_STAT);\n\t}\n\n\t \n\tif (freeze)\n\t\tata_port_freeze(ap);\n\telse if (abort) {\n\t\tif (qc)\n\t\t\tata_link_abort(qc->dev->link);\n\t\telse\n\t\t\tata_port_abort(ap);\n\t}\n}\n\nstatic inline void sil24_host_intr(struct ata_port *ap)\n{\n\tvoid __iomem *port = sil24_port_base(ap);\n\tu32 slot_stat, qc_active;\n\tint rc;\n\n\t \n\tif (ap->flags & SIL24_FLAG_PCIX_IRQ_WOC)\n\t\twritel(PORT_IRQ_COMPLETE, port + PORT_IRQ_STAT);\n\n\tslot_stat = readl(port + PORT_SLOT_STAT);\n\n\tif (unlikely(slot_stat & HOST_SSTAT_ATTN)) {\n\t\tsil24_error_intr(ap);\n\t\treturn;\n\t}\n\n\tqc_active = slot_stat & ~HOST_SSTAT_ATTN;\n\trc = ata_qc_complete_multiple(ap, qc_active);\n\tif (rc > 0)\n\t\treturn;\n\tif (rc < 0) {\n\t\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\t\tehi->err_mask |= AC_ERR_HSM;\n\t\tehi->action |= ATA_EH_RESET;\n\t\tata_port_freeze(ap);\n\t\treturn;\n\t}\n\n\t \n\tif (!(ap->flags & SIL24_FLAG_PCIX_IRQ_WOC) && ata_ratelimit())\n\t\tata_port_info(ap,\n\t\t\t\"spurious interrupt (slot_stat 0x%x active_tag %d sactive 0x%x)\\n\",\n\t\t\tslot_stat, ap->link.active_tag, ap->link.sactive);\n}\n\nstatic irqreturn_t sil24_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tvoid __iomem *host_base = host->iomap[SIL24_HOST_BAR];\n\tunsigned handled = 0;\n\tu32 status;\n\tint i;\n\n\tstatus = readl(host_base + HOST_IRQ_STAT);\n\n\tif (status == 0xffffffff) {\n\t\tdev_err(host->dev, \"IRQ status == 0xffffffff, \"\n\t\t\t\"PCI fault or device removal?\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!(status & IRQ_STAT_4PORTS))\n\t\tgoto out;\n\n\tspin_lock(&host->lock);\n\n\tfor (i = 0; i < host->n_ports; i++)\n\t\tif (status & (1 << i)) {\n\t\t\tsil24_host_intr(host->ports[i]);\n\t\t\thandled++;\n\t\t}\n\n\tspin_unlock(&host->lock);\n out:\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void sil24_error_handler(struct ata_port *ap)\n{\n\tstruct sil24_port_priv *pp = ap->private_data;\n\n\tif (sil24_init_port(ap))\n\t\tata_eh_freeze_port(ap);\n\n\tsata_pmp_error_handler(ap);\n\n\tpp->do_port_rst = 0;\n}\n\nstatic void sil24_post_internal_cmd(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\t \n\tif ((qc->flags & ATA_QCFLAG_EH) && sil24_init_port(ap))\n\t\tata_eh_freeze_port(ap);\n}\n\nstatic int sil24_port_start(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct sil24_port_priv *pp;\n\tunion sil24_cmd_block *cb;\n\tsize_t cb_size = sizeof(*cb) * SIL24_MAX_CMDS;\n\tdma_addr_t cb_dma;\n\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tcb = dmam_alloc_coherent(dev, cb_size, &cb_dma, GFP_KERNEL);\n\tif (!cb)\n\t\treturn -ENOMEM;\n\n\tpp->cmd_block = cb;\n\tpp->cmd_block_dma = cb_dma;\n\n\tap->private_data = pp;\n\n\tata_port_pbar_desc(ap, SIL24_HOST_BAR, -1, \"host\");\n\tata_port_pbar_desc(ap, SIL24_PORT_BAR, sil24_port_offset(ap), \"port\");\n\n\treturn 0;\n}\n\nstatic void sil24_init_controller(struct ata_host *host)\n{\n\tvoid __iomem *host_base = host->iomap[SIL24_HOST_BAR];\n\tu32 tmp;\n\tint i;\n\n\t \n\twritel(0, host_base + HOST_FLASH_CMD);\n\n\t \n\twritel(0, host_base + HOST_CTRL);\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tvoid __iomem *port = sil24_port_base(ap);\n\n\n\t\t \n\t\twritel(0x20c, port + PORT_PHY_CFG);\n\n\t\t \n\t\ttmp = readl(port + PORT_CTRL_STAT);\n\t\tif (tmp & PORT_CS_PORT_RST) {\n\t\t\twritel(PORT_CS_PORT_RST, port + PORT_CTRL_CLR);\n\t\t\ttmp = ata_wait_register(NULL, port + PORT_CTRL_STAT,\n\t\t\t\t\t\tPORT_CS_PORT_RST,\n\t\t\t\t\t\tPORT_CS_PORT_RST, 10, 100);\n\t\t\tif (tmp & PORT_CS_PORT_RST)\n\t\t\t\tdev_err(host->dev,\n\t\t\t\t\t\"failed to clear port RST\\n\");\n\t\t}\n\n\t\t \n\t\tsil24_config_port(ap);\n\t}\n\n\t \n\twritel(IRQ_STAT_4PORTS, host_base + HOST_CTRL);\n}\n\nstatic int sil24_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\textern int __MARKER__sil24_cmd_block_is_sized_wrongly;\n\tstruct ata_port_info pi = sil24_port_info[ent->driver_data];\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tvoid __iomem * const *iomap;\n\tstruct ata_host *host;\n\tint rc;\n\tu32 tmp;\n\n\t \n\tif (sizeof(union sil24_cmd_block) != PAGE_SIZE)\n\t\t__MARKER__sil24_cmd_block_is_sized_wrongly = 1;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev,\n\t\t\t\t(1 << SIL24_HOST_BAR) | (1 << SIL24_PORT_BAR),\n\t\t\t\tDRV_NAME);\n\tif (rc)\n\t\treturn rc;\n\tiomap = pcim_iomap_table(pdev);\n\n\t \n\tif (pi.flags & SIL24_FLAG_PCIX_IRQ_WOC) {\n\t\ttmp = readl(iomap[SIL24_HOST_BAR] + HOST_CTRL);\n\t\tif (tmp & (HOST_CTRL_TRDY | HOST_CTRL_STOP | HOST_CTRL_DEVSEL))\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Applying completion IRQ loss on PCI-X errata fix\\n\");\n\t\telse\n\t\t\tpi.flags &= ~SIL24_FLAG_PCIX_IRQ_WOC;\n\t}\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi,\n\t\t\t\t    SIL24_FLAG2NPORTS(ppi[0]->flags));\n\tif (!host)\n\t\treturn -ENOMEM;\n\thost->iomap = iomap;\n\n\t \n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"DMA enable failed\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tpcie_set_readrq(pdev, 4096);\n\n\tsil24_init_controller(host);\n\n\tif (sata_sil24_msi && !pci_enable_msi(pdev)) {\n\t\tdev_info(&pdev->dev, \"Using MSI\\n\");\n\t\tpci_intx(pdev, 0);\n\t}\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, sil24_interrupt, IRQF_SHARED,\n\t\t\t\t &sil24_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sil24_pci_device_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tvoid __iomem *host_base = host->iomap[SIL24_HOST_BAR];\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND)\n\t\twritel(HOST_CTRL_GLOBAL_RST, host_base + HOST_CTRL);\n\n\tsil24_init_controller(host);\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int sil24_port_resume(struct ata_port *ap)\n{\n\tsil24_config_pmp(ap, ap->nr_pmp_links);\n\treturn 0;\n}\n#endif\n\nmodule_pci_driver(sil24_pci_driver);\n\nMODULE_AUTHOR(\"Tejun Heo\");\nMODULE_DESCRIPTION(\"Silicon Image 3124/3132 SATA low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sil24_pci_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}