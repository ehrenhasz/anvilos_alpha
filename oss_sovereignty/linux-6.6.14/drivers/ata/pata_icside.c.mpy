{
  "module_name": "pata_icside.c",
  "hash_id": "142fdad8e41a4505acfb9c9c41ad6fde60bd7ae3d0a07c596f3e5250d560ef47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_icside.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n\n#include <asm/dma.h>\n#include <asm/ecard.h>\n\n#define DRV_NAME\t\"pata_icside\"\n\n#define ICS_IDENT_OFFSET\t\t0x2280\n\n#define ICS_ARCIN_V5_INTRSTAT\t\t0x0000\n#define ICS_ARCIN_V5_INTROFFSET\t\t0x0004\n\n#define ICS_ARCIN_V6_INTROFFSET_1\t0x2200\n#define ICS_ARCIN_V6_INTRSTAT_1\t\t0x2290\n#define ICS_ARCIN_V6_INTROFFSET_2\t0x3200\n#define ICS_ARCIN_V6_INTRSTAT_2\t\t0x3290\n\nstruct portinfo {\n\tunsigned int dataoffset;\n\tunsigned int ctrloffset;\n\tunsigned int stepping;\n};\n\nstatic const struct portinfo pata_icside_portinfo_v5 = {\n\t.dataoffset\t= 0x2800,\n\t.ctrloffset\t= 0x2b80,\n\t.stepping\t= 6,\n};\n\nstatic const struct portinfo pata_icside_portinfo_v6_1 = {\n\t.dataoffset\t= 0x2000,\n\t.ctrloffset\t= 0x2380,\n\t.stepping\t= 6,\n};\n\nstatic const struct portinfo pata_icside_portinfo_v6_2 = {\n\t.dataoffset\t= 0x3000,\n\t.ctrloffset\t= 0x3380,\n\t.stepping\t= 6,\n};\n\nstruct pata_icside_state {\n\tvoid __iomem *irq_port;\n\tvoid __iomem *ioc_base;\n\tunsigned int type;\n\tunsigned int dma;\n\tstruct {\n\t\tu8 port_sel;\n\t\tu8 disabled;\n\t\tunsigned int speed[ATA_MAX_DEVICES];\n\t} port[2];\n};\n\nstruct pata_icside_info {\n\tstruct pata_icside_state *state;\n\tstruct expansion_card\t*ec;\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*irqaddr;\n\tunsigned int\t\tirqmask;\n\tconst expansioncard_ops_t *irqops;\n\tunsigned int\t\tmwdma_mask;\n\tunsigned int\t\tnr_ports;\n\tconst struct portinfo\t*port[2];\n\tunsigned long\t\traw_base;\n\tunsigned long\t\traw_ioc_base;\n};\n\n#define ICS_TYPE_A3IN\t0\n#define ICS_TYPE_A3USER\t1\n#define ICS_TYPE_V6\t3\n#define ICS_TYPE_V5\t15\n#define ICS_TYPE_NOTYPE\t((unsigned int)-1)\n\n \n \nstatic void pata_icside_irqenable_arcin_v5 (struct expansion_card *ec, int irqnr)\n{\n\tstruct pata_icside_state *state = ec->irq_data;\n\n\twriteb(0, state->irq_port + ICS_ARCIN_V5_INTROFFSET);\n}\n\n \nstatic void pata_icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)\n{\n\tstruct pata_icside_state *state = ec->irq_data;\n\n\treadb(state->irq_port + ICS_ARCIN_V5_INTROFFSET);\n}\n\nstatic const expansioncard_ops_t pata_icside_ops_arcin_v5 = {\n\t.irqenable\t= pata_icside_irqenable_arcin_v5,\n\t.irqdisable\t= pata_icside_irqdisable_arcin_v5,\n};\n\n\n \n \nstatic void pata_icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)\n{\n\tstruct pata_icside_state *state = ec->irq_data;\n\tvoid __iomem *base = state->irq_port;\n\n\tif (!state->port[0].disabled)\n\t\twriteb(0, base + ICS_ARCIN_V6_INTROFFSET_1);\n\tif (!state->port[1].disabled)\n\t\twriteb(0, base + ICS_ARCIN_V6_INTROFFSET_2);\n}\n\n \nstatic void pata_icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)\n{\n\tstruct pata_icside_state *state = ec->irq_data;\n\n\treadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);\n\treadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);\n}\n\n \nstatic int pata_icside_irqpending_arcin_v6(struct expansion_card *ec)\n{\n\tstruct pata_icside_state *state = ec->irq_data;\n\n\treturn readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_1) & 1 ||\n\t       readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_2) & 1;\n}\n\nstatic const expansioncard_ops_t pata_icside_ops_arcin_v6 = {\n\t.irqenable\t= pata_icside_irqenable_arcin_v6,\n\t.irqdisable\t= pata_icside_irqdisable_arcin_v6,\n\t.irqpending\t= pata_icside_irqpending_arcin_v6,\n};\n\n\n \n\n \nstatic void pata_icside_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pata_icside_state *state = ap->host->private_data;\n\tstruct ata_timing t;\n\tunsigned int cycle;\n\tchar iomd_type;\n\n\t \n\tif (ata_timing_compute(adev, adev->dma_mode, &t, 1000, 1))\n\t\treturn;\n\n\t \n\tif (t.active <= 50 && t.recover <= 375 && t.cycle <= 425) {\n\t\tiomd_type = 'D';\n\t\tcycle = 187;\n\t} else if (t.active <= 125 && t.recover <= 375 && t.cycle <= 500) {\n\t\tiomd_type = 'C';\n\t\tcycle = 250;\n\t} else if (t.active <= 200 && t.recover <= 550 && t.cycle <= 750) {\n\t\tiomd_type = 'B';\n\t\tcycle = 437;\n\t} else {\n\t\tiomd_type = 'A';\n\t\tcycle = 562;\n\t}\n\n\tata_dev_info(adev, \"timings: act %dns rec %dns cyc %dns (%c)\\n\",\n\t\t     t.active, t.recover, t.cycle, iomd_type);\n\n\tstate->port[ap->port_no].speed[adev->devno] = cycle;\n}\n\nstatic void pata_icside_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_icside_state *state = ap->host->private_data;\n\tunsigned int write = qc->tf.flags & ATA_TFLAG_WRITE;\n\n\t \n\tBUG_ON(dma_channel_active(state->dma));\n\n\t \n\twriteb(state->port[ap->port_no].port_sel, state->ioc_base);\n\n\tset_dma_speed(state->dma, state->port[ap->port_no].speed[qc->dev->devno]);\n\tset_dma_sg(state->dma, qc->sg, qc->n_elem);\n\tset_dma_mode(state->dma, write ? DMA_MODE_WRITE : DMA_MODE_READ);\n\n\t \n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\nstatic void pata_icside_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_icside_state *state = ap->host->private_data;\n\n\tBUG_ON(dma_channel_active(state->dma));\n\tenable_dma(state->dma);\n}\n\nstatic void pata_icside_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pata_icside_state *state = ap->host->private_data;\n\n\tdisable_dma(state->dma);\n\n\t \n\tata_sff_dma_pause(ap);\n}\n\nstatic u8 pata_icside_bmdma_status(struct ata_port *ap)\n{\n\tstruct pata_icside_state *state = ap->host->private_data;\n\tvoid __iomem *irq_port;\n\n\tirq_port = state->irq_port + (ap->port_no ? ICS_ARCIN_V6_INTRSTAT_2 :\n\t\t\t\t\t\t    ICS_ARCIN_V6_INTRSTAT_1);\n\n\treturn readb(irq_port) & 1 ? ATA_DMA_INTR : 0;\n}\n\nstatic int icside_dma_init(struct pata_icside_info *info)\n{\n\tstruct pata_icside_state *state = info->state;\n\tstruct expansion_card *ec = info->ec;\n\tint i;\n\n\tfor (i = 0; i < ATA_MAX_DEVICES; i++) {\n\t\tstate->port[0].speed[i] = 480;\n\t\tstate->port[1].speed[i] = 480;\n\t}\n\n\tif (ec->dma != NO_DMA && !request_dma(ec->dma, DRV_NAME)) {\n\t\tstate->dma = ec->dma;\n\t\tinfo->mwdma_mask = ATA_MWDMA2;\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct scsi_host_template pata_icside_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= SG_MAX_SEGMENTS,\n\t.dma_boundary\t\t= IOMD_DMA_BOUNDARY,\n};\n\nstatic void pata_icside_postreset(struct ata_link *link, unsigned int *classes)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pata_icside_state *state = ap->host->private_data;\n\n\tif (classes[0] != ATA_DEV_NONE || classes[1] != ATA_DEV_NONE)\n\t\treturn ata_sff_postreset(link, classes);\n\n\tstate->port[ap->port_no].disabled = 1;\n\n\tif (state->type == ICS_TYPE_V6) {\n\t\t \n\t\tvoid __iomem *irq_port = state->irq_port +\n\t\t\t\t(ap->port_no ? ICS_ARCIN_V6_INTROFFSET_2 : ICS_ARCIN_V6_INTROFFSET_1);\n\t\treadb(irq_port);\n\t}\n}\n\nstatic struct ata_port_operations pata_icside_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t \n\t.qc_prep\t\t= ata_noop_qc_prep,\n\t.sff_data_xfer\t\t= ata_sff_data_xfer32,\n\t.bmdma_setup\t\t= pata_icside_bmdma_setup,\n\t.bmdma_start\t\t= pata_icside_bmdma_start,\n\t.bmdma_stop\t\t= pata_icside_bmdma_stop,\n\t.bmdma_status\t\t= pata_icside_bmdma_status,\n\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_dmamode\t\t= pata_icside_set_dmamode,\n\t.postreset\t\t= pata_icside_postreset,\n\n\t.port_start\t\t= ATA_OP_NULL,\t \n};\n\nstatic void pata_icside_setup_ioaddr(struct ata_port *ap, void __iomem *base,\n\t\t\t\t     struct pata_icside_info *info,\n\t\t\t\t     const struct portinfo *port)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tvoid __iomem *cmd = base + port->dataoffset;\n\n\tioaddr->cmd_addr\t= cmd;\n\tioaddr->data_addr\t= cmd + (ATA_REG_DATA    << port->stepping);\n\tioaddr->error_addr\t= cmd + (ATA_REG_ERR     << port->stepping);\n\tioaddr->feature_addr\t= cmd + (ATA_REG_FEATURE << port->stepping);\n\tioaddr->nsect_addr\t= cmd + (ATA_REG_NSECT   << port->stepping);\n\tioaddr->lbal_addr\t= cmd + (ATA_REG_LBAL    << port->stepping);\n\tioaddr->lbam_addr\t= cmd + (ATA_REG_LBAM    << port->stepping);\n\tioaddr->lbah_addr\t= cmd + (ATA_REG_LBAH    << port->stepping);\n\tioaddr->device_addr\t= cmd + (ATA_REG_DEVICE  << port->stepping);\n\tioaddr->status_addr\t= cmd + (ATA_REG_STATUS  << port->stepping);\n\tioaddr->command_addr\t= cmd + (ATA_REG_CMD     << port->stepping);\n\n\tioaddr->ctl_addr\t= base + port->ctrloffset;\n\tioaddr->altstatus_addr\t= ioaddr->ctl_addr;\n\n\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\",\n\t\t      info->raw_base + port->dataoffset,\n\t\t      info->raw_base + port->ctrloffset);\n\n\tif (info->raw_ioc_base)\n\t\tata_port_desc(ap, \"iocbase 0x%lx\", info->raw_ioc_base);\n}\n\nstatic int pata_icside_register_v5(struct pata_icside_info *info)\n{\n\tstruct pata_icside_state *state = info->state;\n\tvoid __iomem *base;\n\n\tbase = ecardm_iomap(info->ec, ECARD_RES_MEMC, 0, 0);\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tstate->irq_port = base;\n\n\tinfo->base = base;\n\tinfo->irqaddr = base + ICS_ARCIN_V5_INTRSTAT;\n\tinfo->irqmask = 1;\n\tinfo->irqops = &pata_icside_ops_arcin_v5;\n\tinfo->nr_ports = 1;\n\tinfo->port[0] = &pata_icside_portinfo_v5;\n\n\tinfo->raw_base = ecard_resource_start(info->ec, ECARD_RES_MEMC);\n\n\treturn 0;\n}\n\nstatic int pata_icside_register_v6(struct pata_icside_info *info)\n{\n\tstruct pata_icside_state *state = info->state;\n\tstruct expansion_card *ec = info->ec;\n\tvoid __iomem *ioc_base, *easi_base;\n\tunsigned int sel = 0;\n\n\tioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\n\tif (!ioc_base)\n\t\treturn -ENOMEM;\n\n\teasi_base = ioc_base;\n\n\tif (ecard_resource_flags(ec, ECARD_RES_EASI)) {\n\t\teasi_base = ecardm_iomap(ec, ECARD_RES_EASI, 0, 0);\n\t\tif (!easi_base)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tsel = 1 << 5;\n\t}\n\n\twriteb(sel, ioc_base);\n\n\tstate->irq_port = easi_base;\n\tstate->ioc_base = ioc_base;\n\tstate->port[0].port_sel = sel;\n\tstate->port[1].port_sel = sel | 1;\n\n\tinfo->base = easi_base;\n\tinfo->irqops = &pata_icside_ops_arcin_v6;\n\tinfo->nr_ports = 2;\n\tinfo->port[0] = &pata_icside_portinfo_v6_1;\n\tinfo->port[1] = &pata_icside_portinfo_v6_2;\n\n\tinfo->raw_base = ecard_resource_start(ec, ECARD_RES_EASI);\n\tinfo->raw_ioc_base = ecard_resource_start(ec, ECARD_RES_IOCFAST);\n\n\treturn icside_dma_init(info);\n}\n\nstatic int pata_icside_add_ports(struct pata_icside_info *info)\n{\n\tstruct expansion_card *ec = info->ec;\n\tstruct ata_host *host;\n\tint i;\n\n\tif (info->irqaddr) {\n\t\tec->irqaddr = info->irqaddr;\n\t\tec->irqmask = info->irqmask;\n\t}\n\tif (info->irqops)\n\t\tecard_setirq(ec, info->irqops, info->state);\n\n\t \n\tec->ops->irqdisable(ec, ec->irq);\n\n\thost = ata_host_alloc(&ec->dev, info->nr_ports);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->private_data = info->state;\n\thost->flags = ATA_HOST_SIMPLEX;\n\n\tfor (i = 0; i < info->nr_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tap->pio_mask = ATA_PIO4;\n\t\tap->mwdma_mask = info->mwdma_mask;\n\t\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\t\tap->ops = &pata_icside_port_ops;\n\n\t\tpata_icside_setup_ioaddr(ap, info->base, info, info->port[i]);\n\t}\n\n\treturn ata_host_activate(host, ec->irq, ata_bmdma_interrupt, 0,\n\t\t\t\t &pata_icside_sht);\n}\n\nstatic int pata_icside_probe(struct expansion_card *ec,\n\t\t\t     const struct ecard_id *id)\n{\n\tstruct pata_icside_state *state;\n\tstruct pata_icside_info info;\n\tvoid __iomem *idmem;\n\tint ret;\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tstate = devm_kzalloc(&ec->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tstate->type = ICS_TYPE_NOTYPE;\n\tstate->dma = NO_DMA;\n\n\tidmem = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\n\tif (idmem) {\n\t\tunsigned int type;\n\n\t\ttype = readb(idmem + ICS_IDENT_OFFSET) & 1;\n\t\ttype |= (readb(idmem + ICS_IDENT_OFFSET + 4) & 1) << 1;\n\t\ttype |= (readb(idmem + ICS_IDENT_OFFSET + 8) & 1) << 2;\n\t\ttype |= (readb(idmem + ICS_IDENT_OFFSET + 12) & 1) << 3;\n\t\tecardm_iounmap(ec, idmem);\n\n\t\tstate->type = type;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.state = state;\n\tinfo.ec = ec;\n\n\tswitch (state->type) {\n\tcase ICS_TYPE_A3IN:\n\t\tdev_warn(&ec->dev, \"A3IN unsupported\\n\");\n\t\tret = -ENODEV;\n\t\tbreak;\n\n\tcase ICS_TYPE_A3USER:\n\t\tdev_warn(&ec->dev, \"A3USER unsupported\\n\");\n\t\tret = -ENODEV;\n\t\tbreak;\n\n\tcase ICS_TYPE_V5:\n\t\tret = pata_icside_register_v5(&info);\n\t\tbreak;\n\n\tcase ICS_TYPE_V6:\n\t\tret = pata_icside_register_v6(&info);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&ec->dev, \"unknown interface type\\n\");\n\t\tret = -ENODEV;\n\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\tret = pata_icside_add_ports(&info);\n\n\tif (ret == 0)\n\t\tgoto out;\n\n release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void pata_icside_shutdown(struct expansion_card *ec)\n{\n\tstruct ata_host *host = ecard_get_drvdata(ec);\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\tec->ops->irqdisable(ec, ec->irq);\n\tlocal_irq_restore(flags);\n\n\t \n\tif (host) {\n\t\tstruct pata_icside_state *state = host->private_data;\n\t\tif (state->ioc_base)\n\t\t\twriteb(0, state->ioc_base);\n\t}\n}\n\nstatic void pata_icside_remove(struct expansion_card *ec)\n{\n\tstruct ata_host *host = ecard_get_drvdata(ec);\n\tstruct pata_icside_state *state = host->private_data;\n\n\tata_host_detach(host);\n\n\tpata_icside_shutdown(ec);\n\n\t \n\tif (state->dma != NO_DMA)\n\t\tfree_dma(state->dma);\n\n\tecard_release_resources(ec);\n}\n\nstatic const struct ecard_id pata_icside_ids[] = {\n\t{ MANU_ICS,  PROD_ICS_IDE  },\n\t{ MANU_ICS2, PROD_ICS2_IDE },\n\t{ 0xffff, 0xffff }\n};\n\nstatic struct ecard_driver pata_icside_driver = {\n\t.probe\t\t= pata_icside_probe,\n\t.remove \t= pata_icside_remove,\n\t.shutdown\t= pata_icside_shutdown,\n\t.id_table\t= pata_icside_ids,\n\t.drv = {\n\t\t.name\t= DRV_NAME,\n\t},\n};\n\nstatic int __init pata_icside_init(void)\n{\n\treturn ecard_register_driver(&pata_icside_driver);\n}\n\nstatic void __exit pata_icside_exit(void)\n{\n\tecard_remove_driver(&pata_icside_driver);\n}\n\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ICS PATA driver\");\n\nmodule_init(pata_icside_init);\nmodule_exit(pata_icside_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}