{
  "module_name": "ahci_xgene.c",
  "hash_id": "2b40b73ab1ed0e9b20511214c4f2f5034991abdc5b9cf684ff9d0f930290e8b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_xgene.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/ahci_platform.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/phy/phy.h>\n#include \"ahci.h\"\n\n#define DRV_NAME \"xgene-ahci\"\n\n \n#define MAX_AHCI_CHN_PERCTR\t\t2\n\n \n#define SATA_ENET_CONFIG_REG\t\t0x00000000\n#define  CFG_SATA_ENET_SELECT_MASK\t0x00000001\n\n \n#define SLVRDERRATTRIBUTES\t\t0x00000000\n#define SLVWRERRATTRIBUTES\t\t0x00000004\n#define MSTRDERRATTRIBUTES\t\t0x00000008\n#define MSTWRERRATTRIBUTES\t\t0x0000000c\n#define BUSCTLREG\t\t\t0x00000014\n#define IOFMSTRWAUX\t\t\t0x00000018\n#define INTSTATUSMASK\t\t\t0x0000002c\n#define ERRINTSTATUS\t\t\t0x00000030\n#define ERRINTSTATUSMASK\t\t0x00000034\n\n \n#define PORTCFG\t\t\t\t0x000000a4\n#define  PORTADDR_SET(dst, src) \\\n\t\t(((dst) & ~0x0000003f) | (((u32)(src)) & 0x0000003f))\n#define PORTPHY1CFG\t\t0x000000a8\n#define PORTPHY1CFG_FRCPHYRDY_SET(dst, src) \\\n\t\t(((dst) & ~0x00100000) | (((u32)(src) << 0x14) & 0x00100000))\n#define PORTPHY2CFG\t\t\t0x000000ac\n#define PORTPHY3CFG\t\t\t0x000000b0\n#define PORTPHY4CFG\t\t\t0x000000b4\n#define PORTPHY5CFG\t\t\t0x000000b8\n#define SCTL0\t\t\t\t0x0000012C\n#define PORTPHY5CFG_RTCHG_SET(dst, src) \\\n\t\t(((dst) & ~0xfff00000) | (((u32)(src) << 0x14) & 0xfff00000))\n#define PORTAXICFG_EN_CONTEXT_SET(dst, src) \\\n\t\t(((dst) & ~0x01000000) | (((u32)(src) << 0x18) & 0x01000000))\n#define PORTAXICFG\t\t\t0x000000bc\n#define PORTAXICFG_OUTTRANS_SET(dst, src) \\\n\t\t(((dst) & ~0x00f00000) | (((u32)(src) << 0x14) & 0x00f00000))\n#define PORTRANSCFG\t\t\t0x000000c8\n#define PORTRANSCFG_RXWM_SET(dst, src)\t\t\\\n\t\t(((dst) & ~0x0000007f) | (((u32)(src)) & 0x0000007f))\n\n \n#define INT_SLV_TMOMASK\t\t\t0x00000010\n\n \n#define CFG_MEM_RAM_SHUTDOWN\t\t0x00000070\n#define BLOCK_MEM_RDY\t\t\t0x00000074\n\n \n#define MAX_LINK_DOWN_RETRY 3\n\nenum xgene_ahci_version {\n\tXGENE_AHCI_V1 = 1,\n\tXGENE_AHCI_V2,\n};\n\nstruct xgene_ahci_context {\n\tstruct ahci_host_priv *hpriv;\n\tstruct device *dev;\n\tu8 last_cmd[MAX_AHCI_CHN_PERCTR];  \n\tu32 class[MAX_AHCI_CHN_PERCTR];  \n\tvoid __iomem *csr_core;\t\t \n\tvoid __iomem *csr_diag;\t\t \n\tvoid __iomem *csr_axi;\t\t \n\tvoid __iomem *csr_mux;\t\t \n};\n\nstatic int xgene_ahci_init_memram(struct xgene_ahci_context *ctx)\n{\n\tdev_dbg(ctx->dev, \"Release memory from shutdown\\n\");\n\twritel(0x0, ctx->csr_diag + CFG_MEM_RAM_SHUTDOWN);\n\treadl(ctx->csr_diag + CFG_MEM_RAM_SHUTDOWN);  \n\tmsleep(1);\t \n\tif (readl(ctx->csr_diag + BLOCK_MEM_RDY) != 0xFFFFFFFF) {\n\t\tdev_err(ctx->dev, \"failed to release memory from shutdown\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nstatic int xgene_ahci_poll_reg_val(struct ata_port *ap,\n\t\t\t\t   void __iomem *reg, unsigned int val,\n\t\t\t\t   unsigned int interval, unsigned int timeout)\n{\n\tunsigned long deadline;\n\tunsigned int tmp;\n\n\ttmp = ioread32(reg);\n\tdeadline = ata_deadline(jiffies, timeout);\n\n\twhile (tmp != val && time_before(jiffies, deadline)) {\n\t\tata_msleep(ap, interval);\n\t\ttmp = ioread32(reg);\n\t}\n\n\treturn tmp;\n}\n\n \nstatic int xgene_ahci_restart_engine(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 fbs;\n\n\t \n\tif (xgene_ahci_poll_reg_val(ap, port_mmio +\n\t\t\t\t    PORT_CMD_ISSUE, 0x0, 1, 100))\n\t\t  return -EBUSY;\n\n\thpriv->stop_engine(ap);\n\tahci_start_fis_rx(ap);\n\n\t \n\tif (pp->fbs_supported) {\n\t\tfbs = readl(port_mmio + PORT_FBS);\n\t\twritel(fbs | PORT_FBS_EN, port_mmio + PORT_FBS);\n\t\tfbs = readl(port_mmio + PORT_FBS);\n\t}\n\n\thpriv->start_engine(ap);\n\n\treturn 0;\n}\n\n \nstatic unsigned int xgene_ahci_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct xgene_ahci_context *ctx = hpriv->plat_data;\n\tint rc = 0;\n\tu32 port_fbs;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\n\t \n\tif (ctx->class[ap->port_no] == ATA_DEV_PMP) {\n\t\tport_fbs = readl(port_mmio + PORT_FBS);\n\t\tport_fbs &= ~PORT_FBS_DEV_MASK;\n\t\tport_fbs |= qc->dev->link->pmp << PORT_FBS_DEV_OFFSET;\n\t\twritel(port_fbs, port_mmio + PORT_FBS);\n\t}\n\n\tif (unlikely((ctx->last_cmd[ap->port_no] == ATA_CMD_ID_ATA) ||\n\t    (ctx->last_cmd[ap->port_no] == ATA_CMD_PACKET) ||\n\t    (ctx->last_cmd[ap->port_no] == ATA_CMD_SMART)))\n\t\txgene_ahci_restart_engine(ap);\n\n\trc = ahci_qc_issue(qc);\n\n\t \n\tctx->last_cmd[ap->port_no] = qc->tf.command;\n\n\treturn rc;\n}\n\nstatic bool xgene_ahci_is_memram_inited(struct xgene_ahci_context *ctx)\n{\n\tvoid __iomem *diagcsr = ctx->csr_diag;\n\n\treturn (readl(diagcsr + CFG_MEM_RAM_SHUTDOWN) == 0 &&\n\t        readl(diagcsr + BLOCK_MEM_RDY) == 0xFFFFFFFF);\n}\n\n \nstatic unsigned int xgene_ahci_read_id(struct ata_device *dev,\n\t\t\t\t       struct ata_taskfile *tf, __le16 *id)\n{\n\tu32 err_mask;\n\n\terr_mask = ata_do_dev_read_id(dev, tf, id);\n\tif (err_mask)\n\t\treturn err_mask;\n\n\t \n\tid[ATA_ID_FEATURE_SUPP] &= cpu_to_le16(~(1 << 8));\n\n\treturn 0;\n}\n\nstatic void xgene_ahci_set_phy_cfg(struct xgene_ahci_context *ctx, int channel)\n{\n\tvoid __iomem *mmio = ctx->hpriv->mmio;\n\tu32 val;\n\n\tdev_dbg(ctx->dev, \"port configure mmio 0x%p channel %d\\n\",\n\t\tmmio, channel);\n\tval = readl(mmio + PORTCFG);\n\tval = PORTADDR_SET(val, channel == 0 ? 2 : 3);\n\twritel(val, mmio + PORTCFG);\n\treadl(mmio + PORTCFG);   \n\t \n\twritel(0x0001fffe, mmio + PORTPHY1CFG);\n\treadl(mmio + PORTPHY1CFG);  \n\twritel(0x28183219, mmio + PORTPHY2CFG);\n\treadl(mmio + PORTPHY2CFG);  \n\twritel(0x13081008, mmio + PORTPHY3CFG);\n\treadl(mmio + PORTPHY3CFG);  \n\twritel(0x00480815, mmio + PORTPHY4CFG);\n\treadl(mmio + PORTPHY4CFG);  \n\t \n\tval = readl(mmio + PORTPHY5CFG);\n\tval = PORTPHY5CFG_RTCHG_SET(val, 0x300);\n\twritel(val, mmio + PORTPHY5CFG);\n\treadl(mmio + PORTPHY5CFG);  \n\tval = readl(mmio + PORTAXICFG);\n\tval = PORTAXICFG_EN_CONTEXT_SET(val, 0x1);  \n\tval = PORTAXICFG_OUTTRANS_SET(val, 0xe);  \n\twritel(val, mmio + PORTAXICFG);\n\treadl(mmio + PORTAXICFG);  \n\t \n\tval = readl(mmio + PORTRANSCFG);\n\tval = PORTRANSCFG_RXWM_SET(val, 0x30);\n\twritel(val, mmio + PORTRANSCFG);\n}\n\n \nstatic int xgene_ahci_do_hardreset(struct ata_link *link,\n\t\t\t\t   unsigned long deadline, bool *online)\n{\n\tconst unsigned int *timing = sata_ehc_deb_timing(&link->eh_context);\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct xgene_ahci_context *ctx = hpriv->plat_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ata_taskfile tf;\n\tint link_down_retry = 0;\n\tint rc;\n\tu32 val, sstatus;\n\n\tdo {\n\t\t \n\t\tata_tf_init(link->device, &tf);\n\t\ttf.status = ATA_BUSY;\n\t\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\t\trc = sata_link_hardreset(link, timing, deadline, online,\n\t\t\t\t ahci_check_ready);\n\t\tif (*online) {\n\t\t\tval = readl(port_mmio + PORT_SCR_ERR);\n\t\t\tif (val & (SERR_DISPARITY | SERR_10B_8B_ERR))\n\t\t\t\tdev_warn(ctx->dev, \"link has error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tsata_scr_read(link, SCR_STATUS, &sstatus);\n\t} while (link_down_retry++ < MAX_LINK_DOWN_RETRY &&\n\t\t (sstatus & 0xff) == 0x1);\n\n\t \n\tval = readl(port_mmio + PORT_SCR_ERR);\n\twritel(val, port_mmio + PORT_SCR_ERR);\n\n\treturn rc;\n}\n\nstatic int xgene_ahci_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\tunsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n        struct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tbool online;\n\tint rc;\n\tu32 portcmd_saved;\n\tu32 portclb_saved;\n\tu32 portclbhi_saved;\n\tu32 portrxfis_saved;\n\tu32 portrxfishi_saved;\n\n\t \n\tportcmd_saved = readl(port_mmio + PORT_CMD);\n\tportclb_saved = readl(port_mmio + PORT_LST_ADDR);\n\tportclbhi_saved = readl(port_mmio + PORT_LST_ADDR_HI);\n\tportrxfis_saved = readl(port_mmio + PORT_FIS_ADDR);\n\tportrxfishi_saved = readl(port_mmio + PORT_FIS_ADDR_HI);\n\n\thpriv->stop_engine(ap);\n\n\trc = xgene_ahci_do_hardreset(link, deadline, &online);\n\n\t \n\twritel(portcmd_saved, port_mmio + PORT_CMD);\n\twritel(portclb_saved, port_mmio + PORT_LST_ADDR);\n\twritel(portclbhi_saved, port_mmio + PORT_LST_ADDR_HI);\n\twritel(portrxfis_saved, port_mmio + PORT_FIS_ADDR);\n\twritel(portrxfishi_saved, port_mmio + PORT_FIS_ADDR_HI);\n\n\thpriv->start_engine(ap);\n\n\tif (online)\n\t\t*class = ahci_dev_classify(ap);\n\n\treturn rc;\n}\n\nstatic void xgene_ahci_host_stop(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\tahci_platform_disable_resources(hpriv);\n}\n\n \nstatic int xgene_ahci_pmp_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline)\n{\n\tint pmp = sata_srst_pmp(link);\n\tstruct ata_port *ap = link->ap;\n\tu32 rc;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 port_fbs;\n\n\t \n\tport_fbs = readl(port_mmio + PORT_FBS);\n\tport_fbs &= ~PORT_FBS_DEV_MASK;\n\tport_fbs |= pmp << PORT_FBS_DEV_OFFSET;\n\twritel(port_fbs, port_mmio + PORT_FBS);\n\n\trc = ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);\n\n\treturn rc;\n}\n\n \nstatic int xgene_ahci_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline)\n{\n\tint pmp = sata_srst_pmp(link);\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct xgene_ahci_context *ctx = hpriv->plat_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 port_fbs;\n\tu32 port_fbs_save;\n\tu32 retry = 1;\n\tu32 rc;\n\n\tport_fbs_save = readl(port_mmio + PORT_FBS);\n\n\t \n\tport_fbs = readl(port_mmio + PORT_FBS);\n\tport_fbs &= ~PORT_FBS_DEV_MASK;\n\tport_fbs |= pmp << PORT_FBS_DEV_OFFSET;\n\twritel(port_fbs, port_mmio + PORT_FBS);\n\nsoftreset_retry:\n\trc = ahci_do_softreset(link, class, pmp,\n\t\t\t       deadline, ahci_check_ready);\n\n\tctx->class[ap->port_no] = *class;\n\tif (*class != ATA_DEV_PMP) {\n\t\t \n\t\tif (retry--) {\n\t\t\twritel(port_fbs_save, port_mmio + PORT_FBS);\n\t\t\tgoto softreset_retry;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic int xgene_ahci_handle_broken_edge_irq(struct ata_host *host,\n\t\t\t\t\t     u32 irq_masked)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *port_mmio;\n\tint i;\n\n\tif (!readl(hpriv->mmio + HOST_IRQ_STAT)) {\n\t\tfor (i = 0; i < host->n_ports; i++) {\n\t\t\tif (irq_masked & (1 << i))\n\t\t\t\tcontinue;\n\n\t\t\tport_mmio = ahci_port_base(host->ports[i]);\n\t\t\tif (readl(port_mmio + PORT_IRQ_STAT))\n\t\t\t\tirq_masked |= (1 << i);\n\t\t}\n\t}\n\n\treturn ahci_handle_port_intr(host, irq_masked);\n}\n\nstatic irqreturn_t xgene_ahci_irq_intr(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct ahci_host_priv *hpriv;\n\tunsigned int rc = 0;\n\tvoid __iomem *mmio;\n\tu32 irq_stat, irq_masked;\n\n\thpriv = host->private_data;\n\tmmio = hpriv->mmio;\n\n\t \n\tirq_stat = readl(mmio + HOST_IRQ_STAT);\n\tif (!irq_stat)\n\t\treturn IRQ_NONE;\n\n\tirq_masked = irq_stat & hpriv->port_map;\n\n\tspin_lock(&host->lock);\n\n\t \n\twritel(irq_stat, mmio + HOST_IRQ_STAT);\n\n\trc = xgene_ahci_handle_broken_edge_irq(host, irq_masked);\n\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_RETVAL(rc);\n}\n\nstatic struct ata_port_operations xgene_ahci_v1_ops = {\n\t.inherits = &ahci_ops,\n\t.host_stop = xgene_ahci_host_stop,\n\t.hardreset = xgene_ahci_hardreset,\n\t.read_id = xgene_ahci_read_id,\n\t.qc_issue = xgene_ahci_qc_issue,\n\t.softreset = xgene_ahci_softreset,\n\t.pmp_softreset = xgene_ahci_pmp_softreset\n};\n\nstatic const struct ata_port_info xgene_ahci_v1_port_info = {\n\t.flags = AHCI_FLAG_COMMON | ATA_FLAG_PMP,\n\t.pio_mask = ATA_PIO4,\n\t.udma_mask = ATA_UDMA6,\n\t.port_ops = &xgene_ahci_v1_ops,\n};\n\nstatic struct ata_port_operations xgene_ahci_v2_ops = {\n\t.inherits = &ahci_ops,\n\t.host_stop = xgene_ahci_host_stop,\n\t.hardreset = xgene_ahci_hardreset,\n\t.read_id = xgene_ahci_read_id,\n};\n\nstatic const struct ata_port_info xgene_ahci_v2_port_info = {\n\t.flags = AHCI_FLAG_COMMON | ATA_FLAG_PMP,\n\t.pio_mask = ATA_PIO4,\n\t.udma_mask = ATA_UDMA6,\n\t.port_ops = &xgene_ahci_v2_ops,\n};\n\nstatic int xgene_ahci_hw_init(struct ahci_host_priv *hpriv)\n{\n\tstruct xgene_ahci_context *ctx = hpriv->plat_data;\n\tint i;\n\tint rc;\n\tu32 val;\n\n\t \n\trc = xgene_ahci_init_memram(ctx);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < MAX_AHCI_CHN_PERCTR; i++)\n\t\txgene_ahci_set_phy_cfg(ctx, i);\n\n\t \n\twritel(0xffffffff, hpriv->mmio + HOST_IRQ_STAT);\n\treadl(hpriv->mmio + HOST_IRQ_STAT);  \n\twritel(0, ctx->csr_core + INTSTATUSMASK);\n\tval = readl(ctx->csr_core + INTSTATUSMASK);  \n\tdev_dbg(ctx->dev, \"top level interrupt mask 0x%X value 0x%08X\\n\",\n\t\tINTSTATUSMASK, val);\n\n\twritel(0x0, ctx->csr_core + ERRINTSTATUSMASK);\n\treadl(ctx->csr_core + ERRINTSTATUSMASK);  \n\twritel(0x0, ctx->csr_axi + INT_SLV_TMOMASK);\n\treadl(ctx->csr_axi + INT_SLV_TMOMASK);\n\n\t \n\twritel(0xffffffff, ctx->csr_core + SLVRDERRATTRIBUTES);\n\twritel(0xffffffff, ctx->csr_core + SLVWRERRATTRIBUTES);\n\twritel(0xffffffff, ctx->csr_core + MSTRDERRATTRIBUTES);\n\twritel(0xffffffff, ctx->csr_core + MSTWRERRATTRIBUTES);\n\n\t \n\tval = readl(ctx->csr_core + BUSCTLREG);\n\tval &= ~0x00000002;      \n\tval &= ~0x00000001;      \n\twritel(val, ctx->csr_core + BUSCTLREG);\n\n\tval = readl(ctx->csr_core + IOFMSTRWAUX);\n\tval |= (1 << 3);         \n\tval |= (1 << 9);         \n\twritel(val, ctx->csr_core + IOFMSTRWAUX);\n\tval = readl(ctx->csr_core + IOFMSTRWAUX);\n\tdev_dbg(ctx->dev, \"coherency 0x%X value 0x%08X\\n\",\n\t\tIOFMSTRWAUX, val);\n\n\treturn rc;\n}\n\nstatic int xgene_ahci_mux_select(struct xgene_ahci_context *ctx)\n{\n\tu32 val;\n\n\t \n\tif (!ctx->csr_mux)\n\t\treturn 0;\n\n\tval = readl(ctx->csr_mux + SATA_ENET_CONFIG_REG);\n\tval &= ~CFG_SATA_ENET_SELECT_MASK;\n\twritel(val, ctx->csr_mux + SATA_ENET_CONFIG_REG);\n\tval = readl(ctx->csr_mux + SATA_ENET_CONFIG_REG);\n\treturn val & CFG_SATA_ENET_SELECT_MASK ? -1 : 0;\n}\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_ahci_acpi_match[] = {\n\t{ \"APMC0D0D\", XGENE_AHCI_V1},\n\t{ \"APMC0D32\", XGENE_AHCI_V2},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, xgene_ahci_acpi_match);\n#endif\n\nstatic const struct of_device_id xgene_ahci_of_match[] = {\n\t{.compatible = \"apm,xgene-ahci\", .data = (void *) XGENE_AHCI_V1},\n\t{.compatible = \"apm,xgene-ahci-v2\", .data = (void *) XGENE_AHCI_V2},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, xgene_ahci_of_match);\n\nstatic int xgene_ahci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct xgene_ahci_context *ctx;\n\tstruct resource *res;\n\tconst struct of_device_id *of_devid;\n\tenum xgene_ahci_version version = XGENE_AHCI_V1;\n\tconst struct ata_port_info *ppi[] = { &xgene_ahci_v1_port_info,\n\t\t\t\t\t      &xgene_ahci_v2_port_info };\n\tint rc;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\thpriv->plat_data = ctx;\n\tctx->hpriv = hpriv;\n\tctx->dev = dev;\n\n\t \n\tctx->csr_core = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(ctx->csr_core))\n\t\treturn PTR_ERR(ctx->csr_core);\n\n\t \n\tctx->csr_diag = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(ctx->csr_diag))\n\t\treturn PTR_ERR(ctx->csr_diag);\n\n\t \n\tctx->csr_axi = devm_platform_ioremap_resource(pdev, 3);\n\tif (IS_ERR(ctx->csr_axi))\n\t\treturn PTR_ERR(ctx->csr_axi);\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 4);\n\tif (res) {\n\t\tvoid __iomem *csr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(csr))\n\t\t\treturn PTR_ERR(csr);\n\n\t\tctx->csr_mux = csr;\n\t}\n\n\tof_devid = of_match_device(xgene_ahci_of_match, dev);\n\tif (of_devid) {\n\t\tif (of_devid->data)\n\t\t\tversion = (unsigned long) of_devid->data;\n\t}\n#ifdef CONFIG_ACPI\n\telse {\n\t\tconst struct acpi_device_id *acpi_id;\n\t\tstruct acpi_device_info *info;\n\t\tacpi_status status;\n\n\t\tacpi_id = acpi_match_device(xgene_ahci_acpi_match, &pdev->dev);\n\t\tif (!acpi_id) {\n\t\t\tdev_warn(&pdev->dev, \"No node entry in ACPI table. Assume version1\\n\");\n\t\t\tversion = XGENE_AHCI_V1;\n\t\t} else if (acpi_id->driver_data) {\n\t\t\tversion = (enum xgene_ahci_version) acpi_id->driver_data;\n\t\t\tstatus = acpi_get_object_info(ACPI_HANDLE(&pdev->dev), &info);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tdev_warn(&pdev->dev, \"%s: Error reading device info. Assume version1\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tversion = XGENE_AHCI_V1;\n\t\t\t} else {\n\t\t\t\tif (info->valid & ACPI_VALID_CID)\n\t\t\t\t\tversion = XGENE_AHCI_V2;\n\t\t\t\tkfree(info);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdev_dbg(dev, \"VAddr 0x%p Mmio VAddr 0x%p\\n\", ctx->csr_core,\n\t\thpriv->mmio);\n\n\t \n\tif ((rc = xgene_ahci_mux_select(ctx))) {\n\t\tdev_err(dev, \"SATA mux selection failed error %d\\n\", rc);\n\t\treturn -ENODEV;\n\t}\n\n\tif (xgene_ahci_is_memram_inited(ctx)) {\n\t\tdev_info(dev, \"skip clock and PHY initialization\\n\");\n\t\tgoto skip_clk_phy;\n\t}\n\n\t \n\trc = ahci_platform_enable_clks(hpriv);\n\tif (rc)\n\t\tgoto disable_resources;\n\tahci_platform_disable_clks(hpriv);\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\t \n\txgene_ahci_hw_init(hpriv);\nskip_clk_phy:\n\n\tswitch (version) {\n\tcase XGENE_AHCI_V1:\n\t\thpriv->flags = AHCI_HFLAG_NO_NCQ;\n\t\tbreak;\n\tcase XGENE_AHCI_V2:\n\t\thpriv->flags |= AHCI_HFLAG_YES_FBS;\n\t\thpriv->irq_handler = xgene_ahci_irq_intr;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trc = ahci_platform_init_host(pdev, hpriv, ppi[version - 1],\n\t\t\t\t     &ahci_platform_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\tdev_dbg(dev, \"X-Gene SATA host controller initialized\\n\");\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n\nstatic struct platform_driver xgene_ahci_driver = {\n\t.probe = xgene_ahci_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = xgene_ahci_of_match,\n\t\t.acpi_match_table = ACPI_PTR(xgene_ahci_acpi_match),\n\t},\n};\n\nmodule_platform_driver(xgene_ahci_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene AHCI SATA driver\");\nMODULE_AUTHOR(\"Loc Ho <lho@apm.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}