{
  "module_name": "ahci_tegra.c",
  "hash_id": "06586e1e57ee265fbeec6af1f482b963abbe8b0a28b5d52bdb824df0df4dd2a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_tegra.c",
  "human_readable_source": "\n \n\n#include <linux/ahci_platform.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/pmc.h>\n\n#include \"ahci.h\"\n\n#define DRV_NAME \"tegra-ahci\"\n\n#define SATA_CONFIGURATION_0\t\t\t\t0x180\n#define SATA_CONFIGURATION_0_EN_FPCI\t\t\tBIT(0)\n#define SATA_CONFIGURATION_0_CLK_OVERRIDE\t\t\tBIT(31)\n\n#define SCFG_OFFSET\t\t\t\t\t0x1000\n\n#define T_SATA0_CFG_1\t\t\t\t\t0x04\n#define T_SATA0_CFG_1_IO_SPACE\t\t\t\tBIT(0)\n#define T_SATA0_CFG_1_MEMORY_SPACE\t\t\tBIT(1)\n#define T_SATA0_CFG_1_BUS_MASTER\t\t\tBIT(2)\n#define T_SATA0_CFG_1_SERR\t\t\t\tBIT(8)\n\n#define T_SATA0_CFG_9\t\t\t\t\t0x24\n#define T_SATA0_CFG_9_BASE_ADDRESS\t\t\t0x40020000\n\n#define SATA_FPCI_BAR5\t\t\t\t\t0x94\n#define SATA_FPCI_BAR5_START_MASK\t\t\t(0xfffffff << 4)\n#define SATA_FPCI_BAR5_START\t\t\t\t(0x0040020 << 4)\n#define SATA_FPCI_BAR5_ACCESS_TYPE\t\t\t(0x1)\n\n#define SATA_INTR_MASK\t\t\t\t\t0x188\n#define SATA_INTR_MASK_IP_INT_MASK\t\t\tBIT(16)\n\n#define T_SATA0_CFG_35\t\t\t\t\t0x94\n#define T_SATA0_CFG_35_IDP_INDEX_MASK\t\t\t(0x7ff << 2)\n#define T_SATA0_CFG_35_IDP_INDEX\t\t\t(0x2a << 2)\n\n#define T_SATA0_AHCI_IDP1\t\t\t\t0x98\n#define T_SATA0_AHCI_IDP1_DATA\t\t\t\t(0x400040)\n\n#define T_SATA0_CFG_PHY_1\t\t\t\t0x12c\n#define T_SATA0_CFG_PHY_1_PADS_IDDQ_EN\t\t\tBIT(23)\n#define T_SATA0_CFG_PHY_1_PAD_PLL_IDDQ_EN\t\tBIT(22)\n\n#define T_SATA0_NVOOB                                   0x114\n#define T_SATA0_NVOOB_SQUELCH_FILTER_MODE_MASK          (0x3 << 24)\n#define T_SATA0_NVOOB_SQUELCH_FILTER_MODE               (0x1 << 24)\n#define T_SATA0_NVOOB_SQUELCH_FILTER_LENGTH_MASK        (0x3 << 26)\n#define T_SATA0_NVOOB_SQUELCH_FILTER_LENGTH             (0x3 << 26)\n\n#define T_SATA_CFG_PHY_0                                0x120\n#define T_SATA_CFG_PHY_0_USE_7BIT_ALIGN_DET_FOR_SPD     BIT(11)\n#define T_SATA_CFG_PHY_0_MASK_SQUELCH                   BIT(24)\n\n#define T_SATA0_CFG2NVOOB_2\t\t\t\t0x134\n#define T_SATA0_CFG2NVOOB_2_COMWAKE_IDLE_CNT_LOW_MASK\t(0x1ff << 18)\n#define T_SATA0_CFG2NVOOB_2_COMWAKE_IDLE_CNT_LOW\t(0xc << 18)\n\n#define T_SATA0_AHCI_HBA_CAP_BKDR\t\t\t0x300\n#define T_SATA0_AHCI_HBA_CAP_BKDR_PARTIAL_ST_CAP\tBIT(13)\n#define T_SATA0_AHCI_HBA_CAP_BKDR_SLUMBER_ST_CAP\tBIT(14)\n#define T_SATA0_AHCI_HBA_CAP_BKDR_SALP\t\t\tBIT(26)\n#define T_SATA0_AHCI_HBA_CAP_BKDR_SUPP_PM\t\tBIT(17)\n#define T_SATA0_AHCI_HBA_CAP_BKDR_SNCQ\t\t\tBIT(30)\n\n#define T_SATA0_BKDOOR_CC\t\t\t\t0x4a4\n#define T_SATA0_BKDOOR_CC_CLASS_CODE_MASK\t\t(0xffff << 16)\n#define T_SATA0_BKDOOR_CC_CLASS_CODE\t\t\t(0x0106 << 16)\n#define T_SATA0_BKDOOR_CC_PROG_IF_MASK\t\t\t(0xff << 8)\n#define T_SATA0_BKDOOR_CC_PROG_IF\t\t\t(0x01 << 8)\n\n#define T_SATA0_CFG_SATA\t\t\t\t0x54c\n#define T_SATA0_CFG_SATA_BACKDOOR_PROG_IF_EN\t\tBIT(12)\n\n#define T_SATA0_CFG_MISC\t\t\t\t0x550\n\n#define T_SATA0_INDEX\t\t\t\t\t0x680\n\n#define T_SATA0_CHX_PHY_CTRL1_GEN1\t\t\t0x690\n#define T_SATA0_CHX_PHY_CTRL1_GEN1_TX_AMP_MASK\t\t0xff\n#define T_SATA0_CHX_PHY_CTRL1_GEN1_TX_AMP_SHIFT\t\t0\n#define T_SATA0_CHX_PHY_CTRL1_GEN1_TX_PEAK_MASK\t\t(0xff << 8)\n#define T_SATA0_CHX_PHY_CTRL1_GEN1_TX_PEAK_SHIFT\t8\n\n#define T_SATA0_CHX_PHY_CTRL1_GEN2\t\t\t0x694\n#define T_SATA0_CHX_PHY_CTRL1_GEN2_TX_AMP_MASK\t\t0xff\n#define T_SATA0_CHX_PHY_CTRL1_GEN2_TX_AMP_SHIFT\t\t0\n#define T_SATA0_CHX_PHY_CTRL1_GEN2_TX_PEAK_MASK\t\t(0xff << 12)\n#define T_SATA0_CHX_PHY_CTRL1_GEN2_TX_PEAK_SHIFT\t12\n\n#define T_SATA0_CHX_PHY_CTRL2\t\t\t\t0x69c\n#define T_SATA0_CHX_PHY_CTRL2_CDR_CNTL_GEN1\t\t0x23\n\n#define T_SATA0_CHX_PHY_CTRL11\t\t\t\t0x6d0\n#define T_SATA0_CHX_PHY_CTRL11_GEN2_RX_EQ\t\t(0x2800 << 16)\n\n#define T_SATA0_CHX_PHY_CTRL17_0\t\t\t0x6e8\n#define T_SATA0_CHX_PHY_CTRL17_0_RX_EQ_CTRL_L_GEN1\t0x55010000\n#define T_SATA0_CHX_PHY_CTRL18_0\t\t\t0x6ec\n#define T_SATA0_CHX_PHY_CTRL18_0_RX_EQ_CTRL_L_GEN2\t0x55010000\n#define T_SATA0_CHX_PHY_CTRL20_0\t\t\t0x6f4\n#define T_SATA0_CHX_PHY_CTRL20_0_RX_EQ_CTRL_H_GEN1\t0x1\n#define T_SATA0_CHX_PHY_CTRL21_0\t\t\t0x6f8\n#define T_SATA0_CHX_PHY_CTRL21_0_RX_EQ_CTRL_H_GEN2\t0x1\n\n \n#define SATA_AUX_MISC_CNTL_1_0\t\t\t\t0x8\n#define SATA_AUX_MISC_CNTL_1_0_DEVSLP_OVERRIDE\t\tBIT(17)\n#define SATA_AUX_MISC_CNTL_1_0_SDS_SUPPORT\t\tBIT(13)\n#define SATA_AUX_MISC_CNTL_1_0_DESO_SUPPORT\t\tBIT(15)\n\n#define SATA_AUX_RX_STAT_INT_0\t\t\t\t0xc\n#define SATA_AUX_RX_STAT_INT_0_SATA_DEVSLP\t\tBIT(7)\n\n#define SATA_AUX_SPARE_CFG0_0\t\t\t\t0x18\n#define SATA_AUX_SPARE_CFG0_0_MDAT_TIMER_AFTER_PG_VALID\tBIT(14)\n\n#define FUSE_SATA_CALIB\t\t\t\t\t0x124\n#define FUSE_SATA_CALIB_MASK\t\t\t\t0x3\n\nstruct sata_pad_calibration {\n\tu8 gen1_tx_amp;\n\tu8 gen1_tx_peak;\n\tu8 gen2_tx_amp;\n\tu8 gen2_tx_peak;\n};\n\nstatic const struct sata_pad_calibration tegra124_pad_calibration[] = {\n\t{0x18, 0x04, 0x18, 0x0a},\n\t{0x0e, 0x04, 0x14, 0x0a},\n\t{0x0e, 0x07, 0x1a, 0x0e},\n\t{0x14, 0x0e, 0x1a, 0x0e},\n};\n\nstruct tegra_ahci_ops {\n\tint (*init)(struct ahci_host_priv *hpriv);\n};\n\nstruct tegra_ahci_regs {\n\tunsigned int nvoob_comma_cnt_mask;\n\tunsigned int nvoob_comma_cnt_val;\n};\n\nstruct tegra_ahci_soc {\n\tconst char *const\t\t*supply_names;\n\tu32\t\t\t\tnum_supplies;\n\tbool\t\t\t\tsupports_devslp;\n\tbool\t\t\t\thas_sata_oob_rst;\n\tconst struct tegra_ahci_ops\t*ops;\n\tconst struct tegra_ahci_regs\t*regs;\n};\n\nstruct tegra_ahci_priv {\n\tstruct platform_device\t   *pdev;\n\tvoid __iomem\t\t   *sata_regs;\n\tvoid __iomem\t\t   *sata_aux_regs;\n\tstruct reset_control\t   *sata_rst;\n\tstruct reset_control\t   *sata_oob_rst;\n\tstruct reset_control\t   *sata_cold_rst;\n\t \n\tstruct clk\t\t   *sata_clk;\n\tstruct regulator_bulk_data *supplies;\n\tconst struct tegra_ahci_soc *soc;\n};\n\nstatic void tegra_ahci_handle_quirks(struct ahci_host_priv *hpriv)\n{\n\tstruct tegra_ahci_priv *tegra = hpriv->plat_data;\n\tu32 val;\n\n\tif (tegra->sata_aux_regs && !tegra->soc->supports_devslp) {\n\t\tval = readl(tegra->sata_aux_regs + SATA_AUX_MISC_CNTL_1_0);\n\t\tval &= ~SATA_AUX_MISC_CNTL_1_0_SDS_SUPPORT;\n\t\twritel(val, tegra->sata_aux_regs + SATA_AUX_MISC_CNTL_1_0);\n\t}\n}\n\nstatic int tegra124_ahci_init(struct ahci_host_priv *hpriv)\n{\n\tstruct tegra_ahci_priv *tegra = hpriv->plat_data;\n\tstruct sata_pad_calibration calib;\n\tint ret;\n\tu32 val;\n\n\t \n\tret = tegra_fuse_readl(FUSE_SATA_CALIB, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tcalib = tegra124_pad_calibration[val & FUSE_SATA_CALIB_MASK];\n\n\twritel(BIT(0), tegra->sata_regs + SCFG_OFFSET + T_SATA0_INDEX);\n\n\tval = readl(tegra->sata_regs +\n\t\t    SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL1_GEN1);\n\tval &= ~T_SATA0_CHX_PHY_CTRL1_GEN1_TX_AMP_MASK;\n\tval &= ~T_SATA0_CHX_PHY_CTRL1_GEN1_TX_PEAK_MASK;\n\tval |= calib.gen1_tx_amp << T_SATA0_CHX_PHY_CTRL1_GEN1_TX_AMP_SHIFT;\n\tval |= calib.gen1_tx_peak << T_SATA0_CHX_PHY_CTRL1_GEN1_TX_PEAK_SHIFT;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET +\n\t       T_SATA0_CHX_PHY_CTRL1_GEN1);\n\n\tval = readl(tegra->sata_regs +\n\t\t    SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL1_GEN2);\n\tval &= ~T_SATA0_CHX_PHY_CTRL1_GEN2_TX_AMP_MASK;\n\tval &= ~T_SATA0_CHX_PHY_CTRL1_GEN2_TX_PEAK_MASK;\n\tval |= calib.gen2_tx_amp << T_SATA0_CHX_PHY_CTRL1_GEN1_TX_AMP_SHIFT;\n\tval |= calib.gen2_tx_peak << T_SATA0_CHX_PHY_CTRL1_GEN1_TX_PEAK_SHIFT;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET +\n\t       T_SATA0_CHX_PHY_CTRL1_GEN2);\n\n\twritel(T_SATA0_CHX_PHY_CTRL11_GEN2_RX_EQ,\n\t       tegra->sata_regs + SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL11);\n\twritel(T_SATA0_CHX_PHY_CTRL2_CDR_CNTL_GEN1,\n\t       tegra->sata_regs + SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL2);\n\n\twritel(0, tegra->sata_regs + SCFG_OFFSET + T_SATA0_INDEX);\n\n\treturn 0;\n}\n\nstatic int tegra_ahci_power_on(struct ahci_host_priv *hpriv)\n{\n\tstruct tegra_ahci_priv *tegra = hpriv->plat_data;\n\tint ret;\n\n\tret = regulator_bulk_enable(tegra->soc->num_supplies,\n\t\t\t\t    tegra->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tegra->pdev->dev.pm_domain) {\n\t\tret = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_SATA,\n\t\t\t\t\t\t\ttegra->sata_clk,\n\t\t\t\t\t\t\ttegra->sata_rst);\n\t\tif (ret)\n\t\t\tgoto disable_regulators;\n\t}\n\n\treset_control_assert(tegra->sata_oob_rst);\n\treset_control_assert(tegra->sata_cold_rst);\n\n\tret = ahci_platform_enable_resources(hpriv);\n\tif (ret)\n\t\tgoto disable_power;\n\n\treset_control_deassert(tegra->sata_cold_rst);\n\treset_control_deassert(tegra->sata_oob_rst);\n\n\treturn 0;\n\ndisable_power:\n\tclk_disable_unprepare(tegra->sata_clk);\n\n\tif (!tegra->pdev->dev.pm_domain)\n\t\ttegra_powergate_power_off(TEGRA_POWERGATE_SATA);\n\ndisable_regulators:\n\tregulator_bulk_disable(tegra->soc->num_supplies, tegra->supplies);\n\n\treturn ret;\n}\n\nstatic void tegra_ahci_power_off(struct ahci_host_priv *hpriv)\n{\n\tstruct tegra_ahci_priv *tegra = hpriv->plat_data;\n\n\tahci_platform_disable_resources(hpriv);\n\n\treset_control_assert(tegra->sata_rst);\n\treset_control_assert(tegra->sata_oob_rst);\n\treset_control_assert(tegra->sata_cold_rst);\n\n\tclk_disable_unprepare(tegra->sata_clk);\n\tif (!tegra->pdev->dev.pm_domain)\n\t\ttegra_powergate_power_off(TEGRA_POWERGATE_SATA);\n\n\tregulator_bulk_disable(tegra->soc->num_supplies, tegra->supplies);\n}\n\nstatic int tegra_ahci_controller_init(struct ahci_host_priv *hpriv)\n{\n\tstruct tegra_ahci_priv *tegra = hpriv->plat_data;\n\tint ret;\n\tu32 val;\n\n\tret = tegra_ahci_power_on(hpriv);\n\tif (ret) {\n\t\tdev_err(&tegra->pdev->dev,\n\t\t\t\"failed to power on AHCI controller: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tval = readl(tegra->sata_regs + SATA_FPCI_BAR5);\n\tval &= ~(SATA_FPCI_BAR5_START_MASK | SATA_FPCI_BAR5_ACCESS_TYPE);\n\tval |= SATA_FPCI_BAR5_START | SATA_FPCI_BAR5_ACCESS_TYPE;\n\twritel(val, tegra->sata_regs + SATA_FPCI_BAR5);\n\n\t \n\tval = readl(tegra->sata_regs + SATA_CONFIGURATION_0);\n\tval |= SATA_CONFIGURATION_0_EN_FPCI;\n\twritel(val, tegra->sata_regs + SATA_CONFIGURATION_0);\n\n\t \n\tval = T_SATA0_CHX_PHY_CTRL17_0_RX_EQ_CTRL_L_GEN1;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL17_0);\n\tval = T_SATA0_CHX_PHY_CTRL18_0_RX_EQ_CTRL_L_GEN2;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL18_0);\n\tval = T_SATA0_CHX_PHY_CTRL20_0_RX_EQ_CTRL_H_GEN1;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL20_0);\n\tval = T_SATA0_CHX_PHY_CTRL21_0_RX_EQ_CTRL_H_GEN2;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CHX_PHY_CTRL21_0);\n\n\t \n\n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA_CFG_PHY_0);\n\tval |= T_SATA_CFG_PHY_0_MASK_SQUELCH;\n\tval &= ~T_SATA_CFG_PHY_0_USE_7BIT_ALIGN_DET_FOR_SPD;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA_CFG_PHY_0);\n\n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_NVOOB);\n\tval &= ~(tegra->soc->regs->nvoob_comma_cnt_mask |\n\t\t T_SATA0_NVOOB_SQUELCH_FILTER_LENGTH_MASK |\n\t\t T_SATA0_NVOOB_SQUELCH_FILTER_MODE_MASK);\n\tval |= (tegra->soc->regs->nvoob_comma_cnt_val |\n\t\tT_SATA0_NVOOB_SQUELCH_FILTER_LENGTH |\n\t\tT_SATA0_NVOOB_SQUELCH_FILTER_MODE);\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_NVOOB);\n\n\t \n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG2NVOOB_2);\n\tval &= ~T_SATA0_CFG2NVOOB_2_COMWAKE_IDLE_CNT_LOW_MASK;\n\tval |= T_SATA0_CFG2NVOOB_2_COMWAKE_IDLE_CNT_LOW;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG2NVOOB_2);\n\n\tif (tegra->soc->ops && tegra->soc->ops->init)\n\t\ttegra->soc->ops->init(hpriv);\n\n\t \n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_1);\n\tval |= (T_SATA0_CFG_1_IO_SPACE | T_SATA0_CFG_1_MEMORY_SPACE |\n\t\tT_SATA0_CFG_1_BUS_MASTER | T_SATA0_CFG_1_SERR);\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_1);\n\tval = T_SATA0_CFG_9_BASE_ADDRESS;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_9);\n\n\t \n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_SATA);\n\tval |= T_SATA0_CFG_SATA_BACKDOOR_PROG_IF_EN;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_SATA);\n\n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_BKDOOR_CC);\n\tval &=\n\t    ~(T_SATA0_BKDOOR_CC_CLASS_CODE_MASK |\n\t      T_SATA0_BKDOOR_CC_PROG_IF_MASK);\n\tval |= T_SATA0_BKDOOR_CC_CLASS_CODE | T_SATA0_BKDOOR_CC_PROG_IF;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_BKDOOR_CC);\n\n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_SATA);\n\tval &= ~T_SATA0_CFG_SATA_BACKDOOR_PROG_IF_EN;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_SATA);\n\n\t \n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_AHCI_HBA_CAP_BKDR);\n\tval |= (T_SATA0_AHCI_HBA_CAP_BKDR_PARTIAL_ST_CAP |\n\t\tT_SATA0_AHCI_HBA_CAP_BKDR_SLUMBER_ST_CAP |\n\t\tT_SATA0_AHCI_HBA_CAP_BKDR_SALP |\n\t\tT_SATA0_AHCI_HBA_CAP_BKDR_SUPP_PM);\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_AHCI_HBA_CAP_BKDR);\n\n\t \n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_35);\n\tval &= ~T_SATA0_CFG_35_IDP_INDEX_MASK;\n\tval |= T_SATA0_CFG_35_IDP_INDEX;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_35);\n\n\tval = T_SATA0_AHCI_IDP1_DATA;\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_AHCI_IDP1);\n\n\tval = readl(tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_PHY_1);\n\tval |= (T_SATA0_CFG_PHY_1_PADS_IDDQ_EN |\n\t\tT_SATA0_CFG_PHY_1_PAD_PLL_IDDQ_EN);\n\twritel(val, tegra->sata_regs + SCFG_OFFSET + T_SATA0_CFG_PHY_1);\n\n\t \n\tval = readl(tegra->sata_regs + SATA_CONFIGURATION_0);\n\tval &= ~SATA_CONFIGURATION_0_CLK_OVERRIDE;\n\twritel(val, tegra->sata_regs + SATA_CONFIGURATION_0);\n\n\ttegra_ahci_handle_quirks(hpriv);\n\n\t \n\n\tval = readl(tegra->sata_regs + SATA_INTR_MASK);\n\tval |= SATA_INTR_MASK_IP_INT_MASK;\n\twritel(val, tegra->sata_regs + SATA_INTR_MASK);\n\n\treturn 0;\n}\n\nstatic void tegra_ahci_controller_deinit(struct ahci_host_priv *hpriv)\n{\n\ttegra_ahci_power_off(hpriv);\n}\n\nstatic void tegra_ahci_host_stop(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\ttegra_ahci_controller_deinit(hpriv);\n}\n\nstatic struct ata_port_operations ahci_tegra_port_ops = {\n\t.inherits\t= &ahci_ops,\n\t.host_stop\t= tegra_ahci_host_stop,\n};\n\nstatic const struct ata_port_info ahci_tegra_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON | ATA_FLAG_NO_DIPM,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_tegra_port_ops,\n};\n\nstatic const char *const tegra124_supply_names[] = {\n\t\"avdd\", \"hvdd\", \"vddio\", \"target-5v\", \"target-12v\"\n};\n\nstatic const struct tegra_ahci_ops tegra124_ahci_ops = {\n\t.init = tegra124_ahci_init,\n};\n\nstatic const struct tegra_ahci_regs tegra124_ahci_regs = {\n\t.nvoob_comma_cnt_mask = GENMASK(30, 28),\n\t.nvoob_comma_cnt_val = (7 << 28),\n};\n\nstatic const struct tegra_ahci_soc tegra124_ahci_soc = {\n\t.supply_names = tegra124_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra124_supply_names),\n\t.supports_devslp = false,\n\t.has_sata_oob_rst = true,\n\t.ops = &tegra124_ahci_ops,\n\t.regs = &tegra124_ahci_regs,\n};\n\nstatic const struct tegra_ahci_soc tegra210_ahci_soc = {\n\t.supports_devslp = false,\n\t.has_sata_oob_rst = true,\n\t.regs = &tegra124_ahci_regs,\n};\n\nstatic const struct tegra_ahci_regs tegra186_ahci_regs = {\n\t.nvoob_comma_cnt_mask = GENMASK(23, 16),\n\t.nvoob_comma_cnt_val = (7 << 16),\n};\n\nstatic const struct tegra_ahci_soc tegra186_ahci_soc = {\n\t.supports_devslp = false,\n\t.has_sata_oob_rst = false,\n\t.regs = &tegra186_ahci_regs,\n};\n\nstatic const struct of_device_id tegra_ahci_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra124-ahci\",\n\t\t.data = &tegra124_ahci_soc\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra210-ahci\",\n\t\t.data = &tegra210_ahci_soc\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra186-ahci\",\n\t\t.data = &tegra186_ahci_soc\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_ahci_of_match);\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int tegra_ahci_probe(struct platform_device *pdev)\n{\n\tstruct ahci_host_priv *hpriv;\n\tstruct tegra_ahci_priv *tegra;\n\tstruct resource *res;\n\tint ret;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\ttegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn -ENOMEM;\n\n\thpriv->plat_data = tegra;\n\n\ttegra->pdev = pdev;\n\ttegra->soc = of_device_get_match_data(&pdev->dev);\n\n\ttegra->sata_regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(tegra->sata_regs))\n\t\treturn PTR_ERR(tegra->sata_regs);\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\tif (res) {\n\t\ttegra->sata_aux_regs = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(tegra->sata_aux_regs))\n\t\t\treturn PTR_ERR(tegra->sata_aux_regs);\n\t}\n\n\ttegra->sata_rst = devm_reset_control_get(&pdev->dev, \"sata\");\n\tif (IS_ERR(tegra->sata_rst)) {\n\t\tdev_err(&pdev->dev, \"Failed to get sata reset\\n\");\n\t\treturn PTR_ERR(tegra->sata_rst);\n\t}\n\n\tif (tegra->soc->has_sata_oob_rst) {\n\t\ttegra->sata_oob_rst = devm_reset_control_get(&pdev->dev,\n\t\t\t\t\t\t\t     \"sata-oob\");\n\t\tif (IS_ERR(tegra->sata_oob_rst)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get sata-oob reset\\n\");\n\t\t\treturn PTR_ERR(tegra->sata_oob_rst);\n\t\t}\n\t}\n\n\ttegra->sata_cold_rst = devm_reset_control_get(&pdev->dev, \"sata-cold\");\n\tif (IS_ERR(tegra->sata_cold_rst)) {\n\t\tdev_err(&pdev->dev, \"Failed to get sata-cold reset\\n\");\n\t\treturn PTR_ERR(tegra->sata_cold_rst);\n\t}\n\n\ttegra->sata_clk = devm_clk_get(&pdev->dev, \"sata\");\n\tif (IS_ERR(tegra->sata_clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get sata clock\\n\");\n\t\treturn PTR_ERR(tegra->sata_clk);\n\t}\n\n\ttegra->supplies = devm_kcalloc(&pdev->dev,\n\t\t\t\t       tegra->soc->num_supplies,\n\t\t\t\t       sizeof(*tegra->supplies), GFP_KERNEL);\n\tif (!tegra->supplies)\n\t\treturn -ENOMEM;\n\n\tregulator_bulk_set_supply_names(tegra->supplies,\n\t\t\t\t\ttegra->soc->supply_names,\n\t\t\t\t\ttegra->soc->num_supplies);\n\n\tret = devm_regulator_bulk_get(&pdev->dev,\n\t\t\t\t      tegra->soc->num_supplies,\n\t\t\t\t      tegra->supplies);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tret = tegra_ahci_controller_init(hpriv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ahci_platform_init_host(pdev, hpriv, &ahci_tegra_port_info,\n\t\t\t\t      &ahci_platform_sht);\n\tif (ret)\n\t\tgoto deinit_controller;\n\n\treturn 0;\n\ndeinit_controller:\n\ttegra_ahci_controller_deinit(hpriv);\n\n\treturn ret;\n};\n\nstatic struct platform_driver tegra_ahci_driver = {\n\t.probe = tegra_ahci_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = tegra_ahci_of_match,\n\t},\n\t \n};\nmodule_platform_driver(tegra_ahci_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra AHCI SATA driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}