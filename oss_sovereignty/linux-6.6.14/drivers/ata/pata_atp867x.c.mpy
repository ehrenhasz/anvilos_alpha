{
  "module_name": "pata_atp867x.c",
  "hash_id": "a12d8e2e7de288666aa5292d2de2b4edfed8faf86901d023e9a3cccbf4593a51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_atp867x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define\tDRV_NAME\t\"pata_atp867x\"\n#define\tDRV_VERSION\t\"0.7.5\"\n\n \n\nenum {\n\tATP867X_IO_CHANNEL_OFFSET\t= 0x10,\n\n\t \n\n\tATP867X_IO_PIOSPD_ACTIVE_SHIFT\t= 4,\n\tATP867X_IO_PIOSPD_RECOVER_SHIFT\t= 0,\n\n\tATP867X_IO_DMAMODE_MSTR_SHIFT\t= 0,\n\tATP867X_IO_DMAMODE_MSTR_MASK\t= 0x07,\n\tATP867X_IO_DMAMODE_SLAVE_SHIFT\t= 4,\n\tATP867X_IO_DMAMODE_SLAVE_MASK\t= 0x70,\n\n\tATP867X_IO_DMAMODE_UDMA_6\t= 0x07,\n\tATP867X_IO_DMAMODE_UDMA_5\t= 0x06,\n\tATP867X_IO_DMAMODE_UDMA_4\t= 0x05,\n\tATP867X_IO_DMAMODE_UDMA_3\t= 0x04,\n\tATP867X_IO_DMAMODE_UDMA_2\t= 0x03,\n\tATP867X_IO_DMAMODE_UDMA_1\t= 0x02,\n\tATP867X_IO_DMAMODE_UDMA_0\t= 0x01,\n\tATP867X_IO_DMAMODE_DISABLE\t= 0x00,\n\n\tATP867X_IO_SYS_INFO_66MHZ\t= 0x04,\n\tATP867X_IO_SYS_INFO_SLOW_UDMA5\t= 0x02,\n\tATP867X_IO_SYS_MASK_RESERVED\t= (~0xf1),\n\n\tATP867X_IO_PORTSPD_VAL\t\t= 0x1143,\n\tATP867X_PREREAD_VAL\t\t= 0x0200,\n\n\tATP867X_NUM_PORTS\t\t= 4,\n\tATP867X_BAR_IOBASE\t\t= 0,\n\tATP867X_BAR_ROMBASE\t\t= 6,\n};\n\n#define ATP867X_IOBASE(ap)\t\t((ap)->host->iomap[0])\n#define ATP867X_SYS_INFO(ap)\t\t(0x3F + ATP867X_IOBASE(ap))\n\n#define ATP867X_IO_PORTBASE(ap, port)\t(0x00 + ATP867X_IOBASE(ap) + \\\n\t\t\t\t\t(port) * ATP867X_IO_CHANNEL_OFFSET)\n#define ATP867X_IO_DMABASE(ap, port)\t(0x40 + \\\n\t\t\t\t\tATP867X_IO_PORTBASE((ap), (port)))\n\n#define ATP867X_IO_STATUS(ap, port)\t(0x07 + \\\n\t\t\t\t\tATP867X_IO_PORTBASE((ap), (port)))\n#define ATP867X_IO_ALTSTATUS(ap, port)\t(0x0E + \\\n\t\t\t\t\tATP867X_IO_PORTBASE((ap), (port)))\n\n \n#define ATP867X_IO_MSTRPIOSPD(ap, port)\t(0x08 + \\\n\t\t\t\t\tATP867X_IO_DMABASE((ap), (port)))\n#define ATP867X_IO_SLAVPIOSPD(ap, port)\t(0x09 + \\\n\t\t\t\t\tATP867X_IO_DMABASE((ap), (port)))\n#define ATP867X_IO_8BPIOSPD(ap, port)\t(0x0A + \\\n\t\t\t\t\tATP867X_IO_DMABASE((ap), (port)))\n#define ATP867X_IO_DMAMODE(ap, port)\t(0x0B + \\\n\t\t\t\t\tATP867X_IO_DMABASE((ap), (port)))\n\n#define ATP867X_IO_PORTSPD(ap, port)\t(0x4A + \\\n\t\t\t\t\tATP867X_IO_PORTBASE((ap), (port)))\n#define ATP867X_IO_PREREAD(ap, port)\t(0x4C + \\\n\t\t\t\t\tATP867X_IO_PORTBASE((ap), (port)))\n\nstruct atp867x_priv {\n\tvoid __iomem *dma_mode;\n\tvoid __iomem *mstr_piospd;\n\tvoid __iomem *slave_piospd;\n\tvoid __iomem *eightb_piospd;\n\tint\t\tpci66mhz;\n};\n\nstatic void atp867x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tstruct atp867x_priv *dp = ap->private_data;\n\tu8 speed = adev->dma_mode;\n\tu8 b;\n\tu8 mode = speed - XFER_UDMA_0 + 1;\n\n\t \n\tif (dp->pci66mhz && mode > ATP867X_IO_DMAMODE_UDMA_0  &&\n\t   (pdev->device == PCI_DEVICE_ID_ARTOP_ATP867B ||\n\t    mode < ATP867X_IO_DMAMODE_UDMA_5))\n\t\tmode--;\n\n\tb = ioread8(dp->dma_mode);\n\tif (adev->devno & 1) {\n\t\tb = (b & ~ATP867X_IO_DMAMODE_SLAVE_MASK) |\n\t\t\t(mode << ATP867X_IO_DMAMODE_SLAVE_SHIFT);\n\t} else {\n\t\tb = (b & ~ATP867X_IO_DMAMODE_MSTR_MASK) |\n\t\t\t(mode << ATP867X_IO_DMAMODE_MSTR_SHIFT);\n\t}\n\tiowrite8(b, dp->dma_mode);\n}\n\nstatic int atp867x_get_active_clocks_shifted(struct ata_port *ap,\n\tunsigned int clk)\n{\n\tstruct atp867x_priv *dp = ap->private_data;\n\tunsigned char clocks = clk;\n\n\t \n\tif (dp->pci66mhz)\n\t\tclocks++;\n\n\tswitch (clocks) {\n\tcase 0:\n\t\tclocks = 1;\n\t\tbreak;\n\tcase 1 ... 6:\n\t\tbreak;\n\tdefault:\n\t\tata_port_warn(ap, \"ATP867X: active %dclk is invalid. \"\n\t\t\t\"Using 12clk.\\n\", clk);\n\t\tfallthrough;\n\tcase 9 ... 12:\n\t\tclocks = 7;\t \n\t\tbreak;\n\tcase 7:\n\tcase 8:\t \n\t\tclocks = 0;\n\t\tgoto active_clock_shift_done;\n\t}\n\nactive_clock_shift_done:\n\treturn clocks << ATP867X_IO_PIOSPD_ACTIVE_SHIFT;\n}\n\nstatic int atp867x_get_recover_clocks_shifted(struct ata_port *ap,\n\t\t\t\t\t      unsigned int clk)\n{\n\tunsigned char clocks = clk;\n\n\tswitch (clocks) {\n\tcase 0:\n\t\tclocks = 1;\n\t\tbreak;\n\tcase 1 ... 11:\n\t\tbreak;\n\tcase 13:\n\tcase 14:\n\t\t--clocks;\t \n\t\tbreak;\n\tcase 15:\n\t\tbreak;\n\tdefault:\n\t\tata_port_warn(ap, \"ATP867X: recover %dclk is invalid. \"\n\t\t\t\"Using default 12clk.\\n\", clk);\n\t\tfallthrough;\n\tcase 12:\t \n\t\tclocks = 0;\n\t\tbreak;\n\t}\n\n\treturn clocks << ATP867X_IO_PIOSPD_RECOVER_SHIFT;\n}\n\nstatic void atp867x_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ata_device *peer = ata_dev_pair(adev);\n\tstruct atp867x_priv *dp = ap->private_data;\n\tu8 speed = adev->pio_mode;\n\tstruct ata_timing t, p;\n\tint T, UT;\n\tu8 b;\n\n\tT = 1000000000 / 33333;\n\tUT = T / 4;\n\n\tata_timing_compute(adev, speed, &t, T, UT);\n\tif (peer && peer->pio_mode) {\n\t\tata_timing_compute(peer, peer->pio_mode, &p, T, UT);\n\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_8BIT);\n\t}\n\n\tb = ioread8(dp->dma_mode);\n\tif (adev->devno & 1)\n\t\tb = (b & ~ATP867X_IO_DMAMODE_SLAVE_MASK);\n\telse\n\t\tb = (b & ~ATP867X_IO_DMAMODE_MSTR_MASK);\n\tiowrite8(b, dp->dma_mode);\n\n\tb = atp867x_get_active_clocks_shifted(ap, t.active) |\n\t\tatp867x_get_recover_clocks_shifted(ap, t.recover);\n\n\tif (adev->devno & 1)\n\t\tiowrite8(b, dp->slave_piospd);\n\telse\n\t\tiowrite8(b, dp->mstr_piospd);\n\n\tb = atp867x_get_active_clocks_shifted(ap, t.act8b) |\n\t\tatp867x_get_recover_clocks_shifted(ap, t.rec8b);\n\n\tiowrite8(b, dp->eightb_piospd);\n}\n\nstatic int atp867x_cable_override(struct pci_dev *pdev)\n{\n\tif (pdev->subsystem_vendor == PCI_VENDOR_ID_ARTOP &&\n\t\t(pdev->subsystem_device == PCI_DEVICE_ID_ARTOP_ATP867A ||\n\t\t pdev->subsystem_device == PCI_DEVICE_ID_ARTOP_ATP867B)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int atp867x_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tif (atp867x_cable_override(pdev))\n\t\treturn ATA_CBL_PATA40_SHORT;\n\n\treturn ATA_CBL_PATA_UNK;\n}\n\nstatic const struct scsi_host_template atp867x_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations atp867x_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.cable_detect\t\t= atp867x_cable_detect,\n\t.set_piomode\t\t= atp867x_set_piomode,\n\t.set_dmamode\t\t= atp867x_set_dmamode,\n};\n\n\nstatic void atp867x_check_res(struct pci_dev *pdev)\n{\n\tint i;\n\tunsigned long start, len;\n\n\t \n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstart = pci_resource_start(pdev, i);\n\t\tlen   = pci_resource_len(pdev, i);\n\t\tdev_dbg(&pdev->dev, \"ATP867X: resource start:len=%lx:%lx\\n\",\n\t\t\tstart, len);\n\t}\n}\n\nstatic void atp867x_check_ports(struct ata_port *ap, int port)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tstruct atp867x_priv *dp = ap->private_data;\n\n\tata_port_dbg(ap, \"ATP867X: port[%d] addresses\\n\"\n\t\t\"  cmd_addr\t=0x%lx, 0x%lx\\n\"\n\t\t\"  ctl_addr\t=0x%lx, 0x%lx\\n\"\n\t\t\"  bmdma_addr\t=0x%lx, 0x%lx\\n\"\n\t\t\"  data_addr\t=0x%lx\\n\"\n\t\t\"  error_addr\t=0x%lx\\n\"\n\t\t\"  feature_addr\t=0x%lx\\n\"\n\t\t\"  nsect_addr\t=0x%lx\\n\"\n\t\t\"  lbal_addr\t=0x%lx\\n\"\n\t\t\"  lbam_addr\t=0x%lx\\n\"\n\t\t\"  lbah_addr\t=0x%lx\\n\"\n\t\t\"  device_addr\t=0x%lx\\n\"\n\t\t\"  status_addr\t=0x%lx\\n\"\n\t\t\"  command_addr\t=0x%lx\\n\"\n\t\t\"  dp->dma_mode\t=0x%lx\\n\"\n\t\t\"  dp->mstr_piospd\t=0x%lx\\n\"\n\t\t\"  dp->slave_piospd\t=0x%lx\\n\"\n\t\t\"  dp->eightb_piospd\t=0x%lx\\n\"\n\t\t\"  dp->pci66mhz\t\t=0x%lx\\n\",\n\t\tport,\n\t\t(unsigned long)ioaddr->cmd_addr,\n\t\t(unsigned long)ATP867X_IO_PORTBASE(ap, port),\n\t\t(unsigned long)ioaddr->ctl_addr,\n\t\t(unsigned long)ATP867X_IO_ALTSTATUS(ap, port),\n\t\t(unsigned long)ioaddr->bmdma_addr,\n\t\t(unsigned long)ATP867X_IO_DMABASE(ap, port),\n\t\t(unsigned long)ioaddr->data_addr,\n\t\t(unsigned long)ioaddr->error_addr,\n\t\t(unsigned long)ioaddr->feature_addr,\n\t\t(unsigned long)ioaddr->nsect_addr,\n\t\t(unsigned long)ioaddr->lbal_addr,\n\t\t(unsigned long)ioaddr->lbam_addr,\n\t\t(unsigned long)ioaddr->lbah_addr,\n\t\t(unsigned long)ioaddr->device_addr,\n\t\t(unsigned long)ioaddr->status_addr,\n\t\t(unsigned long)ioaddr->command_addr,\n\t\t(unsigned long)dp->dma_mode,\n\t\t(unsigned long)dp->mstr_piospd,\n\t\t(unsigned long)dp->slave_piospd,\n\t\t(unsigned long)dp->eightb_piospd,\n\t\t(unsigned long)dp->pci66mhz);\n}\n\nstatic int atp867x_set_priv(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct atp867x_priv *dp;\n\tint port = ap->port_no;\n\n\tdp = ap->private_data =\n\t\tdevm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);\n\tif (dp == NULL)\n\t\treturn -ENOMEM;\n\n\tdp->dma_mode\t = ATP867X_IO_DMAMODE(ap, port);\n\tdp->mstr_piospd\t = ATP867X_IO_MSTRPIOSPD(ap, port);\n\tdp->slave_piospd = ATP867X_IO_SLAVPIOSPD(ap, port);\n\tdp->eightb_piospd = ATP867X_IO_8BPIOSPD(ap, port);\n\n\tdp->pci66mhz =\n\t\tioread8(ATP867X_SYS_INFO(ap)) & ATP867X_IO_SYS_INFO_66MHZ;\n\n\treturn 0;\n}\n\nstatic void atp867x_fixup(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tstruct ata_port *ap = host->ports[0];\n\tint i;\n\tu8 v;\n\n\t \n\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &v);\n\tif (v < 0x80) {\n\t\tv = 0x80;\n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, v);\n\t\tdev_dbg(&pdev->dev, \"ATP867X: set latency timer to %d\\n\", v);\n\t}\n\n\t \n\tfor (i = 0; i < ATP867X_NUM_PORTS; i++)\n\t\tiowrite16(ATP867X_IO_PORTSPD_VAL, ATP867X_IO_PORTSPD(ap, i));\n\n\t \n\tfor (i = 0; i < ATP867X_NUM_PORTS; i++)\n\t\tiowrite16(ATP867X_PREREAD_VAL, ATP867X_IO_PREREAD(ap, i));\n\n\tv = ioread8(ATP867X_IOBASE(ap) + 0x28);\n\tv &= 0xcf;\t \n\tv |= 0xc0;\t \n\tiowrite8(v, ATP867X_IOBASE(ap) + 0x28);\n\n\t \n\tv = ioread8(ATP867X_SYS_INFO(ap));\n\tv &= ATP867X_IO_SYS_MASK_RESERVED;\n\tif (pdev->device == PCI_DEVICE_ID_ARTOP_ATP867B)\n\t\tv |= ATP867X_IO_SYS_INFO_SLOW_UDMA5;\n\tiowrite8(v, ATP867X_SYS_INFO(ap));\n}\n\nstatic int atp867x_ata_pci_sff_init_host(struct ata_host *host)\n{\n\tstruct device *gdev = host->dev;\n\tstruct pci_dev *pdev = to_pci_dev(gdev);\n\tunsigned int mask = 0;\n\tint i, rc;\n\n\t \n\trc = pcim_iomap_regions(pdev, 1 << ATP867X_BAR_IOBASE, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\tatp867x_check_res(pdev);\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++)\n\t\tdev_dbg(gdev, \"ATP867X: iomap[%d]=0x%p\\n\", i,\n\t\t\thost->iomap[i]);\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\t\tioaddr->cmd_addr = ATP867X_IO_PORTBASE(ap, i);\n\t\tioaddr->ctl_addr = ioaddr->altstatus_addr\n\t\t\t\t = ATP867X_IO_ALTSTATUS(ap, i);\n\t\tioaddr->bmdma_addr = ATP867X_IO_DMABASE(ap, i);\n\n\t\tata_sff_std_ports(ioaddr);\n\t\trc = atp867x_set_priv(ap);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tatp867x_check_ports(ap, i);\n\n\t\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\",\n\t\t\t(unsigned long)ioaddr->cmd_addr,\n\t\t\t(unsigned long)ioaddr->ctl_addr);\n\t\tata_port_desc(ap, \"bmdma 0x%lx\",\n\t\t\t(unsigned long)ioaddr->bmdma_addr);\n\n\t\tmask |= 1 << i;\n\t}\n\n\tif (!mask) {\n\t\tdev_err(gdev, \"no available native port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tatp867x_fixup(host);\n\n\treturn dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n}\n\nstatic int atp867x_init_one(struct pci_dev *pdev,\n\tconst struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info_867x = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask \t= ATA_UDMA6,\n\t\t.port_ops\t= &atp867x_ops,\n\t};\n\n\tstruct ata_host *host;\n\tconst struct ata_port_info *ppi[] = { &info_867x, NULL };\n\tint rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_info(&pdev->dev, \"ATP867X: ATP867 ATA UDMA133 controller (rev %02X)\",\n\t\tpdev->device);\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, ATP867X_NUM_PORTS);\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"failed to allocate ATA host\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\trc = atp867x_ata_pci_sff_init_host(host);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to init host\\n\");\n\t\tgoto err_out;\n\t}\n\n\tpci_set_master(pdev);\n\n\trc = ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\tIRQF_SHARED, &atp867x_sht);\n\tif (rc)\n\t\tdev_err(&pdev->dev, \"failed to activate host\\n\");\n\nerr_out:\n\treturn rc;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atp867x_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tatp867x_fixup(host);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic struct pci_device_id atp867x_pci_tbl[] = {\n\t{ PCI_VDEVICE(ARTOP, PCI_DEVICE_ID_ARTOP_ATP867A),\t0 },\n\t{ PCI_VDEVICE(ARTOP, PCI_DEVICE_ID_ARTOP_ATP867B),\t0 },\n\t{ },\n};\n\nstatic struct pci_driver atp867x_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table \t= atp867x_pci_tbl,\n\t.probe \t\t= atp867x_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= atp867x_reinit_one,\n#endif\n};\n\nmodule_pci_driver(atp867x_driver);\n\nMODULE_AUTHOR(\"John(Jung-Ik) Lee, Google Inc.\");\nMODULE_DESCRIPTION(\"low level driver for Artop/Acard 867x ATA controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, atp867x_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}