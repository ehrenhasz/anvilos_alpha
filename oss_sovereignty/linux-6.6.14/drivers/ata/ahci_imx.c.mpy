{
  "module_name": "ahci_imx.c",
  "hash_id": "fe8cb90ca57993135456ff2b9145fec89bf62b9725ce37683bb71aeaf918a6e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_imx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/ahci_platform.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n#include <linux/libata.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/thermal.h>\n#include \"ahci.h\"\n\n#define DRV_NAME \"ahci-imx\"\n\nenum {\n\t \n\tIMX_TIMER1MS\t\t\t\t= 0x00e0,\n\t \n\tIMX_P0PHYCR\t\t\t\t= 0x0178,\n\tIMX_P0PHYCR_TEST_PDDQ\t\t\t= 1 << 20,\n\tIMX_P0PHYCR_CR_READ\t\t\t= 1 << 19,\n\tIMX_P0PHYCR_CR_WRITE\t\t\t= 1 << 18,\n\tIMX_P0PHYCR_CR_CAP_DATA\t\t\t= 1 << 17,\n\tIMX_P0PHYCR_CR_CAP_ADDR\t\t\t= 1 << 16,\n\t \n\tIMX_P0PHYSR\t\t\t\t= 0x017c,\n\tIMX_P0PHYSR_CR_ACK\t\t\t= 1 << 18,\n\tIMX_P0PHYSR_CR_DATA_OUT\t\t\t= 0xffff << 0,\n\t \n\tIMX_LANE0_OUT_STAT\t\t\t= 0x2003,\n\tIMX_LANE0_OUT_STAT_RX_PLL_STATE\t\t= 1 << 1,\n\t \n\tIMX_CLOCK_RESET\t\t\t\t= 0x7f3f,\n\tIMX_CLOCK_RESET_RESET\t\t\t= 1 << 0,\n\t \n\tIMX8QM_SATA_PHY_RX_IMPED_RATIO_OFFSET\t= 0x03,\n\tIMX8QM_SATA_PHY_TX_IMPED_RATIO_OFFSET\t= 0x09,\n\tIMX8QM_SATA_PHY_IMPED_RATIO_85OHM\t= 0x6c,\n\tIMX8QM_LPCG_PHYX2_OFFSET\t\t= 0x00000,\n\tIMX8QM_CSR_PHYX2_OFFSET\t\t\t= 0x90000,\n\tIMX8QM_CSR_PHYX1_OFFSET\t\t\t= 0xa0000,\n\tIMX8QM_CSR_PHYX_STTS0_OFFSET\t\t= 0x4,\n\tIMX8QM_CSR_PCIEA_OFFSET\t\t\t= 0xb0000,\n\tIMX8QM_CSR_PCIEB_OFFSET\t\t\t= 0xc0000,\n\tIMX8QM_CSR_SATA_OFFSET\t\t\t= 0xd0000,\n\tIMX8QM_CSR_PCIE_CTRL2_OFFSET\t\t= 0x8,\n\tIMX8QM_CSR_MISC_OFFSET\t\t\t= 0xe0000,\n\n\tIMX8QM_LPCG_PHYX2_PCLK0_MASK\t\t= (0x3 << 16),\n\tIMX8QM_LPCG_PHYX2_PCLK1_MASK\t\t= (0x3 << 20),\n\tIMX8QM_PHY_APB_RSTN_0\t\t\t= BIT(0),\n\tIMX8QM_PHY_MODE_SATA\t\t\t= BIT(19),\n\tIMX8QM_PHY_MODE_MASK\t\t\t= (0xf << 17),\n\tIMX8QM_PHY_PIPE_RSTN_0\t\t\t= BIT(24),\n\tIMX8QM_PHY_PIPE_RSTN_OVERRIDE_0\t\t= BIT(25),\n\tIMX8QM_PHY_PIPE_RSTN_1\t\t\t= BIT(26),\n\tIMX8QM_PHY_PIPE_RSTN_OVERRIDE_1\t\t= BIT(27),\n\tIMX8QM_STTS0_LANE0_TX_PLL_LOCK\t\t= BIT(4),\n\tIMX8QM_MISC_IOB_RXENA\t\t\t= BIT(0),\n\tIMX8QM_MISC_IOB_TXENA\t\t\t= BIT(1),\n\tIMX8QM_MISC_PHYX1_EPCS_SEL\t\t= BIT(12),\n\tIMX8QM_MISC_CLKREQN_OUT_OVERRIDE_1\t= BIT(24),\n\tIMX8QM_MISC_CLKREQN_OUT_OVERRIDE_0\t= BIT(25),\n\tIMX8QM_MISC_CLKREQN_IN_OVERRIDE_1\t= BIT(28),\n\tIMX8QM_MISC_CLKREQN_IN_OVERRIDE_0\t= BIT(29),\n\tIMX8QM_SATA_CTRL_RESET_N\t\t= BIT(12),\n\tIMX8QM_SATA_CTRL_EPCS_PHYRESET_N\t= BIT(7),\n\tIMX8QM_CTRL_BUTTON_RST_N\t\t= BIT(21),\n\tIMX8QM_CTRL_POWER_UP_RST_N\t\t= BIT(23),\n\tIMX8QM_CTRL_LTSSM_ENABLE\t\t= BIT(4),\n};\n\nenum ahci_imx_type {\n\tAHCI_IMX53,\n\tAHCI_IMX6Q,\n\tAHCI_IMX6QP,\n\tAHCI_IMX8QM,\n};\n\nstruct imx_ahci_priv {\n\tstruct platform_device *ahci_pdev;\n\tenum ahci_imx_type type;\n\tstruct clk *sata_clk;\n\tstruct clk *sata_ref_clk;\n\tstruct clk *ahb_clk;\n\tstruct clk *epcs_tx_clk;\n\tstruct clk *epcs_rx_clk;\n\tstruct clk *phy_apbclk;\n\tstruct clk *phy_pclk0;\n\tstruct clk *phy_pclk1;\n\tvoid __iomem *phy_base;\n\tstruct gpio_desc *clkreq_gpiod;\n\tstruct regmap *gpr;\n\tbool no_device;\n\tbool first_time;\n\tu32 phy_params;\n\tu32 imped_ratio;\n};\n\nstatic int ahci_imx_hotplug;\nmodule_param_named(hotplug, ahci_imx_hotplug, int, 0644);\nMODULE_PARM_DESC(hotplug, \"AHCI IMX hot-plug support (0=Don't support, 1=support)\");\n\nstatic void ahci_imx_host_stop(struct ata_host *host);\n\nstatic int imx_phy_crbit_assert(void __iomem *mmio, u32 bit, bool assert)\n{\n\tint timeout = 10;\n\tu32 crval;\n\tu32 srval;\n\n\t \n\tcrval = readl(mmio + IMX_P0PHYCR);\n\tif (assert)\n\t\tcrval |= bit;\n\telse\n\t\tcrval &= ~bit;\n\twritel(crval, mmio + IMX_P0PHYCR);\n\n\t \n\tdo {\n\t\tsrval = readl(mmio + IMX_P0PHYSR);\n\t\tif ((assert ? srval : ~srval) & IMX_P0PHYSR_CR_ACK)\n\t\t\tbreak;\n\t\tusleep_range(100, 200);\n\t} while (--timeout);\n\n\treturn timeout ? 0 : -ETIMEDOUT;\n}\n\nstatic int imx_phy_reg_addressing(u16 addr, void __iomem *mmio)\n{\n\tu32 crval = addr;\n\tint ret;\n\n\t \n\twritel(crval, mmio + IMX_P0PHYCR);\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_ADDR, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_ADDR, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int imx_phy_reg_write(u16 val, void __iomem *mmio)\n{\n\tu32 crval = val;\n\tint ret;\n\n\t \n\twritel(crval, mmio + IMX_P0PHYCR);\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_DATA, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_DATA, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & IMX_CLOCK_RESET_RESET) {\n\t\t \n\t\tcrval |= IMX_P0PHYCR_CR_WRITE;\n\t\twritel(crval, mmio + IMX_P0PHYCR);\n\t\tgoto out;\n\t}\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_WRITE, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_WRITE, false);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\treturn 0;\n}\n\nstatic int imx_phy_reg_read(u16 *val, void __iomem *mmio)\n{\n\tint ret;\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_READ, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*val = readl(mmio + IMX_P0PHYSR) & IMX_P0PHYSR_CR_DATA_OUT;\n\n\t \n\tret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_READ, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int imx_sata_phy_reset(struct ahci_host_priv *hpriv)\n{\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tint timeout = 10;\n\tu16 val;\n\tint ret;\n\n\tif (imxpriv->type == AHCI_IMX6QP) {\n\t\t \n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR5,\n\t\t\t\t   IMX6Q_GPR5_SATA_SW_PD, 0);\n\n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR5,\n\t\t\t\t   IMX6Q_GPR5_SATA_SW_RST, 0);\n\t\tudelay(50);\n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR5,\n\t\t\t\t   IMX6Q_GPR5_SATA_SW_RST,\n\t\t\t\t   IMX6Q_GPR5_SATA_SW_RST);\n\t\treturn 0;\n\t}\n\n\t \n\tret = imx_phy_reg_addressing(IMX_CLOCK_RESET, mmio);\n\tif (ret)\n\t\treturn ret;\n\tret = imx_phy_reg_write(IMX_CLOCK_RESET_RESET, mmio);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\tusleep_range(100, 200);\n\t\tret = imx_phy_reg_addressing(IMX_LANE0_OUT_STAT, mmio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx_phy_reg_read(&val, mmio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (val & IMX_LANE0_OUT_STAT_RX_PLL_STATE)\n\t\t\tbreak;\n\t} while (--timeout);\n\n\treturn timeout ? 0 : -ETIMEDOUT;\n}\n\nenum {\n\t \n\tSATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT = 0x0001,\n\tSATA_PHY_CR_CLOCK_DAC_CTL = 0x0008,\n\tSATA_PHY_CR_CLOCK_RTUNE_CTL = 0x0009,\n\tSATA_PHY_CR_CLOCK_ADC_OUT = 0x000A,\n\tSATA_PHY_CR_CLOCK_MPLL_TST = 0x0017,\n};\n\nstatic int read_adc_sum(void *dev, u16 rtune_ctl_reg, void __iomem * mmio)\n{\n\tu16 adc_out_reg, read_sum;\n\tu32 index, read_attempt;\n\tconst u32 attempt_limit = 200;\n\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_RTUNE_CTL, mmio);\n\timx_phy_reg_write(rtune_ctl_reg, mmio);\n\n\t \n\tindex = 0;\n\tread_attempt = 0;\n\tadc_out_reg = 0;\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_ADC_OUT, mmio);\n\twhile (index < 2) {\n\t\timx_phy_reg_read(&adc_out_reg, mmio);\n\t\t \n\t\tif (adc_out_reg & 0x400)\n\t\t\tindex++;\n\n\t\tread_attempt++;\n\t\tif (read_attempt > attempt_limit) {\n\t\t\tdev_err(dev, \"Read REG more than %d times!\\n\",\n\t\t\t\tattempt_limit);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tindex = 0;\n\tread_attempt = 0;\n\tread_sum = 0;\n\twhile (index < 80) {\n\t\timx_phy_reg_read(&adc_out_reg, mmio);\n\t\tif (adc_out_reg & 0x400) {\n\t\t\tread_sum = read_sum + (adc_out_reg & 0x3FF);\n\t\t\tindex++;\n\t\t}\n\t\tread_attempt++;\n\t\tif (read_attempt > attempt_limit) {\n\t\t\tdev_err(dev, \"Read REG more than %d times!\\n\",\n\t\t\t\tattempt_limit);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn (read_sum * 1000) / 80;\n}\n\n \nstatic int __sata_ahci_read_temperature(void *dev, int *temp)\n{\n\tu16 mpll_test_reg, rtune_ctl_reg, dac_ctl_reg, read_sum;\n\tu32 str1, str2, str3, str4;\n\tint m1, m2, a;\n\tstruct ahci_host_priv *hpriv = dev_get_drvdata(dev);\n\tvoid __iomem *mmio = hpriv->mmio;\n\n\t \n\tread_sum = 0;\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT, mmio);\n\timx_phy_reg_write(read_sum, mmio);\n\timx_phy_reg_read(&read_sum, mmio);\n\tif ((read_sum & 0xffff) != 0)\n\t\tdev_err(dev, \"Read/Write REG error, 0x%x!\\n\", read_sum);\n\n\timx_phy_reg_write(0x5A5A, mmio);\n\timx_phy_reg_read(&read_sum, mmio);\n\tif ((read_sum & 0xffff) != 0x5A5A)\n\t\tdev_err(dev, \"Read/Write REG error, 0x%x!\\n\", read_sum);\n\n\timx_phy_reg_write(0x1234, mmio);\n\timx_phy_reg_read(&read_sum, mmio);\n\tif ((read_sum & 0xffff) != 0x1234)\n\t\tdev_err(dev, \"Read/Write REG error, 0x%x!\\n\", read_sum);\n\n\t \n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_MPLL_TST, mmio);\n\timx_phy_reg_read(&mpll_test_reg, mmio);\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_RTUNE_CTL, mmio);\n\timx_phy_reg_read(&rtune_ctl_reg, mmio);\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_DAC_CTL, mmio);\n\timx_phy_reg_read(&dac_ctl_reg, mmio);\n\n\t \n\tstr1 = (mpll_test_reg >> 2) & 0x7FF;\n\t \n\tstr2 = (rtune_ctl_reg) & 0x3;\n\t \n\tstr3 = (dac_ctl_reg >> 12)  & 0x7;\n\t \n\tstr4 = (rtune_ctl_reg >> 4);\n\n\t \n\t \n\tmpll_test_reg = (mpll_test_reg & 0xE03) | (512) << 2;\n\t \n\trtune_ctl_reg = (rtune_ctl_reg & 0xFFC) | (1);\n\t \n\tdac_ctl_reg = (dac_ctl_reg & 0x8FF) | (4) << 12;\n\t \n\trtune_ctl_reg = (rtune_ctl_reg & 0xFEF) | (0) << 4;\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_MPLL_TST, mmio);\n\timx_phy_reg_write(mpll_test_reg, mmio);\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_DAC_CTL, mmio);\n\timx_phy_reg_write(dac_ctl_reg, mmio);\n\tm1 = read_adc_sum(dev, rtune_ctl_reg, mmio);\n\n\t \n\t \n\trtune_ctl_reg = (rtune_ctl_reg & 0xFEF) | (1) << 4;\n\tm2 = read_adc_sum(dev, rtune_ctl_reg, mmio);\n\n\t \n\t \n\tmpll_test_reg = (mpll_test_reg & 0xE03) | (str1) << 2;\n\t \n\trtune_ctl_reg = (rtune_ctl_reg & 0xFFC) | (str2);\n\t \n\tdac_ctl_reg = (dac_ctl_reg & 0x8FF) | (str3) << 12;\n\t \n\trtune_ctl_reg = (rtune_ctl_reg & 0xFEF) | (str4) << 4;\n\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_MPLL_TST, mmio);\n\timx_phy_reg_write(mpll_test_reg, mmio);\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_DAC_CTL, mmio);\n\timx_phy_reg_write(dac_ctl_reg, mmio);\n\timx_phy_reg_addressing(SATA_PHY_CR_CLOCK_RTUNE_CTL, mmio);\n\timx_phy_reg_write(rtune_ctl_reg, mmio);\n\n\t \n\tif (!(m2 / 1000))\n\t\tm2 = 1000;\n\ta = (m2 - m1) / (m2/1000);\n\t*temp = ((-559) * a * a) / 1000 + (1379) * a + (-458000);\n\n\treturn 0;\n}\n\nstatic int sata_ahci_read_temperature(struct thermal_zone_device *tz, int *temp)\n{\n\treturn __sata_ahci_read_temperature(thermal_zone_device_priv(tz), temp);\n}\n\nstatic ssize_t sata_ahci_show_temp(struct device *dev,\n\t\t\t\t   struct device_attribute *da,\n\t\t\t\t   char *buf)\n{\n\tunsigned int temp = 0;\n\tint err;\n\n\terr = __sata_ahci_read_temperature(dev, &temp);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%u\\n\", temp);\n}\n\nstatic const struct thermal_zone_device_ops fsl_sata_ahci_of_thermal_ops = {\n\t.get_temp = sata_ahci_read_temperature,\n};\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, sata_ahci_show_temp, NULL, 0);\n\nstatic struct attribute *fsl_sata_ahci_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(fsl_sata_ahci);\n\nstatic int imx8_sata_enable(struct ahci_host_priv *hpriv)\n{\n\tu32 val, reg;\n\tint i, ret;\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\tstruct device *dev = &imxpriv->ahci_pdev->dev;\n\n\t \n\tret = clk_prepare_enable(imxpriv->phy_pclk0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't enable phy_pclk0.\\n\");\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(imxpriv->phy_pclk1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't enable phy_pclk1.\\n\");\n\t\tgoto disable_phy_pclk0;\n\t}\n\tret = clk_prepare_enable(imxpriv->epcs_tx_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't enable epcs_tx_clk.\\n\");\n\t\tgoto disable_phy_pclk1;\n\t}\n\tret = clk_prepare_enable(imxpriv->epcs_rx_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't enable epcs_rx_clk.\\n\");\n\t\tgoto disable_epcs_tx_clk;\n\t}\n\tret = clk_prepare_enable(imxpriv->phy_apbclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't enable phy_apbclk.\\n\");\n\t\tgoto disable_epcs_rx_clk;\n\t}\n\t \n\tregmap_read(imxpriv->gpr, IMX8QM_CSR_PCIEA_OFFSET +\n\t\t\tIMX8QM_CSR_PCIE_CTRL2_OFFSET, &val);\n\tif ((val & IMX8QM_CTRL_LTSSM_ENABLE) == 0) {\n\t\t \n\t\tregmap_update_bits(imxpriv->gpr,\n\t\t\t\tIMX8QM_CSR_PHYX2_OFFSET,\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_0 |\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_OVERRIDE_0,\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_0 |\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_OVERRIDE_0);\n\t}\n\tregmap_read(imxpriv->gpr, IMX8QM_CSR_PCIEB_OFFSET +\n\t\t\tIMX8QM_CSR_PCIE_CTRL2_OFFSET, &reg);\n\tif ((reg & IMX8QM_CTRL_LTSSM_ENABLE) == 0) {\n\t\t \n\t\tregmap_update_bits(imxpriv->gpr,\n\t\t\t\tIMX8QM_CSR_PHYX2_OFFSET,\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_1 |\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_OVERRIDE_1,\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_1 |\n\t\t\t\tIMX8QM_PHY_PIPE_RSTN_OVERRIDE_1);\n\t}\n\tif (((reg | val) & IMX8QM_CTRL_LTSSM_ENABLE) == 0) {\n\t\t \n\t\tregmap_update_bits(imxpriv->gpr,\n\t\t\t\tIMX8QM_LPCG_PHYX2_OFFSET,\n\t\t\t\tIMX8QM_LPCG_PHYX2_PCLK0_MASK |\n\t\t\t\tIMX8QM_LPCG_PHYX2_PCLK1_MASK,\n\t\t\t\t0);\n\t}\n\n\t \n\tval = IMX8QM_CSR_PCIEA_OFFSET + IMX8QM_CSR_PCIE_CTRL2_OFFSET;\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tval,\n\t\t\tIMX8QM_CTRL_BUTTON_RST_N,\n\t\t\tIMX8QM_CTRL_BUTTON_RST_N);\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tval,\n\t\t\tIMX8QM_CTRL_POWER_UP_RST_N,\n\t\t\tIMX8QM_CTRL_POWER_UP_RST_N);\n\n\t \n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_PHYX1_OFFSET,\n\t\t\tIMX8QM_PHY_MODE_MASK,\n\t\t\tIMX8QM_PHY_MODE_SATA);\n\n\t \n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_MISC_OFFSET,\n\t\t\tIMX8QM_MISC_IOB_RXENA,\n\t\t\tIMX8QM_MISC_IOB_RXENA);\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_MISC_OFFSET,\n\t\t\tIMX8QM_MISC_IOB_TXENA,\n\t\t\t0);\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_MISC_OFFSET,\n\t\t\tIMX8QM_MISC_PHYX1_EPCS_SEL,\n\t\t\tIMX8QM_MISC_PHYX1_EPCS_SEL);\n\t \n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_MISC_OFFSET,\n\t\t\tIMX8QM_MISC_CLKREQN_OUT_OVERRIDE_1 |\n\t\t\tIMX8QM_MISC_CLKREQN_OUT_OVERRIDE_0 |\n\t\t\tIMX8QM_MISC_CLKREQN_IN_OVERRIDE_1 |\n\t\t\tIMX8QM_MISC_CLKREQN_IN_OVERRIDE_0,\n\t\t\tIMX8QM_MISC_CLKREQN_OUT_OVERRIDE_1 |\n\t\t\tIMX8QM_MISC_CLKREQN_OUT_OVERRIDE_0 |\n\t\t\tIMX8QM_MISC_CLKREQN_IN_OVERRIDE_1 |\n\t\t\tIMX8QM_MISC_CLKREQN_IN_OVERRIDE_0);\n\n\t \n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_SATA_OFFSET,\n\t\t\tIMX8QM_SATA_CTRL_EPCS_PHYRESET_N,\n\t\t\t0);\n\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_SATA_OFFSET,\n\t\t\tIMX8QM_SATA_CTRL_EPCS_PHYRESET_N,\n\t\t\tIMX8QM_SATA_CTRL_EPCS_PHYRESET_N);\n\n\t \n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_SATA_OFFSET,\n\t\t\tIMX8QM_SATA_CTRL_RESET_N,\n\t\t\tIMX8QM_SATA_CTRL_RESET_N);\n\tudelay(1);\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_SATA_OFFSET,\n\t\t\tIMX8QM_SATA_CTRL_RESET_N,\n\t\t\t0);\n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_SATA_OFFSET,\n\t\t\tIMX8QM_SATA_CTRL_RESET_N,\n\t\t\tIMX8QM_SATA_CTRL_RESET_N);\n\n\t \n\tregmap_update_bits(imxpriv->gpr,\n\t\t\tIMX8QM_CSR_PHYX1_OFFSET,\n\t\t\tIMX8QM_PHY_APB_RSTN_0,\n\t\t\tIMX8QM_PHY_APB_RSTN_0);\n\n\tfor (i = 0; i < 100; i++) {\n\t\treg = IMX8QM_CSR_PHYX1_OFFSET +\n\t\t\tIMX8QM_CSR_PHYX_STTS0_OFFSET;\n\t\tregmap_read(imxpriv->gpr, reg, &val);\n\t\tval &= IMX8QM_STTS0_LANE0_TX_PLL_LOCK;\n\t\tif (val == IMX8QM_STTS0_LANE0_TX_PLL_LOCK)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (val != IMX8QM_STTS0_LANE0_TX_PLL_LOCK) {\n\t\tdev_err(dev, \"TX PLL of the PHY is not locked\\n\");\n\t\tret = -ENODEV;\n\t} else {\n\t\twriteb(imxpriv->imped_ratio, imxpriv->phy_base +\n\t\t\t\tIMX8QM_SATA_PHY_RX_IMPED_RATIO_OFFSET);\n\t\twriteb(imxpriv->imped_ratio, imxpriv->phy_base +\n\t\t\t\tIMX8QM_SATA_PHY_TX_IMPED_RATIO_OFFSET);\n\t\treg = readb(imxpriv->phy_base +\n\t\t\t\tIMX8QM_SATA_PHY_RX_IMPED_RATIO_OFFSET);\n\t\tif (unlikely(reg != imxpriv->imped_ratio))\n\t\t\tdev_info(dev, \"Can't set PHY RX impedance ratio.\\n\");\n\t\treg = readb(imxpriv->phy_base +\n\t\t\t\tIMX8QM_SATA_PHY_TX_IMPED_RATIO_OFFSET);\n\t\tif (unlikely(reg != imxpriv->imped_ratio))\n\t\t\tdev_info(dev, \"Can't set PHY TX impedance ratio.\\n\");\n\t\tusleep_range(50, 100);\n\n\t\t \n\t\tclk_disable_unprepare(imxpriv->phy_apbclk);\n\t\tclk_disable_unprepare(imxpriv->phy_pclk1);\n\t\tclk_disable_unprepare(imxpriv->phy_pclk0);\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(imxpriv->phy_apbclk);\ndisable_epcs_rx_clk:\n\tclk_disable_unprepare(imxpriv->epcs_rx_clk);\ndisable_epcs_tx_clk:\n\tclk_disable_unprepare(imxpriv->epcs_tx_clk);\ndisable_phy_pclk1:\n\tclk_disable_unprepare(imxpriv->phy_pclk1);\ndisable_phy_pclk0:\n\tclk_disable_unprepare(imxpriv->phy_pclk0);\n\n\treturn ret;\n}\n\nstatic int imx_sata_enable(struct ahci_host_priv *hpriv)\n{\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\tstruct device *dev = &imxpriv->ahci_pdev->dev;\n\tint ret;\n\n\tif (imxpriv->no_device)\n\t\treturn 0;\n\n\tret = ahci_platform_enable_regulators(hpriv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(imxpriv->sata_ref_clk);\n\tif (ret < 0)\n\t\tgoto disable_regulator;\n\n\tif (imxpriv->type == AHCI_IMX6Q || imxpriv->type == AHCI_IMX6QP) {\n\t\t \n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\n\t\t\t\t   IMX6Q_GPR13_SATA_RX_EQ_VAL_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_RX_LOS_LVL_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_RX_DPLL_MODE_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_SPD_MODE_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_MPLL_SS_EN |\n\t\t\t\t   IMX6Q_GPR13_SATA_TX_ATTEN_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_TX_BOOST_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_TX_LVL_MASK |\n\t\t\t\t   IMX6Q_GPR13_SATA_MPLL_CLK_EN |\n\t\t\t\t   IMX6Q_GPR13_SATA_TX_EDGE_RATE,\n\t\t\t\t   imxpriv->phy_params);\n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\n\t\t\t\t   IMX6Q_GPR13_SATA_MPLL_CLK_EN,\n\t\t\t\t   IMX6Q_GPR13_SATA_MPLL_CLK_EN);\n\n\t\tusleep_range(100, 200);\n\n\t\tret = imx_sata_phy_reset(hpriv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to reset phy: %d\\n\", ret);\n\t\t\tgoto disable_clk;\n\t\t}\n\t} else if (imxpriv->type == AHCI_IMX8QM) {\n\t\tret = imx8_sata_enable(hpriv);\n\t}\n\n\tusleep_range(1000, 2000);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(imxpriv->sata_ref_clk);\ndisable_regulator:\n\tahci_platform_disable_regulators(hpriv);\n\n\treturn ret;\n}\n\nstatic void imx_sata_disable(struct ahci_host_priv *hpriv)\n{\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\n\tif (imxpriv->no_device)\n\t\treturn;\n\n\tswitch (imxpriv->type) {\n\tcase AHCI_IMX6QP:\n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR5,\n\t\t\t\t   IMX6Q_GPR5_SATA_SW_PD,\n\t\t\t\t   IMX6Q_GPR5_SATA_SW_PD);\n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\n\t\t\t\t   IMX6Q_GPR13_SATA_MPLL_CLK_EN,\n\t\t\t\t   !IMX6Q_GPR13_SATA_MPLL_CLK_EN);\n\t\tbreak;\n\n\tcase AHCI_IMX6Q:\n\t\tregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\n\t\t\t\t   IMX6Q_GPR13_SATA_MPLL_CLK_EN,\n\t\t\t\t   !IMX6Q_GPR13_SATA_MPLL_CLK_EN);\n\t\tbreak;\n\n\tcase AHCI_IMX8QM:\n\t\tclk_disable_unprepare(imxpriv->epcs_rx_clk);\n\t\tclk_disable_unprepare(imxpriv->epcs_tx_clk);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclk_disable_unprepare(imxpriv->sata_ref_clk);\n\n\tahci_platform_disable_regulators(hpriv);\n}\n\nstatic void ahci_imx_error_handler(struct ata_port *ap)\n{\n\tu32 reg_val;\n\tstruct ata_device *dev;\n\tstruct ata_host *host = dev_get_drvdata(ap->dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\n\tahci_error_handler(ap);\n\n\tif (!(imxpriv->first_time) || ahci_imx_hotplug)\n\t\treturn;\n\n\timxpriv->first_time = false;\n\n\tata_for_each_dev(dev, &ap->link, ENABLED)\n\t\treturn;\n\t \n\treg_val = readl(mmio + IMX_P0PHYCR);\n\twritel(reg_val | IMX_P0PHYCR_TEST_PDDQ, mmio + IMX_P0PHYCR);\n\timx_sata_disable(hpriv);\n\timxpriv->no_device = true;\n\n\tdev_info(ap->dev, \"no device found, disabling link.\\n\");\n\tdev_info(ap->dev, \"pass \" MODULE_PARAM_PREFIX \".hotplug=1 to enable hotplug\\n\");\n}\n\nstatic int ahci_imx_softreset(struct ata_link *link, unsigned int *class,\n\t\t       unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_host *host = dev_get_drvdata(ap->dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\tint ret;\n\n\tif (imxpriv->type == AHCI_IMX53)\n\t\tret = ahci_pmp_retry_srst_ops.softreset(link, class, deadline);\n\telse\n\t\tret = ahci_ops.softreset(link, class, deadline);\n\n\treturn ret;\n}\n\nstatic struct ata_port_operations ahci_imx_ops = {\n\t.inherits\t= &ahci_ops,\n\t.host_stop\t= ahci_imx_host_stop,\n\t.error_handler\t= ahci_imx_error_handler,\n\t.softreset\t= ahci_imx_softreset,\n};\n\nstatic const struct ata_port_info ahci_imx_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_imx_ops,\n};\n\nstatic const struct of_device_id imx_ahci_of_match[] = {\n\t{ .compatible = \"fsl,imx53-ahci\", .data = (void *)AHCI_IMX53 },\n\t{ .compatible = \"fsl,imx6q-ahci\", .data = (void *)AHCI_IMX6Q },\n\t{ .compatible = \"fsl,imx6qp-ahci\", .data = (void *)AHCI_IMX6QP },\n\t{ .compatible = \"fsl,imx8qm-ahci\", .data = (void *)AHCI_IMX8QM },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_ahci_of_match);\n\nstruct reg_value {\n\tu32 of_value;\n\tu32 reg_value;\n};\n\nstruct reg_property {\n\tconst char *name;\n\tconst struct reg_value *values;\n\tsize_t num_values;\n\tu32 def_value;\n\tu32 set_value;\n};\n\nstatic const struct reg_value gpr13_tx_level[] = {\n\t{  937, IMX6Q_GPR13_SATA_TX_LVL_0_937_V },\n\t{  947, IMX6Q_GPR13_SATA_TX_LVL_0_947_V },\n\t{  957, IMX6Q_GPR13_SATA_TX_LVL_0_957_V },\n\t{  966, IMX6Q_GPR13_SATA_TX_LVL_0_966_V },\n\t{  976, IMX6Q_GPR13_SATA_TX_LVL_0_976_V },\n\t{  986, IMX6Q_GPR13_SATA_TX_LVL_0_986_V },\n\t{  996, IMX6Q_GPR13_SATA_TX_LVL_0_996_V },\n\t{ 1005, IMX6Q_GPR13_SATA_TX_LVL_1_005_V },\n\t{ 1015, IMX6Q_GPR13_SATA_TX_LVL_1_015_V },\n\t{ 1025, IMX6Q_GPR13_SATA_TX_LVL_1_025_V },\n\t{ 1035, IMX6Q_GPR13_SATA_TX_LVL_1_035_V },\n\t{ 1045, IMX6Q_GPR13_SATA_TX_LVL_1_045_V },\n\t{ 1054, IMX6Q_GPR13_SATA_TX_LVL_1_054_V },\n\t{ 1064, IMX6Q_GPR13_SATA_TX_LVL_1_064_V },\n\t{ 1074, IMX6Q_GPR13_SATA_TX_LVL_1_074_V },\n\t{ 1084, IMX6Q_GPR13_SATA_TX_LVL_1_084_V },\n\t{ 1094, IMX6Q_GPR13_SATA_TX_LVL_1_094_V },\n\t{ 1104, IMX6Q_GPR13_SATA_TX_LVL_1_104_V },\n\t{ 1113, IMX6Q_GPR13_SATA_TX_LVL_1_113_V },\n\t{ 1123, IMX6Q_GPR13_SATA_TX_LVL_1_123_V },\n\t{ 1133, IMX6Q_GPR13_SATA_TX_LVL_1_133_V },\n\t{ 1143, IMX6Q_GPR13_SATA_TX_LVL_1_143_V },\n\t{ 1152, IMX6Q_GPR13_SATA_TX_LVL_1_152_V },\n\t{ 1162, IMX6Q_GPR13_SATA_TX_LVL_1_162_V },\n\t{ 1172, IMX6Q_GPR13_SATA_TX_LVL_1_172_V },\n\t{ 1182, IMX6Q_GPR13_SATA_TX_LVL_1_182_V },\n\t{ 1191, IMX6Q_GPR13_SATA_TX_LVL_1_191_V },\n\t{ 1201, IMX6Q_GPR13_SATA_TX_LVL_1_201_V },\n\t{ 1211, IMX6Q_GPR13_SATA_TX_LVL_1_211_V },\n\t{ 1221, IMX6Q_GPR13_SATA_TX_LVL_1_221_V },\n\t{ 1230, IMX6Q_GPR13_SATA_TX_LVL_1_230_V },\n\t{ 1240, IMX6Q_GPR13_SATA_TX_LVL_1_240_V }\n};\n\nstatic const struct reg_value gpr13_tx_boost[] = {\n\t{    0, IMX6Q_GPR13_SATA_TX_BOOST_0_00_DB },\n\t{  370, IMX6Q_GPR13_SATA_TX_BOOST_0_37_DB },\n\t{  740, IMX6Q_GPR13_SATA_TX_BOOST_0_74_DB },\n\t{ 1110, IMX6Q_GPR13_SATA_TX_BOOST_1_11_DB },\n\t{ 1480, IMX6Q_GPR13_SATA_TX_BOOST_1_48_DB },\n\t{ 1850, IMX6Q_GPR13_SATA_TX_BOOST_1_85_DB },\n\t{ 2220, IMX6Q_GPR13_SATA_TX_BOOST_2_22_DB },\n\t{ 2590, IMX6Q_GPR13_SATA_TX_BOOST_2_59_DB },\n\t{ 2960, IMX6Q_GPR13_SATA_TX_BOOST_2_96_DB },\n\t{ 3330, IMX6Q_GPR13_SATA_TX_BOOST_3_33_DB },\n\t{ 3700, IMX6Q_GPR13_SATA_TX_BOOST_3_70_DB },\n\t{ 4070, IMX6Q_GPR13_SATA_TX_BOOST_4_07_DB },\n\t{ 4440, IMX6Q_GPR13_SATA_TX_BOOST_4_44_DB },\n\t{ 4810, IMX6Q_GPR13_SATA_TX_BOOST_4_81_DB },\n\t{ 5280, IMX6Q_GPR13_SATA_TX_BOOST_5_28_DB },\n\t{ 5750, IMX6Q_GPR13_SATA_TX_BOOST_5_75_DB }\n};\n\nstatic const struct reg_value gpr13_tx_atten[] = {\n\t{  8, IMX6Q_GPR13_SATA_TX_ATTEN_8_16 },\n\t{  9, IMX6Q_GPR13_SATA_TX_ATTEN_9_16 },\n\t{ 10, IMX6Q_GPR13_SATA_TX_ATTEN_10_16 },\n\t{ 12, IMX6Q_GPR13_SATA_TX_ATTEN_12_16 },\n\t{ 14, IMX6Q_GPR13_SATA_TX_ATTEN_14_16 },\n\t{ 16, IMX6Q_GPR13_SATA_TX_ATTEN_16_16 },\n};\n\nstatic const struct reg_value gpr13_rx_eq[] = {\n\t{  500, IMX6Q_GPR13_SATA_RX_EQ_VAL_0_5_DB },\n\t{ 1000, IMX6Q_GPR13_SATA_RX_EQ_VAL_1_0_DB },\n\t{ 1500, IMX6Q_GPR13_SATA_RX_EQ_VAL_1_5_DB },\n\t{ 2000, IMX6Q_GPR13_SATA_RX_EQ_VAL_2_0_DB },\n\t{ 2500, IMX6Q_GPR13_SATA_RX_EQ_VAL_2_5_DB },\n\t{ 3000, IMX6Q_GPR13_SATA_RX_EQ_VAL_3_0_DB },\n\t{ 3500, IMX6Q_GPR13_SATA_RX_EQ_VAL_3_5_DB },\n\t{ 4000, IMX6Q_GPR13_SATA_RX_EQ_VAL_4_0_DB },\n};\n\nstatic const struct reg_property gpr13_props[] = {\n\t{\n\t\t.name = \"fsl,transmit-level-mV\",\n\t\t.values = gpr13_tx_level,\n\t\t.num_values = ARRAY_SIZE(gpr13_tx_level),\n\t\t.def_value = IMX6Q_GPR13_SATA_TX_LVL_1_025_V,\n\t}, {\n\t\t.name = \"fsl,transmit-boost-mdB\",\n\t\t.values = gpr13_tx_boost,\n\t\t.num_values = ARRAY_SIZE(gpr13_tx_boost),\n\t\t.def_value = IMX6Q_GPR13_SATA_TX_BOOST_3_33_DB,\n\t}, {\n\t\t.name = \"fsl,transmit-atten-16ths\",\n\t\t.values = gpr13_tx_atten,\n\t\t.num_values = ARRAY_SIZE(gpr13_tx_atten),\n\t\t.def_value = IMX6Q_GPR13_SATA_TX_ATTEN_9_16,\n\t}, {\n\t\t.name = \"fsl,receive-eq-mdB\",\n\t\t.values = gpr13_rx_eq,\n\t\t.num_values = ARRAY_SIZE(gpr13_rx_eq),\n\t\t.def_value = IMX6Q_GPR13_SATA_RX_EQ_VAL_3_0_DB,\n\t}, {\n\t\t.name = \"fsl,no-spread-spectrum\",\n\t\t.def_value = IMX6Q_GPR13_SATA_MPLL_SS_EN,\n\t\t.set_value = 0,\n\t},\n};\n\nstatic u32 imx_ahci_parse_props(struct device *dev,\n\t\t\t\tconst struct reg_property *prop, size_t num)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 reg_value = 0;\n\tint i, j;\n\n\tfor (i = 0; i < num; i++, prop++) {\n\t\tu32 of_val;\n\n\t\tif (prop->num_values == 0) {\n\t\t\tif (of_property_read_bool(np, prop->name))\n\t\t\t\treg_value |= prop->set_value;\n\t\t\telse\n\t\t\t\treg_value |= prop->def_value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_property_read_u32(np, prop->name, &of_val)) {\n\t\t\tdev_info(dev, \"%s not specified, using %08x\\n\",\n\t\t\t\tprop->name, prop->def_value);\n\t\t\treg_value |= prop->def_value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < prop->num_values; j++) {\n\t\t\tif (prop->values[j].of_value == of_val) {\n\t\t\t\tdev_info(dev, \"%s value %u, using %08x\\n\",\n\t\t\t\t\tprop->name, of_val, prop->values[j].reg_value);\n\t\t\t\treg_value |= prop->values[j].reg_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == prop->num_values) {\n\t\t\tdev_err(dev, \"DT property %s is not a valid value\\n\",\n\t\t\t\tprop->name);\n\t\t\treg_value |= prop->def_value;\n\t\t}\n\t}\n\n\treturn reg_value;\n}\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int imx8_sata_probe(struct device *dev, struct imx_ahci_priv *imxpriv)\n{\n\tstruct resource *phy_res;\n\tstruct platform_device *pdev = imxpriv->ahci_pdev;\n\tstruct device_node *np = dev->of_node;\n\n\tif (of_property_read_u32(np, \"fsl,phy-imp\", &imxpriv->imped_ratio))\n\t\timxpriv->imped_ratio = IMX8QM_SATA_PHY_IMPED_RATIO_85OHM;\n\tphy_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"phy\");\n\tif (phy_res) {\n\t\timxpriv->phy_base = devm_ioremap(dev, phy_res->start,\n\t\t\t\t\tresource_size(phy_res));\n\t\tif (!imxpriv->phy_base) {\n\t\t\tdev_err(dev, \"error with ioremap\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"missing *phy* reg region.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\timxpriv->gpr =\n\t\t syscon_regmap_lookup_by_phandle(np, \"hsio\");\n\tif (IS_ERR(imxpriv->gpr)) {\n\t\tdev_err(dev, \"unable to find gpr registers\\n\");\n\t\treturn PTR_ERR(imxpriv->gpr);\n\t}\n\n\timxpriv->epcs_tx_clk = devm_clk_get(dev, \"epcs_tx\");\n\tif (IS_ERR(imxpriv->epcs_tx_clk)) {\n\t\tdev_err(dev, \"can't get epcs_tx_clk clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->epcs_tx_clk);\n\t}\n\timxpriv->epcs_rx_clk = devm_clk_get(dev, \"epcs_rx\");\n\tif (IS_ERR(imxpriv->epcs_rx_clk)) {\n\t\tdev_err(dev, \"can't get epcs_rx_clk clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->epcs_rx_clk);\n\t}\n\timxpriv->phy_pclk0 = devm_clk_get(dev, \"phy_pclk0\");\n\tif (IS_ERR(imxpriv->phy_pclk0)) {\n\t\tdev_err(dev, \"can't get phy_pclk0 clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->phy_pclk0);\n\t}\n\timxpriv->phy_pclk1 = devm_clk_get(dev, \"phy_pclk1\");\n\tif (IS_ERR(imxpriv->phy_pclk1)) {\n\t\tdev_err(dev, \"can't get phy_pclk1 clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->phy_pclk1);\n\t}\n\timxpriv->phy_apbclk = devm_clk_get(dev, \"phy_apbclk\");\n\tif (IS_ERR(imxpriv->phy_apbclk)) {\n\t\tdev_err(dev, \"can't get phy_apbclk clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->phy_apbclk);\n\t}\n\n\t \n\timxpriv->clkreq_gpiod = devm_gpiod_get_optional(dev, \"clkreq\",\n\t\t\t\tGPIOD_OUT_LOW | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(imxpriv->clkreq_gpiod))\n\t\treturn PTR_ERR(imxpriv->clkreq_gpiod);\n\tif (imxpriv->clkreq_gpiod)\n\t\tgpiod_set_consumer_name(imxpriv->clkreq_gpiod, \"SATA CLKREQ\");\n\n\treturn 0;\n}\n\nstatic int imx_ahci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\tstruct ahci_host_priv *hpriv;\n\tstruct imx_ahci_priv *imxpriv;\n\tunsigned int reg_val;\n\tint ret;\n\n\tof_id = of_match_device(imx_ahci_of_match, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\timxpriv = devm_kzalloc(dev, sizeof(*imxpriv), GFP_KERNEL);\n\tif (!imxpriv)\n\t\treturn -ENOMEM;\n\n\timxpriv->ahci_pdev = pdev;\n\timxpriv->no_device = false;\n\timxpriv->first_time = true;\n\timxpriv->type = (unsigned long)of_id->data;\n\n\timxpriv->sata_clk = devm_clk_get(dev, \"sata\");\n\tif (IS_ERR(imxpriv->sata_clk)) {\n\t\tdev_err(dev, \"can't get sata clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->sata_clk);\n\t}\n\n\timxpriv->sata_ref_clk = devm_clk_get(dev, \"sata_ref\");\n\tif (IS_ERR(imxpriv->sata_ref_clk)) {\n\t\tdev_err(dev, \"can't get sata_ref clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->sata_ref_clk);\n\t}\n\n\timxpriv->ahb_clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(imxpriv->ahb_clk)) {\n\t\tdev_err(dev, \"can't get ahb clock.\\n\");\n\t\treturn PTR_ERR(imxpriv->ahb_clk);\n\t}\n\n\tif (imxpriv->type == AHCI_IMX6Q || imxpriv->type == AHCI_IMX6QP) {\n\t\tu32 reg_value;\n\n\t\timxpriv->gpr = syscon_regmap_lookup_by_compatible(\n\t\t\t\t\t\t\t\"fsl,imx6q-iomuxc-gpr\");\n\t\tif (IS_ERR(imxpriv->gpr)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to find fsl,imx6q-iomux-gpr regmap\\n\");\n\t\t\treturn PTR_ERR(imxpriv->gpr);\n\t\t}\n\n\t\treg_value = imx_ahci_parse_props(dev, gpr13_props,\n\t\t\t\t\t\t ARRAY_SIZE(gpr13_props));\n\n\t\timxpriv->phy_params =\n\t\t\t\t   IMX6Q_GPR13_SATA_RX_LOS_LVL_SATA2M |\n\t\t\t\t   IMX6Q_GPR13_SATA_RX_DPLL_MODE_2P_4F |\n\t\t\t\t   IMX6Q_GPR13_SATA_SPD_MODE_3P0G |\n\t\t\t\t   reg_value;\n\t} else if (imxpriv->type == AHCI_IMX8QM) {\n\t\tret =  imx8_sata_probe(dev, imxpriv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\thpriv->plat_data = imxpriv;\n\n\tret = clk_prepare_enable(imxpriv->sata_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (imxpriv->type == AHCI_IMX53 &&\n\t    IS_ENABLED(CONFIG_HWMON)) {\n\t\t \n\t\tstruct device *hwmon_dev;\n\n\t\thwmon_dev =\n\t\t\tdevm_hwmon_device_register_with_groups(dev,\n\t\t\t\t\t\t\t\"sata_ahci\",\n\t\t\t\t\t\t\thpriv,\n\t\t\t\t\t\t\tfsl_sata_ahci_groups);\n\t\tif (IS_ERR(hwmon_dev)) {\n\t\t\tret = PTR_ERR(hwmon_dev);\n\t\t\tgoto disable_clk;\n\t\t}\n\t\tdevm_thermal_of_zone_register(hwmon_dev, 0, hwmon_dev,\n\t\t\t\t\t      &fsl_sata_ahci_of_thermal_ops);\n\t\tdev_info(dev, \"%s: sensor 'sata_ahci'\\n\", dev_name(hwmon_dev));\n\t}\n\n\tret = imx_sata_enable(hpriv);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\t \n\treg_val = readl(hpriv->mmio + HOST_CAP);\n\tif (!(reg_val & HOST_CAP_SSS)) {\n\t\treg_val |= HOST_CAP_SSS;\n\t\twritel(reg_val, hpriv->mmio + HOST_CAP);\n\t}\n\treg_val = readl(hpriv->mmio + HOST_PORTS_IMPL);\n\tif (!(reg_val & 0x1)) {\n\t\treg_val |= 0x1;\n\t\twritel(reg_val, hpriv->mmio + HOST_PORTS_IMPL);\n\t}\n\n\treg_val = clk_get_rate(imxpriv->ahb_clk) / 1000;\n\twritel(reg_val, hpriv->mmio + IMX_TIMER1MS);\n\n\tret = ahci_platform_init_host(pdev, hpriv, &ahci_imx_port_info,\n\t\t\t\t      &ahci_platform_sht);\n\tif (ret)\n\t\tgoto disable_sata;\n\n\treturn 0;\n\ndisable_sata:\n\timx_sata_disable(hpriv);\ndisable_clk:\n\tclk_disable_unprepare(imxpriv->sata_clk);\n\treturn ret;\n}\n\nstatic void ahci_imx_host_stop(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\n\n\timx_sata_disable(hpriv);\n\tclk_disable_unprepare(imxpriv->sata_clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx_ahci_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint ret;\n\n\tret = ahci_platform_suspend_host(dev);\n\tif (ret)\n\t\treturn ret;\n\n\timx_sata_disable(hpriv);\n\n\treturn 0;\n}\n\nstatic int imx_ahci_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint ret;\n\n\tret = imx_sata_enable(hpriv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ahci_platform_resume_host(dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ahci_imx_pm_ops, imx_ahci_suspend, imx_ahci_resume);\n\nstatic struct platform_driver imx_ahci_driver = {\n\t.probe = imx_ahci_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = imx_ahci_of_match,\n\t\t.pm = &ahci_imx_pm_ops,\n\t},\n};\nmodule_platform_driver(imx_ahci_driver);\n\nMODULE_DESCRIPTION(\"Freescale i.MX AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Richard Zhu <Hong-Xing.Zhu@freescale.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}