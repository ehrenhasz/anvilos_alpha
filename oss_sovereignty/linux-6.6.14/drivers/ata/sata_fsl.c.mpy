{
  "module_name": "sata_fsl.c",
  "hash_id": "dcabeb7e325e8046bd378af9803f8f1eaa85209363ceb9e8374edd8bc312808b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_fsl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n#include <asm/io.h>\n\nstatic unsigned int intr_coalescing_count;\nmodule_param(intr_coalescing_count, int, S_IRUGO);\nMODULE_PARM_DESC(intr_coalescing_count,\n\t\t\t\t \"INT coalescing count threshold (1..31)\");\n\nstatic unsigned int intr_coalescing_ticks;\nmodule_param(intr_coalescing_ticks, int, S_IRUGO);\nMODULE_PARM_DESC(intr_coalescing_ticks,\n\t\t\t\t \"INT coalescing timer threshold in AHB ticks\");\n \nenum {\n\tSATA_FSL_QUEUE_DEPTH\t= 16,\n\tSATA_FSL_MAX_PRD\t= 63,\n\tSATA_FSL_MAX_PRD_USABLE\t= SATA_FSL_MAX_PRD - 1,\n\tSATA_FSL_MAX_PRD_DIRECT\t= 16,\t \n\n\tSATA_FSL_HOST_FLAGS\t= (ATA_FLAG_SATA | ATA_FLAG_PIO_DMA |\n\t\t\t\t   ATA_FLAG_PMP | ATA_FLAG_NCQ |\n\t\t\t\t   ATA_FLAG_AN | ATA_FLAG_NO_LOG_PAGE),\n\n\tSATA_FSL_MAX_CMDS\t= SATA_FSL_QUEUE_DEPTH,\n\tSATA_FSL_CMD_HDR_SIZE\t= 16,\t \n\tSATA_FSL_CMD_SLOT_SIZE  = (SATA_FSL_MAX_CMDS * SATA_FSL_CMD_HDR_SIZE),\n\n\t \n\n\tSATA_FSL_CMD_DESC_CFIS_SZ\t= 32,\n\tSATA_FSL_CMD_DESC_SFIS_SZ\t= 32,\n\tSATA_FSL_CMD_DESC_ACMD_SZ\t= 16,\n\tSATA_FSL_CMD_DESC_RSRVD\t\t= 16,\n\n\tSATA_FSL_CMD_DESC_SIZE\t= (SATA_FSL_CMD_DESC_CFIS_SZ +\n\t\t\t\t SATA_FSL_CMD_DESC_SFIS_SZ +\n\t\t\t\t SATA_FSL_CMD_DESC_ACMD_SZ +\n\t\t\t\t SATA_FSL_CMD_DESC_RSRVD +\n\t\t\t\t SATA_FSL_MAX_PRD * 16),\n\n\tSATA_FSL_CMD_DESC_OFFSET_TO_PRDT\t=\n\t\t\t\t(SATA_FSL_CMD_DESC_CFIS_SZ +\n\t\t\t\t SATA_FSL_CMD_DESC_SFIS_SZ +\n\t\t\t\t SATA_FSL_CMD_DESC_ACMD_SZ +\n\t\t\t\t SATA_FSL_CMD_DESC_RSRVD),\n\n\tSATA_FSL_CMD_DESC_AR_SZ\t= (SATA_FSL_CMD_DESC_SIZE * SATA_FSL_MAX_CMDS),\n\tSATA_FSL_PORT_PRIV_DMA_SZ = (SATA_FSL_CMD_SLOT_SIZE +\n\t\t\t\t\tSATA_FSL_CMD_DESC_AR_SZ),\n\n\t \n\n\tSATA_FSL_MAX_PORTS\t= 1,\n\n\tSATA_FSL_IRQ_FLAG\t= IRQF_SHARED,\n};\n\n \nenum {\n\tICC_MIN_INT_COUNT_THRESHOLD\t= 1,\n\tICC_MAX_INT_COUNT_THRESHOLD\t= ((1 << 5) - 1),\n\tICC_MIN_INT_TICKS_THRESHOLD\t= 0,\n\tICC_MAX_INT_TICKS_THRESHOLD\t= ((1 << 19) - 1),\n\tICC_SAFE_INT_TICKS\t\t= 1,\n};\n\n \nenum {\n\tCQ = 0,\n\tCA = 8,\n\tCC = 0x10,\n\tCE = 0x18,\n\tDE = 0x20,\n\tCHBA = 0x24,\n\tHSTATUS = 0x28,\n\tHCONTROL = 0x2C,\n\tCQPMP = 0x30,\n\tSIGNATURE = 0x34,\n\tICC = 0x38,\n\n\t \n\tONLINE = (1 << 31),\n\tGOING_OFFLINE = (1 << 30),\n\tBIST_ERR = (1 << 29),\n\tCLEAR_ERROR = (1 << 27),\n\n\tFATAL_ERR_HC_MASTER_ERR = (1 << 18),\n\tFATAL_ERR_PARITY_ERR_TX = (1 << 17),\n\tFATAL_ERR_PARITY_ERR_RX = (1 << 16),\n\tFATAL_ERR_DATA_UNDERRUN = (1 << 13),\n\tFATAL_ERR_DATA_OVERRUN = (1 << 12),\n\tFATAL_ERR_CRC_ERR_TX = (1 << 11),\n\tFATAL_ERR_CRC_ERR_RX = (1 << 10),\n\tFATAL_ERR_FIFO_OVRFL_TX = (1 << 9),\n\tFATAL_ERR_FIFO_OVRFL_RX = (1 << 8),\n\n\tFATAL_ERROR_DECODE = FATAL_ERR_HC_MASTER_ERR |\n\t    FATAL_ERR_PARITY_ERR_TX |\n\t    FATAL_ERR_PARITY_ERR_RX |\n\t    FATAL_ERR_DATA_UNDERRUN |\n\t    FATAL_ERR_DATA_OVERRUN |\n\t    FATAL_ERR_CRC_ERR_TX |\n\t    FATAL_ERR_CRC_ERR_RX |\n\t    FATAL_ERR_FIFO_OVRFL_TX | FATAL_ERR_FIFO_OVRFL_RX,\n\n\tINT_ON_DATA_LENGTH_MISMATCH = (1 << 12),\n\tINT_ON_FATAL_ERR = (1 << 5),\n\tINT_ON_PHYRDY_CHG = (1 << 4),\n\n\tINT_ON_SIGNATURE_UPDATE = (1 << 3),\n\tINT_ON_SNOTIFY_UPDATE = (1 << 2),\n\tINT_ON_SINGL_DEVICE_ERR = (1 << 1),\n\tINT_ON_CMD_COMPLETE = 1,\n\n\tINT_ON_ERROR = INT_ON_FATAL_ERR | INT_ON_SNOTIFY_UPDATE |\n\t    INT_ON_PHYRDY_CHG | INT_ON_SINGL_DEVICE_ERR,\n\n\t \n\tHCONTROL_ONLINE_PHY_RST = (1 << 31),\n\tHCONTROL_FORCE_OFFLINE = (1 << 30),\n\tHCONTROL_LEGACY = (1 << 28),\n\tHCONTROL_PARITY_PROT_MOD = (1 << 14),\n\tHCONTROL_DPATH_PARITY = (1 << 12),\n\tHCONTROL_SNOOP_ENABLE = (1 << 10),\n\tHCONTROL_PMP_ATTACHED = (1 << 9),\n\tHCONTROL_COPYOUT_STATFIS = (1 << 8),\n\tIE_ON_FATAL_ERR = (1 << 5),\n\tIE_ON_PHYRDY_CHG = (1 << 4),\n\tIE_ON_SIGNATURE_UPDATE = (1 << 3),\n\tIE_ON_SNOTIFY_UPDATE = (1 << 2),\n\tIE_ON_SINGL_DEVICE_ERR = (1 << 1),\n\tIE_ON_CMD_COMPLETE = 1,\n\n\tDEFAULT_PORT_IRQ_ENABLE_MASK = IE_ON_FATAL_ERR | IE_ON_PHYRDY_CHG |\n\t    IE_ON_SIGNATURE_UPDATE | IE_ON_SNOTIFY_UPDATE |\n\t    IE_ON_SINGL_DEVICE_ERR | IE_ON_CMD_COMPLETE,\n\n\tEXT_INDIRECT_SEG_PRD_FLAG = (1 << 31),\n\tDATA_SNOOP_ENABLE_V1 = (1 << 22),\n\tDATA_SNOOP_ENABLE_V2 = (1 << 28),\n};\n\n \nenum {\n\tSSTATUS = 0,\n\tSERROR = 4,\n\tSCONTROL = 8,\n\tSNOTIFY = 0xC,\n};\n\n \nenum {\n\tTRANSCFG = 0,\n\tTRANSSTATUS = 4,\n\tLINKCFG = 8,\n\tLINKCFG1 = 0xC,\n\tLINKCFG2 = 0x10,\n\tLINKSTATUS = 0x14,\n\tLINKSTATUS1 = 0x18,\n\tPHYCTRLCFG = 0x1C,\n\tCOMMANDSTAT = 0x20,\n};\n\n \nenum {\n\tTRANSCFG_RX_WATER_MARK = (1 << 4),\n};\n\n \nenum {\n\tPHY_BIST_ENABLE = 0x01,\n};\n\n \nstruct cmdhdr_tbl_entry {\n\t__le32 cda;\n\t__le32 prde_fis_len;\n\t__le32 ttl;\n\t__le32 desc_info;\n};\n\n \nenum {\n\tCMD_DESC_RES = (1 << 11),\n\tVENDOR_SPECIFIC_BIST = (1 << 10),\n\tCMD_DESC_SNOOP_ENABLE = (1 << 9),\n\tFPDMA_QUEUED_CMD = (1 << 8),\n\tSRST_CMD = (1 << 7),\n\tBIST = (1 << 6),\n\tATAPI_CMD = (1 << 5),\n};\n\n \nstruct command_desc {\n\tu8 cfis[8 * 4];\n\tu8 sfis[8 * 4];\n\tstruct_group(cdb,\n\t\tu8 acmd[4 * 4];\n\t\tu8 fill[4 * 4];\n\t);\n\tu32 prdt[SATA_FSL_MAX_PRD_DIRECT * 4];\n\tu32 prdt_indirect[(SATA_FSL_MAX_PRD - SATA_FSL_MAX_PRD_DIRECT) * 4];\n};\n\n \n\nstruct prde {\n\t__le32 dba;\n\tu8 fill[2 * 4];\n\t__le32 ddc_and_ext;\n};\n\n \nstruct sata_fsl_port_priv {\n\tstruct cmdhdr_tbl_entry *cmdslot;\n\tdma_addr_t cmdslot_paddr;\n\tstruct command_desc *cmdentry;\n\tdma_addr_t cmdentry_paddr;\n};\n\n \nstruct sata_fsl_host_priv {\n\tvoid __iomem *hcr_base;\n\tvoid __iomem *ssr_base;\n\tvoid __iomem *csr_base;\n\tint irq;\n\tint data_snoop;\n\tstruct device_attribute intr_coalescing;\n\tstruct device_attribute rx_watermark;\n};\n\nstatic void fsl_sata_set_irq_coalescing(struct ata_host *host,\n\t\tunsigned int count, unsigned int ticks)\n{\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tunsigned long flags;\n\n\tif (count > ICC_MAX_INT_COUNT_THRESHOLD)\n\t\tcount = ICC_MAX_INT_COUNT_THRESHOLD;\n\telse if (count < ICC_MIN_INT_COUNT_THRESHOLD)\n\t\tcount = ICC_MIN_INT_COUNT_THRESHOLD;\n\n\tif (ticks > ICC_MAX_INT_TICKS_THRESHOLD)\n\t\tticks = ICC_MAX_INT_TICKS_THRESHOLD;\n\telse if ((ICC_MIN_INT_TICKS_THRESHOLD == ticks) &&\n\t\t\t(count > ICC_MIN_INT_COUNT_THRESHOLD))\n\t\tticks = ICC_SAFE_INT_TICKS;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tiowrite32((count << 24 | ticks), hcr_base + ICC);\n\n\tintr_coalescing_count = count;\n\tintr_coalescing_ticks = ticks;\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tdev_dbg(host->dev, \"interrupt coalescing, count = 0x%x, ticks = %x\\n\",\n\t\tintr_coalescing_count, intr_coalescing_ticks);\n\tdev_dbg(host->dev, \"ICC register status: (hcr base: 0x%p) = 0x%x\\n\",\n\t\thcr_base, ioread32(hcr_base + ICC));\n}\n\nstatic ssize_t fsl_sata_intr_coalescing_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\t%u\\n\",\n\t\t\tintr_coalescing_count, intr_coalescing_ticks);\n}\n\nstatic ssize_t fsl_sata_intr_coalescing_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tunsigned int coalescing_count,\tcoalescing_ticks;\n\n\tif (sscanf(buf, \"%u%u\", &coalescing_count, &coalescing_ticks) != 2) {\n\t\tdev_err(dev, \"fsl-sata: wrong parameter format.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfsl_sata_set_irq_coalescing(dev_get_drvdata(dev),\n\t\t\tcoalescing_count, coalescing_ticks);\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t fsl_sata_rx_watermark_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned int rx_watermark;\n\tunsigned long flags;\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\tvoid __iomem *csr_base = host_priv->csr_base;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\trx_watermark = ioread32(csr_base + TRANSCFG);\n\trx_watermark &= 0x1f;\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn sysfs_emit(buf, \"%u\\n\", rx_watermark);\n}\n\nstatic ssize_t fsl_sata_rx_watermark_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tunsigned int rx_watermark;\n\tunsigned long flags;\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\tvoid __iomem *csr_base = host_priv->csr_base;\n\tu32 temp;\n\n\tif (kstrtouint(buf, 10, &rx_watermark) < 0) {\n\t\tdev_err(dev, \"fsl-sata: wrong parameter format.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&host->lock, flags);\n\ttemp = ioread32(csr_base + TRANSCFG);\n\ttemp &= 0xffffffe0;\n\tiowrite32(temp | rx_watermark, csr_base + TRANSCFG);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn strlen(buf);\n}\n\nstatic inline unsigned int sata_fsl_tag(struct ata_port *ap,\n\t\t\t\t\tunsigned int tag,\n\t\t\t\t\tvoid __iomem *hcr_base)\n{\n\t \n\n\tif (unlikely(tag >= SATA_FSL_QUEUE_DEPTH)) {\n\t\tata_port_dbg(ap, \"tag %d invalid : out of range\\n\", tag);\n\t\treturn 0;\n\t}\n\n\tif (unlikely((ioread32(hcr_base + CQ)) & (1 << tag))) {\n\t\tata_port_dbg(ap, \"tag %d invalid : in use!!\\n\", tag);\n\t\treturn 0;\n\t}\n\n\treturn tag;\n}\n\nstatic void sata_fsl_setup_cmd_hdr_entry(struct ata_port *ap,\n\t\t\t\t\t struct sata_fsl_port_priv *pp,\n\t\t\t\t\t unsigned int tag, u32 desc_info,\n\t\t\t\t\t u32 data_xfer_len, u8 num_prde,\n\t\t\t\t\t u8 fis_len)\n{\n\tdma_addr_t cmd_descriptor_address;\n\n\tcmd_descriptor_address = pp->cmdentry_paddr +\n\t    tag * SATA_FSL_CMD_DESC_SIZE;\n\n\t \n\n\tpp->cmdslot[tag].cda = cpu_to_le32(cmd_descriptor_address);\n\tpp->cmdslot[tag].prde_fis_len =\n\t    cpu_to_le32((num_prde << 16) | (fis_len << 2));\n\tpp->cmdslot[tag].ttl = cpu_to_le32(data_xfer_len & ~0x03);\n\tpp->cmdslot[tag].desc_info = cpu_to_le32(desc_info | (tag & 0x1F));\n\n\tata_port_dbg(ap, \"cda=0x%x, prde_fis_len=0x%x, ttl=0x%x, di=0x%x\\n\",\n\t\t     le32_to_cpu(pp->cmdslot[tag].cda),\n\t\t     le32_to_cpu(pp->cmdslot[tag].prde_fis_len),\n\t\t     le32_to_cpu(pp->cmdslot[tag].ttl),\n\t\t     le32_to_cpu(pp->cmdslot[tag].desc_info));\n}\n\nstatic unsigned int sata_fsl_fill_sg(struct ata_queued_cmd *qc, void *cmd_desc,\n\t\t\t\t     u32 *ttl, dma_addr_t cmd_desc_paddr,\n\t\t\t\t     int data_snoop)\n{\n\tstruct scatterlist *sg;\n\tunsigned int num_prde = 0;\n\tu32 ttl_dwords = 0;\n\n\t \n\tstruct prde *prd = (struct prde *)&((struct command_desc *)\n\t\t\t\t\t    cmd_desc)->prdt;\n\n\tstruct prde *prd_ptr_to_indirect_ext = NULL;\n\tunsigned indirect_ext_segment_sz = 0;\n\tdma_addr_t indirect_ext_segment_paddr;\n\tunsigned int si;\n\n\tindirect_ext_segment_paddr = cmd_desc_paddr +\n\t    SATA_FSL_CMD_DESC_OFFSET_TO_PRDT + SATA_FSL_MAX_PRD_DIRECT * 16;\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tdma_addr_t sg_addr = sg_dma_address(sg);\n\t\tu32 sg_len = sg_dma_len(sg);\n\n\t\t \n\t\tif (unlikely(sg_addr & 0x03))\n\t\t\tata_port_err(qc->ap, \"s/g addr unaligned : 0x%llx\\n\",\n\t\t\t\t     (unsigned long long)sg_addr);\n\t\tif (unlikely(sg_len & 0x03))\n\t\t\tata_port_err(qc->ap, \"s/g len unaligned : 0x%x\\n\",\n\t\t\t\t     sg_len);\n\n\t\tif (num_prde == (SATA_FSL_MAX_PRD_DIRECT - 1) &&\n\t\t    sg_next(sg) != NULL) {\n\t\t\tprd_ptr_to_indirect_ext = prd;\n\t\t\tprd->dba = cpu_to_le32(indirect_ext_segment_paddr);\n\t\t\tindirect_ext_segment_sz = 0;\n\t\t\t++prd;\n\t\t\t++num_prde;\n\t\t}\n\n\t\tttl_dwords += sg_len;\n\t\tprd->dba = cpu_to_le32(sg_addr);\n\t\tprd->ddc_and_ext = cpu_to_le32(data_snoop | (sg_len & ~0x03));\n\n\t\t++num_prde;\n\t\t++prd;\n\t\tif (prd_ptr_to_indirect_ext)\n\t\t\tindirect_ext_segment_sz += sg_len;\n\t}\n\n\tif (prd_ptr_to_indirect_ext) {\n\t\t \n\t\tprd_ptr_to_indirect_ext->ddc_and_ext =\n\t\t    cpu_to_le32((EXT_INDIRECT_SEG_PRD_FLAG |\n\t\t\t\t data_snoop |\n\t\t\t\t (indirect_ext_segment_sz & ~0x03)));\n\t}\n\n\t*ttl = ttl_dwords;\n\treturn num_prde;\n}\n\nstatic enum ata_completion_errors sata_fsl_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_fsl_port_priv *pp = ap->private_data;\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tunsigned int tag = sata_fsl_tag(ap, qc->hw_tag, hcr_base);\n\tstruct command_desc *cd;\n\tu32 desc_info = CMD_DESC_RES | CMD_DESC_SNOOP_ENABLE;\n\tu32 num_prde = 0;\n\tu32 ttl_dwords = 0;\n\tdma_addr_t cd_paddr;\n\n\tcd = (struct command_desc *)pp->cmdentry + tag;\n\tcd_paddr = pp->cmdentry_paddr + tag * SATA_FSL_CMD_DESC_SIZE;\n\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, (u8 *) &cd->cfis);\n\n\t \n\tif (ata_is_atapi(qc->tf.protocol)) {\n\t\tdesc_info |= ATAPI_CMD;\n\t\tmemset(&cd->cdb, 0, sizeof(cd->cdb));\n\t\tmemcpy(&cd->cdb, qc->cdb, qc->dev->cdb_len);\n\t}\n\n\tif (qc->flags & ATA_QCFLAG_DMAMAP)\n\t\tnum_prde = sata_fsl_fill_sg(qc, (void *)cd,\n\t\t\t\t\t    &ttl_dwords, cd_paddr,\n\t\t\t\t\t    host_priv->data_snoop);\n\n\tif (qc->tf.protocol == ATA_PROT_NCQ)\n\t\tdesc_info |= FPDMA_QUEUED_CMD;\n\n\tsata_fsl_setup_cmd_hdr_entry(ap, pp, tag, desc_info, ttl_dwords,\n\t\t\t\t     num_prde, 5);\n\n\tata_port_dbg(ap, \"SATA FSL : di = 0x%x, ttl = %d, num_prde = %d\\n\",\n\t\tdesc_info, ttl_dwords, num_prde);\n\n\treturn AC_ERR_OK;\n}\n\nstatic unsigned int sata_fsl_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tunsigned int tag = sata_fsl_tag(ap, qc->hw_tag, hcr_base);\n\n\tata_port_dbg(ap, \"CQ=0x%x,CA=0x%x,CE=0x%x,CC=0x%x\\n\",\n\t\tioread32(CQ + hcr_base),\n\t\tioread32(CA + hcr_base),\n\t\tioread32(CE + hcr_base), ioread32(CC + hcr_base));\n\n\tiowrite32(qc->dev->link->pmp, CQPMP + hcr_base);\n\n\t \n\tiowrite32(1 << tag, CQ + hcr_base);\n\n\tata_port_dbg(ap, \"tag=%d, CQ=0x%x, CA=0x%x\\n\",\n\t\ttag, ioread32(CQ + hcr_base), ioread32(CA + hcr_base));\n\n\tata_port_dbg(ap, \"CE=0x%x, DE=0x%x, CC=0x%x, CmdStat = 0x%x\\n\",\n\t\tioread32(CE + hcr_base),\n\t\tioread32(DE + hcr_base),\n\t\tioread32(CC + hcr_base),\n\t\tioread32(COMMANDSTAT + host_priv->csr_base));\n\n\treturn 0;\n}\n\nstatic void sata_fsl_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct sata_fsl_port_priv *pp = qc->ap->private_data;\n\tstruct sata_fsl_host_priv *host_priv = qc->ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tunsigned int tag = sata_fsl_tag(qc->ap, qc->hw_tag, hcr_base);\n\tstruct command_desc *cd;\n\n\tcd = pp->cmdentry + tag;\n\n\tata_tf_from_fis(cd->sfis, &qc->result_tf);\n}\n\nstatic int sata_fsl_scr_write(struct ata_link *link,\n\t\t\t      unsigned int sc_reg_in, u32 val)\n{\n\tstruct sata_fsl_host_priv *host_priv = link->ap->host->private_data;\n\tvoid __iomem *ssr_base = host_priv->ssr_base;\n\tunsigned int sc_reg;\n\n\tswitch (sc_reg_in) {\n\tcase SCR_STATUS:\n\tcase SCR_ERROR:\n\tcase SCR_CONTROL:\n\tcase SCR_ACTIVE:\n\t\tsc_reg = sc_reg_in;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tata_link_dbg(link, \"reg_in = %d\\n\", sc_reg);\n\n\tiowrite32(val, ssr_base + (sc_reg * 4));\n\treturn 0;\n}\n\nstatic int sata_fsl_scr_read(struct ata_link *link,\n\t\t\t     unsigned int sc_reg_in, u32 *val)\n{\n\tstruct sata_fsl_host_priv *host_priv = link->ap->host->private_data;\n\tvoid __iomem *ssr_base = host_priv->ssr_base;\n\tunsigned int sc_reg;\n\n\tswitch (sc_reg_in) {\n\tcase SCR_STATUS:\n\tcase SCR_ERROR:\n\tcase SCR_CONTROL:\n\tcase SCR_ACTIVE:\n\t\tsc_reg = sc_reg_in;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tata_link_dbg(link, \"reg_in = %d\\n\", sc_reg);\n\n\t*val = ioread32(ssr_base + (sc_reg * 4));\n\treturn 0;\n}\n\nstatic void sata_fsl_freeze(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\tata_port_dbg(ap, \"CQ=0x%x, CA=0x%x, CE=0x%x, DE=0x%x\\n\",\n\t\tioread32(CQ + hcr_base),\n\t\tioread32(CA + hcr_base),\n\t\tioread32(CE + hcr_base), ioread32(DE + hcr_base));\n\tata_port_dbg(ap, \"CmdStat = 0x%x\\n\",\n\t\tioread32(host_priv->csr_base + COMMANDSTAT));\n\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32((temp & ~0x3F), hcr_base + HCONTROL);\n\n\tata_port_dbg(ap, \"HControl = 0x%x, HStatus = 0x%x\\n\",\n\t\tioread32(hcr_base + HCONTROL), ioread32(hcr_base + HSTATUS));\n}\n\nstatic void sata_fsl_thaw(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\t \n\ttemp = ioread32(hcr_base + HSTATUS);\n\n\tata_port_dbg(ap, \"pending IRQs = 0x%x\\n\", (temp & 0x3F));\n\n\tif (temp & 0x3F)\n\t\tiowrite32((temp & 0x3F), hcr_base + HSTATUS);\n\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32((temp | DEFAULT_PORT_IRQ_ENABLE_MASK), hcr_base + HCONTROL);\n\n\tata_port_dbg(ap, \"HControl = 0x%x, HStatus = 0x%x\\n\",\n\t\tioread32(hcr_base + HCONTROL), ioread32(hcr_base + HSTATUS));\n}\n\nstatic void sata_fsl_pmp_attach(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32((temp | HCONTROL_PMP_ATTACHED), hcr_base + HCONTROL);\n}\n\nstatic void sata_fsl_pmp_detach(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\ttemp = ioread32(hcr_base + HCONTROL);\n\ttemp &= ~HCONTROL_PMP_ATTACHED;\n\tiowrite32(temp, hcr_base + HCONTROL);\n\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32((temp | DEFAULT_PORT_IRQ_ENABLE_MASK), hcr_base + HCONTROL);\n\n}\n\nstatic int sata_fsl_port_start(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct sata_fsl_port_priv *pp;\n\tvoid *mem;\n\tdma_addr_t mem_dma;\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\tpp = kzalloc(sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tmem = dma_alloc_coherent(dev, SATA_FSL_PORT_PRIV_DMA_SZ, &mem_dma,\n\t\t\t\t GFP_KERNEL);\n\tif (!mem) {\n\t\tkfree(pp);\n\t\treturn -ENOMEM;\n\t}\n\n\tpp->cmdslot = mem;\n\tpp->cmdslot_paddr = mem_dma;\n\n\tmem += SATA_FSL_CMD_SLOT_SIZE;\n\tmem_dma += SATA_FSL_CMD_SLOT_SIZE;\n\n\tpp->cmdentry = mem;\n\tpp->cmdentry_paddr = mem_dma;\n\n\tap->private_data = pp;\n\n\tata_port_dbg(ap, \"CHBA = 0x%lx, cmdentry_phys = 0x%lx\\n\",\n\t\t(unsigned long)pp->cmdslot_paddr,\n\t\t(unsigned long)pp->cmdentry_paddr);\n\n\t \n\tiowrite32(pp->cmdslot_paddr & 0xffffffff, hcr_base + CHBA);\n\n\t \n\n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32((temp | HCONTROL_ONLINE_PHY_RST), hcr_base + HCONTROL);\n\n\tata_port_dbg(ap, \"HStatus = 0x%x\\n\", ioread32(hcr_base + HSTATUS));\n\tata_port_dbg(ap, \"HControl = 0x%x\\n\", ioread32(hcr_base + HCONTROL));\n\tata_port_dbg(ap, \"CHBA  = 0x%x\\n\", ioread32(hcr_base + CHBA));\n\n\treturn 0;\n}\n\nstatic void sata_fsl_port_stop(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct sata_fsl_port_priv *pp = ap->private_data;\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\ttemp &= ~HCONTROL_ONLINE_PHY_RST;\n\ttemp |= HCONTROL_FORCE_OFFLINE;\n\tiowrite32(temp, hcr_base + HCONTROL);\n\n\t \n\tata_wait_register(ap, hcr_base + HSTATUS, ONLINE, ONLINE, 1, 1);\n\n\tap->private_data = NULL;\n\tdma_free_coherent(dev, SATA_FSL_PORT_PRIV_DMA_SZ,\n\t\t\t  pp->cmdslot, pp->cmdslot_paddr);\n\n\tkfree(pp);\n}\n\nstatic unsigned int sata_fsl_dev_classify(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tstruct ata_taskfile tf;\n\tu32 temp;\n\n\ttemp = ioread32(hcr_base + SIGNATURE);\n\n\tata_port_dbg(ap, \"HStatus = 0x%x\\n\", ioread32(hcr_base + HSTATUS));\n\tata_port_dbg(ap, \"HControl = 0x%x\\n\", ioread32(hcr_base + HCONTROL));\n\n\ttf.lbah = (temp >> 24) & 0xff;\n\ttf.lbam = (temp >> 16) & 0xff;\n\ttf.lbal = (temp >> 8) & 0xff;\n\ttf.nsect = temp & 0xff;\n\n\treturn ata_port_classify(ap, &tf);\n}\n\nstatic int sata_fsl_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\t\tunsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\tint i = 0;\n\tunsigned long start_jiffies;\n\ntry_offline_again:\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\ttemp &= ~HCONTROL_ONLINE_PHY_RST;\n\tiowrite32(temp, hcr_base + HCONTROL);\n\n\t \n\ttemp = ata_wait_register(ap, hcr_base + HSTATUS, ONLINE, ONLINE,\n\t\t\t\t 1, 500);\n\n\tif (temp & ONLINE) {\n\t\tata_port_err(ap, \"Hardreset failed, not off-lined %d\\n\", i);\n\n\t\t \n\t\ti++;\n\t\tif (i == 2)\n\t\t\tgoto err;\n\t\telse\n\t\t\tgoto try_offline_again;\n\t}\n\n\tata_port_dbg(ap, \"hardreset, controller off-lined\\n\"\n\t\t     \"HStatus = 0x%x HControl = 0x%x\\n\",\n\t\t     ioread32(hcr_base + HSTATUS),\n\t\t     ioread32(hcr_base + HCONTROL));\n\n\t \n\tata_msleep(ap, 1);\n\n\tsata_set_spd(link);\n\n\t \n\n\ttemp = ioread32(hcr_base + HCONTROL);\n\ttemp |= (HCONTROL_ONLINE_PHY_RST | HCONTROL_SNOOP_ENABLE);\n\ttemp |= HCONTROL_PMP_ATTACHED;\n\tiowrite32(temp, hcr_base + HCONTROL);\n\n\ttemp = ata_wait_register(ap, hcr_base + HSTATUS, ONLINE, 0, 1, 500);\n\n\tif (!(temp & ONLINE)) {\n\t\tata_port_err(ap, \"Hardreset failed, not on-lined\\n\");\n\t\tgoto err;\n\t}\n\n\tata_port_dbg(ap, \"controller off-lined & on-lined\\n\"\n\t\t     \"HStatus = 0x%x HControl = 0x%x\\n\",\n\t\t     ioread32(hcr_base + HSTATUS),\n\t\t     ioread32(hcr_base + HCONTROL));\n\n\t \n\n\ttemp = ata_wait_register(ap, hcr_base + HSTATUS, 0xFF, 0, 1, 500);\n\tif ((!(temp & 0x10)) || ata_link_offline(link)) {\n\t\tata_port_warn(ap, \"No Device OR PHYRDY change,Hstatus = 0x%x\\n\",\n\t\t\t      ioread32(hcr_base + HSTATUS));\n\t\t*class = ATA_DEV_NONE;\n\t\treturn 0;\n\t}\n\n\t \n\tstart_jiffies = jiffies;\n\ttemp = ata_wait_register(ap, hcr_base + HSTATUS, 0xFF, 0x10,\n\t\t\t500, jiffies_to_msecs(deadline - start_jiffies));\n\n\tif ((temp & 0xFF) != 0x18) {\n\t\tata_port_warn(ap, \"No Signature Update\\n\");\n\t\t*class = ATA_DEV_NONE;\n\t\tgoto do_followup_srst;\n\t} else {\n\t\tata_port_info(ap, \"Signature Update detected @ %d msecs\\n\",\n\t\t\t      jiffies_to_msecs(jiffies - start_jiffies));\n\t\t*class = sata_fsl_dev_classify(ap);\n\t\treturn 0;\n\t}\n\ndo_followup_srst:\n\t \n\treturn -EAGAIN;\n\nerr:\n\treturn -EIO;\n}\n\nstatic int sata_fsl_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t\t\tunsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct sata_fsl_port_priv *pp = ap->private_data;\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tint pmp = sata_srst_pmp(link);\n\tu32 temp;\n\tstruct ata_taskfile tf;\n\tu8 *cfis;\n\tu32 Serror;\n\n\tif (ata_link_offline(link)) {\n\t\t*class = ATA_DEV_NONE;\n\t\treturn 0;\n\t}\n\n\t \n\n\tata_tf_init(link->device, &tf);\n\tcfis = (u8 *) &pp->cmdentry->cfis;\n\n\t \n\tsata_fsl_setup_cmd_hdr_entry(ap, pp, 0,\n\t\tSRST_CMD | CMD_DESC_RES | CMD_DESC_SNOOP_ENABLE, 0, 0, 5);\n\n\ttf.ctl |= ATA_SRST;\t \n\tata_tf_to_fis(&tf, pmp, 0, cfis);\n\n\tata_port_dbg(ap, \"Dumping cfis : 0x%x, 0x%x, 0x%x, 0x%x\\n\",\n\t\tcfis[0], cfis[1], cfis[2], cfis[3]);\n\n\t \n\n\tata_port_dbg(ap, \"CQ = 0x%x, CA = 0x%x, CC = 0x%x\\n\",\n\t\tioread32(CQ + hcr_base),\n\t\tioread32(CA + hcr_base), ioread32(CC + hcr_base));\n\n\tiowrite32(0xFFFF, CC + hcr_base);\n\tif (pmp != SATA_PMP_CTRL_PORT)\n\t\tiowrite32(pmp, CQPMP + hcr_base);\n\tiowrite32(1, CQ + hcr_base);\n\n\ttemp = ata_wait_register(ap, CQ + hcr_base, 0x1, 0x1, 1, 5000);\n\tif (temp & 0x1) {\n\t\tata_port_warn(ap, \"ATA_SRST issue failed\\n\");\n\n\t\tata_port_dbg(ap, \"Softreset@5000,CQ=0x%x,CA=0x%x,CC=0x%x\\n\",\n\t\t\tioread32(CQ + hcr_base),\n\t\t\tioread32(CA + hcr_base), ioread32(CC + hcr_base));\n\n\t\tsata_fsl_scr_read(&ap->link, SCR_ERROR, &Serror);\n\n\t\tata_port_dbg(ap, \"HStatus = 0x%x HControl = 0x%x Serror = 0x%x\\n\",\n\t\t\t     ioread32(hcr_base + HSTATUS),\n\t\t\t     ioread32(hcr_base + HCONTROL),\n\t\t\t     Serror);\n\t\tgoto err;\n\t}\n\n\tata_msleep(ap, 1);\n\n\t \n\n\tsata_fsl_setup_cmd_hdr_entry(ap, pp, 0,\n\t\t\t\t     CMD_DESC_RES | CMD_DESC_SNOOP_ENABLE,\n\t\t\t\t     0, 0, 5);\n\n\ttf.ctl &= ~ATA_SRST;\t \n\tata_tf_to_fis(&tf, pmp, 0, cfis);\n\n\tif (pmp != SATA_PMP_CTRL_PORT)\n\t\tiowrite32(pmp, CQPMP + hcr_base);\n\tiowrite32(1, CQ + hcr_base);\n\tata_msleep(ap, 150);\t\t \n\n\t \n\tiowrite32(0x01, CC + hcr_base);\t \n\n\t*class = ATA_DEV_NONE;\n\n\t \n\tif (ata_link_online(link)) {\n\t\t \n\n\t\t*class = sata_fsl_dev_classify(ap);\n\n\t\tata_port_dbg(ap, \"ccreg = 0x%x\\n\", ioread32(hcr_base + CC));\n\t\tata_port_dbg(ap, \"cereg = 0x%x\\n\", ioread32(hcr_base + CE));\n\t}\n\n\treturn 0;\n\nerr:\n\treturn -EIO;\n}\n\nstatic void sata_fsl_error_handler(struct ata_port *ap)\n{\n\tsata_pmp_error_handler(ap);\n}\n\nstatic void sata_fsl_post_internal_cmd(struct ata_queued_cmd *qc)\n{\n\tif (qc->flags & ATA_QCFLAG_EH)\n\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\tif (qc->err_mask) {\n\t\t \n\n\t}\n}\n\nstatic void sata_fsl_error_intr(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 hstatus, dereg=0, cereg = 0, SError = 0;\n\tunsigned int err_mask = 0, action = 0;\n\tint freeze = 0, abort=0;\n\tstruct ata_link *link = NULL;\n\tstruct ata_queued_cmd *qc = NULL;\n\tstruct ata_eh_info *ehi;\n\n\thstatus = ioread32(hcr_base + HSTATUS);\n\tcereg = ioread32(hcr_base + CE);\n\n\t \n\tlink = &ap->link;\n\tehi = &link->eh_info;\n\tata_ehi_clear_desc(ehi);\n\n\t \n\n\tsata_fsl_scr_read(&ap->link, SCR_ERROR, &SError);\n\tif (unlikely(SError & 0xFFFF0000))\n\t\tsata_fsl_scr_write(&ap->link, SCR_ERROR, SError);\n\n\tata_port_dbg(ap, \"hStat=0x%x,CE=0x%x,DE =0x%x,SErr=0x%x\\n\",\n\t\thstatus, cereg, ioread32(hcr_base + DE), SError);\n\n\t \n\tif (hstatus & FATAL_ERROR_DECODE) {\n\t\tehi->err_mask |= AC_ERR_ATA_BUS;\n\t\tehi->action |= ATA_EH_SOFTRESET;\n\n\t\tfreeze = 1;\n\t}\n\n\t \n\tif (hstatus & INT_ON_SNOTIFY_UPDATE)\n\t\tsata_async_notification(ap);\n\n\t \n\tif (hstatus & INT_ON_PHYRDY_CHG) {\n\t\tata_port_dbg(ap, \"PHYRDY change indication\\n\");\n\n\t\t \n\t\tata_ehi_hotplugged(ehi);\n\t\tata_ehi_push_desc(ehi, \"%s\", \"PHY RDY changed\");\n\t\tfreeze = 1;\n\t}\n\n\t \n\tif (cereg) {\n\t\t \n\t\tabort = 1;\n\n\t\tata_port_dbg(ap, \"single device error, CE=0x%x, DE=0x%x\\n\",\n\t\t\tioread32(hcr_base + CE), ioread32(hcr_base + DE));\n\n\t\t \n\t\tif (ap->nr_pmp_links) {\n\t\t\tunsigned int dev_num;\n\n\t\t\tdereg = ioread32(hcr_base + DE);\n\t\t\tiowrite32(dereg, hcr_base + DE);\n\t\t\tiowrite32(cereg, hcr_base + CE);\n\n\t\t\tdev_num = ffs(dereg) - 1;\n\t\t\tif (dev_num < ap->nr_pmp_links && dereg != 0) {\n\t\t\t\tlink = &ap->pmp_link[dev_num];\n\t\t\t\tehi = &link->eh_info;\n\t\t\t\tqc = ata_qc_from_tag(ap, link->active_tag);\n\t\t\t\t \n\n\t\t\t\terr_mask |= AC_ERR_DEV;\n\n\t\t\t} else {\n\t\t\t\terr_mask |= AC_ERR_HSM;\n\t\t\t\taction |= ATA_EH_HARDRESET;\n\t\t\t\tfreeze = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdereg = ioread32(hcr_base + DE);\n\t\t\tiowrite32(dereg, hcr_base + DE);\n\t\t\tiowrite32(cereg, hcr_base + CE);\n\n\t\t\tqc = ata_qc_from_tag(ap, link->active_tag);\n\t\t\t \n\t\t\terr_mask |= AC_ERR_DEV;\n\t\t}\n\t}\n\n\t \n\tif (qc)\n\t\tqc->err_mask |= err_mask;\n\telse\n\t\tehi->err_mask |= err_mask;\n\n\tehi->action |= action;\n\n\t \n\tif (freeze)\n\t\tata_port_freeze(ap);\n\telse if (abort) {\n\t\tif (qc)\n\t\t\tata_link_abort(qc->dev->link);\n\t\telse\n\t\t\tata_port_abort(ap);\n\t}\n}\n\nstatic void sata_fsl_host_intr(struct ata_port *ap)\n{\n\tstruct sata_fsl_host_priv *host_priv = ap->host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 hstatus, done_mask = 0;\n\tstruct ata_queued_cmd *qc;\n\tu32 SError;\n\tu32 tag;\n\tu32 status_mask = INT_ON_ERROR;\n\n\thstatus = ioread32(hcr_base + HSTATUS);\n\n\tsata_fsl_scr_read(&ap->link, SCR_ERROR, &SError);\n\n\t \n\tdone_mask = ioread32(hcr_base + CC);\n\n\t \n\tif (unlikely(hstatus & INT_ON_DATA_LENGTH_MISMATCH)) {\n\t\tata_qc_for_each_with_internal(ap, qc, tag) {\n\t\t\tif (qc && ata_is_atapi(qc->tf.protocol)) {\n\t\t\t\tu32 hcontrol;\n\t\t\t\t \n\t\t\t\thcontrol = ioread32(hcr_base + HCONTROL);\n\t\t\t\tiowrite32(hcontrol | CLEAR_ERROR,\n\t\t\t\t\t\thcr_base + HCONTROL);\n\n\t\t\t\t \n\t\t\t\tiowrite32(hcontrol & ~CLEAR_ERROR,\n\t\t\t\t\t\thcr_base + HCONTROL);\n\n\t\t\t\t \n\t\t\t\tsata_fsl_scr_write(&ap->link, SCR_ERROR,\n\t\t\t\t\t\tSError);\n\n\t\t\t\t \n\t\t\t\tstatus_mask &= ~(INT_ON_SINGL_DEVICE_ERR\n\t\t\t\t\t\t| INT_ON_FATAL_ERR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(SError & 0xFFFF0000)) {\n\t\tata_port_dbg(ap, \"serror @host_intr : 0x%x\\n\", SError);\n\t\tsata_fsl_error_intr(ap);\n\t}\n\n\tif (unlikely(hstatus & status_mask)) {\n\t\tata_port_dbg(ap, \"error interrupt!!\\n\");\n\t\tsata_fsl_error_intr(ap);\n\t\treturn;\n\t}\n\n\tata_port_dbg(ap, \"Status of all queues :\\n\");\n\tata_port_dbg(ap, \"done_mask/CC = 0x%x, CA = 0x%x, CE=0x%x,CQ=0x%x,apqa=0x%llx\\n\",\n\t\tdone_mask,\n\t\tioread32(hcr_base + CA),\n\t\tioread32(hcr_base + CE),\n\t\tioread32(hcr_base + CQ),\n\t\tap->qc_active);\n\n\tif (done_mask & ap->qc_active) {\n\t\tint i;\n\t\t \n\t\tiowrite32(done_mask, hcr_base + CC);\n\n\t\tata_port_dbg(ap, \"Status of all queues: done_mask/CC = 0x%x, CA = 0x%x, CE=0x%x\\n\",\n\t\t\tdone_mask, ioread32(hcr_base + CA),\n\t\t\tioread32(hcr_base + CE));\n\n\t\tfor (i = 0; i < SATA_FSL_QUEUE_DEPTH; i++) {\n\t\t\tif (done_mask & (1 << i))\n\t\t\t\tata_port_dbg(ap, \"completing ncq cmd,tag=%d,CC=0x%x,CA=0x%x\\n\",\n\t\t\t\t     i, ioread32(hcr_base + CC),\n\t\t\t\t     ioread32(hcr_base + CA));\n\t\t}\n\t\tata_qc_complete_multiple(ap, ata_qc_get_active(ap) ^ done_mask);\n\t\treturn;\n\n\t} else if ((ap->qc_active & (1ULL << ATA_TAG_INTERNAL))) {\n\t\tiowrite32(1, hcr_base + CC);\n\t\tqc = ata_qc_from_tag(ap, ATA_TAG_INTERNAL);\n\n\t\tata_port_dbg(ap, \"completing non-ncq cmd, CC=0x%x\\n\",\n\t\t\t ioread32(hcr_base + CC));\n\n\t\tif (qc) {\n\t\t\tata_qc_complete(qc);\n\t\t}\n\t} else {\n\t\t \n\t\tata_port_dbg(ap, \"spurious interrupt!!, CC = 0x%x\\n\",\n\t\t\tioread32(hcr_base + CC));\n\t\tiowrite32(done_mask, hcr_base + CC);\n\t\treturn;\n\t}\n}\n\nstatic irqreturn_t sata_fsl_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 interrupt_enables;\n\tunsigned handled = 0;\n\tstruct ata_port *ap;\n\n\t \n\tinterrupt_enables = ioread32(hcr_base + HSTATUS);\n\tinterrupt_enables &= 0x3F;\n\n\tif (!interrupt_enables)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&host->lock);\n\n\t \n\n\tap = host->ports[0];\n\tif (ap) {\n\t\tsata_fsl_host_intr(ap);\n\t} else {\n\t\tdev_warn(host->dev, \"interrupt on disabled port 0\\n\");\n\t}\n\n\tiowrite32(interrupt_enables, hcr_base + HSTATUS);\n\thandled = 1;\n\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic int sata_fsl_init_controller(struct ata_host *host)\n{\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tu32 temp;\n\n\t \n\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32(temp & ~HCONTROL_LEGACY, hcr_base + HCONTROL);\n\n\t \n\ttemp = ioread32(hcr_base + HSTATUS);\n\tif (temp & 0x3F)\n\t\tiowrite32((temp & 0x3F), hcr_base + HSTATUS);\n\n\t \n\ttemp = ioread32(hcr_base + HCONTROL);\n\tiowrite32((temp & ~0x3F), hcr_base + HCONTROL);\n\n\t \n\tdev_dbg(host->dev, \"icc = 0x%x\\n\", ioread32(hcr_base + ICC));\n\tiowrite32(0x01000000, hcr_base + ICC);\n\n\t \n\tiowrite32(0x00000FFFF, hcr_base + CE);\n\tiowrite32(0x00000FFFF, hcr_base + DE);\n\n \t \n\tfsl_sata_set_irq_coalescing(host, intr_coalescing_count,\n\t\t\tintr_coalescing_ticks);\n\n\t \n\n\tdev_dbg(host->dev, \"HStatus = 0x%x HControl = 0x%x\\n\",\n\t\tioread32(hcr_base + HSTATUS), ioread32(hcr_base + HCONTROL));\n\n\treturn 0;\n}\n\nstatic void sata_fsl_host_stop(struct ata_host *host)\n{\n        struct sata_fsl_host_priv *host_priv = host->private_data;\n\n        iounmap(host_priv->hcr_base);\n        kfree(host_priv);\n}\n\n \nstatic const struct scsi_host_template sata_fsl_sht = {\n\tATA_NCQ_SHT_QD(\"sata_fsl\", SATA_FSL_QUEUE_DEPTH),\n\t.sg_tablesize = SATA_FSL_MAX_PRD_USABLE,\n\t.dma_boundary = ATA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations sata_fsl_ops = {\n\t.inherits\t\t= &sata_pmp_port_ops,\n\n\t.qc_defer = ata_std_qc_defer,\n\t.qc_prep = sata_fsl_qc_prep,\n\t.qc_issue = sata_fsl_qc_issue,\n\t.qc_fill_rtf = sata_fsl_qc_fill_rtf,\n\n\t.scr_read = sata_fsl_scr_read,\n\t.scr_write = sata_fsl_scr_write,\n\n\t.freeze = sata_fsl_freeze,\n\t.thaw = sata_fsl_thaw,\n\t.softreset = sata_fsl_softreset,\n\t.hardreset = sata_fsl_hardreset,\n\t.pmp_softreset = sata_fsl_softreset,\n\t.error_handler = sata_fsl_error_handler,\n\t.post_internal_cmd = sata_fsl_post_internal_cmd,\n\n\t.port_start = sata_fsl_port_start,\n\t.port_stop = sata_fsl_port_stop,\n\n\t.host_stop      = sata_fsl_host_stop,\n\n\t.pmp_attach = sata_fsl_pmp_attach,\n\t.pmp_detach = sata_fsl_pmp_detach,\n};\n\nstatic const struct ata_port_info sata_fsl_port_info[] = {\n\t{\n\t .flags = SATA_FSL_HOST_FLAGS,\n\t .pio_mask = ATA_PIO4,\n\t .udma_mask = ATA_UDMA6,\n\t .port_ops = &sata_fsl_ops,\n\t },\n};\n\nstatic int sata_fsl_probe(struct platform_device *ofdev)\n{\n\tint retval = -ENXIO;\n\tvoid __iomem *hcr_base = NULL;\n\tvoid __iomem *ssr_base = NULL;\n\tvoid __iomem *csr_base = NULL;\n\tstruct sata_fsl_host_priv *host_priv = NULL;\n\tint irq;\n\tstruct ata_host *host = NULL;\n\tu32 temp;\n\n\tstruct ata_port_info pi = sata_fsl_port_info[0];\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\n\tdev_info(&ofdev->dev, \"Sata FSL Platform/CSB Driver init\\n\");\n\n\thcr_base = of_iomap(ofdev->dev.of_node, 0);\n\tif (!hcr_base)\n\t\tgoto error_exit_with_cleanup;\n\n\tssr_base = hcr_base + 0x100;\n\tcsr_base = hcr_base + 0x140;\n\n\tif (!of_device_is_compatible(ofdev->dev.of_node, \"fsl,mpc8315-sata\")) {\n\t\ttemp = ioread32(csr_base + TRANSCFG);\n\t\ttemp = temp & 0xffffffe0;\n\t\tiowrite32(temp | TRANSCFG_RX_WATER_MARK, csr_base + TRANSCFG);\n\t}\n\n\tdev_dbg(&ofdev->dev, \"@reset i/o = 0x%x\\n\",\n\t\tioread32(csr_base + TRANSCFG));\n\n\thost_priv = kzalloc(sizeof(struct sata_fsl_host_priv), GFP_KERNEL);\n\tif (!host_priv)\n\t\tgoto error_exit_with_cleanup;\n\n\thost_priv->hcr_base = hcr_base;\n\thost_priv->ssr_base = ssr_base;\n\thost_priv->csr_base = csr_base;\n\n\tirq = platform_get_irq(ofdev, 0);\n\tif (irq < 0) {\n\t\tretval = irq;\n\t\tgoto error_exit_with_cleanup;\n\t}\n\thost_priv->irq = irq;\n\n\tif (of_device_is_compatible(ofdev->dev.of_node, \"fsl,pq-sata-v2\"))\n\t\thost_priv->data_snoop = DATA_SNOOP_ENABLE_V2;\n\telse\n\t\thost_priv->data_snoop = DATA_SNOOP_ENABLE_V1;\n\n\t \n\thost = ata_host_alloc_pinfo(&ofdev->dev, ppi, SATA_FSL_MAX_PORTS);\n\tif (!host) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_exit_with_cleanup;\n\t}\n\n\t \n\thost->private_data = host_priv;\n\n\t \n\tsata_fsl_init_controller(host);\n\n\t \n\tata_host_activate(host, irq, sata_fsl_interrupt, SATA_FSL_IRQ_FLAG,\n\t\t\t  &sata_fsl_sht);\n\n\thost_priv->intr_coalescing.show = fsl_sata_intr_coalescing_show;\n\thost_priv->intr_coalescing.store = fsl_sata_intr_coalescing_store;\n\tsysfs_attr_init(&host_priv->intr_coalescing.attr);\n\thost_priv->intr_coalescing.attr.name = \"intr_coalescing\";\n\thost_priv->intr_coalescing.attr.mode = S_IRUGO | S_IWUSR;\n\tretval = device_create_file(host->dev, &host_priv->intr_coalescing);\n\tif (retval)\n\t\tgoto error_exit_with_cleanup;\n\n\thost_priv->rx_watermark.show = fsl_sata_rx_watermark_show;\n\thost_priv->rx_watermark.store = fsl_sata_rx_watermark_store;\n\tsysfs_attr_init(&host_priv->rx_watermark.attr);\n\thost_priv->rx_watermark.attr.name = \"rx_watermark\";\n\thost_priv->rx_watermark.attr.mode = S_IRUGO | S_IWUSR;\n\tretval = device_create_file(host->dev, &host_priv->rx_watermark);\n\tif (retval) {\n\t\tdevice_remove_file(&ofdev->dev, &host_priv->intr_coalescing);\n\t\tgoto error_exit_with_cleanup;\n\t}\n\n\treturn 0;\n\nerror_exit_with_cleanup:\n\n\tif (host)\n\t\tata_host_detach(host);\n\n\tif (hcr_base)\n\t\tiounmap(hcr_base);\n\tkfree(host_priv);\n\n\treturn retval;\n}\n\nstatic void sata_fsl_remove(struct platform_device *ofdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(ofdev);\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\n\tdevice_remove_file(&ofdev->dev, &host_priv->intr_coalescing);\n\tdevice_remove_file(&ofdev->dev, &host_priv->rx_watermark);\n\n\tata_host_detach(host);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sata_fsl_suspend(struct platform_device *op, pm_message_t state)\n{\n\tstruct ata_host *host = platform_get_drvdata(op);\n\n\tata_host_suspend(host, state);\n\treturn 0;\n}\n\nstatic int sata_fsl_resume(struct platform_device *op)\n{\n\tstruct ata_host *host = platform_get_drvdata(op);\n\tstruct sata_fsl_host_priv *host_priv = host->private_data;\n\tint ret;\n\tvoid __iomem *hcr_base = host_priv->hcr_base;\n\tstruct ata_port *ap = host->ports[0];\n\tstruct sata_fsl_port_priv *pp = ap->private_data;\n\n\tret = sata_fsl_init_controller(host);\n\tif (ret) {\n\t\tdev_err(&op->dev, \"Error initializing hardware\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tiowrite32(pp->cmdslot_paddr & 0xffffffff, hcr_base + CHBA);\n\n\tiowrite32((ioread32(hcr_base + HCONTROL)\n\t\t\t\t| HCONTROL_ONLINE_PHY_RST\n\t\t\t\t| HCONTROL_SNOOP_ENABLE\n\t\t\t\t| HCONTROL_PMP_ATTACHED),\n\t\t\thcr_base + HCONTROL);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id fsl_sata_match[] = {\n\t{ .compatible = \"fsl,pq-sata\", },\n\t{ .compatible = \"fsl,pq-sata-v2\", },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, fsl_sata_match);\n\nstatic struct platform_driver fsl_sata_driver = {\n\t.driver = {\n\t\t.name = \"fsl-sata\",\n\t\t.of_match_table = fsl_sata_match,\n\t},\n\t.probe\t\t= sata_fsl_probe,\n\t.remove_new\t= sata_fsl_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= sata_fsl_suspend,\n\t.resume\t\t= sata_fsl_resume,\n#endif\n};\n\nmodule_platform_driver(fsl_sata_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ashish Kalra, Freescale Semiconductor\");\nMODULE_DESCRIPTION(\"Freescale 3.0Gbps SATA controller low level driver\");\nMODULE_VERSION(\"1.10\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}