{
  "module_name": "pata_sil680.c",
  "hash_id": "a6b60945d7fec57a893584eb09bb6d80ee4e66c1d32aee7e98c64620ad10bd3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_sil680.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_sil680\"\n#define DRV_VERSION \"0.4.9\"\n\n#define SIL680_MMIO_BAR\t\t5\n\n \n\nstatic int sil680_selreg(struct ata_port *ap, int r)\n{\n\treturn 0xA0 + (ap->port_no << 4) + r;\n}\n\n \n\nstatic int sil680_seldev(struct ata_port *ap, struct ata_device *adev, int r)\n{\n\treturn 0xA0 + (ap->port_no << 4) + r + (adev->devno << 1);\n}\n\n\n \n\nstatic int sil680_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint addr = sil680_selreg(ap, 0);\n\tu8 ata66;\n\n\tpci_read_config_byte(pdev, addr, &ata66);\n\tif (ata66 & 1)\n\t\treturn ATA_CBL_PATA80;\n\telse\n\t\treturn ATA_CBL_PATA40;\n}\n\n \n\nstatic void sil680_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u16 speed_p[5] = {\n\t\t0x328A, 0x2283, 0x1104, 0x10C3, 0x10C1\n\t};\n\tstatic const u16 speed_t[5] = {\n\t\t0x328A, 0x2283, 0x1281, 0x10C3, 0x10C1\n\t};\n\n\tint tfaddr = sil680_selreg(ap, 0x02);\n\tint addr = sil680_seldev(ap, adev, 0x04);\n\tint addr_mask = 0x80 + 4 * ap->port_no;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint pio = adev->pio_mode - XFER_PIO_0;\n\tint lowest_pio = pio;\n\tint port_shift = 4 * adev->devno;\n\tu16 reg;\n\tu8 mode;\n\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\n\tif (pair != NULL && adev->pio_mode > pair->pio_mode)\n\t\tlowest_pio = pair->pio_mode - XFER_PIO_0;\n\n\tpci_write_config_word(pdev, addr, speed_p[pio]);\n\tpci_write_config_word(pdev, tfaddr, speed_t[lowest_pio]);\n\n\tpci_read_config_word(pdev, tfaddr-2, &reg);\n\tpci_read_config_byte(pdev, addr_mask, &mode);\n\n\treg &= ~0x0200;\t\t\t \n\tmode &= ~(3 << port_shift);\t \n\n\tif (ata_pio_need_iordy(adev)) {\n\t\treg |= 0x0200;\t\t \n\t\tmode |= 1 << port_shift;\n\t}\n\tpci_write_config_word(pdev, tfaddr-2, reg);\n\tpci_write_config_byte(pdev, addr_mask, mode);\n}\n\n \n\nstatic void sil680_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 ultra_table[2][7] = {\n\t\t{ 0x0C, 0x07, 0x05, 0x04, 0x02, 0x01, 0xFF },\t \n\t\t{ 0x0F, 0x0B, 0x07, 0x05, 0x03, 0x02, 0x01 },\t \n\t};\n\tstatic const u16 dma_table[3] = { 0x2208, 0x10C2, 0x10C1 };\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint ma = sil680_seldev(ap, adev, 0x08);\n\tint ua = sil680_seldev(ap, adev, 0x0C);\n\tint addr_mask = 0x80 + 4 * ap->port_no;\n\tint port_shift = adev->devno * 4;\n\tu8 scsc, mode;\n\tu16 multi, ultra;\n\n\tpci_read_config_byte(pdev, 0x8A, &scsc);\n\tpci_read_config_byte(pdev, addr_mask, &mode);\n\tpci_read_config_word(pdev, ma, &multi);\n\tpci_read_config_word(pdev, ua, &ultra);\n\n\t \n\tultra &= ~0x3F;\n\tmode &= ~(0x03 << port_shift);\n\n\t \n\tscsc = (scsc & 0x30) ? 1 : 0;\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tmulti = 0x10C1;\n\t\tultra |= ultra_table[scsc][adev->dma_mode - XFER_UDMA_0];\n\t\tmode |= (0x03 << port_shift);\n\t} else {\n\t\tmulti = dma_table[adev->dma_mode - XFER_MW_DMA_0];\n\t\tmode |= (0x02 << port_shift);\n\t}\n\tpci_write_config_byte(pdev, addr_mask, mode);\n\tpci_write_config_word(pdev, ma, multi);\n\tpci_write_config_word(pdev, ua, ultra);\n}\n\n \nstatic void sil680_sff_exec_command(struct ata_port *ap,\n\t\t\t\t    const struct ata_taskfile *tf)\n{\n\tiowrite8(tf->command, ap->ioaddr.command_addr);\n\tioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);\n}\n\nstatic bool sil680_sff_irq_check(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tint addr\t\t= sil680_selreg(ap, 1);\n\tu8 val;\n\n\tpci_read_config_byte(pdev, addr, &val);\n\n\treturn val & 0x08;\n}\n\nstatic const struct scsi_host_template sil680_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n\nstatic struct ata_port_operations sil680_port_ops = {\n\t.inherits\t\t= &ata_bmdma32_port_ops,\n\t.sff_exec_command\t= sil680_sff_exec_command,\n\t.sff_irq_check\t\t= sil680_sff_irq_check,\n\t.cable_detect\t\t= sil680_cable_detect,\n\t.set_piomode\t\t= sil680_set_piomode,\n\t.set_dmamode\t\t= sil680_set_dmamode,\n};\n\n \n\nstatic u8 sil680_init_chip(struct pci_dev *pdev, int *try_mmio)\n{\n\tu8 tmpbyte\t= 0;\n\n\t \n\tpci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t      pdev->revision ? 1 : 255);\n\n\tpci_write_config_byte(pdev, 0x80, 0x00);\n\tpci_write_config_byte(pdev, 0x84, 0x00);\n\n\tpci_read_config_byte(pdev, 0x8A, &tmpbyte);\n\n\tdev_dbg(&pdev->dev, \"sil680: BA5_EN = %d clock = %02X\\n\",\n\t\ttmpbyte & 1, tmpbyte & 0x30);\n\n\t*try_mmio = 0;\n#ifdef CONFIG_PPC\n\tif (machine_is(cell))\n\t\t*try_mmio = (tmpbyte & 1) || pci_resource_start(pdev, 5);\n#endif\n\n\tswitch (tmpbyte & 0x30) {\n\tcase 0x00:\n\t\t \n\t\tpci_write_config_byte(pdev, 0x8A, tmpbyte|0x10);\n\t\tbreak;\n\tcase 0x30:\n\t\t \n\t\t \n\t\tpci_write_config_byte(pdev, 0x8A, tmpbyte & ~0x20);\n\t\tbreak;\n\tcase 0x10:\n\t\t \n\t\tbreak;\n\tcase 0x20:\n\t\t \n\t\tbreak;\n\t}\n\n\tpci_read_config_byte(pdev,   0x8A, &tmpbyte);\n\tdev_dbg(&pdev->dev, \"sil680: BA5_EN = %d clock = %02X\\n\",\n\t\ttmpbyte & 1, tmpbyte & 0x30);\n\n\tpci_write_config_byte(pdev,  0xA1, 0x72);\n\tpci_write_config_word(pdev,  0xA2, 0x328A);\n\tpci_write_config_dword(pdev, 0xA4, 0x62DD62DD);\n\tpci_write_config_dword(pdev, 0xA8, 0x43924392);\n\tpci_write_config_dword(pdev, 0xAC, 0x40094009);\n\tpci_write_config_byte(pdev,  0xB1, 0x72);\n\tpci_write_config_word(pdev,  0xB2, 0x328A);\n\tpci_write_config_dword(pdev, 0xB4, 0x62DD62DD);\n\tpci_write_config_dword(pdev, 0xB8, 0x43924392);\n\tpci_write_config_dword(pdev, 0xBC, 0x40094009);\n\n\tswitch (tmpbyte & 0x30) {\n\tcase 0x00:\n\t\tdev_info(&pdev->dev, \"sil680: 100MHz clock.\\n\");\n\t\tbreak;\n\tcase 0x10:\n\t\tdev_info(&pdev->dev, \"sil680: 133MHz clock.\\n\");\n\t\tbreak;\n\tcase 0x20:\n\t\tdev_info(&pdev->dev, \"sil680: Using PCI clock.\\n\");\n\t\tbreak;\n\t \n\tcase 0x30:\n\t\tdev_err(&pdev->dev, \"sil680: Clock disabled ?\\n\");\n\t}\n\treturn tmpbyte & 0x30;\n}\n\nstatic int sil680_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &sil680_port_ops\n\t};\n\tstatic const struct ata_port_info info_slow = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &sil680_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\tstruct ata_host *host;\n\tvoid __iomem *mmio_base;\n\tint rc, try_mmio;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (sil680_init_chip(pdev, &try_mmio)) {\n\t\tcase 0:\n\t\t\tppi[0] = &info_slow;\n\t\t\tbreak;\n\t\tcase 0x30:\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (!try_mmio)\n\t\tgoto use_ioports;\n\n\t \n\trc = pcim_iomap_regions(pdev, 1 << SIL680_MMIO_BAR, DRV_NAME);\n\tif (rc)\n\t\tgoto use_ioports;\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\n\tif (!host)\n\t\treturn -ENOMEM;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\t \n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\tpci_set_master(pdev);\n\n\t \n\tmmio_base = host->iomap[SIL680_MMIO_BAR];\n\thost->ports[0]->ioaddr.bmdma_addr = mmio_base + 0x00;\n\thost->ports[0]->ioaddr.cmd_addr = mmio_base + 0x80;\n\thost->ports[0]->ioaddr.ctl_addr = mmio_base + 0x8a;\n\thost->ports[0]->ioaddr.altstatus_addr = mmio_base + 0x8a;\n\tata_sff_std_ports(&host->ports[0]->ioaddr);\n\thost->ports[1]->ioaddr.bmdma_addr = mmio_base + 0x08;\n\thost->ports[1]->ioaddr.cmd_addr = mmio_base + 0xc0;\n\thost->ports[1]->ioaddr.ctl_addr = mmio_base + 0xca;\n\thost->ports[1]->ioaddr.altstatus_addr = mmio_base + 0xca;\n\tata_sff_std_ports(&host->ports[1]->ioaddr);\n\n\t \n\treturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\t IRQF_SHARED, &sil680_sht);\n\nuse_ioports:\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &sil680_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sil680_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint try_mmio, rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\tsil680_init_chip(pdev, &try_mmio);\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id sil680[] = {\n\t{ PCI_VDEVICE(CMD, PCI_DEVICE_ID_SII_680), },\n\n\t{ },\n};\n\nstatic struct pci_driver sil680_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= sil680,\n\t.probe \t\t= sil680_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= sil680_reinit_one,\n#endif\n};\n\nmodule_pci_driver(sil680_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for SI680 PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sil680);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}