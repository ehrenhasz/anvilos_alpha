{
  "module_name": "pata_hpt3x3.c",
  "hash_id": "a880b2d94b2596cb10acbd653b918584dc1682c017d708be4f63d87aa5bc2cbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_hpt3x3.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_hpt3x3\"\n#define DRV_VERSION\t\"0.6.1\"\n\n \n\nstatic void hpt3x3_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 r1, r2;\n\tint dn = 2 * ap->port_no + adev->devno;\n\n\tpci_read_config_dword(pdev, 0x44, &r1);\n\tpci_read_config_dword(pdev, 0x48, &r2);\n\t \n\tr1 &= ~(7 << (3 * dn));\n\tr1 |= (adev->pio_mode - XFER_PIO_0) << (3 * dn);\n\tr2 &= ~(0x11 << dn);\t \n\n\tpci_write_config_dword(pdev, 0x44, r1);\n\tpci_write_config_dword(pdev, 0x48, r2);\n}\n\n#if defined(CONFIG_PATA_HPT3X3_DMA)\n \n\nstatic void hpt3x3_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 r1, r2;\n\tint dn = 2 * ap->port_no + adev->devno;\n\tint mode_num = adev->dma_mode & 0x0F;\n\n\tpci_read_config_dword(pdev, 0x44, &r1);\n\tpci_read_config_dword(pdev, 0x48, &r2);\n\t \n\tr1 &= ~(7 << (3 * dn));\n\tr1 |= (mode_num << (3 * dn));\n\tr2 &= ~(0x11 << dn);\t \n\n\tif (adev->dma_mode >= XFER_UDMA_0)\n\t\tr2 |= (0x01 << dn);\t \n\telse\n\t\tr2 |= (0x10 << dn);\t \n\n\tpci_write_config_dword(pdev, 0x44, r1);\n\tpci_write_config_dword(pdev, 0x48, r2);\n}\n\n \n\nstatic void hpt3x3_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\n\n\tiowrite8(ioread8(mmio + ATA_DMA_CMD) & ~ ATA_DMA_START,\n\t\t\tmmio + ATA_DMA_CMD);\n\tata_sff_dma_pause(ap);\n\tata_sff_freeze(ap);\n}\n\n \n\nstatic void hpt3x3_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tu8 r = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);\n\tr |= ATA_DMA_INTR | ATA_DMA_ERR;\n\tiowrite8(r, ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);\n\treturn ata_bmdma_setup(qc);\n}\n\n \n\nstatic int hpt3x3_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn 1;\n}\n\n#endif  \n\nstatic const struct scsi_host_template hpt3x3_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations hpt3x3_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= hpt3x3_set_piomode,\n#if defined(CONFIG_PATA_HPT3X3_DMA)\n\t.set_dmamode\t= hpt3x3_set_dmamode,\n\t.bmdma_setup\t= hpt3x3_bmdma_setup,\n\t.check_atapi_dma= hpt3x3_atapi_dma,\n\t.freeze\t\t= hpt3x3_freeze,\n#endif\n\n};\n\n \n\nstatic void hpt3x3_init_chipset(struct pci_dev *dev)\n{\n\tu16 cmd;\n\t \n\tpci_write_config_word(dev, 0x80, 0x00);\n\t \n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\tif (cmd & PCI_COMMAND_MEMORY)\n\t\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xF0);\n\telse\n\t\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);\n}\n\n \n\nstatic int hpt3x3_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n#if defined(CONFIG_PATA_HPT3X3_DMA)\n\t\t \n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA2,\n#endif\n\t\t.port_ops = &hpt3x3_port_ops\n\t};\n\t \n\tstatic const u8 offset_cmd[2] = { 0x20, 0x28 };\n\tstatic const u8 offset_ctl[2] = { 0x36, 0x3E };\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\tstruct ata_host *host;\n\tint i, rc;\n\tvoid __iomem *base;\n\n\thpt3x3_init_chipset(pdev);\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\n\tif (!host)\n\t\treturn -ENOMEM;\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = pcim_iomap_regions(pdev, 1 << 4, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\tbase = host->iomap[4];\t \n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\t\tioaddr->cmd_addr = base + offset_cmd[i];\n\t\tioaddr->altstatus_addr =\n\t\tioaddr->ctl_addr = base + offset_ctl[i];\n\t\tioaddr->scr_addr = NULL;\n\t\tata_sff_std_ports(ioaddr);\n\t\tioaddr->bmdma_addr = base + 8 * i;\n\n\t\tata_port_pbar_desc(ap, 4, -1, \"ioport\");\n\t\tata_port_pbar_desc(ap, 4, offset_cmd[i], \"cmd\");\n\t}\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\t IRQF_SHARED, &hpt3x3_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hpt3x3_reinit_one(struct pci_dev *dev)\n{\n\tstruct ata_host *host = pci_get_drvdata(dev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(dev);\n\tif (rc)\n\t\treturn rc;\n\n\thpt3x3_init_chipset(dev);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id hpt3x3[] = {\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT343), },\n\n\t{ },\n};\n\nstatic struct pci_driver hpt3x3_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= hpt3x3,\n\t.probe \t\t= hpt3x3_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= hpt3x3_reinit_one,\n#endif\n};\n\nmodule_pci_driver(hpt3x3_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the Highpoint HPT343/363\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, hpt3x3);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}