{
  "module_name": "ahci_da850.c",
  "hash_id": "9f0b77c63e6910b77faf46e53564e32422cd7612ea523df732549bfe096de109",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_da850.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/libata.h>\n#include <linux/ahci_platform.h>\n#include \"ahci.h\"\n\n#define DRV_NAME\t\t\"ahci_da850\"\n#define HARDRESET_RETRIES\t5\n\n \n#define SATA_P0PHYCR_REG\t0x178\n\n#define SATA_PHY_MPY(x)\t\t((x) << 0)\n#define SATA_PHY_LOS(x)\t\t((x) << 6)\n#define SATA_PHY_RXCDR(x)\t((x) << 10)\n#define SATA_PHY_RXEQ(x)\t((x) << 13)\n#define SATA_PHY_TXSWING(x)\t((x) << 19)\n#define SATA_PHY_ENPLL(x)\t((x) << 31)\n\nstatic void da850_sata_init(struct device *dev, void __iomem *pwrdn_reg,\n\t\t\t    void __iomem *ahci_base, u32 mpy)\n{\n\tunsigned int val;\n\n\t \n\tval = readl(pwrdn_reg);\n\tval &= ~BIT(0);\n\twritel(val, pwrdn_reg);\n\n\tval = SATA_PHY_MPY(mpy) | SATA_PHY_LOS(1) | SATA_PHY_RXCDR(4) |\n\t      SATA_PHY_RXEQ(1) | SATA_PHY_TXSWING(3) | SATA_PHY_ENPLL(1);\n\n\twritel(val, ahci_base + SATA_P0PHYCR_REG);\n}\n\nstatic u32 ahci_da850_calculate_mpy(unsigned long refclk_rate)\n{\n\tu32 pll_output = 1500000000, needed;\n\n\t \n\tWARN((refclk_rate % 10) != 0, \"refclk must be divisible by 10\");\n\tneeded = pll_output / (refclk_rate / 10);\n\n\t \n\n\tswitch (needed) {\n\tcase 50:\n\t\treturn 0x1;\n\tcase 60:\n\t\treturn 0x2;\n\tcase 80:\n\t\treturn 0x4;\n\tcase 100:\n\t\treturn 0x5;\n\tcase 120:\n\t\treturn 0x6;\n\tcase 125:\n\t\treturn 0x7;\n\tcase 150:\n\t\treturn 0x8;\n\tcase 200:\n\t\treturn 0x9;\n\tcase 250:\n\t\treturn 0xa;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic int ahci_da850_softreset(struct ata_link *link,\n\t\t\t\tunsigned int *class, unsigned long deadline)\n{\n\tint pmp, ret;\n\n\tpmp = sata_srst_pmp(link);\n\n\t \n\tret = ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);\n\tif (pmp && ret == -EBUSY)\n\t\treturn ahci_do_softreset(link, class, 0,\n\t\t\t\t\t deadline, ahci_check_ready);\n\n\treturn ret;\n}\n\nstatic int ahci_da850_hardreset(struct ata_link *link,\n\t\t\t\tunsigned int *class, unsigned long deadline)\n{\n\tint ret, retry = HARDRESET_RETRIES;\n\tbool online;\n\n\t \n\tdo {\n\t\tret = ahci_do_hardreset(link, class, deadline, &online);\n\t\tif (online)\n\t\t\treturn ret;\n\t} while (retry--);\n\n\treturn ret;\n}\n\nstatic struct ata_port_operations ahci_da850_port_ops = {\n\t.inherits = &ahci_platform_ops,\n\t.softreset = ahci_da850_softreset,\n\t \n\t.hardreset = ahci_da850_hardreset,\n\t.pmp_hardreset = ahci_da850_hardreset,\n};\n\nstatic const struct ata_port_info ahci_da850_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_da850_port_ops,\n};\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int ahci_da850_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tvoid __iomem *pwrdn_reg;\n\tstruct resource *res;\n\tu32 mpy;\n\tint rc;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\t \n\tif (hpriv->n_clks < 2) {\n\t\thpriv->clks = devm_kcalloc(dev, 2, sizeof(*hpriv->clks), GFP_KERNEL);\n\t\tif (!hpriv->clks)\n\t\t\treturn -ENOMEM;\n\n\t\thpriv->clks[0].id = \"fck\";\n\t\thpriv->clks[1].id = \"refclk\";\n\t\thpriv->n_clks = 2;\n\n\t\trc = devm_clk_bulk_get(dev, hpriv->n_clks, hpriv->clks);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tmpy = ahci_da850_calculate_mpy(clk_get_rate(hpriv->clks[1].clk));\n\tif (mpy == 0) {\n\t\tdev_err(dev, \"invalid REFCLK multiplier value: 0x%x\", mpy);\n\t\treturn -EINVAL;\n\t}\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\trc = -ENODEV;\n\t\tgoto disable_resources;\n\t}\n\n\tpwrdn_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!pwrdn_reg) {\n\t\trc = -ENOMEM;\n\t\tgoto disable_resources;\n\t}\n\n\tda850_sata_init(dev, pwrdn_reg, hpriv->mmio, mpy);\n\n\trc = ahci_platform_init_host(pdev, hpriv, &ahci_da850_port_info,\n\t\t\t\t     &ahci_platform_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahci_da850_pm_ops, ahci_platform_suspend,\n\t\t\t ahci_platform_resume);\n\nstatic const struct of_device_id ahci_da850_of_match[] = {\n\t{ .compatible = \"ti,da850-ahci\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_da850_of_match);\n\nstatic struct platform_driver ahci_da850_driver = {\n\t.probe = ahci_da850_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_da850_of_match,\n\t\t.pm = &ahci_da850_pm_ops,\n\t},\n};\nmodule_platform_driver(ahci_da850_driver);\n\nMODULE_DESCRIPTION(\"DaVinci DA850 AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}