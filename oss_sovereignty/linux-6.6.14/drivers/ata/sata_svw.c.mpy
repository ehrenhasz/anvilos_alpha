{
  "module_name": "sata_svw.c",
  "hash_id": "3e071bf6e106d3c581a5b82cfb7a6e6fa136e534e944402cc5365f956b33bf3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_svw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi.h>\n#include <linux/libata.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#define DRV_NAME\t\"sata_svw\"\n#define DRV_VERSION\t\"2.3\"\n\nenum {\n\t \n\tK2_FLAG_SATA_8_PORTS\t\t= (1 << 24),\n\tK2_FLAG_NO_ATAPI_DMA\t\t= (1 << 25),\n\tK2_FLAG_BAR_POS_3\t\t\t= (1 << 26),\n\n\t \n\tK2_SATA_TF_CMD_OFFSET\t\t= 0x00,\n\tK2_SATA_TF_DATA_OFFSET\t\t= 0x00,\n\tK2_SATA_TF_ERROR_OFFSET\t\t= 0x04,\n\tK2_SATA_TF_NSECT_OFFSET\t\t= 0x08,\n\tK2_SATA_TF_LBAL_OFFSET\t\t= 0x0c,\n\tK2_SATA_TF_LBAM_OFFSET\t\t= 0x10,\n\tK2_SATA_TF_LBAH_OFFSET\t\t= 0x14,\n\tK2_SATA_TF_DEVICE_OFFSET\t= 0x18,\n\tK2_SATA_TF_CMDSTAT_OFFSET      \t= 0x1c,\n\tK2_SATA_TF_CTL_OFFSET\t\t= 0x20,\n\n\t \n\tK2_SATA_DMA_CMD_OFFSET\t\t= 0x30,\n\n\t \n\tK2_SATA_SCR_STATUS_OFFSET\t= 0x40,\n\tK2_SATA_SCR_ERROR_OFFSET\t= 0x44,\n\tK2_SATA_SCR_CONTROL_OFFSET\t= 0x48,\n\n\t \n\tK2_SATA_SICR1_OFFSET\t\t= 0x80,\n\tK2_SATA_SICR2_OFFSET\t\t= 0x84,\n\tK2_SATA_SIM_OFFSET\t\t= 0x88,\n\n\t \n\tK2_SATA_PORT_OFFSET\t\t= 0x100,\n\n\tchip_svw4\t\t\t= 0,\n\tchip_svw8\t\t\t= 1,\n\tchip_svw42\t\t\t= 2,\t \n\tchip_svw43\t\t\t= 3,\t \n};\n\nstatic u8 k2_stat_check_status(struct ata_port *ap);\n\n\nstatic int k2_sata_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\tu8 cmnd = qc->scsicmd->cmnd[0];\n\n\tif (qc->ap->flags & K2_FLAG_NO_ATAPI_DMA)\n\t\treturn -1;\t \n\telse {\n\t\tswitch (cmnd) {\n\t\tcase READ_10:\n\t\tcase READ_12:\n\t\tcase READ_16:\n\t\tcase WRITE_10:\n\t\tcase WRITE_12:\n\t\tcase WRITE_16:\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t}\n}\n\nstatic int k2_sata_scr_read(struct ata_link *link,\n\t\t\t    unsigned int sc_reg, u32 *val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\t*val = readl(link->ap->ioaddr.scr_addr + (sc_reg * 4));\n\treturn 0;\n}\n\n\nstatic int k2_sata_scr_write(struct ata_link *link,\n\t\t\t     unsigned int sc_reg, u32 val)\n{\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\twritel(val, link->ap->ioaddr.scr_addr + (sc_reg * 4));\n\treturn 0;\n}\n\nstatic int k2_sata_softreset(struct ata_link *link,\n\t\t\t     unsigned int *class, unsigned long deadline)\n{\n\tu8 dmactl;\n\tvoid __iomem *mmio = link->ap->ioaddr.bmdma_addr;\n\n\tdmactl = readb(mmio + ATA_DMA_CMD);\n\n\t \n\tif (dmactl & ATA_DMA_START) {\n\t\tdmactl &= ~ATA_DMA_START;\n\t\twriteb(dmactl, mmio + ATA_DMA_CMD);\n\t}\n\n\treturn ata_sff_softreset(link, class, deadline);\n}\n\nstatic int k2_sata_hardreset(struct ata_link *link,\n\t\t\t     unsigned int *class, unsigned long deadline)\n{\n\tu8 dmactl;\n\tvoid __iomem *mmio = link->ap->ioaddr.bmdma_addr;\n\n\tdmactl = readb(mmio + ATA_DMA_CMD);\n\n\t \n\tif (dmactl & ATA_DMA_START) {\n\t\tdmactl &= ~ATA_DMA_START;\n\t\twriteb(dmactl, mmio + ATA_DMA_CMD);\n\t}\n\n\treturn sata_sff_hardreset(link, class, deadline);\n}\n\nstatic void k2_sata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\n\n\tif (tf->ctl != ap->last_ctl) {\n\t\twriteb(tf->ctl, ioaddr->ctl_addr);\n\t\tap->last_ctl = tf->ctl;\n\t\tata_wait_idle(ap);\n\t}\n\tif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\n\t\twritew(tf->feature | (((u16)tf->hob_feature) << 8),\n\t\t       ioaddr->feature_addr);\n\t\twritew(tf->nsect | (((u16)tf->hob_nsect) << 8),\n\t\t       ioaddr->nsect_addr);\n\t\twritew(tf->lbal | (((u16)tf->hob_lbal) << 8),\n\t\t       ioaddr->lbal_addr);\n\t\twritew(tf->lbam | (((u16)tf->hob_lbam) << 8),\n\t\t       ioaddr->lbam_addr);\n\t\twritew(tf->lbah | (((u16)tf->hob_lbah) << 8),\n\t\t       ioaddr->lbah_addr);\n\t} else if (is_addr) {\n\t\twritew(tf->feature, ioaddr->feature_addr);\n\t\twritew(tf->nsect, ioaddr->nsect_addr);\n\t\twritew(tf->lbal, ioaddr->lbal_addr);\n\t\twritew(tf->lbam, ioaddr->lbam_addr);\n\t\twritew(tf->lbah, ioaddr->lbah_addr);\n\t}\n\n\tif (tf->flags & ATA_TFLAG_DEVICE)\n\t\twriteb(tf->device, ioaddr->device_addr);\n\n\tata_wait_idle(ap);\n}\n\n\nstatic void k2_sata_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tu16 nsect, lbal, lbam, lbah, error;\n\n\ttf->status = k2_stat_check_status(ap);\n\ttf->device = readw(ioaddr->device_addr);\n\terror = readw(ioaddr->error_addr);\n\tnsect = readw(ioaddr->nsect_addr);\n\tlbal = readw(ioaddr->lbal_addr);\n\tlbam = readw(ioaddr->lbam_addr);\n\tlbah = readw(ioaddr->lbah_addr);\n\n\ttf->error = error;\n\ttf->nsect = nsect;\n\ttf->lbal = lbal;\n\ttf->lbam = lbam;\n\ttf->lbah = lbah;\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\ttf->hob_feature = error >> 8;\n\t\ttf->hob_nsect = nsect >> 8;\n\t\ttf->hob_lbal = lbal >> 8;\n\t\ttf->hob_lbam = lbam >> 8;\n\t\ttf->hob_lbah = lbah >> 8;\n\t}\n}\n\n \n\nstatic void k2_bmdma_setup_mmio(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tunsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);\n\tu8 dmactl;\n\tvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\n\n\t \n\tmb();\t \n\twritel(ap->bmdma_prd_dma, mmio + ATA_DMA_TABLE_OFS);\n\n\t \n\tdmactl = readb(mmio + ATA_DMA_CMD);\n\tdmactl &= ~(ATA_DMA_WR | ATA_DMA_START);\n\tif (!rw)\n\t\tdmactl |= ATA_DMA_WR;\n\twriteb(dmactl, mmio + ATA_DMA_CMD);\n\n\t \n\tif (qc->tf.protocol != ATA_PROT_DMA)\n\t\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\n \n\nstatic void k2_bmdma_start_mmio(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\n\tu8 dmactl;\n\n\t \n\tdmactl = readb(mmio + ATA_DMA_CMD);\n\twriteb(dmactl | ATA_DMA_START, mmio + ATA_DMA_CMD);\n\t \n\t \n\tif (qc->tf.protocol == ATA_PROT_DMA)\n\t\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\n\nstatic u8 k2_stat_check_status(struct ata_port *ap)\n{\n\treturn readl(ap->ioaddr.status_addr);\n}\n\nstatic int k2_sata_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct ata_port *ap;\n\tstruct device_node *np;\n\tint index;\n\n\t \n\tap = ata_shost_to_port(shost);\n\tif (ap == NULL)\n\t\treturn 0;\n\n\t \n\tnp = pci_device_to_OF_node(to_pci_dev(ap->host->dev));\n\tif (np == NULL)\n\t\treturn 0;\n\n\t \n\tindex = (ap == ap->host->ports[0]) ? 0 : 1;\n\tfor (np = np->child; np != NULL; np = np->sibling) {\n\t\tu64 reg;\n\n\t\tif (of_property_read_reg(np, 0, &reg, NULL))\n\t\t\tcontinue;\n\t\tif (index == reg) {\n\t\t\tseq_printf(m, \"devspec: %pOF\\n\", np);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct scsi_host_template k2_sata_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n\t.show_info\t\t= k2_sata_show_info,\n};\n\n\nstatic struct ata_port_operations k2_sata_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.softreset              = k2_sata_softreset,\n\t.hardreset              = k2_sata_hardreset,\n\t.sff_tf_load\t\t= k2_sata_tf_load,\n\t.sff_tf_read\t\t= k2_sata_tf_read,\n\t.sff_check_status\t= k2_stat_check_status,\n\t.check_atapi_dma\t= k2_sata_check_atapi_dma,\n\t.bmdma_setup\t\t= k2_bmdma_setup_mmio,\n\t.bmdma_start\t\t= k2_bmdma_start_mmio,\n\t.scr_read\t\t= k2_sata_scr_read,\n\t.scr_write\t\t= k2_sata_scr_write,\n};\n\nstatic const struct ata_port_info k2_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA | K2_FLAG_NO_ATAPI_DMA,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &k2_sata_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA | K2_FLAG_NO_ATAPI_DMA |\n\t\t\t\t  K2_FLAG_SATA_8_PORTS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &k2_sata_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA | K2_FLAG_BAR_POS_3,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &k2_sata_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &k2_sata_ops,\n\t},\n};\n\nstatic void k2_sata_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t= base + K2_SATA_TF_CMD_OFFSET;\n\tport->data_addr\t\t= base + K2_SATA_TF_DATA_OFFSET;\n\tport->feature_addr\t=\n\tport->error_addr\t= base + K2_SATA_TF_ERROR_OFFSET;\n\tport->nsect_addr\t= base + K2_SATA_TF_NSECT_OFFSET;\n\tport->lbal_addr\t\t= base + K2_SATA_TF_LBAL_OFFSET;\n\tport->lbam_addr\t\t= base + K2_SATA_TF_LBAM_OFFSET;\n\tport->lbah_addr\t\t= base + K2_SATA_TF_LBAH_OFFSET;\n\tport->device_addr\t= base + K2_SATA_TF_DEVICE_OFFSET;\n\tport->command_addr\t=\n\tport->status_addr\t= base + K2_SATA_TF_CMDSTAT_OFFSET;\n\tport->altstatus_addr\t=\n\tport->ctl_addr\t\t= base + K2_SATA_TF_CTL_OFFSET;\n\tport->bmdma_addr\t= base + K2_SATA_DMA_CMD_OFFSET;\n\tport->scr_addr\t\t= base + K2_SATA_SCR_STATUS_OFFSET;\n}\n\n\nstatic int k2_sata_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tconst struct ata_port_info *ppi[] =\n\t\t{ &k2_port_info[ent->driver_data], NULL };\n\tstruct ata_host *host;\n\tvoid __iomem *mmio_base;\n\tint n_ports, i, rc, bar_pos;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\tn_ports = 4;\n\tif (ppi[0]->flags & K2_FLAG_SATA_8_PORTS)\n\t\tn_ports = 8;\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tbar_pos = 5;\n\tif (ppi[0]->flags & K2_FLAG_BAR_POS_3)\n\t\tbar_pos = 3;\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (pci_resource_len(pdev, bar_pos) == 0) {\n\t\t \n\t\tpcim_pin_device(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trc = pcim_iomap_regions(pdev, 1 << bar_pos, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\tmmio_base = host->iomap[bar_pos];\n\n\t \n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tunsigned int offset = i * K2_SATA_PORT_OFFSET;\n\n\t\tk2_sata_setup_port(&ap->ioaddr, mmio_base + offset);\n\n\t\tata_port_pbar_desc(ap, 5, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, 5, offset, \"port\");\n\t}\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\twritel(readl(mmio_base + K2_SATA_SICR1_OFFSET) & ~0x00040000,\n\t       mmio_base + K2_SATA_SICR1_OFFSET);\n\n\t \n\twritel(0xffffffff, mmio_base + K2_SATA_SCR_ERROR_OFFSET);\n\twritel(0x0, mmio_base + K2_SATA_SIM_OFFSET);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\t IRQF_SHARED, &k2_sata_sht);\n}\n\n \nstatic const struct pci_device_id k2_sata_pci_tbl[] = {\n\t{ PCI_VDEVICE(SERVERWORKS, 0x0240), chip_svw4 },\n\t{ PCI_VDEVICE(SERVERWORKS, 0x0241), chip_svw8 },\n\t{ PCI_VDEVICE(SERVERWORKS, 0x0242), chip_svw4 },\n\t{ PCI_VDEVICE(SERVERWORKS, 0x024a), chip_svw4 },\n\t{ PCI_VDEVICE(SERVERWORKS, 0x024b), chip_svw4 },\n\t{ PCI_VDEVICE(SERVERWORKS, 0x0410), chip_svw42 },\n\t{ PCI_VDEVICE(SERVERWORKS, 0x0411), chip_svw43 },\n\n\t{ }\n};\n\nstatic struct pci_driver k2_sata_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= k2_sata_pci_tbl,\n\t.probe\t\t\t= k2_sata_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\nmodule_pci_driver(k2_sata_pci_driver);\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt\");\nMODULE_DESCRIPTION(\"low-level driver for K2 SATA controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, k2_sata_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}