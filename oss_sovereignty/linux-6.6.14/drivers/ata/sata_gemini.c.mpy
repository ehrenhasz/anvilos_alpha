{
  "module_name": "sata_gemini.c",
  "hash_id": "3299040796912abe310f726c16af916561a1ba1e01678f9b4420edf49f6bfa62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_gemini.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/reset.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/pinctrl/consumer.h>\n#include \"sata_gemini.h\"\n\n#define DRV_NAME \"gemini_sata_bridge\"\n\n \nstruct sata_gemini {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tenum gemini_muxmode muxmode;\n\tbool ide_pins;\n\tbool sata_bridge;\n\tstruct reset_control *sata0_reset;\n\tstruct reset_control *sata1_reset;\n\tstruct clk *sata0_pclk;\n\tstruct clk *sata1_pclk;\n};\n\n \n#define GEMINI_GLOBAL_MISC_CTRL\t\t0x30\n \n#define GEMINI_IDE_IOMUX_MASK\t\t\t(7 << 24)\n#define GEMINI_IDE_IOMUX_MODE0\t\t\t(0 << 24)\n#define GEMINI_IDE_IOMUX_MODE1\t\t\t(1 << 24)\n#define GEMINI_IDE_IOMUX_MODE2\t\t\t(2 << 24)\n#define GEMINI_IDE_IOMUX_MODE3\t\t\t(3 << 24)\n#define GEMINI_IDE_IOMUX_SHIFT\t\t\t(24)\n\n \n#define GEMINI_SATA_ID\t\t\t\t0x00\n#define GEMINI_SATA_PHY_ID\t\t\t0x04\n#define GEMINI_SATA0_STATUS\t\t\t0x08\n#define GEMINI_SATA1_STATUS\t\t\t0x0c\n#define GEMINI_SATA0_CTRL\t\t\t0x18\n#define GEMINI_SATA1_CTRL\t\t\t0x1c\n\n#define GEMINI_SATA_STATUS_BIST_DONE\t\tBIT(5)\n#define GEMINI_SATA_STATUS_BIST_OK\t\tBIT(4)\n#define GEMINI_SATA_STATUS_PHY_READY\t\tBIT(0)\n\n#define GEMINI_SATA_CTRL_PHY_BIST_EN\t\tBIT(14)\n#define GEMINI_SATA_CTRL_PHY_FORCE_IDLE\t\tBIT(13)\n#define GEMINI_SATA_CTRL_PHY_FORCE_READY\tBIT(12)\n#define GEMINI_SATA_CTRL_PHY_AFE_LOOP_EN\tBIT(10)\n#define GEMINI_SATA_CTRL_PHY_DIG_LOOP_EN\tBIT(9)\n#define GEMINI_SATA_CTRL_HOTPLUG_DETECT_EN\tBIT(4)\n#define GEMINI_SATA_CTRL_ATAPI_EN\t\tBIT(3)\n#define GEMINI_SATA_CTRL_BUS_WITH_20\t\tBIT(2)\n#define GEMINI_SATA_CTRL_SLAVE_EN\t\tBIT(1)\n#define GEMINI_SATA_CTRL_EN\t\t\tBIT(0)\n\n \nstatic struct sata_gemini *sg_singleton;\n\nstruct sata_gemini *gemini_sata_bridge_get(void)\n{\n\tif (sg_singleton)\n\t\treturn sg_singleton;\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL(gemini_sata_bridge_get);\n\nbool gemini_sata_bridge_enabled(struct sata_gemini *sg, bool is_ata1)\n{\n\tif (!sg->sata_bridge)\n\t\treturn false;\n\t \n\tif ((sg->muxmode == GEMINI_MUXMODE_2) &&\n\t    !is_ata1)\n\t\treturn false;\n\tif ((sg->muxmode == GEMINI_MUXMODE_3) &&\n\t    is_ata1)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(gemini_sata_bridge_enabled);\n\nenum gemini_muxmode gemini_sata_get_muxmode(struct sata_gemini *sg)\n{\n\treturn sg->muxmode;\n}\nEXPORT_SYMBOL(gemini_sata_get_muxmode);\n\nstatic int gemini_sata_setup_bridge(struct sata_gemini *sg,\n\t\t\t\t    unsigned int bridge)\n{\n\tunsigned long timeout = jiffies + (HZ * 1);\n\tbool bridge_online;\n\tu32 val;\n\n\tif (bridge == 0) {\n\t\tval = GEMINI_SATA_CTRL_HOTPLUG_DETECT_EN | GEMINI_SATA_CTRL_EN;\n\t\t \n\t\tif (sg->muxmode == GEMINI_MUXMODE_2)\n\t\t\tval |= GEMINI_SATA_CTRL_SLAVE_EN;\n\t\twritel(val, sg->base + GEMINI_SATA0_CTRL);\n\t} else {\n\t\tval = GEMINI_SATA_CTRL_HOTPLUG_DETECT_EN | GEMINI_SATA_CTRL_EN;\n\t\t \n\t\tif (sg->muxmode == GEMINI_MUXMODE_3)\n\t\t\tval |= GEMINI_SATA_CTRL_SLAVE_EN;\n\t\twritel(val, sg->base + GEMINI_SATA1_CTRL);\n\t}\n\n\t \n\tmsleep(10);\n\n\t \n\tdo {\n\t\tmsleep(100);\n\n\t\tif (bridge == 0)\n\t\t\tval = readl(sg->base + GEMINI_SATA0_STATUS);\n\t\telse\n\t\t\tval = readl(sg->base + GEMINI_SATA1_STATUS);\n\t\tif (val & GEMINI_SATA_STATUS_PHY_READY)\n\t\t\tbreak;\n\t} while (time_before(jiffies, timeout));\n\n\tbridge_online = !!(val & GEMINI_SATA_STATUS_PHY_READY);\n\n\tdev_info(sg->dev, \"SATA%d PHY %s\\n\", bridge,\n\t\t bridge_online ? \"ready\" : \"not ready\");\n\n\treturn bridge_online ? 0: -ENODEV;\n}\n\nint gemini_sata_start_bridge(struct sata_gemini *sg, unsigned int bridge)\n{\n\tstruct clk *pclk;\n\tint ret;\n\n\tif (bridge == 0)\n\t\tpclk = sg->sata0_pclk;\n\telse\n\t\tpclk = sg->sata1_pclk;\n\tclk_enable(pclk);\n\tmsleep(10);\n\n\t \n\tret = gemini_sata_setup_bridge(sg, bridge);\n\tif (ret)\n\t\tclk_disable(pclk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(gemini_sata_start_bridge);\n\nvoid gemini_sata_stop_bridge(struct sata_gemini *sg, unsigned int bridge)\n{\n\tif (bridge == 0)\n\t\tclk_disable(sg->sata0_pclk);\n\telse if (bridge == 1)\n\t\tclk_disable(sg->sata1_pclk);\n}\nEXPORT_SYMBOL(gemini_sata_stop_bridge);\n\nint gemini_sata_reset_bridge(struct sata_gemini *sg,\n\t\t\t     unsigned int bridge)\n{\n\tif (bridge == 0)\n\t\treset_control_reset(sg->sata0_reset);\n\telse\n\t\treset_control_reset(sg->sata1_reset);\n\tmsleep(10);\n\treturn gemini_sata_setup_bridge(sg, bridge);\n}\nEXPORT_SYMBOL(gemini_sata_reset_bridge);\n\nstatic int gemini_sata_bridge_init(struct sata_gemini *sg)\n{\n\tstruct device *dev = sg->dev;\n\tu32 sata_id, sata_phy_id;\n\tint ret;\n\n\tsg->sata0_pclk = devm_clk_get(dev, \"SATA0_PCLK\");\n\tif (IS_ERR(sg->sata0_pclk)) {\n\t\tdev_err(dev, \"no SATA0 PCLK\");\n\t\treturn -ENODEV;\n\t}\n\tsg->sata1_pclk = devm_clk_get(dev, \"SATA1_PCLK\");\n\tif (IS_ERR(sg->sata1_pclk)) {\n\t\tdev_err(dev, \"no SATA1 PCLK\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = clk_prepare_enable(sg->sata0_pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable SATA0 PCLK\\n\");\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(sg->sata1_pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable SATA1 PCLK\\n\");\n\t\tclk_disable_unprepare(sg->sata0_pclk);\n\t\treturn ret;\n\t}\n\n\tsg->sata0_reset = devm_reset_control_get_exclusive(dev, \"sata0\");\n\tif (IS_ERR(sg->sata0_reset)) {\n\t\tdev_err(dev, \"no SATA0 reset controller\\n\");\n\t\tclk_disable_unprepare(sg->sata1_pclk);\n\t\tclk_disable_unprepare(sg->sata0_pclk);\n\t\treturn PTR_ERR(sg->sata0_reset);\n\t}\n\tsg->sata1_reset = devm_reset_control_get_exclusive(dev, \"sata1\");\n\tif (IS_ERR(sg->sata1_reset)) {\n\t\tdev_err(dev, \"no SATA1 reset controller\\n\");\n\t\tclk_disable_unprepare(sg->sata1_pclk);\n\t\tclk_disable_unprepare(sg->sata0_pclk);\n\t\treturn PTR_ERR(sg->sata1_reset);\n\t}\n\n\tsata_id = readl(sg->base + GEMINI_SATA_ID);\n\tsata_phy_id = readl(sg->base + GEMINI_SATA_PHY_ID);\n\tsg->sata_bridge = true;\n\tclk_disable(sg->sata0_pclk);\n\tclk_disable(sg->sata1_pclk);\n\n\tdev_info(dev, \"SATA ID %08x, PHY ID: %08x\\n\", sata_id, sata_phy_id);\n\n\treturn 0;\n}\n\nstatic int gemini_setup_ide_pins(struct device *dev)\n{\n\tstruct pinctrl *p;\n\tstruct pinctrl_state *ide_state;\n\tint ret;\n\n\tp = devm_pinctrl_get(dev);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tide_state = pinctrl_lookup_state(p, \"ide\");\n\tif (IS_ERR(ide_state))\n\t\treturn PTR_ERR(ide_state);\n\n\tret = pinctrl_select_state(p, ide_state);\n\tif (ret) {\n\t\tdev_err(dev, \"could not select IDE state\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gemini_sata_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sata_gemini *sg;\n\tstruct regmap *map;\n\tenum gemini_muxmode muxmode;\n\tu32 gmode;\n\tu32 gmask;\n\tint ret;\n\n\tsg = devm_kzalloc(dev, sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\treturn -ENOMEM;\n\tsg->dev = dev;\n\n\tsg->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sg->base))\n\t\treturn PTR_ERR(sg->base);\n\n\tmap = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"no global syscon\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"cortina,gemini-enable-sata-bridge\")) {\n\t\tret = gemini_sata_bridge_init(sg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(np, \"cortina,gemini-enable-ide-pins\"))\n\t\tsg->ide_pins = true;\n\n\tif (!sg->sata_bridge && !sg->ide_pins) {\n\t\tdev_err(dev, \"neither SATA bridge or IDE output enabled\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unprep_clk;\n\t}\n\n\tret = of_property_read_u32(np, \"cortina,gemini-ata-muxmode\", &muxmode);\n\tif (ret) {\n\t\tdev_err(dev, \"could not parse ATA muxmode\\n\");\n\t\tgoto out_unprep_clk;\n\t}\n\tif (muxmode > GEMINI_MUXMODE_3) {\n\t\tdev_err(dev, \"illegal muxmode %d\\n\", muxmode);\n\t\tret = -EINVAL;\n\t\tgoto out_unprep_clk;\n\t}\n\tsg->muxmode = muxmode;\n\tgmask = GEMINI_IDE_IOMUX_MASK;\n\tgmode = (muxmode << GEMINI_IDE_IOMUX_SHIFT);\n\n\tret = regmap_update_bits(map, GEMINI_GLOBAL_MISC_CTRL, gmask, gmode);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to set up IDE muxing\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_unprep_clk;\n\t}\n\n\t \n\tif (sg->ide_pins) {\n\t\tret = gemini_setup_ide_pins(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"set up the Gemini IDE/SATA nexus\\n\");\n\tplatform_set_drvdata(pdev, sg);\n\tsg_singleton = sg;\n\n\treturn 0;\n\nout_unprep_clk:\n\tif (sg->sata_bridge) {\n\t\tclk_unprepare(sg->sata1_pclk);\n\t\tclk_unprepare(sg->sata0_pclk);\n\t}\n\treturn ret;\n}\n\nstatic void gemini_sata_remove(struct platform_device *pdev)\n{\n\tstruct sata_gemini *sg = platform_get_drvdata(pdev);\n\n\tif (sg->sata_bridge) {\n\t\tclk_unprepare(sg->sata1_pclk);\n\t\tclk_unprepare(sg->sata0_pclk);\n\t}\n\tsg_singleton = NULL;\n}\n\nstatic const struct of_device_id gemini_sata_of_match[] = {\n\t{ .compatible = \"cortina,gemini-sata-bridge\", },\n\t{   }\n};\n\nstatic struct platform_driver gemini_sata_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = gemini_sata_of_match,\n\t},\n\t.probe = gemini_sata_probe,\n\t.remove_new = gemini_sata_remove,\n};\nmodule_platform_driver(gemini_sata_driver);\n\nMODULE_DESCRIPTION(\"low level driver for Cortina Systems Gemini SATA bridge\");\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}