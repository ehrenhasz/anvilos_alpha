{
  "module_name": "pata_ftide010.c",
  "hash_id": "b3e22bbb718ede28e250111757f76b5d0cdcff22d436d5fea2aaa3e4ffbb4f8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_ftide010.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/libata.h>\n#include <linux/bitops.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include \"sata_gemini.h\"\n\n#define DRV_NAME \"pata_ftide010\"\n\n \nstruct ftide010 {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *pclk;\n\tstruct ata_host *host;\n\tunsigned int master_cbl;\n\tunsigned int slave_cbl;\n\t \n\tstruct sata_gemini *sg;\n\tbool master_to_sata0;\n\tbool slave_to_sata0;\n\tbool master_to_sata1;\n\tbool slave_to_sata1;\n};\n\n#define FTIDE010_DMA_REG\t0x00\n#define FTIDE010_DMA_STATUS\t0x02\n#define FTIDE010_IDE_BMDTPR\t0x04\n#define FTIDE010_IDE_DEVICE_ID\t0x08\n#define FTIDE010_PIO_TIMING\t0x10\n#define FTIDE010_MWDMA_TIMING\t0x11\n#define FTIDE010_UDMA_TIMING0\t0x12  \n#define FTIDE010_UDMA_TIMING1\t0x13  \n#define FTIDE010_CLK_MOD\t0x14\n \n#define FTIDE010_CMD_DATA\t0x20\n#define FTIDE010_ERROR_FEATURES\t0x21\n#define FTIDE010_NSECT\t\t0x22\n#define FTIDE010_LBAL\t\t0x23\n#define FTIDE010_LBAM\t\t0x24\n#define FTIDE010_LBAH\t\t0x25\n#define FTIDE010_DEVICE\t\t0x26\n#define FTIDE010_STATUS_COMMAND\t0x27\n#define FTIDE010_ALTSTAT_CTRL\t0x36\n\n \n#define FTIDE010_UDMA_TIMING_MODE_56\tBIT(7)\n\n \n#define FTIDE010_CLK_MOD_DEV0_CLK_SEL\tBIT(0)\n#define FTIDE010_CLK_MOD_DEV1_CLK_SEL\tBIT(1)\n \n#define FTIDE010_CLK_MOD_DEV0_UDMA_EN\tBIT(4)\n#define FTIDE010_CLK_MOD_DEV1_UDMA_EN\tBIT(5)\n\nstatic const struct scsi_host_template pata_ftide010_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n \nstatic const u8 pio_active_time[5] = {10, 10, 10, 3, 3};\nstatic const u8 pio_recovery_time[5] = {10, 3, 1, 3, 1};\nstatic const u8 mwdma_50_active_time[3] = {6, 2, 2};\nstatic const u8 mwdma_50_recovery_time[3] = {6, 2, 1};\nstatic const u8 mwdma_66_active_time[3] = {8, 3, 3};\nstatic const u8 mwdma_66_recovery_time[3] = {8, 2, 1};\nstatic const u8 udma_50_setup_time[6] = {3, 3, 2, 2, 1, 1};\nstatic const u8 udma_50_hold_time[6] = {3, 1, 1, 1, 1, 1};\nstatic const u8 udma_66_setup_time[7] = {4, 4, 3, 2, };\nstatic const u8 udma_66_hold_time[7] = {};\n\n \nstatic const bool set_mdma_66_mhz[] = { true, true, true, true };\n\n \nstatic const bool set_udma_66_mhz[] = { false, false, false, true, true, false, true };\n\nstatic void ftide010_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ftide010 *ftide = ap->host->private_data;\n\tu8 speed = adev->dma_mode;\n\tu8 devno = adev->devno & 1;\n\tu8 udma_en_mask;\n\tu8 f66m_en_mask;\n\tu8 clkreg;\n\tu8 timreg;\n\tu8 i;\n\n\t \n\tif (!devno) {\n\t\tudma_en_mask = FTIDE010_CLK_MOD_DEV0_UDMA_EN;\n\t\tf66m_en_mask = FTIDE010_CLK_MOD_DEV0_CLK_SEL;\n\t} else {\n\t\tudma_en_mask = FTIDE010_CLK_MOD_DEV1_UDMA_EN;\n\t\tf66m_en_mask = FTIDE010_CLK_MOD_DEV1_CLK_SEL;\n\t}\n\n\tclkreg = readb(ftide->base + FTIDE010_CLK_MOD);\n\tclkreg &= ~udma_en_mask;\n\tclkreg &= ~f66m_en_mask;\n\n\tif (speed & XFER_UDMA_0) {\n\t\ti = speed & ~XFER_UDMA_0;\n\t\tdev_dbg(ftide->dev, \"set UDMA mode %02x, index %d\\n\",\n\t\t\tspeed, i);\n\n\t\tclkreg |= udma_en_mask;\n\t\tif (set_udma_66_mhz[i]) {\n\t\t\tclkreg |= f66m_en_mask;\n\t\t\ttimreg = udma_66_setup_time[i] << 4 |\n\t\t\t\tudma_66_hold_time[i];\n\t\t} else {\n\t\t\ttimreg = udma_50_setup_time[i] << 4 |\n\t\t\t\tudma_50_hold_time[i];\n\t\t}\n\n\t\t \n\t\tif (i >= 5)\n\t\t\ttimreg |= FTIDE010_UDMA_TIMING_MODE_56;\n\n\t\tdev_dbg(ftide->dev, \"UDMA write clkreg = %02x, timreg = %02x\\n\",\n\t\t\tclkreg, timreg);\n\n\t\twriteb(clkreg, ftide->base + FTIDE010_CLK_MOD);\n\t\twriteb(timreg, ftide->base + FTIDE010_UDMA_TIMING0 + devno);\n\t} else {\n\t\ti = speed & ~XFER_MW_DMA_0;\n\t\tdev_dbg(ftide->dev, \"set MWDMA mode %02x, index %d\\n\",\n\t\t\tspeed, i);\n\n\t\tif (set_mdma_66_mhz[i]) {\n\t\t\tclkreg |= f66m_en_mask;\n\t\t\ttimreg = mwdma_66_active_time[i] << 4 |\n\t\t\t\tmwdma_66_recovery_time[i];\n\t\t} else {\n\t\t\ttimreg = mwdma_50_active_time[i] << 4 |\n\t\t\t\tmwdma_50_recovery_time[i];\n\t\t}\n\t\tdev_dbg(ftide->dev,\n\t\t\t\"MWDMA write clkreg = %02x, timreg = %02x\\n\",\n\t\t\tclkreg, timreg);\n\t\t \n\t\twriteb(clkreg, ftide->base + FTIDE010_CLK_MOD);\n\t\twriteb(timreg, ftide->base + FTIDE010_MWDMA_TIMING);\n\t}\n\n\t \n\tap->private_data = adev;\n\n\treturn;\n}\n\nstatic void ftide010_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ftide010 *ftide = ap->host->private_data;\n\tu8 pio = adev->pio_mode - XFER_PIO_0;\n\n\tdev_dbg(ftide->dev, \"set PIO mode %02x, index %d\\n\",\n\t\tadev->pio_mode, pio);\n\twriteb(pio_active_time[pio] << 4 | pio_recovery_time[pio],\n\t       ftide->base + FTIDE010_PIO_TIMING);\n}\n\n \nstatic unsigned int ftide010_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\n\t \n\tif (adev != ap->private_data && ata_dma_enabled(adev))\n\t\tftide010_set_dmamode(ap, adev);\n\n\treturn ata_bmdma_qc_issue(qc);\n}\n\nstatic struct ata_port_operations pata_ftide010_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.set_dmamode\t= ftide010_set_dmamode,\n\t.set_piomode\t= ftide010_set_piomode,\n\t.qc_issue\t= ftide010_qc_issue,\n};\n\nstatic struct ata_port_info ftide010_port_info = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.pio_mask\t= ATA_PIO4,\n\t.port_ops\t= &pata_ftide010_port_ops,\n};\n\n#if IS_ENABLED(CONFIG_SATA_GEMINI)\n\nstatic int pata_ftide010_gemini_port_start(struct ata_port *ap)\n{\n\tstruct ftide010 *ftide = ap->host->private_data;\n\tstruct device *dev = ftide->dev;\n\tstruct sata_gemini *sg = ftide->sg;\n\tint bridges = 0;\n\tint ret;\n\n\tret = ata_bmdma_port_start(ap);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ftide->master_to_sata0) {\n\t\tdev_info(dev, \"SATA0 (master) start\\n\");\n\t\tret = gemini_sata_start_bridge(sg, 0);\n\t\tif (!ret)\n\t\t\tbridges++;\n\t}\n\tif (ftide->master_to_sata1) {\n\t\tdev_info(dev, \"SATA1 (master) start\\n\");\n\t\tret = gemini_sata_start_bridge(sg, 1);\n\t\tif (!ret)\n\t\t\tbridges++;\n\t}\n\t \n\tif (ftide->slave_to_sata0 && !ftide->master_to_sata0) {\n\t\tdev_info(dev, \"SATA0 (slave) start\\n\");\n\t\tret = gemini_sata_start_bridge(sg, 0);\n\t\tif (!ret)\n\t\t\tbridges++;\n\t}\n\t \n\tif (ftide->slave_to_sata1 && !ftide->master_to_sata1) {\n\t\tdev_info(dev, \"SATA1 (slave) start\\n\");\n\t\tret = gemini_sata_start_bridge(sg, 1);\n\t\tif (!ret)\n\t\t\tbridges++;\n\t}\n\n\tdev_info(dev, \"brought %d bridges online\\n\", bridges);\n\treturn (bridges > 0) ? 0 : -EINVAL; \n}\n\nstatic void pata_ftide010_gemini_port_stop(struct ata_port *ap)\n{\n\tstruct ftide010 *ftide = ap->host->private_data;\n\tstruct device *dev = ftide->dev;\n\tstruct sata_gemini *sg = ftide->sg;\n\n\tif (ftide->master_to_sata0) {\n\t\tdev_info(dev, \"SATA0 (master) stop\\n\");\n\t\tgemini_sata_stop_bridge(sg, 0);\n\t}\n\tif (ftide->master_to_sata1) {\n\t\tdev_info(dev, \"SATA1 (master) stop\\n\");\n\t\tgemini_sata_stop_bridge(sg, 1);\n\t}\n\t \n\tif (ftide->slave_to_sata0 && !ftide->master_to_sata0) {\n\t\tdev_info(dev, \"SATA0 (slave) stop\\n\");\n\t\tgemini_sata_stop_bridge(sg, 0);\n\t}\n\t \n\tif (ftide->slave_to_sata1 && !ftide->master_to_sata1) {\n\t\tdev_info(dev, \"SATA1 (slave) stop\\n\");\n\t\tgemini_sata_stop_bridge(sg, 1);\n\t}\n}\n\nstatic int pata_ftide010_gemini_cable_detect(struct ata_port *ap)\n{\n\tstruct ftide010 *ftide = ap->host->private_data;\n\n\t \n\treturn ftide->master_cbl;\n}\n\nstatic int pata_ftide010_gemini_init(struct ftide010 *ftide,\n\t\t\t\t     struct ata_port_info *pi,\n\t\t\t\t     bool is_ata1)\n{\n\tstruct device *dev = ftide->dev;\n\tstruct sata_gemini *sg;\n\tenum gemini_muxmode muxmode;\n\n\t \n\tsg = gemini_sata_bridge_get();\n\tif (IS_ERR(sg))\n\t\treturn PTR_ERR(sg);\n\tftide->sg = sg;\n\n\tmuxmode = gemini_sata_get_muxmode(sg);\n\n\t \n\tpata_ftide010_port_ops.port_start =\n\t\tpata_ftide010_gemini_port_start;\n\tpata_ftide010_port_ops.port_stop =\n\t\tpata_ftide010_gemini_port_stop;\n\tpata_ftide010_port_ops.cable_detect =\n\t\tpata_ftide010_gemini_cable_detect;\n\n\t \n\tif (gemini_sata_bridge_enabled(sg, is_ata1))\n\t\tpi->flags |= ATA_FLAG_SATA;\n\n\t \n\tif (of_machine_is_compatible(\"itian,sq201\")) {\n\t\tpi->mwdma_mask = 0;\n\t\tpi->udma_mask = 0;\n\t}\n\n\t \n\tif (!is_ata1) {\n\t\tswitch (muxmode) {\n\t\tcase GEMINI_MUXMODE_0:\n\t\t\tftide->master_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_cbl = ATA_CBL_PATA40;\n\t\t\tftide->master_to_sata0 = true;\n\t\t\tbreak;\n\t\tcase GEMINI_MUXMODE_1:\n\t\t\tftide->master_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_cbl = ATA_CBL_NONE;\n\t\t\tftide->master_to_sata0 = true;\n\t\t\tbreak;\n\t\tcase GEMINI_MUXMODE_2:\n\t\t\tftide->master_cbl = ATA_CBL_PATA40;\n\t\t\tftide->slave_cbl = ATA_CBL_PATA40;\n\t\t\tbreak;\n\t\tcase GEMINI_MUXMODE_3:\n\t\t\tftide->master_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_cbl = ATA_CBL_SATA;\n\t\t\tftide->master_to_sata0 = true;\n\t\t\tftide->slave_to_sata1 = true;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (muxmode) {\n\t\tcase GEMINI_MUXMODE_0:\n\t\t\tftide->master_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_cbl = ATA_CBL_NONE;\n\t\t\tftide->master_to_sata1 = true;\n\t\t\tbreak;\n\t\tcase GEMINI_MUXMODE_1:\n\t\t\tftide->master_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_cbl = ATA_CBL_PATA40;\n\t\t\tftide->master_to_sata1 = true;\n\t\t\tbreak;\n\t\tcase GEMINI_MUXMODE_2:\n\t\t\tftide->master_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_cbl = ATA_CBL_SATA;\n\t\t\tftide->slave_to_sata0 = true;\n\t\t\tftide->master_to_sata1 = true;\n\t\t\tbreak;\n\t\tcase GEMINI_MUXMODE_3:\n\t\t\tftide->master_cbl = ATA_CBL_PATA40;\n\t\t\tftide->slave_cbl = ATA_CBL_PATA40;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdev_info(dev, \"set up Gemini PATA%d\\n\", is_ata1);\n\n\treturn 0;\n}\n#else\nstatic int pata_ftide010_gemini_init(struct ftide010 *ftide,\n\t\t\t\t     struct ata_port_info *pi,\n\t\t\t\t     bool is_ata1)\n{\n\treturn -ENOTSUPP;\n}\n#endif\n\n\nstatic int pata_ftide010_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ata_port_info pi = ftide010_port_info;\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct ftide010 *ftide;\n\tstruct resource *res;\n\tint irq;\n\tint ret;\n\tint i;\n\n\tftide = devm_kzalloc(dev, sizeof(*ftide), GFP_KERNEL);\n\tif (!ftide)\n\t\treturn -ENOMEM;\n\tftide->dev = dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tftide->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ftide->base))\n\t\treturn PTR_ERR(ftide->base);\n\n\tftide->pclk = devm_clk_get(dev, \"PCLK\");\n\tif (!IS_ERR(ftide->pclk)) {\n\t\tret = clk_prepare_enable(ftide->pclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable PCLK\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (of_device_is_compatible(np, \"cortina,gemini-pata\")) {\n\t\t \n\t\tret = pata_ftide010_gemini_init(ftide,\n\t\t\t\t&pi,\n\t\t\t\t(res->start == 0x63400000));\n\t\tif (ret)\n\t\t\tgoto err_dis_clk;\n\t} else {\n\t\t \n\t\tftide->master_cbl = ATA_CBL_PATA40;\n\t\tftide->slave_cbl = ATA_CBL_PATA40;\n\t}\n\n\tftide->host = ata_host_alloc_pinfo(dev, ppi, 1);\n\tif (!ftide->host) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dis_clk;\n\t}\n\tftide->host->private_data = ftide;\n\n\tfor (i = 0; i < ftide->host->n_ports; i++) {\n\t\tstruct ata_port *ap = ftide->host->ports[i];\n\t\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\t\tioaddr->bmdma_addr = ftide->base + FTIDE010_DMA_REG;\n\t\tioaddr->cmd_addr = ftide->base + FTIDE010_CMD_DATA;\n\t\tioaddr->ctl_addr = ftide->base + FTIDE010_ALTSTAT_CTRL;\n\t\tioaddr->altstatus_addr = ftide->base + FTIDE010_ALTSTAT_CTRL;\n\t\tata_sff_std_ports(ioaddr);\n\t}\n\n\tdev_info(dev, \"device ID %08x, irq %d, reg %pR\\n\",\n\t\t readl(ftide->base + FTIDE010_IDE_DEVICE_ID), irq, res);\n\n\tret = ata_host_activate(ftide->host, irq, ata_bmdma_interrupt,\n\t\t\t\t0, &pata_ftide010_sht);\n\tif (ret)\n\t\tgoto err_dis_clk;\n\n\treturn 0;\n\nerr_dis_clk:\n\tclk_disable_unprepare(ftide->pclk);\n\n\treturn ret;\n}\n\nstatic void pata_ftide010_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct ftide010 *ftide = host->private_data;\n\n\tata_host_detach(ftide->host);\n\tclk_disable_unprepare(ftide->pclk);\n}\n\nstatic const struct of_device_id pata_ftide010_of_match[] = {\n\t{ .compatible = \"faraday,ftide010\", },\n\t{   }\n};\n\nstatic struct platform_driver pata_ftide010_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = pata_ftide010_of_match,\n\t},\n\t.probe = pata_ftide010_probe,\n\t.remove_new = pata_ftide010_remove,\n};\nmodule_platform_driver(pata_ftide010_driver);\n\nMODULE_DESCRIPTION(\"low level driver for Faraday Technology FTIDE010\");\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}