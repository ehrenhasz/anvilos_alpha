{
  "module_name": "pata_sl82c105.c",
  "hash_id": "057da3d2f3816ed69c1ae76db010cf46000b0405c9f52f93f0f68617ce2a7eb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_sl82c105.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_sl82c105\"\n#define DRV_VERSION \"0.3.3\"\n\nenum {\n\t \n\tCTRL_IDE_IRQB\t=\t(1 << 30),\n\tCTRL_IDE_IRQA   =\t(1 << 28),\n\tCTRL_LEGIRQ     =\t(1 << 11),\n\tCTRL_P1F16      =\t(1 << 5),\n\tCTRL_P1EN       =\t(1 << 4),\n\tCTRL_P0F16      =\t(1 << 1),\n\tCTRL_P0EN       =\t(1 << 0)\n};\n\n \n\nstatic int sl82c105_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstatic const struct pci_bits sl82c105_enable_bits[] = {\n\t\t{ 0x40, 1, 0x01, 0x01 },\n\t\t{ 0x40, 1, 0x10, 0x10 }\n\t};\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tif (ap->port_no && !pci_test_config_bits(pdev, &sl82c105_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\treturn ata_sff_prereset(link, deadline);\n}\n\n\n \n\nstatic void sl82c105_configure_piomode(struct ata_port *ap, struct ata_device *adev, int pio)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic u16 pio_timing[5] = {\n\t\t0x50D, 0x407, 0x304, 0x242, 0x240\n\t};\n\tu16 dummy;\n\tint timing = 0x44 + (8 * ap->port_no) + (4 * adev->devno);\n\n\tpci_write_config_word(pdev, timing, pio_timing[pio]);\n\t \n\tpci_read_config_word(pdev, timing, &dummy);\n}\n\n \n\nstatic void sl82c105_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tsl82c105_configure_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);\n}\n\n \n\nstatic void sl82c105_configure_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic u16 dma_timing[3] = {\n\t\t0x707, 0x201, 0x200\n\t};\n\tu16 dummy;\n\tint timing = 0x44 + (8 * ap->port_no) + (4 * adev->devno);\n\tint dma = adev->dma_mode - XFER_MW_DMA_0;\n\n\tpci_write_config_word(pdev, timing, dma_timing[dma]);\n\t \n\tpci_read_config_word(pdev, timing, &dummy);\n}\n\n \n\nstatic void sl82c105_reset_engine(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu16 val;\n\n\tpci_read_config_word(pdev, 0x7E, &val);\n\tpci_write_config_word(pdev, 0x7E, val | 4);\n\tpci_write_config_word(pdev, 0x7E, val & ~4);\n}\n\n \n\nstatic void sl82c105_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\tudelay(100);\n\tsl82c105_reset_engine(ap);\n\tudelay(100);\n\n\t \n\tsl82c105_configure_dmamode(ap, qc->dev);\n\t \n\tata_bmdma_start(qc);\n}\n\n \n\nstatic void sl82c105_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\tata_bmdma_stop(qc);\n\tsl82c105_reset_engine(ap);\n\tudelay(100);\n\n\t \n\tsl82c105_set_piomode(ap, qc->dev);\n}\n\n \n\nstatic int sl82c105_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_host *host = qc->ap->host;\n\tstruct ata_port *alt = host->ports[1 ^ qc->ap->port_no];\n\tint rc;\n\n\t \n\trc = ata_std_qc_defer(qc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\tif (alt && alt->qc_active)\n\t\treturn\tATA_DEFER_PORT;\n\treturn 0;\n}\n\nstatic bool sl82c105_sff_irq_check(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tu32 val, mask\t\t= ap->port_no ? CTRL_IDE_IRQB : CTRL_IDE_IRQA;\n\n\tpci_read_config_dword(pdev, 0x40, &val);\n\n\treturn val & mask;\n}\n\nstatic const struct scsi_host_template sl82c105_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations sl82c105_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.qc_defer\t= sl82c105_qc_defer,\n\t.bmdma_start \t= sl82c105_bmdma_start,\n\t.bmdma_stop\t= sl82c105_bmdma_stop,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= sl82c105_set_piomode,\n\t.prereset\t= sl82c105_pre_reset,\n\t.sff_irq_check\t= sl82c105_sff_irq_check,\n};\n\n \n\nstatic int sl82c105_bridge_revision(struct pci_dev *pdev)\n{\n\tstruct pci_dev *bridge;\n\n\t \n\tbridge = pci_get_slot(pdev->bus,\n\t\t\t       PCI_DEVFN(PCI_SLOT(pdev->devfn), 0));\n\tif (!bridge)\n\t\treturn -1;\n\n\t \n\tif (bridge->vendor != PCI_VENDOR_ID_WINBOND ||\n\t    bridge->device != PCI_DEVICE_ID_WINBOND_83C553 ||\n\t    bridge->class >> 8 != PCI_CLASS_BRIDGE_ISA) {\n\t    \tpci_dev_put(bridge);\n\t\treturn -1;\n\t}\n\t \n\tpci_dev_put(bridge);\n\treturn bridge->revision;\n}\n\nstatic void sl82c105_fixup(struct pci_dev *pdev)\n{\n\tu32 val;\n\n\tpci_read_config_dword(pdev, 0x40, &val);\n\tval |= CTRL_P0EN | CTRL_P0F16 | CTRL_P1F16;\n\tpci_write_config_dword(pdev, 0x40, val);\n}\n\nstatic int sl82c105_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info_dma = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.port_ops = &sl82c105_port_ops\n\t};\n\tstatic const struct ata_port_info info_early = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.port_ops = &sl82c105_port_ops\n\t};\n\t \n\tconst struct ata_port_info *ppi[] = { &info_early,\n\t\t\t\t\t       NULL };\n\tint rev;\n\tint rc;\n\n\trc = pcim_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\trev = sl82c105_bridge_revision(dev);\n\n\tif (rev == -1)\n\t\tdev_warn(&dev->dev,\n\t\t\t \"pata_sl82c105: Unable to find bridge, disabling DMA\\n\");\n\telse if (rev <= 5)\n\t\tdev_warn(&dev->dev,\n\t\t\t \"pata_sl82c105: Early bridge revision, no DMA available\\n\");\n\telse\n\t\tppi[0] = &info_dma;\n\n\tsl82c105_fixup(dev);\n\n\treturn ata_pci_bmdma_init_one(dev, ppi, &sl82c105_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sl82c105_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tsl82c105_fixup(pdev);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id sl82c105[] = {\n\t{ PCI_VDEVICE(WINBOND, PCI_DEVICE_ID_WINBOND_82C105), },\n\n\t{ },\n};\n\nstatic struct pci_driver sl82c105_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= sl82c105,\n\t.probe \t\t= sl82c105_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= sl82c105_reinit_one,\n#endif\n};\n\nmodule_pci_driver(sl82c105_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Sl82c105\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sl82c105);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}