{
  "module_name": "ahci_brcm.c",
  "hash_id": "9f288616da3d5f898497a3b963298678a483c92bee5016485554c13b9546a240",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_brcm.c",
  "human_readable_source": "\n \n\n#include <linux/ahci_platform.h>\n#include <linux/compiler.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/string.h>\n\n#include \"ahci.h\"\n\n#define DRV_NAME\t\t\t\t\t\"brcm-ahci\"\n\n#define SATA_TOP_CTRL_VERSION\t\t\t\t0x0\n#define SATA_TOP_CTRL_BUS_CTRL\t\t\t\t0x4\n #define MMIO_ENDIAN_SHIFT\t\t\t\t0  \n #define DMADESC_ENDIAN_SHIFT\t\t\t\t2  \n #define DMADATA_ENDIAN_SHIFT\t\t\t\t4  \n #define PIODATA_ENDIAN_SHIFT\t\t\t\t6\n  #define ENDIAN_SWAP_NONE\t\t\t\t0\n  #define ENDIAN_SWAP_FULL\t\t\t\t2\n#define SATA_TOP_CTRL_TP_CTRL\t\t\t\t0x8\n#define SATA_TOP_CTRL_PHY_CTRL\t\t\t\t0xc\n #define SATA_TOP_CTRL_PHY_CTRL_1\t\t\t0x0\n  #define SATA_TOP_CTRL_1_PHY_DEFAULT_POWER_STATE\tBIT(14)\n #define SATA_TOP_CTRL_PHY_CTRL_2\t\t\t0x4\n  #define SATA_TOP_CTRL_2_SW_RST_MDIOREG\t\tBIT(0)\n  #define SATA_TOP_CTRL_2_SW_RST_OOB\t\t\tBIT(1)\n  #define SATA_TOP_CTRL_2_SW_RST_RX\t\t\tBIT(2)\n  #define SATA_TOP_CTRL_2_SW_RST_TX\t\t\tBIT(3)\n  #define SATA_TOP_CTRL_2_PHY_GLOBAL_RESET\t\tBIT(14)\n #define SATA_TOP_CTRL_PHY_OFFS\t\t\t\t0x8\n #define SATA_TOP_MAX_PHYS\t\t\t\t2\n\n#define SATA_FIRST_PORT_CTRL\t\t\t\t0x700\n#define SATA_NEXT_PORT_CTRL_OFFSET\t\t\t0x80\n#define SATA_PORT_PCTRL6(reg_base)\t\t\t(reg_base + 0x18)\n\n \n#if defined(CONFIG_MIPS) && defined(__BIG_ENDIAN)\n#define DATA_ENDIAN\t\t\t 2  \n#define MMIO_ENDIAN\t\t\t 2  \n#else\n#define DATA_ENDIAN\t\t\t 0\n#define MMIO_ENDIAN\t\t\t 0\n#endif\n\n#define BUS_CTRL_ENDIAN_CONF\t\t\t\t\\\n\t((DATA_ENDIAN << DMADATA_ENDIAN_SHIFT) |\t\\\n\t(DATA_ENDIAN << DMADESC_ENDIAN_SHIFT) |\t\t\\\n\t(MMIO_ENDIAN << MMIO_ENDIAN_SHIFT))\n\n#define BUS_CTRL_ENDIAN_NSP_CONF\t\t\t\\\n\t(0x02 << DMADATA_ENDIAN_SHIFT | 0x02 << DMADESC_ENDIAN_SHIFT)\n\n#define BUS_CTRL_ENDIAN_CONF_MASK\t\t\t\\\n\t(0x3 << MMIO_ENDIAN_SHIFT | 0x3 << DMADESC_ENDIAN_SHIFT |\t\\\n\t 0x3 << DMADATA_ENDIAN_SHIFT | 0x3 << PIODATA_ENDIAN_SHIFT)\n\nenum brcm_ahci_version {\n\tBRCM_SATA_BCM7425 = 1,\n\tBRCM_SATA_BCM7445,\n\tBRCM_SATA_NSP,\n\tBRCM_SATA_BCM7216,\n};\n\nenum brcm_ahci_quirks {\n\tBRCM_AHCI_QUIRK_SKIP_PHY_ENABLE\t= BIT(0),\n};\n\nstruct brcm_ahci_priv {\n\tstruct device *dev;\n\tvoid __iomem *top_ctrl;\n\tu32 port_mask;\n\tu32 quirks;\n\tenum brcm_ahci_version version;\n\tstruct reset_control *rcdev_rescal;\n\tstruct reset_control *rcdev_ahci;\n};\n\nstatic inline u32 brcm_sata_readreg(void __iomem *addr)\n{\n\t \n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(addr);\n\telse\n\t\treturn readl_relaxed(addr);\n}\n\nstatic inline void brcm_sata_writereg(u32 val, void __iomem *addr)\n{\n\t \n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(val, addr);\n\telse\n\t\twritel_relaxed(val, addr);\n}\n\nstatic void brcm_sata_alpm_init(struct ahci_host_priv *hpriv)\n{\n\tstruct brcm_ahci_priv *priv = hpriv->plat_data;\n\tu32 port_ctrl, host_caps;\n\tint i;\n\n\t \n\thost_caps = readl(hpriv->mmio + HOST_CAP);\n\tif (!(host_caps & HOST_CAP_ALPM))\n\t\thpriv->flags |= AHCI_HFLAG_YES_ALPM;\n\n\t \n\tfor (i = 0, port_ctrl = SATA_FIRST_PORT_CTRL;\n\t     i < SATA_TOP_MAX_PHYS;\n\t     i++, port_ctrl += SATA_NEXT_PORT_CTRL_OFFSET) {\n\t\tif (priv->port_mask & BIT(i))\n\t\t\twritel(0xff1003fc,\n\t\t\t       hpriv->mmio + SATA_PORT_PCTRL6(port_ctrl));\n\t}\n}\n\nstatic void brcm_sata_phy_enable(struct brcm_ahci_priv *priv, int port)\n{\n\tvoid __iomem *phyctrl = priv->top_ctrl + SATA_TOP_CTRL_PHY_CTRL +\n\t\t\t\t(port * SATA_TOP_CTRL_PHY_OFFS);\n\tvoid __iomem *p;\n\tu32 reg;\n\n\tif (priv->quirks & BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE)\n\t\treturn;\n\n\t \n\tp = phyctrl + SATA_TOP_CTRL_PHY_CTRL_1;\n\treg = brcm_sata_readreg(p);\n\treg &= ~SATA_TOP_CTRL_1_PHY_DEFAULT_POWER_STATE;\n\tbrcm_sata_writereg(reg, p);\n\n\t \n\tp = phyctrl + SATA_TOP_CTRL_PHY_CTRL_2;\n\treg = brcm_sata_readreg(p);\n\treg &= ~(SATA_TOP_CTRL_2_SW_RST_MDIOREG | SATA_TOP_CTRL_2_SW_RST_OOB |\n\t\t SATA_TOP_CTRL_2_SW_RST_RX);\n\treg |= SATA_TOP_CTRL_2_SW_RST_TX;\n\tbrcm_sata_writereg(reg, p);\n\treg = brcm_sata_readreg(p);\n\treg |= SATA_TOP_CTRL_2_PHY_GLOBAL_RESET;\n\tbrcm_sata_writereg(reg, p);\n\treg = brcm_sata_readreg(p);\n\treg &= ~SATA_TOP_CTRL_2_PHY_GLOBAL_RESET;\n\tbrcm_sata_writereg(reg, p);\n\t(void)brcm_sata_readreg(p);\n}\n\nstatic void brcm_sata_phy_disable(struct brcm_ahci_priv *priv, int port)\n{\n\tvoid __iomem *phyctrl = priv->top_ctrl + SATA_TOP_CTRL_PHY_CTRL +\n\t\t\t\t(port * SATA_TOP_CTRL_PHY_OFFS);\n\tvoid __iomem *p;\n\tu32 reg;\n\n\tif (priv->quirks & BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE)\n\t\treturn;\n\n\t \n\tp = phyctrl + SATA_TOP_CTRL_PHY_CTRL_2;\n\treg = brcm_sata_readreg(p);\n\treg |= (SATA_TOP_CTRL_2_SW_RST_MDIOREG | SATA_TOP_CTRL_2_SW_RST_OOB |\n\t\tSATA_TOP_CTRL_2_SW_RST_RX | SATA_TOP_CTRL_2_SW_RST_TX |\n\t\tSATA_TOP_CTRL_2_PHY_GLOBAL_RESET);\n\tbrcm_sata_writereg(reg, p);\n\n\t \n\tp = phyctrl + SATA_TOP_CTRL_PHY_CTRL_1;\n\treg = brcm_sata_readreg(p);\n\treg |= SATA_TOP_CTRL_1_PHY_DEFAULT_POWER_STATE;\n\tbrcm_sata_writereg(reg, p);\n}\n\nstatic void brcm_sata_phys_enable(struct brcm_ahci_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < SATA_TOP_MAX_PHYS; i++)\n\t\tif (priv->port_mask & BIT(i))\n\t\t\tbrcm_sata_phy_enable(priv, i);\n}\n\nstatic void brcm_sata_phys_disable(struct brcm_ahci_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < SATA_TOP_MAX_PHYS; i++)\n\t\tif (priv->port_mask & BIT(i))\n\t\t\tbrcm_sata_phy_disable(priv, i);\n}\n\nstatic u32 brcm_ahci_get_portmask(struct ahci_host_priv *hpriv,\n\t\t\t\t  struct brcm_ahci_priv *priv)\n{\n\tu32 impl;\n\n\timpl = readl(hpriv->mmio + HOST_PORTS_IMPL);\n\n\tif (fls(impl) > SATA_TOP_MAX_PHYS)\n\t\tdev_warn(priv->dev, \"warning: more ports than PHYs (%#x)\\n\",\n\t\t\t impl);\n\telse if (!impl)\n\t\tdev_info(priv->dev, \"no ports found\\n\");\n\n\treturn impl;\n}\n\nstatic void brcm_sata_init(struct brcm_ahci_priv *priv)\n{\n\tvoid __iomem *ctrl = priv->top_ctrl + SATA_TOP_CTRL_BUS_CTRL;\n\tu32 data;\n\n\t \n\tdata = brcm_sata_readreg(ctrl);\n\tdata &= ~BUS_CTRL_ENDIAN_CONF_MASK;\n\tif (priv->version == BRCM_SATA_NSP)\n\t\tdata |= BUS_CTRL_ENDIAN_NSP_CONF;\n\telse\n\t\tdata |= BUS_CTRL_ENDIAN_CONF;\n\tbrcm_sata_writereg(data, ctrl);\n}\n\nstatic unsigned int brcm_ahci_read_id(struct ata_device *dev,\n\t\t\t\t      struct ata_taskfile *tf, __le16 *id)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct ata_host *host = ap->host;\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct brcm_ahci_priv *priv = hpriv->plat_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tunsigned int err_mask;\n\tunsigned long flags;\n\tint i, rc;\n\tu32 ctl;\n\n\t \n\terr_mask = ata_do_dev_read_id(dev, tf, id);\n\tif (likely(!err_mask))\n\t\treturn err_mask;\n\n\t \n\tspin_lock_irqsave(&host->lock, flags);\n\tctl = readl(mmio + HOST_CTL);\n\tctl &= ~HOST_IRQ_EN;\n\twritel(ctl, mmio + HOST_CTL);\n\treadl(mmio + HOST_CTL);  \n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t \n\tbrcm_sata_phy_disable(priv, ap->port_no);\n\n\t \n\tahci_platform_disable_clks(hpriv);\n\tmsleep(10);\n\n\tahci_platform_enable_clks(hpriv);\n\tmsleep(10);\n\n\t \n\tbrcm_sata_phy_enable(priv, ap->port_no);\n\n\t \n\tfor (i = 0; i < hpriv->nports; i++) {\n\t\trc = phy_init(hpriv->phys[i]);\n\t\tif (rc)\n\t\t\tgoto disable_phys;\n\n\t\trc = phy_calibrate(hpriv->phys[i]);\n\t\tif (rc) {\n\t\t\tphy_exit(hpriv->phys[i]);\n\t\t\tgoto disable_phys;\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&host->lock, flags);\n\tctl = readl(mmio + HOST_CTL);\n\tctl |= HOST_IRQ_EN;\n\twritel(ctl, mmio + HOST_CTL);\n\treadl(mmio + HOST_CTL);  \n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn ata_do_dev_read_id(dev, tf, id);\n\ndisable_phys:\n\twhile (--i >= 0) {\n\t\tphy_power_off(hpriv->phys[i]);\n\t\tphy_exit(hpriv->phys[i]);\n\t}\n\n\treturn AC_ERR_OTHER;\n}\n\nstatic void brcm_ahci_host_stop(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\n\tahci_platform_disable_resources(hpriv);\n}\n\nstatic struct ata_port_operations ahci_brcm_platform_ops = {\n\t.inherits\t= &ahci_ops,\n\t.host_stop\t= brcm_ahci_host_stop,\n\t.read_id\t= brcm_ahci_read_id,\n};\n\nstatic const struct ata_port_info ahci_brcm_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON | ATA_FLAG_NO_DIPM,\n\t.link_flags\t= ATA_LFLAG_NO_DEBOUNCE_DELAY,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_brcm_platform_ops,\n};\n\nstatic int brcm_ahci_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct brcm_ahci_priv *priv = hpriv->plat_data;\n\tint ret;\n\n\tbrcm_sata_phys_disable(priv);\n\n\tif (IS_ENABLED(CONFIG_PM_SLEEP))\n\t\tret = ahci_platform_suspend(dev);\n\telse\n\t\tret = 0;\n\n\treset_control_assert(priv->rcdev_ahci);\n\treset_control_rearm(priv->rcdev_rescal);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused brcm_ahci_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct brcm_ahci_priv *priv = hpriv->plat_data;\n\tint ret = 0;\n\n\tret = reset_control_deassert(priv->rcdev_ahci);\n\tif (ret)\n\t\treturn ret;\n\tret = reset_control_reset(priv->rcdev_rescal);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ahci_platform_enable_clks(hpriv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ahci_platform_enable_regulators(hpriv);\n\tif (ret)\n\t\tgoto out_disable_clks;\n\n\tbrcm_sata_init(priv);\n\tbrcm_sata_phys_enable(priv);\n\tbrcm_sata_alpm_init(hpriv);\n\n\t \n\tret = ahci_platform_enable_phys(hpriv);\n\tif (ret)\n\t\tgoto out_disable_phys;\n\n\tret = ahci_platform_resume_host(dev);\n\tif (ret)\n\t\tgoto out_disable_platform_phys;\n\n\t \n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nout_disable_platform_phys:\n\tahci_platform_disable_phys(hpriv);\nout_disable_phys:\n\tbrcm_sata_phys_disable(priv);\n\tahci_platform_disable_regulators(hpriv);\nout_disable_clks:\n\tahci_platform_disable_clks(hpriv);\n\treturn ret;\n}\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic const struct of_device_id ahci_of_match[] = {\n\t{.compatible = \"brcm,bcm7425-ahci\", .data = (void *)BRCM_SATA_BCM7425},\n\t{.compatible = \"brcm,bcm7445-ahci\", .data = (void *)BRCM_SATA_BCM7445},\n\t{.compatible = \"brcm,bcm63138-ahci\", .data = (void *)BRCM_SATA_BCM7445},\n\t{.compatible = \"brcm,bcm-nsp-ahci\", .data = (void *)BRCM_SATA_NSP},\n\t{.compatible = \"brcm,bcm7216-ahci\", .data = (void *)BRCM_SATA_BCM7216},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_of_match);\n\nstatic int brcm_ahci_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tstruct device *dev = &pdev->dev;\n\tstruct brcm_ahci_priv *priv;\n\tstruct ahci_host_priv *hpriv;\n\tstruct resource *res;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(ahci_of_match, pdev->dev.of_node);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tpriv->version = (unsigned long)of_id->data;\n\tpriv->dev = dev;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"top-ctrl\");\n\tpriv->top_ctrl = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->top_ctrl))\n\t\treturn PTR_ERR(priv->top_ctrl);\n\n\tif (priv->version == BRCM_SATA_BCM7216) {\n\t\tpriv->rcdev_rescal = devm_reset_control_get_optional_shared(\n\t\t\t&pdev->dev, \"rescal\");\n\t\tif (IS_ERR(priv->rcdev_rescal))\n\t\t\treturn PTR_ERR(priv->rcdev_rescal);\n\t}\n\tpriv->rcdev_ahci = devm_reset_control_get_optional(&pdev->dev, \"ahci\");\n\tif (IS_ERR(priv->rcdev_ahci))\n\t\treturn PTR_ERR(priv->rcdev_ahci);\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\thpriv->plat_data = priv;\n\thpriv->flags = AHCI_HFLAG_WAKE_BEFORE_STOP | AHCI_HFLAG_NO_WRITE_TO_RO;\n\n\tswitch (priv->version) {\n\tcase BRCM_SATA_BCM7425:\n\t\thpriv->flags |= AHCI_HFLAG_DELAY_ENGINE;\n\t\tfallthrough;\n\tcase BRCM_SATA_NSP:\n\t\thpriv->flags |= AHCI_HFLAG_NO_NCQ;\n\t\tpriv->quirks |= BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = reset_control_reset(priv->rcdev_rescal);\n\tif (ret)\n\t\treturn ret;\n\tret = reset_control_deassert(priv->rcdev_ahci);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ahci_platform_enable_clks(hpriv);\n\tif (ret)\n\t\tgoto out_reset;\n\n\tret = ahci_platform_enable_regulators(hpriv);\n\tif (ret)\n\t\tgoto out_disable_clks;\n\n\t \n\tbrcm_sata_init(priv);\n\n\t \n\tpriv->port_mask = brcm_ahci_get_portmask(hpriv, priv);\n\tif (!priv->port_mask) {\n\t\tret = -ENODEV;\n\t\tgoto out_disable_regulators;\n\t}\n\n\t \n\tbrcm_sata_phys_enable(priv);\n\n\tbrcm_sata_alpm_init(hpriv);\n\n\tret = ahci_platform_enable_phys(hpriv);\n\tif (ret)\n\t\tgoto out_disable_phys;\n\n\tret = ahci_platform_init_host(pdev, hpriv, &ahci_brcm_port_info,\n\t\t\t\t      &ahci_platform_sht);\n\tif (ret)\n\t\tgoto out_disable_platform_phys;\n\n\tdev_info(dev, \"Broadcom AHCI SATA3 registered\\n\");\n\n\treturn 0;\n\nout_disable_platform_phys:\n\tahci_platform_disable_phys(hpriv);\nout_disable_phys:\n\tbrcm_sata_phys_disable(priv);\nout_disable_regulators:\n\tahci_platform_disable_regulators(hpriv);\nout_disable_clks:\n\tahci_platform_disable_clks(hpriv);\nout_reset:\n\treset_control_assert(priv->rcdev_ahci);\n\treset_control_rearm(priv->rcdev_rescal);\n\treturn ret;\n}\n\nstatic void brcm_ahci_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = dev_get_drvdata(&pdev->dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct brcm_ahci_priv *priv = hpriv->plat_data;\n\n\tbrcm_sata_phys_disable(priv);\n\n\tata_platform_remove_one(pdev);\n}\n\nstatic void brcm_ahci_shutdown(struct platform_device *pdev)\n{\n\tint ret;\n\n\t \n\tret = brcm_ahci_suspend(&pdev->dev);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to shutdown\\n\");\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahci_brcm_pm_ops, brcm_ahci_suspend, brcm_ahci_resume);\n\nstatic struct platform_driver brcm_ahci_driver = {\n\t.probe = brcm_ahci_probe,\n\t.remove_new = brcm_ahci_remove,\n\t.shutdown = brcm_ahci_shutdown,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_of_match,\n\t\t.pm = &ahci_brcm_pm_ops,\n\t},\n};\nmodule_platform_driver(brcm_ahci_driver);\n\nMODULE_DESCRIPTION(\"Broadcom SATA3 AHCI Controller Driver\");\nMODULE_AUTHOR(\"Brian Norris\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sata-brcmstb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}