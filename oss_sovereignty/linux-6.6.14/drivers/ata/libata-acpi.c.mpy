{
  "module_name": "libata-acpi.c",
  "hash_id": "c457ae7e5897911a3fe76eacfecf10ae8e7b9aacee9c9e20acff46c036a5a6b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-acpi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ata.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/libata.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <scsi/scsi_device.h>\n#include \"libata.h\"\n\nunsigned int ata_acpi_gtf_filter = ATA_ACPI_FILTER_DEFAULT;\nmodule_param_named(acpi_gtf_filter, ata_acpi_gtf_filter, int, 0644);\nMODULE_PARM_DESC(acpi_gtf_filter, \"filter mask for ACPI _GTF commands, set to filter out (0x1=set xfermode, 0x2=lock/freeze lock, 0x4=DIPM, 0x8=FPDMA non-zero offset, 0x10=FPDMA DMA Setup FIS auto-activate)\");\n\n#define NO_PORT_MULT\t\t0xffff\n#define SATA_ADR(root, pmp)\t(((root) << 16) | (pmp))\n\n#define REGS_PER_GTF\t\t7\nstruct ata_acpi_gtf {\n\tu8\ttf[REGS_PER_GTF];\t \n} __packed;\n\nstatic void ata_acpi_clear_gtf(struct ata_device *dev)\n{\n\tkfree(dev->gtf_cache);\n\tdev->gtf_cache = NULL;\n}\n\nstruct ata_acpi_hotplug_context {\n\tstruct acpi_hotplug_context hp;\n\tunion {\n\t\tstruct ata_port *ap;\n\t\tstruct ata_device *dev;\n\t} data;\n};\n\n#define ata_hotplug_data(context) (container_of((context), struct ata_acpi_hotplug_context, hp)->data)\n\n \nacpi_handle ata_dev_acpi_handle(struct ata_device *dev)\n{\n\treturn dev->flags & ATA_DFLAG_ACPI_DISABLED ?\n\t\t\tNULL : ACPI_HANDLE(&dev->tdev);\n}\n\n \nstatic void ata_acpi_detach_device(struct ata_port *ap, struct ata_device *dev)\n{\n\tif (dev)\n\t\tdev->flags |= ATA_DFLAG_DETACH;\n\telse {\n\t\tstruct ata_link *tlink;\n\t\tstruct ata_device *tdev;\n\n\t\tata_for_each_link(tlink, ap, EDGE)\n\t\t\tata_for_each_dev(tdev, tlink, ALL)\n\t\t\t\ttdev->flags |= ATA_DFLAG_DETACH;\n\t}\n\n\tata_port_schedule_eh(ap);\n}\n\n \nstatic void ata_acpi_handle_hotplug(struct ata_port *ap, struct ata_device *dev,\n\t\t\t\t    u32 event)\n{\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tint wait = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t \n\tswitch (event) {\n\tcase ACPI_NOTIFY_BUS_CHECK:\n\tcase ACPI_NOTIFY_DEVICE_CHECK:\n\t\tata_ehi_push_desc(ehi, \"ACPI event\");\n\n\t\tata_ehi_hotplugged(ehi);\n\t\tata_port_freeze(ap);\n\t\tbreak;\n\tcase ACPI_NOTIFY_EJECT_REQUEST:\n\t\tata_ehi_push_desc(ehi, \"ACPI event\");\n\n\t\tata_acpi_detach_device(ap, dev);\n\t\twait = 1;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tif (wait)\n\t\tata_port_wait_eh(ap);\n}\n\nstatic int ata_acpi_dev_notify_dock(struct acpi_device *adev, u32 event)\n{\n\tstruct ata_device *dev = ata_hotplug_data(adev->hp).dev;\n\tata_acpi_handle_hotplug(dev->link->ap, dev, event);\n\treturn 0;\n}\n\nstatic int ata_acpi_ap_notify_dock(struct acpi_device *adev, u32 event)\n{\n\tata_acpi_handle_hotplug(ata_hotplug_data(adev->hp).ap, NULL, event);\n\treturn 0;\n}\n\nstatic void ata_acpi_uevent(struct ata_port *ap, struct ata_device *dev,\n\tu32 event)\n{\n\tstruct kobject *kobj = NULL;\n\tchar event_string[20];\n\tchar *envp[] = { event_string, NULL };\n\n\tif (dev) {\n\t\tif (dev->sdev)\n\t\t\tkobj = &dev->sdev->sdev_gendev.kobj;\n\t} else\n\t\tkobj = &ap->dev->kobj;\n\n\tif (kobj) {\n\t\tsnprintf(event_string, 20, \"BAY_EVENT=%d\", event);\n\t\tkobject_uevent_env(kobj, KOBJ_CHANGE, envp);\n\t}\n}\n\nstatic void ata_acpi_ap_uevent(struct acpi_device *adev, u32 event)\n{\n\tata_acpi_uevent(ata_hotplug_data(adev->hp).ap, NULL, event);\n}\n\nstatic void ata_acpi_dev_uevent(struct acpi_device *adev, u32 event)\n{\n\tstruct ata_device *dev = ata_hotplug_data(adev->hp).dev;\n\tata_acpi_uevent(dev->link->ap, dev, event);\n}\n\n \nvoid ata_acpi_bind_port(struct ata_port *ap)\n{\n\tstruct acpi_device *host_companion = ACPI_COMPANION(ap->host->dev);\n\tstruct acpi_device *adev;\n\tstruct ata_acpi_hotplug_context *context;\n\n\tif (libata_noacpi || ap->flags & ATA_FLAG_ACPI_SATA || !host_companion)\n\t\treturn;\n\n\tacpi_preset_companion(&ap->tdev, host_companion, ap->port_no);\n\n\tif (ata_acpi_gtm(ap, &ap->__acpi_init_gtm) == 0)\n\t\tap->pflags |= ATA_PFLAG_INIT_GTM_VALID;\n\n\tadev = ACPI_COMPANION(&ap->tdev);\n\tif (!adev || adev->hp)\n\t\treturn;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn;\n\n\tcontext->data.ap = ap;\n\tacpi_initialize_hp_context(adev, &context->hp, ata_acpi_ap_notify_dock,\n\t\t\t\t   ata_acpi_ap_uevent);\n}\n\nvoid ata_acpi_bind_dev(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct acpi_device *port_companion = ACPI_COMPANION(&ap->tdev);\n\tstruct acpi_device *host_companion = ACPI_COMPANION(ap->host->dev);\n\tstruct acpi_device *parent, *adev;\n\tstruct ata_acpi_hotplug_context *context;\n\tu64 adr;\n\n\t \n\tif (libata_noacpi || !host_companion ||\n\t\t\t(!(ap->flags & ATA_FLAG_ACPI_SATA) && !port_companion))\n\t\treturn;\n\n\tif (ap->flags & ATA_FLAG_ACPI_SATA) {\n\t\tif (!sata_pmp_attached(ap))\n\t\t\tadr = SATA_ADR(ap->port_no, NO_PORT_MULT);\n\t\telse\n\t\t\tadr = SATA_ADR(ap->port_no, dev->link->pmp);\n\t\tparent = host_companion;\n\t} else {\n\t\tadr = dev->devno;\n\t\tparent = port_companion;\n\t}\n\n\tacpi_preset_companion(&dev->tdev, parent, adr);\n\tadev = ACPI_COMPANION(&dev->tdev);\n\tif (!adev || adev->hp)\n\t\treturn;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn;\n\n\tcontext->data.dev = dev;\n\tacpi_initialize_hp_context(adev, &context->hp, ata_acpi_dev_notify_dock,\n\t\t\t\t   ata_acpi_dev_uevent);\n}\n\n \nvoid ata_acpi_dissociate(struct ata_host *host)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\n\n\t\tif (ACPI_HANDLE(&ap->tdev) && gtm)\n\t\t\tata_acpi_stm(ap, gtm);\n\t}\n}\n\n \nint ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *gtm)\n{\n\tstruct acpi_buffer output = { .length = ACPI_ALLOCATE_BUFFER };\n\tunion acpi_object *out_obj;\n\tacpi_status status;\n\tint rc = 0;\n\tacpi_handle handle = ACPI_HANDLE(&ap->tdev);\n\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_object(handle, \"_GTM\", NULL, &output);\n\n\trc = -ENOENT;\n\tif (status == AE_NOT_FOUND)\n\t\tgoto out_free;\n\n\trc = -EINVAL;\n\tif (ACPI_FAILURE(status)) {\n\t\tata_port_err(ap, \"ACPI get timing mode failed (AE 0x%x)\\n\",\n\t\t\t     status);\n\t\tgoto out_free;\n\t}\n\n\tout_obj = output.pointer;\n\tif (out_obj->type != ACPI_TYPE_BUFFER) {\n\t\tata_port_warn(ap, \"_GTM returned unexpected object type 0x%x\\n\",\n\t\t\t      out_obj->type);\n\n\t\tgoto out_free;\n\t}\n\n\tif (out_obj->buffer.length != sizeof(struct ata_acpi_gtm)) {\n\t\tata_port_err(ap, \"_GTM returned invalid length %d\\n\",\n\t\t\t     out_obj->buffer.length);\n\t\tgoto out_free;\n\t}\n\n\tmemcpy(gtm, out_obj->buffer.pointer, sizeof(struct ata_acpi_gtm));\n\trc = 0;\n out_free:\n\tkfree(output.pointer);\n\treturn rc;\n}\n\nEXPORT_SYMBOL_GPL(ata_acpi_gtm);\n\n \nint ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm)\n{\n\tacpi_status status;\n\tstruct ata_acpi_gtm\t\tstm_buf = *stm;\n\tstruct acpi_object_list         input;\n\tunion acpi_object               in_params[3];\n\n\tin_params[0].type = ACPI_TYPE_BUFFER;\n\tin_params[0].buffer.length = sizeof(struct ata_acpi_gtm);\n\tin_params[0].buffer.pointer = (u8 *)&stm_buf;\n\t \n\tin_params[1].type = ACPI_TYPE_BUFFER;\n\tin_params[1].buffer.length = 512;\n\tin_params[1].buffer.pointer = (u8 *)ap->link.device[0].id;\n\tin_params[2].type = ACPI_TYPE_BUFFER;\n\tin_params[2].buffer.length = 512;\n\tin_params[2].buffer.pointer = (u8 *)ap->link.device[1].id;\n\n\tinput.count = 3;\n\tinput.pointer = in_params;\n\n\tstatus = acpi_evaluate_object(ACPI_HANDLE(&ap->tdev), \"_STM\",\n\t\t\t\t      &input, NULL);\n\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENOENT;\n\tif (ACPI_FAILURE(status)) {\n\t\tata_port_err(ap, \"ACPI set timing mode failed (status=0x%x)\\n\",\n\t\t\t     status);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(ata_acpi_stm);\n\n \nstatic int ata_dev_get_GTF(struct ata_device *dev, struct ata_acpi_gtf **gtf)\n{\n\tacpi_status status;\n\tstruct acpi_buffer output;\n\tunion acpi_object *out_obj;\n\tint rc = 0;\n\n\t \n\tif (dev->gtf_cache) {\n\t\tout_obj = dev->gtf_cache;\n\t\tgoto done;\n\t}\n\n\t \n\toutput.length = ACPI_ALLOCATE_BUFFER;\n\toutput.pointer = NULL;\t \n\n\t \n\tstatus = acpi_evaluate_object(ata_dev_acpi_handle(dev), \"_GTF\", NULL,\n\t\t\t\t      &output);\n\tout_obj = dev->gtf_cache = output.pointer;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND) {\n\t\t\tata_dev_warn(dev, \"_GTF evaluation failed (AE 0x%x)\\n\",\n\t\t\t\t     status);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!output.length || !output.pointer) {\n\t\tata_dev_dbg(dev, \"Run _GTF: length or ptr is NULL (0x%llx, 0x%p)\\n\",\n\t\t\t    (unsigned long long)output.length,\n\t\t\t    output.pointer);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (out_obj->type != ACPI_TYPE_BUFFER) {\n\t\tata_dev_warn(dev, \"_GTF unexpected object type 0x%x\\n\",\n\t\t\t     out_obj->type);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (out_obj->buffer.length % REGS_PER_GTF) {\n\t\tata_dev_warn(dev, \"unexpected _GTF length (%d)\\n\",\n\t\t\t     out_obj->buffer.length);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n done:\n\trc = out_obj->buffer.length / REGS_PER_GTF;\n\tif (gtf) {\n\t\t*gtf = (void *)out_obj->buffer.pointer;\n\t\tata_dev_dbg(dev, \"returning gtf=%p, gtf_count=%d\\n\",\n\t\t\t    *gtf, rc);\n\t}\n\treturn rc;\n\n out_free:\n\tata_acpi_clear_gtf(dev);\n\treturn rc;\n}\n\n \nunsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,\n\t\t\t\t   const struct ata_acpi_gtm *gtm)\n{\n\tunsigned int xfer_mask = 0;\n\tunsigned int type;\n\tint unit;\n\tu8 mode;\n\n\t \n\tunit = dev->devno;\n\tif (!(gtm->flags & 0x10))\n\t\tunit = 0;\n\n\t \n\tmode = ata_timing_cycle2mode(ATA_SHIFT_PIO, gtm->drive[unit].pio);\n\txfer_mask |= ata_xfer_mode2mask(mode);\n\n\t \n\tif (!(gtm->flags & (1 << (2 * unit))))\n\t\ttype = ATA_SHIFT_MWDMA;\n\telse\n\t\ttype = ATA_SHIFT_UDMA;\n\n\tmode = ata_timing_cycle2mode(type, gtm->drive[unit].dma);\n\txfer_mask |= ata_xfer_mode2mask(mode);\n\n\treturn xfer_mask;\n}\nEXPORT_SYMBOL_GPL(ata_acpi_gtm_xfermask);\n\n \nint ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm)\n{\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, &ap->link, ENABLED) {\n\t\tunsigned int xfer_mask, udma_mask;\n\n\t\txfer_mask = ata_acpi_gtm_xfermask(dev, gtm);\n\t\tata_unpack_xfermask(xfer_mask, NULL, NULL, &udma_mask);\n\n\t\tif (udma_mask & ~ATA_UDMA_MASK_40C)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_acpi_cbl_80wire);\n\nstatic void ata_acpi_gtf_to_tf(struct ata_device *dev,\n\t\t\t       const struct ata_acpi_gtf *gtf,\n\t\t\t       struct ata_taskfile *tf)\n{\n\tata_tf_init(dev, tf);\n\n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf->protocol = ATA_PROT_NODATA;\n\ttf->error   = gtf->tf[0];\t \n\ttf->nsect   = gtf->tf[1];\t \n\ttf->lbal    = gtf->tf[2];\t \n\ttf->lbam    = gtf->tf[3];\t \n\ttf->lbah    = gtf->tf[4];\t \n\ttf->device  = gtf->tf[5];\t \n\ttf->status  = gtf->tf[6];\t \n}\n\nstatic int ata_acpi_filter_tf(struct ata_device *dev,\n\t\t\t      const struct ata_taskfile *tf,\n\t\t\t      const struct ata_taskfile *ptf)\n{\n\tif (dev->gtf_filter & ATA_ACPI_FILTER_SETXFER) {\n\t\t \n\t\tif (tf->command == ATA_CMD_SET_FEATURES &&\n\t\t    tf->feature == SETFEATURES_XFER)\n\t\t\treturn 1;\n\t}\n\n\tif (dev->gtf_filter & ATA_ACPI_FILTER_LOCK) {\n\t\t \n\n\t\t \n\t\tif (tf->command == ATA_CMD_CONF_OVERLAY &&\n\t\t    tf->feature == ATA_DCO_FREEZE_LOCK)\n\t\t\treturn 1;\n\n\t\t \n\t\tif (tf->command == ATA_CMD_SEC_FREEZE_LOCK)\n\t\t\treturn 1;\n\n\t\t \n\t\tif ((!ptf || ptf->command != ATA_CMD_READ_NATIVE_MAX) &&\n\t\t    tf->command == ATA_CMD_SET_MAX &&\n\t\t    (tf->feature == ATA_SET_MAX_LOCK ||\n\t\t     tf->feature == ATA_SET_MAX_FREEZE_LOCK))\n\t\t\treturn 1;\n\t}\n\n\tif (tf->command == ATA_CMD_SET_FEATURES &&\n\t    tf->feature == SETFEATURES_SATA_ENABLE) {\n\t\t \n\t\tif (dev->gtf_filter & ATA_ACPI_FILTER_DIPM &&\n\t\t    tf->nsect == SATA_DIPM)\n\t\t\treturn 1;\n\n\t\t \n\t\tif (dev->gtf_filter & ATA_ACPI_FILTER_FPDMA_OFFSET &&\n\t\t    (tf->nsect == SATA_FPDMA_OFFSET ||\n\t\t     tf->nsect == SATA_FPDMA_IN_ORDER))\n\t\t\treturn 1;\n\n\t\t \n\t\tif (dev->gtf_filter & ATA_ACPI_FILTER_FPDMA_AA &&\n\t\t    tf->nsect == SATA_FPDMA_AA)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ata_acpi_run_tf(struct ata_device *dev,\n\t\t\t   const struct ata_acpi_gtf *gtf,\n\t\t\t   const struct ata_acpi_gtf *prev_gtf)\n{\n\tstruct ata_taskfile *pptf = NULL;\n\tstruct ata_taskfile tf, ptf, rtf;\n\tunsigned int err_mask;\n\tconst char *descr;\n\tint rc;\n\n\tif ((gtf->tf[0] == 0) && (gtf->tf[1] == 0) && (gtf->tf[2] == 0)\n\t    && (gtf->tf[3] == 0) && (gtf->tf[4] == 0) && (gtf->tf[5] == 0)\n\t    && (gtf->tf[6] == 0))\n\t\treturn 0;\n\n\tata_acpi_gtf_to_tf(dev, gtf, &tf);\n\tif (prev_gtf) {\n\t\tata_acpi_gtf_to_tf(dev, prev_gtf, &ptf);\n\t\tpptf = &ptf;\n\t}\n\n\tdescr = ata_get_cmd_name(tf.command);\n\n\tif (!ata_acpi_filter_tf(dev, &tf, pptf)) {\n\t\trtf = tf;\n\t\terr_mask = ata_exec_internal(dev, &rtf, NULL,\n\t\t\t\t\t     DMA_NONE, NULL, 0, 0);\n\n\t\tswitch (err_mask) {\n\t\tcase 0:\n\t\t\tata_dev_dbg(dev,\n\t\t\t\t\"ACPI cmd %02x/%02x:%02x:%02x:%02x:%02x:%02x\"\n\t\t\t\t\"(%s) succeeded\\n\",\n\t\t\t\ttf.command, tf.feature, tf.nsect, tf.lbal,\n\t\t\t\ttf.lbam, tf.lbah, tf.device, descr);\n\t\t\trc = 1;\n\t\t\tbreak;\n\n\t\tcase AC_ERR_DEV:\n\t\t\tata_dev_info(dev,\n\t\t\t\t\"ACPI cmd %02x/%02x:%02x:%02x:%02x:%02x:%02x\"\n\t\t\t\t\"(%s) rejected by device (Stat=0x%02x Err=0x%02x)\",\n\t\t\t\ttf.command, tf.feature, tf.nsect, tf.lbal,\n\t\t\t\ttf.lbam, tf.lbah, tf.device, descr,\n\t\t\t\trtf.status, rtf.error);\n\t\t\trc = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tata_dev_err(dev,\n\t\t\t\t\"ACPI cmd %02x/%02x:%02x:%02x:%02x:%02x:%02x\"\n\t\t\t\t\"(%s) failed (Emask=0x%x Stat=0x%02x Err=0x%02x)\",\n\t\t\t\ttf.command, tf.feature, tf.nsect, tf.lbal,\n\t\t\t\ttf.lbam, tf.lbah, tf.device, descr,\n\t\t\t\terr_mask, rtf.status, rtf.error);\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tata_dev_info(dev,\n\t\t\t\"ACPI cmd %02x/%02x:%02x:%02x:%02x:%02x:%02x\"\n\t\t\t\"(%s) filtered out\\n\",\n\t\t\ttf.command, tf.feature, tf.nsect, tf.lbal,\n\t\t\ttf.lbam, tf.lbah, tf.device, descr);\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n\n \nstatic int ata_acpi_exec_tfs(struct ata_device *dev, int *nr_executed)\n{\n\tstruct ata_acpi_gtf *gtf = NULL, *pgtf = NULL;\n\tint gtf_count, i, rc;\n\n\t \n\trc = ata_dev_get_GTF(dev, &gtf);\n\tif (rc < 0)\n\t\treturn rc;\n\tgtf_count = rc;\n\n\t \n\tfor (i = 0; i < gtf_count; i++, gtf++) {\n\t\trc = ata_acpi_run_tf(dev, gtf, pgtf);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tif (rc) {\n\t\t\t(*nr_executed)++;\n\t\t\tpgtf = gtf;\n\t\t}\n\t}\n\n\tata_acpi_clear_gtf(dev);\n\n\tif (rc < 0)\n\t\treturn rc;\n\treturn 0;\n}\n\n \nstatic int ata_acpi_push_id(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tacpi_status status;\n\tstruct acpi_object_list input;\n\tunion acpi_object in_params[1];\n\n\tata_dev_dbg(dev, \"%s: ix = %d, port#: %d\\n\",\n\t\t    __func__, dev->devno, ap->port_no);\n\n\t \n\t \n\tinput.count = 1;\n\tinput.pointer = in_params;\n\tin_params[0].type = ACPI_TYPE_BUFFER;\n\tin_params[0].buffer.length = sizeof(dev->id[0]) * ATA_ID_WORDS;\n\tin_params[0].buffer.pointer = (u8 *)dev->id;\n\t \n\n\t \n\tswap_buf_le16(dev->id, ATA_ID_WORDS);\n\tstatus = acpi_evaluate_object(ata_dev_acpi_handle(dev), \"_SDD\", &input,\n\t\t\t\t      NULL);\n\tswap_buf_le16(dev->id, ATA_ID_WORDS);\n\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENOENT;\n\n\tif (ACPI_FAILURE(status)) {\n\t\tata_dev_warn(dev, \"ACPI _SDD failed (AE 0x%x)\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ata_acpi_on_resume(struct ata_port *ap)\n{\n\tconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\n\tstruct ata_device *dev;\n\n\tif (ACPI_HANDLE(&ap->tdev) && gtm) {\n\t\t \n\n\t\t \n\t\tata_acpi_stm(ap, gtm);\n\n\t\t \n\t\tata_for_each_dev(dev, &ap->link, ALL) {\n\t\t\tata_acpi_clear_gtf(dev);\n\t\t\tif (ata_dev_enabled(dev) &&\n\t\t\t    ata_dev_acpi_handle(dev) &&\n\t\t\t    ata_dev_get_GTF(dev, NULL) >= 0)\n\t\t\t\tdev->flags |= ATA_DFLAG_ACPI_PENDING;\n\t\t}\n\t} else {\n\t\t \n\t\tata_for_each_dev(dev, &ap->link, ALL) {\n\t\t\tata_acpi_clear_gtf(dev);\n\t\t\tif (ata_dev_enabled(dev))\n\t\t\t\tdev->flags |= ATA_DFLAG_ACPI_PENDING;\n\t\t}\n\t}\n}\n\nstatic int ata_acpi_choose_suspend_state(struct ata_device *dev, bool runtime)\n{\n\tint d_max_in = ACPI_STATE_D3_COLD;\n\tif (!runtime)\n\t\tgoto out;\n\n\t \n\tif (dev->class == ATA_DEV_ATAPI &&\n\t    !(zpodd_dev_enabled(dev) && zpodd_zpready(dev)))\n\t\td_max_in = ACPI_STATE_D3_HOT;\n\nout:\n\treturn acpi_pm_device_sleep_state(&dev->tdev, NULL, d_max_in);\n}\n\nstatic void sata_acpi_set_state(struct ata_port *ap, pm_message_t state)\n{\n\tbool runtime = PMSG_IS_AUTO(state);\n\tstruct ata_device *dev;\n\tacpi_handle handle;\n\tint acpi_state;\n\n\tata_for_each_dev(dev, &ap->link, ENABLED) {\n\t\thandle = ata_dev_acpi_handle(dev);\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\tif (!(state.event & PM_EVENT_RESUME)) {\n\t\t\tacpi_state = ata_acpi_choose_suspend_state(dev, runtime);\n\t\t\tif (acpi_state == ACPI_STATE_D0)\n\t\t\t\tcontinue;\n\t\t\tif (runtime && zpodd_dev_enabled(dev) &&\n\t\t\t    acpi_state == ACPI_STATE_D3_COLD)\n\t\t\t\tzpodd_enable_run_wake(dev);\n\t\t\tacpi_bus_set_power(handle, acpi_state);\n\t\t} else {\n\t\t\tif (runtime && zpodd_dev_enabled(dev))\n\t\t\t\tzpodd_disable_run_wake(dev);\n\t\t\tacpi_bus_set_power(handle, ACPI_STATE_D0);\n\t\t}\n\t}\n}\n\n \nstatic void pata_acpi_set_state(struct ata_port *ap, pm_message_t state)\n{\n\tstruct ata_device *dev;\n\tacpi_handle port_handle;\n\n\tport_handle = ACPI_HANDLE(&ap->tdev);\n\tif (!port_handle)\n\t\treturn;\n\n\t \n\tif (state.event & PM_EVENT_RESUME)\n\t\tacpi_bus_set_power(port_handle, ACPI_STATE_D0);\n\n\tata_for_each_dev(dev, &ap->link, ENABLED) {\n\t\tacpi_handle dev_handle = ata_dev_acpi_handle(dev);\n\t\tif (!dev_handle)\n\t\t\tcontinue;\n\n\t\tacpi_bus_set_power(dev_handle, state.event & PM_EVENT_RESUME ?\n\t\t\t\t\tACPI_STATE_D0 : ACPI_STATE_D3_COLD);\n\t}\n\n\tif (!(state.event & PM_EVENT_RESUME))\n\t\tacpi_bus_set_power(port_handle, ACPI_STATE_D3_COLD);\n}\n\n \nvoid ata_acpi_set_state(struct ata_port *ap, pm_message_t state)\n{\n\tif (ap->flags & ATA_FLAG_ACPI_SATA)\n\t\tsata_acpi_set_state(ap, state);\n\telse\n\t\tpata_acpi_set_state(ap, state);\n}\n\n \nint ata_acpi_on_devcfg(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct ata_eh_context *ehc = &ap->link.eh_context;\n\tint acpi_sata = ap->flags & ATA_FLAG_ACPI_SATA;\n\tint nr_executed = 0;\n\tint rc;\n\n\tif (!ata_dev_acpi_handle(dev))\n\t\treturn 0;\n\n\t \n\tif (!(dev->flags & ATA_DFLAG_ACPI_PENDING) &&\n\t    !(acpi_sata && (ehc->i.flags & ATA_EHI_DID_HARDRESET)))\n\t\treturn 0;\n\n\t \n\tif (acpi_sata) {\n\t\trc = ata_acpi_push_id(dev);\n\t\tif (rc && rc != -ENOENT)\n\t\t\tgoto acpi_err;\n\t}\n\n\t \n\trc = ata_acpi_exec_tfs(dev, &nr_executed);\n\tif (rc)\n\t\tgoto acpi_err;\n\n\tdev->flags &= ~ATA_DFLAG_ACPI_PENDING;\n\n\t \n\tif (nr_executed) {\n\t\trc = ata_dev_reread_id(dev, 0);\n\t\tif (rc < 0) {\n\t\t\tata_dev_err(dev,\n\t\t\t\t    \"failed to IDENTIFY after ACPI commands\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n\n acpi_err:\n\t \n\tif (rc == -EINVAL && !nr_executed && !ata_port_is_frozen(ap))\n\t\treturn 0;\n\n\t \n\tif (!(dev->flags & ATA_DFLAG_ACPI_FAILED)) {\n\t\tdev->flags |= ATA_DFLAG_ACPI_FAILED;\n\t\treturn rc;\n\t}\n\n\tdev->flags |= ATA_DFLAG_ACPI_DISABLED;\n\tata_dev_warn(dev, \"ACPI: failed the second time, disabled\\n\");\n\n\t \n\tif (!nr_executed && !ata_port_is_frozen(ap))\n\t\treturn 0;\n\n\treturn rc;\n}\n\n \nvoid ata_acpi_on_disable(struct ata_device *dev)\n{\n\tata_acpi_clear_gtf(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}