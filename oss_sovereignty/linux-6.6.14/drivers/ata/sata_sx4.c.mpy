{
  "module_name": "sata_sx4.c",
  "hash_id": "3eef5537bf9f6ac0873cf6027016d413871a53a5cebae5f91bf3698349977292",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_sx4.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n#include \"sata_promise.h\"\n\n#define DRV_NAME\t\"sata_sx4\"\n#define DRV_VERSION\t\"0.12\"\n\nstatic int dimm_test;\nmodule_param(dimm_test, int, 0644);\nMODULE_PARM_DESC(dimm_test, \"Enable DIMM test during startup (1 = enabled)\");\n\nenum {\n\tPDC_MMIO_BAR\t\t= 3,\n\tPDC_DIMM_BAR\t\t= 4,\n\n\tPDC_PRD_TBL\t\t= 0x44,\t \n\n\tPDC_PKT_SUBMIT\t\t= 0x40,  \n\tPDC_HDMA_PKT_SUBMIT\t= 0x100,  \n\tPDC_INT_SEQMASK\t\t= 0x40,\t \n\tPDC_HDMA_CTLSTAT\t= 0x12C,  \n\n\tPDC_CTLSTAT\t\t= 0x60,\t \n\n\tPDC_20621_SEQCTL\t= 0x400,\n\tPDC_20621_SEQMASK\t= 0x480,\n\tPDC_20621_GENERAL_CTL\t= 0x484,\n\tPDC_20621_PAGE_SIZE\t= (32 * 1024),\n\n\t \n\tPDC_20621_DIMM_WINDOW\t= 0x0C,\t \n\tPDC_20621_DIMM_BASE\t= 0x00200000,\n\tPDC_20621_DIMM_DATA\t= (64 * 1024),\n\tPDC_DIMM_DATA_STEP\t= (256 * 1024),\n\tPDC_DIMM_WINDOW_STEP\t= (8 * 1024),\n\tPDC_DIMM_HOST_PRD\t= (6 * 1024),\n\tPDC_DIMM_HOST_PKT\t= (128 * 0),\n\tPDC_DIMM_HPKT_PRD\t= (128 * 1),\n\tPDC_DIMM_ATA_PKT\t= (128 * 2),\n\tPDC_DIMM_APKT_PRD\t= (128 * 3),\n\tPDC_DIMM_HEADER_SZ\t= PDC_DIMM_APKT_PRD + 128,\n\tPDC_PAGE_WINDOW\t\t= 0x40,\n\tPDC_PAGE_DATA\t\t= PDC_PAGE_WINDOW +\n\t\t\t\t  (PDC_20621_DIMM_DATA / PDC_20621_PAGE_SIZE),\n\tPDC_PAGE_SET\t\t= PDC_DIMM_DATA_STEP / PDC_20621_PAGE_SIZE,\n\n\tPDC_CHIP0_OFS\t\t= 0xC0000,  \n\n\tPDC_20621_ERR_MASK\t= (1<<19) | (1<<20) | (1<<21) | (1<<22) |\n\t\t\t\t  (1<<23),\n\n\tboard_20621\t\t= 0,\t \n\n\tPDC_MASK_INT\t\t= (1 << 10),  \n\tPDC_RESET\t\t= (1 << 11),  \n\tPDC_DMA_ENABLE\t\t= (1 << 7),   \n\n\tPDC_MAX_HDMA\t\t= 32,\n\tPDC_HDMA_Q_MASK\t\t= (PDC_MAX_HDMA - 1),\n\n\tPDC_DIMM0_SPD_DEV_ADDRESS\t= 0x50,\n\tPDC_DIMM1_SPD_DEV_ADDRESS\t= 0x51,\n\tPDC_I2C_CONTROL\t\t\t= 0x48,\n\tPDC_I2C_ADDR_DATA\t\t= 0x4C,\n\tPDC_DIMM0_CONTROL\t\t= 0x80,\n\tPDC_DIMM1_CONTROL\t\t= 0x84,\n\tPDC_SDRAM_CONTROL\t\t= 0x88,\n\tPDC_I2C_WRITE\t\t\t= 0,\t\t \n\tPDC_I2C_READ\t\t\t= (1 << 6),\t \n\tPDC_I2C_START\t\t\t= (1 << 7),\t \n\tPDC_I2C_MASK_INT\t\t= (1 << 5),\t \n\tPDC_I2C_COMPLETE\t\t= (1 << 16),\t \n\tPDC_I2C_NO_ACK\t\t\t= (1 << 20),\t \n\tPDC_DIMM_SPD_SUBADDRESS_START\t= 0x00,\n\tPDC_DIMM_SPD_SUBADDRESS_END\t= 0x7F,\n\tPDC_DIMM_SPD_ROW_NUM\t\t= 3,\n\tPDC_DIMM_SPD_COLUMN_NUM\t\t= 4,\n\tPDC_DIMM_SPD_MODULE_ROW\t\t= 5,\n\tPDC_DIMM_SPD_TYPE\t\t= 11,\n\tPDC_DIMM_SPD_FRESH_RATE\t\t= 12,\n\tPDC_DIMM_SPD_BANK_NUM\t\t= 17,\n\tPDC_DIMM_SPD_CAS_LATENCY\t= 18,\n\tPDC_DIMM_SPD_ATTRIBUTE\t\t= 21,\n\tPDC_DIMM_SPD_ROW_PRE_CHARGE\t= 27,\n\tPDC_DIMM_SPD_ROW_ACTIVE_DELAY\t= 28,\n\tPDC_DIMM_SPD_RAS_CAS_DELAY\t= 29,\n\tPDC_DIMM_SPD_ACTIVE_PRECHARGE\t= 30,\n\tPDC_DIMM_SPD_SYSTEM_FREQ\t= 126,\n\tPDC_CTL_STATUS\t\t\t= 0x08,\n\tPDC_DIMM_WINDOW_CTLR\t\t= 0x0C,\n\tPDC_TIME_CONTROL\t\t= 0x3C,\n\tPDC_TIME_PERIOD\t\t\t= 0x40,\n\tPDC_TIME_COUNTER\t\t= 0x44,\n\tPDC_GENERAL_CTLR\t\t= 0x484,\n\tPCI_PLL_INIT\t\t\t= 0x8A531824,\n\tPCI_X_TCOUNT\t\t\t= 0xEE1E5CFF,\n\n\t \n\tPDC_TIMER_BUZZER\t\t= (1 << 10),\n\tPDC_TIMER_MODE_PERIODIC\t\t= 0,\t\t \n\tPDC_TIMER_MODE_ONCE\t\t= (1 << 8),\t \n\tPDC_TIMER_ENABLE\t\t= (1 << 7),\n\tPDC_TIMER_MASK_INT\t\t= (1 << 5),\n\tPDC_TIMER_SEQ_MASK\t\t= 0x1f,\t\t \n\tPDC_TIMER_DEFAULT\t\t= PDC_TIMER_MODE_ONCE |\n\t\t\t\t\t  PDC_TIMER_ENABLE |\n\t\t\t\t\t  PDC_TIMER_MASK_INT,\n};\n\n#define ECC_ERASE_BUF_SZ (128 * 1024)\n\nstruct pdc_port_priv {\n\tu8\t\t\tdimm_buf[(ATA_PRD_SZ * ATA_MAX_PRD) + 512];\n\tu8\t\t\t*pkt;\n\tdma_addr_t\t\tpkt_dma;\n};\n\nstruct pdc_host_priv {\n\tunsigned int\t\tdoing_hdma;\n\tunsigned int\t\thdma_prod;\n\tunsigned int\t\thdma_cons;\n\tstruct {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int\tseq;\n\t\tunsigned long\tpkt_ofs;\n\t} hdma[32];\n};\n\n\nstatic int pdc_sata_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic void pdc_error_handler(struct ata_port *ap);\nstatic void pdc_freeze(struct ata_port *ap);\nstatic void pdc_thaw(struct ata_port *ap);\nstatic int pdc_port_start(struct ata_port *ap);\nstatic enum ata_completion_errors pdc20621_qc_prep(struct ata_queued_cmd *qc);\nstatic void pdc_tf_load_mmio(struct ata_port *ap, const struct ata_taskfile *tf);\nstatic void pdc_exec_command_mmio(struct ata_port *ap, const struct ata_taskfile *tf);\nstatic unsigned int pdc20621_dimm_init(struct ata_host *host);\nstatic int pdc20621_detect_dimm(struct ata_host *host);\nstatic unsigned int pdc20621_i2c_read(struct ata_host *host,\n\t\t\t\t      u32 device, u32 subaddr, u32 *pdata);\nstatic int pdc20621_prog_dimm0(struct ata_host *host);\nstatic unsigned int pdc20621_prog_dimm_global(struct ata_host *host);\nstatic void pdc20621_get_from_dimm(struct ata_host *host,\n\t\t\t\t   void *psource, u32 offset, u32 size);\nstatic void pdc20621_put_to_dimm(struct ata_host *host,\n\t\t\t\t void *psource, u32 offset, u32 size);\nstatic void pdc20621_irq_clear(struct ata_port *ap);\nstatic unsigned int pdc20621_qc_issue(struct ata_queued_cmd *qc);\nstatic int pdc_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t unsigned long deadline);\nstatic void pdc_post_internal_cmd(struct ata_queued_cmd *qc);\nstatic int pdc_check_atapi_dma(struct ata_queued_cmd *qc);\n\n\nstatic const struct scsi_host_template pdc_sata_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= LIBATA_MAX_PRD,\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations pdc_20621_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\n\t.check_atapi_dma\t= pdc_check_atapi_dma,\n\t.qc_prep\t\t= pdc20621_qc_prep,\n\t.qc_issue\t\t= pdc20621_qc_issue,\n\n\t.freeze\t\t\t= pdc_freeze,\n\t.thaw\t\t\t= pdc_thaw,\n\t.softreset\t\t= pdc_softreset,\n\t.error_handler\t\t= pdc_error_handler,\n\t.lost_interrupt\t\t= ATA_OP_NULL,\n\t.post_internal_cmd\t= pdc_post_internal_cmd,\n\n\t.port_start\t\t= pdc_port_start,\n\n\t.sff_tf_load\t\t= pdc_tf_load_mmio,\n\t.sff_exec_command\t= pdc_exec_command_mmio,\n\t.sff_irq_clear\t\t= pdc20621_irq_clear,\n};\n\nstatic const struct ata_port_info pdc_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SATA | ATA_FLAG_NO_ATAPI |\n\t\t\t\t  ATA_FLAG_PIO_POLLING,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc_20621_ops,\n\t},\n\n};\n\nstatic const struct pci_device_id pdc_sata_pci_tbl[] = {\n\t{ PCI_VDEVICE(PROMISE, 0x6622), board_20621 },\n\n\t{ }\t \n};\n\nstatic struct pci_driver pdc_sata_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= pdc_sata_pci_tbl,\n\t.probe\t\t\t= pdc_sata_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\n\nstatic int pdc_port_start(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct pdc_port_priv *pp;\n\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tpp->pkt = dmam_alloc_coherent(dev, 128, &pp->pkt_dma, GFP_KERNEL);\n\tif (!pp->pkt)\n\t\treturn -ENOMEM;\n\n\tap->private_data = pp;\n\n\treturn 0;\n}\n\nstatic inline void pdc20621_ata_sg(u8 *buf, unsigned int portno,\n\t\t\t\t   unsigned int total_len)\n{\n\tu32 addr;\n\tunsigned int dw = PDC_DIMM_APKT_PRD >> 2;\n\t__le32 *buf32 = (__le32 *) buf;\n\n\t \n\taddr = PDC_20621_DIMM_BASE + PDC_20621_DIMM_DATA +\n\t       (PDC_DIMM_DATA_STEP * portno);\n\n\tbuf32[dw] = cpu_to_le32(addr);\n\tbuf32[dw + 1] = cpu_to_le32(total_len | ATA_PRD_EOT);\n}\n\nstatic inline void pdc20621_host_sg(u8 *buf, unsigned int portno,\n\t\t\t\t    unsigned int total_len)\n{\n\tu32 addr;\n\tunsigned int dw = PDC_DIMM_HPKT_PRD >> 2;\n\t__le32 *buf32 = (__le32 *) buf;\n\n\t \n\taddr = PDC_20621_DIMM_BASE + PDC_20621_DIMM_DATA +\n\t       (PDC_DIMM_DATA_STEP * portno);\n\n\tbuf32[dw] = cpu_to_le32(addr);\n\tbuf32[dw + 1] = cpu_to_le32(total_len | ATA_PRD_EOT);\n}\n\nstatic inline unsigned int pdc20621_ata_pkt(struct ata_taskfile *tf,\n\t\t\t\t\t    unsigned int devno, u8 *buf,\n\t\t\t\t\t    unsigned int portno)\n{\n\tunsigned int i, dw;\n\t__le32 *buf32 = (__le32 *) buf;\n\tu8 dev_reg;\n\n\tunsigned int dimm_sg = PDC_20621_DIMM_BASE +\n\t\t\t       (PDC_DIMM_WINDOW_STEP * portno) +\n\t\t\t       PDC_DIMM_APKT_PRD;\n\n\ti = PDC_DIMM_ATA_PKT;\n\n\t \n\tif ((tf->protocol == ATA_PROT_DMA) && (!(tf->flags & ATA_TFLAG_WRITE)))\n\t\tbuf[i++] = PDC_PKT_READ;\n\telse if (tf->protocol == ATA_PROT_NODATA)\n\t\tbuf[i++] = PDC_PKT_NODATA;\n\telse\n\t\tbuf[i++] = 0;\n\tbuf[i++] = 0;\t\t\t \n\tbuf[i++] = portno + 1;\t\t \n\tbuf[i++] = 0xff;\t\t \n\n\t \n\tdw = i >> 2;\n\tif (tf->protocol == ATA_PROT_NODATA)\n\t\tbuf32[dw] = 0;\n\telse\n\t\tbuf32[dw] = cpu_to_le32(dimm_sg);\n\tbuf32[dw + 1] = 0;\n\ti += 8;\n\n\tif (devno == 0)\n\t\tdev_reg = ATA_DEVICE_OBS;\n\telse\n\t\tdev_reg = ATA_DEVICE_OBS | ATA_DEV1;\n\n\t \n\tbuf[i++] = (1 << 5) | PDC_PKT_CLEAR_BSY | ATA_REG_DEVICE;\n\tbuf[i++] = dev_reg;\n\n\t \n\tbuf[i++] = (1 << 5) | PDC_REG_DEVCTL;\n\tbuf[i++] = tf->ctl;\n\n\treturn i;\n}\n\nstatic inline void pdc20621_host_pkt(struct ata_taskfile *tf, u8 *buf,\n\t\t\t\t     unsigned int portno)\n{\n\tunsigned int dw;\n\tu32 tmp;\n\t__le32 *buf32 = (__le32 *) buf;\n\n\tunsigned int host_sg = PDC_20621_DIMM_BASE +\n\t\t\t       (PDC_DIMM_WINDOW_STEP * portno) +\n\t\t\t       PDC_DIMM_HOST_PRD;\n\tunsigned int dimm_sg = PDC_20621_DIMM_BASE +\n\t\t\t       (PDC_DIMM_WINDOW_STEP * portno) +\n\t\t\t       PDC_DIMM_HPKT_PRD;\n\n\tdw = PDC_DIMM_HOST_PKT >> 2;\n\n\t \n\tif ((tf->protocol == ATA_PROT_DMA) && (!(tf->flags & ATA_TFLAG_WRITE)))\n\t\ttmp = PDC_PKT_READ;\n\telse\n\t\ttmp = 0;\n\ttmp |= ((portno + 1 + 4) << 16);\t \n\ttmp |= (0xff << 24);\t\t\t \n\tbuf32[dw + 0] = cpu_to_le32(tmp);\n\tbuf32[dw + 1] = cpu_to_le32(host_sg);\n\tbuf32[dw + 2] = cpu_to_le32(dimm_sg);\n\tbuf32[dw + 3] = 0;\n}\n\nstatic void pdc20621_dma_prep(struct ata_queued_cmd *qc)\n{\n\tstruct scatterlist *sg;\n\tstruct ata_port *ap = qc->ap;\n\tstruct pdc_port_priv *pp = ap->private_data;\n\tvoid __iomem *mmio = ap->host->iomap[PDC_MMIO_BAR];\n\tvoid __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];\n\tunsigned int portno = ap->port_no;\n\tunsigned int i, si, idx, total_len = 0, sgt_len;\n\t__le32 *buf = (__le32 *) &pp->dimm_buf[PDC_DIMM_HEADER_SZ];\n\n\tWARN_ON(!(qc->flags & ATA_QCFLAG_DMAMAP));\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\t \n\tidx = 0;\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tbuf[idx++] = cpu_to_le32(sg_dma_address(sg));\n\t\tbuf[idx++] = cpu_to_le32(sg_dma_len(sg));\n\t\ttotal_len += sg_dma_len(sg);\n\t}\n\tbuf[idx - 1] |= cpu_to_le32(ATA_PRD_EOT);\n\tsgt_len = idx * 4;\n\n\t \n\tpdc20621_host_sg(&pp->dimm_buf[0], portno, total_len);\n\tpdc20621_host_pkt(&qc->tf, &pp->dimm_buf[0], portno);\n\n\tpdc20621_ata_sg(&pp->dimm_buf[0], portno, total_len);\n\ti = pdc20621_ata_pkt(&qc->tf, qc->dev->devno, &pp->dimm_buf[0], portno);\n\n\tif (qc->tf.flags & ATA_TFLAG_LBA48)\n\t\ti = pdc_prep_lba48(&qc->tf, &pp->dimm_buf[0], i);\n\telse\n\t\ti = pdc_prep_lba28(&qc->tf, &pp->dimm_buf[0], i);\n\n\tpdc_pkt_footer(&qc->tf, &pp->dimm_buf[0], i);\n\n\t \n\tmemcpy_toio(dimm_mmio + (portno * PDC_DIMM_WINDOW_STEP),\n\t\t    &pp->dimm_buf, PDC_DIMM_HEADER_SZ);\n\tmemcpy_toio(dimm_mmio + (portno * PDC_DIMM_WINDOW_STEP) +\n\t\t    PDC_DIMM_HOST_PRD,\n\t\t    &pp->dimm_buf[PDC_DIMM_HEADER_SZ], sgt_len);\n\n\t \n\twritel(0x00000001, mmio + PDC_20621_GENERAL_CTL);\n\n\treadl(dimm_mmio);\t \n\n\tata_port_dbg(ap, \"ata pkt buf ofs %u, prd size %u, mmio copied\\n\",\n\t\t     i, sgt_len);\n}\n\nstatic void pdc20621_nodata_prep(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pdc_port_priv *pp = ap->private_data;\n\tvoid __iomem *mmio = ap->host->iomap[PDC_MMIO_BAR];\n\tvoid __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];\n\tunsigned int portno = ap->port_no;\n\tunsigned int i;\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\ti = pdc20621_ata_pkt(&qc->tf, qc->dev->devno, &pp->dimm_buf[0], portno);\n\n\tif (qc->tf.flags & ATA_TFLAG_LBA48)\n\t\ti = pdc_prep_lba48(&qc->tf, &pp->dimm_buf[0], i);\n\telse\n\t\ti = pdc_prep_lba28(&qc->tf, &pp->dimm_buf[0], i);\n\n\tpdc_pkt_footer(&qc->tf, &pp->dimm_buf[0], i);\n\n\t \n\tmemcpy_toio(dimm_mmio + (portno * PDC_DIMM_WINDOW_STEP),\n\t\t    &pp->dimm_buf, PDC_DIMM_HEADER_SZ);\n\n\t \n\twritel(0x00000001, mmio + PDC_20621_GENERAL_CTL);\n\n\treadl(dimm_mmio);\t \n\n\tata_port_dbg(ap, \"ata pkt buf ofs %u, mmio copied\\n\", i);\n}\n\nstatic enum ata_completion_errors pdc20621_qc_prep(struct ata_queued_cmd *qc)\n{\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\t\tpdc20621_dma_prep(qc);\n\t\tbreak;\n\tcase ATA_PROT_NODATA:\n\t\tpdc20621_nodata_prep(qc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn AC_ERR_OK;\n}\n\nstatic void __pdc20621_push_hdma(struct ata_queued_cmd *qc,\n\t\t\t\t unsigned int seq,\n\t\t\t\t u32 pkt_ofs)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_host *host = ap->host;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\twritel(0x00000001, mmio + PDC_20621_SEQCTL + (seq * 4));\n\treadl(mmio + PDC_20621_SEQCTL + (seq * 4));\t \n\n\twritel(pkt_ofs, mmio + PDC_HDMA_PKT_SUBMIT);\n\treadl(mmio + PDC_HDMA_PKT_SUBMIT);\t \n}\n\nstatic void pdc20621_push_hdma(struct ata_queued_cmd *qc,\n\t\t\t\tunsigned int seq,\n\t\t\t\tu32 pkt_ofs)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pdc_host_priv *pp = ap->host->private_data;\n\tunsigned int idx = pp->hdma_prod & PDC_HDMA_Q_MASK;\n\n\tif (!pp->doing_hdma) {\n\t\t__pdc20621_push_hdma(qc, seq, pkt_ofs);\n\t\tpp->doing_hdma = 1;\n\t\treturn;\n\t}\n\n\tpp->hdma[idx].qc = qc;\n\tpp->hdma[idx].seq = seq;\n\tpp->hdma[idx].pkt_ofs = pkt_ofs;\n\tpp->hdma_prod++;\n}\n\nstatic void pdc20621_pop_hdma(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct pdc_host_priv *pp = ap->host->private_data;\n\tunsigned int idx = pp->hdma_cons & PDC_HDMA_Q_MASK;\n\n\t \n\tif (pp->hdma_prod == pp->hdma_cons) {\n\t\tpp->doing_hdma = 0;\n\t\treturn;\n\t}\n\n\t__pdc20621_push_hdma(pp->hdma[idx].qc, pp->hdma[idx].seq,\n\t\t\t     pp->hdma[idx].pkt_ofs);\n\tpp->hdma_cons++;\n}\n\nstatic void pdc20621_dump_hdma(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tunsigned int port_no = ap->port_no;\n\tvoid __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];\n\n\tdimm_mmio += (port_no * PDC_DIMM_WINDOW_STEP);\n\tdimm_mmio += PDC_DIMM_HOST_PKT;\n\n\tata_port_dbg(ap, \"HDMA 0x%08X 0x%08X 0x%08X 0x%08X\\n\",\n\t\t     readl(dimm_mmio), readl(dimm_mmio + 4),\n\t\t     readl(dimm_mmio + 8), readl(dimm_mmio + 12));\n}\n\nstatic void pdc20621_packet_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_host *host = ap->host;\n\tunsigned int port_no = ap->port_no;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\tunsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);\n\tu8 seq = (u8) (port_no + 1);\n\tunsigned int port_ofs;\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\twmb();\t\t\t \n\n\tport_ofs = PDC_20621_DIMM_BASE + (PDC_DIMM_WINDOW_STEP * port_no);\n\n\t \n\tif (rw && qc->tf.protocol == ATA_PROT_DMA) {\n\t\tseq += 4;\n\n\t\tpdc20621_dump_hdma(qc);\n\t\tpdc20621_push_hdma(qc, seq, port_ofs + PDC_DIMM_HOST_PKT);\n\t\tata_port_dbg(ap, \"queued ofs 0x%x (%u), seq %u\\n\",\n\t\t\tport_ofs + PDC_DIMM_HOST_PKT,\n\t\t\tport_ofs + PDC_DIMM_HOST_PKT,\n\t\t\tseq);\n\t} else {\n\t\twritel(0x00000001, mmio + PDC_20621_SEQCTL + (seq * 4));\n\t\treadl(mmio + PDC_20621_SEQCTL + (seq * 4));\t \n\n\t\twritel(port_ofs + PDC_DIMM_ATA_PKT,\n\t\t       ap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\n\t\treadl(ap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\n\t\tata_port_dbg(ap, \"submitted ofs 0x%x (%u), seq %u\\n\",\n\t\t\tport_ofs + PDC_DIMM_ATA_PKT,\n\t\t\tport_ofs + PDC_DIMM_ATA_PKT,\n\t\t\tseq);\n\t}\n}\n\nstatic unsigned int pdc20621_qc_issue(struct ata_queued_cmd *qc)\n{\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_NODATA:\n\t\tif (qc->tf.flags & ATA_TFLAG_POLLING)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase ATA_PROT_DMA:\n\t\tpdc20621_packet_start(qc);\n\t\treturn 0;\n\n\tcase ATAPI_PROT_DMA:\n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic inline unsigned int pdc20621_host_intr(struct ata_port *ap,\n\t\t\t\t\t  struct ata_queued_cmd *qc,\n\t\t\t\t\t  unsigned int doing_hdma,\n\t\t\t\t\t  void __iomem *mmio)\n{\n\tunsigned int port_no = ap->port_no;\n\tunsigned int port_ofs =\n\t\tPDC_20621_DIMM_BASE + (PDC_DIMM_WINDOW_STEP * port_no);\n\tu8 status;\n\tunsigned int handled = 0;\n\n\tif ((qc->tf.protocol == ATA_PROT_DMA) &&\t \n\t    (!(qc->tf.flags & ATA_TFLAG_WRITE))) {\n\n\t\t \n\t\tif (doing_hdma) {\n\t\t\tata_port_dbg(ap, \"read hdma, 0x%x 0x%x\\n\",\n\t\t\t\treadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\n\t\t\t \n\t\t\tqc->err_mask |= ac_err_mask(ata_wait_idle(ap));\n\t\t\tata_qc_complete(qc);\n\t\t\tpdc20621_pop_hdma(qc);\n\t\t}\n\n\t\t \n\t\telse {\n\t\t\tu8 seq = (u8) (port_no + 1 + 4);\n\t\t\tata_port_dbg(ap, \"read ata, 0x%x 0x%x\\n\",\n\t\t\t\treadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\n\n\t\t\t \n\t\t\tpdc20621_dump_hdma(qc);\n\t\t\tpdc20621_push_hdma(qc, seq,\n\t\t\t\t\t   port_ofs + PDC_DIMM_HOST_PKT);\n\t\t}\n\t\thandled = 1;\n\n\t} else if (qc->tf.protocol == ATA_PROT_DMA) {\t \n\n\t\t \n\t\tif (doing_hdma) {\n\t\t\tu8 seq = (u8) (port_no + 1);\n\t\t\tata_port_dbg(ap, \"write hdma, 0x%x 0x%x\\n\",\n\t\t\t\treadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\n\n\t\t\t \n\t\t\twritel(0x00000001, mmio + PDC_20621_SEQCTL + (seq * 4));\n\t\t\treadl(mmio + PDC_20621_SEQCTL + (seq * 4));\n\t\t\twritel(port_ofs + PDC_DIMM_ATA_PKT,\n\t\t\t       ap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\n\t\t\treadl(ap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\n\t\t}\n\n\t\t \n\t\telse {\n\t\t\tata_port_dbg(ap, \"write ata, 0x%x 0x%x\\n\",\n\t\t\t\treadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\n\t\t\t \n\t\t\tqc->err_mask |= ac_err_mask(ata_wait_idle(ap));\n\t\t\tata_qc_complete(qc);\n\t\t\tpdc20621_pop_hdma(qc);\n\t\t}\n\t\thandled = 1;\n\n\t \n\t} else if (qc->tf.protocol == ATA_PROT_NODATA) {\n\n\t\tstatus = ata_sff_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);\n\t\tata_port_dbg(ap, \"BUS_NODATA (drv_stat 0x%X)\\n\", status);\n\t\tqc->err_mask |= ac_err_mask(status);\n\t\tata_qc_complete(qc);\n\t\thandled = 1;\n\n\t} else {\n\t\tap->stats.idle_irq++;\n\t}\n\n\treturn handled;\n}\n\nstatic void pdc20621_irq_clear(struct ata_port *ap)\n{\n\tioread8(ap->ioaddr.status_addr);\n}\n\nstatic irqreturn_t pdc20621_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct ata_port *ap;\n\tu32 mask = 0;\n\tunsigned int i, tmp, port_no;\n\tunsigned int handled = 0;\n\tvoid __iomem *mmio_base;\n\n\tif (!host || !host->iomap[PDC_MMIO_BAR])\n\t\treturn IRQ_NONE;\n\n\tmmio_base = host->iomap[PDC_MMIO_BAR];\n\n\t \n\tmmio_base += PDC_CHIP0_OFS;\n\tmask = readl(mmio_base + PDC_20621_SEQMASK);\n\n\tif (mask == 0xffffffff)\n\t\treturn IRQ_NONE;\n\n\tmask &= 0xffff;\t\t \n\tif (!mask)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&host->lock);\n\n\tfor (i = 1; i < 9; i++) {\n\t\tport_no = i - 1;\n\t\tif (port_no > 3)\n\t\t\tport_no -= 4;\n\t\tif (port_no >= host->n_ports)\n\t\t\tap = NULL;\n\t\telse\n\t\t\tap = host->ports[port_no];\n\t\ttmp = mask & (1 << i);\n\t\tif (ap)\n\t\t\tata_port_dbg(ap, \"seq %u, tmp %x\\n\", i, tmp);\n\t\tif (tmp && ap) {\n\t\t\tstruct ata_queued_cmd *qc;\n\n\t\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\t\t\tif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)))\n\t\t\t\thandled += pdc20621_host_intr(ap, qc, (i > 4),\n\t\t\t\t\t\t\t      mmio_base);\n\t\t}\n\t}\n\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void pdc_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *mmio = ap->ioaddr.cmd_addr;\n\tu32 tmp;\n\n\t \n\n\ttmp = readl(mmio + PDC_CTLSTAT);\n\ttmp |= PDC_MASK_INT;\n\ttmp &= ~PDC_DMA_ENABLE;\n\twritel(tmp, mmio + PDC_CTLSTAT);\n\treadl(mmio + PDC_CTLSTAT);  \n}\n\nstatic void pdc_thaw(struct ata_port *ap)\n{\n\tvoid __iomem *mmio = ap->ioaddr.cmd_addr;\n\tu32 tmp;\n\n\t \n\n\t \n\tioread8(ap->ioaddr.status_addr);\n\n\t \n\ttmp = readl(mmio + PDC_CTLSTAT);\n\ttmp &= ~PDC_MASK_INT;\n\twritel(tmp, mmio + PDC_CTLSTAT);\n\treadl(mmio + PDC_CTLSTAT);  \n}\n\nstatic void pdc_reset_port(struct ata_port *ap)\n{\n\tvoid __iomem *mmio = ap->ioaddr.cmd_addr + PDC_CTLSTAT;\n\tunsigned int i;\n\tu32 tmp;\n\n\t \n\n\tfor (i = 11; i > 0; i--) {\n\t\ttmp = readl(mmio);\n\t\tif (tmp & PDC_RESET)\n\t\t\tbreak;\n\n\t\tudelay(100);\n\n\t\ttmp |= PDC_RESET;\n\t\twritel(tmp, mmio);\n\t}\n\n\ttmp &= ~PDC_RESET;\n\twritel(tmp, mmio);\n\treadl(mmio);\t \n}\n\nstatic int pdc_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t unsigned long deadline)\n{\n\tpdc_reset_port(link->ap);\n\treturn ata_sff_softreset(link, class, deadline);\n}\n\nstatic void pdc_error_handler(struct ata_port *ap)\n{\n\tif (!ata_port_is_frozen(ap))\n\t\tpdc_reset_port(ap);\n\n\tata_sff_error_handler(ap);\n}\n\nstatic void pdc_post_internal_cmd(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\t \n\tif (qc->flags & ATA_QCFLAG_EH)\n\t\tpdc_reset_port(ap);\n}\n\nstatic int pdc_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\tu8 *scsicmd = qc->scsicmd->cmnd;\n\tint pio = 1;  \n\n\t \n\tswitch (scsicmd[0]) {\n\tcase WRITE_12:\n\tcase WRITE_10:\n\tcase WRITE_6:\n\tcase READ_12:\n\tcase READ_10:\n\tcase READ_6:\n\tcase 0xad:  \n\tcase 0xbe:  \n\t\tpio = 0;\n\t}\n\t \n\tif (scsicmd[0] == WRITE_10) {\n\t\tunsigned int lba =\n\t\t\t(scsicmd[2] << 24) |\n\t\t\t(scsicmd[3] << 16) |\n\t\t\t(scsicmd[4] << 8) |\n\t\t\tscsicmd[5];\n\t\tif (lba >= 0xFFFF4FA2)\n\t\t\tpio = 1;\n\t}\n\treturn pio;\n}\n\nstatic void pdc_tf_load_mmio(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tWARN_ON(tf->protocol == ATA_PROT_DMA ||\n\t\ttf->protocol == ATAPI_PROT_DMA);\n\tata_sff_tf_load(ap, tf);\n}\n\n\nstatic void pdc_exec_command_mmio(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tWARN_ON(tf->protocol == ATA_PROT_DMA ||\n\t\ttf->protocol == ATAPI_PROT_DMA);\n\tata_sff_exec_command(ap, tf);\n}\n\n\nstatic void pdc_sata_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t= base;\n\tport->data_addr\t\t= base;\n\tport->feature_addr\t=\n\tport->error_addr\t= base + 0x4;\n\tport->nsect_addr\t= base + 0x8;\n\tport->lbal_addr\t\t= base + 0xc;\n\tport->lbam_addr\t\t= base + 0x10;\n\tport->lbah_addr\t\t= base + 0x14;\n\tport->device_addr\t= base + 0x18;\n\tport->command_addr\t=\n\tport->status_addr\t= base + 0x1c;\n\tport->altstatus_addr\t=\n\tport->ctl_addr\t\t= base + 0x38;\n}\n\n\nstatic void pdc20621_get_from_dimm(struct ata_host *host, void *psource,\n\t\t\t\t   u32 offset, u32 size)\n{\n\tu32 window_size;\n\tu16 idx;\n\tu8 page_mask;\n\tlong dist;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\tvoid __iomem *dimm_mmio = host->iomap[PDC_DIMM_BAR];\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\tpage_mask = 0x00;\n\twindow_size = 0x2000 * 4;  \n\tidx = (u16) (offset / window_size);\n\n\twritel(0x01, mmio + PDC_GENERAL_CTLR);\n\treadl(mmio + PDC_GENERAL_CTLR);\n\twritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\n\treadl(mmio + PDC_DIMM_WINDOW_CTLR);\n\n\toffset -= (idx * window_size);\n\tidx++;\n\tdist = ((long) (window_size - (offset + size))) >= 0 ? size :\n\t\t(long) (window_size - offset);\n\tmemcpy_fromio(psource, dimm_mmio + offset / 4, dist);\n\n\tpsource += dist;\n\tsize -= dist;\n\tfor (; (long) size >= (long) window_size ;) {\n\t\twritel(0x01, mmio + PDC_GENERAL_CTLR);\n\t\treadl(mmio + PDC_GENERAL_CTLR);\n\t\twritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\n\t\treadl(mmio + PDC_DIMM_WINDOW_CTLR);\n\t\tmemcpy_fromio(psource, dimm_mmio, window_size / 4);\n\t\tpsource += window_size;\n\t\tsize -= window_size;\n\t\tidx++;\n\t}\n\n\tif (size) {\n\t\twritel(0x01, mmio + PDC_GENERAL_CTLR);\n\t\treadl(mmio + PDC_GENERAL_CTLR);\n\t\twritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\n\t\treadl(mmio + PDC_DIMM_WINDOW_CTLR);\n\t\tmemcpy_fromio(psource, dimm_mmio, size / 4);\n\t}\n}\n\n\nstatic void pdc20621_put_to_dimm(struct ata_host *host, void *psource,\n\t\t\t\t u32 offset, u32 size)\n{\n\tu32 window_size;\n\tu16 idx;\n\tu8 page_mask;\n\tlong dist;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\tvoid __iomem *dimm_mmio = host->iomap[PDC_DIMM_BAR];\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\tpage_mask = 0x00;\n\twindow_size = 0x2000 * 4;        \n\tidx = (u16) (offset / window_size);\n\n\twritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\n\treadl(mmio + PDC_DIMM_WINDOW_CTLR);\n\toffset -= (idx * window_size);\n\tidx++;\n\tdist = ((long)(s32)(window_size - (offset + size))) >= 0 ? size :\n\t\t(long) (window_size - offset);\n\tmemcpy_toio(dimm_mmio + offset / 4, psource, dist);\n\twritel(0x01, mmio + PDC_GENERAL_CTLR);\n\treadl(mmio + PDC_GENERAL_CTLR);\n\n\tpsource += dist;\n\tsize -= dist;\n\tfor (; (long) size >= (long) window_size ;) {\n\t\twritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\n\t\treadl(mmio + PDC_DIMM_WINDOW_CTLR);\n\t\tmemcpy_toio(dimm_mmio, psource, window_size / 4);\n\t\twritel(0x01, mmio + PDC_GENERAL_CTLR);\n\t\treadl(mmio + PDC_GENERAL_CTLR);\n\t\tpsource += window_size;\n\t\tsize -= window_size;\n\t\tidx++;\n\t}\n\n\tif (size) {\n\t\twritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\n\t\treadl(mmio + PDC_DIMM_WINDOW_CTLR);\n\t\tmemcpy_toio(dimm_mmio, psource, size / 4);\n\t\twritel(0x01, mmio + PDC_GENERAL_CTLR);\n\t\treadl(mmio + PDC_GENERAL_CTLR);\n\t}\n}\n\n\nstatic unsigned int pdc20621_i2c_read(struct ata_host *host, u32 device,\n\t\t\t\t      u32 subaddr, u32 *pdata)\n{\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\tu32 i2creg  = 0;\n\tu32 status;\n\tu32 count = 0;\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\ti2creg |= device << 24;\n\ti2creg |= subaddr << 16;\n\n\t \n\twritel(i2creg, mmio + PDC_I2C_ADDR_DATA);\n\treadl(mmio + PDC_I2C_ADDR_DATA);\n\n\t \n\twritel(PDC_I2C_READ | PDC_I2C_START | PDC_I2C_MASK_INT,\n\t       mmio + PDC_I2C_CONTROL);\n\n\tfor (count = 0; count <= 1000; count ++) {\n\t\tstatus = readl(mmio + PDC_I2C_CONTROL);\n\t\tif (status & PDC_I2C_COMPLETE) {\n\t\t\tstatus = readl(mmio + PDC_I2C_ADDR_DATA);\n\t\t\tbreak;\n\t\t} else if (count == 1000)\n\t\t\treturn 0;\n\t}\n\n\t*pdata = (status >> 8) & 0x000000ff;\n\treturn 1;\n}\n\n\nstatic int pdc20621_detect_dimm(struct ata_host *host)\n{\n\tu32 data = 0;\n\tif (pdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\n\t\t\t     PDC_DIMM_SPD_SYSTEM_FREQ, &data)) {\n\t\tif (data == 100)\n\t\t\treturn 100;\n\t} else\n\t\treturn 0;\n\n\tif (pdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS, 9, &data)) {\n\t\tif (data <= 0x75)\n\t\t\treturn 133;\n\t} else\n\t\treturn 0;\n\n\treturn 0;\n}\n\n\nstatic int pdc20621_prog_dimm0(struct ata_host *host)\n{\n\tu32 spd0[50];\n\tu32 data = 0;\n\tint size, i;\n\tu8 bdimmsize;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\tstatic const struct {\n\t\tunsigned int reg;\n\t\tunsigned int ofs;\n\t} pdc_i2c_read_data [] = {\n\t\t{ PDC_DIMM_SPD_TYPE, 11 },\n\t\t{ PDC_DIMM_SPD_FRESH_RATE, 12 },\n\t\t{ PDC_DIMM_SPD_COLUMN_NUM, 4 },\n\t\t{ PDC_DIMM_SPD_ATTRIBUTE, 21 },\n\t\t{ PDC_DIMM_SPD_ROW_NUM, 3 },\n\t\t{ PDC_DIMM_SPD_BANK_NUM, 17 },\n\t\t{ PDC_DIMM_SPD_MODULE_ROW, 5 },\n\t\t{ PDC_DIMM_SPD_ROW_PRE_CHARGE, 27 },\n\t\t{ PDC_DIMM_SPD_ROW_ACTIVE_DELAY, 28 },\n\t\t{ PDC_DIMM_SPD_RAS_CAS_DELAY, 29 },\n\t\t{ PDC_DIMM_SPD_ACTIVE_PRECHARGE, 30 },\n\t\t{ PDC_DIMM_SPD_CAS_LATENCY, 18 },\n\t};\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdc_i2c_read_data); i++)\n\t\tpdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\n\t\t\t\t  pdc_i2c_read_data[i].reg,\n\t\t\t\t  &spd0[pdc_i2c_read_data[i].ofs]);\n\n\tdata |= (spd0[4] - 8) | ((spd0[21] != 0) << 3) | ((spd0[3]-11) << 4);\n\tdata |= ((spd0[17] / 4) << 6) | ((spd0[5] / 2) << 7) |\n\t\t((((spd0[27] + 9) / 10) - 1) << 8) ;\n\tdata |= (((((spd0[29] > spd0[28])\n\t\t    ? spd0[29] : spd0[28]) + 9) / 10) - 1) << 10;\n\tdata |= ((spd0[30] - spd0[29] + 9) / 10 - 2) << 12;\n\n\tif (spd0[18] & 0x08)\n\t\tdata |= ((0x03) << 14);\n\telse if (spd0[18] & 0x04)\n\t\tdata |= ((0x02) << 14);\n\telse if (spd0[18] & 0x01)\n\t\tdata |= ((0x01) << 14);\n\telse\n\t\tdata |= (0 << 14);\n\n\t \n\n\tbdimmsize = spd0[4] + (spd0[5] / 2) + spd0[3] + (spd0[17] / 2) + 3;\n\tsize = (1 << bdimmsize) >> 20;\t \n\tdata |= (((size / 16) - 1) << 16);\n\tdata |= (0 << 23);\n\tdata |= 8;\n\twritel(data, mmio + PDC_DIMM0_CONTROL);\n\treadl(mmio + PDC_DIMM0_CONTROL);\n\treturn size;\n}\n\n\nstatic unsigned int pdc20621_prog_dimm_global(struct ata_host *host)\n{\n\tu32 data, spd0;\n\tint error, i;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\t \n\n\tdata = 0x022259F1;\n\twritel(data, mmio + PDC_SDRAM_CONTROL);\n\treadl(mmio + PDC_SDRAM_CONTROL);\n\n\t \n\tif (!pdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\n\t\t\t       PDC_DIMM_SPD_TYPE, &spd0)) {\n\t\tdev_err(host->dev,\n\t\t\t\"Failed in i2c read: device=%#x, subaddr=%#x\\n\",\n\t\t\tPDC_DIMM0_SPD_DEV_ADDRESS, PDC_DIMM_SPD_TYPE);\n\t\treturn 1;\n\t}\n\tif (spd0 == 0x02) {\n\t\tdata |= (0x01 << 16);\n\t\twritel(data, mmio + PDC_SDRAM_CONTROL);\n\t\treadl(mmio + PDC_SDRAM_CONTROL);\n\t\tdev_err(host->dev, \"Local DIMM ECC Enabled\\n\");\n\t}\n\n\t \n\tdata &= (~(1<<18));\n\tdata |= (1<<19);\n\twritel(data, mmio + PDC_SDRAM_CONTROL);\n\n\terror = 1;\n\tfor (i = 1; i <= 10; i++) {    \n\t\tdata = readl(mmio + PDC_SDRAM_CONTROL);\n\t\tif (!(data & (1<<19))) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(i*100);\n\t}\n\treturn error;\n}\n\n\nstatic unsigned int pdc20621_dimm_init(struct ata_host *host)\n{\n\tint speed, size, length;\n\tu32 addr, spd0, pci_status;\n\tu32 time_period = 0;\n\tu32 tcount = 0;\n\tu32 ticks = 0;\n\tu32 clock = 0;\n\tu32 fparam = 0;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\t \n\n\t \n\twritel(0xffffffff, mmio + PDC_TIME_PERIOD);\n\ttime_period = readl(mmio + PDC_TIME_PERIOD);\n\tdev_dbg(host->dev, \"Time Period Register (0x40): 0x%x\\n\", time_period);\n\n\t \n\twritel(PDC_TIMER_DEFAULT, mmio + PDC_TIME_CONTROL);\n\treadl(mmio + PDC_TIME_CONTROL);\n\n\t \n\tmsleep(3000);\n\n\t \n\n\ttcount = readl(mmio + PDC_TIME_COUNTER);\n\tdev_dbg(host->dev, \"Time Counter Register (0x44): 0x%x\\n\", tcount);\n\n\t \n\tif (tcount >= PCI_X_TCOUNT) {\n\t\tticks = (time_period - tcount);\n\t\tdev_dbg(host->dev, \"Num counters 0x%x (%d)\\n\", ticks, ticks);\n\n\t\tclock = (ticks / 300000);\n\t\tdev_dbg(host->dev, \"10 * Internal clk = 0x%x (%d)\\n\",\n\t\t\tclock, clock);\n\n\t\tclock = (clock * 33);\n\t\tdev_dbg(host->dev, \"10 * Internal clk * 33 = 0x%x (%d)\\n\",\n\t\t\tclock, clock);\n\n\t\t \n\t\tfparam = (1400000 / clock) - 2;\n\t\tdev_dbg(host->dev, \"PLL F Param: 0x%x (%d)\\n\", fparam, fparam);\n\n\t\t \n\t\tpci_status = (0x8a001824 | (fparam << 16));\n\t} else\n\t\tpci_status = PCI_PLL_INIT;\n\n\t \n\tdev_dbg(host->dev, \"pci_status: 0x%x\\n\", pci_status);\n\twritel(pci_status, mmio + PDC_CTL_STATUS);\n\treadl(mmio + PDC_CTL_STATUS);\n\n\t \n\tif (!(speed = pdc20621_detect_dimm(host))) {\n\t\tdev_err(host->dev, \"Detect Local DIMM Fail\\n\");\n\t\treturn 1;\t \n\t}\n\tdev_dbg(host->dev, \"Local DIMM Speed = %d\\n\", speed);\n\n\t \n\tsize = pdc20621_prog_dimm0(host);\n\tdev_dbg(host->dev, \"Local DIMM Size = %dMB\\n\", size);\n\n\t \n\tif (pdc20621_prog_dimm_global(host)) {\n\t\tdev_err(host->dev,\n\t\t\t\"Programming DIMM Module Global Control Register Fail\\n\");\n\t\treturn 1;\n\t}\n\n\tif (dimm_test) {\n\t\tu8 test_parttern1[40] =\n\t\t\t{0x55,0xAA,'P','r','o','m','i','s','e',' ',\n\t\t\t'N','o','t',' ','Y','e','t',' ',\n\t\t\t'D','e','f','i','n','e','d',' ',\n\t\t\t'1','.','1','0',\n\t\t\t'9','8','0','3','1','6','1','2',0,0};\n\t\tu8 test_parttern2[40] = {0};\n\n\t\tpdc20621_put_to_dimm(host, test_parttern2, 0x10040, 40);\n\t\tpdc20621_put_to_dimm(host, test_parttern2, 0x40, 40);\n\n\t\tpdc20621_put_to_dimm(host, test_parttern1, 0x10040, 40);\n\t\tpdc20621_get_from_dimm(host, test_parttern2, 0x40, 40);\n\t\tdev_info(host->dev, \"DIMM test pattern 1: %x, %x, %s\\n\", test_parttern2[0],\n\t\t       test_parttern2[1], &(test_parttern2[2]));\n\t\tpdc20621_get_from_dimm(host, test_parttern2, 0x10040,\n\t\t\t\t       40);\n\t\tdev_info(host->dev, \"DIMM test pattern 2: %x, %x, %s\\n\",\n\t\t\t test_parttern2[0],\n\t\t\t test_parttern2[1], &(test_parttern2[2]));\n\n\t\tpdc20621_put_to_dimm(host, test_parttern1, 0x40, 40);\n\t\tpdc20621_get_from_dimm(host, test_parttern2, 0x40, 40);\n\t\tdev_info(host->dev, \"DIMM test pattern 3: %x, %x, %s\\n\",\n\t\t\t test_parttern2[0],\n\t\t\t test_parttern2[1], &(test_parttern2[2]));\n\t}\n\n\t \n\n\tif (!pdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\n\t\t\t       PDC_DIMM_SPD_TYPE, &spd0)) {\n\t\tdev_err(host->dev,\n\t\t\t\"Failed in i2c read: device=%#x, subaddr=%#x\\n\",\n\t\t       PDC_DIMM0_SPD_DEV_ADDRESS, PDC_DIMM_SPD_TYPE);\n\t\treturn 1;\n\t}\n\tif (spd0 == 0x02) {\n\t\tvoid *buf;\n\t\tdev_dbg(host->dev, \"Start ECC initialization\\n\");\n\t\taddr = 0;\n\t\tlength = size * 1024 * 1024;\n\t\tbuf = kzalloc(ECC_ERASE_BUF_SZ, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn 1;\n\t\twhile (addr < length) {\n\t\t\tpdc20621_put_to_dimm(host, buf, addr,\n\t\t\t\t\t     ECC_ERASE_BUF_SZ);\n\t\t\taddr += ECC_ERASE_BUF_SZ;\n\t\t}\n\t\tkfree(buf);\n\t\tdev_dbg(host->dev, \"Finish ECC initialization\\n\");\n\t}\n\treturn 0;\n}\n\n\nstatic void pdc_20621_init(struct ata_host *host)\n{\n\tu32 tmp;\n\tvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\n\n\t \n\tmmio += PDC_CHIP0_OFS;\n\n\t \n\ttmp = readl(mmio + PDC_20621_DIMM_WINDOW) & 0xffff0000;\n\ttmp |= PDC_PAGE_WINDOW;\t \n\twritel(tmp, mmio + PDC_20621_DIMM_WINDOW);\n\n\t \n\ttmp = readl(mmio + PDC_HDMA_CTLSTAT);\n\ttmp |= PDC_RESET;\n\twritel(tmp, mmio + PDC_HDMA_CTLSTAT);\n\treadl(mmio + PDC_HDMA_CTLSTAT);\t\t \n\n\tudelay(10);\n\n\ttmp = readl(mmio + PDC_HDMA_CTLSTAT);\n\ttmp &= ~PDC_RESET;\n\twritel(tmp, mmio + PDC_HDMA_CTLSTAT);\n\treadl(mmio + PDC_HDMA_CTLSTAT);\t\t \n}\n\nstatic int pdc_sata_init_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tconst struct ata_port_info *ppi[] =\n\t\t{ &pdc_port_info[ent->driver_data], NULL };\n\tstruct ata_host *host;\n\tstruct pdc_host_priv *hpriv;\n\tint i, rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, 4);\n\thpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!host || !hpriv)\n\t\treturn -ENOMEM;\n\n\thost->private_data = hpriv;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev, (1 << PDC_MMIO_BAR) | (1 << PDC_DIMM_BAR),\n\t\t\t\tDRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tvoid __iomem *base = host->iomap[PDC_MMIO_BAR] + PDC_CHIP0_OFS;\n\t\tunsigned int offset = 0x200 + i * 0x80;\n\n\t\tpdc_sata_setup_port(&ap->ioaddr, base + offset);\n\n\t\tata_port_pbar_desc(ap, PDC_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, PDC_DIMM_BAR, -1, \"dimm\");\n\t\tata_port_pbar_desc(ap, PDC_MMIO_BAR, offset, \"port\");\n\t}\n\n\t \n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pdc20621_dimm_init(host))\n\t\treturn -ENOMEM;\n\tpdc_20621_init(host);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, pdc20621_interrupt,\n\t\t\t\t IRQF_SHARED, &pdc_sata_sht);\n}\n\nmodule_pci_driver(pdc_sata_pci_driver);\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"Promise SATA low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pdc_sata_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}