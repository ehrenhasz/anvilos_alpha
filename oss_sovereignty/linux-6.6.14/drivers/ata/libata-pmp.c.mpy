{
  "module_name": "libata-pmp.c",
  "hash_id": "a2ed0e1d4f7c0b649b526f30c91a988aba51518bc52dd3b34b5ef11e4d8c4ff2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-pmp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/libata.h>\n#include <linux/slab.h>\n#include \"libata.h\"\n#include \"libata-transport.h\"\n\nconst struct ata_port_operations sata_pmp_port_ops = {\n\t.inherits\t\t= &sata_port_ops,\n\t.pmp_prereset\t\t= ata_std_prereset,\n\t.pmp_hardreset\t\t= sata_std_hardreset,\n\t.pmp_postreset\t\t= ata_std_postreset,\n\t.error_handler\t\t= sata_pmp_error_handler,\n};\n\n \nstatic unsigned int sata_pmp_read(struct ata_link *link, int reg, u32 *r_val)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *pmp_dev = ap->link.device;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\tata_tf_init(pmp_dev, &tf);\n\ttf.command = ATA_CMD_PMP_READ;\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\n\ttf.feature = reg;\n\ttf.device = link->pmp;\n\n\terr_mask = ata_exec_internal(pmp_dev, &tf, NULL, DMA_NONE, NULL, 0,\n\t\t\t\t     SATA_PMP_RW_TIMEOUT);\n\tif (err_mask)\n\t\treturn err_mask;\n\n\t*r_val = tf.nsect | tf.lbal << 8 | tf.lbam << 16 | tf.lbah << 24;\n\treturn 0;\n}\n\n \nstatic unsigned int sata_pmp_write(struct ata_link *link, int reg, u32 val)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *pmp_dev = ap->link.device;\n\tstruct ata_taskfile tf;\n\n\tata_tf_init(pmp_dev, &tf);\n\ttf.command = ATA_CMD_PMP_WRITE;\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\n\ttf.feature = reg;\n\ttf.device = link->pmp;\n\ttf.nsect = val & 0xff;\n\ttf.lbal = (val >> 8) & 0xff;\n\ttf.lbam = (val >> 16) & 0xff;\n\ttf.lbah = (val >> 24) & 0xff;\n\n\treturn ata_exec_internal(pmp_dev, &tf, NULL, DMA_NONE, NULL, 0,\n\t\t\t\t SATA_PMP_RW_TIMEOUT);\n}\n\n \nint sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc)\n{\n\tstruct ata_link *link = qc->dev->link;\n\tstruct ata_port *ap = link->ap;\n\n\tif (ap->excl_link == NULL || ap->excl_link == link) {\n\t\tif (ap->nr_active_links == 0 || ata_link_active(link)) {\n\t\t\tqc->flags |= ATA_QCFLAG_CLEAR_EXCL;\n\t\t\treturn ata_std_qc_defer(qc);\n\t\t}\n\n\t\tap->excl_link = link;\n\t}\n\n\treturn ATA_DEFER_PORT;\n}\n\n \nint sata_pmp_scr_read(struct ata_link *link, int reg, u32 *r_val)\n{\n\tunsigned int err_mask;\n\n\tif (reg > SATA_PMP_PSCR_CONTROL)\n\t\treturn -EINVAL;\n\n\terr_mask = sata_pmp_read(link, reg, r_val);\n\tif (err_mask) {\n\t\tata_link_warn(link, \"failed to read SCR %d (Emask=0x%x)\\n\",\n\t\t\t      reg, err_mask);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nint sata_pmp_scr_write(struct ata_link *link, int reg, u32 val)\n{\n\tunsigned int err_mask;\n\n\tif (reg > SATA_PMP_PSCR_CONTROL)\n\t\treturn -EINVAL;\n\n\terr_mask = sata_pmp_write(link, reg, val);\n\tif (err_mask) {\n\t\tata_link_warn(link, \"failed to write SCR %d (Emask=0x%x)\\n\",\n\t\t\t      reg, err_mask);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nint sata_pmp_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t     unsigned hints)\n{\n\treturn sata_link_scr_lpm(link, policy, true);\n}\n\n \nstatic int sata_pmp_read_gscr(struct ata_device *dev, u32 *gscr)\n{\n\tstatic const int gscr_to_read[] = { 0, 1, 2, 32, 33, 64, 96 };\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gscr_to_read); i++) {\n\t\tint reg = gscr_to_read[i];\n\t\tunsigned int err_mask;\n\n\t\terr_mask = sata_pmp_read(dev->link, reg, &gscr[reg]);\n\t\tif (err_mask) {\n\t\t\tata_dev_err(dev, \"failed to read PMP GSCR[%d] (Emask=0x%x)\\n\",\n\t\t\t\t    reg, err_mask);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const char *sata_pmp_spec_rev_str(const u32 *gscr)\n{\n\tu32 rev = gscr[SATA_PMP_GSCR_REV];\n\n\tif (rev & (1 << 3))\n\t\treturn \"1.2\";\n\tif (rev & (1 << 2))\n\t\treturn \"1.1\";\n\tif (rev & (1 << 1))\n\t\treturn \"1.0\";\n\treturn \"<unknown>\";\n}\n\n#define PMP_GSCR_SII_POL 129\n\nstatic int sata_pmp_configure(struct ata_device *dev, int print_info)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tu32 *gscr = dev->gscr;\n\tu16 vendor = sata_pmp_gscr_vendor(gscr);\n\tu16 devid = sata_pmp_gscr_devid(gscr);\n\tunsigned int err_mask = 0;\n\tconst char *reason;\n\tint nr_ports, rc;\n\n\tnr_ports = sata_pmp_gscr_ports(gscr);\n\n\tif (nr_ports <= 0 || nr_ports > SATA_PMP_MAX_PORTS) {\n\t\trc = -EINVAL;\n\t\treason = \"invalid nr_ports\";\n\t\tgoto fail;\n\t}\n\n\tif ((ap->flags & ATA_FLAG_AN) &&\n\t    (gscr[SATA_PMP_GSCR_FEAT] & SATA_PMP_FEAT_NOTIFY))\n\t\tdev->flags |= ATA_DFLAG_AN;\n\n\t \n\terr_mask = sata_pmp_write(dev->link, SATA_PMP_GSCR_ERROR_EN,\n\t\t\t\t  SERR_PHYRDY_CHG);\n\tif (err_mask) {\n\t\trc = -EIO;\n\t\treason = \"failed to write GSCR_ERROR_EN\";\n\t\tgoto fail;\n\t}\n\n\t \n\tif (vendor == 0x1095 && (devid == 0x3726 || devid == 0x3826)) {\n\t\tu32 reg;\n\n\t\terr_mask = sata_pmp_read(&ap->link, PMP_GSCR_SII_POL, &reg);\n\t\tif (err_mask) {\n\t\t\trc = -EIO;\n\t\t\treason = \"failed to read Sil3x26 Private Register\";\n\t\t\tgoto fail;\n\t\t}\n\t\treg &= ~0x1;\n\t\terr_mask = sata_pmp_write(&ap->link, PMP_GSCR_SII_POL, reg);\n\t\tif (err_mask) {\n\t\t\trc = -EIO;\n\t\t\treason = \"failed to write Sil3x26 Private Register\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (print_info) {\n\t\tata_dev_info(dev, \"Port Multiplier %s, \"\n\t\t\t     \"0x%04x:0x%04x r%d, %d ports, feat 0x%x/0x%x\\n\",\n\t\t\t     sata_pmp_spec_rev_str(gscr), vendor, devid,\n\t\t\t     sata_pmp_gscr_rev(gscr),\n\t\t\t     nr_ports, gscr[SATA_PMP_GSCR_FEAT_EN],\n\t\t\t     gscr[SATA_PMP_GSCR_FEAT]);\n\n\t\tif (!(dev->flags & ATA_DFLAG_AN))\n\t\t\tata_dev_info(dev,\n\t\t\t\t\"Asynchronous notification not supported, \"\n\t\t\t\t\"hotplug won't work on fan-out ports. Use warm-plug instead.\\n\");\n\t}\n\n\treturn 0;\n\n fail:\n\tata_dev_err(dev,\n\t\t    \"failed to configure Port Multiplier (%s, Emask=0x%x)\\n\",\n\t\t    reason, err_mask);\n\treturn rc;\n}\n\nstatic int sata_pmp_init_links (struct ata_port *ap, int nr_ports)\n{\n\tstruct ata_link *pmp_link = ap->pmp_link;\n\tint i, err;\n\n\tif (!pmp_link) {\n\t\tpmp_link = kcalloc(SATA_PMP_MAX_PORTS, sizeof(pmp_link[0]),\n\t\t\t\t   GFP_NOIO);\n\t\tif (!pmp_link)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < SATA_PMP_MAX_PORTS; i++)\n\t\t\tata_link_init(ap, &pmp_link[i], i);\n\n\t\tap->pmp_link = pmp_link;\n\n\t\tfor (i = 0; i < SATA_PMP_MAX_PORTS; i++) {\n\t\t\terr = ata_tlink_add(&pmp_link[i]);\n\t\t\tif (err) {\n\t\t\t\tgoto err_tlink;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_ports; i++) {\n\t\tstruct ata_link *link = &pmp_link[i];\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\n\t\tlink->flags = 0;\n\t\tehc->i.probe_mask |= ATA_ALL_DEVICES;\n\t\tehc->i.action |= ATA_EH_RESET;\n\t}\n\n\treturn 0;\n  err_tlink:\n\twhile (--i >= 0)\n\t\tata_tlink_delete(&pmp_link[i]);\n\tkfree(pmp_link);\n\tap->pmp_link = NULL;\n\treturn err;\n}\n\nstatic void sata_pmp_quirks(struct ata_port *ap)\n{\n\tu32 *gscr = ap->link.device->gscr;\n\tu16 vendor = sata_pmp_gscr_vendor(gscr);\n\tu16 devid = sata_pmp_gscr_devid(gscr);\n\tstruct ata_link *link;\n\n\tif (vendor == 0x1095 && (devid == 0x3726 || devid == 0x3826)) {\n\t\t \n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\t \n\t\t\tlink->flags |= ATA_LFLAG_NO_LPM;\n\n\t\t\t \n\t\t\tif (link->pmp < 5)\n\t\t\t\tlink->flags |= ATA_LFLAG_NO_SRST |\n\t\t\t\t\t       ATA_LFLAG_ASSUME_ATA;\n\n\t\t\t \n\t\t\tif (link->pmp == 5)\n\t\t\t\tlink->flags |= ATA_LFLAG_NO_SRST |\n\t\t\t\t\t       ATA_LFLAG_ASSUME_SEMB;\n\t\t}\n\t} else if (vendor == 0x1095 && devid == 0x4723) {\n\t\t \n\t\tata_for_each_link(link, ap, EDGE)\n\t\t\tlink->flags |= ATA_LFLAG_NO_LPM |\n\t\t\t\t       ATA_LFLAG_NO_SRST |\n\t\t\t\t       ATA_LFLAG_ASSUME_ATA;\n\t} else if (vendor == 0x1095 && devid == 0x4726) {\n\t\t \n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\t \n\t\t\tlink->flags |= ATA_LFLAG_NO_LPM;\n\n\t\t\t \n\t\t\tif (link->pmp <= 5)\n\t\t\t\tlink->flags |= ATA_LFLAG_NO_SRST |\n\t\t\t\t\t       ATA_LFLAG_ASSUME_ATA;\n\n\t\t\t \n\t\t\tif (link->pmp == 6)\n\t\t\t\tlink->flags |= ATA_LFLAG_NO_SRST |\n\t\t\t\t\t       ATA_LFLAG_ASSUME_SEMB;\n\t\t}\n\t} else if (vendor == 0x1095 && (devid == 0x5723 || devid == 0x5733 ||\n\t\t\t\t\tdevid == 0x5734 || devid == 0x5744)) {\n\t\t \n\n\t\t \n\t\tap->pmp_link[ap->nr_pmp_links - 1].flags |= ATA_LFLAG_NO_RETRY;\n\t} else if (vendor == 0x197b && (devid == 0x2352 || devid == 0x0325)) {\n\t\t \n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\t \n\t\t\tlink->flags |= ATA_LFLAG_NO_LPM |\n\t\t\t\t       ATA_LFLAG_NO_SRST |\n\t\t\t\t       ATA_LFLAG_ASSUME_ATA;\n\t\t}\n\t} else if (vendor == 0x11ab && devid == 0x4140) {\n\t\t \n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\t \n\t\t\tif (link->pmp == 4)\n\t\t\t\tlink->flags |= ATA_LFLAG_DISABLED;\n\t\t}\n\t}\n}\n\n \nint sata_pmp_attach(struct ata_device *dev)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tunsigned long flags;\n\tstruct ata_link *tlink;\n\tint rc;\n\n\t \n\tif (!sata_pmp_supported(ap)) {\n\t\tata_dev_err(dev, \"host does not support Port Multiplier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ata_is_host_link(link)) {\n\t\tata_dev_err(dev, \"Port Multipliers cannot be nested\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->devno) {\n\t\tata_dev_err(dev, \"Port Multiplier must be the first device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(link->pmp != 0);\n\tlink->pmp = SATA_PMP_CTRL_PORT;\n\n\t \n\trc = sata_pmp_read_gscr(dev, dev->gscr);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\trc = sata_pmp_configure(dev, 1);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = sata_pmp_init_links(ap, sata_pmp_gscr_ports(dev->gscr));\n\tif (rc) {\n\t\tata_dev_info(dev, \"failed to initialize PMP links\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\tWARN_ON(ap->nr_pmp_links);\n\tap->nr_pmp_links = sata_pmp_gscr_ports(dev->gscr);\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tsata_pmp_quirks(ap);\n\n\tif (ap->ops->pmp_attach)\n\t\tap->ops->pmp_attach(ap);\n\n\tata_for_each_link(tlink, ap, EDGE)\n\t\tsata_link_init_spd(tlink);\n\n\treturn 0;\n\n fail:\n\tlink->pmp = 0;\n\treturn rc;\n}\n\n \nstatic void sata_pmp_detach(struct ata_device *dev)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_link *tlink;\n\tunsigned long flags;\n\n\tata_dev_info(dev, \"Port Multiplier detaching\\n\");\n\n\tWARN_ON(!ata_is_host_link(link) || dev->devno ||\n\t\tlink->pmp != SATA_PMP_CTRL_PORT);\n\n\tif (ap->ops->pmp_detach)\n\t\tap->ops->pmp_detach(ap);\n\n\tata_for_each_link(tlink, ap, EDGE)\n\t\tata_eh_detach_dev(tlink->device);\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tap->nr_pmp_links = 0;\n\tlink->pmp = 0;\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n\n \nstatic int sata_pmp_same_pmp(struct ata_device *dev, const u32 *new_gscr)\n{\n\tconst u32 *old_gscr = dev->gscr;\n\tu16 old_vendor, new_vendor, old_devid, new_devid;\n\tint old_nr_ports, new_nr_ports;\n\n\told_vendor = sata_pmp_gscr_vendor(old_gscr);\n\tnew_vendor = sata_pmp_gscr_vendor(new_gscr);\n\told_devid = sata_pmp_gscr_devid(old_gscr);\n\tnew_devid = sata_pmp_gscr_devid(new_gscr);\n\told_nr_ports = sata_pmp_gscr_ports(old_gscr);\n\tnew_nr_ports = sata_pmp_gscr_ports(new_gscr);\n\n\tif (old_vendor != new_vendor) {\n\t\tata_dev_info(dev,\n\t\t\t     \"Port Multiplier vendor mismatch '0x%x' != '0x%x'\\n\",\n\t\t\t     old_vendor, new_vendor);\n\t\treturn 0;\n\t}\n\n\tif (old_devid != new_devid) {\n\t\tata_dev_info(dev,\n\t\t\t     \"Port Multiplier device ID mismatch '0x%x' != '0x%x'\\n\",\n\t\t\t     old_devid, new_devid);\n\t\treturn 0;\n\t}\n\n\tif (old_nr_ports != new_nr_ports) {\n\t\tata_dev_info(dev,\n\t\t\t     \"Port Multiplier nr_ports mismatch '0x%x' != '0x%x'\\n\",\n\t\t\t     old_nr_ports, new_nr_ports);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int sata_pmp_revalidate(struct ata_device *dev, unsigned int new_class)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tu32 *gscr = (void *)ap->sector_buf;\n\tint rc;\n\n\tata_eh_about_to_do(link, NULL, ATA_EH_REVALIDATE);\n\n\tif (!ata_dev_enabled(dev)) {\n\t\trc = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (ata_class_enabled(new_class) && new_class != ATA_DEV_PMP) {\n\t\trc = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\t \n\trc = sata_pmp_read_gscr(dev, gscr);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\tif (!sata_pmp_same_pmp(dev, gscr)) {\n\t\trc = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tmemcpy(dev->gscr, gscr, sizeof(gscr[0]) * SATA_PMP_GSCR_DWORDS);\n\n\trc = sata_pmp_configure(dev, 0);\n\tif (rc)\n\t\tgoto fail;\n\n\tata_eh_done(link, NULL, ATA_EH_REVALIDATE);\n\n\treturn 0;\n\n fail:\n\tata_dev_err(dev, \"PMP revalidation failed (errno=%d)\\n\", rc);\n\treturn rc;\n}\n\n \nstatic int sata_pmp_revalidate_quick(struct ata_device *dev)\n{\n\tunsigned int err_mask;\n\tu32 prod_id;\n\n\terr_mask = sata_pmp_read(dev->link, SATA_PMP_GSCR_PROD_ID, &prod_id);\n\tif (err_mask) {\n\t\tata_dev_err(dev,\n\t\t\t    \"failed to read PMP product ID (Emask=0x%x)\\n\",\n\t\t\t    err_mask);\n\t\treturn -EIO;\n\t}\n\n\tif (prod_id != dev->gscr[SATA_PMP_GSCR_PROD_ID]) {\n\t\tata_dev_err(dev, \"PMP product ID mismatch\\n\");\n\t\t \n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sata_pmp_eh_recover_pmp(struct ata_port *ap,\n\t\tata_prereset_fn_t prereset, ata_reset_fn_t softreset,\n\t\tata_reset_fn_t hardreset, ata_postreset_fn_t postreset)\n{\n\tstruct ata_link *link = &ap->link;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_device *dev = link->device;\n\tint tries = ATA_EH_PMP_TRIES;\n\tint detach = 0, rc = 0;\n\tint reval_failed = 0;\n\n\tif (dev->flags & ATA_DFLAG_DETACH) {\n\t\tdetach = 1;\n\t\trc = -ENODEV;\n\t\tgoto fail;\n\t}\n\n retry:\n\tehc->classes[0] = ATA_DEV_UNKNOWN;\n\n\tif (ehc->i.action & ATA_EH_RESET) {\n\t\tstruct ata_link *tlink;\n\n\t\t \n\t\trc = ata_eh_reset(link, 0, prereset, softreset, hardreset,\n\t\t\t\t  postreset);\n\t\tif (rc) {\n\t\t\tata_link_err(link, \"failed to reset PMP, giving up\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tata_for_each_link(tlink, ap, EDGE) {\n\t\t\tstruct ata_eh_context *ehc = &tlink->eh_context;\n\n\t\t\tehc->i.probe_mask |= ATA_ALL_DEVICES;\n\t\t\tehc->i.action |= ATA_EH_RESET;\n\t\t}\n\t}\n\n\t \n\tif (ehc->i.action & ATA_EH_REVALIDATE)\n\t\trc = sata_pmp_revalidate(dev, ehc->classes[0]);\n\telse\n\t\trc = sata_pmp_revalidate_quick(dev);\n\n\tif (rc) {\n\t\ttries--;\n\n\t\tif (rc == -ENODEV) {\n\t\t\tehc->i.probe_mask |= ATA_ALL_DEVICES;\n\t\t\tdetach = 1;\n\t\t\t \n\t\t\ttries = min(tries, 2);\n\t\t}\n\n\t\tif (tries) {\n\t\t\t \n\t\t\tif (reval_failed)\n\t\t\t\tsata_down_spd_limit(link, 0);\n\t\t\telse\n\t\t\t\treval_failed = 1;\n\n\t\t\tehc->i.action |= ATA_EH_RESET;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tata_dev_err(dev,\n\t\t\t\t    \"failed to recover PMP after %d tries, giving up\\n\",\n\t\t\t\t    ATA_EH_PMP_TRIES);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tehc->i.flags = 0;\n\n\treturn 0;\n\n fail:\n\tsata_pmp_detach(dev);\n\tif (detach)\n\t\tata_eh_detach_dev(dev);\n\telse\n\t\tata_dev_disable(dev);\n\n\treturn rc;\n}\n\nstatic int sata_pmp_eh_handle_disabled_links(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tata_for_each_link(link, ap, EDGE) {\n\t\tif (!(link->flags & ATA_LFLAG_DISABLED))\n\t\t\tcontinue;\n\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t\t \n\t\tsata_link_hardreset(link, sata_deb_timing_normal,\n\t\t\t\tata_deadline(jiffies, ATA_TMOUT_INTERNAL_QUICK),\n\t\t\t\tNULL, NULL);\n\n\t\t \n\t\trc = sata_scr_write(link, SCR_ERROR, SERR_PHYRDY_CHG);\n\t\tif (rc) {\n\t\t\tata_link_err(link,\n\t\t\t\t     \"failed to clear SError.N (errno=%d)\\n\",\n\t\t\t\t     rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sata_pmp_handle_link_fail(struct ata_link *link, int *link_tries)\n{\n\tstruct ata_port *ap = link->ap;\n\tunsigned long flags;\n\n\tif (link_tries[link->pmp] && --link_tries[link->pmp])\n\t\treturn 1;\n\n\t \n\tif (!(link->flags & ATA_LFLAG_DISABLED)) {\n\t\tata_link_warn(link,\n\t\t\t\"failed to recover link after %d tries, disabling\\n\",\n\t\t\tATA_EH_PMP_LINK_TRIES);\n\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t\tlink->flags |= ATA_LFLAG_DISABLED;\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t}\n\n\tata_dev_disable(link->device);\n\tlink->eh_context.i.action = 0;\n\n\treturn 0;\n}\n\n \nstatic int sata_pmp_eh_recover(struct ata_port *ap)\n{\n\tstruct ata_port_operations *ops = ap->ops;\n\tint pmp_tries, link_tries[SATA_PMP_MAX_PORTS];\n\tstruct ata_link *pmp_link = &ap->link;\n\tstruct ata_device *pmp_dev = pmp_link->device;\n\tstruct ata_eh_context *pmp_ehc = &pmp_link->eh_context;\n\tu32 *gscr = pmp_dev->gscr;\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tunsigned int err_mask;\n\tu32 gscr_error, sntf;\n\tint cnt, rc;\n\n\tpmp_tries = ATA_EH_PMP_TRIES;\n\tata_for_each_link(link, ap, EDGE)\n\t\tlink_tries[link->pmp] = ATA_EH_PMP_LINK_TRIES;\n\n retry:\n\t \n\tif (!sata_pmp_attached(ap)) {\n\t\trc = ata_eh_recover(ap, ops->prereset, ops->softreset,\n\t\t\t\t    ops->hardreset, ops->postreset, NULL);\n\t\tif (rc) {\n\t\t\tata_for_each_dev(dev, &ap->link, ALL)\n\t\t\t\tata_dev_disable(dev);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (pmp_dev->class != ATA_DEV_PMP)\n\t\t\treturn 0;\n\n\t\t \n\t\tata_for_each_link(link, ap, EDGE)\n\t\t\tlink_tries[link->pmp] = ATA_EH_PMP_LINK_TRIES;\n\n\t\t \n\t}\n\n\t \n\trc = sata_pmp_eh_recover_pmp(ap, ops->prereset, ops->softreset,\n\t\t\t\t     ops->hardreset, ops->postreset);\n\tif (rc)\n\t\tgoto pmp_fail;\n\n\t \n\tif (gscr[SATA_PMP_GSCR_FEAT_EN] & SATA_PMP_FEAT_NOTIFY) {\n\t\tgscr[SATA_PMP_GSCR_FEAT_EN] &= ~SATA_PMP_FEAT_NOTIFY;\n\n\t\terr_mask = sata_pmp_write(pmp_link, SATA_PMP_GSCR_FEAT_EN,\n\t\t\t\t\t  gscr[SATA_PMP_GSCR_FEAT_EN]);\n\t\tif (err_mask) {\n\t\t\tata_link_warn(pmp_link,\n\t\t\t\t\"failed to disable NOTIFY (err_mask=0x%x)\\n\",\n\t\t\t\terr_mask);\n\t\t\tgoto pmp_fail;\n\t\t}\n\t}\n\n\t \n\trc = sata_pmp_eh_handle_disabled_links(ap);\n\tif (rc)\n\t\tgoto pmp_fail;\n\n\t \n\trc = ata_eh_recover(ap, ops->pmp_prereset, ops->pmp_softreset,\n\t\t\t    ops->pmp_hardreset, ops->pmp_postreset, &link);\n\tif (rc)\n\t\tgoto link_fail;\n\n\t \n\trc = sata_scr_read(&ap->link, SCR_NOTIFICATION, &sntf);\n\tif (rc == 0)\n\t\tsata_scr_write(&ap->link, SCR_NOTIFICATION, sntf);\n\n\t \n\tata_for_each_link(link, ap, EDGE)\n\t\tif (link->lpm_policy > ATA_LPM_MAX_POWER)\n\t\t\treturn 0;\n\n\t \n\n\t \n\tif (pmp_dev->flags & ATA_DFLAG_AN) {\n\t\tgscr[SATA_PMP_GSCR_FEAT_EN] |= SATA_PMP_FEAT_NOTIFY;\n\n\t\terr_mask = sata_pmp_write(pmp_link, SATA_PMP_GSCR_FEAT_EN,\n\t\t\t\t\t  gscr[SATA_PMP_GSCR_FEAT_EN]);\n\t\tif (err_mask) {\n\t\t\tata_dev_err(pmp_dev,\n\t\t\t\t    \"failed to write PMP_FEAT_EN (Emask=0x%x)\\n\",\n\t\t\t\t    err_mask);\n\t\t\trc = -EIO;\n\t\t\tgoto pmp_fail;\n\t\t}\n\t}\n\n\t \n\terr_mask = sata_pmp_read(pmp_link, SATA_PMP_GSCR_ERROR, &gscr_error);\n\tif (err_mask) {\n\t\tata_dev_err(pmp_dev,\n\t\t\t    \"failed to read PMP_GSCR_ERROR (Emask=0x%x)\\n\",\n\t\t\t    err_mask);\n\t\trc = -EIO;\n\t\tgoto pmp_fail;\n\t}\n\n\tcnt = 0;\n\tata_for_each_link(link, ap, EDGE) {\n\t\tif (!(gscr_error & (1 << link->pmp)))\n\t\t\tcontinue;\n\n\t\tif (sata_pmp_handle_link_fail(link, link_tries)) {\n\t\t\tata_ehi_hotplugged(&link->eh_context.i);\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tata_link_warn(link,\n\t\t\t\t\"PHY status changed but maxed out on retries, giving up\\n\");\n\t\t\tata_link_warn(link,\n\t\t\t\t\"Manually issue scan to resume this link\\n\");\n\t\t}\n\t}\n\n\tif (cnt) {\n\t\tata_port_info(ap,\n\t\t\t\"PMP SError.N set for some ports, repeating recovery\\n\");\n\t\tgoto retry;\n\t}\n\n\treturn 0;\n\n link_fail:\n\tif (sata_pmp_handle_link_fail(link, link_tries)) {\n\t\tpmp_ehc->i.action |= ATA_EH_RESET;\n\t\tgoto retry;\n\t}\n\n\t \n pmp_fail:\n\t \n\tif (ap->pflags & ATA_PFLAG_UNLOADING)\n\t\treturn rc;\n\n\tif (!sata_pmp_attached(ap))\n\t\tgoto retry;\n\n\tif (--pmp_tries) {\n\t\tpmp_ehc->i.action |= ATA_EH_RESET;\n\t\tgoto retry;\n\t}\n\n\tata_port_err(ap, \"failed to recover PMP after %d tries, giving up\\n\",\n\t\t     ATA_EH_PMP_TRIES);\n\tsata_pmp_detach(pmp_dev);\n\tata_dev_disable(pmp_dev);\n\n\treturn rc;\n}\n\n \nvoid sata_pmp_error_handler(struct ata_port *ap)\n{\n\tata_eh_autopsy(ap);\n\tata_eh_report(ap);\n\tsata_pmp_eh_recover(ap);\n\tata_eh_finish(ap);\n}\n\nEXPORT_SYMBOL_GPL(sata_pmp_port_ops);\nEXPORT_SYMBOL_GPL(sata_pmp_qc_defer_cmd_switch);\nEXPORT_SYMBOL_GPL(sata_pmp_error_handler);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}