{
  "module_name": "pata_artop.c",
  "hash_id": "91400160b1be30148944b424c594132fac355501db28c43542bad0457d7655a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_artop.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/ata.h>\n\n#define DRV_NAME\t\"pata_artop\"\n#define DRV_VERSION\t\"0.4.8\"\n\n \n\nstatic int clock = 0;\n\n \n\nstatic int artop62x0_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstatic const struct pci_bits artop_enable_bits[] = {\n\t\t{ 0x4AU, 1U, 0x02UL, 0x02UL },\t \n\t\t{ 0x4AU, 1U, 0x04UL, 0x04UL },\t \n\t};\n\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\t \n\tif ((pdev->device & 1) &&\n\t    !pci_test_config_bits(pdev, &artop_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic int artop6260_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 tmp;\n\tpci_read_config_byte(pdev, 0x49, &tmp);\n\tif (tmp & (1 << ap->port_no))\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\n \n\nstatic void artop6210_load_piomode(struct ata_port *ap, struct ata_device *adev, unsigned int pio)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tint dn = adev->devno + 2 * ap->port_no;\n\tstatic const u16 timing[2][5] = {\n\t\t{ 0x0000, 0x000A, 0x0008, 0x0303, 0x0301 },\n\t\t{ 0x0700, 0x070A, 0x0708, 0x0403, 0x0401 }\n\n\t};\n\t \n\tpci_write_config_word(pdev, 0x40 + 2 * dn, timing[clock][pio]);\n}\n\n \n\nstatic void artop6210_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tint dn = adev->devno + 2 * ap->port_no;\n\tu8 ultra;\n\n\tartop6210_load_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);\n\n\t \n\tpci_read_config_byte(pdev, 0x54, &ultra);\n\tultra &= ~(3 << (2 * dn));\n\tpci_write_config_byte(pdev, 0x54, ultra);\n}\n\n \n\nstatic void artop6260_load_piomode (struct ata_port *ap, struct ata_device *adev, unsigned int pio)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tint dn = adev->devno + 2 * ap->port_no;\n\tstatic const u8 timing[2][5] = {\n\t\t{ 0x00, 0x0A, 0x08, 0x33, 0x31 },\n\t\t{ 0x70, 0x7A, 0x78, 0x43, 0x41 }\n\n\t};\n\t \n\tpci_write_config_byte(pdev, 0x40 + dn, timing[clock][pio]);\n}\n\n \n\nstatic void artop6260_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tu8 ultra;\n\n\tartop6260_load_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);\n\n\t \n\tpci_read_config_byte(pdev, 0x44 + ap->port_no, &ultra);\n\tultra &= ~(7 << (4  * adev->devno));\t \n\tpci_write_config_byte(pdev, 0x44 + ap->port_no, ultra);\n}\n\n \n\nstatic void artop6210_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tunsigned int pio;\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tint dn = adev->devno + 2 * ap->port_no;\n\tu8 ultra;\n\n\tif (adev->dma_mode == XFER_MW_DMA_0)\n\t\tpio = 1;\n\telse\n\t\tpio = 4;\n\n\t \n\tartop6210_load_piomode(ap, adev, pio);\n\n\tpci_read_config_byte(pdev, 0x54, &ultra);\n\tultra &= ~(3 << (2 * dn));\n\n\t \n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tu8 mode = (adev->dma_mode - XFER_UDMA_0) + 1 - clock;\n\t\tif (mode == 0)\n\t\t\tmode = 1;\n\t\tultra |= (mode << (2 * dn));\n\t}\n\tpci_write_config_byte(pdev, 0x54, ultra);\n}\n\n \n\nstatic void artop6260_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tunsigned int pio;\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tu8 ultra;\n\n\tif (adev->dma_mode == XFER_MW_DMA_0)\n\t\tpio = 1;\n\telse\n\t\tpio = 4;\n\n\t \n\tartop6260_load_piomode(ap, adev, pio);\n\n\t \n\tpci_read_config_byte(pdev, 0x44 + ap->port_no, &ultra);\n\tultra &= ~(7 << (4  * adev->devno));\t \n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tu8 mode = adev->dma_mode - XFER_UDMA_0 + 1 - clock;\n\t\tif (mode == 0)\n\t\t\tmode = 1;\n\t\tultra |= (mode << (4 * adev->devno));\n\t}\n\tpci_write_config_byte(pdev, 0x44 + ap->port_no, ultra);\n}\n\n \n\nstatic int artop6210_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_host *host = qc->ap->host;\n\tstruct ata_port *alt = host->ports[1 ^ qc->ap->port_no];\n\tint rc;\n\n\t \n\trc = ata_std_qc_defer(qc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t \n\tif (alt && alt->qc_active)\n\t\treturn\tATA_DEFER_PORT;\n\treturn 0;\n}\n\nstatic const struct scsi_host_template artop_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations artop6210_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= artop6210_set_piomode,\n\t.set_dmamode\t\t= artop6210_set_dmamode,\n\t.prereset\t\t= artop62x0_pre_reset,\n\t.qc_defer\t\t= artop6210_qc_defer,\n};\n\nstatic struct ata_port_operations artop6260_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.cable_detect\t\t= artop6260_cable_detect,\n\t.set_piomode\t\t= artop6260_set_piomode,\n\t.set_dmamode\t\t= artop6260_set_dmamode,\n\t.prereset\t\t= artop62x0_pre_reset,\n};\n\nstatic void atp8xx_fixup(struct pci_dev *pdev)\n{\n\tu8 reg;\n\n\tswitch (pdev->device) {\n\tcase 0x0005:\n\t\t \n\t\tpci_write_config_byte(pdev, 0x54, 0);\n\t\tbreak;\n\tcase 0x0008:\n\tcase 0x0009:\n\t\t \n\n\t\t \n\t\tpci_read_config_byte(pdev, 0x49, &reg);\n\t\tpci_write_config_byte(pdev, 0x49, reg & ~0x30);\n\n\t\t \n\t\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &reg);\n\t\tif (reg <= 0x80)\n\t\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x90);\n\n\t\t \n\t\tpci_read_config_byte(pdev, 0x4a, &reg);\n\t\tpci_write_config_byte(pdev, 0x4a, (reg & ~0x01) | 0x80);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic int artop_init_one (struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info_6210 = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask \t= ATA_UDMA2,\n\t\t.port_ops\t= &artop6210_ops,\n\t};\n\tstatic const struct ata_port_info info_626x = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask \t= ATA_UDMA4,\n\t\t.port_ops\t= &artop6260_ops,\n\t};\n\tstatic const struct ata_port_info info_628x = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask \t= ATA_UDMA5,\n\t\t.port_ops\t= &artop6260_ops,\n\t};\n\tstatic const struct ata_port_info info_628x_fast = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask \t= ATA_UDMA6,\n\t\t.port_ops\t= &artop6260_ops,\n\t};\n\tconst struct ata_port_info *ppi[] = { NULL, NULL };\n\tint rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (id->driver_data) {\n\tcase 0:\t\t \n\t\tppi[0] = &info_6210;\n\t\tbreak;\n\tcase 1:\t\t \n\t\tppi[0] = &info_626x;\n\t\tbreak;\n\tcase 2:\t\t \n\t\tif (inb(pci_resource_start(pdev, 4)) & 0x10)\n\t\t\tppi[0] = &info_628x_fast;\n\t\telse\n\t\t\tppi[0] = &info_628x;\n\t\tbreak;\n\t}\n\n\tBUG_ON(ppi[0] == NULL);\n\n\tatp8xx_fixup(pdev);\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &artop_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id artop_pci_tbl[] = {\n\t{ PCI_VDEVICE(ARTOP, 0x0005), 0 },\n\t{ PCI_VDEVICE(ARTOP, 0x0006), 1 },\n\t{ PCI_VDEVICE(ARTOP, 0x0007), 1 },\n\t{ PCI_VDEVICE(ARTOP, 0x0008), 2 },\n\t{ PCI_VDEVICE(ARTOP, 0x0009), 2 },\n\n\t{ }\t \n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atp8xx_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tatp8xx_fixup(pdev);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic struct pci_driver artop_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= artop_pci_tbl,\n\t.probe\t\t\t= artop_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= atp8xx_reinit_one,\n#endif\n};\n\nmodule_pci_driver(artop_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox, Bartlomiej Zolnierkiewicz\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for ARTOP PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, artop_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}