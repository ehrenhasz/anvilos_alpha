{
  "module_name": "sata_rcar.c",
  "hash_id": "4bcf2b8f9abed8624b1d850da7729636ed4e14bf7db44879213a55b656b2a1dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_rcar.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/err.h>\n\n#define DRV_NAME \"sata_rcar\"\n\n \n#define ATAPI_CONTROL1_REG\t\t0x180\n#define ATAPI_STATUS_REG\t\t0x184\n#define ATAPI_INT_ENABLE_REG\t\t0x188\n#define ATAPI_DTB_ADR_REG\t\t0x198\n#define ATAPI_DMA_START_ADR_REG\t\t0x19C\n#define ATAPI_DMA_TRANS_CNT_REG\t\t0x1A0\n#define ATAPI_CONTROL2_REG\t\t0x1A4\n#define ATAPI_SIG_ST_REG\t\t0x1B0\n#define ATAPI_BYTE_SWAP_REG\t\t0x1BC\n\n \n#define ATAPI_CONTROL1_ISM\t\tBIT(16)\n#define ATAPI_CONTROL1_DTA32M\t\tBIT(11)\n#define ATAPI_CONTROL1_RESET\t\tBIT(7)\n#define ATAPI_CONTROL1_DESE\t\tBIT(3)\n#define ATAPI_CONTROL1_RW\t\tBIT(2)\n#define ATAPI_CONTROL1_STOP\t\tBIT(1)\n#define ATAPI_CONTROL1_START\t\tBIT(0)\n\n \n#define ATAPI_STATUS_SATAINT\t\tBIT(11)\n#define ATAPI_STATUS_DNEND\t\tBIT(6)\n#define ATAPI_STATUS_DEVTRM\t\tBIT(5)\n#define ATAPI_STATUS_DEVINT\t\tBIT(4)\n#define ATAPI_STATUS_ERR\t\tBIT(2)\n#define ATAPI_STATUS_NEND\t\tBIT(1)\n#define ATAPI_STATUS_ACT\t\tBIT(0)\n\n \n#define ATAPI_INT_ENABLE_SATAINT\tBIT(11)\n#define ATAPI_INT_ENABLE_DNEND\t\tBIT(6)\n#define ATAPI_INT_ENABLE_DEVTRM\t\tBIT(5)\n#define ATAPI_INT_ENABLE_DEVINT\t\tBIT(4)\n#define ATAPI_INT_ENABLE_ERR\t\tBIT(2)\n#define ATAPI_INT_ENABLE_NEND\t\tBIT(1)\n#define ATAPI_INT_ENABLE_ACT\t\tBIT(0)\n\n \n#define SATAPHYADDR_REG\t\t\t0x200\n#define SATAPHYWDATA_REG\t\t0x204\n#define SATAPHYACCEN_REG\t\t0x208\n#define SATAPHYRESET_REG\t\t0x20C\n#define SATAPHYRDATA_REG\t\t0x210\n#define SATAPHYACK_REG\t\t\t0x214\n\n \n#define SATAPHYADDR_PHYRATEMODE\t\tBIT(10)\n#define SATAPHYADDR_PHYCMD_READ\t\tBIT(9)\n#define SATAPHYADDR_PHYCMD_WRITE\tBIT(8)\n\n \n#define SATAPHYACCEN_PHYLANE\t\tBIT(0)\n\n \n#define SATAPHYRESET_PHYRST\t\tBIT(1)\n#define SATAPHYRESET_PHYSRES\t\tBIT(0)\n\n \n#define SATAPHYACK_PHYACK\t\tBIT(0)\n\n \n#define BISTCONF_REG\t\t\t0x102C\n#define SDATA_REG\t\t\t0x1100\n#define SSDEVCON_REG\t\t\t0x1204\n\n#define SCRSSTS_REG\t\t\t0x1400\n#define SCRSERR_REG\t\t\t0x1404\n#define SCRSCON_REG\t\t\t0x1408\n#define SCRSACT_REG\t\t\t0x140C\n\n#define SATAINTSTAT_REG\t\t\t0x1508\n#define SATAINTMASK_REG\t\t\t0x150C\n\n \n#define SATAINTSTAT_SERR\t\tBIT(3)\n#define SATAINTSTAT_ATA\t\t\tBIT(0)\n\n \n#define SATAINTMASK_SERRMSK\t\tBIT(3)\n#define SATAINTMASK_ERRMSK\t\tBIT(2)\n#define SATAINTMASK_ERRCRTMSK\t\tBIT(1)\n#define SATAINTMASK_ATAMSK\t\tBIT(0)\n#define SATAINTMASK_ALL_GEN1\t\t0x7ff\n#define SATAINTMASK_ALL_GEN2\t\t0xfff\n\n#define SATA_RCAR_INT_MASK\t\t(SATAINTMASK_SERRMSK | \\\n\t\t\t\t\t SATAINTMASK_ATAMSK)\n\n \n#define SATAPCTLR1_REG\t\t\t0x43\n#define SATAPCTLR2_REG\t\t\t0x52\n#define SATAPCTLR3_REG\t\t\t0x5A\n#define SATAPCTLR4_REG\t\t\t0x60\n\n \n#define SATA_RCAR_DTEND\t\t\tBIT(0)\n\n#define SATA_RCAR_DMA_BOUNDARY\t\t0x1FFFFFFFUL\n\n \n#define RCAR_GEN2_PHY_CTL1_REG\t\t0x1704\n#define RCAR_GEN2_PHY_CTL1\t\t0x34180002\n#define RCAR_GEN2_PHY_CTL1_SS\t\t0xC180\t \n\n#define RCAR_GEN2_PHY_CTL2_REG\t\t0x170C\n#define RCAR_GEN2_PHY_CTL2\t\t0x00002303\n\n#define RCAR_GEN2_PHY_CTL3_REG\t\t0x171C\n#define RCAR_GEN2_PHY_CTL3\t\t0x000B0194\n\n#define RCAR_GEN2_PHY_CTL4_REG\t\t0x1724\n#define RCAR_GEN2_PHY_CTL4\t\t0x00030994\n\n#define RCAR_GEN2_PHY_CTL5_REG\t\t0x1740\n#define RCAR_GEN2_PHY_CTL5\t\t0x03004001\n#define RCAR_GEN2_PHY_CTL5_DC\t\tBIT(1)\t \n#define RCAR_GEN2_PHY_CTL5_TR\t\tBIT(2)\t \n\nenum sata_rcar_type {\n\tRCAR_GEN1_SATA,\n\tRCAR_GEN2_SATA,\n\tRCAR_GEN3_SATA,\n\tRCAR_R8A7790_ES1_SATA,\n};\n\nstruct sata_rcar_priv {\n\tvoid __iomem *base;\n\tu32 sataint_mask;\n\tenum sata_rcar_type type;\n};\n\nstatic void sata_rcar_gen1_phy_preinit(struct sata_rcar_priv *priv)\n{\n\tvoid __iomem *base = priv->base;\n\n\t \n\tiowrite32(0, base + SATAPHYADDR_REG);\n\t \n\tiowrite32(SATAPHYRESET_PHYRST, base + SATAPHYRESET_REG);\n\tudelay(10);\n\t \n\tiowrite32(0, base + SATAPHYRESET_REG);\n}\n\nstatic void sata_rcar_gen1_phy_write(struct sata_rcar_priv *priv, u16 reg,\n\t\t\t\t     u32 val, int group)\n{\n\tvoid __iomem *base = priv->base;\n\tint timeout;\n\n\t \n\tiowrite32(0, base + SATAPHYRESET_REG);\n\t \n\tiowrite32(SATAPHYACCEN_PHYLANE, base + SATAPHYACCEN_REG);\n\t \n\tiowrite32(val, base + SATAPHYWDATA_REG);\n\t \n\tif (group)\n\t\treg |= SATAPHYADDR_PHYRATEMODE;\n\t \n\tiowrite32(SATAPHYADDR_PHYCMD_WRITE | reg, base + SATAPHYADDR_REG);\n\t \n\tfor (timeout = 0; timeout < 100; timeout++) {\n\t\tval = ioread32(base + SATAPHYACK_REG);\n\t\tif (val & SATAPHYACK_PHYACK)\n\t\t\tbreak;\n\t}\n\tif (timeout >= 100)\n\t\tpr_err(\"%s timeout\\n\", __func__);\n\t \n\tiowrite32(0, base + SATAPHYADDR_REG);\n}\n\nstatic void sata_rcar_gen1_phy_init(struct sata_rcar_priv *priv)\n{\n\tsata_rcar_gen1_phy_preinit(priv);\n\tsata_rcar_gen1_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 0);\n\tsata_rcar_gen1_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 1);\n\tsata_rcar_gen1_phy_write(priv, SATAPCTLR3_REG, 0x0000A061, 0);\n\tsata_rcar_gen1_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 0);\n\tsata_rcar_gen1_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 1);\n\tsata_rcar_gen1_phy_write(priv, SATAPCTLR4_REG, 0x28E80000, 0);\n}\n\nstatic void sata_rcar_gen2_phy_init(struct sata_rcar_priv *priv)\n{\n\tvoid __iomem *base = priv->base;\n\n\tiowrite32(RCAR_GEN2_PHY_CTL1, base + RCAR_GEN2_PHY_CTL1_REG);\n\tiowrite32(RCAR_GEN2_PHY_CTL2, base + RCAR_GEN2_PHY_CTL2_REG);\n\tiowrite32(RCAR_GEN2_PHY_CTL3, base + RCAR_GEN2_PHY_CTL3_REG);\n\tiowrite32(RCAR_GEN2_PHY_CTL4, base + RCAR_GEN2_PHY_CTL4_REG);\n\tiowrite32(RCAR_GEN2_PHY_CTL5 | RCAR_GEN2_PHY_CTL5_DC |\n\t\t  RCAR_GEN2_PHY_CTL5_TR, base + RCAR_GEN2_PHY_CTL5_REG);\n}\n\nstatic void sata_rcar_freeze(struct ata_port *ap)\n{\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\n\t \n\tiowrite32(priv->sataint_mask, priv->base + SATAINTMASK_REG);\n\n\tata_sff_freeze(ap);\n}\n\nstatic void sata_rcar_thaw(struct ata_port *ap)\n{\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\tvoid __iomem *base = priv->base;\n\n\t \n\tiowrite32(~(u32)SATA_RCAR_INT_MASK, base + SATAINTSTAT_REG);\n\n\tata_sff_thaw(ap);\n\n\t \n\tiowrite32(priv->sataint_mask & ~SATA_RCAR_INT_MASK, base + SATAINTMASK_REG);\n}\n\nstatic void sata_rcar_ioread16_rep(void __iomem *reg, void *buffer, int count)\n{\n\tu16 *ptr = buffer;\n\n\twhile (count--) {\n\t\tu16 data = ioread32(reg);\n\n\t\t*ptr++ = data;\n\t}\n}\n\nstatic void sata_rcar_iowrite16_rep(void __iomem *reg, void *buffer, int count)\n{\n\tconst u16 *ptr = buffer;\n\n\twhile (count--)\n\t\tiowrite32(*ptr++, reg);\n}\n\nstatic u8 sata_rcar_check_status(struct ata_port *ap)\n{\n\treturn ioread32(ap->ioaddr.status_addr);\n}\n\nstatic u8 sata_rcar_check_altstatus(struct ata_port *ap)\n{\n\treturn ioread32(ap->ioaddr.altstatus_addr);\n}\n\nstatic void sata_rcar_set_devctl(struct ata_port *ap, u8 ctl)\n{\n\tiowrite32(ctl, ap->ioaddr.ctl_addr);\n}\n\nstatic void sata_rcar_dev_select(struct ata_port *ap, unsigned int device)\n{\n\tiowrite32(ATA_DEVICE_OBS, ap->ioaddr.device_addr);\n\tata_sff_pause(ap);\t \n}\n\nstatic bool sata_rcar_ata_devchk(struct ata_port *ap, unsigned int device)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tu8 nsect, lbal;\n\n\tsata_rcar_dev_select(ap, device);\n\n\tiowrite32(0x55, ioaddr->nsect_addr);\n\tiowrite32(0xaa, ioaddr->lbal_addr);\n\n\tiowrite32(0xaa, ioaddr->nsect_addr);\n\tiowrite32(0x55, ioaddr->lbal_addr);\n\n\tiowrite32(0x55, ioaddr->nsect_addr);\n\tiowrite32(0xaa, ioaddr->lbal_addr);\n\n\tnsect = ioread32(ioaddr->nsect_addr);\n\tlbal  = ioread32(ioaddr->lbal_addr);\n\n\tif (nsect == 0x55 && lbal == 0xaa)\n\t\treturn true;\t \n\n\treturn false;\t\t \n}\n\nstatic int sata_rcar_wait_after_reset(struct ata_link *link,\n\t\t\t\t      unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\n\tata_msleep(ap, ATA_WAIT_AFTER_RESET);\n\n\treturn ata_sff_wait_ready(link, deadline);\n}\n\nstatic int sata_rcar_bus_softreset(struct ata_port *ap, unsigned long deadline)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\t \n\tiowrite32(ap->ctl, ioaddr->ctl_addr);\n\tudelay(20);\n\tiowrite32(ap->ctl | ATA_SRST, ioaddr->ctl_addr);\n\tudelay(20);\n\tiowrite32(ap->ctl, ioaddr->ctl_addr);\n\tap->last_ctl = ap->ctl;\n\n\t \n\treturn sata_rcar_wait_after_reset(&ap->link, deadline);\n}\n\nstatic int sata_rcar_softreset(struct ata_link *link, unsigned int *classes,\n\t\t\t       unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tunsigned int devmask = 0;\n\tint rc;\n\tu8 err;\n\n\t \n\tif (sata_rcar_ata_devchk(ap, 0))\n\t\tdevmask |= 1 << 0;\n\n\t \n\trc = sata_rcar_bus_softreset(ap, deadline);\n\t \n\tif (rc && (rc != -ENODEV || sata_scr_valid(link))) {\n\t\tata_link_err(link, \"SRST failed (errno=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tclasses[0] = ata_sff_dev_classify(&link->device[0], devmask, &err);\n\n\treturn 0;\n}\n\nstatic void sata_rcar_tf_load(struct ata_port *ap,\n\t\t\t      const struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\n\n\tif (tf->ctl != ap->last_ctl) {\n\t\tiowrite32(tf->ctl, ioaddr->ctl_addr);\n\t\tap->last_ctl = tf->ctl;\n\t\tata_wait_idle(ap);\n\t}\n\n\tif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\n\t\tiowrite32(tf->hob_feature, ioaddr->feature_addr);\n\t\tiowrite32(tf->hob_nsect, ioaddr->nsect_addr);\n\t\tiowrite32(tf->hob_lbal, ioaddr->lbal_addr);\n\t\tiowrite32(tf->hob_lbam, ioaddr->lbam_addr);\n\t\tiowrite32(tf->hob_lbah, ioaddr->lbah_addr);\n\t}\n\n\tif (is_addr) {\n\t\tiowrite32(tf->feature, ioaddr->feature_addr);\n\t\tiowrite32(tf->nsect, ioaddr->nsect_addr);\n\t\tiowrite32(tf->lbal, ioaddr->lbal_addr);\n\t\tiowrite32(tf->lbam, ioaddr->lbam_addr);\n\t\tiowrite32(tf->lbah, ioaddr->lbah_addr);\n\t}\n\n\tif (tf->flags & ATA_TFLAG_DEVICE)\n\t\tiowrite32(tf->device, ioaddr->device_addr);\n\n\tata_wait_idle(ap);\n}\n\nstatic void sata_rcar_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\ttf->status = sata_rcar_check_status(ap);\n\ttf->error = ioread32(ioaddr->error_addr);\n\ttf->nsect = ioread32(ioaddr->nsect_addr);\n\ttf->lbal = ioread32(ioaddr->lbal_addr);\n\ttf->lbam = ioread32(ioaddr->lbam_addr);\n\ttf->lbah = ioread32(ioaddr->lbah_addr);\n\ttf->device = ioread32(ioaddr->device_addr);\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\tiowrite32(tf->ctl | ATA_HOB, ioaddr->ctl_addr);\n\t\ttf->hob_feature = ioread32(ioaddr->error_addr);\n\t\ttf->hob_nsect = ioread32(ioaddr->nsect_addr);\n\t\ttf->hob_lbal = ioread32(ioaddr->lbal_addr);\n\t\ttf->hob_lbam = ioread32(ioaddr->lbam_addr);\n\t\ttf->hob_lbah = ioread32(ioaddr->lbah_addr);\n\t\tiowrite32(tf->ctl, ioaddr->ctl_addr);\n\t\tap->last_ctl = tf->ctl;\n\t}\n}\n\nstatic void sata_rcar_exec_command(struct ata_port *ap,\n\t\t\t\t   const struct ata_taskfile *tf)\n{\n\tiowrite32(tf->command, ap->ioaddr.command_addr);\n\tata_sff_pause(ap);\n}\n\nstatic unsigned int sata_rcar_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\t\t      unsigned char *buf,\n\t\t\t\t\t      unsigned int buflen, int rw)\n{\n\tstruct ata_port *ap = qc->dev->link->ap;\n\tvoid __iomem *data_addr = ap->ioaddr.data_addr;\n\tunsigned int words = buflen >> 1;\n\n\t \n\tif (rw == READ)\n\t\tsata_rcar_ioread16_rep(data_addr, buf, words);\n\telse\n\t\tsata_rcar_iowrite16_rep(data_addr, buf, words);\n\n\t \n\tif (unlikely(buflen & 0x01)) {\n\t\tunsigned char pad[2] = { };\n\n\t\t \n\t\tbuf += buflen - 1;\n\n\t\t \n\t\tif (rw == READ) {\n\t\t\tsata_rcar_ioread16_rep(data_addr, pad, 1);\n\t\t\t*buf = pad[0];\n\t\t} else {\n\t\t\tpad[0] = *buf;\n\t\t\tsata_rcar_iowrite16_rep(data_addr, pad, 1);\n\t\t}\n\t\twords++;\n\t}\n\n\treturn words << 1;\n}\n\nstatic void sata_rcar_drain_fifo(struct ata_queued_cmd *qc)\n{\n\tint count;\n\tstruct ata_port *ap;\n\n\t \n\tif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\n\t\treturn;\n\n\tap = qc->ap;\n\t \n\tfor (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ) &&\n\t\t\tcount < 65536; count += 2)\n\t\tioread32(ap->ioaddr.data_addr);\n\n\tif (count)\n\t\tata_port_dbg(ap, \"drained %d bytes to clear DRQ\\n\", count);\n}\n\nstatic int sata_rcar_scr_read(struct ata_link *link, unsigned int sc_reg,\n\t\t\t      u32 *val)\n{\n\tif (sc_reg > SCR_ACTIVE)\n\t\treturn -EINVAL;\n\n\t*val = ioread32(link->ap->ioaddr.scr_addr + (sc_reg << 2));\n\treturn 0;\n}\n\nstatic int sata_rcar_scr_write(struct ata_link *link, unsigned int sc_reg,\n\t\t\t       u32 val)\n{\n\tif (sc_reg > SCR_ACTIVE)\n\t\treturn -EINVAL;\n\n\tiowrite32(val, link->ap->ioaddr.scr_addr + (sc_reg << 2));\n\treturn 0;\n}\n\nstatic void sata_rcar_bmdma_fill_sg(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_bmdma_prd *prd = ap->bmdma_prd;\n\tstruct scatterlist *sg;\n\tunsigned int si;\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tu32 addr, sg_len;\n\n\t\t \n\t\taddr = (u32)sg_dma_address(sg);\n\t\tsg_len = sg_dma_len(sg);\n\n\t\tprd[si].addr = cpu_to_le32(addr);\n\t\tprd[si].flags_len = cpu_to_le32(sg_len);\n\t}\n\n\t \n\tprd[si - 1].addr |= cpu_to_le32(SATA_RCAR_DTEND);\n}\n\nstatic enum ata_completion_errors sata_rcar_qc_prep(struct ata_queued_cmd *qc)\n{\n\tif (!(qc->flags & ATA_QCFLAG_DMAMAP))\n\t\treturn AC_ERR_OK;\n\n\tsata_rcar_bmdma_fill_sg(qc);\n\n\treturn AC_ERR_OK;\n}\n\nstatic void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tunsigned int rw = qc->tf.flags & ATA_TFLAG_WRITE;\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\tvoid __iomem *base = priv->base;\n\tu32 dmactl;\n\n\t \n\tmb();    \n\tiowrite32(ap->bmdma_prd_dma, base + ATAPI_DTB_ADR_REG);\n\n\t \n\tdmactl = ioread32(base + ATAPI_CONTROL1_REG);\n\tdmactl &= ~(ATAPI_CONTROL1_RW | ATAPI_CONTROL1_STOP);\n\tif (dmactl & ATAPI_CONTROL1_START) {\n\t\tdmactl &= ~ATAPI_CONTROL1_START;\n\t\tdmactl |= ATAPI_CONTROL1_STOP;\n\t}\n\tif (!rw)\n\t\tdmactl |= ATAPI_CONTROL1_RW;\n\tiowrite32(dmactl, base + ATAPI_CONTROL1_REG);\n\n\t \n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\nstatic void sata_rcar_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\tvoid __iomem *base = priv->base;\n\tu32 dmactl;\n\n\t \n\tdmactl = ioread32(base + ATAPI_CONTROL1_REG);\n\tdmactl &= ~ATAPI_CONTROL1_STOP;\n\tdmactl |= ATAPI_CONTROL1_START;\n\tiowrite32(dmactl, base + ATAPI_CONTROL1_REG);\n}\n\nstatic void sata_rcar_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\tvoid __iomem *base = priv->base;\n\tu32 dmactl;\n\n\t \n\tdmactl = ioread32(base + ATAPI_CONTROL1_REG);\n\tif (dmactl & ATAPI_CONTROL1_START) {\n\t\tdmactl &= ~ATAPI_CONTROL1_START;\n\t\tdmactl |= ATAPI_CONTROL1_STOP;\n\t\tiowrite32(dmactl, base + ATAPI_CONTROL1_REG);\n\t}\n\n\t \n\tata_sff_dma_pause(ap);\n}\n\nstatic u8 sata_rcar_bmdma_status(struct ata_port *ap)\n{\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\tu8 host_stat = 0;\n\tu32 status;\n\n\tstatus = ioread32(priv->base + ATAPI_STATUS_REG);\n\tif (status & ATAPI_STATUS_DEVINT)\n\t\thost_stat |= ATA_DMA_INTR;\n\tif (status & ATAPI_STATUS_ACT)\n\t\thost_stat |= ATA_DMA_ACTIVE;\n\n\treturn host_stat;\n}\n\nstatic const struct scsi_host_template sata_rcar_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t \n\t.sg_tablesize\t\t= ATA_MAX_PRD,\n\t.dma_boundary\t\t= SATA_RCAR_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations sata_rcar_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\n\t.freeze\t\t\t= sata_rcar_freeze,\n\t.thaw\t\t\t= sata_rcar_thaw,\n\t.softreset\t\t= sata_rcar_softreset,\n\n\t.scr_read\t\t= sata_rcar_scr_read,\n\t.scr_write\t\t= sata_rcar_scr_write,\n\n\t.sff_dev_select\t\t= sata_rcar_dev_select,\n\t.sff_set_devctl\t\t= sata_rcar_set_devctl,\n\t.sff_check_status\t= sata_rcar_check_status,\n\t.sff_check_altstatus\t= sata_rcar_check_altstatus,\n\t.sff_tf_load\t\t= sata_rcar_tf_load,\n\t.sff_tf_read\t\t= sata_rcar_tf_read,\n\t.sff_exec_command\t= sata_rcar_exec_command,\n\t.sff_data_xfer\t\t= sata_rcar_data_xfer,\n\t.sff_drain_fifo\t\t= sata_rcar_drain_fifo,\n\n\t.qc_prep\t\t= sata_rcar_qc_prep,\n\n\t.bmdma_setup\t\t= sata_rcar_bmdma_setup,\n\t.bmdma_start\t\t= sata_rcar_bmdma_start,\n\t.bmdma_stop\t\t= sata_rcar_bmdma_stop,\n\t.bmdma_status\t\t= sata_rcar_bmdma_status,\n};\n\nstatic void sata_rcar_serr_interrupt(struct ata_port *ap)\n{\n\tstruct sata_rcar_priv *priv = ap->host->private_data;\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tint freeze = 0;\n\tu32 serror;\n\n\tserror = ioread32(priv->base + SCRSERR_REG);\n\tif (!serror)\n\t\treturn;\n\n\tata_port_dbg(ap, \"SError @host_intr: 0x%x\\n\", serror);\n\n\t \n\tata_ehi_clear_desc(ehi);\n\n\tif (serror & (SERR_DEV_XCHG | SERR_PHYRDY_CHG)) {\n\t\t \n\t\tata_ehi_hotplugged(ehi);\n\t\tata_ehi_push_desc(ehi, \"%s\", \"hotplug\");\n\n\t\tfreeze = serror & SERR_COMM_WAKE ? 0 : 1;\n\t}\n\n\t \n\tif (freeze)\n\t\tata_port_freeze(ap);\n\telse\n\t\tata_port_abort(ap);\n}\n\nstatic void sata_rcar_ata_interrupt(struct ata_port *ap)\n{\n\tstruct ata_queued_cmd *qc;\n\tint handled = 0;\n\n\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\tif (qc)\n\t\thandled |= ata_bmdma_port_intr(ap, qc);\n\n\t \n\tif (!handled)\n\t\tsata_rcar_check_status(ap);\n}\n\nstatic irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct sata_rcar_priv *priv = host->private_data;\n\tvoid __iomem *base = priv->base;\n\tunsigned int handled = 0;\n\tstruct ata_port *ap;\n\tu32 sataintstat;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tsataintstat = ioread32(base + SATAINTSTAT_REG);\n\tsataintstat &= SATA_RCAR_INT_MASK;\n\tif (!sataintstat)\n\t\tgoto done;\n\t \n\tiowrite32(~sataintstat & priv->sataint_mask, base + SATAINTSTAT_REG);\n\n\tap = host->ports[0];\n\n\tif (sataintstat & SATAINTSTAT_ATA)\n\t\tsata_rcar_ata_interrupt(ap);\n\n\tif (sataintstat & SATAINTSTAT_SERR)\n\t\tsata_rcar_serr_interrupt(ap);\n\n\thandled = 1;\ndone:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void sata_rcar_setup_port(struct ata_host *host)\n{\n\tstruct ata_port *ap = host->ports[0];\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tstruct sata_rcar_priv *priv = host->private_data;\n\tvoid __iomem *base = priv->base;\n\n\tap->ops\t\t= &sata_rcar_port_ops;\n\tap->pio_mask\t= ATA_PIO4;\n\tap->udma_mask\t= ATA_UDMA6;\n\tap->flags\t|= ATA_FLAG_SATA;\n\n\tif (priv->type == RCAR_R8A7790_ES1_SATA)\n\t\tap->flags\t|= ATA_FLAG_NO_DIPM;\n\n\tioaddr->cmd_addr = base + SDATA_REG;\n\tioaddr->ctl_addr = base + SSDEVCON_REG;\n\tioaddr->scr_addr = base + SCRSSTS_REG;\n\tioaddr->altstatus_addr = ioaddr->ctl_addr;\n\n\tioaddr->data_addr\t= ioaddr->cmd_addr + (ATA_REG_DATA << 2);\n\tioaddr->error_addr\t= ioaddr->cmd_addr + (ATA_REG_ERR << 2);\n\tioaddr->feature_addr\t= ioaddr->cmd_addr + (ATA_REG_FEATURE << 2);\n\tioaddr->nsect_addr\t= ioaddr->cmd_addr + (ATA_REG_NSECT << 2);\n\tioaddr->lbal_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAL << 2);\n\tioaddr->lbam_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAM << 2);\n\tioaddr->lbah_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAH << 2);\n\tioaddr->device_addr\t= ioaddr->cmd_addr + (ATA_REG_DEVICE << 2);\n\tioaddr->status_addr\t= ioaddr->cmd_addr + (ATA_REG_STATUS << 2);\n\tioaddr->command_addr\t= ioaddr->cmd_addr + (ATA_REG_CMD << 2);\n}\n\nstatic void sata_rcar_init_module(struct sata_rcar_priv *priv)\n{\n\tvoid __iomem *base = priv->base;\n\tu32 val;\n\n\t \n\tval = ioread32(base + ATAPI_CONTROL1_REG);\n\tval |= ATAPI_CONTROL1_RESET;\n\tiowrite32(val, base + ATAPI_CONTROL1_REG);\n\n\t \n\tval = ioread32(base + ATAPI_CONTROL1_REG);\n\tval |= ATAPI_CONTROL1_ISM;\n\tval |= ATAPI_CONTROL1_DESE;\n\tval |= ATAPI_CONTROL1_DTA32M;\n\tiowrite32(val, base + ATAPI_CONTROL1_REG);\n\n\t \n\tval = ioread32(base + ATAPI_CONTROL1_REG);\n\tval &= ~ATAPI_CONTROL1_RESET;\n\tiowrite32(val, base + ATAPI_CONTROL1_REG);\n\n\t \n\tiowrite32(0, base + SATAINTSTAT_REG);\n\tiowrite32(priv->sataint_mask, base + SATAINTMASK_REG);\n\n\t \n\tiowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);\n}\n\nstatic void sata_rcar_init_controller(struct ata_host *host)\n{\n\tstruct sata_rcar_priv *priv = host->private_data;\n\n\tpriv->sataint_mask = SATAINTMASK_ALL_GEN2;\n\n\t \n\tswitch (priv->type) {\n\tcase RCAR_GEN1_SATA:\n\t\tpriv->sataint_mask = SATAINTMASK_ALL_GEN1;\n\t\tsata_rcar_gen1_phy_init(priv);\n\t\tbreak;\n\tcase RCAR_GEN2_SATA:\n\tcase RCAR_R8A7790_ES1_SATA:\n\t\tsata_rcar_gen2_phy_init(priv);\n\t\tbreak;\n\tcase RCAR_GEN3_SATA:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(host->dev, \"SATA phy is not initialized\\n\");\n\t\tbreak;\n\t}\n\n\tsata_rcar_init_module(priv);\n}\n\nstatic const struct of_device_id sata_rcar_match[] = {\n\t{\n\t\t \n\t\t.compatible = \"renesas,rcar-sata\",\n\t\t.data = (void *)RCAR_GEN1_SATA,\n\t},\n\t{\n\t\t.compatible = \"renesas,sata-r8a7779\",\n\t\t.data = (void *)RCAR_GEN1_SATA,\n\t},\n\t{\n\t\t.compatible = \"renesas,sata-r8a7790\",\n\t\t.data = (void *)RCAR_GEN2_SATA\n\t},\n\t{\n\t\t.compatible = \"renesas,sata-r8a7790-es1\",\n\t\t.data = (void *)RCAR_R8A7790_ES1_SATA\n\t},\n\t{\n\t\t.compatible = \"renesas,sata-r8a7791\",\n\t\t.data = (void *)RCAR_GEN2_SATA\n\t},\n\t{\n\t\t.compatible = \"renesas,sata-r8a7793\",\n\t\t.data = (void *)RCAR_GEN2_SATA\n\t},\n\t{\n\t\t.compatible = \"renesas,sata-r8a7795\",\n\t\t.data = (void *)RCAR_GEN3_SATA\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen2-sata\",\n\t\t.data = (void *)RCAR_GEN2_SATA\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen3-sata\",\n\t\t.data = (void *)RCAR_GEN3_SATA\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sata_rcar_match);\n\nstatic int sata_rcar_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ata_host *host;\n\tstruct sata_rcar_priv *priv;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct sata_rcar_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->type = (unsigned long)of_device_get_match_data(dev);\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tgoto err_pm_put;\n\n\thost = ata_host_alloc(dev, 1);\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pm_put;\n\t}\n\n\thost->private_data = priv;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto err_pm_put;\n\t}\n\n\t \n\tsata_rcar_setup_port(host);\n\n\t \n\tsata_rcar_init_controller(host);\n\n\tret = ata_host_activate(host, irq, sata_rcar_interrupt, 0,\n\t\t\t\t&sata_rcar_sht);\n\tif (!ret)\n\t\treturn 0;\n\nerr_pm_put:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void sata_rcar_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct sata_rcar_priv *priv = host->private_data;\n\tvoid __iomem *base = priv->base;\n\n\tata_host_detach(host);\n\n\t \n\tiowrite32(0, base + ATAPI_INT_ENABLE_REG);\n\t \n\tiowrite32(0, base + SATAINTSTAT_REG);\n\tiowrite32(priv->sataint_mask, base + SATAINTMASK_REG);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sata_rcar_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct sata_rcar_priv *priv = host->private_data;\n\tvoid __iomem *base = priv->base;\n\n\tata_host_suspend(host, PMSG_SUSPEND);\n\n\t \n\tiowrite32(0, base + ATAPI_INT_ENABLE_REG);\n\t \n\tiowrite32(priv->sataint_mask, base + SATAINTMASK_REG);\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic int sata_rcar_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct sata_rcar_priv *priv = host->private_data;\n\tvoid __iomem *base = priv->base;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put(dev);\n\t\treturn ret;\n\t}\n\n\tif (priv->type == RCAR_GEN3_SATA) {\n\t\tsata_rcar_init_module(priv);\n\t} else {\n\t\t \n\t\tiowrite32(0, base + SATAINTSTAT_REG);\n\t\tiowrite32(priv->sataint_mask, base + SATAINTMASK_REG);\n\n\t\t \n\t\tiowrite32(ATAPI_INT_ENABLE_SATAINT,\n\t\t\t  base + ATAPI_INT_ENABLE_REG);\n\t}\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n\nstatic int sata_rcar_restore(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put(dev);\n\t\treturn ret;\n\t}\n\n\tsata_rcar_setup_port(host);\n\n\t \n\tsata_rcar_init_controller(host);\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sata_rcar_pm_ops = {\n\t.suspend\t= sata_rcar_suspend,\n\t.resume\t\t= sata_rcar_resume,\n\t.freeze\t\t= sata_rcar_suspend,\n\t.thaw\t\t= sata_rcar_resume,\n\t.poweroff\t= sata_rcar_suspend,\n\t.restore\t= sata_rcar_restore,\n};\n#endif\n\nstatic struct platform_driver sata_rcar_driver = {\n\t.probe\t\t= sata_rcar_probe,\n\t.remove_new\t= sata_rcar_remove,\n\t.driver = {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= sata_rcar_match,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t\t= &sata_rcar_pm_ops,\n#endif\n\t},\n};\n\nmodule_platform_driver(sata_rcar_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Vladimir Barinov\");\nMODULE_DESCRIPTION(\"Renesas R-Car SATA controller low level driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}