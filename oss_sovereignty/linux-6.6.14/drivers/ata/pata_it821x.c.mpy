{
  "module_name": "pata_it821x.c",
  "hash_id": "eae97322509a131bdc308a5dc9e42ff079e6d0a8a7b07eba8d94b9a722530e32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_it821x.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n\n#define DRV_NAME \"pata_it821x\"\n#define DRV_VERSION \"0.4.2\"\n\nstruct it821x_dev\n{\n\tunsigned int smart:1,\t\t \n\t\ttiming10:1;\t\t \n\tu8\tclock_mode;\t\t \n\tu8\twant[2][2];\t\t \n\t \n\tu16\tpio[2];\t\t\t \n\tu16\tmwdma[2];\t\t \n\tu16\tudma[2];\t\t \n\tu16\tlast_device;\t\t \n};\n\n#define ATA_66\t\t0\n#define ATA_50\t\t1\n#define ATA_ANY\t\t2\n\n#define UDMA_OFF\t0\n#define MWDMA_OFF\t0\n\n \n\nstatic int it8212_noraid;\n\n \n\nstatic void it821x_program(struct ata_port *ap, struct ata_device *adev, u16 timing)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct it821x_dev *itdev = ap->private_data;\n\tint channel = ap->port_no;\n\tu8 conf;\n\n\t \n\tif (itdev->clock_mode == ATA_66)\n\t\tconf = timing >> 8;\n\telse\n\t\tconf = timing & 0xFF;\n\tpci_write_config_byte(pdev, 0x54 + 4 * channel, conf);\n}\n\n\n \n\nstatic void it821x_program_udma(struct ata_port *ap, struct ata_device *adev, u16 timing)\n{\n\tstruct it821x_dev *itdev = ap->private_data;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint channel = ap->port_no;\n\tint unit = adev->devno;\n\tu8 conf;\n\n\t \n\tif (itdev->clock_mode == ATA_66)\n\t\tconf = timing >> 8;\n\telse\n\t\tconf = timing & 0xFF;\n\tif (itdev->timing10 == 0)\n\t\tpci_write_config_byte(pdev, 0x56 + 4 * channel + unit, conf);\n\telse {\n\t\t \n\t\tpci_write_config_byte(pdev, 0x56 + 4 * channel, conf);\n\t\tpci_write_config_byte(pdev, 0x56 + 4 * channel + 1, conf);\n\t}\n}\n\n \n\nstatic void it821x_clock_strategy(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct it821x_dev *itdev = ap->private_data;\n\tu8 unit = adev->devno;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\n\tint clock, altclock;\n\tu8 v;\n\tint sel = 0;\n\n\t \n\tif (itdev->want[0][0] > itdev->want[1][0]) {\n\t\tclock = itdev->want[0][1];\n\t\taltclock = itdev->want[1][1];\n\t} else {\n\t\tclock = itdev->want[1][1];\n\t\taltclock = itdev->want[0][1];\n\t}\n\n\t \n\tif (clock == ATA_ANY)\n\t\tclock = altclock;\n\n\t \n\tif (clock == ATA_ANY)\n\t\treturn;\n\t \n\tif (clock == itdev->clock_mode)\n\t\treturn;\n\n\t \n\tif (clock == ATA_66)\n\t\titdev->clock_mode = ATA_66;\n\telse {\n\t\titdev->clock_mode = ATA_50;\n\t\tsel = 1;\n\t}\n\tpci_read_config_byte(pdev, 0x50, &v);\n\tv &= ~(1 << (1 + ap->port_no));\n\tv |= sel << (1 + ap->port_no);\n\tpci_write_config_byte(pdev, 0x50, v);\n\n\t \n\tif (pair && itdev->udma[1-unit] != UDMA_OFF) {\n\t\tit821x_program_udma(ap, pair, itdev->udma[1-unit]);\n\t\tit821x_program(ap, pair, itdev->pio[1-unit]);\n\t}\n\t \n\tif (itdev->udma[unit] != UDMA_OFF) {\n\t\tit821x_program_udma(ap, adev, itdev->udma[unit]);\n\t\tit821x_program(ap, adev, itdev->pio[unit]);\n\t}\n}\n\n \n\nstatic void it821x_passthru_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\t \n\tstatic const u16 pio[]\t= { 0xAA88, 0xA382, 0xA181, 0x3332, 0x3121 };\n\tstatic const u8 pio_want[]    = { ATA_66, ATA_66, ATA_66, ATA_66, ATA_ANY };\n\n\tstruct it821x_dev *itdev = ap->private_data;\n\tint unit = adev->devno;\n\tint mode_wanted = adev->pio_mode - XFER_PIO_0;\n\n\t \n\titdev->want[unit][1] = pio_want[mode_wanted];\n\titdev->want[unit][0] = 1;\t \n\titdev->pio[unit] = pio[mode_wanted];\n\tit821x_clock_strategy(ap, adev);\n\tit821x_program(ap, adev, itdev->pio[unit]);\n}\n\n \n\nstatic void it821x_passthru_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u16 dma[]\t= \t{ 0x8866, 0x3222, 0x3121 };\n\tstatic const u8 mwdma_want[] =  { ATA_ANY, ATA_66, ATA_ANY };\n\tstatic const u16 udma[]\t= \t{ 0x4433, 0x4231, 0x3121, 0x2121, 0x1111, 0x2211, 0x1111 };\n\tstatic const u8 udma_want[] =   { ATA_ANY, ATA_50, ATA_ANY, ATA_66, ATA_66, ATA_50, ATA_66 };\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct it821x_dev *itdev = ap->private_data;\n\tint channel = ap->port_no;\n\tint unit = adev->devno;\n\tu8 conf;\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tint mode_wanted = adev->dma_mode - XFER_UDMA_0;\n\n\t\titdev->want[unit][1] = udma_want[mode_wanted];\n\t\titdev->want[unit][0] = 3;\t \n\t\titdev->mwdma[unit] = MWDMA_OFF;\n\t\titdev->udma[unit] = udma[mode_wanted];\n\t\tif (mode_wanted >= 5)\n\t\t\titdev->udma[unit] |= 0x8080;\t \n\n\t\t \n\t\tpci_read_config_byte(pdev, 0x50, &conf);\n\t\tif (itdev->timing10)\n\t\t\tconf &= channel ? 0x9F: 0xE7;\n\t\telse\n\t\t\tconf &= ~ (1 << (3 + 2 * channel + unit));\n\t\tpci_write_config_byte(pdev, 0x50, conf);\n\t\tit821x_clock_strategy(ap, adev);\n\t\tit821x_program_udma(ap, adev, itdev->udma[unit]);\n\t} else {\n\t\tint mode_wanted = adev->dma_mode - XFER_MW_DMA_0;\n\n\t\titdev->want[unit][1] = mwdma_want[mode_wanted];\n\t\titdev->want[unit][0] = 2;\t \n\t\titdev->mwdma[unit] = dma[mode_wanted];\n\t\titdev->udma[unit] = UDMA_OFF;\n\n\t\t \n\t\tpci_read_config_byte(pdev, 0x50, &conf);\n\t\tif (itdev->timing10)\n\t\t\tconf |= channel ? 0x60: 0x18;\n\t\telse\n\t\t\tconf |= 1 << (3 + 2 * channel + unit);\n\t\tpci_write_config_byte(pdev, 0x50, conf);\n\t\tit821x_clock_strategy(ap, adev);\n\t}\n}\n\n \n\nstatic void it821x_passthru_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct it821x_dev *itdev = ap->private_data;\n\tint unit = adev->devno;\n\n\tif (itdev->mwdma[unit] != MWDMA_OFF)\n\t\tit821x_program(ap, adev, itdev->mwdma[unit]);\n\telse if (itdev->udma[unit] != UDMA_OFF && itdev->timing10)\n\t\tit821x_program_udma(ap, adev, itdev->udma[unit]);\n\tata_bmdma_start(qc);\n}\n\n \n\nstatic void it821x_passthru_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct it821x_dev *itdev = ap->private_data;\n\tint unit = adev->devno;\n\n\tata_bmdma_stop(qc);\n\tif (itdev->mwdma[unit] != MWDMA_OFF)\n\t\tit821x_program(ap, adev, itdev->pio[unit]);\n}\n\n\n \n\nstatic void it821x_passthru_dev_select(struct ata_port *ap,\n\t\t\t\t       unsigned int device)\n{\n\tstruct it821x_dev *itdev = ap->private_data;\n\tif (itdev && device != itdev->last_device) {\n\t\tstruct ata_device *adev = &ap->link.device[device];\n\t\tit821x_program(ap, adev, itdev->pio[adev->devno]);\n\t\titdev->last_device = device;\n\t}\n\tata_sff_dev_select(ap, device);\n}\n\n \n\nstatic unsigned int it821x_smart_qc_issue(struct ata_queued_cmd *qc)\n{\n\tswitch(qc->tf.command)\n\t{\n\t\t \n\t\tcase ATA_CMD_READ:\n\t\tcase ATA_CMD_READ_EXT:\n\t\tcase ATA_CMD_WRITE:\n\t\tcase ATA_CMD_WRITE_EXT:\n\t\tcase ATA_CMD_PIO_READ:\n\t\tcase ATA_CMD_PIO_READ_EXT:\n\t\tcase ATA_CMD_PIO_WRITE:\n\t\tcase ATA_CMD_PIO_WRITE_EXT:\n\t\tcase ATA_CMD_READ_MULTI:\n\t\tcase ATA_CMD_READ_MULTI_EXT:\n\t\tcase ATA_CMD_WRITE_MULTI:\n\t\tcase ATA_CMD_WRITE_MULTI_EXT:\n\t\tcase ATA_CMD_ID_ATA:\n\t\tcase ATA_CMD_INIT_DEV_PARAMS:\n\t\tcase 0xFC:\t \n\t\t \n\t\tcase ATA_CMD_SET_FEATURES:\n\t\t\treturn ata_bmdma_qc_issue(qc);\n\t}\n\tata_dev_dbg(qc->dev, \"it821x: can't process command 0x%02X\\n\",\n\t\t    qc->tf.command);\n\treturn AC_ERR_DEV;\n}\n\n \n\nstatic unsigned int it821x_passthru_qc_issue(struct ata_queued_cmd *qc)\n{\n\tit821x_passthru_dev_select(qc->ap, qc->dev->devno);\n\treturn ata_bmdma_qc_issue(qc);\n}\n\n \n\nstatic int it821x_smart_set_mode(struct ata_link *link, struct ata_device **unused)\n{\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\t \n\t\tdev->pio_mode = XFER_PIO_0;\n\t\tdev->dma_mode = XFER_MW_DMA_0;\n\t\t \n\t\tif (ata_id_has_dma(dev->id)) {\n\t\t\tata_dev_info(dev, \"configured for DMA\\n\");\n\t\t\tdev->xfer_mode = XFER_MW_DMA_0;\n\t\t\tdev->xfer_shift = ATA_SHIFT_MWDMA;\n\t\t\tdev->flags &= ~ATA_DFLAG_PIO;\n\t\t} else {\n\t\t\tata_dev_info(dev, \"configured for PIO\\n\");\n\t\t\tdev->xfer_mode = XFER_PIO_0;\n\t\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\t\tdev->flags |= ATA_DFLAG_PIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic void it821x_dev_config(struct ata_device *adev)\n{\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\n\tata_id_c_string(adev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\n\tif (adev->max_sectors > 255)\n\t\tadev->max_sectors = 255;\n\n\tif (strstr(model_num, \"Integrated Technology Express\")) {\n\t\t \n\t\tif (adev->id[129] == 1)\n\t\t\tata_dev_info(adev, \"%sRAID%d volume\\n\",\n\t\t\t\t     adev->id[147] ? \"Bootable \" : \"\",\n\t\t\t\t     adev->id[129]);\n\t\telse\n\t\t\tata_dev_info(adev, \"%sRAID%d volume (%dK stripe)\\n\",\n\t\t\t\t     adev->id[147] ? \"Bootable \" : \"\",\n\t\t\t\t     adev->id[129], adev->id[146]);\n\t}\n\t \n\tadev->horkage &= ~ATA_HORKAGE_DIAGNOSTIC;\n\t \n\tadev->horkage |= ATA_HORKAGE_BROKEN_HPA;\n}\n\n \n\nstatic unsigned int it821x_read_id(struct ata_device *adev,\n\t\t\t\t   struct ata_taskfile *tf, __le16 *id)\n{\n\tunsigned int err_mask;\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\n\terr_mask = ata_do_dev_read_id(adev, tf, id);\n\tif (err_mask)\n\t\treturn err_mask;\n\tata_id_c_string((u16 *)id, model_num, ATA_ID_PROD, sizeof(model_num));\n\n\tid[83] &= cpu_to_le16(~(1 << 12));  \n\tid[84] &= cpu_to_le16(~(1 << 6));   \n\tid[85] &= cpu_to_le16(~(1 << 10));  \n\tid[76] = 0;\t\t\t    \n\n\tif (strstr(model_num, \"Integrated Technology Express\")) {\n\t\t \n\t\tid[49] |= cpu_to_le16(0x0300);\t \n\t\tid[83] &= cpu_to_le16(0x7FFF);\n\t\tid[83] |= cpu_to_le16(0x4400);\t \n\t\tid[86] |= cpu_to_le16(0x0400);\t \n\t\tid[ATA_ID_MAJOR_VER] |= cpu_to_le16(0x1F);\n\t\t \n\t\tmemset(&id[ATA_ID_SERNO], 0x20, ATA_ID_SERNO_LEN);\n\t}\n\treturn err_mask;\n}\n\n \n\nstatic int it821x_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct it821x_dev *itdev = ap->private_data;\n\n\t \n\tif (ata_qc_raw_nbytes(qc) < 2048)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (itdev->smart)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (itdev->timing10)\n\t\treturn -EOPNOTSUPP;\n\t \n\treturn 0;\n}\n\n \n\nstatic void it821x_display_disk(struct ata_port *ap, int n, u8 *buf)\n{\n\tunsigned char id[41];\n\tint mode = 0;\n\tconst char *mtype = \"\";\n\tchar mbuf[8];\n\tconst char *cbl = \"(40 wire cable)\";\n\n\tstatic const char *types[5] = {\n\t\t\"RAID0\", \"RAID1\", \"RAID 0+1\", \"JBOD\", \"DISK\"\n\t};\n\n\tif (buf[52] > 4)\t \n\t\treturn;\n\n\tata_id_c_string((u16 *)buf, id, 0, 41);\n\n\tif (buf[51]) {\n\t\tmode = ffs(buf[51]);\n\t\tmtype = \"UDMA\";\n\t} else if (buf[49]) {\n\t\tmode = ffs(buf[49]);\n\t\tmtype = \"MWDMA\";\n\t}\n\n\tif (buf[76])\n\t\tcbl = \"\";\n\n\tif (mode)\n\t\tsnprintf(mbuf, 8, \"%5s%d\", mtype, mode - 1);\n\telse\n\t\tstrcpy(mbuf, \"PIO\");\n\tif (buf[52] == 4)\n\t\tata_port_info(ap, \"%d: %-6s %-8s          %s %s\\n\",\n\t\t\t\tn, mbuf, types[buf[52]], id, cbl);\n\telse\n\t\tata_port_info(ap, \"%d: %-6s %-8s Volume: %1d %s %s\\n\",\n\t\t\t\tn, mbuf, types[buf[52]], buf[53], id, cbl);\n\tif (buf[125] < 100)\n\t\tata_port_info(ap, \"%d: Rebuilding: %d%%\\n\", n, buf[125]);\n}\n\n \n\nstatic u8 *it821x_firmware_command(struct ata_port *ap, u8 cmd, int len)\n{\n\tu8 status;\n\tint n = 0;\n\tu16 *buf = kmalloc(len, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn NULL;\n\n\t \n\tap->ctl |= ATA_NIEN;\n\tiowrite8(ap->ctl, ap->ioaddr.ctl_addr);\n\tata_wait_idle(ap);\n\tiowrite8(ATA_DEVICE_OBS, ap->ioaddr.device_addr);\n\tiowrite8(cmd, ap->ioaddr.command_addr);\n\tudelay(1);\n\t \n\twhile(n++ < 10) {\n\t\tstatus = ioread8(ap->ioaddr.status_addr);\n\t\tif (status & ATA_ERR) {\n\t\t\tkfree(buf);\n\t\t\tata_port_err(ap, \"%s: rejected\\n\", __func__);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (status & ATA_DRQ) {\n\t\t\tioread16_rep(ap->ioaddr.data_addr, buf, len/2);\n\t\t\treturn (u8 *)buf;\n\t\t}\n\t\tusleep_range(500, 1000);\n\t}\n\tkfree(buf);\n\tata_port_err(ap, \"%s: timeout\\n\", __func__);\n\treturn NULL;\n}\n\n \n\nstatic void it821x_probe_firmware(struct ata_port *ap)\n{\n\tu8 *buf;\n\tint i;\n\n\t \n\n\tbuf = it821x_firmware_command(ap, 0xFA, 512);\n\n\tif (buf != NULL) {\n\t\tata_port_info(ap, \"pata_it821x: Firmware %02X/%02X/%02X%02X\\n\",\n\t\t\t\tbuf[505],\n\t\t\t\tbuf[506],\n\t\t\t\tbuf[507],\n\t\t\t\tbuf[508]);\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tit821x_display_disk(ap, i, buf + 128 * i);\n\t\tkfree(buf);\n\t}\n}\n\n\n\n \n\nstatic int it821x_port_start(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct it821x_dev *itdev;\n\tu8 conf;\n\n\tint ret = ata_bmdma_port_start(ap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\titdev = devm_kzalloc(&pdev->dev, sizeof(struct it821x_dev), GFP_KERNEL);\n\tif (itdev == NULL)\n\t\treturn -ENOMEM;\n\tap->private_data = itdev;\n\n\tpci_read_config_byte(pdev, 0x50, &conf);\n\n\tif (conf & 1) {\n\t\titdev->smart = 1;\n\t\t \n\t\t \n\t\tif (ap->port_no == 0)\n\t\t\tit821x_probe_firmware(ap);\n\t}\n\t \n\tif (conf & (1 << (1 + ap->port_no)))\n\t\titdev->clock_mode = ATA_50;\n\telse\n\t\titdev->clock_mode = ATA_66;\n\n\titdev->want[0][1] = ATA_ANY;\n\titdev->want[1][1] = ATA_ANY;\n\titdev->last_device = -1;\n\n\tif (pdev->revision == 0x10) {\n\t\titdev->timing10 = 1;\n\t\t \n\t\tif (!itdev->smart)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Revision 0x10, workarounds activated.\\n\");\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int it821x_rdc_cable(struct ata_port *ap)\n{\n\tu16 r40;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tpci_read_config_word(pdev, 0x40, &r40);\n\tif (r40 & (1 << (2 + ap->port_no)))\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\nstatic const struct scsi_host_template it821x_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations it821x_smart_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.check_atapi_dma= it821x_check_atapi_dma,\n\t.qc_issue\t= it821x_smart_qc_issue,\n\n\t.cable_detect\t= ata_cable_80wire,\n\t.set_mode\t= it821x_smart_set_mode,\n\t.dev_config\t= it821x_dev_config,\n\t.read_id\t= it821x_read_id,\n\n\t.port_start\t= it821x_port_start,\n};\n\nstatic struct ata_port_operations it821x_passthru_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.check_atapi_dma= it821x_check_atapi_dma,\n\t.sff_dev_select\t= it821x_passthru_dev_select,\n\t.bmdma_start \t= it821x_passthru_bmdma_start,\n\t.bmdma_stop\t= it821x_passthru_bmdma_stop,\n\t.qc_issue\t= it821x_passthru_qc_issue,\n\n\t.cable_detect\t= ata_cable_unknown,\n\t.set_piomode\t= it821x_passthru_set_piomode,\n\t.set_dmamode\t= it821x_passthru_set_dmamode,\n\n\t.port_start\t= it821x_port_start,\n};\n\nstatic struct ata_port_operations it821x_rdc_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.check_atapi_dma= it821x_check_atapi_dma,\n\t.sff_dev_select\t= it821x_passthru_dev_select,\n\t.bmdma_start \t= it821x_passthru_bmdma_start,\n\t.bmdma_stop\t= it821x_passthru_bmdma_stop,\n\t.qc_issue\t= it821x_passthru_qc_issue,\n\n\t.cable_detect\t= it821x_rdc_cable,\n\t.set_piomode\t= it821x_passthru_set_piomode,\n\t.set_dmamode\t= it821x_passthru_set_dmamode,\n\n\t.port_start\t= it821x_port_start,\n};\n\nstatic void it821x_disable_raid(struct pci_dev *pdev)\n{\n\t \n\tif (pdev->vendor != PCI_VENDOR_ID_ITE ||\n\t\t\tpdev->device != PCI_DEVICE_ID_ITE_8212)\n\t\t\treturn;\n\n\t \n\tpci_write_config_byte(pdev, 0x5E, 0x01);\n\n\t \n\tpci_write_config_byte(pdev, 0x50, 0x00);\n\tpci_write_config_word(pdev, PCI_COMMAND,\n\t\t\t      PCI_COMMAND_PARITY | PCI_COMMAND_IO |\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\tpci_write_config_word(pdev, 0x40, 0xA0F3);\n\n\tpci_write_config_dword(pdev,0x4C, 0x02040204);\n\tpci_write_config_byte(pdev, 0x42, 0x36);\n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x20);\n}\n\n\nstatic int it821x_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tu8 conf;\n\n\tstatic const struct ata_port_info info_smart = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &it821x_smart_port_ops\n\t};\n\tstatic const struct ata_port_info info_passthru = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &it821x_passthru_port_ops\n\t};\n\tstatic const struct ata_port_info info_rdc = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &it821x_rdc_port_ops\n\t};\n\tstatic const struct ata_port_info info_rdc_11 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t \n\t\t.port_ops = &it821x_rdc_port_ops\n\t};\n\n\tconst struct ata_port_info *ppi[] = { NULL, NULL };\n\tstatic const char *mode[2] = { \"pass through\", \"smart\" };\n\tint rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_RDC) {\n\t\t \n\t\tif (pdev->revision == 0x11)\n\t\t\tppi[0] = &info_rdc_11;\n\t\telse\n\t\t\tppi[0] = &info_rdc;\n\t} else {\n\t\t \n\t\tif (it8212_noraid) {\n\t\t\tdev_info(&pdev->dev, \"forcing bypass mode.\\n\");\n\t\t\tit821x_disable_raid(pdev);\n\t\t}\n\t\tpci_read_config_byte(pdev, 0x50, &conf);\n\t\tconf &= 1;\n\n\t\tdev_info(&pdev->dev, \"controller in %s mode.\\n\", mode[conf]);\n\n\t\tif (conf == 0)\n\t\t\tppi[0] = &info_passthru;\n\t\telse\n\t\t\tppi[0] = &info_smart;\n\t}\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &it821x_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int it821x_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\t \n\tif (it8212_noraid)\n\t\tit821x_disable_raid(pdev);\n\tata_host_resume(host);\n\treturn rc;\n}\n#endif\n\nstatic const struct pci_device_id it821x[] = {\n\t{ PCI_VDEVICE(ITE, PCI_DEVICE_ID_ITE_8211), },\n\t{ PCI_VDEVICE(ITE, PCI_DEVICE_ID_ITE_8212), },\n\t{ PCI_VDEVICE(RDC, PCI_DEVICE_ID_RDC_D1010), },\n\n\t{ },\n};\n\nstatic struct pci_driver it821x_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= it821x,\n\t.probe \t\t= it821x_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= it821x_reinit_one,\n#endif\n};\n\nmodule_pci_driver(it821x_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the IT8211/IT8212 IDE RAID controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, it821x);\nMODULE_VERSION(DRV_VERSION);\n\nmodule_param_named(noraid, it8212_noraid, int, S_IRUGO);\nMODULE_PARM_DESC(noraid, \"Force card into bypass mode\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}