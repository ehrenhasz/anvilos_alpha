{
  "module_name": "ata_piix.c",
  "hash_id": "d438b5fc680dd58f7c4d231b0dedf1bc1e8ac32fd023e9ca6af969cafdacdd71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ata_piix.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n#include <trace/events/libata.h>\n\n#define DRV_NAME\t\"ata_piix\"\n#define DRV_VERSION\t\"2.13\"\n\nenum {\n\tPIIX_IOCFG\t\t= 0x54,  \n\tICH5_PMR\t\t= 0x90,  \n\tICH5_PCS\t\t= 0x92,\t \n\tPIIX_SIDPR_BAR\t\t= 5,\n\tPIIX_SIDPR_LEN\t\t= 16,\n\tPIIX_SIDPR_IDX\t\t= 0,\n\tPIIX_SIDPR_DATA\t\t= 4,\n\n\tPIIX_FLAG_CHECKINTR\t= (1 << 28),  \n\tPIIX_FLAG_SIDPR\t\t= (1 << 29),  \n\n\tPIIX_PATA_FLAGS\t\t= ATA_FLAG_SLAVE_POSS,\n\tPIIX_SATA_FLAGS\t\t= ATA_FLAG_SATA | PIIX_FLAG_CHECKINTR,\n\n\tPIIX_FLAG_PIO16\t\t= (1 << 30),  \n\n\tPIIX_80C_PRI\t\t= (1 << 5) | (1 << 4),\n\tPIIX_80C_SEC\t\t= (1 << 7) | (1 << 6),\n\n\t \n\tP0\t\t\t= 0,   \n\tP1\t\t\t= 1,   \n\tP2\t\t\t= 2,   \n\tP3\t\t\t= 3,   \n\tIDE\t\t\t= -1,  \n\tNA\t\t\t= -2,  \n\tRV\t\t\t= -3,  \n\n\tPIIX_AHCI_DEVICE\t= 6,\n\n\t \n\tPIIX_HOST_BROKEN_SUSPEND = (1 << 24),\n};\n\nenum piix_controller_ids {\n\t \n\tpiix_pata_mwdma,\t \n\tpiix_pata_33,\t\t \n\tich_pata_33,\t\t \n\tich_pata_66,\t\t \n\tich_pata_100,\t\t \n\tich_pata_100_nomwdma1,\t \n\tich5_sata,\n\tich6_sata,\n\tich6m_sata,\n\tich8_sata,\n\tich8_2port_sata,\n\tich8m_apple_sata,\t \n\ttolapai_sata,\n\tpiix_pata_vmw,\t\t\t \n\tich8_sata_snb,\n\tich8_2port_sata_snb,\n\tich8_2port_sata_byt,\n};\n\nstruct piix_map_db {\n\tconst u32 mask;\n\tconst u16 port_enable;\n\tconst int map[][4];\n};\n\nstruct piix_host_priv {\n\tconst int *map;\n\tu32 saved_iocfg;\n\tvoid __iomem *sidpr;\n};\n\nstatic unsigned int in_module_init = 1;\n\nstatic const struct pci_device_id piix_pci_tbl[] = {\n\t \n\t{ 0x8086, 0x7010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_mwdma },\n\t \n\t{ 0x8086, 0x7111, 0x15ad, 0x1976, 0, 0, piix_pata_vmw },\n\t \n\t \n\t{ 0x8086, 0x7111, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_33 },\n\t \n\t{ 0x8086, 0x7199, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_33 },\n\t \n\t{ 0x8086, 0x7601, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_33 },\n\t \n\t{ 0x8086, 0x84CA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix_pata_33 },\n\t \n\t{ 0x8086, 0x2411, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_66 },\n\t \n\t{ 0x8086, 0x2421, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_33 },\n\t \n\t{ 0x8086, 0x244A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x244B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x248A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x248B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x24C1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x24CA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t{ 0x8086, 0x24CB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x24DB, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x245B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x25A2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x266F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\t \n\t{ 0x8086, 0x27DF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100_nomwdma1 },\n\t{ 0x8086, 0x269E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100_nomwdma1 },\n\t \n\t{ 0x8086, 0x2850, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich_pata_100 },\n\n\t \n\n\t \n\t{ 0x8086, 0x24d1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },\n\t \n\t{ 0x8086, 0x24df, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },\n\t \n\t{ 0x8086, 0x25a3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },\n\t \n\t{ 0x8086, 0x25b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },\n\t \n\t{ 0x8086, 0x2651, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich6_sata },\n\t \n\t{ 0x8086, 0x2652, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich6_sata },\n\t \n\t{ 0x8086, 0x2653, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_STORAGE_IDE << 8, 0xffff00, ich6m_sata },\n\t \n\t{ 0x8086, 0x27c0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich6_sata },\n\t \n\t{ 0x8086, 0x27c4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich6m_sata },\n\t \n\t{ 0x8086, 0x2680, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich6_sata },\n\t \n\t{ 0x8086, 0x2820, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x2825, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x2828, 0x106b, 0x00a0, 0, 0, ich8m_apple_sata },\n\t{ 0x8086, 0x2828, 0x106b, 0x00a1, 0, 0, ich8m_apple_sata },\n\t{ 0x8086, 0x2828, 0x106b, 0x00a3, 0, 0, ich8m_apple_sata },\n\t \n\t{ 0x8086, 0x2828, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x2920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x2921, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x2926, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x2928, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x292d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x292e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x5028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, tolapai_sata },\n\t \n\t{ 0x8086, 0x3a00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x3a06, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x3a20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x3a26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x3b20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x3b21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x3b26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x3b28, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x3b2d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x3b2e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata },\n\t \n\t{ 0x8086, 0x1c00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1c01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1c08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x1c09, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x1d00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1d08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x1e00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1e01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1e08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x1e09, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x8c00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x8c01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x8c08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata_snb },\n\t \n\t{ 0x8086, 0x8c09, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x9c00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x9c01, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x9c08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x9c09, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x2326, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x1f20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1f21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x1f30, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x1f31, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x8d00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x8d08, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata_snb },\n\t \n\t{ 0x8086, 0x8d60, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x8d68, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x0F20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata_byt },\n\t{ 0x8086, 0x0F21, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata_byt },\n\t \n\t{ 0x8086, 0x23a6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },\n\t \n\t{ 0x8086, 0x8c88, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata_snb },\n\t \n\t{ 0x8086, 0x8c89, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata_snb },\n\t \n\t{ 0x8086, 0x8c80, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\t \n\t{ 0x8086, 0x8c81, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_sata_snb },\n\n\t{ }\t \n};\n\nstatic const struct piix_map_db ich5_map_db = {\n\t.mask = 0x7,\n\t.port_enable = 0x3,\n\t.map = {\n\t\t \n\t\t{  P0,  NA,  P1,  NA },  \n\t\t{  P1,  NA,  P0,  NA },  \n\t\t{  RV,  RV,  RV,  RV },\n\t\t{  RV,  RV,  RV,  RV },\n\t\t{  P0,  P1, IDE, IDE },  \n\t\t{  P1,  P0, IDE, IDE },  \n\t\t{ IDE, IDE,  P0,  P1 },  \n\t\t{ IDE, IDE,  P1,  P0 },  \n\t},\n};\n\nstatic const struct piix_map_db ich6_map_db = {\n\t.mask = 0x3,\n\t.port_enable = 0xf,\n\t.map = {\n\t\t \n\t\t{  P0,  P2,  P1,  P3 },  \n\t\t{ IDE, IDE,  P1,  P3 },  \n\t\t{  P0,  P2, IDE, IDE },  \n\t\t{  RV,  RV,  RV,  RV },\n\t},\n};\n\nstatic const struct piix_map_db ich6m_map_db = {\n\t.mask = 0x3,\n\t.port_enable = 0x5,\n\n\t \n\t.map = {\n\t\t \n\t\t{  P0,  P2,  NA,  NA },  \n\t\t{ IDE, IDE,  P1,  P3 },  \n\t\t{  P0,  P2, IDE, IDE },  \n\t\t{  RV,  RV,  RV,  RV },\n\t},\n};\n\nstatic const struct piix_map_db ich8_map_db = {\n\t.mask = 0x3,\n\t.port_enable = 0xf,\n\t.map = {\n\t\t \n\t\t{  P0,  P2,  P1,  P3 },  \n\t\t{  RV,  RV,  RV,  RV },\n\t\t{  P0,  P2, IDE, IDE },  \n\t\t{  RV,  RV,  RV,  RV },\n\t},\n};\n\nstatic const struct piix_map_db ich8_2port_map_db = {\n\t.mask = 0x3,\n\t.port_enable = 0x3,\n\t.map = {\n\t\t \n\t\t{  P0,  NA,  P1,  NA },  \n\t\t{  RV,  RV,  RV,  RV },  \n\t\t{  RV,  RV,  RV,  RV },  \n\t\t{  RV,  RV,  RV,  RV },\n\t},\n};\n\nstatic const struct piix_map_db ich8m_apple_map_db = {\n\t.mask = 0x3,\n\t.port_enable = 0x1,\n\t.map = {\n\t\t \n\t\t{  P0,  NA,  NA,  NA },  \n\t\t{  RV,  RV,  RV,  RV },\n\t\t{  P0,  P2, IDE, IDE },  \n\t\t{  RV,  RV,  RV,  RV },\n\t},\n};\n\nstatic const struct piix_map_db tolapai_map_db = {\n\t.mask = 0x3,\n\t.port_enable = 0x3,\n\t.map = {\n\t\t \n\t\t{  P0,  NA,  P1,  NA },  \n\t\t{  RV,  RV,  RV,  RV },  \n\t\t{  RV,  RV,  RV,  RV },  \n\t\t{  RV,  RV,  RV,  RV },\n\t},\n};\n\nstatic const struct piix_map_db *piix_map_db_table[] = {\n\t[ich5_sata]\t\t= &ich5_map_db,\n\t[ich6_sata]\t\t= &ich6_map_db,\n\t[ich6m_sata]\t\t= &ich6m_map_db,\n\t[ich8_sata]\t\t= &ich8_map_db,\n\t[ich8_2port_sata]\t= &ich8_2port_map_db,\n\t[ich8m_apple_sata]\t= &ich8m_apple_map_db,\n\t[tolapai_sata]\t\t= &tolapai_map_db,\n\t[ich8_sata_snb]\t\t= &ich8_map_db,\n\t[ich8_2port_sata_snb]\t= &ich8_2port_map_db,\n\t[ich8_2port_sata_byt]\t= &ich8_2port_map_db,\n};\n\nstatic const struct pci_bits piix_enable_bits[] = {\n\t{ 0x41U, 1U, 0x80UL, 0x80UL },\t \n\t{ 0x43U, 1U, 0x80UL, 0x80UL },\t \n};\n\nMODULE_AUTHOR(\"Andre Hedrick, Alan Cox, Andrzej Krzysztofowicz, Jeff Garzik\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for Intel PIIX/ICH ATA controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, piix_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n\nstruct ich_laptop {\n\tu16 device;\n\tu16 subvendor;\n\tu16 subdevice;\n};\n\n \n\nstatic const struct ich_laptop ich_laptop[] = {\n\t \n\t{ 0x27DF, 0x0005, 0x0280 },\t \n\t{ 0x27DF, 0x1025, 0x0102 },\t \n\t{ 0x27DF, 0x1025, 0x0110 },\t \n\t{ 0x27DF, 0x1028, 0x02b0 },\t \n\t{ 0x27DF, 0x1043, 0x1267 },\t \n\t{ 0x27DF, 0x103C, 0x30A1 },\t \n\t{ 0x27DF, 0x103C, 0x361a },\t \n\t{ 0x27DF, 0x1071, 0xD221 },\t \n\t{ 0x27DF, 0x152D, 0x0778 },\t \n\t{ 0x24CA, 0x1025, 0x0061 },\t \n\t{ 0x24CA, 0x1025, 0x003d },\t \n\t{ 0x24CA, 0x10CF, 0x11AB },\t \n\t{ 0x266F, 0x1025, 0x0066 },\t \n\t{ 0x2653, 0x1043, 0x82D8 },\t \n\t{ 0x27df, 0x104d, 0x900e },\t \n\t \n\t{ 0, }\n};\n\nstatic int piix_port_start(struct ata_port *ap)\n{\n\tif (!(ap->flags & PIIX_FLAG_PIO16))\n\t\tap->pflags |= ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE;\n\n\treturn ata_bmdma_port_start(ap);\n}\n\n \n\nstatic int ich_pata_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct piix_host_priv *hpriv = ap->host->private_data;\n\tconst struct ich_laptop *lap = &ich_laptop[0];\n\tu8 mask;\n\n\t \n\twhile (lap->device) {\n\t\tif (lap->device == pdev->device &&\n\t\t    lap->subvendor == pdev->subsystem_vendor &&\n\t\t    lap->subdevice == pdev->subsystem_device)\n\t\t\treturn ATA_CBL_PATA40_SHORT;\n\n\t\tlap++;\n\t}\n\n\t \n\tmask = ap->port_no == 0 ? PIIX_80C_PRI : PIIX_80C_SEC;\n\tif ((hpriv->saved_iocfg & mask) == 0)\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\n \nstatic int piix_pata_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tif (!pci_test_config_bits(pdev, &piix_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic DEFINE_SPINLOCK(piix_lock);\n\nstatic void piix_set_timings(struct ata_port *ap, struct ata_device *adev,\n\t\t\t     u8 pio)\n{\n\tstruct pci_dev *dev\t= to_pci_dev(ap->host->dev);\n\tunsigned long flags;\n\tunsigned int is_slave\t= (adev->devno != 0);\n\tunsigned int master_port= ap->port_no ? 0x42 : 0x40;\n\tunsigned int slave_port\t= 0x44;\n\tu16 master_data;\n\tu8 slave_data;\n\tu8 udma_enable;\n\tint control = 0;\n\n\t \n\n\tstatic const\t  \n\tu8 timings[][2]\t= { { 0, 0 },\n\t\t\t    { 0, 0 },\n\t\t\t    { 1, 0 },\n\t\t\t    { 2, 1 },\n\t\t\t    { 2, 3 }, };\n\n\tif (pio >= 2)\n\t\tcontrol |= 1;\t \n\tif (ata_pio_need_iordy(adev))\n\t\tcontrol |= 2;\t \n\t \n\tif (adev->class == ATA_DEV_ATA)\n\t\tcontrol |= 4;\t \n\t \n\tif (adev->pio_mode < XFER_PIO_0 + pio)\n\t\t \n\t\tcontrol |= 8;\t \n\n\tspin_lock_irqsave(&piix_lock, flags);\n\n\t \n\tpci_read_config_word(dev, master_port, &master_data);\n\tif (is_slave) {\n\t\t \n\t\tmaster_data &= 0xff0f;\n\t\t \n\t\tmaster_data |= (control << 4);\n\t\tpci_read_config_byte(dev, slave_port, &slave_data);\n\t\tslave_data &= (ap->port_no ? 0x0f : 0xf0);\n\t\t \n\t\tslave_data |= ((timings[pio][0] << 2) | timings[pio][1])\n\t\t\t\t\t\t<< (ap->port_no ? 4 : 0);\n\t} else {\n\t\t \n\t\tmaster_data &= 0xccf0;\n\t\t \n\t\tmaster_data |= control;\n\t\t \n\t\tmaster_data |=\n\t\t\t(timings[pio][0] << 12) |\n\t\t\t(timings[pio][1] << 8);\n\t}\n\n\t \n\tmaster_data |= 0x4000;\n\tpci_write_config_word(dev, master_port, master_data);\n\tif (is_slave)\n\t\tpci_write_config_byte(dev, slave_port, slave_data);\n\n\t \n\n\tif (ap->udma_mask) {\n\t\tpci_read_config_byte(dev, 0x48, &udma_enable);\n\t\tudma_enable &= ~(1 << (2 * ap->port_no + adev->devno));\n\t\tpci_write_config_byte(dev, 0x48, udma_enable);\n\t}\n\n\tspin_unlock_irqrestore(&piix_lock, flags);\n}\n\n \n\nstatic void piix_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tpiix_set_timings(ap, adev, adev->pio_mode - XFER_PIO_0);\n}\n\n \n\nstatic void do_pata_set_dmamode(struct ata_port *ap, struct ata_device *adev, int isich)\n{\n\tstruct pci_dev *dev\t= to_pci_dev(ap->host->dev);\n\tunsigned long flags;\n\tu8 speed\t\t= adev->dma_mode;\n\tint devid\t\t= adev->devno + 2 * ap->port_no;\n\tu8 udma_enable\t\t= 0;\n\n\tif (speed >= XFER_UDMA_0) {\n\t\tunsigned int udma = speed - XFER_UDMA_0;\n\t\tu16 udma_timing;\n\t\tu16 ideconf;\n\t\tint u_clock, u_speed;\n\n\t\tspin_lock_irqsave(&piix_lock, flags);\n\n\t\tpci_read_config_byte(dev, 0x48, &udma_enable);\n\n\t\t \n\t\tu_speed = min(2 - (udma & 1), udma);\n\t\tif (udma == 5)\n\t\t\tu_clock = 0x1000;\t \n\t\telse if (udma > 2)\n\t\t\tu_clock = 1;\t\t \n\t\telse\n\t\t\tu_clock = 0;\t\t \n\n\t\tudma_enable |= (1 << devid);\n\n\t\t \n\t\tpci_read_config_word(dev, 0x4A, &udma_timing);\n\t\tudma_timing &= ~(3 << (4 * devid));\n\t\tudma_timing |= u_speed << (4 * devid);\n\t\tpci_write_config_word(dev, 0x4A, udma_timing);\n\n\t\tif (isich) {\n\t\t\t \n\t\t\tpci_read_config_word(dev, 0x54, &ideconf);\n\t\t\tideconf &= ~(0x1001 << devid);\n\t\t\tideconf |= u_clock << devid;\n\t\t\t \n\t\t\tpci_write_config_word(dev, 0x54, ideconf);\n\t\t}\n\n\t\tpci_write_config_byte(dev, 0x48, udma_enable);\n\n\t\tspin_unlock_irqrestore(&piix_lock, flags);\n\t} else {\n\t\t \n\t\tunsigned int mwdma = speed - XFER_MW_DMA_0;\n\t\tconst unsigned int needed_pio[3] = {\n\t\t\tXFER_PIO_0, XFER_PIO_3, XFER_PIO_4\n\t\t};\n\t\tint pio = needed_pio[mwdma] - XFER_PIO_0;\n\n\t\t \n\t\tpiix_set_timings(ap, adev, pio);\n\t}\n}\n\n \n\nstatic void piix_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tdo_pata_set_dmamode(ap, adev, 0);\n}\n\n \n\nstatic void ich_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tdo_pata_set_dmamode(ap, adev, 1);\n}\n\n \nstatic const int piix_sidx_map[] = {\n\t[SCR_STATUS]\t= 0,\n\t[SCR_ERROR]\t= 2,\n\t[SCR_CONTROL]\t= 1,\n};\n\nstatic void piix_sidpr_sel(struct ata_link *link, unsigned int reg)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct piix_host_priv *hpriv = ap->host->private_data;\n\n\tiowrite32(((ap->port_no * 2 + link->pmp) << 8) | piix_sidx_map[reg],\n\t\t  hpriv->sidpr + PIIX_SIDPR_IDX);\n}\n\nstatic int piix_sidpr_scr_read(struct ata_link *link,\n\t\t\t       unsigned int reg, u32 *val)\n{\n\tstruct piix_host_priv *hpriv = link->ap->host->private_data;\n\n\tif (reg >= ARRAY_SIZE(piix_sidx_map))\n\t\treturn -EINVAL;\n\n\tpiix_sidpr_sel(link, reg);\n\t*val = ioread32(hpriv->sidpr + PIIX_SIDPR_DATA);\n\treturn 0;\n}\n\nstatic int piix_sidpr_scr_write(struct ata_link *link,\n\t\t\t\tunsigned int reg, u32 val)\n{\n\tstruct piix_host_priv *hpriv = link->ap->host->private_data;\n\n\tif (reg >= ARRAY_SIZE(piix_sidx_map))\n\t\treturn -EINVAL;\n\n\tpiix_sidpr_sel(link, reg);\n\tiowrite32(val, hpriv->sidpr + PIIX_SIDPR_DATA);\n\treturn 0;\n}\n\nstatic int piix_sidpr_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\t      unsigned hints)\n{\n\treturn sata_link_scr_lpm(link, policy, false);\n}\n\nstatic bool piix_irq_check(struct ata_port *ap)\n{\n\tunsigned char host_stat;\n\n\tif (unlikely(!ap->ioaddr.bmdma_addr))\n\t\treturn false;\n\n\thost_stat = ap->ops->bmdma_status(ap);\n\ttrace_ata_bmdma_status(ap, host_stat);\n\n\treturn host_stat & ATA_DMA_INTR;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int piix_broken_suspend(void)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t{\n\t\t\t.ident = \"TECRA M3\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TECRA M3\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M3\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Tecra M3\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M3\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_OEM_STRING, \"Tecra M3,\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M4\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Tecra M4\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M4\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TECRA M4\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M5\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TECRA M5\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M6\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TECRA M6\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA M7\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TECRA M7\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"TECRA A8\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TECRA A8\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite R20\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite R20\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite R25\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite R25\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite U200\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite U200\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite U200\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SATELLITE U200\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite Pro U200\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SATELLITE PRO U200\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite U205\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite U205\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"SATELLITE U205\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SATELLITE U205\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Satellite Pro A120\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Satellite Pro A120\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"Portege M500\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PORTEGE M500\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t.ident = \"VGN-BX297XP\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-BX297XP\"),\n\t\t\t},\n\t\t},\n\n\t\t{ }\t \n\t};\n\n\tif (dmi_check_system(sysids))\n\t\treturn 1;\n\n\t \n\tif (dmi_match(DMI_SYS_VENDOR, \"TOSHIBA\") &&\n\t    dmi_match(DMI_PRODUCT_NAME, \"000000\") &&\n\t    dmi_match(DMI_PRODUCT_VERSION, \"000000\") &&\n\t    dmi_match(DMI_PRODUCT_SERIAL, \"000000\") &&\n\t    dmi_match(DMI_BOARD_VENDOR, \"TOSHIBA\") &&\n\t    dmi_match(DMI_BOARD_NAME, \"Portable PC\") &&\n\t    dmi_match(DMI_BOARD_VERSION, \"Version A0\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int piix_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tata_host_suspend(host, mesg);\n\n\t \n\tif (piix_broken_suspend() && (mesg.event & PM_EVENT_SLEEP)) {\n\t\tpci_save_state(pdev);\n\n\t\t \n\t\tif (pdev->current_state == PCI_D0)\n\t\t\tpdev->current_state = PCI_UNKNOWN;\n\n\t\t \n\t\tspin_lock_irqsave(&host->lock, flags);\n\t\thost->flags |= PIIX_HOST_BROKEN_SUSPEND;\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t} else\n\t\tata_pci_device_do_suspend(pdev, mesg);\n\n\treturn 0;\n}\n\nstatic int piix_pci_device_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\tint rc;\n\n\tif (host->flags & PIIX_HOST_BROKEN_SUSPEND) {\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t\thost->flags &= ~PIIX_HOST_BROKEN_SUSPEND;\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\tpci_set_power_state(pdev, PCI_D0);\n\t\tpci_restore_state(pdev);\n\n\t\t \n\t\trc = pci_reenable_device(pdev);\n\t\tif (rc)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to enable device after resume (%d)\\n\",\n\t\t\t\trc);\n\t} else\n\t\trc = ata_pci_device_do_resume(pdev);\n\n\tif (rc == 0)\n\t\tata_host_resume(host);\n\n\treturn rc;\n}\n#endif\n\nstatic u8 piix_vmw_bmdma_status(struct ata_port *ap)\n{\n\treturn ata_bmdma_status(ap) & ~ATA_DMA_ERR;\n}\n\nstatic const struct scsi_host_template piix_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations piix_sata_ops = {\n\t.inherits\t\t= &ata_bmdma32_port_ops,\n\t.sff_irq_check\t\t= piix_irq_check,\n\t.port_start\t\t= piix_port_start,\n};\n\nstatic struct ata_port_operations piix_pata_ops = {\n\t.inherits\t\t= &piix_sata_ops,\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= piix_set_piomode,\n\t.set_dmamode\t\t= piix_set_dmamode,\n\t.prereset\t\t= piix_pata_prereset,\n};\n\nstatic struct ata_port_operations piix_vmw_ops = {\n\t.inherits\t\t= &piix_pata_ops,\n\t.bmdma_status\t\t= piix_vmw_bmdma_status,\n};\n\nstatic struct ata_port_operations ich_pata_ops = {\n\t.inherits\t\t= &piix_pata_ops,\n\t.cable_detect\t\t= ich_pata_cable_detect,\n\t.set_dmamode\t\t= ich_set_dmamode,\n};\n\nstatic struct attribute *piix_sidpr_shost_attrs[] = {\n\t&dev_attr_link_power_management_policy.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(piix_sidpr_shost);\n\nstatic const struct scsi_host_template piix_sidpr_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n\t.shost_groups\t\t= piix_sidpr_shost_groups,\n};\n\nstatic struct ata_port_operations piix_sidpr_sata_ops = {\n\t.inherits\t\t= &piix_sata_ops,\n\t.hardreset\t\t= sata_std_hardreset,\n\t.scr_read\t\t= piix_sidpr_scr_read,\n\t.scr_write\t\t= piix_sidpr_scr_write,\n\t.set_lpm\t\t= piix_sidpr_set_lpm,\n};\n\nstatic struct ata_port_info piix_port_info[] = {\n\t[piix_pata_mwdma] =\t \n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA12_ONLY,  \n\t\t.port_ops\t= &piix_pata_ops,\n\t},\n\n\t[piix_pata_33] =\t \n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA12_ONLY,  \n\t\t.udma_mask\t= ATA_UDMA2,\n\t\t.port_ops\t= &piix_pata_ops,\n\t},\n\n\t[ich_pata_33] =\t\t \n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA12_ONLY,  \n\t\t.udma_mask\t= ATA_UDMA2,\n\t\t.port_ops\t= &ich_pata_ops,\n\t},\n\n\t[ich_pata_66] =\t\t \n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA12_ONLY,  \n\t\t.udma_mask\t= ATA_UDMA4,\n\t\t.port_ops\t= &ich_pata_ops,\n\t},\n\n\t[ich_pata_100] =\n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS | PIIX_FLAG_CHECKINTR,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA12_ONLY,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &ich_pata_ops,\n\t},\n\n\t[ich_pata_100_nomwdma1] =\n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS | PIIX_FLAG_CHECKINTR,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2_ONLY,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &ich_pata_ops,\n\t},\n\n\t[ich5_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich6_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich6m_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich8_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS | PIIX_FLAG_SIDPR,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich8_2port_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS | PIIX_FLAG_SIDPR,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[tolapai_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich8m_apple_sata] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[piix_pata_vmw] =\n\t{\n\t\t.flags\t\t= PIIX_PATA_FLAGS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA12_ONLY,  \n\t\t.udma_mask\t= ATA_UDMA2,\n\t\t.port_ops\t= &piix_vmw_ops,\n\t},\n\n\t \n\t[ich8_sata_snb] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS | PIIX_FLAG_SIDPR | PIIX_FLAG_PIO16,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich8_2port_sata_snb] =\n\t{\n\t\t.flags\t\t= PIIX_SATA_FLAGS | PIIX_FLAG_SIDPR\n\t\t\t\t\t| PIIX_FLAG_PIO16,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &piix_sata_ops,\n\t},\n\n\t[ich8_2port_sata_byt] =\n\t{\n\t\t.flags          = PIIX_SATA_FLAGS | PIIX_FLAG_SIDPR | PIIX_FLAG_PIO16,\n\t\t.pio_mask       = ATA_PIO4,\n\t\t.mwdma_mask     = ATA_MWDMA2,\n\t\t.udma_mask      = ATA_UDMA6,\n\t\t.port_ops       = &piix_sata_ops,\n\t},\n\n};\n\n#define AHCI_PCI_BAR 5\n#define AHCI_GLOBAL_CTL 0x04\n#define AHCI_ENABLE (1 << 31)\nstatic int piix_disable_ahci(struct pci_dev *pdev)\n{\n\tvoid __iomem *mmio;\n\tu32 tmp;\n\tint rc = 0;\n\n\t \n\n\tif (!pci_resource_start(pdev, AHCI_PCI_BAR) ||\n\t    !pci_resource_len(pdev, AHCI_PCI_BAR))\n\t\treturn 0;\n\n\tmmio = pci_iomap(pdev, AHCI_PCI_BAR, 64);\n\tif (!mmio)\n\t\treturn -ENOMEM;\n\n\ttmp = ioread32(mmio + AHCI_GLOBAL_CTL);\n\tif (tmp & AHCI_ENABLE) {\n\t\ttmp &= ~AHCI_ENABLE;\n\t\tiowrite32(tmp, mmio + AHCI_GLOBAL_CTL);\n\n\t\ttmp = ioread32(mmio + AHCI_GLOBAL_CTL);\n\t\tif (tmp & AHCI_ENABLE)\n\t\t\trc = -EIO;\n\t}\n\n\tpci_iounmap(pdev, mmio);\n\treturn rc;\n}\n\n \n\nstatic int piix_check_450nx_errata(struct pci_dev *ata_dev)\n{\n\tstruct pci_dev *pdev = NULL;\n\tu16 cfg;\n\tint no_piix_dma = 0;\n\n\twhile ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454NX, pdev)) != NULL) {\n\t\t \n\t\tpci_read_config_word(pdev, 0x41, &cfg);\n\t\t \n\t\tif (pdev->revision == 0x00)\n\t\t\tno_piix_dma = 1;\n\t\t \n\t\telse if (cfg & (1<<14) && pdev->revision < 5)\n\t\t\tno_piix_dma = 2;\n\t}\n\tif (no_piix_dma)\n\t\tdev_warn(&ata_dev->dev,\n\t\t\t \"450NX errata present, disabling IDE DMA%s\\n\",\n\t\t\t no_piix_dma == 2 ? \" - a BIOS update may resolve this\"\n\t\t\t : \"\");\n\n\treturn no_piix_dma;\n}\n\nstatic void piix_init_pcs(struct ata_host *host,\n\t\t\t  const struct piix_map_db *map_db)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tu16 pcs, new_pcs;\n\n\tpci_read_config_word(pdev, ICH5_PCS, &pcs);\n\n\tnew_pcs = pcs | map_db->port_enable;\n\n\tif (new_pcs != pcs) {\n\t\tpci_write_config_word(pdev, ICH5_PCS, new_pcs);\n\t\tmsleep(150);\n\t}\n}\n\nstatic const int *piix_init_sata_map(struct pci_dev *pdev,\n\t\t\t\t     struct ata_port_info *pinfo,\n\t\t\t\t     const struct piix_map_db *map_db)\n{\n\tconst int *map;\n\tint i, invalid_map = 0;\n\tu8 map_value;\n\tchar buf[32];\n\tchar *p = buf, *end = buf + sizeof(buf);\n\n\tpci_read_config_byte(pdev, ICH5_PMR, &map_value);\n\n\tmap = map_db->map[map_value & map_db->mask];\n\n\tfor (i = 0; i < 4; i++) {\n\t\tswitch (map[i]) {\n\t\tcase RV:\n\t\t\tinvalid_map = 1;\n\t\t\tp += scnprintf(p, end - p, \" XX\");\n\t\t\tbreak;\n\n\t\tcase NA:\n\t\t\tp += scnprintf(p, end - p, \" --\");\n\t\t\tbreak;\n\n\t\tcase IDE:\n\t\t\tWARN_ON((i & 1) || map[i + 1] != IDE);\n\t\t\tpinfo[i / 2] = piix_port_info[ich_pata_100];\n\t\t\ti++;\n\t\t\tp += scnprintf(p, end - p, \" IDE IDE\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tp += scnprintf(p, end - p, \" P%d\", map[i]);\n\t\t\tif (i & 1)\n\t\t\t\tpinfo[i / 2].flags |= ATA_FLAG_SLAVE_POSS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdev_info(&pdev->dev, \"MAP [%s ]\\n\", buf);\n\n\tif (invalid_map)\n\t\tdev_err(&pdev->dev, \"invalid MAP value %u\\n\", map_value);\n\n\treturn map;\n}\n\nstatic bool piix_no_sidpr(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2920 &&\n\t    pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG &&\n\t    pdev->subsystem_device == 0xb049) {\n\t\tdev_warn(host->dev,\n\t\t\t \"Samsung DB-P70 detected, disabling SIDPR\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int piix_init_sidpr(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tstruct piix_host_priv *hpriv = host->private_data;\n\tstruct ata_link *link0 = &host->ports[0]->link;\n\tu32 scontrol;\n\tint i, rc;\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tif (hpriv->map[i] == IDE)\n\t\t\treturn 0;\n\n\t \n\tif (piix_no_sidpr(host))\n\t\treturn 0;\n\n\tif (!(host->ports[0]->flags & PIIX_FLAG_SIDPR))\n\t\treturn 0;\n\n\tif (pci_resource_start(pdev, PIIX_SIDPR_BAR) == 0 ||\n\t    pci_resource_len(pdev, PIIX_SIDPR_BAR) != PIIX_SIDPR_LEN)\n\t\treturn 0;\n\n\tif (pcim_iomap_regions(pdev, 1 << PIIX_SIDPR_BAR, DRV_NAME))\n\t\treturn 0;\n\n\thpriv->sidpr = pcim_iomap_table(pdev)[PIIX_SIDPR_BAR];\n\n\t \n\tpiix_sidpr_scr_read(link0, SCR_CONTROL, &scontrol);\n\n\t \n\tif ((scontrol & 0xf00) != 0x300) {\n\t\tscontrol |= 0x300;\n\t\tpiix_sidpr_scr_write(link0, SCR_CONTROL, scontrol);\n\t\tpiix_sidpr_scr_read(link0, SCR_CONTROL, &scontrol);\n\n\t\tif ((scontrol & 0xf00) != 0x300) {\n\t\t\tdev_info(host->dev,\n\t\t\t\t \"SCR access via SIDPR is available but doesn't work\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tap->ops = &piix_sidpr_sata_ops;\n\n\t\tif (ap->flags & ATA_FLAG_SLAVE_POSS) {\n\t\t\trc = ata_slave_link_init(ap);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void piix_iocfg_bit18_quirk(struct ata_host *host)\n{\n\tstatic const struct dmi_system_id sysids[] = {\n\t\t{\n\t\t\t \n\t\t\t.ident = \"M570U\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Clevo Co.\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"M570U\"),\n\t\t\t},\n\t\t},\n\n\t\t{ }\t \n\t};\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tstruct piix_host_priv *hpriv = host->private_data;\n\n\tif (!dmi_check_system(sysids))\n\t\treturn;\n\n\t \n\tif (hpriv->saved_iocfg & (1 << 18)) {\n\t\tdev_info(&pdev->dev, \"applying IOCFG bit18 quirk\\n\");\n\t\tpci_write_config_dword(pdev, PIIX_IOCFG,\n\t\t\t\t       hpriv->saved_iocfg & ~(1 << 18));\n\t}\n}\n\nstatic bool piix_broken_system_poweroff(struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id broken_systems[] = {\n\t\t{\n\t\t\t.ident = \"HP Compaq 2510p\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq 2510p\"),\n\t\t\t},\n\t\t\t \n\t\t\t.driver_data = (void *)0x1FUL,\n\t\t},\n\t\t{\n\t\t\t.ident = \"HP Compaq nc6000\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq nc6000\"),\n\t\t\t},\n\t\t\t \n\t\t\t.driver_data = (void *)0x1FUL,\n\t\t},\n\n\t\t{ }\t \n\t};\n\tconst struct dmi_system_id *dmi = dmi_first_match(broken_systems);\n\n\tif (dmi) {\n\t\tunsigned long slot = (unsigned long)dmi->driver_data;\n\t\t \n\t\treturn slot == PCI_SLOT(pdev->devfn);\n\t}\n\n\treturn false;\n}\n\nstatic int prefer_ms_hyperv = 1;\nmodule_param(prefer_ms_hyperv, int, 0);\nMODULE_PARM_DESC(prefer_ms_hyperv,\n\t\"Prefer Hyper-V paravirtualization drivers instead of ATA, \"\n\t\"0 - Use ATA drivers, \"\n\t\"1 (Default) - Use the paravirtualization drivers.\");\n\nstatic void piix_ignore_devices_quirk(struct ata_host *host)\n{\n#if IS_ENABLED(CONFIG_HYPERV_STORAGE)\n\tstatic const struct dmi_system_id ignore_hyperv[] = {\n\t\t{\n\t\t\t \n\t\t\t.ident = \"Hyper-V Virtual Machine\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t\t\"Microsoft Corporation\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Virtual Machine\"),\n\t\t\t},\n\t\t},\n\t\t{ }\t \n\t};\n\tstatic const struct dmi_system_id allow_virtual_pc[] = {\n\t\t{\n\t\t\t \n\t\t\t.ident = \"MS Virtual PC 2007\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\t\t\"Microsoft Corporation\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Virtual Machine\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"VS2005R2\"),\n\t\t\t},\n\t\t},\n\t\t{ }\t \n\t};\n\tconst struct dmi_system_id *ignore = dmi_first_match(ignore_hyperv);\n\tconst struct dmi_system_id *allow = dmi_first_match(allow_virtual_pc);\n\n\tif (ignore && !allow && prefer_ms_hyperv) {\n\t\thost->flags |= ATA_HOST_IGNORE_ATA;\n\t\tdev_info(host->dev, \"%s detected, ATA device ignore set\\n\",\n\t\t\tignore->ident);\n\t}\n#endif\n}\n\n \n\nstatic int piix_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ata_port_info port_info[2];\n\tconst struct ata_port_info *ppi[] = { &port_info[0], &port_info[1] };\n\tconst struct scsi_host_template *sht = &piix_sht;\n\tunsigned long port_flags;\n\tstruct ata_host *host;\n\tstruct piix_host_priv *hpriv;\n\tint rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\tif (!in_module_init && ent->driver_data >= ich5_sata)\n\t\treturn -ENODEV;\n\n\tif (piix_broken_system_poweroff(pdev)) {\n\t\tpiix_port_info[ent->driver_data].flags |=\n\t\t\t\tATA_FLAG_NO_POWEROFF_SPINDOWN |\n\t\t\t\t\tATA_FLAG_NO_HIBERNATE_SPINDOWN;\n\t\tdev_info(&pdev->dev, \"quirky BIOS, skipping spindown \"\n\t\t\t\t\"on poweroff and hibernation\\n\");\n\t}\n\n\tport_info[0] = piix_port_info[ent->driver_data];\n\tport_info[1] = piix_port_info[ent->driver_data];\n\n\tport_flags = port_info[0].flags;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\n\t \n\tpci_read_config_dword(pdev, PIIX_IOCFG, &hpriv->saved_iocfg);\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2652) {\n\t\trc = piix_disable_ahci(pdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (port_flags & ATA_FLAG_SATA)\n\t\thpriv->map = piix_init_sata_map(pdev, port_info,\n\t\t\t\t\tpiix_map_db_table[ent->driver_data]);\n\n\trc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\n\tif (rc)\n\t\treturn rc;\n\thost->private_data = hpriv;\n\n\t \n\tif (port_flags & ATA_FLAG_SATA) {\n\t\tpiix_init_pcs(host, piix_map_db_table[ent->driver_data]);\n\t\trc = piix_init_sidpr(host);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (host->ports[0]->ops == &piix_sidpr_sata_ops)\n\t\t\tsht = &piix_sidpr_sht;\n\t}\n\n\t \n\tpiix_iocfg_bit18_quirk(host);\n\n\t \n\tif (port_flags & PIIX_FLAG_CHECKINTR)\n\t\tpci_intx(pdev, 1);\n\n\tif (piix_check_450nx_errata(pdev)) {\n\t\t \n\t\thost->ports[0]->mwdma_mask = 0;\n\t\thost->ports[0]->udma_mask = 0;\n\t\thost->ports[1]->mwdma_mask = 0;\n\t\thost->ports[1]->udma_mask = 0;\n\t}\n\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n\n\t \n\tpiix_ignore_devices_quirk(host);\n\n\tpci_set_master(pdev);\n\treturn ata_pci_sff_activate_host(host, ata_bmdma_interrupt, sht);\n}\n\nstatic void piix_remove_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tstruct piix_host_priv *hpriv = host->private_data;\n\n\tpci_write_config_dword(pdev, PIIX_IOCFG, hpriv->saved_iocfg);\n\n\tata_pci_remove_one(pdev);\n}\n\nstatic struct pci_driver piix_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= piix_pci_tbl,\n\t.probe\t\t\t= piix_init_one,\n\t.remove\t\t\t= piix_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= piix_pci_device_suspend,\n\t.resume\t\t\t= piix_pci_device_resume,\n#endif\n};\n\nstatic int __init piix_init(void)\n{\n\tint rc;\n\n\trc = pci_register_driver(&piix_pci_driver);\n\tif (rc)\n\t\treturn rc;\n\n\tin_module_init = 0;\n\n\treturn 0;\n}\n\nstatic void __exit piix_exit(void)\n{\n\tpci_unregister_driver(&piix_pci_driver);\n}\n\nmodule_init(piix_init);\nmodule_exit(piix_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}