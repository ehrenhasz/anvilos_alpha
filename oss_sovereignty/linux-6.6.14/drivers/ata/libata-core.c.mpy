{
  "module_name": "libata-core.c",
  "hash_id": "948fbf2dd9089fa8a1fb27841f3f1431815499f03f43aede2b69cf35a9f6537e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/suspend.h>\n#include <linux/workqueue.h>\n#include <linux/scatterlist.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/glob.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/cdrom.h>\n#include <linux/ratelimit.h>\n#include <linux/leds.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <asm/setup.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/libata.h>\n\n#include \"libata.h\"\n#include \"libata-transport.h\"\n\nconst struct ata_port_operations ata_base_port_ops = {\n\t.prereset\t\t= ata_std_prereset,\n\t.postreset\t\t= ata_std_postreset,\n\t.error_handler\t\t= ata_std_error_handler,\n\t.sched_eh\t\t= ata_std_sched_eh,\n\t.end_eh\t\t\t= ata_std_end_eh,\n};\n\nconst struct ata_port_operations sata_port_ops = {\n\t.inherits\t\t= &ata_base_port_ops,\n\n\t.qc_defer\t\t= ata_std_qc_defer,\n\t.hardreset\t\t= sata_std_hardreset,\n};\nEXPORT_SYMBOL_GPL(sata_port_ops);\n\nstatic unsigned int ata_dev_init_params(struct ata_device *dev,\n\t\t\t\t\tu16 heads, u16 sectors);\nstatic unsigned int ata_dev_set_xfermode(struct ata_device *dev);\nstatic void ata_dev_xfermask(struct ata_device *dev);\nstatic unsigned long ata_dev_blacklisted(const struct ata_device *dev);\n\natomic_t ata_print_id = ATOMIC_INIT(0);\n\n#ifdef CONFIG_ATA_FORCE\nstruct ata_force_param {\n\tconst char\t*name;\n\tu8\t\tcbl;\n\tu8\t\tspd_limit;\n\tunsigned int\txfer_mask;\n\tunsigned int\thorkage_on;\n\tunsigned int\thorkage_off;\n\tu16\t\tlflags_on;\n\tu16\t\tlflags_off;\n};\n\nstruct ata_force_ent {\n\tint\t\t\tport;\n\tint\t\t\tdevice;\n\tstruct ata_force_param\tparam;\n};\n\nstatic struct ata_force_ent *ata_force_tbl;\nstatic int ata_force_tbl_size;\n\nstatic char ata_force_param_buf[COMMAND_LINE_SIZE] __initdata;\n \nmodule_param_string(force, ata_force_param_buf, sizeof(ata_force_param_buf), 0);\nMODULE_PARM_DESC(force, \"Force ATA configurations including cable type, link speed and transfer mode (see Documentation/admin-guide/kernel-parameters.rst for details)\");\n#endif\n\nstatic int atapi_enabled = 1;\nmodule_param(atapi_enabled, int, 0444);\nMODULE_PARM_DESC(atapi_enabled, \"Enable discovery of ATAPI devices (0=off, 1=on [default])\");\n\nstatic int atapi_dmadir = 0;\nmodule_param(atapi_dmadir, int, 0444);\nMODULE_PARM_DESC(atapi_dmadir, \"Enable ATAPI DMADIR bridge support (0=off [default], 1=on)\");\n\nint atapi_passthru16 = 1;\nmodule_param(atapi_passthru16, int, 0444);\nMODULE_PARM_DESC(atapi_passthru16, \"Enable ATA_16 passthru for ATAPI devices (0=off, 1=on [default])\");\n\nint libata_fua = 0;\nmodule_param_named(fua, libata_fua, int, 0444);\nMODULE_PARM_DESC(fua, \"FUA support (0=off [default], 1=on)\");\n\nstatic int ata_ignore_hpa;\nmodule_param_named(ignore_hpa, ata_ignore_hpa, int, 0644);\nMODULE_PARM_DESC(ignore_hpa, \"Ignore HPA limit (0=keep BIOS limits, 1=ignore limits, using full disk)\");\n\nstatic int libata_dma_mask = ATA_DMA_MASK_ATA|ATA_DMA_MASK_ATAPI|ATA_DMA_MASK_CFA;\nmodule_param_named(dma, libata_dma_mask, int, 0444);\nMODULE_PARM_DESC(dma, \"DMA enable/disable (0x1==ATA, 0x2==ATAPI, 0x4==CF)\");\n\nstatic int ata_probe_timeout;\nmodule_param(ata_probe_timeout, int, 0444);\nMODULE_PARM_DESC(ata_probe_timeout, \"Set ATA probing timeout (seconds)\");\n\nint libata_noacpi = 0;\nmodule_param_named(noacpi, libata_noacpi, int, 0444);\nMODULE_PARM_DESC(noacpi, \"Disable the use of ACPI in probe/suspend/resume (0=off [default], 1=on)\");\n\nint libata_allow_tpm = 0;\nmodule_param_named(allow_tpm, libata_allow_tpm, int, 0444);\nMODULE_PARM_DESC(allow_tpm, \"Permit the use of TPM commands (0=off [default], 1=on)\");\n\nstatic int atapi_an;\nmodule_param(atapi_an, int, 0444);\nMODULE_PARM_DESC(atapi_an, \"Enable ATAPI AN media presence notification (0=0ff [default], 1=on)\");\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"Library module for ATA devices\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\nstatic inline bool ata_dev_print_info(struct ata_device *dev)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\n\treturn ehc->i.flags & ATA_EHI_PRINTINFO;\n}\n\nstatic bool ata_sstatus_online(u32 sstatus)\n{\n\treturn (sstatus & 0xf) == 0x3;\n}\n\n \nstruct ata_link *ata_link_next(struct ata_link *link, struct ata_port *ap,\n\t\t\t       enum ata_link_iter_mode mode)\n{\n\tBUG_ON(mode != ATA_LITER_EDGE &&\n\t       mode != ATA_LITER_PMP_FIRST && mode != ATA_LITER_HOST_FIRST);\n\n\t \n\tif (!link)\n\t\tswitch (mode) {\n\t\tcase ATA_LITER_EDGE:\n\t\tcase ATA_LITER_PMP_FIRST:\n\t\t\tif (sata_pmp_attached(ap))\n\t\t\t\treturn ap->pmp_link;\n\t\t\tfallthrough;\n\t\tcase ATA_LITER_HOST_FIRST:\n\t\t\treturn &ap->link;\n\t\t}\n\n\t \n\tif (link == &ap->link)\n\t\tswitch (mode) {\n\t\tcase ATA_LITER_HOST_FIRST:\n\t\t\tif (sata_pmp_attached(ap))\n\t\t\t\treturn ap->pmp_link;\n\t\t\tfallthrough;\n\t\tcase ATA_LITER_PMP_FIRST:\n\t\t\tif (unlikely(ap->slave_link))\n\t\t\t\treturn ap->slave_link;\n\t\t\tfallthrough;\n\t\tcase ATA_LITER_EDGE:\n\t\t\treturn NULL;\n\t\t}\n\n\t \n\tif (unlikely(link == ap->slave_link))\n\t\treturn NULL;\n\n\t \n\tif (++link < ap->pmp_link + ap->nr_pmp_links)\n\t\treturn link;\n\n\tif (mode == ATA_LITER_PMP_FIRST)\n\t\treturn &ap->link;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ata_link_next);\n\n \nstruct ata_device *ata_dev_next(struct ata_device *dev, struct ata_link *link,\n\t\t\t\tenum ata_dev_iter_mode mode)\n{\n\tBUG_ON(mode != ATA_DITER_ENABLED && mode != ATA_DITER_ENABLED_REVERSE &&\n\t       mode != ATA_DITER_ALL && mode != ATA_DITER_ALL_REVERSE);\n\n\t \n\tif (!dev)\n\t\tswitch (mode) {\n\t\tcase ATA_DITER_ENABLED:\n\t\tcase ATA_DITER_ALL:\n\t\t\tdev = link->device;\n\t\t\tgoto check;\n\t\tcase ATA_DITER_ENABLED_REVERSE:\n\t\tcase ATA_DITER_ALL_REVERSE:\n\t\t\tdev = link->device + ata_link_max_devices(link) - 1;\n\t\t\tgoto check;\n\t\t}\n\n next:\n\t \n\tswitch (mode) {\n\tcase ATA_DITER_ENABLED:\n\tcase ATA_DITER_ALL:\n\t\tif (++dev < link->device + ata_link_max_devices(link))\n\t\t\tgoto check;\n\t\treturn NULL;\n\tcase ATA_DITER_ENABLED_REVERSE:\n\tcase ATA_DITER_ALL_REVERSE:\n\t\tif (--dev >= link->device)\n\t\t\tgoto check;\n\t\treturn NULL;\n\t}\n\n check:\n\tif ((mode == ATA_DITER_ENABLED || mode == ATA_DITER_ENABLED_REVERSE) &&\n\t    !ata_dev_enabled(dev))\n\t\tgoto next;\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(ata_dev_next);\n\n \nstruct ata_link *ata_dev_phys_link(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\n\tif (!ap->slave_link)\n\t\treturn dev->link;\n\tif (!dev->devno)\n\t\treturn &ap->link;\n\treturn ap->slave_link;\n}\n\n#ifdef CONFIG_ATA_FORCE\n \nvoid ata_force_cbl(struct ata_port *ap)\n{\n\tint i;\n\n\tfor (i = ata_force_tbl_size - 1; i >= 0; i--) {\n\t\tconst struct ata_force_ent *fe = &ata_force_tbl[i];\n\n\t\tif (fe->port != -1 && fe->port != ap->print_id)\n\t\t\tcontinue;\n\n\t\tif (fe->param.cbl == ATA_CBL_NONE)\n\t\t\tcontinue;\n\n\t\tap->cbl = fe->param.cbl;\n\t\tata_port_notice(ap, \"FORCE: cable set to %s\\n\", fe->param.name);\n\t\treturn;\n\t}\n}\n\n \nstatic void ata_force_link_limits(struct ata_link *link)\n{\n\tbool did_spd = false;\n\tint linkno = link->pmp;\n\tint i;\n\n\tif (ata_is_host_link(link))\n\t\tlinkno += 15;\n\n\tfor (i = ata_force_tbl_size - 1; i >= 0; i--) {\n\t\tconst struct ata_force_ent *fe = &ata_force_tbl[i];\n\n\t\tif (fe->port != -1 && fe->port != link->ap->print_id)\n\t\t\tcontinue;\n\n\t\tif (fe->device != -1 && fe->device != linkno)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!did_spd && fe->param.spd_limit) {\n\t\t\tlink->hw_sata_spd_limit = (1 << fe->param.spd_limit) - 1;\n\t\t\tata_link_notice(link, \"FORCE: PHY spd limit set to %s\\n\",\n\t\t\t\t\tfe->param.name);\n\t\t\tdid_spd = true;\n\t\t}\n\n\t\t \n\t\tif (fe->param.lflags_on) {\n\t\t\tlink->flags |= fe->param.lflags_on;\n\t\t\tata_link_notice(link,\n\t\t\t\t\t\"FORCE: link flag 0x%x forced -> 0x%x\\n\",\n\t\t\t\t\tfe->param.lflags_on, link->flags);\n\t\t}\n\t\tif (fe->param.lflags_off) {\n\t\t\tlink->flags &= ~fe->param.lflags_off;\n\t\t\tata_link_notice(link,\n\t\t\t\t\"FORCE: link flag 0x%x cleared -> 0x%x\\n\",\n\t\t\t\tfe->param.lflags_off, link->flags);\n\t\t}\n\t}\n}\n\n \nstatic void ata_force_xfermask(struct ata_device *dev)\n{\n\tint devno = dev->link->pmp + dev->devno;\n\tint alt_devno = devno;\n\tint i;\n\n\t \n\tif (ata_is_host_link(dev->link))\n\t\talt_devno += 15;\n\n\tfor (i = ata_force_tbl_size - 1; i >= 0; i--) {\n\t\tconst struct ata_force_ent *fe = &ata_force_tbl[i];\n\t\tunsigned int pio_mask, mwdma_mask, udma_mask;\n\n\t\tif (fe->port != -1 && fe->port != dev->link->ap->print_id)\n\t\t\tcontinue;\n\n\t\tif (fe->device != -1 && fe->device != devno &&\n\t\t    fe->device != alt_devno)\n\t\t\tcontinue;\n\n\t\tif (!fe->param.xfer_mask)\n\t\t\tcontinue;\n\n\t\tata_unpack_xfermask(fe->param.xfer_mask,\n\t\t\t\t    &pio_mask, &mwdma_mask, &udma_mask);\n\t\tif (udma_mask)\n\t\t\tdev->udma_mask = udma_mask;\n\t\telse if (mwdma_mask) {\n\t\t\tdev->udma_mask = 0;\n\t\t\tdev->mwdma_mask = mwdma_mask;\n\t\t} else {\n\t\t\tdev->udma_mask = 0;\n\t\t\tdev->mwdma_mask = 0;\n\t\t\tdev->pio_mask = pio_mask;\n\t\t}\n\n\t\tata_dev_notice(dev, \"FORCE: xfer_mask set to %s\\n\",\n\t\t\t       fe->param.name);\n\t\treturn;\n\t}\n}\n\n \nstatic void ata_force_horkage(struct ata_device *dev)\n{\n\tint devno = dev->link->pmp + dev->devno;\n\tint alt_devno = devno;\n\tint i;\n\n\t \n\tif (ata_is_host_link(dev->link))\n\t\talt_devno += 15;\n\n\tfor (i = 0; i < ata_force_tbl_size; i++) {\n\t\tconst struct ata_force_ent *fe = &ata_force_tbl[i];\n\n\t\tif (fe->port != -1 && fe->port != dev->link->ap->print_id)\n\t\t\tcontinue;\n\n\t\tif (fe->device != -1 && fe->device != devno &&\n\t\t    fe->device != alt_devno)\n\t\t\tcontinue;\n\n\t\tif (!(~dev->horkage & fe->param.horkage_on) &&\n\t\t    !(dev->horkage & fe->param.horkage_off))\n\t\t\tcontinue;\n\n\t\tdev->horkage |= fe->param.horkage_on;\n\t\tdev->horkage &= ~fe->param.horkage_off;\n\n\t\tata_dev_notice(dev, \"FORCE: horkage modified (%s)\\n\",\n\t\t\t       fe->param.name);\n\t}\n}\n#else\nstatic inline void ata_force_link_limits(struct ata_link *link) { }\nstatic inline void ata_force_xfermask(struct ata_device *dev) { }\nstatic inline void ata_force_horkage(struct ata_device *dev) { }\n#endif\n\n \nint atapi_cmd_type(u8 opcode)\n{\n\tswitch (opcode) {\n\tcase GPCMD_READ_10:\n\tcase GPCMD_READ_12:\n\t\treturn ATAPI_READ;\n\n\tcase GPCMD_WRITE_10:\n\tcase GPCMD_WRITE_12:\n\tcase GPCMD_WRITE_AND_VERIFY_10:\n\t\treturn ATAPI_WRITE;\n\n\tcase GPCMD_READ_CD:\n\tcase GPCMD_READ_CD_MSF:\n\t\treturn ATAPI_READ_CD;\n\n\tcase ATA_16:\n\tcase ATA_12:\n\t\tif (atapi_passthru16)\n\t\t\treturn ATAPI_PASS_THRU;\n\t\tfallthrough;\n\tdefault:\n\t\treturn ATAPI_MISC;\n\t}\n}\nEXPORT_SYMBOL_GPL(atapi_cmd_type);\n\nstatic const u8 ata_rw_cmds[] = {\n\t \n\tATA_CMD_READ_MULTI,\n\tATA_CMD_WRITE_MULTI,\n\tATA_CMD_READ_MULTI_EXT,\n\tATA_CMD_WRITE_MULTI_EXT,\n\t0,\n\t0,\n\t0,\n\t0,\n\t \n\tATA_CMD_PIO_READ,\n\tATA_CMD_PIO_WRITE,\n\tATA_CMD_PIO_READ_EXT,\n\tATA_CMD_PIO_WRITE_EXT,\n\t0,\n\t0,\n\t0,\n\t0,\n\t \n\tATA_CMD_READ,\n\tATA_CMD_WRITE,\n\tATA_CMD_READ_EXT,\n\tATA_CMD_WRITE_EXT,\n\t0,\n\t0,\n\t0,\n\tATA_CMD_WRITE_FUA_EXT\n};\n\n \nstatic bool ata_set_rwcmd_protocol(struct ata_device *dev,\n\t\t\t\t   struct ata_taskfile *tf)\n{\n\tu8 cmd;\n\n\tint index, fua, lba48, write;\n\n\tfua = (tf->flags & ATA_TFLAG_FUA) ? 4 : 0;\n\tlba48 = (tf->flags & ATA_TFLAG_LBA48) ? 2 : 0;\n\twrite = (tf->flags & ATA_TFLAG_WRITE) ? 1 : 0;\n\n\tif (dev->flags & ATA_DFLAG_PIO) {\n\t\ttf->protocol = ATA_PROT_PIO;\n\t\tindex = dev->multi_count ? 0 : 8;\n\t} else if (lba48 && (dev->link->ap->flags & ATA_FLAG_PIO_LBA48)) {\n\t\t \n\t\ttf->protocol = ATA_PROT_PIO;\n\t\tindex = dev->multi_count ? 0 : 8;\n\t} else {\n\t\ttf->protocol = ATA_PROT_DMA;\n\t\tindex = 16;\n\t}\n\n\tcmd = ata_rw_cmds[index + fua + lba48 + write];\n\tif (!cmd)\n\t\treturn false;\n\n\ttf->command = cmd;\n\n\treturn true;\n}\n\n \nu64 ata_tf_read_block(const struct ata_taskfile *tf, struct ata_device *dev)\n{\n\tu64 block = 0;\n\n\tif (tf->flags & ATA_TFLAG_LBA) {\n\t\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\t\tblock |= (u64)tf->hob_lbah << 40;\n\t\t\tblock |= (u64)tf->hob_lbam << 32;\n\t\t\tblock |= (u64)tf->hob_lbal << 24;\n\t\t} else\n\t\t\tblock |= (tf->device & 0xf) << 24;\n\n\t\tblock |= tf->lbah << 16;\n\t\tblock |= tf->lbam << 8;\n\t\tblock |= tf->lbal;\n\t} else {\n\t\tu32 cyl, head, sect;\n\n\t\tcyl = tf->lbam | (tf->lbah << 8);\n\t\thead = tf->device & 0xf;\n\t\tsect = tf->lbal;\n\n\t\tif (!sect) {\n\t\t\tata_dev_warn(dev,\n\t\t\t\t     \"device reported invalid CHS sector 0\\n\");\n\t\t\treturn U64_MAX;\n\t\t}\n\n\t\tblock = (cyl * dev->heads + head) * dev->sectors + sect - 1;\n\t}\n\n\treturn block;\n}\n\n \nstatic inline void ata_set_tf_cdl(struct ata_queued_cmd *qc, int cdl)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\n\tif (tf->protocol == ATA_PROT_NCQ)\n\t\ttf->auxiliary |= cdl;\n\telse\n\t\ttf->feature |= cdl;\n\n\t \n\tqc->flags |= ATA_QCFLAG_HAS_CDL | ATA_QCFLAG_RESULT_TF;\n}\n\n \nint ata_build_rw_tf(struct ata_queued_cmd *qc, u64 block, u32 n_block,\n\t\t    unsigned int tf_flags, int cdl, int class)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\tstruct ata_device *dev = qc->dev;\n\n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf->flags |= tf_flags;\n\n\tif (ata_ncq_enabled(dev)) {\n\t\t \n\t\tif (!lba_48_ok(block, n_block))\n\t\t\treturn -ERANGE;\n\n\t\ttf->protocol = ATA_PROT_NCQ;\n\t\ttf->flags |= ATA_TFLAG_LBA | ATA_TFLAG_LBA48;\n\n\t\tif (tf->flags & ATA_TFLAG_WRITE)\n\t\t\ttf->command = ATA_CMD_FPDMA_WRITE;\n\t\telse\n\t\t\ttf->command = ATA_CMD_FPDMA_READ;\n\n\t\ttf->nsect = qc->hw_tag << 3;\n\t\ttf->hob_feature = (n_block >> 8) & 0xff;\n\t\ttf->feature = n_block & 0xff;\n\n\t\ttf->hob_lbah = (block >> 40) & 0xff;\n\t\ttf->hob_lbam = (block >> 32) & 0xff;\n\t\ttf->hob_lbal = (block >> 24) & 0xff;\n\t\ttf->lbah = (block >> 16) & 0xff;\n\t\ttf->lbam = (block >> 8) & 0xff;\n\t\ttf->lbal = block & 0xff;\n\n\t\ttf->device = ATA_LBA;\n\t\tif (tf->flags & ATA_TFLAG_FUA)\n\t\t\ttf->device |= 1 << 7;\n\n\t\tif (dev->flags & ATA_DFLAG_NCQ_PRIO_ENABLED &&\n\t\t    class == IOPRIO_CLASS_RT)\n\t\t\ttf->hob_nsect |= ATA_PRIO_HIGH << ATA_SHIFT_PRIO;\n\n\t\tif ((dev->flags & ATA_DFLAG_CDL_ENABLED) && cdl)\n\t\t\tata_set_tf_cdl(qc, cdl);\n\n\t} else if (dev->flags & ATA_DFLAG_LBA) {\n\t\ttf->flags |= ATA_TFLAG_LBA;\n\n\t\tif ((dev->flags & ATA_DFLAG_CDL_ENABLED) && cdl)\n\t\t\tata_set_tf_cdl(qc, cdl);\n\n\t\t \n\t\tif (!(tf->flags & ATA_TFLAG_FUA) &&\n\t\t    !(qc->flags & ATA_QCFLAG_HAS_CDL) &&\n\t\t    lba_28_ok(block, n_block)) {\n\t\t\t \n\t\t\ttf->device |= (block >> 24) & 0xf;\n\t\t} else if (lba_48_ok(block, n_block)) {\n\t\t\tif (!(dev->flags & ATA_DFLAG_LBA48))\n\t\t\t\treturn -ERANGE;\n\n\t\t\t \n\t\t\ttf->flags |= ATA_TFLAG_LBA48;\n\n\t\t\ttf->hob_nsect = (n_block >> 8) & 0xff;\n\n\t\t\ttf->hob_lbah = (block >> 40) & 0xff;\n\t\t\ttf->hob_lbam = (block >> 32) & 0xff;\n\t\t\ttf->hob_lbal = (block >> 24) & 0xff;\n\t\t} else {\n\t\t\t \n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tif (unlikely(!ata_set_rwcmd_protocol(dev, tf)))\n\t\t\treturn -EINVAL;\n\n\t\ttf->nsect = n_block & 0xff;\n\n\t\ttf->lbah = (block >> 16) & 0xff;\n\t\ttf->lbam = (block >> 8) & 0xff;\n\t\ttf->lbal = block & 0xff;\n\n\t\ttf->device |= ATA_LBA;\n\t} else {\n\t\t \n\t\tu32 sect, head, cyl, track;\n\n\t\t \n\t\tif (!lba_28_ok(block, n_block))\n\t\t\treturn -ERANGE;\n\n\t\tif (unlikely(!ata_set_rwcmd_protocol(dev, tf)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\ttrack = (u32)block / dev->sectors;\n\t\tcyl   = track / dev->heads;\n\t\thead  = track % dev->heads;\n\t\tsect  = (u32)block % dev->sectors + 1;\n\n\t\t \n\t\tif ((cyl >> 16) || (head >> 4) || (sect >> 8) || (!sect))\n\t\t\treturn -ERANGE;\n\n\t\ttf->nsect = n_block & 0xff;  \n\t\ttf->lbal = sect;\n\t\ttf->lbam = cyl;\n\t\ttf->lbah = cyl >> 8;\n\t\ttf->device |= head;\n\t}\n\n\treturn 0;\n}\n\n \nunsigned int ata_pack_xfermask(unsigned int pio_mask,\n\t\t\t       unsigned int mwdma_mask,\n\t\t\t       unsigned int udma_mask)\n{\n\treturn\t((pio_mask << ATA_SHIFT_PIO) & ATA_MASK_PIO) |\n\t\t((mwdma_mask << ATA_SHIFT_MWDMA) & ATA_MASK_MWDMA) |\n\t\t((udma_mask << ATA_SHIFT_UDMA) & ATA_MASK_UDMA);\n}\nEXPORT_SYMBOL_GPL(ata_pack_xfermask);\n\n \nvoid ata_unpack_xfermask(unsigned int xfer_mask, unsigned int *pio_mask,\n\t\t\t unsigned int *mwdma_mask, unsigned int *udma_mask)\n{\n\tif (pio_mask)\n\t\t*pio_mask = (xfer_mask & ATA_MASK_PIO) >> ATA_SHIFT_PIO;\n\tif (mwdma_mask)\n\t\t*mwdma_mask = (xfer_mask & ATA_MASK_MWDMA) >> ATA_SHIFT_MWDMA;\n\tif (udma_mask)\n\t\t*udma_mask = (xfer_mask & ATA_MASK_UDMA) >> ATA_SHIFT_UDMA;\n}\n\nstatic const struct ata_xfer_ent {\n\tint shift, bits;\n\tu8 base;\n} ata_xfer_tbl[] = {\n\t{ ATA_SHIFT_PIO, ATA_NR_PIO_MODES, XFER_PIO_0 },\n\t{ ATA_SHIFT_MWDMA, ATA_NR_MWDMA_MODES, XFER_MW_DMA_0 },\n\t{ ATA_SHIFT_UDMA, ATA_NR_UDMA_MODES, XFER_UDMA_0 },\n\t{ -1, },\n};\n\n \nu8 ata_xfer_mask2mode(unsigned int xfer_mask)\n{\n\tint highbit = fls(xfer_mask) - 1;\n\tconst struct ata_xfer_ent *ent;\n\n\tfor (ent = ata_xfer_tbl; ent->shift >= 0; ent++)\n\t\tif (highbit >= ent->shift && highbit < ent->shift + ent->bits)\n\t\t\treturn ent->base + highbit - ent->shift;\n\treturn 0xff;\n}\nEXPORT_SYMBOL_GPL(ata_xfer_mask2mode);\n\n \nunsigned int ata_xfer_mode2mask(u8 xfer_mode)\n{\n\tconst struct ata_xfer_ent *ent;\n\n\tfor (ent = ata_xfer_tbl; ent->shift >= 0; ent++)\n\t\tif (xfer_mode >= ent->base && xfer_mode < ent->base + ent->bits)\n\t\t\treturn ((2 << (ent->shift + xfer_mode - ent->base)) - 1)\n\t\t\t\t& ~((1 << ent->shift) - 1);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_xfer_mode2mask);\n\n \nint ata_xfer_mode2shift(u8 xfer_mode)\n{\n\tconst struct ata_xfer_ent *ent;\n\n\tfor (ent = ata_xfer_tbl; ent->shift >= 0; ent++)\n\t\tif (xfer_mode >= ent->base && xfer_mode < ent->base + ent->bits)\n\t\t\treturn ent->shift;\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(ata_xfer_mode2shift);\n\n \nconst char *ata_mode_string(unsigned int xfer_mask)\n{\n\tstatic const char * const xfer_mode_str[] = {\n\t\t\"PIO0\",\n\t\t\"PIO1\",\n\t\t\"PIO2\",\n\t\t\"PIO3\",\n\t\t\"PIO4\",\n\t\t\"PIO5\",\n\t\t\"PIO6\",\n\t\t\"MWDMA0\",\n\t\t\"MWDMA1\",\n\t\t\"MWDMA2\",\n\t\t\"MWDMA3\",\n\t\t\"MWDMA4\",\n\t\t\"UDMA/16\",\n\t\t\"UDMA/25\",\n\t\t\"UDMA/33\",\n\t\t\"UDMA/44\",\n\t\t\"UDMA/66\",\n\t\t\"UDMA/100\",\n\t\t\"UDMA/133\",\n\t\t\"UDMA7\",\n\t};\n\tint highbit;\n\n\thighbit = fls(xfer_mask) - 1;\n\tif (highbit >= 0 && highbit < ARRAY_SIZE(xfer_mode_str))\n\t\treturn xfer_mode_str[highbit];\n\treturn \"<n/a>\";\n}\nEXPORT_SYMBOL_GPL(ata_mode_string);\n\nconst char *sata_spd_string(unsigned int spd)\n{\n\tstatic const char * const spd_str[] = {\n\t\t\"1.5 Gbps\",\n\t\t\"3.0 Gbps\",\n\t\t\"6.0 Gbps\",\n\t};\n\n\tif (spd == 0 || (spd - 1) >= ARRAY_SIZE(spd_str))\n\t\treturn \"<unknown>\";\n\treturn spd_str[spd - 1];\n}\n\n \nunsigned int ata_dev_classify(const struct ata_taskfile *tf)\n{\n\t \n\tif (tf->lbam == 0 && tf->lbah == 0)\n\t\treturn ATA_DEV_ATA;\n\n\tif (tf->lbam == 0x14 && tf->lbah == 0xeb)\n\t\treturn ATA_DEV_ATAPI;\n\n\tif (tf->lbam == 0x69 && tf->lbah == 0x96)\n\t\treturn ATA_DEV_PMP;\n\n\tif (tf->lbam == 0x3c && tf->lbah == 0xc3)\n\t\treturn ATA_DEV_SEMB;\n\n\tif (tf->lbam == 0xcd && tf->lbah == 0xab)\n\t\treturn ATA_DEV_ZAC;\n\n\treturn ATA_DEV_UNKNOWN;\n}\nEXPORT_SYMBOL_GPL(ata_dev_classify);\n\n \n\nvoid ata_id_string(const u16 *id, unsigned char *s,\n\t\t   unsigned int ofs, unsigned int len)\n{\n\tunsigned int c;\n\n\tBUG_ON(len & 1);\n\n\twhile (len > 0) {\n\t\tc = id[ofs] >> 8;\n\t\t*s = c;\n\t\ts++;\n\n\t\tc = id[ofs] & 0xff;\n\t\t*s = c;\n\t\ts++;\n\n\t\tofs++;\n\t\tlen -= 2;\n\t}\n}\nEXPORT_SYMBOL_GPL(ata_id_string);\n\n \nvoid ata_id_c_string(const u16 *id, unsigned char *s,\n\t\t     unsigned int ofs, unsigned int len)\n{\n\tunsigned char *p;\n\n\tata_id_string(id, s, ofs, len - 1);\n\n\tp = s + strnlen(s, len - 1);\n\twhile (p > s && p[-1] == ' ')\n\t\tp--;\n\t*p = '\\0';\n}\nEXPORT_SYMBOL_GPL(ata_id_c_string);\n\nstatic u64 ata_id_n_sectors(const u16 *id)\n{\n\tif (ata_id_has_lba(id)) {\n\t\tif (ata_id_has_lba48(id))\n\t\t\treturn ata_id_u64(id, ATA_ID_LBA_CAPACITY_2);\n\n\t\treturn ata_id_u32(id, ATA_ID_LBA_CAPACITY);\n\t}\n\n\tif (ata_id_current_chs_valid(id))\n\t\treturn (u32)id[ATA_ID_CUR_CYLS] * (u32)id[ATA_ID_CUR_HEADS] *\n\t\t       (u32)id[ATA_ID_CUR_SECTORS];\n\n\treturn (u32)id[ATA_ID_CYLS] * (u32)id[ATA_ID_HEADS] *\n\t       (u32)id[ATA_ID_SECTORS];\n}\n\nu64 ata_tf_to_lba48(const struct ata_taskfile *tf)\n{\n\tu64 sectors = 0;\n\n\tsectors |= ((u64)(tf->hob_lbah & 0xff)) << 40;\n\tsectors |= ((u64)(tf->hob_lbam & 0xff)) << 32;\n\tsectors |= ((u64)(tf->hob_lbal & 0xff)) << 24;\n\tsectors |= (tf->lbah & 0xff) << 16;\n\tsectors |= (tf->lbam & 0xff) << 8;\n\tsectors |= (tf->lbal & 0xff);\n\n\treturn sectors;\n}\n\nu64 ata_tf_to_lba(const struct ata_taskfile *tf)\n{\n\tu64 sectors = 0;\n\n\tsectors |= (tf->device & 0x0f) << 24;\n\tsectors |= (tf->lbah & 0xff) << 16;\n\tsectors |= (tf->lbam & 0xff) << 8;\n\tsectors |= (tf->lbal & 0xff);\n\n\treturn sectors;\n}\n\n \nstatic int ata_read_native_max_address(struct ata_device *dev, u64 *max_sectors)\n{\n\tunsigned int err_mask;\n\tstruct ata_taskfile tf;\n\tint lba48 = ata_id_has_lba48(dev->id);\n\n\tata_tf_init(dev, &tf);\n\n\t \n\ttf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\n\tif (lba48) {\n\t\ttf.command = ATA_CMD_READ_NATIVE_MAX_EXT;\n\t\ttf.flags |= ATA_TFLAG_LBA48;\n\t} else\n\t\ttf.command = ATA_CMD_READ_NATIVE_MAX;\n\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.device |= ATA_LBA;\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\tif (err_mask) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"failed to read native max address (err_mask=0x%x)\\n\",\n\t\t\t     err_mask);\n\t\tif (err_mask == AC_ERR_DEV && (tf.error & ATA_ABORTED))\n\t\t\treturn -EACCES;\n\t\treturn -EIO;\n\t}\n\n\tif (lba48)\n\t\t*max_sectors = ata_tf_to_lba48(&tf) + 1;\n\telse\n\t\t*max_sectors = ata_tf_to_lba(&tf) + 1;\n\tif (dev->horkage & ATA_HORKAGE_HPA_SIZE)\n\t\t(*max_sectors)--;\n\treturn 0;\n}\n\n \nstatic int ata_set_max_sectors(struct ata_device *dev, u64 new_sectors)\n{\n\tunsigned int err_mask;\n\tstruct ata_taskfile tf;\n\tint lba48 = ata_id_has_lba48(dev->id);\n\n\tnew_sectors--;\n\n\tata_tf_init(dev, &tf);\n\n\ttf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\n\tif (lba48) {\n\t\ttf.command = ATA_CMD_SET_MAX_EXT;\n\t\ttf.flags |= ATA_TFLAG_LBA48;\n\n\t\ttf.hob_lbal = (new_sectors >> 24) & 0xff;\n\t\ttf.hob_lbam = (new_sectors >> 32) & 0xff;\n\t\ttf.hob_lbah = (new_sectors >> 40) & 0xff;\n\t} else {\n\t\ttf.command = ATA_CMD_SET_MAX;\n\n\t\ttf.device |= (new_sectors >> 24) & 0xf;\n\t}\n\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.device |= ATA_LBA;\n\n\ttf.lbal = (new_sectors >> 0) & 0xff;\n\ttf.lbam = (new_sectors >> 8) & 0xff;\n\ttf.lbah = (new_sectors >> 16) & 0xff;\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\tif (err_mask) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"failed to set max address (err_mask=0x%x)\\n\",\n\t\t\t     err_mask);\n\t\tif (err_mask == AC_ERR_DEV &&\n\t\t    (tf.error & (ATA_ABORTED | ATA_IDNF)))\n\t\t\treturn -EACCES;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ata_hpa_resize(struct ata_device *dev)\n{\n\tbool print_info = ata_dev_print_info(dev);\n\tbool unlock_hpa = ata_ignore_hpa || dev->flags & ATA_DFLAG_UNLOCK_HPA;\n\tu64 sectors = ata_id_n_sectors(dev->id);\n\tu64 native_sectors;\n\tint rc;\n\n\t \n\tif ((dev->class != ATA_DEV_ATA && dev->class != ATA_DEV_ZAC) ||\n\t    !ata_id_has_lba(dev->id) || !ata_id_hpa_enabled(dev->id) ||\n\t    (dev->horkage & ATA_HORKAGE_BROKEN_HPA))\n\t\treturn 0;\n\n\t \n\trc = ata_read_native_max_address(dev, &native_sectors);\n\tif (rc) {\n\t\t \n\t\tif (rc == -EACCES || !unlock_hpa) {\n\t\t\tata_dev_warn(dev,\n\t\t\t\t     \"HPA support seems broken, skipping HPA handling\\n\");\n\t\t\tdev->horkage |= ATA_HORKAGE_BROKEN_HPA;\n\n\t\t\t \n\t\t\tif (rc == -EACCES)\n\t\t\t\trc = 0;\n\t\t}\n\n\t\treturn rc;\n\t}\n\tdev->n_native_sectors = native_sectors;\n\n\t \n\tif (native_sectors <= sectors || !unlock_hpa) {\n\t\tif (!print_info || native_sectors == sectors)\n\t\t\treturn 0;\n\n\t\tif (native_sectors > sectors)\n\t\t\tata_dev_info(dev,\n\t\t\t\t\"HPA detected: current %llu, native %llu\\n\",\n\t\t\t\t(unsigned long long)sectors,\n\t\t\t\t(unsigned long long)native_sectors);\n\t\telse if (native_sectors < sectors)\n\t\t\tata_dev_warn(dev,\n\t\t\t\t\"native sectors (%llu) is smaller than sectors (%llu)\\n\",\n\t\t\t\t(unsigned long long)native_sectors,\n\t\t\t\t(unsigned long long)sectors);\n\t\treturn 0;\n\t}\n\n\t \n\trc = ata_set_max_sectors(dev, native_sectors);\n\tif (rc == -EACCES) {\n\t\t \n\t\tata_dev_warn(dev,\n\t\t\t     \"device aborted resize (%llu -> %llu), skipping HPA handling\\n\",\n\t\t\t     (unsigned long long)sectors,\n\t\t\t     (unsigned long long)native_sectors);\n\t\tdev->horkage |= ATA_HORKAGE_BROKEN_HPA;\n\t\treturn 0;\n\t} else if (rc)\n\t\treturn rc;\n\n\t \n\trc = ata_dev_reread_id(dev, 0);\n\tif (rc) {\n\t\tata_dev_err(dev,\n\t\t\t    \"failed to re-read IDENTIFY data after HPA resizing\\n\");\n\t\treturn rc;\n\t}\n\n\tif (print_info) {\n\t\tu64 new_sectors = ata_id_n_sectors(dev->id);\n\t\tata_dev_info(dev,\n\t\t\t\"HPA unlocked: %llu -> %llu, native %llu\\n\",\n\t\t\t(unsigned long long)sectors,\n\t\t\t(unsigned long long)new_sectors,\n\t\t\t(unsigned long long)native_sectors);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic inline void ata_dump_id(struct ata_device *dev, const u16 *id)\n{\n\tata_dev_dbg(dev,\n\t\t\"49==0x%04x  53==0x%04x  63==0x%04x  64==0x%04x  75==0x%04x\\n\"\n\t\t\"80==0x%04x  81==0x%04x  82==0x%04x  83==0x%04x  84==0x%04x\\n\"\n\t\t\"88==0x%04x  93==0x%04x\\n\",\n\t\tid[49], id[53], id[63], id[64], id[75], id[80],\n\t\tid[81], id[82], id[83], id[84], id[88], id[93]);\n}\n\n \nunsigned int ata_id_xfermask(const u16 *id)\n{\n\tunsigned int pio_mask, mwdma_mask, udma_mask;\n\n\t \n\tif (id[ATA_ID_FIELD_VALID] & (1 << 1)) {\n\t\tpio_mask = id[ATA_ID_PIO_MODES] & 0x03;\n\t\tpio_mask <<= 3;\n\t\tpio_mask |= 0x7;\n\t} else {\n\t\t \n\t\tu8 mode = (id[ATA_ID_OLD_PIO_MODES] >> 8) & 0xFF;\n\t\tif (mode < 5)\t \n\t\t\tpio_mask = (2 << mode) - 1;\n\t\telse\n\t\t\tpio_mask = 1;\n\n\t\t \n\t}\n\n\tmwdma_mask = id[ATA_ID_MWDMA_MODES] & 0x07;\n\n\tif (ata_id_is_cfa(id)) {\n\t\t \n\t\tint pio = (id[ATA_ID_CFA_MODES] >> 0) & 0x7;\n\t\tint dma = (id[ATA_ID_CFA_MODES] >> 3) & 0x7;\n\n\t\tif (pio)\n\t\t\tpio_mask |= (1 << 5);\n\t\tif (pio > 1)\n\t\t\tpio_mask |= (1 << 6);\n\t\tif (dma)\n\t\t\tmwdma_mask |= (1 << 3);\n\t\tif (dma > 1)\n\t\t\tmwdma_mask |= (1 << 4);\n\t}\n\n\tudma_mask = 0;\n\tif (id[ATA_ID_FIELD_VALID] & (1 << 2))\n\t\tudma_mask = id[ATA_ID_UDMA_MODES] & 0xff;\n\n\treturn ata_pack_xfermask(pio_mask, mwdma_mask, udma_mask);\n}\nEXPORT_SYMBOL_GPL(ata_id_xfermask);\n\nstatic void ata_qc_complete_internal(struct ata_queued_cmd *qc)\n{\n\tstruct completion *waiting = qc->private_data;\n\n\tcomplete(waiting);\n}\n\n \nstatic unsigned ata_exec_internal_sg(struct ata_device *dev,\n\t\t\t\t     struct ata_taskfile *tf, const u8 *cdb,\n\t\t\t\t     int dma_dir, struct scatterlist *sgl,\n\t\t\t\t     unsigned int n_elem, unsigned int timeout)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tu8 command = tf->command;\n\tint auto_timeout = 0;\n\tstruct ata_queued_cmd *qc;\n\tunsigned int preempted_tag;\n\tu32 preempted_sactive;\n\tu64 preempted_qc_active;\n\tint preempted_nr_active_links;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tunsigned long flags;\n\tunsigned int err_mask;\n\tint rc;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tif (ata_port_is_frozen(ap)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn AC_ERR_SYSTEM;\n\t}\n\n\t \n\tqc = __ata_qc_from_tag(ap, ATA_TAG_INTERNAL);\n\n\tqc->tag = ATA_TAG_INTERNAL;\n\tqc->hw_tag = 0;\n\tqc->scsicmd = NULL;\n\tqc->ap = ap;\n\tqc->dev = dev;\n\tata_qc_reinit(qc);\n\n\tpreempted_tag = link->active_tag;\n\tpreempted_sactive = link->sactive;\n\tpreempted_qc_active = ap->qc_active;\n\tpreempted_nr_active_links = ap->nr_active_links;\n\tlink->active_tag = ATA_TAG_POISON;\n\tlink->sactive = 0;\n\tap->qc_active = 0;\n\tap->nr_active_links = 0;\n\n\t \n\tqc->tf = *tf;\n\tif (cdb)\n\t\tmemcpy(qc->cdb, cdb, ATAPI_CDB_LEN);\n\n\t \n\tif (tf->protocol == ATAPI_PROT_DMA && (dev->flags & ATA_DFLAG_DMADIR) &&\n\t    dma_dir == DMA_FROM_DEVICE)\n\t\tqc->tf.feature |= ATAPI_DMADIR;\n\n\tqc->flags |= ATA_QCFLAG_RESULT_TF;\n\tqc->dma_dir = dma_dir;\n\tif (dma_dir != DMA_NONE) {\n\t\tunsigned int i, buflen = 0;\n\t\tstruct scatterlist *sg;\n\n\t\tfor_each_sg(sgl, sg, n_elem, i)\n\t\t\tbuflen += sg->length;\n\n\t\tata_sg_init(qc, sgl, n_elem);\n\t\tqc->nbytes = buflen;\n\t}\n\n\tqc->private_data = &wait;\n\tqc->complete_fn = ata_qc_complete_internal;\n\n\tata_qc_issue(qc);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tif (!timeout) {\n\t\tif (ata_probe_timeout)\n\t\t\ttimeout = ata_probe_timeout * 1000;\n\t\telse {\n\t\t\ttimeout = ata_internal_cmd_timeout(dev, command);\n\t\t\tauto_timeout = 1;\n\t\t}\n\t}\n\n\tata_eh_release(ap);\n\n\trc = wait_for_completion_timeout(&wait, msecs_to_jiffies(timeout));\n\n\tata_eh_acquire(ap);\n\n\tata_sff_flush_pio_task(ap);\n\n\tif (!rc) {\n\t\tspin_lock_irqsave(ap->lock, flags);\n\n\t\t \n\t\tif (qc->flags & ATA_QCFLAG_ACTIVE) {\n\t\t\tqc->err_mask |= AC_ERR_TIMEOUT;\n\n\t\t\tata_port_freeze(ap);\n\n\t\t\tata_dev_warn(dev, \"qc timeout after %u msecs (cmd 0x%x)\\n\",\n\t\t\t\t     timeout, command);\n\t\t}\n\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t}\n\n\t \n\tif (ap->ops->post_internal_cmd)\n\t\tap->ops->post_internal_cmd(qc);\n\n\t \n\tif (qc->flags & ATA_QCFLAG_EH) {\n\t\tif (qc->result_tf.status & (ATA_ERR | ATA_DF))\n\t\t\tqc->err_mask |= AC_ERR_DEV;\n\n\t\tif (!qc->err_mask)\n\t\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\t\tif (qc->err_mask & ~AC_ERR_OTHER)\n\t\t\tqc->err_mask &= ~AC_ERR_OTHER;\n\t} else if (qc->tf.command == ATA_CMD_REQ_SENSE_DATA) {\n\t\tqc->result_tf.status |= ATA_SENSE;\n\t}\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\t*tf = qc->result_tf;\n\terr_mask = qc->err_mask;\n\n\tata_qc_free(qc);\n\tlink->active_tag = preempted_tag;\n\tlink->sactive = preempted_sactive;\n\tap->qc_active = preempted_qc_active;\n\tap->nr_active_links = preempted_nr_active_links;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tif ((err_mask & AC_ERR_TIMEOUT) && auto_timeout)\n\t\tata_internal_cmd_timed_out(dev, command);\n\n\treturn err_mask;\n}\n\n \nunsigned ata_exec_internal(struct ata_device *dev,\n\t\t\t   struct ata_taskfile *tf, const u8 *cdb,\n\t\t\t   int dma_dir, void *buf, unsigned int buflen,\n\t\t\t   unsigned int timeout)\n{\n\tstruct scatterlist *psg = NULL, sg;\n\tunsigned int n_elem = 0;\n\n\tif (dma_dir != DMA_NONE) {\n\t\tWARN_ON(!buf);\n\t\tsg_init_one(&sg, buf, buflen);\n\t\tpsg = &sg;\n\t\tn_elem++;\n\t}\n\n\treturn ata_exec_internal_sg(dev, tf, cdb, dma_dir, psg, n_elem,\n\t\t\t\t    timeout);\n}\n\n \nunsigned int ata_pio_need_iordy(const struct ata_device *adev)\n{\n\t \n\tif (adev->link->ap->pflags & ATA_PFLAG_RESETTING)\n\t\treturn 0;\n\t \n\tif (adev->link->ap->flags & ATA_FLAG_NO_IORDY)\n\t\treturn 0;\n\t \n\tif (ata_id_is_cfa(adev->id)\n\t    && (adev->pio_mode == XFER_PIO_5 || adev->pio_mode == XFER_PIO_6))\n\t\treturn 0;\n\t \n\tif (adev->pio_mode > XFER_PIO_2)\n\t\treturn 1;\n\t \n\tif (ata_id_has_iordy(adev->id))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_pio_need_iordy);\n\n \nstatic u32 ata_pio_mask_no_iordy(const struct ata_device *adev)\n{\n\t \n\tif (adev->id[ATA_ID_FIELD_VALID] & 2) {\t \n\t\tu16 pio = adev->id[ATA_ID_EIDE_PIO];\n\t\t \n\t\tif (pio) {\n\t\t\t \n\t\t\tif (pio > 240)\t \n\t\t\t\treturn 3 << ATA_SHIFT_PIO;\n\t\t\treturn 7 << ATA_SHIFT_PIO;\n\t\t}\n\t}\n\treturn 3 << ATA_SHIFT_PIO;\n}\n\n \nunsigned int ata_do_dev_read_id(struct ata_device *dev,\n\t\t\t\tstruct ata_taskfile *tf, __le16 *id)\n{\n\treturn ata_exec_internal(dev, tf, NULL, DMA_FROM_DEVICE,\n\t\t\t\t     id, sizeof(id[0]) * ATA_ID_WORDS, 0);\n}\nEXPORT_SYMBOL_GPL(ata_do_dev_read_id);\n\n \nint ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,\n\t\t    unsigned int flags, u16 *id)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int class = *p_class;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask = 0;\n\tconst char *reason;\n\tbool is_semb = class == ATA_DEV_SEMB;\n\tint may_fallback = 1, tried_spinup = 0;\n\tint rc;\n\nretry:\n\tata_tf_init(dev, &tf);\n\n\tswitch (class) {\n\tcase ATA_DEV_SEMB:\n\t\tclass = ATA_DEV_ATA;\t \n\t\tfallthrough;\n\tcase ATA_DEV_ATA:\n\tcase ATA_DEV_ZAC:\n\t\ttf.command = ATA_CMD_ID_ATA;\n\t\tbreak;\n\tcase ATA_DEV_ATAPI:\n\t\ttf.command = ATA_CMD_ID_ATAPI;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENODEV;\n\t\treason = \"unsupported class\";\n\t\tgoto err_out;\n\t}\n\n\ttf.protocol = ATA_PROT_PIO;\n\n\t \n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\n\t \n\ttf.flags |= ATA_TFLAG_POLLING;\n\n\tif (ap->ops->read_id)\n\t\terr_mask = ap->ops->read_id(dev, &tf, (__le16 *)id);\n\telse\n\t\terr_mask = ata_do_dev_read_id(dev, &tf, (__le16 *)id);\n\n\tif (err_mask) {\n\t\tif (err_mask & AC_ERR_NODEV_HINT) {\n\t\t\tata_dev_dbg(dev, \"NODEV after polling detection\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (is_semb) {\n\t\t\tata_dev_info(dev,\n\t\t     \"IDENTIFY failed on device w/ SEMB sig, disabled\\n\");\n\t\t\t \n\t\t\t*p_class = ATA_DEV_SEMB_UNSUP;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((err_mask == AC_ERR_DEV) && (tf.error & ATA_ABORTED)) {\n\t\t\t \n\t\t\tif (may_fallback) {\n\t\t\t\tmay_fallback = 0;\n\n\t\t\t\tif (class == ATA_DEV_ATA)\n\t\t\t\t\tclass = ATA_DEV_ATAPI;\n\t\t\t\telse\n\t\t\t\t\tclass = ATA_DEV_ATA;\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\t \n\t\t\tata_dev_dbg(dev,\n\t\t\t\t    \"both IDENTIFYs aborted, assuming NODEV\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\trc = -EIO;\n\t\treason = \"I/O error\";\n\t\tgoto err_out;\n\t}\n\n\tif (dev->horkage & ATA_HORKAGE_DUMP_ID) {\n\t\tata_dev_info(dev, \"dumping IDENTIFY data, \"\n\t\t\t    \"class=%d may_fallback=%d tried_spinup=%d\\n\",\n\t\t\t    class, may_fallback, tried_spinup);\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 2, id, ATA_ID_WORDS * sizeof(*id), true);\n\t}\n\n\t \n\tmay_fallback = 0;\n\n\tswap_buf_le16(id, ATA_ID_WORDS);\n\n\t \n\trc = -EINVAL;\n\treason = \"device reports invalid type\";\n\n\tif (class == ATA_DEV_ATA || class == ATA_DEV_ZAC) {\n\t\tif (!ata_id_is_ata(id) && !ata_id_is_cfa(id))\n\t\t\tgoto err_out;\n\t\tif (ap->host->flags & ATA_HOST_IGNORE_ATA &&\n\t\t\t\t\t\t\tata_id_is_ata(id)) {\n\t\t\tata_dev_dbg(dev,\n\t\t\t\t\"host indicates ignore ATA devices, ignored\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else {\n\t\tif (ata_id_is_ata(id))\n\t\t\tgoto err_out;\n\t}\n\n\tif (!tried_spinup && (id[2] == 0x37c8 || id[2] == 0x738c)) {\n\t\ttried_spinup = 1;\n\t\t \n\t\terr_mask = ata_dev_set_feature(dev, SETFEATURES_SPINUP, 0);\n\t\tif (err_mask && id[2] != 0x738c) {\n\t\t\trc = -EIO;\n\t\t\treason = \"SPINUP failed\";\n\t\t\tgoto err_out;\n\t\t}\n\t\t \n\t\tif (id[2] == 0x37c8)\n\t\t\tgoto retry;\n\t}\n\n\tif ((flags & ATA_READID_POSTRESET) &&\n\t    (class == ATA_DEV_ATA || class == ATA_DEV_ZAC)) {\n\t\t \n\t\tif (ata_id_major_version(id) < 4 || !ata_id_has_lba(id)) {\n\t\t\terr_mask = ata_dev_init_params(dev, id[3], id[6]);\n\t\t\tif (err_mask) {\n\t\t\t\trc = -EIO;\n\t\t\t\treason = \"INIT_DEV_PARAMS failed\";\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tflags &= ~ATA_READID_POSTRESET;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t*p_class = class;\n\n\treturn 0;\n\n err_out:\n\tata_dev_warn(dev, \"failed to IDENTIFY (%s, err_mask=0x%x)\\n\",\n\t\t     reason, err_mask);\n\treturn rc;\n}\n\n \nvoid ata_dev_power_set_standby(struct ata_device *dev)\n{\n\tunsigned long ap_flags = dev->link->ap->flags;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\t \n\tif (dev->class != ATA_DEV_ATA && dev->class != ATA_DEV_ZAC)\n\t\treturn;\n\n\t \n\tif ((ap_flags & ATA_FLAG_NO_POWEROFF_SPINDOWN) &&\n\t    system_state == SYSTEM_POWER_OFF)\n\t\treturn;\n\n\tif ((ap_flags & ATA_FLAG_NO_HIBERNATE_SPINDOWN) &&\n\t    system_entering_hibernation())\n\t\treturn;\n\n\tata_tf_init(dev, &tf);\n\ttf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.command = ATA_CMD_STANDBYNOW1;\n\n\tata_dev_notice(dev, \"Entering standby power mode\\n\");\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\tif (err_mask)\n\t\tata_dev_err(dev, \"STANDBY IMMEDIATE failed (err_mask=0x%x)\\n\",\n\t\t\t    err_mask);\n}\n\n \nvoid ata_dev_power_set_active(struct ata_device *dev)\n{\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\t \n\tif (dev->class != ATA_DEV_ATA && dev->class != ATA_DEV_ZAC)\n\t\treturn;\n\n\tata_tf_init(dev, &tf);\n\ttf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.command = ATA_CMD_VERIFY;\n\ttf.nsect = 1;\n\tif (dev->flags & ATA_DFLAG_LBA) {\n\t\ttf.flags |= ATA_TFLAG_LBA;\n\t\ttf.device |= ATA_LBA;\n\t} else {\n\t\t \n\t\ttf.lbal = 0x1;  \n\t}\n\n\tata_dev_notice(dev, \"Entering active power mode\\n\");\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\tif (err_mask)\n\t\tata_dev_err(dev, \"VERIFY failed (err_mask=0x%x)\\n\",\n\t\t\t    err_mask);\n}\n\n \nunsigned int ata_read_log_page(struct ata_device *dev, u8 log,\n\t\t\t       u8 page, void *buf, unsigned int sectors)\n{\n\tunsigned long ap_flags = dev->link->ap->flags;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\tbool dma = false;\n\n\tata_dev_dbg(dev, \"read log page - log 0x%x, page 0x%x\\n\", log, page);\n\n\t \n\tif (ap_flags & ATA_FLAG_NO_LOG_PAGE)\n\t\treturn AC_ERR_DEV;\n\nretry:\n\tata_tf_init(dev, &tf);\n\tif (ata_dma_enabled(dev) && ata_id_has_read_log_dma_ext(dev->id) &&\n\t    !(dev->horkage & ATA_HORKAGE_NO_DMA_LOG)) {\n\t\ttf.command = ATA_CMD_READ_LOG_DMA_EXT;\n\t\ttf.protocol = ATA_PROT_DMA;\n\t\tdma = true;\n\t} else {\n\t\ttf.command = ATA_CMD_READ_LOG_EXT;\n\t\ttf.protocol = ATA_PROT_PIO;\n\t\tdma = false;\n\t}\n\ttf.lbal = log;\n\ttf.lbam = page;\n\ttf.nsect = sectors;\n\ttf.hob_nsect = sectors >> 8;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_LBA48 | ATA_TFLAG_DEVICE;\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_FROM_DEVICE,\n\t\t\t\t     buf, sectors * ATA_SECT_SIZE, 0);\n\n\tif (err_mask) {\n\t\tif (dma) {\n\t\t\tdev->horkage |= ATA_HORKAGE_NO_DMA_LOG;\n\t\t\tif (!ata_port_is_frozen(dev->link->ap))\n\t\t\t\tgoto retry;\n\t\t}\n\t\tata_dev_err(dev,\n\t\t\t    \"Read log 0x%02x page 0x%02x failed, Emask 0x%x\\n\",\n\t\t\t    (unsigned int)log, (unsigned int)page, err_mask);\n\t}\n\n\treturn err_mask;\n}\n\nstatic int ata_log_supported(struct ata_device *dev, u8 log)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\n\tif (dev->horkage & ATA_HORKAGE_NO_LOG_DIR)\n\t\treturn 0;\n\n\tif (ata_read_log_page(dev, ATA_LOG_DIRECTORY, 0, ap->sector_buf, 1))\n\t\treturn 0;\n\treturn get_unaligned_le16(&ap->sector_buf[log * 2]);\n}\n\nstatic bool ata_identify_page_supported(struct ata_device *dev, u8 page)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int err, i;\n\n\tif (dev->horkage & ATA_HORKAGE_NO_ID_DEV_LOG)\n\t\treturn false;\n\n\tif (!ata_log_supported(dev, ATA_LOG_IDENTIFY_DEVICE)) {\n\t\t \n\t\tif (ata_id_major_version(dev->id) >= 10)\n\t\t\tata_dev_warn(dev,\n\t\t\t\t\"ATA Identify Device Log not supported\\n\");\n\t\tdev->horkage |= ATA_HORKAGE_NO_ID_DEV_LOG;\n\t\treturn false;\n\t}\n\n\t \n\terr = ata_read_log_page(dev, ATA_LOG_IDENTIFY_DEVICE, 0, ap->sector_buf,\n\t\t\t\t1);\n\tif (err)\n\t\treturn false;\n\n\tfor (i = 0; i < ap->sector_buf[8]; i++) {\n\t\tif (ap->sector_buf[9 + i] == page)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ata_do_link_spd_horkage(struct ata_device *dev)\n{\n\tstruct ata_link *plink = ata_dev_phys_link(dev);\n\tu32 target, target_limit;\n\n\tif (!sata_scr_valid(plink))\n\t\treturn 0;\n\n\tif (dev->horkage & ATA_HORKAGE_1_5_GBPS)\n\t\ttarget = 1;\n\telse\n\t\treturn 0;\n\n\ttarget_limit = (1 << target) - 1;\n\n\t \n\tif (plink->sata_spd_limit <= target_limit)\n\t\treturn 0;\n\n\tplink->sata_spd_limit = target_limit;\n\n\t \n\tif (plink->sata_spd > target) {\n\t\tata_dev_info(dev, \"applying link speed limit horkage to %s\\n\",\n\t\t\t     sata_spd_string(target));\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic inline u8 ata_dev_knobble(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\n\tif (ata_dev_blacklisted(dev) & ATA_HORKAGE_BRIDGE_OK)\n\t\treturn 0;\n\n\treturn ((ap->cbl == ATA_CBL_SATA) && (!ata_id_is_sata(dev->id)));\n}\n\nstatic void ata_dev_config_ncq_send_recv(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int err_mask;\n\n\tif (!ata_log_supported(dev, ATA_LOG_NCQ_SEND_RECV)) {\n\t\tata_dev_warn(dev, \"NCQ Send/Recv Log not supported\\n\");\n\t\treturn;\n\t}\n\terr_mask = ata_read_log_page(dev, ATA_LOG_NCQ_SEND_RECV,\n\t\t\t\t     0, ap->sector_buf, 1);\n\tif (!err_mask) {\n\t\tu8 *cmds = dev->ncq_send_recv_cmds;\n\n\t\tdev->flags |= ATA_DFLAG_NCQ_SEND_RECV;\n\t\tmemcpy(cmds, ap->sector_buf, ATA_LOG_NCQ_SEND_RECV_SIZE);\n\n\t\tif (dev->horkage & ATA_HORKAGE_NO_NCQ_TRIM) {\n\t\t\tata_dev_dbg(dev, \"disabling queued TRIM support\\n\");\n\t\t\tcmds[ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET] &=\n\t\t\t\t~ATA_LOG_NCQ_SEND_RECV_DSM_TRIM;\n\t\t}\n\t}\n}\n\nstatic void ata_dev_config_ncq_non_data(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int err_mask;\n\n\tif (!ata_log_supported(dev, ATA_LOG_NCQ_NON_DATA)) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"NCQ Send/Recv Log not supported\\n\");\n\t\treturn;\n\t}\n\terr_mask = ata_read_log_page(dev, ATA_LOG_NCQ_NON_DATA,\n\t\t\t\t     0, ap->sector_buf, 1);\n\tif (!err_mask) {\n\t\tu8 *cmds = dev->ncq_non_data_cmds;\n\n\t\tmemcpy(cmds, ap->sector_buf, ATA_LOG_NCQ_NON_DATA_SIZE);\n\t}\n}\n\nstatic void ata_dev_config_ncq_prio(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int err_mask;\n\n\tif (!ata_identify_page_supported(dev, ATA_LOG_SATA_SETTINGS))\n\t\treturn;\n\n\terr_mask = ata_read_log_page(dev,\n\t\t\t\t     ATA_LOG_IDENTIFY_DEVICE,\n\t\t\t\t     ATA_LOG_SATA_SETTINGS,\n\t\t\t\t     ap->sector_buf,\n\t\t\t\t     1);\n\tif (err_mask)\n\t\tgoto not_supported;\n\n\tif (!(ap->sector_buf[ATA_LOG_NCQ_PRIO_OFFSET] & BIT(3)))\n\t\tgoto not_supported;\n\n\tdev->flags |= ATA_DFLAG_NCQ_PRIO;\n\n\treturn;\n\nnot_supported:\n\tdev->flags &= ~ATA_DFLAG_NCQ_PRIO_ENABLED;\n\tdev->flags &= ~ATA_DFLAG_NCQ_PRIO;\n}\n\nstatic bool ata_dev_check_adapter(struct ata_device *dev,\n\t\t\t\t  unsigned short vendor_id)\n{\n\tstruct pci_dev *pcidev = NULL;\n\tstruct device *parent_dev = NULL;\n\n\tfor (parent_dev = dev->tdev.parent; parent_dev != NULL;\n\t     parent_dev = parent_dev->parent) {\n\t\tif (dev_is_pci(parent_dev)) {\n\t\t\tpcidev = to_pci_dev(parent_dev);\n\t\t\tif (pcidev->vendor == vendor_id)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int ata_dev_config_ncq(struct ata_device *dev,\n\t\t\t       char *desc, size_t desc_sz)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tint hdepth = 0, ddepth = ata_id_queue_depth(dev->id);\n\tunsigned int err_mask;\n\tchar *aa_desc = \"\";\n\n\tif (!ata_id_has_ncq(dev->id)) {\n\t\tdesc[0] = '\\0';\n\t\treturn 0;\n\t}\n\tif (!IS_ENABLED(CONFIG_SATA_HOST))\n\t\treturn 0;\n\tif (dev->horkage & ATA_HORKAGE_NONCQ) {\n\t\tsnprintf(desc, desc_sz, \"NCQ (not used)\");\n\t\treturn 0;\n\t}\n\n\tif (dev->horkage & ATA_HORKAGE_NO_NCQ_ON_ATI &&\n\t    ata_dev_check_adapter(dev, PCI_VENDOR_ID_ATI)) {\n\t\tsnprintf(desc, desc_sz, \"NCQ (not used)\");\n\t\treturn 0;\n\t}\n\n\tif (ap->flags & ATA_FLAG_NCQ) {\n\t\thdepth = min(ap->scsi_host->can_queue, ATA_MAX_QUEUE);\n\t\tdev->flags |= ATA_DFLAG_NCQ;\n\t}\n\n\tif (!(dev->horkage & ATA_HORKAGE_BROKEN_FPDMA_AA) &&\n\t\t(ap->flags & ATA_FLAG_FPDMA_AA) &&\n\t\tata_id_has_fpdma_aa(dev->id)) {\n\t\terr_mask = ata_dev_set_feature(dev, SETFEATURES_SATA_ENABLE,\n\t\t\tSATA_FPDMA_AA);\n\t\tif (err_mask) {\n\t\t\tata_dev_err(dev,\n\t\t\t\t    \"failed to enable AA (error_mask=0x%x)\\n\",\n\t\t\t\t    err_mask);\n\t\t\tif (err_mask != AC_ERR_DEV) {\n\t\t\t\tdev->horkage |= ATA_HORKAGE_BROKEN_FPDMA_AA;\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else\n\t\t\taa_desc = \", AA\";\n\t}\n\n\tif (hdepth >= ddepth)\n\t\tsnprintf(desc, desc_sz, \"NCQ (depth %d)%s\", ddepth, aa_desc);\n\telse\n\t\tsnprintf(desc, desc_sz, \"NCQ (depth %d/%d)%s\", hdepth,\n\t\t\tddepth, aa_desc);\n\n\tif ((ap->flags & ATA_FLAG_FPDMA_AUX)) {\n\t\tif (ata_id_has_ncq_send_and_recv(dev->id))\n\t\t\tata_dev_config_ncq_send_recv(dev);\n\t\tif (ata_id_has_ncq_non_data(dev->id))\n\t\t\tata_dev_config_ncq_non_data(dev);\n\t\tif (ata_id_has_ncq_prio(dev->id))\n\t\t\tata_dev_config_ncq_prio(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void ata_dev_config_sense_reporting(struct ata_device *dev)\n{\n\tunsigned int err_mask;\n\n\tif (!ata_id_has_sense_reporting(dev->id))\n\t\treturn;\n\n\tif (ata_id_sense_reporting_enabled(dev->id))\n\t\treturn;\n\n\terr_mask = ata_dev_set_feature(dev, SETFEATURE_SENSE_DATA, 0x1);\n\tif (err_mask) {\n\t\tata_dev_dbg(dev,\n\t\t\t    \"failed to enable Sense Data Reporting, Emask 0x%x\\n\",\n\t\t\t    err_mask);\n\t}\n}\n\nstatic void ata_dev_config_zac(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int err_mask;\n\tu8 *identify_buf = ap->sector_buf;\n\n\tdev->zac_zones_optimal_open = U32_MAX;\n\tdev->zac_zones_optimal_nonseq = U32_MAX;\n\tdev->zac_zones_max_open = U32_MAX;\n\n\t \n\tif (dev->class == ATA_DEV_ZAC)\n\t\tdev->flags |= ATA_DFLAG_ZAC;\n\telse if (ata_id_zoned_cap(dev->id) == 0x01)\n\t\t \n\t\tdev->flags |= ATA_DFLAG_ZAC;\n\n\tif (!(dev->flags & ATA_DFLAG_ZAC))\n\t\treturn;\n\n\tif (!ata_identify_page_supported(dev, ATA_LOG_ZONED_INFORMATION)) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"ATA Zoned Information Log not supported\\n\");\n\t\treturn;\n\t}\n\n\t \n\terr_mask = ata_read_log_page(dev, ATA_LOG_IDENTIFY_DEVICE,\n\t\t\t\t     ATA_LOG_ZONED_INFORMATION,\n\t\t\t\t     identify_buf, 1);\n\tif (!err_mask) {\n\t\tu64 zoned_cap, opt_open, opt_nonseq, max_open;\n\n\t\tzoned_cap = get_unaligned_le64(&identify_buf[8]);\n\t\tif ((zoned_cap >> 63))\n\t\t\tdev->zac_zoned_cap = (zoned_cap & 1);\n\t\topt_open = get_unaligned_le64(&identify_buf[24]);\n\t\tif ((opt_open >> 63))\n\t\t\tdev->zac_zones_optimal_open = (u32)opt_open;\n\t\topt_nonseq = get_unaligned_le64(&identify_buf[32]);\n\t\tif ((opt_nonseq >> 63))\n\t\t\tdev->zac_zones_optimal_nonseq = (u32)opt_nonseq;\n\t\tmax_open = get_unaligned_le64(&identify_buf[40]);\n\t\tif ((max_open >> 63))\n\t\t\tdev->zac_zones_max_open = (u32)max_open;\n\t}\n}\n\nstatic void ata_dev_config_trusted(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tu64 trusted_cap;\n\tunsigned int err;\n\n\tif (!ata_id_has_trusted(dev->id))\n\t\treturn;\n\n\tif (!ata_identify_page_supported(dev, ATA_LOG_SECURITY)) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"Security Log not supported\\n\");\n\t\treturn;\n\t}\n\n\terr = ata_read_log_page(dev, ATA_LOG_IDENTIFY_DEVICE, ATA_LOG_SECURITY,\n\t\t\tap->sector_buf, 1);\n\tif (err)\n\t\treturn;\n\n\ttrusted_cap = get_unaligned_le64(&ap->sector_buf[40]);\n\tif (!(trusted_cap & (1ULL << 63))) {\n\t\tata_dev_dbg(dev,\n\t\t\t    \"Trusted Computing capability qword not valid!\\n\");\n\t\treturn;\n\t}\n\n\tif (trusted_cap & (1 << 0))\n\t\tdev->flags |= ATA_DFLAG_TRUSTED;\n}\n\nstatic void ata_dev_config_cdl(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tunsigned int err_mask;\n\tbool cdl_enabled;\n\tu64 val;\n\n\tif (ata_id_major_version(dev->id) < 12)\n\t\tgoto not_supported;\n\n\tif (!ata_log_supported(dev, ATA_LOG_IDENTIFY_DEVICE) ||\n\t    !ata_identify_page_supported(dev, ATA_LOG_SUPPORTED_CAPABILITIES) ||\n\t    !ata_identify_page_supported(dev, ATA_LOG_CURRENT_SETTINGS))\n\t\tgoto not_supported;\n\n\terr_mask = ata_read_log_page(dev, ATA_LOG_IDENTIFY_DEVICE,\n\t\t\t\t     ATA_LOG_SUPPORTED_CAPABILITIES,\n\t\t\t\t     ap->sector_buf, 1);\n\tif (err_mask)\n\t\tgoto not_supported;\n\n\t \n\tval = get_unaligned_le64(&ap->sector_buf[168]);\n\tif (!(val & BIT_ULL(63)) || !(val & BIT_ULL(0)))\n\t\tgoto not_supported;\n\n\t \n\tif (!(val & BIT_ULL(1)))\n\t\tata_dev_warn(dev,\n\t\t\t\"Command duration guideline is not supported\\n\");\n\n\t \n\tval = get_unaligned_le64(&ap->sector_buf[8]);\n\tif (!(val & BIT_ULL(63)) || !(val & BIT_ULL(47))) {\n\t\tata_dev_warn(dev,\n\t\t\t\"CDL supported but Successful NCQ Command Sense Data is not supported\\n\");\n\t\tgoto not_supported;\n\t}\n\n\t \n\tif (!ata_id_has_ncq_autosense(dev->id)) {\n\t\tata_dev_warn(dev,\n\t\t\t\"CDL supported but NCQ autosense is not supported\\n\");\n\t\tgoto not_supported;\n\t}\n\n\t \n\terr_mask = ata_read_log_page(dev, ATA_LOG_IDENTIFY_DEVICE,\n\t\t\t\t     ATA_LOG_CURRENT_SETTINGS,\n\t\t\t\t     ap->sector_buf, 1);\n\tif (err_mask)\n\t\tgoto not_supported;\n\n\tval = get_unaligned_le64(&ap->sector_buf[8]);\n\tcdl_enabled = val & BIT_ULL(63) && val & BIT_ULL(21);\n\tif (dev->flags & ATA_DFLAG_CDL_ENABLED) {\n\t\tif (!cdl_enabled) {\n\t\t\t \n\t\t\terr_mask = ata_dev_set_feature(dev, SETFEATURES_CDL, 1);\n\t\t\tif (err_mask) {\n\t\t\t\tata_dev_err(dev,\n\t\t\t\t\t    \"Enable CDL feature failed\\n\");\n\t\t\t\tgoto not_supported;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cdl_enabled) {\n\t\t\t \n\t\t\terr_mask = ata_dev_set_feature(dev, SETFEATURES_CDL, 0);\n\t\t\tif (err_mask) {\n\t\t\t\tata_dev_err(dev,\n\t\t\t\t\t    \"Disable CDL feature failed\\n\");\n\t\t\t\tgoto not_supported;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(val & BIT_ULL(63)) || !(val & BIT_ULL(18))) {\n\t\terr_mask = ata_dev_set_feature(dev,\n\t\t\t\t\tSETFEATURE_SENSE_DATA_SUCC_NCQ, 0x1);\n\t\tif (err_mask) {\n\t\t\tata_dev_warn(dev,\n\t\t\t\t     \"failed to enable Sense Data for successful NCQ commands, Emask 0x%x\\n\",\n\t\t\t\t     err_mask);\n\t\t\tgoto not_supported;\n\t\t}\n\t}\n\n\t \n\tif (!ap->ncq_sense_buf) {\n\t\tap->ncq_sense_buf = kmalloc(ATA_LOG_SENSE_NCQ_SIZE, GFP_KERNEL);\n\t\tif (!ap->ncq_sense_buf)\n\t\t\tgoto not_supported;\n\t}\n\n\t \n\terr_mask = ata_read_log_page(dev, ATA_LOG_CDL, 0, ap->sector_buf, 1);\n\tif (err_mask) {\n\t\tata_dev_warn(dev, \"Read Command Duration Limits log failed\\n\");\n\t\tgoto not_supported;\n\t}\n\n\tmemcpy(dev->cdl, ap->sector_buf, ATA_LOG_CDL_SIZE);\n\tdev->flags |= ATA_DFLAG_CDL;\n\n\treturn;\n\nnot_supported:\n\tdev->flags &= ~(ATA_DFLAG_CDL | ATA_DFLAG_CDL_ENABLED);\n\tkfree(ap->ncq_sense_buf);\n\tap->ncq_sense_buf = NULL;\n}\n\nstatic int ata_dev_config_lba(struct ata_device *dev)\n{\n\tconst u16 *id = dev->id;\n\tconst char *lba_desc;\n\tchar ncq_desc[32];\n\tint ret;\n\n\tdev->flags |= ATA_DFLAG_LBA;\n\n\tif (ata_id_has_lba48(id)) {\n\t\tlba_desc = \"LBA48\";\n\t\tdev->flags |= ATA_DFLAG_LBA48;\n\t\tif (dev->n_sectors >= (1UL << 28) &&\n\t\t    ata_id_has_flush_ext(id))\n\t\t\tdev->flags |= ATA_DFLAG_FLUSH_EXT;\n\t} else {\n\t\tlba_desc = \"LBA\";\n\t}\n\n\t \n\tret = ata_dev_config_ncq(dev, ncq_desc, sizeof(ncq_desc));\n\n\t \n\tif (ata_dev_print_info(dev))\n\t\tata_dev_info(dev,\n\t\t\t     \"%llu sectors, multi %u: %s %s\\n\",\n\t\t\t     (unsigned long long)dev->n_sectors,\n\t\t\t     dev->multi_count, lba_desc, ncq_desc);\n\n\treturn ret;\n}\n\nstatic void ata_dev_config_chs(struct ata_device *dev)\n{\n\tconst u16 *id = dev->id;\n\n\tif (ata_id_current_chs_valid(id)) {\n\t\t \n\t\tdev->cylinders = id[54];\n\t\tdev->heads     = id[55];\n\t\tdev->sectors   = id[56];\n\t} else {\n\t\t \n\t\tdev->cylinders\t= id[1];\n\t\tdev->heads\t= id[3];\n\t\tdev->sectors\t= id[6];\n\t}\n\n\t \n\tif (ata_dev_print_info(dev))\n\t\tata_dev_info(dev,\n\t\t\t     \"%llu sectors, multi %u, CHS %u/%u/%u\\n\",\n\t\t\t     (unsigned long long)dev->n_sectors,\n\t\t\t     dev->multi_count, dev->cylinders,\n\t\t\t     dev->heads, dev->sectors);\n}\n\nstatic void ata_dev_config_fua(struct ata_device *dev)\n{\n\t \n\tif (!libata_fua)\n\t\tgoto nofua;\n\n\t \n\tif (!(dev->flags & ATA_DFLAG_LBA48) || !ata_id_has_fua(dev->id))\n\t\tgoto nofua;\n\n\t \n\tif (!ata_ncq_supported(dev) || (dev->horkage & ATA_HORKAGE_NO_FUA))\n\t\tgoto nofua;\n\n\tdev->flags |= ATA_DFLAG_FUA;\n\n\treturn;\n\nnofua:\n\tdev->flags &= ~ATA_DFLAG_FUA;\n}\n\nstatic void ata_dev_config_devslp(struct ata_device *dev)\n{\n\tu8 *sata_setting = dev->link->ap->sector_buf;\n\tunsigned int err_mask;\n\tint i, j;\n\n\t \n\tif (!ata_id_has_devslp(dev->id) ||\n\t    !ata_identify_page_supported(dev, ATA_LOG_SATA_SETTINGS))\n\t\treturn;\n\n\terr_mask = ata_read_log_page(dev,\n\t\t\t\t     ATA_LOG_IDENTIFY_DEVICE,\n\t\t\t\t     ATA_LOG_SATA_SETTINGS,\n\t\t\t\t     sata_setting, 1);\n\tif (err_mask)\n\t\treturn;\n\n\tdev->flags |= ATA_DFLAG_DEVSLP;\n\tfor (i = 0; i < ATA_LOG_DEVSLP_SIZE; i++) {\n\t\tj = ATA_LOG_DEVSLP_OFFSET + i;\n\t\tdev->devslp_timing[i] = sata_setting[j];\n\t}\n}\n\nstatic void ata_dev_config_cpr(struct ata_device *dev)\n{\n\tunsigned int err_mask;\n\tsize_t buf_len;\n\tint i, nr_cpr = 0;\n\tstruct ata_cpr_log *cpr_log = NULL;\n\tu8 *desc, *buf = NULL;\n\n\tif (ata_id_major_version(dev->id) < 11)\n\t\tgoto out;\n\n\tbuf_len = ata_log_supported(dev, ATA_LOG_CONCURRENT_POSITIONING_RANGES);\n\tif (buf_len == 0)\n\t\tgoto out;\n\n\t \n\tbuf_len <<= 9;\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\terr_mask = ata_read_log_page(dev, ATA_LOG_CONCURRENT_POSITIONING_RANGES,\n\t\t\t\t     0, buf, buf_len >> 9);\n\tif (err_mask)\n\t\tgoto out;\n\n\tnr_cpr = buf[0];\n\tif (!nr_cpr)\n\t\tgoto out;\n\n\tcpr_log = kzalloc(struct_size(cpr_log, cpr, nr_cpr), GFP_KERNEL);\n\tif (!cpr_log)\n\t\tgoto out;\n\n\tcpr_log->nr_cpr = nr_cpr;\n\tdesc = &buf[64];\n\tfor (i = 0; i < nr_cpr; i++, desc += 32) {\n\t\tcpr_log->cpr[i].num = desc[0];\n\t\tcpr_log->cpr[i].num_storage_elements = desc[1];\n\t\tcpr_log->cpr[i].start_lba = get_unaligned_le64(&desc[8]);\n\t\tcpr_log->cpr[i].num_lbas = get_unaligned_le64(&desc[16]);\n\t}\n\nout:\n\tswap(dev->cpr_log, cpr_log);\n\tkfree(cpr_log);\n\tkfree(buf);\n}\n\nstatic void ata_dev_print_features(struct ata_device *dev)\n{\n\tif (!(dev->flags & ATA_DFLAG_FEATURES_MASK))\n\t\treturn;\n\n\tata_dev_info(dev,\n\t\t     \"Features:%s%s%s%s%s%s%s%s\\n\",\n\t\t     dev->flags & ATA_DFLAG_FUA ? \" FUA\" : \"\",\n\t\t     dev->flags & ATA_DFLAG_TRUSTED ? \" Trust\" : \"\",\n\t\t     dev->flags & ATA_DFLAG_DA ? \" Dev-Attention\" : \"\",\n\t\t     dev->flags & ATA_DFLAG_DEVSLP ? \" Dev-Sleep\" : \"\",\n\t\t     dev->flags & ATA_DFLAG_NCQ_SEND_RECV ? \" NCQ-sndrcv\" : \"\",\n\t\t     dev->flags & ATA_DFLAG_NCQ_PRIO ? \" NCQ-prio\" : \"\",\n\t\t     dev->flags & ATA_DFLAG_CDL ? \" CDL\" : \"\",\n\t\t     dev->cpr_log ? \" CPR\" : \"\");\n}\n\n \nint ata_dev_configure(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tbool print_info = ata_dev_print_info(dev);\n\tconst u16 *id = dev->id;\n\tunsigned int xfer_mask;\n\tunsigned int err_mask;\n\tchar revbuf[7];\t\t \n\tchar fwrevbuf[ATA_ID_FW_REV_LEN+1];\n\tchar modelbuf[ATA_ID_PROD_LEN+1];\n\tint rc;\n\n\tif (!ata_dev_enabled(dev)) {\n\t\tata_dev_dbg(dev, \"no device\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tdev->horkage |= ata_dev_blacklisted(dev);\n\tata_force_horkage(dev);\n\n\tif (dev->horkage & ATA_HORKAGE_DISABLE) {\n\t\tata_dev_info(dev, \"unsupported device, disabling\\n\");\n\t\tata_dev_disable(dev);\n\t\treturn 0;\n\t}\n\n\tif ((!atapi_enabled || (ap->flags & ATA_FLAG_NO_ATAPI)) &&\n\t    dev->class == ATA_DEV_ATAPI) {\n\t\tata_dev_warn(dev, \"WARNING: ATAPI is %s, device ignored\\n\",\n\t\t\t     atapi_enabled ? \"not supported with this driver\"\n\t\t\t     : \"disabled\");\n\t\tata_dev_disable(dev);\n\t\treturn 0;\n\t}\n\n\trc = ata_do_link_spd_horkage(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif ((dev->horkage & ATA_HORKAGE_WD_BROKEN_LPM) &&\n\t    (id[ATA_ID_SATA_CAPABILITY] & 0xe) == 0x2)\n\t\tdev->horkage |= ATA_HORKAGE_NOLPM;\n\n\tif (ap->flags & ATA_FLAG_NO_LPM)\n\t\tdev->horkage |= ATA_HORKAGE_NOLPM;\n\n\tif (dev->horkage & ATA_HORKAGE_NOLPM) {\n\t\tata_dev_warn(dev, \"LPM support broken, forcing max_power\\n\");\n\t\tdev->link->ap->target_lpm_policy = ATA_LPM_MAX_POWER;\n\t}\n\n\t \n\trc = ata_acpi_on_devcfg(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = ata_hpa_resize(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tata_dev_dbg(dev,\n\t\t    \"%s: cfg 49:%04x 82:%04x 83:%04x 84:%04x \"\n\t\t    \"85:%04x 86:%04x 87:%04x 88:%04x\\n\",\n\t\t    __func__,\n\t\t    id[49], id[82], id[83], id[84],\n\t\t    id[85], id[86], id[87], id[88]);\n\n\t \n\tdev->flags &= ~ATA_DFLAG_CFG_MASK;\n\tdev->max_sectors = 0;\n\tdev->cdb_len = 0;\n\tdev->n_sectors = 0;\n\tdev->cylinders = 0;\n\tdev->heads = 0;\n\tdev->sectors = 0;\n\tdev->multi_count = 0;\n\n\t \n\n\t \n\txfer_mask = ata_id_xfermask(id);\n\n\tata_dump_id(dev, id);\n\n\t \n\tata_id_c_string(dev->id, fwrevbuf, ATA_ID_FW_REV,\n\t\t\tsizeof(fwrevbuf));\n\n\tata_id_c_string(dev->id, modelbuf, ATA_ID_PROD,\n\t\t\tsizeof(modelbuf));\n\n\t \n\tif (dev->class == ATA_DEV_ATA || dev->class == ATA_DEV_ZAC) {\n\t\tif (ata_id_is_cfa(id)) {\n\t\t\t \n\t\t\tif (id[ATA_ID_CFA_KEY_MGMT] & 1)\n\t\t\t\tata_dev_warn(dev,\n\t\"supports DRM functions and may not be fully accessible\\n\");\n\t\t\tsnprintf(revbuf, 7, \"CFA\");\n\t\t} else {\n\t\t\tsnprintf(revbuf, 7, \"ATA-%d\", ata_id_major_version(id));\n\t\t\t \n\t\t\tif (ata_id_has_tpm(id))\n\t\t\t\tata_dev_warn(dev,\n\t\"supports DRM functions and may not be fully accessible\\n\");\n\t\t}\n\n\t\tdev->n_sectors = ata_id_n_sectors(id);\n\n\t\t \n\t\tif ((dev->id[47] >> 8) == 0x80 && (dev->id[59] & 0x100)) {\n\t\t\tunsigned int max = dev->id[47] & 0xff;\n\t\t\tunsigned int cnt = dev->id[59] & 0xff;\n\t\t\t \n\t\t\tif (is_power_of_2(max) && is_power_of_2(cnt))\n\t\t\t\tif (cnt <= max)\n\t\t\t\t\tdev->multi_count = cnt;\n\t\t}\n\n\t\t \n\t\tif (print_info)\n\t\t\tata_dev_info(dev, \"%s: %s, %s, max %s\\n\",\n\t\t\t\t     revbuf, modelbuf, fwrevbuf,\n\t\t\t\t     ata_mode_string(xfer_mask));\n\n\t\tif (ata_id_has_lba(id)) {\n\t\t\trc = ata_dev_config_lba(dev);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else {\n\t\t\tata_dev_config_chs(dev);\n\t\t}\n\n\t\tata_dev_config_fua(dev);\n\t\tata_dev_config_devslp(dev);\n\t\tata_dev_config_sense_reporting(dev);\n\t\tata_dev_config_zac(dev);\n\t\tata_dev_config_trusted(dev);\n\t\tata_dev_config_cpr(dev);\n\t\tata_dev_config_cdl(dev);\n\t\tdev->cdb_len = 32;\n\n\t\tif (print_info)\n\t\t\tata_dev_print_features(dev);\n\t}\n\n\t \n\telse if (dev->class == ATA_DEV_ATAPI) {\n\t\tconst char *cdb_intr_string = \"\";\n\t\tconst char *atapi_an_string = \"\";\n\t\tconst char *dma_dir_string = \"\";\n\t\tu32 sntf;\n\n\t\trc = atapi_cdb_len(id);\n\t\tif ((rc < 12) || (rc > ATAPI_CDB_LEN)) {\n\t\t\tata_dev_warn(dev, \"unsupported CDB len %d\\n\", rc);\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out_nosup;\n\t\t}\n\t\tdev->cdb_len = (unsigned int) rc;\n\n\t\t \n\t\tif (atapi_an &&\n\t\t    (ap->flags & ATA_FLAG_AN) && ata_id_has_atapi_AN(id) &&\n\t\t    (!sata_pmp_attached(ap) ||\n\t\t     sata_scr_read(&ap->link, SCR_NOTIFICATION, &sntf) == 0)) {\n\t\t\t \n\t\t\terr_mask = ata_dev_set_feature(dev,\n\t\t\t\t\tSETFEATURES_SATA_ENABLE, SATA_AN);\n\t\t\tif (err_mask)\n\t\t\t\tata_dev_err(dev,\n\t\t\t\t\t    \"failed to enable ATAPI AN (err_mask=0x%x)\\n\",\n\t\t\t\t\t    err_mask);\n\t\t\telse {\n\t\t\t\tdev->flags |= ATA_DFLAG_AN;\n\t\t\t\tatapi_an_string = \", ATAPI AN\";\n\t\t\t}\n\t\t}\n\n\t\tif (ata_id_cdb_intr(dev->id)) {\n\t\t\tdev->flags |= ATA_DFLAG_CDB_INTR;\n\t\t\tcdb_intr_string = \", CDB intr\";\n\t\t}\n\n\t\tif (atapi_dmadir || (dev->horkage & ATA_HORKAGE_ATAPI_DMADIR) || atapi_id_dmadir(dev->id)) {\n\t\t\tdev->flags |= ATA_DFLAG_DMADIR;\n\t\t\tdma_dir_string = \", DMADIR\";\n\t\t}\n\n\t\tif (ata_id_has_da(dev->id)) {\n\t\t\tdev->flags |= ATA_DFLAG_DA;\n\t\t\tzpodd_init(dev);\n\t\t}\n\n\t\t \n\t\tif (print_info)\n\t\t\tata_dev_info(dev,\n\t\t\t\t     \"ATAPI: %s, %s, max %s%s%s%s\\n\",\n\t\t\t\t     modelbuf, fwrevbuf,\n\t\t\t\t     ata_mode_string(xfer_mask),\n\t\t\t\t     cdb_intr_string, atapi_an_string,\n\t\t\t\t     dma_dir_string);\n\t}\n\n\t \n\tdev->max_sectors = ATA_MAX_SECTORS;\n\tif (dev->flags & ATA_DFLAG_LBA48)\n\t\tdev->max_sectors = ATA_MAX_SECTORS_LBA48;\n\n\t \n\tif (ata_dev_knobble(dev)) {\n\t\tif (print_info)\n\t\t\tata_dev_info(dev, \"applying bridge limits\\n\");\n\t\tdev->udma_mask &= ATA_UDMA5;\n\t\tdev->max_sectors = ATA_MAX_SECTORS;\n\t}\n\n\tif ((dev->class == ATA_DEV_ATAPI) &&\n\t    (atapi_command_packet_set(id) == TYPE_TAPE)) {\n\t\tdev->max_sectors = ATA_MAX_SECTORS_TAPE;\n\t\tdev->horkage |= ATA_HORKAGE_STUCK_ERR;\n\t}\n\n\tif (dev->horkage & ATA_HORKAGE_MAX_SEC_128)\n\t\tdev->max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_128,\n\t\t\t\t\t dev->max_sectors);\n\n\tif (dev->horkage & ATA_HORKAGE_MAX_SEC_1024)\n\t\tdev->max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_1024,\n\t\t\t\t\t dev->max_sectors);\n\n\tif (dev->horkage & ATA_HORKAGE_MAX_SEC_LBA48)\n\t\tdev->max_sectors = ATA_MAX_SECTORS_LBA48;\n\n\tif (ap->ops->dev_config)\n\t\tap->ops->dev_config(dev);\n\n\tif (dev->horkage & ATA_HORKAGE_DIAGNOSTIC) {\n\t\t \n\n\t\tif (print_info) {\n\t\t\tata_dev_warn(dev,\n\"Drive reports diagnostics failure. This may indicate a drive\\n\");\n\t\t\tata_dev_warn(dev,\n\"fault or invalid emulation. Contact drive vendor for information.\\n\");\n\t\t}\n\t}\n\n\tif ((dev->horkage & ATA_HORKAGE_FIRMWARE_WARN) && print_info) {\n\t\tata_dev_warn(dev, \"WARNING: device requires firmware update to be fully functional\\n\");\n\t\tata_dev_warn(dev, \"         contact the vendor or visit http://ata.wiki.kernel.org\\n\");\n\t}\n\n\treturn 0;\n\nerr_out_nosup:\n\treturn rc;\n}\n\n \n\nint ata_cable_40wire(struct ata_port *ap)\n{\n\treturn ATA_CBL_PATA40;\n}\nEXPORT_SYMBOL_GPL(ata_cable_40wire);\n\n \n\nint ata_cable_80wire(struct ata_port *ap)\n{\n\treturn ATA_CBL_PATA80;\n}\nEXPORT_SYMBOL_GPL(ata_cable_80wire);\n\n \n\nint ata_cable_unknown(struct ata_port *ap)\n{\n\treturn ATA_CBL_PATA_UNK;\n}\nEXPORT_SYMBOL_GPL(ata_cable_unknown);\n\n \nint ata_cable_ignore(struct ata_port *ap)\n{\n\treturn ATA_CBL_PATA_IGN;\n}\nEXPORT_SYMBOL_GPL(ata_cable_ignore);\n\n \n\nint ata_cable_sata(struct ata_port *ap)\n{\n\treturn ATA_CBL_SATA;\n}\nEXPORT_SYMBOL_GPL(ata_cable_sata);\n\n \nstatic void sata_print_link_status(struct ata_link *link)\n{\n\tu32 sstatus, scontrol, tmp;\n\n\tif (sata_scr_read(link, SCR_STATUS, &sstatus))\n\t\treturn;\n\tif (sata_scr_read(link, SCR_CONTROL, &scontrol))\n\t\treturn;\n\n\tif (ata_phys_link_online(link)) {\n\t\ttmp = (sstatus >> 4) & 0xf;\n\t\tata_link_info(link, \"SATA link up %s (SStatus %X SControl %X)\\n\",\n\t\t\t      sata_spd_string(tmp), sstatus, scontrol);\n\t} else {\n\t\tata_link_info(link, \"SATA link down (SStatus %X SControl %X)\\n\",\n\t\t\t      sstatus, scontrol);\n\t}\n}\n\n \n\nstruct ata_device *ata_dev_pair(struct ata_device *adev)\n{\n\tstruct ata_link *link = adev->link;\n\tstruct ata_device *pair = &link->device[1 - adev->devno];\n\tif (!ata_dev_enabled(pair))\n\t\treturn NULL;\n\treturn pair;\n}\nEXPORT_SYMBOL_GPL(ata_dev_pair);\n\n \nint sata_down_spd_limit(struct ata_link *link, u32 spd_limit)\n{\n\tu32 sstatus, spd, mask;\n\tint rc, bit;\n\n\tif (!sata_scr_valid(link))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\trc = sata_scr_read(link, SCR_STATUS, &sstatus);\n\tif (rc == 0 && ata_sstatus_online(sstatus))\n\t\tspd = (sstatus >> 4) & 0xf;\n\telse\n\t\tspd = link->sata_spd;\n\n\tmask = link->sata_spd_limit;\n\tif (mask <= 1)\n\t\treturn -EINVAL;\n\n\t \n\tbit = fls(mask) - 1;\n\tmask &= ~(1 << bit);\n\n\t \n\tif (spd > 1)\n\t\tmask &= (1 << (spd - 1)) - 1;\n\telse if (link->sata_spd)\n\t\treturn -EINVAL;\n\n\t \n\tif (!mask)\n\t\treturn -EINVAL;\n\n\tif (spd_limit) {\n\t\tif (mask & ((1 << spd_limit) - 1))\n\t\t\tmask &= (1 << spd_limit) - 1;\n\t\telse {\n\t\t\tbit = ffs(mask) - 1;\n\t\t\tmask = 1 << bit;\n\t\t}\n\t}\n\n\tlink->sata_spd_limit = mask;\n\n\tata_link_warn(link, \"limiting SATA link speed to %s\\n\",\n\t\t      sata_spd_string(fls(mask)));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ATA_ACPI\n \nu8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle)\n{\n\tu8 base_mode = 0xff, last_mode = 0xff;\n\tconst struct ata_xfer_ent *ent;\n\tconst struct ata_timing *t;\n\n\tfor (ent = ata_xfer_tbl; ent->shift >= 0; ent++)\n\t\tif (ent->shift == xfer_shift)\n\t\t\tbase_mode = ent->base;\n\n\tfor (t = ata_timing_find_mode(base_mode);\n\t     t && ata_xfer_mode2shift(t->mode) == xfer_shift; t++) {\n\t\tunsigned short this_cycle;\n\n\t\tswitch (xfer_shift) {\n\t\tcase ATA_SHIFT_PIO:\n\t\tcase ATA_SHIFT_MWDMA:\n\t\t\tthis_cycle = t->cycle;\n\t\t\tbreak;\n\t\tcase ATA_SHIFT_UDMA:\n\t\t\tthis_cycle = t->udma;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0xff;\n\t\t}\n\n\t\tif (cycle > this_cycle)\n\t\t\tbreak;\n\n\t\tlast_mode = t->mode;\n\t}\n\n\treturn last_mode;\n}\n#endif\n\n \nint ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel)\n{\n\tchar buf[32];\n\tunsigned int orig_mask, xfer_mask;\n\tunsigned int pio_mask, mwdma_mask, udma_mask;\n\tint quiet, highbit;\n\n\tquiet = !!(sel & ATA_DNXFER_QUIET);\n\tsel &= ~ATA_DNXFER_QUIET;\n\n\txfer_mask = orig_mask = ata_pack_xfermask(dev->pio_mask,\n\t\t\t\t\t\t  dev->mwdma_mask,\n\t\t\t\t\t\t  dev->udma_mask);\n\tata_unpack_xfermask(xfer_mask, &pio_mask, &mwdma_mask, &udma_mask);\n\n\tswitch (sel) {\n\tcase ATA_DNXFER_PIO:\n\t\thighbit = fls(pio_mask) - 1;\n\t\tpio_mask &= ~(1 << highbit);\n\t\tbreak;\n\n\tcase ATA_DNXFER_DMA:\n\t\tif (udma_mask) {\n\t\t\thighbit = fls(udma_mask) - 1;\n\t\t\tudma_mask &= ~(1 << highbit);\n\t\t\tif (!udma_mask)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (mwdma_mask) {\n\t\t\thighbit = fls(mwdma_mask) - 1;\n\t\t\tmwdma_mask &= ~(1 << highbit);\n\t\t\tif (!mwdma_mask)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t\tbreak;\n\n\tcase ATA_DNXFER_40C:\n\t\tudma_mask &= ATA_UDMA_MASK_40C;\n\t\tbreak;\n\n\tcase ATA_DNXFER_FORCE_PIO0:\n\t\tpio_mask &= 1;\n\t\tfallthrough;\n\tcase ATA_DNXFER_FORCE_PIO:\n\t\tmwdma_mask = 0;\n\t\tudma_mask = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\txfer_mask &= ata_pack_xfermask(pio_mask, mwdma_mask, udma_mask);\n\n\tif (!(xfer_mask & ATA_MASK_PIO) || xfer_mask == orig_mask)\n\t\treturn -ENOENT;\n\n\tif (!quiet) {\n\t\tif (xfer_mask & (ATA_MASK_MWDMA | ATA_MASK_UDMA))\n\t\t\tsnprintf(buf, sizeof(buf), \"%s:%s\",\n\t\t\t\t ata_mode_string(xfer_mask),\n\t\t\t\t ata_mode_string(xfer_mask & ATA_MASK_PIO));\n\t\telse\n\t\t\tsnprintf(buf, sizeof(buf), \"%s\",\n\t\t\t\t ata_mode_string(xfer_mask));\n\n\t\tata_dev_warn(dev, \"limiting speed to %s\\n\", buf);\n\t}\n\n\tata_unpack_xfermask(xfer_mask, &dev->pio_mask, &dev->mwdma_mask,\n\t\t\t    &dev->udma_mask);\n\n\treturn 0;\n}\n\nstatic int ata_dev_set_mode(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\tconst bool nosetxfer = dev->horkage & ATA_HORKAGE_NOSETXFER;\n\tconst char *dev_err_whine = \"\";\n\tint ign_dev_err = 0;\n\tunsigned int err_mask = 0;\n\tint rc;\n\n\tdev->flags &= ~ATA_DFLAG_PIO;\n\tif (dev->xfer_shift == ATA_SHIFT_PIO)\n\t\tdev->flags |= ATA_DFLAG_PIO;\n\n\tif (nosetxfer && ap->flags & ATA_FLAG_SATA && ata_id_is_sata(dev->id))\n\t\tdev_err_whine = \" (SET_XFERMODE skipped)\";\n\telse {\n\t\tif (nosetxfer)\n\t\t\tata_dev_warn(dev,\n\t\t\t\t     \"NOSETXFER but PATA detected - can't \"\n\t\t\t\t     \"skip SETXFER, might malfunction\\n\");\n\t\terr_mask = ata_dev_set_xfermode(dev);\n\t}\n\n\tif (err_mask & ~AC_ERR_DEV)\n\t\tgoto fail;\n\n\t \n\tehc->i.flags |= ATA_EHI_POST_SETMODE;\n\trc = ata_dev_revalidate(dev, ATA_DEV_UNKNOWN, 0);\n\tehc->i.flags &= ~ATA_EHI_POST_SETMODE;\n\tif (rc)\n\t\treturn rc;\n\n\tif (dev->xfer_shift == ATA_SHIFT_PIO) {\n\t\t \n\t\tif (ata_id_is_cfa(dev->id))\n\t\t\tign_dev_err = 1;\n\t\t \n\t\tif (ata_id_major_version(dev->id) == 0 &&\n\t\t\t\t\tdev->pio_mode <= XFER_PIO_2)\n\t\t\tign_dev_err = 1;\n\t\t \n\t\tif (!ata_id_has_iordy(dev->id) && dev->pio_mode <= XFER_PIO_2)\n\t\t\tign_dev_err = 1;\n\t}\n\t \n\tif (dev->xfer_shift == ATA_SHIFT_MWDMA &&\n\t    dev->dma_mode == XFER_MW_DMA_0 &&\n\t    (dev->id[63] >> 8) & 1)\n\t\tign_dev_err = 1;\n\n\t \n\tif (dev->xfer_mode == ata_xfer_mask2mode(ata_id_xfermask(dev->id)))\n\t\tign_dev_err = 1;\n\n\tif (err_mask & AC_ERR_DEV) {\n\t\tif (!ign_dev_err)\n\t\t\tgoto fail;\n\t\telse\n\t\t\tdev_err_whine = \" (device error ignored)\";\n\t}\n\n\tata_dev_dbg(dev, \"xfer_shift=%u, xfer_mode=0x%x\\n\",\n\t\t    dev->xfer_shift, (int)dev->xfer_mode);\n\n\tif (!(ehc->i.flags & ATA_EHI_QUIET) ||\n\t    ehc->i.flags & ATA_EHI_DID_HARDRESET)\n\t\tata_dev_info(dev, \"configured for %s%s\\n\",\n\t\t\t     ata_mode_string(ata_xfer_mode2mask(dev->xfer_mode)),\n\t\t\t     dev_err_whine);\n\n\treturn 0;\n\n fail:\n\tata_dev_err(dev, \"failed to set xfermode (err_mask=0x%x)\\n\", err_mask);\n\treturn -EIO;\n}\n\n \n\nint ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *dev;\n\tint rc = 0, used_dma = 0, found = 0;\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tunsigned int pio_mask, dma_mask;\n\t\tunsigned int mode_mask;\n\n\t\tmode_mask = ATA_DMA_MASK_ATA;\n\t\tif (dev->class == ATA_DEV_ATAPI)\n\t\t\tmode_mask = ATA_DMA_MASK_ATAPI;\n\t\telse if (ata_id_is_cfa(dev->id))\n\t\t\tmode_mask = ATA_DMA_MASK_CFA;\n\n\t\tata_dev_xfermask(dev);\n\t\tata_force_xfermask(dev);\n\n\t\tpio_mask = ata_pack_xfermask(dev->pio_mask, 0, 0);\n\n\t\tif (libata_dma_mask & mode_mask)\n\t\t\tdma_mask = ata_pack_xfermask(0, dev->mwdma_mask,\n\t\t\t\t\t\t     dev->udma_mask);\n\t\telse\n\t\t\tdma_mask = 0;\n\n\t\tdev->pio_mode = ata_xfer_mask2mode(pio_mask);\n\t\tdev->dma_mode = ata_xfer_mask2mode(dma_mask);\n\n\t\tfound = 1;\n\t\tif (ata_dma_enabled(dev))\n\t\t\tused_dma = 1;\n\t}\n\tif (!found)\n\t\tgoto out;\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tif (dev->pio_mode == 0xff) {\n\t\t\tata_dev_warn(dev, \"no PIO support\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev->xfer_mode = dev->pio_mode;\n\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\tif (ap->ops->set_piomode)\n\t\t\tap->ops->set_piomode(ap, dev);\n\t}\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tif (!ata_dma_enabled(dev))\n\t\t\tcontinue;\n\n\t\tdev->xfer_mode = dev->dma_mode;\n\t\tdev->xfer_shift = ata_xfer_mode2shift(dev->dma_mode);\n\t\tif (ap->ops->set_dmamode)\n\t\t\tap->ops->set_dmamode(ap, dev);\n\t}\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\trc = ata_dev_set_mode(dev);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (used_dma && (ap->host->flags & ATA_HOST_SIMPLEX))\n\t\tap->host->simplex_claimed = ap;\n\n out:\n\tif (rc)\n\t\t*r_failed_dev = dev;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_do_set_mode);\n\n \nint ata_wait_ready(struct ata_link *link, unsigned long deadline,\n\t\t   int (*check_ready)(struct ata_link *link))\n{\n\tunsigned long start = jiffies;\n\tunsigned long nodev_deadline;\n\tint warned = 0;\n\n\t \n\tif (link->ap->host->flags & ATA_HOST_PARALLEL_SCAN)\n\t\tnodev_deadline = ata_deadline(start, ATA_TMOUT_FF_WAIT_LONG);\n\telse\n\t\tnodev_deadline = ata_deadline(start, ATA_TMOUT_FF_WAIT);\n\n\t \n\tWARN_ON(link == link->ap->slave_link);\n\n\tif (time_after(nodev_deadline, deadline))\n\t\tnodev_deadline = deadline;\n\n\twhile (1) {\n\t\tunsigned long now = jiffies;\n\t\tint ready, tmp;\n\n\t\tready = tmp = check_ready(link);\n\t\tif (ready > 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (ready == -ENODEV) {\n\t\t\tif (ata_link_online(link))\n\t\t\t\tready = 0;\n\t\t\telse if ((link->ap->flags & ATA_FLAG_SATA) &&\n\t\t\t\t !ata_link_offline(link) &&\n\t\t\t\t time_before(now, nodev_deadline))\n\t\t\t\tready = 0;\n\t\t}\n\n\t\tif (ready)\n\t\t\treturn ready;\n\t\tif (time_after(now, deadline))\n\t\t\treturn -EBUSY;\n\n\t\tif (!warned && time_after(now, start + 5 * HZ) &&\n\t\t    (deadline - now > 3 * HZ)) {\n\t\t\tata_link_warn(link,\n\t\t\t\t\"link is slow to respond, please be patient \"\n\t\t\t\t\"(ready=%d)\\n\", tmp);\n\t\t\twarned = 1;\n\t\t}\n\n\t\tata_msleep(link->ap, 50);\n\t}\n}\n\n \nint ata_wait_after_reset(struct ata_link *link, unsigned long deadline,\n\t\t\t\tint (*check_ready)(struct ata_link *link))\n{\n\tata_msleep(link->ap, ATA_WAIT_AFTER_RESET);\n\n\treturn ata_wait_ready(link, deadline, check_ready);\n}\nEXPORT_SYMBOL_GPL(ata_wait_after_reset);\n\n \nint ata_std_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tconst unsigned int *timing = sata_ehc_deb_timing(ehc);\n\tint rc;\n\n\t \n\tif (ehc->i.action & ATA_EH_HARDRESET)\n\t\treturn 0;\n\n\t \n\tif (ap->flags & ATA_FLAG_SATA) {\n\t\trc = sata_link_resume(link, timing, deadline);\n\t\t \n\t\tif (rc && rc != -EOPNOTSUPP)\n\t\t\tata_link_warn(link,\n\t\t\t\t      \"failed to resume link for reset (errno=%d)\\n\",\n\t\t\t\t      rc);\n\t}\n\n\t \n\tif (ata_phys_link_offline(link))\n\t\tehc->i.action &= ~ATA_EH_SOFTRESET;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_std_prereset);\n\n \nint sata_std_hardreset(struct ata_link *link, unsigned int *class,\n\t\t       unsigned long deadline)\n{\n\tconst unsigned int *timing = sata_ehc_deb_timing(&link->eh_context);\n\tbool online;\n\tint rc;\n\n\t \n\trc = sata_link_hardreset(link, timing, deadline, &online, NULL);\n\treturn online ? -EAGAIN : rc;\n}\nEXPORT_SYMBOL_GPL(sata_std_hardreset);\n\n \nvoid ata_std_postreset(struct ata_link *link, unsigned int *classes)\n{\n\tu32 serror;\n\n\t \n\tif (!sata_scr_read(link, SCR_ERROR, &serror))\n\t\tsata_scr_write(link, SCR_ERROR, serror);\n\n\t \n\tsata_print_link_status(link);\n}\nEXPORT_SYMBOL_GPL(ata_std_postreset);\n\n \nstatic int ata_dev_same_device(struct ata_device *dev, unsigned int new_class,\n\t\t\t       const u16 *new_id)\n{\n\tconst u16 *old_id = dev->id;\n\tunsigned char model[2][ATA_ID_PROD_LEN + 1];\n\tunsigned char serial[2][ATA_ID_SERNO_LEN + 1];\n\n\tif (dev->class != new_class) {\n\t\tata_dev_info(dev, \"class mismatch %d != %d\\n\",\n\t\t\t     dev->class, new_class);\n\t\treturn 0;\n\t}\n\n\tata_id_c_string(old_id, model[0], ATA_ID_PROD, sizeof(model[0]));\n\tata_id_c_string(new_id, model[1], ATA_ID_PROD, sizeof(model[1]));\n\tata_id_c_string(old_id, serial[0], ATA_ID_SERNO, sizeof(serial[0]));\n\tata_id_c_string(new_id, serial[1], ATA_ID_SERNO, sizeof(serial[1]));\n\n\tif (strcmp(model[0], model[1])) {\n\t\tata_dev_info(dev, \"model number mismatch '%s' != '%s'\\n\",\n\t\t\t     model[0], model[1]);\n\t\treturn 0;\n\t}\n\n\tif (strcmp(serial[0], serial[1])) {\n\t\tata_dev_info(dev, \"serial number mismatch '%s' != '%s'\\n\",\n\t\t\t     serial[0], serial[1]);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nint ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags)\n{\n\tunsigned int class = dev->class;\n\tu16 *id = (void *)dev->link->ap->sector_buf;\n\tint rc;\n\n\t \n\trc = ata_dev_read_id(dev, &class, readid_flags, id);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (!ata_dev_same_device(dev, class, id))\n\t\treturn -ENODEV;\n\n\tmemcpy(dev->id, id, sizeof(id[0]) * ATA_ID_WORDS);\n\treturn 0;\n}\n\n \nint ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,\n\t\t       unsigned int readid_flags)\n{\n\tu64 n_sectors = dev->n_sectors;\n\tu64 n_native_sectors = dev->n_native_sectors;\n\tint rc;\n\n\tif (!ata_dev_enabled(dev))\n\t\treturn -ENODEV;\n\n\t \n\tif (ata_class_enabled(new_class) && new_class == ATA_DEV_PMP) {\n\t\tata_dev_info(dev, \"class mismatch %u != %u\\n\",\n\t\t\t     dev->class, new_class);\n\t\trc = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\t \n\trc = ata_dev_reread_id(dev, readid_flags);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\trc = ata_dev_configure(dev);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\tif (dev->class != ATA_DEV_ATA || !n_sectors ||\n\t    dev->n_sectors == n_sectors)\n\t\treturn 0;\n\n\t \n\tata_dev_warn(dev, \"n_sectors mismatch %llu != %llu\\n\",\n\t\t     (unsigned long long)n_sectors,\n\t\t     (unsigned long long)dev->n_sectors);\n\n\t \n\tif (dev->n_native_sectors == n_native_sectors &&\n\t    dev->n_sectors > n_sectors && dev->n_sectors == n_native_sectors) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"new n_sectors matches native, probably \"\n\t\t\t     \"late HPA unlock, n_sectors updated\\n\");\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (dev->n_native_sectors == n_native_sectors &&\n\t    dev->n_sectors < n_sectors && n_sectors == n_native_sectors &&\n\t    !(dev->horkage & ATA_HORKAGE_BROKEN_HPA)) {\n\t\tata_dev_warn(dev,\n\t\t\t     \"old n_sectors matches native, probably \"\n\t\t\t     \"late HPA lock, will try to unlock HPA\\n\");\n\t\t \n\t\tdev->flags |= ATA_DFLAG_UNLOCK_HPA;\n\t\trc = -EIO;\n\t} else\n\t\trc = -ENODEV;\n\n\t \n\tdev->n_native_sectors = n_native_sectors;\n\tdev->n_sectors = n_sectors;\n fail:\n\tata_dev_err(dev, \"revalidation failed (errno=%d)\\n\", rc);\n\treturn rc;\n}\n\nstruct ata_blacklist_entry {\n\tconst char *model_num;\n\tconst char *model_rev;\n\tunsigned long horkage;\n};\n\nstatic const struct ata_blacklist_entry ata_device_blacklist [] = {\n\t \n\t{ \"WDC AC11000H\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"WDC AC22100H\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"WDC AC32500H\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"WDC AC33100H\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"WDC AC31600H\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"WDC AC32100H\",\t\"24.09P07\",\tATA_HORKAGE_NODMA },\n\t{ \"WDC AC23200L\",\t\"21.10N21\",\tATA_HORKAGE_NODMA },\n\t{ \"Compaq CRD-8241B\", \tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"CRD-8400B\",\t\tNULL, \t\tATA_HORKAGE_NODMA },\n\t{ \"CRD-848[02]B\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"CRD-84\",\t\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"SanDisk SDP3B\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"SanDisk SDP3B-64\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"SANYO CD-ROM CRD\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"HITACHI CDR-8\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"HITACHI CDR-8[34]35\",NULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"Toshiba CD-ROM XM-6202B\", NULL,\tATA_HORKAGE_NODMA },\n\t{ \"TOSHIBA CD-ROM XM-1702BC\", NULL,\tATA_HORKAGE_NODMA },\n\t{ \"CD-532E-A\", \t\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"E-IDE CD-ROM CR-840\",NULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"CD-ROM Drive/F5A\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"WPI CDD-820\", \tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"SAMSUNG CD-ROM SC-148C\", NULL,\tATA_HORKAGE_NODMA },\n\t{ \"SAMSUNG CD-ROM SC\",\tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"ATAPI CD-ROM DRIVE 40X MAXIMUM\",NULL,ATA_HORKAGE_NODMA },\n\t{ \"_NEC DV5800A\", \tNULL,\t\tATA_HORKAGE_NODMA },\n\t{ \"SAMSUNG CD-ROM SN-124\", \"N001\",\tATA_HORKAGE_NODMA },\n\t{ \"Seagate STT20000A\", NULL,\t\tATA_HORKAGE_NODMA },\n\t{ \" 2GB ATA Flash Disk\", \"ADMA428M\",\tATA_HORKAGE_NODMA },\n\t{ \"VRFDFC22048UCHC-TE*\", NULL,\t\tATA_HORKAGE_NODMA },\n\t \n\t{ \"Config  Disk\",\tNULL,\t\tATA_HORKAGE_DISABLE },\n\t \n\t{ \"ASMT109x- Config\",\tNULL,\t\tATA_HORKAGE_DISABLE },\n\n\t \n\t{ \"TORiSAN DVD-ROM DRD-N216\", NULL,\tATA_HORKAGE_MAX_SEC_128 },\n\t{ \"QUANTUM DAT    DAT72-000\", NULL,\tATA_HORKAGE_ATAPI_MOD16_DMA },\n\t{ \"Slimtype DVD A  DS8A8SH\", NULL,\tATA_HORKAGE_MAX_SEC_LBA48 },\n\t{ \"Slimtype DVD A  DS8A9SH\", NULL,\tATA_HORKAGE_MAX_SEC_LBA48 },\n\n\t \n\t{ \"ST380013AS\",\t\t\"3.20\",\t\tATA_HORKAGE_MAX_SEC_1024 },\n\n\t \n\t{ \"LITEON CX1-JB*-HP\",\tNULL,\t\tATA_HORKAGE_MAX_SEC_1024 },\n\t{ \"LITEON EP1-*\",\tNULL,\t\tATA_HORKAGE_MAX_SEC_1024 },\n\n\t \n\n\t \n\t \n\t{ \"WDC WD740ADFD-00\",\tNULL,\t\tATA_HORKAGE_NONCQ },\n\t{ \"WDC WD740ADFD-00NLR1\", NULL,\t\tATA_HORKAGE_NONCQ },\n\t \n\t{ \"FUJITSU MHT2060BH\",\tNULL,\t\tATA_HORKAGE_NONCQ },\n\t \n\t{ \"Maxtor *\",\t\t\"BANC*\",\tATA_HORKAGE_NONCQ },\n\t{ \"Maxtor 7V300F0\",\t\"VA111630\",\tATA_HORKAGE_NONCQ },\n\t{ \"ST380817AS\",\t\t\"3.42\",\t\tATA_HORKAGE_NONCQ },\n\t{ \"ST3160023AS\",\t\"3.42\",\t\tATA_HORKAGE_NONCQ },\n\t{ \"OCZ CORE_SSD\",\t\"02.10104\",\tATA_HORKAGE_NONCQ },\n\n\t \n\t{ \"ST31500341AS\",\t\"SD1[5-9]\",\tATA_HORKAGE_NONCQ |\n\t\t\t\t\t\tATA_HORKAGE_FIRMWARE_WARN },\n\n\t{ \"ST31000333AS\",\t\"SD1[5-9]\",\tATA_HORKAGE_NONCQ |\n\t\t\t\t\t\tATA_HORKAGE_FIRMWARE_WARN },\n\n\t{ \"ST3640[36]23AS\",\t\"SD1[5-9]\",\tATA_HORKAGE_NONCQ |\n\t\t\t\t\t\tATA_HORKAGE_FIRMWARE_WARN },\n\n\t{ \"ST3320[68]13AS\",\t\"SD1[5-9]\",\tATA_HORKAGE_NONCQ |\n\t\t\t\t\t\tATA_HORKAGE_FIRMWARE_WARN },\n\n\t \n\t{ \"ST1000LM024 HN-M101MBB\", NULL,\tATA_HORKAGE_BROKEN_FPDMA_AA |\n\t\t\t\t\t\tATA_HORKAGE_NOLPM },\n\t{ \"VB0250EAVER\",\t\"HPG7\",\t\tATA_HORKAGE_BROKEN_FPDMA_AA },\n\n\t \n\t{ \"HTS541060G9SA00\",    \"MB3OC60D\",     ATA_HORKAGE_NONCQ },\n\t{ \"HTS541080G9SA00\",    \"MB4OC60D\",     ATA_HORKAGE_NONCQ },\n\t{ \"HTS541010G9SA00\",    \"MBZOC60D\",     ATA_HORKAGE_NONCQ },\n\n\t \n\t{ \"C300-CTFDDAC128MAG\",\t\"0001\",\t\tATA_HORKAGE_NONCQ },\n\n\t \n\t{ \"SanDisk SD[789]*\",\tNULL,\t\tATA_HORKAGE_MAX_TRIM_128M },\n\n\t \n\t{ \"HDS724040KLSA80\",\t\"KFAOA20N\",\tATA_HORKAGE_BROKEN_HPA },\n\t{ \"WDC WD3200JD-00KLB0\", \"WD-WCAMR1130137\", ATA_HORKAGE_BROKEN_HPA },\n\t{ \"WDC WD2500JD-00HBB0\", \"WD-WMAL71490727\", ATA_HORKAGE_BROKEN_HPA },\n\t{ \"MAXTOR 6L080L4\",\t\"A93.0500\",\tATA_HORKAGE_BROKEN_HPA },\n\n\t \n\t{ \"OCZ-VERTEX\",\t\t    \"1.30\",\tATA_HORKAGE_BROKEN_HPA },\n\n\t \n\t{ \"ST340823A\",\t\tNULL,\t\tATA_HORKAGE_HPA_SIZE },\n\t{ \"ST320413A\",\t\tNULL,\t\tATA_HORKAGE_HPA_SIZE },\n\t{ \"ST310211A\",\t\tNULL,\t\tATA_HORKAGE_HPA_SIZE },\n\n\t \n\t{ \"QUANTUM FIREBALLlct10 05\", \"A03.0900\", ATA_HORKAGE_IVB },\n\t \n\t{ \"TSSTcorp CDDVDW SH-S202[HJN]\", \"SB0[01]\",  ATA_HORKAGE_IVB },\n\n\t \n\t{ \"MTRON MSP-SATA*\",\t\tNULL,\tATA_HORKAGE_BRIDGE_OK },\n\t{ \"BUFFALO HD-QSU2/R5\",\t\tNULL,\tATA_HORKAGE_BRIDGE_OK },\n\n\t \n\t{ \"WD My Book\",\t\t\tNULL,\tATA_HORKAGE_1_5_GBPS },\n\t{ \"Seagate FreeAgent GoFlex\",\tNULL,\tATA_HORKAGE_1_5_GBPS },\n\n\t \n\t{ \"PIONEER DVD-RW  DVRTD08\",\tNULL,\tATA_HORKAGE_NOSETXFER },\n\t{ \"PIONEER DVD-RW  DVRTD08A\",\tNULL,\tATA_HORKAGE_NOSETXFER },\n\t{ \"PIONEER DVD-RW  DVR-215\",\tNULL,\tATA_HORKAGE_NOSETXFER },\n\t{ \"PIONEER DVD-RW  DVR-212D\",\tNULL,\tATA_HORKAGE_NOSETXFER },\n\t{ \"PIONEER DVD-RW  DVR-216D\",\tNULL,\tATA_HORKAGE_NOSETXFER },\n\n\t \n\t{ \"PIONEER BD-RW   BDR-207M\",\tNULL,\tATA_HORKAGE_NOLPM },\n\t{ \"PIONEER BD-RW   BDR-205\",\tNULL,\tATA_HORKAGE_NOLPM },\n\n\t \n\t{ \"CT500BX100SSD1\",\t\tNULL,\tATA_HORKAGE_NOLPM },\n\n\t \n\t{ \"Crucial_CT512MX100*\",\t\"MU01\",\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NOLPM },\n\t \n\t{ \"Crucial_CT512MX100*\",\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NOLPM },\n\n\t \n\t{ \"Crucial_CT480M500*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NOLPM },\n\t{ \"Crucial_CT960M500*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NOLPM },\n\n\t \n\t{ \"SAMSUNG MZMPC128HBFU-000MV\", \"CXM14M1Q\", ATA_HORKAGE_NOLPM },\n\t{ \"SAMSUNG SSD PM830 mSATA *\",  \"CXM13D1Q\", ATA_HORKAGE_NOLPM },\n\t{ \"SAMSUNG MZ7TD256HAFV-000L9\", NULL,       ATA_HORKAGE_NOLPM },\n\t{ \"SAMSUNG MZ7TE512HMHP-000L1\", \"EXT06L0Q\", ATA_HORKAGE_NOLPM },\n\n\t \n\t{ \"Micron_M500IT_*\",\t\t\"MU01\",\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Micron_M500_*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Micron_M5[15]0_*\",\t\t\"MU01\",\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Micron_1100_*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM, },\n\t{ \"Crucial_CT*M500*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Crucial_CT*M550*\",\t\t\"MU01\",\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Crucial_CT*MX100*\",\t\t\"MU01\",\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Samsung SSD 840 EVO*\",\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NO_DMA_LOG |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Samsung SSD 840*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Samsung SSD 850*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Samsung SSD 860*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NO_NCQ_ON_ATI },\n\t{ \"Samsung SSD 870*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NO_NCQ_ON_ATI },\n\t{ \"SAMSUNG*MZ7LH*\",\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_NO_NCQ_ON_ATI, },\n\t{ \"FCCT*M500*\",\t\t\tNULL,\tATA_HORKAGE_NO_NCQ_TRIM |\n\t\t\t\t\t\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\n\t \n\t{ \"SuperSSpeed S238*\",\t\tNULL,\tATA_HORKAGE_NOTRIM },\n\t{ \"M88V29*\",\t\t\tNULL,\tATA_HORKAGE_NOTRIM },\n\n\t \n\n\t \n\t{ \"INTEL*SSDSC2MH*\",\t\tNULL,\t0 },\n\n\t{ \"Micron*\",\t\t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Crucial*\",\t\t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"INTEL*SSD*\", \t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"SSD*INTEL*\",\t\t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"Samsung*SSD*\",\t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"SAMSUNG*SSD*\",\t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"SAMSUNG*MZ7KM*\",\t\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\t{ \"ST[1248][0248]0[FH]*\",\tNULL,\tATA_HORKAGE_ZERO_AFTER_TRIM },\n\n\t \n\t{ \"WDC WD800JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\t{ \"WDC WD1200JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\t{ \"WDC WD1600JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\t{ \"WDC WD2000JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\t{ \"WDC WD2500JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\t{ \"WDC WD3000JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\t{ \"WDC WD3200JD-*\",\t\tNULL,\tATA_HORKAGE_WD_BROKEN_LPM },\n\n\t \n\t{ \"SATADOM-ML 3ME\",\t\tNULL,\tATA_HORKAGE_NO_LOG_DIR },\n\n\t \n\t{ \"Maxtor\",\t\t\"BANC1G10\",\tATA_HORKAGE_NO_FUA },\n\t{ \"WDC*WD2500J*\",\tNULL,\t\tATA_HORKAGE_NO_FUA },\n\t{ \"OCZ-VERTEX*\",\tNULL,\t\tATA_HORKAGE_NO_FUA },\n\t{ \"INTEL*SSDSC2CT*\",\tNULL,\t\tATA_HORKAGE_NO_FUA },\n\n\t \n\t{ }\n};\n\nstatic unsigned long ata_dev_blacklisted(const struct ata_device *dev)\n{\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\tunsigned char model_rev[ATA_ID_FW_REV_LEN + 1];\n\tconst struct ata_blacklist_entry *ad = ata_device_blacklist;\n\n\tata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\tata_id_c_string(dev->id, model_rev, ATA_ID_FW_REV, sizeof(model_rev));\n\n\twhile (ad->model_num) {\n\t\tif (glob_match(ad->model_num, model_num)) {\n\t\t\tif (ad->model_rev == NULL)\n\t\t\t\treturn ad->horkage;\n\t\t\tif (glob_match(ad->model_rev, model_rev))\n\t\t\t\treturn ad->horkage;\n\t\t}\n\t\tad++;\n\t}\n\treturn 0;\n}\n\nstatic int ata_dma_blacklisted(const struct ata_device *dev)\n{\n\t \n\tif ((dev->link->ap->flags & ATA_FLAG_PIO_POLLING) &&\n\t    (dev->flags & ATA_DFLAG_CDB_INTR))\n\t\treturn 1;\n\treturn (dev->horkage & ATA_HORKAGE_NODMA) ? 1 : 0;\n}\n\n \n\nstatic int ata_is_40wire(struct ata_device *dev)\n{\n\tif (dev->horkage & ATA_HORKAGE_IVB)\n\t\treturn ata_drive_40wire_relaxed(dev->id);\n\treturn ata_drive_40wire(dev->id);\n}\n\n \n\nstatic int cable_is_40wire(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\n\t \n\tif (ap->cbl == ATA_CBL_PATA40)\n\t\treturn 1;\n\n\t \n\tif (ap->cbl == ATA_CBL_PATA80 || ap->cbl == ATA_CBL_SATA)\n\t\treturn 0;\n\n\t \n\tif (ap->cbl == ATA_CBL_PATA40_SHORT)\n\t\treturn 0;\n\n\t \n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, link, ENABLED) {\n\t\t\tif (!ata_is_40wire(dev))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic void ata_dev_xfermask(struct ata_device *dev)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_host *host = ap->host;\n\tunsigned int xfer_mask;\n\n\t \n\txfer_mask = ata_pack_xfermask(ap->pio_mask,\n\t\t\t\t      ap->mwdma_mask, ap->udma_mask);\n\n\t \n\txfer_mask &= ata_pack_xfermask(dev->pio_mask,\n\t\t\t\t       dev->mwdma_mask, dev->udma_mask);\n\txfer_mask &= ata_id_xfermask(dev->id);\n\n\t \n\tif (ata_dev_pair(dev)) {\n\t\t \n\t\txfer_mask &= ~(0x03 << (ATA_SHIFT_PIO + 5));\n\t\t \n\t\txfer_mask &= ~(0x03 << (ATA_SHIFT_MWDMA + 3));\n\t}\n\n\tif (ata_dma_blacklisted(dev)) {\n\t\txfer_mask &= ~(ATA_MASK_MWDMA | ATA_MASK_UDMA);\n\t\tata_dev_warn(dev,\n\t\t\t     \"device is on DMA blacklist, disabling DMA\\n\");\n\t}\n\n\tif ((host->flags & ATA_HOST_SIMPLEX) &&\n\t    host->simplex_claimed && host->simplex_claimed != ap) {\n\t\txfer_mask &= ~(ATA_MASK_MWDMA | ATA_MASK_UDMA);\n\t\tata_dev_warn(dev,\n\t\t\t     \"simplex DMA is claimed by other device, disabling DMA\\n\");\n\t}\n\n\tif (ap->flags & ATA_FLAG_NO_IORDY)\n\t\txfer_mask &= ata_pio_mask_no_iordy(dev);\n\n\tif (ap->ops->mode_filter)\n\t\txfer_mask = ap->ops->mode_filter(dev, xfer_mask);\n\n\t \n\tif (xfer_mask & (0xF8 << ATA_SHIFT_UDMA))\n\t\t \n\t\tif (cable_is_40wire(ap)) {\n\t\t\tata_dev_warn(dev,\n\t\t\t\t     \"limited to UDMA/33 due to 40-wire cable\\n\");\n\t\t\txfer_mask &= ~(0xF8 << ATA_SHIFT_UDMA);\n\t\t}\n\n\tata_unpack_xfermask(xfer_mask, &dev->pio_mask,\n\t\t\t    &dev->mwdma_mask, &dev->udma_mask);\n}\n\n \n\nstatic unsigned int ata_dev_set_xfermode(struct ata_device *dev)\n{\n\tstruct ata_taskfile tf;\n\n\t \n\tata_dev_dbg(dev, \"set features - xfer mode\\n\");\n\n\t \n\tata_tf_init(dev, &tf);\n\ttf.command = ATA_CMD_SET_FEATURES;\n\ttf.feature = SETFEATURES_XFER;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_POLLING;\n\ttf.protocol = ATA_PROT_NODATA;\n\t \n\tif (ata_pio_need_iordy(dev))\n\t\ttf.nsect = dev->xfer_mode;\n\t \n \telse if (ata_id_has_iordy(dev->id))\n\t\ttf.nsect = 0x01;\n\telse  \n\t\treturn 0;\n\n\t \n\treturn ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 15000);\n}\n\n \nunsigned int ata_dev_set_feature(struct ata_device *dev, u8 subcmd, u8 action)\n{\n\tstruct ata_taskfile tf;\n\tunsigned int timeout = 0;\n\n\t \n\tata_dev_dbg(dev, \"set features\\n\");\n\n\tata_tf_init(dev, &tf);\n\ttf.command = ATA_CMD_SET_FEATURES;\n\ttf.feature = subcmd;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.nsect = action;\n\n\tif (subcmd == SETFEATURES_SPINUP)\n\t\ttimeout = ata_probe_timeout ?\n\t\t\t  ata_probe_timeout * 1000 : SETFEATURES_SPINUP_TIMEOUT;\n\n\treturn ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, timeout);\n}\nEXPORT_SYMBOL_GPL(ata_dev_set_feature);\n\n \nstatic unsigned int ata_dev_init_params(struct ata_device *dev,\n\t\t\t\t\tu16 heads, u16 sectors)\n{\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\t \n\tif (sectors < 1 || sectors > 255 || heads < 1 || heads > 16)\n\t\treturn AC_ERR_INVALID;\n\n\t \n\tata_dev_dbg(dev, \"init dev params \\n\");\n\n\tata_tf_init(dev, &tf);\n\ttf.command = ATA_CMD_INIT_DEV_PARAMS;\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf.protocol = ATA_PROT_NODATA;\n\ttf.nsect = sectors;\n\ttf.device |= (heads - 1) & 0x0f;  \n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\t \n\tif (err_mask == AC_ERR_DEV && (tf.error & ATA_ABORTED))\n\t\terr_mask = 0;\n\n\treturn err_mask;\n}\n\n \nint atapi_check_dma(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\t \n\tif (!(qc->dev->horkage & ATA_HORKAGE_ATAPI_MOD16_DMA) &&\n\t    unlikely(qc->nbytes & 15))\n\t\treturn 1;\n\n\tif (ap->ops->check_atapi_dma)\n\t\treturn ap->ops->check_atapi_dma(qc);\n\n\treturn 0;\n}\n\n \nint ata_std_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_link *link = qc->dev->link;\n\n\tif (ata_is_ncq(qc->tf.protocol)) {\n\t\tif (!ata_tag_valid(link->active_tag))\n\t\t\treturn 0;\n\t} else {\n\t\tif (!ata_tag_valid(link->active_tag) && !link->sactive)\n\t\t\treturn 0;\n\t}\n\n\treturn ATA_DEFER_LINK;\n}\nEXPORT_SYMBOL_GPL(ata_std_qc_defer);\n\nenum ata_completion_errors ata_noop_qc_prep(struct ata_queued_cmd *qc)\n{\n\treturn AC_ERR_OK;\n}\nEXPORT_SYMBOL_GPL(ata_noop_qc_prep);\n\n \nvoid ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,\n\t\t unsigned int n_elem)\n{\n\tqc->sg = sg;\n\tqc->n_elem = n_elem;\n\tqc->cursg = qc->sg;\n}\n\n#ifdef CONFIG_HAS_DMA\n\n \nstatic void ata_sg_clean(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct scatterlist *sg = qc->sg;\n\tint dir = qc->dma_dir;\n\n\tWARN_ON_ONCE(sg == NULL);\n\n\tif (qc->n_elem)\n\t\tdma_unmap_sg(ap->dev, sg, qc->orig_n_elem, dir);\n\n\tqc->flags &= ~ATA_QCFLAG_DMAMAP;\n\tqc->sg = NULL;\n}\n\n \nstatic int ata_sg_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tunsigned int n_elem;\n\n\tn_elem = dma_map_sg(ap->dev, qc->sg, qc->n_elem, qc->dma_dir);\n\tif (n_elem < 1)\n\t\treturn -1;\n\n\tqc->orig_n_elem = qc->n_elem;\n\tqc->n_elem = n_elem;\n\tqc->flags |= ATA_QCFLAG_DMAMAP;\n\n\treturn 0;\n}\n\n#else  \n\nstatic inline void ata_sg_clean(struct ata_queued_cmd *qc) {}\nstatic inline int ata_sg_setup(struct ata_queued_cmd *qc) { return -1; }\n\n#endif  \n\n \nvoid swap_buf_le16(u16 *buf, unsigned int buf_words)\n{\n#ifdef __BIG_ENDIAN\n\tunsigned int i;\n\n\tfor (i = 0; i < buf_words; i++)\n\t\tbuf[i] = le16_to_cpu(buf[i]);\n#endif  \n}\n\n \nvoid ata_qc_free(struct ata_queued_cmd *qc)\n{\n\tqc->flags = 0;\n\tif (ata_tag_valid(qc->tag))\n\t\tqc->tag = ATA_TAG_POISON;\n}\n\nvoid __ata_qc_complete(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap;\n\tstruct ata_link *link;\n\n\tWARN_ON_ONCE(qc == NULL);  \n\tWARN_ON_ONCE(!(qc->flags & ATA_QCFLAG_ACTIVE));\n\tap = qc->ap;\n\tlink = qc->dev->link;\n\n\tif (likely(qc->flags & ATA_QCFLAG_DMAMAP))\n\t\tata_sg_clean(qc);\n\n\t \n\tif (ata_is_ncq(qc->tf.protocol)) {\n\t\tlink->sactive &= ~(1 << qc->hw_tag);\n\t\tif (!link->sactive)\n\t\t\tap->nr_active_links--;\n\t} else {\n\t\tlink->active_tag = ATA_TAG_POISON;\n\t\tap->nr_active_links--;\n\t}\n\n\t \n\tif (unlikely(qc->flags & ATA_QCFLAG_CLEAR_EXCL &&\n\t\t     ap->excl_link == link))\n\t\tap->excl_link = NULL;\n\n\t \n\tqc->flags &= ~ATA_QCFLAG_ACTIVE;\n\tap->qc_active &= ~(1ULL << qc->tag);\n\n\t \n\tqc->complete_fn(qc);\n}\n\nstatic void fill_result_tf(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\tqc->result_tf.flags = qc->tf.flags;\n\tap->ops->qc_fill_rtf(qc);\n}\n\nstatic void ata_verify_xfer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_device *dev = qc->dev;\n\n\tif (!ata_is_data(qc->tf.protocol))\n\t\treturn;\n\n\tif ((dev->mwdma_mask || dev->udma_mask) && ata_is_pio(qc->tf.protocol))\n\t\treturn;\n\n\tdev->flags &= ~ATA_DFLAG_DUBIOUS_XFER;\n}\n\n \nvoid ata_qc_complete(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *dev = qc->dev;\n\tstruct ata_eh_info *ehi = &dev->link->eh_info;\n\n\t \n\tledtrig_disk_activity(!!(qc->tf.flags & ATA_TFLAG_WRITE));\n\n\t \n\tif (unlikely(qc->err_mask))\n\t\tqc->flags |= ATA_QCFLAG_EH;\n\n\t \n\tif (unlikely(ata_tag_internal(qc->tag))) {\n\t\tfill_result_tf(qc);\n\t\ttrace_ata_qc_complete_internal(qc);\n\t\t__ata_qc_complete(qc);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(qc->flags & ATA_QCFLAG_EH)) {\n\t\tfill_result_tf(qc);\n\t\ttrace_ata_qc_complete_failed(qc);\n\t\tata_qc_schedule_eh(qc);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(ata_port_is_frozen(ap));\n\n\t \n\tif (qc->flags & ATA_QCFLAG_RESULT_TF)\n\t\tfill_result_tf(qc);\n\n\ttrace_ata_qc_complete_done(qc);\n\n\t \n\tif (qc->flags & ATA_QCFLAG_HAS_CDL &&\n\t    qc->result_tf.status & ATA_SENSE) {\n\t\t \n\t\tqc->scsicmd->flags |= SCMD_FORCE_EH_SUCCESS;\n\t\tqc->flags |= ATA_QCFLAG_EH_SUCCESS_CMD;\n\t\tehi->dev_action[dev->devno] |= ATA_EH_GET_SUCCESS_SENSE;\n\n\t\t \n\t\tap->pflags |= ATA_PFLAG_EH_PENDING;\n\t\tata_qc_schedule_eh(qc);\n\t\treturn;\n\t}\n\n\t \n\tswitch (qc->tf.command) {\n\tcase ATA_CMD_SET_FEATURES:\n\t\tif (qc->tf.feature != SETFEATURES_WC_ON &&\n\t\t    qc->tf.feature != SETFEATURES_WC_OFF &&\n\t\t    qc->tf.feature != SETFEATURES_RA_ON &&\n\t\t    qc->tf.feature != SETFEATURES_RA_OFF)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase ATA_CMD_INIT_DEV_PARAMS:  \n\tcase ATA_CMD_SET_MULTI:  \n\t\t \n\t\tehi->dev_action[dev->devno] |= ATA_EH_REVALIDATE;\n\t\tata_port_schedule_eh(ap);\n\t\tbreak;\n\n\tcase ATA_CMD_SLEEP:\n\t\tdev->flags |= ATA_DFLAG_SLEEPING;\n\t\tbreak;\n\t}\n\n\tif (unlikely(dev->flags & ATA_DFLAG_DUBIOUS_XFER))\n\t\tata_verify_xfer(qc);\n\n\t__ata_qc_complete(qc);\n}\nEXPORT_SYMBOL_GPL(ata_qc_complete);\n\n \nu64 ata_qc_get_active(struct ata_port *ap)\n{\n\tu64 qc_active = ap->qc_active;\n\n\t \n\tif (qc_active & (1ULL << ATA_TAG_INTERNAL)) {\n\t\tqc_active |= (1 << 0);\n\t\tqc_active &= ~(1ULL << ATA_TAG_INTERNAL);\n\t}\n\n\treturn qc_active;\n}\nEXPORT_SYMBOL_GPL(ata_qc_get_active);\n\n \nvoid ata_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_link *link = qc->dev->link;\n\tu8 prot = qc->tf.protocol;\n\n\t \n\tWARN_ON_ONCE(ata_tag_valid(link->active_tag));\n\n\tif (ata_is_ncq(prot)) {\n\t\tWARN_ON_ONCE(link->sactive & (1 << qc->hw_tag));\n\n\t\tif (!link->sactive)\n\t\t\tap->nr_active_links++;\n\t\tlink->sactive |= 1 << qc->hw_tag;\n\t} else {\n\t\tWARN_ON_ONCE(link->sactive);\n\n\t\tap->nr_active_links++;\n\t\tlink->active_tag = qc->tag;\n\t}\n\n\tqc->flags |= ATA_QCFLAG_ACTIVE;\n\tap->qc_active |= 1ULL << qc->tag;\n\n\t \n\tif (ata_is_data(prot) && (!qc->sg || !qc->n_elem || !qc->nbytes))\n\t\tgoto sys_err;\n\n\tif (ata_is_dma(prot) || (ata_is_pio(prot) &&\n\t\t\t\t (ap->flags & ATA_FLAG_PIO_DMA)))\n\t\tif (ata_sg_setup(qc))\n\t\t\tgoto sys_err;\n\n\t \n\tif (unlikely(qc->dev->flags & ATA_DFLAG_SLEEPING)) {\n\t\tlink->eh_info.action |= ATA_EH_RESET;\n\t\tata_ehi_push_desc(&link->eh_info, \"waking up from sleep\");\n\t\tata_link_abort(link);\n\t\treturn;\n\t}\n\n\ttrace_ata_qc_prep(qc);\n\tqc->err_mask |= ap->ops->qc_prep(qc);\n\tif (unlikely(qc->err_mask))\n\t\tgoto err;\n\ttrace_ata_qc_issue(qc);\n\tqc->err_mask |= ap->ops->qc_issue(qc);\n\tif (unlikely(qc->err_mask))\n\t\tgoto err;\n\treturn;\n\nsys_err:\n\tqc->err_mask |= AC_ERR_SYSTEM;\nerr:\n\tata_qc_complete(qc);\n}\n\n \nbool ata_phys_link_online(struct ata_link *link)\n{\n\tu32 sstatus;\n\n\tif (sata_scr_read(link, SCR_STATUS, &sstatus) == 0 &&\n\t    ata_sstatus_online(sstatus))\n\t\treturn true;\n\treturn false;\n}\n\n \nbool ata_phys_link_offline(struct ata_link *link)\n{\n\tu32 sstatus;\n\n\tif (sata_scr_read(link, SCR_STATUS, &sstatus) == 0 &&\n\t    !ata_sstatus_online(sstatus))\n\t\treturn true;\n\treturn false;\n}\n\n \nbool ata_link_online(struct ata_link *link)\n{\n\tstruct ata_link *slave = link->ap->slave_link;\n\n\tWARN_ON(link == slave);\t \n\n\treturn ata_phys_link_online(link) ||\n\t\t(slave && ata_phys_link_online(slave));\n}\nEXPORT_SYMBOL_GPL(ata_link_online);\n\n \nbool ata_link_offline(struct ata_link *link)\n{\n\tstruct ata_link *slave = link->ap->slave_link;\n\n\tWARN_ON(link == slave);\t \n\n\treturn ata_phys_link_offline(link) &&\n\t\t(!slave || ata_phys_link_offline(slave));\n}\nEXPORT_SYMBOL_GPL(ata_link_offline);\n\n#ifdef CONFIG_PM\nstatic void ata_port_request_pm(struct ata_port *ap, pm_message_t mesg,\n\t\t\t\tunsigned int action, unsigned int ehi_flags,\n\t\t\t\tbool async)\n{\n\tstruct ata_link *link;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tif (ap->pflags & ATA_PFLAG_PM_PENDING) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tata_port_wait_eh(ap);\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t}\n\n\t \n\tap->pm_mesg = mesg;\n\tap->pflags |= ATA_PFLAG_PM_PENDING;\n\tata_for_each_link(link, ap, HOST_FIRST) {\n\t\tlink->eh_info.action |= action;\n\t\tlink->eh_info.flags |= ehi_flags;\n\t}\n\n\tata_port_schedule_eh(ap);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tif (!async)\n\t\tata_port_wait_eh(ap);\n}\n\n \nstatic const unsigned int ata_port_suspend_ehi = ATA_EHI_QUIET\n\t\t\t\t\t\t | ATA_EHI_NO_AUTOPSY\n\t\t\t\t\t\t | ATA_EHI_NO_RECOVERY;\n\nstatic void ata_port_suspend(struct ata_port *ap, pm_message_t mesg)\n{\n\t \n\tcancel_delayed_work_sync(&ap->scsi_rescan_task);\n\n\tata_port_request_pm(ap, mesg, 0, ata_port_suspend_ehi, false);\n}\n\nstatic void ata_port_suspend_async(struct ata_port *ap, pm_message_t mesg)\n{\n\t \n\tcancel_delayed_work_sync(&ap->scsi_rescan_task);\n\n\tata_port_request_pm(ap, mesg, 0, ata_port_suspend_ehi, true);\n}\n\nstatic int ata_port_pm_suspend(struct device *dev)\n{\n\tstruct ata_port *ap = to_ata_port(dev);\n\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\tata_port_suspend(ap, PMSG_SUSPEND);\n\treturn 0;\n}\n\nstatic int ata_port_pm_freeze(struct device *dev)\n{\n\tstruct ata_port *ap = to_ata_port(dev);\n\n\tif (pm_runtime_suspended(dev))\n\t\treturn 0;\n\n\tata_port_suspend(ap, PMSG_FREEZE);\n\treturn 0;\n}\n\nstatic int ata_port_pm_poweroff(struct device *dev)\n{\n\tata_port_suspend(to_ata_port(dev), PMSG_HIBERNATE);\n\treturn 0;\n}\n\nstatic const unsigned int ata_port_resume_ehi = ATA_EHI_NO_AUTOPSY\n\t\t\t\t\t\t| ATA_EHI_QUIET;\n\nstatic void ata_port_resume(struct ata_port *ap, pm_message_t mesg)\n{\n\tata_port_request_pm(ap, mesg, ATA_EH_RESET, ata_port_resume_ehi, false);\n}\n\nstatic void ata_port_resume_async(struct ata_port *ap, pm_message_t mesg)\n{\n\tata_port_request_pm(ap, mesg, ATA_EH_RESET, ata_port_resume_ehi, true);\n}\n\nstatic int ata_port_pm_resume(struct device *dev)\n{\n\tata_port_resume_async(to_ata_port(dev), PMSG_RESUME);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\treturn 0;\n}\n\n \nstatic int ata_port_runtime_idle(struct device *dev)\n{\n\tstruct ata_port *ap = to_ata_port(dev);\n\tstruct ata_link *link;\n\tstruct ata_device *adev;\n\n\tata_for_each_link(link, ap, HOST_FIRST) {\n\t\tata_for_each_dev(adev, link, ENABLED)\n\t\t\tif (adev->class == ATA_DEV_ATAPI &&\n\t\t\t    !zpodd_dev_enabled(adev))\n\t\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int ata_port_runtime_suspend(struct device *dev)\n{\n\tata_port_suspend(to_ata_port(dev), PMSG_AUTO_SUSPEND);\n\treturn 0;\n}\n\nstatic int ata_port_runtime_resume(struct device *dev)\n{\n\tata_port_resume(to_ata_port(dev), PMSG_AUTO_RESUME);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ata_port_pm_ops = {\n\t.suspend = ata_port_pm_suspend,\n\t.resume = ata_port_pm_resume,\n\t.freeze = ata_port_pm_freeze,\n\t.thaw = ata_port_pm_resume,\n\t.poweroff = ata_port_pm_poweroff,\n\t.restore = ata_port_pm_resume,\n\n\t.runtime_suspend = ata_port_runtime_suspend,\n\t.runtime_resume = ata_port_runtime_resume,\n\t.runtime_idle = ata_port_runtime_idle,\n};\n\n \nvoid ata_sas_port_suspend(struct ata_port *ap)\n{\n\tata_port_suspend_async(ap, PMSG_SUSPEND);\n}\nEXPORT_SYMBOL_GPL(ata_sas_port_suspend);\n\nvoid ata_sas_port_resume(struct ata_port *ap)\n{\n\tata_port_resume_async(ap, PMSG_RESUME);\n}\nEXPORT_SYMBOL_GPL(ata_sas_port_resume);\n\n \nvoid ata_host_suspend(struct ata_host *host, pm_message_t mesg)\n{\n\thost->dev->power.power_state = mesg;\n}\nEXPORT_SYMBOL_GPL(ata_host_suspend);\n\n \nvoid ata_host_resume(struct ata_host *host)\n{\n\thost->dev->power.power_state = PMSG_ON;\n}\nEXPORT_SYMBOL_GPL(ata_host_resume);\n#endif\n\nconst struct device_type ata_port_type = {\n\t.name = ATA_PORT_TYPE_NAME,\n#ifdef CONFIG_PM\n\t.pm = &ata_port_pm_ops,\n#endif\n};\n\n \nvoid ata_dev_init(struct ata_device *dev)\n{\n\tstruct ata_link *link = ata_dev_phys_link(dev);\n\tstruct ata_port *ap = link->ap;\n\tunsigned long flags;\n\n\t \n\tlink->sata_spd_limit = link->hw_sata_spd_limit;\n\tlink->sata_spd = 0;\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\tdev->flags &= ~ATA_DFLAG_INIT_MASK;\n\tdev->horkage = 0;\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tmemset((void *)dev + ATA_DEVICE_CLEAR_BEGIN, 0,\n\t       ATA_DEVICE_CLEAR_END - ATA_DEVICE_CLEAR_BEGIN);\n\tdev->pio_mask = UINT_MAX;\n\tdev->mwdma_mask = UINT_MAX;\n\tdev->udma_mask = UINT_MAX;\n}\n\n \nvoid ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp)\n{\n\tint i;\n\n\t \n\tmemset((void *)link + ATA_LINK_CLEAR_BEGIN, 0,\n\t       ATA_LINK_CLEAR_END - ATA_LINK_CLEAR_BEGIN);\n\n\tlink->ap = ap;\n\tlink->pmp = pmp;\n\tlink->active_tag = ATA_TAG_POISON;\n\tlink->hw_sata_spd_limit = UINT_MAX;\n\n\t \n\tfor (i = 0; i < ATA_MAX_DEVICES; i++) {\n\t\tstruct ata_device *dev = &link->device[i];\n\n\t\tdev->link = link;\n\t\tdev->devno = dev - link->device;\n#ifdef CONFIG_ATA_ACPI\n\t\tdev->gtf_filter = ata_acpi_gtf_filter;\n#endif\n\t\tata_dev_init(dev);\n\t}\n}\n\n \nint sata_link_init_spd(struct ata_link *link)\n{\n\tu8 spd;\n\tint rc;\n\n\trc = sata_scr_read(link, SCR_CONTROL, &link->saved_scontrol);\n\tif (rc)\n\t\treturn rc;\n\n\tspd = (link->saved_scontrol >> 4) & 0xf;\n\tif (spd)\n\t\tlink->hw_sata_spd_limit &= (1 << spd) - 1;\n\n\tata_force_link_limits(link);\n\n\tlink->sata_spd_limit = link->hw_sata_spd_limit;\n\n\treturn 0;\n}\n\n \nstruct ata_port *ata_port_alloc(struct ata_host *host)\n{\n\tstruct ata_port *ap;\n\n\tap = kzalloc(sizeof(*ap), GFP_KERNEL);\n\tif (!ap)\n\t\treturn NULL;\n\n\tap->pflags |= ATA_PFLAG_INITIALIZING | ATA_PFLAG_FROZEN;\n\tap->lock = &host->lock;\n\tap->print_id = -1;\n\tap->local_port_no = -1;\n\tap->host = host;\n\tap->dev = host->dev;\n\n\tmutex_init(&ap->scsi_scan_mutex);\n\tINIT_DELAYED_WORK(&ap->hotplug_task, ata_scsi_hotplug);\n\tINIT_DELAYED_WORK(&ap->scsi_rescan_task, ata_scsi_dev_rescan);\n\tINIT_LIST_HEAD(&ap->eh_done_q);\n\tinit_waitqueue_head(&ap->eh_wait_q);\n\tinit_completion(&ap->park_req_pending);\n\ttimer_setup(&ap->fastdrain_timer, ata_eh_fastdrain_timerfn,\n\t\t    TIMER_DEFERRABLE);\n\n\tap->cbl = ATA_CBL_NONE;\n\n\tata_link_init(ap, &ap->link, 0);\n\n#ifdef ATA_IRQ_TRAP\n\tap->stats.unhandled_irq = 1;\n\tap->stats.idle_irq = 1;\n#endif\n\tata_sff_port_init(ap);\n\n\treturn ap;\n}\n\nstatic void ata_devres_release(struct device *gendev, void *res)\n{\n\tstruct ata_host *host = dev_get_drvdata(gendev);\n\tint i;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (!ap)\n\t\t\tcontinue;\n\n\t\tif (ap->scsi_host)\n\t\t\tscsi_host_put(ap->scsi_host);\n\n\t}\n\n\tdev_set_drvdata(gendev, NULL);\n\tata_host_put(host);\n}\n\nstatic void ata_host_release(struct kref *kref)\n{\n\tstruct ata_host *host = container_of(kref, struct ata_host, kref);\n\tint i;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tkfree(ap->pmp_link);\n\t\tkfree(ap->slave_link);\n\t\tkfree(ap->ncq_sense_buf);\n\t\tkfree(ap);\n\t\thost->ports[i] = NULL;\n\t}\n\tkfree(host);\n}\n\nvoid ata_host_get(struct ata_host *host)\n{\n\tkref_get(&host->kref);\n}\n\nvoid ata_host_put(struct ata_host *host)\n{\n\tkref_put(&host->kref, ata_host_release);\n}\nEXPORT_SYMBOL_GPL(ata_host_put);\n\n \nstruct ata_host *ata_host_alloc(struct device *dev, int max_ports)\n{\n\tstruct ata_host *host;\n\tsize_t sz;\n\tint i;\n\tvoid *dr;\n\n\t \n\tsz = sizeof(struct ata_host) + (max_ports + 1) * sizeof(void *);\n\thost = kzalloc(sz, GFP_KERNEL);\n\tif (!host)\n\t\treturn NULL;\n\n\tif (!devres_open_group(dev, NULL, GFP_KERNEL))\n\t\tgoto err_free;\n\n\tdr = devres_alloc(ata_devres_release, 0, GFP_KERNEL);\n\tif (!dr)\n\t\tgoto err_out;\n\n\tdevres_add(dev, dr);\n\tdev_set_drvdata(dev, host);\n\n\tspin_lock_init(&host->lock);\n\tmutex_init(&host->eh_mutex);\n\thost->dev = dev;\n\thost->n_ports = max_ports;\n\tkref_init(&host->kref);\n\n\t \n\tfor (i = 0; i < max_ports; i++) {\n\t\tstruct ata_port *ap;\n\n\t\tap = ata_port_alloc(host);\n\t\tif (!ap)\n\t\t\tgoto err_out;\n\n\t\tap->port_no = i;\n\t\thost->ports[i] = ap;\n\t}\n\n\tdevres_remove_group(dev, NULL);\n\treturn host;\n\n err_out:\n\tdevres_release_group(dev, NULL);\n err_free:\n\tkfree(host);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ata_host_alloc);\n\n \nstruct ata_host *ata_host_alloc_pinfo(struct device *dev,\n\t\t\t\t      const struct ata_port_info * const * ppi,\n\t\t\t\t      int n_ports)\n{\n\tconst struct ata_port_info *pi = &ata_dummy_port_info;\n\tstruct ata_host *host;\n\tint i, j;\n\n\thost = ata_host_alloc(dev, n_ports);\n\tif (!host)\n\t\treturn NULL;\n\n\tfor (i = 0, j = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (ppi[j])\n\t\t\tpi = ppi[j++];\n\n\t\tap->pio_mask = pi->pio_mask;\n\t\tap->mwdma_mask = pi->mwdma_mask;\n\t\tap->udma_mask = pi->udma_mask;\n\t\tap->flags |= pi->flags;\n\t\tap->link.flags |= pi->link_flags;\n\t\tap->ops = pi->port_ops;\n\n\t\tif (!host->ops && (pi->port_ops != &ata_dummy_port_ops))\n\t\t\thost->ops = pi->port_ops;\n\t}\n\n\treturn host;\n}\nEXPORT_SYMBOL_GPL(ata_host_alloc_pinfo);\n\nstatic void ata_host_stop(struct device *gendev, void *res)\n{\n\tstruct ata_host *host = dev_get_drvdata(gendev);\n\tint i;\n\n\tWARN_ON(!(host->flags & ATA_HOST_STARTED));\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (ap->ops->port_stop)\n\t\t\tap->ops->port_stop(ap);\n\t}\n\n\tif (host->ops->host_stop)\n\t\thost->ops->host_stop(host);\n}\n\n \nstatic void ata_finalize_port_ops(struct ata_port_operations *ops)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tconst struct ata_port_operations *cur;\n\tvoid **begin = (void **)ops;\n\tvoid **end = (void **)&ops->inherits;\n\tvoid **pp;\n\n\tif (!ops || !ops->inherits)\n\t\treturn;\n\n\tspin_lock(&lock);\n\n\tfor (cur = ops->inherits; cur; cur = cur->inherits) {\n\t\tvoid **inherit = (void **)cur;\n\n\t\tfor (pp = begin; pp < end; pp++, inherit++)\n\t\t\tif (!*pp)\n\t\t\t\t*pp = *inherit;\n\t}\n\n\tfor (pp = begin; pp < end; pp++)\n\t\tif (IS_ERR(*pp))\n\t\t\t*pp = NULL;\n\n\tops->inherits = NULL;\n\n\tspin_unlock(&lock);\n}\n\n \nint ata_host_start(struct ata_host *host)\n{\n\tint have_stop = 0;\n\tvoid *start_dr = NULL;\n\tint i, rc;\n\n\tif (host->flags & ATA_HOST_STARTED)\n\t\treturn 0;\n\n\tata_finalize_port_ops(host->ops);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tata_finalize_port_ops(ap->ops);\n\n\t\tif (!host->ops && !ata_port_is_dummy(ap))\n\t\t\thost->ops = ap->ops;\n\n\t\tif (ap->ops->port_stop)\n\t\t\thave_stop = 1;\n\t}\n\n\tif (host->ops && host->ops->host_stop)\n\t\thave_stop = 1;\n\n\tif (have_stop) {\n\t\tstart_dr = devres_alloc(ata_host_stop, 0, GFP_KERNEL);\n\t\tif (!start_dr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (ap->ops->port_start) {\n\t\t\trc = ap->ops->port_start(ap);\n\t\t\tif (rc) {\n\t\t\t\tif (rc != -ENODEV)\n\t\t\t\t\tdev_err(host->dev,\n\t\t\t\t\t\t\"failed to start port %d (errno=%d)\\n\",\n\t\t\t\t\t\ti, rc);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tata_eh_freeze_port(ap);\n\t}\n\n\tif (start_dr)\n\t\tdevres_add(host->dev, start_dr);\n\thost->flags |= ATA_HOST_STARTED;\n\treturn 0;\n\n err_out:\n\twhile (--i >= 0) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (ap->ops->port_stop)\n\t\t\tap->ops->port_stop(ap);\n\t}\n\tdevres_free(start_dr);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_host_start);\n\n \nvoid ata_host_init(struct ata_host *host, struct device *dev,\n\t\t   struct ata_port_operations *ops)\n{\n\tspin_lock_init(&host->lock);\n\tmutex_init(&host->eh_mutex);\n\thost->n_tags = ATA_MAX_QUEUE;\n\thost->dev = dev;\n\thost->ops = ops;\n\tkref_init(&host->kref);\n}\nEXPORT_SYMBOL_GPL(ata_host_init);\n\nvoid ata_port_probe(struct ata_port *ap)\n{\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\tehi->probe_mask |= ATA_ALL_DEVICES;\n\tehi->action |= ATA_EH_RESET;\n\tehi->flags |= ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET;\n\n\tap->pflags &= ~ATA_PFLAG_INITIALIZING;\n\tap->pflags |= ATA_PFLAG_LOADING;\n\tata_port_schedule_eh(ap);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ata_port_probe);\n\nstatic void async_port_probe(void *data, async_cookie_t cookie)\n{\n\tstruct ata_port *ap = data;\n\n\t \n\tif (!(ap->host->flags & ATA_HOST_PARALLEL_SCAN) && ap->port_no != 0)\n\t\tasync_synchronize_cookie(cookie);\n\n\tata_port_probe(ap);\n\tata_port_wait_eh(ap);\n\n\t \n\tasync_synchronize_cookie(cookie);\n\n\tata_scsi_scan_host(ap, 1);\n}\n\n \nint ata_host_register(struct ata_host *host, const struct scsi_host_template *sht)\n{\n\tint i, rc;\n\n\thost->n_tags = clamp(sht->can_queue, 1, ATA_MAX_QUEUE);\n\n\t \n\tif (!(host->flags & ATA_HOST_STARTED)) {\n\t\tdev_err(host->dev, \"BUG: trying to register unstarted host\\n\");\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = host->n_ports; host->ports[i]; i++)\n\t\tkfree(host->ports[i]);\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\thost->ports[i]->print_id = atomic_inc_return(&ata_print_id);\n\t\thost->ports[i]->local_port_no = i + 1;\n\t}\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\trc = ata_tport_add(host->dev,host->ports[i]);\n\t\tif (rc) {\n\t\t\tgoto err_tadd;\n\t\t}\n\t}\n\n\trc = ata_scsi_add_hosts(host, sht);\n\tif (rc)\n\t\tgoto err_tadd;\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tunsigned int xfer_mask;\n\n\t\t \n\t\tif (ap->cbl == ATA_CBL_NONE && (ap->flags & ATA_FLAG_SATA))\n\t\t\tap->cbl = ATA_CBL_SATA;\n\n\t\t \n\t\tsata_link_init_spd(&ap->link);\n\t\tif (ap->slave_link)\n\t\t\tsata_link_init_spd(ap->slave_link);\n\n\t\t \n\t\txfer_mask = ata_pack_xfermask(ap->pio_mask, ap->mwdma_mask,\n\t\t\t\t\t      ap->udma_mask);\n\n\t\tif (!ata_port_is_dummy(ap)) {\n\t\t\tata_port_info(ap, \"%cATA max %s %s\\n\",\n\t\t\t\t      (ap->flags & ATA_FLAG_SATA) ? 'S' : 'P',\n\t\t\t\t      ata_mode_string(xfer_mask),\n\t\t\t\t      ap->link.eh_info.desc);\n\t\t\tata_ehi_clear_desc(&ap->link.eh_info);\n\t\t} else\n\t\t\tata_port_info(ap, \"DUMMY\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tap->cookie = async_schedule(async_port_probe, ap);\n\t}\n\n\treturn 0;\n\n err_tadd:\n\twhile (--i >= 0) {\n\t\tata_tport_delete(host->ports[i]);\n\t}\n\treturn rc;\n\n}\nEXPORT_SYMBOL_GPL(ata_host_register);\n\n \nint ata_host_activate(struct ata_host *host, int irq,\n\t\t      irq_handler_t irq_handler, unsigned long irq_flags,\n\t\t      const struct scsi_host_template *sht)\n{\n\tint i, rc;\n\tchar *irq_desc;\n\n\trc = ata_host_start(host);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (!irq) {\n\t\tWARN_ON(irq_handler);\n\t\treturn ata_host_register(host, sht);\n\t}\n\n\tirq_desc = devm_kasprintf(host->dev, GFP_KERNEL, \"%s[%s]\",\n\t\t\t\t  dev_driver_string(host->dev),\n\t\t\t\t  dev_name(host->dev));\n\tif (!irq_desc)\n\t\treturn -ENOMEM;\n\n\trc = devm_request_irq(host->dev, irq, irq_handler, irq_flags,\n\t\t\t      irq_desc, host);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < host->n_ports; i++)\n\t\tata_port_desc(host->ports[i], \"irq %d\", irq);\n\n\trc = ata_host_register(host, sht);\n\t \n\tif (rc)\n\t\tdevm_free_irq(host->dev, irq, host);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_host_activate);\n\n \nstatic void ata_port_detach(struct ata_port *ap)\n{\n\tunsigned long flags;\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\n\t \n\tata_port_wait_eh(ap);\n\n\tmutex_lock(&ap->scsi_scan_mutex);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tata_for_each_link(link, ap, HOST_FIRST) {\n\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\tif (dev->sdev) {\n\t\t\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\t\t\tscsi_remove_device(dev->sdev);\n\t\t\t\tspin_lock_irqsave(ap->lock, flags);\n\t\t\t\tdev->sdev = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tap->pflags |= ATA_PFLAG_UNLOADING;\n\tata_port_schedule_eh(ap);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tmutex_unlock(&ap->scsi_scan_mutex);\n\n\t \n\tata_port_wait_eh(ap);\n\n\t \n\tWARN_ON(!(ap->pflags & ATA_PFLAG_UNLOADED));\n\n\tcancel_delayed_work_sync(&ap->hotplug_task);\n\tcancel_delayed_work_sync(&ap->scsi_rescan_task);\n\n\t \n\tata_for_each_link(link, ap, HOST_FIRST) {\n\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\tif (zpodd_dev_enabled(dev))\n\t\t\t\tzpodd_exit(dev);\n\t\t}\n\t}\n\tif (ap->pmp_link) {\n\t\tint i;\n\t\tfor (i = 0; i < SATA_PMP_MAX_PORTS; i++)\n\t\t\tata_tlink_delete(&ap->pmp_link[i]);\n\t}\n\t \n\tscsi_remove_host(ap->scsi_host);\n\tata_tport_delete(ap);\n}\n\n \nvoid ata_host_detach(struct ata_host *host)\n{\n\tint i;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\t \n\t\tasync_synchronize_cookie(host->ports[i]->cookie + 1);\n\t\tata_port_detach(host->ports[i]);\n\t}\n\n\t \n\tata_acpi_dissociate(host);\n}\nEXPORT_SYMBOL_GPL(ata_host_detach);\n\n#ifdef CONFIG_PCI\n\n \nvoid ata_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\tata_host_detach(host);\n}\nEXPORT_SYMBOL_GPL(ata_pci_remove_one);\n\nvoid ata_pci_shutdown_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tap->pflags |= ATA_PFLAG_FROZEN;\n\n\t\t \n\t\tif (ap->ops->freeze)\n\t\t\tap->ops->freeze(ap);\n\n\t\t \n\t\tif (ap->ops->port_stop)\n\t\t\tap->ops->port_stop(ap);\n\t}\n}\nEXPORT_SYMBOL_GPL(ata_pci_shutdown_one);\n\n \nint pci_test_config_bits(struct pci_dev *pdev, const struct pci_bits *bits)\n{\n\tunsigned long tmp = 0;\n\n\tswitch (bits->width) {\n\tcase 1: {\n\t\tu8 tmp8 = 0;\n\t\tpci_read_config_byte(pdev, bits->reg, &tmp8);\n\t\ttmp = tmp8;\n\t\tbreak;\n\t}\n\tcase 2: {\n\t\tu16 tmp16 = 0;\n\t\tpci_read_config_word(pdev, bits->reg, &tmp16);\n\t\ttmp = tmp16;\n\t\tbreak;\n\t}\n\tcase 4: {\n\t\tu32 tmp32 = 0;\n\t\tpci_read_config_dword(pdev, bits->reg, &tmp32);\n\t\ttmp = tmp32;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttmp &= bits->mask;\n\n\treturn (tmp == bits->val) ? 1 : 0;\n}\nEXPORT_SYMBOL_GPL(pci_test_config_bits);\n\n#ifdef CONFIG_PM\nvoid ata_pci_device_do_suspend(struct pci_dev *pdev, pm_message_t mesg)\n{\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\n\tif (mesg.event & PM_EVENT_SLEEP)\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n}\nEXPORT_SYMBOL_GPL(ata_pci_device_do_suspend);\n\nint ata_pci_device_do_resume(struct pci_dev *pdev)\n{\n\tint rc;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to enable device after resume (%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tpci_set_master(pdev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_pci_device_do_resume);\n\nint ata_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\tata_host_suspend(host, mesg);\n\n\tata_pci_device_do_suspend(pdev, mesg);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_pci_device_suspend);\n\nint ata_pci_device_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc == 0)\n\t\tata_host_resume(host);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_pci_device_resume);\n#endif  \n#endif  \n\n \nvoid ata_platform_remove_one(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\n\tata_host_detach(host);\n}\nEXPORT_SYMBOL_GPL(ata_platform_remove_one);\n\n#ifdef CONFIG_ATA_FORCE\n\n#define force_cbl(name, flag)\t\t\t\t\\\n\t{ #name,\t.cbl\t\t= (flag) }\n\n#define force_spd_limit(spd, val)\t\t\t\\\n\t{ #spd,\t.spd_limit\t\t= (val) }\n\n#define force_xfer(mode, shift)\t\t\t\t\\\n\t{ #mode,\t.xfer_mask\t= (1UL << (shift)) }\n\n#define force_lflag_on(name, flags)\t\t\t\\\n\t{ #name,\t.lflags_on\t= (flags) }\n\n#define force_lflag_onoff(name, flags)\t\t\t\\\n\t{ \"no\" #name,\t.lflags_on\t= (flags) },\t\\\n\t{ #name,\t.lflags_off\t= (flags) }\n\n#define force_horkage_on(name, flag)\t\t\t\\\n\t{ #name,\t.horkage_on\t= (flag) }\n\n#define force_horkage_onoff(name, flag)\t\t\t\\\n\t{ \"no\" #name,\t.horkage_on\t= (flag) },\t\\\n\t{ #name,\t.horkage_off\t= (flag) }\n\nstatic const struct ata_force_param force_tbl[] __initconst = {\n\tforce_cbl(40c,\t\t\tATA_CBL_PATA40),\n\tforce_cbl(80c,\t\t\tATA_CBL_PATA80),\n\tforce_cbl(short40c,\t\tATA_CBL_PATA40_SHORT),\n\tforce_cbl(unk,\t\t\tATA_CBL_PATA_UNK),\n\tforce_cbl(ign,\t\t\tATA_CBL_PATA_IGN),\n\tforce_cbl(sata,\t\t\tATA_CBL_SATA),\n\n\tforce_spd_limit(1.5Gbps,\t1),\n\tforce_spd_limit(3.0Gbps,\t2),\n\n\tforce_xfer(pio0,\t\tATA_SHIFT_PIO + 0),\n\tforce_xfer(pio1,\t\tATA_SHIFT_PIO + 1),\n\tforce_xfer(pio2,\t\tATA_SHIFT_PIO + 2),\n\tforce_xfer(pio3,\t\tATA_SHIFT_PIO + 3),\n\tforce_xfer(pio4,\t\tATA_SHIFT_PIO + 4),\n\tforce_xfer(pio5,\t\tATA_SHIFT_PIO + 5),\n\tforce_xfer(pio6,\t\tATA_SHIFT_PIO + 6),\n\tforce_xfer(mwdma0,\t\tATA_SHIFT_MWDMA + 0),\n\tforce_xfer(mwdma1,\t\tATA_SHIFT_MWDMA + 1),\n\tforce_xfer(mwdma2,\t\tATA_SHIFT_MWDMA + 2),\n\tforce_xfer(mwdma3,\t\tATA_SHIFT_MWDMA + 3),\n\tforce_xfer(mwdma4,\t\tATA_SHIFT_MWDMA + 4),\n\tforce_xfer(udma0,\t\tATA_SHIFT_UDMA + 0),\n\tforce_xfer(udma16,\t\tATA_SHIFT_UDMA + 0),\n\tforce_xfer(udma/16,\t\tATA_SHIFT_UDMA + 0),\n\tforce_xfer(udma1,\t\tATA_SHIFT_UDMA + 1),\n\tforce_xfer(udma25,\t\tATA_SHIFT_UDMA + 1),\n\tforce_xfer(udma/25,\t\tATA_SHIFT_UDMA + 1),\n\tforce_xfer(udma2,\t\tATA_SHIFT_UDMA + 2),\n\tforce_xfer(udma33,\t\tATA_SHIFT_UDMA + 2),\n\tforce_xfer(udma/33,\t\tATA_SHIFT_UDMA + 2),\n\tforce_xfer(udma3,\t\tATA_SHIFT_UDMA + 3),\n\tforce_xfer(udma44,\t\tATA_SHIFT_UDMA + 3),\n\tforce_xfer(udma/44,\t\tATA_SHIFT_UDMA + 3),\n\tforce_xfer(udma4,\t\tATA_SHIFT_UDMA + 4),\n\tforce_xfer(udma66,\t\tATA_SHIFT_UDMA + 4),\n\tforce_xfer(udma/66,\t\tATA_SHIFT_UDMA + 4),\n\tforce_xfer(udma5,\t\tATA_SHIFT_UDMA + 5),\n\tforce_xfer(udma100,\t\tATA_SHIFT_UDMA + 5),\n\tforce_xfer(udma/100,\t\tATA_SHIFT_UDMA + 5),\n\tforce_xfer(udma6,\t\tATA_SHIFT_UDMA + 6),\n\tforce_xfer(udma133,\t\tATA_SHIFT_UDMA + 6),\n\tforce_xfer(udma/133,\t\tATA_SHIFT_UDMA + 6),\n\tforce_xfer(udma7,\t\tATA_SHIFT_UDMA + 7),\n\n\tforce_lflag_on(nohrst,\t\tATA_LFLAG_NO_HRST),\n\tforce_lflag_on(nosrst,\t\tATA_LFLAG_NO_SRST),\n\tforce_lflag_on(norst,\t\tATA_LFLAG_NO_HRST | ATA_LFLAG_NO_SRST),\n\tforce_lflag_on(rstonce,\t\tATA_LFLAG_RST_ONCE),\n\tforce_lflag_onoff(dbdelay,\tATA_LFLAG_NO_DEBOUNCE_DELAY),\n\n\tforce_horkage_onoff(ncq,\tATA_HORKAGE_NONCQ),\n\tforce_horkage_onoff(ncqtrim,\tATA_HORKAGE_NO_NCQ_TRIM),\n\tforce_horkage_onoff(ncqati,\tATA_HORKAGE_NO_NCQ_ON_ATI),\n\n\tforce_horkage_onoff(trim,\tATA_HORKAGE_NOTRIM),\n\tforce_horkage_on(trim_zero,\tATA_HORKAGE_ZERO_AFTER_TRIM),\n\tforce_horkage_on(max_trim_128m, ATA_HORKAGE_MAX_TRIM_128M),\n\n\tforce_horkage_onoff(dma,\tATA_HORKAGE_NODMA),\n\tforce_horkage_on(atapi_dmadir,\tATA_HORKAGE_ATAPI_DMADIR),\n\tforce_horkage_on(atapi_mod16_dma, ATA_HORKAGE_ATAPI_MOD16_DMA),\n\n\tforce_horkage_onoff(dmalog,\tATA_HORKAGE_NO_DMA_LOG),\n\tforce_horkage_onoff(iddevlog,\tATA_HORKAGE_NO_ID_DEV_LOG),\n\tforce_horkage_onoff(logdir,\tATA_HORKAGE_NO_LOG_DIR),\n\n\tforce_horkage_on(max_sec_128,\tATA_HORKAGE_MAX_SEC_128),\n\tforce_horkage_on(max_sec_1024,\tATA_HORKAGE_MAX_SEC_1024),\n\tforce_horkage_on(max_sec_lba48,\tATA_HORKAGE_MAX_SEC_LBA48),\n\n\tforce_horkage_onoff(lpm,\tATA_HORKAGE_NOLPM),\n\tforce_horkage_onoff(setxfer,\tATA_HORKAGE_NOSETXFER),\n\tforce_horkage_on(dump_id,\tATA_HORKAGE_DUMP_ID),\n\tforce_horkage_onoff(fua,\tATA_HORKAGE_NO_FUA),\n\n\tforce_horkage_on(disable,\tATA_HORKAGE_DISABLE),\n};\n\nstatic int __init ata_parse_force_one(char **cur,\n\t\t\t\t      struct ata_force_ent *force_ent,\n\t\t\t\t      const char **reason)\n{\n\tchar *start = *cur, *p = *cur;\n\tchar *id, *val, *endp;\n\tconst struct ata_force_param *match_fp = NULL;\n\tint nr_matches = 0, i;\n\n\t \n\twhile (*p != '\\0' && *p != ',')\n\t\tp++;\n\n\tif (*p == '\\0')\n\t\t*cur = p;\n\telse\n\t\t*cur = p + 1;\n\n\t*p = '\\0';\n\n\t \n\tp = strchr(start, ':');\n\tif (!p) {\n\t\tval = strstrip(start);\n\t\tgoto parse_val;\n\t}\n\t*p = '\\0';\n\n\tid = strstrip(start);\n\tval = strstrip(p + 1);\n\n\t \n\tp = strchr(id, '.');\n\tif (p) {\n\t\t*p++ = '\\0';\n\t\tforce_ent->device = simple_strtoul(p, &endp, 10);\n\t\tif (p == endp || *endp != '\\0') {\n\t\t\t*reason = \"invalid device\";\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tforce_ent->port = simple_strtoul(id, &endp, 10);\n\tif (id == endp || *endp != '\\0') {\n\t\t*reason = \"invalid port/link\";\n\t\treturn -EINVAL;\n\t}\n\n parse_val:\n\t \n\tfor (i = 0; i < ARRAY_SIZE(force_tbl); i++) {\n\t\tconst struct ata_force_param *fp = &force_tbl[i];\n\n\t\tif (strncasecmp(val, fp->name, strlen(val)))\n\t\t\tcontinue;\n\n\t\tnr_matches++;\n\t\tmatch_fp = fp;\n\n\t\tif (strcasecmp(val, fp->name) == 0) {\n\t\t\tnr_matches = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nr_matches) {\n\t\t*reason = \"unknown value\";\n\t\treturn -EINVAL;\n\t}\n\tif (nr_matches > 1) {\n\t\t*reason = \"ambiguous value\";\n\t\treturn -EINVAL;\n\t}\n\n\tforce_ent->param = *match_fp;\n\n\treturn 0;\n}\n\nstatic void __init ata_parse_force_param(void)\n{\n\tint idx = 0, size = 1;\n\tint last_port = -1, last_device = -1;\n\tchar *p, *cur, *next;\n\n\t \n\tfor (p = ata_force_param_buf; *p; p++)\n\t\tif (*p == ',')\n\t\t\tsize++;\n\n\tata_force_tbl = kcalloc(size, sizeof(ata_force_tbl[0]), GFP_KERNEL);\n\tif (!ata_force_tbl) {\n\t\tprintk(KERN_WARNING \"ata: failed to extend force table, \"\n\t\t       \"libata.force ignored\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfor (cur = ata_force_param_buf; *cur != '\\0'; cur = next) {\n\t\tconst char *reason = \"\";\n\t\tstruct ata_force_ent te = { .port = -1, .device = -1 };\n\n\t\tnext = cur;\n\t\tif (ata_parse_force_one(&next, &te, &reason)) {\n\t\t\tprintk(KERN_WARNING \"ata: failed to parse force \"\n\t\t\t       \"parameter \\\"%s\\\" (%s)\\n\",\n\t\t\t       cur, reason);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (te.port == -1) {\n\t\t\tte.port = last_port;\n\t\t\tte.device = last_device;\n\t\t}\n\n\t\tata_force_tbl[idx++] = te;\n\n\t\tlast_port = te.port;\n\t\tlast_device = te.device;\n\t}\n\n\tata_force_tbl_size = idx;\n}\n\nstatic void ata_free_force_param(void)\n{\n\tkfree(ata_force_tbl);\n}\n#else\nstatic inline void ata_parse_force_param(void) { }\nstatic inline void ata_free_force_param(void) { }\n#endif\n\nstatic int __init ata_init(void)\n{\n\tint rc;\n\n\tata_parse_force_param();\n\n\trc = ata_sff_init();\n\tif (rc) {\n\t\tata_free_force_param();\n\t\treturn rc;\n\t}\n\n\tlibata_transport_init();\n\tata_scsi_transport_template = ata_attach_transport();\n\tif (!ata_scsi_transport_template) {\n\t\tata_sff_exit();\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tprintk(KERN_DEBUG \"libata version \" DRV_VERSION \" loaded.\\n\");\n\treturn 0;\n\nerr_out:\n\treturn rc;\n}\n\nstatic void __exit ata_exit(void)\n{\n\tata_release_transport(ata_scsi_transport_template);\n\tlibata_transport_exit();\n\tata_sff_exit();\n\tata_free_force_param();\n}\n\nsubsys_initcall(ata_init);\nmodule_exit(ata_exit);\n\nstatic DEFINE_RATELIMIT_STATE(ratelimit, HZ / 5, 1);\n\nint ata_ratelimit(void)\n{\n\treturn __ratelimit(&ratelimit);\n}\nEXPORT_SYMBOL_GPL(ata_ratelimit);\n\n \nvoid ata_msleep(struct ata_port *ap, unsigned int msecs)\n{\n\tbool owns_eh = ap && ap->host->eh_owner == current;\n\n\tif (owns_eh)\n\t\tata_eh_release(ap);\n\n\tif (msecs < 20) {\n\t\tunsigned long usecs = msecs * USEC_PER_MSEC;\n\t\tusleep_range(usecs, usecs + 50);\n\t} else {\n\t\tmsleep(msecs);\n\t}\n\n\tif (owns_eh)\n\t\tata_eh_acquire(ap);\n}\nEXPORT_SYMBOL_GPL(ata_msleep);\n\n \nu32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,\n\t\t      unsigned int interval, unsigned int timeout)\n{\n\tunsigned long deadline;\n\tu32 tmp;\n\n\ttmp = ioread32(reg);\n\n\t \n\tdeadline = ata_deadline(jiffies, timeout);\n\n\twhile ((tmp & mask) == val && time_before(jiffies, deadline)) {\n\t\tata_msleep(ap, interval);\n\t\ttmp = ioread32(reg);\n\t}\n\n\treturn tmp;\n}\nEXPORT_SYMBOL_GPL(ata_wait_register);\n\n \nstatic unsigned int ata_dummy_qc_issue(struct ata_queued_cmd *qc)\n{\n\treturn AC_ERR_SYSTEM;\n}\n\nstatic void ata_dummy_error_handler(struct ata_port *ap)\n{\n\t \n}\n\nstruct ata_port_operations ata_dummy_port_ops = {\n\t.qc_prep\t\t= ata_noop_qc_prep,\n\t.qc_issue\t\t= ata_dummy_qc_issue,\n\t.error_handler\t\t= ata_dummy_error_handler,\n\t.sched_eh\t\t= ata_std_sched_eh,\n\t.end_eh\t\t\t= ata_std_end_eh,\n};\nEXPORT_SYMBOL_GPL(ata_dummy_port_ops);\n\nconst struct ata_port_info ata_dummy_port_info = {\n\t.port_ops\t\t= &ata_dummy_port_ops,\n};\nEXPORT_SYMBOL_GPL(ata_dummy_port_info);\n\nvoid ata_print_version(const struct device *dev, const char *version)\n{\n\tdev_printk(KERN_DEBUG, dev, \"version %s\\n\", version);\n}\nEXPORT_SYMBOL(ata_print_version);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(ata_tf_load);\nEXPORT_TRACEPOINT_SYMBOL_GPL(ata_exec_command);\nEXPORT_TRACEPOINT_SYMBOL_GPL(ata_bmdma_setup);\nEXPORT_TRACEPOINT_SYMBOL_GPL(ata_bmdma_start);\nEXPORT_TRACEPOINT_SYMBOL_GPL(ata_bmdma_status);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}