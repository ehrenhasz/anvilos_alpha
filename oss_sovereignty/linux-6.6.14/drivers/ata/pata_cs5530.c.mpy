{
  "module_name": "pata_cs5530.c",
  "hash_id": "4543aac22e4fb109f2831a654fe44615b03da5d002e00bb9c69b1374c8a08e3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_cs5530.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n\n#define DRV_NAME\t\"pata_cs5530\"\n#define DRV_VERSION\t\"0.7.4\"\n\nstatic void __iomem *cs5530_port_base(struct ata_port *ap)\n{\n\tunsigned long bmdma = (unsigned long)ap->ioaddr.bmdma_addr;\n\n\treturn (void __iomem *)((bmdma & ~0x0F) + 0x20 + 0x10 * ap->port_no);\n}\n\n \n\nstatic void cs5530_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const unsigned int cs5530_pio_timings[2][5] = {\n\t\t{0x00009172, 0x00012171, 0x00020080, 0x00032010, 0x00040010},\n\t\t{0xd1329172, 0x71212171, 0x30200080, 0x20102010, 0x00100010}\n\t};\n\tvoid __iomem *base = cs5530_port_base(ap);\n\tu32 tuning;\n\tint format;\n\n\t \n\ttuning = ioread32(base + 0x04);\n\tformat = (tuning & 0x80000000UL) ? 1 : 0;\n\n\t \n\tif (adev->devno)\n\t\tbase += 0x08;\n\n\tiowrite32(cs5530_pio_timings[format][adev->pio_mode - XFER_PIO_0], base);\n}\n\n \n\nstatic void cs5530_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tvoid __iomem *base = cs5530_port_base(ap);\n\tu32 tuning, timing = 0;\n\tu8 reg;\n\n\t \n\ttuning = ioread32(base + 0x04);\n\n\tswitch(adev->dma_mode) {\n\t\tcase XFER_UDMA_0:\n\t\t\ttiming  = 0x00921250;break;\n\t\tcase XFER_UDMA_1:\n\t\t\ttiming  = 0x00911140;break;\n\t\tcase XFER_UDMA_2:\n\t\t\ttiming  = 0x00911030;break;\n\t\tcase XFER_MW_DMA_0:\n\t\t\ttiming  = 0x00077771;break;\n\t\tcase XFER_MW_DMA_1:\n\t\t\ttiming  = 0x00012121;break;\n\t\tcase XFER_MW_DMA_2:\n\t\t\ttiming  = 0x00002020;break;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\t \n\ttiming |= (tuning & 0x80000000UL);\n\tif (adev->devno == 0)  \n\t\tiowrite32(timing, base + 0x04);\n\telse {\n\t\tif (timing & 0x00100000)\n\t\t\ttuning |= 0x00100000;\t \n\t\telse\n\t\t\ttuning &= ~0x00100000;\t \n\t\tiowrite32(tuning, base + 0x04);\n\t\tiowrite32(timing, base + 0x0C);\n\t}\n\n\t \n\treg = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);\n\treg |= (1 << (5 + adev->devno));\n\tiowrite8(reg, ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);\n\n\t \n\n\tap->private_data = adev;\n}\n\n \n\nstatic unsigned int cs5530_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct ata_device *prev = ap->private_data;\n\n\t \n\tif (ata_dma_enabled(adev) && adev != prev && prev != NULL) {\n\t\t \n\t\tif ((ata_using_udma(adev) && !ata_using_udma(prev)) ||\n\t\t    (ata_using_udma(prev) && !ata_using_udma(adev)))\n\t\t    \t \n\t\t    \tcs5530_set_dmamode(ap, adev);\n\t}\n\n\treturn ata_bmdma_qc_issue(qc);\n}\n\nstatic const struct scsi_host_template cs5530_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t= LIBATA_DUMB_MAX_PRD,\n\t.dma_boundary\t= ATA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations cs5530_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\n\t.qc_prep \t= ata_bmdma_dumb_qc_prep,\n\t.qc_issue\t= cs5530_qc_issue,\n\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= cs5530_set_piomode,\n\t.set_dmamode\t= cs5530_set_dmamode,\n};\n\nstatic const struct dmi_system_id palmax_dmi_table[] = {\n\t{\n\t\t.ident = \"Palmax PD1100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Cyrix\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Caddis\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int cs5530_is_palmax(void)\n{\n\tif (dmi_check_system(palmax_dmi_table)) {\n\t\tprintk(KERN_INFO \"Palmax PD1100: Disabling DMA on docking port.\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic int cs5530_init_chip(void)\n{\n\tstruct pci_dev *master_0 = NULL, *cs5530_0 = NULL, *dev = NULL;\n\n\twhile ((dev = pci_get_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {\n\t\tswitch (dev->device) {\n\t\t\tcase PCI_DEVICE_ID_CYRIX_PCI_MASTER:\n\t\t\t\tmaster_0 = pci_dev_get(dev);\n\t\t\t\tbreak;\n\t\t\tcase PCI_DEVICE_ID_CYRIX_5530_LEGACY:\n\t\t\t\tcs5530_0 = pci_dev_get(dev);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!master_0) {\n\t\tprintk(KERN_ERR DRV_NAME \": unable to locate PCI MASTER function\\n\");\n\t\tgoto fail_put;\n\t}\n\tif (!cs5530_0) {\n\t\tprintk(KERN_ERR DRV_NAME \": unable to locate CS5530 LEGACY function\\n\");\n\t\tgoto fail_put;\n\t}\n\n\tpci_set_master(cs5530_0);\n\tpci_try_set_mwi(cs5530_0);\n\n\t \n\n\tpci_write_config_byte(cs5530_0, PCI_CACHE_LINE_SIZE, 0x04);\n\n\t \n\n\tpci_write_config_word(cs5530_0, 0xd0, 0x5006);\n\n\t \n\n\tpci_write_config_byte(master_0, 0x40, 0x1e);\n\n\t \n\n\tpci_write_config_byte(master_0, 0x41, 0x14);\n\n\t \n\n\tpci_write_config_byte(master_0, 0x42, 0x00);\n\tpci_write_config_byte(master_0, 0x43, 0xc1);\n\n\tpci_dev_put(master_0);\n\tpci_dev_put(cs5530_0);\n\treturn 0;\nfail_put:\n\tpci_dev_put(master_0);\n\tpci_dev_put(cs5530_0);\n\treturn -ENODEV;\n}\n\n \n\nstatic int cs5530_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA2,\n\t\t.port_ops = &cs5530_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_palmax_secondary = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.port_ops = &cs5530_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\tint rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (cs5530_init_chip())\n\t\treturn -ENODEV;\n\n\tif (cs5530_is_palmax())\n\t\tppi[1] = &info_palmax_secondary;\n\n\t \n\treturn ata_pci_bmdma_init_one(pdev, ppi, &cs5530_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cs5530_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (cs5530_init_chip())\n\t\treturn -EIO;\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif  \n\nstatic const struct pci_device_id cs5530[] = {\n\t{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5530_IDE), },\n\n\t{ },\n};\n\nstatic struct pci_driver cs5530_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= cs5530,\n\t.probe \t\t= cs5530_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= cs5530_reinit_one,\n#endif\n};\n\nmodule_pci_driver(cs5530_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the Cyrix/NS/AMD 5530\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, cs5530);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}