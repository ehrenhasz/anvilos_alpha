{
  "module_name": "ahci_st.c",
  "hash_id": "b644bac16b9202a440f92713a41da32338520277ee03bf15dfde2d6ac73a35d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_st.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/ahci_platform.h>\n#include <linux/libata.h>\n#include <linux/reset.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n\n#include \"ahci.h\"\n\n#define DRV_NAME  \"st_ahci\"\n\n#define ST_AHCI_OOBR\t\t\t0xbc\n#define ST_AHCI_OOBR_WE\t\t\tBIT(31)\n#define ST_AHCI_OOBR_CWMIN_SHIFT\t24\n#define ST_AHCI_OOBR_CWMAX_SHIFT\t16\n#define ST_AHCI_OOBR_CIMIN_SHIFT\t8\n#define ST_AHCI_OOBR_CIMAX_SHIFT\t0\n\nstruct st_ahci_drv_data {\n\tstruct platform_device *ahci;\n\tstruct reset_control *pwr;\n\tstruct reset_control *sw_rst;\n\tstruct reset_control *pwr_rst;\n};\n\nstatic void st_ahci_configure_oob(void __iomem *mmio)\n{\n\tunsigned long old_val, new_val;\n\n\tnew_val = (0x02 << ST_AHCI_OOBR_CWMIN_SHIFT) |\n\t\t  (0x04 << ST_AHCI_OOBR_CWMAX_SHIFT) |\n\t\t  (0x08 << ST_AHCI_OOBR_CIMIN_SHIFT) |\n\t\t  (0x0C << ST_AHCI_OOBR_CIMAX_SHIFT);\n\n\told_val = readl(mmio + ST_AHCI_OOBR);\n\twritel(old_val | ST_AHCI_OOBR_WE, mmio + ST_AHCI_OOBR);\n\twritel(new_val | ST_AHCI_OOBR_WE, mmio + ST_AHCI_OOBR);\n\twritel(new_val, mmio + ST_AHCI_OOBR);\n}\n\nstatic int st_ahci_deassert_resets(struct ahci_host_priv *hpriv,\n\t\t\t\tstruct device *dev)\n{\n\tstruct st_ahci_drv_data *drv_data = hpriv->plat_data;\n\tint err;\n\n\tif (drv_data->pwr) {\n\t\terr = reset_control_deassert(drv_data->pwr);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to bring out of pwrdwn\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (drv_data->sw_rst) {\n\t\terr = reset_control_deassert(drv_data->sw_rst);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to bring out of sw-rst\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (drv_data->pwr_rst) {\n\t\terr = reset_control_deassert(drv_data->pwr_rst);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to bring out of pwr-rst\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void st_ahci_host_stop(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct st_ahci_drv_data *drv_data = hpriv->plat_data;\n\tstruct device *dev = host->dev;\n\tint err;\n\n\tif (drv_data->pwr) {\n\t\terr = reset_control_assert(drv_data->pwr);\n\t\tif (err)\n\t\t\tdev_err(dev, \"unable to pwrdwn\\n\");\n\t}\n\n\tahci_platform_disable_resources(hpriv);\n}\n\nstatic int st_ahci_probe_resets(struct ahci_host_priv *hpriv,\n\t\t\t\tstruct device *dev)\n{\n\tstruct st_ahci_drv_data *drv_data = hpriv->plat_data;\n\n\tdrv_data->pwr = devm_reset_control_get(dev, \"pwr-dwn\");\n\tif (IS_ERR(drv_data->pwr)) {\n\t\tdev_info(dev, \"power reset control not defined\\n\");\n\t\tdrv_data->pwr = NULL;\n\t}\n\n\tdrv_data->sw_rst = devm_reset_control_get(dev, \"sw-rst\");\n\tif (IS_ERR(drv_data->sw_rst)) {\n\t\tdev_info(dev, \"soft reset control not defined\\n\");\n\t\tdrv_data->sw_rst = NULL;\n\t}\n\n\tdrv_data->pwr_rst = devm_reset_control_get(dev, \"pwr-rst\");\n\tif (IS_ERR(drv_data->pwr_rst)) {\n\t\tdev_dbg(dev, \"power soft reset control not defined\\n\");\n\t\tdrv_data->pwr_rst = NULL;\n\t}\n\n\treturn st_ahci_deassert_resets(hpriv, dev);\n}\n\nstatic struct ata_port_operations st_ahci_port_ops = {\n\t.inherits\t= &ahci_platform_ops,\n\t.host_stop\t= st_ahci_host_stop,\n};\n\nstatic const struct ata_port_info st_ahci_port_info = {\n\t.flags          = AHCI_FLAG_COMMON,\n\t.pio_mask       = ATA_PIO4,\n\t.udma_mask      = ATA_UDMA6,\n\t.port_ops       = &st_ahci_port_ops,\n};\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int st_ahci_probe(struct platform_device *pdev)\n{\n\tstruct st_ahci_drv_data *drv_data;\n\tstruct ahci_host_priv *hpriv;\n\tint err;\n\n\tdrv_data = devm_kzalloc(&pdev->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\thpriv->plat_data = drv_data;\n\n\terr = st_ahci_probe_resets(hpriv, &pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = ahci_platform_enable_resources(hpriv);\n\tif (err)\n\t\treturn err;\n\n\tst_ahci_configure_oob(hpriv->mmio);\n\n\terr = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info,\n\t\t\t\t      &ahci_platform_sht);\n\tif (err) {\n\t\tahci_platform_disable_resources(hpriv);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int st_ahci_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tstruct st_ahci_drv_data *drv_data = hpriv->plat_data;\n\tint err;\n\n\terr = ahci_platform_suspend_host(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (drv_data->pwr) {\n\t\terr = reset_control_assert(drv_data->pwr);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to pwrdwn\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tahci_platform_disable_resources(hpriv);\n\n\treturn 0;\n}\n\nstatic int st_ahci_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint err;\n\n\terr = ahci_platform_enable_resources(hpriv);\n\tif (err)\n\t\treturn err;\n\n\terr = st_ahci_deassert_resets(hpriv, dev);\n\tif (err) {\n\t\tahci_platform_disable_resources(hpriv);\n\t\treturn err;\n\t}\n\n\tst_ahci_configure_oob(hpriv->mmio);\n\n\treturn ahci_platform_resume_host(dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(st_ahci_pm_ops, st_ahci_suspend, st_ahci_resume);\n\nstatic const struct of_device_id st_ahci_match[] = {\n\t{ .compatible = \"st,ahci\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, st_ahci_match);\n\nstatic struct platform_driver st_ahci_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &st_ahci_pm_ops,\n\t\t.of_match_table = st_ahci_match,\n\t},\n\t.probe = st_ahci_probe,\n\t.remove_new = ata_platform_remove_one,\n};\nmodule_platform_driver(st_ahci_driver);\n\nMODULE_AUTHOR(\"Alexandre Torgue <alexandre.torgue@st.com>\");\nMODULE_AUTHOR(\"Francesco Virlinzi <francesco.virlinzi@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SATA AHCI Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}