{
  "module_name": "pata_gayle.c",
  "hash_id": "e64073a2b5fe878fe3344a4a2d0753b5e2fa9050809e2b7ae6f26545fbaec8e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_gayle.c",
  "human_readable_source": "\n\n \n\n#include <linux/ata.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/zorro.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n\n#include <asm/amigahw.h>\n#include <asm/amigaints.h>\n#include <asm/amigayle.h>\n#include <asm/setup.h>\n\n#define DRV_NAME \"pata_gayle\"\n#define DRV_VERSION \"0.1.0\"\n\n#define GAYLE_CONTROL\t0x101a\n\nstatic const struct scsi_host_template pata_gayle_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\n \nstatic unsigned int pata_gayle_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\t\t unsigned char *buf,\n\t\t\t\t\t unsigned int buflen, int rw)\n{\n\tstruct ata_device *dev = qc->dev;\n\tstruct ata_port *ap = dev->link->ap;\n\tvoid __iomem *data_addr = ap->ioaddr.data_addr;\n\tunsigned int words = buflen >> 1;\n\n\t \n\tif (rw == READ)\n\t\traw_insw((u16 *)data_addr, (u16 *)buf, words);\n\telse\n\t\traw_outsw((u16 *)data_addr, (u16 *)buf, words);\n\n\t \n\tif (unlikely(buflen & 0x01)) {\n\t\tunsigned char pad[2] = { };\n\n\t\t \n\t\tbuf += buflen - 1;\n\n\t\tif (rw == READ) {\n\t\t\traw_insw((u16 *)data_addr, (u16 *)pad, 1);\n\t\t\t*buf = pad[0];\n\t\t} else {\n\t\t\tpad[0] = *buf;\n\t\t\traw_outsw((u16 *)data_addr, (u16 *)pad, 1);\n\t\t}\n\t\twords++;\n\t}\n\n\treturn words << 1;\n}\n\n \nstatic int pata_gayle_set_mode(struct ata_link *link,\n\t\t\t       struct ata_device **unused)\n{\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\t \n\t\tdev->pio_mode = dev->xfer_mode = XFER_PIO_0;\n\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\tdev->flags |= ATA_DFLAG_PIO;\n\t\tata_dev_info(dev, \"configured for PIO\\n\");\n\t}\n\treturn 0;\n}\n\nstatic bool pata_gayle_irq_check(struct ata_port *ap)\n{\n\tu8 ch;\n\n\tch = z_readb((unsigned long)ap->private_data);\n\n\treturn !!(ch & GAYLE_IRQ_IDE);\n}\n\nstatic void pata_gayle_irq_clear(struct ata_port *ap)\n{\n\t(void)z_readb((unsigned long)ap->ioaddr.status_addr);\n\tz_writeb(0x7c, (unsigned long)ap->private_data);\n}\n\nstatic struct ata_port_operations pata_gayle_a1200_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t= pata_gayle_data_xfer,\n\t.sff_irq_check\t= pata_gayle_irq_check,\n\t.sff_irq_clear\t= pata_gayle_irq_clear,\n\t.cable_detect\t= ata_cable_unknown,\n\t.set_mode\t= pata_gayle_set_mode,\n};\n\nstatic struct ata_port_operations pata_gayle_a4000_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t= pata_gayle_data_xfer,\n\t.cable_detect\t= ata_cable_unknown,\n\t.set_mode\t= pata_gayle_set_mode,\n};\n\nstatic int __init pata_gayle_init_one(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct gayle_ide_platform_data *pdata;\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\tdev_info(&pdev->dev, \"Amiga Gayle IDE controller (A%u style)\\n\",\n\t\tpdata->explicit_ack ? 1200 : 4000);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tif (!devm_request_mem_region(&pdev->dev, res->start,\n\t\t\t\t     resource_size(res), DRV_NAME)) {\n\t\tpr_err(DRV_NAME \": resources busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tap = host->ports[0];\n\n\tif (pdata->explicit_ack)\n\t\tap->ops = &pata_gayle_a1200_ops;\n\telse\n\t\tap->ops = &pata_gayle_a4000_ops;\n\n\tap->pio_mask = ATA_PIO4;\n\tap->flags |= ATA_FLAG_SLAVE_POSS | ATA_FLAG_NO_IORDY;\n\n\tbase = ZTWO_VADDR(pdata->base);\n\tap->ioaddr.data_addr\t\t= base;\n\tap->ioaddr.error_addr\t\t= base + 2 + 1 * 4;\n\tap->ioaddr.feature_addr\t\t= base + 2 + 1 * 4;\n\tap->ioaddr.nsect_addr\t\t= base + 2 + 2 * 4;\n\tap->ioaddr.lbal_addr\t\t= base + 2 + 3 * 4;\n\tap->ioaddr.lbam_addr\t\t= base + 2 + 4 * 4;\n\tap->ioaddr.lbah_addr\t\t= base + 2 + 5 * 4;\n\tap->ioaddr.device_addr\t\t= base + 2 + 6 * 4;\n\tap->ioaddr.status_addr\t\t= base + 2 + 7 * 4;\n\tap->ioaddr.command_addr\t\t= base + 2 + 7 * 4;\n\n\tap->ioaddr.altstatus_addr\t= base + GAYLE_CONTROL;\n\tap->ioaddr.ctl_addr\t\t= base + GAYLE_CONTROL;\n\n\tap->private_data = (void *)ZTWO_VADDR(pdata->irqport);\n\n\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\", pdata->base,\n\t\t      pdata->base + GAYLE_CONTROL);\n\n\tret = ata_host_activate(host, IRQ_AMIGA_PORTS, ata_sff_interrupt,\n\t\t\t\tIRQF_SHARED, &pata_gayle_sht);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, host);\n\n\treturn 0;\n}\n\nstatic int __exit pata_gayle_remove_one(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\n\tata_host_detach(host);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pata_gayle_driver = {\n\t.remove = __exit_p(pata_gayle_remove_one),\n\t.driver   = {\n\t\t.name\t= \"amiga-gayle-ide\",\n\t},\n};\n\nmodule_platform_driver_probe(pata_gayle_driver, pata_gayle_init_one);\n\nMODULE_AUTHOR(\"Bartlomiej Zolnierkiewicz\");\nMODULE_DESCRIPTION(\"low-level driver for Amiga Gayle PATA\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:amiga-gayle-ide\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}