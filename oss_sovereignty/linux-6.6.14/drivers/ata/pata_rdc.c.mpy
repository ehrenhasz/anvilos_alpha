{
  "module_name": "pata_rdc.c",
  "hash_id": "9da1815f82e5a4964389c575139ecd170c926a2cebc71eccec7c083760bc66d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_rdc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n\n#define DRV_NAME\t\"pata_rdc\"\n#define DRV_VERSION\t\"0.01\"\n\nstruct rdc_host_priv {\n\tu32 saved_iocfg;\n};\n\n \n\nstatic int rdc_pata_cable_detect(struct ata_port *ap)\n{\n\tstruct rdc_host_priv *hpriv = ap->host->private_data;\n\tu8 mask;\n\n\t \n\tmask = 0x30 << (2 * ap->port_no);\n\tif ((hpriv->saved_iocfg & mask) == 0)\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\n \nstatic int rdc_pata_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tstatic const struct pci_bits rdc_enable_bits[] = {\n\t\t{ 0x41U, 1U, 0x80UL, 0x80UL },\t \n\t\t{ 0x43U, 1U, 0x80UL, 0x80UL },\t \n\t};\n\n\tif (!pci_test_config_bits(pdev, &rdc_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic DEFINE_SPINLOCK(rdc_lock);\n\n \n\nstatic void rdc_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tunsigned int pio\t= adev->pio_mode - XFER_PIO_0;\n\tstruct pci_dev *dev\t= to_pci_dev(ap->host->dev);\n\tunsigned long flags;\n\tunsigned int is_slave\t= (adev->devno != 0);\n\tunsigned int master_port= ap->port_no ? 0x42 : 0x40;\n\tunsigned int slave_port\t= 0x44;\n\tu16 master_data;\n\tu8 slave_data;\n\tu8 udma_enable;\n\tint control = 0;\n\n\tstatic const\t  \n\tu8 timings[][2]\t= { { 0, 0 },\n\t\t\t    { 0, 0 },\n\t\t\t    { 1, 0 },\n\t\t\t    { 2, 1 },\n\t\t\t    { 2, 3 }, };\n\n\tif (pio >= 2)\n\t\tcontrol |= 1;\t \n\tif (ata_pio_need_iordy(adev))\n\t\tcontrol |= 2;\t \n\n\tif (adev->class == ATA_DEV_ATA)\n\t\tcontrol |= 4;\t \n\n\tspin_lock_irqsave(&rdc_lock, flags);\n\n\t \n\tpci_read_config_word(dev, master_port, &master_data);\n\tif (is_slave) {\n\t\t \n\t\tmaster_data &= 0xff0f;\n\t\t \n\t\tmaster_data |= 0x4000;\n\t\t \n\t\tmaster_data |= (control << 4);\n\t\tpci_read_config_byte(dev, slave_port, &slave_data);\n\t\tslave_data &= (ap->port_no ? 0x0f : 0xf0);\n\t\t \n\t\tslave_data |= ((timings[pio][0] << 2) | timings[pio][1])\n\t\t\t\t\t\t<< (ap->port_no ? 4 : 0);\n\t} else {\n\t\t \n\t\tmaster_data &= 0xccf0;\n\t\t \n\t\tmaster_data |= control;\n\t\t \n\t\tmaster_data |=\n\t\t\t(timings[pio][0] << 12) |\n\t\t\t(timings[pio][1] << 8);\n\t}\n\tpci_write_config_word(dev, master_port, master_data);\n\tif (is_slave)\n\t\tpci_write_config_byte(dev, slave_port, slave_data);\n\n\t \n\n\tpci_read_config_byte(dev, 0x48, &udma_enable);\n\tudma_enable &= ~(1 << (2 * ap->port_no + adev->devno));\n\tpci_write_config_byte(dev, 0x48, udma_enable);\n\n\tspin_unlock_irqrestore(&rdc_lock, flags);\n}\n\n \n\nstatic void rdc_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *dev\t= to_pci_dev(ap->host->dev);\n\tunsigned long flags;\n\tu8 master_port\t\t= ap->port_no ? 0x42 : 0x40;\n\tu16 master_data;\n\tu8 speed\t\t= adev->dma_mode;\n\tint devid\t\t= adev->devno + 2 * ap->port_no;\n\tu8 udma_enable\t\t= 0;\n\n\tstatic const\t  \n\tu8 timings[][2]\t= { { 0, 0 },\n\t\t\t    { 0, 0 },\n\t\t\t    { 1, 0 },\n\t\t\t    { 2, 1 },\n\t\t\t    { 2, 3 }, };\n\n\tspin_lock_irqsave(&rdc_lock, flags);\n\n\tpci_read_config_word(dev, master_port, &master_data);\n\tpci_read_config_byte(dev, 0x48, &udma_enable);\n\n\tif (speed >= XFER_UDMA_0) {\n\t\tunsigned int udma = adev->dma_mode - XFER_UDMA_0;\n\t\tu16 udma_timing;\n\t\tu16 ideconf;\n\t\tint u_clock, u_speed;\n\n\t\t \n\t\tu_speed = min(2 - (udma & 1), udma);\n\t\tif (udma == 5)\n\t\t\tu_clock = 0x1000;\t \n\t\telse if (udma > 2)\n\t\t\tu_clock = 1;\t\t \n\t\telse\n\t\t\tu_clock = 0;\t\t \n\n\t\tudma_enable |= (1 << devid);\n\n\t\t \n\t\tpci_read_config_word(dev, 0x4A, &udma_timing);\n\t\tudma_timing &= ~(3 << (4 * devid));\n\t\tudma_timing |= u_speed << (4 * devid);\n\t\tpci_write_config_word(dev, 0x4A, udma_timing);\n\n\t\t \n\t\tpci_read_config_word(dev, 0x54, &ideconf);\n\t\tideconf &= ~(0x1001 << devid);\n\t\tideconf |= u_clock << devid;\n\t\tpci_write_config_word(dev, 0x54, ideconf);\n\t} else {\n\t\t \n\t\tunsigned int mwdma\t= adev->dma_mode - XFER_MW_DMA_0;\n\t\tunsigned int control;\n\t\tu8 slave_data;\n\t\tconst unsigned int needed_pio[3] = {\n\t\t\tXFER_PIO_0, XFER_PIO_3, XFER_PIO_4\n\t\t};\n\t\tint pio = needed_pio[mwdma] - XFER_PIO_0;\n\n\t\tcontrol = 3;\t \n\n\t\t \n\n\t\tif (adev->pio_mode < needed_pio[mwdma])\n\t\t\t \n\t\t\tcontrol |= 8;\t \n\n\t\tif (adev->devno) {\t \n\t\t\tmaster_data &= 0xFF4F;   \n\t\t\tmaster_data |= control << 4;\n\t\t\tpci_read_config_byte(dev, 0x44, &slave_data);\n\t\t\tslave_data &= (ap->port_no ? 0x0f : 0xf0);\n\t\t\t \n\t\t\tslave_data |= ((timings[pio][0] << 2) | timings[pio][1]) << (ap->port_no ? 4 : 0);\n\t\t\tpci_write_config_byte(dev, 0x44, slave_data);\n\t\t} else { \t \n\t\t\tmaster_data &= 0xCCF4;\t \n\t\t\tmaster_data |= control;\n\t\t\tmaster_data |=\n\t\t\t\t(timings[pio][0] << 12) |\n\t\t\t\t(timings[pio][1] << 8);\n\t\t}\n\n\t\tudma_enable &= ~(1 << devid);\n\t\tpci_write_config_word(dev, master_port, master_data);\n\t}\n\tpci_write_config_byte(dev, 0x48, udma_enable);\n\n\tspin_unlock_irqrestore(&rdc_lock, flags);\n}\n\nstatic struct ata_port_operations rdc_pata_ops = {\n\t.inherits\t\t= &ata_bmdma32_port_ops,\n\t.cable_detect\t\t= rdc_pata_cable_detect,\n\t.set_piomode\t\t= rdc_set_piomode,\n\t.set_dmamode\t\t= rdc_set_dmamode,\n\t.prereset\t\t= rdc_pata_prereset,\n};\n\nstatic const struct ata_port_info rdc_port_info = {\n\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA12_ONLY,\n\t.udma_mask\t= ATA_UDMA5,\n\t.port_ops\t= &rdc_pata_ops,\n};\n\nstatic const struct scsi_host_template rdc_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n \n\nstatic int rdc_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ata_port_info port_info[2];\n\tconst struct ata_port_info *ppi[] = { &port_info[0], &port_info[1] };\n\tstruct ata_host *host;\n\tstruct rdc_host_priv *hpriv;\n\tint rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\tport_info[0] = rdc_port_info;\n\tport_info[1] = rdc_port_info;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\n\t \n\tpci_read_config_dword(pdev, 0x54, &hpriv->saved_iocfg);\n\n\trc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\n\tif (rc)\n\t\treturn rc;\n\thost->private_data = hpriv;\n\n\tpci_intx(pdev, 1);\n\n\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n\n\tpci_set_master(pdev);\n\treturn ata_pci_sff_activate_host(host, ata_bmdma_interrupt, &rdc_sht);\n}\n\nstatic void rdc_remove_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tstruct rdc_host_priv *hpriv = host->private_data;\n\n\tpci_write_config_dword(pdev, 0x54, hpriv->saved_iocfg);\n\n\tata_pci_remove_one(pdev);\n}\n\nstatic const struct pci_device_id rdc_pci_tbl[] = {\n\t{ PCI_DEVICE(0x17F3, 0x1011), },\n\t{ PCI_DEVICE(0x17F3, 0x1012), },\n\t{ }\t \n};\n\nstatic struct pci_driver rdc_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= rdc_pci_tbl,\n\t.probe\t\t\t= rdc_init_one,\n\t.remove\t\t\t= rdc_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= ata_pci_device_resume,\n#endif\n};\n\n\nmodule_pci_driver(rdc_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox (based on ata_piix)\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for RDC PATA controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, rdc_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}