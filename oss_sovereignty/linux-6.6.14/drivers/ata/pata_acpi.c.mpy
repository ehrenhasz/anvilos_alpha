{
  "module_name": "pata_acpi.c",
  "hash_id": "2e23d9c452536fed4e42d09554c8253553d0c60d650971fb1108cc5f2dc4ee0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/acpi.h>\n#include <linux/libata.h>\n#include <linux/ata.h>\n#include <scsi/scsi_host.h>\n\n#define DRV_NAME\t\"pata_acpi\"\n#define DRV_VERSION\t\"0.2.3\"\n\nstruct pata_acpi {\n\tstruct ata_acpi_gtm gtm;\n\tvoid *last;\n\tunsigned long mask[2];\n};\n\n \n\nstatic int pacpi_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pata_acpi *acpi = ap->private_data;\n\tif (ACPI_HANDLE(&ap->tdev) == NULL || ata_acpi_gtm(ap, &acpi->gtm) < 0)\n\t\treturn -ENODEV;\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic int pacpi_cable_detect(struct ata_port *ap)\n{\n\tstruct pata_acpi *acpi = ap->private_data;\n\n\tif ((acpi->mask[0] | acpi->mask[1]) & (0xF8 << ATA_SHIFT_UDMA))\n\t\treturn ATA_CBL_PATA80;\n\telse\n\t\treturn ATA_CBL_PATA40;\n}\n\n \n\nstatic unsigned long pacpi_discover_modes(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pata_acpi *acpi = ap->private_data;\n\tstruct ata_acpi_gtm probe;\n\tunsigned int xfer_mask;\n\n\tprobe = acpi->gtm;\n\n\tata_acpi_gtm(ap, &probe);\n\n\txfer_mask = ata_acpi_gtm_xfermask(adev, &probe);\n\n\tif (xfer_mask & (0xF8 << ATA_SHIFT_UDMA))\n\t\tap->cbl = ATA_CBL_PATA80;\n\n\treturn xfer_mask;\n}\n\n \n\nstatic unsigned int pacpi_mode_filter(struct ata_device *adev, unsigned int mask)\n{\n\tstruct pata_acpi *acpi = adev->link->ap->private_data;\n\treturn mask & acpi->mask[adev->devno];\n}\n\n \n\nstatic void pacpi_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tint unit = adev->devno;\n\tstruct pata_acpi *acpi = ap->private_data;\n\tconst struct ata_timing *t;\n\n\tif (!(acpi->gtm.flags & 0x10))\n\t\tunit = 0;\n\n\t \n\tt = ata_timing_find_mode(adev->pio_mode);\n\tacpi->gtm.drive[unit].pio = t->cycle;\n\tata_acpi_stm(ap, &acpi->gtm);\n\t \n\tata_acpi_gtm(ap, &acpi->gtm);\n}\n\n \n\nstatic void pacpi_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tint unit = adev->devno;\n\tstruct pata_acpi *acpi = ap->private_data;\n\tconst struct ata_timing *t;\n\n\tif (!(acpi->gtm.flags & 0x10))\n\t\tunit = 0;\n\n\t \n\tt = ata_timing_find_mode(adev->dma_mode);\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tacpi->gtm.drive[unit].dma = t->udma;\n\t\tacpi->gtm.flags |= (1 << (2 * unit));\n\t} else {\n\t\tacpi->gtm.drive[unit].dma = t->cycle;\n\t\tacpi->gtm.flags &= ~(1 << (2 * unit));\n\t}\n\tata_acpi_stm(ap, &acpi->gtm);\n\t \n\tata_acpi_gtm(ap, &acpi->gtm);\n}\n\n \n\nstatic unsigned int pacpi_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct pata_acpi *acpi = ap->private_data;\n\n\tif (acpi->gtm.flags & 0x10)\n\t\treturn ata_bmdma_qc_issue(qc);\n\n\tif (adev != acpi->last) {\n\t\tpacpi_set_piomode(ap, adev);\n\t\tif (ata_dma_enabled(adev))\n\t\t\tpacpi_set_dmamode(ap, adev);\n\t\tacpi->last = adev;\n\t}\n\treturn ata_bmdma_qc_issue(qc);\n}\n\n \n\nstatic int pacpi_port_start(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct pata_acpi *acpi;\n\n\tif (ACPI_HANDLE(&ap->tdev) == NULL)\n\t\treturn -ENODEV;\n\n\tacpi = ap->private_data = devm_kzalloc(&pdev->dev, sizeof(struct pata_acpi), GFP_KERNEL);\n\tif (ap->private_data == NULL)\n\t\treturn -ENOMEM;\n\tacpi->mask[0] = pacpi_discover_modes(ap, &ap->link.device[0]);\n\tacpi->mask[1] = pacpi_discover_modes(ap, &ap->link.device[1]);\n\treturn ata_bmdma_port_start(ap);\n}\n\nstatic const struct scsi_host_template pacpi_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations pacpi_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.qc_issue\t\t= pacpi_qc_issue,\n\t.cable_detect\t\t= pacpi_cable_detect,\n\t.mode_filter\t\t= pacpi_mode_filter,\n\t.set_piomode\t\t= pacpi_set_piomode,\n\t.set_dmamode\t\t= pacpi_set_dmamode,\n\t.prereset\t\t= pacpi_pre_reset,\n\t.port_start\t\t= pacpi_port_start,\n};\n\n\n \n\nstatic int pacpi_init_one (struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask \t= ATA_UDMA6,\n\n\t\t.port_ops\t= &pacpi_ops,\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\tif (pdev->vendor == PCI_VENDOR_ID_ATI) {\n\t\tint rc = pcim_enable_device(pdev);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tpcim_pin_device(pdev);\n\t}\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &pacpi_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id pacpi_pci_tbl[] = {\n\t{ PCI_ANY_ID,\t\tPCI_ANY_ID,\t\t\t   PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 1},\n\t{ }\t \n};\n\nstatic struct pci_driver pacpi_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= pacpi_pci_tbl,\n\t.probe\t\t\t= pacpi_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(pacpi_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for ATA in ACPI mode\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pacpi_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}