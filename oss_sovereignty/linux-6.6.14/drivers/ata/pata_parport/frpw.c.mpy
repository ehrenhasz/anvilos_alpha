{
  "module_name": "frpw.c",
  "hash_id": "caa5fd954b05bbf136c48c0370f07628225a2e32098560fb664c1115631feeb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/frpw.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n#define cec4\t\tw2(0xc);w2(0xe);w2(0xe);w2(0xc);w2(4);w2(4);w2(4);\n#define j44(l,h)\t(((l>>4)&0x0f)|(h&0xf0))\n\n \nstatic int  cont_map[2] = { 0x08, 0x10 };\n\nstatic int frpw_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint h, l, r;\n\n\tr = regr + cont_map[cont];\n\n\tw2(4);\n\tw0(r); cec4;\n\tw2(6); l = r1();\n\tw2(4); h = r1();\n\tw2(4);\n\n\treturn j44(l, h);\n}\n\nstatic void frpw_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint r = regr + cont_map[cont];\n\n\tw2(4); w0(r); cec4;\n\tw0(val);\n\tw2(5); w2(7); w2(5); w2(4);\n}\n\nstatic void frpw_read_block_int(struct pi_adapter *pi, char *buf, int count,\n\t\t\t\tint regr)\n{\n\tint h, l, k, ph;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw2(4); w0(regr); cec4;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(6); l = r1();\n\t\t\tw2(4); h = r1();\n\t\t\tbuf[k] = j44(l, h);\n\t\t}\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 1:\n\t\tph = 2;\n\t\tw2(4); w0(regr + 0xc0); cec4;\n\t\tw0(0xff);\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(0xa4 + ph);\n\t\t\tbuf[k] = r0();\n\t\t\tph = 2 - ph;\n\t\t}\n\t\tw2(0xac); w2(0xa4); w2(4);\n\t\tbreak;\n\n\tcase 2:\n\t\tw2(4); w0(regr + 0x80); cec4;\n\t\tfor (k = 0; k < count; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(0xac); w2(0xa4);\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 3:\n\t\tw2(4); w0(regr + 0x80); cec4;\n\t\tfor (k = 0; k < count - 2; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(0xac); w2(0xa4);\n\t\tbuf[count - 2] = r4();\n\t\tbuf[count - 1] = r4();\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 4:\n\t\tw2(4); w0(regr + 0x80); cec4;\n\t\tfor (k = 0; k < count / 2 - 1; k++)\n\t\t\t((u16 *)buf)[k] = r4w();\n\t\tw2(0xac); w2(0xa4);\n\t\tbuf[count - 2] = r4();\n\t\tbuf[count - 1] = r4();\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 5:\n\t\tw2(4); w0(regr + 0x80); cec4;\n\t\tfor (k = 0; k < count / 4 - 1; k++)\n\t\t\t((u32 *)buf)[k] = r4l();\n\t\tbuf[count - 4] = r4();\n\t\tbuf[count - 3] = r4();\n\t\tw2(0xac); w2(0xa4);\n\t\tbuf[count - 2] = r4();\n\t\tbuf[count - 1] = r4();\n\t\tw2(4);\n\t\tbreak;\n        }\n}\n\nstatic void frpw_read_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tfrpw_read_block_int(pi, buf, count, 0x08);\n}\n\nstatic void frpw_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint k;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tw2(4); w0(8); cec4; w2(5);\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw0(buf[k]);\n\t\t\tw2(7); w2(5);\n\t\t}\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 3:\n\t\tw2(4); w0(0xc8); cec4; w2(5);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tw4(buf[k]);\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 4:\n\t\tw2(4); w0(0xc8); cec4; w2(5);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\tw4w(((u16 *)buf)[k]);\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 5:\n\t\tw2(4); w0(0xc8); cec4; w2(5);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\tw4l(((u32 *)buf)[k]);\n\t\tw2(4);\n\t\tbreak;\n\t}\n}\n\nstatic void frpw_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\tw2(4);\n}\n\nstatic void frpw_disconnect(struct pi_adapter *pi)\n{\n\tw2(4); w0(0x20); cec4;\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\n \nstatic int frpw_test_pnp(struct pi_adapter *pi)\n{\n\tint olddelay, a, b;\n\n#ifdef FRPW_HARD_RESET\n        w0(0); w2(8); udelay(50); w2(0xc);    \n        mdelay(1500);\n#endif\n\n\tolddelay = pi->delay;\n\tpi->delay = 10;\n\n\tpi->saved_r0 = r0();\n        pi->saved_r2 = r2();\n\n\tw2(4); w0(4); w2(6); w2(7);\n\ta = r1() & 0xff; w2(4); b = r1() & 0xff;\n\tw2(0xc); w2(0xe); w2(4);\n\n\tpi->delay = olddelay;\n        w0(pi->saved_r0);\n        w2(pi->saved_r2);\n\n\treturn ((~a & 0x40) && (b & 0x40));\n}\n\n \nstatic int frpw_test_proto(struct pi_adapter *pi)\n{\n\tint j, k, r;\n\tint e[2] = { 0, 0 };\n\tchar scratch[512];\n\n\tif ((pi->private >> 1) != pi->port)\n\t\tpi->private = frpw_test_pnp(pi) + 2*pi->port;\n\n\tif (((pi->private & 0x1) == 0) && (pi->mode > 2)) {\n\t\tdev_dbg(&pi->dev,\n\t\t\t\"frpw: Xilinx does not support mode %d\\n\", pi->mode);\n\t\treturn 1;\n\t}\n\n\tif (((pi->private & 0x1) == 1) && (pi->mode == 2)) {\n\t\tdev_dbg(&pi->dev, \"frpw: ASIC does not support mode 2\\n\");\n\t\treturn 1;\n\t}\n\n\tfrpw_connect(pi);\n\tfor (j = 0; j < 2; j++) {\n\t\tfrpw_write_regr(pi, 0, 6, 0xa0 + j * 0x10);\n\t\tfor (k = 0; k < 256; k++) {\n\t\t\tfrpw_write_regr(pi, 0, 2, k ^ 0xaa);\n\t\t\tfrpw_write_regr(pi, 0, 3, k ^ 0x55);\n\t\t\tif (frpw_read_regr(pi, 0, 2) != (k ^ 0xaa))\n\t\t\t\te[j]++;\n\t\t}\n\t}\n\tfrpw_disconnect(pi);\n\n\tfrpw_connect(pi);\n\tfrpw_read_block_int(pi, scratch, 512, 0x10);\n\tr = 0;\n\tfor (k = 0; k < 128; k++) {\n\t\tif (scratch[k] != k)\n\t\t\tr++;\n\t}\n\tfrpw_disconnect(pi);\n\n\tdev_dbg(&pi->dev,\n\t\t\"frpw: port 0x%x, chip %ld, mode %d, test=(%d,%d,%d)\\n\",\n\t\tpi->port, (pi->private%2), pi->mode, e[0], e[1], r);\n\n\treturn r || (e[0] && e[1]);\n}\n\nstatic void frpw_log_adapter(struct pi_adapter *pi)\n\n{\n\tchar *mode[6] = { \"4-bit\", \"8-bit\", \"EPP\", \"EPP-8\", \"EPP-16\", \"EPP-32\"};\n\n\tdev_info(&pi->dev,\n\t\t \"Freecom (%s) adapter at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t ((pi->private & 0x1) == 0) ? \"Xilinx\" : \"ASIC\",\n\t\t pi->port, pi->mode, mode[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol frpw = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"frpw\",\n\t.max_mode\t= 6,\n\t.epp_first\t= 2,\n\t.default_delay\t= 2,\n\t.max_units\t= 1,\n\t.write_regr\t= frpw_write_regr,\n\t.read_regr\t= frpw_read_regr,\n\t.write_block\t= frpw_write_block,\n\t.read_block\t= frpw_read_block,\n\t.connect\t= frpw_connect,\n\t.disconnect\t= frpw_disconnect,\n\t.test_proto\t= frpw_test_proto,\n\t.log_adapter\t= frpw_log_adapter,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"Freecom Power parallel port IDE adapter protocol driver\");\nmodule_pata_parport_driver(frpw);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}