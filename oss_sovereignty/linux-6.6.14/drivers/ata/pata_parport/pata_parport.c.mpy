{
  "module_name": "pata_parport.c",
  "hash_id": "daaeacbb88847ecd8de15298f1dd72722f5a584f167211c99b1ffb49a7640309",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/pata_parport.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/parport.h>\n#include \"pata_parport.h\"\n\n#define DRV_NAME \"pata_parport\"\n\nstatic DEFINE_IDR(parport_list);\nstatic DEFINE_IDR(protocols);\nstatic DEFINE_IDA(pata_parport_bus_dev_ids);\nstatic DEFINE_MUTEX(pi_mutex);\n\nstatic bool probe = true;\nmodule_param(probe, bool, 0644);\nMODULE_PARM_DESC(probe, \"Enable automatic device probing (0=off, 1=on [default])\");\n\n \nstatic void pi_connect(struct pi_adapter *pi)\n{\n\tparport_claim_or_block(pi->pardev);\n\tpi->proto->connect(pi);\n}\n\nstatic void pi_disconnect(struct pi_adapter *pi)\n{\n\tpi->proto->disconnect(pi);\n\tparport_release(pi->pardev);\n}\n\nstatic void pata_parport_dev_select(struct ata_port *ap, unsigned int device)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\tu8 tmp;\n\n\tif (device == 0)\n\t\ttmp = ATA_DEVICE_OBS;\n\telse\n\t\ttmp = ATA_DEVICE_OBS | ATA_DEV1;\n\n\tpi->proto->write_regr(pi, 0, ATA_REG_DEVICE, tmp);\n\tata_sff_pause(ap);\n}\n\nstatic void pata_parport_set_devctl(struct ata_port *ap, u8 ctl)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\tpi->proto->write_regr(pi, 1, 6, ctl);\n}\n\nstatic bool pata_parport_devchk(struct ata_port *ap, unsigned int device)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\tu8 nsect, lbal;\n\n\tpata_parport_dev_select(ap, device);\n\n\tpi->proto->write_regr(pi, 0, ATA_REG_NSECT, 0x55);\n\tpi->proto->write_regr(pi, 0, ATA_REG_LBAL, 0xaa);\n\n\tpi->proto->write_regr(pi, 0, ATA_REG_NSECT, 0xaa);\n\tpi->proto->write_regr(pi, 0, ATA_REG_LBAL, 0x55);\n\n\tpi->proto->write_regr(pi, 0, ATA_REG_NSECT, 0x55);\n\tpi->proto->write_regr(pi, 0, ATA_REG_LBAL, 0xaa);\n\n\tnsect = pi->proto->read_regr(pi, 0, ATA_REG_NSECT);\n\tlbal = pi->proto->read_regr(pi, 0, ATA_REG_LBAL);\n\n\treturn (nsect == 0x55) && (lbal == 0xaa);\n}\n\nstatic int pata_parport_wait_after_reset(struct ata_link *link,\n\t\t\t\t\t unsigned int devmask,\n\t\t\t\t\t unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pi_adapter *pi = ap->host->private_data;\n\tunsigned int dev0 = devmask & (1 << 0);\n\tunsigned int dev1 = devmask & (1 << 1);\n\tint rc, ret = 0;\n\n\tata_msleep(ap, ATA_WAIT_AFTER_RESET);\n\n\t \n\trc = ata_sff_wait_ready(link, deadline);\n\tif (rc) {\n\t\t \n\t\tif (!dev1)\n\t\t\treturn rc;\n\t\tret = -ENODEV;\n\t}\n\n\t \n\tif (dev1) {\n\t\tint i;\n\n\t\tpata_parport_dev_select(ap, 1);\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu8 nsect, lbal;\n\n\t\t\tnsect = pi->proto->read_regr(pi, 0, ATA_REG_NSECT);\n\t\t\tlbal = pi->proto->read_regr(pi, 0, ATA_REG_LBAL);\n\t\t\tif (nsect == 1 && lbal == 1)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tata_msleep(ap, 50);\n\t\t}\n\n\t\trc = ata_sff_wait_ready(link, deadline);\n\t\tif (rc) {\n\t\t\tif (rc != -ENODEV)\n\t\t\t\treturn rc;\n\t\t\tret = rc;\n\t\t}\n\t}\n\n\tpata_parport_dev_select(ap, 0);\n\tif (dev1)\n\t\tpata_parport_dev_select(ap, 1);\n\tif (dev0)\n\t\tpata_parport_dev_select(ap, 0);\n\n\treturn ret;\n}\n\nstatic int pata_parport_bus_softreset(struct ata_port *ap, unsigned int devmask,\n\t\t\t\t      unsigned long deadline)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\t \n\tpi->proto->write_regr(pi, 1, 6, ap->ctl);\n\tudelay(20);\n\tpi->proto->write_regr(pi, 1, 6, ap->ctl | ATA_SRST);\n\tudelay(20);\n\tpi->proto->write_regr(pi, 1, 6, ap->ctl);\n\tap->last_ctl = ap->ctl;\n\n\t \n\treturn pata_parport_wait_after_reset(&ap->link, devmask, deadline);\n}\n\nstatic int pata_parport_softreset(struct ata_link *link, unsigned int *classes,\n\t\t\t\t  unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tunsigned int devmask = 0;\n\tint rc;\n\tu8 err;\n\n\t \n\tif (pata_parport_devchk(ap, 0))\n\t\tdevmask |= (1 << 0);\n\tif (pata_parport_devchk(ap, 1))\n\t\tdevmask |= (1 << 1);\n\n\t \n\tpata_parport_dev_select(ap, 0);\n\n\t \n\trc = pata_parport_bus_softreset(ap, devmask, deadline);\n\tif (rc && rc != -ENODEV) {\n\t\tata_link_err(link, \"SRST failed (errno=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tclasses[0] = ata_sff_dev_classify(&link->device[0],\n\t\t\t\t\t  devmask & (1 << 0), &err);\n\tif (err != 0x81)\n\t\tclasses[1] = ata_sff_dev_classify(&link->device[1],\n\t\t\t\t\t\t  devmask & (1 << 1), &err);\n\n\treturn 0;\n}\n\nstatic u8 pata_parport_check_status(struct ata_port *ap)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\treturn pi->proto->read_regr(pi, 0, ATA_REG_STATUS);\n}\n\nstatic u8 pata_parport_check_altstatus(struct ata_port *ap)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\treturn pi->proto->read_regr(pi, 1, 6);\n}\n\nstatic void pata_parport_tf_load(struct ata_port *ap,\n\t\t\t\t const struct ata_taskfile *tf)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\tif (tf->ctl != ap->last_ctl) {\n\t\tpi->proto->write_regr(pi, 1, 6, tf->ctl);\n\t\tap->last_ctl = tf->ctl;\n\t\tata_wait_idle(ap);\n\t}\n\n\tif (tf->flags & ATA_TFLAG_ISADDR) {\n\t\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\t\tpi->proto->write_regr(pi, 0, ATA_REG_FEATURE,\n\t\t\t\t\t      tf->hob_feature);\n\t\t\tpi->proto->write_regr(pi, 0, ATA_REG_NSECT,\n\t\t\t\t\t      tf->hob_nsect);\n\t\t\tpi->proto->write_regr(pi, 0, ATA_REG_LBAL,\n\t\t\t\t\t      tf->hob_lbal);\n\t\t\tpi->proto->write_regr(pi, 0, ATA_REG_LBAM,\n\t\t\t\t\t      tf->hob_lbam);\n\t\t\tpi->proto->write_regr(pi, 0, ATA_REG_LBAH,\n\t\t\t\t\t      tf->hob_lbah);\n\t\t}\n\t\tpi->proto->write_regr(pi, 0, ATA_REG_FEATURE, tf->feature);\n\t\tpi->proto->write_regr(pi, 0, ATA_REG_NSECT, tf->nsect);\n\t\tpi->proto->write_regr(pi, 0, ATA_REG_LBAL, tf->lbal);\n\t\tpi->proto->write_regr(pi, 0, ATA_REG_LBAM, tf->lbam);\n\t\tpi->proto->write_regr(pi, 0, ATA_REG_LBAH, tf->lbah);\n\t}\n\n\tif (tf->flags & ATA_TFLAG_DEVICE)\n\t\tpi->proto->write_regr(pi, 0, ATA_REG_DEVICE, tf->device);\n\n\tata_wait_idle(ap);\n}\n\nstatic void pata_parport_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\ttf->status = pi->proto->read_regr(pi, 0, ATA_REG_STATUS);\n\ttf->error = pi->proto->read_regr(pi, 0, ATA_REG_ERR);\n\ttf->nsect = pi->proto->read_regr(pi, 0, ATA_REG_NSECT);\n\ttf->lbal = pi->proto->read_regr(pi, 0, ATA_REG_LBAL);\n\ttf->lbam = pi->proto->read_regr(pi, 0, ATA_REG_LBAM);\n\ttf->lbah = pi->proto->read_regr(pi, 0, ATA_REG_LBAH);\n\ttf->device = pi->proto->read_regr(pi, 0, ATA_REG_DEVICE);\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\tpi->proto->write_regr(pi, 1, 6, tf->ctl | ATA_HOB);\n\t\ttf->hob_feature = pi->proto->read_regr(pi, 0, ATA_REG_ERR);\n\t\ttf->hob_nsect = pi->proto->read_regr(pi, 0, ATA_REG_NSECT);\n\t\ttf->hob_lbal = pi->proto->read_regr(pi, 0, ATA_REG_LBAL);\n\t\ttf->hob_lbam = pi->proto->read_regr(pi, 0, ATA_REG_LBAM);\n\t\ttf->hob_lbah = pi->proto->read_regr(pi, 0, ATA_REG_LBAH);\n\t\tpi->proto->write_regr(pi, 1, 6, tf->ctl);\n\t\tap->last_ctl = tf->ctl;\n\t}\n}\n\nstatic void pata_parport_exec_command(struct ata_port *ap,\n\t\t\t\t      const struct ata_taskfile *tf)\n{\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\tpi->proto->write_regr(pi, 0, ATA_REG_CMD, tf->command);\n\tata_sff_pause(ap);\n}\n\nstatic unsigned int pata_parport_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\tunsigned char *buf, unsigned int buflen, int rw)\n{\n\tstruct ata_port *ap = qc->dev->link->ap;\n\tstruct pi_adapter *pi = ap->host->private_data;\n\n\tif (rw == READ)\n\t\tpi->proto->read_block(pi, buf, buflen);\n\telse\n\t\tpi->proto->write_block(pi, buf, buflen);\n\n\treturn buflen;\n}\n\nstatic void pata_parport_drain_fifo(struct ata_queued_cmd *qc)\n{\n\tint count;\n\tstruct ata_port *ap;\n\tstruct pi_adapter *pi;\n\tchar junk[2];\n\n\t \n\tif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\n\t\treturn;\n\n\tap = qc->ap;\n\tpi = ap->host->private_data;\n\t \n\tfor (count = 0; (pata_parport_check_status(ap) & ATA_DRQ)\n\t\t\t\t\t\t&& count < 65536; count += 2) {\n\t\tpi->proto->read_block(pi, junk, 2);\n\t}\n\n\tif (count)\n\t\tata_port_dbg(ap, \"drained %d bytes to clear DRQ\\n\", count);\n}\n\nstatic struct ata_port_operations pata_parport_port_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\n\t.softreset\t\t= pata_parport_softreset,\n\t.hardreset\t\t= NULL,\n\n\t.sff_dev_select\t\t= pata_parport_dev_select,\n\t.sff_set_devctl\t\t= pata_parport_set_devctl,\n\t.sff_check_status\t= pata_parport_check_status,\n\t.sff_check_altstatus\t= pata_parport_check_altstatus,\n\t.sff_tf_load\t\t= pata_parport_tf_load,\n\t.sff_tf_read\t\t= pata_parport_tf_read,\n\t.sff_exec_command\t= pata_parport_exec_command,\n\t.sff_data_xfer\t\t= pata_parport_data_xfer,\n\t.sff_drain_fifo\t\t= pata_parport_drain_fifo,\n};\n\nstatic const struct ata_port_info pata_parport_port_info = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_POLLING,\n\t.pio_mask\t= ATA_PIO0,\n\t \n\t.port_ops\t= &pata_parport_port_ops,\n};\n\nstatic void pi_release(struct pi_adapter *pi)\n{\n\tparport_unregister_device(pi->pardev);\n\tif (pi->proto->release_proto)\n\t\tpi->proto->release_proto(pi);\n\tmodule_put(pi->proto->owner);\n}\n\nstatic int default_test_proto(struct pi_adapter *pi)\n{\n\tint j, k;\n\tint e[2] = { 0, 0 };\n\n\tpi->proto->connect(pi);\n\n\tfor (j = 0; j < 2; j++) {\n\t\tpi->proto->write_regr(pi, 0, 6, 0xa0 + j * 0x10);\n\t\tfor (k = 0; k < 256; k++) {\n\t\t\tpi->proto->write_regr(pi, 0, 2, k ^ 0xaa);\n\t\t\tpi->proto->write_regr(pi, 0, 3, k ^ 0x55);\n\t\t\tif (pi->proto->read_regr(pi, 0, 2) != (k ^ 0xaa))\n\t\t\t\te[j]++;\n\t\t}\n\t}\n\tpi->proto->disconnect(pi);\n\n\tdev_dbg(&pi->dev, \"%s: port 0x%x, mode %d, test=(%d,%d)\\n\",\n\t\tpi->proto->name, pi->port, pi->mode, e[0], e[1]);\n\n\treturn e[0] && e[1];\t \n}\n\nstatic int pi_test_proto(struct pi_adapter *pi)\n{\n\tint res;\n\n\tparport_claim_or_block(pi->pardev);\n\tif (pi->proto->test_proto)\n\t\tres = pi->proto->test_proto(pi);\n\telse\n\t\tres = default_test_proto(pi);\n\tparport_release(pi->pardev);\n\n\treturn res;\n}\n\nstatic bool pi_probe_mode(struct pi_adapter *pi, int max)\n{\n\tint best, range;\n\n\tif (pi->mode != -1) {\n\t\tif (pi->mode >= max)\n\t\t\treturn false;\n\t\trange = 3;\n\t\tif (pi->mode >= pi->proto->epp_first)\n\t\t\trange = 8;\n\t\tif (range == 8 && pi->port % 8)\n\t\t\treturn false;\n\t\treturn !pi_test_proto(pi);\n\t}\n\tbest = -1;\n\tfor (pi->mode = 0; pi->mode < max; pi->mode++) {\n\t\trange = 3;\n\t\tif (pi->mode >= pi->proto->epp_first)\n\t\t\trange = 8;\n\t\tif (range == 8 && pi->port % 8)\n\t\t\tbreak;\n\t\tif (!pi_test_proto(pi))\n\t\t\tbest = pi->mode;\n\t}\n\tpi->mode = best;\n\treturn best > -1;\n}\n\nstatic bool pi_probe_unit(struct pi_adapter *pi, int unit)\n{\n\tint max, s, e;\n\n\ts = unit;\n\te = s + 1;\n\n\tif (s == -1) {\n\t\ts = 0;\n\t\te = pi->proto->max_units;\n\t}\n\n\tif (pi->proto->test_port) {\n\t\tparport_claim_or_block(pi->pardev);\n\t\tmax = pi->proto->test_port(pi);\n\t\tparport_release(pi->pardev);\n\t} else {\n\t\tmax = pi->proto->max_mode;\n\t}\n\n\tif (pi->proto->probe_unit) {\n\t\tparport_claim_or_block(pi->pardev);\n\t\tfor (pi->unit = s; pi->unit < e; pi->unit++) {\n\t\t\tif (pi->proto->probe_unit(pi)) {\n\t\t\t\tparport_release(pi->pardev);\n\t\t\t\treturn pi_probe_mode(pi, max);\n\t\t\t}\n\t\t}\n\t\tparport_release(pi->pardev);\n\t\treturn false;\n\t}\n\n\treturn pi_probe_mode(pi, max);\n}\n\nstatic void pata_parport_dev_release(struct device *dev)\n{\n\tstruct pi_adapter *pi = container_of(dev, struct pi_adapter, dev);\n\n\tida_free(&pata_parport_bus_dev_ids, dev->id);\n\tkfree(pi);\n}\n\nstatic void pata_parport_bus_release(struct device *dev)\n{\n\t \n}\n\nstatic struct bus_type pata_parport_bus_type = {\n\t.name = DRV_NAME,\n};\n\nstatic struct device pata_parport_bus = {\n\t.init_name = DRV_NAME,\n\t.release = pata_parport_bus_release,\n};\n\nstatic const struct scsi_host_template pata_parport_sht = {\n\tPATA_PARPORT_SHT(\"pata_parport\")\n};\n\nstruct pi_device_match {\n\tstruct parport *parport;\n\tstruct pi_protocol *proto;\n};\n\nstatic int pi_find_dev(struct device *dev, void *data)\n{\n\tstruct pi_adapter *pi = container_of(dev, struct pi_adapter, dev);\n\tstruct pi_device_match *match = data;\n\n\treturn pi->pardev->port == match->parport && pi->proto == match->proto;\n}\n\nstatic struct pi_adapter *pi_init_one(struct parport *parport,\n\t\t\tstruct pi_protocol *pr, int mode, int unit, int delay)\n{\n\tstruct pardev_cb par_cb = { };\n\tconst struct ata_port_info *ppi[] = { &pata_parport_port_info };\n\tstruct ata_host *host;\n\tstruct pi_adapter *pi;\n\tstruct pi_device_match match = { .parport = parport, .proto = pr };\n\tint id;\n\n\t \n\tif (bus_for_each_dev(&pata_parport_bus_type, NULL, &match, pi_find_dev))\n\t\treturn NULL;\n\n\tid = ida_alloc(&pata_parport_bus_dev_ids, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn NULL;\n\n\tpi = kzalloc(sizeof(struct pi_adapter), GFP_KERNEL);\n\tif (!pi) {\n\t\tida_free(&pata_parport_bus_dev_ids, id);\n\t\treturn NULL;\n\t}\n\n\t \n\tpi->dev.parent = &pata_parport_bus;\n\tpi->dev.bus = &pata_parport_bus_type;\n\tpi->dev.driver = &pr->driver;\n\tpi->dev.release = pata_parport_dev_release;\n\tpi->dev.id = id;\n\tdev_set_name(&pi->dev, \"pata_parport.%u\", pi->dev.id);\n\tif (device_register(&pi->dev)) {\n\t\tput_device(&pi->dev);\n\t\t \n\t\treturn NULL;\n\t}\n\n\tpi->proto = pr;\n\n\tif (!try_module_get(pi->proto->owner))\n\t\tgoto out_unreg_dev;\n\tif (pi->proto->init_proto && pi->proto->init_proto(pi) < 0)\n\t\tgoto out_module_put;\n\n\tpi->delay = (delay == -1) ? pi->proto->default_delay : delay;\n\tpi->mode = mode;\n\tpi->port = parport->base;\n\n\tpar_cb.private = pi;\n\tpi->pardev = parport_register_dev_model(parport, DRV_NAME, &par_cb, id);\n\tif (!pi->pardev)\n\t\tgoto out_module_put;\n\n\tif (!pi_probe_unit(pi, unit)) {\n\t\tdev_info(&pi->dev, \"Adapter not found\\n\");\n\t\tgoto out_unreg_parport;\n\t}\n\n\tpi->proto->log_adapter(pi);\n\n\thost = ata_host_alloc_pinfo(&pi->pardev->dev, ppi, 1);\n\tif (!host)\n\t\tgoto out_unreg_parport;\n\tdev_set_drvdata(&pi->dev, host);\n\thost->private_data = pi;\n\n\tata_port_desc(host->ports[0], \"port %s\", pi->pardev->port->name);\n\tata_port_desc(host->ports[0], \"protocol %s\", pi->proto->name);\n\n\tpi_connect(pi);\n\tif (ata_host_activate(host, 0, NULL, 0, &pata_parport_sht))\n\t\tgoto out_disconnect;\n\n\treturn pi;\n\nout_disconnect:\n\tpi_disconnect(pi);\nout_unreg_parport:\n\tparport_unregister_device(pi->pardev);\n\tif (pi->proto->release_proto)\n\t\tpi->proto->release_proto(pi);\nout_module_put:\n\tmodule_put(pi->proto->owner);\nout_unreg_dev:\n\tdevice_unregister(&pi->dev);\n\t \n\treturn NULL;\n}\n\nint pata_parport_register_driver(struct pi_protocol *pr)\n{\n\tint error;\n\tstruct parport *parport;\n\tint port_num;\n\n\tpr->driver.bus = &pata_parport_bus_type;\n\tpr->driver.name = pr->name;\n\terror = driver_register(&pr->driver);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&pi_mutex);\n\terror = idr_alloc(&protocols, pr, 0, 0, GFP_KERNEL);\n\tif (error < 0) {\n\t\tdriver_unregister(&pr->driver);\n\t\tmutex_unlock(&pi_mutex);\n\t\treturn error;\n\t}\n\n\tpr_info(\"pata_parport: protocol %s registered\\n\", pr->name);\n\n\tif (probe) {\n\t\t \n\t\tidr_for_each_entry(&parport_list, parport, port_num)\n\t\t\tpi_init_one(parport, pr, -1, -1, -1);\n\t}\n\tmutex_unlock(&pi_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pata_parport_register_driver);\n\nvoid pata_parport_unregister_driver(struct pi_protocol *pr)\n{\n\tstruct pi_protocol *pr_iter;\n\tint id = -1;\n\n\tmutex_lock(&pi_mutex);\n\tidr_for_each_entry(&protocols, pr_iter, id) {\n\t\tif (pr_iter == pr)\n\t\t\tbreak;\n\t}\n\tidr_remove(&protocols, id);\n\tmutex_unlock(&pi_mutex);\n\tdriver_unregister(&pr->driver);\n}\nEXPORT_SYMBOL_GPL(pata_parport_unregister_driver);\n\nstatic ssize_t new_device_store(const struct bus_type *bus, const char *buf, size_t count)\n{\n\tchar port[12] = \"auto\";\n\tchar protocol[8] = \"auto\";\n\tint mode = -1, unit = -1, delay = -1;\n\tstruct pi_protocol *pr, *pr_wanted;\n\tstruct device_driver *drv;\n\tstruct parport *parport;\n\tint port_num, port_wanted, pr_num;\n\tbool ok = false;\n\n\tif (sscanf(buf, \"%11s %7s %d %d %d\",\n\t\t\tport, protocol, &mode, &unit, &delay) < 1)\n\t\treturn -EINVAL;\n\n\tif (sscanf(port, \"parport%u\", &port_wanted) < 1) {\n\t\tif (strcmp(port, \"auto\")) {\n\t\t\tpr_err(\"invalid port name %s\\n\", port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_wanted = -1;\n\t}\n\n\tdrv = driver_find(protocol, &pata_parport_bus_type);\n\tif (!drv) {\n\t\tif (strcmp(protocol, \"auto\")) {\n\t\t\tpr_err(\"protocol %s not found\\n\", protocol);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpr_wanted = NULL;\n\t} else {\n\t\tpr_wanted = container_of(drv, struct pi_protocol, driver);\n\t}\n\n\tmutex_lock(&pi_mutex);\n\t \n\tidr_for_each_entry(&parport_list, parport, port_num) {\n\t\tif (port_num == port_wanted || port_wanted == -1) {\n\t\t\tparport = parport_find_number(port_num);\n\t\t\tif (!parport) {\n\t\t\t\tpr_err(\"no such port %s\\n\", port);\n\t\t\t\tmutex_unlock(&pi_mutex);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\t \n\t\t\tidr_for_each_entry(&protocols, pr, pr_num) {\n\t\t\t\tif (pr == pr_wanted || !pr_wanted)\n\t\t\t\t\tif (pi_init_one(parport, pr, mode, unit,\n\t\t\t\t\t\t\tdelay))\n\t\t\t\t\t\tok = true;\n\t\t\t}\n\t\t\tparport_put_port(parport);\n\t\t}\n\t}\n\tmutex_unlock(&pi_mutex);\n\tif (!ok)\n\t\treturn -ENODEV;\n\n\treturn count;\n}\nstatic BUS_ATTR_WO(new_device);\n\nstatic void pi_remove_one(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct pi_adapter *pi = host->private_data;\n\n\tata_host_detach(host);\n\tpi_disconnect(pi);\n\tpi_release(pi);\n\tdevice_unregister(dev);\n\t \n}\n\nstatic ssize_t delete_device_store(const struct bus_type *bus, const char *buf, size_t count)\n{\n\tstruct device *dev;\n\n\tmutex_lock(&pi_mutex);\n\tdev = bus_find_device_by_name(bus, NULL, buf);\n\tif (!dev) {\n\t\tmutex_unlock(&pi_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tpi_remove_one(dev);\n\tput_device(dev);\n\tmutex_unlock(&pi_mutex);\n\n\treturn count;\n}\nstatic BUS_ATTR_WO(delete_device);\n\nstatic void pata_parport_attach(struct parport *port)\n{\n\tstruct pi_protocol *pr;\n\tint pr_num, id;\n\n\tmutex_lock(&pi_mutex);\n\tid = idr_alloc(&parport_list, port, port->number, port->number,\n\t\t       GFP_KERNEL);\n\tif (id < 0) {\n\t\tmutex_unlock(&pi_mutex);\n\t\treturn;\n\t}\n\n\tif (probe) {\n\t\t \n\t\tidr_for_each_entry(&protocols, pr, pr_num)\n\t\t\tpi_init_one(port, pr, -1, -1, -1);\n\t}\n\tmutex_unlock(&pi_mutex);\n}\n\nstatic int pi_remove_port(struct device *dev, void *p)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct pi_adapter *pi = host->private_data;\n\n\tif (pi->pardev->port == p)\n\t\tpi_remove_one(dev);\n\n\treturn 0;\n}\n\nstatic void pata_parport_detach(struct parport *port)\n{\n\tmutex_lock(&pi_mutex);\n\tbus_for_each_dev(&pata_parport_bus_type, NULL, port, pi_remove_port);\n\tidr_remove(&parport_list, port->number);\n\tmutex_unlock(&pi_mutex);\n}\n\nstatic struct parport_driver pata_parport_driver = {\n\t.name = DRV_NAME,\n\t.match_port = pata_parport_attach,\n\t.detach = pata_parport_detach,\n\t.devmodel = true,\n};\n\nstatic __init int pata_parport_init(void)\n{\n\tint error;\n\n\terror = bus_register(&pata_parport_bus_type);\n\tif (error) {\n\t\tpr_err(\"failed to register pata_parport bus, error: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = device_register(&pata_parport_bus);\n\tif (error) {\n\t\tpr_err(\"failed to register pata_parport bus, error: %d\\n\", error);\n\t\tgoto out_unregister_bus;\n\t}\n\n\terror = bus_create_file(&pata_parport_bus_type, &bus_attr_new_device);\n\tif (error) {\n\t\tpr_err(\"unable to create sysfs file, error: %d\\n\", error);\n\t\tgoto out_unregister_dev;\n\t}\n\n\terror = bus_create_file(&pata_parport_bus_type, &bus_attr_delete_device);\n\tif (error) {\n\t\tpr_err(\"unable to create sysfs file, error: %d\\n\", error);\n\t\tgoto out_remove_new;\n\t}\n\n\terror = parport_register_driver(&pata_parport_driver);\n\tif (error) {\n\t\tpr_err(\"unable to register parport driver, error: %d\\n\", error);\n\t\tgoto out_remove_del;\n\t}\n\n\treturn 0;\n\nout_remove_del:\n\tbus_remove_file(&pata_parport_bus_type, &bus_attr_delete_device);\nout_remove_new:\n\tbus_remove_file(&pata_parport_bus_type, &bus_attr_new_device);\nout_unregister_dev:\n\tdevice_unregister(&pata_parport_bus);\nout_unregister_bus:\n\tbus_unregister(&pata_parport_bus_type);\n\treturn error;\n}\n\nstatic __exit void pata_parport_exit(void)\n{\n\tparport_unregister_driver(&pata_parport_driver);\n\tbus_remove_file(&pata_parport_bus_type, &bus_attr_new_device);\n\tbus_remove_file(&pata_parport_bus_type, &bus_attr_delete_device);\n\tdevice_unregister(&pata_parport_bus);\n\tbus_unregister(&pata_parport_bus_type);\n}\n\nMODULE_AUTHOR(\"Ondrej Zary\");\nMODULE_DESCRIPTION(\"driver for parallel port ATA adapters\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"paride\");\n\nmodule_init(pata_parport_init);\nmodule_exit(pata_parport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}