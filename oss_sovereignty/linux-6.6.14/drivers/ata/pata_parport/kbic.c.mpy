{
  "module_name": "kbic.c",
  "hash_id": "6f1dc8c31d0aa8570d5dc4d2be9cc5555e1530c15cef2b50da7b70cf198cb5da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/kbic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n#define r12w()\t\t(delay_p, inw(pi->port + 1) & 0xffff)\n\n#define j44(a, b)\t((((a >> 4) & 0x0f) | (b & 0xf0)) ^ 0x88)\n#define j53(w)\t\t(((w >> 3) & 0x1f) | ((w >> 4) & 0xe0))\n\n\n \nstatic int cont_map[2] = { 0x80, 0x40 };\n\nstatic int kbic_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint a, b, s;\n\n\ts = cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(regr | 0x18 | s); w2(4); w2(6); w2(4); w2(1); w0(8);\n\t\ta = r1(); w0(0x28); b = r1(); w2(4);\n\t\treturn j44(a, b);\n\tcase 1:\n\t\tw0(regr|0x38 | s); w2(4); w2(6); w2(4); w2(5); w0(8);\n\t\ta = r12w(); w2(4);\n\t\treturn j53(a);\n\tcase 2:\n\t\tw0(regr | 0x08 | s); w2(4); w2(6); w2(4); w2(0xa5); w2(0xa1);\n\t\ta = r0(); w2(4);\n\t\treturn a;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tw0(0x20 | s); w2(4); w2(6); w2(4); w3(regr);\n\t\ta = r4(); b = r4(); w2(4); w2(0); w2(4);\n\t\treturn a;\n\t}\n\n\treturn -1;\n}\n\nstatic void kbic_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint s = cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tw0(regr | 0x10 | s); w2(4); w2(6); w2(4);\n\t\tw0(val); w2(5); w2(4);\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tw0(0x20 | s); w2(4); w2(6); w2(4); w3(regr);\n\t\tw4(val); w4(val);\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\t}\n}\n\nstatic void k951_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\tw2(4);\n}\n\nstatic void k951_disconnect(struct pi_adapter *pi)\n{\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\n#define\tCCP(x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tw2(0xc4); w0(0xaa); w0(0x55);\t\t\\\n\t\tw0(0); w0(0xff); w0(0x87);\t\t\\\n\t\tw0(0x78); w0(x); w2(0xc5);\t\t\\\n\t\tw2(0xc4); w0(0xff);\t\t\t\\\n\t} while (0)\n\nstatic void k971_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\tCCP(0x20);\n\tw2(4);\n}\n\nstatic void k971_disconnect(struct pi_adapter *pi)\n{\n\tCCP(0x30);\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\n \nstatic void kbic_read_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint k, a, b;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(0x98); w2(4); w2(6); w2(4);\n\t\tfor (k = 0; k < count / 2; k++) {\n\t\t\tw2(1); w0(8);\n\t\t\ta = r1();\n\t\t\tw0(0x28);\n\t\t\tb = r1();\n\t\t\tbuf[2 * k] = j44(a, b);\n\t\t\tw2(5);\n\t\t\tb = r1();\n\t\t\tw0(8);\n\t\t\ta = r1();\n\t\t\tbuf[2 * k + 1] = j44(a, b);\n\t\t\tw2(4);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tw0(0xb8); w2(4); w2(6); w2(4);\n\t\tfor (k = 0; k < count / 4; k++) {\n\t\t\tw0(0xb8);\n\t\t\tw2(4); w2(5);\n\t\t\tw0(8);\n\t\t\tbuf[4 * k] = j53(r12w());\n\t\t\tw0(0xb8);\n\t\t\tbuf[4 * k + 1] = j53(r12w());\n\t\t\tw2(4); w2(5);\n\t\t\tbuf[4 * k + 3] = j53(r12w());\n\t\t\tw0(8);\n\t\t\tbuf[4 * k + 2] = j53(r12w());\n\t\t}\n\t\tw2(4);\n\t\tbreak;\n\tcase 2:\n\t\tw0(0x88); w2(4); w2(6); w2(4);\n\t\tfor (k = 0; k < count / 2; k++) {\n\t\t\tw2(0xa0); w2(0xa1);\n\t\t\tbuf[2 * k] = r0();\n\t\t\tw2(0xa5);\n\t\t\tbuf[2 * k + 1] = r0();\n\t\t}\n\t\tw2(4);\n\t\tbreak;\n\tcase 3:\n\t\tw0(0xa0); w2(4); w2(6); w2(4); w3(0);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\tcase 4:\n\t\tw0(0xa0); w2(4); w2(6); w2(4); w3(0);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\t((u16 *)buf)[k] = r4w();\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\tcase 5:\n\t\tw0(0xa0); w2(4); w2(6); w2(4); w3(0);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\t((u32 *)buf)[k] = r4l();\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\t}\n}\n\nstatic void kbic_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint k;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tw0(0x90); w2(4); w2(6); w2(4);\n\t\tfor (k = 0; k < count / 2; k++) {\n\t\t\tw0(buf[2 * k + 1]);\n\t\t\tw2(0); w2(4);\n\t\t\tw0(buf[2 * k]);\n\t\t\tw2(5); w2(4);\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tw0(0xa0); w2(4); w2(6); w2(4); w3(0);\n\t\tfor (k = 0; k < count / 2; k++) {\n\t\t\tw4(buf[2 * k + 1]);\n\t\t\tw4(buf[2 * k]);\n\t\t}\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\tcase 4:\n\t\tw0(0xa0); w2(4); w2(6); w2(4); w3(0);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\tw4w(swab16(((u16 *)buf)[k]));\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\tcase 5:\n\t\tw0(0xa0); w2(4); w2(6); w2(4); w3(0);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\tw4l(swab16(((u16 *)buf)[2 * k]) |\n\t\t\t    swab16(((u16 *)buf)[2 * k + 1]) << 16);\n\t\tw2(4); w2(0); w2(4);\n\t\tbreak;\n\t}\n}\n\nstatic void kbic_log_adapter(struct pi_adapter *pi, char *chip)\n{\n\tchar *mode[6] = { \"4-bit\", \"5/3\", \"8-bit\", \"EPP-8\", \"EPP_16\", \"EPP-32\"};\n\n\tdev_info(&pi->dev, \"KingByte %s at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t chip, pi->port, pi->mode, mode[pi->mode], pi->delay);\n}\n\nstatic void k951_log_adapter(struct pi_adapter *pi)\n{\n\tkbic_log_adapter(pi, \"KBIC-951A\");\n}\n\nstatic void k971_log_adapter(struct pi_adapter *pi)\n{\n\tkbic_log_adapter(pi, \"KBIC-971A\");\n}\n\nstatic struct pi_protocol k951 = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"k951\",\n\t.max_mode\t= 6,\n\t.epp_first\t= 3,\n\t.default_delay\t= 1,\n\t.max_units\t= 1,\n\t.write_regr\t= kbic_write_regr,\n\t.read_regr\t= kbic_read_regr,\n\t.write_block\t= kbic_write_block,\n\t.read_block\t= kbic_read_block,\n\t.connect\t= k951_connect,\n\t.disconnect\t= k951_disconnect,\n\t.log_adapter\t= k951_log_adapter,\n};\n\nstatic struct pi_protocol k971 = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"k971\",\n\t.max_mode\t= 6,\n\t.epp_first\t= 3,\n\t.default_delay\t= 1,\n\t.max_units\t= 1,\n\t.write_regr\t= kbic_write_regr,\n\t.read_regr\t= kbic_read_regr,\n\t.write_block\t= kbic_write_block,\n\t.read_block\t= kbic_read_block,\n\t.connect\t= k971_connect,\n\t.disconnect\t= k971_disconnect,\n\t.log_adapter\t= k971_log_adapter,\n};\n\nstatic int __init kbic_init(void)\n{\n\tint rv;\n\n\trv = pata_parport_register_driver(&k951);\n\tif (rv < 0)\n\t\treturn rv;\n\trv = pata_parport_register_driver(&k971);\n\tif (rv < 0)\n\t\tpata_parport_unregister_driver(&k951);\n\treturn rv;\n}\n\nstatic void __exit kbic_exit(void)\n{\n\tpata_parport_unregister_driver(&k951);\n\tpata_parport_unregister_driver(&k971);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"KingByte Information Systems KBIC-951A and KBIC-971A \"\n\t\t   \"parallel port IDE adapter protocol driver\");\nmodule_init(kbic_init)\nmodule_exit(kbic_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}