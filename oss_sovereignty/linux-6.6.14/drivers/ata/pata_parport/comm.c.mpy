{
  "module_name": "comm.c",
  "hash_id": "b46d5b9d4787941f12ce2a5114347c5741eba296863056bacbffd7d1bcccc7bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/comm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n \n\n#define j44(a, b)\t(((a >> 3) & 0x0f) | ((b << 1) & 0xf0))\n\n#define P1\tw2(5);w2(0xd);w2(0xd);w2(5);w2(4);\n#define P2\tw2(5);w2(7);w2(7);w2(5);w2(4);\n\n \nstatic int  cont_map[2] = { 0x08, 0x10 };\n\nstatic int comm_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint l, h, r;\n\n\tr = regr + cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(r); P1; w0(0);\n\t\tw2(6); l = r1(); w0(0x80); h = r1(); w2(4);\n\t\treturn j44(l, h);\n\n\tcase 1:\n\t\tw0(r+0x20); P1;\n\t\tw0(0); w2(0x26); h = r0(); w2(4);\n\t\treturn h;\n\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tw3(r+0x20); (void)r1();\n\t\tw2(0x24); h = r4(); w2(4);\n\t\treturn h;\n\t}\n\n\treturn -1;\n}\n\nstatic void comm_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint r = regr + cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\t\tw0(r); P1; w0(val); P2;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tw3(r); (void)r1(); w4(val);\n\t\tbreak;\n\t}\n}\n\nstatic void comm_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\tw2(4); w0(0xff); w2(6);\n\tw2(4); w0(0xaa); w2(6);\n\tw2(4); w0(0x00); w2(6);\n\tw2(4); w0(0x87); w2(6);\n\tw2(4); w0(0xe0); w2(0xc); w2(0xc); w2(4);\n}\n\nstatic void comm_disconnect(struct pi_adapter *pi)\n{\n\tw2(0); w2(0); w2(0); w2(4);\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\nstatic void comm_read_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint i, l, h;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(0x48); P1;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tw0(0); w2(6); l = r1();\n\t\t\tw0(0x80); h = r1(); w2(4);\n\t\t\tbuf[i] = j44(l, h);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tw0(0x68); P1; w0(0);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tw2(0x26);\n\t\t\tbuf[i] = r0();\n\t\t\tw2(0x24);\n\t\t}\n\t\tw2(4);\n\t\tbreak;\n\tcase 2:\n\t\tw3(0x68); (void)r1(); w2(0x24);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tbuf[i] = r4();\n\t\tw2(4);\n\t\tbreak;\n\tcase 3:\n\t\tw3(0x68); (void)r1(); w2(0x24);\n\t\tfor (i = 0; i < count / 2; i++)\n\t\t\t((u16 *)buf)[i] = r4w();\n\t\tw2(4);\n\t\tbreak;\n\tcase 4:\n\t\tw3(0x68); (void)r1(); w2(0x24);\n\t\tfor (i = 0; i < count / 4; i++)\n\t\t\t((u32 *)buf)[i] = r4l();\n\t\tw2(4);\n\t\tbreak;\n\t}\n}\n\n \nstatic void comm_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint k;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\t\tw0(0x68); P1;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(5);\n\t\t\tw0(buf[k ^ 1]);\n\t\t\tw2(7);\n\t\t}\n\t\tw2(5); w2(4);\n\t\tbreak;\n\tcase 2:\n\t\tw3(0x48); (void)r1();\n\t\tfor (k = 0; k < count; k++)\n\t\t\tw4(buf[k ^ 1]);\n\t\tbreak;\n\tcase 3:\n\t\tw3(0x48); (void)r1();\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\tw4w(swab16(((u16 *)buf)[k]));\n\t\tbreak;\n\tcase 4:\n\t\tw3(0x48); (void)r1();\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\tw4l(swab16(((u16 *)buf)[2 * k]) |\n\t\t\t    swab16(((u16 *)buf)[2 * k + 1]) << 16);\n\t\tbreak;\n\t}\n}\n\nstatic void comm_log_adapter(struct pi_adapter *pi)\n{\n\tchar *mode_string[5] = { \"4-bit\", \"8-bit\", \"EPP-8\", \"EPP-16\", \"EPP-32\" };\n\n\tdev_info(&pi->dev,\n\t\t \"DataStor Commuter at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t pi->port, pi->mode, mode_string[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol comm = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"comm\",\n\t.max_mode\t= 5,\n\t.epp_first\t= 2,\n\t.default_delay\t= 1,\n\t.max_units\t= 1,\n\t.write_regr\t= comm_write_regr,\n\t.read_regr\t= comm_read_regr,\n\t.write_block\t= comm_write_block,\n\t.read_block\t= comm_read_block,\n\t.connect\t= comm_connect,\n\t.disconnect\t= comm_disconnect,\n\t.log_adapter\t= comm_log_adapter,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"DataStor Commuter parallel port IDE adapter protocol driver\");\nmodule_pata_parport_driver(comm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}