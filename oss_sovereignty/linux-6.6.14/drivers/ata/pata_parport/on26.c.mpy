{
  "module_name": "on26.c",
  "hash_id": "06491bcbcfc9e3287cca45dd4754e44ff98a6cdadd5a893957661cd94a219cb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/on26.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n \n\n#define j44(a, b)\t(((a >> 4) & 0x0f) | (b & 0xf0))\n\n#define P1\t\t\t\t\t\t      \\\n\tdo {\t\t\t\t\t\t      \\\n\t\tw2(5); w2(0xd); w2(5); w2(0xd); w2(5); w2(4); \\\n\t} while (0)\n\n#define P2\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tw2(5); w2(7); w2(5); w2(4);\t\\\n\t} while (0)\n\n \n\nstatic int on26_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint a, b, r;\n\n\tr = (regr << 2) + 1 + cont;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(1); P1; w0(r); P2; w0(0); P1;\n\t\tw2(6); a = r1(); w2(4);\n\t\tw2(6); b = r1(); w2(4);\n\t\tw2(6); w2(4); w2(6); w2(4);\n\t\treturn j44(a, b);\n\tcase 1:\n\t\tw0(1); P1; w0(r); P2; w0(0); P1;\n\t\tw2(0x26); a = r0(); w2(4); w2(0x26); w2(4);\n\t\treturn a;\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tw3(1); w3(1); w2(5); w4(r); w2(4);\n\t\tw3(0); w3(0); w2(0x24); a = r4(); w2(4);\n\t\tw2(0x24); (void)r4(); w2(4);\n\t\treturn a;\n\t}\n\n\treturn -1;\n}\n\nstatic void on26_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint r = (regr << 2) + 1 + cont;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\t\tw0(1); P1; w0(r); P2; w0(0); P1;\n\t\tw0(val); P2; w0(val); P2;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tw3(1); w3(1); w2(5); w4(r); w2(4);\n\t\tw3(0); w3(0);\n\t\tw2(5); w4(val); w2(4);\n\t\tw2(5); w4(val); w2(4);\n\t\tbreak;\n\t}\n}\n\n#define CCP(x)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tw0(0xfe); w0(0xaa); w0(0x55); w0(0);\t\\\n\t\tw0(0xff); w0(0x87); w0(0x78); w0(x);\t\\\n\t\tw2(4); w2(5); w2(4); w0(0xff);\t\t\\\n\t} while (0)\n\nstatic void on26_connect(struct pi_adapter *pi)\n{\n\tint x;\n\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\n\tCCP(0x20);\n\tif (pi->mode)\n\t\tx = 9;\n\telse\n\t\tx = 8;\n\n\tw0(2); P1; w0(8); P2;\n\tw0(2); P1; w0(x); P2;\n}\n\nstatic void on26_disconnect(struct pi_adapter *pi)\n{\n\tif (pi->mode >= 2) {\n\t\tw3(4); w3(4); w3(4); w3(4);\n\t} else {\n\t\tw0(4); P1; w0(4); P1;\n\t}\n\tCCP(0x30);\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\n#define\tRESET_WAIT  200\n\n \nstatic int on26_test_port(struct pi_adapter *pi)\n{\n\tint i, m, d, x = 0, y = 0;\n\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\n\td = pi->delay;\n\tm = pi->mode;\n\tpi->delay = 5;\n\tpi->mode = 0;\n\n\tw2(0xc);\n\n\tCCP(0x30); CCP(0);\n\n\tw0(0xfe); w0(0xaa); w0(0x55); w0(0); w0(0xff);\n\ti = ((r1() & 0xf0) << 4); w0(0x87);\n\ti |= (r1() & 0xf0); w0(0x78);\n\tw0(0x20); w2(4); w2(5);\n\ti |= ((r1() & 0xf0) >> 4);\n\tw2(4); w0(0xff);\n\n\tif (i == 0xb5f) {\n\t\tw0(2); P1; w0(0);   P2;\n\t\tw0(3); P1; w0(0);   P2;\n\t\tw0(2); P1; w0(8);   P2; udelay(100);\n\t\tw0(2); P1; w0(0xa); P2; udelay(100);\n\t\tw0(2); P1; w0(8);   P2; udelay(1000);\n\n\t\ton26_write_regr(pi, 0, 6, 0xa0);\n\n\t\tfor (i = 0; i < RESET_WAIT; i++) {\n\t\t\ton26_write_regr(pi, 0, 6, 0xa0);\n\t\t\tx = on26_read_regr(pi, 0, 7);\n\t\t\ton26_write_regr(pi, 0, 6, 0xb0);\n\t\t\ty = on26_read_regr(pi, 0, 7);\n\t\t\tif (!((x & 0x80) || (y & 0x80)))\n\t\t\t\tbreak;\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tif (i == RESET_WAIT)\n\t\t\tdev_err(&pi->dev,\n\t\t\t\t\"on26: Device reset failed (%x,%x)\\n\", x, y);\n\n\t\tw0(4); P1; w0(4); P1;\n\t}\n\n\tCCP(0x30);\n\n\tpi->delay = d;\n\tpi->mode = m;\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n\n\treturn 5;\n}\n\nstatic void on26_read_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint k, a, b;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(1); P1; w0(1); P2; w0(2); P1; w0(0x18); P2; w0(0); P1;\n\t\tudelay(10);\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(6); a = r1();\n\t\t\tw2(4); b = r1();\n\t\t\tbuf[k] = j44(a, b);\n\t\t}\n\t\tw0(2); P1; w0(8); P2;\n\t\tbreak;\n\tcase 1:\n\t\tw0(1); P1; w0(1); P2; w0(2); P1; w0(0x19); P2; w0(0); P1;\n\t\tudelay(10);\n\t\tfor (k = 0; k < count / 2; k++) {\n\t\t\tw2(0x26); buf[2 * k] = r0();\n\t\t\tw2(0x24); buf[2 * k + 1] = r0();\n\t\t}\n\t\tw0(2); P1; w0(9); P2;\n\t\tbreak;\n\tcase 2:\n\t\tw3(1); w3(1); w2(5); w4(1); w2(4);\n\t\tw3(0); w3(0); w2(0x24);\n\t\tudelay(10);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(4);\n\t\tbreak;\n\tcase 3:\n\t\tw3(1); w3(1); w2(5); w4(1); w2(4);\n\t\tw3(0); w3(0); w2(0x24);\n\t\tudelay(10);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\t((u16 *)buf)[k] = r4w();\n\t\tw2(4);\n\t\tbreak;\n\tcase 4:\n\t\tw3(1); w3(1); w2(5); w4(1); w2(4);\n\t\tw3(0); w3(0); w2(0x24);\n\t\tudelay(10);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\t((u32 *)buf)[k] = r4l();\n\t\tw2(4);\n\t\tbreak;\n\t}\n}\n\nstatic void on26_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint k;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\t\tw0(1); P1; w0(1); P2;\n\t\tw0(2); P1; w0(0x18 + pi->mode); P2; w0(0); P1;\n\t\tudelay(10);\n\t\tfor (k = 0; k < count / 2; k++) {\n\t\t\tw2(5); w0(buf[2 * k]);\n\t\t\tw2(7); w0(buf[2 * k + 1]);\n\t\t}\n\t\tw2(5); w2(4);\n\t\tw0(2); P1; w0(8 + pi->mode); P2;\n\t\tbreak;\n\tcase 2:\n\t\tw3(1); w3(1); w2(5); w4(1); w2(4);\n\t\tw3(0); w3(0); w2(0xc5);\n\t\tudelay(10);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tw4(buf[k]);\n\t\tw2(0xc4);\n\t\tbreak;\n\tcase 3:\n\t\tw3(1); w3(1); w2(5); w4(1); w2(4);\n\t\tw3(0); w3(0); w2(0xc5);\n\t\tudelay(10);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\tw4w(((u16 *)buf)[k]);\n\t\tw2(0xc4);\n\t\tbreak;\n\tcase 4:\n\t\tw3(1); w3(1); w2(5); w4(1); w2(4);\n\t\tw3(0); w3(0); w2(0xc5);\n\t\tudelay(10);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\tw4l(((u32 *)buf)[k]);\n\t\tw2(0xc4);\n\t\tbreak;\n\t}\n}\n\nstatic void on26_log_adapter(struct pi_adapter *pi)\n{\n\tchar *mode_string[5] = { \"4-bit\", \"8-bit\", \"EPP-8\", \"EPP-16\", \"EPP-32\" };\n\n\tdev_info(&pi->dev,\n\t\t \"OnSpec 90c26 at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t pi->port, pi->mode, mode_string[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol on26 = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"on26\",\n\t.max_mode\t= 5,\n\t.epp_first\t= 2,\n\t.default_delay\t= 1,\n\t.max_units\t= 1,\n\t.write_regr\t= on26_write_regr,\n\t.read_regr\t= on26_read_regr,\n\t.write_block\t= on26_write_block,\n\t.read_block\t= on26_read_block,\n\t.connect\t= on26_connect,\n\t.disconnect\t= on26_disconnect,\n\t.test_port\t= on26_test_port,\n\t.log_adapter\t= on26_log_adapter,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"Onspec 90c26 parallel port IDE adapter protocol driver\");\nmodule_pata_parport_driver(on26);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}