{
  "module_name": "epat.c",
  "hash_id": "58e34aaebae248776fba78cb2910395afed28959aecaf11a605746f147e40f4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/epat.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n#define j44(a, b)\t(((a >> 4) & 0x0f) + (b & 0xf0))\n#define j53(a, b)\t(((a >> 3) & 0x1f) + ((b << 4) & 0xe0))\n\nstatic int epatc8;\n\nmodule_param(epatc8, int, 0);\nMODULE_PARM_DESC(epatc8,\n\t\t \"support for the Shuttle EP1284 chip, \"\n\t\t \"used in any recent Imation SuperDisk (LS-120) drive.\");\n\n \nstatic int cont_map[3] = { 0x18, 0x10, 0 };\n\nstatic void epat_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint r = regr + cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tw0(0x60+r); w2(1); w0(val); w2(4);\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tw3(0x40+r); w4(val);\n\t\tbreak;\n\t}\n}\n\nstatic int epat_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint  a, b, r;\n\n\tr = regr + cont_map[cont];\n\n\tswitch (pi->mode) {\n\n\tcase 0:\n\t\tw0(r); w2(1); w2(3);\n\t\ta = r1(); w2(4); b = r1();\n\t\treturn j44(a, b);\n\tcase 1:\n\t\tw0(0x40+r); w2(1); w2(4);\n\t\ta = r1(); b = r2(); w0(0xff);\n\t\treturn j53(a, b);\n\tcase 2:\n\t\tw0(0x20+r); w2(1); w2(0x25);\n\t\ta = r0(); w2(4);\n\t\treturn a;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tw3(r); w2(0x24); a = r4(); w2(4);\n\t\treturn a;\n\t}\n\n\treturn -1;\t \n}\n\nstatic void epat_read_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint  k, ph, a, b;\n\n\tswitch (pi->mode) {\n\n\tcase 0:\n\t\tw0(7); w2(1); w2(3); w0(0xff);\n\t\tph = 0;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tif (k == count-1)\n\t\t\t\tw0(0xfd);\n\t\t\tw2(6 + ph); a = r1();\n\t\t\tif (a & 8) {\n\t\t\t\tb = a;\n\t\t\t} else {\n\t\t\t\tw2(4+ph); b = r1();\n\t\t\t}\n\t\t\tbuf[k] = j44(a, b);\n\t\t\tph =  1 - ph;\n\t\t}\n\t\tw0(0); w2(4);\n\t\tbreak;\n\n\tcase 1:\n\t\tw0(0x47); w2(1); w2(5); w0(0xff);\n\t\tph = 0;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tif (k == count - 1)\n\t\t\t\tw0(0xfd);\n\t\t\tw2(4 + ph);\n\t\t\ta = r1(); b = r2();\n\t\t\tbuf[k] = j53(a, b);\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw0(0); w2(4);\n\t\tbreak;\n\n\tcase 2:\n\t\tw0(0x27); w2(1); w2(0x25); w0(0);\n\t\tph = 0;\n\t\tfor (k = 0; k < count - 1; k++) {\n\t\t\tw2(0x24 + ph);\n\t\t\tbuf[k] = r0();\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw2(0x26); w2(0x27);\n\t\tbuf[count - 1] = r0();\n\t\tw2(0x25); w2(4);\n\t\tbreak;\n\n\tcase 3:\n\t\tw3(0x80); w2(0x24);\n\t\tfor (k = 0; k < count - 1; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(4); w3(0xa0); w2(0x24);\n\t\tbuf[count - 1] = r4();\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 4:\n\t\tw3(0x80); w2(0x24);\n\t\tfor (k = 0; k < count / 2 - 1; k++)\n\t\t\t((u16 *)buf)[k] = r4w();\n\t\tbuf[count - 2] = r4();\n\t\tw2(4); w3(0xa0); w2(0x24);\n\t\tbuf[count - 1] = r4();\n\t\tw2(4);\n\t\tbreak;\n\n\tcase 5:\n\t\tw3(0x80); w2(0x24);\n\t\tfor (k = 0; k < count / 4 - 1; k++)\n\t\t\t((u32 *)buf)[k] = r4l();\n\t\tfor (k = count - 4; k < count - 1; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(4); w3(0xa0); w2(0x24);\n\t\tbuf[count - 1] = r4();\n\t\tw2(4);\n\t\tbreak;\n\t}\n}\n\nstatic void epat_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint ph, k;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tw0(0x67); w2(1); w2(5);\n\t\tph = 0;\n\t\tfor (k = 0; k < count; k++) {\n\t\t  \tw0(buf[k]);\n\t\t\tw2(4 + ph);\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw2(7); w2(4);\n\t\tbreak;\n\tcase 3:\n\t\tw3(0xc0);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tw4(buf[k]);\n\t\tw2(4);\n\t\tbreak;\n\tcase 4:\n\t\tw3(0xc0);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\tw4w(((u16 *)buf)[k]);\n\t\tw2(4);\n\t\tbreak;\n\tcase 5:\n\t\tw3(0xc0);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\tw4l(((u32 *)buf)[k]);\n\t\tw2(4);\n\t\tbreak;\n\t}\n}\n\n \n\n#define\tWR(r, v)\tepat_write_regr(pi, 2, r, v)\n#define\tRR(r)\t\tepat_read_regr(pi, 2, r)\n\n \n\n#define WRi(r, v)\tepat_write_regr(pi, 0, r, v)\n#define RRi(r)\t\tepat_read_regr(pi, 0, r)\n\n \n\n#define CPP(x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tw2(4); w0(0x22); w0(0xaa);\t\\\n\t\tw0(0x55); w0(0); w0(0xff);\t\\\n\t\tw0(0x87); w0(0x78); w0(x);\t\\\n\t\tw2(4); w2(5); w2(4); w0(0xff);\t\\\n\t} while (0)\n\nstatic void epat_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\n \t \n\tCPP(0);\n\n\tif (epatc8) {\n\t\tCPP(0x40); CPP(0xe0);\n\t\tw0(0); w2(1); w2(4);\n\t\tWR(0x8, 0x12);\n\t\tWR(0xc, 0x14);\n\t\tWR(0x12, 0x10);\n\t\tWR(0xe, 0xf);\n\t\tWR(0xf, 4);\n\t\t \n\t\tWR(0xe, 0xd);\n\t\tWR(0xf, 0);\n\t\t \n\t}\n\n         \n\tCPP(0xe0);\n\tw0(0); w2(1); w2(4);  \n        if (pi->mode >= 3) {\n\t\tw0(0); w2(1); w2(4); w2(0xc);\n\t\t \n\t\tw0(0x40); w2(6); w2(7); w2(4); w2(0xc); w2(4);\n        }\n\n\tif (!epatc8) {\n\t\tWR(8, 0x10);\n\t\tWR(0xc, 0x14);\n\t\tWR(0xa, 0x38);\n\t\tWR(0x12, 0x10);\n\t}\n}\n\nstatic void epat_disconnect(struct pi_adapter *pi)\n{\n\tCPP(0x30);\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\nstatic int epat_test_proto(struct pi_adapter *pi)\n{\n\tint k, j, f, cc;\n\tint e[2] = { 0, 0 };\n\tchar scratch[512];\n\n\tepat_connect(pi);\n\tcc = RR(0xd);\n\tepat_disconnect(pi);\n\n\tepat_connect(pi);\n\tfor (j=0;j<2;j++) {\n\t\tWRi(6, 0xa0 + j * 0x10);\n\t\tfor (k = 0; k < 256; k++) {\n\t\t\tWRi(2, k ^ 0xaa);\n\t\t\tWRi(3, k ^ 0x55);\n\t\t\tif (RRi(2) != (k ^ 0xaa))\n\t\t\t\te[j]++;\n\t\t}\n\t}\n\tepat_disconnect(pi);\n\n\tf = 0;\n\tepat_connect(pi);\n\tWR(0x13, 1); WR(0x13, 0); WR(0xa, 0x11);\n\tepat_read_block(pi, scratch, 512);\n\n\tfor (k = 0; k < 256; k++) {\n\t\tif ((scratch[2 * k] & 0xff) != k)\n\t\t\tf++;\n\t\tif ((scratch[2 * k + 1] & 0xff) != 0xff - k)\n\t\t\tf++;\n\t}\n\tepat_disconnect(pi);\n\n\tdev_dbg(&pi->dev,\n\t\t\"epat: port 0x%x, mode %d, ccr %x, test=(%d,%d,%d)\\n\",\n\t\tpi->port, pi->mode, cc, e[0], e[1], f);\n\n\treturn (e[0] && e[1]) || f;\n}\n\nstatic void epat_log_adapter(struct pi_adapter *pi)\n{\n\tint ver;\n\tchar *mode_string[6] =\n\t\t{ \"4-bit\", \"5/3\", \"8-bit\", \"EPP-8\", \"EPP-16\", \"EPP-32\" };\n\n\tepat_connect(pi);\n\tWR(0xa, 0x38);\t\t \n\tver = RR(0xb);\n\tepat_disconnect(pi);\n\n\tdev_info(&pi->dev,\n\t\t \"Shuttle EPAT chip %x at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t ver, pi->port, pi->mode, mode_string[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol epat = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"epat\",\n\t.max_mode\t= 6,\n\t.epp_first\t= 3,\n\t.default_delay\t= 1,\n\t.max_units\t= 1,\n\t.write_regr\t= epat_write_regr,\n\t.read_regr\t= epat_read_regr,\n\t.write_block\t= epat_write_block,\n\t.read_block\t= epat_read_block,\n\t.connect\t= epat_connect,\n\t.disconnect\t= epat_disconnect,\n\t.test_proto\t= epat_test_proto,\n\t.log_adapter\t= epat_log_adapter,\n};\n\nstatic int __init epat_init(void)\n{\n#ifdef CONFIG_PATA_PARPORT_EPATC8\n\tepatc8 = 1;\n#endif\n\treturn pata_parport_register_driver(&epat);\n}\n\nstatic void __exit epat_exit(void)\n{\n\tpata_parport_unregister_driver(&epat);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"Shuttle Technologies EPAT parallel port IDE adapter \"\n\t\t   \"protocol driver\");\nmodule_init(epat_init)\nmodule_exit(epat_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}