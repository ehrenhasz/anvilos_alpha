{
  "module_name": "epia.c",
  "hash_id": "8462a50b9bffaa3253b58ac9dd282484417c513017b22a8bc803afabdf3ae9c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/epia.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n \n\n#define j44(a, b)\t(((a >> 4) & 0x0f) + (b & 0xf0))\n#define j53(a, b)\t(((a >> 3) & 0x1f) + ((b << 4) & 0xe0))\n\n \nstatic int cont_map[2] = { 0, 0x80 };\n\nstatic int epia_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint a, b, r;\n\n\tregr += cont_map[cont];\n\n\tswitch (pi->mode)  {\n\tcase 0:\n\t\tr = regr ^ 0x39;\n\t\tw0(r); w2(1); w2(3); w0(r);\n\t\ta = r1(); w2(1); b = r1(); w2(4);\n\t\treturn j44(a, b);\n\tcase 1:\n\t\tr = regr ^ 0x31;\n\t\tw0(r); w2(1); w0(r & 0x37);\n\t\tw2(3); w2(5); w0(r | 0xf0);\n\t\ta = r1(); b = r2(); w2(4);\n\t\treturn j53(a, b);\n\tcase 2:\n\t\tr = regr^0x29;\n\t\tw0(r); w2(1); w2(0X21); w2(0x23);\n\t\ta = r0(); w2(4);\n\t\treturn a;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tw3(regr); w2(0x24); a = r4(); w2(4);\n\t\treturn a;\n\t}\n\n\treturn -1;\n}\n\nstatic void epia_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint  r;\n\n\tregr += cont_map[cont];\n\n\tswitch (pi->mode)  {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tr = regr ^ 0x19;\n\t\tw0(r); w2(1); w0(val); w2(3); w2(4);\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\tr = regr ^ 0x40;\n\t\tw3(r); w4(val); w2(4);\n\t\tbreak;\n\t}\n}\n\n#define WR(r, v)\tepia_write_regr(pi, 0, r, v)\n#define RR(r)\t\tepia_read_regr(pi, 0, r)\n\n \nstatic void epia_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tpi->saved_r2 = r2();\n\n\tw2(4); w0(0xa0); w0(0x50); w0(0xc0); w0(0x30); w0(0xa0); w0(0);\n\tw2(1); w2(4);\n\tif (pi->mode >= 3) {\n\t\tw0(0xa); w2(1); w2(4); w0(0x82); w2(4); w2(0xc); w2(4);\n\t\tw2(0x24); w2(0x26); w2(4);\n\t}\n\tWR(0x86, 8);\n}\n\nstatic void epia_disconnect(struct pi_adapter *pi)\n{\n\t \n\tw0(pi->saved_r0);\n\tw2(1); w2(4);\n\tw0(pi->saved_r0);\n\tw2(pi->saved_r2);\n}\n\nstatic void epia_read_block(struct pi_adapter *pi, char *buf, int count)\n\n{\n\tint k, ph, a, b;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(0x81); w2(1); w2(3); w0(0xc1);\n\t\tph = 1;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(2+ph); a = r1();\n\t\t\tw2(4+ph); b = r1();\n\t\t\tbuf[k] = j44(a, b);\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw0(0); w2(4);\n\t\tbreak;\n\tcase 1:\n\t\tw0(0x91); w2(1); w0(0x10); w2(3);\n\t\tw0(0x51); w2(5); w0(0xd1);\n\t\tph = 1;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(4 + ph);\n\t\t\ta = r1(); b = r2();\n\t\t\tbuf[k] = j53(a, b);\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw0(0); w2(4);\n\t\tbreak;\n\tcase 2:\n\t\tw0(0x89); w2(1); w2(0x23); w2(0x21);\n\t\tph = 1;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tw2(0x24 + ph);\n\t\t\tbuf[k] = r0();\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw2(6); w2(4);\n\t\tbreak;\n\tcase 3:\n\t\tif (count > 512)\n\t\t\tWR(0x84, 3);\n\t\tw3(0); w2(0x24);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tbuf[k] = r4();\n\t\tw2(4); WR(0x84, 0);\n\t\tbreak;\n\tcase 4:\n\t\tif (count > 512)\n\t\t\tWR(0x84, 3);\n\t\tw3(0); w2(0x24);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\t((u16 *)buf)[k] = r4w();\n\t\tw2(4); WR(0x84, 0);\n\t\tbreak;\n\tcase 5:\n\t\tif (count > 512)\n\t\t\tWR(0x84, 3);\n\t\tw3(0); w2(0x24);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\t((u32 *)buf)[k] = r4l();\n\t\tw2(4); WR(0x84, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void epia_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint ph, k, last, d;\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tw0(0xa1); w2(1); w2(3); w2(1); w2(5);\n\t\tph = 0;  last = 0x8000;\n\t\tfor (k = 0; k < count; k++) {\n\t\t\td = buf[k];\n\t\t\tif (d != last) {\n\t\t\t\tlast = d;\n\t\t\t\tw0(d);\n\t\t\t}\n\t\t\tw2(4 + ph);\n\t\t\tph = 1 - ph;\n\t\t}\n\t\tw2(7); w2(4);\n\t\tbreak;\n\tcase 3:\n\t\tif (count < 512)\n\t\t\tWR(0x84, 1);\n\t\tw3(0x40);\n\t\tfor (k = 0; k < count; k++)\n\t\t\tw4(buf[k]);\n\t\tif (count < 512)\n\t\t\tWR(0x84, 0);\n\t\tbreak;\n\tcase 4:\n\t\tif (count < 512)\n\t\t\tWR(0x84, 1);\n\t\tw3(0x40);\n\t\tfor (k = 0; k < count / 2; k++)\n\t\t\tw4w(((u16 *)buf)[k]);\n\t\tif (count < 512)\n\t\t\tWR(0x84, 0);\n\t\tbreak;\n\tcase 5:\n\t\tif (count < 512)\n\t\t\tWR(0x84, 1);\n\t\tw3(0x40);\n\t\tfor (k = 0; k < count / 4; k++)\n\t\t\tw4l(((u32 *)buf)[k]);\n\t\tif (count < 512)\n\t\t\tWR(0x84, 0);\n\t\tbreak;\n\t}\n}\n\nstatic int epia_test_proto(struct pi_adapter *pi)\n{\n\tint j, k, f;\n\tint e[2] = { 0, 0 };\n\tchar scratch[512];\n\n\tepia_connect(pi);\n\tfor (j = 0; j < 2; j++) {\n\t\tWR(6, 0xa0 + j * 0x10);\n\t\tfor (k = 0; k < 256; k++) {\n\t\t\tWR(2, k ^ 0xaa);\n\t\t\tWR(3, k ^ 0x55);\n\t\t\tif (RR(2) != (k ^ 0xaa))\n\t\t\t\te[j]++;\n\t\t}\n\t\tWR(2, 1); WR(3, 1);\n\t}\n\tepia_disconnect(pi);\n\n\tf = 0;\n\tepia_connect(pi);\n\tWR(0x84, 8);\n\tepia_read_block(pi, scratch, 512);\n\tfor (k = 0; k < 256; k++) {\n\t\tif ((scratch[2 * k] & 0xff) != ((k + 1) & 0xff))\n\t\t\tf++;\n\t\tif ((scratch[2 * k + 1] & 0xff) != ((-2 - k) & 0xff))\n\t\t\tf++;\n\t}\n\tWR(0x84, 0);\n\tepia_disconnect(pi);\n\n\tdev_dbg(&pi->dev, \"epia: port 0x%x, mode %d, test=(%d,%d,%d)\\n\",\n\t\tpi->port, pi->mode, e[0], e[1], f);\n\n\treturn (e[0] && e[1]) || f;\n}\n\n\nstatic void epia_log_adapter(struct pi_adapter *pi)\n{\n\tchar *mode[6] = { \"4-bit\", \"5/3\", \"8-bit\", \"EPP-8\", \"EPP-16\", \"EPP-32\"};\n\n\tdev_info(&pi->dev,\n\t\t \"Shuttle EPIA at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t pi->port, pi->mode, mode[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol epia = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"epia\",\n\t.max_mode\t= 6,\n\t.epp_first\t= 3,\n\t.default_delay\t= 1,\n\t.max_units\t= 1,\n\t.write_regr\t= epia_write_regr,\n\t.read_regr\t= epia_read_regr,\n\t.write_block\t= epia_write_block,\n\t.read_block\t= epia_read_block,\n\t.connect\t= epia_connect,\n\t.disconnect\t= epia_disconnect,\n\t.test_proto\t= epia_test_proto,\n\t.log_adapter\t= epia_log_adapter,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"Shuttle Technologies EPIA parallel port IDE adapter \"\n\t\t   \"protocol driver\");\nmodule_pata_parport_driver(epia);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}