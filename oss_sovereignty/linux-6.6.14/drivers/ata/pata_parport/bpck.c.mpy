{
  "module_name": "bpck.c",
  "hash_id": "f8c7e00d66285485b069844cfb6d9fb6ff0d1c0f0fd4c7f7fd30d579f8b61e9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/bpck.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <asm/io.h>\n#include \"pata_parport.h\"\n\n#undef r2\n#undef w2\n#undef PC\n\n#define PC\t\t\tpi->private\n#define r2()\t\t\t(PC=(in_p(2) & 0xff))\n#define w2(byte)  \t\t{out_p(2,byte); PC = byte;}\n#define t2(pat)   \t\t{PC ^= pat; out_p(2,PC);}\n#define e2()\t\t\t{PC &= 0xfe; out_p(2,PC);}\n#define o2()\t\t\t{PC |= 1; out_p(2,PC);}\n\n#define j44(l,h)     (((l>>3)&0x7)|((l>>4)&0x8)|((h<<1)&0x70)|(h&0x80))\n\n \nstatic int  cont_map[3] = { 0x40, 0x48, 0 };\n\nstatic int bpck_read_regr(struct pi_adapter *pi, int cont, int regr)\n{\n\tint r, l, h;\n\n\tr = regr + cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tw0(r & 0xf); w0(r); t2(2); t2(4);\n\t        l = r1();\n\t\tt2(4);\n\t\th = r1();\n\t\treturn j44(l, h);\n\tcase 1:\n\t\tw0(r & 0xf); w0(r); t2(2);\n\t\te2(); t2(0x20);\n\t\tt2(4); h = r0();\n\t\tt2(1); t2(0x20);\n\t\treturn h;\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tw0(r); w2(9); w2(0); w2(0x20);\n\t\th = r4();\n\t\tw2(0);\n\t\treturn h;\n\n\t}\n\treturn -1;\n}\n\nstatic void bpck_write_regr(struct pi_adapter *pi, int cont, int regr, int val)\n{\n\tint r;\n\n        r = regr + cont_map[cont];\n\n\tswitch (pi->mode) {\n\tcase 0:\n\tcase 1: w0(r);\n\t\tt2(2);\n\t\tw0(val);\n\t\to2(); t2(4); t2(1);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\tcase 4: w0(r); w2(9); w2(0);\n\t\tw0(val); w2(1); w2(3); w2(0);\n\t\tbreak;\n\n\t}\n}\n\n \n\n#define WR(r,v)\t\tbpck_write_regr(pi,2,r,v)\n#define RR(r)\t\t(bpck_read_regr(pi,2,r))\n\nstatic void bpck_write_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint i;\n\n\tswitch (pi->mode) {\n\n\tcase 0:\n\t\tWR(4, 0x40);\n\t\tw0(0x40); t2(2); t2(1);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tw0(buf[i]);\n\t\t\tt2(4);\n\t\t}\n\t\tWR(4, 0);\n\t\tbreak;\n\n\tcase 1:\n\t\tWR(4, 0x50);\n\t\tw0(0x40); t2(2); t2(1);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tw0(buf[i]);\n\t\t\tt2(4);\n\t\t}\n\t\tWR(4, 0x10);\n\t\tbreak;\n\n\tcase 2:\n\t\tWR(4, 0x48);\n\t\tw0(0x40); w2(9); w2(0); w2(1);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tw4(buf[i]);\n\t\tw2(0);\n\t\tWR(4, 8);\n\t\tbreak;\n\n\tcase 3:\n\t\tWR(4, 0x48);\n\t\tw0(0x40); w2(9); w2(0); w2(1);\n\t\tfor (i = 0; i < count / 2; i++)\n\t\t\tw4w(((u16 *)buf)[i]);\n\t\tw2(0);\n\t\tWR(4, 8);\n\t\tbreak;\n\n\tcase 4:\n\t\tWR(4, 0x48);\n\t\tw0(0x40); w2(9); w2(0); w2(1);\n\t\tfor (i = 0; i < count / 4; i++)\n\t\t\tw4l(((u32 *)buf)[i]);\n\t\tw2(0);\n\t\tWR(4, 8);\n\t\tbreak;\n \t}\n}\n\nstatic void bpck_read_block(struct pi_adapter *pi, char *buf, int count)\n{\n\tint i, l, h;\n\n\tswitch (pi->mode) {\n\n\tcase 0:\n\t\tWR(4, 0x40);\n\t\tw0(0x40); t2(2);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tt2(4); l = r1();\n\t\t\tt2(4); h = r1();\n\t\t\tbuf[i] = j44(l, h);\n\t\t}\n\t\tWR(4, 0);\n\t\tbreak;\n\n\tcase 1:\n\t\tWR(4, 0x50);\n\t\tw0(0x40); t2(2); t2(0x20);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tt2(4);\n\t\t\tbuf[i] = r0();\n\t\t}\n\t\tt2(1); t2(0x20);\n\t\tWR(4, 0x10);\n\t\tbreak;\n\n\tcase 2:\n\t\tWR(4, 0x48);\n\t\tw0(0x40); w2(9); w2(0); w2(0x20);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tbuf[i] = r4();\n\t\tw2(0);\n\t\tWR(4, 8);\n\t\tbreak;\n\n\tcase 3:\n\t\tWR(4, 0x48);\n\t\tw0(0x40); w2(9); w2(0); w2(0x20);\n\t\tfor (i = 0; i < count / 2; i++)\n\t\t\t((u16 *)buf)[i] = r4w();\n\t\tw2(0);\n\t\tWR(4, 8);\n\t\tbreak;\n\n\tcase 4:\n\t\tWR(4, 0x48);\n\t\tw0(0x40); w2(9); w2(0); w2(0x20);\n\t\tfor (i = 0; i < count / 4; i++)\n\t\t\t((u32 *)buf)[i] = r4l();\n\t\tw2(0);\n\t\tWR(4, 8);\n\t\tbreak;\n\n\t}\n}\n\nstatic int bpck_probe_unit(struct pi_adapter *pi)\n{\n\tint o1, o0, f7, id;\n\tint t, s;\n\n\tid = pi->unit;\n\ts = 0;\n\tw2(4); w2(0xe); r2(); t2(2);\n\to1 = r1()&0xf8;\n\to0 = r0();\n\tw0(255-id); w2(4); w0(id);\n\tt2(8); t2(8); t2(8);\n\tt2(2); t = r1()&0xf8;\n\tf7 = ((id % 8) == 7);\n\tif ((f7) || (t != o1)) {\n\t\tt2(2);\n\t\ts = r1() & 0xf8;\n\t}\n\tif ((t == o1) && ((!f7) || (s == o1)))  {\n\t\tw2(0x4c); w0(o0);\n\t\treturn 0;\n\t}\n\tt2(8); w0(0); t2(2); w2(0x4c); w0(o0);\n\treturn 1;\n}\n\nstatic void bpck_connect(struct pi_adapter *pi)\n{\n\tpi->saved_r0 = r0();\n\tw0(0xff-pi->unit); w2(4); w0(pi->unit);\n\tt2(8); t2(8); t2(8);\n\tt2(2); t2(2);\n\n\tswitch (pi->mode) {\n\tcase 0:\n\t\tt2(8); WR(4, 0);\n\t\tbreak;\n\tcase 1:\n\t\tt2(8); WR(4, 0x10);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tw2(0); WR(4, 8);\n\t\tbreak;\n\t}\n\n\tWR(5,8);\n\n\t \n\tWR(0x46, 0x10);\n\tWR(0x4c, 0x38);\n\tWR(0x4d, 0x88);\n\tWR(0x46, 0xa0);\n\tWR(0x41, 0);\n\tWR(0x4e, 8);\n\t \n}\n\nstatic void bpck_disconnect(struct pi_adapter *pi)\n{\n\tw0(0);\n\tif (pi->mode >= 2) {\n\t\tw2(9); w2(0);\n\t} else {\n\t\tt2(2);\n\t}\n\tw2(0x4c); w0(pi->saved_r0);\n}\n\nstatic void bpck_force_spp(struct pi_adapter *pi)\n{\n\t \n\tpi->saved_r0 = r0();\n\tw0(0xff-pi->unit); w2(4); w0(pi->unit);\n\tt2(8); t2(8); t2(8);\n\tt2(2); t2(2);\n\n\tw2(0);\n\tw0(4); w2(9); w2(0);\n\tw0(0); w2(1); w2(3); w2(0);\n\tw0(0); w2(9); w2(0);\n\tw2(0x4c); w0(pi->saved_r0);\n}\n\n#define TEST_LEN  16\n\nstatic int bpck_test_proto(struct pi_adapter *pi)\n{\n\tint i, e, l, h, om;\n\tchar buf[TEST_LEN];\n\n\tbpck_force_spp(pi);\n\n\tswitch (pi->mode) {\n\n\tcase 0:\n\t\tbpck_connect(pi);\n\t\tWR(0x13, 0x7f);\n\t\tw0(0x13); t2(2);\n\t\tfor (i = 0; i < TEST_LEN; i++) {\n\t\t\tt2(4); l = r1();\n\t\t\tt2(4); h = r1();\n\t\t\tbuf[i] = j44(l, h);\n\t\t}\n\t\tbpck_disconnect(pi);\n\t\tbreak;\n\n\tcase 1:\n\t\tbpck_connect(pi);\n\t\tWR(0x13, 0x7f);\n\t\tw0(0x13); t2(2); t2(0x20);\n\t\tfor (i = 0; i < TEST_LEN; i++) {\n\t\t\tt2(4);\n\t\t\tbuf[i] = r0();\n\t\t}\n\t\tt2(1); t2(0x20);\n\t\tbpck_disconnect(pi);\n\t\tbreak;\n\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\tom = pi->mode;\n\t\tpi->mode = 0;\n\t\tbpck_connect(pi);\n\t\tWR(7, 3);\n\t\tWR(4, 8);\n\t\tbpck_disconnect(pi);\n\n\t\tpi->mode = om;\n\t\tbpck_connect(pi);\n\t\tw0(0x13); w2(9); w2(1); w0(0); w2(3); w2(0); w2(0xe0);\n\n\t\tswitch (pi->mode) {\n\t\tcase 2:\n\t\t\tfor (i = 0; i < TEST_LEN; i++)\n\t\t\t\tbuf[i] = r4();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfor (i = 0; i < TEST_LEN / 2; i++)\n\t\t\t\t((u16 *)buf)[i] = r4w();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfor (i = 0; i < TEST_LEN / 4; i++)\n\t\t\t\t((u32 *)buf)[i] = r4l();\n\t\t\tbreak;\n\t\t}\n\n\t\tw2(0);\n\t\tWR(7, 0);\n\t\tbpck_disconnect(pi);\n\t\tbreak;\n\n\t}\n\n\tdev_dbg(&pi->dev, \"bpck: 0x%x unit %d mode %d: \",\n\t\tpi->port, pi->unit, pi->mode);\n\tprint_hex_dump_debug(\"bpck: \", DUMP_PREFIX_NONE, TEST_LEN, 1, buf,\n\t\t\t     TEST_LEN, false);\n\n\te = 0;\n\tfor (i = 0; i < TEST_LEN; i++) {\n\t\tif (buf[i] != i + 1)\n\t\t\te++;\n\t}\n\n\treturn e;\n}\n\nstatic void bpck_read_eeprom(struct pi_adapter *pi, char *buf)\n{\n\tint i, j, k, p, v, f, om, od;\n\n\tbpck_force_spp(pi);\n\n\tom = pi->mode;  od = pi->delay;\n\tpi->mode = 0; pi->delay = 6;\n\n\tbpck_connect(pi);\n\n\tWR(4, 0);\n\tfor (i = 0; i < 64; i++) {\n\t\tWR(6, 8);\n\t\tWR(6, 0xc);\n\t\tp = 0x100;\n\t\tfor (k = 0; k < 9; k++) {\n\t\t\tf = (((i + 0x180) & p) != 0) * 2;\n\t\t\tWR(6, f + 0xc);\n\t\t\tWR(6, f + 0xd);\n\t\t\tWR(6, f + 0xc);\n\t\t\tp = (p >> 1);\n\t\t}\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tv = 0;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tWR(6, 0xc);\n\t\t\t\tWR(6, 0xd);\n\t\t\t\tWR(6, 0xc);\n\t\t\t\tf = RR(0);\n\t\t\t\tv = 2 * v + (f == 0x84);\n\t\t\t}\n\t\t\tbuf[2 * i + 1 - j] = v;\n\t\t}\n\t}\n\tWR(6, 8);\n\tWR(6, 0);\n\tWR(5, 8);\n\n\tbpck_disconnect(pi);\n\n        if (om >= 2) {\n\t\tbpck_connect(pi);\n\t\tWR(7, 3);\n\t\tWR(4, 8);\n\t\tbpck_disconnect(pi);\n        }\n\n\tpi->mode = om; pi->delay = od;\n}\n\nstatic int bpck_test_port(struct pi_adapter *pi)\n{\n\tint i, r, m;\n\n\t \n\tw2(0x2c); i = r0(); w0(255-i); r = r0(); w0(i);\n\tm = -1;\n\tif (r == i)\n\t\tm = 2;\n\tif (r == (255-i))\n\t\tm = 0;\n\n\tw2(0xc);\n\ti = r0();\n\tw0(255-i);\n\tr = r0();\n\tw0(i);\n\tif (r != (255-i))\n\t\tm = -1;\n\n\tif (m == 0) {\n\t\tw2(6);\n\t\tw2(0xc);\n\t\tr = r0();\n\t\tw0(0xaa);\n\t\tw0(r);\n\t\tw0(0xaa);\n\t}\n\tif (m == 2) {\n\t\tw2(0x26);\n\t\tw2(0xc);\n\t}\n\n\tif (m == -1)\n\t\treturn 0;\n\n\treturn 5;\n}\n\nstatic void bpck_log_adapter(struct pi_adapter *pi)\n{\n\tchar *mode_str[5] = { \"4-bit\", \"8-bit\", \"EPP-8\", \"EPP-16\", \"EPP-32\" };\n\tchar scratch[128];\n\n\tbpck_read_eeprom(pi,scratch);\n\tprint_hex_dump_bytes(\"bpck EEPROM: \", DUMP_PREFIX_NONE, scratch, 128);\n\tdev_info(&pi->dev,\n\t\t \"backpack %8.8s unit %d at 0x%x, mode %d (%s), delay %d\\n\",\n\t\t &scratch[110], pi->unit, pi->port, pi->mode,\n\t\t mode_str[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol bpck = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bpck\",\n\t.max_mode\t= 5,\n\t.epp_first\t= 2,\n\t.default_delay\t= 4,\n\t.max_units\t= 255,\n\t.write_regr\t= bpck_write_regr,\n\t.read_regr\t= bpck_read_regr,\n\t.write_block\t= bpck_write_block,\n\t.read_block\t= bpck_read_block,\n\t.connect\t= bpck_connect,\n\t.disconnect\t= bpck_disconnect,\n\t.test_port\t= bpck_test_port,\n\t.probe_unit\t= bpck_probe_unit,\n\t.test_proto\t= bpck_test_proto,\n\t.log_adapter\t= bpck_log_adapter,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Grant R. Guenther <grant@torque.net>\");\nMODULE_DESCRIPTION(\"MicroSolutions BACKPACK parallel port IDE adapter protocol driver\");\nmodule_pata_parport_driver(bpck);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}