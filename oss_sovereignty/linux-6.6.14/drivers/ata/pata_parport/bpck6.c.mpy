{
  "module_name": "bpck6.c",
  "hash_id": "d9c537722c54b3c147810e38fefdae8aebf1e23c4df4fc4824c9c7ff85b9ee16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_parport/bpck6.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/parport.h>\n#include \"pata_parport.h\"\n\n \n#define ACCESS_REG\t\t0x00\n#define ACCESS_PORT\t\t0x40\n\n#define ACCESS_READ\t\t0x00\n#define ACCESS_WRITE\t\t0x20\n\n \n#define CMD_PREFIX_SET\t\t0xe0\t\n#define CMD_PREFIX_RESET\t0xc0\t\n #define PREFIX_IO16\t\t0x01\t\n #define PREFIX_FASTWR\t\t0x04\t\n #define PREFIX_BLK\t\t0x08\t\n\n \n#define REG_STATUS\t\t0x00\t\n #define STATUS_IRQA\t\t0x01\t\n #define STATUS_EEPROM_DO\t0x40\t\n#define REG_VERSION\t\t0x01\t\n#define REG_HWCFG\t\t0x02\t\n#define REG_RAMSIZE\t\t0x03\t\n #define RAMSIZE_128K\t\t0x02\n#define REG_EEPROM\t\t0x06\t\n #define EEPROM_SK\t\t0x01\t\n #define EEPROM_DI\t\t0x02\t\n #define EEPROM_CS\t\t0x04\t\n #define EEPROM_EN\t\t0x08\t\n#define REG_BLKSIZE\t\t0x08\t\n\n \n#define fifo_wait\t\t0x10\n\n \n#define PPCMODE_UNI_SW\t\t0\n#define PPCMODE_UNI_FW\t\t1\n#define PPCMODE_BI_SW\t\t2\n#define PPCMODE_BI_FW\t\t3\n#define PPCMODE_EPP_BYTE\t4\n#define PPCMODE_EPP_WORD\t5\n#define PPCMODE_EPP_DWORD\t6\n\nstatic int mode_map[] = { PPCMODE_UNI_FW, PPCMODE_BI_FW, PPCMODE_EPP_BYTE,\n\t\t\t  PPCMODE_EPP_WORD, PPCMODE_EPP_DWORD };\n\nstatic void bpck6_send_cmd(struct pi_adapter *pi, u8 cmd)\n{\n\tswitch (mode_map[pi->mode]) {\n\tcase PPCMODE_UNI_SW:\n\tcase PPCMODE_UNI_FW:\n\tcase PPCMODE_BI_SW:\n\tcase PPCMODE_BI_FW:\n\t\tparport_write_data(pi->pardev->port, cmd);\n\t\tparport_frob_control(pi->pardev->port, 0, PARPORT_CONTROL_AUTOFD);\n\t\tbreak;\n\tcase PPCMODE_EPP_BYTE:\n\tcase PPCMODE_EPP_WORD:\n\tcase PPCMODE_EPP_DWORD:\n\t\tpi->pardev->port->ops->epp_write_addr(pi->pardev->port, &cmd, 1, 0);\n\t\tbreak;\n\t}\n}\n\nstatic u8 bpck6_rd_data_byte(struct pi_adapter *pi)\n{\n\tu8 data = 0;\n\n\tswitch (mode_map[pi->mode]) {\n\tcase PPCMODE_UNI_SW:\n\tcase PPCMODE_UNI_FW:\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE,\n\t\t\t\t\t\t\tPARPORT_CONTROL_INIT);\n\t\tdata = parport_read_status(pi->pardev->port);\n\t\tdata = ((data & 0x80) >> 1) | ((data & 0x38) >> 3);\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE,\n\t\t\t\t\t\t\tPARPORT_CONTROL_STROBE);\n\t\tdata |= parport_read_status(pi->pardev->port) & 0xB8;\n\t\tbreak;\n\tcase PPCMODE_BI_SW:\n\tcase PPCMODE_BI_FW:\n\t\tparport_data_reverse(pi->pardev->port);\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE,\n\t\t\t\tPARPORT_CONTROL_STROBE | PARPORT_CONTROL_INIT);\n\t\tdata = parport_read_data(pi->pardev->port);\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE, 0);\n\t\tparport_data_forward(pi->pardev->port);\n\t\tbreak;\n\tcase PPCMODE_EPP_BYTE:\n\tcase PPCMODE_EPP_WORD:\n\tcase PPCMODE_EPP_DWORD:\n\t\tpi->pardev->port->ops->epp_read_data(pi->pardev->port, &data, 1, 0);\n\t\tbreak;\n\t}\n\n\treturn data;\n}\n\nstatic void bpck6_wr_data_byte(struct pi_adapter *pi, u8 data)\n{\n\tswitch (mode_map[pi->mode]) {\n\tcase PPCMODE_UNI_SW:\n\tcase PPCMODE_UNI_FW:\n\tcase PPCMODE_BI_SW:\n\tcase PPCMODE_BI_FW:\n\t\tparport_write_data(pi->pardev->port, data);\n\t\tparport_frob_control(pi->pardev->port, 0, PARPORT_CONTROL_INIT);\n\t\tbreak;\n\tcase PPCMODE_EPP_BYTE:\n\tcase PPCMODE_EPP_WORD:\n\tcase PPCMODE_EPP_DWORD:\n\t\tpi->pardev->port->ops->epp_write_data(pi->pardev->port, &data, 1, 0);\n\t\tbreak;\n\t}\n}\n\nstatic int bpck6_read_regr(struct pi_adapter *pi, int cont, int reg)\n{\n\tu8 port = cont ? reg | 8 : reg;\n\n\tbpck6_send_cmd(pi, port | ACCESS_PORT | ACCESS_READ);\n\treturn bpck6_rd_data_byte(pi);\n}\n\nstatic void bpck6_write_regr(struct pi_adapter *pi, int cont, int reg, int val)\n{\n\tu8 port = cont ? reg | 8 : reg;\n\n\tbpck6_send_cmd(pi, port | ACCESS_PORT | ACCESS_WRITE);\n\tbpck6_wr_data_byte(pi, val);\n}\n\nstatic void bpck6_wait_for_fifo(struct pi_adapter *pi)\n{\n\tint i;\n\n\tif (pi->private & fifo_wait) {\n\t\tfor (i = 0; i < 20; i++)\n\t\t\tparport_read_status(pi->pardev->port);\n\t}\n}\n\nstatic void bpck6_write_block(struct pi_adapter *pi, char *buf, int len)\n{\n\tu8 this, last;\n\n\tbpck6_send_cmd(pi, REG_BLKSIZE | ACCESS_REG | ACCESS_WRITE);\n\tbpck6_wr_data_byte(pi, (u8)len);\n\tbpck6_wr_data_byte(pi, (u8)(len >> 8));\n\tbpck6_wr_data_byte(pi, 0);\n\n\tbpck6_send_cmd(pi, CMD_PREFIX_SET | PREFIX_IO16 | PREFIX_BLK);\n\tbpck6_send_cmd(pi, ATA_REG_DATA | ACCESS_PORT | ACCESS_WRITE);\n\n\tswitch (mode_map[pi->mode]) {\n\tcase PPCMODE_UNI_SW:\n\tcase PPCMODE_BI_SW:\n\t\twhile (len--) {\n\t\t\tparport_write_data(pi->pardev->port, *buf++);\n\t\t\tparport_frob_control(pi->pardev->port, 0,\n\t\t\t\t\t\t\tPARPORT_CONTROL_INIT);\n\t\t}\n\t\tbreak;\n\tcase PPCMODE_UNI_FW:\n\tcase PPCMODE_BI_FW:\n\t\tbpck6_send_cmd(pi, CMD_PREFIX_SET | PREFIX_FASTWR);\n\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE,\n\t\t\t\t\t\t\tPARPORT_CONTROL_STROBE);\n\n\t\tlast = *buf;\n\n\t\tparport_write_data(pi->pardev->port, last);\n\n\t\twhile (len) {\n\t\t\tthis = *buf++;\n\t\t\tlen--;\n\n\t\t\tif (this == last) {\n\t\t\t\tparport_frob_control(pi->pardev->port, 0,\n\t\t\t\t\t\t\tPARPORT_CONTROL_INIT);\n\t\t\t} else {\n\t\t\t\tparport_write_data(pi->pardev->port, this);\n\t\t\t\tlast = this;\n\t\t\t}\n\t\t}\n\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE,\n\t\t\t\t\t\t\t0);\n\t\tbpck6_send_cmd(pi, CMD_PREFIX_RESET | PREFIX_FASTWR);\n\t\tbreak;\n\tcase PPCMODE_EPP_BYTE:\n\t\tpi->pardev->port->ops->epp_write_data(pi->pardev->port, buf,\n\t\t\t\t\t\tlen, PARPORT_EPP_FAST_8);\n\t\tbpck6_wait_for_fifo(pi);\n\t\tbreak;\n\tcase PPCMODE_EPP_WORD:\n\t\tpi->pardev->port->ops->epp_write_data(pi->pardev->port, buf,\n\t\t\t\t\t\tlen, PARPORT_EPP_FAST_16);\n\t\tbpck6_wait_for_fifo(pi);\n\t\tbreak;\n\tcase PPCMODE_EPP_DWORD:\n\t\tpi->pardev->port->ops->epp_write_data(pi->pardev->port, buf,\n\t\t\t\t\t\tlen, PARPORT_EPP_FAST_32);\n\t\tbpck6_wait_for_fifo(pi);\n\t\tbreak;\n\t}\n\n\tbpck6_send_cmd(pi, CMD_PREFIX_RESET | PREFIX_IO16 | PREFIX_BLK);\n}\n\nstatic void bpck6_read_block(struct pi_adapter *pi, char *buf, int len)\n{\n\tbpck6_send_cmd(pi, REG_BLKSIZE | ACCESS_REG | ACCESS_WRITE);\n\tbpck6_wr_data_byte(pi, (u8)len);\n\tbpck6_wr_data_byte(pi, (u8)(len >> 8));\n\tbpck6_wr_data_byte(pi, 0);\n\n\tbpck6_send_cmd(pi, CMD_PREFIX_SET | PREFIX_IO16 | PREFIX_BLK);\n\tbpck6_send_cmd(pi, ATA_REG_DATA | ACCESS_PORT | ACCESS_READ);\n\n\tswitch (mode_map[pi->mode]) {\n\tcase PPCMODE_UNI_SW:\n\tcase PPCMODE_UNI_FW:\n\t\twhile (len) {\n\t\t\tu8 d;\n\n\t\t\tparport_frob_control(pi->pardev->port,\n\t\t\t\t\tPARPORT_CONTROL_STROBE,\n\t\t\t\t\tPARPORT_CONTROL_INIT);  \n\t\t\td = parport_read_status(pi->pardev->port);\n\t\t\td = ((d & 0x80) >> 1) | ((d & 0x38) >> 3);\n\t\t\tparport_frob_control(pi->pardev->port,\n\t\t\t\t\tPARPORT_CONTROL_STROBE,\n\t\t\t\t\tPARPORT_CONTROL_STROBE);\n\t\t\td |= parport_read_status(pi->pardev->port) & 0xB8;\n\t\t\t*buf++ = d;\n\t\t\tlen--;\n\t\t}\n\t\tbreak;\n\tcase PPCMODE_BI_SW:\n\tcase PPCMODE_BI_FW:\n\t\tparport_data_reverse(pi->pardev->port);\n\t\twhile (len) {\n\t\t\tparport_frob_control(pi->pardev->port,\n\t\t\t\tPARPORT_CONTROL_STROBE,\n\t\t\t\tPARPORT_CONTROL_STROBE | PARPORT_CONTROL_INIT);\n\t\t\t*buf++ = parport_read_data(pi->pardev->port);\n\t\t\tlen--;\n\t\t}\n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_STROBE,\n\t\t\t\t\t0);\n\t\tparport_data_forward(pi->pardev->port);\n\t\tbreak;\n\tcase PPCMODE_EPP_BYTE:\n\t\tpi->pardev->port->ops->epp_read_data(pi->pardev->port, buf, len,\n\t\t\t\t\t\tPARPORT_EPP_FAST_8);\n\t\tbreak;\n\tcase PPCMODE_EPP_WORD:\n\t\tpi->pardev->port->ops->epp_read_data(pi->pardev->port, buf, len,\n\t\t\t\t\t\tPARPORT_EPP_FAST_16);\n\t\tbreak;\n\tcase PPCMODE_EPP_DWORD:\n\t\tpi->pardev->port->ops->epp_read_data(pi->pardev->port, buf, len,\n\t\t\t\t\t\tPARPORT_EPP_FAST_32);\n\t\tbreak;\n\t}\n\n\tbpck6_send_cmd(pi, CMD_PREFIX_RESET | PREFIX_IO16 | PREFIX_BLK);\n}\n\nstatic int bpck6_open(struct pi_adapter *pi)\n{\n\tu8 i, j, k;\n\n\tpi->saved_r0 = parport_read_data(pi->pardev->port);\n\tpi->saved_r2 = parport_read_control(pi->pardev->port) & 0x5F;\n\n\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_SELECT,\n\t\t\t\t\t\tPARPORT_CONTROL_SELECT);\n\tif (pi->saved_r0 == 'b')\n\t\tparport_write_data(pi->pardev->port, 'x');\n\tparport_write_data(pi->pardev->port, 'b');\n\tparport_write_data(pi->pardev->port, 'p');\n\tparport_write_data(pi->pardev->port, pi->unit);\n\tparport_write_data(pi->pardev->port, ~pi->unit);\n\n\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_SELECT, 0);\n\tparport_write_control(pi->pardev->port, PARPORT_CONTROL_INIT);\n\n\ti = mode_map[pi->mode] & 0x0C;\n\tif (i == 0)\n\t\ti = (mode_map[pi->mode] & 2) | 1;\n\tparport_write_data(pi->pardev->port, i);\n\n\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_SELECT,\n\t\t\t\t\t\tPARPORT_CONTROL_SELECT);\n\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_AUTOFD,\n\t\t\t\t\t\tPARPORT_CONTROL_AUTOFD);\n\n\tj = ((i & 0x08) << 4) | ((i & 0x07) << 3);\n\tk = parport_read_status(pi->pardev->port) & 0xB8;\n\tif (j != k)\n\t\tgoto fail;\n\n\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_AUTOFD, 0);\n\tk = (parport_read_status(pi->pardev->port) & 0xB8) ^ 0xB8;\n\tif (j != k)\n\t\tgoto fail;\n\n\tif (i & 4) {\n\t\t \n\t\tparport_frob_control(pi->pardev->port,\n\t\t\tPARPORT_CONTROL_SELECT | PARPORT_CONTROL_INIT, 0);\n\t} else {\n\t\t \n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_SELECT, 0);\n\t}\n\n\tpi->private = 0;\n\n\tbpck6_send_cmd(pi, ACCESS_REG | ACCESS_WRITE | REG_RAMSIZE);\n\tbpck6_wr_data_byte(pi, RAMSIZE_128K);\n\n\tbpck6_send_cmd(pi, ACCESS_REG | ACCESS_READ | REG_VERSION);\n\tif ((bpck6_rd_data_byte(pi) & 0x3F) == 0x0C)\n\t\tpi->private |= fifo_wait;\n\n\treturn 1;\n\nfail:\n\tparport_write_control(pi->pardev->port, pi->saved_r2);\n\tparport_write_data(pi->pardev->port, pi->saved_r0);\n\n\treturn 0;\n}\n\nstatic void bpck6_deselect(struct pi_adapter *pi)\n{\n\tif (mode_map[pi->mode] & 4) {\n\t\t \n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_INIT,\n\t\t\t\t     PARPORT_CONTROL_INIT);\n\t} else {\n\t\t \n\t\tparport_frob_control(pi->pardev->port, PARPORT_CONTROL_SELECT,\n\t\t\t\t     PARPORT_CONTROL_SELECT);\n\t}\n\n\tparport_write_data(pi->pardev->port, pi->saved_r0);\n\tparport_write_control(pi->pardev->port,\n\t\t\tpi->saved_r2 | PARPORT_CONTROL_SELECT);\n\tparport_write_control(pi->pardev->port, pi->saved_r2);\n}\n\nstatic void bpck6_wr_extout(struct pi_adapter *pi, u8 regdata)\n{\n\tbpck6_send_cmd(pi, REG_VERSION | ACCESS_REG | ACCESS_WRITE);\n\tbpck6_wr_data_byte(pi, (u8)((regdata & 0x03) << 6));\n}\n\nstatic void bpck6_connect(struct pi_adapter *pi)\n{\n\tdev_dbg(&pi->dev, \"connect\\n\");\n\n\tbpck6_open(pi);\n\tbpck6_wr_extout(pi, 0x3);\n}\n\nstatic void bpck6_disconnect(struct pi_adapter *pi)\n{\n\tdev_dbg(&pi->dev, \"disconnect\\n\");\n\tbpck6_wr_extout(pi, 0x0);\n\tbpck6_deselect(pi);\n}\n\n \nstatic int bpck6_test_port(struct pi_adapter *pi)\n{\n\tdev_dbg(&pi->dev, \"PARPORT indicates modes=%x for lp=0x%lx\\n\",\n\t\tpi->pardev->port->modes, pi->pardev->port->base);\n\n\t \n\tif (pi->pardev->port->modes & PARPORT_MODE_EPP)\n\t\treturn 5;  \n\tif (pi->pardev->port->modes & PARPORT_MODE_TRISTATE)\n\t\treturn 2;\n\treturn 1;  \n}\n\nstatic int bpck6_probe_unit(struct pi_adapter *pi)\n{\n\tint out, saved_mode;\n\n\tdev_dbg(&pi->dev, \"PROBE UNIT %x on port:%x\\n\", pi->unit, pi->port);\n\n\tsaved_mode = pi->mode;\n\t \n\tpi->mode = 0;\n\n\tout = bpck6_open(pi);\n\n\tdev_dbg(&pi->dev, \"ppc_open returned %2x\\n\", out);\n\n\tif (out) {\n\t\tbpck6_deselect(pi);\n\t\tdev_dbg(&pi->dev, \"leaving probe\\n\");\n\t\tpi->mode = saved_mode;\n\t\treturn 1;\n\t}\n\n\tdev_dbg(&pi->dev, \"Failed open\\n\");\n\tpi->mode = saved_mode;\n\n\treturn 0;\n}\n\nstatic void bpck6_log_adapter(struct pi_adapter *pi)\n{\n\tchar *mode_string[5] = { \"4-bit\", \"8-bit\", \"EPP-8\", \"EPP-16\", \"EPP-32\" };\n\n\tdev_info(&pi->dev,\n\t\t \"Micro Solutions BACKPACK Drive unit %d at 0x%x, mode:%d (%s), delay %d\\n\",\n\t\t pi->unit, pi->port, pi->mode, mode_string[pi->mode], pi->delay);\n}\n\nstatic struct pi_protocol bpck6 = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bpck6\",\n\t.max_mode\t= 5,\n\t.epp_first\t= 2,  \n\t.max_units\t= 255,\n\t.write_regr\t= bpck6_write_regr,\n\t.read_regr\t= bpck6_read_regr,\n\t.write_block\t= bpck6_write_block,\n\t.read_block\t= bpck6_read_block,\n\t.connect\t= bpck6_connect,\n\t.disconnect\t= bpck6_disconnect,\n\t.test_port\t= bpck6_test_port,\n\t.probe_unit\t= bpck6_probe_unit,\n\t.log_adapter\t= bpck6_log_adapter,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Micro Solutions Inc.\");\nMODULE_DESCRIPTION(\"Micro Solutions BACKPACK parallel port IDE adapter \"\n\t\t   \"(version 6 drives) protocol driver\");\nmodule_pata_parport_driver(bpck6);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}