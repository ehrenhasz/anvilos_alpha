{
  "module_name": "pata_imx.c",
  "hash_id": "d7533f6d909de7e3bf1b170ac1f745034304589701d63996585e05a72eedfcb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_imx.c",
  "human_readable_source": " \n\n#include <linux/ata.h>\n#include <linux/clk.h>\n#include <linux/libata.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME \"pata_imx\"\n\n#define PATA_IMX_ATA_TIME_OFF\t\t0x00\n#define PATA_IMX_ATA_TIME_ON\t\t0x01\n#define PATA_IMX_ATA_TIME_1\t\t0x02\n#define PATA_IMX_ATA_TIME_2W\t\t0x03\n#define PATA_IMX_ATA_TIME_2R\t\t0x04\n#define PATA_IMX_ATA_TIME_AX\t\t0x05\n#define PATA_IMX_ATA_TIME_PIO_RDX\t0x06\n#define PATA_IMX_ATA_TIME_4\t\t0x07\n#define PATA_IMX_ATA_TIME_9\t\t0x08\n\n#define PATA_IMX_ATA_CONTROL\t\t0x24\n#define PATA_IMX_ATA_CTRL_FIFO_RST_B\t(1<<7)\n#define PATA_IMX_ATA_CTRL_ATA_RST_B\t(1<<6)\n#define PATA_IMX_ATA_CTRL_IORDY_EN\t(1<<0)\n#define PATA_IMX_ATA_INT_EN\t\t0x2C\n#define PATA_IMX_ATA_INTR_ATA_INTRQ2\t(1<<3)\n#define PATA_IMX_DRIVE_DATA\t\t0xA0\n#define PATA_IMX_DRIVE_CONTROL\t\t0xD8\n\nstatic u32 pio_t4[] = { 30,  20,  15,  10,  10 };\nstatic u32 pio_t9[] = { 20,  15,  10,  10,  10 };\nstatic u32 pio_tA[] = { 35,  35,  35,  35,  35 };\n\nstruct pata_imx_priv {\n\tstruct clk *clk;\n\t \n\tvoid __iomem *host_regs;\n\tu32 ata_ctl;\n};\n\nstatic void pata_imx_set_timing(struct ata_device *adev,\n\t\t\t\tstruct pata_imx_priv *priv)\n{\n\tstruct ata_timing timing;\n\tunsigned long clkrate;\n\tu32 T, mode;\n\n\tclkrate = clk_get_rate(priv->clk);\n\n\tif (adev->pio_mode < XFER_PIO_0 || adev->pio_mode > XFER_PIO_4 ||\n\t    !clkrate)\n\t\treturn;\n\n\tT = 1000000000 / clkrate;\n\tata_timing_compute(adev, adev->pio_mode, &timing, T * 1000, 0);\n\n\tmode = adev->pio_mode - XFER_PIO_0;\n\n\twriteb(3, priv->host_regs + PATA_IMX_ATA_TIME_OFF);\n\twriteb(3, priv->host_regs + PATA_IMX_ATA_TIME_ON);\n\twriteb(timing.setup, priv->host_regs + PATA_IMX_ATA_TIME_1);\n\twriteb(timing.act8b, priv->host_regs + PATA_IMX_ATA_TIME_2W);\n\twriteb(timing.act8b, priv->host_regs + PATA_IMX_ATA_TIME_2R);\n\twriteb(1, priv->host_regs + PATA_IMX_ATA_TIME_PIO_RDX);\n\n\twriteb(pio_t4[mode] / T + 1, priv->host_regs + PATA_IMX_ATA_TIME_4);\n\twriteb(pio_t9[mode] / T + 1, priv->host_regs + PATA_IMX_ATA_TIME_9);\n\twriteb(pio_tA[mode] / T + 1, priv->host_regs + PATA_IMX_ATA_TIME_AX);\n}\n\nstatic void pata_imx_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pata_imx_priv *priv = ap->host->private_data;\n\tu32 val;\n\n\tpata_imx_set_timing(adev, priv);\n\n\tval = __raw_readl(priv->host_regs + PATA_IMX_ATA_CONTROL);\n\tif (ata_pio_need_iordy(adev))\n\t\tval |= PATA_IMX_ATA_CTRL_IORDY_EN;\n\telse\n\t\tval &= ~PATA_IMX_ATA_CTRL_IORDY_EN;\n\t__raw_writel(val, priv->host_regs + PATA_IMX_ATA_CONTROL);\n}\n\nstatic const struct scsi_host_template pata_imx_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations pata_imx_port_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t\t= ata_sff_data_xfer32,\n\t.cable_detect\t\t= ata_cable_unknown,\n\t.set_piomode\t\t= pata_imx_set_piomode,\n};\n\nstatic void pata_imx_setup_port(struct ata_ioports *ioaddr)\n{\n\t \n\tioaddr->data_addr\t= ioaddr->cmd_addr + (ATA_REG_DATA    << 2);\n\tioaddr->error_addr\t= ioaddr->cmd_addr + (ATA_REG_ERR     << 2);\n\tioaddr->feature_addr\t= ioaddr->cmd_addr + (ATA_REG_FEATURE << 2);\n\tioaddr->nsect_addr\t= ioaddr->cmd_addr + (ATA_REG_NSECT   << 2);\n\tioaddr->lbal_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAL    << 2);\n\tioaddr->lbam_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAM    << 2);\n\tioaddr->lbah_addr\t= ioaddr->cmd_addr + (ATA_REG_LBAH    << 2);\n\tioaddr->device_addr\t= ioaddr->cmd_addr + (ATA_REG_DEVICE  << 2);\n\tioaddr->status_addr\t= ioaddr->cmd_addr + (ATA_REG_STATUS  << 2);\n\tioaddr->command_addr\t= ioaddr->cmd_addr + (ATA_REG_CMD     << 2);\n}\n\nstatic int pata_imx_probe(struct platform_device *pdev)\n{\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tstruct pata_imx_priv *priv;\n\tint irq = 0;\n\tstruct resource *io_res;\n\tint ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct pata_imx_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get and enable clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->private_data = priv;\n\tap = host->ports[0];\n\n\tap->ops = &pata_imx_port_ops;\n\tap->pio_mask = ATA_PIO4;\n\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\n\tpriv->host_regs = devm_platform_get_and_ioremap_resource(pdev, 0, &io_res);\n\tif (IS_ERR(priv->host_regs))\n\t\treturn PTR_ERR(priv->host_regs);\n\n\tap->ioaddr.cmd_addr = priv->host_regs + PATA_IMX_DRIVE_DATA;\n\tap->ioaddr.ctl_addr = priv->host_regs + PATA_IMX_DRIVE_CONTROL;\n\n\tap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\n\n\tpata_imx_setup_port(&ap->ioaddr);\n\n\tata_port_desc(ap, \"cmd 0x%llx ctl 0x%llx\",\n\t\t(unsigned long long)io_res->start + PATA_IMX_DRIVE_DATA,\n\t\t(unsigned long long)io_res->start + PATA_IMX_DRIVE_CONTROL);\n\n\t \n\t__raw_writel(PATA_IMX_ATA_CTRL_FIFO_RST_B |\n\t\t\tPATA_IMX_ATA_CTRL_ATA_RST_B,\n\t\t\tpriv->host_regs + PATA_IMX_ATA_CONTROL);\n\t \n\t__raw_writel(PATA_IMX_ATA_INTR_ATA_INTRQ2,\n\t\t\tpriv->host_regs + PATA_IMX_ATA_INT_EN);\n\n\t \n\tret = ata_host_activate(host, irq, ata_sff_interrupt, 0,\n\t\t\t\t&pata_imx_sht);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void pata_imx_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct pata_imx_priv *priv = host->private_data;\n\n\tata_host_detach(host);\n\n\t__raw_writel(0, priv->host_regs + PATA_IMX_ATA_INT_EN);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pata_imx_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct pata_imx_priv *priv = host->private_data;\n\n\tata_host_suspend(host, PMSG_SUSPEND);\n\n\t__raw_writel(0, priv->host_regs + PATA_IMX_ATA_INT_EN);\n\tpriv->ata_ctl = __raw_readl(priv->host_regs + PATA_IMX_ATA_CONTROL);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int pata_imx_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct pata_imx_priv *priv = host->private_data;\n\n\tint ret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t__raw_writel(priv->ata_ctl, priv->host_regs + PATA_IMX_ATA_CONTROL);\n\n\t__raw_writel(PATA_IMX_ATA_INTR_ATA_INTRQ2,\n\t\t\tpriv->host_regs + PATA_IMX_ATA_INT_EN);\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pata_imx_pm_ops, pata_imx_suspend, pata_imx_resume);\n\nstatic const struct of_device_id imx_pata_dt_ids[] = {\n\t{\n\t\t.compatible = \"fsl,imx27-pata\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, imx_pata_dt_ids);\n\nstatic struct platform_driver pata_imx_driver = {\n\t.probe\t\t= pata_imx_probe,\n\t.remove_new\t= pata_imx_remove,\n\t.driver = {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= imx_pata_dt_ids,\n\t\t.pm\t\t= &pata_imx_pm_ops,\n\t},\n};\n\nmodule_platform_driver(pata_imx_driver);\n\nMODULE_AUTHOR(\"Arnaud Patard <arnaud.patard@rtp-net.org>\");\nMODULE_DESCRIPTION(\"low-level driver for iMX PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}