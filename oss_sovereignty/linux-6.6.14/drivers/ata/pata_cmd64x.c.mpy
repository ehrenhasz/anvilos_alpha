{
  "module_name": "pata_cmd64x.c",
  "hash_id": "24c8f4fc23899c5de5b8959878cf0ecc5e33a86825ea454229c679274405d46b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_cmd64x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_cmd64x\"\n#define DRV_VERSION \"0.2.18\"\n\n \n\nenum {\n\tCFR \t\t= 0x50,\n\t\tCFR_INTR_CH0  = 0x04,\n\tCNTRL\t\t= 0x51,\n\t\tCNTRL_CH0     = 0x04,\n\t\tCNTRL_CH1     = 0x08,\n\tCMDTIM \t\t= 0x52,\n\tARTTIM0 \t= 0x53,\n\tDRWTIM0 \t= 0x54,\n\tARTTIM1 \t= 0x55,\n\tDRWTIM1 \t= 0x56,\n\tARTTIM23 \t= 0x57,\n\t\tARTTIM23_DIS_RA2  = 0x04,\n\t\tARTTIM23_DIS_RA3  = 0x08,\n\t\tARTTIM23_INTR_CH1 = 0x10,\n\tDRWTIM2 \t= 0x58,\n\tBRST \t\t= 0x59,\n\tDRWTIM3 \t= 0x5b,\n\tBMIDECR0\t= 0x70,\n\tMRDMODE\t\t= 0x71,\n\t\tMRDMODE_INTR_CH0 = 0x04,\n\t\tMRDMODE_INTR_CH1 = 0x08,\n\tBMIDESR0\t= 0x72,\n\tUDIDETCR0\t= 0x73,\n\tDTPR0\t\t= 0x74,\n\tBMIDECR1\t= 0x78,\n\tBMIDECSR\t= 0x79,\n\tUDIDETCR1\t= 0x7B,\n\tDTPR1\t\t= 0x7C\n};\n\nstatic int cmd648_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 r;\n\n\t \n\tpci_read_config_byte(pdev, BMIDECSR, &r);\n\tif (r & (1 << ap->port_no))\n\t\treturn ATA_CBL_PATA80;\n\treturn ATA_CBL_PATA40;\n}\n\n \n\nstatic void cmd64x_set_timing(struct ata_port *ap, struct ata_device *adev, u8 mode)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct ata_timing t;\n\tconst unsigned long T = 1000000 / 33;\n\tconst u8 setup_data[] = { 0x40, 0x40, 0x40, 0x80, 0x00 };\n\n\tu8 reg;\n\n\t \n\tconst u8 arttim_port[2][2] = {\n\t\t{ ARTTIM0, ARTTIM1 },\n\t\t{ ARTTIM23, ARTTIM23 }\n\t};\n\tconst u8 drwtim_port[2][2] = {\n\t\t{ DRWTIM0, DRWTIM1 },\n\t\t{ DRWTIM2, DRWTIM3 }\n\t};\n\n\tint arttim = arttim_port[ap->port_no][adev->devno];\n\tint drwtim = drwtim_port[ap->port_no][adev->devno];\n\n\t \n\tif (ata_timing_compute(adev, mode, &t, T, 0) < 0) {\n\t\tata_dev_err(adev, DRV_NAME \": mode computation failed.\\n\");\n\t\treturn;\n\t}\n\tif (ap->port_no) {\n\t\t \n\t\tstruct ata_device *pair = ata_dev_pair(adev);\n\n\t\tif (pair) {\n\t\t\tstruct ata_timing tp;\n\t\t\tata_timing_compute(pair, pair->pio_mode, &tp, T, 0);\n\t\t\tata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\n\t\t}\n\t}\n\n\tata_dev_dbg(adev, DRV_NAME \": active %d recovery %d setup %d.\\n\",\n\t\tt.active, t.recover, t.setup);\n\tif (t.recover > 16) {\n\t\tt.active += t.recover - 16;\n\t\tt.recover = 16;\n\t}\n\tif (t.active > 16)\n\t\tt.active = 16;\n\n\t \n\n\tif (t.recover == 16)\n\t\tt.recover = 0;\n\telse if (t.recover > 1)\n\t\tt.recover--;\n\telse\n\t\tt.recover = 15;\n\n\tif (t.setup > 4)\n\t\tt.setup = 0xC0;\n\telse\n\t\tt.setup = setup_data[t.setup];\n\n\tt.active &= 0x0F;\t \n\n\t \n\tpci_read_config_byte(pdev, arttim, &reg);\n\treg &= 0x3F;\n\treg |= t.setup;\n\tpci_write_config_byte(pdev, arttim, reg);\n\n\t \n\tpci_write_config_byte(pdev, drwtim, (t.active << 4) | t.recover);\n}\n\n \n\nstatic void cmd64x_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tcmd64x_set_timing(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void cmd64x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic const u8 udma_data[] = {\n\t\t0x30, 0x20, 0x10, 0x20, 0x10, 0x00\n\t};\n\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 regU, regD;\n\n\tint pciU = UDIDETCR0 + 8 * ap->port_no;\n\tint pciD = BMIDESR0 + 8 * ap->port_no;\n\tint shift = 2 * adev->devno;\n\n\tpci_read_config_byte(pdev, pciD, &regD);\n\tpci_read_config_byte(pdev, pciU, &regU);\n\n\t \n\tregD &= ~(0x20 << adev->devno);\n\t \n\tregU &= ~(0x30 << shift);\n\t \n\tregU &= ~(0x05 << adev->devno);\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\t \n\t\tregU |= udma_data[adev->dma_mode - XFER_UDMA_0] << shift;\n\t\t \n\t\tregU |= 1 << adev->devno;  \n\t\tif (adev->dma_mode > XFER_UDMA_2)  \n\t\t\tregU |= 4 << adev->devno;\n\t} else {\n\t\tregU &= ~ (1 << adev->devno);\t \n\t\tcmd64x_set_timing(ap, adev, adev->dma_mode);\n\t}\n\n\tregD |= 0x20 << adev->devno;\n\n\tpci_write_config_byte(pdev, pciU, regU);\n\tpci_write_config_byte(pdev, pciD, regD);\n}\n\n \n\nstatic bool cmd64x_sff_irq_check(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint irq_mask = ap->port_no ? ARTTIM23_INTR_CH1 : CFR_INTR_CH0;\n\tint irq_reg  = ap->port_no ? ARTTIM23 : CFR;\n\tu8 irq_stat;\n\n\t \n\tpci_read_config_byte(pdev, irq_reg, &irq_stat);\n\n\treturn irq_stat & irq_mask;\n}\n\n \n\nstatic void cmd64x_sff_irq_clear(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint irq_reg = ap->port_no ? ARTTIM23 : CFR;\n\tu8 irq_stat;\n\n\tata_bmdma_irq_clear(ap);\n\n\t \n\tpci_read_config_byte(pdev, irq_reg, &irq_stat);\n}\n\n \n\nstatic bool cmd648_sff_irq_check(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tunsigned long base = pci_resource_start(pdev, 4);\n\tint irq_mask = ap->port_no ? MRDMODE_INTR_CH1 : MRDMODE_INTR_CH0;\n\tu8 mrdmode = inb(base + 1);\n\n\treturn mrdmode & irq_mask;\n}\n\n \n\nstatic void cmd648_sff_irq_clear(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tunsigned long base = pci_resource_start(pdev, 4);\n\tint irq_mask = ap->port_no ? MRDMODE_INTR_CH1 : MRDMODE_INTR_CH0;\n\tu8 mrdmode;\n\n\tata_bmdma_irq_clear(ap);\n\n\t \n\tmrdmode  = inb(base + 1);\n\tmrdmode &= ~(MRDMODE_INTR_CH0 | MRDMODE_INTR_CH1);\n\toutb(mrdmode | irq_mask, base + 1);\n}\n\n \n\nstatic void cmd646r1_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tata_bmdma_stop(qc);\n}\n\nstatic const struct scsi_host_template cmd64x_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic const struct ata_port_operations cmd64x_base_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.set_piomode\t= cmd64x_set_piomode,\n\t.set_dmamode\t= cmd64x_set_dmamode,\n};\n\nstatic struct ata_port_operations cmd64x_port_ops = {\n\t.inherits\t= &cmd64x_base_ops,\n\t.sff_irq_check\t= cmd64x_sff_irq_check,\n\t.sff_irq_clear\t= cmd64x_sff_irq_clear,\n\t.cable_detect\t= ata_cable_40wire,\n};\n\nstatic struct ata_port_operations cmd646r1_port_ops = {\n\t.inherits\t= &cmd64x_base_ops,\n\t.sff_irq_check\t= cmd64x_sff_irq_check,\n\t.sff_irq_clear\t= cmd64x_sff_irq_clear,\n\t.bmdma_stop\t= cmd646r1_bmdma_stop,\n\t.cable_detect\t= ata_cable_40wire,\n};\n\nstatic struct ata_port_operations cmd646r3_port_ops = {\n\t.inherits\t= &cmd64x_base_ops,\n\t.sff_irq_check\t= cmd648_sff_irq_check,\n\t.sff_irq_clear\t= cmd648_sff_irq_clear,\n\t.cable_detect\t= ata_cable_40wire,\n};\n\nstatic struct ata_port_operations cmd648_port_ops = {\n\t.inherits\t= &cmd64x_base_ops,\n\t.sff_irq_check\t= cmd648_sff_irq_check,\n\t.sff_irq_clear\t= cmd648_sff_irq_clear,\n\t.cable_detect\t= cmd648_cable_detect,\n};\n\nstatic void cmd64x_fixup(struct pci_dev *pdev)\n{\n\tu8 mrdmode;\n\n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 64);\n\tpci_read_config_byte(pdev, MRDMODE, &mrdmode);\n\tmrdmode &= ~0x30;\t \n\tmrdmode |= 0x02;\t \n\tpci_write_config_byte(pdev, MRDMODE, mrdmode);\n\n\t \n#ifdef CONFIG_PPC\n\tpci_write_config_byte(pdev, UDIDETCR0, 0xF0);\n#endif\n}\n\nstatic int cmd64x_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info cmd_info[7] = {\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.port_ops = &cmd64x_port_ops\n\t\t},\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.port_ops = &cmd64x_port_ops\n\t\t},\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.port_ops = &cmd646r3_port_ops\n\t\t},\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA2,\n\t\t\t.port_ops = &cmd646r3_port_ops\n\t\t},\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.port_ops = &cmd646r1_port_ops\n\t\t},\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA4,\n\t\t\t.port_ops = &cmd648_port_ops\n\t\t},\n\t\t{\t \n\t\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t\t.pio_mask = ATA_PIO4,\n\t\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t\t.udma_mask = ATA_UDMA5,\n\t\t\t.port_ops = &cmd648_port_ops\n\t\t}\n\t};\n\tconst struct ata_port_info *ppi[] = {\n\t\t&cmd_info[id->driver_data],\n\t\t&cmd_info[id->driver_data],\n\t\tNULL\n\t};\n\tu8 reg;\n\tint rc;\n\tstruct pci_dev *bridge = pdev->bus->self;\n\t \n\tint port_ok = !(bridge && bridge->vendor ==\n\t\t\tPCI_VENDOR_ID_MOBILITY_ELECTRONICS);\n\t \n\tint cntrl_ch0_ok = (id->driver_data != 0);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (id->driver_data == 0)\t \n\t\tata_pci_bmdma_clear_simplex(pdev);\n\n\tif (pdev->device == PCI_DEVICE_ID_CMD_646)\n\t\tswitch (pdev->revision) {\n\t\t \n\t\tdefault:\n\t\t\tppi[0] = &cmd_info[3];\n\t\t\tppi[1] = &cmd_info[3];\n\t\t\tbreak;\n\t\t \n\t\tcase 3:\n\t\tcase 4:\n\t\t\tppi[0] = &cmd_info[2];\n\t\t\tppi[1] = &cmd_info[2];\n\t\t\tbreak;\n\t\t \n\t\tcase 1:\n\t\t\tppi[0] = &cmd_info[4];\n\t\t\tppi[1] = &cmd_info[4];\n\t\t\tfallthrough;\n\t\t \n\t\tcase 2:\n\t\tcase 0:\n\t\t\tcntrl_ch0_ok = 0;\n\t\t\tbreak;\n\t\t}\n\n\tcmd64x_fixup(pdev);\n\n\t \n\tpci_read_config_byte(pdev, CNTRL, &reg);\n\tif (!port_ok)\n\t\tdev_notice(&pdev->dev, \"Mobility Bridge detected, ignoring CNTRL port enable/disable\\n\");\n\tif (port_ok && cntrl_ch0_ok && !(reg & CNTRL_CH0)) {\n\t\tdev_notice(&pdev->dev, \"Primary port is disabled\\n\");\n\t\tppi[0] = &ata_dummy_port_info;\n\n\t}\n\tif (port_ok && !(reg & CNTRL_CH1)) {\n\t\tdev_notice(&pdev->dev, \"Secondary port is disabled\\n\");\n\t\tppi[1] = &ata_dummy_port_info;\n\t}\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &cmd64x_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cmd64x_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tcmd64x_fixup(pdev);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id cmd64x[] = {\n\t{ PCI_VDEVICE(CMD, PCI_DEVICE_ID_CMD_643), 0 },\n\t{ PCI_VDEVICE(CMD, PCI_DEVICE_ID_CMD_646), 1 },\n\t{ PCI_VDEVICE(CMD, PCI_DEVICE_ID_CMD_648), 5 },\n\t{ PCI_VDEVICE(CMD, PCI_DEVICE_ID_CMD_649), 6 },\n\n\t{ },\n};\n\nstatic struct pci_driver cmd64x_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= cmd64x,\n\t.probe \t\t= cmd64x_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= cmd64x_reinit_one,\n#endif\n};\n\nmodule_pci_driver(cmd64x_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for CMD64x series PATA controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, cmd64x);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}