{
  "module_name": "sata_highbank.c",
  "hash_id": "e412d11b8f5529f476e11923749899b40205ee8fa70b69ddc0c3221696b6be05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_highbank.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/libata.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n\n#include \"ahci.h\"\n\n#define CPHY_MAP(dev, addr) ((((dev) & 0x1f) << 7) | (((addr) >> 9) & 0x7f))\n#define CPHY_ADDR(addr) (((addr) & 0x1ff) << 2)\n#define SERDES_CR_CTL\t\t\t0x80a0\n#define SERDES_CR_ADDR\t\t\t0x80a1\n#define SERDES_CR_DATA\t\t\t0x80a2\n#define CR_BUSY\t\t\t\t0x0001\n#define CR_START\t\t\t0x0001\n#define CR_WR_RDN\t\t\t0x0002\n#define CPHY_TX_INPUT_STS\t\t0x2001\n#define CPHY_RX_INPUT_STS\t\t0x2002\n#define CPHY_SATA_TX_OVERRIDE\t\t0x8000\n#define CPHY_SATA_RX_OVERRIDE\t \t0x4000\n#define CPHY_TX_OVERRIDE\t\t0x2004\n#define CPHY_RX_OVERRIDE\t\t0x2005\n#define SPHY_LANE\t\t\t0x100\n#define SPHY_HALF_RATE\t\t\t0x0001\n#define CPHY_SATA_DPLL_MODE\t\t0x0700\n#define CPHY_SATA_DPLL_SHIFT\t\t8\n#define CPHY_SATA_DPLL_RESET\t\t(1 << 11)\n#define CPHY_SATA_TX_ATTEN\t\t0x1c00\n#define CPHY_SATA_TX_ATTEN_SHIFT\t10\n#define CPHY_PHY_COUNT\t\t\t6\n#define CPHY_LANE_COUNT\t\t\t4\n#define CPHY_PORT_COUNT\t\t\t(CPHY_PHY_COUNT * CPHY_LANE_COUNT)\n\nstatic DEFINE_SPINLOCK(cphy_lock);\n \nstruct phy_lane_info {\n\tvoid __iomem *phy_base;\n\tu8 lane_mapping;\n\tu8 phy_devs;\n\tu8 tx_atten;\n};\nstatic struct phy_lane_info port_data[CPHY_PORT_COUNT];\n\nstatic DEFINE_SPINLOCK(sgpio_lock);\n#define SCLOCK\t\t\t\t0\n#define SLOAD\t\t\t\t1\n#define SDATA\t\t\t\t2\n#define SGPIO_PINS\t\t\t3\n#define SGPIO_PORTS\t\t\t8\n\nstruct ecx_plat_data {\n\tu32\t\tn_ports;\n\t \n\tu32\t\tpre_clocks;\n\tu32\t\tpost_clocks;\n\tstruct gpio_desc *sgpio_gpiod[SGPIO_PINS];\n\tu32\t\tsgpio_pattern;\n\tu32\t\tport_to_sgpio[SGPIO_PORTS];\n};\n\n#define SGPIO_SIGNALS\t\t\t3\n#define ECX_ACTIVITY_BITS\t\t0x300000\n#define ECX_ACTIVITY_SHIFT\t\t0\n#define ECX_LOCATE_BITS\t\t\t0x80000\n#define ECX_LOCATE_SHIFT\t\t1\n#define ECX_FAULT_BITS\t\t\t0x400000\n#define ECX_FAULT_SHIFT\t\t\t2\nstatic inline int sgpio_bit_shift(struct ecx_plat_data *pdata, u32 port,\n\t\t\t\tu32 shift)\n{\n\treturn 1 << (3 * pdata->port_to_sgpio[port] + shift);\n}\n\nstatic void ecx_parse_sgpio(struct ecx_plat_data *pdata, u32 port, u32 state)\n{\n\tif (state & ECX_ACTIVITY_BITS)\n\t\tpdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,\n\t\t\t\t\t\tECX_ACTIVITY_SHIFT);\n\telse\n\t\tpdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,\n\t\t\t\t\t\tECX_ACTIVITY_SHIFT);\n\tif (state & ECX_LOCATE_BITS)\n\t\tpdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,\n\t\t\t\t\t\tECX_LOCATE_SHIFT);\n\telse\n\t\tpdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,\n\t\t\t\t\t\tECX_LOCATE_SHIFT);\n\tif (state & ECX_FAULT_BITS)\n\t\tpdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,\n\t\t\t\t\t\tECX_FAULT_SHIFT);\n\telse\n\t\tpdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,\n\t\t\t\t\t\tECX_FAULT_SHIFT);\n}\n\n \nstatic void ecx_led_cycle_clock(struct ecx_plat_data *pdata)\n{\n\tgpiod_set_value(pdata->sgpio_gpiod[SCLOCK], 1);\n\tudelay(50);\n\tgpiod_set_value(pdata->sgpio_gpiod[SCLOCK], 0);\n\tudelay(50);\n}\n\nstatic ssize_t ecx_transmit_led_message(struct ata_port *ap, u32 state,\n\t\t\t\t\tssize_t size)\n{\n\tstruct ahci_host_priv *hpriv =  ap->host->private_data;\n\tstruct ecx_plat_data *pdata = hpriv->plat_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tunsigned long flags;\n\tint pmp, i;\n\tstruct ahci_em_priv *emp;\n\tu32 sgpio_out;\n\n\t \n\tpmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\n\tif (pmp < EM_MAX_SLOTS)\n\t\temp = &pp->em_priv[pmp];\n\telse\n\t\treturn -EINVAL;\n\n\tif (!(hpriv->em_msg_type & EM_MSG_TYPE_LED))\n\t\treturn size;\n\n\tspin_lock_irqsave(&sgpio_lock, flags);\n\tecx_parse_sgpio(pdata, ap->port_no, state);\n\tsgpio_out = pdata->sgpio_pattern;\n\tfor (i = 0; i < pdata->pre_clocks; i++)\n\t\tecx_led_cycle_clock(pdata);\n\n\tgpiod_set_value(pdata->sgpio_gpiod[SLOAD], 1);\n\tecx_led_cycle_clock(pdata);\n\tgpiod_set_value(pdata->sgpio_gpiod[SLOAD], 0);\n\t \n\tfor (i = 0; i < (SGPIO_SIGNALS * pdata->n_ports); i++) {\n\t\tgpiod_set_value(pdata->sgpio_gpiod[SDATA], sgpio_out & 1);\n\t\tsgpio_out >>= 1;\n\t\tecx_led_cycle_clock(pdata);\n\t}\n\tfor (i = 0; i < pdata->post_clocks; i++)\n\t\tecx_led_cycle_clock(pdata);\n\n\t \n\temp->led_state = state;\n\n\tspin_unlock_irqrestore(&sgpio_lock, flags);\n\treturn size;\n}\n\nstatic void highbank_set_em_messages(struct device *dev,\n\t\t\t\t\tstruct ahci_host_priv *hpriv,\n\t\t\t\t\tstruct ata_port_info *pi)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct ecx_plat_data *pdata = hpriv->plat_data;\n\tint i;\n\n\tfor (i = 0; i < SGPIO_PINS; i++) {\n\t\tstruct gpio_desc *gpiod;\n\n\t\tgpiod = devm_gpiod_get_index(dev, \"calxeda,sgpio\", i,\n\t\t\t\t\t     GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(gpiod)) {\n\t\t\tdev_err(dev, \"failed to get GPIO %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tgpiod_set_consumer_name(gpiod, \"CX SGPIO\");\n\n\t\tpdata->sgpio_gpiod[i] = gpiod;\n\t}\n\tof_property_read_u32_array(np, \"calxeda,led-order\",\n\t\t\t\t\t\tpdata->port_to_sgpio,\n\t\t\t\t\t\tpdata->n_ports);\n\tif (of_property_read_u32(np, \"calxeda,pre-clocks\", &pdata->pre_clocks))\n\t\tpdata->pre_clocks = 0;\n\tif (of_property_read_u32(np, \"calxeda,post-clocks\",\n\t\t\t\t&pdata->post_clocks))\n\t\tpdata->post_clocks = 0;\n\n\t \n\thpriv->em_loc = 0;\n\thpriv->em_buf_sz = 4;\n\thpriv->em_msg_type = EM_MSG_TYPE_LED;\n\tpi->flags |= ATA_FLAG_EM | ATA_FLAG_SW_ACTIVITY;\n}\n\nstatic u32 __combo_phy_reg_read(u8 sata_port, u32 addr)\n{\n\tu32 data;\n\tu8 dev = port_data[sata_port].phy_devs;\n\tspin_lock(&cphy_lock);\n\twritel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);\n\tdata = readl(port_data[sata_port].phy_base + CPHY_ADDR(addr));\n\tspin_unlock(&cphy_lock);\n\treturn data;\n}\n\nstatic void __combo_phy_reg_write(u8 sata_port, u32 addr, u32 data)\n{\n\tu8 dev = port_data[sata_port].phy_devs;\n\tspin_lock(&cphy_lock);\n\twritel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);\n\twritel(data, port_data[sata_port].phy_base + CPHY_ADDR(addr));\n\tspin_unlock(&cphy_lock);\n}\n\nstatic void combo_phy_wait_for_ready(u8 sata_port)\n{\n\twhile (__combo_phy_reg_read(sata_port, SERDES_CR_CTL) & CR_BUSY)\n\t\tudelay(5);\n}\n\nstatic u32 combo_phy_read(u8 sata_port, u32 addr)\n{\n\tcombo_phy_wait_for_ready(sata_port);\n\t__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);\n\t__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_START);\n\tcombo_phy_wait_for_ready(sata_port);\n\treturn __combo_phy_reg_read(sata_port, SERDES_CR_DATA);\n}\n\nstatic void combo_phy_write(u8 sata_port, u32 addr, u32 data)\n{\n\tcombo_phy_wait_for_ready(sata_port);\n\t__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);\n\t__combo_phy_reg_write(sata_port, SERDES_CR_DATA, data);\n\t__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_WR_RDN | CR_START);\n}\n\nstatic void highbank_cphy_disable_overrides(u8 sata_port)\n{\n\tu8 lane = port_data[sata_port].lane_mapping;\n\tu32 tmp;\n\tif (unlikely(port_data[sata_port].phy_base == NULL))\n\t\treturn;\n\ttmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);\n\ttmp &= ~CPHY_SATA_RX_OVERRIDE;\n\tcombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\n}\n\nstatic void cphy_override_tx_attenuation(u8 sata_port, u32 val)\n{\n\tu8 lane = port_data[sata_port].lane_mapping;\n\tu32 tmp;\n\n\tif (val & 0x8)\n\t\treturn;\n\n\ttmp = combo_phy_read(sata_port, CPHY_TX_INPUT_STS + lane * SPHY_LANE);\n\ttmp &= ~CPHY_SATA_TX_OVERRIDE;\n\tcombo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\ttmp |= CPHY_SATA_TX_OVERRIDE;\n\tcombo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\ttmp |= (val << CPHY_SATA_TX_ATTEN_SHIFT) & CPHY_SATA_TX_ATTEN;\n\tcombo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);\n}\n\nstatic void cphy_override_rx_mode(u8 sata_port, u32 val)\n{\n\tu8 lane = port_data[sata_port].lane_mapping;\n\tu32 tmp;\n\ttmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);\n\ttmp &= ~CPHY_SATA_RX_OVERRIDE;\n\tcombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\ttmp |= CPHY_SATA_RX_OVERRIDE;\n\tcombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\ttmp &= ~CPHY_SATA_DPLL_MODE;\n\ttmp |= val << CPHY_SATA_DPLL_SHIFT;\n\tcombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\ttmp |= CPHY_SATA_DPLL_RESET;\n\tcombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\ttmp &= ~CPHY_SATA_DPLL_RESET;\n\tcombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\n\n\tmsleep(15);\n}\n\nstatic void highbank_cphy_override_lane(u8 sata_port)\n{\n\tu8 lane = port_data[sata_port].lane_mapping;\n\tu32 tmp, k = 0;\n\n\tif (unlikely(port_data[sata_port].phy_base == NULL))\n\t\treturn;\n\tdo {\n\t\ttmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS +\n\t\t\t\t\t\tlane * SPHY_LANE);\n\t} while ((tmp & SPHY_HALF_RATE) && (k++ < 1000));\n\tcphy_override_rx_mode(sata_port, 3);\n\tcphy_override_tx_attenuation(sata_port, port_data[sata_port].tx_atten);\n}\n\nstatic int highbank_initialize_phys(struct device *dev, void __iomem *addr)\n{\n\tstruct device_node *sata_node = dev->of_node;\n\tint phy_count = 0, phy, port = 0, i;\n\tvoid __iomem *cphy_base[CPHY_PHY_COUNT] = {};\n\tstruct device_node *phy_nodes[CPHY_PHY_COUNT] = {};\n\tu32 tx_atten[CPHY_PORT_COUNT] = {};\n\n\tmemset(port_data, 0, sizeof(struct phy_lane_info) * CPHY_PORT_COUNT);\n\n\tdo {\n\t\tu32 tmp;\n\t\tstruct of_phandle_args phy_data;\n\t\tif (of_parse_phandle_with_args(sata_node,\n\t\t\t\t\"calxeda,port-phys\", \"#phy-cells\",\n\t\t\t\tport, &phy_data))\n\t\t\tbreak;\n\t\tfor (phy = 0; phy < phy_count; phy++) {\n\t\t\tif (phy_nodes[phy] == phy_data.np)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (phy_nodes[phy] == NULL) {\n\t\t\tphy_nodes[phy] = phy_data.np;\n\t\t\tcphy_base[phy] = of_iomap(phy_nodes[phy], 0);\n\t\t\tif (cphy_base[phy] == NULL) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tphy_count += 1;\n\t\t}\n\t\tport_data[port].lane_mapping = phy_data.args[0];\n\t\tof_property_read_u32(phy_nodes[phy], \"phydev\", &tmp);\n\t\tport_data[port].phy_devs = tmp;\n\t\tport_data[port].phy_base = cphy_base[phy];\n\t\tof_node_put(phy_data.np);\n\t\tport += 1;\n\t} while (port < CPHY_PORT_COUNT);\n\tof_property_read_u32_array(sata_node, \"calxeda,tx-atten\",\n\t\t\t\ttx_atten, port);\n\tfor (i = 0; i < port; i++)\n\t\tport_data[i].tx_atten = (u8) tx_atten[i];\n\treturn 0;\n}\n\n \nstatic int ahci_highbank_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t\tunsigned long deadline)\n{\n\tstatic const unsigned int timing[] = { 5, 100, 500};\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tu32 sstatus;\n\tint rc;\n\tint retry = 100;\n\n\thpriv->stop_engine(ap);\n\n\t \n\tata_tf_init(link->device, &tf);\n\ttf.status = ATA_BUSY;\n\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\tdo {\n\t\thighbank_cphy_disable_overrides(link->ap->port_no);\n\t\trc = sata_link_hardreset(link, timing, deadline, &online, NULL);\n\t\thighbank_cphy_override_lane(link->ap->port_no);\n\n\t\t \n\t\tif (sata_scr_read(link, SCR_STATUS, &sstatus))\n\t\t\tbreak;\n\t\tif (!(sstatus & 0x3))\n\t\t\tbreak;\n\t} while (!online && retry--);\n\n\thpriv->start_engine(ap);\n\n\tif (online)\n\t\t*class = ahci_dev_classify(ap);\n\n\treturn rc;\n}\n\nstatic struct ata_port_operations ahci_highbank_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.hardreset\t\t= ahci_highbank_hardreset,\n\t.transmit_led_message   = ecx_transmit_led_message,\n};\n\nstatic const struct ata_port_info ahci_highbank_port_info = {\n\t.flags          = AHCI_FLAG_COMMON,\n\t.pio_mask       = ATA_PIO4,\n\t.udma_mask      = ATA_UDMA6,\n\t.port_ops       = &ahci_highbank_ops,\n};\n\nstatic const struct scsi_host_template ahci_highbank_platform_sht = {\n\tAHCI_SHT(\"sata_highbank\"),\n};\n\nstatic const struct of_device_id ahci_of_match[] = {\n\t{ .compatible = \"calxeda,hb-ahci\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_of_match);\n\nstatic int ahci_highbank_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct ecx_plat_data *pdata;\n\tstruct ata_host *host;\n\tstruct resource *mem;\n\tint irq;\n\tint i;\n\tint rc;\n\tu32 n_ports;\n\tstruct ata_port_info pi = ahci_highbank_port_info;\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem) {\n\t\tdev_err(dev, \"no mmio space\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\thpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv) {\n\t\tdev_err(dev, \"can't alloc ahci_host_priv\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tdev_err(dev, \"can't alloc ecx_plat_data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thpriv->irq = irq;\n\thpriv->flags |= (unsigned long)pi.private_data;\n\n\thpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));\n\tif (!hpriv->mmio) {\n\t\tdev_err(dev, \"can't map %pR\\n\", mem);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = highbank_initialize_phys(dev, hpriv->mmio);\n\tif (rc)\n\t\treturn rc;\n\n\n\tahci_save_initial_config(dev, hpriv);\n\n\t \n\tif (hpriv->cap & HOST_CAP_NCQ)\n\t\tpi.flags |= ATA_FLAG_NCQ;\n\n\tif (hpriv->cap & HOST_CAP_PMP)\n\t\tpi.flags |= ATA_FLAG_PMP;\n\n\tif (hpriv->cap & HOST_CAP_64)\n\t\tdma_set_coherent_mask(dev, DMA_BIT_MASK(64));\n\n\t \n\tn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\n\n\tpdata->n_ports = n_ports;\n\thpriv->plat_data = pdata;\n\thighbank_set_em_messages(dev, hpriv, &pi);\n\n\thost = ata_host_alloc_pinfo(dev, ppi, n_ports);\n\tif (!host) {\n\t\trc = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\thost->private_data = hpriv;\n\n\tif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\n\t\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tata_port_desc(ap, \"mmio %pR\", mem);\n\t\tata_port_desc(ap, \"port 0x%x\", 0x100 + ap->port_no * 0x80);\n\n\t\t \n\t\tif (ap->flags & ATA_FLAG_EM)\n\t\t\tap->em_message_type = hpriv->em_msg_type;\n\n\t\t \n\t\tif (!(hpriv->port_map & (1 << i)))\n\t\t\tap->ops = &ata_dummy_port_ops;\n\t}\n\n\trc = ahci_reset_controller(host);\n\tif (rc)\n\t\tgoto err0;\n\n\tahci_init_controller(host);\n\tahci_print_info(host, \"platform\");\n\n\trc = ahci_host_activate(host, &ahci_highbank_platform_sht);\n\tif (rc)\n\t\tgoto err0;\n\n\treturn 0;\nerr0:\n\treturn rc;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ahci_highbank_suspend(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 ctl;\n\n\tif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\n\t\tdev_err(dev, \"firmware update required for suspend/resume\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tctl = readl(mmio + HOST_CTL);\n\tctl &= ~HOST_IRQ_EN;\n\twritel(ctl, mmio + HOST_CTL);\n\treadl(mmio + HOST_CTL);  \n\n\tata_host_suspend(host, PMSG_SUSPEND);\n\treturn 0;\n}\n\nstatic int ahci_highbank_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tint rc;\n\n\tif (dev->power.power_state.event == PM_EVENT_SUSPEND) {\n\t\trc = ahci_reset_controller(host);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tahci_init_controller(host);\n\t}\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ahci_highbank_pm_ops,\n\t\t  ahci_highbank_suspend, ahci_highbank_resume);\n\nstatic struct platform_driver ahci_highbank_driver = {\n\t.remove_new = ata_platform_remove_one,\n        .driver = {\n                .name = \"highbank-ahci\",\n                .of_match_table = ahci_of_match,\n                .pm = &ahci_highbank_pm_ops,\n        },\n\t.probe = ahci_highbank_probe,\n};\n\nmodule_platform_driver(ahci_highbank_driver);\n\nMODULE_DESCRIPTION(\"Calxeda Highbank AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Mark Langsdorf <mark.langsdorf@calxeda.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"sata:highbank\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}