{
  "module_name": "pata_pdc2027x.c",
  "hash_id": "4859e9dd898c8e115394930483fd23a861d7ec63f53bb0d3680f68e1125c20af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_pdc2027x.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/ktime.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_pdc2027x\"\n#define DRV_VERSION\t\"1.0\"\n\nenum {\n\tPDC_MMIO_BAR\t\t= 5,\n\n\tPDC_UDMA_100\t\t= 0,\n\tPDC_UDMA_133\t\t= 1,\n\n\tPDC_100_MHZ\t\t= 100000000,\n\tPDC_133_MHZ\t\t= 133333333,\n\n\tPDC_SYS_CTL\t\t= 0x1100,\n\tPDC_ATA_CTL\t\t= 0x1104,\n\tPDC_GLOBAL_CTL\t\t= 0x1108,\n\tPDC_CTCR0\t\t= 0x110C,\n\tPDC_CTCR1\t\t= 0x1110,\n\tPDC_BYTE_COUNT\t\t= 0x1120,\n\tPDC_PLL_CTL\t\t= 0x1202,\n};\n\nstatic int pdc2027x_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\n#ifdef CONFIG_PM_SLEEP\nstatic int pdc2027x_reinit_one(struct pci_dev *pdev);\n#endif\nstatic int pdc2027x_prereset(struct ata_link *link, unsigned long deadline);\nstatic void pdc2027x_set_piomode(struct ata_port *ap, struct ata_device *adev);\nstatic void pdc2027x_set_dmamode(struct ata_port *ap, struct ata_device *adev);\nstatic int pdc2027x_check_atapi_dma(struct ata_queued_cmd *qc);\nstatic unsigned int pdc2027x_mode_filter(struct ata_device *adev, unsigned int mask);\nstatic int pdc2027x_cable_detect(struct ata_port *ap);\nstatic int pdc2027x_set_mode(struct ata_link *link, struct ata_device **r_failed);\n\n \nstatic const struct pdc2027x_pio_timing {\n\tu8 value0, value1, value2;\n} pdc2027x_pio_timing_tbl[] = {\n\t{ 0xfb, 0x2b, 0xac },  \n\t{ 0x46, 0x29, 0xa4 },  \n\t{ 0x23, 0x26, 0x64 },  \n\t{ 0x27, 0x0d, 0x35 },  \n\t{ 0x23, 0x09, 0x25 },  \n};\n\nstatic const struct pdc2027x_mdma_timing {\n\tu8 value0, value1;\n} pdc2027x_mdma_timing_tbl[] = {\n\t{ 0xdf, 0x5f },  \n\t{ 0x6b, 0x27 },  \n\t{ 0x69, 0x25 },  \n};\n\nstatic const struct pdc2027x_udma_timing {\n\tu8 value0, value1, value2;\n} pdc2027x_udma_timing_tbl[] = {\n\t{ 0x4a, 0x0f, 0xd5 },  \n\t{ 0x3a, 0x0a, 0xd0 },  \n\t{ 0x2a, 0x07, 0xcd },  \n\t{ 0x1a, 0x05, 0xcd },  \n\t{ 0x1a, 0x03, 0xcd },  \n\t{ 0x1a, 0x02, 0xcb },  \n\t{ 0x1a, 0x01, 0xcb },  \n};\n\nstatic const struct pci_device_id pdc2027x_pci_tbl[] = {\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20268), PDC_UDMA_100 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20269), PDC_UDMA_133 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20270), PDC_UDMA_100 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20271), PDC_UDMA_133 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20275), PDC_UDMA_133 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20276), PDC_UDMA_133 },\n\t{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20277), PDC_UDMA_133 },\n\n\t{ }\t \n};\n\nstatic struct pci_driver pdc2027x_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= pdc2027x_pci_tbl,\n\t.probe\t\t\t= pdc2027x_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= pdc2027x_reinit_one,\n#endif\n};\n\nstatic const struct scsi_host_template pdc2027x_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations pdc2027x_pata100_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.check_atapi_dma\t= pdc2027x_check_atapi_dma,\n\t.cable_detect\t\t= pdc2027x_cable_detect,\n\t.prereset\t\t= pdc2027x_prereset,\n};\n\nstatic struct ata_port_operations pdc2027x_pata133_ops = {\n\t.inherits\t\t= &pdc2027x_pata100_ops,\n\t.mode_filter\t\t= pdc2027x_mode_filter,\n\t.set_piomode\t\t= pdc2027x_set_piomode,\n\t.set_dmamode\t\t= pdc2027x_set_dmamode,\n\t.set_mode\t\t= pdc2027x_set_mode,\n};\n\nstatic struct ata_port_info pdc2027x_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &pdc2027x_pata100_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &pdc2027x_pata133_ops,\n\t},\n};\n\nMODULE_AUTHOR(\"Andre Hedrick, Frank Tiernan, Albert Lee\");\nMODULE_DESCRIPTION(\"libata driver module for Promise PDC20268 to PDC20277\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, pdc2027x_pci_tbl);\n\n \nstatic inline void __iomem *port_mmio(struct ata_port *ap, unsigned int offset)\n{\n\treturn ap->host->iomap[PDC_MMIO_BAR] + ap->port_no * 0x100 + offset;\n}\n\n \nstatic inline void __iomem *dev_mmio(struct ata_port *ap, struct ata_device *adev, unsigned int offset)\n{\n\tu8 adj = (adev->devno) ? 0x08 : 0x00;\n\treturn port_mmio(ap, offset) + adj;\n}\n\n \nstatic int pdc2027x_cable_detect(struct ata_port *ap)\n{\n\tu32 cgcr;\n\n\t \n\tcgcr = ioread32(port_mmio(ap, PDC_GLOBAL_CTL));\n\tif (cgcr & (1 << 26))\n\t\tgoto cbl40;\n\n\tata_port_dbg(ap, \"No cable or 80-conductor cable\\n\");\n\n\treturn ATA_CBL_PATA80;\ncbl40:\n\tata_port_info(ap, DRV_NAME \":40-conductor cable detected\\n\");\n\treturn ATA_CBL_PATA40;\n}\n\n \nstatic inline int pdc2027x_port_enabled(struct ata_port *ap)\n{\n\treturn ioread8(port_mmio(ap, PDC_ATA_CTL)) & 0x02;\n}\n\n \n\nstatic int pdc2027x_prereset(struct ata_link *link, unsigned long deadline)\n{\n\t \n\tif (!pdc2027x_port_enabled(link->ap))\n\t\treturn -ENOENT;\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic unsigned int pdc2027x_mode_filter(struct ata_device *adev, unsigned int mask)\n{\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\n\tif (adev->class != ATA_DEV_ATA || adev->devno == 0 || pair == NULL)\n\t\treturn mask;\n\n\t \n\tata_id_c_string(pair->id, model_num, ATA_ID_PROD,\n\t\t\t  ATA_ID_PROD_LEN + 1);\n\t \n\tif (strstr(model_num, \"Maxtor\") == NULL && pair->dma_mode == XFER_UDMA_6)\n\t\tmask &= ~ (1 << (6 + ATA_SHIFT_UDMA));\n\n\treturn mask;\n}\n\n \n\nstatic void pdc2027x_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tunsigned int pio = adev->pio_mode - XFER_PIO_0;\n\tu32 ctcr0, ctcr1;\n\n\tata_port_dbg(ap, \"adev->pio_mode[%X]\\n\", adev->pio_mode);\n\n\t \n\tif (pio > 4) {\n\t\tata_port_err(ap, \"Unknown pio mode [%d] ignored\\n\", pio);\n\t\treturn;\n\n\t}\n\n\t \n\tata_port_dbg(ap, \"Set pio regs... \\n\");\n\n\tctcr0 = ioread32(dev_mmio(ap, adev, PDC_CTCR0));\n\tctcr0 &= 0xffff0000;\n\tctcr0 |= pdc2027x_pio_timing_tbl[pio].value0 |\n\t\t(pdc2027x_pio_timing_tbl[pio].value1 << 8);\n\tiowrite32(ctcr0, dev_mmio(ap, adev, PDC_CTCR0));\n\n\tctcr1 = ioread32(dev_mmio(ap, adev, PDC_CTCR1));\n\tctcr1 &= 0x00ffffff;\n\tctcr1 |= (pdc2027x_pio_timing_tbl[pio].value2 << 24);\n\tiowrite32(ctcr1, dev_mmio(ap, adev, PDC_CTCR1));\n\n\tata_port_dbg(ap, \"Set to pio mode[%u] \\n\", pio);\n}\n\n \nstatic void pdc2027x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tunsigned int dma_mode = adev->dma_mode;\n\tu32 ctcr0, ctcr1;\n\n\tif ((dma_mode >= XFER_UDMA_0) &&\n\t   (dma_mode <= XFER_UDMA_6)) {\n\t\t \n\t\tunsigned int udma_mode = dma_mode & 0x07;\n\n\t\tif (dma_mode == XFER_UDMA_2) {\n\t\t\t \n\t\t\tctcr1 = ioread32(dev_mmio(ap, adev, PDC_CTCR1));\n\t\t\tiowrite32(ctcr1 & ~(1 << 7), dev_mmio(ap, adev, PDC_CTCR1));\n\t\t}\n\n\t\tata_port_dbg(ap, \"Set udma regs... \\n\");\n\n\t\tctcr1 = ioread32(dev_mmio(ap, adev, PDC_CTCR1));\n\t\tctcr1 &= 0xff000000;\n\t\tctcr1 |= pdc2027x_udma_timing_tbl[udma_mode].value0 |\n\t\t\t(pdc2027x_udma_timing_tbl[udma_mode].value1 << 8) |\n\t\t\t(pdc2027x_udma_timing_tbl[udma_mode].value2 << 16);\n\t\tiowrite32(ctcr1, dev_mmio(ap, adev, PDC_CTCR1));\n\n\t\tata_port_dbg(ap, \"Set to udma mode[%u] \\n\", udma_mode);\n\n\t} else  if ((dma_mode >= XFER_MW_DMA_0) &&\n\t\t   (dma_mode <= XFER_MW_DMA_2)) {\n\t\t \n\t\tunsigned int mdma_mode = dma_mode & 0x07;\n\n\t\tata_port_dbg(ap, \"Set mdma regs... \\n\");\n\t\tctcr0 = ioread32(dev_mmio(ap, adev, PDC_CTCR0));\n\n\t\tctcr0 &= 0x0000ffff;\n\t\tctcr0 |= (pdc2027x_mdma_timing_tbl[mdma_mode].value0 << 16) |\n\t\t\t(pdc2027x_mdma_timing_tbl[mdma_mode].value1 << 24);\n\n\t\tiowrite32(ctcr0, dev_mmio(ap, adev, PDC_CTCR0));\n\n\t\tata_port_dbg(ap, \"Set to mdma mode[%u] \\n\", mdma_mode);\n\t} else {\n\t\tata_port_err(ap, \"Unknown dma mode [%u] ignored\\n\", dma_mode);\n\t}\n}\n\n \nstatic int pdc2027x_set_mode(struct ata_link *link, struct ata_device **r_failed)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *dev;\n\tint rc;\n\n\trc = ata_do_set_mode(link, r_failed);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tpdc2027x_set_piomode(ap, dev);\n\n\t\t \n\t\tif (dev->xfer_shift == ATA_SHIFT_PIO) {\n\t\t\tu32 ctcr1 = ioread32(dev_mmio(ap, dev, PDC_CTCR1));\n\t\t\tctcr1 |= (1 << 25);\n\t\t\tiowrite32(ctcr1, dev_mmio(ap, dev, PDC_CTCR1));\n\n\t\t\tata_dev_dbg(dev, \"Turn on prefetch\\n\");\n\t\t} else {\n\t\t\tpdc2027x_set_dmamode(ap, dev);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int pdc2027x_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tu8 *scsicmd = cmd->cmnd;\n\tint rc = 1;  \n\n\t \n\tswitch (scsicmd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase READ_6:\n\tcase WRITE_6:\n\tcase 0xad:  \n\tcase 0xbe:  \n\t\t \n\t\trc = 0;\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\n\treturn rc;\n}\n\n \n\nstatic long pdc_read_counter(struct ata_host *host)\n{\n\tvoid __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];\n\tlong counter;\n\tint retry = 1;\n\tu32 bccrl, bccrh, bccrlv, bccrhv;\n\nretry:\n\tbccrl = ioread32(mmio_base + PDC_BYTE_COUNT) & 0x7fff;\n\tbccrh = ioread32(mmio_base + PDC_BYTE_COUNT + 0x100) & 0x7fff;\n\n\t \n\tbccrlv = ioread32(mmio_base + PDC_BYTE_COUNT) & 0x7fff;\n\tbccrhv = ioread32(mmio_base + PDC_BYTE_COUNT + 0x100) & 0x7fff;\n\n\tcounter = (bccrh << 15) | bccrl;\n\n\tdev_dbg(host->dev, \"bccrh [%X] bccrl [%X]\\n\", bccrh,  bccrl);\n\tdev_dbg(host->dev, \"bccrhv[%X] bccrlv[%X]\\n\", bccrhv, bccrlv);\n\n\t \n\tif (retry && !(bccrh == bccrhv && bccrl >= bccrlv)) {\n\t\tretry--;\n\t\tdev_dbg(host->dev, \"rereading counter\\n\");\n\t\tgoto retry;\n\t}\n\n\treturn counter;\n}\n\n \nstatic void pdc_adjust_pll(struct ata_host *host, long pll_clock, unsigned int board_idx)\n{\n\tvoid __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];\n\tu16 pll_ctl;\n\tlong pll_clock_khz = pll_clock / 1000;\n\tlong pout_required = board_idx? PDC_133_MHZ:PDC_100_MHZ;\n\tlong ratio = pout_required / pll_clock_khz;\n\tint F, R;\n\n\t \n\tif (unlikely(pll_clock_khz < 5000L || pll_clock_khz > 70000L)) {\n\t\tdev_err(host->dev, \"Invalid PLL input clock %ldkHz, give up!\\n\",\n\t\t\tpll_clock_khz);\n\t\treturn;\n\t}\n\n\tdev_dbg(host->dev, \"pout_required is %ld\\n\", pout_required);\n\n\t \n\tpll_ctl = ioread16(mmio_base + PDC_PLL_CTL);\n\n\tdev_dbg(host->dev, \"pll_ctl[%X]\\n\", pll_ctl);\n\n\t \n\tif (ratio < 8600L) {  \n\t\t \n\t\tR = 0x0d;\n\t} else if (ratio < 12900L) {  \n\t\t \n\t\tR = 0x08;\n\t} else if (ratio < 16100L) {  \n\t\t \n\t\tR = 0x06;\n\t} else if (ratio < 64000L) {  \n\t\tR = 0x00;\n\t} else {\n\t\t \n\t\tdev_err(host->dev, \"Invalid ratio %ld, give up!\\n\", ratio);\n\t\treturn;\n\t}\n\n\tF = (ratio * (R+2)) / 1000 - 2;\n\n\tif (unlikely(F < 0 || F > 127)) {\n\t\t \n\t\tdev_err(host->dev, \"F[%d] invalid!\\n\", F);\n\t\treturn;\n\t}\n\n\tdev_dbg(host->dev, \"F[%d] R[%d] ratio*1000[%ld]\\n\", F, R, ratio);\n\n\tpll_ctl = (R << 8) | F;\n\n\tdev_dbg(host->dev, \"Writing pll_ctl[%X]\\n\", pll_ctl);\n\n\tiowrite16(pll_ctl, mmio_base + PDC_PLL_CTL);\n\tioread16(mmio_base + PDC_PLL_CTL);  \n\n\t \n\tmsleep(30);\n\n\t \n\tpll_ctl = ioread16(mmio_base + PDC_PLL_CTL);\n\n\tdev_dbg(host->dev, \"pll_ctl[%X]\\n\", pll_ctl);\n\n\treturn;\n}\n\n \nstatic long pdc_detect_pll_input_clock(struct ata_host *host)\n{\n\tvoid __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];\n\tu32 scr;\n\tlong start_count, end_count;\n\tktime_t start_time, end_time;\n\tlong pll_clock, usec_elapsed;\n\n\t \n\tscr = ioread32(mmio_base + PDC_SYS_CTL);\n\tdev_dbg(host->dev, \"scr[%X]\\n\", scr);\n\tiowrite32(scr | (0x01 << 14), mmio_base + PDC_SYS_CTL);\n\tioread32(mmio_base + PDC_SYS_CTL);  \n\n\t \n\tstart_count = pdc_read_counter(host);\n\tstart_time = ktime_get();\n\n\t \n\tmsleep(100);\n\n\t \n\tend_count = pdc_read_counter(host);\n\tend_time = ktime_get();\n\n\t \n\tscr = ioread32(mmio_base + PDC_SYS_CTL);\n\tdev_dbg(host->dev, \"scr[%X]\\n\", scr);\n\tiowrite32(scr & ~(0x01 << 14), mmio_base + PDC_SYS_CTL);\n\tioread32(mmio_base + PDC_SYS_CTL);  \n\n\t \n\tusec_elapsed = (long) ktime_us_delta(end_time, start_time);\n\n\tpll_clock = ((start_count - end_count) & 0x3fffffff) / 100 *\n\t\t(100000000 / usec_elapsed);\n\n\tdev_dbg(host->dev, \"start[%ld] end[%ld] PLL input clock[%ld]HZ\\n\",\n\t\t     start_count, end_count, pll_clock);\n\n\treturn pll_clock;\n}\n\n \nstatic void pdc_hardware_init(struct ata_host *host, unsigned int board_idx)\n{\n\tlong pll_clock;\n\n\t \n\tpll_clock = pdc_detect_pll_input_clock(host);\n\n\tdev_info(host->dev, \"PLL input clock %ld kHz\\n\", pll_clock/1000);\n\n\t \n\tpdc_adjust_pll(host, pll_clock, board_idx);\n}\n\n \nstatic void pdc_ata_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t=\n\tport->data_addr\t\t= base;\n\tport->feature_addr\t=\n\tport->error_addr\t= base + 0x05;\n\tport->nsect_addr\t= base + 0x0a;\n\tport->lbal_addr\t\t= base + 0x0f;\n\tport->lbam_addr\t\t= base + 0x10;\n\tport->lbah_addr\t\t= base + 0x15;\n\tport->device_addr\t= base + 0x1a;\n\tport->command_addr\t=\n\tport->status_addr\t= base + 0x1f;\n\tport->altstatus_addr\t=\n\tport->ctl_addr\t\t= base + 0x81a;\n}\n\n \nstatic int pdc2027x_init_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstatic const unsigned long cmd_offset[] = { 0x17c0, 0x15c0 };\n\tstatic const unsigned long bmdma_offset[] = { 0x1000, 0x1008 };\n\tunsigned int board_idx = (unsigned int) ent->driver_data;\n\tconst struct ata_port_info *ppi[] =\n\t\t{ &pdc2027x_port_info[board_idx], NULL };\n\tstruct ata_host *host;\n\tvoid __iomem *mmio_base;\n\tint i, rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev, 1 << PDC_MMIO_BAR, DRV_NAME);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\tmmio_base = host->iomap[PDC_MMIO_BAR];\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tpdc_ata_setup_port(&ap->ioaddr, mmio_base + cmd_offset[i]);\n\t\tap->ioaddr.bmdma_addr = mmio_base + bmdma_offset[i];\n\n\t\tata_port_pbar_desc(ap, PDC_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, PDC_MMIO_BAR, cmd_offset[i], \"cmd\");\n\t}\n\n\t\n\n\t \n\tpdc_hardware_init(host, board_idx);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\t IRQF_SHARED, &pdc2027x_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pdc2027x_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tunsigned int board_idx;\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pdev->device == PCI_DEVICE_ID_PROMISE_20268 ||\n\t    pdev->device == PCI_DEVICE_ID_PROMISE_20270)\n\t\tboard_idx = PDC_UDMA_100;\n\telse\n\t\tboard_idx = PDC_UDMA_133;\n\n\tpdc_hardware_init(host, board_idx);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nmodule_pci_driver(pdc2027x_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}