{
  "module_name": "libata-sata.c",
  "hash_id": "8645dcd4e6bffa013f6605567187bff95065149dc4fbac42431292084f28059c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-sata.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <linux/libata.h>\n#include <asm/unaligned.h>\n\n#include \"libata.h\"\n#include \"libata-transport.h\"\n\n \nconst unsigned int sata_deb_timing_normal[]\t\t= {   5,  100, 2000 };\nEXPORT_SYMBOL_GPL(sata_deb_timing_normal);\nconst unsigned int sata_deb_timing_hotplug[]\t\t= {  25,  500, 2000 };\nEXPORT_SYMBOL_GPL(sata_deb_timing_hotplug);\nconst unsigned int sata_deb_timing_long[]\t\t= { 100, 2000, 5000 };\nEXPORT_SYMBOL_GPL(sata_deb_timing_long);\n\n \nint sata_scr_valid(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\n\treturn (ap->flags & ATA_FLAG_SATA) && ap->ops->scr_read;\n}\nEXPORT_SYMBOL_GPL(sata_scr_valid);\n\n \nint sata_scr_read(struct ata_link *link, int reg, u32 *val)\n{\n\tif (ata_is_host_link(link)) {\n\t\tif (sata_scr_valid(link))\n\t\t\treturn link->ap->ops->scr_read(link, reg, val);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn sata_pmp_scr_read(link, reg, val);\n}\nEXPORT_SYMBOL_GPL(sata_scr_read);\n\n \nint sata_scr_write(struct ata_link *link, int reg, u32 val)\n{\n\tif (ata_is_host_link(link)) {\n\t\tif (sata_scr_valid(link))\n\t\t\treturn link->ap->ops->scr_write(link, reg, val);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn sata_pmp_scr_write(link, reg, val);\n}\nEXPORT_SYMBOL_GPL(sata_scr_write);\n\n \nint sata_scr_write_flush(struct ata_link *link, int reg, u32 val)\n{\n\tif (ata_is_host_link(link)) {\n\t\tint rc;\n\n\t\tif (sata_scr_valid(link)) {\n\t\t\trc = link->ap->ops->scr_write(link, reg, val);\n\t\t\tif (rc == 0)\n\t\t\t\trc = link->ap->ops->scr_read(link, reg, &val);\n\t\t\treturn rc;\n\t\t}\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn sata_pmp_scr_write(link, reg, val);\n}\nEXPORT_SYMBOL_GPL(sata_scr_write_flush);\n\n \nvoid ata_tf_to_fis(const struct ata_taskfile *tf, u8 pmp, int is_cmd, u8 *fis)\n{\n\tfis[0] = 0x27;\t\t\t \n\tfis[1] = pmp & 0xf;\t\t \n\tif (is_cmd)\n\t\tfis[1] |= (1 << 7);\t \n\n\tfis[2] = tf->command;\n\tfis[3] = tf->feature;\n\n\tfis[4] = tf->lbal;\n\tfis[5] = tf->lbam;\n\tfis[6] = tf->lbah;\n\tfis[7] = tf->device;\n\n\tfis[8] = tf->hob_lbal;\n\tfis[9] = tf->hob_lbam;\n\tfis[10] = tf->hob_lbah;\n\tfis[11] = tf->hob_feature;\n\n\tfis[12] = tf->nsect;\n\tfis[13] = tf->hob_nsect;\n\tfis[14] = 0;\n\tfis[15] = tf->ctl;\n\n\tfis[16] = tf->auxiliary & 0xff;\n\tfis[17] = (tf->auxiliary >> 8) & 0xff;\n\tfis[18] = (tf->auxiliary >> 16) & 0xff;\n\tfis[19] = (tf->auxiliary >> 24) & 0xff;\n}\nEXPORT_SYMBOL_GPL(ata_tf_to_fis);\n\n \n\nvoid ata_tf_from_fis(const u8 *fis, struct ata_taskfile *tf)\n{\n\ttf->status\t= fis[2];\n\ttf->error\t= fis[3];\n\n\ttf->lbal\t= fis[4];\n\ttf->lbam\t= fis[5];\n\ttf->lbah\t= fis[6];\n\ttf->device\t= fis[7];\n\n\ttf->hob_lbal\t= fis[8];\n\ttf->hob_lbam\t= fis[9];\n\ttf->hob_lbah\t= fis[10];\n\n\ttf->nsect\t= fis[12];\n\ttf->hob_nsect\t= fis[13];\n}\nEXPORT_SYMBOL_GPL(ata_tf_from_fis);\n\n \nint sata_link_debounce(struct ata_link *link, const unsigned int *params,\n\t\t       unsigned long deadline)\n{\n\tunsigned int interval = params[0];\n\tunsigned int duration = params[1];\n\tunsigned long last_jiffies, t;\n\tu32 last, cur;\n\tint rc;\n\n\tt = ata_deadline(jiffies, params[2]);\n\tif (time_before(t, deadline))\n\t\tdeadline = t;\n\n\tif ((rc = sata_scr_read(link, SCR_STATUS, &cur)))\n\t\treturn rc;\n\tcur &= 0xf;\n\n\tlast = cur;\n\tlast_jiffies = jiffies;\n\n\twhile (1) {\n\t\tata_msleep(link->ap, interval);\n\t\tif ((rc = sata_scr_read(link, SCR_STATUS, &cur)))\n\t\t\treturn rc;\n\t\tcur &= 0xf;\n\n\t\t \n\t\tif (cur == last) {\n\t\t\tif (cur == 1 && time_before(jiffies, deadline))\n\t\t\t\tcontinue;\n\t\t\tif (time_after(jiffies,\n\t\t\t\t       ata_deadline(last_jiffies, duration)))\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tlast = cur;\n\t\tlast_jiffies = jiffies;\n\n\t\t \n\t\tif (time_after(jiffies, deadline))\n\t\t\treturn -EPIPE;\n\t}\n}\nEXPORT_SYMBOL_GPL(sata_link_debounce);\n\n \nint sata_link_resume(struct ata_link *link, const unsigned int *params,\n\t\t     unsigned long deadline)\n{\n\tint tries = ATA_LINK_RESUME_TRIES;\n\tu32 scontrol, serror;\n\tint rc;\n\n\tif ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))\n\t\treturn rc;\n\n\t \n\tdo {\n\t\tscontrol = (scontrol & 0x0f0) | 0x300;\n\t\tif ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))\n\t\t\treturn rc;\n\t\t \n\t\tif (!(link->flags & ATA_LFLAG_NO_DEBOUNCE_DELAY))\n\t\t\tata_msleep(link->ap, 200);\n\n\t\t \n\t\tif ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))\n\t\t\treturn rc;\n\t} while ((scontrol & 0xf0f) != 0x300 && --tries);\n\n\tif ((scontrol & 0xf0f) != 0x300) {\n\t\tata_link_warn(link, \"failed to resume link (SControl %X)\\n\",\n\t\t\t     scontrol);\n\t\treturn 0;\n\t}\n\n\tif (tries < ATA_LINK_RESUME_TRIES)\n\t\tata_link_warn(link, \"link resume succeeded after %d retries\\n\",\n\t\t\t      ATA_LINK_RESUME_TRIES - tries);\n\n\tif ((rc = sata_link_debounce(link, params, deadline)))\n\t\treturn rc;\n\n\t \n\tif (!(rc = sata_scr_read(link, SCR_ERROR, &serror)))\n\t\trc = sata_scr_write(link, SCR_ERROR, serror);\n\n\treturn rc != -EINVAL ? rc : 0;\n}\nEXPORT_SYMBOL_GPL(sata_link_resume);\n\n \nint sata_link_scr_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t      bool spm_wakeup)\n{\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tbool woken_up = false;\n\tu32 scontrol;\n\tint rc;\n\n\trc = sata_scr_read(link, SCR_CONTROL, &scontrol);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (policy) {\n\tcase ATA_LPM_MAX_POWER:\n\t\t \n\t\tscontrol |= (0x7 << 8);\n\t\t \n\t\tif (spm_wakeup) {\n\t\t\tscontrol |= (0x4 << 12);\n\t\t\twoken_up = true;\n\t\t}\n\t\tbreak;\n\tcase ATA_LPM_MED_POWER:\n\t\t \n\t\tscontrol &= ~(0x1 << 8);\n\t\tscontrol |= (0x6 << 8);\n\t\tbreak;\n\tcase ATA_LPM_MED_POWER_WITH_DIPM:\n\tcase ATA_LPM_MIN_POWER_WITH_PARTIAL:\n\tcase ATA_LPM_MIN_POWER:\n\t\tif (ata_link_nr_enabled(link) > 0) {\n\t\t\t \n\t\t\tscontrol &= ~(0x7 << 8);\n\n\t\t\t \n\t\t\tif (link->ap->host->flags & ATA_HOST_NO_PART)\n\t\t\t\tscontrol |= (0x1 << 8);\n\n\t\t\tif (link->ap->host->flags & ATA_HOST_NO_SSC)\n\t\t\t\tscontrol |= (0x2 << 8);\n\n\t\t\tif (link->ap->host->flags & ATA_HOST_NO_DEVSLP)\n\t\t\t\tscontrol |= (0x4 << 8);\n\t\t} else {\n\t\t\t \n\t\t\tscontrol &= ~0xf;\n\t\t\tscontrol |= (0x1 << 2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\trc = sata_scr_write(link, SCR_CONTROL, scontrol);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (woken_up)\n\t\tmsleep(10);\n\n\t \n\tehc->i.serror &= ~SERR_PHYRDY_CHG;\n\treturn sata_scr_write(link, SCR_ERROR, SERR_PHYRDY_CHG);\n}\nEXPORT_SYMBOL_GPL(sata_link_scr_lpm);\n\nstatic int __sata_set_spd_needed(struct ata_link *link, u32 *scontrol)\n{\n\tstruct ata_link *host_link = &link->ap->link;\n\tu32 limit, target, spd;\n\n\tlimit = link->sata_spd_limit;\n\n\t \n\tif (!ata_is_host_link(link) && host_link->sata_spd)\n\t\tlimit &= (1 << host_link->sata_spd) - 1;\n\n\tif (limit == UINT_MAX)\n\t\ttarget = 0;\n\telse\n\t\ttarget = fls(limit);\n\n\tspd = (*scontrol >> 4) & 0xf;\n\t*scontrol = (*scontrol & ~0xf0) | ((target & 0xf) << 4);\n\n\treturn spd != target;\n}\n\n \nstatic int sata_set_spd_needed(struct ata_link *link)\n{\n\tu32 scontrol;\n\n\tif (sata_scr_read(link, SCR_CONTROL, &scontrol))\n\t\treturn 1;\n\n\treturn __sata_set_spd_needed(link, &scontrol);\n}\n\n \nint sata_set_spd(struct ata_link *link)\n{\n\tu32 scontrol;\n\tint rc;\n\n\tif ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))\n\t\treturn rc;\n\n\tif (!__sata_set_spd_needed(link, &scontrol))\n\t\treturn 0;\n\n\tif ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))\n\t\treturn rc;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(sata_set_spd);\n\n \nint sata_link_hardreset(struct ata_link *link, const unsigned int *timing,\n\t\t\tunsigned long deadline,\n\t\t\tbool *online, int (*check_ready)(struct ata_link *))\n{\n\tu32 scontrol;\n\tint rc;\n\n\tif (online)\n\t\t*online = false;\n\n\tif (sata_set_spd_needed(link)) {\n\t\t \n\t\tif ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))\n\t\t\tgoto out;\n\n\t\tscontrol = (scontrol & 0x0f0) | 0x304;\n\n\t\tif ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))\n\t\t\tgoto out;\n\n\t\tsata_set_spd(link);\n\t}\n\n\t \n\tif ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))\n\t\tgoto out;\n\n\tscontrol = (scontrol & 0x0f0) | 0x301;\n\n\tif ((rc = sata_scr_write_flush(link, SCR_CONTROL, scontrol)))\n\t\tgoto out;\n\n\t \n\tata_msleep(link->ap, 1);\n\n\t \n\trc = sata_link_resume(link, timing, deadline);\n\tif (rc)\n\t\tgoto out;\n\t \n\tif (ata_phys_link_offline(link))\n\t\tgoto out;\n\n\t \n\tif (online)\n\t\t*online = true;\n\n\tif (sata_pmp_supported(link->ap) && ata_is_host_link(link)) {\n\t\t \n\t\tif (check_ready) {\n\t\t\tunsigned long pmp_deadline;\n\n\t\t\tpmp_deadline = ata_deadline(jiffies,\n\t\t\t\t\t\t    ATA_TMOUT_PMP_SRST_WAIT);\n\t\t\tif (time_after(pmp_deadline, deadline))\n\t\t\t\tpmp_deadline = deadline;\n\t\t\tata_wait_ready(link, pmp_deadline, check_ready);\n\t\t}\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tif (check_ready)\n\t\trc = ata_wait_ready(link, deadline, check_ready);\n out:\n\tif (rc && rc != -EAGAIN) {\n\t\t \n\t\tif (online)\n\t\t\t*online = false;\n\t\tata_link_err(link, \"COMRESET failed (errno=%d)\\n\", rc);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(sata_link_hardreset);\n\n \nint ata_qc_complete_multiple(struct ata_port *ap, u64 qc_active)\n{\n\tu64 done_mask, ap_qc_active = ap->qc_active;\n\tint nr_done = 0;\n\n\t \n\tif (ap_qc_active & (1ULL << ATA_TAG_INTERNAL)) {\n\t\tqc_active |= (qc_active & 0x01) << ATA_TAG_INTERNAL;\n\t\tqc_active ^= qc_active & 0x01;\n\t}\n\n\tdone_mask = ap_qc_active ^ qc_active;\n\n\tif (unlikely(done_mask & qc_active)) {\n\t\tata_port_err(ap, \"illegal qc_active transition (%08llx->%08llx)\\n\",\n\t\t\t     ap->qc_active, qc_active);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ap->ops->qc_ncq_fill_rtf)\n\t\tap->ops->qc_ncq_fill_rtf(ap, done_mask);\n\n\twhile (done_mask) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag = __ffs64(done_mask);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (qc) {\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_done++;\n\t\t}\n\t\tdone_mask &= ~(1ULL << tag);\n\t}\n\n\treturn nr_done;\n}\nEXPORT_SYMBOL_GPL(ata_qc_complete_multiple);\n\n \nint ata_slave_link_init(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\n\tWARN_ON(ap->slave_link);\n\tWARN_ON(ap->flags & ATA_FLAG_PMP);\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tata_link_init(ap, link, 1);\n\tap->slave_link = link;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_slave_link_init);\n\n \nbool sata_lpm_ignore_phy_events(struct ata_link *link)\n{\n\tunsigned long lpm_timeout = link->last_lpm_change +\n\t\t\t\t    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);\n\n\t \n\tif (link->lpm_policy > ATA_LPM_MAX_POWER)\n\t\treturn true;\n\n\t \n\tif ((link->flags & ATA_LFLAG_CHANGED) &&\n\t    time_before(jiffies, lpm_timeout))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);\n\nstatic const char *ata_lpm_policy_names[] = {\n\t[ATA_LPM_UNKNOWN]\t\t= \"max_performance\",\n\t[ATA_LPM_MAX_POWER]\t\t= \"max_performance\",\n\t[ATA_LPM_MED_POWER]\t\t= \"medium_power\",\n\t[ATA_LPM_MED_POWER_WITH_DIPM]\t= \"med_power_with_dipm\",\n\t[ATA_LPM_MIN_POWER_WITH_PARTIAL] = \"min_power_with_partial\",\n\t[ATA_LPM_MIN_POWER]\t\t= \"min_power\",\n};\n\nstatic ssize_t ata_scsi_lpm_store(struct device *device,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(device);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tenum ata_lpm_policy policy;\n\tunsigned long flags;\n\n\t \n\tfor (policy = ATA_LPM_MAX_POWER;\n\t     policy < ARRAY_SIZE(ata_lpm_policy_names); policy++) {\n\t\tconst char *name = ata_lpm_policy_names[policy];\n\n\t\tif (strncmp(name, buf, strlen(name)) == 0)\n\t\t\tbreak;\n\t}\n\tif (policy == ARRAY_SIZE(ata_lpm_policy_names))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, &ap->link, ENABLED) {\n\t\t\tif (dev->horkage & ATA_HORKAGE_NOLPM) {\n\t\t\t\tcount = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tap->target_lpm_policy = policy;\n\tata_port_schedule_eh(ap);\nout_unlock:\n\tspin_unlock_irqrestore(ap->lock, flags);\n\treturn count;\n}\n\nstatic ssize_t ata_scsi_lpm_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\n\tif (ap->target_lpm_policy >= ARRAY_SIZE(ata_lpm_policy_names))\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\tata_lpm_policy_names[ap->target_lpm_policy]);\n}\nDEVICE_ATTR(link_power_management_policy, S_IRUGO | S_IWUSR,\n\t    ata_scsi_lpm_show, ata_scsi_lpm_store);\nEXPORT_SYMBOL_GPL(dev_attr_link_power_management_policy);\n\nstatic ssize_t ata_ncq_prio_supported_show(struct device *device,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(device);\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct ata_device *dev;\n\tbool ncq_prio_supported;\n\tint rc = 0;\n\n\tspin_lock_irq(ap->lock);\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (!dev)\n\t\trc = -ENODEV;\n\telse\n\t\tncq_prio_supported = dev->flags & ATA_DFLAG_NCQ_PRIO;\n\tspin_unlock_irq(ap->lock);\n\n\treturn rc ? rc : sysfs_emit(buf, \"%u\\n\", ncq_prio_supported);\n}\n\nDEVICE_ATTR(ncq_prio_supported, S_IRUGO, ata_ncq_prio_supported_show, NULL);\nEXPORT_SYMBOL_GPL(dev_attr_ncq_prio_supported);\n\nstatic ssize_t ata_ncq_prio_enable_show(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(device);\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct ata_device *dev;\n\tbool ncq_prio_enable;\n\tint rc = 0;\n\n\tspin_lock_irq(ap->lock);\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (!dev)\n\t\trc = -ENODEV;\n\telse\n\t\tncq_prio_enable = dev->flags & ATA_DFLAG_NCQ_PRIO_ENABLED;\n\tspin_unlock_irq(ap->lock);\n\n\treturn rc ? rc : sysfs_emit(buf, \"%u\\n\", ncq_prio_enable);\n}\n\nstatic ssize_t ata_ncq_prio_enable_store(struct device *device,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tstruct scsi_device *sdev = to_scsi_device(device);\n\tstruct ata_port *ap;\n\tstruct ata_device *dev;\n\tlong int input;\n\tint rc = 0;\n\n\trc = kstrtol(buf, 10, &input);\n\tif (rc)\n\t\treturn rc;\n\tif ((input < 0) || (input > 1))\n\t\treturn -EINVAL;\n\n\tap = ata_shost_to_port(sdev->host);\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (unlikely(!dev))\n\t\treturn  -ENODEV;\n\n\tspin_lock_irq(ap->lock);\n\n\tif (!(dev->flags & ATA_DFLAG_NCQ_PRIO)) {\n\t\trc = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (input) {\n\t\tif (dev->flags & ATA_DFLAG_CDL_ENABLED) {\n\t\t\tata_dev_err(dev,\n\t\t\t\t\"CDL must be disabled to enable NCQ priority\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tdev->flags |= ATA_DFLAG_NCQ_PRIO_ENABLED;\n\t} else {\n\t\tdev->flags &= ~ATA_DFLAG_NCQ_PRIO_ENABLED;\n\t}\n\nunlock:\n\tspin_unlock_irq(ap->lock);\n\n\treturn rc ? rc : len;\n}\n\nDEVICE_ATTR(ncq_prio_enable, S_IRUGO | S_IWUSR,\n\t    ata_ncq_prio_enable_show, ata_ncq_prio_enable_store);\nEXPORT_SYMBOL_GPL(dev_attr_ncq_prio_enable);\n\nstatic struct attribute *ata_ncq_sdev_attrs[] = {\n\t&dev_attr_unload_heads.attr,\n\t&dev_attr_ncq_prio_enable.attr,\n\t&dev_attr_ncq_prio_supported.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ata_ncq_sdev_attr_group = {\n\t.attrs = ata_ncq_sdev_attrs\n};\n\nconst struct attribute_group *ata_ncq_sdev_groups[] = {\n\t&ata_ncq_sdev_attr_group,\n\tNULL\n};\nEXPORT_SYMBOL_GPL(ata_ncq_sdev_groups);\n\nstatic ssize_t\nata_scsi_em_message_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tif (ap->ops->em_store && (ap->flags & ATA_FLAG_EM))\n\t\treturn ap->ops->em_store(ap, buf, count);\n\treturn -EINVAL;\n}\n\nstatic ssize_t\nata_scsi_em_message_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\n\tif (ap->ops->em_show && (ap->flags & ATA_FLAG_EM))\n\t\treturn ap->ops->em_show(ap, buf);\n\treturn -EINVAL;\n}\nDEVICE_ATTR(em_message, S_IRUGO | S_IWUSR,\n\t\tata_scsi_em_message_show, ata_scsi_em_message_store);\nEXPORT_SYMBOL_GPL(dev_attr_em_message);\n\nstatic ssize_t\nata_scsi_em_message_type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ap->em_message_type);\n}\nDEVICE_ATTR(em_message_type, S_IRUGO,\n\t\t  ata_scsi_em_message_type_show, NULL);\nEXPORT_SYMBOL_GPL(dev_attr_em_message_type);\n\nstatic ssize_t\nata_scsi_activity_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct ata_device *atadev = ata_scsi_find_dev(ap, sdev);\n\n\tif (atadev && ap->ops->sw_activity_show &&\n\t    (ap->flags & ATA_FLAG_SW_ACTIVITY))\n\t\treturn ap->ops->sw_activity_show(atadev, buf);\n\treturn -EINVAL;\n}\n\nstatic ssize_t\nata_scsi_activity_store(struct device *dev, struct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct ata_device *atadev = ata_scsi_find_dev(ap, sdev);\n\tenum sw_activity val;\n\tint rc;\n\n\tif (atadev && ap->ops->sw_activity_store &&\n\t    (ap->flags & ATA_FLAG_SW_ACTIVITY)) {\n\t\tval = simple_strtoul(buf, NULL, 0);\n\t\tswitch (val) {\n\t\tcase OFF: case BLINK_ON: case BLINK_OFF:\n\t\t\trc = ap->ops->sw_activity_store(atadev, val);\n\t\t\tif (!rc)\n\t\t\t\treturn count;\n\t\t\telse\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\nDEVICE_ATTR(sw_activity, S_IWUSR | S_IRUGO, ata_scsi_activity_show,\n\t\t\tata_scsi_activity_store);\nEXPORT_SYMBOL_GPL(dev_attr_sw_activity);\n\n \nint ata_change_queue_depth(struct ata_port *ap, struct scsi_device *sdev,\n\t\t\t   int queue_depth)\n{\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\tint max_queue_depth;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (!dev || queue_depth < 1 || queue_depth == sdev->queue_depth) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn sdev->queue_depth;\n\t}\n\n\t \n\tmax_queue_depth = min(ATA_MAX_QUEUE, sdev->host->can_queue);\n\tmax_queue_depth = min(max_queue_depth, ata_id_queue_depth(dev->id));\n\tif (queue_depth > max_queue_depth) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (queue_depth == 1 || !ata_ncq_supported(dev)) {\n\t\tdev->flags |= ATA_DFLAG_NCQ_OFF;\n\t\tqueue_depth = 1;\n\t} else {\n\t\tdev->flags &= ~ATA_DFLAG_NCQ_OFF;\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tif (queue_depth == sdev->queue_depth)\n\t\treturn sdev->queue_depth;\n\n\treturn scsi_change_queue_depth(sdev, queue_depth);\n}\nEXPORT_SYMBOL_GPL(ata_change_queue_depth);\n\n \nint ata_scsi_change_queue_depth(struct scsi_device *sdev, int queue_depth)\n{\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\n\treturn ata_change_queue_depth(ap, sdev, queue_depth);\n}\nEXPORT_SYMBOL_GPL(ata_scsi_change_queue_depth);\n\n \n\nstruct ata_port *ata_sas_port_alloc(struct ata_host *host,\n\t\t\t\t    struct ata_port_info *port_info,\n\t\t\t\t    struct Scsi_Host *shost)\n{\n\tstruct ata_port *ap;\n\n\tap = ata_port_alloc(host);\n\tif (!ap)\n\t\treturn NULL;\n\n\tap->port_no = 0;\n\tap->lock = &host->lock;\n\tap->pio_mask = port_info->pio_mask;\n\tap->mwdma_mask = port_info->mwdma_mask;\n\tap->udma_mask = port_info->udma_mask;\n\tap->flags |= port_info->flags;\n\tap->ops = port_info->port_ops;\n\tap->cbl = ATA_CBL_SATA;\n\tap->print_id = atomic_inc_return(&ata_print_id);\n\n\treturn ap;\n}\nEXPORT_SYMBOL_GPL(ata_sas_port_alloc);\n\nint ata_sas_tport_add(struct device *parent, struct ata_port *ap)\n{\n\treturn ata_tport_add(parent, ap);\n}\nEXPORT_SYMBOL_GPL(ata_sas_tport_add);\n\nvoid ata_sas_tport_delete(struct ata_port *ap)\n{\n\tata_tport_delete(ap);\n}\nEXPORT_SYMBOL_GPL(ata_sas_tport_delete);\n\n \n\nint ata_sas_slave_configure(struct scsi_device *sdev, struct ata_port *ap)\n{\n\tata_scsi_sdev_config(sdev);\n\tata_scsi_dev_config(sdev, ap->link.device);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_sas_slave_configure);\n\n \n\nint ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap)\n{\n\tint rc = 0;\n\n\tif (likely(ata_dev_enabled(ap->link.device)))\n\t\trc = __ata_scsi_queuecmd(cmd, ap->link.device);\n\telse {\n\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\tscsi_done(cmd);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_sas_queuecmd);\n\n \nint sata_async_notification(struct ata_port *ap)\n{\n\tu32 sntf;\n\tint rc;\n\n\tif (!(ap->flags & ATA_FLAG_AN))\n\t\treturn 0;\n\n\trc = sata_scr_read(&ap->link, SCR_NOTIFICATION, &sntf);\n\tif (rc == 0)\n\t\tsata_scr_write(&ap->link, SCR_NOTIFICATION, sntf);\n\n\tif (!sata_pmp_attached(ap) || rc) {\n\t\t \n\t\tif (!sata_pmp_attached(ap)) {\n\t\t\t \n\t\t\tstruct ata_device *dev = ap->link.device;\n\n\t\t\tif ((dev->class == ATA_DEV_ATAPI) &&\n\t\t\t    (dev->flags & ATA_DFLAG_AN))\n\t\t\t\tata_scsi_media_change_notify(dev);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tata_port_schedule_eh(ap);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t \n\t\tstruct ata_link *link;\n\n\t\t \n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\tif (!(sntf & (1 << link->pmp)))\n\t\t\t\tcontinue;\n\n\t\t\tif ((link->device->class == ATA_DEV_ATAPI) &&\n\t\t\t    (link->device->flags & ATA_DFLAG_AN))\n\t\t\t\tata_scsi_media_change_notify(link->device);\n\t\t}\n\n\t\t \n\t\tif (sntf & (1 << SATA_PMP_CTRL_PORT)) {\n\t\t\tata_port_schedule_eh(ap);\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(sata_async_notification);\n\n \nstatic int ata_eh_read_log_10h(struct ata_device *dev,\n\t\t\t       int *tag, struct ata_taskfile *tf)\n{\n\tu8 *buf = dev->link->ap->sector_buf;\n\tunsigned int err_mask;\n\tu8 csum;\n\tint i;\n\n\terr_mask = ata_read_log_page(dev, ATA_LOG_SATA_NCQ, 0, buf, 1);\n\tif (err_mask)\n\t\treturn -EIO;\n\n\tcsum = 0;\n\tfor (i = 0; i < ATA_SECT_SIZE; i++)\n\t\tcsum += buf[i];\n\tif (csum)\n\t\tata_dev_warn(dev, \"invalid checksum 0x%x on log page 10h\\n\",\n\t\t\t     csum);\n\n\tif (buf[0] & 0x80)\n\t\treturn -ENOENT;\n\n\t*tag = buf[0] & 0x1f;\n\n\ttf->status = buf[2];\n\ttf->error = buf[3];\n\ttf->lbal = buf[4];\n\ttf->lbam = buf[5];\n\ttf->lbah = buf[6];\n\ttf->device = buf[7];\n\ttf->hob_lbal = buf[8];\n\ttf->hob_lbam = buf[9];\n\ttf->hob_lbah = buf[10];\n\ttf->nsect = buf[12];\n\ttf->hob_nsect = buf[13];\n\tif (ata_id_has_ncq_autosense(dev->id) && (tf->status & ATA_SENSE))\n\t\ttf->auxiliary = buf[14] << 16 | buf[15] << 8 | buf[16];\n\n\treturn 0;\n}\n\n \nint ata_eh_read_sense_success_ncq_log(struct ata_link *link)\n{\n\tstruct ata_device *dev = link->device;\n\tstruct ata_port *ap = dev->link->ap;\n\tu8 *buf = ap->ncq_sense_buf;\n\tstruct ata_queued_cmd *qc;\n\tunsigned int err_mask, tag;\n\tu8 *sense, sk = 0, asc = 0, ascq = 0;\n\tu64 sense_valid, val;\n\tint ret = 0;\n\n\terr_mask = ata_read_log_page(dev, ATA_LOG_SENSE_NCQ, 0, buf, 2);\n\tif (err_mask) {\n\t\tata_dev_err(dev,\n\t\t\t\"Failed to read Sense Data for Successful NCQ Commands log\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tval = get_unaligned_le64(&buf[0]);\n\tif ((val & 0xffff) != 1 || ((val >> 16) & 0xff) != 0x0f) {\n\t\tata_dev_err(dev,\n\t\t\t\"Invalid Sense Data for Successful NCQ Commands log\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsense_valid = (u64)buf[8] | ((u64)buf[9] << 8) |\n\t\t((u64)buf[10] << 16) | ((u64)buf[11] << 24);\n\n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t\t    !(qc->flags & ATA_QCFLAG_EH_SUCCESS_CMD) ||\n\t\t    qc->err_mask ||\n\t\t    ata_dev_phys_link(qc->dev) != link)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(sense_valid & (1ULL << tag))) {\n\t\t\tqc->result_tf.status &= ~ATA_SENSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsense = &buf[32 + 24 * tag];\n\t\tsk = sense[0];\n\t\tasc = sense[1];\n\t\tascq = sense[2];\n\n\t\tif (!ata_scsi_sense_is_valid(sk, asc, ascq)) {\n\t\t\tret = -EIO;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tscsi_build_sense_buffer(dev->flags & ATA_DFLAG_D_SENSE,\n\t\t\t\t\tqc->scsicmd->sense_buffer, sk,\n\t\t\t\t\tasc, ascq);\n\t\tqc->flags |= ATA_QCFLAG_SENSE_VALID;\n\n\t\t \n\t\tscsi_check_sense(qc->scsicmd);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ata_eh_read_sense_success_ncq_log);\n\n \nvoid ata_eh_analyze_ncq_error(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_device *dev = link->device;\n\tstruct ata_queued_cmd *qc;\n\tstruct ata_taskfile tf;\n\tint tag, rc;\n\n\t \n\tif (ata_port_is_frozen(ap))\n\t\treturn;\n\n\t \n\tif (!link->sactive || !(ehc->i.err_mask & AC_ERR_DEV))\n\t\treturn;\n\n\t \n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH))\n\t\t\tcontinue;\n\n\t\tif (qc->err_mask)\n\t\t\treturn;\n\t}\n\n\t \n\tmemset(&tf, 0, sizeof(tf));\n\trc = ata_eh_read_log_10h(dev, &tag, &tf);\n\tif (rc) {\n\t\tata_link_err(link, \"failed to read log page 10h (errno=%d)\\n\",\n\t\t\t     rc);\n\t\treturn;\n\t}\n\n\tif (!(link->sactive & (1 << tag))) {\n\t\tata_link_err(link, \"log page 10h reported inactive tag %d\\n\",\n\t\t\t     tag);\n\t\treturn;\n\t}\n\n\t \n\tqc = __ata_qc_from_tag(ap, tag);\n\tmemcpy(&qc->result_tf, &tf, sizeof(tf));\n\tqc->result_tf.flags = ATA_TFLAG_ISADDR | ATA_TFLAG_LBA | ATA_TFLAG_LBA48;\n\tqc->err_mask |= AC_ERR_DEV | AC_ERR_NCQ;\n\n\t \n\tif (qc->result_tf.auxiliary) {\n\t\tchar sense_key, asc, ascq;\n\n\t\tsense_key = (qc->result_tf.auxiliary >> 16) & 0xff;\n\t\tasc = (qc->result_tf.auxiliary >> 8) & 0xff;\n\t\tascq = qc->result_tf.auxiliary & 0xff;\n\t\tif (ata_scsi_sense_is_valid(sense_key, asc, ascq)) {\n\t\t\tata_scsi_set_sense(dev, qc->scsicmd, sense_key, asc,\n\t\t\t\t\t   ascq);\n\t\t\tata_scsi_set_sense_information(dev, qc->scsicmd,\n\t\t\t\t\t\t       &qc->result_tf);\n\t\t\tqc->flags |= ATA_QCFLAG_SENSE_VALID;\n\t\t}\n\t}\n\n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t\t    qc->flags & ATA_QCFLAG_EH_SUCCESS_CMD ||\n\t\t    ata_dev_phys_link(qc->dev) != link)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (qc->err_mask)\n\t\t\tcontinue;\n\n\t\t \n\t\tqc->result_tf.status &= ~ATA_ERR;\n\t\tqc->result_tf.error = 0;\n\n\t\t \n\t\tqc->flags |= ATA_QCFLAG_RETRY;\n\t}\n\n\tehc->i.err_mask &= ~AC_ERR_DEV;\n}\nEXPORT_SYMBOL_GPL(ata_eh_analyze_ncq_error);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}