{
  "module_name": "pata_of_platform.c",
  "hash_id": "0dae8fcdc842bc972a5ced363357565ecd15a93214b76b362039e4ba367980e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_of_platform.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/ata_platform.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_of_platform\"\n\nstatic const struct scsi_host_template pata_platform_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic int pata_of_platform_probe(struct platform_device *ofdev)\n{\n\tint ret;\n\tstruct device_node *dn = ofdev->dev.of_node;\n\tstruct resource io_res;\n\tstruct resource ctl_res;\n\tstruct resource irq_res;\n\tunsigned int reg_shift = 0;\n\tint pio_mode = 0;\n\tint pio_mask;\n\tbool use16bit;\n\tint irq;\n\n\tret = of_address_to_resource(dn, 0, &io_res);\n\tif (ret) {\n\t\tdev_err(&ofdev->dev, \"can't get IO address from \"\n\t\t\t\"device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_address_to_resource(dn, 1, &ctl_res);\n\tif (ret) {\n\t\tdev_err(&ofdev->dev, \"can't get CTL address from \"\n\t\t\t\"device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&irq_res, 0, sizeof(irq_res));\n\n\tirq = platform_get_irq_optional(ofdev, 0);\n\tif (irq < 0 && irq != -ENXIO)\n\t\treturn irq;\n\tif (irq > 0) {\n\t\tirq_res.start = irq;\n\t\tirq_res.end = irq;\n\t}\n\n\tof_property_read_u32(dn, \"reg-shift\", &reg_shift);\n\n\tif (!of_property_read_u32(dn, \"pio-mode\", &pio_mode)) {\n\t\tif (pio_mode > 6) {\n\t\t\tdev_err(&ofdev->dev, \"invalid pio-mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tdev_info(&ofdev->dev, \"pio-mode unspecified, assuming PIO0\\n\");\n\t}\n\n\tuse16bit = of_property_read_bool(dn, \"ata-generic,use16bit\");\n\n\tpio_mask = 1 << pio_mode;\n\tpio_mask |= (1 << pio_mode) - 1;\n\n\treturn __pata_platform_probe(&ofdev->dev, &io_res, &ctl_res, irq > 0 ? &irq_res : NULL,\n\t\t\t\t     reg_shift, pio_mask, &pata_platform_sht,\n\t\t\t\t     use16bit);\n}\n\nstatic const struct of_device_id pata_of_platform_match[] = {\n\t{ .compatible = \"ata-generic\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pata_of_platform_match);\n\nstatic struct platform_driver pata_of_platform_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = pata_of_platform_match,\n\t},\n\t.probe\t\t= pata_of_platform_probe,\n\t.remove_new\t= ata_platform_remove_one,\n};\n\nmodule_platform_driver(pata_of_platform_driver);\n\nMODULE_DESCRIPTION(\"OF-platform PATA driver\");\nMODULE_AUTHOR(\"Anton Vorontsov <avorontsov@ru.mvista.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}