{
  "module_name": "pata_ep93xx.c",
  "hash_id": "cfa0c1c490639506e5734e8b31675cca352184c4807d4947afaf6b2d8e4e1c70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_ep93xx.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <scsi/scsi_host.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n#include <linux/platform_device.h>\n#include <linux/sys_soc.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/ktime.h>\n\n#include <linux/platform_data/dma-ep93xx.h>\n#include <linux/soc/cirrus/ep93xx.h>\n\n#define DRV_NAME\t\"ep93xx-ide\"\n#define DRV_VERSION\t\"1.0\"\n\nenum {\n\t \n\tIDECTRL\t\t\t\t= 0x00,\n\tIDECTRL_CS0N\t\t\t= (1 << 0),\n\tIDECTRL_CS1N\t\t\t= (1 << 1),\n\tIDECTRL_DIORN\t\t\t= (1 << 5),\n\tIDECTRL_DIOWN\t\t\t= (1 << 6),\n\tIDECTRL_INTRQ\t\t\t= (1 << 9),\n\tIDECTRL_IORDY\t\t\t= (1 << 10),\n\t \n\tIDECTRL_ADDR_CMD\t\t= 0 + 2,  \n\tIDECTRL_ADDR_DATA\t\t= (ATA_REG_DATA << 2) + 2,\n\tIDECTRL_ADDR_ERROR\t\t= (ATA_REG_ERR << 2) + 2,\n\tIDECTRL_ADDR_FEATURE\t\t= (ATA_REG_FEATURE << 2) + 2,\n\tIDECTRL_ADDR_NSECT\t\t= (ATA_REG_NSECT << 2) + 2,\n\tIDECTRL_ADDR_LBAL\t\t= (ATA_REG_LBAL << 2) + 2,\n\tIDECTRL_ADDR_LBAM\t\t= (ATA_REG_LBAM << 2) + 2,\n\tIDECTRL_ADDR_LBAH\t\t= (ATA_REG_LBAH << 2) + 2,\n\tIDECTRL_ADDR_DEVICE\t\t= (ATA_REG_DEVICE << 2) + 2,\n\tIDECTRL_ADDR_STATUS\t\t= (ATA_REG_STATUS << 2) + 2,\n\tIDECTRL_ADDR_COMMAND\t\t= (ATA_REG_CMD << 2) + 2,\n\tIDECTRL_ADDR_ALTSTATUS\t\t= (0x06 << 2) + 1,  \n\tIDECTRL_ADDR_CTL\t\t= (0x06 << 2) + 1,  \n\n\t \n\tIDECFG\t\t\t\t= 0x04,\n\tIDECFG_IDEEN\t\t\t= (1 << 0),\n\tIDECFG_PIO\t\t\t= (1 << 1),\n\tIDECFG_MDMA\t\t\t= (1 << 2),\n\tIDECFG_UDMA\t\t\t= (1 << 3),\n\tIDECFG_MODE_SHIFT\t\t= 4,\n\tIDECFG_MODE_MASK\t\t= (0xf << 4),\n\tIDECFG_WST_SHIFT\t\t= 8,\n\tIDECFG_WST_MASK\t\t\t= (0x3 << 8),\n\n\t \n\tIDEMDMAOP\t\t\t= 0x08,\n\n\t \n\tIDEUDMAOP\t\t\t= 0x0c,\n\tIDEUDMAOP_UEN\t\t\t= (1 << 0),\n\tIDEUDMAOP_RWOP\t\t\t= (1 << 1),\n\n\t \n\tIDEDATAOUT\t\t\t= 0x10,\n\tIDEDATAIN\t\t\t= 0x14,\n\tIDEMDMADATAOUT\t\t\t= 0x18,\n\tIDEMDMADATAIN\t\t\t= 0x1c,\n\tIDEUDMADATAOUT\t\t\t= 0x20,\n\tIDEUDMADATAIN\t\t\t= 0x24,\n\n\t \n\tIDEUDMASTS\t\t\t= 0x28,\n\tIDEUDMASTS_DMAIDE\t\t= (1 << 16),\n\tIDEUDMASTS_INTIDE\t\t= (1 << 17),\n\tIDEUDMASTS_SBUSY\t\t= (1 << 18),\n\tIDEUDMASTS_NDO\t\t\t= (1 << 24),\n\tIDEUDMASTS_NDI\t\t\t= (1 << 25),\n\tIDEUDMASTS_N4X\t\t\t= (1 << 26),\n\n\t \n\tIDEUDMADEBUG\t\t\t= 0x2c,\n};\n\nstruct ep93xx_pata_data {\n\tconst struct platform_device *pdev;\n\tvoid __iomem *ide_base;\n\tstruct ata_timing t;\n\tbool iordy;\n\n\tunsigned long udma_in_phys;\n\tunsigned long udma_out_phys;\n\n\tstruct dma_chan *dma_rx_channel;\n\tstruct ep93xx_dma_data dma_rx_data;\n\tstruct dma_chan *dma_tx_channel;\n\tstruct ep93xx_dma_data dma_tx_data;\n};\n\nstatic void ep93xx_pata_clear_regs(void __iomem *base)\n{\n\twritel(IDECTRL_CS0N | IDECTRL_CS1N | IDECTRL_DIORN |\n\t\tIDECTRL_DIOWN, base + IDECTRL);\n\n\twritel(0, base + IDECFG);\n\twritel(0, base + IDEMDMAOP);\n\twritel(0, base + IDEUDMAOP);\n\twritel(0, base + IDEDATAOUT);\n\twritel(0, base + IDEDATAIN);\n\twritel(0, base + IDEMDMADATAOUT);\n\twritel(0, base + IDEMDMADATAIN);\n\twritel(0, base + IDEUDMADATAOUT);\n\twritel(0, base + IDEUDMADATAIN);\n\twritel(0, base + IDEUDMADEBUG);\n}\n\nstatic bool ep93xx_pata_check_iordy(void __iomem *base)\n{\n\treturn !!(readl(base + IDECTRL) & IDECTRL_IORDY);\n}\n\n \nstatic int ep93xx_pata_get_wst(int pio_mode)\n{\n\tint val;\n\n\tif (pio_mode == 0)\n\t\tval = 3;\n\telse if (pio_mode < 3)\n\t\tval = 2;\n\telse\n\t\tval = 1;\n\n\treturn val << IDECFG_WST_SHIFT;\n}\n\nstatic void ep93xx_pata_enable_pio(void __iomem *base, int pio_mode)\n{\n\twritel(IDECFG_IDEEN | IDECFG_PIO |\n\t\tep93xx_pata_get_wst(pio_mode) |\n\t\t(pio_mode << IDECFG_MODE_SHIFT), base + IDECFG);\n}\n\n \nstatic void ep93xx_pata_delay(unsigned long count)\n{\n\t__asm__ volatile (\n\t\t\"0:\\n\"\n\t\t\"mov r0, r0\\n\"\n\t\t\"subs %0, %1, #1\\n\"\n\t\t\"bge 0b\\n\"\n\t\t: \"=r\" (count)\n\t\t: \"0\" (count)\n\t);\n}\n\nstatic unsigned long ep93xx_pata_wait_for_iordy(void __iomem *base,\n\t\t\t\t\t\tunsigned long t2)\n{\n\t \n\tunsigned long start = (1250 + 35) / 25 - t2;\n\tunsigned long counter = start;\n\n\twhile (!ep93xx_pata_check_iordy(base) && counter--)\n\t\tep93xx_pata_delay(1);\n\treturn start - counter;\n}\n\n \nstatic void ep93xx_pata_rw_begin(void __iomem *base, unsigned long addr,\n\t\t\t\t unsigned long t1)\n{\n\twritel(IDECTRL_DIOWN | IDECTRL_DIORN | addr, base + IDECTRL);\n\tep93xx_pata_delay(t1);\n}\n\n \nstatic void ep93xx_pata_rw_end(void __iomem *base, unsigned long addr,\n\t\t\t       bool iordy, unsigned long t0, unsigned long t2,\n\t\t\t       unsigned long t2i)\n{\n\tep93xx_pata_delay(t2);\n\t \n\tif (iordy)\n\t\tt2 += ep93xx_pata_wait_for_iordy(base, t2);\n\twritel(IDECTRL_DIOWN | IDECTRL_DIORN | addr, base + IDECTRL);\n\tif (t0 > t2 && t0 - t2 > t2i)\n\t\tep93xx_pata_delay(t0 - t2);\n\telse\n\t\tep93xx_pata_delay(t2i);\n}\n\nstatic u16 ep93xx_pata_read(struct ep93xx_pata_data *drv_data,\n\t\t\t    unsigned long addr,\n\t\t\t    bool reg)\n{\n\tvoid __iomem *base = drv_data->ide_base;\n\tconst struct ata_timing *t = &drv_data->t;\n\tunsigned long t0 = reg ? t->cyc8b : t->cycle;\n\tunsigned long t2 = reg ? t->act8b : t->active;\n\tunsigned long t2i = reg ? t->rec8b : t->recover;\n\n\tep93xx_pata_rw_begin(base, addr, t->setup);\n\twritel(IDECTRL_DIOWN | addr, base + IDECTRL);\n\t \n\tep93xx_pata_rw_end(base, addr, drv_data->iordy, t0, t2, t2i);\n\treturn readl(base + IDEDATAIN);\n}\n\n \nstatic u16 ep93xx_pata_read_reg(struct ep93xx_pata_data *drv_data,\n\t\t\t\tunsigned long addr)\n{\n\treturn ep93xx_pata_read(drv_data, addr, true);\n}\n\n \nstatic u16 ep93xx_pata_read_data(struct ep93xx_pata_data *drv_data,\n\t\t\t\t unsigned long addr)\n{\n\treturn ep93xx_pata_read(drv_data, addr, false);\n}\n\nstatic void ep93xx_pata_write(struct ep93xx_pata_data *drv_data,\n\t\t\t      u16 value, unsigned long addr,\n\t\t\t      bool reg)\n{\n\tvoid __iomem *base = drv_data->ide_base;\n\tconst struct ata_timing *t = &drv_data->t;\n\tunsigned long t0 = reg ? t->cyc8b : t->cycle;\n\tunsigned long t2 = reg ? t->act8b : t->active;\n\tunsigned long t2i = reg ? t->rec8b : t->recover;\n\n\tep93xx_pata_rw_begin(base, addr, t->setup);\n\t \n\twritel(value, base + IDEDATAOUT);\n\twritel(IDECTRL_DIORN | addr, base + IDECTRL);\n\tep93xx_pata_rw_end(base, addr, drv_data->iordy, t0, t2, t2i);\n}\n\n \nstatic void ep93xx_pata_write_reg(struct ep93xx_pata_data *drv_data,\n\t\t\t\t  u16 value, unsigned long addr)\n{\n\tep93xx_pata_write(drv_data, value, addr, true);\n}\n\n \nstatic void ep93xx_pata_write_data(struct ep93xx_pata_data *drv_data,\n\t\t\t\t   u16 value, unsigned long addr)\n{\n\tep93xx_pata_write(drv_data, value, addr, false);\n}\n\nstatic void ep93xx_pata_set_piomode(struct ata_port *ap,\n\t\t\t\t    struct ata_device *adev)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\t \n\tunsigned long T = 1000000 / (200 / 5);\n\n\tata_timing_compute(adev, adev->pio_mode, &drv_data->t, T, 0);\n\tif (pair && pair->pio_mode) {\n\t\tstruct ata_timing t;\n\t\tata_timing_compute(pair, pair->pio_mode, &t, T, 0);\n\t\tata_timing_merge(&t, &drv_data->t, &drv_data->t,\n\t\t\tATA_TIMING_SETUP | ATA_TIMING_8BIT);\n\t}\n\tdrv_data->iordy = ata_pio_need_iordy(adev);\n\n\tep93xx_pata_enable_pio(drv_data->ide_base,\n\t\t\t       adev->pio_mode - XFER_PIO_0);\n}\n\n \nstatic u8 ep93xx_pata_check_status(struct ata_port *ap)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\treturn ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_STATUS);\n}\n\nstatic u8 ep93xx_pata_check_altstatus(struct ata_port *ap)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\treturn ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_ALTSTATUS);\n}\n\n \nstatic void ep93xx_pata_tf_load(struct ata_port *ap,\n\t\t\t\tconst struct ata_taskfile *tf)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\n\n\tif (tf->ctl != ap->last_ctl) {\n\t\tep93xx_pata_write_reg(drv_data, tf->ctl, IDECTRL_ADDR_CTL);\n\t\tap->last_ctl = tf->ctl;\n\t\tata_wait_idle(ap);\n\t}\n\n\tif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\n\t\tep93xx_pata_write_reg(drv_data, tf->hob_feature,\n\t\t\tIDECTRL_ADDR_FEATURE);\n\t\tep93xx_pata_write_reg(drv_data, tf->hob_nsect,\n\t\t\tIDECTRL_ADDR_NSECT);\n\t\tep93xx_pata_write_reg(drv_data, tf->hob_lbal,\n\t\t\tIDECTRL_ADDR_LBAL);\n\t\tep93xx_pata_write_reg(drv_data, tf->hob_lbam,\n\t\t\tIDECTRL_ADDR_LBAM);\n\t\tep93xx_pata_write_reg(drv_data, tf->hob_lbah,\n\t\t\tIDECTRL_ADDR_LBAH);\n\t}\n\n\tif (is_addr) {\n\t\tep93xx_pata_write_reg(drv_data, tf->feature,\n\t\t\tIDECTRL_ADDR_FEATURE);\n\t\tep93xx_pata_write_reg(drv_data, tf->nsect, IDECTRL_ADDR_NSECT);\n\t\tep93xx_pata_write_reg(drv_data, tf->lbal, IDECTRL_ADDR_LBAL);\n\t\tep93xx_pata_write_reg(drv_data, tf->lbam, IDECTRL_ADDR_LBAM);\n\t\tep93xx_pata_write_reg(drv_data, tf->lbah, IDECTRL_ADDR_LBAH);\n\t}\n\n\tif (tf->flags & ATA_TFLAG_DEVICE)\n\t\tep93xx_pata_write_reg(drv_data, tf->device,\n\t\t\tIDECTRL_ADDR_DEVICE);\n\n\tata_wait_idle(ap);\n}\n\n \nstatic void ep93xx_pata_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\ttf->status = ep93xx_pata_check_status(ap);\n\ttf->error = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_FEATURE);\n\ttf->nsect = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_NSECT);\n\ttf->lbal = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAL);\n\ttf->lbam = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAM);\n\ttf->lbah = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAH);\n\ttf->device = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_DEVICE);\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\tep93xx_pata_write_reg(drv_data, tf->ctl | ATA_HOB,\n\t\t\tIDECTRL_ADDR_CTL);\n\t\ttf->hob_feature = ep93xx_pata_read_reg(drv_data,\n\t\t\tIDECTRL_ADDR_FEATURE);\n\t\ttf->hob_nsect = ep93xx_pata_read_reg(drv_data,\n\t\t\tIDECTRL_ADDR_NSECT);\n\t\ttf->hob_lbal = ep93xx_pata_read_reg(drv_data,\n\t\t\tIDECTRL_ADDR_LBAL);\n\t\ttf->hob_lbam = ep93xx_pata_read_reg(drv_data,\n\t\t\tIDECTRL_ADDR_LBAM);\n\t\ttf->hob_lbah = ep93xx_pata_read_reg(drv_data,\n\t\t\tIDECTRL_ADDR_LBAH);\n\t\tep93xx_pata_write_reg(drv_data, tf->ctl, IDECTRL_ADDR_CTL);\n\t\tap->last_ctl = tf->ctl;\n\t}\n}\n\n \nstatic void ep93xx_pata_exec_command(struct ata_port *ap,\n\t\t\t\t     const struct ata_taskfile *tf)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\tep93xx_pata_write_reg(drv_data, tf->command,\n\t\t\t  IDECTRL_ADDR_COMMAND);\n\tata_sff_pause(ap);\n}\n\n \nstatic void ep93xx_pata_dev_select(struct ata_port *ap, unsigned int device)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tu8 tmp = ATA_DEVICE_OBS;\n\n\tif (device != 0)\n\t\ttmp |= ATA_DEV1;\n\n\tep93xx_pata_write_reg(drv_data, tmp, IDECTRL_ADDR_DEVICE);\n\tata_sff_pause(ap);\t \n}\n\n \nstatic void ep93xx_pata_set_devctl(struct ata_port *ap, u8 ctl)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\tep93xx_pata_write_reg(drv_data, ctl, IDECTRL_ADDR_CTL);\n}\n\n \nstatic unsigned int ep93xx_pata_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\t\t  unsigned char *buf,\n\t\t\t\t\t  unsigned int buflen, int rw)\n{\n\tstruct ata_port *ap = qc->dev->link->ap;\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tu16 *data = (u16 *)buf;\n\tunsigned int words = buflen >> 1;\n\n\t \n\twhile (words--)\n\t\tif (rw == READ)\n\t\t\t*data++ = cpu_to_le16(\n\t\t\t\tep93xx_pata_read_data(\n\t\t\t\t\tdrv_data, IDECTRL_ADDR_DATA));\n\t\telse\n\t\t\tep93xx_pata_write_data(drv_data, le16_to_cpu(*data++),\n\t\t\t\tIDECTRL_ADDR_DATA);\n\n\t \n\tif (unlikely(buflen & 0x01)) {\n\t\tunsigned char pad[2] = { };\n\n\t\tbuf += buflen - 1;\n\n\t\tif (rw == READ) {\n\t\t\t*pad = cpu_to_le16(\n\t\t\t\tep93xx_pata_read_data(\n\t\t\t\t\tdrv_data, IDECTRL_ADDR_DATA));\n\t\t\t*buf = pad[0];\n\t\t} else {\n\t\t\tpad[0] = *buf;\n\t\t\tep93xx_pata_write_data(drv_data, le16_to_cpu(*pad),\n\t\t\t\t\t  IDECTRL_ADDR_DATA);\n\t\t}\n\t\twords++;\n\t}\n\n\treturn words << 1;\n}\n\n \nstatic bool ep93xx_pata_device_is_present(struct ata_port *ap,\n\t\t\t\t\t  unsigned int device)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tu8 nsect, lbal;\n\n\tap->ops->sff_dev_select(ap, device);\n\n\tep93xx_pata_write_reg(drv_data, 0x55, IDECTRL_ADDR_NSECT);\n\tep93xx_pata_write_reg(drv_data, 0xaa, IDECTRL_ADDR_LBAL);\n\n\tep93xx_pata_write_reg(drv_data, 0xaa, IDECTRL_ADDR_NSECT);\n\tep93xx_pata_write_reg(drv_data, 0x55, IDECTRL_ADDR_LBAL);\n\n\tep93xx_pata_write_reg(drv_data, 0x55, IDECTRL_ADDR_NSECT);\n\tep93xx_pata_write_reg(drv_data, 0xaa, IDECTRL_ADDR_LBAL);\n\n\tnsect = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_NSECT);\n\tlbal = ep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_LBAL);\n\n\tif ((nsect == 0x55) && (lbal == 0xaa))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int ep93xx_pata_wait_after_reset(struct ata_link *link,\n\t\t\t\t\tunsigned int devmask,\n\t\t\t\t\tunsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tunsigned int dev0 = devmask & (1 << 0);\n\tunsigned int dev1 = devmask & (1 << 1);\n\tint rc, ret = 0;\n\n\tata_msleep(ap, ATA_WAIT_AFTER_RESET);\n\n\t \n\trc = ata_sff_wait_ready(link, deadline);\n\t \n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (dev1) {\n\t\tint i;\n\n\t\tap->ops->sff_dev_select(ap, 1);\n\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tu8 nsect, lbal;\n\n\t\t\tnsect = ep93xx_pata_read_reg(drv_data,\n\t\t\t\tIDECTRL_ADDR_NSECT);\n\t\t\tlbal = ep93xx_pata_read_reg(drv_data,\n\t\t\t\tIDECTRL_ADDR_LBAL);\n\t\t\tif (nsect == 1 && lbal == 1)\n\t\t\t\tbreak;\n\t\t\tmsleep(50);\t \n\t\t}\n\n\t\trc = ata_sff_wait_ready(link, deadline);\n\t\tif (rc) {\n\t\t\tif (rc != -ENODEV)\n\t\t\t\treturn rc;\n\t\t\tret = rc;\n\t\t}\n\t}\n\t \n\tap->ops->sff_dev_select(ap, 0);\n\tif (dev1)\n\t\tap->ops->sff_dev_select(ap, 1);\n\tif (dev0)\n\t\tap->ops->sff_dev_select(ap, 0);\n\n\treturn ret;\n}\n\n \nstatic int ep93xx_pata_bus_softreset(struct ata_port *ap, unsigned int devmask,\n\t\t\t\t     unsigned long deadline)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\tep93xx_pata_write_reg(drv_data, ap->ctl, IDECTRL_ADDR_CTL);\n\tudelay(20);\t\t \n\tep93xx_pata_write_reg(drv_data, ap->ctl | ATA_SRST, IDECTRL_ADDR_CTL);\n\tudelay(20);\t\t \n\tep93xx_pata_write_reg(drv_data, ap->ctl, IDECTRL_ADDR_CTL);\n\tap->last_ctl = ap->ctl;\n\n\treturn ep93xx_pata_wait_after_reset(&ap->link, devmask, deadline);\n}\n\nstatic void ep93xx_pata_release_dma(struct ep93xx_pata_data *drv_data)\n{\n\tif (drv_data->dma_rx_channel) {\n\t\tdma_release_channel(drv_data->dma_rx_channel);\n\t\tdrv_data->dma_rx_channel = NULL;\n\t}\n\tif (drv_data->dma_tx_channel) {\n\t\tdma_release_channel(drv_data->dma_tx_channel);\n\t\tdrv_data->dma_tx_channel = NULL;\n\t}\n}\n\nstatic bool ep93xx_pata_dma_filter(struct dma_chan *chan, void *filter_param)\n{\n\tif (ep93xx_dma_chan_is_m2p(chan))\n\t\treturn false;\n\n\tchan->private = filter_param;\n\treturn true;\n}\n\nstatic void ep93xx_pata_dma_init(struct ep93xx_pata_data *drv_data)\n{\n\tconst struct platform_device *pdev = drv_data->pdev;\n\tdma_cap_mask_t mask;\n\tstruct dma_slave_config conf;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\t \n\tdrv_data->dma_rx_data.port = EP93XX_DMA_IDE;\n\tdrv_data->dma_rx_data.direction = DMA_DEV_TO_MEM;\n\tdrv_data->dma_rx_data.name = \"ep93xx-pata-rx\";\n\tdrv_data->dma_rx_channel = dma_request_channel(mask,\n\t\tep93xx_pata_dma_filter, &drv_data->dma_rx_data);\n\tif (!drv_data->dma_rx_channel)\n\t\treturn;\n\n\tdrv_data->dma_tx_data.port = EP93XX_DMA_IDE;\n\tdrv_data->dma_tx_data.direction = DMA_MEM_TO_DEV;\n\tdrv_data->dma_tx_data.name = \"ep93xx-pata-tx\";\n\tdrv_data->dma_tx_channel = dma_request_channel(mask,\n\t\tep93xx_pata_dma_filter, &drv_data->dma_tx_data);\n\tif (!drv_data->dma_tx_channel) {\n\t\tdma_release_channel(drv_data->dma_rx_channel);\n\t\treturn;\n\t}\n\n\t \n\tmemset(&conf, 0, sizeof(conf));\n\tconf.direction = DMA_DEV_TO_MEM;\n\tconf.src_addr = drv_data->udma_in_phys;\n\tconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tif (dmaengine_slave_config(drv_data->dma_rx_channel, &conf)) {\n\t\tdev_err(&pdev->dev, \"failed to configure rx dma channel\\n\");\n\t\tep93xx_pata_release_dma(drv_data);\n\t\treturn;\n\t}\n\n\t \n\tmemset(&conf, 0, sizeof(conf));\n\tconf.direction = DMA_MEM_TO_DEV;\n\tconf.dst_addr = drv_data->udma_out_phys;\n\tconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tif (dmaengine_slave_config(drv_data->dma_tx_channel, &conf)) {\n\t\tdev_err(&pdev->dev, \"failed to configure tx dma channel\\n\");\n\t\tep93xx_pata_release_dma(drv_data);\n\t}\n}\n\nstatic void ep93xx_pata_dma_start(struct ata_queued_cmd *qc)\n{\n\tstruct dma_async_tx_descriptor *txd;\n\tstruct ep93xx_pata_data *drv_data = qc->ap->host->private_data;\n\tvoid __iomem *base = drv_data->ide_base;\n\tstruct ata_device *adev = qc->dev;\n\tu32 v = qc->dma_dir == DMA_TO_DEVICE ? IDEUDMAOP_RWOP : 0;\n\tstruct dma_chan *channel = qc->dma_dir == DMA_TO_DEVICE\n\t\t? drv_data->dma_tx_channel : drv_data->dma_rx_channel;\n\n\ttxd = dmaengine_prep_slave_sg(channel, qc->sg, qc->n_elem, qc->dma_dir,\n\t\tDMA_CTRL_ACK);\n\tif (!txd) {\n\t\tdev_err(qc->ap->dev, \"failed to prepare slave for sg dma\\n\");\n\t\treturn;\n\t}\n\ttxd->callback = NULL;\n\ttxd->callback_param = NULL;\n\n\tif (dmaengine_submit(txd) < 0) {\n\t\tdev_err(qc->ap->dev, \"failed to submit dma transfer\\n\");\n\t\treturn;\n\t}\n\tdma_async_issue_pending(channel);\n\n\t \n\twritel(v, base + IDEUDMAOP);\n\treadl(base + IDEUDMAOP);\n\twritel(v | IDEUDMAOP_UEN, base + IDEUDMAOP);\n\n\twritel(IDECFG_IDEEN | IDECFG_UDMA |\n\t\t((adev->xfer_mode - XFER_UDMA_0) << IDECFG_MODE_SHIFT),\n\t\tbase + IDECFG);\n}\n\nstatic void ep93xx_pata_dma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ep93xx_pata_data *drv_data = qc->ap->host->private_data;\n\tvoid __iomem *base = drv_data->ide_base;\n\n\t \n\tdmaengine_terminate_all(drv_data->dma_rx_channel);\n\tdmaengine_terminate_all(drv_data->dma_tx_channel);\n\n\t \n\twritel(0, base + IDEUDMAOP);\n\twritel(readl(base + IDECTRL) | IDECTRL_DIOWN | IDECTRL_DIORN |\n\t\tIDECTRL_CS0N | IDECTRL_CS1N, base + IDECTRL);\n\n\tep93xx_pata_enable_pio(drv_data->ide_base,\n\t\tqc->dev->pio_mode - XFER_PIO_0);\n\n\tata_sff_dma_pause(qc->ap);\n}\n\nstatic void ep93xx_pata_dma_setup(struct ata_queued_cmd *qc)\n{\n\tqc->ap->ops->sff_exec_command(qc->ap, &qc->tf);\n}\n\nstatic u8 ep93xx_pata_dma_status(struct ata_port *ap)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\tu32 val = readl(drv_data->ide_base + IDEUDMASTS);\n\n\t \n\tif (val & IDEUDMASTS_NDO || val & IDEUDMASTS_NDI ||\n\t    val & IDEUDMASTS_N4X || val & IDEUDMASTS_INTIDE)\n\t\treturn ATA_DMA_ERR;\n\n\t \n\tif (readl(drv_data->ide_base + IDECTRL) & IDECTRL_INTRQ)\n\t\treturn ATA_DMA_INTR;\n\n\tif (val & IDEUDMASTS_SBUSY || val & IDEUDMASTS_DMAIDE)\n\t\treturn ATA_DMA_ACTIVE;\n\n\treturn 0;\n}\n\n \nstatic int ep93xx_pata_softreset(struct ata_link *al, unsigned int *classes,\n\t\t\t\t unsigned long deadline)\n{\n\tstruct ata_port *ap = al->ap;\n\tunsigned int slave_possible = ap->flags & ATA_FLAG_SLAVE_POSS;\n\tunsigned int devmask = 0;\n\tint rc;\n\tu8 err;\n\n\t \n\tif (ep93xx_pata_device_is_present(ap, 0))\n\t\tdevmask |= (1 << 0);\n\tif (slave_possible && ep93xx_pata_device_is_present(ap, 1))\n\t\tdevmask |= (1 << 1);\n\n\t \n\tap->ops->sff_dev_select(al->ap, 0);\n\n\t \n\trc = ep93xx_pata_bus_softreset(ap, devmask, deadline);\n\t \n\tif (rc && (rc != -ENODEV || sata_scr_valid(al))) {\n\t\tata_link_err(al, \"SRST failed (errno=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tclasses[0] = ata_sff_dev_classify(&al->device[0], devmask & (1 << 0),\n\t\t\t\t\t  &err);\n\tif (slave_possible && err != 0x81)\n\t\tclasses[1] = ata_sff_dev_classify(&al->device[1],\n\t\t\t\t\t\t  devmask & (1 << 1), &err);\n\n\treturn 0;\n}\n\n \nstatic void ep93xx_pata_drain_fifo(struct ata_queued_cmd *qc)\n{\n\tint count;\n\tstruct ata_port *ap;\n\tstruct ep93xx_pata_data *drv_data;\n\n\t \n\tif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\n\t\treturn;\n\n\tap = qc->ap;\n\tdrv_data = ap->host->private_data;\n\t \n\tfor (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ)\n\t\t     && count < 65536; count += 2)\n\t\tep93xx_pata_read_reg(drv_data, IDECTRL_ADDR_DATA);\n\n\tif (count)\n\t\tata_port_dbg(ap, \"drained %d bytes to clear DRQ.\\n\", count);\n\n}\n\nstatic int ep93xx_pata_port_start(struct ata_port *ap)\n{\n\tstruct ep93xx_pata_data *drv_data = ap->host->private_data;\n\n\t \n\tdrv_data->t = *ata_timing_find_mode(XFER_PIO_0);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template ep93xx_pata_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t \n\t.sg_tablesize\t\t= 32,\n\t \n\t.dma_boundary\t\t= 0x7fff,\n};\n\nstatic struct ata_port_operations ep93xx_pata_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\n\t.qc_prep\t\t= ata_noop_qc_prep,\n\n\t.softreset\t\t= ep93xx_pata_softreset,\n\t.hardreset\t\t= ATA_OP_NULL,\n\n\t.sff_dev_select\t\t= ep93xx_pata_dev_select,\n\t.sff_set_devctl\t\t= ep93xx_pata_set_devctl,\n\t.sff_check_status\t= ep93xx_pata_check_status,\n\t.sff_check_altstatus\t= ep93xx_pata_check_altstatus,\n\t.sff_tf_load\t\t= ep93xx_pata_tf_load,\n\t.sff_tf_read\t\t= ep93xx_pata_tf_read,\n\t.sff_exec_command\t= ep93xx_pata_exec_command,\n\t.sff_data_xfer\t\t= ep93xx_pata_data_xfer,\n\t.sff_drain_fifo\t\t= ep93xx_pata_drain_fifo,\n\t.sff_irq_clear\t\t= ATA_OP_NULL,\n\n\t.set_piomode\t\t= ep93xx_pata_set_piomode,\n\n\t.bmdma_setup\t\t= ep93xx_pata_dma_setup,\n\t.bmdma_start\t\t= ep93xx_pata_dma_start,\n\t.bmdma_stop\t\t= ep93xx_pata_dma_stop,\n\t.bmdma_status\t\t= ep93xx_pata_dma_status,\n\n\t.cable_detect\t\t= ata_cable_unknown,\n\t.port_start\t\t= ep93xx_pata_port_start,\n};\n\nstatic const struct soc_device_attribute ep93xx_soc_table[] = {\n\t{ .revision = \"E1\", .data = (void *)ATA_UDMA3 },\n\t{ .revision = \"E2\", .data = (void *)ATA_UDMA4 },\n\t{   }\n};\n\nstatic int ep93xx_pata_probe(struct platform_device *pdev)\n{\n\tstruct ep93xx_pata_data *drv_data;\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tint irq;\n\tstruct resource *mem_res;\n\tvoid __iomem *ide_base;\n\tint err;\n\n\terr = ep93xx_ide_acquire_gpio(pdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto err_rel_gpio;\n\t}\n\n\tide_base = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);\n\tif (IS_ERR(ide_base)) {\n\t\terr = PTR_ERR(ide_base);\n\t\tgoto err_rel_gpio;\n\t}\n\n\tdrv_data = devm_kzalloc(&pdev->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rel_gpio;\n\t}\n\n\tdrv_data->pdev = pdev;\n\tdrv_data->ide_base = ide_base;\n\tdrv_data->udma_in_phys = mem_res->start + IDEUDMADATAIN;\n\tdrv_data->udma_out_phys = mem_res->start + IDEUDMADATAOUT;\n\tep93xx_pata_dma_init(drv_data);\n\n\t \n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rel_dma;\n\t}\n\n\tep93xx_pata_clear_regs(ide_base);\n\n\thost->private_data = drv_data;\n\n\tap = host->ports[0];\n\tap->dev = &pdev->dev;\n\tap->ops = &ep93xx_pata_port_ops;\n\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\tap->pio_mask = ATA_PIO4;\n\n\t \n\tif (drv_data->dma_rx_channel && drv_data->dma_tx_channel) {\n\t\tconst struct soc_device_attribute *match;\n\n\t\tmatch = soc_device_match(ep93xx_soc_table);\n\t\tif (match)\n\t\t\tap->udma_mask = (unsigned int) match->data;\n\t\telse\n\t\t\tap->udma_mask = ATA_UDMA2;\n\t}\n\n\t \n\tep93xx_pata_enable_pio(ide_base, 0);\n\n\tdev_info(&pdev->dev, \"version \" DRV_VERSION \"\\n\");\n\n\t \n\terr = ata_host_activate(host, irq, ata_bmdma_interrupt, 0,\n\t\t&ep93xx_pata_sht);\n\tif (err == 0)\n\t\treturn 0;\n\nerr_rel_dma:\n\tep93xx_pata_release_dma(drv_data);\nerr_rel_gpio:\n\tep93xx_ide_release_gpio(pdev);\n\treturn err;\n}\n\nstatic void ep93xx_pata_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct ep93xx_pata_data *drv_data = host->private_data;\n\n\tata_host_detach(host);\n\tep93xx_pata_release_dma(drv_data);\n\tep93xx_pata_clear_regs(drv_data->ide_base);\n\tep93xx_ide_release_gpio(pdev);\n}\n\nstatic struct platform_driver ep93xx_pata_platform_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = ep93xx_pata_probe,\n\t.remove_new = ep93xx_pata_remove,\n};\n\nmodule_platform_driver(ep93xx_pata_platform_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo, Lennert Buytenhek, Joao Ramos, \"\n\t\t\"Bartlomiej Zolnierkiewicz, Rafal Prylowski\");\nMODULE_DESCRIPTION(\"low-level driver for cirrus ep93xx IDE controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:pata_ep93xx\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}