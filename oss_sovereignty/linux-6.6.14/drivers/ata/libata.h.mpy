{
  "module_name": "libata.h",
  "hash_id": "4083a93e125c04e91c92bccd3c42f11592aeaa7dc62c91f7526351c7ec5de28d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata.h",
  "human_readable_source": " \n \n\n#ifndef __LIBATA_H__\n#define __LIBATA_H__\n\n#define DRV_NAME\t\"libata\"\n#define DRV_VERSION\t\"3.00\"\t \n\n \nenum {\n\t \n\tATA_READID_POSTRESET\t= (1 << 0),  \n\n\t \n\tATA_DNXFER_PIO\t\t= 0,\t \n\tATA_DNXFER_DMA\t\t= 1,\t \n\tATA_DNXFER_40C\t\t= 2,\t \n\tATA_DNXFER_FORCE_PIO\t= 3,\t \n\tATA_DNXFER_FORCE_PIO0\t= 4,\t \n\n\tATA_DNXFER_QUIET\t= (1 << 31),\n};\n\n#define ATA_PORT_TYPE_NAME\t\"ata_port\"\n\nextern atomic_t ata_print_id;\nextern int atapi_passthru16;\nextern int libata_fua;\nextern int libata_noacpi;\nextern int libata_allow_tpm;\nextern const struct device_type ata_port_type;\nextern struct ata_link *ata_dev_phys_link(struct ata_device *dev);\n#ifdef CONFIG_ATA_FORCE\nextern void ata_force_cbl(struct ata_port *ap);\n#else\nstatic inline void ata_force_cbl(struct ata_port *ap) { }\n#endif\nextern u64 ata_tf_to_lba(const struct ata_taskfile *tf);\nextern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);\nextern int ata_build_rw_tf(struct ata_queued_cmd *qc, u64 block, u32 n_block,\n\t\t\t   unsigned int tf_flags, int dld, int class);\nextern u64 ata_tf_read_block(const struct ata_taskfile *tf,\n\t\t\t     struct ata_device *dev);\nextern unsigned ata_exec_internal(struct ata_device *dev,\n\t\t\t\t  struct ata_taskfile *tf, const u8 *cdb,\n\t\t\t\t  int dma_dir, void *buf, unsigned int buflen,\n\t\t\t\t  unsigned int timeout);\nextern int ata_wait_ready(struct ata_link *link, unsigned long deadline,\n\t\t\t  int (*check_ready)(struct ata_link *link));\nextern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,\n\t\t\t   unsigned int flags, u16 *id);\nextern int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags);\nextern int ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,\n\t\t\t      unsigned int readid_flags);\nextern int ata_dev_configure(struct ata_device *dev);\nextern void ata_dev_power_set_standby(struct ata_device *dev);\nextern void ata_dev_power_set_active(struct ata_device *dev);\nextern int sata_down_spd_limit(struct ata_link *link, u32 spd_limit);\nextern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);\nextern unsigned int ata_dev_set_feature(struct ata_device *dev,\n\t\t\t\t\tu8 subcmd, u8 action);\nextern void ata_qc_free(struct ata_queued_cmd *qc);\nextern void ata_qc_issue(struct ata_queued_cmd *qc);\nextern void __ata_qc_complete(struct ata_queued_cmd *qc);\nextern int atapi_check_dma(struct ata_queued_cmd *qc);\nextern void swap_buf_le16(u16 *buf, unsigned int buf_words);\nextern bool ata_phys_link_online(struct ata_link *link);\nextern bool ata_phys_link_offline(struct ata_link *link);\nextern void ata_dev_init(struct ata_device *dev);\nextern void ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp);\nextern int sata_link_init_spd(struct ata_link *link);\nextern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);\nextern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);\nextern struct ata_port *ata_port_alloc(struct ata_host *host);\nextern const char *sata_spd_string(unsigned int spd);\nextern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,\n\t\t\t\t      u8 page, void *buf, unsigned int sectors);\n\n#define to_ata_port(d) container_of(d, struct ata_port, tdev)\n\n \n#ifdef CONFIG_ATA_ACPI\nextern unsigned int ata_acpi_gtf_filter;\nextern void ata_acpi_dissociate(struct ata_host *host);\nextern void ata_acpi_on_resume(struct ata_port *ap);\nextern int ata_acpi_on_devcfg(struct ata_device *dev);\nextern void ata_acpi_on_disable(struct ata_device *dev);\nextern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);\nextern void ata_acpi_bind_port(struct ata_port *ap);\nextern void ata_acpi_bind_dev(struct ata_device *dev);\nextern acpi_handle ata_dev_acpi_handle(struct ata_device *dev);\n#else\nstatic inline void ata_acpi_dissociate(struct ata_host *host) { }\nstatic inline void ata_acpi_on_resume(struct ata_port *ap) { }\nstatic inline int ata_acpi_on_devcfg(struct ata_device *dev) { return 0; }\nstatic inline void ata_acpi_on_disable(struct ata_device *dev) { }\nstatic inline void ata_acpi_set_state(struct ata_port *ap,\n\t\t\t\t      pm_message_t state) { }\nstatic inline void ata_acpi_bind_port(struct ata_port *ap) {}\nstatic inline void ata_acpi_bind_dev(struct ata_device *dev) {}\n#endif\n\n \nextern struct ata_device *ata_scsi_find_dev(struct ata_port *ap,\n\t\t\t\t\t    const struct scsi_device *scsidev);\nextern int ata_scsi_add_hosts(struct ata_host *host,\n\t\t\t      const struct scsi_host_template *sht);\nextern void ata_scsi_scan_host(struct ata_port *ap, int sync);\nextern int ata_scsi_offline_dev(struct ata_device *dev);\nextern bool ata_scsi_sense_is_valid(u8 sk, u8 asc, u8 ascq);\nextern void ata_scsi_set_sense(struct ata_device *dev,\n\t\t\t       struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);\nextern void ata_scsi_set_sense_information(struct ata_device *dev,\n\t\t\t\t\t   struct scsi_cmnd *cmd,\n\t\t\t\t\t   const struct ata_taskfile *tf);\nextern void ata_scsi_media_change_notify(struct ata_device *dev);\nextern void ata_scsi_hotplug(struct work_struct *work);\nextern void ata_schedule_scsi_eh(struct Scsi_Host *shost);\nextern void ata_scsi_dev_rescan(struct work_struct *work);\nextern int ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,\n\t\t\t      unsigned int id, u64 lun);\nvoid ata_scsi_sdev_config(struct scsi_device *sdev);\nint ata_scsi_dev_config(struct scsi_device *sdev, struct ata_device *dev);\nint __ata_scsi_queuecmd(struct scsi_cmnd *scmd, struct ata_device *dev);\n\n \nextern unsigned int ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);\nextern void ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd);\nextern void ata_eh_acquire(struct ata_port *ap);\nextern void ata_eh_release(struct ata_port *ap);\nextern void ata_scsi_error(struct Scsi_Host *host);\nextern void ata_eh_fastdrain_timerfn(struct timer_list *t);\nextern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);\nextern void ata_dev_disable(struct ata_device *dev);\nextern void ata_eh_detach_dev(struct ata_device *dev);\nextern void ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,\n\t\t\t       unsigned int action);\nextern void ata_eh_done(struct ata_link *link, struct ata_device *dev,\n\t\t\tunsigned int action);\nextern void ata_eh_autopsy(struct ata_port *ap);\nconst char *ata_get_cmd_name(u8 command);\nextern void ata_eh_report(struct ata_port *ap);\nextern int ata_eh_reset(struct ata_link *link, int classify,\n\t\t\tata_prereset_fn_t prereset, ata_reset_fn_t softreset,\n\t\t\tata_reset_fn_t hardreset, ata_postreset_fn_t postreset);\nextern int ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);\nextern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,\n\t\t\t  ata_reset_fn_t softreset, ata_reset_fn_t hardreset,\n\t\t\t  ata_postreset_fn_t postreset,\n\t\t\t  struct ata_link **r_failed_disk);\nextern void ata_eh_finish(struct ata_port *ap);\nextern int ata_ering_map(struct ata_ering *ering,\n\t\t\t int (*map_fn)(struct ata_ering_entry *, void *),\n\t\t\t void *arg);\nextern unsigned int atapi_eh_tur(struct ata_device *dev, u8 *r_sense_key);\nextern unsigned int atapi_eh_request_sense(struct ata_device *dev,\n\t\t\t\t\t   u8 *sense_buf, u8 dfl_sense_key);\n\n \n#ifdef CONFIG_SATA_PMP\nextern int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val);\nextern int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val);\nextern int sata_pmp_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\t    unsigned hints);\nextern int sata_pmp_attach(struct ata_device *dev);\n#else  \nstatic inline int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int sata_pmp_set_lpm(struct ata_link *link,\n\t\t\t\t   enum ata_lpm_policy policy, unsigned hints)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int sata_pmp_attach(struct ata_device *dev)\n{\n\treturn -EINVAL;\n}\n#endif  \n\n \n#ifdef CONFIG_ATA_SFF\nextern void ata_sff_flush_pio_task(struct ata_port *ap);\nextern void ata_sff_port_init(struct ata_port *ap);\nextern int ata_sff_init(void);\nextern void ata_sff_exit(void);\n#else  \nstatic inline void ata_sff_flush_pio_task(struct ata_port *ap)\n{ }\nstatic inline void ata_sff_port_init(struct ata_port *ap)\n{ }\nstatic inline int ata_sff_init(void)\n{ return 0; }\nstatic inline void ata_sff_exit(void)\n{ }\n#endif  \n\n \n#ifdef CONFIG_SATA_ZPODD\nvoid zpodd_init(struct ata_device *dev);\nvoid zpodd_exit(struct ata_device *dev);\nstatic inline bool zpodd_dev_enabled(struct ata_device *dev)\n{\n\treturn dev->zpodd != NULL;\n}\nvoid zpodd_on_suspend(struct ata_device *dev);\nbool zpodd_zpready(struct ata_device *dev);\nvoid zpodd_enable_run_wake(struct ata_device *dev);\nvoid zpodd_disable_run_wake(struct ata_device *dev);\nvoid zpodd_post_poweron(struct ata_device *dev);\n#else  \nstatic inline void zpodd_init(struct ata_device *dev) {}\nstatic inline void zpodd_exit(struct ata_device *dev) {}\nstatic inline bool zpodd_dev_enabled(struct ata_device *dev) { return false; }\nstatic inline void zpodd_on_suspend(struct ata_device *dev) {}\nstatic inline bool zpodd_zpready(struct ata_device *dev) { return false; }\nstatic inline void zpodd_enable_run_wake(struct ata_device *dev) {}\nstatic inline void zpodd_disable_run_wake(struct ata_device *dev) {}\nstatic inline void zpodd_post_poweron(struct ata_device *dev) {}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}