{
  "module_name": "libahci.c",
  "hash_id": "354a77e991809c3cbb5b6ed7a485e51619300e9b4c3f1f3842d722afda443407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libahci.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/nospec.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n#include <linux/pci.h>\n#include \"ahci.h\"\n#include \"libata.h\"\n\nstatic int ahci_skip_host_reset;\nint ahci_ignore_sss;\nEXPORT_SYMBOL_GPL(ahci_ignore_sss);\n\nmodule_param_named(skip_host_reset, ahci_skip_host_reset, int, 0444);\nMODULE_PARM_DESC(skip_host_reset, \"skip global host reset (0=don't skip, 1=skip)\");\n\nmodule_param_named(ignore_sss, ahci_ignore_sss, int, 0444);\nMODULE_PARM_DESC(ignore_sss, \"Ignore staggered spinup flag (0=don't ignore, 1=ignore)\");\n\nstatic int ahci_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\tunsigned hints);\nstatic ssize_t ahci_led_show(struct ata_port *ap, char *buf);\nstatic ssize_t ahci_led_store(struct ata_port *ap, const char *buf,\n\t\t\t      size_t size);\nstatic ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,\n\t\t\t\t\tssize_t size);\n\n\n\nstatic int ahci_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);\nstatic int ahci_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);\nstatic void ahci_qc_fill_rtf(struct ata_queued_cmd *qc);\nstatic void ahci_qc_ncq_fill_rtf(struct ata_port *ap, u64 done_mask);\nstatic int ahci_port_start(struct ata_port *ap);\nstatic void ahci_port_stop(struct ata_port *ap);\nstatic enum ata_completion_errors ahci_qc_prep(struct ata_queued_cmd *qc);\nstatic int ahci_pmp_qc_defer(struct ata_queued_cmd *qc);\nstatic void ahci_freeze(struct ata_port *ap);\nstatic void ahci_thaw(struct ata_port *ap);\nstatic void ahci_set_aggressive_devslp(struct ata_port *ap, bool sleep);\nstatic void ahci_enable_fbs(struct ata_port *ap);\nstatic void ahci_disable_fbs(struct ata_port *ap);\nstatic void ahci_pmp_attach(struct ata_port *ap);\nstatic void ahci_pmp_detach(struct ata_port *ap);\nstatic int ahci_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline);\nstatic int ahci_pmp_retry_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline);\nstatic int ahci_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline);\nstatic void ahci_postreset(struct ata_link *link, unsigned int *class);\nstatic void ahci_post_internal_cmd(struct ata_queued_cmd *qc);\nstatic void ahci_dev_config(struct ata_device *dev);\n#ifdef CONFIG_PM\nstatic int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg);\n#endif\nstatic ssize_t ahci_activity_show(struct ata_device *dev, char *buf);\nstatic ssize_t ahci_activity_store(struct ata_device *dev,\n\t\t\t\t   enum sw_activity val);\nstatic void ahci_init_sw_activity(struct ata_link *link);\n\nstatic ssize_t ahci_show_host_caps(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf);\nstatic ssize_t ahci_show_host_cap2(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf);\nstatic ssize_t ahci_show_host_version(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf);\nstatic ssize_t ahci_show_port_cmd(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf);\nstatic ssize_t ahci_read_em_buffer(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf);\nstatic ssize_t ahci_store_em_buffer(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size);\nstatic ssize_t ahci_show_em_supported(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf);\nstatic irqreturn_t ahci_single_level_irq_intr(int irq, void *dev_instance);\n\nstatic DEVICE_ATTR(ahci_host_caps, S_IRUGO, ahci_show_host_caps, NULL);\nstatic DEVICE_ATTR(ahci_host_cap2, S_IRUGO, ahci_show_host_cap2, NULL);\nstatic DEVICE_ATTR(ahci_host_version, S_IRUGO, ahci_show_host_version, NULL);\nstatic DEVICE_ATTR(ahci_port_cmd, S_IRUGO, ahci_show_port_cmd, NULL);\nstatic DEVICE_ATTR(em_buffer, S_IWUSR | S_IRUGO,\n\t\t   ahci_read_em_buffer, ahci_store_em_buffer);\nstatic DEVICE_ATTR(em_message_supported, S_IRUGO, ahci_show_em_supported, NULL);\n\nstatic struct attribute *ahci_shost_attrs[] = {\n\t&dev_attr_link_power_management_policy.attr,\n\t&dev_attr_em_message_type.attr,\n\t&dev_attr_em_message.attr,\n\t&dev_attr_ahci_host_caps.attr,\n\t&dev_attr_ahci_host_cap2.attr,\n\t&dev_attr_ahci_host_version.attr,\n\t&dev_attr_ahci_port_cmd.attr,\n\t&dev_attr_em_buffer.attr,\n\t&dev_attr_em_message_supported.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ahci_shost_attr_group = {\n\t.attrs = ahci_shost_attrs\n};\n\nconst struct attribute_group *ahci_shost_groups[] = {\n\t&ahci_shost_attr_group,\n\tNULL\n};\nEXPORT_SYMBOL_GPL(ahci_shost_groups);\n\nstatic struct attribute *ahci_sdev_attrs[] = {\n\t&dev_attr_sw_activity.attr,\n\t&dev_attr_unload_heads.attr,\n\t&dev_attr_ncq_prio_supported.attr,\n\t&dev_attr_ncq_prio_enable.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ahci_sdev_attr_group = {\n\t.attrs = ahci_sdev_attrs\n};\n\nconst struct attribute_group *ahci_sdev_groups[] = {\n\t&ahci_sdev_attr_group,\n\tNULL\n};\nEXPORT_SYMBOL_GPL(ahci_sdev_groups);\n\nstruct ata_port_operations ahci_ops = {\n\t.inherits\t\t= &sata_pmp_port_ops,\n\n\t.qc_defer\t\t= ahci_pmp_qc_defer,\n\t.qc_prep\t\t= ahci_qc_prep,\n\t.qc_issue\t\t= ahci_qc_issue,\n\t.qc_fill_rtf\t\t= ahci_qc_fill_rtf,\n\t.qc_ncq_fill_rtf\t= ahci_qc_ncq_fill_rtf,\n\n\t.freeze\t\t\t= ahci_freeze,\n\t.thaw\t\t\t= ahci_thaw,\n\t.softreset\t\t= ahci_softreset,\n\t.hardreset\t\t= ahci_hardreset,\n\t.postreset\t\t= ahci_postreset,\n\t.pmp_softreset\t\t= ahci_softreset,\n\t.error_handler\t\t= ahci_error_handler,\n\t.post_internal_cmd\t= ahci_post_internal_cmd,\n\t.dev_config\t\t= ahci_dev_config,\n\n\t.scr_read\t\t= ahci_scr_read,\n\t.scr_write\t\t= ahci_scr_write,\n\t.pmp_attach\t\t= ahci_pmp_attach,\n\t.pmp_detach\t\t= ahci_pmp_detach,\n\n\t.set_lpm\t\t= ahci_set_lpm,\n\t.em_show\t\t= ahci_led_show,\n\t.em_store\t\t= ahci_led_store,\n\t.sw_activity_show\t= ahci_activity_show,\n\t.sw_activity_store\t= ahci_activity_store,\n\t.transmit_led_message\t= ahci_transmit_led_message,\n#ifdef CONFIG_PM\n\t.port_suspend\t\t= ahci_port_suspend,\n\t.port_resume\t\t= ahci_port_resume,\n#endif\n\t.port_start\t\t= ahci_port_start,\n\t.port_stop\t\t= ahci_port_stop,\n};\nEXPORT_SYMBOL_GPL(ahci_ops);\n\nstruct ata_port_operations ahci_pmp_retry_srst_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.softreset\t\t= ahci_pmp_retry_softreset,\n};\nEXPORT_SYMBOL_GPL(ahci_pmp_retry_srst_ops);\n\nstatic bool ahci_em_messages __read_mostly = true;\nmodule_param(ahci_em_messages, bool, 0444);\n \nMODULE_PARM_DESC(ahci_em_messages,\n\t\"AHCI Enclosure Management Message control (0 = off, 1 = on)\");\n\n \nstatic int devslp_idle_timeout __read_mostly = 1000;\nmodule_param(devslp_idle_timeout, int, 0644);\nMODULE_PARM_DESC(devslp_idle_timeout, \"device sleep idle timeout\");\n\nstatic void ahci_enable_ahci(void __iomem *mmio)\n{\n\tint i;\n\tu32 tmp;\n\n\t \n\ttmp = readl(mmio + HOST_CTL);\n\tif (tmp & HOST_AHCI_EN)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\ttmp |= HOST_AHCI_EN;\n\t\twritel(tmp, mmio + HOST_CTL);\n\t\ttmp = readl(mmio + HOST_CTL);\t \n\t\tif (tmp & HOST_AHCI_EN)\n\t\t\treturn;\n\t\tmsleep(10);\n\t}\n\n\tWARN_ON(1);\n}\n\n \nstatic int ahci_rpm_get_port(struct ata_port *ap)\n{\n\treturn pm_runtime_get_sync(ap->dev);\n}\n\n \nstatic void ahci_rpm_put_port(struct ata_port *ap)\n{\n\tpm_runtime_put(ap->dev);\n}\n\nstatic ssize_t ahci_show_host_caps(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\treturn sprintf(buf, \"%x\\n\", hpriv->cap);\n}\n\nstatic ssize_t ahci_show_host_cap2(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\treturn sprintf(buf, \"%x\\n\", hpriv->cap2);\n}\n\nstatic ssize_t ahci_show_host_version(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\treturn sprintf(buf, \"%x\\n\", hpriv->version);\n}\n\nstatic ssize_t ahci_show_port_cmd(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tssize_t ret;\n\n\tahci_rpm_get_port(ap);\n\tret = sprintf(buf, \"%x\\n\", readl(port_mmio + PORT_CMD));\n\tahci_rpm_put_port(ap);\n\n\treturn ret;\n}\n\nstatic ssize_t ahci_read_em_buffer(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tvoid __iomem *em_mmio = mmio + hpriv->em_loc;\n\tu32 em_ctl, msg;\n\tunsigned long flags;\n\tsize_t count;\n\tint i;\n\n\tahci_rpm_get_port(ap);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tem_ctl = readl(mmio + HOST_EM_CTL);\n\tif (!(ap->flags & ATA_FLAG_EM) || em_ctl & EM_CTL_XMT ||\n\t    !(hpriv->em_msg_type & EM_MSG_TYPE_SGPIO)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tahci_rpm_put_port(ap);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(em_ctl & EM_CTL_MR)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tahci_rpm_put_port(ap);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!(em_ctl & EM_CTL_SMB))\n\t\tem_mmio += hpriv->em_buf_sz;\n\n\tcount = hpriv->em_buf_sz;\n\n\t \n\tif (count > PAGE_SIZE) {\n\t\tif (printk_ratelimit())\n\t\t\tata_port_warn(ap,\n\t\t\t\t      \"EM read buffer size too large: \"\n\t\t\t\t      \"buffer size %u, page size %lu\\n\",\n\t\t\t\t      hpriv->em_buf_sz, PAGE_SIZE);\n\t\tcount = PAGE_SIZE;\n\t}\n\n\tfor (i = 0; i < count; i += 4) {\n\t\tmsg = readl(em_mmio + i);\n\t\tbuf[i] = msg & 0xff;\n\t\tbuf[i + 1] = (msg >> 8) & 0xff;\n\t\tbuf[i + 2] = (msg >> 16) & 0xff;\n\t\tbuf[i + 3] = (msg >> 24) & 0xff;\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tahci_rpm_put_port(ap);\n\n\treturn i;\n}\n\nstatic ssize_t ahci_store_em_buffer(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tvoid __iomem *em_mmio = mmio + hpriv->em_loc;\n\tconst unsigned char *msg_buf = buf;\n\tu32 em_ctl, msg;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tif (!(ap->flags & ATA_FLAG_EM) ||\n\t    !(hpriv->em_msg_type & EM_MSG_TYPE_SGPIO) ||\n\t    size % 4 || size > hpriv->em_buf_sz)\n\t\treturn -EINVAL;\n\n\tahci_rpm_get_port(ap);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tem_ctl = readl(mmio + HOST_EM_CTL);\n\tif (em_ctl & EM_CTL_TM) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tahci_rpm_put_port(ap);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < size; i += 4) {\n\t\tmsg = msg_buf[i] | msg_buf[i + 1] << 8 |\n\t\t      msg_buf[i + 2] << 16 | msg_buf[i + 3] << 24;\n\t\twritel(msg, em_mmio + i);\n\t}\n\n\twritel(em_ctl | EM_CTL_TM, mmio + HOST_EM_CTL);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tahci_rpm_put_port(ap);\n\n\treturn size;\n}\n\nstatic ssize_t ahci_show_em_supported(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 em_ctl;\n\n\tahci_rpm_get_port(ap);\n\tem_ctl = readl(mmio + HOST_EM_CTL);\n\tahci_rpm_put_port(ap);\n\n\treturn sprintf(buf, \"%s%s%s%s\\n\",\n\t\t       em_ctl & EM_CTL_LED ? \"led \" : \"\",\n\t\t       em_ctl & EM_CTL_SAFTE ? \"saf-te \" : \"\",\n\t\t       em_ctl & EM_CTL_SES ? \"ses-2 \" : \"\",\n\t\t       em_ctl & EM_CTL_SGPIO ? \"sgpio \" : \"\");\n}\n\n \nvoid ahci_save_initial_config(struct device *dev, struct ahci_host_priv *hpriv)\n{\n\tvoid __iomem *mmio = hpriv->mmio;\n\tvoid __iomem *port_mmio;\n\tunsigned long port_map;\n\tu32 cap, cap2, vers;\n\tint i;\n\n\t \n\tahci_enable_ahci(mmio);\n\n\t \n\n\t \n\tcap = readl(mmio + HOST_CAP);\n\tif (hpriv->saved_cap)\n\t\tcap = (cap & ~(HOST_CAP_SSS | HOST_CAP_MPS)) | hpriv->saved_cap;\n\thpriv->saved_cap = cap;\n\n\t \n\tvers = readl(mmio + HOST_VERSION);\n\tif ((vers >> 16) > 1 ||\n\t   ((vers >> 16) == 1 && (vers & 0xFFFF) >= 0x200))\n\t\thpriv->saved_cap2 = cap2 = readl(mmio + HOST_CAP2);\n\telse\n\t\thpriv->saved_cap2 = cap2 = 0;\n\n\t \n\tif ((cap & HOST_CAP_64) && (hpriv->flags & AHCI_HFLAG_32BIT_ONLY)) {\n\t\tdev_info(dev, \"controller can't do 64bit DMA, forcing 32bit\\n\");\n\t\tcap &= ~HOST_CAP_64;\n\t}\n\n\tif ((cap & HOST_CAP_NCQ) && (hpriv->flags & AHCI_HFLAG_NO_NCQ)) {\n\t\tdev_info(dev, \"controller can't do NCQ, turning off CAP_NCQ\\n\");\n\t\tcap &= ~HOST_CAP_NCQ;\n\t}\n\n\tif (!(cap & HOST_CAP_NCQ) && (hpriv->flags & AHCI_HFLAG_YES_NCQ)) {\n\t\tdev_info(dev, \"controller can do NCQ, turning on CAP_NCQ\\n\");\n\t\tcap |= HOST_CAP_NCQ;\n\t}\n\n\tif ((cap & HOST_CAP_PMP) && (hpriv->flags & AHCI_HFLAG_NO_PMP)) {\n\t\tdev_info(dev, \"controller can't do PMP, turning off CAP_PMP\\n\");\n\t\tcap &= ~HOST_CAP_PMP;\n\t}\n\n\tif ((cap & HOST_CAP_SNTF) && (hpriv->flags & AHCI_HFLAG_NO_SNTF)) {\n\t\tdev_info(dev,\n\t\t\t \"controller can't do SNTF, turning off CAP_SNTF\\n\");\n\t\tcap &= ~HOST_CAP_SNTF;\n\t}\n\n\tif ((cap2 & HOST_CAP2_SDS) && (hpriv->flags & AHCI_HFLAG_NO_DEVSLP)) {\n\t\tdev_info(dev,\n\t\t\t \"controller can't do DEVSLP, turning off\\n\");\n\t\tcap2 &= ~HOST_CAP2_SDS;\n\t\tcap2 &= ~HOST_CAP2_SADM;\n\t}\n\n\tif (!(cap & HOST_CAP_FBS) && (hpriv->flags & AHCI_HFLAG_YES_FBS)) {\n\t\tdev_info(dev, \"controller can do FBS, turning on CAP_FBS\\n\");\n\t\tcap |= HOST_CAP_FBS;\n\t}\n\n\tif ((cap & HOST_CAP_FBS) && (hpriv->flags & AHCI_HFLAG_NO_FBS)) {\n\t\tdev_info(dev, \"controller can't do FBS, turning off CAP_FBS\\n\");\n\t\tcap &= ~HOST_CAP_FBS;\n\t}\n\n\tif (!(cap & HOST_CAP_ALPM) && (hpriv->flags & AHCI_HFLAG_YES_ALPM)) {\n\t\tdev_info(dev, \"controller can do ALPM, turning on CAP_ALPM\\n\");\n\t\tcap |= HOST_CAP_ALPM;\n\t}\n\n\tif ((cap & HOST_CAP_SXS) && (hpriv->flags & AHCI_HFLAG_NO_SXS)) {\n\t\tdev_info(dev, \"controller does not support SXS, disabling CAP_SXS\\n\");\n\t\tcap &= ~HOST_CAP_SXS;\n\t}\n\n\t \n\tport_map = readl(mmio + HOST_PORTS_IMPL);\n\tif (hpriv->saved_port_map && port_map != hpriv->saved_port_map) {\n\t\tdev_info(dev, \"forcing port_map 0x%lx -> 0x%x\\n\",\n\t\t\t port_map, hpriv->saved_port_map);\n\t\tport_map = hpriv->saved_port_map;\n\t} else {\n\t\thpriv->saved_port_map = port_map;\n\t}\n\n\tif (hpriv->mask_port_map) {\n\t\tdev_warn(dev, \"masking port_map 0x%lx -> 0x%lx\\n\",\n\t\t\tport_map,\n\t\t\tport_map & hpriv->mask_port_map);\n\t\tport_map &= hpriv->mask_port_map;\n\t}\n\n\t \n\tif (port_map) {\n\t\tint map_ports = 0;\n\n\t\tfor (i = 0; i < AHCI_MAX_PORTS; i++)\n\t\t\tif (port_map & (1 << i))\n\t\t\t\tmap_ports++;\n\n\t\t \n\t\tif (map_ports > ahci_nr_ports(cap)) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"implemented port map (0x%lx) contains more ports than nr_ports (%u), using nr_ports\\n\",\n\t\t\t\t port_map, ahci_nr_ports(cap));\n\t\t\tport_map = 0;\n\t\t}\n\t}\n\n\t \n\tif (!port_map && vers < 0x10300) {\n\t\tport_map = (1 << ahci_nr_ports(cap)) - 1;\n\t\tdev_warn(dev, \"forcing PORTS_IMPL to 0x%lx\\n\", port_map);\n\n\t\t \n\t\thpriv->saved_port_map = port_map;\n\t}\n\n\t \n\tfor_each_set_bit(i, &port_map, AHCI_MAX_PORTS) {\n\t\tif (hpriv->saved_port_cap[i])\n\t\t\tcontinue;\n\n\t\tport_mmio = __ahci_port_base(hpriv, i);\n\t\thpriv->saved_port_cap[i] =\n\t\t\treadl(port_mmio + PORT_CMD) & PORT_CMD_CAP;\n\t}\n\n\t \n\thpriv->cap = cap;\n\thpriv->cap2 = cap2;\n\thpriv->version = vers;\n\thpriv->port_map = port_map;\n\n\tif (!hpriv->start_engine)\n\t\thpriv->start_engine = ahci_start_engine;\n\n\tif (!hpriv->stop_engine)\n\t\thpriv->stop_engine = ahci_stop_engine;\n\n\tif (!hpriv->irq_handler)\n\t\thpriv->irq_handler = ahci_single_level_irq_intr;\n}\nEXPORT_SYMBOL_GPL(ahci_save_initial_config);\n\n \nstatic void ahci_restore_initial_config(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tunsigned long port_map = hpriv->port_map;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tvoid __iomem *port_mmio;\n\tint i;\n\n\twritel(hpriv->saved_cap, mmio + HOST_CAP);\n\tif (hpriv->saved_cap2)\n\t\twritel(hpriv->saved_cap2, mmio + HOST_CAP2);\n\twritel(hpriv->saved_port_map, mmio + HOST_PORTS_IMPL);\n\t(void) readl(mmio + HOST_PORTS_IMPL);\t \n\n\tfor_each_set_bit(i, &port_map, AHCI_MAX_PORTS) {\n\t\tport_mmio = __ahci_port_base(hpriv, i);\n\t\twritel(hpriv->saved_port_cap[i], port_mmio + PORT_CMD);\n\t}\n}\n\nstatic unsigned ahci_scr_offset(struct ata_port *ap, unsigned int sc_reg)\n{\n\tstatic const int offset[] = {\n\t\t[SCR_STATUS]\t\t= PORT_SCR_STAT,\n\t\t[SCR_CONTROL]\t\t= PORT_SCR_CTL,\n\t\t[SCR_ERROR]\t\t= PORT_SCR_ERR,\n\t\t[SCR_ACTIVE]\t\t= PORT_SCR_ACT,\n\t\t[SCR_NOTIFICATION]\t= PORT_SCR_NTF,\n\t};\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\tif (sc_reg < ARRAY_SIZE(offset) &&\n\t    (sc_reg != SCR_NOTIFICATION || (hpriv->cap & HOST_CAP_SNTF)))\n\t\treturn offset[sc_reg];\n\treturn 0;\n}\n\nstatic int ahci_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tint offset = ahci_scr_offset(link->ap, sc_reg);\n\n\tif (offset) {\n\t\t*val = readl(port_mmio + offset);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ahci_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tint offset = ahci_scr_offset(link->ap, sc_reg);\n\n\tif (offset) {\n\t\twritel(val, port_mmio + offset);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nvoid ahci_start_engine(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 tmp;\n\n\t \n\ttmp = readl(port_mmio + PORT_CMD);\n\ttmp |= PORT_CMD_START;\n\twritel(tmp, port_mmio + PORT_CMD);\n\treadl(port_mmio + PORT_CMD);  \n}\nEXPORT_SYMBOL_GPL(ahci_start_engine);\n\nint ahci_stop_engine(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu32 tmp;\n\n\t \n\tif ((hpriv->flags & AHCI_HFLAG_WAKE_BEFORE_STOP) &&\n\t    (ap->link.lpm_policy > ATA_LPM_MAX_POWER) &&\n\t    ahci_set_lpm(&ap->link, ATA_LPM_MAX_POWER, ATA_LPM_WAKE_ONLY)) {\n\t\tdev_err(ap->host->dev, \"Failed to wake up port before engine stop\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttmp = readl(port_mmio + PORT_CMD);\n\n\t \n\tif ((tmp & (PORT_CMD_START | PORT_CMD_LIST_ON)) == 0)\n\t\treturn 0;\n\n\t \n\tif (tmp == 0xffffffff) {\n\t\tdev_err(ap->host->dev, \"AHCI controller unavailable!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\ttmp &= ~PORT_CMD_START;\n\twritel(tmp, port_mmio + PORT_CMD);\n\n\t \n\ttmp = ata_wait_register(ap, port_mmio + PORT_CMD,\n\t\t\t\tPORT_CMD_LIST_ON, PORT_CMD_LIST_ON, 1, 500);\n\tif (tmp & PORT_CMD_LIST_ON)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_stop_engine);\n\nvoid ahci_start_fis_rx(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tu32 tmp;\n\n\t \n\tif (hpriv->cap & HOST_CAP_64)\n\t\twritel((pp->cmd_slot_dma >> 16) >> 16,\n\t\t       port_mmio + PORT_LST_ADDR_HI);\n\twritel(pp->cmd_slot_dma & 0xffffffff, port_mmio + PORT_LST_ADDR);\n\n\tif (hpriv->cap & HOST_CAP_64)\n\t\twritel((pp->rx_fis_dma >> 16) >> 16,\n\t\t       port_mmio + PORT_FIS_ADDR_HI);\n\twritel(pp->rx_fis_dma & 0xffffffff, port_mmio + PORT_FIS_ADDR);\n\n\t \n\ttmp = readl(port_mmio + PORT_CMD);\n\ttmp |= PORT_CMD_FIS_RX;\n\twritel(tmp, port_mmio + PORT_CMD);\n\n\t \n\treadl(port_mmio + PORT_CMD);\n}\nEXPORT_SYMBOL_GPL(ahci_start_fis_rx);\n\nstatic int ahci_stop_fis_rx(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 tmp;\n\n\t \n\ttmp = readl(port_mmio + PORT_CMD);\n\ttmp &= ~PORT_CMD_FIS_RX;\n\twritel(tmp, port_mmio + PORT_CMD);\n\n\t \n\ttmp = ata_wait_register(ap, port_mmio + PORT_CMD, PORT_CMD_FIS_ON,\n\t\t\t\tPORT_CMD_FIS_ON, 10, 1000);\n\tif (tmp & PORT_CMD_FIS_ON)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void ahci_power_up(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 cmd;\n\n\tcmd = readl(port_mmio + PORT_CMD) & ~PORT_CMD_ICC_MASK;\n\n\t \n\tif (hpriv->cap & HOST_CAP_SSS) {\n\t\tcmd |= PORT_CMD_SPIN_UP;\n\t\twritel(cmd, port_mmio + PORT_CMD);\n\t}\n\n\t \n\twritel(cmd | PORT_CMD_ICC_ACTIVE, port_mmio + PORT_CMD);\n}\n\nstatic int ahci_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\tunsigned int hints)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\n\tif (policy != ATA_LPM_MAX_POWER) {\n\t\t \n\t\thints &= ~ATA_LPM_WAKE_ONLY;\n\n\t\t \n\t\tpp->intr_mask &= ~PORT_IRQ_PHYRDY;\n\t\twritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\n\n\t\tsata_link_scr_lpm(link, policy, false);\n\t}\n\n\tif (hpriv->cap & HOST_CAP_ALPM) {\n\t\tu32 cmd = readl(port_mmio + PORT_CMD);\n\n\t\tif (policy == ATA_LPM_MAX_POWER || !(hints & ATA_LPM_HIPM)) {\n\t\t\tif (!(hints & ATA_LPM_WAKE_ONLY))\n\t\t\t\tcmd &= ~(PORT_CMD_ASP | PORT_CMD_ALPE);\n\t\t\tcmd |= PORT_CMD_ICC_ACTIVE;\n\n\t\t\twritel(cmd, port_mmio + PORT_CMD);\n\t\t\treadl(port_mmio + PORT_CMD);\n\n\t\t\t \n\t\t\tata_msleep(ap, 10);\n\n\t\t\tif (hints & ATA_LPM_WAKE_ONLY)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tcmd |= PORT_CMD_ALPE;\n\t\t\tif (policy == ATA_LPM_MIN_POWER)\n\t\t\t\tcmd |= PORT_CMD_ASP;\n\t\t\telse if (policy == ATA_LPM_MIN_POWER_WITH_PARTIAL)\n\t\t\t\tcmd &= ~PORT_CMD_ASP;\n\n\t\t\t \n\t\t\twritel(cmd, port_mmio + PORT_CMD);\n\t\t}\n\t}\n\n\t \n\tif ((hpriv->cap2 & HOST_CAP2_SDS) &&\n\t    (hpriv->cap2 & HOST_CAP2_SADM) &&\n\t    (link->device->flags & ATA_DFLAG_DEVSLP)) {\n\t\tif (policy == ATA_LPM_MIN_POWER ||\n\t\t    policy == ATA_LPM_MIN_POWER_WITH_PARTIAL)\n\t\t\tahci_set_aggressive_devslp(ap, true);\n\t\telse\n\t\t\tahci_set_aggressive_devslp(ap, false);\n\t}\n\n\tif (policy == ATA_LPM_MAX_POWER) {\n\t\tsata_link_scr_lpm(link, policy, false);\n\n\t\t \n\t\tpp->intr_mask |= PORT_IRQ_PHYRDY;\n\t\twritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic void ahci_power_down(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 cmd, scontrol;\n\n\tif (!(hpriv->cap & HOST_CAP_SSS))\n\t\treturn;\n\n\t \n\tscontrol = readl(port_mmio + PORT_SCR_CTL);\n\tscontrol &= ~0xf;\n\twritel(scontrol, port_mmio + PORT_SCR_CTL);\n\n\t \n\tcmd = readl(port_mmio + PORT_CMD) & ~PORT_CMD_ICC_MASK;\n\tcmd &= ~PORT_CMD_SPIN_UP;\n\twritel(cmd, port_mmio + PORT_CMD);\n}\n#endif\n\nstatic void ahci_start_port(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ata_link *link;\n\tstruct ahci_em_priv *emp;\n\tssize_t rc;\n\tint i;\n\n\t \n\tahci_start_fis_rx(ap);\n\n\t \n\tif (!(hpriv->flags & AHCI_HFLAG_DELAY_ENGINE))\n\t\thpriv->start_engine(ap);\n\n\t \n\tif (ap->flags & ATA_FLAG_EM) {\n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\temp = &pp->em_priv[link->pmp];\n\n\t\t\t \n\t\t\tfor (i = 0; i < EM_MAX_RETRY; i++) {\n\t\t\t\trc = ap->ops->transmit_led_message(ap,\n\t\t\t\t\t\t\t       emp->led_state,\n\t\t\t\t\t\t\t       4);\n\t\t\t\t \n\t\t\t\tif (rc == -EBUSY)\n\t\t\t\t\tmsleep(1);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ap->flags & ATA_FLAG_SW_ACTIVITY)\n\t\tata_for_each_link(link, ap, EDGE)\n\t\t\tahci_init_sw_activity(link);\n\n}\n\nstatic int ahci_deinit_port(struct ata_port *ap, const char **emsg)\n{\n\tint rc;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\t \n\trc = hpriv->stop_engine(ap);\n\tif (rc) {\n\t\t*emsg = \"failed to stop engine\";\n\t\treturn rc;\n\t}\n\n\t \n\trc = ahci_stop_fis_rx(ap);\n\tif (rc) {\n\t\t*emsg = \"failed stop FIS RX\";\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint ahci_reset_controller(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 tmp;\n\n\t \n\tahci_enable_ahci(mmio);\n\n\t \n\tif (ahci_skip_host_reset) {\n\t\tdev_info(host->dev, \"Skipping global host reset\\n\");\n\t\treturn 0;\n\t}\n\n\ttmp = readl(mmio + HOST_CTL);\n\tif (!(tmp & HOST_RESET)) {\n\t\twritel(tmp | HOST_RESET, mmio + HOST_CTL);\n\t\treadl(mmio + HOST_CTL);  \n\t}\n\n\t \n\ttmp = ata_wait_register(NULL, mmio + HOST_CTL, HOST_RESET,\n\t\t\t\tHOST_RESET, 10, 1000);\n\tif (tmp & HOST_RESET) {\n\t\tdev_err(host->dev, \"Controller reset failed (0x%x)\\n\",\n\t\t\ttmp);\n\t\treturn -EIO;\n\t}\n\n\t \n\tahci_enable_ahci(mmio);\n\n\t \n\tif (!(hpriv->flags & AHCI_HFLAG_NO_WRITE_TO_RO))\n\t\tahci_restore_initial_config(host);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_reset_controller);\n\nstatic void ahci_sw_activity(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\n\n\tif (!(link->flags & ATA_LFLAG_SW_ACTIVITY))\n\t\treturn;\n\n\temp->activity++;\n\tif (!timer_pending(&emp->timer))\n\t\tmod_timer(&emp->timer, jiffies + msecs_to_jiffies(10));\n}\n\nstatic void ahci_sw_activity_blink(struct timer_list *t)\n{\n\tstruct ahci_em_priv *emp = from_timer(emp, t, timer);\n\tstruct ata_link *link = emp->link;\n\tstruct ata_port *ap = link->ap;\n\n\tunsigned long led_message = emp->led_state;\n\tu32 activity_led_state;\n\tunsigned long flags;\n\n\tled_message &= EM_MSG_LED_VALUE;\n\tled_message |= ap->port_no | (link->pmp << 8);\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\tif (emp->saved_activity != emp->activity) {\n\t\temp->saved_activity = emp->activity;\n\t\t \n\t\tactivity_led_state = led_message & EM_MSG_LED_VALUE_ON;\n\n\t\tif (activity_led_state)\n\t\t\tactivity_led_state = 0;\n\t\telse\n\t\t\tactivity_led_state = 1;\n\n\t\t \n\t\tled_message &= ~EM_MSG_LED_VALUE_ACTIVITY;\n\n\t\t \n\t\tled_message |= (activity_led_state << 16);\n\t\tmod_timer(&emp->timer, jiffies + msecs_to_jiffies(100));\n\t} else {\n\t\t \n\t\tled_message &= ~EM_MSG_LED_VALUE_ACTIVITY;\n\t\tif (emp->blink_policy == BLINK_OFF)\n\t\t\tled_message |= (1 << 16);\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tap->ops->transmit_led_message(ap, led_message, 4);\n}\n\nstatic void ahci_init_sw_activity(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\n\n\t \n\temp->saved_activity = emp->activity = 0;\n\temp->link = link;\n\ttimer_setup(&emp->timer, ahci_sw_activity_blink, 0);\n\n\t \n\tif (emp->blink_policy)\n\t\tlink->flags |= ATA_LFLAG_SW_ACTIVITY;\n}\n\nint ahci_reset_em(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 em_ctl;\n\n\tem_ctl = readl(mmio + HOST_EM_CTL);\n\tif ((em_ctl & EM_CTL_TM) || (em_ctl & EM_CTL_RST))\n\t\treturn -EINVAL;\n\n\twritel(em_ctl | EM_CTL_RST, mmio + HOST_EM_CTL);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_reset_em);\n\nstatic ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,\n\t\t\t\t\tssize_t size)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 em_ctl;\n\tu32 message[] = {0, 0};\n\tunsigned long flags;\n\tint pmp;\n\tstruct ahci_em_priv *emp;\n\n\t \n\tpmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\n\tif (pmp < EM_MAX_SLOTS)\n\t\temp = &pp->em_priv[pmp];\n\telse\n\t\treturn -EINVAL;\n\n\tahci_rpm_get_port(ap);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tem_ctl = readl(mmio + HOST_EM_CTL);\n\tif (em_ctl & EM_CTL_TM) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tahci_rpm_put_port(ap);\n\t\treturn -EBUSY;\n\t}\n\n\tif (hpriv->em_msg_type & EM_MSG_TYPE_LED) {\n\t\t \n\t\tmessage[0] |= (4 << 8);\n\n\t\t \n\t\tmessage[1] = ((state & ~EM_MSG_LED_HBA_PORT) | ap->port_no);\n\n\t\t \n\t\twritel(message[0], mmio + hpriv->em_loc);\n\t\twritel(message[1], mmio + hpriv->em_loc+4);\n\n\t\t \n\t\twritel(em_ctl | EM_CTL_TM, mmio + HOST_EM_CTL);\n\t}\n\n\t \n\temp->led_state = state;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tahci_rpm_put_port(ap);\n\n\treturn size;\n}\n\nstatic ssize_t ahci_led_show(struct ata_port *ap, char *buf)\n{\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ata_link *link;\n\tstruct ahci_em_priv *emp;\n\tint rc = 0;\n\n\tata_for_each_link(link, ap, EDGE) {\n\t\temp = &pp->em_priv[link->pmp];\n\t\trc += sprintf(buf, \"%lx\\n\", emp->led_state);\n\t}\n\treturn rc;\n}\n\nstatic ssize_t ahci_led_store(struct ata_port *ap, const char *buf,\n\t\t\t\tsize_t size)\n{\n\tunsigned int state;\n\tint pmp;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_em_priv *emp;\n\n\tif (kstrtouint(buf, 0, &state) < 0)\n\t\treturn -EINVAL;\n\n\t \n\tpmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\n\tif (pmp < EM_MAX_SLOTS) {\n\t\tpmp = array_index_nospec(pmp, EM_MAX_SLOTS);\n\t\temp = &pp->em_priv[pmp];\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (emp->blink_policy)\n\t\tstate &= ~EM_MSG_LED_VALUE_ACTIVITY;\n\n\treturn ap->ops->transmit_led_message(ap, state, size);\n}\n\nstatic ssize_t ahci_activity_store(struct ata_device *dev, enum sw_activity val)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\n\tu32 port_led_state = emp->led_state;\n\n\t \n\tif (val == OFF) {\n\t\t \n\t\tlink->flags &= ~(ATA_LFLAG_SW_ACTIVITY);\n\n\t\t \n\t\tport_led_state &= EM_MSG_LED_VALUE_OFF;\n\t\tport_led_state |= (ap->port_no | (link->pmp << 8));\n\t\tap->ops->transmit_led_message(ap, port_led_state, 4);\n\t} else {\n\t\tlink->flags |= ATA_LFLAG_SW_ACTIVITY;\n\t\tif (val == BLINK_OFF) {\n\t\t\t \n\t\t\tport_led_state &= EM_MSG_LED_VALUE_OFF;\n\t\t\tport_led_state |= (ap->port_no | (link->pmp << 8));\n\t\t\tport_led_state |= EM_MSG_LED_VALUE_ON;  \n\t\t\tap->ops->transmit_led_message(ap, port_led_state, 4);\n\t\t}\n\t}\n\temp->blink_policy = val;\n\treturn 0;\n}\n\nstatic ssize_t ahci_activity_show(struct ata_device *dev, char *buf)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\n\n\t \n\treturn sprintf(buf, \"%d\\n\", emp->blink_policy);\n}\n\nstatic void ahci_port_clear_pending_irq(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 tmp;\n\n\t \n\ttmp = readl(port_mmio + PORT_SCR_ERR);\n\tdev_dbg(ap->host->dev, \"PORT_SCR_ERR 0x%x\\n\", tmp);\n\twritel(tmp, port_mmio + PORT_SCR_ERR);\n\n\t \n\ttmp = readl(port_mmio + PORT_IRQ_STAT);\n\tdev_dbg(ap->host->dev, \"PORT_IRQ_STAT 0x%x\\n\", tmp);\n\tif (tmp)\n\t\twritel(tmp, port_mmio + PORT_IRQ_STAT);\n\n\twritel(1 << ap->port_no, hpriv->mmio + HOST_IRQ_STAT);\n}\n\nstatic void ahci_port_init(struct device *dev, struct ata_port *ap,\n\t\t\t   int port_no, void __iomem *mmio,\n\t\t\t   void __iomem *port_mmio)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tconst char *emsg = NULL;\n\tint rc;\n\tu32 tmp;\n\n\t \n\trc = ahci_deinit_port(ap, &emsg);\n\tif (rc)\n\t\tdev_warn(dev, \"%s (%d)\\n\", emsg, rc);\n\n\tahci_port_clear_pending_irq(ap);\n\n\t \n\ttmp = readl(port_mmio + PORT_CMD);\n\tif ((tmp & PORT_CMD_ESP) && (hpriv->cap & HOST_CAP_SXS))\n\t\tap->pflags |= ATA_PFLAG_EXTERNAL;\n}\n\nvoid ahci_init_controller(struct ata_host *host)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tint i;\n\tvoid __iomem *port_mmio;\n\tu32 tmp;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tport_mmio = ahci_port_base(ap);\n\t\tif (ata_port_is_dummy(ap))\n\t\t\tcontinue;\n\n\t\tahci_port_init(host->dev, ap, i, mmio, port_mmio);\n\t}\n\n\ttmp = readl(mmio + HOST_CTL);\n\tdev_dbg(host->dev, \"HOST_CTL 0x%x\\n\", tmp);\n\twritel(tmp | HOST_IRQ_EN, mmio + HOST_CTL);\n\ttmp = readl(mmio + HOST_CTL);\n\tdev_dbg(host->dev, \"HOST_CTL 0x%x\\n\", tmp);\n}\nEXPORT_SYMBOL_GPL(ahci_init_controller);\n\nstatic void ahci_dev_config(struct ata_device *dev)\n{\n\tstruct ahci_host_priv *hpriv = dev->link->ap->host->private_data;\n\n\tif (hpriv->flags & AHCI_HFLAG_SECT255) {\n\t\tdev->max_sectors = 255;\n\t\tata_dev_info(dev,\n\t\t\t     \"SB600 AHCI: limiting to 255 sectors per cmd\\n\");\n\t}\n}\n\nunsigned int ahci_dev_classify(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ata_taskfile tf;\n\tu32 tmp;\n\n\ttmp = readl(port_mmio + PORT_SIG);\n\ttf.lbah\t\t= (tmp >> 24)\t& 0xff;\n\ttf.lbam\t\t= (tmp >> 16)\t& 0xff;\n\ttf.lbal\t\t= (tmp >> 8)\t& 0xff;\n\ttf.nsect\t= (tmp)\t\t& 0xff;\n\n\treturn ata_port_classify(ap, &tf);\n}\nEXPORT_SYMBOL_GPL(ahci_dev_classify);\n\nvoid ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,\n\t\t\tu32 opts)\n{\n\tdma_addr_t cmd_tbl_dma;\n\n\tcmd_tbl_dma = pp->cmd_tbl_dma + tag * AHCI_CMD_TBL_SZ;\n\n\tpp->cmd_slot[tag].opts = cpu_to_le32(opts);\n\tpp->cmd_slot[tag].status = 0;\n\tpp->cmd_slot[tag].tbl_addr = cpu_to_le32(cmd_tbl_dma & 0xffffffff);\n\tpp->cmd_slot[tag].tbl_addr_hi = cpu_to_le32((cmd_tbl_dma >> 16) >> 16);\n}\nEXPORT_SYMBOL_GPL(ahci_fill_cmd_slot);\n\nint ahci_kick_engine(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;\n\tu32 tmp;\n\tint busy, rc;\n\n\t \n\trc = hpriv->stop_engine(ap);\n\tif (rc)\n\t\tgoto out_restart;\n\n\t \n\tbusy = status & (ATA_BUSY | ATA_DRQ);\n\tif (!busy && !sata_pmp_attached(ap)) {\n\t\trc = 0;\n\t\tgoto out_restart;\n\t}\n\n\tif (!(hpriv->cap & HOST_CAP_CLO)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out_restart;\n\t}\n\n\t \n\ttmp = readl(port_mmio + PORT_CMD);\n\ttmp |= PORT_CMD_CLO;\n\twritel(tmp, port_mmio + PORT_CMD);\n\n\trc = 0;\n\ttmp = ata_wait_register(ap, port_mmio + PORT_CMD,\n\t\t\t\tPORT_CMD_CLO, PORT_CMD_CLO, 1, 500);\n\tif (tmp & PORT_CMD_CLO)\n\t\trc = -EIO;\n\n\t \n out_restart:\n\thpriv->start_engine(ap);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_kick_engine);\n\nstatic int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,\n\t\t\t\tstruct ata_taskfile *tf, int is_cmd, u16 flags,\n\t\t\t\tunsigned int timeout_msec)\n{\n\tconst u32 cmd_fis_len = 5;  \n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu8 *fis = pp->cmd_tbl;\n\tu32 tmp;\n\n\t \n\tata_tf_to_fis(tf, pmp, is_cmd, fis);\n\tahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp << 12));\n\n\t \n\tif (pp->fbs_enabled && pp->fbs_last_dev != pmp) {\n\t\ttmp = readl(port_mmio + PORT_FBS);\n\t\ttmp &= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);\n\t\ttmp |= pmp << PORT_FBS_DEV_OFFSET;\n\t\twritel(tmp, port_mmio + PORT_FBS);\n\t\tpp->fbs_last_dev = pmp;\n\t}\n\n\t \n\twritel(1, port_mmio + PORT_CMD_ISSUE);\n\n\tif (timeout_msec) {\n\t\ttmp = ata_wait_register(ap, port_mmio + PORT_CMD_ISSUE,\n\t\t\t\t\t0x1, 0x1, 1, timeout_msec);\n\t\tif (tmp & 0x1) {\n\t\t\tahci_kick_engine(ap);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else\n\t\treadl(port_mmio + PORT_CMD_ISSUE);\t \n\n\treturn 0;\n}\n\nint ahci_do_softreset(struct ata_link *link, unsigned int *class,\n\t\t      int pmp, unsigned long deadline,\n\t\t      int (*check_ready)(struct ata_link *link))\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tconst char *reason = NULL;\n\tunsigned long now;\n\tunsigned int msecs;\n\tstruct ata_taskfile tf;\n\tbool fbs_disabled = false;\n\tint rc;\n\n\t \n\trc = ahci_kick_engine(ap);\n\tif (rc && rc != -EOPNOTSUPP)\n\t\tata_link_warn(link, \"failed to reset engine (errno=%d)\\n\", rc);\n\n\t \n\tif (!ata_is_host_link(link) && pp->fbs_enabled) {\n\t\tahci_disable_fbs(ap);\n\t\tfbs_disabled = true;\n\t}\n\n\tata_tf_init(link->device, &tf);\n\n\t \n\tmsecs = 0;\n\tnow = jiffies;\n\tif (time_after(deadline, now))\n\t\tmsecs = jiffies_to_msecs(deadline - now);\n\n\ttf.ctl |= ATA_SRST;\n\tif (ahci_exec_polled_cmd(ap, pmp, &tf, 0,\n\t\t\t\t AHCI_CMD_RESET | AHCI_CMD_CLR_BUSY, msecs)) {\n\t\trc = -EIO;\n\t\treason = \"1st FIS failed\";\n\t\tgoto fail;\n\t}\n\n\t \n\tata_msleep(ap, 1);\n\n\t \n\ttf.ctl &= ~ATA_SRST;\n\tahci_exec_polled_cmd(ap, pmp, &tf, 0, 0, 0);\n\n\t \n\trc = ata_wait_after_reset(link, deadline, check_ready);\n\tif (rc == -EBUSY && hpriv->flags & AHCI_HFLAG_SRST_TOUT_IS_OFFLINE) {\n\t\t \n\t\tata_link_info(link, \"device not ready, treating as offline\\n\");\n\t\t*class = ATA_DEV_NONE;\n\t} else if (rc) {\n\t\t \n\t\treason = \"device not ready\";\n\t\tgoto fail;\n\t} else\n\t\t*class = ahci_dev_classify(ap);\n\n\t \n\tif (fbs_disabled)\n\t\tahci_enable_fbs(ap);\n\n\treturn 0;\n\n fail:\n\tata_link_err(link, \"softreset failed (%s)\\n\", reason);\n\treturn rc;\n}\n\nint ahci_check_ready(struct ata_link *link)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tu8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;\n\n\treturn ata_check_ready(status);\n}\nEXPORT_SYMBOL_GPL(ahci_check_ready);\n\nstatic int ahci_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline)\n{\n\tint pmp = sata_srst_pmp(link);\n\n\treturn ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);\n}\nEXPORT_SYMBOL_GPL(ahci_do_softreset);\n\nstatic int ahci_bad_pmp_check_ready(struct ata_link *link)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tu8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;\n\tu32 irq_status = readl(port_mmio + PORT_IRQ_STAT);\n\n\t \n\tif (irq_status & PORT_IRQ_BAD_PMP)\n\t\treturn -EIO;\n\n\treturn ata_check_ready(status);\n}\n\nstatic int ahci_pmp_retry_softreset(struct ata_link *link, unsigned int *class,\n\t\t\t\t    unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tint pmp = sata_srst_pmp(link);\n\tint rc;\n\tu32 irq_sts;\n\n\trc = ahci_do_softreset(link, class, pmp, deadline,\n\t\t\t       ahci_bad_pmp_check_ready);\n\n\t \n\tif (rc == -EIO) {\n\t\tirq_sts = readl(port_mmio + PORT_IRQ_STAT);\n\t\tif (irq_sts & PORT_IRQ_BAD_PMP) {\n\t\t\tata_link_warn(link,\n\t\t\t\t\t\"applying PMP SRST workaround \"\n\t\t\t\t\t\"and retrying\\n\");\n\t\t\trc = ahci_do_softreset(link, class, 0, deadline,\n\t\t\t\t\t       ahci_check_ready);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint ahci_do_hardreset(struct ata_link *link, unsigned int *class,\n\t\t      unsigned long deadline, bool *online)\n{\n\tconst unsigned int *timing = sata_ehc_deb_timing(&link->eh_context);\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tstruct ata_taskfile tf;\n\tint rc;\n\n\thpriv->stop_engine(ap);\n\n\t \n\tata_tf_init(link->device, &tf);\n\ttf.status = ATA_BUSY;\n\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\tahci_port_clear_pending_irq(ap);\n\n\trc = sata_link_hardreset(link, timing, deadline, online,\n\t\t\t\t ahci_check_ready);\n\n\thpriv->start_engine(ap);\n\n\tif (*online)\n\t\t*class = ahci_dev_classify(ap);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_do_hardreset);\n\nstatic int ahci_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline)\n{\n\tbool online;\n\n\treturn ahci_do_hardreset(link, class, deadline, &online);\n}\n\nstatic void ahci_postreset(struct ata_link *link, unsigned int *class)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 new_tmp, tmp;\n\n\tata_std_postreset(link, class);\n\n\t \n\tnew_tmp = tmp = readl(port_mmio + PORT_CMD);\n\tif (*class == ATA_DEV_ATAPI)\n\t\tnew_tmp |= PORT_CMD_ATAPI;\n\telse\n\t\tnew_tmp &= ~PORT_CMD_ATAPI;\n\tif (new_tmp != tmp) {\n\t\twritel(new_tmp, port_mmio + PORT_CMD);\n\t\treadl(port_mmio + PORT_CMD);  \n\t}\n}\n\nstatic unsigned int ahci_fill_sg(struct ata_queued_cmd *qc, void *cmd_tbl)\n{\n\tstruct scatterlist *sg;\n\tstruct ahci_sg *ahci_sg = cmd_tbl + AHCI_CMD_TBL_HDR_SZ;\n\tunsigned int si;\n\n\t \n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tdma_addr_t addr = sg_dma_address(sg);\n\t\tu32 sg_len = sg_dma_len(sg);\n\n\t\tahci_sg[si].addr = cpu_to_le32(addr & 0xffffffff);\n\t\tahci_sg[si].addr_hi = cpu_to_le32((addr >> 16) >> 16);\n\t\tahci_sg[si].flags_size = cpu_to_le32(sg_len - 1);\n\t}\n\n\treturn si;\n}\n\nstatic int ahci_pmp_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\n\tif (!sata_pmp_attached(ap) || pp->fbs_enabled)\n\t\treturn ata_std_qc_defer(qc);\n\telse\n\t\treturn sata_pmp_qc_defer_cmd_switch(qc);\n}\n\nstatic enum ata_completion_errors ahci_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tint is_atapi = ata_is_atapi(qc->tf.protocol);\n\tvoid *cmd_tbl;\n\tu32 opts;\n\tconst u32 cmd_fis_len = 5;  \n\tunsigned int n_elem;\n\n\t \n\tcmd_tbl = pp->cmd_tbl + qc->hw_tag * AHCI_CMD_TBL_SZ;\n\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, cmd_tbl);\n\tif (is_atapi) {\n\t\tmemset(cmd_tbl + AHCI_CMD_TBL_CDB, 0, 32);\n\t\tmemcpy(cmd_tbl + AHCI_CMD_TBL_CDB, qc->cdb, qc->dev->cdb_len);\n\t}\n\n\tn_elem = 0;\n\tif (qc->flags & ATA_QCFLAG_DMAMAP)\n\t\tn_elem = ahci_fill_sg(qc, cmd_tbl);\n\n\t \n\topts = cmd_fis_len | n_elem << 16 | (qc->dev->link->pmp << 12);\n\tif (qc->tf.flags & ATA_TFLAG_WRITE)\n\t\topts |= AHCI_CMD_WRITE;\n\tif (is_atapi)\n\t\topts |= AHCI_CMD_ATAPI | AHCI_CMD_PREFETCH;\n\n\tahci_fill_cmd_slot(pp, qc->hw_tag, opts);\n\n\treturn AC_ERR_OK;\n}\n\nstatic void ahci_fbs_dec_intr(struct ata_port *ap)\n{\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 fbs = readl(port_mmio + PORT_FBS);\n\tint retries = 3;\n\n\tBUG_ON(!pp->fbs_enabled);\n\n\t \n\twritel(fbs | PORT_FBS_DEC, port_mmio + PORT_FBS);\n\tfbs = readl(port_mmio + PORT_FBS);\n\twhile ((fbs & PORT_FBS_DEC) && retries--) {\n\t\tudelay(1);\n\t\tfbs = readl(port_mmio + PORT_FBS);\n\t}\n\n\tif (fbs & PORT_FBS_DEC)\n\t\tdev_err(ap->host->dev, \"failed to clear device error\\n\");\n}\n\nstatic void ahci_error_intr(struct ata_port *ap, u32 irq_stat)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ata_eh_info *host_ehi = &ap->link.eh_info;\n\tstruct ata_link *link = NULL;\n\tstruct ata_queued_cmd *active_qc;\n\tstruct ata_eh_info *active_ehi;\n\tbool fbs_need_dec = false;\n\tu32 serror;\n\n\t \n\tif (pp->fbs_enabled) {\n\t\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\t\tu32 fbs = readl(port_mmio + PORT_FBS);\n\t\tint pmp = fbs >> PORT_FBS_DWE_OFFSET;\n\n\t\tif ((fbs & PORT_FBS_SDE) && (pmp < ap->nr_pmp_links)) {\n\t\t\tlink = &ap->pmp_link[pmp];\n\t\t\tfbs_need_dec = true;\n\t\t}\n\n\t} else\n\t\tata_for_each_link(link, ap, EDGE)\n\t\t\tif (ata_link_active(link))\n\t\t\t\tbreak;\n\n\tif (!link)\n\t\tlink = &ap->link;\n\n\tactive_qc = ata_qc_from_tag(ap, link->active_tag);\n\tactive_ehi = &link->eh_info;\n\n\t \n\tata_ehi_clear_desc(host_ehi);\n\tata_ehi_push_desc(host_ehi, \"irq_stat 0x%08x\", irq_stat);\n\n\t \n\tahci_scr_read(&ap->link, SCR_ERROR, &serror);\n\tahci_scr_write(&ap->link, SCR_ERROR, serror);\n\thost_ehi->serror |= serror;\n\n\t \n\tif (hpriv->flags & AHCI_HFLAG_IGN_IRQ_IF_ERR)\n\t\tirq_stat &= ~PORT_IRQ_IF_ERR;\n\n\tif (irq_stat & PORT_IRQ_TF_ERR) {\n\t\t \n\t\tif (active_qc)\n\t\t\tactive_qc->err_mask |= AC_ERR_DEV;\n\t\telse\n\t\t\tactive_ehi->err_mask |= AC_ERR_DEV;\n\n\t\tif (hpriv->flags & AHCI_HFLAG_IGN_SERR_INTERNAL)\n\t\t\thost_ehi->serror &= ~SERR_INTERNAL;\n\t}\n\n\tif (irq_stat & PORT_IRQ_UNK_FIS) {\n\t\tu32 *unk = pp->rx_fis + RX_FIS_UNK;\n\n\t\tactive_ehi->err_mask |= AC_ERR_HSM;\n\t\tactive_ehi->action |= ATA_EH_RESET;\n\t\tata_ehi_push_desc(active_ehi,\n\t\t\t\t  \"unknown FIS %08x %08x %08x %08x\" ,\n\t\t\t\t  unk[0], unk[1], unk[2], unk[3]);\n\t}\n\n\tif (sata_pmp_attached(ap) && (irq_stat & PORT_IRQ_BAD_PMP)) {\n\t\tactive_ehi->err_mask |= AC_ERR_HSM;\n\t\tactive_ehi->action |= ATA_EH_RESET;\n\t\tata_ehi_push_desc(active_ehi, \"incorrect PMP\");\n\t}\n\n\tif (irq_stat & (PORT_IRQ_HBUS_ERR | PORT_IRQ_HBUS_DATA_ERR)) {\n\t\thost_ehi->err_mask |= AC_ERR_HOST_BUS;\n\t\thost_ehi->action |= ATA_EH_RESET;\n\t\tata_ehi_push_desc(host_ehi, \"host bus error\");\n\t}\n\n\tif (irq_stat & PORT_IRQ_IF_ERR) {\n\t\tif (fbs_need_dec)\n\t\t\tactive_ehi->err_mask |= AC_ERR_DEV;\n\t\telse {\n\t\t\thost_ehi->err_mask |= AC_ERR_ATA_BUS;\n\t\t\thost_ehi->action |= ATA_EH_RESET;\n\t\t}\n\n\t\tata_ehi_push_desc(host_ehi, \"interface fatal error\");\n\t}\n\n\tif (irq_stat & (PORT_IRQ_CONNECT | PORT_IRQ_PHYRDY)) {\n\t\tata_ehi_hotplugged(host_ehi);\n\t\tata_ehi_push_desc(host_ehi, \"%s\",\n\t\t\tirq_stat & PORT_IRQ_CONNECT ?\n\t\t\t\"connection status changed\" : \"PHY RDY changed\");\n\t}\n\n\t \n\n\tif (irq_stat & PORT_IRQ_FREEZE)\n\t\tata_port_freeze(ap);\n\telse if (fbs_need_dec) {\n\t\tata_link_abort(link);\n\t\tahci_fbs_dec_intr(ap);\n\t} else\n\t\tata_port_abort(ap);\n}\n\nstatic void ahci_qc_complete(struct ata_port *ap, void __iomem *port_mmio)\n{\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tu32 qc_active = 0;\n\tint rc;\n\n\t \n\tif (pp->fbs_enabled) {\n\t\tif (ap->qc_active) {\n\t\t\tqc_active = readl(port_mmio + PORT_SCR_ACT);\n\t\t\tqc_active |= readl(port_mmio + PORT_CMD_ISSUE);\n\t\t}\n\t} else {\n\t\t \n\t\tif (ap->qc_active && pp->active_link->sactive)\n\t\t\tqc_active = readl(port_mmio + PORT_SCR_ACT);\n\t\telse\n\t\t\tqc_active = readl(port_mmio + PORT_CMD_ISSUE);\n\t}\n\n\trc = ata_qc_complete_multiple(ap, qc_active);\n\tif (unlikely(rc < 0 && !(ap->pflags & ATA_PFLAG_RESETTING))) {\n\t\tehi->err_mask |= AC_ERR_HSM;\n\t\tehi->action |= ATA_EH_RESET;\n\t\tata_port_freeze(ap);\n\t}\n}\n\nstatic void ahci_handle_port_interrupt(struct ata_port *ap,\n\t\t\t\t       void __iomem *port_mmio, u32 status)\n{\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\t \n\tif (unlikely(ap->pflags & ATA_PFLAG_RESETTING))\n\t\tstatus &= ~PORT_IRQ_BAD_PMP;\n\n\tif (sata_lpm_ignore_phy_events(&ap->link)) {\n\t\tstatus &= ~PORT_IRQ_PHYRDY;\n\t\tahci_scr_write(&ap->link, SCR_ERROR, SERR_PHYRDY_CHG);\n\t}\n\n\tif (unlikely(status & PORT_IRQ_ERROR)) {\n\t\t \n\t\tahci_qc_complete(ap, port_mmio);\n\t\tahci_error_intr(ap, status);\n\t\treturn;\n\t}\n\n\tif (status & PORT_IRQ_SDB_FIS) {\n\t\t \n\t\tif (hpriv->cap & HOST_CAP_SNTF)\n\t\t\tsata_async_notification(ap);\n\t\telse {\n\t\t\t \n\t\t\tif (pp->fbs_enabled)\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\telse {\n\t\t\t\tconst __le32 *f = pp->rx_fis + RX_FIS_SDB;\n\t\t\t\tu32 f0 = le32_to_cpu(f[0]);\n\t\t\t\tif (f0 & (1 << 15))\n\t\t\t\t\tsata_async_notification(ap);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tahci_qc_complete(ap, port_mmio);\n}\n\nstatic void ahci_port_intr(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 status;\n\n\tstatus = readl(port_mmio + PORT_IRQ_STAT);\n\twritel(status, port_mmio + PORT_IRQ_STAT);\n\n\tahci_handle_port_interrupt(ap, port_mmio, status);\n}\n\nstatic irqreturn_t ahci_multi_irqs_intr_hard(int irq, void *dev_instance)\n{\n\tstruct ata_port *ap = dev_instance;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 status;\n\n\tstatus = readl(port_mmio + PORT_IRQ_STAT);\n\twritel(status, port_mmio + PORT_IRQ_STAT);\n\n\tspin_lock(ap->lock);\n\tahci_handle_port_interrupt(ap, port_mmio, status);\n\tspin_unlock(ap->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nu32 ahci_handle_port_intr(struct ata_host *host, u32 irq_masked)\n{\n\tunsigned int i, handled = 0;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap;\n\n\t\tif (!(irq_masked & (1 << i)))\n\t\t\tcontinue;\n\n\t\tap = host->ports[i];\n\t\tif (ap) {\n\t\t\tahci_port_intr(ap);\n\t\t} else {\n\t\t\tif (ata_ratelimit())\n\t\t\t\tdev_warn(host->dev,\n\t\t\t\t\t \"interrupt on disabled port %u\\n\", i);\n\t\t}\n\n\t\thandled = 1;\n\t}\n\n\treturn handled;\n}\nEXPORT_SYMBOL_GPL(ahci_handle_port_intr);\n\nstatic irqreturn_t ahci_single_level_irq_intr(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tstruct ahci_host_priv *hpriv;\n\tunsigned int rc = 0;\n\tvoid __iomem *mmio;\n\tu32 irq_stat, irq_masked;\n\n\thpriv = host->private_data;\n\tmmio = hpriv->mmio;\n\n\t \n\tirq_stat = readl(mmio + HOST_IRQ_STAT);\n\tif (!irq_stat)\n\t\treturn IRQ_NONE;\n\n\tirq_masked = irq_stat & hpriv->port_map;\n\n\tspin_lock(&host->lock);\n\n\trc = ahci_handle_port_intr(host, irq_masked);\n\n\t \n\twritel(irq_stat, mmio + HOST_IRQ_STAT);\n\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_RETVAL(rc);\n}\n\nunsigned int ahci_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_port_priv *pp = ap->private_data;\n\n\t \n\tpp->active_link = qc->dev->link;\n\n\tif (ata_is_ncq(qc->tf.protocol))\n\t\twritel(1 << qc->hw_tag, port_mmio + PORT_SCR_ACT);\n\n\tif (pp->fbs_enabled && pp->fbs_last_dev != qc->dev->link->pmp) {\n\t\tu32 fbs = readl(port_mmio + PORT_FBS);\n\t\tfbs &= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);\n\t\tfbs |= qc->dev->link->pmp << PORT_FBS_DEV_OFFSET;\n\t\twritel(fbs, port_mmio + PORT_FBS);\n\t\tpp->fbs_last_dev = qc->dev->link->pmp;\n\t}\n\n\twritel(1 << qc->hw_tag, port_mmio + PORT_CMD_ISSUE);\n\n\tahci_sw_activity(qc->dev->link);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_qc_issue);\n\nstatic void ahci_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct ahci_port_priv *pp = qc->ap->private_data;\n\tu8 *rx_fis = pp->rx_fis;\n\n\t \n\tif (qc->flags & ATA_QCFLAG_RTF_FILLED)\n\t\treturn;\n\n\tif (pp->fbs_enabled)\n\t\trx_fis += qc->dev->link->pmp * AHCI_RX_FIS_SZ;\n\n\t \n\tif (qc->tf.protocol == ATA_PROT_PIO && qc->dma_dir == DMA_FROM_DEVICE &&\n\t    !(qc->flags & ATA_QCFLAG_EH)) {\n\t\tata_tf_from_fis(rx_fis + RX_FIS_PIO_SETUP, &qc->result_tf);\n\t\tqc->result_tf.status = (rx_fis + RX_FIS_PIO_SETUP)[15];\n\t\tqc->flags |= ATA_QCFLAG_RTF_FILLED;\n\t\treturn;\n\t}\n\n\t \n\tif (ata_is_ncq(qc->tf.protocol)) {\n\t\tconst u8 *fis = rx_fis + RX_FIS_SDB;\n\n\t\t \n\t\tqc->result_tf.status = fis[2];\n\t\tqc->result_tf.error = fis[3];\n\t\tqc->flags |= ATA_QCFLAG_RTF_FILLED;\n\t\treturn;\n\t}\n\n\tata_tf_from_fis(rx_fis + RX_FIS_D2H_REG, &qc->result_tf);\n\tqc->flags |= ATA_QCFLAG_RTF_FILLED;\n}\n\nstatic void ahci_qc_ncq_fill_rtf(struct ata_port *ap, u64 done_mask)\n{\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tconst u8 *fis;\n\n\t \n\tif (!ap->qc_active)\n\t\treturn;\n\n\t \n\tif (!pp->fbs_enabled) {\n\t\tu8 status, error;\n\n\t\t \n\t\tif (!pp->active_link->sactive)\n\t\t\treturn;\n\n\t\tfis = pp->rx_fis + RX_FIS_SDB;\n\t\tstatus = fis[2];\n\t\terror = fis[3];\n\n\t\twhile (done_mask) {\n\t\t\tstruct ata_queued_cmd *qc;\n\t\t\tunsigned int tag = __ffs64(done_mask);\n\n\t\t\tqc = ata_qc_from_tag(ap, tag);\n\t\t\tif (qc && ata_is_ncq(qc->tf.protocol)) {\n\t\t\t\tqc->result_tf.status = status;\n\t\t\t\tqc->result_tf.error = error;\n\t\t\t\tqc->flags |= ATA_QCFLAG_RTF_FILLED;\n\t\t\t}\n\t\t\tdone_mask &= ~(1ULL << tag);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\twhile (done_mask) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag = __ffs64(done_mask);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (qc && ata_is_ncq(qc->tf.protocol)) {\n\t\t\tfis = pp->rx_fis;\n\t\t\tfis += qc->dev->link->pmp * AHCI_RX_FIS_SZ;\n\t\t\tfis += RX_FIS_SDB;\n\t\t\tqc->result_tf.status = fis[2];\n\t\t\tqc->result_tf.error = fis[3];\n\t\t\tqc->flags |= ATA_QCFLAG_RTF_FILLED;\n\t\t}\n\t\tdone_mask &= ~(1ULL << tag);\n\t}\n}\n\nstatic void ahci_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\n\t \n\twritel(0, port_mmio + PORT_IRQ_MASK);\n}\n\nstatic void ahci_thaw(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 tmp;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\n\t \n\ttmp = readl(port_mmio + PORT_IRQ_STAT);\n\twritel(tmp, port_mmio + PORT_IRQ_STAT);\n\twritel(1 << ap->port_no, mmio + HOST_IRQ_STAT);\n\n\t \n\twritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\n}\n\nvoid ahci_error_handler(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\tif (!ata_port_is_frozen(ap)) {\n\t\t \n\t\thpriv->stop_engine(ap);\n\t\thpriv->start_engine(ap);\n\t}\n\n\tsata_pmp_error_handler(ap);\n\n\tif (!ata_dev_enabled(ap->link.device))\n\t\thpriv->stop_engine(ap);\n}\nEXPORT_SYMBOL_GPL(ahci_error_handler);\n\nstatic void ahci_post_internal_cmd(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\t \n\tif (qc->flags & ATA_QCFLAG_EH)\n\t\tahci_kick_engine(ap);\n}\n\nstatic void ahci_set_aggressive_devslp(struct ata_port *ap, bool sleep)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ata_device *dev = ap->link.device;\n\tu32 devslp, dm, dito, mdat, deto, dito_conf;\n\tint rc;\n\tunsigned int err_mask;\n\n\tdevslp = readl(port_mmio + PORT_DEVSLP);\n\tif (!(devslp & PORT_DEVSLP_DSP)) {\n\t\tdev_info(ap->host->dev, \"port does not support device sleep\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!sleep) {\n\t\tif (devslp & PORT_DEVSLP_ADSE) {\n\t\t\twritel(devslp & ~PORT_DEVSLP_ADSE,\n\t\t\t       port_mmio + PORT_DEVSLP);\n\t\t\terr_mask = ata_dev_set_feature(dev,\n\t\t\t\t\t\t       SETFEATURES_SATA_DISABLE,\n\t\t\t\t\t\t       SATA_DEVSLP);\n\t\t\tif (err_mask && err_mask != AC_ERR_DEV)\n\t\t\t\tata_dev_warn(dev, \"failed to disable DEVSLP\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\tdm = (devslp & PORT_DEVSLP_DM_MASK) >> PORT_DEVSLP_DM_OFFSET;\n\tdito = devslp_idle_timeout / (dm + 1);\n\tif (dito > 0x3ff)\n\t\tdito = 0x3ff;\n\n\tdito_conf = (devslp >> PORT_DEVSLP_DITO_OFFSET) & 0x3FF;\n\n\t \n\tif ((devslp & PORT_DEVSLP_ADSE) && (dito_conf == dito))\n\t\treturn;\n\n\t \n\trc = hpriv->stop_engine(ap);\n\tif (rc)\n\t\treturn;\n\n\t \n\tif (dev->devslp_timing[ATA_LOG_DEVSLP_VALID] &\n\t    ATA_LOG_DEVSLP_VALID_MASK) {\n\t\tmdat = dev->devslp_timing[ATA_LOG_DEVSLP_MDAT] &\n\t\t       ATA_LOG_DEVSLP_MDAT_MASK;\n\t\tif (!mdat)\n\t\t\tmdat = 10;\n\t\tdeto = dev->devslp_timing[ATA_LOG_DEVSLP_DETO];\n\t\tif (!deto)\n\t\t\tdeto = 20;\n\t} else {\n\t\tmdat = 10;\n\t\tdeto = 20;\n\t}\n\n\t \n\tdevslp &= ~GENMASK_ULL(24, 2);\n\tdevslp |= ((dito << PORT_DEVSLP_DITO_OFFSET) |\n\t\t   (mdat << PORT_DEVSLP_MDAT_OFFSET) |\n\t\t   (deto << PORT_DEVSLP_DETO_OFFSET) |\n\t\t   PORT_DEVSLP_ADSE);\n\twritel(devslp, port_mmio + PORT_DEVSLP);\n\n\thpriv->start_engine(ap);\n\n\t \n\terr_mask = ata_dev_set_feature(dev,\n\t\t\t\t       SETFEATURES_SATA_ENABLE,\n\t\t\t\t       SATA_DEVSLP);\n\tif (err_mask && err_mask != AC_ERR_DEV)\n\t\tata_dev_warn(dev, \"failed to enable DEVSLP\\n\");\n}\n\nstatic void ahci_enable_fbs(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 fbs;\n\tint rc;\n\n\tif (!pp->fbs_supported)\n\t\treturn;\n\n\tfbs = readl(port_mmio + PORT_FBS);\n\tif (fbs & PORT_FBS_EN) {\n\t\tpp->fbs_enabled = true;\n\t\tpp->fbs_last_dev = -1;  \n\t\treturn;\n\t}\n\n\trc = hpriv->stop_engine(ap);\n\tif (rc)\n\t\treturn;\n\n\twritel(fbs | PORT_FBS_EN, port_mmio + PORT_FBS);\n\tfbs = readl(port_mmio + PORT_FBS);\n\tif (fbs & PORT_FBS_EN) {\n\t\tdev_info(ap->host->dev, \"FBS is enabled\\n\");\n\t\tpp->fbs_enabled = true;\n\t\tpp->fbs_last_dev = -1;  \n\t} else\n\t\tdev_err(ap->host->dev, \"Failed to enable FBS\\n\");\n\n\thpriv->start_engine(ap);\n}\n\nstatic void ahci_disable_fbs(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 fbs;\n\tint rc;\n\n\tif (!pp->fbs_supported)\n\t\treturn;\n\n\tfbs = readl(port_mmio + PORT_FBS);\n\tif ((fbs & PORT_FBS_EN) == 0) {\n\t\tpp->fbs_enabled = false;\n\t\treturn;\n\t}\n\n\trc = hpriv->stop_engine(ap);\n\tif (rc)\n\t\treturn;\n\n\twritel(fbs & ~PORT_FBS_EN, port_mmio + PORT_FBS);\n\tfbs = readl(port_mmio + PORT_FBS);\n\tif (fbs & PORT_FBS_EN)\n\t\tdev_err(ap->host->dev, \"Failed to disable FBS\\n\");\n\telse {\n\t\tdev_info(ap->host->dev, \"FBS is disabled\\n\");\n\t\tpp->fbs_enabled = false;\n\t}\n\n\thpriv->start_engine(ap);\n}\n\nstatic void ahci_pmp_attach(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tu32 cmd;\n\n\tcmd = readl(port_mmio + PORT_CMD);\n\tcmd |= PORT_CMD_PMP;\n\twritel(cmd, port_mmio + PORT_CMD);\n\n\tahci_enable_fbs(ap);\n\n\tpp->intr_mask |= PORT_IRQ_BAD_PMP;\n\n\t \n\tif (!ata_port_is_frozen(ap))\n\t\twritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\n}\n\nstatic void ahci_pmp_detach(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tu32 cmd;\n\n\tahci_disable_fbs(ap);\n\n\tcmd = readl(port_mmio + PORT_CMD);\n\tcmd &= ~PORT_CMD_PMP;\n\twritel(cmd, port_mmio + PORT_CMD);\n\n\tpp->intr_mask &= ~PORT_IRQ_BAD_PMP;\n\n\t \n\tif (!ata_port_is_frozen(ap))\n\t\twritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\n}\n\nint ahci_port_resume(struct ata_port *ap)\n{\n\tahci_rpm_get_port(ap);\n\n\tahci_power_up(ap);\n\tahci_start_port(ap);\n\n\tif (sata_pmp_attached(ap))\n\t\tahci_pmp_attach(ap);\n\telse\n\t\tahci_pmp_detach(ap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ahci_port_resume);\n\n#ifdef CONFIG_PM\nstatic void ahci_handle_s2idle(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 devslp;\n\n\tif (pm_suspend_via_firmware())\n\t\treturn;\n\tdevslp = readl(port_mmio + PORT_DEVSLP);\n\tif ((devslp & PORT_DEVSLP_ADSE))\n\t\tata_msleep(ap, devslp_idle_timeout);\n}\n\nstatic int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)\n{\n\tconst char *emsg = NULL;\n\tint rc;\n\n\trc = ahci_deinit_port(ap, &emsg);\n\tif (rc == 0)\n\t\tahci_power_down(ap);\n\telse {\n\t\tata_port_err(ap, \"%s (%d)\\n\", emsg, rc);\n\t\tata_port_freeze(ap);\n\t}\n\n\tif (acpi_storage_d3(ap->host->dev))\n\t\tahci_handle_s2idle(ap);\n\n\tahci_rpm_put_port(ap);\n\treturn rc;\n}\n#endif\n\nstatic int ahci_port_start(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct device *dev = ap->host->dev;\n\tstruct ahci_port_priv *pp;\n\tvoid *mem;\n\tdma_addr_t mem_dma;\n\tsize_t dma_sz, rx_fis_sz;\n\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tif (ap->host->n_ports > 1) {\n\t\tpp->irq_desc = devm_kzalloc(dev, 8, GFP_KERNEL);\n\t\tif (!pp->irq_desc) {\n\t\t\tdevm_kfree(dev, pp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsnprintf(pp->irq_desc, 8,\n\t\t\t \"%s%d\", dev_driver_string(dev), ap->port_no);\n\t}\n\n\t \n\tif ((hpriv->cap & HOST_CAP_FBS) && sata_pmp_supported(ap)) {\n\t\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\t\tu32 cmd = readl(port_mmio + PORT_CMD);\n\t\tif (cmd & PORT_CMD_FBSCP)\n\t\t\tpp->fbs_supported = true;\n\t\telse if (hpriv->flags & AHCI_HFLAG_YES_FBS) {\n\t\t\tdev_info(dev, \"port %d can do FBS, forcing FBSCP\\n\",\n\t\t\t\t ap->port_no);\n\t\t\tpp->fbs_supported = true;\n\t\t} else\n\t\t\tdev_warn(dev, \"port %d is not capable of FBS\\n\",\n\t\t\t\t ap->port_no);\n\t}\n\n\tif (pp->fbs_supported) {\n\t\tdma_sz = AHCI_PORT_PRIV_FBS_DMA_SZ;\n\t\trx_fis_sz = AHCI_RX_FIS_SZ * 16;\n\t} else {\n\t\tdma_sz = AHCI_PORT_PRIV_DMA_SZ;\n\t\trx_fis_sz = AHCI_RX_FIS_SZ;\n\t}\n\n\tmem = dmam_alloc_coherent(dev, dma_sz, &mem_dma, GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\t \n\tpp->cmd_slot = mem;\n\tpp->cmd_slot_dma = mem_dma;\n\n\tmem += AHCI_CMD_SLOT_SZ;\n\tmem_dma += AHCI_CMD_SLOT_SZ;\n\n\t \n\tpp->rx_fis = mem;\n\tpp->rx_fis_dma = mem_dma;\n\n\tmem += rx_fis_sz;\n\tmem_dma += rx_fis_sz;\n\n\t \n\tpp->cmd_tbl = mem;\n\tpp->cmd_tbl_dma = mem_dma;\n\n\t \n\tpp->intr_mask = DEF_PORT_IRQ;\n\n\t \n\tif (hpriv->flags & AHCI_HFLAG_MULTI_MSI) {\n\t\tspin_lock_init(&pp->lock);\n\t\tap->lock = &pp->lock;\n\t}\n\n\tap->private_data = pp;\n\n\t \n\treturn ahci_port_resume(ap);\n}\n\nstatic void ahci_port_stop(struct ata_port *ap)\n{\n\tconst char *emsg = NULL;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tvoid __iomem *host_mmio = hpriv->mmio;\n\tint rc;\n\n\t \n\trc = ahci_deinit_port(ap, &emsg);\n\tif (rc)\n\t\tata_port_warn(ap, \"%s (%d)\\n\", emsg, rc);\n\n\t \n\twritel(1 << ap->port_no, host_mmio + HOST_IRQ_STAT);\n\n\tahci_rpm_put_port(ap);\n}\n\nvoid ahci_print_info(struct ata_host *host, const char *scc_s)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tu32 vers, cap, cap2, impl, speed;\n\tconst char *speed_s;\n\n\tvers = hpriv->version;\n\tcap = hpriv->cap;\n\tcap2 = hpriv->cap2;\n\timpl = hpriv->port_map;\n\n\tspeed = (cap >> 20) & 0xf;\n\tif (speed == 1)\n\t\tspeed_s = \"1.5\";\n\telse if (speed == 2)\n\t\tspeed_s = \"3\";\n\telse if (speed == 3)\n\t\tspeed_s = \"6\";\n\telse\n\t\tspeed_s = \"?\";\n\n\tdev_info(host->dev,\n\t\t\"AHCI %02x%02x.%02x%02x \"\n\t\t\"%u slots %u ports %s Gbps 0x%x impl %s mode\\n\"\n\t\t,\n\n\t\t(vers >> 24) & 0xff,\n\t\t(vers >> 16) & 0xff,\n\t\t(vers >> 8) & 0xff,\n\t\tvers & 0xff,\n\n\t\t((cap >> 8) & 0x1f) + 1,\n\t\t(cap & 0x1f) + 1,\n\t\tspeed_s,\n\t\timpl,\n\t\tscc_s);\n\n\tdev_info(host->dev,\n\t\t\"flags: \"\n\t\t\"%s%s%s%s%s%s%s\"\n\t\t\"%s%s%s%s%s%s%s\"\n\t\t\"%s%s%s%s%s%s%s\"\n\t\t\"%s%s\\n\"\n\t\t,\n\n\t\tcap & HOST_CAP_64 ? \"64bit \" : \"\",\n\t\tcap & HOST_CAP_NCQ ? \"ncq \" : \"\",\n\t\tcap & HOST_CAP_SNTF ? \"sntf \" : \"\",\n\t\tcap & HOST_CAP_MPS ? \"ilck \" : \"\",\n\t\tcap & HOST_CAP_SSS ? \"stag \" : \"\",\n\t\tcap & HOST_CAP_ALPM ? \"pm \" : \"\",\n\t\tcap & HOST_CAP_LED ? \"led \" : \"\",\n\t\tcap & HOST_CAP_CLO ? \"clo \" : \"\",\n\t\tcap & HOST_CAP_ONLY ? \"only \" : \"\",\n\t\tcap & HOST_CAP_PMP ? \"pmp \" : \"\",\n\t\tcap & HOST_CAP_FBS ? \"fbs \" : \"\",\n\t\tcap & HOST_CAP_PIO_MULTI ? \"pio \" : \"\",\n\t\tcap & HOST_CAP_SSC ? \"slum \" : \"\",\n\t\tcap & HOST_CAP_PART ? \"part \" : \"\",\n\t\tcap & HOST_CAP_CCC ? \"ccc \" : \"\",\n\t\tcap & HOST_CAP_EMS ? \"ems \" : \"\",\n\t\tcap & HOST_CAP_SXS ? \"sxs \" : \"\",\n\t\tcap2 & HOST_CAP2_DESO ? \"deso \" : \"\",\n\t\tcap2 & HOST_CAP2_SADM ? \"sadm \" : \"\",\n\t\tcap2 & HOST_CAP2_SDS ? \"sds \" : \"\",\n\t\tcap2 & HOST_CAP2_APST ? \"apst \" : \"\",\n\t\tcap2 & HOST_CAP2_NVMHCI ? \"nvmp \" : \"\",\n\t\tcap2 & HOST_CAP2_BOH ? \"boh \" : \"\"\n\t\t);\n}\nEXPORT_SYMBOL_GPL(ahci_print_info);\n\nvoid ahci_set_em_messages(struct ahci_host_priv *hpriv,\n\t\t\t  struct ata_port_info *pi)\n{\n\tu8 messages;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 em_loc = readl(mmio + HOST_EM_LOC);\n\tu32 em_ctl = readl(mmio + HOST_EM_CTL);\n\n\tif (!ahci_em_messages || !(hpriv->cap & HOST_CAP_EMS))\n\t\treturn;\n\n\tmessages = (em_ctl & EM_CTRL_MSG_TYPE) >> 16;\n\n\tif (messages) {\n\t\t \n\t\thpriv->em_loc = ((em_loc >> 16) * 4);\n\t\thpriv->em_buf_sz = ((em_loc & 0xff) * 4);\n\t\thpriv->em_msg_type = messages;\n\t\tpi->flags |= ATA_FLAG_EM;\n\t\tif (!(em_ctl & EM_CTL_ALHD))\n\t\t\tpi->flags |= ATA_FLAG_SW_ACTIVITY;\n\t}\n}\nEXPORT_SYMBOL_GPL(ahci_set_em_messages);\n\nstatic int ahci_host_activate_multi_irqs(struct ata_host *host,\n\t\t\t\t\t const struct scsi_host_template *sht)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint i, rc;\n\n\trc = ata_host_start(host);\n\tif (rc)\n\t\treturn rc;\n\t \n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ahci_port_priv *pp = host->ports[i]->private_data;\n\t\tint irq = hpriv->get_irq_vector(host, i);\n\n\t\t \n\t\tif (!pp) {\n\t\t\tdisable_irq(irq);\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = devm_request_irq(host->dev, irq, ahci_multi_irqs_intr_hard,\n\t\t\t\t0, pp->irq_desc, host->ports[i]);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tata_port_desc(host->ports[i], \"irq %d\", irq);\n\t}\n\n\treturn ata_host_register(host, sht);\n}\n\n \nint ahci_host_activate(struct ata_host *host, const struct scsi_host_template *sht)\n{\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint irq = hpriv->irq;\n\tint rc;\n\n\tif (hpriv->flags & AHCI_HFLAG_MULTI_MSI) {\n\t\tif (hpriv->irq_handler &&\n\t\t    hpriv->irq_handler != ahci_single_level_irq_intr)\n\t\t\tdev_warn(host->dev,\n\t\t\t         \"both AHCI_HFLAG_MULTI_MSI flag set and custom irq handler implemented\\n\");\n\t\tif (!hpriv->get_irq_vector) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t\"AHCI_HFLAG_MULTI_MSI requires ->get_irq_vector!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\trc = ahci_host_activate_multi_irqs(host, sht);\n\t} else {\n\t\trc = ata_host_activate(host, irq, hpriv->irq_handler,\n\t\t\t\t       IRQF_SHARED, sht);\n\t}\n\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ahci_host_activate);\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"Common AHCI SATA low-level routines\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}