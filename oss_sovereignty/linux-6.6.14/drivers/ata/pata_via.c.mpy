{
  "module_name": "pata_via.c",
  "hash_id": "48732d7677450b5e4f969d07984c2f70a5db00287da77c64a39f621cdedeb8ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_via.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n\n#define DRV_NAME \"pata_via\"\n#define DRV_VERSION \"0.3.4\"\n\nenum {\n\tVIA_BAD_PREQ\t= 0x01,  \n\tVIA_BAD_CLK66\t= 0x02,  \n\tVIA_SET_FIFO\t= 0x04,  \n\tVIA_NO_UNMASK\t= 0x08,  \n\tVIA_BAD_ID\t= 0x10,  \n\tVIA_BAD_AST\t= 0x20,  \n\tVIA_NO_ENABLES\t= 0x40,  \n\tVIA_SATA_PATA\t= 0x80,  \n};\n\nenum {\n\tVIA_IDFLAG_SINGLE = (1 << 0),  \n};\n\n \n\nstatic const struct via_isa_bridge {\n\tconst char *name;\n\tu16 id;\n\tu8 rev_min;\n\tu8 rev_max;\n\tu8 udma_mask;\n\tu8 flags;\n} via_isa_bridges[] = {\n\t{ \"vx855\",\tPCI_DEVICE_ID_VIA_VX855,    0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST | VIA_SATA_PATA },\n\t{ \"vx800\",\tPCI_DEVICE_ID_VIA_VX800,    0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST | VIA_SATA_PATA },\n\t{ \"vt8261\",\tPCI_DEVICE_ID_VIA_8261,     0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"vt8237s\",\tPCI_DEVICE_ID_VIA_8237S,    0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"vt8251\",\tPCI_DEVICE_ID_VIA_8251,     0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"cx700\",\tPCI_DEVICE_ID_VIA_CX700,    0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST | VIA_SATA_PATA },\n\t{ \"vt6410\",\tPCI_DEVICE_ID_VIA_6410,     0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST | VIA_NO_ENABLES },\n\t{ \"vt6415\",\tPCI_DEVICE_ID_VIA_6415,     0x00, 0xff, ATA_UDMA6, VIA_BAD_AST | VIA_NO_ENABLES },\n\t{ \"vt8237a\",\tPCI_DEVICE_ID_VIA_8237A,    0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"vt8237\",\tPCI_DEVICE_ID_VIA_8237,     0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"vt8235\",\tPCI_DEVICE_ID_VIA_8235,     0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"vt8233a\",\tPCI_DEVICE_ID_VIA_8233A,    0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ \"vt8233c\",\tPCI_DEVICE_ID_VIA_8233C_0,  0x00, 0x2f, ATA_UDMA5, },\n\t{ \"vt8233\",\tPCI_DEVICE_ID_VIA_8233_0,   0x00, 0x2f, ATA_UDMA5, },\n\t{ \"vt8231\",\tPCI_DEVICE_ID_VIA_8231,     0x00, 0x2f, ATA_UDMA5, },\n\t{ \"vt82c686b\",\tPCI_DEVICE_ID_VIA_82C686,   0x40, 0x4f, ATA_UDMA5, },\n\t{ \"vt82c686a\",\tPCI_DEVICE_ID_VIA_82C686,   0x10, 0x2f, ATA_UDMA4, },\n\t{ \"vt82c686\",\tPCI_DEVICE_ID_VIA_82C686,   0x00, 0x0f, ATA_UDMA2, VIA_BAD_CLK66 },\n\t{ \"vt82c596b\",\tPCI_DEVICE_ID_VIA_82C596,   0x10, 0x2f, ATA_UDMA4, },\n\t{ \"vt82c596a\",\tPCI_DEVICE_ID_VIA_82C596,   0x00, 0x0f, ATA_UDMA2, VIA_BAD_CLK66 },\n\t{ \"vt82c586b\",\tPCI_DEVICE_ID_VIA_82C586_0, 0x47, 0x4f, ATA_UDMA2, VIA_SET_FIFO },\n\t{ \"vt82c586b\",\tPCI_DEVICE_ID_VIA_82C586_0, 0x40, 0x46, ATA_UDMA2, VIA_SET_FIFO | VIA_BAD_PREQ },\n\t{ \"vt82c586b\",\tPCI_DEVICE_ID_VIA_82C586_0, 0x30, 0x3f, ATA_UDMA2, VIA_SET_FIFO },\n\t{ \"vt82c586a\",\tPCI_DEVICE_ID_VIA_82C586_0, 0x20, 0x2f, ATA_UDMA2, VIA_SET_FIFO },\n\t{ \"vt82c586\",\tPCI_DEVICE_ID_VIA_82C586_0, 0x00, 0x0f,      0x00, VIA_SET_FIFO },\n\t{ \"vt82c576\",\tPCI_DEVICE_ID_VIA_82C576,   0x00, 0x2f,      0x00, VIA_SET_FIFO | VIA_NO_UNMASK },\n\t{ \"vt82c576\",\tPCI_DEVICE_ID_VIA_82C576,   0x00, 0x2f,      0x00, VIA_SET_FIFO | VIA_NO_UNMASK | VIA_BAD_ID },\n\t{ \"vtxxxx\",\tPCI_DEVICE_ID_VIA_ANON,     0x00, 0x2f, ATA_UDMA6, VIA_BAD_AST },\n\t{ NULL }\n};\n\nstatic const struct dmi_system_id no_atapi_dma_dmi_table[] = {\n\t{\n\t\t.ident = \"AVERATEC 3200\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AVERATEC\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"3200\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstruct via_port {\n\tu8 cached_device;\n};\n\n \n\nstatic const struct dmi_system_id cable_dmi_table[] = {\n\t{\n\t\t.ident = \"Acer Ferrari 3400\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Acer,Inc.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Ferrari 3400\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int via_cable_override(struct pci_dev *pdev)\n{\n\t \n\tif (dmi_check_system(cable_dmi_table))\n\t\treturn 1;\n\t \n\tif (pdev->subsystem_vendor == 0x161F && pdev->subsystem_device == 0x2032)\n\t\treturn 1;\n\treturn 0;\n}\n\n\n \n\nstatic int via_cable_detect(struct ata_port *ap) {\n\tconst struct via_isa_bridge *config = ap->host->private_data;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 ata66;\n\n\tif (via_cable_override(pdev))\n\t\treturn ATA_CBL_PATA40_SHORT;\n\n\tif ((config->flags & VIA_SATA_PATA) && ap->port_no == 0)\n\t\treturn ATA_CBL_SATA;\n\n\t \n\tif (config->udma_mask < ATA_UDMA4)\n\t\treturn ATA_CBL_PATA40;\n\t \n\telse if (config->udma_mask < ATA_UDMA5)\n\t\treturn ATA_CBL_PATA_UNK;\n\t \n\tpci_read_config_dword(pdev, 0x50, &ata66);\n\t \n\tif (ata66 & (0x10100000 >> (16 * ap->port_no)))\n\t\treturn ATA_CBL_PATA80;\n\t \n\tif (ata_acpi_init_gtm(ap) &&\n\t    ata_acpi_cbl_80wire(ap, ata_acpi_init_gtm(ap)))\n\t\treturn ATA_CBL_PATA80;\n\treturn ATA_CBL_PATA40;\n}\n\nstatic int via_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tconst struct via_isa_bridge *config = ap->host->private_data;\n\n\tif (!(config->flags & VIA_NO_ENABLES)) {\n\t\tstatic const struct pci_bits via_enable_bits[] = {\n\t\t\t{ 0x40, 1, 0x02, 0x02 },\n\t\t\t{ 0x40, 1, 0x01, 0x01 }\n\t\t};\n\t\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\t\tif (!pci_test_config_bits(pdev, &via_enable_bits[ap->port_no]))\n\t\t\treturn -ENOENT;\n\t}\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\n\n \n\nstatic void via_do_set_mode(struct ata_port *ap, struct ata_device *adev,\n\t\t\t    int mode, int set_ast, int udma_type)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct ata_device *peer = ata_dev_pair(adev);\n\tstruct ata_timing t, p;\n\tconst int via_clock = 33333;\t \n\tconst int T = 1000000000 / via_clock;\n\tint UT = T;\n\tint ut;\n\tint offset = 3 - (2*ap->port_no) - adev->devno;\n\n\tswitch (udma_type) {\n\tcase ATA_UDMA4:\n\t\tUT = T / 2; break;\n\tcase ATA_UDMA5:\n\t\tUT = T / 3; break;\n\tcase ATA_UDMA6:\n\t\tUT = T / 4; break;\n\t}\n\n\t \n\tata_timing_compute(adev, mode, &t, T, UT);\n\n\t \n\tif (peer) {\n\t\tif (peer->pio_mode) {\n\t\t\tata_timing_compute(peer, peer->pio_mode, &p, T, UT);\n\t\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_8BIT);\n\t\t}\n\t}\n\n\t \n\tif (set_ast) {\n\t\tu8 setup;\t \n\t\tint shift = 2 * offset;\n\n\t\tpci_read_config_byte(pdev, 0x4C, &setup);\n\t\tsetup &= ~(3 << shift);\n\t\tsetup |= (clamp_val(t.setup, 1, 4) - 1) << shift;\n\t\tpci_write_config_byte(pdev, 0x4C, setup);\n\t}\n\n\t \n\tpci_write_config_byte(pdev, 0x4F - ap->port_no,\n\t\t((clamp_val(t.act8b, 1, 16) - 1) << 4) | (clamp_val(t.rec8b, 1, 16) - 1));\n\tpci_write_config_byte(pdev, 0x48 + offset,\n\t\t((clamp_val(t.active, 1, 16) - 1) << 4) | (clamp_val(t.recover, 1, 16) - 1));\n\n\t \n\tswitch (udma_type) {\n\tcase ATA_UDMA2:\n\tdefault:\n\t\tut = t.udma ? (0xe0 | (clamp_val(t.udma, 2, 5) - 2)) : 0x03;\n\t\tbreak;\n\tcase ATA_UDMA4:\n\t\tut = t.udma ? (0xe8 | (clamp_val(t.udma, 2, 9) - 2)) : 0x0f;\n\t\tbreak;\n\tcase ATA_UDMA5:\n\t\tut = t.udma ? (0xe0 | (clamp_val(t.udma, 2, 9) - 2)) : 0x07;\n\t\tbreak;\n\tcase ATA_UDMA6:\n\t\tut = t.udma ? (0xe0 | (clamp_val(t.udma, 2, 9) - 2)) : 0x07;\n\t\tbreak;\n\t}\n\n\t \n\tif (udma_type) {\n\t\tu8 udma_etc;\n\n\t\tpci_read_config_byte(pdev, 0x50 + offset, &udma_etc);\n\n\t\t \n\t\tudma_etc &= ~0x20;\n\n\t\tif (t.udma) {\n\t\t\t \n\t\t\tudma_etc &= 0x10;\n\t\t\tudma_etc |= ut;\n\t\t}\n\n\t\tpci_write_config_byte(pdev, 0x50 + offset, udma_etc);\n\t}\n}\n\nstatic void via_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tconst struct via_isa_bridge *config = ap->host->private_data;\n\tint set_ast = (config->flags & VIA_BAD_AST) ? 0 : 1;\n\n\tvia_do_set_mode(ap, adev, adev->pio_mode, set_ast, config->udma_mask);\n}\n\nstatic void via_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tconst struct via_isa_bridge *config = ap->host->private_data;\n\tint set_ast = (config->flags & VIA_BAD_AST) ? 0 : 1;\n\n\tvia_do_set_mode(ap, adev, adev->dma_mode, set_ast, config->udma_mask);\n}\n\n \n\nstatic unsigned int via_mode_filter(struct ata_device *dev, unsigned int mask)\n{\n\tstruct ata_host *host = dev->link->ap->host;\n\tconst struct via_isa_bridge *config = host->private_data;\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\n\tif (config->id == PCI_DEVICE_ID_VIA_82C586_0) {\n\t\tata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\t\tif (strcmp(model_num, \"TS64GSSD25-M\") == 0) {\n\t\t\tata_dev_warn(dev,\n\t\"disabling UDMA mode due to reported lockups with this device\\n\");\n\t\t\tmask &= ~ ATA_MASK_UDMA;\n\t\t}\n\t}\n\n\tif (dev->class == ATA_DEV_ATAPI &&\n\t    dmi_check_system(no_atapi_dma_dmi_table)) {\n\t\tata_dev_warn(dev, \"controller locks up on ATAPI DMA, forcing PIO\\n\");\n\t\tmask &= ATA_MASK_PIO;\n\t}\n\n\treturn mask;\n}\n\n \nstatic void via_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\tstruct via_port *vp = ap->private_data;\n\tunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\n\tint newctl = 0;\n\n\tif (tf->ctl != ap->last_ctl) {\n\t\tiowrite8(tf->ctl, ioaddr->ctl_addr);\n\t\tap->last_ctl = tf->ctl;\n\t\tata_wait_idle(ap);\n\t\tnewctl = 1;\n\t}\n\n\tif (tf->flags & ATA_TFLAG_DEVICE) {\n\t\tiowrite8(tf->device, ioaddr->device_addr);\n\t\tvp->cached_device = tf->device;\n\t} else if (newctl)\n\t\tiowrite8(vp->cached_device, ioaddr->device_addr);\n\n\tif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\n\t\tWARN_ON_ONCE(!ioaddr->ctl_addr);\n\t\tiowrite8(tf->hob_feature, ioaddr->feature_addr);\n\t\tiowrite8(tf->hob_nsect, ioaddr->nsect_addr);\n\t\tiowrite8(tf->hob_lbal, ioaddr->lbal_addr);\n\t\tiowrite8(tf->hob_lbam, ioaddr->lbam_addr);\n\t\tiowrite8(tf->hob_lbah, ioaddr->lbah_addr);\n\t}\n\n\tif (is_addr) {\n\t\tiowrite8(tf->feature, ioaddr->feature_addr);\n\t\tiowrite8(tf->nsect, ioaddr->nsect_addr);\n\t\tiowrite8(tf->lbal, ioaddr->lbal_addr);\n\t\tiowrite8(tf->lbam, ioaddr->lbam_addr);\n\t\tiowrite8(tf->lbah, ioaddr->lbah_addr);\n\t}\n\n\tata_wait_idle(ap);\n}\n\nstatic int via_port_start(struct ata_port *ap)\n{\n\tstruct via_port *vp;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tint ret = ata_bmdma_port_start(ap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvp = devm_kzalloc(&pdev->dev, sizeof(struct via_port), GFP_KERNEL);\n\tif (vp == NULL)\n\t\treturn -ENOMEM;\n\tap->private_data = vp;\n\treturn 0;\n}\n\nstatic const struct scsi_host_template via_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations via_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.cable_detect\t= via_cable_detect,\n\t.set_piomode\t= via_set_piomode,\n\t.set_dmamode\t= via_set_dmamode,\n\t.prereset\t= via_pre_reset,\n\t.sff_tf_load\t= via_tf_load,\n\t.port_start\t= via_port_start,\n\t.mode_filter\t= via_mode_filter,\n};\n\nstatic struct ata_port_operations via_port_ops_noirq = {\n\t.inherits\t= &via_port_ops,\n\t.sff_data_xfer\t= ata_sff_data_xfer32,\n};\n\n \n\nstatic void via_config_fifo(struct pci_dev *pdev, unsigned int flags)\n{\n\tu8 enable;\n\n\t \n\tpci_read_config_byte(pdev, 0x40 , &enable);\n\tenable &= 3;\n\n\tif (flags & VIA_SET_FIFO) {\n\t\tstatic const u8 fifo_setting[4] = {0x00, 0x60, 0x00, 0x20};\n\t\tu8 fifo;\n\n\t\tpci_read_config_byte(pdev, 0x43, &fifo);\n\n\t\t \n\t\tif (flags & VIA_BAD_PREQ)\n\t\t\tfifo &= 0x7F;\n\t\telse\n\t\t\tfifo &= 0x9f;\n\t\t \n\t\tfifo |= fifo_setting[enable];\n\t\tpci_write_config_byte(pdev, 0x43, fifo);\n\t}\n}\n\nstatic void via_fixup(struct pci_dev *pdev, const struct via_isa_bridge *config)\n{\n\tu32 timing;\n\n\t \n\tvia_config_fifo(pdev, config->flags);\n\n\tif (config->udma_mask == ATA_UDMA4) {\n\t\t \n\t\tpci_read_config_dword(pdev, 0x50, &timing);\n\t\ttiming |= 0x80008;\n\t\tpci_write_config_dword(pdev, 0x50, timing);\n\t}\n\tif (config->flags & VIA_BAD_CLK66) {\n\t\t \n\t\tpci_read_config_dword(pdev, 0x50, &timing);\n\t\ttiming &= ~0x80008;\n\t\tpci_write_config_dword(pdev, 0x50, timing);\n\t}\n}\n\n \n\nstatic int via_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\t \n\tstatic const struct ata_port_info via_mwdma_info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.port_ops = &via_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info via_mwdma_info_borked = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.port_ops = &via_port_ops_noirq,\n\t};\n\t \n\tstatic const struct ata_port_info via_udma33_info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA2,\n\t\t.port_ops = &via_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info via_udma66_info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA4,\n\t\t.port_ops = &via_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info via_udma100_info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &via_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info via_udma133_info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\t \n\t\t.port_ops = &via_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { NULL, NULL };\n\tstruct pci_dev *isa;\n\tconst struct via_isa_bridge *config;\n\tu8 enable;\n\tunsigned long flags = id->driver_data;\n\tint rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (flags & VIA_IDFLAG_SINGLE)\n\t\tppi[1] = &ata_dummy_port_info;\n\n\t \n\tfor (config = via_isa_bridges; config->id != PCI_DEVICE_ID_VIA_ANON;\n\t     config++)\n\t\tif ((isa = pci_get_device(PCI_VENDOR_ID_VIA +\n\t\t\t!!(config->flags & VIA_BAD_ID),\n\t\t\tconfig->id, NULL))) {\n\t\t\tu8 rev = isa->revision;\n\t\t\tpci_dev_put(isa);\n\n\t\t\tif ((id->device == 0x0415 || id->device == 0x3164) &&\n\t\t\t    (config->id != id->device))\n\t\t\t\tcontinue;\n\n\t\t\tif (rev >= config->rev_min && rev <= config->rev_max)\n\t\t\t\tbreak;\n\t\t}\n\n\tif (!(config->flags & VIA_NO_ENABLES)) {\n\t\t \n\t\tpci_read_config_byte(pdev, 0x40 , &enable);\n\t\tenable &= 3;\n\t\tif (enable == 0)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tswitch (config->udma_mask) {\n\tcase 0x00:\n\t\tif (config->flags & VIA_NO_UNMASK)\n\t\t\tppi[0] = &via_mwdma_info_borked;\n\t\telse\n\t\t\tppi[0] = &via_mwdma_info;\n\t\tbreak;\n\tcase ATA_UDMA2:\n\t\tppi[0] = &via_udma33_info;\n\t\tbreak;\n\tcase ATA_UDMA4:\n\t\tppi[0] = &via_udma66_info;\n\t\tbreak;\n\tcase ATA_UDMA5:\n\t\tppi[0] = &via_udma100_info;\n\t\tbreak;\n\tcase ATA_UDMA6:\n\t\tppi[0] = &via_udma133_info;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENODEV;\n \t}\n\n\tvia_fixup(pdev, config);\n\n\t \n\treturn ata_pci_bmdma_init_one(pdev, ppi, &via_sht, (void *)config, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \n\nstatic int via_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tvia_fixup(pdev, host->private_data);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id via[] = {\n\t{ PCI_VDEVICE(VIA, 0x0415), },\n\t{ PCI_VDEVICE(VIA, 0x0571), },\n\t{ PCI_VDEVICE(VIA, 0x0581), },\n\t{ PCI_VDEVICE(VIA, 0x1571), },\n\t{ PCI_VDEVICE(VIA, 0x3164), },\n\t{ PCI_VDEVICE(VIA, 0x5324), },\n\t{ PCI_VDEVICE(VIA, 0xC409), VIA_IDFLAG_SINGLE },\n\t{ PCI_VDEVICE(VIA, 0x9001), VIA_IDFLAG_SINGLE },\n\n\t{ },\n};\n\nstatic struct pci_driver via_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= via,\n\t.probe \t\t= via_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= via_reinit_one,\n#endif\n};\n\nmodule_pci_driver(via_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for VIA PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, via);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}