{
  "module_name": "sata_sis.c",
  "hash_id": "ac6783425520e66123869b1bd3ca88f6714a58600023448199918c72790849ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_sis.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include \"sis.h\"\n\n#define DRV_NAME\t\"sata_sis\"\n#define DRV_VERSION\t\"1.0\"\n\nenum {\n\tsis_180\t\t\t= 0,\n\tSIS_SCR_PCI_BAR\t\t= 5,\n\n\t \n\tSIS_GENCTL\t\t= 0x54,  \n\tSIS_SCR_BASE\t\t= 0xc0,  \n\tSIS180_SATA1_OFS\t= 0x10,  \n\tSIS182_SATA1_OFS\t= 0x20,  \n\tSIS_PMR\t\t\t= 0x90,  \n\tSIS_PMR_COMBINED\t= 0x30,\n\n\t \n\tSIS_FLAG_CFGSCR\t\t= (1 << 30),  \n\n\tGENCTL_IOMAPPED_SCR\t= (1 << 26),  \n};\n\nstatic int sis_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\nstatic int sis_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);\nstatic int sis_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);\n\nstatic const struct pci_device_id sis_pci_tbl[] = {\n\t{ PCI_VDEVICE(SI, 0x0180), sis_180 },\t \n\t{ PCI_VDEVICE(SI, 0x0181), sis_180 },\t \n\t{ PCI_VDEVICE(SI, 0x0182), sis_180 },\t \n\t{ PCI_VDEVICE(SI, 0x0183), sis_180 },\t \n\t{ PCI_VDEVICE(SI, 0x1182), sis_180 },\t \n\t{ PCI_VDEVICE(SI, 0x1183), sis_180 },\t \n\n\t{ }\t \n};\n\nstatic struct pci_driver sis_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= sis_pci_tbl,\n\t.probe\t\t\t= sis_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= ata_pci_device_resume,\n#endif\n};\n\nstatic const struct scsi_host_template sis_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations sis_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.scr_read\t\t= sis_scr_read,\n\t.scr_write\t\t= sis_scr_write,\n};\n\nstatic const struct ata_port_info sis_port_info = {\n\t.flags\t\t= ATA_FLAG_SATA,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &sis_ops,\n};\n\nMODULE_AUTHOR(\"Uwe Koziolek\");\nMODULE_DESCRIPTION(\"low-level driver for Silicon Integrated Systems SATA controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sis_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n\nstatic unsigned int get_scr_cfg_addr(struct ata_link *link, unsigned int sc_reg)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tunsigned int addr = SIS_SCR_BASE + (4 * sc_reg);\n\tu8 pmr;\n\n\tif (ap->port_no)  {\n\t\tswitch (pdev->device) {\n\t\tcase 0x0180:\n\t\tcase 0x0181:\n\t\t\tpci_read_config_byte(pdev, SIS_PMR, &pmr);\n\t\t\tif ((pmr & SIS_PMR_COMBINED) == 0)\n\t\t\t\taddr += SIS180_SATA1_OFS;\n\t\t\tbreak;\n\n\t\tcase 0x0182:\n\t\tcase 0x0183:\n\t\tcase 0x1182:\n\t\t\taddr += SIS182_SATA1_OFS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (link->pmp)\n\t\taddr += 0x10;\n\n\treturn addr;\n}\n\nstatic u32 sis_scr_cfg_read(struct ata_link *link,\n\t\t\t    unsigned int sc_reg, u32 *val)\n{\n\tstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\n\tunsigned int cfg_addr = get_scr_cfg_addr(link, sc_reg);\n\n\tif (sc_reg == SCR_ERROR)  \n\t\treturn -EINVAL;\n\n\tpci_read_config_dword(pdev, cfg_addr, val);\n\treturn 0;\n}\n\nstatic int sis_scr_cfg_write(struct ata_link *link,\n\t\t\t     unsigned int sc_reg, u32 val)\n{\n\tstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\n\tunsigned int cfg_addr = get_scr_cfg_addr(link, sc_reg);\n\n\tpci_write_config_dword(pdev, cfg_addr, val);\n\treturn 0;\n}\n\nstatic int sis_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *base = ap->ioaddr.scr_addr + link->pmp * 0x10;\n\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\n\tif (ap->flags & SIS_FLAG_CFGSCR)\n\t\treturn sis_scr_cfg_read(link, sc_reg, val);\n\n\t*val = ioread32(base + sc_reg * 4);\n\treturn 0;\n}\n\nstatic int sis_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *base = ap->ioaddr.scr_addr + link->pmp * 0x10;\n\n\tif (sc_reg > SCR_CONTROL)\n\t\treturn -EINVAL;\n\n\tif (ap->flags & SIS_FLAG_CFGSCR)\n\t\treturn sis_scr_cfg_write(link, sc_reg, val);\n\n\tiowrite32(val, base + (sc_reg * 4));\n\treturn 0;\n}\n\nstatic int sis_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct ata_port_info pi = sis_port_info;\n\tconst struct ata_port_info *ppi[] = { &pi, &pi };\n\tstruct ata_host *host;\n\tu32 genctl, val;\n\tu8 pmr;\n\tu8 port2_start = 0x20;\n\tint i, rc;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpci_read_config_dword(pdev, SIS_GENCTL, &genctl);\n\tif ((genctl & GENCTL_IOMAPPED_SCR) == 0)\n\t\tpi.flags |= SIS_FLAG_CFGSCR;\n\n\t \n\tif ((!(pi.flags & SIS_FLAG_CFGSCR)) &&\n\t    ((pci_resource_start(pdev, SIS_SCR_PCI_BAR) == 0) ||\n\t     (pci_resource_len(pdev, SIS_SCR_PCI_BAR) < 128))) {\n\t\tgenctl &= ~GENCTL_IOMAPPED_SCR;\n\t\tpci_write_config_dword(pdev, SIS_GENCTL, genctl);\n\t\tpi.flags |= SIS_FLAG_CFGSCR;\n\t}\n\n\tpci_read_config_byte(pdev, SIS_PMR, &pmr);\n\tswitch (ent->device) {\n\tcase 0x0180:\n\tcase 0x0181:\n\n\t\t \n\t\tswitch (pmr & 0x30) {\n\t\tcase 0x10:\n\t\t\tppi[1] = &sis_info133_for_sata;\n\t\t\tbreak;\n\n\t\tcase 0x30:\n\t\t\tppi[0] = &sis_info133_for_sata;\n\t\t\tbreak;\n\t\t}\n\t\tif ((pmr & SIS_PMR_COMBINED) == 0) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Detected SiS 180/181/964 chipset in SATA mode\\n\");\n\t\t\tport2_start = 64;\n\t\t} else {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Detected SiS 180/181 chipset in combined mode\\n\");\n\t\t\tport2_start = 0;\n\t\t\tpi.flags |= ATA_FLAG_SLAVE_POSS;\n\t\t}\n\t\tbreak;\n\n\tcase 0x0182:\n\tcase 0x0183:\n\t\tpci_read_config_dword(pdev, 0x6C, &val);\n\t\tif (val & (1L << 31)) {\n\t\t\tdev_info(&pdev->dev, \"Detected SiS 182/965 chipset\\n\");\n\t\t\tpi.flags |= ATA_FLAG_SLAVE_POSS;\n\t\t} else {\n\t\t\tdev_info(&pdev->dev, \"Detected SiS 182/965L chipset\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x1182:\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Detected SiS 1182/966/680 SATA controller\\n\");\n\t\tpi.flags |= ATA_FLAG_SLAVE_POSS;\n\t\tbreak;\n\n\tcase 0x1183:\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Detected SiS 1183/966/966L/968/680 controller in PATA mode\\n\");\n\t\tppi[0] = &sis_info133_for_sata;\n\t\tppi[1] = &sis_info133_for_sata;\n\t\tbreak;\n\t}\n\n\trc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (ap->flags & ATA_FLAG_SATA &&\n\t\t    ap->flags & ATA_FLAG_SLAVE_POSS) {\n\t\t\trc = ata_slave_link_init(ap);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (!(pi.flags & SIS_FLAG_CFGSCR)) {\n\t\tvoid __iomem *mmio;\n\n\t\trc = pcim_iomap_regions(pdev, 1 << SIS_SCR_PCI_BAR, DRV_NAME);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tmmio = host->iomap[SIS_SCR_PCI_BAR];\n\n\t\thost->ports[0]->ioaddr.scr_addr = mmio;\n\t\thost->ports[1]->ioaddr.scr_addr = mmio + port2_start;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_intx(pdev, 1);\n\treturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\n\t\t\t\t IRQF_SHARED, &sis_sht);\n}\n\nmodule_pci_driver(sis_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}