{
  "module_name": "pdc_adma.c",
  "hash_id": "6862b0e2d55979b1ea9eb0b1ccd3691baf8995c895188260716c40968889658f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pdc_adma.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pdc_adma\"\n#define DRV_VERSION\t\"1.0\"\n\n \n#define ADMA_ATA_REGS(base, port_no)\t((base) + ((port_no) * 0x40))\n\n \n#define ADMA_REGS(base, port_no)\t((base) + 0x80 + ((port_no) * 0x20))\n\n \n#define ADMA_PORT_REGS(ap) \\\n\tADMA_REGS((ap)->host->iomap[ADMA_MMIO_BAR], ap->port_no)\n\nenum {\n\tADMA_MMIO_BAR\t\t= 4,\n\n\tADMA_PORTS\t\t= 2,\n\tADMA_CPB_BYTES\t\t= 40,\n\tADMA_PRD_BYTES\t\t= LIBATA_MAX_PRD * 16,\n\tADMA_PKT_BYTES\t\t= ADMA_CPB_BYTES + ADMA_PRD_BYTES,\n\n\tADMA_DMA_BOUNDARY\t= 0xffffffff,\n\n\t \n\tADMA_MODE_LOCK\t\t= 0x00c7,\n\n\t \n\tADMA_CONTROL\t\t= 0x0000,  \n\tADMA_STATUS\t\t= 0x0002,  \n\tADMA_CPB_COUNT\t\t= 0x0004,  \n\tADMA_CPB_CURRENT\t= 0x000c,  \n\tADMA_CPB_NEXT\t\t= 0x000c,  \n\tADMA_CPB_LOOKUP\t\t= 0x0010,  \n\tADMA_FIFO_IN\t\t= 0x0014,  \n\tADMA_FIFO_OUT\t\t= 0x0016,  \n\n\t \n\taNIEN\t\t\t= (1 << 8),  \n\taGO\t\t\t= (1 << 7),  \n\taRSTADM\t\t\t= (1 << 5),  \n\taPIOMD4\t\t\t= 0x0003,    \n\n\t \n\taPSD\t\t\t= (1 << 6),\n\taUIRQ\t\t\t= (1 << 4),\n\taPERR\t\t\t= (1 << 0),\n\n\t \n\tcDONE\t\t\t= (1 << 0),\n\tcATERR\t\t\t= (1 << 3),\n\n\tcVLD\t\t\t= (1 << 0),\n\tcDAT\t\t\t= (1 << 2),\n\tcIEN\t\t\t= (1 << 3),\n\n\t \n\tpORD\t\t\t= (1 << 4),\n\tpDIRO\t\t\t= (1 << 5),\n\tpEND\t\t\t= (1 << 7),\n\n\t \n\trIGN\t\t\t= (1 << 5),\n\trEND\t\t\t= (1 << 7),\n\n\t \n\tADMA_REGS_CONTROL\t= 0x0e,\n\tADMA_REGS_SECTOR_COUNT\t= 0x12,\n\tADMA_REGS_LBA_LOW\t= 0x13,\n\tADMA_REGS_LBA_MID\t= 0x14,\n\tADMA_REGS_LBA_HIGH\t= 0x15,\n\tADMA_REGS_DEVICE\t= 0x16,\n\tADMA_REGS_COMMAND\t= 0x17,\n\n\t \n\tboard_1841_idx\t\t= 0,\t \n};\n\ntypedef enum { adma_state_idle, adma_state_pkt, adma_state_mmio } adma_state_t;\n\nstruct adma_port_priv {\n\tu8\t\t\t*pkt;\n\tdma_addr_t\t\tpkt_dma;\n\tadma_state_t\t\tstate;\n};\n\nstatic int adma_ata_init_one(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent);\nstatic int adma_port_start(struct ata_port *ap);\nstatic void adma_port_stop(struct ata_port *ap);\nstatic enum ata_completion_errors adma_qc_prep(struct ata_queued_cmd *qc);\nstatic unsigned int adma_qc_issue(struct ata_queued_cmd *qc);\nstatic int adma_check_atapi_dma(struct ata_queued_cmd *qc);\nstatic void adma_freeze(struct ata_port *ap);\nstatic void adma_thaw(struct ata_port *ap);\nstatic int adma_prereset(struct ata_link *link, unsigned long deadline);\n\nstatic const struct scsi_host_template adma_ata_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= LIBATA_MAX_PRD,\n\t.dma_boundary\t\t= ADMA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations adma_ata_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\n\t.lost_interrupt\t\t= ATA_OP_NULL,\n\n\t.check_atapi_dma\t= adma_check_atapi_dma,\n\t.qc_prep\t\t= adma_qc_prep,\n\t.qc_issue\t\t= adma_qc_issue,\n\n\t.freeze\t\t\t= adma_freeze,\n\t.thaw\t\t\t= adma_thaw,\n\t.prereset\t\t= adma_prereset,\n\n\t.port_start\t\t= adma_port_start,\n\t.port_stop\t\t= adma_port_stop,\n};\n\nstatic struct ata_port_info adma_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_POLLING,\n\t\t.pio_mask\t= ATA_PIO4_ONLY,\n\t\t.udma_mask\t= ATA_UDMA4,\n\t\t.port_ops\t= &adma_ata_ops,\n\t},\n};\n\nstatic const struct pci_device_id adma_ata_pci_tbl[] = {\n\t{ PCI_VDEVICE(PDC, 0x1841), board_1841_idx },\n\n\t{ }\t \n};\n\nstatic struct pci_driver adma_ata_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= adma_ata_pci_tbl,\n\t.probe\t\t\t= adma_ata_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n};\n\nstatic int adma_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn 1;\t \n}\n\nstatic void adma_reset_engine(struct ata_port *ap)\n{\n\tvoid __iomem *chan = ADMA_PORT_REGS(ap);\n\n\t \n\twritew(aPIOMD4 | aNIEN | aRSTADM, chan + ADMA_CONTROL);\n\tudelay(2);\n\twritew(aPIOMD4, chan + ADMA_CONTROL);\n\tudelay(2);\n}\n\nstatic void adma_reinit_engine(struct ata_port *ap)\n{\n\tstruct adma_port_priv *pp = ap->private_data;\n\tvoid __iomem *chan = ADMA_PORT_REGS(ap);\n\n\t \n\twriteb(ATA_NIEN, ap->ioaddr.ctl_addr);\n\tata_sff_check_status(ap);\n\n\t \n\tadma_reset_engine(ap);\n\n\t \n\twritew(0x100, chan + ADMA_FIFO_IN);\n\n\t \n\twritel((u32)pp->pkt_dma, chan + ADMA_CPB_NEXT);\n\n\t \n\twritew(0x100, chan + ADMA_FIFO_OUT);\n\n\t \n\twritew(1, chan + ADMA_CPB_COUNT);\n\n\t \n\treadb(chan + ADMA_STATUS);\n}\n\nstatic inline void adma_enter_reg_mode(struct ata_port *ap)\n{\n\tvoid __iomem *chan = ADMA_PORT_REGS(ap);\n\n\twritew(aPIOMD4, chan + ADMA_CONTROL);\n\treadb(chan + ADMA_STATUS);\t \n}\n\nstatic void adma_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *chan = ADMA_PORT_REGS(ap);\n\n\t \n\twriteb(ATA_NIEN, ap->ioaddr.ctl_addr);\n\tata_sff_check_status(ap);\n\n\t \n\twritew(aPIOMD4 | aNIEN | aRSTADM, chan + ADMA_CONTROL);\n\tudelay(2);\n\twritew(aPIOMD4 | aNIEN, chan + ADMA_CONTROL);\n\tudelay(2);\n}\n\nstatic void adma_thaw(struct ata_port *ap)\n{\n\tadma_reinit_engine(ap);\n}\n\nstatic int adma_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct adma_port_priv *pp = ap->private_data;\n\n\tif (pp->state != adma_state_idle)  \n\t\tpp->state = adma_state_mmio;\n\tadma_reinit_engine(ap);\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic int adma_fill_sg(struct ata_queued_cmd *qc)\n{\n\tstruct scatterlist *sg;\n\tstruct ata_port *ap = qc->ap;\n\tstruct adma_port_priv *pp = ap->private_data;\n\tu8  *buf = pp->pkt, *last_buf = NULL;\n\tint i = (2 + buf[3]) * 8;\n\tu8 pFLAGS = pORD | ((qc->tf.flags & ATA_TFLAG_WRITE) ? pDIRO : 0);\n\tunsigned int si;\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tu32 addr;\n\t\tu32 len;\n\n\t\taddr = (u32)sg_dma_address(sg);\n\t\t*(__le32 *)(buf + i) = cpu_to_le32(addr);\n\t\ti += 4;\n\n\t\tlen = sg_dma_len(sg) >> 3;\n\t\t*(__le32 *)(buf + i) = cpu_to_le32(len);\n\t\ti += 4;\n\n\t\tlast_buf = &buf[i];\n\t\tbuf[i++] = pFLAGS;\n\t\tbuf[i++] = qc->dev->dma_mode & 0xf;\n\t\tbuf[i++] = 0;\t \n\t\tbuf[i++] = 0;\t \n\n\t\t*(__le32 *)(buf + i) =\n\t\t\t(pFLAGS & pEND) ? 0 : cpu_to_le32(pp->pkt_dma + i + 4);\n\t\ti += 4;\n\t}\n\n\tif (likely(last_buf))\n\t\t*last_buf |= pEND;\n\n\treturn i;\n}\n\nstatic enum ata_completion_errors adma_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct adma_port_priv *pp = qc->ap->private_data;\n\tu8  *buf = pp->pkt;\n\tu32 pkt_dma = (u32)pp->pkt_dma;\n\tint i = 0;\n\n\tadma_enter_reg_mode(qc->ap);\n\tif (qc->tf.protocol != ATA_PROT_DMA)\n\t\treturn AC_ERR_OK;\n\n\tbuf[i++] = 0;\t \n\tbuf[i++] = 0;\t \n\tbuf[i++] = cVLD | cDAT | cIEN;\n\ti++;\t\t \n\n\t*(__le32 *)(buf+i) = cpu_to_le32(pkt_dma);\t \n\ti += 4;\t\t \n\ti += 4;\t\t \n\n\tbuf[i++] = 0;\t \n\tbuf[i++] = 0;\t \n\tbuf[i++] = 0;\t \n\tbuf[i++] = 0;\t \n\n\t \n\tbuf[i++] = qc->tf.device;\n\tbuf[i++] = ADMA_REGS_DEVICE;\n\tif ((qc->tf.flags & ATA_TFLAG_LBA48)) {\n\t\tbuf[i++] = qc->tf.hob_nsect;\n\t\tbuf[i++] = ADMA_REGS_SECTOR_COUNT;\n\t\tbuf[i++] = qc->tf.hob_lbal;\n\t\tbuf[i++] = ADMA_REGS_LBA_LOW;\n\t\tbuf[i++] = qc->tf.hob_lbam;\n\t\tbuf[i++] = ADMA_REGS_LBA_MID;\n\t\tbuf[i++] = qc->tf.hob_lbah;\n\t\tbuf[i++] = ADMA_REGS_LBA_HIGH;\n\t}\n\tbuf[i++] = qc->tf.nsect;\n\tbuf[i++] = ADMA_REGS_SECTOR_COUNT;\n\tbuf[i++] = qc->tf.lbal;\n\tbuf[i++] = ADMA_REGS_LBA_LOW;\n\tbuf[i++] = qc->tf.lbam;\n\tbuf[i++] = ADMA_REGS_LBA_MID;\n\tbuf[i++] = qc->tf.lbah;\n\tbuf[i++] = ADMA_REGS_LBA_HIGH;\n\tbuf[i++] = 0;\n\tbuf[i++] = ADMA_REGS_CONTROL;\n\tbuf[i++] = rIGN;\n\tbuf[i++] = 0;\n\tbuf[i++] = qc->tf.command;\n\tbuf[i++] = ADMA_REGS_COMMAND | rEND;\n\n\tbuf[3] = (i >> 3) - 2;\t\t\t\t \n\t*(__le32 *)(buf+8) = cpu_to_le32(pkt_dma + i);\t \n\n\ti = adma_fill_sg(qc);\n\twmb();\t \n\treturn AC_ERR_OK;\n}\n\nstatic inline void adma_packet_start(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tvoid __iomem *chan = ADMA_PORT_REGS(ap);\n\n\t \n\twritew(aPIOMD4 | aGO, chan + ADMA_CONTROL);\n}\n\nstatic unsigned int adma_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct adma_port_priv *pp = qc->ap->private_data;\n\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_DMA:\n\t\tpp->state = adma_state_pkt;\n\t\tadma_packet_start(qc);\n\t\treturn 0;\n\n\tcase ATAPI_PROT_DMA:\n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpp->state = adma_state_mmio;\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic inline unsigned int adma_intr_pkt(struct ata_host *host)\n{\n\tunsigned int handled = 0, port_no;\n\n\tfor (port_no = 0; port_no < host->n_ports; ++port_no) {\n\t\tstruct ata_port *ap = host->ports[port_no];\n\t\tstruct adma_port_priv *pp;\n\t\tstruct ata_queued_cmd *qc;\n\t\tvoid __iomem *chan = ADMA_PORT_REGS(ap);\n\t\tu8 status = readb(chan + ADMA_STATUS);\n\n\t\tif (status == 0)\n\t\t\tcontinue;\n\t\thandled = 1;\n\t\tadma_enter_reg_mode(ap);\n\t\tpp = ap->private_data;\n\t\tif (!pp || pp->state != adma_state_pkt)\n\t\t\tcontinue;\n\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\t\tif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING))) {\n\t\t\tif (status & aPERR)\n\t\t\t\tqc->err_mask |= AC_ERR_HOST_BUS;\n\t\t\telse if ((status & (aPSD | aUIRQ)))\n\t\t\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\t\t\tif (pp->pkt[0] & cATERR)\n\t\t\t\tqc->err_mask |= AC_ERR_DEV;\n\t\t\telse if (pp->pkt[0] != cDONE)\n\t\t\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\t\t\tif (!qc->err_mask)\n\t\t\t\tata_qc_complete(qc);\n\t\t\telse {\n\t\t\t\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\t\t\t\tata_ehi_clear_desc(ehi);\n\t\t\t\tata_ehi_push_desc(ehi,\n\t\t\t\t\t\"ADMA-status 0x%02X\", status);\n\t\t\t\tata_ehi_push_desc(ehi,\n\t\t\t\t\t\"pkt[0] 0x%02X\", pp->pkt[0]);\n\n\t\t\t\tif (qc->err_mask == AC_ERR_DEV)\n\t\t\t\t\tata_port_abort(ap);\n\t\t\t\telse\n\t\t\t\t\tata_port_freeze(ap);\n\t\t\t}\n\t\t}\n\t}\n\treturn handled;\n}\n\nstatic inline unsigned int adma_intr_mmio(struct ata_host *host)\n{\n\tunsigned int handled = 0, port_no;\n\n\tfor (port_no = 0; port_no < host->n_ports; ++port_no) {\n\t\tstruct ata_port *ap = host->ports[port_no];\n\t\tstruct adma_port_priv *pp = ap->private_data;\n\t\tstruct ata_queued_cmd *qc;\n\n\t\tif (!pp || pp->state != adma_state_mmio)\n\t\t\tcontinue;\n\t\tqc = ata_qc_from_tag(ap, ap->link.active_tag);\n\t\tif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING))) {\n\n\t\t\t \n\t\t\tu8 status = ata_sff_check_status(ap);\n\t\t\tif ((status & ATA_BUSY))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tpp->state = adma_state_idle;\n\t\t\tqc->err_mask |= ac_err_mask(status);\n\t\t\tif (!qc->err_mask)\n\t\t\t\tata_qc_complete(qc);\n\t\t\telse {\n\t\t\t\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\t\t\t\tata_ehi_clear_desc(ehi);\n\t\t\t\tata_ehi_push_desc(ehi, \"status 0x%02X\", status);\n\n\t\t\t\tif (qc->err_mask == AC_ERR_DEV)\n\t\t\t\t\tata_port_abort(ap);\n\t\t\t\telse\n\t\t\t\t\tata_port_freeze(ap);\n\t\t\t}\n\t\t\thandled = 1;\n\t\t}\n\t}\n\treturn handled;\n}\n\nstatic irqreturn_t adma_intr(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tunsigned int handled = 0;\n\n\tspin_lock(&host->lock);\n\thandled  = adma_intr_pkt(host) | adma_intr_mmio(host);\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void adma_ata_setup_port(struct ata_ioports *port, void __iomem *base)\n{\n\tport->cmd_addr\t\t=\n\tport->data_addr\t\t= base + 0x000;\n\tport->error_addr\t=\n\tport->feature_addr\t= base + 0x004;\n\tport->nsect_addr\t= base + 0x008;\n\tport->lbal_addr\t\t= base + 0x00c;\n\tport->lbam_addr\t\t= base + 0x010;\n\tport->lbah_addr\t\t= base + 0x014;\n\tport->device_addr\t= base + 0x018;\n\tport->status_addr\t=\n\tport->command_addr\t= base + 0x01c;\n\tport->altstatus_addr\t=\n\tport->ctl_addr\t\t= base + 0x038;\n}\n\nstatic int adma_port_start(struct ata_port *ap)\n{\n\tstruct device *dev = ap->host->dev;\n\tstruct adma_port_priv *pp;\n\n\tadma_enter_reg_mode(ap);\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\tpp->pkt = dmam_alloc_coherent(dev, ADMA_PKT_BYTES, &pp->pkt_dma,\n\t\t\t\t      GFP_KERNEL);\n\tif (!pp->pkt)\n\t\treturn -ENOMEM;\n\t \n\tif ((pp->pkt_dma & 7) != 0) {\n\t\tata_port_err(ap, \"bad alignment for pp->pkt_dma: %08x\\n\",\n\t\t\t     (u32)pp->pkt_dma);\n\t\treturn -ENOMEM;\n\t}\n\tap->private_data = pp;\n\tadma_reinit_engine(ap);\n\treturn 0;\n}\n\nstatic void adma_port_stop(struct ata_port *ap)\n{\n\tadma_reset_engine(ap);\n}\n\nstatic void adma_host_init(struct ata_host *host, unsigned int chip_id)\n{\n\tunsigned int port_no;\n\n\t \n\twriteb(7, host->iomap[ADMA_MMIO_BAR] + ADMA_MODE_LOCK);\n\n\t \n\tfor (port_no = 0; port_no < ADMA_PORTS; ++port_no)\n\t\tadma_reset_engine(host->ports[port_no]);\n}\n\nstatic int adma_ata_init_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tunsigned int board_idx = (unsigned int) ent->driver_data;\n\tconst struct ata_port_info *ppi[] = { &adma_port_info[board_idx], NULL };\n\tstruct ata_host *host;\n\tvoid __iomem *mmio_base;\n\tint rc, port_no;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, ADMA_PORTS);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((pci_resource_flags(pdev, 4) & IORESOURCE_MEM) == 0)\n\t\treturn -ENODEV;\n\n\trc = pcim_iomap_regions(pdev, 1 << ADMA_MMIO_BAR, DRV_NAME);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\tmmio_base = host->iomap[ADMA_MMIO_BAR];\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"32-bit DMA enable failed\\n\");\n\t\treturn rc;\n\t}\n\n\tfor (port_no = 0; port_no < ADMA_PORTS; ++port_no) {\n\t\tstruct ata_port *ap = host->ports[port_no];\n\t\tvoid __iomem *port_base = ADMA_ATA_REGS(mmio_base, port_no);\n\t\tunsigned int offset = port_base - mmio_base;\n\n\t\tadma_ata_setup_port(&ap->ioaddr, port_base);\n\n\t\tata_port_pbar_desc(ap, ADMA_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, ADMA_MMIO_BAR, offset, \"port\");\n\t}\n\n\t \n\tadma_host_init(host, board_idx);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, adma_intr, IRQF_SHARED,\n\t\t\t\t &adma_ata_sht);\n}\n\nmodule_pci_driver(adma_ata_pci_driver);\n\nMODULE_AUTHOR(\"Mark Lord\");\nMODULE_DESCRIPTION(\"Pacific Digital Corporation ADMA low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, adma_ata_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}