{
  "module_name": "pata_optidma.c",
  "hash_id": "3f2171380d6a519a70c5ab7013dfefa0a84f77a34ddf9aadbb8426d547d0fc0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_optidma.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_optidma\"\n#define DRV_VERSION \"0.3.2\"\n\nenum {\n\tREAD_REG\t= 0,\t \n\tWRITE_REG \t= 1,\t \n\tCNTRL_REG \t= 3,\t \n\tSTRAP_REG \t= 5,\t \n\tMISC_REG \t= 6\t \n};\n\nstatic int pci_clock;\t \n\n \n\nstatic int optidma_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic const struct pci_bits optidma_enable_bits = {\n\t\t0x40, 1, 0x08, 0x00\n\t};\n\n\tif (ap->port_no && !pci_test_config_bits(pdev, &optidma_enable_bits))\n\t\treturn -ENOENT;\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic void optidma_unlock(struct ata_port *ap)\n{\n\tvoid __iomem *regio = ap->ioaddr.cmd_addr;\n\n\t \n\tioread16(regio + 1);\n\tioread16(regio + 1);\n\tiowrite8(3, regio + 2);\n}\n\n \n\nstatic void optidma_lock(struct ata_port *ap)\n{\n\tvoid __iomem *regio = ap->ioaddr.cmd_addr;\n\n\t \n\tiowrite8(0x83, regio + 2);\n}\n\n \n\nstatic void optidma_mode_setup(struct ata_port *ap, struct ata_device *adev, u8 mode)\n{\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tint pio = adev->pio_mode - XFER_PIO_0;\n\tint dma = adev->dma_mode - XFER_MW_DMA_0;\n\tvoid __iomem *regio = ap->ioaddr.cmd_addr;\n\tu8 addr;\n\n\t \n\tstatic const u8 addr_timing[2][5] = {\n\t\t{ 0x30, 0x20, 0x20, 0x10, 0x10 },\n\t\t{ 0x20, 0x20, 0x10, 0x10, 0x10 }\n\t};\n\tstatic const u8 data_rec_timing[2][5] = {\n\t\t{ 0x59, 0x46, 0x30, 0x20, 0x20 },\n\t\t{ 0x46, 0x32, 0x20, 0x20, 0x10 }\n\t};\n\tstatic const u8 dma_data_rec_timing[2][3] = {\n\t\t{ 0x76, 0x20, 0x20 },\n\t\t{ 0x54, 0x20, 0x10 }\n\t};\n\n\t \n\toptidma_unlock(ap);\n\n\n\t \n\n\tif (mode >= XFER_MW_DMA_0)\n\t\taddr = 0;\n\telse\n\t\taddr = addr_timing[pci_clock][pio];\n\n\tif (pair) {\n\t\tu8 pair_addr;\n\t\t \n\t\tif (ata_dma_enabled(pair))\n\t\t\tpair_addr = 0;\n\t\telse\n\t\t\tpair_addr = addr_timing[pci_clock][pair->pio_mode - XFER_PIO_0];\n\t\tif (pair_addr > addr)\n\t\t\taddr = pair_addr;\n\t}\n\n\t \n\t \n\tiowrite8(adev->devno, regio + MISC_REG);\n\t \n\tif (mode < XFER_MW_DMA_0) {\n\t\tiowrite8(data_rec_timing[pci_clock][pio], regio + READ_REG);\n\t\tiowrite8(data_rec_timing[pci_clock][pio], regio + WRITE_REG);\n\t} else if (mode < XFER_UDMA_0) {\n\t\tiowrite8(dma_data_rec_timing[pci_clock][dma], regio + READ_REG);\n\t\tiowrite8(dma_data_rec_timing[pci_clock][dma], regio + WRITE_REG);\n\t}\n\t \n\tiowrite8(addr | adev->devno, regio + MISC_REG);\n\n\t \n\tiowrite8(0x85, regio + CNTRL_REG);\n\n\t \n\toptidma_lock(ap);\n\n\t \n}\n\n \n\nstatic void optiplus_mode_setup(struct ata_port *ap, struct ata_device *adev, u8 mode)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 udcfg;\n\tu8 udslave;\n\tint dev2 = 2 * adev->devno;\n\tint unit = 2 * ap->port_no + adev->devno;\n\tint udma = mode - XFER_UDMA_0;\n\n\tpci_read_config_byte(pdev, 0x44, &udcfg);\n\tif (mode <= XFER_UDMA_0) {\n\t\tudcfg &= ~(1 << unit);\n\t\toptidma_mode_setup(ap, adev, adev->dma_mode);\n\t} else {\n\t\tudcfg |=  (1 << unit);\n\t\tif (ap->port_no) {\n\t\t\tpci_read_config_byte(pdev, 0x45, &udslave);\n\t\t\tudslave &= ~(0x03 << dev2);\n\t\t\tudslave |= (udma << dev2);\n\t\t\tpci_write_config_byte(pdev, 0x45, udslave);\n\t\t} else {\n\t\t\tudcfg &= ~(0x30 << dev2);\n\t\t\tudcfg |= (udma << dev2);\n\t\t}\n\t}\n\tpci_write_config_byte(pdev, 0x44, udcfg);\n}\n\n \n\nstatic void optidma_set_pio_mode(struct ata_port *ap, struct ata_device *adev)\n{\n\toptidma_mode_setup(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void optidma_set_dma_mode(struct ata_port *ap, struct ata_device *adev)\n{\n\toptidma_mode_setup(ap, adev, adev->dma_mode);\n}\n\n \n\nstatic void optiplus_set_pio_mode(struct ata_port *ap, struct ata_device *adev)\n{\n\toptiplus_mode_setup(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void optiplus_set_dma_mode(struct ata_port *ap, struct ata_device *adev)\n{\n\toptiplus_mode_setup(ap, adev, adev->dma_mode);\n}\n\n \n\nstatic u8 optidma_make_bits43(struct ata_device *adev)\n{\n\tstatic const u8 bits43[5] = {\n\t\t0, 0, 0, 1, 2\n\t};\n\tif (!ata_dev_enabled(adev))\n\t\treturn 0;\n\tif (ata_dma_enabled(adev))\n\t\treturn adev->dma_mode - XFER_MW_DMA_0;\n\treturn bits43[adev->pio_mode - XFER_PIO_0];\n}\n\n \n\nstatic int optidma_set_mode(struct ata_link *link, struct ata_device **r_failed)\n{\n\tstruct ata_port *ap = link->ap;\n\tu8 r;\n\tint nybble = 4 * ap->port_no;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint rc  = ata_do_set_mode(link, r_failed);\n\tif (rc == 0) {\n\t\tpci_read_config_byte(pdev, 0x43, &r);\n\n\t\tr &= (0x0F << nybble);\n\t\tr |= (optidma_make_bits43(&link->device[0]) +\n\t\t     (optidma_make_bits43(&link->device[0]) << 2)) << nybble;\n\t\tpci_write_config_byte(pdev, 0x43, r);\n\t}\n\treturn rc;\n}\n\nstatic const struct scsi_host_template optidma_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations optidma_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= optidma_set_pio_mode,\n\t.set_dmamode\t= optidma_set_dma_mode,\n\t.set_mode\t= optidma_set_mode,\n\t.prereset\t= optidma_pre_reset,\n};\n\nstatic struct ata_port_operations optiplus_port_ops = {\n\t.inherits\t= &optidma_port_ops,\n\t.set_piomode\t= optiplus_set_pio_mode,\n\t.set_dmamode\t= optiplus_set_dma_mode,\n};\n\n \n\nstatic int optiplus_with_udma(struct pci_dev *pdev)\n{\n\tu8 r;\n\tint ret = 0;\n\tint ioport = 0x22;\n\tstruct pci_dev *dev1;\n\n\t \n\tdev1 = pci_get_device(0x1045, 0xC701, NULL);\n\tif (dev1 == NULL)\n\t\treturn 0;\n\n\t \n\tpci_read_config_byte(dev1, 0x08, &r);\n\tif (r < 0x10)\n\t\tgoto done_nomsg;\n\t \n\tpci_read_config_byte(dev1, 0x5F, &r);\n\tioport |= (r << 8);\n\toutb(0x10, ioport);\n\t \n\tif ((inb(ioport + 2) & 1) == 0)\n\t\tgoto done;\n\n\t \n\tpci_read_config_byte(pdev, 0x42, &r);\n\tif ((r & 0x36) != 0x36)\n\t\tgoto done;\n\tpci_read_config_byte(dev1, 0x52, &r);\n\tif (r & 0x80)\t \n\t\tret = 1;\ndone:\n\tprintk(KERN_WARNING \"UDMA not supported in this configuration.\\n\");\ndone_nomsg:\t\t \n\tpci_dev_put(dev1);\n\treturn ret;\n}\n\nstatic int optidma_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info_82c700 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.port_ops = &optidma_port_ops\n\t};\n\tstatic const struct ata_port_info info_82c700_udma = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA2,\n\t\t.port_ops = &optiplus_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info_82c700, NULL };\n\tint rc;\n\n\tata_print_version_once(&dev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tinw(0x1F1);\n\tinw(0x1F1);\n\tpci_clock = inb(0x1F5) & 1;\t\t \n\n\tif (optiplus_with_udma(dev))\n\t\tppi[0] = &info_82c700_udma;\n\n\treturn ata_pci_bmdma_init_one(dev, ppi, &optidma_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id optidma[] = {\n\t{ PCI_VDEVICE(OPTI, 0xD568), },\t\t \n\n\t{ },\n};\n\nstatic struct pci_driver optidma_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= optidma,\n\t.probe \t\t= optidma_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(optidma_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Opti Firestar/Firestar Plus\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, optidma);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}