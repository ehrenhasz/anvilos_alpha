{
  "module_name": "pata_hpt366.c",
  "hash_id": "6c1aafab8af289a698f9c8753b4d00080a584893f81b2df980df75d5ca8b254e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_hpt366.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_hpt366\"\n#define DRV_VERSION\t\"0.6.13\"\n\nstruct hpt_clock {\n\tu8\txfer_mode;\n\tu32\ttiming;\n};\n\n \n\nstatic const struct hpt_clock hpt366_40[] = {\n\t{\tXFER_UDMA_4,\t0x900fd943\t},\n\t{\tXFER_UDMA_3,\t0x900ad943\t},\n\t{\tXFER_UDMA_2,\t0x900bd943\t},\n\t{\tXFER_UDMA_1,\t0x9008d943\t},\n\t{\tXFER_UDMA_0,\t0x9008d943\t},\n\n\t{\tXFER_MW_DMA_2,\t0xa008d943\t},\n\t{\tXFER_MW_DMA_1,\t0xa010d955\t},\n\t{\tXFER_MW_DMA_0,\t0xa010d9fc\t},\n\n\t{\tXFER_PIO_4,\t0xc008d963\t},\n\t{\tXFER_PIO_3,\t0xc010d974\t},\n\t{\tXFER_PIO_2,\t0xc010d997\t},\n\t{\tXFER_PIO_1,\t0xc010d9c7\t},\n\t{\tXFER_PIO_0,\t0xc018d9d9\t},\n\t{\t0,\t\t0x0120d9d9\t}\n};\n\nstatic const struct hpt_clock hpt366_33[] = {\n\t{\tXFER_UDMA_4,\t0x90c9a731\t},\n\t{\tXFER_UDMA_3,\t0x90cfa731\t},\n\t{\tXFER_UDMA_2,\t0x90caa731\t},\n\t{\tXFER_UDMA_1,\t0x90cba731\t},\n\t{\tXFER_UDMA_0,\t0x90c8a731\t},\n\n\t{\tXFER_MW_DMA_2,\t0xa0c8a731\t},\n\t{\tXFER_MW_DMA_1,\t0xa0c8a732\t},\t \n\t{\tXFER_MW_DMA_0,\t0xa0c8a797\t},\n\n\t{\tXFER_PIO_4,\t0xc0c8a731\t},\n\t{\tXFER_PIO_3,\t0xc0c8a742\t},\n\t{\tXFER_PIO_2,\t0xc0d0a753\t},\n\t{\tXFER_PIO_1,\t0xc0d0a7a3\t},\t \n\t{\tXFER_PIO_0,\t0xc0d0a7aa\t},\t \n\t{\t0,\t\t0x0120a7a7\t}\n};\n\nstatic const struct hpt_clock hpt366_25[] = {\n\t{\tXFER_UDMA_4,\t0x90c98521\t},\n\t{\tXFER_UDMA_3,\t0x90cf8521\t},\n\t{\tXFER_UDMA_2,\t0x90cf8521\t},\n\t{\tXFER_UDMA_1,\t0x90cb8521\t},\n\t{\tXFER_UDMA_0,\t0x90cb8521\t},\n\n\t{\tXFER_MW_DMA_2,\t0xa0ca8521\t},\n\t{\tXFER_MW_DMA_1,\t0xa0ca8532\t},\n\t{\tXFER_MW_DMA_0,\t0xa0ca8575\t},\n\n\t{\tXFER_PIO_4,\t0xc0ca8521\t},\n\t{\tXFER_PIO_3,\t0xc0ca8532\t},\n\t{\tXFER_PIO_2,\t0xc0ca8542\t},\n\t{\tXFER_PIO_1,\t0xc0d08572\t},\n\t{\tXFER_PIO_0,\t0xc0d08585\t},\n\t{\t0,\t\t0x01208585\t}\n};\n\n \n\nstatic u32 hpt36x_find_mode(struct ata_port *ap, int speed)\n{\n\tstruct hpt_clock *clocks = ap->host->private_data;\n\n\twhile (clocks->xfer_mode) {\n\t\tif (clocks->xfer_mode == speed)\n\t\t\treturn clocks->timing;\n\t\tclocks++;\n\t}\n\tBUG();\n\treturn 0xffffffffU;\t \n}\n\nstatic const char * const bad_ata33[] = {\n\t\"Maxtor 92720U8\", \"Maxtor 92040U6\", \"Maxtor 91360U4\", \"Maxtor 91020U3\",\n\t\"Maxtor 90845U3\", \"Maxtor 90650U2\",\n\t\"Maxtor 91360D8\", \"Maxtor 91190D7\", \"Maxtor 91020D6\", \"Maxtor 90845D5\",\n\t\"Maxtor 90680D4\", \"Maxtor 90510D3\", \"Maxtor 90340D2\",\n\t\"Maxtor 91152D8\", \"Maxtor 91008D7\", \"Maxtor 90845D6\", \"Maxtor 90840D6\",\n\t\"Maxtor 90720D5\", \"Maxtor 90648D5\", \"Maxtor 90576D4\",\n\t\"Maxtor 90510D4\",\n\t\"Maxtor 90432D3\", \"Maxtor 90288D2\", \"Maxtor 90256D2\",\n\t\"Maxtor 91000D8\", \"Maxtor 90910D8\", \"Maxtor 90875D7\", \"Maxtor 90840D7\",\n\t\"Maxtor 90750D6\", \"Maxtor 90625D5\", \"Maxtor 90500D4\",\n\t\"Maxtor 91728D8\", \"Maxtor 91512D7\", \"Maxtor 91303D6\", \"Maxtor 91080D5\",\n\t\"Maxtor 90845D4\", \"Maxtor 90680D4\", \"Maxtor 90648D3\", \"Maxtor 90432D2\",\n\tNULL\n};\n\nstatic const char * const bad_ata66_4[] = {\n\t\"IBM-DTLA-307075\",\n\t\"IBM-DTLA-307060\",\n\t\"IBM-DTLA-307045\",\n\t\"IBM-DTLA-307030\",\n\t\"IBM-DTLA-307020\",\n\t\"IBM-DTLA-307015\",\n\t\"IBM-DTLA-305040\",\n\t\"IBM-DTLA-305030\",\n\t\"IBM-DTLA-305020\",\n\t\"IC35L010AVER07-0\",\n\t\"IC35L020AVER07-0\",\n\t\"IC35L030AVER07-0\",\n\t\"IC35L040AVER07-0\",\n\t\"IC35L060AVER07-0\",\n\t\"WDC AC310200R\",\n\tNULL\n};\n\nstatic const char * const bad_ata66_3[] = {\n\t\"WDC AC310200R\",\n\tNULL\n};\n\nstatic int hpt_dma_blacklisted(const struct ata_device *dev, char *modestr,\n\t\t\t       const char * const list[])\n{\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\tint i;\n\n\tata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\n\ti = match_string(list, -1, model_num);\n\tif (i >= 0) {\n\t\tata_dev_warn(dev, \"%s is not supported for %s\\n\", modestr, list[i]);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic unsigned int hpt366_filter(struct ata_device *adev, unsigned int mask)\n{\n\tif (adev->class == ATA_DEV_ATA) {\n\t\tif (hpt_dma_blacklisted(adev, \"UDMA\",  bad_ata33))\n\t\t\tmask &= ~ATA_MASK_UDMA;\n\t\tif (hpt_dma_blacklisted(adev, \"UDMA3\", bad_ata66_3))\n\t\t\tmask &= ~(0xF8 << ATA_SHIFT_UDMA);\n\t\tif (hpt_dma_blacklisted(adev, \"UDMA4\", bad_ata66_4))\n\t\t\tmask &= ~(0xF0 << ATA_SHIFT_UDMA);\n\t} else if (adev->class == ATA_DEV_ATAPI)\n\t\tmask &= ~(ATA_MASK_MWDMA | ATA_MASK_UDMA);\n\n\treturn mask;\n}\n\nstatic int hpt36x_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 ata66;\n\n\t \n\tpci_read_config_byte(pdev, 0x5A, &ata66);\n\tif (ata66 & 2)\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\nstatic void hpt366_set_mode(struct ata_port *ap, struct ata_device *adev,\n\t\t\t    u8 mode)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu32 addr = 0x40 + 4 * adev->devno;\n\tu32 mask, reg, t;\n\n\t \n\tif (mode < XFER_MW_DMA_0)\n\t\tmask = 0xc1f8ffff;\n\telse if (mode < XFER_UDMA_0)\n\t\tmask = 0x303800ff;\n\telse\n\t\tmask = 0x30070000;\n\n\tt = hpt36x_find_mode(ap, mode);\n\n\t \n\tpci_read_config_dword(pdev, addr, &reg);\n\treg = ((reg & ~mask) | (t & mask)) & ~0xc0000000;\n\tpci_write_config_dword(pdev, addr, reg);\n}\n\n \n\nstatic void hpt366_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\thpt366_set_mode(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void hpt366_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\thpt366_set_mode(ap, adev, adev->dma_mode);\n}\n\n \n\nstatic int hpt366_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\t \n\tstatic const struct pci_bits hpt366_enable_bits = {\n\t\t0x50, 1, 0x30, 0x30\n\t};\n\tu8 mcr2;\n\n\tif (!pci_test_config_bits(pdev, &hpt366_enable_bits))\n\t\treturn -ENOENT;\n\n\tpci_read_config_byte(pdev, 0x51, &mcr2);\n\tif (mcr2 & 0x80)\n\t\tpci_write_config_byte(pdev, 0x51, mcr2 & ~0x80);\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\nstatic const struct scsi_host_template hpt36x_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n \n\nstatic struct ata_port_operations hpt366_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.prereset\t= hpt366_prereset,\n\t.cable_detect\t= hpt36x_cable_detect,\n\t.mode_filter\t= hpt366_filter,\n\t.set_piomode\t= hpt366_set_piomode,\n\t.set_dmamode\t= hpt366_set_dmamode,\n};\n\n \n\nstatic void hpt36x_init_chipset(struct pci_dev *dev)\n{\n\tu8 mcr1;\n\n\tpci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\n\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\n\tpci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\n\tpci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\n\n\t \n\tpci_read_config_byte(dev, 0x50, &mcr1);\n\tif (mcr1 & 0x30)\n\t\tpci_write_config_byte(dev, 0x50, mcr1 | 0x30);\n}\n\n \n\nstatic int hpt36x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info_hpt366 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA4,\n\t\t.port_ops = &hpt366_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info_hpt366, NULL };\n\n\tconst void *hpriv = NULL;\n\tu32 reg1;\n\tint rc;\n\n\trc = pcim_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\t \n\tif (dev->revision > 2)\n\t\treturn -ENODEV;\n\n\thpt36x_init_chipset(dev);\n\n\tpci_read_config_dword(dev, 0x40,  &reg1);\n\n\t \n\t \n\tswitch ((reg1 & 0xf00) >> 8) {\n\tcase 9:\n\t\thpriv = &hpt366_40;\n\t\tbreak;\n\tcase 5:\n\t\thpriv = &hpt366_25;\n\t\tbreak;\n\tdefault:\n\t\thpriv = &hpt366_33;\n\t\tbreak;\n\t}\n\t \n\treturn ata_pci_bmdma_init_one(dev, ppi, &hpt36x_sht, (void *)hpriv, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hpt36x_reinit_one(struct pci_dev *dev)\n{\n\tstruct ata_host *host = pci_get_drvdata(dev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(dev);\n\tif (rc)\n\t\treturn rc;\n\thpt36x_init_chipset(dev);\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id hpt36x[] = {\n\t{ PCI_VDEVICE(TTI, PCI_DEVICE_ID_TTI_HPT366), },\n\t{ },\n};\n\nstatic struct pci_driver hpt36x_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= hpt36x,\n\t.probe\t\t= hpt36x_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= hpt36x_reinit_one,\n#endif\n};\n\nmodule_pci_driver(hpt36x_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for the Highpoint HPT366/368\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, hpt36x);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}