{
  "module_name": "sata_sil.c",
  "hash_id": "65a2c0585b712052ffab1e9d24e03da2ddab1ce67b988535ce567999ce037aed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/sata_sil.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n\n#define DRV_NAME\t\"sata_sil\"\n#define DRV_VERSION\t\"2.4\"\n\n#define SIL_DMA_BOUNDARY\t0x7fffffffUL\n\nenum {\n\tSIL_MMIO_BAR\t\t= 5,\n\n\t \n\tSIL_FLAG_NO_SATA_IRQ\t= (1 << 28),\n\tSIL_FLAG_RERR_ON_DMA_ACT = (1 << 29),\n\tSIL_FLAG_MOD15WRITE\t= (1 << 30),\n\n\tSIL_DFL_PORT_FLAGS\t= ATA_FLAG_SATA,\n\n\t \n\tsil_3112\t\t= 0,\n\tsil_3112_no_sata_irq\t= 1,\n\tsil_3512\t\t= 2,\n\tsil_3114\t\t= 3,\n\n\t \n\tSIL_SYSCFG\t\t= 0x48,\n\n\t \n\t \n\tSIL_MASK_IDE0_INT\t= (1 << 22),\n\tSIL_MASK_IDE1_INT\t= (1 << 23),\n\tSIL_MASK_IDE2_INT\t= (1 << 24),\n\tSIL_MASK_IDE3_INT\t= (1 << 25),\n\tSIL_MASK_2PORT\t\t= SIL_MASK_IDE0_INT | SIL_MASK_IDE1_INT,\n\tSIL_MASK_4PORT\t\t= SIL_MASK_2PORT |\n\t\t\t\t  SIL_MASK_IDE2_INT | SIL_MASK_IDE3_INT,\n\n\t \n\tSIL_INTR_STEERING\t= (1 << 1),\n\n\tSIL_DMA_ENABLE\t\t= (1 << 0),   \n\tSIL_DMA_RDWR\t\t= (1 << 3),   \n\tSIL_DMA_SATA_IRQ\t= (1 << 4),   \n\tSIL_DMA_ACTIVE\t\t= (1 << 16),  \n\tSIL_DMA_ERROR\t\t= (1 << 17),  \n\tSIL_DMA_COMPLETE\t= (1 << 18),  \n\tSIL_DMA_N_SATA_IRQ\t= (1 << 6),   \n\tSIL_DMA_N_ACTIVE\t= (1 << 24),  \n\tSIL_DMA_N_ERROR\t\t= (1 << 25),  \n\tSIL_DMA_N_COMPLETE\t= (1 << 26),  \n\n\t \n\tSIL_SIEN_N\t\t= (1 << 16),  \n\n\t \n\tSIL_QUIRK_MOD15WRITE\t= (1 << 0),\n\tSIL_QUIRK_UDMA5MAX\t= (1 << 1),\n};\n\nstatic int sil_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\n#ifdef CONFIG_PM_SLEEP\nstatic int sil_pci_device_resume(struct pci_dev *pdev);\n#endif\nstatic void sil_dev_config(struct ata_device *dev);\nstatic int sil_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);\nstatic int sil_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);\nstatic int sil_set_mode(struct ata_link *link, struct ata_device **r_failed);\nstatic enum ata_completion_errors sil_qc_prep(struct ata_queued_cmd *qc);\nstatic void sil_bmdma_setup(struct ata_queued_cmd *qc);\nstatic void sil_bmdma_start(struct ata_queued_cmd *qc);\nstatic void sil_bmdma_stop(struct ata_queued_cmd *qc);\nstatic void sil_freeze(struct ata_port *ap);\nstatic void sil_thaw(struct ata_port *ap);\n\n\nstatic const struct pci_device_id sil_pci_tbl[] = {\n\t{ PCI_VDEVICE(CMD, 0x3112), sil_3112 },\n\t{ PCI_VDEVICE(CMD, 0x0240), sil_3112 },\n\t{ PCI_VDEVICE(CMD, 0x3512), sil_3512 },\n\t{ PCI_VDEVICE(CMD, 0x3114), sil_3114 },\n\t{ PCI_VDEVICE(ATI, 0x436e), sil_3112 },\n\t{ PCI_VDEVICE(ATI, 0x4379), sil_3112_no_sata_irq },\n\t{ PCI_VDEVICE(ATI, 0x437a), sil_3112_no_sata_irq },\n\n\t{ }\t \n};\n\n\n \nstatic const struct sil_drivelist {\n\tconst char *product;\n\tunsigned int quirk;\n} sil_blacklist [] = {\n\t{ \"ST320012AS\",\t\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST330013AS\",\t\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST340017AS\",\t\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST360015AS\",\t\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST380023AS\",\t\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST3120023AS\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST340014ASL\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST360014ASL\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST380011ASL\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST3120022ASL\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"ST3160021ASL\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"TOSHIBA MK2561GSYN\",\tSIL_QUIRK_MOD15WRITE },\n\t{ \"Maxtor 4D060H3\",\tSIL_QUIRK_UDMA5MAX },\n\t{ }\n};\n\nstatic struct pci_driver sil_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= sil_pci_tbl,\n\t.probe\t\t\t= sil_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= sil_pci_device_resume,\n#endif\n};\n\nstatic const struct scsi_host_template sil_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t \n\t.dma_boundary\t\t= SIL_DMA_BOUNDARY,\n\t.sg_tablesize\t\t= ATA_MAX_PRD\n};\n\nstatic struct ata_port_operations sil_ops = {\n\t.inherits\t\t= &ata_bmdma32_port_ops,\n\t.dev_config\t\t= sil_dev_config,\n\t.set_mode\t\t= sil_set_mode,\n\t.bmdma_setup            = sil_bmdma_setup,\n\t.bmdma_start            = sil_bmdma_start,\n\t.bmdma_stop\t\t= sil_bmdma_stop,\n\t.qc_prep\t\t= sil_qc_prep,\n\t.freeze\t\t\t= sil_freeze,\n\t.thaw\t\t\t= sil_thaw,\n\t.scr_read\t\t= sil_scr_read,\n\t.scr_write\t\t= sil_scr_write,\n};\n\nstatic const struct ata_port_info sil_port_info[] = {\n\t \n\t{\n\t\t.flags\t\t= SIL_DFL_PORT_FLAGS | SIL_FLAG_MOD15WRITE,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= SIL_DFL_PORT_FLAGS | SIL_FLAG_MOD15WRITE |\n\t\t\t\t  SIL_FLAG_NO_SATA_IRQ,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= SIL_DFL_PORT_FLAGS | SIL_FLAG_RERR_ON_DMA_ACT,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil_ops,\n\t},\n\t \n\t{\n\t\t.flags\t\t= SIL_DFL_PORT_FLAGS | SIL_FLAG_RERR_ON_DMA_ACT,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.udma_mask\t= ATA_UDMA5,\n\t\t.port_ops\t= &sil_ops,\n\t},\n};\n\n \n \nstatic const struct {\n\tunsigned long tf;\t \n\tunsigned long ctl;\t \n\tunsigned long bmdma;\t \n\tunsigned long bmdma2;\t \n\tunsigned long fifo_cfg;\t \n\tunsigned long scr;\t \n\tunsigned long sien;\t \n\tunsigned long xfer_mode; \n\tunsigned long sfis_cfg;\t \n} sil_port[] = {\n\t \n\t \n\t{  0x80,  0x8A,   0x0,  0x10,  0x40, 0x100, 0x148,  0xb4, 0x14c },\n\t{  0xC0,  0xCA,   0x8,  0x18,  0x44, 0x180, 0x1c8,  0xf4, 0x1cc },\n\t{ 0x280, 0x28A, 0x200, 0x210, 0x240, 0x300, 0x348, 0x2b4, 0x34c },\n\t{ 0x2C0, 0x2CA, 0x208, 0x218, 0x244, 0x380, 0x3c8, 0x2f4, 0x3cc },\n\t \n};\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"low-level driver for Silicon Image SATA controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sil_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n\nstatic int slow_down;\nmodule_param(slow_down, int, 0444);\nMODULE_PARM_DESC(slow_down, \"Sledgehammer used to work around random problems, by limiting commands to 15 sectors (0=off, 1=on)\");\n\n\nstatic void sil_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tvoid __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];\n\tvoid __iomem *bmdma2 = mmio_base + sil_port[ap->port_no].bmdma2;\n\n\t \n\tiowrite8(0, bmdma2);\n\n\t \n\tata_sff_dma_pause(ap);\n}\n\nstatic void sil_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tvoid __iomem *bmdma = ap->ioaddr.bmdma_addr;\n\n\t \n\tiowrite32(ap->bmdma_prd_dma, bmdma + ATA_DMA_TABLE_OFS);\n\n\t \n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\nstatic void sil_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tunsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);\n\tstruct ata_port *ap = qc->ap;\n\tvoid __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];\n\tvoid __iomem *bmdma2 = mmio_base + sil_port[ap->port_no].bmdma2;\n\tu8 dmactl = ATA_DMA_START;\n\n\t \n\tif (!rw)\n\t\tdmactl |= ATA_DMA_WR;\n\tiowrite8(dmactl, bmdma2);\n}\n\n \nstatic void sil_fill_sg(struct ata_queued_cmd *qc)\n{\n\tstruct scatterlist *sg;\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_bmdma_prd *prd, *last_prd = NULL;\n\tunsigned int si;\n\n\tprd = &ap->bmdma_prd[0];\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\t \n\t\tu32 addr = (u32) sg_dma_address(sg);\n\t\tu32 sg_len = sg_dma_len(sg);\n\n\t\tprd->addr = cpu_to_le32(addr);\n\t\tprd->flags_len = cpu_to_le32(sg_len);\n\n\t\tlast_prd = prd;\n\t\tprd++;\n\t}\n\n\tif (likely(last_prd))\n\t\tlast_prd->flags_len |= cpu_to_le32(ATA_PRD_EOT);\n}\n\nstatic enum ata_completion_errors sil_qc_prep(struct ata_queued_cmd *qc)\n{\n\tif (!(qc->flags & ATA_QCFLAG_DMAMAP))\n\t\treturn AC_ERR_OK;\n\n\tsil_fill_sg(qc);\n\n\treturn AC_ERR_OK;\n}\n\nstatic unsigned char sil_get_device_cache_line(struct pci_dev *pdev)\n{\n\tu8 cache_line = 0;\n\tpci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &cache_line);\n\treturn cache_line;\n}\n\n \n\nstatic int sil_set_mode(struct ata_link *link, struct ata_device **r_failed)\n{\n\tstruct ata_port *ap = link->ap;\n\tvoid __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];\n\tvoid __iomem *addr = mmio_base + sil_port[ap->port_no].xfer_mode;\n\tstruct ata_device *dev;\n\tu32 tmp, dev_mode[2] = { };\n\tint rc;\n\n\trc = ata_do_set_mode(link, r_failed);\n\tif (rc)\n\t\treturn rc;\n\n\tata_for_each_dev(dev, link, ALL) {\n\t\tif (!ata_dev_enabled(dev))\n\t\t\tdev_mode[dev->devno] = 0;\t \n\t\telse if (dev->flags & ATA_DFLAG_PIO)\n\t\t\tdev_mode[dev->devno] = 1;\t \n\t\telse\n\t\t\tdev_mode[dev->devno] = 3;\t \n\t\t \n\t}\n\n\ttmp = readl(addr);\n\ttmp &= ~((1<<5) | (1<<4) | (1<<1) | (1<<0));\n\ttmp |= dev_mode[0];\n\ttmp |= (dev_mode[1] << 4);\n\twritel(tmp, addr);\n\treadl(addr);\t \n\treturn 0;\n}\n\nstatic inline void __iomem *sil_scr_addr(struct ata_port *ap,\n\t\t\t\t\t unsigned int sc_reg)\n{\n\tvoid __iomem *offset = ap->ioaddr.scr_addr;\n\n\tswitch (sc_reg) {\n\tcase SCR_STATUS:\n\t\treturn offset + 4;\n\tcase SCR_ERROR:\n\t\treturn offset + 8;\n\tcase SCR_CONTROL:\n\t\treturn offset;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic int sil_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\n{\n\tvoid __iomem *mmio = sil_scr_addr(link->ap, sc_reg);\n\n\tif (mmio) {\n\t\t*val = readl(mmio);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int sil_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\n{\n\tvoid __iomem *mmio = sil_scr_addr(link->ap, sc_reg);\n\n\tif (mmio) {\n\t\twritel(val, mmio);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void sil_host_intr(struct ata_port *ap, u32 bmdma2)\n{\n\tstruct ata_eh_info *ehi = &ap->link.eh_info;\n\tstruct ata_queued_cmd *qc = ata_qc_from_tag(ap, ap->link.active_tag);\n\tu8 status;\n\n\tif (unlikely(bmdma2 & SIL_DMA_SATA_IRQ)) {\n\t\tu32 serror = 0xffffffff;\n\n\t\t \n\t\tsil_scr_read(&ap->link, SCR_ERROR, &serror);\n\t\tsil_scr_write(&ap->link, SCR_ERROR, serror);\n\n\t\t \n\t\tif (serror & SERR_PHYRDY_CHG) {\n\t\t\tap->link.eh_info.serror |= serror;\n\t\t\tgoto freeze;\n\t\t}\n\n\t\tif (!(bmdma2 & SIL_DMA_COMPLETE))\n\t\t\treturn;\n\t}\n\n\tif (unlikely(!qc || (qc->tf.flags & ATA_TFLAG_POLLING))) {\n\t\t \n\t\tap->ops->sff_check_status(ap);\n\t\treturn;\n\t}\n\n\t \n\tswitch (ap->hsm_task_state) {\n\tcase HSM_ST_FIRST:\n\t\t \n\n\t\t \n\t\tif (!(qc->dev->flags & ATA_DFLAG_CDB_INTR))\n\t\t\tgoto err_hsm;\n\t\tbreak;\n\tcase HSM_ST_LAST:\n\t\tif (ata_is_dma(qc->tf.protocol)) {\n\t\t\t \n\t\t\tap->ops->bmdma_stop(qc);\n\n\t\t\tif (bmdma2 & SIL_DMA_ERROR) {\n\t\t\t\tqc->err_mask |= AC_ERR_HOST_BUS;\n\t\t\t\tap->hsm_task_state = HSM_ST_ERR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HSM_ST:\n\t\tbreak;\n\tdefault:\n\t\tgoto err_hsm;\n\t}\n\n\t \n\tstatus = ap->ops->sff_check_status(ap);\n\tif (unlikely(status & ATA_BUSY))\n\t\tgoto err_hsm;\n\n\t \n\tata_bmdma_irq_clear(ap);\n\n\t \n\tata_sff_hsm_move(ap, qc, status, 0);\n\n\tif (unlikely(qc->err_mask) && ata_is_dma(qc->tf.protocol))\n\t\tata_ehi_push_desc(ehi, \"BMDMA2 stat 0x%x\", bmdma2);\n\n\treturn;\n\n err_hsm:\n\tqc->err_mask |= AC_ERR_HSM;\n freeze:\n\tata_port_freeze(ap);\n}\n\nstatic irqreturn_t sil_interrupt(int irq, void *dev_instance)\n{\n\tstruct ata_host *host = dev_instance;\n\tvoid __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];\n\tint handled = 0;\n\tint i;\n\n\tspin_lock(&host->lock);\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tu32 bmdma2 = readl(mmio_base + sil_port[ap->port_no].bmdma2);\n\n\t\t \n\t\tif (ap->flags & SIL_FLAG_NO_SATA_IRQ)\n\t\t\tbmdma2 &= ~SIL_DMA_SATA_IRQ;\n\n\t\tif (bmdma2 == 0xffffffff ||\n\t\t    !(bmdma2 & (SIL_DMA_COMPLETE | SIL_DMA_SATA_IRQ)))\n\t\t\tcontinue;\n\n\t\tsil_host_intr(ap, bmdma2);\n\t\thandled = 1;\n\t}\n\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void sil_freeze(struct ata_port *ap)\n{\n\tvoid __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];\n\tu32 tmp;\n\n\t \n\twritel(0, mmio_base + sil_port[ap->port_no].sien);\n\n\t \n\ttmp = readl(mmio_base + SIL_SYSCFG);\n\ttmp |= SIL_MASK_IDE0_INT << ap->port_no;\n\twritel(tmp, mmio_base + SIL_SYSCFG);\n\treadl(mmio_base + SIL_SYSCFG);\t \n\n\t \n\tiowrite8(ioread8(ap->ioaddr.bmdma_addr) & ~SIL_DMA_ENABLE,\n\t\t ap->ioaddr.bmdma_addr);\n\n\t \n\tioread8(ap->ioaddr.bmdma_addr);\n}\n\nstatic void sil_thaw(struct ata_port *ap)\n{\n\tvoid __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];\n\tu32 tmp;\n\n\t \n\tap->ops->sff_check_status(ap);\n\tata_bmdma_irq_clear(ap);\n\n\t \n\tif (!(ap->flags & SIL_FLAG_NO_SATA_IRQ))\n\t\twritel(SIL_SIEN_N, mmio_base + sil_port[ap->port_no].sien);\n\n\t \n\ttmp = readl(mmio_base + SIL_SYSCFG);\n\ttmp &= ~(SIL_MASK_IDE0_INT << ap->port_no);\n\twritel(tmp, mmio_base + SIL_SYSCFG);\n}\n\n \nstatic void sil_dev_config(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tint print_info = ap->link.eh_context.i.flags & ATA_EHI_PRINTINFO;\n\tunsigned int n, quirks = 0;\n\tunsigned char model_num[ATA_ID_PROD_LEN + 1];\n\n\t \n\tdev->horkage |= ATA_HORKAGE_NOTRIM;\n\n\tata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\n\tfor (n = 0; sil_blacklist[n].product; n++)\n\t\tif (!strcmp(sil_blacklist[n].product, model_num)) {\n\t\t\tquirks = sil_blacklist[n].quirk;\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (slow_down ||\n\t    ((ap->flags & SIL_FLAG_MOD15WRITE) &&\n\t     (quirks & SIL_QUIRK_MOD15WRITE))) {\n\t\tif (print_info)\n\t\t\tata_dev_info(dev,\n\t\t\"applying Seagate errata fix (mod15write workaround)\\n\");\n\t\tdev->max_sectors = 15;\n\t\treturn;\n\t}\n\n\t \n\tif (quirks & SIL_QUIRK_UDMA5MAX) {\n\t\tif (print_info)\n\t\t\tata_dev_info(dev, \"applying Maxtor errata fix %s\\n\",\n\t\t\t\t     model_num);\n\t\tdev->udma_mask &= ATA_UDMA5;\n\t\treturn;\n\t}\n}\n\nstatic void sil_init_controller(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tvoid __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];\n\tu8 cls;\n\tu32 tmp;\n\tint i;\n\n\t \n\tcls = sil_get_device_cache_line(pdev);\n\tif (cls) {\n\t\tcls >>= 3;\n\t\tcls++;   \n\t\tfor (i = 0; i < host->n_ports; i++)\n\t\t\twritew(cls << 8 | cls,\n\t\t\t       mmio_base + sil_port[i].fifo_cfg);\n\t} else\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"cache line size not set.  Driver may not function\\n\");\n\n\t \n\tif (host->ports[0]->flags & SIL_FLAG_RERR_ON_DMA_ACT) {\n\t\tint cnt;\n\n\t\tfor (i = 0, cnt = 0; i < host->n_ports; i++) {\n\t\t\ttmp = readl(mmio_base + sil_port[i].sfis_cfg);\n\t\t\tif ((tmp & 0x3) != 0x01)\n\t\t\t\tcontinue;\n\t\t\tif (!cnt)\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t \"Applying R_ERR on DMA activate FIS errata fix\\n\");\n\t\t\twritel(tmp & ~0x3, mmio_base + sil_port[i].sfis_cfg);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (host->n_ports == 4) {\n\t\t \n\t\ttmp = readl(mmio_base + sil_port[2].bmdma);\n\t\tif ((tmp & SIL_INTR_STEERING) == 0)\n\t\t\twritel(tmp | SIL_INTR_STEERING,\n\t\t\t       mmio_base + sil_port[2].bmdma);\n\t}\n}\n\nstatic bool sil_broken_system_poweroff(struct pci_dev *pdev)\n{\n\tstatic const struct dmi_system_id broken_systems[] = {\n\t\t{\n\t\t\t.ident = \"HP Compaq nx6325\",\n\t\t\t.matches = {\n\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Compaq nx6325\"),\n\t\t\t},\n\t\t\t \n\t\t\t.driver_data = (void *)0x12UL,\n\t\t},\n\n\t\t{ }\t \n\t};\n\tconst struct dmi_system_id *dmi = dmi_first_match(broken_systems);\n\n\tif (dmi) {\n\t\tunsigned long slot = (unsigned long)dmi->driver_data;\n\t\t \n\t\treturn slot == PCI_SLOT(pdev->devfn);\n\t}\n\n\treturn false;\n}\n\nstatic int sil_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint board_id = ent->driver_data;\n\tstruct ata_port_info pi = sil_port_info[board_id];\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct ata_host *host;\n\tvoid __iomem *mmio_base;\n\tint n_ports, rc;\n\tunsigned int i;\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\tn_ports = 2;\n\tif (board_id == sil_3114)\n\t\tn_ports = 4;\n\n\tif (sil_broken_system_poweroff(pdev)) {\n\t\tpi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN |\n\t\t\t\t\tATA_FLAG_NO_HIBERNATE_SPINDOWN;\n\t\tdev_info(&pdev->dev, \"quirky BIOS, skipping spindown \"\n\t\t\t\t\"on poweroff and hibernation\\n\");\n\t}\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev, 1 << SIL_MMIO_BAR, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\thost->iomap = pcim_iomap_table(pdev);\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\tmmio_base = host->iomap[SIL_MMIO_BAR];\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\t\tioaddr->cmd_addr = mmio_base + sil_port[i].tf;\n\t\tioaddr->altstatus_addr =\n\t\tioaddr->ctl_addr = mmio_base + sil_port[i].ctl;\n\t\tioaddr->bmdma_addr = mmio_base + sil_port[i].bmdma;\n\t\tioaddr->scr_addr = mmio_base + sil_port[i].scr;\n\t\tata_sff_std_ports(ioaddr);\n\n\t\tata_port_pbar_desc(ap, SIL_MMIO_BAR, -1, \"mmio\");\n\t\tata_port_pbar_desc(ap, SIL_MMIO_BAR, sil_port[i].tf, \"tf\");\n\t}\n\n\t \n\tsil_init_controller(host);\n\n\tpci_set_master(pdev);\n\treturn ata_host_activate(host, pdev->irq, sil_interrupt, IRQF_SHARED,\n\t\t\t\t &sil_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sil_pci_device_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tsil_init_controller(host);\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nmodule_pci_driver(sil_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}