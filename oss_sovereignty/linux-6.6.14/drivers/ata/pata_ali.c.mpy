{
  "module_name": "pata_ali.c",
  "hash_id": "70a18d26784d8f0fa3e7b24404bd87b638a13f4d42950436866b5c9c2911992e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_ali.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/dmi.h>\n\n#define DRV_NAME \"pata_ali\"\n#define DRV_VERSION \"0.7.8\"\n\nstatic int ali_atapi_dma;\nmodule_param_named(atapi_dma, ali_atapi_dma, int, 0644);\nMODULE_PARM_DESC(atapi_dma, \"Enable ATAPI DMA (0=disable, 1=enable)\");\n\nstatic struct pci_dev *ali_isa_bridge;\n\n \n\nstatic const struct dmi_system_id cable_dmi_table[] = {\n\t{\n\t\t.ident = \"HP Pavilion N5430\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"OmniBook N32N-736\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Toshiba Satellite S1800-814\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"S1800-814\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int ali_cable_override(struct pci_dev *pdev)\n{\n\t \n\tif (pdev->subsystem_vendor == 0x10CF && pdev->subsystem_device == 0x10AF)\n\t   \treturn 1;\n\t \n\tif (pdev->subsystem_vendor == 0x1071 && pdev->subsystem_device == 0x8317)\n\t\treturn 1;\n\t \n\tif (dmi_check_system(cable_dmi_table))\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\nstatic int ali_c2_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 ata66;\n\n\t \n\n\tif (ali_cable_override(pdev))\n\t\treturn ATA_CBL_PATA40_SHORT;\n\n\t \n\tpci_read_config_byte(pdev, 0x4A, &ata66);\n\tif (ata66 & (1 << ap->port_no))\n\t\treturn ATA_CBL_PATA40;\n\telse\n\t\treturn ATA_CBL_PATA80;\n}\n\n \n\nstatic unsigned int ali_20_filter(struct ata_device *adev, unsigned int mask)\n{\n\tchar model_num[ATA_ID_PROD_LEN + 1];\n\t \n\tif (adev->class != ATA_DEV_ATA)\n\t\tmask &= ~(ATA_MASK_MWDMA | ATA_MASK_UDMA);\n\tata_id_c_string(adev->id, model_num, ATA_ID_PROD, sizeof(model_num));\n\tif (strstr(model_num, \"WDC\"))\n\t\tmask &= ~ATA_MASK_UDMA;\n\treturn mask;\n}\n\n \n\nstatic void ali_fifo_control(struct ata_port *ap, struct ata_device *adev, int on)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint pio_fifo = 0x54 + ap->port_no;\n\tu8 fifo;\n\tint shift = 4 * adev->devno;\n\n\t \n\n\tpci_read_config_byte(pdev, pio_fifo, &fifo);\n\tfifo &= ~(0x0F << shift);\n\tfifo |= (on << shift);\n\tpci_write_config_byte(pdev, pio_fifo, fifo);\n}\n\n \n\nstatic void ali_program_modes(struct ata_port *ap, struct ata_device *adev, struct ata_timing *t, u8 ultra)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint cas = 0x58 + 4 * ap->port_no;\t \n\tint cbt = 0x59 + 4 * ap->port_no;\t \n\tint drwt = 0x5A + 4 * ap->port_no + adev->devno;  \n\tint udmat = 0x56 + ap->port_no;\t \n\tint shift = 4 * adev->devno;\n\tu8 udma;\n\n\tif (t != NULL) {\n\t\tt->setup = clamp_val(t->setup, 1, 8) & 7;\n\t\tt->act8b = clamp_val(t->act8b, 1, 8) & 7;\n\t\tt->rec8b = clamp_val(t->rec8b, 1, 16) & 15;\n\t\tt->active = clamp_val(t->active, 1, 8) & 7;\n\t\tt->recover = clamp_val(t->recover, 1, 16) & 15;\n\n\t\tpci_write_config_byte(pdev, cas, t->setup);\n\t\tpci_write_config_byte(pdev, cbt, (t->act8b << 4) | t->rec8b);\n\t\tpci_write_config_byte(pdev, drwt, (t->active << 4) | t->recover);\n\t}\n\n\t \n\tpci_read_config_byte(pdev, udmat, &udma);\n\tudma &= ~(0x0F << shift);\n\tudma |= ultra << shift;\n\tpci_write_config_byte(pdev, udmat, udma);\n}\n\n \n\nstatic void ali_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tstruct ata_timing t;\n\tunsigned long T =  1000000000 / 33333;\t \n\n\tata_timing_compute(adev, adev->pio_mode, &t, T, 1);\n\tif (pair) {\n\t\tstruct ata_timing p;\n\t\tata_timing_compute(pair, pair->pio_mode, &p, T, 1);\n\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\n\t\tif (ata_dma_enabled(pair)) {\n\t\t\tata_timing_compute(pair, pair->dma_mode, &p, T, 1);\n\t\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\n\t\t}\n\t}\n\n\t \n\tif (adev->class != ATA_DEV_ATA)\n\t\tali_fifo_control(ap, adev, 0x00);\n\tali_program_modes(ap, adev, &t, 0);\n\tif (adev->class == ATA_DEV_ATA)\n\t\tali_fifo_control(ap, adev, 0x05);\n\n}\n\n \n\nstatic void ali_set_dmamode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic u8 udma_timing[7] = { 0xC, 0xB, 0xA, 0x9, 0x8, 0xF, 0xD };\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tstruct ata_timing t;\n\tunsigned long T =  1000000000 / 33333;\t \n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\n\tif (adev->class == ATA_DEV_ATA)\n\t\tali_fifo_control(ap, adev, 0x08);\n\n\tif (adev->dma_mode >= XFER_UDMA_0) {\n\t\tali_program_modes(ap, adev, NULL, udma_timing[adev->dma_mode - XFER_UDMA_0]);\n\t\tif (adev->dma_mode >= XFER_UDMA_3) {\n\t\t\tu8 reg4b;\n\t\t\tpci_read_config_byte(pdev, 0x4B, &reg4b);\n\t\t\treg4b |= 1;\n\t\t\tpci_write_config_byte(pdev, 0x4B, reg4b);\n\t\t}\n\t} else {\n\t\tata_timing_compute(adev, adev->dma_mode, &t, T, 1);\n\t\tif (pair) {\n\t\t\tstruct ata_timing p;\n\t\t\tata_timing_compute(pair, pair->pio_mode, &p, T, 1);\n\t\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\n\t\t\tif (ata_dma_enabled(pair)) {\n\t\t\t\tata_timing_compute(pair, pair->dma_mode, &p, T, 1);\n\t\t\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\n\t\t\t}\n\t\t}\n\t\tali_program_modes(ap, adev, &t, 0);\n\t}\n}\n\n \n\nstatic void ali_warn_atapi_dma(struct ata_device *adev)\n{\n\tstruct ata_eh_context *ehc = &adev->link->eh_context;\n\tint print_info = ehc->i.flags & ATA_EHI_PRINTINFO;\n\n\tif (print_info && adev->class == ATA_DEV_ATAPI && !ali_atapi_dma) {\n\t\tata_dev_warn(adev,\n\t\t\t     \"WARNING: ATAPI DMA disabled for reliability issues.  It can be enabled\\n\");\n\t\tata_dev_warn(adev,\n\t\t\t     \"WARNING: via pata_ali.atapi_dma modparam or corresponding sysfs node.\\n\");\n\t}\n}\n\n \n\nstatic void ali_lock_sectors(struct ata_device *adev)\n{\n\tadev->max_sectors = 255;\n\tali_warn_atapi_dma(adev);\n}\n\n \n\nstatic int ali_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\tif (!ali_atapi_dma) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (atapi_cmd_type(qc->cdb[0]) == ATAPI_MISC)\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic void ali_c2_c3_postreset(struct ata_link *link, unsigned int *classes)\n{\n\tu8 r;\n\tint port_bit = 4 << link->ap->port_no;\n\n\t \n\tif (ali_isa_bridge) {\n\t\t \n\t\tpci_read_config_byte(ali_isa_bridge, 0x58, &r);\n\t\tr &= ~port_bit;\n\t\tpci_write_config_byte(ali_isa_bridge, 0x58, r);\n\t\tr |= port_bit;\n\t\tpci_write_config_byte(ali_isa_bridge, 0x58, r);\n\t}\n\tata_sff_postreset(link, classes);\n}\n\nstatic const struct scsi_host_template ali_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\n \n\nstatic struct ata_port_operations ali_early_port_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= ali_set_piomode,\n\t.sff_data_xfer  = ata_sff_data_xfer32,\n};\n\nstatic const struct ata_port_operations ali_dma_base_ops = {\n\t.inherits\t= &ata_bmdma32_port_ops,\n\t.set_piomode\t= ali_set_piomode,\n\t.set_dmamode\t= ali_set_dmamode,\n};\n\n \nstatic struct ata_port_operations ali_20_port_ops = {\n\t.inherits\t= &ali_dma_base_ops,\n\t.cable_detect\t= ata_cable_40wire,\n\t.mode_filter\t= ali_20_filter,\n\t.check_atapi_dma = ali_check_atapi_dma,\n\t.dev_config\t= ali_lock_sectors,\n};\n\n \nstatic struct ata_port_operations ali_c2_port_ops = {\n\t.inherits\t= &ali_dma_base_ops,\n\t.check_atapi_dma = ali_check_atapi_dma,\n\t.cable_detect\t= ali_c2_cable_detect,\n\t.dev_config\t= ali_lock_sectors,\n\t.postreset\t= ali_c2_c3_postreset,\n};\n\n \nstatic struct ata_port_operations ali_c4_port_ops = {\n\t.inherits\t= &ali_dma_base_ops,\n\t.check_atapi_dma = ali_check_atapi_dma,\n\t.cable_detect\t= ali_c2_cable_detect,\n\t.dev_config\t= ali_lock_sectors,\n};\n\n \nstatic struct ata_port_operations ali_c5_port_ops = {\n\t.inherits\t= &ali_dma_base_ops,\n\t.check_atapi_dma = ali_check_atapi_dma,\n\t.dev_config\t= ali_warn_atapi_dma,\n\t.cable_detect\t= ali_c2_cable_detect,\n};\n\n\n \n\nstatic void ali_init_chipset(struct pci_dev *pdev)\n{\n\tu8 tmp;\n\tstruct pci_dev *north;\n\n\t \n\n\tif (pdev->revision <= 0x20) {\n\t\tpci_read_config_byte(pdev, 0x53, &tmp);\n\t\ttmp |= 0x03;\n\t\tpci_write_config_byte(pdev, 0x53, tmp);\n\t} else {\n\t\tpci_read_config_byte(pdev, 0x4a, &tmp);\n\t\tpci_write_config_byte(pdev, 0x4a, tmp | 0x20);\n\t\tpci_read_config_byte(pdev, 0x4B, &tmp);\n\t\tif (pdev->revision < 0xC2)\n\t\t\t \n\t\t\t \n\t\t\ttmp &= 0x7F;\n\t\t \n\t\tif (pdev->revision >= 0xc2)\n\t\t\ttmp |= 0x01;\n\t\tpci_write_config_byte(pdev, 0x4B, tmp | 0x08);\n\t\t \n\t\tpci_read_config_byte(pdev, 0x53, &tmp);\n\t\tif (pdev->revision >= 0xc7)\n\t\t\ttmp |= 0x03;\n\t\telse\n\t\t\ttmp |= 0x01;\t \n\t\tpci_write_config_byte(pdev, 0x53, tmp);\n\t}\n\tnorth = pci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus), 0,\n\t\t\t\t\t    PCI_DEVFN(0, 0));\n\tif (north && north->vendor == PCI_VENDOR_ID_AL && ali_isa_bridge) {\n\t\t \n\t\tpci_read_config_byte(ali_isa_bridge, 0x79, &tmp);\n\t\tif (pdev->revision == 0xC2)\n\t\t\tpci_write_config_byte(ali_isa_bridge, 0x79, tmp | 0x04);\n\t\telse if (pdev->revision > 0xC2 && pdev->revision < 0xC5)\n\t\t\tpci_write_config_byte(ali_isa_bridge, 0x79, tmp | 0x02);\n\t}\n\tpci_dev_put(north);\n\tata_pci_bmdma_clear_simplex(pdev);\n}\n \n\nstatic int ali_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info_early = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.port_ops = &ali_early_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_20 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\n\t\t\t\t\t\t\tATA_FLAG_IGN_SIMPLEX,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.port_ops = &ali_20_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_20_udma = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\n\t\t\t\t\t\t\tATA_FLAG_IGN_SIMPLEX,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA2,\n\t\t.port_ops = &ali_20_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_c2 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\n\t\t\t\t\t\t\tATA_FLAG_IGN_SIMPLEX,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA4,\n\t\t.port_ops = &ali_c2_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_c3 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\n\t\t\t\t\t\t\tATA_FLAG_IGN_SIMPLEX,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA4,\n\t\t.port_ops = &ali_c2_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_c4 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\n\t\t\t\t\t\t\tATA_FLAG_IGN_SIMPLEX,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA5,\n\t\t.port_ops = &ali_c4_port_ops\n\t};\n\t \n\tstatic const struct ata_port_info info_c5 = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS | \tATA_FLAG_IGN_SIMPLEX,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.mwdma_mask = ATA_MWDMA2,\n\t\t.udma_mask = ATA_UDMA6,\n\t\t.port_ops = &ali_c5_port_ops\n\t};\n\n\tconst struct ata_port_info *ppi[] = { NULL, NULL };\n\tu8 tmp;\n\tint rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tif (pdev->revision < 0x20) {\n\t\tppi[0] = &info_early;\n\t} else if (pdev->revision < 0xC2) {\n        \tppi[0] = &info_20;\n\t} else if (pdev->revision == 0xC2) {\n        \tppi[0] = &info_c2;\n\t} else if (pdev->revision == 0xC3) {\n        \tppi[0] = &info_c3;\n\t} else if (pdev->revision == 0xC4) {\n        \tppi[0] = &info_c4;\n\t} else\n        \tppi[0] = &info_c5;\n\n\tali_init_chipset(pdev);\n\n\tif (ali_isa_bridge && pdev->revision >= 0x20 && pdev->revision < 0xC2) {\n\t\t \n\t\tpci_read_config_byte(ali_isa_bridge, 0x5E, &tmp);\n\t\tif ((tmp & 0x1E) == 0x12)\n\t        \tppi[0] = &info_20_udma;\n\t}\n\n\tif (!ppi[0]->mwdma_mask && !ppi[0]->udma_mask)\n\t\treturn ata_pci_sff_init_one(pdev, ppi, &ali_sht, NULL, 0);\n\telse\n\t\treturn ata_pci_bmdma_init_one(pdev, ppi, &ali_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ali_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\tali_init_chipset(pdev);\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id ali[] = {\n\t{ PCI_VDEVICE(AL, PCI_DEVICE_ID_AL_M5228), },\n\t{ PCI_VDEVICE(AL, PCI_DEVICE_ID_AL_M5229), },\n\n\t{ },\n};\n\nstatic struct pci_driver ali_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= ali,\n\t.probe \t\t= ali_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ali_reinit_one,\n#endif\n};\n\nstatic int __init ali_init(void)\n{\n\tint ret;\n\tali_isa_bridge = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, NULL);\n\n\tret = pci_register_driver(&ali_pci_driver);\n\tif (ret < 0)\n\t\tpci_dev_put(ali_isa_bridge);\n\treturn ret;\n}\n\n\nstatic void __exit ali_exit(void)\n{\n\tpci_unregister_driver(&ali_pci_driver);\n\tpci_dev_put(ali_isa_bridge);\n}\n\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for ALi PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, ali);\nMODULE_VERSION(DRV_VERSION);\n\nmodule_init(ali_init);\nmodule_exit(ali_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}