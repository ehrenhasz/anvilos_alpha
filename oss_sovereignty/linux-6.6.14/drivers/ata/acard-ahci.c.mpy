{
  "module_name": "acard-ahci.c",
  "hash_id": "73993e8bef49df0d540eee8d56c902bc4fcaec46abeab72b9e3a80cd9955fd85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/acard-ahci.c",
  "human_readable_source": "\n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <linux/libata.h>\n#include \"ahci.h\"\n\n#define DRV_NAME\t\"acard-ahci\"\n#define DRV_VERSION\t\"1.0\"\n\n \n\n#define ACARD_AHCI_RX_FIS_SZ 128\n\nenum {\n\tAHCI_PCI_BAR\t\t= 5,\n};\n\nenum board_ids {\n\tboard_acard_ahci,\n};\n\nstruct acard_sg {\n\t__le32\t\t\taddr;\n\t__le32\t\t\taddr_hi;\n\t__le32\t\t\treserved;\n\t__le32\t\t\tsize;\t  \n};\n\nstatic enum ata_completion_errors acard_ahci_qc_prep(struct ata_queued_cmd *qc);\nstatic void acard_ahci_qc_fill_rtf(struct ata_queued_cmd *qc);\nstatic int acard_ahci_port_start(struct ata_port *ap);\nstatic int acard_ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acard_ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);\nstatic int acard_ahci_pci_device_resume(struct pci_dev *pdev);\n#endif\n\nstatic const struct scsi_host_template acard_ahci_sht = {\n\tAHCI_SHT(\"acard-ahci\"),\n};\n\nstatic struct ata_port_operations acard_ops = {\n\t.inherits\t\t= &ahci_ops,\n\t.qc_prep\t\t= acard_ahci_qc_prep,\n\t.qc_fill_rtf\t\t= acard_ahci_qc_fill_rtf,\n\t.port_start             = acard_ahci_port_start,\n};\n\n#define AHCI_HFLAGS(flags)\t.private_data\t= (void *)(flags)\n\nstatic const struct ata_port_info acard_ahci_port_info[] = {\n\t[board_acard_ahci] =\n\t{\n\t\tAHCI_HFLAGS\t(AHCI_HFLAG_NO_NCQ),\n\t\t.flags\t\t= AHCI_FLAG_COMMON,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.udma_mask\t= ATA_UDMA6,\n\t\t.port_ops\t= &acard_ops,\n\t},\n};\n\nstatic const struct pci_device_id acard_ahci_pci_tbl[] = {\n\t \n\t{ PCI_VDEVICE(ARTOP, 0x000d), board_acard_ahci },  \n\n\t{ }     \n};\n\nstatic struct pci_driver acard_ahci_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= acard_ahci_pci_tbl,\n\t.probe\t\t\t= acard_ahci_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= acard_ahci_pci_device_suspend,\n\t.resume\t\t\t= acard_ahci_pci_device_resume,\n#endif\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acard_ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tvoid __iomem *mmio = hpriv->mmio;\n\tu32 ctl;\n\n\tif (mesg.event & PM_EVENT_SUSPEND &&\n\t    hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"BIOS update required for suspend/resume\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (mesg.event & PM_EVENT_SLEEP) {\n\t\t \n\t\tctl = readl(mmio + HOST_CTL);\n\t\tctl &= ~HOST_IRQ_EN;\n\t\twritel(ctl, mmio + HOST_CTL);\n\t\treadl(mmio + HOST_CTL);  \n\t}\n\n\treturn ata_pci_device_suspend(pdev, mesg);\n}\n\nstatic int acard_ahci_pci_device_resume(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\n\t\trc = ahci_reset_controller(host);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tahci_init_controller(host);\n\t}\n\n\tata_host_resume(host);\n\n\treturn 0;\n}\n#endif\n\nstatic void acard_ahci_pci_print_info(struct ata_host *host)\n{\n\tstruct pci_dev *pdev = to_pci_dev(host->dev);\n\tu16 cc;\n\tconst char *scc_s;\n\n\tpci_read_config_word(pdev, 0x0a, &cc);\n\tif (cc == PCI_CLASS_STORAGE_IDE)\n\t\tscc_s = \"IDE\";\n\telse if (cc == PCI_CLASS_STORAGE_SATA)\n\t\tscc_s = \"SATA\";\n\telse if (cc == PCI_CLASS_STORAGE_RAID)\n\t\tscc_s = \"RAID\";\n\telse\n\t\tscc_s = \"unknown\";\n\n\tahci_print_info(host, scc_s);\n}\n\nstatic unsigned int acard_ahci_fill_sg(struct ata_queued_cmd *qc, void *cmd_tbl)\n{\n\tstruct scatterlist *sg;\n\tstruct acard_sg *acard_sg = cmd_tbl + AHCI_CMD_TBL_HDR_SZ;\n\tunsigned int si, last_si = 0;\n\n\t \n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tdma_addr_t addr = sg_dma_address(sg);\n\t\tu32 sg_len = sg_dma_len(sg);\n\n\t\t \n\t\tacard_sg[si].addr = cpu_to_le32(addr & 0xffffffff);\n\t\tacard_sg[si].addr_hi = cpu_to_le32((addr >> 16) >> 16);\n\t\tacard_sg[si].size = cpu_to_le32(sg_len);\n\t\tlast_si = si;\n\t}\n\n\tacard_sg[last_si].size |= cpu_to_le32(1 << 31);\t \n\n\treturn si;\n}\n\nstatic enum ata_completion_errors acard_ahci_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tint is_atapi = ata_is_atapi(qc->tf.protocol);\n\tvoid *cmd_tbl;\n\tu32 opts;\n\tconst u32 cmd_fis_len = 5;  \n\n\t \n\tcmd_tbl = pp->cmd_tbl + qc->hw_tag * AHCI_CMD_TBL_SZ;\n\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, cmd_tbl);\n\tif (is_atapi) {\n\t\tmemset(cmd_tbl + AHCI_CMD_TBL_CDB, 0, 32);\n\t\tmemcpy(cmd_tbl + AHCI_CMD_TBL_CDB, qc->cdb, qc->dev->cdb_len);\n\t}\n\n\tif (qc->flags & ATA_QCFLAG_DMAMAP)\n\t\tacard_ahci_fill_sg(qc, cmd_tbl);\n\n\t \n\topts = cmd_fis_len | (qc->dev->link->pmp << 12);\n\tif (qc->tf.flags & ATA_TFLAG_WRITE)\n\t\topts |= AHCI_CMD_WRITE;\n\tif (is_atapi)\n\t\topts |= AHCI_CMD_ATAPI | AHCI_CMD_PREFETCH;\n\n\tahci_fill_cmd_slot(pp, qc->hw_tag, opts);\n\n\treturn AC_ERR_OK;\n}\n\nstatic void acard_ahci_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct ahci_port_priv *pp = qc->ap->private_data;\n\tu8 *rx_fis = pp->rx_fis;\n\n\tif (pp->fbs_enabled)\n\t\trx_fis += qc->dev->link->pmp * ACARD_AHCI_RX_FIS_SZ;\n\n\t \n\tif (qc->tf.protocol == ATA_PROT_PIO && qc->dma_dir == DMA_FROM_DEVICE &&\n\t    !(qc->flags & ATA_QCFLAG_EH)) {\n\t\tata_tf_from_fis(rx_fis + RX_FIS_PIO_SETUP, &qc->result_tf);\n\t\tqc->result_tf.status = (rx_fis + RX_FIS_PIO_SETUP)[15];\n\t} else\n\t\tata_tf_from_fis(rx_fis + RX_FIS_D2H_REG, &qc->result_tf);\n}\n\nstatic int acard_ahci_port_start(struct ata_port *ap)\n{\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct device *dev = ap->host->dev;\n\tstruct ahci_port_priv *pp;\n\tvoid *mem;\n\tdma_addr_t mem_dma;\n\tsize_t dma_sz, rx_fis_sz;\n\n\tpp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\t \n\tif ((hpriv->cap & HOST_CAP_FBS) && sata_pmp_supported(ap)) {\n\t\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\t\tu32 cmd = readl(port_mmio + PORT_CMD);\n\t\tif (cmd & PORT_CMD_FBSCP)\n\t\t\tpp->fbs_supported = true;\n\t\telse if (hpriv->flags & AHCI_HFLAG_YES_FBS) {\n\t\t\tdev_info(dev, \"port %d can do FBS, forcing FBSCP\\n\",\n\t\t\t\t ap->port_no);\n\t\t\tpp->fbs_supported = true;\n\t\t} else\n\t\t\tdev_warn(dev, \"port %d is not capable of FBS\\n\",\n\t\t\t\t ap->port_no);\n\t}\n\n\tif (pp->fbs_supported) {\n\t\tdma_sz = AHCI_PORT_PRIV_FBS_DMA_SZ;\n\t\trx_fis_sz = ACARD_AHCI_RX_FIS_SZ * 16;\n\t} else {\n\t\tdma_sz = AHCI_PORT_PRIV_DMA_SZ;\n\t\trx_fis_sz = ACARD_AHCI_RX_FIS_SZ;\n\t}\n\n\tmem = dmam_alloc_coherent(dev, dma_sz, &mem_dma, GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\t \n\tpp->cmd_slot = mem;\n\tpp->cmd_slot_dma = mem_dma;\n\n\tmem += AHCI_CMD_SLOT_SZ;\n\tmem_dma += AHCI_CMD_SLOT_SZ;\n\n\t \n\tpp->rx_fis = mem;\n\tpp->rx_fis_dma = mem_dma;\n\n\tmem += rx_fis_sz;\n\tmem_dma += rx_fis_sz;\n\n\t \n\tpp->cmd_tbl = mem;\n\tpp->cmd_tbl_dma = mem_dma;\n\n\t \n\tpp->intr_mask = DEF_PORT_IRQ;\n\n\tap->private_data = pp;\n\n\t \n\treturn ahci_port_resume(ap);\n}\n\nstatic int acard_ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned int board_id = ent->driver_data;\n\tstruct ata_port_info pi = acard_ahci_port_info[board_id];\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct ata_host *host;\n\tint n_ports, i, rc;\n\n\tWARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = pcim_iomap_regions_request_all(pdev, 1 << AHCI_PCI_BAR, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\n\tif (!hpriv)\n\t\treturn -ENOMEM;\n\n\thpriv->irq = pdev->irq;\n\thpriv->flags |= (unsigned long)pi.private_data;\n\n\tif (!(hpriv->flags & AHCI_HFLAG_NO_MSI))\n\t\tpci_enable_msi(pdev);\n\n\thpriv->mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];\n\n\t \n\tahci_save_initial_config(&pdev->dev, hpriv);\n\n\t \n\tif (hpriv->cap & HOST_CAP_NCQ)\n\t\tpi.flags |= ATA_FLAG_NCQ;\n\n\tif (hpriv->cap & HOST_CAP_PMP)\n\t\tpi.flags |= ATA_FLAG_PMP;\n\n\tahci_set_em_messages(hpriv, &pi);\n\n\t \n\tn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\n\tif (!host)\n\t\treturn -ENOMEM;\n\thost->private_data = hpriv;\n\n\tif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\n\t\thost->flags |= ATA_HOST_PARALLEL_SCAN;\n\telse\n\t\tprintk(KERN_INFO \"ahci: SSS flag set, parallel bus scan disabled\\n\");\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tata_port_pbar_desc(ap, AHCI_PCI_BAR, -1, \"abar\");\n\t\tata_port_pbar_desc(ap, AHCI_PCI_BAR,\n\t\t\t\t   0x100 + ap->port_no * 0x80, \"port\");\n\n\t\t \n\t\t \n\t\t \n\t\tif (!(hpriv->port_map & (1 << i)))\n\t\t\tap->ops = &ata_dummy_port_ops;\n\t}\n\n\t \n\trc = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\tDMA_BIT_MASK((hpriv->cap & HOST_CAP_64) ? 64 : 32));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"DMA enable failed\\n\");\n\t\treturn rc;\n\t}\n\n\trc = ahci_reset_controller(host);\n\tif (rc)\n\t\treturn rc;\n\n\tahci_init_controller(host);\n\tacard_ahci_pci_print_info(host);\n\n\tpci_set_master(pdev);\n\treturn ahci_host_activate(host, &acard_ahci_sht);\n}\n\nmodule_pci_driver(acard_ahci_pci_driver);\n\nMODULE_AUTHOR(\"Jeff Garzik\");\nMODULE_DESCRIPTION(\"ACard AHCI SATA low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, acard_ahci_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}