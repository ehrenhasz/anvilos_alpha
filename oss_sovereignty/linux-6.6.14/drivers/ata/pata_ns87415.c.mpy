{
  "module_name": "pata_ns87415.c",
  "hash_id": "65719126ec68fd017c4bc9d6b97f6a75bc6ad37dd7864e71f39f5c49cecf2180",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_ns87415.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/ata.h>\n\n#define DRV_NAME\t\"pata_ns87415\"\n#define DRV_VERSION\t\"0.0.1\"\n\n \n\nstatic void ns87415_set_mode(struct ata_port *ap, struct ata_device *adev, u8 mode)\n{\n\tstruct pci_dev *dev\t= to_pci_dev(ap->host->dev);\n\tint unit\t\t= 2 * ap->port_no + adev->devno;\n\tint timing\t\t= 0x44 + 2 * unit;\n\tunsigned long T\t\t= 1000000000 / 33333;\t \n\tstruct ata_timing t;\n\tu16 clocking;\n\tu8 iordy;\n\tu8 status;\n\n\t \n\n\tata_timing_compute(adev, adev->pio_mode, &t, T, 0);\n\n\tclocking = 17 - clamp_val(t.active, 2, 17);\n\tclocking |= (16 - clamp_val(t.recover, 1, 16)) << 4;\n \t \n\tclocking |= (clocking << 8);\n\tpci_write_config_word(dev, timing, clocking);\n\n\t \n\tpci_read_config_byte(dev, 0x42, &iordy);\n\tiordy &= ~(1 << (4 + unit));\n\tif (mode >= XFER_MW_DMA_0 || !ata_pio_need_iordy(adev))\n\t\tiordy |= (1 << (4 + unit));\n\n\t \n\n\tpci_read_config_byte(dev, 0x43, &status);\n\twhile (status & 0x03) {\n\t\tudelay(1);\n\t\tpci_read_config_byte(dev, 0x43, &status);\n\t}\n\t \n\tpci_write_config_byte(dev, 0x42, iordy);\n\n\t \n}\n\n \n\nstatic void ns87415_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tns87415_set_mode(ap, adev, adev->pio_mode);\n}\n\n \n\nstatic void ns87415_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tunsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);\n\tu8 dmactl;\n\n\t \n\tmb();\t \n\tiowrite32(ap->bmdma_prd_dma, ap->ioaddr.bmdma_addr + ATA_DMA_TABLE_OFS);\n\n\t \n\tdmactl = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);\n\tdmactl &= ~(ATA_DMA_WR | ATA_DMA_START);\n\t \n\tdmactl |= ATA_DMA_INTR | ATA_DMA_ERR;\n\tif (!rw)\n\t\tdmactl |= ATA_DMA_WR;\n\tiowrite8(dmactl, ap->ioaddr.bmdma_addr + ATA_DMA_CMD);\n\t \n\tap->ops->sff_exec_command(ap, &qc->tf);\n}\n\n \n\nstatic void ns87415_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tns87415_set_mode(qc->ap, qc->dev, qc->dev->dma_mode);\n\tata_bmdma_start(qc);\n}\n\n \n\nstatic void ns87415_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tata_bmdma_stop(qc);\n\tns87415_set_mode(qc->ap, qc->dev, qc->dev->pio_mode);\n}\n\n \n\nstatic void ns87415_irq_clear(struct ata_port *ap)\n{\n\tvoid __iomem *mmio = ap->ioaddr.bmdma_addr;\n\n\tif (!mmio)\n\t\treturn;\n\tiowrite8((ioread8(mmio + ATA_DMA_CMD) | ATA_DMA_INTR | ATA_DMA_ERR),\n\t\t\tmmio + ATA_DMA_CMD);\n}\n\n \n\nstatic int ns87415_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#if defined(CONFIG_SUPERIO)\n\n \n\n#include <asm/superio.h>\n\n#define SUPERIO_IDE_MAX_RETRIES 25\n\n \n\nstatic u8 ns87560_read_buggy(void __iomem *port)\n{\n\tu8 tmp;\n\tint retries = SUPERIO_IDE_MAX_RETRIES;\n\tdo {\n\t\ttmp = ioread8(port);\n\t\tif (tmp != 0)\n\t\t\treturn tmp;\n\t\tudelay(50);\n\t} while(retries-- > 0);\n\treturn tmp;\n}\n\n \n\nstatic u8 ns87560_check_status(struct ata_port *ap)\n{\n\treturn ns87560_read_buggy(ap->ioaddr.status_addr);\n}\n\n \nstatic void ns87560_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\ttf->status = ns87560_check_status(ap);\n\ttf->error = ioread8(ioaddr->error_addr);\n\ttf->nsect = ioread8(ioaddr->nsect_addr);\n\ttf->lbal = ioread8(ioaddr->lbal_addr);\n\ttf->lbam = ioread8(ioaddr->lbam_addr);\n\ttf->lbah = ioread8(ioaddr->lbah_addr);\n\ttf->device = ns87560_read_buggy(ioaddr->device_addr);\n\n\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\tiowrite8(tf->ctl | ATA_HOB, ioaddr->ctl_addr);\n\t\ttf->hob_feature = ioread8(ioaddr->error_addr);\n\t\ttf->hob_nsect = ioread8(ioaddr->nsect_addr);\n\t\ttf->hob_lbal = ioread8(ioaddr->lbal_addr);\n\t\ttf->hob_lbam = ioread8(ioaddr->lbam_addr);\n\t\ttf->hob_lbah = ioread8(ioaddr->lbah_addr);\n\t\tiowrite8(tf->ctl, ioaddr->ctl_addr);\n\t\tap->last_ctl = tf->ctl;\n\t}\n}\n\n \n\nstatic u8 ns87560_bmdma_status(struct ata_port *ap)\n{\n\treturn ns87560_read_buggy(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);\n}\n#endif\t\t \n\nstatic struct ata_port_operations ns87415_pata_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\n\t.check_atapi_dma\t= ns87415_check_atapi_dma,\n\t.bmdma_setup\t\t= ns87415_bmdma_setup,\n\t.bmdma_start\t\t= ns87415_bmdma_start,\n\t.bmdma_stop\t\t= ns87415_bmdma_stop,\n\t.sff_irq_clear\t\t= ns87415_irq_clear,\n\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= ns87415_set_piomode,\n};\n\n#if defined(CONFIG_SUPERIO)\nstatic struct ata_port_operations ns87560_pata_ops = {\n\t.inherits\t\t= &ns87415_pata_ops,\n\t.sff_tf_read\t\t= ns87560_tf_read,\n\t.sff_check_status\t= ns87560_check_status,\n\t.bmdma_status\t\t= ns87560_bmdma_status,\n};\n#endif\n\nstatic const struct scsi_host_template ns87415_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic void ns87415_fixup(struct pci_dev *pdev)\n{\n\t \n\tpci_write_config_byte(pdev, 0x55, 0xEE);\n\t \n\tpci_write_config_byte(pdev, 0x54, 0xB7);\n}\n\n \n\nstatic int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.port_ops\t= &ns87415_pata_ops,\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\tint rc;\n#if defined(CONFIG_SUPERIO)\n\tstatic const struct ata_port_info info87560 = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.mwdma_mask\t= ATA_MWDMA2,\n\t\t.port_ops\t= &ns87560_pata_ops,\n\t};\n\n\tif (PCI_SLOT(pdev->devfn) == 0x0E)\n\t\tppi[0] = &info87560;\n#endif\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tns87415_fixup(pdev);\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &ns87415_sht, NULL, 0);\n}\n\nstatic const struct pci_device_id ns87415_pci_tbl[] = {\n\t{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_87415), },\n\n\t{ }\t \n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ns87415_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tns87415_fixup(pdev);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic struct pci_driver ns87415_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= ns87415_pci_tbl,\n\t.probe\t\t\t= ns87415_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= ns87415_reinit_one,\n#endif\n};\n\nmodule_pci_driver(ns87415_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"ATA low-level driver for NS87415 controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, ns87415_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}