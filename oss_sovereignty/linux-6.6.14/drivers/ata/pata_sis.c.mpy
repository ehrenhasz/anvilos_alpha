{
  "module_name": "pata_sis.c",
  "hash_id": "3dc42a38633b1bf3d6da45d15fa925db2b7cb91efe00486be8ca8098fa1ae702",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_sis.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n#include <linux/ata.h>\n#include \"sis.h\"\n\n#define DRV_NAME\t\"pata_sis\"\n#define DRV_VERSION\t\"0.5.2\"\n\nstruct sis_chipset {\n\tu16 device;\t\t\t\t \n\tconst struct ata_port_info *info;\t \n\t \n};\n\nstruct sis_laptop {\n\tu16 device;\n\tu16 subvendor;\n\tu16 subdevice;\n};\n\nstatic const struct sis_laptop sis_laptop[] = {\n\t \n\t{ 0x5513, 0x1043, 0x1107 },\t \n\t{ 0x5513, 0x1734, 0x105F },\t \n\t{ 0x5513, 0x1071, 0x8640 },\t \n\t \n\t{ 0, }\n};\n\nstatic int sis_short_ata40(struct pci_dev *dev)\n{\n\tconst struct sis_laptop *lap = &sis_laptop[0];\n\n\twhile (lap->device) {\n\t\tif (lap->device == dev->device &&\n\t\t    lap->subvendor == dev->subsystem_vendor &&\n\t\t    lap->subdevice == dev->subsystem_device)\n\t\t\treturn 1;\n\t\tlap++;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int sis_old_port_base(struct ata_device *adev)\n{\n\treturn 0x40 + (4 * adev->link->ap->port_no) + (2 * adev->devno);\n}\n\n \n\nstatic int sis_port_base(struct ata_device *adev)\n{\n\tstruct ata_port *ap = adev->link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port = 0x40;\n\tu32 reg54;\n\n\t \n\tpci_read_config_dword(pdev, 0x54, &reg54);\n\tif (reg54 & 0x40000000)\n\t\tport = 0x70;\n\n\treturn port + (8 * ap->port_no) + (4 * adev->devno);\n}\n\n \n\nstatic int sis_133_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu16 tmp;\n\n\t \n\tpci_read_config_word(pdev, 0x50 + 2 * ap->port_no, &tmp);\n\tif ((tmp & 0x8000) && !sis_short_ata40(pdev))\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\n \n\nstatic int sis_66_cable_detect(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 tmp;\n\n\t \n\tpci_read_config_byte(pdev, 0x48, &tmp);\n\ttmp >>= ap->port_no;\n\tif ((tmp & 0x10) && !sis_short_ata40(pdev))\n\t\treturn ATA_CBL_PATA40;\n\treturn ATA_CBL_PATA80;\n}\n\n\n \n\nstatic int sis_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstatic const struct pci_bits sis_enable_bits[] = {\n\t\t{ 0x4aU, 1U, 0x02UL, 0x02UL },\t \n\t\t{ 0x4aU, 1U, 0x04UL, 0x04UL },\t \n\t};\n\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\n\tif (!pci_test_config_bits(pdev, &sis_enable_bits[ap->port_no]))\n\t\treturn -ENOENT;\n\n\t \n\tpci_write_config_byte(pdev, 0x4B, 0);\n\treturn ata_sff_prereset(link, deadline);\n}\n\n\n \n\nstatic void sis_set_fifo(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu8 fifoctrl;\n\tu8 mask = 0x11;\n\n\tmask <<= (2 * ap->port_no);\n\tmask <<= adev->devno;\n\n\t \n\tpci_read_config_byte(pdev, 0x4B, &fifoctrl);\n\tfifoctrl &= ~mask;\n\n\t \n\tif (adev->class == ATA_DEV_ATA)\n\t\tfifoctrl |= mask;\n\tpci_write_config_byte(pdev, 0x4B, fifoctrl);\n}\n\n \n\nstatic void sis_old_set_piomode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port = sis_old_port_base(adev);\n\tu8 t1, t2;\n\tint speed = adev->pio_mode - XFER_PIO_0;\n\n\tstatic const u8 active[]   = { 0x00, 0x07, 0x04, 0x03, 0x01 };\n\tstatic const u8 recovery[] = { 0x00, 0x06, 0x04, 0x03, 0x03 };\n\n\tsis_set_fifo(ap, adev);\n\n\tpci_read_config_byte(pdev, port, &t1);\n\tpci_read_config_byte(pdev, port + 1, &t2);\n\n\tt1 &= ~0x0F;\t \n\tt2 &= ~0x07;\n\n\tt1 |= active[speed];\n\tt2 |= recovery[speed];\n\n\tpci_write_config_byte(pdev, port, t1);\n\tpci_write_config_byte(pdev, port + 1, t2);\n}\n\n \n\nstatic void sis_100_set_piomode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port = sis_old_port_base(adev);\n\tint speed = adev->pio_mode - XFER_PIO_0;\n\n\tstatic const u8 actrec[] = { 0x00, 0x67, 0x44, 0x33, 0x31 };\n\n\tsis_set_fifo(ap, adev);\n\n\tpci_write_config_byte(pdev, port, actrec[speed]);\n}\n\n \n\nstatic void sis_133_set_piomode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port;\n\tu32 t1;\n\tint speed = adev->pio_mode - XFER_PIO_0;\n\n\tstatic const u32 timing133[] = {\n\t\t0x28269000,\t \n\t\t0x0C266000,\n\t\t0x04263000,\n\t\t0x0C0A3000,\n\t\t0x05093000\n\t};\n\tstatic const u32 timing100[] = {\n\t\t0x1E1C6000,\t \n\t\t0x091C4000,\n\t\t0x031C2000,\n\t\t0x09072000,\n\t\t0x04062000\n\t};\n\n\tsis_set_fifo(ap, adev);\n\n\tport = sis_port_base(adev);\n\tpci_read_config_dword(pdev, port, &t1);\n\tt1 &= 0xC0C00FFF;\t \n\n\tif (t1 & 0x08)\t\t \n\t\tt1 |= timing133[speed];\n\telse\n\t\tt1 |= timing100[speed];\n\tpci_write_config_byte(pdev, port, t1);\n}\n\n \n\nstatic void sis_old_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint speed = adev->dma_mode - XFER_MW_DMA_0;\n\tint drive_pci = sis_old_port_base(adev);\n\tu16 timing;\n\n\tstatic const u16 mwdma_bits[] = { 0x008, 0x302, 0x301 };\n\tstatic const u16 udma_bits[]  = { 0xE000, 0xC000, 0xA000 };\n\n\tpci_read_config_word(pdev, drive_pci, &timing);\n\n\tif (adev->dma_mode < XFER_UDMA_0) {\n\t\t \n\t\ttiming &= ~0x870F;\n\t\ttiming |= mwdma_bits[speed];\n\t} else {\n\t\t \n\t\tspeed = adev->dma_mode - XFER_UDMA_0;\n\t\ttiming &= ~0x6000;\n\t\ttiming |= udma_bits[speed];\n\t}\n\tpci_write_config_word(pdev, drive_pci, timing);\n}\n\n \n\nstatic void sis_66_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint speed = adev->dma_mode - XFER_MW_DMA_0;\n\tint drive_pci = sis_old_port_base(adev);\n\tu16 timing;\n\n\t \n\tstatic const u16 mwdma_bits[] = { 0x008, 0x302, 0x301 };\n\tstatic const u16 udma_bits[]  = { 0xF000, 0xD000, 0xB000, 0xA000, 0x9000, 0x8000 };\n\n\tpci_read_config_word(pdev, drive_pci, &timing);\n\n\tif (adev->dma_mode < XFER_UDMA_0) {\n\t\t \n\t\ttiming &= ~0x870F;\n\t\ttiming |= mwdma_bits[speed];\n\t} else {\n\t\t \n\t\tspeed = adev->dma_mode - XFER_UDMA_0;\n\t\ttiming &= ~0xF000;\n\t\ttiming |= udma_bits[speed];\n\t}\n\tpci_write_config_word(pdev, drive_pci, timing);\n}\n\n \n\nstatic void sis_100_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint speed = adev->dma_mode - XFER_MW_DMA_0;\n\tint drive_pci = sis_old_port_base(adev);\n\tu8 timing;\n\n\tstatic const u8 udma_bits[]  = { 0x8B, 0x87, 0x85, 0x83, 0x82, 0x81};\n\n\tpci_read_config_byte(pdev, drive_pci + 1, &timing);\n\n\tif (adev->dma_mode < XFER_UDMA_0) {\n\t\t \n\t} else {\n\t\t \n\t\tspeed = adev->dma_mode - XFER_UDMA_0;\n\t\ttiming &= ~0x8F;\n\t\ttiming |= udma_bits[speed];\n\t}\n\tpci_write_config_byte(pdev, drive_pci + 1, timing);\n}\n\n \n\nstatic void sis_133_early_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint speed = adev->dma_mode - XFER_MW_DMA_0;\n\tint drive_pci = sis_old_port_base(adev);\n\tu8 timing;\n\t \n\tstatic const u8 udma_bits[]  = { 0x8F, 0x8A, 0x87, 0x85, 0x83, 0x82, 0x81};\n\n\tpci_read_config_byte(pdev, drive_pci + 1, &timing);\n\n\tif (adev->dma_mode < XFER_UDMA_0) {\n\t\t \n\t} else {\n\t\t \n\t\tspeed = adev->dma_mode - XFER_UDMA_0;\n\t\ttiming &= ~0x8F;\n\t\ttiming |= udma_bits[speed];\n\t}\n\tpci_write_config_byte(pdev, drive_pci + 1, timing);\n}\n\n \n\nstatic void sis_133_set_dmamode (struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port;\n\tu32 t1;\n\n\tport = sis_port_base(adev);\n\tpci_read_config_dword(pdev, port, &t1);\n\n\tif (adev->dma_mode < XFER_UDMA_0) {\n\t\t \n\t\tstatic const u32 timing_u100[] = { 0x19154000, 0x06072000, 0x04062000 };\n\t\tstatic const u32 timing_u133[] = { 0x221C6000, 0x0C0A3000, 0x05093000 };\n\t\tint speed = adev->dma_mode - XFER_MW_DMA_0;\n\n\t\tt1 &= 0xC0C00FFF;\n\t\t \n\t\tt1 &= ~0x00000004;\n\t\tif (t1 & 0x08)\n\t\t\tt1 |= timing_u133[speed];\n\t\telse\n\t\t\tt1 |= timing_u100[speed];\n\t} else {\n\t\t \n\t\tstatic const u32 timing_u100[] = { 0x6B0, 0x470, 0x350, 0x140, 0x120, 0x110, 0x000 };\n\t\tstatic const u32 timing_u133[] = { 0x9F0, 0x6A0, 0x470, 0x250, 0x230, 0x220, 0x210 };\n\t\tint speed = adev->dma_mode - XFER_UDMA_0;\n\n\t\tt1 &= ~0x00000FF0;\n\t\t \n\t\tt1 |= 0x00000004;\n\t\tif (t1 & 0x08)\n\t\t\tt1 |= timing_u133[speed];\n\t\telse\n\t\t\tt1 |= timing_u100[speed];\n\t}\n\tpci_write_config_dword(pdev, port, t1);\n}\n\n \n\nstatic unsigned int sis_133_mode_filter(struct ata_device *adev, unsigned int mask)\n{\n\tstruct ata_port *ap = adev->link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint port = sis_port_base(adev);\n\tu32 t1;\n\n\tpci_read_config_dword(pdev, port, &t1);\n\t \n\tif (!(t1 & 0x08))\n\t\tmask &= ~(0xC0 << ATA_SHIFT_UDMA);\n\treturn mask;\n}\n\nstatic const struct scsi_host_template sis_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations sis_133_for_sata_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.set_piomode\t\t= sis_133_set_piomode,\n\t.set_dmamode\t\t= sis_133_set_dmamode,\n\t.cable_detect\t\t= sis_133_cable_detect,\n};\n\nstatic struct ata_port_operations sis_base_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.prereset\t\t= sis_pre_reset,\n};\n\nstatic struct ata_port_operations sis_133_ops = {\n\t.inherits\t\t= &sis_base_ops,\n\t.set_piomode\t\t= sis_133_set_piomode,\n\t.set_dmamode\t\t= sis_133_set_dmamode,\n\t.cable_detect\t\t= sis_133_cable_detect,\n\t.mode_filter\t\t= sis_133_mode_filter,\n};\n\nstatic struct ata_port_operations sis_133_early_ops = {\n\t.inherits\t\t= &sis_base_ops,\n\t.set_piomode\t\t= sis_100_set_piomode,\n\t.set_dmamode\t\t= sis_133_early_set_dmamode,\n\t.cable_detect\t\t= sis_66_cable_detect,\n};\n\nstatic struct ata_port_operations sis_100_ops = {\n\t.inherits\t\t= &sis_base_ops,\n\t.set_piomode\t\t= sis_100_set_piomode,\n\t.set_dmamode\t\t= sis_100_set_dmamode,\n\t.cable_detect\t\t= sis_66_cable_detect,\n};\n\nstatic struct ata_port_operations sis_66_ops = {\n\t.inherits\t\t= &sis_base_ops,\n\t.set_piomode\t\t= sis_old_set_piomode,\n\t.set_dmamode\t\t= sis_66_set_dmamode,\n\t.cable_detect\t\t= sis_66_cable_detect,\n};\n\nstatic struct ata_port_operations sis_old_ops = {\n\t.inherits\t\t= &sis_base_ops,\n\t.set_piomode\t\t= sis_old_set_piomode,\n\t.set_dmamode\t\t= sis_old_set_dmamode,\n\t.cable_detect\t\t= ata_cable_40wire,\n};\n\nstatic const struct ata_port_info sis_info = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t \n\t.port_ops\t= &sis_old_ops,\n};\nstatic const struct ata_port_info sis_info33 = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA2,\n\t.port_ops\t= &sis_old_ops,\n};\nstatic const struct ata_port_info sis_info66 = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t \n\t.udma_mask\t= ATA_UDMA4,\n\t.port_ops\t= &sis_66_ops,\n};\nstatic const struct ata_port_info sis_info100 = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t \n\t.udma_mask\t= ATA_UDMA5,\n\t.port_ops\t= &sis_100_ops,\n};\nstatic const struct ata_port_info sis_info100_early = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t \n\t.udma_mask\t= ATA_UDMA5,\n\t.port_ops\t= &sis_66_ops,\n};\nstatic const struct ata_port_info sis_info133 = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &sis_133_ops,\n};\nconst struct ata_port_info sis_info133_for_sata = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t \n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &sis_133_for_sata_ops,\n};\nstatic const struct ata_port_info sis_info133_early = {\n\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t.pio_mask\t= ATA_PIO4,\n\t \n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &sis_133_early_ops,\n};\n\n \nEXPORT_SYMBOL_GPL(sis_info133_for_sata);\n\nstatic void sis_fixup(struct pci_dev *pdev, struct sis_chipset *sis)\n{\n\tu16 regw;\n\tu8 reg;\n\n\tif (sis->info == &sis_info133) {\n\t\tpci_read_config_word(pdev, 0x50, &regw);\n\t\tif (regw & 0x08)\n\t\t\tpci_write_config_word(pdev, 0x50, regw & ~0x08);\n\t\tpci_read_config_word(pdev, 0x52, &regw);\n\t\tif (regw & 0x08)\n\t\t\tpci_write_config_word(pdev, 0x52, regw & ~0x08);\n\t\treturn;\n\t}\n\n\tif (sis->info == &sis_info133_early || sis->info == &sis_info100) {\n\t\t \n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\n\t\t \n\t\tpci_read_config_byte(pdev, 0x49, &reg);\n\t\tif (!(reg & 0x01))\n\t\t\tpci_write_config_byte(pdev, 0x49, reg | 0x01);\n\t\treturn;\n\t}\n\n\tif (sis->info == &sis_info66 || sis->info == &sis_info100_early) {\n\t\t \n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\n\t\t \n\t\tpci_read_config_byte(pdev, 0x52, &reg);\n\t\tif (!(reg & 0x04))\n\t\t\tpci_write_config_byte(pdev, 0x52, reg | 0x04);\n\t\treturn;\n\t}\n\n\tif (sis->info == &sis_info33) {\n\t\tpci_read_config_byte(pdev, PCI_CLASS_PROG, &reg);\n\t\tif (( reg & 0x0F ) != 0x00)\n\t\t\tpci_write_config_byte(pdev, PCI_CLASS_PROG, reg & 0xF0);\n\t\t \n\t}\n\n\tif (sis->info == &sis_info || sis->info == &sis_info33) {\n\t\t \n\t\tpci_read_config_byte(pdev, 0x52, &reg);\n\t\tif (!(reg & 0x08))\n\t\t\tpci_write_config_byte(pdev, 0x52, reg|0x08);\n\t\treturn;\n\t}\n\n\tBUG();\n}\n\n \n\nstatic int sis_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tconst struct ata_port_info *ppi[] = { NULL, NULL };\n\tstruct pci_dev *host = NULL;\n\tstruct sis_chipset *chipset = NULL;\n\tstruct sis_chipset *sets;\n\tint rc;\n\n\tstatic struct sis_chipset sis_chipsets[] = {\n\n\t\t{ 0x0968, &sis_info133 },\n\t\t{ 0x0966, &sis_info133 },\n\t\t{ 0x0965, &sis_info133 },\n\t\t{ 0x0745, &sis_info100 },\n\t\t{ 0x0735, &sis_info100 },\n\t\t{ 0x0733, &sis_info100 },\n\t\t{ 0x0635, &sis_info100 },\n\t\t{ 0x0633, &sis_info100 },\n\n\t\t{ 0x0730, &sis_info100_early },\t \n\t\t{ 0x0550, &sis_info100_early },\t \n\n\t\t{ 0x0640, &sis_info66 },\n\t\t{ 0x0630, &sis_info66 },\n\t\t{ 0x0620, &sis_info66 },\n\t\t{ 0x0540, &sis_info66 },\n\t\t{ 0x0530, &sis_info66 },\n\n\t\t{ 0x5600, &sis_info33 },\n\t\t{ 0x5598, &sis_info33 },\n\t\t{ 0x5597, &sis_info33 },\n\t\t{ 0x5591, &sis_info33 },\n\t\t{ 0x5582, &sis_info33 },\n\t\t{ 0x5581, &sis_info33 },\n\n\t\t{ 0x5596, &sis_info },\n\t\t{ 0x5571, &sis_info },\n\t\t{ 0x5517, &sis_info },\n\t\t{ 0x5511, &sis_info },\n\n\t\t{0}\n\t};\n\tstatic struct sis_chipset sis133_early = {\n\t\t0x0, &sis_info133_early\n\t};\n\tstatic struct sis_chipset sis133 = {\n\t\t0x0, &sis_info133\n\t};\n\tstatic struct sis_chipset sis100_early = {\n\t\t0x0, &sis_info100_early\n\t};\n\tstatic struct sis_chipset sis100 = {\n\t\t0x0, &sis_info100\n\t};\n\n\tata_print_version_once(&pdev->dev, DRV_VERSION);\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor (sets = &sis_chipsets[0]; sets->device; sets++) {\n\t\thost = pci_get_device(PCI_VENDOR_ID_SI, sets->device, NULL);\n\t\tif (host != NULL) {\n\t\t\tchipset = sets;\t\t\t \n\t\t\tif (sets->device == 0x630) {\t \n\t\t\t\tif (host->revision >= 0x30)\t \n\t\t\t\t\tchipset = &sis100_early;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (chipset == NULL) {\n\t\t \n\t\tu32 idemisc;\n\t\tu16 trueid;\n\n\t\t \n\n\t\tpci_read_config_dword(pdev, 0x54, &idemisc);\n\t\tpci_write_config_dword(pdev, 0x54, idemisc & 0x7fffffff);\n\t\tpci_read_config_word(pdev, PCI_DEVICE_ID, &trueid);\n\t\tpci_write_config_dword(pdev, 0x54, idemisc);\n\n\t\tswitch(trueid) {\n\t\tcase 0x5518:\t \n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"SiS 962/963 MuTIOL IDE UDMA133 controller\\n\");\n\t\t\tchipset = &sis133;\n\t\t\tif ((idemisc & 0x40000000) == 0) {\n\t\t\t\tpci_write_config_dword(pdev, 0x54, idemisc | 0x40000000);\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t \"Switching to 5513 register mapping\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0180:\t \n\t\t\tchipset = &sis133;\n\t\t\tbreak;\n\t\tcase 0x1180:\t \n\t\t\tchipset = &sis133;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (chipset == NULL) {\n\t\tstruct pci_dev *lpc_bridge;\n\t\tu16 trueid;\n\t\tu8 prefctl;\n\t\tu8 idecfg;\n\n\t\t \n\t\tpci_read_config_byte(pdev, 0x4a, &idecfg);\n\t\tpci_write_config_byte(pdev, 0x4a, idecfg | 0x10);\n\t\tpci_read_config_word(pdev, PCI_DEVICE_ID, &trueid);\n\t\tpci_write_config_byte(pdev, 0x4a, idecfg);\n\n\t\tswitch(trueid) {\n\t\tcase 0x5517:\n\t\t\tlpc_bridge = pci_get_slot(pdev->bus, 0x10);  \n\t\t\tif (lpc_bridge == NULL)\n\t\t\t\tbreak;\n\t\t\tpci_read_config_byte(pdev, 0x49, &prefctl);\n\t\t\tpci_dev_put(lpc_bridge);\n\n\t\t\tif (lpc_bridge->revision == 0x10 && (prefctl & 0x80)) {\n\t\t\t\tchipset = &sis133_early;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchipset = &sis100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpci_dev_put(host);\n\n\t \n\tif (chipset == NULL)\n\t\treturn -ENODEV;\n\n\tppi[0] = chipset->info;\n\n\tsis_fixup(pdev, chipset);\n\n\treturn ata_pci_bmdma_init_one(pdev, ppi, &sis_sht, chipset, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sis_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tsis_fixup(pdev, host->private_data);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id sis_pci_tbl[] = {\n\t{ PCI_VDEVICE(SI, 0x5513), },\t \n\t{ PCI_VDEVICE(SI, 0x5518), },\t \n\t{ PCI_VDEVICE(SI, 0x1180), },\t \n\n\t{ }\n};\n\nstatic struct pci_driver sis_pci_driver = {\n\t.name\t\t\t= DRV_NAME,\n\t.id_table\t\t= sis_pci_tbl,\n\t.probe\t\t\t= sis_init_one,\n\t.remove\t\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= ata_pci_device_suspend,\n\t.resume\t\t\t= sis_reinit_one,\n#endif\n};\n\nmodule_pci_driver(sis_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"SCSI low-level driver for SiS ATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, sis_pci_tbl);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}