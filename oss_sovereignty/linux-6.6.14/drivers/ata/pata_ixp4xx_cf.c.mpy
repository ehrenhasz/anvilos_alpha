{
  "module_name": "pata_ixp4xx_cf.c",
  "hash_id": "5b8304a80e6ab3770c414540f3a058894295d7ed0991888b37be14872b791b76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_ixp4xx_cf.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/libata.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <scsi/scsi_host.h>\n\n#define DRV_NAME\t\"pata_ixp4xx_cf\"\n#define DRV_VERSION\t\"1.0\"\n\nstruct ixp4xx_pata {\n\tstruct ata_host *host;\n\tstruct regmap *rmap;\n\tu32 cmd_csreg;\n\tvoid __iomem *cmd;\n\tvoid __iomem *ctl;\n};\n\n#define IXP4XX_EXP_TIMING_STRIDE\t0x04\n \n#define IXP4XX_EXP_T1_T5_MASK\tGENMASK(29, 16)\n#define IXP4XX_EXP_PIO_0_8\t0x0a470000\n#define IXP4XX_EXP_PIO_1_8\t0x06430000\n#define IXP4XX_EXP_PIO_2_8\t0x02410000\n#define IXP4XX_EXP_PIO_3_8\t0x00820000\n#define IXP4XX_EXP_PIO_4_8\t0x00400000\n#define IXP4XX_EXP_PIO_0_16\t0x29640000\n#define IXP4XX_EXP_PIO_1_16\t0x05030000\n#define IXP4XX_EXP_PIO_2_16\t0x00b20000\n#define IXP4XX_EXP_PIO_3_16\t0x00820000\n#define IXP4XX_EXP_PIO_4_16\t0x00400000\n#define IXP4XX_EXP_BW_MASK\t(BIT(6)|BIT(0))\n#define IXP4XX_EXP_BYTE_RD16\tBIT(6)  \n#define IXP4XX_EXP_BYTE_EN\tBIT(0)  \n\nstatic void ixp4xx_set_8bit_timing(struct ixp4xx_pata *ixpp, u8 pio_mode)\n{\n\tswitch (pio_mode) {\n\tcase XFER_PIO_0:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_0_8);\n\t\tbreak;\n\tcase XFER_PIO_1:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_1_8);\n\t\tbreak;\n\tcase XFER_PIO_2:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_2_8);\n\t\tbreak;\n\tcase XFER_PIO_3:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_3_8);\n\t\tbreak;\n\tcase XFER_PIO_4:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_4_8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t   IXP4XX_EXP_BW_MASK, IXP4XX_EXP_BYTE_RD16|IXP4XX_EXP_BYTE_EN);\n}\n\nstatic void ixp4xx_set_16bit_timing(struct ixp4xx_pata *ixpp, u8 pio_mode)\n{\n\tswitch (pio_mode){\n\tcase XFER_PIO_0:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_0_16);\n\t\tbreak;\n\tcase XFER_PIO_1:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_1_16);\n\t\tbreak;\n\tcase XFER_PIO_2:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_2_16);\n\t\tbreak;\n\tcase XFER_PIO_3:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_3_16);\n\t\tbreak;\n\tcase XFER_PIO_4:\n\t\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t\t   IXP4XX_EXP_T1_T5_MASK, IXP4XX_EXP_PIO_4_16);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tregmap_update_bits(ixpp->rmap, ixpp->cmd_csreg,\n\t\t\t   IXP4XX_EXP_BW_MASK, IXP4XX_EXP_BYTE_RD16);\n}\n\n \nstatic void ixp4xx_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ixp4xx_pata *ixpp = ap->host->private_data;\n\n\tata_dev_info(adev, \"configured for PIO%d 8bit\\n\",\n\t\t       adev->pio_mode - XFER_PIO_0);\n\tixp4xx_set_8bit_timing(ixpp, adev->pio_mode);\n}\n\n\nstatic unsigned int ixp4xx_mmio_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\t\t  unsigned char *buf, unsigned int buflen, int rw)\n{\n\tunsigned int i;\n\tunsigned int words = buflen >> 1;\n\tu16 *buf16 = (u16 *) buf;\n\tstruct ata_device *adev = qc->dev;\n\tstruct ata_port *ap = qc->dev->link->ap;\n\tvoid __iomem *mmio = ap->ioaddr.data_addr;\n\tstruct ixp4xx_pata *ixpp = ap->host->private_data;\n\tunsigned long flags;\n\n\tata_dev_dbg(adev, \"%s %d bytes\\n\", (rw == READ) ? \"READ\" : \"WRITE\",\n\t\t    buflen);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tixp4xx_set_16bit_timing(ixpp, adev->pio_mode);\n\tudelay(5);\n\n\t \n\tif (rw == READ)\n\t\tfor (i = 0; i < words; i++)\n\t\t\tbuf16[i] = readw(mmio);\n\telse\n\t\tfor (i = 0; i < words; i++)\n\t\t\twritew(buf16[i], mmio);\n\n\t \n\tif (unlikely(buflen & 0x01)) {\n\t\tu16 align_buf[1] = { 0 };\n\t\tunsigned char *trailing_buf = buf + buflen - 1;\n\n\t\tif (rw == READ) {\n\t\t\talign_buf[0] = readw(mmio);\n\t\t\tmemcpy(trailing_buf, align_buf, 1);\n\t\t} else {\n\t\t\tmemcpy(align_buf, trailing_buf, 1);\n\t\t\twritew(align_buf[0], mmio);\n\t\t}\n\t\twords++;\n\t}\n\n\tixp4xx_set_8bit_timing(ixpp, adev->pio_mode);\n\tudelay(5);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn words << 1;\n}\n\nstatic const struct scsi_host_template ixp4xx_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations ixp4xx_port_ops = {\n\t.inherits\t\t= &ata_sff_port_ops,\n\t.sff_data_xfer\t\t= ixp4xx_mmio_data_xfer,\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= ixp4xx_set_piomode,\n};\n\nstatic struct ata_port_info ixp4xx_port_info = {\n\t.flags\t\t= ATA_FLAG_NO_ATAPI,\n\t.pio_mask\t= ATA_PIO4,\n\t.port_ops\t= &ixp4xx_port_ops,\n};\n\nstatic void ixp4xx_setup_port(struct ata_port *ap,\n\t\t\t      struct ixp4xx_pata *ixpp,\n\t\t\t      unsigned long raw_cmd, unsigned long raw_ctl)\n{\n\tstruct ata_ioports *ioaddr = &ap->ioaddr;\n\n\traw_ctl += 0x06;\n\tioaddr->cmd_addr\t= ixpp->cmd;\n\tioaddr->altstatus_addr\t= ixpp->ctl + 0x06;\n\tioaddr->ctl_addr\t= ixpp->ctl + 0x06;\n\n\tata_sff_std_ports(ioaddr);\n\n\tif (!IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)) {\n\t\t \n\n\t\t*(unsigned long *)&ioaddr->data_addr\t\t^= 0x02;\n\t\t*(unsigned long *)&ioaddr->cmd_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->altstatus_addr\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->ctl_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->error_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->feature_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->nsect_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->lbal_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->lbam_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->lbah_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->device_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->status_addr\t\t^= 0x03;\n\t\t*(unsigned long *)&ioaddr->command_addr\t\t^= 0x03;\n\n\t\traw_cmd ^= 0x03;\n\t\traw_ctl ^= 0x03;\n\t}\n\n\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\", raw_cmd, raw_ctl);\n}\n\nstatic int ixp4xx_pata_probe(struct platform_device *pdev)\n{\n\tstruct resource *cmd, *ctl;\n\tstruct ata_port_info pi = ixp4xx_port_info;\n\tconst struct ata_port_info *ppi[] = { &pi, NULL };\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ixp4xx_pata *ixpp;\n\tu32 csindex;\n\tint ret;\n\tint irq;\n\n\tixpp = devm_kzalloc(dev, sizeof(*ixpp), GFP_KERNEL);\n\tif (!ixpp)\n\t\treturn -ENOMEM;\n\n\tixpp->rmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(ixpp->rmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(ixpp->rmap), \"no regmap\\n\");\n\t \n\tret = of_property_read_u32_index(np, \"reg\", 0, &csindex);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"can't inspect CMD address\\n\");\n\tdev_info(dev, \"using CS%d for PIO timing configuration\\n\", csindex);\n\tixpp->cmd_csreg = csindex * IXP4XX_EXP_TIMING_STRIDE;\n\n\tixpp->host = ata_host_alloc_pinfo(dev, ppi, 1);\n\tif (!ixpp->host)\n\t\treturn -ENOMEM;\n\tixpp->host->private_data = ixpp;\n\n\tret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tixpp->cmd = devm_platform_get_and_ioremap_resource(pdev, 0, &cmd);\n\tif (IS_ERR(ixpp->cmd))\n\t\treturn PTR_ERR(ixpp->cmd);\n\n\tixpp->ctl = devm_platform_get_and_ioremap_resource(pdev, 1, &ctl);\n\tif (IS_ERR(ixpp->ctl))\n\t\treturn PTR_ERR(ixpp->ctl);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tirq_set_irq_type(irq, IRQ_TYPE_EDGE_RISING);\n\n\t \n\tixp4xx_setup_port(ixpp->host->ports[0], ixpp, cmd->start, ctl->start);\n\n\tata_print_version_once(dev, DRV_VERSION);\n\n\treturn ata_host_activate(ixpp->host, irq, ata_sff_interrupt, 0, &ixp4xx_sht);\n}\n\nstatic const struct of_device_id ixp4xx_pata_of_match[] = {\n\t{ .compatible = \"intel,ixp4xx-compact-flash\", },\n\t{   }\n};\n\nstatic struct platform_driver ixp4xx_pata_platform_driver = {\n\t.driver\t = {\n\t\t.name   = DRV_NAME,\n\t\t.of_match_table = ixp4xx_pata_of_match,\n\t},\n\t.probe\t\t= ixp4xx_pata_probe,\n\t.remove_new\t= ata_platform_remove_one,\n};\n\nmodule_platform_driver(ixp4xx_pata_platform_driver);\n\nMODULE_AUTHOR(\"Alessandro Zummo <a.zummo@towertech.it>\");\nMODULE_DESCRIPTION(\"low-level driver for ixp4xx Compact Flash PATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}