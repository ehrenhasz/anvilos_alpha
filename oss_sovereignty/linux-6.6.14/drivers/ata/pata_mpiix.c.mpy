{
  "module_name": "pata_mpiix.c",
  "hash_id": "9fbe95ea58d3afe3414c26eeabd169f909545035091dd2da20d4d3525a66cc0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_mpiix.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_mpiix\"\n#define DRV_VERSION \"0.7.7\"\n\nenum {\n\tIDETIM = 0x6C,\t\t \n\tIORDY = (1 << 1),\n\tPPE = (1 << 2),\n\tFTIM = (1 << 0),\n\tENABLED = (1 << 15),\n\tSECONDARY = (1 << 14)\n};\n\nstatic int mpiix_pre_reset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstatic const struct pci_bits mpiix_enable_bits = { 0x6D, 1, 0x80, 0x80 };\n\n\tif (!pci_test_config_bits(pdev, &mpiix_enable_bits))\n\t\treturn -ENOENT;\n\n\treturn ata_sff_prereset(link, deadline);\n}\n\n \n\nstatic void mpiix_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tint control = 0;\n\tint pio = adev->pio_mode - XFER_PIO_0;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tu16 idetim;\n\tstatic const\t  \n\tu8 timings[][2]\t= { { 0, 0 },\n\t\t\t    { 0, 0 },\n\t\t\t    { 1, 0 },\n\t\t\t    { 2, 1 },\n\t\t\t    { 2, 3 }, };\n\n\tpci_read_config_word(pdev, IDETIM, &idetim);\n\n\t \n\tif (adev->class == ATA_DEV_ATA)\n\t\tcontrol |= PPE;\t\t \n\tif (ata_pio_need_iordy(adev))\n\t\tcontrol |= IORDY;\n\tif (pio > 1)\n\t\tcontrol |= FTIM;\t \n\n\t \n\tidetim &= 0xCCEE;\n\tidetim &= ~(0x07  << (4 * adev->devno));\n\tidetim |= control << (4 * adev->devno);\n\n\tidetim |= (timings[pio][0] << 12) | (timings[pio][1] << 8);\n\tpci_write_config_word(pdev, IDETIM, idetim);\n\n\t \n\tap->private_data = adev;\n}\n\n \n\nstatic unsigned int mpiix_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\n\t \n\n\tif (adev->pio_mode && adev != ap->private_data)\n\t\tmpiix_set_piomode(ap, adev);\n\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic const struct scsi_host_template mpiix_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations mpiix_port_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.qc_issue\t= mpiix_qc_issue,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= mpiix_set_piomode,\n\t.prereset\t= mpiix_pre_reset,\n\t.sff_data_xfer\t= ata_sff_data_xfer32,\n};\n\nstatic int mpiix_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\t \n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tvoid __iomem *cmd_addr, *ctl_addr;\n\tu16 idetim;\n\tint cmd, ctl, irq;\n\n\tata_print_version_once(&dev->dev, DRV_VERSION);\n\n\thost = ata_host_alloc(&dev->dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\tap = host->ports[0];\n\n\t \n\n\tpci_read_config_word(dev, IDETIM, &idetim);\n\tif (!(idetim & ENABLED))\n\t\treturn -ENODEV;\n\n\t \n\tif (!(idetim & SECONDARY)) {\n\t\tcmd = 0x1F0;\n\t\tctl = 0x3F6;\n\t\tirq = 14;\n\t} else {\n\t\tcmd = 0x170;\n\t\tctl = 0x376;\n\t\tirq = 15;\n\t}\n\n\tcmd_addr = devm_ioport_map(&dev->dev, cmd, 8);\n\tctl_addr = devm_ioport_map(&dev->dev, ctl, 1);\n\tif (!cmd_addr || !ctl_addr)\n\t\treturn -ENOMEM;\n\n\tata_port_desc(ap, \"cmd 0x%x ctl 0x%x\", cmd, ctl);\n\n\t \n\n\tap->ops = &mpiix_port_ops;\n\tap->pio_mask = ATA_PIO4;\n\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\n\tap->ioaddr.cmd_addr = cmd_addr;\n\tap->ioaddr.ctl_addr = ctl_addr;\n\tap->ioaddr.altstatus_addr = ctl_addr;\n\n\t \n\tata_sff_std_ports(&ap->ioaddr);\n\n\t \n\treturn ata_host_activate(host, irq, ata_sff_interrupt, IRQF_SHARED,\n\t\t\t\t &mpiix_sht);\n}\n\nstatic const struct pci_device_id mpiix[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_82371MX), },\n\n\t{ },\n};\n\nstatic struct pci_driver mpiix_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= mpiix,\n\t.probe \t\t= mpiix_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ata_pci_device_resume,\n#endif\n};\n\nmodule_pci_driver(mpiix_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Intel MPIIX\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, mpiix);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}