{
  "module_name": "pata_pxa.c",
  "hash_id": "de5aa85bce2aa7aa2877eb8489510a6763dca2a3ed9280edc678e3fdb499c371",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_pxa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n#include <linux/platform_device.h>\n#include <linux/dmaengine.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n\n#include <scsi/scsi_host.h>\n\n#include <linux/platform_data/ata-pxa.h>\n\n#define DRV_NAME\t\"pata_pxa\"\n#define DRV_VERSION\t\"0.1\"\n\nstruct pata_pxa_data {\n\tstruct dma_chan\t\t*dma_chan;\n\tdma_cookie_t\t\tdma_cookie;\n\tstruct completion\tdma_done;\n};\n\n \nstatic void pxa_ata_dma_irq(void *d)\n{\n\tstruct pata_pxa_data *pd = d;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(pd->dma_chan, pd->dma_cookie, NULL);\n\tif (status == DMA_ERROR || status == DMA_COMPLETE)\n\t\tcomplete(&pd->dma_done);\n}\n\n \nstatic enum ata_completion_errors pxa_qc_prep(struct ata_queued_cmd *qc)\n{\n\tstruct pata_pxa_data *pd = qc->ap->private_data;\n\tstruct dma_async_tx_descriptor *tx;\n\tenum dma_transfer_direction dir;\n\n\tif (!(qc->flags & ATA_QCFLAG_DMAMAP))\n\t\treturn AC_ERR_OK;\n\n\tdir = (qc->dma_dir == DMA_TO_DEVICE ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM);\n\ttx = dmaengine_prep_slave_sg(pd->dma_chan, qc->sg, qc->n_elem, dir,\n\t\t\t\t     DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tata_dev_err(qc->dev, \"prep_slave_sg() failed\\n\");\n\t\treturn AC_ERR_OK;\n\t}\n\ttx->callback = pxa_ata_dma_irq;\n\ttx->callback_param = pd;\n\tpd->dma_cookie = dmaengine_submit(tx);\n\n\treturn AC_ERR_OK;\n}\n\n \nstatic void pxa_bmdma_setup(struct ata_queued_cmd *qc)\n{\n\tqc->ap->ops->sff_exec_command(qc->ap, &qc->tf);\n}\n\n \nstatic void pxa_bmdma_start(struct ata_queued_cmd *qc)\n{\n\tstruct pata_pxa_data *pd = qc->ap->private_data;\n\tinit_completion(&pd->dma_done);\n\tdma_async_issue_pending(pd->dma_chan);\n}\n\n \nstatic void pxa_bmdma_stop(struct ata_queued_cmd *qc)\n{\n\tstruct pata_pxa_data *pd = qc->ap->private_data;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(pd->dma_chan, pd->dma_cookie, NULL);\n\tif (status != DMA_ERROR && status != DMA_COMPLETE &&\n\t    wait_for_completion_timeout(&pd->dma_done, HZ))\n\t\tata_dev_err(qc->dev, \"Timeout waiting for DMA completion!\");\n\n\tdmaengine_terminate_all(pd->dma_chan);\n}\n\n \nstatic unsigned char pxa_bmdma_status(struct ata_port *ap)\n{\n\tstruct pata_pxa_data *pd = ap->private_data;\n\tunsigned char ret = ATA_DMA_INTR;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tstatus = dmaengine_tx_status(pd->dma_chan, pd->dma_cookie, &state);\n\tif (status != DMA_COMPLETE)\n\t\tret |= ATA_DMA_ERR;\n\n\treturn ret;\n}\n\n \nstatic void pxa_irq_clear(struct ata_port *ap)\n{\n}\n\n \nstatic int pxa_check_atapi_dma(struct ata_queued_cmd *qc)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct scsi_host_template pxa_ata_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations pxa_ata_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.cable_detect\t\t= ata_cable_40wire,\n\n\t.bmdma_setup\t\t= pxa_bmdma_setup,\n\t.bmdma_start\t\t= pxa_bmdma_start,\n\t.bmdma_stop\t\t= pxa_bmdma_stop,\n\t.bmdma_status\t\t= pxa_bmdma_status,\n\n\t.check_atapi_dma\t= pxa_check_atapi_dma,\n\n\t.sff_irq_clear\t\t= pxa_irq_clear,\n\n\t.qc_prep\t\t= pxa_qc_prep,\n};\n\nstatic int pxa_ata_probe(struct platform_device *pdev)\n{\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tstruct pata_pxa_data *data;\n\tstruct resource *cmd_res;\n\tstruct resource *ctl_res;\n\tstruct resource *dma_res;\n\tstruct pata_pxa_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct dma_slave_config\tconfig;\n\tint ret = 0;\n\tint irq;\n\n\t \n\tif (pdev->num_resources != 4) {\n\t\tdev_err(&pdev->dev, \"invalid number of resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcmd_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(cmd_res == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tctl_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (unlikely(ctl_res == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tdma_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (unlikely(dma_res == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tap\t\t= host->ports[0];\n\tap->ops\t\t= &pxa_ata_port_ops;\n\tap->pio_mask\t= ATA_PIO4;\n\tap->mwdma_mask\t= ATA_MWDMA2;\n\n\tap->ioaddr.cmd_addr\t= devm_ioremap(&pdev->dev, cmd_res->start,\n\t\t\t\t\t\tresource_size(cmd_res));\n\tap->ioaddr.ctl_addr\t= devm_ioremap(&pdev->dev, ctl_res->start,\n\t\t\t\t\t\tresource_size(ctl_res));\n\tap->ioaddr.bmdma_addr\t= devm_ioremap(&pdev->dev, dma_res->start,\n\t\t\t\t\t\tresource_size(dma_res));\n\n\t \n\tap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\n\tap->ioaddr.data_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_DATA << pdata->reg_shift);\n\tap->ioaddr.error_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_ERR << pdata->reg_shift);\n\tap->ioaddr.feature_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_FEATURE << pdata->reg_shift);\n\tap->ioaddr.nsect_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_NSECT << pdata->reg_shift);\n\tap->ioaddr.lbal_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_LBAL << pdata->reg_shift);\n\tap->ioaddr.lbam_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_LBAM << pdata->reg_shift);\n\tap->ioaddr.lbah_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_LBAH << pdata->reg_shift);\n\tap->ioaddr.device_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_DEVICE << pdata->reg_shift);\n\tap->ioaddr.status_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_STATUS << pdata->reg_shift);\n\tap->ioaddr.command_addr\t= ap->ioaddr.cmd_addr +\n\t\t\t\t\t(ATA_REG_CMD << pdata->reg_shift);\n\n\t \n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct pata_pxa_data),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tap->private_data = data;\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tconfig.src_addr = dma_res->start;\n\tconfig.dst_addr = dma_res->start;\n\tconfig.src_maxburst = 32;\n\tconfig.dst_maxburst = 32;\n\n\t \n\tdata->dma_chan =\n\t\tdma_request_slave_channel(&pdev->dev, \"data\");\n\tif (!data->dma_chan)\n\t\treturn -EBUSY;\n\tret = dmaengine_slave_config(data->dma_chan, &config);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"dma configuration failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ata_host_activate(host, irq, ata_sff_interrupt,\n\t\t\t\tpdata->irq_flags, &pxa_ata_sht);\n\tif (ret)\n\t\tdma_release_channel(data->dma_chan);\n\n\treturn ret;\n}\n\nstatic void pxa_ata_remove(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct pata_pxa_data *data = host->ports[0]->private_data;\n\n\tdma_release_channel(data->dma_chan);\n\n\tata_host_detach(host);\n}\n\nstatic struct platform_driver pxa_ata_driver = {\n\t.probe\t\t= pxa_ata_probe,\n\t.remove_new\t= pxa_ata_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t},\n};\n\nmodule_platform_driver(pxa_ata_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut@gmail.com>\");\nMODULE_DESCRIPTION(\"DMA-capable driver for PATA on PXA CPU\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}