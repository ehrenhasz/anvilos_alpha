{
  "module_name": "pata_cmd640.c",
  "hash_id": "db1b3632599dedb49e491c92086505a947b55e68e18dcfb7f8d3ffef6cbcc88e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_cmd640.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_cmd640\"\n#define DRV_VERSION \"0.0.5\"\n\nstruct cmd640_reg {\n\tint last;\n\tu8 reg58[ATA_MAX_DEVICES];\n};\n\nenum {\n\tCFR = 0x50,\n\tCNTRL = 0x51,\n\tCMDTIM = 0x52,\n\tARTIM0 = 0x53,\n\tDRWTIM0 = 0x54,\n\tARTIM23 = 0x57,\n\tDRWTIM23 = 0x58,\n\tBRST = 0x59\n};\n\n \n\nstatic void cmd640_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct cmd640_reg *timing = ap->private_data;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct ata_timing t;\n\tconst unsigned long T = 1000000 / 33;\n\tconst u8 setup_data[] = { 0x40, 0x40, 0x40, 0x80, 0x00 };\n\tu8 reg;\n\tint arttim = ARTIM0 + 2 * adev->devno;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\n\tif (ata_timing_compute(adev, adev->pio_mode, &t, T, 0) < 0) {\n\t\tata_dev_err(adev, DRV_NAME \": mode computation failed.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (ap->port_no && pair) {\n\t\tstruct ata_timing p;\n\t\tata_timing_compute(pair, pair->pio_mode, &p, T, 1);\n\t\tata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP);\n\t}\n\n\t \n\tif (t.recover > 16) {\n\t\tt.active += t.recover - 16;\n\t\tt.recover = 16;\n\t}\n\tif (t.active > 16)\n\t\tt.active = 16;\n\n\t \n\n\tif (t.recover > 1)\n\t\tt.recover--;\t \n\telse\n\t\tt.recover = 15;\n\n\tif (t.setup > 4)\n\t\tt.setup = 0xC0;\n\telse\n\t\tt.setup = setup_data[t.setup];\n\n\tif (ap->port_no == 0) {\n\t\tt.active &= 0x0F;\t \n\n\t\t \n\t\tpci_read_config_byte(pdev, arttim, &reg);\n\t\treg &= 0x3F;\n\t\treg |= t.setup;\n\t\tpci_write_config_byte(pdev, arttim, reg);\n\n\t\t \n\t\tpci_write_config_byte(pdev, arttim + 1, (t.active << 4) | t.recover);\n\t} else {\n\t\t \n\t\tpci_read_config_byte(pdev, ARTIM23, &reg);\n\t\treg &= 0x3F;\n\t\treg |= t.setup;\n\t\tpci_write_config_byte(pdev, ARTIM23, reg);\n\t\ttiming->reg58[adev->devno] = (t.active << 4) | t.recover;\n\t}\n}\n\n\n \n\nstatic unsigned int cmd640_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct cmd640_reg *timing = ap->private_data;\n\n\tif (ap->port_no != 0 && adev->devno != timing->last) {\n\t\tpci_write_config_byte(pdev, DRWTIM23, timing->reg58[adev->devno]);\n\t\ttiming->last = adev->devno;\n\t}\n\treturn ata_sff_qc_issue(qc);\n}\n\n \n\nstatic int cmd640_port_start(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tstruct cmd640_reg *timing;\n\n\ttiming = devm_kzalloc(&pdev->dev, sizeof(struct cmd640_reg), GFP_KERNEL);\n\tif (timing == NULL)\n\t\treturn -ENOMEM;\n\ttiming->last = -1;\t \n\tap->private_data = timing;\n\treturn 0;\n}\n\nstatic bool cmd640_sff_irq_check(struct ata_port *ap)\n{\n\tstruct pci_dev *pdev\t= to_pci_dev(ap->host->dev);\n\tint irq_reg\t\t= ap->port_no ? ARTIM23 : CFR;\n\tu8  irq_stat, irq_mask\t= ap->port_no ? 0x10 : 0x04;\n\n\tpci_read_config_byte(pdev, irq_reg, &irq_stat);\n\n\treturn irq_stat & irq_mask;\n}\n\nstatic const struct scsi_host_template cmd640_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations cmd640_port_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t \n\t.sff_data_xfer\t= ata_sff_data_xfer32,\n\t.sff_irq_check\t= cmd640_sff_irq_check,\n\t.qc_issue\t= cmd640_qc_issue,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= cmd640_set_piomode,\n\t.port_start\t= cmd640_port_start,\n};\n\nstatic void cmd640_hardware_init(struct pci_dev *pdev)\n{\n\tu8 ctrl;\n\n\t \n\tpci_write_config_byte(pdev, 0x5B, 0x00);\n\t \n\tpci_write_config_byte(pdev, CMDTIM, 0);\n\t \n\tpci_write_config_byte(pdev, BRST, 0x40);\n\t \n\t \n\tpci_read_config_byte(pdev, CNTRL, &ctrl);\n\tpci_write_config_byte(pdev, CNTRL, ctrl | 0xC0);\n\t \n\tpci_read_config_byte(pdev, ARTIM23, &ctrl);\n\tctrl |= 0x0C;\n\tpci_write_config_byte(pdev, ARTIM23, ctrl);\n}\n\nstatic int cmd640_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct ata_port_info info = {\n\t\t.flags = ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask = ATA_PIO4,\n\t\t.port_ops = &cmd640_port_ops\n\t};\n\tconst struct ata_port_info *ppi[] = { &info, NULL };\n\tint rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tcmd640_hardware_init(pdev);\n\n\treturn ata_pci_sff_init_one(pdev, ppi, &cmd640_sht, NULL, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cmd640_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\tcmd640_hardware_init(pdev);\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id cmd640[] = {\n\t{ PCI_VDEVICE(CMD, 0x640), 0 },\n\t{ },\n};\n\nstatic struct pci_driver cmd640_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= cmd640,\n\t.probe \t\t= cmd640_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= cmd640_reinit_one,\n#endif\n};\n\nmodule_pci_driver(cmd640_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for CMD640 PATA controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, cmd640);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}