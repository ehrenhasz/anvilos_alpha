{
  "module_name": "pata_cs5520.c",
  "hash_id": "60afd19d5a86e0305ca4b56714d2cfd954a64ea74b6cc59365c564fa39e4a019",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_cs5520.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME\t\"pata_cs5520\"\n#define DRV_VERSION\t\"0.6.6\"\n\nstruct pio_clocks\n{\n\tint address;\n\tint assert;\n\tint recovery;\n};\n\nstatic const struct pio_clocks cs5520_pio_clocks[]={\n\t{3, 6, 11},\n\t{2, 5, 6},\n\t{1, 4, 3},\n\t{1, 3, 2},\n\t{1, 2, 1}\n};\n\n \n\nstatic void cs5520_set_timings(struct ata_port *ap, struct ata_device *adev, int pio)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tint slave = adev->devno;\n\n\tpio -= XFER_PIO_0;\n\n\t \n\tpci_write_config_byte(pdev, 0x62 + ap->port_no,\n\t\t\t\t(cs5520_pio_clocks[pio].recovery << 4) |\n\t\t\t\t(cs5520_pio_clocks[pio].assert));\n\t \n\t \n\tpci_write_config_byte(pdev, 0x64 +  4*ap->port_no + slave,\n\t\t\t\t(cs5520_pio_clocks[pio].recovery << 4) |\n\t\t\t\t(cs5520_pio_clocks[pio].assert));\n\t \n\tpci_write_config_byte(pdev, 0x66 +  4*ap->port_no + slave,\n\t\t\t\t(cs5520_pio_clocks[pio].recovery << 4) |\n\t\t\t\t(cs5520_pio_clocks[pio].assert));\n}\n\n \n\nstatic void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tcs5520_set_timings(ap, adev, adev->pio_mode);\n}\n\nstatic const struct scsi_host_template cs5520_sht = {\n\tATA_BASE_SHT(DRV_NAME),\n\t.sg_tablesize\t\t= LIBATA_DUMB_MAX_PRD,\n\t.dma_boundary\t\t= ATA_DMA_BOUNDARY,\n};\n\nstatic struct ata_port_operations cs5520_port_ops = {\n\t.inherits\t\t= &ata_bmdma_port_ops,\n\t.qc_prep\t\t= ata_bmdma_dumb_qc_prep,\n\t.cable_detect\t\t= ata_cable_40wire,\n\t.set_piomode\t\t= cs5520_set_piomode,\n};\n\nstatic int cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const unsigned int cmd_port[] = { 0x1F0, 0x170 };\n\tstatic const unsigned int ctl_port[] = { 0x3F6, 0x376 };\n\tstruct ata_port_info pi = {\n\t\t.flags\t\t= ATA_FLAG_SLAVE_POSS,\n\t\t.pio_mask\t= ATA_PIO4,\n\t\t.port_ops\t= &cs5520_port_ops,\n\t};\n\tconst struct ata_port_info *ppi[2];\n\tu8 pcicfg;\n\tvoid __iomem *iomap[5];\n\tstruct ata_host *host;\n\tstruct ata_ioports *ioaddr;\n\tint i, rc;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpci_read_config_byte(pdev, 0x60, &pcicfg);\n\n\t \n\tif ((pcicfg & 3) == 0)\n\t\treturn -ENODEV;\n\n\tppi[0] = ppi[1] = &ata_dummy_port_info;\n\tif (pcicfg & 1)\n\t\tppi[0] = &pi;\n\tif (pcicfg & 2)\n\t\tppi[1] = &pi;\n\n\tif ((pcicfg & 0x40) == 0) {\n\t\tdev_warn(&pdev->dev, \"DMA mode disabled. Enabling.\\n\");\n\t\tpci_write_config_byte(pdev, 0x60, pcicfg | 0x40);\n\t}\n\n\tpi.mwdma_mask = id->driver_data;\n\n\thost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pci_enable_device_io(pdev)) {\n\t\tdev_err(&pdev->dev, \"unable to configure BAR2.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(&pdev->dev, \"unable to configure DMA mask.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tiomap[0] = devm_ioport_map(&pdev->dev, cmd_port[0], 8);\n\tiomap[1] = devm_ioport_map(&pdev->dev, ctl_port[0], 1);\n\tiomap[2] = devm_ioport_map(&pdev->dev, cmd_port[1], 8);\n\tiomap[3] = devm_ioport_map(&pdev->dev, ctl_port[1], 1);\n\tiomap[4] = pcim_iomap(pdev, 2, 0);\n\n\tif (!iomap[0] || !iomap[1] || !iomap[2] || !iomap[3] || !iomap[4])\n\t\treturn -ENOMEM;\n\n\tioaddr = &host->ports[0]->ioaddr;\n\tioaddr->cmd_addr = iomap[0];\n\tioaddr->ctl_addr = iomap[1];\n\tioaddr->altstatus_addr = iomap[1];\n\tioaddr->bmdma_addr = iomap[4];\n\tata_sff_std_ports(ioaddr);\n\n\tata_port_desc(host->ports[0],\n\t\t      \"cmd 0x%x ctl 0x%x\", cmd_port[0], ctl_port[0]);\n\tata_port_pbar_desc(host->ports[0], 4, 0, \"bmdma\");\n\n\tioaddr = &host->ports[1]->ioaddr;\n\tioaddr->cmd_addr = iomap[2];\n\tioaddr->ctl_addr = iomap[3];\n\tioaddr->altstatus_addr = iomap[3];\n\tioaddr->bmdma_addr = iomap[4] + 8;\n\tata_sff_std_ports(ioaddr);\n\n\tata_port_desc(host->ports[1],\n\t\t      \"cmd 0x%x ctl 0x%x\", cmd_port[1], ctl_port[1]);\n\tata_port_pbar_desc(host->ports[1], 4, 8, \"bmdma\");\n\n\t \n\tpci_set_master(pdev);\n\trc = ata_host_start(host);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const int irq[] = { 14, 15 };\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (ata_port_is_dummy(ap))\n\t\t\tcontinue;\n\n\t\trc = devm_request_irq(&pdev->dev, irq[ap->port_no],\n\t\t\t\t      ata_bmdma_interrupt, 0, DRV_NAME, host);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tata_port_desc(ap, \"irq %d\", irq[i]);\n\t}\n\n\treturn ata_host_register(host, &cs5520_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \n\nstatic int cs5520_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tu8 pcicfg;\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_read_config_byte(pdev, 0x60, &pcicfg);\n\tif ((pcicfg & 0x40) == 0)\n\t\tpci_write_config_byte(pdev, 0x60, pcicfg | 0x40);\n\n\tata_host_resume(host);\n\treturn 0;\n}\n\n \n\nstatic int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\n\tata_host_suspend(host, mesg);\n\n\tpci_save_state(pdev);\n\treturn 0;\n}\n#endif  \n\n \n\nstatic const struct pci_device_id pata_cs5520[] = {\n\t{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5510), },\n\t{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5520), },\n\n\t{ },\n};\n\nstatic struct pci_driver cs5520_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= pata_cs5520,\n\t.probe \t\t= cs5520_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= cs5520_pci_device_suspend,\n\t.resume\t\t= cs5520_reinit_one,\n#endif\n};\n\nmodule_pci_driver(cs5520_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Cyrix CS5510/5520\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pata_cs5520);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}