{
  "module_name": "ahci_mvebu.c",
  "hash_id": "d3d58a971cbc9f7652e41fea5490301976f2483add6caa48851cb29a2cc65cc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_mvebu.c",
  "human_readable_source": " \n\n#include <linux/ahci_platform.h>\n#include <linux/kernel.h>\n#include <linux/mbus.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include \"ahci.h\"\n\n#define DRV_NAME \"ahci-mvebu\"\n\n#define AHCI_VENDOR_SPECIFIC_0_ADDR  0xa0\n#define AHCI_VENDOR_SPECIFIC_0_DATA  0xa4\n\n#define AHCI_WINDOW_CTRL(win)\t(0x60 + ((win) << 4))\n#define AHCI_WINDOW_BASE(win)\t(0x64 + ((win) << 4))\n#define AHCI_WINDOW_SIZE(win)\t(0x68 + ((win) << 4))\n\nstruct ahci_mvebu_plat_data {\n\tint (*plat_config)(struct ahci_host_priv *hpriv);\n\tunsigned int flags;\n};\n\nstatic void ahci_mvebu_mbus_config(struct ahci_host_priv *hpriv,\n\t\t\t\t   const struct mbus_dram_target_info *dram)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\twritel(0, hpriv->mmio + AHCI_WINDOW_CTRL(i));\n\t\twritel(0, hpriv->mmio + AHCI_WINDOW_BASE(i));\n\t\twritel(0, hpriv->mmio + AHCI_WINDOW_SIZE(i));\n\t}\n\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\twritel((cs->mbus_attr << 8) |\n\t\t       (dram->mbus_dram_target_id << 4) | 1,\n\t\t       hpriv->mmio + AHCI_WINDOW_CTRL(i));\n\t\twritel(cs->base >> 16, hpriv->mmio + AHCI_WINDOW_BASE(i));\n\t\twritel(((cs->size - 1) & 0xffff0000),\n\t\t       hpriv->mmio + AHCI_WINDOW_SIZE(i));\n\t}\n}\n\nstatic void ahci_mvebu_regret_option(struct ahci_host_priv *hpriv)\n{\n\t \n\twritel(0x4, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_ADDR);\n\twritel(0x80, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_DATA);\n}\n\nstatic int ahci_mvebu_armada_380_config(struct ahci_host_priv *hpriv)\n{\n\tconst struct mbus_dram_target_info *dram;\n\tint rc = 0;\n\n\tdram = mv_mbus_dram_info();\n\tif (dram)\n\t\tahci_mvebu_mbus_config(hpriv, dram);\n\telse\n\t\trc = -ENODEV;\n\n\tahci_mvebu_regret_option(hpriv);\n\n\treturn rc;\n}\n\nstatic int ahci_mvebu_armada_3700_config(struct ahci_host_priv *hpriv)\n{\n\tu32 reg;\n\n\twritel(0, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_ADDR);\n\n\treg = readl(hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_DATA);\n\treg |= BIT(6);\n\twritel(reg, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_DATA);\n\n\treturn 0;\n}\n\n \nstatic int ahci_mvebu_stop_engine(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tu32 tmp, port_fbs;\n\n\ttmp = readl(port_mmio + PORT_CMD);\n\n\t \n\tif ((tmp & (PORT_CMD_START | PORT_CMD_LIST_ON)) == 0)\n\t\treturn 0;\n\n\t \n\tport_fbs = readl(port_mmio + PORT_FBS);\n\n\t \n\ttmp &= ~PORT_CMD_START;\n\twritel(tmp, port_mmio + PORT_CMD);\n\n\t \n\twritel(port_fbs, port_mmio + PORT_FBS);\n\n\t \n\ttmp = ata_wait_register(ap, port_mmio + PORT_CMD,\n\t\t\t\tPORT_CMD_LIST_ON, PORT_CMD_LIST_ON, 1, 500);\n\tif (tmp & PORT_CMD_LIST_ON)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ahci_mvebu_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\treturn ahci_platform_suspend_host(&pdev->dev);\n}\n\nstatic int ahci_mvebu_resume(struct platform_device *pdev)\n{\n\tstruct ata_host *host = platform_get_drvdata(pdev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tconst struct ahci_mvebu_plat_data *pdata = hpriv->plat_data;\n\n\tpdata->plat_config(hpriv);\n\n\treturn ahci_platform_resume_host(&pdev->dev);\n}\n#else\n#define ahci_mvebu_suspend NULL\n#define ahci_mvebu_resume NULL\n#endif\n\nstatic const struct ata_port_info ahci_mvebu_port_info = {\n\t.flags\t   = AHCI_FLAG_COMMON,\n\t.pio_mask  = ATA_PIO4,\n\t.udma_mask = ATA_UDMA6,\n\t.port_ops  = &ahci_platform_ops,\n};\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int ahci_mvebu_probe(struct platform_device *pdev)\n{\n\tconst struct ahci_mvebu_plat_data *pdata;\n\tstruct ahci_host_priv *hpriv;\n\tint rc;\n\n\tpdata = of_device_get_match_data(&pdev->dev);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\thpriv->flags |= pdata->flags;\n\thpriv->plat_data = (void *)pdata;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv->stop_engine = ahci_mvebu_stop_engine;\n\n\trc = pdata->plat_config(hpriv);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\trc = ahci_platform_init_host(pdev, hpriv, &ahci_mvebu_port_info,\n\t\t\t\t     &ahci_platform_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n\nstatic const struct ahci_mvebu_plat_data ahci_mvebu_armada_380_plat_data = {\n\t.plat_config = ahci_mvebu_armada_380_config,\n};\n\nstatic const struct ahci_mvebu_plat_data ahci_mvebu_armada_3700_plat_data = {\n\t.plat_config = ahci_mvebu_armada_3700_config,\n\t.flags = AHCI_HFLAG_SUSPEND_PHYS,\n};\n\nstatic const struct of_device_id ahci_mvebu_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,armada-380-ahci\",\n\t\t.data = &ahci_mvebu_armada_380_plat_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-3700-ahci\",\n\t\t.data = &ahci_mvebu_armada_3700_plat_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_mvebu_of_match);\n\nstatic struct platform_driver ahci_mvebu_driver = {\n\t.probe = ahci_mvebu_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.suspend = ahci_mvebu_suspend,\n\t.resume = ahci_mvebu_resume,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_mvebu_of_match,\n\t},\n};\nmodule_platform_driver(ahci_mvebu_driver);\n\nMODULE_DESCRIPTION(\"Marvell EBU AHCI SATA driver\");\nMODULE_AUTHOR(\"Thomas Petazzoni <thomas.petazzoni@free-electrons.com>, Marcin Wojtas <mw@semihalf.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ahci_mvebu\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}