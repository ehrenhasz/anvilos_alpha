{
  "module_name": "ahci_sunxi.c",
  "hash_id": "8b2ca21db8e5bd0e41e18b4203c88c1ef08001f0d11324101ee7e675be92fc57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_sunxi.c",
  "human_readable_source": "\n \n\n#include <linux/ahci_platform.h>\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include \"ahci.h\"\n\n#define DRV_NAME \"ahci-sunxi\"\n\n \nstatic bool enable_pmp;\nmodule_param(enable_pmp, bool, 0);\nMODULE_PARM_DESC(enable_pmp,\n\t\"Enable support for sata port multipliers, only use if you use a pmp!\");\n\n#define AHCI_BISTAFR\t0x00a0\n#define AHCI_BISTCR\t0x00a4\n#define AHCI_BISTFCTR\t0x00a8\n#define AHCI_BISTSR\t0x00ac\n#define AHCI_BISTDECR\t0x00b0\n#define AHCI_DIAGNR0\t0x00b4\n#define AHCI_DIAGNR1\t0x00b8\n#define AHCI_OOBR\t0x00bc\n#define AHCI_PHYCS0R\t0x00c0\n#define AHCI_PHYCS1R\t0x00c4\n#define AHCI_PHYCS2R\t0x00c8\n#define AHCI_TIMER1MS\t0x00e0\n#define AHCI_GPARAM1R\t0x00e8\n#define AHCI_GPARAM2R\t0x00ec\n#define AHCI_PPARAMR\t0x00f0\n#define AHCI_TESTR\t0x00f4\n#define AHCI_VERSIONR\t0x00f8\n#define AHCI_IDR\t0x00fc\n#define AHCI_RWCR\t0x00fc\n#define AHCI_P0DMACR\t0x0170\n#define AHCI_P0PHYCR\t0x0178\n#define AHCI_P0PHYSR\t0x017c\n\nstatic void sunxi_clrbits(void __iomem *reg, u32 clr_val)\n{\n\tu32 reg_val;\n\n\treg_val = readl(reg);\n\treg_val &= ~(clr_val);\n\twritel(reg_val, reg);\n}\n\nstatic void sunxi_setbits(void __iomem *reg, u32 set_val)\n{\n\tu32 reg_val;\n\n\treg_val = readl(reg);\n\treg_val |= set_val;\n\twritel(reg_val, reg);\n}\n\nstatic void sunxi_clrsetbits(void __iomem *reg, u32 clr_val, u32 set_val)\n{\n\tu32 reg_val;\n\n\treg_val = readl(reg);\n\treg_val &= ~(clr_val);\n\treg_val |= set_val;\n\twritel(reg_val, reg);\n}\n\nstatic u32 sunxi_getbits(void __iomem *reg, u8 mask, u8 shift)\n{\n\treturn (readl(reg) >> shift) & mask;\n}\n\nstatic int ahci_sunxi_phy_init(struct device *dev, void __iomem *reg_base)\n{\n\tu32 reg_val;\n\tint timeout;\n\n\t \n\twritel(0, reg_base + AHCI_RWCR);\n\tmsleep(5);\n\n\tsunxi_setbits(reg_base + AHCI_PHYCS1R, BIT(19));\n\tsunxi_clrsetbits(reg_base + AHCI_PHYCS0R,\n\t\t\t (0x7 << 24),\n\t\t\t (0x5 << 24) | BIT(23) | BIT(18));\n\tsunxi_clrsetbits(reg_base + AHCI_PHYCS1R,\n\t\t\t (0x3 << 16) | (0x1f << 8) | (0x3 << 6),\n\t\t\t (0x2 << 16) | (0x6 << 8) | (0x2 << 6));\n\tsunxi_setbits(reg_base + AHCI_PHYCS1R, BIT(28) | BIT(15));\n\tsunxi_clrbits(reg_base + AHCI_PHYCS1R, BIT(19));\n\tsunxi_clrsetbits(reg_base + AHCI_PHYCS0R,\n\t\t\t (0x7 << 20), (0x3 << 20));\n\tsunxi_clrsetbits(reg_base + AHCI_PHYCS2R,\n\t\t\t (0x1f << 5), (0x19 << 5));\n\tmsleep(5);\n\n\tsunxi_setbits(reg_base + AHCI_PHYCS0R, (0x1 << 19));\n\n\ttimeout = 250;  \n\tdo {\n\t\treg_val = sunxi_getbits(reg_base + AHCI_PHYCS0R, 0x7, 28);\n\t\tif (reg_val == 0x02)\n\t\t\tbreak;\n\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(dev, \"PHY power up failed.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(1);\n\t} while (1);\n\n\tsunxi_setbits(reg_base + AHCI_PHYCS2R, (0x1 << 24));\n\n\ttimeout = 100;  \n\tdo {\n\t\treg_val = sunxi_getbits(reg_base + AHCI_PHYCS2R, 0x1, 24);\n\t\tif (reg_val == 0x00)\n\t\t\tbreak;\n\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(dev, \"PHY calibration failed.\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tudelay(1);\n\t} while (1);\n\n\tmsleep(15);\n\n\twritel(0x7, reg_base + AHCI_RWCR);\n\n\treturn 0;\n}\n\nstatic void ahci_sunxi_start_engine(struct ata_port *ap)\n{\n\tvoid __iomem *port_mmio = ahci_port_base(ap);\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\n\t \n\tsunxi_clrsetbits(hpriv->mmio + AHCI_P0DMACR, 0x0000ffff, 0x00004433);\n\n\t \n\tsunxi_setbits(port_mmio + PORT_CMD, PORT_CMD_START);\n}\n\nstatic const struct ata_port_info ahci_sunxi_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON | ATA_FLAG_NCQ | ATA_FLAG_NO_DIPM,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_platform_ops,\n};\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int ahci_sunxi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tint rc;\n\n\thpriv = ahci_platform_get_resources(pdev, AHCI_PLATFORM_GET_RESETS);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\thpriv->start_engine = ahci_sunxi_start_engine;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_sunxi_phy_init(dev, hpriv->mmio);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\thpriv->flags = AHCI_HFLAG_32BIT_ONLY | AHCI_HFLAG_NO_MSI |\n\t\t       AHCI_HFLAG_YES_NCQ;\n\n\t \n\tif (!enable_pmp)\n\t\thpriv->flags |= AHCI_HFLAG_NO_PMP;\n\n\trc = ahci_platform_init_host(pdev, hpriv, &ahci_sunxi_port_info,\n\t\t\t\t     &ahci_platform_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ahci_sunxi_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_sunxi_phy_init(dev, hpriv->mmio);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\trc = ahci_platform_resume_host(dev);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn rc;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ahci_sunxi_pm_ops, ahci_platform_suspend,\n\t\t\t ahci_sunxi_resume);\n\nstatic const struct of_device_id ahci_sunxi_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-ahci\", },\n\t{ .compatible = \"allwinner,sun8i-r40-ahci\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_sunxi_of_match);\n\nstatic struct platform_driver ahci_sunxi_driver = {\n\t.probe = ahci_sunxi_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_sunxi_of_match,\n\t\t.pm = &ahci_sunxi_pm_ops,\n\t},\n};\nmodule_platform_driver(ahci_sunxi_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sunxi AHCI SATA driver\");\nMODULE_AUTHOR(\"Olliver Schinagl <oliver@schinagl.nl>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}