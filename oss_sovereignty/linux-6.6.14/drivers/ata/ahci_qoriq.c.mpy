{
  "module_name": "ahci_qoriq.c",
  "hash_id": "728a2d6f35e1faf86d785488e3295d05124555e110b65afc652d7561bba629ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_qoriq.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/ahci_platform.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/libata.h>\n#include \"ahci.h\"\n\n#define DRV_NAME \"ahci-qoriq\"\n\n \n#define PORT_PHY1\t0xA8\n#define PORT_PHY2\t0xAC\n#define PORT_PHY3\t0xB0\n#define PORT_PHY4\t0xB4\n#define PORT_PHY5\t0xB8\n#define PORT_AXICC\t0xBC\n#define PORT_TRANS\t0xC8\n\n \n#define AHCI_PORT_PHY_1_CFG\t0xa003fffe\n#define AHCI_PORT_PHY2_CFG\t0x28184d1f\n#define AHCI_PORT_PHY3_CFG\t0x0e081509\n#define AHCI_PORT_TRANS_CFG\t0x08000029\n#define AHCI_PORT_AXICC_CFG\t0x3fffffff\n\n \n#define LS1021A_PORT_PHY2\t0x28183414\n#define LS1021A_PORT_PHY3\t0x0e080e06\n#define LS1021A_PORT_PHY4\t0x064a080b\n#define LS1021A_PORT_PHY5\t0x2aa86470\n#define LS1021A_AXICC_ADDR\t0xC0\n\n#define SATA_ECC_DISABLE\t0x00020000\n#define ECC_DIS_ARMV8_CH2\t0x80000000\n#define ECC_DIS_LS1088A\t\t0x40000000\n\nenum ahci_qoriq_type {\n\tAHCI_LS1021A,\n\tAHCI_LS1028A,\n\tAHCI_LS1043A,\n\tAHCI_LS2080A,\n\tAHCI_LS1046A,\n\tAHCI_LS1088A,\n\tAHCI_LS2088A,\n\tAHCI_LX2160A,\n};\n\nstruct ahci_qoriq_priv {\n\tstruct ccsr_ahci *reg_base;\n\tenum ahci_qoriq_type type;\n\tvoid __iomem *ecc_addr;\n\tbool is_dmacoherent;\n};\n\nstatic bool ecc_initialized;\n\nstatic const struct of_device_id ahci_qoriq_of_match[] = {\n\t{ .compatible = \"fsl,ls1021a-ahci\", .data = (void *)AHCI_LS1021A},\n\t{ .compatible = \"fsl,ls1028a-ahci\", .data = (void *)AHCI_LS1028A},\n\t{ .compatible = \"fsl,ls1043a-ahci\", .data = (void *)AHCI_LS1043A},\n\t{ .compatible = \"fsl,ls2080a-ahci\", .data = (void *)AHCI_LS2080A},\n\t{ .compatible = \"fsl,ls1046a-ahci\", .data = (void *)AHCI_LS1046A},\n\t{ .compatible = \"fsl,ls1088a-ahci\", .data = (void *)AHCI_LS1088A},\n\t{ .compatible = \"fsl,ls2088a-ahci\", .data = (void *)AHCI_LS2088A},\n\t{ .compatible = \"fsl,lx2160a-ahci\", .data = (void *)AHCI_LX2160A},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_qoriq_of_match);\n\nstatic const struct acpi_device_id ahci_qoriq_acpi_match[] = {\n\t{\"NXP0004\", .driver_data = (kernel_ulong_t)AHCI_LX2160A},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ahci_qoriq_acpi_match);\n\nstatic int ahci_qoriq_hardreset(struct ata_link *link, unsigned int *class,\n\t\t\t  unsigned long deadline)\n{\n\tconst unsigned int *timing = sata_ehc_deb_timing(&link->eh_context);\n\tvoid __iomem *port_mmio = ahci_port_base(link->ap);\n\tu32 px_cmd, px_is, px_val;\n\tstruct ata_port *ap = link->ap;\n\tstruct ahci_port_priv *pp = ap->private_data;\n\tstruct ahci_host_priv *hpriv = ap->host->private_data;\n\tstruct ahci_qoriq_priv *qoriq_priv = hpriv->plat_data;\n\tu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\n\tstruct ata_taskfile tf;\n\tbool online;\n\tint rc;\n\tbool ls1021a_workaround = (qoriq_priv->type == AHCI_LS1021A);\n\n\thpriv->stop_engine(ap);\n\n\t \n\tif (ls1021a_workaround) {\n\t\tpx_cmd = readl(port_mmio + PORT_CMD);\n\t\tpx_is = readl(port_mmio + PORT_IRQ_STAT);\n\t}\n\n\t \n\tata_tf_init(link->device, &tf);\n\ttf.status = ATA_BUSY;\n\tata_tf_to_fis(&tf, 0, 0, d2h_fis);\n\n\trc = sata_link_hardreset(link, timing, deadline, &online,\n\t\t\t\t ahci_check_ready);\n\n\t \n\tif (ls1021a_workaround) {\n\t\tpx_val = readl(port_mmio + PORT_CMD);\n\t\tif (px_val != px_cmd)\n\t\t\twritel(px_cmd, port_mmio + PORT_CMD);\n\n\t\tpx_val = readl(port_mmio + PORT_IRQ_STAT);\n\t\tif (px_val != px_is)\n\t\t\twritel(px_is, port_mmio + PORT_IRQ_STAT);\n\t}\n\n\thpriv->start_engine(ap);\n\n\tif (online)\n\t\t*class = ahci_dev_classify(ap);\n\treturn rc;\n}\n\nstatic struct ata_port_operations ahci_qoriq_ops = {\n\t.inherits\t= &ahci_ops,\n\t.hardreset\t= ahci_qoriq_hardreset,\n};\n\nstatic const struct ata_port_info ahci_qoriq_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON | ATA_FLAG_NCQ,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_qoriq_ops,\n};\n\nstatic const struct scsi_host_template ahci_qoriq_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int ahci_qoriq_phy_init(struct ahci_host_priv *hpriv)\n{\n\tstruct ahci_qoriq_priv *qpriv = hpriv->plat_data;\n\tvoid __iomem *reg_base = hpriv->mmio;\n\n\tswitch (qpriv->type) {\n\tcase AHCI_LS1021A:\n\t\tif (!(qpriv->ecc_addr || ecc_initialized))\n\t\t\treturn -EINVAL;\n\t\telse if (qpriv->ecc_addr && !ecc_initialized)\n\t\t\twritel(SATA_ECC_DISABLE, qpriv->ecc_addr);\n\t\twritel(AHCI_PORT_PHY_1_CFG, reg_base + PORT_PHY1);\n\t\twritel(LS1021A_PORT_PHY2, reg_base + PORT_PHY2);\n\t\twritel(LS1021A_PORT_PHY3, reg_base + PORT_PHY3);\n\t\twritel(LS1021A_PORT_PHY4, reg_base + PORT_PHY4);\n\t\twritel(LS1021A_PORT_PHY5, reg_base + PORT_PHY5);\n\t\twritel(AHCI_PORT_TRANS_CFG, reg_base + PORT_TRANS);\n\t\tif (qpriv->is_dmacoherent)\n\t\t\twritel(AHCI_PORT_AXICC_CFG,\n\t\t\t\t\treg_base + LS1021A_AXICC_ADDR);\n\t\tbreak;\n\n\tcase AHCI_LS1043A:\n\t\tif (!(qpriv->ecc_addr || ecc_initialized))\n\t\t\treturn -EINVAL;\n\t\telse if (qpriv->ecc_addr && !ecc_initialized)\n\t\t\twritel(readl(qpriv->ecc_addr) |\n\t\t\t       ECC_DIS_ARMV8_CH2,\n\t\t\t       qpriv->ecc_addr);\n\t\twritel(AHCI_PORT_PHY_1_CFG, reg_base + PORT_PHY1);\n\t\twritel(AHCI_PORT_PHY2_CFG, reg_base + PORT_PHY2);\n\t\twritel(AHCI_PORT_PHY3_CFG, reg_base + PORT_PHY3);\n\t\twritel(AHCI_PORT_TRANS_CFG, reg_base + PORT_TRANS);\n\t\tif (qpriv->is_dmacoherent)\n\t\t\twritel(AHCI_PORT_AXICC_CFG, reg_base + PORT_AXICC);\n\t\tbreak;\n\n\tcase AHCI_LS2080A:\n\t\twritel(AHCI_PORT_PHY_1_CFG, reg_base + PORT_PHY1);\n\t\twritel(AHCI_PORT_PHY2_CFG, reg_base + PORT_PHY2);\n\t\twritel(AHCI_PORT_PHY3_CFG, reg_base + PORT_PHY3);\n\t\twritel(AHCI_PORT_TRANS_CFG, reg_base + PORT_TRANS);\n\t\tif (qpriv->is_dmacoherent)\n\t\t\twritel(AHCI_PORT_AXICC_CFG, reg_base + PORT_AXICC);\n\t\tbreak;\n\n\tcase AHCI_LS1046A:\n\t\tif (!(qpriv->ecc_addr || ecc_initialized))\n\t\t\treturn -EINVAL;\n\t\telse if (qpriv->ecc_addr && !ecc_initialized)\n\t\t\twritel(readl(qpriv->ecc_addr) |\n\t\t\t       ECC_DIS_ARMV8_CH2,\n\t\t\t       qpriv->ecc_addr);\n\t\twritel(AHCI_PORT_PHY_1_CFG, reg_base + PORT_PHY1);\n\t\twritel(AHCI_PORT_PHY2_CFG, reg_base + PORT_PHY2);\n\t\twritel(AHCI_PORT_PHY3_CFG, reg_base + PORT_PHY3);\n\t\twritel(AHCI_PORT_TRANS_CFG, reg_base + PORT_TRANS);\n\t\tif (qpriv->is_dmacoherent)\n\t\t\twritel(AHCI_PORT_AXICC_CFG, reg_base + PORT_AXICC);\n\t\tbreak;\n\n\tcase AHCI_LS1028A:\n\tcase AHCI_LS1088A:\n\tcase AHCI_LX2160A:\n\t\tif (!(qpriv->ecc_addr || ecc_initialized))\n\t\t\treturn -EINVAL;\n\t\telse if (qpriv->ecc_addr && !ecc_initialized)\n\t\t\twritel(readl(qpriv->ecc_addr) |\n\t\t\t       ECC_DIS_LS1088A,\n\t\t\t       qpriv->ecc_addr);\n\t\twritel(AHCI_PORT_PHY_1_CFG, reg_base + PORT_PHY1);\n\t\twritel(AHCI_PORT_PHY2_CFG, reg_base + PORT_PHY2);\n\t\twritel(AHCI_PORT_PHY3_CFG, reg_base + PORT_PHY3);\n\t\twritel(AHCI_PORT_TRANS_CFG, reg_base + PORT_TRANS);\n\t\tif (qpriv->is_dmacoherent)\n\t\t\twritel(AHCI_PORT_AXICC_CFG, reg_base + PORT_AXICC);\n\t\tbreak;\n\n\tcase AHCI_LS2088A:\n\t\twritel(AHCI_PORT_PHY_1_CFG, reg_base + PORT_PHY1);\n\t\twritel(AHCI_PORT_PHY2_CFG, reg_base + PORT_PHY2);\n\t\twritel(AHCI_PORT_PHY3_CFG, reg_base + PORT_PHY3);\n\t\twritel(AHCI_PORT_TRANS_CFG, reg_base + PORT_TRANS);\n\t\tif (qpriv->is_dmacoherent)\n\t\t\twritel(AHCI_PORT_AXICC_CFG, reg_base + PORT_AXICC);\n\t\tbreak;\n\t}\n\n\tecc_initialized = true;\n\treturn 0;\n}\n\nstatic int ahci_qoriq_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct acpi_device_id *acpi_id;\n\tstruct device *dev = &pdev->dev;\n\tstruct ahci_host_priv *hpriv;\n\tstruct ahci_qoriq_priv *qoriq_priv;\n\tconst struct of_device_id *of_id;\n\tstruct resource *res;\n\tint rc;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\tof_id = of_match_node(ahci_qoriq_of_match, np);\n\tacpi_id = acpi_match_device(ahci_qoriq_acpi_match, &pdev->dev);\n\tif (!(of_id || acpi_id))\n\t\treturn -ENODEV;\n\n\tqoriq_priv = devm_kzalloc(dev, sizeof(*qoriq_priv), GFP_KERNEL);\n\tif (!qoriq_priv)\n\t\treturn -ENOMEM;\n\n\tif (of_id)\n\t\tqoriq_priv->type = (unsigned long)of_id->data;\n\telse\n\t\tqoriq_priv->type = (enum ahci_qoriq_type)acpi_id->driver_data;\n\n\tif (unlikely(!ecc_initialized)) {\n\t\tres = platform_get_resource_byname(pdev,\n\t\t\t\t\t\t   IORESOURCE_MEM,\n\t\t\t\t\t\t   \"sata-ecc\");\n\t\tif (res) {\n\t\t\tqoriq_priv->ecc_addr =\n\t\t\t\tdevm_ioremap_resource(dev, res);\n\t\t\tif (IS_ERR(qoriq_priv->ecc_addr))\n\t\t\t\treturn PTR_ERR(qoriq_priv->ecc_addr);\n\t\t}\n\t}\n\n\tif (device_get_dma_attr(&pdev->dev) == DEV_DMA_COHERENT)\n\t\tqoriq_priv->is_dmacoherent = true;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\thpriv->plat_data = qoriq_priv;\n\trc = ahci_qoriq_phy_init(hpriv);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\trc = ahci_platform_init_host(pdev, hpriv, &ahci_qoriq_port_info,\n\t\t\t\t     &ahci_qoriq_sht);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\n\treturn rc;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ahci_qoriq_resume(struct device *dev)\n{\n\tstruct ata_host *host = dev_get_drvdata(dev);\n\tstruct ahci_host_priv *hpriv = host->private_data;\n\tint rc;\n\n\trc = ahci_platform_enable_resources(hpriv);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ahci_qoriq_phy_init(hpriv);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\trc = ahci_platform_resume_host(dev);\n\tif (rc)\n\t\tgoto disable_resources;\n\n\t \n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\n\treturn rc;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ahci_qoriq_pm_ops, ahci_platform_suspend,\n\t\t\t ahci_qoriq_resume);\n\nstatic struct platform_driver ahci_qoriq_driver = {\n\t.probe = ahci_qoriq_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_qoriq_of_match,\n\t\t.acpi_match_table = ahci_qoriq_acpi_match,\n\t\t.pm = &ahci_qoriq_pm_ops,\n\t},\n};\nmodule_platform_driver(ahci_qoriq_driver);\n\nMODULE_DESCRIPTION(\"Freescale QorIQ AHCI SATA platform driver\");\nMODULE_AUTHOR(\"Tang Yuantian <Yuantian.Tang@freescale.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}