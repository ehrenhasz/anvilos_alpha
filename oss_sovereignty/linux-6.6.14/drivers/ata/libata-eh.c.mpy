{
  "module_name": "libata-eh.c",
  "hash_id": "513165d8a9a24b192546d06ca71e688a2487a706d9382621e058cc4384253a63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-eh.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include \"../scsi/scsi_transport_api.h\"\n\n#include <linux/libata.h>\n\n#include <trace/events/libata.h>\n#include \"libata.h\"\n\nenum {\n\t \n\tATA_EH_SPDN_NCQ_OFF\t\t= (1 << 0),\n\tATA_EH_SPDN_SPEED_DOWN\t\t= (1 << 1),\n\tATA_EH_SPDN_FALLBACK_TO_PIO\t= (1 << 2),\n\tATA_EH_SPDN_KEEP_ERRORS\t\t= (1 << 3),\n\n\t \n\tATA_EFLAG_IS_IO\t\t\t= (1 << 0),\n\tATA_EFLAG_DUBIOUS_XFER\t\t= (1 << 1),\n\tATA_EFLAG_OLD_ER                = (1 << 31),\n\n\t \n\tATA_ECAT_NONE\t\t\t= 0,\n\tATA_ECAT_ATA_BUS\t\t= 1,\n\tATA_ECAT_TOUT_HSM\t\t= 2,\n\tATA_ECAT_UNK_DEV\t\t= 3,\n\tATA_ECAT_DUBIOUS_NONE\t\t= 4,\n\tATA_ECAT_DUBIOUS_ATA_BUS\t= 5,\n\tATA_ECAT_DUBIOUS_TOUT_HSM\t= 6,\n\tATA_ECAT_DUBIOUS_UNK_DEV\t= 7,\n\tATA_ECAT_NR\t\t\t= 8,\n\n\tATA_EH_CMD_DFL_TIMEOUT\t\t=  5000,\n\n\t \n\tATA_EH_RESET_COOL_DOWN\t\t=  5000,\n\n\t \n\tATA_EH_PRERESET_TIMEOUT\t\t= 10000,\n\tATA_EH_FASTDRAIN_INTERVAL\t=  3000,\n\n\tATA_EH_UA_TRIES\t\t\t= 5,\n\n\t \n\tATA_EH_PROBE_TRIAL_INTERVAL\t= 60000,\t \n\tATA_EH_PROBE_TRIALS\t\t= 2,\n};\n\n \nstatic const unsigned int ata_eh_reset_timeouts[] = {\n\t10000,\t \n\t10000,\t \n\t35000,\t \n\t 5000,\t \n\tUINT_MAX,  \n};\n\nstatic const unsigned int ata_eh_identify_timeouts[] = {\n\t 5000,\t \n\t10000,   \n\t30000,\t \n\tUINT_MAX,\n};\n\nstatic const unsigned int ata_eh_revalidate_timeouts[] = {\n\t15000,\t \n\t15000,   \n\tUINT_MAX,\n};\n\nstatic const unsigned int ata_eh_flush_timeouts[] = {\n\t15000,\t \n\t15000,   \n\t30000,\t \n\tUINT_MAX,\n};\n\nstatic const unsigned int ata_eh_other_timeouts[] = {\n\t 5000,\t \n\t10000,\t \n\t \n\tUINT_MAX,\n};\n\nstruct ata_eh_cmd_timeout_ent {\n\tconst u8\t\t*commands;\n\tconst unsigned int\t*timeouts;\n};\n\n \n#define CMDS(cmds...)\t(const u8 []){ cmds, 0 }\nstatic const struct ata_eh_cmd_timeout_ent\nata_eh_cmd_timeout_table[ATA_EH_CMD_TIMEOUT_TABLE_SIZE] = {\n\t{ .commands = CMDS(ATA_CMD_ID_ATA, ATA_CMD_ID_ATAPI),\n\t  .timeouts = ata_eh_identify_timeouts, },\n\t{ .commands = CMDS(ATA_CMD_READ_LOG_EXT, ATA_CMD_READ_LOG_DMA_EXT),\n\t  .timeouts = ata_eh_revalidate_timeouts, },\n\t{ .commands = CMDS(ATA_CMD_READ_NATIVE_MAX, ATA_CMD_READ_NATIVE_MAX_EXT),\n\t  .timeouts = ata_eh_other_timeouts, },\n\t{ .commands = CMDS(ATA_CMD_SET_MAX, ATA_CMD_SET_MAX_EXT),\n\t  .timeouts = ata_eh_other_timeouts, },\n\t{ .commands = CMDS(ATA_CMD_SET_FEATURES),\n\t  .timeouts = ata_eh_other_timeouts, },\n\t{ .commands = CMDS(ATA_CMD_INIT_DEV_PARAMS),\n\t  .timeouts = ata_eh_other_timeouts, },\n\t{ .commands = CMDS(ATA_CMD_FLUSH, ATA_CMD_FLUSH_EXT),\n\t  .timeouts = ata_eh_flush_timeouts },\n\t{ .commands = CMDS(ATA_CMD_VERIFY),\n\t  .timeouts = ata_eh_reset_timeouts },\n};\n#undef CMDS\n\nstatic void __ata_port_freeze(struct ata_port *ap);\nstatic int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\t  struct ata_device **r_failed_dev);\n#ifdef CONFIG_PM\nstatic void ata_eh_handle_port_suspend(struct ata_port *ap);\nstatic void ata_eh_handle_port_resume(struct ata_port *ap);\n#else  \nstatic void ata_eh_handle_port_suspend(struct ata_port *ap)\n{ }\n\nstatic void ata_eh_handle_port_resume(struct ata_port *ap)\n{ }\n#endif  \n\nstatic __printf(2, 0) void __ata_ehi_pushv_desc(struct ata_eh_info *ehi,\n\t\t\t\t const char *fmt, va_list args)\n{\n\tehi->desc_len += vscnprintf(ehi->desc + ehi->desc_len,\n\t\t\t\t     ATA_EH_DESC_LEN - ehi->desc_len,\n\t\t\t\t     fmt, args);\n}\n\n \nvoid __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\t__ata_ehi_pushv_desc(ehi, fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(__ata_ehi_push_desc);\n\n \nvoid ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (ehi->desc_len)\n\t\t__ata_ehi_push_desc(ehi, \", \");\n\n\tva_start(args, fmt);\n\t__ata_ehi_pushv_desc(ehi, fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(ata_ehi_push_desc);\n\n \nvoid ata_ehi_clear_desc(struct ata_eh_info *ehi)\n{\n\tehi->desc[0] = '\\0';\n\tehi->desc_len = 0;\n}\nEXPORT_SYMBOL_GPL(ata_ehi_clear_desc);\n\n \nvoid ata_port_desc(struct ata_port *ap, const char *fmt, ...)\n{\n\tva_list args;\n\n\tWARN_ON(!(ap->pflags & ATA_PFLAG_INITIALIZING));\n\n\tif (ap->link.eh_info.desc_len)\n\t\t__ata_ehi_push_desc(&ap->link.eh_info, \" \");\n\n\tva_start(args, fmt);\n\t__ata_ehi_pushv_desc(&ap->link.eh_info, fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(ata_port_desc);\n\n#ifdef CONFIG_PCI\n \nvoid ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,\n\t\t\tconst char *name)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\n\tchar *type = \"\";\n\tunsigned long long start, len;\n\n\tif (pci_resource_flags(pdev, bar) & IORESOURCE_MEM)\n\t\ttype = \"m\";\n\telse if (pci_resource_flags(pdev, bar) & IORESOURCE_IO)\n\t\ttype = \"i\";\n\n\tstart = (unsigned long long)pci_resource_start(pdev, bar);\n\tlen = (unsigned long long)pci_resource_len(pdev, bar);\n\n\tif (offset < 0)\n\t\tata_port_desc(ap, \"%s %s%llu@0x%llx\", name, type, len, start);\n\telse\n\t\tata_port_desc(ap, \"%s 0x%llx\", name,\n\t\t\t\tstart + (unsigned long long)offset);\n}\nEXPORT_SYMBOL_GPL(ata_port_pbar_desc);\n#endif  \n\nstatic int ata_lookup_timeout_table(u8 cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < ATA_EH_CMD_TIMEOUT_TABLE_SIZE; i++) {\n\t\tconst u8 *cur;\n\n\t\tfor (cur = ata_eh_cmd_timeout_table[i].commands; *cur; cur++)\n\t\t\tif (*cur == cmd)\n\t\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n \nunsigned int ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\tint ent = ata_lookup_timeout_table(cmd);\n\tint idx;\n\n\tif (ent < 0)\n\t\treturn ATA_EH_CMD_DFL_TIMEOUT;\n\n\tidx = ehc->cmd_timeout_idx[dev->devno][ent];\n\treturn ata_eh_cmd_timeout_table[ent].timeouts[idx];\n}\n\n \nvoid ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\tint ent = ata_lookup_timeout_table(cmd);\n\tint idx;\n\n\tif (ent < 0)\n\t\treturn;\n\n\tidx = ehc->cmd_timeout_idx[dev->devno][ent];\n\tif (ata_eh_cmd_timeout_table[ent].timeouts[idx + 1] != UINT_MAX)\n\t\tehc->cmd_timeout_idx[dev->devno][ent]++;\n}\n\nstatic void ata_ering_record(struct ata_ering *ering, unsigned int eflags,\n\t\t\t     unsigned int err_mask)\n{\n\tstruct ata_ering_entry *ent;\n\n\tWARN_ON(!err_mask);\n\n\tering->cursor++;\n\tering->cursor %= ATA_ERING_SIZE;\n\n\tent = &ering->ring[ering->cursor];\n\tent->eflags = eflags;\n\tent->err_mask = err_mask;\n\tent->timestamp = get_jiffies_64();\n}\n\nstatic struct ata_ering_entry *ata_ering_top(struct ata_ering *ering)\n{\n\tstruct ata_ering_entry *ent = &ering->ring[ering->cursor];\n\n\tif (ent->err_mask)\n\t\treturn ent;\n\treturn NULL;\n}\n\nint ata_ering_map(struct ata_ering *ering,\n\t\t  int (*map_fn)(struct ata_ering_entry *, void *),\n\t\t  void *arg)\n{\n\tint idx, rc = 0;\n\tstruct ata_ering_entry *ent;\n\n\tidx = ering->cursor;\n\tdo {\n\t\tent = &ering->ring[idx];\n\t\tif (!ent->err_mask)\n\t\t\tbreak;\n\t\trc = map_fn(ent, arg);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tidx = (idx - 1 + ATA_ERING_SIZE) % ATA_ERING_SIZE;\n\t} while (idx != ering->cursor);\n\n\treturn rc;\n}\n\nstatic int ata_ering_clear_cb(struct ata_ering_entry *ent, void *void_arg)\n{\n\tent->eflags |= ATA_EFLAG_OLD_ER;\n\treturn 0;\n}\n\nstatic void ata_ering_clear(struct ata_ering *ering)\n{\n\tata_ering_map(ering, ata_ering_clear_cb, NULL);\n}\n\nstatic unsigned int ata_eh_dev_action(struct ata_device *dev)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\n\treturn ehc->i.action | ehc->i.dev_action[dev->devno];\n}\n\nstatic void ata_eh_clear_action(struct ata_link *link, struct ata_device *dev,\n\t\t\t\tstruct ata_eh_info *ehi, unsigned int action)\n{\n\tstruct ata_device *tdev;\n\n\tif (!dev) {\n\t\tehi->action &= ~action;\n\t\tata_for_each_dev(tdev, link, ALL)\n\t\t\tehi->dev_action[tdev->devno] &= ~action;\n\t} else {\n\t\t \n\t\tWARN_ON(!(action & ATA_EH_PERDEV_MASK));\n\n\t\t \n\t\tif (ehi->action & action) {\n\t\t\tata_for_each_dev(tdev, link, ALL)\n\t\t\t\tehi->dev_action[tdev->devno] |=\n\t\t\t\t\tehi->action & action;\n\t\t\tehi->action &= ~action;\n\t\t}\n\n\t\t \n\t\tehi->dev_action[dev->devno] &= ~action;\n\t}\n}\n\n \nvoid ata_eh_acquire(struct ata_port *ap)\n{\n\tmutex_lock(&ap->host->eh_mutex);\n\tWARN_ON_ONCE(ap->host->eh_owner);\n\tap->host->eh_owner = current;\n}\n\n \nvoid ata_eh_release(struct ata_port *ap)\n{\n\tWARN_ON_ONCE(ap->host->eh_owner != current);\n\tap->host->eh_owner = NULL;\n\tmutex_unlock(&ap->host->eh_mutex);\n}\n\nstatic void ata_eh_unload(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\n\t \n\tif (system_state != SYSTEM_RESTART) {\n\t\tata_for_each_link(link, ap, PMP_FIRST) {\n\t\t\tata_for_each_dev(dev, link, ENABLED)\n\t\t\t\tata_dev_power_set_standby(dev);\n\t\t}\n\t}\n\n\t \n\tata_for_each_link(link, ap, PMP_FIRST) {\n\t\tsata_scr_write(link, SCR_CONTROL, link->saved_scontrol & 0xff0);\n\t\tata_for_each_dev(dev, link, ALL)\n\t\t\tata_dev_disable(dev);\n\t}\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\tata_port_freeze(ap);\t\t\t \n\tap->pflags &= ~ATA_PFLAG_EH_PENDING;\t \n\tap->pflags |= ATA_PFLAG_UNLOADED;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n\n \nvoid ata_scsi_error(struct Scsi_Host *host)\n{\n\tstruct ata_port *ap = ata_shost_to_port(host);\n\tunsigned long flags;\n\tLIST_HEAD(eh_work_q);\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\tlist_splice_init(&host->eh_cmd_q, &eh_work_q);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\tata_scsi_cmd_error_handler(host, ap, &eh_work_q);\n\n\t \n\tata_scsi_port_error_handler(host, ap);\n\n\t \n\tWARN_ON(!list_empty(&eh_work_q));\n\n}\n\n \nvoid ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap,\n\t\t\t\tstruct list_head *eh_work_q)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct scsi_cmnd *scmd, *tmp;\n\tint nr_timedout = 0;\n\n\t \n\tata_sff_flush_pio_task(ap);\n\n\t \n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tif (ap->ops->lost_interrupt)\n\t\tap->ops->lost_interrupt(ap);\n\n\tlist_for_each_entry_safe(scmd, tmp, eh_work_q, eh_entry) {\n\t\tstruct ata_queued_cmd *qc;\n\n\t\tata_qc_for_each_raw(ap, qc, i) {\n\t\t\tif (qc->flags & ATA_QCFLAG_ACTIVE &&\n\t\t\t    qc->scsicmd == scmd)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i < ATA_MAX_QUEUE) {\n\t\t\t \n\t\t\tif (!(qc->flags & ATA_QCFLAG_EH)) {\n\t\t\t\t \n\t\t\t\tqc->err_mask |= AC_ERR_TIMEOUT;\n\t\t\t\tqc->flags |= ATA_QCFLAG_EH;\n\t\t\t\tnr_timedout++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tscmd->retries = scmd->allowed;\n\t\t\tscsi_eh_finish_cmd(scmd, &ap->eh_done_q);\n\t\t}\n\t}\n\n\t \n\tif (nr_timedout)\n\t\t__ata_port_freeze(ap);\n\n\t \n\tap->eh_tries = ATA_EH_MAX_TRIES;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL(ata_scsi_cmd_error_handler);\n\n \nvoid ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap)\n{\n\tunsigned long flags;\n\tstruct ata_link *link;\n\n\t \n\tata_eh_acquire(ap);\n repeat:\n\t \n\tdel_timer_sync(&ap->fastdrain_timer);\n\n\t \n\tata_eh_handle_port_resume(ap);\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\tata_for_each_link(link, ap, HOST_FIRST) {\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\t\tstruct ata_device *dev;\n\n\t\tmemset(&link->eh_context, 0, sizeof(link->eh_context));\n\t\tlink->eh_context.i = link->eh_info;\n\t\tmemset(&link->eh_info, 0, sizeof(link->eh_info));\n\n\t\tata_for_each_dev(dev, link, ENABLED) {\n\t\t\tint devno = dev->devno;\n\n\t\t\tehc->saved_xfer_mode[devno] = dev->xfer_mode;\n\t\t\tif (ata_ncq_enabled(dev))\n\t\t\t\tehc->saved_ncq_enabled |= 1 << devno;\n\n\t\t\t \n\t\t\tif (ap->pflags & ATA_PFLAG_RESUMING)\n\t\t\t\tehc->i.dev_action[devno] |= ATA_EH_SET_ACTIVE;\n\t\t}\n\t}\n\n\tap->pflags |= ATA_PFLAG_EH_IN_PROGRESS;\n\tap->pflags &= ~ATA_PFLAG_EH_PENDING;\n\tap->excl_link = NULL;\t \n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t \n\tif (!(ap->pflags & (ATA_PFLAG_UNLOADING | ATA_PFLAG_SUSPENDED)))\n\t\tap->ops->error_handler(ap);\n\telse {\n\t\t \n\t\tif ((ap->pflags & ATA_PFLAG_UNLOADING) &&\n\t\t    !(ap->pflags & ATA_PFLAG_UNLOADED))\n\t\t\tata_eh_unload(ap);\n\t\tata_eh_finish(ap);\n\t}\n\n\t \n\tata_eh_handle_port_suspend(ap);\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\tif (ap->pflags & ATA_PFLAG_EH_PENDING) {\n\t\tif (--ap->eh_tries) {\n\t\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\t\tgoto repeat;\n\t\t}\n\t\tata_port_err(ap,\n\t\t\t     \"EH pending after %d tries, giving up\\n\",\n\t\t\t     ATA_EH_MAX_TRIES);\n\t\tap->pflags &= ~ATA_PFLAG_EH_PENDING;\n\t}\n\n\t \n\tata_for_each_link(link, ap, HOST_FIRST)\n\t\tmemset(&link->eh_info, 0, sizeof(link->eh_info));\n\n\t \n\tap->ops->end_eh(ap);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tata_eh_release(ap);\n\n\tscsi_eh_flush_done_q(&ap->eh_done_q);\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\tap->pflags &= ~ATA_PFLAG_RESUMING;\n\n\tif (ap->pflags & ATA_PFLAG_LOADING)\n\t\tap->pflags &= ~ATA_PFLAG_LOADING;\n\telse if ((ap->pflags & ATA_PFLAG_SCSI_HOTPLUG) &&\n\t\t!(ap->flags & ATA_FLAG_SAS_HOST))\n\t\tschedule_delayed_work(&ap->hotplug_task, 0);\n\n\tif (ap->pflags & ATA_PFLAG_RECOVERED)\n\t\tata_port_info(ap, \"EH complete\\n\");\n\n\tap->pflags &= ~(ATA_PFLAG_SCSI_HOTPLUG | ATA_PFLAG_RECOVERED);\n\n\t \n\tap->pflags &= ~ATA_PFLAG_EH_IN_PROGRESS;\n\twake_up_all(&ap->eh_wait_q);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ata_scsi_port_error_handler);\n\n \nvoid ata_port_wait_eh(struct ata_port *ap)\n{\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\n retry:\n\tspin_lock_irqsave(ap->lock, flags);\n\n\twhile (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS)) {\n\t\tprepare_to_wait(&ap->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t}\n\tfinish_wait(&ap->eh_wait_q, &wait);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t \n\tif (scsi_host_in_recovery(ap->scsi_host)) {\n\t\tata_msleep(ap, 10);\n\t\tgoto retry;\n\t}\n}\nEXPORT_SYMBOL_GPL(ata_port_wait_eh);\n\nstatic unsigned int ata_eh_nr_in_flight(struct ata_port *ap)\n{\n\tstruct ata_queued_cmd *qc;\n\tunsigned int tag;\n\tunsigned int nr = 0;\n\n\t \n\tata_qc_for_each(ap, qc, tag) {\n\t\tif (qc)\n\t\t\tnr++;\n\t}\n\n\treturn nr;\n}\n\nvoid ata_eh_fastdrain_timerfn(struct timer_list *t)\n{\n\tstruct ata_port *ap = from_timer(ap, t, fastdrain_timer);\n\tunsigned long flags;\n\tunsigned int cnt;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tcnt = ata_eh_nr_in_flight(ap);\n\n\t \n\tif (!cnt)\n\t\tgoto out_unlock;\n\n\tif (cnt == ap->fastdrain_cnt) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag;\n\n\t\t \n\t\tata_qc_for_each(ap, qc, tag) {\n\t\t\tif (qc)\n\t\t\t\tqc->err_mask |= AC_ERR_TIMEOUT;\n\t\t}\n\n\t\tata_port_freeze(ap);\n\t} else {\n\t\t \n\t\tap->fastdrain_cnt = cnt;\n\t\tap->fastdrain_timer.expires =\n\t\t\tata_deadline(jiffies, ATA_EH_FASTDRAIN_INTERVAL);\n\t\tadd_timer(&ap->fastdrain_timer);\n\t}\n\n out_unlock:\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n\n \nstatic void ata_eh_set_pending(struct ata_port *ap, int fastdrain)\n{\n\tunsigned int cnt;\n\n\t \n\tif (ap->pflags & ATA_PFLAG_EH_PENDING)\n\t\treturn;\n\n\tap->pflags |= ATA_PFLAG_EH_PENDING;\n\n\tif (!fastdrain)\n\t\treturn;\n\n\t \n\tcnt = ata_eh_nr_in_flight(ap);\n\tif (!cnt)\n\t\treturn;\n\n\t \n\tap->fastdrain_cnt = cnt;\n\tap->fastdrain_timer.expires =\n\t\tata_deadline(jiffies, ATA_EH_FASTDRAIN_INTERVAL);\n\tadd_timer(&ap->fastdrain_timer);\n}\n\n \nvoid ata_qc_schedule_eh(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\n\tqc->flags |= ATA_QCFLAG_EH;\n\tata_eh_set_pending(ap, 1);\n\n\t \n\tblk_abort_request(scsi_cmd_to_rq(qc->scsicmd));\n}\n\n \nvoid ata_std_sched_eh(struct ata_port *ap)\n{\n\tif (ap->pflags & ATA_PFLAG_INITIALIZING)\n\t\treturn;\n\n\tata_eh_set_pending(ap, 1);\n\tscsi_schedule_eh(ap->scsi_host);\n\n\ttrace_ata_std_sched_eh(ap);\n}\nEXPORT_SYMBOL_GPL(ata_std_sched_eh);\n\n \nvoid ata_std_end_eh(struct ata_port *ap)\n{\n\tstruct Scsi_Host *host = ap->scsi_host;\n\n\thost->host_eh_scheduled = 0;\n}\nEXPORT_SYMBOL(ata_std_end_eh);\n\n\n \nvoid ata_port_schedule_eh(struct ata_port *ap)\n{\n\t \n\tap->ops->sched_eh(ap);\n}\nEXPORT_SYMBOL_GPL(ata_port_schedule_eh);\n\nstatic int ata_do_link_abort(struct ata_port *ap, struct ata_link *link)\n{\n\tstruct ata_queued_cmd *qc;\n\tint tag, nr_aborted = 0;\n\n\t \n\tata_eh_set_pending(ap, 0);\n\n\t \n\tata_qc_for_each_with_internal(ap, qc, tag) {\n\t\tif (qc && (!link || qc->dev->link == link)) {\n\t\t\tqc->flags |= ATA_QCFLAG_EH;\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_aborted++;\n\t\t}\n\t}\n\n\tif (!nr_aborted)\n\t\tata_port_schedule_eh(ap);\n\n\treturn nr_aborted;\n}\n\n \nint ata_link_abort(struct ata_link *link)\n{\n\treturn ata_do_link_abort(link->ap, link);\n}\nEXPORT_SYMBOL_GPL(ata_link_abort);\n\n \nint ata_port_abort(struct ata_port *ap)\n{\n\treturn ata_do_link_abort(ap, NULL);\n}\nEXPORT_SYMBOL_GPL(ata_port_abort);\n\n \nstatic void __ata_port_freeze(struct ata_port *ap)\n{\n\tif (ap->ops->freeze)\n\t\tap->ops->freeze(ap);\n\n\tap->pflags |= ATA_PFLAG_FROZEN;\n\n\ttrace_ata_port_freeze(ap);\n}\n\n \nint ata_port_freeze(struct ata_port *ap)\n{\n\t__ata_port_freeze(ap);\n\n\treturn ata_port_abort(ap);\n}\nEXPORT_SYMBOL_GPL(ata_port_freeze);\n\n \nvoid ata_eh_freeze_port(struct ata_port *ap)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t__ata_port_freeze(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ata_eh_freeze_port);\n\n \nvoid ata_eh_thaw_port(struct ata_port *ap)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tap->pflags &= ~ATA_PFLAG_FROZEN;\n\n\tif (ap->ops->thaw)\n\t\tap->ops->thaw(ap);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\ttrace_ata_port_thaw(ap);\n}\n\nstatic void ata_eh_scsidone(struct scsi_cmnd *scmd)\n{\n\t \n}\n\nstatic void __ata_eh_qc_complete(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tqc->scsidone = ata_eh_scsidone;\n\t__ata_qc_complete(qc);\n\tWARN_ON(ata_tag_valid(qc->tag));\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tscsi_eh_finish_cmd(scmd, &ap->eh_done_q);\n}\n\n \nvoid ata_eh_qc_complete(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tscmd->retries = scmd->allowed;\n\t__ata_eh_qc_complete(qc);\n}\n\n \nvoid ata_eh_qc_retry(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tif (!qc->err_mask)\n\t\tscmd->allowed++;\n\t__ata_eh_qc_complete(qc);\n}\n\n \nvoid ata_dev_disable(struct ata_device *dev)\n{\n\tif (!ata_dev_enabled(dev))\n\t\treturn;\n\n\tata_dev_warn(dev, \"disable device\\n\");\n\tata_acpi_on_disable(dev);\n\tata_down_xfermask_limit(dev, ATA_DNXFER_FORCE_PIO0 | ATA_DNXFER_QUIET);\n\tdev->class++;\n\n\t \n\tata_ering_clear(&dev->ering);\n}\nEXPORT_SYMBOL_GPL(ata_dev_disable);\n\n \nvoid ata_eh_detach_dev(struct ata_device *dev)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tunsigned long flags;\n\n\t \n\tif (ata_dev_enabled(dev))\n\t\tata_dev_power_set_standby(dev);\n\n\tata_dev_disable(dev);\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tdev->flags &= ~ATA_DFLAG_DETACH;\n\n\tif (ata_scsi_offline_dev(dev)) {\n\t\tdev->flags |= ATA_DFLAG_DETACHED;\n\t\tap->pflags |= ATA_PFLAG_SCSI_HOTPLUG;\n\t}\n\n\t \n\tata_eh_clear_action(link, dev, &link->eh_info, ATA_EH_PERDEV_MASK);\n\tata_eh_clear_action(link, dev, &link->eh_context.i, ATA_EH_PERDEV_MASK);\n\tehc->saved_xfer_mode[dev->devno] = 0;\n\tehc->saved_ncq_enabled &= ~(1 << dev->devno);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n\n \nvoid ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,\n\t\t\tunsigned int action)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_info *ehi = &link->eh_info;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tunsigned long flags;\n\n\ttrace_ata_eh_about_to_do(link, dev ? dev->devno : 0, action);\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tata_eh_clear_action(link, dev, ehi, action);\n\n\t \n\tif (!(ehc->i.flags & ATA_EHI_QUIET) && link != ap->slave_link)\n\t\tap->pflags |= ATA_PFLAG_RECOVERED;\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n\n \nvoid ata_eh_done(struct ata_link *link, struct ata_device *dev,\n\t\t unsigned int action)\n{\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\n\ttrace_ata_eh_done(link, dev ? dev->devno : 0, action);\n\n\tata_eh_clear_action(link, dev, &ehc->i, action);\n}\n\n \nstatic const char *ata_err_string(unsigned int err_mask)\n{\n\tif (err_mask & AC_ERR_HOST_BUS)\n\t\treturn \"host bus error\";\n\tif (err_mask & AC_ERR_ATA_BUS)\n\t\treturn \"ATA bus error\";\n\tif (err_mask & AC_ERR_TIMEOUT)\n\t\treturn \"timeout\";\n\tif (err_mask & AC_ERR_HSM)\n\t\treturn \"HSM violation\";\n\tif (err_mask & AC_ERR_SYSTEM)\n\t\treturn \"internal error\";\n\tif (err_mask & AC_ERR_MEDIA)\n\t\treturn \"media error\";\n\tif (err_mask & AC_ERR_INVALID)\n\t\treturn \"invalid argument\";\n\tif (err_mask & AC_ERR_DEV)\n\t\treturn \"device error\";\n\tif (err_mask & AC_ERR_NCQ)\n\t\treturn \"NCQ error\";\n\tif (err_mask & AC_ERR_NODEV_HINT)\n\t\treturn \"Polling detection error\";\n\treturn \"unknown error\";\n}\n\n \nunsigned int atapi_eh_tur(struct ata_device *dev, u8 *r_sense_key)\n{\n\tu8 cdb[ATAPI_CDB_LEN] = { TEST_UNIT_READY, 0, 0, 0, 0, 0 };\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\tata_tf_init(dev, &tf);\n\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf.command = ATA_CMD_PACKET;\n\ttf.protocol = ATAPI_PROT_NODATA;\n\n\terr_mask = ata_exec_internal(dev, &tf, cdb, DMA_NONE, NULL, 0, 0);\n\tif (err_mask == AC_ERR_DEV)\n\t\t*r_sense_key = tf.error >> 4;\n\treturn err_mask;\n}\n\n \nstatic bool ata_eh_request_sense(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tstruct ata_device *dev = qc->dev;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\tif (ata_port_is_frozen(qc->ap)) {\n\t\tata_dev_warn(dev, \"sense data available but port frozen\\n\");\n\t\treturn false;\n\t}\n\n\tif (!ata_id_sense_reporting_enabled(dev->id)) {\n\t\tata_dev_warn(qc->dev, \"sense data reporting disabled\\n\");\n\t\treturn false;\n\t}\n\n\tata_tf_init(dev, &tf);\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf.flags |= ATA_TFLAG_LBA | ATA_TFLAG_LBA48;\n\ttf.command = ATA_CMD_REQ_SENSE_DATA;\n\ttf.protocol = ATA_PROT_NODATA;\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\t \n\tif (tf.status & ATA_SENSE) {\n\t\tif (ata_scsi_sense_is_valid(tf.lbah, tf.lbam, tf.lbal)) {\n\t\t\t \n\t\t\tscsi_build_sense_buffer(dev->flags & ATA_DFLAG_D_SENSE,\n\t\t\t\t\t\tcmd->sense_buffer, tf.lbah,\n\t\t\t\t\t\ttf.lbam, tf.lbal);\n\t\t\tqc->flags |= ATA_QCFLAG_SENSE_VALID;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tata_dev_warn(dev, \"request sense failed stat %02x emask %x\\n\",\n\t\t\t     tf.status, err_mask);\n\t}\n\n\treturn false;\n}\n\n \nunsigned int atapi_eh_request_sense(struct ata_device *dev,\n\t\t\t\t\t   u8 *sense_buf, u8 dfl_sense_key)\n{\n\tu8 cdb[ATAPI_CDB_LEN] =\n\t\t{ REQUEST_SENSE, 0, 0, 0, SCSI_SENSE_BUFFERSIZE, 0 };\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct ata_taskfile tf;\n\n\tmemset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);\n\n\t \n\tsense_buf[0] = 0x70;\n\tsense_buf[2] = dfl_sense_key;\n\n\t \n\tata_tf_init(dev, &tf);\n\n\ttf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf.command = ATA_CMD_PACKET;\n\n\t \n\tif (ap->flags & ATA_FLAG_PIO_DMA) {\n\t\ttf.protocol = ATAPI_PROT_DMA;\n\t\ttf.feature |= ATAPI_PKT_DMA;\n\t} else {\n\t\ttf.protocol = ATAPI_PROT_PIO;\n\t\ttf.lbam = SCSI_SENSE_BUFFERSIZE;\n\t\ttf.lbah = 0;\n\t}\n\n\treturn ata_exec_internal(dev, &tf, cdb, DMA_FROM_DEVICE,\n\t\t\t\t sense_buf, SCSI_SENSE_BUFFERSIZE, 0);\n}\n\n \nstatic void ata_eh_analyze_serror(struct ata_link *link)\n{\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tu32 serror = ehc->i.serror;\n\tunsigned int err_mask = 0, action = 0;\n\tu32 hotplug_mask;\n\n\tif (serror & (SERR_PERSISTENT | SERR_DATA)) {\n\t\terr_mask |= AC_ERR_ATA_BUS;\n\t\taction |= ATA_EH_RESET;\n\t}\n\tif (serror & SERR_PROTOCOL) {\n\t\terr_mask |= AC_ERR_HSM;\n\t\taction |= ATA_EH_RESET;\n\t}\n\tif (serror & SERR_INTERNAL) {\n\t\terr_mask |= AC_ERR_SYSTEM;\n\t\taction |= ATA_EH_RESET;\n\t}\n\n\t \n\tif (link->lpm_policy > ATA_LPM_MAX_POWER)\n\t\thotplug_mask = 0;\t \n\telse if (!(link->flags & ATA_LFLAG_DISABLED) || ata_is_host_link(link))\n\t\thotplug_mask = SERR_PHYRDY_CHG | SERR_DEV_XCHG;\n\telse\n\t\thotplug_mask = SERR_PHYRDY_CHG;\n\n\tif (serror & hotplug_mask)\n\t\tata_ehi_hotplugged(&ehc->i);\n\n\tehc->i.err_mask |= err_mask;\n\tehc->i.action |= action;\n}\n\n \nstatic unsigned int ata_eh_analyze_tf(struct ata_queued_cmd *qc)\n{\n\tconst struct ata_taskfile *tf = &qc->result_tf;\n\tunsigned int tmp, action = 0;\n\tu8 stat = tf->status, err = tf->error;\n\n\tif ((stat & (ATA_BUSY | ATA_DRQ | ATA_DRDY)) != ATA_DRDY) {\n\t\tqc->err_mask |= AC_ERR_HSM;\n\t\treturn ATA_EH_RESET;\n\t}\n\n\tif (stat & (ATA_ERR | ATA_DF)) {\n\t\tqc->err_mask |= AC_ERR_DEV;\n\t\t \n\t\tif (stat & ATA_DF)\n\t\t\tstat &= ~ATA_SENSE;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tswitch (qc->dev->class) {\n\tcase ATA_DEV_ATA:\n\tcase ATA_DEV_ZAC:\n\t\t \n\t\tif (!(qc->flags & ATA_QCFLAG_SENSE_VALID) &&\n\t\t    (stat & ATA_SENSE) && ata_eh_request_sense(qc))\n\t\t\tset_status_byte(qc->scsicmd, SAM_STAT_CHECK_CONDITION);\n\t\tif (err & ATA_ICRC)\n\t\t\tqc->err_mask |= AC_ERR_ATA_BUS;\n\t\tif (err & (ATA_UNC | ATA_AMNF))\n\t\t\tqc->err_mask |= AC_ERR_MEDIA;\n\t\tif (err & ATA_IDNF)\n\t\t\tqc->err_mask |= AC_ERR_INVALID;\n\t\tbreak;\n\n\tcase ATA_DEV_ATAPI:\n\t\tif (!ata_port_is_frozen(qc->ap)) {\n\t\t\ttmp = atapi_eh_request_sense(qc->dev,\n\t\t\t\t\t\tqc->scsicmd->sense_buffer,\n\t\t\t\t\t\tqc->result_tf.error >> 4);\n\t\t\tif (!tmp)\n\t\t\t\tqc->flags |= ATA_QCFLAG_SENSE_VALID;\n\t\t\telse\n\t\t\t\tqc->err_mask |= tmp;\n\t\t}\n\t}\n\n\tif (qc->flags & ATA_QCFLAG_SENSE_VALID) {\n\t\tenum scsi_disposition ret = scsi_check_sense(qc->scsicmd);\n\t\t \n\t\tif (ret == NEEDS_RETRY || ret == ADD_TO_MLQUEUE) {\n\t\t\tqc->flags |= ATA_QCFLAG_RETRY;\n\t\t\tqc->err_mask |= AC_ERR_OTHER;\n\t\t} else if (ret != SUCCESS) {\n\t\t\tqc->err_mask |= AC_ERR_HSM;\n\t\t}\n\t}\n\tif (qc->err_mask & (AC_ERR_HSM | AC_ERR_TIMEOUT | AC_ERR_ATA_BUS))\n\t\taction |= ATA_EH_RESET;\n\n\treturn action;\n}\n\nstatic int ata_eh_categorize_error(unsigned int eflags, unsigned int err_mask,\n\t\t\t\t   int *xfer_ok)\n{\n\tint base = 0;\n\n\tif (!(eflags & ATA_EFLAG_DUBIOUS_XFER))\n\t\t*xfer_ok = 1;\n\n\tif (!*xfer_ok)\n\t\tbase = ATA_ECAT_DUBIOUS_NONE;\n\n\tif (err_mask & AC_ERR_ATA_BUS)\n\t\treturn base + ATA_ECAT_ATA_BUS;\n\n\tif (err_mask & AC_ERR_TIMEOUT)\n\t\treturn base + ATA_ECAT_TOUT_HSM;\n\n\tif (eflags & ATA_EFLAG_IS_IO) {\n\t\tif (err_mask & AC_ERR_HSM)\n\t\t\treturn base + ATA_ECAT_TOUT_HSM;\n\t\tif ((err_mask &\n\t\t     (AC_ERR_DEV|AC_ERR_MEDIA|AC_ERR_INVALID)) == AC_ERR_DEV)\n\t\t\treturn base + ATA_ECAT_UNK_DEV;\n\t}\n\n\treturn 0;\n}\n\nstruct speed_down_verdict_arg {\n\tu64 since;\n\tint xfer_ok;\n\tint nr_errors[ATA_ECAT_NR];\n};\n\nstatic int speed_down_verdict_cb(struct ata_ering_entry *ent, void *void_arg)\n{\n\tstruct speed_down_verdict_arg *arg = void_arg;\n\tint cat;\n\n\tif ((ent->eflags & ATA_EFLAG_OLD_ER) || (ent->timestamp < arg->since))\n\t\treturn -1;\n\n\tcat = ata_eh_categorize_error(ent->eflags, ent->err_mask,\n\t\t\t\t      &arg->xfer_ok);\n\targ->nr_errors[cat]++;\n\n\treturn 0;\n}\n\n \nstatic unsigned int ata_eh_speed_down_verdict(struct ata_device *dev)\n{\n\tconst u64 j5mins = 5LLU * 60 * HZ, j10mins = 10LLU * 60 * HZ;\n\tu64 j64 = get_jiffies_64();\n\tstruct speed_down_verdict_arg arg;\n\tunsigned int verdict = 0;\n\n\t \n\tmemset(&arg, 0, sizeof(arg));\n\targ.since = j64 - min(j64, j5mins);\n\tata_ering_map(&dev->ering, speed_down_verdict_cb, &arg);\n\n\tif (arg.nr_errors[ATA_ECAT_DUBIOUS_ATA_BUS] +\n\t    arg.nr_errors[ATA_ECAT_DUBIOUS_TOUT_HSM] > 1)\n\t\tverdict |= ATA_EH_SPDN_SPEED_DOWN |\n\t\t\tATA_EH_SPDN_FALLBACK_TO_PIO | ATA_EH_SPDN_KEEP_ERRORS;\n\n\tif (arg.nr_errors[ATA_ECAT_DUBIOUS_TOUT_HSM] +\n\t    arg.nr_errors[ATA_ECAT_DUBIOUS_UNK_DEV] > 1)\n\t\tverdict |= ATA_EH_SPDN_NCQ_OFF | ATA_EH_SPDN_KEEP_ERRORS;\n\n\tif (arg.nr_errors[ATA_ECAT_ATA_BUS] +\n\t    arg.nr_errors[ATA_ECAT_TOUT_HSM] +\n\t    arg.nr_errors[ATA_ECAT_UNK_DEV] > 6)\n\t\tverdict |= ATA_EH_SPDN_FALLBACK_TO_PIO;\n\n\t \n\tmemset(&arg, 0, sizeof(arg));\n\targ.since = j64 - min(j64, j10mins);\n\tata_ering_map(&dev->ering, speed_down_verdict_cb, &arg);\n\n\tif (arg.nr_errors[ATA_ECAT_TOUT_HSM] +\n\t    arg.nr_errors[ATA_ECAT_UNK_DEV] > 3)\n\t\tverdict |= ATA_EH_SPDN_NCQ_OFF;\n\n\tif (arg.nr_errors[ATA_ECAT_ATA_BUS] +\n\t    arg.nr_errors[ATA_ECAT_TOUT_HSM] > 3 ||\n\t    arg.nr_errors[ATA_ECAT_UNK_DEV] > 6)\n\t\tverdict |= ATA_EH_SPDN_SPEED_DOWN;\n\n\treturn verdict;\n}\n\n \nstatic unsigned int ata_eh_speed_down(struct ata_device *dev,\n\t\t\t\tunsigned int eflags, unsigned int err_mask)\n{\n\tstruct ata_link *link = ata_dev_phys_link(dev);\n\tint xfer_ok = 0;\n\tunsigned int verdict;\n\tunsigned int action = 0;\n\n\t \n\tif (ata_eh_categorize_error(eflags, err_mask, &xfer_ok) == 0)\n\t\treturn 0;\n\n\t \n\tata_ering_record(&dev->ering, eflags, err_mask);\n\tverdict = ata_eh_speed_down_verdict(dev);\n\n\t \n\tif ((verdict & ATA_EH_SPDN_NCQ_OFF) && ata_ncq_enabled(dev)) {\n\t\tdev->flags |= ATA_DFLAG_NCQ_OFF;\n\t\tata_dev_warn(dev, \"NCQ disabled due to excessive errors\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (verdict & ATA_EH_SPDN_SPEED_DOWN) {\n\t\t \n\t\tif (sata_down_spd_limit(link, 0) == 0) {\n\t\t\taction |= ATA_EH_RESET;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (dev->spdn_cnt < 2) {\n\t\t\tstatic const int dma_dnxfer_sel[] =\n\t\t\t\t{ ATA_DNXFER_DMA, ATA_DNXFER_40C };\n\t\t\tstatic const int pio_dnxfer_sel[] =\n\t\t\t\t{ ATA_DNXFER_PIO, ATA_DNXFER_FORCE_PIO0 };\n\t\t\tint sel;\n\n\t\t\tif (dev->xfer_shift != ATA_SHIFT_PIO)\n\t\t\t\tsel = dma_dnxfer_sel[dev->spdn_cnt];\n\t\t\telse\n\t\t\t\tsel = pio_dnxfer_sel[dev->spdn_cnt];\n\n\t\t\tdev->spdn_cnt++;\n\n\t\t\tif (ata_down_xfermask_limit(dev, sel) == 0) {\n\t\t\t\taction |= ATA_EH_RESET;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((verdict & ATA_EH_SPDN_FALLBACK_TO_PIO) && (dev->spdn_cnt >= 2) &&\n\t    (link->ap->cbl != ATA_CBL_SATA || dev->class == ATA_DEV_ATAPI) &&\n\t    (dev->xfer_shift != ATA_SHIFT_PIO)) {\n\t\tif (ata_down_xfermask_limit(dev, ATA_DNXFER_FORCE_PIO) == 0) {\n\t\t\tdev->spdn_cnt = 0;\n\t\t\taction |= ATA_EH_RESET;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\treturn 0;\n done:\n\t \n\tif (!(verdict & ATA_EH_SPDN_KEEP_ERRORS))\n\t\tata_ering_clear(&dev->ering);\n\treturn action;\n}\n\n \nstatic inline int ata_eh_worth_retry(struct ata_queued_cmd *qc)\n{\n\tif (qc->err_mask & AC_ERR_MEDIA)\n\t\treturn 0;\t \n\tif (qc->flags & ATA_QCFLAG_IO)\n\t\treturn 1;\t \n\tif (qc->err_mask & AC_ERR_INVALID)\n\t\treturn 0;\t \n\treturn qc->err_mask != AC_ERR_DEV;   \n}\n\n \nstatic inline bool ata_eh_quiet(struct ata_queued_cmd *qc)\n{\n\tif (qc->scsicmd && scsi_cmd_to_rq(qc->scsicmd)->rq_flags & RQF_QUIET)\n\t\tqc->flags |= ATA_QCFLAG_QUIET;\n\treturn qc->flags & ATA_QCFLAG_QUIET;\n}\n\nstatic int ata_eh_read_sense_success_non_ncq(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_queued_cmd *qc;\n\n\tqc = __ata_qc_from_tag(ap, link->active_tag);\n\tif (!qc)\n\t\treturn -EIO;\n\n\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t    !(qc->flags & ATA_QCFLAG_EH_SUCCESS_CMD) ||\n\t    qc->err_mask)\n\t\treturn -EIO;\n\n\tif (!ata_eh_request_sense(qc))\n\t\treturn -EIO;\n\n\t \n\tscsi_check_sense(qc->scsicmd);\n\n\treturn 0;\n}\n\nstatic void ata_eh_get_success_sense(struct ata_link *link)\n{\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_device *dev = link->device;\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_queued_cmd *qc;\n\tint tag, ret = 0;\n\n\tif (!(ehc->i.dev_action[dev->devno] & ATA_EH_GET_SUCCESS_SENSE))\n\t\treturn;\n\n\t \n\tif (ata_port_is_frozen(ap)) {\n\t\tata_dev_warn(dev,\n\t\t\t\"successful sense data available but port frozen\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (link->sactive)\n\t\tret = ata_eh_read_sense_success_ncq_log(link);\n\telse\n\t\tret = ata_eh_read_sense_success_non_ncq(link);\n\tif (ret)\n\t\tgoto out;\n\n\tata_eh_done(link, dev, ATA_EH_GET_SUCCESS_SENSE);\n\treturn;\n\nout:\n\t \n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t\t    !(qc->flags & ATA_QCFLAG_EH_SUCCESS_CMD) ||\n\t\t    qc->err_mask ||\n\t\t    ata_dev_phys_link(qc->dev) != link)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (qc->flags & ATA_QCFLAG_SENSE_VALID)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(qc->result_tf.status & ATA_SENSE))\n\t\t\tcontinue;\n\n\t\t \n\t\tata_scsi_set_sense(dev, qc->scsicmd, ABORTED_COMMAND, 0, 0);\n\t\tqc->flags |= ATA_QCFLAG_SENSE_VALID;\n\t}\n\tata_eh_done(link, dev, ATA_EH_GET_SUCCESS_SENSE);\n}\n\n \nstatic void ata_eh_link_autopsy(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_queued_cmd *qc;\n\tstruct ata_device *dev;\n\tunsigned int all_err_mask = 0, eflags = 0;\n\tint tag, nr_failed = 0, nr_quiet = 0;\n\tu32 serror;\n\tint rc;\n\n\tif (ehc->i.flags & ATA_EHI_NO_AUTOPSY)\n\t\treturn;\n\n\t \n\trc = sata_scr_read(link, SCR_ERROR, &serror);\n\tif (rc == 0) {\n\t\tehc->i.serror |= serror;\n\t\tata_eh_analyze_serror(link);\n\t} else if (rc != -EOPNOTSUPP) {\n\t\t \n\t\tehc->i.probe_mask |= ATA_ALL_DEVICES;\n\t\tehc->i.action |= ATA_EH_RESET;\n\t\tehc->i.err_mask |= AC_ERR_OTHER;\n\t}\n\n\t \n\tata_eh_analyze_ncq_error(link);\n\n\t \n\tata_eh_get_success_sense(link);\n\n\t \n\tif (ehc->i.err_mask & ~AC_ERR_OTHER)\n\t\tehc->i.err_mask &= ~AC_ERR_OTHER;\n\n\tall_err_mask |= ehc->i.err_mask;\n\n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t\t    qc->flags & ATA_QCFLAG_RETRY ||\n\t\t    qc->flags & ATA_QCFLAG_EH_SUCCESS_CMD ||\n\t\t    ata_dev_phys_link(qc->dev) != link)\n\t\t\tcontinue;\n\n\t\t \n\t\tqc->err_mask |= ehc->i.err_mask;\n\n\t\t \n\t\tehc->i.action |= ata_eh_analyze_tf(qc);\n\n\t\t \n\t\tif (qc->err_mask & AC_ERR_ATA_BUS)\n\t\t\tqc->err_mask &= ~(AC_ERR_DEV | AC_ERR_MEDIA |\n\t\t\t\t\t  AC_ERR_INVALID);\n\n\t\t \n\t\tif (qc->err_mask & ~AC_ERR_OTHER)\n\t\t\tqc->err_mask &= ~AC_ERR_OTHER;\n\n\t\t \n\t\tif (qc->flags & ATA_QCFLAG_SENSE_VALID)\n\t\t\tqc->err_mask &= ~(AC_ERR_DEV | AC_ERR_OTHER);\n\t\telse if (ata_eh_worth_retry(qc))\n\t\t\tqc->flags |= ATA_QCFLAG_RETRY;\n\n\t\t \n\t\tehc->i.dev = qc->dev;\n\t\tall_err_mask |= qc->err_mask;\n\t\tif (qc->flags & ATA_QCFLAG_IO)\n\t\t\teflags |= ATA_EFLAG_IS_IO;\n\t\ttrace_ata_eh_link_autopsy_qc(qc);\n\n\t\t \n\t\tif (ata_eh_quiet(qc))\n\t\t\tnr_quiet++;\n\t\tnr_failed++;\n\t}\n\n\t \n\tif (nr_quiet == nr_failed)\n\t\tehc->i.flags |= ATA_EHI_QUIET;\n\n\t \n\tif (ata_port_is_frozen(ap) ||\n\t    all_err_mask & (AC_ERR_HSM | AC_ERR_TIMEOUT))\n\t\tehc->i.action |= ATA_EH_RESET;\n\telse if (((eflags & ATA_EFLAG_IS_IO) && all_err_mask) ||\n\t\t (!(eflags & ATA_EFLAG_IS_IO) && (all_err_mask & ~AC_ERR_DEV)))\n\t\tehc->i.action |= ATA_EH_REVALIDATE;\n\n\t \n\tif (ehc->i.dev) {\n\t\tehc->i.dev_action[ehc->i.dev->devno] |=\n\t\t\tehc->i.action & ATA_EH_PERDEV_MASK;\n\t\tehc->i.action &= ~ATA_EH_PERDEV_MASK;\n\t}\n\n\t \n\tif ((all_err_mask & AC_ERR_TIMEOUT) && !ata_is_host_link(link))\n\t\tap->link.eh_context.i.err_mask |= AC_ERR_TIMEOUT;\n\n\t \n\tdev = ehc->i.dev;\n\tif (!dev && ((ata_link_max_devices(link) == 1 &&\n\t\t      ata_dev_enabled(link->device))))\n\t    dev = link->device;\n\n\tif (dev) {\n\t\tif (dev->flags & ATA_DFLAG_DUBIOUS_XFER)\n\t\t\teflags |= ATA_EFLAG_DUBIOUS_XFER;\n\t\tehc->i.action |= ata_eh_speed_down(dev, eflags, all_err_mask);\n\t\ttrace_ata_eh_link_autopsy(dev, ehc->i.action, all_err_mask);\n\t}\n}\n\n \nvoid ata_eh_autopsy(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\n\tata_for_each_link(link, ap, EDGE)\n\t\tata_eh_link_autopsy(link);\n\n\t \n\tif (ap->slave_link) {\n\t\tstruct ata_eh_context *mehc = &ap->link.eh_context;\n\t\tstruct ata_eh_context *sehc = &ap->slave_link->eh_context;\n\n\t\t \n\t\tsehc->i.flags |= mehc->i.flags & ATA_EHI_TO_SLAVE_MASK;\n\n\t\t \n\t\tata_eh_link_autopsy(ap->slave_link);\n\n\t\t \n\t\tata_eh_about_to_do(ap->slave_link, NULL, ATA_EH_ALL_ACTIONS);\n\t\tmehc->i.action\t\t|= sehc->i.action;\n\t\tmehc->i.dev_action[1]\t|= sehc->i.dev_action[1];\n\t\tmehc->i.flags\t\t|= sehc->i.flags;\n\t\tata_eh_done(ap->slave_link, NULL, ATA_EH_ALL_ACTIONS);\n\t}\n\n\t \n\tif (sata_pmp_attached(ap))\n\t\tata_eh_link_autopsy(&ap->link);\n}\n\n \nconst char *ata_get_cmd_name(u8 command)\n{\n#ifdef CONFIG_ATA_VERBOSE_ERROR\n\tstatic const struct\n\t{\n\t\tu8 command;\n\t\tconst char *text;\n\t} cmd_descr[] = {\n\t\t{ ATA_CMD_DEV_RESET,\t\t\"DEVICE RESET\" },\n\t\t{ ATA_CMD_CHK_POWER,\t\t\"CHECK POWER MODE\" },\n\t\t{ ATA_CMD_STANDBY,\t\t\"STANDBY\" },\n\t\t{ ATA_CMD_IDLE,\t\t\t\"IDLE\" },\n\t\t{ ATA_CMD_EDD,\t\t\t\"EXECUTE DEVICE DIAGNOSTIC\" },\n\t\t{ ATA_CMD_DOWNLOAD_MICRO,\t\"DOWNLOAD MICROCODE\" },\n\t\t{ ATA_CMD_DOWNLOAD_MICRO_DMA,\t\"DOWNLOAD MICROCODE DMA\" },\n\t\t{ ATA_CMD_NOP,\t\t\t\"NOP\" },\n\t\t{ ATA_CMD_FLUSH,\t\t\"FLUSH CACHE\" },\n\t\t{ ATA_CMD_FLUSH_EXT,\t\t\"FLUSH CACHE EXT\" },\n\t\t{ ATA_CMD_ID_ATA,\t\t\"IDENTIFY DEVICE\" },\n\t\t{ ATA_CMD_ID_ATAPI,\t\t\"IDENTIFY PACKET DEVICE\" },\n\t\t{ ATA_CMD_SERVICE,\t\t\"SERVICE\" },\n\t\t{ ATA_CMD_READ,\t\t\t\"READ DMA\" },\n\t\t{ ATA_CMD_READ_EXT,\t\t\"READ DMA EXT\" },\n\t\t{ ATA_CMD_READ_QUEUED,\t\t\"READ DMA QUEUED\" },\n\t\t{ ATA_CMD_READ_STREAM_EXT,\t\"READ STREAM EXT\" },\n\t\t{ ATA_CMD_READ_STREAM_DMA_EXT,  \"READ STREAM DMA EXT\" },\n\t\t{ ATA_CMD_WRITE,\t\t\"WRITE DMA\" },\n\t\t{ ATA_CMD_WRITE_EXT,\t\t\"WRITE DMA EXT\" },\n\t\t{ ATA_CMD_WRITE_QUEUED,\t\t\"WRITE DMA QUEUED EXT\" },\n\t\t{ ATA_CMD_WRITE_STREAM_EXT,\t\"WRITE STREAM EXT\" },\n\t\t{ ATA_CMD_WRITE_STREAM_DMA_EXT, \"WRITE STREAM DMA EXT\" },\n\t\t{ ATA_CMD_WRITE_FUA_EXT,\t\"WRITE DMA FUA EXT\" },\n\t\t{ ATA_CMD_WRITE_QUEUED_FUA_EXT, \"WRITE DMA QUEUED FUA EXT\" },\n\t\t{ ATA_CMD_FPDMA_READ,\t\t\"READ FPDMA QUEUED\" },\n\t\t{ ATA_CMD_FPDMA_WRITE,\t\t\"WRITE FPDMA QUEUED\" },\n\t\t{ ATA_CMD_NCQ_NON_DATA,\t\t\"NCQ NON-DATA\" },\n\t\t{ ATA_CMD_FPDMA_SEND,\t\t\"SEND FPDMA QUEUED\" },\n\t\t{ ATA_CMD_FPDMA_RECV,\t\t\"RECEIVE FPDMA QUEUED\" },\n\t\t{ ATA_CMD_PIO_READ,\t\t\"READ SECTOR(S)\" },\n\t\t{ ATA_CMD_PIO_READ_EXT,\t\t\"READ SECTOR(S) EXT\" },\n\t\t{ ATA_CMD_PIO_WRITE,\t\t\"WRITE SECTOR(S)\" },\n\t\t{ ATA_CMD_PIO_WRITE_EXT,\t\"WRITE SECTOR(S) EXT\" },\n\t\t{ ATA_CMD_READ_MULTI,\t\t\"READ MULTIPLE\" },\n\t\t{ ATA_CMD_READ_MULTI_EXT,\t\"READ MULTIPLE EXT\" },\n\t\t{ ATA_CMD_WRITE_MULTI,\t\t\"WRITE MULTIPLE\" },\n\t\t{ ATA_CMD_WRITE_MULTI_EXT,\t\"WRITE MULTIPLE EXT\" },\n\t\t{ ATA_CMD_WRITE_MULTI_FUA_EXT,\t\"WRITE MULTIPLE FUA EXT\" },\n\t\t{ ATA_CMD_SET_FEATURES,\t\t\"SET FEATURES\" },\n\t\t{ ATA_CMD_SET_MULTI,\t\t\"SET MULTIPLE MODE\" },\n\t\t{ ATA_CMD_VERIFY,\t\t\"READ VERIFY SECTOR(S)\" },\n\t\t{ ATA_CMD_VERIFY_EXT,\t\t\"READ VERIFY SECTOR(S) EXT\" },\n\t\t{ ATA_CMD_WRITE_UNCORR_EXT,\t\"WRITE UNCORRECTABLE EXT\" },\n\t\t{ ATA_CMD_STANDBYNOW1,\t\t\"STANDBY IMMEDIATE\" },\n\t\t{ ATA_CMD_IDLEIMMEDIATE,\t\"IDLE IMMEDIATE\" },\n\t\t{ ATA_CMD_SLEEP,\t\t\"SLEEP\" },\n\t\t{ ATA_CMD_INIT_DEV_PARAMS,\t\"INITIALIZE DEVICE PARAMETERS\" },\n\t\t{ ATA_CMD_READ_NATIVE_MAX,\t\"READ NATIVE MAX ADDRESS\" },\n\t\t{ ATA_CMD_READ_NATIVE_MAX_EXT,\t\"READ NATIVE MAX ADDRESS EXT\" },\n\t\t{ ATA_CMD_SET_MAX,\t\t\"SET MAX ADDRESS\" },\n\t\t{ ATA_CMD_SET_MAX_EXT,\t\t\"SET MAX ADDRESS EXT\" },\n\t\t{ ATA_CMD_READ_LOG_EXT,\t\t\"READ LOG EXT\" },\n\t\t{ ATA_CMD_WRITE_LOG_EXT,\t\"WRITE LOG EXT\" },\n\t\t{ ATA_CMD_READ_LOG_DMA_EXT,\t\"READ LOG DMA EXT\" },\n\t\t{ ATA_CMD_WRITE_LOG_DMA_EXT,\t\"WRITE LOG DMA EXT\" },\n\t\t{ ATA_CMD_TRUSTED_NONDATA,\t\"TRUSTED NON-DATA\" },\n\t\t{ ATA_CMD_TRUSTED_RCV,\t\t\"TRUSTED RECEIVE\" },\n\t\t{ ATA_CMD_TRUSTED_RCV_DMA,\t\"TRUSTED RECEIVE DMA\" },\n\t\t{ ATA_CMD_TRUSTED_SND,\t\t\"TRUSTED SEND\" },\n\t\t{ ATA_CMD_TRUSTED_SND_DMA,\t\"TRUSTED SEND DMA\" },\n\t\t{ ATA_CMD_PMP_READ,\t\t\"READ BUFFER\" },\n\t\t{ ATA_CMD_PMP_READ_DMA,\t\t\"READ BUFFER DMA\" },\n\t\t{ ATA_CMD_PMP_WRITE,\t\t\"WRITE BUFFER\" },\n\t\t{ ATA_CMD_PMP_WRITE_DMA,\t\"WRITE BUFFER DMA\" },\n\t\t{ ATA_CMD_CONF_OVERLAY,\t\t\"DEVICE CONFIGURATION OVERLAY\" },\n\t\t{ ATA_CMD_SEC_SET_PASS,\t\t\"SECURITY SET PASSWORD\" },\n\t\t{ ATA_CMD_SEC_UNLOCK,\t\t\"SECURITY UNLOCK\" },\n\t\t{ ATA_CMD_SEC_ERASE_PREP,\t\"SECURITY ERASE PREPARE\" },\n\t\t{ ATA_CMD_SEC_ERASE_UNIT,\t\"SECURITY ERASE UNIT\" },\n\t\t{ ATA_CMD_SEC_FREEZE_LOCK,\t\"SECURITY FREEZE LOCK\" },\n\t\t{ ATA_CMD_SEC_DISABLE_PASS,\t\"SECURITY DISABLE PASSWORD\" },\n\t\t{ ATA_CMD_CONFIG_STREAM,\t\"CONFIGURE STREAM\" },\n\t\t{ ATA_CMD_SMART,\t\t\"SMART\" },\n\t\t{ ATA_CMD_MEDIA_LOCK,\t\t\"DOOR LOCK\" },\n\t\t{ ATA_CMD_MEDIA_UNLOCK,\t\t\"DOOR UNLOCK\" },\n\t\t{ ATA_CMD_DSM,\t\t\t\"DATA SET MANAGEMENT\" },\n\t\t{ ATA_CMD_CHK_MED_CRD_TYP,\t\"CHECK MEDIA CARD TYPE\" },\n\t\t{ ATA_CMD_CFA_REQ_EXT_ERR,\t\"CFA REQUEST EXTENDED ERROR\" },\n\t\t{ ATA_CMD_CFA_WRITE_NE,\t\t\"CFA WRITE SECTORS WITHOUT ERASE\" },\n\t\t{ ATA_CMD_CFA_TRANS_SECT,\t\"CFA TRANSLATE SECTOR\" },\n\t\t{ ATA_CMD_CFA_ERASE,\t\t\"CFA ERASE SECTORS\" },\n\t\t{ ATA_CMD_CFA_WRITE_MULT_NE,\t\"CFA WRITE MULTIPLE WITHOUT ERASE\" },\n\t\t{ ATA_CMD_REQ_SENSE_DATA,\t\"REQUEST SENSE DATA EXT\" },\n\t\t{ ATA_CMD_SANITIZE_DEVICE,\t\"SANITIZE DEVICE\" },\n\t\t{ ATA_CMD_ZAC_MGMT_IN,\t\t\"ZAC MANAGEMENT IN\" },\n\t\t{ ATA_CMD_ZAC_MGMT_OUT,\t\t\"ZAC MANAGEMENT OUT\" },\n\t\t{ ATA_CMD_READ_LONG,\t\t\"READ LONG (with retries)\" },\n\t\t{ ATA_CMD_READ_LONG_ONCE,\t\"READ LONG (without retries)\" },\n\t\t{ ATA_CMD_WRITE_LONG,\t\t\"WRITE LONG (with retries)\" },\n\t\t{ ATA_CMD_WRITE_LONG_ONCE,\t\"WRITE LONG (without retries)\" },\n\t\t{ ATA_CMD_RESTORE,\t\t\"RECALIBRATE\" },\n\t\t{ 0,\t\t\t\tNULL }  \n\t};\n\n\tunsigned int i;\n\tfor (i = 0; cmd_descr[i].text; i++)\n\t\tif (cmd_descr[i].command == command)\n\t\t\treturn cmd_descr[i].text;\n#endif\n\n\treturn \"unknown\";\n}\nEXPORT_SYMBOL_GPL(ata_get_cmd_name);\n\n \nstatic void ata_eh_link_report(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_queued_cmd *qc;\n\tconst char *frozen, *desc;\n\tchar tries_buf[16] = \"\";\n\tint tag, nr_failed = 0;\n\n\tif (ehc->i.flags & ATA_EHI_QUIET)\n\t\treturn;\n\n\tdesc = NULL;\n\tif (ehc->i.desc[0] != '\\0')\n\t\tdesc = ehc->i.desc;\n\n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t\t    ata_dev_phys_link(qc->dev) != link ||\n\t\t    ((qc->flags & ATA_QCFLAG_QUIET) &&\n\t\t     qc->err_mask == AC_ERR_DEV))\n\t\t\tcontinue;\n\t\tif (qc->flags & ATA_QCFLAG_SENSE_VALID && !qc->err_mask)\n\t\t\tcontinue;\n\n\t\tnr_failed++;\n\t}\n\n\tif (!nr_failed && !ehc->i.err_mask)\n\t\treturn;\n\n\tfrozen = \"\";\n\tif (ata_port_is_frozen(ap))\n\t\tfrozen = \" frozen\";\n\n\tif (ap->eh_tries < ATA_EH_MAX_TRIES)\n\t\tsnprintf(tries_buf, sizeof(tries_buf), \" t%d\",\n\t\t\t ap->eh_tries);\n\n\tif (ehc->i.dev) {\n\t\tata_dev_err(ehc->i.dev, \"exception Emask 0x%x \"\n\t\t\t    \"SAct 0x%x SErr 0x%x action 0x%x%s%s\\n\",\n\t\t\t    ehc->i.err_mask, link->sactive, ehc->i.serror,\n\t\t\t    ehc->i.action, frozen, tries_buf);\n\t\tif (desc)\n\t\t\tata_dev_err(ehc->i.dev, \"%s\\n\", desc);\n\t} else {\n\t\tata_link_err(link, \"exception Emask 0x%x \"\n\t\t\t     \"SAct 0x%x SErr 0x%x action 0x%x%s%s\\n\",\n\t\t\t     ehc->i.err_mask, link->sactive, ehc->i.serror,\n\t\t\t     ehc->i.action, frozen, tries_buf);\n\t\tif (desc)\n\t\t\tata_link_err(link, \"%s\\n\", desc);\n\t}\n\n#ifdef CONFIG_ATA_VERBOSE_ERROR\n\tif (ehc->i.serror)\n\t\tata_link_err(link,\n\t\t  \"SError: { %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s}\\n\",\n\t\t  ehc->i.serror & SERR_DATA_RECOVERED ? \"RecovData \" : \"\",\n\t\t  ehc->i.serror & SERR_COMM_RECOVERED ? \"RecovComm \" : \"\",\n\t\t  ehc->i.serror & SERR_DATA ? \"UnrecovData \" : \"\",\n\t\t  ehc->i.serror & SERR_PERSISTENT ? \"Persist \" : \"\",\n\t\t  ehc->i.serror & SERR_PROTOCOL ? \"Proto \" : \"\",\n\t\t  ehc->i.serror & SERR_INTERNAL ? \"HostInt \" : \"\",\n\t\t  ehc->i.serror & SERR_PHYRDY_CHG ? \"PHYRdyChg \" : \"\",\n\t\t  ehc->i.serror & SERR_PHY_INT_ERR ? \"PHYInt \" : \"\",\n\t\t  ehc->i.serror & SERR_COMM_WAKE ? \"CommWake \" : \"\",\n\t\t  ehc->i.serror & SERR_10B_8B_ERR ? \"10B8B \" : \"\",\n\t\t  ehc->i.serror & SERR_DISPARITY ? \"Dispar \" : \"\",\n\t\t  ehc->i.serror & SERR_CRC ? \"BadCRC \" : \"\",\n\t\t  ehc->i.serror & SERR_HANDSHAKE ? \"Handshk \" : \"\",\n\t\t  ehc->i.serror & SERR_LINK_SEQ_ERR ? \"LinkSeq \" : \"\",\n\t\t  ehc->i.serror & SERR_TRANS_ST_ERROR ? \"TrStaTrns \" : \"\",\n\t\t  ehc->i.serror & SERR_UNRECOG_FIS ? \"UnrecFIS \" : \"\",\n\t\t  ehc->i.serror & SERR_DEV_XCHG ? \"DevExch \" : \"\");\n#endif\n\n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tstruct ata_taskfile *cmd = &qc->tf, *res = &qc->result_tf;\n\t\tchar data_buf[20] = \"\";\n\t\tchar cdb_buf[70] = \"\";\n\n\t\tif (!(qc->flags & ATA_QCFLAG_EH) ||\n\t\t    ata_dev_phys_link(qc->dev) != link || !qc->err_mask)\n\t\t\tcontinue;\n\n\t\tif (qc->dma_dir != DMA_NONE) {\n\t\t\tstatic const char *dma_str[] = {\n\t\t\t\t[DMA_BIDIRECTIONAL]\t= \"bidi\",\n\t\t\t\t[DMA_TO_DEVICE]\t\t= \"out\",\n\t\t\t\t[DMA_FROM_DEVICE]\t= \"in\",\n\t\t\t};\n\t\t\tconst char *prot_str = NULL;\n\n\t\t\tswitch (qc->tf.protocol) {\n\t\t\tcase ATA_PROT_UNKNOWN:\n\t\t\t\tprot_str = \"unknown\";\n\t\t\t\tbreak;\n\t\t\tcase ATA_PROT_NODATA:\n\t\t\t\tprot_str = \"nodata\";\n\t\t\t\tbreak;\n\t\t\tcase ATA_PROT_PIO:\n\t\t\t\tprot_str = \"pio\";\n\t\t\t\tbreak;\n\t\t\tcase ATA_PROT_DMA:\n\t\t\t\tprot_str = \"dma\";\n\t\t\t\tbreak;\n\t\t\tcase ATA_PROT_NCQ:\n\t\t\t\tprot_str = \"ncq dma\";\n\t\t\t\tbreak;\n\t\t\tcase ATA_PROT_NCQ_NODATA:\n\t\t\t\tprot_str = \"ncq nodata\";\n\t\t\t\tbreak;\n\t\t\tcase ATAPI_PROT_NODATA:\n\t\t\t\tprot_str = \"nodata\";\n\t\t\t\tbreak;\n\t\t\tcase ATAPI_PROT_PIO:\n\t\t\t\tprot_str = \"pio\";\n\t\t\t\tbreak;\n\t\t\tcase ATAPI_PROT_DMA:\n\t\t\t\tprot_str = \"dma\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsnprintf(data_buf, sizeof(data_buf), \" %s %u %s\",\n\t\t\t\t prot_str, qc->nbytes, dma_str[qc->dma_dir]);\n\t\t}\n\n\t\tif (ata_is_atapi(qc->tf.protocol)) {\n\t\t\tconst u8 *cdb = qc->cdb;\n\t\t\tsize_t cdb_len = qc->dev->cdb_len;\n\n\t\t\tif (qc->scsicmd) {\n\t\t\t\tcdb = qc->scsicmd->cmnd;\n\t\t\t\tcdb_len = qc->scsicmd->cmd_len;\n\t\t\t}\n\t\t\t__scsi_format_command(cdb_buf, sizeof(cdb_buf),\n\t\t\t\t\t      cdb, cdb_len);\n\t\t} else\n\t\t\tata_dev_err(qc->dev, \"failed command: %s\\n\",\n\t\t\t\t    ata_get_cmd_name(cmd->command));\n\n\t\tata_dev_err(qc->dev,\n\t\t\t\"cmd %02x/%02x:%02x:%02x:%02x:%02x/%02x:%02x:%02x:%02x:%02x/%02x \"\n\t\t\t\"tag %d%s\\n         %s\"\n\t\t\t\"res %02x/%02x:%02x:%02x:%02x:%02x/%02x:%02x:%02x:%02x:%02x/%02x \"\n\t\t\t\"Emask 0x%x (%s)%s\\n\",\n\t\t\tcmd->command, cmd->feature, cmd->nsect,\n\t\t\tcmd->lbal, cmd->lbam, cmd->lbah,\n\t\t\tcmd->hob_feature, cmd->hob_nsect,\n\t\t\tcmd->hob_lbal, cmd->hob_lbam, cmd->hob_lbah,\n\t\t\tcmd->device, qc->tag, data_buf, cdb_buf,\n\t\t\tres->status, res->error, res->nsect,\n\t\t\tres->lbal, res->lbam, res->lbah,\n\t\t\tres->hob_feature, res->hob_nsect,\n\t\t\tres->hob_lbal, res->hob_lbam, res->hob_lbah,\n\t\t\tres->device, qc->err_mask, ata_err_string(qc->err_mask),\n\t\t\tqc->err_mask & AC_ERR_NCQ ? \" <F>\" : \"\");\n\n#ifdef CONFIG_ATA_VERBOSE_ERROR\n\t\tif (res->status & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ |\n\t\t\t\t   ATA_SENSE | ATA_ERR)) {\n\t\t\tif (res->status & ATA_BUSY)\n\t\t\t\tata_dev_err(qc->dev, \"status: { Busy }\\n\");\n\t\t\telse\n\t\t\t\tata_dev_err(qc->dev, \"status: { %s%s%s%s%s}\\n\",\n\t\t\t\t  res->status & ATA_DRDY ? \"DRDY \" : \"\",\n\t\t\t\t  res->status & ATA_DF ? \"DF \" : \"\",\n\t\t\t\t  res->status & ATA_DRQ ? \"DRQ \" : \"\",\n\t\t\t\t  res->status & ATA_SENSE ? \"SENSE \" : \"\",\n\t\t\t\t  res->status & ATA_ERR ? \"ERR \" : \"\");\n\t\t}\n\n\t\tif (cmd->command != ATA_CMD_PACKET &&\n\t\t    (res->error & (ATA_ICRC | ATA_UNC | ATA_AMNF | ATA_IDNF |\n\t\t\t\t   ATA_ABORTED)))\n\t\t\tata_dev_err(qc->dev, \"error: { %s%s%s%s%s}\\n\",\n\t\t\t\t    res->error & ATA_ICRC ? \"ICRC \" : \"\",\n\t\t\t\t    res->error & ATA_UNC ? \"UNC \" : \"\",\n\t\t\t\t    res->error & ATA_AMNF ? \"AMNF \" : \"\",\n\t\t\t\t    res->error & ATA_IDNF ? \"IDNF \" : \"\",\n\t\t\t\t    res->error & ATA_ABORTED ? \"ABRT \" : \"\");\n#endif\n\t}\n}\n\n \nvoid ata_eh_report(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\n\tata_for_each_link(link, ap, HOST_FIRST)\n\t\tata_eh_link_report(link);\n}\n\nstatic int ata_do_reset(struct ata_link *link, ata_reset_fn_t reset,\n\t\t\tunsigned int *classes, unsigned long deadline,\n\t\t\tbool clear_classes)\n{\n\tstruct ata_device *dev;\n\n\tif (clear_classes)\n\t\tata_for_each_dev(dev, link, ALL)\n\t\t\tclasses[dev->devno] = ATA_DEV_UNKNOWN;\n\n\treturn reset(link, classes, deadline);\n}\n\nstatic int ata_eh_followup_srst_needed(struct ata_link *link, int rc)\n{\n\tif ((link->flags & ATA_LFLAG_NO_SRST) || ata_link_offline(link))\n\t\treturn 0;\n\tif (rc == -EAGAIN)\n\t\treturn 1;\n\tif (sata_pmp_supported(link->ap) && ata_is_host_link(link))\n\t\treturn 1;\n\treturn 0;\n}\n\nint ata_eh_reset(struct ata_link *link, int classify,\n\t\t ata_prereset_fn_t prereset, ata_reset_fn_t softreset,\n\t\t ata_reset_fn_t hardreset, ata_postreset_fn_t postreset)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_link *slave = ap->slave_link;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_eh_context *sehc = slave ? &slave->eh_context : NULL;\n\tunsigned int *classes = ehc->classes;\n\tunsigned int lflags = link->flags;\n\tint verbose = !(ehc->i.flags & ATA_EHI_QUIET);\n\tint max_tries = 0, try = 0;\n\tstruct ata_link *failed_link;\n\tstruct ata_device *dev;\n\tunsigned long deadline, now;\n\tata_reset_fn_t reset;\n\tunsigned long flags;\n\tu32 sstatus;\n\tint nr_unknown, rc;\n\n\t \n\twhile (ata_eh_reset_timeouts[max_tries] != UINT_MAX)\n\t\tmax_tries++;\n\tif (link->flags & ATA_LFLAG_RST_ONCE)\n\t\tmax_tries = 1;\n\tif (link->flags & ATA_LFLAG_NO_HRST)\n\t\thardreset = NULL;\n\tif (link->flags & ATA_LFLAG_NO_SRST)\n\t\tsoftreset = NULL;\n\n\t \n\tif (ehc->i.flags & ATA_EHI_DID_RESET) {\n\t\tnow = jiffies;\n\t\tWARN_ON(time_after(ehc->last_reset, now));\n\t\tdeadline = ata_deadline(ehc->last_reset,\n\t\t\t\t\tATA_EH_RESET_COOL_DOWN);\n\t\tif (time_before(now, deadline))\n\t\t\tschedule_timeout_uninterruptible(deadline - now);\n\t}\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tap->pflags |= ATA_PFLAG_RESETTING;\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tata_eh_about_to_do(link, NULL, ATA_EH_RESET);\n\n\tata_for_each_dev(dev, link, ALL) {\n\t\t \n\t\tdev->pio_mode = XFER_PIO_0;\n\t\tdev->dma_mode = 0xff;\n\n\t\t \n\t\tif (ap->ops->set_piomode)\n\t\t\tap->ops->set_piomode(ap, dev);\n\t}\n\n\t \n\treset = NULL;\n\tehc->i.action &= ~ATA_EH_RESET;\n\tif (hardreset) {\n\t\treset = hardreset;\n\t\tehc->i.action |= ATA_EH_HARDRESET;\n\t} else if (softreset) {\n\t\treset = softreset;\n\t\tehc->i.action |= ATA_EH_SOFTRESET;\n\t}\n\n\tif (prereset) {\n\t\tunsigned long deadline = ata_deadline(jiffies,\n\t\t\t\t\t\t      ATA_EH_PRERESET_TIMEOUT);\n\n\t\tif (slave) {\n\t\t\tsehc->i.action &= ~ATA_EH_RESET;\n\t\t\tsehc->i.action |= ehc->i.action;\n\t\t}\n\n\t\trc = prereset(link, deadline);\n\n\t\t \n\t\tif (slave && (rc == 0 || rc == -ENOENT)) {\n\t\t\tint tmp;\n\n\t\t\ttmp = prereset(slave, deadline);\n\t\t\tif (tmp != -ENOENT)\n\t\t\t\trc = tmp;\n\n\t\t\tehc->i.action |= sehc->i.action;\n\t\t}\n\n\t\tif (rc) {\n\t\t\tif (rc == -ENOENT) {\n\t\t\t\tata_link_dbg(link, \"port disabled--ignoring\\n\");\n\t\t\t\tehc->i.action &= ~ATA_EH_RESET;\n\n\t\t\t\tata_for_each_dev(dev, link, ALL)\n\t\t\t\t\tclasses[dev->devno] = ATA_DEV_NONE;\n\n\t\t\t\trc = 0;\n\t\t\t} else\n\t\t\t\tata_link_err(link,\n\t\t\t\t\t     \"prereset failed (errno=%d)\\n\",\n\t\t\t\t\t     rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (reset && !(ehc->i.action & ATA_EH_RESET)) {\n\t\t\tata_for_each_dev(dev, link, ALL)\n\t\t\t\tclasses[dev->devno] = ATA_DEV_NONE;\n\t\t\tif (ata_port_is_frozen(ap) && ata_is_host_link(link))\n\t\t\t\tata_eh_thaw_port(ap);\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n retry:\n\t \n\tif (ata_is_host_link(link))\n\t\tata_eh_freeze_port(ap);\n\n\tdeadline = ata_deadline(jiffies, ata_eh_reset_timeouts[try++]);\n\n\tif (reset) {\n\t\tif (verbose)\n\t\t\tata_link_info(link, \"%s resetting link\\n\",\n\t\t\t\t      reset == softreset ? \"soft\" : \"hard\");\n\n\t\t \n\t\tehc->last_reset = jiffies;\n\t\tif (reset == hardreset) {\n\t\t\tehc->i.flags |= ATA_EHI_DID_HARDRESET;\n\t\t\ttrace_ata_link_hardreset_begin(link, classes, deadline);\n\t\t} else {\n\t\t\tehc->i.flags |= ATA_EHI_DID_SOFTRESET;\n\t\t\ttrace_ata_link_softreset_begin(link, classes, deadline);\n\t\t}\n\n\t\trc = ata_do_reset(link, reset, classes, deadline, true);\n\t\tif (reset == hardreset)\n\t\t\ttrace_ata_link_hardreset_end(link, classes, rc);\n\t\telse\n\t\t\ttrace_ata_link_softreset_end(link, classes, rc);\n\t\tif (rc && rc != -EAGAIN) {\n\t\t\tfailed_link = link;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tif (slave && reset == hardreset) {\n\t\t\tint tmp;\n\n\t\t\tif (verbose)\n\t\t\t\tata_link_info(slave, \"hard resetting link\\n\");\n\n\t\t\tata_eh_about_to_do(slave, NULL, ATA_EH_RESET);\n\t\t\ttrace_ata_slave_hardreset_begin(slave, classes,\n\t\t\t\t\t\t\tdeadline);\n\t\t\ttmp = ata_do_reset(slave, reset, classes, deadline,\n\t\t\t\t\t   false);\n\t\t\ttrace_ata_slave_hardreset_end(slave, classes, tmp);\n\t\t\tswitch (tmp) {\n\t\t\tcase -EAGAIN:\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfailed_link = slave;\n\t\t\t\trc = tmp;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (reset == hardreset &&\n\t\t    ata_eh_followup_srst_needed(link, rc)) {\n\t\t\treset = softreset;\n\n\t\t\tif (!reset) {\n\t\t\t\tata_link_err(link,\n\t     \"follow-up softreset required but no softreset available\\n\");\n\t\t\t\tfailed_link = link;\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tata_eh_about_to_do(link, NULL, ATA_EH_RESET);\n\t\t\ttrace_ata_link_softreset_begin(link, classes, deadline);\n\t\t\trc = ata_do_reset(link, reset, classes, deadline, true);\n\t\t\ttrace_ata_link_softreset_end(link, classes, rc);\n\t\t\tif (rc) {\n\t\t\t\tfailed_link = link;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (verbose)\n\t\t\tata_link_info(link,\n\t\"no reset method available, skipping reset\\n\");\n\t\tif (!(lflags & ATA_LFLAG_ASSUME_CLASS))\n\t\t\tlflags |= ATA_LFLAG_ASSUME_ATA;\n\t}\n\n\t \n\tata_for_each_dev(dev, link, ALL) {\n\t\t \n\t\tdev->pio_mode = XFER_PIO_0;\n\t\tdev->flags &= ~ATA_DFLAG_SLEEPING;\n\n\t\tif (ata_phys_link_offline(ata_dev_phys_link(dev)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (lflags & ATA_LFLAG_ASSUME_ATA)\n\t\t\tclasses[dev->devno] = ATA_DEV_ATA;\n\t\telse if (lflags & ATA_LFLAG_ASSUME_SEMB)\n\t\t\tclasses[dev->devno] = ATA_DEV_SEMB_UNSUP;\n\t}\n\n\t \n\tif (sata_scr_read(link, SCR_STATUS, &sstatus) == 0)\n\t\tlink->sata_spd = (sstatus >> 4) & 0xf;\n\tif (slave && sata_scr_read(slave, SCR_STATUS, &sstatus) == 0)\n\t\tslave->sata_spd = (sstatus >> 4) & 0xf;\n\n\t \n\tif (ata_is_host_link(link))\n\t\tata_eh_thaw_port(ap);\n\n\t \n\tif (postreset) {\n\t\tpostreset(link, classes);\n\t\ttrace_ata_link_postreset(link, classes, rc);\n\t\tif (slave) {\n\t\t\tpostreset(slave, classes);\n\t\t\ttrace_ata_slave_postreset(slave, classes, rc);\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(link->ap->lock, flags);\n\tlink->eh_info.serror = 0;\n\tif (slave)\n\t\tslave->eh_info.serror = 0;\n\tspin_unlock_irqrestore(link->ap->lock, flags);\n\n\t \n\tnr_unknown = 0;\n\tata_for_each_dev(dev, link, ALL) {\n\t\tif (ata_phys_link_online(ata_dev_phys_link(dev))) {\n\t\t\tif (classes[dev->devno] == ATA_DEV_UNKNOWN) {\n\t\t\t\tata_dev_dbg(dev, \"link online but device misclassified\\n\");\n\t\t\t\tclasses[dev->devno] = ATA_DEV_NONE;\n\t\t\t\tnr_unknown++;\n\t\t\t}\n\t\t} else if (ata_phys_link_offline(ata_dev_phys_link(dev))) {\n\t\t\tif (ata_class_enabled(classes[dev->devno]))\n\t\t\t\tata_dev_dbg(dev,\n\t\t\t\t\t    \"link offline, clearing class %d to NONE\\n\",\n\t\t\t\t\t    classes[dev->devno]);\n\t\t\tclasses[dev->devno] = ATA_DEV_NONE;\n\t\t} else if (classes[dev->devno] == ATA_DEV_UNKNOWN) {\n\t\t\tata_dev_dbg(dev,\n\t\t\t\t    \"link status unknown, clearing UNKNOWN to NONE\\n\");\n\t\t\tclasses[dev->devno] = ATA_DEV_NONE;\n\t\t}\n\t}\n\n\tif (classify && nr_unknown) {\n\t\tif (try < max_tries) {\n\t\t\tata_link_warn(link,\n\t\t\t\t      \"link online but %d devices misclassified, retrying\\n\",\n\t\t\t\t      nr_unknown);\n\t\t\tfailed_link = link;\n\t\t\trc = -EAGAIN;\n\t\t\tgoto fail;\n\t\t}\n\t\tata_link_warn(link,\n\t\t\t      \"link online but %d devices misclassified, \"\n\t\t\t      \"device detection might fail\\n\", nr_unknown);\n\t}\n\n\t \n\tata_eh_done(link, NULL, ATA_EH_RESET);\n\tif (slave)\n\t\tata_eh_done(slave, NULL, ATA_EH_RESET);\n\tehc->last_reset = jiffies;\t\t \n\tehc->i.action |= ATA_EH_REVALIDATE;\n\tlink->lpm_policy = ATA_LPM_UNKNOWN;\t \n\n\trc = 0;\n out:\n\t \n\tehc->i.flags &= ~ATA_EHI_HOTPLUGGED;\n\tif (slave)\n\t\tsehc->i.flags &= ~ATA_EHI_HOTPLUGGED;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tap->pflags &= ~ATA_PFLAG_RESETTING;\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn rc;\n\n fail:\n\t \n\tif (!ata_is_host_link(link) &&\n\t    sata_scr_read(link, SCR_STATUS, &sstatus))\n\t\trc = -ERESTART;\n\n\tif (try >= max_tries) {\n\t\t \n\t\tif (ata_is_host_link(link))\n\t\t\tata_eh_thaw_port(ap);\n\t\tgoto out;\n\t}\n\n\tnow = jiffies;\n\tif (time_before(now, deadline)) {\n\t\tunsigned long delta = deadline - now;\n\n\t\tata_link_warn(failed_link,\n\t\t\t\"reset failed (errno=%d), retrying in %u secs\\n\",\n\t\t\trc, DIV_ROUND_UP(jiffies_to_msecs(delta), 1000));\n\n\t\tata_eh_release(ap);\n\t\twhile (delta)\n\t\t\tdelta = schedule_timeout_uninterruptible(delta);\n\t\tata_eh_acquire(ap);\n\t}\n\n\t \n\tif (rc == -ERESTART) {\n\t\tif (ata_is_host_link(link))\n\t\t\tata_eh_thaw_port(ap);\n\t\tgoto out;\n\t}\n\n\tif (try == max_tries - 1) {\n\t\tsata_down_spd_limit(link, 0);\n\t\tif (slave)\n\t\t\tsata_down_spd_limit(slave, 0);\n\t} else if (rc == -EPIPE)\n\t\tsata_down_spd_limit(failed_link, 0);\n\n\tif (hardreset)\n\t\treset = hardreset;\n\tgoto retry;\n}\n\nstatic inline void ata_eh_pull_park_action(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(ap->lock, flags);\n\treinit_completion(&ap->park_req_pending);\n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\tstruct ata_eh_info *ehi = &link->eh_info;\n\n\t\t\tlink->eh_context.i.dev_action[dev->devno] |=\n\t\t\t\tehi->dev_action[dev->devno] & ATA_EH_PARK;\n\t\t\tata_eh_clear_action(link, dev, ehi, ATA_EH_PARK);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n\nstatic void ata_eh_park_issue_cmd(struct ata_device *dev, int park)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\n\tata_tf_init(dev, &tf);\n\tif (park) {\n\t\tehc->unloaded_mask |= 1 << dev->devno;\n\t\ttf.command = ATA_CMD_IDLEIMMEDIATE;\n\t\ttf.feature = 0x44;\n\t\ttf.lbal = 0x4c;\n\t\ttf.lbam = 0x4e;\n\t\ttf.lbah = 0x55;\n\t} else {\n\t\tehc->unloaded_mask &= ~(1 << dev->devno);\n\t\ttf.command = ATA_CMD_CHK_POWER;\n\t}\n\n\ttf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\ttf.protocol = ATA_PROT_NODATA;\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\tif (park && (err_mask || tf.lbal != 0xc4)) {\n\t\tata_dev_err(dev, \"head unload failed!\\n\");\n\t\tehc->unloaded_mask &= ~(1 << dev->devno);\n\t}\n}\n\nstatic int ata_eh_revalidate_and_attach(struct ata_link *link,\n\t\t\t\t\tstruct ata_device **r_failed_dev)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_device *dev;\n\tunsigned int new_mask = 0;\n\tunsigned long flags;\n\tint rc = 0;\n\n\t \n\tata_for_each_dev(dev, link, ALL_REVERSE) {\n\t\tunsigned int action = ata_eh_dev_action(dev);\n\t\tunsigned int readid_flags = 0;\n\n\t\tif (ehc->i.flags & ATA_EHI_DID_RESET)\n\t\t\treadid_flags |= ATA_READID_POSTRESET;\n\n\t\t \n\t\tif ((action & ATA_EH_SET_ACTIVE) && ata_dev_enabled(dev)) {\n\t\t\tata_dev_power_set_active(dev);\n\t\t\tata_eh_done(link, dev, ATA_EH_SET_ACTIVE);\n\t\t}\n\n\t\tif ((action & ATA_EH_REVALIDATE) && ata_dev_enabled(dev)) {\n\t\t\tWARN_ON(dev->class == ATA_DEV_PMP);\n\n\t\t\t \n\t\t\tif (link->lpm_policy > ATA_LPM_MAX_POWER) {\n\t\t\t\trc = ata_eh_set_lpm(link, ATA_LPM_MAX_POWER,\n\t\t\t\t\t\t    r_failed_dev);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (ata_phys_link_offline(ata_dev_phys_link(dev))) {\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tata_eh_about_to_do(link, dev, ATA_EH_REVALIDATE);\n\t\t\trc = ata_dev_revalidate(dev, ehc->classes[dev->devno],\n\t\t\t\t\t\treadid_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\n\t\t\tata_eh_done(link, dev, ATA_EH_REVALIDATE);\n\n\t\t\t \n\t\t\tehc->i.flags |= ATA_EHI_SETMODE;\n\n\t\t\t \n\t\t\tschedule_delayed_work(&ap->scsi_rescan_task, 0);\n\t\t} else if (dev->class == ATA_DEV_UNKNOWN &&\n\t\t\t   ehc->tries[dev->devno] &&\n\t\t\t   ata_class_enabled(ehc->classes[dev->devno])) {\n\t\t\t \n\t\t\tdev->class = ehc->classes[dev->devno];\n\n\t\t\tif (dev->class == ATA_DEV_PMP)\n\t\t\t\trc = sata_pmp_attach(dev);\n\t\t\telse\n\t\t\t\trc = ata_dev_read_id(dev, &dev->class,\n\t\t\t\t\t\t     readid_flags, dev->id);\n\n\t\t\t \n\t\t\tehc->classes[dev->devno] = dev->class;\n\t\t\tdev->class = ATA_DEV_UNKNOWN;\n\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tata_ering_clear(&dev->ering);\n\t\t\t\tnew_mask |= 1 << dev->devno;\n\t\t\t\tbreak;\n\t\t\tcase -ENOENT:\n\t\t\t\t \n\t\t\t\tata_eh_thaw_port(ap);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((ehc->i.flags & ATA_EHI_DID_RESET) && ata_is_host_link(link)) {\n\t\tif (ap->ops->cable_detect)\n\t\t\tap->cbl = ap->ops->cable_detect(ap);\n\t\tata_force_cbl(ap);\n\t}\n\n\t \n\tata_for_each_dev(dev, link, ALL) {\n\t\tif (!(new_mask & (1 << dev->devno)))\n\t\t\tcontinue;\n\n\t\tdev->class = ehc->classes[dev->devno];\n\n\t\tif (dev->class == ATA_DEV_PMP)\n\t\t\tcontinue;\n\n\t\tehc->i.flags |= ATA_EHI_PRINTINFO;\n\t\trc = ata_dev_configure(dev);\n\t\tehc->i.flags &= ~ATA_EHI_PRINTINFO;\n\t\tif (rc) {\n\t\t\tdev->class = ATA_DEV_UNKNOWN;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t\tap->pflags |= ATA_PFLAG_SCSI_HOTPLUG;\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t\t \n\t\tehc->i.flags |= ATA_EHI_SETMODE;\n\t}\n\n\treturn 0;\n\n err:\n\t*r_failed_dev = dev;\n\treturn rc;\n}\n\n \nint ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *dev;\n\tint rc;\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tif (!(dev->flags & ATA_DFLAG_DUBIOUS_XFER)) {\n\t\t\tstruct ata_ering_entry *ent;\n\n\t\t\tent = ata_ering_top(&dev->ering);\n\t\t\tif (ent)\n\t\t\t\tent->eflags &= ~ATA_EFLAG_DUBIOUS_XFER;\n\t\t}\n\t}\n\n\t \n\tif (ap->ops->set_mode)\n\t\trc = ap->ops->set_mode(link, r_failed_dev);\n\telse\n\t\trc = ata_do_set_mode(link, r_failed_dev);\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\t\tu8 saved_xfer_mode = ehc->saved_xfer_mode[dev->devno];\n\t\tu8 saved_ncq = !!(ehc->saved_ncq_enabled & (1 << dev->devno));\n\n\t\tif (dev->xfer_mode != saved_xfer_mode ||\n\t\t    ata_ncq_enabled(dev) != saved_ncq)\n\t\t\tdev->flags |= ATA_DFLAG_DUBIOUS_XFER;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int atapi_eh_clear_ua(struct ata_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ATA_EH_UA_TRIES; i++) {\n\t\tu8 *sense_buffer = dev->link->ap->sector_buf;\n\t\tu8 sense_key = 0;\n\t\tunsigned int err_mask;\n\n\t\terr_mask = atapi_eh_tur(dev, &sense_key);\n\t\tif (err_mask != 0 && err_mask != AC_ERR_DEV) {\n\t\t\tata_dev_warn(dev,\n\t\t\t\t     \"TEST_UNIT_READY failed (err_mask=0x%x)\\n\",\n\t\t\t\t     err_mask);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (!err_mask || sense_key != UNIT_ATTENTION)\n\t\t\treturn 0;\n\n\t\terr_mask = atapi_eh_request_sense(dev, sense_buffer, sense_key);\n\t\tif (err_mask) {\n\t\t\tata_dev_warn(dev, \"failed to clear \"\n\t\t\t\t\"UNIT ATTENTION (err_mask=0x%x)\\n\", err_mask);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tata_dev_warn(dev, \"UNIT ATTENTION persists after %d tries\\n\",\n\t\t     ATA_EH_UA_TRIES);\n\n\treturn 0;\n}\n\n \nstatic int ata_eh_maybe_retry_flush(struct ata_device *dev)\n{\n\tstruct ata_link *link = dev->link;\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_queued_cmd *qc;\n\tstruct ata_taskfile tf;\n\tunsigned int err_mask;\n\tint rc = 0;\n\n\t \n\tif (!ata_tag_valid(link->active_tag))\n\t\treturn 0;\n\n\tqc = __ata_qc_from_tag(ap, link->active_tag);\n\tif (qc->dev != dev || (qc->tf.command != ATA_CMD_FLUSH_EXT &&\n\t\t\t       qc->tf.command != ATA_CMD_FLUSH))\n\t\treturn 0;\n\n\t \n\tif (qc->err_mask & AC_ERR_DEV)\n\t\treturn 0;\n\n\t \n\tata_tf_init(dev, &tf);\n\n\ttf.command = qc->tf.command;\n\ttf.flags |= ATA_TFLAG_DEVICE;\n\ttf.protocol = ATA_PROT_NODATA;\n\n\tata_dev_warn(dev, \"retrying FLUSH 0x%x Emask 0x%x\\n\",\n\t\t       tf.command, qc->err_mask);\n\n\terr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\n\tif (!err_mask) {\n\t\t \n\t\tqc->scsicmd->allowed = max(qc->scsicmd->allowed, 1);\n\t} else {\n\t\tata_dev_warn(dev, \"FLUSH failed Emask 0x%x\\n\",\n\t\t\t       err_mask);\n\t\trc = -EIO;\n\n\t\t \n\t\tif (err_mask & AC_ERR_DEV) {\n\t\t\tqc->err_mask |= AC_ERR_DEV;\n\t\t\tqc->result_tf = tf;\n\t\t\tif (!ata_port_is_frozen(ap))\n\t\t\t\trc = 0;\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nstatic int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\n\t\t\t  struct ata_device **r_failed_dev)\n{\n\tstruct ata_port *ap = ata_is_host_link(link) ? link->ap : NULL;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_device *dev, *link_dev = NULL, *lpm_dev = NULL;\n\tenum ata_lpm_policy old_policy = link->lpm_policy;\n\tbool no_dipm = link->ap->flags & ATA_FLAG_NO_DIPM;\n\tunsigned int hints = ATA_LPM_EMPTY | ATA_LPM_HIPM;\n\tunsigned int err_mask;\n\tint rc;\n\n\t \n\tif (!IS_ENABLED(CONFIG_SATA_HOST) ||\n\t    (link->flags & ATA_LFLAG_NO_LPM) || (ap && !ap->ops->set_lpm))\n\t\treturn 0;\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tbool hipm = ata_id_has_hipm(dev->id);\n\t\tbool dipm = ata_id_has_dipm(dev->id) && !no_dipm;\n\n\t\t \n\t\tif (!link_dev)\n\t\t\tlink_dev = dev;\n\n\t\tif (!lpm_dev && (hipm || dipm))\n\t\t\tlpm_dev = dev;\n\n\t\thints &= ~ATA_LPM_EMPTY;\n\t\tif (!hipm)\n\t\t\thints &= ~ATA_LPM_HIPM;\n\n\t\t \n\t\tif (policy < ATA_LPM_MED_POWER_WITH_DIPM && dipm) {\n\t\t\terr_mask = ata_dev_set_feature(dev,\n\t\t\t\t\tSETFEATURES_SATA_DISABLE, SATA_DIPM);\n\t\t\tif (err_mask && err_mask != AC_ERR_DEV) {\n\t\t\t\tata_dev_warn(dev,\n\t\t\t\t\t     \"failed to disable DIPM, Emask 0x%x\\n\",\n\t\t\t\t\t     err_mask);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ap) {\n\t\trc = ap->ops->set_lpm(link, policy, hints);\n\t\tif (!rc && ap->slave_link)\n\t\t\trc = ap->ops->set_lpm(ap->slave_link, policy, hints);\n\t} else\n\t\trc = sata_pmp_set_lpm(link, policy, hints);\n\n\t \n\tif (rc) {\n\t\tif (rc == -EOPNOTSUPP) {\n\t\t\tlink->flags |= ATA_LFLAG_NO_LPM;\n\t\t\treturn 0;\n\t\t}\n\t\tdev = lpm_dev ? lpm_dev : link_dev;\n\t\tgoto fail;\n\t}\n\n\t \n\tlink->lpm_policy = policy;\n\tif (ap && ap->slave_link)\n\t\tap->slave_link->lpm_policy = policy;\n\n\t \n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tif (policy >= ATA_LPM_MED_POWER_WITH_DIPM && !no_dipm &&\n\t\t    ata_id_has_dipm(dev->id)) {\n\t\t\terr_mask = ata_dev_set_feature(dev,\n\t\t\t\t\tSETFEATURES_SATA_ENABLE, SATA_DIPM);\n\t\t\tif (err_mask && err_mask != AC_ERR_DEV) {\n\t\t\t\tata_dev_warn(dev,\n\t\t\t\t\t\"failed to enable DIPM, Emask 0x%x\\n\",\n\t\t\t\t\terr_mask);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tlink->last_lpm_change = jiffies;\n\tlink->flags |= ATA_LFLAG_CHANGED;\n\n\treturn 0;\n\nfail:\n\t \n\tlink->lpm_policy = old_policy;\n\tif (ap && ap->slave_link)\n\t\tap->slave_link->lpm_policy = old_policy;\n\n\t \n\tif (!dev || ehc->tries[dev->devno] <= 2) {\n\t\tata_link_warn(link, \"disabling LPM on the link\\n\");\n\t\tlink->flags |= ATA_LFLAG_NO_LPM;\n\t}\n\tif (r_failed_dev)\n\t\t*r_failed_dev = dev;\n\treturn rc;\n}\n\nint ata_link_nr_enabled(struct ata_link *link)\n{\n\tstruct ata_device *dev;\n\tint cnt = 0;\n\n\tata_for_each_dev(dev, link, ENABLED)\n\t\tcnt++;\n\treturn cnt;\n}\n\nstatic int ata_link_nr_vacant(struct ata_link *link)\n{\n\tstruct ata_device *dev;\n\tint cnt = 0;\n\n\tata_for_each_dev(dev, link, ALL)\n\t\tif (dev->class == ATA_DEV_UNKNOWN)\n\t\t\tcnt++;\n\treturn cnt;\n}\n\nstatic int ata_eh_skip_recovery(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_eh_context *ehc = &link->eh_context;\n\tstruct ata_device *dev;\n\n\t \n\tif (link->flags & ATA_LFLAG_DISABLED)\n\t\treturn 1;\n\n\t \n\tif (ehc->i.flags & ATA_EHI_NO_RECOVERY)\n\t\treturn 1;\n\n\t \n\tif (ata_port_is_frozen(ap) || ata_link_nr_enabled(link))\n\t\treturn 0;\n\n\t \n\tif ((ehc->i.action & ATA_EH_RESET) &&\n\t    !(ehc->i.flags & ATA_EHI_DID_RESET))\n\t\treturn 0;\n\n\t \n\tata_for_each_dev(dev, link, ALL) {\n\t\tif (dev->class == ATA_DEV_UNKNOWN &&\n\t\t    ehc->classes[dev->devno] != ATA_DEV_NONE)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int ata_count_probe_trials_cb(struct ata_ering_entry *ent, void *void_arg)\n{\n\tu64 interval = msecs_to_jiffies(ATA_EH_PROBE_TRIAL_INTERVAL);\n\tu64 now = get_jiffies_64();\n\tint *trials = void_arg;\n\n\tif ((ent->eflags & ATA_EFLAG_OLD_ER) ||\n\t    (ent->timestamp < now - min(now, interval)))\n\t\treturn -1;\n\n\t(*trials)++;\n\treturn 0;\n}\n\nstatic int ata_eh_schedule_probe(struct ata_device *dev)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\tstruct ata_link *link = ata_dev_phys_link(dev);\n\tint trials = 0;\n\n\tif (!(ehc->i.probe_mask & (1 << dev->devno)) ||\n\t    (ehc->did_probe_mask & (1 << dev->devno)))\n\t\treturn 0;\n\n\tata_eh_detach_dev(dev);\n\tata_dev_init(dev);\n\tehc->did_probe_mask |= (1 << dev->devno);\n\tehc->i.action |= ATA_EH_RESET;\n\tehc->saved_xfer_mode[dev->devno] = 0;\n\tehc->saved_ncq_enabled &= ~(1 << dev->devno);\n\n\t \n\tif (link->lpm_policy > ATA_LPM_MAX_POWER) {\n\t\tif (ata_is_host_link(link))\n\t\t\tlink->ap->ops->set_lpm(link, ATA_LPM_MAX_POWER,\n\t\t\t\t\t       ATA_LPM_EMPTY);\n\t\telse\n\t\t\tsata_pmp_set_lpm(link, ATA_LPM_MAX_POWER,\n\t\t\t\t\t ATA_LPM_EMPTY);\n\t}\n\n\t \n\tata_ering_record(&dev->ering, 0, AC_ERR_OTHER);\n\tata_ering_map(&dev->ering, ata_count_probe_trials_cb, &trials);\n\n\tif (trials > ATA_EH_PROBE_TRIALS)\n\t\tsata_down_spd_limit(link, 1);\n\n\treturn 1;\n}\n\nstatic int ata_eh_handle_dev_fail(struct ata_device *dev, int err)\n{\n\tstruct ata_eh_context *ehc = &dev->link->eh_context;\n\n\t \n\tif (err != -EAGAIN)\n\t\tehc->tries[dev->devno]--;\n\n\tswitch (err) {\n\tcase -ENODEV:\n\t\t \n\t\tehc->i.probe_mask |= (1 << dev->devno);\n\t\tfallthrough;\n\tcase -EINVAL:\n\t\t \n\t\tehc->tries[dev->devno] = min(ehc->tries[dev->devno], 1);\n\t\tfallthrough;\n\tcase -EIO:\n\t\tif (ehc->tries[dev->devno] == 1) {\n\t\t\t \n\t\t\tsata_down_spd_limit(ata_dev_phys_link(dev), 0);\n\t\t\tif (dev->pio_mode > XFER_PIO_0)\n\t\t\t\tata_down_xfermask_limit(dev, ATA_DNXFER_PIO);\n\t\t}\n\t}\n\n\tif (ata_dev_enabled(dev) && !ehc->tries[dev->devno]) {\n\t\t \n\t\tata_dev_disable(dev);\n\n\t\t \n\t\tif (ata_phys_link_offline(ata_dev_phys_link(dev)))\n\t\t\tata_eh_detach_dev(dev);\n\n\t\t \n\t\tif (ata_eh_schedule_probe(dev)) {\n\t\t\tehc->tries[dev->devno] = ATA_EH_DEV_TRIES;\n\t\t\tmemset(ehc->cmd_timeout_idx[dev->devno], 0,\n\t\t\t       sizeof(ehc->cmd_timeout_idx[dev->devno]));\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tehc->i.action |= ATA_EH_RESET;\n\t\treturn 0;\n\t}\n}\n\n \nint ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,\n\t\t   ata_reset_fn_t softreset, ata_reset_fn_t hardreset,\n\t\t   ata_postreset_fn_t postreset,\n\t\t   struct ata_link **r_failed_link)\n{\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tint rc, nr_fails;\n\tunsigned long flags, deadline;\n\n\t \n\tata_for_each_link(link, ap, EDGE) {\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\n\t\t \n\t\tif (ehc->i.action & ATA_EH_ENABLE_LINK) {\n\t\t\tata_eh_about_to_do(link, NULL, ATA_EH_ENABLE_LINK);\n\t\t\tspin_lock_irqsave(ap->lock, flags);\n\t\t\tlink->flags &= ~ATA_LFLAG_DISABLED;\n\t\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\t\tata_eh_done(link, NULL, ATA_EH_ENABLE_LINK);\n\t\t}\n\n\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\tif (link->flags & ATA_LFLAG_NO_RETRY)\n\t\t\t\tehc->tries[dev->devno] = 1;\n\t\t\telse\n\t\t\t\tehc->tries[dev->devno] = ATA_EH_DEV_TRIES;\n\n\t\t\t \n\t\t\tehc->i.action |= ehc->i.dev_action[dev->devno] &\n\t\t\t\t\t ~ATA_EH_PERDEV_MASK;\n\t\t\tehc->i.dev_action[dev->devno] &= ATA_EH_PERDEV_MASK;\n\n\t\t\t \n\t\t\tif (dev->flags & ATA_DFLAG_DETACH)\n\t\t\t\tata_eh_detach_dev(dev);\n\n\t\t\t \n\t\t\tif (!ata_dev_enabled(dev))\n\t\t\t\tata_eh_schedule_probe(dev);\n\t\t}\n\t}\n\n retry:\n\trc = 0;\n\n\t \n\tif (ap->pflags & ATA_PFLAG_UNLOADING)\n\t\tgoto out;\n\n\t \n\tata_for_each_link(link, ap, EDGE) {\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\n\t\t \n\t\tif (ata_eh_skip_recovery(link))\n\t\t\tehc->i.action = 0;\n\n\t\tata_for_each_dev(dev, link, ALL)\n\t\t\tehc->classes[dev->devno] = ATA_DEV_UNKNOWN;\n\t}\n\n\t \n\tata_for_each_link(link, ap, EDGE) {\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\n\t\tif (!(ehc->i.action & ATA_EH_RESET))\n\t\t\tcontinue;\n\n\t\trc = ata_eh_reset(link, ata_link_nr_vacant(link),\n\t\t\t\t  prereset, softreset, hardreset, postreset);\n\t\tif (rc) {\n\t\t\tata_link_err(link, \"reset failed, giving up\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdo {\n\t\tunsigned long now;\n\n\t\t \n\t\tata_eh_pull_park_action(ap);\n\n\t\tdeadline = jiffies;\n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\t\t\t\tunsigned long tmp;\n\n\t\t\t\tif (dev->class != ATA_DEV_ATA &&\n\t\t\t\t    dev->class != ATA_DEV_ZAC)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!(ehc->i.dev_action[dev->devno] &\n\t\t\t\t      ATA_EH_PARK))\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp = dev->unpark_deadline;\n\t\t\t\tif (time_before(deadline, tmp))\n\t\t\t\t\tdeadline = tmp;\n\t\t\t\telse if (time_before_eq(tmp, jiffies))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ehc->unloaded_mask & (1 << dev->devno))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tata_eh_park_issue_cmd(dev, 1);\n\t\t\t}\n\t\t}\n\n\t\tnow = jiffies;\n\t\tif (time_before_eq(deadline, now))\n\t\t\tbreak;\n\n\t\tata_eh_release(ap);\n\t\tdeadline = wait_for_completion_timeout(&ap->park_req_pending,\n\t\t\t\t\t\t       deadline - now);\n\t\tata_eh_acquire(ap);\n\t} while (deadline);\n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\tif (!(link->eh_context.unloaded_mask &\n\t\t\t      (1 << dev->devno)))\n\t\t\t\tcontinue;\n\n\t\t\tata_eh_park_issue_cmd(dev, 0);\n\t\t\tata_eh_done(link, dev, ATA_EH_PARK);\n\t\t}\n\t}\n\n\t \n\tnr_fails = 0;\n\tata_for_each_link(link, ap, PMP_FIRST) {\n\t\tstruct ata_eh_context *ehc = &link->eh_context;\n\n\t\tif (sata_pmp_attached(ap) && ata_is_host_link(link))\n\t\t\tgoto config_lpm;\n\n\t\t \n\t\trc = ata_eh_revalidate_and_attach(link, &dev);\n\t\tif (rc)\n\t\t\tgoto rest_fail;\n\n\t\t \n\t\tif (link->device->class == ATA_DEV_PMP) {\n\t\t\tehc->i.action = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (ehc->i.flags & ATA_EHI_SETMODE) {\n\t\t\trc = ata_set_mode(link, &dev);\n\t\t\tif (rc)\n\t\t\t\tgoto rest_fail;\n\t\t\tehc->i.flags &= ~ATA_EHI_SETMODE;\n\t\t}\n\n\t\t \n\t\tif (ehc->i.flags & ATA_EHI_DID_RESET) {\n\t\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\t\tif (dev->class != ATA_DEV_ATAPI)\n\t\t\t\t\tcontinue;\n\t\t\t\trc = atapi_eh_clear_ua(dev);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto rest_fail;\n\t\t\t\tif (zpodd_dev_enabled(dev))\n\t\t\t\t\tzpodd_post_poweron(dev);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tata_for_each_dev(dev, link, ALL) {\n\t\t\tif (dev->class != ATA_DEV_ATA &&\n\t\t\t    dev->class != ATA_DEV_ZAC)\n\t\t\t\tcontinue;\n\t\t\trc = ata_eh_maybe_retry_flush(dev);\n\t\t\tif (rc)\n\t\t\t\tgoto rest_fail;\n\t\t}\n\n\tconfig_lpm:\n\t\t \n\t\tif (link->lpm_policy != ap->target_lpm_policy) {\n\t\t\trc = ata_eh_set_lpm(link, ap->target_lpm_policy, &dev);\n\t\t\tif (rc)\n\t\t\t\tgoto rest_fail;\n\t\t}\n\n\t\t \n\t\tehc->i.flags = 0;\n\t\tcontinue;\n\n\trest_fail:\n\t\tnr_fails++;\n\t\tif (dev)\n\t\t\tata_eh_handle_dev_fail(dev, rc);\n\n\t\tif (ata_port_is_frozen(ap)) {\n\t\t\t \n\t\t\tif (sata_pmp_attached(ap))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (nr_fails)\n\t\tgoto retry;\n\n out:\n\tif (rc && r_failed_link)\n\t\t*r_failed_link = link;\n\n\treturn rc;\n}\n\n \nvoid ata_eh_finish(struct ata_port *ap)\n{\n\tstruct ata_queued_cmd *qc;\n\tint tag;\n\n\t \n\tata_qc_for_each_raw(ap, qc, tag) {\n\t\tif (!(qc->flags & ATA_QCFLAG_EH))\n\t\t\tcontinue;\n\n\t\tif (qc->err_mask) {\n\t\t\t \n\t\t\tif (qc->flags & ATA_QCFLAG_RETRY) {\n\t\t\t\t \n\t\t\t\tata_eh_qc_retry(qc);\n\t\t\t} else {\n\t\t\t\tata_eh_qc_complete(qc);\n\t\t\t}\n\t\t} else {\n\t\t\tif (qc->flags & ATA_QCFLAG_SENSE_VALID ||\n\t\t\t    qc->flags & ATA_QCFLAG_EH_SUCCESS_CMD) {\n\t\t\t\tata_eh_qc_complete(qc);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmemset(&qc->result_tf, 0, sizeof(qc->result_tf));\n\t\t\t\t \n\t\t\t\tata_eh_qc_retry(qc);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tWARN_ON(ap->nr_active_links);\n\tap->nr_active_links = 0;\n}\n\n \nvoid ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,\n\t       ata_reset_fn_t softreset, ata_reset_fn_t hardreset,\n\t       ata_postreset_fn_t postreset)\n{\n\tstruct ata_device *dev;\n\tint rc;\n\n\tata_eh_autopsy(ap);\n\tata_eh_report(ap);\n\n\trc = ata_eh_recover(ap, prereset, softreset, hardreset, postreset,\n\t\t\t    NULL);\n\tif (rc) {\n\t\tata_for_each_dev(dev, &ap->link, ALL)\n\t\t\tata_dev_disable(dev);\n\t}\n\n\tata_eh_finish(ap);\n}\n\n \nvoid ata_std_error_handler(struct ata_port *ap)\n{\n\tstruct ata_port_operations *ops = ap->ops;\n\tata_reset_fn_t hardreset = ops->hardreset;\n\n\t \n\tif (hardreset == sata_std_hardreset && !sata_scr_valid(&ap->link))\n\t\thardreset = NULL;\n\n\tata_do_eh(ap, ops->prereset, ops->softreset, hardreset, ops->postreset);\n}\nEXPORT_SYMBOL_GPL(ata_std_error_handler);\n\n#ifdef CONFIG_PM\n \nstatic void ata_eh_handle_port_suspend(struct ata_port *ap)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\tstruct ata_device *dev;\n\tstruct ata_link *link;\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\tif (!(ap->pflags & ATA_PFLAG_PM_PENDING) ||\n\t    ap->pm_mesg.event & PM_EVENT_RESUME) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tWARN_ON(ap->pflags & ATA_PFLAG_SUSPENDED);\n\n\t \n\tata_for_each_link(link, ap, HOST_FIRST) {\n\t\tata_for_each_dev(dev, link, ENABLED)\n\t\t\tata_dev_power_set_standby(dev);\n\t}\n\n\t \n\tif (PMSG_IS_AUTO(ap->pm_mesg)) {\n\t\tata_for_each_dev(dev, &ap->link, ENABLED) {\n\t\t\tif (zpodd_dev_enabled(dev))\n\t\t\t\tzpodd_on_suspend(dev);\n\t\t}\n\t}\n\n\t \n\tata_eh_freeze_port(ap);\n\n\tif (ap->ops->port_suspend)\n\t\trc = ap->ops->port_suspend(ap, ap->pm_mesg);\n\n\tata_acpi_set_state(ap, ap->pm_mesg);\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\n\tap->pflags &= ~ATA_PFLAG_PM_PENDING;\n\tif (rc == 0)\n\t\tap->pflags |= ATA_PFLAG_SUSPENDED;\n\telse if (ata_port_is_frozen(ap))\n\t\tata_port_schedule_eh(ap);\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn;\n}\n\n \nstatic void ata_eh_handle_port_resume(struct ata_port *ap)\n{\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\tif (!(ap->pflags & ATA_PFLAG_PM_PENDING) ||\n\t    !(ap->pm_mesg.event & PM_EVENT_RESUME)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tWARN_ON(!(ap->pflags & ATA_PFLAG_SUSPENDED));\n\n\t \n\tata_for_each_link(link, ap, HOST_FIRST)\n\t\tata_for_each_dev(dev, link, ALL)\n\t\t\tata_ering_clear(&dev->ering);\n\n\tata_acpi_set_state(ap, ap->pm_mesg);\n\n\tif (ap->ops->port_resume)\n\t\tap->ops->port_resume(ap);\n\n\t \n\tata_acpi_on_resume(ap);\n\n\t \n\tspin_lock_irqsave(ap->lock, flags);\n\tap->pflags &= ~(ATA_PFLAG_PM_PENDING | ATA_PFLAG_SUSPENDED);\n\tap->pflags |= ATA_PFLAG_RESUMING;\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}