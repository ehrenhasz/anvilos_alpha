{
  "module_name": "ahci_mtk.c",
  "hash_id": "e779186c7e321c84071fee95a65f61a64bb97fdaded8152ad8cdebf8127bb9c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/ahci_mtk.c",
  "human_readable_source": "\n \n\n#include <linux/ahci_platform.h>\n#include <linux/kernel.h>\n#include <linux/libata.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include \"ahci.h\"\n\n#define DRV_NAME\t\t\"ahci-mtk\"\n\n#define SYS_CFG\t\t\t0x14\n#define SYS_CFG_SATA_MSK\tGENMASK(31, 30)\n#define SYS_CFG_SATA_EN\t\tBIT(31)\n\nstruct mtk_ahci_plat {\n\tstruct regmap *mode;\n\tstruct reset_control *axi_rst;\n\tstruct reset_control *sw_rst;\n\tstruct reset_control *reg_rst;\n};\n\nstatic const struct ata_port_info ahci_port_info = {\n\t.flags\t\t= AHCI_FLAG_COMMON,\n\t.pio_mask\t= ATA_PIO4,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ahci_platform_ops,\n};\n\nstatic const struct scsi_host_template ahci_platform_sht = {\n\tAHCI_SHT(DRV_NAME),\n};\n\nstatic int mtk_ahci_platform_resets(struct ahci_host_priv *hpriv,\n\t\t\t\t    struct device *dev)\n{\n\tstruct mtk_ahci_plat *plat = hpriv->plat_data;\n\tint err;\n\n\t \n\tplat->axi_rst = devm_reset_control_get_optional_exclusive(dev, \"axi\");\n\tif (PTR_ERR(plat->axi_rst) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(plat->axi_rst);\n\n\tplat->sw_rst = devm_reset_control_get_optional_exclusive(dev, \"sw\");\n\tif (PTR_ERR(plat->sw_rst) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(plat->sw_rst);\n\n\tplat->reg_rst = devm_reset_control_get_optional_exclusive(dev, \"reg\");\n\tif (PTR_ERR(plat->reg_rst) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(plat->reg_rst);\n\n\terr = reset_control_assert(plat->axi_rst);\n\tif (err) {\n\t\tdev_err(dev, \"failed to assert AXI bus\\n\");\n\t\treturn err;\n\t}\n\n\terr = reset_control_assert(plat->sw_rst);\n\tif (err) {\n\t\tdev_err(dev, \"failed to assert PHY digital part\\n\");\n\t\treturn err;\n\t}\n\n\terr = reset_control_assert(plat->reg_rst);\n\tif (err) {\n\t\tdev_err(dev, \"failed to assert PHY register part\\n\");\n\t\treturn err;\n\t}\n\n\terr = reset_control_deassert(plat->reg_rst);\n\tif (err) {\n\t\tdev_err(dev, \"failed to deassert PHY register part\\n\");\n\t\treturn err;\n\t}\n\n\terr = reset_control_deassert(plat->sw_rst);\n\tif (err) {\n\t\tdev_err(dev, \"failed to deassert PHY digital part\\n\");\n\t\treturn err;\n\t}\n\n\terr = reset_control_deassert(plat->axi_rst);\n\tif (err) {\n\t\tdev_err(dev, \"failed to deassert AXI bus\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_ahci_parse_property(struct ahci_host_priv *hpriv,\n\t\t\t\t   struct device *dev)\n{\n\tstruct mtk_ahci_plat *plat = hpriv->plat_data;\n\tstruct device_node *np = dev->of_node;\n\n\t \n\tif (of_property_present(np, \"mediatek,phy-mode\")) {\n\t\tplat->mode = syscon_regmap_lookup_by_phandle(\n\t\t\t\t\tnp, \"mediatek,phy-mode\");\n\t\tif (IS_ERR(plat->mode)) {\n\t\t\tdev_err(dev, \"missing phy-mode phandle\\n\");\n\t\t\treturn PTR_ERR(plat->mode);\n\t\t}\n\n\t\tregmap_update_bits(plat->mode, SYS_CFG, SYS_CFG_SATA_MSK,\n\t\t\t\t   SYS_CFG_SATA_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_ahci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_ahci_plat *plat;\n\tstruct ahci_host_priv *hpriv;\n\tint err;\n\n\tplat = devm_kzalloc(dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn -ENOMEM;\n\n\thpriv = ahci_platform_get_resources(pdev, 0);\n\tif (IS_ERR(hpriv))\n\t\treturn PTR_ERR(hpriv);\n\n\thpriv->plat_data = plat;\n\n\terr = mtk_ahci_parse_property(hpriv, dev);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_ahci_platform_resets(hpriv, dev);\n\tif (err)\n\t\treturn err;\n\n\terr = ahci_platform_enable_resources(hpriv);\n\tif (err)\n\t\treturn err;\n\n\terr = ahci_platform_init_host(pdev, hpriv, &ahci_port_info,\n\t\t\t\t      &ahci_platform_sht);\n\tif (err)\n\t\tgoto disable_resources;\n\n\treturn 0;\n\ndisable_resources:\n\tahci_platform_disable_resources(hpriv);\n\treturn err;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,\n\t\t\t ahci_platform_resume);\n\nstatic const struct of_device_id ahci_of_match[] = {\n\t{ .compatible = \"mediatek,mtk-ahci\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ahci_of_match);\n\nstatic struct platform_driver mtk_ahci_driver = {\n\t.probe = mtk_ahci_probe,\n\t.remove_new = ata_platform_remove_one,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ahci_of_match,\n\t\t.pm = &ahci_pm_ops,\n\t},\n};\nmodule_platform_driver(mtk_ahci_driver);\n\nMODULE_DESCRIPTION(\"MediaTek SATA AHCI Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}