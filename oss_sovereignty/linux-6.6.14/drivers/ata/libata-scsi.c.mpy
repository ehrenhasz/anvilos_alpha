{
  "module_name": "libata-scsi.c",
  "hash_id": "dc19a92ac74dc1786e1570b9e5a56996f8a7e19490cb4edc13c6987571c73e19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/libata-scsi.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <linux/libata.h>\n#include <linux/hdreg.h>\n#include <linux/uaccess.h>\n#include <linux/suspend.h>\n#include <asm/unaligned.h>\n#include <linux/ioprio.h>\n#include <linux/of.h>\n\n#include \"libata.h\"\n#include \"libata-transport.h\"\n\n#define ATA_SCSI_RBUF_SIZE\t2048\n\nstatic DEFINE_SPINLOCK(ata_scsi_rbuf_lock);\nstatic u8 ata_scsi_rbuf[ATA_SCSI_RBUF_SIZE];\n\ntypedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *qc);\n\nstatic struct ata_device *__ata_scsi_find_dev(struct ata_port *ap,\n\t\t\t\t\tconst struct scsi_device *scsidev);\n\n#define RW_RECOVERY_MPAGE\t\t0x1\n#define RW_RECOVERY_MPAGE_LEN\t\t12\n#define CACHE_MPAGE\t\t\t0x8\n#define CACHE_MPAGE_LEN\t\t\t20\n#define CONTROL_MPAGE\t\t\t0xa\n#define CONTROL_MPAGE_LEN\t\t12\n#define ALL_MPAGES\t\t\t0x3f\n#define ALL_SUB_MPAGES\t\t\t0xff\n#define CDL_T2A_SUB_MPAGE\t\t0x07\n#define CDL_T2B_SUB_MPAGE\t\t0x08\n#define CDL_T2_SUB_MPAGE_LEN\t\t232\n#define ATA_FEATURE_SUB_MPAGE\t\t0xf2\n#define ATA_FEATURE_SUB_MPAGE_LEN\t16\n\nstatic const u8 def_rw_recovery_mpage[RW_RECOVERY_MPAGE_LEN] = {\n\tRW_RECOVERY_MPAGE,\n\tRW_RECOVERY_MPAGE_LEN - 2,\n\t(1 << 7),\t \n\t0,\t\t \n\t0, 0, 0, 0,\n\t0,\t\t \n\t0, 0, 0\n};\n\nstatic const u8 def_cache_mpage[CACHE_MPAGE_LEN] = {\n\tCACHE_MPAGE,\n\tCACHE_MPAGE_LEN - 2,\n\t0,\t\t \n\t0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0,\t\t \n\t0, 0, 0, 0, 0, 0, 0\n};\n\nstatic const u8 def_control_mpage[CONTROL_MPAGE_LEN] = {\n\tCONTROL_MPAGE,\n\tCONTROL_MPAGE_LEN - 2,\n\t2,\t \n\t0,\t \n\t0, 0, 0, 0, 0xff, 0xff,\n\t0, 30\t \n};\n\nstatic ssize_t ata_scsi_park_show(struct device *device,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(device);\n\tstruct ata_port *ap;\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tunsigned long now;\n\tunsigned int msecs;\n\tint rc = 0;\n\n\tap = ata_shost_to_port(sdev->host);\n\n\tspin_lock_irq(ap->lock);\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (!dev) {\n\t\trc = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (dev->flags & ATA_DFLAG_NO_UNLOAD) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tlink = dev->link;\n\tnow = jiffies;\n\tif (ap->pflags & ATA_PFLAG_EH_IN_PROGRESS &&\n\t    link->eh_context.unloaded_mask & (1 << dev->devno) &&\n\t    time_after(dev->unpark_deadline, now))\n\t\tmsecs = jiffies_to_msecs(dev->unpark_deadline - now);\n\telse\n\t\tmsecs = 0;\n\nunlock:\n\tspin_unlock_irq(ap->lock);\n\n\treturn rc ? rc : sysfs_emit(buf, \"%u\\n\", msecs);\n}\n\nstatic ssize_t ata_scsi_park_store(struct device *device,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t len)\n{\n\tstruct scsi_device *sdev = to_scsi_device(device);\n\tstruct ata_port *ap;\n\tstruct ata_device *dev;\n\tint input;\n\tunsigned long flags;\n\tint rc;\n\n\trc = kstrtoint(buf, 10, &input);\n\tif (rc)\n\t\treturn rc;\n\tif (input < -2)\n\t\treturn -EINVAL;\n\tif (input > ATA_TMOUT_MAX_PARK) {\n\t\trc = -EOVERFLOW;\n\t\tinput = ATA_TMOUT_MAX_PARK;\n\t}\n\n\tap = ata_shost_to_port(sdev->host);\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (unlikely(!dev)) {\n\t\trc = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (dev->class != ATA_DEV_ATA &&\n\t    dev->class != ATA_DEV_ZAC) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tif (input >= 0) {\n\t\tif (dev->flags & ATA_DFLAG_NO_UNLOAD) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdev->unpark_deadline = ata_deadline(jiffies, input);\n\t\tdev->link->eh_info.dev_action[dev->devno] |= ATA_EH_PARK;\n\t\tata_port_schedule_eh(ap);\n\t\tcomplete(&ap->park_req_pending);\n\t} else {\n\t\tswitch (input) {\n\t\tcase -1:\n\t\t\tdev->flags &= ~ATA_DFLAG_NO_UNLOAD;\n\t\t\tbreak;\n\t\tcase -2:\n\t\t\tdev->flags |= ATA_DFLAG_NO_UNLOAD;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock:\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn rc ? rc : len;\n}\nDEVICE_ATTR(unload_heads, S_IRUGO | S_IWUSR,\n\t    ata_scsi_park_show, ata_scsi_park_store);\nEXPORT_SYMBOL_GPL(dev_attr_unload_heads);\n\nbool ata_scsi_sense_is_valid(u8 sk, u8 asc, u8 ascq)\n{\n\t \n\tif (sk == 0 && asc == 0 && ascq == 0)\n\t\treturn false;\n\n\t \n\tif (sk > COMPLETED)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid ata_scsi_set_sense(struct ata_device *dev, struct scsi_cmnd *cmd,\n\t\t\tu8 sk, u8 asc, u8 ascq)\n{\n\tbool d_sense = (dev->flags & ATA_DFLAG_D_SENSE);\n\n\tscsi_build_sense(cmd, d_sense, sk, asc, ascq);\n}\n\nvoid ata_scsi_set_sense_information(struct ata_device *dev,\n\t\t\t\t    struct scsi_cmnd *cmd,\n\t\t\t\t    const struct ata_taskfile *tf)\n{\n\tu64 information;\n\n\tinformation = ata_tf_read_block(tf, dev);\n\tif (information == U64_MAX)\n\t\treturn;\n\n\tscsi_set_sense_information(cmd->sense_buffer,\n\t\t\t\t   SCSI_SENSE_BUFFERSIZE, information);\n}\n\nstatic void ata_scsi_set_invalid_field(struct ata_device *dev,\n\t\t\t\t       struct scsi_cmnd *cmd, u16 field, u8 bit)\n{\n\tata_scsi_set_sense(dev, cmd, ILLEGAL_REQUEST, 0x24, 0x0);\n\t \n\tscsi_set_sense_field_pointer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t     field, bit, 1);\n}\n\nstatic void ata_scsi_set_invalid_parameter(struct ata_device *dev,\n\t\t\t\t\t   struct scsi_cmnd *cmd, u16 field)\n{\n\t \n\tata_scsi_set_sense(dev, cmd, ILLEGAL_REQUEST, 0x26, 0x0);\n\tscsi_set_sense_field_pointer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t     field, 0xff, 0);\n}\n\nstatic struct attribute *ata_common_sdev_attrs[] = {\n\t&dev_attr_unload_heads.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ata_common_sdev_attr_group = {\n\t.attrs = ata_common_sdev_attrs\n};\n\nconst struct attribute_group *ata_common_sdev_groups[] = {\n\t&ata_common_sdev_attr_group,\n\tNULL\n};\nEXPORT_SYMBOL_GPL(ata_common_sdev_groups);\n\n \nint ata_std_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\t\t       sector_t capacity, int geom[])\n{\n\tgeom[0] = 255;\n\tgeom[1] = 63;\n\tsector_div(capacity, 255*63);\n\tgeom[2] = capacity;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_std_bios_param);\n\n \nvoid ata_scsi_unlock_native_capacity(struct scsi_device *sdev)\n{\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tdev = ata_scsi_find_dev(ap, sdev);\n\tif (dev && dev->n_sectors < dev->n_native_sectors) {\n\t\tdev->flags |= ATA_DFLAG_UNLOCK_HPA;\n\t\tdev->link->eh_info.action |= ATA_EH_RESET;\n\t\tata_port_schedule_eh(ap);\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tata_port_wait_eh(ap);\n}\nEXPORT_SYMBOL_GPL(ata_scsi_unlock_native_capacity);\n\n \nstatic int ata_get_identity(struct ata_port *ap, struct scsi_device *sdev,\n\t\t\t    void __user *arg)\n{\n\tstruct ata_device *dev = ata_scsi_find_dev(ap, sdev);\n\tu16 __user *dst = arg;\n\tchar buf[40];\n\n\tif (!dev)\n\t\treturn -ENOMSG;\n\n\tif (copy_to_user(dst, dev->id, ATA_ID_WORDS * sizeof(u16)))\n\t\treturn -EFAULT;\n\n\tata_id_string(dev->id, buf, ATA_ID_PROD, ATA_ID_PROD_LEN);\n\tif (copy_to_user(dst + ATA_ID_PROD, buf, ATA_ID_PROD_LEN))\n\t\treturn -EFAULT;\n\n\tata_id_string(dev->id, buf, ATA_ID_FW_REV, ATA_ID_FW_REV_LEN);\n\tif (copy_to_user(dst + ATA_ID_FW_REV, buf, ATA_ID_FW_REV_LEN))\n\t\treturn -EFAULT;\n\n\tata_id_string(dev->id, buf, ATA_ID_SERNO, ATA_ID_SERNO_LEN);\n\tif (copy_to_user(dst + ATA_ID_SERNO, buf, ATA_ID_SERNO_LEN))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nint ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg)\n{\n\tint rc = 0;\n\tu8 sensebuf[SCSI_SENSE_BUFFERSIZE];\n\tu8 scsi_cmd[MAX_COMMAND_SIZE];\n\tu8 args[4], *argbuf = NULL;\n\tint argsize = 0;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t\t.sense = sensebuf,\n\t\t.sense_len = sizeof(sensebuf),\n\t};\n\tint cmd_result;\n\n\tif (arg == NULL)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(args, arg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tmemset(sensebuf, 0, sizeof(sensebuf));\n\tmemset(scsi_cmd, 0, sizeof(scsi_cmd));\n\n\tif (args[3]) {\n\t\targsize = ATA_SECT_SIZE * args[3];\n\t\targbuf = kmalloc(argsize, GFP_KERNEL);\n\t\tif (argbuf == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tscsi_cmd[1]  = (4 << 1);  \n\t\tscsi_cmd[2]  = 0x0e;      \n\t} else {\n\t\tscsi_cmd[1]  = (3 << 1);  \n\t\tscsi_cmd[2]  = 0x20;      \n\t}\n\n\tscsi_cmd[0] = ATA_16;\n\n\tscsi_cmd[4] = args[2];\n\tif (args[0] == ATA_CMD_SMART) {  \n\t\tscsi_cmd[6]  = args[3];\n\t\tscsi_cmd[8]  = args[1];\n\t\tscsi_cmd[10] = ATA_SMART_LBAM_PASS;\n\t\tscsi_cmd[12] = ATA_SMART_LBAH_PASS;\n\t} else {\n\t\tscsi_cmd[6]  = args[1];\n\t}\n\tscsi_cmd[14] = args[0];\n\n\t \n\tcmd_result = scsi_execute_cmd(scsidev, scsi_cmd, REQ_OP_DRV_IN, argbuf,\n\t\t\t\t      argsize, 10 * HZ, 5, &exec_args);\n\tif (cmd_result < 0) {\n\t\trc = cmd_result;\n\t\tgoto error;\n\t}\n\tif (scsi_sense_valid(&sshdr)) { \n\t\tu8 *desc = sensebuf + 8;\n\n\t\t \n\t\tif (scsi_status_is_check_condition(cmd_result)) {\n\t\t\tif (sshdr.sense_key == RECOVERED_ERROR &&\n\t\t\t    sshdr.asc == 0 && sshdr.ascq == 0x1d)\n\t\t\t\tcmd_result &= ~SAM_STAT_CHECK_CONDITION;\n\t\t}\n\n\t\t \n\t\tif (sensebuf[0] == 0x72 &&\t \n\t\t    desc[0] == 0x09) {\t\t \n\t\t\targs[0] = desc[13];\t \n\t\t\targs[1] = desc[3];\t \n\t\t\targs[2] = desc[5];\t \n\t\t\tif (copy_to_user(arg, args, sizeof(args)))\n\t\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\n\n\tif (cmd_result) {\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\tif ((argbuf)\n\t && copy_to_user(arg + sizeof(args), argbuf, argsize))\n\t\trc = -EFAULT;\nerror:\n\tkfree(argbuf);\n\treturn rc;\n}\n\n \nint ata_task_ioctl(struct scsi_device *scsidev, void __user *arg)\n{\n\tint rc = 0;\n\tu8 sensebuf[SCSI_SENSE_BUFFERSIZE];\n\tu8 scsi_cmd[MAX_COMMAND_SIZE];\n\tu8 args[7];\n\tstruct scsi_sense_hdr sshdr;\n\tint cmd_result;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t\t.sense = sensebuf,\n\t\t.sense_len = sizeof(sensebuf),\n\t};\n\n\tif (arg == NULL)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(args, arg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tmemset(sensebuf, 0, sizeof(sensebuf));\n\tmemset(scsi_cmd, 0, sizeof(scsi_cmd));\n\tscsi_cmd[0]  = ATA_16;\n\tscsi_cmd[1]  = (3 << 1);  \n\tscsi_cmd[2]  = 0x20;      \n\tscsi_cmd[4]  = args[1];\n\tscsi_cmd[6]  = args[2];\n\tscsi_cmd[8]  = args[3];\n\tscsi_cmd[10] = args[4];\n\tscsi_cmd[12] = args[5];\n\tscsi_cmd[13] = args[6] & 0x4f;\n\tscsi_cmd[14] = args[0];\n\n\t \n\tcmd_result = scsi_execute_cmd(scsidev, scsi_cmd, REQ_OP_DRV_IN, NULL,\n\t\t\t\t      0, 10 * HZ, 5, &exec_args);\n\tif (cmd_result < 0) {\n\t\trc = cmd_result;\n\t\tgoto error;\n\t}\n\tif (scsi_sense_valid(&sshdr)) { \n\t\tu8 *desc = sensebuf + 8;\n\n\t\t \n\t\tif (cmd_result & SAM_STAT_CHECK_CONDITION) {\n\t\t\tif (sshdr.sense_key == RECOVERED_ERROR &&\n\t\t\t    sshdr.asc == 0 && sshdr.ascq == 0x1d)\n\t\t\t\tcmd_result &= ~SAM_STAT_CHECK_CONDITION;\n\t\t}\n\n\t\t \n\t\tif (sensebuf[0] == 0x72 &&\t \n\t\t\t\tdesc[0] == 0x09) { \n\t\t\targs[0] = desc[13];\t \n\t\t\targs[1] = desc[3];\t \n\t\t\targs[2] = desc[5];\t \n\t\t\targs[3] = desc[7];\t \n\t\t\targs[4] = desc[9];\t \n\t\t\targs[5] = desc[11];\t \n\t\t\targs[6] = desc[12];\t \n\t\t\tif (copy_to_user(arg, args, sizeof(args)))\n\t\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\n\tif (cmd_result) {\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n error:\n\treturn rc;\n}\n\nstatic bool ata_ioc32(struct ata_port *ap)\n{\n\tif (ap->flags & ATA_FLAG_PIO_DMA)\n\t\treturn true;\n\tif (ap->pflags & ATA_PFLAG_PIO32)\n\t\treturn true;\n\treturn false;\n}\n\n \nint ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *scsidev,\n\t\t     unsigned int cmd, void __user *arg)\n{\n\tunsigned long val;\n\tint rc = -EINVAL;\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase HDIO_GET_32BIT:\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t\tval = ata_ioc32(ap);\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n#ifdef CONFIG_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\treturn put_user(val, (compat_ulong_t __user *)arg);\n#endif\n\t\treturn put_user(val, (unsigned long __user *)arg);\n\n\tcase HDIO_SET_32BIT:\n\t\tval = (unsigned long) arg;\n\t\trc = 0;\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t\tif (ap->pflags & ATA_PFLAG_PIO32CHANGE) {\n\t\t\tif (val)\n\t\t\t\tap->pflags |= ATA_PFLAG_PIO32;\n\t\t\telse\n\t\t\t\tap->pflags &= ~ATA_PFLAG_PIO32;\n\t\t} else {\n\t\t\tif (val != ata_ioc32(ap))\n\t\t\t\trc = -EINVAL;\n\t\t}\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\treturn rc;\n\n\tcase HDIO_GET_IDENTITY:\n\t\treturn ata_get_identity(ap, scsidev, arg);\n\n\tcase HDIO_DRIVE_CMD:\n\t\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\t\treturn -EACCES;\n\t\treturn ata_cmd_ioctl(scsidev, arg);\n\n\tcase HDIO_DRIVE_TASK:\n\t\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\t\treturn -EACCES;\n\t\treturn ata_task_ioctl(scsidev, arg);\n\n\tdefault:\n\t\trc = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_sas_scsi_ioctl);\n\nint ata_scsi_ioctl(struct scsi_device *scsidev, unsigned int cmd,\n\t\t   void __user *arg)\n{\n\treturn ata_sas_scsi_ioctl(ata_shost_to_port(scsidev->host),\n\t\t\t\tscsidev, cmd, arg);\n}\nEXPORT_SYMBOL_GPL(ata_scsi_ioctl);\n\n \nstatic struct ata_queued_cmd *ata_scsi_qc_new(struct ata_device *dev,\n\t\t\t\t\t      struct scsi_cmnd *cmd)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct ata_queued_cmd *qc;\n\tint tag;\n\n\tif (unlikely(ata_port_is_frozen(ap)))\n\t\tgoto fail;\n\n\tif (ap->flags & ATA_FLAG_SAS_HOST) {\n\t\t \n\t\tif (WARN_ON_ONCE(cmd->budget_token >= ATA_MAX_QUEUE))\n\t\t\tgoto fail;\n\t\ttag = cmd->budget_token;\n\t} else {\n\t\ttag = scsi_cmd_to_rq(cmd)->tag;\n\t}\n\n\tqc = __ata_qc_from_tag(ap, tag);\n\tqc->tag = qc->hw_tag = tag;\n\tqc->ap = ap;\n\tqc->dev = dev;\n\n\tata_qc_reinit(qc);\n\n\tqc->scsicmd = cmd;\n\tqc->scsidone = scsi_done;\n\n\tqc->sg = scsi_sglist(cmd);\n\tqc->n_elem = scsi_sg_count(cmd);\n\n\tif (scsi_cmd_to_rq(cmd)->rq_flags & RQF_QUIET)\n\t\tqc->flags |= ATA_QCFLAG_QUIET;\n\n\treturn qc;\n\nfail:\n\tset_host_byte(cmd, DID_OK);\n\tset_status_byte(cmd, SAM_STAT_TASK_SET_FULL);\n\tscsi_done(cmd);\n\treturn NULL;\n}\n\nstatic void ata_qc_set_pc_nbytes(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\n\tqc->extrabytes = scmd->extra_len;\n\tqc->nbytes = scsi_bufflen(scmd) + qc->extrabytes;\n}\n\n \nstatic void ata_to_sense_error(unsigned id, u8 drv_stat, u8 drv_err, u8 *sk,\n\t\t\t       u8 *asc, u8 *ascq)\n{\n\tint i;\n\n\t \n\tstatic const unsigned char sense_table[][4] = {\n\t\t \n\t\t{0xd1,\t\tABORTED_COMMAND, 0x00, 0x00},\n\t\t\t \n\t\t \n\t\t{0xd0,\t\tABORTED_COMMAND, 0x00, 0x00},\n\t\t\t \n\t\t \n\t\t{0x61,\t\tHARDWARE_ERROR, 0x00, 0x00},\n\t\t\t \n\t\t \t\t \n\t\t{0x84,\t\tABORTED_COMMAND, 0x47, 0x00},\n\t\t\t \n\t\t \n\t\t{0x37,\t\tNOT_READY, 0x04, 0x00},\n\t\t\t \n\t\t \n\t\t{0x09,\t\tNOT_READY, 0x04, 0x00},\n\t\t\t \n\t\t \n\t\t{0x01,\t\tMEDIUM_ERROR, 0x13, 0x00},\n\t\t\t \n\t\t \n\t\t{0x02,\t\tHARDWARE_ERROR, 0x00, 0x00},\n\t\t\t \n\t\t \n\t\t \n\t\t{0x08,\t\tNOT_READY, 0x04, 0x00},\n\t\t\t \n\t\t \n\t\t{0x10,\t\tILLEGAL_REQUEST, 0x21, 0x00},\n\t\t\t \n\t\t \n\t\t{0x20,\t\tUNIT_ATTENTION, 0x28, 0x00},\n\t\t\t \n\t\t \n\t\t{0x40,\t\tMEDIUM_ERROR, 0x11, 0x04},\n\t\t\t \n\t\t \n\t\t{0x80,\t\tMEDIUM_ERROR, 0x11, 0x04},\n\t\t\t \n\t\t{0xFF, 0xFF, 0xFF, 0xFF},  \n\t};\n\tstatic const unsigned char stat_table[][4] = {\n\t\t \n\t\t{0x80,\t\tABORTED_COMMAND, 0x47, 0x00},\n\t\t \n\t\t{0x40,\t\tILLEGAL_REQUEST, 0x21, 0x04},\n\t\t \n\t\t{0x20,\t\tHARDWARE_ERROR,  0x44, 0x00},\n\t\t \n\t\t{0x08,\t\tABORTED_COMMAND, 0x47, 0x00},\n\t\t \n\t\t{0x04,\t\tRECOVERED_ERROR, 0x11, 0x00},\n\t\t \n\t\t{0xFF, 0xFF, 0xFF, 0xFF},  \n\t};\n\n\t \n\tif (drv_stat & ATA_BUSY) {\n\t\tdrv_err = 0;\t \n\t}\n\n\tif (drv_err) {\n\t\t \n\t\tfor (i = 0; sense_table[i][0] != 0xFF; i++) {\n\t\t\t \n\t\t\tif ((sense_table[i][0] & drv_err) ==\n\t\t\t    sense_table[i][0]) {\n\t\t\t\t*sk = sense_table[i][1];\n\t\t\t\t*asc = sense_table[i][2];\n\t\t\t\t*ascq = sense_table[i][3];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; stat_table[i][0] != 0xFF; i++) {\n\t\tif (stat_table[i][0] & drv_stat) {\n\t\t\t*sk = stat_table[i][1];\n\t\t\t*asc = stat_table[i][2];\n\t\t\t*ascq = stat_table[i][3];\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\t*sk = ABORTED_COMMAND;\n\t*asc = 0x00;\n\t*ascq = 0x00;\n}\n\n \nstatic void ata_gen_passthru_sense(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tstruct ata_taskfile *tf = &qc->result_tf;\n\tunsigned char *sb = cmd->sense_buffer;\n\tunsigned char *desc = sb + 8;\n\tu8 sense_key, asc, ascq;\n\n\tmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\n\n\t \n\tif (qc->err_mask ||\n\t    tf->status & (ATA_BUSY | ATA_DF | ATA_ERR | ATA_DRQ)) {\n\t\tata_to_sense_error(qc->ap->print_id, tf->status, tf->error,\n\t\t\t\t   &sense_key, &asc, &ascq);\n\t\tata_scsi_set_sense(qc->dev, cmd, sense_key, asc, ascq);\n\t} else {\n\t\t \n\t\tscsi_build_sense(cmd, 1, RECOVERED_ERROR, 0, 0x1D);\n\t}\n\n\tif ((cmd->sense_buffer[0] & 0x7f) >= 0x72) {\n\t\tu8 len;\n\n\t\t \n\t\tlen = sb[7];\n\t\tdesc = (char *)scsi_sense_desc_find(sb, len + 8, 9);\n\t\tif (!desc) {\n\t\t\tif (SCSI_SENSE_BUFFERSIZE < len + 14)\n\t\t\t\treturn;\n\t\t\tsb[7] = len + 14;\n\t\t\tdesc = sb + 8 + len;\n\t\t}\n\t\tdesc[0] = 9;\n\t\tdesc[1] = 12;\n\t\t \n\t\tdesc[2] = 0x00;\n\t\tdesc[3] = tf->error;\n\t\tdesc[5] = tf->nsect;\n\t\tdesc[7] = tf->lbal;\n\t\tdesc[9] = tf->lbam;\n\t\tdesc[11] = tf->lbah;\n\t\tdesc[12] = tf->device;\n\t\tdesc[13] = tf->status;\n\n\t\t \n\t\tif (tf->flags & ATA_TFLAG_LBA48) {\n\t\t\tdesc[2] |= 0x01;\n\t\t\tdesc[4] = tf->hob_nsect;\n\t\t\tdesc[6] = tf->hob_lbal;\n\t\t\tdesc[8] = tf->hob_lbam;\n\t\t\tdesc[10] = tf->hob_lbah;\n\t\t}\n\t} else {\n\t\t \n\t\tdesc[0] = tf->error;\n\t\tdesc[1] = tf->status;\n\t\tdesc[2] = tf->device;\n\t\tdesc[3] = tf->nsect;\n\t\tdesc[7] = 0;\n\t\tif (tf->flags & ATA_TFLAG_LBA48)  {\n\t\t\tdesc[8] |= 0x80;\n\t\t\tif (tf->hob_nsect)\n\t\t\t\tdesc[8] |= 0x40;\n\t\t\tif (tf->hob_lbal || tf->hob_lbam || tf->hob_lbah)\n\t\t\t\tdesc[8] |= 0x20;\n\t\t}\n\t\tdesc[9] = tf->lbal;\n\t\tdesc[10] = tf->lbam;\n\t\tdesc[11] = tf->lbah;\n\t}\n}\n\n \nstatic void ata_gen_ata_sense(struct ata_queued_cmd *qc)\n{\n\tstruct ata_device *dev = qc->dev;\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tstruct ata_taskfile *tf = &qc->result_tf;\n\tunsigned char *sb = cmd->sense_buffer;\n\tu64 block;\n\tu8 sense_key, asc, ascq;\n\n\tmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\n\n\tif (ata_dev_disabled(dev)) {\n\t\t \n\t\t \n\t\tata_scsi_set_sense(dev, cmd, NOT_READY, 0x04, 0x21);\n\t\treturn;\n\t}\n\t \n\tif (qc->err_mask ||\n\t    tf->status & (ATA_BUSY | ATA_DF | ATA_ERR | ATA_DRQ)) {\n\t\tata_to_sense_error(qc->ap->print_id, tf->status, tf->error,\n\t\t\t\t   &sense_key, &asc, &ascq);\n\t\tata_scsi_set_sense(dev, cmd, sense_key, asc, ascq);\n\t} else {\n\t\t \n\t\tata_dev_warn(dev, \"could not decode error status 0x%x err_mask 0x%x\\n\",\n\t\t\t     tf->status, qc->err_mask);\n\t\tata_scsi_set_sense(dev, cmd, ABORTED_COMMAND, 0, 0);\n\t\treturn;\n\t}\n\n\tblock = ata_tf_read_block(&qc->result_tf, dev);\n\tif (block == U64_MAX)\n\t\treturn;\n\n\tscsi_set_sense_information(sb, SCSI_SENSE_BUFFERSIZE, block);\n}\n\nvoid ata_scsi_sdev_config(struct scsi_device *sdev)\n{\n\tsdev->use_10_for_rw = 1;\n\tsdev->use_10_for_ms = 1;\n\tsdev->no_write_same = 1;\n\n\t \n\tsdev->max_device_blocked = 1;\n}\n\n \nbool ata_scsi_dma_need_drain(struct request *rq)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\n\treturn atapi_cmd_type(scmd->cmnd[0]) == ATAPI_MISC;\n}\nEXPORT_SYMBOL_GPL(ata_scsi_dma_need_drain);\n\nint ata_scsi_dev_config(struct scsi_device *sdev, struct ata_device *dev)\n{\n\tstruct request_queue *q = sdev->request_queue;\n\tint depth = 1;\n\n\tif (!ata_id_has_unload(dev->id))\n\t\tdev->flags |= ATA_DFLAG_NO_UNLOAD;\n\n\t \n\tdev->max_sectors = min(dev->max_sectors, sdev->host->max_sectors);\n\tblk_queue_max_hw_sectors(q, dev->max_sectors);\n\n\tif (dev->class == ATA_DEV_ATAPI) {\n\t\tsdev->sector_size = ATA_SECT_SIZE;\n\n\t\t \n\t\tblk_queue_update_dma_pad(q, ATA_DMA_PAD_SZ - 1);\n\n\t\t \n\t\tblk_queue_max_segments(q, queue_max_segments(q) - 1);\n\n\t\tsdev->dma_drain_len = ATAPI_MAX_DRAIN;\n\t\tsdev->dma_drain_buf = kmalloc(sdev->dma_drain_len, GFP_NOIO);\n\t\tif (!sdev->dma_drain_buf) {\n\t\t\tata_dev_err(dev, \"drain buffer allocation failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tsdev->sector_size = ata_id_logical_sector_size(dev->id);\n\n\t\t \n\t\tsdev->manage_runtime_start_stop = 1;\n\t\tsdev->manage_shutdown = 1;\n\t\tsdev->force_runtime_start_on_system_start = 1;\n\t}\n\n\t \n\tif (sdev->sector_size > PAGE_SIZE)\n\t\tata_dev_warn(dev,\n\t\t\t\"sector_size=%u > PAGE_SIZE, PIO may malfunction\\n\",\n\t\t\tsdev->sector_size);\n\n\tblk_queue_update_dma_alignment(q, sdev->sector_size - 1);\n\n\tif (dev->flags & ATA_DFLAG_AN)\n\t\tset_bit(SDEV_EVT_MEDIA_CHANGE, sdev->supported_events);\n\n\tif (ata_ncq_supported(dev))\n\t\tdepth = min(sdev->host->can_queue, ata_id_queue_depth(dev->id));\n\tdepth = min(ATA_MAX_QUEUE, depth);\n\tscsi_change_queue_depth(sdev, depth);\n\n\tif (dev->flags & ATA_DFLAG_TRUSTED)\n\t\tsdev->security_supported = 1;\n\n\tdev->sdev = sdev;\n\treturn 0;\n}\n\n \n\nint ata_scsi_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct device_link *link;\n\n\tata_scsi_sdev_config(sdev);\n\n\t \n\tlink = device_link_add(&sdev->sdev_gendev, &ap->tdev,\n\t\t\t       DL_FLAG_STATELESS |\n\t\t\t       DL_FLAG_PM_RUNTIME | DL_FLAG_RPM_ACTIVE);\n\tif (!link) {\n\t\tata_port_err(ap, \"Failed to create link to scsi device %s\\n\",\n\t\t\t     dev_name(&sdev->sdev_gendev));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_scsi_slave_alloc);\n\n \n\nint ata_scsi_slave_config(struct scsi_device *sdev)\n{\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tstruct ata_device *dev = __ata_scsi_find_dev(ap, sdev);\n\n\tif (dev)\n\t\treturn ata_scsi_dev_config(sdev, dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ata_scsi_slave_config);\n\n \nvoid ata_scsi_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct ata_port *ap = ata_shost_to_port(sdev->host);\n\tunsigned long flags;\n\tstruct ata_device *dev;\n\n\tdevice_link_remove(&sdev->sdev_gendev, &ap->tdev);\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tdev = __ata_scsi_find_dev(ap, sdev);\n\tif (dev && dev->sdev) {\n\t\t \n\t\tdev->sdev = NULL;\n\t\tdev->flags |= ATA_DFLAG_DETACH;\n\t\tata_port_schedule_eh(ap);\n\t}\n\tspin_unlock_irqrestore(ap->lock, flags);\n\n\tkfree(sdev->dma_drain_buf);\n}\nEXPORT_SYMBOL_GPL(ata_scsi_slave_destroy);\n\n \nstatic unsigned int ata_scsi_start_stop_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct ata_taskfile *tf = &qc->tf;\n\tconst u8 *cdb = scmd->cmnd;\n\tu16 fp;\n\tu8 bp = 0xff;\n\n\tif (scmd->cmd_len < 5) {\n\t\tfp = 4;\n\t\tgoto invalid_fld;\n\t}\n\n\ttf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\ttf->protocol = ATA_PROT_NODATA;\n\tif (cdb[1] & 0x1) {\n\t\t;\t \n\t}\n\tif (cdb[4] & 0x2) {\n\t\tfp = 4;\n\t\tbp = 1;\n\t\tgoto invalid_fld;        \n\t}\n\tif (((cdb[4] >> 4) & 0xf) != 0) {\n\t\tfp = 4;\n\t\tbp = 3;\n\t\tgoto invalid_fld;        \n\t}\n\n\tif (cdb[4] & 0x1) {\n\t\ttf->nsect = 1;   \n\n\t\tif (qc->dev->flags & ATA_DFLAG_LBA) {\n\t\t\ttf->flags |= ATA_TFLAG_LBA;\n\n\t\t\ttf->lbah = 0x0;\n\t\t\ttf->lbam = 0x0;\n\t\t\ttf->lbal = 0x0;\n\t\t\ttf->device |= ATA_LBA;\n\t\t} else {\n\t\t\t \n\t\t\ttf->lbal = 0x1;  \n\t\t\ttf->lbam = 0x0;  \n\t\t\ttf->lbah = 0x0;  \n\t\t}\n\n\t\ttf->command = ATA_CMD_VERIFY;    \n\t} else {\n\t\t \n\t\tif ((qc->ap->flags & ATA_FLAG_NO_POWEROFF_SPINDOWN) &&\n\t\t    system_state == SYSTEM_POWER_OFF)\n\t\t\tgoto skip;\n\n\t\tif ((qc->ap->flags & ATA_FLAG_NO_HIBERNATE_SPINDOWN) &&\n\t\t    system_entering_hibernation())\n\t\t\tgoto skip;\n\n\t\t \n\t\ttf->command = ATA_CMD_STANDBYNOW1;\n\t}\n\n\t \n\n\treturn 0;\n\n invalid_fld:\n\tata_scsi_set_invalid_field(qc->dev, scmd, fp, bp);\n\treturn 1;\n skip:\n\tscmd->result = SAM_STAT_GOOD;\n\treturn 1;\n}\n\n\n \nstatic unsigned int ata_scsi_flush_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\n\ttf->flags |= ATA_TFLAG_DEVICE;\n\ttf->protocol = ATA_PROT_NODATA;\n\n\tif (qc->dev->flags & ATA_DFLAG_FLUSH_EXT)\n\t\ttf->command = ATA_CMD_FLUSH_EXT;\n\telse\n\t\ttf->command = ATA_CMD_FLUSH;\n\n\t \n\tqc->flags |= ATA_QCFLAG_IO;\n\n\treturn 0;\n}\n\n \nstatic void scsi_6_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\n{\n\tu64 lba = 0;\n\tu32 len;\n\n\tlba |= ((u64)(cdb[1] & 0x1f)) << 16;\n\tlba |= ((u64)cdb[2]) << 8;\n\tlba |= ((u64)cdb[3]);\n\n\tlen = cdb[4];\n\n\t*plba = lba;\n\t*plen = len;\n}\n\n \nstatic inline void scsi_10_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\n{\n\t*plba = get_unaligned_be32(&cdb[2]);\n\t*plen = get_unaligned_be16(&cdb[7]);\n}\n\n \nstatic inline void scsi_16_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\n{\n\t*plba = get_unaligned_be64(&cdb[2]);\n\t*plen = get_unaligned_be32(&cdb[10]);\n}\n\n \nstatic inline int scsi_dld(const u8 *cdb)\n{\n\treturn ((cdb[1] & 0x01) << 2) | ((cdb[14] >> 6) & 0x03);\n}\n\n \nstatic unsigned int ata_scsi_verify_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct ata_taskfile *tf = &qc->tf;\n\tstruct ata_device *dev = qc->dev;\n\tu64 dev_sectors = qc->dev->n_sectors;\n\tconst u8 *cdb = scmd->cmnd;\n\tu64 block;\n\tu32 n_block;\n\tu16 fp;\n\n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\ttf->protocol = ATA_PROT_NODATA;\n\n\tswitch (cdb[0]) {\n\tcase VERIFY:\n\t\tif (scmd->cmd_len < 10) {\n\t\t\tfp = 9;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t\tscsi_10_lba_len(cdb, &block, &n_block);\n\t\tbreak;\n\tcase VERIFY_16:\n\t\tif (scmd->cmd_len < 16) {\n\t\t\tfp = 15;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t\tscsi_16_lba_len(cdb, &block, &n_block);\n\t\tbreak;\n\tdefault:\n\t\tfp = 0;\n\t\tgoto invalid_fld;\n\t}\n\n\tif (!n_block)\n\t\tgoto nothing_to_do;\n\tif (block >= dev_sectors)\n\t\tgoto out_of_range;\n\tif ((block + n_block) > dev_sectors)\n\t\tgoto out_of_range;\n\n\tif (dev->flags & ATA_DFLAG_LBA) {\n\t\ttf->flags |= ATA_TFLAG_LBA;\n\n\t\tif (lba_28_ok(block, n_block)) {\n\t\t\t \n\t\t\ttf->command = ATA_CMD_VERIFY;\n\t\t\ttf->device |= (block >> 24) & 0xf;\n\t\t} else if (lba_48_ok(block, n_block)) {\n\t\t\tif (!(dev->flags & ATA_DFLAG_LBA48))\n\t\t\t\tgoto out_of_range;\n\n\t\t\t \n\t\t\ttf->flags |= ATA_TFLAG_LBA48;\n\t\t\ttf->command = ATA_CMD_VERIFY_EXT;\n\n\t\t\ttf->hob_nsect = (n_block >> 8) & 0xff;\n\n\t\t\ttf->hob_lbah = (block >> 40) & 0xff;\n\t\t\ttf->hob_lbam = (block >> 32) & 0xff;\n\t\t\ttf->hob_lbal = (block >> 24) & 0xff;\n\t\t} else\n\t\t\t \n\t\t\tgoto out_of_range;\n\n\t\ttf->nsect = n_block & 0xff;\n\n\t\ttf->lbah = (block >> 16) & 0xff;\n\t\ttf->lbam = (block >> 8) & 0xff;\n\t\ttf->lbal = block & 0xff;\n\n\t\ttf->device |= ATA_LBA;\n\t} else {\n\t\t \n\t\tu32 sect, head, cyl, track;\n\n\t\tif (!lba_28_ok(block, n_block))\n\t\t\tgoto out_of_range;\n\n\t\t \n\t\ttrack = (u32)block / dev->sectors;\n\t\tcyl   = track / dev->heads;\n\t\thead  = track % dev->heads;\n\t\tsect  = (u32)block % dev->sectors + 1;\n\n\t\t \n\t\tif ((cyl >> 16) || (head >> 4) || (sect >> 8) || (!sect))\n\t\t\tgoto out_of_range;\n\n\t\ttf->command = ATA_CMD_VERIFY;\n\t\ttf->nsect = n_block & 0xff;  \n\t\ttf->lbal = sect;\n\t\ttf->lbam = cyl;\n\t\ttf->lbah = cyl >> 8;\n\t\ttf->device |= head;\n\t}\n\n\treturn 0;\n\ninvalid_fld:\n\tata_scsi_set_invalid_field(qc->dev, scmd, fp, 0xff);\n\treturn 1;\n\nout_of_range:\n\tata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x21, 0x0);\n\t \n\treturn 1;\n\nnothing_to_do:\n\tscmd->result = SAM_STAT_GOOD;\n\treturn 1;\n}\n\nstatic bool ata_check_nblocks(struct scsi_cmnd *scmd, u32 n_blocks)\n{\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tu32 req_blocks;\n\n\tif (!blk_rq_is_passthrough(rq))\n\t\treturn true;\n\n\treq_blocks = blk_rq_bytes(rq) / scmd->device->sector_size;\n\tif (n_blocks > req_blocks)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic unsigned int ata_scsi_rw_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tconst u8 *cdb = scmd->cmnd;\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tint class = IOPRIO_PRIO_CLASS(req_get_ioprio(rq));\n\tunsigned int tf_flags = 0;\n\tint dld = 0;\n\tu64 block;\n\tu32 n_block;\n\tint rc;\n\tu16 fp = 0;\n\n\tswitch (cdb[0]) {\n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase WRITE_16:\n\t\ttf_flags |= ATA_TFLAG_WRITE;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (cdb[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\t\tif (unlikely(scmd->cmd_len < 10)) {\n\t\t\tfp = 9;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t\tscsi_10_lba_len(cdb, &block, &n_block);\n\t\tif (cdb[1] & (1 << 3))\n\t\t\ttf_flags |= ATA_TFLAG_FUA;\n\t\tif (!ata_check_nblocks(scmd, n_block))\n\t\t\tgoto invalid_fld;\n\t\tbreak;\n\tcase READ_6:\n\tcase WRITE_6:\n\t\tif (unlikely(scmd->cmd_len < 6)) {\n\t\t\tfp = 5;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t\tscsi_6_lba_len(cdb, &block, &n_block);\n\n\t\t \n\t\tif (!n_block)\n\t\t\tn_block = 256;\n\t\tif (!ata_check_nblocks(scmd, n_block))\n\t\t\tgoto invalid_fld;\n\t\tbreak;\n\tcase READ_16:\n\tcase WRITE_16:\n\t\tif (unlikely(scmd->cmd_len < 16)) {\n\t\t\tfp = 15;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t\tscsi_16_lba_len(cdb, &block, &n_block);\n\t\tdld = scsi_dld(cdb);\n\t\tif (cdb[1] & (1 << 3))\n\t\t\ttf_flags |= ATA_TFLAG_FUA;\n\t\tif (!ata_check_nblocks(scmd, n_block))\n\t\t\tgoto invalid_fld;\n\t\tbreak;\n\tdefault:\n\t\tfp = 0;\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tif (!n_block)\n\t\t \n\t\tgoto nothing_to_do;\n\n\tqc->flags |= ATA_QCFLAG_IO;\n\tqc->nbytes = n_block * scmd->device->sector_size;\n\n\trc = ata_build_rw_tf(qc, block, n_block, tf_flags, dld, class);\n\tif (likely(rc == 0))\n\t\treturn 0;\n\n\tif (rc == -ERANGE)\n\t\tgoto out_of_range;\n\t \ninvalid_fld:\n\tata_scsi_set_invalid_field(qc->dev, scmd, fp, 0xff);\n\treturn 1;\n\nout_of_range:\n\tata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x21, 0x0);\n\t \n\treturn 1;\n\nnothing_to_do:\n\tscmd->result = SAM_STAT_GOOD;\n\treturn 1;\n}\n\nstatic void ata_qc_done(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tvoid (*done)(struct scsi_cmnd *) = qc->scsidone;\n\n\tata_qc_free(qc);\n\tdone(cmd);\n}\n\nstatic void ata_scsi_qc_complete(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tu8 *cdb = cmd->cmnd;\n\tint need_sense = (qc->err_mask != 0) &&\n\t\t!(qc->flags & ATA_QCFLAG_SENSE_VALID);\n\n\t \n\tif (((cdb[0] == ATA_16) || (cdb[0] == ATA_12)) &&\n\t    ((cdb[2] & 0x20) || need_sense))\n\t\tata_gen_passthru_sense(qc);\n\telse if (need_sense)\n\t\tata_gen_ata_sense(qc);\n\telse\n\t\t \n\t\tcmd->result &= 0x0000ffff;\n\n\tata_qc_done(qc);\n}\n\n \nstatic int ata_scsi_translate(struct ata_device *dev, struct scsi_cmnd *cmd,\n\t\t\t      ata_xlat_func_t xlat_func)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct ata_queued_cmd *qc;\n\tint rc;\n\n\tqc = ata_scsi_qc_new(dev, cmd);\n\tif (!qc)\n\t\tgoto err_mem;\n\n\t \n\tif (cmd->sc_data_direction == DMA_FROM_DEVICE ||\n\t    cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tif (unlikely(scsi_bufflen(cmd) < 1)) {\n\t\t\tata_dev_warn(dev, \"WARNING: zero len r/w req\\n\");\n\t\t\tgoto err_did;\n\t\t}\n\n\t\tata_sg_init(qc, scsi_sglist(cmd), scsi_sg_count(cmd));\n\n\t\tqc->dma_dir = cmd->sc_data_direction;\n\t}\n\n\tqc->complete_fn = ata_scsi_qc_complete;\n\n\tif (xlat_func(qc))\n\t\tgoto early_finish;\n\n\tif (ap->ops->qc_defer) {\n\t\tif ((rc = ap->ops->qc_defer(qc)))\n\t\t\tgoto defer;\n\t}\n\n\t \n\tata_qc_issue(qc);\n\n\treturn 0;\n\nearly_finish:\n\tata_qc_free(qc);\n\tscsi_done(cmd);\n\treturn 0;\n\nerr_did:\n\tata_qc_free(qc);\n\tcmd->result = (DID_ERROR << 16);\n\tscsi_done(cmd);\nerr_mem:\n\treturn 0;\n\ndefer:\n\tata_qc_free(qc);\n\tif (rc == ATA_DEFER_LINK)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\telse\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\nstruct ata_scsi_args {\n\tstruct ata_device\t*dev;\n\tu16\t\t\t*id;\n\tstruct scsi_cmnd\t*cmd;\n};\n\n \nstatic void ata_scsi_rbuf_fill(struct ata_scsi_args *args,\n\t\tunsigned int (*actor)(struct ata_scsi_args *args, u8 *rbuf))\n{\n\tunsigned int rc;\n\tstruct scsi_cmnd *cmd = args->cmd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ata_scsi_rbuf_lock, flags);\n\n\tmemset(ata_scsi_rbuf, 0, ATA_SCSI_RBUF_SIZE);\n\trc = actor(args, ata_scsi_rbuf);\n\tif (rc == 0)\n\t\tsg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\n\t\t\t\t    ata_scsi_rbuf, ATA_SCSI_RBUF_SIZE);\n\n\tspin_unlock_irqrestore(&ata_scsi_rbuf_lock, flags);\n\n\tif (rc == 0)\n\t\tcmd->result = SAM_STAT_GOOD;\n}\n\n \nstatic unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstatic const u8 versions[] = {\n\t\t0x00,\n\t\t0x60,\t \n\n\t\t0x03,\n\t\t0x20,\t \n\n\t\t0x03,\n\t\t0x00\t \n\t};\n\tstatic const u8 versions_zbc[] = {\n\t\t0x00,\n\t\t0xA0,\t \n\n\t\t0x06,\n\t\t0x00,\t \n\n\t\t0x05,\n\t\t0xC0,\t \n\n\t\t0x60,\n\t\t0x24,    \n\t};\n\n\tu8 hdr[] = {\n\t\tTYPE_DISK,\n\t\t0,\n\t\t0x5,\t \n\t\t2,\n\t\t95 - 4,\n\t\t0,\n\t\t0,\n\t\t2\n\t};\n\n\t \n\tif (ata_id_removable(args->id) ||\n\t    (args->dev->link->ap->pflags & ATA_PFLAG_EXTERNAL))\n\t\thdr[1] |= (1 << 7);\n\n\tif (args->dev->class == ATA_DEV_ZAC) {\n\t\thdr[0] = TYPE_ZBC;\n\t\thdr[2] = 0x7;  \n\t}\n\n\tif (args->dev->flags & ATA_DFLAG_CDL)\n\t\thdr[2] = 0xd;  \n\n\tmemcpy(rbuf, hdr, sizeof(hdr));\n\tmemcpy(&rbuf[8], \"ATA     \", 8);\n\tata_id_string(args->id, &rbuf[16], ATA_ID_PROD, 16);\n\n\t \n\tata_id_string(args->id, &rbuf[32], ATA_ID_FW_REV + 2, 4);\n\tif (strncmp(&rbuf[32], \"    \", 4) == 0)\n\t\tata_id_string(args->id, &rbuf[32], ATA_ID_FW_REV, 4);\n\n\tif (rbuf[32] == 0 || rbuf[32] == ' ')\n\t\tmemcpy(&rbuf[32], \"n/a \", 4);\n\n\tif (ata_id_zoned_cap(args->id) || args->dev->class == ATA_DEV_ZAC)\n\t\tmemcpy(rbuf + 58, versions_zbc, sizeof(versions_zbc));\n\telse\n\t\tmemcpy(rbuf + 58, versions, sizeof(versions));\n\n\treturn 0;\n}\n\n \nstatic unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tint i, num_pages = 0;\n\tstatic const u8 pages[] = {\n\t\t0x00,\t \n\t\t0x80,\t \n\t\t0x83,\t \n\t\t0x89,\t \n\t\t0xb0,\t \n\t\t0xb1,\t \n\t\t0xb2,\t \n\t\t0xb6,\t \n\t\t0xb9,\t \n\t};\n\n\tfor (i = 0; i < sizeof(pages); i++) {\n\t\tif (pages[i] == 0xb6 &&\n\t\t    !(args->dev->flags & ATA_DFLAG_ZAC))\n\t\t\tcontinue;\n\t\trbuf[num_pages + 4] = pages[i];\n\t\tnum_pages++;\n\t}\n\trbuf[3] = num_pages;\t \n\treturn 0;\n}\n\n \nstatic unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstatic const u8 hdr[] = {\n\t\t0,\n\t\t0x80,\t\t\t \n\t\t0,\n\t\tATA_ID_SERNO_LEN,\t \n\t};\n\n\tmemcpy(rbuf, hdr, sizeof(hdr));\n\tata_id_string(args->id, (unsigned char *) &rbuf[4],\n\t\t      ATA_ID_SERNO, ATA_ID_SERNO_LEN);\n\treturn 0;\n}\n\n \nstatic unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tconst int sat_model_serial_desc_len = 68;\n\tint num;\n\n\trbuf[1] = 0x83;\t\t\t \n\tnum = 4;\n\n\t \n\trbuf[num + 0] = 2;\n\trbuf[num + 3] = ATA_ID_SERNO_LEN;\n\tnum += 4;\n\tata_id_string(args->id, (unsigned char *) rbuf + num,\n\t\t      ATA_ID_SERNO, ATA_ID_SERNO_LEN);\n\tnum += ATA_ID_SERNO_LEN;\n\n\t \n\t \n\trbuf[num + 0] = 2;\n\trbuf[num + 1] = 1;\n\trbuf[num + 3] = sat_model_serial_desc_len;\n\tnum += 4;\n\tmemcpy(rbuf + num, \"ATA     \", 8);\n\tnum += 8;\n\tata_id_string(args->id, (unsigned char *) rbuf + num, ATA_ID_PROD,\n\t\t      ATA_ID_PROD_LEN);\n\tnum += ATA_ID_PROD_LEN;\n\tata_id_string(args->id, (unsigned char *) rbuf + num, ATA_ID_SERNO,\n\t\t      ATA_ID_SERNO_LEN);\n\tnum += ATA_ID_SERNO_LEN;\n\n\tif (ata_id_has_wwn(args->id)) {\n\t\t \n\t\t \n\t\trbuf[num + 0] = 1;\n\t\trbuf[num + 1] = 3;\n\t\trbuf[num + 3] = ATA_ID_WWN_LEN;\n\t\tnum += 4;\n\t\tata_id_string(args->id, (unsigned char *) rbuf + num,\n\t\t\t      ATA_ID_WWN, ATA_ID_WWN_LEN);\n\t\tnum += ATA_ID_WWN_LEN;\n\t}\n\trbuf[3] = num - 4;     \n\treturn 0;\n}\n\n \nstatic unsigned int ata_scsiop_inq_89(struct ata_scsi_args *args, u8 *rbuf)\n{\n\trbuf[1] = 0x89;\t\t\t \n\trbuf[2] = (0x238 >> 8);\t\t \n\trbuf[3] = (0x238 & 0xff);\n\n\tmemcpy(&rbuf[8], \"linux   \", 8);\n\tmemcpy(&rbuf[16], \"libata          \", 16);\n\tmemcpy(&rbuf[32], DRV_VERSION, 4);\n\n\trbuf[36] = 0x34;\t\t \n\trbuf[37] = (1 << 7);\t\t \n\t\t\t\t\t \n\n\t \n\trbuf[38] = ATA_DRDY;\t\t \n\trbuf[40] = 0x1;\n\trbuf[48] = 0x1;\n\n\trbuf[56] = ATA_CMD_ID_ATA;\n\n\tmemcpy(&rbuf[60], &args->id[0], 512);\n\treturn 0;\n}\n\nstatic unsigned int ata_scsiop_inq_b0(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstruct ata_device *dev = args->dev;\n\tu16 min_io_sectors;\n\n\trbuf[1] = 0xb0;\n\trbuf[3] = 0x3c;\t\t \n\n\t \n\tmin_io_sectors = 1 << ata_id_log2_per_physical_sector(args->id);\n\tput_unaligned_be16(min_io_sectors, &rbuf[6]);\n\n\t \n\tif (ata_id_has_trim(args->id)) {\n\t\tu64 max_blocks = 65535 * ATA_MAX_TRIM_RNUM;\n\n\t\tif (dev->horkage & ATA_HORKAGE_MAX_TRIM_128M)\n\t\t\tmax_blocks = 128 << (20 - SECTOR_SHIFT);\n\n\t\tput_unaligned_be64(max_blocks, &rbuf[36]);\n\t\tput_unaligned_be32(1, &rbuf[28]);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int ata_scsiop_inq_b1(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tint form_factor = ata_id_form_factor(args->id);\n\tint media_rotation_rate = ata_id_rotation_rate(args->id);\n\tu8 zoned = ata_id_zoned_cap(args->id);\n\n\trbuf[1] = 0xb1;\n\trbuf[3] = 0x3c;\n\trbuf[4] = media_rotation_rate >> 8;\n\trbuf[5] = media_rotation_rate;\n\trbuf[7] = form_factor;\n\tif (zoned)\n\t\trbuf[8] = (zoned << 4);\n\n\treturn 0;\n}\n\nstatic unsigned int ata_scsiop_inq_b2(struct ata_scsi_args *args, u8 *rbuf)\n{\n\t \n\trbuf[1] = 0xb2;\n\trbuf[3] = 0x4;\n\trbuf[5] = 1 << 6;\t \n\n\treturn 0;\n}\n\nstatic unsigned int ata_scsiop_inq_b6(struct ata_scsi_args *args, u8 *rbuf)\n{\n\t \n\trbuf[1] = 0xb6;\n\trbuf[3] = 0x3C;\n\n\t \n\tif (args->dev->zac_zoned_cap & 1)\n\t\trbuf[4] |= 1;\n\tput_unaligned_be32(args->dev->zac_zones_optimal_open, &rbuf[8]);\n\tput_unaligned_be32(args->dev->zac_zones_optimal_nonseq, &rbuf[12]);\n\tput_unaligned_be32(args->dev->zac_zones_max_open, &rbuf[16]);\n\n\treturn 0;\n}\n\nstatic unsigned int ata_scsiop_inq_b9(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstruct ata_cpr_log *cpr_log = args->dev->cpr_log;\n\tu8 *desc = &rbuf[64];\n\tint i;\n\n\t \n\trbuf[1] = 0xb9;\n\tput_unaligned_be16(64 + (int)cpr_log->nr_cpr * 32 - 4, &rbuf[2]);\n\n\tfor (i = 0; i < cpr_log->nr_cpr; i++, desc += 32) {\n\t\tdesc[0] = cpr_log->cpr[i].num;\n\t\tdesc[1] = cpr_log->cpr[i].num_storage_elements;\n\t\tput_unaligned_be64(cpr_log->cpr[i].start_lba, &desc[8]);\n\t\tput_unaligned_be64(cpr_log->cpr[i].num_lbas, &desc[16]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void modecpy(u8 *dest, const u8 *src, int n, bool changeable)\n{\n\tif (changeable) {\n\t\tmemcpy(dest, src, 2);\n\t\tmemset(dest + 2, 0, n - 2);\n\t} else {\n\t\tmemcpy(dest, src, n);\n\t}\n}\n\n \nstatic unsigned int ata_msense_caching(u16 *id, u8 *buf, bool changeable)\n{\n\tmodecpy(buf, def_cache_mpage, sizeof(def_cache_mpage), changeable);\n\tif (changeable) {\n\t\tbuf[2] |= (1 << 2);\t \n\t} else {\n\t\tbuf[2] |= (ata_id_wcache_enabled(id) << 2);\t \n\t\tbuf[12] |= (!ata_id_rahead_enabled(id) << 5);\t \n\t}\n\treturn sizeof(def_cache_mpage);\n}\n\n \nstatic unsigned int ata_msense_control_spg0(struct ata_device *dev, u8 *buf,\n\t\t\t\t\t    bool changeable)\n{\n\tmodecpy(buf, def_control_mpage,\n\t\tsizeof(def_control_mpage), changeable);\n\tif (changeable) {\n\t\t \n\t\tbuf[2] |= (1 << 2);\n\t} else {\n\t\tbool d_sense = (dev->flags & ATA_DFLAG_D_SENSE);\n\n\t\t \n\t\tbuf[2] |= (d_sense << 2);\n\t}\n\n\treturn sizeof(def_control_mpage);\n}\n\n \nstatic inline u16 ata_xlat_cdl_limit(u8 *buf)\n{\n\tu32 limit = get_unaligned_le32(buf);\n\n\treturn min_t(u32, limit / 10000, 65535);\n}\n\n \nstatic unsigned int ata_msense_control_spgt2(struct ata_device *dev, u8 *buf,\n\t\t\t\t\t     u8 spg)\n{\n\tu8 *b, *cdl = dev->cdl, *desc;\n\tu32 policy;\n\tint i;\n\n\t \n\tbuf[0] = CONTROL_MPAGE;\n\tbuf[1] = spg;\n\tput_unaligned_be16(CDL_T2_SUB_MPAGE_LEN - 4, &buf[2]);\n\tif (spg == CDL_T2A_SUB_MPAGE) {\n\t\t \n\t\tbuf[7] = (cdl[0] & 0x03) << 4;\n\t\tdesc = cdl + 64;\n\t} else {\n\t\t \n\t\tdesc = cdl + 288;\n\t}\n\n\t \n\tb = &buf[8];\n\tpolicy = get_unaligned_le32(&cdl[0]);\n\tfor (i = 0; i < 7; i++, b += 32, desc += 32) {\n\t\t \n\t\tb[0] = 0x0a;\n\n\t\t \n\t\tput_unaligned_be16(ata_xlat_cdl_limit(&desc[8]), &b[2]);\n\t\tb[6] = ((policy >> 8) & 0x0f) << 4;\n\n\t\t \n\t\tput_unaligned_be16(ata_xlat_cdl_limit(&desc[4]), &b[4]);\n\t\tb[6] |= (policy >> 4) & 0x0f;\n\n\t\t \n\t\tput_unaligned_be16(ata_xlat_cdl_limit(&desc[16]), &b[10]);\n\t\tb[14] = policy & 0x0f;\n\t}\n\n\treturn CDL_T2_SUB_MPAGE_LEN;\n}\n\n \nstatic unsigned int ata_msense_control_ata_feature(struct ata_device *dev,\n\t\t\t\t\t\t   u8 *buf)\n{\n\t \n\tbuf[0] = CONTROL_MPAGE | (1 << 6);\n\tbuf[1] = ATA_FEATURE_SUB_MPAGE;\n\n\t \n\tput_unaligned_be16(ATA_FEATURE_SUB_MPAGE_LEN - 4, &buf[2]);\n\n\tif (dev->flags & ATA_DFLAG_CDL)\n\t\tbuf[4] = 0x02;  \n\telse\n\t\tbuf[4] = 0;\n\n\treturn ATA_FEATURE_SUB_MPAGE_LEN;\n}\n\n \nstatic unsigned int ata_msense_control(struct ata_device *dev, u8 *buf,\n\t\t\t\t       u8 spg, bool changeable)\n{\n\tunsigned int n;\n\n\tswitch (spg) {\n\tcase 0:\n\t\treturn ata_msense_control_spg0(dev, buf, changeable);\n\tcase CDL_T2A_SUB_MPAGE:\n\tcase CDL_T2B_SUB_MPAGE:\n\t\treturn ata_msense_control_spgt2(dev, buf, spg);\n\tcase ATA_FEATURE_SUB_MPAGE:\n\t\treturn ata_msense_control_ata_feature(dev, buf);\n\tcase ALL_SUB_MPAGES:\n\t\tn = ata_msense_control_spg0(dev, buf, changeable);\n\t\tn += ata_msense_control_spgt2(dev, buf + n, CDL_T2A_SUB_MPAGE);\n\t\tn += ata_msense_control_spgt2(dev, buf + n, CDL_T2A_SUB_MPAGE);\n\t\tn += ata_msense_control_ata_feature(dev, buf + n);\n\t\treturn n;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic unsigned int ata_msense_rw_recovery(u8 *buf, bool changeable)\n{\n\tmodecpy(buf, def_rw_recovery_mpage, sizeof(def_rw_recovery_mpage),\n\t\tchangeable);\n\treturn sizeof(def_rw_recovery_mpage);\n}\n\n \nstatic unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstruct ata_device *dev = args->dev;\n\tu8 *scsicmd = args->cmd->cmnd, *p = rbuf;\n\tstatic const u8 sat_blk_desc[] = {\n\t\t0, 0, 0, 0,\t \n\t\t0,\n\t\t0, 0x2, 0x0\t \n\t};\n\tu8 pg, spg;\n\tunsigned int ebd, page_control, six_byte;\n\tu8 dpofua = 0, bp = 0xff;\n\tu16 fp;\n\n\tsix_byte = (scsicmd[0] == MODE_SENSE);\n\tebd = !(scsicmd[1] & 0x8);       \n\t \n\n\tpage_control = scsicmd[2] >> 6;\n\tswitch (page_control) {\n\tcase 0:  \n\tcase 1:  \n\tcase 2:  \n\t\tbreak;   \n\tcase 3:  \n\t\tgoto saving_not_supp;\n\tdefault:\n\t\tfp = 2;\n\t\tbp = 6;\n\t\tgoto invalid_fld;\n\t}\n\n\tif (six_byte)\n\t\tp += 4 + (ebd ? 8 : 0);\n\telse\n\t\tp += 8 + (ebd ? 8 : 0);\n\n\tpg = scsicmd[2] & 0x3f;\n\tspg = scsicmd[3];\n\n\t \n\tif (spg) {\n\t\tswitch (spg) {\n\t\tcase ALL_SUB_MPAGES:\n\t\t\tbreak;\n\t\tcase CDL_T2A_SUB_MPAGE:\n\t\tcase CDL_T2B_SUB_MPAGE:\n\t\tcase ATA_FEATURE_SUB_MPAGE:\n\t\t\tif (dev->flags & ATA_DFLAG_CDL && pg == CONTROL_MPAGE)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tfp = 3;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t}\n\n\tswitch(pg) {\n\tcase RW_RECOVERY_MPAGE:\n\t\tp += ata_msense_rw_recovery(p, page_control == 1);\n\t\tbreak;\n\n\tcase CACHE_MPAGE:\n\t\tp += ata_msense_caching(args->id, p, page_control == 1);\n\t\tbreak;\n\n\tcase CONTROL_MPAGE:\n\t\tp += ata_msense_control(args->dev, p, spg, page_control == 1);\n\t\tbreak;\n\n\tcase ALL_MPAGES:\n\t\tp += ata_msense_rw_recovery(p, page_control == 1);\n\t\tp += ata_msense_caching(args->id, p, page_control == 1);\n\t\tp += ata_msense_control(args->dev, p, spg, page_control == 1);\n\t\tbreak;\n\n\tdefault:\t\t \n\t\tfp = 2;\n\t\tgoto invalid_fld;\n\t}\n\n\tif (dev->flags & ATA_DFLAG_FUA)\n\t\tdpofua = 1 << 4;\n\n\tif (six_byte) {\n\t\trbuf[0] = p - rbuf - 1;\n\t\trbuf[2] |= dpofua;\n\t\tif (ebd) {\n\t\t\trbuf[3] = sizeof(sat_blk_desc);\n\t\t\tmemcpy(rbuf + 4, sat_blk_desc, sizeof(sat_blk_desc));\n\t\t}\n\t} else {\n\t\tput_unaligned_be16(p - rbuf - 2, &rbuf[0]);\n\t\trbuf[3] |= dpofua;\n\t\tif (ebd) {\n\t\t\trbuf[7] = sizeof(sat_blk_desc);\n\t\t\tmemcpy(rbuf + 8, sat_blk_desc, sizeof(sat_blk_desc));\n\t\t}\n\t}\n\treturn 0;\n\ninvalid_fld:\n\tata_scsi_set_invalid_field(dev, args->cmd, fp, bp);\n\treturn 1;\n\nsaving_not_supp:\n\tata_scsi_set_sense(dev, args->cmd, ILLEGAL_REQUEST, 0x39, 0x0);\n\t  \n\treturn 1;\n}\n\n \nstatic unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstruct ata_device *dev = args->dev;\n\tu64 last_lba = dev->n_sectors - 1;  \n\tu32 sector_size;  \n\tu8 log2_per_phys;\n\tu16 lowest_aligned;\n\n\tsector_size = ata_id_logical_sector_size(dev->id);\n\tlog2_per_phys = ata_id_log2_per_physical_sector(dev->id);\n\tlowest_aligned = ata_id_logical_sector_offset(dev->id, log2_per_phys);\n\n\tif (args->cmd->cmnd[0] == READ_CAPACITY) {\n\t\tif (last_lba >= 0xffffffffULL)\n\t\t\tlast_lba = 0xffffffff;\n\n\t\t \n\t\trbuf[0] = last_lba >> (8 * 3);\n\t\trbuf[1] = last_lba >> (8 * 2);\n\t\trbuf[2] = last_lba >> (8 * 1);\n\t\trbuf[3] = last_lba;\n\n\t\t \n\t\trbuf[4] = sector_size >> (8 * 3);\n\t\trbuf[5] = sector_size >> (8 * 2);\n\t\trbuf[6] = sector_size >> (8 * 1);\n\t\trbuf[7] = sector_size;\n\t} else {\n\t\t \n\t\trbuf[0] = last_lba >> (8 * 7);\n\t\trbuf[1] = last_lba >> (8 * 6);\n\t\trbuf[2] = last_lba >> (8 * 5);\n\t\trbuf[3] = last_lba >> (8 * 4);\n\t\trbuf[4] = last_lba >> (8 * 3);\n\t\trbuf[5] = last_lba >> (8 * 2);\n\t\trbuf[6] = last_lba >> (8 * 1);\n\t\trbuf[7] = last_lba;\n\n\t\t \n\t\trbuf[ 8] = sector_size >> (8 * 3);\n\t\trbuf[ 9] = sector_size >> (8 * 2);\n\t\trbuf[10] = sector_size >> (8 * 1);\n\t\trbuf[11] = sector_size;\n\n\t\trbuf[12] = 0;\n\t\trbuf[13] = log2_per_phys;\n\t\trbuf[14] = (lowest_aligned >> 8) & 0x3f;\n\t\trbuf[15] = lowest_aligned;\n\n\t\tif (ata_id_has_trim(args->id) &&\n\t\t    !(dev->horkage & ATA_HORKAGE_NOTRIM)) {\n\t\t\trbuf[14] |= 0x80;  \n\n\t\t\tif (ata_id_has_zero_after_trim(args->id) &&\n\t\t\t    dev->horkage & ATA_HORKAGE_ZERO_AFTER_TRIM) {\n\t\t\t\tata_dev_info(dev, \"Enabling discard_zeroes_data\\n\");\n\t\t\t\trbuf[14] |= 0x40;  \n\t\t\t}\n\t\t}\n\t\tif (ata_id_zoned_cap(args->id) ||\n\t\t    args->dev->class == ATA_DEV_ZAC)\n\t\t\trbuf[12] = (1 << 4);  \n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf)\n{\n\trbuf[3] = 8;\t \n\n\treturn 0;\n}\n\n \nstatic void atapi_fixup_inquiry(struct scsi_cmnd *cmd)\n{\n\tu8 buf[4];\n\n\tsg_copy_to_buffer(scsi_sglist(cmd), scsi_sg_count(cmd), buf, 4);\n\tif (buf[2] == 0) {\n\t\tbuf[2] = 0x5;\n\t\tbuf[3] = 0x32;\n\t}\n\tsg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd), buf, 4);\n}\n\nstatic void atapi_qc_complete(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *cmd = qc->scsicmd;\n\tunsigned int err_mask = qc->err_mask;\n\n\t \n\tif (unlikely(err_mask || qc->flags & ATA_QCFLAG_SENSE_VALID)) {\n\n\t\tif (!(qc->flags & ATA_QCFLAG_SENSE_VALID)) {\n\t\t\t \n\t\t\tata_gen_passthru_sense(qc);\n\t\t}\n\n\t\t \n\t\tif (qc->cdb[0] == ALLOW_MEDIUM_REMOVAL && qc->dev->sdev)\n\t\t\tqc->dev->sdev->locked = 0;\n\n\t\tqc->scsicmd->result = SAM_STAT_CHECK_CONDITION;\n\t\tata_qc_done(qc);\n\t\treturn;\n\t}\n\n\t \n\tif (cmd->cmnd[0] == INQUIRY && (cmd->cmnd[1] & 0x03) == 0)\n\t\tatapi_fixup_inquiry(cmd);\n\tcmd->result = SAM_STAT_GOOD;\n\n\tata_qc_done(qc);\n}\n \nstatic unsigned int atapi_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct ata_device *dev = qc->dev;\n\tint nodata = (scmd->sc_data_direction == DMA_NONE);\n\tint using_pio = !nodata && (dev->flags & ATA_DFLAG_PIO);\n\tunsigned int nbytes;\n\n\tmemset(qc->cdb, 0, dev->cdb_len);\n\tmemcpy(qc->cdb, scmd->cmnd, scmd->cmd_len);\n\n\tqc->complete_fn = atapi_qc_complete;\n\n\tqc->tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\tif (scmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tqc->tf.flags |= ATA_TFLAG_WRITE;\n\t}\n\n\tqc->tf.command = ATA_CMD_PACKET;\n\tata_qc_set_pc_nbytes(qc);\n\n\t \n\tif (!nodata && !using_pio && atapi_check_dma(qc))\n\t\tusing_pio = 1;\n\n\t \n\tnbytes = min(ata_qc_raw_nbytes(qc), (unsigned int)63 * 1024);\n\n\t \n\tif (nbytes & 0x1)\n\t\tnbytes++;\n\n\tqc->tf.lbam = (nbytes & 0xFF);\n\tqc->tf.lbah = (nbytes >> 8);\n\n\tif (nodata)\n\t\tqc->tf.protocol = ATAPI_PROT_NODATA;\n\telse if (using_pio)\n\t\tqc->tf.protocol = ATAPI_PROT_PIO;\n\telse {\n\t\t \n\t\tqc->tf.protocol = ATAPI_PROT_DMA;\n\t\tqc->tf.feature |= ATAPI_PKT_DMA;\n\n\t\tif ((dev->flags & ATA_DFLAG_DMADIR) &&\n\t\t    (scmd->sc_data_direction != DMA_TO_DEVICE))\n\t\t\t \n\t\t\tqc->tf.feature |= ATAPI_DMADIR;\n\t}\n\n\n\t \n\treturn 0;\n}\n\nstatic struct ata_device *ata_find_dev(struct ata_port *ap, unsigned int devno)\n{\n\t \n\tif (likely(!sata_pmp_attached(ap))) {\n\t\tint link_max_devices = ata_link_max_devices(&ap->link);\n\n\t\tif (link_max_devices == 1)\n\t\t\treturn &ap->link.device[0];\n\n\t\tif (devno < link_max_devices)\n\t\t\treturn &ap->link.device[devno];\n\n\t\treturn NULL;\n\t}\n\n\t \n\tif (devno < ap->nr_pmp_links)\n\t\treturn &ap->pmp_link[devno].device[0];\n\n\treturn NULL;\n}\n\nstatic struct ata_device *__ata_scsi_find_dev(struct ata_port *ap,\n\t\t\t\t\t      const struct scsi_device *scsidev)\n{\n\tint devno;\n\n\t \n\tif (!sata_pmp_attached(ap)) {\n\t\tif (unlikely(scsidev->channel || scsidev->lun))\n\t\t\treturn NULL;\n\t\tdevno = scsidev->id;\n\t} else {\n\t\tif (unlikely(scsidev->id || scsidev->lun))\n\t\t\treturn NULL;\n\t\tdevno = scsidev->channel;\n\t}\n\n\treturn ata_find_dev(ap, devno);\n}\n\n \nstruct ata_device *\nata_scsi_find_dev(struct ata_port *ap, const struct scsi_device *scsidev)\n{\n\tstruct ata_device *dev = __ata_scsi_find_dev(ap, scsidev);\n\n\tif (unlikely(!dev || !ata_dev_enabled(dev)))\n\t\treturn NULL;\n\n\treturn dev;\n}\n\n \nstatic u8\nata_scsi_map_proto(u8 byte1)\n{\n\tswitch((byte1 & 0x1e) >> 1) {\n\tcase 3:\t\t \n\t\treturn ATA_PROT_NODATA;\n\n\tcase 6:\t\t \n\tcase 10:\t \n\tcase 11:\t \n\t\treturn ATA_PROT_DMA;\n\n\tcase 4:\t\t \n\tcase 5:\t\t \n\t\treturn ATA_PROT_PIO;\n\n\tcase 12:\t \n\t\treturn ATA_PROT_NCQ;\n\n\tcase 0:\t\t \n\tcase 1:\t\t \n\tcase 8:\t\t \n\tcase 9:\t\t \n\tcase 7:\t\t \n\tcase 15:\t \n\tdefault:\t \n\t\tbreak;\n\t}\n\n\treturn ATA_PROT_UNKNOWN;\n}\n\n \nstatic unsigned int ata_scsi_pass_thru(struct ata_queued_cmd *qc)\n{\n\tstruct ata_taskfile *tf = &(qc->tf);\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct ata_device *dev = qc->dev;\n\tconst u8 *cdb = scmd->cmnd;\n\tu16 fp;\n\tu16 cdb_offset = 0;\n\n\t \n\tif (cdb[0] == VARIABLE_LENGTH_CMD)\n\t\tcdb_offset = 9;\n\n\ttf->protocol = ata_scsi_map_proto(cdb[1 + cdb_offset]);\n\tif (tf->protocol == ATA_PROT_UNKNOWN) {\n\t\tfp = 1;\n\t\tgoto invalid_fld;\n\t}\n\n\tif ((cdb[2 + cdb_offset] & 0x3) == 0) {\n\t\t \n\t\tif (scmd->sc_data_direction != DMA_NONE) {\n\t\t\tfp = 2 + cdb_offset;\n\t\t\tgoto invalid_fld;\n\t\t}\n\n\t\tif (ata_is_ncq(tf->protocol))\n\t\t\ttf->protocol = ATA_PROT_NCQ_NODATA;\n\t}\n\n\t \n\ttf->flags |= ATA_TFLAG_LBA;\n\n\t \n\tswitch (cdb[0]) {\n\tcase ATA_16:\n\t\t \n\t\tif (cdb[1] & 0x01) {\n\t\t\ttf->hob_feature = cdb[3];\n\t\t\ttf->hob_nsect = cdb[5];\n\t\t\ttf->hob_lbal = cdb[7];\n\t\t\ttf->hob_lbam = cdb[9];\n\t\t\ttf->hob_lbah = cdb[11];\n\t\t\ttf->flags |= ATA_TFLAG_LBA48;\n\t\t} else\n\t\t\ttf->flags &= ~ATA_TFLAG_LBA48;\n\n\t\t \n\t\ttf->feature = cdb[4];\n\t\ttf->nsect = cdb[6];\n\t\ttf->lbal = cdb[8];\n\t\ttf->lbam = cdb[10];\n\t\ttf->lbah = cdb[12];\n\t\ttf->device = cdb[13];\n\t\ttf->command = cdb[14];\n\t\tbreak;\n\tcase ATA_12:\n\t\t \n\t\ttf->flags &= ~ATA_TFLAG_LBA48;\n\n\t\ttf->feature = cdb[3];\n\t\ttf->nsect = cdb[4];\n\t\ttf->lbal = cdb[5];\n\t\ttf->lbam = cdb[6];\n\t\ttf->lbah = cdb[7];\n\t\ttf->device = cdb[8];\n\t\ttf->command = cdb[9];\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (cdb[10] & 0x01) {\n\t\t\ttf->hob_feature = cdb[20];\n\t\t\ttf->hob_nsect = cdb[22];\n\t\t\ttf->hob_lbal = cdb[16];\n\t\t\ttf->hob_lbam = cdb[15];\n\t\t\ttf->hob_lbah = cdb[14];\n\t\t\ttf->flags |= ATA_TFLAG_LBA48;\n\t\t} else\n\t\t\ttf->flags &= ~ATA_TFLAG_LBA48;\n\n\t\ttf->feature = cdb[21];\n\t\ttf->nsect = cdb[23];\n\t\ttf->lbal = cdb[19];\n\t\ttf->lbam = cdb[18];\n\t\ttf->lbah = cdb[17];\n\t\ttf->device = cdb[24];\n\t\ttf->command = cdb[25];\n\t\ttf->auxiliary = get_unaligned_be32(&cdb[28]);\n\t\tbreak;\n\t}\n\n\t \n\tif (ata_is_ncq(tf->protocol))\n\t\ttf->nsect = qc->hw_tag << 3;\n\n\t \n\ttf->device = dev->devno ?\n\t\ttf->device | ATA_DEV1 : tf->device & ~ATA_DEV1;\n\n\tswitch (tf->command) {\n\t \n\tcase ATA_CMD_READ_LONG:\n\tcase ATA_CMD_READ_LONG_ONCE:\n\tcase ATA_CMD_WRITE_LONG:\n\tcase ATA_CMD_WRITE_LONG_ONCE:\n\t\tif (tf->protocol != ATA_PROT_PIO || tf->nsect != 1) {\n\t\t\tfp = 1;\n\t\t\tgoto invalid_fld;\n\t\t}\n\t\tqc->sect_size = scsi_bufflen(scmd);\n\t\tbreak;\n\n\t \n\tcase ATA_CMD_CFA_WRITE_NE:\n\tcase ATA_CMD_CFA_TRANS_SECT:\n\tcase ATA_CMD_CFA_WRITE_MULT_NE:\n\t \n\tcase ATA_CMD_READ:\n\tcase ATA_CMD_READ_EXT:\n\tcase ATA_CMD_READ_QUEUED:\n\t \n\tcase ATA_CMD_FPDMA_READ:\n\tcase ATA_CMD_READ_MULTI:\n\tcase ATA_CMD_READ_MULTI_EXT:\n\tcase ATA_CMD_PIO_READ:\n\tcase ATA_CMD_PIO_READ_EXT:\n\tcase ATA_CMD_READ_STREAM_DMA_EXT:\n\tcase ATA_CMD_READ_STREAM_EXT:\n\tcase ATA_CMD_VERIFY:\n\tcase ATA_CMD_VERIFY_EXT:\n\tcase ATA_CMD_WRITE:\n\tcase ATA_CMD_WRITE_EXT:\n\tcase ATA_CMD_WRITE_FUA_EXT:\n\tcase ATA_CMD_WRITE_QUEUED:\n\tcase ATA_CMD_WRITE_QUEUED_FUA_EXT:\n\tcase ATA_CMD_FPDMA_WRITE:\n\tcase ATA_CMD_WRITE_MULTI:\n\tcase ATA_CMD_WRITE_MULTI_EXT:\n\tcase ATA_CMD_WRITE_MULTI_FUA_EXT:\n\tcase ATA_CMD_PIO_WRITE:\n\tcase ATA_CMD_PIO_WRITE_EXT:\n\tcase ATA_CMD_WRITE_STREAM_DMA_EXT:\n\tcase ATA_CMD_WRITE_STREAM_EXT:\n\t\tqc->sect_size = scmd->device->sector_size;\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tqc->sect_size = ATA_SECT_SIZE;\n\t}\n\n\t \n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\n\tif (scmd->sc_data_direction == DMA_TO_DEVICE)\n\t\ttf->flags |= ATA_TFLAG_WRITE;\n\n\tqc->flags |= ATA_QCFLAG_RESULT_TF | ATA_QCFLAG_QUIET;\n\n\t \n\tata_qc_set_pc_nbytes(qc);\n\n\t \n\tif (tf->protocol == ATA_PROT_DMA && !ata_dma_enabled(dev)) {\n\t\tfp = 1;\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tif (ata_is_ncq(tf->protocol) && !ata_ncq_enabled(dev)) {\n\t\tfp = 1;\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tif ((cdb[1] & 0xe0) && !is_multi_taskfile(tf)) {\n\t\tfp = 1;\n\t\tgoto invalid_fld;\n\t}\n\n\tif (is_multi_taskfile(tf)) {\n\t\tunsigned int multi_count = 1 << (cdb[1] >> 5);\n\n\t\t \n\t\tif (multi_count != dev->multi_count)\n\t\t\tata_dev_warn(dev, \"invalid multi_count %u ignored\\n\",\n\t\t\t\t     multi_count);\n\t}\n\n\t \n\tif (tf->command == ATA_CMD_SET_FEATURES &&\n\t    tf->feature == SETFEATURES_XFER) {\n\t\tfp = (cdb[0] == ATA_16) ? 4 : 3;\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tif (tf->command >= 0x5C && tf->command <= 0x5F && !libata_allow_tpm) {\n\t\tfp = (cdb[0] == ATA_16) ? 14 : 9;\n\t\tgoto invalid_fld;\n\t}\n\n\treturn 0;\n\n invalid_fld:\n\tata_scsi_set_invalid_field(dev, scmd, fp, 0xff);\n\treturn 1;\n}\n\n \nstatic size_t ata_format_dsm_trim_descr(struct scsi_cmnd *cmd, u32 trmax,\n\t\t\t\t\tu64 sector, u32 count)\n{\n\tstruct scsi_device *sdp = cmd->device;\n\tsize_t len = sdp->sector_size;\n\tsize_t r;\n\t__le64 *buf;\n\tu32 i = 0;\n\tunsigned long flags;\n\n\tWARN_ON(len > ATA_SCSI_RBUF_SIZE);\n\n\tif (len > ATA_SCSI_RBUF_SIZE)\n\t\tlen = ATA_SCSI_RBUF_SIZE;\n\n\tspin_lock_irqsave(&ata_scsi_rbuf_lock, flags);\n\tbuf = ((void *)ata_scsi_rbuf);\n\tmemset(buf, 0, len);\n\twhile (i < trmax) {\n\t\tu64 entry = sector |\n\t\t\t((u64)(count > 0xffff ? 0xffff : count) << 48);\n\t\tbuf[i++] = __cpu_to_le64(entry);\n\t\tif (count <= 0xffff)\n\t\t\tbreak;\n\t\tcount -= 0xffff;\n\t\tsector += 0xffff;\n\t}\n\tr = sg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd), buf, len);\n\tspin_unlock_irqrestore(&ata_scsi_rbuf_lock, flags);\n\n\treturn r;\n}\n\n \nstatic unsigned int ata_scsi_write_same_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct scsi_device *sdp = scmd->device;\n\tsize_t len = sdp->sector_size;\n\tstruct ata_device *dev = qc->dev;\n\tconst u8 *cdb = scmd->cmnd;\n\tu64 block;\n\tu32 n_block;\n\tconst u32 trmax = len >> 3;\n\tu32 size;\n\tu16 fp;\n\tu8 bp = 0xff;\n\tu8 unmap = cdb[1] & 0x8;\n\n\t \n\tif (unlikely(!ata_dma_enabled(dev)))\n\t\tgoto invalid_opcode;\n\n\t \n\tif (unlikely(blk_rq_is_passthrough(scsi_cmd_to_rq(scmd))))\n\t\tgoto invalid_opcode;\n\n\tif (unlikely(scmd->cmd_len < 16)) {\n\t\tfp = 15;\n\t\tgoto invalid_fld;\n\t}\n\tscsi_16_lba_len(cdb, &block, &n_block);\n\n\tif (!unmap ||\n\t    (dev->horkage & ATA_HORKAGE_NOTRIM) ||\n\t    !ata_id_has_trim(dev->id)) {\n\t\tfp = 1;\n\t\tbp = 3;\n\t\tgoto invalid_fld;\n\t}\n\t \n\tif (n_block > 0xffff * trmax) {\n\t\tfp = 2;\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tif (!scsi_sg_count(scmd))\n\t\tgoto invalid_param_len;\n\n\t \n\n\tsize = ata_format_dsm_trim_descr(scmd, trmax, block, n_block);\n\tif (size != len)\n\t\tgoto invalid_param_len;\n\n\tif (ata_ncq_enabled(dev) && ata_fpdma_dsm_supported(dev)) {\n\t\t \n\t\ttf->protocol = ATA_PROT_NCQ;\n\t\ttf->command = ATA_CMD_FPDMA_SEND;\n\t\ttf->hob_nsect = ATA_SUBCMD_FPDMA_SEND_DSM & 0x1f;\n\t\ttf->nsect = qc->hw_tag << 3;\n\t\ttf->hob_feature = (size / 512) >> 8;\n\t\ttf->feature = size / 512;\n\n\t\ttf->auxiliary = 1;\n\t} else {\n\t\ttf->protocol = ATA_PROT_DMA;\n\t\ttf->hob_feature = 0;\n\t\ttf->feature = ATA_DSM_TRIM;\n\t\ttf->hob_nsect = (size / 512) >> 8;\n\t\ttf->nsect = size / 512;\n\t\ttf->command = ATA_CMD_DSM;\n\t}\n\n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 |\n\t\t     ATA_TFLAG_WRITE;\n\n\tata_qc_set_pc_nbytes(qc);\n\n\treturn 0;\n\ninvalid_fld:\n\tata_scsi_set_invalid_field(dev, scmd, fp, bp);\n\treturn 1;\ninvalid_param_len:\n\t \n\tata_scsi_set_sense(dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\n\treturn 1;\ninvalid_opcode:\n\t \n\tata_scsi_set_sense(dev, scmd, ILLEGAL_REQUEST, 0x20, 0x0);\n\treturn 1;\n}\n\n \nstatic unsigned int ata_scsiop_maint_in(struct ata_scsi_args *args, u8 *rbuf)\n{\n\tstruct ata_device *dev = args->dev;\n\tu8 *cdb = args->cmd->cmnd;\n\tu8 supported = 0, cdlp = 0, rwcdlp = 0;\n\tunsigned int err = 0;\n\n\tif (cdb[2] != 1 && cdb[2] != 3) {\n\t\tata_dev_warn(dev, \"invalid command format %d\\n\", cdb[2]);\n\t\terr = 2;\n\t\tgoto out;\n\t}\n\n\tswitch (cdb[3]) {\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\tcase READ_CAPACITY:\n\tcase SERVICE_ACTION_IN_16:\n\tcase REPORT_LUNS:\n\tcase REQUEST_SENSE:\n\tcase SYNCHRONIZE_CACHE:\n\tcase SYNCHRONIZE_CACHE_16:\n\tcase REZERO_UNIT:\n\tcase SEEK_6:\n\tcase SEEK_10:\n\tcase TEST_UNIT_READY:\n\tcase SEND_DIAGNOSTIC:\n\tcase MAINTENANCE_IN:\n\tcase READ_6:\n\tcase READ_10:\n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase ATA_12:\n\tcase ATA_16:\n\tcase VERIFY:\n\tcase VERIFY_16:\n\tcase MODE_SELECT:\n\tcase MODE_SELECT_10:\n\tcase START_STOP:\n\t\tsupported = 3;\n\t\tbreak;\n\tcase READ_16:\n\t\tsupported = 3;\n\t\tif (dev->flags & ATA_DFLAG_CDL) {\n\t\t\t \n\t\t\trwcdlp = 0x01;\n\t\t\tcdlp = 0x01 << 3;\n\t\t}\n\t\tbreak;\n\tcase WRITE_16:\n\t\tsupported = 3;\n\t\tif (dev->flags & ATA_DFLAG_CDL) {\n\t\t\t \n\t\t\trwcdlp = 0x01;\n\t\t\tcdlp = 0x02 << 3;\n\t\t}\n\t\tbreak;\n\tcase ZBC_IN:\n\tcase ZBC_OUT:\n\t\tif (ata_id_zoned_cap(dev->id) ||\n\t\t    dev->class == ATA_DEV_ZAC)\n\t\t\tsupported = 3;\n\t\tbreak;\n\tcase SECURITY_PROTOCOL_IN:\n\tcase SECURITY_PROTOCOL_OUT:\n\t\tif (dev->flags & ATA_DFLAG_TRUSTED)\n\t\t\tsupported = 3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\t \n\trbuf[0] = rwcdlp;\n\trbuf[1] = cdlp | supported;\n\treturn err;\n}\n\n \nstatic void ata_scsi_report_zones_complete(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct sg_mapping_iter miter;\n\tunsigned long flags;\n\tunsigned int bytes = 0;\n\n\tsg_miter_start(&miter, scsi_sglist(scmd), scsi_sg_count(scmd),\n\t\t       SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\n\tlocal_irq_save(flags);\n\twhile (sg_miter_next(&miter)) {\n\t\tunsigned int offset = 0;\n\n\t\tif (bytes == 0) {\n\t\t\tchar *hdr;\n\t\t\tu32 list_length;\n\t\t\tu64 max_lba, opt_lba;\n\t\t\tu16 same;\n\n\t\t\t \n\t\t\thdr = miter.addr;\n\t\t\tlist_length = get_unaligned_le32(&hdr[0]);\n\t\t\tsame = get_unaligned_le16(&hdr[4]);\n\t\t\tmax_lba = get_unaligned_le64(&hdr[8]);\n\t\t\topt_lba = get_unaligned_le64(&hdr[16]);\n\t\t\tput_unaligned_be32(list_length, &hdr[0]);\n\t\t\thdr[4] = same & 0xf;\n\t\t\tput_unaligned_be64(max_lba, &hdr[8]);\n\t\t\tput_unaligned_be64(opt_lba, &hdr[16]);\n\t\t\toffset += 64;\n\t\t\tbytes += 64;\n\t\t}\n\t\twhile (offset < miter.length) {\n\t\t\tchar *rec;\n\t\t\tu8 cond, type, non_seq, reset;\n\t\t\tu64 size, start, wp;\n\n\t\t\t \n\t\t\trec = miter.addr + offset;\n\t\t\ttype = rec[0] & 0xf;\n\t\t\tcond = (rec[1] >> 4) & 0xf;\n\t\t\tnon_seq = (rec[1] & 2);\n\t\t\treset = (rec[1] & 1);\n\t\t\tsize = get_unaligned_le64(&rec[8]);\n\t\t\tstart = get_unaligned_le64(&rec[16]);\n\t\t\twp = get_unaligned_le64(&rec[24]);\n\t\t\trec[0] = type;\n\t\t\trec[1] = (cond << 4) | non_seq | reset;\n\t\t\tput_unaligned_be64(size, &rec[8]);\n\t\t\tput_unaligned_be64(start, &rec[16]);\n\t\t\tput_unaligned_be64(wp, &rec[24]);\n\t\t\tWARN_ON(offset + 64 > miter.length);\n\t\t\toffset += 64;\n\t\t\tbytes += 64;\n\t\t}\n\t}\n\tsg_miter_stop(&miter);\n\tlocal_irq_restore(flags);\n\n\tata_scsi_qc_complete(qc);\n}\n\nstatic unsigned int ata_scsi_zbc_in_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tconst u8 *cdb = scmd->cmnd;\n\tu16 sect, fp = (u16)-1;\n\tu8 sa, options, bp = 0xff;\n\tu64 block;\n\tu32 n_block;\n\n\tif (unlikely(scmd->cmd_len < 16)) {\n\t\tata_dev_warn(qc->dev, \"invalid cdb length %d\\n\",\n\t\t\t     scmd->cmd_len);\n\t\tfp = 15;\n\t\tgoto invalid_fld;\n\t}\n\tscsi_16_lba_len(cdb, &block, &n_block);\n\tif (n_block != scsi_bufflen(scmd)) {\n\t\tata_dev_warn(qc->dev, \"non-matching transfer count (%d/%d)\\n\",\n\t\t\t     n_block, scsi_bufflen(scmd));\n\t\tgoto invalid_param_len;\n\t}\n\tsa = cdb[1] & 0x1f;\n\tif (sa != ZI_REPORT_ZONES) {\n\t\tata_dev_warn(qc->dev, \"invalid service action %d\\n\", sa);\n\t\tfp = 1;\n\t\tgoto invalid_fld;\n\t}\n\t \n\tif ((n_block / 512) > 0xffff || n_block < 512 || (n_block % 512)) {\n\t\tata_dev_warn(qc->dev, \"invalid transfer count %d\\n\", n_block);\n\t\tgoto invalid_param_len;\n\t}\n\tsect = n_block / 512;\n\toptions = cdb[14] & 0xbf;\n\n\tif (ata_ncq_enabled(qc->dev) &&\n\t    ata_fpdma_zac_mgmt_in_supported(qc->dev)) {\n\t\ttf->protocol = ATA_PROT_NCQ;\n\t\ttf->command = ATA_CMD_FPDMA_RECV;\n\t\ttf->hob_nsect = ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN & 0x1f;\n\t\ttf->nsect = qc->hw_tag << 3;\n\t\ttf->feature = sect & 0xff;\n\t\ttf->hob_feature = (sect >> 8) & 0xff;\n\t\ttf->auxiliary = ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES | (options << 8);\n\t} else {\n\t\ttf->command = ATA_CMD_ZAC_MGMT_IN;\n\t\ttf->feature = ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES;\n\t\ttf->protocol = ATA_PROT_DMA;\n\t\ttf->hob_feature = options;\n\t\ttf->hob_nsect = (sect >> 8) & 0xff;\n\t\ttf->nsect = sect & 0xff;\n\t}\n\ttf->device = ATA_LBA;\n\ttf->lbah = (block >> 16) & 0xff;\n\ttf->lbam = (block >> 8) & 0xff;\n\ttf->lbal = block & 0xff;\n\ttf->hob_lbah = (block >> 40) & 0xff;\n\ttf->hob_lbam = (block >> 32) & 0xff;\n\ttf->hob_lbal = (block >> 24) & 0xff;\n\n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\n\tqc->flags |= ATA_QCFLAG_RESULT_TF;\n\n\tata_qc_set_pc_nbytes(qc);\n\n\tqc->complete_fn = ata_scsi_report_zones_complete;\n\n\treturn 0;\n\ninvalid_fld:\n\tata_scsi_set_invalid_field(qc->dev, scmd, fp, bp);\n\treturn 1;\n\ninvalid_param_len:\n\t \n\tata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\n\treturn 1;\n}\n\nstatic unsigned int ata_scsi_zbc_out_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tstruct ata_device *dev = qc->dev;\n\tconst u8 *cdb = scmd->cmnd;\n\tu8 all, sa;\n\tu64 block;\n\tu32 n_block;\n\tu16 fp = (u16)-1;\n\n\tif (unlikely(scmd->cmd_len < 16)) {\n\t\tfp = 15;\n\t\tgoto invalid_fld;\n\t}\n\n\tsa = cdb[1] & 0x1f;\n\tif ((sa != ZO_CLOSE_ZONE) && (sa != ZO_FINISH_ZONE) &&\n\t    (sa != ZO_OPEN_ZONE) && (sa != ZO_RESET_WRITE_POINTER)) {\n\t\tfp = 1;\n\t\tgoto invalid_fld;\n\t}\n\n\tscsi_16_lba_len(cdb, &block, &n_block);\n\tif (n_block) {\n\t\t \n\t\tgoto invalid_param_len;\n\t}\n\n\tall = cdb[14] & 0x1;\n\tif (all) {\n\t\t \n\t\tblock = 0;\n\t} else if (block >= dev->n_sectors) {\n\t\t \n\t\tfp = 2;\n\t\tgoto invalid_fld;\n\t}\n\n\tif (ata_ncq_enabled(qc->dev) &&\n\t    ata_fpdma_zac_mgmt_out_supported(qc->dev)) {\n\t\ttf->protocol = ATA_PROT_NCQ_NODATA;\n\t\ttf->command = ATA_CMD_NCQ_NON_DATA;\n\t\ttf->feature = ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT;\n\t\ttf->nsect = qc->hw_tag << 3;\n\t\ttf->auxiliary = sa | ((u16)all << 8);\n\t} else {\n\t\ttf->protocol = ATA_PROT_NODATA;\n\t\ttf->command = ATA_CMD_ZAC_MGMT_OUT;\n\t\ttf->feature = sa;\n\t\ttf->hob_feature = all;\n\t}\n\ttf->lbah = (block >> 16) & 0xff;\n\ttf->lbam = (block >> 8) & 0xff;\n\ttf->lbal = block & 0xff;\n\ttf->hob_lbah = (block >> 40) & 0xff;\n\ttf->hob_lbam = (block >> 32) & 0xff;\n\ttf->hob_lbal = (block >> 24) & 0xff;\n\ttf->device = ATA_LBA;\n\ttf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\n\n\treturn 0;\n\n invalid_fld:\n\tata_scsi_set_invalid_field(qc->dev, scmd, fp, 0xff);\n\treturn 1;\ninvalid_param_len:\n\t \n\tata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\n\treturn 1;\n}\n\n \nstatic int ata_mselect_caching(struct ata_queued_cmd *qc,\n\t\t\t       const u8 *buf, int len, u16 *fp)\n{\n\tstruct ata_taskfile *tf = &qc->tf;\n\tstruct ata_device *dev = qc->dev;\n\tu8 mpage[CACHE_MPAGE_LEN];\n\tu8 wce;\n\tint i;\n\n\t \n\n\tif (len != CACHE_MPAGE_LEN - 2) {\n\t\t*fp = min(len, CACHE_MPAGE_LEN - 2);\n\t\treturn -EINVAL;\n\t}\n\n\twce = buf[0] & (1 << 2);\n\n\t \n\tata_msense_caching(dev->id, mpage, false);\n\tfor (i = 0; i < CACHE_MPAGE_LEN - 2; i++) {\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (mpage[i + 2] != buf[i]) {\n\t\t\t*fp = i;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\ttf->protocol = ATA_PROT_NODATA;\n\ttf->nsect = 0;\n\ttf->command = ATA_CMD_SET_FEATURES;\n\ttf->feature = wce ? SETFEATURES_WC_ON : SETFEATURES_WC_OFF;\n\treturn 0;\n}\n\n \nstatic int ata_mselect_control_spg0(struct ata_queued_cmd *qc,\n\t\t\t\t    const u8 *buf, int len, u16 *fp)\n{\n\tstruct ata_device *dev = qc->dev;\n\tu8 mpage[CONTROL_MPAGE_LEN];\n\tu8 d_sense;\n\tint i;\n\n\t \n\n\tif (len != CONTROL_MPAGE_LEN - 2) {\n\t\t*fp = min(len, CONTROL_MPAGE_LEN - 2);\n\t\treturn -EINVAL;\n\t}\n\n\td_sense = buf[0] & (1 << 2);\n\n\t \n\tata_msense_control_spg0(dev, mpage, false);\n\tfor (i = 0; i < CONTROL_MPAGE_LEN - 2; i++) {\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (mpage[2 + i] != buf[i]) {\n\t\t\t*fp = i;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (d_sense & (1 << 2))\n\t\tdev->flags |= ATA_DFLAG_D_SENSE;\n\telse\n\t\tdev->flags &= ~ATA_DFLAG_D_SENSE;\n\treturn 0;\n}\n\n \nstatic unsigned int ata_mselect_control_ata_feature(struct ata_queued_cmd *qc,\n\t\t\t\t\t\t    const u8 *buf, int len,\n\t\t\t\t\t\t    u16 *fp)\n{\n\tstruct ata_device *dev = qc->dev;\n\tstruct ata_taskfile *tf = &qc->tf;\n\tu8 cdl_action;\n\n\t \n\tif (len != ATA_FEATURE_SUB_MPAGE_LEN - 4) {\n\t\t*fp = min(len, ATA_FEATURE_SUB_MPAGE_LEN - 4);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (buf[0] & 0x03) {\n\tcase 0:\n\t\t \n\t\tcdl_action = 0;\n\t\tdev->flags &= ~ATA_DFLAG_CDL_ENABLED;\n\t\tbreak;\n\tcase 0x02:\n\t\t \n\t\tif (dev->flags & ATA_DFLAG_NCQ_PRIO_ENABLED) {\n\t\t\tata_dev_err(dev,\n\t\t\t\t\"NCQ priority must be disabled to enable CDL\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcdl_action = 1;\n\t\tdev->flags |= ATA_DFLAG_CDL_ENABLED;\n\t\tbreak;\n\tdefault:\n\t\t*fp = 0;\n\t\treturn -EINVAL;\n\t}\n\n\ttf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\n\ttf->protocol = ATA_PROT_NODATA;\n\ttf->command = ATA_CMD_SET_FEATURES;\n\ttf->feature = SETFEATURES_CDL;\n\ttf->nsect = cdl_action;\n\n\treturn 1;\n}\n\n \nstatic int ata_mselect_control(struct ata_queued_cmd *qc, u8 spg,\n\t\t\t       const u8 *buf, int len, u16 *fp)\n{\n\tswitch (spg) {\n\tcase 0:\n\t\treturn ata_mselect_control_spg0(qc, buf, len, fp);\n\tcase ATA_FEATURE_SUB_MPAGE:\n\t\treturn ata_mselect_control_ata_feature(qc, buf, len, fp);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic unsigned int ata_scsi_mode_select_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tconst u8 *cdb = scmd->cmnd;\n\tu8 pg, spg;\n\tunsigned six_byte, pg_len, hdr_len, bd_len;\n\tint len, ret;\n\tu16 fp = (u16)-1;\n\tu8 bp = 0xff;\n\tu8 buffer[64];\n\tconst u8 *p = buffer;\n\n\tsix_byte = (cdb[0] == MODE_SELECT);\n\tif (six_byte) {\n\t\tif (scmd->cmd_len < 5) {\n\t\t\tfp = 4;\n\t\t\tgoto invalid_fld;\n\t\t}\n\n\t\tlen = cdb[4];\n\t\thdr_len = 4;\n\t} else {\n\t\tif (scmd->cmd_len < 9) {\n\t\t\tfp = 8;\n\t\t\tgoto invalid_fld;\n\t\t}\n\n\t\tlen = get_unaligned_be16(&cdb[7]);\n\t\thdr_len = 8;\n\t}\n\n\t \n\tif ((cdb[1] & 0x11) != 0x10) {\n\t\tfp = 1;\n\t\tbp = (cdb[1] & 0x01) ? 1 : 5;\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tif (!scsi_sg_count(scmd) || scsi_sglist(scmd)->length < len)\n\t\tgoto invalid_param_len;\n\n\t \n\tif (len < hdr_len)\n\t\tgoto invalid_param_len;\n\n\tif (!sg_copy_to_buffer(scsi_sglist(scmd), scsi_sg_count(scmd),\n\t\t\t       buffer, sizeof(buffer)))\n\t\tgoto invalid_param_len;\n\n\tif (six_byte)\n\t\tbd_len = p[3];\n\telse\n\t\tbd_len = get_unaligned_be16(&p[6]);\n\n\tlen -= hdr_len;\n\tp += hdr_len;\n\tif (len < bd_len)\n\t\tgoto invalid_param_len;\n\tif (bd_len != 0 && bd_len != 8) {\n\t\tfp = (six_byte) ? 3 : 6;\n\t\tfp += bd_len + hdr_len;\n\t\tgoto invalid_param;\n\t}\n\n\tlen -= bd_len;\n\tp += bd_len;\n\tif (len == 0)\n\t\tgoto skip;\n\n\t \n\tpg = p[0] & 0x3f;\n\tif (p[0] & 0x40) {\n\t\tif (len < 4)\n\t\t\tgoto invalid_param_len;\n\n\t\tspg = p[1];\n\t\tpg_len = get_unaligned_be16(&p[2]);\n\t\tp += 4;\n\t\tlen -= 4;\n\t} else {\n\t\tif (len < 2)\n\t\t\tgoto invalid_param_len;\n\n\t\tspg = 0;\n\t\tpg_len = p[1];\n\t\tp += 2;\n\t\tlen -= 2;\n\t}\n\n\t \n\tif (spg) {\n\t\tswitch (spg) {\n\t\tcase ALL_SUB_MPAGES:\n\t\t\t \n\t\t\tif (pg == CONTROL_MPAGE) {\n\t\t\t\tfp = (p[0] & 0x40) ? 1 : 0;\n\t\t\t\tfp += hdr_len + bd_len;\n\t\t\t\tgoto invalid_param;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ATA_FEATURE_SUB_MPAGE:\n\t\t\tif (qc->dev->flags & ATA_DFLAG_CDL &&\n\t\t\t    pg == CONTROL_MPAGE)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tfp = (p[0] & 0x40) ? 1 : 0;\n\t\t\tfp += hdr_len + bd_len;\n\t\t\tgoto invalid_param;\n\t\t}\n\t}\n\tif (pg_len > len)\n\t\tgoto invalid_param_len;\n\n\tswitch (pg) {\n\tcase CACHE_MPAGE:\n\t\tif (ata_mselect_caching(qc, p, pg_len, &fp) < 0) {\n\t\t\tfp += hdr_len + bd_len;\n\t\t\tgoto invalid_param;\n\t\t}\n\t\tbreak;\n\tcase CONTROL_MPAGE:\n\t\tret = ata_mselect_control(qc, spg, p, pg_len, &fp);\n\t\tif (ret < 0) {\n\t\t\tfp += hdr_len + bd_len;\n\t\t\tgoto invalid_param;\n\t\t}\n\t\tif (!ret)\n\t\t\tgoto skip;  \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfp = bd_len + hdr_len;\n\t\tgoto invalid_param;\n\t}\n\n\t \n\tif (len > pg_len)\n\t\tgoto invalid_param;\n\n\treturn 0;\n\n invalid_fld:\n\tata_scsi_set_invalid_field(qc->dev, scmd, fp, bp);\n\treturn 1;\n\n invalid_param:\n\tata_scsi_set_invalid_parameter(qc->dev, scmd, fp);\n\treturn 1;\n\n invalid_param_len:\n\t \n\tata_scsi_set_sense(qc->dev, scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\n\treturn 1;\n\n skip:\n\tscmd->result = SAM_STAT_GOOD;\n\treturn 1;\n}\n\nstatic u8 ata_scsi_trusted_op(u32 len, bool send, bool dma)\n{\n\tif (len == 0)\n\t\treturn ATA_CMD_TRUSTED_NONDATA;\n\telse if (send)\n\t\treturn dma ? ATA_CMD_TRUSTED_SND_DMA : ATA_CMD_TRUSTED_SND;\n\telse\n\t\treturn dma ? ATA_CMD_TRUSTED_RCV_DMA : ATA_CMD_TRUSTED_RCV;\n}\n\nstatic unsigned int ata_scsi_security_inout_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tconst u8 *cdb = scmd->cmnd;\n\tstruct ata_taskfile *tf = &qc->tf;\n\tu8 secp = cdb[1];\n\tbool send = (cdb[0] == SECURITY_PROTOCOL_OUT);\n\tu16 spsp = get_unaligned_be16(&cdb[2]);\n\tu32 len = get_unaligned_be32(&cdb[6]);\n\tbool dma = !(qc->dev->flags & ATA_DFLAG_PIO);\n\n\t \n\tif (secp == 0xef) {\n\t\tata_scsi_set_invalid_field(qc->dev, scmd, 1, 0);\n\t\treturn 1;\n\t}\n\n\tif (cdb[4] & 7) {  \n\t\tif (len > 0xffff) {\n\t\t\tata_scsi_set_invalid_field(qc->dev, scmd, 6, 0);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (len > 0x01fffe00) {\n\t\t\tata_scsi_set_invalid_field(qc->dev, scmd, 6, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tlen = (len + 511) / 512;\n\t}\n\n\ttf->protocol = dma ? ATA_PROT_DMA : ATA_PROT_PIO;\n\ttf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR | ATA_TFLAG_LBA;\n\tif (send)\n\t\ttf->flags |= ATA_TFLAG_WRITE;\n\ttf->command = ata_scsi_trusted_op(len, send, dma);\n\ttf->feature = secp;\n\ttf->lbam = spsp & 0xff;\n\ttf->lbah = spsp >> 8;\n\n\tif (len) {\n\t\ttf->nsect = len & 0xff;\n\t\ttf->lbal = len >> 8;\n\t} else {\n\t\tif (!send)\n\t\t\ttf->lbah = (1 << 7);\n\t}\n\n\tata_qc_set_pc_nbytes(qc);\n\treturn 0;\n}\n\n \nstatic unsigned int ata_scsi_var_len_cdb_xlat(struct ata_queued_cmd *qc)\n{\n\tstruct scsi_cmnd *scmd = qc->scsicmd;\n\tconst u8 *cdb = scmd->cmnd;\n\tconst u16 sa = get_unaligned_be16(&cdb[8]);\n\n\t \n\tif (sa == ATA_32)\n\t\treturn ata_scsi_pass_thru(qc);\n\n\t \n\treturn 1;\n}\n\n \n\nstatic inline ata_xlat_func_t ata_get_xlat_func(struct ata_device *dev, u8 cmd)\n{\n\tswitch (cmd) {\n\tcase READ_6:\n\tcase READ_10:\n\tcase READ_16:\n\n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase WRITE_16:\n\t\treturn ata_scsi_rw_xlat;\n\n\tcase WRITE_SAME_16:\n\t\treturn ata_scsi_write_same_xlat;\n\n\tcase SYNCHRONIZE_CACHE:\n\tcase SYNCHRONIZE_CACHE_16:\n\t\tif (ata_try_flush_cache(dev))\n\t\t\treturn ata_scsi_flush_xlat;\n\t\tbreak;\n\n\tcase VERIFY:\n\tcase VERIFY_16:\n\t\treturn ata_scsi_verify_xlat;\n\n\tcase ATA_12:\n\tcase ATA_16:\n\t\treturn ata_scsi_pass_thru;\n\n\tcase VARIABLE_LENGTH_CMD:\n\t\treturn ata_scsi_var_len_cdb_xlat;\n\n\tcase MODE_SELECT:\n\tcase MODE_SELECT_10:\n\t\treturn ata_scsi_mode_select_xlat;\n\n\tcase ZBC_IN:\n\t\treturn ata_scsi_zbc_in_xlat;\n\n\tcase ZBC_OUT:\n\t\treturn ata_scsi_zbc_out_xlat;\n\n\tcase SECURITY_PROTOCOL_IN:\n\tcase SECURITY_PROTOCOL_OUT:\n\t\tif (!(dev->flags & ATA_DFLAG_TRUSTED))\n\t\t\tbreak;\n\t\treturn ata_scsi_security_inout_xlat;\n\n\tcase START_STOP:\n\t\treturn ata_scsi_start_stop_xlat;\n\t}\n\n\treturn NULL;\n}\n\nint __ata_scsi_queuecmd(struct scsi_cmnd *scmd, struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tu8 scsi_op = scmd->cmnd[0];\n\tata_xlat_func_t xlat_func;\n\n\t \n\tif (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS))\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\tif (unlikely(!scmd->cmd_len))\n\t\tgoto bad_cdb_len;\n\n\tif (dev->class == ATA_DEV_ATA || dev->class == ATA_DEV_ZAC) {\n\t\tif (unlikely(scmd->cmd_len > dev->cdb_len))\n\t\t\tgoto bad_cdb_len;\n\n\t\txlat_func = ata_get_xlat_func(dev, scsi_op);\n\t} else if (likely((scsi_op != ATA_16) || !atapi_passthru16)) {\n\t\t \n\t\tint len = COMMAND_SIZE(scsi_op);\n\n\t\tif (unlikely(len > scmd->cmd_len ||\n\t\t\t     len > dev->cdb_len ||\n\t\t\t     scmd->cmd_len > ATAPI_CDB_LEN))\n\t\t\tgoto bad_cdb_len;\n\n\t\txlat_func = atapi_xlat;\n\t} else {\n\t\t \n\t\tif (unlikely(scmd->cmd_len > 16))\n\t\t\tgoto bad_cdb_len;\n\n\t\txlat_func = ata_get_xlat_func(dev, scsi_op);\n\t}\n\n\tif (xlat_func)\n\t\treturn ata_scsi_translate(dev, scmd, xlat_func);\n\n\tata_scsi_simulate(dev, scmd);\n\n\treturn 0;\n\n bad_cdb_len:\n\tscmd->result = DID_ERROR << 16;\n\tscsi_done(scmd);\n\treturn 0;\n}\n\n \nint ata_scsi_queuecmd(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\n{\n\tstruct ata_port *ap;\n\tstruct ata_device *dev;\n\tstruct scsi_device *scsidev = cmd->device;\n\tint rc = 0;\n\tunsigned long irq_flags;\n\n\tap = ata_shost_to_port(shost);\n\n\tspin_lock_irqsave(ap->lock, irq_flags);\n\n\tdev = ata_scsi_find_dev(ap, scsidev);\n\tif (likely(dev))\n\t\trc = __ata_scsi_queuecmd(cmd, dev);\n\telse {\n\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\tscsi_done(cmd);\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, irq_flags);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ata_scsi_queuecmd);\n\n \n\nvoid ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd)\n{\n\tstruct ata_scsi_args args;\n\tconst u8 *scsicmd = cmd->cmnd;\n\tu8 tmp8;\n\n\targs.dev = dev;\n\targs.id = dev->id;\n\targs.cmd = cmd;\n\n\tswitch(scsicmd[0]) {\n\tcase INQUIRY:\n\t\tif (scsicmd[1] & 2)\t\t    \n\t\t\tata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\n\t\telse if ((scsicmd[1] & 1) == 0)     \n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_std);\n\t\telse switch (scsicmd[2]) {\n\t\tcase 0x00:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_00);\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_80);\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_83);\n\t\t\tbreak;\n\t\tcase 0x89:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_89);\n\t\t\tbreak;\n\t\tcase 0xb0:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_b0);\n\t\t\tbreak;\n\t\tcase 0xb1:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_b1);\n\t\t\tbreak;\n\t\tcase 0xb2:\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_b2);\n\t\t\tbreak;\n\t\tcase 0xb6:\n\t\t\tif (dev->flags & ATA_DFLAG_ZAC)\n\t\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_b6);\n\t\t\telse\n\t\t\t\tata_scsi_set_invalid_field(dev, cmd, 2, 0xff);\n\t\t\tbreak;\n\t\tcase 0xb9:\n\t\t\tif (dev->cpr_log)\n\t\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_inq_b9);\n\t\t\telse\n\t\t\t\tata_scsi_set_invalid_field(dev, cmd, 2, 0xff);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tata_scsi_set_invalid_field(dev, cmd, 2, 0xff);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\t\tata_scsi_rbuf_fill(&args, ata_scsiop_mode_sense);\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);\n\t\tbreak;\n\n\tcase SERVICE_ACTION_IN_16:\n\t\tif ((scsicmd[1] & 0x1f) == SAI_READ_CAPACITY_16)\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);\n\t\telse\n\t\t\tata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\n\t\tbreak;\n\n\tcase REPORT_LUNS:\n\t\tata_scsi_rbuf_fill(&args, ata_scsiop_report_luns);\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tata_scsi_set_sense(dev, cmd, 0, 0, 0);\n\t\tbreak;\n\n\t \n\tcase SYNCHRONIZE_CACHE:\n\tcase SYNCHRONIZE_CACHE_16:\n\t\tfallthrough;\n\n\t \n\tcase REZERO_UNIT:\n\tcase SEEK_6:\n\tcase SEEK_10:\n\tcase TEST_UNIT_READY:\n\t\tbreak;\n\n\tcase SEND_DIAGNOSTIC:\n\t\ttmp8 = scsicmd[1] & ~(1 << 3);\n\t\tif (tmp8 != 0x4 || scsicmd[3] || scsicmd[4])\n\t\t\tata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\n\t\tbreak;\n\n\tcase MAINTENANCE_IN:\n\t\tif ((scsicmd[1] & 0x1f) == MI_REPORT_SUPPORTED_OPERATION_CODES)\n\t\t\tata_scsi_rbuf_fill(&args, ata_scsiop_maint_in);\n\t\telse\n\t\t\tata_scsi_set_invalid_field(dev, cmd, 1, 0xff);\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tata_scsi_set_sense(dev, cmd, ILLEGAL_REQUEST, 0x20, 0x0);\n\t\t \n\t\tbreak;\n\t}\n\n\tscsi_done(cmd);\n}\n\nint ata_scsi_add_hosts(struct ata_host *host, const struct scsi_host_template *sht)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\t\tstruct Scsi_Host *shost;\n\n\t\trc = -ENOMEM;\n\t\tshost = scsi_host_alloc(sht, sizeof(struct ata_port *));\n\t\tif (!shost)\n\t\t\tgoto err_alloc;\n\n\t\tshost->eh_noresume = 1;\n\t\t*(struct ata_port **)&shost->hostdata[0] = ap;\n\t\tap->scsi_host = shost;\n\n\t\tshost->transportt = ata_scsi_transport_template;\n\t\tshost->unique_id = ap->print_id;\n\t\tshost->max_id = 16;\n\t\tshost->max_lun = 1;\n\t\tshost->max_channel = 1;\n\t\tshost->max_cmd_len = 32;\n\n\t\t \n\t\tshost->max_host_blocked = 1;\n\n\t\trc = scsi_add_host_with_dma(shost, &ap->tdev, ap->host->dev);\n\t\tif (rc)\n\t\t\tgoto err_alloc;\n\t}\n\n\treturn 0;\n\n err_alloc:\n\twhile (--i >= 0) {\n\t\tstruct Scsi_Host *shost = host->ports[i]->scsi_host;\n\n\t\t \n\t\tscsi_remove_host(shost);\n\t}\n\treturn rc;\n}\n\n#ifdef CONFIG_OF\nstatic void ata_scsi_assign_ofnode(struct ata_device *dev, struct ata_port *ap)\n{\n\tstruct scsi_device *sdev = dev->sdev;\n\tstruct device *d = ap->host->dev;\n\tstruct device_node *np = d->of_node;\n\tstruct device_node *child;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tint ret;\n\t\tu32 val;\n\n\t\tret = of_property_read_u32(child, \"reg\", &val);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif (val == dev->devno) {\n\t\t\tdev_dbg(d, \"found matching device node\\n\");\n\t\t\tsdev->sdev_gendev.of_node = child;\n\t\t\treturn;\n\t\t}\n\t}\n}\n#else\nstatic void ata_scsi_assign_ofnode(struct ata_device *dev, struct ata_port *ap)\n{\n}\n#endif\n\nvoid ata_scsi_scan_host(struct ata_port *ap, int sync)\n{\n\tint tries = 5;\n\tstruct ata_device *last_failed_dev = NULL;\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\n repeat:\n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, link, ENABLED) {\n\t\t\tstruct scsi_device *sdev;\n\t\t\tint channel = 0, id = 0;\n\n\t\t\tif (dev->sdev)\n\t\t\t\tcontinue;\n\n\t\t\tif (ata_is_host_link(link))\n\t\t\t\tid = dev->devno;\n\t\t\telse\n\t\t\t\tchannel = link->pmp;\n\n\t\t\tsdev = __scsi_add_device(ap->scsi_host, channel, id, 0,\n\t\t\t\t\t\t NULL);\n\t\t\tif (!IS_ERR(sdev)) {\n\t\t\t\tdev->sdev = sdev;\n\t\t\t\tata_scsi_assign_ofnode(dev, ap);\n\t\t\t\tscsi_device_put(sdev);\n\t\t\t} else {\n\t\t\t\tdev->sdev = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, link, ENABLED) {\n\t\t\tif (!dev->sdev)\n\t\t\t\tgoto exit_loop;\n\t\t}\n\t}\n exit_loop:\n\tif (!link)\n\t\treturn;\n\n\t \n\tif (sync) {\n\t\t \n\t\tif (dev != last_failed_dev) {\n\t\t\tmsleep(100);\n\t\t\tlast_failed_dev = dev;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t \n\t\tif (--tries) {\n\t\t\tmsleep(100);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tata_port_err(ap,\n\t\t\t     \"WARNING: synchronous SCSI scan failed without making any progress, switching to async\\n\");\n\t}\n\n\tqueue_delayed_work(system_long_wq, &ap->hotplug_task,\n\t\t\t   round_jiffies_relative(HZ));\n}\n\n \nint ata_scsi_offline_dev(struct ata_device *dev)\n{\n\tif (dev->sdev) {\n\t\tscsi_device_set_state(dev->sdev, SDEV_OFFLINE);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void ata_scsi_remove_dev(struct ata_device *dev)\n{\n\tstruct ata_port *ap = dev->link->ap;\n\tstruct scsi_device *sdev;\n\tunsigned long flags;\n\n\t \n\tmutex_lock(&ap->scsi_host->scan_mutex);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\t \n\tsdev = dev->sdev;\n\tdev->sdev = NULL;\n\n\tif (sdev) {\n\t\t \n\t\tif (scsi_device_get(sdev) == 0) {\n\t\t\t \n\t\t\tscsi_device_set_state(sdev, SDEV_OFFLINE);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\tsdev = NULL;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tmutex_unlock(&ap->scsi_host->scan_mutex);\n\n\tif (sdev) {\n\t\tata_dev_info(dev, \"detaching (SCSI %s)\\n\",\n\t\t\t     dev_name(&sdev->sdev_gendev));\n\n\t\tscsi_remove_device(sdev);\n\t\tscsi_device_put(sdev);\n\t}\n}\n\nstatic void ata_scsi_handle_link_detach(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, link, ALL) {\n\t\tunsigned long flags;\n\n\t\tif (!(dev->flags & ATA_DFLAG_DETACHED))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(ap->lock, flags);\n\t\tdev->flags &= ~ATA_DFLAG_DETACHED;\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\n\t\tif (zpodd_dev_enabled(dev))\n\t\t\tzpodd_exit(dev);\n\n\t\tata_scsi_remove_dev(dev);\n\t}\n}\n\n \nvoid ata_scsi_media_change_notify(struct ata_device *dev)\n{\n\tif (dev->sdev)\n\t\tsdev_evt_send_simple(dev->sdev, SDEV_EVT_MEDIA_CHANGE,\n\t\t\t\t     GFP_ATOMIC);\n}\n\n \nvoid ata_scsi_hotplug(struct work_struct *work)\n{\n\tstruct ata_port *ap =\n\t\tcontainer_of(work, struct ata_port, hotplug_task.work);\n\tint i;\n\n\tif (ap->pflags & ATA_PFLAG_UNLOADING)\n\t\treturn;\n\n\tmutex_lock(&ap->scsi_scan_mutex);\n\n\t \n\tata_scsi_handle_link_detach(&ap->link);\n\tif (ap->pmp_link)\n\t\tfor (i = 0; i < SATA_PMP_MAX_PORTS; i++)\n\t\t\tata_scsi_handle_link_detach(&ap->pmp_link[i]);\n\n\t \n\tata_scsi_scan_host(ap, 0);\n\n\tmutex_unlock(&ap->scsi_scan_mutex);\n}\n\n \nint ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,\n\t\t       unsigned int id, u64 lun)\n{\n\tstruct ata_port *ap = ata_shost_to_port(shost);\n\tunsigned long flags;\n\tint devno, rc = 0;\n\n\tif (lun != SCAN_WILD_CARD && lun)\n\t\treturn -EINVAL;\n\n\tif (!sata_pmp_attached(ap)) {\n\t\tif (channel != SCAN_WILD_CARD && channel)\n\t\t\treturn -EINVAL;\n\t\tdevno = id;\n\t} else {\n\t\tif (id != SCAN_WILD_CARD && id)\n\t\t\treturn -EINVAL;\n\t\tdevno = channel;\n\t}\n\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tif (devno == SCAN_WILD_CARD) {\n\t\tstruct ata_link *link;\n\n\t\tata_for_each_link(link, ap, EDGE) {\n\t\t\tstruct ata_eh_info *ehi = &link->eh_info;\n\t\t\tehi->probe_mask |= ATA_ALL_DEVICES;\n\t\t\tehi->action |= ATA_EH_RESET;\n\t\t}\n\t} else {\n\t\tstruct ata_device *dev = ata_find_dev(ap, devno);\n\n\t\tif (dev) {\n\t\t\tstruct ata_eh_info *ehi = &dev->link->eh_info;\n\t\t\tehi->probe_mask |= 1 << dev->devno;\n\t\t\tehi->action |= ATA_EH_RESET;\n\t\t} else\n\t\t\trc = -EINVAL;\n\t}\n\n\tif (rc == 0) {\n\t\tata_port_schedule_eh(ap);\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tata_port_wait_eh(ap);\n\t} else\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\n\treturn rc;\n}\n\n \nvoid ata_scsi_dev_rescan(struct work_struct *work)\n{\n\tstruct ata_port *ap =\n\t\tcontainer_of(work, struct ata_port, scsi_rescan_task.work);\n\tstruct ata_link *link;\n\tstruct ata_device *dev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tmutex_lock(&ap->scsi_scan_mutex);\n\tspin_lock_irqsave(ap->lock, flags);\n\n\tata_for_each_link(link, ap, EDGE) {\n\t\tata_for_each_dev(dev, link, ENABLED) {\n\t\t\tstruct scsi_device *sdev = dev->sdev;\n\n\t\t\t \n\t\t\tif (ap->pflags & ATA_PFLAG_SUSPENDED)\n\t\t\t\tgoto unlock;\n\n\t\t\tif (!sdev)\n\t\t\t\tcontinue;\n\t\t\tif (scsi_device_get(sdev))\n\t\t\t\tcontinue;\n\n\t\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\t\tret = scsi_rescan_device(sdev);\n\t\t\tscsi_device_put(sdev);\n\t\t\tspin_lock_irqsave(ap->lock, flags);\n\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(ap->lock, flags);\n\tmutex_unlock(&ap->scsi_scan_mutex);\n\n\t \n\tif (ret)\n\t\tschedule_delayed_work(&ap->scsi_rescan_task,\n\t\t\t\t      msecs_to_jiffies(5));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}