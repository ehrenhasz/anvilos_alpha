{
  "module_name": "pata_legacy.c",
  "hash_id": "d092c0bb205bbfaca0cd50ca4706609bdcb4a3105433134a786cb247897fb79a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_legacy.c",
  "human_readable_source": "\n \n\n#include <linux/async.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/ata.h>\n#include <linux/libata.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME \"pata_legacy\"\n#define DRV_VERSION \"0.6.5\"\n\n#define NR_HOST 6\n\nstatic int all;\nmodule_param(all, int, 0444);\nMODULE_PARM_DESC(all,\n\t\t \"Set to probe unclaimed pri/sec ISA port ranges even if PCI\");\n\nstatic int probe_all;\nmodule_param(probe_all, int, 0);\nMODULE_PARM_DESC(probe_all,\n\t\t \"Set to probe tertiary+ ISA port ranges even if PCI\");\n\nstatic int probe_mask = ~0;\nmodule_param(probe_mask, int, 0);\nMODULE_PARM_DESC(probe_mask, \"Probe mask for legacy ISA PATA ports\");\n\nstatic int autospeed;\nmodule_param(autospeed, int, 0);\nMODULE_PARM_DESC(autospeed, \"Chip present that snoops speed changes\");\n\nstatic int pio_mask = ATA_PIO4;\nmodule_param(pio_mask, int, 0);\nMODULE_PARM_DESC(pio_mask, \"PIO range for autospeed devices\");\n\nstatic int iordy_mask = 0xFFFFFFFF;\nmodule_param(iordy_mask, int, 0);\nMODULE_PARM_DESC(iordy_mask, \"Use IORDY if available\");\n\nstatic int ht6560a;\nmodule_param(ht6560a, int, 0);\nMODULE_PARM_DESC(ht6560a, \"HT 6560A on primary 1, second 2, both 3\");\n\nstatic int ht6560b;\nmodule_param(ht6560b, int, 0);\nMODULE_PARM_DESC(ht6560b, \"HT 6560B on primary 1, secondary 2, both 3\");\n\nstatic int opti82c611a;\nmodule_param(opti82c611a, int, 0);\nMODULE_PARM_DESC(opti82c611a,\n\t\t \"Opti 82c611A on primary 1, secondary 2, both 3\");\n\nstatic int opti82c46x;\nmodule_param(opti82c46x, int, 0);\nMODULE_PARM_DESC(opti82c46x,\n\t\t \"Opti 82c465MV on primary 1, secondary 2, both 3\");\n\n#ifdef CONFIG_PATA_QDI_MODULE\nstatic int qdi = 1;\n#else\nstatic int qdi;\n#endif\nmodule_param(qdi, int, 0);\nMODULE_PARM_DESC(qdi, \"Set to probe QDI controllers\");\n\n#ifdef CONFIG_PATA_WINBOND_VLB_MODULE\nstatic int winbond = 1;\n#else\nstatic int winbond;\n#endif\nmodule_param(winbond, int, 0);\nMODULE_PARM_DESC(winbond,\n\t\t \"Set to probe Winbond controllers, \"\n\t\t \"give I/O port if non standard\");\n\n\nenum controller {\n\tBIOS = 0,\n\tSNOOP = 1,\n\tPDC20230 = 2,\n\tHT6560A = 3,\n\tHT6560B = 4,\n\tOPTI611A = 5,\n\tOPTI46X = 6,\n\tQDI6500 = 7,\n\tQDI6580 = 8,\n\tQDI6580DP = 9,\t\t \n\tW83759A = 10,\n\n\tUNKNOWN = -1\n};\n\nstruct legacy_data {\n\tunsigned long timing;\n\tu8 clock[2];\n\tu8 last;\n\tint fast;\n\tenum controller type;\n\tstruct platform_device *platform_dev;\n};\n\nstruct legacy_probe {\n\tunsigned char *name;\n\tunsigned long port;\n\tunsigned int irq;\n\tunsigned int slot;\n\tenum controller type;\n\tunsigned long private;\n};\n\nstruct legacy_controller {\n\tconst char *name;\n\tstruct ata_port_operations *ops;\n\tunsigned int pio_mask;\n\tunsigned int flags;\n\tunsigned int pflags;\n\tint (*setup)(struct platform_device *, struct legacy_probe *probe,\n\t\tstruct legacy_data *data);\n};\n\nstatic int legacy_port[NR_HOST] = { 0x1f0, 0x170, 0x1e8, 0x168, 0x1e0, 0x160 };\n\nstatic struct legacy_probe probe_list[NR_HOST];\nstatic struct legacy_data legacy_data[NR_HOST];\nstatic struct ata_host *legacy_host[NR_HOST];\nstatic int nr_legacy_host;\n\n\n \n\nstatic int legacy_probe_add(unsigned long port, unsigned int irq,\n\t\t\t\tenum controller type, unsigned long private)\n{\n\tstruct legacy_probe *lp = &probe_list[0];\n\tint i;\n\tstruct legacy_probe *free = NULL;\n\n\tfor (i = 0; i < NR_HOST; i++) {\n\t\tif (lp->port == 0 && free == NULL)\n\t\t\tfree = lp;\n\t\t \n\t\tif (lp->port == port || legacy_port[i] == port) {\n\t\t\tif (!(probe_mask & 1 << i))\n\t\t\t\treturn -1;\n\t\t\tfree = lp;\n\t\t\tbreak;\n\t\t}\n\t\tlp++;\n\t}\n\tif (free == NULL) {\n\t\tprintk(KERN_ERR \"pata_legacy: Too many interfaces.\\n\");\n\t\treturn -1;\n\t}\n\t \n\tfree->port = port;\n\tfree->irq = irq;\n\tfree->type = type;\n\tfree->private = private;\n\treturn 0;\n}\n\n\n \n\nstatic int legacy_set_mode(struct ata_link *link, struct ata_device **unused)\n{\n\tstruct ata_device *dev;\n\n\tata_for_each_dev(dev, link, ENABLED) {\n\t\tata_dev_info(dev, \"configured for PIO\\n\");\n\t\tdev->pio_mode = XFER_PIO_0;\n\t\tdev->xfer_mode = XFER_PIO_0;\n\t\tdev->xfer_shift = ATA_SHIFT_PIO;\n\t\tdev->flags |= ATA_DFLAG_PIO;\n\t}\n\treturn 0;\n}\n\nstatic const struct scsi_host_template legacy_sht = {\n\tATA_PIO_SHT(DRV_NAME),\n};\n\nstatic const struct ata_port_operations legacy_base_port_ops = {\n\t.inherits\t= &ata_sff_port_ops,\n\t.cable_detect\t= ata_cable_40wire,\n};\n\n \n\nstatic struct ata_port_operations simple_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.sff_data_xfer\t= ata_sff_data_xfer32,\n};\n\nstatic struct ata_port_operations legacy_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.sff_data_xfer\t= ata_sff_data_xfer32,\n\t.set_mode\t= legacy_set_mode,\n};\n\n \n\nstatic void pdc20230_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tint tries = 5;\n\tint pio = adev->pio_mode - XFER_PIO_0;\n\tu8 rt;\n\tunsigned long flags;\n\n\t \n\n\tlocal_irq_save(flags);\n\n\t \n\tdo {\n\t\tinb(0x1F5);\n\t\toutb(inb(0x1F2) | 0x80, 0x1F2);\n\t\tinb(0x1F2);\n\t\tinb(0x3F6);\n\t\tinb(0x3F6);\n\t\tinb(0x1F2);\n\t\tinb(0x1F2);\n\t}\n\twhile ((inb(0x1F2) & 0x80) && --tries);\n\n\tlocal_irq_restore(flags);\n\n\toutb(inb(0x1F4) & 0x07, 0x1F4);\n\n\trt = inb(0x1F3);\n\trt &= ~(0x07 << (3 * !adev->devno));\n\tif (pio)\n\t\trt |= (1 + 3 * pio) << (3 * !adev->devno);\n\toutb(rt, 0x1F3);\n\n\tudelay(100);\n\toutb(inb(0x1F2) | 0x01, 0x1F2);\n\tudelay(100);\n\tinb(0x1F5);\n\n}\n\nstatic unsigned int pdc_data_xfer_vlb(struct ata_queued_cmd *qc,\n\t\t\tunsigned char *buf, unsigned int buflen, int rw)\n{\n\tstruct ata_device *dev = qc->dev;\n\tstruct ata_port *ap = dev->link->ap;\n\tint slop = buflen & 3;\n\n\t \n\tif (ata_id_has_dword_io(dev->id) && (slop == 0 || slop == 3)\n\t\t\t\t\t&& (ap->pflags & ATA_PFLAG_PIO32)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\n\t\t \n\t\tioread8(ap->ioaddr.nsect_addr);\n\t\tioread8(ap->ioaddr.nsect_addr);\n\t\tioread8(ap->ioaddr.nsect_addr);\n\n\t\t \n\t\tif (rw == READ)\n\t\t\tioread32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\n\t\telse\n\t\t\tiowrite32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\n\n\t\tif (unlikely(slop)) {\n\t\t\t__le32 pad = 0;\n\n\t\t\tif (rw == READ) {\n\t\t\t\tpad = cpu_to_le32(ioread32(ap->ioaddr.data_addr));\n\t\t\t\tmemcpy(buf + buflen - slop, &pad, slop);\n\t\t\t} else {\n\t\t\t\tmemcpy(&pad, buf + buflen - slop, slop);\n\t\t\t\tiowrite32(le32_to_cpu(pad), ap->ioaddr.data_addr);\n\t\t\t}\n\t\t\tbuflen += 4 - slop;\n\t\t}\n\t\tlocal_irq_restore(flags);\n\t} else\n\t\tbuflen = ata_sff_data_xfer32(qc, buf, buflen, rw);\n\n\treturn buflen;\n}\n\nstatic struct ata_port_operations pdc20230_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= pdc20230_set_piomode,\n\t.sff_data_xfer\t= pdc_data_xfer_vlb,\n};\n\n \n\nstatic void ht6560a_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tu8 active, recover;\n\tstruct ata_timing t;\n\n\t \n\tata_timing_compute(adev, adev->pio_mode, &t, 20000, 1000);\n\n\tactive = clamp_val(t.active, 2, 15);\n\trecover = clamp_val(t.recover, 4, 15);\n\n\tinb(0x3E6);\n\tinb(0x3E6);\n\tinb(0x3E6);\n\tinb(0x3E6);\n\n\tiowrite8(recover << 4 | active, ap->ioaddr.device_addr);\n\tioread8(ap->ioaddr.status_addr);\n}\n\nstatic struct ata_port_operations ht6560a_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= ht6560a_set_piomode,\n};\n\n \n\nstatic void ht6560b_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tu8 active, recover;\n\tstruct ata_timing t;\n\n\t \n\tata_timing_compute(adev, adev->pio_mode, &t, 20000, 1000);\n\n\tactive = clamp_val(t.active, 2, 15);\n\trecover = clamp_val(t.recover, 2, 16) & 0x0F;\n\n\tinb(0x3E6);\n\tinb(0x3E6);\n\tinb(0x3E6);\n\tinb(0x3E6);\n\n\tiowrite8(recover << 4 | active, ap->ioaddr.device_addr);\n\n\tif (adev->class != ATA_DEV_ATA) {\n\t\tu8 rconf = inb(0x3E6);\n\t\tif (rconf & 0x24) {\n\t\t\trconf &= ~0x24;\n\t\t\toutb(rconf, 0x3E6);\n\t\t}\n\t}\n\tioread8(ap->ioaddr.status_addr);\n}\n\nstatic struct ata_port_operations ht6560b_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= ht6560b_set_piomode,\n};\n\n \n\n \n\nstatic u8 opti_syscfg(u8 reg)\n{\n\tunsigned long flags;\n\tu8 r;\n\n\t \n\tlocal_irq_save(flags);\n\toutb(reg, 0x22);\n\tr = inb(0x24);\n\tlocal_irq_restore(flags);\n\treturn r;\n}\n\n \n\nstatic void opti82c611a_set_piomode(struct ata_port *ap,\n\t\t\t\t\t\tstruct ata_device *adev)\n{\n\tu8 active, recover, setup;\n\tstruct ata_timing t;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tint clock;\n\tint khz[4] = { 50000, 40000, 33000, 25000 };\n\tu8 rc;\n\n\t \n\tioread16(ap->ioaddr.error_addr);\n\tioread16(ap->ioaddr.error_addr);\n\tiowrite8(3, ap->ioaddr.nsect_addr);\n\n\t \n\tclock = 1000000000 / khz[ioread8(ap->ioaddr.lbah_addr) & 0x03];\n\n\t \n\tata_timing_compute(adev, adev->pio_mode, &t, clock, 1000);\n\n\t \n\tif (pair) {\n\t\tstruct ata_timing tp;\n\t\tata_timing_compute(pair, pair->pio_mode, &tp, clock, 1000);\n\n\t\tata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\n\t}\n\n\tactive = clamp_val(t.active, 2, 17) - 2;\n\trecover = clamp_val(t.recover, 1, 16) - 1;\n\tsetup = clamp_val(t.setup, 1, 4) - 1;\n\n\t \n\trc = ioread8(ap->ioaddr.lbal_addr);\n\trc &= 0x7F;\n\trc |= (adev->devno << 7);\n\tiowrite8(rc, ap->ioaddr.lbal_addr);\n\n\t \n\tiowrite8(active << 4 | recover, ap->ioaddr.error_addr);\n\n\t \n\trc = ioread8(ap->ioaddr.device_addr);\n\trc &= 0xC0;\n\trc |= adev->devno;\t \n\trc |= (setup << 4) | 0x04;\n\tiowrite8(rc, ap->ioaddr.device_addr);\n\n\t \n\tiowrite8(active << 4 | recover, ap->ioaddr.data_addr);\n\n\t \n\trc = ioread8(ap->ioaddr.lbal_addr);\n\trc &= 0x73;\n\trc |= 0x84;\n\tiowrite8(rc, ap->ioaddr.lbal_addr);\n\n\t \n\tiowrite8(0x83,  ap->ioaddr.nsect_addr);\n}\n\n\nstatic struct ata_port_operations opti82c611a_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= opti82c611a_set_piomode,\n};\n\n \n\nstatic void opti82c46x_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tu8 active, recover, setup;\n\tstruct ata_timing t;\n\tstruct ata_device *pair = ata_dev_pair(adev);\n\tint clock;\n\tint khz[4] = { 50000, 40000, 33000, 25000 };\n\tu8 rc;\n\tu8 sysclk;\n\n\t \n\tsysclk = (opti_syscfg(0xAC) & 0xC0) >> 6;\t \n\n\t \n\tioread16(ap->ioaddr.error_addr);\n\tioread16(ap->ioaddr.error_addr);\n\tiowrite8(3, ap->ioaddr.nsect_addr);\n\n\t \n\tclock = 1000000000 / khz[sysclk];\n\n\t \n\tata_timing_compute(adev, adev->pio_mode, &t, clock, 1000);\n\n\t \n\tif (pair) {\n\t\tstruct ata_timing tp;\n\t\tata_timing_compute(pair, pair->pio_mode, &tp, clock, 1000);\n\n\t\tata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\n\t}\n\n\tactive = clamp_val(t.active, 2, 17) - 2;\n\trecover = clamp_val(t.recover, 1, 16) - 1;\n\tsetup = clamp_val(t.setup, 1, 4) - 1;\n\n\t \n\trc = ioread8(ap->ioaddr.lbal_addr);\n\trc &= 0x7F;\n\trc |= (adev->devno << 7);\n\tiowrite8(rc, ap->ioaddr.lbal_addr);\n\n\t \n\tiowrite8(active << 4 | recover, ap->ioaddr.error_addr);\n\n\t \n\trc = ioread8(ap->ioaddr.device_addr);\n\trc &= 0xC0;\n\trc |= adev->devno;\t \n\trc |= (setup << 4) | 0x04;\n\tiowrite8(rc, ap->ioaddr.device_addr);\n\n\t \n\tiowrite8(active << 4 | recover, ap->ioaddr.data_addr);\n\n\t \n\trc = ioread8(ap->ioaddr.lbal_addr);\n\trc &= 0x73;\n\trc |= 0x84;\n\tiowrite8(rc, ap->ioaddr.lbal_addr);\n\n\t \n\tiowrite8(0x83,  ap->ioaddr.nsect_addr);\n\n\t \n\tap->host->private_data = ap;\n}\n\n \n\nstatic unsigned int opti82c46x_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\n\t \n\tif (ap->host->private_data != ap->host\n\t    && ap->host->private_data != NULL)\n\t\topti82c46x_set_piomode(ap, adev);\n\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic struct ata_port_operations opti82c46x_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= opti82c46x_set_piomode,\n\t.qc_issue\t= opti82c46x_qc_issue,\n};\n\n \n\nstatic void qdi65x0_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ata_timing t;\n\tstruct legacy_data *ld_qdi = ap->host->private_data;\n\tint active, recovery;\n\tu8 timing;\n\n\t \n\tata_timing_compute(adev, adev->pio_mode, &t, 30303, 1000);\n\n\tif (ld_qdi->fast) {\n\t\tactive = 8 - clamp_val(t.active, 1, 8);\n\t\trecovery = 18 - clamp_val(t.recover, 3, 18);\n\t} else {\n\t\tactive = 9 - clamp_val(t.active, 2, 9);\n\t\trecovery = 15 - clamp_val(t.recover, 0, 15);\n\t}\n\ttiming = (recovery << 4) | active | 0x08;\n\tld_qdi->clock[adev->devno] = timing;\n\n\tif (ld_qdi->type == QDI6580)\n\t\toutb(timing, ld_qdi->timing + 2 * adev->devno);\n\telse\n\t\toutb(timing, ld_qdi->timing + 2 * ap->port_no);\n\n\t \n\tif (ld_qdi->type != QDI6500 && adev->class != ATA_DEV_ATA)\n\t\toutb(0x5F, (ld_qdi->timing & 0xFFF0) + 3);\n}\n\n \n\nstatic unsigned int qdi_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ata_device *adev = qc->dev;\n\tstruct legacy_data *ld_qdi = ap->host->private_data;\n\n\tif (ld_qdi->clock[adev->devno] != ld_qdi->last) {\n\t\tif (adev->pio_mode) {\n\t\t\tld_qdi->last = ld_qdi->clock[adev->devno];\n\t\t\toutb(ld_qdi->clock[adev->devno], ld_qdi->timing +\n\t\t\t\t\t\t\t2 * ap->port_no);\n\t\t}\n\t}\n\treturn ata_sff_qc_issue(qc);\n}\n\nstatic unsigned int vlb32_data_xfer(struct ata_queued_cmd *qc,\n\t\t\t\t    unsigned char *buf,\n\t\t\t\t    unsigned int buflen, int rw)\n{\n\tstruct ata_device *adev = qc->dev;\n\tstruct ata_port *ap = adev->link->ap;\n\tint slop = buflen & 3;\n\n\tif (ata_id_has_dword_io(adev->id) && (slop == 0 || slop == 3)\n\t\t\t\t\t&& (ap->pflags & ATA_PFLAG_PIO32)) {\n\t\tif (rw == WRITE)\n\t\t\tiowrite32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\n\t\telse\n\t\t\tioread32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\n\n\t\tif (unlikely(slop)) {\n\t\t\t__le32 pad = 0;\n\n\t\t\tif (rw == WRITE) {\n\t\t\t\tmemcpy(&pad, buf + buflen - slop, slop);\n\t\t\t\tiowrite32(le32_to_cpu(pad), ap->ioaddr.data_addr);\n\t\t\t} else {\n\t\t\t\tpad = cpu_to_le32(ioread32(ap->ioaddr.data_addr));\n\t\t\t\tmemcpy(buf + buflen - slop, &pad, slop);\n\t\t\t}\n\t\t}\n\t\treturn (buflen + 3) & ~3;\n\t} else\n\t\treturn ata_sff_data_xfer(qc, buf, buflen, rw);\n}\n\nstatic int qdi_port(struct platform_device *dev,\n\t\t\tstruct legacy_probe *lp, struct legacy_data *ld)\n{\n\tif (devm_request_region(&dev->dev, lp->private, 4, \"qdi\") == NULL)\n\t\treturn -EBUSY;\n\tld->timing = lp->private;\n\treturn 0;\n}\n\nstatic struct ata_port_operations qdi6500_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= qdi65x0_set_piomode,\n\t.qc_issue\t= qdi_qc_issue,\n\t.sff_data_xfer\t= vlb32_data_xfer,\n};\n\nstatic struct ata_port_operations qdi6580_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= qdi65x0_set_piomode,\n\t.sff_data_xfer\t= vlb32_data_xfer,\n};\n\nstatic struct ata_port_operations qdi6580dp_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= qdi65x0_set_piomode,\n\t.qc_issue\t= qdi_qc_issue,\n\t.sff_data_xfer\t= vlb32_data_xfer,\n};\n\nstatic DEFINE_SPINLOCK(winbond_lock);\n\nstatic void winbond_writecfg(unsigned long port, u8 reg, u8 val)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&winbond_lock, flags);\n\toutb(reg, port + 0x01);\n\toutb(val, port + 0x02);\n\tspin_unlock_irqrestore(&winbond_lock, flags);\n}\n\nstatic u8 winbond_readcfg(unsigned long port, u8 reg)\n{\n\tu8 val;\n\n\tunsigned long flags;\n\tspin_lock_irqsave(&winbond_lock, flags);\n\toutb(reg, port + 0x01);\n\tval = inb(port + 0x02);\n\tspin_unlock_irqrestore(&winbond_lock, flags);\n\n\treturn val;\n}\n\nstatic void winbond_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstruct ata_timing t;\n\tstruct legacy_data *ld_winbond = ap->host->private_data;\n\tint active, recovery;\n\tu8 reg;\n\tint timing = 0x88 + (ap->port_no * 4) + (adev->devno * 2);\n\n\treg = winbond_readcfg(ld_winbond->timing, 0x81);\n\n\t \n\tif (reg & 0x40)\t\t \n\t\tata_timing_compute(adev, adev->pio_mode, &t, 20000, 1000);\n\telse\n\t\tata_timing_compute(adev, adev->pio_mode, &t, 30303, 1000);\n\n\tactive = (clamp_val(t.active, 3, 17) - 1) & 0x0F;\n\trecovery = (clamp_val(t.recover, 1, 15) + 1) & 0x0F;\n\ttiming = (active << 4) | recovery;\n\twinbond_writecfg(ld_winbond->timing, timing, reg);\n\n\t \n\n\treg = 0x35;\n\tif (adev->class != ATA_DEV_ATA)\n\t\treg |= 0x08;\t \n\tif (!ata_pio_need_iordy(adev))\n\t\treg |= 0x02;\t \n\treg |= (clamp_val(t.setup, 0, 3) << 6);\n\twinbond_writecfg(ld_winbond->timing, timing + 1, reg);\n}\n\nstatic int winbond_port(struct platform_device *dev,\n\t\t\tstruct legacy_probe *lp, struct legacy_data *ld)\n{\n\tif (devm_request_region(&dev->dev, lp->private, 4, \"winbond\") == NULL)\n\t\treturn -EBUSY;\n\tld->timing = lp->private;\n\treturn 0;\n}\n\nstatic struct ata_port_operations winbond_port_ops = {\n\t.inherits\t= &legacy_base_port_ops,\n\t.set_piomode\t= winbond_set_piomode,\n\t.sff_data_xfer\t= vlb32_data_xfer,\n};\n\nstatic struct legacy_controller controllers[] = {\n\t{\"BIOS\",\t&legacy_port_ops, \tATA_PIO4,\n\t\t\tATA_FLAG_NO_IORDY,\t0,\t\t\tNULL },\n\t{\"Snooping\", \t&simple_port_ops, \tATA_PIO4,\n\t\t\t0,\t\t\t0,\t\t\tNULL },\n\t{\"PDC20230\",\t&pdc20230_port_ops,\tATA_PIO2,\n\t\t\tATA_FLAG_NO_IORDY,\n\t\t\tATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE,\tNULL },\n\t{\"HT6560A\",\t&ht6560a_port_ops,\tATA_PIO2,\n\t\t\tATA_FLAG_NO_IORDY,\t0,\t\t\tNULL },\n\t{\"HT6560B\",\t&ht6560b_port_ops,\tATA_PIO4,\n\t\t\tATA_FLAG_NO_IORDY,\t0,\t\t\tNULL },\n\t{\"OPTI82C611A\",\t&opti82c611a_port_ops,\tATA_PIO3,\n\t\t\t0,\t\t\t0,\t\t\tNULL },\n\t{\"OPTI82C46X\",\t&opti82c46x_port_ops,\tATA_PIO3,\n\t\t\t0,\t\t\t0,\t\t\tNULL },\n\t{\"QDI6500\",\t&qdi6500_port_ops,\tATA_PIO2,\n\t\t\tATA_FLAG_NO_IORDY,\n\t\t\tATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE,    qdi_port },\n\t{\"QDI6580\",\t&qdi6580_port_ops,\tATA_PIO4,\n\t\t\t0, ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE, qdi_port },\n\t{\"QDI6580DP\",\t&qdi6580dp_port_ops,\tATA_PIO4,\n\t\t\t0, ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE, qdi_port },\n\t{\"W83759A\",\t&winbond_port_ops,\tATA_PIO4,\n\t\t\t0, ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE,\n\t\t\t\t\t\t\t\twinbond_port }\n};\n\n \n\nstatic __init int probe_chip_type(struct legacy_probe *probe)\n{\n\tint mask = 1 << probe->slot;\n\n\tif (winbond && (probe->port == 0x1F0 || probe->port == 0x170)) {\n\t\tu8 reg = winbond_readcfg(winbond, 0x81);\n\t\treg |= 0x80;\t \n\t\twinbond_writecfg(winbond, 0x81, reg);\n\t\treg = winbond_readcfg(winbond, 0x83);\n\t\treg |= 0xF0;\t \n\t\twinbond_writecfg(winbond, 0x83, reg);\n\t\treg = winbond_readcfg(winbond, 0x85);\n\t\treg |= 0xF0;\t \n\t\twinbond_writecfg(winbond, 0x85, reg);\n\n\t\treg = winbond_readcfg(winbond, 0x81);\n\n\t\tif (reg & mask)\n\t\t\treturn W83759A;\n\t}\n\tif (probe->port == 0x1F0) {\n\t\tunsigned long flags;\n\t\tlocal_irq_save(flags);\n\t\t \n\t\toutb(inb(0x1F2) | 0x80, 0x1F2);\n\t\tinb(0x1F5);\n\t\tinb(0x1F2);\n\t\tinb(0x3F6);\n\t\tinb(0x3F6);\n\t\tinb(0x1F2);\n\t\tinb(0x1F2);\n\n\t\tif ((inb(0x1F2) & 0x80) == 0) {\n\t\t\t \n\t\t\tprintk(KERN_INFO  \"PDC20230-C/20630 VLB ATA controller\"\n\t\t\t\t\t\t\t\" detected.\\n\");\n\t\t\tudelay(100);\n\t\t\tinb(0x1F5);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn PDC20230;\n\t\t} else {\n\t\t\toutb(0x55, 0x1F2);\n\t\t\tinb(0x1F2);\n\t\t\tinb(0x1F2);\n\t\t\tif (inb(0x1F2) == 0x00)\n\t\t\t\tprintk(KERN_INFO \"PDC20230-B VLB ATA \"\n\t\t\t\t\t\t     \"controller detected.\\n\");\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn BIOS;\n\t\t}\n\t}\n\n\tif (ht6560a & mask)\n\t\treturn HT6560A;\n\tif (ht6560b & mask)\n\t\treturn HT6560B;\n\tif (opti82c611a & mask)\n\t\treturn OPTI611A;\n\tif (opti82c46x & mask)\n\t\treturn OPTI46X;\n\tif (autospeed & mask)\n\t\treturn SNOOP;\n\treturn BIOS;\n}\n\n\n \n\nstatic __init int legacy_init_one(struct legacy_probe *probe)\n{\n\tstruct legacy_controller *controller = &controllers[probe->type];\n\tint pio_modes = controller->pio_mask;\n\tunsigned long io = probe->port;\n\tu32 mask = (1 << probe->slot);\n\tstruct ata_port_operations *ops = controller->ops;\n\tstruct legacy_data *ld = &legacy_data[probe->slot];\n\tstruct ata_host *host = NULL;\n\tstruct ata_port *ap;\n\tstruct platform_device *pdev;\n\tstruct ata_device *dev;\n\tvoid __iomem *io_addr, *ctrl_addr;\n\tu32 iordy = (iordy_mask & mask) ? 0: ATA_FLAG_NO_IORDY;\n\tint ret;\n\n\tiordy |= controller->flags;\n\n\tpdev = platform_device_register_simple(DRV_NAME, probe->slot, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tret = -EBUSY;\n\tif (devm_request_region(&pdev->dev, io, 8, \"pata_legacy\") == NULL ||\n\t    devm_request_region(&pdev->dev, io + 0x0206, 1,\n\t\t\t\t\t\t\t\"pata_legacy\") == NULL)\n\t\tgoto fail;\n\n\tret = -ENOMEM;\n\tio_addr = devm_ioport_map(&pdev->dev, io, 8);\n\tctrl_addr = devm_ioport_map(&pdev->dev, io + 0x0206, 1);\n\tif (!io_addr || !ctrl_addr)\n\t\tgoto fail;\n\tld->type = probe->type;\n\tif (controller->setup)\n\t\tif (controller->setup(pdev, probe, ld) < 0)\n\t\t\tgoto fail;\n\thost = ata_host_alloc(&pdev->dev, 1);\n\tif (!host)\n\t\tgoto fail;\n\tap = host->ports[0];\n\n\tap->ops = ops;\n\tap->pio_mask = pio_modes;\n\tap->flags |= ATA_FLAG_SLAVE_POSS | iordy;\n\tap->pflags |= controller->pflags;\n\tap->ioaddr.cmd_addr = io_addr;\n\tap->ioaddr.altstatus_addr = ctrl_addr;\n\tap->ioaddr.ctl_addr = ctrl_addr;\n\tata_sff_std_ports(&ap->ioaddr);\n\tap->host->private_data = ld;\n\n\tata_port_desc(ap, \"cmd 0x%lx ctl 0x%lx\", io, io + 0x0206);\n\n\tret = ata_host_activate(host, probe->irq, ata_sff_interrupt, 0,\n\t\t\t\t&legacy_sht);\n\tif (ret)\n\t\tgoto fail;\n\tasync_synchronize_full();\n\tld->platform_dev = pdev;\n\n\t \n\n\tret = -ENODEV;\n\tata_for_each_dev(dev, &ap->link, ALL) {\n\t\tif (!ata_dev_absent(dev)) {\n\t\t\tlegacy_host[probe->slot] = host;\n\t\t\tld->platform_dev = pdev;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tata_host_detach(host);\nfail:\n\tplatform_device_unregister(pdev);\n\treturn ret;\n}\n\n \n\nstatic void __init legacy_check_special_cases(struct pci_dev *p, int *primary,\n\t\t\t\t\t\t\t\tint *secondary)\n{\n\t \n\tif (p->vendor == 0x1078 && p->device == 0x0000) {\n\t\t*primary = *secondary = 1;\n\t\treturn;\n\t}\n\t \n\tif (p->vendor == 0x1078 && p->device == 0x0002) {\n\t\t*primary = *secondary = 1;\n\t\treturn;\n\t}\n\t \n\tif (p->vendor == 0x8086 && p->device == 0x1234) {\n\t\tu16 r;\n\t\tpci_read_config_word(p, 0x6C, &r);\n\t\tif (r & 0x8000) {\n\t\t\t \n\t\t\tif (r & 0x4000)\n\t\t\t\t*secondary = 1;\n\t\t\telse\n\t\t\t\t*primary = 1;\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic __init void probe_opti_vlb(void)\n{\n\t \n\tstatic const char *optis[4] = {\n\t\t\"3/463MV\", \"5MV\",\n\t\t\"5MVA\", \"5MVB\"\n\t};\n\tu8 chans = 1;\n\tu8 ctrl = (opti_syscfg(0x30) & 0xC0) >> 6;\n\n\topti82c46x = 3;\t \n\tprintk(KERN_INFO DRV_NAME \": Opti 82C46%s chipset support.\\n\",\n\t\t\t\t\t\t\t\toptis[ctrl]);\n\tif (ctrl == 3)\n\t\tchans = (opti_syscfg(0x3F) & 0x20) ? 2 : 1;\n\tctrl = opti_syscfg(0xAC);\n\t \n\tif (ctrl & 8) {\n\t\tif (chans == 2) {\n\t\t\tlegacy_probe_add(0x1F0, 14, OPTI46X, 0);\n\t\t\tlegacy_probe_add(0x170, 15, OPTI46X, 0);\n\t\t}\n\t\tif (ctrl & 4)\n\t\t\tlegacy_probe_add(0x170, 15, OPTI46X, 0);\n\t\telse\n\t\t\tlegacy_probe_add(0x1F0, 14, OPTI46X, 0);\n\t} else\n\t\tlegacy_probe_add(0x1F0, 14, OPTI46X, 0);\n}\n\nstatic __init void qdi65_identify_port(u8 r, u8 res, unsigned long port)\n{\n\tstatic const unsigned long ide_port[2] = { 0x170, 0x1F0 };\n\t \n\tif ((r & 0xF0) == 0xC0) {\n\t\t \n\t\tif (r & 8)\n\t\t\t \n\t\t\treturn;\n\t\tlegacy_probe_add(ide_port[r & 0x01], 14 + (r & 0x01),\n\t\t\t\t\t\t\t\tQDI6500, port);\n\t}\n\tif (((r & 0xF0) == 0xA0) || (r & 0xF0) == 0x50) {\n\t\t \n\t\tif (!request_region(port + 2 , 2, \"pata_qdi\")) {\n\t\t\trelease_region(port, 2);\n\t\t\treturn;\n\t\t}\n\t\tres = inb(port + 3);\n\t\t \n\t\tif (res & 1)\n\t\t\tlegacy_probe_add(ide_port[r & 0x01], 14 + (r & 0x01),\n\t\t\t\t\t\t\t\tQDI6580, port);\n\t\telse {  \n\t\t\tlegacy_probe_add(0x1F0, 14, QDI6580DP, port);\n\t\t\t \n\t\t\tlegacy_probe_add(0x170, 15, QDI6580DP, port + 2);\n\t\t}\n\t\trelease_region(port + 2, 2);\n\t}\n}\n\nstatic __init void probe_qdi_vlb(void)\n{\n\tunsigned long flags;\n\tstatic const unsigned long qd_port[2] = { 0x30, 0xB0 };\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned long port = qd_port[i];\n\t\tu8 r, res;\n\n\n\t\tif (request_region(port, 2, \"pata_qdi\")) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\t \n\t\t\tr = inb(port);\n\t\t\tudelay(1);\n\t\t\toutb(0x19, port);\n\t\t\tudelay(1);\n\t\t\tres = inb(port);\n\t\t\tudelay(1);\n\t\t\toutb(r, port);\n\t\t\tudelay(1);\n\t\t\tlocal_irq_restore(flags);\n\n\t\t\t \n\t\t\tif (res == 0x19) {\n\t\t\t\trelease_region(port, 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tr = inb(port + 1);\n\t\t\tudelay(1);\n\t\t\t \n\t\t\tif ((r & 2) >> 1 == i)\n\t\t\t\tqdi65_identify_port(r, res, port);\n\t\t\trelease_region(port, 2);\n\t\t}\n\t}\n}\n\n \n\nstatic __init int legacy_init(void)\n{\n\tint i;\n\tint ct = 0;\n\tint primary = 0;\n\tint secondary = 0;\n\tint pci_present = 0;\n\tstruct legacy_probe *pl = &probe_list[0];\n\tint slot = 0;\n\n\tstruct pci_dev *p = NULL;\n\n\tfor_each_pci_dev(p) {\n\t\tint r;\n\t\t \n\t\tfor (r = 0; r < 6; r++) {\n\t\t\tif (pci_resource_start(p, r) == 0x1f0)\n\t\t\t\tprimary = 1;\n\t\t\tif (pci_resource_start(p, r) == 0x170)\n\t\t\t\tsecondary = 1;\n\t\t}\n\t\t \n\t\tlegacy_check_special_cases(p, &primary, &secondary);\n\n\t\t \n\t\tpci_present = 1;\n\t}\n\n\tif (winbond == 1)\n\t\twinbond = 0x130;\t \n\n\tif (primary == 0 || all)\n\t\tlegacy_probe_add(0x1F0, 14, UNKNOWN, 0);\n\tif (secondary == 0 || all)\n\t\tlegacy_probe_add(0x170, 15, UNKNOWN, 0);\n\n\tif (probe_all || !pci_present) {\n\t\t \n\t\tlegacy_probe_add(0x1E8, 11, UNKNOWN, 0);\n\t\tlegacy_probe_add(0x168, 10, UNKNOWN, 0);\n\t\tlegacy_probe_add(0x1E0, 8, UNKNOWN, 0);\n\t\tlegacy_probe_add(0x160, 12, UNKNOWN, 0);\n\t}\n\n\tif (opti82c46x)\n\t\tprobe_opti_vlb();\n\tif (qdi)\n\t\tprobe_qdi_vlb();\n\n\tfor (i = 0; i < NR_HOST; i++, pl++) {\n\t\tif (pl->port == 0)\n\t\t\tcontinue;\n\t\tif (pl->type == UNKNOWN)\n\t\t\tpl->type = probe_chip_type(pl);\n\t\tpl->slot = slot++;\n\t\tif (legacy_init_one(pl) == 0)\n\t\t\tct++;\n\t}\n\tif (ct != 0)\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\nstatic __exit void legacy_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_legacy_host; i++) {\n\t\tstruct legacy_data *ld = &legacy_data[i];\n\t\tata_host_detach(legacy_host[i]);\n\t\tplatform_device_unregister(ld->platform_dev);\n\t}\n}\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for legacy ATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_ALIAS(\"pata_qdi\");\nMODULE_ALIAS(\"pata_winbond\");\n\nmodule_init(legacy_init);\nmodule_exit(legacy_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}