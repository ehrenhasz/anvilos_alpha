{
  "module_name": "pata_ninja32.c",
  "hash_id": "0d5a4922282dbe206beeb138e6e1307791b3fa7d7561f22017ebebf117f2d826",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ata/pata_ninja32.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <scsi/scsi_host.h>\n#include <linux/libata.h>\n\n#define DRV_NAME \"pata_ninja32\"\n#define DRV_VERSION \"0.1.5\"\n\n\n \n\nstatic void ninja32_set_piomode(struct ata_port *ap, struct ata_device *adev)\n{\n\tstatic u16 pio_timing[5] = {\n\t\t0xd6, 0x85, 0x44, 0x33, 0x13\n\t};\n\tiowrite8(pio_timing[adev->pio_mode - XFER_PIO_0],\n\t\t ap->ioaddr.bmdma_addr + 0x1f);\n\tap->private_data = adev;\n}\n\n\nstatic void ninja32_dev_select(struct ata_port *ap, unsigned int device)\n{\n\tstruct ata_device *adev = &ap->link.device[device];\n\tif (ap->private_data != adev) {\n\t\tiowrite8(0xd6, ap->ioaddr.bmdma_addr + 0x1f);\n\t\tata_sff_dev_select(ap, device);\n\t\tninja32_set_piomode(ap, adev);\n\t}\n}\n\nstatic const struct scsi_host_template ninja32_sht = {\n\tATA_BMDMA_SHT(DRV_NAME),\n};\n\nstatic struct ata_port_operations ninja32_port_ops = {\n\t.inherits\t= &ata_bmdma_port_ops,\n\t.sff_dev_select = ninja32_dev_select,\n\t.cable_detect\t= ata_cable_40wire,\n\t.set_piomode\t= ninja32_set_piomode,\n\t.sff_data_xfer\t= ata_sff_data_xfer32\n};\n\nstatic void ninja32_program(void __iomem *base)\n{\n\tiowrite8(0x05, base + 0x01);\t \n\tiowrite8(0xBE, base + 0x02);\t \n\tiowrite8(0x01, base + 0x03);\t \n\tiowrite8(0x20, base + 0x04);\t \n\tiowrite8(0x8f, base + 0x05);\t \n\tiowrite8(0xa4, base + 0x1c);\t \n\tiowrite8(0x83, base + 0x1d);\t \n}\n\nstatic int ninja32_init_one(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct ata_host *host;\n\tstruct ata_port *ap;\n\tvoid __iomem *base;\n\tint rc;\n\n\thost = ata_host_alloc(&dev->dev, 1);\n\tif (!host)\n\t\treturn -ENOMEM;\n\tap = host->ports[0];\n\n\t \n\trc = pcim_enable_device(dev);\n\tif (rc)\n\t\treturn rc;\n\trc = pcim_iomap_regions(dev, 1 << 0, DRV_NAME);\n\tif (rc == -EBUSY)\n\t\tpcim_pin_device(dev);\n\tif (rc)\n\t\treturn rc;\n\n\thost->iomap = pcim_iomap_table(dev);\n\trc = dma_set_mask_and_coherent(&dev->dev, ATA_DMA_MASK);\n\tif (rc)\n\t\treturn rc;\n\tpci_set_master(dev);\n\n\t \n\tbase = host->iomap[0];\n\tif (!base)\n\t\treturn -ENOMEM;\n\tap->ops = &ninja32_port_ops;\n\tap->pio_mask = ATA_PIO4;\n\tap->flags |= ATA_FLAG_SLAVE_POSS;\n\n\tap->ioaddr.cmd_addr = base + 0x10;\n\tap->ioaddr.ctl_addr = base + 0x1E;\n\tap->ioaddr.altstatus_addr = base + 0x1E;\n\tap->ioaddr.bmdma_addr = base;\n\tata_sff_std_ports(&ap->ioaddr);\n\tap->pflags |= ATA_PFLAG_PIO32 | ATA_PFLAG_PIO32CHANGE;\n\n\tninja32_program(base);\n\t \n\treturn ata_host_activate(host, dev->irq, ata_bmdma_interrupt,\n\t\t\t\t IRQF_SHARED, &ninja32_sht);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ninja32_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\tninja32_program(host->iomap[0]);\n\tata_host_resume(host);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id ninja32[] = {\n\t{ 0x10FC, 0x0003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0x1145, 0x8008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0x1145, 0xf008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0x1145, 0xf021, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0x1145, 0xf024, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0x1145, 0xf02C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ },\n};\n\nstatic struct pci_driver ninja32_pci_driver = {\n\t.name \t\t= DRV_NAME,\n\t.id_table\t= ninja32,\n\t.probe \t\t= ninja32_init_one,\n\t.remove\t\t= ata_pci_remove_one,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= ata_pci_device_suspend,\n\t.resume\t\t= ninja32_reinit_one,\n#endif\n};\n\nmodule_pci_driver(ninja32_pci_driver);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"low-level driver for Ninja32 ATA\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, ninja32);\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}