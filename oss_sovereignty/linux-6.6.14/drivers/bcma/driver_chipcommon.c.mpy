{
  "module_name": "driver_chipcommon.c",
  "hash_id": "81c7d6c860f158697f9bd49455866e38a3af927f2347a77bd104d0401a724c40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/driver_chipcommon.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/bcm47xx_wdt.h>\n#include <linux/export.h>\n#include <linux/platform_device.h>\n#include <linux/bcma/bcma.h>\n\nstatic inline u32 bcma_cc_write32_masked(struct bcma_drv_cc *cc, u16 offset,\n\t\t\t\t\t u32 mask, u32 value)\n{\n\tvalue &= mask;\n\tvalue |= bcma_cc_read32(cc, offset) & ~mask;\n\tbcma_cc_write32(cc, offset, value);\n\n\treturn value;\n}\n\nu32 bcma_chipco_get_alp_clock(struct bcma_drv_cc *cc)\n{\n\tif (cc->capabilities & BCMA_CC_CAP_PMU)\n\t\treturn bcma_pmu_get_alp_clock(cc);\n\n\treturn 20000000;\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_get_alp_clock);\n\nstatic bool bcma_core_cc_has_pmu_watchdog(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tif (cc->capabilities & BCMA_CC_CAP_PMU) {\n\t\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM53573) {\n\t\t\tWARN(bus->chipinfo.rev <= 1, \"No watchdog available\\n\");\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nstatic u32 bcma_chipco_watchdog_get_max_timer(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tu32 nb;\n\n\tif (bcma_core_cc_has_pmu_watchdog(cc)) {\n\t\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)\n\t\t\tnb = 32;\n\t\telse if (cc->core->id.rev < 26)\n\t\t\tnb = 16;\n\t\telse\n\t\t\tnb = (cc->core->id.rev >= 37) ? 32 : 24;\n\t} else {\n\t\tnb = 28;\n\t}\n\tif (nb == 32)\n\t\treturn 0xffffffff;\n\telse\n\t\treturn (1 << nb) - 1;\n}\n\nstatic u32 bcma_chipco_watchdog_timer_set_wdt(struct bcm47xx_wdt *wdt,\n\t\t\t\t\t      u32 ticks)\n{\n\tstruct bcma_drv_cc *cc = bcm47xx_wdt_get_drvdata(wdt);\n\n\treturn bcma_chipco_watchdog_timer_set(cc, ticks);\n}\n\nstatic u32 bcma_chipco_watchdog_timer_set_ms_wdt(struct bcm47xx_wdt *wdt,\n\t\t\t\t\t\t u32 ms)\n{\n\tstruct bcma_drv_cc *cc = bcm47xx_wdt_get_drvdata(wdt);\n\tu32 ticks;\n\n\tticks = bcma_chipco_watchdog_timer_set(cc, cc->ticks_per_ms * ms);\n\treturn ticks / cc->ticks_per_ms;\n}\n\nstatic int bcma_chipco_watchdog_ticks_per_ms(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tif (cc->capabilities & BCMA_CC_CAP_PMU) {\n\t\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)\n\t\t\t \n\t\t\treturn bcma_chipco_get_alp_clock(cc) / 4000;\n\t\telse\n\t\t\t \n\t\t\treturn 32;\n\t} else {\n\t\treturn bcma_chipco_get_alp_clock(cc) / 1000;\n\t}\n}\n\nint bcma_chipco_watchdog_register(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tstruct bcm47xx_wdt wdt = {};\n\tstruct platform_device *pdev;\n\n\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM53573 &&\n\t    bus->chipinfo.rev <= 1) {\n\t\tpr_debug(\"No watchdog on 53573A0 / 53573A1\\n\");\n\t\treturn 0;\n\t}\n\n\twdt.driver_data = cc;\n\twdt.timer_set = bcma_chipco_watchdog_timer_set_wdt;\n\twdt.timer_set_ms = bcma_chipco_watchdog_timer_set_ms_wdt;\n\twdt.max_timer_ms =\n\t\tbcma_chipco_watchdog_get_max_timer(cc) / cc->ticks_per_ms;\n\n\tpdev = platform_device_register_data(NULL, \"bcm47xx-wdt\",\n\t\t\t\t\t     bus->num, &wdt,\n\t\t\t\t\t     sizeof(wdt));\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tcc->watchdog = pdev;\n\n\treturn 0;\n}\n\nstatic void bcma_core_chipcommon_flash_detect(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tswitch (cc->capabilities & BCMA_CC_CAP_FLASHT) {\n\tcase BCMA_CC_FLASHT_STSER:\n\tcase BCMA_CC_FLASHT_ATSER:\n\t\tbcma_debug(bus, \"Found serial flash\\n\");\n\t\tbcma_sflash_init(cc);\n\t\tbreak;\n\tcase BCMA_CC_FLASHT_PARA:\n\t\tbcma_debug(bus, \"Found parallel flash\\n\");\n\t\tbcma_pflash_init(cc);\n\t\tbreak;\n\tdefault:\n\t\tbcma_err(bus, \"Flash type not supported\\n\");\n\t}\n\n\tif (cc->core->id.rev == 38 ||\n\t    bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {\n\t\tif (cc->capabilities & BCMA_CC_CAP_NFLASH) {\n\t\t\tbcma_debug(bus, \"Found NAND flash\\n\");\n\t\t\tbcma_nflash_init(cc);\n\t\t}\n\t}\n}\n\nvoid bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tif (cc->early_setup_done)\n\t\treturn;\n\n\tspin_lock_init(&cc->gpio_lock);\n\n\tif (cc->core->id.rev >= 11)\n\t\tcc->status = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);\n\tcc->capabilities = bcma_cc_read32(cc, BCMA_CC_CAP);\n\tif (cc->core->id.rev >= 35)\n\t\tcc->capabilities_ext = bcma_cc_read32(cc, BCMA_CC_CAP_EXT);\n\n\tif (cc->capabilities & BCMA_CC_CAP_PMU)\n\t\tbcma_pmu_early_init(cc);\n\n\tif (bus->hosttype == BCMA_HOSTTYPE_SOC)\n\t\tbcma_core_chipcommon_flash_detect(cc);\n\n\tcc->early_setup_done = true;\n}\n\nvoid bcma_core_chipcommon_init(struct bcma_drv_cc *cc)\n{\n\tu32 leddc_on = 10;\n\tu32 leddc_off = 90;\n\n\tif (cc->setup_done)\n\t\treturn;\n\n\tbcma_core_chipcommon_early_init(cc);\n\n\tif (cc->core->id.rev >= 20) {\n\t\tu32 pullup = 0, pulldown = 0;\n\n\t\tif (cc->core->bus->chipinfo.id == BCMA_CHIP_ID_BCM43142) {\n\t\t\tpullup = 0x402e0;\n\t\t\tpulldown = 0x20500;\n\t\t}\n\n\t\tbcma_cc_write32(cc, BCMA_CC_GPIOPULLUP, pullup);\n\t\tbcma_cc_write32(cc, BCMA_CC_GPIOPULLDOWN, pulldown);\n\t}\n\n\tif (cc->capabilities & BCMA_CC_CAP_PMU)\n\t\tbcma_pmu_init(cc);\n\tif (cc->capabilities & BCMA_CC_CAP_PCTL)\n\t\tbcma_err(cc->core->bus, \"Power control not implemented!\\n\");\n\n\tif (cc->core->id.rev >= 16) {\n\t\tif (cc->core->bus->sprom.leddc_on_time &&\n\t\t    cc->core->bus->sprom.leddc_off_time) {\n\t\t\tleddc_on = cc->core->bus->sprom.leddc_on_time;\n\t\t\tleddc_off = cc->core->bus->sprom.leddc_off_time;\n\t\t}\n\t\tbcma_cc_write32(cc, BCMA_CC_GPIOTIMER,\n\t\t\t((leddc_on << BCMA_CC_GPIOTIMER_ONTIME_SHIFT) |\n\t\t\t (leddc_off << BCMA_CC_GPIOTIMER_OFFTIME_SHIFT)));\n\t}\n\tcc->ticks_per_ms = bcma_chipco_watchdog_ticks_per_ms(cc);\n\n\tcc->setup_done = true;\n}\n\n \nu32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks)\n{\n\tu32 maxt;\n\n\tmaxt = bcma_chipco_watchdog_get_max_timer(cc);\n\tif (bcma_core_cc_has_pmu_watchdog(cc)) {\n\t\tif (ticks == 1)\n\t\t\tticks = 2;\n\t\telse if (ticks > maxt)\n\t\t\tticks = maxt;\n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_WATCHDOG, ticks);\n\t} else {\n\t\tstruct bcma_bus *bus = cc->core->bus;\n\n\t\tif (bus->chipinfo.id != BCMA_CHIP_ID_BCM4707 &&\n\t\t    bus->chipinfo.id != BCMA_CHIP_ID_BCM47094 &&\n\t\t    bus->chipinfo.id != BCMA_CHIP_ID_BCM53018)\n\t\t\tbcma_core_set_clockmode(cc->core,\n\t\t\t\t\t\tticks ? BCMA_CLKMODE_FAST : BCMA_CLKMODE_DYNAMIC);\n\n\t\tif (ticks > maxt)\n\t\t\tticks = maxt;\n\t\t \n\t\tbcma_cc_write32(cc, BCMA_CC_WATCHDOG, ticks);\n\t}\n\treturn ticks;\n}\n\nvoid bcma_chipco_irq_mask(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tbcma_cc_write32_masked(cc, BCMA_CC_IRQMASK, mask, value);\n}\n\nu32 bcma_chipco_irq_status(struct bcma_drv_cc *cc, u32 mask)\n{\n\treturn bcma_cc_read32(cc, BCMA_CC_IRQSTAT) & mask;\n}\n\nu32 bcma_chipco_gpio_in(struct bcma_drv_cc *cc, u32 mask)\n{\n\treturn bcma_cc_read32(cc, BCMA_CC_GPIOIN) & mask;\n}\n\nu32 bcma_chipco_gpio_out(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOOUT, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_gpio_out);\n\nu32 bcma_chipco_gpio_outen(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOOUTEN, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_gpio_outen);\n\n \nu32 bcma_chipco_gpio_control(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOCTL, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_gpio_control);\n\nu32 bcma_chipco_gpio_intmask(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOIRQ, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 bcma_chipco_gpio_polarity(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOPOL, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 bcma_chipco_gpio_pullup(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tif (cc->core->id.rev < 20)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOPULLUP, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 bcma_chipco_gpio_pulldown(struct bcma_drv_cc *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res;\n\n\tif (cc->core->id.rev < 20)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = bcma_cc_write32_masked(cc, BCMA_CC_GPIOPULLDOWN, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\n#ifdef CONFIG_BCMA_DRIVER_MIPS\nvoid bcma_chipco_serial_init(struct bcma_drv_cc *cc)\n{\n\tunsigned int irq;\n\tu32 baud_base;\n\tu32 i;\n\tunsigned int ccrev = cc->core->id.rev;\n\tstruct bcma_serial_port *ports = cc->serial_ports;\n\n\tif (ccrev >= 11 && ccrev != 15) {\n\t\tbaud_base = bcma_chipco_get_alp_clock(cc);\n\t\tif (ccrev >= 21) {\n\t\t\t \n\t\t\tbcma_cc_write32(cc, BCMA_CC_CORECTL,\n\t\t\t\t       bcma_cc_read32(cc, BCMA_CC_CORECTL)\n\t\t\t\t       & ~BCMA_CC_CORECTL_UARTCLKEN);\n\t\t}\n\t\t \n\t\tbcma_cc_write32(cc, BCMA_CC_CORECTL,\n\t\t\t       bcma_cc_read32(cc, BCMA_CC_CORECTL)\n\t\t\t       | BCMA_CC_CORECTL_UARTCLK0);\n\t\tif (ccrev >= 21) {\n\t\t\t \n\t\t\tbcma_cc_write32(cc, BCMA_CC_CORECTL,\n\t\t\t\t       bcma_cc_read32(cc, BCMA_CC_CORECTL)\n\t\t\t\t       | BCMA_CC_CORECTL_UARTCLKEN);\n\t\t}\n\t} else {\n\t\tbcma_err(cc->core->bus, \"serial not supported on this device ccrev: 0x%x\\n\",\n\t\t\t ccrev);\n\t\treturn;\n\t}\n\n\tirq = bcma_core_irq(cc->core, 0);\n\n\t \n\tcc->nr_serial_ports = (cc->capabilities & BCMA_CC_CAP_NRUART);\n\tfor (i = 0; i < cc->nr_serial_ports; i++) {\n\t\tports[i].regs = cc->core->io_addr + BCMA_CC_UART0_DATA +\n\t\t\t\t(i * 256);\n\t\tports[i].irq = irq;\n\t\tports[i].baud_base = baud_base;\n\t\tports[i].reg_shift = 0;\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}