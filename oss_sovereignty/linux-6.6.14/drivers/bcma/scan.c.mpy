{
  "module_name": "scan.c",
  "hash_id": "1ac32a91656e8b573bd41a1b93bca467e529a16885d1fb42bee7e758957422e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/scan.c",
  "human_readable_source": " \n\n#include \"scan.h\"\n#include \"bcma_private.h\"\n\n#include <linux/bcma/bcma.h>\n#include <linux/bcma/bcma_regs.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\nstruct bcma_device_id_name {\n\tu16 id;\n\tconst char *name;\n};\n\nstatic const struct bcma_device_id_name bcma_arm_device_names[] = {\n\t{ BCMA_CORE_4706_MAC_GBIT_COMMON, \"BCM4706 GBit MAC Common\" },\n\t{ BCMA_CORE_ARM_1176, \"ARM 1176\" },\n\t{ BCMA_CORE_ARM_7TDMI, \"ARM 7TDMI\" },\n\t{ BCMA_CORE_ARM_CM3, \"ARM CM3\" },\n};\n\nstatic const struct bcma_device_id_name bcma_bcm_device_names[] = {\n\t{ BCMA_CORE_OOB_ROUTER, \"OOB Router\" },\n\t{ BCMA_CORE_4706_CHIPCOMMON, \"BCM4706 ChipCommon\" },\n\t{ BCMA_CORE_4706_SOC_RAM, \"BCM4706 SOC RAM\" },\n\t{ BCMA_CORE_4706_MAC_GBIT, \"BCM4706 GBit MAC\" },\n\t{ BCMA_CORE_NS_PCIEG2, \"PCIe Gen 2\" },\n\t{ BCMA_CORE_NS_DMA, \"DMA\" },\n\t{ BCMA_CORE_NS_SDIO3, \"SDIO3\" },\n\t{ BCMA_CORE_NS_USB20, \"USB 2.0\" },\n\t{ BCMA_CORE_NS_USB30, \"USB 3.0\" },\n\t{ BCMA_CORE_NS_A9JTAG, \"ARM Cortex A9 JTAG\" },\n\t{ BCMA_CORE_NS_DDR23, \"Denali DDR2/DDR3 memory controller\" },\n\t{ BCMA_CORE_NS_ROM, \"ROM\" },\n\t{ BCMA_CORE_NS_NAND, \"NAND flash controller\" },\n\t{ BCMA_CORE_NS_QSPI, \"SPI flash controller\" },\n\t{ BCMA_CORE_NS_CHIPCOMMON_B, \"Chipcommon B\" },\n\t{ BCMA_CORE_ARMCA9, \"ARM Cortex A9 core (ihost)\" },\n\t{ BCMA_CORE_AMEMC, \"AMEMC (DDR)\" },\n\t{ BCMA_CORE_ALTA, \"ALTA (I2S)\" },\n\t{ BCMA_CORE_INVALID, \"Invalid\" },\n\t{ BCMA_CORE_CHIPCOMMON, \"ChipCommon\" },\n\t{ BCMA_CORE_ILINE20, \"ILine 20\" },\n\t{ BCMA_CORE_SRAM, \"SRAM\" },\n\t{ BCMA_CORE_SDRAM, \"SDRAM\" },\n\t{ BCMA_CORE_PCI, \"PCI\" },\n\t{ BCMA_CORE_ETHERNET, \"Fast Ethernet\" },\n\t{ BCMA_CORE_V90, \"V90\" },\n\t{ BCMA_CORE_USB11_HOSTDEV, \"USB 1.1 Hostdev\" },\n\t{ BCMA_CORE_ADSL, \"ADSL\" },\n\t{ BCMA_CORE_ILINE100, \"ILine 100\" },\n\t{ BCMA_CORE_IPSEC, \"IPSEC\" },\n\t{ BCMA_CORE_UTOPIA, \"UTOPIA\" },\n\t{ BCMA_CORE_PCMCIA, \"PCMCIA\" },\n\t{ BCMA_CORE_INTERNAL_MEM, \"Internal Memory\" },\n\t{ BCMA_CORE_MEMC_SDRAM, \"MEMC SDRAM\" },\n\t{ BCMA_CORE_OFDM, \"OFDM\" },\n\t{ BCMA_CORE_EXTIF, \"EXTIF\" },\n\t{ BCMA_CORE_80211, \"IEEE 802.11\" },\n\t{ BCMA_CORE_PHY_A, \"PHY A\" },\n\t{ BCMA_CORE_PHY_B, \"PHY B\" },\n\t{ BCMA_CORE_PHY_G, \"PHY G\" },\n\t{ BCMA_CORE_USB11_HOST, \"USB 1.1 Host\" },\n\t{ BCMA_CORE_USB11_DEV, \"USB 1.1 Device\" },\n\t{ BCMA_CORE_USB20_HOST, \"USB 2.0 Host\" },\n\t{ BCMA_CORE_USB20_DEV, \"USB 2.0 Device\" },\n\t{ BCMA_CORE_SDIO_HOST, \"SDIO Host\" },\n\t{ BCMA_CORE_ROBOSWITCH, \"Roboswitch\" },\n\t{ BCMA_CORE_PARA_ATA, \"PATA\" },\n\t{ BCMA_CORE_SATA_XORDMA, \"SATA XOR-DMA\" },\n\t{ BCMA_CORE_ETHERNET_GBIT, \"GBit Ethernet\" },\n\t{ BCMA_CORE_PCIE, \"PCIe\" },\n\t{ BCMA_CORE_PHY_N, \"PHY N\" },\n\t{ BCMA_CORE_SRAM_CTL, \"SRAM Controller\" },\n\t{ BCMA_CORE_MINI_MACPHY, \"Mini MACPHY\" },\n\t{ BCMA_CORE_PHY_LP, \"PHY LP\" },\n\t{ BCMA_CORE_PMU, \"PMU\" },\n\t{ BCMA_CORE_PHY_SSN, \"PHY SSN\" },\n\t{ BCMA_CORE_SDIO_DEV, \"SDIO Device\" },\n\t{ BCMA_CORE_PHY_HT, \"PHY HT\" },\n\t{ BCMA_CORE_MAC_GBIT, \"GBit MAC\" },\n\t{ BCMA_CORE_DDR12_MEM_CTL, \"DDR1/DDR2 Memory Controller\" },\n\t{ BCMA_CORE_PCIE_RC, \"PCIe Root Complex\" },\n\t{ BCMA_CORE_OCP_OCP_BRIDGE, \"OCP to OCP Bridge\" },\n\t{ BCMA_CORE_SHARED_COMMON, \"Common Shared\" },\n\t{ BCMA_CORE_OCP_AHB_BRIDGE, \"OCP to AHB Bridge\" },\n\t{ BCMA_CORE_SPI_HOST, \"SPI Host\" },\n\t{ BCMA_CORE_I2S, \"I2S\" },\n\t{ BCMA_CORE_SDR_DDR1_MEM_CTL, \"SDR/DDR1 Memory Controller\" },\n\t{ BCMA_CORE_SHIM, \"SHIM\" },\n\t{ BCMA_CORE_PCIE2, \"PCIe Gen2\" },\n\t{ BCMA_CORE_ARM_CR4, \"ARM CR4\" },\n\t{ BCMA_CORE_GCI, \"GCI\" },\n\t{ BCMA_CORE_CMEM, \"CNDS DDR2/3 memory controller\" },\n\t{ BCMA_CORE_ARM_CA7, \"ARM CA7\" },\n\t{ BCMA_CORE_DEFAULT, \"Default\" },\n};\n\nstatic const struct bcma_device_id_name bcma_mips_device_names[] = {\n\t{ BCMA_CORE_MIPS, \"MIPS\" },\n\t{ BCMA_CORE_MIPS_3302, \"MIPS 3302\" },\n\t{ BCMA_CORE_MIPS_74K, \"MIPS 74K\" },\n};\n\nstatic const char *bcma_device_name(const struct bcma_device_id *id)\n{\n\tconst struct bcma_device_id_name *names;\n\tint size, i;\n\n\t \n\tswitch (id->manuf) {\n\tcase BCMA_MANUF_ARM:\n\t\tnames = bcma_arm_device_names;\n\t\tsize = ARRAY_SIZE(bcma_arm_device_names);\n\t\tbreak;\n\tcase BCMA_MANUF_BCM:\n\t\tnames = bcma_bcm_device_names;\n\t\tsize = ARRAY_SIZE(bcma_bcm_device_names);\n\t\tbreak;\n\tcase BCMA_MANUF_MIPS:\n\t\tnames = bcma_mips_device_names;\n\t\tsize = ARRAY_SIZE(bcma_mips_device_names);\n\t\tbreak;\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (names[i].id == id->id)\n\t\t\treturn names[i].name;\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\nstatic u32 bcma_scan_read32(struct bcma_bus *bus, u16 offset)\n{\n\treturn readl(bus->mmio + offset);\n}\n\nstatic void bcma_scan_switch_core(struct bcma_bus *bus, u32 addr)\n{\n\tif (bus->hosttype == BCMA_HOSTTYPE_PCI)\n\t\tpci_write_config_dword(bus->host_pci, BCMA_PCI_BAR0_WIN,\n\t\t\t\t       addr);\n}\n\nstatic u32 bcma_erom_get_ent(struct bcma_bus *bus, u32 __iomem **eromptr)\n{\n\tu32 ent = readl(*eromptr);\n\t(*eromptr)++;\n\treturn ent;\n}\n\nstatic void bcma_erom_push_ent(u32 __iomem **eromptr)\n{\n\t(*eromptr)--;\n}\n\nstatic s32 bcma_erom_get_ci(struct bcma_bus *bus, u32 __iomem **eromptr)\n{\n\tu32 ent = bcma_erom_get_ent(bus, eromptr);\n\tif (!(ent & SCAN_ER_VALID))\n\t\treturn -ENOENT;\n\tif ((ent & SCAN_ER_TAG) != SCAN_ER_TAG_CI)\n\t\treturn -ENOENT;\n\treturn ent;\n}\n\nstatic bool bcma_erom_is_end(struct bcma_bus *bus, u32 __iomem **eromptr)\n{\n\tu32 ent = bcma_erom_get_ent(bus, eromptr);\n\tbcma_erom_push_ent(eromptr);\n\treturn (ent == (SCAN_ER_TAG_END | SCAN_ER_VALID));\n}\n\nstatic bool bcma_erom_is_bridge(struct bcma_bus *bus, u32 __iomem **eromptr)\n{\n\tu32 ent = bcma_erom_get_ent(bus, eromptr);\n\tbcma_erom_push_ent(eromptr);\n\treturn (((ent & SCAN_ER_VALID)) &&\n\t\t((ent & SCAN_ER_TAGX) == SCAN_ER_TAG_ADDR) &&\n\t\t((ent & SCAN_ADDR_TYPE) == SCAN_ADDR_TYPE_BRIDGE));\n}\n\nstatic void bcma_erom_skip_component(struct bcma_bus *bus, u32 __iomem **eromptr)\n{\n\tu32 ent;\n\twhile (1) {\n\t\tent = bcma_erom_get_ent(bus, eromptr);\n\t\tif ((ent & SCAN_ER_VALID) &&\n\t\t    ((ent & SCAN_ER_TAG) == SCAN_ER_TAG_CI))\n\t\t\tbreak;\n\t\tif (ent == (SCAN_ER_TAG_END | SCAN_ER_VALID))\n\t\t\tbreak;\n\t}\n\tbcma_erom_push_ent(eromptr);\n}\n\nstatic s32 bcma_erom_get_mst_port(struct bcma_bus *bus, u32 __iomem **eromptr)\n{\n\tu32 ent = bcma_erom_get_ent(bus, eromptr);\n\tif (!(ent & SCAN_ER_VALID))\n\t\treturn -ENOENT;\n\tif ((ent & SCAN_ER_TAG) != SCAN_ER_TAG_MP)\n\t\treturn -ENOENT;\n\treturn ent;\n}\n\nstatic u32 bcma_erom_get_addr_desc(struct bcma_bus *bus, u32 __iomem **eromptr,\n\t\t\t\t  u32 type, u8 port)\n{\n\tu32 addrl;\n\tu32 size;\n\n\tu32 ent = bcma_erom_get_ent(bus, eromptr);\n\tif ((!(ent & SCAN_ER_VALID)) ||\n\t    ((ent & SCAN_ER_TAGX) != SCAN_ER_TAG_ADDR) ||\n\t    ((ent & SCAN_ADDR_TYPE) != type) ||\n\t    (((ent & SCAN_ADDR_PORT) >> SCAN_ADDR_PORT_SHIFT) != port)) {\n\t\tbcma_erom_push_ent(eromptr);\n\t\treturn (u32)-EINVAL;\n\t}\n\n\taddrl = ent & SCAN_ADDR_ADDR;\n\tif (ent & SCAN_ADDR_AG32)\n\t\tbcma_erom_get_ent(bus, eromptr);\n\n\tif ((ent & SCAN_ADDR_SZ) == SCAN_ADDR_SZ_SZD) {\n\t\tsize = bcma_erom_get_ent(bus, eromptr);\n\t\tif (size & SCAN_SIZE_SG32)\n\t\t\tbcma_erom_get_ent(bus, eromptr);\n\t}\n\n\treturn addrl;\n}\n\nstatic struct bcma_device *bcma_find_core_by_index(struct bcma_bus *bus,\n\t\t\t\t\t\t   u16 index)\n{\n\tstruct bcma_device *core;\n\n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\tif (core->core_index == index)\n\t\t\treturn core;\n\t}\n\treturn NULL;\n}\n\nstatic struct bcma_device *bcma_find_core_reverse(struct bcma_bus *bus, u16 coreid)\n{\n\tstruct bcma_device *core;\n\n\tlist_for_each_entry_reverse(core, &bus->cores, list) {\n\t\tif (core->id.id == coreid)\n\t\t\treturn core;\n\t}\n\treturn NULL;\n}\n\n#define IS_ERR_VALUE_U32(x) ((x) >= (u32)-MAX_ERRNO)\n\nstatic int bcma_get_next_core(struct bcma_bus *bus, u32 __iomem **eromptr,\n\t\t\t      struct bcma_device_id *match, int core_num,\n\t\t\t      struct bcma_device *core)\n{\n\tu32 tmp;\n\tu8 i, j, k;\n\ts32 cia, cib;\n\tu8 ports[2], wrappers[2];\n\n\t \n\tcia = bcma_erom_get_ci(bus, eromptr);\n\tif (cia < 0) {\n\t\tbcma_erom_push_ent(eromptr);\n\t\tif (bcma_erom_is_end(bus, eromptr))\n\t\t\treturn -ESPIPE;\n\t\treturn -EILSEQ;\n\t}\n\tcib = bcma_erom_get_ci(bus, eromptr);\n\tif (cib < 0)\n\t\treturn -EILSEQ;\n\n\t \n\tcore->id.class = (cia & SCAN_CIA_CLASS) >> SCAN_CIA_CLASS_SHIFT;\n\tcore->id.id = (cia & SCAN_CIA_ID) >> SCAN_CIA_ID_SHIFT;\n\tcore->id.manuf = (cia & SCAN_CIA_MANUF) >> SCAN_CIA_MANUF_SHIFT;\n\tports[0] = (cib & SCAN_CIB_NMP) >> SCAN_CIB_NMP_SHIFT;\n\tports[1] = (cib & SCAN_CIB_NSP) >> SCAN_CIB_NSP_SHIFT;\n\twrappers[0] = (cib & SCAN_CIB_NMW) >> SCAN_CIB_NMW_SHIFT;\n\twrappers[1] = (cib & SCAN_CIB_NSW) >> SCAN_CIB_NSW_SHIFT;\n\tcore->id.rev = (cib & SCAN_CIB_REV) >> SCAN_CIB_REV_SHIFT;\n\n\tif (((core->id.manuf == BCMA_MANUF_ARM) &&\n\t     (core->id.id == 0xFFF)) ||\n\t    (ports[1] == 0)) {\n\t\tbcma_erom_skip_component(bus, eromptr);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (wrappers[0] + wrappers[1] == 0) {\n\t\t \n\t\tswitch (core->id.id) {\n\t\tcase BCMA_CORE_4706_MAC_GBIT_COMMON:\n\t\tcase BCMA_CORE_NS_CHIPCOMMON_B:\n\t\tcase BCMA_CORE_PMU:\n\t\tcase BCMA_CORE_GCI:\n\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbcma_erom_skip_component(bus, eromptr);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tif (bcma_erom_is_bridge(bus, eromptr)) {\n\t\tbcma_erom_skip_component(bus, eromptr);\n\t\treturn -ENXIO;\n\t}\n\n\tif (bcma_find_core_by_index(bus, core_num)) {\n\t\tbcma_erom_skip_component(bus, eromptr);\n\t\treturn -ENODEV;\n\t}\n\n\tif (match && ((match->manuf != BCMA_ANY_MANUF &&\n\t      match->manuf != core->id.manuf) ||\n\t     (match->id != BCMA_ANY_ID && match->id != core->id.id) ||\n\t     (match->rev != BCMA_ANY_REV && match->rev != core->id.rev) ||\n\t     (match->class != BCMA_ANY_CLASS && match->class != core->id.class)\n\t    )) {\n\t\tbcma_erom_skip_component(bus, eromptr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < ports[0]; i++) {\n\t\ts32 mst_port_d = bcma_erom_get_mst_port(bus, eromptr);\n\t\tif (mst_port_d < 0)\n\t\t\treturn -EILSEQ;\n\t}\n\n\t \n\ttmp = bcma_erom_get_addr_desc(bus, eromptr, SCAN_ADDR_TYPE_SLAVE, 0);\n\tif (tmp == 0 || IS_ERR_VALUE_U32(tmp)) {\n\t\t \n\t\ttmp = bcma_erom_get_addr_desc(bus, eromptr,\n\t\t\t\t\t      SCAN_ADDR_TYPE_BRIDGE, 0);\n\t\tif (tmp == 0 || IS_ERR_VALUE_U32(tmp)) {\n\t\t\treturn -EILSEQ;\n\t\t} else {\n\t\t\tbcma_info(bus, \"Bridge found\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\tcore->addr = tmp;\n\n\t \n\tk = 0;\n\tfor (i = 0; i < ports[1]; i++) {\n\t\tfor (j = 0; ; j++) {\n\t\t\ttmp = bcma_erom_get_addr_desc(bus, eromptr,\n\t\t\t\tSCAN_ADDR_TYPE_SLAVE, i);\n\t\t\tif (IS_ERR_VALUE_U32(tmp)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else if (k < ARRAY_SIZE(core->addr_s)) {\n\t\t\t\tcore->addr_s[k] = tmp;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < wrappers[0]; i++) {\n\t\tfor (j = 0; ; j++) {\n\t\t\ttmp = bcma_erom_get_addr_desc(bus, eromptr,\n\t\t\t\tSCAN_ADDR_TYPE_MWRAP, i);\n\t\t\tif (IS_ERR_VALUE_U32(tmp)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (i == 0 && j == 0)\n\t\t\t\t\tcore->wrap = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < wrappers[1]; i++) {\n\t\tu8 hack = (ports[1] == 1) ? 0 : 1;\n\t\tfor (j = 0; ; j++) {\n\t\t\ttmp = bcma_erom_get_addr_desc(bus, eromptr,\n\t\t\t\tSCAN_ADDR_TYPE_SWRAP, i + hack);\n\t\t\tif (IS_ERR_VALUE_U32(tmp)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (wrappers[0] == 0 && !i && !j)\n\t\t\t\t\tcore->wrap = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tif (bus->hosttype == BCMA_HOSTTYPE_SOC) {\n\t\tcore->io_addr = ioremap(core->addr, BCMA_CORE_SIZE);\n\t\tif (!core->io_addr)\n\t\t\treturn -ENOMEM;\n\t\tif (core->wrap) {\n\t\t\tcore->io_wrap = ioremap(core->wrap,\n\t\t\t\t\t\t\tBCMA_CORE_SIZE);\n\t\t\tif (!core->io_wrap) {\n\t\t\t\tiounmap(core->io_addr);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid bcma_detect_chip(struct bcma_bus *bus)\n{\n\ts32 tmp;\n\tstruct bcma_chipinfo *chipinfo = &(bus->chipinfo);\n\tchar chip_id[8];\n\n\tbcma_scan_switch_core(bus, BCMA_ADDR_BASE);\n\n\ttmp = bcma_scan_read32(bus, BCMA_CC_ID);\n\tchipinfo->id = (tmp & BCMA_CC_ID_ID) >> BCMA_CC_ID_ID_SHIFT;\n\tchipinfo->rev = (tmp & BCMA_CC_ID_REV) >> BCMA_CC_ID_REV_SHIFT;\n\tchipinfo->pkg = (tmp & BCMA_CC_ID_PKG) >> BCMA_CC_ID_PKG_SHIFT;\n\n\tsnprintf(chip_id, ARRAY_SIZE(chip_id),\n\t\t (chipinfo->id > 0x9999) ? \"%d\" : \"0x%04X\", chipinfo->id);\n\tbcma_info(bus, \"Found chip with id %s, rev 0x%02X and package 0x%02X\\n\",\n\t\t  chip_id, chipinfo->rev, chipinfo->pkg);\n}\n\nint bcma_bus_scan(struct bcma_bus *bus)\n{\n\tu32 erombase;\n\tu32 __iomem *eromptr, *eromend;\n\n\tint err, core_num = 0;\n\n\t \n\tif (bus->nr_cores)\n\t\treturn 0;\n\n\terombase = bcma_scan_read32(bus, BCMA_CC_EROM);\n\tif (bus->hosttype == BCMA_HOSTTYPE_SOC) {\n\t\teromptr = ioremap(erombase, BCMA_CORE_SIZE);\n\t\tif (!eromptr)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\teromptr = bus->mmio;\n\t}\n\n\teromend = eromptr + BCMA_CORE_SIZE / sizeof(u32);\n\n\tbcma_scan_switch_core(bus, erombase);\n\n\twhile (eromptr < eromend) {\n\t\tstruct bcma_device *other_core;\n\t\tstruct bcma_device *core = kzalloc(sizeof(*core), GFP_KERNEL);\n\t\tif (!core) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tINIT_LIST_HEAD(&core->list);\n\t\tcore->bus = bus;\n\n\t\terr = bcma_get_next_core(bus, &eromptr, NULL, core_num, core);\n\t\tif (err < 0) {\n\t\t\tkfree(core);\n\t\t\tif (err == -ENODEV) {\n\t\t\t\tcore_num++;\n\t\t\t\tcontinue;\n\t\t\t} else if (err == -ENXIO) {\n\t\t\t\tcontinue;\n\t\t\t} else if (err == -ESPIPE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tcore->core_index = core_num++;\n\t\tbus->nr_cores++;\n\t\tother_core = bcma_find_core_reverse(bus, core->id.id);\n\t\tcore->core_unit = (other_core == NULL) ? 0 : other_core->core_unit + 1;\n\t\tbcma_prepare_core(bus, core);\n\n\t\tbcma_info(bus, \"Core %d found: %s (manuf 0x%03X, id 0x%03X, rev 0x%02X, class 0x%X)\\n\",\n\t\t\t  core->core_index, bcma_device_name(&core->id),\n\t\t\t  core->id.manuf, core->id.id, core->id.rev,\n\t\t\t  core->id.class);\n\n\t\tlist_add_tail(&core->list, &bus->cores);\n\t}\n\n\terr = 0;\nout:\n\tif (bus->hosttype == BCMA_HOSTTYPE_SOC)\n\t\tiounmap(eromptr);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}