{
  "module_name": "bcma_private.h",
  "hash_id": "325a8ac78b1e6520e2177c09829e66d3ea0164f0b8c10386547651fd5780296f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/bcma_private.h",
  "human_readable_source": " \n#ifndef LINUX_BCMA_PRIVATE_H_\n#define LINUX_BCMA_PRIVATE_H_\n\n#ifndef pr_fmt\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n#endif\n\n#include <linux/bcma/bcma.h>\n#include <linux/delay.h>\n\n#define bcma_err(bus, fmt, ...) \\\n\tdev_err((bus)->dev, \"bus%d: \" fmt, (bus)->num, ##__VA_ARGS__)\n#define bcma_warn(bus, fmt, ...) \\\n\tdev_warn((bus)->dev, \"bus%d: \" fmt, (bus)->num, ##__VA_ARGS__)\n#define bcma_info(bus, fmt, ...) \\\n\tdev_info((bus)->dev, \"bus%d: \" fmt, (bus)->num, ##__VA_ARGS__)\n#define bcma_debug(bus, fmt, ...) \\\n\tdev_dbg((bus)->dev, \"bus%d: \" fmt, (bus)->num, ##__VA_ARGS__)\n\nstruct bcma_bus;\n\n \nbool bcma_wait_value(struct bcma_device *core, u16 reg, u32 mask, u32 value,\n\t\t     int timeout);\nvoid bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core);\nvoid bcma_init_bus(struct bcma_bus *bus);\nvoid bcma_unregister_cores(struct bcma_bus *bus);\nint bcma_bus_register(struct bcma_bus *bus);\nvoid bcma_bus_unregister(struct bcma_bus *bus);\nint __init bcma_bus_early_register(struct bcma_bus *bus);\n#ifdef CONFIG_PM\nint bcma_bus_suspend(struct bcma_bus *bus);\nint bcma_bus_resume(struct bcma_bus *bus);\n#endif\n\n \nvoid bcma_detect_chip(struct bcma_bus *bus);\nint bcma_bus_scan(struct bcma_bus *bus);\n\n \nint bcma_sprom_get(struct bcma_bus *bus);\n\n \nvoid bcma_core_chipcommon_early_init(struct bcma_drv_cc *cc);\nvoid bcma_core_chipcommon_init(struct bcma_drv_cc *cc);\nvoid bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable);\n#ifdef CONFIG_BCMA_DRIVER_MIPS\nvoid bcma_chipco_serial_init(struct bcma_drv_cc *cc);\n#endif  \n\n \nint bcma_core_chipcommon_b_init(struct bcma_drv_cc_b *ccb);\nvoid bcma_core_chipcommon_b_free(struct bcma_drv_cc_b *ccb);\n\n \nvoid bcma_pmu_early_init(struct bcma_drv_cc *cc);\nvoid bcma_pmu_init(struct bcma_drv_cc *cc);\nu32 bcma_pmu_get_alp_clock(struct bcma_drv_cc *cc);\nu32 bcma_pmu_get_cpu_clock(struct bcma_drv_cc *cc);\n\n \n\n#ifdef CONFIG_BCMA_PFLASH\nextern struct platform_device bcma_pflash_dev;\nint bcma_pflash_init(struct bcma_drv_cc *cc);\n#else\nstatic inline int bcma_pflash_init(struct bcma_drv_cc *cc)\n{\n\tbcma_err(cc->core->bus, \"Parallel flash not supported\\n\");\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_BCMA_SFLASH\n \nint bcma_sflash_init(struct bcma_drv_cc *cc);\nextern struct platform_device bcma_sflash_dev;\n#else\nstatic inline int bcma_sflash_init(struct bcma_drv_cc *cc)\n{\n\tbcma_err(cc->core->bus, \"Serial flash not supported\\n\");\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_BCMA_NFLASH\n \nint bcma_nflash_init(struct bcma_drv_cc *cc);\nextern struct platform_device bcma_nflash_dev;\n#else\nstatic inline int bcma_nflash_init(struct bcma_drv_cc *cc)\n{\n\tbcma_err(cc->core->bus, \"NAND flash not supported\\n\");\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_BCMA_HOST_PCI\n \nextern int __init bcma_host_pci_init(void);\nextern void __exit bcma_host_pci_exit(void);\n#endif  \n\n \n#if defined(CONFIG_BCMA_HOST_SOC) && defined(CONFIG_OF)\nextern int __init bcma_host_soc_register_driver(void);\nextern void __exit bcma_host_soc_unregister_driver(void);\n#else\nstatic inline int __init bcma_host_soc_register_driver(void)\n{\n\treturn 0;\n}\nstatic inline void __exit bcma_host_soc_unregister_driver(void)\n{\n}\n#endif  \n\n \n#ifdef CONFIG_BCMA_DRIVER_PCI\nu32 bcma_pcie_read(struct bcma_drv_pci *pc, u32 address);\nvoid bcma_core_pci_early_init(struct bcma_drv_pci *pc);\nvoid bcma_core_pci_init(struct bcma_drv_pci *pc);\nvoid bcma_core_pci_up(struct bcma_drv_pci *pc);\nvoid bcma_core_pci_down(struct bcma_drv_pci *pc);\n#else\nstatic inline void bcma_core_pci_early_init(struct bcma_drv_pci *pc)\n{\n\tWARN_ON(pc->core->bus->hosttype == BCMA_HOSTTYPE_PCI);\n}\nstatic inline void bcma_core_pci_init(struct bcma_drv_pci *pc)\n{\n\t \n\tWARN_ON(pc->core->bus->hosttype == BCMA_HOSTTYPE_PCI);\n}\n#endif\n\n \n#ifdef CONFIG_BCMA_DRIVER_PCI\nvoid bcma_core_pcie2_init(struct bcma_drv_pcie2 *pcie2);\nvoid bcma_core_pcie2_up(struct bcma_drv_pcie2 *pcie2);\n#else\nstatic inline void bcma_core_pcie2_init(struct bcma_drv_pcie2 *pcie2)\n{\n\t \n\tWARN_ON(pcie2->core->bus->hosttype == BCMA_HOSTTYPE_PCI);\n}\n#endif\n\nextern int bcma_chipco_watchdog_register(struct bcma_drv_cc *cc);\n\n#ifdef CONFIG_BCMA_DRIVER_PCI_HOSTMODE\nbool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc);\nvoid bcma_core_pci_hostmode_init(struct bcma_drv_pci *pc);\n#else\nstatic inline bool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc)\n{\n\treturn false;\n}\nstatic inline void bcma_core_pci_hostmode_init(struct bcma_drv_pci *pc)\n{\n}\n#endif  \n\n \n\n#ifdef CONFIG_BCMA_DRIVER_MIPS\nunsigned int bcma_core_mips_irq(struct bcma_device *dev);\nvoid bcma_core_mips_early_init(struct bcma_drv_mips *mcore);\nvoid bcma_core_mips_init(struct bcma_drv_mips *mcore);\n#else\nstatic inline unsigned int bcma_core_mips_irq(struct bcma_device *dev)\n{\n\treturn 0;\n}\nstatic inline void bcma_core_mips_early_init(struct bcma_drv_mips *mcore)\n{\n}\nstatic inline void bcma_core_mips_init(struct bcma_drv_mips *mcore)\n{\n}\n#endif\n\n \n\n#ifdef CONFIG_BCMA_DRIVER_GMAC_CMN\nvoid bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc);\n#else\nstatic inline void bcma_core_gmac_cmn_init(struct bcma_drv_gmac_cmn *gc)\n{\n}\n#endif\n\n#ifdef CONFIG_BCMA_DRIVER_GPIO\n \nint bcma_gpio_init(struct bcma_drv_cc *cc);\nint bcma_gpio_unregister(struct bcma_drv_cc *cc);\n#else\nstatic inline int bcma_gpio_init(struct bcma_drv_cc *cc)\n{\n\treturn -ENOTSUPP;\n}\nstatic inline int bcma_gpio_unregister(struct bcma_drv_cc *cc)\n{\n\treturn 0;\n}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}