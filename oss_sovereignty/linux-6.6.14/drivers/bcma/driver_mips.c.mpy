{
  "module_name": "driver_mips.c",
  "hash_id": "6be2d832304703eb31ef97030b6fa86e901d554f8ec816226691e4790cadd5dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/driver_mips.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n\n#include <linux/bcma/bcma.h>\n\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/time.h>\n#ifdef CONFIG_BCM47XX\n#include <linux/bcm47xx_nvram.h>\n#endif\n\nenum bcma_boot_dev {\n\tBCMA_BOOT_DEV_UNK = 0,\n\tBCMA_BOOT_DEV_ROM,\n\tBCMA_BOOT_DEV_PARALLEL,\n\tBCMA_BOOT_DEV_SERIAL,\n\tBCMA_BOOT_DEV_NAND,\n};\n\n \nstatic inline bool bcma_core_mips_bcm47162a0_quirk(struct bcma_device *dev)\n{\n\treturn dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM47162 &&\n\t       dev->bus->chipinfo.rev == 0 && dev->id.id == BCMA_CORE_MIPS_74K;\n}\n\n \nstatic inline bool bcma_core_mips_bcm5357b0_quirk(struct bcma_device *dev)\n{\n\treturn (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\n\t\tdev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) &&\n\t       dev->bus->chipinfo.pkg == 11 &&\n\t       dev->id.id == BCMA_CORE_USB20_HOST;\n}\n\nstatic u32 bcma_core_mips_irqflag(struct bcma_device *dev)\n{\n\tu32 flag;\n\n\tif (bcma_core_mips_bcm47162a0_quirk(dev))\n\t\treturn dev->core_index;\n\tif (bcma_core_mips_bcm5357b0_quirk(dev))\n\t\treturn dev->core_index;\n\tflag = bcma_aread32(dev, BCMA_MIPS_OOBSELOUTA30);\n\n\tif (flag)\n\t\treturn flag & 0x1F;\n\telse\n\t\treturn 0x3f;\n}\n\n \nunsigned int bcma_core_mips_irq(struct bcma_device *dev)\n{\n\tstruct bcma_device *mdev = dev->bus->drv_mips.core;\n\tu32 irqflag;\n\tunsigned int irq;\n\n\tirqflag = bcma_core_mips_irqflag(dev);\n\tif (irqflag == 0x3f)\n\t\treturn 6;\n\n\tfor (irq = 0; irq <= 4; irq++)\n\t\tif (bcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq)) &\n\t\t    (1 << irqflag))\n\t\t\treturn irq;\n\n\treturn 5;\n}\n\nstatic void bcma_core_mips_set_irq(struct bcma_device *dev, unsigned int irq)\n{\n\tunsigned int oldirq = bcma_core_mips_irq(dev);\n\tstruct bcma_bus *bus = dev->bus;\n\tstruct bcma_device *mdev = bus->drv_mips.core;\n\tu32 irqflag;\n\n\tirqflag = bcma_core_mips_irqflag(dev);\n\tBUG_ON(oldirq == 6);\n\n\tdev->irq = irq + 2;\n\n\t \n\tif (oldirq == 0)\n\t\tbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0),\n\t\t\t    bcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0)) &\n\t\t\t    ~(1 << irqflag));\n\telse if (oldirq != 5)\n\t\tbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(oldirq), 0);\n\n\t \n\tif (irq == 0) {\n\t\tbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0),\n\t\t\t    bcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0)) |\n\t\t\t    (1 << irqflag));\n\t} else {\n\t\tu32 irqinitmask = bcma_read32(mdev,\n\t\t\t\t\t      BCMA_MIPS_MIPS74K_INTMASK(irq));\n\t\tif (irqinitmask) {\n\t\t\tstruct bcma_device *core;\n\n\t\t\t \n\t\t\tlist_for_each_entry(core, &bus->cores, list) {\n\t\t\t\tif ((1 << bcma_core_mips_irqflag(core)) ==\n\t\t\t\t    irqinitmask) {\n\t\t\t\t\tbcma_core_mips_set_irq(core, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq),\n\t\t\t     1 << irqflag);\n\t}\n\n\tbcma_debug(bus, \"set_irq: core 0x%04x, irq %d => %d\\n\",\n\t\t   dev->id.id, oldirq <= 4 ? oldirq + 2 : 0, irq + 2);\n}\n\nstatic void bcma_core_mips_set_irq_name(struct bcma_bus *bus, unsigned int irq,\n\t\t\t\t\tu16 coreid, u8 unit)\n{\n\tstruct bcma_device *core;\n\n\tcore = bcma_find_core_unit(bus, coreid, unit);\n\tif (!core) {\n\t\tbcma_warn(bus,\n\t\t\t  \"Can not find core (id: 0x%x, unit %i) for IRQ configuration.\\n\",\n\t\t\t  coreid, unit);\n\t\treturn;\n\t}\n\n\tbcma_core_mips_set_irq(core, irq);\n}\n\nstatic void bcma_core_mips_print_irq(struct bcma_device *dev, unsigned int irq)\n{\n\tint i;\n\tstatic const char *irq_name[] = {\"2(S)\", \"3\", \"4\", \"5\", \"6\", \"D\", \"I\"};\n\tchar interrupts[25];\n\tchar *ints = interrupts;\n\n\tfor (i = 0; i < ARRAY_SIZE(irq_name); i++)\n\t\tints += sprintf(ints, \" %s%c\",\n\t\t\t\tirq_name[i], i == irq ? '*' : ' ');\n\n\tbcma_debug(dev->bus, \"core 0x%04x, irq:%s\\n\", dev->id.id, interrupts);\n}\n\nstatic void bcma_core_mips_dump_irq(struct bcma_bus *bus)\n{\n\tstruct bcma_device *core;\n\n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\tbcma_core_mips_print_irq(core, bcma_core_mips_irq(core));\n\t}\n}\n\nu32 bcma_cpu_clock(struct bcma_drv_mips *mcore)\n{\n\tstruct bcma_bus *bus = mcore->core->bus;\n\n\tif (bus->drv_cc.capabilities & BCMA_CC_CAP_PMU)\n\t\treturn bcma_pmu_get_cpu_clock(&bus->drv_cc);\n\n\tbcma_err(bus, \"No PMU available, need this to get the cpu clock\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(bcma_cpu_clock);\n\nstatic enum bcma_boot_dev bcma_boot_dev(struct bcma_bus *bus)\n{\n\tstruct bcma_drv_cc *cc = &bus->drv_cc;\n\tu8 cc_rev = cc->core->id.rev;\n\n\tif (cc_rev == 42) {\n\t\tstruct bcma_device *core;\n\n\t\tcore = bcma_find_core(bus, BCMA_CORE_NS_ROM);\n\t\tif (core) {\n\t\t\tswitch (bcma_aread32(core, BCMA_IOST) &\n\t\t\t\tBCMA_NS_ROM_IOST_BOOT_DEV_MASK) {\n\t\t\tcase BCMA_NS_ROM_IOST_BOOT_DEV_NOR:\n\t\t\t\treturn BCMA_BOOT_DEV_SERIAL;\n\t\t\tcase BCMA_NS_ROM_IOST_BOOT_DEV_NAND:\n\t\t\t\treturn BCMA_BOOT_DEV_NAND;\n\t\t\tcase BCMA_NS_ROM_IOST_BOOT_DEV_ROM:\n\t\t\tdefault:\n\t\t\t\treturn BCMA_BOOT_DEV_ROM;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cc_rev == 38) {\n\t\t\tif (cc->status & BCMA_CC_CHIPST_5357_NAND_BOOT)\n\t\t\t\treturn BCMA_BOOT_DEV_NAND;\n\t\t\telse if (cc->status & BIT(5))\n\t\t\t\treturn BCMA_BOOT_DEV_ROM;\n\t\t}\n\n\t\tif ((cc->capabilities & BCMA_CC_CAP_FLASHT) ==\n\t\t    BCMA_CC_FLASHT_PARA)\n\t\t\treturn BCMA_BOOT_DEV_PARALLEL;\n\t\telse\n\t\t\treturn BCMA_BOOT_DEV_SERIAL;\n\t}\n\n\treturn BCMA_BOOT_DEV_SERIAL;\n}\n\nstatic void bcma_core_mips_nvram_init(struct bcma_drv_mips *mcore)\n{\n\tstruct bcma_bus *bus = mcore->core->bus;\n\tenum bcma_boot_dev boot_dev;\n\n\t \n\tboot_dev = bcma_boot_dev(bus);\n\tswitch (boot_dev) {\n\tcase BCMA_BOOT_DEV_PARALLEL:\n\tcase BCMA_BOOT_DEV_SERIAL:\n#ifdef CONFIG_BCM47XX\n\t\tbcm47xx_nvram_init_from_mem(BCMA_SOC_FLASH2,\n\t\t\t\t\t    BCMA_SOC_FLASH2_SZ);\n#endif\n\t\tbreak;\n\tcase BCMA_BOOT_DEV_NAND:\n#ifdef CONFIG_BCM47XX\n\t\tbcm47xx_nvram_init_from_mem(BCMA_SOC_FLASH1,\n\t\t\t\t\t    BCMA_SOC_FLASH1_SZ);\n#endif\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid bcma_core_mips_early_init(struct bcma_drv_mips *mcore)\n{\n\tstruct bcma_bus *bus = mcore->core->bus;\n\n\tif (mcore->early_setup_done)\n\t\treturn;\n\n\tbcma_chipco_serial_init(&bus->drv_cc);\n\tbcma_core_mips_nvram_init(mcore);\n\n\tmcore->early_setup_done = true;\n}\n\nstatic void bcma_fix_i2s_irqflag(struct bcma_bus *bus)\n{\n\tstruct bcma_device *cpu, *pcie, *i2s;\n\n\t \n\tif (bus->chipinfo.id != BCMA_CHIP_ID_BCM4716 &&\n\t    bus->chipinfo.id != BCMA_CHIP_ID_BCM4748)\n\t\treturn;\n\n\tcpu = bcma_find_core(bus, BCMA_CORE_MIPS_74K);\n\tpcie = bcma_find_core(bus, BCMA_CORE_PCIE);\n\ti2s = bcma_find_core(bus, BCMA_CORE_I2S);\n\tif (cpu && pcie && i2s &&\n\t    bcma_aread32(cpu, BCMA_MIPS_OOBSELINA74) == 0x08060504 &&\n\t    bcma_aread32(pcie, BCMA_MIPS_OOBSELINA74) == 0x08060504 &&\n\t    bcma_aread32(i2s, BCMA_MIPS_OOBSELOUTA30) == 0x88) {\n\t\tbcma_awrite32(cpu, BCMA_MIPS_OOBSELINA74, 0x07060504);\n\t\tbcma_awrite32(pcie, BCMA_MIPS_OOBSELINA74, 0x07060504);\n\t\tbcma_awrite32(i2s, BCMA_MIPS_OOBSELOUTA30, 0x87);\n\t\tbcma_debug(bus,\n\t\t\t   \"Moved i2s interrupt to oob line 7 instead of 8\\n\");\n\t}\n}\n\nvoid bcma_core_mips_init(struct bcma_drv_mips *mcore)\n{\n\tstruct bcma_bus *bus;\n\tstruct bcma_device *core;\n\tbus = mcore->core->bus;\n\n\tif (mcore->setup_done)\n\t\treturn;\n\n\tbcma_debug(bus, \"Initializing MIPS core...\\n\");\n\n\tbcma_core_mips_early_init(mcore);\n\n\tbcma_fix_i2s_irqflag(bus);\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4716:\n\tcase BCMA_CHIP_ID_BCM4748:\n\t\tbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_80211, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_MAC_GBIT, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 3, BCMA_CORE_USB20_HOST, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 4, BCMA_CORE_PCIE, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_CHIPCOMMON, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_I2S, 0);\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM5356:\n\tcase BCMA_CHIP_ID_BCM47162:\n\tcase BCMA_CHIP_ID_BCM53572:\n\t\tbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_80211, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_MAC_GBIT, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_CHIPCOMMON, 0);\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM5357:\n\tcase BCMA_CHIP_ID_BCM4749:\n\t\tbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_80211, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_MAC_GBIT, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 3, BCMA_CORE_USB20_HOST, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_CHIPCOMMON, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_I2S, 0);\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM4706:\n\t\tbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_PCIE, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_4706_MAC_GBIT,\n\t\t\t\t\t    0);\n\t\tbcma_core_mips_set_irq_name(bus, 3, BCMA_CORE_PCIE, 1);\n\t\tbcma_core_mips_set_irq_name(bus, 4, BCMA_CORE_USB20_HOST, 0);\n\t\tbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_4706_CHIPCOMMON,\n\t\t\t\t\t    0);\n\t\tbreak;\n\tdefault:\n\t\tlist_for_each_entry(core, &bus->cores, list) {\n\t\t\tcore->irq = bcma_core_irq(core, 0);\n\t\t}\n\t\tbcma_err(bus,\n\t\t\t \"Unknown device (0x%x) found, can not configure IRQs\\n\",\n\t\t\t bus->chipinfo.id);\n\t}\n\tbcma_debug(bus, \"IRQ reconfiguration done\\n\");\n\tbcma_core_mips_dump_irq(bus);\n\n\tmcore->setup_done = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}