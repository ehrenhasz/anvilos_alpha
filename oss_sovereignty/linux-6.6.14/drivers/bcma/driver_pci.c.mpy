{
  "module_name": "driver_pci.c",
  "hash_id": "26cb73cbd6480187a962806944e45573a4122ece5843cf5caabf4d95e805bd80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/driver_pci.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/export.h>\n#include <linux/bcma/bcma.h>\n\n \n\nu32 bcma_pcie_read(struct bcma_drv_pci *pc, u32 address)\n{\n\tpcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_ADDR, address);\n\tpcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_ADDR);\n\treturn pcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_DATA);\n}\n\nstatic void bcma_pcie_write(struct bcma_drv_pci *pc, u32 address, u32 data)\n{\n\tpcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_ADDR, address);\n\tpcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_ADDR);\n\tpcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_DATA, data);\n}\n\nstatic void bcma_pcie_mdio_set_phy(struct bcma_drv_pci *pc, u16 phy)\n{\n\tu32 v;\n\tint i;\n\n\tv = BCMA_CORE_PCI_MDIODATA_START;\n\tv |= BCMA_CORE_PCI_MDIODATA_WRITE;\n\tv |= (BCMA_CORE_PCI_MDIODATA_DEV_ADDR <<\n\t      BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF);\n\tv |= (BCMA_CORE_PCI_MDIODATA_BLK_ADDR <<\n\t      BCMA_CORE_PCI_MDIODATA_REGADDR_SHF);\n\tv |= BCMA_CORE_PCI_MDIODATA_TA;\n\tv |= (phy << 4);\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_DATA, v);\n\n\tudelay(10);\n\tfor (i = 0; i < 200; i++) {\n\t\tv = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_CONTROL);\n\t\tif (v & BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\nstatic u16 bcma_pcie_mdio_read(struct bcma_drv_pci *pc, u16 device, u8 address)\n{\n\tint max_retries = 10;\n\tu16 ret = 0;\n\tu32 v;\n\tint i;\n\n\t \n\tv = BCMA_CORE_PCI_MDIOCTL_PREAM_EN;\n\tv |= BCMA_CORE_PCI_MDIOCTL_DIVISOR_VAL;\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, v);\n\n\tif (pc->core->id.rev >= 10) {\n\t\tmax_retries = 200;\n\t\tbcma_pcie_mdio_set_phy(pc, device);\n\t\tv = (BCMA_CORE_PCI_MDIODATA_DEV_ADDR <<\n\t\t     BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF);\n\t\tv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF);\n\t} else {\n\t\tv = (device << BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF_OLD);\n\t\tv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF_OLD);\n\t}\n\n\tv |= BCMA_CORE_PCI_MDIODATA_START;\n\tv |= BCMA_CORE_PCI_MDIODATA_READ;\n\tv |= BCMA_CORE_PCI_MDIODATA_TA;\n\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_DATA, v);\n\t \n\tudelay(10);\n\tfor (i = 0; i < max_retries; i++) {\n\t\tv = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_CONTROL);\n\t\tif (v & BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE) {\n\t\t\tudelay(10);\n\t\t\tret = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_DATA);\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, 0);\n\treturn ret;\n}\n\nstatic void bcma_pcie_mdio_write(struct bcma_drv_pci *pc, u16 device,\n\t\t\t\tu8 address, u16 data)\n{\n\tint max_retries = 10;\n\tu32 v;\n\tint i;\n\n\t \n\tv = BCMA_CORE_PCI_MDIOCTL_PREAM_EN;\n\tv |= BCMA_CORE_PCI_MDIOCTL_DIVISOR_VAL;\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, v);\n\n\tif (pc->core->id.rev >= 10) {\n\t\tmax_retries = 200;\n\t\tbcma_pcie_mdio_set_phy(pc, device);\n\t\tv = (BCMA_CORE_PCI_MDIODATA_DEV_ADDR <<\n\t\t     BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF);\n\t\tv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF);\n\t} else {\n\t\tv = (device << BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF_OLD);\n\t\tv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF_OLD);\n\t}\n\n\tv |= BCMA_CORE_PCI_MDIODATA_START;\n\tv |= BCMA_CORE_PCI_MDIODATA_WRITE;\n\tv |= BCMA_CORE_PCI_MDIODATA_TA;\n\tv |= data;\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_DATA, v);\n\t \n\tudelay(10);\n\tfor (i = 0; i < max_retries; i++) {\n\t\tv = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_CONTROL);\n\t\tif (v & BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tpcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, 0);\n}\n\nstatic u16 bcma_pcie_mdio_writeread(struct bcma_drv_pci *pc, u16 device,\n\t\t\t\t    u8 address, u16 data)\n{\n\tbcma_pcie_mdio_write(pc, device, address, data);\n\treturn bcma_pcie_mdio_read(pc, device, address);\n}\n\n \n\nstatic void bcma_core_pci_fixcfg(struct bcma_drv_pci *pc)\n{\n\tstruct bcma_device *core = pc->core;\n\tu16 val16, core_index;\n\tuint regoff;\n\n\tregoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_PI_OFFSET);\n\tcore_index = (u16)core->core_index;\n\n\tval16 = pcicore_read16(pc, regoff);\n\tif (((val16 & BCMA_CORE_PCI_SPROM_PI_MASK) >> BCMA_CORE_PCI_SPROM_PI_SHIFT)\n\t     != core_index) {\n\t\tval16 = (core_index << BCMA_CORE_PCI_SPROM_PI_SHIFT) |\n\t\t\t(val16 & ~BCMA_CORE_PCI_SPROM_PI_MASK);\n\t\tpcicore_write16(pc, regoff, val16);\n\t}\n}\n\n \nvoid bcma_core_pci_early_init(struct bcma_drv_pci *pc)\n{\n\tif (pc->early_setup_done)\n\t\treturn;\n\n\tpc->hostmode = bcma_core_pci_is_in_hostmode(pc);\n\tif (pc->hostmode)\n\t\tgoto out;\n\n\tbcma_core_pci_fixcfg(pc);\n\nout:\n\tpc->early_setup_done = true;\n}\n\n \n\nstatic u8 bcma_pcicore_polarity_workaround(struct bcma_drv_pci *pc)\n{\n\tu32 tmp;\n\n\ttmp = bcma_pcie_read(pc, BCMA_CORE_PCI_PLP_STATUSREG);\n\tif (tmp & BCMA_CORE_PCI_PLP_POLARITYINV_STAT)\n\t\treturn BCMA_CORE_PCI_SERDES_RX_CTRL_FORCE |\n\t\t       BCMA_CORE_PCI_SERDES_RX_CTRL_POLARITY;\n\telse\n\t\treturn BCMA_CORE_PCI_SERDES_RX_CTRL_FORCE;\n}\n\nstatic void bcma_pcicore_serdes_workaround(struct bcma_drv_pci *pc)\n{\n\tu16 tmp;\n\n\tbcma_pcie_mdio_write(pc, BCMA_CORE_PCI_MDIODATA_DEV_RX,\n\t                     BCMA_CORE_PCI_SERDES_RX_CTRL,\n\t\t\t     bcma_pcicore_polarity_workaround(pc));\n\ttmp = bcma_pcie_mdio_read(pc, BCMA_CORE_PCI_MDIODATA_DEV_PLL,\n\t                          BCMA_CORE_PCI_SERDES_PLL_CTRL);\n\tif (tmp & BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN)\n\t\tbcma_pcie_mdio_write(pc, BCMA_CORE_PCI_MDIODATA_DEV_PLL,\n\t\t                     BCMA_CORE_PCI_SERDES_PLL_CTRL,\n\t\t                     tmp & ~BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN);\n}\n\n \n \nstatic void bcma_core_pci_config_fixup(struct bcma_drv_pci *pc)\n{\n\tu16 val16;\n\tuint regoff;\n\n\tregoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_MISC_CONFIG);\n\n\tval16 = pcicore_read16(pc, regoff);\n\n\tif (!(val16 & BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST)) {\n\t\tval16 |= BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST;\n\t\tpcicore_write16(pc, regoff, val16);\n\t}\n}\n\n \n\nstatic void bcma_core_pci_clientmode_init(struct bcma_drv_pci *pc)\n{\n\tbcma_pcicore_serdes_workaround(pc);\n\tbcma_core_pci_config_fixup(pc);\n}\n\nvoid bcma_core_pci_init(struct bcma_drv_pci *pc)\n{\n\tif (pc->setup_done)\n\t\treturn;\n\n\tbcma_core_pci_early_init(pc);\n\n\tif (pc->hostmode)\n\t\tbcma_core_pci_hostmode_init(pc);\n\telse\n\t\tbcma_core_pci_clientmode_init(pc);\n}\n\nvoid bcma_core_pci_power_save(struct bcma_bus *bus, bool up)\n{\n\tstruct bcma_drv_pci *pc;\n\tu16 data;\n\n\tif (bus->hosttype != BCMA_HOSTTYPE_PCI)\n\t\treturn;\n\n\tpc = &bus->drv_pci[0];\n\n\tif (pc->core->id.rev >= 15 && pc->core->id.rev <= 20) {\n\t\tdata = up ? 0x74 : 0x7C;\n\t\tbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\n\t\t\t\t\t BCMA_CORE_PCI_MDIO_BLK1_MGMT1, 0x7F64);\n\t\tbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\n\t\t\t\t\t BCMA_CORE_PCI_MDIO_BLK1_MGMT3, data);\n\t} else if (pc->core->id.rev >= 21 && pc->core->id.rev <= 22) {\n\t\tdata = up ? 0x75 : 0x7D;\n\t\tbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\n\t\t\t\t\t BCMA_CORE_PCI_MDIO_BLK1_MGMT1, 0x7E65);\n\t\tbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\n\t\t\t\t\t BCMA_CORE_PCI_MDIO_BLK1_MGMT3, data);\n\t}\n}\nEXPORT_SYMBOL_GPL(bcma_core_pci_power_save);\n\nstatic void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend)\n{\n\tu32 w;\n\n\tw = bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);\n\tif (extend)\n\t\tw |= BCMA_CORE_PCI_ASPMTIMER_EXTEND;\n\telse\n\t\tw &= ~BCMA_CORE_PCI_ASPMTIMER_EXTEND;\n\tbcma_pcie_write(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG, w);\n\tbcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);\n}\n\nvoid bcma_core_pci_up(struct bcma_drv_pci *pc)\n{\n\tbcma_core_pci_extend_L1timer(pc, true);\n}\n\nvoid bcma_core_pci_down(struct bcma_drv_pci *pc)\n{\n\tbcma_core_pci_extend_L1timer(pc, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}