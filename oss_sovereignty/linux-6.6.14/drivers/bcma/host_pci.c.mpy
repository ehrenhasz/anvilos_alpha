{
  "module_name": "host_pci.c",
  "hash_id": "f903a8f3f2c3439d26546853d0832094a40e404090ead13375fd8f73f97b7ea6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/host_pci.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/slab.h>\n#include <linux/bcma/bcma.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n\nstatic void bcma_host_pci_switch_core(struct bcma_device *core)\n{\n\tint win2 = core->bus->host_is_pcie2 ?\n\t\tBCMA_PCIE2_BAR0_WIN2 : BCMA_PCI_BAR0_WIN2;\n\n\tpci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN,\n\t\t\t       core->addr);\n\tpci_write_config_dword(core->bus->host_pci, win2, core->wrap);\n\tcore->bus->mapped_core = core;\n\tbcma_debug(core->bus, \"Switched to core: 0x%X\\n\", core->id.id);\n}\n\n \nstatic u16 bcma_host_pci_provide_access_to_core(struct bcma_device *core)\n{\n\tswitch (core->id.id) {\n\tcase BCMA_CORE_CHIPCOMMON:\n\t\treturn 3 * BCMA_CORE_SIZE;\n\tcase BCMA_CORE_PCIE:\n\t\treturn 2 * BCMA_CORE_SIZE;\n\t}\n\n\tif (core->bus->mapped_core != core)\n\t\tbcma_host_pci_switch_core(core);\n\treturn 0;\n}\n\nstatic u8 bcma_host_pci_read8(struct bcma_device *core, u16 offset)\n{\n\toffset += bcma_host_pci_provide_access_to_core(core);\n\treturn ioread8(core->bus->mmio + offset);\n}\n\nstatic u16 bcma_host_pci_read16(struct bcma_device *core, u16 offset)\n{\n\toffset += bcma_host_pci_provide_access_to_core(core);\n\treturn ioread16(core->bus->mmio + offset);\n}\n\nstatic u32 bcma_host_pci_read32(struct bcma_device *core, u16 offset)\n{\n\toffset += bcma_host_pci_provide_access_to_core(core);\n\treturn ioread32(core->bus->mmio + offset);\n}\n\nstatic void bcma_host_pci_write8(struct bcma_device *core, u16 offset,\n\t\t\t\t u8 value)\n{\n\toffset += bcma_host_pci_provide_access_to_core(core);\n\tiowrite8(value, core->bus->mmio + offset);\n}\n\nstatic void bcma_host_pci_write16(struct bcma_device *core, u16 offset,\n\t\t\t\t u16 value)\n{\n\toffset += bcma_host_pci_provide_access_to_core(core);\n\tiowrite16(value, core->bus->mmio + offset);\n}\n\nstatic void bcma_host_pci_write32(struct bcma_device *core, u16 offset,\n\t\t\t\t u32 value)\n{\n\toffset += bcma_host_pci_provide_access_to_core(core);\n\tiowrite32(value, core->bus->mmio + offset);\n}\n\n#ifdef CONFIG_BCMA_BLOCKIO\nstatic void bcma_host_pci_block_read(struct bcma_device *core, void *buffer,\n\t\t\t\t     size_t count, u16 offset, u8 reg_width)\n{\n\tvoid __iomem *addr = core->bus->mmio + offset;\n\tif (core->bus->mapped_core != core)\n\t\tbcma_host_pci_switch_core(core);\n\tswitch (reg_width) {\n\tcase sizeof(u8):\n\t\tioread8_rep(addr, buffer, count);\n\t\tbreak;\n\tcase sizeof(u16):\n\t\tWARN_ON(count & 1);\n\t\tioread16_rep(addr, buffer, count >> 1);\n\t\tbreak;\n\tcase sizeof(u32):\n\t\tWARN_ON(count & 3);\n\t\tioread32_rep(addr, buffer, count >> 2);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void bcma_host_pci_block_write(struct bcma_device *core,\n\t\t\t\t      const void *buffer, size_t count,\n\t\t\t\t      u16 offset, u8 reg_width)\n{\n\tvoid __iomem *addr = core->bus->mmio + offset;\n\tif (core->bus->mapped_core != core)\n\t\tbcma_host_pci_switch_core(core);\n\tswitch (reg_width) {\n\tcase sizeof(u8):\n\t\tiowrite8_rep(addr, buffer, count);\n\t\tbreak;\n\tcase sizeof(u16):\n\t\tWARN_ON(count & 1);\n\t\tiowrite16_rep(addr, buffer, count >> 1);\n\t\tbreak;\n\tcase sizeof(u32):\n\t\tWARN_ON(count & 3);\n\t\tiowrite32_rep(addr, buffer, count >> 2);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n#endif\n\nstatic u32 bcma_host_pci_aread32(struct bcma_device *core, u16 offset)\n{\n\tif (core->bus->mapped_core != core)\n\t\tbcma_host_pci_switch_core(core);\n\treturn ioread32(core->bus->mmio + (1 * BCMA_CORE_SIZE) + offset);\n}\n\nstatic void bcma_host_pci_awrite32(struct bcma_device *core, u16 offset,\n\t\t\t\t  u32 value)\n{\n\tif (core->bus->mapped_core != core)\n\t\tbcma_host_pci_switch_core(core);\n\tiowrite32(value, core->bus->mmio + (1 * BCMA_CORE_SIZE) + offset);\n}\n\nstatic const struct bcma_host_ops bcma_host_pci_ops = {\n\t.read8\t\t= bcma_host_pci_read8,\n\t.read16\t\t= bcma_host_pci_read16,\n\t.read32\t\t= bcma_host_pci_read32,\n\t.write8\t\t= bcma_host_pci_write8,\n\t.write16\t= bcma_host_pci_write16,\n\t.write32\t= bcma_host_pci_write32,\n#ifdef CONFIG_BCMA_BLOCKIO\n\t.block_read\t= bcma_host_pci_block_read,\n\t.block_write\t= bcma_host_pci_block_write,\n#endif\n\t.aread32\t= bcma_host_pci_aread32,\n\t.awrite32\t= bcma_host_pci_awrite32,\n};\n\nstatic int bcma_host_pci_probe(struct pci_dev *dev,\n\t\t\t       const struct pci_device_id *id)\n{\n\tstruct bcma_bus *bus;\n\tint err = -ENOMEM;\n\tu32 val;\n\n\t \n\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\tgoto out;\n\n\t \n\terr = pci_enable_device(dev);\n\tif (err)\n\t\tgoto err_kfree_bus;\n\n\terr = pci_request_regions(dev, \"bcma-pci-bridge\");\n\tif (err)\n\t\tgoto err_pci_disable;\n\tpci_set_master(dev);\n\n\t \n\tpci_read_config_dword(dev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(dev, 0x40, val & 0xffff00ff);\n\n\t \n\tif (!pci_is_pcie(dev)) {\n\t\tbcma_err(bus, \"PCI card detected, they are not supported.\\n\");\n\t\terr = -ENXIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tbus->dev = &dev->dev;\n\n\t \n\terr = -ENOMEM;\n\tbus->mmio = pci_iomap(dev, 0, ~0UL);\n\tif (!bus->mmio)\n\t\tgoto err_pci_release_regions;\n\n\t \n\tbus->host_pci = dev;\n\tbus->hosttype = BCMA_HOSTTYPE_PCI;\n\tbus->ops = &bcma_host_pci_ops;\n\n\tbus->boardinfo.vendor = bus->host_pci->subsystem_vendor;\n\tbus->boardinfo.type = bus->host_pci->subsystem_device;\n\n\t \n\tbcma_init_bus(bus);\n\n\t \n\terr = bcma_bus_scan(bus);\n\tif (err)\n\t\tgoto err_pci_unmap_mmio;\n\n\tif (bcma_find_core(bus, BCMA_CORE_PCIE2))\n\t\tbus->host_is_pcie2 = true;\n\n\t \n\terr = bcma_bus_register(bus);\n\tif (err)\n\t\tgoto err_unregister_cores;\n\n\tpci_set_drvdata(dev, bus);\n\nout:\n\treturn err;\n\nerr_unregister_cores:\n\tbcma_unregister_cores(bus);\nerr_pci_unmap_mmio:\n\tpci_iounmap(dev, bus->mmio);\nerr_pci_release_regions:\n\tpci_release_regions(dev);\nerr_pci_disable:\n\tpci_disable_device(dev);\nerr_kfree_bus:\n\tkfree(bus);\n\treturn err;\n}\n\nstatic void bcma_host_pci_remove(struct pci_dev *dev)\n{\n\tstruct bcma_bus *bus = pci_get_drvdata(dev);\n\n\tbcma_bus_unregister(bus);\n\tpci_iounmap(dev, bus->mmio);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\tkfree(bus);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bcma_host_pci_suspend(struct device *dev)\n{\n\tstruct bcma_bus *bus = dev_get_drvdata(dev);\n\n\tbus->mapped_core = NULL;\n\n\treturn bcma_bus_suspend(bus);\n}\n\nstatic int bcma_host_pci_resume(struct device *dev)\n{\n\tstruct bcma_bus *bus = dev_get_drvdata(dev);\n\n\treturn bcma_bus_resume(bus);\n}\n\nstatic SIMPLE_DEV_PM_OPS(bcma_pm_ops, bcma_host_pci_suspend,\n\t\t\t bcma_host_pci_resume);\n#define BCMA_PM_OPS\t(&bcma_pm_ops)\n\n#else  \n\n#define BCMA_PM_OPS     NULL\n\n#endif  \n\nstatic const struct pci_device_id bcma_pci_bridge_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x0576) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4313) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43224) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4331) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4353) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4357) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4358) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4359) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4360) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_DELL, 0x0016) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_DELL, 0x0018) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_FOXCONN, 0xe092) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, 0x4365, PCI_VENDOR_ID_HP, 0x804a) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a0) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43a9) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43aa) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x43b1) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4727) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43227) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43228) },\t \n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, bcma_pci_bridge_tbl);\n\nstatic struct pci_driver bcma_pci_bridge_driver = {\n\t.name = \"bcma-pci-bridge\",\n\t.id_table = bcma_pci_bridge_tbl,\n\t.probe = bcma_host_pci_probe,\n\t.remove = bcma_host_pci_remove,\n\t.driver.pm = BCMA_PM_OPS,\n};\n\nint __init bcma_host_pci_init(void)\n{\n\treturn pci_register_driver(&bcma_pci_bridge_driver);\n}\n\nvoid __exit bcma_host_pci_exit(void)\n{\n\tpci_unregister_driver(&bcma_pci_bridge_driver);\n}\n\n \n\n \nvoid bcma_host_pci_up(struct bcma_bus *bus)\n{\n\tif (bus->hosttype != BCMA_HOSTTYPE_PCI)\n\t\treturn;\n\n\tif (bus->host_is_pcie2)\n\t\tbcma_core_pcie2_up(&bus->drv_pcie2);\n\telse\n\t\tbcma_core_pci_up(&bus->drv_pci[0]);\n}\nEXPORT_SYMBOL_GPL(bcma_host_pci_up);\n\n \nvoid bcma_host_pci_down(struct bcma_bus *bus)\n{\n\tif (bus->hosttype != BCMA_HOSTTYPE_PCI)\n\t\treturn;\n\n\tif (!bus->host_is_pcie2)\n\t\tbcma_core_pci_down(&bus->drv_pci[0]);\n}\nEXPORT_SYMBOL_GPL(bcma_host_pci_down);\n\n \nint bcma_host_pci_irq_ctl(struct bcma_bus *bus, struct bcma_device *core,\n\t\t\t  bool enable)\n{\n\tstruct pci_dev *pdev;\n\tu32 coremask, tmp;\n\tint err = 0;\n\n\tif (bus->hosttype != BCMA_HOSTTYPE_PCI) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tpdev = bus->host_pci;\n\n\terr = pci_read_config_dword(pdev, BCMA_PCI_IRQMASK, &tmp);\n\tif (err)\n\t\tgoto out;\n\n\tcoremask = BIT(core->core_index) << 8;\n\tif (enable)\n\t\ttmp |= coremask;\n\telse\n\t\ttmp &= ~coremask;\n\n\terr = pci_write_config_dword(pdev, BCMA_PCI_IRQMASK, tmp);\n\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(bcma_host_pci_irq_ctl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}