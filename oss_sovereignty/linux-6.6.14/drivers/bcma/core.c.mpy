{
  "module_name": "core.c",
  "hash_id": "15c4c07142bc66c8eb766f9ae8fb20d475e6594c842f6e0d58130e9977b421e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/core.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/export.h>\n#include <linux/bcma/bcma.h>\n\nstatic bool bcma_core_wait_value(struct bcma_device *core, u16 reg, u32 mask,\n\t\t\t\t u32 value, int timeout)\n{\n\tunsigned long deadline = jiffies + timeout;\n\tu32 val;\n\n\tdo {\n\t\tval = bcma_aread32(core, reg);\n\t\tif ((val & mask) == value)\n\t\t\treturn true;\n\t\tcpu_relax();\n\t\tudelay(10);\n\t} while (!time_after_eq(jiffies, deadline));\n\n\tbcma_warn(core->bus, \"Timeout waiting for register 0x%04X!\\n\", reg);\n\n\treturn false;\n}\n\nbool bcma_core_is_enabled(struct bcma_device *core)\n{\n\tif ((bcma_aread32(core, BCMA_IOCTL) & (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC))\n\t    != BCMA_IOCTL_CLK)\n\t\treturn false;\n\tif (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(bcma_core_is_enabled);\n\nvoid bcma_core_disable(struct bcma_device *core, u32 flags)\n{\n\tif (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)\n\t\treturn;\n\n\tbcma_core_wait_value(core, BCMA_RESET_ST, ~0, 0, 300);\n\n\tbcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);\n\tbcma_aread32(core, BCMA_RESET_CTL);\n\tudelay(1);\n\n\tbcma_awrite32(core, BCMA_IOCTL, flags);\n\tbcma_aread32(core, BCMA_IOCTL);\n\tudelay(10);\n}\nEXPORT_SYMBOL_GPL(bcma_core_disable);\n\nint bcma_core_enable(struct bcma_device *core, u32 flags)\n{\n\tbcma_core_disable(core, flags);\n\n\tbcma_awrite32(core, BCMA_IOCTL, (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC | flags));\n\tbcma_aread32(core, BCMA_IOCTL);\n\n\tbcma_awrite32(core, BCMA_RESET_CTL, 0);\n\tbcma_aread32(core, BCMA_RESET_CTL);\n\tudelay(1);\n\n\tbcma_awrite32(core, BCMA_IOCTL, (BCMA_IOCTL_CLK | flags));\n\tbcma_aread32(core, BCMA_IOCTL);\n\tudelay(1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcma_core_enable);\n\nvoid bcma_core_set_clockmode(struct bcma_device *core,\n\t\t\t     enum bcma_clkmode clkmode)\n{\n\tu16 i;\n\n\tWARN_ON(core->id.id != BCMA_CORE_CHIPCOMMON &&\n\t\tcore->id.id != BCMA_CORE_PCIE &&\n\t\tcore->id.id != BCMA_CORE_80211);\n\n\tswitch (clkmode) {\n\tcase BCMA_CLKMODE_FAST:\n\t\tbcma_set32(core, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);\n\t\tusleep_range(64, 300);\n\t\tfor (i = 0; i < 1500; i++) {\n\t\t\tif (bcma_read32(core, BCMA_CLKCTLST) &\n\t\t\t    BCMA_CLKCTLST_HAVEHT) {\n\t\t\t\ti = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(10);\n\t\t}\n\t\tif (i)\n\t\t\tbcma_err(core->bus, \"HT force timeout\\n\");\n\t\tbreak;\n\tcase BCMA_CLKMODE_DYNAMIC:\n\t\tbcma_set32(core, BCMA_CLKCTLST, ~BCMA_CLKCTLST_FORCEHT);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(bcma_core_set_clockmode);\n\nvoid bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status, bool on)\n{\n\tu16 i;\n\n\tWARN_ON(req & ~BCMA_CLKCTLST_EXTRESREQ);\n\tWARN_ON(status & ~BCMA_CLKCTLST_EXTRESST);\n\n\tif (on) {\n\t\tbcma_set32(core, BCMA_CLKCTLST, req);\n\t\tfor (i = 0; i < 10000; i++) {\n\t\t\tif ((bcma_read32(core, BCMA_CLKCTLST) & status) ==\n\t\t\t    status) {\n\t\t\t\ti = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(10);\n\t\t}\n\t\tif (i)\n\t\t\tbcma_err(core->bus, \"PLL enable timeout\\n\");\n\t} else {\n\t\t \n\t\tbcma_mask32(core, BCMA_CLKCTLST, ~req);\n\t\tbcma_read32(core, BCMA_CLKCTLST);\n\t}\n}\nEXPORT_SYMBOL_GPL(bcma_core_pll_ctl);\n\nu32 bcma_core_dma_translation(struct bcma_device *core)\n{\n\tswitch (core->bus->hosttype) {\n\tcase BCMA_HOSTTYPE_SOC:\n\t\treturn 0;\n\tcase BCMA_HOSTTYPE_PCI:\n\t\tif (bcma_aread32(core, BCMA_IOST) & BCMA_IOST_DMA64)\n\t\t\treturn BCMA_DMA_TRANSLATION_DMA64_CMT;\n\t\telse\n\t\t\treturn BCMA_DMA_TRANSLATION_DMA32_CMT;\n\tdefault:\n\t\tbcma_err(core->bus, \"DMA translation unknown for host %d\\n\",\n\t\t\t core->bus->hosttype);\n\t}\n\treturn BCMA_DMA_TRANSLATION_NONE;\n}\nEXPORT_SYMBOL(bcma_core_dma_translation);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}