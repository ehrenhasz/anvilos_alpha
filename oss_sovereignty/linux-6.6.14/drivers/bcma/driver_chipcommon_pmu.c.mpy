{
  "module_name": "driver_chipcommon_pmu.c",
  "hash_id": "0e5685bf0b4ac798fbbc54d4c18a4b2a7497ab6e49a9627063372178020f58f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/driver_chipcommon_pmu.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/export.h>\n#include <linux/bcma/bcma.h>\n\nu32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset)\n{\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);\n\tbcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);\n\treturn bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_pll_read);\n\nvoid bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset, u32 value)\n{\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);\n\tbcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, value);\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_pll_write);\n\nvoid bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,\n\t\t\t     u32 set)\n{\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);\n\tbcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_ADDR);\n\tbcma_pmu_maskset32(cc, BCMA_CC_PMU_PLLCTL_DATA, mask, set);\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_pll_maskset);\n\nvoid bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,\n\t\t\t\t u32 offset, u32 mask, u32 set)\n{\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_CHIPCTL_ADDR, offset);\n\tbcma_pmu_read32(cc, BCMA_CC_PMU_CHIPCTL_ADDR);\n\tbcma_pmu_maskset32(cc, BCMA_CC_PMU_CHIPCTL_DATA, mask, set);\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_chipctl_maskset);\n\nvoid bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc, u32 offset, u32 mask,\n\t\t\t\tu32 set)\n{\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_REGCTL_ADDR, offset);\n\tbcma_pmu_read32(cc, BCMA_CC_PMU_REGCTL_ADDR);\n\tbcma_pmu_maskset32(cc, BCMA_CC_PMU_REGCTL_DATA, mask, set);\n}\nEXPORT_SYMBOL_GPL(bcma_chipco_regctl_maskset);\n\nstatic u32 bcma_pmu_xtalfreq(struct bcma_drv_cc *cc)\n{\n\tu32 ilp_ctl, alp_hz;\n\n\tif (!(bcma_pmu_read32(cc, BCMA_CC_PMU_STAT) &\n\t      BCMA_CC_PMU_STAT_EXT_LPO_AVAIL))\n\t\treturn 0;\n\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_XTAL_FREQ,\n\t\t\t BIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));\n\tusleep_range(1000, 2000);\n\n\tilp_ctl = bcma_pmu_read32(cc, BCMA_CC_PMU_XTAL_FREQ);\n\tilp_ctl &= BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK;\n\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);\n\n\talp_hz = ilp_ctl * 32768 / 4;\n\treturn (alp_hz + 50000) / 100000 * 100;\n}\n\nstatic void bcma_pmu2_pll_init0(struct bcma_drv_cc *cc, u32 xtalfreq)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tu32 freq_tgt_target = 0, freq_tgt_current;\n\tu32 pll0, mask;\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM43142:\n\t\t \n\t\tswitch (xtalfreq) {\n\t\tcase 12000:\n\t\t\tfreq_tgt_target = 0x50D52;\n\t\t\tbreak;\n\t\tcase 20000:\n\t\t\tfreq_tgt_target = 0x307FE;\n\t\t\tbreak;\n\t\tcase 26000:\n\t\t\tfreq_tgt_target = 0x254EA;\n\t\t\tbreak;\n\t\tcase 37400:\n\t\t\tfreq_tgt_target = 0x19EF8;\n\t\t\tbreak;\n\t\tcase 52000:\n\t\t\tfreq_tgt_target = 0x12A75;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!freq_tgt_target) {\n\t\tbcma_err(bus, \"Unknown TGT frequency for xtalfreq %d\\n\",\n\t\t\t xtalfreq);\n\t\treturn;\n\t}\n\n\tpll0 = bcma_chipco_pll_read(cc, BCMA_CC_PMU15_PLL_PLLCTL0);\n\tfreq_tgt_current = (pll0 & BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK) >>\n\t\tBCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT;\n\n\tif (freq_tgt_current == freq_tgt_target) {\n\t\tbcma_debug(bus, \"Target TGT frequency already set\\n\");\n\t\treturn;\n\t}\n\n\t \n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM43142:\n\t\tmask = (u32)~(BCMA_RES_4314_HT_AVAIL |\n\t\t\t      BCMA_RES_4314_MACPHY_CLK_AVAIL);\n\n\t\tbcma_pmu_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);\n\t\tbcma_pmu_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);\n\t\tbcma_wait_value(cc->core, BCMA_CLKCTLST,\n\t\t\t\tBCMA_CLKCTLST_HAVEHT, 0, 20000);\n\t\tbreak;\n\t}\n\n\tpll0 &= ~BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK;\n\tpll0 |= freq_tgt_target << BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT;\n\tbcma_chipco_pll_write(cc, BCMA_CC_PMU15_PLL_PLLCTL0, pll0);\n\n\t \n\tif (cc->pmu.rev >= 2)\n\t\tbcma_pmu_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);\n\n\t \n}\n\nstatic void bcma_pmu_pll_init(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tu32 xtalfreq = bcma_pmu_xtalfreq(cc);\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM43142:\n\t\tif (xtalfreq == 0)\n\t\t\txtalfreq = 20000;\n\t\tbcma_pmu2_pll_init0(cc, xtalfreq);\n\t\tbreak;\n\t}\n}\n\nstatic void bcma_pmu_resources_init(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tu32 min_msk = 0, max_msk = 0;\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4313:\n\t\tmin_msk = 0x200D;\n\t\tmax_msk = 0xFFFF;\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM43142:\n\t\tmin_msk = BCMA_RES_4314_LPLDO_PU |\n\t\t\t  BCMA_RES_4314_PMU_SLEEP_DIS |\n\t\t\t  BCMA_RES_4314_PMU_BG_PU |\n\t\t\t  BCMA_RES_4314_CBUCK_LPOM_PU |\n\t\t\t  BCMA_RES_4314_CBUCK_PFM_PU |\n\t\t\t  BCMA_RES_4314_CLDO_PU |\n\t\t\t  BCMA_RES_4314_LPLDO2_LVM |\n\t\t\t  BCMA_RES_4314_WL_PMU_PU |\n\t\t\t  BCMA_RES_4314_LDO3P3_PU |\n\t\t\t  BCMA_RES_4314_OTP_PU |\n\t\t\t  BCMA_RES_4314_WL_PWRSW_PU |\n\t\t\t  BCMA_RES_4314_LQ_AVAIL |\n\t\t\t  BCMA_RES_4314_LOGIC_RET |\n\t\t\t  BCMA_RES_4314_MEM_SLEEP |\n\t\t\t  BCMA_RES_4314_MACPHY_RET |\n\t\t\t  BCMA_RES_4314_WL_CORE_READY;\n\t\tmax_msk = 0x3FFFFFFF;\n\t\tbreak;\n\tdefault:\n\t\tbcma_debug(bus, \"PMU resource config unknown or not needed for device 0x%04X\\n\",\n\t\t\t   bus->chipinfo.id);\n\t}\n\n\t \n\tif (min_msk)\n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_MINRES_MSK, min_msk);\n\tif (max_msk)\n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_MAXRES_MSK, max_msk);\n\n\t \n\tusleep_range(2000, 2500);\n}\n\n \nvoid bcma_chipco_bcm4331_ext_pa_lines_ctl(struct bcma_drv_cc *cc, bool enable)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tu32 val;\n\n\tval = bcma_cc_read32(cc, BCMA_CC_CHIPCTL);\n\tif (enable) {\n\t\tval |= BCMA_CHIPCTL_4331_EXTPA_EN;\n\t\tif (bus->chipinfo.pkg == 9 || bus->chipinfo.pkg == 11)\n\t\t\tval |= BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;\n\t\telse if (bus->chipinfo.rev > 0)\n\t\t\tval |= BCMA_CHIPCTL_4331_EXTPA_EN2;\n\t} else {\n\t\tval &= ~BCMA_CHIPCTL_4331_EXTPA_EN;\n\t\tval &= ~BCMA_CHIPCTL_4331_EXTPA_EN2;\n\t\tval &= ~BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5;\n\t}\n\tbcma_cc_write32(cc, BCMA_CC_CHIPCTL, val);\n}\n\nstatic void bcma_pmu_workarounds(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4313:\n\t\t \n\t\tbcma_chipco_chipctl_maskset(cc, 0,\n\t\t\t\t\t    ~BCMA_CCTRL_4313_12MA_LED_DRIVE,\n\t\t\t\t\t    BCMA_CCTRL_4313_12MA_LED_DRIVE);\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM4331:\n\tcase BCMA_CHIP_ID_BCM43431:\n\t\t \n\t\tbcma_chipco_bcm4331_ext_pa_lines_ctl(cc, true);\n\t\tbreak;\n\tcase BCMA_CHIP_ID_BCM43224:\n\tcase BCMA_CHIP_ID_BCM43421:\n\t\t \n\t\tif (bus->chipinfo.rev == 0) {\n\t\t\tbcma_cc_maskset32(cc, BCMA_CC_CHIPCTL,\n\t\t\t\t\t  ~BCMA_CCTRL_43224_GPIO_TOGGLE,\n\t\t\t\t\t  BCMA_CCTRL_43224_GPIO_TOGGLE);\n\t\t\tbcma_chipco_chipctl_maskset(cc, 0,\n\t\t\t\t\t\t    ~BCMA_CCTRL_43224A0_12MA_LED_DRIVE,\n\t\t\t\t\t\t    BCMA_CCTRL_43224A0_12MA_LED_DRIVE);\n\t\t} else {\n\t\t\tbcma_chipco_chipctl_maskset(cc, 0,\n\t\t\t\t\t\t    ~BCMA_CCTRL_43224B0_12MA_LED_DRIVE,\n\t\t\t\t\t\t    BCMA_CCTRL_43224B0_12MA_LED_DRIVE);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbcma_debug(bus, \"Workarounds unknown or not needed for device 0x%04X\\n\",\n\t\t\t   bus->chipinfo.id);\n\t}\n}\n\nvoid bcma_pmu_early_init(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tu32 pmucap;\n\n\tif (cc->core->id.rev >= 35 &&\n\t    cc->capabilities_ext & BCMA_CC_CAP_EXT_AOB_PRESENT) {\n\t\tcc->pmu.core = bcma_find_core(bus, BCMA_CORE_PMU);\n\t\tif (!cc->pmu.core)\n\t\t\tbcma_warn(bus, \"Couldn't find expected PMU core\");\n\t}\n\tif (!cc->pmu.core)\n\t\tcc->pmu.core = cc->core;\n\n\tpmucap = bcma_pmu_read32(cc, BCMA_CC_PMU_CAP);\n\tcc->pmu.rev = (pmucap & BCMA_CC_PMU_CAP_REVISION);\n\n\tbcma_debug(bus, \"Found rev %u PMU (capabilities 0x%08X)\\n\", cc->pmu.rev,\n\t\t   pmucap);\n}\n\nvoid bcma_pmu_init(struct bcma_drv_cc *cc)\n{\n\tif (cc->pmu.rev == 1)\n\t\tbcma_pmu_mask32(cc, BCMA_CC_PMU_CTL,\n\t\t\t\t~BCMA_CC_PMU_CTL_NOILPONW);\n\telse\n\t\tbcma_pmu_set32(cc, BCMA_CC_PMU_CTL,\n\t\t\t       BCMA_CC_PMU_CTL_NOILPONW);\n\n\tbcma_pmu_pll_init(cc);\n\tbcma_pmu_resources_init(cc);\n\tbcma_pmu_workarounds(cc);\n}\n\nu32 bcma_pmu_get_alp_clock(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4313:\n\tcase BCMA_CHIP_ID_BCM43224:\n\tcase BCMA_CHIP_ID_BCM43225:\n\tcase BCMA_CHIP_ID_BCM43227:\n\tcase BCMA_CHIP_ID_BCM43228:\n\tcase BCMA_CHIP_ID_BCM4331:\n\tcase BCMA_CHIP_ID_BCM43421:\n\tcase BCMA_CHIP_ID_BCM43428:\n\tcase BCMA_CHIP_ID_BCM43431:\n\tcase BCMA_CHIP_ID_BCM4716:\n\tcase BCMA_CHIP_ID_BCM47162:\n\tcase BCMA_CHIP_ID_BCM4748:\n\tcase BCMA_CHIP_ID_BCM4749:\n\tcase BCMA_CHIP_ID_BCM5357:\n\tcase BCMA_CHIP_ID_BCM53572:\n\tcase BCMA_CHIP_ID_BCM6362:\n\t\t \n\t\treturn 20000 * 1000;\n\tcase BCMA_CHIP_ID_BCM4706:\n\tcase BCMA_CHIP_ID_BCM5356:\n\t\t \n\t\treturn 25000 * 1000;\n\tcase BCMA_CHIP_ID_BCM43460:\n\tcase BCMA_CHIP_ID_BCM4352:\n\tcase BCMA_CHIP_ID_BCM4360:\n\t\tif (cc->status & BCMA_CC_CHIPST_4360_XTAL_40MZ)\n\t\t\treturn 40000 * 1000;\n\t\telse\n\t\t\treturn 20000 * 1000;\n\tdefault:\n\t\tbcma_warn(bus, \"No ALP clock specified for %04X device, pmu rev. %d, using default %d Hz\\n\",\n\t\t\t  bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_ALP_CLOCK);\n\t}\n\treturn BCMA_CC_PMU_ALP_CLOCK;\n}\n\n \nstatic u32 bcma_pmu_pll_clock(struct bcma_drv_cc *cc, u32 pll0, u32 m)\n{\n\tu32 tmp, div, ndiv, p1, p2, fc;\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tBUG_ON((pll0 & 3) || (pll0 > BCMA_CC_PMU4716_MAINPLL_PLL0));\n\n\tBUG_ON(!m || m > 4);\n\n\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\n\t    bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) {\n\t\t \n\t\ttmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);\n\t\tif (tmp & 0x40000)\n\t\t\treturn 133 * 1000000;\n\t}\n\n\ttmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_P1P2_OFF);\n\tp1 = (tmp & BCMA_CC_PPL_P1_MASK) >> BCMA_CC_PPL_P1_SHIFT;\n\tp2 = (tmp & BCMA_CC_PPL_P2_MASK) >> BCMA_CC_PPL_P2_SHIFT;\n\n\ttmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_M14_OFF);\n\tdiv = (tmp >> ((m - 1) * BCMA_CC_PPL_MDIV_WIDTH)) &\n\t\tBCMA_CC_PPL_MDIV_MASK;\n\n\ttmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PPL_NM5_OFF);\n\tndiv = (tmp & BCMA_CC_PPL_NDIV_MASK) >> BCMA_CC_PPL_NDIV_SHIFT;\n\n\t \n\tfc = bcma_pmu_get_alp_clock(cc) / 1000000;\n\tfc = (p1 * ndiv * fc) / p2;\n\n\t \n\treturn (fc / div) * 1000000;\n}\n\nstatic u32 bcma_pmu_pll_clock_bcm4706(struct bcma_drv_cc *cc, u32 pll0, u32 m)\n{\n\tu32 tmp, ndiv, p1div, p2div;\n\tu32 clock;\n\n\tBUG_ON(!m || m > 4);\n\n\t \n\ttmp = bcma_chipco_pll_read(cc, pll0 + BCMA_CC_PMU6_4706_PROCPLL_OFF);\n\tndiv = (tmp & BCMA_CC_PMU6_4706_PROC_NDIV_INT_MASK)\n\t\t>> BCMA_CC_PMU6_4706_PROC_NDIV_INT_SHIFT;\n\tp1div = (tmp & BCMA_CC_PMU6_4706_PROC_P1DIV_MASK)\n\t\t>> BCMA_CC_PMU6_4706_PROC_P1DIV_SHIFT;\n\tp2div = (tmp & BCMA_CC_PMU6_4706_PROC_P2DIV_MASK)\n\t\t>> BCMA_CC_PMU6_4706_PROC_P2DIV_SHIFT;\n\n\ttmp = bcma_cc_read32(cc, BCMA_CC_CHIPSTAT);\n\tif (tmp & BCMA_CC_CHIPST_4706_PKG_OPTION)\n\t\t \n\t\tclock = (25000000 / 4) * ndiv * p2div / p1div;\n\telse\n\t\t \n\t\tclock = (25000000 / 2) * ndiv * p2div / p1div;\n\n\tif (m == BCMA_CC_PMU5_MAINPLL_SSB)\n\t\tclock = clock / 4;\n\n\treturn clock;\n}\n\n \nu32 bcma_pmu_get_bus_clock(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4716:\n\tcase BCMA_CHIP_ID_BCM4748:\n\tcase BCMA_CHIP_ID_BCM47162:\n\t\treturn bcma_pmu_pll_clock(cc, BCMA_CC_PMU4716_MAINPLL_PLL0,\n\t\t\t\t\t  BCMA_CC_PMU5_MAINPLL_SSB);\n\tcase BCMA_CHIP_ID_BCM5356:\n\t\treturn bcma_pmu_pll_clock(cc, BCMA_CC_PMU5356_MAINPLL_PLL0,\n\t\t\t\t\t  BCMA_CC_PMU5_MAINPLL_SSB);\n\tcase BCMA_CHIP_ID_BCM5357:\n\tcase BCMA_CHIP_ID_BCM4749:\n\t\treturn bcma_pmu_pll_clock(cc, BCMA_CC_PMU5357_MAINPLL_PLL0,\n\t\t\t\t\t  BCMA_CC_PMU5_MAINPLL_SSB);\n\tcase BCMA_CHIP_ID_BCM4706:\n\t\treturn bcma_pmu_pll_clock_bcm4706(cc,\n\t\t\t\t\t\t  BCMA_CC_PMU4706_MAINPLL_PLL0,\n\t\t\t\t\t\t  BCMA_CC_PMU5_MAINPLL_SSB);\n\tcase BCMA_CHIP_ID_BCM53572:\n\t\treturn 75000000;\n\tdefault:\n\t\tbcma_warn(bus, \"No bus clock specified for %04X device, pmu rev. %d, using default %d Hz\\n\",\n\t\t\t  bus->chipinfo.id, cc->pmu.rev, BCMA_CC_PMU_HT_CLOCK);\n\t}\n\treturn BCMA_CC_PMU_HT_CLOCK;\n}\nEXPORT_SYMBOL_GPL(bcma_pmu_get_bus_clock);\n\n \nu32 bcma_pmu_get_cpu_clock(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM53572)\n\t\treturn 300000000;\n\n\t \n\tif (cc->pmu.rev >= 5) {\n\t\tu32 pll;\n\t\tswitch (bus->chipinfo.id) {\n\t\tcase BCMA_CHIP_ID_BCM4706:\n\t\t\treturn bcma_pmu_pll_clock_bcm4706(cc,\n\t\t\t\t\t\tBCMA_CC_PMU4706_MAINPLL_PLL0,\n\t\t\t\t\t\tBCMA_CC_PMU5_MAINPLL_CPU);\n\t\tcase BCMA_CHIP_ID_BCM5356:\n\t\t\tpll = BCMA_CC_PMU5356_MAINPLL_PLL0;\n\t\t\tbreak;\n\t\tcase BCMA_CHIP_ID_BCM5357:\n\t\tcase BCMA_CHIP_ID_BCM4749:\n\t\t\tpll = BCMA_CC_PMU5357_MAINPLL_PLL0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpll = BCMA_CC_PMU4716_MAINPLL_PLL0;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bcma_pmu_pll_clock(cc, pll, BCMA_CC_PMU5_MAINPLL_CPU);\n\t}\n\n\t \n\treturn bcma_pmu_get_bus_clock(cc);\n}\n\nstatic void bcma_pmu_spuravoid_pll_write(struct bcma_drv_cc *cc, u32 offset,\n\t\t\t\t\t u32 value)\n{\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR, offset);\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, value);\n}\n\nvoid bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid)\n{\n\tu32 tmp = 0;\n\tu8 phypll_offset = 0;\n\tu8 bcm5357_bcm43236_p1div[] = {0x1, 0x5, 0x5};\n\tu8 bcm5357_bcm43236_ndiv[] = {0x30, 0xf6, 0xfc};\n\tstruct bcma_bus *bus = cc->core->bus;\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM5357:\n\tcase BCMA_CHIP_ID_BCM4749:\n\tcase BCMA_CHIP_ID_BCM53572:\n\t\t \n\n\t\t \n\t\tphypll_offset = (bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\n\t\t       bus->chipinfo.id == BCMA_CHIP_ID_BCM4749 ||\n\t\t       bus->chipinfo.id == BCMA_CHIP_ID_BCM53572) ? 6 : 0;\n\n\t\t \n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR,\n\t\t\t\tBCMA_CC_PMU_PLL_CTL0 + phypll_offset);\n\t\ttmp = bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);\n\t\ttmp &= (~(BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK));\n\t\ttmp |= (bcm5357_bcm43236_p1div[spuravoid] << BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT);\n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, tmp);\n\n\t\t \n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_ADDR,\n\t\t\t\tBCMA_CC_PMU_PLL_CTL2 + phypll_offset);\n\t\ttmp = bcma_pmu_read32(cc, BCMA_CC_PMU_PLLCTL_DATA);\n\t\ttmp &= ~(BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK);\n\t\ttmp |= (bcm5357_bcm43236_ndiv[spuravoid]) << BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT;\n\t\tbcma_pmu_write32(cc, BCMA_CC_PMU_PLLCTL_DATA, tmp);\n\n\t\ttmp = BCMA_CC_PMU_CTL_PLL_UPD;\n\t\tbreak;\n\n\tcase BCMA_CHIP_ID_BCM4331:\n\tcase BCMA_CHIP_ID_BCM43431:\n\t\tif (spuravoid == 2) {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11500014);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x0FC00a08);\n\t\t} else if (spuravoid == 1) {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11500014);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x0F600a08);\n\t\t} else {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11100014);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x03000a08);\n\t\t}\n\t\ttmp = BCMA_CC_PMU_CTL_PLL_UPD;\n\t\tbreak;\n\n\tcase BCMA_CHIP_ID_BCM43224:\n\tcase BCMA_CHIP_ID_BCM43225:\n\tcase BCMA_CHIP_ID_BCM43421:\n\t\tif (spuravoid == 1) {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11500010);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\n\t\t\t\t\t\t     0x000C0C06);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x0F600a08);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\n\t\t\t\t\t\t     0x00000000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\n\t\t\t\t\t\t     0x2001E920);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\n\t\t\t\t\t\t     0x88888815);\n\t\t} else {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11100010);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\n\t\t\t\t\t\t     0x000c0c06);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x03000a08);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\n\t\t\t\t\t\t     0x00000000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\n\t\t\t\t\t\t     0x200005c0);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\n\t\t\t\t\t\t     0x88888815);\n\t\t}\n\t\ttmp = BCMA_CC_PMU_CTL_PLL_UPD;\n\t\tbreak;\n\n\tcase BCMA_CHIP_ID_BCM4716:\n\tcase BCMA_CHIP_ID_BCM4748:\n\tcase BCMA_CHIP_ID_BCM47162:\n\t\tif (spuravoid == 1) {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11500060);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\n\t\t\t\t\t\t     0x080C0C06);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x0F600000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\n\t\t\t\t\t\t     0x00000000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\n\t\t\t\t\t\t     0x2001E924);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\n\t\t\t\t\t\t     0x88888815);\n\t\t} else {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11100060);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\n\t\t\t\t\t\t     0x080c0c06);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x03000000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\n\t\t\t\t\t\t     0x00000000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\n\t\t\t\t\t\t     0x200005c0);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\n\t\t\t\t\t\t     0x88888815);\n\t\t}\n\n\t\ttmp = BCMA_CC_PMU_CTL_PLL_UPD | BCMA_CC_PMU_CTL_NOILPONW;\n\t\tbreak;\n\n\tcase BCMA_CHIP_ID_BCM43131:\n\tcase BCMA_CHIP_ID_BCM43217:\n\tcase BCMA_CHIP_ID_BCM43227:\n\tcase BCMA_CHIP_ID_BCM43228:\n\tcase BCMA_CHIP_ID_BCM43428:\n\t\t \n\t\t \n\t\tif (spuravoid == 1) {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x01100014);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\n\t\t\t\t\t\t     0x040C0C06);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x03140A08);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\n\t\t\t\t\t\t     0x00333333);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\n\t\t\t\t\t\t     0x202C2820);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\n\t\t\t\t\t\t     0x88888815);\n\t\t} else {\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL0,\n\t\t\t\t\t\t     0x11100014);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL1,\n\t\t\t\t\t\t     0x040c0c06);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL2,\n\t\t\t\t\t\t     0x03000a08);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL3,\n\t\t\t\t\t\t     0x00000000);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL4,\n\t\t\t\t\t\t     0x200005c0);\n\t\t\tbcma_pmu_spuravoid_pll_write(cc, BCMA_CC_PMU_PLL_CTL5,\n\t\t\t\t\t\t     0x88888815);\n\t\t}\n\t\ttmp = BCMA_CC_PMU_CTL_PLL_UPD;\n\t\tbreak;\n\tdefault:\n\t\tbcma_err(bus, \"Unknown spuravoidance settings for chip 0x%04X, not changing PLL\\n\",\n\t\t\t bus->chipinfo.id);\n\t\tbreak;\n\t}\n\n\ttmp |= bcma_pmu_read32(cc, BCMA_CC_PMU_CTL);\n\tbcma_pmu_write32(cc, BCMA_CC_PMU_CTL, tmp);\n}\nEXPORT_SYMBOL_GPL(bcma_pmu_spuravoid_pllupdate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}