{
  "module_name": "main.c",
  "hash_id": "1c113216f416d0d4e24b0d0d6d43d2b384f4037067374f6c0db9e23077278839",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/main.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/module.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/bcma/bcma.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n\nMODULE_DESCRIPTION(\"Broadcom's specific AMBA driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic unsigned int bcma_bus_next_num;\n\n \nstatic DEFINE_MUTEX(bcma_buses_mutex);\n\nstatic int bcma_bus_match(struct device *dev, struct device_driver *drv);\nstatic int bcma_device_probe(struct device *dev);\nstatic void bcma_device_remove(struct device *dev);\nstatic int bcma_device_uevent(const struct device *dev, struct kobj_uevent_env *env);\n\nstatic ssize_t manuf_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\treturn sprintf(buf, \"0x%03X\\n\", core->id.manuf);\n}\nstatic DEVICE_ATTR_RO(manuf);\n\nstatic ssize_t id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\treturn sprintf(buf, \"0x%03X\\n\", core->id.id);\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic ssize_t rev_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\treturn sprintf(buf, \"0x%02X\\n\", core->id.rev);\n}\nstatic DEVICE_ATTR_RO(rev);\n\nstatic ssize_t class_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\treturn sprintf(buf, \"0x%X\\n\", core->id.class);\n}\nstatic DEVICE_ATTR_RO(class);\n\nstatic struct attribute *bcma_device_attrs[] = {\n\t&dev_attr_manuf.attr,\n\t&dev_attr_id.attr,\n\t&dev_attr_rev.attr,\n\t&dev_attr_class.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(bcma_device);\n\nstatic struct bus_type bcma_bus_type = {\n\t.name\t\t= \"bcma\",\n\t.match\t\t= bcma_bus_match,\n\t.probe\t\t= bcma_device_probe,\n\t.remove\t\t= bcma_device_remove,\n\t.uevent\t\t= bcma_device_uevent,\n\t.dev_groups\t= bcma_device_groups,\n};\n\nstatic u16 bcma_cc_core_id(struct bcma_bus *bus)\n{\n\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706)\n\t\treturn BCMA_CORE_4706_CHIPCOMMON;\n\treturn BCMA_CORE_CHIPCOMMON;\n}\n\nstruct bcma_device *bcma_find_core_unit(struct bcma_bus *bus, u16 coreid,\n\t\t\t\t\tu8 unit)\n{\n\tstruct bcma_device *core;\n\n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\tif (core->id.id == coreid && core->core_unit == unit)\n\t\t\treturn core;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(bcma_find_core_unit);\n\nbool bcma_wait_value(struct bcma_device *core, u16 reg, u32 mask, u32 value,\n\t\t     int timeout)\n{\n\tunsigned long deadline = jiffies + timeout;\n\tu32 val;\n\n\tdo {\n\t\tval = bcma_read32(core, reg);\n\t\tif ((val & mask) == value)\n\t\t\treturn true;\n\t\tcpu_relax();\n\t\tudelay(10);\n\t} while (!time_after_eq(jiffies, deadline));\n\n\tbcma_warn(core->bus, \"Timeout waiting for register 0x%04X!\\n\", reg);\n\n\treturn false;\n}\n\nstatic void bcma_release_core_dev(struct device *dev)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\tif (core->io_addr)\n\t\tiounmap(core->io_addr);\n\tif (core->io_wrap)\n\t\tiounmap(core->io_wrap);\n\tkfree(core);\n}\n\nstatic bool bcma_is_core_needed_early(u16 core_id)\n{\n\tswitch (core_id) {\n\tcase BCMA_CORE_NS_NAND:\n\tcase BCMA_CORE_NS_QSPI:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct device_node *bcma_of_find_child_device(struct device *parent,\n\t\t\t\t\t\t     struct bcma_device *core)\n{\n\tstruct device_node *node;\n\tint ret;\n\n\tif (!parent->of_node)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(parent->of_node, node) {\n\t\tstruct resource res;\n\t\tret = of_address_to_resource(node, 0, &res);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif (res.start == core->addr)\n\t\t\treturn node;\n\t}\n\treturn NULL;\n}\n\nstatic int bcma_of_irq_parse(struct device *parent,\n\t\t\t     struct bcma_device *core,\n\t\t\t     struct of_phandle_args *out_irq, int num)\n{\n\t__be32 laddr[1];\n\tint rc;\n\n\tif (core->dev.of_node) {\n\t\trc = of_irq_parse_one(core->dev.of_node, num, out_irq);\n\t\tif (!rc)\n\t\t\treturn rc;\n\t}\n\n\tout_irq->np = parent->of_node;\n\tout_irq->args_count = 1;\n\tout_irq->args[0] = num;\n\n\tladdr[0] = cpu_to_be32(core->addr);\n\treturn of_irq_parse_raw(laddr, out_irq);\n}\n\nstatic unsigned int bcma_of_get_irq(struct device *parent,\n\t\t\t\t    struct bcma_device *core, int num)\n{\n\tstruct of_phandle_args out_irq;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_OF_IRQ) || !parent->of_node)\n\t\treturn 0;\n\n\tret = bcma_of_irq_parse(parent, core, &out_irq, num);\n\tif (ret) {\n\t\tbcma_debug(core->bus, \"bcma_of_get_irq() failed with rc=%d\\n\",\n\t\t\t   ret);\n\t\treturn 0;\n\t}\n\n\treturn irq_create_of_mapping(&out_irq);\n}\n\nstatic void bcma_of_fill_device(struct device *parent,\n\t\t\t\tstruct bcma_device *core)\n{\n\tstruct device_node *node;\n\n\tnode = bcma_of_find_child_device(parent, core);\n\tif (node)\n\t\tcore->dev.of_node = node;\n\n\tcore->irq = bcma_of_get_irq(parent, core, 0);\n\n\tof_dma_configure(&core->dev, node, false);\n}\n\nunsigned int bcma_core_irq(struct bcma_device *core, int num)\n{\n\tstruct bcma_bus *bus = core->bus;\n\tunsigned int mips_irq;\n\n\tswitch (bus->hosttype) {\n\tcase BCMA_HOSTTYPE_PCI:\n\t\treturn bus->host_pci->irq;\n\tcase BCMA_HOSTTYPE_SOC:\n\t\tif (bus->drv_mips.core && num == 0) {\n\t\t\tmips_irq = bcma_core_mips_irq(core);\n\t\t\treturn mips_irq <= 4 ? mips_irq + 2 : 0;\n\t\t}\n\t\tif (bus->dev)\n\t\t\treturn bcma_of_get_irq(bus->dev, core, num);\n\t\treturn 0;\n\tcase BCMA_HOSTTYPE_SDIO:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(bcma_core_irq);\n\nvoid bcma_prepare_core(struct bcma_bus *bus, struct bcma_device *core)\n{\n\tdevice_initialize(&core->dev);\n\tcore->dev.release = bcma_release_core_dev;\n\tcore->dev.bus = &bcma_bus_type;\n\tdev_set_name(&core->dev, \"bcma%d:%d\", bus->num, core->core_index);\n\tcore->dev.parent = bus->dev;\n\tif (bus->dev)\n\t\tbcma_of_fill_device(bus->dev, core);\n\n\tswitch (bus->hosttype) {\n\tcase BCMA_HOSTTYPE_PCI:\n\t\tcore->dma_dev = bus->dev;\n\t\tcore->irq = bus->host_pci->irq;\n\t\tbreak;\n\tcase BCMA_HOSTTYPE_SOC:\n\t\tif (IS_ENABLED(CONFIG_OF) && bus->dev) {\n\t\t\tcore->dma_dev = bus->dev;\n\t\t} else {\n\t\t\tcore->dev.dma_mask = &core->dev.coherent_dma_mask;\n\t\t\tcore->dma_dev = &core->dev;\n\t\t}\n\t\tbreak;\n\tcase BCMA_HOSTTYPE_SDIO:\n\t\tbreak;\n\t}\n}\n\nvoid bcma_init_bus(struct bcma_bus *bus)\n{\n\tmutex_lock(&bcma_buses_mutex);\n\tbus->num = bcma_bus_next_num++;\n\tmutex_unlock(&bcma_buses_mutex);\n\n\tINIT_LIST_HEAD(&bus->cores);\n\tbus->nr_cores = 0;\n\n\tbcma_detect_chip(bus);\n}\n\nstatic void bcma_register_core(struct bcma_bus *bus, struct bcma_device *core)\n{\n\tint err;\n\n\terr = device_add(&core->dev);\n\tif (err) {\n\t\tbcma_err(bus, \"Could not register dev for core 0x%03X\\n\",\n\t\t\t core->id.id);\n\t\treturn;\n\t}\n\tcore->dev_registered = true;\n}\n\nstatic int bcma_register_devices(struct bcma_bus *bus)\n{\n\tstruct bcma_device *core;\n\tint err;\n\n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\t \n\t\tswitch (core->id.id) {\n\t\tcase BCMA_CORE_4706_CHIPCOMMON:\n\t\tcase BCMA_CORE_CHIPCOMMON:\n\t\tcase BCMA_CORE_NS_CHIPCOMMON_B:\n\t\tcase BCMA_CORE_PCI:\n\t\tcase BCMA_CORE_PCIE:\n\t\tcase BCMA_CORE_PCIE2:\n\t\tcase BCMA_CORE_MIPS_74K:\n\t\tcase BCMA_CORE_4706_MAC_GBIT_COMMON:\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (bcma_is_core_needed_early(core->id.id))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (core->id.id == BCMA_CORE_4706_MAC_GBIT &&\n\t\t    core->core_unit > 0)\n\t\t\tcontinue;\n\n\t\tbcma_register_core(bus, core);\n\t}\n\n#ifdef CONFIG_BCMA_PFLASH\n\tif (bus->drv_cc.pflash.present) {\n\t\terr = platform_device_register(&bcma_pflash_dev);\n\t\tif (err)\n\t\t\tbcma_err(bus, \"Error registering parallel flash\\n\");\n\t}\n#endif\n\n#ifdef CONFIG_BCMA_SFLASH\n\tif (bus->drv_cc.sflash.present) {\n\t\terr = platform_device_register(&bcma_sflash_dev);\n\t\tif (err)\n\t\t\tbcma_err(bus, \"Error registering serial flash\\n\");\n\t}\n#endif\n\n#ifdef CONFIG_BCMA_NFLASH\n\tif (bus->drv_cc.nflash.present) {\n\t\terr = platform_device_register(&bcma_nflash_dev);\n\t\tif (err)\n\t\t\tbcma_err(bus, \"Error registering NAND flash\\n\");\n\t}\n#endif\n\terr = bcma_gpio_init(&bus->drv_cc);\n\tif (err == -ENOTSUPP)\n\t\tbcma_debug(bus, \"GPIO driver not activated\\n\");\n\telse if (err) {\n\t\tbcma_err(bus, \"Error registering GPIO driver: %i\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (bus->hosttype == BCMA_HOSTTYPE_SOC) {\n\t\terr = bcma_chipco_watchdog_register(&bus->drv_cc);\n\t\tif (err)\n\t\t\tbcma_err(bus, \"Error registering watchdog driver\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid bcma_unregister_cores(struct bcma_bus *bus)\n{\n\tstruct bcma_device *core, *tmp;\n\n\tlist_for_each_entry_safe(core, tmp, &bus->cores, list) {\n\t\tif (!core->dev_registered)\n\t\t\tcontinue;\n\t\tlist_del(&core->list);\n\t\tdevice_unregister(&core->dev);\n\t}\n\tif (bus->hosttype == BCMA_HOSTTYPE_SOC)\n\t\tplatform_device_unregister(bus->drv_cc.watchdog);\n\n\t \n\tlist_for_each_entry_safe(core, tmp, &bus->cores, list) {\n\t\tlist_del(&core->list);\n\t\tput_device(&core->dev);\n\t}\n}\n\nint bcma_bus_register(struct bcma_bus *bus)\n{\n\tint err;\n\tstruct bcma_device *core;\n\n\t \n\terr = bcma_bus_scan(bus);\n\tif (err) {\n\t\tbcma_err(bus, \"Failed to scan: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tcore = bcma_find_core(bus, bcma_cc_core_id(bus));\n\tif (core) {\n\t\tbus->drv_cc.core = core;\n\t\tbcma_core_chipcommon_early_init(&bus->drv_cc);\n\t}\n\n\t \n\tcore = bcma_find_core(bus, BCMA_CORE_PCIE);\n\tif (core) {\n\t\tbus->drv_pci[0].core = core;\n\t\tbcma_core_pci_early_init(&bus->drv_pci[0]);\n\t}\n\n\tif (bus->dev)\n\t\tof_platform_default_populate(bus->dev->of_node, NULL, bus->dev);\n\n\t \n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\tif (bcma_is_core_needed_early(core->id.id))\n\t\t\tbcma_register_core(bus, core);\n\t}\n\n\t \n\terr = bcma_sprom_get(bus);\n\tif (err == -ENOENT) {\n\t\tbcma_err(bus, \"No SPROM available\\n\");\n\t} else if (err)\n\t\tbcma_err(bus, \"Failed to get SPROM: %d\\n\", err);\n\n\t \n\tcore = bcma_find_core(bus, bcma_cc_core_id(bus));\n\tif (core) {\n\t\tbus->drv_cc.core = core;\n\t\tbcma_core_chipcommon_init(&bus->drv_cc);\n\t}\n\n\t \n\tcore = bcma_find_core(bus, BCMA_CORE_NS_CHIPCOMMON_B);\n\tif (core) {\n\t\tbus->drv_cc_b.core = core;\n\t\tbcma_core_chipcommon_b_init(&bus->drv_cc_b);\n\t}\n\n\t \n\tcore = bcma_find_core(bus, BCMA_CORE_MIPS_74K);\n\tif (core) {\n\t\tbus->drv_mips.core = core;\n\t\tbcma_core_mips_init(&bus->drv_mips);\n\t}\n\n\t \n\tcore = bcma_find_core_unit(bus, BCMA_CORE_PCIE, 0);\n\tif (core) {\n\t\tbus->drv_pci[0].core = core;\n\t\tbcma_core_pci_init(&bus->drv_pci[0]);\n\t}\n\n\t \n\tcore = bcma_find_core_unit(bus, BCMA_CORE_PCIE, 1);\n\tif (core) {\n\t\tbus->drv_pci[1].core = core;\n\t\tbcma_core_pci_init(&bus->drv_pci[1]);\n\t}\n\n\t \n\tcore = bcma_find_core_unit(bus, BCMA_CORE_PCIE2, 0);\n\tif (core) {\n\t\tbus->drv_pcie2.core = core;\n\t\tbcma_core_pcie2_init(&bus->drv_pcie2);\n\t}\n\n\t \n\tcore = bcma_find_core(bus, BCMA_CORE_4706_MAC_GBIT_COMMON);\n\tif (core) {\n\t\tbus->drv_gmac_cmn.core = core;\n\t\tbcma_core_gmac_cmn_init(&bus->drv_gmac_cmn);\n\t}\n\n\t \n\tbcma_register_devices(bus);\n\n\tbcma_info(bus, \"Bus registered\\n\");\n\n\treturn 0;\n}\n\nvoid bcma_bus_unregister(struct bcma_bus *bus)\n{\n\tint err;\n\n\terr = bcma_gpio_unregister(&bus->drv_cc);\n\tif (err == -EBUSY)\n\t\tbcma_err(bus, \"Some GPIOs are still in use.\\n\");\n\telse if (err)\n\t\tbcma_err(bus, \"Can not unregister GPIO driver: %i\\n\", err);\n\n\tbcma_core_chipcommon_b_free(&bus->drv_cc_b);\n\n\tbcma_unregister_cores(bus);\n}\n\n \nint __init bcma_bus_early_register(struct bcma_bus *bus)\n{\n\tint err;\n\tstruct bcma_device *core;\n\n\t \n\terr = bcma_bus_scan(bus);\n\tif (err) {\n\t\tbcma_err(bus, \"Failed to scan bus: %d\\n\", err);\n\t\treturn -1;\n\t}\n\n\t \n\tcore = bcma_find_core(bus, bcma_cc_core_id(bus));\n\tif (core) {\n\t\tbus->drv_cc.core = core;\n\t\tbcma_core_chipcommon_early_init(&bus->drv_cc);\n\t}\n\n\t \n\tcore = bcma_find_core(bus, BCMA_CORE_MIPS_74K);\n\tif (core) {\n\t\tbus->drv_mips.core = core;\n\t\tbcma_core_mips_early_init(&bus->drv_mips);\n\t}\n\n\tbcma_info(bus, \"Early bus registered\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nint bcma_bus_suspend(struct bcma_bus *bus)\n{\n\tstruct bcma_device *core;\n\n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\tstruct device_driver *drv = core->dev.driver;\n\t\tif (drv) {\n\t\t\tstruct bcma_driver *adrv = container_of(drv, struct bcma_driver, drv);\n\t\t\tif (adrv->suspend)\n\t\t\t\tadrv->suspend(core);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bcma_bus_resume(struct bcma_bus *bus)\n{\n\tstruct bcma_device *core;\n\n\t \n\tif (bus->drv_cc.core) {\n\t\tbus->drv_cc.setup_done = false;\n\t\tbcma_core_chipcommon_init(&bus->drv_cc);\n\t}\n\n\tlist_for_each_entry(core, &bus->cores, list) {\n\t\tstruct device_driver *drv = core->dev.driver;\n\t\tif (drv) {\n\t\t\tstruct bcma_driver *adrv = container_of(drv, struct bcma_driver, drv);\n\t\t\tif (adrv->resume)\n\t\t\t\tadrv->resume(core);\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nint __bcma_driver_register(struct bcma_driver *drv, struct module *owner)\n{\n\tdrv->drv.name = drv->name;\n\tdrv->drv.bus = &bcma_bus_type;\n\tdrv->drv.owner = owner;\n\n\treturn driver_register(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(__bcma_driver_register);\n\nvoid bcma_driver_unregister(struct bcma_driver *drv)\n{\n\tdriver_unregister(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(bcma_driver_unregister);\n\nstatic int bcma_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\tstruct bcma_driver *adrv = container_of(drv, struct bcma_driver, drv);\n\tconst struct bcma_device_id *cid = &core->id;\n\tconst struct bcma_device_id *did;\n\n\tfor (did = adrv->id_table; did->manuf || did->id || did->rev; did++) {\n\t    if ((did->manuf == cid->manuf || did->manuf == BCMA_ANY_MANUF) &&\n\t\t(did->id == cid->id || did->id == BCMA_ANY_ID) &&\n\t\t(did->rev == cid->rev || did->rev == BCMA_ANY_REV) &&\n\t\t(did->class == cid->class || did->class == BCMA_ANY_CLASS))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bcma_device_probe(struct device *dev)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\tstruct bcma_driver *adrv = container_of(dev->driver, struct bcma_driver,\n\t\t\t\t\t       drv);\n\tint err = 0;\n\n\tget_device(dev);\n\tif (adrv->probe)\n\t\terr = adrv->probe(core);\n\tif (err)\n\t\tput_device(dev);\n\n\treturn err;\n}\n\nstatic void bcma_device_remove(struct device *dev)\n{\n\tstruct bcma_device *core = container_of(dev, struct bcma_device, dev);\n\tstruct bcma_driver *adrv = container_of(dev->driver, struct bcma_driver,\n\t\t\t\t\t       drv);\n\n\tif (adrv->remove)\n\t\tadrv->remove(core);\n\tput_device(dev);\n}\n\nstatic int bcma_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct bcma_device *core = container_of_const(dev, struct bcma_device, dev);\n\n\treturn add_uevent_var(env,\n\t\t\t      \"MODALIAS=bcma:m%04Xid%04Xrev%02Xcl%02X\",\n\t\t\t      core->id.manuf, core->id.id,\n\t\t\t      core->id.rev, core->id.class);\n}\n\nstatic unsigned int bcma_bus_registered;\n\n \nstatic int __init bcma_init_bus_register(void)\n{\n\tint err;\n\n\tif (bcma_bus_registered)\n\t\treturn 0;\n\n\terr = bus_register(&bcma_bus_type);\n\tif (!err)\n\t\tbcma_bus_registered = 1;\n\n\treturn err;\n}\n#ifndef MODULE\nfs_initcall(bcma_init_bus_register);\n#endif\n\n \nstatic int __init bcma_modinit(void)\n{\n\tint err;\n\n\terr = bcma_init_bus_register();\n\tif (err)\n\t\treturn err;\n\n\terr = bcma_host_soc_register_driver();\n\tif (err) {\n\t\tpr_err(\"SoC host initialization failed\\n\");\n\t\terr = 0;\n\t}\n#ifdef CONFIG_BCMA_HOST_PCI\n\terr = bcma_host_pci_init();\n\tif (err) {\n\t\tpr_err(\"PCI host initialization failed\\n\");\n\t\terr = 0;\n\t}\n#endif\n\n\treturn err;\n}\nmodule_init(bcma_modinit);\n\nstatic void __exit bcma_modexit(void)\n{\n#ifdef CONFIG_BCMA_HOST_PCI\n\tbcma_host_pci_exit();\n#endif\n\tbcma_host_soc_unregister_driver();\n\tbus_unregister(&bcma_bus_type);\n}\nmodule_exit(bcma_modexit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}