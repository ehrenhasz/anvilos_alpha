{
  "module_name": "host_soc.c",
  "hash_id": "fab2ff3006a6e213f21b3d4be6b9e4138af4148d906fd1f6111f305bd56fdd9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/host_soc.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include \"scan.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/bcma/bcma.h>\n#include <linux/bcma/bcma_soc.h>\n\nstatic u8 bcma_host_soc_read8(struct bcma_device *core, u16 offset)\n{\n\treturn readb(core->io_addr + offset);\n}\n\nstatic u16 bcma_host_soc_read16(struct bcma_device *core, u16 offset)\n{\n\treturn readw(core->io_addr + offset);\n}\n\nstatic u32 bcma_host_soc_read32(struct bcma_device *core, u16 offset)\n{\n\treturn readl(core->io_addr + offset);\n}\n\nstatic void bcma_host_soc_write8(struct bcma_device *core, u16 offset,\n\t\t\t\t u8 value)\n{\n\twriteb(value, core->io_addr + offset);\n}\n\nstatic void bcma_host_soc_write16(struct bcma_device *core, u16 offset,\n\t\t\t\t u16 value)\n{\n\twritew(value, core->io_addr + offset);\n}\n\nstatic void bcma_host_soc_write32(struct bcma_device *core, u16 offset,\n\t\t\t\t u32 value)\n{\n\twritel(value, core->io_addr + offset);\n}\n\n#ifdef CONFIG_BCMA_BLOCKIO\nstatic void bcma_host_soc_block_read(struct bcma_device *core, void *buffer,\n\t\t\t\t     size_t count, u16 offset, u8 reg_width)\n{\n\tvoid __iomem *addr = core->io_addr + offset;\n\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\tu8 *buf = buffer;\n\n\t\twhile (count) {\n\t\t\t*buf = __raw_readb(addr);\n\t\t\tbuf++;\n\t\t\tcount--;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\t__le16 *buf = buffer;\n\n\t\tWARN_ON(count & 1);\n\t\twhile (count) {\n\t\t\t*buf = (__force __le16)__raw_readw(addr);\n\t\t\tbuf++;\n\t\t\tcount -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\t__le32 *buf = buffer;\n\n\t\tWARN_ON(count & 3);\n\t\twhile (count) {\n\t\t\t*buf = (__force __le32)__raw_readl(addr);\n\t\t\tbuf++;\n\t\t\tcount -= 4;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void bcma_host_soc_block_write(struct bcma_device *core,\n\t\t\t\t      const void *buffer,\n\t\t\t\t      size_t count, u16 offset, u8 reg_width)\n{\n\tvoid __iomem *addr = core->io_addr + offset;\n\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\tconst u8 *buf = buffer;\n\n\t\twhile (count) {\n\t\t\t__raw_writeb(*buf, addr);\n\t\t\tbuf++;\n\t\t\tcount--;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\tconst __le16 *buf = buffer;\n\n\t\tWARN_ON(count & 1);\n\t\twhile (count) {\n\t\t\t__raw_writew((__force u16)(*buf), addr);\n\t\t\tbuf++;\n\t\t\tcount -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\tconst __le32 *buf = buffer;\n\n\t\tWARN_ON(count & 3);\n\t\twhile (count) {\n\t\t\t__raw_writel((__force u32)(*buf), addr);\n\t\t\tbuf++;\n\t\t\tcount -= 4;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n#endif  \n\nstatic u32 bcma_host_soc_aread32(struct bcma_device *core, u16 offset)\n{\n\tif (WARN_ONCE(!core->io_wrap, \"Accessed core has no wrapper/agent\\n\"))\n\t\treturn ~0;\n\treturn readl(core->io_wrap + offset);\n}\n\nstatic void bcma_host_soc_awrite32(struct bcma_device *core, u16 offset,\n\t\t\t\t  u32 value)\n{\n\tif (WARN_ONCE(!core->io_wrap, \"Accessed core has no wrapper/agent\\n\"))\n\t\treturn;\n\twritel(value, core->io_wrap + offset);\n}\n\nstatic const struct bcma_host_ops bcma_host_soc_ops = {\n\t.read8\t\t= bcma_host_soc_read8,\n\t.read16\t\t= bcma_host_soc_read16,\n\t.read32\t\t= bcma_host_soc_read32,\n\t.write8\t\t= bcma_host_soc_write8,\n\t.write16\t= bcma_host_soc_write16,\n\t.write32\t= bcma_host_soc_write32,\n#ifdef CONFIG_BCMA_BLOCKIO\n\t.block_read\t= bcma_host_soc_block_read,\n\t.block_write\t= bcma_host_soc_block_write,\n#endif\n\t.aread32\t= bcma_host_soc_aread32,\n\t.awrite32\t= bcma_host_soc_awrite32,\n};\n\nint __init bcma_host_soc_register(struct bcma_soc *soc)\n{\n\tstruct bcma_bus *bus = &soc->bus;\n\n\t \n\tbus->mmio = ioremap(BCMA_ADDR_BASE, BCMA_CORE_SIZE * 1);\n\tif (!bus->mmio)\n\t\treturn -ENOMEM;\n\n\t \n\tbus->hosttype = BCMA_HOSTTYPE_SOC;\n\tbus->ops = &bcma_host_soc_ops;\n\n\t \n\tbcma_init_bus(bus);\n\n\treturn 0;\n}\n\nint __init bcma_host_soc_init(struct bcma_soc *soc)\n{\n\tstruct bcma_bus *bus = &soc->bus;\n\tint err;\n\n\t \n\terr = bcma_bus_early_register(bus);\n\tif (err)\n\t\tiounmap(bus->mmio);\n\n\treturn err;\n}\n\n#ifdef CONFIG_OF\nstatic int bcma_host_soc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct bcma_bus *bus;\n\tint err;\n\n\t \n\tbus = devm_kzalloc(dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->dev = dev;\n\n\t \n\tbus->mmio = of_iomap(np, 0);\n\tif (!bus->mmio)\n\t\treturn -ENOMEM;\n\n\t \n\tbus->hosttype = BCMA_HOSTTYPE_SOC;\n\tbus->ops = &bcma_host_soc_ops;\n\n\t \n\tbcma_init_bus(bus);\n\n\t \n\terr = bcma_bus_register(bus);\n\tif (err)\n\t\tgoto err_unmap_mmio;\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn err;\n\nerr_unmap_mmio:\n\tiounmap(bus->mmio);\n\treturn err;\n}\n\nstatic int bcma_host_soc_remove(struct platform_device *pdev)\n{\n\tstruct bcma_bus *bus = platform_get_drvdata(pdev);\n\n\tbcma_bus_unregister(bus);\n\tiounmap(bus->mmio);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcma_host_soc_of_match[] = {\n\t{ .compatible = \"brcm,bus-axi\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcma_host_soc_of_match);\n\nstatic struct platform_driver bcma_host_soc_driver = {\n\t.driver = {\n\t\t.name = \"bcma-host-soc\",\n\t\t.of_match_table = bcma_host_soc_of_match,\n\t},\n\t.probe\t\t= bcma_host_soc_probe,\n\t.remove\t\t= bcma_host_soc_remove,\n};\n\nint __init bcma_host_soc_register_driver(void)\n{\n\treturn platform_driver_register(&bcma_host_soc_driver);\n}\n\nvoid __exit bcma_host_soc_unregister_driver(void)\n{\n\tplatform_driver_unregister(&bcma_host_soc_driver);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}