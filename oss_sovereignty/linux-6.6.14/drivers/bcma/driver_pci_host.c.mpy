{
  "module_name": "driver_pci_host.c",
  "hash_id": "b46712fc1f798890704b64d2546a622cfa42590a1cc820bfe0ced7b3fad88989",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/driver_pci_host.c",
  "human_readable_source": " \n\n#include \"bcma_private.h\"\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/bcma/bcma.h>\n#include <asm/paccess.h>\n\n \n#define mips_busprobe32(val, addr)\tget_dbe((val), ((u32 *)(addr)))\n\n \n#define BCMA_PCI_SLOT_MAX\t16\n#define\tPCI_CONFIG_SPACE_SIZE\t256\n\nbool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc)\n{\n\tstruct bcma_bus *bus = pc->core->bus;\n\tu16 chipid_top;\n\tu32 tmp;\n\n\tchipid_top = (bus->chipinfo.id & 0xFF00);\n\tif (chipid_top != 0x4700 &&\n\t    chipid_top != 0x5300)\n\t\treturn false;\n\n\tbcma_core_enable(pc->core, 0);\n\n\treturn !mips_busprobe32(tmp, pc->core->io_addr);\n}\n\nstatic u32 bcma_pcie_read_config(struct bcma_drv_pci *pc, u32 address)\n{\n\tpcicore_write32(pc, BCMA_CORE_PCI_CONFIG_ADDR, address);\n\tpcicore_read32(pc, BCMA_CORE_PCI_CONFIG_ADDR);\n\treturn pcicore_read32(pc, BCMA_CORE_PCI_CONFIG_DATA);\n}\n\nstatic void bcma_pcie_write_config(struct bcma_drv_pci *pc, u32 address,\n\t\t\t\t   u32 data)\n{\n\tpcicore_write32(pc, BCMA_CORE_PCI_CONFIG_ADDR, address);\n\tpcicore_read32(pc, BCMA_CORE_PCI_CONFIG_ADDR);\n\tpcicore_write32(pc, BCMA_CORE_PCI_CONFIG_DATA, data);\n}\n\nstatic u32 bcma_get_cfgspace_addr(struct bcma_drv_pci *pc, unsigned int dev,\n\t\t\t     unsigned int func, unsigned int off)\n{\n\tu32 addr = 0;\n\n\t \n\tif (dev >= 2 || !(bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_LSREG)\n\t\t\t  & BCMA_CORE_PCI_DLLP_LSREG_LINKUP))\n\t\tgoto out;\n\n\t \n\t \n\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI1, BCMA_CORE_PCI_SBTOPCI_CFG0);\n\t \n\taddr = pc->host_controller->host_cfg_addr;\n\taddr |= (dev << BCMA_CORE_PCI_CFG_SLOT_SHIFT);\n\taddr |= (func << BCMA_CORE_PCI_CFG_FUN_SHIFT);\n\taddr |= (off & ~3);\n\nout:\n\treturn addr;\n}\n\nstatic int bcma_extpci_read_config(struct bcma_drv_pci *pc, unsigned int dev,\n\t\t\t\t  unsigned int func, unsigned int off,\n\t\t\t\t  void *buf, int len)\n{\n\tint err = -EINVAL;\n\tu32 addr, val;\n\tvoid __iomem *mmio = 0;\n\n\tWARN_ON(!pc->hostmode);\n\tif (unlikely(len != 1 && len != 2 && len != 4))\n\t\tgoto out;\n\tif (dev == 0) {\n\t\t \n\t\tif (func > 1)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (off >= PCI_CONFIG_SPACE_SIZE) {\n\t\t\taddr = (func << 12);\n\t\t\taddr |= (off & 0x0FFC);\n\t\t\tval = bcma_pcie_read_config(pc, addr);\n\t\t} else {\n\t\t\taddr = BCMA_CORE_PCI_PCICFG0;\n\t\t\taddr |= (func << 8);\n\t\t\taddr |= (off & 0xFC);\n\t\t\tval = pcicore_read32(pc, addr);\n\t\t}\n\t} else {\n\t\taddr = bcma_get_cfgspace_addr(pc, dev, func, off);\n\t\tif (unlikely(!addr))\n\t\t\tgoto out;\n\t\terr = -ENOMEM;\n\t\tmmio = ioremap(addr, sizeof(val));\n\t\tif (!mmio)\n\t\t\tgoto out;\n\n\t\tif (mips_busprobe32(val, mmio)) {\n\t\t\tval = 0xFFFFFFFF;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\tval >>= (8 * (off & 3));\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *)buf) = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*((u16 *)buf) = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*((u32 *)buf) = (u32)val;\n\t\tbreak;\n\t}\n\terr = 0;\nunmap:\n\tif (mmio)\n\t\tiounmap(mmio);\nout:\n\treturn err;\n}\n\nstatic int bcma_extpci_write_config(struct bcma_drv_pci *pc, unsigned int dev,\n\t\t\t\t   unsigned int func, unsigned int off,\n\t\t\t\t   const void *buf, int len)\n{\n\tint err = -EINVAL;\n\tu32 addr, val;\n\tvoid __iomem *mmio = 0;\n\tu16 chipid = pc->core->bus->chipinfo.id;\n\n\tWARN_ON(!pc->hostmode);\n\tif (unlikely(len != 1 && len != 2 && len != 4))\n\t\tgoto out;\n\tif (dev == 0) {\n\t\t \n\t\tif (func > 1)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (off >= PCI_CONFIG_SPACE_SIZE) {\n\t\t\taddr = (func << 12);\n\t\t\taddr |= (off & 0x0FFC);\n\t\t\tval = bcma_pcie_read_config(pc, addr);\n\t\t} else {\n\t\t\taddr = BCMA_CORE_PCI_PCICFG0;\n\t\t\taddr |= (func << 8);\n\t\t\taddr |= (off & 0xFC);\n\t\t\tval = pcicore_read32(pc, addr);\n\t\t}\n\t} else {\n\t\taddr = bcma_get_cfgspace_addr(pc, dev, func, off);\n\t\tif (unlikely(!addr))\n\t\t\tgoto out;\n\t\terr = -ENOMEM;\n\t\tmmio = ioremap(addr, sizeof(val));\n\t\tif (!mmio)\n\t\t\tgoto out;\n\n\t\tif (mips_busprobe32(val, mmio)) {\n\t\t\tval = 0xFFFFFFFF;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\tval &= ~(0xFF << (8 * (off & 3)));\n\t\tval |= *((const u8 *)buf) << (8 * (off & 3));\n\t\tbreak;\n\tcase 2:\n\t\tval &= ~(0xFFFF << (8 * (off & 3)));\n\t\tval |= *((const u16 *)buf) << (8 * (off & 3));\n\t\tbreak;\n\tcase 4:\n\t\tval = *((const u32 *)buf);\n\t\tbreak;\n\t}\n\tif (dev == 0) {\n\t\t \n\t\tif (off >= PCI_CONFIG_SPACE_SIZE)\n\t\t\tbcma_pcie_write_config(pc, addr, val);\n\t\telse\n\t\t\tpcicore_write32(pc, addr, val);\n\t} else {\n\t\twritel(val, mmio);\n\n\t\tif (chipid == BCMA_CHIP_ID_BCM4716 ||\n\t\t    chipid == BCMA_CHIP_ID_BCM4748)\n\t\t\treadl(mmio);\n\t}\n\n\terr = 0;\nunmap:\n\tif (mmio)\n\t\tiounmap(mmio);\nout:\n\treturn err;\n}\n\nstatic int bcma_core_pci_hostmode_read_config(struct pci_bus *bus,\n\t\t\t\t\t      unsigned int devfn,\n\t\t\t\t\t      int reg, int size, u32 *val)\n{\n\tunsigned long flags;\n\tint err;\n\tstruct bcma_drv_pci *pc;\n\tstruct bcma_drv_pci_host *pc_host;\n\n\tpc_host = container_of(bus->ops, struct bcma_drv_pci_host, pci_ops);\n\tpc = pc_host->pdev;\n\n\tspin_lock_irqsave(&pc_host->cfgspace_lock, flags);\n\terr = bcma_extpci_read_config(pc, PCI_SLOT(devfn),\n\t\t\t\t     PCI_FUNC(devfn), reg, val, size);\n\tspin_unlock_irqrestore(&pc_host->cfgspace_lock, flags);\n\n\treturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\n}\n\nstatic int bcma_core_pci_hostmode_write_config(struct pci_bus *bus,\n\t\t\t\t\t       unsigned int devfn,\n\t\t\t\t\t       int reg, int size, u32 val)\n{\n\tunsigned long flags;\n\tint err;\n\tstruct bcma_drv_pci *pc;\n\tstruct bcma_drv_pci_host *pc_host;\n\n\tpc_host = container_of(bus->ops, struct bcma_drv_pci_host, pci_ops);\n\tpc = pc_host->pdev;\n\n\tspin_lock_irqsave(&pc_host->cfgspace_lock, flags);\n\terr = bcma_extpci_write_config(pc, PCI_SLOT(devfn),\n\t\t\t\t      PCI_FUNC(devfn), reg, &val, size);\n\tspin_unlock_irqrestore(&pc_host->cfgspace_lock, flags);\n\n\treturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\n}\n\n \nstatic u8 bcma_find_pci_capability(struct bcma_drv_pci *pc, unsigned int dev,\n\t\t\t\t   unsigned int func, u8 req_cap_id,\n\t\t\t\t   unsigned char *buf, u32 *buflen)\n{\n\tu8 cap_id;\n\tu8 cap_ptr = 0;\n\tu32 bufsize;\n\tu8 byte_val;\n\n\t \n\tbcma_extpci_read_config(pc, dev, func, PCI_HEADER_TYPE, &byte_val,\n\t\t\t\tsizeof(u8));\n\tif ((byte_val & 0x7F) != PCI_HEADER_TYPE_NORMAL)\n\t\treturn cap_ptr;\n\n\t \n\tbcma_extpci_read_config(pc, dev, func, PCI_STATUS, &byte_val,\n\t\t\t\tsizeof(u8));\n\tif (!(byte_val & PCI_STATUS_CAP_LIST))\n\t\treturn cap_ptr;\n\n\t \n\tbcma_extpci_read_config(pc, dev, func, PCI_CAPABILITY_LIST, &cap_ptr,\n\t\t\t\tsizeof(u8));\n\tif (cap_ptr == 0x00)\n\t\treturn cap_ptr;\n\n\t \n\tbcma_extpci_read_config(pc, dev, func, cap_ptr, &cap_id, sizeof(u8));\n\twhile (cap_id != req_cap_id) {\n\t\tbcma_extpci_read_config(pc, dev, func, cap_ptr + 1, &cap_ptr,\n\t\t\t\t\tsizeof(u8));\n\t\tif (cap_ptr == 0x00)\n\t\t\treturn cap_ptr;\n\t\tbcma_extpci_read_config(pc, dev, func, cap_ptr, &cap_id,\n\t\t\t\t\tsizeof(u8));\n\t}\n\n\t \n\tif ((buf != NULL) && (buflen != NULL)) {\n\t\tu8 cap_data;\n\n\t\tbufsize = *buflen;\n\t\tif (!bufsize)\n\t\t\treturn cap_ptr;\n\n\t\t*buflen = 0;\n\n\t\t \n\t\tcap_data = cap_ptr + 2;\n\t\tif ((bufsize + cap_data)  > PCI_CONFIG_SPACE_SIZE)\n\t\t\tbufsize = PCI_CONFIG_SPACE_SIZE - cap_data;\n\t\t*buflen = bufsize;\n\t\twhile (bufsize--) {\n\t\t\tbcma_extpci_read_config(pc, dev, func, cap_data, buf,\n\t\t\t\t\t\tsizeof(u8));\n\t\t\tcap_data++;\n\t\t\tbuf++;\n\t\t}\n\t}\n\n\treturn cap_ptr;\n}\n\n \nstatic void bcma_core_pci_enable_crs(struct bcma_drv_pci *pc)\n{\n\tstruct bcma_bus *bus = pc->core->bus;\n\tu8 cap_ptr, root_ctrl, root_cap, dev;\n\tu16 val16;\n\tint i;\n\n\tcap_ptr = bcma_find_pci_capability(pc, 0, 0, PCI_CAP_ID_EXP, NULL,\n\t\t\t\t\t   NULL);\n\troot_cap = cap_ptr + PCI_EXP_RTCAP;\n\tbcma_extpci_read_config(pc, 0, 0, root_cap, &val16, sizeof(u16));\n\tif (val16 & BCMA_CORE_PCI_RC_CRS_VISIBILITY) {\n\t\t \n\t\troot_ctrl = cap_ptr + PCI_EXP_RTCTL;\n\t\tval16 = PCI_EXP_RTCTL_CRSSVE;\n\t\tbcma_extpci_read_config(pc, 0, 0, root_ctrl, &val16,\n\t\t\t\t\tsizeof(u16));\n\n\t\t \n\t\tfor (dev = 1; dev < BCMA_PCI_SLOT_MAX; dev++) {\n\t\t\tfor (i = 0; i < 100000; i++) {\n\t\t\t\tbcma_extpci_read_config(pc, dev, 0,\n\t\t\t\t\t\t\tPCI_VENDOR_ID, &val16,\n\t\t\t\t\t\t\tsizeof(val16));\n\t\t\t\tif (val16 != 0x1)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t\tif (val16 == 0x1)\n\t\t\t\tbcma_err(bus, \"PCI: Broken device in slot %d\\n\",\n\t\t\t\t\t dev);\n\t\t}\n\t}\n}\n\nvoid bcma_core_pci_hostmode_init(struct bcma_drv_pci *pc)\n{\n\tstruct bcma_bus *bus = pc->core->bus;\n\tstruct bcma_drv_pci_host *pc_host;\n\tu32 tmp;\n\tu32 pci_membase_1G;\n\tunsigned long io_map_base;\n\n\tbcma_info(bus, \"PCIEcore in host mode found\\n\");\n\n\tif (bus->sprom.boardflags_lo & BCMA_CORE_PCI_BFL_NOPCI) {\n\t\tbcma_info(bus, \"This PCIE core is disabled and not working\\n\");\n\t\treturn;\n\t}\n\n\tpc_host = kzalloc(sizeof(*pc_host), GFP_KERNEL);\n\tif (!pc_host)  {\n\t\tbcma_err(bus, \"can not allocate memory\");\n\t\treturn;\n\t}\n\n\tspin_lock_init(&pc_host->cfgspace_lock);\n\n\tpc->host_controller = pc_host;\n\tpc_host->pci_controller.io_resource = &pc_host->io_resource;\n\tpc_host->pci_controller.mem_resource = &pc_host->mem_resource;\n\tpc_host->pci_controller.pci_ops = &pc_host->pci_ops;\n\tpc_host->pdev = pc;\n\n\tpci_membase_1G = BCMA_SOC_PCI_DMA;\n\tpc_host->host_cfg_addr = BCMA_SOC_PCI_CFG;\n\n\tpc_host->pci_ops.read = bcma_core_pci_hostmode_read_config;\n\tpc_host->pci_ops.write = bcma_core_pci_hostmode_write_config;\n\n\tpc_host->mem_resource.name = \"BCMA PCIcore external memory\";\n\tpc_host->mem_resource.start = BCMA_SOC_PCI_DMA;\n\tpc_host->mem_resource.end = BCMA_SOC_PCI_DMA + BCMA_SOC_PCI_DMA_SZ - 1;\n\tpc_host->mem_resource.flags = IORESOURCE_MEM | IORESOURCE_PCI_FIXED;\n\n\tpc_host->io_resource.name = \"BCMA PCIcore external I/O\";\n\tpc_host->io_resource.start = 0x100;\n\tpc_host->io_resource.end = 0x7FF;\n\tpc_host->io_resource.flags = IORESOURCE_IO | IORESOURCE_PCI_FIXED;\n\n\t \n\tusleep_range(3000, 5000);\n\tpcicore_write32(pc, BCMA_CORE_PCI_CTL, BCMA_CORE_PCI_CTL_RST_OE);\n\tmsleep(50);\n\tpcicore_write32(pc, BCMA_CORE_PCI_CTL, BCMA_CORE_PCI_CTL_RST |\n\t\t\tBCMA_CORE_PCI_CTL_RST_OE);\n\n\t \n\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4716 ||\n\t    bus->chipinfo.id == BCMA_CHIP_ID_BCM4748) {\n\t\tpc_host->mem_resource.start = BCMA_SOC_PCI_MEM;\n\t\tpc_host->mem_resource.end = BCMA_SOC_PCI_MEM +\n\t\t\t\t\t    BCMA_SOC_PCI_MEM_SZ - 1;\n\t\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\n\t\t\t\tBCMA_CORE_PCI_SBTOPCI_MEM | BCMA_SOC_PCI_MEM);\n\t} else if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {\n\t\ttmp = BCMA_CORE_PCI_SBTOPCI_MEM;\n\t\ttmp |= BCMA_CORE_PCI_SBTOPCI_PREF;\n\t\ttmp |= BCMA_CORE_PCI_SBTOPCI_BURST;\n\t\tif (pc->core->core_unit == 0) {\n\t\t\tpc_host->mem_resource.start = BCMA_SOC_PCI_MEM;\n\t\t\tpc_host->mem_resource.end = BCMA_SOC_PCI_MEM +\n\t\t\t\t\t\t    BCMA_SOC_PCI_MEM_SZ - 1;\n\t\t\tpc_host->io_resource.start = 0x100;\n\t\t\tpc_host->io_resource.end = 0x47F;\n\t\t\tpci_membase_1G = BCMA_SOC_PCIE_DMA_H32;\n\t\t\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\n\t\t\t\t\ttmp | BCMA_SOC_PCI_MEM);\n\t\t} else if (pc->core->core_unit == 1) {\n\t\t\tpc_host->mem_resource.start = BCMA_SOC_PCI1_MEM;\n\t\t\tpc_host->mem_resource.end = BCMA_SOC_PCI1_MEM +\n\t\t\t\t\t\t    BCMA_SOC_PCI_MEM_SZ - 1;\n\t\t\tpc_host->io_resource.start = 0x480;\n\t\t\tpc_host->io_resource.end = 0x7FF;\n\t\t\tpci_membase_1G = BCMA_SOC_PCIE1_DMA_H32;\n\t\t\tpc_host->host_cfg_addr = BCMA_SOC_PCI1_CFG;\n\t\t\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\n\t\t\t\t\ttmp | BCMA_SOC_PCI1_MEM);\n\t\t}\n\t} else\n\t\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\n\t\t\t\tBCMA_CORE_PCI_SBTOPCI_IO);\n\n\t \n\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI1, BCMA_CORE_PCI_SBTOPCI_CFG0);\n\n\t \n\tpcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI2,\n\t\t\tBCMA_CORE_PCI_SBTOPCI_MEM | pci_membase_1G);\n\n\n\t \n\tmsleep(100);\n\n\tbcma_core_pci_enable_crs(pc);\n\n\tif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706 ||\n\t    bus->chipinfo.id == BCMA_CHIP_ID_BCM4716) {\n\t\tu16 val16;\n\t\tbcma_extpci_read_config(pc, 0, 0, BCMA_CORE_PCI_CFG_DEVCTRL,\n\t\t\t\t\t&val16, sizeof(val16));\n\t\tval16 |= (2 << 5);\t \n\t\tval16 |= (2 << 12);\t \n\t\tbcma_extpci_write_config(pc, 0, 0, BCMA_CORE_PCI_CFG_DEVCTRL,\n\t\t\t\t\t &val16, sizeof(val16));\n\t}\n\n\t \n\ttmp = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\n\tbcma_extpci_write_config(pc, 0, 0, PCI_COMMAND, &tmp, sizeof(tmp));\n\n\t \n\tpcicore_write32(pc, BCMA_CORE_PCI_IMASK, BCMA_CORE_PCI_IMASK_INTA);\n\n\t \n\tio_map_base = (unsigned long)ioremap(pc_host->mem_resource.start,\n\t\t\t\t\t\t     resource_size(&pc_host->mem_resource));\n\tpc_host->pci_controller.io_map_base = io_map_base;\n\tset_io_port_base(pc_host->pci_controller.io_map_base);\n\t \n\tusleep_range(10000, 15000);\n\tregister_pci_controller(&pc_host->pci_controller);\n\treturn;\n}\n\n \nstatic void bcma_core_pci_fixup_pcibridge(struct pci_dev *dev)\n{\n\tif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\n\t\t \n\t\treturn;\n\t}\n\tif (PCI_SLOT(dev->devfn) != 0)\n\t\treturn;\n\n\tpr_info(\"PCI: Fixing up bridge %s\\n\", pci_name(dev));\n\n\t \n\tpci_set_master(dev);\n\tif (pcibios_enable_device(dev, ~0) < 0) {\n\t\tpr_err(\"PCI: BCMA bridge enable failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tpci_write_config_dword(dev, BCMA_PCI_BAR1_CONTROL, 3);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, bcma_core_pci_fixup_pcibridge);\n\n \nstatic void bcma_core_pci_fixup_addresses(struct pci_dev *dev)\n{\n\tstruct resource *res;\n\tint pos, err;\n\n\tif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\n\t\t \n\t\treturn;\n\t}\n\tif (PCI_SLOT(dev->devfn) == 0)\n\t\treturn;\n\n\tpr_info(\"PCI: Fixing up addresses %s\\n\", pci_name(dev));\n\n\tfor (pos = 0; pos < 6; pos++) {\n\t\tres = &dev->resource[pos];\n\t\tif (res->flags & (IORESOURCE_IO | IORESOURCE_MEM)) {\n\t\t\terr = pci_assign_resource(dev, pos);\n\t\t\tif (err)\n\t\t\t\tpr_err(\"PCI: Problem fixing up the addresses on %s\\n\",\n\t\t\t\t       pci_name(dev));\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, bcma_core_pci_fixup_addresses);\n\n \nint bcma_core_pci_plat_dev_init(struct pci_dev *dev)\n{\n\tstruct bcma_drv_pci_host *pc_host;\n\tint readrq;\n\n\tif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\tpc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,\n\t\t\t       pci_ops);\n\n\tpr_info(\"PCI: Fixing up device %s\\n\", pci_name(dev));\n\n\t \n\tdev->irq = bcma_core_irq(pc_host->pdev->core, 0);\n\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\n\n\treadrq = pcie_get_readrq(dev);\n\tif (readrq > 128) {\n\t\tpr_info(\"change PCIe max read request size from %i to 128\\n\", readrq);\n\t\tpcie_set_readrq(dev, 128);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(bcma_core_pci_plat_dev_init);\n\n \nint bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev)\n{\n\tstruct bcma_drv_pci_host *pc_host;\n\n\tif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tpc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,\n\t\t\t       pci_ops);\n\treturn bcma_core_irq(pc_host->pdev->core, 0);\n}\nEXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}