{
  "module_name": "driver_gpio.c",
  "hash_id": "b638c847b1d006956824af39c1989aef142513dc0b07623ab563b5a1bab3f1b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bcma/driver_gpio.c",
  "human_readable_source": " \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/property.h>\n\n#include <linux/bcma/bcma.h>\n\n#include \"bcma_private.h\"\n\n#define BCMA_GPIO_MAX_PINS\t32\n\nstatic int bcma_gpio_get_value(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(chip);\n\n\treturn !!bcma_chipco_gpio_in(cc, 1 << gpio);\n}\n\nstatic void bcma_gpio_set_value(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\tint value)\n{\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(chip);\n\n\tbcma_chipco_gpio_out(cc, 1 << gpio, value ? 1 << gpio : 0);\n}\n\nstatic int bcma_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(chip);\n\n\tbcma_chipco_gpio_outen(cc, 1 << gpio, 0);\n\treturn 0;\n}\n\nstatic int bcma_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\t      int value)\n{\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(chip);\n\n\tbcma_chipco_gpio_outen(cc, 1 << gpio, 1 << gpio);\n\tbcma_chipco_gpio_out(cc, 1 << gpio, value ? 1 << gpio : 0);\n\treturn 0;\n}\n\nstatic int bcma_gpio_request(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(chip);\n\n\tbcma_chipco_gpio_control(cc, 1 << gpio, 0);\n\t \n\tbcma_chipco_gpio_pulldown(cc, 1 << gpio, 0);\n\t \n\tbcma_chipco_gpio_pullup(cc, 1 << gpio, 1 << gpio);\n\n\treturn 0;\n}\n\nstatic void bcma_gpio_free(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(chip);\n\n\t \n\tbcma_chipco_gpio_pullup(cc, 1 << gpio, 0);\n}\n\n#if IS_BUILTIN(CONFIG_BCM47XX) || IS_BUILTIN(CONFIG_ARCH_BCM_5301X)\n\nstatic void bcma_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(gc);\n\tint gpio = irqd_to_hwirq(d);\n\tu32 val = bcma_chipco_gpio_in(cc, BIT(gpio));\n\n\tgpiochip_enable_irq(gc, gpio);\n\tbcma_chipco_gpio_polarity(cc, BIT(gpio), val);\n\tbcma_chipco_gpio_intmask(cc, BIT(gpio), BIT(gpio));\n}\n\nstatic void bcma_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct bcma_drv_cc *cc = gpiochip_get_data(gc);\n\tint gpio = irqd_to_hwirq(d);\n\n\tbcma_chipco_gpio_intmask(cc, BIT(gpio), 0);\n\tgpiochip_disable_irq(gc, gpio);\n}\n\nstatic const struct irq_chip bcma_gpio_irq_chip = {\n\t.name\t\t= \"BCMA-GPIO\",\n\t.irq_mask\t= bcma_gpio_irq_mask,\n\t.irq_unmask\t= bcma_gpio_irq_unmask,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic irqreturn_t bcma_gpio_irq_handler(int irq, void *dev_id)\n{\n\tstruct bcma_drv_cc *cc = dev_id;\n\tstruct gpio_chip *gc = &cc->gpio;\n\tu32 val = bcma_cc_read32(cc, BCMA_CC_GPIOIN);\n\tu32 mask = bcma_cc_read32(cc, BCMA_CC_GPIOIRQ);\n\tu32 pol = bcma_cc_read32(cc, BCMA_CC_GPIOPOL);\n\tunsigned long irqs = (val ^ pol) & mask;\n\tint gpio;\n\n\tif (!irqs)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(gpio, &irqs, gc->ngpio)\n\t\tgeneric_handle_domain_irq_safe(gc->irq.domain, gpio);\n\tbcma_chipco_gpio_polarity(cc, irqs, val & irqs);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcma_gpio_irq_init(struct bcma_drv_cc *cc)\n{\n\tstruct gpio_chip *chip = &cc->gpio;\n\tstruct gpio_irq_chip *girq = &chip->irq;\n\tint hwirq, err;\n\n\tif (cc->core->bus->hosttype != BCMA_HOSTTYPE_SOC)\n\t\treturn 0;\n\n\thwirq = bcma_core_irq(cc->core, 0);\n\terr = request_irq(hwirq, bcma_gpio_irq_handler, IRQF_SHARED, \"gpio\",\n\t\t\t  cc);\n\tif (err)\n\t\treturn err;\n\n\tbcma_chipco_gpio_intmask(cc, ~0, 0);\n\tbcma_cc_set32(cc, BCMA_CC_IRQMASK, BCMA_CC_IRQ_GPIO);\n\n\tgpio_irq_chip_set_chip(girq, &bcma_gpio_irq_chip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\n\treturn 0;\n}\n\nstatic void bcma_gpio_irq_exit(struct bcma_drv_cc *cc)\n{\n\tif (cc->core->bus->hosttype != BCMA_HOSTTYPE_SOC)\n\t\treturn;\n\n\tbcma_cc_mask32(cc, BCMA_CC_IRQMASK, ~BCMA_CC_IRQ_GPIO);\n\tfree_irq(bcma_core_irq(cc->core, 0), cc);\n}\n#else\nstatic int bcma_gpio_irq_init(struct bcma_drv_cc *cc)\n{\n\treturn 0;\n}\n\nstatic void bcma_gpio_irq_exit(struct bcma_drv_cc *cc)\n{\n}\n#endif\n\nint bcma_gpio_init(struct bcma_drv_cc *cc)\n{\n\tstruct bcma_bus *bus = cc->core->bus;\n\tstruct gpio_chip *chip = &cc->gpio;\n\tint err;\n\n\tchip->label\t\t= \"bcma_gpio\";\n\tchip->owner\t\t= THIS_MODULE;\n\tchip->request\t\t= bcma_gpio_request;\n\tchip->free\t\t= bcma_gpio_free;\n\tchip->get\t\t= bcma_gpio_get_value;\n\tchip->set\t\t= bcma_gpio_set_value;\n\tchip->direction_input\t= bcma_gpio_direction_input;\n\tchip->direction_output\t= bcma_gpio_direction_output;\n\tchip->parent\t\t= bus->dev;\n\tchip->fwnode\t\t= dev_fwnode(&cc->core->dev);\n\n\tswitch (bus->chipinfo.id) {\n\tcase BCMA_CHIP_ID_BCM4707:\n\tcase BCMA_CHIP_ID_BCM5357:\n\tcase BCMA_CHIP_ID_BCM53572:\n\tcase BCMA_CHIP_ID_BCM53573:\n\tcase BCMA_CHIP_ID_BCM47094:\n\t\tchip->ngpio\t= 32;\n\t\tbreak;\n\tdefault:\n\t\tchip->ngpio\t= 16;\n\t}\n\n\t \n\tif (IS_BUILTIN(CONFIG_BCM47XX) ||\n\t    cc->core->bus->hosttype == BCMA_HOSTTYPE_SOC)\n\t\tchip->base\t\t= bus->num * BCMA_GPIO_MAX_PINS;\n\telse\n\t\tchip->base\t\t= -1;\n\n\terr = bcma_gpio_irq_init(cc);\n\tif (err)\n\t\treturn err;\n\n\terr = gpiochip_add_data(chip, cc);\n\tif (err) {\n\t\tbcma_gpio_irq_exit(cc);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint bcma_gpio_unregister(struct bcma_drv_cc *cc)\n{\n\tbcma_gpio_irq_exit(cc);\n\tgpiochip_remove(&cc->gpio);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}