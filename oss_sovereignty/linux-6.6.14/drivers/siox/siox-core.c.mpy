{
  "module_name": "siox-core.c",
  "hash_id": "b957acabd4f3cd44d9b9d355c70ff043d3709299d72e2eb174ef4437b601a6b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/siox/siox-core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include \"siox.h\"\n\n \n#define SIOX_STATUS_WDG\t\t\t0x01\n\n \n#define SIOX_STATUS_COUNTER\t\t0x0e\n\n \n#define SIOX_STATUS_TYPE\t\t0xf0\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/siox.h>\n\nstatic bool siox_is_registered;\n\nstatic void siox_master_lock(struct siox_master *smaster)\n{\n\tmutex_lock(&smaster->lock);\n}\n\nstatic void siox_master_unlock(struct siox_master *smaster)\n{\n\tmutex_unlock(&smaster->lock);\n}\n\nstatic inline u8 siox_status_clean(u8 status_read, u8 status_written)\n{\n\t \n\n\treturn status_read ^ (~status_written & 0xe);\n}\n\nstatic bool siox_device_counter_error(struct siox_device *sdevice,\n\t\t\t\t      u8 status_clean)\n{\n\treturn (status_clean & SIOX_STATUS_COUNTER) != 0;\n}\n\nstatic bool siox_device_type_error(struct siox_device *sdevice, u8 status_clean)\n{\n\tu8 statustype = (status_clean & SIOX_STATUS_TYPE) >> 4;\n\n\t \n\tif (sdevice->statustype) {\n\t\tif (statustype != sdevice->statustype)\n\t\t\treturn true;\n\t} else {\n\t\tswitch (statustype) {\n\t\tcase 0:\n\t\tcase 0xf:\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool siox_device_wdg_error(struct siox_device *sdevice, u8 status_clean)\n{\n\treturn (status_clean & SIOX_STATUS_WDG) == 0;\n}\n\n \nbool siox_device_synced(struct siox_device *sdevice)\n{\n\tif (siox_device_type_error(sdevice, sdevice->status_read_clean))\n\t\treturn false;\n\n\treturn !siox_device_counter_error(sdevice, sdevice->status_read_clean);\n\n}\nEXPORT_SYMBOL_GPL(siox_device_synced);\n\n \nbool siox_device_connected(struct siox_device *sdevice)\n{\n\tif (!siox_device_synced(sdevice))\n\t\treturn false;\n\n\treturn !siox_device_wdg_error(sdevice, sdevice->status_read_clean);\n}\nEXPORT_SYMBOL_GPL(siox_device_connected);\n\nstatic void siox_poll(struct siox_master *smaster)\n{\n\tstruct siox_device *sdevice;\n\tsize_t i = smaster->setbuf_len;\n\tunsigned int devno = 0;\n\tint unsync_error = 0;\n\n\tsmaster->last_poll = jiffies;\n\n\t \n\tif (++smaster->status > 0x0d)\n\t\tsmaster->status = 0;\n\n\tmemset(smaster->buf, 0, smaster->setbuf_len);\n\n\t \n\tlist_for_each_entry(sdevice, &smaster->devices, node) {\n\t\tstruct siox_driver *sdriver =\n\t\t\tto_siox_driver(sdevice->dev.driver);\n\t\tsdevice->status_written = smaster->status;\n\n\t\ti -= sdevice->inbytes;\n\n\t\t \n\t\tif (!siox_device_synced(sdevice))\n\t\t\tunsync_error = 1;\n\n\t\tif (sdriver && !unsync_error)\n\t\t\tsdriver->set_data(sdevice, sdevice->status_written,\n\t\t\t\t\t  &smaster->buf[i + 1]);\n\t\telse\n\t\t\t \n\t\t\tsdevice->status_written &= ~SIOX_STATUS_WDG;\n\n\t\tsmaster->buf[i] = sdevice->status_written;\n\n\t\ttrace_siox_set_data(smaster, sdevice, devno, i);\n\n\t\tdevno++;\n\t}\n\n\tsmaster->pushpull(smaster, smaster->setbuf_len, smaster->buf,\n\t\t\t  smaster->getbuf_len,\n\t\t\t  smaster->buf + smaster->setbuf_len);\n\n\tunsync_error = 0;\n\n\t \n\tdevno = 0;\n\ti = smaster->setbuf_len;\n\tlist_for_each_entry(sdevice, &smaster->devices, node) {\n\t\tstruct siox_driver *sdriver =\n\t\t\tto_siox_driver(sdevice->dev.driver);\n\t\tu8 status = smaster->buf[i + sdevice->outbytes - 1];\n\t\tu8 status_clean;\n\t\tu8 prev_status_clean = sdevice->status_read_clean;\n\t\tbool synced = true;\n\t\tbool connected = true;\n\n\t\tif (!siox_device_synced(sdevice))\n\t\t\tunsync_error = 1;\n\n\t\t \n\t\tif (!sdriver || unsync_error)\n\t\t\tstatus &= ~SIOX_STATUS_WDG;\n\n\t\tstatus_clean =\n\t\t\tsiox_status_clean(status,\n\t\t\t\t\t  sdevice->status_written_lastcycle);\n\n\t\t \n\t\tif (siox_device_counter_error(sdevice, status_clean) ||\n\t\t    siox_device_type_error(sdevice, status_clean)) {\n\t\t\tbool prev_error;\n\n\t\t\tsynced = false;\n\n\t\t\t \n\t\t\tprev_error =\n\t\t\t\tsiox_device_counter_error(sdevice,\n\t\t\t\t\t\t\t  prev_status_clean) ||\n\t\t\t\tsiox_device_type_error(sdevice,\n\t\t\t\t\t\t       prev_status_clean);\n\n\t\t\tif (!prev_error) {\n\t\t\t\tsdevice->status_errors++;\n\t\t\t\tsysfs_notify_dirent(sdevice->status_errors_kn);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!synced) {\n\t\t\tstatus &= ~SIOX_STATUS_WDG;\n\t\t\tstatus_clean &= ~SIOX_STATUS_WDG;\n\t\t}\n\n\t\tif (siox_device_wdg_error(sdevice, status_clean))\n\t\t\tconnected = false;\n\n\t\t \n\t\tif ((status_clean ^ prev_status_clean) & SIOX_STATUS_WDG) {\n\t\t\tsysfs_notify_dirent(sdevice->watchdog_kn);\n\n\t\t\tif (siox_device_wdg_error(sdevice, status_clean)) {\n\t\t\t\tstruct kernfs_node *wd_errs =\n\t\t\t\t\tsdevice->watchdog_errors_kn;\n\n\t\t\t\tsdevice->watchdog_errors++;\n\t\t\t\tsysfs_notify_dirent(wd_errs);\n\t\t\t}\n\t\t}\n\n\t\tif (connected != sdevice->connected)\n\t\t\tsysfs_notify_dirent(sdevice->connected_kn);\n\n\t\tsdevice->status_read_clean = status_clean;\n\t\tsdevice->status_written_lastcycle = sdevice->status_written;\n\t\tsdevice->connected = connected;\n\n\t\ttrace_siox_get_data(smaster, sdevice, devno, status_clean, i);\n\n\t\t \n\t\tif (sdriver && connected)\n\t\t\tsdriver->get_data(sdevice, &smaster->buf[i]);\n\n\t\tdevno++;\n\t\ti += sdevice->outbytes;\n\t}\n}\n\nstatic int siox_poll_thread(void *data)\n{\n\tstruct siox_master *smaster = data;\n\tsigned long timeout = 0;\n\n\tget_device(&smaster->dev);\n\n\tfor (;;) {\n\t\tif (kthread_should_stop()) {\n\t\t\tput_device(&smaster->dev);\n\t\t\treturn 0;\n\t\t}\n\n\t\tsiox_master_lock(smaster);\n\n\t\tif (smaster->active) {\n\t\t\tunsigned long next_poll =\n\t\t\t\tsmaster->last_poll + smaster->poll_interval;\n\t\t\tif (time_is_before_eq_jiffies(next_poll))\n\t\t\t\tsiox_poll(smaster);\n\n\t\t\ttimeout = smaster->poll_interval -\n\t\t\t\t(jiffies - smaster->last_poll);\n\t\t} else {\n\t\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\t}\n\n\t\t \n\t\tif (timeout > 0)\n\t\t\tset_current_state(TASK_IDLE);\n\n\t\tsiox_master_unlock(smaster);\n\n\t\tif (timeout > 0)\n\t\t\tschedule_timeout(timeout);\n\n\t\t \n\t\tset_current_state(TASK_RUNNING);\n\t}\n}\n\nstatic int __siox_start(struct siox_master *smaster)\n{\n\tif (!(smaster->setbuf_len + smaster->getbuf_len))\n\t\treturn -ENODEV;\n\n\tif (!smaster->buf)\n\t\treturn -ENOMEM;\n\n\tif (smaster->active)\n\t\treturn 0;\n\n\tsmaster->active = 1;\n\twake_up_process(smaster->poll_thread);\n\n\treturn 1;\n}\n\nstatic int siox_start(struct siox_master *smaster)\n{\n\tint ret;\n\n\tsiox_master_lock(smaster);\n\tret = __siox_start(smaster);\n\tsiox_master_unlock(smaster);\n\n\treturn ret;\n}\n\nstatic int __siox_stop(struct siox_master *smaster)\n{\n\tif (smaster->active) {\n\t\tstruct siox_device *sdevice;\n\n\t\tsmaster->active = 0;\n\n\t\tlist_for_each_entry(sdevice, &smaster->devices, node) {\n\t\t\tif (sdevice->connected)\n\t\t\t\tsysfs_notify_dirent(sdevice->connected_kn);\n\t\t\tsdevice->connected = false;\n\t\t}\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int siox_stop(struct siox_master *smaster)\n{\n\tint ret;\n\n\tsiox_master_lock(smaster);\n\tret = __siox_stop(smaster);\n\tsiox_master_unlock(smaster);\n\n\treturn ret;\n}\n\nstatic ssize_t type_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", sdev->type);\n}\n\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t inbytes_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\n\treturn sprintf(buf, \"%zu\\n\", sdev->inbytes);\n}\n\nstatic DEVICE_ATTR_RO(inbytes);\n\nstatic ssize_t outbytes_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\n\treturn sprintf(buf, \"%zu\\n\", sdev->outbytes);\n}\n\nstatic DEVICE_ATTR_RO(outbytes);\n\nstatic ssize_t status_errors_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\tunsigned int status_errors;\n\n\tsiox_master_lock(sdev->smaster);\n\n\tstatus_errors = sdev->status_errors;\n\n\tsiox_master_unlock(sdev->smaster);\n\n\treturn sprintf(buf, \"%u\\n\", status_errors);\n}\n\nstatic DEVICE_ATTR_RO(status_errors);\n\nstatic ssize_t connected_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\tbool connected;\n\n\tsiox_master_lock(sdev->smaster);\n\n\tconnected = sdev->connected;\n\n\tsiox_master_unlock(sdev->smaster);\n\n\treturn sprintf(buf, \"%u\\n\", connected);\n}\n\nstatic DEVICE_ATTR_RO(connected);\n\nstatic ssize_t watchdog_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\tu8 status;\n\n\tsiox_master_lock(sdev->smaster);\n\n\tstatus = sdev->status_read_clean;\n\n\tsiox_master_unlock(sdev->smaster);\n\n\treturn sprintf(buf, \"%d\\n\", status & SIOX_STATUS_WDG);\n}\n\nstatic DEVICE_ATTR_RO(watchdog);\n\nstatic ssize_t watchdog_errors_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct siox_device *sdev = to_siox_device(dev);\n\tunsigned int watchdog_errors;\n\n\tsiox_master_lock(sdev->smaster);\n\n\twatchdog_errors = sdev->watchdog_errors;\n\n\tsiox_master_unlock(sdev->smaster);\n\n\treturn sprintf(buf, \"%u\\n\", watchdog_errors);\n}\n\nstatic DEVICE_ATTR_RO(watchdog_errors);\n\nstatic struct attribute *siox_device_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_inbytes.attr,\n\t&dev_attr_outbytes.attr,\n\t&dev_attr_status_errors.attr,\n\t&dev_attr_connected.attr,\n\t&dev_attr_watchdog.attr,\n\t&dev_attr_watchdog_errors.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(siox_device);\n\nstatic void siox_device_release(struct device *dev)\n{\n\tstruct siox_device *sdevice = to_siox_device(dev);\n\n\tkfree(sdevice);\n}\n\nstatic struct device_type siox_device_type = {\n\t.groups = siox_device_groups,\n\t.release = siox_device_release,\n};\n\nstatic int siox_match(struct device *dev, struct device_driver *drv)\n{\n\tif (dev->type != &siox_device_type)\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\nstatic int siox_probe(struct device *dev)\n{\n\tstruct siox_driver *sdriver = to_siox_driver(dev->driver);\n\tstruct siox_device *sdevice = to_siox_device(dev);\n\n\treturn sdriver->probe(sdevice);\n}\n\nstatic void siox_remove(struct device *dev)\n{\n\tstruct siox_driver *sdriver =\n\t\tcontainer_of(dev->driver, struct siox_driver, driver);\n\tstruct siox_device *sdevice = to_siox_device(dev);\n\n\tif (sdriver->remove)\n\t\tsdriver->remove(sdevice);\n}\n\nstatic void siox_shutdown(struct device *dev)\n{\n\tstruct siox_device *sdevice = to_siox_device(dev);\n\tstruct siox_driver *sdriver;\n\n\tif (!dev->driver)\n\t\treturn;\n\n\tsdriver = container_of(dev->driver, struct siox_driver, driver);\n\tif (sdriver->shutdown)\n\t\tsdriver->shutdown(sdevice);\n}\n\nstatic struct bus_type siox_bus_type = {\n\t.name = \"siox\",\n\t.match = siox_match,\n\t.probe = siox_probe,\n\t.remove = siox_remove,\n\t.shutdown = siox_shutdown,\n};\n\nstatic ssize_t active_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\n\treturn sprintf(buf, \"%d\\n\", smaster->active);\n}\n\nstatic ssize_t active_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\tint ret;\n\tint active;\n\n\tret = kstrtoint(buf, 0, &active);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (active)\n\t\tret = siox_start(smaster);\n\telse\n\t\tret = siox_stop(smaster);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(active);\n\nstatic struct siox_device *siox_device_add(struct siox_master *smaster,\n\t\t\t\t\t   const char *type, size_t inbytes,\n\t\t\t\t\t   size_t outbytes, u8 statustype);\n\nstatic ssize_t device_add_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\tint ret;\n\tchar type[20] = \"\";\n\tsize_t inbytes = 0, outbytes = 0;\n\tu8 statustype = 0;\n\n\tret = sscanf(buf, \"%19s %zu %zu %hhu\", type, &inbytes,\n\t\t     &outbytes, &statustype);\n\tif (ret != 3 && ret != 4)\n\t\treturn -EINVAL;\n\n\tif (strcmp(type, \"siox-12x8\") || inbytes != 2 || outbytes != 4)\n\t\treturn -EINVAL;\n\n\tsiox_device_add(smaster, \"siox-12x8\", inbytes, outbytes, statustype);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(device_add);\n\nstatic void siox_device_remove(struct siox_master *smaster);\n\nstatic ssize_t device_remove_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\n\t \n\tsiox_device_remove(smaster);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(device_remove);\n\nstatic ssize_t poll_interval_ns_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\n\treturn sprintf(buf, \"%lld\\n\", jiffies_to_nsecs(smaster->poll_interval));\n}\n\nstatic ssize_t poll_interval_ns_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\tint ret;\n\tu64 val;\n\n\tret = kstrtou64(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsiox_master_lock(smaster);\n\n\tsmaster->poll_interval = nsecs_to_jiffies(val);\n\n\tsiox_master_unlock(smaster);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(poll_interval_ns);\n\nstatic struct attribute *siox_master_attrs[] = {\n\t&dev_attr_active.attr,\n\t&dev_attr_device_add.attr,\n\t&dev_attr_device_remove.attr,\n\t&dev_attr_poll_interval_ns.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(siox_master);\n\nstatic void siox_master_release(struct device *dev)\n{\n\tstruct siox_master *smaster = to_siox_master(dev);\n\n\tkfree(smaster);\n}\n\nstatic struct device_type siox_master_type = {\n\t.groups = siox_master_groups,\n\t.release = siox_master_release,\n};\n\nstruct siox_master *siox_master_alloc(struct device *dev,\n\t\t\t\t      size_t size)\n{\n\tstruct siox_master *smaster;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tsmaster = kzalloc(sizeof(*smaster) + size, GFP_KERNEL);\n\tif (!smaster)\n\t\treturn NULL;\n\n\tdevice_initialize(&smaster->dev);\n\n\tsmaster->busno = -1;\n\tsmaster->dev.bus = &siox_bus_type;\n\tsmaster->dev.type = &siox_master_type;\n\tsmaster->dev.parent = dev;\n\tsmaster->poll_interval = DIV_ROUND_UP(HZ, 40);\n\n\tdev_set_drvdata(&smaster->dev, &smaster[1]);\n\n\treturn smaster;\n}\nEXPORT_SYMBOL_GPL(siox_master_alloc);\n\nint siox_master_register(struct siox_master *smaster)\n{\n\tint ret;\n\n\tif (!siox_is_registered)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!smaster->pushpull)\n\t\treturn -EINVAL;\n\n\tdev_set_name(&smaster->dev, \"siox-%d\", smaster->busno);\n\n\tmutex_init(&smaster->lock);\n\tINIT_LIST_HEAD(&smaster->devices);\n\n\tsmaster->last_poll = jiffies;\n\tsmaster->poll_thread = kthread_run(siox_poll_thread, smaster,\n\t\t\t\t\t   \"siox-%d\", smaster->busno);\n\tif (IS_ERR(smaster->poll_thread)) {\n\t\tsmaster->active = 0;\n\t\treturn PTR_ERR(smaster->poll_thread);\n\t}\n\n\tret = device_add(&smaster->dev);\n\tif (ret)\n\t\tkthread_stop(smaster->poll_thread);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(siox_master_register);\n\nvoid siox_master_unregister(struct siox_master *smaster)\n{\n\t \n\tdevice_del(&smaster->dev);\n\n\tsiox_master_lock(smaster);\n\n\t__siox_stop(smaster);\n\n\twhile (smaster->num_devices) {\n\t\tstruct siox_device *sdevice;\n\n\t\tsdevice = container_of(smaster->devices.prev,\n\t\t\t\t       struct siox_device, node);\n\t\tlist_del(&sdevice->node);\n\t\tsmaster->num_devices--;\n\n\t\tsiox_master_unlock(smaster);\n\n\t\tdevice_unregister(&sdevice->dev);\n\n\t\tsiox_master_lock(smaster);\n\t}\n\n\tsiox_master_unlock(smaster);\n\n\tput_device(&smaster->dev);\n}\nEXPORT_SYMBOL_GPL(siox_master_unregister);\n\nstatic struct siox_device *siox_device_add(struct siox_master *smaster,\n\t\t\t\t\t   const char *type, size_t inbytes,\n\t\t\t\t\t   size_t outbytes, u8 statustype)\n{\n\tstruct siox_device *sdevice;\n\tint ret;\n\tsize_t buf_len;\n\n\tsdevice = kzalloc(sizeof(*sdevice), GFP_KERNEL);\n\tif (!sdevice)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsdevice->type = type;\n\tsdevice->inbytes = inbytes;\n\tsdevice->outbytes = outbytes;\n\tsdevice->statustype = statustype;\n\n\tsdevice->smaster = smaster;\n\tsdevice->dev.parent = &smaster->dev;\n\tsdevice->dev.bus = &siox_bus_type;\n\tsdevice->dev.type = &siox_device_type;\n\n\tsiox_master_lock(smaster);\n\n\tdev_set_name(&sdevice->dev, \"siox-%d-%d\",\n\t\t     smaster->busno, smaster->num_devices);\n\n\tbuf_len = smaster->setbuf_len + inbytes +\n\t\tsmaster->getbuf_len + outbytes;\n\tif (smaster->buf_len < buf_len) {\n\t\tu8 *buf = krealloc(smaster->buf, buf_len, GFP_KERNEL);\n\n\t\tif (!buf) {\n\t\t\tdev_err(&smaster->dev,\n\t\t\t\t\"failed to realloc buffer to %zu\\n\", buf_len);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_buf_alloc;\n\t\t}\n\n\t\tsmaster->buf_len = buf_len;\n\t\tsmaster->buf = buf;\n\t}\n\n\tret = device_register(&sdevice->dev);\n\tif (ret) {\n\t\tdev_err(&smaster->dev, \"failed to register device: %d\\n\", ret);\n\n\t\tgoto err_device_register;\n\t}\n\n\tsmaster->num_devices++;\n\tlist_add_tail(&sdevice->node, &smaster->devices);\n\n\tsmaster->setbuf_len += sdevice->inbytes;\n\tsmaster->getbuf_len += sdevice->outbytes;\n\n\tsdevice->status_errors_kn = sysfs_get_dirent(sdevice->dev.kobj.sd,\n\t\t\t\t\t\t     \"status_errors\");\n\tsdevice->watchdog_kn = sysfs_get_dirent(sdevice->dev.kobj.sd,\n\t\t\t\t\t\t\"watchdog\");\n\tsdevice->watchdog_errors_kn = sysfs_get_dirent(sdevice->dev.kobj.sd,\n\t\t\t\t\t\t       \"watchdog_errors\");\n\tsdevice->connected_kn = sysfs_get_dirent(sdevice->dev.kobj.sd,\n\t\t\t\t\t\t \"connected\");\n\n\tsiox_master_unlock(smaster);\n\n\treturn sdevice;\n\nerr_device_register:\n\t \n\tput_device(&sdevice->dev);\n\tsdevice = NULL;\n\nerr_buf_alloc:\n\tsiox_master_unlock(smaster);\n\n\tkfree(sdevice);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void siox_device_remove(struct siox_master *smaster)\n{\n\tstruct siox_device *sdevice;\n\n\tsiox_master_lock(smaster);\n\n\tif (!smaster->num_devices) {\n\t\tsiox_master_unlock(smaster);\n\t\treturn;\n\t}\n\n\tsdevice = container_of(smaster->devices.prev, struct siox_device, node);\n\tlist_del(&sdevice->node);\n\tsmaster->num_devices--;\n\n\tsmaster->setbuf_len -= sdevice->inbytes;\n\tsmaster->getbuf_len -= sdevice->outbytes;\n\n\tif (!smaster->num_devices)\n\t\t__siox_stop(smaster);\n\n\tsiox_master_unlock(smaster);\n\n\t \n\tdevice_unregister(&sdevice->dev);\n}\n\nint __siox_driver_register(struct siox_driver *sdriver, struct module *owner)\n{\n\tint ret;\n\n\tif (unlikely(!siox_is_registered))\n\t\treturn -EPROBE_DEFER;\n\n\tif (!sdriver->probe ||\n\t    (!sdriver->set_data && !sdriver->get_data)) {\n\t\tpr_err(\"Driver %s doesn't provide needed callbacks\\n\",\n\t\t       sdriver->driver.name);\n\t\treturn -EINVAL;\n\t}\n\n\tsdriver->driver.owner = owner;\n\tsdriver->driver.bus = &siox_bus_type;\n\n\tret = driver_register(&sdriver->driver);\n\tif (ret)\n\t\tpr_err(\"Failed to register siox driver %s (%d)\\n\",\n\t\t       sdriver->driver.name, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__siox_driver_register);\n\nstatic int __init siox_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&siox_bus_type);\n\tif (ret) {\n\t\tpr_err(\"Registration of SIOX bus type failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsiox_is_registered = true;\n\n\treturn 0;\n}\nsubsys_initcall(siox_init);\n\nstatic void __exit siox_exit(void)\n{\n\tbus_unregister(&siox_bus_type);\n}\nmodule_exit(siox_exit);\n\nMODULE_AUTHOR(\"Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Eckelmann SIOX driver core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}