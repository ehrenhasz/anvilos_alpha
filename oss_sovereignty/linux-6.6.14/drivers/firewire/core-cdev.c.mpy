{
  "module_name": "core-cdev.c",
  "hash_id": "0905064bd417dad0d1892f1321ab990c5504f2b8f2b406dbf2f4bf7c380c5813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core-cdev.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/compat.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-cdev.h>\n#include <linux/idr.h>\n#include <linux/irqflags.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/sched.h>  \n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n\n#include \"core.h\"\n\n \n#define FW_CDEV_KERNEL_VERSION\t\t\t5\n#define FW_CDEV_VERSION_EVENT_REQUEST2\t\t4\n#define FW_CDEV_VERSION_ALLOCATE_REGION_END\t4\n#define FW_CDEV_VERSION_AUTO_FLUSH_ISO_OVERFLOW\t5\n#define FW_CDEV_VERSION_EVENT_ASYNC_TSTAMP\t6\n\nstruct client {\n\tu32 version;\n\tstruct fw_device *device;\n\n\tspinlock_t lock;\n\tbool in_shutdown;\n\tstruct idr resource_idr;\n\tstruct list_head event_list;\n\twait_queue_head_t wait;\n\twait_queue_head_t tx_flush_wait;\n\tu64 bus_reset_closure;\n\n\tstruct fw_iso_context *iso_context;\n\tu64 iso_closure;\n\tstruct fw_iso_buffer buffer;\n\tunsigned long vm_start;\n\tbool buffer_is_mapped;\n\n\tstruct list_head phy_receiver_link;\n\tu64 phy_receiver_closure;\n\n\tstruct list_head link;\n\tstruct kref kref;\n};\n\nstatic inline void client_get(struct client *client)\n{\n\tkref_get(&client->kref);\n}\n\nstatic void client_release(struct kref *kref)\n{\n\tstruct client *client = container_of(kref, struct client, kref);\n\n\tfw_device_put(client->device);\n\tkfree(client);\n}\n\nstatic void client_put(struct client *client)\n{\n\tkref_put(&client->kref, client_release);\n}\n\nstruct client_resource;\ntypedef void (*client_resource_release_fn_t)(struct client *,\n\t\t\t\t\t     struct client_resource *);\nstruct client_resource {\n\tclient_resource_release_fn_t release;\n\tint handle;\n};\n\nstruct address_handler_resource {\n\tstruct client_resource resource;\n\tstruct fw_address_handler handler;\n\t__u64 closure;\n\tstruct client *client;\n};\n\nstruct outbound_transaction_resource {\n\tstruct client_resource resource;\n\tstruct fw_transaction transaction;\n};\n\nstruct inbound_transaction_resource {\n\tstruct client_resource resource;\n\tstruct fw_card *card;\n\tstruct fw_request *request;\n\tbool is_fcp;\n\tvoid *data;\n\tsize_t length;\n};\n\nstruct descriptor_resource {\n\tstruct client_resource resource;\n\tstruct fw_descriptor descriptor;\n\tu32 data[];\n};\n\nstruct iso_resource {\n\tstruct client_resource resource;\n\tstruct client *client;\n\t \n\tstruct delayed_work work;\n\tenum {ISO_RES_ALLOC, ISO_RES_REALLOC, ISO_RES_DEALLOC,\n\t      ISO_RES_ALLOC_ONCE, ISO_RES_DEALLOC_ONCE,} todo;\n\tint generation;\n\tu64 channels;\n\ts32 bandwidth;\n\tstruct iso_resource_event *e_alloc, *e_dealloc;\n};\n\nstatic void release_iso_resource(struct client *, struct client_resource *);\n\nstatic void schedule_iso_resource(struct iso_resource *r, unsigned long delay)\n{\n\tclient_get(r->client);\n\tif (!queue_delayed_work(fw_workqueue, &r->work, delay))\n\t\tclient_put(r->client);\n}\n\nstatic void schedule_if_iso_resource(struct client_resource *resource)\n{\n\tif (resource->release == release_iso_resource)\n\t\tschedule_iso_resource(container_of(resource,\n\t\t\t\t\tstruct iso_resource, resource), 0);\n}\n\n \nstruct event {\n\tstruct { void *data; size_t size; } v[2];\n\tstruct list_head link;\n};\n\nstruct bus_reset_event {\n\tstruct event event;\n\tstruct fw_cdev_event_bus_reset reset;\n};\n\nstruct outbound_transaction_event {\n\tstruct event event;\n\tstruct client *client;\n\tstruct outbound_transaction_resource r;\n\tunion {\n\t\tstruct fw_cdev_event_response without_tstamp;\n\t\tstruct fw_cdev_event_response2 with_tstamp;\n\t} rsp;\n};\n\nstruct inbound_transaction_event {\n\tstruct event event;\n\tunion {\n\t\tstruct fw_cdev_event_request request;\n\t\tstruct fw_cdev_event_request2 request2;\n\t\tstruct fw_cdev_event_request3 with_tstamp;\n\t} req;\n};\n\nstruct iso_interrupt_event {\n\tstruct event event;\n\tstruct fw_cdev_event_iso_interrupt interrupt;\n};\n\nstruct iso_interrupt_mc_event {\n\tstruct event event;\n\tstruct fw_cdev_event_iso_interrupt_mc interrupt;\n};\n\nstruct iso_resource_event {\n\tstruct event event;\n\tstruct fw_cdev_event_iso_resource iso_resource;\n};\n\nstruct outbound_phy_packet_event {\n\tstruct event event;\n\tstruct client *client;\n\tstruct fw_packet p;\n\tunion {\n\t\tstruct fw_cdev_event_phy_packet without_tstamp;\n\t\tstruct fw_cdev_event_phy_packet2 with_tstamp;\n\t} phy_packet;\n};\n\nstruct inbound_phy_packet_event {\n\tstruct event event;\n\tunion {\n\t\tstruct fw_cdev_event_phy_packet without_tstamp;\n\t\tstruct fw_cdev_event_phy_packet2 with_tstamp;\n\t} phy_packet;\n};\n\n#ifdef CONFIG_COMPAT\nstatic void __user *u64_to_uptr(u64 value)\n{\n\tif (in_compat_syscall())\n\t\treturn compat_ptr(value);\n\telse\n\t\treturn (void __user *)(unsigned long)value;\n}\n\nstatic u64 uptr_to_u64(void __user *ptr)\n{\n\tif (in_compat_syscall())\n\t\treturn ptr_to_compat(ptr);\n\telse\n\t\treturn (u64)(unsigned long)ptr;\n}\n#else\nstatic inline void __user *u64_to_uptr(u64 value)\n{\n\treturn (void __user *)(unsigned long)value;\n}\n\nstatic inline u64 uptr_to_u64(void __user *ptr)\n{\n\treturn (u64)(unsigned long)ptr;\n}\n#endif  \n\nstatic int fw_device_op_open(struct inode *inode, struct file *file)\n{\n\tstruct fw_device *device;\n\tstruct client *client;\n\n\tdevice = fw_device_get_by_devt(inode->i_rdev);\n\tif (device == NULL)\n\t\treturn -ENODEV;\n\n\tif (fw_device_is_shutdown(device)) {\n\t\tfw_device_put(device);\n\t\treturn -ENODEV;\n\t}\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL) {\n\t\tfw_device_put(device);\n\t\treturn -ENOMEM;\n\t}\n\n\tclient->device = device;\n\tspin_lock_init(&client->lock);\n\tidr_init(&client->resource_idr);\n\tINIT_LIST_HEAD(&client->event_list);\n\tinit_waitqueue_head(&client->wait);\n\tinit_waitqueue_head(&client->tx_flush_wait);\n\tINIT_LIST_HEAD(&client->phy_receiver_link);\n\tINIT_LIST_HEAD(&client->link);\n\tkref_init(&client->kref);\n\n\tfile->private_data = client;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic void queue_event(struct client *client, struct event *event,\n\t\t\tvoid *data0, size_t size0, void *data1, size_t size1)\n{\n\tunsigned long flags;\n\n\tevent->v[0].data = data0;\n\tevent->v[0].size = size0;\n\tevent->v[1].data = data1;\n\tevent->v[1].size = size1;\n\n\tspin_lock_irqsave(&client->lock, flags);\n\tif (client->in_shutdown)\n\t\tkfree(event);\n\telse\n\t\tlist_add_tail(&event->link, &client->event_list);\n\tspin_unlock_irqrestore(&client->lock, flags);\n\n\twake_up_interruptible(&client->wait);\n}\n\nstatic int dequeue_event(struct client *client,\n\t\t\t char __user *buffer, size_t count)\n{\n\tstruct event *event;\n\tsize_t size, total;\n\tint i, ret;\n\n\tret = wait_event_interruptible(client->wait,\n\t\t\t!list_empty(&client->event_list) ||\n\t\t\tfw_device_is_shutdown(client->device));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (list_empty(&client->event_list) &&\n\t\t       fw_device_is_shutdown(client->device))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&client->lock);\n\tevent = list_first_entry(&client->event_list, struct event, link);\n\tlist_del(&event->link);\n\tspin_unlock_irq(&client->lock);\n\n\ttotal = 0;\n\tfor (i = 0; i < ARRAY_SIZE(event->v) && total < count; i++) {\n\t\tsize = min(event->v[i].size, count - total);\n\t\tif (copy_to_user(buffer + total, event->v[i].data, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\ttotal += size;\n\t}\n\tret = total;\n\n out:\n\tkfree(event);\n\n\treturn ret;\n}\n\nstatic ssize_t fw_device_op_read(struct file *file, char __user *buffer,\n\t\t\t\t size_t count, loff_t *offset)\n{\n\tstruct client *client = file->private_data;\n\n\treturn dequeue_event(client, buffer, count);\n}\n\nstatic void fill_bus_reset_event(struct fw_cdev_event_bus_reset *event,\n\t\t\t\t struct client *client)\n{\n\tstruct fw_card *card = client->device->card;\n\n\tspin_lock_irq(&card->lock);\n\n\tevent->closure\t     = client->bus_reset_closure;\n\tevent->type          = FW_CDEV_EVENT_BUS_RESET;\n\tevent->generation    = client->device->generation;\n\tevent->node_id       = client->device->node_id;\n\tevent->local_node_id = card->local_node->node_id;\n\tevent->bm_node_id    = card->bm_node_id;\n\tevent->irm_node_id   = card->irm_node->node_id;\n\tevent->root_node_id  = card->root_node->node_id;\n\n\tspin_unlock_irq(&card->lock);\n}\n\nstatic void for_each_client(struct fw_device *device,\n\t\t\t    void (*callback)(struct client *client))\n{\n\tstruct client *c;\n\n\tmutex_lock(&device->client_list_mutex);\n\tlist_for_each_entry(c, &device->client_list, link)\n\t\tcallback(c);\n\tmutex_unlock(&device->client_list_mutex);\n}\n\nstatic int schedule_reallocations(int id, void *p, void *data)\n{\n\tschedule_if_iso_resource(p);\n\n\treturn 0;\n}\n\nstatic void queue_bus_reset_event(struct client *client)\n{\n\tstruct bus_reset_event *e;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (e == NULL)\n\t\treturn;\n\n\tfill_bus_reset_event(&e->reset, client);\n\n\tqueue_event(client, &e->event,\n\t\t    &e->reset, sizeof(e->reset), NULL, 0);\n\n\tspin_lock_irq(&client->lock);\n\tidr_for_each(&client->resource_idr, schedule_reallocations, client);\n\tspin_unlock_irq(&client->lock);\n}\n\nvoid fw_device_cdev_update(struct fw_device *device)\n{\n\tfor_each_client(device, queue_bus_reset_event);\n}\n\nstatic void wake_up_client(struct client *client)\n{\n\twake_up_interruptible(&client->wait);\n}\n\nvoid fw_device_cdev_remove(struct fw_device *device)\n{\n\tfor_each_client(device, wake_up_client);\n}\n\nunion ioctl_arg {\n\tstruct fw_cdev_get_info\t\t\tget_info;\n\tstruct fw_cdev_send_request\t\tsend_request;\n\tstruct fw_cdev_allocate\t\t\tallocate;\n\tstruct fw_cdev_deallocate\t\tdeallocate;\n\tstruct fw_cdev_send_response\t\tsend_response;\n\tstruct fw_cdev_initiate_bus_reset\tinitiate_bus_reset;\n\tstruct fw_cdev_add_descriptor\t\tadd_descriptor;\n\tstruct fw_cdev_remove_descriptor\tremove_descriptor;\n\tstruct fw_cdev_create_iso_context\tcreate_iso_context;\n\tstruct fw_cdev_queue_iso\t\tqueue_iso;\n\tstruct fw_cdev_start_iso\t\tstart_iso;\n\tstruct fw_cdev_stop_iso\t\t\tstop_iso;\n\tstruct fw_cdev_get_cycle_timer\t\tget_cycle_timer;\n\tstruct fw_cdev_allocate_iso_resource\tallocate_iso_resource;\n\tstruct fw_cdev_send_stream_packet\tsend_stream_packet;\n\tstruct fw_cdev_get_cycle_timer2\t\tget_cycle_timer2;\n\tstruct fw_cdev_send_phy_packet\t\tsend_phy_packet;\n\tstruct fw_cdev_receive_phy_packets\treceive_phy_packets;\n\tstruct fw_cdev_set_iso_channels\t\tset_iso_channels;\n\tstruct fw_cdev_flush_iso\t\tflush_iso;\n};\n\nstatic int ioctl_get_info(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_get_info *a = &arg->get_info;\n\tstruct fw_cdev_event_bus_reset bus_reset;\n\tunsigned long ret = 0;\n\n\tclient->version = a->version;\n\ta->version = FW_CDEV_KERNEL_VERSION;\n\ta->card = client->device->card->index;\n\n\tdown_read(&fw_device_rwsem);\n\n\tif (a->rom != 0) {\n\t\tsize_t want = a->rom_length;\n\t\tsize_t have = client->device->config_rom_length * 4;\n\n\t\tret = copy_to_user(u64_to_uptr(a->rom),\n\t\t\t\t   client->device->config_rom, min(want, have));\n\t}\n\ta->rom_length = client->device->config_rom_length * 4;\n\n\tup_read(&fw_device_rwsem);\n\n\tif (ret != 0)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&client->device->client_list_mutex);\n\n\tclient->bus_reset_closure = a->bus_reset_closure;\n\tif (a->bus_reset != 0) {\n\t\tfill_bus_reset_event(&bus_reset, client);\n\t\t \n\t\tret = copy_to_user(u64_to_uptr(a->bus_reset), &bus_reset, 36);\n\t}\n\tif (ret == 0 && list_empty(&client->link))\n\t\tlist_add_tail(&client->link, &client->device->client_list);\n\n\tmutex_unlock(&client->device->client_list_mutex);\n\n\treturn ret ? -EFAULT : 0;\n}\n\nstatic int add_client_resource(struct client *client,\n\t\t\t       struct client_resource *resource, gfp_t gfp_mask)\n{\n\tbool preload = gfpflags_allow_blocking(gfp_mask);\n\tunsigned long flags;\n\tint ret;\n\n\tif (preload)\n\t\tidr_preload(gfp_mask);\n\tspin_lock_irqsave(&client->lock, flags);\n\n\tif (client->in_shutdown)\n\t\tret = -ECANCELED;\n\telse\n\t\tret = idr_alloc(&client->resource_idr, resource, 0, 0,\n\t\t\t\tGFP_NOWAIT);\n\tif (ret >= 0) {\n\t\tresource->handle = ret;\n\t\tclient_get(client);\n\t\tschedule_if_iso_resource(resource);\n\t}\n\n\tspin_unlock_irqrestore(&client->lock, flags);\n\tif (preload)\n\t\tidr_preload_end();\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int release_client_resource(struct client *client, u32 handle,\n\t\t\t\t   client_resource_release_fn_t release,\n\t\t\t\t   struct client_resource **return_resource)\n{\n\tstruct client_resource *resource;\n\n\tspin_lock_irq(&client->lock);\n\tif (client->in_shutdown)\n\t\tresource = NULL;\n\telse\n\t\tresource = idr_find(&client->resource_idr, handle);\n\tif (resource && resource->release == release)\n\t\tidr_remove(&client->resource_idr, handle);\n\tspin_unlock_irq(&client->lock);\n\n\tif (!(resource && resource->release == release))\n\t\treturn -EINVAL;\n\n\tif (return_resource)\n\t\t*return_resource = resource;\n\telse\n\t\tresource->release(client, resource);\n\n\tclient_put(client);\n\n\treturn 0;\n}\n\nstatic void release_transaction(struct client *client,\n\t\t\t\tstruct client_resource *resource)\n{\n}\n\nstatic void complete_transaction(struct fw_card *card, int rcode, u32 request_tstamp,\n\t\t\t\t u32 response_tstamp, void *payload, size_t length, void *data)\n{\n\tstruct outbound_transaction_event *e = data;\n\tstruct client *client = e->client;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&client->lock, flags);\n\tidr_remove(&client->resource_idr, e->r.resource.handle);\n\tif (client->in_shutdown)\n\t\twake_up(&client->tx_flush_wait);\n\tspin_unlock_irqrestore(&client->lock, flags);\n\n\tswitch (e->rsp.without_tstamp.type) {\n\tcase FW_CDEV_EVENT_RESPONSE:\n\t{\n\t\tstruct fw_cdev_event_response *rsp = &e->rsp.without_tstamp;\n\n\t\tif (length < rsp->length)\n\t\t\trsp->length = length;\n\t\tif (rcode == RCODE_COMPLETE)\n\t\t\tmemcpy(rsp->data, payload, rsp->length);\n\n\t\trsp->rcode = rcode;\n\n\t\t \n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (rsp->length <= sizeof(*rsp) - offsetof(typeof(*rsp), data))\n\t\t\tqueue_event(client, &e->event, rsp, sizeof(*rsp), rsp->data, rsp->length);\n\t\telse\n\t\t\tqueue_event(client, &e->event, rsp, sizeof(*rsp) + rsp->length, NULL, 0);\n\n\t\tbreak;\n\t}\n\tcase FW_CDEV_EVENT_RESPONSE2:\n\t{\n\t\tstruct fw_cdev_event_response2 *rsp = &e->rsp.with_tstamp;\n\n\t\tif (length < rsp->length)\n\t\t\trsp->length = length;\n\t\tif (rcode == RCODE_COMPLETE)\n\t\t\tmemcpy(rsp->data, payload, rsp->length);\n\n\t\trsp->rcode = rcode;\n\t\trsp->request_tstamp = request_tstamp;\n\t\trsp->response_tstamp = response_tstamp;\n\n\t\tqueue_event(client, &e->event, rsp, sizeof(*rsp) + rsp->length, NULL, 0);\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\t}\n\n\t \n\tclient_put(client);\n}\n\nstatic int init_request(struct client *client,\n\t\t\tstruct fw_cdev_send_request *request,\n\t\t\tint destination_id, int speed)\n{\n\tstruct outbound_transaction_event *e;\n\tvoid *payload;\n\tint ret;\n\n\tif (request->tcode != TCODE_STREAM_DATA &&\n\t    (request->length > 4096 || request->length > 512 << speed))\n\t\treturn -EIO;\n\n\tif (request->tcode == TCODE_WRITE_QUADLET_REQUEST &&\n\t    request->length < 4)\n\t\treturn -EINVAL;\n\n\te = kmalloc(sizeof(*e) + request->length, GFP_KERNEL);\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\te->client = client;\n\n\tif (client->version < FW_CDEV_VERSION_EVENT_ASYNC_TSTAMP) {\n\t\tstruct fw_cdev_event_response *rsp = &e->rsp.without_tstamp;\n\n\t\trsp->type = FW_CDEV_EVENT_RESPONSE;\n\t\trsp->length = request->length;\n\t\trsp->closure = request->closure;\n\t\tpayload = rsp->data;\n\t} else {\n\t\tstruct fw_cdev_event_response2 *rsp = &e->rsp.with_tstamp;\n\n\t\trsp->type = FW_CDEV_EVENT_RESPONSE2;\n\t\trsp->length = request->length;\n\t\trsp->closure = request->closure;\n\t\tpayload = rsp->data;\n\t}\n\n\tif (request->data && copy_from_user(payload, u64_to_uptr(request->data), request->length)) {\n\t\tret = -EFAULT;\n\t\tgoto failed;\n\t}\n\n\te->r.resource.release = release_transaction;\n\tret = add_client_resource(client, &e->r.resource, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tfw_send_request_with_tstamp(client->device->card, &e->r.transaction, request->tcode,\n\t\t\t\t    destination_id, request->generation, speed, request->offset,\n\t\t\t\t    payload, request->length, complete_transaction, e);\n\treturn 0;\n\n failed:\n\tkfree(e);\n\n\treturn ret;\n}\n\nstatic int ioctl_send_request(struct client *client, union ioctl_arg *arg)\n{\n\tswitch (arg->send_request.tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\tcase TCODE_READ_QUADLET_REQUEST:\n\tcase TCODE_READ_BLOCK_REQUEST:\n\tcase TCODE_LOCK_MASK_SWAP:\n\tcase TCODE_LOCK_COMPARE_SWAP:\n\tcase TCODE_LOCK_FETCH_ADD:\n\tcase TCODE_LOCK_LITTLE_ADD:\n\tcase TCODE_LOCK_BOUNDED_ADD:\n\tcase TCODE_LOCK_WRAP_ADD:\n\tcase TCODE_LOCK_VENDOR_DEPENDENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn init_request(client, &arg->send_request, client->device->node_id,\n\t\t\t    client->device->max_speed);\n}\n\nstatic void release_request(struct client *client,\n\t\t\t    struct client_resource *resource)\n{\n\tstruct inbound_transaction_resource *r = container_of(resource,\n\t\t\tstruct inbound_transaction_resource, resource);\n\n\tif (r->is_fcp)\n\t\tfw_request_put(r->request);\n\telse\n\t\tfw_send_response(r->card, r->request, RCODE_CONFLICT_ERROR);\n\n\tfw_card_put(r->card);\n\tkfree(r);\n}\n\nstatic void handle_request(struct fw_card *card, struct fw_request *request,\n\t\t\t   int tcode, int destination, int source,\n\t\t\t   int generation, unsigned long long offset,\n\t\t\t   void *payload, size_t length, void *callback_data)\n{\n\tstruct address_handler_resource *handler = callback_data;\n\tbool is_fcp = is_in_fcp_region(offset, length);\n\tstruct inbound_transaction_resource *r;\n\tstruct inbound_transaction_event *e;\n\tsize_t event_size0;\n\tint ret;\n\n\t \n\tfw_card_get(card);\n\n\t \n\t \n\tif (is_fcp)\n\t\tfw_request_get(request);\n\n\tr = kmalloc(sizeof(*r), GFP_ATOMIC);\n\te = kmalloc(sizeof(*e), GFP_ATOMIC);\n\tif (r == NULL || e == NULL)\n\t\tgoto failed;\n\n\tr->card    = card;\n\tr->request = request;\n\tr->is_fcp  = is_fcp;\n\tr->data    = payload;\n\tr->length  = length;\n\n\tr->resource.release = release_request;\n\tret = add_client_resource(handler->client, &r->resource, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tif (handler->client->version < FW_CDEV_VERSION_EVENT_REQUEST2) {\n\t\tstruct fw_cdev_event_request *req = &e->req.request;\n\n\t\tif (tcode & 0x10)\n\t\t\ttcode = TCODE_LOCK_REQUEST;\n\n\t\treq->type\t= FW_CDEV_EVENT_REQUEST;\n\t\treq->tcode\t= tcode;\n\t\treq->offset\t= offset;\n\t\treq->length\t= length;\n\t\treq->handle\t= r->resource.handle;\n\t\treq->closure\t= handler->closure;\n\t\tevent_size0\t= sizeof(*req);\n\t} else if (handler->client->version < FW_CDEV_VERSION_EVENT_ASYNC_TSTAMP) {\n\t\tstruct fw_cdev_event_request2 *req = &e->req.request2;\n\n\t\treq->type\t= FW_CDEV_EVENT_REQUEST2;\n\t\treq->tcode\t= tcode;\n\t\treq->offset\t= offset;\n\t\treq->source_node_id = source;\n\t\treq->destination_node_id = destination;\n\t\treq->card\t= card->index;\n\t\treq->generation\t= generation;\n\t\treq->length\t= length;\n\t\treq->handle\t= r->resource.handle;\n\t\treq->closure\t= handler->closure;\n\t\tevent_size0\t= sizeof(*req);\n\t} else {\n\t\tstruct fw_cdev_event_request3 *req = &e->req.with_tstamp;\n\n\t\treq->type\t= FW_CDEV_EVENT_REQUEST3;\n\t\treq->tcode\t= tcode;\n\t\treq->offset\t= offset;\n\t\treq->source_node_id = source;\n\t\treq->destination_node_id = destination;\n\t\treq->card\t= card->index;\n\t\treq->generation\t= generation;\n\t\treq->length\t= length;\n\t\treq->handle\t= r->resource.handle;\n\t\treq->closure\t= handler->closure;\n\t\treq->tstamp\t= fw_request_get_timestamp(request);\n\t\tevent_size0\t= sizeof(*req);\n\t}\n\n\tqueue_event(handler->client, &e->event,\n\t\t    &e->req, event_size0, r->data, length);\n\treturn;\n\n failed:\n\tkfree(r);\n\tkfree(e);\n\n\tif (!is_fcp)\n\t\tfw_send_response(card, request, RCODE_CONFLICT_ERROR);\n\telse\n\t\tfw_request_put(request);\n\n\tfw_card_put(card);\n}\n\nstatic void release_address_handler(struct client *client,\n\t\t\t\t    struct client_resource *resource)\n{\n\tstruct address_handler_resource *r =\n\t    container_of(resource, struct address_handler_resource, resource);\n\n\tfw_core_remove_address_handler(&r->handler);\n\tkfree(r);\n}\n\nstatic int ioctl_allocate(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_allocate *a = &arg->allocate;\n\tstruct address_handler_resource *r;\n\tstruct fw_address_region region;\n\tint ret;\n\n\tr = kmalloc(sizeof(*r), GFP_KERNEL);\n\tif (r == NULL)\n\t\treturn -ENOMEM;\n\n\tregion.start = a->offset;\n\tif (client->version < FW_CDEV_VERSION_ALLOCATE_REGION_END)\n\t\tregion.end = a->offset + a->length;\n\telse\n\t\tregion.end = a->region_end;\n\n\tr->handler.length           = a->length;\n\tr->handler.address_callback = handle_request;\n\tr->handler.callback_data    = r;\n\tr->closure   = a->closure;\n\tr->client    = client;\n\n\tret = fw_core_add_address_handler(&r->handler, &region);\n\tif (ret < 0) {\n\t\tkfree(r);\n\t\treturn ret;\n\t}\n\ta->offset = r->handler.offset;\n\n\tr->resource.release = release_address_handler;\n\tret = add_client_resource(client, &r->resource, GFP_KERNEL);\n\tif (ret < 0) {\n\t\trelease_address_handler(client, &r->resource);\n\t\treturn ret;\n\t}\n\ta->handle = r->resource.handle;\n\n\treturn 0;\n}\n\nstatic int ioctl_deallocate(struct client *client, union ioctl_arg *arg)\n{\n\treturn release_client_resource(client, arg->deallocate.handle,\n\t\t\t\t       release_address_handler, NULL);\n}\n\nstatic int ioctl_send_response(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_send_response *a = &arg->send_response;\n\tstruct client_resource *resource;\n\tstruct inbound_transaction_resource *r;\n\tint ret = 0;\n\n\tif (release_client_resource(client, a->handle,\n\t\t\t\t    release_request, &resource) < 0)\n\t\treturn -EINVAL;\n\n\tr = container_of(resource, struct inbound_transaction_resource,\n\t\t\t resource);\n\tif (r->is_fcp) {\n\t\tfw_request_put(r->request);\n\t\tgoto out;\n\t}\n\n\tif (a->length != fw_get_response_length(r->request)) {\n\t\tret = -EINVAL;\n\t\tfw_request_put(r->request);\n\t\tgoto out;\n\t}\n\tif (copy_from_user(r->data, u64_to_uptr(a->data), a->length)) {\n\t\tret = -EFAULT;\n\t\tfw_request_put(r->request);\n\t\tgoto out;\n\t}\n\tfw_send_response(r->card, r->request, a->rcode);\n out:\n\tfw_card_put(r->card);\n\tkfree(r);\n\n\treturn ret;\n}\n\nstatic int ioctl_initiate_bus_reset(struct client *client, union ioctl_arg *arg)\n{\n\tfw_schedule_bus_reset(client->device->card, true,\n\t\t\targ->initiate_bus_reset.type == FW_CDEV_SHORT_RESET);\n\treturn 0;\n}\n\nstatic void release_descriptor(struct client *client,\n\t\t\t       struct client_resource *resource)\n{\n\tstruct descriptor_resource *r =\n\t\tcontainer_of(resource, struct descriptor_resource, resource);\n\n\tfw_core_remove_descriptor(&r->descriptor);\n\tkfree(r);\n}\n\nstatic int ioctl_add_descriptor(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_add_descriptor *a = &arg->add_descriptor;\n\tstruct descriptor_resource *r;\n\tint ret;\n\n\t \n\tif (!client->device->is_local)\n\t\treturn -ENOSYS;\n\n\tif (a->length > 256)\n\t\treturn -EINVAL;\n\n\tr = kmalloc(sizeof(*r) + a->length * 4, GFP_KERNEL);\n\tif (r == NULL)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(r->data, u64_to_uptr(a->data), a->length * 4)) {\n\t\tret = -EFAULT;\n\t\tgoto failed;\n\t}\n\n\tr->descriptor.length    = a->length;\n\tr->descriptor.immediate = a->immediate;\n\tr->descriptor.key       = a->key;\n\tr->descriptor.data      = r->data;\n\n\tret = fw_core_add_descriptor(&r->descriptor);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tr->resource.release = release_descriptor;\n\tret = add_client_resource(client, &r->resource, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tfw_core_remove_descriptor(&r->descriptor);\n\t\tgoto failed;\n\t}\n\ta->handle = r->resource.handle;\n\n\treturn 0;\n failed:\n\tkfree(r);\n\n\treturn ret;\n}\n\nstatic int ioctl_remove_descriptor(struct client *client, union ioctl_arg *arg)\n{\n\treturn release_client_resource(client, arg->remove_descriptor.handle,\n\t\t\t\t       release_descriptor, NULL);\n}\n\nstatic void iso_callback(struct fw_iso_context *context, u32 cycle,\n\t\t\t size_t header_length, void *header, void *data)\n{\n\tstruct client *client = data;\n\tstruct iso_interrupt_event *e;\n\n\te = kmalloc(sizeof(*e) + header_length, GFP_ATOMIC);\n\tif (e == NULL)\n\t\treturn;\n\n\te->interrupt.type      = FW_CDEV_EVENT_ISO_INTERRUPT;\n\te->interrupt.closure   = client->iso_closure;\n\te->interrupt.cycle     = cycle;\n\te->interrupt.header_length = header_length;\n\tmemcpy(e->interrupt.header, header, header_length);\n\tqueue_event(client, &e->event, &e->interrupt,\n\t\t    sizeof(e->interrupt) + header_length, NULL, 0);\n}\n\nstatic void iso_mc_callback(struct fw_iso_context *context,\n\t\t\t    dma_addr_t completed, void *data)\n{\n\tstruct client *client = data;\n\tstruct iso_interrupt_mc_event *e;\n\n\te = kmalloc(sizeof(*e), GFP_ATOMIC);\n\tif (e == NULL)\n\t\treturn;\n\n\te->interrupt.type      = FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL;\n\te->interrupt.closure   = client->iso_closure;\n\te->interrupt.completed = fw_iso_buffer_lookup(&client->buffer,\n\t\t\t\t\t\t      completed);\n\tqueue_event(client, &e->event, &e->interrupt,\n\t\t    sizeof(e->interrupt), NULL, 0);\n}\n\nstatic enum dma_data_direction iso_dma_direction(struct fw_iso_context *context)\n{\n\t\tif (context->type == FW_ISO_CONTEXT_TRANSMIT)\n\t\t\treturn DMA_TO_DEVICE;\n\t\telse\n\t\t\treturn DMA_FROM_DEVICE;\n}\n\nstatic struct fw_iso_context *fw_iso_mc_context_create(struct fw_card *card,\n\t\t\t\t\t\tfw_iso_mc_callback_t callback,\n\t\t\t\t\t\tvoid *callback_data)\n{\n\tstruct fw_iso_context *ctx;\n\n\tctx = fw_iso_context_create(card, FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL,\n\t\t\t\t    0, 0, 0, NULL, callback_data);\n\tif (!IS_ERR(ctx))\n\t\tctx->callback.mc = callback;\n\n\treturn ctx;\n}\n\nstatic int ioctl_create_iso_context(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_create_iso_context *a = &arg->create_iso_context;\n\tstruct fw_iso_context *context;\n\tunion fw_iso_callback cb;\n\tint ret;\n\n\tBUILD_BUG_ON(FW_CDEV_ISO_CONTEXT_TRANSMIT != FW_ISO_CONTEXT_TRANSMIT ||\n\t\t     FW_CDEV_ISO_CONTEXT_RECEIVE  != FW_ISO_CONTEXT_RECEIVE  ||\n\t\t     FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL !=\n\t\t\t\t\tFW_ISO_CONTEXT_RECEIVE_MULTICHANNEL);\n\n\tswitch (a->type) {\n\tcase FW_ISO_CONTEXT_TRANSMIT:\n\t\tif (a->speed > SCODE_3200 || a->channel > 63)\n\t\t\treturn -EINVAL;\n\n\t\tcb.sc = iso_callback;\n\t\tbreak;\n\n\tcase FW_ISO_CONTEXT_RECEIVE:\n\t\tif (a->header_size < 4 || (a->header_size & 3) ||\n\t\t    a->channel > 63)\n\t\t\treturn -EINVAL;\n\n\t\tcb.sc = iso_callback;\n\t\tbreak;\n\n\tcase FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL:\n\t\tcb.mc = iso_mc_callback;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (a->type == FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL)\n\t\tcontext = fw_iso_mc_context_create(client->device->card, cb.mc,\n\t\t\t\t\t\t   client);\n\telse\n\t\tcontext = fw_iso_context_create(client->device->card, a->type,\n\t\t\t\t\t\ta->channel, a->speed,\n\t\t\t\t\t\ta->header_size, cb.sc, client);\n\tif (IS_ERR(context))\n\t\treturn PTR_ERR(context);\n\tif (client->version < FW_CDEV_VERSION_AUTO_FLUSH_ISO_OVERFLOW)\n\t\tcontext->drop_overflow_headers = true;\n\n\t \n\tspin_lock_irq(&client->lock);\n\tif (client->iso_context != NULL) {\n\t\tspin_unlock_irq(&client->lock);\n\t\tfw_iso_context_destroy(context);\n\n\t\treturn -EBUSY;\n\t}\n\tif (!client->buffer_is_mapped) {\n\t\tret = fw_iso_buffer_map_dma(&client->buffer,\n\t\t\t\t\t    client->device->card,\n\t\t\t\t\t    iso_dma_direction(context));\n\t\tif (ret < 0) {\n\t\t\tspin_unlock_irq(&client->lock);\n\t\t\tfw_iso_context_destroy(context);\n\n\t\t\treturn ret;\n\t\t}\n\t\tclient->buffer_is_mapped = true;\n\t}\n\tclient->iso_closure = a->closure;\n\tclient->iso_context = context;\n\tspin_unlock_irq(&client->lock);\n\n\ta->handle = 0;\n\n\treturn 0;\n}\n\nstatic int ioctl_set_iso_channels(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_set_iso_channels *a = &arg->set_iso_channels;\n\tstruct fw_iso_context *ctx = client->iso_context;\n\n\tif (ctx == NULL || a->handle != 0)\n\t\treturn -EINVAL;\n\n\treturn fw_iso_context_set_channels(ctx, &a->channels);\n}\n\n \n#define GET_PAYLOAD_LENGTH(v)\t((v) & 0xffff)\n#define GET_INTERRUPT(v)\t(((v) >> 16) & 0x01)\n#define GET_SKIP(v)\t\t(((v) >> 17) & 0x01)\n#define GET_TAG(v)\t\t(((v) >> 18) & 0x03)\n#define GET_SY(v)\t\t(((v) >> 20) & 0x0f)\n#define GET_HEADER_LENGTH(v)\t(((v) >> 24) & 0xff)\n\nstatic int ioctl_queue_iso(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_queue_iso *a = &arg->queue_iso;\n\tstruct fw_cdev_iso_packet __user *p, *end, *next;\n\tstruct fw_iso_context *ctx = client->iso_context;\n\tunsigned long payload, buffer_end, transmit_header_bytes = 0;\n\tu32 control;\n\tint count;\n\tstruct {\n\t\tstruct fw_iso_packet packet;\n\t\tu8 header[256];\n\t} u;\n\n\tif (ctx == NULL || a->handle != 0)\n\t\treturn -EINVAL;\n\n\t \n\tpayload = (unsigned long)a->data - client->vm_start;\n\tbuffer_end = client->buffer.page_count << PAGE_SHIFT;\n\tif (a->data == 0 || client->buffer.pages == NULL ||\n\t    payload >= buffer_end) {\n\t\tpayload = 0;\n\t\tbuffer_end = 0;\n\t}\n\n\tif (ctx->type == FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL && payload & 3)\n\t\treturn -EINVAL;\n\n\tp = (struct fw_cdev_iso_packet __user *)u64_to_uptr(a->packets);\n\n\tend = (void __user *)p + a->size;\n\tcount = 0;\n\twhile (p < end) {\n\t\tif (get_user(control, &p->control))\n\t\t\treturn -EFAULT;\n\t\tu.packet.payload_length = GET_PAYLOAD_LENGTH(control);\n\t\tu.packet.interrupt = GET_INTERRUPT(control);\n\t\tu.packet.skip = GET_SKIP(control);\n\t\tu.packet.tag = GET_TAG(control);\n\t\tu.packet.sy = GET_SY(control);\n\t\tu.packet.header_length = GET_HEADER_LENGTH(control);\n\n\t\tswitch (ctx->type) {\n\t\tcase FW_ISO_CONTEXT_TRANSMIT:\n\t\t\tif (u.packet.header_length & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\ttransmit_header_bytes = u.packet.header_length;\n\t\t\tbreak;\n\n\t\tcase FW_ISO_CONTEXT_RECEIVE:\n\t\t\tif (u.packet.header_length == 0 ||\n\t\t\t    u.packet.header_length % ctx->header_size != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL:\n\t\t\tif (u.packet.payload_length == 0 ||\n\t\t\t    u.packet.payload_length & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext = (struct fw_cdev_iso_packet __user *)\n\t\t\t&p->header[transmit_header_bytes / 4];\n\t\tif (next > end)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user\n\t\t    (u.packet.header, p->header, transmit_header_bytes))\n\t\t\treturn -EFAULT;\n\t\tif (u.packet.skip && ctx->type == FW_ISO_CONTEXT_TRANSMIT &&\n\t\t    u.packet.header_length + u.packet.payload_length > 0)\n\t\t\treturn -EINVAL;\n\t\tif (payload + u.packet.payload_length > buffer_end)\n\t\t\treturn -EINVAL;\n\n\t\tif (fw_iso_context_queue(ctx, &u.packet,\n\t\t\t\t\t &client->buffer, payload))\n\t\t\tbreak;\n\n\t\tp = next;\n\t\tpayload += u.packet.payload_length;\n\t\tcount++;\n\t}\n\tfw_iso_context_queue_flush(ctx);\n\n\ta->size    -= uptr_to_u64(p) - a->packets;\n\ta->packets  = uptr_to_u64(p);\n\ta->data     = client->vm_start + payload;\n\n\treturn count;\n}\n\nstatic int ioctl_start_iso(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_start_iso *a = &arg->start_iso;\n\n\tBUILD_BUG_ON(\n\t    FW_CDEV_ISO_CONTEXT_MATCH_TAG0 != FW_ISO_CONTEXT_MATCH_TAG0 ||\n\t    FW_CDEV_ISO_CONTEXT_MATCH_TAG1 != FW_ISO_CONTEXT_MATCH_TAG1 ||\n\t    FW_CDEV_ISO_CONTEXT_MATCH_TAG2 != FW_ISO_CONTEXT_MATCH_TAG2 ||\n\t    FW_CDEV_ISO_CONTEXT_MATCH_TAG3 != FW_ISO_CONTEXT_MATCH_TAG3 ||\n\t    FW_CDEV_ISO_CONTEXT_MATCH_ALL_TAGS != FW_ISO_CONTEXT_MATCH_ALL_TAGS);\n\n\tif (client->iso_context == NULL || a->handle != 0)\n\t\treturn -EINVAL;\n\n\tif (client->iso_context->type == FW_ISO_CONTEXT_RECEIVE &&\n\t    (a->tags == 0 || a->tags > 15 || a->sync > 15))\n\t\treturn -EINVAL;\n\n\treturn fw_iso_context_start(client->iso_context,\n\t\t\t\t    a->cycle, a->sync, a->tags);\n}\n\nstatic int ioctl_stop_iso(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_stop_iso *a = &arg->stop_iso;\n\n\tif (client->iso_context == NULL || a->handle != 0)\n\t\treturn -EINVAL;\n\n\treturn fw_iso_context_stop(client->iso_context);\n}\n\nstatic int ioctl_flush_iso(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_flush_iso *a = &arg->flush_iso;\n\n\tif (client->iso_context == NULL || a->handle != 0)\n\t\treturn -EINVAL;\n\n\treturn fw_iso_context_flush_completions(client->iso_context);\n}\n\nstatic int ioctl_get_cycle_timer2(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_get_cycle_timer2 *a = &arg->get_cycle_timer2;\n\tstruct fw_card *card = client->device->card;\n\tstruct timespec64 ts = {0, 0};\n\tu32 cycle_time = 0;\n\tint ret = 0;\n\n\tlocal_irq_disable();\n\n\tret = fw_card_read_cycle_time(card, &cycle_time);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tswitch (a->clk_id) {\n\tcase CLOCK_REALTIME:      ktime_get_real_ts64(&ts);\tbreak;\n\tcase CLOCK_MONOTONIC:     ktime_get_ts64(&ts);\t\tbreak;\n\tcase CLOCK_MONOTONIC_RAW: ktime_get_raw_ts64(&ts);\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nend:\n\tlocal_irq_enable();\n\n\ta->tv_sec      = ts.tv_sec;\n\ta->tv_nsec     = ts.tv_nsec;\n\ta->cycle_timer = cycle_time;\n\n\treturn ret;\n}\n\nstatic int ioctl_get_cycle_timer(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_get_cycle_timer *a = &arg->get_cycle_timer;\n\tstruct fw_cdev_get_cycle_timer2 ct2;\n\n\tct2.clk_id = CLOCK_REALTIME;\n\tioctl_get_cycle_timer2(client, (union ioctl_arg *)&ct2);\n\n\ta->local_time = ct2.tv_sec * USEC_PER_SEC + ct2.tv_nsec / NSEC_PER_USEC;\n\ta->cycle_timer = ct2.cycle_timer;\n\n\treturn 0;\n}\n\nstatic void iso_resource_work(struct work_struct *work)\n{\n\tstruct iso_resource_event *e;\n\tstruct iso_resource *r =\n\t\t\tcontainer_of(work, struct iso_resource, work.work);\n\tstruct client *client = r->client;\n\tint generation, channel, bandwidth, todo;\n\tbool skip, free, success;\n\n\tspin_lock_irq(&client->lock);\n\tgeneration = client->device->generation;\n\ttodo = r->todo;\n\t \n\tif (todo == ISO_RES_ALLOC &&\n\t    time_before64(get_jiffies_64(),\n\t\t\t  client->device->card->reset_jiffies + HZ)) {\n\t\tschedule_iso_resource(r, DIV_ROUND_UP(HZ, 3));\n\t\tskip = true;\n\t} else {\n\t\t \n\t\tskip = todo == ISO_RES_REALLOC &&\n\t\t       r->generation == generation;\n\t}\n\tfree = todo == ISO_RES_DEALLOC ||\n\t       todo == ISO_RES_ALLOC_ONCE ||\n\t       todo == ISO_RES_DEALLOC_ONCE;\n\tr->generation = generation;\n\tspin_unlock_irq(&client->lock);\n\n\tif (skip)\n\t\tgoto out;\n\n\tbandwidth = r->bandwidth;\n\n\tfw_iso_resource_manage(client->device->card, generation,\n\t\t\tr->channels, &channel, &bandwidth,\n\t\t\ttodo == ISO_RES_ALLOC ||\n\t\t\ttodo == ISO_RES_REALLOC ||\n\t\t\ttodo == ISO_RES_ALLOC_ONCE);\n\t \n\tif (channel == -EAGAIN &&\n\t    (todo == ISO_RES_ALLOC || todo == ISO_RES_REALLOC))\n\t\tgoto out;\n\n\tsuccess = channel >= 0 || bandwidth > 0;\n\n\tspin_lock_irq(&client->lock);\n\t \n\tif (r->todo == ISO_RES_ALLOC)\n\t\tr->todo = ISO_RES_REALLOC;\n\t \n\tif (r->todo == ISO_RES_REALLOC && !success &&\n\t    !client->in_shutdown &&\n\t    idr_remove(&client->resource_idr, r->resource.handle)) {\n\t\tclient_put(client);\n\t\tfree = true;\n\t}\n\tspin_unlock_irq(&client->lock);\n\n\tif (todo == ISO_RES_ALLOC && channel >= 0)\n\t\tr->channels = 1ULL << channel;\n\n\tif (todo == ISO_RES_REALLOC && success)\n\t\tgoto out;\n\n\tif (todo == ISO_RES_ALLOC || todo == ISO_RES_ALLOC_ONCE) {\n\t\te = r->e_alloc;\n\t\tr->e_alloc = NULL;\n\t} else {\n\t\te = r->e_dealloc;\n\t\tr->e_dealloc = NULL;\n\t}\n\te->iso_resource.handle    = r->resource.handle;\n\te->iso_resource.channel   = channel;\n\te->iso_resource.bandwidth = bandwidth;\n\n\tqueue_event(client, &e->event,\n\t\t    &e->iso_resource, sizeof(e->iso_resource), NULL, 0);\n\n\tif (free) {\n\t\tcancel_delayed_work(&r->work);\n\t\tkfree(r->e_alloc);\n\t\tkfree(r->e_dealloc);\n\t\tkfree(r);\n\t}\n out:\n\tclient_put(client);\n}\n\nstatic void release_iso_resource(struct client *client,\n\t\t\t\t struct client_resource *resource)\n{\n\tstruct iso_resource *r =\n\t\tcontainer_of(resource, struct iso_resource, resource);\n\n\tspin_lock_irq(&client->lock);\n\tr->todo = ISO_RES_DEALLOC;\n\tschedule_iso_resource(r, 0);\n\tspin_unlock_irq(&client->lock);\n}\n\nstatic int init_iso_resource(struct client *client,\n\t\tstruct fw_cdev_allocate_iso_resource *request, int todo)\n{\n\tstruct iso_resource_event *e1, *e2;\n\tstruct iso_resource *r;\n\tint ret;\n\n\tif ((request->channels == 0 && request->bandwidth == 0) ||\n\t    request->bandwidth > BANDWIDTH_AVAILABLE_INITIAL)\n\t\treturn -EINVAL;\n\n\tr  = kmalloc(sizeof(*r), GFP_KERNEL);\n\te1 = kmalloc(sizeof(*e1), GFP_KERNEL);\n\te2 = kmalloc(sizeof(*e2), GFP_KERNEL);\n\tif (r == NULL || e1 == NULL || e2 == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tINIT_DELAYED_WORK(&r->work, iso_resource_work);\n\tr->client\t= client;\n\tr->todo\t\t= todo;\n\tr->generation\t= -1;\n\tr->channels\t= request->channels;\n\tr->bandwidth\t= request->bandwidth;\n\tr->e_alloc\t= e1;\n\tr->e_dealloc\t= e2;\n\n\te1->iso_resource.closure = request->closure;\n\te1->iso_resource.type    = FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED;\n\te2->iso_resource.closure = request->closure;\n\te2->iso_resource.type    = FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED;\n\n\tif (todo == ISO_RES_ALLOC) {\n\t\tr->resource.release = release_iso_resource;\n\t\tret = add_client_resource(client, &r->resource, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tr->resource.release = NULL;\n\t\tr->resource.handle = -1;\n\t\tschedule_iso_resource(r, 0);\n\t}\n\trequest->handle = r->resource.handle;\n\n\treturn 0;\n fail:\n\tkfree(r);\n\tkfree(e1);\n\tkfree(e2);\n\n\treturn ret;\n}\n\nstatic int ioctl_allocate_iso_resource(struct client *client,\n\t\t\t\t       union ioctl_arg *arg)\n{\n\treturn init_iso_resource(client,\n\t\t\t&arg->allocate_iso_resource, ISO_RES_ALLOC);\n}\n\nstatic int ioctl_deallocate_iso_resource(struct client *client,\n\t\t\t\t\t union ioctl_arg *arg)\n{\n\treturn release_client_resource(client,\n\t\t\targ->deallocate.handle, release_iso_resource, NULL);\n}\n\nstatic int ioctl_allocate_iso_resource_once(struct client *client,\n\t\t\t\t\t    union ioctl_arg *arg)\n{\n\treturn init_iso_resource(client,\n\t\t\t&arg->allocate_iso_resource, ISO_RES_ALLOC_ONCE);\n}\n\nstatic int ioctl_deallocate_iso_resource_once(struct client *client,\n\t\t\t\t\t      union ioctl_arg *arg)\n{\n\treturn init_iso_resource(client,\n\t\t\t&arg->allocate_iso_resource, ISO_RES_DEALLOC_ONCE);\n}\n\n \nstatic int ioctl_get_speed(struct client *client, union ioctl_arg *arg)\n{\n\treturn client->device->max_speed;\n}\n\nstatic int ioctl_send_broadcast_request(struct client *client,\n\t\t\t\t\tunion ioctl_arg *arg)\n{\n\tstruct fw_cdev_send_request *a = &arg->send_request;\n\n\tswitch (a->tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (a->offset < CSR_REGISTER_BASE + CSR_CONFIG_ROM_END)\n\t\treturn -EACCES;\n\n\treturn init_request(client, a, LOCAL_BUS | 0x3f, SCODE_100);\n}\n\nstatic int ioctl_send_stream_packet(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_send_stream_packet *a = &arg->send_stream_packet;\n\tstruct fw_cdev_send_request request;\n\tint dest;\n\n\tif (a->speed > client->device->card->link_speed ||\n\t    a->length > 1024 << a->speed)\n\t\treturn -EIO;\n\n\tif (a->tag > 3 || a->channel > 63 || a->sy > 15)\n\t\treturn -EINVAL;\n\n\tdest = fw_stream_packet_destination_id(a->tag, a->channel, a->sy);\n\trequest.tcode\t\t= TCODE_STREAM_DATA;\n\trequest.length\t\t= a->length;\n\trequest.closure\t\t= a->closure;\n\trequest.data\t\t= a->data;\n\trequest.generation\t= a->generation;\n\n\treturn init_request(client, &request, dest, a->speed);\n}\n\nstatic void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tstruct client *e_client = e->client;\n\tu32 rcode;\n\n\tswitch (status) {\n\t \n\tcase ACK_COMPLETE:\n\t\trcode = RCODE_COMPLETE;\n\t\tbreak;\n\t \n\tcase ACK_PENDING:\n\t\trcode = RCODE_COMPLETE;\n\t\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\n\t\trcode = RCODE_BUSY;\n\t\tbreak;\n\tcase ACK_DATA_ERROR:\n\t\trcode = RCODE_DATA_ERROR;\n\t\tbreak;\n\tcase ACK_TYPE_ERROR:\n\t\trcode = RCODE_TYPE_ERROR;\n\t\tbreak;\n\t \n\tdefault:\n\t\trcode = status;\n\t\tbreak;\n\t}\n\n\tswitch (e->phy_packet.without_tstamp.type) {\n\tcase FW_CDEV_EVENT_PHY_PACKET_SENT:\n\t{\n\t\tstruct fw_cdev_event_phy_packet *pp = &e->phy_packet.without_tstamp;\n\n\t\tpp->rcode = rcode;\n\t\tpp->data[0] = packet->timestamp;\n\t\tqueue_event(e->client, &e->event, &e->phy_packet, sizeof(*pp) + pp->length,\n\t\t\t    NULL, 0);\n\t\tbreak;\n\t}\n\tcase FW_CDEV_EVENT_PHY_PACKET_SENT2:\n\t{\n\t\tstruct fw_cdev_event_phy_packet2 *pp = &e->phy_packet.with_tstamp;\n\n\t\tpp->rcode = rcode;\n\t\tpp->tstamp = packet->timestamp;\n\t\tqueue_event(e->client, &e->event, &e->phy_packet, sizeof(*pp) + pp->length,\n\t\t\t    NULL, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tclient_put(e_client);\n}\n\nstatic int ioctl_send_phy_packet(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_send_phy_packet *a = &arg->send_phy_packet;\n\tstruct fw_card *card = client->device->card;\n\tstruct outbound_phy_packet_event *e;\n\n\t \n\tif (!client->device->is_local)\n\t\treturn -ENOSYS;\n\n\te = kzalloc(sizeof(*e) + sizeof(a->data), GFP_KERNEL);\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\tclient_get(client);\n\te->client\t\t= client;\n\te->p.speed\t\t= SCODE_100;\n\te->p.generation\t\t= a->generation;\n\te->p.header[0]\t\t= TCODE_LINK_INTERNAL << 4;\n\te->p.header[1]\t\t= a->data[0];\n\te->p.header[2]\t\t= a->data[1];\n\te->p.header_length\t= 12;\n\te->p.callback\t\t= outbound_phy_packet_callback;\n\n\tif (client->version < FW_CDEV_VERSION_EVENT_ASYNC_TSTAMP) {\n\t\tstruct fw_cdev_event_phy_packet *pp = &e->phy_packet.without_tstamp;\n\n\t\tpp->closure = a->closure;\n\t\tpp->type = FW_CDEV_EVENT_PHY_PACKET_SENT;\n\t\tif (is_ping_packet(a->data))\n\t\t\tpp->length = 4;\n\t} else {\n\t\tstruct fw_cdev_event_phy_packet2 *pp = &e->phy_packet.with_tstamp;\n\n\t\tpp->closure = a->closure;\n\t\tpp->type = FW_CDEV_EVENT_PHY_PACKET_SENT2;\n\t\t\n\t\t\n\t\tpp->length = sizeof(a->data);\n\t\tmemcpy(pp->data, a->data, sizeof(a->data));\n\t}\n\n\tcard->driver->send_request(card, &e->p);\n\n\treturn 0;\n}\n\nstatic int ioctl_receive_phy_packets(struct client *client, union ioctl_arg *arg)\n{\n\tstruct fw_cdev_receive_phy_packets *a = &arg->receive_phy_packets;\n\tstruct fw_card *card = client->device->card;\n\n\t \n\tif (!client->device->is_local)\n\t\treturn -ENOSYS;\n\n\tspin_lock_irq(&card->lock);\n\n\tlist_move_tail(&client->phy_receiver_link, &card->phy_receiver_list);\n\tclient->phy_receiver_closure = a->closure;\n\n\tspin_unlock_irq(&card->lock);\n\n\treturn 0;\n}\n\nvoid fw_cdev_handle_phy_packet(struct fw_card *card, struct fw_packet *p)\n{\n\tstruct client *client;\n\tstruct inbound_phy_packet_event *e;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\tlist_for_each_entry(client, &card->phy_receiver_list, phy_receiver_link) {\n\t\te = kmalloc(sizeof(*e) + 8, GFP_ATOMIC);\n\t\tif (e == NULL)\n\t\t\tbreak;\n\n\t\tif (client->version < FW_CDEV_VERSION_EVENT_ASYNC_TSTAMP) {\n\t\t\tstruct fw_cdev_event_phy_packet *pp = &e->phy_packet.without_tstamp;\n\n\t\t\tpp->closure = client->phy_receiver_closure;\n\t\t\tpp->type = FW_CDEV_EVENT_PHY_PACKET_RECEIVED;\n\t\t\tpp->rcode = RCODE_COMPLETE;\n\t\t\tpp->length = 8;\n\t\t\tpp->data[0] = p->header[1];\n\t\t\tpp->data[1] = p->header[2];\n\t\t\tqueue_event(client, &e->event, &e->phy_packet, sizeof(*pp) + 8, NULL, 0);\n\t\t} else {\n\t\t\tstruct fw_cdev_event_phy_packet2 *pp = &e->phy_packet.with_tstamp;\n\n\t\t\tpp = &e->phy_packet.with_tstamp;\n\t\t\tpp->closure = client->phy_receiver_closure;\n\t\t\tpp->type = FW_CDEV_EVENT_PHY_PACKET_RECEIVED2;\n\t\t\tpp->rcode = RCODE_COMPLETE;\n\t\t\tpp->length = 8;\n\t\t\tpp->tstamp = p->timestamp;\n\t\t\tpp->data[0] = p->header[1];\n\t\t\tpp->data[1] = p->header[2];\n\t\t\tqueue_event(client, &e->event, &e->phy_packet, sizeof(*pp) + 8, NULL, 0);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n}\n\nstatic int (* const ioctl_handlers[])(struct client *, union ioctl_arg *) = {\n\t[0x00] = ioctl_get_info,\n\t[0x01] = ioctl_send_request,\n\t[0x02] = ioctl_allocate,\n\t[0x03] = ioctl_deallocate,\n\t[0x04] = ioctl_send_response,\n\t[0x05] = ioctl_initiate_bus_reset,\n\t[0x06] = ioctl_add_descriptor,\n\t[0x07] = ioctl_remove_descriptor,\n\t[0x08] = ioctl_create_iso_context,\n\t[0x09] = ioctl_queue_iso,\n\t[0x0a] = ioctl_start_iso,\n\t[0x0b] = ioctl_stop_iso,\n\t[0x0c] = ioctl_get_cycle_timer,\n\t[0x0d] = ioctl_allocate_iso_resource,\n\t[0x0e] = ioctl_deallocate_iso_resource,\n\t[0x0f] = ioctl_allocate_iso_resource_once,\n\t[0x10] = ioctl_deallocate_iso_resource_once,\n\t[0x11] = ioctl_get_speed,\n\t[0x12] = ioctl_send_broadcast_request,\n\t[0x13] = ioctl_send_stream_packet,\n\t[0x14] = ioctl_get_cycle_timer2,\n\t[0x15] = ioctl_send_phy_packet,\n\t[0x16] = ioctl_receive_phy_packets,\n\t[0x17] = ioctl_set_iso_channels,\n\t[0x18] = ioctl_flush_iso,\n};\n\nstatic int dispatch_ioctl(struct client *client,\n\t\t\t  unsigned int cmd, void __user *arg)\n{\n\tunion ioctl_arg buffer;\n\tint ret;\n\n\tif (fw_device_is_shutdown(client->device))\n\t\treturn -ENODEV;\n\n\tif (_IOC_TYPE(cmd) != '#' ||\n\t    _IOC_NR(cmd) >= ARRAY_SIZE(ioctl_handlers) ||\n\t    _IOC_SIZE(cmd) > sizeof(buffer))\n\t\treturn -ENOTTY;\n\n\tmemset(&buffer, 0, sizeof(buffer));\n\n\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\tif (copy_from_user(&buffer, arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tret = ioctl_handlers[_IOC_NR(cmd)](client, &buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\tif (copy_to_user(arg, &buffer, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic long fw_device_op_ioctl(struct file *file,\n\t\t\t       unsigned int cmd, unsigned long arg)\n{\n\treturn dispatch_ioctl(file->private_data, cmd, (void __user *)arg);\n}\n\nstatic int fw_device_op_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct client *client = file->private_data;\n\tunsigned long size;\n\tint page_count, ret;\n\n\tif (fw_device_is_shutdown(client->device))\n\t\treturn -ENODEV;\n\n\t \n\tif (client->buffer.pages != NULL)\n\t\treturn -EBUSY;\n\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\tif (vma->vm_start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tclient->vm_start = vma->vm_start;\n\tsize = vma->vm_end - vma->vm_start;\n\tpage_count = size >> PAGE_SHIFT;\n\tif (size & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tret = fw_iso_buffer_alloc(&client->buffer, page_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irq(&client->lock);\n\tif (client->iso_context) {\n\t\tret = fw_iso_buffer_map_dma(&client->buffer,\n\t\t\t\tclient->device->card,\n\t\t\t\tiso_dma_direction(client->iso_context));\n\t\tclient->buffer_is_mapped = (ret == 0);\n\t}\n\tspin_unlock_irq(&client->lock);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = vm_map_pages_zero(vma, client->buffer.pages,\n\t\t\t\tclient->buffer.page_count);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn 0;\n fail:\n\tfw_iso_buffer_destroy(&client->buffer, client->device->card);\n\treturn ret;\n}\n\nstatic int is_outbound_transaction_resource(int id, void *p, void *data)\n{\n\tstruct client_resource *resource = p;\n\n\treturn resource->release == release_transaction;\n}\n\nstatic int has_outbound_transactions(struct client *client)\n{\n\tint ret;\n\n\tspin_lock_irq(&client->lock);\n\tret = idr_for_each(&client->resource_idr,\n\t\t\t   is_outbound_transaction_resource, NULL);\n\tspin_unlock_irq(&client->lock);\n\n\treturn ret;\n}\n\nstatic int shutdown_resource(int id, void *p, void *data)\n{\n\tstruct client_resource *resource = p;\n\tstruct client *client = data;\n\n\tresource->release(client, resource);\n\tclient_put(client);\n\n\treturn 0;\n}\n\nstatic int fw_device_op_release(struct inode *inode, struct file *file)\n{\n\tstruct client *client = file->private_data;\n\tstruct event *event, *next_event;\n\n\tspin_lock_irq(&client->device->card->lock);\n\tlist_del(&client->phy_receiver_link);\n\tspin_unlock_irq(&client->device->card->lock);\n\n\tmutex_lock(&client->device->client_list_mutex);\n\tlist_del(&client->link);\n\tmutex_unlock(&client->device->client_list_mutex);\n\n\tif (client->iso_context)\n\t\tfw_iso_context_destroy(client->iso_context);\n\n\tif (client->buffer.pages)\n\t\tfw_iso_buffer_destroy(&client->buffer, client->device->card);\n\n\t \n\tspin_lock_irq(&client->lock);\n\tclient->in_shutdown = true;\n\tspin_unlock_irq(&client->lock);\n\n\twait_event(client->tx_flush_wait, !has_outbound_transactions(client));\n\n\tidr_for_each(&client->resource_idr, shutdown_resource, client);\n\tidr_destroy(&client->resource_idr);\n\n\tlist_for_each_entry_safe(event, next_event, &client->event_list, link)\n\t\tkfree(event);\n\n\tclient_put(client);\n\n\treturn 0;\n}\n\nstatic __poll_t fw_device_op_poll(struct file *file, poll_table * pt)\n{\n\tstruct client *client = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &client->wait, pt);\n\n\tif (fw_device_is_shutdown(client->device))\n\t\tmask |= EPOLLHUP | EPOLLERR;\n\tif (!list_empty(&client->event_list))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nconst struct file_operations fw_device_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.open\t\t= fw_device_op_open,\n\t.read\t\t= fw_device_op_read,\n\t.unlocked_ioctl\t= fw_device_op_ioctl,\n\t.mmap\t\t= fw_device_op_mmap,\n\t.release\t= fw_device_op_release,\n\t.poll\t\t= fw_device_op_poll,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}