{
  "module_name": "sbp2.c",
  "hash_id": "b242240482a753e17c4edd178e2e2e65678b5e5b714ae722a317ac57e27d1680",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/sbp2.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/blkdev.h>\n#include <linux/bug.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/stringify.h>\n#include <linux/workqueue.h>\n\n#include <asm/byteorder.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n \nstatic bool sbp2_param_exclusive_login = 1;\nmodule_param_named(exclusive_login, sbp2_param_exclusive_login, bool, 0644);\nMODULE_PARM_DESC(exclusive_login, \"Exclusive login to sbp2 device \"\n\t\t \"(default = Y, use N for concurrent initiators)\");\n\n \n#define SBP2_WORKAROUND_128K_MAX_TRANS\t0x1\n#define SBP2_WORKAROUND_INQUIRY_36\t0x2\n#define SBP2_WORKAROUND_MODE_SENSE_8\t0x4\n#define SBP2_WORKAROUND_FIX_CAPACITY\t0x8\n#define SBP2_WORKAROUND_DELAY_INQUIRY\t0x10\n#define SBP2_INQUIRY_DELAY\t\t12\n#define SBP2_WORKAROUND_POWER_CONDITION\t0x20\n#define SBP2_WORKAROUND_OVERRIDE\t0x100\n\nstatic int sbp2_param_workarounds;\nmodule_param_named(workarounds, sbp2_param_workarounds, int, 0644);\nMODULE_PARM_DESC(workarounds, \"Work around device bugs (default = 0\"\n\t\", 128kB max transfer = \" __stringify(SBP2_WORKAROUND_128K_MAX_TRANS)\n\t\", 36 byte inquiry = \"    __stringify(SBP2_WORKAROUND_INQUIRY_36)\n\t\", skip mode page 8 = \"   __stringify(SBP2_WORKAROUND_MODE_SENSE_8)\n\t\", fix capacity = \"       __stringify(SBP2_WORKAROUND_FIX_CAPACITY)\n\t\", delay inquiry = \"      __stringify(SBP2_WORKAROUND_DELAY_INQUIRY)\n\t\", set power condition in start stop unit = \"\n\t\t\t\t  __stringify(SBP2_WORKAROUND_POWER_CONDITION)\n\t\", override internal blacklist = \" __stringify(SBP2_WORKAROUND_OVERRIDE)\n\t\", or a combination)\");\n\n \nstruct sbp2_logical_unit {\n\tstruct sbp2_target *tgt;\n\tstruct list_head link;\n\tstruct fw_address_handler address_handler;\n\tstruct list_head orb_list;\n\n\tu64 command_block_agent_address;\n\tu16 lun;\n\tint login_id;\n\n\t \n\tint generation;\n\tint retries;\n\twork_func_t workfn;\n\tstruct delayed_work work;\n\tbool has_sdev;\n\tbool blocked;\n};\n\nstatic void sbp2_queue_work(struct sbp2_logical_unit *lu, unsigned long delay)\n{\n\tqueue_delayed_work(fw_workqueue, &lu->work, delay);\n}\n\n \nstruct sbp2_target {\n\tstruct fw_unit *unit;\n\tstruct list_head lu_list;\n\n\tu64 management_agent_address;\n\tu64 guid;\n\tint directory_id;\n\tint node_id;\n\tint address_high;\n\tunsigned int workarounds;\n\tunsigned int mgt_orb_timeout;\n\tunsigned int max_payload;\n\n\tspinlock_t lock;\n\tint dont_block;\t \n\tint blocked;\t \n};\n\nstatic struct fw_device *target_parent_device(struct sbp2_target *tgt)\n{\n\treturn fw_parent_device(tgt->unit);\n}\n\nstatic const struct device *tgt_dev(const struct sbp2_target *tgt)\n{\n\treturn &tgt->unit->device;\n}\n\nstatic const struct device *lu_dev(const struct sbp2_logical_unit *lu)\n{\n\treturn &lu->tgt->unit->device;\n}\n\n \n#define INVALID_LOGIN_ID 0x10000\n\n#define SBP2_ORB_TIMEOUT\t\t2000U\t\t \n#define SBP2_ORB_NULL\t\t\t0x80000000\n#define SBP2_RETRY_LIMIT\t\t0xf\t\t \n#define SBP2_CYCLE_LIMIT\t\t(0xc8 << 12)\t \n\n \n#define SBP2_MAX_CDB_SIZE\t\t16\n\n \n#define SBP2_MAX_SEG_SIZE\t\t0xfffc\n\n \n#define SBP2_CSR_UNIT_CHARACTERISTICS\t0x3a\n#define SBP2_CSR_FIRMWARE_REVISION\t0x3c\n#define SBP2_CSR_LOGICAL_UNIT_NUMBER\t0x14\n#define SBP2_CSR_UNIT_UNIQUE_ID\t\t0x8d\n#define SBP2_CSR_LOGICAL_UNIT_DIRECTORY\t0xd4\n\n \n#define SBP2_LOGIN_REQUEST\t\t0x0\n#define SBP2_QUERY_LOGINS_REQUEST\t0x1\n#define SBP2_RECONNECT_REQUEST\t\t0x3\n#define SBP2_SET_PASSWORD_REQUEST\t0x4\n#define SBP2_LOGOUT_REQUEST\t\t0x7\n#define SBP2_ABORT_TASK_REQUEST\t\t0xb\n#define SBP2_ABORT_TASK_SET\t\t0xc\n#define SBP2_LOGICAL_UNIT_RESET\t\t0xe\n#define SBP2_TARGET_RESET_REQUEST\t0xf\n\n \n#define SBP2_AGENT_STATE\t\t0x00\n#define SBP2_AGENT_RESET\t\t0x04\n#define SBP2_ORB_POINTER\t\t0x08\n#define SBP2_DOORBELL\t\t\t0x10\n#define SBP2_UNSOLICITED_STATUS_ENABLE\t0x14\n\n \n#define SBP2_STATUS_REQUEST_COMPLETE\t0x0\n#define SBP2_STATUS_TRANSPORT_FAILURE\t0x1\n#define SBP2_STATUS_ILLEGAL_REQUEST\t0x2\n#define SBP2_STATUS_VENDOR_DEPENDENT\t0x3\n\n#define STATUS_GET_ORB_HIGH(v)\t\t((v).status & 0xffff)\n#define STATUS_GET_SBP_STATUS(v)\t(((v).status >> 16) & 0xff)\n#define STATUS_GET_LEN(v)\t\t(((v).status >> 24) & 0x07)\n#define STATUS_GET_DEAD(v)\t\t(((v).status >> 27) & 0x01)\n#define STATUS_GET_RESPONSE(v)\t\t(((v).status >> 28) & 0x03)\n#define STATUS_GET_SOURCE(v)\t\t(((v).status >> 30) & 0x03)\n#define STATUS_GET_ORB_LOW(v)\t\t((v).orb_low)\n#define STATUS_GET_DATA(v)\t\t((v).data)\n\nstruct sbp2_status {\n\tu32 status;\n\tu32 orb_low;\n\tu8 data[24];\n};\n\nstruct sbp2_pointer {\n\t__be32 high;\n\t__be32 low;\n};\n\nstruct sbp2_orb {\n\tstruct fw_transaction t;\n\tstruct kref kref;\n\tdma_addr_t request_bus;\n\tint rcode;\n\tvoid (*callback)(struct sbp2_orb * orb, struct sbp2_status * status);\n\tstruct sbp2_logical_unit *lu;\n\tstruct list_head link;\n};\n\n#define MANAGEMENT_ORB_LUN(v)\t\t\t((v))\n#define MANAGEMENT_ORB_FUNCTION(v)\t\t((v) << 16)\n#define MANAGEMENT_ORB_RECONNECT(v)\t\t((v) << 20)\n#define MANAGEMENT_ORB_EXCLUSIVE(v)\t\t((v) ? 1 << 28 : 0)\n#define MANAGEMENT_ORB_REQUEST_FORMAT(v)\t((v) << 29)\n#define MANAGEMENT_ORB_NOTIFY\t\t\t((1) << 31)\n\n#define MANAGEMENT_ORB_RESPONSE_LENGTH(v)\t((v))\n#define MANAGEMENT_ORB_PASSWORD_LENGTH(v)\t((v) << 16)\n\nstruct sbp2_management_orb {\n\tstruct sbp2_orb base;\n\tstruct {\n\t\tstruct sbp2_pointer password;\n\t\tstruct sbp2_pointer response;\n\t\t__be32 misc;\n\t\t__be32 length;\n\t\tstruct sbp2_pointer status_fifo;\n\t} request;\n\t__be32 response[4];\n\tdma_addr_t response_bus;\n\tstruct completion done;\n\tstruct sbp2_status status;\n};\n\nstruct sbp2_login_response {\n\t__be32 misc;\n\tstruct sbp2_pointer command_block_agent;\n\t__be32 reconnect_hold;\n};\n#define COMMAND_ORB_DATA_SIZE(v)\t((v))\n#define COMMAND_ORB_PAGE_SIZE(v)\t((v) << 16)\n#define COMMAND_ORB_PAGE_TABLE_PRESENT\t((1) << 19)\n#define COMMAND_ORB_MAX_PAYLOAD(v)\t((v) << 20)\n#define COMMAND_ORB_SPEED(v)\t\t((v) << 24)\n#define COMMAND_ORB_DIRECTION\t\t((1) << 27)\n#define COMMAND_ORB_REQUEST_FORMAT(v)\t((v) << 29)\n#define COMMAND_ORB_NOTIFY\t\t((1) << 31)\n\nstruct sbp2_command_orb {\n\tstruct sbp2_orb base;\n\tstruct {\n\t\tstruct sbp2_pointer next;\n\t\tstruct sbp2_pointer data_descriptor;\n\t\t__be32 misc;\n\t\tu8 command_block[SBP2_MAX_CDB_SIZE];\n\t} request;\n\tstruct scsi_cmnd *cmd;\n\n\tstruct sbp2_pointer page_table[SG_ALL] __attribute__((aligned(8)));\n\tdma_addr_t page_table_bus;\n};\n\n#define SBP2_ROM_VALUE_WILDCARD ~0          \n#define SBP2_ROM_VALUE_MISSING  0xff000000  \n\n \nstatic const struct {\n\tu32 firmware_revision;\n\tu32 model;\n\tunsigned int workarounds;\n} sbp2_workarounds_table[] = {\n\t  {\n\t\t.firmware_revision\t= 0x002800,\n\t\t.model\t\t\t= 0x001010,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_INQUIRY_36 |\n\t\t\t\t\t  SBP2_WORKAROUND_MODE_SENSE_8 |\n\t\t\t\t\t  SBP2_WORKAROUND_POWER_CONDITION,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x002800,\n\t\t.model\t\t\t= 0x000000,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_POWER_CONDITION,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x000200,\n\t\t.model\t\t\t= SBP2_ROM_VALUE_WILDCARD,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_INQUIRY_36,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x012800,\n\t\t.model\t\t\t= SBP2_ROM_VALUE_WILDCARD,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_POWER_CONDITION,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0xa0b800,\n\t\t.model\t\t\t= SBP2_ROM_VALUE_WILDCARD,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_128K_MAX_TRANS,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x002600,\n\t\t.model\t\t\t= SBP2_ROM_VALUE_WILDCARD,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_128K_MAX_TRANS,\n\t},\n\t \n\t{\n\t\t.firmware_revision\t= 0x0a2700,\n\t\t.model\t\t\t= 0x000000,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_128K_MAX_TRANS |\n\t\t\t\t\t  SBP2_WORKAROUND_FIX_CAPACITY,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x0a2700,\n\t\t.model\t\t\t= 0x000021,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_FIX_CAPACITY,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x0a2700,\n\t\t.model\t\t\t= 0x000022,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_FIX_CAPACITY,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x0a2700,\n\t\t.model\t\t\t= 0x000023,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_FIX_CAPACITY,\n\t},\n\t  {\n\t\t.firmware_revision\t= 0x0a2700,\n\t\t.model\t\t\t= 0x00007e,\n\t\t.workarounds\t\t= SBP2_WORKAROUND_FIX_CAPACITY,\n\t}\n};\n\nstatic void free_orb(struct kref *kref)\n{\n\tstruct sbp2_orb *orb = container_of(kref, struct sbp2_orb, kref);\n\n\tkfree(orb);\n}\n\nstatic void sbp2_status_write(struct fw_card *card, struct fw_request *request,\n\t\t\t      int tcode, int destination, int source,\n\t\t\t      int generation, unsigned long long offset,\n\t\t\t      void *payload, size_t length, void *callback_data)\n{\n\tstruct sbp2_logical_unit *lu = callback_data;\n\tstruct sbp2_orb *orb = NULL, *iter;\n\tstruct sbp2_status status;\n\tunsigned long flags;\n\n\tif (tcode != TCODE_WRITE_BLOCK_REQUEST ||\n\t    length < 8 || length > sizeof(status)) {\n\t\tfw_send_response(card, request, RCODE_TYPE_ERROR);\n\t\treturn;\n\t}\n\n\tstatus.status  = be32_to_cpup(payload);\n\tstatus.orb_low = be32_to_cpup(payload + 4);\n\tmemset(status.data, 0, sizeof(status.data));\n\tif (length > 8)\n\t\tmemcpy(status.data, payload + 8, length - 8);\n\n\tif (STATUS_GET_SOURCE(status) == 2 || STATUS_GET_SOURCE(status) == 3) {\n\t\tdev_notice(lu_dev(lu),\n\t\t\t   \"non-ORB related status write, not handled\\n\");\n\t\tfw_send_response(card, request, RCODE_COMPLETE);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&lu->tgt->lock, flags);\n\tlist_for_each_entry(iter, &lu->orb_list, link) {\n\t\tif (STATUS_GET_ORB_HIGH(status) == 0 &&\n\t\t    STATUS_GET_ORB_LOW(status) == iter->request_bus) {\n\t\t\titer->rcode = RCODE_COMPLETE;\n\t\t\tlist_del(&iter->link);\n\t\t\torb = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lu->tgt->lock, flags);\n\n\tif (orb) {\n\t\torb->callback(orb, &status);\n\t\tkref_put(&orb->kref, free_orb);  \n\t} else {\n\t\tdev_err(lu_dev(lu), \"status write for unknown ORB\\n\");\n\t}\n\n\tfw_send_response(card, request, RCODE_COMPLETE);\n}\n\nstatic void complete_transaction(struct fw_card *card, int rcode,\n\t\t\t\t void *payload, size_t length, void *data)\n{\n\tstruct sbp2_orb *orb = data;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&orb->lu->tgt->lock, flags);\n\n\tif (orb->rcode == -1)\n\t\torb->rcode = rcode;\n\tif (orb->rcode != RCODE_COMPLETE) {\n\t\tlist_del(&orb->link);\n\t\tspin_unlock_irqrestore(&orb->lu->tgt->lock, flags);\n\n\t\torb->callback(orb, NULL);\n\t\tkref_put(&orb->kref, free_orb);  \n\t} else {\n\t\tspin_unlock_irqrestore(&orb->lu->tgt->lock, flags);\n\t}\n\n\tkref_put(&orb->kref, free_orb);  \n}\n\nstatic void sbp2_send_orb(struct sbp2_orb *orb, struct sbp2_logical_unit *lu,\n\t\t\t  int node_id, int generation, u64 offset)\n{\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\tstruct sbp2_pointer orb_pointer;\n\tunsigned long flags;\n\n\torb_pointer.high = 0;\n\torb_pointer.low = cpu_to_be32(orb->request_bus);\n\n\torb->lu = lu;\n\tspin_lock_irqsave(&lu->tgt->lock, flags);\n\tlist_add_tail(&orb->link, &lu->orb_list);\n\tspin_unlock_irqrestore(&lu->tgt->lock, flags);\n\n\tkref_get(&orb->kref);  \n\tkref_get(&orb->kref);  \n\n\tfw_send_request(device->card, &orb->t, TCODE_WRITE_BLOCK_REQUEST,\n\t\t\tnode_id, generation, device->max_speed, offset,\n\t\t\t&orb_pointer, 8, complete_transaction, orb);\n}\n\nstatic int sbp2_cancel_orbs(struct sbp2_logical_unit *lu)\n{\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\tstruct sbp2_orb *orb, *next;\n\tstruct list_head list;\n\tint retval = -ENOENT;\n\n\tINIT_LIST_HEAD(&list);\n\tspin_lock_irq(&lu->tgt->lock);\n\tlist_splice_init(&lu->orb_list, &list);\n\tspin_unlock_irq(&lu->tgt->lock);\n\n\tlist_for_each_entry_safe(orb, next, &list, link) {\n\t\tretval = 0;\n\t\tif (fw_cancel_transaction(device->card, &orb->t) == 0)\n\t\t\tcontinue;\n\n\t\torb->rcode = RCODE_CANCELLED;\n\t\torb->callback(orb, NULL);\n\t\tkref_put(&orb->kref, free_orb);  \n\t}\n\n\treturn retval;\n}\n\nstatic void complete_management_orb(struct sbp2_orb *base_orb,\n\t\t\t\t    struct sbp2_status *status)\n{\n\tstruct sbp2_management_orb *orb =\n\t\tcontainer_of(base_orb, struct sbp2_management_orb, base);\n\n\tif (status)\n\t\tmemcpy(&orb->status, status, sizeof(*status));\n\tcomplete(&orb->done);\n}\n\nstatic int sbp2_send_management_orb(struct sbp2_logical_unit *lu, int node_id,\n\t\t\t\t    int generation, int function,\n\t\t\t\t    int lun_or_login_id, void *response)\n{\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\tstruct sbp2_management_orb *orb;\n\tunsigned int timeout;\n\tint retval = -ENOMEM;\n\n\tif (function == SBP2_LOGOUT_REQUEST && fw_device_is_shutdown(device))\n\t\treturn 0;\n\n\torb = kzalloc(sizeof(*orb), GFP_NOIO);\n\tif (orb == NULL)\n\t\treturn -ENOMEM;\n\n\tkref_init(&orb->base.kref);\n\torb->response_bus =\n\t\tdma_map_single(device->card->device, &orb->response,\n\t\t\t       sizeof(orb->response), DMA_FROM_DEVICE);\n\tif (dma_mapping_error(device->card->device, orb->response_bus))\n\t\tgoto fail_mapping_response;\n\n\torb->request.response.high = 0;\n\torb->request.response.low  = cpu_to_be32(orb->response_bus);\n\n\torb->request.misc = cpu_to_be32(\n\t\tMANAGEMENT_ORB_NOTIFY |\n\t\tMANAGEMENT_ORB_FUNCTION(function) |\n\t\tMANAGEMENT_ORB_LUN(lun_or_login_id));\n\torb->request.length = cpu_to_be32(\n\t\tMANAGEMENT_ORB_RESPONSE_LENGTH(sizeof(orb->response)));\n\n\torb->request.status_fifo.high =\n\t\tcpu_to_be32(lu->address_handler.offset >> 32);\n\torb->request.status_fifo.low  =\n\t\tcpu_to_be32(lu->address_handler.offset);\n\n\tif (function == SBP2_LOGIN_REQUEST) {\n\t\t \n\t\torb->request.misc |= cpu_to_be32(\n\t\t\tMANAGEMENT_ORB_RECONNECT(2) |\n\t\t\tMANAGEMENT_ORB_EXCLUSIVE(sbp2_param_exclusive_login));\n\t\ttimeout = lu->tgt->mgt_orb_timeout;\n\t} else {\n\t\ttimeout = SBP2_ORB_TIMEOUT;\n\t}\n\n\tinit_completion(&orb->done);\n\torb->base.callback = complete_management_orb;\n\n\torb->base.request_bus =\n\t\tdma_map_single(device->card->device, &orb->request,\n\t\t\t       sizeof(orb->request), DMA_TO_DEVICE);\n\tif (dma_mapping_error(device->card->device, orb->base.request_bus))\n\t\tgoto fail_mapping_request;\n\n\tsbp2_send_orb(&orb->base, lu, node_id, generation,\n\t\t      lu->tgt->management_agent_address);\n\n\twait_for_completion_timeout(&orb->done, msecs_to_jiffies(timeout));\n\n\tretval = -EIO;\n\tif (sbp2_cancel_orbs(lu) == 0) {\n\t\tdev_err(lu_dev(lu), \"ORB reply timed out, rcode 0x%02x\\n\",\n\t\t\torb->base.rcode);\n\t\tgoto out;\n\t}\n\n\tif (orb->base.rcode != RCODE_COMPLETE) {\n\t\tdev_err(lu_dev(lu), \"management write failed, rcode 0x%02x\\n\",\n\t\t\torb->base.rcode);\n\t\tgoto out;\n\t}\n\n\tif (STATUS_GET_RESPONSE(orb->status) != 0 ||\n\t    STATUS_GET_SBP_STATUS(orb->status) != 0) {\n\t\tdev_err(lu_dev(lu), \"error status: %d:%d\\n\",\n\t\t\t STATUS_GET_RESPONSE(orb->status),\n\t\t\t STATUS_GET_SBP_STATUS(orb->status));\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n out:\n\tdma_unmap_single(device->card->device, orb->base.request_bus,\n\t\t\t sizeof(orb->request), DMA_TO_DEVICE);\n fail_mapping_request:\n\tdma_unmap_single(device->card->device, orb->response_bus,\n\t\t\t sizeof(orb->response), DMA_FROM_DEVICE);\n fail_mapping_response:\n\tif (response)\n\t\tmemcpy(response, orb->response, sizeof(orb->response));\n\tkref_put(&orb->base.kref, free_orb);\n\n\treturn retval;\n}\n\nstatic void sbp2_agent_reset(struct sbp2_logical_unit *lu)\n{\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\t__be32 d = 0;\n\n\tfw_run_transaction(device->card, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   lu->tgt->node_id, lu->generation, device->max_speed,\n\t\t\t   lu->command_block_agent_address + SBP2_AGENT_RESET,\n\t\t\t   &d, 4);\n}\n\nstatic void complete_agent_reset_write_no_wait(struct fw_card *card,\n\t\tint rcode, void *payload, size_t length, void *data)\n{\n\tkfree(data);\n}\n\nstatic void sbp2_agent_reset_no_wait(struct sbp2_logical_unit *lu)\n{\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\tstruct fw_transaction *t;\n\tstatic __be32 d;\n\n\tt = kmalloc(sizeof(*t), GFP_ATOMIC);\n\tif (t == NULL)\n\t\treturn;\n\n\tfw_send_request(device->card, t, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\tlu->tgt->node_id, lu->generation, device->max_speed,\n\t\t\tlu->command_block_agent_address + SBP2_AGENT_RESET,\n\t\t\t&d, 4, complete_agent_reset_write_no_wait, t);\n}\n\nstatic inline void sbp2_allow_block(struct sbp2_target *tgt)\n{\n\tspin_lock_irq(&tgt->lock);\n\t--tgt->dont_block;\n\tspin_unlock_irq(&tgt->lock);\n}\n\n \nstatic void sbp2_conditionally_block(struct sbp2_logical_unit *lu)\n{\n\tstruct sbp2_target *tgt = lu->tgt;\n\tstruct fw_card *card = target_parent_device(tgt)->card;\n\tstruct Scsi_Host *shost =\n\t\tcontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tgt->lock, flags);\n\tif (!tgt->dont_block && !lu->blocked &&\n\t    lu->generation != card->generation) {\n\t\tlu->blocked = true;\n\t\tif (++tgt->blocked == 1)\n\t\t\tscsi_block_requests(shost);\n\t}\n\tspin_unlock_irqrestore(&tgt->lock, flags);\n}\n\n \nstatic void sbp2_conditionally_unblock(struct sbp2_logical_unit *lu)\n{\n\tstruct sbp2_target *tgt = lu->tgt;\n\tstruct fw_card *card = target_parent_device(tgt)->card;\n\tstruct Scsi_Host *shost =\n\t\tcontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\n\tbool unblock = false;\n\n\tspin_lock_irq(&tgt->lock);\n\tif (lu->blocked && lu->generation == card->generation) {\n\t\tlu->blocked = false;\n\t\tunblock = --tgt->blocked == 0;\n\t}\n\tspin_unlock_irq(&tgt->lock);\n\n\tif (unblock)\n\t\tscsi_unblock_requests(shost);\n}\n\n \nstatic void sbp2_unblock(struct sbp2_target *tgt)\n{\n\tstruct Scsi_Host *shost =\n\t\tcontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\n\n\tspin_lock_irq(&tgt->lock);\n\t++tgt->dont_block;\n\tspin_unlock_irq(&tgt->lock);\n\n\tscsi_unblock_requests(shost);\n}\n\nstatic int sbp2_lun2int(u16 lun)\n{\n\tstruct scsi_lun eight_bytes_lun;\n\n\tmemset(&eight_bytes_lun, 0, sizeof(eight_bytes_lun));\n\teight_bytes_lun.scsi_lun[0] = (lun >> 8) & 0xff;\n\teight_bytes_lun.scsi_lun[1] = lun & 0xff;\n\n\treturn scsilun_to_int(&eight_bytes_lun);\n}\n\n \nstatic void sbp2_set_busy_timeout(struct sbp2_logical_unit *lu)\n{\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\t__be32 d = cpu_to_be32(SBP2_CYCLE_LIMIT | SBP2_RETRY_LIMIT);\n\n\tfw_run_transaction(device->card, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t   lu->tgt->node_id, lu->generation, device->max_speed,\n\t\t\t   CSR_REGISTER_BASE + CSR_BUSY_TIMEOUT, &d, 4);\n}\n\nstatic void sbp2_reconnect(struct work_struct *work);\n\nstatic void sbp2_login(struct work_struct *work)\n{\n\tstruct sbp2_logical_unit *lu =\n\t\tcontainer_of(work, struct sbp2_logical_unit, work.work);\n\tstruct sbp2_target *tgt = lu->tgt;\n\tstruct fw_device *device = target_parent_device(tgt);\n\tstruct Scsi_Host *shost;\n\tstruct scsi_device *sdev;\n\tstruct sbp2_login_response response;\n\tint generation, node_id, local_node_id;\n\n\tif (fw_device_is_shutdown(device))\n\t\treturn;\n\n\tgeneration    = device->generation;\n\tsmp_rmb();     \n\tnode_id       = device->node_id;\n\tlocal_node_id = device->card->node_id;\n\n\t \n\tif (lu->has_sdev)\n\t\tsbp2_send_management_orb(lu, device->node_id, generation,\n\t\t\t\tSBP2_LOGOUT_REQUEST, lu->login_id, NULL);\n\n\tif (sbp2_send_management_orb(lu, node_id, generation,\n\t\t\t\tSBP2_LOGIN_REQUEST, lu->lun, &response) < 0) {\n\t\tif (lu->retries++ < 5) {\n\t\t\tsbp2_queue_work(lu, DIV_ROUND_UP(HZ, 5));\n\t\t} else {\n\t\t\tdev_err(tgt_dev(tgt), \"failed to login to LUN %04x\\n\",\n\t\t\t\tlu->lun);\n\t\t\t \n\t\t\tsbp2_unblock(lu->tgt);\n\t\t}\n\t\treturn;\n\t}\n\n\ttgt->node_id\t  = node_id;\n\ttgt->address_high = local_node_id << 16;\n\tsmp_wmb();\t   \n\tlu->generation\t  = generation;\n\n\tlu->command_block_agent_address =\n\t\t((u64)(be32_to_cpu(response.command_block_agent.high) & 0xffff)\n\t\t      << 32) | be32_to_cpu(response.command_block_agent.low);\n\tlu->login_id = be32_to_cpu(response.misc) & 0xffff;\n\n\tdev_notice(tgt_dev(tgt), \"logged in to LUN %04x (%d retries)\\n\",\n\t\t   lu->lun, lu->retries);\n\n\t \n\tsbp2_set_busy_timeout(lu);\n\n\tlu->workfn = sbp2_reconnect;\n\tsbp2_agent_reset(lu);\n\n\t \n\tif (lu->has_sdev) {\n\t\tsbp2_cancel_orbs(lu);\n\t\tsbp2_conditionally_unblock(lu);\n\n\t\treturn;\n\t}\n\n\tif (lu->tgt->workarounds & SBP2_WORKAROUND_DELAY_INQUIRY)\n\t\tssleep(SBP2_INQUIRY_DELAY);\n\n\tshost = container_of((void *)tgt, struct Scsi_Host, hostdata[0]);\n\tsdev = __scsi_add_device(shost, 0, 0, sbp2_lun2int(lu->lun), lu);\n\t \n\n\t \n\tif (IS_ERR(sdev))\n\t\tgoto out_logout_login;\n\n\t \n\tsmp_rmb();  \n\tif (generation != device->card->generation) {\n\t\tscsi_remove_device(sdev);\n\t\tscsi_device_put(sdev);\n\t\tgoto out_logout_login;\n\t}\n\n\t \n\tlu->has_sdev = true;\n\tscsi_device_put(sdev);\n\tsbp2_allow_block(tgt);\n\n\treturn;\n\n out_logout_login:\n\tsmp_rmb();  \n\tgeneration = device->generation;\n\tsmp_rmb();  \n\n\tsbp2_send_management_orb(lu, device->node_id, generation,\n\t\t\t\t SBP2_LOGOUT_REQUEST, lu->login_id, NULL);\n\t \n\tlu->workfn = sbp2_login;\n}\n\nstatic void sbp2_reconnect(struct work_struct *work)\n{\n\tstruct sbp2_logical_unit *lu =\n\t\tcontainer_of(work, struct sbp2_logical_unit, work.work);\n\tstruct sbp2_target *tgt = lu->tgt;\n\tstruct fw_device *device = target_parent_device(tgt);\n\tint generation, node_id, local_node_id;\n\n\tif (fw_device_is_shutdown(device))\n\t\treturn;\n\n\tgeneration    = device->generation;\n\tsmp_rmb();     \n\tnode_id       = device->node_id;\n\tlocal_node_id = device->card->node_id;\n\n\tif (sbp2_send_management_orb(lu, node_id, generation,\n\t\t\t\t     SBP2_RECONNECT_REQUEST,\n\t\t\t\t     lu->login_id, NULL) < 0) {\n\t\t \n\t\tsmp_rmb();  \n\t\tif (generation == device->card->generation ||\n\t\t    lu->retries++ >= 5) {\n\t\t\tdev_err(tgt_dev(tgt), \"failed to reconnect\\n\");\n\t\t\tlu->retries = 0;\n\t\t\tlu->workfn = sbp2_login;\n\t\t}\n\t\tsbp2_queue_work(lu, DIV_ROUND_UP(HZ, 5));\n\n\t\treturn;\n\t}\n\n\ttgt->node_id      = node_id;\n\ttgt->address_high = local_node_id << 16;\n\tsmp_wmb();\t   \n\tlu->generation\t  = generation;\n\n\tdev_notice(tgt_dev(tgt), \"reconnected to LUN %04x (%d retries)\\n\",\n\t\t   lu->lun, lu->retries);\n\n\tsbp2_agent_reset(lu);\n\tsbp2_cancel_orbs(lu);\n\tsbp2_conditionally_unblock(lu);\n}\n\nstatic void sbp2_lu_workfn(struct work_struct *work)\n{\n\tstruct sbp2_logical_unit *lu = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct sbp2_logical_unit, work);\n\tlu->workfn(work);\n}\n\nstatic int sbp2_add_logical_unit(struct sbp2_target *tgt, int lun_entry)\n{\n\tstruct sbp2_logical_unit *lu;\n\n\tlu = kmalloc(sizeof(*lu), GFP_KERNEL);\n\tif (!lu)\n\t\treturn -ENOMEM;\n\n\tlu->address_handler.length           = 0x100;\n\tlu->address_handler.address_callback = sbp2_status_write;\n\tlu->address_handler.callback_data    = lu;\n\n\tif (fw_core_add_address_handler(&lu->address_handler,\n\t\t\t\t\t&fw_high_memory_region) < 0) {\n\t\tkfree(lu);\n\t\treturn -ENOMEM;\n\t}\n\n\tlu->tgt      = tgt;\n\tlu->lun      = lun_entry & 0xffff;\n\tlu->login_id = INVALID_LOGIN_ID;\n\tlu->retries  = 0;\n\tlu->has_sdev = false;\n\tlu->blocked  = false;\n\t++tgt->dont_block;\n\tINIT_LIST_HEAD(&lu->orb_list);\n\tlu->workfn = sbp2_login;\n\tINIT_DELAYED_WORK(&lu->work, sbp2_lu_workfn);\n\n\tlist_add_tail(&lu->link, &tgt->lu_list);\n\treturn 0;\n}\n\nstatic void sbp2_get_unit_unique_id(struct sbp2_target *tgt,\n\t\t\t\t    const u32 *leaf)\n{\n\tif ((leaf[0] & 0xffff0000) == 0x00020000)\n\t\ttgt->guid = (u64)leaf[1] << 32 | leaf[2];\n}\n\nstatic int sbp2_scan_logical_unit_dir(struct sbp2_target *tgt,\n\t\t\t\t      const u32 *directory)\n{\n\tstruct fw_csr_iterator ci;\n\tint key, value;\n\n\tfw_csr_iterator_init(&ci, directory);\n\twhile (fw_csr_iterator_next(&ci, &key, &value))\n\t\tif (key == SBP2_CSR_LOGICAL_UNIT_NUMBER &&\n\t\t    sbp2_add_logical_unit(tgt, value) < 0)\n\t\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int sbp2_scan_unit_dir(struct sbp2_target *tgt, const u32 *directory,\n\t\t\t      u32 *model, u32 *firmware_revision)\n{\n\tstruct fw_csr_iterator ci;\n\tint key, value;\n\n\tfw_csr_iterator_init(&ci, directory);\n\twhile (fw_csr_iterator_next(&ci, &key, &value)) {\n\t\tswitch (key) {\n\n\t\tcase CSR_DEPENDENT_INFO | CSR_OFFSET:\n\t\t\ttgt->management_agent_address =\n\t\t\t\t\tCSR_REGISTER_BASE + 4 * value;\n\t\t\tbreak;\n\n\t\tcase CSR_DIRECTORY_ID:\n\t\t\ttgt->directory_id = value;\n\t\t\tbreak;\n\n\t\tcase CSR_MODEL:\n\t\t\t*model = value;\n\t\t\tbreak;\n\n\t\tcase SBP2_CSR_FIRMWARE_REVISION:\n\t\t\t*firmware_revision = value;\n\t\t\tbreak;\n\n\t\tcase SBP2_CSR_UNIT_CHARACTERISTICS:\n\t\t\t \n\t\t\ttgt->mgt_orb_timeout = (value >> 8 & 0xff) * 500;\n\t\t\tbreak;\n\n\t\tcase SBP2_CSR_LOGICAL_UNIT_NUMBER:\n\t\t\tif (sbp2_add_logical_unit(tgt, value) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase SBP2_CSR_UNIT_UNIQUE_ID:\n\t\t\tsbp2_get_unit_unique_id(tgt, ci.p - 1 + value);\n\t\t\tbreak;\n\n\t\tcase SBP2_CSR_LOGICAL_UNIT_DIRECTORY:\n\t\t\t \n\t\t\tif (sbp2_scan_logical_unit_dir(tgt, ci.p - 1 + value) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void sbp2_clamp_management_orb_timeout(struct sbp2_target *tgt)\n{\n\tunsigned int timeout = tgt->mgt_orb_timeout;\n\n\tif (timeout > 40000)\n\t\tdev_notice(tgt_dev(tgt), \"%ds mgt_ORB_timeout limited to 40s\\n\",\n\t\t\t   timeout / 1000);\n\n\ttgt->mgt_orb_timeout = clamp_val(timeout, 5000, 40000);\n}\n\nstatic void sbp2_init_workarounds(struct sbp2_target *tgt, u32 model,\n\t\t\t\t  u32 firmware_revision)\n{\n\tint i;\n\tunsigned int w = sbp2_param_workarounds;\n\n\tif (w)\n\t\tdev_notice(tgt_dev(tgt),\n\t\t\t   \"Please notify linux1394-devel@lists.sf.net \"\n\t\t\t   \"if you need the workarounds parameter\\n\");\n\n\tif (w & SBP2_WORKAROUND_OVERRIDE)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(sbp2_workarounds_table); i++) {\n\n\t\tif (sbp2_workarounds_table[i].firmware_revision !=\n\t\t    (firmware_revision & 0xffffff00))\n\t\t\tcontinue;\n\n\t\tif (sbp2_workarounds_table[i].model != model &&\n\t\t    sbp2_workarounds_table[i].model != SBP2_ROM_VALUE_WILDCARD)\n\t\t\tcontinue;\n\n\t\tw |= sbp2_workarounds_table[i].workarounds;\n\t\tbreak;\n\t}\n out:\n\tif (w)\n\t\tdev_notice(tgt_dev(tgt), \"workarounds 0x%x \"\n\t\t\t   \"(firmware_revision 0x%06x, model_id 0x%06x)\\n\",\n\t\t\t   w, firmware_revision, model);\n\ttgt->workarounds = w;\n}\n\nstatic const struct scsi_host_template scsi_driver_template;\nstatic void sbp2_remove(struct fw_unit *unit);\n\nstatic int sbp2_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct sbp2_target *tgt;\n\tstruct sbp2_logical_unit *lu;\n\tstruct Scsi_Host *shost;\n\tu32 model, firmware_revision;\n\n\t \n\tif (device->is_local)\n\t\treturn -ENODEV;\n\n\tshost = scsi_host_alloc(&scsi_driver_template, sizeof(*tgt));\n\tif (shost == NULL)\n\t\treturn -ENOMEM;\n\n\ttgt = (struct sbp2_target *)shost->hostdata;\n\tdev_set_drvdata(&unit->device, tgt);\n\ttgt->unit = unit;\n\tINIT_LIST_HEAD(&tgt->lu_list);\n\tspin_lock_init(&tgt->lock);\n\ttgt->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];\n\n\tif (fw_device_enable_phys_dma(device) < 0)\n\t\tgoto fail_shost_put;\n\n\tshost->max_cmd_len = SBP2_MAX_CDB_SIZE;\n\n\tif (scsi_add_host_with_dma(shost, &unit->device,\n\t\t\t\t   device->card->device) < 0)\n\t\tgoto fail_shost_put;\n\n\t \n\ttgt->directory_id = ((unit->directory - device->config_rom) * 4\n\t\t\t     + CSR_CONFIG_ROM) & 0xffffff;\n\n\tfirmware_revision = SBP2_ROM_VALUE_MISSING;\n\tmodel\t\t  = SBP2_ROM_VALUE_MISSING;\n\n\tif (sbp2_scan_unit_dir(tgt, unit->directory, &model,\n\t\t\t       &firmware_revision) < 0)\n\t\tgoto fail_remove;\n\n\tsbp2_clamp_management_orb_timeout(tgt);\n\tsbp2_init_workarounds(tgt, model, firmware_revision);\n\n\t \n\ttgt->max_payload = min3(device->max_speed + 7, 10U,\n\t\t\t\tdevice->card->max_receive - 1);\n\n\t \n\tlist_for_each_entry(lu, &tgt->lu_list, link)\n\t\tsbp2_queue_work(lu, DIV_ROUND_UP(HZ, 5));\n\n\treturn 0;\n\n fail_remove:\n\tsbp2_remove(unit);\n\treturn -ENOMEM;\n\n fail_shost_put:\n\tscsi_host_put(shost);\n\treturn -ENOMEM;\n}\n\nstatic void sbp2_update(struct fw_unit *unit)\n{\n\tstruct sbp2_target *tgt = dev_get_drvdata(&unit->device);\n\tstruct sbp2_logical_unit *lu;\n\n\tfw_device_enable_phys_dma(fw_parent_device(unit));\n\n\t \n\tlist_for_each_entry(lu, &tgt->lu_list, link) {\n\t\tsbp2_conditionally_block(lu);\n\t\tlu->retries = 0;\n\t\tsbp2_queue_work(lu, 0);\n\t}\n}\n\nstatic void sbp2_remove(struct fw_unit *unit)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct sbp2_target *tgt = dev_get_drvdata(&unit->device);\n\tstruct sbp2_logical_unit *lu, *next;\n\tstruct Scsi_Host *shost =\n\t\tcontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\n\tstruct scsi_device *sdev;\n\n\t \n\tsbp2_unblock(tgt);\n\n\tlist_for_each_entry_safe(lu, next, &tgt->lu_list, link) {\n\t\tcancel_delayed_work_sync(&lu->work);\n\t\tsdev = scsi_device_lookup(shost, 0, 0, sbp2_lun2int(lu->lun));\n\t\tif (sdev) {\n\t\t\tscsi_remove_device(sdev);\n\t\t\tscsi_device_put(sdev);\n\t\t}\n\t\tif (lu->login_id != INVALID_LOGIN_ID) {\n\t\t\tint generation, node_id;\n\t\t\t \n\t\t\tgeneration = device->generation;\n\t\t\tsmp_rmb();  \n\t\t\tnode_id    = device->node_id;\n\t\t\tsbp2_send_management_orb(lu, node_id, generation,\n\t\t\t\t\t\t SBP2_LOGOUT_REQUEST,\n\t\t\t\t\t\t lu->login_id, NULL);\n\t\t}\n\t\tfw_core_remove_address_handler(&lu->address_handler);\n\t\tlist_del(&lu->link);\n\t\tkfree(lu);\n\t}\n\tscsi_remove_host(shost);\n\tdev_notice(&unit->device, \"released target %d:0:0\\n\", shost->host_no);\n\n\tscsi_host_put(shost);\n}\n\n#define SBP2_UNIT_SPEC_ID_ENTRY\t0x0000609e\n#define SBP2_SW_VERSION_ENTRY\t0x00010483\n\nstatic const struct ieee1394_device_id sbp2_id_table[] = {\n\t{\n\t\t.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\tIEEE1394_MATCH_VERSION,\n\t\t.specifier_id = SBP2_UNIT_SPEC_ID_ENTRY,\n\t\t.version      = SBP2_SW_VERSION_ENTRY,\n\t},\n\t{ }\n};\n\nstatic struct fw_driver sbp2_driver = {\n\t.driver   = {\n\t\t.owner  = THIS_MODULE,\n\t\t.name   = KBUILD_MODNAME,\n\t\t.bus    = &fw_bus_type,\n\t},\n\t.probe    = sbp2_probe,\n\t.update   = sbp2_update,\n\t.remove   = sbp2_remove,\n\t.id_table = sbp2_id_table,\n};\n\nstatic void sbp2_unmap_scatterlist(struct device *card_device,\n\t\t\t\t   struct sbp2_command_orb *orb)\n{\n\tscsi_dma_unmap(orb->cmd);\n\n\tif (orb->request.misc & cpu_to_be32(COMMAND_ORB_PAGE_TABLE_PRESENT))\n\t\tdma_unmap_single(card_device, orb->page_table_bus,\n\t\t\t\t sizeof(orb->page_table), DMA_TO_DEVICE);\n}\n\nstatic unsigned int sbp2_status_to_sense_data(u8 *sbp2_status, u8 *sense_data)\n{\n\tint sam_status;\n\tint sfmt = (sbp2_status[0] >> 6) & 0x03;\n\n\tif (sfmt == 2 || sfmt == 3) {\n\t\t \n\t\treturn DID_ERROR << 16;\n\t}\n\n\tsense_data[0] = 0x70 | sfmt | (sbp2_status[1] & 0x80);\n\tsense_data[1] = 0x0;\n\tsense_data[2] = ((sbp2_status[1] << 1) & 0xe0) | (sbp2_status[1] & 0x0f);\n\tsense_data[3] = sbp2_status[4];\n\tsense_data[4] = sbp2_status[5];\n\tsense_data[5] = sbp2_status[6];\n\tsense_data[6] = sbp2_status[7];\n\tsense_data[7] = 10;\n\tsense_data[8] = sbp2_status[8];\n\tsense_data[9] = sbp2_status[9];\n\tsense_data[10] = sbp2_status[10];\n\tsense_data[11] = sbp2_status[11];\n\tsense_data[12] = sbp2_status[2];\n\tsense_data[13] = sbp2_status[3];\n\tsense_data[14] = sbp2_status[12];\n\tsense_data[15] = sbp2_status[13];\n\n\tsam_status = sbp2_status[0] & 0x3f;\n\n\tswitch (sam_status) {\n\tcase SAM_STAT_GOOD:\n\tcase SAM_STAT_CHECK_CONDITION:\n\tcase SAM_STAT_CONDITION_MET:\n\tcase SAM_STAT_BUSY:\n\tcase SAM_STAT_RESERVATION_CONFLICT:\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\t\treturn DID_OK << 16 | sam_status;\n\n\tdefault:\n\t\treturn DID_ERROR << 16;\n\t}\n}\n\nstatic void complete_command_orb(struct sbp2_orb *base_orb,\n\t\t\t\t struct sbp2_status *status)\n{\n\tstruct sbp2_command_orb *orb =\n\t\tcontainer_of(base_orb, struct sbp2_command_orb, base);\n\tstruct fw_device *device = target_parent_device(base_orb->lu->tgt);\n\tint result;\n\n\tif (status != NULL) {\n\t\tif (STATUS_GET_DEAD(*status))\n\t\t\tsbp2_agent_reset_no_wait(base_orb->lu);\n\n\t\tswitch (STATUS_GET_RESPONSE(*status)) {\n\t\tcase SBP2_STATUS_REQUEST_COMPLETE:\n\t\t\tresult = DID_OK << 16;\n\t\t\tbreak;\n\t\tcase SBP2_STATUS_TRANSPORT_FAILURE:\n\t\t\tresult = DID_BUS_BUSY << 16;\n\t\t\tbreak;\n\t\tcase SBP2_STATUS_ILLEGAL_REQUEST:\n\t\tcase SBP2_STATUS_VENDOR_DEPENDENT:\n\t\tdefault:\n\t\t\tresult = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == DID_OK << 16 && STATUS_GET_LEN(*status) > 1)\n\t\t\tresult = sbp2_status_to_sense_data(STATUS_GET_DATA(*status),\n\t\t\t\t\t\t\t   orb->cmd->sense_buffer);\n\t} else {\n\t\t \n\t\tresult = DID_BUS_BUSY << 16;\n\t\tsbp2_conditionally_block(base_orb->lu);\n\t}\n\n\tdma_unmap_single(device->card->device, orb->base.request_bus,\n\t\t\t sizeof(orb->request), DMA_TO_DEVICE);\n\tsbp2_unmap_scatterlist(device->card->device, orb);\n\n\torb->cmd->result = result;\n\tscsi_done(orb->cmd);\n}\n\nstatic int sbp2_map_scatterlist(struct sbp2_command_orb *orb,\n\t\tstruct fw_device *device, struct sbp2_logical_unit *lu)\n{\n\tstruct scatterlist *sg = scsi_sglist(orb->cmd);\n\tint i, n;\n\n\tn = scsi_dma_map(orb->cmd);\n\tif (n <= 0)\n\t\tgoto fail;\n\n\t \n\tif (n == 1) {\n\t\torb->request.data_descriptor.high =\n\t\t\tcpu_to_be32(lu->tgt->address_high);\n\t\torb->request.data_descriptor.low  =\n\t\t\tcpu_to_be32(sg_dma_address(sg));\n\t\torb->request.misc |=\n\t\t\tcpu_to_be32(COMMAND_ORB_DATA_SIZE(sg_dma_len(sg)));\n\t\treturn 0;\n\t}\n\n\tfor_each_sg(sg, sg, n, i) {\n\t\torb->page_table[i].high = cpu_to_be32(sg_dma_len(sg) << 16);\n\t\torb->page_table[i].low = cpu_to_be32(sg_dma_address(sg));\n\t}\n\n\torb->page_table_bus =\n\t\tdma_map_single(device->card->device, orb->page_table,\n\t\t\t       sizeof(orb->page_table), DMA_TO_DEVICE);\n\tif (dma_mapping_error(device->card->device, orb->page_table_bus))\n\t\tgoto fail_page_table;\n\n\t \n\torb->request.data_descriptor.high = cpu_to_be32(lu->tgt->address_high);\n\torb->request.data_descriptor.low  = cpu_to_be32(orb->page_table_bus);\n\torb->request.misc |= cpu_to_be32(COMMAND_ORB_PAGE_TABLE_PRESENT |\n\t\t\t\t\t COMMAND_ORB_DATA_SIZE(n));\n\n\treturn 0;\n\n fail_page_table:\n\tscsi_dma_unmap(orb->cmd);\n fail:\n\treturn -ENOMEM;\n}\n\n \n\nstatic int sbp2_scsi_queuecommand(struct Scsi_Host *shost,\n\t\t\t\t  struct scsi_cmnd *cmd)\n{\n\tstruct sbp2_logical_unit *lu = cmd->device->hostdata;\n\tstruct fw_device *device = target_parent_device(lu->tgt);\n\tstruct sbp2_command_orb *orb;\n\tint generation, retval = SCSI_MLQUEUE_HOST_BUSY;\n\n\torb = kzalloc(sizeof(*orb), GFP_ATOMIC);\n\tif (orb == NULL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\torb->base.rcode = -1;\n\tkref_init(&orb->base.kref);\n\torb->cmd = cmd;\n\torb->request.next.high = cpu_to_be32(SBP2_ORB_NULL);\n\torb->request.misc = cpu_to_be32(\n\t\tCOMMAND_ORB_MAX_PAYLOAD(lu->tgt->max_payload) |\n\t\tCOMMAND_ORB_SPEED(device->max_speed) |\n\t\tCOMMAND_ORB_NOTIFY);\n\n\tif (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\torb->request.misc |= cpu_to_be32(COMMAND_ORB_DIRECTION);\n\n\tgeneration = device->generation;\n\tsmp_rmb();     \n\n\tif (scsi_sg_count(cmd) && sbp2_map_scatterlist(orb, device, lu) < 0)\n\t\tgoto out;\n\n\tmemcpy(orb->request.command_block, cmd->cmnd, cmd->cmd_len);\n\n\torb->base.callback = complete_command_orb;\n\torb->base.request_bus =\n\t\tdma_map_single(device->card->device, &orb->request,\n\t\t\t       sizeof(orb->request), DMA_TO_DEVICE);\n\tif (dma_mapping_error(device->card->device, orb->base.request_bus)) {\n\t\tsbp2_unmap_scatterlist(device->card->device, orb);\n\t\tgoto out;\n\t}\n\n\tsbp2_send_orb(&orb->base, lu, lu->tgt->node_id, generation,\n\t\t      lu->command_block_agent_address + SBP2_ORB_POINTER);\n\tretval = 0;\n out:\n\tkref_put(&orb->base.kref, free_orb);\n\treturn retval;\n}\n\nstatic int sbp2_scsi_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct sbp2_logical_unit *lu = sdev->hostdata;\n\n\t \n\tif (!lu)\n\t\treturn -ENOSYS;\n\n\tsdev->allow_restart = 1;\n\n\t \n\tblk_queue_update_dma_alignment(sdev->request_queue, 4 - 1);\n\n\tif (lu->tgt->workarounds & SBP2_WORKAROUND_INQUIRY_36)\n\t\tsdev->inquiry_len = 36;\n\n\treturn 0;\n}\n\nstatic int sbp2_scsi_slave_configure(struct scsi_device *sdev)\n{\n\tstruct sbp2_logical_unit *lu = sdev->hostdata;\n\n\tsdev->use_10_for_rw = 1;\n\n\tif (sbp2_param_exclusive_login) {\n\t\tsdev->manage_system_start_stop = 1;\n\t\tsdev->manage_runtime_start_stop = 1;\n\t\tsdev->manage_shutdown = 1;\n\t}\n\n\tif (sdev->type == TYPE_ROM)\n\t\tsdev->use_10_for_ms = 1;\n\n\tif (sdev->type == TYPE_DISK &&\n\t    lu->tgt->workarounds & SBP2_WORKAROUND_MODE_SENSE_8)\n\t\tsdev->skip_ms_page_8 = 1;\n\n\tif (lu->tgt->workarounds & SBP2_WORKAROUND_FIX_CAPACITY)\n\t\tsdev->fix_capacity = 1;\n\n\tif (lu->tgt->workarounds & SBP2_WORKAROUND_POWER_CONDITION)\n\t\tsdev->start_stop_pwr_cond = 1;\n\n\tif (lu->tgt->workarounds & SBP2_WORKAROUND_128K_MAX_TRANS)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 128 * 1024 / 512);\n\n\treturn 0;\n}\n\n \nstatic int sbp2_scsi_abort(struct scsi_cmnd *cmd)\n{\n\tstruct sbp2_logical_unit *lu = cmd->device->hostdata;\n\n\tdev_notice(lu_dev(lu), \"sbp2_scsi_abort\\n\");\n\tsbp2_agent_reset(lu);\n\tsbp2_cancel_orbs(lu);\n\n\treturn SUCCESS;\n}\n\n \nstatic ssize_t sbp2_sysfs_ieee1394_id_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct sbp2_logical_unit *lu;\n\n\tif (!sdev)\n\t\treturn 0;\n\n\tlu = sdev->hostdata;\n\n\treturn sprintf(buf, \"%016llx:%06x:%04x\\n\",\n\t\t\t(unsigned long long)lu->tgt->guid,\n\t\t\tlu->tgt->directory_id, lu->lun);\n}\n\nstatic DEVICE_ATTR(ieee1394_id, S_IRUGO, sbp2_sysfs_ieee1394_id_show, NULL);\n\nstatic struct attribute *sbp2_scsi_sysfs_attrs[] = {\n\t&dev_attr_ieee1394_id.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(sbp2_scsi_sysfs);\n\nstatic const struct scsi_host_template scsi_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"SBP-2 IEEE-1394\",\n\t.proc_name\t\t= \"sbp2\",\n\t.queuecommand\t\t= sbp2_scsi_queuecommand,\n\t.slave_alloc\t\t= sbp2_scsi_slave_alloc,\n\t.slave_configure\t= sbp2_scsi_slave_configure,\n\t.eh_abort_handler\t= sbp2_scsi_abort,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.max_segment_size\t= SBP2_MAX_SEG_SIZE,\n\t.can_queue\t\t= 1,\n\t.sdev_groups\t\t= sbp2_scsi_sysfs_groups,\n};\n\nMODULE_AUTHOR(\"Kristian Hoegsberg <krh@bitplanet.net>\");\nMODULE_DESCRIPTION(\"SCSI over IEEE1394\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(ieee1394, sbp2_id_table);\n\n \nMODULE_ALIAS(\"sbp2\");\n\nstatic int __init sbp2_init(void)\n{\n\treturn driver_register(&sbp2_driver.driver);\n}\n\nstatic void __exit sbp2_cleanup(void)\n{\n\tdriver_unregister(&sbp2_driver.driver);\n}\n\nmodule_init(sbp2_init);\nmodule_exit(sbp2_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}