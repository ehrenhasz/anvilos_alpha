{
  "module_name": "core-card.c",
  "hash_id": "cc4272407302bc973bed510f791a486e4f5ff0aa99e9561eeaffba3b97f797c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core-card.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/completion.h>\n#include <linux/crc-itu-t.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n\n#include \"core.h\"\n\n#define define_fw_printk_level(func, kern_level)\t\t\\\nvoid func(const struct fw_card *card, const char *fmt, ...)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct va_format vaf;\t\t\t\t\t\\\n\tva_list args;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tva_start(args, fmt);\t\t\t\t\t\\\n\tvaf.fmt = fmt;\t\t\t\t\t\t\\\n\tvaf.va = &args;\t\t\t\t\t\t\\\n\tprintk(kern_level KBUILD_MODNAME \" %s: %pV\",\t\t\\\n\t       dev_name(card->device), &vaf);\t\t\t\\\n\tva_end(args);\t\t\t\t\t\t\\\n}\ndefine_fw_printk_level(fw_err, KERN_ERR);\ndefine_fw_printk_level(fw_notice, KERN_NOTICE);\n\nint fw_compute_block_crc(__be32 *block)\n{\n\tint length;\n\tu16 crc;\n\n\tlength = (be32_to_cpu(block[0]) >> 16) & 0xff;\n\tcrc = crc_itu_t(0, (u8 *)&block[1], length * 4);\n\t*block |= cpu_to_be32(crc);\n\n\treturn length;\n}\n\nstatic DEFINE_MUTEX(card_mutex);\nstatic LIST_HEAD(card_list);\n\nstatic LIST_HEAD(descriptor_list);\nstatic int descriptor_count;\n\nstatic __be32 tmp_config_rom[256];\n \nstatic size_t config_rom_length = 1 + 4 + 1 + 1;\n\n#define BIB_CRC(v)\t\t((v) <<  0)\n#define BIB_CRC_LENGTH(v)\t((v) << 16)\n#define BIB_INFO_LENGTH(v)\t((v) << 24)\n#define BIB_BUS_NAME\t\t0x31333934  \n#define BIB_LINK_SPEED(v)\t((v) <<  0)\n#define BIB_GENERATION(v)\t((v) <<  4)\n#define BIB_MAX_ROM(v)\t\t((v) <<  8)\n#define BIB_MAX_RECEIVE(v)\t((v) << 12)\n#define BIB_CYC_CLK_ACC(v)\t((v) << 16)\n#define BIB_PMC\t\t\t((1) << 27)\n#define BIB_BMC\t\t\t((1) << 28)\n#define BIB_ISC\t\t\t((1) << 29)\n#define BIB_CMC\t\t\t((1) << 30)\n#define BIB_IRMC\t\t((1) << 31)\n#define NODE_CAPABILITIES\t0x0c0083c0  \n\n \n#define DEFAULT_SPLIT_TIMEOUT\t(2 * 8000)\n\n#define CANON_OUI\t\t0x000085\n\nstatic void generate_config_rom(struct fw_card *card, __be32 *config_rom)\n{\n\tstruct fw_descriptor *desc;\n\tint i, j, k, length;\n\n\t \n\n\tconfig_rom[0] = cpu_to_be32(\n\t\tBIB_CRC_LENGTH(4) | BIB_INFO_LENGTH(4) | BIB_CRC(0));\n\tconfig_rom[1] = cpu_to_be32(BIB_BUS_NAME);\n\tconfig_rom[2] = cpu_to_be32(\n\t\tBIB_LINK_SPEED(card->link_speed) |\n\t\tBIB_GENERATION(card->config_rom_generation++ % 14 + 2) |\n\t\tBIB_MAX_ROM(2) |\n\t\tBIB_MAX_RECEIVE(card->max_receive) |\n\t\tBIB_BMC | BIB_ISC | BIB_CMC | BIB_IRMC);\n\tconfig_rom[3] = cpu_to_be32(card->guid >> 32);\n\tconfig_rom[4] = cpu_to_be32(card->guid);\n\n\t \n\tconfig_rom[6] = cpu_to_be32(NODE_CAPABILITIES);\n\ti = 7;\n\tj = 7 + descriptor_count;\n\n\t \n\tlist_for_each_entry (desc, &descriptor_list, link) {\n\t\tif (desc->immediate > 0)\n\t\t\tconfig_rom[i++] = cpu_to_be32(desc->immediate);\n\t\tconfig_rom[i] = cpu_to_be32(desc->key | (j - i));\n\t\ti++;\n\t\tj += desc->length;\n\t}\n\n\t \n\tconfig_rom[5] = cpu_to_be32((i - 5 - 1) << 16);\n\n\t \n\tlist_for_each_entry (desc, &descriptor_list, link) {\n\t\tfor (k = 0; k < desc->length; k++)\n\t\t\tconfig_rom[i + k] = cpu_to_be32(desc->data[k]);\n\t\ti += desc->length;\n\t}\n\n\t \n\tfor (i = 0; i < j; i += length + 1)\n\t\tlength = fw_compute_block_crc(config_rom + i);\n\n\tWARN_ON(j != config_rom_length);\n}\n\nstatic void update_config_roms(void)\n{\n\tstruct fw_card *card;\n\n\tlist_for_each_entry (card, &card_list, link) {\n\t\tgenerate_config_rom(card, tmp_config_rom);\n\t\tcard->driver->set_config_rom(card, tmp_config_rom,\n\t\t\t\t\t     config_rom_length);\n\t}\n}\n\nstatic size_t required_space(struct fw_descriptor *desc)\n{\n\t \n\treturn desc->length + 1 + (desc->immediate > 0 ? 1 : 0);\n}\n\nint fw_core_add_descriptor(struct fw_descriptor *desc)\n{\n\tsize_t i;\n\tint ret;\n\n\t \n\ti = 0;\n\twhile (i < desc->length)\n\t\ti += (desc->data[i] >> 16) + 1;\n\n\tif (i != desc->length)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card_mutex);\n\n\tif (config_rom_length + required_space(desc) > 256) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tlist_add_tail(&desc->link, &descriptor_list);\n\t\tconfig_rom_length += required_space(desc);\n\t\tdescriptor_count++;\n\t\tif (desc->immediate > 0)\n\t\t\tdescriptor_count++;\n\t\tupdate_config_roms();\n\t\tret = 0;\n\t}\n\n\tmutex_unlock(&card_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fw_core_add_descriptor);\n\nvoid fw_core_remove_descriptor(struct fw_descriptor *desc)\n{\n\tmutex_lock(&card_mutex);\n\n\tlist_del(&desc->link);\n\tconfig_rom_length -= required_space(desc);\n\tdescriptor_count--;\n\tif (desc->immediate > 0)\n\t\tdescriptor_count--;\n\tupdate_config_roms();\n\n\tmutex_unlock(&card_mutex);\n}\nEXPORT_SYMBOL(fw_core_remove_descriptor);\n\nstatic int reset_bus(struct fw_card *card, bool short_reset)\n{\n\tint reg = short_reset ? 5 : 1;\n\tint bit = short_reset ? PHY_BUS_SHORT_RESET : PHY_BUS_RESET;\n\n\treturn card->driver->update_phy_reg(card, reg, 0, bit);\n}\n\nvoid fw_schedule_bus_reset(struct fw_card *card, bool delayed, bool short_reset)\n{\n\t \n\tcard->br_short = short_reset;\n\n\t \n\tfw_card_get(card);\n\tif (!queue_delayed_work(fw_workqueue, &card->br_work,\n\t\t\t\tdelayed ? DIV_ROUND_UP(HZ, 100) : 0))\n\t\tfw_card_put(card);\n}\nEXPORT_SYMBOL(fw_schedule_bus_reset);\n\nstatic void br_work(struct work_struct *work)\n{\n\tstruct fw_card *card = container_of(work, struct fw_card, br_work.work);\n\n\t \n\tif (card->reset_jiffies != 0 &&\n\t    time_before64(get_jiffies_64(), card->reset_jiffies + 2 * HZ)) {\n\t\tif (!queue_delayed_work(fw_workqueue, &card->br_work, 2 * HZ))\n\t\t\tfw_card_put(card);\n\t\treturn;\n\t}\n\n\tfw_send_phy_config(card, FW_PHY_CONFIG_NO_NODE_ID, card->generation,\n\t\t\t   FW_PHY_CONFIG_CURRENT_GAP_COUNT);\n\treset_bus(card, card->br_short);\n\tfw_card_put(card);\n}\n\nstatic void allocate_broadcast_channel(struct fw_card *card, int generation)\n{\n\tint channel, bandwidth = 0;\n\n\tif (!card->broadcast_channel_allocated) {\n\t\tfw_iso_resource_manage(card, generation, 1ULL << 31,\n\t\t\t\t       &channel, &bandwidth, true);\n\t\tif (channel != 31) {\n\t\t\tfw_notice(card, \"failed to allocate broadcast channel\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcard->broadcast_channel_allocated = true;\n\t}\n\n\tdevice_for_each_child(card->device, (void *)(long)generation,\n\t\t\t      fw_device_set_broadcast_channel);\n}\n\nstatic const char gap_count_table[] = {\n\t63, 5, 7, 8, 10, 13, 16, 18, 21, 24, 26, 29, 32, 35, 37, 40\n};\n\nvoid fw_schedule_bm_work(struct fw_card *card, unsigned long delay)\n{\n\tfw_card_get(card);\n\tif (!schedule_delayed_work(&card->bm_work, delay))\n\t\tfw_card_put(card);\n}\n\nstatic void bm_work(struct work_struct *work)\n{\n\tstruct fw_card *card = container_of(work, struct fw_card, bm_work.work);\n\tstruct fw_device *root_device, *irm_device;\n\tstruct fw_node *root_node;\n\tint root_id, new_root_id, irm_id, bm_id, local_id;\n\tint gap_count, generation, grace, rcode;\n\tbool do_reset = false;\n\tbool root_device_is_running;\n\tbool root_device_is_cmc;\n\tbool irm_is_1394_1995_only;\n\tbool keep_this_irm;\n\t__be32 transaction_data[2];\n\n\tspin_lock_irq(&card->lock);\n\n\tif (card->local_node == NULL) {\n\t\tspin_unlock_irq(&card->lock);\n\t\tgoto out_put_card;\n\t}\n\n\tgeneration = card->generation;\n\n\troot_node = card->root_node;\n\tfw_node_get(root_node);\n\troot_device = root_node->data;\n\troot_device_is_running = root_device &&\n\t\t\tatomic_read(&root_device->state) == FW_DEVICE_RUNNING;\n\troot_device_is_cmc = root_device && root_device->cmc;\n\n\tirm_device = card->irm_node->data;\n\tirm_is_1394_1995_only = irm_device && irm_device->config_rom &&\n\t\t\t(irm_device->config_rom[2] & 0x000000f0) == 0;\n\n\t \n\tkeep_this_irm = irm_device && irm_device->config_rom &&\n\t\t\tirm_device->config_rom[3] >> 8 == CANON_OUI;\n\n\troot_id  = root_node->node_id;\n\tirm_id   = card->irm_node->node_id;\n\tlocal_id = card->local_node->node_id;\n\n\tgrace = time_after64(get_jiffies_64(),\n\t\t\t     card->reset_jiffies + DIV_ROUND_UP(HZ, 8));\n\n\tif ((is_next_generation(generation, card->bm_generation) &&\n\t     !card->bm_abdicate) ||\n\t    (card->bm_generation != generation && grace)) {\n\t\t \n\n\t\tif (!card->irm_node->link_on) {\n\t\t\tnew_root_id = local_id;\n\t\t\tfw_notice(card, \"%s, making local node (%02x) root\\n\",\n\t\t\t\t  \"IRM has link off\", new_root_id);\n\t\t\tgoto pick_me;\n\t\t}\n\n\t\tif (irm_is_1394_1995_only && !keep_this_irm) {\n\t\t\tnew_root_id = local_id;\n\t\t\tfw_notice(card, \"%s, making local node (%02x) root\\n\",\n\t\t\t\t  \"IRM is not 1394a compliant\", new_root_id);\n\t\t\tgoto pick_me;\n\t\t}\n\n\t\ttransaction_data[0] = cpu_to_be32(0x3f);\n\t\ttransaction_data[1] = cpu_to_be32(local_id);\n\n\t\tspin_unlock_irq(&card->lock);\n\n\t\trcode = fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,\n\t\t\t\tirm_id, generation, SCODE_100,\n\t\t\t\tCSR_REGISTER_BASE + CSR_BUS_MANAGER_ID,\n\t\t\t\ttransaction_data, 8);\n\n\t\tif (rcode == RCODE_GENERATION)\n\t\t\t \n\t\t\tgoto out;\n\n\t\tbm_id = be32_to_cpu(transaction_data[0]);\n\n\t\tspin_lock_irq(&card->lock);\n\t\tif (rcode == RCODE_COMPLETE && generation == card->generation)\n\t\t\tcard->bm_node_id =\n\t\t\t    bm_id == 0x3f ? local_id : 0xffc0 | bm_id;\n\t\tspin_unlock_irq(&card->lock);\n\n\t\tif (rcode == RCODE_COMPLETE && bm_id != 0x3f) {\n\t\t\t \n\t\t\tif (local_id == irm_id)\n\t\t\t\tallocate_broadcast_channel(card, generation);\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rcode == RCODE_SEND_ERROR) {\n\t\t\t \n\t\t\tfw_schedule_bm_work(card, DIV_ROUND_UP(HZ, 8));\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irq(&card->lock);\n\n\t\tif (rcode != RCODE_COMPLETE && !keep_this_irm) {\n\t\t\t \n\t\t\tnew_root_id = local_id;\n\t\t\tfw_notice(card, \"BM lock failed (%s), making local node (%02x) root\\n\",\n\t\t\t\t  fw_rcode_string(rcode), new_root_id);\n\t\t\tgoto pick_me;\n\t\t}\n\t} else if (card->bm_generation != generation) {\n\t\t \n\t\tspin_unlock_irq(&card->lock);\n\t\tfw_schedule_bm_work(card, DIV_ROUND_UP(HZ, 8));\n\t\tgoto out;\n\t}\n\n\t \n\tcard->bm_generation = generation;\n\n\tif (root_device == NULL) {\n\t\t \n\t\tnew_root_id = local_id;\n\t} else if (!root_device_is_running) {\n\t\t \n\t\tspin_unlock_irq(&card->lock);\n\t\tgoto out;\n\t} else if (root_device_is_cmc) {\n\t\t \n\t\tnew_root_id = root_id;\n\t} else {\n\t\t \n\t\tnew_root_id = local_id;\n\t}\n\n pick_me:\n\t \n\tif (!card->beta_repeaters_present &&\n\t    root_node->max_hops < ARRAY_SIZE(gap_count_table))\n\t\tgap_count = gap_count_table[root_node->max_hops];\n\telse\n\t\tgap_count = 63;\n\n\t \n\n\tif (card->bm_retries++ < 5 &&\n\t    (card->gap_count != gap_count || new_root_id != root_id))\n\t\tdo_reset = true;\n\n\tspin_unlock_irq(&card->lock);\n\n\tif (do_reset) {\n\t\tfw_notice(card, \"phy config: new root=%x, gap_count=%d\\n\",\n\t\t\t  new_root_id, gap_count);\n\t\tfw_send_phy_config(card, new_root_id, generation, gap_count);\n\t\treset_bus(card, true);\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (root_device_is_cmc) {\n\t\t \n\t\ttransaction_data[0] = cpu_to_be32(CSR_STATE_BIT_CMSTR);\n\t\trcode = fw_run_transaction(card, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\troot_id, generation, SCODE_100,\n\t\t\t\tCSR_REGISTER_BASE + CSR_STATE_SET,\n\t\t\t\ttransaction_data, 4);\n\t\tif (rcode == RCODE_GENERATION)\n\t\t\tgoto out;\n\t}\n\n\tif (local_id == irm_id)\n\t\tallocate_broadcast_channel(card, generation);\n\n out:\n\tfw_node_put(root_node);\n out_put_card:\n\tfw_card_put(card);\n}\n\nvoid fw_card_initialize(struct fw_card *card,\n\t\t\tconst struct fw_card_driver *driver,\n\t\t\tstruct device *device)\n{\n\tstatic atomic_t index = ATOMIC_INIT(-1);\n\n\tcard->index = atomic_inc_return(&index);\n\tcard->driver = driver;\n\tcard->device = device;\n\tcard->current_tlabel = 0;\n\tcard->tlabel_mask = 0;\n\tcard->split_timeout_hi = DEFAULT_SPLIT_TIMEOUT / 8000;\n\tcard->split_timeout_lo = (DEFAULT_SPLIT_TIMEOUT % 8000) << 19;\n\tcard->split_timeout_cycles = DEFAULT_SPLIT_TIMEOUT;\n\tcard->split_timeout_jiffies =\n\t\t\tDIV_ROUND_UP(DEFAULT_SPLIT_TIMEOUT * HZ, 8000);\n\tcard->color = 0;\n\tcard->broadcast_channel = BROADCAST_CHANNEL_INITIAL;\n\n\tkref_init(&card->kref);\n\tinit_completion(&card->done);\n\tINIT_LIST_HEAD(&card->transaction_list);\n\tINIT_LIST_HEAD(&card->phy_receiver_list);\n\tspin_lock_init(&card->lock);\n\n\tcard->local_node = NULL;\n\n\tINIT_DELAYED_WORK(&card->br_work, br_work);\n\tINIT_DELAYED_WORK(&card->bm_work, bm_work);\n}\nEXPORT_SYMBOL(fw_card_initialize);\n\nint fw_card_add(struct fw_card *card,\n\t\tu32 max_receive, u32 link_speed, u64 guid)\n{\n\tint ret;\n\n\tcard->max_receive = max_receive;\n\tcard->link_speed = link_speed;\n\tcard->guid = guid;\n\n\tmutex_lock(&card_mutex);\n\n\tgenerate_config_rom(card, tmp_config_rom);\n\tret = card->driver->enable(card, tmp_config_rom, config_rom_length);\n\tif (ret == 0)\n\t\tlist_add_tail(&card->link, &card_list);\n\n\tmutex_unlock(&card_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fw_card_add);\n\n \n\nstatic int dummy_read_phy_reg(struct fw_card *card, int address)\n{\n\treturn -ENODEV;\n}\n\nstatic int dummy_update_phy_reg(struct fw_card *card, int address,\n\t\t\t\tint clear_bits, int set_bits)\n{\n\treturn -ENODEV;\n}\n\nstatic void dummy_send_request(struct fw_card *card, struct fw_packet *packet)\n{\n\tpacket->callback(packet, card, RCODE_CANCELLED);\n}\n\nstatic void dummy_send_response(struct fw_card *card, struct fw_packet *packet)\n{\n\tpacket->callback(packet, card, RCODE_CANCELLED);\n}\n\nstatic int dummy_cancel_packet(struct fw_card *card, struct fw_packet *packet)\n{\n\treturn -ENOENT;\n}\n\nstatic int dummy_enable_phys_dma(struct fw_card *card,\n\t\t\t\t int node_id, int generation)\n{\n\treturn -ENODEV;\n}\n\nstatic struct fw_iso_context *dummy_allocate_iso_context(struct fw_card *card,\n\t\t\t\tint type, int channel, size_t header_size)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic u32 dummy_read_csr(struct fw_card *card, int csr_offset)\n{\n\treturn 0;\n}\n\nstatic void dummy_write_csr(struct fw_card *card, int csr_offset, u32 value)\n{\n}\n\nstatic int dummy_start_iso(struct fw_iso_context *ctx,\n\t\t\t   s32 cycle, u32 sync, u32 tags)\n{\n\treturn -ENODEV;\n}\n\nstatic int dummy_set_iso_channels(struct fw_iso_context *ctx, u64 *channels)\n{\n\treturn -ENODEV;\n}\n\nstatic int dummy_queue_iso(struct fw_iso_context *ctx, struct fw_iso_packet *p,\n\t\t\t   struct fw_iso_buffer *buffer, unsigned long payload)\n{\n\treturn -ENODEV;\n}\n\nstatic void dummy_flush_queue_iso(struct fw_iso_context *ctx)\n{\n}\n\nstatic int dummy_flush_iso_completions(struct fw_iso_context *ctx)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct fw_card_driver dummy_driver_template = {\n\t.read_phy_reg\t\t= dummy_read_phy_reg,\n\t.update_phy_reg\t\t= dummy_update_phy_reg,\n\t.send_request\t\t= dummy_send_request,\n\t.send_response\t\t= dummy_send_response,\n\t.cancel_packet\t\t= dummy_cancel_packet,\n\t.enable_phys_dma\t= dummy_enable_phys_dma,\n\t.read_csr\t\t= dummy_read_csr,\n\t.write_csr\t\t= dummy_write_csr,\n\t.allocate_iso_context\t= dummy_allocate_iso_context,\n\t.start_iso\t\t= dummy_start_iso,\n\t.set_iso_channels\t= dummy_set_iso_channels,\n\t.queue_iso\t\t= dummy_queue_iso,\n\t.flush_queue_iso\t= dummy_flush_queue_iso,\n\t.flush_iso_completions\t= dummy_flush_iso_completions,\n};\n\nvoid fw_card_release(struct kref *kref)\n{\n\tstruct fw_card *card = container_of(kref, struct fw_card, kref);\n\n\tcomplete(&card->done);\n}\nEXPORT_SYMBOL_GPL(fw_card_release);\n\nvoid fw_core_remove_card(struct fw_card *card)\n{\n\tstruct fw_card_driver dummy_driver = dummy_driver_template;\n\tunsigned long flags;\n\n\tcard->driver->update_phy_reg(card, 4,\n\t\t\t\t     PHY_LINK_ACTIVE | PHY_CONTENDER, 0);\n\tfw_schedule_bus_reset(card, false, true);\n\n\tmutex_lock(&card_mutex);\n\tlist_del_init(&card->link);\n\tmutex_unlock(&card_mutex);\n\n\t \n\tdummy_driver.free_iso_context\t= card->driver->free_iso_context;\n\tdummy_driver.stop_iso\t\t= card->driver->stop_iso;\n\tcard->driver = &dummy_driver;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tfw_destroy_nodes(card);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\t \n\tfw_card_put(card);\n\twait_for_completion(&card->done);\n\n\tWARN_ON(!list_empty(&card->transaction_list));\n}\nEXPORT_SYMBOL(fw_core_remove_card);\n\n \nint fw_card_read_cycle_time(struct fw_card *card, u32 *cycle_time)\n{\n\tif (card->driver->read_csr == dummy_read_csr)\n\t\treturn -ENODEV;\n\n\t \n\t\n\t*cycle_time = card->driver->read_csr(card, CSR_CYCLE_TIME);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fw_card_read_cycle_time);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}