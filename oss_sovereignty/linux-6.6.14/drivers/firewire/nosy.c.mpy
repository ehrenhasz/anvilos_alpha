{
  "module_name": "nosy.c",
  "hash_id": "f8590d993e4cc80d72c3940fb84a336b5edd9275e5ea0e3112916365108c3f47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/nosy.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/sched.h>  \n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/time64.h>\n#include <linux/timex.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n#include <linux/dma-mapping.h>\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n\n#include \"nosy.h\"\n#include \"nosy-user.h\"\n\n#define TCODE_PHY_PACKET\t\t0x10\n#define PCI_DEVICE_ID_TI_PCILYNX\t0x8000\n\nstatic char driver_name[] = KBUILD_MODNAME;\n\n \nstruct pcl {\n\t__le32 next;\n\t__le32 async_error_next;\n\tu32 user_data;\n\t__le32 pcl_status;\n\t__le32 remaining_transfer_count;\n\t__le32 next_data_buffer;\n\tstruct {\n\t\t__le32 control;\n\t\t__le32 pointer;\n\t} buffer[13];\n};\n\nstruct packet {\n\tunsigned int length;\n\tchar data[];\n};\n\nstruct packet_buffer {\n\tchar *data;\n\tsize_t capacity;\n\tlong total_packet_count, lost_packet_count;\n\tatomic_t size;\n\tstruct packet *head, *tail;\n\twait_queue_head_t wait;\n};\n\nstruct pcilynx {\n\tstruct pci_dev *pci_device;\n\t__iomem char *registers;\n\n\tstruct pcl *rcv_start_pcl, *rcv_pcl;\n\t__le32 *rcv_buffer;\n\n\tdma_addr_t rcv_start_pcl_bus, rcv_pcl_bus, rcv_buffer_bus;\n\n\tspinlock_t client_list_lock;\n\tstruct list_head client_list;\n\n\tstruct miscdevice misc;\n\tstruct list_head link;\n\tstruct kref kref;\n};\n\nstatic inline struct pcilynx *\nlynx_get(struct pcilynx *lynx)\n{\n\tkref_get(&lynx->kref);\n\n\treturn lynx;\n}\n\nstatic void\nlynx_release(struct kref *kref)\n{\n\tkfree(container_of(kref, struct pcilynx, kref));\n}\n\nstatic inline void\nlynx_put(struct pcilynx *lynx)\n{\n\tkref_put(&lynx->kref, lynx_release);\n}\n\nstruct client {\n\tstruct pcilynx *lynx;\n\tu32 tcode_mask;\n\tstruct packet_buffer buffer;\n\tstruct list_head link;\n};\n\nstatic DEFINE_MUTEX(card_mutex);\nstatic LIST_HEAD(card_list);\n\nstatic int\npacket_buffer_init(struct packet_buffer *buffer, size_t capacity)\n{\n\tbuffer->data = kmalloc(capacity, GFP_KERNEL);\n\tif (buffer->data == NULL)\n\t\treturn -ENOMEM;\n\tbuffer->head = (struct packet *) buffer->data;\n\tbuffer->tail = (struct packet *) buffer->data;\n\tbuffer->capacity = capacity;\n\tbuffer->lost_packet_count = 0;\n\tatomic_set(&buffer->size, 0);\n\tinit_waitqueue_head(&buffer->wait);\n\n\treturn 0;\n}\n\nstatic void\npacket_buffer_destroy(struct packet_buffer *buffer)\n{\n\tkfree(buffer->data);\n}\n\nstatic int\npacket_buffer_get(struct client *client, char __user *data, size_t user_length)\n{\n\tstruct packet_buffer *buffer = &client->buffer;\n\tsize_t length;\n\tchar *end;\n\n\tif (wait_event_interruptible(buffer->wait,\n\t\t\t\t     atomic_read(&buffer->size) > 0) ||\n\t\t\t\t     list_empty(&client->lynx->link))\n\t\treturn -ERESTARTSYS;\n\n\tif (atomic_read(&buffer->size) == 0)\n\t\treturn -ENODEV;\n\n\t \n\n\tend = buffer->data + buffer->capacity;\n\tlength = buffer->head->length;\n\n\tif (&buffer->head->data[length] < end) {\n\t\tif (copy_to_user(data, buffer->head->data, length))\n\t\t\treturn -EFAULT;\n\t\tbuffer->head = (struct packet *) &buffer->head->data[length];\n\t} else {\n\t\tsize_t split = end - buffer->head->data;\n\n\t\tif (copy_to_user(data, buffer->head->data, split))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(data + split, buffer->data, length - split))\n\t\t\treturn -EFAULT;\n\t\tbuffer->head = (struct packet *) &buffer->data[length - split];\n\t}\n\n\t \n\tatomic_sub(sizeof(struct packet) + length, &buffer->size);\n\n\treturn length;\n}\n\nstatic void\npacket_buffer_put(struct packet_buffer *buffer, void *data, size_t length)\n{\n\tchar *end;\n\n\tbuffer->total_packet_count++;\n\n\tif (buffer->capacity <\n\t    atomic_read(&buffer->size) + sizeof(struct packet) + length) {\n\t\tbuffer->lost_packet_count++;\n\t\treturn;\n\t}\n\n\tend = buffer->data + buffer->capacity;\n\tbuffer->tail->length = length;\n\n\tif (&buffer->tail->data[length] < end) {\n\t\tmemcpy(buffer->tail->data, data, length);\n\t\tbuffer->tail = (struct packet *) &buffer->tail->data[length];\n\t} else {\n\t\tsize_t split = end - buffer->tail->data;\n\n\t\tmemcpy(buffer->tail->data, data, split);\n\t\tmemcpy(buffer->data, data + split, length - split);\n\t\tbuffer->tail = (struct packet *) &buffer->data[length - split];\n\t}\n\n\t \n\n\tatomic_add(sizeof(struct packet) + length, &buffer->size);\n\twake_up_interruptible(&buffer->wait);\n}\n\nstatic inline void\nreg_write(struct pcilynx *lynx, int offset, u32 data)\n{\n\twritel(data, lynx->registers + offset);\n}\n\nstatic inline u32\nreg_read(struct pcilynx *lynx, int offset)\n{\n\treturn readl(lynx->registers + offset);\n}\n\nstatic inline void\nreg_set_bits(struct pcilynx *lynx, int offset, u32 mask)\n{\n\treg_write(lynx, offset, (reg_read(lynx, offset) | mask));\n}\n\n \nstatic inline void\nrun_pcl(struct pcilynx *lynx, dma_addr_t pcl_bus,\n\t\t\t   int dmachan)\n{\n\treg_write(lynx, DMA0_CURRENT_PCL + dmachan * 0x20, pcl_bus);\n\treg_write(lynx, DMA0_CHAN_CTRL + dmachan * 0x20,\n\t\t  DMA_CHAN_CTRL_ENABLE | DMA_CHAN_CTRL_LINK);\n}\n\nstatic int\nset_phy_reg(struct pcilynx *lynx, int addr, int val)\n{\n\tif (addr > 15) {\n\t\tdev_err(&lynx->pci_device->dev,\n\t\t\t\"PHY register address %d out of range\\n\", addr);\n\t\treturn -1;\n\t}\n\tif (val > 0xff) {\n\t\tdev_err(&lynx->pci_device->dev,\n\t\t\t\"PHY register value %d out of range\\n\", val);\n\t\treturn -1;\n\t}\n\treg_write(lynx, LINK_PHY, LINK_PHY_WRITE |\n\t\t  LINK_PHY_ADDR(addr) | LINK_PHY_WDATA(val));\n\n\treturn 0;\n}\n\nstatic int\nnosy_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct client *client;\n\tstruct pcilynx *tmp, *lynx = NULL;\n\n\tmutex_lock(&card_mutex);\n\tlist_for_each_entry(tmp, &card_list, link)\n\t\tif (tmp->misc.minor == minor) {\n\t\t\tlynx = lynx_get(tmp);\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&card_mutex);\n\tif (lynx == NULL)\n\t\treturn -ENODEV;\n\n\tclient = kmalloc(sizeof *client, GFP_KERNEL);\n\tif (client == NULL)\n\t\tgoto fail;\n\n\tclient->tcode_mask = ~0;\n\tclient->lynx = lynx;\n\tINIT_LIST_HEAD(&client->link);\n\n\tif (packet_buffer_init(&client->buffer, 128 * 1024) < 0)\n\t\tgoto fail;\n\n\tfile->private_data = client;\n\n\treturn stream_open(inode, file);\nfail:\n\tkfree(client);\n\tlynx_put(lynx);\n\n\treturn -ENOMEM;\n}\n\nstatic int\nnosy_release(struct inode *inode, struct file *file)\n{\n\tstruct client *client = file->private_data;\n\tstruct pcilynx *lynx = client->lynx;\n\n\tspin_lock_irq(&lynx->client_list_lock);\n\tlist_del_init(&client->link);\n\tspin_unlock_irq(&lynx->client_list_lock);\n\n\tpacket_buffer_destroy(&client->buffer);\n\tkfree(client);\n\tlynx_put(lynx);\n\n\treturn 0;\n}\n\nstatic __poll_t\nnosy_poll(struct file *file, poll_table *pt)\n{\n\tstruct client *client = file->private_data;\n\t__poll_t ret = 0;\n\n\tpoll_wait(file, &client->buffer.wait, pt);\n\n\tif (atomic_read(&client->buffer.size) > 0)\n\t\tret = EPOLLIN | EPOLLRDNORM;\n\n\tif (list_empty(&client->lynx->link))\n\t\tret |= EPOLLHUP;\n\n\treturn ret;\n}\n\nstatic ssize_t\nnosy_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)\n{\n\tstruct client *client = file->private_data;\n\n\treturn packet_buffer_get(client, buffer, count);\n}\n\nstatic long\nnosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\n\tcase NOSY_IOC_START:\n\t\tret = -EBUSY;\n\t\tspin_lock_irq(client_list_lock);\n\t\tif (list_empty(&client->link)) {\n\t\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn ret;\n\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t\t \n\t}\n}\n\nstatic const struct file_operations nosy_ops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.read =\t\t\tnosy_read,\n\t.unlocked_ioctl =\tnosy_ioctl,\n\t.poll =\t\t\tnosy_poll,\n\t.open =\t\t\tnosy_open,\n\t.release =\t\tnosy_release,\n};\n\n#define PHY_PACKET_SIZE 12  \n\nstatic void\npacket_irq_handler(struct pcilynx *lynx)\n{\n\tstruct client *client;\n\tu32 tcode_mask, tcode, timestamp;\n\tsize_t length;\n\tstruct timespec64 ts64;\n\n\t \n\n\tlength = __le32_to_cpu(lynx->rcv_pcl->pcl_status) & 0x00001fff;\n\ttcode  = __le32_to_cpu(lynx->rcv_buffer[1]) >> 4 & 0xf;\n\n\tktime_get_real_ts64(&ts64);\n\ttimestamp = ts64.tv_nsec / NSEC_PER_USEC;\n\tlynx->rcv_buffer[0] = (__force __le32)timestamp;\n\n\tif (length == PHY_PACKET_SIZE)\n\t\ttcode_mask = 1 << TCODE_PHY_PACKET;\n\telse\n\t\ttcode_mask = 1 << tcode;\n\n\tspin_lock(&lynx->client_list_lock);\n\n\tlist_for_each_entry(client, &lynx->client_list, link)\n\t\tif (client->tcode_mask & tcode_mask)\n\t\t\tpacket_buffer_put(&client->buffer,\n\t\t\t\t\t  lynx->rcv_buffer, length + 4);\n\n\tspin_unlock(&lynx->client_list_lock);\n}\n\nstatic void\nbus_reset_irq_handler(struct pcilynx *lynx)\n{\n\tstruct client *client;\n\tstruct timespec64 ts64;\n\tu32    timestamp;\n\n\tktime_get_real_ts64(&ts64);\n\ttimestamp = ts64.tv_nsec / NSEC_PER_USEC;\n\n\tspin_lock(&lynx->client_list_lock);\n\n\tlist_for_each_entry(client, &lynx->client_list, link)\n\t\tpacket_buffer_put(&client->buffer, &timestamp, 4);\n\n\tspin_unlock(&lynx->client_list_lock);\n}\n\nstatic irqreturn_t\nirq_handler(int irq, void *device)\n{\n\tstruct pcilynx *lynx = device;\n\tu32 pci_int_status;\n\n\tpci_int_status = reg_read(lynx, PCI_INT_STATUS);\n\n\tif (pci_int_status == ~0)\n\t\t \n\t\treturn IRQ_NONE;\n\n\tif ((pci_int_status & PCI_INT_INT_PEND) == 0)\n\t\t \n\t\treturn IRQ_NONE;\n\n\tif ((pci_int_status & PCI_INT_P1394_INT) != 0) {\n\t\tu32 link_int_status;\n\n\t\tlink_int_status = reg_read(lynx, LINK_INT_STATUS);\n\t\treg_write(lynx, LINK_INT_STATUS, link_int_status);\n\n\t\tif ((link_int_status & LINK_INT_PHY_BUSRESET) > 0)\n\t\t\tbus_reset_irq_handler(lynx);\n\t}\n\n\t \n\n\treg_write(lynx, PCI_INT_STATUS, pci_int_status);\n\n\tif ((pci_int_status & PCI_INT_DMA0_HLT) > 0) {\n\t\tpacket_irq_handler(lynx);\n\t\trun_pcl(lynx, lynx->rcv_start_pcl_bus, 0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nremove_card(struct pci_dev *dev)\n{\n\tstruct pcilynx *lynx = pci_get_drvdata(dev);\n\tstruct client *client;\n\n\tmutex_lock(&card_mutex);\n\tlist_del_init(&lynx->link);\n\tmisc_deregister(&lynx->misc);\n\tmutex_unlock(&card_mutex);\n\n\treg_write(lynx, PCI_INT_ENABLE, 0);\n\tfree_irq(lynx->pci_device->irq, lynx);\n\n\tspin_lock_irq(&lynx->client_list_lock);\n\tlist_for_each_entry(client, &lynx->client_list, link)\n\t\twake_up_interruptible(&client->buffer.wait);\n\tspin_unlock_irq(&lynx->client_list_lock);\n\n\tdma_free_coherent(&lynx->pci_device->dev, sizeof(struct pcl),\n\t\t\t  lynx->rcv_start_pcl, lynx->rcv_start_pcl_bus);\n\tdma_free_coherent(&lynx->pci_device->dev, sizeof(struct pcl),\n\t\t\t  lynx->rcv_pcl, lynx->rcv_pcl_bus);\n\tdma_free_coherent(&lynx->pci_device->dev, PAGE_SIZE, lynx->rcv_buffer,\n\t\t\t  lynx->rcv_buffer_bus);\n\n\tiounmap(lynx->registers);\n\tpci_disable_device(dev);\n\tlynx_put(lynx);\n}\n\n#define RCV_BUFFER_SIZE (16 * 1024)\n\nstatic int\nadd_card(struct pci_dev *dev, const struct pci_device_id *unused)\n{\n\tstruct pcilynx *lynx;\n\tu32 p, end;\n\tint ret, i;\n\n\tif (dma_set_mask(&dev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(&dev->dev,\n\t\t    \"DMA address limits not supported for PCILynx hardware\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (pci_enable_device(dev)) {\n\t\tdev_err(&dev->dev, \"Failed to enable PCILynx hardware\\n\");\n\t\treturn -ENXIO;\n\t}\n\tpci_set_master(dev);\n\n\tlynx = kzalloc(sizeof *lynx, GFP_KERNEL);\n\tif (lynx == NULL) {\n\t\tdev_err(&dev->dev, \"Failed to allocate control structure\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_disable;\n\t}\n\tlynx->pci_device = dev;\n\tpci_set_drvdata(dev, lynx);\n\n\tspin_lock_init(&lynx->client_list_lock);\n\tINIT_LIST_HEAD(&lynx->client_list);\n\tkref_init(&lynx->kref);\n\n\tlynx->registers = ioremap(pci_resource_start(dev, 0),\n\t\t\t\t\t  PCILYNX_MAX_REGISTER);\n\tif (lynx->registers == NULL) {\n\t\tdev_err(&dev->dev, \"Failed to map registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_deallocate_lynx;\n\t}\n\n\tlynx->rcv_start_pcl = dma_alloc_coherent(&lynx->pci_device->dev,\n\t\t\t\t\t\t sizeof(struct pcl),\n\t\t\t\t\t\t &lynx->rcv_start_pcl_bus,\n\t\t\t\t\t\t GFP_KERNEL);\n\tlynx->rcv_pcl = dma_alloc_coherent(&lynx->pci_device->dev,\n\t\t\t\t\t   sizeof(struct pcl),\n\t\t\t\t\t   &lynx->rcv_pcl_bus, GFP_KERNEL);\n\tlynx->rcv_buffer = dma_alloc_coherent(&lynx->pci_device->dev,\n\t\t\t\t\t      RCV_BUFFER_SIZE,\n\t\t\t\t\t      &lynx->rcv_buffer_bus, GFP_KERNEL);\n\tif (lynx->rcv_start_pcl == NULL ||\n\t    lynx->rcv_pcl == NULL ||\n\t    lynx->rcv_buffer == NULL) {\n\t\tdev_err(&dev->dev, \"Failed to allocate receive buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_deallocate_buffers;\n\t}\n\tlynx->rcv_start_pcl->next\t= cpu_to_le32(lynx->rcv_pcl_bus);\n\tlynx->rcv_pcl->next\t\t= cpu_to_le32(PCL_NEXT_INVALID);\n\tlynx->rcv_pcl->async_error_next\t= cpu_to_le32(PCL_NEXT_INVALID);\n\n\tlynx->rcv_pcl->buffer[0].control =\n\t\t\tcpu_to_le32(PCL_CMD_RCV | PCL_BIGENDIAN | 2044);\n\tlynx->rcv_pcl->buffer[0].pointer =\n\t\t\tcpu_to_le32(lynx->rcv_buffer_bus + 4);\n\tp = lynx->rcv_buffer_bus + 2048;\n\tend = lynx->rcv_buffer_bus + RCV_BUFFER_SIZE;\n\tfor (i = 1; p < end; i++, p += 2048) {\n\t\tlynx->rcv_pcl->buffer[i].control =\n\t\t\tcpu_to_le32(PCL_CMD_RCV | PCL_BIGENDIAN | 2048);\n\t\tlynx->rcv_pcl->buffer[i].pointer = cpu_to_le32(p);\n\t}\n\tlynx->rcv_pcl->buffer[i - 1].control |= cpu_to_le32(PCL_LAST_BUFF);\n\n\treg_set_bits(lynx, MISC_CONTROL, MISC_CONTROL_SWRESET);\n\t \n\treg_write(lynx, DMA0_CHAN_CTRL, 0);\n\treg_write(lynx, DMA_GLOBAL_REGISTER, 0x00 << 24);\n\n#if 0\n\t \n\tif ((get_phy_reg(lynx, 2) & 0xe0) == 0xe0) {\n\t\tlynx->phyic.reg_1394a = 1;\n\t\tPRINT(KERN_INFO, lynx->id,\n\t\t      \"found 1394a conform PHY (using extended register set)\");\n\t\tlynx->phyic.vendor = get_phy_vendorid(lynx);\n\t\tlynx->phyic.product = get_phy_productid(lynx);\n\t} else {\n\t\tlynx->phyic.reg_1394a = 0;\n\t\tPRINT(KERN_INFO, lynx->id, \"found old 1394 PHY\");\n\t}\n#endif\n\n\t \n\treg_write(lynx, FIFO_SIZES, 255);\n\n\treg_set_bits(lynx, PCI_INT_ENABLE, PCI_INT_DMA_ALL);\n\n\treg_write(lynx, LINK_INT_ENABLE,\n\t\t  LINK_INT_PHY_TIME_OUT | LINK_INT_PHY_REG_RCVD |\n\t\t  LINK_INT_PHY_BUSRESET | LINK_INT_IT_STUCK |\n\t\t  LINK_INT_AT_STUCK | LINK_INT_SNTRJ |\n\t\t  LINK_INT_TC_ERR | LINK_INT_GRF_OVER_FLOW |\n\t\t  LINK_INT_ITF_UNDER_FLOW | LINK_INT_ATF_UNDER_FLOW);\n\n\t \n\tset_phy_reg(lynx, 4, 0);\n\n\t \n\treg_set_bits(lynx, LINK_CONTROL, LINK_CONTROL_SNOOP_ENABLE);\n\n\trun_pcl(lynx, lynx->rcv_start_pcl_bus, 0);\n\n\tif (request_irq(dev->irq, irq_handler, IRQF_SHARED,\n\t\t\tdriver_name, lynx)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Failed to allocate shared interrupt %d\\n\", dev->irq);\n\t\tret = -EIO;\n\t\tgoto fail_deallocate_buffers;\n\t}\n\n\tlynx->misc.parent = &dev->dev;\n\tlynx->misc.minor = MISC_DYNAMIC_MINOR;\n\tlynx->misc.name = \"nosy\";\n\tlynx->misc.fops = &nosy_ops;\n\n\tmutex_lock(&card_mutex);\n\tret = misc_register(&lynx->misc);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"Failed to register misc char device\\n\");\n\t\tmutex_unlock(&card_mutex);\n\t\tgoto fail_free_irq;\n\t}\n\tlist_add_tail(&lynx->link, &card_list);\n\tmutex_unlock(&card_mutex);\n\n\tdev_info(&dev->dev,\n\t\t \"Initialized PCILynx IEEE1394 card, irq=%d\\n\", dev->irq);\n\n\treturn 0;\n\nfail_free_irq:\n\treg_write(lynx, PCI_INT_ENABLE, 0);\n\tfree_irq(lynx->pci_device->irq, lynx);\n\nfail_deallocate_buffers:\n\tif (lynx->rcv_start_pcl)\n\t\tdma_free_coherent(&lynx->pci_device->dev, sizeof(struct pcl),\n\t\t\t\t  lynx->rcv_start_pcl,\n\t\t\t\t  lynx->rcv_start_pcl_bus);\n\tif (lynx->rcv_pcl)\n\t\tdma_free_coherent(&lynx->pci_device->dev, sizeof(struct pcl),\n\t\t\t\t  lynx->rcv_pcl, lynx->rcv_pcl_bus);\n\tif (lynx->rcv_buffer)\n\t\tdma_free_coherent(&lynx->pci_device->dev, PAGE_SIZE,\n\t\t\t\t  lynx->rcv_buffer, lynx->rcv_buffer_bus);\n\tiounmap(lynx->registers);\n\nfail_deallocate_lynx:\n\tkfree(lynx);\n\nfail_disable:\n\tpci_disable_device(dev);\n\n\treturn ret;\n}\n\nstatic struct pci_device_id pci_table[] = {\n\t{\n\t\t.vendor =    PCI_VENDOR_ID_TI,\n\t\t.device =    PCI_DEVICE_ID_TI_PCILYNX,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t},\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(pci, pci_table);\n\nstatic struct pci_driver lynx_pci_driver = {\n\t.name =\t\tdriver_name,\n\t.id_table =\tpci_table,\n\t.probe =\tadd_card,\n\t.remove =\tremove_card,\n};\n\nmodule_pci_driver(lynx_pci_driver);\n\nMODULE_AUTHOR(\"Kristian Hoegsberg\");\nMODULE_DESCRIPTION(\"Snoop mode driver for TI pcilynx 1394 controllers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}