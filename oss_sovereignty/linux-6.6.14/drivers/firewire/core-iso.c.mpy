{
  "module_name": "core-iso.c",
  "hash_id": "1a656ac4169808caa7e0f6d3de64ba622ec275fbd795db31d2591f1e44ecb6d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core-iso.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n\n#include <asm/byteorder.h>\n\n#include \"core.h\"\n\n \n\nint fw_iso_buffer_alloc(struct fw_iso_buffer *buffer, int page_count)\n{\n\tint i;\n\n\tbuffer->page_count = 0;\n\tbuffer->page_count_mapped = 0;\n\tbuffer->pages = kmalloc_array(page_count, sizeof(buffer->pages[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (buffer->pages == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tbuffer->pages[i] = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);\n\t\tif (buffer->pages[i] == NULL)\n\t\t\tbreak;\n\t}\n\tbuffer->page_count = i;\n\tif (i < page_count) {\n\t\tfw_iso_buffer_destroy(buffer, NULL);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint fw_iso_buffer_map_dma(struct fw_iso_buffer *buffer, struct fw_card *card,\n\t\t\t  enum dma_data_direction direction)\n{\n\tdma_addr_t address;\n\tint i;\n\n\tbuffer->direction = direction;\n\n\tfor (i = 0; i < buffer->page_count; i++) {\n\t\taddress = dma_map_page(card->device, buffer->pages[i],\n\t\t\t\t       0, PAGE_SIZE, direction);\n\t\tif (dma_mapping_error(card->device, address))\n\t\t\tbreak;\n\n\t\tset_page_private(buffer->pages[i], address);\n\t}\n\tbuffer->page_count_mapped = i;\n\tif (i < buffer->page_count)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,\n\t\t       int page_count, enum dma_data_direction direction)\n{\n\tint ret;\n\n\tret = fw_iso_buffer_alloc(buffer, page_count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = fw_iso_buffer_map_dma(buffer, card, direction);\n\tif (ret < 0)\n\t\tfw_iso_buffer_destroy(buffer, card);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fw_iso_buffer_init);\n\nvoid fw_iso_buffer_destroy(struct fw_iso_buffer *buffer,\n\t\t\t   struct fw_card *card)\n{\n\tint i;\n\tdma_addr_t address;\n\n\tfor (i = 0; i < buffer->page_count_mapped; i++) {\n\t\taddress = page_private(buffer->pages[i]);\n\t\tdma_unmap_page(card->device, address,\n\t\t\t       PAGE_SIZE, buffer->direction);\n\t}\n\tfor (i = 0; i < buffer->page_count; i++)\n\t\t__free_page(buffer->pages[i]);\n\n\tkfree(buffer->pages);\n\tbuffer->pages = NULL;\n\tbuffer->page_count = 0;\n\tbuffer->page_count_mapped = 0;\n}\nEXPORT_SYMBOL(fw_iso_buffer_destroy);\n\n \nsize_t fw_iso_buffer_lookup(struct fw_iso_buffer *buffer, dma_addr_t completed)\n{\n\tsize_t i;\n\tdma_addr_t address;\n\tssize_t offset;\n\n\tfor (i = 0; i < buffer->page_count; i++) {\n\t\taddress = page_private(buffer->pages[i]);\n\t\toffset = (ssize_t)completed - (ssize_t)address;\n\t\tif (offset > 0 && offset <= PAGE_SIZE)\n\t\t\treturn (i << PAGE_SHIFT) + offset;\n\t}\n\n\treturn 0;\n}\n\nstruct fw_iso_context *fw_iso_context_create(struct fw_card *card,\n\t\tint type, int channel, int speed, size_t header_size,\n\t\tfw_iso_callback_t callback, void *callback_data)\n{\n\tstruct fw_iso_context *ctx;\n\n\tctx = card->driver->allocate_iso_context(card,\n\t\t\t\t\t\t type, channel, header_size);\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\n\tctx->card = card;\n\tctx->type = type;\n\tctx->channel = channel;\n\tctx->speed = speed;\n\tctx->header_size = header_size;\n\tctx->callback.sc = callback;\n\tctx->callback_data = callback_data;\n\n\treturn ctx;\n}\nEXPORT_SYMBOL(fw_iso_context_create);\n\nvoid fw_iso_context_destroy(struct fw_iso_context *ctx)\n{\n\tctx->card->driver->free_iso_context(ctx);\n}\nEXPORT_SYMBOL(fw_iso_context_destroy);\n\nint fw_iso_context_start(struct fw_iso_context *ctx,\n\t\t\t int cycle, int sync, int tags)\n{\n\treturn ctx->card->driver->start_iso(ctx, cycle, sync, tags);\n}\nEXPORT_SYMBOL(fw_iso_context_start);\n\nint fw_iso_context_set_channels(struct fw_iso_context *ctx, u64 *channels)\n{\n\treturn ctx->card->driver->set_iso_channels(ctx, channels);\n}\n\nint fw_iso_context_queue(struct fw_iso_context *ctx,\n\t\t\t struct fw_iso_packet *packet,\n\t\t\t struct fw_iso_buffer *buffer,\n\t\t\t unsigned long payload)\n{\n\treturn ctx->card->driver->queue_iso(ctx, packet, buffer, payload);\n}\nEXPORT_SYMBOL(fw_iso_context_queue);\n\nvoid fw_iso_context_queue_flush(struct fw_iso_context *ctx)\n{\n\tctx->card->driver->flush_queue_iso(ctx);\n}\nEXPORT_SYMBOL(fw_iso_context_queue_flush);\n\nint fw_iso_context_flush_completions(struct fw_iso_context *ctx)\n{\n\treturn ctx->card->driver->flush_iso_completions(ctx);\n}\nEXPORT_SYMBOL(fw_iso_context_flush_completions);\n\nint fw_iso_context_stop(struct fw_iso_context *ctx)\n{\n\treturn ctx->card->driver->stop_iso(ctx);\n}\nEXPORT_SYMBOL(fw_iso_context_stop);\n\n \n\nstatic int manage_bandwidth(struct fw_card *card, int irm_id, int generation,\n\t\t\t    int bandwidth, bool allocate)\n{\n\tint try, new, old = allocate ? BANDWIDTH_AVAILABLE_INITIAL : 0;\n\t__be32 data[2];\n\n\t \n\tfor (try = 0; try < 5; try++) {\n\t\tnew = allocate ? old - bandwidth : old + bandwidth;\n\t\tif (new < 0 || new > BANDWIDTH_AVAILABLE_INITIAL)\n\t\t\treturn -EBUSY;\n\n\t\tdata[0] = cpu_to_be32(old);\n\t\tdata[1] = cpu_to_be32(new);\n\t\tswitch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,\n\t\t\t\tirm_id, generation, SCODE_100,\n\t\t\t\tCSR_REGISTER_BASE + CSR_BANDWIDTH_AVAILABLE,\n\t\t\t\tdata, 8)) {\n\t\tcase RCODE_GENERATION:\n\t\t\t \n\t\t\treturn allocate ? -EAGAIN : bandwidth;\n\n\t\tcase RCODE_COMPLETE:\n\t\t\tif (be32_to_cpup(data) == old)\n\t\t\t\treturn bandwidth;\n\n\t\t\told = be32_to_cpup(data);\n\t\t\t \n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int manage_channel(struct fw_card *card, int irm_id, int generation,\n\t\tu32 channels_mask, u64 offset, bool allocate)\n{\n\t__be32 bit, all, old;\n\t__be32 data[2];\n\tint channel, ret = -EIO, retry = 5;\n\n\told = all = allocate ? cpu_to_be32(~0) : 0;\n\n\tfor (channel = 0; channel < 32; channel++) {\n\t\tif (!(channels_mask & 1 << channel))\n\t\t\tcontinue;\n\n\t\tret = -EBUSY;\n\n\t\tbit = cpu_to_be32(1 << (31 - channel));\n\t\tif ((old & bit) != (all & bit))\n\t\t\tcontinue;\n\n\t\tdata[0] = old;\n\t\tdata[1] = old ^ bit;\n\t\tswitch (fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,\n\t\t\t\t\t   irm_id, generation, SCODE_100,\n\t\t\t\t\t   offset, data, 8)) {\n\t\tcase RCODE_GENERATION:\n\t\t\t \n\t\t\treturn allocate ? -EAGAIN : channel;\n\n\t\tcase RCODE_COMPLETE:\n\t\t\tif (data[0] == old)\n\t\t\t\treturn channel;\n\n\t\t\told = data[0];\n\n\t\t\t \n\t\t\tif ((data[0] & bit) == (data[1] & bit))\n\t\t\t\tcontinue;\n\n\t\t\tfallthrough;\t \n\t\tdefault:\n\t\t\tif (retry) {\n\t\t\t\tretry--;\n\t\t\t\tchannel--;\n\t\t\t} else {\n\t\t\t\tret = -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void deallocate_channel(struct fw_card *card, int irm_id,\n\t\t\t       int generation, int channel)\n{\n\tu32 mask;\n\tu64 offset;\n\n\tmask = channel < 32 ? 1 << channel : 1 << (channel - 32);\n\toffset = channel < 32 ? CSR_REGISTER_BASE + CSR_CHANNELS_AVAILABLE_HI :\n\t\t\t\tCSR_REGISTER_BASE + CSR_CHANNELS_AVAILABLE_LO;\n\n\tmanage_channel(card, irm_id, generation, mask, offset, false);\n}\n\n \nvoid fw_iso_resource_manage(struct fw_card *card, int generation,\n\t\t\t    u64 channels_mask, int *channel, int *bandwidth,\n\t\t\t    bool allocate)\n{\n\tu32 channels_hi = channels_mask;\t \n\tu32 channels_lo = channels_mask >> 32;\t \n\tint irm_id, ret, c = -EINVAL;\n\n\tspin_lock_irq(&card->lock);\n\tirm_id = card->irm_node->node_id;\n\tspin_unlock_irq(&card->lock);\n\n\tif (channels_hi)\n\t\tc = manage_channel(card, irm_id, generation, channels_hi,\n\t\t\t\tCSR_REGISTER_BASE + CSR_CHANNELS_AVAILABLE_HI,\n\t\t\t\tallocate);\n\tif (channels_lo && c < 0) {\n\t\tc = manage_channel(card, irm_id, generation, channels_lo,\n\t\t\t\tCSR_REGISTER_BASE + CSR_CHANNELS_AVAILABLE_LO,\n\t\t\t\tallocate);\n\t\tif (c >= 0)\n\t\t\tc += 32;\n\t}\n\t*channel = c;\n\n\tif (allocate && channels_mask != 0 && c < 0)\n\t\t*bandwidth = 0;\n\n\tif (*bandwidth == 0)\n\t\treturn;\n\n\tret = manage_bandwidth(card, irm_id, generation, *bandwidth, allocate);\n\tif (ret < 0)\n\t\t*bandwidth = 0;\n\n\tif (allocate && ret < 0) {\n\t\tif (c >= 0)\n\t\t\tdeallocate_channel(card, irm_id, generation, c);\n\t\t*channel = ret;\n\t}\n}\nEXPORT_SYMBOL(fw_iso_resource_manage);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}