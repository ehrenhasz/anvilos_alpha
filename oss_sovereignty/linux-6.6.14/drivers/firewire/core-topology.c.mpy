{
  "module_name": "core-topology.c",
  "hash_id": "7c901ee44aaf305189146ec505bf0b3b456762d66f399cd6d35698545a879268",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core-topology.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n\n#include \"core.h\"\n\n#define SELF_ID_PHY_ID(q)\t\t(((q) >> 24) & 0x3f)\n#define SELF_ID_EXTENDED(q)\t\t(((q) >> 23) & 0x01)\n#define SELF_ID_LINK_ON(q)\t\t(((q) >> 22) & 0x01)\n#define SELF_ID_GAP_COUNT(q)\t\t(((q) >> 16) & 0x3f)\n#define SELF_ID_PHY_SPEED(q)\t\t(((q) >> 14) & 0x03)\n#define SELF_ID_CONTENDER(q)\t\t(((q) >> 11) & 0x01)\n#define SELF_ID_PHY_INITIATOR(q)\t(((q) >>  1) & 0x01)\n#define SELF_ID_MORE_PACKETS(q)\t\t(((q) >>  0) & 0x01)\n\n#define SELF_ID_EXT_SEQUENCE(q)\t\t(((q) >> 20) & 0x07)\n\n#define SELFID_PORT_CHILD\t0x3\n#define SELFID_PORT_PARENT\t0x2\n#define SELFID_PORT_NCONN\t0x1\n#define SELFID_PORT_NONE\t0x0\n\nstatic u32 *count_ports(u32 *sid, int *total_port_count, int *child_port_count)\n{\n\tu32 q;\n\tint port_type, shift, seq;\n\n\t*total_port_count = 0;\n\t*child_port_count = 0;\n\n\tshift = 6;\n\tq = *sid;\n\tseq = 0;\n\n\twhile (1) {\n\t\tport_type = (q >> shift) & 0x03;\n\t\tswitch (port_type) {\n\t\tcase SELFID_PORT_CHILD:\n\t\t\t(*child_port_count)++;\n\t\t\tfallthrough;\n\t\tcase SELFID_PORT_PARENT:\n\t\tcase SELFID_PORT_NCONN:\n\t\t\t(*total_port_count)++;\n\t\t\tfallthrough;\n\t\tcase SELFID_PORT_NONE:\n\t\t\tbreak;\n\t\t}\n\n\t\tshift -= 2;\n\t\tif (shift == 0) {\n\t\t\tif (!SELF_ID_MORE_PACKETS(q))\n\t\t\t\treturn sid + 1;\n\n\t\t\tshift = 16;\n\t\t\tsid++;\n\t\t\tq = *sid;\n\n\t\t\t \n\n\t\t\tif (!SELF_ID_EXTENDED(q) ||\n\t\t\t    seq != SELF_ID_EXT_SEQUENCE(q))\n\t\t\t\treturn NULL;\n\n\t\t\tseq++;\n\t\t}\n\t}\n}\n\nstatic int get_port_type(u32 *sid, int port_index)\n{\n\tint index, shift;\n\n\tindex = (port_index + 5) / 8;\n\tshift = 16 - ((port_index + 5) & 7) * 2;\n\treturn (sid[index] >> shift) & 0x03;\n}\n\nstatic struct fw_node *fw_node_create(u32 sid, int port_count, int color)\n{\n\tstruct fw_node *node;\n\n\tnode = kzalloc(struct_size(node, ports, port_count), GFP_ATOMIC);\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tnode->color = color;\n\tnode->node_id = LOCAL_BUS | SELF_ID_PHY_ID(sid);\n\tnode->link_on = SELF_ID_LINK_ON(sid);\n\tnode->phy_speed = SELF_ID_PHY_SPEED(sid);\n\tnode->initiated_reset = SELF_ID_PHY_INITIATOR(sid);\n\tnode->port_count = port_count;\n\n\trefcount_set(&node->ref_count, 1);\n\tINIT_LIST_HEAD(&node->link);\n\n\treturn node;\n}\n\n \nstatic void update_hop_count(struct fw_node *node)\n{\n\tint depths[2] = { -1, -1 };\n\tint max_child_hops = 0;\n\tint i;\n\n\tfor (i = 0; i < node->port_count; i++) {\n\t\tif (node->ports[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (node->ports[i]->max_hops > max_child_hops)\n\t\t\tmax_child_hops = node->ports[i]->max_hops;\n\n\t\tif (node->ports[i]->max_depth > depths[0]) {\n\t\t\tdepths[1] = depths[0];\n\t\t\tdepths[0] = node->ports[i]->max_depth;\n\t\t} else if (node->ports[i]->max_depth > depths[1])\n\t\t\tdepths[1] = node->ports[i]->max_depth;\n\t}\n\n\tnode->max_depth = depths[0] + 1;\n\tnode->max_hops = max(max_child_hops, depths[0] + depths[1] + 2);\n}\n\nstatic inline struct fw_node *fw_node(struct list_head *l)\n{\n\treturn list_entry(l, struct fw_node, link);\n}\n\n \nstatic struct fw_node *build_tree(struct fw_card *card,\n\t\t\t\t  u32 *sid, int self_id_count)\n{\n\tstruct fw_node *node, *child, *local_node, *irm_node;\n\tstruct list_head stack, *h;\n\tu32 *next_sid, *end, q;\n\tint i, port_count, child_port_count, phy_id, parent_count, stack_depth;\n\tint gap_count;\n\tbool beta_repeaters_present;\n\n\tlocal_node = NULL;\n\tnode = NULL;\n\tINIT_LIST_HEAD(&stack);\n\tstack_depth = 0;\n\tend = sid + self_id_count;\n\tphy_id = 0;\n\tirm_node = NULL;\n\tgap_count = SELF_ID_GAP_COUNT(*sid);\n\tbeta_repeaters_present = false;\n\n\twhile (sid < end) {\n\t\tnext_sid = count_ports(sid, &port_count, &child_port_count);\n\n\t\tif (next_sid == NULL) {\n\t\t\tfw_err(card, \"inconsistent extended self IDs\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tq = *sid;\n\t\tif (phy_id != SELF_ID_PHY_ID(q)) {\n\t\t\tfw_err(card, \"PHY ID mismatch in self ID: %d != %d\\n\",\n\t\t\t       phy_id, SELF_ID_PHY_ID(q));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (child_port_count > stack_depth) {\n\t\t\tfw_err(card, \"topology stack underflow\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0, h = &stack; i < child_port_count; i++)\n\t\t\th = h->prev;\n\t\t \n\t\tchild = fw_node(h);\n\n\t\tnode = fw_node_create(q, port_count, card->color);\n\t\tif (node == NULL) {\n\t\t\tfw_err(card, \"out of memory while building topology\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (phy_id == (card->node_id & 0x3f))\n\t\t\tlocal_node = node;\n\n\t\tif (SELF_ID_CONTENDER(q))\n\t\t\tirm_node = node;\n\n\t\tparent_count = 0;\n\n\t\tfor (i = 0; i < port_count; i++) {\n\t\t\tswitch (get_port_type(sid, i)) {\n\t\t\tcase SELFID_PORT_PARENT:\n\t\t\t\t \n\t\t\t\tparent_count++;\n\t\t\t\tnode->color = i;\n\t\t\t\tbreak;\n\n\t\t\tcase SELFID_PORT_CHILD:\n\t\t\t\tnode->ports[i] = child;\n\t\t\t\t \n\t\t\t\tchild->ports[child->color] = node;\n\t\t\t\tchild->color = card->color;\n\t\t\t\tchild = fw_node(child->link.next);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((next_sid == end && parent_count != 0) ||\n\t\t    (next_sid < end && parent_count != 1)) {\n\t\t\tfw_err(card, \"parent port inconsistency for node %d: \"\n\t\t\t       \"parent_count=%d\\n\", phy_id, parent_count);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\t__list_del(h->prev, &stack);\n\t\tlist_add_tail(&node->link, &stack);\n\t\tstack_depth += 1 - child_port_count;\n\n\t\tif (node->phy_speed == SCODE_BETA &&\n\t\t    parent_count + child_port_count > 1)\n\t\t\tbeta_repeaters_present = true;\n\n\t\t \n\t\tif (SELF_ID_GAP_COUNT(q) != gap_count)\n\t\t\tgap_count = 0;\n\n\t\tupdate_hop_count(node);\n\n\t\tsid = next_sid;\n\t\tphy_id++;\n\t}\n\n\tcard->root_node = node;\n\tcard->irm_node = irm_node;\n\tcard->gap_count = gap_count;\n\tcard->beta_repeaters_present = beta_repeaters_present;\n\n\treturn local_node;\n}\n\ntypedef void (*fw_node_callback_t)(struct fw_card * card,\n\t\t\t\t   struct fw_node * node,\n\t\t\t\t   struct fw_node * parent);\n\nstatic void for_each_fw_node(struct fw_card *card, struct fw_node *root,\n\t\t\t     fw_node_callback_t callback)\n{\n\tstruct list_head list;\n\tstruct fw_node *node, *next, *child, *parent;\n\tint i;\n\n\tINIT_LIST_HEAD(&list);\n\n\tfw_node_get(root);\n\tlist_add_tail(&root->link, &list);\n\tparent = NULL;\n\tlist_for_each_entry(node, &list, link) {\n\t\tnode->color = card->color;\n\n\t\tfor (i = 0; i < node->port_count; i++) {\n\t\t\tchild = node->ports[i];\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\t\t\tif (child->color == card->color)\n\t\t\t\tparent = child;\n\t\t\telse {\n\t\t\t\tfw_node_get(child);\n\t\t\t\tlist_add_tail(&child->link, &list);\n\t\t\t}\n\t\t}\n\n\t\tcallback(card, node, parent);\n\t}\n\n\tlist_for_each_entry_safe(node, next, &list, link)\n\t\tfw_node_put(node);\n}\n\nstatic void report_lost_node(struct fw_card *card,\n\t\t\t     struct fw_node *node, struct fw_node *parent)\n{\n\tfw_node_event(card, node, FW_NODE_DESTROYED);\n\tfw_node_put(node);\n\n\t \n\tcard->bm_retries = 0;\n}\n\nstatic void report_found_node(struct fw_card *card,\n\t\t\t      struct fw_node *node, struct fw_node *parent)\n{\n\tint b_path = (node->phy_speed == SCODE_BETA);\n\n\tif (parent != NULL) {\n\t\t \n\t\tnode->max_speed = parent->max_speed < node->phy_speed ?\n\t\t\t\t\tparent->max_speed : node->phy_speed;\n\t\tnode->b_path = parent->b_path && b_path;\n\t} else {\n\t\tnode->max_speed = node->phy_speed;\n\t\tnode->b_path = b_path;\n\t}\n\n\tfw_node_event(card, node, FW_NODE_CREATED);\n\n\t \n\tcard->bm_retries = 0;\n}\n\n \nvoid fw_destroy_nodes(struct fw_card *card)\n{\n\tcard->color++;\n\tif (card->local_node != NULL)\n\t\tfor_each_fw_node(card, card->local_node, report_lost_node);\n\tcard->local_node = NULL;\n}\n\nstatic void move_tree(struct fw_node *node0, struct fw_node *node1, int port)\n{\n\tstruct fw_node *tree;\n\tint i;\n\n\ttree = node1->ports[port];\n\tnode0->ports[port] = tree;\n\tfor (i = 0; i < tree->port_count; i++) {\n\t\tif (tree->ports[i] == node1) {\n\t\t\ttree->ports[i] = node0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void update_tree(struct fw_card *card, struct fw_node *root)\n{\n\tstruct list_head list0, list1;\n\tstruct fw_node *node0, *node1, *next1;\n\tint i, event;\n\n\tINIT_LIST_HEAD(&list0);\n\tlist_add_tail(&card->local_node->link, &list0);\n\tINIT_LIST_HEAD(&list1);\n\tlist_add_tail(&root->link, &list1);\n\n\tnode0 = fw_node(list0.next);\n\tnode1 = fw_node(list1.next);\n\n\twhile (&node0->link != &list0) {\n\t\tWARN_ON(node0->port_count != node1->port_count);\n\n\t\tif (node0->link_on && !node1->link_on)\n\t\t\tevent = FW_NODE_LINK_OFF;\n\t\telse if (!node0->link_on && node1->link_on)\n\t\t\tevent = FW_NODE_LINK_ON;\n\t\telse if (node1->initiated_reset && node1->link_on)\n\t\t\tevent = FW_NODE_INITIATED_RESET;\n\t\telse\n\t\t\tevent = FW_NODE_UPDATED;\n\n\t\tnode0->node_id = node1->node_id;\n\t\tnode0->color = card->color;\n\t\tnode0->link_on = node1->link_on;\n\t\tnode0->initiated_reset = node1->initiated_reset;\n\t\tnode0->max_hops = node1->max_hops;\n\t\tnode1->color = card->color;\n\t\tfw_node_event(card, node0, event);\n\n\t\tif (card->root_node == node1)\n\t\t\tcard->root_node = node0;\n\t\tif (card->irm_node == node1)\n\t\t\tcard->irm_node = node0;\n\n\t\tfor (i = 0; i < node0->port_count; i++) {\n\t\t\tif (node0->ports[i] && node1->ports[i]) {\n\t\t\t\t \n\t\t\t\tif (node0->ports[i]->color == card->color)\n\t\t\t\t\tcontinue;\n\t\t\t\tlist_add_tail(&node0->ports[i]->link, &list0);\n\t\t\t\tlist_add_tail(&node1->ports[i]->link, &list1);\n\t\t\t} else if (node0->ports[i]) {\n\t\t\t\t \n\n\t\t\t\tfor_each_fw_node(card, node0->ports[i],\n\t\t\t\t\t\t report_lost_node);\n\t\t\t\tnode0->ports[i] = NULL;\n\t\t\t} else if (node1->ports[i]) {\n\t\t\t\t \n\t\t\t\tmove_tree(node0, node1, i);\n\t\t\t\tfor_each_fw_node(card, node0->ports[i],\n\t\t\t\t\t\t report_found_node);\n\t\t\t}\n\t\t}\n\n\t\tnode0 = fw_node(node0->link.next);\n\t\tnext1 = fw_node(node1->link.next);\n\t\tfw_node_put(node1);\n\t\tnode1 = next1;\n\t}\n}\n\nstatic void update_topology_map(struct fw_card *card,\n\t\t\t\tu32 *self_ids, int self_id_count)\n{\n\tint node_count = (card->root_node->node_id & 0x3f) + 1;\n\t__be32 *map = card->topology_map;\n\n\t*map++ = cpu_to_be32((self_id_count + 2) << 16);\n\t*map++ = cpu_to_be32(be32_to_cpu(card->topology_map[1]) + 1);\n\t*map++ = cpu_to_be32((node_count << 16) | self_id_count);\n\n\twhile (self_id_count--)\n\t\t*map++ = cpu_to_be32p(self_ids++);\n\n\tfw_compute_block_crc(card->topology_map);\n}\n\nvoid fw_core_handle_bus_reset(struct fw_card *card, int node_id, int generation,\n\t\t\t      int self_id_count, u32 *self_ids, bool bm_abdicate)\n{\n\tstruct fw_node *local_node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\t \n\tif (!is_next_generation(generation, card->generation) &&\n\t    card->local_node != NULL) {\n\t\tfw_destroy_nodes(card);\n\t\tcard->bm_retries = 0;\n\t}\n\n\tcard->broadcast_channel_allocated = card->broadcast_channel_auto_allocated;\n\tcard->node_id = node_id;\n\t \n\tsmp_wmb();\n\tcard->generation = generation;\n\tcard->reset_jiffies = get_jiffies_64();\n\tcard->bm_node_id  = 0xffff;\n\tcard->bm_abdicate = bm_abdicate;\n\tfw_schedule_bm_work(card, 0);\n\n\tlocal_node = build_tree(card, self_ids, self_id_count);\n\n\tupdate_topology_map(card, self_ids, self_id_count);\n\n\tcard->color++;\n\n\tif (local_node == NULL) {\n\t\tfw_err(card, \"topology build failed\\n\");\n\t\t \n\t} else if (card->local_node == NULL) {\n\t\tcard->local_node = local_node;\n\t\tfor_each_fw_node(card, local_node, report_found_node);\n\t} else {\n\t\tupdate_tree(card, local_node);\n\t}\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n}\nEXPORT_SYMBOL(fw_core_handle_bus_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}