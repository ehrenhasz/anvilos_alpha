{
  "module_name": "core.h",
  "hash_id": "d0a7b7077fcab19b644342ac3647b64ef67d78de01b2da886c8e0b09be654897",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core.h",
  "human_readable_source": " \n#ifndef _FIREWIRE_CORE_H\n#define _FIREWIRE_CORE_H\n\n#include <linux/compiler.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/idr.h>\n#include <linux/mm_types.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/refcount.h>\n\nstruct device;\nstruct fw_card;\nstruct fw_device;\nstruct fw_iso_buffer;\nstruct fw_iso_context;\nstruct fw_iso_packet;\nstruct fw_node;\nstruct fw_packet;\n\n\n \n\nextern __printf(2, 3)\nvoid fw_err(const struct fw_card *card, const char *fmt, ...);\nextern __printf(2, 3)\nvoid fw_notice(const struct fw_card *card, const char *fmt, ...);\n\n \n#define PHY_LINK_ACTIVE\t\t0x80\n#define PHY_CONTENDER\t\t0x40\n#define PHY_BUS_RESET\t\t0x40\n#define PHY_EXTENDED_REGISTERS\t0xe0\n#define PHY_BUS_SHORT_RESET\t0x40\n#define PHY_INT_STATUS_BITS\t0x3c\n#define PHY_ENABLE_ACCEL\t0x02\n#define PHY_ENABLE_MULTI\t0x01\n#define PHY_PAGE_SELECT\t\t0xe0\n\n#define BANDWIDTH_AVAILABLE_INITIAL\t4915\n#define BROADCAST_CHANNEL_INITIAL\t(1 << 31 | 31)\n#define BROADCAST_CHANNEL_VALID\t\t(1 << 30)\n\n#define CSR_STATE_BIT_CMSTR\t(1 << 8)\n#define CSR_STATE_BIT_ABDICATE\t(1 << 10)\n\nstruct fw_card_driver {\n\t \n\tint (*enable)(struct fw_card *card,\n\t\t      const __be32 *config_rom, size_t length);\n\n\tint (*read_phy_reg)(struct fw_card *card, int address);\n\tint (*update_phy_reg)(struct fw_card *card, int address,\n\t\t\t      int clear_bits, int set_bits);\n\n\t \n\tint (*set_config_rom)(struct fw_card *card,\n\t\t\t      const __be32 *config_rom, size_t length);\n\n\tvoid (*send_request)(struct fw_card *card, struct fw_packet *packet);\n\tvoid (*send_response)(struct fw_card *card, struct fw_packet *packet);\n\t \n\tint (*cancel_packet)(struct fw_card *card, struct fw_packet *packet);\n\n\t \n\tint (*enable_phys_dma)(struct fw_card *card,\n\t\t\t       int node_id, int generation);\n\n\tu32 (*read_csr)(struct fw_card *card, int csr_offset);\n\tvoid (*write_csr)(struct fw_card *card, int csr_offset, u32 value);\n\n\tstruct fw_iso_context *\n\t(*allocate_iso_context)(struct fw_card *card,\n\t\t\t\tint type, int channel, size_t header_size);\n\tvoid (*free_iso_context)(struct fw_iso_context *ctx);\n\n\tint (*start_iso)(struct fw_iso_context *ctx,\n\t\t\t s32 cycle, u32 sync, u32 tags);\n\n\tint (*set_iso_channels)(struct fw_iso_context *ctx, u64 *channels);\n\n\tint (*queue_iso)(struct fw_iso_context *ctx,\n\t\t\t struct fw_iso_packet *packet,\n\t\t\t struct fw_iso_buffer *buffer,\n\t\t\t unsigned long payload);\n\n\tvoid (*flush_queue_iso)(struct fw_iso_context *ctx);\n\n\tint (*flush_iso_completions)(struct fw_iso_context *ctx);\n\n\tint (*stop_iso)(struct fw_iso_context *ctx);\n};\n\nvoid fw_card_initialize(struct fw_card *card,\n\t\tconst struct fw_card_driver *driver, struct device *device);\nint fw_card_add(struct fw_card *card,\n\t\tu32 max_receive, u32 link_speed, u64 guid);\nvoid fw_core_remove_card(struct fw_card *card);\nint fw_compute_block_crc(__be32 *block);\nvoid fw_schedule_bm_work(struct fw_card *card, unsigned long delay);\n\n \n\nextern const struct file_operations fw_device_ops;\n\nvoid fw_device_cdev_update(struct fw_device *device);\nvoid fw_device_cdev_remove(struct fw_device *device);\nvoid fw_cdev_handle_phy_packet(struct fw_card *card, struct fw_packet *p);\n\n\n \n\nextern struct rw_semaphore fw_device_rwsem;\nextern struct idr fw_device_idr;\nextern int fw_cdev_major;\n\nstatic inline struct fw_device *fw_device_get(struct fw_device *device)\n{\n\tget_device(&device->device);\n\n\treturn device;\n}\n\nstatic inline void fw_device_put(struct fw_device *device)\n{\n\tput_device(&device->device);\n}\n\nstruct fw_device *fw_device_get_by_devt(dev_t devt);\nint fw_device_set_broadcast_channel(struct device *dev, void *gen);\nvoid fw_node_event(struct fw_card *card, struct fw_node *node, int event);\n\n\n \n\nint fw_iso_buffer_alloc(struct fw_iso_buffer *buffer, int page_count);\nint fw_iso_buffer_map_dma(struct fw_iso_buffer *buffer, struct fw_card *card,\n\t\t\t  enum dma_data_direction direction);\n\n\n \n\nenum {\n\tFW_NODE_CREATED,\n\tFW_NODE_UPDATED,\n\tFW_NODE_DESTROYED,\n\tFW_NODE_LINK_ON,\n\tFW_NODE_LINK_OFF,\n\tFW_NODE_INITIATED_RESET,\n};\n\nstruct fw_node {\n\tu16 node_id;\n\tu8 color;\n\tu8 port_count;\n\tu8 link_on:1;\n\tu8 initiated_reset:1;\n\tu8 b_path:1;\n\tu8 phy_speed:2;\t \n\tu8 max_speed:2;\t \n\tu8 max_depth:4;\t \n\tu8 max_hops:4;\t \n\trefcount_t ref_count;\n\n\t \n\tstruct list_head link;\n\n\t \n\tvoid *data;\n\n\tstruct fw_node *ports[];\n};\n\nstatic inline struct fw_node *fw_node_get(struct fw_node *node)\n{\n\trefcount_inc(&node->ref_count);\n\n\treturn node;\n}\n\nstatic inline void fw_node_put(struct fw_node *node)\n{\n\tif (refcount_dec_and_test(&node->ref_count))\n\t\tkfree(node);\n}\n\nvoid fw_core_handle_bus_reset(struct fw_card *card, int node_id,\n\tint generation, int self_id_count, u32 *self_ids, bool bm_abdicate);\nvoid fw_destroy_nodes(struct fw_card *card);\n\n \nstatic inline bool is_next_generation(int new_generation, int old_generation)\n{\n\treturn (new_generation & 0xff) == ((old_generation + 1) & 0xff);\n}\n\n\n \n\n#define TCODE_LINK_INTERNAL\t\t0xe\n\n#define TCODE_IS_READ_REQUEST(tcode)\t(((tcode) & ~1) == 4)\n#define TCODE_IS_BLOCK_PACKET(tcode)\t(((tcode) &  1) != 0)\n#define TCODE_IS_LINK_INTERNAL(tcode)\t((tcode) == TCODE_LINK_INTERNAL)\n#define TCODE_IS_REQUEST(tcode)\t\t(((tcode) &  2) == 0)\n#define TCODE_IS_RESPONSE(tcode)\t(((tcode) &  2) != 0)\n#define TCODE_HAS_REQUEST_DATA(tcode)\t(((tcode) & 12) != 4)\n#define TCODE_HAS_RESPONSE_DATA(tcode)\t(((tcode) & 12) != 0)\n\n#define LOCAL_BUS 0xffc0\n\n \n#define FW_MAX_PHYSICAL_RANGE\t\t(1ULL << 32)\n\nvoid fw_core_handle_request(struct fw_card *card, struct fw_packet *request);\nvoid fw_core_handle_response(struct fw_card *card, struct fw_packet *packet);\nint fw_get_response_length(struct fw_request *request);\nvoid fw_fill_response(struct fw_packet *response, u32 *request_header,\n\t\t      int rcode, void *payload, size_t length);\n\nvoid fw_request_get(struct fw_request *request);\nvoid fw_request_put(struct fw_request *request);\n\n\n\nstatic inline u32 cycle_time_to_ohci_tstamp(u32 tstamp)\n{\n\treturn (tstamp & 0x0ffff000) >> 12;\n}\n\n#define FW_PHY_CONFIG_NO_NODE_ID\t-1\n#define FW_PHY_CONFIG_CURRENT_GAP_COUNT\t-1\nvoid fw_send_phy_config(struct fw_card *card,\n\t\t\tint node_id, int generation, int gap_count);\n\nstatic inline bool is_ping_packet(u32 *data)\n{\n\treturn (data[0] & 0xc0ffffff) == 0 && ~data[0] == data[1];\n}\n\nstatic inline bool is_in_fcp_region(u64 offset, size_t length)\n{\n\treturn offset >= (CSR_REGISTER_BASE | CSR_FCP_COMMAND) &&\n\t\toffset + length <= (CSR_REGISTER_BASE | CSR_FCP_END);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}