{
  "module_name": "core-device.c",
  "hash_id": "5c4355c08562690f745a9e1a1f11d5d5fd67f5fde0dc568036ea76a506a57660",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core-device.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/idr.h>\n#include <linux/jiffies.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n\n#include \"core.h\"\n\nvoid fw_csr_iterator_init(struct fw_csr_iterator *ci, const u32 *p)\n{\n\tci->p = p + 1;\n\tci->end = ci->p + (p[0] >> 16);\n}\nEXPORT_SYMBOL(fw_csr_iterator_init);\n\nint fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value)\n{\n\t*key = *ci->p >> 24;\n\t*value = *ci->p & 0xffffff;\n\n\treturn ci->p++ < ci->end;\n}\nEXPORT_SYMBOL(fw_csr_iterator_next);\n\nstatic const u32 *search_leaf(const u32 *directory, int search_key)\n{\n\tstruct fw_csr_iterator ci;\n\tint last_key = 0, key, value;\n\n\tfw_csr_iterator_init(&ci, directory);\n\twhile (fw_csr_iterator_next(&ci, &key, &value)) {\n\t\tif (last_key == search_key &&\n\t\t    key == (CSR_DESCRIPTOR | CSR_LEAF))\n\t\t\treturn ci.p - 1 + value;\n\n\t\tlast_key = key;\n\t}\n\n\treturn NULL;\n}\n\nstatic int textual_leaf_to_string(const u32 *block, char *buf, size_t size)\n{\n\tunsigned int quadlets, i;\n\tchar c;\n\n\tif (!size || !buf)\n\t\treturn -EINVAL;\n\n\tquadlets = min(block[0] >> 16, 256U);\n\tif (quadlets < 2)\n\t\treturn -ENODATA;\n\n\tif (block[1] != 0 || block[2] != 0)\n\t\t \n\t\treturn -ENODATA;\n\n\tblock += 3;\n\tquadlets -= 2;\n\tfor (i = 0; i < quadlets * 4 && i < size - 1; i++) {\n\t\tc = block[i / 4] >> (24 - 8 * (i % 4));\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\t\tbuf[i] = c;\n\t}\n\tbuf[i] = '\\0';\n\n\treturn i;\n}\n\n \nint fw_csr_string(const u32 *directory, int key, char *buf, size_t size)\n{\n\tconst u32 *leaf = search_leaf(directory, key);\n\tif (!leaf)\n\t\treturn -ENOENT;\n\n\treturn textual_leaf_to_string(leaf, buf, size);\n}\nEXPORT_SYMBOL(fw_csr_string);\n\nstatic void get_ids(const u32 *directory, int *id)\n{\n\tstruct fw_csr_iterator ci;\n\tint key, value;\n\n\tfw_csr_iterator_init(&ci, directory);\n\twhile (fw_csr_iterator_next(&ci, &key, &value)) {\n\t\tswitch (key) {\n\t\tcase CSR_VENDOR:\tid[0] = value; break;\n\t\tcase CSR_MODEL:\t\tid[1] = value; break;\n\t\tcase CSR_SPECIFIER_ID:\tid[2] = value; break;\n\t\tcase CSR_VERSION:\tid[3] = value; break;\n\t\t}\n\t}\n}\n\nstatic void get_modalias_ids(const struct fw_unit *unit, int *id)\n{\n\tget_ids(&fw_parent_device(unit)->config_rom[5], id);\n\tget_ids(unit->directory, id);\n}\n\nstatic bool match_ids(const struct ieee1394_device_id *id_table, int *id)\n{\n\tint match = 0;\n\n\tif (id[0] == id_table->vendor_id)\n\t\tmatch |= IEEE1394_MATCH_VENDOR_ID;\n\tif (id[1] == id_table->model_id)\n\t\tmatch |= IEEE1394_MATCH_MODEL_ID;\n\tif (id[2] == id_table->specifier_id)\n\t\tmatch |= IEEE1394_MATCH_SPECIFIER_ID;\n\tif (id[3] == id_table->version)\n\t\tmatch |= IEEE1394_MATCH_VERSION;\n\n\treturn (match & id_table->match_flags) == id_table->match_flags;\n}\n\nstatic const struct ieee1394_device_id *unit_match(struct device *dev,\n\t\t\t\t\t\t   struct device_driver *drv)\n{\n\tconst struct ieee1394_device_id *id_table =\n\t\t\tcontainer_of(drv, struct fw_driver, driver)->id_table;\n\tint id[] = {0, 0, 0, 0};\n\n\tget_modalias_ids(fw_unit(dev), id);\n\n\tfor (; id_table->match_flags != 0; id_table++)\n\t\tif (match_ids(id_table, id))\n\t\t\treturn id_table;\n\n\treturn NULL;\n}\n\nstatic bool is_fw_unit(struct device *dev);\n\nstatic int fw_unit_match(struct device *dev, struct device_driver *drv)\n{\n\t \n\treturn is_fw_unit(dev) && unit_match(dev, drv) != NULL;\n}\n\nstatic int fw_unit_probe(struct device *dev)\n{\n\tstruct fw_driver *driver =\n\t\t\tcontainer_of(dev->driver, struct fw_driver, driver);\n\n\treturn driver->probe(fw_unit(dev), unit_match(dev, dev->driver));\n}\n\nstatic void fw_unit_remove(struct device *dev)\n{\n\tstruct fw_driver *driver =\n\t\t\tcontainer_of(dev->driver, struct fw_driver, driver);\n\n\tdriver->remove(fw_unit(dev));\n}\n\nstatic int get_modalias(const struct fw_unit *unit, char *buffer, size_t buffer_size)\n{\n\tint id[] = {0, 0, 0, 0};\n\n\tget_modalias_ids(unit, id);\n\n\treturn snprintf(buffer, buffer_size,\n\t\t\t\"ieee1394:ven%08Xmo%08Xsp%08Xver%08X\",\n\t\t\tid[0], id[1], id[2], id[3]);\n}\n\nstatic int fw_unit_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct fw_unit *unit = fw_unit(dev);\n\tchar modalias[64];\n\n\tget_modalias(unit, modalias, sizeof(modalias));\n\n\tif (add_uevent_var(env, \"MODALIAS=%s\", modalias))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct bus_type fw_bus_type = {\n\t.name = \"firewire\",\n\t.match = fw_unit_match,\n\t.probe = fw_unit_probe,\n\t.remove = fw_unit_remove,\n};\nEXPORT_SYMBOL(fw_bus_type);\n\nint fw_device_enable_phys_dma(struct fw_device *device)\n{\n\tint generation = device->generation;\n\n\t \n\tsmp_rmb();\n\n\treturn device->card->driver->enable_phys_dma(device->card,\n\t\t\t\t\t\t     device->node_id,\n\t\t\t\t\t\t     generation);\n}\nEXPORT_SYMBOL(fw_device_enable_phys_dma);\n\nstruct config_rom_attribute {\n\tstruct device_attribute attr;\n\tu32 key;\n};\n\nstatic ssize_t show_immediate(struct device *dev,\n\t\t\t      struct device_attribute *dattr, char *buf)\n{\n\tstruct config_rom_attribute *attr =\n\t\tcontainer_of(dattr, struct config_rom_attribute, attr);\n\tstruct fw_csr_iterator ci;\n\tconst u32 *dir;\n\tint key, value, ret = -ENOENT;\n\n\tdown_read(&fw_device_rwsem);\n\n\tif (is_fw_unit(dev))\n\t\tdir = fw_unit(dev)->directory;\n\telse\n\t\tdir = fw_device(dev)->config_rom + 5;\n\n\tfw_csr_iterator_init(&ci, dir);\n\twhile (fw_csr_iterator_next(&ci, &key, &value))\n\t\tif (attr->key == key) {\n\t\t\tret = snprintf(buf, buf ? PAGE_SIZE : 0,\n\t\t\t\t       \"0x%06x\\n\", value);\n\t\t\tbreak;\n\t\t}\n\n\tup_read(&fw_device_rwsem);\n\n\treturn ret;\n}\n\n#define IMMEDIATE_ATTR(name, key)\t\t\t\t\\\n\t{ __ATTR(name, S_IRUGO, show_immediate, NULL), key }\n\nstatic ssize_t show_text_leaf(struct device *dev,\n\t\t\t      struct device_attribute *dattr, char *buf)\n{\n\tstruct config_rom_attribute *attr =\n\t\tcontainer_of(dattr, struct config_rom_attribute, attr);\n\tconst u32 *dir;\n\tsize_t bufsize;\n\tchar dummy_buf[2];\n\tint ret;\n\n\tdown_read(&fw_device_rwsem);\n\n\tif (is_fw_unit(dev))\n\t\tdir = fw_unit(dev)->directory;\n\telse\n\t\tdir = fw_device(dev)->config_rom + 5;\n\n\tif (buf) {\n\t\tbufsize = PAGE_SIZE - 1;\n\t} else {\n\t\tbuf = dummy_buf;\n\t\tbufsize = 1;\n\t}\n\n\tret = fw_csr_string(dir, attr->key, buf, bufsize);\n\n\tif (ret >= 0) {\n\t\t \n\t\twhile (ret > 0 && isspace(buf[ret - 1]))\n\t\t\tret--;\n\t\tstrcpy(buf + ret, \"\\n\");\n\t\tret++;\n\t}\n\n\tup_read(&fw_device_rwsem);\n\n\treturn ret;\n}\n\n#define TEXT_LEAF_ATTR(name, key)\t\t\t\t\\\n\t{ __ATTR(name, S_IRUGO, show_text_leaf, NULL), key }\n\nstatic struct config_rom_attribute config_rom_attributes[] = {\n\tIMMEDIATE_ATTR(vendor, CSR_VENDOR),\n\tIMMEDIATE_ATTR(hardware_version, CSR_HARDWARE_VERSION),\n\tIMMEDIATE_ATTR(specifier_id, CSR_SPECIFIER_ID),\n\tIMMEDIATE_ATTR(version, CSR_VERSION),\n\tIMMEDIATE_ATTR(model, CSR_MODEL),\n\tTEXT_LEAF_ATTR(vendor_name, CSR_VENDOR),\n\tTEXT_LEAF_ATTR(model_name, CSR_MODEL),\n\tTEXT_LEAF_ATTR(hardware_version_name, CSR_HARDWARE_VERSION),\n};\n\nstatic void init_fw_attribute_group(struct device *dev,\n\t\t\t\t    struct device_attribute *attrs,\n\t\t\t\t    struct fw_attribute_group *group)\n{\n\tstruct device_attribute *attr;\n\tint i, j;\n\n\tfor (j = 0; attrs[j].attr.name != NULL; j++)\n\t\tgroup->attrs[j] = &attrs[j].attr;\n\n\tfor (i = 0; i < ARRAY_SIZE(config_rom_attributes); i++) {\n\t\tattr = &config_rom_attributes[i].attr;\n\t\tif (attr->show(dev, attr, NULL) < 0)\n\t\t\tcontinue;\n\t\tgroup->attrs[j++] = &attr->attr;\n\t}\n\n\tgroup->attrs[j] = NULL;\n\tgroup->groups[0] = &group->group;\n\tgroup->groups[1] = NULL;\n\tgroup->group.attrs = group->attrs;\n\tdev->groups = (const struct attribute_group **) group->groups;\n}\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fw_unit *unit = fw_unit(dev);\n\tint length;\n\n\tlength = get_modalias(unit, buf, PAGE_SIZE);\n\tstrcpy(buf + length, \"\\n\");\n\n\treturn length + 1;\n}\n\nstatic ssize_t rom_index_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct fw_device *device = fw_device(dev->parent);\n\tstruct fw_unit *unit = fw_unit(dev);\n\n\treturn sysfs_emit(buf, \"%td\\n\", unit->directory - device->config_rom);\n}\n\nstatic struct device_attribute fw_unit_attributes[] = {\n\t__ATTR_RO(modalias),\n\t__ATTR_RO(rom_index),\n\t__ATTR_NULL,\n};\n\nstatic ssize_t config_rom_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct fw_device *device = fw_device(dev);\n\tsize_t length;\n\n\tdown_read(&fw_device_rwsem);\n\tlength = device->config_rom_length * 4;\n\tmemcpy(buf, device->config_rom, length);\n\tup_read(&fw_device_rwsem);\n\n\treturn length;\n}\n\nstatic ssize_t guid_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct fw_device *device = fw_device(dev);\n\tint ret;\n\n\tdown_read(&fw_device_rwsem);\n\tret = sysfs_emit(buf, \"0x%08x%08x\\n\", device->config_rom[3], device->config_rom[4]);\n\tup_read(&fw_device_rwsem);\n\n\treturn ret;\n}\n\nstatic ssize_t is_local_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fw_device *device = fw_device(dev);\n\n\treturn sprintf(buf, \"%u\\n\", device->is_local);\n}\n\nstatic int units_sprintf(char *buf, const u32 *directory)\n{\n\tstruct fw_csr_iterator ci;\n\tint key, value;\n\tint specifier_id = 0;\n\tint version = 0;\n\n\tfw_csr_iterator_init(&ci, directory);\n\twhile (fw_csr_iterator_next(&ci, &key, &value)) {\n\t\tswitch (key) {\n\t\tcase CSR_SPECIFIER_ID:\n\t\t\tspecifier_id = value;\n\t\t\tbreak;\n\t\tcase CSR_VERSION:\n\t\t\tversion = value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sprintf(buf, \"0x%06x:0x%06x \", specifier_id, version);\n}\n\nstatic ssize_t units_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct fw_device *device = fw_device(dev);\n\tstruct fw_csr_iterator ci;\n\tint key, value, i = 0;\n\n\tdown_read(&fw_device_rwsem);\n\tfw_csr_iterator_init(&ci, &device->config_rom[5]);\n\twhile (fw_csr_iterator_next(&ci, &key, &value)) {\n\t\tif (key != (CSR_UNIT | CSR_DIRECTORY))\n\t\t\tcontinue;\n\t\ti += units_sprintf(&buf[i], ci.p + value - 1);\n\t\tif (i >= PAGE_SIZE - (8 + 1 + 8 + 1))\n\t\t\tbreak;\n\t}\n\tup_read(&fw_device_rwsem);\n\n\tif (i)\n\t\tbuf[i - 1] = '\\n';\n\n\treturn i;\n}\n\nstatic struct device_attribute fw_device_attributes[] = {\n\t__ATTR_RO(config_rom),\n\t__ATTR_RO(guid),\n\t__ATTR_RO(is_local),\n\t__ATTR_RO(units),\n\t__ATTR_NULL,\n};\n\nstatic int read_rom(struct fw_device *device,\n\t\t    int generation, int index, u32 *data)\n{\n\tu64 offset = (CSR_REGISTER_BASE | CSR_CONFIG_ROM) + index * 4;\n\tint i, rcode;\n\n\t \n\tsmp_rmb();\n\n\tfor (i = 10; i < 100; i += 10) {\n\t\trcode = fw_run_transaction(device->card,\n\t\t\t\tTCODE_READ_QUADLET_REQUEST, device->node_id,\n\t\t\t\tgeneration, device->max_speed, offset, data, 4);\n\t\tif (rcode != RCODE_BUSY)\n\t\t\tbreak;\n\t\tmsleep(i);\n\t}\n\tbe32_to_cpus(data);\n\n\treturn rcode;\n}\n\n#define MAX_CONFIG_ROM_SIZE 256\n\n \nstatic int read_config_rom(struct fw_device *device, int generation)\n{\n\tstruct fw_card *card = device->card;\n\tconst u32 *old_rom, *new_rom;\n\tu32 *rom, *stack;\n\tu32 sp, key;\n\tint i, end, length, ret;\n\n\trom = kmalloc(sizeof(*rom) * MAX_CONFIG_ROM_SIZE +\n\t\t      sizeof(*stack) * MAX_CONFIG_ROM_SIZE, GFP_KERNEL);\n\tif (rom == NULL)\n\t\treturn -ENOMEM;\n\n\tstack = &rom[MAX_CONFIG_ROM_SIZE];\n\tmemset(rom, 0, sizeof(*rom) * MAX_CONFIG_ROM_SIZE);\n\n\tdevice->max_speed = SCODE_100;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tret = read_rom(device, generation, i, &rom[i]);\n\t\tif (ret != RCODE_COMPLETE)\n\t\t\tgoto out;\n\t\t \n\t\tif (i == 0 && rom[i] == 0) {\n\t\t\tret = RCODE_BUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdevice->max_speed = device->node->max_speed;\n\n\t \n\tif ((rom[2] & 0x7) < device->max_speed ||\n\t    device->max_speed == SCODE_BETA ||\n\t    card->beta_repeaters_present) {\n\t\tu32 dummy;\n\n\t\t \n\t\tif (device->max_speed == SCODE_BETA)\n\t\t\tdevice->max_speed = card->link_speed;\n\n\t\twhile (device->max_speed > SCODE_100) {\n\t\t\tif (read_rom(device, generation, 0, &dummy) ==\n\t\t\t    RCODE_COMPLETE)\n\t\t\t\tbreak;\n\t\t\tdevice->max_speed--;\n\t\t}\n\t}\n\n\t \n\tlength = i;\n\tsp = 0;\n\tstack[sp++] = 0xc0000005;\n\twhile (sp > 0) {\n\t\t \n\t\tkey = stack[--sp];\n\t\ti = key & 0xffffff;\n\t\tif (WARN_ON(i >= MAX_CONFIG_ROM_SIZE)) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = read_rom(device, generation, i, &rom[i]);\n\t\tif (ret != RCODE_COMPLETE)\n\t\t\tgoto out;\n\t\tend = i + (rom[i] >> 16) + 1;\n\t\tif (end > MAX_CONFIG_ROM_SIZE) {\n\t\t\t \n\t\t\tfw_err(card, \"skipped invalid ROM block %x at %llx\\n\",\n\t\t\t       rom[i],\n\t\t\t       i * 4 | CSR_REGISTER_BASE | CSR_CONFIG_ROM);\n\t\t\trom[i] = 0;\n\t\t\tend = i;\n\t\t}\n\t\ti++;\n\n\t\t \n\t\tfor (; i < end; i++) {\n\t\t\tret = read_rom(device, generation, i, &rom[i]);\n\t\t\tif (ret != RCODE_COMPLETE)\n\t\t\t\tgoto out;\n\n\t\t\tif ((key >> 30) != 3 || (rom[i] >> 30) < 2)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (i + (rom[i] & 0xffffff) >= MAX_CONFIG_ROM_SIZE) {\n\t\t\t\tfw_err(card,\n\t\t\t\t       \"skipped unsupported ROM entry %x at %llx\\n\",\n\t\t\t\t       rom[i],\n\t\t\t\t       i * 4 | CSR_REGISTER_BASE | CSR_CONFIG_ROM);\n\t\t\t\trom[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstack[sp++] = i + rom[i];\n\t\t}\n\t\tif (length < i)\n\t\t\tlength = i;\n\t}\n\n\told_rom = device->config_rom;\n\tnew_rom = kmemdup(rom, length * 4, GFP_KERNEL);\n\tif (new_rom == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdown_write(&fw_device_rwsem);\n\tdevice->config_rom = new_rom;\n\tdevice->config_rom_length = length;\n\tup_write(&fw_device_rwsem);\n\n\tkfree(old_rom);\n\tret = RCODE_COMPLETE;\n\tdevice->max_rec\t= rom[2] >> 12 & 0xf;\n\tdevice->cmc\t= rom[2] >> 30 & 1;\n\tdevice->irmc\t= rom[2] >> 31 & 1;\n out:\n\tkfree(rom);\n\n\treturn ret;\n}\n\nstatic void fw_unit_release(struct device *dev)\n{\n\tstruct fw_unit *unit = fw_unit(dev);\n\n\tfw_device_put(fw_parent_device(unit));\n\tkfree(unit);\n}\n\nstatic struct device_type fw_unit_type = {\n\t.uevent\t\t= fw_unit_uevent,\n\t.release\t= fw_unit_release,\n};\n\nstatic bool is_fw_unit(struct device *dev)\n{\n\treturn dev->type == &fw_unit_type;\n}\n\nstatic void create_units(struct fw_device *device)\n{\n\tstruct fw_csr_iterator ci;\n\tstruct fw_unit *unit;\n\tint key, value, i;\n\n\ti = 0;\n\tfw_csr_iterator_init(&ci, &device->config_rom[5]);\n\twhile (fw_csr_iterator_next(&ci, &key, &value)) {\n\t\tif (key != (CSR_UNIT | CSR_DIRECTORY))\n\t\t\tcontinue;\n\n\t\t \n\t\tunit = kzalloc(sizeof(*unit), GFP_KERNEL);\n\t\tif (unit == NULL)\n\t\t\tcontinue;\n\n\t\tunit->directory = ci.p + value - 1;\n\t\tunit->device.bus = &fw_bus_type;\n\t\tunit->device.type = &fw_unit_type;\n\t\tunit->device.parent = &device->device;\n\t\tdev_set_name(&unit->device, \"%s.%d\", dev_name(&device->device), i++);\n\n\t\tBUILD_BUG_ON(ARRAY_SIZE(unit->attribute_group.attrs) <\n\t\t\t\tARRAY_SIZE(fw_unit_attributes) +\n\t\t\t\tARRAY_SIZE(config_rom_attributes));\n\t\tinit_fw_attribute_group(&unit->device,\n\t\t\t\t\tfw_unit_attributes,\n\t\t\t\t\t&unit->attribute_group);\n\n\t\tfw_device_get(device);\n\t\tif (device_register(&unit->device) < 0) {\n\t\t\tput_device(&unit->device);\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic int shutdown_unit(struct device *device, void *data)\n{\n\tdevice_unregister(device);\n\n\treturn 0;\n}\n\n \nDECLARE_RWSEM(fw_device_rwsem);\n\nDEFINE_IDR(fw_device_idr);\nint fw_cdev_major;\n\nstruct fw_device *fw_device_get_by_devt(dev_t devt)\n{\n\tstruct fw_device *device;\n\n\tdown_read(&fw_device_rwsem);\n\tdevice = idr_find(&fw_device_idr, MINOR(devt));\n\tif (device)\n\t\tfw_device_get(device);\n\tup_read(&fw_device_rwsem);\n\n\treturn device;\n}\n\nstruct workqueue_struct *fw_workqueue;\nEXPORT_SYMBOL(fw_workqueue);\n\nstatic void fw_schedule_device_work(struct fw_device *device,\n\t\t\t\t    unsigned long delay)\n{\n\tqueue_delayed_work(fw_workqueue, &device->work, delay);\n}\n\n \n\n#define MAX_RETRIES\t10\n#define RETRY_DELAY\t(3 * HZ)\n#define INITIAL_DELAY\t(HZ / 2)\n#define SHUTDOWN_DELAY\t(2 * HZ)\n\nstatic void fw_device_shutdown(struct work_struct *work)\n{\n\tstruct fw_device *device =\n\t\tcontainer_of(work, struct fw_device, work.work);\n\tint minor = MINOR(device->device.devt);\n\n\tif (time_before64(get_jiffies_64(),\n\t\t\t  device->card->reset_jiffies + SHUTDOWN_DELAY)\n\t    && !list_empty(&device->card->link)) {\n\t\tfw_schedule_device_work(device, SHUTDOWN_DELAY);\n\t\treturn;\n\t}\n\n\tif (atomic_cmpxchg(&device->state,\n\t\t\t   FW_DEVICE_GONE,\n\t\t\t   FW_DEVICE_SHUTDOWN) != FW_DEVICE_GONE)\n\t\treturn;\n\n\tfw_device_cdev_remove(device);\n\tdevice_for_each_child(&device->device, NULL, shutdown_unit);\n\tdevice_unregister(&device->device);\n\n\tdown_write(&fw_device_rwsem);\n\tidr_remove(&fw_device_idr, minor);\n\tup_write(&fw_device_rwsem);\n\n\tfw_device_put(device);\n}\n\nstatic void fw_device_release(struct device *dev)\n{\n\tstruct fw_device *device = fw_device(dev);\n\tstruct fw_card *card = device->card;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&card->lock, flags);\n\tdevice->node->data = NULL;\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tfw_node_put(device->node);\n\tkfree(device->config_rom);\n\tkfree(device);\n\tfw_card_put(card);\n}\n\nstatic struct device_type fw_device_type = {\n\t.release = fw_device_release,\n};\n\nstatic bool is_fw_device(struct device *dev)\n{\n\treturn dev->type == &fw_device_type;\n}\n\nstatic int update_unit(struct device *dev, void *data)\n{\n\tstruct fw_unit *unit = fw_unit(dev);\n\tstruct fw_driver *driver = (struct fw_driver *)dev->driver;\n\n\tif (is_fw_unit(dev) && driver != NULL && driver->update != NULL) {\n\t\tdevice_lock(dev);\n\t\tdriver->update(unit);\n\t\tdevice_unlock(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void fw_device_update(struct work_struct *work)\n{\n\tstruct fw_device *device =\n\t\tcontainer_of(work, struct fw_device, work.work);\n\n\tfw_device_cdev_update(device);\n\tdevice_for_each_child(&device->device, NULL, update_unit);\n}\n\n \nstatic int lookup_existing_device(struct device *dev, void *data)\n{\n\tstruct fw_device *old = fw_device(dev);\n\tstruct fw_device *new = data;\n\tstruct fw_card *card = new->card;\n\tint match = 0;\n\n\tif (!is_fw_device(dev))\n\t\treturn 0;\n\n\tdown_read(&fw_device_rwsem);  \n\tspin_lock_irq(&card->lock);   \n\n\tif (memcmp(old->config_rom, new->config_rom, 6 * 4) == 0 &&\n\t    atomic_cmpxchg(&old->state,\n\t\t\t   FW_DEVICE_GONE,\n\t\t\t   FW_DEVICE_RUNNING) == FW_DEVICE_GONE) {\n\t\tstruct fw_node *current_node = new->node;\n\t\tstruct fw_node *obsolete_node = old->node;\n\n\t\tnew->node = obsolete_node;\n\t\tnew->node->data = new;\n\t\told->node = current_node;\n\t\told->node->data = old;\n\n\t\told->max_speed = new->max_speed;\n\t\told->node_id = current_node->node_id;\n\t\tsmp_wmb();   \n\t\told->generation = card->generation;\n\t\told->config_rom_retries = 0;\n\t\tfw_notice(card, \"rediscovered device %s\\n\", dev_name(dev));\n\n\t\told->workfn = fw_device_update;\n\t\tfw_schedule_device_work(old, 0);\n\n\t\tif (current_node == card->root_node)\n\t\t\tfw_schedule_bm_work(card, 0);\n\n\t\tmatch = 1;\n\t}\n\n\tspin_unlock_irq(&card->lock);\n\tup_read(&fw_device_rwsem);\n\n\treturn match;\n}\n\nenum { BC_UNKNOWN = 0, BC_UNIMPLEMENTED, BC_IMPLEMENTED, };\n\nstatic void set_broadcast_channel(struct fw_device *device, int generation)\n{\n\tstruct fw_card *card = device->card;\n\t__be32 data;\n\tint rcode;\n\n\tif (!card->broadcast_channel_allocated)\n\t\treturn;\n\n\t \n\tif (!device->irmc || device->max_rec < 8)\n\t\treturn;\n\n\t \n\tif (device->bc_implemented == BC_UNKNOWN) {\n\t\trcode = fw_run_transaction(card, TCODE_READ_QUADLET_REQUEST,\n\t\t\t\tdevice->node_id, generation, device->max_speed,\n\t\t\t\tCSR_REGISTER_BASE + CSR_BROADCAST_CHANNEL,\n\t\t\t\t&data, 4);\n\t\tswitch (rcode) {\n\t\tcase RCODE_COMPLETE:\n\t\t\tif (data & cpu_to_be32(1 << 31)) {\n\t\t\t\tdevice->bc_implemented = BC_IMPLEMENTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t \n\t\tcase RCODE_ADDRESS_ERROR:\n\t\t\tdevice->bc_implemented = BC_UNIMPLEMENTED;\n\t\t}\n\t}\n\n\tif (device->bc_implemented == BC_IMPLEMENTED) {\n\t\tdata = cpu_to_be32(BROADCAST_CHANNEL_INITIAL |\n\t\t\t\t   BROADCAST_CHANNEL_VALID);\n\t\tfw_run_transaction(card, TCODE_WRITE_QUADLET_REQUEST,\n\t\t\t\tdevice->node_id, generation, device->max_speed,\n\t\t\t\tCSR_REGISTER_BASE + CSR_BROADCAST_CHANNEL,\n\t\t\t\t&data, 4);\n\t}\n}\n\nint fw_device_set_broadcast_channel(struct device *dev, void *gen)\n{\n\tif (is_fw_device(dev))\n\t\tset_broadcast_channel(fw_device(dev), (long)gen);\n\n\treturn 0;\n}\n\nstatic void fw_device_init(struct work_struct *work)\n{\n\tstruct fw_device *device =\n\t\tcontainer_of(work, struct fw_device, work.work);\n\tstruct fw_card *card = device->card;\n\tstruct device *revived_dev;\n\tint minor, ret;\n\n\t \n\n\tret = read_config_rom(device, device->generation);\n\tif (ret != RCODE_COMPLETE) {\n\t\tif (device->config_rom_retries < MAX_RETRIES &&\n\t\t    atomic_read(&device->state) == FW_DEVICE_INITIALIZING) {\n\t\t\tdevice->config_rom_retries++;\n\t\t\tfw_schedule_device_work(device, RETRY_DELAY);\n\t\t} else {\n\t\t\tif (device->node->link_on)\n\t\t\t\tfw_notice(card, \"giving up on node %x: reading config rom failed: %s\\n\",\n\t\t\t\t\t  device->node_id,\n\t\t\t\t\t  fw_rcode_string(ret));\n\t\t\tif (device->node == card->root_node)\n\t\t\t\tfw_schedule_bm_work(card, 0);\n\t\t\tfw_device_release(&device->device);\n\t\t}\n\t\treturn;\n\t}\n\n\trevived_dev = device_find_child(card->device,\n\t\t\t\t\tdevice, lookup_existing_device);\n\tif (revived_dev) {\n\t\tput_device(revived_dev);\n\t\tfw_device_release(&device->device);\n\n\t\treturn;\n\t}\n\n\tdevice_initialize(&device->device);\n\n\tfw_device_get(device);\n\tdown_write(&fw_device_rwsem);\n\tminor = idr_alloc(&fw_device_idr, device, 0, 1 << MINORBITS,\n\t\t\tGFP_KERNEL);\n\tup_write(&fw_device_rwsem);\n\n\tif (minor < 0)\n\t\tgoto error;\n\n\tdevice->device.bus = &fw_bus_type;\n\tdevice->device.type = &fw_device_type;\n\tdevice->device.parent = card->device;\n\tdevice->device.devt = MKDEV(fw_cdev_major, minor);\n\tdev_set_name(&device->device, \"fw%d\", minor);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(device->attribute_group.attrs) <\n\t\t\tARRAY_SIZE(fw_device_attributes) +\n\t\t\tARRAY_SIZE(config_rom_attributes));\n\tinit_fw_attribute_group(&device->device,\n\t\t\t\tfw_device_attributes,\n\t\t\t\t&device->attribute_group);\n\n\tif (device_add(&device->device)) {\n\t\tfw_err(card, \"failed to add device\\n\");\n\t\tgoto error_with_cdev;\n\t}\n\n\tcreate_units(device);\n\n\t \n\tif (atomic_cmpxchg(&device->state,\n\t\t\t   FW_DEVICE_INITIALIZING,\n\t\t\t   FW_DEVICE_RUNNING) == FW_DEVICE_GONE) {\n\t\tdevice->workfn = fw_device_shutdown;\n\t\tfw_schedule_device_work(device, SHUTDOWN_DELAY);\n\t} else {\n\t\tfw_notice(card, \"created device %s: GUID %08x%08x, S%d00\\n\",\n\t\t\t  dev_name(&device->device),\n\t\t\t  device->config_rom[3], device->config_rom[4],\n\t\t\t  1 << device->max_speed);\n\t\tdevice->config_rom_retries = 0;\n\n\t\tset_broadcast_channel(device, device->generation);\n\n\t\tadd_device_randomness(&device->config_rom[3], 8);\n\t}\n\n\t \n\tif (device->node == card->root_node)\n\t\tfw_schedule_bm_work(card, 0);\n\n\treturn;\n\n error_with_cdev:\n\tdown_write(&fw_device_rwsem);\n\tidr_remove(&fw_device_idr, minor);\n\tup_write(&fw_device_rwsem);\n error:\n\tfw_device_put(device);\t\t \n\n\tput_device(&device->device);\t \n}\n\n \nstatic int reread_config_rom(struct fw_device *device, int generation,\n\t\t\t     bool *changed)\n{\n\tu32 q;\n\tint i, rcode;\n\n\tfor (i = 0; i < 6; i++) {\n\t\trcode = read_rom(device, generation, i, &q);\n\t\tif (rcode != RCODE_COMPLETE)\n\t\t\treturn rcode;\n\n\t\tif (i == 0 && q == 0)\n\t\t\t \n\t\t\treturn RCODE_BUSY;\n\n\t\tif (q != device->config_rom[i]) {\n\t\t\t*changed = true;\n\t\t\treturn RCODE_COMPLETE;\n\t\t}\n\t}\n\n\t*changed = false;\n\treturn RCODE_COMPLETE;\n}\n\nstatic void fw_device_refresh(struct work_struct *work)\n{\n\tstruct fw_device *device =\n\t\tcontainer_of(work, struct fw_device, work.work);\n\tstruct fw_card *card = device->card;\n\tint ret, node_id = device->node_id;\n\tbool changed;\n\n\tret = reread_config_rom(device, device->generation, &changed);\n\tif (ret != RCODE_COMPLETE)\n\t\tgoto failed_config_rom;\n\n\tif (!changed) {\n\t\tif (atomic_cmpxchg(&device->state,\n\t\t\t\t   FW_DEVICE_INITIALIZING,\n\t\t\t\t   FW_DEVICE_RUNNING) == FW_DEVICE_GONE)\n\t\t\tgoto gone;\n\n\t\tfw_device_update(work);\n\t\tdevice->config_rom_retries = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tdevice_for_each_child(&device->device, NULL, shutdown_unit);\n\n\tret = read_config_rom(device, device->generation);\n\tif (ret != RCODE_COMPLETE)\n\t\tgoto failed_config_rom;\n\n\tfw_device_cdev_update(device);\n\tcreate_units(device);\n\n\t \n\tkobject_uevent(&device->device.kobj, KOBJ_CHANGE);\n\n\tif (atomic_cmpxchg(&device->state,\n\t\t\t   FW_DEVICE_INITIALIZING,\n\t\t\t   FW_DEVICE_RUNNING) == FW_DEVICE_GONE)\n\t\tgoto gone;\n\n\tfw_notice(card, \"refreshed device %s\\n\", dev_name(&device->device));\n\tdevice->config_rom_retries = 0;\n\tgoto out;\n\n failed_config_rom:\n\tif (device->config_rom_retries < MAX_RETRIES &&\n\t    atomic_read(&device->state) == FW_DEVICE_INITIALIZING) {\n\t\tdevice->config_rom_retries++;\n\t\tfw_schedule_device_work(device, RETRY_DELAY);\n\t\treturn;\n\t}\n\n\tfw_notice(card, \"giving up on refresh of device %s: %s\\n\",\n\t\t  dev_name(&device->device), fw_rcode_string(ret));\n gone:\n\tatomic_set(&device->state, FW_DEVICE_GONE);\n\tdevice->workfn = fw_device_shutdown;\n\tfw_schedule_device_work(device, SHUTDOWN_DELAY);\n out:\n\tif (node_id == card->root_node->node_id)\n\t\tfw_schedule_bm_work(card, 0);\n}\n\nstatic void fw_device_workfn(struct work_struct *work)\n{\n\tstruct fw_device *device = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct fw_device, work);\n\tdevice->workfn(work);\n}\n\nvoid fw_node_event(struct fw_card *card, struct fw_node *node, int event)\n{\n\tstruct fw_device *device;\n\n\tswitch (event) {\n\tcase FW_NODE_CREATED:\n\t\t \n create:\n\t\tdevice = kzalloc(sizeof(*device), GFP_ATOMIC);\n\t\tif (device == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tatomic_set(&device->state, FW_DEVICE_INITIALIZING);\n\t\tdevice->card = fw_card_get(card);\n\t\tdevice->node = fw_node_get(node);\n\t\tdevice->node_id = node->node_id;\n\t\tdevice->generation = card->generation;\n\t\tdevice->is_local = node == card->local_node;\n\t\tmutex_init(&device->client_list_mutex);\n\t\tINIT_LIST_HEAD(&device->client_list);\n\n\t\t \n\t\tnode->data = device;\n\n\t\t \n\t\tdevice->workfn = fw_device_init;\n\t\tINIT_DELAYED_WORK(&device->work, fw_device_workfn);\n\t\tfw_schedule_device_work(device, INITIAL_DELAY);\n\t\tbreak;\n\n\tcase FW_NODE_INITIATED_RESET:\n\tcase FW_NODE_LINK_ON:\n\t\tdevice = node->data;\n\t\tif (device == NULL)\n\t\t\tgoto create;\n\n\t\tdevice->node_id = node->node_id;\n\t\tsmp_wmb();   \n\t\tdevice->generation = card->generation;\n\t\tif (atomic_cmpxchg(&device->state,\n\t\t\t    FW_DEVICE_RUNNING,\n\t\t\t    FW_DEVICE_INITIALIZING) == FW_DEVICE_RUNNING) {\n\t\t\tdevice->workfn = fw_device_refresh;\n\t\t\tfw_schedule_device_work(device,\n\t\t\t\tdevice->is_local ? 0 : INITIAL_DELAY);\n\t\t}\n\t\tbreak;\n\n\tcase FW_NODE_UPDATED:\n\t\tdevice = node->data;\n\t\tif (device == NULL)\n\t\t\tbreak;\n\n\t\tdevice->node_id = node->node_id;\n\t\tsmp_wmb();   \n\t\tdevice->generation = card->generation;\n\t\tif (atomic_read(&device->state) == FW_DEVICE_RUNNING) {\n\t\t\tdevice->workfn = fw_device_update;\n\t\t\tfw_schedule_device_work(device, 0);\n\t\t}\n\t\tbreak;\n\n\tcase FW_NODE_DESTROYED:\n\tcase FW_NODE_LINK_OFF:\n\t\tif (!node->data)\n\t\t\tbreak;\n\n\t\t \n\t\tdevice = node->data;\n\t\tif (atomic_xchg(&device->state,\n\t\t\t\tFW_DEVICE_GONE) == FW_DEVICE_RUNNING) {\n\t\t\tdevice->workfn = fw_device_shutdown;\n\t\t\tfw_schedule_device_work(device,\n\t\t\t\tlist_empty(&card->link) ? 0 : SHUTDOWN_DELAY);\n\t\t}\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}