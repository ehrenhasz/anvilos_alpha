{
  "module_name": "core-transaction.c",
  "hash_id": "105f976349d6a9ca00a020dba3199f3cae174bcc545e68875f290908a7366a51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/firewire/core-transaction.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <asm/byteorder.h>\n\n#include \"core.h\"\n\n#define HEADER_PRI(pri)\t\t\t((pri) << 0)\n#define HEADER_TCODE(tcode)\t\t((tcode) << 4)\n#define HEADER_RETRY(retry)\t\t((retry) << 8)\n#define HEADER_TLABEL(tlabel)\t\t((tlabel) << 10)\n#define HEADER_DESTINATION(destination)\t((destination) << 16)\n#define HEADER_SOURCE(source)\t\t((source) << 16)\n#define HEADER_RCODE(rcode)\t\t((rcode) << 12)\n#define HEADER_OFFSET_HIGH(offset_high)\t((offset_high) << 0)\n#define HEADER_DATA_LENGTH(length)\t((length) << 16)\n#define HEADER_EXTENDED_TCODE(tcode)\t((tcode) << 0)\n\n#define HEADER_GET_TCODE(q)\t\t(((q) >> 4) & 0x0f)\n#define HEADER_GET_TLABEL(q)\t\t(((q) >> 10) & 0x3f)\n#define HEADER_GET_RCODE(q)\t\t(((q) >> 12) & 0x0f)\n#define HEADER_GET_DESTINATION(q)\t(((q) >> 16) & 0xffff)\n#define HEADER_GET_SOURCE(q)\t\t(((q) >> 16) & 0xffff)\n#define HEADER_GET_OFFSET_HIGH(q)\t(((q) >> 0) & 0xffff)\n#define HEADER_GET_DATA_LENGTH(q)\t(((q) >> 16) & 0xffff)\n#define HEADER_GET_EXTENDED_TCODE(q)\t(((q) >> 0) & 0xffff)\n\n#define HEADER_DESTINATION_IS_BROADCAST(q) \\\n\t(((q) & HEADER_DESTINATION(0x3f)) == HEADER_DESTINATION(0x3f))\n\n#define PHY_PACKET_CONFIG\t0x0\n#define PHY_PACKET_LINK_ON\t0x1\n#define PHY_PACKET_SELF_ID\t0x2\n\n#define PHY_CONFIG_GAP_COUNT(gap_count)\t(((gap_count) << 16) | (1 << 22))\n#define PHY_CONFIG_ROOT_ID(node_id)\t((((node_id) & 0x3f) << 24) | (1 << 23))\n#define PHY_IDENTIFIER(id)\t\t((id) << 30)\n\n \nstatic int try_cancel_split_timeout(struct fw_transaction *t)\n{\n\tif (t->is_split_transaction)\n\t\treturn del_timer(&t->split_timeout_timer);\n\telse\n\t\treturn 1;\n}\n\nstatic int close_transaction(struct fw_transaction *transaction, struct fw_card *card, int rcode,\n\t\t\t     u32 response_tstamp)\n{\n\tstruct fw_transaction *t = NULL, *iter;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry(iter, &card->transaction_list, link) {\n\t\tif (iter == transaction) {\n\t\t\tif (!try_cancel_split_timeout(iter)) {\n\t\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\t\tgoto timed_out;\n\t\t\t}\n\t\t\tlist_del_init(&iter->link);\n\t\t\tcard->tlabel_mask &= ~(1ULL << iter->tlabel);\n\t\t\tt = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tif (t) {\n\t\tif (!t->with_tstamp) {\n\t\t\tt->callback.without_tstamp(card, rcode, NULL, 0, t->callback_data);\n\t\t} else {\n\t\t\tt->callback.with_tstamp(card, rcode, t->packet.timestamp, response_tstamp,\n\t\t\t\t\t\tNULL, 0, t->callback_data);\n\t\t}\n\t\treturn 0;\n\t}\n\n timed_out:\n\treturn -ENOENT;\n}\n\n \nint fw_cancel_transaction(struct fw_card *card,\n\t\t\t  struct fw_transaction *transaction)\n{\n\tu32 tstamp;\n\n\t \n\n\tif (card->driver->cancel_packet(card, &transaction->packet) == 0)\n\t\treturn 0;\n\n\t \n\n\tif (transaction->packet.ack == 0) {\n\t\t \n\t\ttstamp = transaction->packet.timestamp;\n\t} else {\n\t\tu32 curr_cycle_time = 0;\n\n\t\t(void)fw_card_read_cycle_time(card, &curr_cycle_time);\n\t\ttstamp = cycle_time_to_ohci_tstamp(curr_cycle_time);\n\t}\n\n\treturn close_transaction(transaction, card, RCODE_CANCELLED, tstamp);\n}\nEXPORT_SYMBOL(fw_cancel_transaction);\n\nstatic void split_transaction_timeout_callback(struct timer_list *timer)\n{\n\tstruct fw_transaction *t = from_timer(t, timer, split_timeout_timer);\n\tstruct fw_card *card = t->card;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tif (list_empty(&t->link)) {\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\treturn;\n\t}\n\tlist_del(&t->link);\n\tcard->tlabel_mask &= ~(1ULL << t->tlabel);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tif (!t->with_tstamp) {\n\t\tt->callback.without_tstamp(card, RCODE_CANCELLED, NULL, 0, t->callback_data);\n\t} else {\n\t\tt->callback.with_tstamp(card, RCODE_CANCELLED, t->packet.timestamp,\n\t\t\t\t\tt->split_timeout_cycle, NULL, 0, t->callback_data);\n\t}\n}\n\nstatic void start_split_transaction_timeout(struct fw_transaction *t,\n\t\t\t\t\t    struct fw_card *card)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\tif (list_empty(&t->link) || WARN_ON(t->is_split_transaction)) {\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\treturn;\n\t}\n\n\tt->is_split_transaction = true;\n\tmod_timer(&t->split_timeout_timer,\n\t\t  jiffies + card->split_timeout_jiffies);\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n}\n\nstatic u32 compute_split_timeout_timestamp(struct fw_card *card, u32 request_timestamp);\n\nstatic void transmit_complete_callback(struct fw_packet *packet,\n\t\t\t\t       struct fw_card *card, int status)\n{\n\tstruct fw_transaction *t =\n\t    container_of(packet, struct fw_transaction, packet);\n\n\tswitch (status) {\n\tcase ACK_COMPLETE:\n\t\tclose_transaction(t, card, RCODE_COMPLETE, packet->timestamp);\n\t\tbreak;\n\tcase ACK_PENDING:\n\t{\n\t\tt->split_timeout_cycle =\n\t\t\tcompute_split_timeout_timestamp(card, packet->timestamp) & 0xffff;\n\t\tstart_split_transaction_timeout(t, card);\n\t\tbreak;\n\t}\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\n\t\tclose_transaction(t, card, RCODE_BUSY, packet->timestamp);\n\t\tbreak;\n\tcase ACK_DATA_ERROR:\n\t\tclose_transaction(t, card, RCODE_DATA_ERROR, packet->timestamp);\n\t\tbreak;\n\tcase ACK_TYPE_ERROR:\n\t\tclose_transaction(t, card, RCODE_TYPE_ERROR, packet->timestamp);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tclose_transaction(t, card, status, packet->timestamp);\n\t\tbreak;\n\t}\n}\n\nstatic void fw_fill_request(struct fw_packet *packet, int tcode, int tlabel,\n\t\tint destination_id, int source_id, int generation, int speed,\n\t\tunsigned long long offset, void *payload, size_t length)\n{\n\tint ext_tcode;\n\n\tif (tcode == TCODE_STREAM_DATA) {\n\t\tpacket->header[0] =\n\t\t\tHEADER_DATA_LENGTH(length) |\n\t\t\tdestination_id |\n\t\t\tHEADER_TCODE(TCODE_STREAM_DATA);\n\t\tpacket->header_length = 4;\n\t\tpacket->payload = payload;\n\t\tpacket->payload_length = length;\n\n\t\tgoto common;\n\t}\n\n\tif (tcode > 0x10) {\n\t\text_tcode = tcode & ~0x10;\n\t\ttcode = TCODE_LOCK_REQUEST;\n\t} else\n\t\text_tcode = 0;\n\n\tpacket->header[0] =\n\t\tHEADER_RETRY(RETRY_X) |\n\t\tHEADER_TLABEL(tlabel) |\n\t\tHEADER_TCODE(tcode) |\n\t\tHEADER_DESTINATION(destination_id);\n\tpacket->header[1] =\n\t\tHEADER_OFFSET_HIGH(offset >> 32) | HEADER_SOURCE(source_id);\n\tpacket->header[2] =\n\t\toffset;\n\n\tswitch (tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\t\tpacket->header[3] = *(u32 *)payload;\n\t\tpacket->header_length = 16;\n\t\tpacket->payload_length = 0;\n\t\tbreak;\n\n\tcase TCODE_LOCK_REQUEST:\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\t\tpacket->header[3] =\n\t\t\tHEADER_DATA_LENGTH(length) |\n\t\t\tHEADER_EXTENDED_TCODE(ext_tcode);\n\t\tpacket->header_length = 16;\n\t\tpacket->payload = payload;\n\t\tpacket->payload_length = length;\n\t\tbreak;\n\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\tpacket->header_length = 12;\n\t\tpacket->payload_length = 0;\n\t\tbreak;\n\n\tcase TCODE_READ_BLOCK_REQUEST:\n\t\tpacket->header[3] =\n\t\t\tHEADER_DATA_LENGTH(length) |\n\t\t\tHEADER_EXTENDED_TCODE(ext_tcode);\n\t\tpacket->header_length = 16;\n\t\tpacket->payload_length = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"wrong tcode %d\\n\", tcode);\n\t}\n common:\n\tpacket->speed = speed;\n\tpacket->generation = generation;\n\tpacket->ack = 0;\n\tpacket->payload_mapped = false;\n}\n\nstatic int allocate_tlabel(struct fw_card *card)\n{\n\tint tlabel;\n\n\ttlabel = card->current_tlabel;\n\twhile (card->tlabel_mask & (1ULL << tlabel)) {\n\t\ttlabel = (tlabel + 1) & 0x3f;\n\t\tif (tlabel == card->current_tlabel)\n\t\t\treturn -EBUSY;\n\t}\n\n\tcard->current_tlabel = (tlabel + 1) & 0x3f;\n\tcard->tlabel_mask |= 1ULL << tlabel;\n\n\treturn tlabel;\n}\n\n \nvoid __fw_send_request(struct fw_card *card, struct fw_transaction *t, int tcode,\n\t\tint destination_id, int generation, int speed, unsigned long long offset,\n\t\tvoid *payload, size_t length, union fw_transaction_callback callback,\n\t\tbool with_tstamp, void *callback_data)\n{\n\tunsigned long flags;\n\tint tlabel;\n\n\t \n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\ttlabel = allocate_tlabel(card);\n\tif (tlabel < 0) {\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tif (!with_tstamp) {\n\t\t\tcallback.without_tstamp(card, RCODE_SEND_ERROR, NULL, 0, callback_data);\n\t\t} else {\n\t\t\t\n\t\t\tu32 curr_cycle_time = 0;\n\t\t\tu32 tstamp;\n\n\t\t\t(void)fw_card_read_cycle_time(card, &curr_cycle_time);\n\t\t\ttstamp = cycle_time_to_ohci_tstamp(curr_cycle_time);\n\n\t\t\tcallback.with_tstamp(card, RCODE_SEND_ERROR, tstamp, tstamp, NULL, 0,\n\t\t\t\t\t     callback_data);\n\t\t}\n\t\treturn;\n\t}\n\n\tt->node_id = destination_id;\n\tt->tlabel = tlabel;\n\tt->card = card;\n\tt->is_split_transaction = false;\n\ttimer_setup(&t->split_timeout_timer, split_transaction_timeout_callback, 0);\n\tt->callback = callback;\n\tt->with_tstamp = with_tstamp;\n\tt->callback_data = callback_data;\n\n\tfw_fill_request(&t->packet, tcode, t->tlabel, destination_id, card->node_id, generation,\n\t\t\tspeed, offset, payload, length);\n\tt->packet.callback = transmit_complete_callback;\n\n\tlist_add_tail(&t->link, &card->transaction_list);\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tcard->driver->send_request(card, &t->packet);\n}\nEXPORT_SYMBOL_GPL(__fw_send_request);\n\nstruct transaction_callback_data {\n\tstruct completion done;\n\tvoid *payload;\n\tint rcode;\n};\n\nstatic void transaction_callback(struct fw_card *card, int rcode,\n\t\t\t\t void *payload, size_t length, void *data)\n{\n\tstruct transaction_callback_data *d = data;\n\n\tif (rcode == RCODE_COMPLETE)\n\t\tmemcpy(d->payload, payload, length);\n\td->rcode = rcode;\n\tcomplete(&d->done);\n}\n\n \nint fw_run_transaction(struct fw_card *card, int tcode, int destination_id,\n\t\t       int generation, int speed, unsigned long long offset,\n\t\t       void *payload, size_t length)\n{\n\tstruct transaction_callback_data d;\n\tstruct fw_transaction t;\n\n\ttimer_setup_on_stack(&t.split_timeout_timer, NULL, 0);\n\tinit_completion(&d.done);\n\td.payload = payload;\n\tfw_send_request(card, &t, tcode, destination_id, generation, speed,\n\t\t\toffset, payload, length, transaction_callback, &d);\n\twait_for_completion(&d.done);\n\tdestroy_timer_on_stack(&t.split_timeout_timer);\n\n\treturn d.rcode;\n}\nEXPORT_SYMBOL(fw_run_transaction);\n\nstatic DEFINE_MUTEX(phy_config_mutex);\nstatic DECLARE_COMPLETION(phy_config_done);\n\nstatic void transmit_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tcomplete(&phy_config_done);\n}\n\nstatic struct fw_packet phy_config_packet = {\n\t.header_length\t= 12,\n\t.header[0]\t= TCODE_LINK_INTERNAL << 4,\n\t.payload_length\t= 0,\n\t.speed\t\t= SCODE_100,\n\t.callback\t= transmit_phy_packet_callback,\n};\n\nvoid fw_send_phy_config(struct fw_card *card,\n\t\t\tint node_id, int generation, int gap_count)\n{\n\tlong timeout = DIV_ROUND_UP(HZ, 10);\n\tu32 data = PHY_IDENTIFIER(PHY_PACKET_CONFIG);\n\n\tif (node_id != FW_PHY_CONFIG_NO_NODE_ID)\n\t\tdata |= PHY_CONFIG_ROOT_ID(node_id);\n\n\tif (gap_count == FW_PHY_CONFIG_CURRENT_GAP_COUNT) {\n\t\tgap_count = card->driver->read_phy_reg(card, 1);\n\t\tif (gap_count < 0)\n\t\t\treturn;\n\n\t\tgap_count &= 63;\n\t\tif (gap_count == 63)\n\t\t\treturn;\n\t}\n\tdata |= PHY_CONFIG_GAP_COUNT(gap_count);\n\n\tmutex_lock(&phy_config_mutex);\n\n\tphy_config_packet.header[1] = data;\n\tphy_config_packet.header[2] = ~data;\n\tphy_config_packet.generation = generation;\n\treinit_completion(&phy_config_done);\n\n\tcard->driver->send_request(card, &phy_config_packet);\n\twait_for_completion_timeout(&phy_config_done, timeout);\n\n\tmutex_unlock(&phy_config_mutex);\n}\n\nstatic struct fw_address_handler *lookup_overlapping_address_handler(\n\tstruct list_head *list, unsigned long long offset, size_t length)\n{\n\tstruct fw_address_handler *handler;\n\n\tlist_for_each_entry_rcu(handler, list, link) {\n\t\tif (handler->offset < offset + length &&\n\t\t    offset < handler->offset + handler->length)\n\t\t\treturn handler;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool is_enclosing_handler(struct fw_address_handler *handler,\n\t\t\t\t unsigned long long offset, size_t length)\n{\n\treturn handler->offset <= offset &&\n\t\toffset + length <= handler->offset + handler->length;\n}\n\nstatic struct fw_address_handler *lookup_enclosing_address_handler(\n\tstruct list_head *list, unsigned long long offset, size_t length)\n{\n\tstruct fw_address_handler *handler;\n\n\tlist_for_each_entry_rcu(handler, list, link) {\n\t\tif (is_enclosing_handler(handler, offset, length))\n\t\t\treturn handler;\n\t}\n\n\treturn NULL;\n}\n\nstatic DEFINE_SPINLOCK(address_handler_list_lock);\nstatic LIST_HEAD(address_handler_list);\n\nconst struct fw_address_region fw_high_memory_region =\n\t{ .start = FW_MAX_PHYSICAL_RANGE, .end = 0xffffe0000000ULL, };\nEXPORT_SYMBOL(fw_high_memory_region);\n\nstatic const struct fw_address_region low_memory_region =\n\t{ .start = 0x000000000000ULL, .end = FW_MAX_PHYSICAL_RANGE, };\n\n#if 0\nconst struct fw_address_region fw_private_region =\n\t{ .start = 0xffffe0000000ULL, .end = 0xfffff0000000ULL,  };\nconst struct fw_address_region fw_csr_region =\n\t{ .start = CSR_REGISTER_BASE,\n\t  .end   = CSR_REGISTER_BASE | CSR_CONFIG_ROM_END,  };\nconst struct fw_address_region fw_unit_space_region =\n\t{ .start = 0xfffff0000900ULL, .end = 0x1000000000000ULL, };\n#endif   \n\n \nint fw_core_add_address_handler(struct fw_address_handler *handler,\n\t\t\t\tconst struct fw_address_region *region)\n{\n\tstruct fw_address_handler *other;\n\tint ret = -EBUSY;\n\n\tif (region->start & 0xffff000000000003ULL ||\n\t    region->start >= region->end ||\n\t    region->end   > 0x0001000000000000ULL ||\n\t    handler->length & 3 ||\n\t    handler->length == 0)\n\t\treturn -EINVAL;\n\n\tspin_lock(&address_handler_list_lock);\n\n\thandler->offset = region->start;\n\twhile (handler->offset + handler->length <= region->end) {\n\t\tif (is_in_fcp_region(handler->offset, handler->length))\n\t\t\tother = NULL;\n\t\telse\n\t\t\tother = lookup_overlapping_address_handler\n\t\t\t\t\t(&address_handler_list,\n\t\t\t\t\t handler->offset, handler->length);\n\t\tif (other != NULL) {\n\t\t\thandler->offset += other->length;\n\t\t} else {\n\t\t\tlist_add_tail_rcu(&handler->link, &address_handler_list);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&address_handler_list_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(fw_core_add_address_handler);\n\n \nvoid fw_core_remove_address_handler(struct fw_address_handler *handler)\n{\n\tspin_lock(&address_handler_list_lock);\n\tlist_del_rcu(&handler->link);\n\tspin_unlock(&address_handler_list_lock);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(fw_core_remove_address_handler);\n\nstruct fw_request {\n\tstruct kref kref;\n\tstruct fw_packet response;\n\tu32 request_header[4];\n\tint ack;\n\tu32 timestamp;\n\tu32 length;\n\tu32 data[];\n};\n\nvoid fw_request_get(struct fw_request *request)\n{\n\tkref_get(&request->kref);\n}\n\nstatic void release_request(struct kref *kref)\n{\n\tstruct fw_request *request = container_of(kref, struct fw_request, kref);\n\n\tkfree(request);\n}\n\nvoid fw_request_put(struct fw_request *request)\n{\n\tkref_put(&request->kref, release_request);\n}\n\nstatic void free_response_callback(struct fw_packet *packet,\n\t\t\t\t   struct fw_card *card, int status)\n{\n\tstruct fw_request *request = container_of(packet, struct fw_request, response);\n\n\t\n\tfw_request_put(request);\n\n\t\n\tfw_request_put(request);\n}\n\nint fw_get_response_length(struct fw_request *r)\n{\n\tint tcode, ext_tcode, data_length;\n\n\ttcode = HEADER_GET_TCODE(r->request_header[0]);\n\n\tswitch (tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\t\treturn 0;\n\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\treturn 4;\n\n\tcase TCODE_READ_BLOCK_REQUEST:\n\t\tdata_length = HEADER_GET_DATA_LENGTH(r->request_header[3]);\n\t\treturn data_length;\n\n\tcase TCODE_LOCK_REQUEST:\n\t\text_tcode = HEADER_GET_EXTENDED_TCODE(r->request_header[3]);\n\t\tdata_length = HEADER_GET_DATA_LENGTH(r->request_header[3]);\n\t\tswitch (ext_tcode) {\n\t\tcase EXTCODE_FETCH_ADD:\n\t\tcase EXTCODE_LITTLE_ADD:\n\t\t\treturn data_length;\n\t\tdefault:\n\t\t\treturn data_length / 2;\n\t\t}\n\n\tdefault:\n\t\tWARN(1, \"wrong tcode %d\\n\", tcode);\n\t\treturn 0;\n\t}\n}\n\nvoid fw_fill_response(struct fw_packet *response, u32 *request_header,\n\t\t      int rcode, void *payload, size_t length)\n{\n\tint tcode, tlabel, extended_tcode, source, destination;\n\n\ttcode          = HEADER_GET_TCODE(request_header[0]);\n\ttlabel         = HEADER_GET_TLABEL(request_header[0]);\n\tsource         = HEADER_GET_DESTINATION(request_header[0]);\n\tdestination    = HEADER_GET_SOURCE(request_header[1]);\n\textended_tcode = HEADER_GET_EXTENDED_TCODE(request_header[3]);\n\n\tresponse->header[0] =\n\t\tHEADER_RETRY(RETRY_1) |\n\t\tHEADER_TLABEL(tlabel) |\n\t\tHEADER_DESTINATION(destination);\n\tresponse->header[1] =\n\t\tHEADER_SOURCE(source) |\n\t\tHEADER_RCODE(rcode);\n\tresponse->header[2] = 0;\n\n\tswitch (tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\t\tresponse->header[0] |= HEADER_TCODE(TCODE_WRITE_RESPONSE);\n\t\tresponse->header_length = 12;\n\t\tresponse->payload_length = 0;\n\t\tbreak;\n\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\tresponse->header[0] |=\n\t\t\tHEADER_TCODE(TCODE_READ_QUADLET_RESPONSE);\n\t\tif (payload != NULL)\n\t\t\tresponse->header[3] = *(u32 *)payload;\n\t\telse\n\t\t\tresponse->header[3] = 0;\n\t\tresponse->header_length = 16;\n\t\tresponse->payload_length = 0;\n\t\tbreak;\n\n\tcase TCODE_READ_BLOCK_REQUEST:\n\tcase TCODE_LOCK_REQUEST:\n\t\tresponse->header[0] |= HEADER_TCODE(tcode + 2);\n\t\tresponse->header[3] =\n\t\t\tHEADER_DATA_LENGTH(length) |\n\t\t\tHEADER_EXTENDED_TCODE(extended_tcode);\n\t\tresponse->header_length = 16;\n\t\tresponse->payload = payload;\n\t\tresponse->payload_length = length;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"wrong tcode %d\\n\", tcode);\n\t}\n\n\tresponse->payload_mapped = false;\n}\nEXPORT_SYMBOL(fw_fill_response);\n\nstatic u32 compute_split_timeout_timestamp(struct fw_card *card,\n\t\t\t\t\t   u32 request_timestamp)\n{\n\tunsigned int cycles;\n\tu32 timestamp;\n\n\tcycles = card->split_timeout_cycles;\n\tcycles += request_timestamp & 0x1fff;\n\n\ttimestamp = request_timestamp & ~0x1fff;\n\ttimestamp += (cycles / 8000) << 13;\n\ttimestamp |= cycles % 8000;\n\n\treturn timestamp;\n}\n\nstatic struct fw_request *allocate_request(struct fw_card *card,\n\t\t\t\t\t   struct fw_packet *p)\n{\n\tstruct fw_request *request;\n\tu32 *data, length;\n\tint request_tcode;\n\n\trequest_tcode = HEADER_GET_TCODE(p->header[0]);\n\tswitch (request_tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\t\tdata = &p->header[3];\n\t\tlength = 4;\n\t\tbreak;\n\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\tcase TCODE_LOCK_REQUEST:\n\t\tdata = p->payload;\n\t\tlength = HEADER_GET_DATA_LENGTH(p->header[3]);\n\t\tbreak;\n\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\tdata = NULL;\n\t\tlength = 4;\n\t\tbreak;\n\n\tcase TCODE_READ_BLOCK_REQUEST:\n\t\tdata = NULL;\n\t\tlength = HEADER_GET_DATA_LENGTH(p->header[3]);\n\t\tbreak;\n\n\tdefault:\n\t\tfw_notice(card, \"ERROR - corrupt request received - %08x %08x %08x\\n\",\n\t\t\t p->header[0], p->header[1], p->header[2]);\n\t\treturn NULL;\n\t}\n\n\trequest = kmalloc(sizeof(*request) + length, GFP_ATOMIC);\n\tif (request == NULL)\n\t\treturn NULL;\n\tkref_init(&request->kref);\n\n\trequest->response.speed = p->speed;\n\trequest->response.timestamp =\n\t\t\tcompute_split_timeout_timestamp(card, p->timestamp);\n\trequest->response.generation = p->generation;\n\trequest->response.ack = 0;\n\trequest->response.callback = free_response_callback;\n\trequest->ack = p->ack;\n\trequest->timestamp = p->timestamp;\n\trequest->length = length;\n\tif (data)\n\t\tmemcpy(request->data, data, length);\n\n\tmemcpy(request->request_header, p->header, sizeof(p->header));\n\n\treturn request;\n}\n\n \nvoid fw_send_response(struct fw_card *card,\n\t\t      struct fw_request *request, int rcode)\n{\n\t \n\tif (request->ack != ACK_PENDING ||\n\t    HEADER_DESTINATION_IS_BROADCAST(request->request_header[0])) {\n\t\tfw_request_put(request);\n\t\treturn;\n\t}\n\n\tif (rcode == RCODE_COMPLETE)\n\t\tfw_fill_response(&request->response, request->request_header,\n\t\t\t\t rcode, request->data,\n\t\t\t\t fw_get_response_length(request));\n\telse\n\t\tfw_fill_response(&request->response, request->request_header,\n\t\t\t\t rcode, NULL, 0);\n\n\t \n\tfw_request_get(request);\n\n\tcard->driver->send_response(card, &request->response);\n}\nEXPORT_SYMBOL(fw_send_response);\n\n \nint fw_get_request_speed(struct fw_request *request)\n{\n\treturn request->response.speed;\n}\nEXPORT_SYMBOL(fw_get_request_speed);\n\n \nu32 fw_request_get_timestamp(const struct fw_request *request)\n{\n\treturn request->timestamp;\n}\nEXPORT_SYMBOL_GPL(fw_request_get_timestamp);\n\nstatic void handle_exclusive_region_request(struct fw_card *card,\n\t\t\t\t\t    struct fw_packet *p,\n\t\t\t\t\t    struct fw_request *request,\n\t\t\t\t\t    unsigned long long offset)\n{\n\tstruct fw_address_handler *handler;\n\tint tcode, destination, source;\n\n\tdestination = HEADER_GET_DESTINATION(p->header[0]);\n\tsource      = HEADER_GET_SOURCE(p->header[1]);\n\ttcode       = HEADER_GET_TCODE(p->header[0]);\n\tif (tcode == TCODE_LOCK_REQUEST)\n\t\ttcode = 0x10 + HEADER_GET_EXTENDED_TCODE(p->header[3]);\n\n\trcu_read_lock();\n\thandler = lookup_enclosing_address_handler(&address_handler_list,\n\t\t\t\t\t\t   offset, request->length);\n\tif (handler)\n\t\thandler->address_callback(card, request,\n\t\t\t\t\t  tcode, destination, source,\n\t\t\t\t\t  p->generation, offset,\n\t\t\t\t\t  request->data, request->length,\n\t\t\t\t\t  handler->callback_data);\n\trcu_read_unlock();\n\n\tif (!handler)\n\t\tfw_send_response(card, request, RCODE_ADDRESS_ERROR);\n}\n\nstatic void handle_fcp_region_request(struct fw_card *card,\n\t\t\t\t      struct fw_packet *p,\n\t\t\t\t      struct fw_request *request,\n\t\t\t\t      unsigned long long offset)\n{\n\tstruct fw_address_handler *handler;\n\tint tcode, destination, source;\n\n\tif ((offset != (CSR_REGISTER_BASE | CSR_FCP_COMMAND) &&\n\t     offset != (CSR_REGISTER_BASE | CSR_FCP_RESPONSE)) ||\n\t    request->length > 0x200) {\n\t\tfw_send_response(card, request, RCODE_ADDRESS_ERROR);\n\n\t\treturn;\n\t}\n\n\ttcode       = HEADER_GET_TCODE(p->header[0]);\n\tdestination = HEADER_GET_DESTINATION(p->header[0]);\n\tsource      = HEADER_GET_SOURCE(p->header[1]);\n\n\tif (tcode != TCODE_WRITE_QUADLET_REQUEST &&\n\t    tcode != TCODE_WRITE_BLOCK_REQUEST) {\n\t\tfw_send_response(card, request, RCODE_TYPE_ERROR);\n\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(handler, &address_handler_list, link) {\n\t\tif (is_enclosing_handler(handler, offset, request->length))\n\t\t\thandler->address_callback(card, request, tcode,\n\t\t\t\t\t\t  destination, source,\n\t\t\t\t\t\t  p->generation, offset,\n\t\t\t\t\t\t  request->data,\n\t\t\t\t\t\t  request->length,\n\t\t\t\t\t\t  handler->callback_data);\n\t}\n\trcu_read_unlock();\n\n\tfw_send_response(card, request, RCODE_COMPLETE);\n}\n\nvoid fw_core_handle_request(struct fw_card *card, struct fw_packet *p)\n{\n\tstruct fw_request *request;\n\tunsigned long long offset;\n\n\tif (p->ack != ACK_PENDING && p->ack != ACK_COMPLETE)\n\t\treturn;\n\n\tif (TCODE_IS_LINK_INTERNAL(HEADER_GET_TCODE(p->header[0]))) {\n\t\tfw_cdev_handle_phy_packet(card, p);\n\t\treturn;\n\t}\n\n\trequest = allocate_request(card, p);\n\tif (request == NULL) {\n\t\t \n\t\treturn;\n\t}\n\n\toffset = ((u64)HEADER_GET_OFFSET_HIGH(p->header[1]) << 32) |\n\t\tp->header[2];\n\n\tif (!is_in_fcp_region(offset, request->length))\n\t\thandle_exclusive_region_request(card, p, request, offset);\n\telse\n\t\thandle_fcp_region_request(card, p, request, offset);\n\n}\nEXPORT_SYMBOL(fw_core_handle_request);\n\nvoid fw_core_handle_response(struct fw_card *card, struct fw_packet *p)\n{\n\tstruct fw_transaction *t = NULL, *iter;\n\tunsigned long flags;\n\tu32 *data;\n\tsize_t data_length;\n\tint tcode, tlabel, source, rcode;\n\n\ttcode\t= HEADER_GET_TCODE(p->header[0]);\n\ttlabel\t= HEADER_GET_TLABEL(p->header[0]);\n\tsource\t= HEADER_GET_SOURCE(p->header[1]);\n\trcode\t= HEADER_GET_RCODE(p->header[1]);\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry(iter, &card->transaction_list, link) {\n\t\tif (iter->node_id == source && iter->tlabel == tlabel) {\n\t\t\tif (!try_cancel_split_timeout(iter)) {\n\t\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\t\tgoto timed_out;\n\t\t\t}\n\t\t\tlist_del_init(&iter->link);\n\t\t\tcard->tlabel_mask &= ~(1ULL << iter->tlabel);\n\t\t\tt = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tif (!t) {\n timed_out:\n\t\tfw_notice(card, \"unsolicited response (source %x, tlabel %x)\\n\",\n\t\t\t  source, tlabel);\n\t\treturn;\n\t}\n\n\t \n\n\tswitch (tcode) {\n\tcase TCODE_READ_QUADLET_RESPONSE:\n\t\tdata = (u32 *) &p->header[3];\n\t\tdata_length = 4;\n\t\tbreak;\n\n\tcase TCODE_WRITE_RESPONSE:\n\t\tdata = NULL;\n\t\tdata_length = 0;\n\t\tbreak;\n\n\tcase TCODE_READ_BLOCK_RESPONSE:\n\tcase TCODE_LOCK_RESPONSE:\n\t\tdata = p->payload;\n\t\tdata_length = HEADER_GET_DATA_LENGTH(p->header[3]);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdata = NULL;\n\t\tdata_length = 0;\n\t\tbreak;\n\t}\n\n\t \n\tcard->driver->cancel_packet(card, &t->packet);\n\n\tif (!t->with_tstamp) {\n\t\tt->callback.without_tstamp(card, rcode, data, data_length, t->callback_data);\n\t} else {\n\t\tt->callback.with_tstamp(card, rcode, t->packet.timestamp, p->timestamp, data,\n\t\t\t\t\tdata_length, t->callback_data);\n\t}\n}\nEXPORT_SYMBOL(fw_core_handle_response);\n\n \nconst char *fw_rcode_string(int rcode)\n{\n\tstatic const char *const names[] = {\n\t\t[RCODE_COMPLETE]       = \"no error\",\n\t\t[RCODE_CONFLICT_ERROR] = \"conflict error\",\n\t\t[RCODE_DATA_ERROR]     = \"data error\",\n\t\t[RCODE_TYPE_ERROR]     = \"type error\",\n\t\t[RCODE_ADDRESS_ERROR]  = \"address error\",\n\t\t[RCODE_SEND_ERROR]     = \"send error\",\n\t\t[RCODE_CANCELLED]      = \"timeout\",\n\t\t[RCODE_BUSY]           = \"busy\",\n\t\t[RCODE_GENERATION]     = \"bus reset\",\n\t\t[RCODE_NO_ACK]         = \"no ack\",\n\t};\n\n\tif ((unsigned int)rcode < ARRAY_SIZE(names) && names[rcode])\n\t\treturn names[rcode];\n\telse\n\t\treturn \"unknown\";\n}\nEXPORT_SYMBOL(fw_rcode_string);\n\nstatic const struct fw_address_region topology_map_region =\n\t{ .start = CSR_REGISTER_BASE | CSR_TOPOLOGY_MAP,\n\t  .end   = CSR_REGISTER_BASE | CSR_TOPOLOGY_MAP_END, };\n\nstatic void handle_topology_map(struct fw_card *card, struct fw_request *request,\n\t\tint tcode, int destination, int source, int generation,\n\t\tunsigned long long offset, void *payload, size_t length,\n\t\tvoid *callback_data)\n{\n\tint start;\n\n\tif (!TCODE_IS_READ_REQUEST(tcode)) {\n\t\tfw_send_response(card, request, RCODE_TYPE_ERROR);\n\t\treturn;\n\t}\n\n\tif ((offset & 3) > 0 || (length & 3) > 0) {\n\t\tfw_send_response(card, request, RCODE_ADDRESS_ERROR);\n\t\treturn;\n\t}\n\n\tstart = (offset - topology_map_region.start) / 4;\n\tmemcpy(payload, &card->topology_map[start], length);\n\n\tfw_send_response(card, request, RCODE_COMPLETE);\n}\n\nstatic struct fw_address_handler topology_map = {\n\t.length\t\t\t= 0x400,\n\t.address_callback\t= handle_topology_map,\n};\n\nstatic const struct fw_address_region registers_region =\n\t{ .start = CSR_REGISTER_BASE,\n\t  .end   = CSR_REGISTER_BASE | CSR_CONFIG_ROM, };\n\nstatic void update_split_timeout(struct fw_card *card)\n{\n\tunsigned int cycles;\n\n\tcycles = card->split_timeout_hi * 8000 + (card->split_timeout_lo >> 19);\n\n\t \n\tcycles = clamp(cycles, 800u, 3u * 8000u);\n\n\tcard->split_timeout_cycles = cycles;\n\tcard->split_timeout_jiffies = DIV_ROUND_UP(cycles * HZ, 8000);\n}\n\nstatic void handle_registers(struct fw_card *card, struct fw_request *request,\n\t\tint tcode, int destination, int source, int generation,\n\t\tunsigned long long offset, void *payload, size_t length,\n\t\tvoid *callback_data)\n{\n\tint reg = offset & ~CSR_REGISTER_BASE;\n\t__be32 *data = payload;\n\tint rcode = RCODE_COMPLETE;\n\tunsigned long flags;\n\n\tswitch (reg) {\n\tcase CSR_PRIORITY_BUDGET:\n\t\tif (!card->priority_budget_implemented) {\n\t\t\trcode = RCODE_ADDRESS_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase CSR_NODE_IDS:\n\t\t \n\t\tfallthrough;\n\n\tcase CSR_STATE_CLEAR:\n\tcase CSR_STATE_SET:\n\tcase CSR_CYCLE_TIME:\n\tcase CSR_BUS_TIME:\n\tcase CSR_BUSY_TIMEOUT:\n\t\tif (tcode == TCODE_READ_QUADLET_REQUEST)\n\t\t\t*data = cpu_to_be32(card->driver->read_csr(card, reg));\n\t\telse if (tcode == TCODE_WRITE_QUADLET_REQUEST)\n\t\t\tcard->driver->write_csr(card, reg, be32_to_cpu(*data));\n\t\telse\n\t\t\trcode = RCODE_TYPE_ERROR;\n\t\tbreak;\n\n\tcase CSR_RESET_START:\n\t\tif (tcode == TCODE_WRITE_QUADLET_REQUEST)\n\t\t\tcard->driver->write_csr(card, CSR_STATE_CLEAR,\n\t\t\t\t\t\tCSR_STATE_BIT_ABDICATE);\n\t\telse\n\t\t\trcode = RCODE_TYPE_ERROR;\n\t\tbreak;\n\n\tcase CSR_SPLIT_TIMEOUT_HI:\n\t\tif (tcode == TCODE_READ_QUADLET_REQUEST) {\n\t\t\t*data = cpu_to_be32(card->split_timeout_hi);\n\t\t} else if (tcode == TCODE_WRITE_QUADLET_REQUEST) {\n\t\t\tspin_lock_irqsave(&card->lock, flags);\n\t\t\tcard->split_timeout_hi = be32_to_cpu(*data) & 7;\n\t\t\tupdate_split_timeout(card);\n\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t} else {\n\t\t\trcode = RCODE_TYPE_ERROR;\n\t\t}\n\t\tbreak;\n\n\tcase CSR_SPLIT_TIMEOUT_LO:\n\t\tif (tcode == TCODE_READ_QUADLET_REQUEST) {\n\t\t\t*data = cpu_to_be32(card->split_timeout_lo);\n\t\t} else if (tcode == TCODE_WRITE_QUADLET_REQUEST) {\n\t\t\tspin_lock_irqsave(&card->lock, flags);\n\t\t\tcard->split_timeout_lo =\n\t\t\t\t\tbe32_to_cpu(*data) & 0xfff80000;\n\t\t\tupdate_split_timeout(card);\n\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t} else {\n\t\t\trcode = RCODE_TYPE_ERROR;\n\t\t}\n\t\tbreak;\n\n\tcase CSR_MAINT_UTILITY:\n\t\tif (tcode == TCODE_READ_QUADLET_REQUEST)\n\t\t\t*data = card->maint_utility_register;\n\t\telse if (tcode == TCODE_WRITE_QUADLET_REQUEST)\n\t\t\tcard->maint_utility_register = *data;\n\t\telse\n\t\t\trcode = RCODE_TYPE_ERROR;\n\t\tbreak;\n\n\tcase CSR_BROADCAST_CHANNEL:\n\t\tif (tcode == TCODE_READ_QUADLET_REQUEST)\n\t\t\t*data = cpu_to_be32(card->broadcast_channel);\n\t\telse if (tcode == TCODE_WRITE_QUADLET_REQUEST)\n\t\t\tcard->broadcast_channel =\n\t\t\t    (be32_to_cpu(*data) & BROADCAST_CHANNEL_VALID) |\n\t\t\t    BROADCAST_CHANNEL_INITIAL;\n\t\telse\n\t\t\trcode = RCODE_TYPE_ERROR;\n\t\tbreak;\n\n\tcase CSR_BUS_MANAGER_ID:\n\tcase CSR_BANDWIDTH_AVAILABLE:\n\tcase CSR_CHANNELS_AVAILABLE_HI:\n\tcase CSR_CHANNELS_AVAILABLE_LO:\n\t\t \n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\trcode = RCODE_ADDRESS_ERROR;\n\t\tbreak;\n\t}\n\n\tfw_send_response(card, request, rcode);\n}\n\nstatic struct fw_address_handler registers = {\n\t.length\t\t\t= 0x400,\n\t.address_callback\t= handle_registers,\n};\n\nstatic void handle_low_memory(struct fw_card *card, struct fw_request *request,\n\t\tint tcode, int destination, int source, int generation,\n\t\tunsigned long long offset, void *payload, size_t length,\n\t\tvoid *callback_data)\n{\n\t \n\tfw_send_response(card, request, RCODE_TYPE_ERROR);\n}\n\nstatic struct fw_address_handler low_memory = {\n\t.length\t\t\t= FW_MAX_PHYSICAL_RANGE,\n\t.address_callback\t= handle_low_memory,\n};\n\nMODULE_AUTHOR(\"Kristian Hoegsberg <krh@bitplanet.net>\");\nMODULE_DESCRIPTION(\"Core IEEE1394 transaction logic\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const u32 vendor_textual_descriptor[] = {\n\t \n\t0x00060000,\n\t0x00000000,\n\t0x00000000,\n\t0x4c696e75,\t\t \n\t0x78204669,\t\t \n\t0x72657769,\t\t \n\t0x72650000,\t\t \n};\n\nstatic const u32 model_textual_descriptor[] = {\n\t \n\t0x00030000,\n\t0x00000000,\n\t0x00000000,\n\t0x4a756a75,\t\t \n};\n\nstatic struct fw_descriptor vendor_id_descriptor = {\n\t.length = ARRAY_SIZE(vendor_textual_descriptor),\n\t.immediate = 0x03001f11,\n\t.key = 0x81000000,\n\t.data = vendor_textual_descriptor,\n};\n\nstatic struct fw_descriptor model_id_descriptor = {\n\t.length = ARRAY_SIZE(model_textual_descriptor),\n\t.immediate = 0x17023901,\n\t.key = 0x81000000,\n\t.data = model_textual_descriptor,\n};\n\nstatic int __init fw_core_init(void)\n{\n\tint ret;\n\n\tfw_workqueue = alloc_workqueue(\"firewire\", WQ_MEM_RECLAIM, 0);\n\tif (!fw_workqueue)\n\t\treturn -ENOMEM;\n\n\tret = bus_register(&fw_bus_type);\n\tif (ret < 0) {\n\t\tdestroy_workqueue(fw_workqueue);\n\t\treturn ret;\n\t}\n\n\tfw_cdev_major = register_chrdev(0, \"firewire\", &fw_device_ops);\n\tif (fw_cdev_major < 0) {\n\t\tbus_unregister(&fw_bus_type);\n\t\tdestroy_workqueue(fw_workqueue);\n\t\treturn fw_cdev_major;\n\t}\n\n\tfw_core_add_address_handler(&topology_map, &topology_map_region);\n\tfw_core_add_address_handler(&registers, &registers_region);\n\tfw_core_add_address_handler(&low_memory, &low_memory_region);\n\tfw_core_add_descriptor(&vendor_id_descriptor);\n\tfw_core_add_descriptor(&model_id_descriptor);\n\n\treturn 0;\n}\n\nstatic void __exit fw_core_cleanup(void)\n{\n\tunregister_chrdev(fw_cdev_major, \"firewire\");\n\tbus_unregister(&fw_bus_type);\n\tdestroy_workqueue(fw_workqueue);\n\tidr_destroy(&fw_device_idr);\n}\n\nmodule_init(fw_core_init);\nmodule_exit(fw_core_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}