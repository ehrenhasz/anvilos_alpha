{
  "module_name": "ssi_protocol.c",
  "hash_id": "c4c8f44c188f716c76344bef1039f45b8aeeca8896b0914696e092895bde9831",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hsi/clients/ssi_protocol.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/if_phonet.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/scatterlist.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/hsi/hsi.h>\n#include <linux/hsi/ssi_protocol.h>\n\n#define SSIP_TXQUEUE_LEN\t100\n#define SSIP_MAX_MTU\t\t65535\n#define SSIP_DEFAULT_MTU\t4000\n#define PN_MEDIA_SOS\t\t21\n#define SSIP_MIN_PN_HDR\t\t6\t \n#define SSIP_WDTOUT\t\t2000\t \n#define SSIP_KATOUT\t\t15\t \n#define SSIP_MAX_CMDS\t\t5  \n#define SSIP_BYTES_TO_FRAMES(x) ((((x) - 1) >> 2) + 1)\n#define SSIP_CMT_LOADER_SYNC\t0x11223344\n \n#define SSIP_COMMAND(data)\t((data) >> 28)\n#define SSIP_PAYLOAD(data)\t((data) & 0xfffffff)\n \n#define SSIP_SW_BREAK\t\t0\n#define SSIP_BOOTINFO_REQ\t1\n#define SSIP_BOOTINFO_RESP\t2\n#define SSIP_WAKETEST_RESULT\t3\n#define SSIP_START_TRANS\t4\n#define SSIP_READY\t\t5\n \n#define SSIP_DATA_VERSION(data)\t((data) & 0xff)\n#define SSIP_LOCAL_VERID\t1\n#define SSIP_WAKETEST_OK\t0\n#define SSIP_WAKETEST_FAILED\t1\n#define SSIP_PDU_LENGTH(data)\t(((data) >> 8) & 0xffff)\n#define SSIP_MSG_ID(data)\t((data) & 0xff)\n \n#define SSIP_CMD(cmd, payload)\t(((cmd) << 28) | ((payload) & 0xfffffff))\n \n#define SSIP_BOOTINFO_REQ_CMD(ver) \\\n\t\tSSIP_CMD(SSIP_BOOTINFO_REQ, SSIP_DATA_VERSION(ver))\n#define SSIP_BOOTINFO_RESP_CMD(ver) \\\n\t\tSSIP_CMD(SSIP_BOOTINFO_RESP, SSIP_DATA_VERSION(ver))\n#define SSIP_START_TRANS_CMD(pdulen, id) \\\n\t\tSSIP_CMD(SSIP_START_TRANS, (((pdulen) << 8) | SSIP_MSG_ID(id)))\n#define SSIP_READY_CMD\t\tSSIP_CMD(SSIP_READY, 0)\n#define SSIP_SWBREAK_CMD\tSSIP_CMD(SSIP_SW_BREAK, 0)\n\n#define SSIP_WAKETEST_FLAG 0\n\n \nenum {\n\tINIT,\n\tHANDSHAKE,\n\tACTIVE,\n};\n\n \nenum {\n\tSEND_IDLE,\n\tWAIT4READY,\n\tSEND_READY,\n\tSENDING,\n\tSENDING_SWBREAK,\n};\n\n \nenum {\n\tRECV_IDLE,\n\tRECV_READY,\n\tRECEIVING,\n};\n\n \nstruct ssi_protocol {\n\tunsigned int\t\tmain_state;\n\tunsigned int\t\tsend_state;\n\tunsigned int\t\trecv_state;\n\tunsigned long\t\tflags;\n\tu8\t\t\trxid;\n\tu8\t\t\ttxid;\n\tunsigned int\t\ttxqueue_len;\n\tstruct timer_list\ttx_wd;\n\tstruct timer_list\trx_wd;\n\tstruct timer_list\tkeep_alive;  \n\tspinlock_t\t\tlock;\n\tstruct net_device\t*netdev;\n\tstruct list_head\ttxqueue;\n\tstruct list_head\tcmdqueue;\n\tstruct work_struct\twork;\n\tstruct hsi_client\t*cl;\n\tstruct list_head\tlink;\n\tatomic_t\t\ttx_usecnt;\n\tint\t\t\tchannel_id_cmd;\n\tint\t\t\tchannel_id_data;\n};\n\n \nstatic LIST_HEAD(ssip_list);\n\nstatic void ssip_rxcmd_complete(struct hsi_msg *msg);\n\nstatic inline void ssip_set_cmd(struct hsi_msg *msg, u32 cmd)\n{\n\tu32 *data;\n\n\tdata = sg_virt(msg->sgt.sgl);\n\t*data = cmd;\n}\n\nstatic inline u32 ssip_get_cmd(struct hsi_msg *msg)\n{\n\tu32 *data;\n\n\tdata = sg_virt(msg->sgt.sgl);\n\n\treturn *data;\n}\n\nstatic void ssip_skb_to_msg(struct sk_buff *skb, struct hsi_msg *msg)\n{\n\tskb_frag_t *frag;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tBUG_ON(msg->sgt.nents != (unsigned int)(skb_shinfo(skb)->nr_frags + 1));\n\n\tsg = msg->sgt.sgl;\n\tsg_set_buf(sg, skb->data, skb_headlen(skb));\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tsg = sg_next(sg);\n\t\tBUG_ON(!sg);\n\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\tsg_set_page(sg, skb_frag_page(frag), skb_frag_size(frag),\n\t\t\t\tskb_frag_off(frag));\n\t}\n}\n\nstatic void ssip_free_data(struct hsi_msg *msg)\n{\n\tstruct sk_buff *skb;\n\n\tskb = msg->context;\n\tpr_debug(\"free data: msg %p context %p skb %p\\n\", msg, msg->context,\n\t\t\t\t\t\t\t\tskb);\n\tmsg->destructor = NULL;\n\tdev_kfree_skb(skb);\n\thsi_free_msg(msg);\n}\n\nstatic struct hsi_msg *ssip_alloc_data(struct ssi_protocol *ssi,\n\t\t\t\t\tstruct sk_buff *skb, gfp_t flags)\n{\n\tstruct hsi_msg *msg;\n\n\tmsg = hsi_alloc_msg(skb_shinfo(skb)->nr_frags + 1, flags);\n\tif (!msg)\n\t\treturn NULL;\n\tssip_skb_to_msg(skb, msg);\n\tmsg->destructor = ssip_free_data;\n\tmsg->channel = ssi->channel_id_data;\n\tmsg->context = skb;\n\n\treturn msg;\n}\n\nstatic inline void ssip_release_cmd(struct hsi_msg *msg)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(msg->cl);\n\n\tdev_dbg(&msg->cl->device, \"Release cmd 0x%08x\\n\", ssip_get_cmd(msg));\n\tspin_lock_bh(&ssi->lock);\n\tlist_add_tail(&msg->link, &ssi->cmdqueue);\n\tspin_unlock_bh(&ssi->lock);\n}\n\nstatic struct hsi_msg *ssip_claim_cmd(struct ssi_protocol *ssi)\n{\n\tstruct hsi_msg *msg;\n\n\tBUG_ON(list_empty(&ssi->cmdqueue));\n\n\tspin_lock_bh(&ssi->lock);\n\tmsg = list_first_entry(&ssi->cmdqueue, struct hsi_msg, link);\n\tlist_del(&msg->link);\n\tspin_unlock_bh(&ssi->lock);\n\tmsg->destructor = ssip_release_cmd;\n\n\treturn msg;\n}\n\nstatic void ssip_free_cmds(struct ssi_protocol *ssi)\n{\n\tstruct hsi_msg *msg, *tmp;\n\n\tlist_for_each_entry_safe(msg, tmp, &ssi->cmdqueue, link) {\n\t\tlist_del(&msg->link);\n\t\tmsg->destructor = NULL;\n\t\tkfree(sg_virt(msg->sgt.sgl));\n\t\thsi_free_msg(msg);\n\t}\n}\n\nstatic int ssip_alloc_cmds(struct ssi_protocol *ssi)\n{\n\tstruct hsi_msg *msg;\n\tu32 *buf;\n\tunsigned int i;\n\n\tfor (i = 0; i < SSIP_MAX_CMDS; i++) {\n\t\tmsg = hsi_alloc_msg(1, GFP_KERNEL);\n\t\tif (!msg)\n\t\t\tgoto out;\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\thsi_free_msg(msg);\n\t\t\tgoto out;\n\t\t}\n\t\tsg_init_one(msg->sgt.sgl, buf, sizeof(*buf));\n\t\tmsg->channel = ssi->channel_id_cmd;\n\t\tlist_add_tail(&msg->link, &ssi->cmdqueue);\n\t}\n\n\treturn 0;\nout:\n\tssip_free_cmds(ssi);\n\n\treturn -ENOMEM;\n}\n\nstatic void ssip_set_rxstate(struct ssi_protocol *ssi, unsigned int state)\n{\n\tssi->recv_state = state;\n\tswitch (state) {\n\tcase RECV_IDLE:\n\t\tdel_timer(&ssi->rx_wd);\n\t\tif (ssi->send_state == SEND_IDLE)\n\t\t\tdel_timer(&ssi->keep_alive);\n\t\tbreak;\n\tcase RECV_READY:\n\t\t \n\t\tif (atomic_read(&ssi->tx_usecnt))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase RECEIVING:\n\t\tmod_timer(&ssi->keep_alive, jiffies +\n\t\t\t\t\t\tmsecs_to_jiffies(SSIP_KATOUT));\n\t\tmod_timer(&ssi->rx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ssip_set_txstate(struct ssi_protocol *ssi, unsigned int state)\n{\n\tssi->send_state = state;\n\tswitch (state) {\n\tcase SEND_IDLE:\n\tcase SEND_READY:\n\t\tdel_timer(&ssi->tx_wd);\n\t\tif (ssi->recv_state == RECV_IDLE)\n\t\t\tdel_timer(&ssi->keep_alive);\n\t\tbreak;\n\tcase WAIT4READY:\n\tcase SENDING:\n\tcase SENDING_SWBREAK:\n\t\tmod_timer(&ssi->keep_alive,\n\t\t\t\tjiffies + msecs_to_jiffies(SSIP_KATOUT));\n\t\tmod_timer(&ssi->tx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstruct hsi_client *ssip_slave_get_master(struct hsi_client *slave)\n{\n\tstruct hsi_client *master = ERR_PTR(-ENODEV);\n\tstruct ssi_protocol *ssi;\n\n\tlist_for_each_entry(ssi, &ssip_list, link)\n\t\tif (slave->device.parent == ssi->cl->device.parent) {\n\t\t\tmaster = ssi->cl;\n\t\t\tbreak;\n\t\t}\n\n\treturn master;\n}\nEXPORT_SYMBOL_GPL(ssip_slave_get_master);\n\nint ssip_slave_start_tx(struct hsi_client *master)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(master);\n\n\tdev_dbg(&master->device, \"start TX %d\\n\", atomic_read(&ssi->tx_usecnt));\n\tspin_lock_bh(&ssi->lock);\n\tif (ssi->send_state == SEND_IDLE) {\n\t\tssip_set_txstate(ssi, WAIT4READY);\n\t\thsi_start_tx(master);\n\t}\n\tspin_unlock_bh(&ssi->lock);\n\tatomic_inc(&ssi->tx_usecnt);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssip_slave_start_tx);\n\nint ssip_slave_stop_tx(struct hsi_client *master)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(master);\n\n\tWARN_ON_ONCE(atomic_read(&ssi->tx_usecnt) == 0);\n\n\tif (atomic_dec_and_test(&ssi->tx_usecnt)) {\n\t\tspin_lock_bh(&ssi->lock);\n\t\tif ((ssi->send_state == SEND_READY) ||\n\t\t\t(ssi->send_state == WAIT4READY)) {\n\t\t\tssip_set_txstate(ssi, SEND_IDLE);\n\t\t\thsi_stop_tx(master);\n\t\t}\n\t\tspin_unlock_bh(&ssi->lock);\n\t}\n\tdev_dbg(&master->device, \"stop TX %d\\n\", atomic_read(&ssi->tx_usecnt));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssip_slave_stop_tx);\n\nint ssip_slave_running(struct hsi_client *master)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(master);\n\treturn netif_running(ssi->netdev);\n}\nEXPORT_SYMBOL_GPL(ssip_slave_running);\n\nstatic void ssip_reset(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct list_head *head, *tmp;\n\tstruct hsi_msg *msg;\n\n\tif (netif_running(ssi->netdev))\n\t\tnetif_carrier_off(ssi->netdev);\n\thsi_flush(cl);\n\tspin_lock_bh(&ssi->lock);\n\tif (ssi->send_state != SEND_IDLE)\n\t\thsi_stop_tx(cl);\n\tspin_unlock_bh(&ssi->lock);\n\tif (test_and_clear_bit(SSIP_WAKETEST_FLAG, &ssi->flags))\n\t\tssi_waketest(cl, 0);  \n\tspin_lock_bh(&ssi->lock);\n\tdel_timer(&ssi->rx_wd);\n\tdel_timer(&ssi->tx_wd);\n\tdel_timer(&ssi->keep_alive);\n\tssi->main_state = 0;\n\tssi->send_state = 0;\n\tssi->recv_state = 0;\n\tssi->flags = 0;\n\tssi->rxid = 0;\n\tssi->txid = 0;\n\tlist_for_each_safe(head, tmp, &ssi->txqueue) {\n\t\tmsg = list_entry(head, struct hsi_msg, link);\n\t\tdev_dbg(&cl->device, \"Pending TX data\\n\");\n\t\tlist_del(head);\n\t\tssip_free_data(msg);\n\t}\n\tssi->txqueue_len = 0;\n\tspin_unlock_bh(&ssi->lock);\n}\n\nstatic void ssip_dump_state(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\n\tspin_lock_bh(&ssi->lock);\n\tdev_err(&cl->device, \"Main state: %d\\n\", ssi->main_state);\n\tdev_err(&cl->device, \"Recv state: %d\\n\", ssi->recv_state);\n\tdev_err(&cl->device, \"Send state: %d\\n\", ssi->send_state);\n\tdev_err(&cl->device, \"CMT %s\\n\", (ssi->main_state == ACTIVE) ?\n\t\t\t\t\t\t\t\"Online\" : \"Offline\");\n\tdev_err(&cl->device, \"Wake test %d\\n\",\n\t\t\t\ttest_bit(SSIP_WAKETEST_FLAG, &ssi->flags));\n\tdev_err(&cl->device, \"Data RX id: %d\\n\", ssi->rxid);\n\tdev_err(&cl->device, \"Data TX id: %d\\n\", ssi->txid);\n\n\tlist_for_each_entry(msg, &ssi->txqueue, link)\n\t\tdev_err(&cl->device, \"pending TX data (%p)\\n\", msg);\n\tspin_unlock_bh(&ssi->lock);\n}\n\nstatic void ssip_error(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\n\tssip_dump_state(cl);\n\tssip_reset(cl);\n\tmsg = ssip_claim_cmd(ssi);\n\tmsg->complete = ssip_rxcmd_complete;\n\thsi_async_read(cl, msg);\n}\n\nstatic void ssip_keep_alive(struct timer_list *t)\n{\n\tstruct ssi_protocol *ssi = from_timer(ssi, t, keep_alive);\n\tstruct hsi_client *cl = ssi->cl;\n\n\tdev_dbg(&cl->device, \"Keep alive kick in: m(%d) r(%d) s(%d)\\n\",\n\t\tssi->main_state, ssi->recv_state, ssi->send_state);\n\n\tspin_lock(&ssi->lock);\n\tif (ssi->recv_state == RECV_IDLE)\n\t\tswitch (ssi->send_state) {\n\t\tcase SEND_READY:\n\t\t\tif (atomic_read(&ssi->tx_usecnt) == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\t\t \n\t\tcase SEND_IDLE:\n\t\t\tspin_unlock(&ssi->lock);\n\t\t\treturn;\n\t\t}\n\tmod_timer(&ssi->keep_alive, jiffies + msecs_to_jiffies(SSIP_KATOUT));\n\tspin_unlock(&ssi->lock);\n}\n\nstatic void ssip_rx_wd(struct timer_list *t)\n{\n\tstruct ssi_protocol *ssi = from_timer(ssi, t, rx_wd);\n\tstruct hsi_client *cl = ssi->cl;\n\n\tdev_err(&cl->device, \"Watchdog triggered\\n\");\n\tssip_error(cl);\n}\n\nstatic void ssip_tx_wd(struct timer_list *t)\n{\n\tstruct ssi_protocol *ssi = from_timer(ssi, t, tx_wd);\n\tstruct hsi_client *cl = ssi->cl;\n\n\tdev_err(&cl->device, \"Watchdog triggered\\n\");\n\tssip_error(cl);\n}\n\nstatic void ssip_send_bootinfo_req_cmd(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\n\tdev_dbg(&cl->device, \"Issuing BOOT INFO REQ command\\n\");\n\tmsg = ssip_claim_cmd(ssi);\n\tssip_set_cmd(msg, SSIP_BOOTINFO_REQ_CMD(SSIP_LOCAL_VERID));\n\tmsg->complete = ssip_release_cmd;\n\thsi_async_write(cl, msg);\n\tdev_dbg(&cl->device, \"Issuing RX command\\n\");\n\tmsg = ssip_claim_cmd(ssi);\n\tmsg->complete = ssip_rxcmd_complete;\n\thsi_async_read(cl, msg);\n}\n\nstatic void ssip_start_rx(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\n\tdev_dbg(&cl->device, \"RX start M(%d) R(%d)\\n\", ssi->main_state,\n\t\t\t\t\t\tssi->recv_state);\n\tspin_lock_bh(&ssi->lock);\n\t \n\tif ((ssi->main_state != ACTIVE) || (ssi->recv_state == RECV_READY)) {\n\t\tspin_unlock_bh(&ssi->lock);\n\t\treturn;\n\t}\n\tssip_set_rxstate(ssi, RECV_READY);\n\tspin_unlock_bh(&ssi->lock);\n\n\tmsg = ssip_claim_cmd(ssi);\n\tssip_set_cmd(msg, SSIP_READY_CMD);\n\tmsg->complete = ssip_release_cmd;\n\tdev_dbg(&cl->device, \"Send READY\\n\");\n\thsi_async_write(cl, msg);\n}\n\nstatic void ssip_stop_rx(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\n\tdev_dbg(&cl->device, \"RX stop M(%d)\\n\", ssi->main_state);\n\tspin_lock_bh(&ssi->lock);\n\tif (likely(ssi->main_state == ACTIVE))\n\t\tssip_set_rxstate(ssi, RECV_IDLE);\n\tspin_unlock_bh(&ssi->lock);\n}\n\nstatic void ssip_free_strans(struct hsi_msg *msg)\n{\n\tssip_free_data(msg->context);\n\tssip_release_cmd(msg);\n}\n\nstatic void ssip_strans_complete(struct hsi_msg *msg)\n{\n\tstruct hsi_client *cl = msg->cl;\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *data;\n\n\tdata = msg->context;\n\tssip_release_cmd(msg);\n\tspin_lock_bh(&ssi->lock);\n\tssip_set_txstate(ssi, SENDING);\n\tspin_unlock_bh(&ssi->lock);\n\thsi_async_write(cl, data);\n}\n\nstatic int ssip_xmit(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg, *dmsg;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&ssi->lock);\n\tif (list_empty(&ssi->txqueue)) {\n\t\tspin_unlock_bh(&ssi->lock);\n\t\treturn 0;\n\t}\n\tdmsg = list_first_entry(&ssi->txqueue, struct hsi_msg, link);\n\tlist_del(&dmsg->link);\n\tssi->txqueue_len--;\n\tspin_unlock_bh(&ssi->lock);\n\n\tmsg = ssip_claim_cmd(ssi);\n\tskb = dmsg->context;\n\tmsg->context = dmsg;\n\tmsg->complete = ssip_strans_complete;\n\tmsg->destructor = ssip_free_strans;\n\n\tspin_lock_bh(&ssi->lock);\n\tssip_set_cmd(msg, SSIP_START_TRANS_CMD(SSIP_BYTES_TO_FRAMES(skb->len),\n\t\t\t\t\t\t\t\tssi->txid));\n\tssi->txid++;\n\tssip_set_txstate(ssi, SENDING);\n\tspin_unlock_bh(&ssi->lock);\n\n\tdev_dbg(&cl->device, \"Send STRANS (%d frames)\\n\",\n\t\t\t\t\t\tSSIP_BYTES_TO_FRAMES(skb->len));\n\n\treturn hsi_async_write(cl, msg);\n}\n\n \nstatic void ssip_pn_rx(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\n\tif (unlikely(!netif_running(dev))) {\n\t\tdev_dbg(&dev->dev, \"Drop RX packet\\n\");\n\t\tdev->stats.rx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tif (unlikely(!pskb_may_pull(skb, SSIP_MIN_PN_HDR))) {\n\t\tdev_dbg(&dev->dev, \"Error drop RX packet\\n\");\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_length_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += skb->len;\n\n\t \n\t((u16 *)skb->data)[2] = ntohs(((u16 *)skb->data)[2]);\n\tdev_dbg(&dev->dev, \"RX length fixed (%04x -> %u)\\n\",\n\t\t\t((u16 *)skb->data)[2], ntohs(((u16 *)skb->data)[2]));\n\n\tskb->protocol = htons(ETH_P_PHONET);\n\tskb_reset_mac_header(skb);\n\t__skb_pull(skb, 1);\n\tnetif_rx(skb);\n}\n\nstatic void ssip_rx_data_complete(struct hsi_msg *msg)\n{\n\tstruct hsi_client *cl = msg->cl;\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct sk_buff *skb;\n\n\tif (msg->status == HSI_STATUS_ERROR) {\n\t\tdev_err(&cl->device, \"RX data error\\n\");\n\t\tssip_free_data(msg);\n\t\tssip_error(cl);\n\t\treturn;\n\t}\n\tdel_timer(&ssi->rx_wd);  \n\tskb = msg->context;\n\tssip_pn_rx(skb);\n\thsi_free_msg(msg);\n}\n\nstatic void ssip_rx_bootinforeq(struct hsi_client *cl, u32 cmd)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\n\t \n\tif (cmd == SSIP_CMT_LOADER_SYNC)\n\t\treturn;\n\n\tswitch (ssi->main_state) {\n\tcase ACTIVE:\n\t\tdev_err(&cl->device, \"Boot info req on active state\\n\");\n\t\tssip_error(cl);\n\t\tfallthrough;\n\tcase INIT:\n\tcase HANDSHAKE:\n\t\tspin_lock_bh(&ssi->lock);\n\t\tssi->main_state = HANDSHAKE;\n\t\tspin_unlock_bh(&ssi->lock);\n\n\t\tif (!test_and_set_bit(SSIP_WAKETEST_FLAG, &ssi->flags))\n\t\t\tssi_waketest(cl, 1);  \n\n\t\tspin_lock_bh(&ssi->lock);\n\t\t \n\t\tmod_timer(&ssi->tx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tdev_dbg(&cl->device, \"Send BOOTINFO_RESP\\n\");\n\t\tif (SSIP_DATA_VERSION(cmd) != SSIP_LOCAL_VERID)\n\t\t\tdev_warn(&cl->device, \"boot info req verid mismatch\\n\");\n\t\tmsg = ssip_claim_cmd(ssi);\n\t\tssip_set_cmd(msg, SSIP_BOOTINFO_RESP_CMD(SSIP_LOCAL_VERID));\n\t\tmsg->complete = ssip_release_cmd;\n\t\thsi_async_write(cl, msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&cl->device, \"Wrong state M(%d)\\n\", ssi->main_state);\n\t\tbreak;\n\t}\n}\n\nstatic void ssip_rx_bootinforesp(struct hsi_client *cl, u32 cmd)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\n\tif (SSIP_DATA_VERSION(cmd) != SSIP_LOCAL_VERID)\n\t\tdev_warn(&cl->device, \"boot info resp verid mismatch\\n\");\n\n\tspin_lock_bh(&ssi->lock);\n\tif (ssi->main_state != ACTIVE)\n\t\t \n\t\tmod_timer(&ssi->tx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\n\telse\n\t\tdev_dbg(&cl->device, \"boot info resp ignored M(%d)\\n\",\n\t\t\t\t\t\t\tssi->main_state);\n\tspin_unlock_bh(&ssi->lock);\n}\n\nstatic void ssip_rx_waketest(struct hsi_client *cl, u32 cmd)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tunsigned int wkres = SSIP_PAYLOAD(cmd);\n\n\tspin_lock_bh(&ssi->lock);\n\tif (ssi->main_state != HANDSHAKE) {\n\t\tdev_dbg(&cl->device, \"wake lines test ignored M(%d)\\n\",\n\t\t\t\t\t\t\tssi->main_state);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\treturn;\n\t}\n\tspin_unlock_bh(&ssi->lock);\n\n\tif (test_and_clear_bit(SSIP_WAKETEST_FLAG, &ssi->flags))\n\t\tssi_waketest(cl, 0);  \n\n\tspin_lock_bh(&ssi->lock);\n\tssi->main_state = ACTIVE;\n\tdel_timer(&ssi->tx_wd);  \n\tspin_unlock_bh(&ssi->lock);\n\n\tdev_notice(&cl->device, \"WAKELINES TEST %s\\n\",\n\t\t\t\twkres & SSIP_WAKETEST_FAILED ? \"FAILED\" : \"OK\");\n\tif (wkres & SSIP_WAKETEST_FAILED) {\n\t\tssip_error(cl);\n\t\treturn;\n\t}\n\tdev_dbg(&cl->device, \"CMT is ONLINE\\n\");\n\tnetif_wake_queue(ssi->netdev);\n\tnetif_carrier_on(ssi->netdev);\n}\n\nstatic void ssip_rx_ready(struct hsi_client *cl)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\n\tspin_lock_bh(&ssi->lock);\n\tif (unlikely(ssi->main_state != ACTIVE)) {\n\t\tdev_dbg(&cl->device, \"READY on wrong state: S(%d) M(%d)\\n\",\n\t\t\t\t\tssi->send_state, ssi->main_state);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\treturn;\n\t}\n\tif (ssi->send_state != WAIT4READY) {\n\t\tdev_dbg(&cl->device, \"Ignore spurious READY command\\n\");\n\t\tspin_unlock_bh(&ssi->lock);\n\t\treturn;\n\t}\n\tssip_set_txstate(ssi, SEND_READY);\n\tspin_unlock_bh(&ssi->lock);\n\tssip_xmit(cl);\n}\n\nstatic void ssip_rx_strans(struct hsi_client *cl, u32 cmd)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct sk_buff *skb;\n\tstruct hsi_msg *msg;\n\tint len = SSIP_PDU_LENGTH(cmd);\n\n\tdev_dbg(&cl->device, \"RX strans: %d frames\\n\", len);\n\tspin_lock_bh(&ssi->lock);\n\tif (unlikely(ssi->main_state != ACTIVE)) {\n\t\tdev_err(&cl->device, \"START TRANS wrong state: S(%d) M(%d)\\n\",\n\t\t\t\t\tssi->send_state, ssi->main_state);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\treturn;\n\t}\n\tssip_set_rxstate(ssi, RECEIVING);\n\tif (unlikely(SSIP_MSG_ID(cmd) != ssi->rxid)) {\n\t\tdev_err(&cl->device, \"START TRANS id %d expected %d\\n\",\n\t\t\t\t\tSSIP_MSG_ID(cmd), ssi->rxid);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tgoto out1;\n\t}\n\tssi->rxid++;\n\tspin_unlock_bh(&ssi->lock);\n\tskb = netdev_alloc_skb(ssi->netdev, len * 4);\n\tif (unlikely(!skb)) {\n\t\tdev_err(&cl->device, \"No memory for rx skb\\n\");\n\t\tgoto out1;\n\t}\n\tskb_put(skb, len * 4);\n\tmsg = ssip_alloc_data(ssi, skb, GFP_ATOMIC);\n\tif (unlikely(!msg)) {\n\t\tdev_err(&cl->device, \"No memory for RX data msg\\n\");\n\t\tgoto out2;\n\t}\n\tmsg->complete = ssip_rx_data_complete;\n\thsi_async_read(cl, msg);\n\n\treturn;\nout2:\n\tdev_kfree_skb(skb);\nout1:\n\tssip_error(cl);\n}\n\nstatic void ssip_rxcmd_complete(struct hsi_msg *msg)\n{\n\tstruct hsi_client *cl = msg->cl;\n\tu32 cmd = ssip_get_cmd(msg);\n\tunsigned int cmdid = SSIP_COMMAND(cmd);\n\n\tif (msg->status == HSI_STATUS_ERROR) {\n\t\tdev_err(&cl->device, \"RX error detected\\n\");\n\t\tssip_release_cmd(msg);\n\t\tssip_error(cl);\n\t\treturn;\n\t}\n\thsi_async_read(cl, msg);\n\tdev_dbg(&cl->device, \"RX cmd: 0x%08x\\n\", cmd);\n\tswitch (cmdid) {\n\tcase SSIP_SW_BREAK:\n\t\t \n\t\tbreak;\n\tcase SSIP_BOOTINFO_REQ:\n\t\tssip_rx_bootinforeq(cl, cmd);\n\t\tbreak;\n\tcase SSIP_BOOTINFO_RESP:\n\t\tssip_rx_bootinforesp(cl, cmd);\n\t\tbreak;\n\tcase SSIP_WAKETEST_RESULT:\n\t\tssip_rx_waketest(cl, cmd);\n\t\tbreak;\n\tcase SSIP_START_TRANS:\n\t\tssip_rx_strans(cl, cmd);\n\t\tbreak;\n\tcase SSIP_READY:\n\t\tssip_rx_ready(cl);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&cl->device, \"command 0x%08x not supported\\n\", cmd);\n\t\tbreak;\n\t}\n}\n\nstatic void ssip_swbreak_complete(struct hsi_msg *msg)\n{\n\tstruct hsi_client *cl = msg->cl;\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\n\tssip_release_cmd(msg);\n\tspin_lock_bh(&ssi->lock);\n\tif (list_empty(&ssi->txqueue)) {\n\t\tif (atomic_read(&ssi->tx_usecnt)) {\n\t\t\tssip_set_txstate(ssi, SEND_READY);\n\t\t} else {\n\t\t\tssip_set_txstate(ssi, SEND_IDLE);\n\t\t\thsi_stop_tx(cl);\n\t\t}\n\t\tspin_unlock_bh(&ssi->lock);\n\t} else {\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tssip_xmit(cl);\n\t}\n\tnetif_wake_queue(ssi->netdev);\n}\n\nstatic void ssip_tx_data_complete(struct hsi_msg *msg)\n{\n\tstruct hsi_client *cl = msg->cl;\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *cmsg;\n\n\tif (msg->status == HSI_STATUS_ERROR) {\n\t\tdev_err(&cl->device, \"TX data error\\n\");\n\t\tssip_error(cl);\n\t\tgoto out;\n\t}\n\tspin_lock_bh(&ssi->lock);\n\tif (list_empty(&ssi->txqueue)) {\n\t\tssip_set_txstate(ssi, SENDING_SWBREAK);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tcmsg = ssip_claim_cmd(ssi);\n\t\tssip_set_cmd(cmsg, SSIP_SWBREAK_CMD);\n\t\tcmsg->complete = ssip_swbreak_complete;\n\t\tdev_dbg(&cl->device, \"Send SWBREAK\\n\");\n\t\thsi_async_write(cl, cmsg);\n\t} else {\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tssip_xmit(cl);\n\t}\nout:\n\tssip_free_data(msg);\n}\n\nstatic void ssip_port_event(struct hsi_client *cl, unsigned long event)\n{\n\tswitch (event) {\n\tcase HSI_EVENT_START_RX:\n\t\tssip_start_rx(cl);\n\t\tbreak;\n\tcase HSI_EVENT_STOP_RX:\n\t\tssip_stop_rx(cl);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic int ssip_pn_open(struct net_device *dev)\n{\n\tstruct hsi_client *cl = to_hsi_client(dev->dev.parent);\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tint err;\n\n\terr = hsi_claim_port(cl, 1);\n\tif (err < 0) {\n\t\tdev_err(&cl->device, \"SSI port already claimed\\n\");\n\t\treturn err;\n\t}\n\terr = hsi_register_port_event(cl, ssip_port_event);\n\tif (err < 0) {\n\t\tdev_err(&cl->device, \"Register HSI port event failed (%d)\\n\",\n\t\t\terr);\n\t\thsi_release_port(cl);\n\t\treturn err;\n\t}\n\tdev_dbg(&cl->device, \"Configuring SSI port\\n\");\n\thsi_setup(cl);\n\n\tif (!test_and_set_bit(SSIP_WAKETEST_FLAG, &ssi->flags))\n\t\tssi_waketest(cl, 1);  \n\n\tspin_lock_bh(&ssi->lock);\n\tssi->main_state = HANDSHAKE;\n\tspin_unlock_bh(&ssi->lock);\n\n\tssip_send_bootinfo_req_cmd(cl);\n\n\treturn 0;\n}\n\nstatic int ssip_pn_stop(struct net_device *dev)\n{\n\tstruct hsi_client *cl = to_hsi_client(dev->dev.parent);\n\n\tssip_reset(cl);\n\thsi_unregister_port_event(cl);\n\thsi_release_port(cl);\n\n\treturn 0;\n}\n\nstatic void ssip_xmit_work(struct work_struct *work)\n{\n\tstruct ssi_protocol *ssi =\n\t\t\t\tcontainer_of(work, struct ssi_protocol, work);\n\tstruct hsi_client *cl = ssi->cl;\n\n\tssip_xmit(cl);\n}\n\nstatic netdev_tx_t ssip_pn_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hsi_client *cl = to_hsi_client(dev->dev.parent);\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\n\tif ((skb->protocol != htons(ETH_P_PHONET)) ||\n\t\t\t\t\t(skb->len < SSIP_MIN_PN_HDR))\n\t\tgoto drop;\n\t \n\tif ((skb->len & 3) && skb_pad(skb, 4 - (skb->len & 3)))\n\t\tgoto inc_dropped;\n\n\t \n\tif (skb_cow_head(skb, 0))\n\t\tgoto drop;\n\n\t \n\t((u16 *)skb->data)[2] = htons(((u16 *)skb->data)[2]);\n\n\tmsg = ssip_alloc_data(ssi, skb, GFP_ATOMIC);\n\tif (!msg) {\n\t\tdev_dbg(&cl->device, \"Dropping tx data: No memory\\n\");\n\t\tgoto drop;\n\t}\n\tmsg->complete = ssip_tx_data_complete;\n\n\tspin_lock_bh(&ssi->lock);\n\tif (unlikely(ssi->main_state != ACTIVE)) {\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tdev_dbg(&cl->device, \"Dropping tx data: CMT is OFFLINE\\n\");\n\t\tgoto drop2;\n\t}\n\tlist_add_tail(&msg->link, &ssi->txqueue);\n\tssi->txqueue_len++;\n\tif (dev->tx_queue_len < ssi->txqueue_len) {\n\t\tdev_info(&cl->device, \"TX queue full %d\\n\", ssi->txqueue_len);\n\t\tnetif_stop_queue(dev);\n\t}\n\tif (ssi->send_state == SEND_IDLE) {\n\t\tssip_set_txstate(ssi, WAIT4READY);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tdev_dbg(&cl->device, \"Start TX qlen %d\\n\", ssi->txqueue_len);\n\t\thsi_start_tx(cl);\n\t} else if (ssi->send_state == SEND_READY) {\n\t\t \n\t\tdev_dbg(&cl->device, \"Start TX on SEND READY qlen %d\\n\",\n\t\t\t\t\t\t\tssi->txqueue_len);\n\t\tspin_unlock_bh(&ssi->lock);\n\t\tschedule_work(&ssi->work);\n\t} else {\n\t\tspin_unlock_bh(&ssi->lock);\n\t}\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\treturn NETDEV_TX_OK;\ndrop2:\n\thsi_free_msg(msg);\ndrop:\n\tdev_kfree_skb(skb);\ninc_dropped:\n\tdev->stats.tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\n \nvoid ssip_reset_event(struct hsi_client *master)\n{\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(master);\n\tdev_err(&ssi->cl->device, \"CMT reset detected!\\n\");\n\tssip_error(ssi->cl);\n}\nEXPORT_SYMBOL_GPL(ssip_reset_event);\n\nstatic const struct net_device_ops ssip_pn_ops = {\n\t.ndo_open\t= ssip_pn_open,\n\t.ndo_stop\t= ssip_pn_stop,\n\t.ndo_start_xmit\t= ssip_pn_xmit,\n};\n\nstatic void ssip_pn_setup(struct net_device *dev)\n{\n\tstatic const u8 addr = PN_MEDIA_SOS;\n\n\tdev->features\t\t= 0;\n\tdev->netdev_ops\t\t= &ssip_pn_ops;\n\tdev->type\t\t= ARPHRD_PHONET;\n\tdev->flags\t\t= IFF_POINTOPOINT | IFF_NOARP;\n\tdev->mtu\t\t= SSIP_DEFAULT_MTU;\n\tdev->hard_header_len\t= 1;\n\tdev->addr_len\t\t= 1;\n\tdev_addr_set(dev, &addr);\n\tdev->tx_queue_len\t= SSIP_TXQUEUE_LEN;\n\n\tdev->needs_free_netdev\t= true;\n\tdev->header_ops\t\t= &phonet_header_ops;\n}\n\nstatic int ssi_protocol_probe(struct device *dev)\n{\n\tstatic const char ifname[] = \"phonet%d\";\n\tstruct hsi_client *cl = to_hsi_client(dev);\n\tstruct ssi_protocol *ssi;\n\tint err;\n\n\tssi = kzalloc(sizeof(*ssi), GFP_KERNEL);\n\tif (!ssi)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ssi->lock);\n\ttimer_setup(&ssi->rx_wd, ssip_rx_wd, TIMER_DEFERRABLE);\n\ttimer_setup(&ssi->tx_wd, ssip_tx_wd, TIMER_DEFERRABLE);\n\ttimer_setup(&ssi->keep_alive, ssip_keep_alive, 0);\n\tINIT_LIST_HEAD(&ssi->txqueue);\n\tINIT_LIST_HEAD(&ssi->cmdqueue);\n\tatomic_set(&ssi->tx_usecnt, 0);\n\thsi_client_set_drvdata(cl, ssi);\n\tssi->cl = cl;\n\tINIT_WORK(&ssi->work, ssip_xmit_work);\n\n\tssi->channel_id_cmd = hsi_get_channel_id_by_name(cl, \"mcsaab-control\");\n\tif (ssi->channel_id_cmd < 0) {\n\t\terr = ssi->channel_id_cmd;\n\t\tdev_err(dev, \"Could not get cmd channel (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\tssi->channel_id_data = hsi_get_channel_id_by_name(cl, \"mcsaab-data\");\n\tif (ssi->channel_id_data < 0) {\n\t\terr = ssi->channel_id_data;\n\t\tdev_err(dev, \"Could not get data channel (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = ssip_alloc_cmds(ssi);\n\tif (err < 0) {\n\t\tdev_err(dev, \"No memory for commands\\n\");\n\t\tgoto out;\n\t}\n\n\tssi->netdev = alloc_netdev(0, ifname, NET_NAME_UNKNOWN, ssip_pn_setup);\n\tif (!ssi->netdev) {\n\t\tdev_err(dev, \"No memory for netdev\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t \n\tssi->netdev->min_mtu = PHONET_MIN_MTU;\n\tssi->netdev->max_mtu = SSIP_MAX_MTU;\n\n\tSET_NETDEV_DEV(ssi->netdev, dev);\n\tnetif_carrier_off(ssi->netdev);\n\terr = register_netdev(ssi->netdev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Register netdev failed (%d)\\n\", err);\n\t\tgoto out2;\n\t}\n\n\tlist_add(&ssi->link, &ssip_list);\n\n\tdev_dbg(dev, \"channel configuration: cmd=%d, data=%d\\n\",\n\t\tssi->channel_id_cmd, ssi->channel_id_data);\n\n\treturn 0;\nout2:\n\tfree_netdev(ssi->netdev);\nout1:\n\tssip_free_cmds(ssi);\nout:\n\tkfree(ssi);\n\n\treturn err;\n}\n\nstatic int ssi_protocol_remove(struct device *dev)\n{\n\tstruct hsi_client *cl = to_hsi_client(dev);\n\tstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\n\n\tlist_del(&ssi->link);\n\tunregister_netdev(ssi->netdev);\n\tssip_free_cmds(ssi);\n\thsi_client_set_drvdata(cl, NULL);\n\tkfree(ssi);\n\n\treturn 0;\n}\n\nstatic struct hsi_client_driver ssip_driver = {\n\t.driver = {\n\t\t.name\t= \"ssi-protocol\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.probe\t= ssi_protocol_probe,\n\t\t.remove\t= ssi_protocol_remove,\n\t},\n};\n\nstatic int __init ssip_init(void)\n{\n\tpr_info(\"SSI protocol aka McSAAB added\\n\");\n\n\treturn hsi_register_client_driver(&ssip_driver);\n}\nmodule_init(ssip_init);\n\nstatic void __exit ssip_exit(void)\n{\n\thsi_unregister_client_driver(&ssip_driver);\n\tpr_info(\"SSI protocol driver removed\\n\");\n}\nmodule_exit(ssip_exit);\n\nMODULE_ALIAS(\"hsi:ssi-protocol\");\nMODULE_AUTHOR(\"Carlos Chinea <carlos.chinea@nokia.com>\");\nMODULE_AUTHOR(\"Remi Denis-Courmont <remi.denis-courmont@nokia.com>\");\nMODULE_DESCRIPTION(\"SSI protocol improved aka McSAAB\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}