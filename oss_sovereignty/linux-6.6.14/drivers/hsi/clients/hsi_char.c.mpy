{
  "module_name": "hsi_char.c",
  "hash_id": "9b111fae4fa8db8186cd81c47e0e47d66cedffe25ba4c46d674b6d65d465016d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hsi/clients/hsi_char.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kmemleak.h>\n#include <linux/ioctl.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/scatterlist.h>\n#include <linux/stat.h>\n#include <linux/hsi/hsi.h>\n#include <linux/hsi/hsi_char.h>\n\n#define HSC_DEVS\t\t16  \n#define HSC_MSGS\t\t4\n\n#define HSC_RXBREAK\t\t0\n\n#define HSC_ID_BITS\t\t6\n#define HSC_PORT_ID_BITS\t4\n#define HSC_ID_MASK\t\t3\n#define HSC_PORT_ID_MASK\t3\n#define HSC_CH_MASK\t\t0xf\n\n \n#define HSC_BASEMINOR(id, port_id) \\\n\t\t((((id) & HSC_ID_MASK) << HSC_ID_BITS) | \\\n\t\t(((port_id) & HSC_PORT_ID_MASK) << HSC_PORT_ID_BITS))\n\nenum {\n\tHSC_CH_OPEN,\n\tHSC_CH_READ,\n\tHSC_CH_WRITE,\n\tHSC_CH_WLINE,\n};\n\nenum {\n\tHSC_RX,\n\tHSC_TX,\n};\n\nstruct hsc_client_data;\n \nstruct hsc_channel {\n\tunsigned int\t\tch;\n\tunsigned long\t\tflags;\n\tstruct list_head\tfree_msgs_list;\n\tstruct list_head\trx_msgs_queue;\n\tstruct list_head\ttx_msgs_queue;\n\tspinlock_t\t\tlock;\n\tstruct hsi_client\t*cl;\n\tstruct hsc_client_data *cl_data;\n\twait_queue_head_t\trx_wait;\n\twait_queue_head_t\ttx_wait;\n};\n\n \nstruct hsc_client_data {\n\tstruct cdev\t\tcdev;\n\tstruct mutex\t\tlock;\n\tunsigned long\t\tflags;\n\tunsigned int\t\tusecnt;\n\tstruct hsi_client\t*cl;\n\tstruct hsc_channel\tchannels[HSC_DEVS];\n};\n\n \nstatic unsigned int hsc_major;\n \nstatic unsigned int max_data_size = 0x1000;\nmodule_param(max_data_size, uint, 0);\nMODULE_PARM_DESC(max_data_size, \"max read/write data size [4,8..65536] (^2)\");\n\nstatic void hsc_add_tail(struct hsc_channel *channel, struct hsi_msg *msg,\n\t\t\t\t\t\t\tstruct list_head *queue)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->lock, flags);\n\tlist_add_tail(&msg->link, queue);\n\tspin_unlock_irqrestore(&channel->lock, flags);\n}\n\nstatic struct hsi_msg *hsc_get_first_msg(struct hsc_channel *channel,\n\t\t\t\t\t\t\tstruct list_head *queue)\n{\n\tstruct hsi_msg *msg = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->lock, flags);\n\n\tif (list_empty(queue))\n\t\tgoto out;\n\n\tmsg = list_first_entry(queue, struct hsi_msg, link);\n\tlist_del(&msg->link);\nout:\n\tspin_unlock_irqrestore(&channel->lock, flags);\n\n\treturn msg;\n}\n\nstatic inline void hsc_msg_free(struct hsi_msg *msg)\n{\n\tkfree(sg_virt(msg->sgt.sgl));\n\thsi_free_msg(msg);\n}\n\nstatic void hsc_free_list(struct list_head *list)\n{\n\tstruct hsi_msg *msg, *tmp;\n\n\tlist_for_each_entry_safe(msg, tmp, list, link) {\n\t\tlist_del(&msg->link);\n\t\thsc_msg_free(msg);\n\t}\n}\n\nstatic void hsc_reset_list(struct hsc_channel *channel, struct list_head *l)\n{\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\n\tspin_lock_irqsave(&channel->lock, flags);\n\tlist_splice_init(l, &list);\n\tspin_unlock_irqrestore(&channel->lock, flags);\n\n\thsc_free_list(&list);\n}\n\nstatic inline struct hsi_msg *hsc_msg_alloc(unsigned int alloc_size)\n{\n\tstruct hsi_msg *msg;\n\tvoid *buf;\n\n\tmsg = hsi_alloc_msg(1, GFP_KERNEL);\n\tif (!msg)\n\t\tgoto out;\n\tbuf = kmalloc(alloc_size, GFP_KERNEL);\n\tif (!buf) {\n\t\thsi_free_msg(msg);\n\t\tgoto out;\n\t}\n\tsg_init_one(msg->sgt.sgl, buf, alloc_size);\n\t \n\tkmemleak_ignore(buf);\n\n\treturn msg;\nout:\n\treturn NULL;\n}\n\nstatic inline int hsc_msgs_alloc(struct hsc_channel *channel)\n{\n\tstruct hsi_msg *msg;\n\tint i;\n\n\tfor (i = 0; i < HSC_MSGS; i++) {\n\t\tmsg = hsc_msg_alloc(max_data_size);\n\t\tif (!msg)\n\t\t\tgoto out;\n\t\tmsg->channel = channel->ch;\n\t\tlist_add_tail(&msg->link, &channel->free_msgs_list);\n\t}\n\n\treturn 0;\nout:\n\thsc_free_list(&channel->free_msgs_list);\n\n\treturn -ENOMEM;\n}\n\nstatic inline unsigned int hsc_msg_len_get(struct hsi_msg *msg)\n{\n\treturn msg->sgt.sgl->length;\n}\n\nstatic inline void hsc_msg_len_set(struct hsi_msg *msg, unsigned int len)\n{\n\tmsg->sgt.sgl->length = len;\n}\n\nstatic void hsc_rx_completed(struct hsi_msg *msg)\n{\n\tstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\n\tstruct hsc_channel *channel = cl_data->channels + msg->channel;\n\n\tif (test_bit(HSC_CH_READ, &channel->flags)) {\n\t\thsc_add_tail(channel, msg, &channel->rx_msgs_queue);\n\t\twake_up(&channel->rx_wait);\n\t} else {\n\t\thsc_add_tail(channel, msg, &channel->free_msgs_list);\n\t}\n}\n\nstatic void hsc_rx_msg_destructor(struct hsi_msg *msg)\n{\n\tmsg->status = HSI_STATUS_ERROR;\n\thsc_msg_len_set(msg, 0);\n\thsc_rx_completed(msg);\n}\n\nstatic void hsc_tx_completed(struct hsi_msg *msg)\n{\n\tstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\n\tstruct hsc_channel *channel = cl_data->channels + msg->channel;\n\n\tif (test_bit(HSC_CH_WRITE, &channel->flags)) {\n\t\thsc_add_tail(channel, msg, &channel->tx_msgs_queue);\n\t\twake_up(&channel->tx_wait);\n\t} else {\n\t\thsc_add_tail(channel, msg, &channel->free_msgs_list);\n\t}\n}\n\nstatic void hsc_tx_msg_destructor(struct hsi_msg *msg)\n{\n\tmsg->status = HSI_STATUS_ERROR;\n\thsc_msg_len_set(msg, 0);\n\thsc_tx_completed(msg);\n}\n\nstatic void hsc_break_req_destructor(struct hsi_msg *msg)\n{\n\tstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\n\n\thsi_free_msg(msg);\n\tclear_bit(HSC_RXBREAK, &cl_data->flags);\n}\n\nstatic void hsc_break_received(struct hsi_msg *msg)\n{\n\tstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\n\tstruct hsc_channel *channel = cl_data->channels;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < HSC_DEVS; i++, channel++) {\n\t\tstruct hsi_msg *msg2;\n\n\t\tif (!test_bit(HSC_CH_READ, &channel->flags))\n\t\t\tcontinue;\n\t\tmsg2 = hsc_get_first_msg(channel, &channel->free_msgs_list);\n\t\tif (!msg2)\n\t\t\tcontinue;\n\t\tclear_bit(HSC_CH_READ, &channel->flags);\n\t\thsc_msg_len_set(msg2, 0);\n\t\tmsg2->status = HSI_STATUS_COMPLETED;\n\t\thsc_add_tail(channel, msg2, &channel->rx_msgs_queue);\n\t\twake_up(&channel->rx_wait);\n\t}\n\thsi_flush(msg->cl);\n\tret = hsi_async_read(msg->cl, msg);\n\tif (ret < 0)\n\t\thsc_break_req_destructor(msg);\n}\n\nstatic int hsc_break_request(struct hsi_client *cl)\n{\n\tstruct hsc_client_data *cl_data = hsi_client_drvdata(cl);\n\tstruct hsi_msg *msg;\n\tint ret;\n\n\tif (test_and_set_bit(HSC_RXBREAK, &cl_data->flags))\n\t\treturn -EBUSY;\n\n\tmsg = hsi_alloc_msg(0, GFP_KERNEL);\n\tif (!msg) {\n\t\tclear_bit(HSC_RXBREAK, &cl_data->flags);\n\t\treturn -ENOMEM;\n\t}\n\tmsg->break_frame = 1;\n\tmsg->complete = hsc_break_received;\n\tmsg->destructor = hsc_break_req_destructor;\n\tret = hsi_async_read(cl, msg);\n\tif (ret < 0)\n\t\thsc_break_req_destructor(msg);\n\n\treturn ret;\n}\n\nstatic int hsc_break_send(struct hsi_client *cl)\n{\n\tstruct hsi_msg *msg;\n\tint ret;\n\n\tmsg = hsi_alloc_msg(0, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tmsg->break_frame = 1;\n\tmsg->complete = hsi_free_msg;\n\tmsg->destructor = hsi_free_msg;\n\tret = hsi_async_write(cl, msg);\n\tif (ret < 0)\n\t\thsi_free_msg(msg);\n\n\treturn ret;\n}\n\nstatic int hsc_rx_set(struct hsi_client *cl, struct hsc_rx_config *rxc)\n{\n\tstruct hsi_config tmp;\n\tint ret;\n\n\tif ((rxc->mode != HSI_MODE_STREAM) && (rxc->mode != HSI_MODE_FRAME))\n\t\treturn -EINVAL;\n\tif ((rxc->channels == 0) || (rxc->channels > HSC_DEVS))\n\t\treturn -EINVAL;\n\tif (rxc->channels & (rxc->channels - 1))\n\t\treturn -EINVAL;\n\tif ((rxc->flow != HSI_FLOW_SYNC) && (rxc->flow != HSI_FLOW_PIPE))\n\t\treturn -EINVAL;\n\ttmp = cl->rx_cfg;\n\tcl->rx_cfg.mode = rxc->mode;\n\tcl->rx_cfg.num_hw_channels = rxc->channels;\n\tcl->rx_cfg.flow = rxc->flow;\n\tret = hsi_setup(cl);\n\tif (ret < 0) {\n\t\tcl->rx_cfg = tmp;\n\t\treturn ret;\n\t}\n\tif (rxc->mode == HSI_MODE_FRAME)\n\t\thsc_break_request(cl);\n\n\treturn ret;\n}\n\nstatic inline void hsc_rx_get(struct hsi_client *cl, struct hsc_rx_config *rxc)\n{\n\trxc->mode = cl->rx_cfg.mode;\n\trxc->channels = cl->rx_cfg.num_hw_channels;\n\trxc->flow = cl->rx_cfg.flow;\n}\n\nstatic int hsc_tx_set(struct hsi_client *cl, struct hsc_tx_config *txc)\n{\n\tstruct hsi_config tmp;\n\tint ret;\n\n\tif ((txc->mode != HSI_MODE_STREAM) && (txc->mode != HSI_MODE_FRAME))\n\t\treturn -EINVAL;\n\tif ((txc->channels == 0) || (txc->channels > HSC_DEVS))\n\t\treturn -EINVAL;\n\tif (txc->channels & (txc->channels - 1))\n\t\treturn -EINVAL;\n\tif ((txc->arb_mode != HSI_ARB_RR) && (txc->arb_mode != HSI_ARB_PRIO))\n\t\treturn -EINVAL;\n\ttmp = cl->tx_cfg;\n\tcl->tx_cfg.mode = txc->mode;\n\tcl->tx_cfg.num_hw_channels = txc->channels;\n\tcl->tx_cfg.speed = txc->speed;\n\tcl->tx_cfg.arb_mode = txc->arb_mode;\n\tret = hsi_setup(cl);\n\tif (ret < 0) {\n\t\tcl->tx_cfg = tmp;\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void hsc_tx_get(struct hsi_client *cl, struct hsc_tx_config *txc)\n{\n\ttxc->mode = cl->tx_cfg.mode;\n\ttxc->channels = cl->tx_cfg.num_hw_channels;\n\ttxc->speed = cl->tx_cfg.speed;\n\ttxc->arb_mode = cl->tx_cfg.arb_mode;\n}\n\nstatic ssize_t hsc_read(struct file *file, char __user *buf, size_t len,\n\t\t\t\t\t\tloff_t *ppos __maybe_unused)\n{\n\tstruct hsc_channel *channel = file->private_data;\n\tstruct hsi_msg *msg;\n\tssize_t ret;\n\n\tif (len == 0)\n\t\treturn 0;\n\tif (!IS_ALIGNED(len, sizeof(u32)))\n\t\treturn -EINVAL;\n\tif (len > max_data_size)\n\t\tlen = max_data_size;\n\tif (channel->ch >= channel->cl->rx_cfg.num_hw_channels)\n\t\treturn -ECHRNG;\n\tif (test_and_set_bit(HSC_CH_READ, &channel->flags))\n\t\treturn -EBUSY;\n\tmsg = hsc_get_first_msg(channel, &channel->free_msgs_list);\n\tif (!msg) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\thsc_msg_len_set(msg, len);\n\tmsg->complete = hsc_rx_completed;\n\tmsg->destructor = hsc_rx_msg_destructor;\n\tret = hsi_async_read(channel->cl, msg);\n\tif (ret < 0) {\n\t\thsc_add_tail(channel, msg, &channel->free_msgs_list);\n\t\tgoto out;\n\t}\n\n\tret = wait_event_interruptible(channel->rx_wait,\n\t\t\t\t\t!list_empty(&channel->rx_msgs_queue));\n\tif (ret < 0) {\n\t\tclear_bit(HSC_CH_READ, &channel->flags);\n\t\thsi_flush(channel->cl);\n\t\treturn -EINTR;\n\t}\n\n\tmsg = hsc_get_first_msg(channel, &channel->rx_msgs_queue);\n\tif (msg) {\n\t\tif (msg->status != HSI_STATUS_ERROR) {\n\t\t\tret = copy_to_user((void __user *)buf,\n\t\t\tsg_virt(msg->sgt.sgl), hsc_msg_len_get(msg));\n\t\t\tif (ret)\n\t\t\t\tret = -EFAULT;\n\t\t\telse\n\t\t\t\tret = hsc_msg_len_get(msg);\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t}\n\t\thsc_add_tail(channel, msg, &channel->free_msgs_list);\n\t}\nout:\n\tclear_bit(HSC_CH_READ, &channel->flags);\n\n\treturn ret;\n}\n\nstatic ssize_t hsc_write(struct file *file, const char __user *buf, size_t len,\n\t\t\t\t\t\tloff_t *ppos __maybe_unused)\n{\n\tstruct hsc_channel *channel = file->private_data;\n\tstruct hsi_msg *msg;\n\tssize_t ret;\n\n\tif ((len == 0) || !IS_ALIGNED(len, sizeof(u32)))\n\t\treturn -EINVAL;\n\tif (len > max_data_size)\n\t\tlen = max_data_size;\n\tif (channel->ch >= channel->cl->tx_cfg.num_hw_channels)\n\t\treturn -ECHRNG;\n\tif (test_and_set_bit(HSC_CH_WRITE, &channel->flags))\n\t\treturn -EBUSY;\n\tmsg = hsc_get_first_msg(channel, &channel->free_msgs_list);\n\tif (!msg) {\n\t\tclear_bit(HSC_CH_WRITE, &channel->flags);\n\t\treturn -ENOSPC;\n\t}\n\tif (copy_from_user(sg_virt(msg->sgt.sgl), (void __user *)buf, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\thsc_msg_len_set(msg, len);\n\tmsg->complete = hsc_tx_completed;\n\tmsg->destructor = hsc_tx_msg_destructor;\n\tret = hsi_async_write(channel->cl, msg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wait_event_interruptible(channel->tx_wait,\n\t\t\t\t\t!list_empty(&channel->tx_msgs_queue));\n\tif (ret < 0) {\n\t\tclear_bit(HSC_CH_WRITE, &channel->flags);\n\t\thsi_flush(channel->cl);\n\t\treturn -EINTR;\n\t}\n\n\tmsg = hsc_get_first_msg(channel, &channel->tx_msgs_queue);\n\tif (msg) {\n\t\tif (msg->status == HSI_STATUS_ERROR)\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = hsc_msg_len_get(msg);\n\n\t\thsc_add_tail(channel, msg, &channel->free_msgs_list);\n\t}\nout:\n\tclear_bit(HSC_CH_WRITE, &channel->flags);\n\n\treturn ret;\n}\n\nstatic long hsc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hsc_channel *channel = file->private_data;\n\tunsigned int state;\n\tstruct hsc_rx_config rxc;\n\tstruct hsc_tx_config txc;\n\tlong ret = 0;\n\n\tswitch (cmd) {\n\tcase HSC_RESET:\n\t\thsi_flush(channel->cl);\n\t\tbreak;\n\tcase HSC_SET_PM:\n\t\tif (copy_from_user(&state, (void __user *)arg, sizeof(state)))\n\t\t\treturn -EFAULT;\n\t\tif (state == HSC_PM_DISABLE) {\n\t\t\tif (test_and_set_bit(HSC_CH_WLINE, &channel->flags))\n\t\t\t\treturn -EINVAL;\n\t\t\tret = hsi_start_tx(channel->cl);\n\t\t} else if (state == HSC_PM_ENABLE) {\n\t\t\tif (!test_and_clear_bit(HSC_CH_WLINE, &channel->flags))\n\t\t\t\treturn -EINVAL;\n\t\t\tret = hsi_stop_tx(channel->cl);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase HSC_SEND_BREAK:\n\t\treturn hsc_break_send(channel->cl);\n\tcase HSC_SET_RX:\n\t\tif (copy_from_user(&rxc, (void __user *)arg, sizeof(rxc)))\n\t\t\treturn -EFAULT;\n\t\treturn hsc_rx_set(channel->cl, &rxc);\n\tcase HSC_GET_RX:\n\t\thsc_rx_get(channel->cl, &rxc);\n\t\tif (copy_to_user((void __user *)arg, &rxc, sizeof(rxc)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase HSC_SET_TX:\n\t\tif (copy_from_user(&txc, (void __user *)arg, sizeof(txc)))\n\t\t\treturn -EFAULT;\n\t\treturn hsc_tx_set(channel->cl, &txc);\n\tcase HSC_GET_TX:\n\t\thsc_tx_get(channel->cl, &txc);\n\t\tif (copy_to_user((void __user *)arg, &txc, sizeof(txc)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void __hsc_port_release(struct hsc_client_data *cl_data)\n{\n\tBUG_ON(cl_data->usecnt == 0);\n\n\tif (--cl_data->usecnt == 0) {\n\t\thsi_flush(cl_data->cl);\n\t\thsi_release_port(cl_data->cl);\n\t}\n}\n\nstatic int hsc_open(struct inode *inode, struct file *file)\n{\n\tstruct hsc_client_data *cl_data;\n\tstruct hsc_channel *channel;\n\tint ret = 0;\n\n\tpr_debug(\"open, minor = %d\\n\", iminor(inode));\n\n\tcl_data = container_of(inode->i_cdev, struct hsc_client_data, cdev);\n\tmutex_lock(&cl_data->lock);\n\tchannel = cl_data->channels + (iminor(inode) & HSC_CH_MASK);\n\n\tif (test_and_set_bit(HSC_CH_OPEN, &channel->flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\t \n\tif (cl_data->usecnt == 0) {\n\t\tret = hsi_claim_port(cl_data->cl, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\thsi_setup(cl_data->cl);\n\t}\n\tcl_data->usecnt++;\n\n\tret = hsc_msgs_alloc(channel);\n\tif (ret < 0) {\n\t\t__hsc_port_release(cl_data);\n\t\tgoto out;\n\t}\n\n\tfile->private_data = channel;\n\tmutex_unlock(&cl_data->lock);\n\n\treturn ret;\nout:\n\tmutex_unlock(&cl_data->lock);\n\n\treturn ret;\n}\n\nstatic int hsc_release(struct inode *inode __maybe_unused, struct file *file)\n{\n\tstruct hsc_channel *channel = file->private_data;\n\tstruct hsc_client_data *cl_data = channel->cl_data;\n\n\tmutex_lock(&cl_data->lock);\n\tfile->private_data = NULL;\n\tif (test_and_clear_bit(HSC_CH_WLINE, &channel->flags))\n\t\thsi_stop_tx(channel->cl);\n\t__hsc_port_release(cl_data);\n\thsc_reset_list(channel, &channel->rx_msgs_queue);\n\thsc_reset_list(channel, &channel->tx_msgs_queue);\n\thsc_reset_list(channel, &channel->free_msgs_list);\n\tclear_bit(HSC_CH_READ, &channel->flags);\n\tclear_bit(HSC_CH_WRITE, &channel->flags);\n\tclear_bit(HSC_CH_OPEN, &channel->flags);\n\twake_up(&channel->rx_wait);\n\twake_up(&channel->tx_wait);\n\tmutex_unlock(&cl_data->lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations hsc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= hsc_read,\n\t.write\t\t= hsc_write,\n\t.unlocked_ioctl\t= hsc_ioctl,\n\t.open\t\t= hsc_open,\n\t.release\t= hsc_release,\n};\n\nstatic void hsc_channel_init(struct hsc_channel *channel)\n{\n\tinit_waitqueue_head(&channel->rx_wait);\n\tinit_waitqueue_head(&channel->tx_wait);\n\tspin_lock_init(&channel->lock);\n\tINIT_LIST_HEAD(&channel->free_msgs_list);\n\tINIT_LIST_HEAD(&channel->rx_msgs_queue);\n\tINIT_LIST_HEAD(&channel->tx_msgs_queue);\n}\n\nstatic int hsc_probe(struct device *dev)\n{\n\tconst char devname[] = \"hsi_char\";\n\tstruct hsc_client_data *cl_data;\n\tstruct hsc_channel *channel;\n\tstruct hsi_client *cl = to_hsi_client(dev);\n\tunsigned int hsc_baseminor;\n\tdev_t hsc_dev;\n\tint ret;\n\tint i;\n\n\tcl_data = kzalloc(sizeof(*cl_data), GFP_KERNEL);\n\tif (!cl_data)\n\t\treturn -ENOMEM;\n\n\thsc_baseminor = HSC_BASEMINOR(hsi_id(cl), hsi_port_id(cl));\n\tif (!hsc_major) {\n\t\tret = alloc_chrdev_region(&hsc_dev, hsc_baseminor,\n\t\t\t\t\t\tHSC_DEVS, devname);\n\t\tif (ret == 0)\n\t\t\thsc_major = MAJOR(hsc_dev);\n\t} else {\n\t\thsc_dev = MKDEV(hsc_major, hsc_baseminor);\n\t\tret = register_chrdev_region(hsc_dev, HSC_DEVS, devname);\n\t}\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Device %s allocation failed %d\\n\",\n\t\t\t\t\thsc_major ? \"minor\" : \"major\", ret);\n\t\tgoto out1;\n\t}\n\tmutex_init(&cl_data->lock);\n\thsi_client_set_drvdata(cl, cl_data);\n\tcdev_init(&cl_data->cdev, &hsc_fops);\n\tcl_data->cdev.owner = THIS_MODULE;\n\tcl_data->cl = cl;\n\tfor (i = 0, channel = cl_data->channels; i < HSC_DEVS; i++, channel++) {\n\t\thsc_channel_init(channel);\n\t\tchannel->ch = i;\n\t\tchannel->cl = cl;\n\t\tchannel->cl_data = cl_data;\n\t}\n\n\t \n\tret = cdev_add(&cl_data->cdev, hsc_dev, HSC_DEVS);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not add char device %d\\n\", ret);\n\t\tgoto out2;\n\t}\n\n\treturn 0;\nout2:\n\tunregister_chrdev_region(hsc_dev, HSC_DEVS);\nout1:\n\tkfree(cl_data);\n\n\treturn ret;\n}\n\nstatic int hsc_remove(struct device *dev)\n{\n\tstruct hsi_client *cl = to_hsi_client(dev);\n\tstruct hsc_client_data *cl_data = hsi_client_drvdata(cl);\n\tdev_t hsc_dev = cl_data->cdev.dev;\n\n\tcdev_del(&cl_data->cdev);\n\tunregister_chrdev_region(hsc_dev, HSC_DEVS);\n\thsi_client_set_drvdata(cl, NULL);\n\tkfree(cl_data);\n\n\treturn 0;\n}\n\nstatic struct hsi_client_driver hsc_driver = {\n\t.driver = {\n\t\t.name\t= \"hsi_char\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.probe\t= hsc_probe,\n\t\t.remove\t= hsc_remove,\n\t},\n};\n\nstatic int __init hsc_init(void)\n{\n\tint ret;\n\n\tif ((max_data_size < 4) || (max_data_size > 0x10000) ||\n\t\t(max_data_size & (max_data_size - 1))) {\n\t\tpr_err(\"Invalid max read/write data size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = hsi_register_client_driver(&hsc_driver);\n\tif (ret) {\n\t\tpr_err(\"Error while registering HSI/SSI driver %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpr_info(\"HSI/SSI char device loaded\\n\");\n\n\treturn 0;\n}\nmodule_init(hsc_init);\n\nstatic void __exit hsc_exit(void)\n{\n\thsi_unregister_client_driver(&hsc_driver);\n\tpr_info(\"HSI char device removed\\n\");\n}\nmodule_exit(hsc_exit);\n\nMODULE_AUTHOR(\"Andras Domokos <andras.domokos@nokia.com>\");\nMODULE_ALIAS(\"hsi:hsi_char\");\nMODULE_DESCRIPTION(\"HSI character device\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}