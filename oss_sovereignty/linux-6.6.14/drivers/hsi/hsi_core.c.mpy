{
  "module_name": "hsi_core.c",
  "hash_id": "f20ab4eadeb04b87bc4d22734c123b75881a7db7803ad2da8b014b6ce6dc3043",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hsi/hsi_core.c",
  "human_readable_source": "\n \n#include <linux/hsi/hsi.h>\n#include <linux/compiler.h>\n#include <linux/list.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include \"hsi_core.h\"\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\tstruct device_attribute *a __maybe_unused, char *buf)\n{\n\treturn sprintf(buf, \"hsi:%s\\n\", dev_name(dev));\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *hsi_bus_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(hsi_bus_dev);\n\nstatic int hsi_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tadd_uevent_var(env, \"MODALIAS=hsi:%s\", dev_name(dev));\n\n\treturn 0;\n}\n\nstatic int hsi_bus_match(struct device *dev, struct device_driver *driver)\n{\n\tif (of_driver_match_device(dev, driver))\n\t\treturn true;\n\n\tif (strcmp(dev_name(dev), driver->name) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct bus_type hsi_bus_type = {\n\t.name\t\t= \"hsi\",\n\t.dev_groups\t= hsi_bus_dev_groups,\n\t.match\t\t= hsi_bus_match,\n\t.uevent\t\t= hsi_bus_uevent,\n};\n\nstatic void hsi_client_release(struct device *dev)\n{\n\tstruct hsi_client *cl = to_hsi_client(dev);\n\n\tkfree(cl->tx_cfg.channels);\n\tkfree(cl->rx_cfg.channels);\n\tkfree(cl);\n}\n\nstruct hsi_client *hsi_new_client(struct hsi_port *port,\n\t\t\t\t\t\tstruct hsi_board_info *info)\n{\n\tstruct hsi_client *cl;\n\tsize_t size;\n\n\tcl = kzalloc(sizeof(*cl), GFP_KERNEL);\n\tif (!cl)\n\t\tgoto err;\n\n\tcl->tx_cfg = info->tx_cfg;\n\tif (cl->tx_cfg.channels) {\n\t\tsize = cl->tx_cfg.num_channels * sizeof(*cl->tx_cfg.channels);\n\t\tcl->tx_cfg.channels = kmemdup(info->tx_cfg.channels, size,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!cl->tx_cfg.channels)\n\t\t\tgoto err_tx;\n\t}\n\n\tcl->rx_cfg = info->rx_cfg;\n\tif (cl->rx_cfg.channels) {\n\t\tsize = cl->rx_cfg.num_channels * sizeof(*cl->rx_cfg.channels);\n\t\tcl->rx_cfg.channels = kmemdup(info->rx_cfg.channels, size,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!cl->rx_cfg.channels)\n\t\t\tgoto err_rx;\n\t}\n\n\tcl->device.bus = &hsi_bus_type;\n\tcl->device.parent = &port->device;\n\tcl->device.release = hsi_client_release;\n\tdev_set_name(&cl->device, \"%s\", info->name);\n\tcl->device.platform_data = info->platform_data;\n\tif (info->archdata)\n\t\tcl->device.archdata = *info->archdata;\n\tif (device_register(&cl->device) < 0) {\n\t\tpr_err(\"hsi: failed to register client: %s\\n\", info->name);\n\t\tput_device(&cl->device);\n\t\tgoto err;\n\t}\n\n\treturn cl;\nerr_rx:\n\tkfree(cl->tx_cfg.channels);\nerr_tx:\n\tkfree(cl);\nerr:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(hsi_new_client);\n\nstatic void hsi_scan_board_info(struct hsi_controller *hsi)\n{\n\tstruct hsi_cl_info *cl_info;\n\tstruct hsi_port\t*p;\n\n\tlist_for_each_entry(cl_info, &hsi_board_list, list)\n\t\tif (cl_info->info.hsi_id == hsi->id) {\n\t\t\tp = hsi_find_port_num(hsi, cl_info->info.port);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\thsi_new_client(p, &cl_info->info);\n\t\t}\n}\n\n#ifdef CONFIG_OF\nstatic struct hsi_board_info hsi_char_dev_info = {\n\t.name = \"hsi_char\",\n};\n\nstatic int hsi_of_property_parse_mode(struct device_node *client, char *name,\n\t\t\t\t      unsigned int *result)\n{\n\tconst char *mode;\n\tint err;\n\n\terr = of_property_read_string(client, name, &mode);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (strcmp(mode, \"stream\") == 0)\n\t\t*result = HSI_MODE_STREAM;\n\telse if (strcmp(mode, \"frame\") == 0)\n\t\t*result = HSI_MODE_FRAME;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hsi_of_property_parse_flow(struct device_node *client, char *name,\n\t\t\t\t      unsigned int *result)\n{\n\tconst char *flow;\n\tint err;\n\n\terr = of_property_read_string(client, name, &flow);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (strcmp(flow, \"synchronized\") == 0)\n\t\t*result = HSI_FLOW_SYNC;\n\telse if (strcmp(flow, \"pipeline\") == 0)\n\t\t*result = HSI_FLOW_PIPE;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hsi_of_property_parse_arb_mode(struct device_node *client,\n\t\t\t\t\t  char *name, unsigned int *result)\n{\n\tconst char *arb_mode;\n\tint err;\n\n\terr = of_property_read_string(client, name, &arb_mode);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (strcmp(arb_mode, \"round-robin\") == 0)\n\t\t*result = HSI_ARB_RR;\n\telse if (strcmp(arb_mode, \"priority\") == 0)\n\t\t*result = HSI_ARB_PRIO;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void hsi_add_client_from_dt(struct hsi_port *port,\n\t\t\t\t\t\tstruct device_node *client)\n{\n\tstruct hsi_client *cl;\n\tstruct hsi_channel channel;\n\tstruct property *prop;\n\tchar name[32];\n\tint length, cells, err, i, max_chan, mode;\n\n\tcl = kzalloc(sizeof(*cl), GFP_KERNEL);\n\tif (!cl)\n\t\treturn;\n\n\terr = of_alias_from_compatible(client, name, sizeof(name));\n\tif (err)\n\t\tgoto err;\n\n\terr = hsi_of_property_parse_mode(client, \"hsi-mode\", &mode);\n\tif (err) {\n\t\terr = hsi_of_property_parse_mode(client, \"hsi-rx-mode\",\n\t\t\t\t\t\t &cl->rx_cfg.mode);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = hsi_of_property_parse_mode(client, \"hsi-tx-mode\",\n\t\t\t\t\t\t &cl->tx_cfg.mode);\n\t\tif (err)\n\t\t\tgoto err;\n\t} else {\n\t\tcl->rx_cfg.mode = mode;\n\t\tcl->tx_cfg.mode = mode;\n\t}\n\n\terr = of_property_read_u32(client, \"hsi-speed-kbps\",\n\t\t\t\t   &cl->tx_cfg.speed);\n\tif (err)\n\t\tgoto err;\n\tcl->rx_cfg.speed = cl->tx_cfg.speed;\n\n\terr = hsi_of_property_parse_flow(client, \"hsi-flow\",\n\t\t\t\t\t &cl->rx_cfg.flow);\n\tif (err)\n\t\tgoto err;\n\n\terr = hsi_of_property_parse_arb_mode(client, \"hsi-arb-mode\",\n\t\t\t\t\t     &cl->rx_cfg.arb_mode);\n\tif (err)\n\t\tgoto err;\n\n\tprop = of_find_property(client, \"hsi-channel-ids\", &length);\n\tif (!prop) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tcells = length / sizeof(u32);\n\n\tcl->rx_cfg.num_channels = cells;\n\tcl->tx_cfg.num_channels = cells;\n\tcl->rx_cfg.channels = kcalloc(cells, sizeof(channel), GFP_KERNEL);\n\tif (!cl->rx_cfg.channels) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcl->tx_cfg.channels = kcalloc(cells, sizeof(channel), GFP_KERNEL);\n\tif (!cl->tx_cfg.channels) {\n\t\terr = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tmax_chan = 0;\n\tfor (i = 0; i < cells; i++) {\n\t\terr = of_property_read_u32_index(client, \"hsi-channel-ids\", i,\n\t\t\t\t\t\t &channel.id);\n\t\tif (err)\n\t\t\tgoto err3;\n\n\t\terr = of_property_read_string_index(client, \"hsi-channel-names\",\n\t\t\t\t\t\t    i, &channel.name);\n\t\tif (err)\n\t\t\tchannel.name = NULL;\n\n\t\tif (channel.id > max_chan)\n\t\t\tmax_chan = channel.id;\n\n\t\tcl->rx_cfg.channels[i] = channel;\n\t\tcl->tx_cfg.channels[i] = channel;\n\t}\n\n\tcl->rx_cfg.num_hw_channels = max_chan + 1;\n\tcl->tx_cfg.num_hw_channels = max_chan + 1;\n\n\tcl->device.bus = &hsi_bus_type;\n\tcl->device.parent = &port->device;\n\tcl->device.release = hsi_client_release;\n\tcl->device.of_node = client;\n\n\tdev_set_name(&cl->device, \"%s\", name);\n\tif (device_register(&cl->device) < 0) {\n\t\tpr_err(\"hsi: failed to register client: %s\\n\", name);\n\t\tput_device(&cl->device);\n\t}\n\n\treturn;\n\nerr3:\n\tkfree(cl->tx_cfg.channels);\nerr2:\n\tkfree(cl->rx_cfg.channels);\nerr:\n\tkfree(cl);\n\tpr_err(\"hsi client: missing or incorrect of property: err=%d\\n\", err);\n}\n\nvoid hsi_add_clients_from_dt(struct hsi_port *port, struct device_node *clients)\n{\n\tstruct device_node *child;\n\n\t \n\thsi_new_client(port, &hsi_char_dev_info);\n\n\tfor_each_available_child_of_node(clients, child)\n\t\thsi_add_client_from_dt(port, child);\n}\nEXPORT_SYMBOL_GPL(hsi_add_clients_from_dt);\n#endif\n\nint hsi_remove_client(struct device *dev, void *data __maybe_unused)\n{\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hsi_remove_client);\n\nstatic int hsi_remove_port(struct device *dev, void *data __maybe_unused)\n{\n\tdevice_for_each_child(dev, NULL, hsi_remove_client);\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\nstatic void hsi_controller_release(struct device *dev)\n{\n\tstruct hsi_controller *hsi = to_hsi_controller(dev);\n\n\tkfree(hsi->port);\n\tkfree(hsi);\n}\n\nstatic void hsi_port_release(struct device *dev)\n{\n\tkfree(to_hsi_port(dev));\n}\n\n \nvoid hsi_port_unregister_clients(struct hsi_port *port)\n{\n\tdevice_for_each_child(&port->device, NULL, hsi_remove_client);\n}\nEXPORT_SYMBOL_GPL(hsi_port_unregister_clients);\n\n \nvoid hsi_unregister_controller(struct hsi_controller *hsi)\n{\n\tdevice_for_each_child(&hsi->device, NULL, hsi_remove_port);\n\tdevice_unregister(&hsi->device);\n}\nEXPORT_SYMBOL_GPL(hsi_unregister_controller);\n\n \nint hsi_register_controller(struct hsi_controller *hsi)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = device_add(&hsi->device);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < hsi->num_ports; i++) {\n\t\thsi->port[i]->device.parent = &hsi->device;\n\t\terr = device_add(&hsi->port[i]->device);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\t \n\thsi_scan_board_info(hsi);\n\n\treturn 0;\nout:\n\twhile (i-- > 0)\n\t\tdevice_del(&hsi->port[i]->device);\n\tdevice_del(&hsi->device);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(hsi_register_controller);\n\n \nint hsi_register_client_driver(struct hsi_client_driver *drv)\n{\n\tdrv->driver.bus = &hsi_bus_type;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(hsi_register_client_driver);\n\nstatic inline int hsi_dummy_msg(struct hsi_msg *msg __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline int hsi_dummy_cl(struct hsi_client *cl __maybe_unused)\n{\n\treturn 0;\n}\n\n \nvoid hsi_put_controller(struct hsi_controller *hsi)\n{\n\tunsigned int i;\n\n\tif (!hsi)\n\t\treturn;\n\n\tfor (i = 0; i < hsi->num_ports; i++)\n\t\tif (hsi->port && hsi->port[i])\n\t\t\tput_device(&hsi->port[i]->device);\n\tput_device(&hsi->device);\n}\nEXPORT_SYMBOL_GPL(hsi_put_controller);\n\n \nstruct hsi_controller *hsi_alloc_controller(unsigned int n_ports, gfp_t flags)\n{\n\tstruct hsi_controller\t*hsi;\n\tstruct hsi_port\t\t**port;\n\tunsigned int\t\ti;\n\n\tif (!n_ports)\n\t\treturn NULL;\n\n\thsi = kzalloc(sizeof(*hsi), flags);\n\tif (!hsi)\n\t\treturn NULL;\n\tport = kcalloc(n_ports, sizeof(*port), flags);\n\tif (!port) {\n\t\tkfree(hsi);\n\t\treturn NULL;\n\t}\n\thsi->num_ports = n_ports;\n\thsi->port = port;\n\thsi->device.release = hsi_controller_release;\n\tdevice_initialize(&hsi->device);\n\n\tfor (i = 0; i < n_ports; i++) {\n\t\tport[i] = kzalloc(sizeof(**port), flags);\n\t\tif (port[i] == NULL)\n\t\t\tgoto out;\n\t\tport[i]->num = i;\n\t\tport[i]->async = hsi_dummy_msg;\n\t\tport[i]->setup = hsi_dummy_cl;\n\t\tport[i]->flush = hsi_dummy_cl;\n\t\tport[i]->start_tx = hsi_dummy_cl;\n\t\tport[i]->stop_tx = hsi_dummy_cl;\n\t\tport[i]->release = hsi_dummy_cl;\n\t\tmutex_init(&port[i]->lock);\n\t\tBLOCKING_INIT_NOTIFIER_HEAD(&port[i]->n_head);\n\t\tdev_set_name(&port[i]->device, \"port%d\", i);\n\t\thsi->port[i]->device.release = hsi_port_release;\n\t\tdevice_initialize(&hsi->port[i]->device);\n\t}\n\n\treturn hsi;\nout:\n\thsi_put_controller(hsi);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(hsi_alloc_controller);\n\n \nvoid hsi_free_msg(struct hsi_msg *msg)\n{\n\tif (!msg)\n\t\treturn;\n\tsg_free_table(&msg->sgt);\n\tkfree(msg);\n}\nEXPORT_SYMBOL_GPL(hsi_free_msg);\n\n \nstruct hsi_msg *hsi_alloc_msg(unsigned int nents, gfp_t flags)\n{\n\tstruct hsi_msg *msg;\n\tint err;\n\n\tmsg = kzalloc(sizeof(*msg), flags);\n\tif (!msg)\n\t\treturn NULL;\n\n\tif (!nents)\n\t\treturn msg;\n\n\terr = sg_alloc_table(&msg->sgt, nents, flags);\n\tif (unlikely(err)) {\n\t\tkfree(msg);\n\t\tmsg = NULL;\n\t}\n\n\treturn msg;\n}\nEXPORT_SYMBOL_GPL(hsi_alloc_msg);\n\n \nint hsi_async(struct hsi_client *cl, struct hsi_msg *msg)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\n\tif (!hsi_port_claimed(cl))\n\t\treturn -EACCES;\n\n\tWARN_ON_ONCE(!msg->destructor || !msg->complete);\n\tmsg->cl = cl;\n\n\treturn port->async(msg);\n}\nEXPORT_SYMBOL_GPL(hsi_async);\n\n \nint hsi_claim_port(struct hsi_client *cl, unsigned int share)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tint err = 0;\n\n\tmutex_lock(&port->lock);\n\tif ((port->claimed) && (!port->shared || !share)) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!try_module_get(to_hsi_controller(port->device.parent)->owner)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tport->claimed++;\n\tport->shared = !!share;\n\tcl->pclaimed = 1;\nout:\n\tmutex_unlock(&port->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(hsi_claim_port);\n\n \nvoid hsi_release_port(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\n\tmutex_lock(&port->lock);\n\t \n\tport->release(cl);\n\tif (cl->pclaimed)\n\t\tport->claimed--;\n\tBUG_ON(port->claimed < 0);\n\tcl->pclaimed = 0;\n\tif (!port->claimed)\n\t\tport->shared = 0;\n\tmodule_put(to_hsi_controller(port->device.parent)->owner);\n\tmutex_unlock(&port->lock);\n}\nEXPORT_SYMBOL_GPL(hsi_release_port);\n\nstatic int hsi_event_notifier_call(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *data __maybe_unused)\n{\n\tstruct hsi_client *cl = container_of(nb, struct hsi_client, nb);\n\n\t(*cl->ehandler)(cl, event);\n\n\treturn 0;\n}\n\n \nint hsi_register_port_event(struct hsi_client *cl,\n\t\t\tvoid (*handler)(struct hsi_client *, unsigned long))\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\n\tif (!handler || cl->ehandler)\n\t\treturn -EINVAL;\n\tif (!hsi_port_claimed(cl))\n\t\treturn -EACCES;\n\tcl->ehandler = handler;\n\tcl->nb.notifier_call = hsi_event_notifier_call;\n\n\treturn blocking_notifier_chain_register(&port->n_head, &cl->nb);\n}\nEXPORT_SYMBOL_GPL(hsi_register_port_event);\n\n \nint hsi_unregister_port_event(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tint err;\n\n\tWARN_ON(!hsi_port_claimed(cl));\n\n\terr = blocking_notifier_chain_unregister(&port->n_head, &cl->nb);\n\tif (!err)\n\t\tcl->ehandler = NULL;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(hsi_unregister_port_event);\n\n \nint hsi_event(struct hsi_port *port, unsigned long event)\n{\n\treturn blocking_notifier_call_chain(&port->n_head, event, NULL);\n}\nEXPORT_SYMBOL_GPL(hsi_event);\n\n \nint hsi_get_channel_id_by_name(struct hsi_client *cl, char *name)\n{\n\tint i;\n\n\tif (!cl->rx_cfg.channels)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < cl->rx_cfg.num_channels; i++)\n\t\tif (!strcmp(cl->rx_cfg.channels[i].name, name))\n\t\t\treturn cl->rx_cfg.channels[i].id;\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(hsi_get_channel_id_by_name);\n\nstatic int __init hsi_init(void)\n{\n\treturn bus_register(&hsi_bus_type);\n}\npostcore_initcall(hsi_init);\n\nstatic void __exit hsi_exit(void)\n{\n\tbus_unregister(&hsi_bus_type);\n}\nmodule_exit(hsi_exit);\n\nMODULE_AUTHOR(\"Carlos Chinea <carlos.chinea@nokia.com>\");\nMODULE_DESCRIPTION(\"High-speed Synchronous Serial Interface (HSI) framework\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}