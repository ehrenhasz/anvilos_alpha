{
  "module_name": "omap_ssi_core.c",
  "hash_id": "85dcfca1db08243886a57993a395dfa2e66a804dbe5bc90a02070d6ca0124124",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hsi/controllers/omap_ssi_core.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/err.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/delay.h>\n#include <linux/hsi/ssi_protocol.h>\n#include <linux/seq_file.h>\n#include <linux/scatterlist.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/debugfs.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/hsi/hsi.h>\n#include <linux/idr.h>\n\n#include \"omap_ssi_regs.h\"\n#include \"omap_ssi.h\"\n\n \nstatic DEFINE_IDA(platform_omap_ssi_ida);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int ssi_regs_show(struct seq_file *m, void *p __maybe_unused)\n{\n\tstruct hsi_controller *ssi = m->private;\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem *sys = omap_ssi->sys;\n\n\tpm_runtime_get_sync(ssi->device.parent);\n\tseq_printf(m, \"REVISION\\t: 0x%08x\\n\",  readl(sys + SSI_REVISION_REG));\n\tseq_printf(m, \"SYSCONFIG\\t: 0x%08x\\n\", readl(sys + SSI_SYSCONFIG_REG));\n\tseq_printf(m, \"SYSSTATUS\\t: 0x%08x\\n\", readl(sys + SSI_SYSSTATUS_REG));\n\tpm_runtime_put(ssi->device.parent);\n\n\treturn 0;\n}\n\nstatic int ssi_gdd_regs_show(struct seq_file *m, void *p __maybe_unused)\n{\n\tstruct hsi_controller *ssi = m->private;\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem *gdd = omap_ssi->gdd;\n\tvoid __iomem *sys = omap_ssi->sys;\n\tint lch;\n\n\tpm_runtime_get_sync(ssi->device.parent);\n\n\tseq_printf(m, \"GDD_MPU_STATUS\\t: 0x%08x\\n\",\n\t\treadl(sys + SSI_GDD_MPU_IRQ_STATUS_REG));\n\tseq_printf(m, \"GDD_MPU_ENABLE\\t: 0x%08x\\n\\n\",\n\t\treadl(sys + SSI_GDD_MPU_IRQ_ENABLE_REG));\n\tseq_printf(m, \"HW_ID\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_HW_ID_REG));\n\tseq_printf(m, \"PPORT_ID\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_PPORT_ID_REG));\n\tseq_printf(m, \"MPORT_ID\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_MPORT_ID_REG));\n\tseq_printf(m, \"TEST\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_TEST_REG));\n\tseq_printf(m, \"GCR\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_GCR_REG));\n\n\tfor (lch = 0; lch < SSI_MAX_GDD_LCH; lch++) {\n\t\tseq_printf(m, \"\\nGDD LCH %d\\n=========\\n\", lch);\n\t\tseq_printf(m, \"CSDP\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CSDP_REG(lch)));\n\t\tseq_printf(m, \"CCR\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CCR_REG(lch)));\n\t\tseq_printf(m, \"CICR\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CICR_REG(lch)));\n\t\tseq_printf(m, \"CSR\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CSR_REG(lch)));\n\t\tseq_printf(m, \"CSSA\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_CSSA_REG(lch)));\n\t\tseq_printf(m, \"CDSA\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(gdd + SSI_GDD_CDSA_REG(lch)));\n\t\tseq_printf(m, \"CEN\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CEN_REG(lch)));\n\t\tseq_printf(m, \"CSAC\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CSAC_REG(lch)));\n\t\tseq_printf(m, \"CDAC\\t\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CDAC_REG(lch)));\n\t\tseq_printf(m, \"CLNK_CTRL\\t: 0x%04x\\n\",\n\t\t\t\treadw(gdd + SSI_GDD_CLNK_CTRL_REG(lch)));\n\t}\n\n\tpm_runtime_put(ssi->device.parent);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(ssi_regs);\nDEFINE_SHOW_ATTRIBUTE(ssi_gdd_regs);\n\nstatic int ssi_debug_add_ctrl(struct hsi_controller *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct dentry *dir;\n\n\t \n\tomap_ssi->dir = debugfs_create_dir(dev_name(&ssi->device), NULL);\n\tif (!omap_ssi->dir)\n\t\treturn -ENOMEM;\n\n\tdebugfs_create_file(\"regs\", S_IRUGO, omap_ssi->dir, ssi,\n\t\t\t\t\t\t\t\t&ssi_regs_fops);\n\t \n\tdir = debugfs_create_dir(\"gdd\", omap_ssi->dir);\n\tif (!dir)\n\t\tgoto rback;\n\tdebugfs_create_file(\"regs\", S_IRUGO, dir, ssi, &ssi_gdd_regs_fops);\n\n\treturn 0;\nrback:\n\tdebugfs_remove_recursive(omap_ssi->dir);\n\n\treturn -ENOMEM;\n}\n\nstatic void ssi_debug_remove_ctrl(struct hsi_controller *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tdebugfs_remove_recursive(omap_ssi->dir);\n}\n#endif  \n\n \nvoid ssi_waketest(struct hsi_client *cl, unsigned int enable)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tomap_port->wktest = !!enable;\n\tif (omap_port->wktest) {\n\t\tpm_runtime_get_sync(ssi->device.parent);\n\t\twritel_relaxed(SSI_WAKE(0),\n\t\t\t\tomap_ssi->sys + SSI_SET_WAKE_REG(port->num));\n\t} else {\n\t\twritel_relaxed(SSI_WAKE(0),\n\t\t\t\tomap_ssi->sys +\tSSI_CLEAR_WAKE_REG(port->num));\n\t\tpm_runtime_put(ssi->device.parent);\n\t}\n}\nEXPORT_SYMBOL_GPL(ssi_waketest);\n\nstatic void ssi_gdd_complete(struct hsi_controller *ssi, unsigned int lch)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct hsi_msg *msg = omap_ssi->gdd_trn[lch].msg;\n\tstruct hsi_port *port = to_hsi_port(msg->cl->device.parent);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tunsigned int dir;\n\tu32 csr;\n\tu32 val;\n\n\tspin_lock(&omap_ssi->lock);\n\n\tval = readl(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\tval &= ~SSI_GDD_LCH(lch);\n\twritel_relaxed(val, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\n\tif (msg->ttype == HSI_MSG_READ) {\n\t\tdir = DMA_FROM_DEVICE;\n\t\tval = SSI_DATAAVAILABLE(msg->channel);\n\t\tpm_runtime_put(omap_port->pdev);\n\t} else {\n\t\tdir = DMA_TO_DEVICE;\n\t\tval = SSI_DATAACCEPT(msg->channel);\n\t\t \n\t}\n\tdma_unmap_sg(&ssi->device, msg->sgt.sgl, msg->sgt.nents, dir);\n\tcsr = readw(omap_ssi->gdd + SSI_GDD_CSR_REG(lch));\n\tomap_ssi->gdd_trn[lch].msg = NULL;  \n\tdev_dbg(&port->device, \"DMA completed ch %d ttype %d\\n\",\n\t\t\t\tmsg->channel, msg->ttype);\n\tspin_unlock(&omap_ssi->lock);\n\tif (csr & SSI_CSR_TOUR) {  \n\t\tmsg->status = HSI_STATUS_ERROR;\n\t\tmsg->actual_len = 0;\n\t\tspin_lock(&omap_port->lock);\n\t\tlist_del(&msg->link);  \n\t\tspin_unlock(&omap_port->lock);\n\n\t\tlist_add_tail(&msg->link, &omap_port->errqueue);\n\t\tschedule_delayed_work(&omap_port->errqueue_work, 0);\n\t\treturn;\n\t}\n\tspin_lock(&omap_port->lock);\n\tval |= readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\twritel_relaxed(val, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\tspin_unlock(&omap_port->lock);\n\n\tmsg->status = HSI_STATUS_COMPLETED;\n\tmsg->actual_len = sg_dma_len(msg->sgt.sgl);\n}\n\nstatic void ssi_gdd_tasklet(unsigned long dev)\n{\n\tstruct hsi_controller *ssi = (struct hsi_controller *)dev;\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem *sys = omap_ssi->sys;\n\tunsigned int lch;\n\tu32 status_reg;\n\n\tpm_runtime_get(ssi->device.parent);\n\n\tif (!pm_runtime_active(ssi->device.parent)) {\n\t\tdev_warn(ssi->device.parent, \"ssi_gdd_tasklet called without runtime PM!\\n\");\n\t\tpm_runtime_put(ssi->device.parent);\n\t\treturn;\n\t}\n\n\tstatus_reg = readl(sys + SSI_GDD_MPU_IRQ_STATUS_REG);\n\tfor (lch = 0; lch < SSI_MAX_GDD_LCH; lch++) {\n\t\tif (status_reg & SSI_GDD_LCH(lch))\n\t\t\tssi_gdd_complete(ssi, lch);\n\t}\n\twritel_relaxed(status_reg, sys + SSI_GDD_MPU_IRQ_STATUS_REG);\n\tstatus_reg = readl(sys + SSI_GDD_MPU_IRQ_STATUS_REG);\n\n\tpm_runtime_put(ssi->device.parent);\n\n\tif (status_reg)\n\t\ttasklet_hi_schedule(&omap_ssi->gdd_tasklet);\n\telse\n\t\tenable_irq(omap_ssi->gdd_irq);\n\n}\n\nstatic irqreturn_t ssi_gdd_isr(int irq, void *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\ttasklet_hi_schedule(&omap_ssi->gdd_tasklet);\n\tdisable_irq_nosync(irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned long ssi_get_clk_rate(struct hsi_controller *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tunsigned long rate = clk_get_rate(omap_ssi->fck);\n\treturn rate;\n}\n\nstatic int ssi_clk_event(struct notifier_block *nb, unsigned long event,\n\t\t\t\t\t\t\t\tvoid *data)\n{\n\tstruct omap_ssi_controller *omap_ssi = container_of(nb,\n\t\t\t\t\tstruct omap_ssi_controller, fck_nb);\n\tstruct hsi_controller *ssi = to_hsi_controller(omap_ssi->dev);\n\tstruct clk_notifier_data *clk_data = data;\n\tstruct omap_ssi_port *omap_port;\n\tint i;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\tdev_dbg(&ssi->device, \"pre rate change\\n\");\n\n\t\tfor (i = 0; i < ssi->num_ports; i++) {\n\t\t\tomap_port = omap_ssi->port[i];\n\n\t\t\tif (!omap_port)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdisable_irq(omap_port->wake_irq);\n\n\t\t\t \n\t\t\tpinctrl_pm_select_idle_state(omap_port->pdev);\n\t\t\tudelay(1);  \n\t\t}\n\n\t\tbreak;\n\tcase ABORT_RATE_CHANGE:\n\t\tdev_dbg(&ssi->device, \"abort rate change\\n\");\n\t\tfallthrough;\n\tcase POST_RATE_CHANGE:\n\t\tdev_dbg(&ssi->device, \"post rate change (%lu -> %lu)\\n\",\n\t\t\tclk_data->old_rate, clk_data->new_rate);\n\t\tomap_ssi->fck_rate = DIV_ROUND_CLOSEST(clk_data->new_rate, 1000);  \n\n\t\tfor (i = 0; i < ssi->num_ports; i++) {\n\t\t\tomap_port = omap_ssi->port[i];\n\n\t\t\tif (!omap_port)\n\t\t\t\tcontinue;\n\n\t\t\tomap_ssi_port_update_fclk(ssi, omap_port);\n\n\t\t\t \n\t\t\tpinctrl_pm_select_default_state(omap_port->pdev);\n\t\t\tenable_irq(omap_port->wake_irq);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int ssi_get_iomem(struct platform_device *pd,\n\t\tconst char *name, void __iomem **pbase, dma_addr_t *phy)\n{\n\tstruct resource *mem;\n\tvoid __iomem *base;\n\tstruct hsi_controller *ssi = platform_get_drvdata(pd);\n\n\tmem = platform_get_resource_byname(pd, IORESOURCE_MEM, name);\n\tbase = devm_ioremap_resource(&ssi->device, mem);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t*pbase = base;\n\n\tif (phy)\n\t\t*phy = mem->start;\n\n\treturn 0;\n}\n\nstatic int ssi_add_controller(struct hsi_controller *ssi,\n\t\t\t\t\t\tstruct platform_device *pd)\n{\n\tstruct omap_ssi_controller *omap_ssi;\n\tint err;\n\n\tomap_ssi = devm_kzalloc(&ssi->device, sizeof(*omap_ssi), GFP_KERNEL);\n\tif (!omap_ssi)\n\t\treturn -ENOMEM;\n\n\terr = ida_simple_get(&platform_omap_ssi_ida, 0, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\treturn err;\n\tssi->id = err;\n\n\tssi->owner = THIS_MODULE;\n\tssi->device.parent = &pd->dev;\n\tdev_set_name(&ssi->device, \"ssi%d\", ssi->id);\n\thsi_controller_set_drvdata(ssi, omap_ssi);\n\tomap_ssi->dev = &ssi->device;\n\terr = ssi_get_iomem(pd, \"sys\", &omap_ssi->sys, NULL);\n\tif (err < 0)\n\t\tgoto out_err;\n\terr = ssi_get_iomem(pd, \"gdd\", &omap_ssi->gdd, NULL);\n\tif (err < 0)\n\t\tgoto out_err;\n\terr = platform_get_irq_byname(pd, \"gdd_mpu\");\n\tif (err < 0)\n\t\tgoto out_err;\n\tomap_ssi->gdd_irq = err;\n\ttasklet_init(&omap_ssi->gdd_tasklet, ssi_gdd_tasklet,\n\t\t\t\t\t\t\t(unsigned long)ssi);\n\terr = devm_request_irq(&ssi->device, omap_ssi->gdd_irq, ssi_gdd_isr,\n\t\t\t\t\t\t0, \"gdd_mpu\", ssi);\n\tif (err < 0) {\n\t\tdev_err(&ssi->device, \"Request GDD IRQ %d failed (%d)\",\n\t\t\t\t\t\t\tomap_ssi->gdd_irq, err);\n\t\tgoto out_err;\n\t}\n\n\tomap_ssi->port = devm_kcalloc(&ssi->device, ssi->num_ports,\n\t\t\t\t      sizeof(*omap_ssi->port), GFP_KERNEL);\n\tif (!omap_ssi->port) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tomap_ssi->fck = devm_clk_get(&ssi->device, \"ssi_ssr_fck\");\n\tif (IS_ERR(omap_ssi->fck)) {\n\t\tdev_err(&pd->dev, \"Could not acquire clock \\\"ssi_ssr_fck\\\": %li\\n\",\n\t\t\tPTR_ERR(omap_ssi->fck));\n\t\terr = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\tomap_ssi->fck_nb.notifier_call = ssi_clk_event;\n\tomap_ssi->fck_nb.priority = INT_MAX;\n\tclk_notifier_register(omap_ssi->fck, &omap_ssi->fck_nb);\n\n\t \n\tomap_ssi->get_loss = NULL;\n\n\tomap_ssi->max_speed = UINT_MAX;\n\tspin_lock_init(&omap_ssi->lock);\n\terr = hsi_register_controller(ssi);\n\n\tif (err < 0)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tida_simple_remove(&platform_omap_ssi_ida, ssi->id);\n\treturn err;\n}\n\nstatic int ssi_hw_init(struct hsi_controller *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tint err;\n\n\terr = pm_runtime_resume_and_get(ssi->device.parent);\n\tif (err < 0) {\n\t\tdev_err(&ssi->device, \"runtime PM failed %d\\n\", err);\n\t\treturn err;\n\t}\n\t \n\twritel_relaxed(SSI_SWRESET, omap_ssi->gdd + SSI_GDD_GRST_REG);\n\t \n\tomap_ssi->fck_rate = DIV_ROUND_CLOSEST(ssi_get_clk_rate(ssi), 1000);\n\tdev_dbg(&ssi->device, \"SSI fck rate %lu kHz\\n\", omap_ssi->fck_rate);\n\n\twritel_relaxed(SSI_CLK_AUTOGATING_ON, omap_ssi->sys + SSI_GDD_GCR_REG);\n\tomap_ssi->gdd_gcr = SSI_CLK_AUTOGATING_ON;\n\tpm_runtime_put_sync(ssi->device.parent);\n\n\treturn 0;\n}\n\nstatic void ssi_remove_controller(struct hsi_controller *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tint id = ssi->id;\n\ttasklet_kill(&omap_ssi->gdd_tasklet);\n\thsi_unregister_controller(ssi);\n\tclk_notifier_unregister(omap_ssi->fck, &omap_ssi->fck_nb);\n\tida_simple_remove(&platform_omap_ssi_ida, id);\n}\n\nstatic inline int ssi_of_get_available_ports_count(const struct device_node *np)\n{\n\tstruct device_node *child;\n\tint num = 0;\n\n\tfor_each_available_child_of_node(np, child)\n\t\tif (of_device_is_compatible(child, \"ti,omap3-ssi-port\"))\n\t\t\tnum++;\n\n\treturn num;\n}\n\nstatic int ssi_remove_ports(struct device *dev, void *c)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tif (!dev->of_node)\n\t\treturn 0;\n\n\tof_node_clear_flag(dev->of_node, OF_POPULATED);\n\tof_device_unregister(pdev);\n\n\treturn 0;\n}\n\nstatic int ssi_probe(struct platform_device *pd)\n{\n\tstruct platform_device *childpdev;\n\tstruct device_node *np = pd->dev.of_node;\n\tstruct device_node *child;\n\tstruct hsi_controller *ssi;\n\tint err;\n\tint num_ports;\n\n\tif (!np) {\n\t\tdev_err(&pd->dev, \"missing device tree data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ports = ssi_of_get_available_ports_count(np);\n\n\tssi = hsi_alloc_controller(num_ports, GFP_KERNEL);\n\tif (!ssi) {\n\t\tdev_err(&pd->dev, \"No memory for controller\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pd, ssi);\n\n\terr = ssi_add_controller(ssi, pd);\n\tif (err < 0) {\n\t\thsi_put_controller(ssi);\n\t\tgoto out1;\n\t}\n\n\tpm_runtime_enable(&pd->dev);\n\n\terr = ssi_hw_init(ssi);\n\tif (err < 0)\n\t\tgoto out2;\n#ifdef CONFIG_DEBUG_FS\n\terr = ssi_debug_add_ctrl(ssi);\n\tif (err < 0)\n\t\tgoto out2;\n#endif\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (!of_device_is_compatible(child, \"ti,omap3-ssi-port\"))\n\t\t\tcontinue;\n\n\t\tchildpdev = of_platform_device_create(child, NULL, &pd->dev);\n\t\tif (!childpdev) {\n\t\t\terr = -ENODEV;\n\t\t\tdev_err(&pd->dev, \"failed to create ssi controller port\\n\");\n\t\t\tof_node_put(child);\n\t\t\tgoto out3;\n\t\t}\n\t}\n\n\tdev_info(&pd->dev, \"ssi controller %d initialized (%d ports)!\\n\",\n\t\tssi->id, num_ports);\n\treturn err;\nout3:\n\tdevice_for_each_child(&pd->dev, NULL, ssi_remove_ports);\nout2:\n\tssi_remove_controller(ssi);\n\tpm_runtime_disable(&pd->dev);\nout1:\n\tplatform_set_drvdata(pd, NULL);\n\n\treturn err;\n}\n\nstatic int ssi_remove(struct platform_device *pd)\n{\n\tstruct hsi_controller *ssi = platform_get_drvdata(pd);\n\n\t \n\tdevice_for_each_child(&pd->dev, NULL, ssi_remove_ports);\n\n#ifdef CONFIG_DEBUG_FS\n\tssi_debug_remove_ctrl(ssi);\n#endif\n\tssi_remove_controller(ssi);\n\tplatform_set_drvdata(pd, NULL);\n\n\tpm_runtime_disable(&pd->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int omap_ssi_runtime_suspend(struct device *dev)\n{\n\tstruct hsi_controller *ssi = dev_get_drvdata(dev);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tdev_dbg(dev, \"runtime suspend!\\n\");\n\n\tif (omap_ssi->get_loss)\n\t\tomap_ssi->loss_count =\n\t\t\t\tomap_ssi->get_loss(ssi->device.parent);\n\n\treturn 0;\n}\n\nstatic int omap_ssi_runtime_resume(struct device *dev)\n{\n\tstruct hsi_controller *ssi = dev_get_drvdata(dev);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tdev_dbg(dev, \"runtime resume!\\n\");\n\n\tif ((omap_ssi->get_loss) && (omap_ssi->loss_count ==\n\t\t\t\tomap_ssi->get_loss(ssi->device.parent)))\n\t\treturn 0;\n\n\twritel_relaxed(omap_ssi->gdd_gcr, omap_ssi->gdd + SSI_GDD_GCR_REG);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_ssi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(omap_ssi_runtime_suspend, omap_ssi_runtime_resume,\n\t\tNULL)\n};\n\n#define DEV_PM_OPS     (&omap_ssi_pm_ops)\n#else\n#define DEV_PM_OPS     NULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id omap_ssi_of_match[] = {\n\t{ .compatible = \"ti,omap3-ssi\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_ssi_of_match);\n#else\n#define omap_ssi_of_match NULL\n#endif\n\nstatic struct platform_driver ssi_pdriver = {\n\t.probe = ssi_probe,\n\t.remove\t= ssi_remove,\n\t.driver\t= {\n\t\t.name\t= \"omap_ssi\",\n\t\t.pm     = DEV_PM_OPS,\n\t\t.of_match_table = omap_ssi_of_match,\n\t},\n};\n\nstatic int __init ssi_init(void) {\n\tint ret;\n\n\tret = platform_driver_register(&ssi_pdriver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&ssi_port_pdriver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&ssi_pdriver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(ssi_init);\n\nstatic void __exit ssi_exit(void) {\n\tplatform_driver_unregister(&ssi_port_pdriver);\n\tplatform_driver_unregister(&ssi_pdriver);\n}\nmodule_exit(ssi_exit);\n\nMODULE_ALIAS(\"platform:omap_ssi\");\nMODULE_AUTHOR(\"Carlos Chinea <carlos.chinea@nokia.com>\");\nMODULE_AUTHOR(\"Sebastian Reichel <sre@kernel.org>\");\nMODULE_DESCRIPTION(\"Synchronous Serial Interface Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}