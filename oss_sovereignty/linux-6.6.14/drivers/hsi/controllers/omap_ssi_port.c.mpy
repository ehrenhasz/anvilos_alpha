{
  "module_name": "omap_ssi_port.c",
  "hash_id": "ff15ddc6470de5bd76a46fbab710f50ee76f5abb040cd86dbb06279be014b538",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hsi/controllers/omap_ssi_port.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/debugfs.h>\n\n#include \"omap_ssi_regs.h\"\n#include \"omap_ssi.h\"\n\nstatic inline int hsi_dummy_msg(struct hsi_msg *msg __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline int hsi_dummy_cl(struct hsi_client *cl __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline unsigned int ssi_wakein(struct hsi_port *port)\n{\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\treturn gpiod_get_value(omap_port->wake_gpio);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void ssi_debug_remove_port(struct hsi_port *port)\n{\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\n\tdebugfs_remove_recursive(omap_port->dir);\n}\n\nstatic int ssi_port_regs_show(struct seq_file *m, void *p __maybe_unused)\n{\n\tstruct hsi_port *port = m->private;\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem\t*base = omap_ssi->sys;\n\tunsigned int ch;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tif (omap_port->wake_irq > 0)\n\t\tseq_printf(m, \"CAWAKE\\t\\t: %d\\n\", ssi_wakein(port));\n\tseq_printf(m, \"WAKE\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_WAKE_REG(port->num)));\n\tseq_printf(m, \"MPU_ENABLE_IRQ%d\\t: 0x%08x\\n\", 0,\n\t\t\treadl(base + SSI_MPU_ENABLE_REG(port->num, 0)));\n\tseq_printf(m, \"MPU_STATUS_IRQ%d\\t: 0x%08x\\n\", 0,\n\t\t\treadl(base + SSI_MPU_STATUS_REG(port->num, 0)));\n\t \n\tbase = omap_port->sst_base;\n\tseq_puts(m, \"\\nSST\\n===\\n\");\n\tseq_printf(m, \"ID SST\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_ID_REG));\n\tseq_printf(m, \"MODE\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_MODE_REG));\n\tseq_printf(m, \"FRAMESIZE\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_FRAMESIZE_REG));\n\tseq_printf(m, \"DIVISOR\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_DIVISOR_REG));\n\tseq_printf(m, \"CHANNELS\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_CHANNELS_REG));\n\tseq_printf(m, \"ARBMODE\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_ARBMODE_REG));\n\tseq_printf(m, \"TXSTATE\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_TXSTATE_REG));\n\tseq_printf(m, \"BUFSTATE\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_BUFSTATE_REG));\n\tseq_printf(m, \"BREAK\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SST_BREAK_REG));\n\tfor (ch = 0; ch < omap_port->channels; ch++) {\n\t\tseq_printf(m, \"BUFFER_CH%d\\t: 0x%08x\\n\", ch,\n\t\t\t\treadl(base + SSI_SST_BUFFER_CH_REG(ch)));\n\t}\n\t \n\tbase = omap_port->ssr_base;\n\tseq_puts(m, \"\\nSSR\\n===\\n\");\n\tseq_printf(m, \"ID SSR\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_ID_REG));\n\tseq_printf(m, \"MODE\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_MODE_REG));\n\tseq_printf(m, \"FRAMESIZE\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_FRAMESIZE_REG));\n\tseq_printf(m, \"CHANNELS\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_CHANNELS_REG));\n\tseq_printf(m, \"TIMEOUT\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_TIMEOUT_REG));\n\tseq_printf(m, \"RXSTATE\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_RXSTATE_REG));\n\tseq_printf(m, \"BUFSTATE\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_BUFSTATE_REG));\n\tseq_printf(m, \"BREAK\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_BREAK_REG));\n\tseq_printf(m, \"ERROR\\t\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_ERROR_REG));\n\tseq_printf(m, \"ERRORACK\\t: 0x%08x\\n\",\n\t\t\t\treadl(base + SSI_SSR_ERRORACK_REG));\n\tfor (ch = 0; ch < omap_port->channels; ch++) {\n\t\tseq_printf(m, \"BUFFER_CH%d\\t: 0x%08x\\n\", ch,\n\t\t\t\treadl(base + SSI_SSR_BUFFER_CH_REG(ch)));\n\t}\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(ssi_port_regs);\n\nstatic int ssi_div_get(void *data, u64 *val)\n{\n\tstruct hsi_port *port = data;\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\t*val = readl(omap_port->sst_base + SSI_SST_DIVISOR_REG);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn 0;\n}\n\nstatic int ssi_div_set(void *data, u64 val)\n{\n\tstruct hsi_port *port = data;\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\n\tif (val > 127)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\twritel(val, omap_port->sst_base + SSI_SST_DIVISOR_REG);\n\tomap_port->sst.divisor = val;\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(ssi_sst_div_fops, ssi_div_get, ssi_div_set, \"%llu\\n\");\n\nstatic void ssi_debug_add_port(struct omap_ssi_port *omap_port,\n\t\t\t\t     struct dentry *dir)\n{\n\tstruct hsi_port *port = to_hsi_port(omap_port->dev);\n\n\tdir = debugfs_create_dir(dev_name(omap_port->dev), dir);\n\tomap_port->dir = dir;\n\tdebugfs_create_file(\"regs\", S_IRUGO, dir, port, &ssi_port_regs_fops);\n\tdir = debugfs_create_dir(\"sst\", dir);\n\tdebugfs_create_file_unsafe(\"divisor\", 0644, dir, port,\n\t\t\t\t   &ssi_sst_div_fops);\n}\n#endif\n\nstatic void ssi_process_errqueue(struct work_struct *work)\n{\n\tstruct omap_ssi_port *omap_port;\n\tstruct list_head *head, *tmp;\n\tstruct hsi_msg *msg;\n\n\tomap_port = container_of(work, struct omap_ssi_port, errqueue_work.work);\n\n\tlist_for_each_safe(head, tmp, &omap_port->errqueue) {\n\t\tmsg = list_entry(head, struct hsi_msg, link);\n\t\tmsg->complete(msg);\n\t\tlist_del(head);\n\t}\n}\n\nstatic int ssi_claim_lch(struct hsi_msg *msg)\n{\n\n\tstruct hsi_port *port = hsi_get_port(msg->cl);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tint lch;\n\n\tfor (lch = 0; lch < SSI_MAX_GDD_LCH; lch++)\n\t\tif (!omap_ssi->gdd_trn[lch].msg) {\n\t\t\tomap_ssi->gdd_trn[lch].msg = msg;\n\t\t\tomap_ssi->gdd_trn[lch].sg = msg->sgt.sgl;\n\t\t\treturn lch;\n\t\t}\n\n\treturn -EBUSY;\n}\n\nstatic int ssi_start_dma(struct hsi_msg *msg, int lch)\n{\n\tstruct hsi_port *port = hsi_get_port(msg->cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem *gdd = omap_ssi->gdd;\n\tint err;\n\tu16 csdp;\n\tu16 ccr;\n\tu32 s_addr;\n\tu32 d_addr;\n\tu32 tmp;\n\n\t \n\tpm_runtime_get(omap_port->pdev);\n\n\tif (!pm_runtime_active(omap_port->pdev)) {\n\t\tdev_warn(&port->device, \"ssi_start_dma called without runtime PM!\\n\");\n\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (msg->ttype == HSI_MSG_READ) {\n\t\terr = dma_map_sg(&ssi->device, msg->sgt.sgl, msg->sgt.nents,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_dbg(&ssi->device, \"DMA map SG failed !\\n\");\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\t\treturn -EIO;\n\t\t}\n\t\tcsdp = SSI_DST_BURST_4x32_BIT | SSI_DST_MEMORY_PORT |\n\t\t\tSSI_SRC_SINGLE_ACCESS0 | SSI_SRC_PERIPHERAL_PORT |\n\t\t\tSSI_DATA_TYPE_S32;\n\t\tccr = msg->channel + 0x10 + (port->num * 8);  \n\t\tccr |= SSI_DST_AMODE_POSTINC | SSI_SRC_AMODE_CONST |\n\t\t\tSSI_CCR_ENABLE;\n\t\ts_addr = omap_port->ssr_dma +\n\t\t\t\t\tSSI_SSR_BUFFER_CH_REG(msg->channel);\n\t\td_addr = sg_dma_address(msg->sgt.sgl);\n\t} else {\n\t\terr = dma_map_sg(&ssi->device, msg->sgt.sgl, msg->sgt.nents,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_dbg(&ssi->device, \"DMA map SG failed !\\n\");\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\t\treturn -EIO;\n\t\t}\n\t\tcsdp = SSI_SRC_BURST_4x32_BIT | SSI_SRC_MEMORY_PORT |\n\t\t\tSSI_DST_SINGLE_ACCESS0 | SSI_DST_PERIPHERAL_PORT |\n\t\t\tSSI_DATA_TYPE_S32;\n\t\tccr = (msg->channel + 1 + (port->num * 8)) & 0xf;  \n\t\tccr |= SSI_SRC_AMODE_POSTINC | SSI_DST_AMODE_CONST |\n\t\t\tSSI_CCR_ENABLE;\n\t\ts_addr = sg_dma_address(msg->sgt.sgl);\n\t\td_addr = omap_port->sst_dma +\n\t\t\t\t\tSSI_SST_BUFFER_CH_REG(msg->channel);\n\t}\n\tdev_dbg(&ssi->device, \"lch %d cdsp %08x ccr %04x s_addr %08x d_addr %08x\\n\",\n\t\tlch, csdp, ccr, s_addr, d_addr);\n\n\twritew_relaxed(csdp, gdd + SSI_GDD_CSDP_REG(lch));\n\twritew_relaxed(SSI_BLOCK_IE | SSI_TOUT_IE, gdd + SSI_GDD_CICR_REG(lch));\n\twritel_relaxed(d_addr, gdd + SSI_GDD_CDSA_REG(lch));\n\twritel_relaxed(s_addr, gdd + SSI_GDD_CSSA_REG(lch));\n\twritew_relaxed(SSI_BYTES_TO_FRAMES(msg->sgt.sgl->length),\n\t\t\t\t\t\tgdd + SSI_GDD_CEN_REG(lch));\n\n\tspin_lock_bh(&omap_ssi->lock);\n\ttmp = readl(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\ttmp |= SSI_GDD_LCH(lch);\n\twritel_relaxed(tmp, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\tspin_unlock_bh(&omap_ssi->lock);\n\twritew(ccr, gdd + SSI_GDD_CCR_REG(lch));\n\tmsg->status = HSI_STATUS_PROCEEDING;\n\n\treturn 0;\n}\n\nstatic int ssi_start_pio(struct hsi_msg *msg)\n{\n\tstruct hsi_port *port = hsi_get_port(msg->cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tu32 val;\n\n\tpm_runtime_get(omap_port->pdev);\n\n\tif (!pm_runtime_active(omap_port->pdev)) {\n\t\tdev_warn(&port->device, \"ssi_start_pio called without runtime PM!\\n\");\n\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (msg->ttype == HSI_MSG_WRITE) {\n\t\tval = SSI_DATAACCEPT(msg->channel);\n\t\t \n\t\tpm_runtime_get(omap_port->pdev);\n\t} else {\n\t\tval = SSI_DATAAVAILABLE(msg->channel) | SSI_ERROROCCURED;\n\t}\n\tdev_dbg(&port->device, \"Single %s transfer\\n\",\n\t\t\t\t\t\tmsg->ttype ? \"write\" : \"read\");\n\tval |= readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\twritel(val, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\tmsg->actual_len = 0;\n\tmsg->status = HSI_STATUS_PROCEEDING;\n\n\treturn 0;\n}\n\nstatic int ssi_start_transfer(struct list_head *queue)\n{\n\tstruct hsi_msg *msg;\n\tint lch = -1;\n\n\tif (list_empty(queue))\n\t\treturn 0;\n\tmsg = list_first_entry(queue, struct hsi_msg, link);\n\tif (msg->status != HSI_STATUS_QUEUED)\n\t\treturn 0;\n\tif ((msg->sgt.nents) && (msg->sgt.sgl->length > sizeof(u32)))\n\t\tlch = ssi_claim_lch(msg);\n\tif (lch >= 0)\n\t\treturn ssi_start_dma(msg, lch);\n\telse\n\t\treturn ssi_start_pio(msg);\n}\n\nstatic int ssi_async_break(struct hsi_msg *msg)\n{\n\tstruct hsi_port *port = hsi_get_port(msg->cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tint err = 0;\n\tu32 tmp;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tif (msg->ttype == HSI_MSG_WRITE) {\n\t\tif (omap_port->sst.mode != SSI_MODE_FRAME) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\twritel(1, omap_port->sst_base + SSI_SST_BREAK_REG);\n\t\tmsg->status = HSI_STATUS_COMPLETED;\n\t\tmsg->complete(msg);\n\t} else {\n\t\tif (omap_port->ssr.mode != SSI_MODE_FRAME) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_bh(&omap_port->lock);\n\t\ttmp = readl(omap_ssi->sys +\n\t\t\t\t\tSSI_MPU_ENABLE_REG(port->num, 0));\n\t\twritel(tmp | SSI_BREAKDETECTED,\n\t\t\tomap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\t\tmsg->status = HSI_STATUS_PROCEEDING;\n\t\tlist_add_tail(&msg->link, &omap_port->brkqueue);\n\t\tspin_unlock_bh(&omap_port->lock);\n\t}\nout:\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn err;\n}\n\nstatic int ssi_async(struct hsi_msg *msg)\n{\n\tstruct hsi_port *port = hsi_get_port(msg->cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct list_head *queue;\n\tint err = 0;\n\n\tBUG_ON(!msg);\n\n\tif (msg->sgt.nents > 1)\n\t\treturn -ENOSYS;  \n\n\tif (msg->break_frame)\n\t\treturn ssi_async_break(msg);\n\n\tif (msg->ttype) {\n\t\tBUG_ON(msg->channel >= omap_port->sst.channels);\n\t\tqueue = &omap_port->txqueue[msg->channel];\n\t} else {\n\t\tBUG_ON(msg->channel >= omap_port->ssr.channels);\n\t\tqueue = &omap_port->rxqueue[msg->channel];\n\t}\n\tmsg->status = HSI_STATUS_QUEUED;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tspin_lock_bh(&omap_port->lock);\n\tlist_add_tail(&msg->link, queue);\n\terr = ssi_start_transfer(queue);\n\tif (err < 0) {\n\t\tlist_del(&msg->link);\n\t\tmsg->status = HSI_STATUS_ERROR;\n\t}\n\tspin_unlock_bh(&omap_port->lock);\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\tdev_dbg(&port->device, \"msg status %d ttype %d ch %d\\n\",\n\t\t\t\tmsg->status, msg->ttype, msg->channel);\n\n\treturn err;\n}\n\nstatic u32 ssi_calculate_div(struct hsi_controller *ssi)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tu32 tx_fckrate = (u32) omap_ssi->fck_rate;\n\n\t \n\ttx_fckrate >>= 1;\n\t \n\ttx_fckrate--;\n\tdev_dbg(&ssi->device, \"TX div %d for fck_rate %lu Khz speed %d Kb/s\\n\",\n\t\ttx_fckrate / omap_ssi->max_speed, omap_ssi->fck_rate,\n\t\tomap_ssi->max_speed);\n\n\treturn tx_fckrate / omap_ssi->max_speed;\n}\n\nstatic void ssi_flush_queue(struct list_head *queue, struct hsi_client *cl)\n{\n\tstruct list_head *node, *tmp;\n\tstruct hsi_msg *msg;\n\n\tlist_for_each_safe(node, tmp, queue) {\n\t\tmsg = list_entry(node, struct hsi_msg, link);\n\t\tif ((cl) && (cl != msg->cl))\n\t\t\tcontinue;\n\t\tlist_del(node);\n\t\tpr_debug(\"flush queue: ch %d, msg %p len %d type %d ctxt %p\\n\",\n\t\t\tmsg->channel, msg, msg->sgt.sgl->length,\n\t\t\t\t\tmsg->ttype, msg->context);\n\t\tif (msg->destructor)\n\t\t\tmsg->destructor(msg);\n\t\telse\n\t\t\thsi_free_msg(msg);\n\t}\n}\n\nstatic int ssi_setup(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = to_hsi_port(cl->device.parent);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem *sst = omap_port->sst_base;\n\tvoid __iomem *ssr = omap_port->ssr_base;\n\tu32 div;\n\tu32 val;\n\tint err = 0;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tspin_lock_bh(&omap_port->lock);\n\tif (cl->tx_cfg.speed)\n\t\tomap_ssi->max_speed = cl->tx_cfg.speed;\n\tdiv = ssi_calculate_div(ssi);\n\tif (div > SSI_MAX_DIVISOR) {\n\t\tdev_err(&cl->device, \"Invalid TX speed %d Mb/s (div %d)\\n\",\n\t\t\t\t\t\tcl->tx_cfg.speed, div);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\twritel_relaxed(SSI_MODE_SLEEP, sst + SSI_SST_MODE_REG);\n\twritel_relaxed(SSI_MODE_SLEEP, ssr + SSI_SSR_MODE_REG);\n\t \n\tval = readl(ssr + SSI_SSR_MODE_REG);\n\t \n\twritel_relaxed(31, sst + SSI_SST_FRAMESIZE_REG);\n\twritel_relaxed(div, sst + SSI_SST_DIVISOR_REG);\n\twritel_relaxed(cl->tx_cfg.num_hw_channels, sst + SSI_SST_CHANNELS_REG);\n\twritel_relaxed(cl->tx_cfg.arb_mode, sst + SSI_SST_ARBMODE_REG);\n\twritel_relaxed(cl->tx_cfg.mode, sst + SSI_SST_MODE_REG);\n\t \n\twritel_relaxed(31, ssr + SSI_SSR_FRAMESIZE_REG);\n\twritel_relaxed(cl->rx_cfg.num_hw_channels, ssr + SSI_SSR_CHANNELS_REG);\n\twritel_relaxed(0, ssr + SSI_SSR_TIMEOUT_REG);\n\t \n\tif ((omap_port->ssr.mode == SSI_MODE_FRAME) &&\n\t\t(cl->rx_cfg.mode != SSI_MODE_FRAME))\n\t\tssi_flush_queue(&omap_port->brkqueue, cl);\n\twritel_relaxed(cl->rx_cfg.mode, ssr + SSI_SSR_MODE_REG);\n\tomap_port->channels = max(cl->rx_cfg.num_hw_channels,\n\t\t\t\t  cl->tx_cfg.num_hw_channels);\n\t \n\t \n\tomap_port->sst.divisor = div;\n\tomap_port->sst.frame_size = 31;\n\tomap_port->sst.channels = cl->tx_cfg.num_hw_channels;\n\tomap_port->sst.arb_mode = cl->tx_cfg.arb_mode;\n\tomap_port->sst.mode = cl->tx_cfg.mode;\n\t \n\tomap_port->ssr.frame_size = 31;\n\tomap_port->ssr.timeout = 0;\n\tomap_port->ssr.channels = cl->rx_cfg.num_hw_channels;\n\tomap_port->ssr.mode = cl->rx_cfg.mode;\nout:\n\tspin_unlock_bh(&omap_port->lock);\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn err;\n}\n\nstatic int ssi_flush(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct hsi_msg *msg;\n\tvoid __iomem *sst = omap_port->sst_base;\n\tvoid __iomem *ssr = omap_port->ssr_base;\n\tunsigned int i;\n\tu32 err;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tspin_lock_bh(&omap_port->lock);\n\n\t \n\tpinctrl_pm_select_idle_state(omap_port->pdev);\n\tudelay(1);  \n\n\t \n\tfor (i = 0; i < SSI_MAX_GDD_LCH; i++) {\n\t\tmsg = omap_ssi->gdd_trn[i].msg;\n\t\tif (!msg || (port != hsi_get_port(msg->cl)))\n\t\t\tcontinue;\n\t\twritew_relaxed(0, omap_ssi->gdd + SSI_GDD_CCR_REG(i));\n\t\tif (msg->ttype == HSI_MSG_READ)\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\tomap_ssi->gdd_trn[i].msg = NULL;\n\t}\n\t \n\twritel_relaxed(0, sst + SSI_SST_BUFSTATE_REG);\n\twritel_relaxed(0, sst + SSI_SST_TXSTATE_REG);\n\t \n\twritel_relaxed(0, ssr + SSI_SSR_RXSTATE_REG);\n\twritel_relaxed(0, ssr + SSI_SSR_BUFSTATE_REG);\n\t \n\terr = readl(ssr + SSI_SSR_ERROR_REG);\n\twritel_relaxed(err, ssr + SSI_SSR_ERRORACK_REG);\n\t \n\twritel_relaxed(0, ssr + SSI_SSR_BREAK_REG);\n\t \n\twritel_relaxed(0, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\twritel_relaxed(0xffffff00,\n\t\t\tomap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\n\twritel_relaxed(0, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\twritel(0xff, omap_ssi->sys + SSI_GDD_MPU_IRQ_STATUS_REG);\n\t \n\tfor (i = 0; i < omap_port->channels; i++) {\n\t\t \n\t\tif (!list_empty(&omap_port->txqueue[i]))\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\tssi_flush_queue(&omap_port->txqueue[i], NULL);\n\t\tssi_flush_queue(&omap_port->rxqueue[i], NULL);\n\t}\n\tssi_flush_queue(&omap_port->brkqueue, NULL);\n\n\t \n\tpinctrl_pm_select_default_state(omap_port->pdev);\n\n\tspin_unlock_bh(&omap_port->lock);\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn 0;\n}\n\nstatic void start_tx_work(struct work_struct *work)\n{\n\tstruct omap_ssi_port *omap_port =\n\t\t\t\tcontainer_of(work, struct omap_ssi_port, work);\n\tstruct hsi_port *port = to_hsi_port(omap_port->dev);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tpm_runtime_get_sync(omap_port->pdev);  \n\twritel(SSI_WAKE(0), omap_ssi->sys + SSI_SET_WAKE_REG(port->num));\n}\n\nstatic int ssi_start_tx(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\n\tdev_dbg(&port->device, \"Wake out high %d\\n\", omap_port->wk_refcount);\n\n\tspin_lock_bh(&omap_port->wk_lock);\n\tif (omap_port->wk_refcount++) {\n\t\tspin_unlock_bh(&omap_port->wk_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&omap_port->wk_lock);\n\n\tschedule_work(&omap_port->work);\n\n\treturn 0;\n}\n\nstatic int ssi_stop_tx(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tdev_dbg(&port->device, \"Wake out low %d\\n\", omap_port->wk_refcount);\n\n\tspin_lock_bh(&omap_port->wk_lock);\n\tBUG_ON(!omap_port->wk_refcount);\n\tif (--omap_port->wk_refcount) {\n\t\tspin_unlock_bh(&omap_port->wk_lock);\n\t\treturn 0;\n\t}\n\twritel(SSI_WAKE(0), omap_ssi->sys + SSI_CLEAR_WAKE_REG(port->num));\n\tspin_unlock_bh(&omap_port->wk_lock);\n\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);  \n\n\n\treturn 0;\n}\n\nstatic void ssi_transfer(struct omap_ssi_port *omap_port,\n\t\t\t\t\t\t\tstruct list_head *queue)\n{\n\tstruct hsi_msg *msg;\n\tint err = -1;\n\n\tpm_runtime_get(omap_port->pdev);\n\tspin_lock_bh(&omap_port->lock);\n\twhile (err < 0) {\n\t\terr = ssi_start_transfer(queue);\n\t\tif (err < 0) {\n\t\t\tmsg = list_first_entry(queue, struct hsi_msg, link);\n\t\t\tmsg->status = HSI_STATUS_ERROR;\n\t\t\tmsg->actual_len = 0;\n\t\t\tlist_del(&msg->link);\n\t\t\tspin_unlock_bh(&omap_port->lock);\n\t\t\tmsg->complete(msg);\n\t\t\tspin_lock_bh(&omap_port->lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&omap_port->lock);\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n}\n\nstatic void ssi_cleanup_queues(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct hsi_msg *msg;\n\tunsigned int i;\n\tu32 rxbufstate = 0;\n\tu32 txbufstate = 0;\n\tu32 status = SSI_ERROROCCURED;\n\tu32 tmp;\n\n\tssi_flush_queue(&omap_port->brkqueue, cl);\n\tif (list_empty(&omap_port->brkqueue))\n\t\tstatus |= SSI_BREAKDETECTED;\n\n\tfor (i = 0; i < omap_port->channels; i++) {\n\t\tif (list_empty(&omap_port->txqueue[i]))\n\t\t\tcontinue;\n\t\tmsg = list_first_entry(&omap_port->txqueue[i], struct hsi_msg,\n\t\t\t\t\t\t\t\t\tlink);\n\t\tif ((msg->cl == cl) && (msg->status == HSI_STATUS_PROCEEDING)) {\n\t\t\ttxbufstate |= (1 << i);\n\t\t\tstatus |= SSI_DATAACCEPT(i);\n\t\t\t \n\t\t\tpm_runtime_mark_last_busy(omap_port->pdev);\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\t}\n\t\tssi_flush_queue(&omap_port->txqueue[i], cl);\n\t}\n\tfor (i = 0; i < omap_port->channels; i++) {\n\t\tif (list_empty(&omap_port->rxqueue[i]))\n\t\t\tcontinue;\n\t\tmsg = list_first_entry(&omap_port->rxqueue[i], struct hsi_msg,\n\t\t\t\t\t\t\t\t\tlink);\n\t\tif ((msg->cl == cl) && (msg->status == HSI_STATUS_PROCEEDING)) {\n\t\t\trxbufstate |= (1 << i);\n\t\t\tstatus |= SSI_DATAAVAILABLE(i);\n\t\t}\n\t\tssi_flush_queue(&omap_port->rxqueue[i], cl);\n\t\t \n\t\tif (!list_empty(&omap_port->rxqueue[i]))\n\t\t\tstatus &= ~SSI_ERROROCCURED;\n\t}\n\t \n\ttmp = readl(omap_port->sst_base + SSI_SST_BUFSTATE_REG);\n\ttmp &= ~txbufstate;\n\twritel_relaxed(tmp, omap_port->sst_base + SSI_SST_BUFSTATE_REG);\n\t \n\ttmp = readl(omap_port->ssr_base + SSI_SSR_BUFSTATE_REG);\n\ttmp &= ~rxbufstate;\n\twritel_relaxed(tmp, omap_port->ssr_base + SSI_SSR_BUFSTATE_REG);\n\t \n\ttmp = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\ttmp &= ~status;\n\twritel_relaxed(tmp, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\twritel_relaxed(status, omap_ssi->sys +\n\t\tSSI_MPU_STATUS_REG(port->num, 0));\n}\n\nstatic void ssi_cleanup_gdd(struct hsi_controller *ssi, struct hsi_client *cl)\n{\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_msg *msg;\n\tunsigned int i;\n\tu32 val = 0;\n\tu32 tmp;\n\n\tfor (i = 0; i < SSI_MAX_GDD_LCH; i++) {\n\t\tmsg = omap_ssi->gdd_trn[i].msg;\n\t\tif ((!msg) || (msg->cl != cl))\n\t\t\tcontinue;\n\t\twritew_relaxed(0, omap_ssi->gdd + SSI_GDD_CCR_REG(i));\n\t\tval |= (1 << i);\n\t\t \n\t\tif (msg->ttype == HSI_MSG_READ) {\n\t\t\tpm_runtime_mark_last_busy(omap_port->pdev);\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\t}\n\t\tomap_ssi->gdd_trn[i].msg = NULL;\n\t}\n\ttmp = readl_relaxed(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\ttmp &= ~val;\n\twritel_relaxed(tmp, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\twritel(val, omap_ssi->sys + SSI_GDD_MPU_IRQ_STATUS_REG);\n}\n\nstatic int ssi_set_port_mode(struct omap_ssi_port *omap_port, u32 mode)\n{\n\twritel(mode, omap_port->sst_base + SSI_SST_MODE_REG);\n\twritel(mode, omap_port->ssr_base + SSI_SSR_MODE_REG);\n\t \n\tmode = readl(omap_port->ssr_base + SSI_SSR_MODE_REG);\n\n\treturn 0;\n}\n\nstatic int ssi_release(struct hsi_client *cl)\n{\n\tstruct hsi_port *port = hsi_get_port(cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tspin_lock_bh(&omap_port->lock);\n\t \n\tssi_cleanup_gdd(ssi, cl);\n\t \n\tssi_cleanup_queues(cl);\n\t \n\tif (port->claimed <= 1) {\n\t\t \n\t\tif (test_and_clear_bit(SSI_WAKE_EN, &omap_port->flags))\n\t\t\tpm_runtime_put_sync(omap_port->pdev);\n\t\tpm_runtime_get(omap_port->pdev);\n\t\t \n\t\tssi_set_port_mode(omap_port, SSI_MODE_SLEEP);\n\t\tomap_port->sst.mode = SSI_MODE_SLEEP;\n\t\tomap_port->ssr.mode = SSI_MODE_SLEEP;\n\t\tpm_runtime_put(omap_port->pdev);\n\t\tWARN_ON(omap_port->wk_refcount != 0);\n\t}\n\tspin_unlock_bh(&omap_port->lock);\n\tpm_runtime_put_sync(omap_port->pdev);\n\n\treturn 0;\n}\n\n\n\nstatic void ssi_error(struct hsi_port *port)\n{\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct hsi_msg *msg;\n\tunsigned int i;\n\tu32 err;\n\tu32 val;\n\tu32 tmp;\n\n\t \n\terr = readl(omap_port->ssr_base + SSI_SSR_ERROR_REG);\n\tdev_err(&port->device, \"SSI error: 0x%02x\\n\", err);\n\tif (!err) {\n\t\tdev_dbg(&port->device, \"spurious SSI error ignored!\\n\");\n\t\treturn;\n\t}\n\tspin_lock(&omap_ssi->lock);\n\t \n\tfor (i = 0, val = 0; i < SSI_MAX_GDD_LCH; i++) {\n\t\tmsg = omap_ssi->gdd_trn[i].msg;\n\t\tif ((msg) && (msg->ttype == HSI_MSG_READ)) {\n\t\t\twritew_relaxed(0, omap_ssi->gdd + SSI_GDD_CCR_REG(i));\n\t\t\tval |= (1 << i);\n\t\t\tomap_ssi->gdd_trn[i].msg = NULL;\n\t\t}\n\t}\n\ttmp = readl(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\ttmp &= ~val;\n\twritel_relaxed(tmp, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\n\tspin_unlock(&omap_ssi->lock);\n\t \n\tspin_lock(&omap_port->lock);\n\ttmp = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\ttmp &= 0xfeff00ff;  \n\twritel_relaxed(tmp, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\t \n\twritel_relaxed(err, omap_port->ssr_base + SSI_SSR_ERRORACK_REG);\n\twritel_relaxed(SSI_ERROROCCURED,\n\t\t\tomap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\n\t \n\tfor (i = 0; i < omap_port->channels; i++) {\n\t\tif (list_empty(&omap_port->rxqueue[i]))\n\t\t\tcontinue;\n\t\tmsg = list_first_entry(&omap_port->rxqueue[i], struct hsi_msg,\n\t\t\t\t\t\t\t\t\tlink);\n\t\tlist_del(&msg->link);\n\t\tmsg->status = HSI_STATUS_ERROR;\n\t\tspin_unlock(&omap_port->lock);\n\t\tmsg->complete(msg);\n\t\t \n\t\tssi_transfer(omap_port, &omap_port->rxqueue[i]);\n\t\tspin_lock(&omap_port->lock);\n\t}\n\tspin_unlock(&omap_port->lock);\n}\n\nstatic void ssi_break_complete(struct hsi_port *port)\n{\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct hsi_msg *msg;\n\tstruct hsi_msg *tmp;\n\tu32 val;\n\n\tdev_dbg(&port->device, \"HWBREAK received\\n\");\n\n\tspin_lock(&omap_port->lock);\n\tval = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\tval &= ~SSI_BREAKDETECTED;\n\twritel_relaxed(val, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\twritel_relaxed(0, omap_port->ssr_base + SSI_SSR_BREAK_REG);\n\twritel(SSI_BREAKDETECTED,\n\t\t\tomap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\n\tspin_unlock(&omap_port->lock);\n\n\tlist_for_each_entry_safe(msg, tmp, &omap_port->brkqueue, link) {\n\t\tmsg->status = HSI_STATUS_COMPLETED;\n\t\tspin_lock(&omap_port->lock);\n\t\tlist_del(&msg->link);\n\t\tspin_unlock(&omap_port->lock);\n\t\tmsg->complete(msg);\n\t}\n\n}\n\nstatic void ssi_pio_complete(struct hsi_port *port, struct list_head *queue)\n{\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_msg *msg;\n\tu32 *buf;\n\tu32 reg;\n\tu32 val;\n\n\tspin_lock_bh(&omap_port->lock);\n\tmsg = list_first_entry(queue, struct hsi_msg, link);\n\tif ((!msg->sgt.nents) || (!msg->sgt.sgl->length)) {\n\t\tmsg->actual_len = 0;\n\t\tmsg->status = HSI_STATUS_PENDING;\n\t}\n\tif (msg->ttype == HSI_MSG_WRITE)\n\t\tval = SSI_DATAACCEPT(msg->channel);\n\telse\n\t\tval = SSI_DATAAVAILABLE(msg->channel);\n\tif (msg->status == HSI_STATUS_PROCEEDING) {\n\t\tbuf = sg_virt(msg->sgt.sgl) + msg->actual_len;\n\t\tif (msg->ttype == HSI_MSG_WRITE)\n\t\t\twritel(*buf, omap_port->sst_base +\n\t\t\t\t\tSSI_SST_BUFFER_CH_REG(msg->channel));\n\t\t else\n\t\t\t*buf = readl(omap_port->ssr_base +\n\t\t\t\t\tSSI_SSR_BUFFER_CH_REG(msg->channel));\n\t\tdev_dbg(&port->device, \"ch %d ttype %d 0x%08x\\n\", msg->channel,\n\t\t\t\t\t\t\tmsg->ttype, *buf);\n\t\tmsg->actual_len += sizeof(*buf);\n\t\tif (msg->actual_len >= msg->sgt.sgl->length)\n\t\t\tmsg->status = HSI_STATUS_COMPLETED;\n\t\t \n\t\tif ((msg->status == HSI_STATUS_PROCEEDING) ||\n\t\t\t\t((msg->status == HSI_STATUS_COMPLETED) &&\n\t\t\t\t\t(msg->ttype == HSI_MSG_WRITE))) {\n\t\t\twritel(val, omap_ssi->sys +\n\t\t\t\t\tSSI_MPU_STATUS_REG(port->num, 0));\n\t\t\tspin_unlock_bh(&omap_port->lock);\n\n\t\t\treturn;\n\t\t}\n\n\t}\n\t \n\treg = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\tif (msg->ttype == HSI_MSG_WRITE) {\n\t\t \n\t\tpm_runtime_mark_last_busy(omap_port->pdev);\n\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t}\n\treg &= ~val;\n\twritel_relaxed(reg, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\twritel_relaxed(val, omap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\n\tlist_del(&msg->link);\n\tspin_unlock_bh(&omap_port->lock);\n\tmsg->complete(msg);\n\tssi_transfer(omap_port, queue);\n}\n\nstatic irqreturn_t ssi_pio_thread(int irq, void *ssi_port)\n{\n\tstruct hsi_port *port = (struct hsi_port *)ssi_port;\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem *sys = omap_ssi->sys;\n\tunsigned int ch;\n\tu32 status_reg;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\n\tdo {\n\t\tstatus_reg = readl(sys + SSI_MPU_STATUS_REG(port->num, 0));\n\t\tstatus_reg &= readl(sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\n\t\tfor (ch = 0; ch < omap_port->channels; ch++) {\n\t\t\tif (status_reg & SSI_DATAACCEPT(ch))\n\t\t\t\tssi_pio_complete(port, &omap_port->txqueue[ch]);\n\t\t\tif (status_reg & SSI_DATAAVAILABLE(ch))\n\t\t\t\tssi_pio_complete(port, &omap_port->rxqueue[ch]);\n\t\t}\n\t\tif (status_reg & SSI_BREAKDETECTED)\n\t\t\tssi_break_complete(port);\n\t\tif (status_reg & SSI_ERROROCCURED)\n\t\t\tssi_error(port);\n\n\t\tstatus_reg = readl(sys + SSI_MPU_STATUS_REG(port->num, 0));\n\t\tstatus_reg &= readl(sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\n\t\t \n\t} while (status_reg);\n\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ssi_wake_thread(int irq __maybe_unused, void *ssi_port)\n{\n\tstruct hsi_port *port = (struct hsi_port *)ssi_port;\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tif (ssi_wakein(port)) {\n\t\t \n\t\tif (!test_and_set_bit(SSI_WAKE_EN, &omap_port->flags))\n\t\t\tpm_runtime_get_sync(omap_port->pdev);\n\t\tdev_dbg(&ssi->device, \"Wake in high\\n\");\n\t\tif (omap_port->wktest) {  \n\t\t\twritel(SSI_WAKE(0),\n\t\t\t\tomap_ssi->sys + SSI_SET_WAKE_REG(port->num));\n\t\t}\n\t\thsi_event(port, HSI_EVENT_START_RX);\n\t} else {\n\t\tdev_dbg(&ssi->device, \"Wake in low\\n\");\n\t\tif (omap_port->wktest) {  \n\t\t\twritel(SSI_WAKE(0),\n\t\t\t\tomap_ssi->sys + SSI_CLEAR_WAKE_REG(port->num));\n\t\t}\n\t\thsi_event(port, HSI_EVENT_STOP_RX);\n\t\tif (test_and_clear_bit(SSI_WAKE_EN, &omap_port->flags)) {\n\t\t\tpm_runtime_mark_last_busy(omap_port->pdev);\n\t\t\tpm_runtime_put_autosuspend(omap_port->pdev);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ssi_port_irq(struct hsi_port *port, struct platform_device *pd)\n{\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tint err;\n\n\terr = platform_get_irq(pd, 0);\n\tif (err < 0)\n\t\treturn err;\n\tomap_port->irq = err;\n\terr = devm_request_threaded_irq(&port->device, omap_port->irq, NULL,\n\t\t\t\tssi_pio_thread, IRQF_ONESHOT, \"SSI PORT\", port);\n\tif (err < 0)\n\t\tdev_err(&port->device, \"Request IRQ %d failed (%d)\\n\",\n\t\t\t\t\t\t\tomap_port->irq, err);\n\treturn err;\n}\n\nstatic int ssi_wake_irq(struct hsi_port *port, struct platform_device *pd)\n{\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tint cawake_irq;\n\tint err;\n\n\tif (!omap_port->wake_gpio) {\n\t\tomap_port->wake_irq = -1;\n\t\treturn 0;\n\t}\n\n\tcawake_irq = gpiod_to_irq(omap_port->wake_gpio);\n\tomap_port->wake_irq = cawake_irq;\n\n\terr = devm_request_threaded_irq(&port->device, cawake_irq, NULL,\n\t\tssi_wake_thread,\n\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\"SSI cawake\", port);\n\tif (err < 0)\n\t\tdev_err(&port->device, \"Request Wake in IRQ %d failed %d\\n\",\n\t\t\t\t\t\tcawake_irq, err);\n\terr = enable_irq_wake(cawake_irq);\n\tif (err < 0)\n\t\tdev_err(&port->device, \"Enable wake on the wakeline in irq %d failed %d\\n\",\n\t\t\tcawake_irq, err);\n\n\treturn err;\n}\n\nstatic void ssi_queues_init(struct omap_ssi_port *omap_port)\n{\n\tunsigned int ch;\n\n\tfor (ch = 0; ch < SSI_MAX_CHANNELS; ch++) {\n\t\tINIT_LIST_HEAD(&omap_port->txqueue[ch]);\n\t\tINIT_LIST_HEAD(&omap_port->rxqueue[ch]);\n\t}\n\tINIT_LIST_HEAD(&omap_port->brkqueue);\n}\n\nstatic int ssi_port_get_iomem(struct platform_device *pd,\n\t\tconst char *name, void __iomem **pbase, dma_addr_t *phy)\n{\n\tstruct hsi_port *port = platform_get_drvdata(pd);\n\tstruct resource *mem;\n\tstruct resource *ioarea;\n\tvoid __iomem *base;\n\n\tmem = platform_get_resource_byname(pd, IORESOURCE_MEM, name);\n\tif (!mem) {\n\t\tdev_err(&pd->dev, \"IO memory region missing (%s)\\n\", name);\n\t\treturn -ENXIO;\n\t}\n\tioarea = devm_request_mem_region(&port->device, mem->start,\n\t\t\t\t\tresource_size(mem), dev_name(&pd->dev));\n\tif (!ioarea) {\n\t\tdev_err(&pd->dev, \"%s IO memory region request failed\\n\",\n\t\t\t\t\t\t\t\tmem->name);\n\t\treturn -ENXIO;\n\t}\n\tbase = devm_ioremap(&port->device, mem->start, resource_size(mem));\n\tif (!base) {\n\t\tdev_err(&pd->dev, \"%s IO remap failed\\n\", mem->name);\n\t\treturn -ENXIO;\n\t}\n\t*pbase = base;\n\n\tif (phy)\n\t\t*phy = mem->start;\n\n\treturn 0;\n}\n\nstatic int ssi_port_probe(struct platform_device *pd)\n{\n\tstruct device_node *np = pd->dev.of_node;\n\tstruct hsi_port *port;\n\tstruct omap_ssi_port *omap_port;\n\tstruct hsi_controller *ssi = dev_get_drvdata(pd->dev.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tstruct gpio_desc *cawake_gpio = NULL;\n\tu32 port_id;\n\tint err;\n\n\tdev_dbg(&pd->dev, \"init ssi port...\\n\");\n\n\tif (!ssi->port || !omap_ssi->port) {\n\t\tdev_err(&pd->dev, \"ssi controller not initialized!\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t \n\tfor (port_id = 0; port_id < ssi->num_ports && omap_ssi->port[port_id];\n\t\tport_id++)\n\t\t;\n\n\tif (port_id >= ssi->num_ports) {\n\t\tdev_err(&pd->dev, \"port id out of range!\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tport = ssi->port[port_id];\n\n\tif (!np) {\n\t\tdev_err(&pd->dev, \"missing device tree data\\n\");\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tcawake_gpio = devm_gpiod_get(&pd->dev, \"ti,ssi-cawake\", GPIOD_IN);\n\tif (IS_ERR(cawake_gpio)) {\n\t\terr = PTR_ERR(cawake_gpio);\n\t\tdev_err(&pd->dev, \"couldn't get cawake gpio (err=%d)!\\n\", err);\n\t\tgoto error;\n\t}\n\n\tomap_port = devm_kzalloc(&port->device, sizeof(*omap_port), GFP_KERNEL);\n\tif (!omap_port) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tomap_port->wake_gpio = cawake_gpio;\n\tomap_port->pdev = &pd->dev;\n\tomap_port->port_id = port_id;\n\n\tINIT_DEFERRABLE_WORK(&omap_port->errqueue_work, ssi_process_errqueue);\n\tINIT_WORK(&omap_port->work, start_tx_work);\n\n\t \n\tport->async\t= ssi_async;\n\tport->setup\t= ssi_setup;\n\tport->flush\t= ssi_flush;\n\tport->start_tx\t= ssi_start_tx;\n\tport->stop_tx\t= ssi_stop_tx;\n\tport->release\t= ssi_release;\n\thsi_port_set_drvdata(port, omap_port);\n\tomap_ssi->port[port_id] = omap_port;\n\n\tplatform_set_drvdata(pd, port);\n\n\terr = ssi_port_get_iomem(pd, \"tx\", &omap_port->sst_base,\n\t\t&omap_port->sst_dma);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ssi_port_get_iomem(pd, \"rx\", &omap_port->ssr_base,\n\t\t&omap_port->ssr_dma);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = ssi_port_irq(port, pd);\n\tif (err < 0)\n\t\tgoto error;\n\terr = ssi_wake_irq(port, pd);\n\tif (err < 0)\n\t\tgoto error;\n\n\tssi_queues_init(omap_port);\n\tspin_lock_init(&omap_port->lock);\n\tspin_lock_init(&omap_port->wk_lock);\n\tomap_port->dev = &port->device;\n\n\tpm_runtime_use_autosuspend(omap_port->pdev);\n\tpm_runtime_set_autosuspend_delay(omap_port->pdev, 250);\n\tpm_runtime_enable(omap_port->pdev);\n\n#ifdef CONFIG_DEBUG_FS\n\tssi_debug_add_port(omap_port, omap_ssi->dir);\n#endif\n\n\thsi_add_clients_from_dt(port, np);\n\n\tdev_info(&pd->dev, \"ssi port %u successfully initialized\\n\", port_id);\n\n\treturn 0;\n\nerror:\n\treturn err;\n}\n\nstatic int ssi_port_remove(struct platform_device *pd)\n{\n\tstruct hsi_port *port = platform_get_drvdata(pd);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n#ifdef CONFIG_DEBUG_FS\n\tssi_debug_remove_port(port);\n#endif\n\n\tcancel_delayed_work_sync(&omap_port->errqueue_work);\n\n\thsi_port_unregister_clients(port);\n\n\tport->async\t= hsi_dummy_msg;\n\tport->setup\t= hsi_dummy_cl;\n\tport->flush\t= hsi_dummy_cl;\n\tport->start_tx\t= hsi_dummy_cl;\n\tport->stop_tx\t= hsi_dummy_cl;\n\tport->release\t= hsi_dummy_cl;\n\n\tomap_ssi->port[omap_port->port_id] = NULL;\n\tplatform_set_drvdata(pd, NULL);\n\n\tpm_runtime_dont_use_autosuspend(&pd->dev);\n\tpm_runtime_disable(&pd->dev);\n\n\treturn 0;\n}\n\nstatic int ssi_restore_divisor(struct omap_ssi_port *omap_port)\n{\n\twritel_relaxed(omap_port->sst.divisor,\n\t\t\t\tomap_port->sst_base + SSI_SST_DIVISOR_REG);\n\n\treturn 0;\n}\n\nvoid omap_ssi_port_update_fclk(struct hsi_controller *ssi,\n\t\t\t       struct omap_ssi_port *omap_port)\n{\n\t \n\tu32 div = ssi_calculate_div(ssi);\n\tomap_port->sst.divisor = div;\n\tssi_restore_divisor(omap_port);\n}\n\n#ifdef CONFIG_PM\nstatic int ssi_save_port_ctx(struct omap_ssi_port *omap_port)\n{\n\tstruct hsi_port *port = to_hsi_port(omap_port->dev);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tomap_port->sys_mpu_enable = readl(omap_ssi->sys +\n\t\t\t\t\tSSI_MPU_ENABLE_REG(port->num, 0));\n\n\treturn 0;\n}\n\nstatic int ssi_restore_port_ctx(struct omap_ssi_port *omap_port)\n{\n\tstruct hsi_port *port = to_hsi_port(omap_port->dev);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\tvoid __iomem\t*base;\n\n\twritel_relaxed(omap_port->sys_mpu_enable,\n\t\t\tomap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\n\n\t \n\tbase = omap_port->sst_base;\n\twritel_relaxed(omap_port->sst.frame_size, base + SSI_SST_FRAMESIZE_REG);\n\twritel_relaxed(omap_port->sst.channels, base + SSI_SST_CHANNELS_REG);\n\twritel_relaxed(omap_port->sst.arb_mode, base + SSI_SST_ARBMODE_REG);\n\n\t \n\tbase = omap_port->ssr_base;\n\twritel_relaxed(omap_port->ssr.frame_size, base + SSI_SSR_FRAMESIZE_REG);\n\twritel_relaxed(omap_port->ssr.channels, base + SSI_SSR_CHANNELS_REG);\n\twritel_relaxed(omap_port->ssr.timeout, base + SSI_SSR_TIMEOUT_REG);\n\n\treturn 0;\n}\n\nstatic int ssi_restore_port_mode(struct omap_ssi_port *omap_port)\n{\n\tu32 mode;\n\n\twritel_relaxed(omap_port->sst.mode,\n\t\t\t\tomap_port->sst_base + SSI_SST_MODE_REG);\n\twritel_relaxed(omap_port->ssr.mode,\n\t\t\t\tomap_port->ssr_base + SSI_SSR_MODE_REG);\n\t \n\tmode = readl(omap_port->ssr_base + SSI_SSR_MODE_REG);\n\n\treturn 0;\n}\n\nstatic int omap_ssi_port_runtime_suspend(struct device *dev)\n{\n\tstruct hsi_port *port = dev_get_drvdata(dev);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tdev_dbg(dev, \"port runtime suspend!\\n\");\n\n\tssi_set_port_mode(omap_port, SSI_MODE_SLEEP);\n\tif (omap_ssi->get_loss)\n\t\tomap_port->loss_count =\n\t\t\t\tomap_ssi->get_loss(ssi->device.parent);\n\tssi_save_port_ctx(omap_port);\n\n\treturn 0;\n}\n\nstatic int omap_ssi_port_runtime_resume(struct device *dev)\n{\n\tstruct hsi_port *port = dev_get_drvdata(dev);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\n\tstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\n\n\tdev_dbg(dev, \"port runtime resume!\\n\");\n\n\tif ((omap_ssi->get_loss) && (omap_port->loss_count ==\n\t\t\t\tomap_ssi->get_loss(ssi->device.parent)))\n\t\tgoto mode;  \n\n\tssi_restore_port_ctx(omap_port);\n\nmode:\n\tssi_restore_divisor(omap_port);\n\tssi_restore_port_mode(omap_port);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_ssi_port_pm_ops = {\n\tSET_RUNTIME_PM_OPS(omap_ssi_port_runtime_suspend,\n\t\tomap_ssi_port_runtime_resume, NULL)\n};\n\n#define DEV_PM_OPS     (&omap_ssi_port_pm_ops)\n#else\n#define DEV_PM_OPS     NULL\n#endif\n\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id omap_ssi_port_of_match[] = {\n\t{ .compatible = \"ti,omap3-ssi-port\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_ssi_port_of_match);\n#else\n#define omap_ssi_port_of_match NULL\n#endif\n\nstruct platform_driver ssi_port_pdriver = {\n\t.probe = ssi_port_probe,\n\t.remove\t= ssi_port_remove,\n\t.driver\t= {\n\t\t.name\t= \"omap_ssi_port\",\n\t\t.of_match_table = omap_ssi_port_of_match,\n\t\t.pm\t= DEV_PM_OPS,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}