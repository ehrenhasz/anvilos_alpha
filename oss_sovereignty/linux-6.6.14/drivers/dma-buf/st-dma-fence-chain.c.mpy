{
  "module_name": "st-dma-fence-chain.c",
  "hash_id": "f83cf5bf2e068f15b9017c901748f418e13b09a003cacf6acfa506cec94162d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/st-dma-fence-chain.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/dma-fence.h>\n#include <linux/dma-fence-chain.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/random.h>\n\n#include \"selftest.h\"\n\n#define CHAIN_SZ (4 << 10)\n\nstatic struct kmem_cache *slab_fences;\n\nstatic inline struct mock_fence {\n\tstruct dma_fence base;\n\tspinlock_t lock;\n} *to_mock_fence(struct dma_fence *f) {\n\treturn container_of(f, struct mock_fence, base);\n}\n\nstatic const char *mock_name(struct dma_fence *f)\n{\n\treturn \"mock\";\n}\n\nstatic void mock_fence_release(struct dma_fence *f)\n{\n\tkmem_cache_free(slab_fences, to_mock_fence(f));\n}\n\nstatic const struct dma_fence_ops mock_ops = {\n\t.get_driver_name = mock_name,\n\t.get_timeline_name = mock_name,\n\t.release = mock_fence_release,\n};\n\nstatic struct dma_fence *mock_fence(void)\n{\n\tstruct mock_fence *f;\n\n\tf = kmem_cache_alloc(slab_fences, GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\n\tspin_lock_init(&f->lock);\n\tdma_fence_init(&f->base, &mock_ops, &f->lock, 0, 0);\n\n\treturn &f->base;\n}\n\nstatic struct dma_fence *mock_chain(struct dma_fence *prev,\n\t\t\t\t    struct dma_fence *fence,\n\t\t\t\t    u64 seqno)\n{\n\tstruct dma_fence_chain *f;\n\n\tf = dma_fence_chain_alloc();\n\tif (!f)\n\t\treturn NULL;\n\n\tdma_fence_chain_init(f, dma_fence_get(prev), dma_fence_get(fence),\n\t\t\t     seqno);\n\n\treturn &f->base;\n}\n\nstatic int sanitycheck(void *arg)\n{\n\tstruct dma_fence *f, *chain;\n\tint err = 0;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tchain = mock_chain(NULL, f, 1);\n\tif (!chain)\n\t\terr = -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(chain);\n\n\tdma_fence_signal(f);\n\tdma_fence_put(f);\n\n\tdma_fence_put(chain);\n\n\treturn err;\n}\n\nstruct fence_chains {\n\tunsigned int chain_length;\n\tstruct dma_fence **fences;\n\tstruct dma_fence **chains;\n\n\tstruct dma_fence *tail;\n};\n\nstatic uint64_t seqno_inc(unsigned int i)\n{\n\treturn i + 1;\n}\n\nstatic int fence_chains_init(struct fence_chains *fc, unsigned int count,\n\t\t\t     uint64_t (*seqno_fn)(unsigned int))\n{\n\tunsigned int i;\n\tint err = 0;\n\n\tfc->chains = kvmalloc_array(count, sizeof(*fc->chains),\n\t\t\t\t    GFP_KERNEL | __GFP_ZERO);\n\tif (!fc->chains)\n\t\treturn -ENOMEM;\n\n\tfc->fences = kvmalloc_array(count, sizeof(*fc->fences),\n\t\t\t\t    GFP_KERNEL | __GFP_ZERO);\n\tif (!fc->fences) {\n\t\terr = -ENOMEM;\n\t\tgoto err_chains;\n\t}\n\n\tfc->tail = NULL;\n\tfor (i = 0; i < count; i++) {\n\t\tfc->fences[i] = mock_fence();\n\t\tif (!fc->fences[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfc->chains[i] = mock_chain(fc->tail,\n\t\t\t\t\t   fc->fences[i],\n\t\t\t\t\t   seqno_fn(i));\n\t\tif (!fc->chains[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfc->tail = fc->chains[i];\n\n\t\tdma_fence_enable_sw_signaling(fc->chains[i]);\n\t}\n\n\tfc->chain_length = i;\n\treturn 0;\n\nunwind:\n\tfor (i = 0; i < count; i++) {\n\t\tdma_fence_put(fc->fences[i]);\n\t\tdma_fence_put(fc->chains[i]);\n\t}\n\tkvfree(fc->fences);\nerr_chains:\n\tkvfree(fc->chains);\n\treturn err;\n}\n\nstatic void fence_chains_fini(struct fence_chains *fc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < fc->chain_length; i++) {\n\t\tdma_fence_signal(fc->fences[i]);\n\t\tdma_fence_put(fc->fences[i]);\n\t}\n\tkvfree(fc->fences);\n\n\tfor (i = 0; i < fc->chain_length; i++)\n\t\tdma_fence_put(fc->chains[i]);\n\tkvfree(fc->chains);\n}\n\nstatic int find_seqno(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct dma_fence *fence;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, 64, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\tfence = dma_fence_get(fc.tail);\n\terr = dma_fence_chain_find_seqno(&fence, 0);\n\tdma_fence_put(fence);\n\tif (err) {\n\t\tpr_err(\"Reported %d for find_seqno(0)!\\n\", err);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < fc.chain_length; i++) {\n\t\tfence = dma_fence_get(fc.tail);\n\t\terr = dma_fence_chain_find_seqno(&fence, i + 1);\n\t\tdma_fence_put(fence);\n\t\tif (err) {\n\t\t\tpr_err(\"Reported %d for find_seqno(%d:%d)!\\n\",\n\t\t\t       err, fc.chain_length + 1, i + 1);\n\t\t\tgoto err;\n\t\t}\n\t\tif (fence != fc.chains[i]) {\n\t\t\tpr_err(\"Incorrect fence reported by find_seqno(%d:%d)\\n\",\n\t\t\t       fc.chain_length + 1, i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdma_fence_get(fence);\n\t\terr = dma_fence_chain_find_seqno(&fence, i + 1);\n\t\tdma_fence_put(fence);\n\t\tif (err) {\n\t\t\tpr_err(\"Error reported for finding self\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (fence != fc.chains[i]) {\n\t\t\tpr_err(\"Incorrect fence reported by find self\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdma_fence_get(fence);\n\t\terr = dma_fence_chain_find_seqno(&fence, i + 2);\n\t\tdma_fence_put(fence);\n\t\tif (!err) {\n\t\t\tpr_err(\"Error not reported for future fence: find_seqno(%d:%d)!\\n\",\n\t\t\t       i + 1, i + 2);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdma_fence_get(fence);\n\t\terr = dma_fence_chain_find_seqno(&fence, i);\n\t\tdma_fence_put(fence);\n\t\tif (err) {\n\t\t\tpr_err(\"Error reported for previous fence!\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (i > 0 && fence != fc.chains[i - 1]) {\n\t\t\tpr_err(\"Incorrect fence reported by find_seqno(%d:%d)\\n\",\n\t\t\t       i + 1, i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic int find_signaled(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct dma_fence *fence;\n\tint err;\n\n\terr = fence_chains_init(&fc, 2, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\tdma_fence_signal(fc.fences[0]);\n\n\tfence = dma_fence_get(fc.tail);\n\terr = dma_fence_chain_find_seqno(&fence, 1);\n\tdma_fence_put(fence);\n\tif (err) {\n\t\tpr_err(\"Reported %d for find_seqno()!\\n\", err);\n\t\tgoto err;\n\t}\n\n\tif (fence && fence != fc.chains[0]) {\n\t\tpr_err(\"Incorrect chain-fence.seqno:%lld reported for completed seqno:1\\n\",\n\t\t       fence->seqno);\n\n\t\tdma_fence_get(fence);\n\t\terr = dma_fence_chain_find_seqno(&fence, 1);\n\t\tdma_fence_put(fence);\n\t\tif (err)\n\t\t\tpr_err(\"Reported %d for finding self!\\n\", err);\n\n\t\terr = -EINVAL;\n\t}\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic int find_out_of_order(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct dma_fence *fence;\n\tint err;\n\n\terr = fence_chains_init(&fc, 3, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\tdma_fence_signal(fc.fences[1]);\n\n\tfence = dma_fence_get(fc.tail);\n\terr = dma_fence_chain_find_seqno(&fence, 2);\n\tdma_fence_put(fence);\n\tif (err) {\n\t\tpr_err(\"Reported %d for find_seqno()!\\n\", err);\n\t\tgoto err;\n\t}\n\n\t \n\tif (fence != fc.chains[0]) {\n\t\tpr_err(\"Incorrect chain-fence.seqno:%lld reported for completed seqno:2\\n\",\n\t\t       fence ? fence->seqno : 0);\n\n\t\terr = -EINVAL;\n\t}\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic uint64_t seqno_inc2(unsigned int i)\n{\n\treturn 2 * i + 2;\n}\n\nstatic int find_gap(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct dma_fence *fence;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, 64, seqno_inc2);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < fc.chain_length; i++) {\n\t\tfence = dma_fence_get(fc.tail);\n\t\terr = dma_fence_chain_find_seqno(&fence, 2 * i + 1);\n\t\tdma_fence_put(fence);\n\t\tif (err) {\n\t\t\tpr_err(\"Reported %d for find_seqno(%d:%d)!\\n\",\n\t\t\t       err, fc.chain_length + 1, 2 * i + 1);\n\t\t\tgoto err;\n\t\t}\n\t\tif (fence != fc.chains[i]) {\n\t\t\tpr_err(\"Incorrect fence.seqno:%lld reported by find_seqno(%d:%d)\\n\",\n\t\t\t       fence->seqno,\n\t\t\t       fc.chain_length + 1,\n\t\t\t       2 * i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdma_fence_get(fence);\n\t\terr = dma_fence_chain_find_seqno(&fence, 2 * i + 2);\n\t\tdma_fence_put(fence);\n\t\tif (err) {\n\t\t\tpr_err(\"Error reported for finding self\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (fence != fc.chains[i]) {\n\t\t\tpr_err(\"Incorrect fence reported by find self\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstruct find_race {\n\tstruct fence_chains fc;\n\tatomic_t children;\n};\n\nstatic int __find_race(void *arg)\n{\n\tstruct find_race *data = arg;\n\tint err = 0;\n\n\twhile (!kthread_should_stop()) {\n\t\tstruct dma_fence *fence = dma_fence_get(data->fc.tail);\n\t\tint seqno;\n\n\t\tseqno = get_random_u32_inclusive(1, data->fc.chain_length);\n\n\t\terr = dma_fence_chain_find_seqno(&fence, seqno);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to find fence seqno:%d\\n\",\n\t\t\t       seqno);\n\t\t\tdma_fence_put(fence);\n\t\t\tbreak;\n\t\t}\n\t\tif (!fence)\n\t\t\tgoto signal;\n\n\t\t \n\t\tif (fence->seqno == seqno) {\n\t\t\terr = dma_fence_chain_find_seqno(&fence, seqno);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Reported an invalid fence for find-self:%d\\n\",\n\t\t\t\t       seqno);\n\t\t\t\tdma_fence_put(fence);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdma_fence_put(fence);\n\nsignal:\n\t\tseqno = get_random_u32_below(data->fc.chain_length - 1);\n\t\tdma_fence_signal(data->fc.fences[seqno]);\n\t\tcond_resched();\n\t}\n\n\tif (atomic_dec_and_test(&data->children))\n\t\twake_up_var(&data->children);\n\treturn err;\n}\n\nstatic int find_race(void *arg)\n{\n\tstruct find_race data;\n\tint ncpus = num_online_cpus();\n\tstruct task_struct **threads;\n\tunsigned long count;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&data.fc, CHAIN_SZ, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\tthreads = kmalloc_array(ncpus, sizeof(*threads), GFP_KERNEL);\n\tif (!threads) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tatomic_set(&data.children, 0);\n\tfor (i = 0; i < ncpus; i++) {\n\t\tthreads[i] = kthread_run(__find_race, &data, \"dmabuf/%d\", i);\n\t\tif (IS_ERR(threads[i])) {\n\t\t\tncpus = i;\n\t\t\tbreak;\n\t\t}\n\t\tatomic_inc(&data.children);\n\t\tget_task_struct(threads[i]);\n\t}\n\n\twait_var_event_timeout(&data.children,\n\t\t\t       !atomic_read(&data.children),\n\t\t\t       5 * HZ);\n\n\tfor (i = 0; i < ncpus; i++) {\n\t\tint ret;\n\n\t\tret = kthread_stop(threads[i]);\n\t\tif (ret && !err)\n\t\t\terr = ret;\n\t\tput_task_struct(threads[i]);\n\t}\n\tkfree(threads);\n\n\tcount = 0;\n\tfor (i = 0; i < data.fc.chain_length; i++)\n\t\tif (dma_fence_is_signaled(data.fc.fences[i]))\n\t\t\tcount++;\n\tpr_info(\"Completed %lu cycles\\n\", count);\n\nerr:\n\tfence_chains_fini(&data.fc);\n\treturn err;\n}\n\nstatic int signal_forward(void *arg)\n{\n\tstruct fence_chains fc;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, 64, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < fc.chain_length; i++) {\n\t\tdma_fence_signal(fc.fences[i]);\n\n\t\tif (!dma_fence_is_signaled(fc.chains[i])) {\n\t\t\tpr_err(\"chain[%d] not signaled!\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (i + 1 < fc.chain_length &&\n\t\t    dma_fence_is_signaled(fc.chains[i + 1])) {\n\t\t\tpr_err(\"chain[%d] is signaled!\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic int signal_backward(void *arg)\n{\n\tstruct fence_chains fc;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, 64, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = fc.chain_length; i--; ) {\n\t\tdma_fence_signal(fc.fences[i]);\n\n\t\tif (i > 0 && dma_fence_is_signaled(fc.chains[i])) {\n\t\t\tpr_err(\"chain[%d] is signaled!\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < fc.chain_length; i++) {\n\t\tif (!dma_fence_is_signaled(fc.chains[i])) {\n\t\t\tpr_err(\"chain[%d] was not signaled!\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic int __wait_fence_chains(void *arg)\n{\n\tstruct fence_chains *fc = arg;\n\n\tif (dma_fence_wait(fc->tail, false))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int wait_forward(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct task_struct *tsk;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, CHAIN_SZ, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\ttsk = kthread_run(__wait_fence_chains, &fc, \"dmabuf/wait\");\n\tif (IS_ERR(tsk)) {\n\t\terr = PTR_ERR(tsk);\n\t\tgoto err;\n\t}\n\tget_task_struct(tsk);\n\tyield_to(tsk, true);\n\n\tfor (i = 0; i < fc.chain_length; i++)\n\t\tdma_fence_signal(fc.fences[i]);\n\n\terr = kthread_stop(tsk);\n\tput_task_struct(tsk);\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic int wait_backward(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct task_struct *tsk;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, CHAIN_SZ, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\ttsk = kthread_run(__wait_fence_chains, &fc, \"dmabuf/wait\");\n\tif (IS_ERR(tsk)) {\n\t\terr = PTR_ERR(tsk);\n\t\tgoto err;\n\t}\n\tget_task_struct(tsk);\n\tyield_to(tsk, true);\n\n\tfor (i = fc.chain_length; i--; )\n\t\tdma_fence_signal(fc.fences[i]);\n\n\terr = kthread_stop(tsk);\n\tput_task_struct(tsk);\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nstatic void randomise_fences(struct fence_chains *fc)\n{\n\tunsigned int count = fc->chain_length;\n\n\t \n\twhile (--count) {\n\t\tunsigned int swp;\n\n\t\tswp = get_random_u32_below(count + 1);\n\t\tif (swp == count)\n\t\t\tcontinue;\n\n\t\tswap(fc->fences[count], fc->fences[swp]);\n\t}\n}\n\nstatic int wait_random(void *arg)\n{\n\tstruct fence_chains fc;\n\tstruct task_struct *tsk;\n\tint err;\n\tint i;\n\n\terr = fence_chains_init(&fc, CHAIN_SZ, seqno_inc);\n\tif (err)\n\t\treturn err;\n\n\trandomise_fences(&fc);\n\n\ttsk = kthread_run(__wait_fence_chains, &fc, \"dmabuf/wait\");\n\tif (IS_ERR(tsk)) {\n\t\terr = PTR_ERR(tsk);\n\t\tgoto err;\n\t}\n\tget_task_struct(tsk);\n\tyield_to(tsk, true);\n\n\tfor (i = 0; i < fc.chain_length; i++)\n\t\tdma_fence_signal(fc.fences[i]);\n\n\terr = kthread_stop(tsk);\n\tput_task_struct(tsk);\n\nerr:\n\tfence_chains_fini(&fc);\n\treturn err;\n}\n\nint dma_fence_chain(void)\n{\n\tstatic const struct subtest tests[] = {\n\t\tSUBTEST(sanitycheck),\n\t\tSUBTEST(find_seqno),\n\t\tSUBTEST(find_signaled),\n\t\tSUBTEST(find_out_of_order),\n\t\tSUBTEST(find_gap),\n\t\tSUBTEST(find_race),\n\t\tSUBTEST(signal_forward),\n\t\tSUBTEST(signal_backward),\n\t\tSUBTEST(wait_forward),\n\t\tSUBTEST(wait_backward),\n\t\tSUBTEST(wait_random),\n\t};\n\tint ret;\n\n\tpr_info(\"sizeof(dma_fence_chain)=%zu\\n\",\n\t\tsizeof(struct dma_fence_chain));\n\n\tslab_fences = KMEM_CACHE(mock_fence,\n\t\t\t\t SLAB_TYPESAFE_BY_RCU |\n\t\t\t\t SLAB_HWCACHE_ALIGN);\n\tif (!slab_fences)\n\t\treturn -ENOMEM;\n\n\tret = subtests(tests, NULL);\n\n\tkmem_cache_destroy(slab_fences);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}