{
  "module_name": "sw_sync.c",
  "hash_id": "b9ccb6ef923b1f4a3a8e8ce11cd567f7e42a7a2179f3ef451293c070568ee860",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/sw_sync.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/sync_file.h>\n\n#include \"sync_debug.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"sync_trace.h\"\n\n \nstruct sw_sync_create_fence_data {\n\t__u32\tvalue;\n\tchar\tname[32];\n\t__s32\tfence;  \n};\n\n#define SW_SYNC_IOC_MAGIC\t'W'\n\n#define SW_SYNC_IOC_CREATE_FENCE\t_IOWR(SW_SYNC_IOC_MAGIC, 0,\\\n\t\tstruct sw_sync_create_fence_data)\n\n#define SW_SYNC_IOC_INC\t\t\t_IOW(SW_SYNC_IOC_MAGIC, 1, __u32)\n\nstatic const struct dma_fence_ops timeline_fence_ops;\n\nstatic inline struct sync_pt *dma_fence_to_sync_pt(struct dma_fence *fence)\n{\n\tif (fence->ops != &timeline_fence_ops)\n\t\treturn NULL;\n\treturn container_of(fence, struct sync_pt, base);\n}\n\n \nstatic struct sync_timeline *sync_timeline_create(const char *name)\n{\n\tstruct sync_timeline *obj;\n\n\tobj = kzalloc(sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn NULL;\n\n\tkref_init(&obj->kref);\n\tobj->context = dma_fence_context_alloc(1);\n\tstrscpy(obj->name, name, sizeof(obj->name));\n\n\tobj->pt_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&obj->pt_list);\n\tspin_lock_init(&obj->lock);\n\n\tsync_timeline_debug_add(obj);\n\n\treturn obj;\n}\n\nstatic void sync_timeline_free(struct kref *kref)\n{\n\tstruct sync_timeline *obj =\n\t\tcontainer_of(kref, struct sync_timeline, kref);\n\n\tsync_timeline_debug_remove(obj);\n\n\tkfree(obj);\n}\n\nstatic void sync_timeline_get(struct sync_timeline *obj)\n{\n\tkref_get(&obj->kref);\n}\n\nstatic void sync_timeline_put(struct sync_timeline *obj)\n{\n\tkref_put(&obj->kref, sync_timeline_free);\n}\n\nstatic const char *timeline_fence_get_driver_name(struct dma_fence *fence)\n{\n\treturn \"sw_sync\";\n}\n\nstatic const char *timeline_fence_get_timeline_name(struct dma_fence *fence)\n{\n\tstruct sync_timeline *parent = dma_fence_parent(fence);\n\n\treturn parent->name;\n}\n\nstatic void timeline_fence_release(struct dma_fence *fence)\n{\n\tstruct sync_pt *pt = dma_fence_to_sync_pt(fence);\n\tstruct sync_timeline *parent = dma_fence_parent(fence);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\tif (!list_empty(&pt->link)) {\n\t\tlist_del(&pt->link);\n\t\trb_erase(&pt->node, &parent->pt_tree);\n\t}\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\tsync_timeline_put(parent);\n\tdma_fence_free(fence);\n}\n\nstatic bool timeline_fence_signaled(struct dma_fence *fence)\n{\n\tstruct sync_timeline *parent = dma_fence_parent(fence);\n\n\treturn !__dma_fence_is_later(fence->seqno, parent->value, fence->ops);\n}\n\nstatic bool timeline_fence_enable_signaling(struct dma_fence *fence)\n{\n\treturn true;\n}\n\nstatic void timeline_fence_value_str(struct dma_fence *fence,\n\t\t\t\t    char *str, int size)\n{\n\tsnprintf(str, size, \"%lld\", fence->seqno);\n}\n\nstatic void timeline_fence_timeline_value_str(struct dma_fence *fence,\n\t\t\t\t\t     char *str, int size)\n{\n\tstruct sync_timeline *parent = dma_fence_parent(fence);\n\n\tsnprintf(str, size, \"%d\", parent->value);\n}\n\nstatic const struct dma_fence_ops timeline_fence_ops = {\n\t.get_driver_name = timeline_fence_get_driver_name,\n\t.get_timeline_name = timeline_fence_get_timeline_name,\n\t.enable_signaling = timeline_fence_enable_signaling,\n\t.signaled = timeline_fence_signaled,\n\t.release = timeline_fence_release,\n\t.fence_value_str = timeline_fence_value_str,\n\t.timeline_value_str = timeline_fence_timeline_value_str,\n};\n\n \nstatic void sync_timeline_signal(struct sync_timeline *obj, unsigned int inc)\n{\n\tLIST_HEAD(signalled);\n\tstruct sync_pt *pt, *next;\n\n\ttrace_sync_timeline(obj);\n\n\tspin_lock_irq(&obj->lock);\n\n\tobj->value += inc;\n\n\tlist_for_each_entry_safe(pt, next, &obj->pt_list, link) {\n\t\tif (!timeline_fence_signaled(&pt->base))\n\t\t\tbreak;\n\n\t\tdma_fence_get(&pt->base);\n\n\t\tlist_move_tail(&pt->link, &signalled);\n\t\trb_erase(&pt->node, &obj->pt_tree);\n\n\t\tdma_fence_signal_locked(&pt->base);\n\t}\n\n\tspin_unlock_irq(&obj->lock);\n\n\tlist_for_each_entry_safe(pt, next, &signalled, link) {\n\t\tlist_del_init(&pt->link);\n\t\tdma_fence_put(&pt->base);\n\t}\n}\n\n \nstatic struct sync_pt *sync_pt_create(struct sync_timeline *obj,\n\t\t\t\t      unsigned int value)\n{\n\tstruct sync_pt *pt;\n\n\tpt = kzalloc(sizeof(*pt), GFP_KERNEL);\n\tif (!pt)\n\t\treturn NULL;\n\n\tsync_timeline_get(obj);\n\tdma_fence_init(&pt->base, &timeline_fence_ops, &obj->lock,\n\t\t       obj->context, value);\n\tINIT_LIST_HEAD(&pt->link);\n\n\tspin_lock_irq(&obj->lock);\n\tif (!dma_fence_is_signaled_locked(&pt->base)) {\n\t\tstruct rb_node **p = &obj->pt_tree.rb_node;\n\t\tstruct rb_node *parent = NULL;\n\n\t\twhile (*p) {\n\t\t\tstruct sync_pt *other;\n\t\t\tint cmp;\n\n\t\t\tparent = *p;\n\t\t\tother = rb_entry(parent, typeof(*pt), node);\n\t\t\tcmp = value - other->base.seqno;\n\t\t\tif (cmp > 0) {\n\t\t\t\tp = &parent->rb_right;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tp = &parent->rb_left;\n\t\t\t} else {\n\t\t\t\tif (dma_fence_get_rcu(&other->base)) {\n\t\t\t\t\tsync_timeline_put(obj);\n\t\t\t\t\tkfree(pt);\n\t\t\t\t\tpt = other;\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t\tp = &parent->rb_left;\n\t\t\t}\n\t\t}\n\t\trb_link_node(&pt->node, parent, p);\n\t\trb_insert_color(&pt->node, &obj->pt_tree);\n\n\t\tparent = rb_next(&pt->node);\n\t\tlist_add_tail(&pt->link,\n\t\t\t      parent ? &rb_entry(parent, typeof(*pt), node)->link : &obj->pt_list);\n\t}\nunlock:\n\tspin_unlock_irq(&obj->lock);\n\n\treturn pt;\n}\n\n \n\n \nstatic int sw_sync_debugfs_open(struct inode *inode, struct file *file)\n{\n\tstruct sync_timeline *obj;\n\tchar task_comm[TASK_COMM_LEN];\n\n\tget_task_comm(task_comm, current);\n\n\tobj = sync_timeline_create(task_comm);\n\tif (!obj)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = obj;\n\n\treturn 0;\n}\n\nstatic int sw_sync_debugfs_release(struct inode *inode, struct file *file)\n{\n\tstruct sync_timeline *obj = file->private_data;\n\tstruct sync_pt *pt, *next;\n\n\tspin_lock_irq(&obj->lock);\n\n\tlist_for_each_entry_safe(pt, next, &obj->pt_list, link) {\n\t\tdma_fence_set_error(&pt->base, -ENOENT);\n\t\tdma_fence_signal_locked(&pt->base);\n\t}\n\n\tspin_unlock_irq(&obj->lock);\n\n\tsync_timeline_put(obj);\n\treturn 0;\n}\n\nstatic long sw_sync_ioctl_create_fence(struct sync_timeline *obj,\n\t\t\t\t       unsigned long arg)\n{\n\tint fd = get_unused_fd_flags(O_CLOEXEC);\n\tint err;\n\tstruct sync_pt *pt;\n\tstruct sync_file *sync_file;\n\tstruct sw_sync_create_fence_data data;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (copy_from_user(&data, (void __user *)arg, sizeof(data))) {\n\t\terr = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tpt = sync_pt_create(obj, data.value);\n\tif (!pt) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tsync_file = sync_file_create(&pt->base);\n\tdma_fence_put(&pt->base);\n\tif (!sync_file) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdata.fence = fd;\n\tif (copy_to_user((void __user *)arg, &data, sizeof(data))) {\n\t\tfput(sync_file->file);\n\t\terr = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tfd_install(fd, sync_file->file);\n\n\treturn 0;\n\nerr:\n\tput_unused_fd(fd);\n\treturn err;\n}\n\nstatic long sw_sync_ioctl_inc(struct sync_timeline *obj, unsigned long arg)\n{\n\tu32 value;\n\n\tif (copy_from_user(&value, (void __user *)arg, sizeof(value)))\n\t\treturn -EFAULT;\n\n\twhile (value > INT_MAX)  {\n\t\tsync_timeline_signal(obj, INT_MAX);\n\t\tvalue -= INT_MAX;\n\t}\n\n\tsync_timeline_signal(obj, value);\n\n\treturn 0;\n}\n\nstatic long sw_sync_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct sync_timeline *obj = file->private_data;\n\n\tswitch (cmd) {\n\tcase SW_SYNC_IOC_CREATE_FENCE:\n\t\treturn sw_sync_ioctl_create_fence(obj, arg);\n\n\tcase SW_SYNC_IOC_INC:\n\t\treturn sw_sync_ioctl_inc(obj, arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nconst struct file_operations sw_sync_debugfs_fops = {\n\t.open           = sw_sync_debugfs_open,\n\t.release        = sw_sync_debugfs_release,\n\t.unlocked_ioctl = sw_sync_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}