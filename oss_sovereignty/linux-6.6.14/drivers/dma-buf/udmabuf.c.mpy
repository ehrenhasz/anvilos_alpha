{
  "module_name": "udmabuf.c",
  "hash_id": "7cb4cff838ab657745a2b9c5f964f3a0f060f0557a87a38f2c565c8b2f4dbcb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/udmabuf.c",
  "human_readable_source": "\n#include <linux/cred.h>\n#include <linux/device.h>\n#include <linux/dma-buf.h>\n#include <linux/dma-resv.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/memfd.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/shmem_fs.h>\n#include <linux/slab.h>\n#include <linux/udmabuf.h>\n#include <linux/vmalloc.h>\n#include <linux/iosys-map.h>\n\nstatic int list_limit = 1024;\nmodule_param(list_limit, int, 0644);\nMODULE_PARM_DESC(list_limit, \"udmabuf_create_list->count limit. Default is 1024.\");\n\nstatic int size_limit_mb = 64;\nmodule_param(size_limit_mb, int, 0644);\nMODULE_PARM_DESC(size_limit_mb, \"Max size of a dmabuf, in megabytes. Default is 64.\");\n\nstruct udmabuf {\n\tpgoff_t pagecount;\n\tstruct page **pages;\n\tstruct sg_table *sg;\n\tstruct miscdevice *device;\n};\n\nstatic vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct udmabuf *ubuf = vma->vm_private_data;\n\tpgoff_t pgoff = vmf->pgoff;\n\n\tif (pgoff >= ubuf->pagecount)\n\t\treturn VM_FAULT_SIGBUS;\n\tvmf->page = ubuf->pages[pgoff];\n\tget_page(vmf->page);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct udmabuf_vm_ops = {\n\t.fault = udmabuf_vm_fault,\n};\n\nstatic int mmap_udmabuf(struct dma_buf *buf, struct vm_area_struct *vma)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\n\tif ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &udmabuf_vm_ops;\n\tvma->vm_private_data = ubuf;\n\treturn 0;\n}\n\nstatic int vmap_udmabuf(struct dma_buf *buf, struct iosys_map *map)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\tvoid *vaddr;\n\n\tdma_resv_assert_held(buf->resv);\n\n\tvaddr = vm_map_ram(ubuf->pages, ubuf->pagecount, -1);\n\tif (!vaddr)\n\t\treturn -EINVAL;\n\n\tiosys_map_set_vaddr(map, vaddr);\n\treturn 0;\n}\n\nstatic void vunmap_udmabuf(struct dma_buf *buf, struct iosys_map *map)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\n\tdma_resv_assert_held(buf->resv);\n\n\tvm_unmap_ram(map->vaddr, ubuf->pagecount);\n}\n\nstatic struct sg_table *get_sg_table(struct device *dev, struct dma_buf *buf,\n\t\t\t\t     enum dma_data_direction direction)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\tstruct sg_table *sg;\n\tint ret;\n\n\tsg = kzalloc(sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = sg_alloc_table_from_pages(sg, ubuf->pages, ubuf->pagecount,\n\t\t\t\t\t0, ubuf->pagecount << PAGE_SHIFT,\n\t\t\t\t\tGFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = dma_map_sgtable(dev, sg, direction, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\treturn sg;\n\nerr:\n\tsg_free_table(sg);\n\tkfree(sg);\n\treturn ERR_PTR(ret);\n}\n\nstatic void put_sg_table(struct device *dev, struct sg_table *sg,\n\t\t\t enum dma_data_direction direction)\n{\n\tdma_unmap_sgtable(dev, sg, direction, 0);\n\tsg_free_table(sg);\n\tkfree(sg);\n}\n\nstatic struct sg_table *map_udmabuf(struct dma_buf_attachment *at,\n\t\t\t\t    enum dma_data_direction direction)\n{\n\treturn get_sg_table(at->dev, at->dmabuf, direction);\n}\n\nstatic void unmap_udmabuf(struct dma_buf_attachment *at,\n\t\t\t  struct sg_table *sg,\n\t\t\t  enum dma_data_direction direction)\n{\n\treturn put_sg_table(at->dev, sg, direction);\n}\n\nstatic void release_udmabuf(struct dma_buf *buf)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\tstruct device *dev = ubuf->device->this_device;\n\tpgoff_t pg;\n\n\tif (ubuf->sg)\n\t\tput_sg_table(dev, ubuf->sg, DMA_BIDIRECTIONAL);\n\n\tfor (pg = 0; pg < ubuf->pagecount; pg++)\n\t\tput_page(ubuf->pages[pg]);\n\tkfree(ubuf->pages);\n\tkfree(ubuf);\n}\n\nstatic int begin_cpu_udmabuf(struct dma_buf *buf,\n\t\t\t     enum dma_data_direction direction)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\tstruct device *dev = ubuf->device->this_device;\n\tint ret = 0;\n\n\tif (!ubuf->sg) {\n\t\tubuf->sg = get_sg_table(dev, buf, direction);\n\t\tif (IS_ERR(ubuf->sg)) {\n\t\t\tret = PTR_ERR(ubuf->sg);\n\t\t\tubuf->sg = NULL;\n\t\t}\n\t} else {\n\t\tdma_sync_sg_for_cpu(dev, ubuf->sg->sgl, ubuf->sg->nents,\n\t\t\t\t    direction);\n\t}\n\n\treturn ret;\n}\n\nstatic int end_cpu_udmabuf(struct dma_buf *buf,\n\t\t\t   enum dma_data_direction direction)\n{\n\tstruct udmabuf *ubuf = buf->priv;\n\tstruct device *dev = ubuf->device->this_device;\n\n\tif (!ubuf->sg)\n\t\treturn -EINVAL;\n\n\tdma_sync_sg_for_device(dev, ubuf->sg->sgl, ubuf->sg->nents, direction);\n\treturn 0;\n}\n\nstatic const struct dma_buf_ops udmabuf_ops = {\n\t.cache_sgt_mapping = true,\n\t.map_dma_buf\t   = map_udmabuf,\n\t.unmap_dma_buf\t   = unmap_udmabuf,\n\t.release\t   = release_udmabuf,\n\t.mmap\t\t   = mmap_udmabuf,\n\t.vmap\t\t   = vmap_udmabuf,\n\t.vunmap\t\t   = vunmap_udmabuf,\n\t.begin_cpu_access  = begin_cpu_udmabuf,\n\t.end_cpu_access    = end_cpu_udmabuf,\n};\n\n#define SEALS_WANTED (F_SEAL_SHRINK)\n#define SEALS_DENIED (F_SEAL_WRITE)\n\nstatic long udmabuf_create(struct miscdevice *device,\n\t\t\t   struct udmabuf_create_list *head,\n\t\t\t   struct udmabuf_create_item *list)\n{\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\tstruct file *memfd = NULL;\n\tstruct address_space *mapping = NULL;\n\tstruct udmabuf *ubuf;\n\tstruct dma_buf *buf;\n\tpgoff_t pgoff, pgcnt, pgidx, pgbuf = 0, pglimit;\n\tstruct page *page;\n\tint seals, ret = -EINVAL;\n\tu32 i, flags;\n\n\tubuf = kzalloc(sizeof(*ubuf), GFP_KERNEL);\n\tif (!ubuf)\n\t\treturn -ENOMEM;\n\n\tpglimit = (size_limit_mb * 1024 * 1024) >> PAGE_SHIFT;\n\tfor (i = 0; i < head->count; i++) {\n\t\tif (!IS_ALIGNED(list[i].offset, PAGE_SIZE))\n\t\t\tgoto err;\n\t\tif (!IS_ALIGNED(list[i].size, PAGE_SIZE))\n\t\t\tgoto err;\n\t\tubuf->pagecount += list[i].size >> PAGE_SHIFT;\n\t\tif (ubuf->pagecount > pglimit)\n\t\t\tgoto err;\n\t}\n\n\tif (!ubuf->pagecount)\n\t\tgoto err;\n\n\tubuf->pages = kmalloc_array(ubuf->pagecount, sizeof(*ubuf->pages),\n\t\t\t\t    GFP_KERNEL);\n\tif (!ubuf->pages) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tpgbuf = 0;\n\tfor (i = 0; i < head->count; i++) {\n\t\tret = -EBADFD;\n\t\tmemfd = fget(list[i].memfd);\n\t\tif (!memfd)\n\t\t\tgoto err;\n\t\tmapping = memfd->f_mapping;\n\t\tif (!shmem_mapping(mapping))\n\t\t\tgoto err;\n\t\tseals = memfd_fcntl(memfd, F_GET_SEALS, 0);\n\t\tif (seals == -EINVAL)\n\t\t\tgoto err;\n\t\tret = -EINVAL;\n\t\tif ((seals & SEALS_WANTED) != SEALS_WANTED ||\n\t\t    (seals & SEALS_DENIED) != 0)\n\t\t\tgoto err;\n\t\tpgoff = list[i].offset >> PAGE_SHIFT;\n\t\tpgcnt = list[i].size   >> PAGE_SHIFT;\n\t\tfor (pgidx = 0; pgidx < pgcnt; pgidx++) {\n\t\t\tpage = shmem_read_mapping_page(mapping, pgoff + pgidx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tret = PTR_ERR(page);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tubuf->pages[pgbuf++] = page;\n\t\t}\n\t\tfput(memfd);\n\t\tmemfd = NULL;\n\t}\n\n\texp_info.ops  = &udmabuf_ops;\n\texp_info.size = ubuf->pagecount << PAGE_SHIFT;\n\texp_info.priv = ubuf;\n\texp_info.flags = O_RDWR;\n\n\tubuf->device = device;\n\tbuf = dma_buf_export(&exp_info);\n\tif (IS_ERR(buf)) {\n\t\tret = PTR_ERR(buf);\n\t\tgoto err;\n\t}\n\n\tflags = 0;\n\tif (head->flags & UDMABUF_FLAGS_CLOEXEC)\n\t\tflags |= O_CLOEXEC;\n\treturn dma_buf_fd(buf, flags);\n\nerr:\n\twhile (pgbuf > 0)\n\t\tput_page(ubuf->pages[--pgbuf]);\n\tif (memfd)\n\t\tfput(memfd);\n\tkfree(ubuf->pages);\n\tkfree(ubuf);\n\treturn ret;\n}\n\nstatic long udmabuf_ioctl_create(struct file *filp, unsigned long arg)\n{\n\tstruct udmabuf_create create;\n\tstruct udmabuf_create_list head;\n\tstruct udmabuf_create_item list;\n\n\tif (copy_from_user(&create, (void __user *)arg,\n\t\t\t   sizeof(create)))\n\t\treturn -EFAULT;\n\n\thead.flags  = create.flags;\n\thead.count  = 1;\n\tlist.memfd  = create.memfd;\n\tlist.offset = create.offset;\n\tlist.size   = create.size;\n\n\treturn udmabuf_create(filp->private_data, &head, &list);\n}\n\nstatic long udmabuf_ioctl_create_list(struct file *filp, unsigned long arg)\n{\n\tstruct udmabuf_create_list head;\n\tstruct udmabuf_create_item *list;\n\tint ret = -EINVAL;\n\tu32 lsize;\n\n\tif (copy_from_user(&head, (void __user *)arg, sizeof(head)))\n\t\treturn -EFAULT;\n\tif (head.count > list_limit)\n\t\treturn -EINVAL;\n\tlsize = sizeof(struct udmabuf_create_item) * head.count;\n\tlist = memdup_user((void __user *)(arg + sizeof(head)), lsize);\n\tif (IS_ERR(list))\n\t\treturn PTR_ERR(list);\n\n\tret = udmabuf_create(filp->private_data, &head, list);\n\tkfree(list);\n\treturn ret;\n}\n\nstatic long udmabuf_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\t  unsigned long arg)\n{\n\tlong ret;\n\n\tswitch (ioctl) {\n\tcase UDMABUF_CREATE:\n\t\tret = udmabuf_ioctl_create(filp, arg);\n\t\tbreak;\n\tcase UDMABUF_CREATE_LIST:\n\t\tret = udmabuf_ioctl_create_list(filp, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations udmabuf_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl = udmabuf_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = udmabuf_ioctl,\n#endif\n};\n\nstatic struct miscdevice udmabuf_misc = {\n\t.minor          = MISC_DYNAMIC_MINOR,\n\t.name           = \"udmabuf\",\n\t.fops           = &udmabuf_fops,\n};\n\nstatic int __init udmabuf_dev_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&udmabuf_misc);\n\tif (ret < 0) {\n\t\tpr_err(\"Could not initialize udmabuf device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dma_coerce_mask_and_coherent(udmabuf_misc.this_device,\n\t\t\t\t\t   DMA_BIT_MASK(64));\n\tif (ret < 0) {\n\t\tpr_err(\"Could not setup DMA mask for udmabuf device\\n\");\n\t\tmisc_deregister(&udmabuf_misc);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit udmabuf_dev_exit(void)\n{\n\tmisc_deregister(&udmabuf_misc);\n}\n\nmodule_init(udmabuf_dev_init)\nmodule_exit(udmabuf_dev_exit)\n\nMODULE_AUTHOR(\"Gerd Hoffmann <kraxel@redhat.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}