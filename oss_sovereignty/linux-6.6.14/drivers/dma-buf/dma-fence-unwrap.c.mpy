{
  "module_name": "dma-fence-unwrap.c",
  "hash_id": "71596e177a74c3c08d5685af332a880c16eafc16ce93f1314e7b45c5718e7d32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/dma-fence-unwrap.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence.h>\n#include <linux/dma-fence-array.h>\n#include <linux/dma-fence-chain.h>\n#include <linux/dma-fence-unwrap.h>\n#include <linux/slab.h>\n\n \nstatic struct dma_fence *\n__dma_fence_unwrap_array(struct dma_fence_unwrap *cursor)\n{\n\tcursor->array = dma_fence_chain_contained(cursor->chain);\n\tcursor->index = 0;\n\treturn dma_fence_array_first(cursor->array);\n}\n\n \nstruct dma_fence *dma_fence_unwrap_first(struct dma_fence *head,\n\t\t\t\t\t struct dma_fence_unwrap *cursor)\n{\n\tcursor->chain = dma_fence_get(head);\n\treturn __dma_fence_unwrap_array(cursor);\n}\nEXPORT_SYMBOL_GPL(dma_fence_unwrap_first);\n\n \nstruct dma_fence *dma_fence_unwrap_next(struct dma_fence_unwrap *cursor)\n{\n\tstruct dma_fence *tmp;\n\n\t++cursor->index;\n\ttmp = dma_fence_array_next(cursor->array, cursor->index);\n\tif (tmp)\n\t\treturn tmp;\n\n\tcursor->chain = dma_fence_chain_walk(cursor->chain);\n\treturn __dma_fence_unwrap_array(cursor);\n}\nEXPORT_SYMBOL_GPL(dma_fence_unwrap_next);\n\n \nstruct dma_fence *__dma_fence_unwrap_merge(unsigned int num_fences,\n\t\t\t\t\t   struct dma_fence **fences,\n\t\t\t\t\t   struct dma_fence_unwrap *iter)\n{\n\tstruct dma_fence_array *result;\n\tstruct dma_fence *tmp, **array;\n\tktime_t timestamp;\n\tunsigned int i;\n\tsize_t count;\n\n\tcount = 0;\n\ttimestamp = ns_to_ktime(0);\n\tfor (i = 0; i < num_fences; ++i) {\n\t\tdma_fence_unwrap_for_each(tmp, &iter[i], fences[i]) {\n\t\t\tif (!dma_fence_is_signaled(tmp)) {\n\t\t\t\t++count;\n\t\t\t} else {\n\t\t\t\tktime_t t = dma_fence_timestamp(tmp);\n\n\t\t\t\tif (ktime_after(t, timestamp))\n\t\t\t\t\ttimestamp = t;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (count == 0)\n\t\treturn dma_fence_allocate_private_stub(timestamp);\n\n\tarray = kmalloc_array(count, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn NULL;\n\n\t \n\tfor (i = 0; i < num_fences; ++i)\n\t\tfences[i] = dma_fence_unwrap_first(fences[i], &iter[i]);\n\n\tcount = 0;\n\tdo {\n\t\tunsigned int sel;\n\nrestart:\n\t\ttmp = NULL;\n\t\tfor (i = 0; i < num_fences; ++i) {\n\t\t\tstruct dma_fence *next;\n\n\t\t\twhile (fences[i] && dma_fence_is_signaled(fences[i]))\n\t\t\t\tfences[i] = dma_fence_unwrap_next(&iter[i]);\n\n\t\t\tnext = fences[i];\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!tmp || tmp->context > next->context) {\n\t\t\t\ttmp = next;\n\t\t\t\tsel = i;\n\n\t\t\t} else if (tmp->context < next->context) {\n\t\t\t\tcontinue;\n\n\t\t\t} else if (dma_fence_is_later(tmp, next)) {\n\t\t\t\tfences[i] = dma_fence_unwrap_next(&iter[i]);\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tfences[sel] = dma_fence_unwrap_next(&iter[sel]);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\tarray[count++] = dma_fence_get(tmp);\n\t\t\tfences[sel] = dma_fence_unwrap_next(&iter[sel]);\n\t\t}\n\t} while (tmp);\n\n\tif (count == 0) {\n\t\ttmp = dma_fence_allocate_private_stub(ktime_get());\n\t\tgoto return_tmp;\n\t}\n\n\tif (count == 1) {\n\t\ttmp = array[0];\n\t\tgoto return_tmp;\n\t}\n\n\tresult = dma_fence_array_create(count, array,\n\t\t\t\t\tdma_fence_context_alloc(1),\n\t\t\t\t\t1, false);\n\tif (!result) {\n\t\ttmp = NULL;\n\t\tgoto return_tmp;\n\t}\n\treturn &result->base;\n\nreturn_tmp:\n\tkfree(array);\n\treturn tmp;\n}\nEXPORT_SYMBOL_GPL(__dma_fence_unwrap_merge);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}