{
  "module_name": "dma-fence-chain.c",
  "hash_id": "914610f7d827d32710f5f54a802b60109824ca462b15212590dc5c46e1b8ac86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/dma-fence-chain.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence-chain.h>\n\nstatic bool dma_fence_chain_enable_signaling(struct dma_fence *fence);\n\n \nstatic struct dma_fence *dma_fence_chain_get_prev(struct dma_fence_chain *chain)\n{\n\tstruct dma_fence *prev;\n\n\trcu_read_lock();\n\tprev = dma_fence_get_rcu_safe(&chain->prev);\n\trcu_read_unlock();\n\treturn prev;\n}\n\n \nstruct dma_fence *dma_fence_chain_walk(struct dma_fence *fence)\n{\n\tstruct dma_fence_chain *chain, *prev_chain;\n\tstruct dma_fence *prev, *replacement, *tmp;\n\n\tchain = to_dma_fence_chain(fence);\n\tif (!chain) {\n\t\tdma_fence_put(fence);\n\t\treturn NULL;\n\t}\n\n\twhile ((prev = dma_fence_chain_get_prev(chain))) {\n\n\t\tprev_chain = to_dma_fence_chain(prev);\n\t\tif (prev_chain) {\n\t\t\tif (!dma_fence_is_signaled(prev_chain->fence))\n\t\t\t\tbreak;\n\n\t\t\treplacement = dma_fence_chain_get_prev(prev_chain);\n\t\t} else {\n\t\t\tif (!dma_fence_is_signaled(prev))\n\t\t\t\tbreak;\n\n\t\t\treplacement = NULL;\n\t\t}\n\n\t\ttmp = unrcu_pointer(cmpxchg(&chain->prev, RCU_INITIALIZER(prev),\n\t\t\t\t\t     RCU_INITIALIZER(replacement)));\n\t\tif (tmp == prev)\n\t\t\tdma_fence_put(tmp);\n\t\telse\n\t\t\tdma_fence_put(replacement);\n\t\tdma_fence_put(prev);\n\t}\n\n\tdma_fence_put(fence);\n\treturn prev;\n}\nEXPORT_SYMBOL(dma_fence_chain_walk);\n\n \nint dma_fence_chain_find_seqno(struct dma_fence **pfence, uint64_t seqno)\n{\n\tstruct dma_fence_chain *chain;\n\n\tif (!seqno)\n\t\treturn 0;\n\n\tchain = to_dma_fence_chain(*pfence);\n\tif (!chain || chain->base.seqno < seqno)\n\t\treturn -EINVAL;\n\n\tdma_fence_chain_for_each(*pfence, &chain->base) {\n\t\tif ((*pfence)->context != chain->base.context ||\n\t\t    to_dma_fence_chain(*pfence)->prev_seqno < seqno)\n\t\t\tbreak;\n\t}\n\tdma_fence_put(&chain->base);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dma_fence_chain_find_seqno);\n\nstatic const char *dma_fence_chain_get_driver_name(struct dma_fence *fence)\n{\n        return \"dma_fence_chain\";\n}\n\nstatic const char *dma_fence_chain_get_timeline_name(struct dma_fence *fence)\n{\n        return \"unbound\";\n}\n\nstatic void dma_fence_chain_irq_work(struct irq_work *work)\n{\n\tstruct dma_fence_chain *chain;\n\n\tchain = container_of(work, typeof(*chain), work);\n\n\t \n\tif (!dma_fence_chain_enable_signaling(&chain->base))\n\t\t \n\t\tdma_fence_signal(&chain->base);\n\tdma_fence_put(&chain->base);\n}\n\nstatic void dma_fence_chain_cb(struct dma_fence *f, struct dma_fence_cb *cb)\n{\n\tstruct dma_fence_chain *chain;\n\n\tchain = container_of(cb, typeof(*chain), cb);\n\tinit_irq_work(&chain->work, dma_fence_chain_irq_work);\n\tirq_work_queue(&chain->work);\n\tdma_fence_put(f);\n}\n\nstatic bool dma_fence_chain_enable_signaling(struct dma_fence *fence)\n{\n\tstruct dma_fence_chain *head = to_dma_fence_chain(fence);\n\n\tdma_fence_get(&head->base);\n\tdma_fence_chain_for_each(fence, &head->base) {\n\t\tstruct dma_fence *f = dma_fence_chain_contained(fence);\n\n\t\tdma_fence_get(f);\n\t\tif (!dma_fence_add_callback(f, &head->cb, dma_fence_chain_cb)) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn true;\n\t\t}\n\t\tdma_fence_put(f);\n\t}\n\tdma_fence_put(&head->base);\n\treturn false;\n}\n\nstatic bool dma_fence_chain_signaled(struct dma_fence *fence)\n{\n\tdma_fence_chain_for_each(fence, fence) {\n\t\tstruct dma_fence *f = dma_fence_chain_contained(fence);\n\n\t\tif (!dma_fence_is_signaled(f)) {\n\t\t\tdma_fence_put(fence);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void dma_fence_chain_release(struct dma_fence *fence)\n{\n\tstruct dma_fence_chain *chain = to_dma_fence_chain(fence);\n\tstruct dma_fence *prev;\n\n\t \n\twhile ((prev = rcu_dereference_protected(chain->prev, true))) {\n\t\tstruct dma_fence_chain *prev_chain;\n\n\t\tif (kref_read(&prev->refcount) > 1)\n\t\t       break;\n\n\t\tprev_chain = to_dma_fence_chain(prev);\n\t\tif (!prev_chain)\n\t\t\tbreak;\n\n\t\t \n\t\tchain->prev = prev_chain->prev;\n\t\tRCU_INIT_POINTER(prev_chain->prev, NULL);\n\t\tdma_fence_put(prev);\n\t}\n\tdma_fence_put(prev);\n\n\tdma_fence_put(chain->fence);\n\tdma_fence_free(fence);\n}\n\n\nstatic void dma_fence_chain_set_deadline(struct dma_fence *fence,\n\t\t\t\t\t ktime_t deadline)\n{\n\tdma_fence_chain_for_each(fence, fence) {\n\t\tstruct dma_fence *f = dma_fence_chain_contained(fence);\n\n\t\tdma_fence_set_deadline(f, deadline);\n\t}\n}\n\nconst struct dma_fence_ops dma_fence_chain_ops = {\n\t.use_64bit_seqno = true,\n\t.get_driver_name = dma_fence_chain_get_driver_name,\n\t.get_timeline_name = dma_fence_chain_get_timeline_name,\n\t.enable_signaling = dma_fence_chain_enable_signaling,\n\t.signaled = dma_fence_chain_signaled,\n\t.release = dma_fence_chain_release,\n\t.set_deadline = dma_fence_chain_set_deadline,\n};\nEXPORT_SYMBOL(dma_fence_chain_ops);\n\n \nvoid dma_fence_chain_init(struct dma_fence_chain *chain,\n\t\t\t  struct dma_fence *prev,\n\t\t\t  struct dma_fence *fence,\n\t\t\t  uint64_t seqno)\n{\n\tstruct dma_fence_chain *prev_chain = to_dma_fence_chain(prev);\n\tuint64_t context;\n\n\tspin_lock_init(&chain->lock);\n\trcu_assign_pointer(chain->prev, prev);\n\tchain->fence = fence;\n\tchain->prev_seqno = 0;\n\n\t \n\tif (prev_chain && __dma_fence_is_later(seqno, prev->seqno, prev->ops)) {\n\t\tcontext = prev->context;\n\t\tchain->prev_seqno = prev->seqno;\n\t} else {\n\t\tcontext = dma_fence_context_alloc(1);\n\t\t \n\t\tif (prev_chain)\n\t\t\tseqno = max(prev->seqno, seqno);\n\t}\n\n\tdma_fence_init(&chain->base, &dma_fence_chain_ops,\n\t\t       &chain->lock, context, seqno);\n\n\t \n\tWARN_ON(dma_fence_is_chain(fence));\n}\nEXPORT_SYMBOL(dma_fence_chain_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}