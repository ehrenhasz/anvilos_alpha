{
  "module_name": "dma-resv.c",
  "hash_id": "b8917b4a4d1424c447386125a18c1d118d32e96bf9903481b36631137f737523",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/dma-resv.c",
  "human_readable_source": "\n \n \n\n#include <linux/dma-resv.h>\n#include <linux/dma-fence-array.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/seq_file.h>\n\n \n\nDEFINE_WD_CLASS(reservation_ww_class);\nEXPORT_SYMBOL(reservation_ww_class);\n\n \n#define DMA_RESV_LIST_MASK\t0x3\n\nstruct dma_resv_list {\n\tstruct rcu_head rcu;\n\tu32 num_fences, max_fences;\n\tstruct dma_fence __rcu *table[];\n};\n\n \nstatic void dma_resv_list_entry(struct dma_resv_list *list, unsigned int index,\n\t\t\t\tstruct dma_resv *resv, struct dma_fence **fence,\n\t\t\t\tenum dma_resv_usage *usage)\n{\n\tlong tmp;\n\n\ttmp = (long)rcu_dereference_check(list->table[index],\n\t\t\t\t\t  resv ? dma_resv_held(resv) : true);\n\t*fence = (struct dma_fence *)(tmp & ~DMA_RESV_LIST_MASK);\n\tif (usage)\n\t\t*usage = tmp & DMA_RESV_LIST_MASK;\n}\n\n \nstatic void dma_resv_list_set(struct dma_resv_list *list,\n\t\t\t      unsigned int index,\n\t\t\t      struct dma_fence *fence,\n\t\t\t      enum dma_resv_usage usage)\n{\n\tlong tmp = ((long)fence) | usage;\n\n\tRCU_INIT_POINTER(list->table[index], (struct dma_fence *)tmp);\n}\n\n \nstatic struct dma_resv_list *dma_resv_list_alloc(unsigned int max_fences)\n{\n\tstruct dma_resv_list *list;\n\tsize_t size;\n\n\t \n\tsize = kmalloc_size_roundup(struct_size(list, table, max_fences));\n\n\tlist = kmalloc(size, GFP_KERNEL);\n\tif (!list)\n\t\treturn NULL;\n\n\t \n\tlist->max_fences = (size - offsetof(typeof(*list), table)) /\n\t\tsizeof(*list->table);\n\n\treturn list;\n}\n\n \nstatic void dma_resv_list_free(struct dma_resv_list *list)\n{\n\tunsigned int i;\n\n\tif (!list)\n\t\treturn;\n\n\tfor (i = 0; i < list->num_fences; ++i) {\n\t\tstruct dma_fence *fence;\n\n\t\tdma_resv_list_entry(list, i, NULL, &fence, NULL);\n\t\tdma_fence_put(fence);\n\t}\n\tkfree_rcu(list, rcu);\n}\n\n \nvoid dma_resv_init(struct dma_resv *obj)\n{\n\tww_mutex_init(&obj->lock, &reservation_ww_class);\n\n\tRCU_INIT_POINTER(obj->fences, NULL);\n}\nEXPORT_SYMBOL(dma_resv_init);\n\n \nvoid dma_resv_fini(struct dma_resv *obj)\n{\n\t \n\tdma_resv_list_free(rcu_dereference_protected(obj->fences, true));\n\tww_mutex_destroy(&obj->lock);\n}\nEXPORT_SYMBOL(dma_resv_fini);\n\n \nstatic inline struct dma_resv_list *dma_resv_fences_list(struct dma_resv *obj)\n{\n\treturn rcu_dereference_check(obj->fences, dma_resv_held(obj));\n}\n\n \nint dma_resv_reserve_fences(struct dma_resv *obj, unsigned int num_fences)\n{\n\tstruct dma_resv_list *old, *new;\n\tunsigned int i, j, k, max;\n\n\tdma_resv_assert_held(obj);\n\n\told = dma_resv_fences_list(obj);\n\tif (old && old->max_fences) {\n\t\tif ((old->num_fences + num_fences) <= old->max_fences)\n\t\t\treturn 0;\n\t\tmax = max(old->num_fences + num_fences, old->max_fences * 2);\n\t} else {\n\t\tmax = max(4ul, roundup_pow_of_two(num_fences));\n\t}\n\n\tnew = dma_resv_list_alloc(max);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0, j = 0, k = max; i < (old ? old->num_fences : 0); ++i) {\n\t\tenum dma_resv_usage usage;\n\t\tstruct dma_fence *fence;\n\n\t\tdma_resv_list_entry(old, i, obj, &fence, &usage);\n\t\tif (dma_fence_is_signaled(fence))\n\t\t\tRCU_INIT_POINTER(new->table[--k], fence);\n\t\telse\n\t\t\tdma_resv_list_set(new, j++, fence, usage);\n\t}\n\tnew->num_fences = j;\n\n\t \n\trcu_assign_pointer(obj->fences, new);\n\n\tif (!old)\n\t\treturn 0;\n\n\t \n\tfor (i = k; i < max; ++i) {\n\t\tstruct dma_fence *fence;\n\n\t\tfence = rcu_dereference_protected(new->table[i],\n\t\t\t\t\t\t  dma_resv_held(obj));\n\t\tdma_fence_put(fence);\n\t}\n\tkfree_rcu(old, rcu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dma_resv_reserve_fences);\n\n#ifdef CONFIG_DEBUG_MUTEXES\n \nvoid dma_resv_reset_max_fences(struct dma_resv *obj)\n{\n\tstruct dma_resv_list *fences = dma_resv_fences_list(obj);\n\n\tdma_resv_assert_held(obj);\n\n\t \n\tif (fences)\n\t\tfences->max_fences = fences->num_fences;\n}\nEXPORT_SYMBOL(dma_resv_reset_max_fences);\n#endif\n\n \nvoid dma_resv_add_fence(struct dma_resv *obj, struct dma_fence *fence,\n\t\t\tenum dma_resv_usage usage)\n{\n\tstruct dma_resv_list *fobj;\n\tstruct dma_fence *old;\n\tunsigned int i, count;\n\n\tdma_fence_get(fence);\n\n\tdma_resv_assert_held(obj);\n\n\t \n\tWARN_ON(dma_fence_is_container(fence));\n\n\tfobj = dma_resv_fences_list(obj);\n\tcount = fobj->num_fences;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tenum dma_resv_usage old_usage;\n\n\t\tdma_resv_list_entry(fobj, i, obj, &old, &old_usage);\n\t\tif ((old->context == fence->context && old_usage >= usage &&\n\t\t     dma_fence_is_later_or_same(fence, old)) ||\n\t\t    dma_fence_is_signaled(old)) {\n\t\t\tdma_resv_list_set(fobj, i, fence, usage);\n\t\t\tdma_fence_put(old);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tBUG_ON(fobj->num_fences >= fobj->max_fences);\n\tcount++;\n\n\tdma_resv_list_set(fobj, i, fence, usage);\n\t \n\tsmp_store_mb(fobj->num_fences, count);\n}\nEXPORT_SYMBOL(dma_resv_add_fence);\n\n \nvoid dma_resv_replace_fences(struct dma_resv *obj, uint64_t context,\n\t\t\t     struct dma_fence *replacement,\n\t\t\t     enum dma_resv_usage usage)\n{\n\tstruct dma_resv_list *list;\n\tunsigned int i;\n\n\tdma_resv_assert_held(obj);\n\n\tlist = dma_resv_fences_list(obj);\n\tfor (i = 0; list && i < list->num_fences; ++i) {\n\t\tstruct dma_fence *old;\n\n\t\tdma_resv_list_entry(list, i, obj, &old, NULL);\n\t\tif (old->context != context)\n\t\t\tcontinue;\n\n\t\tdma_resv_list_set(list, i, dma_fence_get(replacement), usage);\n\t\tdma_fence_put(old);\n\t}\n}\nEXPORT_SYMBOL(dma_resv_replace_fences);\n\n \nstatic void dma_resv_iter_restart_unlocked(struct dma_resv_iter *cursor)\n{\n\tcursor->index = 0;\n\tcursor->num_fences = 0;\n\tcursor->fences = dma_resv_fences_list(cursor->obj);\n\tif (cursor->fences)\n\t\tcursor->num_fences = cursor->fences->num_fences;\n\tcursor->is_restarted = true;\n}\n\n \nstatic void dma_resv_iter_walk_unlocked(struct dma_resv_iter *cursor)\n{\n\tif (!cursor->fences)\n\t\treturn;\n\n\tdo {\n\t\t \n\t\tdma_fence_put(cursor->fence);\n\n\t\tif (cursor->index >= cursor->num_fences) {\n\t\t\tcursor->fence = NULL;\n\t\t\tbreak;\n\n\t\t}\n\n\t\tdma_resv_list_entry(cursor->fences, cursor->index++,\n\t\t\t\t    cursor->obj, &cursor->fence,\n\t\t\t\t    &cursor->fence_usage);\n\t\tcursor->fence = dma_fence_get_rcu(cursor->fence);\n\t\tif (!cursor->fence) {\n\t\t\tdma_resv_iter_restart_unlocked(cursor);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!dma_fence_is_signaled(cursor->fence) &&\n\t\t    cursor->usage >= cursor->fence_usage)\n\t\t\tbreak;\n\t} while (true);\n}\n\n \nstruct dma_fence *dma_resv_iter_first_unlocked(struct dma_resv_iter *cursor)\n{\n\trcu_read_lock();\n\tdo {\n\t\tdma_resv_iter_restart_unlocked(cursor);\n\t\tdma_resv_iter_walk_unlocked(cursor);\n\t} while (dma_resv_fences_list(cursor->obj) != cursor->fences);\n\trcu_read_unlock();\n\n\treturn cursor->fence;\n}\nEXPORT_SYMBOL(dma_resv_iter_first_unlocked);\n\n \nstruct dma_fence *dma_resv_iter_next_unlocked(struct dma_resv_iter *cursor)\n{\n\tbool restart;\n\n\trcu_read_lock();\n\tcursor->is_restarted = false;\n\trestart = dma_resv_fences_list(cursor->obj) != cursor->fences;\n\tdo {\n\t\tif (restart)\n\t\t\tdma_resv_iter_restart_unlocked(cursor);\n\t\tdma_resv_iter_walk_unlocked(cursor);\n\t\trestart = true;\n\t} while (dma_resv_fences_list(cursor->obj) != cursor->fences);\n\trcu_read_unlock();\n\n\treturn cursor->fence;\n}\nEXPORT_SYMBOL(dma_resv_iter_next_unlocked);\n\n \nstruct dma_fence *dma_resv_iter_first(struct dma_resv_iter *cursor)\n{\n\tstruct dma_fence *fence;\n\n\tdma_resv_assert_held(cursor->obj);\n\n\tcursor->index = 0;\n\tcursor->fences = dma_resv_fences_list(cursor->obj);\n\n\tfence = dma_resv_iter_next(cursor);\n\tcursor->is_restarted = true;\n\treturn fence;\n}\nEXPORT_SYMBOL_GPL(dma_resv_iter_first);\n\n \nstruct dma_fence *dma_resv_iter_next(struct dma_resv_iter *cursor)\n{\n\tstruct dma_fence *fence;\n\n\tdma_resv_assert_held(cursor->obj);\n\n\tcursor->is_restarted = false;\n\n\tdo {\n\t\tif (!cursor->fences ||\n\t\t    cursor->index >= cursor->fences->num_fences)\n\t\t\treturn NULL;\n\n\t\tdma_resv_list_entry(cursor->fences, cursor->index++,\n\t\t\t\t    cursor->obj, &fence, &cursor->fence_usage);\n\t} while (cursor->fence_usage > cursor->usage);\n\n\treturn fence;\n}\nEXPORT_SYMBOL_GPL(dma_resv_iter_next);\n\n \nint dma_resv_copy_fences(struct dma_resv *dst, struct dma_resv *src)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_resv_list *list;\n\tstruct dma_fence *f;\n\n\tdma_resv_assert_held(dst);\n\n\tlist = NULL;\n\n\tdma_resv_iter_begin(&cursor, src, DMA_RESV_USAGE_BOOKKEEP);\n\tdma_resv_for_each_fence_unlocked(&cursor, f) {\n\n\t\tif (dma_resv_iter_is_restarted(&cursor)) {\n\t\t\tdma_resv_list_free(list);\n\n\t\t\tlist = dma_resv_list_alloc(cursor.num_fences);\n\t\t\tif (!list) {\n\t\t\t\tdma_resv_iter_end(&cursor);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tlist->num_fences = 0;\n\t\t}\n\n\t\tdma_fence_get(f);\n\t\tdma_resv_list_set(list, list->num_fences++, f,\n\t\t\t\t  dma_resv_iter_usage(&cursor));\n\t}\n\tdma_resv_iter_end(&cursor);\n\n\tlist = rcu_replace_pointer(dst->fences, list, dma_resv_held(dst));\n\tdma_resv_list_free(list);\n\treturn 0;\n}\nEXPORT_SYMBOL(dma_resv_copy_fences);\n\n \nint dma_resv_get_fences(struct dma_resv *obj, enum dma_resv_usage usage,\n\t\t\tunsigned int *num_fences, struct dma_fence ***fences)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\t*num_fences = 0;\n\t*fences = NULL;\n\n\tdma_resv_iter_begin(&cursor, obj, usage);\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\n\t\tif (dma_resv_iter_is_restarted(&cursor)) {\n\t\t\tstruct dma_fence **new_fences;\n\t\t\tunsigned int count;\n\n\t\t\twhile (*num_fences)\n\t\t\t\tdma_fence_put((*fences)[--(*num_fences)]);\n\n\t\t\tcount = cursor.num_fences + 1;\n\n\t\t\t \n\t\t\tnew_fences = krealloc_array(*fences, count,\n\t\t\t\t\t\t    sizeof(void *),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (count && !new_fences) {\n\t\t\t\tkfree(*fences);\n\t\t\t\t*fences = NULL;\n\t\t\t\t*num_fences = 0;\n\t\t\t\tdma_resv_iter_end(&cursor);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t*fences = new_fences;\n\t\t}\n\n\t\t(*fences)[(*num_fences)++] = dma_fence_get(fence);\n\t}\n\tdma_resv_iter_end(&cursor);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dma_resv_get_fences);\n\n \nint dma_resv_get_singleton(struct dma_resv *obj, enum dma_resv_usage usage,\n\t\t\t   struct dma_fence **fence)\n{\n\tstruct dma_fence_array *array;\n\tstruct dma_fence **fences;\n\tunsigned count;\n\tint r;\n\n\tr = dma_resv_get_fences(obj, usage, &count, &fences);\n        if (r)\n\t\treturn r;\n\n\tif (count == 0) {\n\t\t*fence = NULL;\n\t\treturn 0;\n\t}\n\n\tif (count == 1) {\n\t\t*fence = fences[0];\n\t\tkfree(fences);\n\t\treturn 0;\n\t}\n\n\tarray = dma_fence_array_create(count, fences,\n\t\t\t\t       dma_fence_context_alloc(1),\n\t\t\t\t       1, false);\n\tif (!array) {\n\t\twhile (count--)\n\t\t\tdma_fence_put(fences[count]);\n\t\tkfree(fences);\n\t\treturn -ENOMEM;\n\t}\n\n\t*fence = &array->base;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dma_resv_get_singleton);\n\n \nlong dma_resv_wait_timeout(struct dma_resv *obj, enum dma_resv_usage usage,\n\t\t\t   bool intr, unsigned long timeout)\n{\n\tlong ret = timeout ? timeout : 1;\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\tdma_resv_iter_begin(&cursor, obj, usage);\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\n\t\tret = dma_fence_wait_timeout(fence, intr, ret);\n\t\tif (ret <= 0) {\n\t\t\tdma_resv_iter_end(&cursor);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdma_resv_iter_end(&cursor);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dma_resv_wait_timeout);\n\n \nvoid dma_resv_set_deadline(struct dma_resv *obj, enum dma_resv_usage usage,\n\t\t\t   ktime_t deadline)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\tdma_resv_iter_begin(&cursor, obj, usage);\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\tdma_fence_set_deadline(fence, deadline);\n\t}\n\tdma_resv_iter_end(&cursor);\n}\nEXPORT_SYMBOL_GPL(dma_resv_set_deadline);\n\n \nbool dma_resv_test_signaled(struct dma_resv *obj, enum dma_resv_usage usage)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\tdma_resv_iter_begin(&cursor, obj, usage);\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\tdma_resv_iter_end(&cursor);\n\t\treturn false;\n\t}\n\tdma_resv_iter_end(&cursor);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(dma_resv_test_signaled);\n\n \nvoid dma_resv_describe(struct dma_resv *obj, struct seq_file *seq)\n{\n\tstatic const char *usage[] = { \"kernel\", \"write\", \"read\", \"bookkeep\" };\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\n\tdma_resv_for_each_fence(&cursor, obj, DMA_RESV_USAGE_READ, fence) {\n\t\tseq_printf(seq, \"\\t%s fence:\",\n\t\t\t   usage[dma_resv_iter_usage(&cursor)]);\n\t\tdma_fence_describe(fence, seq);\n\t}\n}\nEXPORT_SYMBOL_GPL(dma_resv_describe);\n\n#if IS_ENABLED(CONFIG_LOCKDEP)\nstatic int __init dma_resv_lockdep(void)\n{\n\tstruct mm_struct *mm = mm_alloc();\n\tstruct ww_acquire_ctx ctx;\n\tstruct dma_resv obj;\n\tstruct address_space mapping;\n\tint ret;\n\n\tif (!mm)\n\t\treturn -ENOMEM;\n\n\tdma_resv_init(&obj);\n\taddress_space_init_once(&mapping);\n\n\tmmap_read_lock(mm);\n\tww_acquire_init(&ctx, &reservation_ww_class);\n\tret = dma_resv_lock(&obj, &ctx);\n\tif (ret == -EDEADLK)\n\t\tdma_resv_lock_slow(&obj, &ctx);\n\tfs_reclaim_acquire(GFP_KERNEL);\n\t \n\ti_mmap_lock_write(&mapping);\n\ti_mmap_unlock_write(&mapping);\n#ifdef CONFIG_MMU_NOTIFIER\n\tlock_map_acquire(&__mmu_notifier_invalidate_range_start_map);\n\t__dma_fence_might_wait();\n\tlock_map_release(&__mmu_notifier_invalidate_range_start_map);\n#else\n\t__dma_fence_might_wait();\n#endif\n\tfs_reclaim_release(GFP_KERNEL);\n\tww_mutex_unlock(&obj.lock);\n\tww_acquire_fini(&ctx);\n\tmmap_read_unlock(mm);\n\n\tmmput(mm);\n\n\treturn 0;\n}\nsubsys_initcall(dma_resv_lockdep);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}