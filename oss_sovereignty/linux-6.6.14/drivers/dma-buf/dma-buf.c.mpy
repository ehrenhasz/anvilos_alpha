{
  "module_name": "dma-buf.c",
  "hash_id": "f3c7fc9fe0d5aea84eddc08454922a9731393590ee4b975ec077d63129cafaca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/dma-buf.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/dma-buf.h>\n#include <linux/dma-fence.h>\n#include <linux/dma-fence-unwrap.h>\n#include <linux/anon_inodes.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/sync_file.h>\n#include <linux/poll.h>\n#include <linux/dma-resv.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/pseudo_fs.h>\n\n#include <uapi/linux/dma-buf.h>\n#include <uapi/linux/magic.h>\n\n#include \"dma-buf-sysfs-stats.h\"\n\nstatic inline int is_dma_buf_file(struct file *);\n\nstruct dma_buf_list {\n\tstruct list_head head;\n\tstruct mutex lock;\n};\n\nstatic struct dma_buf_list db_list;\n\nstatic char *dmabuffs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tstruct dma_buf *dmabuf;\n\tchar name[DMA_BUF_NAME_LEN];\n\tsize_t ret = 0;\n\n\tdmabuf = dentry->d_fsdata;\n\tspin_lock(&dmabuf->name_lock);\n\tif (dmabuf->name)\n\t\tret = strlcpy(name, dmabuf->name, DMA_BUF_NAME_LEN);\n\tspin_unlock(&dmabuf->name_lock);\n\n\treturn dynamic_dname(buffer, buflen, \"/%s:%s\",\n\t\t\t     dentry->d_name.name, ret > 0 ? name : \"\");\n}\n\nstatic void dma_buf_release(struct dentry *dentry)\n{\n\tstruct dma_buf *dmabuf;\n\n\tdmabuf = dentry->d_fsdata;\n\tif (unlikely(!dmabuf))\n\t\treturn;\n\n\tBUG_ON(dmabuf->vmapping_counter);\n\n\t \n\tBUG_ON(dmabuf->cb_in.active || dmabuf->cb_out.active);\n\n\tdma_buf_stats_teardown(dmabuf);\n\tdmabuf->ops->release(dmabuf);\n\n\tif (dmabuf->resv == (struct dma_resv *)&dmabuf[1])\n\t\tdma_resv_fini(dmabuf->resv);\n\n\tWARN_ON(!list_empty(&dmabuf->attachments));\n\tmodule_put(dmabuf->owner);\n\tkfree(dmabuf->name);\n\tkfree(dmabuf);\n}\n\nstatic int dma_buf_file_release(struct inode *inode, struct file *file)\n{\n\tstruct dma_buf *dmabuf;\n\n\tif (!is_dma_buf_file(file))\n\t\treturn -EINVAL;\n\n\tdmabuf = file->private_data;\n\tif (dmabuf) {\n\t\tmutex_lock(&db_list.lock);\n\t\tlist_del(&dmabuf->list_node);\n\t\tmutex_unlock(&db_list.lock);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dentry_operations dma_buf_dentry_ops = {\n\t.d_dname = dmabuffs_dname,\n\t.d_release = dma_buf_release,\n};\n\nstatic struct vfsmount *dma_buf_mnt;\n\nstatic int dma_buf_fs_init_context(struct fs_context *fc)\n{\n\tstruct pseudo_fs_context *ctx;\n\n\tctx = init_pseudo(fc, DMA_BUF_MAGIC);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->dops = &dma_buf_dentry_ops;\n\treturn 0;\n}\n\nstatic struct file_system_type dma_buf_fs_type = {\n\t.name = \"dmabuf\",\n\t.init_fs_context = dma_buf_fs_init_context,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic int dma_buf_mmap_internal(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct dma_buf *dmabuf;\n\n\tif (!is_dma_buf_file(file))\n\t\treturn -EINVAL;\n\n\tdmabuf = file->private_data;\n\n\t \n\tif (!dmabuf->ops->mmap)\n\t\treturn -EINVAL;\n\n\t \n\tif (vma->vm_pgoff + vma_pages(vma) >\n\t    dmabuf->size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\n\treturn dmabuf->ops->mmap(dmabuf, vma);\n}\n\nstatic loff_t dma_buf_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dma_buf *dmabuf;\n\tloff_t base;\n\n\tif (!is_dma_buf_file(file))\n\t\treturn -EBADF;\n\n\tdmabuf = file->private_data;\n\n\t \n\tif (whence == SEEK_END)\n\t\tbase = dmabuf->size;\n\telse if (whence == SEEK_SET)\n\t\tbase = 0;\n\telse\n\t\treturn -EINVAL;\n\n\tif (offset != 0)\n\t\treturn -EINVAL;\n\n\treturn base + offset;\n}\n\n \n\nstatic void dma_buf_poll_cb(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tstruct dma_buf_poll_cb_t *dcb = (struct dma_buf_poll_cb_t *)cb;\n\tstruct dma_buf *dmabuf = container_of(dcb->poll, struct dma_buf, poll);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dcb->poll->lock, flags);\n\twake_up_locked_poll(dcb->poll, dcb->active);\n\tdcb->active = 0;\n\tspin_unlock_irqrestore(&dcb->poll->lock, flags);\n\tdma_fence_put(fence);\n\t \n\tfput(dmabuf->file);\n}\n\nstatic bool dma_buf_poll_add_cb(struct dma_resv *resv, bool write,\n\t\t\t\tstruct dma_buf_poll_cb_t *dcb)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *fence;\n\tint r;\n\n\tdma_resv_for_each_fence(&cursor, resv, dma_resv_usage_rw(write),\n\t\t\t\tfence) {\n\t\tdma_fence_get(fence);\n\t\tr = dma_fence_add_callback(fence, &dcb->cb, dma_buf_poll_cb);\n\t\tif (!r)\n\t\t\treturn true;\n\t\tdma_fence_put(fence);\n\t}\n\n\treturn false;\n}\n\nstatic __poll_t dma_buf_poll(struct file *file, poll_table *poll)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct dma_resv *resv;\n\t__poll_t events;\n\n\tdmabuf = file->private_data;\n\tif (!dmabuf || !dmabuf->resv)\n\t\treturn EPOLLERR;\n\n\tresv = dmabuf->resv;\n\n\tpoll_wait(file, &dmabuf->poll, poll);\n\n\tevents = poll_requested_events(poll) & (EPOLLIN | EPOLLOUT);\n\tif (!events)\n\t\treturn 0;\n\n\tdma_resv_lock(resv, NULL);\n\n\tif (events & EPOLLOUT) {\n\t\tstruct dma_buf_poll_cb_t *dcb = &dmabuf->cb_out;\n\n\t\t \n\t\tspin_lock_irq(&dmabuf->poll.lock);\n\t\tif (dcb->active)\n\t\t\tevents &= ~EPOLLOUT;\n\t\telse\n\t\t\tdcb->active = EPOLLOUT;\n\t\tspin_unlock_irq(&dmabuf->poll.lock);\n\n\t\tif (events & EPOLLOUT) {\n\t\t\t \n\t\t\tget_file(dmabuf->file);\n\n\t\t\tif (!dma_buf_poll_add_cb(resv, true, dcb))\n\t\t\t\t \n\t\t\t\tdma_buf_poll_cb(NULL, &dcb->cb);\n\t\t\telse\n\t\t\t\tevents &= ~EPOLLOUT;\n\t\t}\n\t}\n\n\tif (events & EPOLLIN) {\n\t\tstruct dma_buf_poll_cb_t *dcb = &dmabuf->cb_in;\n\n\t\t \n\t\tspin_lock_irq(&dmabuf->poll.lock);\n\t\tif (dcb->active)\n\t\t\tevents &= ~EPOLLIN;\n\t\telse\n\t\t\tdcb->active = EPOLLIN;\n\t\tspin_unlock_irq(&dmabuf->poll.lock);\n\n\t\tif (events & EPOLLIN) {\n\t\t\t \n\t\t\tget_file(dmabuf->file);\n\n\t\t\tif (!dma_buf_poll_add_cb(resv, false, dcb))\n\t\t\t\t \n\t\t\t\tdma_buf_poll_cb(NULL, &dcb->cb);\n\t\t\telse\n\t\t\t\tevents &= ~EPOLLIN;\n\t\t}\n\t}\n\n\tdma_resv_unlock(resv);\n\treturn events;\n}\n\n \nstatic long dma_buf_set_name(struct dma_buf *dmabuf, const char __user *buf)\n{\n\tchar *name = strndup_user(buf, DMA_BUF_NAME_LEN);\n\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tspin_lock(&dmabuf->name_lock);\n\tkfree(dmabuf->name);\n\tdmabuf->name = name;\n\tspin_unlock(&dmabuf->name_lock);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SYNC_FILE)\nstatic long dma_buf_export_sync_file(struct dma_buf *dmabuf,\n\t\t\t\t     void __user *user_data)\n{\n\tstruct dma_buf_export_sync_file arg;\n\tenum dma_resv_usage usage;\n\tstruct dma_fence *fence = NULL;\n\tstruct sync_file *sync_file;\n\tint fd, ret;\n\n\tif (copy_from_user(&arg, user_data, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~DMA_BUF_SYNC_RW)\n\t\treturn -EINVAL;\n\n\tif ((arg.flags & DMA_BUF_SYNC_RW) == 0)\n\t\treturn -EINVAL;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tusage = dma_resv_usage_rw(arg.flags & DMA_BUF_SYNC_WRITE);\n\tret = dma_resv_get_singleton(dmabuf->resv, usage, &fence);\n\tif (ret)\n\t\tgoto err_put_fd;\n\n\tif (!fence)\n\t\tfence = dma_fence_get_stub();\n\n\tsync_file = sync_file_create(fence);\n\n\tdma_fence_put(fence);\n\n\tif (!sync_file) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_fd;\n\t}\n\n\targ.fd = fd;\n\tif (copy_to_user(user_data, &arg, sizeof(arg))) {\n\t\tret = -EFAULT;\n\t\tgoto err_put_file;\n\t}\n\n\tfd_install(fd, sync_file->file);\n\n\treturn 0;\n\nerr_put_file:\n\tfput(sync_file->file);\nerr_put_fd:\n\tput_unused_fd(fd);\n\treturn ret;\n}\n\nstatic long dma_buf_import_sync_file(struct dma_buf *dmabuf,\n\t\t\t\t     const void __user *user_data)\n{\n\tstruct dma_buf_import_sync_file arg;\n\tstruct dma_fence *fence, *f;\n\tenum dma_resv_usage usage;\n\tstruct dma_fence_unwrap iter;\n\tunsigned int num_fences;\n\tint ret = 0;\n\n\tif (copy_from_user(&arg, user_data, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~DMA_BUF_SYNC_RW)\n\t\treturn -EINVAL;\n\n\tif ((arg.flags & DMA_BUF_SYNC_RW) == 0)\n\t\treturn -EINVAL;\n\n\tfence = sync_file_get_fence(arg.fd);\n\tif (!fence)\n\t\treturn -EINVAL;\n\n\tusage = (arg.flags & DMA_BUF_SYNC_WRITE) ? DMA_RESV_USAGE_WRITE :\n\t\t\t\t\t\t   DMA_RESV_USAGE_READ;\n\n\tnum_fences = 0;\n\tdma_fence_unwrap_for_each(f, &iter, fence)\n\t\t++num_fences;\n\n\tif (num_fences > 0) {\n\t\tdma_resv_lock(dmabuf->resv, NULL);\n\n\t\tret = dma_resv_reserve_fences(dmabuf->resv, num_fences);\n\t\tif (!ret) {\n\t\t\tdma_fence_unwrap_for_each(f, &iter, fence)\n\t\t\t\tdma_resv_add_fence(dmabuf->resv, f, usage);\n\t\t}\n\n\t\tdma_resv_unlock(dmabuf->resv);\n\t}\n\n\tdma_fence_put(fence);\n\n\treturn ret;\n}\n#endif\n\nstatic long dma_buf_ioctl(struct file *file,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct dma_buf_sync sync;\n\tenum dma_data_direction direction;\n\tint ret;\n\n\tdmabuf = file->private_data;\n\n\tswitch (cmd) {\n\tcase DMA_BUF_IOCTL_SYNC:\n\t\tif (copy_from_user(&sync, (void __user *) arg, sizeof(sync)))\n\t\t\treturn -EFAULT;\n\n\t\tif (sync.flags & ~DMA_BUF_SYNC_VALID_FLAGS_MASK)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sync.flags & DMA_BUF_SYNC_RW) {\n\t\tcase DMA_BUF_SYNC_READ:\n\t\t\tdirection = DMA_FROM_DEVICE;\n\t\t\tbreak;\n\t\tcase DMA_BUF_SYNC_WRITE:\n\t\t\tdirection = DMA_TO_DEVICE;\n\t\t\tbreak;\n\t\tcase DMA_BUF_SYNC_RW:\n\t\t\tdirection = DMA_BIDIRECTIONAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sync.flags & DMA_BUF_SYNC_END)\n\t\t\tret = dma_buf_end_cpu_access(dmabuf, direction);\n\t\telse\n\t\t\tret = dma_buf_begin_cpu_access(dmabuf, direction);\n\n\t\treturn ret;\n\n\tcase DMA_BUF_SET_NAME_A:\n\tcase DMA_BUF_SET_NAME_B:\n\t\treturn dma_buf_set_name(dmabuf, (const char __user *)arg);\n\n#if IS_ENABLED(CONFIG_SYNC_FILE)\n\tcase DMA_BUF_IOCTL_EXPORT_SYNC_FILE:\n\t\treturn dma_buf_export_sync_file(dmabuf, (void __user *)arg);\n\tcase DMA_BUF_IOCTL_IMPORT_SYNC_FILE:\n\t\treturn dma_buf_import_sync_file(dmabuf, (const void __user *)arg);\n#endif\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic void dma_buf_show_fdinfo(struct seq_file *m, struct file *file)\n{\n\tstruct dma_buf *dmabuf = file->private_data;\n\n\tseq_printf(m, \"size:\\t%zu\\n\", dmabuf->size);\n\t \n\tseq_printf(m, \"count:\\t%ld\\n\", file_count(dmabuf->file) - 1);\n\tseq_printf(m, \"exp_name:\\t%s\\n\", dmabuf->exp_name);\n\tspin_lock(&dmabuf->name_lock);\n\tif (dmabuf->name)\n\t\tseq_printf(m, \"name:\\t%s\\n\", dmabuf->name);\n\tspin_unlock(&dmabuf->name_lock);\n}\n\nstatic const struct file_operations dma_buf_fops = {\n\t.release\t= dma_buf_file_release,\n\t.mmap\t\t= dma_buf_mmap_internal,\n\t.llseek\t\t= dma_buf_llseek,\n\t.poll\t\t= dma_buf_poll,\n\t.unlocked_ioctl\t= dma_buf_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.show_fdinfo\t= dma_buf_show_fdinfo,\n};\n\n \nstatic inline int is_dma_buf_file(struct file *file)\n{\n\treturn file->f_op == &dma_buf_fops;\n}\n\nstatic struct file *dma_buf_getfile(size_t size, int flags)\n{\n\tstatic atomic64_t dmabuf_inode = ATOMIC64_INIT(0);\n\tstruct inode *inode = alloc_anon_inode(dma_buf_mnt->mnt_sb);\n\tstruct file *file;\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_size = size;\n\tinode_set_bytes(inode, size);\n\n\t \n\tinode->i_ino = atomic64_add_return(1, &dmabuf_inode);\n\tflags &= O_ACCMODE | O_NONBLOCK;\n\tfile = alloc_file_pseudo(inode, dma_buf_mnt, \"dmabuf\",\n\t\t\t\t flags, &dma_buf_fops);\n\tif (IS_ERR(file))\n\t\tgoto err_alloc_file;\n\n\treturn file;\n\nerr_alloc_file:\n\tiput(inode);\n\treturn file;\n}\n\n \n\n \nstruct dma_buf *dma_buf_export(const struct dma_buf_export_info *exp_info)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct dma_resv *resv = exp_info->resv;\n\tstruct file *file;\n\tsize_t alloc_size = sizeof(struct dma_buf);\n\tint ret;\n\n\tif (WARN_ON(!exp_info->priv || !exp_info->ops\n\t\t    || !exp_info->ops->map_dma_buf\n\t\t    || !exp_info->ops->unmap_dma_buf\n\t\t    || !exp_info->ops->release))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN_ON(exp_info->ops->cache_sgt_mapping &&\n\t\t    (exp_info->ops->pin || exp_info->ops->unpin)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN_ON(!exp_info->ops->pin != !exp_info->ops->unpin))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!try_module_get(exp_info->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tfile = dma_buf_getfile(exp_info->size, exp_info->flags);\n\tif (IS_ERR(file)) {\n\t\tret = PTR_ERR(file);\n\t\tgoto err_module;\n\t}\n\n\tif (!exp_info->resv)\n\t\talloc_size += sizeof(struct dma_resv);\n\telse\n\t\t \n\t\talloc_size += 1;\n\tdmabuf = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!dmabuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_file;\n\t}\n\n\tdmabuf->priv = exp_info->priv;\n\tdmabuf->ops = exp_info->ops;\n\tdmabuf->size = exp_info->size;\n\tdmabuf->exp_name = exp_info->exp_name;\n\tdmabuf->owner = exp_info->owner;\n\tspin_lock_init(&dmabuf->name_lock);\n\tinit_waitqueue_head(&dmabuf->poll);\n\tdmabuf->cb_in.poll = dmabuf->cb_out.poll = &dmabuf->poll;\n\tdmabuf->cb_in.active = dmabuf->cb_out.active = 0;\n\tINIT_LIST_HEAD(&dmabuf->attachments);\n\n\tif (!resv) {\n\t\tdmabuf->resv = (struct dma_resv *)&dmabuf[1];\n\t\tdma_resv_init(dmabuf->resv);\n\t} else {\n\t\tdmabuf->resv = resv;\n\t}\n\n\tret = dma_buf_stats_setup(dmabuf, file);\n\tif (ret)\n\t\tgoto err_dmabuf;\n\n\tfile->private_data = dmabuf;\n\tfile->f_path.dentry->d_fsdata = dmabuf;\n\tdmabuf->file = file;\n\n\tmutex_lock(&db_list.lock);\n\tlist_add(&dmabuf->list_node, &db_list.head);\n\tmutex_unlock(&db_list.lock);\n\n\treturn dmabuf;\n\nerr_dmabuf:\n\tif (!resv)\n\t\tdma_resv_fini(dmabuf->resv);\n\tkfree(dmabuf);\nerr_file:\n\tfput(file);\nerr_module:\n\tmodule_put(exp_info->owner);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_export, DMA_BUF);\n\n \nint dma_buf_fd(struct dma_buf *dmabuf, int flags)\n{\n\tint fd;\n\n\tif (!dmabuf || !dmabuf->file)\n\t\treturn -EINVAL;\n\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfd_install(fd, dmabuf->file);\n\n\treturn fd;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_fd, DMA_BUF);\n\n \nstruct dma_buf *dma_buf_get(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (!is_dma_buf_file(file)) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn file->private_data;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_get, DMA_BUF);\n\n \nvoid dma_buf_put(struct dma_buf *dmabuf)\n{\n\tif (WARN_ON(!dmabuf || !dmabuf->file))\n\t\treturn;\n\n\tfput(dmabuf->file);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_put, DMA_BUF);\n\nstatic void mangle_sg_table(struct sg_table *sg_table)\n{\n#ifdef CONFIG_DMABUF_DEBUG\n\tint i;\n\tstruct scatterlist *sg;\n\n\t \n\tfor_each_sgtable_sg(sg_table, sg, i)\n\t\tsg->page_link ^= ~0xffUL;\n#endif\n\n}\nstatic struct sg_table * __map_dma_buf(struct dma_buf_attachment *attach,\n\t\t\t\t       enum dma_data_direction direction)\n{\n\tstruct sg_table *sg_table;\n\tsigned long ret;\n\n\tsg_table = attach->dmabuf->ops->map_dma_buf(attach, direction);\n\tif (IS_ERR_OR_NULL(sg_table))\n\t\treturn sg_table;\n\n\tif (!dma_buf_attachment_is_dynamic(attach)) {\n\t\tret = dma_resv_wait_timeout(attach->dmabuf->resv,\n\t\t\t\t\t    DMA_RESV_USAGE_KERNEL, true,\n\t\t\t\t\t    MAX_SCHEDULE_TIMEOUT);\n\t\tif (ret < 0) {\n\t\t\tattach->dmabuf->ops->unmap_dma_buf(attach, sg_table,\n\t\t\t\t\t\t\t   direction);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tmangle_sg_table(sg_table);\n\treturn sg_table;\n}\n\n \n\n \nstruct dma_buf_attachment *\ndma_buf_dynamic_attach(struct dma_buf *dmabuf, struct device *dev,\n\t\t       const struct dma_buf_attach_ops *importer_ops,\n\t\t       void *importer_priv)\n{\n\tstruct dma_buf_attachment *attach;\n\tint ret;\n\n\tif (WARN_ON(!dmabuf || !dev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN_ON(importer_ops && !importer_ops->move_notify))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tattach = kzalloc(sizeof(*attach), GFP_KERNEL);\n\tif (!attach)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tattach->dev = dev;\n\tattach->dmabuf = dmabuf;\n\tif (importer_ops)\n\t\tattach->peer2peer = importer_ops->allow_peer2peer;\n\tattach->importer_ops = importer_ops;\n\tattach->importer_priv = importer_priv;\n\n\tif (dmabuf->ops->attach) {\n\t\tret = dmabuf->ops->attach(dmabuf, attach);\n\t\tif (ret)\n\t\t\tgoto err_attach;\n\t}\n\tdma_resv_lock(dmabuf->resv, NULL);\n\tlist_add(&attach->node, &dmabuf->attachments);\n\tdma_resv_unlock(dmabuf->resv);\n\n\t \n\tif (dma_buf_attachment_is_dynamic(attach) !=\n\t    dma_buf_is_dynamic(dmabuf)) {\n\t\tstruct sg_table *sgt;\n\n\t\tdma_resv_lock(attach->dmabuf->resv, NULL);\n\t\tif (dma_buf_is_dynamic(attach->dmabuf)) {\n\t\t\tret = dmabuf->ops->pin(attach);\n\t\t\tif (ret)\n\t\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tsgt = __map_dma_buf(attach, DMA_BIDIRECTIONAL);\n\t\tif (!sgt)\n\t\t\tsgt = ERR_PTR(-ENOMEM);\n\t\tif (IS_ERR(sgt)) {\n\t\t\tret = PTR_ERR(sgt);\n\t\t\tgoto err_unpin;\n\t\t}\n\t\tdma_resv_unlock(attach->dmabuf->resv);\n\t\tattach->sgt = sgt;\n\t\tattach->dir = DMA_BIDIRECTIONAL;\n\t}\n\n\treturn attach;\n\nerr_attach:\n\tkfree(attach);\n\treturn ERR_PTR(ret);\n\nerr_unpin:\n\tif (dma_buf_is_dynamic(attach->dmabuf))\n\t\tdmabuf->ops->unpin(attach);\n\nerr_unlock:\n\tdma_resv_unlock(attach->dmabuf->resv);\n\n\tdma_buf_detach(dmabuf, attach);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_dynamic_attach, DMA_BUF);\n\n \nstruct dma_buf_attachment *dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t\t  struct device *dev)\n{\n\treturn dma_buf_dynamic_attach(dmabuf, dev, NULL, NULL);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_attach, DMA_BUF);\n\nstatic void __unmap_dma_buf(struct dma_buf_attachment *attach,\n\t\t\t    struct sg_table *sg_table,\n\t\t\t    enum dma_data_direction direction)\n{\n\t \n\tmangle_sg_table(sg_table);\n\n\tattach->dmabuf->ops->unmap_dma_buf(attach, sg_table, direction);\n}\n\n \nvoid dma_buf_detach(struct dma_buf *dmabuf, struct dma_buf_attachment *attach)\n{\n\tif (WARN_ON(!dmabuf || !attach || dmabuf != attach->dmabuf))\n\t\treturn;\n\n\tdma_resv_lock(dmabuf->resv, NULL);\n\n\tif (attach->sgt) {\n\n\t\t__unmap_dma_buf(attach, attach->sgt, attach->dir);\n\n\t\tif (dma_buf_is_dynamic(attach->dmabuf))\n\t\t\tdmabuf->ops->unpin(attach);\n\t}\n\tlist_del(&attach->node);\n\n\tdma_resv_unlock(dmabuf->resv);\n\n\tif (dmabuf->ops->detach)\n\t\tdmabuf->ops->detach(dmabuf, attach);\n\n\tkfree(attach);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_detach, DMA_BUF);\n\n \nint dma_buf_pin(struct dma_buf_attachment *attach)\n{\n\tstruct dma_buf *dmabuf = attach->dmabuf;\n\tint ret = 0;\n\n\tWARN_ON(!dma_buf_attachment_is_dynamic(attach));\n\n\tdma_resv_assert_held(dmabuf->resv);\n\n\tif (dmabuf->ops->pin)\n\t\tret = dmabuf->ops->pin(attach);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_pin, DMA_BUF);\n\n \nvoid dma_buf_unpin(struct dma_buf_attachment *attach)\n{\n\tstruct dma_buf *dmabuf = attach->dmabuf;\n\n\tWARN_ON(!dma_buf_attachment_is_dynamic(attach));\n\n\tdma_resv_assert_held(dmabuf->resv);\n\n\tif (dmabuf->ops->unpin)\n\t\tdmabuf->ops->unpin(attach);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_unpin, DMA_BUF);\n\n \nstruct sg_table *dma_buf_map_attachment(struct dma_buf_attachment *attach,\n\t\t\t\t\tenum dma_data_direction direction)\n{\n\tstruct sg_table *sg_table;\n\tint r;\n\n\tmight_sleep();\n\n\tif (WARN_ON(!attach || !attach->dmabuf))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdma_resv_assert_held(attach->dmabuf->resv);\n\n\tif (attach->sgt) {\n\t\t \n\t\tif (attach->dir != direction &&\n\t\t    attach->dir != DMA_BIDIRECTIONAL)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\treturn attach->sgt;\n\t}\n\n\tif (dma_buf_is_dynamic(attach->dmabuf)) {\n\t\tif (!IS_ENABLED(CONFIG_DMABUF_MOVE_NOTIFY)) {\n\t\t\tr = attach->dmabuf->ops->pin(attach);\n\t\t\tif (r)\n\t\t\t\treturn ERR_PTR(r);\n\t\t}\n\t}\n\n\tsg_table = __map_dma_buf(attach, direction);\n\tif (!sg_table)\n\t\tsg_table = ERR_PTR(-ENOMEM);\n\n\tif (IS_ERR(sg_table) && dma_buf_is_dynamic(attach->dmabuf) &&\n\t     !IS_ENABLED(CONFIG_DMABUF_MOVE_NOTIFY))\n\t\tattach->dmabuf->ops->unpin(attach);\n\n\tif (!IS_ERR(sg_table) && attach->dmabuf->ops->cache_sgt_mapping) {\n\t\tattach->sgt = sg_table;\n\t\tattach->dir = direction;\n\t}\n\n#ifdef CONFIG_DMA_API_DEBUG\n\tif (!IS_ERR(sg_table)) {\n\t\tstruct scatterlist *sg;\n\t\tu64 addr;\n\t\tint len;\n\t\tint i;\n\n\t\tfor_each_sgtable_dma_sg(sg_table, sg, i) {\n\t\t\taddr = sg_dma_address(sg);\n\t\t\tlen = sg_dma_len(sg);\n\t\t\tif (!PAGE_ALIGNED(addr) || !PAGE_ALIGNED(len)) {\n\t\t\t\tpr_debug(\"%s: addr %llx or len %x is not page aligned!\\n\",\n\t\t\t\t\t __func__, addr, len);\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\treturn sg_table;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_map_attachment, DMA_BUF);\n\n \nstruct sg_table *\ndma_buf_map_attachment_unlocked(struct dma_buf_attachment *attach,\n\t\t\t\tenum dma_data_direction direction)\n{\n\tstruct sg_table *sg_table;\n\n\tmight_sleep();\n\n\tif (WARN_ON(!attach || !attach->dmabuf))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdma_resv_lock(attach->dmabuf->resv, NULL);\n\tsg_table = dma_buf_map_attachment(attach, direction);\n\tdma_resv_unlock(attach->dmabuf->resv);\n\n\treturn sg_table;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_map_attachment_unlocked, DMA_BUF);\n\n \nvoid dma_buf_unmap_attachment(struct dma_buf_attachment *attach,\n\t\t\t\tstruct sg_table *sg_table,\n\t\t\t\tenum dma_data_direction direction)\n{\n\tmight_sleep();\n\n\tif (WARN_ON(!attach || !attach->dmabuf || !sg_table))\n\t\treturn;\n\n\tdma_resv_assert_held(attach->dmabuf->resv);\n\n\tif (attach->sgt == sg_table)\n\t\treturn;\n\n\t__unmap_dma_buf(attach, sg_table, direction);\n\n\tif (dma_buf_is_dynamic(attach->dmabuf) &&\n\t    !IS_ENABLED(CONFIG_DMABUF_MOVE_NOTIFY))\n\t\tdma_buf_unpin(attach);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_unmap_attachment, DMA_BUF);\n\n \nvoid dma_buf_unmap_attachment_unlocked(struct dma_buf_attachment *attach,\n\t\t\t\t       struct sg_table *sg_table,\n\t\t\t\t       enum dma_data_direction direction)\n{\n\tmight_sleep();\n\n\tif (WARN_ON(!attach || !attach->dmabuf || !sg_table))\n\t\treturn;\n\n\tdma_resv_lock(attach->dmabuf->resv, NULL);\n\tdma_buf_unmap_attachment(attach, sg_table, direction);\n\tdma_resv_unlock(attach->dmabuf->resv);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_unmap_attachment_unlocked, DMA_BUF);\n\n \nvoid dma_buf_move_notify(struct dma_buf *dmabuf)\n{\n\tstruct dma_buf_attachment *attach;\n\n\tdma_resv_assert_held(dmabuf->resv);\n\n\tlist_for_each_entry(attach, &dmabuf->attachments, node)\n\t\tif (attach->importer_ops)\n\t\t\tattach->importer_ops->move_notify(attach);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_move_notify, DMA_BUF);\n\n \n\nstatic int __dma_buf_begin_cpu_access(struct dma_buf *dmabuf,\n\t\t\t\t      enum dma_data_direction direction)\n{\n\tbool write = (direction == DMA_BIDIRECTIONAL ||\n\t\t      direction == DMA_TO_DEVICE);\n\tstruct dma_resv *resv = dmabuf->resv;\n\tlong ret;\n\n\t \n\tret = dma_resv_wait_timeout(resv, dma_resv_usage_rw(write),\n\t\t\t\t    true, MAX_SCHEDULE_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint dma_buf_begin_cpu_access(struct dma_buf *dmabuf,\n\t\t\t     enum dma_data_direction direction)\n{\n\tint ret = 0;\n\n\tif (WARN_ON(!dmabuf))\n\t\treturn -EINVAL;\n\n\tmight_lock(&dmabuf->resv->lock.base);\n\n\tif (dmabuf->ops->begin_cpu_access)\n\t\tret = dmabuf->ops->begin_cpu_access(dmabuf, direction);\n\n\t \n\tif (ret == 0)\n\t\tret = __dma_buf_begin_cpu_access(dmabuf, direction);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_begin_cpu_access, DMA_BUF);\n\n \nint dma_buf_end_cpu_access(struct dma_buf *dmabuf,\n\t\t\t   enum dma_data_direction direction)\n{\n\tint ret = 0;\n\n\tWARN_ON(!dmabuf);\n\n\tmight_lock(&dmabuf->resv->lock.base);\n\n\tif (dmabuf->ops->end_cpu_access)\n\t\tret = dmabuf->ops->end_cpu_access(dmabuf, direction);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_end_cpu_access, DMA_BUF);\n\n\n \nint dma_buf_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma,\n\t\t unsigned long pgoff)\n{\n\tif (WARN_ON(!dmabuf || !vma))\n\t\treturn -EINVAL;\n\n\t \n\tif (!dmabuf->ops->mmap)\n\t\treturn -EINVAL;\n\n\t \n\tif (pgoff + vma_pages(vma) < pgoff)\n\t\treturn -EOVERFLOW;\n\n\t \n\tif (pgoff + vma_pages(vma) >\n\t    dmabuf->size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tvma_set_file(vma, dmabuf->file);\n\tvma->vm_pgoff = pgoff;\n\n\treturn dmabuf->ops->mmap(dmabuf, vma);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_mmap, DMA_BUF);\n\n \nint dma_buf_vmap(struct dma_buf *dmabuf, struct iosys_map *map)\n{\n\tstruct iosys_map ptr;\n\tint ret;\n\n\tiosys_map_clear(map);\n\n\tif (WARN_ON(!dmabuf))\n\t\treturn -EINVAL;\n\n\tdma_resv_assert_held(dmabuf->resv);\n\n\tif (!dmabuf->ops->vmap)\n\t\treturn -EINVAL;\n\n\tif (dmabuf->vmapping_counter) {\n\t\tdmabuf->vmapping_counter++;\n\t\tBUG_ON(iosys_map_is_null(&dmabuf->vmap_ptr));\n\t\t*map = dmabuf->vmap_ptr;\n\t\treturn 0;\n\t}\n\n\tBUG_ON(iosys_map_is_set(&dmabuf->vmap_ptr));\n\n\tret = dmabuf->ops->vmap(dmabuf, &ptr);\n\tif (WARN_ON_ONCE(ret))\n\t\treturn ret;\n\n\tdmabuf->vmap_ptr = ptr;\n\tdmabuf->vmapping_counter = 1;\n\n\t*map = dmabuf->vmap_ptr;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_vmap, DMA_BUF);\n\n \nint dma_buf_vmap_unlocked(struct dma_buf *dmabuf, struct iosys_map *map)\n{\n\tint ret;\n\n\tiosys_map_clear(map);\n\n\tif (WARN_ON(!dmabuf))\n\t\treturn -EINVAL;\n\n\tdma_resv_lock(dmabuf->resv, NULL);\n\tret = dma_buf_vmap(dmabuf, map);\n\tdma_resv_unlock(dmabuf->resv);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_vmap_unlocked, DMA_BUF);\n\n \nvoid dma_buf_vunmap(struct dma_buf *dmabuf, struct iosys_map *map)\n{\n\tif (WARN_ON(!dmabuf))\n\t\treturn;\n\n\tdma_resv_assert_held(dmabuf->resv);\n\n\tBUG_ON(iosys_map_is_null(&dmabuf->vmap_ptr));\n\tBUG_ON(dmabuf->vmapping_counter == 0);\n\tBUG_ON(!iosys_map_is_equal(&dmabuf->vmap_ptr, map));\n\n\tif (--dmabuf->vmapping_counter == 0) {\n\t\tif (dmabuf->ops->vunmap)\n\t\t\tdmabuf->ops->vunmap(dmabuf, map);\n\t\tiosys_map_clear(&dmabuf->vmap_ptr);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_vunmap, DMA_BUF);\n\n \nvoid dma_buf_vunmap_unlocked(struct dma_buf *dmabuf, struct iosys_map *map)\n{\n\tif (WARN_ON(!dmabuf))\n\t\treturn;\n\n\tdma_resv_lock(dmabuf->resv, NULL);\n\tdma_buf_vunmap(dmabuf, map);\n\tdma_resv_unlock(dmabuf->resv);\n}\nEXPORT_SYMBOL_NS_GPL(dma_buf_vunmap_unlocked, DMA_BUF);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int dma_buf_debug_show(struct seq_file *s, void *unused)\n{\n\tstruct dma_buf *buf_obj;\n\tstruct dma_buf_attachment *attach_obj;\n\tint count = 0, attach_count;\n\tsize_t size = 0;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&db_list.lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tseq_puts(s, \"\\nDma-buf Objects:\\n\");\n\tseq_printf(s, \"%-8s\\t%-8s\\t%-8s\\t%-8s\\texp_name\\t%-8s\\tname\\n\",\n\t\t   \"size\", \"flags\", \"mode\", \"count\", \"ino\");\n\n\tlist_for_each_entry(buf_obj, &db_list.head, list_node) {\n\n\t\tret = dma_resv_lock_interruptible(buf_obj->resv, NULL);\n\t\tif (ret)\n\t\t\tgoto error_unlock;\n\n\n\t\tspin_lock(&buf_obj->name_lock);\n\t\tseq_printf(s, \"%08zu\\t%08x\\t%08x\\t%08ld\\t%s\\t%08lu\\t%s\\n\",\n\t\t\t\tbuf_obj->size,\n\t\t\t\tbuf_obj->file->f_flags, buf_obj->file->f_mode,\n\t\t\t\tfile_count(buf_obj->file),\n\t\t\t\tbuf_obj->exp_name,\n\t\t\t\tfile_inode(buf_obj->file)->i_ino,\n\t\t\t\tbuf_obj->name ?: \"<none>\");\n\t\tspin_unlock(&buf_obj->name_lock);\n\n\t\tdma_resv_describe(buf_obj->resv, s);\n\n\t\tseq_puts(s, \"\\tAttached Devices:\\n\");\n\t\tattach_count = 0;\n\n\t\tlist_for_each_entry(attach_obj, &buf_obj->attachments, node) {\n\t\t\tseq_printf(s, \"\\t%s\\n\", dev_name(attach_obj->dev));\n\t\t\tattach_count++;\n\t\t}\n\t\tdma_resv_unlock(buf_obj->resv);\n\n\t\tseq_printf(s, \"Total %d devices attached\\n\\n\",\n\t\t\t\tattach_count);\n\n\t\tcount++;\n\t\tsize += buf_obj->size;\n\t}\n\n\tseq_printf(s, \"\\nTotal %d objects, %zu bytes\\n\", count, size);\n\n\tmutex_unlock(&db_list.lock);\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&db_list.lock);\n\treturn ret;\n}\n\nDEFINE_SHOW_ATTRIBUTE(dma_buf_debug);\n\nstatic struct dentry *dma_buf_debugfs_dir;\n\nstatic int dma_buf_init_debugfs(void)\n{\n\tstruct dentry *d;\n\tint err = 0;\n\n\td = debugfs_create_dir(\"dma_buf\", NULL);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\n\tdma_buf_debugfs_dir = d;\n\n\td = debugfs_create_file(\"bufinfo\", S_IRUGO, dma_buf_debugfs_dir,\n\t\t\t\tNULL, &dma_buf_debug_fops);\n\tif (IS_ERR(d)) {\n\t\tpr_debug(\"dma_buf: debugfs: failed to create node bufinfo\\n\");\n\t\tdebugfs_remove_recursive(dma_buf_debugfs_dir);\n\t\tdma_buf_debugfs_dir = NULL;\n\t\terr = PTR_ERR(d);\n\t}\n\n\treturn err;\n}\n\nstatic void dma_buf_uninit_debugfs(void)\n{\n\tdebugfs_remove_recursive(dma_buf_debugfs_dir);\n}\n#else\nstatic inline int dma_buf_init_debugfs(void)\n{\n\treturn 0;\n}\nstatic inline void dma_buf_uninit_debugfs(void)\n{\n}\n#endif\n\nstatic int __init dma_buf_init(void)\n{\n\tint ret;\n\n\tret = dma_buf_init_sysfs_statistics();\n\tif (ret)\n\t\treturn ret;\n\n\tdma_buf_mnt = kern_mount(&dma_buf_fs_type);\n\tif (IS_ERR(dma_buf_mnt))\n\t\treturn PTR_ERR(dma_buf_mnt);\n\n\tmutex_init(&db_list.lock);\n\tINIT_LIST_HEAD(&db_list.head);\n\tdma_buf_init_debugfs();\n\treturn 0;\n}\nsubsys_initcall(dma_buf_init);\n\nstatic void __exit dma_buf_deinit(void)\n{\n\tdma_buf_uninit_debugfs();\n\tkern_unmount(dma_buf_mnt);\n\tdma_buf_uninit_sysfs_statistics();\n}\n__exitcall(dma_buf_deinit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}