{
  "module_name": "dma-heap.c",
  "hash_id": "30177789ec4decb6bf605d47713a293752c56f36a14ec312ed56812ba0c35ac6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/dma-heap.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/dma-buf.h>\n#include <linux/err.h>\n#include <linux/xarray.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/dma-heap.h>\n#include <uapi/linux/dma-heap.h>\n\n#define DEVNAME \"dma_heap\"\n\n#define NUM_HEAP_MINORS 128\n\n \nstruct dma_heap {\n\tconst char *name;\n\tconst struct dma_heap_ops *ops;\n\tvoid *priv;\n\tdev_t heap_devt;\n\tstruct list_head list;\n\tstruct cdev heap_cdev;\n};\n\nstatic LIST_HEAD(heap_list);\nstatic DEFINE_MUTEX(heap_list_lock);\nstatic dev_t dma_heap_devt;\nstatic struct class *dma_heap_class;\nstatic DEFINE_XARRAY_ALLOC(dma_heap_minors);\n\nstatic int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,\n\t\t\t\t unsigned int fd_flags,\n\t\t\t\t unsigned int heap_flags)\n{\n\tstruct dma_buf *dmabuf;\n\tint fd;\n\n\t \n\tlen = PAGE_ALIGN(len);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tdmabuf = heap->ops->allocate(heap, len, fd_flags, heap_flags);\n\tif (IS_ERR(dmabuf))\n\t\treturn PTR_ERR(dmabuf);\n\n\tfd = dma_buf_fd(dmabuf, fd_flags);\n\tif (fd < 0) {\n\t\tdma_buf_put(dmabuf);\n\t\t \n\t}\n\treturn fd;\n}\n\nstatic int dma_heap_open(struct inode *inode, struct file *file)\n{\n\tstruct dma_heap *heap;\n\n\theap = xa_load(&dma_heap_minors, iminor(inode));\n\tif (!heap) {\n\t\tpr_err(\"dma_heap: minor %d unknown.\\n\", iminor(inode));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfile->private_data = heap;\n\tnonseekable_open(inode, file);\n\n\treturn 0;\n}\n\nstatic long dma_heap_ioctl_allocate(struct file *file, void *data)\n{\n\tstruct dma_heap_allocation_data *heap_allocation = data;\n\tstruct dma_heap *heap = file->private_data;\n\tint fd;\n\n\tif (heap_allocation->fd)\n\t\treturn -EINVAL;\n\n\tif (heap_allocation->fd_flags & ~DMA_HEAP_VALID_FD_FLAGS)\n\t\treturn -EINVAL;\n\n\tif (heap_allocation->heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS)\n\t\treturn -EINVAL;\n\n\tfd = dma_heap_buffer_alloc(heap, heap_allocation->len,\n\t\t\t\t   heap_allocation->fd_flags,\n\t\t\t\t   heap_allocation->heap_flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\theap_allocation->fd = fd;\n\n\treturn 0;\n}\n\nstatic unsigned int dma_heap_ioctl_cmds[] = {\n\tDMA_HEAP_IOCTL_ALLOC,\n};\n\nstatic long dma_heap_ioctl(struct file *file, unsigned int ucmd,\n\t\t\t   unsigned long arg)\n{\n\tchar stack_kdata[128];\n\tchar *kdata = stack_kdata;\n\tunsigned int kcmd;\n\tunsigned int in_size, out_size, drv_size, ksize;\n\tint nr = _IOC_NR(ucmd);\n\tint ret = 0;\n\n\tif (nr >= ARRAY_SIZE(dma_heap_ioctl_cmds))\n\t\treturn -EINVAL;\n\n\tnr = array_index_nospec(nr, ARRAY_SIZE(dma_heap_ioctl_cmds));\n\t \n\tkcmd = dma_heap_ioctl_cmds[nr];\n\n\t \n\tdrv_size = _IOC_SIZE(kcmd);\n\tout_size = _IOC_SIZE(ucmd);\n\tin_size = out_size;\n\tif ((ucmd & kcmd & IOC_IN) == 0)\n\t\tin_size = 0;\n\tif ((ucmd & kcmd & IOC_OUT) == 0)\n\t\tout_size = 0;\n\tksize = max(max(in_size, out_size), drv_size);\n\n\t \n\tif (ksize > sizeof(stack_kdata)) {\n\t\tkdata = kmalloc(ksize, GFP_KERNEL);\n\t\tif (!kdata)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(kdata, (void __user *)arg, in_size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\t \n\tif (ksize > in_size)\n\t\tmemset(kdata + in_size, 0, ksize - in_size);\n\n\tswitch (kcmd) {\n\tcase DMA_HEAP_IOCTL_ALLOC:\n\t\tret = dma_heap_ioctl_allocate(file, kdata);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tgoto err;\n\t}\n\n\tif (copy_to_user((void __user *)arg, kdata, out_size) != 0)\n\t\tret = -EFAULT;\nerr:\n\tif (kdata != stack_kdata)\n\t\tkfree(kdata);\n\treturn ret;\n}\n\nstatic const struct file_operations dma_heap_fops = {\n\t.owner          = THIS_MODULE,\n\t.open\t\t= dma_heap_open,\n\t.unlocked_ioctl = dma_heap_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= dma_heap_ioctl,\n#endif\n};\n\n \nvoid *dma_heap_get_drvdata(struct dma_heap *heap)\n{\n\treturn heap->priv;\n}\n\n \nconst char *dma_heap_get_name(struct dma_heap *heap)\n{\n\treturn heap->name;\n}\n\nstruct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)\n{\n\tstruct dma_heap *heap, *h, *err_ret;\n\tstruct device *dev_ret;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!exp_info->name || !strcmp(exp_info->name, \"\")) {\n\t\tpr_err(\"dma_heap: Cannot add heap without a name\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!exp_info->ops || !exp_info->ops->allocate) {\n\t\tpr_err(\"dma_heap: Cannot add heap with invalid ops struct\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\theap = kzalloc(sizeof(*heap), GFP_KERNEL);\n\tif (!heap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\theap->name = exp_info->name;\n\theap->ops = exp_info->ops;\n\theap->priv = exp_info->priv;\n\n\t \n\tret = xa_alloc(&dma_heap_minors, &minor, heap,\n\t\t       XA_LIMIT(0, NUM_HEAP_MINORS - 1), GFP_KERNEL);\n\tif (ret < 0) {\n\t\tpr_err(\"dma_heap: Unable to get minor number for heap\\n\");\n\t\terr_ret = ERR_PTR(ret);\n\t\tgoto err0;\n\t}\n\n\t \n\theap->heap_devt = MKDEV(MAJOR(dma_heap_devt), minor);\n\n\tcdev_init(&heap->heap_cdev, &dma_heap_fops);\n\tret = cdev_add(&heap->heap_cdev, heap->heap_devt, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"dma_heap: Unable to add char device\\n\");\n\t\terr_ret = ERR_PTR(ret);\n\t\tgoto err1;\n\t}\n\n\tdev_ret = device_create(dma_heap_class,\n\t\t\t\tNULL,\n\t\t\t\theap->heap_devt,\n\t\t\t\tNULL,\n\t\t\t\theap->name);\n\tif (IS_ERR(dev_ret)) {\n\t\tpr_err(\"dma_heap: Unable to create device\\n\");\n\t\terr_ret = ERR_CAST(dev_ret);\n\t\tgoto err2;\n\t}\n\n\tmutex_lock(&heap_list_lock);\n\t \n\tlist_for_each_entry(h, &heap_list, list) {\n\t\tif (!strcmp(h->name, exp_info->name)) {\n\t\t\tmutex_unlock(&heap_list_lock);\n\t\t\tpr_err(\"dma_heap: Already registered heap named %s\\n\",\n\t\t\t       exp_info->name);\n\t\t\terr_ret = ERR_PTR(-EINVAL);\n\t\t\tgoto err3;\n\t\t}\n\t}\n\n\t \n\tlist_add(&heap->list, &heap_list);\n\tmutex_unlock(&heap_list_lock);\n\n\treturn heap;\n\nerr3:\n\tdevice_destroy(dma_heap_class, heap->heap_devt);\nerr2:\n\tcdev_del(&heap->heap_cdev);\nerr1:\n\txa_erase(&dma_heap_minors, minor);\nerr0:\n\tkfree(heap);\n\treturn err_ret;\n}\n\nstatic char *dma_heap_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"dma_heap/%s\", dev_name(dev));\n}\n\nstatic int dma_heap_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&dma_heap_devt, 0, NUM_HEAP_MINORS, DEVNAME);\n\tif (ret)\n\t\treturn ret;\n\n\tdma_heap_class = class_create(DEVNAME);\n\tif (IS_ERR(dma_heap_class)) {\n\t\tunregister_chrdev_region(dma_heap_devt, NUM_HEAP_MINORS);\n\t\treturn PTR_ERR(dma_heap_class);\n\t}\n\tdma_heap_class->devnode = dma_heap_devnode;\n\n\treturn 0;\n}\nsubsys_initcall(dma_heap_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}