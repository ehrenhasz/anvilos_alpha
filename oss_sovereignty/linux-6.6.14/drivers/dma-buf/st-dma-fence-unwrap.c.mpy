{
  "module_name": "st-dma-fence-unwrap.c",
  "hash_id": "72e06d2295223ff7b3c597fa2e7fd6cf421f64b1d93f90932863bea99f5b5863",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/st-dma-fence-unwrap.c",
  "human_readable_source": "\n\n \n\n#include <linux/dma-fence.h>\n#include <linux/dma-fence-array.h>\n#include <linux/dma-fence-chain.h>\n#include <linux/dma-fence-unwrap.h>\n\n#include \"selftest.h\"\n\n#define CHAIN_SZ (4 << 10)\n\nstruct mock_fence {\n\tstruct dma_fence base;\n\tspinlock_t lock;\n};\n\nstatic const char *mock_name(struct dma_fence *f)\n{\n\treturn \"mock\";\n}\n\nstatic const struct dma_fence_ops mock_ops = {\n\t.get_driver_name = mock_name,\n\t.get_timeline_name = mock_name,\n};\n\nstatic struct dma_fence *mock_fence(void)\n{\n\tstruct mock_fence *f;\n\n\tf = kmalloc(sizeof(*f), GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\n\tspin_lock_init(&f->lock);\n\tdma_fence_init(&f->base, &mock_ops, &f->lock,\n\t\t       dma_fence_context_alloc(1), 1);\n\n\treturn &f->base;\n}\n\nstatic struct dma_fence *mock_array(unsigned int num_fences, ...)\n{\n\tstruct dma_fence_array *array;\n\tstruct dma_fence **fences;\n\tva_list valist;\n\tint i;\n\n\tfences = kcalloc(num_fences, sizeof(*fences), GFP_KERNEL);\n\tif (!fences)\n\t\tgoto error_put;\n\n\tva_start(valist, num_fences);\n\tfor (i = 0; i < num_fences; ++i)\n\t\tfences[i] = va_arg(valist, typeof(*fences));\n\tva_end(valist);\n\n\tarray = dma_fence_array_create(num_fences, fences,\n\t\t\t\t       dma_fence_context_alloc(1),\n\t\t\t\t       1, false);\n\tif (!array)\n\t\tgoto error_free;\n\treturn &array->base;\n\nerror_free:\n\tkfree(fences);\n\nerror_put:\n\tva_start(valist, num_fences);\n\tfor (i = 0; i < num_fences; ++i)\n\t\tdma_fence_put(va_arg(valist, typeof(*fences)));\n\tva_end(valist);\n\treturn NULL;\n}\n\nstatic struct dma_fence *mock_chain(struct dma_fence *prev,\n\t\t\t\t    struct dma_fence *fence)\n{\n\tstruct dma_fence_chain *f;\n\n\tf = dma_fence_chain_alloc();\n\tif (!f) {\n\t\tdma_fence_put(prev);\n\t\tdma_fence_put(fence);\n\t\treturn NULL;\n\t}\n\n\tdma_fence_chain_init(f, prev, fence, 1);\n\treturn &f->base;\n}\n\nstatic int sanitycheck(void *arg)\n{\n\tstruct dma_fence *f, *chain, *array;\n\tint err = 0;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tarray = mock_array(1, f);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tchain = mock_chain(NULL, array);\n\tif (!chain)\n\t\treturn -ENOMEM;\n\n\tdma_fence_put(chain);\n\treturn err;\n}\n\nstatic int unwrap_array(void *arg)\n{\n\tstruct dma_fence *fence, *f1, *f2, *array;\n\tstruct dma_fence_unwrap iter;\n\tint err = 0;\n\n\tf1 = mock_fence();\n\tif (!f1)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f1);\n\n\tf2 = mock_fence();\n\tif (!f2) {\n\t\tdma_fence_put(f1);\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_fence_enable_sw_signaling(f2);\n\n\tarray = mock_array(2, f1, f2);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tdma_fence_unwrap_for_each(fence, &iter, array) {\n\t\tif (fence == f1) {\n\t\t\tf1 = NULL;\n\t\t} else if (fence == f2) {\n\t\t\tf2 = NULL;\n\t\t} else {\n\t\t\tpr_err(\"Unexpected fence!\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (f1 || f2) {\n\t\tpr_err(\"Not all fences seen!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tdma_fence_put(array);\n\treturn err;\n}\n\nstatic int unwrap_chain(void *arg)\n{\n\tstruct dma_fence *fence, *f1, *f2, *chain;\n\tstruct dma_fence_unwrap iter;\n\tint err = 0;\n\n\tf1 = mock_fence();\n\tif (!f1)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f1);\n\n\tf2 = mock_fence();\n\tif (!f2) {\n\t\tdma_fence_put(f1);\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_fence_enable_sw_signaling(f2);\n\n\tchain = mock_chain(f1, f2);\n\tif (!chain)\n\t\treturn -ENOMEM;\n\n\tdma_fence_unwrap_for_each(fence, &iter, chain) {\n\t\tif (fence == f1) {\n\t\t\tf1 = NULL;\n\t\t} else if (fence == f2) {\n\t\t\tf2 = NULL;\n\t\t} else {\n\t\t\tpr_err(\"Unexpected fence!\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (f1 || f2) {\n\t\tpr_err(\"Not all fences seen!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tdma_fence_put(chain);\n\treturn err;\n}\n\nstatic int unwrap_chain_array(void *arg)\n{\n\tstruct dma_fence *fence, *f1, *f2, *array, *chain;\n\tstruct dma_fence_unwrap iter;\n\tint err = 0;\n\n\tf1 = mock_fence();\n\tif (!f1)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f1);\n\n\tf2 = mock_fence();\n\tif (!f2) {\n\t\tdma_fence_put(f1);\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_fence_enable_sw_signaling(f2);\n\n\tarray = mock_array(2, f1, f2);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tchain = mock_chain(NULL, array);\n\tif (!chain)\n\t\treturn -ENOMEM;\n\n\tdma_fence_unwrap_for_each(fence, &iter, chain) {\n\t\tif (fence == f1) {\n\t\t\tf1 = NULL;\n\t\t} else if (fence == f2) {\n\t\t\tf2 = NULL;\n\t\t} else {\n\t\t\tpr_err(\"Unexpected fence!\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (f1 || f2) {\n\t\tpr_err(\"Not all fences seen!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tdma_fence_put(chain);\n\treturn err;\n}\n\nstatic int unwrap_merge(void *arg)\n{\n\tstruct dma_fence *fence, *f1, *f2, *f3;\n\tstruct dma_fence_unwrap iter;\n\tint err = 0;\n\n\tf1 = mock_fence();\n\tif (!f1)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f1);\n\n\tf2 = mock_fence();\n\tif (!f2) {\n\t\terr = -ENOMEM;\n\t\tgoto error_put_f1;\n\t}\n\n\tdma_fence_enable_sw_signaling(f2);\n\n\tf3 = dma_fence_unwrap_merge(f1, f2);\n\tif (!f3) {\n\t\terr = -ENOMEM;\n\t\tgoto error_put_f2;\n\t}\n\n\tdma_fence_unwrap_for_each(fence, &iter, f3) {\n\t\tif (fence == f1) {\n\t\t\tdma_fence_put(f1);\n\t\t\tf1 = NULL;\n\t\t} else if (fence == f2) {\n\t\t\tdma_fence_put(f2);\n\t\t\tf2 = NULL;\n\t\t} else {\n\t\t\tpr_err(\"Unexpected fence!\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (f1 || f2) {\n\t\tpr_err(\"Not all fences seen!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tdma_fence_put(f3);\nerror_put_f2:\n\tdma_fence_put(f2);\nerror_put_f1:\n\tdma_fence_put(f1);\n\treturn err;\n}\n\nstatic int unwrap_merge_complex(void *arg)\n{\n\tstruct dma_fence *fence, *f1, *f2, *f3, *f4, *f5;\n\tstruct dma_fence_unwrap iter;\n\tint err = -ENOMEM;\n\n\tf1 = mock_fence();\n\tif (!f1)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f1);\n\n\tf2 = mock_fence();\n\tif (!f2)\n\t\tgoto error_put_f1;\n\n\tdma_fence_enable_sw_signaling(f2);\n\n\tf3 = dma_fence_unwrap_merge(f1, f2);\n\tif (!f3)\n\t\tgoto error_put_f2;\n\n\t \n\tf4 = dma_fence_unwrap_merge(f2, f1);\n\tif (!f4)\n\t\tgoto error_put_f3;\n\n\t \n\tf5 = dma_fence_unwrap_merge(f3, f4, dma_fence_get_stub());\n\tif (!f5)\n\t\tgoto error_put_f4;\n\n\terr = 0;\n\tdma_fence_unwrap_for_each(fence, &iter, f5) {\n\t\tif (fence == f1) {\n\t\t\tdma_fence_put(f1);\n\t\t\tf1 = NULL;\n\t\t} else if (fence == f2) {\n\t\t\tdma_fence_put(f2);\n\t\t\tf2 = NULL;\n\t\t} else {\n\t\t\tpr_err(\"Unexpected fence!\\n\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (f1 || f2) {\n\t\tpr_err(\"Not all fences seen!\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tdma_fence_put(f5);\nerror_put_f4:\n\tdma_fence_put(f4);\nerror_put_f3:\n\tdma_fence_put(f3);\nerror_put_f2:\n\tdma_fence_put(f2);\nerror_put_f1:\n\tdma_fence_put(f1);\n\treturn err;\n}\n\nint dma_fence_unwrap(void)\n{\n\tstatic const struct subtest tests[] = {\n\t\tSUBTEST(sanitycheck),\n\t\tSUBTEST(unwrap_array),\n\t\tSUBTEST(unwrap_chain),\n\t\tSUBTEST(unwrap_chain_array),\n\t\tSUBTEST(unwrap_merge),\n\t\tSUBTEST(unwrap_merge_complex),\n\t};\n\n\treturn subtests(tests, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}