{
  "module_name": "st-dma-fence.c",
  "hash_id": "bd83677355fe002ccd7f063ad423be546ad16cf0cf18afac6e505214ef8666a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/st-dma-fence.c",
  "human_readable_source": " \n\n \n\n#include <linux/delay.h>\n#include <linux/dma-fence.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"selftest.h\"\n\nstatic struct kmem_cache *slab_fences;\n\nstatic struct mock_fence {\n\tstruct dma_fence base;\n\tstruct spinlock lock;\n} *to_mock_fence(struct dma_fence *f) {\n\treturn container_of(f, struct mock_fence, base);\n}\n\nstatic const char *mock_name(struct dma_fence *f)\n{\n\treturn \"mock\";\n}\n\nstatic void mock_fence_release(struct dma_fence *f)\n{\n\tkmem_cache_free(slab_fences, to_mock_fence(f));\n}\n\nstruct wait_cb {\n\tstruct dma_fence_cb cb;\n\tstruct task_struct *task;\n};\n\nstatic void mock_wakeup(struct dma_fence *f, struct dma_fence_cb *cb)\n{\n\twake_up_process(container_of(cb, struct wait_cb, cb)->task);\n}\n\nstatic long mock_wait(struct dma_fence *f, bool intr, long timeout)\n{\n\tconst int state = intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE;\n\tstruct wait_cb cb = { .task = current };\n\n\tif (dma_fence_add_callback(f, &cb.cb, mock_wakeup))\n\t\treturn timeout;\n\n\twhile (timeout) {\n\t\tset_current_state(state);\n\n\t\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &f->flags))\n\t\t\tbreak;\n\n\t\tif (signal_pending_state(state, current))\n\t\t\tbreak;\n\n\t\ttimeout = schedule_timeout(timeout);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!dma_fence_remove_callback(f, &cb.cb))\n\t\treturn timeout;\n\n\tif (signal_pending_state(state, current))\n\t\treturn -ERESTARTSYS;\n\n\treturn -ETIME;\n}\n\nstatic const struct dma_fence_ops mock_ops = {\n\t.get_driver_name = mock_name,\n\t.get_timeline_name = mock_name,\n\t.wait = mock_wait,\n\t.release = mock_fence_release,\n};\n\nstatic struct dma_fence *mock_fence(void)\n{\n\tstruct mock_fence *f;\n\n\tf = kmem_cache_alloc(slab_fences, GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\n\tspin_lock_init(&f->lock);\n\tdma_fence_init(&f->base, &mock_ops, &f->lock, 0, 0);\n\n\treturn &f->base;\n}\n\nstatic int sanitycheck(void *arg)\n{\n\tstruct dma_fence *f;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_fence_signal(f);\n\tdma_fence_put(f);\n\n\treturn 0;\n}\n\nstatic int test_signaling(void *arg)\n{\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tif (dma_fence_is_signaled(f)) {\n\t\tpr_err(\"Fence unexpectedly signaled on creation\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (dma_fence_signal(f)) {\n\t\tpr_err(\"Fence reported being already signaled\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (!dma_fence_is_signaled(f)) {\n\t\tpr_err(\"Fence not reporting signaled\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (!dma_fence_signal(f)) {\n\t\tpr_err(\"Fence reported not being already signaled\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstruct simple_cb {\n\tstruct dma_fence_cb cb;\n\tbool seen;\n};\n\nstatic void simple_callback(struct dma_fence *f, struct dma_fence_cb *cb)\n{\n\tsmp_store_mb(container_of(cb, struct simple_cb, cb)->seen, true);\n}\n\nstatic int test_add_callback(void *arg)\n{\n\tstruct simple_cb cb = {};\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tif (dma_fence_add_callback(f, &cb.cb, simple_callback)) {\n\t\tpr_err(\"Failed to add callback, fence already signaled!\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\tif (!cb.seen) {\n\t\tpr_err(\"Callback failed!\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstatic int test_late_add_callback(void *arg)\n{\n\tstruct simple_cb cb = {};\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_fence_signal(f);\n\n\tif (!dma_fence_add_callback(f, &cb.cb, simple_callback)) {\n\t\tpr_err(\"Added callback, but fence was already signaled!\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\tif (cb.seen) {\n\t\tpr_err(\"Callback called after failed attachment !\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstatic int test_rm_callback(void *arg)\n{\n\tstruct simple_cb cb = {};\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tif (dma_fence_add_callback(f, &cb.cb, simple_callback)) {\n\t\tpr_err(\"Failed to add callback, fence already signaled!\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (!dma_fence_remove_callback(f, &cb.cb)) {\n\t\tpr_err(\"Failed to remove callback!\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\tif (cb.seen) {\n\t\tpr_err(\"Callback still signaled after removal!\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstatic int test_late_rm_callback(void *arg)\n{\n\tstruct simple_cb cb = {};\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tif (dma_fence_add_callback(f, &cb.cb, simple_callback)) {\n\t\tpr_err(\"Failed to add callback, fence already signaled!\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\tif (!cb.seen) {\n\t\tpr_err(\"Callback failed!\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (dma_fence_remove_callback(f, &cb.cb)) {\n\t\tpr_err(\"Callback removal succeed after being executed!\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstatic int test_status(void *arg)\n{\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tif (dma_fence_get_status(f)) {\n\t\tpr_err(\"Fence unexpectedly has signaled status on creation\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\tif (!dma_fence_get_status(f)) {\n\t\tpr_err(\"Fence not reporting signaled status\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstatic int test_error(void *arg)\n{\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_fence_set_error(f, -EIO);\n\n\tif (dma_fence_get_status(f)) {\n\t\tpr_err(\"Fence unexpectedly has error status before signal\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\tif (dma_fence_get_status(f) != -EIO) {\n\t\tpr_err(\"Fence not reporting error status, got %d\\n\",\n\t\t       dma_fence_get_status(f));\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstatic int test_wait(void *arg)\n{\n\tstruct dma_fence *f;\n\tint err = -EINVAL;\n\n\tf = mock_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tif (dma_fence_wait_timeout(f, false, 0) != -ETIME) {\n\t\tpr_err(\"Wait reported complete before being signaled\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\n\n\tif (dma_fence_wait_timeout(f, false, 0) != 0) {\n\t\tpr_err(\"Wait reported incomplete after being signaled\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdma_fence_signal(f);\n\tdma_fence_put(f);\n\treturn err;\n}\n\nstruct wait_timer {\n\tstruct timer_list timer;\n\tstruct dma_fence *f;\n};\n\nstatic void wait_timer(struct timer_list *timer)\n{\n\tstruct wait_timer *wt = from_timer(wt, timer, timer);\n\n\tdma_fence_signal(wt->f);\n}\n\nstatic int test_wait_timeout(void *arg)\n{\n\tstruct wait_timer wt;\n\tint err = -EINVAL;\n\n\ttimer_setup_on_stack(&wt.timer, wait_timer, 0);\n\n\twt.f = mock_fence();\n\tif (!wt.f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(wt.f);\n\n\tif (dma_fence_wait_timeout(wt.f, false, 1) != -ETIME) {\n\t\tpr_err(\"Wait reported complete before being signaled\\n\");\n\t\tgoto err_free;\n\t}\n\n\tmod_timer(&wt.timer, jiffies + 1);\n\n\tif (dma_fence_wait_timeout(wt.f, false, 2) == -ETIME) {\n\t\tif (timer_pending(&wt.timer)) {\n\t\t\tpr_notice(\"Timer did not fire within the jiffie!\\n\");\n\t\t\terr = 0;  \n\t\t} else {\n\t\t\tpr_err(\"Wait reported incomplete after timeout\\n\");\n\t\t}\n\t\tgoto err_free;\n\t}\n\n\terr = 0;\nerr_free:\n\tdel_timer_sync(&wt.timer);\n\tdestroy_timer_on_stack(&wt.timer);\n\tdma_fence_signal(wt.f);\n\tdma_fence_put(wt.f);\n\treturn err;\n}\n\nstatic int test_stub(void *arg)\n{\n\tstruct dma_fence *f[64];\n\tint err = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(f); i++) {\n\t\tf[i] = dma_fence_get_stub();\n\t\tif (!dma_fence_is_signaled(f[i])) {\n\t\t\tpr_err(\"Obtained unsignaled stub fence!\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\terr = 0;\nerr:\n\twhile (i--)\n\t\tdma_fence_put(f[i]);\n\treturn err;\n}\n\n \n\nstruct race_thread {\n\tstruct dma_fence __rcu **fences;\n\tstruct task_struct *task;\n\tbool before;\n\tint id;\n};\n\nstatic void __wait_for_callbacks(struct dma_fence *f)\n{\n\tspin_lock_irq(f->lock);\n\tspin_unlock_irq(f->lock);\n}\n\nstatic int thread_signal_callback(void *arg)\n{\n\tconst struct race_thread *t = arg;\n\tunsigned long pass = 0;\n\tunsigned long miss = 0;\n\tint err = 0;\n\n\twhile (!err && !kthread_should_stop()) {\n\t\tstruct dma_fence *f1, *f2;\n\t\tstruct simple_cb cb;\n\n\t\tf1 = mock_fence();\n\t\tif (!f1) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdma_fence_enable_sw_signaling(f1);\n\n\t\trcu_assign_pointer(t->fences[t->id], f1);\n\t\tsmp_wmb();\n\n\t\trcu_read_lock();\n\t\tdo {\n\t\t\tf2 = dma_fence_get_rcu_safe(&t->fences[!t->id]);\n\t\t} while (!f2 && !kthread_should_stop());\n\t\trcu_read_unlock();\n\n\t\tif (t->before)\n\t\t\tdma_fence_signal(f1);\n\n\t\tsmp_store_mb(cb.seen, false);\n\t\tif (!f2 ||\n\t\t    dma_fence_add_callback(f2, &cb.cb, simple_callback)) {\n\t\t\tmiss++;\n\t\t\tcb.seen = true;\n\t\t}\n\n\t\tif (!t->before)\n\t\t\tdma_fence_signal(f1);\n\n\t\tif (!cb.seen) {\n\t\t\tdma_fence_wait(f2, false);\n\t\t\t__wait_for_callbacks(f2);\n\t\t}\n\n\t\tif (!READ_ONCE(cb.seen)) {\n\t\t\tpr_err(\"Callback not seen on thread %d, pass %lu (%lu misses), signaling %s add_callback; fence signaled? %s\\n\",\n\t\t\t       t->id, pass, miss,\n\t\t\t       t->before ? \"before\" : \"after\",\n\t\t\t       dma_fence_is_signaled(f2) ? \"yes\" : \"no\");\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tdma_fence_put(f2);\n\n\t\trcu_assign_pointer(t->fences[t->id], NULL);\n\t\tsmp_wmb();\n\n\t\tdma_fence_put(f1);\n\n\t\tpass++;\n\t}\n\n\tpr_info(\"%s[%d] completed %lu passes, %lu misses\\n\",\n\t\t__func__, t->id, pass, miss);\n\treturn err;\n}\n\nstatic int race_signal_callback(void *arg)\n{\n\tstruct dma_fence __rcu *f[2] = {};\n\tint ret = 0;\n\tint pass;\n\n\tfor (pass = 0; !ret && pass <= 1; pass++) {\n\t\tstruct race_thread t[2];\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(t); i++) {\n\t\t\tt[i].fences = f;\n\t\t\tt[i].id = i;\n\t\t\tt[i].before = pass;\n\t\t\tt[i].task = kthread_run(thread_signal_callback, &t[i],\n\t\t\t\t\t\t\"dma-fence:%d\", i);\n\t\t\tget_task_struct(t[i].task);\n\t\t}\n\n\t\tmsleep(50);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(t); i++) {\n\t\t\tint err;\n\n\t\t\terr = kthread_stop(t[i].task);\n\t\t\tif (err && !ret)\n\t\t\t\tret = err;\n\n\t\t\tput_task_struct(t[i].task);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint dma_fence(void)\n{\n\tstatic const struct subtest tests[] = {\n\t\tSUBTEST(sanitycheck),\n\t\tSUBTEST(test_signaling),\n\t\tSUBTEST(test_add_callback),\n\t\tSUBTEST(test_late_add_callback),\n\t\tSUBTEST(test_rm_callback),\n\t\tSUBTEST(test_late_rm_callback),\n\t\tSUBTEST(test_status),\n\t\tSUBTEST(test_error),\n\t\tSUBTEST(test_wait),\n\t\tSUBTEST(test_wait_timeout),\n\t\tSUBTEST(test_stub),\n\t\tSUBTEST(race_signal_callback),\n\t};\n\tint ret;\n\n\tpr_info(\"sizeof(dma_fence)=%zu\\n\", sizeof(struct dma_fence));\n\n\tslab_fences = KMEM_CACHE(mock_fence,\n\t\t\t\t SLAB_TYPESAFE_BY_RCU |\n\t\t\t\t SLAB_HWCACHE_ALIGN);\n\tif (!slab_fences)\n\t\treturn -ENOMEM;\n\n\tret = subtests(tests, NULL);\n\n\tkmem_cache_destroy(slab_fences);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}