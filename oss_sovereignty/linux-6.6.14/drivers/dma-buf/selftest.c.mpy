{
  "module_name": "selftest.c",
  "hash_id": "28ad2bc5067860182c10440c52abb1861f714b67d78c92851dd6a297bb205719",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/selftest.c",
  "human_readable_source": " \n\n \n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n\n#include \"selftest.h\"\n\nenum {\n#define selftest(n, func) __idx_##n,\n#include \"selftests.h\"\n#undef selftest\n};\n\n#define selftest(n, f) [__idx_##n] = { .name = #n, .func = f },\nstatic struct selftest {\n\tbool enabled;\n\tconst char *name;\n\tint (*func)(void);\n} selftests[] = {\n#include \"selftests.h\"\n};\n#undef selftest\n\n \n#define param(n) __PASTE(igt__, __PASTE(__PASTE(__LINE__, __), n))\n#define selftest_0(n, func, id) \\\nmodule_param_named(id, selftests[__idx_##n].enabled, bool, 0400);\n#define selftest(n, func) selftest_0(n, func, param(n))\n#include \"selftests.h\"\n#undef selftest\n\nint __sanitycheck__(void)\n{\n\tpr_debug(\"Hello World!\\n\");\n\treturn 0;\n}\n\nstatic char *__st_filter;\n\nstatic bool apply_subtest_filter(const char *caller, const char *name)\n{\n\tchar *filter, *sep, *tok;\n\tbool result = true;\n\n\tfilter = kstrdup(__st_filter, GFP_KERNEL);\n\tfor (sep = filter; (tok = strsep(&sep, \",\"));) {\n\t\tbool allow = true;\n\t\tchar *sl;\n\n\t\tif (*tok == '!') {\n\t\t\tallow = false;\n\t\t\ttok++;\n\t\t}\n\n\t\tif (*tok == '\\0')\n\t\t\tcontinue;\n\n\t\tsl = strchr(tok, '/');\n\t\tif (sl) {\n\t\t\t*sl++ = '\\0';\n\t\t\tif (strcmp(tok, caller)) {\n\t\t\t\tif (allow)\n\t\t\t\t\tresult = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttok = sl;\n\t\t}\n\n\t\tif (strcmp(tok, name)) {\n\t\t\tif (allow)\n\t\t\t\tresult = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = allow;\n\t\tbreak;\n\t}\n\tkfree(filter);\n\n\treturn result;\n}\n\nint\n__subtests(const char *caller, const struct subtest *st, int count, void *data)\n{\n\tint err;\n\n\tfor (; count--; st++) {\n\t\tcond_resched();\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tif (!apply_subtest_filter(caller, st->name))\n\t\t\tcontinue;\n\n\t\tpr_info(\"dma-buf: Running %s/%s\\n\", caller, st->name);\n\n\t\terr = st->func(data);\n\t\tif (err && err != -EINTR) {\n\t\t\tpr_err(\"dma-buf/%s: %s failed with error %d\\n\",\n\t\t\t       caller, st->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void set_default_test_all(struct selftest *st, unsigned long count)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (st[i].enabled)\n\t\t\treturn;\n\n\tfor (i = 0; i < count; i++)\n\t\tst[i].enabled = true;\n}\n\nstatic int run_selftests(struct selftest *st, unsigned long count)\n{\n\tint err = 0;\n\n\tset_default_test_all(st, count);\n\n\t \n\tfor (; count--; st++) {\n\t\tif (!st->enabled)\n\t\t\tcontinue;\n\n\t\tpr_info(\"dma-buf: Running %s\\n\", st->name);\n\t\terr = st->func();\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (WARN(err > 0 || err == -ENOTTY,\n\t\t \"%s returned %d, conflicting with selftest's magic values!\\n\",\n\t\t st->name, err))\n\t\terr = -1;\n\n\treturn err;\n}\n\nstatic int __init st_init(void)\n{\n\treturn run_selftests(selftests, ARRAY_SIZE(selftests));\n}\n\nstatic void __exit st_exit(void)\n{\n}\n\nmodule_param_named(st_filter, __st_filter, charp, 0400);\nmodule_init(st_init);\nmodule_exit(st_exit);\n\nMODULE_DESCRIPTION(\"Self-test harness for dma-buf\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}