{
  "module_name": "sync_file.c",
  "hash_id": "cb012cc9c64294a54b572fef37441a5d7ac9ade8736289399c6aebad0d9b503a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/sync_file.c",
  "human_readable_source": "\n \n\n#include <linux/dma-fence-unwrap.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/sync_file.h>\n#include <uapi/linux/sync_file.h>\n\nstatic const struct file_operations sync_file_fops;\n\nstatic struct sync_file *sync_file_alloc(void)\n{\n\tstruct sync_file *sync_file;\n\n\tsync_file = kzalloc(sizeof(*sync_file), GFP_KERNEL);\n\tif (!sync_file)\n\t\treturn NULL;\n\n\tsync_file->file = anon_inode_getfile(\"sync_file\", &sync_file_fops,\n\t\t\t\t\t     sync_file, 0);\n\tif (IS_ERR(sync_file->file))\n\t\tgoto err;\n\n\tinit_waitqueue_head(&sync_file->wq);\n\n\tINIT_LIST_HEAD(&sync_file->cb.node);\n\n\treturn sync_file;\n\nerr:\n\tkfree(sync_file);\n\treturn NULL;\n}\n\nstatic void fence_check_cb_func(struct dma_fence *f, struct dma_fence_cb *cb)\n{\n\tstruct sync_file *sync_file;\n\n\tsync_file = container_of(cb, struct sync_file, cb);\n\n\twake_up_all(&sync_file->wq);\n}\n\n \nstruct sync_file *sync_file_create(struct dma_fence *fence)\n{\n\tstruct sync_file *sync_file;\n\n\tsync_file = sync_file_alloc();\n\tif (!sync_file)\n\t\treturn NULL;\n\n\tsync_file->fence = dma_fence_get(fence);\n\n\treturn sync_file;\n}\nEXPORT_SYMBOL(sync_file_create);\n\nstatic struct sync_file *sync_file_fdget(int fd)\n{\n\tstruct file *file = fget(fd);\n\n\tif (!file)\n\t\treturn NULL;\n\n\tif (file->f_op != &sync_file_fops)\n\t\tgoto err;\n\n\treturn file->private_data;\n\nerr:\n\tfput(file);\n\treturn NULL;\n}\n\n \nstruct dma_fence *sync_file_get_fence(int fd)\n{\n\tstruct sync_file *sync_file;\n\tstruct dma_fence *fence;\n\n\tsync_file = sync_file_fdget(fd);\n\tif (!sync_file)\n\t\treturn NULL;\n\n\tfence = dma_fence_get(sync_file->fence);\n\tfput(sync_file->file);\n\n\treturn fence;\n}\nEXPORT_SYMBOL(sync_file_get_fence);\n\n \nchar *sync_file_get_name(struct sync_file *sync_file, char *buf, int len)\n{\n\tif (sync_file->user_name[0]) {\n\t\tstrscpy(buf, sync_file->user_name, len);\n\t} else {\n\t\tstruct dma_fence *fence = sync_file->fence;\n\n\t\tsnprintf(buf, len, \"%s-%s%llu-%lld\",\n\t\t\t fence->ops->get_driver_name(fence),\n\t\t\t fence->ops->get_timeline_name(fence),\n\t\t\t fence->context,\n\t\t\t fence->seqno);\n\t}\n\n\treturn buf;\n}\n\n \nstatic struct sync_file *sync_file_merge(const char *name, struct sync_file *a,\n\t\t\t\t\t struct sync_file *b)\n{\n\tstruct sync_file *sync_file;\n\tstruct dma_fence *fence;\n\n\tsync_file = sync_file_alloc();\n\tif (!sync_file)\n\t\treturn NULL;\n\n\tfence = dma_fence_unwrap_merge(a->fence, b->fence);\n\tif (!fence) {\n\t\tfput(sync_file->file);\n\t\treturn NULL;\n\t}\n\tsync_file->fence = fence;\n\tstrscpy(sync_file->user_name, name, sizeof(sync_file->user_name));\n\treturn sync_file;\n}\n\nstatic int sync_file_release(struct inode *inode, struct file *file)\n{\n\tstruct sync_file *sync_file = file->private_data;\n\n\tif (test_bit(POLL_ENABLED, &sync_file->flags))\n\t\tdma_fence_remove_callback(sync_file->fence, &sync_file->cb);\n\tdma_fence_put(sync_file->fence);\n\tkfree(sync_file);\n\n\treturn 0;\n}\n\nstatic __poll_t sync_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct sync_file *sync_file = file->private_data;\n\n\tpoll_wait(file, &sync_file->wq, wait);\n\n\tif (list_empty(&sync_file->cb.node) &&\n\t    !test_and_set_bit(POLL_ENABLED, &sync_file->flags)) {\n\t\tif (dma_fence_add_callback(sync_file->fence, &sync_file->cb,\n\t\t\t\t\t   fence_check_cb_func) < 0)\n\t\t\twake_up_all(&sync_file->wq);\n\t}\n\n\treturn dma_fence_is_signaled(sync_file->fence) ? EPOLLIN : 0;\n}\n\nstatic long sync_file_ioctl_merge(struct sync_file *sync_file,\n\t\t\t\t  unsigned long arg)\n{\n\tint fd = get_unused_fd_flags(O_CLOEXEC);\n\tint err;\n\tstruct sync_file *fence2, *fence3;\n\tstruct sync_merge_data data;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (copy_from_user(&data, (void __user *)arg, sizeof(data))) {\n\t\terr = -EFAULT;\n\t\tgoto err_put_fd;\n\t}\n\n\tif (data.flags || data.pad) {\n\t\terr = -EINVAL;\n\t\tgoto err_put_fd;\n\t}\n\n\tfence2 = sync_file_fdget(data.fd2);\n\tif (!fence2) {\n\t\terr = -ENOENT;\n\t\tgoto err_put_fd;\n\t}\n\n\tdata.name[sizeof(data.name) - 1] = '\\0';\n\tfence3 = sync_file_merge(data.name, sync_file, fence2);\n\tif (!fence3) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put_fence2;\n\t}\n\n\tdata.fence = fd;\n\tif (copy_to_user((void __user *)arg, &data, sizeof(data))) {\n\t\terr = -EFAULT;\n\t\tgoto err_put_fence3;\n\t}\n\n\tfd_install(fd, fence3->file);\n\tfput(fence2->file);\n\treturn 0;\n\nerr_put_fence3:\n\tfput(fence3->file);\n\nerr_put_fence2:\n\tfput(fence2->file);\n\nerr_put_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}\n\nstatic int sync_fill_fence_info(struct dma_fence *fence,\n\t\t\t\t struct sync_fence_info *info)\n{\n\tstrscpy(info->obj_name, fence->ops->get_timeline_name(fence),\n\t\tsizeof(info->obj_name));\n\tstrscpy(info->driver_name, fence->ops->get_driver_name(fence),\n\t\tsizeof(info->driver_name));\n\n\tinfo->status = dma_fence_get_status(fence);\n\tinfo->timestamp_ns =\n\t\tdma_fence_is_signaled(fence) ?\n\t\t\tktime_to_ns(dma_fence_timestamp(fence)) :\n\t\t\tktime_set(0, 0);\n\n\treturn info->status;\n}\n\nstatic long sync_file_ioctl_fence_info(struct sync_file *sync_file,\n\t\t\t\t       unsigned long arg)\n{\n\tstruct sync_fence_info *fence_info = NULL;\n\tstruct dma_fence_unwrap iter;\n\tstruct sync_file_info info;\n\tunsigned int num_fences;\n\tstruct dma_fence *fence;\n\tint ret;\n\t__u32 size;\n\n\tif (copy_from_user(&info, (void __user *)arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.flags || info.pad)\n\t\treturn -EINVAL;\n\n\tnum_fences = 0;\n\tdma_fence_unwrap_for_each(fence, &iter, sync_file->fence)\n\t\t++num_fences;\n\n\t \n\tif (!info.num_fences) {\n\t\tinfo.status = dma_fence_get_status(sync_file->fence);\n\t\tgoto no_fences;\n\t} else {\n\t\tinfo.status = 1;\n\t}\n\n\tif (info.num_fences < num_fences)\n\t\treturn -EINVAL;\n\n\tsize = num_fences * sizeof(*fence_info);\n\tfence_info = kzalloc(size, GFP_KERNEL);\n\tif (!fence_info)\n\t\treturn -ENOMEM;\n\n\tnum_fences = 0;\n\tdma_fence_unwrap_for_each(fence, &iter, sync_file->fence) {\n\t\tint status;\n\n\t\tstatus = sync_fill_fence_info(fence, &fence_info[num_fences++]);\n\t\tinfo.status = info.status <= 0 ? info.status : status;\n\t}\n\n\tif (copy_to_user(u64_to_user_ptr(info.sync_fence_info), fence_info,\n\t\t\t size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nno_fences:\n\tsync_file_get_name(sync_file, info.name, sizeof(info.name));\n\tinfo.num_fences = num_fences;\n\n\tif (copy_to_user((void __user *)arg, &info, sizeof(info)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\n\nout:\n\tkfree(fence_info);\n\n\treturn ret;\n}\n\nstatic long sync_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct sync_file *sync_file = file->private_data;\n\n\tswitch (cmd) {\n\tcase SYNC_IOC_MERGE:\n\t\treturn sync_file_ioctl_merge(sync_file, arg);\n\n\tcase SYNC_IOC_FILE_INFO:\n\t\treturn sync_file_ioctl_fence_info(sync_file, arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations sync_file_fops = {\n\t.release = sync_file_release,\n\t.poll = sync_file_poll,\n\t.unlocked_ioctl = sync_file_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}