{
  "module_name": "st-dma-resv.c",
  "hash_id": "634adad61455951bc5a5f77193fc3b009d9bae2f08b5413d9ee32666489501c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/st-dma-resv.c",
  "human_readable_source": " \n\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/dma-resv.h>\n\n#include \"selftest.h\"\n\nstatic struct spinlock fence_lock;\n\nstatic const char *fence_name(struct dma_fence *f)\n{\n\treturn \"selftest\";\n}\n\nstatic const struct dma_fence_ops fence_ops = {\n\t.get_driver_name = fence_name,\n\t.get_timeline_name = fence_name,\n};\n\nstatic struct dma_fence *alloc_fence(void)\n{\n\tstruct dma_fence *f;\n\n\tf = kmalloc(sizeof(*f), GFP_KERNEL);\n\tif (!f)\n\t\treturn NULL;\n\n\tdma_fence_init(f, &fence_ops, &fence_lock, 0, 0);\n\treturn f;\n}\n\nstatic int sanitycheck(void *arg)\n{\n\tstruct dma_resv resv;\n\tstruct dma_fence *f;\n\tint r;\n\n\tf = alloc_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_fence_signal(f);\n\tdma_fence_put(f);\n\n\tdma_resv_init(&resv);\n\tr = dma_resv_lock(&resv, NULL);\n\tif (r)\n\t\tpr_err(\"Resv locking failed\\n\");\n\telse\n\t\tdma_resv_unlock(&resv);\n\tdma_resv_fini(&resv);\n\treturn r;\n}\n\nstatic int test_signaling(void *arg)\n{\n\tenum dma_resv_usage usage = (unsigned long)arg;\n\tstruct dma_resv resv;\n\tstruct dma_fence *f;\n\tint r;\n\n\tf = alloc_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_resv_init(&resv);\n\tr = dma_resv_lock(&resv, NULL);\n\tif (r) {\n\t\tpr_err(\"Resv locking failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tr = dma_resv_reserve_fences(&resv, 1);\n\tif (r) {\n\t\tpr_err(\"Resv shared slot allocation failed\\n\");\n\t\tgoto err_unlock;\n\t}\n\n\tdma_resv_add_fence(&resv, f, usage);\n\tif (dma_resv_test_signaled(&resv, usage)) {\n\t\tpr_err(\"Resv unexpectedly signaled\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\tdma_fence_signal(f);\n\tif (!dma_resv_test_signaled(&resv, usage)) {\n\t\tpr_err(\"Resv not reporting signaled\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\nerr_unlock:\n\tdma_resv_unlock(&resv);\nerr_free:\n\tdma_resv_fini(&resv);\n\tdma_fence_put(f);\n\treturn r;\n}\n\nstatic int test_for_each(void *arg)\n{\n\tenum dma_resv_usage usage = (unsigned long)arg;\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *f, *fence;\n\tstruct dma_resv resv;\n\tint r;\n\n\tf = alloc_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_resv_init(&resv);\n\tr = dma_resv_lock(&resv, NULL);\n\tif (r) {\n\t\tpr_err(\"Resv locking failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tr = dma_resv_reserve_fences(&resv, 1);\n\tif (r) {\n\t\tpr_err(\"Resv shared slot allocation failed\\n\");\n\t\tgoto err_unlock;\n\t}\n\n\tdma_resv_add_fence(&resv, f, usage);\n\n\tr = -ENOENT;\n\tdma_resv_for_each_fence(&cursor, &resv, usage, fence) {\n\t\tif (!r) {\n\t\t\tpr_err(\"More than one fence found\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (f != fence) {\n\t\t\tpr_err(\"Unexpected fence\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (dma_resv_iter_usage(&cursor) != usage) {\n\t\t\tpr_err(\"Unexpected fence usage\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tr = 0;\n\t}\n\tif (r) {\n\t\tpr_err(\"No fence found\\n\");\n\t\tgoto err_unlock;\n\t}\n\tdma_fence_signal(f);\nerr_unlock:\n\tdma_resv_unlock(&resv);\nerr_free:\n\tdma_resv_fini(&resv);\n\tdma_fence_put(f);\n\treturn r;\n}\n\nstatic int test_for_each_unlocked(void *arg)\n{\n\tenum dma_resv_usage usage = (unsigned long)arg;\n\tstruct dma_resv_iter cursor;\n\tstruct dma_fence *f, *fence;\n\tstruct dma_resv resv;\n\tint r;\n\n\tf = alloc_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_resv_init(&resv);\n\tr = dma_resv_lock(&resv, NULL);\n\tif (r) {\n\t\tpr_err(\"Resv locking failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tr = dma_resv_reserve_fences(&resv, 1);\n\tif (r) {\n\t\tpr_err(\"Resv shared slot allocation failed\\n\");\n\t\tdma_resv_unlock(&resv);\n\t\tgoto err_free;\n\t}\n\n\tdma_resv_add_fence(&resv, f, usage);\n\tdma_resv_unlock(&resv);\n\n\tr = -ENOENT;\n\tdma_resv_iter_begin(&cursor, &resv, usage);\n\tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n\t\tif (!r) {\n\t\t\tpr_err(\"More than one fence found\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_iter_end;\n\t\t}\n\t\tif (!dma_resv_iter_is_restarted(&cursor)) {\n\t\t\tpr_err(\"No restart flag\\n\");\n\t\t\tgoto err_iter_end;\n\t\t}\n\t\tif (f != fence) {\n\t\t\tpr_err(\"Unexpected fence\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_iter_end;\n\t\t}\n\t\tif (dma_resv_iter_usage(&cursor) != usage) {\n\t\t\tpr_err(\"Unexpected fence usage\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_iter_end;\n\t\t}\n\n\t\t \n\t\tif (r == -ENOENT) {\n\t\t\tr = -EINVAL;\n\t\t\t \n\t\t\tcursor.fences = (void*)~0;\n\t\t} else if (r == -EINVAL) {\n\t\t\tr = 0;\n\t\t}\n\t}\n\tif (r)\n\t\tpr_err(\"No fence found\\n\");\nerr_iter_end:\n\tdma_resv_iter_end(&cursor);\n\tdma_fence_signal(f);\nerr_free:\n\tdma_resv_fini(&resv);\n\tdma_fence_put(f);\n\treturn r;\n}\n\nstatic int test_get_fences(void *arg)\n{\n\tenum dma_resv_usage usage = (unsigned long)arg;\n\tstruct dma_fence *f, **fences = NULL;\n\tstruct dma_resv resv;\n\tint r, i;\n\n\tf = alloc_fence();\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tdma_fence_enable_sw_signaling(f);\n\n\tdma_resv_init(&resv);\n\tr = dma_resv_lock(&resv, NULL);\n\tif (r) {\n\t\tpr_err(\"Resv locking failed\\n\");\n\t\tgoto err_resv;\n\t}\n\n\tr = dma_resv_reserve_fences(&resv, 1);\n\tif (r) {\n\t\tpr_err(\"Resv shared slot allocation failed\\n\");\n\t\tdma_resv_unlock(&resv);\n\t\tgoto err_resv;\n\t}\n\n\tdma_resv_add_fence(&resv, f, usage);\n\tdma_resv_unlock(&resv);\n\n\tr = dma_resv_get_fences(&resv, usage, &i, &fences);\n\tif (r) {\n\t\tpr_err(\"get_fences failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (i != 1 || fences[0] != f) {\n\t\tpr_err(\"get_fences returned unexpected fence\\n\");\n\t\tgoto err_free;\n\t}\n\n\tdma_fence_signal(f);\nerr_free:\n\twhile (i--)\n\t\tdma_fence_put(fences[i]);\n\tkfree(fences);\nerr_resv:\n\tdma_resv_fini(&resv);\n\tdma_fence_put(f);\n\treturn r;\n}\n\nint dma_resv(void)\n{\n\tstatic const struct subtest tests[] = {\n\t\tSUBTEST(sanitycheck),\n\t\tSUBTEST(test_signaling),\n\t\tSUBTEST(test_for_each),\n\t\tSUBTEST(test_for_each_unlocked),\n\t\tSUBTEST(test_get_fences),\n\t};\n\tenum dma_resv_usage usage;\n\tint r;\n\n\tspin_lock_init(&fence_lock);\n\tfor (usage = DMA_RESV_USAGE_KERNEL; usage <= DMA_RESV_USAGE_BOOKKEEP;\n\t     ++usage) {\n\t\tr = subtests(tests, (void *)(unsigned long)usage);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}