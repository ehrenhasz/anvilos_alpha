{
  "module_name": "sync_debug.c",
  "hash_id": "9e08aaebc4f347ca4af57c1c59a93706516baa37bcbf6124490d12d6fbe0e0ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/sync_debug.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include \"sync_debug.h\"\n\nstatic struct dentry *dbgfs;\n\nstatic LIST_HEAD(sync_timeline_list_head);\nstatic DEFINE_SPINLOCK(sync_timeline_list_lock);\nstatic LIST_HEAD(sync_file_list_head);\nstatic DEFINE_SPINLOCK(sync_file_list_lock);\n\nvoid sync_timeline_debug_add(struct sync_timeline *obj)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sync_timeline_list_lock, flags);\n\tlist_add_tail(&obj->sync_timeline_list, &sync_timeline_list_head);\n\tspin_unlock_irqrestore(&sync_timeline_list_lock, flags);\n}\n\nvoid sync_timeline_debug_remove(struct sync_timeline *obj)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sync_timeline_list_lock, flags);\n\tlist_del(&obj->sync_timeline_list);\n\tspin_unlock_irqrestore(&sync_timeline_list_lock, flags);\n}\n\nvoid sync_file_debug_add(struct sync_file *sync_file)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sync_file_list_lock, flags);\n\tlist_add_tail(&sync_file->sync_file_list, &sync_file_list_head);\n\tspin_unlock_irqrestore(&sync_file_list_lock, flags);\n}\n\nvoid sync_file_debug_remove(struct sync_file *sync_file)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sync_file_list_lock, flags);\n\tlist_del(&sync_file->sync_file_list);\n\tspin_unlock_irqrestore(&sync_file_list_lock, flags);\n}\n\nstatic const char *sync_status_str(int status)\n{\n\tif (status < 0)\n\t\treturn \"error\";\n\n\tif (status > 0)\n\t\treturn \"signaled\";\n\n\treturn \"active\";\n}\n\nstatic void sync_print_fence(struct seq_file *s,\n\t\t\t     struct dma_fence *fence, bool show)\n{\n\tstruct sync_timeline *parent = dma_fence_parent(fence);\n\tint status;\n\n\tstatus = dma_fence_get_status_locked(fence);\n\n\tseq_printf(s, \"  %s%sfence %s\",\n\t\t   show ? parent->name : \"\",\n\t\t   show ? \"_\" : \"\",\n\t\t   sync_status_str(status));\n\n\tif (test_bit(DMA_FENCE_FLAG_TIMESTAMP_BIT, &fence->flags)) {\n\t\tstruct timespec64 ts64 =\n\t\t\tktime_to_timespec64(fence->timestamp);\n\n\t\tseq_printf(s, \"@%lld.%09ld\", (s64)ts64.tv_sec, ts64.tv_nsec);\n\t}\n\n\tif (fence->ops->timeline_value_str &&\n\t\tfence->ops->fence_value_str) {\n\t\tchar value[64];\n\t\tbool success;\n\n\t\tfence->ops->fence_value_str(fence, value, sizeof(value));\n\t\tsuccess = strlen(value);\n\n\t\tif (success) {\n\t\t\tseq_printf(s, \": %s\", value);\n\n\t\t\tfence->ops->timeline_value_str(fence, value,\n\t\t\t\t\t\t       sizeof(value));\n\n\t\t\tif (strlen(value))\n\t\t\t\tseq_printf(s, \" / %s\", value);\n\t\t}\n\t}\n\n\tseq_putc(s, '\\n');\n}\n\nstatic void sync_print_obj(struct seq_file *s, struct sync_timeline *obj)\n{\n\tstruct list_head *pos;\n\n\tseq_printf(s, \"%s: %d\\n\", obj->name, obj->value);\n\n\tspin_lock_irq(&obj->lock);\n\tlist_for_each(pos, &obj->pt_list) {\n\t\tstruct sync_pt *pt = container_of(pos, struct sync_pt, link);\n\t\tsync_print_fence(s, &pt->base, false);\n\t}\n\tspin_unlock_irq(&obj->lock);\n}\n\nstatic void sync_print_sync_file(struct seq_file *s,\n\t\t\t\t  struct sync_file *sync_file)\n{\n\tchar buf[128];\n\tint i;\n\n\tseq_printf(s, \"[%p] %s: %s\\n\", sync_file,\n\t\t   sync_file_get_name(sync_file, buf, sizeof(buf)),\n\t\t   sync_status_str(dma_fence_get_status(sync_file->fence)));\n\n\tif (dma_fence_is_array(sync_file->fence)) {\n\t\tstruct dma_fence_array *array = to_dma_fence_array(sync_file->fence);\n\n\t\tfor (i = 0; i < array->num_fences; ++i)\n\t\t\tsync_print_fence(s, array->fences[i], true);\n\t} else {\n\t\tsync_print_fence(s, sync_file->fence, true);\n\t}\n}\n\nstatic int sync_info_debugfs_show(struct seq_file *s, void *unused)\n{\n\tstruct list_head *pos;\n\n\tseq_puts(s, \"objs:\\n--------------\\n\");\n\n\tspin_lock_irq(&sync_timeline_list_lock);\n\tlist_for_each(pos, &sync_timeline_list_head) {\n\t\tstruct sync_timeline *obj =\n\t\t\tcontainer_of(pos, struct sync_timeline,\n\t\t\t\t     sync_timeline_list);\n\n\t\tsync_print_obj(s, obj);\n\t\tseq_putc(s, '\\n');\n\t}\n\tspin_unlock_irq(&sync_timeline_list_lock);\n\n\tseq_puts(s, \"fences:\\n--------------\\n\");\n\n\tspin_lock_irq(&sync_file_list_lock);\n\tlist_for_each(pos, &sync_file_list_head) {\n\t\tstruct sync_file *sync_file =\n\t\t\tcontainer_of(pos, struct sync_file, sync_file_list);\n\n\t\tsync_print_sync_file(s, sync_file);\n\t\tseq_putc(s, '\\n');\n\t}\n\tspin_unlock_irq(&sync_file_list_lock);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sync_info_debugfs);\n\nstatic __init int sync_debugfs_init(void)\n{\n\tdbgfs = debugfs_create_dir(\"sync\", NULL);\n\n\t \n\tdebugfs_create_file_unsafe(\"info\", 0444, dbgfs, NULL,\n\t\t\t\t   &sync_info_debugfs_fops);\n\tdebugfs_create_file_unsafe(\"sw_sync\", 0644, dbgfs, NULL,\n\t\t\t\t   &sw_sync_debugfs_fops);\n\n\treturn 0;\n}\nlate_initcall(sync_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}