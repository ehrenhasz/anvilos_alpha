{
  "module_name": "dma-fence.c",
  "hash_id": "82a463640b17a69e7fedec64093d6770a0097cca608636c4eb7e252d392623a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/dma-buf/dma-fence.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/atomic.h>\n#include <linux/dma-fence.h>\n#include <linux/sched/signal.h>\n#include <linux/seq_file.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/dma_fence.h>\n\nEXPORT_TRACEPOINT_SYMBOL(dma_fence_emit);\nEXPORT_TRACEPOINT_SYMBOL(dma_fence_enable_signal);\nEXPORT_TRACEPOINT_SYMBOL(dma_fence_signaled);\n\nstatic DEFINE_SPINLOCK(dma_fence_stub_lock);\nstatic struct dma_fence dma_fence_stub;\n\n \nstatic atomic64_t dma_fence_context_counter = ATOMIC64_INIT(1);\n\n \n\n \n\nstatic const char *dma_fence_stub_get_name(struct dma_fence *fence)\n{\n        return \"stub\";\n}\n\nstatic const struct dma_fence_ops dma_fence_stub_ops = {\n\t.get_driver_name = dma_fence_stub_get_name,\n\t.get_timeline_name = dma_fence_stub_get_name,\n};\n\n \nstruct dma_fence *dma_fence_get_stub(void)\n{\n\tspin_lock(&dma_fence_stub_lock);\n\tif (!dma_fence_stub.ops) {\n\t\tdma_fence_init(&dma_fence_stub,\n\t\t\t       &dma_fence_stub_ops,\n\t\t\t       &dma_fence_stub_lock,\n\t\t\t       0, 0);\n\n\t\tset_bit(DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT,\n\t\t\t&dma_fence_stub.flags);\n\n\t\tdma_fence_signal_locked(&dma_fence_stub);\n\t}\n\tspin_unlock(&dma_fence_stub_lock);\n\n\treturn dma_fence_get(&dma_fence_stub);\n}\nEXPORT_SYMBOL(dma_fence_get_stub);\n\n \nstruct dma_fence *dma_fence_allocate_private_stub(ktime_t timestamp)\n{\n\tstruct dma_fence *fence;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (fence == NULL)\n\t\treturn NULL;\n\n\tdma_fence_init(fence,\n\t\t       &dma_fence_stub_ops,\n\t\t       &dma_fence_stub_lock,\n\t\t       0, 0);\n\n\tset_bit(DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT,\n\t\t&fence->flags);\n\n\tdma_fence_signal_timestamp(fence, timestamp);\n\n\treturn fence;\n}\nEXPORT_SYMBOL(dma_fence_allocate_private_stub);\n\n \nu64 dma_fence_context_alloc(unsigned num)\n{\n\tWARN_ON(!num);\n\treturn atomic64_fetch_add(num, &dma_fence_context_counter);\n}\nEXPORT_SYMBOL(dma_fence_context_alloc);\n\n \n#ifdef CONFIG_LOCKDEP\nstatic struct lockdep_map dma_fence_lockdep_map = {\n\t.name = \"dma_fence_map\"\n};\n\n \nbool dma_fence_begin_signalling(void)\n{\n\t \n\tif (lock_is_held_type(&dma_fence_lockdep_map, 1))\n\t\treturn true;\n\n\t \n\tif (in_atomic())\n\t\treturn true;\n\n\t \n\tlock_acquire(&dma_fence_lockdep_map, 0, 0, 1, 1, NULL, _RET_IP_);\n\n\treturn false;\n}\nEXPORT_SYMBOL(dma_fence_begin_signalling);\n\n \nvoid dma_fence_end_signalling(bool cookie)\n{\n\tif (cookie)\n\t\treturn;\n\n\tlock_release(&dma_fence_lockdep_map, _RET_IP_);\n}\nEXPORT_SYMBOL(dma_fence_end_signalling);\n\nvoid __dma_fence_might_wait(void)\n{\n\tbool tmp;\n\n\ttmp = lock_is_held_type(&dma_fence_lockdep_map, 1);\n\tif (tmp)\n\t\tlock_release(&dma_fence_lockdep_map, _THIS_IP_);\n\tlock_map_acquire(&dma_fence_lockdep_map);\n\tlock_map_release(&dma_fence_lockdep_map);\n\tif (tmp)\n\t\tlock_acquire(&dma_fence_lockdep_map, 0, 0, 1, 1, NULL, _THIS_IP_);\n}\n#endif\n\n\n \nint dma_fence_signal_timestamp_locked(struct dma_fence *fence,\n\t\t\t\t      ktime_t timestamp)\n{\n\tstruct dma_fence_cb *cur, *tmp;\n\tstruct list_head cb_list;\n\n\tlockdep_assert_held(fence->lock);\n\n\tif (unlikely(test_and_set_bit(DMA_FENCE_FLAG_SIGNALED_BIT,\n\t\t\t\t      &fence->flags)))\n\t\treturn -EINVAL;\n\n\t \n\tlist_replace(&fence->cb_list, &cb_list);\n\n\tfence->timestamp = timestamp;\n\tset_bit(DMA_FENCE_FLAG_TIMESTAMP_BIT, &fence->flags);\n\ttrace_dma_fence_signaled(fence);\n\n\tlist_for_each_entry_safe(cur, tmp, &cb_list, node) {\n\t\tINIT_LIST_HEAD(&cur->node);\n\t\tcur->func(fence, cur);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dma_fence_signal_timestamp_locked);\n\n \nint dma_fence_signal_timestamp(struct dma_fence *fence, ktime_t timestamp)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (!fence)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\tret = dma_fence_signal_timestamp_locked(fence, timestamp);\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_signal_timestamp);\n\n \nint dma_fence_signal_locked(struct dma_fence *fence)\n{\n\treturn dma_fence_signal_timestamp_locked(fence, ktime_get());\n}\nEXPORT_SYMBOL(dma_fence_signal_locked);\n\n \nint dma_fence_signal(struct dma_fence *fence)\n{\n\tunsigned long flags;\n\tint ret;\n\tbool tmp;\n\n\tif (!fence)\n\t\treturn -EINVAL;\n\n\ttmp = dma_fence_begin_signalling();\n\n\tspin_lock_irqsave(fence->lock, flags);\n\tret = dma_fence_signal_timestamp_locked(fence, ktime_get());\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\tdma_fence_end_signalling(tmp);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_signal);\n\n \nsigned long\ndma_fence_wait_timeout(struct dma_fence *fence, bool intr, signed long timeout)\n{\n\tsigned long ret;\n\n\tif (WARN_ON(timeout < 0))\n\t\treturn -EINVAL;\n\n\tmight_sleep();\n\n\t__dma_fence_might_wait();\n\n\tdma_fence_enable_sw_signaling(fence);\n\n\ttrace_dma_fence_wait_start(fence);\n\tif (fence->ops->wait)\n\t\tret = fence->ops->wait(fence, intr, timeout);\n\telse\n\t\tret = dma_fence_default_wait(fence, intr, timeout);\n\ttrace_dma_fence_wait_end(fence);\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_wait_timeout);\n\n \nvoid dma_fence_release(struct kref *kref)\n{\n\tstruct dma_fence *fence =\n\t\tcontainer_of(kref, struct dma_fence, refcount);\n\n\ttrace_dma_fence_destroy(fence);\n\n\tif (WARN(!list_empty(&fence->cb_list) &&\n\t\t !test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags),\n\t\t \"Fence %s:%s:%llx:%llx released with pending signals!\\n\",\n\t\t fence->ops->get_driver_name(fence),\n\t\t fence->ops->get_timeline_name(fence),\n\t\t fence->context, fence->seqno)) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tspin_lock_irqsave(fence->lock, flags);\n\t\tfence->error = -EDEADLK;\n\t\tdma_fence_signal_locked(fence);\n\t\tspin_unlock_irqrestore(fence->lock, flags);\n\t}\n\n\tif (fence->ops->release)\n\t\tfence->ops->release(fence);\n\telse\n\t\tdma_fence_free(fence);\n}\nEXPORT_SYMBOL(dma_fence_release);\n\n \nvoid dma_fence_free(struct dma_fence *fence)\n{\n\tkfree_rcu(fence, rcu);\n}\nEXPORT_SYMBOL(dma_fence_free);\n\nstatic bool __dma_fence_enable_signaling(struct dma_fence *fence)\n{\n\tbool was_set;\n\n\tlockdep_assert_held(fence->lock);\n\n\twas_set = test_and_set_bit(DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT,\n\t\t\t\t   &fence->flags);\n\n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags))\n\t\treturn false;\n\n\tif (!was_set && fence->ops->enable_signaling) {\n\t\ttrace_dma_fence_enable_signal(fence);\n\n\t\tif (!fence->ops->enable_signaling(fence)) {\n\t\t\tdma_fence_signal_locked(fence);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nvoid dma_fence_enable_sw_signaling(struct dma_fence *fence)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\t__dma_fence_enable_signaling(fence);\n\tspin_unlock_irqrestore(fence->lock, flags);\n}\nEXPORT_SYMBOL(dma_fence_enable_sw_signaling);\n\n \nint dma_fence_add_callback(struct dma_fence *fence, struct dma_fence_cb *cb,\n\t\t\t   dma_fence_func_t func)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (WARN_ON(!fence || !func))\n\t\treturn -EINVAL;\n\n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {\n\t\tINIT_LIST_HEAD(&cb->node);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irqsave(fence->lock, flags);\n\n\tif (__dma_fence_enable_signaling(fence)) {\n\t\tcb->func = func;\n\t\tlist_add_tail(&cb->node, &fence->cb_list);\n\t} else {\n\t\tINIT_LIST_HEAD(&cb->node);\n\t\tret = -ENOENT;\n\t}\n\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_add_callback);\n\n \nint dma_fence_get_status(struct dma_fence *fence)\n{\n\tunsigned long flags;\n\tint status;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\tstatus = dma_fence_get_status_locked(fence);\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\treturn status;\n}\nEXPORT_SYMBOL(dma_fence_get_status);\n\n \nbool\ndma_fence_remove_callback(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\n\tret = !list_empty(&cb->node);\n\tif (ret)\n\t\tlist_del_init(&cb->node);\n\n\tspin_unlock_irqrestore(fence->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_remove_callback);\n\nstruct default_wait_cb {\n\tstruct dma_fence_cb base;\n\tstruct task_struct *task;\n};\n\nstatic void\ndma_fence_default_wait_cb(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tstruct default_wait_cb *wait =\n\t\tcontainer_of(cb, struct default_wait_cb, base);\n\n\twake_up_state(wait->task, TASK_NORMAL);\n}\n\n \nsigned long\ndma_fence_default_wait(struct dma_fence *fence, bool intr, signed long timeout)\n{\n\tstruct default_wait_cb cb;\n\tunsigned long flags;\n\tsigned long ret = timeout ? timeout : 1;\n\n\tspin_lock_irqsave(fence->lock, flags);\n\n\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags))\n\t\tgoto out;\n\n\tif (intr && signal_pending(current)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out;\n\t}\n\n\tif (!timeout) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcb.base.func = dma_fence_default_wait_cb;\n\tcb.task = current;\n\tlist_add(&cb.base.node, &fence->cb_list);\n\n\twhile (!test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags) && ret > 0) {\n\t\tif (intr)\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(fence->lock, flags);\n\n\t\tret = schedule_timeout(ret);\n\n\t\tspin_lock_irqsave(fence->lock, flags);\n\t\tif (ret > 0 && intr && signal_pending(current))\n\t\t\tret = -ERESTARTSYS;\n\t}\n\n\tif (!list_empty(&cb.base.node))\n\t\tlist_del(&cb.base.node);\n\t__set_current_state(TASK_RUNNING);\n\nout:\n\tspin_unlock_irqrestore(fence->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_default_wait);\n\nstatic bool\ndma_fence_test_signaled_any(struct dma_fence **fences, uint32_t count,\n\t\t\t    uint32_t *idx)\n{\n\tint i;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct dma_fence *fence = fences[i];\n\t\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {\n\t\t\tif (idx)\n\t\t\t\t*idx = i;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \nsigned long\ndma_fence_wait_any_timeout(struct dma_fence **fences, uint32_t count,\n\t\t\t   bool intr, signed long timeout, uint32_t *idx)\n{\n\tstruct default_wait_cb *cb;\n\tsigned long ret = timeout;\n\tunsigned i;\n\n\tif (WARN_ON(!fences || !count || timeout < 0))\n\t\treturn -EINVAL;\n\n\tif (timeout == 0) {\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tif (dma_fence_is_signaled(fences[i])) {\n\t\t\t\tif (idx)\n\t\t\t\t\t*idx = i;\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\treturn 0;\n\t}\n\n\tcb = kcalloc(count, sizeof(struct default_wait_cb), GFP_KERNEL);\n\tif (cb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_cb;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct dma_fence *fence = fences[i];\n\n\t\tcb[i].task = current;\n\t\tif (dma_fence_add_callback(fence, &cb[i].base,\n\t\t\t\t\t   dma_fence_default_wait_cb)) {\n\t\t\t \n\t\t\tif (idx)\n\t\t\t\t*idx = i;\n\t\t\tgoto fence_rm_cb;\n\t\t}\n\t}\n\n\twhile (ret > 0) {\n\t\tif (intr)\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\tif (dma_fence_test_signaled_any(fences, count, idx))\n\t\t\tbreak;\n\n\t\tret = schedule_timeout(ret);\n\n\t\tif (ret > 0 && intr && signal_pending(current))\n\t\t\tret = -ERESTARTSYS;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\nfence_rm_cb:\n\twhile (i-- > 0)\n\t\tdma_fence_remove_callback(fences[i], &cb[i].base);\n\nerr_free_cb:\n\tkfree(cb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_fence_wait_any_timeout);\n\n \n\n \nvoid dma_fence_set_deadline(struct dma_fence *fence, ktime_t deadline)\n{\n\tif (fence->ops->set_deadline && !dma_fence_is_signaled(fence))\n\t\tfence->ops->set_deadline(fence, deadline);\n}\nEXPORT_SYMBOL(dma_fence_set_deadline);\n\n \nvoid dma_fence_describe(struct dma_fence *fence, struct seq_file *seq)\n{\n\tseq_printf(seq, \"%s %s seq %llu %ssignalled\\n\",\n\t\t   fence->ops->get_driver_name(fence),\n\t\t   fence->ops->get_timeline_name(fence), fence->seqno,\n\t\t   dma_fence_is_signaled(fence) ? \"\" : \"un\");\n}\nEXPORT_SYMBOL(dma_fence_describe);\n\n \nvoid\ndma_fence_init(struct dma_fence *fence, const struct dma_fence_ops *ops,\n\t       spinlock_t *lock, u64 context, u64 seqno)\n{\n\tBUG_ON(!lock);\n\tBUG_ON(!ops || !ops->get_driver_name || !ops->get_timeline_name);\n\n\tkref_init(&fence->refcount);\n\tfence->ops = ops;\n\tINIT_LIST_HEAD(&fence->cb_list);\n\tfence->lock = lock;\n\tfence->context = context;\n\tfence->seqno = seqno;\n\tfence->flags = 0UL;\n\tfence->error = 0;\n\n\ttrace_dma_fence_init(fence);\n}\nEXPORT_SYMBOL(dma_fence_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}