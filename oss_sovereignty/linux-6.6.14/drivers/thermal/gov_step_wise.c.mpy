{
  "module_name": "gov_step_wise.c",
  "hash_id": "1b7b40bf93b907088f4035e2d9a23201489200d63fc4c17e6e1d2673d45115e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/gov_step_wise.c",
  "human_readable_source": "\n \n\n#include <linux/thermal.h>\n#include <linux/minmax.h>\n#include \"thermal_trace.h\"\n\n#include \"thermal_core.h\"\n\n \nstatic unsigned long get_target_state(struct thermal_instance *instance,\n\t\t\t\tenum thermal_trend trend, bool throttle)\n{\n\tstruct thermal_cooling_device *cdev = instance->cdev;\n\tunsigned long cur_state;\n\tunsigned long next_target;\n\n\t \n\tcdev->ops->get_cur_state(cdev, &cur_state);\n\tnext_target = instance->target;\n\tdev_dbg(&cdev->device, \"cur_state=%ld\\n\", cur_state);\n\n\tif (!instance->initialized) {\n\t\tif (throttle) {\n\t\t\tnext_target = clamp((cur_state + 1), instance->lower, instance->upper);\n\t\t} else {\n\t\t\tnext_target = THERMAL_NO_TARGET;\n\t\t}\n\n\t\treturn next_target;\n\t}\n\n\tif (throttle) {\n\t\tif (trend == THERMAL_TREND_RAISING)\n\t\t\tnext_target = clamp((cur_state + 1), instance->lower, instance->upper);\n\t} else {\n\t\tif (trend == THERMAL_TREND_DROPPING) {\n\t\t\tif (cur_state <= instance->lower)\n\t\t\t\tnext_target = THERMAL_NO_TARGET;\n\t\t\telse\n\t\t\t\tnext_target = clamp((cur_state - 1), instance->lower, instance->upper);\n\t\t}\n\t}\n\n\treturn next_target;\n}\n\nstatic void update_passive_instance(struct thermal_zone_device *tz,\n\t\t\t\tenum thermal_trip_type type, int value)\n{\n\t \n\tif (type == THERMAL_TRIP_PASSIVE)\n\t\ttz->passive += value;\n}\n\nstatic void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip_id)\n{\n\tenum thermal_trend trend;\n\tstruct thermal_instance *instance;\n\tstruct thermal_trip trip;\n\tbool throttle = false;\n\tint old_target;\n\n\t__thermal_zone_get_trip(tz, trip_id, &trip);\n\n\ttrend = get_tz_trend(tz, trip_id);\n\n\tif (tz->temperature >= trip.temperature) {\n\t\tthrottle = true;\n\t\ttrace_thermal_zone_trip(tz, trip_id, trip.type);\n\t}\n\n\tdev_dbg(&tz->device, \"Trip%d[type=%d,temp=%d]:trend=%d,throttle=%d\\n\",\n\t\t\t\ttrip_id, trip.type, trip.temperature, trend, throttle);\n\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tif (instance->trip != trip_id)\n\t\t\tcontinue;\n\n\t\told_target = instance->target;\n\t\tinstance->target = get_target_state(instance, trend, throttle);\n\t\tdev_dbg(&instance->cdev->device, \"old_target=%d, target=%d\\n\",\n\t\t\t\t\told_target, (int)instance->target);\n\n\t\tif (instance->initialized && old_target == instance->target)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (old_target == THERMAL_NO_TARGET &&\n\t\t\tinstance->target != THERMAL_NO_TARGET)\n\t\t\tupdate_passive_instance(tz, trip.type, 1);\n\t\t \n\t\telse if (old_target != THERMAL_NO_TARGET &&\n\t\t\tinstance->target == THERMAL_NO_TARGET)\n\t\t\tupdate_passive_instance(tz, trip.type, -1);\n\n\t\tinstance->initialized = true;\n\t\tmutex_lock(&instance->cdev->lock);\n\t\tinstance->cdev->updated = false;  \n\t\tmutex_unlock(&instance->cdev->lock);\n\t}\n}\n\n \nstatic int step_wise_throttle(struct thermal_zone_device *tz, int trip)\n{\n\tstruct thermal_instance *instance;\n\n\tlockdep_assert_held(&tz->lock);\n\n\tthermal_zone_trip_update(tz, trip);\n\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node)\n\t\tthermal_cdev_update(instance->cdev);\n\n\treturn 0;\n}\n\nstatic struct thermal_governor thermal_gov_step_wise = {\n\t.name\t\t= \"step_wise\",\n\t.throttle\t= step_wise_throttle,\n};\nTHERMAL_GOVERNOR_DECLARE(thermal_gov_step_wise);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}