{
  "module_name": "rockchip_thermal.c",
  "hash_id": "7f14ffc7551a8df741ce90b6956022a9dfa9ce858ee81b6db74ad23a32390cb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/rockchip_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/thermal.h>\n#include <linux/mfd/syscon.h>\n#include <linux/pinctrl/consumer.h>\n\n \nenum tshut_mode {\n\tTSHUT_MODE_CRU = 0,\n\tTSHUT_MODE_GPIO,\n};\n\n \nenum tshut_polarity {\n\tTSHUT_LOW_ACTIVE = 0,\n\tTSHUT_HIGH_ACTIVE,\n};\n\n \nenum adc_sort_mode {\n\tADC_DECREMENT = 0,\n\tADC_INCREMENT,\n};\n\n#include \"thermal_hwmon.h\"\n\n \nstruct chip_tsadc_table {\n\tconst struct tsadc_table *id;\n\tunsigned int length;\n\tu32 data_mask;\n\tenum adc_sort_mode mode;\n};\n\n \nstruct rockchip_tsadc_chip {\n\t \n\tint chn_offset;\n\tint chn_num;\n\n\t \n\tint tshut_temp;\n\tenum tshut_mode tshut_mode;\n\tenum tshut_polarity tshut_polarity;\n\n\t \n\tvoid (*initialize)(struct regmap *grf,\n\t\t\t   void __iomem *reg, enum tshut_polarity p);\n\tvoid (*irq_ack)(void __iomem *reg);\n\tvoid (*control)(void __iomem *reg, bool on);\n\n\t \n\tint (*get_temp)(const struct chip_tsadc_table *table,\n\t\t\tint chn, void __iomem *reg, int *temp);\n\tint (*set_alarm_temp)(const struct chip_tsadc_table *table,\n\t\t\t      int chn, void __iomem *reg, int temp);\n\tint (*set_tshut_temp)(const struct chip_tsadc_table *table,\n\t\t\t      int chn, void __iomem *reg, int temp);\n\tvoid (*set_tshut_mode)(int chn, void __iomem *reg, enum tshut_mode m);\n\n\t \n\tstruct chip_tsadc_table table;\n};\n\n \nstruct rockchip_thermal_sensor {\n\tstruct rockchip_thermal_data *thermal;\n\tstruct thermal_zone_device *tzd;\n\tint id;\n};\n\n \nstruct rockchip_thermal_data {\n\tconst struct rockchip_tsadc_chip *chip;\n\tstruct platform_device *pdev;\n\tstruct reset_control *reset;\n\n\tstruct rockchip_thermal_sensor *sensors;\n\n\tstruct clk *clk;\n\tstruct clk *pclk;\n\n\tstruct regmap *grf;\n\tvoid __iomem *regs;\n\n\tint tshut_temp;\n\tenum tshut_mode tshut_mode;\n\tenum tshut_polarity tshut_polarity;\n};\n\n \n#define TSADCV2_USER_CON\t\t\t0x00\n#define TSADCV2_AUTO_CON\t\t\t0x04\n#define TSADCV2_INT_EN\t\t\t\t0x08\n#define TSADCV2_INT_PD\t\t\t\t0x0c\n#define TSADCV3_AUTO_SRC_CON\t\t\t0x0c\n#define TSADCV3_HT_INT_EN\t\t\t0x14\n#define TSADCV3_HSHUT_GPIO_INT_EN\t\t0x18\n#define TSADCV3_HSHUT_CRU_INT_EN\t\t0x1c\n#define TSADCV3_INT_PD\t\t\t\t0x24\n#define TSADCV3_HSHUT_PD\t\t\t0x28\n#define TSADCV2_DATA(chn)\t\t\t(0x20 + (chn) * 0x04)\n#define TSADCV2_COMP_INT(chn)\t\t        (0x30 + (chn) * 0x04)\n#define TSADCV2_COMP_SHUT(chn)\t\t        (0x40 + (chn) * 0x04)\n#define TSADCV3_DATA(chn)\t\t\t(0x2c + (chn) * 0x04)\n#define TSADCV3_COMP_INT(chn)\t\t        (0x6c + (chn) * 0x04)\n#define TSADCV3_COMP_SHUT(chn)\t\t        (0x10c + (chn) * 0x04)\n#define TSADCV2_HIGHT_INT_DEBOUNCE\t\t0x60\n#define TSADCV2_HIGHT_TSHUT_DEBOUNCE\t\t0x64\n#define TSADCV3_HIGHT_INT_DEBOUNCE\t\t0x14c\n#define TSADCV3_HIGHT_TSHUT_DEBOUNCE\t\t0x150\n#define TSADCV2_AUTO_PERIOD\t\t\t0x68\n#define TSADCV2_AUTO_PERIOD_HT\t\t\t0x6c\n#define TSADCV3_AUTO_PERIOD\t\t\t0x154\n#define TSADCV3_AUTO_PERIOD_HT\t\t\t0x158\n\n#define TSADCV2_AUTO_EN\t\t\t\tBIT(0)\n#define TSADCV2_AUTO_EN_MASK\t\t\tBIT(16)\n#define TSADCV2_AUTO_SRC_EN(chn)\t\tBIT(4 + (chn))\n#define TSADCV3_AUTO_SRC_EN(chn)\t\tBIT(chn)\n#define TSADCV3_AUTO_SRC_EN_MASK(chn)\t\tBIT(16 + chn)\n#define TSADCV2_AUTO_TSHUT_POLARITY_HIGH\tBIT(8)\n#define TSADCV2_AUTO_TSHUT_POLARITY_MASK\tBIT(24)\n\n#define TSADCV3_AUTO_Q_SEL_EN\t\t\tBIT(1)\n\n#define TSADCV2_INT_SRC_EN(chn)\t\t\tBIT(chn)\n#define TSADCV2_INT_SRC_EN_MASK(chn)\t\tBIT(16 + (chn))\n#define TSADCV2_SHUT_2GPIO_SRC_EN(chn)\t\tBIT(4 + (chn))\n#define TSADCV2_SHUT_2CRU_SRC_EN(chn)\t\tBIT(8 + (chn))\n\n#define TSADCV2_INT_PD_CLEAR_MASK\t\t~BIT(8)\n#define TSADCV3_INT_PD_CLEAR_MASK\t\t~BIT(16)\n#define TSADCV4_INT_PD_CLEAR_MASK\t\t0xffffffff\n\n#define TSADCV2_DATA_MASK\t\t\t0xfff\n#define TSADCV3_DATA_MASK\t\t\t0x3ff\n#define TSADCV4_DATA_MASK\t\t\t0x1ff\n\n#define TSADCV2_HIGHT_INT_DEBOUNCE_COUNT\t4\n#define TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT\t4\n#define TSADCV2_AUTO_PERIOD_TIME\t\t250  \n#define TSADCV2_AUTO_PERIOD_HT_TIME\t\t50   \n#define TSADCV3_AUTO_PERIOD_TIME\t\t1875  \n#define TSADCV3_AUTO_PERIOD_HT_TIME\t\t1875  \n\n#define TSADCV5_AUTO_PERIOD_TIME\t\t1622  \n#define TSADCV5_AUTO_PERIOD_HT_TIME\t\t1622  \n#define TSADCV6_AUTO_PERIOD_TIME\t\t5000  \n#define TSADCV6_AUTO_PERIOD_HT_TIME\t\t5000  \n\n#define TSADCV2_USER_INTER_PD_SOC\t\t0x340  \n#define TSADCV5_USER_INTER_PD_SOC\t\t0xfc0  \n\n#define GRF_SARADC_TESTBIT\t\t\t0x0e644\n#define GRF_TSADC_TESTBIT_L\t\t\t0x0e648\n#define GRF_TSADC_TESTBIT_H\t\t\t0x0e64c\n\n#define PX30_GRF_SOC_CON2\t\t\t0x0408\n\n#define RK3568_GRF_TSADC_CON\t\t\t0x0600\n#define RK3568_GRF_TSADC_ANA_REG0\t\t(0x10001 << 0)\n#define RK3568_GRF_TSADC_ANA_REG1\t\t(0x10001 << 1)\n#define RK3568_GRF_TSADC_ANA_REG2\t\t(0x10001 << 2)\n#define RK3568_GRF_TSADC_TSEN\t\t\t(0x10001 << 8)\n\n#define RK3588_GRF0_TSADC_CON\t\t\t0x0100\n\n#define RK3588_GRF0_TSADC_TRM\t\t\t(0xff0077 << 0)\n#define RK3588_GRF0_TSADC_SHUT_2CRU\t\t(0x30003 << 10)\n#define RK3588_GRF0_TSADC_SHUT_2GPIO\t\t(0x70007 << 12)\n\n#define GRF_SARADC_TESTBIT_ON\t\t\t(0x10001 << 2)\n#define GRF_TSADC_TESTBIT_H_ON\t\t\t(0x10001 << 2)\n#define GRF_TSADC_VCM_EN_L\t\t\t(0x10001 << 7)\n#define GRF_TSADC_VCM_EN_H\t\t\t(0x10001 << 7)\n\n#define GRF_CON_TSADC_CH_INV\t\t\t(0x10001 << 1)\n\n \nstruct tsadc_table {\n\tu32 code;\n\tint temp;\n};\n\nstatic const struct tsadc_table rv1108_table[] = {\n\t{0, -40000},\n\t{374, -40000},\n\t{382, -35000},\n\t{389, -30000},\n\t{397, -25000},\n\t{405, -20000},\n\t{413, -15000},\n\t{421, -10000},\n\t{429, -5000},\n\t{436, 0},\n\t{444, 5000},\n\t{452, 10000},\n\t{460, 15000},\n\t{468, 20000},\n\t{476, 25000},\n\t{483, 30000},\n\t{491, 35000},\n\t{499, 40000},\n\t{507, 45000},\n\t{515, 50000},\n\t{523, 55000},\n\t{531, 60000},\n\t{539, 65000},\n\t{547, 70000},\n\t{555, 75000},\n\t{562, 80000},\n\t{570, 85000},\n\t{578, 90000},\n\t{586, 95000},\n\t{594, 100000},\n\t{602, 105000},\n\t{610, 110000},\n\t{618, 115000},\n\t{626, 120000},\n\t{634, 125000},\n\t{TSADCV2_DATA_MASK, 125000},\n};\n\nstatic const struct tsadc_table rk3228_code_table[] = {\n\t{0, -40000},\n\t{588, -40000},\n\t{593, -35000},\n\t{598, -30000},\n\t{603, -25000},\n\t{608, -20000},\n\t{613, -15000},\n\t{618, -10000},\n\t{623, -5000},\n\t{629, 0},\n\t{634, 5000},\n\t{639, 10000},\n\t{644, 15000},\n\t{649, 20000},\n\t{654, 25000},\n\t{660, 30000},\n\t{665, 35000},\n\t{670, 40000},\n\t{675, 45000},\n\t{681, 50000},\n\t{686, 55000},\n\t{691, 60000},\n\t{696, 65000},\n\t{702, 70000},\n\t{707, 75000},\n\t{712, 80000},\n\t{717, 85000},\n\t{723, 90000},\n\t{728, 95000},\n\t{733, 100000},\n\t{738, 105000},\n\t{744, 110000},\n\t{749, 115000},\n\t{754, 120000},\n\t{760, 125000},\n\t{TSADCV2_DATA_MASK, 125000},\n};\n\nstatic const struct tsadc_table rk3288_code_table[] = {\n\t{TSADCV2_DATA_MASK, -40000},\n\t{3800, -40000},\n\t{3792, -35000},\n\t{3783, -30000},\n\t{3774, -25000},\n\t{3765, -20000},\n\t{3756, -15000},\n\t{3747, -10000},\n\t{3737, -5000},\n\t{3728, 0},\n\t{3718, 5000},\n\t{3708, 10000},\n\t{3698, 15000},\n\t{3688, 20000},\n\t{3678, 25000},\n\t{3667, 30000},\n\t{3656, 35000},\n\t{3645, 40000},\n\t{3634, 45000},\n\t{3623, 50000},\n\t{3611, 55000},\n\t{3600, 60000},\n\t{3588, 65000},\n\t{3575, 70000},\n\t{3563, 75000},\n\t{3550, 80000},\n\t{3537, 85000},\n\t{3524, 90000},\n\t{3510, 95000},\n\t{3496, 100000},\n\t{3482, 105000},\n\t{3467, 110000},\n\t{3452, 115000},\n\t{3437, 120000},\n\t{3421, 125000},\n\t{0, 125000},\n};\n\nstatic const struct tsadc_table rk3328_code_table[] = {\n\t{0, -40000},\n\t{296, -40000},\n\t{304, -35000},\n\t{313, -30000},\n\t{331, -20000},\n\t{340, -15000},\n\t{349, -10000},\n\t{359, -5000},\n\t{368, 0},\n\t{378, 5000},\n\t{388, 10000},\n\t{398, 15000},\n\t{408, 20000},\n\t{418, 25000},\n\t{429, 30000},\n\t{440, 35000},\n\t{451, 40000},\n\t{462, 45000},\n\t{473, 50000},\n\t{485, 55000},\n\t{496, 60000},\n\t{508, 65000},\n\t{521, 70000},\n\t{533, 75000},\n\t{546, 80000},\n\t{559, 85000},\n\t{572, 90000},\n\t{586, 95000},\n\t{600, 100000},\n\t{614, 105000},\n\t{629, 110000},\n\t{644, 115000},\n\t{659, 120000},\n\t{675, 125000},\n\t{TSADCV2_DATA_MASK, 125000},\n};\n\nstatic const struct tsadc_table rk3368_code_table[] = {\n\t{0, -40000},\n\t{106, -40000},\n\t{108, -35000},\n\t{110, -30000},\n\t{112, -25000},\n\t{114, -20000},\n\t{116, -15000},\n\t{118, -10000},\n\t{120, -5000},\n\t{122, 0},\n\t{124, 5000},\n\t{126, 10000},\n\t{128, 15000},\n\t{130, 20000},\n\t{132, 25000},\n\t{134, 30000},\n\t{136, 35000},\n\t{138, 40000},\n\t{140, 45000},\n\t{142, 50000},\n\t{144, 55000},\n\t{146, 60000},\n\t{148, 65000},\n\t{150, 70000},\n\t{152, 75000},\n\t{154, 80000},\n\t{156, 85000},\n\t{158, 90000},\n\t{160, 95000},\n\t{162, 100000},\n\t{163, 105000},\n\t{165, 110000},\n\t{167, 115000},\n\t{169, 120000},\n\t{171, 125000},\n\t{TSADCV3_DATA_MASK, 125000},\n};\n\nstatic const struct tsadc_table rk3399_code_table[] = {\n\t{0, -40000},\n\t{402, -40000},\n\t{410, -35000},\n\t{419, -30000},\n\t{427, -25000},\n\t{436, -20000},\n\t{444, -15000},\n\t{453, -10000},\n\t{461, -5000},\n\t{470, 0},\n\t{478, 5000},\n\t{487, 10000},\n\t{496, 15000},\n\t{504, 20000},\n\t{513, 25000},\n\t{521, 30000},\n\t{530, 35000},\n\t{538, 40000},\n\t{547, 45000},\n\t{555, 50000},\n\t{564, 55000},\n\t{573, 60000},\n\t{581, 65000},\n\t{590, 70000},\n\t{599, 75000},\n\t{607, 80000},\n\t{616, 85000},\n\t{624, 90000},\n\t{633, 95000},\n\t{642, 100000},\n\t{650, 105000},\n\t{659, 110000},\n\t{668, 115000},\n\t{677, 120000},\n\t{685, 125000},\n\t{TSADCV3_DATA_MASK, 125000},\n};\n\nstatic const struct tsadc_table rk3568_code_table[] = {\n\t{0, -40000},\n\t{1584, -40000},\n\t{1620, -35000},\n\t{1652, -30000},\n\t{1688, -25000},\n\t{1720, -20000},\n\t{1756, -15000},\n\t{1788, -10000},\n\t{1824, -5000},\n\t{1856, 0},\n\t{1892, 5000},\n\t{1924, 10000},\n\t{1956, 15000},\n\t{1992, 20000},\n\t{2024, 25000},\n\t{2060, 30000},\n\t{2092, 35000},\n\t{2128, 40000},\n\t{2160, 45000},\n\t{2196, 50000},\n\t{2228, 55000},\n\t{2264, 60000},\n\t{2300, 65000},\n\t{2332, 70000},\n\t{2368, 75000},\n\t{2400, 80000},\n\t{2436, 85000},\n\t{2468, 90000},\n\t{2500, 95000},\n\t{2536, 100000},\n\t{2572, 105000},\n\t{2604, 110000},\n\t{2636, 115000},\n\t{2672, 120000},\n\t{2704, 125000},\n\t{TSADCV2_DATA_MASK, 125000},\n};\n\nstatic const struct tsadc_table rk3588_code_table[] = {\n\t{0, -40000},\n\t{215, -40000},\n\t{285, 25000},\n\t{350, 85000},\n\t{395, 125000},\n\t{TSADCV4_DATA_MASK, 125000},\n};\n\nstatic u32 rk_tsadcv2_temp_to_code(const struct chip_tsadc_table *table,\n\t\t\t\t   int temp)\n{\n\tint high, low, mid;\n\tunsigned long num;\n\tunsigned int denom;\n\tu32 error = table->data_mask;\n\n\tlow = 0;\n\thigh = (table->length - 1) - 1;  \n\tmid = (high + low) / 2;\n\n\t \n\tif (temp < table->id[low].temp || temp > table->id[high].temp)\n\t\tgoto exit;\n\n\twhile (low <= high) {\n\t\tif (temp == table->id[mid].temp)\n\t\t\treturn table->id[mid].code;\n\t\telse if (temp < table->id[mid].temp)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t\tmid = (low + high) / 2;\n\t}\n\n\t \n\tnum = abs(table->id[mid + 1].code - table->id[mid].code);\n\tnum *= temp - table->id[mid].temp;\n\tdenom = table->id[mid + 1].temp - table->id[mid].temp;\n\n\tswitch (table->mode) {\n\tcase ADC_DECREMENT:\n\t\treturn table->id[mid].code - (num / denom);\n\tcase ADC_INCREMENT:\n\t\treturn table->id[mid].code + (num / denom);\n\tdefault:\n\t\tpr_err(\"%s: unknown table mode: %d\\n\", __func__, table->mode);\n\t\treturn error;\n\t}\n\nexit:\n\tpr_err(\"%s: invalid temperature, temp=%d error=%d\\n\",\n\t       __func__, temp, error);\n\treturn error;\n}\n\nstatic int rk_tsadcv2_code_to_temp(const struct chip_tsadc_table *table,\n\t\t\t\t   u32 code, int *temp)\n{\n\tunsigned int low = 1;\n\tunsigned int high = table->length - 1;\n\tunsigned int mid = (low + high) / 2;\n\tunsigned int num;\n\tunsigned long denom;\n\n\tWARN_ON(table->length < 2);\n\n\tswitch (table->mode) {\n\tcase ADC_DECREMENT:\n\t\tcode &= table->data_mask;\n\t\tif (code <= table->id[high].code)\n\t\t\treturn -EAGAIN;\t\t \n\n\t\twhile (low <= high) {\n\t\t\tif (code >= table->id[mid].code &&\n\t\t\t    code < table->id[mid - 1].code)\n\t\t\t\tbreak;\n\t\t\telse if (code < table->id[mid].code)\n\t\t\t\tlow = mid + 1;\n\t\t\telse\n\t\t\t\thigh = mid - 1;\n\n\t\t\tmid = (low + high) / 2;\n\t\t}\n\t\tbreak;\n\tcase ADC_INCREMENT:\n\t\tcode &= table->data_mask;\n\t\tif (code < table->id[low].code)\n\t\t\treturn -EAGAIN;\t\t \n\n\t\twhile (low <= high) {\n\t\t\tif (code <= table->id[mid].code &&\n\t\t\t    code > table->id[mid - 1].code)\n\t\t\t\tbreak;\n\t\t\telse if (code > table->id[mid].code)\n\t\t\t\tlow = mid + 1;\n\t\t\telse\n\t\t\t\thigh = mid - 1;\n\n\t\t\tmid = (low + high) / 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown table mode: %d\\n\", __func__, table->mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnum = table->id[mid].temp - table->id[mid - 1].temp;\n\tnum *= abs(table->id[mid - 1].code - code);\n\tdenom = abs(table->id[mid - 1].code - table->id[mid].code);\n\t*temp = table->id[mid - 1].temp + (num / denom);\n\n\treturn 0;\n}\n\n \nstatic void rk_tsadcv2_initialize(struct regmap *grf, void __iomem *regs,\n\t\t\t\t  enum tshut_polarity tshut_polarity)\n{\n\tif (tshut_polarity == TSHUT_HIGH_ACTIVE)\n\t\twritel_relaxed(0U | TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n\telse\n\t\twritel_relaxed(0U & ~TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n\n\twritel_relaxed(TSADCV2_AUTO_PERIOD_TIME, regs + TSADCV2_AUTO_PERIOD);\n\twritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\n\t\t       regs + TSADCV2_HIGHT_INT_DEBOUNCE);\n\twritel_relaxed(TSADCV2_AUTO_PERIOD_HT_TIME,\n\t\t       regs + TSADCV2_AUTO_PERIOD_HT);\n\twritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\n\t\t       regs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\n}\n\n \nstatic void rk_tsadcv3_initialize(struct regmap *grf, void __iomem *regs,\n\t\t\t\t  enum tshut_polarity tshut_polarity)\n{\n\t \n\tif (IS_ERR(grf)) {\n\t\t \n\t\twritel_relaxed(TSADCV2_USER_INTER_PD_SOC, regs +\n\t\t\t       TSADCV2_USER_CON);\n\n\t\twritel_relaxed(TSADCV2_AUTO_PERIOD_TIME,\n\t\t\t       regs + TSADCV2_AUTO_PERIOD);\n\t\twritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\n\t\t\t       regs + TSADCV2_HIGHT_INT_DEBOUNCE);\n\t\twritel_relaxed(TSADCV2_AUTO_PERIOD_HT_TIME,\n\t\t\t       regs + TSADCV2_AUTO_PERIOD_HT);\n\t\twritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\n\t\t\t       regs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\n\n\t} else {\n\t\t \n\t\tregmap_write(grf, GRF_TSADC_TESTBIT_L, GRF_TSADC_VCM_EN_L);\n\t\tregmap_write(grf, GRF_TSADC_TESTBIT_H, GRF_TSADC_VCM_EN_H);\n\n\t\tusleep_range(15, 100);  \n\t\tregmap_write(grf, GRF_SARADC_TESTBIT, GRF_SARADC_TESTBIT_ON);\n\t\tregmap_write(grf, GRF_TSADC_TESTBIT_H, GRF_TSADC_TESTBIT_H_ON);\n\t\tusleep_range(90, 200);  \n\n\t\twritel_relaxed(TSADCV3_AUTO_PERIOD_TIME,\n\t\t\t       regs + TSADCV2_AUTO_PERIOD);\n\t\twritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\n\t\t\t       regs + TSADCV2_HIGHT_INT_DEBOUNCE);\n\t\twritel_relaxed(TSADCV3_AUTO_PERIOD_HT_TIME,\n\t\t\t       regs + TSADCV2_AUTO_PERIOD_HT);\n\t\twritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\n\t\t\t       regs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\n\t}\n\n\tif (tshut_polarity == TSHUT_HIGH_ACTIVE)\n\t\twritel_relaxed(0U | TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n\telse\n\t\twritel_relaxed(0U & ~TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n}\n\nstatic void rk_tsadcv4_initialize(struct regmap *grf, void __iomem *regs,\n\t\t\t\t  enum tshut_polarity tshut_polarity)\n{\n\trk_tsadcv2_initialize(grf, regs, tshut_polarity);\n\tregmap_write(grf, PX30_GRF_SOC_CON2, GRF_CON_TSADC_CH_INV);\n}\n\nstatic void rk_tsadcv7_initialize(struct regmap *grf, void __iomem *regs,\n\t\t\t\t  enum tshut_polarity tshut_polarity)\n{\n\twritel_relaxed(TSADCV5_USER_INTER_PD_SOC, regs + TSADCV2_USER_CON);\n\twritel_relaxed(TSADCV5_AUTO_PERIOD_TIME, regs + TSADCV2_AUTO_PERIOD);\n\twritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\n\t\t       regs + TSADCV2_HIGHT_INT_DEBOUNCE);\n\twritel_relaxed(TSADCV5_AUTO_PERIOD_HT_TIME,\n\t\t       regs + TSADCV2_AUTO_PERIOD_HT);\n\twritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\n\t\t       regs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\n\n\tif (tshut_polarity == TSHUT_HIGH_ACTIVE)\n\t\twritel_relaxed(0U | TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n\telse\n\t\twritel_relaxed(0U & ~TSADCV2_AUTO_TSHUT_POLARITY_HIGH,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n\n\t \n\tif (!IS_ERR(grf)) {\n\t\tregmap_write(grf, RK3568_GRF_TSADC_CON, RK3568_GRF_TSADC_TSEN);\n\t\t \n\t\tudelay(15);\n\t\tregmap_write(grf, RK3568_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG0);\n\t\tregmap_write(grf, RK3568_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG1);\n\t\tregmap_write(grf, RK3568_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG2);\n\n\t\t \n\t\tusleep_range(100, 200);\n\t}\n}\n\nstatic void rk_tsadcv8_initialize(struct regmap *grf, void __iomem *regs,\n\t\t\t\t  enum tshut_polarity tshut_polarity)\n{\n\twritel_relaxed(TSADCV6_AUTO_PERIOD_TIME, regs + TSADCV3_AUTO_PERIOD);\n\twritel_relaxed(TSADCV6_AUTO_PERIOD_HT_TIME,\n\t\t       regs + TSADCV3_AUTO_PERIOD_HT);\n\twritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\n\t\t       regs + TSADCV3_HIGHT_INT_DEBOUNCE);\n\twritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\n\t\t       regs + TSADCV3_HIGHT_TSHUT_DEBOUNCE);\n\tif (tshut_polarity == TSHUT_HIGH_ACTIVE)\n\t\twritel_relaxed(TSADCV2_AUTO_TSHUT_POLARITY_HIGH |\n\t\t\t       TSADCV2_AUTO_TSHUT_POLARITY_MASK,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n\telse\n\t\twritel_relaxed(TSADCV2_AUTO_TSHUT_POLARITY_MASK,\n\t\t\t       regs + TSADCV2_AUTO_CON);\n}\n\nstatic void rk_tsadcv2_irq_ack(void __iomem *regs)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV2_INT_PD);\n\twritel_relaxed(val & TSADCV2_INT_PD_CLEAR_MASK, regs + TSADCV2_INT_PD);\n}\n\nstatic void rk_tsadcv3_irq_ack(void __iomem *regs)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV2_INT_PD);\n\twritel_relaxed(val & TSADCV3_INT_PD_CLEAR_MASK, regs + TSADCV2_INT_PD);\n}\n\nstatic void rk_tsadcv4_irq_ack(void __iomem *regs)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV3_INT_PD);\n\twritel_relaxed(val & TSADCV4_INT_PD_CLEAR_MASK, regs + TSADCV3_INT_PD);\n\tval = readl_relaxed(regs + TSADCV3_HSHUT_PD);\n\twritel_relaxed(val & TSADCV3_INT_PD_CLEAR_MASK,\n\t\t       regs + TSADCV3_HSHUT_PD);\n}\n\nstatic void rk_tsadcv2_control(void __iomem *regs, bool enable)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV2_AUTO_CON);\n\tif (enable)\n\t\tval |= TSADCV2_AUTO_EN;\n\telse\n\t\tval &= ~TSADCV2_AUTO_EN;\n\n\twritel_relaxed(val, regs + TSADCV2_AUTO_CON);\n}\n\n \nstatic void rk_tsadcv3_control(void __iomem *regs, bool enable)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV2_AUTO_CON);\n\tif (enable)\n\t\tval |= TSADCV2_AUTO_EN | TSADCV3_AUTO_Q_SEL_EN;\n\telse\n\t\tval &= ~TSADCV2_AUTO_EN;\n\n\twritel_relaxed(val, regs + TSADCV2_AUTO_CON);\n}\n\nstatic void rk_tsadcv4_control(void __iomem *regs, bool enable)\n{\n\tu32 val;\n\n\tif (enable)\n\t\tval = TSADCV2_AUTO_EN | TSADCV2_AUTO_EN_MASK;\n\telse\n\t\tval = TSADCV2_AUTO_EN_MASK;\n\n\twritel_relaxed(val, regs + TSADCV2_AUTO_CON);\n}\n\nstatic int rk_tsadcv2_get_temp(const struct chip_tsadc_table *table,\n\t\t\t       int chn, void __iomem *regs, int *temp)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV2_DATA(chn));\n\n\treturn rk_tsadcv2_code_to_temp(table, val, temp);\n}\n\nstatic int rk_tsadcv4_get_temp(const struct chip_tsadc_table *table,\n\t\t\t       int chn, void __iomem *regs, int *temp)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV3_DATA(chn));\n\n\treturn rk_tsadcv2_code_to_temp(table, val, temp);\n}\n\nstatic int rk_tsadcv2_alarm_temp(const struct chip_tsadc_table *table,\n\t\t\t\t int chn, void __iomem *regs, int temp)\n{\n\tu32 alarm_value;\n\tu32 int_en, int_clr;\n\n\t \n\tif (temp == INT_MAX) {\n\t\tint_clr = readl_relaxed(regs + TSADCV2_INT_EN);\n\t\tint_clr &= ~TSADCV2_INT_SRC_EN(chn);\n\t\twritel_relaxed(int_clr, regs + TSADCV2_INT_EN);\n\t\treturn 0;\n\t}\n\n\t \n\talarm_value = rk_tsadcv2_temp_to_code(table, temp);\n\tif (alarm_value == table->data_mask)\n\t\treturn -ERANGE;\n\n\twritel_relaxed(alarm_value & table->data_mask,\n\t\t       regs + TSADCV2_COMP_INT(chn));\n\n\tint_en = readl_relaxed(regs + TSADCV2_INT_EN);\n\tint_en |= TSADCV2_INT_SRC_EN(chn);\n\twritel_relaxed(int_en, regs + TSADCV2_INT_EN);\n\n\treturn 0;\n}\n\nstatic int rk_tsadcv3_alarm_temp(const struct chip_tsadc_table *table,\n\t\t\t\t int chn, void __iomem *regs, int temp)\n{\n\tu32 alarm_value;\n\n\t \n\tif (temp == INT_MAX) {\n\t\twritel_relaxed(TSADCV2_INT_SRC_EN_MASK(chn),\n\t\t\t       regs + TSADCV3_HT_INT_EN);\n\t\treturn 0;\n\t}\n\t \n\talarm_value = rk_tsadcv2_temp_to_code(table, temp);\n\tif (alarm_value == table->data_mask)\n\t\treturn -ERANGE;\n\twritel_relaxed(alarm_value & table->data_mask,\n\t\t       regs + TSADCV3_COMP_INT(chn));\n\twritel_relaxed(TSADCV2_INT_SRC_EN(chn) | TSADCV2_INT_SRC_EN_MASK(chn),\n\t\t       regs + TSADCV3_HT_INT_EN);\n\treturn 0;\n}\n\nstatic int rk_tsadcv2_tshut_temp(const struct chip_tsadc_table *table,\n\t\t\t\t int chn, void __iomem *regs, int temp)\n{\n\tu32 tshut_value, val;\n\n\t \n\ttshut_value = rk_tsadcv2_temp_to_code(table, temp);\n\tif (tshut_value == table->data_mask)\n\t\treturn -ERANGE;\n\n\twritel_relaxed(tshut_value, regs + TSADCV2_COMP_SHUT(chn));\n\n\t \n\tval = readl_relaxed(regs + TSADCV2_AUTO_CON);\n\twritel_relaxed(val | TSADCV2_AUTO_SRC_EN(chn), regs + TSADCV2_AUTO_CON);\n\n\treturn 0;\n}\n\nstatic int rk_tsadcv3_tshut_temp(const struct chip_tsadc_table *table,\n\t\t\t\t int chn, void __iomem *regs, int temp)\n{\n\tu32 tshut_value;\n\n\t \n\ttshut_value = rk_tsadcv2_temp_to_code(table, temp);\n\tif (tshut_value == table->data_mask)\n\t\treturn -ERANGE;\n\n\twritel_relaxed(tshut_value, regs + TSADCV3_COMP_SHUT(chn));\n\n\t \n\twritel_relaxed(TSADCV3_AUTO_SRC_EN(chn) | TSADCV3_AUTO_SRC_EN_MASK(chn),\n\t\t       regs + TSADCV3_AUTO_SRC_CON);\n\n\treturn 0;\n}\n\nstatic void rk_tsadcv2_tshut_mode(int chn, void __iomem *regs,\n\t\t\t\t  enum tshut_mode mode)\n{\n\tu32 val;\n\n\tval = readl_relaxed(regs + TSADCV2_INT_EN);\n\tif (mode == TSHUT_MODE_GPIO) {\n\t\tval &= ~TSADCV2_SHUT_2CRU_SRC_EN(chn);\n\t\tval |= TSADCV2_SHUT_2GPIO_SRC_EN(chn);\n\t} else {\n\t\tval &= ~TSADCV2_SHUT_2GPIO_SRC_EN(chn);\n\t\tval |= TSADCV2_SHUT_2CRU_SRC_EN(chn);\n\t}\n\n\twritel_relaxed(val, regs + TSADCV2_INT_EN);\n}\n\nstatic void rk_tsadcv3_tshut_mode(int chn, void __iomem *regs,\n\t\t\t\t  enum tshut_mode mode)\n{\n\tu32 val_gpio, val_cru;\n\n\tif (mode == TSHUT_MODE_GPIO) {\n\t\tval_gpio = TSADCV2_INT_SRC_EN(chn) | TSADCV2_INT_SRC_EN_MASK(chn);\n\t\tval_cru = TSADCV2_INT_SRC_EN_MASK(chn);\n\t} else {\n\t\tval_cru = TSADCV2_INT_SRC_EN(chn) | TSADCV2_INT_SRC_EN_MASK(chn);\n\t\tval_gpio = TSADCV2_INT_SRC_EN_MASK(chn);\n\t}\n\twritel_relaxed(val_gpio, regs + TSADCV3_HSHUT_GPIO_INT_EN);\n\twritel_relaxed(val_cru, regs + TSADCV3_HSHUT_CRU_INT_EN);\n}\n\nstatic const struct rockchip_tsadc_chip px30_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 2,  \n\n\t.tshut_mode = TSHUT_MODE_CRU,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv4_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3328_code_table,\n\t\t.length = ARRAY_SIZE(rk3328_code_table),\n\t\t.data_mask = TSADCV2_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rv1108_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 1,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv2_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rv1108_table,\n\t\t.length = ARRAY_SIZE(rv1108_table),\n\t\t.data_mask = TSADCV2_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3228_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 1,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv2_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3228_code_table,\n\t\t.length = ARRAY_SIZE(rk3228_code_table),\n\t\t.data_mask = TSADCV3_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3288_tsadc_data = {\n\t \n\t.chn_offset = 1,\n\t.chn_num = 2,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv2_initialize,\n\t.irq_ack = rk_tsadcv2_irq_ack,\n\t.control = rk_tsadcv2_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3288_code_table,\n\t\t.length = ARRAY_SIZE(rk3288_code_table),\n\t\t.data_mask = TSADCV2_DATA_MASK,\n\t\t.mode = ADC_DECREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3328_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 1,  \n\n\t.tshut_mode = TSHUT_MODE_CRU,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv2_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3328_code_table,\n\t\t.length = ARRAY_SIZE(rk3328_code_table),\n\t\t.data_mask = TSADCV2_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3366_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 2,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv3_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3228_code_table,\n\t\t.length = ARRAY_SIZE(rk3228_code_table),\n\t\t.data_mask = TSADCV3_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3368_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 2,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv2_initialize,\n\t.irq_ack = rk_tsadcv2_irq_ack,\n\t.control = rk_tsadcv2_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3368_code_table,\n\t\t.length = ARRAY_SIZE(rk3368_code_table),\n\t\t.data_mask = TSADCV3_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3399_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 2,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv3_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3399_code_table,\n\t\t.length = ARRAY_SIZE(rk3399_code_table),\n\t\t.data_mask = TSADCV3_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3568_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 2,  \n\n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\n\t.initialize = rk_tsadcv7_initialize,\n\t.irq_ack = rk_tsadcv3_irq_ack,\n\t.control = rk_tsadcv3_control,\n\t.get_temp = rk_tsadcv2_get_temp,\n\t.set_alarm_temp = rk_tsadcv2_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv2_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv2_tshut_mode,\n\n\t.table = {\n\t\t.id = rk3568_code_table,\n\t\t.length = ARRAY_SIZE(rk3568_code_table),\n\t\t.data_mask = TSADCV2_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct rockchip_tsadc_chip rk3588_tsadc_data = {\n\t \n\t.chn_offset = 0,\n\t.chn_num = 7,  \n\t.tshut_mode = TSHUT_MODE_GPIO,  \n\t.tshut_polarity = TSHUT_LOW_ACTIVE,  \n\t.tshut_temp = 95000,\n\t.initialize = rk_tsadcv8_initialize,\n\t.irq_ack = rk_tsadcv4_irq_ack,\n\t.control = rk_tsadcv4_control,\n\t.get_temp = rk_tsadcv4_get_temp,\n\t.set_alarm_temp = rk_tsadcv3_alarm_temp,\n\t.set_tshut_temp = rk_tsadcv3_tshut_temp,\n\t.set_tshut_mode = rk_tsadcv3_tshut_mode,\n\t.table = {\n\t\t.id = rk3588_code_table,\n\t\t.length = ARRAY_SIZE(rk3588_code_table),\n\t\t.data_mask = TSADCV4_DATA_MASK,\n\t\t.mode = ADC_INCREMENT,\n\t},\n};\n\nstatic const struct of_device_id of_rockchip_thermal_match[] = {\n\t{\t.compatible = \"rockchip,px30-tsadc\",\n\t\t.data = (void *)&px30_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rv1108-tsadc\",\n\t\t.data = (void *)&rv1108_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3228-tsadc\",\n\t\t.data = (void *)&rk3228_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3288-tsadc\",\n\t\t.data = (void *)&rk3288_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3328-tsadc\",\n\t\t.data = (void *)&rk3328_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3366-tsadc\",\n\t\t.data = (void *)&rk3366_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3368-tsadc\",\n\t\t.data = (void *)&rk3368_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3399-tsadc\",\n\t\t.data = (void *)&rk3399_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3568-tsadc\",\n\t\t.data = (void *)&rk3568_tsadc_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3588-tsadc\",\n\t\t.data = (void *)&rk3588_tsadc_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, of_rockchip_thermal_match);\n\nstatic void\nrockchip_thermal_toggle_sensor(struct rockchip_thermal_sensor *sensor, bool on)\n{\n\tstruct thermal_zone_device *tzd = sensor->tzd;\n\n\tif (on)\n\t\tthermal_zone_device_enable(tzd);\n\telse\n\t\tthermal_zone_device_disable(tzd);\n}\n\nstatic irqreturn_t rockchip_thermal_alarm_irq_thread(int irq, void *dev)\n{\n\tstruct rockchip_thermal_data *thermal = dev;\n\tint i;\n\n\tdev_dbg(&thermal->pdev->dev, \"thermal alarm\\n\");\n\n\tthermal->chip->irq_ack(thermal->regs);\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++)\n\t\tthermal_zone_device_update(thermal->sensors[i].tzd,\n\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rockchip_thermal_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct rockchip_thermal_sensor *sensor = thermal_zone_device_priv(tz);\n\tstruct rockchip_thermal_data *thermal = sensor->thermal;\n\tconst struct rockchip_tsadc_chip *tsadc = thermal->chip;\n\n\tdev_dbg(&thermal->pdev->dev, \"%s: sensor %d: low: %d, high %d\\n\",\n\t\t__func__, sensor->id, low, high);\n\n\treturn tsadc->set_alarm_temp(&tsadc->table,\n\t\t\t\t     sensor->id, thermal->regs, high);\n}\n\nstatic int rockchip_thermal_get_temp(struct thermal_zone_device *tz, int *out_temp)\n{\n\tstruct rockchip_thermal_sensor *sensor = thermal_zone_device_priv(tz);\n\tstruct rockchip_thermal_data *thermal = sensor->thermal;\n\tconst struct rockchip_tsadc_chip *tsadc = sensor->thermal->chip;\n\tint retval;\n\n\tretval = tsadc->get_temp(&tsadc->table,\n\t\t\t\t sensor->id, thermal->regs, out_temp);\n\treturn retval;\n}\n\nstatic const struct thermal_zone_device_ops rockchip_of_thermal_ops = {\n\t.get_temp = rockchip_thermal_get_temp,\n\t.set_trips = rockchip_thermal_set_trips,\n};\n\nstatic int rockchip_configure_from_dt(struct device *dev,\n\t\t\t\t      struct device_node *np,\n\t\t\t\t      struct rockchip_thermal_data *thermal)\n{\n\tu32 shut_temp, tshut_mode, tshut_polarity;\n\n\tif (of_property_read_u32(np, \"rockchip,hw-tshut-temp\", &shut_temp)) {\n\t\tdev_warn(dev,\n\t\t\t \"Missing tshut temp property, using default %d\\n\",\n\t\t\t thermal->chip->tshut_temp);\n\t\tthermal->tshut_temp = thermal->chip->tshut_temp;\n\t} else {\n\t\tif (shut_temp > INT_MAX) {\n\t\t\tdev_err(dev, \"Invalid tshut temperature specified: %d\\n\",\n\t\t\t\tshut_temp);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tthermal->tshut_temp = shut_temp;\n\t}\n\n\tif (of_property_read_u32(np, \"rockchip,hw-tshut-mode\", &tshut_mode)) {\n\t\tdev_warn(dev,\n\t\t\t \"Missing tshut mode property, using default (%s)\\n\",\n\t\t\t thermal->chip->tshut_mode == TSHUT_MODE_GPIO ?\n\t\t\t\t\"gpio\" : \"cru\");\n\t\tthermal->tshut_mode = thermal->chip->tshut_mode;\n\t} else {\n\t\tthermal->tshut_mode = tshut_mode;\n\t}\n\n\tif (thermal->tshut_mode > 1) {\n\t\tdev_err(dev, \"Invalid tshut mode specified: %d\\n\",\n\t\t\tthermal->tshut_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(np, \"rockchip,hw-tshut-polarity\",\n\t\t\t\t &tshut_polarity)) {\n\t\tdev_warn(dev,\n\t\t\t \"Missing tshut-polarity property, using default (%s)\\n\",\n\t\t\t thermal->chip->tshut_polarity == TSHUT_LOW_ACTIVE ?\n\t\t\t\t\"low\" : \"high\");\n\t\tthermal->tshut_polarity = thermal->chip->tshut_polarity;\n\t} else {\n\t\tthermal->tshut_polarity = tshut_polarity;\n\t}\n\n\tif (thermal->tshut_polarity > 1) {\n\t\tdev_err(dev, \"Invalid tshut-polarity specified: %d\\n\",\n\t\t\tthermal->tshut_polarity);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tthermal->grf = syscon_regmap_lookup_by_phandle(np, \"rockchip,grf\");\n\tif (IS_ERR(thermal->grf))\n\t\tdev_warn(dev, \"Missing rockchip,grf property\\n\");\n\n\treturn 0;\n}\n\nstatic int\nrockchip_thermal_register_sensor(struct platform_device *pdev,\n\t\t\t\t struct rockchip_thermal_data *thermal,\n\t\t\t\t struct rockchip_thermal_sensor *sensor,\n\t\t\t\t int id)\n{\n\tconst struct rockchip_tsadc_chip *tsadc = thermal->chip;\n\tint error;\n\n\ttsadc->set_tshut_mode(id, thermal->regs, thermal->tshut_mode);\n\n\terror = tsadc->set_tshut_temp(&tsadc->table, id, thermal->regs,\n\t\t\t      thermal->tshut_temp);\n\tif (error)\n\t\tdev_err(&pdev->dev, \"%s: invalid tshut=%d, error=%d\\n\",\n\t\t\t__func__, thermal->tshut_temp, error);\n\n\tsensor->thermal = thermal;\n\tsensor->id = id;\n\tsensor->tzd = devm_thermal_of_zone_register(&pdev->dev, id, sensor,\n\t\t\t\t\t\t    &rockchip_of_thermal_ops);\n\tif (IS_ERR(sensor->tzd)) {\n\t\terror = PTR_ERR(sensor->tzd);\n\t\tdev_err(&pdev->dev, \"failed to register sensor %d: %d\\n\",\n\t\t\tid, error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rockchip_thermal_reset_controller(struct reset_control *reset)\n{\n\treset_control_assert(reset);\n\tusleep_range(10, 20);\n\treset_control_deassert(reset);\n}\n\nstatic int rockchip_thermal_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct rockchip_thermal_data *thermal;\n\tint irq;\n\tint i;\n\tint error;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tthermal = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_thermal_data),\n\t\t\t       GFP_KERNEL);\n\tif (!thermal)\n\t\treturn -ENOMEM;\n\n\tthermal->pdev = pdev;\n\n\tthermal->chip = device_get_match_data(&pdev->dev);\n\tif (!thermal->chip)\n\t\treturn -EINVAL;\n\n\tthermal->sensors = devm_kcalloc(&pdev->dev, thermal->chip->chn_num,\n\t\t\t\t\tsizeof(*thermal->sensors), GFP_KERNEL);\n\tif (!thermal->sensors)\n\t\treturn -ENOMEM;\n\n\tthermal->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(thermal->regs))\n\t\treturn PTR_ERR(thermal->regs);\n\n\tthermal->reset = devm_reset_control_array_get_exclusive(&pdev->dev);\n\tif (IS_ERR(thermal->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(thermal->reset),\n\t\t\t\t     \"failed to get tsadc reset.\\n\");\n\n\tthermal->clk = devm_clk_get_enabled(&pdev->dev, \"tsadc\");\n\tif (IS_ERR(thermal->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(thermal->clk),\n\t\t\t\t     \"failed to get tsadc clock.\\n\");\n\n\tthermal->pclk = devm_clk_get_enabled(&pdev->dev, \"apb_pclk\");\n\tif (IS_ERR(thermal->pclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(thermal->pclk),\n\t\t\t\t     \"failed to get apb_pclk clock.\\n\");\n\n\trockchip_thermal_reset_controller(thermal->reset);\n\n\terror = rockchip_configure_from_dt(&pdev->dev, np, thermal);\n\tif (error)\n\t\treturn dev_err_probe(&pdev->dev, error,\n\t\t\t\t\"failed to parse device tree data\\n\");\n\n\tthermal->chip->initialize(thermal->grf, thermal->regs,\n\t\t\t\t  thermal->tshut_polarity);\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++) {\n\t\terror = rockchip_thermal_register_sensor(pdev, thermal,\n\t\t\t\t\t\t&thermal->sensors[i],\n\t\t\t\t\t\tthermal->chip->chn_offset + i);\n\t\tif (error)\n\t\t\treturn dev_err_probe(&pdev->dev, error,\n\t\t\t\t\"failed to register sensor[%d].\\n\", i);\n\t}\n\n\terror = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t  &rockchip_thermal_alarm_irq_thread,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"rockchip_thermal\", thermal);\n\tif (error)\n\t\treturn dev_err_probe(&pdev->dev, error,\n\t\t\t\t     \"failed to request tsadc irq.\\n\");\n\n\tthermal->chip->control(thermal->regs, true);\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++) {\n\t\trockchip_thermal_toggle_sensor(&thermal->sensors[i], true);\n\t\terror = thermal_add_hwmon_sysfs(thermal->sensors[i].tzd);\n\t\tif (error)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"failed to register sensor %d with hwmon: %d\\n\",\n\t\t\t\t i, error);\n\t}\n\n\tplatform_set_drvdata(pdev, thermal);\n\n\treturn 0;\n}\n\nstatic int rockchip_thermal_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++) {\n\t\tstruct rockchip_thermal_sensor *sensor = &thermal->sensors[i];\n\n\t\tthermal_remove_hwmon_sysfs(sensor->tzd);\n\t\trockchip_thermal_toggle_sensor(sensor, false);\n\t}\n\n\tthermal->chip->control(thermal->regs, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rockchip_thermal_suspend(struct device *dev)\n{\n\tstruct rockchip_thermal_data *thermal = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++)\n\t\trockchip_thermal_toggle_sensor(&thermal->sensors[i], false);\n\n\tthermal->chip->control(thermal->regs, false);\n\n\tclk_disable(thermal->pclk);\n\tclk_disable(thermal->clk);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rockchip_thermal_resume(struct device *dev)\n{\n\tstruct rockchip_thermal_data *thermal = dev_get_drvdata(dev);\n\tint i;\n\tint error;\n\n\terror = clk_enable(thermal->clk);\n\tif (error)\n\t\treturn error;\n\n\terror = clk_enable(thermal->pclk);\n\tif (error) {\n\t\tclk_disable(thermal->clk);\n\t\treturn error;\n\t}\n\n\trockchip_thermal_reset_controller(thermal->reset);\n\n\tthermal->chip->initialize(thermal->grf, thermal->regs,\n\t\t\t\t  thermal->tshut_polarity);\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++) {\n\t\tint id = thermal->sensors[i].id;\n\n\t\tthermal->chip->set_tshut_mode(id, thermal->regs,\n\t\t\t\t\t      thermal->tshut_mode);\n\n\t\terror = thermal->chip->set_tshut_temp(&thermal->chip->table,\n\t\t\t\t\t      id, thermal->regs,\n\t\t\t\t\t      thermal->tshut_temp);\n\t\tif (error)\n\t\t\tdev_err(dev, \"%s: invalid tshut=%d, error=%d\\n\",\n\t\t\t\t__func__, thermal->tshut_temp, error);\n\t}\n\n\tthermal->chip->control(thermal->regs, true);\n\n\tfor (i = 0; i < thermal->chip->chn_num; i++)\n\t\trockchip_thermal_toggle_sensor(&thermal->sensors[i], true);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rockchip_thermal_pm_ops,\n\t\t\t rockchip_thermal_suspend, rockchip_thermal_resume);\n\nstatic struct platform_driver rockchip_thermal_driver = {\n\t.driver = {\n\t\t.name = \"rockchip-thermal\",\n\t\t.pm = &rockchip_thermal_pm_ops,\n\t\t.of_match_table = of_rockchip_thermal_match,\n\t},\n\t.probe = rockchip_thermal_probe,\n\t.remove = rockchip_thermal_remove,\n};\n\nmodule_platform_driver(rockchip_thermal_driver);\n\nMODULE_DESCRIPTION(\"ROCKCHIP THERMAL Driver\");\nMODULE_AUTHOR(\"Rockchip, Inc.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:rockchip-thermal\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}