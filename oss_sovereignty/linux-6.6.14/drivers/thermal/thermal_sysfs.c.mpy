{
  "module_name": "thermal_sysfs.c",
  "hash_id": "8f5a6dffb8604ee12d1e68f16bb98337d600c99762fd08021d7a67bc767603a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/thermal_sysfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sysfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n\n#include \"thermal_core.h\"\n\n \n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\n\treturn sprintf(buf, \"%s\\n\", tz->type);\n}\n\nstatic ssize_t\ntemp_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tint temperature, ret;\n\n\tret = thermal_zone_get_temp(tz, &temperature);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", temperature);\n}\n\nstatic ssize_t\nmode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tint enabled;\n\n\tmutex_lock(&tz->lock);\n\tenabled = thermal_zone_device_is_enabled(tz);\n\tmutex_unlock(&tz->lock);\n\n\treturn sprintf(buf, \"%s\\n\", enabled ? \"enabled\" : \"disabled\");\n}\n\nstatic ssize_t\nmode_store(struct device *dev, struct device_attribute *attr,\n\t   const char *buf, size_t count)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tint result;\n\n\tif (!strncmp(buf, \"enabled\", sizeof(\"enabled\") - 1))\n\t\tresult = thermal_zone_device_enable(tz);\n\telse if (!strncmp(buf, \"disabled\", sizeof(\"disabled\") - 1))\n\t\tresult = thermal_zone_device_disable(tz);\n\telse\n\t\tresult = -EINVAL;\n\n\tif (result)\n\t\treturn result;\n\n\treturn count;\n}\n\nstatic ssize_t\ntrip_point_type_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tstruct thermal_trip trip;\n\tint trip_id, result;\n\n\tif (sscanf(attr->attr.name, \"trip_point_%d_type\", &trip_id) != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (device_is_registered(dev))\n\t\tresult = __thermal_zone_get_trip(tz, trip_id, &trip);\n\telse\n\t\tresult = -ENODEV;\n\n\tmutex_unlock(&tz->lock);\n\n\tif (result)\n\t\treturn result;\n\n\tswitch (trip.type) {\n\tcase THERMAL_TRIP_CRITICAL:\n\t\treturn sprintf(buf, \"critical\\n\");\n\tcase THERMAL_TRIP_HOT:\n\t\treturn sprintf(buf, \"hot\\n\");\n\tcase THERMAL_TRIP_PASSIVE:\n\t\treturn sprintf(buf, \"passive\\n\");\n\tcase THERMAL_TRIP_ACTIVE:\n\t\treturn sprintf(buf, \"active\\n\");\n\tdefault:\n\t\treturn sprintf(buf, \"unknown\\n\");\n\t}\n}\n\nstatic ssize_t\ntrip_point_temp_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tstruct thermal_trip trip;\n\tint trip_id, ret;\n\n\tif (sscanf(attr->attr.name, \"trip_point_%d_temp\", &trip_id) != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (!device_is_registered(dev)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tret = __thermal_zone_get_trip(tz, trip_id, &trip);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = kstrtoint(buf, 10, &trip.temperature);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = thermal_zone_set_trip(tz, trip_id, &trip);\nunlock:\n\tmutex_unlock(&tz->lock);\n\t\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\ntrip_point_temp_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tstruct thermal_trip trip;\n\tint trip_id, ret;\n\n\tif (sscanf(attr->attr.name, \"trip_point_%d_temp\", &trip_id) != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (device_is_registered(dev))\n\t\tret = __thermal_zone_get_trip(tz, trip_id, &trip);\n\telse\n\t\tret = -ENODEV;\n\n\tmutex_unlock(&tz->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", trip.temperature);\n}\n\nstatic ssize_t\ntrip_point_hyst_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tstruct thermal_trip trip;\n\tint trip_id, ret;\n\n\tif (sscanf(attr->attr.name, \"trip_point_%d_hyst\", &trip_id) != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (!device_is_registered(dev)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tret = __thermal_zone_get_trip(tz, trip_id, &trip);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = kstrtoint(buf, 10, &trip.hysteresis);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = thermal_zone_set_trip(tz, trip_id, &trip);\nunlock:\n\tmutex_unlock(&tz->lock);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\ntrip_point_hyst_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tstruct thermal_trip trip;\n\tint trip_id, ret;\n\n\tif (sscanf(attr->attr.name, \"trip_point_%d_hyst\", &trip_id) != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (device_is_registered(dev))\n\t\tret = __thermal_zone_get_trip(tz, trip_id, &trip);\n\telse\n\t\tret = -ENODEV;\n\n\tmutex_unlock(&tz->lock);\n\n\treturn ret ? ret : sprintf(buf, \"%d\\n\", trip.hysteresis);\n}\n\nstatic ssize_t\npolicy_store(struct device *dev, struct device_attribute *attr,\n\t     const char *buf, size_t count)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tchar name[THERMAL_NAME_LENGTH];\n\tint ret;\n\n\tsnprintf(name, sizeof(name), \"%s\", buf);\n\n\tret = thermal_zone_device_set_policy(tz, name);\n\tif (!ret)\n\t\tret = count;\n\n\treturn ret;\n}\n\nstatic ssize_t\npolicy_show(struct device *dev, struct device_attribute *devattr, char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\n\treturn sprintf(buf, \"%s\\n\", tz->governor->name);\n}\n\nstatic ssize_t\navailable_policies_show(struct device *dev, struct device_attribute *devattr,\n\t\t\tchar *buf)\n{\n\treturn thermal_build_list_of_policies(buf);\n}\n\n#if (IS_ENABLED(CONFIG_THERMAL_EMULATION))\nstatic ssize_t\nemul_temp_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tint ret = 0;\n\tint temperature;\n\n\tif (kstrtoint(buf, 10, &temperature))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (!device_is_registered(dev)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (!tz->ops->set_emul_temp)\n\t\ttz->emul_temperature = temperature;\n\telse\n\t\tret = tz->ops->set_emul_temp(tz, temperature);\n\n\tif (!ret)\n\t\t__thermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\n\nunlock:\n\tmutex_unlock(&tz->lock);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_WO(emul_temp);\n#endif\n\nstatic ssize_t\nsustainable_power_show(struct device *dev, struct device_attribute *devattr,\n\t\t       char *buf)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\n\tif (tz->tzp)\n\t\treturn sprintf(buf, \"%u\\n\", tz->tzp->sustainable_power);\n\telse\n\t\treturn -EIO;\n}\n\nstatic ssize_t\nsustainable_power_store(struct device *dev, struct device_attribute *devattr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\n\tu32 sustainable_power;\n\n\tif (!tz->tzp)\n\t\treturn -EIO;\n\n\tif (kstrtou32(buf, 10, &sustainable_power))\n\t\treturn -EINVAL;\n\n\ttz->tzp->sustainable_power = sustainable_power;\n\n\treturn count;\n}\n\n#define create_s32_tzp_attr(name)\t\t\t\t\t\\\n\tstatic ssize_t\t\t\t\t\t\t\t\\\n\tname##_show(struct device *dev, struct device_attribute *devattr, \\\n\t\tchar *buf)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (tz->tzp)\t\t\t\t\t\t\t\\\n\t\treturn sprintf(buf, \"%d\\n\", tz->tzp->name);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\treturn -EIO;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t\t\t\t\t\t\t\t\\\n\tname##_store(struct device *dev, struct device_attribute *devattr, \\\n\t\tconst char *buf, size_t count)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct thermal_zone_device *tz = to_thermal_zone(dev);\t\\\n\t\ts32 value;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (!tz->tzp)\t\t\t\t\t\t\\\n\t\t\treturn -EIO;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (kstrtos32(buf, 10, &value))\t\t\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\ttz->tzp->name = value;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn count;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic DEVICE_ATTR_RW(name)\n\ncreate_s32_tzp_attr(k_po);\ncreate_s32_tzp_attr(k_pu);\ncreate_s32_tzp_attr(k_i);\ncreate_s32_tzp_attr(k_d);\ncreate_s32_tzp_attr(integral_cutoff);\ncreate_s32_tzp_attr(slope);\ncreate_s32_tzp_attr(offset);\n#undef create_s32_tzp_attr\n\n \nstatic DEVICE_ATTR_RO(type);\nstatic DEVICE_ATTR_RO(temp);\nstatic DEVICE_ATTR_RW(policy);\nstatic DEVICE_ATTR_RO(available_policies);\nstatic DEVICE_ATTR_RW(sustainable_power);\n\n \nstatic DEVICE_ATTR_RW(mode);\n\n \nstatic struct attribute *thermal_zone_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_temp.attr,\n#if (IS_ENABLED(CONFIG_THERMAL_EMULATION))\n\t&dev_attr_emul_temp.attr,\n#endif\n\t&dev_attr_policy.attr,\n\t&dev_attr_available_policies.attr,\n\t&dev_attr_sustainable_power.attr,\n\t&dev_attr_k_po.attr,\n\t&dev_attr_k_pu.attr,\n\t&dev_attr_k_i.attr,\n\t&dev_attr_k_d.attr,\n\t&dev_attr_integral_cutoff.attr,\n\t&dev_attr_slope.attr,\n\t&dev_attr_offset.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group thermal_zone_attribute_group = {\n\t.attrs = thermal_zone_dev_attrs,\n};\n\nstatic struct attribute *thermal_zone_mode_attrs[] = {\n\t&dev_attr_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group thermal_zone_mode_attribute_group = {\n\t.attrs = thermal_zone_mode_attrs,\n};\n\nstatic const struct attribute_group *thermal_zone_attribute_groups[] = {\n\t&thermal_zone_attribute_group,\n\t&thermal_zone_mode_attribute_group,\n\t \n};\n\n \nstatic int create_trip_attrs(struct thermal_zone_device *tz, int mask)\n{\n\tstruct attribute **attrs;\n\tint indx;\n\n\t \n\tif (tz->num_trips <= 0)\n\t\treturn -EINVAL;\n\n\ttz->trip_type_attrs = kcalloc(tz->num_trips, sizeof(*tz->trip_type_attrs),\n\t\t\t\t      GFP_KERNEL);\n\tif (!tz->trip_type_attrs)\n\t\treturn -ENOMEM;\n\n\ttz->trip_temp_attrs = kcalloc(tz->num_trips, sizeof(*tz->trip_temp_attrs),\n\t\t\t\t      GFP_KERNEL);\n\tif (!tz->trip_temp_attrs) {\n\t\tkfree(tz->trip_type_attrs);\n\t\treturn -ENOMEM;\n\t}\n\n\ttz->trip_hyst_attrs = kcalloc(tz->num_trips,\n\t\t\t\t      sizeof(*tz->trip_hyst_attrs),\n\t\t\t\t      GFP_KERNEL);\n\tif (!tz->trip_hyst_attrs) {\n\t\tkfree(tz->trip_type_attrs);\n\t\tkfree(tz->trip_temp_attrs);\n\t\treturn -ENOMEM;\n\t}\n\n\tattrs = kcalloc(tz->num_trips * 3 + 1, sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs) {\n\t\tkfree(tz->trip_type_attrs);\n\t\tkfree(tz->trip_temp_attrs);\n\t\tkfree(tz->trip_hyst_attrs);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (indx = 0; indx < tz->num_trips; indx++) {\n\t\t \n\t\tsnprintf(tz->trip_type_attrs[indx].name, THERMAL_NAME_LENGTH,\n\t\t\t \"trip_point_%d_type\", indx);\n\n\t\tsysfs_attr_init(&tz->trip_type_attrs[indx].attr.attr);\n\t\ttz->trip_type_attrs[indx].attr.attr.name =\n\t\t\t\t\t\ttz->trip_type_attrs[indx].name;\n\t\ttz->trip_type_attrs[indx].attr.attr.mode = S_IRUGO;\n\t\ttz->trip_type_attrs[indx].attr.show = trip_point_type_show;\n\t\tattrs[indx] = &tz->trip_type_attrs[indx].attr.attr;\n\n\t\t \n\t\tsnprintf(tz->trip_temp_attrs[indx].name, THERMAL_NAME_LENGTH,\n\t\t\t \"trip_point_%d_temp\", indx);\n\n\t\tsysfs_attr_init(&tz->trip_temp_attrs[indx].attr.attr);\n\t\ttz->trip_temp_attrs[indx].attr.attr.name =\n\t\t\t\t\t\ttz->trip_temp_attrs[indx].name;\n\t\ttz->trip_temp_attrs[indx].attr.attr.mode = S_IRUGO;\n\t\ttz->trip_temp_attrs[indx].attr.show = trip_point_temp_show;\n\t\tif (IS_ENABLED(CONFIG_THERMAL_WRITABLE_TRIPS) &&\n\t\t    mask & (1 << indx)) {\n\t\t\ttz->trip_temp_attrs[indx].attr.attr.mode |= S_IWUSR;\n\t\t\ttz->trip_temp_attrs[indx].attr.store =\n\t\t\t\t\t\t\ttrip_point_temp_store;\n\t\t}\n\t\tattrs[indx + tz->num_trips] = &tz->trip_temp_attrs[indx].attr.attr;\n\n\t\tsnprintf(tz->trip_hyst_attrs[indx].name, THERMAL_NAME_LENGTH,\n\t\t\t \"trip_point_%d_hyst\", indx);\n\n\t\tsysfs_attr_init(&tz->trip_hyst_attrs[indx].attr.attr);\n\t\ttz->trip_hyst_attrs[indx].attr.attr.name =\n\t\t\t\t\ttz->trip_hyst_attrs[indx].name;\n\t\ttz->trip_hyst_attrs[indx].attr.attr.mode = S_IRUGO;\n\t\ttz->trip_hyst_attrs[indx].attr.show = trip_point_hyst_show;\n\t\tif (tz->ops->set_trip_hyst) {\n\t\t\ttz->trip_hyst_attrs[indx].attr.attr.mode |= S_IWUSR;\n\t\t\ttz->trip_hyst_attrs[indx].attr.store =\n\t\t\t\t\ttrip_point_hyst_store;\n\t\t}\n\t\tattrs[indx + tz->num_trips * 2] =\n\t\t\t\t\t&tz->trip_hyst_attrs[indx].attr.attr;\n\t}\n\tattrs[tz->num_trips * 3] = NULL;\n\n\ttz->trips_attribute_group.attrs = attrs;\n\n\treturn 0;\n}\n\n \nstatic void destroy_trip_attrs(struct thermal_zone_device *tz)\n{\n\tif (!tz)\n\t\treturn;\n\n\tkfree(tz->trip_type_attrs);\n\tkfree(tz->trip_temp_attrs);\n\tkfree(tz->trip_hyst_attrs);\n\tkfree(tz->trips_attribute_group.attrs);\n}\n\nint thermal_zone_create_device_groups(struct thermal_zone_device *tz,\n\t\t\t\t      int mask)\n{\n\tconst struct attribute_group **groups;\n\tint i, size, result;\n\n\t \n\tsize = ARRAY_SIZE(thermal_zone_attribute_groups) + 2;\n\t \n\tgroups = kcalloc(size, sizeof(*groups), GFP_KERNEL);\n\tif (!groups)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < size - 2; i++)\n\t\tgroups[i] = thermal_zone_attribute_groups[i];\n\n\tif (tz->num_trips) {\n\t\tresult = create_trip_attrs(tz, mask);\n\t\tif (result) {\n\t\t\tkfree(groups);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tgroups[size - 2] = &tz->trips_attribute_group;\n\t}\n\n\ttz->device.groups = groups;\n\n\treturn 0;\n}\n\nvoid thermal_zone_destroy_device_groups(struct thermal_zone_device *tz)\n{\n\tif (!tz)\n\t\treturn;\n\n\tif (tz->num_trips)\n\t\tdestroy_trip_attrs(tz);\n\n\tkfree(tz->device.groups);\n}\n\n \nstatic ssize_t\ncdev_type_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", cdev->type);\n}\n\nstatic ssize_t max_state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\n\treturn sprintf(buf, \"%ld\\n\", cdev->max_state);\n}\n\nstatic ssize_t cur_state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\tunsigned long state;\n\tint ret;\n\n\tret = cdev->ops->get_cur_state(cdev, &state);\n\tif (ret)\n\t\treturn ret;\n\treturn sprintf(buf, \"%ld\\n\", state);\n}\n\nstatic ssize_t\ncur_state_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\tunsigned long state;\n\tint result;\n\n\tif (sscanf(buf, \"%ld\\n\", &state) != 1)\n\t\treturn -EINVAL;\n\n\tif ((long)state < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (state > cdev->max_state)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cdev->lock);\n\n\tresult = cdev->ops->set_cur_state(cdev, state);\n\tif (!result)\n\t\tthermal_cooling_device_stats_update(cdev, state);\n\n\tmutex_unlock(&cdev->lock);\n\treturn result ? result : count;\n}\n\nstatic struct device_attribute\ndev_attr_cdev_type = __ATTR(type, 0444, cdev_type_show, NULL);\nstatic DEVICE_ATTR_RO(max_state);\nstatic DEVICE_ATTR_RW(cur_state);\n\nstatic struct attribute *cooling_device_attrs[] = {\n\t&dev_attr_cdev_type.attr,\n\t&dev_attr_max_state.attr,\n\t&dev_attr_cur_state.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cooling_device_attr_group = {\n\t.attrs = cooling_device_attrs,\n};\n\nstatic const struct attribute_group *cooling_device_attr_groups[] = {\n\t&cooling_device_attr_group,\n\tNULL,  \n\tNULL,\n};\n\n#ifdef CONFIG_THERMAL_STATISTICS\nstruct cooling_dev_stats {\n\tspinlock_t lock;\n\tunsigned int total_trans;\n\tunsigned long state;\n\tktime_t last_time;\n\tktime_t *time_in_state;\n\tunsigned int *trans_table;\n};\n\nstatic void update_time_in_state(struct cooling_dev_stats *stats)\n{\n\tktime_t now = ktime_get(), delta;\n\n\tdelta = ktime_sub(now, stats->last_time);\n\tstats->time_in_state[stats->state] =\n\t\tktime_add(stats->time_in_state[stats->state], delta);\n\tstats->last_time = now;\n}\n\nvoid thermal_cooling_device_stats_update(struct thermal_cooling_device *cdev,\n\t\t\t\t\t unsigned long new_state)\n{\n\tstruct cooling_dev_stats *stats = cdev->stats;\n\n\tlockdep_assert_held(&cdev->lock);\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->lock);\n\n\tif (stats->state == new_state)\n\t\tgoto unlock;\n\n\tupdate_time_in_state(stats);\n\tstats->trans_table[stats->state * (cdev->max_state + 1) + new_state]++;\n\tstats->state = new_state;\n\tstats->total_trans++;\n\nunlock:\n\tspin_unlock(&stats->lock);\n}\n\nstatic ssize_t total_trans_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\tstruct cooling_dev_stats *stats;\n\tint ret = 0;\n\n\tmutex_lock(&cdev->lock);\n\n\tstats = cdev->stats;\n\tif (!stats)\n\t\tgoto unlock;\n\n\tspin_lock(&stats->lock);\n\tret = sprintf(buf, \"%u\\n\", stats->total_trans);\n\tspin_unlock(&stats->lock);\n\nunlock:\n\tmutex_unlock(&cdev->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntime_in_state_ms_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\tstruct cooling_dev_stats *stats;\n\tssize_t len = 0;\n\tint i;\n\n\tmutex_lock(&cdev->lock);\n\n\tstats = cdev->stats;\n\tif (!stats)\n\t\tgoto unlock;\n\n\tspin_lock(&stats->lock);\n\n\tupdate_time_in_state(stats);\n\n\tfor (i = 0; i <= cdev->max_state; i++) {\n\t\tlen += sprintf(buf + len, \"state%u\\t%llu\\n\", i,\n\t\t\t       ktime_to_ms(stats->time_in_state[i]));\n\t}\n\tspin_unlock(&stats->lock);\n\nunlock:\n\tmutex_unlock(&cdev->lock);\n\n\treturn len;\n}\n\nstatic ssize_t\nreset_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t    size_t count)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\tstruct cooling_dev_stats *stats;\n\tint i, states;\n\n\tmutex_lock(&cdev->lock);\n\n\tstats = cdev->stats;\n\tif (!stats)\n\t\tgoto unlock;\n\n\tstates = cdev->max_state + 1;\n\n\tspin_lock(&stats->lock);\n\n\tstats->total_trans = 0;\n\tstats->last_time = ktime_get();\n\tmemset(stats->trans_table, 0,\n\t       states * states * sizeof(*stats->trans_table));\n\n\tfor (i = 0; i < states; i++)\n\t\tstats->time_in_state[i] = ktime_set(0, 0);\n\n\tspin_unlock(&stats->lock);\n\nunlock:\n\tmutex_unlock(&cdev->lock);\n\n\treturn count;\n}\n\nstatic ssize_t trans_table_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct thermal_cooling_device *cdev = to_cooling_device(dev);\n\tstruct cooling_dev_stats *stats;\n\tssize_t len = 0;\n\tint i, j;\n\n\tmutex_lock(&cdev->lock);\n\n\tstats = cdev->stats;\n\tif (!stats) {\n\t\tlen = -ENODATA;\n\t\tgoto unlock;\n\t}\n\n\tlen += snprintf(buf + len, PAGE_SIZE - len, \" From  :    To\\n\");\n\tlen += snprintf(buf + len, PAGE_SIZE - len, \"       : \");\n\tfor (i = 0; i <= cdev->max_state; i++) {\n\t\tif (len >= PAGE_SIZE)\n\t\t\tbreak;\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"state%2u  \", i);\n\t}\n\tif (len >= PAGE_SIZE) {\n\t\tlen = PAGE_SIZE;\n\t\tgoto unlock;\n\t}\n\n\tlen += snprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\n\tfor (i = 0; i <= cdev->max_state; i++) {\n\t\tif (len >= PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"state%2u:\", i);\n\n\t\tfor (j = 0; j <= cdev->max_state; j++) {\n\t\t\tif (len >= PAGE_SIZE)\n\t\t\t\tbreak;\n\t\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"%8u \",\n\t\t\t\tstats->trans_table[i * (cdev->max_state + 1) + j]);\n\t\t}\n\t\tif (len >= PAGE_SIZE)\n\t\t\tbreak;\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\t}\n\n\tif (len >= PAGE_SIZE) {\n\t\tpr_warn_once(\"Thermal transition table exceeds PAGE_SIZE. Disabling\\n\");\n\t\tlen = -EFBIG;\n\t}\n\nunlock:\n\tmutex_unlock(&cdev->lock);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(total_trans);\nstatic DEVICE_ATTR_RO(time_in_state_ms);\nstatic DEVICE_ATTR_WO(reset);\nstatic DEVICE_ATTR_RO(trans_table);\n\nstatic struct attribute *cooling_device_stats_attrs[] = {\n\t&dev_attr_total_trans.attr,\n\t&dev_attr_time_in_state_ms.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_trans_table.attr,\n\tNULL\n};\n\nstatic const struct attribute_group cooling_device_stats_attr_group = {\n\t.attrs = cooling_device_stats_attrs,\n\t.name = \"stats\"\n};\n\nstatic void cooling_device_stats_setup(struct thermal_cooling_device *cdev)\n{\n\tconst struct attribute_group *stats_attr_group = NULL;\n\tstruct cooling_dev_stats *stats;\n\t \n\tunsigned long states = cdev->max_state + 1;\n\tint var;\n\n\tvar = sizeof(*stats);\n\tvar += sizeof(*stats->time_in_state) * states;\n\tvar += sizeof(*stats->trans_table) * states * states;\n\n\tstats = kzalloc(var, GFP_KERNEL);\n\tif (!stats)\n\t\tgoto out;\n\n\tstats->time_in_state = (ktime_t *)(stats + 1);\n\tstats->trans_table = (unsigned int *)(stats->time_in_state + states);\n\tcdev->stats = stats;\n\tstats->last_time = ktime_get();\n\n\tspin_lock_init(&stats->lock);\n\n\tstats_attr_group = &cooling_device_stats_attr_group;\n\nout:\n\t \n\tvar = ARRAY_SIZE(cooling_device_attr_groups) - 2;\n\tcooling_device_attr_groups[var] = stats_attr_group;\n}\n\nstatic void cooling_device_stats_destroy(struct thermal_cooling_device *cdev)\n{\n\tkfree(cdev->stats);\n\tcdev->stats = NULL;\n}\n\n#else\n\nstatic inline void\ncooling_device_stats_setup(struct thermal_cooling_device *cdev) {}\nstatic inline void\ncooling_device_stats_destroy(struct thermal_cooling_device *cdev) {}\n\n#endif  \n\nvoid thermal_cooling_device_setup_sysfs(struct thermal_cooling_device *cdev)\n{\n\tcooling_device_stats_setup(cdev);\n\tcdev->device.groups = cooling_device_attr_groups;\n}\n\nvoid thermal_cooling_device_destroy_sysfs(struct thermal_cooling_device *cdev)\n{\n\tcooling_device_stats_destroy(cdev);\n}\n\nvoid thermal_cooling_device_stats_reinit(struct thermal_cooling_device *cdev)\n{\n\tlockdep_assert_held(&cdev->lock);\n\n\tcooling_device_stats_destroy(cdev);\n\tcooling_device_stats_setup(cdev);\n}\n\n \nssize_t\ntrip_point_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_instance *instance;\n\n\tinstance =\n\t    container_of(attr, struct thermal_instance, attr);\n\n\treturn sprintf(buf, \"%d\\n\", instance->trip);\n}\n\nssize_t\nweight_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_instance *instance;\n\n\tinstance = container_of(attr, struct thermal_instance, weight_attr);\n\n\treturn sprintf(buf, \"%d\\n\", instance->weight);\n}\n\nssize_t weight_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct thermal_instance *instance;\n\tint ret, weight;\n\n\tret = kstrtoint(buf, 0, &weight);\n\tif (ret)\n\t\treturn ret;\n\n\tinstance = container_of(attr, struct thermal_instance, weight_attr);\n\tinstance->weight = weight;\n\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}