{
  "module_name": "imx_thermal.c",
  "hash_id": "675b326c25a0748aab4958167ab86d7cd002d3a2ffd42ea4c4a791f1e328faf0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/imx_thermal.c",
  "human_readable_source": "\n\n\n\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu_cooling.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/pm_runtime.h>\n\n#define REG_SET\t\t0x4\n#define REG_CLR\t\t0x8\n#define REG_TOG\t\t0xc\n\n \n#define IMX6_MISC0\t\t\t\t0x0150\n#define IMX6_MISC0_REFTOP_SELBIASOFF\t\t(1 << 3)\n#define IMX6_MISC1\t\t\t\t0x0160\n#define IMX6_MISC1_IRQ_TEMPHIGH\t\t\t(1 << 29)\n \n#define IMX6_MISC1_IRQ_TEMPLOW\t\t\t(1 << 28)\n#define IMX6_MISC1_IRQ_TEMPPANIC\t\t(1 << 27)\n\n#define IMX6_TEMPSENSE0\t\t\t\t0x0180\n#define IMX6_TEMPSENSE0_ALARM_VALUE_SHIFT\t20\n#define IMX6_TEMPSENSE0_ALARM_VALUE_MASK\t(0xfff << 20)\n#define IMX6_TEMPSENSE0_TEMP_CNT_SHIFT\t\t8\n#define IMX6_TEMPSENSE0_TEMP_CNT_MASK\t\t(0xfff << 8)\n#define IMX6_TEMPSENSE0_FINISHED\t\t(1 << 2)\n#define IMX6_TEMPSENSE0_MEASURE_TEMP\t\t(1 << 1)\n#define IMX6_TEMPSENSE0_POWER_DOWN\t\t(1 << 0)\n\n#define IMX6_TEMPSENSE1\t\t\t\t0x0190\n#define IMX6_TEMPSENSE1_MEASURE_FREQ\t\t0xffff\n#define IMX6_TEMPSENSE1_MEASURE_FREQ_SHIFT\t0\n\n#define OCOTP_MEM0\t\t\t0x0480\n#define OCOTP_ANA1\t\t\t0x04e0\n\n \n#define IMX6_TEMPSENSE2\t\t\t\t0x0290\n#define IMX6_TEMPSENSE2_LOW_VALUE_SHIFT\t\t0\n#define IMX6_TEMPSENSE2_LOW_VALUE_MASK\t\t0xfff\n#define IMX6_TEMPSENSE2_PANIC_VALUE_SHIFT\t16\n#define IMX6_TEMPSENSE2_PANIC_VALUE_MASK\t0xfff0000\n\n \n#define IMX7_ANADIG_DIGPROG\t\t\t0x800\n#define IMX7_TEMPSENSE0\t\t\t\t0x300\n#define IMX7_TEMPSENSE0_PANIC_ALARM_SHIFT\t18\n#define IMX7_TEMPSENSE0_PANIC_ALARM_MASK\t(0x1ff << 18)\n#define IMX7_TEMPSENSE0_HIGH_ALARM_SHIFT\t9\n#define IMX7_TEMPSENSE0_HIGH_ALARM_MASK\t\t(0x1ff << 9)\n#define IMX7_TEMPSENSE0_LOW_ALARM_SHIFT\t\t0\n#define IMX7_TEMPSENSE0_LOW_ALARM_MASK\t\t0x1ff\n\n#define IMX7_TEMPSENSE1\t\t\t\t0x310\n#define IMX7_TEMPSENSE1_MEASURE_FREQ_SHIFT\t16\n#define IMX7_TEMPSENSE1_MEASURE_FREQ_MASK\t(0xffff << 16)\n#define IMX7_TEMPSENSE1_FINISHED\t\t(1 << 11)\n#define IMX7_TEMPSENSE1_MEASURE_TEMP\t\t(1 << 10)\n#define IMX7_TEMPSENSE1_POWER_DOWN\t\t(1 << 9)\n#define IMX7_TEMPSENSE1_TEMP_VALUE_SHIFT\t0\n#define IMX7_TEMPSENSE1_TEMP_VALUE_MASK\t\t0x1ff\n\n \nenum imx_thermal_trip {\n\tIMX_TRIP_PASSIVE,\n\tIMX_TRIP_CRITICAL,\n};\n\n#define IMX_POLLING_DELAY\t\t2000  \n#define IMX_PASSIVE_DELAY\t\t1000\n\n#define TEMPMON_IMX6Q\t\t\t1\n#define TEMPMON_IMX6SX\t\t\t2\n#define TEMPMON_IMX7D\t\t\t3\n\nstruct thermal_soc_data {\n\tu32 version;\n\n\tu32 sensor_ctrl;\n\tu32 power_down_mask;\n\tu32 measure_temp_mask;\n\n\tu32 measure_freq_ctrl;\n\tu32 measure_freq_mask;\n\tu32 measure_freq_shift;\n\n\tu32 temp_data;\n\tu32 temp_value_mask;\n\tu32 temp_value_shift;\n\tu32 temp_valid_mask;\n\n\tu32 panic_alarm_ctrl;\n\tu32 panic_alarm_mask;\n\tu32 panic_alarm_shift;\n\n\tu32 high_alarm_ctrl;\n\tu32 high_alarm_mask;\n\tu32 high_alarm_shift;\n\n\tu32 low_alarm_ctrl;\n\tu32 low_alarm_mask;\n\tu32 low_alarm_shift;\n};\n\nstatic struct thermal_trip trips[] = {\n\t[IMX_TRIP_PASSIVE]  = { .type = THERMAL_TRIP_PASSIVE  },\n\t[IMX_TRIP_CRITICAL] = { .type = THERMAL_TRIP_CRITICAL },\n};\n\nstatic struct thermal_soc_data thermal_imx6q_data = {\n\t.version = TEMPMON_IMX6Q,\n\n\t.sensor_ctrl = IMX6_TEMPSENSE0,\n\t.power_down_mask = IMX6_TEMPSENSE0_POWER_DOWN,\n\t.measure_temp_mask = IMX6_TEMPSENSE0_MEASURE_TEMP,\n\n\t.measure_freq_ctrl = IMX6_TEMPSENSE1,\n\t.measure_freq_shift = IMX6_TEMPSENSE1_MEASURE_FREQ_SHIFT,\n\t.measure_freq_mask = IMX6_TEMPSENSE1_MEASURE_FREQ,\n\n\t.temp_data = IMX6_TEMPSENSE0,\n\t.temp_value_mask = IMX6_TEMPSENSE0_TEMP_CNT_MASK,\n\t.temp_value_shift = IMX6_TEMPSENSE0_TEMP_CNT_SHIFT,\n\t.temp_valid_mask = IMX6_TEMPSENSE0_FINISHED,\n\n\t.high_alarm_ctrl = IMX6_TEMPSENSE0,\n\t.high_alarm_mask = IMX6_TEMPSENSE0_ALARM_VALUE_MASK,\n\t.high_alarm_shift = IMX6_TEMPSENSE0_ALARM_VALUE_SHIFT,\n};\n\nstatic struct thermal_soc_data thermal_imx6sx_data = {\n\t.version = TEMPMON_IMX6SX,\n\n\t.sensor_ctrl = IMX6_TEMPSENSE0,\n\t.power_down_mask = IMX6_TEMPSENSE0_POWER_DOWN,\n\t.measure_temp_mask = IMX6_TEMPSENSE0_MEASURE_TEMP,\n\n\t.measure_freq_ctrl = IMX6_TEMPSENSE1,\n\t.measure_freq_shift = IMX6_TEMPSENSE1_MEASURE_FREQ_SHIFT,\n\t.measure_freq_mask = IMX6_TEMPSENSE1_MEASURE_FREQ,\n\n\t.temp_data = IMX6_TEMPSENSE0,\n\t.temp_value_mask = IMX6_TEMPSENSE0_TEMP_CNT_MASK,\n\t.temp_value_shift = IMX6_TEMPSENSE0_TEMP_CNT_SHIFT,\n\t.temp_valid_mask = IMX6_TEMPSENSE0_FINISHED,\n\n\t.high_alarm_ctrl = IMX6_TEMPSENSE0,\n\t.high_alarm_mask = IMX6_TEMPSENSE0_ALARM_VALUE_MASK,\n\t.high_alarm_shift = IMX6_TEMPSENSE0_ALARM_VALUE_SHIFT,\n\n\t.panic_alarm_ctrl = IMX6_TEMPSENSE2,\n\t.panic_alarm_mask = IMX6_TEMPSENSE2_PANIC_VALUE_MASK,\n\t.panic_alarm_shift = IMX6_TEMPSENSE2_PANIC_VALUE_SHIFT,\n\n\t.low_alarm_ctrl = IMX6_TEMPSENSE2,\n\t.low_alarm_mask = IMX6_TEMPSENSE2_LOW_VALUE_MASK,\n\t.low_alarm_shift = IMX6_TEMPSENSE2_LOW_VALUE_SHIFT,\n};\n\nstatic struct thermal_soc_data thermal_imx7d_data = {\n\t.version = TEMPMON_IMX7D,\n\n\t.sensor_ctrl = IMX7_TEMPSENSE1,\n\t.power_down_mask = IMX7_TEMPSENSE1_POWER_DOWN,\n\t.measure_temp_mask = IMX7_TEMPSENSE1_MEASURE_TEMP,\n\n\t.measure_freq_ctrl = IMX7_TEMPSENSE1,\n\t.measure_freq_shift = IMX7_TEMPSENSE1_MEASURE_FREQ_SHIFT,\n\t.measure_freq_mask = IMX7_TEMPSENSE1_MEASURE_FREQ_MASK,\n\n\t.temp_data = IMX7_TEMPSENSE1,\n\t.temp_value_mask = IMX7_TEMPSENSE1_TEMP_VALUE_MASK,\n\t.temp_value_shift = IMX7_TEMPSENSE1_TEMP_VALUE_SHIFT,\n\t.temp_valid_mask = IMX7_TEMPSENSE1_FINISHED,\n\n\t.panic_alarm_ctrl = IMX7_TEMPSENSE1,\n\t.panic_alarm_mask = IMX7_TEMPSENSE0_PANIC_ALARM_MASK,\n\t.panic_alarm_shift = IMX7_TEMPSENSE0_PANIC_ALARM_SHIFT,\n\n\t.high_alarm_ctrl = IMX7_TEMPSENSE0,\n\t.high_alarm_mask = IMX7_TEMPSENSE0_HIGH_ALARM_MASK,\n\t.high_alarm_shift = IMX7_TEMPSENSE0_HIGH_ALARM_SHIFT,\n\n\t.low_alarm_ctrl = IMX7_TEMPSENSE0,\n\t.low_alarm_mask = IMX7_TEMPSENSE0_LOW_ALARM_MASK,\n\t.low_alarm_shift = IMX7_TEMPSENSE0_LOW_ALARM_SHIFT,\n};\n\nstruct imx_thermal_data {\n\tstruct device *dev;\n\tstruct cpufreq_policy *policy;\n\tstruct thermal_zone_device *tz;\n\tstruct thermal_cooling_device *cdev;\n\tstruct regmap *tempmon;\n\tu32 c1, c2;  \n\tint temp_max;\n\tint alarm_temp;\n\tint last_temp;\n\tbool irq_enabled;\n\tint irq;\n\tstruct clk *thermal_clk;\n\tconst struct thermal_soc_data *socdata;\n\tconst char *temp_grade;\n};\n\nstatic void imx_set_panic_temp(struct imx_thermal_data *data,\n\t\t\t       int panic_temp)\n{\n\tconst struct thermal_soc_data *soc_data = data->socdata;\n\tstruct regmap *map = data->tempmon;\n\tint critical_value;\n\n\tcritical_value = (data->c2 - panic_temp) / data->c1;\n\n\tregmap_write(map, soc_data->panic_alarm_ctrl + REG_CLR,\n\t\t     soc_data->panic_alarm_mask);\n\tregmap_write(map, soc_data->panic_alarm_ctrl + REG_SET,\n\t\t     critical_value << soc_data->panic_alarm_shift);\n}\n\nstatic void imx_set_alarm_temp(struct imx_thermal_data *data,\n\t\t\t       int alarm_temp)\n{\n\tstruct regmap *map = data->tempmon;\n\tconst struct thermal_soc_data *soc_data = data->socdata;\n\tint alarm_value;\n\n\tdata->alarm_temp = alarm_temp;\n\n\tif (data->socdata->version == TEMPMON_IMX7D)\n\t\talarm_value = alarm_temp / 1000 + data->c1 - 25;\n\telse\n\t\talarm_value = (data->c2 - alarm_temp) / data->c1;\n\n\tregmap_write(map, soc_data->high_alarm_ctrl + REG_CLR,\n\t\t     soc_data->high_alarm_mask);\n\tregmap_write(map, soc_data->high_alarm_ctrl + REG_SET,\n\t\t     alarm_value << soc_data->high_alarm_shift);\n}\n\nstatic int imx_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct imx_thermal_data *data = thermal_zone_device_priv(tz);\n\tconst struct thermal_soc_data *soc_data = data->socdata;\n\tstruct regmap *map = data->tempmon;\n\tunsigned int n_meas;\n\tu32 val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(data->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_read(map, soc_data->temp_data, &val);\n\n\tif ((val & soc_data->temp_valid_mask) == 0)\n\t\treturn -EAGAIN;\n\n\tn_meas = (val & soc_data->temp_value_mask)\n\t\t>> soc_data->temp_value_shift;\n\n\t \n\tif (data->socdata->version == TEMPMON_IMX7D)\n\t\t*temp = (n_meas - data->c1 + 25) * 1000;\n\telse\n\t\t*temp = data->c2 - n_meas * data->c1;\n\n\t \n\tif (data->socdata->version == TEMPMON_IMX6Q) {\n\t\tif (data->alarm_temp == trips[IMX_TRIP_PASSIVE].temperature &&\n\t\t\t*temp >= trips[IMX_TRIP_PASSIVE].temperature)\n\t\t\timx_set_alarm_temp(data, trips[IMX_TRIP_CRITICAL].temperature);\n\t\tif (data->alarm_temp == trips[IMX_TRIP_CRITICAL].temperature &&\n\t\t\t*temp < trips[IMX_TRIP_PASSIVE].temperature) {\n\t\t\timx_set_alarm_temp(data, trips[IMX_TRIP_PASSIVE].temperature);\n\t\t\tdev_dbg(data->dev, \"thermal alarm off: T < %d\\n\",\n\t\t\t\tdata->alarm_temp / 1000);\n\t\t}\n\t}\n\n\tif (*temp != data->last_temp) {\n\t\tdev_dbg(data->dev, \"millicelsius: %d\\n\", *temp);\n\t\tdata->last_temp = *temp;\n\t}\n\n\t \n\tif (!data->irq_enabled && *temp < data->alarm_temp) {\n\t\tdata->irq_enabled = true;\n\t\tenable_irq(data->irq);\n\t}\n\n\tpm_runtime_put(data->dev);\n\n\treturn 0;\n}\n\nstatic int imx_change_mode(struct thermal_zone_device *tz,\n\t\t\t   enum thermal_device_mode mode)\n{\n\tstruct imx_thermal_data *data = thermal_zone_device_priv(tz);\n\n\tif (mode == THERMAL_DEVICE_ENABLED) {\n\t\tpm_runtime_get(data->dev);\n\n\t\tif (!data->irq_enabled) {\n\t\t\tdata->irq_enabled = true;\n\t\t\tenable_irq(data->irq);\n\t\t}\n\t} else {\n\t\tpm_runtime_put(data->dev);\n\n\t\tif (data->irq_enabled) {\n\t\t\tdisable_irq(data->irq);\n\t\t\tdata->irq_enabled = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_set_trip_temp(struct thermal_zone_device *tz, int trip_id,\n\t\t\t     int temp)\n{\n\tstruct imx_thermal_data *data = thermal_zone_device_priv(tz);\n\tstruct thermal_trip trip;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(data->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __thermal_zone_get_trip(tz, trip_id, &trip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (trip.type == THERMAL_TRIP_CRITICAL)\n\t\treturn -EPERM;\n\n\t \n\tif (temp < 0 || temp > trips[IMX_TRIP_CRITICAL].temperature)\n\t\treturn -EINVAL;\n\n\timx_set_alarm_temp(data, temp);\n\n\tpm_runtime_put(data->dev);\n\n\treturn 0;\n}\n\nstatic int imx_bind(struct thermal_zone_device *tz,\n\t\t    struct thermal_cooling_device *cdev)\n{\n\treturn thermal_zone_bind_cooling_device(tz, IMX_TRIP_PASSIVE, cdev,\n\t\t\t\t\t\tTHERMAL_NO_LIMIT,\n\t\t\t\t\t\tTHERMAL_NO_LIMIT,\n\t\t\t\t\t\tTHERMAL_WEIGHT_DEFAULT);\n}\n\nstatic int imx_unbind(struct thermal_zone_device *tz,\n\t\t      struct thermal_cooling_device *cdev)\n{\n\treturn thermal_zone_unbind_cooling_device(tz, IMX_TRIP_PASSIVE, cdev);\n}\n\nstatic struct thermal_zone_device_ops imx_tz_ops = {\n\t.bind = imx_bind,\n\t.unbind = imx_unbind,\n\t.get_temp = imx_get_temp,\n\t.change_mode = imx_change_mode,\n\t.set_trip_temp = imx_set_trip_temp,\n};\n\nstatic int imx_init_calib(struct platform_device *pdev, u32 ocotp_ana1)\n{\n\tstruct imx_thermal_data *data = platform_get_drvdata(pdev);\n\tint n1;\n\tu64 temp64;\n\n\tif (ocotp_ana1 == 0 || ocotp_ana1 == ~0) {\n\t\tdev_err(&pdev->dev, \"invalid sensor calibration data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data->socdata->version == TEMPMON_IMX7D) {\n\t\tdata->c1 = (ocotp_ana1 >> 9) & 0x1ff;\n\t\treturn 0;\n\t}\n\n\t \n\tn1 = ocotp_ana1 >> 20;\n\n\ttemp64 = 10000000;  \n\ttemp64 *= 1000;  \n\tdo_div(temp64, 15423 * n1 - 4148468);\n\tdata->c1 = temp64;\n\tdata->c2 = n1 * data->c1 + 28581;\n\n\treturn 0;\n}\n\nstatic void imx_init_temp_grade(struct platform_device *pdev, u32 ocotp_mem0)\n{\n\tstruct imx_thermal_data *data = platform_get_drvdata(pdev);\n\n\t \n\tswitch ((ocotp_mem0 >> 6) & 0x3) {\n\tcase 0:  \n\t\tdata->temp_grade = \"Commercial\";\n\t\tdata->temp_max = 95000;\n\t\tbreak;\n\tcase 1:  \n\t\tdata->temp_grade = \"Extended Commercial\";\n\t\tdata->temp_max = 105000;\n\t\tbreak;\n\tcase 2:  \n\t\tdata->temp_grade = \"Industrial\";\n\t\tdata->temp_max = 105000;\n\t\tbreak;\n\tcase 3:  \n\t\tdata->temp_grade = \"Automotive\";\n\t\tdata->temp_max = 125000;\n\t\tbreak;\n\t}\n\n\t \n\ttrips[IMX_TRIP_PASSIVE].temperature = data->temp_max - (1000 * 10);\n\ttrips[IMX_TRIP_CRITICAL].temperature = data->temp_max - (1000 * 5);\n}\n\nstatic int imx_init_from_tempmon_data(struct platform_device *pdev)\n{\n\tstruct regmap *map;\n\tint ret;\n\tu32 val;\n\n\tmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t      \"fsl,tempmon-data\");\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tdev_err(&pdev->dev, \"failed to get sensor regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(map, OCOTP_ANA1, &val);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to read sensor data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = imx_init_calib(pdev, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(map, OCOTP_MEM0, &val);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to read sensor data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\timx_init_temp_grade(pdev, val);\n\n\treturn 0;\n}\n\nstatic int imx_init_from_nvmem_cells(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 val;\n\n\tret = nvmem_cell_read_u32(&pdev->dev, \"calib\", &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx_init_calib(pdev, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvmem_cell_read_u32(&pdev->dev, \"temp_grade\", &val);\n\tif (ret)\n\t\treturn ret;\n\timx_init_temp_grade(pdev, val);\n\n\treturn 0;\n}\n\nstatic irqreturn_t imx_thermal_alarm_irq(int irq, void *dev)\n{\n\tstruct imx_thermal_data *data = dev;\n\n\tdisable_irq_nosync(irq);\n\tdata->irq_enabled = false;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t imx_thermal_alarm_irq_thread(int irq, void *dev)\n{\n\tstruct imx_thermal_data *data = dev;\n\n\tdev_dbg(data->dev, \"THERMAL ALARM: T > %d\\n\", data->alarm_temp / 1000);\n\n\tthermal_zone_device_update(data->tz, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id of_imx_thermal_match[] = {\n\t{ .compatible = \"fsl,imx6q-tempmon\", .data = &thermal_imx6q_data, },\n\t{ .compatible = \"fsl,imx6sx-tempmon\", .data = &thermal_imx6sx_data, },\n\t{ .compatible = \"fsl,imx7d-tempmon\", .data = &thermal_imx7d_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_imx_thermal_match);\n\n#ifdef CONFIG_CPU_FREQ\n \nstatic int imx_thermal_register_legacy_cooling(struct imx_thermal_data *data)\n{\n\tstruct device_node *np;\n\tint ret = 0;\n\n\tdata->policy = cpufreq_cpu_get(0);\n\tif (!data->policy) {\n\t\tpr_debug(\"%s: CPUFreq policy not found\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tnp = of_get_cpu_node(data->policy->cpu, NULL);\n\n\tif (!np || !of_property_present(np, \"#cooling-cells\")) {\n\t\tdata->cdev = cpufreq_cooling_register(data->policy);\n\t\tif (IS_ERR(data->cdev)) {\n\t\t\tret = PTR_ERR(data->cdev);\n\t\t\tcpufreq_cpu_put(data->policy);\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\treturn ret;\n}\n\nstatic void imx_thermal_unregister_legacy_cooling(struct imx_thermal_data *data)\n{\n\tcpufreq_cooling_unregister(data->cdev);\n\tcpufreq_cpu_put(data->policy);\n}\n\n#else\n\nstatic inline int imx_thermal_register_legacy_cooling(struct imx_thermal_data *data)\n{\n\treturn 0;\n}\n\nstatic inline void imx_thermal_unregister_legacy_cooling(struct imx_thermal_data *data)\n{\n}\n#endif\n\nstatic int imx_thermal_probe(struct platform_device *pdev)\n{\n\tstruct imx_thermal_data *data;\n\tstruct regmap *map;\n\tint measure_freq;\n\tint ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &pdev->dev;\n\n\tmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, \"fsl,tempmon\");\n\tif (IS_ERR(map)) {\n\t\tret = PTR_ERR(map);\n\t\tdev_err(&pdev->dev, \"failed to get tempmon regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdata->tempmon = map;\n\n\tdata->socdata = of_device_get_match_data(&pdev->dev);\n\tif (!data->socdata) {\n\t\tdev_err(&pdev->dev, \"no device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (data->socdata->version == TEMPMON_IMX6SX) {\n\t\tregmap_write(map, IMX6_MISC1 + REG_CLR,\n\t\t\tIMX6_MISC1_IRQ_TEMPHIGH | IMX6_MISC1_IRQ_TEMPLOW\n\t\t\t| IMX6_MISC1_IRQ_TEMPPANIC);\n\t\t \n\t\tregmap_write(map, data->socdata->low_alarm_ctrl + REG_SET,\n\t\t\t     data->socdata->low_alarm_mask);\n\t}\n\n\tdata->irq = platform_get_irq(pdev, 0);\n\tif (data->irq < 0)\n\t\treturn data->irq;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tif (of_property_present(pdev->dev.of_node, \"nvmem-cells\")) {\n\t\tret = imx_init_from_nvmem_cells(pdev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"failed to init from nvmem\\n\");\n\t} else {\n\t\tret = imx_init_from_tempmon_data(pdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to init from fsl,tempmon-data\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tregmap_write(map, data->socdata->sensor_ctrl + REG_CLR,\n\t\t     data->socdata->power_down_mask);\n\tregmap_write(map, data->socdata->sensor_ctrl + REG_CLR,\n\t\t     data->socdata->measure_temp_mask);\n\tregmap_write(map, data->socdata->measure_freq_ctrl + REG_CLR,\n\t\t     data->socdata->measure_freq_mask);\n\tif (data->socdata->version != TEMPMON_IMX7D)\n\t\tregmap_write(map, IMX6_MISC0 + REG_SET,\n\t\t\tIMX6_MISC0_REFTOP_SELBIASOFF);\n\tregmap_write(map, data->socdata->sensor_ctrl + REG_SET,\n\t\t     data->socdata->power_down_mask);\n\n\tret = imx_thermal_register_legacy_cooling(data);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to register cpufreq cooling device\\n\");\n\n\tdata->thermal_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(data->thermal_clk)) {\n\t\tret = PTR_ERR(data->thermal_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get thermal clk: %d\\n\", ret);\n\t\tgoto legacy_cleanup;\n\t}\n\n\t \n\tret = clk_prepare_enable(data->thermal_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable thermal clk: %d\\n\", ret);\n\t\tgoto legacy_cleanup;\n\t}\n\n\tdata->tz = thermal_zone_device_register_with_trips(\"imx_thermal_zone\",\n\t\t\t\t\t\t\t   trips,\n\t\t\t\t\t\t\t   ARRAY_SIZE(trips),\n\t\t\t\t\t\t\t   BIT(IMX_TRIP_PASSIVE), data,\n\t\t\t\t\t\t\t   &imx_tz_ops, NULL,\n\t\t\t\t\t\t\t   IMX_PASSIVE_DELAY,\n\t\t\t\t\t\t\t   IMX_POLLING_DELAY);\n\tif (IS_ERR(data->tz)) {\n\t\tret = PTR_ERR(data->tz);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to register thermal zone device %d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\tdev_info(&pdev->dev, \"%s CPU temperature grade - max:%dC\"\n\t\t \" critical:%dC passive:%dC\\n\", data->temp_grade,\n\t\t data->temp_max / 1000, trips[IMX_TRIP_CRITICAL].temperature / 1000,\n\t\t trips[IMX_TRIP_PASSIVE].temperature / 1000);\n\n\t \n\tregmap_write(map, data->socdata->measure_freq_ctrl + REG_CLR,\n\t\t     data->socdata->measure_freq_mask);\n\tmeasure_freq = DIV_ROUND_UP(32768, 10);  \n\tregmap_write(map, data->socdata->measure_freq_ctrl + REG_SET,\n\t\t     measure_freq << data->socdata->measure_freq_shift);\n\timx_set_alarm_temp(data, trips[IMX_TRIP_PASSIVE].temperature);\n\n\tif (data->socdata->version == TEMPMON_IMX6SX)\n\t\timx_set_panic_temp(data, trips[IMX_TRIP_CRITICAL].temperature);\n\n\tregmap_write(map, data->socdata->sensor_ctrl + REG_CLR,\n\t\t     data->socdata->power_down_mask);\n\tregmap_write(map, data->socdata->sensor_ctrl + REG_SET,\n\t\t     data->socdata->measure_temp_mask);\n\t \n\tusleep_range(20, 50);\n\n\t \n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(data->dev);\n\n\tret = pm_runtime_resume_and_get(data->dev);\n\tif (ret < 0)\n\t\tgoto disable_runtime_pm;\n\n\tdata->irq_enabled = true;\n\tret = thermal_zone_device_enable(data->tz);\n\tif (ret)\n\t\tgoto thermal_zone_unregister;\n\n\tret = devm_request_threaded_irq(&pdev->dev, data->irq,\n\t\t\timx_thermal_alarm_irq, imx_thermal_alarm_irq_thread,\n\t\t\t0, \"imx_thermal\", data);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request alarm irq: %d\\n\", ret);\n\t\tgoto thermal_zone_unregister;\n\t}\n\n\tpm_runtime_put(data->dev);\n\n\treturn 0;\n\nthermal_zone_unregister:\n\tthermal_zone_device_unregister(data->tz);\ndisable_runtime_pm:\n\tpm_runtime_put_noidle(data->dev);\n\tpm_runtime_disable(data->dev);\nclk_disable:\n\tclk_disable_unprepare(data->thermal_clk);\nlegacy_cleanup:\n\timx_thermal_unregister_legacy_cooling(data);\n\n\treturn ret;\n}\n\nstatic int imx_thermal_remove(struct platform_device *pdev)\n{\n\tstruct imx_thermal_data *data = platform_get_drvdata(pdev);\n\n\tpm_runtime_put_noidle(data->dev);\n\tpm_runtime_disable(data->dev);\n\n\tthermal_zone_device_unregister(data->tz);\n\timx_thermal_unregister_legacy_cooling(data);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_thermal_suspend(struct device *dev)\n{\n\tstruct imx_thermal_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = thermal_zone_device_disable(data->tz);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pm_runtime_force_suspend(data->dev);\n}\n\nstatic int __maybe_unused imx_thermal_resume(struct device *dev)\n{\n\tstruct imx_thermal_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(data->dev);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn thermal_zone_device_enable(data->tz);\n}\n\nstatic int __maybe_unused imx_thermal_runtime_suspend(struct device *dev)\n{\n\tstruct imx_thermal_data *data = dev_get_drvdata(dev);\n\tconst struct thermal_soc_data *socdata = data->socdata;\n\tstruct regmap *map = data->tempmon;\n\tint ret;\n\n\tret = regmap_write(map, socdata->sensor_ctrl + REG_CLR,\n\t\t\t   socdata->measure_temp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(map, socdata->sensor_ctrl + REG_SET,\n\t\t\t   socdata->power_down_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(data->thermal_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_thermal_runtime_resume(struct device *dev)\n{\n\tstruct imx_thermal_data *data = dev_get_drvdata(dev);\n\tconst struct thermal_soc_data *socdata = data->socdata;\n\tstruct regmap *map = data->tempmon;\n\tint ret;\n\n\tret = clk_prepare_enable(data->thermal_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(map, socdata->sensor_ctrl + REG_CLR,\n\t\t\t   socdata->power_down_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(map, socdata->sensor_ctrl + REG_SET,\n\t\t\t   socdata->measure_temp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(20, 50);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx_thermal_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx_thermal_suspend, imx_thermal_resume)\n\tSET_RUNTIME_PM_OPS(imx_thermal_runtime_suspend,\n\t\t\t   imx_thermal_runtime_resume, NULL)\n};\n\nstatic struct platform_driver imx_thermal = {\n\t.driver = {\n\t\t.name\t= \"imx_thermal\",\n\t\t.pm\t= &imx_thermal_pm_ops,\n\t\t.of_match_table = of_imx_thermal_match,\n\t},\n\t.probe\t\t= imx_thermal_probe,\n\t.remove\t\t= imx_thermal_remove,\n};\nmodule_platform_driver(imx_thermal);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Thermal driver for Freescale i.MX SoCs\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx-thermal\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}