{
  "module_name": "st_thermal.c",
  "hash_id": "9056cfc3e95b6a48e84713c5af984ab6283a3a7c4dcaeb4f15fb59ab4dc7a771",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/st/st_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include \"st_thermal.h\"\n\n \n#define mcelsius(temp)\t\t\t((temp) * 1000)\n\n \nstatic int st_thermal_alloc_regfields(struct st_thermal_sensor *sensor)\n{\n\tstruct device *dev = sensor->dev;\n\tstruct regmap *regmap = sensor->regmap;\n\tconst struct reg_field *reg_fields = sensor->cdata->reg_fields;\n\n\tsensor->dcorrect = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t   reg_fields[DCORRECT]);\n\n\tsensor->overflow = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t   reg_fields[OVERFLOW]);\n\n\tsensor->temp_data = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\t    reg_fields[DATA]);\n\n\tif (IS_ERR(sensor->dcorrect) ||\n\t    IS_ERR(sensor->overflow) ||\n\t    IS_ERR(sensor->temp_data)) {\n\t\tdev_err(dev, \"failed to allocate common regfields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn sensor->ops->alloc_regfields(sensor);\n}\n\nstatic int st_thermal_sensor_on(struct st_thermal_sensor *sensor)\n{\n\tint ret;\n\tstruct device *dev = sensor->dev;\n\n\tret = clk_prepare_enable(sensor->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sensor->ops->power_ctrl(sensor, POWER_ON);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to power on sensor\\n\");\n\t\tclk_disable_unprepare(sensor->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int st_thermal_sensor_off(struct st_thermal_sensor *sensor)\n{\n\tint ret;\n\n\tret = sensor->ops->power_ctrl(sensor, POWER_OFF);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(sensor->clk);\n\n\treturn 0;\n}\n\nstatic int st_thermal_calibration(struct st_thermal_sensor *sensor)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct device *dev = sensor->dev;\n\n\t \n\tret = regmap_field_read(sensor->dcorrect, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read calibration data\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!val) {\n\t\t \n\t\tret = regmap_field_write(sensor->dcorrect,\n\t\t\t\t\t sensor->cdata->calibration_val);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to set calibration data\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic int st_thermal_get_temp(struct thermal_zone_device *th, int *temperature)\n{\n\tstruct st_thermal_sensor *sensor = thermal_zone_device_priv(th);\n\tunsigned int temp;\n\tunsigned int overflow;\n\tint ret;\n\n\tret = regmap_field_read(sensor->overflow, &overflow);\n\tif (ret)\n\t\treturn ret;\n\tif (overflow)\n\t\treturn -EIO;\n\n\tret = regmap_field_read(sensor->temp_data, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp += sensor->cdata->temp_adjust_val;\n\ttemp = mcelsius(temp);\n\n\t*temperature = temp;\n\n\treturn 0;\n}\n\nstatic struct thermal_zone_device_ops st_tz_ops = {\n\t.get_temp\t= st_thermal_get_temp,\n};\n\nstatic struct thermal_trip trip;\n\nint st_thermal_register(struct platform_device *pdev,\n\t\t\tconst struct of_device_id *st_thermal_of_match)\n{\n\tstruct st_thermal_sensor *sensor;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct of_device_id *match;\n\n\tint polling_delay;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(dev, \"device tree node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tsensor->dev = dev;\n\n\tmatch = of_match_device(st_thermal_of_match, dev);\n\tif (!(match && match->data))\n\t\treturn -EINVAL;\n\n\tsensor->cdata = match->data;\n\tif (!sensor->cdata->ops)\n\t\treturn -EINVAL;\n\n\tsensor->ops = sensor->cdata->ops;\n\n\tret = (sensor->ops->regmap_init)(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = st_thermal_alloc_regfields(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tsensor->clk = devm_clk_get(dev, \"thermal\");\n\tif (IS_ERR(sensor->clk)) {\n\t\tdev_err(dev, \"failed to fetch clock\\n\");\n\t\treturn PTR_ERR(sensor->clk);\n\t}\n\n\tif (sensor->ops->register_enable_irq) {\n\t\tret = sensor->ops->register_enable_irq(sensor);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = st_thermal_sensor_on(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = st_thermal_calibration(sensor);\n\tif (ret)\n\t\tgoto sensor_off;\n\n\tpolling_delay = sensor->ops->register_enable_irq ? 0 : 1000;\n\n\ttrip.temperature = sensor->cdata->crit_temp;\n\ttrip.type = THERMAL_TRIP_CRITICAL;\n\n\tsensor->thermal_dev =\n\t\tthermal_zone_device_register_with_trips(dev_name(dev), &trip, 1, 0, sensor,\n\t\t\t\t\t\t\t&st_tz_ops, NULL, 0, polling_delay);\n\tif (IS_ERR(sensor->thermal_dev)) {\n\t\tdev_err(dev, \"failed to register thermal zone device\\n\");\n\t\tret = PTR_ERR(sensor->thermal_dev);\n\t\tgoto sensor_off;\n\t}\n\tret = thermal_zone_device_enable(sensor->thermal_dev);\n\tif (ret)\n\t\tgoto tzd_unregister;\n\n\tplatform_set_drvdata(pdev, sensor);\n\n\treturn 0;\n\ntzd_unregister:\n\tthermal_zone_device_unregister(sensor->thermal_dev);\nsensor_off:\n\tst_thermal_sensor_off(sensor);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(st_thermal_register);\n\nvoid st_thermal_unregister(struct platform_device *pdev)\n{\n\tstruct st_thermal_sensor *sensor = platform_get_drvdata(pdev);\n\n\tst_thermal_sensor_off(sensor);\n\tthermal_zone_device_unregister(sensor->thermal_dev);\n}\nEXPORT_SYMBOL_GPL(st_thermal_unregister);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int st_thermal_suspend(struct device *dev)\n{\n\tstruct st_thermal_sensor *sensor = dev_get_drvdata(dev);\n\n\treturn st_thermal_sensor_off(sensor);\n}\n\nstatic int st_thermal_resume(struct device *dev)\n{\n\tint ret;\n\tstruct st_thermal_sensor *sensor = dev_get_drvdata(dev);\n\n\tret = st_thermal_sensor_on(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = st_thermal_calibration(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sensor->ops->enable_irq) {\n\t\tret = sensor->ops->enable_irq(sensor);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nSIMPLE_DEV_PM_OPS(st_thermal_pm_ops, st_thermal_suspend, st_thermal_resume);\nEXPORT_SYMBOL_GPL(st_thermal_pm_ops);\n\nMODULE_AUTHOR(\"STMicroelectronics (R&D) Limited <ajitpal.singh@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STi SoC Thermal Sensor Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}