{
  "module_name": "stm_thermal.c",
  "hash_id": "344716150085152e14458df25755bf735e25598a23e4f5bdcf488f728ed34abc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/st/stm_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n\n#include \"../thermal_hwmon.h\"\n\n \n#define DTS_CFGR1_OFFSET\t0x0\n#define DTS_T0VALR1_OFFSET\t0x8\n#define DTS_RAMPVALR_OFFSET\t0X10\n#define DTS_ITR1_OFFSET\t\t0x14\n#define DTS_DR_OFFSET\t\t0x1C\n#define DTS_SR_OFFSET\t\t0x20\n#define DTS_ITENR_OFFSET\t0x24\n#define DTS_ICIFR_OFFSET\t0x28\n\n \n#define HSREF_CLK_DIV_MASK\tGENMASK(30, 24)\n#define TS1_SMP_TIME_MASK\tGENMASK(19, 16)\n#define TS1_INTRIG_SEL_MASK\tGENMASK(11, 8)\n\n \n#define TS1_T0_MASK\t\tGENMASK(17, 16)\n#define TS1_FMT0_MASK\t\tGENMASK(15, 0)\n\n \n#define TS1_RAMP_COEFF_MASK\tGENMASK(15, 0)\n\n \n#define TS1_HITTHD_MASK\t\tGENMASK(31, 16)\n#define TS1_LITTHD_MASK\t\tGENMASK(15, 0)\n\n \n#define TS1_MFREQ_MASK\t\tGENMASK(15, 0)\n\n \n#define ITENR_MASK\t\t(GENMASK(2, 0) | GENMASK(6, 4))\n\n \n#define ICIFR_MASK\t\t(GENMASK(2, 0) | GENMASK(6, 4))\n\n \n#define TS1_T0_POS\t\t16\n#define TS1_HITTHD_POS\t\t16\n#define TS1_LITTHD_POS\t\t0\n#define HSREF_CLK_DIV_POS\t24\n\n \n#define TS1_EN\t\t\tBIT(0)\n#define TS1_START\t\tBIT(4)\n#define REFCLK_SEL\t\tBIT(20)\n#define REFCLK_LSE\t\tREFCLK_SEL\n#define Q_MEAS_OPT\t\tBIT(21)\n#define CALIBRATION_CONTROL\tQ_MEAS_OPT\n\n \n#define TS_RDY\t\t\tBIT(15)\n \n#define HIGH_THRESHOLD\t\tBIT(2)\n#define LOW_THRESHOLD\t\tBIT(1)\n\n \n#define ADJUST\t\t\t100\n#define ONE_MHZ\t\t\t1000000\n#define POLL_TIMEOUT\t\t5000\n#define STARTUP_TIME\t\t40\n#define TS1_T0_VAL0\t\t30000   \n#define TS1_T0_VAL1\t\t130000  \n#define NO_HW_TRIG\t\t0\n#define SAMPLING_TIME\t\t15\n\nstruct stm_thermal_sensor {\n\tstruct device *dev;\n\tstruct thermal_zone_device *th_dev;\n\tenum thermal_device_mode mode;\n\tstruct clk *clk;\n\tunsigned int low_temp_enabled;\n\tunsigned int high_temp_enabled;\n\tint irq;\n\tvoid __iomem *base;\n\tint t0, fmt0, ramp_coeff;\n};\n\nstatic int stm_enable_irq(struct stm_thermal_sensor *sensor)\n{\n\tu32 value;\n\n\tdev_dbg(sensor->dev, \"low:%d high:%d\\n\", sensor->low_temp_enabled,\n\t\tsensor->high_temp_enabled);\n\n\t \n\tvalue = readl_relaxed(sensor->base + DTS_ITENR_OFFSET);\n\tvalue &= ~(LOW_THRESHOLD | HIGH_THRESHOLD);\n\n\tif (sensor->low_temp_enabled)\n\t\tvalue |= HIGH_THRESHOLD;\n\n\tif (sensor->high_temp_enabled)\n\t\tvalue |= LOW_THRESHOLD;\n\n\t \n\twritel_relaxed(value, sensor->base + DTS_ITENR_OFFSET);\n\n\treturn 0;\n}\n\nstatic irqreturn_t stm_thermal_irq_handler(int irq, void *sdata)\n{\n\tstruct stm_thermal_sensor *sensor = sdata;\n\n\tdev_dbg(sensor->dev, \"sr:%d\\n\",\n\t\treadl_relaxed(sensor->base + DTS_SR_OFFSET));\n\n\tthermal_zone_device_update(sensor->th_dev, THERMAL_EVENT_UNSPECIFIED);\n\n\tstm_enable_irq(sensor);\n\n\t \n\twritel_relaxed(ICIFR_MASK, sensor->base + DTS_ICIFR_OFFSET);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stm_sensor_power_on(struct stm_thermal_sensor *sensor)\n{\n\tint ret;\n\tu32 value;\n\n\t \n\tvalue = readl_relaxed(sensor->base + DTS_CFGR1_OFFSET);\n\tvalue |= TS1_EN;\n\twritel_relaxed(value, sensor->base + DTS_CFGR1_OFFSET);\n\n\t \n\tret = readl_poll_timeout(sensor->base + DTS_SR_OFFSET,\n\t\t\t\t value, (value & TS_RDY),\n\t\t\t\t STARTUP_TIME, POLL_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvalue = readl_relaxed(sensor->base +\n\t\t\t      DTS_CFGR1_OFFSET);\n\tvalue |= TS1_START;\n\twritel_relaxed(value, sensor->base +\n\t\t       DTS_CFGR1_OFFSET);\n\n\tsensor->mode = THERMAL_DEVICE_ENABLED;\n\n\treturn 0;\n}\n\nstatic int stm_sensor_power_off(struct stm_thermal_sensor *sensor)\n{\n\tu32 value;\n\n\tsensor->mode = THERMAL_DEVICE_DISABLED;\n\n\t \n\tvalue = readl_relaxed(sensor->base + DTS_CFGR1_OFFSET);\n\tvalue &= ~TS1_START;\n\twritel_relaxed(value, sensor->base + DTS_CFGR1_OFFSET);\n\n\t \n\tusleep_range(STARTUP_TIME, POLL_TIMEOUT);\n\n\t \n\tvalue = readl_relaxed(sensor->base + DTS_CFGR1_OFFSET);\n\tvalue &= ~TS1_EN;\n\twritel_relaxed(value, sensor->base + DTS_CFGR1_OFFSET);\n\n\t \n\treturn readl_poll_timeout(sensor->base + DTS_SR_OFFSET, value,\n\t\t\t\t  !(value & TS_RDY),\n\t\t\t\t  STARTUP_TIME, POLL_TIMEOUT);\n}\n\nstatic int stm_thermal_calibration(struct stm_thermal_sensor *sensor)\n{\n\tu32 value, clk_freq;\n\tu32 prescaler;\n\n\t \n\tclk_freq = clk_get_rate(sensor->clk);\n\tif (!clk_freq)\n\t\treturn -EINVAL;\n\n\tprescaler = 0;\n\tclk_freq /= ONE_MHZ;\n\tif (clk_freq) {\n\t\twhile (prescaler <= clk_freq)\n\t\t\tprescaler++;\n\t}\n\n\tvalue = readl_relaxed(sensor->base + DTS_CFGR1_OFFSET);\n\n\t \n\tvalue &= ~HSREF_CLK_DIV_MASK;\n\n\t \n\tvalue |= (prescaler << HSREF_CLK_DIV_POS);\n\n\t \n\tvalue &= ~REFCLK_SEL;\n\n\t \n\tvalue |= TS1_SMP_TIME_MASK;\n\n\t \n\tvalue &= ~CALIBRATION_CONTROL;\n\n\t \n\tvalue &= ~TS1_INTRIG_SEL_MASK;\n\tvalue |= NO_HW_TRIG;\n\n\twritel_relaxed(value, sensor->base + DTS_CFGR1_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic int stm_thermal_read_factory_settings(struct stm_thermal_sensor *sensor)\n{\n\t \n\tsensor->t0 = readl_relaxed(sensor->base + DTS_T0VALR1_OFFSET) &\n\t\t\t\t\tTS1_T0_MASK;\n\tif (!sensor->t0)\n\t\tsensor->t0 = TS1_T0_VAL0;\n\telse\n\t\tsensor->t0 = TS1_T0_VAL1;\n\n\t \n\tsensor->fmt0 = ADJUST * (readl_relaxed(sensor->base +\n\t\t\t\t DTS_T0VALR1_OFFSET) & TS1_FMT0_MASK);\n\n\t \n\tsensor->ramp_coeff = readl_relaxed(sensor->base + DTS_RAMPVALR_OFFSET) &\n\t\t\t\t\t   TS1_RAMP_COEFF_MASK;\n\n\tif (!sensor->fmt0 || !sensor->ramp_coeff) {\n\t\tdev_err(sensor->dev, \"%s: wrong setting\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(sensor->dev, \"%s: T0 = %doC, FMT0 = %dHz, RAMP_COEFF = %dHz/oC\",\n\t\t__func__, sensor->t0, sensor->fmt0, sensor->ramp_coeff);\n\n\treturn 0;\n}\n\nstatic int stm_thermal_calculate_threshold(struct stm_thermal_sensor *sensor,\n\t\t\t\t\t   int temp, u32 *th)\n{\n\tint freqM;\n\n\t \n\tfreqM = ((temp - sensor->t0) * sensor->ramp_coeff) / 1000 +\n\t\tsensor->fmt0;\n\n\t \n\t*th = clk_get_rate(sensor->clk) * SAMPLING_TIME / freqM;\n\tif (!*th)\n\t\treturn -EINVAL;\n\n\tdev_dbg(sensor->dev, \"freqM=%d Hz, threshold=0x%x\", freqM, *th);\n\n\treturn 0;\n}\n\n \nstatic int stm_disable_irq(struct stm_thermal_sensor *sensor)\n{\n\tu32 value;\n\n\t \n\tvalue = readl_relaxed(sensor->base + DTS_ITENR_OFFSET);\n\tvalue &= ~ITENR_MASK;\n\twritel_relaxed(value, sensor->base + DTS_ITENR_OFFSET);\n\n\treturn 0;\n}\n\nstatic int stm_thermal_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct stm_thermal_sensor *sensor = thermal_zone_device_priv(tz);\n\tu32 itr1, th;\n\tint ret;\n\n\tdev_dbg(sensor->dev, \"set trips %d <--> %d\\n\", low, high);\n\n\t \n\titr1 = readl_relaxed(sensor->base + DTS_ITR1_OFFSET);\n\titr1 &= ~(TS1_LITTHD_MASK | TS1_HITTHD_MASK);\n\n\t \n\n\tif (low > -INT_MAX) {\n\t\tsensor->low_temp_enabled = 1;\n\t\t \n\t\tret = stm_thermal_calculate_threshold(sensor, low - 500, &th);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\titr1 |= (TS1_HITTHD_MASK  & (th << TS1_HITTHD_POS));\n\t} else {\n\t\tsensor->low_temp_enabled = 0;\n\t}\n\n\t \n\tif (high < INT_MAX) {\n\t\tsensor->high_temp_enabled = 1;\n\t\tret = stm_thermal_calculate_threshold(sensor, high, &th);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\titr1 |= (TS1_LITTHD_MASK  & (th << TS1_LITTHD_POS));\n\t} else {\n\t\tsensor->high_temp_enabled = 0;\n\t}\n\n\t \n\twritel_relaxed(itr1, sensor->base + DTS_ITR1_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic int stm_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct stm_thermal_sensor *sensor = thermal_zone_device_priv(tz);\n\tu32 periods;\n\tint freqM, ret;\n\n\tif (sensor->mode != THERMAL_DEVICE_ENABLED)\n\t\treturn -EAGAIN;\n\n\t \n\tret = readl_relaxed_poll_timeout(sensor->base + DTS_DR_OFFSET, periods,\n\t\t\t\t\t (periods & TS1_MFREQ_MASK),\n\t\t\t\t\t STARTUP_TIME, POLL_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfreqM = (clk_get_rate(sensor->clk) * SAMPLING_TIME) / periods;\n\tif (!freqM)\n\t\treturn -EINVAL;\n\n\t \n\t*temp = (freqM - sensor->fmt0) * 1000 / sensor->ramp_coeff + sensor->t0;\n\n\treturn 0;\n}\n\n \nstatic int stm_register_irq(struct stm_thermal_sensor *sensor)\n{\n\tstruct device *dev = sensor->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\n\tsensor->irq = platform_get_irq(pdev, 0);\n\tif (sensor->irq < 0)\n\t\treturn sensor->irq;\n\n\tret = devm_request_threaded_irq(dev, sensor->irq,\n\t\t\t\t\tNULL,\n\t\t\t\t\tstm_thermal_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\tdev->driver->name, sensor);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: Failed to register IRQ %d\\n\", __func__,\n\t\t\tsensor->irq);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"%s: thermal IRQ registered\", __func__);\n\n\treturn 0;\n}\n\nstatic int stm_thermal_sensor_off(struct stm_thermal_sensor *sensor)\n{\n\tint ret;\n\n\tstm_disable_irq(sensor);\n\n\tret = stm_sensor_power_off(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(sensor->clk);\n\n\treturn 0;\n}\n\nstatic int stm_thermal_prepare(struct stm_thermal_sensor *sensor)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(sensor->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm_thermal_read_factory_settings(sensor);\n\tif (ret)\n\t\tgoto thermal_unprepare;\n\n\tret = stm_thermal_calibration(sensor);\n\tif (ret)\n\t\tgoto thermal_unprepare;\n\n\treturn 0;\n\nthermal_unprepare:\n\tclk_disable_unprepare(sensor->clk);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm_thermal_suspend(struct device *dev)\n{\n\tstruct stm_thermal_sensor *sensor = dev_get_drvdata(dev);\n\n\treturn stm_thermal_sensor_off(sensor);\n}\n\nstatic int stm_thermal_resume(struct device *dev)\n{\n\tint ret;\n\tstruct stm_thermal_sensor *sensor = dev_get_drvdata(dev);\n\n\tret = stm_thermal_prepare(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm_sensor_power_on(sensor);\n\tif (ret)\n\t\treturn ret;\n\n\tthermal_zone_device_update(sensor->th_dev, THERMAL_EVENT_UNSPECIFIED);\n\tstm_enable_irq(sensor);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(stm_thermal_pm_ops,\n\t\t\t stm_thermal_suspend, stm_thermal_resume);\n\nstatic const struct thermal_zone_device_ops stm_tz_ops = {\n\t.get_temp\t= stm_thermal_get_temp,\n\t.set_trips\t= stm_thermal_set_trips,\n};\n\nstatic const struct of_device_id stm_thermal_of_match[] = {\n\t\t{ .compatible = \"st,stm32-thermal\"},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, stm_thermal_of_match);\n\nstatic int stm_thermal_probe(struct platform_device *pdev)\n{\n\tstruct stm_thermal_sensor *sensor;\n\tvoid __iomem *base;\n\tint ret;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"%s: device tree node not found\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsensor = devm_kzalloc(&pdev->dev, sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, sensor);\n\n\tsensor->dev = &pdev->dev;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t \n\tsensor->base = base;\n\n\tsensor->clk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(sensor->clk)) {\n\t\tdev_err(&pdev->dev, \"%s: failed to fetch PCLK clock\\n\",\n\t\t\t__func__);\n\t\treturn PTR_ERR(sensor->clk);\n\t}\n\n\tstm_disable_irq(sensor);\n\n\t \n\twritel_relaxed(ICIFR_MASK, sensor->base + DTS_ICIFR_OFFSET);\n\n\t \n\tret = stm_thermal_prepare(sensor);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error prepare sensor: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = stm_sensor_power_on(sensor);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error power on sensor: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsensor->th_dev = devm_thermal_of_zone_register(&pdev->dev, 0,\n\t\t\t\t\t\t       sensor,\n\t\t\t\t\t\t       &stm_tz_ops);\n\n\tif (IS_ERR(sensor->th_dev)) {\n\t\tdev_err(&pdev->dev, \"%s: thermal zone sensor registering KO\\n\",\n\t\t\t__func__);\n\t\tret = PTR_ERR(sensor->th_dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = stm_register_irq(sensor);\n\tif (ret)\n\t\tgoto err_tz;\n\n\tstm_enable_irq(sensor);\n\n\t \n\tret = thermal_add_hwmon_sysfs(sensor->th_dev);\n\tif (ret)\n\t\tgoto err_tz;\n\n\tdev_info(&pdev->dev, \"%s: Driver initialized successfully\\n\",\n\t\t __func__);\n\n\treturn 0;\n\nerr_tz:\n\treturn ret;\n}\n\nstatic int stm_thermal_remove(struct platform_device *pdev)\n{\n\tstruct stm_thermal_sensor *sensor = platform_get_drvdata(pdev);\n\n\tstm_thermal_sensor_off(sensor);\n\tthermal_remove_hwmon_sysfs(sensor->th_dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver stm_thermal_driver = {\n\t.driver = {\n\t\t.name\t= \"stm_thermal\",\n\t\t.pm     = &stm_thermal_pm_ops,\n\t\t.of_match_table = stm_thermal_of_match,\n\t},\n\t.probe\t\t= stm_thermal_probe,\n\t.remove\t\t= stm_thermal_remove,\n};\nmodule_platform_driver(stm_thermal_driver);\n\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Thermal Sensor Driver\");\nMODULE_AUTHOR(\"David Hernandez Sanchez <david.hernandezsanchez@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:stm_thermal\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}