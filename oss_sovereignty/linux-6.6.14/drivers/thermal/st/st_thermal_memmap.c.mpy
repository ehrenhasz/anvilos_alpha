{
  "module_name": "st_thermal_memmap.c",
  "hash_id": "3efcde79bb02bb6a4277e1ae9048baa682c0173c55e266561be47d8720381ad7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/st/st_thermal_memmap.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/module.h>\n\n#include \"st_thermal.h\"\n\n#define STIH416_MPE_CONF\t\t\t0x0\n#define STIH416_MPE_STATUS\t\t\t0x4\n#define STIH416_MPE_INT_THRESH\t\t\t0x8\n#define STIH416_MPE_INT_EN\t\t\t0xC\n\n \n#define THERMAL_PDN\t\t\t\tBIT(4)\n#define THERMAL_SRSTN\t\t\t\tBIT(10)\n\nstatic const struct reg_field st_mmap_thermal_regfields[MAX_REGFIELDS] = {\n\t \n\t[INT_THRESH_HI]\t= REG_FIELD(STIH416_MPE_INT_THRESH, \t0,  7),\n\t[DCORRECT]\t= REG_FIELD(STIH416_MPE_CONF,\t\t5,  9),\n\t[OVERFLOW]\t= REG_FIELD(STIH416_MPE_STATUS,\t\t9,  9),\n\t[DATA]\t\t= REG_FIELD(STIH416_MPE_STATUS,\t\t11, 18),\n\t[INT_ENABLE]\t= REG_FIELD(STIH416_MPE_INT_EN,\t\t0,  0),\n};\n\nstatic irqreturn_t st_mmap_thermal_trip_handler(int irq, void *sdata)\n{\n\tstruct st_thermal_sensor *sensor = sdata;\n\n\tthermal_zone_device_update(sensor->thermal_dev,\n\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int st_mmap_power_ctrl(struct st_thermal_sensor *sensor,\n\t\t\t      enum st_thermal_power_state power_state)\n{\n\tconst unsigned int mask = (THERMAL_PDN | THERMAL_SRSTN);\n\tconst unsigned int val = power_state ? mask : 0;\n\n\treturn regmap_update_bits(sensor->regmap, STIH416_MPE_CONF, mask, val);\n}\n\nstatic int st_mmap_alloc_regfields(struct st_thermal_sensor *sensor)\n{\n\tstruct device *dev = sensor->dev;\n\tstruct regmap *regmap = sensor->regmap;\n\tconst struct reg_field *reg_fields = sensor->cdata->reg_fields;\n\n\tsensor->int_thresh_hi = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\treg_fields[INT_THRESH_HI]);\n\tsensor->int_enable = devm_regmap_field_alloc(dev, regmap,\n\t\t\t\t\t\treg_fields[INT_ENABLE]);\n\n\tif (IS_ERR(sensor->int_thresh_hi) || IS_ERR(sensor->int_enable)) {\n\t\tdev_err(dev, \"failed to alloc mmap regfields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_mmap_enable_irq(struct st_thermal_sensor *sensor)\n{\n\tint ret;\n\n\t \n\tret = regmap_field_write(sensor->int_thresh_hi,\n\t\t\t\t sensor->cdata->crit_temp -\n\t\t\t\t sensor->cdata->temp_adjust_val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_field_write(sensor->int_enable, 1);\n}\n\nstatic int st_mmap_register_enable_irq(struct st_thermal_sensor *sensor)\n{\n\tstruct device *dev = sensor->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\n\tsensor->irq = platform_get_irq(pdev, 0);\n\tif (sensor->irq < 0)\n\t\treturn sensor->irq;\n\n\tret = devm_request_threaded_irq(dev, sensor->irq,\n\t\t\t\t\tNULL, st_mmap_thermal_trip_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdev->driver->name, sensor);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register IRQ %d\\n\", sensor->irq);\n\t\treturn ret;\n\t}\n\n\treturn st_mmap_enable_irq(sensor);\n}\n\nstatic const struct regmap_config st_416mpe_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int st_mmap_regmap_init(struct st_thermal_sensor *sensor)\n{\n\tstruct device *dev = sensor->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tsensor->mmio_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(sensor->mmio_base))\n\t\treturn PTR_ERR(sensor->mmio_base);\n\n\tsensor->regmap = devm_regmap_init_mmio(dev, sensor->mmio_base,\n\t\t\t\t&st_416mpe_regmap_config);\n\tif (IS_ERR(sensor->regmap)) {\n\t\tdev_err(dev, \"failed to initialise regmap\\n\");\n\t\treturn PTR_ERR(sensor->regmap);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct st_thermal_sensor_ops st_mmap_sensor_ops = {\n\t.power_ctrl\t\t= st_mmap_power_ctrl,\n\t.alloc_regfields\t= st_mmap_alloc_regfields,\n\t.regmap_init\t\t= st_mmap_regmap_init,\n\t.register_enable_irq\t= st_mmap_register_enable_irq,\n\t.enable_irq\t\t= st_mmap_enable_irq,\n};\n\n \nstatic const struct st_thermal_compat_data st_416mpe_cdata = {\n\t.reg_fields\t\t= st_mmap_thermal_regfields,\n\t.ops\t\t\t= &st_mmap_sensor_ops,\n\t.calibration_val\t= 14,\n\t.temp_adjust_val\t= -95,\n\t.crit_temp\t\t= 120,\n};\n\n \nstatic const struct st_thermal_compat_data st_407_cdata = {\n\t.reg_fields\t\t= st_mmap_thermal_regfields,\n\t.ops\t\t\t= &st_mmap_sensor_ops,\n\t.calibration_val\t= 16,\n\t.temp_adjust_val\t= -95,\n\t.crit_temp\t\t= 120,\n};\n\nstatic const struct of_device_id st_mmap_thermal_of_match[] = {\n\t{ .compatible = \"st,stih416-mpe-thermal\", .data = &st_416mpe_cdata },\n\t{ .compatible = \"st,stih407-thermal\",     .data = &st_407_cdata },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, st_mmap_thermal_of_match);\n\nstatic int st_mmap_probe(struct platform_device *pdev)\n{\n\treturn st_thermal_register(pdev,  st_mmap_thermal_of_match);\n}\n\nstatic void st_mmap_remove(struct platform_device *pdev)\n{\n\tst_thermal_unregister(pdev);\n}\n\nstatic struct platform_driver st_mmap_thermal_driver = {\n\t.driver = {\n\t\t.name\t= \"st_thermal_mmap\",\n\t\t.pm     = &st_thermal_pm_ops,\n\t\t.of_match_table = st_mmap_thermal_of_match,\n\t},\n\t.probe\t\t= st_mmap_probe,\n\t.remove_new\t= st_mmap_remove,\n};\n\nmodule_platform_driver(st_mmap_thermal_driver);\n\nMODULE_AUTHOR(\"STMicroelectronics (R&D) Limited <ajitpal.singh@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STi SoC Thermal Sensor Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}