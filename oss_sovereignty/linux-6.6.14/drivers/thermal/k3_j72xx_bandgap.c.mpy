{
  "module_name": "k3_j72xx_bandgap.c",
  "hash_id": "be3e2e14b2702345fca03c61d52bdc7851ae947c3c45e382ae91108f14770196",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/k3_j72xx_bandgap.c",
  "human_readable_source": "\n \n\n#include <linux/math.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/thermal.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#define K3_VTM_DEVINFO_PWR0_OFFSET\t\t0x4\n#define K3_VTM_DEVINFO_PWR0_TEMPSENS_CT_MASK\t0xf0\n#define K3_VTM_TMPSENS0_CTRL_OFFSET\t\t0x300\n#define K3_VTM_MISC_CTRL_OFFSET\t\t\t0xc\n#define K3_VTM_TMPSENS_STAT_OFFSET\t\t0x8\n#define K3_VTM_ANYMAXT_OUTRG_ALERT_EN\t\t0x1\n#define K3_VTM_MISC_CTRL2_OFFSET\t\t0x10\n#define K3_VTM_TS_STAT_DTEMP_MASK\t\t0x3ff\n#define K3_VTM_MAX_NUM_TS\t\t\t8\n#define K3_VTM_TMPSENS_CTRL_SOC\t\t\tBIT(5)\n#define K3_VTM_TMPSENS_CTRL_CLRZ\t\tBIT(6)\n#define K3_VTM_TMPSENS_CTRL_CLKON_REQ\t\tBIT(7)\n#define K3_VTM_TMPSENS_CTRL_MAXT_OUTRG_EN\tBIT(11)\n\n#define K3_VTM_CORRECTION_TEMP_CNT\t\t3\n\n#define MINUS40CREF\t\t\t\t5\n#define PLUS30CREF\t\t\t\t253\n#define PLUS125CREF\t\t\t\t730\n#define PLUS150CREF\t\t\t\t940\n\n#define TABLE_SIZE\t\t\t\t1024\n#define MAX_TEMP\t\t\t\t123000\n#define COOL_DOWN_TEMP\t\t\t\t105000\n\n#define FACTORS_REDUCTION\t\t\t13\nstatic int *derived_table;\n\nstatic int compute_value(int index, const s64 *factors, int nr_factors,\n\t\t\t int reduction)\n{\n\ts64 value = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_factors; i++)\n\t\tvalue += factors[i] * int_pow(index, i);\n\n\treturn (int)div64_s64(value, int_pow(10, reduction));\n}\n\nstatic void init_table(int factors_size, int *table, const s64 *factors)\n{\n\tint i;\n\n\tfor (i = 0; i < TABLE_SIZE; i++)\n\t\ttable[i] = compute_value(i, factors, factors_size,\n\t\t\t\t\t FACTORS_REDUCTION);\n}\n\n \nstruct err_values {\n\tint refs[4];\n\tint errs[4];\n};\n\nstatic void create_table_segments(struct err_values *err_vals, int seg,\n\t\t\t\t  int *ref_table)\n{\n\tint m = 0, c, num, den, i, err, idx1, idx2, err1, err2, ref1, ref2;\n\n\tif (seg == 0)\n\t\tidx1 = 0;\n\telse\n\t\tidx1 = err_vals->refs[seg];\n\n\tidx2 = err_vals->refs[seg + 1];\n\terr1 = err_vals->errs[seg];\n\terr2 = err_vals->errs[seg + 1];\n\tref1 = err_vals->refs[seg];\n\tref2 = err_vals->refs[seg + 1];\n\n\t \n\tnum = ref2 - ref1;\n\tden = err2 - err1;\n\tif (den)\n\t\tm = num / den;\n\tc = ref2 - m * err2;\n\n\t \n\tif (den != 0 && m != 0) {\n\t\tfor (i = idx1; i <= idx2; i++) {\n\t\t\terr = (i - c) / m;\n\t\t\tif (((i + err) < 0) || ((i + err) >= TABLE_SIZE))\n\t\t\t\tcontinue;\n\t\t\tderived_table[i] = ref_table[i + err];\n\t\t}\n\t} else {  \n\t\tfor (i = idx1; i <= idx2; i++) {\n\t\t\tif (((i + err1) < 0) || ((i + err1) >= TABLE_SIZE))\n\t\t\t\tcontinue;\n\t\t\tderived_table[i] = ref_table[i + err1];\n\t\t}\n\t}\n}\n\nstatic int prep_lookup_table(struct err_values *err_vals, int *ref_table)\n{\n\tint inc, i, seg;\n\n\t \n\tfor (seg = 0; seg < 3; seg++)\n\t\tcreate_table_segments(err_vals, seg, ref_table);\n\n\t \n\ti = 0;\n\twhile (!derived_table[i])\n\t\ti++;\n\n\t \n\tif (i) {\n\t\t \n\t\twhile (i--)\n\t\t\tderived_table[i] = derived_table[i + 1] - 300;\n\t}\n\n\t \n\ti = TABLE_SIZE - 1;\n\twhile (!derived_table[i])\n\t\ti--;\n\n\ti++;\n\tinc = 1;\n\twhile (i < TABLE_SIZE) {\n\t\tderived_table[i] = derived_table[i - 1] + inc * 100;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstruct k3_thermal_data;\n\nstruct k3_j72xx_bandgap {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *cfg2_base;\n\tstruct k3_thermal_data *ts_data[K3_VTM_MAX_NUM_TS];\n};\n\n \nstruct k3_thermal_data {\n\tstruct k3_j72xx_bandgap *bgp;\n\tu32 ctrl_offset;\n\tu32 stat_offset;\n};\n\nstatic int two_cmp(int tmp, int mask)\n{\n\ttmp = ~(tmp);\n\ttmp &= mask;\n\ttmp += 1;\n\n\t \n\treturn (0 - tmp);\n}\n\nstatic unsigned int vtm_get_best_value(unsigned int s0, unsigned int s1,\n\t\t\t\t       unsigned int s2)\n{\n\tint d01 = abs(s0 - s1);\n\tint d02 = abs(s0 - s2);\n\tint d12 = abs(s1 - s2);\n\n\tif (d01 <= d02 && d01 <= d12)\n\t\treturn (s0 + s1) / 2;\n\n\tif (d02 <= d01 && d02 <= d12)\n\t\treturn (s0 + s2) / 2;\n\n\treturn (s1 + s2) / 2;\n}\n\nstatic inline int k3_bgp_read_temp(struct k3_thermal_data *devdata,\n\t\t\t\t   int *temp)\n{\n\tstruct k3_j72xx_bandgap *bgp;\n\tunsigned int dtemp, s0, s1, s2;\n\n\tbgp = devdata->bgp;\n\t \n\ts0 = readl(bgp->base + devdata->stat_offset) &\n\t\tK3_VTM_TS_STAT_DTEMP_MASK;\n\ts1 = readl(bgp->base + devdata->stat_offset) &\n\t\tK3_VTM_TS_STAT_DTEMP_MASK;\n\ts2 = readl(bgp->base + devdata->stat_offset) &\n\t\tK3_VTM_TS_STAT_DTEMP_MASK;\n\tdtemp = vtm_get_best_value(s0, s1, s2);\n\n\tif (dtemp < 0 || dtemp >= TABLE_SIZE)\n\t\treturn -EINVAL;\n\n\t*temp = derived_table[dtemp];\n\n\treturn 0;\n}\n\n \nstatic int k3_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\treturn k3_bgp_read_temp(thermal_zone_device_priv(tz), temp);\n}\n\nstatic const struct thermal_zone_device_ops k3_of_thermal_ops = {\n\t.get_temp = k3_thermal_get_temp,\n};\n\nstatic int k3_j72xx_bandgap_temp_to_adc_code(int temp)\n{\n\tint low = 0, high = TABLE_SIZE - 1, mid;\n\n\tif (temp > 160000 || temp < -50000)\n\t\treturn -EINVAL;\n\n\t \n\twhile (low < (high - 1)) {\n\t\tmid = (low + high) / 2;\n\t\tif (temp <= derived_table[mid])\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid;\n\t}\n\n\treturn mid;\n}\n\nstatic void get_efuse_values(int id, struct k3_thermal_data *data, int *err,\n\t\t\t     void __iomem *fuse_base)\n{\n\tint i, tmp, pow;\n\tint ct_offsets[5][K3_VTM_CORRECTION_TEMP_CNT] = {\n\t\t{ 0x0, 0x8, 0x4 },\n\t\t{ 0x0, 0x8, 0x4 },\n\t\t{ 0x0, -1,  0x4 },\n\t\t{ 0x0, 0xC, -1 },\n\t\t{ 0x0, 0xc, 0x8 }\n\t};\n\tint ct_bm[5][K3_VTM_CORRECTION_TEMP_CNT] = {\n\t\t{ 0x3f, 0x1fe000, 0x1ff },\n\t\t{ 0xfc0, 0x1fe000, 0x3fe00 },\n\t\t{ 0x3f000, 0x7f800000, 0x7fc0000 },\n\t\t{ 0xfc0000, 0x1fe0, 0x1f800000 },\n\t\t{ 0x3f000000, 0x1fe000, 0x1ff0 }\n\t};\n\n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\tif (ct_offsets[id][i] == -1 && i == 1) {\n\t\t\t \n\t\t\ttmp = (readl(fuse_base + 0x8) & 0xE0000000) >> (29);\n\t\t\ttmp |= ((readl(fuse_base + 0xC) & 0x1F) << 3);\n\t\t\tpow = tmp & 0x80;\n\t\t} else if (ct_offsets[id][i] == -1 && i == 2) {\n\t\t\t \n\t\t\ttmp = (readl(fuse_base + 0x4) & 0xF8000000) >> (27);\n\t\t\ttmp |= ((readl(fuse_base + 0x8) & 0xF) << 5);\n\t\t\tpow = tmp & 0x100;\n\t\t} else {\n\t\t\ttmp = readl(fuse_base + ct_offsets[id][i]);\n\t\t\ttmp &= ct_bm[id][i];\n\t\t\ttmp = tmp >> __ffs(ct_bm[id][i]);\n\n\t\t\t \n\t\t\tpow = ct_bm[id][i] >> __ffs(ct_bm[id][i]);\n\t\t\tpow += 1;\n\t\t\tpow /= 2;\n\t\t}\n\n\t\t \n\t\tif (tmp & pow) {\n\t\t\t \n\t\t\ttmp = two_cmp(tmp, ct_bm[id][i] >> __ffs(ct_bm[id][i]));\n\t\t}\n\t\terr[i] = tmp;\n\t}\n\n\t \n\terr[i] = 0;\n}\n\nstatic void print_look_up_table(struct device *dev, int *ref_table)\n{\n\tint i;\n\n\tdev_dbg(dev, \"The contents of derived array\\n\");\n\tdev_dbg(dev, \"Code   Temperature\\n\");\n\tfor (i = 0; i < TABLE_SIZE; i++)\n\t\tdev_dbg(dev, \"%d       %d %d\\n\", i, derived_table[i], ref_table[i]);\n}\n\nstruct k3_j72xx_bandgap_data {\n\tconst bool has_errata_i2128;\n};\n\nstatic int k3_j72xx_bandgap_probe(struct platform_device *pdev)\n{\n\tint ret = 0, cnt, val, id;\n\tint high_max, low_temp;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct k3_j72xx_bandgap *bgp;\n\tstruct k3_thermal_data *data;\n\tbool workaround_needed = false;\n\tconst struct k3_j72xx_bandgap_data *driver_data;\n\tstruct thermal_zone_device *ti_thermal;\n\tint *ref_table;\n\tstruct err_values err_vals;\n\tvoid __iomem *fuse_base;\n\n\tconst s64 golden_factors[] = {\n\t\t-490019999999999936,\n\t\t3251200000000000,\n\t\t-1705800000000,\n\t\t603730000,\n\t\t-92627,\n\t};\n\n\tconst s64 pvt_wa_factors[] = {\n\t\t-415230000000000000,\n\t\t3126600000000000,\n\t\t-1157800000000,\n\t};\n\n\tbgp = devm_kzalloc(&pdev->dev, sizeof(*bgp), GFP_KERNEL);\n\tif (!bgp)\n\t\treturn -ENOMEM;\n\n\tbgp->dev = dev;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbgp->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(bgp->base))\n\t\treturn PTR_ERR(bgp->base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tbgp->cfg2_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(bgp->cfg2_base))\n\t\treturn PTR_ERR(bgp->cfg2_base);\n\n\tdriver_data = of_device_get_match_data(dev);\n\tif (driver_data)\n\t\tworkaround_needed = driver_data->has_errata_i2128;\n\n\t \n\tif (workaround_needed) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\t\tfuse_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(fuse_base))\n\t\t\treturn PTR_ERR(fuse_base);\n\n\t\tif ((readl(fuse_base) & 0xc0000000) == 0xc0000000)\n\t\t\tworkaround_needed = false;\n\t}\n\n\tdev_dbg(bgp->dev, \"Work around %sneeded\\n\",\n\t\tworkaround_needed ? \"\" : \"not \");\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\tpm_runtime_disable(dev);\n\t\treturn ret;\n\t}\n\n\t \n\tval = readl(bgp->base + K3_VTM_DEVINFO_PWR0_OFFSET);\n\tcnt = val & K3_VTM_DEVINFO_PWR0_TEMPSENS_CT_MASK;\n\tcnt >>= __ffs(K3_VTM_DEVINFO_PWR0_TEMPSENS_CT_MASK);\n\n\tdata = devm_kcalloc(bgp->dev, cnt, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tref_table = kzalloc(sizeof(*ref_table) * TABLE_SIZE, GFP_KERNEL);\n\tif (!ref_table) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tderived_table = devm_kzalloc(bgp->dev, sizeof(*derived_table) * TABLE_SIZE,\n\t\t\t\t     GFP_KERNEL);\n\tif (!derived_table) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ref_table;\n\t}\n\n\tif (!workaround_needed)\n\t\tinit_table(5, ref_table, golden_factors);\n\telse\n\t\tinit_table(3, ref_table, pvt_wa_factors);\n\n\t \n\tfor (id = 0; id < cnt; id++) {\n\t\tdata[id].bgp = bgp;\n\t\tdata[id].ctrl_offset = K3_VTM_TMPSENS0_CTRL_OFFSET + id * 0x20;\n\t\tdata[id].stat_offset = data[id].ctrl_offset +\n\t\t\t\t\tK3_VTM_TMPSENS_STAT_OFFSET;\n\n\t\tif (workaround_needed) {\n\t\t\t \n\t\t\terr_vals.refs[0] = MINUS40CREF;\n\t\t\terr_vals.refs[1] = PLUS30CREF;\n\t\t\terr_vals.refs[2] = PLUS125CREF;\n\t\t\terr_vals.refs[3] = PLUS150CREF;\n\t\t\tget_efuse_values(id, &data[id], err_vals.errs, fuse_base);\n\t\t}\n\n\t\tif (id == 0 && workaround_needed)\n\t\t\tprep_lookup_table(&err_vals, ref_table);\n\t\telse if (id == 0 && !workaround_needed)\n\t\t\tmemcpy(derived_table, ref_table, TABLE_SIZE * 4);\n\n\t\tval = readl(data[id].bgp->cfg2_base + data[id].ctrl_offset);\n\t\tval |= (K3_VTM_TMPSENS_CTRL_MAXT_OUTRG_EN |\n\t\t\tK3_VTM_TMPSENS_CTRL_SOC |\n\t\t\tK3_VTM_TMPSENS_CTRL_CLRZ | BIT(4));\n\t\twritel(val, data[id].bgp->cfg2_base + data[id].ctrl_offset);\n\n\t\tbgp->ts_data[id] = &data[id];\n\t\tti_thermal = devm_thermal_of_zone_register(bgp->dev, id, &data[id],\n\t\t\t\t\t\t\t   &k3_of_thermal_ops);\n\t\tif (IS_ERR(ti_thermal)) {\n\t\t\tdev_err(bgp->dev, \"thermal zone device is NULL\\n\");\n\t\t\tret = PTR_ERR(ti_thermal);\n\t\t\tgoto err_free_ref_table;\n\t\t}\n\t}\n\n\t \n\thigh_max = k3_j72xx_bandgap_temp_to_adc_code(MAX_TEMP);\n\tlow_temp = k3_j72xx_bandgap_temp_to_adc_code(COOL_DOWN_TEMP);\n\n\twritel((low_temp << 16) | high_max, data[0].bgp->cfg2_base +\n\t       K3_VTM_MISC_CTRL2_OFFSET);\n\tmdelay(100);\n\twritel(K3_VTM_ANYMAXT_OUTRG_ALERT_EN, data[0].bgp->cfg2_base +\n\t       K3_VTM_MISC_CTRL_OFFSET);\n\n\tprint_look_up_table(dev, ref_table);\n\t \n\tkfree(ref_table);\n\n\treturn 0;\n\nerr_free_ref_table:\n\tkfree(ref_table);\n\nerr_alloc:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int k3_j72xx_bandgap_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct k3_j72xx_bandgap_data k3_j72xx_bandgap_j721e_data = {\n\t.has_errata_i2128 = true,\n};\n\nstatic const struct k3_j72xx_bandgap_data k3_j72xx_bandgap_j7200_data = {\n\t.has_errata_i2128 = false,\n};\n\nstatic const struct of_device_id of_k3_j72xx_bandgap_match[] = {\n\t{\n\t\t.compatible = \"ti,j721e-vtm\",\n\t\t.data = &k3_j72xx_bandgap_j721e_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j7200-vtm\",\n\t\t.data = &k3_j72xx_bandgap_j7200_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, of_k3_j72xx_bandgap_match);\n\nstatic struct platform_driver k3_j72xx_bandgap_sensor_driver = {\n\t.probe = k3_j72xx_bandgap_probe,\n\t.remove = k3_j72xx_bandgap_remove,\n\t.driver = {\n\t\t.name = \"k3-j72xx-soc-thermal\",\n\t\t.of_match_table\t= of_k3_j72xx_bandgap_match,\n\t},\n};\n\nmodule_platform_driver(k3_j72xx_bandgap_sensor_driver);\n\nMODULE_DESCRIPTION(\"K3 bandgap temperature sensor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"J Keerthy <j-keerthy@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}