{
  "module_name": "imx_sc_thermal.c",
  "hash_id": "f75bd0009adf31de8cfa34e1b196b95883d7a0438aa9eac9d4c9d2ef01e6ea05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/imx_sc_thermal.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/err.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n\n#define IMX_SC_MISC_FUNC_GET_TEMP\t13\n\nstatic struct imx_sc_ipc *thermal_ipc_handle;\n\nstruct imx_sc_sensor {\n\tstruct thermal_zone_device *tzd;\n\tu32 resource_id;\n};\n\nstruct req_get_temp {\n\tu16 resource_id;\n\tu8 type;\n} __packed __aligned(4);\n\nstruct resp_get_temp {\n\ts16 celsius;\n\ts8 tenths;\n} __packed __aligned(4);\n\nstruct imx_sc_msg_misc_get_temp {\n\tstruct imx_sc_rpc_msg hdr;\n\tunion {\n\t\tstruct req_get_temp req;\n\t\tstruct resp_get_temp resp;\n\t} data;\n} __packed __aligned(4);\n\nstatic int imx_sc_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct imx_sc_msg_misc_get_temp msg;\n\tstruct imx_sc_rpc_msg *hdr = &msg.hdr;\n\tstruct imx_sc_sensor *sensor = thermal_zone_device_priv(tz);\n\tint ret;\n\n\tmsg.data.req.resource_id = sensor->resource_id;\n\tmsg.data.req.type = IMX_SC_C_TEMP;\n\n\thdr->ver = IMX_SC_RPC_VERSION;\n\thdr->svc = IMX_SC_RPC_SVC_MISC;\n\thdr->func = IMX_SC_MISC_FUNC_GET_TEMP;\n\thdr->size = 2;\n\n\tret = imx_scu_call_rpc(thermal_ipc_handle, &msg, true);\n\tif (ret)\n\t\treturn ret;\n\n\t*temp = msg.data.resp.celsius * 1000 + msg.data.resp.tenths * 100;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops imx_sc_thermal_ops = {\n\t.get_temp = imx_sc_thermal_get_temp,\n};\n\nstatic int imx_sc_thermal_probe(struct platform_device *pdev)\n{\n\tstruct imx_sc_sensor *sensor;\n\tconst int *resource_id;\n\tint i, ret;\n\n\tret = imx_scu_get_handle(&thermal_ipc_handle);\n\tif (ret)\n\t\treturn ret;\n\n\tresource_id = of_device_get_match_data(&pdev->dev);\n\tif (!resource_id)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; resource_id[i] >= 0; i++) {\n\n\t\tsensor = devm_kzalloc(&pdev->dev, sizeof(*sensor), GFP_KERNEL);\n\t\tif (!sensor)\n\t\t\treturn -ENOMEM;\n\n\t\tsensor->resource_id = resource_id[i];\n\n\t\tsensor->tzd = devm_thermal_of_zone_register(&pdev->dev, sensor->resource_id,\n\t\t\t\t\t\t\t    sensor, &imx_sc_thermal_ops);\n\t\tif (IS_ERR(sensor->tzd)) {\n\t\t\t \n\t\t\tret = PTR_ERR(sensor->tzd);\n\n\t\t\tdevm_kfree(&pdev->dev, sensor);\n\n\t\t\t \n\t\t\tif (ret == -ENODEV)\n\t\t\t\tcontinue;\n\n\t\t\tdev_err(&pdev->dev, \"failed to register thermal zone\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdevm_thermal_add_hwmon_sysfs(&pdev->dev, sensor->tzd);\n\t}\n\n\treturn 0;\n}\n\nstatic const int imx_sc_sensors[] = {\n\tIMX_SC_R_SYSTEM, IMX_SC_R_PMIC_0,\n\tIMX_SC_R_AP_0, IMX_SC_R_AP_1,\n\tIMX_SC_R_GPU_0_PID0, IMX_SC_R_GPU_1_PID0,\n\tIMX_SC_R_DRC_0, -1 };\n\nstatic const struct of_device_id imx_sc_thermal_table[] = {\n\t{ .compatible = \"fsl,imx-sc-thermal\", .data =  imx_sc_sensors },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, imx_sc_thermal_table);\n\nstatic struct platform_driver imx_sc_thermal_driver = {\n\t\t.probe = imx_sc_thermal_probe,\n\t\t.driver = {\n\t\t\t.name = \"imx-sc-thermal\",\n\t\t\t.of_match_table = imx_sc_thermal_table,\n\t\t},\n};\nmodule_platform_driver(imx_sc_thermal_driver);\n\nMODULE_AUTHOR(\"Anson Huang <Anson.Huang@nxp.com>\");\nMODULE_DESCRIPTION(\"Thermal driver for NXP i.MX SoCs with system controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}