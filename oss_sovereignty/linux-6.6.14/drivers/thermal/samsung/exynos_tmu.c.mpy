{
  "module_name": "exynos_tmu.c",
  "hash_id": "08d87dacec1598e1b11570af03b14fef7a01f5354f552f68c2138cbd983880b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/samsung/exynos_tmu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/thermal.h>\n\n#include <dt-bindings/thermal/thermal_exynos.h>\n\n \n#define EXYNOS_TMU_REG_TRIMINFO\t\t0x0\n#define EXYNOS_TMU_REG_CONTROL\t\t0x20\n#define EXYNOS_TMU_REG_STATUS\t\t0x28\n#define EXYNOS_TMU_REG_CURRENT_TEMP\t0x40\n#define EXYNOS_TMU_REG_INTEN\t\t0x70\n#define EXYNOS_TMU_REG_INTSTAT\t\t0x74\n#define EXYNOS_TMU_REG_INTCLEAR\t\t0x78\n\n#define EXYNOS_TMU_TEMP_MASK\t\t0xff\n#define EXYNOS_TMU_REF_VOLTAGE_SHIFT\t24\n#define EXYNOS_TMU_REF_VOLTAGE_MASK\t0x1f\n#define EXYNOS_TMU_BUF_SLOPE_SEL_MASK\t0xf\n#define EXYNOS_TMU_BUF_SLOPE_SEL_SHIFT\t8\n#define EXYNOS_TMU_CORE_EN_SHIFT\t0\n\n \n#define EXYNOS_TMU_TRIMINFO_CON1\t0x10\n\n \n#define EXYNOS4210_TMU_REG_THRESHOLD_TEMP\t0x44\n#define EXYNOS4210_TMU_REG_TRIG_LEVEL0\t0x50\n\n \n#define EXYNOS_TMU_TRIMINFO_CON2\t0x14\n#define EXYNOS_THD_TEMP_RISE\t\t0x50\n#define EXYNOS_THD_TEMP_FALL\t\t0x54\n#define EXYNOS_EMUL_CON\t\t0x80\n\n#define EXYNOS_TRIMINFO_RELOAD_ENABLE\t1\n#define EXYNOS_TRIMINFO_25_SHIFT\t0\n#define EXYNOS_TRIMINFO_85_SHIFT\t8\n#define EXYNOS_TMU_TRIP_MODE_SHIFT\t13\n#define EXYNOS_TMU_TRIP_MODE_MASK\t0x7\n#define EXYNOS_TMU_THERM_TRIP_EN_SHIFT\t12\n\n#define EXYNOS_TMU_INTEN_RISE0_SHIFT\t0\n#define EXYNOS_TMU_INTEN_FALL0_SHIFT\t16\n\n#define EXYNOS_EMUL_TIME\t0x57F0\n#define EXYNOS_EMUL_TIME_MASK\t0xffff\n#define EXYNOS_EMUL_TIME_SHIFT\t16\n#define EXYNOS_EMUL_DATA_SHIFT\t8\n#define EXYNOS_EMUL_DATA_MASK\t0xFF\n#define EXYNOS_EMUL_ENABLE\t0x1\n\n \n#define EXYNOS5260_TMU_REG_INTEN\t\t0xC0\n#define EXYNOS5260_TMU_REG_INTSTAT\t\t0xC4\n#define EXYNOS5260_TMU_REG_INTCLEAR\t\t0xC8\n#define EXYNOS5260_EMUL_CON\t\t\t0x100\n\n \n#define EXYNOS4412_MUX_ADDR_VALUE          6\n#define EXYNOS4412_MUX_ADDR_SHIFT          20\n\n \n#define EXYNOS5433_THD_TEMP_RISE3_0\t\t0x050\n#define EXYNOS5433_THD_TEMP_RISE7_4\t\t0x054\n#define EXYNOS5433_THD_TEMP_FALL3_0\t\t0x060\n#define EXYNOS5433_THD_TEMP_FALL7_4\t\t0x064\n#define EXYNOS5433_TMU_REG_INTEN\t\t0x0c0\n#define EXYNOS5433_TMU_REG_INTPEND\t\t0x0c8\n#define EXYNOS5433_TMU_EMUL_CON\t\t\t0x110\n#define EXYNOS5433_TMU_PD_DET_EN\t\t0x130\n\n#define EXYNOS5433_TRIMINFO_SENSOR_ID_SHIFT\t16\n#define EXYNOS5433_TRIMINFO_CALIB_SEL_SHIFT\t23\n#define EXYNOS5433_TRIMINFO_SENSOR_ID_MASK\t\\\n\t\t\t(0xf << EXYNOS5433_TRIMINFO_SENSOR_ID_SHIFT)\n#define EXYNOS5433_TRIMINFO_CALIB_SEL_MASK\tBIT(23)\n\n#define EXYNOS5433_TRIMINFO_ONE_POINT_TRIMMING\t0\n#define EXYNOS5433_TRIMINFO_TWO_POINT_TRIMMING\t1\n\n#define EXYNOS5433_PD_DET_EN\t\t\t1\n\n#define EXYNOS5433_G3D_BASE\t\t\t0x10070000\n\n \n#define EXYNOS7_THD_TEMP_RISE7_6\t\t0x50\n#define EXYNOS7_THD_TEMP_FALL7_6\t\t0x60\n#define EXYNOS7_TMU_REG_INTEN\t\t\t0x110\n#define EXYNOS7_TMU_REG_INTPEND\t\t\t0x118\n#define EXYNOS7_TMU_REG_EMUL_CON\t\t0x160\n\n#define EXYNOS7_TMU_TEMP_MASK\t\t\t0x1ff\n#define EXYNOS7_PD_DET_EN_SHIFT\t\t\t23\n#define EXYNOS7_TMU_INTEN_RISE0_SHIFT\t\t0\n#define EXYNOS7_EMUL_DATA_SHIFT\t\t\t7\n#define EXYNOS7_EMUL_DATA_MASK\t\t\t0x1ff\n\n#define EXYNOS_FIRST_POINT_TRIM\t\t\t25\n#define EXYNOS_SECOND_POINT_TRIM\t\t85\n\n#define EXYNOS_NOISE_CANCEL_MODE\t\t4\n\n#define MCELSIUS\t1000\n\nenum soc_type {\n\tSOC_ARCH_EXYNOS3250 = 1,\n\tSOC_ARCH_EXYNOS4210,\n\tSOC_ARCH_EXYNOS4412,\n\tSOC_ARCH_EXYNOS5250,\n\tSOC_ARCH_EXYNOS5260,\n\tSOC_ARCH_EXYNOS5420,\n\tSOC_ARCH_EXYNOS5420_TRIMINFO,\n\tSOC_ARCH_EXYNOS5433,\n\tSOC_ARCH_EXYNOS7,\n};\n\n \nstruct exynos_tmu_data {\n\tint id;\n\tvoid __iomem *base;\n\tvoid __iomem *base_second;\n\tint irq;\n\tenum soc_type soc;\n\tstruct work_struct irq_work;\n\tstruct mutex lock;\n\tstruct clk *clk, *clk_sec, *sclk;\n\tu32 cal_type;\n\tu32 efuse_value;\n\tu32 min_efuse_value;\n\tu32 max_efuse_value;\n\tu16 temp_error1, temp_error2;\n\tu8 gain;\n\tu8 reference_voltage;\n\tstruct regulator *regulator;\n\tstruct thermal_zone_device *tzd;\n\tunsigned int ntrip;\n\tbool enabled;\n\n\tvoid (*tmu_set_trip_temp)(struct exynos_tmu_data *data, int trip,\n\t\t\t\t u8 temp);\n\tvoid (*tmu_set_trip_hyst)(struct exynos_tmu_data *data, int trip,\n\t\t\t\t u8 temp, u8 hyst);\n\tvoid (*tmu_initialize)(struct platform_device *pdev);\n\tvoid (*tmu_control)(struct platform_device *pdev, bool on);\n\tint (*tmu_read)(struct exynos_tmu_data *data);\n\tvoid (*tmu_set_emulation)(struct exynos_tmu_data *data, int temp);\n\tvoid (*tmu_clear_irqs)(struct exynos_tmu_data *data);\n};\n\n \nstatic int temp_to_code(struct exynos_tmu_data *data, u8 temp)\n{\n\tif (data->cal_type == TYPE_ONE_POINT_TRIMMING)\n\t\treturn temp + data->temp_error1 - EXYNOS_FIRST_POINT_TRIM;\n\n\treturn (temp - EXYNOS_FIRST_POINT_TRIM) *\n\t\t(data->temp_error2 - data->temp_error1) /\n\t\t(EXYNOS_SECOND_POINT_TRIM - EXYNOS_FIRST_POINT_TRIM) +\n\t\tdata->temp_error1;\n}\n\n \nstatic int code_to_temp(struct exynos_tmu_data *data, u16 temp_code)\n{\n\tif (data->cal_type == TYPE_ONE_POINT_TRIMMING)\n\t\treturn temp_code - data->temp_error1 + EXYNOS_FIRST_POINT_TRIM;\n\n\treturn (temp_code - data->temp_error1) *\n\t\t(EXYNOS_SECOND_POINT_TRIM - EXYNOS_FIRST_POINT_TRIM) /\n\t\t(data->temp_error2 - data->temp_error1) +\n\t\tEXYNOS_FIRST_POINT_TRIM;\n}\n\nstatic void sanitize_temp_error(struct exynos_tmu_data *data, u32 trim_info)\n{\n\tu16 tmu_temp_mask =\n\t\t(data->soc == SOC_ARCH_EXYNOS7) ? EXYNOS7_TMU_TEMP_MASK\n\t\t\t\t\t\t: EXYNOS_TMU_TEMP_MASK;\n\n\tdata->temp_error1 = trim_info & tmu_temp_mask;\n\tdata->temp_error2 = ((trim_info >> EXYNOS_TRIMINFO_85_SHIFT) &\n\t\t\t\tEXYNOS_TMU_TEMP_MASK);\n\n\tif (!data->temp_error1 ||\n\t    (data->min_efuse_value > data->temp_error1) ||\n\t    (data->temp_error1 > data->max_efuse_value))\n\t\tdata->temp_error1 = data->efuse_value & EXYNOS_TMU_TEMP_MASK;\n\n\tif (!data->temp_error2)\n\t\tdata->temp_error2 =\n\t\t\t(data->efuse_value >> EXYNOS_TRIMINFO_85_SHIFT) &\n\t\t\tEXYNOS_TMU_TEMP_MASK;\n}\n\nstatic int exynos_tmu_initialize(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tstruct thermal_zone_device *tzd = data->tzd;\n\tint num_trips = thermal_zone_get_num_trips(tzd);\n\tunsigned int status;\n\tint ret = 0, temp;\n\n\tret = thermal_zone_get_crit_temp(tzd, &temp);\n\tif (ret && data->soc != SOC_ARCH_EXYNOS5433) {  \n\t\tdev_err(&pdev->dev,\n\t\t\t\"No CRITICAL trip point defined in device tree!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (num_trips > data->ntrip) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"More trip points than supported by this TMU.\\n\");\n\t\tdev_info(&pdev->dev,\n\t\t\t \"%d trip points should be configured in polling mode.\\n\",\n\t\t\t num_trips - data->ntrip);\n\t}\n\n\tmutex_lock(&data->lock);\n\tclk_enable(data->clk);\n\tif (!IS_ERR(data->clk_sec))\n\t\tclk_enable(data->clk_sec);\n\n\tstatus = readb(data->base + EXYNOS_TMU_REG_STATUS);\n\tif (!status) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tint i, ntrips =\n\t\t\tmin_t(int, num_trips, data->ntrip);\n\n\t\tdata->tmu_initialize(pdev);\n\n\t\t \n\t\tfor (i = 0; i < ntrips; i++) {\n\n\t\t\tstruct thermal_trip trip;\n\n\t\t\tret = thermal_zone_get_trip(tzd, i, &trip);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tdata->tmu_set_trip_temp(data, i, trip.temperature / MCELSIUS);\n\t\t\tdata->tmu_set_trip_hyst(data, i, trip.temperature / MCELSIUS,\n\t\t\t\t\t\ttrip.hysteresis / MCELSIUS);\n\t\t}\n\n\t\tdata->tmu_clear_irqs(data);\n\t}\nerr:\n\tclk_disable(data->clk);\n\tmutex_unlock(&data->lock);\n\tif (!IS_ERR(data->clk_sec))\n\t\tclk_disable(data->clk_sec);\nout:\n\treturn ret;\n}\n\nstatic u32 get_con_reg(struct exynos_tmu_data *data, u32 con)\n{\n\tif (data->soc == SOC_ARCH_EXYNOS4412 ||\n\t    data->soc == SOC_ARCH_EXYNOS3250)\n\t\tcon |= (EXYNOS4412_MUX_ADDR_VALUE << EXYNOS4412_MUX_ADDR_SHIFT);\n\n\tcon &= ~(EXYNOS_TMU_REF_VOLTAGE_MASK << EXYNOS_TMU_REF_VOLTAGE_SHIFT);\n\tcon |= data->reference_voltage << EXYNOS_TMU_REF_VOLTAGE_SHIFT;\n\n\tcon &= ~(EXYNOS_TMU_BUF_SLOPE_SEL_MASK << EXYNOS_TMU_BUF_SLOPE_SEL_SHIFT);\n\tcon |= (data->gain << EXYNOS_TMU_BUF_SLOPE_SEL_SHIFT);\n\n\tcon &= ~(EXYNOS_TMU_TRIP_MODE_MASK << EXYNOS_TMU_TRIP_MODE_SHIFT);\n\tcon |= (EXYNOS_NOISE_CANCEL_MODE << EXYNOS_TMU_TRIP_MODE_SHIFT);\n\n\treturn con;\n}\n\nstatic void exynos_tmu_control(struct platform_device *pdev, bool on)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\n\tmutex_lock(&data->lock);\n\tclk_enable(data->clk);\n\tdata->tmu_control(pdev, on);\n\tdata->enabled = on;\n\tclk_disable(data->clk);\n\tmutex_unlock(&data->lock);\n}\n\nstatic void exynos4210_tmu_set_trip_temp(struct exynos_tmu_data *data,\n\t\t\t\t\t int trip_id, u8 temp)\n{\n\tstruct thermal_trip trip;\n\tu8 ref, th_code;\n\n\tif (thermal_zone_get_trip(data->tzd, 0, &trip))\n\t\treturn;\n\n\tref = trip.temperature / MCELSIUS;\n\n\tif (trip_id == 0) {\n\t\tth_code = temp_to_code(data, ref);\n\t\twriteb(th_code, data->base + EXYNOS4210_TMU_REG_THRESHOLD_TEMP);\n\t}\n\n\ttemp -= ref;\n\twriteb(temp, data->base + EXYNOS4210_TMU_REG_TRIG_LEVEL0 + trip_id * 4);\n}\n\n \nstatic void exynos4210_tmu_set_trip_hyst(struct exynos_tmu_data *data,\n\t\t\t\t\t int trip, u8 temp, u8 hyst)\n{\n}\n\nstatic void exynos4210_tmu_initialize(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\n\tsanitize_temp_error(data, readl(data->base + EXYNOS_TMU_REG_TRIMINFO));\n}\n\nstatic void exynos4412_tmu_set_trip_temp(struct exynos_tmu_data *data,\n\t\t\t\t\t int trip, u8 temp)\n{\n\tu32 th, con;\n\n\tth = readl(data->base + EXYNOS_THD_TEMP_RISE);\n\tth &= ~(0xff << 8 * trip);\n\tth |= temp_to_code(data, temp) << 8 * trip;\n\twritel(th, data->base + EXYNOS_THD_TEMP_RISE);\n\n\tif (trip == 3) {\n\t\tcon = readl(data->base + EXYNOS_TMU_REG_CONTROL);\n\t\tcon |= (1 << EXYNOS_TMU_THERM_TRIP_EN_SHIFT);\n\t\twritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\n\t}\n}\n\nstatic void exynos4412_tmu_set_trip_hyst(struct exynos_tmu_data *data,\n\t\t\t\t\t int trip, u8 temp, u8 hyst)\n{\n\tu32 th;\n\n\tth = readl(data->base + EXYNOS_THD_TEMP_FALL);\n\tth &= ~(0xff << 8 * trip);\n\tif (hyst)\n\t\tth |= temp_to_code(data, temp - hyst) << 8 * trip;\n\twritel(th, data->base + EXYNOS_THD_TEMP_FALL);\n}\n\nstatic void exynos4412_tmu_initialize(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tunsigned int trim_info, ctrl;\n\n\tif (data->soc == SOC_ARCH_EXYNOS3250 ||\n\t    data->soc == SOC_ARCH_EXYNOS4412 ||\n\t    data->soc == SOC_ARCH_EXYNOS5250) {\n\t\tif (data->soc == SOC_ARCH_EXYNOS3250) {\n\t\t\tctrl = readl(data->base + EXYNOS_TMU_TRIMINFO_CON1);\n\t\t\tctrl |= EXYNOS_TRIMINFO_RELOAD_ENABLE;\n\t\t\twritel(ctrl, data->base + EXYNOS_TMU_TRIMINFO_CON1);\n\t\t}\n\t\tctrl = readl(data->base + EXYNOS_TMU_TRIMINFO_CON2);\n\t\tctrl |= EXYNOS_TRIMINFO_RELOAD_ENABLE;\n\t\twritel(ctrl, data->base + EXYNOS_TMU_TRIMINFO_CON2);\n\t}\n\n\t \n\tif (data->soc == SOC_ARCH_EXYNOS5420_TRIMINFO)\n\t\ttrim_info = readl(data->base_second + EXYNOS_TMU_REG_TRIMINFO);\n\telse\n\t\ttrim_info = readl(data->base + EXYNOS_TMU_REG_TRIMINFO);\n\n\tsanitize_temp_error(data, trim_info);\n}\n\nstatic void exynos5433_tmu_set_trip_temp(struct exynos_tmu_data *data,\n\t\t\t\t\t int trip, u8 temp)\n{\n\tunsigned int reg_off, j;\n\tu32 th;\n\n\tif (trip > 3) {\n\t\treg_off = EXYNOS5433_THD_TEMP_RISE7_4;\n\t\tj = trip - 4;\n\t} else {\n\t\treg_off = EXYNOS5433_THD_TEMP_RISE3_0;\n\t\tj = trip;\n\t}\n\n\tth = readl(data->base + reg_off);\n\tth &= ~(0xff << j * 8);\n\tth |= (temp_to_code(data, temp) << j * 8);\n\twritel(th, data->base + reg_off);\n}\n\nstatic void exynos5433_tmu_set_trip_hyst(struct exynos_tmu_data *data,\n\t\t\t\t\t int trip, u8 temp, u8 hyst)\n{\n\tunsigned int reg_off, j;\n\tu32 th;\n\n\tif (trip > 3) {\n\t\treg_off = EXYNOS5433_THD_TEMP_FALL7_4;\n\t\tj = trip - 4;\n\t} else {\n\t\treg_off = EXYNOS5433_THD_TEMP_FALL3_0;\n\t\tj = trip;\n\t}\n\n\tth = readl(data->base + reg_off);\n\tth &= ~(0xff << j * 8);\n\tth |= (temp_to_code(data, temp - hyst) << j * 8);\n\twritel(th, data->base + reg_off);\n}\n\nstatic void exynos5433_tmu_initialize(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tunsigned int trim_info;\n\tint sensor_id, cal_type;\n\n\ttrim_info = readl(data->base + EXYNOS_TMU_REG_TRIMINFO);\n\tsanitize_temp_error(data, trim_info);\n\n\t \n\tsensor_id = (trim_info & EXYNOS5433_TRIMINFO_SENSOR_ID_MASK)\n\t\t\t\t>> EXYNOS5433_TRIMINFO_SENSOR_ID_SHIFT;\n\tdev_info(&pdev->dev, \"Temperature sensor ID: 0x%x\\n\", sensor_id);\n\n\t \n\twritel(trim_info, data->base + EXYNOS_TMU_REG_TRIMINFO);\n\tcal_type = (trim_info & EXYNOS5433_TRIMINFO_CALIB_SEL_MASK)\n\t\t\t\t>> EXYNOS5433_TRIMINFO_CALIB_SEL_SHIFT;\n\n\tswitch (cal_type) {\n\tcase EXYNOS5433_TRIMINFO_TWO_POINT_TRIMMING:\n\t\tdata->cal_type = TYPE_TWO_POINT_TRIMMING;\n\t\tbreak;\n\tcase EXYNOS5433_TRIMINFO_ONE_POINT_TRIMMING:\n\tdefault:\n\t\tdata->cal_type = TYPE_ONE_POINT_TRIMMING;\n\t\tbreak;\n\t}\n\n\tdev_info(&pdev->dev, \"Calibration type is %d-point calibration\\n\",\n\t\t\tcal_type ?  2 : 1);\n}\n\nstatic void exynos7_tmu_set_trip_temp(struct exynos_tmu_data *data,\n\t\t\t\t      int trip, u8 temp)\n{\n\tunsigned int reg_off, bit_off;\n\tu32 th;\n\n\treg_off = ((7 - trip) / 2) * 4;\n\tbit_off = ((8 - trip) % 2);\n\n\tth = readl(data->base + EXYNOS7_THD_TEMP_RISE7_6 + reg_off);\n\tth &= ~(EXYNOS7_TMU_TEMP_MASK << (16 * bit_off));\n\tth |= temp_to_code(data, temp) << (16 * bit_off);\n\twritel(th, data->base + EXYNOS7_THD_TEMP_RISE7_6 + reg_off);\n}\n\nstatic void exynos7_tmu_set_trip_hyst(struct exynos_tmu_data *data,\n\t\t\t\t      int trip, u8 temp, u8 hyst)\n{\n\tunsigned int reg_off, bit_off;\n\tu32 th;\n\n\treg_off = ((7 - trip) / 2) * 4;\n\tbit_off = ((8 - trip) % 2);\n\n\tth = readl(data->base + EXYNOS7_THD_TEMP_FALL7_6 + reg_off);\n\tth &= ~(EXYNOS7_TMU_TEMP_MASK << (16 * bit_off));\n\tth |= temp_to_code(data, temp - hyst) << (16 * bit_off);\n\twritel(th, data->base + EXYNOS7_THD_TEMP_FALL7_6 + reg_off);\n}\n\nstatic void exynos7_tmu_initialize(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tunsigned int trim_info;\n\n\ttrim_info = readl(data->base + EXYNOS_TMU_REG_TRIMINFO);\n\tsanitize_temp_error(data, trim_info);\n}\n\nstatic void exynos4210_tmu_control(struct platform_device *pdev, bool on)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tstruct thermal_zone_device *tz = data->tzd;\n\tstruct thermal_trip trip;\n\tunsigned int con, interrupt_en = 0, i;\n\n\tcon = get_con_reg(data, readl(data->base + EXYNOS_TMU_REG_CONTROL));\n\n\tif (on) {\n\t\tfor (i = 0; i < data->ntrip; i++) {\n\t\t\tif (thermal_zone_get_trip(tz, i, &trip))\n\t\t\t\tcontinue;\n\n\t\t\tinterrupt_en |=\n\t\t\t\t(1 << (EXYNOS_TMU_INTEN_RISE0_SHIFT + i * 4));\n\t\t}\n\n\t\tif (data->soc != SOC_ARCH_EXYNOS4210)\n\t\t\tinterrupt_en |=\n\t\t\t\tinterrupt_en << EXYNOS_TMU_INTEN_FALL0_SHIFT;\n\n\t\tcon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\n\t} else {\n\t\tcon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\n\t}\n\n\twritel(interrupt_en, data->base + EXYNOS_TMU_REG_INTEN);\n\twritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\n}\n\nstatic void exynos5433_tmu_control(struct platform_device *pdev, bool on)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tstruct thermal_zone_device *tz = data->tzd;\n\tstruct thermal_trip trip;\n\tunsigned int con, interrupt_en = 0, pd_det_en, i;\n\n\tcon = get_con_reg(data, readl(data->base + EXYNOS_TMU_REG_CONTROL));\n\n\tif (on) {\n\t\tfor (i = 0; i < data->ntrip; i++) {\n\t\t\tif (thermal_zone_get_trip(tz, i, &trip))\n\t\t\t\tcontinue;\n\n\t\t\tinterrupt_en |=\n\t\t\t\t(1 << (EXYNOS7_TMU_INTEN_RISE0_SHIFT + i));\n\t\t}\n\n\t\tinterrupt_en |=\n\t\t\tinterrupt_en << EXYNOS_TMU_INTEN_FALL0_SHIFT;\n\n\t\tcon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\n\t} else\n\t\tcon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\n\n\tpd_det_en = on ? EXYNOS5433_PD_DET_EN : 0;\n\n\twritel(pd_det_en, data->base + EXYNOS5433_TMU_PD_DET_EN);\n\twritel(interrupt_en, data->base + EXYNOS5433_TMU_REG_INTEN);\n\twritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\n}\n\nstatic void exynos7_tmu_control(struct platform_device *pdev, bool on)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tstruct thermal_zone_device *tz = data->tzd;\n\tstruct thermal_trip trip;\n\tunsigned int con, interrupt_en = 0, i;\n\n\tcon = get_con_reg(data, readl(data->base + EXYNOS_TMU_REG_CONTROL));\n\n\tif (on) {\n\t\tfor (i = 0; i < data->ntrip; i++) {\n\t\t\tif (thermal_zone_get_trip(tz, i, &trip))\n\t\t\t\tcontinue;\n\n\t\t\tinterrupt_en |=\n\t\t\t\t(1 << (EXYNOS7_TMU_INTEN_RISE0_SHIFT + i));\n\t\t}\n\n\t\tinterrupt_en |=\n\t\t\tinterrupt_en << EXYNOS_TMU_INTEN_FALL0_SHIFT;\n\n\t\tcon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\n\t\tcon |= (1 << EXYNOS7_PD_DET_EN_SHIFT);\n\t} else {\n\t\tcon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\n\t\tcon &= ~(1 << EXYNOS7_PD_DET_EN_SHIFT);\n\t}\n\n\twritel(interrupt_en, data->base + EXYNOS7_TMU_REG_INTEN);\n\twritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\n}\n\nstatic int exynos_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct exynos_tmu_data *data = thermal_zone_device_priv(tz);\n\tint value, ret = 0;\n\n\tif (!data || !data->tmu_read)\n\t\treturn -EINVAL;\n\telse if (!data->enabled)\n\t\t \n\t\treturn -EAGAIN;\n\n\tmutex_lock(&data->lock);\n\tclk_enable(data->clk);\n\n\tvalue = data->tmu_read(data);\n\tif (value < 0)\n\t\tret = value;\n\telse\n\t\t*temp = code_to_temp(data, value) * MCELSIUS;\n\n\tclk_disable(data->clk);\n\tmutex_unlock(&data->lock);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_THERMAL_EMULATION\nstatic u32 get_emul_con_reg(struct exynos_tmu_data *data, unsigned int val,\n\t\t\t    int temp)\n{\n\tif (temp) {\n\t\ttemp /= MCELSIUS;\n\n\t\tval &= ~(EXYNOS_EMUL_TIME_MASK << EXYNOS_EMUL_TIME_SHIFT);\n\t\tval |= (EXYNOS_EMUL_TIME << EXYNOS_EMUL_TIME_SHIFT);\n\t\tif (data->soc == SOC_ARCH_EXYNOS7) {\n\t\t\tval &= ~(EXYNOS7_EMUL_DATA_MASK <<\n\t\t\t\tEXYNOS7_EMUL_DATA_SHIFT);\n\t\t\tval |= (temp_to_code(data, temp) <<\n\t\t\t\tEXYNOS7_EMUL_DATA_SHIFT) |\n\t\t\t\tEXYNOS_EMUL_ENABLE;\n\t\t} else {\n\t\t\tval &= ~(EXYNOS_EMUL_DATA_MASK <<\n\t\t\t\tEXYNOS_EMUL_DATA_SHIFT);\n\t\t\tval |= (temp_to_code(data, temp) <<\n\t\t\t\tEXYNOS_EMUL_DATA_SHIFT) |\n\t\t\t\tEXYNOS_EMUL_ENABLE;\n\t\t}\n\t} else {\n\t\tval &= ~EXYNOS_EMUL_ENABLE;\n\t}\n\n\treturn val;\n}\n\nstatic void exynos4412_tmu_set_emulation(struct exynos_tmu_data *data,\n\t\t\t\t\t int temp)\n{\n\tunsigned int val;\n\tu32 emul_con;\n\n\tif (data->soc == SOC_ARCH_EXYNOS5260)\n\t\temul_con = EXYNOS5260_EMUL_CON;\n\telse if (data->soc == SOC_ARCH_EXYNOS5433)\n\t\temul_con = EXYNOS5433_TMU_EMUL_CON;\n\telse if (data->soc == SOC_ARCH_EXYNOS7)\n\t\temul_con = EXYNOS7_TMU_REG_EMUL_CON;\n\telse\n\t\temul_con = EXYNOS_EMUL_CON;\n\n\tval = readl(data->base + emul_con);\n\tval = get_emul_con_reg(data, val, temp);\n\twritel(val, data->base + emul_con);\n}\n\nstatic int exynos_tmu_set_emulation(struct thermal_zone_device *tz, int temp)\n{\n\tstruct exynos_tmu_data *data = thermal_zone_device_priv(tz);\n\tint ret = -EINVAL;\n\n\tif (data->soc == SOC_ARCH_EXYNOS4210)\n\t\tgoto out;\n\n\tif (temp && temp < MCELSIUS)\n\t\tgoto out;\n\n\tmutex_lock(&data->lock);\n\tclk_enable(data->clk);\n\tdata->tmu_set_emulation(data, temp);\n\tclk_disable(data->clk);\n\tmutex_unlock(&data->lock);\n\treturn 0;\nout:\n\treturn ret;\n}\n#else\n#define exynos4412_tmu_set_emulation NULL\nstatic int exynos_tmu_set_emulation(struct thermal_zone_device *tz, int temp)\n\t{ return -EINVAL; }\n#endif  \n\nstatic int exynos4210_tmu_read(struct exynos_tmu_data *data)\n{\n\tint ret = readb(data->base + EXYNOS_TMU_REG_CURRENT_TEMP);\n\n\t \n\treturn (ret < 75 || ret > 175) ? -ENODATA : ret;\n}\n\nstatic int exynos4412_tmu_read(struct exynos_tmu_data *data)\n{\n\treturn readb(data->base + EXYNOS_TMU_REG_CURRENT_TEMP);\n}\n\nstatic int exynos7_tmu_read(struct exynos_tmu_data *data)\n{\n\treturn readw(data->base + EXYNOS_TMU_REG_CURRENT_TEMP) &\n\t\tEXYNOS7_TMU_TEMP_MASK;\n}\n\nstatic void exynos_tmu_work(struct work_struct *work)\n{\n\tstruct exynos_tmu_data *data = container_of(work,\n\t\t\tstruct exynos_tmu_data, irq_work);\n\n\tthermal_zone_device_update(data->tzd, THERMAL_EVENT_UNSPECIFIED);\n\n\tmutex_lock(&data->lock);\n\tclk_enable(data->clk);\n\n\t \n\tdata->tmu_clear_irqs(data);\n\n\tclk_disable(data->clk);\n\tmutex_unlock(&data->lock);\n\tenable_irq(data->irq);\n}\n\nstatic void exynos4210_tmu_clear_irqs(struct exynos_tmu_data *data)\n{\n\tunsigned int val_irq;\n\tu32 tmu_intstat, tmu_intclear;\n\n\tif (data->soc == SOC_ARCH_EXYNOS5260) {\n\t\ttmu_intstat = EXYNOS5260_TMU_REG_INTSTAT;\n\t\ttmu_intclear = EXYNOS5260_TMU_REG_INTCLEAR;\n\t} else if (data->soc == SOC_ARCH_EXYNOS7) {\n\t\ttmu_intstat = EXYNOS7_TMU_REG_INTPEND;\n\t\ttmu_intclear = EXYNOS7_TMU_REG_INTPEND;\n\t} else if (data->soc == SOC_ARCH_EXYNOS5433) {\n\t\ttmu_intstat = EXYNOS5433_TMU_REG_INTPEND;\n\t\ttmu_intclear = EXYNOS5433_TMU_REG_INTPEND;\n\t} else {\n\t\ttmu_intstat = EXYNOS_TMU_REG_INTSTAT;\n\t\ttmu_intclear = EXYNOS_TMU_REG_INTCLEAR;\n\t}\n\n\tval_irq = readl(data->base + tmu_intstat);\n\t \n\twritel(val_irq, data->base + tmu_intclear);\n}\n\nstatic irqreturn_t exynos_tmu_irq(int irq, void *id)\n{\n\tstruct exynos_tmu_data *data = id;\n\n\tdisable_irq_nosync(irq);\n\tschedule_work(&data->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id exynos_tmu_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos3250-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS3250,\n\t}, {\n\t\t.compatible = \"samsung,exynos4210-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS4210,\n\t}, {\n\t\t.compatible = \"samsung,exynos4412-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS4412,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS5250,\n\t}, {\n\t\t.compatible = \"samsung,exynos5260-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS5260,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS5420,\n\t}, {\n\t\t.compatible = \"samsung,exynos5420-tmu-ext-triminfo\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS5420_TRIMINFO,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS5433,\n\t}, {\n\t\t.compatible = \"samsung,exynos7-tmu\",\n\t\t.data = (const void *)SOC_ARCH_EXYNOS7,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos_tmu_match);\n\nstatic int exynos_map_dt_data(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\tstruct resource res;\n\n\tif (!data || !pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tdata->id = of_alias_get_id(pdev->dev.of_node, \"tmuctrl\");\n\tif (data->id < 0)\n\t\tdata->id = 0;\n\n\tdata->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\n\tif (data->irq <= 0) {\n\t\tdev_err(&pdev->dev, \"failed to get IRQ\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_address_to_resource(pdev->dev.of_node, 0, &res)) {\n\t\tdev_err(&pdev->dev, \"failed to get Resource 0\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->base = devm_ioremap(&pdev->dev, res.start, resource_size(&res));\n\tif (!data->base) {\n\t\tdev_err(&pdev->dev, \"Failed to ioremap memory\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tdata->soc = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tswitch (data->soc) {\n\tcase SOC_ARCH_EXYNOS4210:\n\t\tdata->tmu_set_trip_temp = exynos4210_tmu_set_trip_temp;\n\t\tdata->tmu_set_trip_hyst = exynos4210_tmu_set_trip_hyst;\n\t\tdata->tmu_initialize = exynos4210_tmu_initialize;\n\t\tdata->tmu_control = exynos4210_tmu_control;\n\t\tdata->tmu_read = exynos4210_tmu_read;\n\t\tdata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\n\t\tdata->ntrip = 4;\n\t\tdata->gain = 15;\n\t\tdata->reference_voltage = 7;\n\t\tdata->efuse_value = 55;\n\t\tdata->min_efuse_value = 40;\n\t\tdata->max_efuse_value = 100;\n\t\tbreak;\n\tcase SOC_ARCH_EXYNOS3250:\n\tcase SOC_ARCH_EXYNOS4412:\n\tcase SOC_ARCH_EXYNOS5250:\n\tcase SOC_ARCH_EXYNOS5260:\n\tcase SOC_ARCH_EXYNOS5420:\n\tcase SOC_ARCH_EXYNOS5420_TRIMINFO:\n\t\tdata->tmu_set_trip_temp = exynos4412_tmu_set_trip_temp;\n\t\tdata->tmu_set_trip_hyst = exynos4412_tmu_set_trip_hyst;\n\t\tdata->tmu_initialize = exynos4412_tmu_initialize;\n\t\tdata->tmu_control = exynos4210_tmu_control;\n\t\tdata->tmu_read = exynos4412_tmu_read;\n\t\tdata->tmu_set_emulation = exynos4412_tmu_set_emulation;\n\t\tdata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\n\t\tdata->ntrip = 4;\n\t\tdata->gain = 8;\n\t\tdata->reference_voltage = 16;\n\t\tdata->efuse_value = 55;\n\t\tif (data->soc != SOC_ARCH_EXYNOS5420 &&\n\t\t    data->soc != SOC_ARCH_EXYNOS5420_TRIMINFO)\n\t\t\tdata->min_efuse_value = 40;\n\t\telse\n\t\t\tdata->min_efuse_value = 0;\n\t\tdata->max_efuse_value = 100;\n\t\tbreak;\n\tcase SOC_ARCH_EXYNOS5433:\n\t\tdata->tmu_set_trip_temp = exynos5433_tmu_set_trip_temp;\n\t\tdata->tmu_set_trip_hyst = exynos5433_tmu_set_trip_hyst;\n\t\tdata->tmu_initialize = exynos5433_tmu_initialize;\n\t\tdata->tmu_control = exynos5433_tmu_control;\n\t\tdata->tmu_read = exynos4412_tmu_read;\n\t\tdata->tmu_set_emulation = exynos4412_tmu_set_emulation;\n\t\tdata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\n\t\tdata->ntrip = 8;\n\t\tdata->gain = 8;\n\t\tif (res.start == EXYNOS5433_G3D_BASE)\n\t\t\tdata->reference_voltage = 23;\n\t\telse\n\t\t\tdata->reference_voltage = 16;\n\t\tdata->efuse_value = 75;\n\t\tdata->min_efuse_value = 40;\n\t\tdata->max_efuse_value = 150;\n\t\tbreak;\n\tcase SOC_ARCH_EXYNOS7:\n\t\tdata->tmu_set_trip_temp = exynos7_tmu_set_trip_temp;\n\t\tdata->tmu_set_trip_hyst = exynos7_tmu_set_trip_hyst;\n\t\tdata->tmu_initialize = exynos7_tmu_initialize;\n\t\tdata->tmu_control = exynos7_tmu_control;\n\t\tdata->tmu_read = exynos7_tmu_read;\n\t\tdata->tmu_set_emulation = exynos4412_tmu_set_emulation;\n\t\tdata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\n\t\tdata->ntrip = 8;\n\t\tdata->gain = 9;\n\t\tdata->reference_voltage = 17;\n\t\tdata->efuse_value = 75;\n\t\tdata->min_efuse_value = 15;\n\t\tdata->max_efuse_value = 100;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Platform not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->cal_type = TYPE_ONE_POINT_TRIMMING;\n\n\t \n\tif (data->soc != SOC_ARCH_EXYNOS5420_TRIMINFO)\n\t\treturn 0;\n\n\tif (of_address_to_resource(pdev->dev.of_node, 1, &res)) {\n\t\tdev_err(&pdev->dev, \"failed to get Resource 1\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata->base_second = devm_ioremap(&pdev->dev, res.start,\n\t\t\t\t\tresource_size(&res));\n\tif (!data->base_second) {\n\t\tdev_err(&pdev->dev, \"Failed to ioremap memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops exynos_sensor_ops = {\n\t.get_temp = exynos_get_temp,\n\t.set_emul_temp = exynos_tmu_set_emulation,\n};\n\nstatic int exynos_tmu_probe(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct exynos_tmu_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\tmutex_init(&data->lock);\n\n\t \n\tdata->regulator = devm_regulator_get_optional(&pdev->dev, \"vtmu\");\n\tif (!IS_ERR(data->regulator)) {\n\t\tret = regulator_enable(data->regulator);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to enable vtmu\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (PTR_ERR(data->regulator) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(&pdev->dev, \"Regulator node (vtmu) not found\\n\");\n\t}\n\n\tret = exynos_map_dt_data(pdev);\n\tif (ret)\n\t\tgoto err_sensor;\n\n\tINIT_WORK(&data->irq_work, exynos_tmu_work);\n\n\tdata->clk = devm_clk_get(&pdev->dev, \"tmu_apbif\");\n\tif (IS_ERR(data->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get clock\\n\");\n\t\tret = PTR_ERR(data->clk);\n\t\tgoto err_sensor;\n\t}\n\n\tdata->clk_sec = devm_clk_get(&pdev->dev, \"tmu_triminfo_apbif\");\n\tif (IS_ERR(data->clk_sec)) {\n\t\tif (data->soc == SOC_ARCH_EXYNOS5420_TRIMINFO) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get triminfo clock\\n\");\n\t\t\tret = PTR_ERR(data->clk_sec);\n\t\t\tgoto err_sensor;\n\t\t}\n\t} else {\n\t\tret = clk_prepare(data->clk_sec);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get clock\\n\");\n\t\t\tgoto err_sensor;\n\t\t}\n\t}\n\n\tret = clk_prepare(data->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to get clock\\n\");\n\t\tgoto err_clk_sec;\n\t}\n\n\tswitch (data->soc) {\n\tcase SOC_ARCH_EXYNOS5433:\n\tcase SOC_ARCH_EXYNOS7:\n\t\tdata->sclk = devm_clk_get(&pdev->dev, \"tmu_sclk\");\n\t\tif (IS_ERR(data->sclk)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get sclk\\n\");\n\t\t\tret = PTR_ERR(data->sclk);\n\t\t\tgoto err_clk;\n\t\t} else {\n\t\t\tret = clk_prepare_enable(data->sclk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"Failed to enable sclk\\n\");\n\t\t\t\tgoto err_clk;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tdata->tzd = devm_thermal_of_zone_register(&pdev->dev, 0, data,\n\t\t\t\t\t\t  &exynos_sensor_ops);\n\tif (IS_ERR(data->tzd)) {\n\t\tret = PTR_ERR(data->tzd);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Failed to register sensor: %d\\n\",\n\t\t\t\tret);\n\t\tgoto err_sclk;\n\t}\n\n\tret = exynos_tmu_initialize(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize TMU\\n\");\n\t\tgoto err_sclk;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, data->irq, exynos_tmu_irq,\n\t\tIRQF_TRIGGER_RISING | IRQF_SHARED, dev_name(&pdev->dev), data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq: %d\\n\", data->irq);\n\t\tgoto err_sclk;\n\t}\n\n\texynos_tmu_control(pdev, true);\n\treturn 0;\n\nerr_sclk:\n\tclk_disable_unprepare(data->sclk);\nerr_clk:\n\tclk_unprepare(data->clk);\nerr_clk_sec:\n\tif (!IS_ERR(data->clk_sec))\n\t\tclk_unprepare(data->clk_sec);\nerr_sensor:\n\tif (!IS_ERR(data->regulator))\n\t\tregulator_disable(data->regulator);\n\n\treturn ret;\n}\n\nstatic int exynos_tmu_remove(struct platform_device *pdev)\n{\n\tstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\n\n\texynos_tmu_control(pdev, false);\n\n\tclk_disable_unprepare(data->sclk);\n\tclk_unprepare(data->clk);\n\tif (!IS_ERR(data->clk_sec))\n\t\tclk_unprepare(data->clk_sec);\n\n\tif (!IS_ERR(data->regulator))\n\t\tregulator_disable(data->regulator);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int exynos_tmu_suspend(struct device *dev)\n{\n\texynos_tmu_control(to_platform_device(dev), false);\n\n\treturn 0;\n}\n\nstatic int exynos_tmu_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\texynos_tmu_initialize(pdev);\n\texynos_tmu_control(pdev, true);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(exynos_tmu_pm,\n\t\t\t exynos_tmu_suspend, exynos_tmu_resume);\n#define EXYNOS_TMU_PM\t(&exynos_tmu_pm)\n#else\n#define EXYNOS_TMU_PM\tNULL\n#endif\n\nstatic struct platform_driver exynos_tmu_driver = {\n\t.driver = {\n\t\t.name   = \"exynos-tmu\",\n\t\t.pm     = EXYNOS_TMU_PM,\n\t\t.of_match_table = exynos_tmu_match,\n\t},\n\t.probe = exynos_tmu_probe,\n\t.remove\t= exynos_tmu_remove,\n};\n\nmodule_platform_driver(exynos_tmu_driver);\n\nMODULE_DESCRIPTION(\"Exynos TMU Driver\");\nMODULE_AUTHOR(\"Donggeun Kim <dg77.kim@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:exynos-tmu\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}