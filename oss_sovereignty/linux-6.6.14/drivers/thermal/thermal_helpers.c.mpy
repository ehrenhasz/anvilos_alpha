{
  "module_name": "thermal_helpers.c",
  "hash_id": "c03c3dda890a9563794fbf44220a5720239117193570b88bb13e2a5f7c73fe50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/thermal_helpers.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n\n#include \"thermal_core.h\"\n#include \"thermal_trace.h\"\n\nint get_tz_trend(struct thermal_zone_device *tz, int trip_index)\n{\n\tstruct thermal_trip *trip = tz->trips ? &tz->trips[trip_index] : NULL;\n\tenum thermal_trend trend;\n\n\tif (tz->emul_temperature || !tz->ops->get_trend ||\n\t    tz->ops->get_trend(tz, trip, &trend)) {\n\t\tif (tz->temperature > tz->last_temperature)\n\t\t\ttrend = THERMAL_TREND_RAISING;\n\t\telse if (tz->temperature < tz->last_temperature)\n\t\t\ttrend = THERMAL_TREND_DROPPING;\n\t\telse\n\t\t\ttrend = THERMAL_TREND_STABLE;\n\t}\n\n\treturn trend;\n}\n\nstruct thermal_instance *\nget_thermal_instance(struct thermal_zone_device *tz,\n\t\t     struct thermal_cooling_device *cdev, int trip)\n{\n\tstruct thermal_instance *pos = NULL;\n\tstruct thermal_instance *target_instance = NULL;\n\n\tmutex_lock(&tz->lock);\n\tmutex_lock(&cdev->lock);\n\n\tlist_for_each_entry(pos, &tz->thermal_instances, tz_node) {\n\t\tif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\n\t\t\ttarget_instance = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&cdev->lock);\n\tmutex_unlock(&tz->lock);\n\n\treturn target_instance;\n}\nEXPORT_SYMBOL(get_thermal_instance);\n\n \nint __thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tint ret = -EINVAL;\n\tint count;\n\tint crit_temp = INT_MAX;\n\tstruct thermal_trip trip;\n\n\tlockdep_assert_held(&tz->lock);\n\n\tret = tz->ops->get_temp(tz, temp);\n\n\tif (IS_ENABLED(CONFIG_THERMAL_EMULATION) && tz->emul_temperature) {\n\t\tfor (count = 0; count < tz->num_trips; count++) {\n\t\t\tret = __thermal_zone_get_trip(tz, count, &trip);\n\t\t\tif (!ret && trip.type == THERMAL_TRIP_CRITICAL) {\n\t\t\t\tcrit_temp = trip.temperature;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!ret && *temp < crit_temp)\n\t\t\t*temp = tz->emul_temperature;\n\t}\n\n\tif (ret)\n\t\tdev_dbg(&tz->device, \"Failed to get temperature: %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nint thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(tz))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tif (!tz->ops->get_temp) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (device_is_registered(&tz->device))\n\t\tret = __thermal_zone_get_temp(tz, temp);\n\telse\n\t\tret = -ENODEV;\n\nunlock:\n\tmutex_unlock(&tz->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_get_temp);\n\nstatic void thermal_cdev_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       int target)\n{\n\tif (cdev->ops->set_cur_state(cdev, target))\n\t\treturn;\n\n\tthermal_notify_cdev_state_update(cdev->id, target);\n\tthermal_cooling_device_stats_update(cdev, target);\n}\n\nvoid __thermal_cdev_update(struct thermal_cooling_device *cdev)\n{\n\tstruct thermal_instance *instance;\n\tunsigned long target = 0;\n\n\t \n\tlist_for_each_entry(instance, &cdev->thermal_instances, cdev_node) {\n\t\tdev_dbg(&cdev->device, \"zone%d->target=%lu\\n\",\n\t\t\tinstance->tz->id, instance->target);\n\t\tif (instance->target == THERMAL_NO_TARGET)\n\t\t\tcontinue;\n\t\tif (instance->target > target)\n\t\t\ttarget = instance->target;\n\t}\n\n\tthermal_cdev_set_cur_state(cdev, target);\n\n\ttrace_cdev_update(cdev, target);\n\tdev_dbg(&cdev->device, \"set to state %lu\\n\", target);\n}\n\n \nvoid thermal_cdev_update(struct thermal_cooling_device *cdev)\n{\n\tmutex_lock(&cdev->lock);\n\tif (!cdev->updated) {\n\t\t__thermal_cdev_update(cdev);\n\t\tcdev->updated = true;\n\t}\n\tmutex_unlock(&cdev->lock);\n}\n\n \nint thermal_zone_get_slope(struct thermal_zone_device *tz)\n{\n\tif (tz && tz->tzp)\n\t\treturn tz->tzp->slope;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_get_slope);\n\n \nint thermal_zone_get_offset(struct thermal_zone_device *tz)\n{\n\tif (tz && tz->tzp)\n\t\treturn tz->tzp->offset;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_get_offset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}