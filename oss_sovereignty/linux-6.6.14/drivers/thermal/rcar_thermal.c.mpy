{
  "module_name": "rcar_thermal.c",
  "hash_id": "54b2b9de9c7239bd0ede9440085efc6e992e584e6ed4c4e871d408dbe94ee22a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/rcar_thermal.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n\n#define IDLE_INTERVAL\t5000\n\n#define COMMON_STR\t0x00\n#define COMMON_ENR\t0x04\n#define COMMON_INTMSK\t0x0c\n\n#define REG_POSNEG\t0x20\n#define REG_FILONOFF\t0x28\n#define REG_THSCR\t0x2c\n#define REG_THSSR\t0x30\n#define REG_INTCTRL\t0x34\n\n \n#define CPCTL\t(1 << 12)\n\n \n#define CTEMP\t0x3f\n\nstruct rcar_thermal_common {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct list_head head;\n\tspinlock_t lock;\n};\n\nstruct rcar_thermal_chip {\n\tunsigned int use_of_thermal : 1;\n\tunsigned int has_filonoff : 1;\n\tunsigned int irq_per_ch : 1;\n\tunsigned int needs_suspend_resume : 1;\n\tunsigned int nirqs;\n\tunsigned int ctemp_bands;\n};\n\nstatic const struct rcar_thermal_chip rcar_thermal = {\n\t.use_of_thermal = 0,\n\t.has_filonoff = 1,\n\t.irq_per_ch = 0,\n\t.needs_suspend_resume = 0,\n\t.nirqs = 1,\n\t.ctemp_bands = 1,\n};\n\nstatic const struct rcar_thermal_chip rcar_gen2_thermal = {\n\t.use_of_thermal = 1,\n\t.has_filonoff = 1,\n\t.irq_per_ch = 0,\n\t.needs_suspend_resume = 0,\n\t.nirqs = 1,\n\t.ctemp_bands = 1,\n};\n\nstatic const struct rcar_thermal_chip rcar_gen3_thermal = {\n\t.use_of_thermal = 1,\n\t.has_filonoff = 0,\n\t.irq_per_ch = 1,\n\t.needs_suspend_resume = 1,\n\t \n\t.nirqs = 2,\n\t.ctemp_bands = 2,\n};\n\nstruct rcar_thermal_priv {\n\tvoid __iomem *base;\n\tstruct rcar_thermal_common *common;\n\tstruct thermal_zone_device *zone;\n\tconst struct rcar_thermal_chip *chip;\n\tstruct delayed_work work;\n\tstruct mutex lock;\n\tstruct list_head list;\n\tint id;\n};\n\n#define rcar_thermal_for_each_priv(pos, common)\t\\\n\tlist_for_each_entry(pos, &common->head, list)\n\n#define MCELSIUS(temp)\t\t\t((temp) * 1000)\n#define rcar_priv_to_dev(priv)\t\t((priv)->common->dev)\n#define rcar_has_irq_support(priv)\t((priv)->common->base)\n#define rcar_id_to_shift(priv)\t\t((priv)->id * 8)\n\nstatic const struct of_device_id rcar_thermal_dt_ids[] = {\n\t{\n\t\t.compatible = \"renesas,rcar-thermal\",\n\t\t.data = &rcar_thermal,\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen2-thermal\",\n\t\t .data = &rcar_gen2_thermal,\n\t},\n\t{\n\t\t.compatible = \"renesas,thermal-r8a774c0\",\n\t\t.data = &rcar_gen3_thermal,\n\t},\n\t{\n\t\t.compatible = \"renesas,thermal-r8a77970\",\n\t\t.data = &rcar_gen3_thermal,\n\t},\n\t{\n\t\t.compatible = \"renesas,thermal-r8a77990\",\n\t\t.data = &rcar_gen3_thermal,\n\t},\n\t{\n\t\t.compatible = \"renesas,thermal-r8a77995\",\n\t\t.data = &rcar_gen3_thermal,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rcar_thermal_dt_ids);\n\n \n#define rcar_thermal_common_read(c, r) \\\n\t_rcar_thermal_common_read(c, COMMON_ ##r)\nstatic u32 _rcar_thermal_common_read(struct rcar_thermal_common *common,\n\t\t\t\t     u32 reg)\n{\n\treturn ioread32(common->base + reg);\n}\n\n#define rcar_thermal_common_write(c, r, d) \\\n\t_rcar_thermal_common_write(c, COMMON_ ##r, d)\nstatic void _rcar_thermal_common_write(struct rcar_thermal_common *common,\n\t\t\t\t       u32 reg, u32 data)\n{\n\tiowrite32(data, common->base + reg);\n}\n\n#define rcar_thermal_common_bset(c, r, m, d) \\\n\t_rcar_thermal_common_bset(c, COMMON_ ##r, m, d)\nstatic void _rcar_thermal_common_bset(struct rcar_thermal_common *common,\n\t\t\t\t      u32 reg, u32 mask, u32 data)\n{\n\tu32 val;\n\n\tval = ioread32(common->base + reg);\n\tval &= ~mask;\n\tval |= (data & mask);\n\tiowrite32(val, common->base + reg);\n}\n\n#define rcar_thermal_read(p, r) _rcar_thermal_read(p, REG_ ##r)\nstatic u32 _rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)\n{\n\treturn ioread32(priv->base + reg);\n}\n\n#define rcar_thermal_write(p, r, d) _rcar_thermal_write(p, REG_ ##r, d)\nstatic void _rcar_thermal_write(struct rcar_thermal_priv *priv,\n\t\t\t\tu32 reg, u32 data)\n{\n\tiowrite32(data, priv->base + reg);\n}\n\n#define rcar_thermal_bset(p, r, m, d) _rcar_thermal_bset(p, REG_ ##r, m, d)\nstatic void _rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,\n\t\t\t       u32 mask, u32 data)\n{\n\tu32 val;\n\n\tval = ioread32(priv->base + reg);\n\tval &= ~mask;\n\tval |= (data & mask);\n\tiowrite32(val, priv->base + reg);\n}\n\n \nstatic int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)\n{\n\tstruct device *dev = rcar_priv_to_dev(priv);\n\tint old, new, ctemp = -EINVAL;\n\tunsigned int i;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\trcar_thermal_bset(priv, THSCR, CPCTL, CPCTL);\n\n\told = ~0;\n\tfor (i = 0; i < 128; i++) {\n\t\t \n\t\tusleep_range(300, 400);\n\n\t\tnew = rcar_thermal_read(priv, THSSR) & CTEMP;\n\t\tif (new == old) {\n\t\t\tctemp = new;\n\t\t\tbreak;\n\t\t}\n\t\told = new;\n\t}\n\n\tif (ctemp < 0) {\n\t\tdev_err(dev, \"thermal sensor was broken\\n\");\n\t\tgoto err_out_unlock;\n\t}\n\n\t \n\tif (rcar_has_irq_support(priv)) {\n\t\tif (priv->chip->has_filonoff)\n\t\t\trcar_thermal_write(priv, FILONOFF, 0);\n\n\t\t \n\t\trcar_thermal_write(priv, POSNEG,  0x1);\n\t\trcar_thermal_write(priv, INTCTRL, (((ctemp - 0) << 8) |\n\t\t\t\t\t\t   ((ctemp - 1) << 0)));\n\t}\n\nerr_out_unlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ctemp;\n}\n\nstatic int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,\n\t\t\t\t\t int *temp)\n{\n\tint ctemp;\n\n\tctemp = rcar_thermal_update_temp(priv);\n\tif (ctemp < 0)\n\t\treturn ctemp;\n\n\t \n\n\tif (priv->chip->ctemp_bands == 1)\n\t\t*temp = MCELSIUS((ctemp * 5) - 65);\n\telse if (ctemp < 24)\n\t\t*temp = MCELSIUS(((ctemp * 55) - 720) / 10);\n\telse\n\t\t*temp = MCELSIUS((ctemp * 5) - 60);\n\n\treturn 0;\n}\n\nstatic int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)\n{\n\tstruct rcar_thermal_priv *priv = thermal_zone_device_priv(zone);\n\n\treturn rcar_thermal_get_current_temp(priv, temp);\n}\n\nstatic struct thermal_zone_device_ops rcar_thermal_zone_ops = {\n\t.get_temp\t= rcar_thermal_get_temp,\n};\n\nstatic struct thermal_trip trips[] = {\n\t{ .type = THERMAL_TRIP_CRITICAL, .temperature = 90000 }\n};\n\n \n#define rcar_thermal_irq_enable(p)\t_rcar_thermal_irq_ctrl(p, 1)\n#define rcar_thermal_irq_disable(p)\t_rcar_thermal_irq_ctrl(p, 0)\nstatic void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)\n{\n\tstruct rcar_thermal_common *common = priv->common;\n\tunsigned long flags;\n\tu32 mask = 0x3 << rcar_id_to_shift(priv);  \n\n\tif (!rcar_has_irq_support(priv))\n\t\treturn;\n\n\tspin_lock_irqsave(&common->lock, flags);\n\n\trcar_thermal_common_bset(common, INTMSK, mask, enable ? 0 : mask);\n\n\tspin_unlock_irqrestore(&common->lock, flags);\n}\n\nstatic void rcar_thermal_work(struct work_struct *work)\n{\n\tstruct rcar_thermal_priv *priv;\n\tint ret;\n\n\tpriv = container_of(work, struct rcar_thermal_priv, work.work);\n\n\tret = rcar_thermal_update_temp(priv);\n\tif (ret < 0)\n\t\treturn;\n\n\trcar_thermal_irq_enable(priv);\n\n\tthermal_zone_device_update(priv->zone, THERMAL_EVENT_UNSPECIFIED);\n}\n\nstatic u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)\n{\n\tstruct device *dev = rcar_priv_to_dev(priv);\n\n\tstatus = (status >> rcar_id_to_shift(priv)) & 0x3;\n\n\tif (status) {\n\t\tdev_dbg(dev, \"thermal%d %s%s\\n\",\n\t\t\tpriv->id,\n\t\t\t(status & 0x2) ? \"Rising \" : \"\",\n\t\t\t(status & 0x1) ? \"Falling\" : \"\");\n\t}\n\n\treturn status;\n}\n\nstatic irqreturn_t rcar_thermal_irq(int irq, void *data)\n{\n\tstruct rcar_thermal_common *common = data;\n\tstruct rcar_thermal_priv *priv;\n\tu32 status, mask;\n\n\tspin_lock(&common->lock);\n\n\tmask\t= rcar_thermal_common_read(common, INTMSK);\n\tstatus\t= rcar_thermal_common_read(common, STR);\n\trcar_thermal_common_write(common, STR, 0x000F0F0F & mask);\n\n\tspin_unlock(&common->lock);\n\n\tstatus = status & ~mask;\n\n\t \n\trcar_thermal_for_each_priv(priv, common) {\n\t\tif (rcar_thermal_had_changed(priv, status)) {\n\t\t\trcar_thermal_irq_disable(priv);\n\t\t\tqueue_delayed_work(system_freezable_wq, &priv->work,\n\t\t\t\t\t   msecs_to_jiffies(300));\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int rcar_thermal_remove(struct platform_device *pdev)\n{\n\tstruct rcar_thermal_common *common = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tstruct rcar_thermal_priv *priv;\n\n\trcar_thermal_for_each_priv(priv, common) {\n\t\trcar_thermal_irq_disable(priv);\n\t\tcancel_delayed_work_sync(&priv->work);\n\t\tif (priv->chip->use_of_thermal)\n\t\t\tthermal_remove_hwmon_sysfs(priv->zone);\n\t\telse\n\t\t\tthermal_zone_device_unregister(priv->zone);\n\t}\n\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int rcar_thermal_probe(struct platform_device *pdev)\n{\n\tstruct rcar_thermal_common *common;\n\tstruct rcar_thermal_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tconst struct rcar_thermal_chip *chip = of_device_get_match_data(dev);\n\tint mres = 0;\n\tint i;\n\tint ret = -ENODEV;\n\tint idle = IDLE_INTERVAL;\n\tu32 enr_bits = 0;\n\n\tcommon = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);\n\tif (!common)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, common);\n\n\tINIT_LIST_HEAD(&common->head);\n\tspin_lock_init(&common->lock);\n\tcommon->dev = dev;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tfor (i = 0; i < chip->nirqs; i++) {\n\t\tint irq;\n\n\t\tret = platform_get_irq_optional(pdev, i);\n\t\tif (ret < 0 && ret != -ENXIO)\n\t\t\tgoto error_unregister;\n\t\tif (ret > 0)\n\t\t\tirq = ret;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (!common->base) {\n\t\t\t \n\t\t\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t    mres++);\n\t\t\tcommon->base = devm_ioremap_resource(dev, res);\n\t\t\tif (IS_ERR(common->base)) {\n\t\t\t\tret = PTR_ERR(common->base);\n\t\t\t\tgoto error_unregister;\n\t\t\t}\n\n\t\t\tidle = 0;  \n\t\t}\n\n\t\tret = devm_request_irq(dev, irq, rcar_thermal_irq,\n\t\t\t\t       IRQF_SHARED, dev_name(dev), common);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"irq request failed\\n \");\n\t\t\tgoto error_unregister;\n\t\t}\n\n\t\t \n\t\tif (chip->irq_per_ch)\n\t\t\tenr_bits |= 1 << i;\n\t}\n\n\tfor (i = 0;; i++) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, mres++);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\t\tif (!priv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_unregister;\n\t\t}\n\n\t\tpriv->base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(priv->base)) {\n\t\t\tret = PTR_ERR(priv->base);\n\t\t\tgoto error_unregister;\n\t\t}\n\n\t\tpriv->common = common;\n\t\tpriv->id = i;\n\t\tpriv->chip = chip;\n\t\tmutex_init(&priv->lock);\n\t\tINIT_LIST_HEAD(&priv->list);\n\t\tINIT_DELAYED_WORK(&priv->work, rcar_thermal_work);\n\t\tret = rcar_thermal_update_temp(priv);\n\t\tif (ret < 0)\n\t\t\tgoto error_unregister;\n\n\t\tif (chip->use_of_thermal) {\n\t\t\tpriv->zone = devm_thermal_of_zone_register(\n\t\t\t\t\t\tdev, i, priv,\n\t\t\t\t\t\t&rcar_thermal_zone_ops);\n\t\t} else {\n\t\t\tpriv->zone = thermal_zone_device_register_with_trips(\n\t\t\t\t\"rcar_thermal\", trips, ARRAY_SIZE(trips), 0, priv,\n\t\t\t\t\t\t&rcar_thermal_zone_ops, NULL, 0,\n\t\t\t\t\t\tidle);\n\n\t\t\tret = thermal_zone_device_enable(priv->zone);\n\t\t\tif (ret) {\n\t\t\t\tthermal_zone_device_unregister(priv->zone);\n\t\t\t\tpriv->zone = ERR_PTR(ret);\n\t\t\t}\n\t\t}\n\t\tif (IS_ERR(priv->zone)) {\n\t\t\tdev_err(dev, \"can't register thermal zone\\n\");\n\t\t\tret = PTR_ERR(priv->zone);\n\t\t\tpriv->zone = NULL;\n\t\t\tgoto error_unregister;\n\t\t}\n\n\t\tif (chip->use_of_thermal) {\n\t\t\tret = thermal_add_hwmon_sysfs(priv->zone);\n\t\t\tif (ret)\n\t\t\t\tgoto error_unregister;\n\t\t}\n\n\t\trcar_thermal_irq_enable(priv);\n\n\t\tlist_move_tail(&priv->list, &common->head);\n\n\t\t \n\t\tif (!chip->irq_per_ch)\n\t\t\tenr_bits |= 3 << (i * 8);\n\t}\n\n\tif (common->base && enr_bits)\n\t\trcar_thermal_common_write(common, ENR, enr_bits);\n\n\tdev_info(dev, \"%d sensor probed\\n\", i);\n\n\treturn 0;\n\nerror_unregister:\n\trcar_thermal_remove(pdev);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rcar_thermal_suspend(struct device *dev)\n{\n\tstruct rcar_thermal_common *common = dev_get_drvdata(dev);\n\tstruct rcar_thermal_priv *priv = list_first_entry(&common->head,\n\t\t\t\t\t\t\t  typeof(*priv), list);\n\n\tif (priv->chip->needs_suspend_resume) {\n\t\trcar_thermal_common_write(common, ENR, 0);\n\t\trcar_thermal_irq_disable(priv);\n\t\trcar_thermal_bset(priv, THSCR, CPCTL, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int rcar_thermal_resume(struct device *dev)\n{\n\tstruct rcar_thermal_common *common = dev_get_drvdata(dev);\n\tstruct rcar_thermal_priv *priv = list_first_entry(&common->head,\n\t\t\t\t\t\t\t  typeof(*priv), list);\n\tint ret;\n\n\tif (priv->chip->needs_suspend_resume) {\n\t\tret = rcar_thermal_update_temp(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\trcar_thermal_irq_enable(priv);\n\t\trcar_thermal_common_write(common, ENR, 0x03);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(rcar_thermal_pm_ops, rcar_thermal_suspend,\n\t\t\t rcar_thermal_resume);\n\nstatic struct platform_driver rcar_thermal_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rcar_thermal\",\n\t\t.pm = &rcar_thermal_pm_ops,\n\t\t.of_match_table = rcar_thermal_dt_ids,\n\t},\n\t.probe\t\t= rcar_thermal_probe,\n\t.remove\t\t= rcar_thermal_remove,\n};\nmodule_platform_driver(rcar_thermal_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"R-Car THS/TSC thermal sensor driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}