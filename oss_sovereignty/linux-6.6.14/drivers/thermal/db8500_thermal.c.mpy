{
  "module_name": "db8500_thermal.c",
  "hash_id": "03b637e714a869e2153c5f2b7d69fb29f5ef8e01c79dd3ca2812ebd996159760",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/db8500_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/cpu_cooling.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/dbx500-prcmu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#define PRCMU_DEFAULT_MEASURE_TIME\t0xFFF\n#define PRCMU_DEFAULT_LOW_TEMP\t\t0\n\n \nstatic const unsigned long db8500_thermal_points[] = {\n\t15000,\n\t20000,\n\t25000,\n\t30000,\n\t35000,\n\t40000,\n\t45000,\n\t50000,\n\t55000,\n\t60000,\n\t65000,\n\t70000,\n\t75000,\n\t80000,\n\t \n\t85000,\n\t90000,\n\t95000,\n\t100000,\n};\n\nstruct db8500_thermal_zone {\n\tstruct thermal_zone_device *tz;\n\tstruct device *dev;\n\tunsigned long interpolated_temp;\n\tunsigned int cur_index;\n};\n\n \nstatic int db8500_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct db8500_thermal_zone *th = thermal_zone_device_priv(tz);\n\n\t \n\t*temp = th->interpolated_temp;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops thdev_ops = {\n\t.get_temp = db8500_thermal_get_temp,\n};\n\nstatic void db8500_thermal_update_config(struct db8500_thermal_zone *th,\n\t\t\t\t\t unsigned int idx,\n\t\t\t\t\t unsigned long next_low,\n\t\t\t\t\t unsigned long next_high)\n{\n\tprcmu_stop_temp_sense();\n\n\tth->cur_index = idx;\n\tth->interpolated_temp = (next_low + next_high)/2;\n\n\t \n\tprcmu_config_hotmon((u8)(next_low/1000), (u8)(next_high/1000));\n\tprcmu_start_temp_sense(PRCMU_DEFAULT_MEASURE_TIME);\n}\n\nstatic irqreturn_t prcmu_low_irq_handler(int irq, void *irq_data)\n{\n\tstruct db8500_thermal_zone *th = irq_data;\n\tunsigned int idx = th->cur_index;\n\tunsigned long next_low, next_high;\n\n\tif (idx == 0)\n\t\t \n\t\treturn IRQ_HANDLED;\n\n\tif (idx == 1) {\n\t\tnext_high = db8500_thermal_points[0];\n\t\tnext_low = PRCMU_DEFAULT_LOW_TEMP;\n\t} else {\n\t\tnext_high = db8500_thermal_points[idx - 1];\n\t\tnext_low = db8500_thermal_points[idx - 2];\n\t}\n\tidx -= 1;\n\n\tdb8500_thermal_update_config(th, idx, next_low, next_high);\n\tdev_dbg(th->dev,\n\t\t\"PRCMU set max %ld, min %ld\\n\", next_high, next_low);\n\n\tthermal_zone_device_update(th->tz, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t prcmu_high_irq_handler(int irq, void *irq_data)\n{\n\tstruct db8500_thermal_zone *th = irq_data;\n\tunsigned int idx = th->cur_index;\n\tunsigned long next_low, next_high;\n\tint num_points = ARRAY_SIZE(db8500_thermal_points);\n\n\tif (idx < num_points - 1) {\n\t\tnext_high = db8500_thermal_points[idx+1];\n\t\tnext_low = db8500_thermal_points[idx];\n\t\tidx += 1;\n\n\t\tdb8500_thermal_update_config(th, idx, next_low, next_high);\n\n\t\tdev_dbg(th->dev,\n\t\t\t\"PRCMU set max %ld, min %ld\\n\", next_high, next_low);\n\t} else if (idx == num_points - 1)\n\t\t \n\t\tth->interpolated_temp = db8500_thermal_points[idx] + 1;\n\n\tthermal_zone_device_update(th->tz, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int db8500_thermal_probe(struct platform_device *pdev)\n{\n\tstruct db8500_thermal_zone *th = NULL;\n\tstruct device *dev = &pdev->dev;\n\tint low_irq, high_irq, ret = 0;\n\n\tth = devm_kzalloc(dev, sizeof(*th), GFP_KERNEL);\n\tif (!th)\n\t\treturn -ENOMEM;\n\n\tth->dev = dev;\n\n\tlow_irq = platform_get_irq_byname(pdev, \"IRQ_HOTMON_LOW\");\n\tif (low_irq < 0)\n\t\treturn low_irq;\n\n\tret = devm_request_threaded_irq(dev, low_irq, NULL,\n\t\tprcmu_low_irq_handler, IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\"dbx500_temp_low\", th);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to allocate temp low irq\\n\");\n\t\treturn ret;\n\t}\n\n\thigh_irq = platform_get_irq_byname(pdev, \"IRQ_HOTMON_HIGH\");\n\tif (high_irq < 0)\n\t\treturn high_irq;\n\n\tret = devm_request_threaded_irq(dev, high_irq, NULL,\n\t\tprcmu_high_irq_handler, IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\"dbx500_temp_high\", th);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to allocate temp high irq\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tth->tz = devm_thermal_of_zone_register(dev, 0, th, &thdev_ops);\n\tif (IS_ERR(th->tz)) {\n\t\tdev_err(dev, \"register thermal zone sensor failed\\n\");\n\t\treturn PTR_ERR(th->tz);\n\t}\n\tdev_info(dev, \"thermal zone sensor registered\\n\");\n\n\t \n\tdb8500_thermal_update_config(th, 0, PRCMU_DEFAULT_LOW_TEMP,\n\t\t\t\t     db8500_thermal_points[0]);\n\n\tplatform_set_drvdata(pdev, th);\n\n\treturn 0;\n}\n\nstatic int db8500_thermal_suspend(struct platform_device *pdev,\n\t\tpm_message_t state)\n{\n\tprcmu_stop_temp_sense();\n\n\treturn 0;\n}\n\nstatic int db8500_thermal_resume(struct platform_device *pdev)\n{\n\tstruct db8500_thermal_zone *th = platform_get_drvdata(pdev);\n\n\t \n\tdb8500_thermal_update_config(th, 0, PRCMU_DEFAULT_LOW_TEMP,\n\t\t\t\t     db8500_thermal_points[0]);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id db8500_thermal_match[] = {\n\t{ .compatible = \"stericsson,db8500-thermal\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, db8500_thermal_match);\n\nstatic struct platform_driver db8500_thermal_driver = {\n\t.driver = {\n\t\t.name = \"db8500-thermal\",\n\t\t.of_match_table = db8500_thermal_match,\n\t},\n\t.probe = db8500_thermal_probe,\n\t.suspend = db8500_thermal_suspend,\n\t.resume = db8500_thermal_resume,\n};\n\nmodule_platform_driver(db8500_thermal_driver);\n\nMODULE_AUTHOR(\"Hongbo Zhang <hongbo.zhang@stericsson.com>\");\nMODULE_DESCRIPTION(\"DB8500 thermal driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}