{
  "module_name": "imx8mm_thermal.c",
  "hash_id": "504d09184fd87e4eeed66c1e95198b319e96a8255e44ddb2f94aca65f821b8d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/imx8mm_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n\n#define TER\t\t\t0x0\t \n#define TPS\t\t\t0x4\n#define TRITSR\t\t\t0x20\t \n \n#define TASR\t\t\t0x28\n#define TASR_BUF_SLOPE_MASK\tGENMASK(19, 16)\n#define TASR_BUF_VREF_MASK\tGENMASK(4, 0)\t \n#define TASR_BUF_VERF_SEL_MASK\tGENMASK(1, 0)\t \n#define TCALIV(n)\t\t(0x30 + ((n) * 4))\n#define TCALIV_EN\t\tBIT(31)\n#define TCALIV_HR_MASK\t\tGENMASK(23, 16)\t \n#define TCALIV_RT_MASK\t\tGENMASK(7, 0)\t \n#define TCALIV_SNSR105C_MASK\tGENMASK(27, 16)\t \n#define TCALIV_SNSR25C_MASK\tGENMASK(11, 0)\t \n#define TRIM\t\t\t0x3c\n#define TRIM_BJT_CUR_MASK\tGENMASK(23, 20)\n#define TRIM_BGR_MASK\t\tGENMASK(31, 28)\n#define TRIM_VLSB_MASK\t\tGENMASK(15, 12)\n#define TRIM_EN_CH\t\tBIT(7)\n\n#define TER_ADC_PD\t\tBIT(30)\n#define TER_EN\t\t\tBIT(31)\n#define TRITSR_TEMP0_VAL_MASK\tGENMASK(7, 0)\n#define TRITSR_TEMP1_VAL_MASK\tGENMASK(23, 16)\n\n#define PROBE_SEL_ALL\t\tGENMASK(31, 30)\n\n#define probe_status_offset(x)\t(30 + x)\n#define SIGN_BIT\t\tBIT(7)\n#define TEMP_VAL_MASK\t\tGENMASK(6, 0)\n\n \n#define ANA0_EN\t\t\tBIT(25)\n#define ANA0_BUF_VREF_MASK\tGENMASK(24, 20)\n#define ANA0_BUF_SLOPE_MASK\tGENMASK(19, 16)\n#define ANA0_HR_MASK\t\tGENMASK(15, 8)\n#define ANA0_RT_MASK\t\tGENMASK(7, 0)\n#define TRIM2_VLSB_MASK\t\tGENMASK(23, 20)\n#define TRIM2_BGR_MASK\t\tGENMASK(19, 16)\n#define TRIM2_BJT_CUR_MASK\tGENMASK(15, 12)\n#define TRIM2_BUF_SLOP_SEL_MASK\tGENMASK(11, 8)\n#define TRIM2_BUF_VERF_SEL_MASK\tGENMASK(7, 6)\n#define TRIM3_TCA25_0_LSB_MASK\tGENMASK(31, 28)\n#define TRIM3_TCA40_0_MASK\tGENMASK(27, 16)\n#define TRIM4_TCA40_1_MASK\tGENMASK(31, 20)\n#define TRIM4_TCA105_0_MASK\tGENMASK(19, 8)\n#define TRIM4_TCA25_0_MSB_MASK\tGENMASK(7, 0)\n#define TRIM5_TCA105_1_MASK\tGENMASK(23, 12)\n#define TRIM5_TCA25_1_MASK\tGENMASK(11, 0)\n\n#define VER1_TEMP_LOW_LIMIT\t10000\n#define VER2_TEMP_LOW_LIMIT\t-40000\n#define VER2_TEMP_HIGH_LIMIT\t125000\n\n#define TMU_VER1\t\t0x1\n#define TMU_VER2\t\t0x2\n\nstruct thermal_soc_data {\n\tu32 num_sensors;\n\tu32 version;\n\tint (*get_temp)(void *, int *);\n};\n\nstruct tmu_sensor {\n\tstruct imx8mm_tmu *priv;\n\tu32 hw_id;\n\tstruct thermal_zone_device *tzd;\n};\n\nstruct imx8mm_tmu {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tconst struct thermal_soc_data *socdata;\n\tstruct tmu_sensor sensors[];\n};\n\nstatic int imx8mm_tmu_get_temp(void *data, int *temp)\n{\n\tstruct tmu_sensor *sensor = data;\n\tstruct imx8mm_tmu *tmu = sensor->priv;\n\tu32 val;\n\n\tval = readl_relaxed(tmu->base + TRITSR) & TRITSR_TEMP0_VAL_MASK;\n\n\t \n\n\t*temp = val * 1000;\n\tif (*temp < VER1_TEMP_LOW_LIMIT || *temp > VER2_TEMP_HIGH_LIMIT)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int imx8mp_tmu_get_temp(void *data, int *temp)\n{\n\tstruct tmu_sensor *sensor = data;\n\tstruct imx8mm_tmu *tmu = sensor->priv;\n\tunsigned long val;\n\tbool ready;\n\n\tval = readl_relaxed(tmu->base + TRITSR);\n\tready = test_bit(probe_status_offset(sensor->hw_id), &val);\n\tif (!ready)\n\t\treturn -EAGAIN;\n\n\tval = sensor->hw_id ? FIELD_GET(TRITSR_TEMP1_VAL_MASK, val) :\n\t      FIELD_GET(TRITSR_TEMP0_VAL_MASK, val);\n\tif (val & SIGN_BIT)  \n\t\tval = (~(val & TEMP_VAL_MASK) + 1);\n\n\t*temp = val * 1000;\n\tif (*temp < VER2_TEMP_LOW_LIMIT || *temp > VER2_TEMP_HIGH_LIMIT)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int tmu_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct tmu_sensor *sensor = thermal_zone_device_priv(tz);\n\tstruct imx8mm_tmu *tmu = sensor->priv;\n\n\treturn tmu->socdata->get_temp(sensor, temp);\n}\n\nstatic const struct thermal_zone_device_ops tmu_tz_ops = {\n\t.get_temp = tmu_get_temp,\n};\n\nstatic void imx8mm_tmu_enable(struct imx8mm_tmu *tmu, bool enable)\n{\n\tu32 val;\n\n\tval = readl_relaxed(tmu->base + TER);\n\tval = enable ? (val | TER_EN) : (val & ~TER_EN);\n\tif (tmu->socdata->version == TMU_VER2)\n\t\tval = enable ? (val & ~TER_ADC_PD) : (val | TER_ADC_PD);\n\twritel_relaxed(val, tmu->base + TER);\n}\n\nstatic void imx8mm_tmu_probe_sel_all(struct imx8mm_tmu *tmu)\n{\n\tu32 val;\n\n\tval = readl_relaxed(tmu->base + TPS);\n\tval |= PROBE_SEL_ALL;\n\twritel_relaxed(val, tmu->base + TPS);\n}\n\nstatic int imx8mm_tmu_probe_set_calib_v1(struct platform_device *pdev,\n\t\t\t\t\t struct imx8mm_tmu *tmu)\n{\n\tstruct device *dev = &pdev->dev;\n\tu32 ana0;\n\tint ret;\n\n\tret = nvmem_cell_read_u32(&pdev->dev, \"calib\", &ana0);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read OCOTP nvmem cell\\n\");\n\n\twritel(FIELD_PREP(TASR_BUF_VREF_MASK,\n\t\t\t  FIELD_GET(ANA0_BUF_VREF_MASK, ana0)) |\n\t       FIELD_PREP(TASR_BUF_SLOPE_MASK,\n\t\t\t  FIELD_GET(ANA0_BUF_SLOPE_MASK, ana0)),\n\t       tmu->base + TASR);\n\n\twritel(FIELD_PREP(TCALIV_RT_MASK, FIELD_GET(ANA0_RT_MASK, ana0)) |\n\t       FIELD_PREP(TCALIV_HR_MASK, FIELD_GET(ANA0_HR_MASK, ana0)) |\n\t       ((ana0 & ANA0_EN) ? TCALIV_EN : 0),\n\t       tmu->base + TCALIV(0));\n\n\treturn 0;\n}\n\nstatic int imx8mm_tmu_probe_set_calib_v2(struct platform_device *pdev,\n\t\t\t\t\t struct imx8mm_tmu *tmu)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nvmem_cell *cell;\n\tu32 trim[4] = { 0 };\n\tsize_t len;\n\tvoid *buf;\n\n\tcell = nvmem_cell_get(dev, \"calib\");\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tbuf = nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmemcpy(trim, buf, min(len, sizeof(trim)));\n\tkfree(buf);\n\n\tif (len != 16) {\n\t\tdev_err(dev,\n\t\t\t\"OCOTP nvmem cell length is %zu, must be 16.\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!trim[0] && !trim[1] && !trim[2] && !trim[3]) {\n\t\t \n\t\twritel(FIELD_PREP(TCALIV_SNSR25C_MASK, 0x63c),\n\t\t       tmu->base + TCALIV(0));\n\t\twritel(FIELD_PREP(TCALIV_SNSR25C_MASK, 0x63c),\n\t\t       tmu->base + TCALIV(1));\n\t\treturn 0;\n\t}\n\n\twritel(FIELD_PREP(TASR_BUF_VERF_SEL_MASK,\n\t\t\t  FIELD_GET(TRIM2_BUF_VERF_SEL_MASK, trim[0])) |\n\t       FIELD_PREP(TASR_BUF_SLOPE_MASK,\n\t\t\t  FIELD_GET(TRIM2_BUF_SLOP_SEL_MASK, trim[0])),\n\t       tmu->base + TASR);\n\n\twritel(FIELD_PREP(TRIM_BJT_CUR_MASK,\n\t\t\t  FIELD_GET(TRIM2_BJT_CUR_MASK, trim[0])) |\n\t       FIELD_PREP(TRIM_BGR_MASK, FIELD_GET(TRIM2_BGR_MASK, trim[0])) |\n\t       FIELD_PREP(TRIM_VLSB_MASK, FIELD_GET(TRIM2_VLSB_MASK, trim[0])) |\n\t       TRIM_EN_CH,\n\t       tmu->base + TRIM);\n\n\twritel(FIELD_PREP(TCALIV_SNSR25C_MASK,\n\t\t\t  FIELD_GET(TRIM3_TCA25_0_LSB_MASK, trim[1]) |\n\t\t\t  (FIELD_GET(TRIM4_TCA25_0_MSB_MASK, trim[2]) << 4)) |\n\t       FIELD_PREP(TCALIV_SNSR105C_MASK,\n\t\t\t  FIELD_GET(TRIM4_TCA105_0_MASK, trim[2])),\n\t       tmu->base + TCALIV(0));\n\n\twritel(FIELD_PREP(TCALIV_SNSR25C_MASK,\n\t\t\t  FIELD_GET(TRIM5_TCA25_1_MASK, trim[3])) |\n\t       FIELD_PREP(TCALIV_SNSR105C_MASK,\n\t\t\t  FIELD_GET(TRIM5_TCA105_1_MASK, trim[3])),\n\t       tmu->base + TCALIV(1));\n\n\twritel(FIELD_PREP(TCALIV_SNSR25C_MASK,\n\t\t\t  FIELD_GET(TRIM3_TCA40_0_MASK, trim[1])) |\n\t       FIELD_PREP(TCALIV_SNSR105C_MASK,\n\t\t\t  FIELD_GET(TRIM4_TCA40_1_MASK, trim[2])),\n\t       tmu->base + TCALIV(2));\n\n\treturn 0;\n}\n\nstatic int imx8mm_tmu_probe_set_calib(struct platform_device *pdev,\n\t\t\t\t      struct imx8mm_tmu *tmu)\n{\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tif (!of_property_present(pdev->dev.of_node, \"nvmem-cells\")) {\n\t\tdev_warn(dev,\n\t\t\t \"No OCOTP nvmem reference found, SoC-specific calibration not loaded. Please update your DT.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (tmu->socdata->version == TMU_VER1)\n\t\treturn imx8mm_tmu_probe_set_calib_v1(pdev, tmu);\n\n\treturn imx8mm_tmu_probe_set_calib_v2(pdev, tmu);\n}\n\nstatic int imx8mm_tmu_probe(struct platform_device *pdev)\n{\n\tconst struct thermal_soc_data *data;\n\tstruct imx8mm_tmu *tmu;\n\tint ret;\n\tint i;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\n\ttmu = devm_kzalloc(&pdev->dev, struct_size(tmu, sensors,\n\t\t\t   data->num_sensors), GFP_KERNEL);\n\tif (!tmu)\n\t\treturn -ENOMEM;\n\n\ttmu->socdata = data;\n\n\ttmu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tmu->base))\n\t\treturn PTR_ERR(tmu->base);\n\n\ttmu->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(tmu->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tmu->clk),\n\t\t\t\t     \"failed to get tmu clock\\n\");\n\n\tret = clk_prepare_enable(tmu->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable tmu clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\timx8mm_tmu_enable(tmu, false);\n\n\tfor (i = 0; i < data->num_sensors; i++) {\n\t\ttmu->sensors[i].priv = tmu;\n\t\ttmu->sensors[i].tzd =\n\t\t\tdevm_thermal_of_zone_register(&pdev->dev, i,\n\t\t\t\t\t\t      &tmu->sensors[i],\n\t\t\t\t\t\t      &tmu_tz_ops);\n\t\tif (IS_ERR(tmu->sensors[i].tzd)) {\n\t\t\tret = PTR_ERR(tmu->sensors[i].tzd);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to register thermal zone sensor[%d]: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto disable_clk;\n\t\t}\n\t\ttmu->sensors[i].hw_id = i;\n\n\t\tdevm_thermal_add_hwmon_sysfs(&pdev->dev, tmu->sensors[i].tzd);\n\t}\n\n\tplatform_set_drvdata(pdev, tmu);\n\n\tret = imx8mm_tmu_probe_set_calib(pdev, tmu);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\t \n\tif (tmu->socdata->version == TMU_VER2)\n\t\timx8mm_tmu_probe_sel_all(tmu);\n\n\t \n\timx8mm_tmu_enable(tmu, true);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(tmu->clk);\n\treturn ret;\n}\n\nstatic int imx8mm_tmu_remove(struct platform_device *pdev)\n{\n\tstruct imx8mm_tmu *tmu = platform_get_drvdata(pdev);\n\n\t \n\timx8mm_tmu_enable(tmu, false);\n\n\tclk_disable_unprepare(tmu->clk);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic struct thermal_soc_data imx8mm_tmu_data = {\n\t.num_sensors = 1,\n\t.version = TMU_VER1,\n\t.get_temp = imx8mm_tmu_get_temp,\n};\n\nstatic struct thermal_soc_data imx8mp_tmu_data = {\n\t.num_sensors = 2,\n\t.version = TMU_VER2,\n\t.get_temp = imx8mp_tmu_get_temp,\n};\n\nstatic const struct of_device_id imx8mm_tmu_table[] = {\n\t{ .compatible = \"fsl,imx8mm-tmu\", .data = &imx8mm_tmu_data, },\n\t{ .compatible = \"fsl,imx8mp-tmu\", .data = &imx8mp_tmu_data, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx8mm_tmu_table);\n\nstatic struct platform_driver imx8mm_tmu = {\n\t.driver = {\n\t\t.name\t= \"i.mx8mm_thermal\",\n\t\t.of_match_table = imx8mm_tmu_table,\n\t},\n\t.probe = imx8mm_tmu_probe,\n\t.remove = imx8mm_tmu_remove,\n};\nmodule_platform_driver(imx8mm_tmu);\n\nMODULE_AUTHOR(\"Anson Huang <Anson.Huang@nxp.com>\");\nMODULE_DESCRIPTION(\"i.MX8MM Thermal Monitor Unit driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}