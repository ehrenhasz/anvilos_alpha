{
  "module_name": "devfreq_cooling.c",
  "hash_id": "1f5625c6dae98b92535b45cd346efa9aecc113eddc6f68648a9d810deefbe372",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/devfreq_cooling.c",
  "human_readable_source": "\n \n\n#include <linux/devfreq.h>\n#include <linux/devfreq_cooling.h>\n#include <linux/energy_model.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_qos.h>\n#include <linux/thermal.h>\n#include <linux/units.h>\n\n#include \"thermal_trace.h\"\n\n#define SCALE_ERROR_MITIGATION\t100\n\n \nstruct devfreq_cooling_device {\n\tstruct thermal_cooling_device *cdev;\n\tstruct thermal_cooling_device_ops cooling_ops;\n\tstruct devfreq *devfreq;\n\tunsigned long cooling_state;\n\tu32 *freq_table;\n\tsize_t max_state;\n\tstruct devfreq_cooling_power *power_ops;\n\tu32 res_util;\n\tint capped_state;\n\tstruct dev_pm_qos_request req_max_freq;\n\tstruct em_perf_domain *em_pd;\n};\n\nstatic int devfreq_cooling_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t\t unsigned long *state)\n{\n\tstruct devfreq_cooling_device *dfc = cdev->devdata;\n\n\t*state = dfc->max_state;\n\n\treturn 0;\n}\n\nstatic int devfreq_cooling_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t\t unsigned long *state)\n{\n\tstruct devfreq_cooling_device *dfc = cdev->devdata;\n\n\t*state = dfc->cooling_state;\n\n\treturn 0;\n}\n\nstatic int devfreq_cooling_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t\t unsigned long state)\n{\n\tstruct devfreq_cooling_device *dfc = cdev->devdata;\n\tstruct devfreq *df = dfc->devfreq;\n\tstruct device *dev = df->dev.parent;\n\tunsigned long freq;\n\tint perf_idx;\n\n\tif (state == dfc->cooling_state)\n\t\treturn 0;\n\n\tdev_dbg(dev, \"Setting cooling state %lu\\n\", state);\n\n\tif (state > dfc->max_state)\n\t\treturn -EINVAL;\n\n\tif (dfc->em_pd) {\n\t\tperf_idx = dfc->max_state - state;\n\t\tfreq = dfc->em_pd->table[perf_idx].frequency * 1000;\n\t} else {\n\t\tfreq = dfc->freq_table[state];\n\t}\n\n\tdev_pm_qos_update_request(&dfc->req_max_freq,\n\t\t\t\t  DIV_ROUND_UP(freq, HZ_PER_KHZ));\n\n\tdfc->cooling_state = state;\n\n\treturn 0;\n}\n\n \nstatic int get_perf_idx(struct em_perf_domain *em_pd, unsigned long freq)\n{\n\tint i;\n\n\tfor (i = 0; i < em_pd->nr_perf_states; i++) {\n\t\tif (em_pd->table[i].frequency == freq)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic unsigned long get_voltage(struct devfreq *df, unsigned long freq)\n{\n\tstruct device *dev = df->dev.parent;\n\tunsigned long voltage;\n\tstruct dev_pm_opp *opp;\n\n\topp = dev_pm_opp_find_freq_exact(dev, freq, true);\n\tif (PTR_ERR(opp) == -ERANGE)\n\t\topp = dev_pm_opp_find_freq_exact(dev, freq, false);\n\n\tif (IS_ERR(opp)) {\n\t\tdev_err_ratelimited(dev, \"Failed to find OPP for frequency %lu: %ld\\n\",\n\t\t\t\t    freq, PTR_ERR(opp));\n\t\treturn 0;\n\t}\n\n\tvoltage = dev_pm_opp_get_voltage(opp) / 1000;  \n\tdev_pm_opp_put(opp);\n\n\tif (voltage == 0) {\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"Failed to get voltage for frequency %lu\\n\",\n\t\t\t\t    freq);\n\t}\n\n\treturn voltage;\n}\n\nstatic void _normalize_load(struct devfreq_dev_status *status)\n{\n\tif (status->total_time > 0xfffff) {\n\t\tstatus->total_time >>= 10;\n\t\tstatus->busy_time >>= 10;\n\t}\n\n\tstatus->busy_time <<= 10;\n\tstatus->busy_time /= status->total_time ? : 1;\n\n\tstatus->busy_time = status->busy_time ? : 1;\n\tstatus->total_time = 1024;\n}\n\nstatic int devfreq_cooling_get_requested_power(struct thermal_cooling_device *cdev,\n\t\t\t\t\t       u32 *power)\n{\n\tstruct devfreq_cooling_device *dfc = cdev->devdata;\n\tstruct devfreq *df = dfc->devfreq;\n\tstruct devfreq_dev_status status;\n\tunsigned long state;\n\tunsigned long freq;\n\tunsigned long voltage;\n\tint res, perf_idx;\n\n\tmutex_lock(&df->lock);\n\tstatus = df->last_status;\n\tmutex_unlock(&df->lock);\n\n\tfreq = status.current_frequency;\n\n\tif (dfc->power_ops && dfc->power_ops->get_real_power) {\n\t\tvoltage = get_voltage(df, freq);\n\t\tif (voltage == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tres = dfc->power_ops->get_real_power(df, power, freq, voltage);\n\t\tif (!res) {\n\t\t\tstate = dfc->capped_state;\n\n\t\t\t \n\t\t\tdfc->res_util = dfc->em_pd->table[state].power;\n\t\t\tdfc->res_util /= MICROWATT_PER_MILLIWATT;\n\n\t\t\tdfc->res_util *= SCALE_ERROR_MITIGATION;\n\n\t\t\tif (*power > 1)\n\t\t\t\tdfc->res_util /= *power;\n\t\t} else {\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t \n\t\tperf_idx = get_perf_idx(dfc->em_pd, freq / 1000);\n\t\tif (perf_idx < 0) {\n\t\t\tres = -EAGAIN;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t_normalize_load(&status);\n\n\t\t \n\t\t*power = dfc->em_pd->table[perf_idx].power;\n\t\t*power /= MICROWATT_PER_MILLIWATT;\n\t\t \n\t\t*power *= status.busy_time;\n\t\t*power >>= 10;\n\t}\n\n\ttrace_thermal_power_devfreq_get_power(cdev, &status, freq, *power);\n\n\treturn 0;\nfail:\n\t \n\tdfc->res_util = SCALE_ERROR_MITIGATION;\n\treturn res;\n}\n\nstatic int devfreq_cooling_state2power(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long state, u32 *power)\n{\n\tstruct devfreq_cooling_device *dfc = cdev->devdata;\n\tint perf_idx;\n\n\tif (state > dfc->max_state)\n\t\treturn -EINVAL;\n\n\tperf_idx = dfc->max_state - state;\n\t*power = dfc->em_pd->table[perf_idx].power;\n\t*power /= MICROWATT_PER_MILLIWATT;\n\n\treturn 0;\n}\n\nstatic int devfreq_cooling_power2state(struct thermal_cooling_device *cdev,\n\t\t\t\t       u32 power, unsigned long *state)\n{\n\tstruct devfreq_cooling_device *dfc = cdev->devdata;\n\tstruct devfreq *df = dfc->devfreq;\n\tstruct devfreq_dev_status status;\n\tunsigned long freq, em_power_mw;\n\ts32 est_power;\n\tint i;\n\n\tmutex_lock(&df->lock);\n\tstatus = df->last_status;\n\tmutex_unlock(&df->lock);\n\n\tfreq = status.current_frequency;\n\n\tif (dfc->power_ops && dfc->power_ops->get_real_power) {\n\t\t \n\t\test_power = power * dfc->res_util;\n\t\test_power /= SCALE_ERROR_MITIGATION;\n\t} else {\n\t\t \n\t\t_normalize_load(&status);\n\t\test_power = power << 10;\n\t\test_power /= status.busy_time;\n\t}\n\n\t \n\tfor (i = dfc->max_state; i > 0; i--) {\n\t\t \n\t\tem_power_mw = dfc->em_pd->table[i].power;\n\t\tem_power_mw /= MICROWATT_PER_MILLIWATT;\n\t\tif (est_power >= em_power_mw)\n\t\t\tbreak;\n\t}\n\n\t*state = dfc->max_state - i;\n\tdfc->capped_state = *state;\n\n\ttrace_thermal_power_devfreq_limit(cdev, freq, *state, power);\n\treturn 0;\n}\n\n \nstatic int devfreq_cooling_gen_tables(struct devfreq_cooling_device *dfc,\n\t\t\t\t      int num_opps)\n{\n\tstruct devfreq *df = dfc->devfreq;\n\tstruct device *dev = df->dev.parent;\n\tunsigned long freq;\n\tint i;\n\n\tdfc->freq_table = kcalloc(num_opps, sizeof(*dfc->freq_table),\n\t\t\t     GFP_KERNEL);\n\tif (!dfc->freq_table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, freq = ULONG_MAX; i < num_opps; i++, freq--) {\n\t\tstruct dev_pm_opp *opp;\n\n\t\topp = dev_pm_opp_find_freq_floor(dev, &freq);\n\t\tif (IS_ERR(opp)) {\n\t\t\tkfree(dfc->freq_table);\n\t\t\treturn PTR_ERR(opp);\n\t\t}\n\n\t\tdev_pm_opp_put(opp);\n\t\tdfc->freq_table[i] = freq;\n\t}\n\n\treturn 0;\n}\n\n \nstruct thermal_cooling_device *\nof_devfreq_cooling_register_power(struct device_node *np, struct devfreq *df,\n\t\t\t\t  struct devfreq_cooling_power *dfc_power)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *dev = df->dev.parent;\n\tstruct devfreq_cooling_device *dfc;\n\tstruct em_perf_domain *em;\n\tstruct thermal_cooling_device_ops *ops;\n\tchar *name;\n\tint err, num_opps;\n\n\n\tdfc = kzalloc(sizeof(*dfc), GFP_KERNEL);\n\tif (!dfc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdfc->devfreq = df;\n\n\tops = &dfc->cooling_ops;\n\tops->get_max_state = devfreq_cooling_get_max_state;\n\tops->get_cur_state = devfreq_cooling_get_cur_state;\n\tops->set_cur_state = devfreq_cooling_set_cur_state;\n\n\tem = em_pd_get(dev);\n\tif (em && !em_is_artificial(em)) {\n\t\tdfc->em_pd = em;\n\t\tops->get_requested_power =\n\t\t\tdevfreq_cooling_get_requested_power;\n\t\tops->state2power = devfreq_cooling_state2power;\n\t\tops->power2state = devfreq_cooling_power2state;\n\n\t\tdfc->power_ops = dfc_power;\n\n\t\tnum_opps = em_pd_nr_perf_states(dfc->em_pd);\n\t} else {\n\t\t \n\t\tdev_dbg(dev, \"missing proper EM for cooling device\\n\");\n\n\t\tnum_opps = dev_pm_opp_get_opp_count(dev);\n\n\t\terr = devfreq_cooling_gen_tables(dfc, num_opps);\n\t\tif (err)\n\t\t\tgoto free_dfc;\n\t}\n\n\tif (num_opps <= 0) {\n\t\terr = -EINVAL;\n\t\tgoto free_dfc;\n\t}\n\n\t \n\tdfc->max_state = num_opps - 1;\n\n\terr = dev_pm_qos_add_request(dev, &dfc->req_max_freq,\n\t\t\t\t     DEV_PM_QOS_MAX_FREQUENCY,\n\t\t\t\t     PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE);\n\tif (err < 0)\n\t\tgoto free_table;\n\n\terr = -ENOMEM;\n\tname = kasprintf(GFP_KERNEL, \"devfreq-%s\", dev_name(dev));\n\tif (!name)\n\t\tgoto remove_qos_req;\n\n\tcdev = thermal_of_cooling_device_register(np, name, dfc, ops);\n\tkfree(name);\n\n\tif (IS_ERR(cdev)) {\n\t\terr = PTR_ERR(cdev);\n\t\tdev_err(dev,\n\t\t\t\"Failed to register devfreq cooling device (%d)\\n\",\n\t\t\terr);\n\t\tgoto remove_qos_req;\n\t}\n\n\tdfc->cdev = cdev;\n\n\treturn cdev;\n\nremove_qos_req:\n\tdev_pm_qos_remove_request(&dfc->req_max_freq);\nfree_table:\n\tkfree(dfc->freq_table);\nfree_dfc:\n\tkfree(dfc);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(of_devfreq_cooling_register_power);\n\n \nstruct thermal_cooling_device *\nof_devfreq_cooling_register(struct device_node *np, struct devfreq *df)\n{\n\treturn of_devfreq_cooling_register_power(np, df, NULL);\n}\nEXPORT_SYMBOL_GPL(of_devfreq_cooling_register);\n\n \nstruct thermal_cooling_device *devfreq_cooling_register(struct devfreq *df)\n{\n\treturn of_devfreq_cooling_register(NULL, df);\n}\nEXPORT_SYMBOL_GPL(devfreq_cooling_register);\n\n \nstruct thermal_cooling_device *\ndevfreq_cooling_em_register(struct devfreq *df,\n\t\t\t    struct devfreq_cooling_power *dfc_power)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *dev;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(df))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev = df->dev.parent;\n\n\tret = dev_pm_opp_of_register_em(dev, NULL);\n\tif (ret)\n\t\tdev_dbg(dev, \"Unable to register EM for devfreq cooling device (%d)\\n\",\n\t\t\tret);\n\n\tcdev = of_devfreq_cooling_register_power(dev->of_node, df, dfc_power);\n\n\tif (IS_ERR_OR_NULL(cdev))\n\t\tem_dev_unregister_perf_domain(dev);\n\n\treturn cdev;\n}\nEXPORT_SYMBOL_GPL(devfreq_cooling_em_register);\n\n \nvoid devfreq_cooling_unregister(struct thermal_cooling_device *cdev)\n{\n\tstruct devfreq_cooling_device *dfc;\n\tstruct device *dev;\n\n\tif (IS_ERR_OR_NULL(cdev))\n\t\treturn;\n\n\tdfc = cdev->devdata;\n\tdev = dfc->devfreq->dev.parent;\n\n\tthermal_cooling_device_unregister(dfc->cdev);\n\tdev_pm_qos_remove_request(&dfc->req_max_freq);\n\n\tem_dev_unregister_perf_domain(dev);\n\n\tkfree(dfc->freq_table);\n\tkfree(dfc);\n}\nEXPORT_SYMBOL_GPL(devfreq_cooling_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}