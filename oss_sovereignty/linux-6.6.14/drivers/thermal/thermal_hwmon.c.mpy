{
  "module_name": "thermal_hwmon.c",
  "hash_id": "961e3cd39deb6deb2227b5f4243cee8214e247aa1bb6be0e6c9a39b1f9f30056",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/thermal_hwmon.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/hwmon.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n#include \"thermal_core.h\"\n\n \n \nstruct thermal_hwmon_device {\n\tchar type[THERMAL_NAME_LENGTH];\n\tstruct device *device;\n\tint count;\n\tstruct list_head tz_list;\n\tstruct list_head node;\n};\n\nstruct thermal_hwmon_attr {\n\tstruct device_attribute attr;\n\tchar name[16];\n};\n\n \nstruct thermal_hwmon_temp {\n\tstruct list_head hwmon_node;\n\tstruct thermal_zone_device *tz;\n\tstruct thermal_hwmon_attr temp_input;\t \n\tstruct thermal_hwmon_attr temp_crit;\t \n};\n\nstatic LIST_HEAD(thermal_hwmon_list);\n\nstatic DEFINE_MUTEX(thermal_hwmon_list_lock);\n\nstatic ssize_t\ntemp_input_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tint temperature;\n\tint ret;\n\tstruct thermal_hwmon_attr *hwmon_attr\n\t\t\t= container_of(attr, struct thermal_hwmon_attr, attr);\n\tstruct thermal_hwmon_temp *temp\n\t\t\t= container_of(hwmon_attr, struct thermal_hwmon_temp,\n\t\t\t\t       temp_input);\n\tstruct thermal_zone_device *tz = temp->tz;\n\n\tret = thermal_zone_get_temp(tz, &temperature);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", temperature);\n}\n\nstatic ssize_t\ntemp_crit_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct thermal_hwmon_attr *hwmon_attr\n\t\t\t= container_of(attr, struct thermal_hwmon_attr, attr);\n\tstruct thermal_hwmon_temp *temp\n\t\t\t= container_of(hwmon_attr, struct thermal_hwmon_temp,\n\t\t\t\t       temp_crit);\n\tstruct thermal_zone_device *tz = temp->tz;\n\tint temperature;\n\tint ret;\n\n\tmutex_lock(&tz->lock);\n\n\tif (device_is_registered(&tz->device))\n\t\tret = tz->ops->get_crit_temp(tz, &temperature);\n\telse\n\t\tret = -ENODEV;\n\n\tmutex_unlock(&tz->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", temperature);\n}\n\n\nstatic struct thermal_hwmon_device *\nthermal_hwmon_lookup_by_type(const struct thermal_zone_device *tz)\n{\n\tstruct thermal_hwmon_device *hwmon;\n\tchar type[THERMAL_NAME_LENGTH];\n\n\tmutex_lock(&thermal_hwmon_list_lock);\n\tlist_for_each_entry(hwmon, &thermal_hwmon_list, node) {\n\t\tstrcpy(type, tz->type);\n\t\tstrreplace(type, '-', '_');\n\t\tif (!strcmp(hwmon->type, type)) {\n\t\t\tmutex_unlock(&thermal_hwmon_list_lock);\n\t\t\treturn hwmon;\n\t\t}\n\t}\n\tmutex_unlock(&thermal_hwmon_list_lock);\n\n\treturn NULL;\n}\n\n \nstatic struct thermal_hwmon_temp *\nthermal_hwmon_lookup_temp(const struct thermal_hwmon_device *hwmon,\n\t\t\t  const struct thermal_zone_device *tz)\n{\n\tstruct thermal_hwmon_temp *temp;\n\n\tmutex_lock(&thermal_hwmon_list_lock);\n\tlist_for_each_entry(temp, &hwmon->tz_list, hwmon_node)\n\t\tif (temp->tz == tz) {\n\t\t\tmutex_unlock(&thermal_hwmon_list_lock);\n\t\t\treturn temp;\n\t\t}\n\tmutex_unlock(&thermal_hwmon_list_lock);\n\n\treturn NULL;\n}\n\nstatic bool thermal_zone_crit_temp_valid(struct thermal_zone_device *tz)\n{\n\tint temp;\n\treturn tz->ops->get_crit_temp && !tz->ops->get_crit_temp(tz, &temp);\n}\n\nint thermal_add_hwmon_sysfs(struct thermal_zone_device *tz)\n{\n\tstruct thermal_hwmon_device *hwmon;\n\tstruct thermal_hwmon_temp *temp;\n\tint new_hwmon_device = 1;\n\tint result;\n\n\thwmon = thermal_hwmon_lookup_by_type(tz);\n\tif (hwmon) {\n\t\tnew_hwmon_device = 0;\n\t\tgoto register_sys_interface;\n\t}\n\n\thwmon = kzalloc(sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&hwmon->tz_list);\n\tstrscpy(hwmon->type, tz->type, THERMAL_NAME_LENGTH);\n\tstrreplace(hwmon->type, '-', '_');\n\thwmon->device = hwmon_device_register_for_thermal(&tz->device,\n\t\t\t\t\t\t\t  hwmon->type, hwmon);\n\tif (IS_ERR(hwmon->device)) {\n\t\tresult = PTR_ERR(hwmon->device);\n\t\tgoto free_mem;\n\t}\n\n register_sys_interface:\n\ttemp = kzalloc(sizeof(*temp), GFP_KERNEL);\n\tif (!temp) {\n\t\tresult = -ENOMEM;\n\t\tgoto unregister_name;\n\t}\n\n\ttemp->tz = tz;\n\thwmon->count++;\n\n\tsnprintf(temp->temp_input.name, sizeof(temp->temp_input.name),\n\t\t \"temp%d_input\", hwmon->count);\n\ttemp->temp_input.attr.attr.name = temp->temp_input.name;\n\ttemp->temp_input.attr.attr.mode = 0444;\n\ttemp->temp_input.attr.show = temp_input_show;\n\tsysfs_attr_init(&temp->temp_input.attr.attr);\n\tresult = device_create_file(hwmon->device, &temp->temp_input.attr);\n\tif (result)\n\t\tgoto free_temp_mem;\n\n\tif (thermal_zone_crit_temp_valid(tz)) {\n\t\tsnprintf(temp->temp_crit.name,\n\t\t\t\tsizeof(temp->temp_crit.name),\n\t\t\t\t\"temp%d_crit\", hwmon->count);\n\t\ttemp->temp_crit.attr.attr.name = temp->temp_crit.name;\n\t\ttemp->temp_crit.attr.attr.mode = 0444;\n\t\ttemp->temp_crit.attr.show = temp_crit_show;\n\t\tsysfs_attr_init(&temp->temp_crit.attr.attr);\n\t\tresult = device_create_file(hwmon->device,\n\t\t\t\t\t    &temp->temp_crit.attr);\n\t\tif (result)\n\t\t\tgoto unregister_input;\n\t}\n\n\tmutex_lock(&thermal_hwmon_list_lock);\n\tif (new_hwmon_device)\n\t\tlist_add_tail(&hwmon->node, &thermal_hwmon_list);\n\tlist_add_tail(&temp->hwmon_node, &hwmon->tz_list);\n\tmutex_unlock(&thermal_hwmon_list_lock);\n\n\treturn 0;\n\n unregister_input:\n\tdevice_remove_file(hwmon->device, &temp->temp_input.attr);\n free_temp_mem:\n\tkfree(temp);\n unregister_name:\n\tif (new_hwmon_device)\n\t\thwmon_device_unregister(hwmon->device);\n free_mem:\n\tkfree(hwmon);\n\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(thermal_add_hwmon_sysfs);\n\nvoid thermal_remove_hwmon_sysfs(struct thermal_zone_device *tz)\n{\n\tstruct thermal_hwmon_device *hwmon;\n\tstruct thermal_hwmon_temp *temp;\n\n\thwmon = thermal_hwmon_lookup_by_type(tz);\n\tif (unlikely(!hwmon)) {\n\t\t \n\t\tdev_dbg(&tz->device, \"hwmon device lookup failed!\\n\");\n\t\treturn;\n\t}\n\n\ttemp = thermal_hwmon_lookup_temp(hwmon, tz);\n\tif (unlikely(!temp)) {\n\t\t \n\t\tdev_dbg(&tz->device, \"temperature input lookup failed!\\n\");\n\t\treturn;\n\t}\n\n\tdevice_remove_file(hwmon->device, &temp->temp_input.attr);\n\tif (thermal_zone_crit_temp_valid(tz))\n\t\tdevice_remove_file(hwmon->device, &temp->temp_crit.attr);\n\n\tmutex_lock(&thermal_hwmon_list_lock);\n\tlist_del(&temp->hwmon_node);\n\tkfree(temp);\n\tif (!list_empty(&hwmon->tz_list)) {\n\t\tmutex_unlock(&thermal_hwmon_list_lock);\n\t\treturn;\n\t}\n\tlist_del(&hwmon->node);\n\tmutex_unlock(&thermal_hwmon_list_lock);\n\n\thwmon_device_unregister(hwmon->device);\n\tkfree(hwmon);\n}\nEXPORT_SYMBOL_GPL(thermal_remove_hwmon_sysfs);\n\nstatic void devm_thermal_hwmon_release(struct device *dev, void *res)\n{\n\tthermal_remove_hwmon_sysfs(*(struct thermal_zone_device **)res);\n}\n\nint devm_thermal_add_hwmon_sysfs(struct device *dev, struct thermal_zone_device *tz)\n{\n\tstruct thermal_zone_device **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_thermal_hwmon_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr) {\n\t\tdev_warn(dev, \"Failed to allocate device resource data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = thermal_add_hwmon_sysfs(tz);\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to add hwmon sysfs attributes\\n\");\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\t*ptr = tz;\n\tdevres_add(dev, ptr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_thermal_add_hwmon_sysfs);\n\nMODULE_IMPORT_NS(HWMON_THERMAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}