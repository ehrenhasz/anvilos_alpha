{
  "module_name": "thermal-generic-adc.c",
  "hash_id": "9ea5469bbc2a80ac63d98ff9e697eb494c7d6e8dbb59873234f3e14e09b27adc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/thermal-generic-adc.c",
  "human_readable_source": "\n \n#include <linux/iio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n\nstruct gadc_thermal_info {\n\tstruct device *dev;\n\tstruct thermal_zone_device *tz_dev;\n\tstruct iio_channel *channel;\n\ts32 *lookup_table;\n\tint nlookup_table;\n};\n\nstatic int gadc_thermal_adc_to_temp(struct gadc_thermal_info *gti, int val)\n{\n\tint temp, temp_hi, temp_lo, adc_hi, adc_lo;\n\tint i;\n\n\tif (!gti->lookup_table)\n\t\treturn val;\n\n\tfor (i = 0; i < gti->nlookup_table; i++) {\n\t\tif (val >= gti->lookup_table[2 * i + 1])\n\t\t\tbreak;\n\t}\n\n\tif (i == 0) {\n\t\ttemp = gti->lookup_table[0];\n\t} else if (i >= gti->nlookup_table) {\n\t\ttemp = gti->lookup_table[2 * (gti->nlookup_table - 1)];\n\t} else {\n\t\tadc_hi = gti->lookup_table[2 * i - 1];\n\t\tadc_lo = gti->lookup_table[2 * i + 1];\n\n\t\ttemp_hi = gti->lookup_table[2 * i - 2];\n\t\ttemp_lo = gti->lookup_table[2 * i];\n\n\t\ttemp = temp_hi + mult_frac(temp_lo - temp_hi, val - adc_hi,\n\t\t\t\t\t   adc_lo - adc_hi);\n\t}\n\n\treturn temp;\n}\n\nstatic int gadc_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct gadc_thermal_info *gti = thermal_zone_device_priv(tz);\n\tint val;\n\tint ret;\n\n\tret = iio_read_channel_processed(gti->channel, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*temp = gadc_thermal_adc_to_temp(gti, val);\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops gadc_thermal_ops = {\n\t.get_temp = gadc_thermal_get_temp,\n};\n\nstatic int gadc_thermal_read_linear_lookup_table(struct device *dev,\n\t\t\t\t\t\t struct gadc_thermal_info *gti)\n{\n\tstruct device_node *np = dev->of_node;\n\tenum iio_chan_type chan_type;\n\tint ntable;\n\tint ret;\n\n\tntable = of_property_count_elems_of_size(np, \"temperature-lookup-table\",\n\t\t\t\t\t\t sizeof(u32));\n\tif (ntable <= 0) {\n\t\tret = iio_get_channel_type(gti->channel, &chan_type);\n\t\tif (ret || chan_type != IIO_TEMP)\n\t\t\tdev_notice(dev,\n\t\t\t\t   \"no lookup table, assuming DAC channel returns milliCelcius\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ntable % 2) {\n\t\tdev_err(dev, \"Pair of temperature vs ADC read value missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgti->lookup_table = devm_kcalloc(dev,\n\t\t\t\t\t ntable, sizeof(*gti->lookup_table),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!gti->lookup_table)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, \"temperature-lookup-table\",\n\t\t\t\t\t (u32 *)gti->lookup_table, ntable);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read temperature lookup table: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tgti->nlookup_table = ntable / 2;\n\n\treturn 0;\n}\n\nstatic int gadc_thermal_probe(struct platform_device *pdev)\n{\n\tstruct gadc_thermal_info *gti;\n\tint ret;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"Only DT based supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgti = devm_kzalloc(&pdev->dev, sizeof(*gti), GFP_KERNEL);\n\tif (!gti)\n\t\treturn -ENOMEM;\n\n\tgti->channel = devm_iio_channel_get(&pdev->dev, \"sensor-channel\");\n\tif (IS_ERR(gti->channel)) {\n\t\tret = PTR_ERR(gti->channel);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"IIO channel not found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gadc_thermal_read_linear_lookup_table(&pdev->dev, gti);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgti->dev = &pdev->dev;\n\n\tgti->tz_dev = devm_thermal_of_zone_register(&pdev->dev, 0, gti,\n\t\t\t\t\t\t    &gadc_thermal_ops);\n\tif (IS_ERR(gti->tz_dev)) {\n\t\tret = PTR_ERR(gti->tz_dev);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Thermal zone sensor register failed: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdevm_thermal_add_hwmon_sysfs(&pdev->dev, gti->tz_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_adc_thermal_match[] = {\n\t{ .compatible = \"generic-adc-thermal\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_adc_thermal_match);\n\nstatic struct platform_driver gadc_thermal_driver = {\n\t.driver = {\n\t\t.name = \"generic-adc-thermal\",\n\t\t.of_match_table = of_adc_thermal_match,\n\t},\n\t.probe = gadc_thermal_probe,\n};\n\nmodule_platform_driver(gadc_thermal_driver);\n\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_DESCRIPTION(\"Generic ADC thermal driver using IIO framework with DT\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}