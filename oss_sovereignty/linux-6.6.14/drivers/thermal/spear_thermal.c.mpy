{
  "module_name": "spear_thermal.c",
  "hash_id": "e1dd1e4bae4da6c7c6f62e53d9b285b76344c57785385b6774c6ff398d49c4a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/spear_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n\n#define MD_FACTOR\t1000\n\n \nstruct spear_thermal_dev {\n\t \n\tvoid __iomem *thermal_base;\n\t \n\tstruct clk *clk;\n\t \n\tunsigned int flags;\n};\n\nstatic inline int thermal_get_temp(struct thermal_zone_device *thermal,\n\t\t\t\tint *temp)\n{\n\tstruct spear_thermal_dev *stdev = thermal_zone_device_priv(thermal);\n\n\t \n\t*temp = (readl_relaxed(stdev->thermal_base) & 0x7F) * MD_FACTOR;\n\treturn 0;\n}\n\nstatic struct thermal_zone_device_ops ops = {\n\t.get_temp = thermal_get_temp,\n};\n\nstatic int __maybe_unused spear_thermal_suspend(struct device *dev)\n{\n\tstruct thermal_zone_device *spear_thermal = dev_get_drvdata(dev);\n\tstruct spear_thermal_dev *stdev = thermal_zone_device_priv(spear_thermal);\n\tunsigned int actual_mask = 0;\n\n\t \n\tactual_mask = readl_relaxed(stdev->thermal_base);\n\twritel_relaxed(actual_mask & ~stdev->flags, stdev->thermal_base);\n\n\tclk_disable(stdev->clk);\n\tdev_info(dev, \"Suspended.\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused spear_thermal_resume(struct device *dev)\n{\n\tstruct thermal_zone_device *spear_thermal = dev_get_drvdata(dev);\n\tstruct spear_thermal_dev *stdev = thermal_zone_device_priv(spear_thermal);\n\tunsigned int actual_mask = 0;\n\tint ret = 0;\n\n\tret = clk_enable(stdev->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tactual_mask = readl_relaxed(stdev->thermal_base);\n\twritel_relaxed(actual_mask | stdev->flags, stdev->thermal_base);\n\n\tdev_info(dev, \"Resumed.\\n\");\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(spear_thermal_pm_ops, spear_thermal_suspend,\n\t\tspear_thermal_resume);\n\nstatic int spear_thermal_probe(struct platform_device *pdev)\n{\n\tstruct thermal_zone_device *spear_thermal = NULL;\n\tstruct spear_thermal_dev *stdev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret = 0, val;\n\n\tif (!np || !of_property_read_u32(np, \"st,thermal-flags\", &val)) {\n\t\tdev_err(&pdev->dev, \"Failed: DT Pdata not passed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstdev = devm_kzalloc(&pdev->dev, sizeof(*stdev), GFP_KERNEL);\n\tif (!stdev)\n\t\treturn -ENOMEM;\n\n\t \n\tstdev->thermal_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(stdev->thermal_base))\n\t\treturn PTR_ERR(stdev->thermal_base);\n\n\tstdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(stdev->clk)) {\n\t\tdev_err(&pdev->dev, \"Can't get clock\\n\");\n\t\treturn PTR_ERR(stdev->clk);\n\t}\n\n\tret = clk_enable(stdev->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tstdev->flags = val;\n\twritel_relaxed(stdev->flags, stdev->thermal_base);\n\n\tspear_thermal = thermal_tripless_zone_device_register(\"spear_thermal\",\n\t\t\t\t\t\t\t      stdev, &ops, NULL);\n\tif (IS_ERR(spear_thermal)) {\n\t\tdev_err(&pdev->dev, \"thermal zone device is NULL\\n\");\n\t\tret = PTR_ERR(spear_thermal);\n\t\tgoto disable_clk;\n\t}\n\tret = thermal_zone_device_enable(spear_thermal);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable thermal zone\\n\");\n\t\tgoto unregister_tzd;\n\t}\n\n\tplatform_set_drvdata(pdev, spear_thermal);\n\n\tdev_info(&pdev->dev, \"Thermal Sensor Loaded at: 0x%p.\\n\",\n\t\t\tstdev->thermal_base);\n\n\treturn 0;\n\nunregister_tzd:\n\tthermal_zone_device_unregister(spear_thermal);\ndisable_clk:\n\tclk_disable(stdev->clk);\n\n\treturn ret;\n}\n\nstatic int spear_thermal_exit(struct platform_device *pdev)\n{\n\tunsigned int actual_mask = 0;\n\tstruct thermal_zone_device *spear_thermal = platform_get_drvdata(pdev);\n\tstruct spear_thermal_dev *stdev = thermal_zone_device_priv(spear_thermal);\n\n\tthermal_zone_device_unregister(spear_thermal);\n\n\t \n\tactual_mask = readl_relaxed(stdev->thermal_base);\n\twritel_relaxed(actual_mask & ~stdev->flags, stdev->thermal_base);\n\n\tclk_disable(stdev->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id spear_thermal_id_table[] = {\n\t{ .compatible = \"st,thermal-spear1340\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spear_thermal_id_table);\n\nstatic struct platform_driver spear_thermal_driver = {\n\t.probe = spear_thermal_probe,\n\t.remove = spear_thermal_exit,\n\t.driver = {\n\t\t.name = \"spear_thermal\",\n\t\t.pm = &spear_thermal_pm_ops,\n\t\t.of_match_table = spear_thermal_id_table,\n\t},\n};\n\nmodule_platform_driver(spear_thermal_driver);\n\nMODULE_AUTHOR(\"Vincenzo Frascino <vincenzo.frascino@st.com>\");\nMODULE_DESCRIPTION(\"SPEAr thermal driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}