{
  "module_name": "qoriq_thermal.c",
  "hash_id": "d2321190d51389ebc92e4e7a5eac9aaa73912ac7f2c74d49b1cba82d64dca2ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/qoriq_thermal.c",
  "human_readable_source": "\n\n\n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sizes.h>\n#include <linux/thermal.h>\n#include <linux/units.h>\n\n#include \"thermal_hwmon.h\"\n\n#define SITES_MAX\t\t16\n#define TMR_DISABLE\t\t0x0\n#define TMR_ME\t\t\t0x80000000\n#define TMR_ALPF\t\t0x0c000000\n#define TMR_ALPF_V2\t\t0x03000000\n#define TMTMIR_DEFAULT\t0x0000000f\n#define TIER_DISABLE\t0x0\n#define TEUMR0_V2\t\t0x51009c00\n#define TMSARA_V2\t\t0xe\n#define TMU_VER1\t\t0x1\n#define TMU_VER2\t\t0x2\n\n#define REGS_TMR\t0x000\t \n#define TMR_DISABLE\t0x0\n#define TMR_ME\t\t0x80000000\n#define TMR_ALPF\t0x0c000000\n\n#define REGS_TMTMIR\t0x008\t \n#define TMTMIR_DEFAULT\t0x0000000f\n\n#define REGS_V2_TMSR\t0x008\t \n\n#define REGS_V2_TMTMIR\t0x00c\t \n\n#define REGS_TIER\t0x020\t \n#define TIER_DISABLE\t0x0\n\n\n#define REGS_TTCFGR\t0x080\t \n#define REGS_TSCFGR\t0x084\t \n\n#define REGS_TRITSR(n)\t(0x100 + 16 * (n))  \n#define TRITSR_V\tBIT(31)\n#define TRITSR_TP5\tBIT(9)\n#define REGS_V2_TMSAR(n)\t(0x304 + 16 * (n))\t \n#define REGS_TTRnCR(n)\t(0xf10 + 4 * (n))  \n#define REGS_IPBRR(n)\t\t(0xbf8 + 4 * (n))  \n#define REGS_V2_TEUMR(n)\t(0xf00 + 4 * (n))\n\n \nstruct qoriq_sensor {\n\tint\t\t\t\tid;\n};\n\nstruct qoriq_tmu_data {\n\tint ver;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tstruct qoriq_sensor\tsensor[SITES_MAX];\n};\n\nstatic struct qoriq_tmu_data *qoriq_sensor_to_data(struct qoriq_sensor *s)\n{\n\treturn container_of(s, struct qoriq_tmu_data, sensor[s->id]);\n}\n\nstatic int tmu_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct qoriq_sensor *qsensor = thermal_zone_device_priv(tz);\n\tstruct qoriq_tmu_data *qdata = qoriq_sensor_to_data(qsensor);\n\tu32 val;\n\t \n\n\tregmap_read(qdata->regmap, REGS_TMR, &val);\n\tif (!(val & TMR_ME))\n\t\treturn -EAGAIN;\n\n\tif (regmap_read_poll_timeout(qdata->regmap,\n\t\t\t\t     REGS_TRITSR(qsensor->id),\n\t\t\t\t     val,\n\t\t\t\t     val & TRITSR_V,\n\t\t\t\t     USEC_PER_MSEC,\n\t\t\t\t     10 * USEC_PER_MSEC))\n\t\treturn -ENODATA;\n\n\tif (qdata->ver == TMU_VER1) {\n\t\t*temp = (val & GENMASK(7, 0)) * MILLIDEGREE_PER_DEGREE;\n\t} else {\n\t\tif (val & TRITSR_TP5)\n\t\t\t*temp = milli_kelvin_to_millicelsius((val & GENMASK(8, 0)) *\n\t\t\t\t\t\t\t     MILLIDEGREE_PER_DEGREE + 500);\n\t\telse\n\t\t\t*temp = kelvin_to_millicelsius(val & GENMASK(8, 0));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops tmu_tz_ops = {\n\t.get_temp = tmu_get_temp,\n};\n\nstatic int qoriq_tmu_register_tmu_zone(struct device *dev,\n\t\t\t\t       struct qoriq_tmu_data *qdata)\n{\n\tint id, sites = 0;\n\n\tfor (id = 0; id < SITES_MAX; id++) {\n\t\tstruct thermal_zone_device *tzd;\n\t\tstruct qoriq_sensor *sensor = &qdata->sensor[id];\n\t\tint ret;\n\n\t\tsensor->id = id;\n\n\t\ttzd = devm_thermal_of_zone_register(dev, id,\n\t\t\t\t\t\t    sensor,\n\t\t\t\t\t\t    &tmu_tz_ops);\n\t\tret = PTR_ERR_OR_ZERO(tzd);\n\t\tif (ret) {\n\t\t\tif (ret == -ENODEV)\n\t\t\t\tcontinue;\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (qdata->ver == TMU_VER1)\n\t\t\tsites |= 0x1 << (15 - id);\n\t\telse\n\t\t\tsites |= 0x1 << id;\n\n\t\tdevm_thermal_add_hwmon_sysfs(dev, tzd);\n\t}\n\n\tif (sites) {\n\t\tif (qdata->ver == TMU_VER1) {\n\t\t\tregmap_write(qdata->regmap, REGS_TMR, TMR_ME | TMR_ALPF | sites);\n\t\t} else {\n\t\t\tregmap_write(qdata->regmap, REGS_V2_TMSR, sites);\n\t\t\tregmap_write(qdata->regmap, REGS_TMR, TMR_ME | TMR_ALPF_V2);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qoriq_tmu_calibration(struct device *dev,\n\t\t\t\t struct qoriq_tmu_data *data)\n{\n\tint i, val, len;\n\tu32 range[4];\n\tconst u32 *calibration;\n\tstruct device_node *np = dev->of_node;\n\n\tlen = of_property_count_u32_elems(np, \"fsl,tmu-range\");\n\tif (len < 0 || len > 4) {\n\t\tdev_err(dev, \"invalid range data.\\n\");\n\t\treturn len;\n\t}\n\n\tval = of_property_read_u32_array(np, \"fsl,tmu-range\", range, len);\n\tif (val != 0) {\n\t\tdev_err(dev, \"failed to read range data.\\n\");\n\t\treturn val;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tregmap_write(data->regmap, REGS_TTRnCR(i), range[i]);\n\n\tcalibration = of_get_property(np, \"fsl,tmu-calibration\", &len);\n\tif (calibration == NULL || len % 8) {\n\t\tdev_err(dev, \"invalid calibration data.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < len; i += 8, calibration += 2) {\n\t\tval = of_read_number(calibration, 1);\n\t\tregmap_write(data->regmap, REGS_TTCFGR, val);\n\t\tval = of_read_number(calibration + 1, 1);\n\t\tregmap_write(data->regmap, REGS_TSCFGR, val);\n\t}\n\n\treturn 0;\n}\n\nstatic void qoriq_tmu_init_device(struct qoriq_tmu_data *data)\n{\n\t \n\tregmap_write(data->regmap, REGS_TIER, TIER_DISABLE);\n\n\t \n\n\tif (data->ver == TMU_VER1) {\n\t\tregmap_write(data->regmap, REGS_TMTMIR, TMTMIR_DEFAULT);\n\t} else {\n\t\tregmap_write(data->regmap, REGS_V2_TMTMIR, TMTMIR_DEFAULT);\n\t\tregmap_write(data->regmap, REGS_V2_TEUMR(0), TEUMR0_V2);\n\t}\n\n\t \n\tregmap_write(data->regmap, REGS_TMR, TMR_DISABLE);\n}\n\nstatic const struct regmap_range qoriq_yes_ranges[] = {\n\tregmap_reg_range(REGS_TMR, REGS_TSCFGR),\n\tregmap_reg_range(REGS_TTRnCR(0), REGS_TTRnCR(15)),\n\tregmap_reg_range(REGS_V2_TEUMR(0), REGS_V2_TEUMR(2)),\n\tregmap_reg_range(REGS_V2_TMSAR(0), REGS_V2_TMSAR(15)),\n\tregmap_reg_range(REGS_IPBRR(0), REGS_IPBRR(1)),\n\t \n\tregmap_reg_range(REGS_TRITSR(0), REGS_TRITSR(15)),\n};\n\nstatic const struct regmap_access_table qoriq_wr_table = {\n\t.yes_ranges\t= qoriq_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(qoriq_yes_ranges) - 1,\n};\n\nstatic const struct regmap_access_table qoriq_rd_table = {\n\t.yes_ranges\t= qoriq_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(qoriq_yes_ranges),\n};\n\nstatic void qoriq_tmu_action(void *p)\n{\n\tstruct qoriq_tmu_data *data = p;\n\n\tregmap_write(data->regmap, REGS_TMR, TMR_DISABLE);\n\tclk_disable_unprepare(data->clk);\n}\n\nstatic int qoriq_tmu_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 ver;\n\tstruct qoriq_tmu_data *data;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tconst bool little_endian = of_property_read_bool(np, \"little-endian\");\n\tconst enum regmap_endian format_endian =\n\t\tlittle_endian ? REGMAP_ENDIAN_LITTLE : REGMAP_ENDIAN_BIG;\n\tconst struct regmap_config regmap_config = {\n\t\t.reg_bits\t\t= 32,\n\t\t.val_bits\t\t= 32,\n\t\t.reg_stride\t\t= 4,\n\t\t.rd_table\t\t= &qoriq_rd_table,\n\t\t.wr_table\t\t= &qoriq_wr_table,\n\t\t.val_format_endian\t= format_endian,\n\t\t.max_register\t\t= SZ_4K,\n\t};\n\tvoid __iomem *base;\n\n\tdata = devm_kzalloc(dev, sizeof(struct qoriq_tmu_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tret = PTR_ERR_OR_ZERO(base);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get memory region\\n\");\n\t\treturn ret;\n\t}\n\n\tdata->regmap = devm_regmap_init_mmio(dev, base, &regmap_config);\n\tret = PTR_ERR_OR_ZERO(data->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init regmap (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(data->clk))\n\t\treturn PTR_ERR(data->clk);\n\n\tret = clk_prepare_enable(data->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, qoriq_tmu_action, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(data->regmap, REGS_IPBRR(0), &ver);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to read IP block version\\n\");\n\t\treturn ret;\n\t}\n\tdata->ver = (ver >> 8) & 0xff;\n\n\tqoriq_tmu_init_device(data);\t \n\n\tret = qoriq_tmu_calibration(dev, data);\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = qoriq_tmu_register_tmu_zone(dev, data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register sensors\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qoriq_tmu_suspend(struct device *dev)\n{\n\tstruct qoriq_tmu_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(data->regmap, REGS_TMR, TMR_ME, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qoriq_tmu_resume(struct device *dev)\n{\n\tint ret;\n\tstruct qoriq_tmu_data *data = dev_get_drvdata(dev);\n\n\tret = clk_prepare_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(data->regmap, REGS_TMR, TMR_ME, TMR_ME);\n}\n\nstatic SIMPLE_DEV_PM_OPS(qoriq_tmu_pm_ops,\n\t\t\t qoriq_tmu_suspend, qoriq_tmu_resume);\n\nstatic const struct of_device_id qoriq_tmu_match[] = {\n\t{ .compatible = \"fsl,qoriq-tmu\", },\n\t{ .compatible = \"fsl,imx8mq-tmu\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, qoriq_tmu_match);\n\nstatic struct platform_driver qoriq_tmu = {\n\t.driver\t= {\n\t\t.name\t\t= \"qoriq_thermal\",\n\t\t.pm\t\t= &qoriq_tmu_pm_ops,\n\t\t.of_match_table\t= qoriq_tmu_match,\n\t},\n\t.probe\t= qoriq_tmu_probe,\n};\nmodule_platform_driver(qoriq_tmu);\n\nMODULE_AUTHOR(\"Jia Hongtao <hongtao.jia@nxp.com>\");\nMODULE_DESCRIPTION(\"QorIQ Thermal Monitoring Unit driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}