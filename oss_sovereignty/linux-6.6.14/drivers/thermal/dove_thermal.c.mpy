{
  "module_name": "dove_thermal.c",
  "hash_id": "d07b03dab3dc7e3ef28a8f4fde4e276243fb591936647f1ba2a8ea1a84581006",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/dove_thermal.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n\n#define DOVE_THERMAL_TEMP_OFFSET\t1\n#define DOVE_THERMAL_TEMP_MASK\t\t0x1FF\n\n \n#define PMU_TM_DISABLE_OFFS\t\t0\n#define PMU_TM_DISABLE_MASK\t\t(0x1 << PMU_TM_DISABLE_OFFS)\n\n \n#define PMU_TDC0_SW_RST_MASK\t\t(0x1 << 1)\n#define PMU_TDC0_SEL_VCAL_OFFS\t\t5\n#define PMU_TDC0_SEL_VCAL_MASK\t\t(0x3 << PMU_TDC0_SEL_VCAL_OFFS)\n#define PMU_TDC0_REF_CAL_CNT_OFFS\t11\n#define PMU_TDC0_REF_CAL_CNT_MASK\t(0x1FF << PMU_TDC0_REF_CAL_CNT_OFFS)\n#define PMU_TDC0_AVG_NUM_OFFS\t\t25\n#define PMU_TDC0_AVG_NUM_MASK\t\t(0x7 << PMU_TDC0_AVG_NUM_OFFS)\n\n \n#define PMU_TEMP_DIOD_CTRL1_REG\t\t0x04\n#define PMU_TDC1_TEMP_VALID_MASK\t(0x1 << 10)\n\n \nstruct dove_thermal_priv {\n\tvoid __iomem *sensor;\n\tvoid __iomem *control;\n};\n\nstatic int dove_init_sensor(const struct dove_thermal_priv *priv)\n{\n\tu32 reg;\n\tu32 i;\n\n\t \n\treg = readl_relaxed(priv->control);\n\n\t \n\treg &= ~PMU_TDC0_AVG_NUM_MASK;\n\treg |= (0x1 << PMU_TDC0_AVG_NUM_OFFS);\n\n\t \n\treg &= ~PMU_TDC0_REF_CAL_CNT_MASK;\n\treg |= (0x0F1 << PMU_TDC0_REF_CAL_CNT_OFFS);\n\n\t \n\treg &= ~PMU_TDC0_SEL_VCAL_MASK;\n\treg |= (0x2 << PMU_TDC0_SEL_VCAL_OFFS);\n\twritel(reg, priv->control);\n\n\t \n\treg = readl_relaxed(priv->control);\n\twritel((reg | PMU_TDC0_SW_RST_MASK), priv->control);\n\twritel(reg, priv->control);\n\n\t \n\treg = readl_relaxed(priv->sensor);\n\treg &= ~PMU_TM_DISABLE_MASK;\n\twritel(reg, priv->sensor);\n\n\t \n\tfor (i = 0; i < 1000000; i++) {\n\t\treg = readl_relaxed(priv->sensor);\n\t\tif (reg & DOVE_THERMAL_TEMP_MASK)\n\t\t\tbreak;\n\t}\n\n\tif (i == 1000000)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int dove_get_temp(struct thermal_zone_device *thermal,\n\t\t\t  int *temp)\n{\n\tunsigned long reg;\n\tstruct dove_thermal_priv *priv = thermal_zone_device_priv(thermal);\n\n\t \n\treg = readl_relaxed(priv->control + PMU_TEMP_DIOD_CTRL1_REG);\n\tif ((reg & PMU_TDC1_TEMP_VALID_MASK) == 0x0)\n\t\treturn -EIO;\n\n\t \n\treg = readl_relaxed(priv->sensor);\n\treg = (reg >> DOVE_THERMAL_TEMP_OFFSET) & DOVE_THERMAL_TEMP_MASK;\n\t*temp = ((3220000000UL - (10000000UL * reg)) / 13625);\n\n\treturn 0;\n}\n\nstatic struct thermal_zone_device_ops ops = {\n\t.get_temp = dove_get_temp,\n};\n\nstatic const struct of_device_id dove_thermal_id_table[] = {\n\t{ .compatible = \"marvell,dove-thermal\" },\n\t{}\n};\n\nstatic int dove_thermal_probe(struct platform_device *pdev)\n{\n\tstruct thermal_zone_device *thermal = NULL;\n\tstruct dove_thermal_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->sensor = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(priv->sensor))\n\t\treturn PTR_ERR(priv->sensor);\n\n\tpriv->control = devm_platform_get_and_ioremap_resource(pdev, 1, NULL);\n\tif (IS_ERR(priv->control))\n\t\treturn PTR_ERR(priv->control);\n\n\tret = dove_init_sensor(priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize sensor\\n\");\n\t\treturn ret;\n\t}\n\n\tthermal = thermal_tripless_zone_device_register(\"dove_thermal\", priv,\n\t\t\t\t\t\t\t&ops, NULL);\n\tif (IS_ERR(thermal)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register thermal zone device\\n\");\n\t\treturn PTR_ERR(thermal);\n\t}\n\n\tret = thermal_zone_device_enable(thermal);\n\tif (ret) {\n\t\tthermal_zone_device_unregister(thermal);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, thermal);\n\n\treturn 0;\n}\n\nstatic int dove_thermal_exit(struct platform_device *pdev)\n{\n\tstruct thermal_zone_device *dove_thermal =\n\t\tplatform_get_drvdata(pdev);\n\n\tthermal_zone_device_unregister(dove_thermal);\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(of, dove_thermal_id_table);\n\nstatic struct platform_driver dove_thermal_driver = {\n\t.probe = dove_thermal_probe,\n\t.remove = dove_thermal_exit,\n\t.driver = {\n\t\t.name = \"dove_thermal\",\n\t\t.of_match_table = dove_thermal_id_table,\n\t},\n};\n\nmodule_platform_driver(dove_thermal_driver);\n\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_DESCRIPTION(\"Dove thermal driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}