{
  "module_name": "uniphier_thermal.c",
  "hash_id": "ce677f1737db848bcd293ef986af59ec3015008a3ccf5eccc995ee91f49b7882",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/uniphier_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n\n \n#define PVTCTLEN\t\t\t0x0000\n#define PVTCTLEN_EN\t\t\tBIT(0)\n\n#define PVTCTLMODE\t\t\t0x0004\n#define PVTCTLMODE_MASK\t\t\t0xf\n#define PVTCTLMODE_TEMPMON\t\t0x5\n\n#define EMONREPEAT\t\t\t0x0040\n#define EMONREPEAT_ENDLESS\t\tBIT(24)\n#define EMONREPEAT_PERIOD\t\tGENMASK(3, 0)\n#define EMONREPEAT_PERIOD_1000000\t0x9\n\n \n#define PVTCTLSEL\t\t\t0x0900\n#define PVTCTLSEL_MASK\t\t\tGENMASK(2, 0)\n#define PVTCTLSEL_MONITOR\t\t0\n\n#define SETALERT0\t\t\t0x0910\n#define SETALERT1\t\t\t0x0914\n#define SETALERT2\t\t\t0x0918\n#define SETALERT_TEMP_OVF\t\t(GENMASK(7, 0) << 16)\n#define SETALERT_TEMP_OVF_VALUE(val)\t(((val) & GENMASK(7, 0)) << 16)\n#define SETALERT_EN\t\t\tBIT(0)\n\n#define PMALERTINTCTL\t\t\t0x0920\n#define PMALERTINTCTL_CLR(ch)\t\tBIT(4 * (ch) + 2)\n#define PMALERTINTCTL_SET(ch)\t\tBIT(4 * (ch) + 1)\n#define PMALERTINTCTL_EN(ch)\t\tBIT(4 * (ch) + 0)\n#define PMALERTINTCTL_MASK\t\t(GENMASK(10, 8) | GENMASK(6, 4) | \\\n\t\t\t\t\t GENMASK(2, 0))\n\n#define TMOD\t\t\t\t0x0928\n#define TMOD_WIDTH\t\t\t9\n\n#define TMODCOEF\t\t\t0x0e5c\n\n#define TMODSETUP0_EN\t\t\tBIT(30)\n#define TMODSETUP0_VAL(val)\t\t(((val) & GENMASK(13, 0)) << 16)\n#define TMODSETUP1_EN\t\t\tBIT(15)\n#define TMODSETUP1_VAL(val)\t\t((val) & GENMASK(14, 0))\n\n \n#define CRITICAL_TEMP_LIMIT\t\t(120 * 1000)\n\n \n#define ALERT_CH_NUM\t\t\t3\n\n \nstruct uniphier_tm_soc_data {\n\tu32 map_base;\n\tu32 block_base;\n\tu32 tmod_setup_addr;\n};\n\nstruct uniphier_tm_dev {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tbool alert_en[ALERT_CH_NUM];\n\tstruct thermal_zone_device *tz_dev;\n\tconst struct uniphier_tm_soc_data *data;\n};\n\nstatic int uniphier_tm_initialize_sensor(struct uniphier_tm_dev *tdev)\n{\n\tstruct regmap *map = tdev->regmap;\n\tu32 val;\n\tu32 tmod_calib[2];\n\tint ret;\n\n\t \n\tregmap_write_bits(map, tdev->data->block_base + PVTCTLEN,\n\t\t\t  PVTCTLEN_EN, 0);\n\n\t \n\tret = regmap_read(map, tdev->data->map_base + TMODCOEF, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (!val) {\n\t\t \n\t\tret = of_property_read_u32_array(tdev->dev->of_node,\n\t\t\t\t\t\t \"socionext,tmod-calibration\",\n\t\t\t\t\t\t tmod_calib,\n\t\t\t\t\t\t ARRAY_SIZE(tmod_calib));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tregmap_write(map, tdev->data->tmod_setup_addr,\n\t\t\tTMODSETUP0_EN | TMODSETUP0_VAL(tmod_calib[0]) |\n\t\t\tTMODSETUP1_EN | TMODSETUP1_VAL(tmod_calib[1]));\n\t}\n\n\t \n\tregmap_write_bits(map, tdev->data->block_base + PVTCTLMODE,\n\t\t\t  PVTCTLMODE_MASK, PVTCTLMODE_TEMPMON);\n\n\t \n\tregmap_write_bits(map, tdev->data->block_base + EMONREPEAT,\n\t\t\t  EMONREPEAT_ENDLESS | EMONREPEAT_PERIOD,\n\t\t\t  EMONREPEAT_ENDLESS | EMONREPEAT_PERIOD_1000000);\n\n\t \n\tregmap_write_bits(map, tdev->data->map_base + PVTCTLSEL,\n\t\t\t  PVTCTLSEL_MASK, PVTCTLSEL_MONITOR);\n\n\treturn 0;\n}\n\nstatic void uniphier_tm_set_alert(struct uniphier_tm_dev *tdev, u32 ch,\n\t\t\t\t  u32 temp)\n{\n\tstruct regmap *map = tdev->regmap;\n\n\t \n\tregmap_write_bits(map, tdev->data->map_base + SETALERT0 + (ch << 2),\n\t\t\t  SETALERT_EN | SETALERT_TEMP_OVF,\n\t\t\t  SETALERT_EN |\n\t\t\t  SETALERT_TEMP_OVF_VALUE(temp / 1000));\n}\n\nstatic void uniphier_tm_enable_sensor(struct uniphier_tm_dev *tdev)\n{\n\tstruct regmap *map = tdev->regmap;\n\tint i;\n\tu32 bits = 0;\n\n\tfor (i = 0; i < ALERT_CH_NUM; i++)\n\t\tif (tdev->alert_en[i])\n\t\t\tbits |= PMALERTINTCTL_EN(i);\n\n\t \n\tregmap_write_bits(map, tdev->data->map_base + PMALERTINTCTL,\n\t\t\t  PMALERTINTCTL_MASK, bits);\n\n\t \n\tregmap_write_bits(map, tdev->data->block_base + PVTCTLEN,\n\t\t\t  PVTCTLEN_EN, PVTCTLEN_EN);\n\n\tusleep_range(700, 1500);\t \n}\n\nstatic void uniphier_tm_disable_sensor(struct uniphier_tm_dev *tdev)\n{\n\tstruct regmap *map = tdev->regmap;\n\n\t \n\tregmap_write_bits(map, tdev->data->map_base + PMALERTINTCTL,\n\t\t\t  PMALERTINTCTL_MASK, 0);\n\n\t \n\tregmap_write_bits(map, tdev->data->block_base + PVTCTLEN,\n\t\t\t  PVTCTLEN_EN, 0);\n\n\tusleep_range(1000, 2000);\t \n}\n\nstatic int uniphier_tm_get_temp(struct thermal_zone_device *tz, int *out_temp)\n{\n\tstruct uniphier_tm_dev *tdev = thermal_zone_device_priv(tz);\n\tstruct regmap *map = tdev->regmap;\n\tint ret;\n\tu32 temp;\n\n\tret = regmap_read(map, tdev->data->map_base + TMOD, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*out_temp = sign_extend32(temp, TMOD_WIDTH - 1) * 1000;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops uniphier_of_thermal_ops = {\n\t.get_temp = uniphier_tm_get_temp,\n};\n\nstatic void uniphier_tm_irq_clear(struct uniphier_tm_dev *tdev)\n{\n\tu32 mask = 0, bits = 0;\n\tint i;\n\n\tfor (i = 0; i < ALERT_CH_NUM; i++) {\n\t\tmask |= (PMALERTINTCTL_CLR(i) | PMALERTINTCTL_SET(i));\n\t\tbits |= PMALERTINTCTL_CLR(i);\n\t}\n\n\t \n\tregmap_write_bits(tdev->regmap,\n\t\t\t  tdev->data->map_base + PMALERTINTCTL, mask, bits);\n}\n\nstatic irqreturn_t uniphier_tm_alarm_irq(int irq, void *_tdev)\n{\n\tstruct uniphier_tm_dev *tdev = _tdev;\n\n\tdisable_irq_nosync(irq);\n\tuniphier_tm_irq_clear(tdev);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t uniphier_tm_alarm_irq_thread(int irq, void *_tdev)\n{\n\tstruct uniphier_tm_dev *tdev = _tdev;\n\n\tthermal_zone_device_update(tdev->tz_dev, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int uniphier_tm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tstruct device_node *parent;\n\tstruct uniphier_tm_dev *tdev;\n\tint i, ret, irq, crit_temp = INT_MAX;\n\n\ttdev = devm_kzalloc(dev, sizeof(*tdev), GFP_KERNEL);\n\tif (!tdev)\n\t\treturn -ENOMEM;\n\ttdev->dev = dev;\n\n\ttdev->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!tdev->data))\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tparent = of_get_parent(dev->of_node);  \n\tregmap = syscon_node_to_regmap(parent);\n\tof_node_put(parent);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to get regmap (error %ld)\\n\",\n\t\t\tPTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\ttdev->regmap = regmap;\n\n\tret = uniphier_tm_initialize_sensor(tdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize sensor\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, uniphier_tm_alarm_irq,\n\t\t\t\t\tuniphier_tm_alarm_irq_thread,\n\t\t\t\t\t0, \"thermal\", tdev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, tdev);\n\n\ttdev->tz_dev = devm_thermal_of_zone_register(dev, 0, tdev,\n\t\t\t\t\t\t     &uniphier_of_thermal_ops);\n\tif (IS_ERR(tdev->tz_dev)) {\n\t\tdev_err(dev, \"failed to register sensor device\\n\");\n\t\treturn PTR_ERR(tdev->tz_dev);\n\t}\n\n\t \n\tfor (i = 0; i < thermal_zone_get_num_trips(tdev->tz_dev); i++) {\n\t\tstruct thermal_trip trip;\n\n\t\tret = thermal_zone_get_trip(tdev->tz_dev, i, &trip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (trip.type == THERMAL_TRIP_CRITICAL &&\n\t\t    trip.temperature < crit_temp)\n\t\t\tcrit_temp = trip.temperature;\n\t\tuniphier_tm_set_alert(tdev, i, trip.temperature);\n\t\ttdev->alert_en[i] = true;\n\t}\n\tif (crit_temp > CRITICAL_TEMP_LIMIT) {\n\t\tdev_err(dev, \"critical trip is over limit(>%d), or not set\\n\",\n\t\t\tCRITICAL_TEMP_LIMIT);\n\t\treturn -EINVAL;\n\t}\n\n\tuniphier_tm_enable_sensor(tdev);\n\n\treturn 0;\n}\n\nstatic int uniphier_tm_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_tm_dev *tdev = platform_get_drvdata(pdev);\n\n\t \n\tuniphier_tm_disable_sensor(tdev);\n\n\treturn 0;\n}\n\nstatic const struct uniphier_tm_soc_data uniphier_pxs2_tm_data = {\n\t.map_base        = 0xe000,\n\t.block_base      = 0xe000,\n\t.tmod_setup_addr = 0xe904,\n};\n\nstatic const struct uniphier_tm_soc_data uniphier_ld20_tm_data = {\n\t.map_base        = 0xe000,\n\t.block_base      = 0xe800,\n\t.tmod_setup_addr = 0xe938,\n};\n\nstatic const struct of_device_id uniphier_tm_dt_ids[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-thermal\",\n\t\t.data       = &uniphier_pxs2_tm_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-thermal\",\n\t\t.data       = &uniphier_ld20_tm_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-thermal\",\n\t\t.data       = &uniphier_ld20_tm_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-thermal\",\n\t\t.data       = &uniphier_ld20_tm_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_tm_dt_ids);\n\nstatic struct platform_driver uniphier_tm_driver = {\n\t.probe = uniphier_tm_probe,\n\t.remove = uniphier_tm_remove,\n\t.driver = {\n\t\t.name = \"uniphier-thermal\",\n\t\t.of_match_table = uniphier_tm_dt_ids,\n\t},\n};\nmodule_platform_driver(uniphier_tm_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier thermal driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}