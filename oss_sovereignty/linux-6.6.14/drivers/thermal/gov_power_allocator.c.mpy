{
  "module_name": "gov_power_allocator.c",
  "hash_id": "6bfe6fe7a1653d23a2d94ee9cd03c22e9f88d5f3a2f3468ab4cef43698e8e454",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/gov_power_allocator.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"Power allocator: \" fmt\n\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#define CREATE_TRACE_POINTS\n#include \"thermal_trace_ipa.h\"\n\n#include \"thermal_core.h\"\n\n#define INVALID_TRIP -1\n\n#define FRAC_BITS 10\n#define int_to_frac(x) ((x) << FRAC_BITS)\n#define frac_to_int(x) ((x) >> FRAC_BITS)\n\n \nstatic inline s64 mul_frac(s64 x, s64 y)\n{\n\treturn (x * y) >> FRAC_BITS;\n}\n\n \nstatic inline s64 div_frac(s64 x, s64 y)\n{\n\treturn div_s64(x << FRAC_BITS, y);\n}\n\n \nstruct power_allocator_params {\n\tbool allocated_tzp;\n\ts64 err_integral;\n\ts32 prev_err;\n\tint trip_switch_on;\n\tint trip_max_desired_temperature;\n\tu32 sustainable_power;\n};\n\n \nstatic u32 estimate_sustainable_power(struct thermal_zone_device *tz)\n{\n\tu32 sustainable_power = 0;\n\tstruct thermal_instance *instance;\n\tstruct power_allocator_params *params = tz->governor_data;\n\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tstruct thermal_cooling_device *cdev = instance->cdev;\n\t\tu32 min_power;\n\n\t\tif (instance->trip != params->trip_max_desired_temperature)\n\t\t\tcontinue;\n\n\t\tif (!cdev_is_power_actor(cdev))\n\t\t\tcontinue;\n\n\t\tif (cdev->ops->state2power(cdev, instance->upper, &min_power))\n\t\t\tcontinue;\n\n\t\tsustainable_power += min_power;\n\t}\n\n\treturn sustainable_power;\n}\n\n \nstatic void estimate_pid_constants(struct thermal_zone_device *tz,\n\t\t\t\t   u32 sustainable_power, int trip_switch_on,\n\t\t\t\t   int control_temp)\n{\n\tstruct thermal_trip trip;\n\tu32 temperature_threshold = control_temp;\n\tint ret;\n\ts32 k_i;\n\n\tret = __thermal_zone_get_trip(tz, trip_switch_on, &trip);\n\tif (!ret)\n\t\ttemperature_threshold -= trip.temperature;\n\n\t \n\tif (!temperature_threshold)\n\t\treturn;\n\n\ttz->tzp->k_po = int_to_frac(sustainable_power) /\n\t\ttemperature_threshold;\n\n\ttz->tzp->k_pu = int_to_frac(2 * sustainable_power) /\n\t\ttemperature_threshold;\n\n\tk_i = tz->tzp->k_pu / 10;\n\ttz->tzp->k_i = k_i > 0 ? k_i : 1;\n\n\t \n}\n\n \nstatic u32 get_sustainable_power(struct thermal_zone_device *tz,\n\t\t\t\t struct power_allocator_params *params,\n\t\t\t\t int control_temp)\n{\n\tu32 sustainable_power;\n\n\tif (!tz->tzp->sustainable_power)\n\t\tsustainable_power = estimate_sustainable_power(tz);\n\telse\n\t\tsustainable_power = tz->tzp->sustainable_power;\n\n\t \n\tif (sustainable_power != params->sustainable_power) {\n\t\testimate_pid_constants(tz, sustainable_power,\n\t\t\t\t       params->trip_switch_on, control_temp);\n\n\t\t \n\t\ttz->tzp->sustainable_power = sustainable_power;\n\t\tparams->sustainable_power = sustainable_power;\n\t}\n\n\treturn sustainable_power;\n}\n\n \nstatic u32 pid_controller(struct thermal_zone_device *tz,\n\t\t\t  int control_temp,\n\t\t\t  u32 max_allocatable_power)\n{\n\ts64 p, i, d, power_range;\n\ts32 err, max_power_frac;\n\tu32 sustainable_power;\n\tstruct power_allocator_params *params = tz->governor_data;\n\n\tmax_power_frac = int_to_frac(max_allocatable_power);\n\n\tsustainable_power = get_sustainable_power(tz, params, control_temp);\n\n\terr = control_temp - tz->temperature;\n\terr = int_to_frac(err);\n\n\t \n\tp = mul_frac(err < 0 ? tz->tzp->k_po : tz->tzp->k_pu, err);\n\n\t \n\ti = mul_frac(tz->tzp->k_i, params->err_integral);\n\n\tif (err < int_to_frac(tz->tzp->integral_cutoff)) {\n\t\ts64 i_next = i + mul_frac(tz->tzp->k_i, err);\n\n\t\tif (abs(i_next) < max_power_frac) {\n\t\t\ti = i_next;\n\t\t\tparams->err_integral += err;\n\t\t}\n\t}\n\n\t \n\td = mul_frac(tz->tzp->k_d, err - params->prev_err);\n\td = div_frac(d, jiffies_to_msecs(tz->passive_delay_jiffies));\n\tparams->prev_err = err;\n\n\tpower_range = p + i + d;\n\n\t \n\tpower_range = sustainable_power + frac_to_int(power_range);\n\n\tpower_range = clamp(power_range, (s64)0, (s64)max_allocatable_power);\n\n\ttrace_thermal_power_allocator_pid(tz, frac_to_int(err),\n\t\t\t\t\t  frac_to_int(params->err_integral),\n\t\t\t\t\t  frac_to_int(p), frac_to_int(i),\n\t\t\t\t\t  frac_to_int(d), power_range);\n\n\treturn power_range;\n}\n\n \nstatic int\npower_actor_set_power(struct thermal_cooling_device *cdev,\n\t\t      struct thermal_instance *instance, u32 power)\n{\n\tunsigned long state;\n\tint ret;\n\n\tret = cdev->ops->power2state(cdev, power, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tinstance->target = clamp_val(state, instance->lower, instance->upper);\n\tmutex_lock(&cdev->lock);\n\t__thermal_cdev_update(cdev);\n\tmutex_unlock(&cdev->lock);\n\n\treturn 0;\n}\n\n \nstatic void divvy_up_power(u32 *req_power, u32 *max_power, int num_actors,\n\t\t\t   u32 total_req_power, u32 power_range,\n\t\t\t   u32 *granted_power, u32 *extra_actor_power)\n{\n\tu32 extra_power, capped_extra_power;\n\tint i;\n\n\t \n\tif (!total_req_power)\n\t\ttotal_req_power = 1;\n\n\tcapped_extra_power = 0;\n\textra_power = 0;\n\tfor (i = 0; i < num_actors; i++) {\n\t\tu64 req_range = (u64)req_power[i] * power_range;\n\n\t\tgranted_power[i] = DIV_ROUND_CLOSEST_ULL(req_range,\n\t\t\t\t\t\t\t total_req_power);\n\n\t\tif (granted_power[i] > max_power[i]) {\n\t\t\textra_power += granted_power[i] - max_power[i];\n\t\t\tgranted_power[i] = max_power[i];\n\t\t}\n\n\t\textra_actor_power[i] = max_power[i] - granted_power[i];\n\t\tcapped_extra_power += extra_actor_power[i];\n\t}\n\n\tif (!extra_power)\n\t\treturn;\n\n\t \n\textra_power = min(extra_power, capped_extra_power);\n\tif (capped_extra_power > 0)\n\t\tfor (i = 0; i < num_actors; i++) {\n\t\t\tu64 extra_range = (u64)extra_actor_power[i] * extra_power;\n\t\t\tgranted_power[i] += DIV_ROUND_CLOSEST_ULL(extra_range,\n\t\t\t\t\t\t\t capped_extra_power);\n\t\t}\n}\n\nstatic int allocate_power(struct thermal_zone_device *tz,\n\t\t\t  int control_temp)\n{\n\tstruct thermal_instance *instance;\n\tstruct power_allocator_params *params = tz->governor_data;\n\tu32 *req_power, *max_power, *granted_power, *extra_actor_power;\n\tu32 *weighted_req_power;\n\tu32 total_req_power, max_allocatable_power, total_weighted_req_power;\n\tu32 total_granted_power, power_range;\n\tint i, num_actors, total_weight, ret = 0;\n\tint trip_max_desired_temperature = params->trip_max_desired_temperature;\n\n\tnum_actors = 0;\n\ttotal_weight = 0;\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tif ((instance->trip == trip_max_desired_temperature) &&\n\t\t    cdev_is_power_actor(instance->cdev)) {\n\t\t\tnum_actors++;\n\t\t\ttotal_weight += instance->weight;\n\t\t}\n\t}\n\n\tif (!num_actors)\n\t\treturn -ENODEV;\n\n\t \n\tBUILD_BUG_ON(sizeof(*req_power) != sizeof(*max_power));\n\tBUILD_BUG_ON(sizeof(*req_power) != sizeof(*granted_power));\n\tBUILD_BUG_ON(sizeof(*req_power) != sizeof(*extra_actor_power));\n\tBUILD_BUG_ON(sizeof(*req_power) != sizeof(*weighted_req_power));\n\treq_power = kcalloc(num_actors * 5, sizeof(*req_power), GFP_KERNEL);\n\tif (!req_power)\n\t\treturn -ENOMEM;\n\n\tmax_power = &req_power[num_actors];\n\tgranted_power = &req_power[2 * num_actors];\n\textra_actor_power = &req_power[3 * num_actors];\n\tweighted_req_power = &req_power[4 * num_actors];\n\n\ti = 0;\n\ttotal_weighted_req_power = 0;\n\ttotal_req_power = 0;\n\tmax_allocatable_power = 0;\n\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tint weight;\n\t\tstruct thermal_cooling_device *cdev = instance->cdev;\n\n\t\tif (instance->trip != trip_max_desired_temperature)\n\t\t\tcontinue;\n\n\t\tif (!cdev_is_power_actor(cdev))\n\t\t\tcontinue;\n\n\t\tif (cdev->ops->get_requested_power(cdev, &req_power[i]))\n\t\t\tcontinue;\n\n\t\tif (!total_weight)\n\t\t\tweight = 1 << FRAC_BITS;\n\t\telse\n\t\t\tweight = instance->weight;\n\n\t\tweighted_req_power[i] = frac_to_int(weight * req_power[i]);\n\n\t\tif (cdev->ops->state2power(cdev, instance->lower,\n\t\t\t\t\t   &max_power[i]))\n\t\t\tcontinue;\n\n\t\ttotal_req_power += req_power[i];\n\t\tmax_allocatable_power += max_power[i];\n\t\ttotal_weighted_req_power += weighted_req_power[i];\n\n\t\ti++;\n\t}\n\n\tpower_range = pid_controller(tz, control_temp, max_allocatable_power);\n\n\tdivvy_up_power(weighted_req_power, max_power, num_actors,\n\t\t       total_weighted_req_power, power_range, granted_power,\n\t\t       extra_actor_power);\n\n\ttotal_granted_power = 0;\n\ti = 0;\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tif (instance->trip != trip_max_desired_temperature)\n\t\t\tcontinue;\n\n\t\tif (!cdev_is_power_actor(instance->cdev))\n\t\t\tcontinue;\n\n\t\tpower_actor_set_power(instance->cdev, instance,\n\t\t\t\t      granted_power[i]);\n\t\ttotal_granted_power += granted_power[i];\n\n\t\ti++;\n\t}\n\n\ttrace_thermal_power_allocator(tz, req_power, total_req_power,\n\t\t\t\t      granted_power, total_granted_power,\n\t\t\t\t      num_actors, power_range,\n\t\t\t\t      max_allocatable_power, tz->temperature,\n\t\t\t\t      control_temp - tz->temperature);\n\n\tkfree(req_power);\n\n\treturn ret;\n}\n\n \nstatic void get_governor_trips(struct thermal_zone_device *tz,\n\t\t\t       struct power_allocator_params *params)\n{\n\tint i, last_active, last_passive;\n\tbool found_first_passive;\n\n\tfound_first_passive = false;\n\tlast_active = INVALID_TRIP;\n\tlast_passive = INVALID_TRIP;\n\n\tfor (i = 0; i < tz->num_trips; i++) {\n\t\tstruct thermal_trip trip;\n\t\tint ret;\n\n\t\tret = __thermal_zone_get_trip(tz, i, &trip);\n\t\tif (ret) {\n\t\t\tdev_warn(&tz->device,\n\t\t\t\t \"Failed to get trip point %d type: %d\\n\", i,\n\t\t\t\t ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (trip.type == THERMAL_TRIP_PASSIVE) {\n\t\t\tif (!found_first_passive) {\n\t\t\t\tparams->trip_switch_on = i;\n\t\t\t\tfound_first_passive = true;\n\t\t\t} else  {\n\t\t\t\tlast_passive = i;\n\t\t\t}\n\t\t} else if (trip.type == THERMAL_TRIP_ACTIVE) {\n\t\t\tlast_active = i;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (last_passive != INVALID_TRIP) {\n\t\tparams->trip_max_desired_temperature = last_passive;\n\t} else if (found_first_passive) {\n\t\tparams->trip_max_desired_temperature = params->trip_switch_on;\n\t\tparams->trip_switch_on = INVALID_TRIP;\n\t} else {\n\t\tparams->trip_switch_on = INVALID_TRIP;\n\t\tparams->trip_max_desired_temperature = last_active;\n\t}\n}\n\nstatic void reset_pid_controller(struct power_allocator_params *params)\n{\n\tparams->err_integral = 0;\n\tparams->prev_err = 0;\n}\n\nstatic void allow_maximum_power(struct thermal_zone_device *tz, bool update)\n{\n\tstruct thermal_instance *instance;\n\tstruct power_allocator_params *params = tz->governor_data;\n\tu32 req_power;\n\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tstruct thermal_cooling_device *cdev = instance->cdev;\n\n\t\tif ((instance->trip != params->trip_max_desired_temperature) ||\n\t\t    (!cdev_is_power_actor(instance->cdev)))\n\t\t\tcontinue;\n\n\t\tinstance->target = 0;\n\t\tmutex_lock(&instance->cdev->lock);\n\t\t \n\t\tcdev->ops->get_requested_power(cdev, &req_power);\n\n\t\tif (update)\n\t\t\t__thermal_cdev_update(instance->cdev);\n\n\t\tmutex_unlock(&instance->cdev->lock);\n\t}\n}\n\n \nstatic int check_power_actors(struct thermal_zone_device *tz)\n{\n\tstruct thermal_instance *instance;\n\tint ret = 0;\n\n\tlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\n\t\tif (!cdev_is_power_actor(instance->cdev)) {\n\t\t\tdev_warn(&tz->device, \"power_allocator: %s is not a power actor\\n\",\n\t\t\t\t instance->cdev->type);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int power_allocator_bind(struct thermal_zone_device *tz)\n{\n\tint ret;\n\tstruct power_allocator_params *params;\n\tstruct thermal_trip trip;\n\n\tret = check_power_actors(tz);\n\tif (ret)\n\t\treturn ret;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tif (!tz->tzp) {\n\t\ttz->tzp = kzalloc(sizeof(*tz->tzp), GFP_KERNEL);\n\t\tif (!tz->tzp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_params;\n\t\t}\n\n\t\tparams->allocated_tzp = true;\n\t}\n\n\tif (!tz->tzp->sustainable_power)\n\t\tdev_warn(&tz->device, \"power_allocator: sustainable_power will be estimated\\n\");\n\n\tget_governor_trips(tz, params);\n\n\tif (tz->num_trips > 0) {\n\t\tret = __thermal_zone_get_trip(tz, params->trip_max_desired_temperature,\n\t\t\t\t\t      &trip);\n\t\tif (!ret)\n\t\t\testimate_pid_constants(tz, tz->tzp->sustainable_power,\n\t\t\t\t\t       params->trip_switch_on,\n\t\t\t\t\t       trip.temperature);\n\t}\n\n\treset_pid_controller(params);\n\n\ttz->governor_data = params;\n\n\treturn 0;\n\nfree_params:\n\tkfree(params);\n\n\treturn ret;\n}\n\nstatic void power_allocator_unbind(struct thermal_zone_device *tz)\n{\n\tstruct power_allocator_params *params = tz->governor_data;\n\n\tdev_dbg(&tz->device, \"Unbinding from thermal zone %d\\n\", tz->id);\n\n\tif (params->allocated_tzp) {\n\t\tkfree(tz->tzp);\n\t\ttz->tzp = NULL;\n\t}\n\n\tkfree(tz->governor_data);\n\ttz->governor_data = NULL;\n}\n\nstatic int power_allocator_throttle(struct thermal_zone_device *tz, int trip_id)\n{\n\tstruct power_allocator_params *params = tz->governor_data;\n\tstruct thermal_trip trip;\n\tint ret;\n\tbool update;\n\n\tlockdep_assert_held(&tz->lock);\n\n\t \n\tif (trip_id != params->trip_max_desired_temperature)\n\t\treturn 0;\n\n\tret = __thermal_zone_get_trip(tz, params->trip_switch_on, &trip);\n\tif (!ret && (tz->temperature < trip.temperature)) {\n\t\tupdate = (tz->last_temperature >= trip.temperature);\n\t\ttz->passive = 0;\n\t\treset_pid_controller(params);\n\t\tallow_maximum_power(tz, update);\n\t\treturn 0;\n\t}\n\n\ttz->passive = 1;\n\n\tret = __thermal_zone_get_trip(tz, params->trip_max_desired_temperature, &trip);\n\tif (ret) {\n\t\tdev_warn(&tz->device, \"Failed to get the maximum desired temperature: %d\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\treturn allocate_power(tz, trip.temperature);\n}\n\nstatic struct thermal_governor thermal_gov_power_allocator = {\n\t.name\t\t= \"power_allocator\",\n\t.bind_to_tz\t= power_allocator_bind,\n\t.unbind_from_tz\t= power_allocator_unbind,\n\t.throttle\t= power_allocator_throttle,\n};\nTHERMAL_GOVERNOR_DECLARE(thermal_gov_power_allocator);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}