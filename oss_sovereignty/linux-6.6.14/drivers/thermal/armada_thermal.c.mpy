{
  "module_name": "armada_thermal.c",
  "hash_id": "bf593464e460878cc40852fd48468021520be8cad58159bf2592ed45154393b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/armada_thermal.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <linux/thermal.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/interrupt.h>\n\n \n#define PMU_TDC0_SW_RST_MASK\t\t(0x1 << 1)\n#define PMU_TM_DISABLE_OFFS\t\t0\n#define PMU_TM_DISABLE_MASK\t\t(0x1 << PMU_TM_DISABLE_OFFS)\n#define PMU_TDC0_REF_CAL_CNT_OFFS\t11\n#define PMU_TDC0_REF_CAL_CNT_MASK\t(0x1ff << PMU_TDC0_REF_CAL_CNT_OFFS)\n#define PMU_TDC0_OTF_CAL_MASK\t\t(0x1 << 30)\n#define PMU_TDC0_START_CAL_MASK\t\t(0x1 << 25)\n\n#define A375_UNIT_CONTROL_SHIFT\t\t27\n#define A375_UNIT_CONTROL_MASK\t\t0x7\n#define A375_READOUT_INVERT\t\tBIT(15)\n#define A375_HW_RESETn\t\t\tBIT(8)\n\n \n#define CONTROL0_TSEN_TC_TRIM_MASK\t0x7\n#define CONTROL0_TSEN_TC_TRIM_VAL\t0x3\n\n#define CONTROL0_TSEN_START\t\tBIT(0)\n#define CONTROL0_TSEN_RESET\t\tBIT(1)\n#define CONTROL0_TSEN_ENABLE\t\tBIT(2)\n#define CONTROL0_TSEN_AVG_BYPASS\tBIT(6)\n#define CONTROL0_TSEN_CHAN_SHIFT\t13\n#define CONTROL0_TSEN_CHAN_MASK\t\t0xF\n#define CONTROL0_TSEN_OSR_SHIFT\t\t24\n#define CONTROL0_TSEN_OSR_MAX\t\t0x3\n#define CONTROL0_TSEN_MODE_SHIFT\t30\n#define CONTROL0_TSEN_MODE_EXTERNAL\t0x2\n#define CONTROL0_TSEN_MODE_MASK\t\t0x3\n\n#define CONTROL1_TSEN_AVG_MASK\t\t0x7\n#define CONTROL1_EXT_TSEN_SW_RESET\tBIT(7)\n#define CONTROL1_EXT_TSEN_HW_RESETn\tBIT(8)\n#define CONTROL1_TSEN_INT_EN\t\tBIT(25)\n#define CONTROL1_TSEN_SELECT_OFF\t21\n#define CONTROL1_TSEN_SELECT_MASK\t0x3\n\n#define STATUS_POLL_PERIOD_US\t\t1000\n#define STATUS_POLL_TIMEOUT_US\t\t100000\n#define OVERHEAT_INT_POLL_DELAY_MS\t1000\n\nstruct armada_thermal_data;\n\n \nstruct armada_thermal_priv {\n\tstruct device *dev;\n\tstruct regmap *syscon;\n\tchar zone_name[THERMAL_NAME_LENGTH];\n\t \n\tstruct mutex update_lock;\n\tstruct armada_thermal_data *data;\n\tstruct thermal_zone_device *overheat_sensor;\n\tint interrupt_source;\n\tint current_channel;\n\tlong current_threshold;\n\tlong current_hysteresis;\n};\n\nstruct armada_thermal_data {\n\t \n\tvoid (*init)(struct platform_device *pdev,\n\t\t     struct armada_thermal_priv *priv);\n\n\t \n\ts64 coef_b;\n\ts64 coef_m;\n\tu32 coef_div;\n\tbool inverted;\n\tbool signed_sample;\n\n\t \n\tunsigned int temp_shift;\n\tunsigned int temp_mask;\n\tunsigned int thresh_shift;\n\tunsigned int hyst_shift;\n\tunsigned int hyst_mask;\n\tu32 is_valid_bit;\n\n\t \n\tunsigned int syscon_control0_off;\n\tunsigned int syscon_control1_off;\n\tunsigned int syscon_status_off;\n\tunsigned int dfx_irq_cause_off;\n\tunsigned int dfx_irq_mask_off;\n\tunsigned int dfx_overheat_irq;\n\tunsigned int dfx_server_irq_mask_off;\n\tunsigned int dfx_server_irq_en;\n\n\t \n\tunsigned int cpu_nr;\n};\n\nstruct armada_drvdata {\n\tenum drvtype {\n\t\tLEGACY,\n\t\tSYSCON\n\t} type;\n\tunion {\n\t\tstruct armada_thermal_priv *priv;\n\t\tstruct thermal_zone_device *tz;\n\t} data;\n};\n\n \nstruct armada_thermal_sensor {\n\tstruct armada_thermal_priv *priv;\n\tint id;\n};\n\nstatic void armadaxp_init(struct platform_device *pdev,\n\t\t\t  struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg |= PMU_TDC0_OTF_CAL_MASK;\n\n\t \n\treg &= ~PMU_TDC0_REF_CAL_CNT_MASK;\n\treg |= (0xf1 << PMU_TDC0_REF_CAL_CNT_OFFS);\n\n\t \n\treg |= PMU_TDC0_SW_RST_MASK;\n\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n\n\treg &= ~PMU_TDC0_SW_RST_MASK;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n\n\t \n\tregmap_read(priv->syscon, data->syscon_status_off, &reg);\n\treg &= ~PMU_TM_DISABLE_MASK;\n\tregmap_write(priv->syscon, data->syscon_status_off, reg);\n}\n\nstatic void armada370_init(struct platform_device *pdev,\n\t\t\t   struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg |= PMU_TDC0_OTF_CAL_MASK;\n\n\t \n\treg &= ~PMU_TDC0_REF_CAL_CNT_MASK;\n\treg |= (0xf1 << PMU_TDC0_REF_CAL_CNT_OFFS);\n\n\t \n\treg &= ~PMU_TDC0_START_CAL_MASK;\n\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n\n\tmsleep(10);\n}\n\nstatic void armada375_init(struct platform_device *pdev,\n\t\t\t   struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg &= ~(A375_UNIT_CONTROL_MASK << A375_UNIT_CONTROL_SHIFT);\n\treg &= ~A375_READOUT_INVERT;\n\treg &= ~A375_HW_RESETn;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n\n\tmsleep(20);\n\n\treg |= A375_HW_RESETn;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n\n\tmsleep(50);\n}\n\nstatic int armada_wait_sensor_validity(struct armada_thermal_priv *priv)\n{\n\tu32 reg;\n\n\treturn regmap_read_poll_timeout(priv->syscon,\n\t\t\t\t\tpriv->data->syscon_status_off, reg,\n\t\t\t\t\treg & priv->data->is_valid_bit,\n\t\t\t\t\tSTATUS_POLL_PERIOD_US,\n\t\t\t\t\tSTATUS_POLL_TIMEOUT_US);\n}\n\nstatic void armada380_init(struct platform_device *pdev,\n\t\t\t   struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\t \n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg |= CONTROL1_EXT_TSEN_HW_RESETn;\n\treg &= ~CONTROL1_EXT_TSEN_SW_RESET;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n\n\t \n\tregmap_read(priv->syscon, data->syscon_control0_off, &reg);\n\treg &= ~CONTROL0_TSEN_TC_TRIM_MASK;\n\treg |= CONTROL0_TSEN_TC_TRIM_VAL;\n\tregmap_write(priv->syscon, data->syscon_control0_off, reg);\n}\n\nstatic void armada_ap80x_init(struct platform_device *pdev,\n\t\t\t      struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\tregmap_read(priv->syscon, data->syscon_control0_off, &reg);\n\treg &= ~CONTROL0_TSEN_RESET;\n\treg |= CONTROL0_TSEN_START | CONTROL0_TSEN_ENABLE;\n\n\t \n\treg |= CONTROL0_TSEN_OSR_MAX << CONTROL0_TSEN_OSR_SHIFT;\n\n\t \n\treg &= ~CONTROL0_TSEN_AVG_BYPASS;\n\n\tregmap_write(priv->syscon, data->syscon_control0_off, reg);\n}\n\nstatic void armada_cp110_init(struct platform_device *pdev,\n\t\t\t      struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\tarmada380_init(pdev, priv);\n\n\t \n\tregmap_read(priv->syscon, data->syscon_control0_off, &reg);\n\treg |= CONTROL0_TSEN_OSR_MAX << CONTROL0_TSEN_OSR_SHIFT;\n\tregmap_write(priv->syscon, data->syscon_control0_off, reg);\n\n\t \n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg &= ~CONTROL1_TSEN_AVG_MASK;\n\treg |= 1;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n}\n\nstatic bool armada_is_valid(struct armada_thermal_priv *priv)\n{\n\tu32 reg;\n\n\tif (!priv->data->is_valid_bit)\n\t\treturn true;\n\n\tregmap_read(priv->syscon, priv->data->syscon_status_off, &reg);\n\n\treturn reg & priv->data->is_valid_bit;\n}\n\nstatic void armada_enable_overheat_interrupt(struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\t \n\tregmap_read(priv->syscon, data->dfx_irq_cause_off, &reg);\n\n\t \n\tregmap_read(priv->syscon, data->dfx_irq_mask_off, &reg);\n\treg |= data->dfx_overheat_irq;\n\tregmap_write(priv->syscon, data->dfx_irq_mask_off, reg);\n\n\t \n\tregmap_read(priv->syscon, data->dfx_server_irq_mask_off, &reg);\n\treg |= data->dfx_server_irq_en;\n\tregmap_write(priv->syscon, data->dfx_server_irq_mask_off, reg);\n\n\t \n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg |= CONTROL1_TSEN_INT_EN;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n}\n\nstatic void __maybe_unused\narmada_disable_overheat_interrupt(struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 reg;\n\n\tregmap_read(priv->syscon, data->syscon_control1_off, &reg);\n\treg &= ~CONTROL1_TSEN_INT_EN;\n\tregmap_write(priv->syscon, data->syscon_control1_off, reg);\n}\n\n \nstatic int armada_select_channel(struct armada_thermal_priv *priv, int channel)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tu32 ctrl0;\n\n\tif (channel < 0 || channel > priv->data->cpu_nr)\n\t\treturn -EINVAL;\n\n\tif (priv->current_channel == channel)\n\t\treturn 0;\n\n\t \n\tregmap_read(priv->syscon, data->syscon_control0_off, &ctrl0);\n\tctrl0 &= ~CONTROL0_TSEN_START;\n\tregmap_write(priv->syscon, data->syscon_control0_off, ctrl0);\n\n\t \n\tctrl0 &= ~(CONTROL0_TSEN_MODE_MASK << CONTROL0_TSEN_MODE_SHIFT);\n\n\t \n\tif (channel) {\n\t\t \n\t\tctrl0 |= CONTROL0_TSEN_MODE_EXTERNAL <<\n\t\t\t CONTROL0_TSEN_MODE_SHIFT;\n\t\t \n\t\tctrl0 &= ~(CONTROL0_TSEN_CHAN_MASK << CONTROL0_TSEN_CHAN_SHIFT);\n\t\tctrl0 |= (channel - 1) << CONTROL0_TSEN_CHAN_SHIFT;\n\t}\n\n\t \n\tregmap_write(priv->syscon, data->syscon_control0_off, ctrl0);\n\tpriv->current_channel = channel;\n\n\t \n\tctrl0 |= CONTROL0_TSEN_START;\n\tregmap_write(priv->syscon, data->syscon_control0_off, ctrl0);\n\n\t \n\tif (armada_wait_sensor_validity(priv))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int armada_read_sensor(struct armada_thermal_priv *priv, int *temp)\n{\n\tu32 reg, div;\n\ts64 sample, b, m;\n\n\tregmap_read(priv->syscon, priv->data->syscon_status_off, &reg);\n\treg = (reg >> priv->data->temp_shift) & priv->data->temp_mask;\n\tif (priv->data->signed_sample)\n\t\t \n\t\tsample = sign_extend32(reg, fls(priv->data->temp_mask) - 1);\n\telse\n\t\tsample = reg;\n\n\t \n\tb = priv->data->coef_b;\n\tm = priv->data->coef_m;\n\tdiv = priv->data->coef_div;\n\n\tif (priv->data->inverted)\n\t\t*temp = div_s64((m * sample) - b, div);\n\telse\n\t\t*temp = div_s64(b - (m * sample), div);\n\n\treturn 0;\n}\n\nstatic int armada_get_temp_legacy(struct thermal_zone_device *thermal,\n\t\t\t\t  int *temp)\n{\n\tstruct armada_thermal_priv *priv = thermal_zone_device_priv(thermal);\n\tint ret;\n\n\t \n\tif (!armada_is_valid(priv))\n\t\treturn -EIO;\n\n\t \n\tret = armada_read_sensor(priv, temp);\n\n\treturn ret;\n}\n\nstatic struct thermal_zone_device_ops legacy_ops = {\n\t.get_temp = armada_get_temp_legacy,\n};\n\nstatic int armada_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct armada_thermal_sensor *sensor = thermal_zone_device_priv(tz);\n\tstruct armada_thermal_priv *priv = sensor->priv;\n\tint ret;\n\n\tmutex_lock(&priv->update_lock);\n\n\t \n\tret = armada_select_channel(priv, sensor->id);\n\tif (ret)\n\t\tgoto unlock_mutex;\n\n\t \n\tret = armada_read_sensor(priv, temp);\n\tif (ret)\n\t\tgoto unlock_mutex;\n\n\t \n\tret = armada_select_channel(priv, priv->interrupt_source);\n\nunlock_mutex:\n\tmutex_unlock(&priv->update_lock);\n\n\treturn ret;\n}\n\nstatic const struct thermal_zone_device_ops of_ops = {\n\t.get_temp = armada_get_temp,\n};\n\nstatic unsigned int armada_mc_to_reg_temp(struct armada_thermal_data *data,\n\t\t\t\t\t  unsigned int temp_mc)\n{\n\ts64 b = data->coef_b;\n\ts64 m = data->coef_m;\n\ts64 div = data->coef_div;\n\tunsigned int sample;\n\n\tif (data->inverted)\n\t\tsample = div_s64(((temp_mc * div) + b), m);\n\telse\n\t\tsample = div_s64((b - (temp_mc * div)), m);\n\n\treturn sample & data->temp_mask;\n}\n\n \nstatic unsigned int hyst_levels_mc[] = {1900, 3800, 7600, 15200};\n\nstatic unsigned int armada_mc_to_reg_hyst(struct armada_thermal_data *data,\n\t\t\t\t\t  unsigned int hyst_mc)\n{\n\tint i;\n\n\t \n\tfor (i = ARRAY_SIZE(hyst_levels_mc) - 1; i > 0; i--)\n\t\tif (hyst_mc >= hyst_levels_mc[i])\n\t\t\tbreak;\n\n\treturn i & data->hyst_mask;\n}\n\nstatic void armada_set_overheat_thresholds(struct armada_thermal_priv *priv,\n\t\t\t\t\t   int thresh_mc, int hyst_mc)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tunsigned int threshold = armada_mc_to_reg_temp(data, thresh_mc);\n\tunsigned int hysteresis = armada_mc_to_reg_hyst(data, hyst_mc);\n\tu32 ctrl1;\n\n\tregmap_read(priv->syscon, data->syscon_control1_off, &ctrl1);\n\n\t \n\tif (thresh_mc >= 0) {\n\t\tctrl1 &= ~(data->temp_mask << data->thresh_shift);\n\t\tctrl1 |= threshold << data->thresh_shift;\n\t\tpriv->current_threshold = thresh_mc;\n\t}\n\n\t \n\tif (hyst_mc >= 0) {\n\t\tctrl1 &= ~(data->hyst_mask << data->hyst_shift);\n\t\tctrl1 |= hysteresis << data->hyst_shift;\n\t\tpriv->current_hysteresis = hyst_mc;\n\t}\n\n\tregmap_write(priv->syscon, data->syscon_control1_off, ctrl1);\n}\n\nstatic irqreturn_t armada_overheat_isr(int irq, void *blob)\n{\n\t \n\tdisable_irq_nosync(irq);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t armada_overheat_isr_thread(int irq, void *blob)\n{\n\tstruct armada_thermal_priv *priv = blob;\n\tint low_threshold = priv->current_threshold - priv->current_hysteresis;\n\tint temperature;\n\tu32 dummy;\n\tint ret;\n\n\t \n\tthermal_zone_device_update(priv->overheat_sensor,\n\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\n\t \n\tdo {\n\t\tmsleep(OVERHEAT_INT_POLL_DELAY_MS);\n\t\tmutex_lock(&priv->update_lock);\n\t\tret = armada_read_sensor(priv, &temperature);\n\t\tmutex_unlock(&priv->update_lock);\n\t\tif (ret)\n\t\t\tgoto enable_irq;\n\t} while (temperature >= low_threshold);\n\n\tregmap_read(priv->syscon, priv->data->dfx_irq_cause_off, &dummy);\n\n\t \n\tthermal_zone_device_update(priv->overheat_sensor,\n\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\nenable_irq:\n\tenable_irq(irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct armada_thermal_data armadaxp_data = {\n\t.init = armadaxp_init,\n\t.temp_shift = 10,\n\t.temp_mask = 0x1ff,\n\t.coef_b = 3153000000ULL,\n\t.coef_m = 10000000ULL,\n\t.coef_div = 13825,\n\t.syscon_status_off = 0xb0,\n\t.syscon_control1_off = 0x2d0,\n};\n\nstatic const struct armada_thermal_data armada370_data = {\n\t.init = armada370_init,\n\t.is_valid_bit = BIT(9),\n\t.temp_shift = 10,\n\t.temp_mask = 0x1ff,\n\t.coef_b = 3153000000ULL,\n\t.coef_m = 10000000ULL,\n\t.coef_div = 13825,\n\t.syscon_status_off = 0x0,\n\t.syscon_control1_off = 0x4,\n};\n\nstatic const struct armada_thermal_data armada375_data = {\n\t.init = armada375_init,\n\t.is_valid_bit = BIT(10),\n\t.temp_shift = 0,\n\t.temp_mask = 0x1ff,\n\t.coef_b = 3171900000ULL,\n\t.coef_m = 10000000ULL,\n\t.coef_div = 13616,\n\t.syscon_status_off = 0x78,\n\t.syscon_control0_off = 0x7c,\n\t.syscon_control1_off = 0x80,\n};\n\nstatic const struct armada_thermal_data armada380_data = {\n\t.init = armada380_init,\n\t.is_valid_bit = BIT(10),\n\t.temp_shift = 0,\n\t.temp_mask = 0x3ff,\n\t.coef_b = 1172499100ULL,\n\t.coef_m = 2000096ULL,\n\t.coef_div = 4201,\n\t.inverted = true,\n\t.syscon_control0_off = 0x70,\n\t.syscon_control1_off = 0x74,\n\t.syscon_status_off = 0x78,\n};\n\nstatic const struct armada_thermal_data armada_ap806_data = {\n\t.init = armada_ap80x_init,\n\t.is_valid_bit = BIT(16),\n\t.temp_shift = 0,\n\t.temp_mask = 0x3ff,\n\t.thresh_shift = 3,\n\t.hyst_shift = 19,\n\t.hyst_mask = 0x3,\n\t.coef_b = -150000LL,\n\t.coef_m = 423ULL,\n\t.coef_div = 1,\n\t.inverted = true,\n\t.signed_sample = true,\n\t.syscon_control0_off = 0x84,\n\t.syscon_control1_off = 0x88,\n\t.syscon_status_off = 0x8C,\n\t.dfx_irq_cause_off = 0x108,\n\t.dfx_irq_mask_off = 0x10C,\n\t.dfx_overheat_irq = BIT(22),\n\t.dfx_server_irq_mask_off = 0x104,\n\t.dfx_server_irq_en = BIT(1),\n\t.cpu_nr = 4,\n};\n\nstatic const struct armada_thermal_data armada_ap807_data = {\n\t.init = armada_ap80x_init,\n\t.is_valid_bit = BIT(16),\n\t.temp_shift = 0,\n\t.temp_mask = 0x3ff,\n\t.thresh_shift = 3,\n\t.hyst_shift = 19,\n\t.hyst_mask = 0x3,\n\t.coef_b = -128900LL,\n\t.coef_m = 394ULL,\n\t.coef_div = 1,\n\t.inverted = true,\n\t.signed_sample = true,\n\t.syscon_control0_off = 0x84,\n\t.syscon_control1_off = 0x88,\n\t.syscon_status_off = 0x8C,\n\t.dfx_irq_cause_off = 0x108,\n\t.dfx_irq_mask_off = 0x10C,\n\t.dfx_overheat_irq = BIT(22),\n\t.dfx_server_irq_mask_off = 0x104,\n\t.dfx_server_irq_en = BIT(1),\n\t.cpu_nr = 4,\n};\n\nstatic const struct armada_thermal_data armada_cp110_data = {\n\t.init = armada_cp110_init,\n\t.is_valid_bit = BIT(10),\n\t.temp_shift = 0,\n\t.temp_mask = 0x3ff,\n\t.thresh_shift = 16,\n\t.hyst_shift = 26,\n\t.hyst_mask = 0x3,\n\t.coef_b = 1172499100ULL,\n\t.coef_m = 2000096ULL,\n\t.coef_div = 4201,\n\t.inverted = true,\n\t.syscon_control0_off = 0x70,\n\t.syscon_control1_off = 0x74,\n\t.syscon_status_off = 0x78,\n\t.dfx_irq_cause_off = 0x108,\n\t.dfx_irq_mask_off = 0x10C,\n\t.dfx_overheat_irq = BIT(20),\n\t.dfx_server_irq_mask_off = 0x104,\n\t.dfx_server_irq_en = BIT(1),\n};\n\nstatic const struct of_device_id armada_thermal_id_table[] = {\n\t{\n\t\t.compatible = \"marvell,armadaxp-thermal\",\n\t\t.data       = &armadaxp_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada370-thermal\",\n\t\t.data       = &armada370_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada375-thermal\",\n\t\t.data       = &armada375_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada380-thermal\",\n\t\t.data       = &armada380_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-ap806-thermal\",\n\t\t.data       = &armada_ap806_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-ap807-thermal\",\n\t\t.data       = &armada_ap807_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-cp110-thermal\",\n\t\t.data       = &armada_cp110_data,\n\t},\n\t{\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, armada_thermal_id_table);\n\nstatic const struct regmap_config armada_thermal_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n};\n\nstatic int armada_thermal_probe_legacy(struct platform_device *pdev,\n\t\t\t\t       struct armada_thermal_priv *priv)\n{\n\tstruct armada_thermal_data *data = priv->data;\n\tvoid __iomem *base;\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t \n\tif (((unsigned long)base & ~PAGE_MASK) < data->syscon_status_off)\n\t\treturn -EINVAL;\n\tbase -= data->syscon_status_off;\n\n\tpriv->syscon = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t     &armada_thermal_regmap_config);\n\treturn PTR_ERR_OR_ZERO(priv->syscon);\n}\n\nstatic int armada_thermal_probe_syscon(struct platform_device *pdev,\n\t\t\t\t       struct armada_thermal_priv *priv)\n{\n\tpriv->syscon = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\treturn PTR_ERR_OR_ZERO(priv->syscon);\n}\n\nstatic void armada_set_sane_name(struct platform_device *pdev,\n\t\t\t\t struct armada_thermal_priv *priv)\n{\n\tconst char *name = dev_name(&pdev->dev);\n\tchar *insane_char;\n\n\tif (strlen(name) > THERMAL_NAME_LENGTH) {\n\t\t \n\t\tname = strrchr(name, ':');\n\t\tif (!name)\n\t\t\tname = \"armada_thermal\";\n\t\telse\n\t\t\tname++;\n\t}\n\n\t \n\tstrscpy(priv->zone_name, name, THERMAL_NAME_LENGTH);\n\n\t \n\tdo {\n\t\tinsane_char = strpbrk(priv->zone_name, \"-\");\n\t\tif (insane_char)\n\t\t\t*insane_char = '_';\n\t} while (insane_char);\n}\n\n \nstatic int armada_configure_overheat_int(struct armada_thermal_priv *priv,\n\t\t\t\t\t struct thermal_zone_device *tz,\n\t\t\t\t\t int sensor_id)\n{\n\t \n\tint temperature;\n\tint ret;\n\n\tret = thermal_zone_get_crit_temp(tz, &temperature);\n\tif (ret)\n\t\treturn ret;\n\n\tret = armada_select_channel(priv, sensor_id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tarmada_set_overheat_thresholds(priv, temperature, 0);\n\tpriv->overheat_sensor = tz;\n\tpriv->interrupt_source = sensor_id;\n\tarmada_enable_overheat_interrupt(priv);\n\n\treturn 0;\n}\n\nstatic int armada_thermal_probe(struct platform_device *pdev)\n{\n\tstruct thermal_zone_device *tz;\n\tstruct armada_thermal_sensor *sensor;\n\tstruct armada_drvdata *drvdata;\n\tconst struct of_device_id *match;\n\tstruct armada_thermal_priv *priv;\n\tint sensor_id, irq;\n\tint ret;\n\n\tmatch = of_match_device(armada_thermal_id_table, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tpriv->data = (struct armada_thermal_data *)match->data;\n\n\tmutex_init(&priv->update_lock);\n\n\t \n\tif (IS_ERR(syscon_node_to_regmap(pdev->dev.parent->of_node))) {\n\t\t \n\t\tarmada_set_sane_name(pdev, priv);\n\n\t\tret = armada_thermal_probe_legacy(pdev, priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->data->init(pdev, priv);\n\n\t\t \n\t\tarmada_wait_sensor_validity(priv);\n\n\t\ttz = thermal_tripless_zone_device_register(priv->zone_name,\n\t\t\t\t\t\t\t   priv, &legacy_ops,\n\t\t\t\t\t\t\t   NULL);\n\t\tif (IS_ERR(tz)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to register thermal zone device\\n\");\n\t\t\treturn PTR_ERR(tz);\n\t\t}\n\n\t\tret = thermal_zone_device_enable(tz);\n\t\tif (ret) {\n\t\t\tthermal_zone_device_unregister(tz);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdrvdata->type = LEGACY;\n\t\tdrvdata->data.tz = tz;\n\t\tplatform_set_drvdata(pdev, drvdata);\n\n\t\treturn 0;\n\t}\n\n\tret = armada_thermal_probe_syscon(pdev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->current_channel = -1;\n\tpriv->data->init(pdev, priv);\n\tdrvdata->type = SYSCON;\n\tdrvdata->data.priv = priv;\n\tplatform_set_drvdata(pdev, drvdata);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq == -EPROBE_DEFER)\n\t\treturn irq;\n\n\t \n\tif (irq > 0) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\t\tarmada_overheat_isr,\n\t\t\t\t\t\tarmada_overheat_isr_thread,\n\t\t\t\t\t\t0, NULL, priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Cannot request threaded IRQ %d\\n\",\n\t\t\t\tirq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (sensor_id = 0; sensor_id <= priv->data->cpu_nr; sensor_id++) {\n\t\tsensor = devm_kzalloc(&pdev->dev,\n\t\t\t\t      sizeof(struct armada_thermal_sensor),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!sensor)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tsensor->priv = priv;\n\t\tsensor->id = sensor_id;\n\t\ttz = devm_thermal_of_zone_register(&pdev->dev,\n\t\t\t\t\t\t   sensor->id, sensor,\n\t\t\t\t\t\t   &of_ops);\n\t\tif (IS_ERR(tz)) {\n\t\t\tdev_info(&pdev->dev, \"Thermal sensor %d unavailable\\n\",\n\t\t\t\t sensor_id);\n\t\t\tdevm_kfree(&pdev->dev, sensor);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (irq > 0 && !priv->overheat_sensor)\n\t\t\tarmada_configure_overheat_int(priv, tz, sensor->id);\n\t}\n\n\t \n\tif (!priv->overheat_sensor)\n\t\tdev_warn(&pdev->dev, \"Overheat interrupt not available\\n\");\n\n\treturn 0;\n}\n\nstatic int armada_thermal_exit(struct platform_device *pdev)\n{\n\tstruct armada_drvdata *drvdata = platform_get_drvdata(pdev);\n\n\tif (drvdata->type == LEGACY)\n\t\tthermal_zone_device_unregister(drvdata->data.tz);\n\n\treturn 0;\n}\n\nstatic struct platform_driver armada_thermal_driver = {\n\t.probe = armada_thermal_probe,\n\t.remove = armada_thermal_exit,\n\t.driver = {\n\t\t.name = \"armada_thermal\",\n\t\t.of_match_table = armada_thermal_id_table,\n\t},\n};\n\nmodule_platform_driver(armada_thermal_driver);\n\nMODULE_AUTHOR(\"Ezequiel Garcia <ezequiel.garcia@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Marvell EBU Armada SoCs thermal driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}