{
  "module_name": "sun8i_thermal.c",
  "hash_id": "64fe48c2680d2719a19e595f8c0a0f314b78ec9c6b2d4b74cec65a161382b986",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/sun8i_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n\n#define MAX_SENSOR_NUM\t4\n\n#define FT_TEMP_MASK\t\t\t\tGENMASK(11, 0)\n#define TEMP_CALIB_MASK\t\t\t\tGENMASK(11, 0)\n#define CALIBRATE_DEFAULT\t\t\t0x800\n\n#define SUN8I_THS_CTRL0\t\t\t\t0x00\n#define SUN8I_THS_CTRL2\t\t\t\t0x40\n#define SUN8I_THS_IC\t\t\t\t0x44\n#define SUN8I_THS_IS\t\t\t\t0x48\n#define SUN8I_THS_MFC\t\t\t\t0x70\n#define SUN8I_THS_TEMP_CALIB\t\t\t0x74\n#define SUN8I_THS_TEMP_DATA\t\t\t0x80\n\n#define SUN50I_THS_CTRL0\t\t\t0x00\n#define SUN50I_H6_THS_ENABLE\t\t\t0x04\n#define SUN50I_H6_THS_PC\t\t\t0x08\n#define SUN50I_H6_THS_DIC\t\t\t0x10\n#define SUN50I_H6_THS_DIS\t\t\t0x20\n#define SUN50I_H6_THS_MFC\t\t\t0x30\n#define SUN50I_H6_THS_TEMP_CALIB\t\t0xa0\n#define SUN50I_H6_THS_TEMP_DATA\t\t\t0xc0\n\n#define SUN8I_THS_CTRL0_T_ACQ0(x)\t\t(GENMASK(15, 0) & (x))\n#define SUN8I_THS_CTRL2_T_ACQ1(x)\t\t((GENMASK(15, 0) & (x)) << 16)\n#define SUN8I_THS_DATA_IRQ_STS(x)\t\tBIT(x + 8)\n\n#define SUN50I_THS_CTRL0_T_ACQ(x)\t\t((GENMASK(15, 0) & (x)) << 16)\n#define SUN50I_THS_FILTER_EN\t\t\tBIT(2)\n#define SUN50I_THS_FILTER_TYPE(x)\t\t(GENMASK(1, 0) & (x))\n#define SUN50I_H6_THS_PC_TEMP_PERIOD(x)\t\t((GENMASK(19, 0) & (x)) << 12)\n#define SUN50I_H6_THS_DATA_IRQ_STS(x)\t\tBIT(x)\n\nstruct tsensor {\n\tstruct ths_device\t\t*tmdev;\n\tstruct thermal_zone_device\t*tzd;\n\tint\t\t\t\tid;\n};\n\nstruct ths_thermal_chip {\n\tbool            has_mod_clk;\n\tbool            has_bus_clk_reset;\n\tint\t\tsensor_num;\n\tint\t\toffset;\n\tint\t\tscale;\n\tint\t\tft_deviation;\n\tint\t\ttemp_data_base;\n\tint\t\t(*calibrate)(struct ths_device *tmdev,\n\t\t\t\t     u16 *caldata, int callen);\n\tint\t\t(*init)(struct ths_device *tmdev);\n\tunsigned long\t(*irq_ack)(struct ths_device *tmdev);\n\tint\t\t(*calc_temp)(struct ths_device *tmdev,\n\t\t\t\t     int id, int reg);\n};\n\nstruct ths_device {\n\tconst struct ths_thermal_chip\t\t*chip;\n\tstruct device\t\t\t\t*dev;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct reset_control\t\t\t*reset;\n\tstruct clk\t\t\t\t*bus_clk;\n\tstruct clk                              *mod_clk;\n\tstruct tsensor\t\t\t\tsensor[MAX_SENSOR_NUM];\n};\n\n \nstatic int sun8i_ths_calc_temp(struct ths_device *tmdev,\n\t\t\t       int id, int reg)\n{\n\treturn tmdev->chip->offset - (reg * tmdev->chip->scale / 10);\n}\n\nstatic int sun50i_h5_calc_temp(struct ths_device *tmdev,\n\t\t\t       int id, int reg)\n{\n\tif (reg >= 0x500)\n\t\treturn -1191 * reg / 10 + 223000;\n\telse if (!id)\n\t\treturn -1452 * reg / 10 + 259000;\n\telse\n\t\treturn -1590 * reg / 10 + 276000;\n}\n\nstatic int sun8i_ths_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct tsensor *s = thermal_zone_device_priv(tz);\n\tstruct ths_device *tmdev = s->tmdev;\n\tint val = 0;\n\n\tregmap_read(tmdev->regmap, tmdev->chip->temp_data_base +\n\t\t    0x4 * s->id, &val);\n\n\t \n\tif (!val)\n\t\treturn -EAGAIN;\n\n\t*temp = tmdev->chip->calc_temp(tmdev, s->id, val);\n\t \n\t*temp += tmdev->chip->ft_deviation;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops ths_ops = {\n\t.get_temp = sun8i_ths_get_temp,\n};\n\nstatic const struct regmap_config config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n\t.max_register = 0xfc,\n};\n\nstatic unsigned long sun8i_h3_irq_ack(struct ths_device *tmdev)\n{\n\tunsigned long irq_bitmap = 0;\n\tint i, state;\n\n\tregmap_read(tmdev->regmap, SUN8I_THS_IS, &state);\n\n\tfor (i = 0; i < tmdev->chip->sensor_num; i++) {\n\t\tif (state & SUN8I_THS_DATA_IRQ_STS(i)) {\n\t\t\tregmap_write(tmdev->regmap, SUN8I_THS_IS,\n\t\t\t\t     SUN8I_THS_DATA_IRQ_STS(i));\n\t\t\tbitmap_set(&irq_bitmap, i, 1);\n\t\t}\n\t}\n\n\treturn irq_bitmap;\n}\n\nstatic unsigned long sun50i_h6_irq_ack(struct ths_device *tmdev)\n{\n\tunsigned long irq_bitmap = 0;\n\tint i, state;\n\n\tregmap_read(tmdev->regmap, SUN50I_H6_THS_DIS, &state);\n\n\tfor (i = 0; i < tmdev->chip->sensor_num; i++) {\n\t\tif (state & SUN50I_H6_THS_DATA_IRQ_STS(i)) {\n\t\t\tregmap_write(tmdev->regmap, SUN50I_H6_THS_DIS,\n\t\t\t\t     SUN50I_H6_THS_DATA_IRQ_STS(i));\n\t\t\tbitmap_set(&irq_bitmap, i, 1);\n\t\t}\n\t}\n\n\treturn irq_bitmap;\n}\n\nstatic irqreturn_t sun8i_irq_thread(int irq, void *data)\n{\n\tstruct ths_device *tmdev = data;\n\tunsigned long irq_bitmap = tmdev->chip->irq_ack(tmdev);\n\tint i;\n\n\tfor_each_set_bit(i, &irq_bitmap, tmdev->chip->sensor_num) {\n\t\tthermal_zone_device_update(tmdev->sensor[i].tzd,\n\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sun8i_h3_ths_calibrate(struct ths_device *tmdev,\n\t\t\t\t  u16 *caldata, int callen)\n{\n\tint i;\n\n\tif (!caldata[0] || callen < 2 * tmdev->chip->sensor_num)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < tmdev->chip->sensor_num; i++) {\n\t\tint offset = (i % 2) << 4;\n\n\t\tregmap_update_bits(tmdev->regmap,\n\t\t\t\t   SUN8I_THS_TEMP_CALIB + (4 * (i >> 1)),\n\t\t\t\t   TEMP_CALIB_MASK << offset,\n\t\t\t\t   caldata[i] << offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun50i_h6_ths_calibrate(struct ths_device *tmdev,\n\t\t\t\t   u16 *caldata, int callen)\n{\n\tstruct device *dev = tmdev->dev;\n\tint i, ft_temp;\n\n\tif (!caldata[0] || callen < 2 + 2 * tmdev->chip->sensor_num)\n\t\treturn -EINVAL;\n\n\t \n\tft_temp = (caldata[0] & FT_TEMP_MASK) * 100;\n\n\tfor (i = 0; i < tmdev->chip->sensor_num; i++) {\n\t\tint sensor_reg = caldata[i + 1] & TEMP_CALIB_MASK;\n\t\tint cdata, offset;\n\t\tint sensor_temp = tmdev->chip->calc_temp(tmdev, i, sensor_reg);\n\n\t\t \n\t\tcdata = CALIBRATE_DEFAULT -\n\t\t\t((sensor_temp - ft_temp) * 10 / tmdev->chip->scale);\n\t\tif (cdata & ~TEMP_CALIB_MASK) {\n\t\t\t \n\t\t\tdev_warn(dev, \"sensor%d is not calibrated.\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = (i % 2) * 16;\n\t\tregmap_update_bits(tmdev->regmap,\n\t\t\t\t   SUN50I_H6_THS_TEMP_CALIB + (i / 2 * 4),\n\t\t\t\t   TEMP_CALIB_MASK << offset,\n\t\t\t\t   cdata << offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun8i_ths_calibrate(struct ths_device *tmdev)\n{\n\tstruct nvmem_cell *calcell;\n\tstruct device *dev = tmdev->dev;\n\tu16 *caldata;\n\tsize_t callen;\n\tint ret = 0;\n\n\tcalcell = nvmem_cell_get(dev, \"calibration\");\n\tif (IS_ERR(calcell)) {\n\t\tif (PTR_ERR(calcell) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\t \n\t\tgoto out;\n\t}\n\n\tcaldata = nvmem_cell_read(calcell, &callen);\n\tif (IS_ERR(caldata)) {\n\t\tret = PTR_ERR(caldata);\n\t\tgoto out;\n\t}\n\n\ttmdev->chip->calibrate(tmdev, caldata, callen);\n\n\tkfree(caldata);\nout:\n\tif (!IS_ERR(calcell))\n\t\tnvmem_cell_put(calcell);\n\treturn ret;\n}\n\nstatic void sun8i_ths_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int sun8i_ths_resource_init(struct ths_device *tmdev)\n{\n\tstruct device *dev = tmdev->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tvoid __iomem *base;\n\tint ret;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\ttmdev->regmap = devm_regmap_init_mmio(dev, base, &config);\n\tif (IS_ERR(tmdev->regmap))\n\t\treturn PTR_ERR(tmdev->regmap);\n\n\tif (tmdev->chip->has_bus_clk_reset) {\n\t\ttmdev->reset = devm_reset_control_get(dev, NULL);\n\t\tif (IS_ERR(tmdev->reset))\n\t\t\treturn PTR_ERR(tmdev->reset);\n\n\t\tret = reset_control_deassert(tmdev->reset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(dev, sun8i_ths_reset_control_assert,\n\t\t\t\t\t       tmdev->reset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttmdev->bus_clk = devm_clk_get_enabled(&pdev->dev, \"bus\");\n\t\tif (IS_ERR(tmdev->bus_clk))\n\t\t\treturn PTR_ERR(tmdev->bus_clk);\n\t}\n\n\tif (tmdev->chip->has_mod_clk) {\n\t\ttmdev->mod_clk = devm_clk_get_enabled(&pdev->dev, \"mod\");\n\t\tif (IS_ERR(tmdev->mod_clk))\n\t\t\treturn PTR_ERR(tmdev->mod_clk);\n\t}\n\n\tret = clk_set_rate(tmdev->mod_clk, 24000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun8i_ths_calibrate(tmdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sun8i_h3_thermal_init(struct ths_device *tmdev)\n{\n\tint val;\n\n\t \n\tregmap_write(tmdev->regmap, SUN8I_THS_MFC,\n\t\t     SUN50I_THS_FILTER_EN |\n\t\t     SUN50I_THS_FILTER_TYPE(1));\n\t \n\tval = GENMASK(7 + tmdev->chip->sensor_num, 8);\n\tregmap_write(tmdev->regmap, SUN8I_THS_IC,\n\t\t     SUN50I_H6_THS_PC_TEMP_PERIOD(365) | val);\n\t \n\tregmap_write(tmdev->regmap, SUN8I_THS_CTRL0,\n\t\t     SUN8I_THS_CTRL0_T_ACQ0(479));\n\tval = GENMASK(tmdev->chip->sensor_num - 1, 0);\n\tregmap_write(tmdev->regmap, SUN8I_THS_CTRL2,\n\t\t     SUN8I_THS_CTRL2_T_ACQ1(479) | val);\n\n\treturn 0;\n}\n\n \n#define SUN50I_H6_CTRL0_UNK 0x0000002f\n\nstatic int sun50i_h6_thermal_init(struct ths_device *tmdev)\n{\n\tint val;\n\n\t \n\tregmap_write(tmdev->regmap, SUN50I_THS_CTRL0,\n\t\t     SUN50I_H6_CTRL0_UNK | SUN50I_THS_CTRL0_T_ACQ(479));\n\t \n\tregmap_write(tmdev->regmap, SUN50I_H6_THS_MFC,\n\t\t     SUN50I_THS_FILTER_EN |\n\t\t     SUN50I_THS_FILTER_TYPE(1));\n\t \n\tregmap_write(tmdev->regmap, SUN50I_H6_THS_PC,\n\t\t     SUN50I_H6_THS_PC_TEMP_PERIOD(365));\n\t \n\tval = GENMASK(tmdev->chip->sensor_num - 1, 0);\n\tregmap_write(tmdev->regmap, SUN50I_H6_THS_ENABLE, val);\n\t \n\tval = GENMASK(tmdev->chip->sensor_num - 1, 0);\n\tregmap_write(tmdev->regmap, SUN50I_H6_THS_DIC, val);\n\n\treturn 0;\n}\n\nstatic int sun8i_ths_register(struct ths_device *tmdev)\n{\n\tint i;\n\n\tfor (i = 0; i < tmdev->chip->sensor_num; i++) {\n\t\ttmdev->sensor[i].tmdev = tmdev;\n\t\ttmdev->sensor[i].id = i;\n\t\ttmdev->sensor[i].tzd =\n\t\t\tdevm_thermal_of_zone_register(tmdev->dev,\n\t\t\t\t\t\t      i,\n\t\t\t\t\t\t      &tmdev->sensor[i],\n\t\t\t\t\t\t      &ths_ops);\n\t\tif (IS_ERR(tmdev->sensor[i].tzd))\n\t\t\treturn PTR_ERR(tmdev->sensor[i].tzd);\n\n\t\tdevm_thermal_add_hwmon_sysfs(tmdev->dev, tmdev->sensor[i].tzd);\n\t}\n\n\treturn 0;\n}\n\nstatic int sun8i_ths_probe(struct platform_device *pdev)\n{\n\tstruct ths_device *tmdev;\n\tstruct device *dev = &pdev->dev;\n\tint ret, irq;\n\n\ttmdev = devm_kzalloc(dev, sizeof(*tmdev), GFP_KERNEL);\n\tif (!tmdev)\n\t\treturn -ENOMEM;\n\n\ttmdev->dev = dev;\n\ttmdev->chip = of_device_get_match_data(&pdev->dev);\n\tif (!tmdev->chip)\n\t\treturn -EINVAL;\n\n\tret = sun8i_ths_resource_init(tmdev);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = tmdev->chip->init(tmdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sun8i_ths_register(tmdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\tsun8i_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT, \"ths\", tmdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct ths_thermal_chip sun8i_a83t_ths = {\n\t.sensor_num = 3,\n\t.scale = 705,\n\t.offset = 191668,\n\t.temp_data_base = SUN8I_THS_TEMP_DATA,\n\t.calibrate = sun8i_h3_ths_calibrate,\n\t.init = sun8i_h3_thermal_init,\n\t.irq_ack = sun8i_h3_irq_ack,\n\t.calc_temp = sun8i_ths_calc_temp,\n};\n\nstatic const struct ths_thermal_chip sun8i_h3_ths = {\n\t.sensor_num = 1,\n\t.scale = 1211,\n\t.offset = 217000,\n\t.has_mod_clk = true,\n\t.has_bus_clk_reset = true,\n\t.temp_data_base = SUN8I_THS_TEMP_DATA,\n\t.calibrate = sun8i_h3_ths_calibrate,\n\t.init = sun8i_h3_thermal_init,\n\t.irq_ack = sun8i_h3_irq_ack,\n\t.calc_temp = sun8i_ths_calc_temp,\n};\n\nstatic const struct ths_thermal_chip sun8i_r40_ths = {\n\t.sensor_num = 2,\n\t.offset = 251086,\n\t.scale = 1130,\n\t.has_mod_clk = true,\n\t.has_bus_clk_reset = true,\n\t.temp_data_base = SUN8I_THS_TEMP_DATA,\n\t.calibrate = sun8i_h3_ths_calibrate,\n\t.init = sun8i_h3_thermal_init,\n\t.irq_ack = sun8i_h3_irq_ack,\n\t.calc_temp = sun8i_ths_calc_temp,\n};\n\nstatic const struct ths_thermal_chip sun50i_a64_ths = {\n\t.sensor_num = 3,\n\t.offset = 260890,\n\t.scale = 1170,\n\t.has_mod_clk = true,\n\t.has_bus_clk_reset = true,\n\t.temp_data_base = SUN8I_THS_TEMP_DATA,\n\t.calibrate = sun8i_h3_ths_calibrate,\n\t.init = sun8i_h3_thermal_init,\n\t.irq_ack = sun8i_h3_irq_ack,\n\t.calc_temp = sun8i_ths_calc_temp,\n};\n\nstatic const struct ths_thermal_chip sun50i_a100_ths = {\n\t.sensor_num = 3,\n\t.has_bus_clk_reset = true,\n\t.ft_deviation = 8000,\n\t.offset = 187744,\n\t.scale = 672,\n\t.temp_data_base = SUN50I_H6_THS_TEMP_DATA,\n\t.calibrate = sun50i_h6_ths_calibrate,\n\t.init = sun50i_h6_thermal_init,\n\t.irq_ack = sun50i_h6_irq_ack,\n\t.calc_temp = sun8i_ths_calc_temp,\n};\n\nstatic const struct ths_thermal_chip sun50i_h5_ths = {\n\t.sensor_num = 2,\n\t.has_mod_clk = true,\n\t.has_bus_clk_reset = true,\n\t.temp_data_base = SUN8I_THS_TEMP_DATA,\n\t.calibrate = sun8i_h3_ths_calibrate,\n\t.init = sun8i_h3_thermal_init,\n\t.irq_ack = sun8i_h3_irq_ack,\n\t.calc_temp = sun50i_h5_calc_temp,\n};\n\nstatic const struct ths_thermal_chip sun50i_h6_ths = {\n\t.sensor_num = 2,\n\t.has_bus_clk_reset = true,\n\t.ft_deviation = 7000,\n\t.offset = 187744,\n\t.scale = 672,\n\t.temp_data_base = SUN50I_H6_THS_TEMP_DATA,\n\t.calibrate = sun50i_h6_ths_calibrate,\n\t.init = sun50i_h6_thermal_init,\n\t.irq_ack = sun50i_h6_irq_ack,\n\t.calc_temp = sun8i_ths_calc_temp,\n};\n\nstatic const struct of_device_id of_ths_match[] = {\n\t{ .compatible = \"allwinner,sun8i-a83t-ths\", .data = &sun8i_a83t_ths },\n\t{ .compatible = \"allwinner,sun8i-h3-ths\", .data = &sun8i_h3_ths },\n\t{ .compatible = \"allwinner,sun8i-r40-ths\", .data = &sun8i_r40_ths },\n\t{ .compatible = \"allwinner,sun50i-a64-ths\", .data = &sun50i_a64_ths },\n\t{ .compatible = \"allwinner,sun50i-a100-ths\", .data = &sun50i_a100_ths },\n\t{ .compatible = \"allwinner,sun50i-h5-ths\", .data = &sun50i_h5_ths },\n\t{ .compatible = \"allwinner,sun50i-h6-ths\", .data = &sun50i_h6_ths },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, of_ths_match);\n\nstatic struct platform_driver ths_driver = {\n\t.probe = sun8i_ths_probe,\n\t.driver = {\n\t\t.name = \"sun8i-thermal\",\n\t\t.of_match_table = of_ths_match,\n\t},\n};\nmodule_platform_driver(ths_driver);\n\nMODULE_DESCRIPTION(\"Thermal sensor driver for Allwinner SOC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}