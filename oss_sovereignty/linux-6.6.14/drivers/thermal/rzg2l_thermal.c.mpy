{
  "module_name": "rzg2l_thermal.c",
  "hash_id": "140330cdc2692616420e32e88423a6a140c0a8e090070a084f3e2ee022feb4cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/rzg2l_thermal.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/math.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/thermal.h>\n#include <linux/units.h>\n\n#include \"thermal_hwmon.h\"\n\n#define CTEMP_MASK\t0xFFF\n\n \n#define SW_CALIB0_VAL\t3148\n#define SW_CALIB1_VAL\t503\n\n \n#define TSU_SM\t\t0x00\n#define TSU_ST\t\t0x04\n#define TSU_SAD\t\t0x0C\n#define TSU_SS\t\t0x10\n\n#define OTPTSUTRIM_REG(n)\t(0x18 + ((n) * 0x4))\n#define OTPTSUTRIM_EN_MASK\tBIT(31)\n#define OTPTSUTRIM_MASK\t\tGENMASK(11, 0)\n\n \n#define TSU_SM_EN_TS\t\tBIT(0)\n#define TSU_SM_ADC_EN_TS\tBIT(1)\n#define TSU_SM_NORMAL_MODE\t(TSU_SM_EN_TS | TSU_SM_ADC_EN_TS)\n\n \n#define TSU_ST_START\t\tBIT(0)\n\n#define TSU_SS_CONV_RUNNING\tBIT(0)\n\n#define TS_CODE_AVE_SCALE(x)\t((x) * 1000000)\n#define MCELSIUS(temp)\t\t((temp) * MILLIDEGREE_PER_DEGREE)\n#define TS_CODE_CAP_TIMES\t8\t \n\n#define RZG2L_THERMAL_GRAN\t500\t \n#define RZG2L_TSU_SS_TIMEOUT_US\t1000\n\n#define CURVATURE_CORRECTION_CONST\t13\n\nstruct rzg2l_thermal_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct thermal_zone_device *zone;\n\tstruct reset_control *rstc;\n\tu32 calib0, calib1;\n};\n\nstatic inline u32 rzg2l_thermal_read(struct rzg2l_thermal_priv *priv, u32 reg)\n{\n\treturn ioread32(priv->base + reg);\n}\n\nstatic inline void rzg2l_thermal_write(struct rzg2l_thermal_priv *priv, u32 reg,\n\t\t\t\t       u32 data)\n{\n\tiowrite32(data, priv->base + reg);\n}\n\nstatic int rzg2l_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct rzg2l_thermal_priv *priv = thermal_zone_device_priv(tz);\n\tu32 result = 0, dsensor, ts_code_ave;\n\tint val, i;\n\n\tfor (i = 0; i < TS_CODE_CAP_TIMES ; i++) {\n\t\t \n\t\tresult += rzg2l_thermal_read(priv, TSU_SAD) & CTEMP_MASK;\n\t\tusleep_range(20, 30);\n\t}\n\n\tts_code_ave = result / TS_CODE_CAP_TIMES;\n\n\t \n\tdsensor = TS_CODE_AVE_SCALE(ts_code_ave) /\n\t\t(TS_CODE_AVE_SCALE(1) + (ts_code_ave * CURVATURE_CORRECTION_CONST));\n\n\t \n\tval = ((dsensor - priv->calib1) * (MCELSIUS(165) /\n\t\t(priv->calib0 - priv->calib1))) - MCELSIUS(40);\n\n\t*temp = roundup(val, RZG2L_THERMAL_GRAN);\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops rzg2l_tz_of_ops = {\n\t.get_temp = rzg2l_thermal_get_temp,\n};\n\nstatic int rzg2l_thermal_init(struct rzg2l_thermal_priv *priv)\n{\n\tu32 reg_val;\n\n\trzg2l_thermal_write(priv, TSU_SM, TSU_SM_NORMAL_MODE);\n\trzg2l_thermal_write(priv, TSU_ST, 0);\n\n\t \n\tusleep_range(60, 80);\n\n\treg_val = rzg2l_thermal_read(priv, TSU_ST);\n\treg_val |= TSU_ST_START;\n\trzg2l_thermal_write(priv, TSU_ST, reg_val);\n\n\treturn readl_poll_timeout(priv->base + TSU_SS, reg_val,\n\t\t\t\t  reg_val == TSU_SS_CONV_RUNNING, 50,\n\t\t\t\t  RZG2L_TSU_SS_TIMEOUT_US);\n}\n\nstatic void rzg2l_thermal_reset_assert_pm_disable_put(struct platform_device *pdev)\n{\n\tstruct rzg2l_thermal_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treset_control_assert(priv->rstc);\n}\n\nstatic int rzg2l_thermal_remove(struct platform_device *pdev)\n{\n\tstruct rzg2l_thermal_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tthermal_remove_hwmon_sysfs(priv->zone);\n\trzg2l_thermal_reset_assert_pm_disable_put(pdev);\n\n\treturn 0;\n}\n\nstatic int rzg2l_thermal_probe(struct platform_device *pdev)\n{\n\tstruct thermal_zone_device *zone;\n\tstruct rzg2l_thermal_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->dev = dev;\n\tpriv->rstc = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(priv->rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->rstc),\n\t\t\t\t     \"failed to get cpg reset\");\n\n\tret = reset_control_deassert(priv->rstc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to deassert\");\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tpriv->calib0 = rzg2l_thermal_read(priv, OTPTSUTRIM_REG(0));\n\tif (priv->calib0 & OTPTSUTRIM_EN_MASK)\n\t\tpriv->calib0 &= OTPTSUTRIM_MASK;\n\telse\n\t\tpriv->calib0 = SW_CALIB0_VAL;\n\n\tpriv->calib1 = rzg2l_thermal_read(priv, OTPTSUTRIM_REG(1));\n\tif (priv->calib1 & OTPTSUTRIM_EN_MASK)\n\t\tpriv->calib1 &= OTPTSUTRIM_MASK;\n\telse\n\t\tpriv->calib1 = SW_CALIB1_VAL;\n\n\tplatform_set_drvdata(pdev, priv);\n\tret = rzg2l_thermal_init(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to start TSU\");\n\t\tgoto err;\n\t}\n\n\tzone = devm_thermal_of_zone_register(dev, 0, priv,\n\t\t\t\t\t     &rzg2l_tz_of_ops);\n\tif (IS_ERR(zone)) {\n\t\tdev_err(dev, \"Can't register thermal zone\");\n\t\tret = PTR_ERR(zone);\n\t\tgoto err;\n\t}\n\n\tpriv->zone = zone;\n\tret = thermal_add_hwmon_sysfs(priv->zone);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_dbg(dev, \"TSU probed with %s calibration values\",\n\t\trzg2l_thermal_read(priv, OTPTSUTRIM_REG(0)) ?  \"hw\" : \"sw\");\n\n\treturn 0;\n\nerr:\n\trzg2l_thermal_reset_assert_pm_disable_put(pdev);\n\treturn ret;\n}\n\nstatic const struct of_device_id rzg2l_thermal_dt_ids[] = {\n\t{ .compatible = \"renesas,rzg2l-tsu\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzg2l_thermal_dt_ids);\n\nstatic struct platform_driver rzg2l_thermal_driver = {\n\t.driver = {\n\t\t.name = \"rzg2l_thermal\",\n\t\t.of_match_table = rzg2l_thermal_dt_ids,\n\t},\n\t.probe = rzg2l_thermal_probe,\n\t.remove = rzg2l_thermal_remove,\n};\nmodule_platform_driver(rzg2l_thermal_driver);\n\nMODULE_DESCRIPTION(\"Renesas RZ/G2L TSU Thermal Sensor Driver\");\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}