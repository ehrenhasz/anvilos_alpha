{
  "module_name": "thermal_core.c",
  "hash_id": "70bc13bcfd9862f50ea6eb13ab986158c8f955427045725fb2faabea1122e801",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/thermal_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/idr.h>\n#include <linux/thermal.h>\n#include <linux/reboot.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/suspend.h>\n\n#define CREATE_TRACE_POINTS\n#include \"thermal_trace.h\"\n\n#include \"thermal_core.h\"\n#include \"thermal_hwmon.h\"\n\nstatic DEFINE_IDA(thermal_tz_ida);\nstatic DEFINE_IDA(thermal_cdev_ida);\n\nstatic LIST_HEAD(thermal_tz_list);\nstatic LIST_HEAD(thermal_cdev_list);\nstatic LIST_HEAD(thermal_governor_list);\n\nstatic DEFINE_MUTEX(thermal_list_lock);\nstatic DEFINE_MUTEX(thermal_governor_lock);\n\nstatic atomic_t in_suspend;\n\nstatic struct thermal_governor *def_governor;\n\n \n\nstatic struct thermal_governor *__find_governor(const char *name)\n{\n\tstruct thermal_governor *pos;\n\n\tif (!name || !name[0])\n\t\treturn def_governor;\n\n\tlist_for_each_entry(pos, &thermal_governor_list, governor_list)\n\t\tif (!strncasecmp(name, pos->name, THERMAL_NAME_LENGTH))\n\t\t\treturn pos;\n\n\treturn NULL;\n}\n\n \nstatic void bind_previous_governor(struct thermal_zone_device *tz,\n\t\t\t\t   const char *failed_gov_name)\n{\n\tif (tz->governor && tz->governor->bind_to_tz) {\n\t\tif (tz->governor->bind_to_tz(tz)) {\n\t\t\tdev_err(&tz->device,\n\t\t\t\t\"governor %s failed to bind and the previous one (%s) failed to bind again, thermal zone %s has no governor\\n\",\n\t\t\t\tfailed_gov_name, tz->governor->name, tz->type);\n\t\t\ttz->governor = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int thermal_set_governor(struct thermal_zone_device *tz,\n\t\t\t\tstruct thermal_governor *new_gov)\n{\n\tint ret = 0;\n\n\tif (tz->governor && tz->governor->unbind_from_tz)\n\t\ttz->governor->unbind_from_tz(tz);\n\n\tif (new_gov && new_gov->bind_to_tz) {\n\t\tret = new_gov->bind_to_tz(tz);\n\t\tif (ret) {\n\t\t\tbind_previous_governor(tz, new_gov->name);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttz->governor = new_gov;\n\n\treturn ret;\n}\n\nint thermal_register_governor(struct thermal_governor *governor)\n{\n\tint err;\n\tconst char *name;\n\tstruct thermal_zone_device *pos;\n\n\tif (!governor)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&thermal_governor_lock);\n\n\terr = -EBUSY;\n\tif (!__find_governor(governor->name)) {\n\t\tbool match_default;\n\n\t\terr = 0;\n\t\tlist_add(&governor->governor_list, &thermal_governor_list);\n\t\tmatch_default = !strncmp(governor->name,\n\t\t\t\t\t DEFAULT_THERMAL_GOVERNOR,\n\t\t\t\t\t THERMAL_NAME_LENGTH);\n\n\t\tif (!def_governor && match_default)\n\t\t\tdef_governor = governor;\n\t}\n\n\tmutex_lock(&thermal_list_lock);\n\n\tlist_for_each_entry(pos, &thermal_tz_list, node) {\n\t\t \n\t\tif (pos->governor)\n\t\t\tcontinue;\n\n\t\tname = pos->tzp->governor_name;\n\n\t\tif (!strncasecmp(name, governor->name, THERMAL_NAME_LENGTH)) {\n\t\t\tint ret;\n\n\t\t\tret = thermal_set_governor(pos, governor);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&pos->device,\n\t\t\t\t\t\"Failed to set governor %s for thermal zone %s: %d\\n\",\n\t\t\t\t\tgovernor->name, pos->type, ret);\n\t\t}\n\t}\n\n\tmutex_unlock(&thermal_list_lock);\n\tmutex_unlock(&thermal_governor_lock);\n\n\treturn err;\n}\n\nvoid thermal_unregister_governor(struct thermal_governor *governor)\n{\n\tstruct thermal_zone_device *pos;\n\n\tif (!governor)\n\t\treturn;\n\n\tmutex_lock(&thermal_governor_lock);\n\n\tif (!__find_governor(governor->name))\n\t\tgoto exit;\n\n\tmutex_lock(&thermal_list_lock);\n\n\tlist_for_each_entry(pos, &thermal_tz_list, node) {\n\t\tif (!strncasecmp(pos->governor->name, governor->name,\n\t\t\t\t THERMAL_NAME_LENGTH))\n\t\t\tthermal_set_governor(pos, NULL);\n\t}\n\n\tmutex_unlock(&thermal_list_lock);\n\tlist_del(&governor->governor_list);\nexit:\n\tmutex_unlock(&thermal_governor_lock);\n}\n\nint thermal_zone_device_set_policy(struct thermal_zone_device *tz,\n\t\t\t\t   char *policy)\n{\n\tstruct thermal_governor *gov;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&thermal_governor_lock);\n\tmutex_lock(&tz->lock);\n\n\tif (!device_is_registered(&tz->device))\n\t\tgoto exit;\n\n\tgov = __find_governor(strim(policy));\n\tif (!gov)\n\t\tgoto exit;\n\n\tret = thermal_set_governor(tz, gov);\n\nexit:\n\tmutex_unlock(&tz->lock);\n\tmutex_unlock(&thermal_governor_lock);\n\n\tthermal_notify_tz_gov_change(tz->id, policy);\n\n\treturn ret;\n}\n\nint thermal_build_list_of_policies(char *buf)\n{\n\tstruct thermal_governor *pos;\n\tssize_t count = 0;\n\n\tmutex_lock(&thermal_governor_lock);\n\n\tlist_for_each_entry(pos, &thermal_governor_list, governor_list) {\n\t\tcount += sysfs_emit_at(buf, count, \"%s \", pos->name);\n\t}\n\tcount += sysfs_emit_at(buf, count, \"\\n\");\n\n\tmutex_unlock(&thermal_governor_lock);\n\n\treturn count;\n}\n\nstatic void __init thermal_unregister_governors(void)\n{\n\tstruct thermal_governor **governor;\n\n\tfor_each_governor_table(governor)\n\t\tthermal_unregister_governor(*governor);\n}\n\nstatic int __init thermal_register_governors(void)\n{\n\tint ret = 0;\n\tstruct thermal_governor **governor;\n\n\tfor_each_governor_table(governor) {\n\t\tret = thermal_register_governor(*governor);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to register governor: '%s'\",\n\t\t\t       (*governor)->name);\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_info(\"Registered thermal governor '%s'\",\n\t\t\t(*governor)->name);\n\t}\n\n\tif (ret) {\n\t\tstruct thermal_governor **gov;\n\n\t\tfor_each_governor_table(gov) {\n\t\t\tif (gov == governor)\n\t\t\t\tbreak;\n\t\t\tthermal_unregister_governor(*gov);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic void thermal_zone_device_set_polling(struct thermal_zone_device *tz,\n\t\t\t\t\t    unsigned long delay)\n{\n\tif (delay)\n\t\tmod_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t &tz->poll_queue, delay);\n\telse\n\t\tcancel_delayed_work(&tz->poll_queue);\n}\n\nstatic void monitor_thermal_zone(struct thermal_zone_device *tz)\n{\n\tif (tz->mode != THERMAL_DEVICE_ENABLED)\n\t\tthermal_zone_device_set_polling(tz, 0);\n\telse if (tz->passive)\n\t\tthermal_zone_device_set_polling(tz, tz->passive_delay_jiffies);\n\telse if (tz->polling_delay_jiffies)\n\t\tthermal_zone_device_set_polling(tz, tz->polling_delay_jiffies);\n}\n\nstatic void handle_non_critical_trips(struct thermal_zone_device *tz, int trip)\n{\n\ttz->governor ? tz->governor->throttle(tz, trip) :\n\t\t       def_governor->throttle(tz, trip);\n}\n\nvoid thermal_zone_device_critical(struct thermal_zone_device *tz)\n{\n\t \n\tint poweroff_delay_ms = CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS;\n\n\tdev_emerg(&tz->device, \"%s: critical temperature reached, \"\n\t\t  \"shutting down\\n\", tz->type);\n\n\thw_protection_shutdown(\"Temperature too high\", poweroff_delay_ms);\n}\nEXPORT_SYMBOL(thermal_zone_device_critical);\n\nstatic void handle_critical_trips(struct thermal_zone_device *tz,\n\t\t\t\t  int trip, int trip_temp, enum thermal_trip_type trip_type)\n{\n\t \n\tif (trip_temp <= 0 || tz->temperature < trip_temp)\n\t\treturn;\n\n\ttrace_thermal_zone_trip(tz, trip, trip_type);\n\n\tif (trip_type == THERMAL_TRIP_HOT && tz->ops->hot)\n\t\ttz->ops->hot(tz);\n\telse if (trip_type == THERMAL_TRIP_CRITICAL)\n\t\ttz->ops->critical(tz);\n}\n\nstatic void handle_thermal_trip(struct thermal_zone_device *tz, int trip_id)\n{\n\tstruct thermal_trip trip;\n\n\t \n\tif (test_bit(trip_id, &tz->trips_disabled))\n\t\treturn;\n\n\t__thermal_zone_get_trip(tz, trip_id, &trip);\n\n\tif (trip.temperature == THERMAL_TEMP_INVALID)\n\t\treturn;\n\n\tif (tz->last_temperature != THERMAL_TEMP_INVALID) {\n\t\tif (tz->last_temperature < trip.temperature &&\n\t\t    tz->temperature >= trip.temperature)\n\t\t\tthermal_notify_tz_trip_up(tz->id, trip_id,\n\t\t\t\t\t\t  tz->temperature);\n\t\tif (tz->last_temperature >= trip.temperature &&\n\t\t    tz->temperature < (trip.temperature - trip.hysteresis))\n\t\t\tthermal_notify_tz_trip_down(tz->id, trip_id,\n\t\t\t\t\t\t    tz->temperature);\n\t}\n\n\tif (trip.type == THERMAL_TRIP_CRITICAL || trip.type == THERMAL_TRIP_HOT)\n\t\thandle_critical_trips(tz, trip_id, trip.temperature, trip.type);\n\telse\n\t\thandle_non_critical_trips(tz, trip_id);\n}\n\nstatic void update_temperature(struct thermal_zone_device *tz)\n{\n\tint temp, ret;\n\n\tret = __thermal_zone_get_temp(tz, &temp);\n\tif (ret) {\n\t\tif (ret != -EAGAIN)\n\t\t\tdev_warn(&tz->device,\n\t\t\t\t \"failed to read out thermal zone (%d)\\n\",\n\t\t\t\t ret);\n\t\treturn;\n\t}\n\n\ttz->last_temperature = tz->temperature;\n\ttz->temperature = temp;\n\n\ttrace_thermal_temperature(tz);\n\n\tthermal_genl_sampling_temp(tz->id, temp);\n}\n\nstatic void thermal_zone_device_init(struct thermal_zone_device *tz)\n{\n\tstruct thermal_instance *pos;\n\ttz->temperature = THERMAL_TEMP_INVALID;\n\ttz->prev_low_trip = -INT_MAX;\n\ttz->prev_high_trip = INT_MAX;\n\tlist_for_each_entry(pos, &tz->thermal_instances, tz_node)\n\t\tpos->initialized = false;\n}\n\nvoid __thermal_zone_device_update(struct thermal_zone_device *tz,\n\t\t\t\t  enum thermal_notify_event event)\n{\n\tint count;\n\n\tif (atomic_read(&in_suspend))\n\t\treturn;\n\n\tif (WARN_ONCE(!tz->ops->get_temp,\n\t\t      \"'%s' must not be called without 'get_temp' ops set\\n\",\n\t\t      __func__))\n\t\treturn;\n\n\tif (!thermal_zone_device_is_enabled(tz))\n\t\treturn;\n\n\tupdate_temperature(tz);\n\n\t__thermal_zone_set_trips(tz);\n\n\ttz->notify_event = event;\n\n\tfor (count = 0; count < tz->num_trips; count++)\n\t\thandle_thermal_trip(tz, count);\n\n\tmonitor_thermal_zone(tz);\n}\n\nstatic int thermal_zone_device_set_mode(struct thermal_zone_device *tz,\n\t\t\t\t\tenum thermal_device_mode mode)\n{\n\tint ret = 0;\n\n\tmutex_lock(&tz->lock);\n\n\t \n\tif (mode == tz->mode) {\n\t\tmutex_unlock(&tz->lock);\n\n\t\treturn ret;\n\t}\n\n\tif (!device_is_registered(&tz->device)) {\n\t\tmutex_unlock(&tz->lock);\n\n\t\treturn -ENODEV;\n\t}\n\n\tif (tz->ops->change_mode)\n\t\tret = tz->ops->change_mode(tz, mode);\n\n\tif (!ret)\n\t\ttz->mode = mode;\n\n\t__thermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\n\n\tmutex_unlock(&tz->lock);\n\n\tif (mode == THERMAL_DEVICE_ENABLED)\n\t\tthermal_notify_tz_enable(tz->id);\n\telse\n\t\tthermal_notify_tz_disable(tz->id);\n\n\treturn ret;\n}\n\nint thermal_zone_device_enable(struct thermal_zone_device *tz)\n{\n\treturn thermal_zone_device_set_mode(tz, THERMAL_DEVICE_ENABLED);\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_enable);\n\nint thermal_zone_device_disable(struct thermal_zone_device *tz)\n{\n\treturn thermal_zone_device_set_mode(tz, THERMAL_DEVICE_DISABLED);\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_disable);\n\nint thermal_zone_device_is_enabled(struct thermal_zone_device *tz)\n{\n\tlockdep_assert_held(&tz->lock);\n\n\treturn tz->mode == THERMAL_DEVICE_ENABLED;\n}\n\nvoid thermal_zone_device_update(struct thermal_zone_device *tz,\n\t\t\t\tenum thermal_notify_event event)\n{\n\tmutex_lock(&tz->lock);\n\tif (device_is_registered(&tz->device))\n\t\t__thermal_zone_device_update(tz, event);\n\tmutex_unlock(&tz->lock);\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_update);\n\n \nvoid thermal_zone_device_exec(struct thermal_zone_device *tz,\n\t\t\t      void (*cb)(struct thermal_zone_device *,\n\t\t\t\t\t unsigned long),\n\t\t\t      unsigned long data)\n{\n\tmutex_lock(&tz->lock);\n\n\tcb(tz, data);\n\n\tmutex_unlock(&tz->lock);\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_exec);\n\nstatic void thermal_zone_device_check(struct work_struct *work)\n{\n\tstruct thermal_zone_device *tz = container_of(work, struct\n\t\t\t\t\t\t      thermal_zone_device,\n\t\t\t\t\t\t      poll_queue.work);\n\tthermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\n}\n\nint for_each_thermal_governor(int (*cb)(struct thermal_governor *, void *),\n\t\t\t      void *data)\n{\n\tstruct thermal_governor *gov;\n\tint ret = 0;\n\n\tmutex_lock(&thermal_governor_lock);\n\tlist_for_each_entry(gov, &thermal_governor_list, governor_list) {\n\t\tret = cb(gov, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&thermal_governor_lock);\n\n\treturn ret;\n}\n\nint for_each_thermal_cooling_device(int (*cb)(struct thermal_cooling_device *,\n\t\t\t\t\t      void *), void *data)\n{\n\tstruct thermal_cooling_device *cdev;\n\tint ret = 0;\n\n\tmutex_lock(&thermal_list_lock);\n\tlist_for_each_entry(cdev, &thermal_cdev_list, node) {\n\t\tret = cb(cdev, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&thermal_list_lock);\n\n\treturn ret;\n}\n\nint for_each_thermal_zone(int (*cb)(struct thermal_zone_device *, void *),\n\t\t\t  void *data)\n{\n\tstruct thermal_zone_device *tz;\n\tint ret = 0;\n\n\tmutex_lock(&thermal_list_lock);\n\tlist_for_each_entry(tz, &thermal_tz_list, node) {\n\t\tret = cb(tz, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&thermal_list_lock);\n\n\treturn ret;\n}\n\nstruct thermal_zone_device *thermal_zone_get_by_id(int id)\n{\n\tstruct thermal_zone_device *tz, *match = NULL;\n\n\tmutex_lock(&thermal_list_lock);\n\tlist_for_each_entry(tz, &thermal_tz_list, node) {\n\t\tif (tz->id == id) {\n\t\t\tmatch = tz;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&thermal_list_lock);\n\n\treturn match;\n}\n\n \n\n \nint thermal_zone_bind_cooling_device(struct thermal_zone_device *tz,\n\t\t\t\t     int trip,\n\t\t\t\t     struct thermal_cooling_device *cdev,\n\t\t\t\t     unsigned long upper, unsigned long lower,\n\t\t\t\t     unsigned int weight)\n{\n\tstruct thermal_instance *dev;\n\tstruct thermal_instance *pos;\n\tstruct thermal_zone_device *pos1;\n\tstruct thermal_cooling_device *pos2;\n\tbool upper_no_limit;\n\tint result;\n\n\tif (trip >= tz->num_trips || trip < 0)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(pos1, &thermal_tz_list, node) {\n\t\tif (pos1 == tz)\n\t\t\tbreak;\n\t}\n\tlist_for_each_entry(pos2, &thermal_cdev_list, node) {\n\t\tif (pos2 == cdev)\n\t\t\tbreak;\n\t}\n\n\tif (tz != pos1 || cdev != pos2)\n\t\treturn -EINVAL;\n\n\t \n\tlower = lower == THERMAL_NO_LIMIT ? 0 : lower;\n\n\tif (upper == THERMAL_NO_LIMIT) {\n\t\tupper = cdev->max_state;\n\t\tupper_no_limit = true;\n\t} else {\n\t\tupper_no_limit = false;\n\t}\n\n\tif (lower > upper || upper > cdev->max_state)\n\t\treturn -EINVAL;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->tz = tz;\n\tdev->cdev = cdev;\n\tdev->trip = trip;\n\tdev->upper = upper;\n\tdev->upper_no_limit = upper_no_limit;\n\tdev->lower = lower;\n\tdev->target = THERMAL_NO_TARGET;\n\tdev->weight = weight;\n\n\tresult = ida_alloc(&tz->ida, GFP_KERNEL);\n\tif (result < 0)\n\t\tgoto free_mem;\n\n\tdev->id = result;\n\tsprintf(dev->name, \"cdev%d\", dev->id);\n\tresult =\n\t    sysfs_create_link(&tz->device.kobj, &cdev->device.kobj, dev->name);\n\tif (result)\n\t\tgoto release_ida;\n\n\tsnprintf(dev->attr_name, sizeof(dev->attr_name), \"cdev%d_trip_point\",\n\t\t dev->id);\n\tsysfs_attr_init(&dev->attr.attr);\n\tdev->attr.attr.name = dev->attr_name;\n\tdev->attr.attr.mode = 0444;\n\tdev->attr.show = trip_point_show;\n\tresult = device_create_file(&tz->device, &dev->attr);\n\tif (result)\n\t\tgoto remove_symbol_link;\n\n\tsnprintf(dev->weight_attr_name, sizeof(dev->weight_attr_name),\n\t\t \"cdev%d_weight\", dev->id);\n\tsysfs_attr_init(&dev->weight_attr.attr);\n\tdev->weight_attr.attr.name = dev->weight_attr_name;\n\tdev->weight_attr.attr.mode = S_IWUSR | S_IRUGO;\n\tdev->weight_attr.show = weight_show;\n\tdev->weight_attr.store = weight_store;\n\tresult = device_create_file(&tz->device, &dev->weight_attr);\n\tif (result)\n\t\tgoto remove_trip_file;\n\n\tmutex_lock(&tz->lock);\n\tmutex_lock(&cdev->lock);\n\tlist_for_each_entry(pos, &tz->thermal_instances, tz_node)\n\t\tif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\n\t\t\tresult = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\tif (!result) {\n\t\tlist_add_tail(&dev->tz_node, &tz->thermal_instances);\n\t\tlist_add_tail(&dev->cdev_node, &cdev->thermal_instances);\n\t\tatomic_set(&tz->need_update, 1);\n\t}\n\tmutex_unlock(&cdev->lock);\n\tmutex_unlock(&tz->lock);\n\n\tif (!result)\n\t\treturn 0;\n\n\tdevice_remove_file(&tz->device, &dev->weight_attr);\nremove_trip_file:\n\tdevice_remove_file(&tz->device, &dev->attr);\nremove_symbol_link:\n\tsysfs_remove_link(&tz->device.kobj, dev->name);\nrelease_ida:\n\tida_free(&tz->ida, dev->id);\nfree_mem:\n\tkfree(dev);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_bind_cooling_device);\n\n \nint thermal_zone_unbind_cooling_device(struct thermal_zone_device *tz,\n\t\t\t\t       int trip,\n\t\t\t\t       struct thermal_cooling_device *cdev)\n{\n\tstruct thermal_instance *pos, *next;\n\n\tmutex_lock(&tz->lock);\n\tmutex_lock(&cdev->lock);\n\tlist_for_each_entry_safe(pos, next, &tz->thermal_instances, tz_node) {\n\t\tif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\n\t\t\tlist_del(&pos->tz_node);\n\t\t\tlist_del(&pos->cdev_node);\n\t\t\tmutex_unlock(&cdev->lock);\n\t\t\tmutex_unlock(&tz->lock);\n\t\t\tgoto unbind;\n\t\t}\n\t}\n\tmutex_unlock(&cdev->lock);\n\tmutex_unlock(&tz->lock);\n\n\treturn -ENODEV;\n\nunbind:\n\tdevice_remove_file(&tz->device, &pos->weight_attr);\n\tdevice_remove_file(&tz->device, &pos->attr);\n\tsysfs_remove_link(&tz->device.kobj, pos->name);\n\tida_free(&tz->ida, pos->id);\n\tkfree(pos);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_unbind_cooling_device);\n\nstatic void thermal_release(struct device *dev)\n{\n\tstruct thermal_zone_device *tz;\n\tstruct thermal_cooling_device *cdev;\n\n\tif (!strncmp(dev_name(dev), \"thermal_zone\",\n\t\t     sizeof(\"thermal_zone\") - 1)) {\n\t\ttz = to_thermal_zone(dev);\n\t\tthermal_zone_destroy_device_groups(tz);\n\t\tmutex_destroy(&tz->lock);\n\t\tkfree(tz);\n\t} else if (!strncmp(dev_name(dev), \"cooling_device\",\n\t\t\t    sizeof(\"cooling_device\") - 1)) {\n\t\tcdev = to_cooling_device(dev);\n\t\tthermal_cooling_device_destroy_sysfs(cdev);\n\t\tkfree(cdev->type);\n\t\tida_free(&thermal_cdev_ida, cdev->id);\n\t\tkfree(cdev);\n\t}\n}\n\nstatic struct class *thermal_class;\n\nstatic inline\nvoid print_bind_err_msg(struct thermal_zone_device *tz,\n\t\t\tstruct thermal_cooling_device *cdev, int ret)\n{\n\tdev_err(&tz->device, \"binding zone %s with cdev %s failed:%d\\n\",\n\t\ttz->type, cdev->type, ret);\n}\n\nstatic void bind_cdev(struct thermal_cooling_device *cdev)\n{\n\tint ret;\n\tstruct thermal_zone_device *pos = NULL;\n\n\tlist_for_each_entry(pos, &thermal_tz_list, node) {\n\t\tif (pos->ops->bind) {\n\t\t\tret = pos->ops->bind(pos, cdev);\n\t\t\tif (ret)\n\t\t\t\tprint_bind_err_msg(pos, cdev, ret);\n\t\t}\n\t}\n}\n\n \nstatic struct thermal_cooling_device *\n__thermal_cooling_device_register(struct device_node *np,\n\t\t\t\t  const char *type, void *devdata,\n\t\t\t\t  const struct thermal_cooling_device_ops *ops)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct thermal_zone_device *pos = NULL;\n\tint id, ret;\n\n\tif (!ops || !ops->get_max_state || !ops->get_cur_state ||\n\t    !ops->set_cur_state)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!thermal_class)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tcdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ida_alloc(&thermal_cdev_ida, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out_kfree_cdev;\n\tcdev->id = ret;\n\tid = ret;\n\n\tcdev->type = kstrdup(type ? type : \"\", GFP_KERNEL);\n\tif (!cdev->type) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ida_remove;\n\t}\n\n\tmutex_init(&cdev->lock);\n\tINIT_LIST_HEAD(&cdev->thermal_instances);\n\tcdev->np = np;\n\tcdev->ops = ops;\n\tcdev->updated = false;\n\tcdev->device.class = thermal_class;\n\tcdev->devdata = devdata;\n\n\tret = cdev->ops->get_max_state(cdev, &cdev->max_state);\n\tif (ret)\n\t\tgoto out_cdev_type;\n\n\tthermal_cooling_device_setup_sysfs(cdev);\n\n\tret = dev_set_name(&cdev->device, \"cooling_device%d\", cdev->id);\n\tif (ret)\n\t\tgoto out_cooling_dev;\n\n\tret = device_register(&cdev->device);\n\tif (ret) {\n\t\t \n\t\tput_device(&cdev->device);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tmutex_lock(&thermal_list_lock);\n\n\tlist_add(&cdev->node, &thermal_cdev_list);\n\n\t \n\tbind_cdev(cdev);\n\n\tlist_for_each_entry(pos, &thermal_tz_list, node)\n\t\tif (atomic_cmpxchg(&pos->need_update, 1, 0))\n\t\t\tthermal_zone_device_update(pos,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\n\tmutex_unlock(&thermal_list_lock);\n\n\treturn cdev;\n\nout_cooling_dev:\n\tthermal_cooling_device_destroy_sysfs(cdev);\nout_cdev_type:\n\tkfree(cdev->type);\nout_ida_remove:\n\tida_free(&thermal_cdev_ida, id);\nout_kfree_cdev:\n\tkfree(cdev);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct thermal_cooling_device *\nthermal_cooling_device_register(const char *type, void *devdata,\n\t\t\t\tconst struct thermal_cooling_device_ops *ops)\n{\n\treturn __thermal_cooling_device_register(NULL, type, devdata, ops);\n}\nEXPORT_SYMBOL_GPL(thermal_cooling_device_register);\n\n \nstruct thermal_cooling_device *\nthermal_of_cooling_device_register(struct device_node *np,\n\t\t\t\t   const char *type, void *devdata,\n\t\t\t\t   const struct thermal_cooling_device_ops *ops)\n{\n\treturn __thermal_cooling_device_register(np, type, devdata, ops);\n}\nEXPORT_SYMBOL_GPL(thermal_of_cooling_device_register);\n\nstatic void thermal_cooling_device_release(struct device *dev, void *res)\n{\n\tthermal_cooling_device_unregister(\n\t\t\t\t*(struct thermal_cooling_device **)res);\n}\n\n \nstruct thermal_cooling_device *\ndevm_thermal_of_cooling_device_register(struct device *dev,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tchar *type, void *devdata,\n\t\t\t\tconst struct thermal_cooling_device_ops *ops)\n{\n\tstruct thermal_cooling_device **ptr, *tcd;\n\n\tptr = devres_alloc(thermal_cooling_device_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttcd = __thermal_cooling_device_register(np, type, devdata, ops);\n\tif (IS_ERR(tcd)) {\n\t\tdevres_free(ptr);\n\t\treturn tcd;\n\t}\n\n\t*ptr = tcd;\n\tdevres_add(dev, ptr);\n\n\treturn tcd;\n}\nEXPORT_SYMBOL_GPL(devm_thermal_of_cooling_device_register);\n\nstatic bool thermal_cooling_device_present(struct thermal_cooling_device *cdev)\n{\n\tstruct thermal_cooling_device *pos = NULL;\n\n\tlist_for_each_entry(pos, &thermal_cdev_list, node) {\n\t\tif (pos == cdev)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid thermal_cooling_device_update(struct thermal_cooling_device *cdev)\n{\n\tstruct thermal_instance *ti;\n\tunsigned long state;\n\n\tif (IS_ERR_OR_NULL(cdev))\n\t\treturn;\n\n\t \n\tmutex_lock(&thermal_list_lock);\n\n\tif (!thermal_cooling_device_present(cdev))\n\t\tgoto unlock_list;\n\n\t \n\tmutex_lock(&cdev->lock);\n\n\tif (cdev->ops->get_max_state(cdev, &cdev->max_state))\n\t\tgoto unlock;\n\n\tthermal_cooling_device_stats_reinit(cdev);\n\n\tlist_for_each_entry(ti, &cdev->thermal_instances, cdev_node) {\n\t\tif (ti->upper == cdev->max_state)\n\t\t\tcontinue;\n\n\t\tif (ti->upper < cdev->max_state) {\n\t\t\tif (ti->upper_no_limit)\n\t\t\t\tti->upper = cdev->max_state;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tti->upper = cdev->max_state;\n\t\tif (ti->lower > ti->upper)\n\t\t\tti->lower = ti->upper;\n\n\t\tif (ti->target == THERMAL_NO_TARGET)\n\t\t\tcontinue;\n\n\t\tif (ti->target > ti->upper)\n\t\t\tti->target = ti->upper;\n\t}\n\n\tif (cdev->ops->get_cur_state(cdev, &state) || state > cdev->max_state)\n\t\tgoto unlock;\n\n\tthermal_cooling_device_stats_update(cdev, state);\n\nunlock:\n\tmutex_unlock(&cdev->lock);\n\nunlock_list:\n\tmutex_unlock(&thermal_list_lock);\n}\nEXPORT_SYMBOL_GPL(thermal_cooling_device_update);\n\n \nvoid thermal_cooling_device_unregister(struct thermal_cooling_device *cdev)\n{\n\tstruct thermal_zone_device *tz;\n\n\tif (!cdev)\n\t\treturn;\n\n\tmutex_lock(&thermal_list_lock);\n\n\tif (!thermal_cooling_device_present(cdev)) {\n\t\tmutex_unlock(&thermal_list_lock);\n\t\treturn;\n\t}\n\n\tlist_del(&cdev->node);\n\n\t \n\tlist_for_each_entry(tz, &thermal_tz_list, node) {\n\t\tif (tz->ops->unbind)\n\t\t\ttz->ops->unbind(tz, cdev);\n\t}\n\n\tmutex_unlock(&thermal_list_lock);\n\n\tdevice_unregister(&cdev->device);\n}\nEXPORT_SYMBOL_GPL(thermal_cooling_device_unregister);\n\nstatic void bind_tz(struct thermal_zone_device *tz)\n{\n\tint ret;\n\tstruct thermal_cooling_device *pos = NULL;\n\n\tif (!tz->ops->bind)\n\t\treturn;\n\n\tmutex_lock(&thermal_list_lock);\n\n\tlist_for_each_entry(pos, &thermal_cdev_list, node) {\n\t\tret = tz->ops->bind(tz, pos);\n\t\tif (ret)\n\t\t\tprint_bind_err_msg(tz, pos, ret);\n\t}\n\n\tmutex_unlock(&thermal_list_lock);\n}\n\nstatic void thermal_set_delay_jiffies(unsigned long *delay_jiffies, int delay_ms)\n{\n\t*delay_jiffies = msecs_to_jiffies(delay_ms);\n\tif (delay_ms > 1000)\n\t\t*delay_jiffies = round_jiffies(*delay_jiffies);\n}\n\nint thermal_zone_get_crit_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tint i, ret = -EINVAL;\n\n\tif (tz->ops->get_crit_temp)\n\t\treturn tz->ops->get_crit_temp(tz, temp);\n\n\tif (!tz->trips)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tz->lock);\n\n\tfor (i = 0; i < tz->num_trips; i++) {\n\t\tif (tz->trips[i].type == THERMAL_TRIP_CRITICAL) {\n\t\t\t*temp = tz->trips[i].temperature;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tz->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_get_crit_temp);\n\n \nstruct thermal_zone_device *\nthermal_zone_device_register_with_trips(const char *type, struct thermal_trip *trips, int num_trips, int mask,\n\t\t\t\t\tvoid *devdata, struct thermal_zone_device_ops *ops,\n\t\t\t\t\tconst struct thermal_zone_params *tzp, int passive_delay,\n\t\t\t\t\tint polling_delay)\n{\n\tstruct thermal_zone_device *tz;\n\tint id;\n\tint result;\n\tint count;\n\tstruct thermal_governor *governor;\n\n\tif (!type || strlen(type) == 0) {\n\t\tpr_err(\"No thermal zone type defined\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (strlen(type) >= THERMAL_NAME_LENGTH) {\n\t\tpr_err(\"Thermal zone name (%s) too long, should be under %d chars\\n\",\n\t\t       type, THERMAL_NAME_LENGTH);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (num_trips > (BITS_PER_TYPE(int) - 1) || num_trips < 0 || mask >> num_trips) {\n\t\tpr_err(\"Incorrect number of thermal trips\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!ops) {\n\t\tpr_err(\"Thermal zone device ops not defined\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (num_trips > 0 && !trips)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!thermal_class)\n\t\treturn ERR_PTR(-ENODEV);\n\n\ttz = kzalloc(sizeof(*tz), GFP_KERNEL);\n\tif (!tz)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (tzp) {\n\t\ttz->tzp = kmemdup(tzp, sizeof(*tzp), GFP_KERNEL);\n\t\tif (!tz->tzp) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto free_tz;\n\t\t}\n\t}\n\n\tINIT_LIST_HEAD(&tz->thermal_instances);\n\tida_init(&tz->ida);\n\tmutex_init(&tz->lock);\n\tid = ida_alloc(&thermal_tz_ida, GFP_KERNEL);\n\tif (id < 0) {\n\t\tresult = id;\n\t\tgoto free_tzp;\n\t}\n\n\ttz->id = id;\n\tstrscpy(tz->type, type, sizeof(tz->type));\n\n\tif (!ops->critical)\n\t\tops->critical = thermal_zone_device_critical;\n\n\ttz->ops = ops;\n\ttz->device.class = thermal_class;\n\ttz->devdata = devdata;\n\ttz->trips = trips;\n\ttz->num_trips = num_trips;\n\n\tthermal_set_delay_jiffies(&tz->passive_delay_jiffies, passive_delay);\n\tthermal_set_delay_jiffies(&tz->polling_delay_jiffies, polling_delay);\n\n\t \n\t \n\tresult = thermal_zone_create_device_groups(tz, mask);\n\tif (result)\n\t\tgoto remove_id;\n\n\t \n\tatomic_set(&tz->need_update, 1);\n\n\tresult = dev_set_name(&tz->device, \"thermal_zone%d\", tz->id);\n\tif (result) {\n\t\tthermal_zone_destroy_device_groups(tz);\n\t\tgoto remove_id;\n\t}\n\tresult = device_register(&tz->device);\n\tif (result)\n\t\tgoto release_device;\n\n\tfor (count = 0; count < num_trips; count++) {\n\t\tstruct thermal_trip trip;\n\n\t\tresult = thermal_zone_get_trip(tz, count, &trip);\n\t\tif (result || !trip.temperature)\n\t\t\tset_bit(count, &tz->trips_disabled);\n\t}\n\n\t \n\tmutex_lock(&thermal_governor_lock);\n\n\tif (tz->tzp)\n\t\tgovernor = __find_governor(tz->tzp->governor_name);\n\telse\n\t\tgovernor = def_governor;\n\n\tresult = thermal_set_governor(tz, governor);\n\tif (result) {\n\t\tmutex_unlock(&thermal_governor_lock);\n\t\tgoto unregister;\n\t}\n\n\tmutex_unlock(&thermal_governor_lock);\n\n\tif (!tz->tzp || !tz->tzp->no_hwmon) {\n\t\tresult = thermal_add_hwmon_sysfs(tz);\n\t\tif (result)\n\t\t\tgoto unregister;\n\t}\n\n\tmutex_lock(&thermal_list_lock);\n\tlist_add_tail(&tz->node, &thermal_tz_list);\n\tmutex_unlock(&thermal_list_lock);\n\n\t \n\tbind_tz(tz);\n\n\tINIT_DELAYED_WORK(&tz->poll_queue, thermal_zone_device_check);\n\n\tthermal_zone_device_init(tz);\n\t \n\tif (atomic_cmpxchg(&tz->need_update, 1, 0))\n\t\tthermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\n\n\tthermal_notify_tz_create(tz->id, tz->type);\n\n\treturn tz;\n\nunregister:\n\tdevice_del(&tz->device);\nrelease_device:\n\tput_device(&tz->device);\nremove_id:\n\tida_free(&thermal_tz_ida, id);\nfree_tzp:\n\tkfree(tz->tzp);\nfree_tz:\n\tkfree(tz);\n\treturn ERR_PTR(result);\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_register_with_trips);\n\nstruct thermal_zone_device *thermal_tripless_zone_device_register(\n\t\t\t\t\tconst char *type,\n\t\t\t\t\tvoid *devdata,\n\t\t\t\t\tstruct thermal_zone_device_ops *ops,\n\t\t\t\t\tconst struct thermal_zone_params *tzp)\n{\n\treturn thermal_zone_device_register_with_trips(type, NULL, 0, 0, devdata,\n\t\t\t\t\t\t       ops, tzp, 0, 0);\n}\nEXPORT_SYMBOL_GPL(thermal_tripless_zone_device_register);\n\nvoid *thermal_zone_device_priv(struct thermal_zone_device *tzd)\n{\n\treturn tzd->devdata;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_priv);\n\nconst char *thermal_zone_device_type(struct thermal_zone_device *tzd)\n{\n\treturn tzd->type;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_type);\n\nint thermal_zone_device_id(struct thermal_zone_device *tzd)\n{\n\treturn tzd->id;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_id);\n\nstruct device *thermal_zone_device(struct thermal_zone_device *tzd)\n{\n\treturn &tzd->device;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device);\n\n \nvoid thermal_zone_device_unregister(struct thermal_zone_device *tz)\n{\n\tint tz_id;\n\tstruct thermal_cooling_device *cdev;\n\tstruct thermal_zone_device *pos = NULL;\n\n\tif (!tz)\n\t\treturn;\n\n\ttz_id = tz->id;\n\n\tmutex_lock(&thermal_list_lock);\n\tlist_for_each_entry(pos, &thermal_tz_list, node)\n\t\tif (pos == tz)\n\t\t\tbreak;\n\tif (pos != tz) {\n\t\t \n\t\tmutex_unlock(&thermal_list_lock);\n\t\treturn;\n\t}\n\tlist_del(&tz->node);\n\n\t \n\tlist_for_each_entry(cdev, &thermal_cdev_list, node)\n\t\tif (tz->ops->unbind)\n\t\t\ttz->ops->unbind(tz, cdev);\n\n\tmutex_unlock(&thermal_list_lock);\n\n\tcancel_delayed_work_sync(&tz->poll_queue);\n\n\tthermal_set_governor(tz, NULL);\n\n\tthermal_remove_hwmon_sysfs(tz);\n\tida_free(&thermal_tz_ida, tz->id);\n\tida_destroy(&tz->ida);\n\n\tmutex_lock(&tz->lock);\n\tdevice_del(&tz->device);\n\tmutex_unlock(&tz->lock);\n\n\tkfree(tz->tzp);\n\n\tput_device(&tz->device);\n\n\tthermal_notify_tz_delete(tz_id);\n}\nEXPORT_SYMBOL_GPL(thermal_zone_device_unregister);\n\n \nstruct thermal_zone_device *thermal_zone_get_zone_by_name(const char *name)\n{\n\tstruct thermal_zone_device *pos = NULL, *ref = ERR_PTR(-EINVAL);\n\tunsigned int found = 0;\n\n\tif (!name)\n\t\tgoto exit;\n\n\tmutex_lock(&thermal_list_lock);\n\tlist_for_each_entry(pos, &thermal_tz_list, node)\n\t\tif (!strncasecmp(name, pos->type, THERMAL_NAME_LENGTH)) {\n\t\t\tfound++;\n\t\t\tref = pos;\n\t\t}\n\tmutex_unlock(&thermal_list_lock);\n\n\t \n\tif (found == 0)\n\t\tref = ERR_PTR(-ENODEV);\n\telse if (found > 1)\n\t \n\t\tref = ERR_PTR(-EEXIST);\n\nexit:\n\treturn ref;\n}\nEXPORT_SYMBOL_GPL(thermal_zone_get_zone_by_name);\n\nstatic int thermal_pm_notify(struct notifier_block *nb,\n\t\t\t     unsigned long mode, void *_unused)\n{\n\tstruct thermal_zone_device *tz;\n\n\tswitch (mode) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tatomic_set(&in_suspend, 1);\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\tcase PM_POST_SUSPEND:\n\t\tatomic_set(&in_suspend, 0);\n\t\tlist_for_each_entry(tz, &thermal_tz_list, node) {\n\t\t\tthermal_zone_device_init(tz);\n\t\t\tthermal_zone_device_update(tz,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block thermal_pm_nb = {\n\t.notifier_call = thermal_pm_notify,\n};\n\nstatic int __init thermal_init(void)\n{\n\tint result;\n\n\tresult = thermal_netlink_init();\n\tif (result)\n\t\tgoto error;\n\n\tresult = thermal_register_governors();\n\tif (result)\n\t\tgoto unregister_netlink;\n\n\tthermal_class = kzalloc(sizeof(*thermal_class), GFP_KERNEL);\n\tif (!thermal_class) {\n\t\tresult = -ENOMEM;\n\t\tgoto unregister_governors;\n\t}\n\n\tthermal_class->name = \"thermal\";\n\tthermal_class->dev_release = thermal_release;\n\n\tresult = class_register(thermal_class);\n\tif (result) {\n\t\tkfree(thermal_class);\n\t\tthermal_class = NULL;\n\t\tgoto unregister_governors;\n\t}\n\n\tresult = register_pm_notifier(&thermal_pm_nb);\n\tif (result)\n\t\tpr_warn(\"Thermal: Can not register suspend notifier, return %d\\n\",\n\t\t\tresult);\n\n\treturn 0;\n\nunregister_governors:\n\tthermal_unregister_governors();\nunregister_netlink:\n\tthermal_netlink_exit();\nerror:\n\tmutex_destroy(&thermal_list_lock);\n\tmutex_destroy(&thermal_governor_lock);\n\treturn result;\n}\npostcore_initcall(thermal_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}