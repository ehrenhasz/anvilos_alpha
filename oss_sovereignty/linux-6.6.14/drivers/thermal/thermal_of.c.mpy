{
  "module_name": "thermal_of.c",
  "hash_id": "dc0387f48041991b5b0b992bf8dd75dd3e3b134e6f1ac3f8f647437c3170c875",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/thermal_of.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n#include <linux/types.h>\n#include <linux/string.h>\n\n#include \"thermal_core.h\"\n\n \n\nstatic int of_find_trip_id(struct device_node *np, struct device_node *trip)\n{\n\tstruct device_node *trips;\n\tstruct device_node *t;\n\tint i = 0;\n\n\ttrips = of_get_child_by_name(np, \"trips\");\n\tif (!trips) {\n\t\tpr_err(\"Failed to find 'trips' node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_child_of_node(trips, t) {\n\n\t\tif (t == trip) {\n\t\t\tof_node_put(t);\n\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\n\ti = -ENXIO;\nout:\n\tof_node_put(trips);\n\n\treturn i;\n}\n\n \nstatic const char * const trip_types[] = {\n\t[THERMAL_TRIP_ACTIVE]\t= \"active\",\n\t[THERMAL_TRIP_PASSIVE]\t= \"passive\",\n\t[THERMAL_TRIP_HOT]\t= \"hot\",\n\t[THERMAL_TRIP_CRITICAL]\t= \"critical\",\n};\n\n \nstatic int thermal_of_get_trip_type(struct device_node *np,\n\t\t\t\t    enum thermal_trip_type *type)\n{\n\tconst char *t;\n\tint err, i;\n\n\terr = of_property_read_string(np, \"type\", &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(trip_types); i++)\n\t\tif (!strcasecmp(t, trip_types[i])) {\n\t\t\t*type = i;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}\n\nstatic int thermal_of_populate_trip(struct device_node *np,\n\t\t\t\t    struct thermal_trip *trip)\n{\n\tint prop;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"temperature\", &prop);\n\tif (ret < 0) {\n\t\tpr_err(\"missing temperature property\\n\");\n\t\treturn ret;\n\t}\n\ttrip->temperature = prop;\n\n\tret = of_property_read_u32(np, \"hysteresis\", &prop);\n\tif (ret < 0) {\n\t\tpr_err(\"missing hysteresis property\\n\");\n\t\treturn ret;\n\t}\n\ttrip->hysteresis = prop;\n\n\tret = thermal_of_get_trip_type(np, &trip->type);\n\tif (ret < 0) {\n\t\tpr_err(\"wrong trip type property\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct thermal_trip *thermal_of_trips_init(struct device_node *np, int *ntrips)\n{\n\tstruct thermal_trip *tt;\n\tstruct device_node *trips, *trip;\n\tint ret, count;\n\n\ttrips = of_get_child_by_name(np, \"trips\");\n\tif (!trips) {\n\t\tpr_err(\"Failed to find 'trips' node\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcount = of_get_child_count(trips);\n\tif (!count) {\n\t\tpr_err(\"No trip point defined\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_of_node_put;\n\t}\n\n\ttt = kzalloc(sizeof(*tt) * count, GFP_KERNEL);\n\tif (!tt) {\n\t\tret = -ENOMEM;\n\t\tgoto out_of_node_put;\n\t}\n\n\t*ntrips = count;\n\n\tcount = 0;\n\tfor_each_child_of_node(trips, trip) {\n\t\tret = thermal_of_populate_trip(trip, &tt[count++]);\n\t\tif (ret)\n\t\t\tgoto out_kfree;\n\t}\n\n\tof_node_put(trips);\n\n\treturn tt;\n\nout_kfree:\n\tkfree(tt);\n\t*ntrips = 0;\nout_of_node_put:\n\tof_node_put(trips);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic struct device_node *of_thermal_zone_find(struct device_node *sensor, int id)\n{\n\tstruct device_node *np, *tz;\n\tstruct of_phandle_args sensor_specs;\n\n\tnp = of_find_node_by_name(NULL, \"thermal-zones\");\n\tif (!np) {\n\t\tpr_debug(\"No thermal zones description\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tfor_each_available_child_of_node(np, tz) {\n\n\t\tint count, i;\n\n\t\tcount = of_count_phandle_with_args(tz, \"thermal-sensors\",\n\t\t\t\t\t\t   \"#thermal-sensor-cells\");\n\t\tif (count <= 0) {\n\t\t\tpr_err(\"%pOFn: missing thermal sensor\\n\", tz);\n\t\t\ttz = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < count; i++) {\n\n\t\t\tint ret;\n\n\t\t\tret = of_parse_phandle_with_args(tz, \"thermal-sensors\",\n\t\t\t\t\t\t\t \"#thermal-sensor-cells\",\n\t\t\t\t\t\t\t i, &sensor_specs);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"%pOFn: Failed to read thermal-sensors cells: %d\\n\", tz, ret);\n\t\t\t\ttz = ERR_PTR(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif ((sensor == sensor_specs.np) && id == (sensor_specs.args_count ?\n\t\t\t\t\t\t\t\t  sensor_specs.args[0] : 0)) {\n\t\t\t\tpr_debug(\"sensor %pOFn id=%d belongs to %pOFn\\n\", sensor, id, tz);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\ttz = ERR_PTR(-ENODEV);\nout:\n\tof_node_put(np);\n\treturn tz;\n}\n\nstatic int thermal_of_monitor_init(struct device_node *np, int *delay, int *pdelay)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"polling-delay-passive\", pdelay);\n\tif (ret < 0) {\n\t\tpr_err(\"%pOFn: missing polling-delay-passive property\\n\", np);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"polling-delay\", delay);\n\tif (ret < 0) {\n\t\tpr_err(\"%pOFn: missing polling-delay property\\n\", np);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void thermal_of_parameters_init(struct device_node *np,\n\t\t\t\t       struct thermal_zone_params *tzp)\n{\n\tint coef[2];\n\tint ncoef = ARRAY_SIZE(coef);\n\tint prop, ret;\n\n\ttzp->no_hwmon = true;\n\n\tif (!of_property_read_u32(np, \"sustainable-power\", &prop))\n\t\ttzp->sustainable_power = prop;\n\n\t \n\tret = of_property_read_u32_array(np, \"coefficients\", coef, ncoef);\n\tif (ret) {\n\t\tcoef[0] = 1;\n\t\tcoef[1] = 0;\n\t}\n\n\ttzp->slope = coef[0];\n\ttzp->offset = coef[1];\n}\n\nstatic struct device_node *thermal_of_zone_get_by_name(struct thermal_zone_device *tz)\n{\n\tstruct device_node *np, *tz_np;\n\n\tnp = of_find_node_by_name(NULL, \"thermal-zones\");\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\ttz_np = of_get_child_by_name(np, tz->type);\n\n\tof_node_put(np);\n\n\tif (!tz_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn tz_np;\n}\n\nstatic int __thermal_of_unbind(struct device_node *map_np, int index, int trip_id,\n\t\t\t       struct thermal_zone_device *tz, struct thermal_cooling_device *cdev)\n{\n\tstruct of_phandle_args cooling_spec;\n\tint ret;\n\n\tret = of_parse_phandle_with_args(map_np, \"cooling-device\", \"#cooling-cells\",\n\t\t\t\t\t index, &cooling_spec);\n\n\tif (ret < 0) {\n\t\tpr_err(\"Invalid cooling-device entry\\n\");\n\t\treturn ret;\n\t}\n\n\tof_node_put(cooling_spec.np);\n\n\tif (cooling_spec.args_count < 2) {\n\t\tpr_err(\"wrong reference to cooling device, missing limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cooling_spec.np != cdev->np)\n\t\treturn 0;\n\n\tret = thermal_zone_unbind_cooling_device(tz, trip_id, cdev);\n\tif (ret)\n\t\tpr_err(\"Failed to unbind '%s' with '%s': %d\\n\", tz->type, cdev->type, ret);\n\n\treturn ret;\n}\n\nstatic int __thermal_of_bind(struct device_node *map_np, int index, int trip_id,\n\t\t\t     struct thermal_zone_device *tz, struct thermal_cooling_device *cdev)\n{\n\tstruct of_phandle_args cooling_spec;\n\tint ret, weight = THERMAL_WEIGHT_DEFAULT;\n\n\tof_property_read_u32(map_np, \"contribution\", &weight);\n\n\tret = of_parse_phandle_with_args(map_np, \"cooling-device\", \"#cooling-cells\",\n\t\t\t\t\t index, &cooling_spec);\n\n\tif (ret < 0) {\n\t\tpr_err(\"Invalid cooling-device entry\\n\");\n\t\treturn ret;\n\t}\n\n\tof_node_put(cooling_spec.np);\n\n\tif (cooling_spec.args_count < 2) {\n\t\tpr_err(\"wrong reference to cooling device, missing limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cooling_spec.np != cdev->np)\n\t\treturn 0;\n\n\tret = thermal_zone_bind_cooling_device(tz, trip_id, cdev, cooling_spec.args[1],\n\t\t\t\t\t       cooling_spec.args[0],\n\t\t\t\t\t       weight);\n\tif (ret)\n\t\tpr_err(\"Failed to bind '%s' with '%s': %d\\n\", tz->type, cdev->type, ret);\n\n\treturn ret;\n}\n\nstatic int thermal_of_for_each_cooling_device(struct device_node *tz_np, struct device_node *map_np,\n\t\t\t\t\t      struct thermal_zone_device *tz, struct thermal_cooling_device *cdev,\n\t\t\t\t\t      int (*action)(struct device_node *, int, int,\n\t\t\t\t\t\t\t    struct thermal_zone_device *, struct thermal_cooling_device *))\n{\n\tstruct device_node *tr_np;\n\tint count, i, trip_id;\n\n\ttr_np = of_parse_phandle(map_np, \"trip\", 0);\n\tif (!tr_np)\n\t\treturn -ENODEV;\n\n\ttrip_id = of_find_trip_id(tz_np, tr_np);\n\tif (trip_id < 0)\n\t\treturn trip_id;\n\n\tcount = of_count_phandle_with_args(map_np, \"cooling-device\", \"#cooling-cells\");\n\tif (count <= 0) {\n\t\tpr_err(\"Add a cooling_device property with at least one device\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\taction(map_np, i, trip_id, tz, cdev);\n\n\treturn 0;\n}\n\nstatic int thermal_of_for_each_cooling_maps(struct thermal_zone_device *tz,\n\t\t\t\t\t    struct thermal_cooling_device *cdev,\n\t\t\t\t\t    int (*action)(struct device_node *, int, int,\n\t\t\t\t\t\t\t  struct thermal_zone_device *, struct thermal_cooling_device *))\n{\n\tstruct device_node *tz_np, *cm_np, *child;\n\tint ret = 0;\n\n\ttz_np = thermal_of_zone_get_by_name(tz);\n\tif (IS_ERR(tz_np)) {\n\t\tpr_err(\"Failed to get node tz by name\\n\");\n\t\treturn PTR_ERR(tz_np);\n\t}\n\n\tcm_np = of_get_child_by_name(tz_np, \"cooling-maps\");\n\tif (!cm_np)\n\t\tgoto out;\n\n\tfor_each_child_of_node(cm_np, child) {\n\t\tret = thermal_of_for_each_cooling_device(tz_np, child, tz, cdev, action);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(cm_np);\nout:\n\tof_node_put(tz_np);\n\n\treturn ret;\n}\n\nstatic int thermal_of_bind(struct thermal_zone_device *tz,\n\t\t\t   struct thermal_cooling_device *cdev)\n{\n\treturn thermal_of_for_each_cooling_maps(tz, cdev, __thermal_of_bind);\n}\n\nstatic int thermal_of_unbind(struct thermal_zone_device *tz,\n\t\t\t     struct thermal_cooling_device *cdev)\n{\n\treturn thermal_of_for_each_cooling_maps(tz, cdev, __thermal_of_unbind);\n}\n\n \nstatic void thermal_of_zone_unregister(struct thermal_zone_device *tz)\n{\n\tstruct thermal_trip *trips = tz->trips;\n\tstruct thermal_zone_device_ops *ops = tz->ops;\n\n\tthermal_zone_device_disable(tz);\n\tthermal_zone_device_unregister(tz);\n\tkfree(trips);\n\tkfree(ops);\n}\n\n \nstatic struct thermal_zone_device *thermal_of_zone_register(struct device_node *sensor, int id, void *data,\n\t\t\t\t\t\t\t    const struct thermal_zone_device_ops *ops)\n{\n\tstruct thermal_zone_device *tz;\n\tstruct thermal_trip *trips;\n\tstruct thermal_zone_params tzp = {};\n\tstruct thermal_zone_device_ops *of_ops;\n\tstruct device_node *np;\n\tint delay, pdelay;\n\tint ntrips, mask;\n\tint ret;\n\n\tof_ops = kmemdup(ops, sizeof(*ops), GFP_KERNEL);\n\tif (!of_ops)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnp = of_thermal_zone_find(sensor, id);\n\tif (IS_ERR(np)) {\n\t\tif (PTR_ERR(np) != -ENODEV)\n\t\t\tpr_err(\"Failed to find thermal zone for %pOFn id=%d\\n\", sensor, id);\n\t\tret = PTR_ERR(np);\n\t\tgoto out_kfree_of_ops;\n\t}\n\n\ttrips = thermal_of_trips_init(np, &ntrips);\n\tif (IS_ERR(trips)) {\n\t\tpr_err(\"Failed to find trip points for %pOFn id=%d\\n\", sensor, id);\n\t\tret = PTR_ERR(trips);\n\t\tgoto out_kfree_of_ops;\n\t}\n\n\tret = thermal_of_monitor_init(np, &delay, &pdelay);\n\tif (ret) {\n\t\tpr_err(\"Failed to initialize monitoring delays from %pOFn\\n\", np);\n\t\tgoto out_kfree_trips;\n\t}\n\n\tthermal_of_parameters_init(np, &tzp);\n\n\tof_ops->bind = thermal_of_bind;\n\tof_ops->unbind = thermal_of_unbind;\n\n\tmask = GENMASK_ULL((ntrips) - 1, 0);\n\n\ttz = thermal_zone_device_register_with_trips(np->name, trips, ntrips,\n\t\t\t\t\t\t     mask, data, of_ops, &tzp,\n\t\t\t\t\t\t     pdelay, delay);\n\tif (IS_ERR(tz)) {\n\t\tret = PTR_ERR(tz);\n\t\tpr_err(\"Failed to register thermal zone %pOFn: %d\\n\", np, ret);\n\t\tgoto out_kfree_trips;\n\t}\n\n\tret = thermal_zone_device_enable(tz);\n\tif (ret) {\n\t\tpr_err(\"Failed to enabled thermal zone '%s', id=%d: %d\\n\",\n\t\t       tz->type, tz->id, ret);\n\t\tthermal_of_zone_unregister(tz);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn tz;\n\nout_kfree_trips:\n\tkfree(trips);\nout_kfree_of_ops:\n\tkfree(of_ops);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void devm_thermal_of_zone_release(struct device *dev, void *res)\n{\n\tthermal_of_zone_unregister(*(struct thermal_zone_device **)res);\n}\n\nstatic int devm_thermal_of_zone_match(struct device *dev, void *res,\n\t\t\t\t      void *data)\n{\n\tstruct thermal_zone_device **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\n \nstruct thermal_zone_device *devm_thermal_of_zone_register(struct device *dev, int sensor_id, void *data,\n\t\t\t\t\t\t\t  const struct thermal_zone_device_ops *ops)\n{\n\tstruct thermal_zone_device **ptr, *tzd;\n\n\tptr = devres_alloc(devm_thermal_of_zone_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttzd = thermal_of_zone_register(dev->of_node, sensor_id, data, ops);\n\tif (IS_ERR(tzd)) {\n\t\tdevres_free(ptr);\n\t\treturn tzd;\n\t}\n\n\t*ptr = tzd;\n\tdevres_add(dev, ptr);\n\n\treturn tzd;\n}\nEXPORT_SYMBOL_GPL(devm_thermal_of_zone_register);\n\n \nvoid devm_thermal_of_zone_unregister(struct device *dev, struct thermal_zone_device *tz)\n{\n\tWARN_ON(devres_release(dev, devm_thermal_of_zone_release,\n\t\t\t       devm_thermal_of_zone_match, tz));\n}\nEXPORT_SYMBOL_GPL(devm_thermal_of_zone_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}