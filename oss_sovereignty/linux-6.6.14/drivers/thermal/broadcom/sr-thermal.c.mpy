{
  "module_name": "sr-thermal.c",
  "hash_id": "c0d33be174a19dbeabeec14525836143fed45afec8b423f9f71958ca47e82d63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/broadcom/sr-thermal.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n\n \n#define SR_TMON_TEMP_BASE(id)   ((id) * 0x4)\n\n#define SR_TMON_MAX_LIST        6\n\nstruct sr_tmon {\n\tunsigned int crit_temp;\n\tunsigned int tmon_id;\n\tstruct sr_thermal *priv;\n};\n\nstruct sr_thermal {\n\tvoid __iomem *regs;\n\tunsigned int max_crit_temp;\n\tstruct sr_tmon tmon[SR_TMON_MAX_LIST];\n};\n\nstatic int sr_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct sr_tmon *tmon = thermal_zone_device_priv(tz);\n\tstruct sr_thermal *sr_thermal = tmon->priv;\n\n\t*temp = readl(sr_thermal->regs + SR_TMON_TEMP_BASE(tmon->tmon_id));\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops sr_tz_ops = {\n\t.get_temp = sr_get_temp,\n};\n\nstatic int sr_thermal_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct thermal_zone_device *tz;\n\tstruct sr_thermal *sr_thermal;\n\tstruct sr_tmon *tmon;\n\tstruct resource *res;\n\tu32 sr_tmon_list = 0;\n\tunsigned int i;\n\tint ret;\n\n\tsr_thermal = devm_kzalloc(dev, sizeof(*sr_thermal), GFP_KERNEL);\n\tif (!sr_thermal)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOENT;\n\n\tsr_thermal->regs = (void __iomem *)devm_memremap(&pdev->dev, res->start,\n\t\t\t\t\t\t\t resource_size(res),\n\t\t\t\t\t\t\t MEMREMAP_WB);\n\tif (IS_ERR(sr_thermal->regs)) {\n\t\tdev_err(dev, \"failed to get io address\\n\");\n\t\treturn PTR_ERR(sr_thermal->regs);\n\t}\n\n\tret = device_property_read_u32(dev, \"brcm,tmon-mask\", &sr_tmon_list);\n\tif (ret)\n\t\treturn ret;\n\n\ttmon = sr_thermal->tmon;\n\tfor (i = 0; i < SR_TMON_MAX_LIST; i++, tmon++) {\n\t\tif (!(sr_tmon_list & BIT(i)))\n\t\t\tcontinue;\n\n\t\t \n\t\twritel(0, sr_thermal->regs + SR_TMON_TEMP_BASE(i));\n\t\ttmon->tmon_id = i;\n\t\ttmon->priv = sr_thermal;\n\t\ttz = devm_thermal_of_zone_register(dev, i, tmon,\n\t\t\t\t\t\t   &sr_tz_ops);\n\t\tif (IS_ERR(tz))\n\t\t\treturn PTR_ERR(tz);\n\n\t\tdev_dbg(dev, \"thermal sensor %d registered\\n\", i);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sr_thermal_of_match[] = {\n\t{ .compatible = \"brcm,sr-thermal\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sr_thermal_of_match);\n\nstatic struct platform_driver sr_thermal_driver = {\n\t.probe\t\t= sr_thermal_probe,\n\t.driver = {\n\t\t.name = \"sr-thermal\",\n\t\t.of_match_table = sr_thermal_of_match,\n\t},\n};\nmodule_platform_driver(sr_thermal_driver);\n\nMODULE_AUTHOR(\"Pramod Kumar <pramod.kumar@broadcom.com>\");\nMODULE_DESCRIPTION(\"Stingray thermal driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}