{
  "module_name": "bcm2835_thermal.c",
  "hash_id": "187d8b82e3232e4333f5ac697a3e392f46e20fba8c84a5d4c69c2b0f93ad8d51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/broadcom/bcm2835_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n\n#include \"../thermal_hwmon.h\"\n\n#define BCM2835_TS_TSENSCTL\t\t\t0x00\n#define BCM2835_TS_TSENSSTAT\t\t\t0x04\n\n#define BCM2835_TS_TSENSCTL_PRWDW\t\tBIT(0)\n#define BCM2835_TS_TSENSCTL_RSTB\t\tBIT(1)\n\n \n#define BCM2835_TS_TSENSCTL_CTRL_BITS\t\t3\n#define BCM2835_TS_TSENSCTL_CTRL_SHIFT\t\t2\n#define BCM2835_TS_TSENSCTL_CTRL_MASK\t\t    \\\n\tGENMASK(BCM2835_TS_TSENSCTL_CTRL_BITS +     \\\n\t\tBCM2835_TS_TSENSCTL_CTRL_SHIFT - 1, \\\n\t\tBCM2835_TS_TSENSCTL_CTRL_SHIFT)\n#define BCM2835_TS_TSENSCTL_CTRL_DEFAULT\t1\n#define BCM2835_TS_TSENSCTL_EN_INT\t\tBIT(5)\n#define BCM2835_TS_TSENSCTL_DIRECT\t\tBIT(6)\n#define BCM2835_TS_TSENSCTL_CLR_INT\t\tBIT(7)\n#define BCM2835_TS_TSENSCTL_THOLD_SHIFT\t\t8\n#define BCM2835_TS_TSENSCTL_THOLD_BITS\t\t10\n#define BCM2835_TS_TSENSCTL_THOLD_MASK\t\t     \\\n\tGENMASK(BCM2835_TS_TSENSCTL_THOLD_BITS +     \\\n\t\tBCM2835_TS_TSENSCTL_THOLD_SHIFT - 1, \\\n\t\tBCM2835_TS_TSENSCTL_THOLD_SHIFT)\n \n#define BCM2835_TS_TSENSCTL_RSTDELAY_SHIFT\t18\n#define BCM2835_TS_TSENSCTL_RSTDELAY_BITS\t8\n#define BCM2835_TS_TSENSCTL_REGULEN\t\tBIT(26)\n\n#define BCM2835_TS_TSENSSTAT_DATA_BITS\t\t10\n#define BCM2835_TS_TSENSSTAT_DATA_SHIFT\t\t0\n#define BCM2835_TS_TSENSSTAT_DATA_MASK\t\t     \\\n\tGENMASK(BCM2835_TS_TSENSSTAT_DATA_BITS +     \\\n\t\tBCM2835_TS_TSENSSTAT_DATA_SHIFT - 1, \\\n\t\tBCM2835_TS_TSENSSTAT_DATA_SHIFT)\n#define BCM2835_TS_TSENSSTAT_VALID\t\tBIT(10)\n#define BCM2835_TS_TSENSSTAT_INTERRUPT\t\tBIT(11)\n\nstruct bcm2835_thermal_data {\n\tstruct thermal_zone_device *tz;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct dentry *debugfsdir;\n};\n\nstatic int bcm2835_thermal_adc2temp(u32 adc, int offset, int slope)\n{\n\treturn offset + slope * adc;\n}\n\nstatic int bcm2835_thermal_temp2adc(int temp, int offset, int slope)\n{\n\ttemp -= offset;\n\ttemp /= slope;\n\n\tif (temp < 0)\n\t\ttemp = 0;\n\tif (temp >= BIT(BCM2835_TS_TSENSSTAT_DATA_BITS))\n\t\ttemp = BIT(BCM2835_TS_TSENSSTAT_DATA_BITS) - 1;\n\n\treturn temp;\n}\n\nstatic int bcm2835_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct bcm2835_thermal_data *data = thermal_zone_device_priv(tz);\n\tu32 val = readl(data->regs + BCM2835_TS_TSENSSTAT);\n\n\tif (!(val & BCM2835_TS_TSENSSTAT_VALID))\n\t\treturn -EIO;\n\n\tval &= BCM2835_TS_TSENSSTAT_DATA_MASK;\n\n\t*temp = bcm2835_thermal_adc2temp(\n\t\tval,\n\t\tthermal_zone_get_offset(data->tz),\n\t\tthermal_zone_get_slope(data->tz));\n\n\treturn 0;\n}\n\nstatic const struct debugfs_reg32 bcm2835_thermal_regs[] = {\n\t{\n\t\t.name = \"ctl\",\n\t\t.offset = 0\n\t},\n\t{\n\t\t.name = \"stat\",\n\t\t.offset = 4\n\t}\n};\n\nstatic void bcm2835_thermal_debugfs(struct platform_device *pdev)\n{\n\tstruct bcm2835_thermal_data *data = platform_get_drvdata(pdev);\n\tstruct debugfs_regset32 *regset;\n\n\tdata->debugfsdir = debugfs_create_dir(\"bcm2835_thermal\", NULL);\n\n\tregset = devm_kzalloc(&pdev->dev, sizeof(*regset), GFP_KERNEL);\n\tif (!regset)\n\t\treturn;\n\n\tregset->regs = bcm2835_thermal_regs;\n\tregset->nregs = ARRAY_SIZE(bcm2835_thermal_regs);\n\tregset->base = data->regs;\n\n\tdebugfs_create_regset32(\"regset\", 0444, data->debugfsdir, regset);\n}\n\nstatic const struct thermal_zone_device_ops bcm2835_thermal_ops = {\n\t.get_temp = bcm2835_thermal_get_temp,\n};\n\n \n\nstatic const struct of_device_id bcm2835_thermal_of_match_table[] = {\n\t{\n\t\t.compatible = \"brcm,bcm2835-thermal\",\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm2836-thermal\",\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm2837-thermal\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm2835_thermal_of_match_table);\n\nstatic int bcm2835_thermal_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct thermal_zone_device *tz;\n\tstruct bcm2835_thermal_data *data;\n\tint err = 0;\n\tu32 val;\n\tunsigned long rate;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(bcm2835_thermal_of_match_table,\n\t\t\t\t&pdev->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tdata->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(data->regs)) {\n\t\terr = PTR_ERR(data->regs);\n\t\treturn err;\n\t}\n\n\tdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(data->clk)) {\n\t\terr = PTR_ERR(data->clk);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Could not get clk: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(data->clk);\n\tif (err)\n\t\treturn err;\n\n\trate = clk_get_rate(data->clk);\n\tif ((rate < 1920000) || (rate > 5000000))\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Clock %pCn running at %lu Hz is outside of the recommended range: 1.92 to 5MHz\\n\",\n\t\t\t data->clk, rate);\n\n\t \n\ttz = devm_thermal_of_zone_register(&pdev->dev, 0, data,\n\t\t\t\t\t   &bcm2835_thermal_ops);\n\tif (IS_ERR(tz)) {\n\t\terr = PTR_ERR(tz);\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register the thermal device: %d\\n\",\n\t\t\terr);\n\t\tgoto err_clk;\n\t}\n\n\t \n\tval = readl(data->regs + BCM2835_TS_TSENSCTL);\n\tif (!(val & BCM2835_TS_TSENSCTL_RSTB)) {\n\t\tstruct thermal_trip trip;\n\t\tint offset, slope;\n\n\t\tslope = thermal_zone_get_slope(tz);\n\t\toffset = thermal_zone_get_offset(tz);\n\t\t \n\t\terr = thermal_zone_get_trip(tz, 0, &trip);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Not able to read trip_temp: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto err_tz;\n\t\t}\n\n\t\t \n\t\tval = (BCM2835_TS_TSENSCTL_CTRL_DEFAULT <<\n\t\t       BCM2835_TS_TSENSCTL_CTRL_SHIFT) |\n\t\t      BCM2835_TS_TSENSCTL_REGULEN;\n\n\t\t \n\t\tval |= (0xFE << BCM2835_TS_TSENSCTL_RSTDELAY_SHIFT);\n\n\t\t \n\t\tval |= bcm2835_thermal_temp2adc(trip.temperature,\n\t\t\t\t\t\toffset,\n\t\t\t\t\t\tslope)\n\t\t\t<< BCM2835_TS_TSENSCTL_THOLD_SHIFT;\n\n\t\t \n\t\twritel(val, data->regs + BCM2835_TS_TSENSCTL);\n\t\tval |= BCM2835_TS_TSENSCTL_RSTB;\n\t\twritel(val, data->regs + BCM2835_TS_TSENSCTL);\n\t}\n\n\tdata->tz = tz;\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\terr = thermal_add_hwmon_sysfs(tz);\n\tif (err)\n\t\tgoto err_tz;\n\n\tbcm2835_thermal_debugfs(pdev);\n\n\treturn 0;\nerr_tz:\n\tdevm_thermal_of_zone_unregister(&pdev->dev, tz);\nerr_clk:\n\tclk_disable_unprepare(data->clk);\n\n\treturn err;\n}\n\nstatic int bcm2835_thermal_remove(struct platform_device *pdev)\n{\n\tstruct bcm2835_thermal_data *data = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(data->debugfsdir);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver bcm2835_thermal_driver = {\n\t.probe = bcm2835_thermal_probe,\n\t.remove = bcm2835_thermal_remove,\n\t.driver = {\n\t\t.name = \"bcm2835_thermal\",\n\t\t.of_match_table = bcm2835_thermal_of_match_table,\n\t},\n};\nmodule_platform_driver(bcm2835_thermal_driver);\n\nMODULE_AUTHOR(\"Martin Sperl\");\nMODULE_DESCRIPTION(\"Thermal driver for bcm2835 chip\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}