{
  "module_name": "brcmstb_thermal.c",
  "hash_id": "56e79ceea7eceda3339d699fa9517557bab8e1085670776ce3b2fe651945560c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/broadcom/brcmstb_thermal.c",
  "human_readable_source": "\n \n\n#define DRV_NAME\t\"brcmstb_thermal\"\n\n#define pr_fmt(fmt)\tDRV_NAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irqreturn.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n\n#define AVS_TMON_STATUS\t\t\t0x00\n #define AVS_TMON_STATUS_valid_msk\tBIT(11)\n #define AVS_TMON_STATUS_data_msk\tGENMASK(10, 1)\n #define AVS_TMON_STATUS_data_shift\t1\n\n#define AVS_TMON_EN_OVERTEMP_RESET\t0x04\n #define AVS_TMON_EN_OVERTEMP_RESET_msk\tBIT(0)\n\n#define AVS_TMON_RESET_THRESH\t\t0x08\n #define AVS_TMON_RESET_THRESH_msk\tGENMASK(10, 1)\n #define AVS_TMON_RESET_THRESH_shift\t1\n\n#define AVS_TMON_INT_IDLE_TIME\t\t0x10\n\n#define AVS_TMON_EN_TEMP_INT_SRCS\t0x14\n #define AVS_TMON_EN_TEMP_INT_SRCS_high\tBIT(1)\n #define AVS_TMON_EN_TEMP_INT_SRCS_low\tBIT(0)\n\n#define AVS_TMON_INT_THRESH\t\t0x18\n #define AVS_TMON_INT_THRESH_high_msk\tGENMASK(26, 17)\n #define AVS_TMON_INT_THRESH_high_shift\t17\n #define AVS_TMON_INT_THRESH_low_msk\tGENMASK(10, 1)\n #define AVS_TMON_INT_THRESH_low_shift\t1\n\n#define AVS_TMON_TEMP_INT_CODE\t\t0x1c\n#define AVS_TMON_TP_TEST_ENABLE\t\t0x20\n\n \n#define AVS_TMON_TEMP_SLOPE\t\t487\n#define AVS_TMON_TEMP_OFFSET\t\t410040\n\n \n#define AVS_TMON_TEMP_MAX\t\t0x3ff\n#define AVS_TMON_TEMP_MIN\t\t-88161\n#define AVS_TMON_TEMP_MASK\t\tAVS_TMON_TEMP_MAX\n\nenum avs_tmon_trip_type {\n\tTMON_TRIP_TYPE_LOW = 0,\n\tTMON_TRIP_TYPE_HIGH,\n\tTMON_TRIP_TYPE_RESET,\n\tTMON_TRIP_TYPE_MAX,\n};\n\nstruct avs_tmon_trip {\n\t \n\tu32 enable_offs;\n\tu32 enable_mask;\n\n\t \n\tu32 reg_offs;\n\tu32 reg_msk;\n\tint reg_shift;\n};\n\nstatic struct avs_tmon_trip avs_tmon_trips[] = {\n\t \n\t[TMON_TRIP_TYPE_LOW] = {\n\t\t.enable_offs\t= AVS_TMON_EN_TEMP_INT_SRCS,\n\t\t.enable_mask\t= AVS_TMON_EN_TEMP_INT_SRCS_low,\n\t\t.reg_offs\t= AVS_TMON_INT_THRESH,\n\t\t.reg_msk\t= AVS_TMON_INT_THRESH_low_msk,\n\t\t.reg_shift\t= AVS_TMON_INT_THRESH_low_shift,\n\t},\n\t \n\t[TMON_TRIP_TYPE_HIGH] = {\n\t\t.enable_offs\t= AVS_TMON_EN_TEMP_INT_SRCS,\n\t\t.enable_mask\t= AVS_TMON_EN_TEMP_INT_SRCS_high,\n\t\t.reg_offs\t= AVS_TMON_INT_THRESH,\n\t\t.reg_msk\t= AVS_TMON_INT_THRESH_high_msk,\n\t\t.reg_shift\t= AVS_TMON_INT_THRESH_high_shift,\n\t},\n\t \n\t[TMON_TRIP_TYPE_RESET] = {\n\t\t.enable_offs\t= AVS_TMON_EN_OVERTEMP_RESET,\n\t\t.enable_mask\t= AVS_TMON_EN_OVERTEMP_RESET_msk,\n\t\t.reg_offs\t= AVS_TMON_RESET_THRESH,\n\t\t.reg_msk\t= AVS_TMON_RESET_THRESH_msk,\n\t\t.reg_shift\t= AVS_TMON_RESET_THRESH_shift,\n\t},\n};\n\nstruct brcmstb_thermal_params {\n\tunsigned int offset;\n\tunsigned int mult;\n\tconst struct thermal_zone_device_ops *of_ops;\n};\n\nstruct brcmstb_thermal_priv {\n\tvoid __iomem *tmon_base;\n\tstruct device *dev;\n\tstruct thermal_zone_device *thermal;\n\t \n\tconst struct brcmstb_thermal_params *temp_params;\n};\n\n \nstatic inline int avs_tmon_code_to_temp(struct brcmstb_thermal_priv *priv,\n\t\t\t\t\tu32 code)\n{\n\tint offset = priv->temp_params->offset;\n\tint mult = priv->temp_params->mult;\n\n\treturn (offset - (int)((code & AVS_TMON_TEMP_MASK) * mult));\n}\n\n \nstatic inline u32 avs_tmon_temp_to_code(struct brcmstb_thermal_priv *priv,\n\t\t\t\t\tint temp, bool low)\n{\n\tint offset = priv->temp_params->offset;\n\tint mult = priv->temp_params->mult;\n\n\tif (temp < AVS_TMON_TEMP_MIN)\n\t\treturn AVS_TMON_TEMP_MAX;\t \n\n\tif (temp >= offset)\n\t\treturn 0;\t \n\n\tif (low)\n\t\treturn (u32)(DIV_ROUND_UP(offset - temp, mult));\n\telse\n\t\treturn (u32)((offset - temp) / mult);\n}\n\nstatic int brcmstb_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct brcmstb_thermal_priv *priv = thermal_zone_device_priv(tz);\n\tu32 val;\n\tlong t;\n\n\tval = __raw_readl(priv->tmon_base + AVS_TMON_STATUS);\n\n\tif (!(val & AVS_TMON_STATUS_valid_msk))\n\t\treturn -EIO;\n\n\tval = (val & AVS_TMON_STATUS_data_msk) >> AVS_TMON_STATUS_data_shift;\n\n\tt = avs_tmon_code_to_temp(priv, val);\n\tif (t < 0)\n\t\t*temp = 0;\n\telse\n\t\t*temp = t;\n\n\treturn 0;\n}\n\nstatic void avs_tmon_trip_enable(struct brcmstb_thermal_priv *priv,\n\t\t\t\t enum avs_tmon_trip_type type, int en)\n{\n\tstruct avs_tmon_trip *trip = &avs_tmon_trips[type];\n\tu32 val = __raw_readl(priv->tmon_base + trip->enable_offs);\n\n\tdev_dbg(priv->dev, \"%sable trip, type %d\\n\", en ? \"en\" : \"dis\", type);\n\n\tif (en)\n\t\tval |= trip->enable_mask;\n\telse\n\t\tval &= ~trip->enable_mask;\n\n\t__raw_writel(val, priv->tmon_base + trip->enable_offs);\n}\n\nstatic int avs_tmon_get_trip_temp(struct brcmstb_thermal_priv *priv,\n\t\t\t\t  enum avs_tmon_trip_type type)\n{\n\tstruct avs_tmon_trip *trip = &avs_tmon_trips[type];\n\tu32 val = __raw_readl(priv->tmon_base + trip->reg_offs);\n\n\tval &= trip->reg_msk;\n\tval >>= trip->reg_shift;\n\n\treturn avs_tmon_code_to_temp(priv, val);\n}\n\nstatic void avs_tmon_set_trip_temp(struct brcmstb_thermal_priv *priv,\n\t\t\t\t   enum avs_tmon_trip_type type,\n\t\t\t\t   int temp)\n{\n\tstruct avs_tmon_trip *trip = &avs_tmon_trips[type];\n\tu32 val, orig;\n\n\tdev_dbg(priv->dev, \"set temp %d to %d\\n\", type, temp);\n\n\t \n\tval = avs_tmon_temp_to_code(priv, temp,\n\t\t\t\t    type == TMON_TRIP_TYPE_LOW);\n\n\tval <<= trip->reg_shift;\n\tval &= trip->reg_msk;\n\n\torig = __raw_readl(priv->tmon_base + trip->reg_offs);\n\torig &= ~trip->reg_msk;\n\torig |= val;\n\t__raw_writel(orig, priv->tmon_base + trip->reg_offs);\n}\n\nstatic int avs_tmon_get_intr_temp(struct brcmstb_thermal_priv *priv)\n{\n\tu32 val;\n\n\tval = __raw_readl(priv->tmon_base + AVS_TMON_TEMP_INT_CODE);\n\treturn avs_tmon_code_to_temp(priv, val);\n}\n\nstatic irqreturn_t brcmstb_tmon_irq_thread(int irq, void *data)\n{\n\tstruct brcmstb_thermal_priv *priv = data;\n\tint low, high, intr;\n\n\tlow = avs_tmon_get_trip_temp(priv, TMON_TRIP_TYPE_LOW);\n\thigh = avs_tmon_get_trip_temp(priv, TMON_TRIP_TYPE_HIGH);\n\tintr = avs_tmon_get_intr_temp(priv);\n\n\tdev_dbg(priv->dev, \"low/intr/high: %d/%d/%d\\n\",\n\t\t\tlow, intr, high);\n\n\t \n\tif (intr >= high)\n\t\tavs_tmon_trip_enable(priv, TMON_TRIP_TYPE_HIGH, 0);\n\t \n\tif (intr <= low)\n\t\tavs_tmon_trip_enable(priv, TMON_TRIP_TYPE_LOW, 0);\n\n\t \n\tthermal_zone_device_update(priv->thermal, intr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int brcmstb_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct brcmstb_thermal_priv *priv = thermal_zone_device_priv(tz);\n\n\tdev_dbg(priv->dev, \"set trips %d <--> %d\\n\", low, high);\n\n\t \n\tif (low <= -INT_MAX) {\n\t\tavs_tmon_trip_enable(priv, TMON_TRIP_TYPE_LOW, 0);\n\t} else {\n\t\tavs_tmon_set_trip_temp(priv, TMON_TRIP_TYPE_LOW, low);\n\t\tavs_tmon_trip_enable(priv, TMON_TRIP_TYPE_LOW, 1);\n\t}\n\n\t \n\tif (high == INT_MAX) {\n\t\tavs_tmon_trip_enable(priv, TMON_TRIP_TYPE_HIGH, 0);\n\t} else {\n\t\tavs_tmon_set_trip_temp(priv, TMON_TRIP_TYPE_HIGH, high);\n\t\tavs_tmon_trip_enable(priv, TMON_TRIP_TYPE_HIGH, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops brcmstb_16nm_of_ops = {\n\t.get_temp\t= brcmstb_get_temp,\n};\n\nstatic const struct brcmstb_thermal_params brcmstb_16nm_params = {\n\t.offset\t= 457829,\n\t.mult\t= 557,\n\t.of_ops\t= &brcmstb_16nm_of_ops,\n};\n\nstatic const struct thermal_zone_device_ops brcmstb_28nm_of_ops = {\n\t.get_temp\t= brcmstb_get_temp,\n\t.set_trips\t= brcmstb_set_trips,\n};\n\nstatic const struct brcmstb_thermal_params brcmstb_28nm_params = {\n\t.offset\t= 410040,\n\t.mult\t= 487,\n\t.of_ops\t= &brcmstb_28nm_of_ops,\n};\n\nstatic const struct of_device_id brcmstb_thermal_id_table[] = {\n\t{ .compatible = \"brcm,avs-tmon-bcm7216\", .data = &brcmstb_16nm_params },\n\t{ .compatible = \"brcm,avs-tmon\", .data = &brcmstb_28nm_params },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, brcmstb_thermal_id_table);\n\nstatic int brcmstb_thermal_probe(struct platform_device *pdev)\n{\n\tconst struct thermal_zone_device_ops *of_ops;\n\tstruct thermal_zone_device *thermal;\n\tstruct brcmstb_thermal_priv *priv;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->temp_params = of_device_get_match_data(&pdev->dev);\n\tif (!priv->temp_params)\n\t\treturn -EINVAL;\n\n\tpriv->tmon_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(priv->tmon_base))\n\t\treturn PTR_ERR(priv->tmon_base);\n\n\tpriv->dev = &pdev->dev;\n\tof_ops = priv->temp_params->of_ops;\n\n\tthermal = devm_thermal_of_zone_register(&pdev->dev, 0, priv,\n\t\t\t\t\t\tof_ops);\n\tif (IS_ERR(thermal)) {\n\t\tret = PTR_ERR(thermal);\n\t\tdev_err(&pdev->dev, \"could not register sensor: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->thermal = thermal;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq >= 0) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tbrcmstb_tmon_irq_thread,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tDRV_NAME, priv);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"could not request IRQ: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_info(&pdev->dev, \"registered AVS TMON of-sensor driver\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver brcmstb_thermal_driver = {\n\t.probe = brcmstb_thermal_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = brcmstb_thermal_id_table,\n\t},\n};\nmodule_platform_driver(brcmstb_thermal_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Brian Norris\");\nMODULE_DESCRIPTION(\"Broadcom STB AVS TMON thermal driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}