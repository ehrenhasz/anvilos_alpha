{
  "module_name": "soctherm.c",
  "hash_id": "3756cb21244ed52f36e7390354072bfcbb95b0cbd070e8c80dd5d2729af7c32a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/tegra/soctherm.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/thermal.h>\n\n#include <dt-bindings/thermal/tegra124-soctherm.h>\n\n#include \"../thermal_core.h\"\n#include \"soctherm.h\"\n\n#define SENSOR_CONFIG0\t\t\t\t0\n#define SENSOR_CONFIG0_STOP\t\t\tBIT(0)\n#define SENSOR_CONFIG0_CPTR_OVER\t\tBIT(2)\n#define SENSOR_CONFIG0_OVER\t\t\tBIT(3)\n#define SENSOR_CONFIG0_TCALC_OVER\t\tBIT(4)\n#define SENSOR_CONFIG0_TALL_MASK\t\t(0xfffff << 8)\n#define SENSOR_CONFIG0_TALL_SHIFT\t\t8\n\n#define SENSOR_CONFIG1\t\t\t\t4\n#define SENSOR_CONFIG1_TSAMPLE_MASK\t\t0x3ff\n#define SENSOR_CONFIG1_TSAMPLE_SHIFT\t\t0\n#define SENSOR_CONFIG1_TIDDQ_EN_MASK\t\t(0x3f << 15)\n#define SENSOR_CONFIG1_TIDDQ_EN_SHIFT\t\t15\n#define SENSOR_CONFIG1_TEN_COUNT_MASK\t\t(0x3f << 24)\n#define SENSOR_CONFIG1_TEN_COUNT_SHIFT\t\t24\n#define SENSOR_CONFIG1_TEMP_ENABLE\t\tBIT(31)\n\n \n\n#define SENSOR_STATUS0\t\t\t\t0xc\n#define SENSOR_STATUS0_VALID_MASK\t\tBIT(31)\n#define SENSOR_STATUS0_CAPTURE_MASK\t\t0xffff\n\n#define SENSOR_STATUS1\t\t\t\t0x10\n#define SENSOR_STATUS1_TEMP_VALID_MASK\t\tBIT(31)\n#define SENSOR_STATUS1_TEMP_MASK\t\t0xffff\n\n#define READBACK_VALUE_MASK\t\t\t0xff00\n#define READBACK_VALUE_SHIFT\t\t\t8\n#define READBACK_ADD_HALF\t\t\tBIT(7)\n#define READBACK_NEGATE\t\t\t\tBIT(0)\n\n \n#define THERMCTL_LVL0_CPU0_EN_MASK\t\tBIT(8)\n#define THERMCTL_LVL0_CPU0_CPU_THROT_MASK\t(0x3 << 5)\n#define THERMCTL_LVL0_CPU0_CPU_THROT_LIGHT\t0x1\n#define THERMCTL_LVL0_CPU0_CPU_THROT_HEAVY\t0x2\n#define THERMCTL_LVL0_CPU0_GPU_THROT_MASK\t(0x3 << 3)\n#define THERMCTL_LVL0_CPU0_GPU_THROT_LIGHT\t0x1\n#define THERMCTL_LVL0_CPU0_GPU_THROT_HEAVY\t0x2\n#define THERMCTL_LVL0_CPU0_MEM_THROT_MASK\tBIT(2)\n#define THERMCTL_LVL0_CPU0_STATUS_MASK\t\t0x3\n\n#define THERMCTL_LVL0_UP_STATS\t\t\t0x10\n#define THERMCTL_LVL0_DN_STATS\t\t\t0x14\n\n#define THERMCTL_INTR_STATUS\t\t\t0x84\n\n#define TH_INTR_MD0_MASK\t\t\tBIT(25)\n#define TH_INTR_MU0_MASK\t\t\tBIT(24)\n#define TH_INTR_GD0_MASK\t\t\tBIT(17)\n#define TH_INTR_GU0_MASK\t\t\tBIT(16)\n#define TH_INTR_CD0_MASK\t\t\tBIT(9)\n#define TH_INTR_CU0_MASK\t\t\tBIT(8)\n#define TH_INTR_PD0_MASK\t\t\tBIT(1)\n#define TH_INTR_PU0_MASK\t\t\tBIT(0)\n#define TH_INTR_IGNORE_MASK\t\t\t0xFCFCFCFC\n\n#define THERMCTL_STATS_CTL\t\t\t0x94\n#define STATS_CTL_CLR_DN\t\t\t0x8\n#define STATS_CTL_EN_DN\t\t\t\t0x4\n#define STATS_CTL_CLR_UP\t\t\t0x2\n#define STATS_CTL_EN_UP\t\t\t\t0x1\n\n#define OC1_CFG\t\t\t\t\t0x310\n#define OC1_CFG_LONG_LATENCY_MASK\t\tBIT(6)\n#define OC1_CFG_HW_RESTORE_MASK\t\t\tBIT(5)\n#define OC1_CFG_PWR_GOOD_MASK_MASK\t\tBIT(4)\n#define OC1_CFG_THROTTLE_MODE_MASK\t\t(0x3 << 2)\n#define OC1_CFG_ALARM_POLARITY_MASK\t\tBIT(1)\n#define OC1_CFG_EN_THROTTLE_MASK\t\tBIT(0)\n\n#define OC1_CNT_THRESHOLD\t\t\t0x314\n#define OC1_THROTTLE_PERIOD\t\t\t0x318\n#define OC1_ALARM_COUNT\t\t\t\t0x31c\n#define OC1_FILTER\t\t\t\t0x320\n#define OC1_STATS\t\t\t\t0x3a8\n\n#define OC_INTR_STATUS\t\t\t\t0x39c\n#define OC_INTR_ENABLE\t\t\t\t0x3a0\n#define OC_INTR_DISABLE\t\t\t\t0x3a4\n#define OC_STATS_CTL\t\t\t\t0x3c4\n#define OC_STATS_CTL_CLR_ALL\t\t\t0x2\n#define OC_STATS_CTL_EN_ALL\t\t\t0x1\n\n#define OC_INTR_OC1_MASK\t\t\tBIT(0)\n#define OC_INTR_OC2_MASK\t\t\tBIT(1)\n#define OC_INTR_OC3_MASK\t\t\tBIT(2)\n#define OC_INTR_OC4_MASK\t\t\tBIT(3)\n#define OC_INTR_OC5_MASK\t\t\tBIT(4)\n\n#define THROT_GLOBAL_CFG\t\t\t0x400\n#define THROT_GLOBAL_ENB_MASK\t\t\tBIT(0)\n\n#define CPU_PSKIP_STATUS\t\t\t0x418\n#define XPU_PSKIP_STATUS_M_MASK\t\t\t(0xff << 12)\n#define XPU_PSKIP_STATUS_N_MASK\t\t\t(0xff << 4)\n#define XPU_PSKIP_STATUS_SW_OVERRIDE_MASK\tBIT(1)\n#define XPU_PSKIP_STATUS_ENABLED_MASK\t\tBIT(0)\n\n#define THROT_PRIORITY_LOCK\t\t\t0x424\n#define THROT_PRIORITY_LOCK_PRIORITY_MASK\t0xff\n\n#define THROT_STATUS\t\t\t\t0x428\n#define THROT_STATUS_BREACH_MASK\t\tBIT(12)\n#define THROT_STATUS_STATE_MASK\t\t\t(0xff << 4)\n#define THROT_STATUS_ENABLED_MASK\t\tBIT(0)\n\n#define THROT_PSKIP_CTRL_LITE_CPU\t\t0x430\n#define THROT_PSKIP_CTRL_ENABLE_MASK            BIT(31)\n#define THROT_PSKIP_CTRL_DIVIDEND_MASK          (0xff << 8)\n#define THROT_PSKIP_CTRL_DIVISOR_MASK           0xff\n#define THROT_PSKIP_CTRL_VECT_GPU_MASK          (0x7 << 16)\n#define THROT_PSKIP_CTRL_VECT_CPU_MASK          (0x7 << 8)\n#define THROT_PSKIP_CTRL_VECT2_CPU_MASK         0x7\n\n#define THROT_VECT_NONE\t\t\t\t0x0  \n#define THROT_VECT_LOW\t\t\t\t0x1  \n#define THROT_VECT_MED\t\t\t\t0x3  \n#define THROT_VECT_HIGH\t\t\t\t0x7  \n\n#define THROT_PSKIP_RAMP_LITE_CPU\t\t0x434\n#define THROT_PSKIP_RAMP_SEQ_BYPASS_MODE_MASK\tBIT(31)\n#define THROT_PSKIP_RAMP_DURATION_MASK\t\t(0xffff << 8)\n#define THROT_PSKIP_RAMP_STEP_MASK\t\t0xff\n\n#define THROT_PRIORITY_LITE\t\t\t0x444\n#define THROT_PRIORITY_LITE_PRIO_MASK\t\t0xff\n\n#define THROT_DELAY_LITE\t\t\t0x448\n#define THROT_DELAY_LITE_DELAY_MASK\t\t0xff\n\n \n#define CAR_SUPER_CCLKG_DIVIDER\t\t\t0x36c\n#define CDIVG_USE_THERM_CONTROLS_MASK\t\tBIT(30)\n\n \n#define CCROC_SUPER_CCLKG_DIVIDER\t\t0x024\n\n#define CCROC_GLOBAL_CFG\t\t\t0x148\n\n#define CCROC_THROT_PSKIP_RAMP_CPU\t\t0x150\n#define CCROC_THROT_PSKIP_RAMP_SEQ_BYPASS_MODE_MASK\tBIT(31)\n#define CCROC_THROT_PSKIP_RAMP_DURATION_MASK\t(0xffff << 8)\n#define CCROC_THROT_PSKIP_RAMP_STEP_MASK\t0xff\n\n#define CCROC_THROT_PSKIP_CTRL_CPU\t\t0x154\n#define CCROC_THROT_PSKIP_CTRL_ENB_MASK\t\tBIT(31)\n#define CCROC_THROT_PSKIP_CTRL_DIVIDEND_MASK\t(0xff << 8)\n#define CCROC_THROT_PSKIP_CTRL_DIVISOR_MASK\t0xff\n\n \n#define REG_GET_MASK(r, m)\t(((r) & (m)) >> (ffs(m) - 1))\n \n#define REG_SET_MASK(r, m, v)\t(((r) & ~(m)) | \\\n\t\t\t\t (((v) & (m >> (ffs(m) - 1))) << (ffs(m) - 1)))\n\n \n#define THROT_DEPTH_DIVIDEND(depth)\t((256 * (100 - (depth)) / 100) - 1)\n\n \n#define THROT_LEVEL_TO_DEPTH(level)\t((0x1 << (level)) - 1)\n\n \n#define THROT_OFFSET\t\t\t0x30\n#define THROT_PSKIP_CTRL(throt, dev)\t(THROT_PSKIP_CTRL_LITE_CPU + \\\n\t\t\t\t\t(THROT_OFFSET * throt) + (8 * dev))\n#define THROT_PSKIP_RAMP(throt, dev)\t(THROT_PSKIP_RAMP_LITE_CPU + \\\n\t\t\t\t\t(THROT_OFFSET * throt) + (8 * dev))\n\n \n#define THROT_PRIORITY_CTRL(throt)\t(THROT_PRIORITY_LITE + \\\n\t\t\t\t\t(THROT_OFFSET * throt))\n#define THROT_DELAY_CTRL(throt)\t\t(THROT_DELAY_LITE + \\\n\t\t\t\t\t(THROT_OFFSET * throt))\n\n#define ALARM_OFFSET\t\t\t0x14\n#define ALARM_CFG(throt)\t\t(OC1_CFG + \\\n\t\t\t\t\t(ALARM_OFFSET * (throt - THROTTLE_OC1)))\n\n#define ALARM_CNT_THRESHOLD(throt)\t(OC1_CNT_THRESHOLD + \\\n\t\t\t\t\t(ALARM_OFFSET * (throt - THROTTLE_OC1)))\n\n#define ALARM_THROTTLE_PERIOD(throt)\t(OC1_THROTTLE_PERIOD + \\\n\t\t\t\t\t(ALARM_OFFSET * (throt - THROTTLE_OC1)))\n\n#define ALARM_ALARM_COUNT(throt)\t(OC1_ALARM_COUNT + \\\n\t\t\t\t\t(ALARM_OFFSET * (throt - THROTTLE_OC1)))\n\n#define ALARM_FILTER(throt)\t\t(OC1_FILTER + \\\n\t\t\t\t\t(ALARM_OFFSET * (throt - THROTTLE_OC1)))\n\n#define ALARM_STATS(throt)\t\t(OC1_STATS + \\\n\t\t\t\t\t(4 * (throt - THROTTLE_OC1)))\n\n \n#define CCROC_THROT_OFFSET\t\t\t0x0c\n#define CCROC_THROT_PSKIP_CTRL_CPU_REG(vect)    (CCROC_THROT_PSKIP_CTRL_CPU + \\\n\t\t\t\t\t\t(CCROC_THROT_OFFSET * vect))\n#define CCROC_THROT_PSKIP_RAMP_CPU_REG(vect)    (CCROC_THROT_PSKIP_RAMP_CPU + \\\n\t\t\t\t\t\t(CCROC_THROT_OFFSET * vect))\n\n \n#define THERMCTL_LVL_REGS_SIZE\t\t0x20\n#define THERMCTL_LVL_REG(rg, lv)\t((rg) + ((lv) * THERMCTL_LVL_REGS_SIZE))\n\n#define OC_THROTTLE_MODE_DISABLED\t0\n#define OC_THROTTLE_MODE_BRIEF\t\t2\n\nstatic const int min_low_temp = -127000;\nstatic const int max_high_temp = 127000;\n\nenum soctherm_throttle_id {\n\tTHROTTLE_LIGHT = 0,\n\tTHROTTLE_HEAVY,\n\tTHROTTLE_OC1,\n\tTHROTTLE_OC2,\n\tTHROTTLE_OC3,\n\tTHROTTLE_OC4,\n\tTHROTTLE_OC5,  \n\tTHROTTLE_SIZE,\n};\n\nenum soctherm_oc_irq_id {\n\tTEGRA_SOC_OC_IRQ_1,\n\tTEGRA_SOC_OC_IRQ_2,\n\tTEGRA_SOC_OC_IRQ_3,\n\tTEGRA_SOC_OC_IRQ_4,\n\tTEGRA_SOC_OC_IRQ_5,\n\tTEGRA_SOC_OC_IRQ_MAX,\n};\n\nenum soctherm_throttle_dev_id {\n\tTHROTTLE_DEV_CPU = 0,\n\tTHROTTLE_DEV_GPU,\n\tTHROTTLE_DEV_SIZE,\n};\n\nstatic const char *const throt_names[] = {\n\t[THROTTLE_LIGHT] = \"light\",\n\t[THROTTLE_HEAVY] = \"heavy\",\n\t[THROTTLE_OC1]   = \"oc1\",\n\t[THROTTLE_OC2]   = \"oc2\",\n\t[THROTTLE_OC3]   = \"oc3\",\n\t[THROTTLE_OC4]   = \"oc4\",\n\t[THROTTLE_OC5]   = \"oc5\",\n};\n\nstruct tegra_soctherm;\nstruct tegra_thermctl_zone {\n\tvoid __iomem *reg;\n\tstruct device *dev;\n\tstruct tegra_soctherm *ts;\n\tstruct thermal_zone_device *tz;\n\tconst struct tegra_tsensor_group *sg;\n};\n\nstruct soctherm_oc_cfg {\n\tu32 active_low;\n\tu32 throt_period;\n\tu32 alarm_cnt_thresh;\n\tu32 alarm_filter;\n\tu32 mode;\n\tbool intr_en;\n};\n\nstruct soctherm_throt_cfg {\n\tconst char *name;\n\tunsigned int id;\n\tu8 priority;\n\tu8 cpu_throt_level;\n\tu32 cpu_throt_depth;\n\tu32 gpu_throt_level;\n\tstruct soctherm_oc_cfg oc_cfg;\n\tstruct thermal_cooling_device *cdev;\n\tbool init;\n};\n\nstruct tegra_soctherm {\n\tstruct reset_control *reset;\n\tstruct clk *clock_tsensor;\n\tstruct clk *clock_soctherm;\n\tvoid __iomem *regs;\n\tvoid __iomem *clk_regs;\n\tvoid __iomem *ccroc_regs;\n\n\tint thermal_irq;\n\tint edp_irq;\n\n\tu32 *calib;\n\tstruct thermal_zone_device **thermctl_tzs;\n\tstruct tegra_soctherm_soc *soc;\n\n\tstruct soctherm_throt_cfg throt_cfgs[THROTTLE_SIZE];\n\n\tstruct dentry *debugfs_dir;\n\n\tstruct mutex thermctl_lock;\n};\n\nstruct soctherm_oc_irq_chip_data {\n\tstruct mutex\t\tirq_lock;  \n\tstruct irq_chip\t\tirq_chip;\n\tstruct irq_domain\t*domain;\n\tint\t\t\tirq_enable;\n};\n\nstatic struct soctherm_oc_irq_chip_data soc_irq_cdata;\n\n \nstatic inline void ccroc_writel(struct tegra_soctherm *ts, u32 value, u32 reg)\n{\n\twritel(value, (ts->ccroc_regs + reg));\n}\n\n \nstatic inline u32 ccroc_readl(struct tegra_soctherm *ts, u32 reg)\n{\n\treturn readl(ts->ccroc_regs + reg);\n}\n\nstatic void enable_tsensor(struct tegra_soctherm *tegra, unsigned int i)\n{\n\tconst struct tegra_tsensor *sensor = &tegra->soc->tsensors[i];\n\tvoid __iomem *base = tegra->regs + sensor->base;\n\tunsigned int val;\n\n\tval = sensor->config->tall << SENSOR_CONFIG0_TALL_SHIFT;\n\twritel(val, base + SENSOR_CONFIG0);\n\n\tval  = (sensor->config->tsample - 1) << SENSOR_CONFIG1_TSAMPLE_SHIFT;\n\tval |= sensor->config->tiddq_en << SENSOR_CONFIG1_TIDDQ_EN_SHIFT;\n\tval |= sensor->config->ten_count << SENSOR_CONFIG1_TEN_COUNT_SHIFT;\n\tval |= SENSOR_CONFIG1_TEMP_ENABLE;\n\twritel(val, base + SENSOR_CONFIG1);\n\n\twritel(tegra->calib[i], base + SENSOR_CONFIG2);\n}\n\n \nstatic int translate_temp(u16 val)\n{\n\tint t;\n\n\tt = ((val & READBACK_VALUE_MASK) >> READBACK_VALUE_SHIFT) * 1000;\n\tif (val & READBACK_ADD_HALF)\n\t\tt += 500;\n\tif (val & READBACK_NEGATE)\n\t\tt *= -1;\n\n\treturn t;\n}\n\nstatic int tegra_thermctl_get_temp(struct thermal_zone_device *tz, int *out_temp)\n{\n\tstruct tegra_thermctl_zone *zone = thermal_zone_device_priv(tz);\n\tu32 val;\n\n\tval = readl(zone->reg);\n\tval = REG_GET_MASK(val, zone->sg->sensor_temp_mask);\n\t*out_temp = translate_temp(val);\n\n\treturn 0;\n}\n\n \nstatic int enforce_temp_range(struct device *dev, int trip_temp)\n{\n\tint temp;\n\n\ttemp = clamp_val(trip_temp, min_low_temp, max_high_temp);\n\tif (temp != trip_temp)\n\t\tdev_dbg(dev, \"soctherm: trip temperature %d forced to %d\\n\",\n\t\t\ttrip_temp, temp);\n\treturn temp;\n}\n\n \nstatic int thermtrip_program(struct device *dev,\n\t\t\t     const struct tegra_tsensor_group *sg,\n\t\t\t     int trip_temp)\n{\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tint temp;\n\tu32 r;\n\n\tif (!sg || !sg->thermtrip_threshold_mask)\n\t\treturn -EINVAL;\n\n\ttemp = enforce_temp_range(dev, trip_temp) / ts->soc->thresh_grain;\n\n\tr = readl(ts->regs + THERMCTL_THERMTRIP_CTL);\n\tr = REG_SET_MASK(r, sg->thermtrip_threshold_mask, temp);\n\tr = REG_SET_MASK(r, sg->thermtrip_enable_mask, 1);\n\tr = REG_SET_MASK(r, sg->thermtrip_any_en_mask, 0);\n\twritel(r, ts->regs + THERMCTL_THERMTRIP_CTL);\n\n\treturn 0;\n}\n\n \nstatic int throttrip_program(struct device *dev,\n\t\t\t     const struct tegra_tsensor_group *sg,\n\t\t\t     struct soctherm_throt_cfg *stc,\n\t\t\t     int trip_temp)\n{\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tint temp, cpu_throt, gpu_throt;\n\tunsigned int throt;\n\tu32 r, reg_off;\n\n\tif (!sg || !stc || !stc->init)\n\t\treturn -EINVAL;\n\n\ttemp = enforce_temp_range(dev, trip_temp) / ts->soc->thresh_grain;\n\n\t \n\tthrot = stc->id;\n\treg_off = THERMCTL_LVL_REG(sg->thermctl_lvl0_offset, throt + 1);\n\n\tif (throt == THROTTLE_LIGHT) {\n\t\tcpu_throt = THERMCTL_LVL0_CPU0_CPU_THROT_LIGHT;\n\t\tgpu_throt = THERMCTL_LVL0_CPU0_GPU_THROT_LIGHT;\n\t} else {\n\t\tcpu_throt = THERMCTL_LVL0_CPU0_CPU_THROT_HEAVY;\n\t\tgpu_throt = THERMCTL_LVL0_CPU0_GPU_THROT_HEAVY;\n\t\tif (throt != THROTTLE_HEAVY)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"invalid throt id %d - assuming HEAVY\",\n\t\t\t\t throt);\n\t}\n\n\tr = readl(ts->regs + reg_off);\n\tr = REG_SET_MASK(r, sg->thermctl_lvl0_up_thresh_mask, temp);\n\tr = REG_SET_MASK(r, sg->thermctl_lvl0_dn_thresh_mask, temp);\n\tr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_CPU_THROT_MASK, cpu_throt);\n\tr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_GPU_THROT_MASK, gpu_throt);\n\tr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_EN_MASK, 1);\n\twritel(r, ts->regs + reg_off);\n\n\treturn 0;\n}\n\nstatic struct soctherm_throt_cfg *\nfind_throttle_cfg_by_name(struct tegra_soctherm *ts, const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; ts->throt_cfgs[i].name; i++)\n\t\tif (!strcmp(ts->throt_cfgs[i].name, name))\n\t\t\treturn &ts->throt_cfgs[i];\n\n\treturn NULL;\n}\n\nstatic int tsensor_group_thermtrip_get(struct tegra_soctherm *ts, int id)\n{\n\tint i, temp = min_low_temp;\n\tstruct tsensor_group_thermtrips *tt = ts->soc->thermtrips;\n\n\tif (id >= TEGRA124_SOCTHERM_SENSOR_NUM)\n\t\treturn temp;\n\n\tif (tt) {\n\t\tfor (i = 0; i < ts->soc->num_ttgs; i++) {\n\t\t\tif (tt[i].id == id)\n\t\t\t\treturn tt[i].temp;\n\t\t}\n\t}\n\n\treturn temp;\n}\n\nstatic int tegra_thermctl_set_trip_temp(struct thermal_zone_device *tz, int trip_id, int temp)\n{\n\tstruct tegra_thermctl_zone *zone = thermal_zone_device_priv(tz);\n\tstruct tegra_soctherm *ts = zone->ts;\n\tstruct thermal_trip trip;\n\tconst struct tegra_tsensor_group *sg = zone->sg;\n\tstruct device *dev = zone->dev;\n\tint ret;\n\n\tif (!tz)\n\t\treturn -EINVAL;\n\n\tret = __thermal_zone_get_trip(tz, trip_id, &trip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trip.type == THERMAL_TRIP_CRITICAL) {\n\t\t \n\t\tif (min_low_temp == tsensor_group_thermtrip_get(ts, sg->id))\n\t\t\treturn thermtrip_program(dev, sg, temp);\n\t\telse\n\t\t\treturn 0;\n\n\t} else if (trip.type == THERMAL_TRIP_HOT) {\n\t\tint i;\n\n\t\tfor (i = 0; i < THROTTLE_SIZE; i++) {\n\t\t\tstruct thermal_cooling_device *cdev;\n\t\t\tstruct soctherm_throt_cfg *stc;\n\n\t\t\tif (!ts->throt_cfgs[i].init)\n\t\t\t\tcontinue;\n\n\t\t\tcdev = ts->throt_cfgs[i].cdev;\n\t\t\tif (get_thermal_instance(tz, cdev, trip_id))\n\t\t\t\tstc = find_throttle_cfg_by_name(ts, cdev->type);\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\treturn throttrip_program(dev, sg, stc, temp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void thermal_irq_enable(struct tegra_thermctl_zone *zn)\n{\n\tu32 r;\n\n\t \n\tmutex_lock(&zn->ts->thermctl_lock);\n\tr = readl(zn->ts->regs + THERMCTL_INTR_ENABLE);\n\tr = REG_SET_MASK(r, zn->sg->thermctl_isr_mask, TH_INTR_UP_DN_EN);\n\twritel(r, zn->ts->regs + THERMCTL_INTR_ENABLE);\n\tmutex_unlock(&zn->ts->thermctl_lock);\n}\n\nstatic void thermal_irq_disable(struct tegra_thermctl_zone *zn)\n{\n\tu32 r;\n\n\t \n\tmutex_lock(&zn->ts->thermctl_lock);\n\tr = readl(zn->ts->regs + THERMCTL_INTR_DISABLE);\n\tr = REG_SET_MASK(r, zn->sg->thermctl_isr_mask, 0);\n\twritel(r, zn->ts->regs + THERMCTL_INTR_DISABLE);\n\tmutex_unlock(&zn->ts->thermctl_lock);\n}\n\nstatic int tegra_thermctl_set_trips(struct thermal_zone_device *tz, int lo, int hi)\n{\n\tstruct tegra_thermctl_zone *zone = thermal_zone_device_priv(tz);\n\tu32 r;\n\n\tthermal_irq_disable(zone);\n\n\tr = readl(zone->ts->regs + zone->sg->thermctl_lvl0_offset);\n\tr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_EN_MASK, 0);\n\twritel(r, zone->ts->regs + zone->sg->thermctl_lvl0_offset);\n\n\tlo = enforce_temp_range(zone->dev, lo) / zone->ts->soc->thresh_grain;\n\thi = enforce_temp_range(zone->dev, hi) / zone->ts->soc->thresh_grain;\n\tdev_dbg(zone->dev, \"%s hi:%d, lo:%d\\n\", __func__, hi, lo);\n\n\tr = REG_SET_MASK(r, zone->sg->thermctl_lvl0_up_thresh_mask, hi);\n\tr = REG_SET_MASK(r, zone->sg->thermctl_lvl0_dn_thresh_mask, lo);\n\tr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_EN_MASK, 1);\n\twritel(r, zone->ts->regs + zone->sg->thermctl_lvl0_offset);\n\n\tthermal_irq_enable(zone);\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops tegra_of_thermal_ops = {\n\t.get_temp = tegra_thermctl_get_temp,\n\t.set_trip_temp = tegra_thermctl_set_trip_temp,\n\t.set_trips = tegra_thermctl_set_trips,\n};\n\nstatic int get_hot_temp(struct thermal_zone_device *tz, int *trip_id, int *temp)\n{\n\tint i, ret;\n\tstruct thermal_trip trip;\n\n\tfor (i = 0; i < thermal_zone_get_num_trips(tz); i++) {\n\n\t\tret = thermal_zone_get_trip(tz, i, &trip);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tif (trip.type == THERMAL_TRIP_HOT) {\n\t\t\t*trip_id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int tegra_soctherm_set_hwtrips(struct device *dev,\n\t\t\t\t      const struct tegra_tsensor_group *sg,\n\t\t\t\t      struct thermal_zone_device *tz)\n{\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tstruct soctherm_throt_cfg *stc;\n\tint i, trip, temperature, ret;\n\n\t \n\ttemperature = tsensor_group_thermtrip_get(ts, sg->id);\n\tif (min_low_temp == temperature)\n\t\tif (thermal_zone_get_crit_temp(tz, &temperature))\n\t\t\ttemperature = max_high_temp;\n\n\tret = thermtrip_program(dev, sg, temperature);\n\tif (ret) {\n\t\tdev_err(dev, \"thermtrip: %s: error during enable\\n\", sg->name);\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"thermtrip: will shut down when %s reaches %d mC\\n\",\n\t\t sg->name, temperature);\n\n\tret = get_hot_temp(tz, &trip, &temperature);\n\tif (ret) {\n\t\tdev_info(dev, \"throttrip: %s: missing hot temperature\\n\",\n\t\t\t sg->name);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < THROTTLE_OC1; i++) {\n\t\tstruct thermal_cooling_device *cdev;\n\n\t\tif (!ts->throt_cfgs[i].init)\n\t\t\tcontinue;\n\n\t\tcdev = ts->throt_cfgs[i].cdev;\n\t\tif (get_thermal_instance(tz, cdev, trip))\n\t\t\tstc = find_throttle_cfg_by_name(ts, cdev->type);\n\t\telse\n\t\t\tcontinue;\n\n\t\tret = throttrip_program(dev, sg, stc, temperature);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"throttrip: %s: error during enable\\n\",\n\t\t\t\tsg->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_info(dev,\n\t\t\t \"throttrip: will throttle when %s reaches %d mC\\n\",\n\t\t\t sg->name, temperature);\n\t\tbreak;\n\t}\n\n\tif (i == THROTTLE_SIZE)\n\t\tdev_info(dev, \"throttrip: %s: missing throttle cdev\\n\",\n\t\t\t sg->name);\n\n\treturn 0;\n}\n\nstatic irqreturn_t soctherm_thermal_isr(int irq, void *dev_id)\n{\n\tstruct tegra_soctherm *ts = dev_id;\n\tu32 r;\n\n\t \n\tr = readl(ts->regs + THERMCTL_INTR_STATUS);\n\twritel(r, ts->regs + THERMCTL_INTR_DISABLE);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t soctherm_thermal_isr_thread(int irq, void *dev_id)\n{\n\tstruct tegra_soctherm *ts = dev_id;\n\tstruct thermal_zone_device *tz;\n\tu32 st, ex = 0, cp = 0, gp = 0, pl = 0, me = 0;\n\n\tst = readl(ts->regs + THERMCTL_INTR_STATUS);\n\n\t \n\tcp |= st & TH_INTR_CD0_MASK;\n\tcp |= st & TH_INTR_CU0_MASK;\n\n\tgp |= st & TH_INTR_GD0_MASK;\n\tgp |= st & TH_INTR_GU0_MASK;\n\n\tpl |= st & TH_INTR_PD0_MASK;\n\tpl |= st & TH_INTR_PU0_MASK;\n\n\tme |= st & TH_INTR_MD0_MASK;\n\tme |= st & TH_INTR_MU0_MASK;\n\n\tex |= cp | gp | pl | me;\n\tif (ex) {\n\t\twritel(ex, ts->regs + THERMCTL_INTR_STATUS);\n\t\tst &= ~ex;\n\n\t\tif (cp) {\n\t\t\ttz = ts->thermctl_tzs[TEGRA124_SOCTHERM_SENSOR_CPU];\n\t\t\tthermal_zone_device_update(tz,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\n\t\tif (gp) {\n\t\t\ttz = ts->thermctl_tzs[TEGRA124_SOCTHERM_SENSOR_GPU];\n\t\t\tthermal_zone_device_update(tz,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\n\t\tif (pl) {\n\t\t\ttz = ts->thermctl_tzs[TEGRA124_SOCTHERM_SENSOR_PLLX];\n\t\t\tthermal_zone_device_update(tz,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\n\t\tif (me) {\n\t\t\ttz = ts->thermctl_tzs[TEGRA124_SOCTHERM_SENSOR_MEM];\n\t\t\tthermal_zone_device_update(tz,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\t}\n\n\t \n\tex |= TH_INTR_IGNORE_MASK;\n\tst &= ~ex;\n\n\tif (st) {\n\t\t \n\t\tpr_err(\"soctherm: Ignored unexpected INTRs 0x%08x\\n\", st);\n\t\twritel(st, ts->regs + THERMCTL_INTR_STATUS);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void soctherm_oc_intr_enable(struct tegra_soctherm *ts,\n\t\t\t\t    enum soctherm_throttle_id alarm,\n\t\t\t\t    bool enable)\n{\n\tu32 r;\n\n\tif (!enable)\n\t\treturn;\n\n\tr = readl(ts->regs + OC_INTR_ENABLE);\n\tswitch (alarm) {\n\tcase THROTTLE_OC1:\n\t\tr = REG_SET_MASK(r, OC_INTR_OC1_MASK, 1);\n\t\tbreak;\n\tcase THROTTLE_OC2:\n\t\tr = REG_SET_MASK(r, OC_INTR_OC2_MASK, 1);\n\t\tbreak;\n\tcase THROTTLE_OC3:\n\t\tr = REG_SET_MASK(r, OC_INTR_OC3_MASK, 1);\n\t\tbreak;\n\tcase THROTTLE_OC4:\n\t\tr = REG_SET_MASK(r, OC_INTR_OC4_MASK, 1);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t\tbreak;\n\t}\n\twritel(r, ts->regs + OC_INTR_ENABLE);\n}\n\n \nstatic int soctherm_handle_alarm(enum soctherm_throttle_id alarm)\n{\n\tint rv = -EINVAL;\n\n\tswitch (alarm) {\n\tcase THROTTLE_OC1:\n\t\tpr_debug(\"soctherm: Successfully handled OC1 alarm\\n\");\n\t\trv = 0;\n\t\tbreak;\n\n\tcase THROTTLE_OC2:\n\t\tpr_debug(\"soctherm: Successfully handled OC2 alarm\\n\");\n\t\trv = 0;\n\t\tbreak;\n\n\tcase THROTTLE_OC3:\n\t\tpr_debug(\"soctherm: Successfully handled OC3 alarm\\n\");\n\t\trv = 0;\n\t\tbreak;\n\n\tcase THROTTLE_OC4:\n\t\tpr_debug(\"soctherm: Successfully handled OC4 alarm\\n\");\n\t\trv = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rv)\n\t\tpr_err(\"soctherm: ERROR in handling %s alarm\\n\",\n\t\t       throt_names[alarm]);\n\n\treturn rv;\n}\n\n \nstatic irqreturn_t soctherm_edp_isr_thread(int irq, void *arg)\n{\n\tstruct tegra_soctherm *ts = arg;\n\tu32 st, ex, oc1, oc2, oc3, oc4;\n\n\tst = readl(ts->regs + OC_INTR_STATUS);\n\n\t \n\toc1 = st & OC_INTR_OC1_MASK;\n\toc2 = st & OC_INTR_OC2_MASK;\n\toc3 = st & OC_INTR_OC3_MASK;\n\toc4 = st & OC_INTR_OC4_MASK;\n\tex = oc1 | oc2 | oc3 | oc4;\n\n\tpr_err(\"soctherm: OC ALARM 0x%08x\\n\", ex);\n\tif (ex) {\n\t\twritel(st, ts->regs + OC_INTR_STATUS);\n\t\tst &= ~ex;\n\n\t\tif (oc1 && !soctherm_handle_alarm(THROTTLE_OC1))\n\t\t\tsoctherm_oc_intr_enable(ts, THROTTLE_OC1, true);\n\n\t\tif (oc2 && !soctherm_handle_alarm(THROTTLE_OC2))\n\t\t\tsoctherm_oc_intr_enable(ts, THROTTLE_OC2, true);\n\n\t\tif (oc3 && !soctherm_handle_alarm(THROTTLE_OC3))\n\t\t\tsoctherm_oc_intr_enable(ts, THROTTLE_OC3, true);\n\n\t\tif (oc4 && !soctherm_handle_alarm(THROTTLE_OC4))\n\t\t\tsoctherm_oc_intr_enable(ts, THROTTLE_OC4, true);\n\n\t\tif (oc1 && soc_irq_cdata.irq_enable & BIT(0))\n\t\t\thandle_nested_irq(\n\t\t\t\tirq_find_mapping(soc_irq_cdata.domain, 0));\n\n\t\tif (oc2 && soc_irq_cdata.irq_enable & BIT(1))\n\t\t\thandle_nested_irq(\n\t\t\t\tirq_find_mapping(soc_irq_cdata.domain, 1));\n\n\t\tif (oc3 && soc_irq_cdata.irq_enable & BIT(2))\n\t\t\thandle_nested_irq(\n\t\t\t\tirq_find_mapping(soc_irq_cdata.domain, 2));\n\n\t\tif (oc4 && soc_irq_cdata.irq_enable & BIT(3))\n\t\t\thandle_nested_irq(\n\t\t\t\tirq_find_mapping(soc_irq_cdata.domain, 3));\n\t}\n\n\tif (st) {\n\t\tpr_err(\"soctherm: Ignored unexpected OC ALARM 0x%08x\\n\", st);\n\t\twritel(st, ts->regs + OC_INTR_STATUS);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t soctherm_edp_isr(int irq, void *arg)\n{\n\tstruct tegra_soctherm *ts = arg;\n\tu32 r;\n\n\tif (!ts)\n\t\treturn IRQ_NONE;\n\n\tr = readl(ts->regs + OC_INTR_STATUS);\n\twritel(r, ts->regs + OC_INTR_DISABLE);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic void soctherm_oc_irq_lock(struct irq_data *data)\n{\n\tstruct soctherm_oc_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&d->irq_lock);\n}\n\n \nstatic void soctherm_oc_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct soctherm_oc_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\n\tmutex_unlock(&d->irq_lock);\n}\n\n \nstatic void soctherm_oc_irq_enable(struct irq_data *data)\n{\n\tstruct soctherm_oc_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\n\td->irq_enable |= BIT(data->hwirq);\n}\n\n \nstatic void soctherm_oc_irq_disable(struct irq_data *data)\n{\n\tstruct soctherm_oc_irq_chip_data *d = irq_data_get_irq_chip_data(data);\n\n\td->irq_enable &= ~BIT(data->hwirq);\n}\n\nstatic int soctherm_oc_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\treturn 0;\n}\n\n \nstatic int soctherm_oc_irq_map(struct irq_domain *h, unsigned int virq,\n\t\tirq_hw_number_t hw)\n{\n\tstruct soctherm_oc_irq_chip_data *data = h->host_data;\n\n\tirq_set_chip_data(virq, data);\n\tirq_set_chip(virq, &data->irq_chip);\n\tirq_set_nested_thread(virq, 1);\n\treturn 0;\n}\n\n \nstatic int soctherm_irq_domain_xlate_twocell(struct irq_domain *d,\n\tstruct device_node *ctrlr, const u32 *intspec, unsigned int intsize,\n\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 2))\n\t\treturn -EINVAL;\n\n\t \n\t*out_hwirq = intspec[0] - 1;\n\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops soctherm_oc_domain_ops = {\n\t.map\t= soctherm_oc_irq_map,\n\t.xlate\t= soctherm_irq_domain_xlate_twocell,\n};\n\n \nstatic int soctherm_oc_int_init(struct device_node *np, int num_irqs)\n{\n\tif (!num_irqs) {\n\t\tpr_info(\"%s(): OC interrupts are not enabled\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmutex_init(&soc_irq_cdata.irq_lock);\n\tsoc_irq_cdata.irq_enable = 0;\n\n\tsoc_irq_cdata.irq_chip.name = \"soc_therm_oc\";\n\tsoc_irq_cdata.irq_chip.irq_bus_lock = soctherm_oc_irq_lock;\n\tsoc_irq_cdata.irq_chip.irq_bus_sync_unlock =\n\t\tsoctherm_oc_irq_sync_unlock;\n\tsoc_irq_cdata.irq_chip.irq_disable = soctherm_oc_irq_disable;\n\tsoc_irq_cdata.irq_chip.irq_enable = soctherm_oc_irq_enable;\n\tsoc_irq_cdata.irq_chip.irq_set_type = soctherm_oc_irq_set_type;\n\tsoc_irq_cdata.irq_chip.irq_set_wake = NULL;\n\n\tsoc_irq_cdata.domain = irq_domain_add_linear(np, num_irqs,\n\t\t\t\t\t\t     &soctherm_oc_domain_ops,\n\t\t\t\t\t\t     &soc_irq_cdata);\n\n\tif (!soc_irq_cdata.domain) {\n\t\tpr_err(\"%s: Failed to create IRQ domain\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"%s(): OC interrupts enabled successful\\n\", __func__);\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int regs_show(struct seq_file *s, void *data)\n{\n\tstruct platform_device *pdev = s->private;\n\tstruct tegra_soctherm *ts = platform_get_drvdata(pdev);\n\tconst struct tegra_tsensor *tsensors = ts->soc->tsensors;\n\tconst struct tegra_tsensor_group **ttgs = ts->soc->ttgs;\n\tu32 r, state;\n\tint i, level;\n\n\tseq_puts(s, \"-----TSENSE (convert HW)-----\\n\");\n\n\tfor (i = 0; i < ts->soc->num_tsensors; i++) {\n\t\tr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG1);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG1_TEMP_ENABLE);\n\n\t\tseq_printf(s, \"%s: \", tsensors[i].name);\n\t\tseq_printf(s, \"En(%d) \", state);\n\n\t\tif (!state) {\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG1_TIDDQ_EN_MASK);\n\t\tseq_printf(s, \"tiddq(%d) \", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG1_TEN_COUNT_MASK);\n\t\tseq_printf(s, \"ten_count(%d) \", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG1_TSAMPLE_MASK);\n\t\tseq_printf(s, \"tsample(%d) \", state + 1);\n\n\t\tr = readl(ts->regs + tsensors[i].base + SENSOR_STATUS1);\n\t\tstate = REG_GET_MASK(r, SENSOR_STATUS1_TEMP_VALID_MASK);\n\t\tseq_printf(s, \"Temp(%d/\", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_STATUS1_TEMP_MASK);\n\t\tseq_printf(s, \"%d) \", translate_temp(state));\n\n\t\tr = readl(ts->regs + tsensors[i].base + SENSOR_STATUS0);\n\t\tstate = REG_GET_MASK(r, SENSOR_STATUS0_VALID_MASK);\n\t\tseq_printf(s, \"Capture(%d/\", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_STATUS0_CAPTURE_MASK);\n\t\tseq_printf(s, \"%d) \", state);\n\n\t\tr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG0);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG0_STOP);\n\t\tseq_printf(s, \"Stop(%d) \", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG0_TALL_MASK);\n\t\tseq_printf(s, \"Tall(%d) \", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG0_TCALC_OVER);\n\t\tseq_printf(s, \"Over(%d/\", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG0_OVER);\n\t\tseq_printf(s, \"%d/\", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG0_CPTR_OVER);\n\t\tseq_printf(s, \"%d) \", state);\n\n\t\tr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG2);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG2_THERMA_MASK);\n\t\tseq_printf(s, \"Therm_A/B(%d/\", state);\n\t\tstate = REG_GET_MASK(r, SENSOR_CONFIG2_THERMB_MASK);\n\t\tseq_printf(s, \"%d)\\n\", (s16)state);\n\t}\n\n\tr = readl(ts->regs + SENSOR_PDIV);\n\tseq_printf(s, \"PDIV: 0x%x\\n\", r);\n\n\tr = readl(ts->regs + SENSOR_HOTSPOT_OFF);\n\tseq_printf(s, \"HOTSPOT: 0x%x\\n\", r);\n\n\tseq_puts(s, \"\\n\");\n\tseq_puts(s, \"-----SOC_THERM-----\\n\");\n\n\tr = readl(ts->regs + SENSOR_TEMP1);\n\tstate = REG_GET_MASK(r, SENSOR_TEMP1_CPU_TEMP_MASK);\n\tseq_printf(s, \"Temperatures: CPU(%d) \", translate_temp(state));\n\tstate = REG_GET_MASK(r, SENSOR_TEMP1_GPU_TEMP_MASK);\n\tseq_printf(s, \" GPU(%d) \", translate_temp(state));\n\tr = readl(ts->regs + SENSOR_TEMP2);\n\tstate = REG_GET_MASK(r, SENSOR_TEMP2_PLLX_TEMP_MASK);\n\tseq_printf(s, \" PLLX(%d) \", translate_temp(state));\n\tstate = REG_GET_MASK(r, SENSOR_TEMP2_MEM_TEMP_MASK);\n\tseq_printf(s, \" MEM(%d)\\n\", translate_temp(state));\n\n\tfor (i = 0; i < ts->soc->num_ttgs; i++) {\n\t\tseq_printf(s, \"%s:\\n\", ttgs[i]->name);\n\t\tfor (level = 0; level < 4; level++) {\n\t\t\ts32 v;\n\t\t\tu32 mask;\n\t\t\tu16 off = ttgs[i]->thermctl_lvl0_offset;\n\n\t\t\tr = readl(ts->regs + THERMCTL_LVL_REG(off, level));\n\n\t\t\tmask = ttgs[i]->thermctl_lvl0_up_thresh_mask;\n\t\t\tstate = REG_GET_MASK(r, mask);\n\t\t\tv = sign_extend32(state, ts->soc->bptt - 1);\n\t\t\tv *= ts->soc->thresh_grain;\n\t\t\tseq_printf(s, \"   %d: Up/Dn(%d /\", level, v);\n\n\t\t\tmask = ttgs[i]->thermctl_lvl0_dn_thresh_mask;\n\t\t\tstate = REG_GET_MASK(r, mask);\n\t\t\tv = sign_extend32(state, ts->soc->bptt - 1);\n\t\t\tv *= ts->soc->thresh_grain;\n\t\t\tseq_printf(s, \"%d ) \", v);\n\n\t\t\tmask = THERMCTL_LVL0_CPU0_EN_MASK;\n\t\t\tstate = REG_GET_MASK(r, mask);\n\t\t\tseq_printf(s, \"En(%d) \", state);\n\n\t\t\tmask = THERMCTL_LVL0_CPU0_CPU_THROT_MASK;\n\t\t\tstate = REG_GET_MASK(r, mask);\n\t\t\tseq_puts(s, \"CPU Throt\");\n\t\t\tif (!state)\n\t\t\t\tseq_printf(s, \"(%s) \", \"none\");\n\t\t\telse if (state == THERMCTL_LVL0_CPU0_CPU_THROT_LIGHT)\n\t\t\t\tseq_printf(s, \"(%s) \", \"L\");\n\t\t\telse if (state == THERMCTL_LVL0_CPU0_CPU_THROT_HEAVY)\n\t\t\t\tseq_printf(s, \"(%s) \", \"H\");\n\t\t\telse\n\t\t\t\tseq_printf(s, \"(%s) \", \"H+L\");\n\n\t\t\tmask = THERMCTL_LVL0_CPU0_GPU_THROT_MASK;\n\t\t\tstate = REG_GET_MASK(r, mask);\n\t\t\tseq_puts(s, \"GPU Throt\");\n\t\t\tif (!state)\n\t\t\t\tseq_printf(s, \"(%s) \", \"none\");\n\t\t\telse if (state == THERMCTL_LVL0_CPU0_GPU_THROT_LIGHT)\n\t\t\t\tseq_printf(s, \"(%s) \", \"L\");\n\t\t\telse if (state == THERMCTL_LVL0_CPU0_GPU_THROT_HEAVY)\n\t\t\t\tseq_printf(s, \"(%s) \", \"H\");\n\t\t\telse\n\t\t\t\tseq_printf(s, \"(%s) \", \"H+L\");\n\n\t\t\tmask = THERMCTL_LVL0_CPU0_STATUS_MASK;\n\t\t\tstate = REG_GET_MASK(r, mask);\n\t\t\tseq_printf(s, \"Status(%s)\\n\",\n\t\t\t\t   state == 0 ? \"LO\" :\n\t\t\t\t   state == 1 ? \"In\" :\n\t\t\t\t   state == 2 ? \"Res\" : \"HI\");\n\t\t}\n\t}\n\n\tr = readl(ts->regs + THERMCTL_STATS_CTL);\n\tseq_printf(s, \"STATS: Up(%s) Dn(%s)\\n\",\n\t\t   r & STATS_CTL_EN_UP ? \"En\" : \"--\",\n\t\t   r & STATS_CTL_EN_DN ? \"En\" : \"--\");\n\n\tfor (level = 0; level < 4; level++) {\n\t\tu16 off;\n\n\t\toff = THERMCTL_LVL0_UP_STATS;\n\t\tr = readl(ts->regs + THERMCTL_LVL_REG(off, level));\n\t\tseq_printf(s, \"  Level_%d Up(%d) \", level, r);\n\n\t\toff = THERMCTL_LVL0_DN_STATS;\n\t\tr = readl(ts->regs + THERMCTL_LVL_REG(off, level));\n\t\tseq_printf(s, \"Dn(%d)\\n\", r);\n\t}\n\n\tr = readl(ts->regs + THERMCTL_THERMTRIP_CTL);\n\tstate = REG_GET_MASK(r, ttgs[0]->thermtrip_any_en_mask);\n\tseq_printf(s, \"Thermtrip Any En(%d)\\n\", state);\n\tfor (i = 0; i < ts->soc->num_ttgs; i++) {\n\t\tstate = REG_GET_MASK(r, ttgs[i]->thermtrip_enable_mask);\n\t\tseq_printf(s, \"     %s En(%d) \", ttgs[i]->name, state);\n\t\tstate = REG_GET_MASK(r, ttgs[i]->thermtrip_threshold_mask);\n\t\tstate *= ts->soc->thresh_grain;\n\t\tseq_printf(s, \"Thresh(%d)\\n\", state);\n\t}\n\n\tr = readl(ts->regs + THROT_GLOBAL_CFG);\n\tseq_puts(s, \"\\n\");\n\tseq_printf(s, \"GLOBAL THROTTLE CONFIG: 0x%08x\\n\", r);\n\n\tseq_puts(s, \"---------------------------------------------------\\n\");\n\tr = readl(ts->regs + THROT_STATUS);\n\tstate = REG_GET_MASK(r, THROT_STATUS_BREACH_MASK);\n\tseq_printf(s, \"THROT STATUS: breach(%d) \", state);\n\tstate = REG_GET_MASK(r, THROT_STATUS_STATE_MASK);\n\tseq_printf(s, \"state(%d) \", state);\n\tstate = REG_GET_MASK(r, THROT_STATUS_ENABLED_MASK);\n\tseq_printf(s, \"enabled(%d)\\n\", state);\n\n\tr = readl(ts->regs + CPU_PSKIP_STATUS);\n\tif (ts->soc->use_ccroc) {\n\t\tstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_ENABLED_MASK);\n\t\tseq_printf(s, \"CPU PSKIP STATUS: enabled(%d)\\n\", state);\n\t} else {\n\t\tstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_M_MASK);\n\t\tseq_printf(s, \"CPU PSKIP STATUS: M(%d) \", state);\n\t\tstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_N_MASK);\n\t\tseq_printf(s, \"N(%d) \", state);\n\t\tstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_ENABLED_MASK);\n\t\tseq_printf(s, \"enabled(%d)\\n\", state);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(regs);\n\nstatic void soctherm_debug_init(struct platform_device *pdev)\n{\n\tstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(\"soctherm\", NULL);\n\n\ttegra->debugfs_dir = root;\n\n\tdebugfs_create_file(\"reg_contents\", 0644, root, pdev, &regs_fops);\n}\n#else\nstatic inline void soctherm_debug_init(struct platform_device *pdev) {}\n#endif\n\nstatic int soctherm_clk_enable(struct platform_device *pdev, bool enable)\n{\n\tstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\n\tint err;\n\n\tif (!tegra->clock_soctherm || !tegra->clock_tsensor)\n\t\treturn -EINVAL;\n\n\treset_control_assert(tegra->reset);\n\n\tif (enable) {\n\t\terr = clk_prepare_enable(tegra->clock_soctherm);\n\t\tif (err) {\n\t\t\treset_control_deassert(tegra->reset);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = clk_prepare_enable(tegra->clock_tsensor);\n\t\tif (err) {\n\t\t\tclk_disable_unprepare(tegra->clock_soctherm);\n\t\t\treset_control_deassert(tegra->reset);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tclk_disable_unprepare(tegra->clock_tsensor);\n\t\tclk_disable_unprepare(tegra->clock_soctherm);\n\t}\n\n\treset_control_deassert(tegra->reset);\n\n\treturn 0;\n}\n\nstatic int throt_get_cdev_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t    unsigned long *max_state)\n{\n\t*max_state = 1;\n\treturn 0;\n}\n\nstatic int throt_get_cdev_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t    unsigned long *cur_state)\n{\n\tstruct tegra_soctherm *ts = cdev->devdata;\n\tu32 r;\n\n\tr = readl(ts->regs + THROT_STATUS);\n\tif (REG_GET_MASK(r, THROT_STATUS_STATE_MASK))\n\t\t*cur_state = 1;\n\telse\n\t\t*cur_state = 0;\n\n\treturn 0;\n}\n\nstatic int throt_set_cdev_state(struct thermal_cooling_device *cdev,\n\t\t\t\tunsigned long cur_state)\n{\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops throt_cooling_ops = {\n\t.get_max_state = throt_get_cdev_max_state,\n\t.get_cur_state = throt_get_cdev_cur_state,\n\t.set_cur_state = throt_set_cdev_state,\n};\n\nstatic int soctherm_thermtrips_parse(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tstruct tsensor_group_thermtrips *tt = ts->soc->thermtrips;\n\tconst int max_num_prop = ts->soc->num_ttgs * 2;\n\tu32 *tlb;\n\tint i, j, n, ret;\n\n\tif (!tt)\n\t\treturn -ENOMEM;\n\n\tn = of_property_count_u32_elems(dev->of_node, \"nvidia,thermtrips\");\n\tif (n <= 0) {\n\t\tdev_info(dev,\n\t\t\t \"missing thermtrips, will use critical trips as shut down temp\\n\");\n\t\treturn n;\n\t}\n\n\tn = min(max_num_prop, n);\n\n\ttlb = devm_kcalloc(&pdev->dev, max_num_prop, sizeof(u32), GFP_KERNEL);\n\tif (!tlb)\n\t\treturn -ENOMEM;\n\tret = of_property_read_u32_array(dev->of_node, \"nvidia,thermtrips\",\n\t\t\t\t\t tlb, n);\n\tif (ret) {\n\t\tdev_err(dev, \"invalid num ele: thermtrips:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti = 0;\n\tfor (j = 0; j < n; j = j + 2) {\n\t\tif (tlb[j] >= TEGRA124_SOCTHERM_SENSOR_NUM)\n\t\t\tcontinue;\n\n\t\ttt[i].id = tlb[j];\n\t\ttt[i].temp = tlb[j + 1];\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic void soctherm_oc_cfg_parse(struct device *dev,\n\t\t\t\tstruct device_node *np_oc,\n\t\t\t\tstruct soctherm_throt_cfg *stc)\n{\n\tu32 val;\n\n\tif (of_property_read_bool(np_oc, \"nvidia,polarity-active-low\"))\n\t\tstc->oc_cfg.active_low = 1;\n\telse\n\t\tstc->oc_cfg.active_low = 0;\n\n\tif (!of_property_read_u32(np_oc, \"nvidia,count-threshold\", &val)) {\n\t\tstc->oc_cfg.intr_en = 1;\n\t\tstc->oc_cfg.alarm_cnt_thresh = val;\n\t}\n\n\tif (!of_property_read_u32(np_oc, \"nvidia,throttle-period-us\", &val))\n\t\tstc->oc_cfg.throt_period = val;\n\n\tif (!of_property_read_u32(np_oc, \"nvidia,alarm-filter\", &val))\n\t\tstc->oc_cfg.alarm_filter = val;\n\n\t \n\tstc->oc_cfg.mode = OC_THROTTLE_MODE_BRIEF;\n}\n\nstatic int soctherm_throt_cfg_parse(struct device *dev,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    struct soctherm_throt_cfg *stc)\n{\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tint ret;\n\tu32 val;\n\n\tret = of_property_read_u32(np, \"nvidia,priority\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"throttle-cfg: %s: invalid priority\\n\", stc->name);\n\t\treturn -EINVAL;\n\t}\n\tstc->priority = val;\n\n\tret = of_property_read_u32(np, ts->soc->use_ccroc ?\n\t\t\t\t   \"nvidia,cpu-throt-level\" :\n\t\t\t\t   \"nvidia,cpu-throt-percent\", &val);\n\tif (!ret) {\n\t\tif (ts->soc->use_ccroc &&\n\t\t    val <= TEGRA_SOCTHERM_THROT_LEVEL_HIGH)\n\t\t\tstc->cpu_throt_level = val;\n\t\telse if (!ts->soc->use_ccroc && val <= 100)\n\t\t\tstc->cpu_throt_depth = val;\n\t\telse\n\t\t\tgoto err;\n\t} else {\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(np, \"nvidia,gpu-throt-level\", &val);\n\tif (!ret && val <= TEGRA_SOCTHERM_THROT_LEVEL_HIGH)\n\t\tstc->gpu_throt_level = val;\n\telse\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(dev, \"throttle-cfg: %s: no throt prop or invalid prop\\n\",\n\t\tstc->name);\n\treturn -EINVAL;\n}\n\n \nstatic void soctherm_init_hw_throt_cdev(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tstruct device_node *np_stc, *np_stcc;\n\tconst char *name;\n\tint i;\n\n\tfor (i = 0; i < THROTTLE_SIZE; i++) {\n\t\tts->throt_cfgs[i].name = throt_names[i];\n\t\tts->throt_cfgs[i].id = i;\n\t\tts->throt_cfgs[i].init = false;\n\t}\n\n\tnp_stc = of_get_child_by_name(dev->of_node, \"throttle-cfgs\");\n\tif (!np_stc) {\n\t\tdev_info(dev,\n\t\t\t \"throttle-cfg: no throttle-cfgs - not enabling\\n\");\n\t\treturn;\n\t}\n\n\tfor_each_child_of_node(np_stc, np_stcc) {\n\t\tstruct soctherm_throt_cfg *stc;\n\t\tstruct thermal_cooling_device *tcd;\n\t\tint err;\n\n\t\tname = np_stcc->name;\n\t\tstc = find_throttle_cfg_by_name(ts, name);\n\t\tif (!stc) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"throttle-cfg: could not find %s\\n\", name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stc->init) {\n\t\t\tdev_err(dev, \"throttle-cfg: %s: redefined!\\n\", name);\n\t\t\tof_node_put(np_stcc);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = soctherm_throt_cfg_parse(dev, np_stcc, stc);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (stc->id >= THROTTLE_OC1) {\n\t\t\tsoctherm_oc_cfg_parse(dev, np_stcc, stc);\n\t\t\tstc->init = true;\n\t\t} else {\n\n\t\t\ttcd = thermal_of_cooling_device_register(np_stcc,\n\t\t\t\t\t\t\t (char *)name, ts,\n\t\t\t\t\t\t\t &throt_cooling_ops);\n\t\t\tif (IS_ERR_OR_NULL(tcd)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"throttle-cfg: %s: failed to register cooling device\\n\",\n\t\t\t\t\tname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstc->cdev = tcd;\n\t\t\tstc->init = true;\n\t\t}\n\n\t}\n\n\tof_node_put(np_stc);\n}\n\n \nstatic void throttlectl_cpu_level_cfg(struct tegra_soctherm *ts, int level)\n{\n\tu8 depth, dividend;\n\tu32 r;\n\n\tswitch (level) {\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_LOW:\n\t\tdepth = 50;\n\t\tbreak;\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_MED:\n\t\tdepth = 75;\n\t\tbreak;\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_HIGH:\n\t\tdepth = 80;\n\t\tbreak;\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_NONE:\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\n\tdividend = THROT_DEPTH_DIVIDEND(depth);\n\n\t \n\tr = ccroc_readl(ts, CCROC_THROT_PSKIP_RAMP_CPU_REG(level));\n\tr = REG_SET_MASK(r, CCROC_THROT_PSKIP_RAMP_DURATION_MASK, 0xff);\n\tr = REG_SET_MASK(r, CCROC_THROT_PSKIP_RAMP_STEP_MASK, 0xf);\n\tccroc_writel(ts, r, CCROC_THROT_PSKIP_RAMP_CPU_REG(level));\n\n\tr = ccroc_readl(ts, CCROC_THROT_PSKIP_CTRL_CPU_REG(level));\n\tr = REG_SET_MASK(r, CCROC_THROT_PSKIP_CTRL_ENB_MASK, 1);\n\tr = REG_SET_MASK(r, CCROC_THROT_PSKIP_CTRL_DIVIDEND_MASK, dividend);\n\tr = REG_SET_MASK(r, CCROC_THROT_PSKIP_CTRL_DIVISOR_MASK, 0xff);\n\tccroc_writel(ts, r, CCROC_THROT_PSKIP_CTRL_CPU_REG(level));\n}\n\n \nstatic void throttlectl_cpu_level_select(struct tegra_soctherm *ts,\n\t\t\t\t\t enum soctherm_throttle_id throt)\n{\n\tu32 r, throt_vect;\n\n\t \n\tswitch (ts->throt_cfgs[throt].cpu_throt_level) {\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_LOW:\n\t\tthrot_vect = THROT_VECT_LOW;\n\t\tbreak;\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_MED:\n\t\tthrot_vect = THROT_VECT_MED;\n\t\tbreak;\n\tcase TEGRA_SOCTHERM_THROT_LEVEL_HIGH:\n\t\tthrot_vect = THROT_VECT_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tthrot_vect = THROT_VECT_NONE;\n\t\tbreak;\n\t}\n\n\tr = readl(ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_ENABLE_MASK, 1);\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_VECT_CPU_MASK, throt_vect);\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_VECT2_CPU_MASK, throt_vect);\n\twritel(r, ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\n\n\t \n\tr = REG_SET_MASK(0, THROT_PSKIP_RAMP_SEQ_BYPASS_MODE_MASK, 1);\n\twritel(r, ts->regs + THROT_PSKIP_RAMP(throt, THROTTLE_DEV_CPU));\n}\n\n \nstatic void throttlectl_cpu_mn(struct tegra_soctherm *ts,\n\t\t\t       enum soctherm_throttle_id throt)\n{\n\tu32 r;\n\tint depth;\n\tu8 dividend;\n\n\tdepth = ts->throt_cfgs[throt].cpu_throt_depth;\n\tdividend = THROT_DEPTH_DIVIDEND(depth);\n\n\tr = readl(ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_ENABLE_MASK, 1);\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_DIVIDEND_MASK, dividend);\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_DIVISOR_MASK, 0xff);\n\twritel(r, ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\n\n\tr = readl(ts->regs + THROT_PSKIP_RAMP(throt, THROTTLE_DEV_CPU));\n\tr = REG_SET_MASK(r, THROT_PSKIP_RAMP_DURATION_MASK, 0xff);\n\tr = REG_SET_MASK(r, THROT_PSKIP_RAMP_STEP_MASK, 0xf);\n\twritel(r, ts->regs + THROT_PSKIP_RAMP(throt, THROTTLE_DEV_CPU));\n}\n\n \nstatic void throttlectl_gpu_level_select(struct tegra_soctherm *ts,\n\t\t\t\t\t enum soctherm_throttle_id throt)\n{\n\tu32 r, level, throt_vect;\n\n\tlevel = ts->throt_cfgs[throt].gpu_throt_level;\n\tthrot_vect = THROT_LEVEL_TO_DEPTH(level);\n\tr = readl(ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_GPU));\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_ENABLE_MASK, 1);\n\tr = REG_SET_MASK(r, THROT_PSKIP_CTRL_VECT_GPU_MASK, throt_vect);\n\twritel(r, ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_GPU));\n}\n\nstatic int soctherm_oc_cfg_program(struct tegra_soctherm *ts,\n\t\t\t\t      enum soctherm_throttle_id throt)\n{\n\tu32 r;\n\tstruct soctherm_oc_cfg *oc = &ts->throt_cfgs[throt].oc_cfg;\n\n\tif (oc->mode == OC_THROTTLE_MODE_DISABLED)\n\t\treturn -EINVAL;\n\n\tr = REG_SET_MASK(0, OC1_CFG_HW_RESTORE_MASK, 1);\n\tr = REG_SET_MASK(r, OC1_CFG_THROTTLE_MODE_MASK, oc->mode);\n\tr = REG_SET_MASK(r, OC1_CFG_ALARM_POLARITY_MASK, oc->active_low);\n\tr = REG_SET_MASK(r, OC1_CFG_EN_THROTTLE_MASK, 1);\n\twritel(r, ts->regs + ALARM_CFG(throt));\n\twritel(oc->throt_period, ts->regs + ALARM_THROTTLE_PERIOD(throt));\n\twritel(oc->alarm_cnt_thresh, ts->regs + ALARM_CNT_THRESHOLD(throt));\n\twritel(oc->alarm_filter, ts->regs + ALARM_FILTER(throt));\n\tsoctherm_oc_intr_enable(ts, throt, oc->intr_en);\n\n\treturn 0;\n}\n\n \nstatic void soctherm_throttle_program(struct tegra_soctherm *ts,\n\t\t\t\t      enum soctherm_throttle_id throt)\n{\n\tu32 r;\n\tstruct soctherm_throt_cfg stc = ts->throt_cfgs[throt];\n\n\tif (!stc.init)\n\t\treturn;\n\n\tif ((throt >= THROTTLE_OC1) && (soctherm_oc_cfg_program(ts, throt)))\n\t\treturn;\n\n\t \n\tif (ts->soc->use_ccroc)\n\t\tthrottlectl_cpu_level_select(ts, throt);\n\telse\n\t\tthrottlectl_cpu_mn(ts, throt);\n\n\tthrottlectl_gpu_level_select(ts, throt);\n\n\tr = REG_SET_MASK(0, THROT_PRIORITY_LITE_PRIO_MASK, stc.priority);\n\twritel(r, ts->regs + THROT_PRIORITY_CTRL(throt));\n\n\tr = REG_SET_MASK(0, THROT_DELAY_LITE_DELAY_MASK, 0);\n\twritel(r, ts->regs + THROT_DELAY_CTRL(throt));\n\n\tr = readl(ts->regs + THROT_PRIORITY_LOCK);\n\tr = REG_GET_MASK(r, THROT_PRIORITY_LOCK_PRIORITY_MASK);\n\tif (r >= stc.priority)\n\t\treturn;\n\tr = REG_SET_MASK(0, THROT_PRIORITY_LOCK_PRIORITY_MASK,\n\t\t\t stc.priority);\n\twritel(r, ts->regs + THROT_PRIORITY_LOCK);\n}\n\nstatic void tegra_soctherm_throttle(struct device *dev)\n{\n\tstruct tegra_soctherm *ts = dev_get_drvdata(dev);\n\tu32 v;\n\tint i;\n\n\t \n\tif (ts->soc->use_ccroc) {\n\t\tthrottlectl_cpu_level_cfg(ts, TEGRA_SOCTHERM_THROT_LEVEL_LOW);\n\t\tthrottlectl_cpu_level_cfg(ts, TEGRA_SOCTHERM_THROT_LEVEL_MED);\n\t\tthrottlectl_cpu_level_cfg(ts, TEGRA_SOCTHERM_THROT_LEVEL_HIGH);\n\t}\n\n\t \n\tfor (i = 0; i < THROTTLE_SIZE; i++)\n\t\tsoctherm_throttle_program(ts, i);\n\n\tv = REG_SET_MASK(0, THROT_GLOBAL_ENB_MASK, 1);\n\tif (ts->soc->use_ccroc) {\n\t\tccroc_writel(ts, v, CCROC_GLOBAL_CFG);\n\n\t\tv = ccroc_readl(ts, CCROC_SUPER_CCLKG_DIVIDER);\n\t\tv = REG_SET_MASK(v, CDIVG_USE_THERM_CONTROLS_MASK, 1);\n\t\tccroc_writel(ts, v, CCROC_SUPER_CCLKG_DIVIDER);\n\t} else {\n\t\twritel(v, ts->regs + THROT_GLOBAL_CFG);\n\n\t\tv = readl(ts->clk_regs + CAR_SUPER_CCLKG_DIVIDER);\n\t\tv = REG_SET_MASK(v, CDIVG_USE_THERM_CONTROLS_MASK, 1);\n\t\twritel(v, ts->clk_regs + CAR_SUPER_CCLKG_DIVIDER);\n\t}\n\n\t \n\tv = STATS_CTL_CLR_DN | STATS_CTL_EN_DN |\n\t    STATS_CTL_CLR_UP | STATS_CTL_EN_UP;\n\twritel(v, ts->regs + THERMCTL_STATS_CTL);\n}\n\nstatic int soctherm_interrupts_init(struct platform_device *pdev,\n\t\t\t\t    struct tegra_soctherm *tegra)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tret = soctherm_oc_int_init(np, TEGRA_SOC_OC_IRQ_MAX);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"soctherm_oc_int_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\ttegra->thermal_irq = platform_get_irq(pdev, 0);\n\tif (tegra->thermal_irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"get 'thermal_irq' failed.\\n\");\n\t\treturn 0;\n\t}\n\n\ttegra->edp_irq = platform_get_irq(pdev, 1);\n\tif (tegra->edp_irq < 0) {\n\t\tdev_dbg(&pdev->dev, \"get 'edp_irq' failed.\\n\");\n\t\treturn 0;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\ttegra->thermal_irq,\n\t\t\t\t\tsoctherm_thermal_isr,\n\t\t\t\t\tsoctherm_thermal_isr_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\tdev_name(&pdev->dev),\n\t\t\t\t\ttegra);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq 'thermal_irq' failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\ttegra->edp_irq,\n\t\t\t\t\tsoctherm_edp_isr,\n\t\t\t\t\tsoctherm_edp_isr_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"soctherm_edp\",\n\t\t\t\t\ttegra);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"request_irq 'edp_irq' failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void soctherm_init(struct platform_device *pdev)\n{\n\tstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\n\tconst struct tegra_tsensor_group **ttgs = tegra->soc->ttgs;\n\tint i;\n\tu32 pdiv, hotspot;\n\n\t \n\tfor (i = 0; i < tegra->soc->num_tsensors; ++i)\n\t\tenable_tsensor(tegra, i);\n\n\t \n\tpdiv = readl(tegra->regs + SENSOR_PDIV);\n\thotspot = readl(tegra->regs + SENSOR_HOTSPOT_OFF);\n\tfor (i = 0; i < tegra->soc->num_ttgs; ++i) {\n\t\tpdiv = REG_SET_MASK(pdiv, ttgs[i]->pdiv_mask,\n\t\t\t\t    ttgs[i]->pdiv);\n\t\t \n\t\tif (ttgs[i]->id == TEGRA124_SOCTHERM_SENSOR_PLLX)\n\t\t\tcontinue;\n\t\thotspot =  REG_SET_MASK(hotspot,\n\t\t\t\t\tttgs[i]->pllx_hotspot_mask,\n\t\t\t\t\tttgs[i]->pllx_hotspot_diff);\n\t}\n\twritel(pdiv, tegra->regs + SENSOR_PDIV);\n\twritel(hotspot, tegra->regs + SENSOR_HOTSPOT_OFF);\n\n\t \n\ttegra_soctherm_throttle(&pdev->dev);\n}\n\nstatic const struct of_device_id tegra_soctherm_of_match[] = {\n#ifdef CONFIG_ARCH_TEGRA_124_SOC\n\t{\n\t\t.compatible = \"nvidia,tegra124-soctherm\",\n\t\t.data = &tegra124_soctherm,\n\t},\n#endif\n#ifdef CONFIG_ARCH_TEGRA_132_SOC\n\t{\n\t\t.compatible = \"nvidia,tegra132-soctherm\",\n\t\t.data = &tegra132_soctherm,\n\t},\n#endif\n#ifdef CONFIG_ARCH_TEGRA_210_SOC\n\t{\n\t\t.compatible = \"nvidia,tegra210-soctherm\",\n\t\t.data = &tegra210_soctherm,\n\t},\n#endif\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_soctherm_of_match);\n\nstatic int tegra_soctherm_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct tegra_soctherm *tegra;\n\tstruct thermal_zone_device *z;\n\tstruct tsensor_shared_calib shared_calib;\n\tstruct tegra_soctherm_soc *soc;\n\tunsigned int i;\n\tint err;\n\n\tmatch = of_match_node(tegra_soctherm_of_match, pdev->dev.of_node);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tsoc = (struct tegra_soctherm_soc *)match->data;\n\tif (soc->num_ttgs > TEGRA124_SOCTHERM_SENSOR_NUM)\n\t\treturn -EINVAL;\n\n\ttegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tegra->thermctl_lock);\n\tdev_set_drvdata(&pdev->dev, tegra);\n\n\ttegra->soc = soc;\n\n\ttegra->regs = devm_platform_ioremap_resource_byname(pdev, \"soctherm-reg\");\n\tif (IS_ERR(tegra->regs)) {\n\t\tdev_err(&pdev->dev, \"can't get soctherm registers\");\n\t\treturn PTR_ERR(tegra->regs);\n\t}\n\n\tif (!tegra->soc->use_ccroc) {\n\t\ttegra->clk_regs = devm_platform_ioremap_resource_byname(pdev, \"car-reg\");\n\t\tif (IS_ERR(tegra->clk_regs)) {\n\t\t\tdev_err(&pdev->dev, \"can't get car clk registers\");\n\t\t\treturn PTR_ERR(tegra->clk_regs);\n\t\t}\n\t} else {\n\t\ttegra->ccroc_regs = devm_platform_ioremap_resource_byname(pdev, \"ccroc-reg\");\n\t\tif (IS_ERR(tegra->ccroc_regs)) {\n\t\t\tdev_err(&pdev->dev, \"can't get ccroc registers\");\n\t\t\treturn PTR_ERR(tegra->ccroc_regs);\n\t\t}\n\t}\n\n\ttegra->reset = devm_reset_control_get(&pdev->dev, \"soctherm\");\n\tif (IS_ERR(tegra->reset)) {\n\t\tdev_err(&pdev->dev, \"can't get soctherm reset\\n\");\n\t\treturn PTR_ERR(tegra->reset);\n\t}\n\n\ttegra->clock_tsensor = devm_clk_get(&pdev->dev, \"tsensor\");\n\tif (IS_ERR(tegra->clock_tsensor)) {\n\t\tdev_err(&pdev->dev, \"can't get tsensor clock\\n\");\n\t\treturn PTR_ERR(tegra->clock_tsensor);\n\t}\n\n\ttegra->clock_soctherm = devm_clk_get(&pdev->dev, \"soctherm\");\n\tif (IS_ERR(tegra->clock_soctherm)) {\n\t\tdev_err(&pdev->dev, \"can't get soctherm clock\\n\");\n\t\treturn PTR_ERR(tegra->clock_soctherm);\n\t}\n\n\ttegra->calib = devm_kcalloc(&pdev->dev,\n\t\t\t\t    soc->num_tsensors, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!tegra->calib)\n\t\treturn -ENOMEM;\n\n\t \n\terr = tegra_calc_shared_calib(soc->tfuse, &shared_calib);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < soc->num_tsensors; ++i) {\n\t\terr = tegra_calc_tsensor_calib(&soc->tsensors[i],\n\t\t\t\t\t       &shared_calib,\n\t\t\t\t\t       &tegra->calib[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ttegra->thermctl_tzs = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t   soc->num_ttgs, sizeof(z),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!tegra->thermctl_tzs)\n\t\treturn -ENOMEM;\n\n\terr = soctherm_clk_enable(pdev, true);\n\tif (err)\n\t\treturn err;\n\n\tsoctherm_thermtrips_parse(pdev);\n\n\tsoctherm_init_hw_throt_cdev(pdev);\n\n\tsoctherm_init(pdev);\n\n\tfor (i = 0; i < soc->num_ttgs; ++i) {\n\t\tstruct tegra_thermctl_zone *zone =\n\t\t\tdevm_kzalloc(&pdev->dev, sizeof(*zone), GFP_KERNEL);\n\t\tif (!zone) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto disable_clocks;\n\t\t}\n\n\t\tzone->reg = tegra->regs + soc->ttgs[i]->sensor_temp_offset;\n\t\tzone->dev = &pdev->dev;\n\t\tzone->sg = soc->ttgs[i];\n\t\tzone->ts = tegra;\n\n\t\tz = devm_thermal_of_zone_register(&pdev->dev,\n\t\t\t\t\t\t  soc->ttgs[i]->id, zone,\n\t\t\t\t\t\t  &tegra_of_thermal_ops);\n\t\tif (IS_ERR(z)) {\n\t\t\terr = PTR_ERR(z);\n\t\t\tdev_err(&pdev->dev, \"failed to register sensor: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto disable_clocks;\n\t\t}\n\n\t\tzone->tz = z;\n\t\ttegra->thermctl_tzs[soc->ttgs[i]->id] = z;\n\n\t\t \n\t\terr = tegra_soctherm_set_hwtrips(&pdev->dev, soc->ttgs[i], z);\n\t\tif (err)\n\t\t\tgoto disable_clocks;\n\t}\n\n\terr = soctherm_interrupts_init(pdev, tegra);\n\n\tsoctherm_debug_init(pdev);\n\n\treturn 0;\n\ndisable_clocks:\n\tsoctherm_clk_enable(pdev, false);\n\n\treturn err;\n}\n\nstatic int tegra_soctherm_remove(struct platform_device *pdev)\n{\n\tstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(tegra->debugfs_dir);\n\n\tsoctherm_clk_enable(pdev, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused soctherm_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tsoctherm_clk_enable(pdev, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused soctherm_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\n\tstruct tegra_soctherm_soc *soc = tegra->soc;\n\tint err, i;\n\n\terr = soctherm_clk_enable(pdev, true);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Resume failed: enable clocks failed\\n\");\n\t\treturn err;\n\t}\n\n\tsoctherm_init(pdev);\n\n\tfor (i = 0; i < soc->num_ttgs; ++i) {\n\t\tstruct thermal_zone_device *tz;\n\n\t\ttz = tegra->thermctl_tzs[soc->ttgs[i]->id];\n\t\terr = tegra_soctherm_set_hwtrips(dev, soc->ttgs[i], tz);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Resume failed: set hwtrips failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tegra_soctherm_pm, soctherm_suspend, soctherm_resume);\n\nstatic struct platform_driver tegra_soctherm_driver = {\n\t.probe = tegra_soctherm_probe,\n\t.remove = tegra_soctherm_remove,\n\t.driver = {\n\t\t.name = \"tegra_soctherm\",\n\t\t.pm = &tegra_soctherm_pm,\n\t\t.of_match_table = tegra_soctherm_of_match,\n\t},\n};\nmodule_platform_driver(tegra_soctherm_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra SOCTHERM thermal management driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}