{
  "module_name": "tegra30-tsensor.c",
  "hash_id": "8668a0bc098682ac72f0ceff80f566ee94eaa2eb0424ab7e9856948fe2c0cbfa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/tegra/tegra30-tsensor.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n#include <linux/types.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"../thermal_hwmon.h\"\n\n#define TSENSOR_SENSOR0_CONFIG0\t\t\t\t0x0\n#define TSENSOR_SENSOR0_CONFIG0_SENSOR_STOP\t\tBIT(0)\n#define TSENSOR_SENSOR0_CONFIG0_HW_FREQ_DIV_EN\t\tBIT(1)\n#define TSENSOR_SENSOR0_CONFIG0_THERMAL_RST_EN\t\tBIT(2)\n#define TSENSOR_SENSOR0_CONFIG0_DVFS_EN\t\t\tBIT(3)\n#define TSENSOR_SENSOR0_CONFIG0_INTR_OVERFLOW_EN\tBIT(4)\n#define TSENSOR_SENSOR0_CONFIG0_INTR_HW_FREQ_DIV_EN\tBIT(5)\n#define TSENSOR_SENSOR0_CONFIG0_INTR_THERMAL_RST_EN\tBIT(6)\n#define TSENSOR_SENSOR0_CONFIG0_M\t\t\tGENMASK(23,  8)\n#define TSENSOR_SENSOR0_CONFIG0_N\t\t\tGENMASK(31, 24)\n\n#define TSENSOR_SENSOR0_CONFIG1\t\t\t\t0x8\n#define TSENSOR_SENSOR0_CONFIG1_TH1\t\t\tGENMASK(15,  0)\n#define TSENSOR_SENSOR0_CONFIG1_TH2\t\t\tGENMASK(31, 16)\n\n#define TSENSOR_SENSOR0_CONFIG2\t\t\t\t0xc\n#define TSENSOR_SENSOR0_CONFIG2_TH3\t\t\tGENMASK(15,  0)\n\n#define TSENSOR_SENSOR0_STATUS0\t\t\t\t0x18\n#define TSENSOR_SENSOR0_STATUS0_STATE\t\t\tGENMASK(2, 0)\n#define TSENSOR_SENSOR0_STATUS0_INTR\t\t\tBIT(8)\n#define TSENSOR_SENSOR0_STATUS0_CURRENT_VALID\t\tBIT(9)\n\n#define TSENSOR_SENSOR0_TS_STATUS1\t\t\t0x1c\n#define TSENSOR_SENSOR0_TS_STATUS1_CURRENT_COUNT\tGENMASK(31, 16)\n\n#define TEGRA30_FUSE_TEST_PROG_VER\t\t\t0x28\n\n#define TEGRA30_FUSE_TSENSOR_CALIB\t\t\t0x98\n#define TEGRA30_FUSE_TSENSOR_CALIB_LOW\t\t\tGENMASK(15,  0)\n#define TEGRA30_FUSE_TSENSOR_CALIB_HIGH\t\t\tGENMASK(31, 16)\n\n#define TEGRA30_FUSE_SPARE_BIT\t\t\t\t0x144\n\nstruct tegra_tsensor;\n\nstruct tegra_tsensor_calibration_data {\n\tint a, b, m, n, p, r;\n};\n\nstruct tegra_tsensor_channel {\n\tvoid __iomem *regs;\n\tunsigned int id;\n\tstruct tegra_tsensor *ts;\n\tstruct thermal_zone_device *tzd;\n};\n\nstruct tegra_tsensor {\n\tvoid __iomem *regs;\n\tbool swap_channels;\n\tstruct clk *clk;\n\tstruct device *dev;\n\tstruct reset_control *rst;\n\tstruct tegra_tsensor_channel ch[2];\n\tstruct tegra_tsensor_calibration_data calib;\n};\n\nstatic int tegra_tsensor_hw_enable(const struct tegra_tsensor *ts)\n{\n\tu32 val;\n\tint err;\n\n\terr = reset_control_assert(ts->rst);\n\tif (err) {\n\t\tdev_err(ts->dev, \"failed to assert hardware reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(ts->clk);\n\tif (err) {\n\t\tdev_err(ts->dev, \"failed to enable clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfsleep(1000);\n\n\terr = reset_control_deassert(ts->rst);\n\tif (err) {\n\t\tdev_err(ts->dev, \"failed to deassert hardware reset: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tval  = FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_M, 12500);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_N, 255);\n\n\t \n\twritel_relaxed(val, ts->regs + 0x40 + TSENSOR_SENSOR0_CONFIG0);\n\twritel_relaxed(val, ts->regs + 0x80 + TSENSOR_SENSOR0_CONFIG0);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(ts->clk);\n\n\treturn err;\n}\n\nstatic int tegra_tsensor_hw_disable(const struct tegra_tsensor *ts)\n{\n\tint err;\n\n\terr = reset_control_assert(ts->rst);\n\tif (err) {\n\t\tdev_err(ts->dev, \"failed to assert hardware reset: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tclk_disable_unprepare(ts->clk);\n\n\treturn 0;\n}\n\nstatic void devm_tegra_tsensor_hw_disable(void *data)\n{\n\tconst struct tegra_tsensor *ts = data;\n\n\ttegra_tsensor_hw_disable(ts);\n}\n\nstatic int tegra_tsensor_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tconst struct tegra_tsensor_channel *tsc = thermal_zone_device_priv(tz);\n\tconst struct tegra_tsensor *ts = tsc->ts;\n\tint err, c1, c2, c3, c4, counter;\n\tu32 val;\n\n\t \n\terr = readl_relaxed_poll_timeout(tsc->regs + TSENSOR_SENSOR0_STATUS0, val,\n\t\t\t\t\t val & TSENSOR_SENSOR0_STATUS0_CURRENT_VALID,\n\t\t\t\t\t 21 * USEC_PER_MSEC,\n\t\t\t\t\t 21 * USEC_PER_MSEC * 50);\n\tif (err) {\n\t\tdev_err_once(ts->dev, \"ch%u: counter invalid\\n\", tsc->id);\n\t\treturn err;\n\t}\n\n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_TS_STATUS1);\n\tcounter = FIELD_GET(TSENSOR_SENSOR0_TS_STATUS1_CURRENT_COUNT, val);\n\n\t \n\tif (counter == 0xffff) {\n\t\tdev_err_once(ts->dev, \"ch%u: counter overflow\\n\", tsc->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tc1 = DIV_ROUND_CLOSEST(ts->calib.a * counter + ts->calib.b, 1000000);\n\tc1 = c1 ?: 1;\n\tc2 = DIV_ROUND_CLOSEST(ts->calib.p, c1);\n\tc3 = c1 * ts->calib.m;\n\tc4 = ts->calib.n;\n\n\t*temp = DIV_ROUND_CLOSEST(c1 * (c2 + c3 + c4), 1000);\n\n\treturn 0;\n}\n\nstatic int tegra_tsensor_temp_to_counter(const struct tegra_tsensor *ts, int temp)\n{\n\tint c1, c2;\n\n\tc1 = DIV_ROUND_CLOSEST(ts->calib.p - temp * 1000, ts->calib.m);\n\tc2 = -ts->calib.r - int_sqrt(ts->calib.r * ts->calib.r - c1);\n\n\treturn DIV_ROUND_CLOSEST(c2 * 1000000 - ts->calib.b, ts->calib.a);\n}\n\nstatic int tegra_tsensor_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tconst struct tegra_tsensor_channel *tsc = thermal_zone_device_priv(tz);\n\tconst struct tegra_tsensor *ts = tsc->ts;\n\tu32 val;\n\n\t \n\tif (high == INT_MAX)\n\t\treturn 0;\n\n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_CONFIG1);\n\tval &= ~TSENSOR_SENSOR0_CONFIG1_TH1;\n\n\thigh = tegra_tsensor_temp_to_counter(ts, high);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG1_TH1, high);\n\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_CONFIG1);\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops ops = {\n\t.get_temp = tegra_tsensor_get_temp,\n\t.set_trips = tegra_tsensor_set_trips,\n};\n\nstatic bool\ntegra_tsensor_handle_channel_interrupt(const struct tegra_tsensor *ts,\n\t\t\t\t       unsigned int id)\n{\n\tconst struct tegra_tsensor_channel *tsc = &ts->ch[id];\n\tu32 val;\n\n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_STATUS0);\n\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_STATUS0);\n\n\tif (FIELD_GET(TSENSOR_SENSOR0_STATUS0_STATE, val) == 5)\n\t\tdev_err_ratelimited(ts->dev, \"ch%u: counter overflowed\\n\", id);\n\n\tif (!FIELD_GET(TSENSOR_SENSOR0_STATUS0_INTR, val))\n\t\treturn false;\n\n\tthermal_zone_device_update(tsc->tzd, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn true;\n}\n\nstatic irqreturn_t tegra_tsensor_isr(int irq, void *data)\n{\n\tconst struct tegra_tsensor *ts = data;\n\tbool handled = false;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ts->ch); i++)\n\t\thandled |= tegra_tsensor_handle_channel_interrupt(ts, i);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int tegra_tsensor_disable_hw_channel(const struct tegra_tsensor *ts,\n\t\t\t\t\t    unsigned int id)\n{\n\tconst struct tegra_tsensor_channel *tsc = &ts->ch[id];\n\tstruct thermal_zone_device *tzd = tsc->tzd;\n\tu32 val;\n\tint err;\n\n\tif (!tzd)\n\t\tgoto stop_channel;\n\n\terr = thermal_zone_device_disable(tzd);\n\tif (err) {\n\t\tdev_err(ts->dev, \"ch%u: failed to disable zone: %d\\n\", id, err);\n\t\treturn err;\n\t}\n\nstop_channel:\n\t \n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_CONFIG0);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_SENSOR_STOP, 1);\n\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_CONFIG0);\n\n\treturn 0;\n}\n\nstatic void tegra_tsensor_get_hw_channel_trips(struct thermal_zone_device *tzd,\n\t\t\t\t\t       int *hot_trip, int *crit_trip)\n{\n\tunsigned int i;\n\n\t \n\t*hot_trip  = 85000;\n\t*crit_trip = 90000;\n\n\tfor (i = 0; i < thermal_zone_get_num_trips(tzd); i++) {\n\n\t\tstruct thermal_trip trip;\n\n\t\tthermal_zone_get_trip(tzd, i, &trip);\n\n\t\tif (trip.type == THERMAL_TRIP_HOT)\n\t\t\t*hot_trip = trip.temperature;\n\n\t\tif (trip.type == THERMAL_TRIP_CRITICAL)\n\t\t\t*crit_trip = trip.temperature;\n\t}\n\n\t \n\t*hot_trip = clamp(*hot_trip, 25000, 90000);\n\n\t \n\t*crit_trip = clamp(*crit_trip + 5000, 25000, 90000);\n}\n\nstatic int tegra_tsensor_enable_hw_channel(const struct tegra_tsensor *ts,\n\t\t\t\t\t   unsigned int id)\n{\n\tconst struct tegra_tsensor_channel *tsc = &ts->ch[id];\n\tstruct thermal_zone_device *tzd = tsc->tzd;\n\tint err, hot_trip = 0, crit_trip = 0;\n\tu32 val;\n\n\tif (!tzd) {\n\t\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_CONFIG0);\n\t\tval &= ~TSENSOR_SENSOR0_CONFIG0_SENSOR_STOP;\n\t\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_CONFIG0);\n\n\t\treturn 0;\n\t}\n\n\ttegra_tsensor_get_hw_channel_trips(tzd, &hot_trip, &crit_trip);\n\n\tdev_info_once(ts->dev, \"ch%u: PMC emergency shutdown trip set to %dC\\n\",\n\t\t      id, DIV_ROUND_CLOSEST(crit_trip, 1000));\n\n\thot_trip  = tegra_tsensor_temp_to_counter(ts, hot_trip);\n\tcrit_trip = tegra_tsensor_temp_to_counter(ts, crit_trip);\n\n\t \n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_CONFIG1);\n\tval &= ~TSENSOR_SENSOR0_CONFIG1_TH2;\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG1_TH2, hot_trip);\n\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_CONFIG1);\n\n\t \n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_CONFIG2);\n\tval &= ~TSENSOR_SENSOR0_CONFIG2_TH3;\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG2_TH3, crit_trip);\n\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_CONFIG2);\n\n\t \n\tval = readl_relaxed(tsc->regs + TSENSOR_SENSOR0_CONFIG0);\n\tval &= ~TSENSOR_SENSOR0_CONFIG0_SENSOR_STOP;\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_DVFS_EN, 1);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_HW_FREQ_DIV_EN, 0);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_THERMAL_RST_EN, 1);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_INTR_OVERFLOW_EN, 1);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_INTR_HW_FREQ_DIV_EN, 1);\n\tval |= FIELD_PREP(TSENSOR_SENSOR0_CONFIG0_INTR_THERMAL_RST_EN, 1);\n\twritel_relaxed(val, tsc->regs + TSENSOR_SENSOR0_CONFIG0);\n\n\terr = thermal_zone_device_enable(tzd);\n\tif (err) {\n\t\tdev_err(ts->dev, \"ch%u: failed to enable zone: %d\\n\", id, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool tegra_tsensor_fuse_read_spare(unsigned int spare)\n{\n\tu32 val = 0;\n\n\ttegra_fuse_readl(TEGRA30_FUSE_SPARE_BIT + spare * 4, &val);\n\n\treturn !!val;\n}\n\nstatic int tegra_tsensor_nvmem_setup(struct tegra_tsensor *ts)\n{\n\tu32 i, ate_ver = 0, cal = 0, t1_25C = 0, t2_90C = 0;\n\tint err, c1_25C, c2_90C;\n\n\terr = tegra_fuse_readl(TEGRA30_FUSE_TEST_PROG_VER, &ate_ver);\n\tif (err) {\n\t\tdev_err_probe(ts->dev, err, \"failed to get ATE version\\n\");\n\t\treturn err;\n\t}\n\n\tif (ate_ver < 8) {\n\t\tdev_info(ts->dev, \"unsupported ATE version: %u\\n\", ate_ver);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (ate_ver <= 21) {\n\t\tdev_info_once(ts->dev,\n\t\t\t      \"older ATE version detected, channels remapped\\n\");\n\t\tts->swap_channels = true;\n\t}\n\n\terr = tegra_fuse_readl(TEGRA30_FUSE_TSENSOR_CALIB, &cal);\n\tif (err) {\n\t\tdev_err(ts->dev, \"failed to get calibration data: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tc1_25C = FIELD_GET(TEGRA30_FUSE_TSENSOR_CALIB_LOW, cal);\n\tc2_90C = FIELD_GET(TEGRA30_FUSE_TSENSOR_CALIB_HIGH, cal);\n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tt1_25C |= tegra_tsensor_fuse_read_spare(14 + i) << i;\n\t\tt1_25C |= tegra_tsensor_fuse_read_spare(21 + i) << i;\n\n\t\tt2_90C |= tegra_tsensor_fuse_read_spare(0 + i) << i;\n\t\tt2_90C |= tegra_tsensor_fuse_read_spare(7 + i) << i;\n\t}\n\n\tif (c2_90C - c1_25C <= t2_90C - t1_25C) {\n\t\tdev_err(ts->dev, \"invalid calibration data: %d %d %u %u\\n\",\n\t\t\tc2_90C, c1_25C, t2_90C, t1_25C);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tts->calib.a = DIV_ROUND_CLOSEST((t2_90C - t1_25C) * 1000000,\n\t\t\t\t\t(c2_90C - c1_25C));\n\n\tts->calib.b = t1_25C * 1000000 - ts->calib.a * c1_25C;\n\n\tif (tegra_sku_info.revision == TEGRA_REVISION_A01) {\n\t\tts->calib.m =     -2775;\n\t\tts->calib.n =   1338811;\n\t\tts->calib.p =  -7300000;\n\t} else {\n\t\tts->calib.m =     -3512;\n\t\tts->calib.n =   1528943;\n\t\tts->calib.p = -11100000;\n\t}\n\n\t \n\tts->calib.r = DIV_ROUND_CLOSEST(ts->calib.n, ts->calib.m * 2);\n\n\tdev_info_once(ts->dev,\n\t\t      \"calibration: %d %d %u %u ATE ver: %u SoC rev: %u\\n\",\n\t\t      c2_90C, c1_25C, t2_90C, t1_25C, ate_ver,\n\t\t      tegra_sku_info.revision);\n\n\treturn 0;\n}\n\nstatic int tegra_tsensor_register_channel(struct tegra_tsensor *ts,\n\t\t\t\t\t  unsigned int id)\n{\n\tstruct tegra_tsensor_channel *tsc = &ts->ch[id];\n\tunsigned int hw_id = ts->swap_channels ? !id : id;\n\n\ttsc->ts = ts;\n\ttsc->id = id;\n\ttsc->regs = ts->regs + 0x40 * (hw_id + 1);\n\n\ttsc->tzd = devm_thermal_of_zone_register(ts->dev, id, tsc, &ops);\n\tif (IS_ERR(tsc->tzd)) {\n\t\tif (PTR_ERR(tsc->tzd) != -ENODEV)\n\t\t\treturn dev_err_probe(ts->dev, PTR_ERR(tsc->tzd),\n\t\t\t\t\t     \"failed to register thermal zone\\n\");\n\n\t\t \n\t\ttsc->tzd = NULL;\n\t\treturn 0;\n\t}\n\n\tdevm_thermal_add_hwmon_sysfs(ts->dev, tsc->tzd);\n\n\treturn 0;\n}\n\nstatic int tegra_tsensor_probe(struct platform_device *pdev)\n{\n\tstruct tegra_tsensor *ts;\n\tunsigned int i;\n\tint err, irq;\n\n\tts = devm_kzalloc(&pdev->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tts->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ts);\n\n\tts->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ts->regs))\n\t\treturn PTR_ERR(ts->regs);\n\n\tts->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ts->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ts->clk),\n\t\t\t\t     \"failed to get clock\\n\");\n\n\tts->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(ts->rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ts->rst),\n\t\t\t\t     \"failed to get reset control\\n\");\n\n\terr = tegra_tsensor_nvmem_setup(ts);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_tsensor_hw_enable(ts);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       devm_tegra_tsensor_hw_disable,\n\t\t\t\t       ts);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ts->ch); i++) {\n\t\terr = tegra_tsensor_register_channel(ts, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ts->ch); i++) {\n\t\terr = tegra_tsensor_enable_hw_channel(ts, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\ttegra_tsensor_isr, IRQF_ONESHOT,\n\t\t\t\t\t\"tegra_tsensor\", ts);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"failed to request interrupt\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_tsensor_suspend(struct device *dev)\n{\n\tstruct tegra_tsensor *ts = dev_get_drvdata(dev);\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ts->ch); i++) {\n\t\terr = tegra_tsensor_disable_hw_channel(ts, i);\n\t\tif (err)\n\t\t\tgoto enable_channel;\n\t}\n\n\terr = tegra_tsensor_hw_disable(ts);\n\tif (err)\n\t\tgoto enable_channel;\n\n\treturn 0;\n\nenable_channel:\n\twhile (i--)\n\t\ttegra_tsensor_enable_hw_channel(ts, i);\n\n\treturn err;\n}\n\nstatic int __maybe_unused tegra_tsensor_resume(struct device *dev)\n{\n\tstruct tegra_tsensor *ts = dev_get_drvdata(dev);\n\tunsigned int i;\n\tint err;\n\n\terr = tegra_tsensor_hw_enable(ts);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ts->ch); i++) {\n\t\terr = tegra_tsensor_enable_hw_channel(ts, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_tsensor_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(tegra_tsensor_suspend,\n\t\t\t\t      tegra_tsensor_resume)\n};\n\nstatic const struct of_device_id tegra_tsensor_of_match[] = {\n\t{ .compatible = \"nvidia,tegra30-tsensor\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra_tsensor_of_match);\n\nstatic struct platform_driver tegra_tsensor_driver = {\n\t.probe = tegra_tsensor_probe,\n\t.driver = {\n\t\t.name = \"tegra30-tsensor\",\n\t\t.of_match_table = tegra_tsensor_of_match,\n\t\t.pm = &tegra_tsensor_pm_ops,\n\t},\n};\nmodule_platform_driver(tegra_tsensor_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra30 Thermal Sensor driver\");\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}