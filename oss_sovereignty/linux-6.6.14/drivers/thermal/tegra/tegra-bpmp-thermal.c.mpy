{
  "module_name": "tegra-bpmp-thermal.c",
  "hash_id": "06dc87a1ae4fee47b6ea3be72e559217abe4ee8aefb2f2713a5d02349e0b3a18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/tegra/tegra-bpmp-thermal.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n#include <linux/workqueue.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n\nstruct tegra_bpmp_thermal_zone {\n\tstruct tegra_bpmp_thermal *tegra;\n\tstruct thermal_zone_device *tzd;\n\tstruct work_struct tz_device_update_work;\n\tunsigned int idx;\n};\n\nstruct tegra_bpmp_thermal {\n\tstruct device *dev;\n\tstruct tegra_bpmp *bpmp;\n\tunsigned int num_zones;\n\tstruct tegra_bpmp_thermal_zone **zones;\n};\n\nstatic int __tegra_bpmp_thermal_get_temp(struct tegra_bpmp_thermal_zone *zone,\n\t\t\t\t\t int *out_temp)\n{\n\tstruct mrq_thermal_host_to_bpmp_request req;\n\tunion mrq_thermal_bpmp_to_host_response reply;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.type = CMD_THERMAL_GET_TEMP;\n\treq.get_temp.zone = zone->idx;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_THERMAL;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\tmsg.rx.data = &reply;\n\tmsg.rx.size = sizeof(reply);\n\n\terr = tegra_bpmp_transfer(zone->tegra->bpmp, &msg);\n\tif (err)\n\t\treturn err;\n\tif (msg.rx.ret == -BPMP_EFAULT)\n\t\treturn -EAGAIN;\n\tif (msg.rx.ret)\n\t\treturn -EINVAL;\n\n\t*out_temp = reply.get_temp.temp;\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_thermal_get_temp(struct thermal_zone_device *tz, int *out_temp)\n{\n\tstruct tegra_bpmp_thermal_zone *zone = thermal_zone_device_priv(tz);\n\n\treturn __tegra_bpmp_thermal_get_temp(zone, out_temp);\n}\n\nstatic int tegra_bpmp_thermal_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct tegra_bpmp_thermal_zone *zone = thermal_zone_device_priv(tz);\n\tstruct mrq_thermal_host_to_bpmp_request req;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.type = CMD_THERMAL_SET_TRIP;\n\treq.set_trip.zone = zone->idx;\n\treq.set_trip.enabled = true;\n\treq.set_trip.low = low;\n\treq.set_trip.high = high;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_THERMAL;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\n\terr = tegra_bpmp_transfer(zone->tegra->bpmp, &msg);\n\tif (err)\n\t\treturn err;\n\tif (msg.rx.ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void tz_device_update_work_fn(struct work_struct *work)\n{\n\tstruct tegra_bpmp_thermal_zone *zone;\n\n\tzone = container_of(work, struct tegra_bpmp_thermal_zone,\n\t\t\t    tz_device_update_work);\n\n\tthermal_zone_device_update(zone->tzd, THERMAL_TRIP_VIOLATED);\n}\n\nstatic void bpmp_mrq_thermal(unsigned int mrq, struct tegra_bpmp_channel *ch,\n\t\t\t     void *data)\n{\n\tstruct mrq_thermal_bpmp_to_host_request req;\n\tstruct tegra_bpmp_thermal *tegra = data;\n\tsize_t offset;\n\tint i;\n\n\toffset = offsetof(struct tegra_bpmp_mb_data, data);\n\tiosys_map_memcpy_from(&req, &ch->ib, offset, sizeof(req));\n\n\tif (req.type != CMD_THERMAL_HOST_TRIP_REACHED) {\n\t\tdev_err(tegra->dev, \"%s: invalid request type: %d\\n\", __func__, req.type);\n\t\ttegra_bpmp_mrq_return(ch, -EINVAL, NULL, 0);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < tegra->num_zones; ++i) {\n\t\tif (tegra->zones[i]->idx != req.host_trip_reached.zone)\n\t\t\tcontinue;\n\n\t\tschedule_work(&tegra->zones[i]->tz_device_update_work);\n\t\ttegra_bpmp_mrq_return(ch, 0, NULL, 0);\n\t\treturn;\n\t}\n\n\tdev_err(tegra->dev, \"%s: invalid thermal zone: %d\\n\", __func__,\n\t\treq.host_trip_reached.zone);\n\ttegra_bpmp_mrq_return(ch, -EINVAL, NULL, 0);\n}\n\nstatic int tegra_bpmp_thermal_get_num_zones(struct tegra_bpmp *bpmp,\n\t\t\t\t\t    int *num_zones)\n{\n\tstruct mrq_thermal_host_to_bpmp_request req;\n\tunion mrq_thermal_bpmp_to_host_response reply;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.type = CMD_THERMAL_GET_NUM_ZONES;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_THERMAL;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\tmsg.rx.data = &reply;\n\tmsg.rx.size = sizeof(reply);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err)\n\t\treturn err;\n\tif (msg.rx.ret)\n\t\treturn -EINVAL;\n\n\t*num_zones = reply.get_num_zones.num;\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_thermal_trips_supported(struct tegra_bpmp *bpmp, bool *supported)\n{\n\tstruct mrq_thermal_host_to_bpmp_request req;\n\tunion mrq_thermal_bpmp_to_host_response reply;\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.type = CMD_THERMAL_QUERY_ABI;\n\treq.query_abi.type = CMD_THERMAL_SET_TRIP;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_THERMAL;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\tmsg.rx.data = &reply;\n\tmsg.rx.size = sizeof(reply);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err)\n\t\treturn err;\n\n\tif (msg.rx.ret == 0) {\n\t\t*supported = true;\n\t\treturn 0;\n\t} else if (msg.rx.ret == -BPMP_ENODEV) {\n\t\t*supported = false;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct thermal_zone_device_ops tegra_bpmp_of_thermal_ops = {\n\t.get_temp = tegra_bpmp_thermal_get_temp,\n\t.set_trips = tegra_bpmp_thermal_set_trips,\n};\n\nstatic const struct thermal_zone_device_ops tegra_bpmp_of_thermal_ops_notrips = {\n\t.get_temp = tegra_bpmp_thermal_get_temp,\n};\n\nstatic int tegra_bpmp_thermal_probe(struct platform_device *pdev)\n{\n\tstruct tegra_bpmp *bpmp = dev_get_drvdata(pdev->dev.parent);\n\tconst struct thermal_zone_device_ops *thermal_ops;\n\tstruct tegra_bpmp_thermal *tegra;\n\tstruct thermal_zone_device *tzd;\n\tunsigned int i, max_num_zones;\n\tbool supported;\n\tint err;\n\n\terr = tegra_bpmp_thermal_trips_supported(bpmp, &supported);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to determine if trip points are supported\\n\");\n\t\treturn err;\n\t}\n\n\tif (supported)\n\t\tthermal_ops = &tegra_bpmp_of_thermal_ops;\n\telse\n\t\tthermal_ops = &tegra_bpmp_of_thermal_ops_notrips;\n\n\ttegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn -ENOMEM;\n\n\ttegra->dev = &pdev->dev;\n\ttegra->bpmp = bpmp;\n\n\terr = tegra_bpmp_thermal_get_num_zones(bpmp, &max_num_zones);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to get the number of zones: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\ttegra->zones = devm_kcalloc(&pdev->dev, max_num_zones,\n\t\t\t\t    sizeof(*tegra->zones), GFP_KERNEL);\n\tif (!tegra->zones)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_num_zones; ++i) {\n\t\tstruct tegra_bpmp_thermal_zone *zone;\n\t\tint temp;\n\n\t\tzone = devm_kzalloc(&pdev->dev, sizeof(*zone), GFP_KERNEL);\n\t\tif (!zone)\n\t\t\treturn -ENOMEM;\n\n\t\tzone->idx = i;\n\t\tzone->tegra = tegra;\n\n\t\terr = __tegra_bpmp_thermal_get_temp(zone, &temp);\n\n\t\t \n\t\tif (err < 0 && err != -EAGAIN) {\n\t\t\tdevm_kfree(&pdev->dev, zone);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttzd = devm_thermal_of_zone_register(\n\t\t\t&pdev->dev, i, zone, thermal_ops);\n\t\tif (IS_ERR(tzd)) {\n\t\t\tif (PTR_ERR(tzd) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tdevm_kfree(&pdev->dev, zone);\n\t\t\tcontinue;\n\t\t}\n\n\t\tzone->tzd = tzd;\n\t\tINIT_WORK(&zone->tz_device_update_work,\n\t\t\t  tz_device_update_work_fn);\n\n\t\ttegra->zones[tegra->num_zones++] = zone;\n\t}\n\n\terr = tegra_bpmp_request_mrq(bpmp, MRQ_THERMAL, bpmp_mrq_thermal,\n\t\t\t\t     tegra);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register mrq handler: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, tegra);\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_thermal_remove(struct platform_device *pdev)\n{\n\tstruct tegra_bpmp_thermal *tegra = platform_get_drvdata(pdev);\n\n\ttegra_bpmp_free_mrq(tegra->bpmp, MRQ_THERMAL, tegra);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_bpmp_thermal_of_match[] = {\n\t{ .compatible = \"nvidia,tegra186-bpmp-thermal\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_bpmp_thermal_of_match);\n\nstatic struct platform_driver tegra_bpmp_thermal_driver = {\n\t.probe = tegra_bpmp_thermal_probe,\n\t.remove = tegra_bpmp_thermal_remove,\n\t.driver = {\n\t\t.name = \"tegra-bpmp-thermal\",\n\t\t.of_match_table = tegra_bpmp_thermal_of_match,\n\t},\n};\nmodule_platform_driver(tegra_bpmp_thermal_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra BPMP thermal sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}