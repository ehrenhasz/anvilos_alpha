{
  "module_name": "ti-thermal-common.c",
  "hash_id": "089255cbbdebc0080dce7b2f5e6ee511d1696a92ee80b145ce1481245351b61b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/ti-soc-thermal/ti-thermal-common.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/thermal.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/cpu_cooling.h>\n#include <linux/of.h>\n\n#include \"ti-thermal.h\"\n#include \"ti-bandgap.h\"\n#include \"../thermal_hwmon.h\"\n\n#define TI_BANDGAP_UPDATE_INTERVAL_MS 250\n\n \nstruct ti_thermal_data {\n\tstruct cpufreq_policy *policy;\n\tstruct thermal_zone_device *ti_thermal;\n\tstruct thermal_zone_device *pcb_tz;\n\tstruct thermal_cooling_device *cool_dev;\n\tstruct ti_bandgap *bgp;\n\tenum thermal_device_mode mode;\n\tstruct work_struct thermal_wq;\n\tint sensor_id;\n\tbool our_zone;\n};\n\nstatic void ti_thermal_work(struct work_struct *work)\n{\n\tstruct ti_thermal_data *data = container_of(work,\n\t\t\t\t\tstruct ti_thermal_data, thermal_wq);\n\n\tthermal_zone_device_update(data->ti_thermal, THERMAL_EVENT_UNSPECIFIED);\n\n\tdev_dbg(data->bgp->dev, \"updated thermal zone %s\\n\",\n\t\tthermal_zone_device_type(data->ti_thermal));\n}\n\n \nstatic inline int ti_thermal_hotspot_temperature(int t, int s, int c)\n{\n\tint delta = t * s / 1000 + c;\n\n\tif (delta < 0)\n\t\tdelta = 0;\n\n\treturn t + delta;\n}\n\n \n \nstatic inline int __ti_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct thermal_zone_device *pcb_tz = NULL;\n\tstruct ti_thermal_data *data = thermal_zone_device_priv(tz);\n\tstruct ti_bandgap *bgp;\n\tconst struct ti_temp_sensor *s;\n\tint ret, tmp, slope, constant;\n\tint pcb_temp;\n\n\tif (!data)\n\t\treturn 0;\n\n\tbgp = data->bgp;\n\ts = &bgp->conf->sensors[data->sensor_id];\n\n\tret = ti_bandgap_read_temperature(bgp, data->sensor_id, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tslope = thermal_zone_get_slope(tz);\n\tconstant = thermal_zone_get_offset(tz);\n\n\tpcb_tz = data->pcb_tz;\n\t \n\tif (!IS_ERR(pcb_tz)) {\n\t\tret = thermal_zone_get_temp(pcb_tz, &pcb_temp);\n\t\tif (!ret) {\n\t\t\ttmp -= pcb_temp;  \n\t\t\tslope = s->slope_pcb;\n\t\t\tconstant = s->constant_pcb;\n\t\t} else {\n\t\t\tdev_err(bgp->dev,\n\t\t\t\t\"Failed to read PCB state. Using defaults\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\t*temp = ti_thermal_hotspot_temperature(tmp, slope, constant);\n\n\treturn ret;\n}\n\nstatic int __ti_thermal_get_trend(struct thermal_zone_device *tz,\n\t\t\t\t  const struct thermal_trip *trip,\n\t\t\t\t  enum thermal_trend *trend)\n{\n\tstruct ti_thermal_data *data = thermal_zone_device_priv(tz);\n\tstruct ti_bandgap *bgp;\n\tint id, tr, ret = 0;\n\n\tbgp = data->bgp;\n\tid = data->sensor_id;\n\n\tret = ti_bandgap_get_trend(bgp, id, &tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tr > 0)\n\t\t*trend = THERMAL_TREND_RAISING;\n\telse if (tr < 0)\n\t\t*trend = THERMAL_TREND_DROPPING;\n\telse\n\t\t*trend = THERMAL_TREND_STABLE;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops ti_of_thermal_ops = {\n\t.get_temp = __ti_thermal_get_temp,\n\t.get_trend = __ti_thermal_get_trend,\n};\n\nstatic struct ti_thermal_data\n*ti_thermal_build_data(struct ti_bandgap *bgp, int id)\n{\n\tstruct ti_thermal_data *data;\n\n\tdata = devm_kzalloc(bgp->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tdev_err(bgp->dev, \"kzalloc fail\\n\");\n\t\treturn NULL;\n\t}\n\tdata->sensor_id = id;\n\tdata->bgp = bgp;\n\tdata->mode = THERMAL_DEVICE_ENABLED;\n\t \n\tdata->pcb_tz = thermal_zone_get_zone_by_name(\"pcb\");\n\tINIT_WORK(&data->thermal_wq, ti_thermal_work);\n\n\treturn data;\n}\n\nint ti_thermal_expose_sensor(struct ti_bandgap *bgp, int id,\n\t\t\t     char *domain)\n{\n\tstruct ti_thermal_data *data;\n\n\tdata = ti_bandgap_get_sensor_data(bgp, id);\n\n\tif (IS_ERR_OR_NULL(data))\n\t\tdata = ti_thermal_build_data(bgp, id);\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\t \n\tdata->ti_thermal = devm_thermal_of_zone_register(bgp->dev, id,\n\t\t\t\t\tdata, &ti_of_thermal_ops);\n\tif (IS_ERR(data->ti_thermal)) {\n\t\tdev_err(bgp->dev, \"thermal zone device is NULL\\n\");\n\t\treturn PTR_ERR(data->ti_thermal);\n\t}\n\n\tti_bandgap_set_sensor_data(bgp, id, data);\n\tti_bandgap_write_update_interval(bgp, data->sensor_id,\n\t\t\t\t\t TI_BANDGAP_UPDATE_INTERVAL_MS);\n\n\tdevm_thermal_add_hwmon_sysfs(bgp->dev, data->ti_thermal);\n\n\treturn 0;\n}\n\nint ti_thermal_remove_sensor(struct ti_bandgap *bgp, int id)\n{\n\tstruct ti_thermal_data *data;\n\n\tdata = ti_bandgap_get_sensor_data(bgp, id);\n\n\tif (!IS_ERR_OR_NULL(data) && data->ti_thermal) {\n\t\tif (data->our_zone)\n\t\t\tthermal_zone_device_unregister(data->ti_thermal);\n\t}\n\n\treturn 0;\n}\n\nint ti_thermal_report_sensor_temperature(struct ti_bandgap *bgp, int id)\n{\n\tstruct ti_thermal_data *data;\n\n\tdata = ti_bandgap_get_sensor_data(bgp, id);\n\n\tschedule_work(&data->thermal_wq);\n\n\treturn 0;\n}\n\nint ti_thermal_register_cpu_cooling(struct ti_bandgap *bgp, int id)\n{\n\tstruct ti_thermal_data *data;\n\tstruct device_node *np = bgp->dev->of_node;\n\n\t \n\tif (of_property_present(np, \"#thermal-sensor-cells\"))\n\t\treturn 0;\n\n\tdata = ti_bandgap_get_sensor_data(bgp, id);\n\tif (!data || IS_ERR(data))\n\t\tdata = ti_thermal_build_data(bgp, id);\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tdata->policy = cpufreq_cpu_get(0);\n\tif (!data->policy) {\n\t\tpr_debug(\"%s: CPUFreq policy not found\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tdata->cool_dev = cpufreq_cooling_register(data->policy);\n\tif (IS_ERR(data->cool_dev)) {\n\t\tint ret = PTR_ERR(data->cool_dev);\n\t\tdev_err(bgp->dev, \"Failed to register cpu cooling device %d\\n\",\n\t\t\tret);\n\t\tcpufreq_cpu_put(data->policy);\n\n\t\treturn ret;\n\t}\n\tti_bandgap_set_sensor_data(bgp, id, data);\n\n\treturn 0;\n}\n\nint ti_thermal_unregister_cpu_cooling(struct ti_bandgap *bgp, int id)\n{\n\tstruct ti_thermal_data *data;\n\n\tdata = ti_bandgap_get_sensor_data(bgp, id);\n\n\tif (!IS_ERR_OR_NULL(data)) {\n\t\tcpufreq_cooling_unregister(data->cool_dev);\n\t\tif (data->policy)\n\t\t\tcpufreq_cpu_put(data->policy);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}