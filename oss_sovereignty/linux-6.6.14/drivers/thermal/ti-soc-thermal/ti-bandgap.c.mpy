{
  "module_name": "ti-bandgap.c",
  "hash_id": "cde60e04cd8cd22785f7300b3491fecd60d7e9d4d82233771fec63928c832bfa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/ti-soc-thermal/ti-bandgap.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpu_pm.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/sys_soc.h>\n#include <linux/types.h>\n\n#include \"ti-bandgap.h\"\n\nstatic int ti_bandgap_force_single_read(struct ti_bandgap *bgp, int id);\n#ifdef CONFIG_PM_SLEEP\nstatic int bandgap_omap_cpu_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long cmd, void *v);\n#endif\n\n \n\n \nstatic u32 ti_bandgap_readl(struct ti_bandgap *bgp, u32 reg)\n{\n\treturn readl(bgp->base + reg);\n}\n\n \nstatic void ti_bandgap_writel(struct ti_bandgap *bgp, u32 val, u32 reg)\n{\n\twritel(val, bgp->base + reg);\n}\n\n \n#define RMW_BITS(bgp, id, reg, mask, val)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstruct temp_sensor_registers *t;\t\t\t\\\n\tu32 r;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tt = bgp->conf->sensors[(id)].registers;\t\t\\\n\tr = ti_bandgap_readl(bgp, t->reg);\t\t\t\\\n\tr &= ~t->mask;\t\t\t\t\t\t\\\n\tr |= (val) << __ffs(t->mask);\t\t\t\t\\\n\tti_bandgap_writel(bgp, r, t->reg);\t\t\t\\\n} while (0)\n\n \n\n \nstatic int ti_bandgap_power(struct ti_bandgap *bgp, bool on)\n{\n\tint i;\n\n\tif (!TI_BANDGAP_HAS(bgp, POWER_SWITCH))\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < bgp->conf->sensor_count; i++)\n\t\t \n\t\tRMW_BITS(bgp, i, temp_sensor_ctrl, bgap_tempsoff_mask, !on);\n\treturn 0;\n}\n\n \nstatic u32 ti_errata814_bandgap_read_temp(struct ti_bandgap *bgp,  u32 reg)\n{\n\tu32 val1, val2;\n\n\tval1 = ti_bandgap_readl(bgp, reg);\n\tval2 = ti_bandgap_readl(bgp, reg);\n\n\t \n\tif (val1 == val2)\n\t\treturn val1;\n\n\t \n\treturn ti_bandgap_readl(bgp, reg);\n}\n\n \nstatic u32 ti_bandgap_read_temp(struct ti_bandgap *bgp, int id)\n{\n\tstruct temp_sensor_registers *tsr;\n\tu32 temp, reg;\n\n\ttsr = bgp->conf->sensors[id].registers;\n\treg = tsr->temp_sensor_ctrl;\n\n\tif (TI_BANDGAP_HAS(bgp, FREEZE_BIT)) {\n\t\tRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 1);\n\t\t \n\t\treg = tsr->ctrl_dtemp_1;\n\t}\n\n\t \n\tif (TI_BANDGAP_HAS(bgp, ERRATA_814))\n\t\ttemp = ti_errata814_bandgap_read_temp(bgp, reg);\n\telse\n\t\ttemp = ti_bandgap_readl(bgp, reg);\n\n\ttemp &= tsr->bgap_dtemp_mask;\n\n\tif (TI_BANDGAP_HAS(bgp, FREEZE_BIT))\n\t\tRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 0);\n\n\treturn temp;\n}\n\n \n\n \nstatic irqreturn_t ti_bandgap_talert_irq_handler(int irq, void *data)\n{\n\tstruct ti_bandgap *bgp = data;\n\tstruct temp_sensor_registers *tsr;\n\tu32 t_hot = 0, t_cold = 0, ctrl;\n\tint i;\n\n\tspin_lock(&bgp->lock);\n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\ttsr = bgp->conf->sensors[i].registers;\n\t\tctrl = ti_bandgap_readl(bgp, tsr->bgap_status);\n\n\t\t \n\t\tt_hot = ctrl & tsr->status_hot_mask;\n\n\t\t \n\t\tt_cold = ctrl & tsr->status_cold_mask;\n\n\t\tif (!t_cold && !t_hot)\n\t\t\tcontinue;\n\n\t\tctrl = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\n\t\t \n\t\tif (t_hot) {\n\t\t\tctrl &= ~tsr->mask_hot_mask;\n\t\t\tctrl |= tsr->mask_cold_mask;\n\t\t} else if (t_cold) {\n\t\t\tctrl &= ~tsr->mask_cold_mask;\n\t\t\tctrl |= tsr->mask_hot_mask;\n\t\t}\n\n\t\tti_bandgap_writel(bgp, ctrl, tsr->bgap_mask_ctrl);\n\n\t\tdev_dbg(bgp->dev,\n\t\t\t\"%s: IRQ from %s sensor: hotevent %d coldevent %d\\n\",\n\t\t\t__func__, bgp->conf->sensors[i].domain,\n\t\t\tt_hot, t_cold);\n\n\t\t \n\t\tif (bgp->conf->report_temperature)\n\t\t\tbgp->conf->report_temperature(bgp, i);\n\t}\n\tspin_unlock(&bgp->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t ti_bandgap_tshut_irq_handler(int irq, void *data)\n{\n\tpr_emerg(\"%s: TSHUT temperature reached. Needs shut down...\\n\",\n\t\t __func__);\n\n\torderly_poweroff(true);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic\nint ti_bandgap_adc_to_mcelsius(struct ti_bandgap *bgp, int adc_val, int *t)\n{\n\tconst struct ti_bandgap_data *conf = bgp->conf;\n\n\t \n\tif (adc_val < conf->adc_start_val || adc_val > conf->adc_end_val)\n\t\treturn -ERANGE;\n\n\t*t = bgp->conf->conv_table[adc_val - conf->adc_start_val];\n\treturn 0;\n}\n\n \nstatic inline int ti_bandgap_validate(struct ti_bandgap *bgp, int id)\n{\n\tif (IS_ERR_OR_NULL(bgp)) {\n\t\tpr_err(\"%s: invalid bandgap pointer\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((id < 0) || (id >= bgp->conf->sensor_count)) {\n\t\tdev_err(bgp->dev, \"%s: sensor id out of range (%d)\\n\",\n\t\t\t__func__, id);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ti_bandgap_read_counter(struct ti_bandgap *bgp, int id,\n\t\t\t\t    int *interval)\n{\n\tstruct temp_sensor_registers *tsr;\n\tint time;\n\n\ttsr = bgp->conf->sensors[id].registers;\n\ttime = ti_bandgap_readl(bgp, tsr->bgap_counter);\n\ttime = (time & tsr->counter_mask) >>\n\t\t\t\t\t__ffs(tsr->counter_mask);\n\ttime = time * 1000 / bgp->clk_rate;\n\t*interval = time;\n}\n\n \nstatic void ti_bandgap_read_counter_delay(struct ti_bandgap *bgp, int id,\n\t\t\t\t\t  int *interval)\n{\n\tstruct temp_sensor_registers *tsr;\n\tint reg_val;\n\n\ttsr = bgp->conf->sensors[id].registers;\n\n\treg_val = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\n\treg_val = (reg_val & tsr->mask_counter_delay_mask) >>\n\t\t\t\t__ffs(tsr->mask_counter_delay_mask);\n\tswitch (reg_val) {\n\tcase 0:\n\t\t*interval = 0;\n\t\tbreak;\n\tcase 1:\n\t\t*interval = 1;\n\t\tbreak;\n\tcase 2:\n\t\t*interval = 10;\n\t\tbreak;\n\tcase 3:\n\t\t*interval = 100;\n\t\tbreak;\n\tcase 4:\n\t\t*interval = 250;\n\t\tbreak;\n\tcase 5:\n\t\t*interval = 500;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(bgp->dev, \"Wrong counter delay value read from register %X\",\n\t\t\t reg_val);\n\t}\n}\n\n \nint ti_bandgap_read_update_interval(struct ti_bandgap *bgp, int id,\n\t\t\t\t    int *interval)\n{\n\tint ret = 0;\n\n\tret = ti_bandgap_validate(bgp, id);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (!TI_BANDGAP_HAS(bgp, COUNTER) &&\n\t    !TI_BANDGAP_HAS(bgp, COUNTER_DELAY)) {\n\t\tret = -ENOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tif (TI_BANDGAP_HAS(bgp, COUNTER)) {\n\t\tti_bandgap_read_counter(bgp, id, interval);\n\t\tgoto exit;\n\t}\n\n\tti_bandgap_read_counter_delay(bgp, id, interval);\nexit:\n\treturn ret;\n}\n\n \nstatic int ti_bandgap_write_counter_delay(struct ti_bandgap *bgp, int id,\n\t\t\t\t\t  u32 interval)\n{\n\tint rval;\n\n\tswitch (interval) {\n\tcase 0:  \n\t\trval = 0x0;\n\t\tbreak;\n\tcase 1:  \n\t\trval = 0x1;\n\t\tbreak;\n\tcase 10:  \n\t\trval = 0x2;\n\t\tbreak;\n\tcase 100:  \n\t\trval = 0x3;\n\t\tbreak;\n\tcase 250:  \n\t\trval = 0x4;\n\t\tbreak;\n\tcase 500:  \n\t\trval = 0x5;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(bgp->dev, \"Delay %d ms is not supported\\n\", interval);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&bgp->lock);\n\tRMW_BITS(bgp, id, bgap_mask_ctrl, mask_counter_delay_mask, rval);\n\tspin_unlock(&bgp->lock);\n\n\treturn 0;\n}\n\n \nstatic void ti_bandgap_write_counter(struct ti_bandgap *bgp, int id,\n\t\t\t\t     u32 interval)\n{\n\tinterval = interval * bgp->clk_rate / 1000;\n\tspin_lock(&bgp->lock);\n\tRMW_BITS(bgp, id, bgap_counter, counter_mask, interval);\n\tspin_unlock(&bgp->lock);\n}\n\n \nint ti_bandgap_write_update_interval(struct ti_bandgap *bgp,\n\t\t\t\t     int id, u32 interval)\n{\n\tint ret = ti_bandgap_validate(bgp, id);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (!TI_BANDGAP_HAS(bgp, COUNTER) &&\n\t    !TI_BANDGAP_HAS(bgp, COUNTER_DELAY)) {\n\t\tret = -ENOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tif (TI_BANDGAP_HAS(bgp, COUNTER)) {\n\t\tti_bandgap_write_counter(bgp, id, interval);\n\t\tgoto exit;\n\t}\n\n\tret = ti_bandgap_write_counter_delay(bgp, id, interval);\nexit:\n\treturn ret;\n}\n\n \nint ti_bandgap_read_temperature(struct ti_bandgap *bgp, int id,\n\t\t\t\tint *temperature)\n{\n\tu32 temp;\n\tint ret;\n\n\tret = ti_bandgap_validate(bgp, id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!TI_BANDGAP_HAS(bgp, MODE_CONFIG)) {\n\t\tret = ti_bandgap_force_single_read(bgp, id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock(&bgp->lock);\n\ttemp = ti_bandgap_read_temp(bgp, id);\n\tspin_unlock(&bgp->lock);\n\n\tret = ti_bandgap_adc_to_mcelsius(bgp, temp, &temp);\n\tif (ret)\n\t\treturn -EIO;\n\n\t*temperature = temp;\n\n\treturn 0;\n}\n\n \nint ti_bandgap_set_sensor_data(struct ti_bandgap *bgp, int id, void *data)\n{\n\tint ret = ti_bandgap_validate(bgp, id);\n\tif (ret)\n\t\treturn ret;\n\n\tbgp->regval[id].data = data;\n\n\treturn 0;\n}\n\n \nvoid *ti_bandgap_get_sensor_data(struct ti_bandgap *bgp, int id)\n{\n\tint ret = ti_bandgap_validate(bgp, id);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn bgp->regval[id].data;\n}\n\n \n\n \nstatic int\nti_bandgap_force_single_read(struct ti_bandgap *bgp, int id)\n{\n\tstruct temp_sensor_registers *tsr = bgp->conf->sensors[id].registers;\n\tvoid __iomem *temp_sensor_ctrl = bgp->base + tsr->temp_sensor_ctrl;\n\tint error;\n\tu32 val;\n\n\t \n\tif (TI_BANDGAP_HAS(bgp, MODE_CONFIG)) {\n\t\tif (TI_BANDGAP_HAS(bgp, CONT_MODE_ONLY))\n\t\t\tRMW_BITS(bgp, id, bgap_mode_ctrl, mode_ctrl_mask, 1);\n\t\telse\n\t\t\tRMW_BITS(bgp, id, bgap_mode_ctrl, mode_ctrl_mask, 0);\n\t}\n\n\t \n\tif (tsr->bgap_soc_mask) {\n\t\tRMW_BITS(bgp, id, temp_sensor_ctrl, bgap_soc_mask, 1);\n\n\t\t \n\t\terror = readl_poll_timeout_atomic(temp_sensor_ctrl, val,\n\t\t\t\t\t\t  val & tsr->bgap_eocz_mask,\n\t\t\t\t\t\t  1, 1000);\n\t\tif (error)\n\t\t\tdev_warn(bgp->dev, \"eocz timed out waiting high\\n\");\n\n\t\t \n\t\tRMW_BITS(bgp, id, temp_sensor_ctrl, bgap_soc_mask, 0);\n\t}\n\n\t \n\terror = readl_poll_timeout_atomic(temp_sensor_ctrl, val,\n\t\t\t\t\t  !(val & tsr->bgap_eocz_mask),\n\t\t\t\t\t  1, 1500);\n\tif (error)\n\t\tdev_warn(bgp->dev, \"eocz timed out waiting low\\n\");\n\n\treturn 0;\n}\n\n \nstatic int ti_bandgap_set_continuous_mode(struct ti_bandgap *bgp)\n{\n\tint i;\n\n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\t \n\t\tti_bandgap_force_single_read(bgp, i);\n\t\tRMW_BITS(bgp, i, bgap_mode_ctrl, mode_ctrl_mask, 1);\n\t}\n\n\treturn 0;\n}\n\n \nint ti_bandgap_get_trend(struct ti_bandgap *bgp, int id, int *trend)\n{\n\tstruct temp_sensor_registers *tsr;\n\tu32 temp1, temp2, reg1, reg2;\n\tint t1, t2, interval, ret = 0;\n\n\tret = ti_bandgap_validate(bgp, id);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (!TI_BANDGAP_HAS(bgp, HISTORY_BUFFER) ||\n\t    !TI_BANDGAP_HAS(bgp, FREEZE_BIT)) {\n\t\tret = -ENOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&bgp->lock);\n\n\ttsr = bgp->conf->sensors[id].registers;\n\n\t \n\tRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 1);\n\treg1 = tsr->ctrl_dtemp_1;\n\treg2 = tsr->ctrl_dtemp_2;\n\n\t \n\ttemp1 = ti_bandgap_readl(bgp, reg1);\n\ttemp1 &= tsr->bgap_dtemp_mask;\n\n\ttemp2 = ti_bandgap_readl(bgp, reg2);\n\ttemp2 &= tsr->bgap_dtemp_mask;\n\n\t \n\tret = ti_bandgap_adc_to_mcelsius(bgp, temp1, &t1);\n\tif (ret)\n\t\tgoto unfreeze;\n\n\tret = ti_bandgap_adc_to_mcelsius(bgp, temp2, &t2);\n\tif (ret)\n\t\tgoto unfreeze;\n\n\t \n\tret = ti_bandgap_read_update_interval(bgp, id, &interval);\n\tif (ret)\n\t\tgoto unfreeze;\n\n\t \n\tif (interval == 0)\n\t\tinterval = 1;\n\n\t*trend = (t1 - t2) / interval;\n\n\tdev_dbg(bgp->dev, \"The temperatures are t1 = %d and t2 = %d and trend =%d\\n\",\n\t\tt1, t2, *trend);\n\nunfreeze:\n\tRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 0);\n\tspin_unlock(&bgp->lock);\nexit:\n\treturn ret;\n}\n\n \nstatic int ti_bandgap_tshut_init(struct ti_bandgap *bgp,\n\t\t\t\t struct platform_device *pdev)\n{\n\tint status;\n\n\tstatus = request_irq(gpiod_to_irq(bgp->tshut_gpiod),\n\t\t\t     ti_bandgap_tshut_irq_handler,\n\t\t\t     IRQF_TRIGGER_RISING, \"tshut\", NULL);\n\tif (status)\n\t\tdev_err(bgp->dev, \"request irq failed for TSHUT\");\n\n\treturn 0;\n}\n\n \nstatic int ti_bandgap_talert_init(struct ti_bandgap *bgp,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tint ret;\n\n\tbgp->irq = platform_get_irq(pdev, 0);\n\tif (bgp->irq < 0)\n\t\treturn bgp->irq;\n\n\tret = request_threaded_irq(bgp->irq, NULL,\n\t\t\t\t   ti_bandgap_talert_irq_handler,\n\t\t\t\t   IRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t   \"talert\", bgp);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Request threaded irq failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_ti_bandgap_match[];\n \nstatic struct ti_bandgap *ti_bandgap_build(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\tstruct ti_bandgap *bgp;\n\tstruct resource *res;\n\tint i;\n\n\t \n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"no platform information available\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbgp = devm_kzalloc(&pdev->dev, sizeof(*bgp), GFP_KERNEL);\n\tif (!bgp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_id = of_match_device(of_ti_bandgap_match, &pdev->dev);\n\tif (of_id)\n\t\tbgp->conf = of_id->data;\n\n\t \n\tbgp->regval = devm_kcalloc(&pdev->dev, bgp->conf->sensor_count,\n\t\t\t\t   sizeof(*bgp->regval), GFP_KERNEL);\n\tif (!bgp->regval)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ti = 0;\n\tdo {\n\t\tvoid __iomem *chunk;\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res)\n\t\t\tbreak;\n\t\tchunk = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (i == 0)\n\t\t\tbgp->base = chunk;\n\t\tif (IS_ERR(chunk))\n\t\t\treturn ERR_CAST(chunk);\n\n\t\ti++;\n\t} while (res);\n\n\tif (TI_BANDGAP_HAS(bgp, TSHUT)) {\n\t\tbgp->tshut_gpiod = devm_gpiod_get(&pdev->dev, NULL, GPIOD_IN);\n\t\tif (IS_ERR(bgp->tshut_gpiod)) {\n\t\t\tdev_err(&pdev->dev, \"invalid gpio for tshut\\n\");\n\t\t\treturn ERR_CAST(bgp->tshut_gpiod);\n\t\t}\n\t}\n\n\treturn bgp;\n}\n\n \nstatic const struct soc_device_attribute soc_no_cpu_notifier[] = {\n\t{ .machine = \"OMAP4430\" },\n\t{   }\n};\n\n \n\nstatic\nint ti_bandgap_probe(struct platform_device *pdev)\n{\n\tstruct ti_bandgap *bgp;\n\tint clk_rate, ret, i;\n\n\tbgp = ti_bandgap_build(pdev);\n\tif (IS_ERR(bgp)) {\n\t\tdev_err(&pdev->dev, \"failed to fetch platform data\\n\");\n\t\treturn PTR_ERR(bgp);\n\t}\n\tbgp->dev = &pdev->dev;\n\n\tif (TI_BANDGAP_HAS(bgp, UNRELIABLE))\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"This OMAP thermal sensor is unreliable. You've been warned\\n\");\n\n\tif (TI_BANDGAP_HAS(bgp, TSHUT)) {\n\t\tret = ti_bandgap_tshut_init(bgp, pdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to initialize system tshut IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tbgp->fclock = clk_get(NULL, bgp->conf->fclock_name);\n\tif (IS_ERR(bgp->fclock)) {\n\t\tdev_err(&pdev->dev, \"failed to request fclock reference\\n\");\n\t\tret = PTR_ERR(bgp->fclock);\n\t\tgoto free_irqs;\n\t}\n\n\tbgp->div_clk = clk_get(NULL, bgp->conf->div_ck_name);\n\tif (IS_ERR(bgp->div_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to request div_ts_ck clock ref\\n\");\n\t\tret = PTR_ERR(bgp->div_clk);\n\t\tgoto put_fclock;\n\t}\n\n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\tstruct temp_sensor_registers *tsr;\n\t\tu32 val;\n\n\t\ttsr = bgp->conf->sensors[i].registers;\n\t\t \n\t\tval = ti_bandgap_readl(bgp, tsr->bgap_efuse);\n\t\tif (!val)\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Non-trimmed BGAP, Temp not accurate\\n\");\n\t}\n\n\tclk_rate = clk_round_rate(bgp->div_clk,\n\t\t\t\t  bgp->conf->sensors[0].ts_data->max_freq);\n\tif (clk_rate < bgp->conf->sensors[0].ts_data->min_freq ||\n\t    clk_rate <= 0) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev, \"wrong clock rate (%d)\\n\", clk_rate);\n\t\tgoto put_clks;\n\t}\n\n\tret = clk_set_rate(bgp->div_clk, clk_rate);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Cannot re-set clock rate. Continuing\\n\");\n\n\tbgp->clk_rate = clk_rate;\n\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\tclk_prepare_enable(bgp->fclock);\n\n\n\tspin_lock_init(&bgp->lock);\n\tbgp->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, bgp);\n\n\tti_bandgap_power(bgp, true);\n\n\t \n\tif (TI_BANDGAP_HAS(bgp, COUNTER))\n\t\tfor (i = 0; i < bgp->conf->sensor_count; i++)\n\t\t\tRMW_BITS(bgp, i, bgap_counter, counter_mask, 1);\n\n\t \n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\tstruct temp_sensor_data *ts_data;\n\n\t\tts_data = bgp->conf->sensors[i].ts_data;\n\n\t\tif (TI_BANDGAP_HAS(bgp, TALERT)) {\n\t\t\t \n\t\t\tRMW_BITS(bgp, i, bgap_threshold,\n\t\t\t\t threshold_tcold_mask, ts_data->t_cold);\n\t\t\tRMW_BITS(bgp, i, bgap_threshold,\n\t\t\t\t threshold_thot_mask, ts_data->t_hot);\n\t\t\t \n\t\t\tRMW_BITS(bgp, i, bgap_mask_ctrl, mask_hot_mask, 1);\n\t\t\tRMW_BITS(bgp, i, bgap_mask_ctrl, mask_cold_mask, 1);\n\t\t}\n\n\t\tif (TI_BANDGAP_HAS(bgp, TSHUT_CONFIG)) {\n\t\t\t \n\t\t\tRMW_BITS(bgp, i, tshut_threshold,\n\t\t\t\t tshut_hot_mask, ts_data->tshut_hot);\n\t\t\tRMW_BITS(bgp, i, tshut_threshold,\n\t\t\t\t tshut_cold_mask, ts_data->tshut_cold);\n\t\t}\n\t}\n\n\tif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\n\t\tti_bandgap_set_continuous_mode(bgp);\n\n\t \n\tif (TI_BANDGAP_HAS(bgp, COUNTER))\n\t\tfor (i = 0; i < bgp->conf->sensor_count; i++)\n\t\t\tRMW_BITS(bgp, i, bgap_counter, counter_mask,\n\t\t\t\t bgp->clk_rate / 4);\n\n\t \n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\tchar *domain;\n\n\t\tif (bgp->conf->sensors[i].register_cooling) {\n\t\t\tret = bgp->conf->sensors[i].register_cooling(bgp, i);\n\t\t\tif (ret)\n\t\t\t\tgoto remove_sensors;\n\t\t}\n\n\t\tif (bgp->conf->expose_sensor) {\n\t\t\tdomain = bgp->conf->sensors[i].domain;\n\t\t\tret = bgp->conf->expose_sensor(bgp, i, domain);\n\t\t\tif (ret)\n\t\t\t\tgoto remove_last_cooling;\n\t\t}\n\t}\n\n\t \n\tif (TI_BANDGAP_HAS(bgp, TALERT)) {\n\t\tret = ti_bandgap_talert_init(bgp, pdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to initialize Talert IRQ\\n\");\n\t\t\ti = bgp->conf->sensor_count;\n\t\t\tgoto disable_clk;\n\t\t}\n\t}\n\n#ifdef CONFIG_PM_SLEEP\n\tbgp->nb.notifier_call = bandgap_omap_cpu_notifier;\n\tif (!soc_device_match(soc_no_cpu_notifier))\n\t\tcpu_pm_register_notifier(&bgp->nb);\n#endif\n\n\treturn 0;\n\nremove_last_cooling:\n\tif (bgp->conf->sensors[i].unregister_cooling)\n\t\tbgp->conf->sensors[i].unregister_cooling(bgp, i);\nremove_sensors:\n\tfor (i--; i >= 0; i--) {\n\t\tif (bgp->conf->sensors[i].unregister_cooling)\n\t\t\tbgp->conf->sensors[i].unregister_cooling(bgp, i);\n\t\tif (bgp->conf->remove_sensor)\n\t\t\tbgp->conf->remove_sensor(bgp, i);\n\t}\n\tti_bandgap_power(bgp, false);\ndisable_clk:\n\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\tclk_disable_unprepare(bgp->fclock);\nput_clks:\n\tclk_put(bgp->div_clk);\nput_fclock:\n\tclk_put(bgp->fclock);\nfree_irqs:\n\tif (TI_BANDGAP_HAS(bgp, TSHUT))\n\t\tfree_irq(gpiod_to_irq(bgp->tshut_gpiod), NULL);\n\n\treturn ret;\n}\n\nstatic\nint ti_bandgap_remove(struct platform_device *pdev)\n{\n\tstruct ti_bandgap *bgp = platform_get_drvdata(pdev);\n\tint i;\n\n\tif (!soc_device_match(soc_no_cpu_notifier))\n\t\tcpu_pm_unregister_notifier(&bgp->nb);\n\n\t \n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\tif (bgp->conf->sensors[i].unregister_cooling)\n\t\t\tbgp->conf->sensors[i].unregister_cooling(bgp, i);\n\n\t\tif (bgp->conf->remove_sensor)\n\t\t\tbgp->conf->remove_sensor(bgp, i);\n\t}\n\n\tti_bandgap_power(bgp, false);\n\n\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\tclk_disable_unprepare(bgp->fclock);\n\tclk_put(bgp->fclock);\n\tclk_put(bgp->div_clk);\n\n\tif (TI_BANDGAP_HAS(bgp, TALERT))\n\t\tfree_irq(bgp->irq, bgp);\n\n\tif (TI_BANDGAP_HAS(bgp, TSHUT))\n\t\tfree_irq(gpiod_to_irq(bgp->tshut_gpiod), NULL);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ti_bandgap_save_ctxt(struct ti_bandgap *bgp)\n{\n\tint i;\n\n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\tstruct temp_sensor_registers *tsr;\n\t\tstruct temp_sensor_regval *rval;\n\n\t\trval = &bgp->regval[i];\n\t\ttsr = bgp->conf->sensors[i].registers;\n\n\t\tif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\n\t\t\trval->bg_mode_ctrl = ti_bandgap_readl(bgp,\n\t\t\t\t\t\t\ttsr->bgap_mode_ctrl);\n\t\tif (TI_BANDGAP_HAS(bgp, COUNTER))\n\t\t\trval->bg_counter = ti_bandgap_readl(bgp,\n\t\t\t\t\t\t\ttsr->bgap_counter);\n\t\tif (TI_BANDGAP_HAS(bgp, TALERT)) {\n\t\t\trval->bg_threshold = ti_bandgap_readl(bgp,\n\t\t\t\t\t\t\ttsr->bgap_threshold);\n\t\t\trval->bg_ctrl = ti_bandgap_readl(bgp,\n\t\t\t\t\t\t   tsr->bgap_mask_ctrl);\n\t\t}\n\n\t\tif (TI_BANDGAP_HAS(bgp, TSHUT_CONFIG))\n\t\t\trval->tshut_threshold = ti_bandgap_readl(bgp,\n\t\t\t\t\t\t   tsr->tshut_threshold);\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_bandgap_restore_ctxt(struct ti_bandgap *bgp)\n{\n\tint i;\n\n\tfor (i = 0; i < bgp->conf->sensor_count; i++) {\n\t\tstruct temp_sensor_registers *tsr;\n\t\tstruct temp_sensor_regval *rval;\n\n\t\trval = &bgp->regval[i];\n\t\ttsr = bgp->conf->sensors[i].registers;\n\n\t\tif (TI_BANDGAP_HAS(bgp, TSHUT_CONFIG))\n\t\t\tti_bandgap_writel(bgp, rval->tshut_threshold,\n\t\t\t\t\t  tsr->tshut_threshold);\n\t\t \n\t\tti_bandgap_force_single_read(bgp, i);\n\n\t\tif (TI_BANDGAP_HAS(bgp, COUNTER))\n\t\t\tti_bandgap_writel(bgp, rval->bg_counter,\n\t\t\t\t\t  tsr->bgap_counter);\n\t\tif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\n\t\t\tti_bandgap_writel(bgp, rval->bg_mode_ctrl,\n\t\t\t\t\t  tsr->bgap_mode_ctrl);\n\t\tif (TI_BANDGAP_HAS(bgp, TALERT)) {\n\t\t\tti_bandgap_writel(bgp, rval->bg_threshold,\n\t\t\t\t\t  tsr->bgap_threshold);\n\t\t\tti_bandgap_writel(bgp, rval->bg_ctrl,\n\t\t\t\t\t  tsr->bgap_mask_ctrl);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_bandgap_suspend(struct device *dev)\n{\n\tstruct ti_bandgap *bgp = dev_get_drvdata(dev);\n\tint err;\n\n\terr = ti_bandgap_save_ctxt(bgp);\n\tti_bandgap_power(bgp, false);\n\n\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\tclk_disable_unprepare(bgp->fclock);\n\n\tbgp->is_suspended = true;\n\n\treturn err;\n}\n\nstatic int bandgap_omap_cpu_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long cmd, void *v)\n{\n\tstruct ti_bandgap *bgp;\n\n\tbgp = container_of(nb, struct ti_bandgap, nb);\n\n\tspin_lock(&bgp->lock);\n\tswitch (cmd) {\n\tcase CPU_CLUSTER_PM_ENTER:\n\t\tif (bgp->is_suspended)\n\t\t\tbreak;\n\t\tti_bandgap_save_ctxt(bgp);\n\t\tti_bandgap_power(bgp, false);\n\t\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\t\tclk_disable(bgp->fclock);\n\t\tbreak;\n\tcase CPU_CLUSTER_PM_ENTER_FAILED:\n\tcase CPU_CLUSTER_PM_EXIT:\n\t\tif (bgp->is_suspended)\n\t\t\tbreak;\n\t\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\t\tclk_enable(bgp->fclock);\n\t\tti_bandgap_power(bgp, true);\n\t\tti_bandgap_restore_ctxt(bgp);\n\t\tbreak;\n\t}\n\tspin_unlock(&bgp->lock);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int ti_bandgap_resume(struct device *dev)\n{\n\tstruct ti_bandgap *bgp = dev_get_drvdata(dev);\n\n\tif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\n\t\tclk_prepare_enable(bgp->fclock);\n\n\tti_bandgap_power(bgp, true);\n\tbgp->is_suspended = false;\n\n\treturn ti_bandgap_restore_ctxt(bgp);\n}\nstatic SIMPLE_DEV_PM_OPS(ti_bandgap_dev_pm_ops, ti_bandgap_suspend,\n\t\t\t ti_bandgap_resume);\n\n#define DEV_PM_OPS\t(&ti_bandgap_dev_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif\n\nstatic const struct of_device_id of_ti_bandgap_match[] = {\n#ifdef CONFIG_OMAP3_THERMAL\n\t{\n\t\t.compatible = \"ti,omap34xx-bandgap\",\n\t\t.data = (void *)&omap34xx_data,\n\t},\n\t{\n\t\t.compatible = \"ti,omap36xx-bandgap\",\n\t\t.data = (void *)&omap36xx_data,\n\t},\n#endif\n#ifdef CONFIG_OMAP4_THERMAL\n\t{\n\t\t.compatible = \"ti,omap4430-bandgap\",\n\t\t.data = (void *)&omap4430_data,\n\t},\n\t{\n\t\t.compatible = \"ti,omap4460-bandgap\",\n\t\t.data = (void *)&omap4460_data,\n\t},\n\t{\n\t\t.compatible = \"ti,omap4470-bandgap\",\n\t\t.data = (void *)&omap4470_data,\n\t},\n#endif\n#ifdef CONFIG_OMAP5_THERMAL\n\t{\n\t\t.compatible = \"ti,omap5430-bandgap\",\n\t\t.data = (void *)&omap5430_data,\n\t},\n#endif\n#ifdef CONFIG_DRA752_THERMAL\n\t{\n\t\t.compatible = \"ti,dra752-bandgap\",\n\t\t.data = (void *)&dra752_data,\n\t},\n#endif\n\t \n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_ti_bandgap_match);\n\nstatic struct platform_driver ti_bandgap_sensor_driver = {\n\t.probe = ti_bandgap_probe,\n\t.remove = ti_bandgap_remove,\n\t.driver = {\n\t\t\t.name = \"ti-soc-thermal\",\n\t\t\t.pm = DEV_PM_OPS,\n\t\t\t.of_match_table\t= of_ti_bandgap_match,\n\t},\n};\n\nmodule_platform_driver(ti_bandgap_sensor_driver);\n\nMODULE_DESCRIPTION(\"OMAP4+ bandgap temperature sensor driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:ti-soc-thermal\");\nMODULE_AUTHOR(\"Texas Instrument Inc.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}