{
  "module_name": "intel_quark_dts_thermal.c",
  "hash_id": "9cfd2c9b807f4049cc19780d710114132625f45378e233836fc7a62b1fdbfe30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/intel_quark_dts_thermal.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/thermal.h>\n#include <asm/cpu_device_id.h>\n#include <asm/iosf_mbi.h>\n\n \n#define QRK_DTS_REG_OFFSET_RESET\t0x34\n#define QRK_DTS_RESET_BIT\t\tBIT(0)\n\n \n#define QRK_DTS_REG_OFFSET_ENABLE\t0xB0\n#define QRK_DTS_ENABLE_BIT\t\tBIT(15)\n\n \n#define QRK_DTS_REG_OFFSET_TEMP\t\t0xB1\n#define QRK_DTS_MASK_TEMP\t\t0xFF\n#define QRK_DTS_OFFSET_TEMP\t\t0\n#define QRK_DTS_OFFSET_REL_TEMP\t\t16\n#define QRK_DTS_TEMP_BASE\t\t50\n\n \n#define QRK_DTS_REG_OFFSET_PTPS\t\t0xB2\n#define QRK_DTS_MASK_TP_THRES\t\t0xFF\n#define QRK_DTS_SHIFT_TP\t\t8\n#define QRK_DTS_ID_TP_CRITICAL\t\t0\n#define QRK_DTS_ID_TP_HOT\t\t1\n#define QRK_DTS_SAFE_TP_THRES\t\t105\n\n \n#define QRK_DTS_REG_OFFSET_LOCK\t\t0x71\n#define QRK_DTS_LOCK_BIT\t\tBIT(5)\n\n \n#define QRK_MAX_DTS_TRIPS\t2\n \n#define QRK_DTS_WR_MASK_SET\t0x3\n \n#define QRK_DTS_WR_MASK_CLR\t0\n\n#define DEFAULT_POLL_DELAY\t2000\n\nstruct soc_sensor_entry {\n\tbool locked;\n\tu32 store_ptps;\n\tu32 store_dts_enable;\n\tstruct thermal_zone_device *tzone;\n\tstruct thermal_trip trips[QRK_MAX_DTS_TRIPS];\n};\n\nstatic struct soc_sensor_entry *soc_dts;\n\nstatic int polling_delay = DEFAULT_POLL_DELAY;\nmodule_param(polling_delay, int, 0644);\nMODULE_PARM_DESC(polling_delay,\n\t\"Polling interval for checking trip points (in milliseconds)\");\n\nstatic DEFINE_MUTEX(dts_update_mutex);\n\nstatic int soc_dts_enable(struct thermal_zone_device *tzd)\n{\n\tu32 out;\n\tstruct soc_sensor_entry *aux_entry = thermal_zone_device_priv(tzd);\n\tint ret;\n\n\tret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t    QRK_DTS_REG_OFFSET_ENABLE, &out);\n\tif (ret)\n\t\treturn ret;\n\n\tif (out & QRK_DTS_ENABLE_BIT)\n\t\treturn 0;\n\n\tif (!aux_entry->locked) {\n\t\tout |= QRK_DTS_ENABLE_BIT;\n\t\tret = iosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\n\t\t\t\t     QRK_DTS_REG_OFFSET_ENABLE, out);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tpr_info(\"DTS is locked. Cannot enable DTS\\n\");\n\t\tret = -EPERM;\n\t}\n\n\treturn ret;\n}\n\nstatic int soc_dts_disable(struct thermal_zone_device *tzd)\n{\n\tu32 out;\n\tstruct soc_sensor_entry *aux_entry = thermal_zone_device_priv(tzd);\n\tint ret;\n\n\tret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t    QRK_DTS_REG_OFFSET_ENABLE, &out);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(out & QRK_DTS_ENABLE_BIT))\n\t\treturn 0;\n\n\tif (!aux_entry->locked) {\n\t\tout &= ~QRK_DTS_ENABLE_BIT;\n\t\tret = iosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\n\t\t\t\t     QRK_DTS_REG_OFFSET_ENABLE, out);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tpr_info(\"DTS is locked. Cannot disable DTS\\n\");\n\t\tret = -EPERM;\n\t}\n\n\treturn ret;\n}\n\nstatic int get_trip_temp(int trip)\n{\n\tint status, temp;\n\tu32 out;\n\n\tmutex_lock(&dts_update_mutex);\n\tstatus = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t       QRK_DTS_REG_OFFSET_PTPS, &out);\n\tmutex_unlock(&dts_update_mutex);\n\n\tif (status)\n\t\treturn THERMAL_TEMP_INVALID;\n\n\t \n\ttemp = (out >> (trip * QRK_DTS_SHIFT_TP)) & QRK_DTS_MASK_TP_THRES;\n\ttemp -= QRK_DTS_TEMP_BASE;\n\n\treturn temp;\n}\n\nstatic int update_trip_temp(struct soc_sensor_entry *aux_entry,\n\t\t\t\tint trip, int temp)\n{\n\tu32 out;\n\tu32 temp_out;\n\tu32 store_ptps;\n\tint ret;\n\n\tmutex_lock(&dts_update_mutex);\n\tif (aux_entry->locked) {\n\t\tret = -EPERM;\n\t\tgoto failed;\n\t}\n\n\tret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t    QRK_DTS_REG_OFFSET_PTPS, &store_ptps);\n\tif (ret)\n\t\tgoto failed;\n\n\t \n\tif (temp > QRK_DTS_SAFE_TP_THRES)\n\t\ttemp = QRK_DTS_SAFE_TP_THRES;\n\n\t \n\ttemp_out = temp + QRK_DTS_TEMP_BASE;\n\tout = (store_ptps & ~(QRK_DTS_MASK_TP_THRES <<\n\t\t(trip * QRK_DTS_SHIFT_TP)));\n\tout |= (temp_out & QRK_DTS_MASK_TP_THRES) <<\n\t\t(trip * QRK_DTS_SHIFT_TP);\n\n\tret = iosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\n\t\t\t     QRK_DTS_REG_OFFSET_PTPS, out);\n\nfailed:\n\tmutex_unlock(&dts_update_mutex);\n\treturn ret;\n}\n\nstatic inline int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip,\n\t\t\t\tint temp)\n{\n\treturn update_trip_temp(thermal_zone_device_priv(tzd), trip, temp);\n}\n\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd,\n\t\t\t\tint *temp)\n{\n\tu32 out;\n\tint ret;\n\n\tmutex_lock(&dts_update_mutex);\n\tret = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t    QRK_DTS_REG_OFFSET_TEMP, &out);\n\tmutex_unlock(&dts_update_mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tout = (out >> QRK_DTS_OFFSET_TEMP) & QRK_DTS_MASK_TEMP;\n\t*temp = out - QRK_DTS_TEMP_BASE;\n\n\treturn 0;\n}\n\nstatic int sys_change_mode(struct thermal_zone_device *tzd,\n\t\t\t   enum thermal_device_mode mode)\n{\n\tint ret;\n\n\tmutex_lock(&dts_update_mutex);\n\tif (mode == THERMAL_DEVICE_ENABLED)\n\t\tret = soc_dts_enable(tzd);\n\telse\n\t\tret = soc_dts_disable(tzd);\n\tmutex_unlock(&dts_update_mutex);\n\n\treturn ret;\n}\n\nstatic struct thermal_zone_device_ops tzone_ops = {\n\t.get_temp = sys_get_curr_temp,\n\t.set_trip_temp = sys_set_trip_temp,\n\t.change_mode = sys_change_mode,\n};\n\nstatic void free_soc_dts(struct soc_sensor_entry *aux_entry)\n{\n\tif (aux_entry) {\n\t\tif (!aux_entry->locked) {\n\t\t\tmutex_lock(&dts_update_mutex);\n\t\t\tiosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\n\t\t\t\t       QRK_DTS_REG_OFFSET_ENABLE,\n\t\t\t\t       aux_entry->store_dts_enable);\n\n\t\t\tiosf_mbi_write(QRK_MBI_UNIT_RMU, MBI_REG_WRITE,\n\t\t\t\t       QRK_DTS_REG_OFFSET_PTPS,\n\t\t\t\t       aux_entry->store_ptps);\n\t\t\tmutex_unlock(&dts_update_mutex);\n\t\t}\n\t\tthermal_zone_device_unregister(aux_entry->tzone);\n\t\tkfree(aux_entry);\n\t}\n}\n\nstatic struct soc_sensor_entry *alloc_soc_dts(void)\n{\n\tstruct soc_sensor_entry *aux_entry;\n\tint err;\n\tu32 out;\n\tint wr_mask;\n\n\taux_entry = kzalloc(sizeof(*aux_entry), GFP_KERNEL);\n\tif (!aux_entry) {\n\t\terr = -ENOMEM;\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\terr = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t    QRK_DTS_REG_OFFSET_LOCK, &out);\n\tif (err)\n\t\tgoto err_ret;\n\n\tif (out & QRK_DTS_LOCK_BIT) {\n\t\taux_entry->locked = true;\n\t\twr_mask = QRK_DTS_WR_MASK_CLR;\n\t} else {\n\t\taux_entry->locked = false;\n\t\twr_mask = QRK_DTS_WR_MASK_SET;\n\t}\n\n\t \n\tif (!aux_entry->locked) {\n\t\t \n\t\terr = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t\t    QRK_DTS_REG_OFFSET_ENABLE,\n\t\t\t\t    &aux_entry->store_dts_enable);\n\t\tif (err)\n\t\t\tgoto err_ret;\n\n\t\t \n\t\terr = iosf_mbi_read(QRK_MBI_UNIT_RMU, MBI_REG_READ,\n\t\t\t\t    QRK_DTS_REG_OFFSET_PTPS,\n\t\t\t\t    &aux_entry->store_ptps);\n\t\tif (err)\n\t\t\tgoto err_ret;\n\t}\n\n\taux_entry->trips[QRK_DTS_ID_TP_CRITICAL].temperature = get_trip_temp(QRK_DTS_ID_TP_CRITICAL);\n\taux_entry->trips[QRK_DTS_ID_TP_CRITICAL].type = THERMAL_TRIP_CRITICAL;\n\n\taux_entry->trips[QRK_DTS_ID_TP_HOT].temperature = get_trip_temp(QRK_DTS_ID_TP_HOT);\n\taux_entry->trips[QRK_DTS_ID_TP_HOT].type = THERMAL_TRIP_HOT;\n\n\taux_entry->tzone = thermal_zone_device_register_with_trips(\"quark_dts\",\n\t\t\t\t\t\t\t\t   aux_entry->trips,\n\t\t\t\t\t\t\t\t   QRK_MAX_DTS_TRIPS,\n\t\t\t\t\t\t\t\t   wr_mask,\n\t\t\t\t\t\t\t\t   aux_entry, &tzone_ops,\n\t\t\t\t\t\t\t\t   NULL, 0, polling_delay);\n\tif (IS_ERR(aux_entry->tzone)) {\n\t\terr = PTR_ERR(aux_entry->tzone);\n\t\tgoto err_ret;\n\t}\n\n\terr = thermal_zone_device_enable(aux_entry->tzone);\n\tif (err)\n\t\tgoto err_aux_status;\n\n\treturn aux_entry;\n\nerr_aux_status:\n\tthermal_zone_device_unregister(aux_entry->tzone);\nerr_ret:\n\tkfree(aux_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic const struct x86_cpu_id qrk_thermal_ids[] __initconst  = {\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL, 5, INTEL_FAM5_QUARK_X1000, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, qrk_thermal_ids);\n\nstatic int __init intel_quark_thermal_init(void)\n{\n\tif (!x86_match_cpu(qrk_thermal_ids) || !iosf_mbi_available())\n\t\treturn -ENODEV;\n\n\tsoc_dts = alloc_soc_dts();\n\tif (IS_ERR(soc_dts))\n\t\treturn PTR_ERR(soc_dts);\n\n\treturn 0;\n}\n\nstatic void __exit intel_quark_thermal_exit(void)\n{\n\tfree_soc_dts(soc_dts);\n}\n\nmodule_init(intel_quark_thermal_init)\nmodule_exit(intel_quark_thermal_exit)\n\nMODULE_DESCRIPTION(\"Intel Quark DTS Thermal Driver\");\nMODULE_AUTHOR(\"Ong Boon Leong <boon.leong.ong@intel.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}