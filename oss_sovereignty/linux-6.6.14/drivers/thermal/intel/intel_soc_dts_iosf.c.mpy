{
  "module_name": "intel_soc_dts_iosf.c",
  "hash_id": "d2aca92d31ee220d49c82bc4c6f8597f2d1a28c15e962db0245932ceefc893a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/intel_soc_dts_iosf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/intel_tcc.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <asm/iosf_mbi.h>\n#include \"intel_soc_dts_iosf.h\"\n\n#define SOC_DTS_OFFSET_ENABLE\t\t0xB0\n#define SOC_DTS_OFFSET_TEMP\t\t0xB1\n\n#define SOC_DTS_OFFSET_PTPS\t\t0xB2\n#define SOC_DTS_OFFSET_PTTS\t\t0xB3\n#define SOC_DTS_OFFSET_PTTSS\t\t0xB4\n#define SOC_DTS_OFFSET_PTMC\t\t0x80\n#define SOC_DTS_TE_AUX0\t\t\t0xB5\n#define SOC_DTS_TE_AUX1\t\t\t0xB6\n\n#define SOC_DTS_AUX0_ENABLE_BIT\t\tBIT(0)\n#define SOC_DTS_AUX1_ENABLE_BIT\t\tBIT(1)\n#define SOC_DTS_CPU_MODULE0_ENABLE_BIT\tBIT(16)\n#define SOC_DTS_CPU_MODULE1_ENABLE_BIT\tBIT(17)\n#define SOC_DTS_TE_SCI_ENABLE\t\tBIT(9)\n#define SOC_DTS_TE_SMI_ENABLE\t\tBIT(10)\n#define SOC_DTS_TE_MSI_ENABLE\t\tBIT(11)\n#define SOC_DTS_TE_APICA_ENABLE\t\tBIT(14)\n#define SOC_DTS_PTMC_APIC_DEASSERT_BIT\tBIT(4)\n\n \n#define SOC_DTS_TJMAX_ENCODING\t\t0x7F\n\n \n#define SOC_DTS_TRIP_MASK\t\t0x03\n\nstatic int update_trip_temp(struct intel_soc_dts_sensors *sensors,\n\t\t\t    int thres_index, int temp)\n{\n\tint status;\n\tu32 temp_out;\n\tu32 out;\n\tunsigned long update_ptps;\n\tu32 store_ptps;\n\tu32 store_ptmc;\n\tu32 store_te_out;\n\tu32 te_out;\n\tu32 int_enable_bit = SOC_DTS_TE_APICA_ENABLE;\n\n\tif (sensors->intr_type == INTEL_SOC_DTS_INTERRUPT_MSI)\n\t\tint_enable_bit |= SOC_DTS_TE_MSI_ENABLE;\n\n\ttemp_out = (sensors->tj_max - temp) / 1000;\n\n\tstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t       SOC_DTS_OFFSET_PTPS, &store_ptps);\n\tif (status)\n\t\treturn status;\n\n\tupdate_ptps = store_ptps;\n\tbitmap_set_value8(&update_ptps, temp_out & 0xFF, thres_index * 8);\n\tout = update_ptps;\n\n\tstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t\tSOC_DTS_OFFSET_PTPS, out);\n\tif (status)\n\t\treturn status;\n\n\tpr_debug(\"update_trip_temp PTPS = %x\\n\", out);\n\tstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t       SOC_DTS_OFFSET_PTMC, &out);\n\tif (status)\n\t\tgoto err_restore_ptps;\n\n\tstore_ptmc = out;\n\n\tstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t       SOC_DTS_TE_AUX0 + thres_index,\n\t\t\t       &te_out);\n\tif (status)\n\t\tgoto err_restore_ptmc;\n\n\tstore_te_out = te_out;\n\t \n\tout |= (SOC_DTS_CPU_MODULE0_ENABLE_BIT |\n\t\t\t\t\tSOC_DTS_CPU_MODULE1_ENABLE_BIT);\n\tif (temp) {\n\t\tif (thres_index)\n\t\t\tout |= SOC_DTS_AUX1_ENABLE_BIT;\n\t\telse\n\t\t\tout |= SOC_DTS_AUX0_ENABLE_BIT;\n\t\tte_out |= int_enable_bit;\n\t} else {\n\t\tif (thres_index)\n\t\t\tout &= ~SOC_DTS_AUX1_ENABLE_BIT;\n\t\telse\n\t\t\tout &= ~SOC_DTS_AUX0_ENABLE_BIT;\n\t\tte_out &= ~int_enable_bit;\n\t}\n\tstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t\tSOC_DTS_OFFSET_PTMC, out);\n\tif (status)\n\t\tgoto err_restore_te_out;\n\n\tstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t\tSOC_DTS_TE_AUX0 + thres_index,\n\t\t\t\tte_out);\n\tif (status)\n\t\tgoto err_restore_te_out;\n\n\treturn 0;\nerr_restore_te_out:\n\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t       SOC_DTS_OFFSET_PTMC, store_te_out);\nerr_restore_ptmc:\n\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t       SOC_DTS_OFFSET_PTMC, store_ptmc);\nerr_restore_ptps:\n\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t       SOC_DTS_OFFSET_PTPS, store_ptps);\n\t \n\n\treturn status;\n}\n\nstatic int configure_trip(struct intel_soc_dts_sensor_entry *dts,\n\t\t\t  int thres_index, enum thermal_trip_type trip_type,\n\t\t\t  int temp)\n{\n\tint ret;\n\n\tret = update_trip_temp(dts->sensors, thres_index, temp);\n\tif (ret)\n\t\treturn ret;\n\n\tdts->trips[thres_index].temperature = temp;\n\tdts->trips[thres_index].type = trip_type;\n\n\treturn 0;\n}\n\nstatic int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip,\n\t\t\t     int temp)\n{\n\tstruct intel_soc_dts_sensor_entry *dts = thermal_zone_device_priv(tzd);\n\tstruct intel_soc_dts_sensors *sensors = dts->sensors;\n\tint status;\n\n\tif (temp > sensors->tj_max)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sensors->dts_update_lock);\n\tstatus = update_trip_temp(sensors, trip, temp);\n\tmutex_unlock(&sensors->dts_update_lock);\n\n\treturn status;\n}\n\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd,\n\t\t\t     int *temp)\n{\n\tint status;\n\tu32 out;\n\tstruct intel_soc_dts_sensor_entry *dts = thermal_zone_device_priv(tzd);\n\tstruct intel_soc_dts_sensors *sensors;\n\tunsigned long raw;\n\n\tsensors = dts->sensors;\n\tstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t       SOC_DTS_OFFSET_TEMP, &out);\n\tif (status)\n\t\treturn status;\n\n\traw = out;\n\tout = bitmap_get_value8(&raw, dts->id * 8) - SOC_DTS_TJMAX_ENCODING;\n\t*temp = sensors->tj_max - out * 1000;\n\n\treturn 0;\n}\n\nstatic struct thermal_zone_device_ops tzone_ops = {\n\t.get_temp = sys_get_curr_temp,\n\t.set_trip_temp = sys_set_trip_temp,\n};\n\nstatic int soc_dts_enable(int id)\n{\n\tu32 out;\n\tint ret;\n\n\tret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t    SOC_DTS_OFFSET_ENABLE, &out);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(out & BIT(id))) {\n\t\tout |= BIT(id);\n\t\tret = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t\t     SOC_DTS_OFFSET_ENABLE, out);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void remove_dts_thermal_zone(struct intel_soc_dts_sensor_entry *dts)\n{\n\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t       SOC_DTS_OFFSET_ENABLE, dts->store_status);\n\tthermal_zone_device_unregister(dts->tzone);\n}\n\nstatic int add_dts_thermal_zone(int id, struct intel_soc_dts_sensor_entry *dts,\n\t\t\t\tbool critical_trip)\n{\n\tint writable_trip_cnt = SOC_MAX_DTS_TRIPS;\n\tchar name[10];\n\tunsigned long trip;\n\tint trip_mask;\n\tunsigned long ptps;\n\tu32 store_ptps;\n\tunsigned long i;\n\tint ret;\n\n\t \n\tret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t    SOC_DTS_OFFSET_ENABLE, &dts->store_status);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tdts->id = id;\n\n\tif (critical_trip)\n\t\twritable_trip_cnt--;\n\n\ttrip_mask = GENMASK(writable_trip_cnt - 1, 0);\n\n\t \n\tret = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t    SOC_DTS_OFFSET_PTPS, &store_ptps);\n\tif (ret)\n\t\ttrip_mask = 0;\n\telse {\n\t\tptps = store_ptps;\n\t\tfor_each_set_clump8(i, trip, &ptps, writable_trip_cnt * 8)\n\t\t\ttrip_mask &= ~BIT(i / 8);\n\t}\n\tdts->trip_mask = trip_mask;\n\tsnprintf(name, sizeof(name), \"soc_dts%d\", id);\n\tdts->tzone = thermal_zone_device_register_with_trips(name, dts->trips,\n\t\t\t\t\t\t\t     SOC_MAX_DTS_TRIPS,\n\t\t\t\t\t\t\t     trip_mask,\n\t\t\t\t\t\t\t     dts, &tzone_ops,\n\t\t\t\t\t\t\t     NULL, 0, 0);\n\tif (IS_ERR(dts->tzone)) {\n\t\tret = PTR_ERR(dts->tzone);\n\t\tgoto err_ret;\n\t}\n\tret = thermal_zone_device_enable(dts->tzone);\n\tif (ret)\n\t\tgoto err_enable;\n\n\tret = soc_dts_enable(id);\n\tif (ret)\n\t\tgoto err_enable;\n\n\treturn 0;\nerr_enable:\n\tthermal_zone_device_unregister(dts->tzone);\nerr_ret:\n\treturn ret;\n}\n\nvoid intel_soc_dts_iosf_interrupt_handler(struct intel_soc_dts_sensors *sensors)\n{\n\tu32 sticky_out;\n\tint status;\n\tu32 ptmc_out;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sensors->intr_notify_lock, flags);\n\n\tstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t       SOC_DTS_OFFSET_PTMC, &ptmc_out);\n\tptmc_out |= SOC_DTS_PTMC_APIC_DEASSERT_BIT;\n\tstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t\tSOC_DTS_OFFSET_PTMC, ptmc_out);\n\n\tstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ,\n\t\t\t       SOC_DTS_OFFSET_PTTSS, &sticky_out);\n\tpr_debug(\"status %d PTTSS %x\\n\", status, sticky_out);\n\tif (sticky_out & SOC_DTS_TRIP_MASK) {\n\t\tint i;\n\t\t \n\t\tstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, MBI_REG_WRITE,\n\t\t\t\t\tSOC_DTS_OFFSET_PTTSS, sticky_out);\n\t\tspin_unlock_irqrestore(&sensors->intr_notify_lock, flags);\n\n\t\tfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\n\t\t\tpr_debug(\"TZD update for zone %d\\n\", i);\n\t\t\tthermal_zone_device_update(sensors->soc_dts[i].tzone,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t\t}\n\t} else\n\t\tspin_unlock_irqrestore(&sensors->intr_notify_lock, flags);\n}\nEXPORT_SYMBOL_GPL(intel_soc_dts_iosf_interrupt_handler);\n\nstatic void dts_trips_reset(struct intel_soc_dts_sensors *sensors, int dts_index)\n{\n\tconfigure_trip(&sensors->soc_dts[dts_index], 0, 0, 0);\n\tconfigure_trip(&sensors->soc_dts[dts_index], 1, 0, 0);\n}\n\nstruct intel_soc_dts_sensors *\nintel_soc_dts_iosf_init(enum intel_soc_dts_interrupt_type intr_type,\n\t\t\tbool critical_trip, int crit_offset)\n{\n\tstruct intel_soc_dts_sensors *sensors;\n\tint tj_max;\n\tint ret;\n\tint i;\n\n\tif (!iosf_mbi_available())\n\t\treturn ERR_PTR(-ENODEV);\n\n\ttj_max = intel_tcc_get_tjmax(-1);\n\tif (tj_max < 0)\n\t\treturn ERR_PTR(tj_max);\n\n\tsensors = kzalloc(sizeof(*sensors), GFP_KERNEL);\n\tif (!sensors)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&sensors->intr_notify_lock);\n\tmutex_init(&sensors->dts_update_lock);\n\tsensors->intr_type = intr_type;\n\tsensors->tj_max = tj_max * 1000;\n\n\tfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\n\t\tenum thermal_trip_type trip_type;\n\t\tint temp;\n\n\t\tsensors->soc_dts[i].sensors = sensors;\n\n\t\tret = configure_trip(&sensors->soc_dts[i], 0,\n\t\t\t\t     THERMAL_TRIP_PASSIVE, 0);\n\t\tif (ret)\n\t\t\tgoto err_reset_trips;\n\n\t\tif (critical_trip) {\n\t\t\ttrip_type = THERMAL_TRIP_CRITICAL;\n\t\t\ttemp = sensors->tj_max - crit_offset;\n\t\t} else {\n\t\t\ttrip_type = THERMAL_TRIP_PASSIVE;\n\t\t\ttemp = 0;\n\t\t}\n\t\tret = configure_trip(&sensors->soc_dts[i], 1, trip_type, temp);\n\t\tif (ret)\n\t\t\tgoto err_reset_trips;\n\t}\n\n\tfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\n\t\tret = add_dts_thermal_zone(i, &sensors->soc_dts[i], critical_trip);\n\t\tif (ret)\n\t\t\tgoto err_remove_zone;\n\t}\n\n\treturn sensors;\n\nerr_remove_zone:\n\tfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i)\n\t\tremove_dts_thermal_zone(&sensors->soc_dts[i]);\n\nerr_reset_trips:\n\tfor (i = 0; i < SOC_MAX_DTS_SENSORS; i++)\n\t\tdts_trips_reset(sensors, i);\n\n\tkfree(sensors);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(intel_soc_dts_iosf_init);\n\nvoid intel_soc_dts_iosf_exit(struct intel_soc_dts_sensors *sensors)\n{\n\tint i;\n\n\tfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\n\t\tremove_dts_thermal_zone(&sensors->soc_dts[i]);\n\t\tdts_trips_reset(sensors, i);\n\t}\n\tkfree(sensors);\n}\nEXPORT_SYMBOL_GPL(intel_soc_dts_iosf_exit);\n\nMODULE_IMPORT_NS(INTEL_TCC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}