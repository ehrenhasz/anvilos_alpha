{
  "module_name": "intel_soc_dts_thermal.c",
  "hash_id": "0ac0d4ec0e759ef47955766936a044f96164064bb4f2d611058e1185cc1749d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/intel_soc_dts_thermal.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include \"intel_soc_dts_iosf.h\"\n\n#define CRITICAL_OFFSET_FROM_TJ_MAX\t5000\n\nstatic int crit_offset = CRITICAL_OFFSET_FROM_TJ_MAX;\nmodule_param(crit_offset, int, 0644);\nMODULE_PARM_DESC(crit_offset,\n\t\"Critical Temperature offset from tj max in millidegree Celsius.\");\n\n \n#define BYT_SOC_DTS_APIC_IRQ\t86\n\nstatic int soc_dts_thres_gsi;\nstatic int soc_dts_thres_irq;\nstatic struct intel_soc_dts_sensors *soc_dts;\n\nstatic irqreturn_t soc_irq_thread_fn(int irq, void *dev_data)\n{\n\tpr_debug(\"proc_thermal_interrupt\\n\");\n\tintel_soc_dts_iosf_interrupt_handler(soc_dts);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct x86_cpu_id soc_thermal_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT, BYT_SOC_DTS_APIC_IRQ),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, soc_thermal_ids);\n\nstatic int __init intel_soc_thermal_init(void)\n{\n\tint err = 0;\n\tconst struct x86_cpu_id *match_cpu;\n\n\tmatch_cpu = x86_match_cpu(soc_thermal_ids);\n\tif (!match_cpu)\n\t\treturn -ENODEV;\n\n\t \n\tsoc_dts = intel_soc_dts_iosf_init(INTEL_SOC_DTS_INTERRUPT_APIC, true,\n\t\t\t\t\t  crit_offset);\n\tif (IS_ERR(soc_dts)) {\n\t\terr = PTR_ERR(soc_dts);\n\t\treturn err;\n\t}\n\n\tsoc_dts_thres_gsi = (int)match_cpu->driver_data;\n\tif (soc_dts_thres_gsi) {\n\t\t \n\t\tsoc_dts_thres_irq = acpi_register_gsi(NULL, soc_dts_thres_gsi,\n\t\t\t\t\t\t      ACPI_LEVEL_SENSITIVE,\n\t\t\t\t\t\t      ACPI_ACTIVE_LOW);\n\t\tif (soc_dts_thres_irq < 0) {\n\t\t\tpr_warn(\"intel_soc_dts: Could not get IRQ for GSI %d, err %d\\n\",\n\t\t\t\tsoc_dts_thres_gsi, soc_dts_thres_irq);\n\t\t\tsoc_dts_thres_irq = 0;\n\t\t}\n\t}\n\n\tif (soc_dts_thres_irq) {\n\t\terr = request_threaded_irq(soc_dts_thres_irq, NULL,\n\t\t\t\t\t   soc_irq_thread_fn,\n\t\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t   \"soc_dts\", soc_dts);\n\t\tif (err) {\n\t\t\t \n\t\t\tpr_warn(\"request_threaded_irq ret %d\\n\", err);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit intel_soc_thermal_exit(void)\n{\n\tif (soc_dts_thres_irq) {\n\t\tfree_irq(soc_dts_thres_irq, soc_dts);\n\t\tacpi_unregister_gsi(soc_dts_thres_gsi);\n\t}\n\tintel_soc_dts_iosf_exit(soc_dts);\n}\n\nmodule_init(intel_soc_thermal_init)\nmodule_exit(intel_soc_thermal_exit)\n\nMODULE_DESCRIPTION(\"Intel SoC DTS Thermal Driver\");\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}