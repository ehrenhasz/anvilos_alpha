{
  "module_name": "therm_throt.c",
  "hash_id": "b11417618900e3c3f8a3d632e442bc955ed6394433a14283021ada814e21b6ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/therm_throt.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n\n#include <asm/processor.h>\n#include <asm/thermal.h>\n#include <asm/traps.h>\n#include <asm/apic.h>\n#include <asm/irq.h>\n#include <asm/msr.h>\n\n#include \"intel_hfi.h\"\n#include \"thermal_interrupt.h\"\n\n \n#define CHECK_INTERVAL\t\t(300 * HZ)\n\n#define THERMAL_THROTTLING_EVENT\t0\n#define POWER_LIMIT_EVENT\t\t1\n\n \nstruct _thermal_state {\n\tu64\t\t\tnext_check;\n\tu64\t\t\tlast_interrupt_time;\n\tstruct delayed_work\ttherm_work;\n\tunsigned long\t\tcount;\n\tunsigned long\t\tlast_count;\n\tunsigned long\t\tmax_time_ms;\n\tunsigned long\t\ttotal_time_ms;\n\tbool\t\t\trate_control_active;\n\tbool\t\t\tnew_event;\n\tu8\t\t\tlevel;\n\tu8\t\t\tsample_index;\n\tu8\t\t\tsample_count;\n\tu8\t\t\taverage;\n\tu8\t\t\tbaseline_temp;\n\tu8\t\t\ttemp_samples[3];\n};\n\nstruct thermal_state {\n\tstruct _thermal_state core_throttle;\n\tstruct _thermal_state core_power_limit;\n\tstruct _thermal_state package_throttle;\n\tstruct _thermal_state package_power_limit;\n\tstruct _thermal_state core_thresh0;\n\tstruct _thermal_state core_thresh1;\n\tstruct _thermal_state pkg_thresh0;\n\tstruct _thermal_state pkg_thresh1;\n};\n\n \nint (*platform_thermal_notify)(__u64 msr_val);\nEXPORT_SYMBOL(platform_thermal_notify);\n\n \nint (*platform_thermal_package_notify)(__u64 msr_val);\nEXPORT_SYMBOL_GPL(platform_thermal_package_notify);\n\n \nbool (*platform_thermal_package_rate_control)(void);\nEXPORT_SYMBOL_GPL(platform_thermal_package_rate_control);\n\n\nstatic DEFINE_PER_CPU(struct thermal_state, thermal_state);\n\nstatic atomic_t therm_throt_en\t= ATOMIC_INIT(0);\n\nstatic u32 lvtthmr_init __read_mostly;\n\n#ifdef CONFIG_SYSFS\n#define define_therm_throt_device_one_ro(_name)\t\t\t\t\\\n\tstatic DEVICE_ATTR(_name, 0444,\t\t\t\t\t\\\n\t\t\t   therm_throt_device_show_##_name,\t\t\\\n\t\t\t\t   NULL)\t\t\t\t\\\n\n#define define_therm_throt_device_show_func(event, name)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t therm_throt_device_show_##event##_##name(\t\t\\\n\t\t\tstruct device *dev,\t\t\t\t\\\n\t\t\tstruct device_attribute *attr,\t\t\t\\\n\t\t\tchar *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int cpu = dev->id;\t\t\t\t\t\\\n\tssize_t ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t \t\t\t\\\n\tif (cpu_online(cpu)) {\t\t\t\t\t\t\\\n\t\tret = sprintf(buf, \"%lu\\n\",\t\t\t\t\\\n\t\t\t      per_cpu(thermal_state, cpu).event.name);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\tret = 0;\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\ndefine_therm_throt_device_show_func(core_throttle, count);\ndefine_therm_throt_device_one_ro(core_throttle_count);\n\ndefine_therm_throt_device_show_func(core_power_limit, count);\ndefine_therm_throt_device_one_ro(core_power_limit_count);\n\ndefine_therm_throt_device_show_func(package_throttle, count);\ndefine_therm_throt_device_one_ro(package_throttle_count);\n\ndefine_therm_throt_device_show_func(package_power_limit, count);\ndefine_therm_throt_device_one_ro(package_power_limit_count);\n\ndefine_therm_throt_device_show_func(core_throttle, max_time_ms);\ndefine_therm_throt_device_one_ro(core_throttle_max_time_ms);\n\ndefine_therm_throt_device_show_func(package_throttle, max_time_ms);\ndefine_therm_throt_device_one_ro(package_throttle_max_time_ms);\n\ndefine_therm_throt_device_show_func(core_throttle, total_time_ms);\ndefine_therm_throt_device_one_ro(core_throttle_total_time_ms);\n\ndefine_therm_throt_device_show_func(package_throttle, total_time_ms);\ndefine_therm_throt_device_one_ro(package_throttle_total_time_ms);\n\nstatic struct attribute *thermal_throttle_attrs[] = {\n\t&dev_attr_core_throttle_count.attr,\n\t&dev_attr_core_throttle_max_time_ms.attr,\n\t&dev_attr_core_throttle_total_time_ms.attr,\n\tNULL\n};\n\nstatic const struct attribute_group thermal_attr_group = {\n\t.attrs\t= thermal_throttle_attrs,\n\t.name\t= \"thermal_throttle\"\n};\n#endif  \n\n#define THERM_THROT_POLL_INTERVAL\tHZ\n#define THERM_STATUS_PROCHOT_LOG\tBIT(1)\n\nstatic u64 therm_intr_core_clear_mask;\nstatic u64 therm_intr_pkg_clear_mask;\n\nstatic void thermal_intr_init_core_clear_mask(void)\n{\n\tif (therm_intr_core_clear_mask)\n\t\treturn;\n\n\t \n\n\t \n\ttherm_intr_core_clear_mask = (BIT(1) | BIT(3) | BIT(5));\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_TM2))\n\t\ttherm_intr_core_clear_mask |= (BIT(7) | BIT(9));\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_PLN))\n\t\ttherm_intr_core_clear_mask |= BIT(11);\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_HWP))\n\t\ttherm_intr_core_clear_mask |= (BIT(13) | BIT(15));\n}\n\nstatic void thermal_intr_init_pkg_clear_mask(void)\n{\n\tif (therm_intr_pkg_clear_mask)\n\t\treturn;\n\n\t \n\n\t \n\tif (boot_cpu_has(X86_FEATURE_PTS))\n\t\ttherm_intr_pkg_clear_mask = (BIT(1) | BIT(3) | BIT(5) | BIT(7) | BIT(9) | BIT(11));\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_HFI))\n\t\ttherm_intr_pkg_clear_mask |= BIT(26);\n}\n\n \nvoid thermal_clear_package_intr_status(int level, u64 bit_mask)\n{\n\tu64 msr_val;\n\tint msr;\n\n\tif (level == CORE_LEVEL) {\n\t\tmsr  = MSR_IA32_THERM_STATUS;\n\t\tmsr_val = therm_intr_core_clear_mask;\n\t} else {\n\t\tmsr  = MSR_IA32_PACKAGE_THERM_STATUS;\n\t\tmsr_val = therm_intr_pkg_clear_mask;\n\t}\n\n\tmsr_val &= ~bit_mask;\n\twrmsrl(msr, msr_val);\n}\nEXPORT_SYMBOL_GPL(thermal_clear_package_intr_status);\n\nstatic void get_therm_status(int level, bool *proc_hot, u8 *temp)\n{\n\tint msr;\n\tu64 msr_val;\n\n\tif (level == CORE_LEVEL)\n\t\tmsr = MSR_IA32_THERM_STATUS;\n\telse\n\t\tmsr = MSR_IA32_PACKAGE_THERM_STATUS;\n\n\trdmsrl(msr, msr_val);\n\tif (msr_val & THERM_STATUS_PROCHOT_LOG)\n\t\t*proc_hot = true;\n\telse\n\t\t*proc_hot = false;\n\n\t*temp = (msr_val >> 16) & 0x7F;\n}\n\nstatic void __maybe_unused throttle_active_work(struct work_struct *work)\n{\n\tstruct _thermal_state *state = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct _thermal_state, therm_work);\n\tunsigned int i, avg, this_cpu = smp_processor_id();\n\tu64 now = get_jiffies_64();\n\tbool hot;\n\tu8 temp;\n\n\tget_therm_status(state->level, &hot, &temp);\n\t \n\tif (!hot && temp > state->baseline_temp) {\n\t\tif (state->rate_control_active)\n\t\t\tpr_info(\"CPU%d: %s temperature/speed normal (total events = %lu)\\n\",\n\t\t\t\tthis_cpu,\n\t\t\t\tstate->level == CORE_LEVEL ? \"Core\" : \"Package\",\n\t\t\t\tstate->count);\n\n\t\tstate->rate_control_active = false;\n\t\treturn;\n\t}\n\n\tif (time_before64(now, state->next_check) &&\n\t\t\t  state->rate_control_active)\n\t\tgoto re_arm;\n\n\tstate->next_check = now + CHECK_INTERVAL;\n\n\tif (state->count != state->last_count) {\n\t\t \n\t\tstate->last_count = state->count;\n\t\tstate->average = 0;\n\t\tstate->sample_count = 0;\n\t\tstate->sample_index = 0;\n\t}\n\n\tstate->temp_samples[state->sample_index] = temp;\n\tstate->sample_count++;\n\tstate->sample_index = (state->sample_index + 1) % ARRAY_SIZE(state->temp_samples);\n\tif (state->sample_count < ARRAY_SIZE(state->temp_samples))\n\t\tgoto re_arm;\n\n\tavg = 0;\n\tfor (i = 0; i < ARRAY_SIZE(state->temp_samples); ++i)\n\t\tavg += state->temp_samples[i];\n\n\tavg /= ARRAY_SIZE(state->temp_samples);\n\n\tif (state->average > avg) {\n\t\tpr_warn(\"CPU%d: %s temperature is above threshold, cpu clock is throttled (total events = %lu)\\n\",\n\t\t\tthis_cpu,\n\t\t\tstate->level == CORE_LEVEL ? \"Core\" : \"Package\",\n\t\t\tstate->count);\n\t\tstate->rate_control_active = true;\n\t}\n\n\tstate->average = avg;\n\nre_arm:\n\tthermal_clear_package_intr_status(state->level, THERM_STATUS_PROCHOT_LOG);\n\tschedule_delayed_work_on(this_cpu, &state->therm_work, THERM_THROT_POLL_INTERVAL);\n}\n\n \nstatic void therm_throt_process(bool new_event, int event, int level)\n{\n\tstruct _thermal_state *state;\n\tunsigned int this_cpu = smp_processor_id();\n\tbool old_event;\n\tu64 now;\n\tstruct thermal_state *pstate = &per_cpu(thermal_state, this_cpu);\n\n\tnow = get_jiffies_64();\n\tif (level == CORE_LEVEL) {\n\t\tif (event == THERMAL_THROTTLING_EVENT)\n\t\t\tstate = &pstate->core_throttle;\n\t\telse if (event == POWER_LIMIT_EVENT)\n\t\t\tstate = &pstate->core_power_limit;\n\t\telse\n\t\t\treturn;\n\t} else if (level == PACKAGE_LEVEL) {\n\t\tif (event == THERMAL_THROTTLING_EVENT)\n\t\t\tstate = &pstate->package_throttle;\n\t\telse if (event == POWER_LIMIT_EVENT)\n\t\t\tstate = &pstate->package_power_limit;\n\t\telse\n\t\t\treturn;\n\t} else\n\t\treturn;\n\n\told_event = state->new_event;\n\tstate->new_event = new_event;\n\n\tif (new_event)\n\t\tstate->count++;\n\n\tif (event != THERMAL_THROTTLING_EVENT)\n\t\treturn;\n\n\tif (new_event && !state->last_interrupt_time) {\n\t\tbool hot;\n\t\tu8 temp;\n\n\t\tget_therm_status(state->level, &hot, &temp);\n\t\t \n\t\tif (temp > 10)\n\t\t\treturn;\n\n\t\tstate->baseline_temp = temp;\n\t\tstate->last_interrupt_time = now;\n\t\tschedule_delayed_work_on(this_cpu, &state->therm_work, THERM_THROT_POLL_INTERVAL);\n\t} else if (old_event && state->last_interrupt_time) {\n\t\tunsigned long throttle_time;\n\n\t\tthrottle_time = jiffies_delta_to_msecs(now - state->last_interrupt_time);\n\t\tif (throttle_time > state->max_time_ms)\n\t\t\tstate->max_time_ms = throttle_time;\n\t\tstate->total_time_ms += throttle_time;\n\t\tstate->last_interrupt_time = 0;\n\t}\n}\n\nstatic int thresh_event_valid(int level, int event)\n{\n\tstruct _thermal_state *state;\n\tunsigned int this_cpu = smp_processor_id();\n\tstruct thermal_state *pstate = &per_cpu(thermal_state, this_cpu);\n\tu64 now = get_jiffies_64();\n\n\tif (level == PACKAGE_LEVEL)\n\t\tstate = (event == 0) ? &pstate->pkg_thresh0 :\n\t\t\t\t\t\t&pstate->pkg_thresh1;\n\telse\n\t\tstate = (event == 0) ? &pstate->core_thresh0 :\n\t\t\t\t\t\t&pstate->core_thresh1;\n\n\tif (time_before64(now, state->next_check))\n\t\treturn 0;\n\n\tstate->next_check = now + CHECK_INTERVAL;\n\n\treturn 1;\n}\n\nstatic bool int_pln_enable;\nstatic int __init int_pln_enable_setup(char *s)\n{\n\tint_pln_enable = true;\n\n\treturn 1;\n}\n__setup(\"int_pln_enable\", int_pln_enable_setup);\n\n#ifdef CONFIG_SYSFS\n \nstatic int thermal_throttle_add_dev(struct device *dev, unsigned int cpu)\n{\n\tint err;\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\n\terr = sysfs_create_group(&dev->kobj, &thermal_attr_group);\n\tif (err)\n\t\treturn err;\n\n\tif (cpu_has(c, X86_FEATURE_PLN) && int_pln_enable) {\n\t\terr = sysfs_add_file_to_group(&dev->kobj,\n\t\t\t\t\t      &dev_attr_core_power_limit_count.attr,\n\t\t\t\t\t      thermal_attr_group.name);\n\t\tif (err)\n\t\t\tgoto del_group;\n\t}\n\n\tif (cpu_has(c, X86_FEATURE_PTS)) {\n\t\terr = sysfs_add_file_to_group(&dev->kobj,\n\t\t\t\t\t      &dev_attr_package_throttle_count.attr,\n\t\t\t\t\t      thermal_attr_group.name);\n\t\tif (err)\n\t\t\tgoto del_group;\n\n\t\terr = sysfs_add_file_to_group(&dev->kobj,\n\t\t\t\t\t      &dev_attr_package_throttle_max_time_ms.attr,\n\t\t\t\t\t      thermal_attr_group.name);\n\t\tif (err)\n\t\t\tgoto del_group;\n\n\t\terr = sysfs_add_file_to_group(&dev->kobj,\n\t\t\t\t\t      &dev_attr_package_throttle_total_time_ms.attr,\n\t\t\t\t\t      thermal_attr_group.name);\n\t\tif (err)\n\t\t\tgoto del_group;\n\n\t\tif (cpu_has(c, X86_FEATURE_PLN) && int_pln_enable) {\n\t\t\terr = sysfs_add_file_to_group(&dev->kobj,\n\t\t\t\t\t&dev_attr_package_power_limit_count.attr,\n\t\t\t\t\tthermal_attr_group.name);\n\t\t\tif (err)\n\t\t\t\tgoto del_group;\n\t\t}\n\t}\n\n\treturn 0;\n\ndel_group:\n\tsysfs_remove_group(&dev->kobj, &thermal_attr_group);\n\n\treturn err;\n}\n\nstatic void thermal_throttle_remove_dev(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &thermal_attr_group);\n}\n\n \nstatic int thermal_throttle_online(unsigned int cpu)\n{\n\tstruct thermal_state *state = &per_cpu(thermal_state, cpu);\n\tstruct device *dev = get_cpu_device(cpu);\n\tu32 l;\n\n\tstate->package_throttle.level = PACKAGE_LEVEL;\n\tstate->core_throttle.level = CORE_LEVEL;\n\n\tINIT_DELAYED_WORK(&state->package_throttle.therm_work, throttle_active_work);\n\tINIT_DELAYED_WORK(&state->core_throttle.therm_work, throttle_active_work);\n\n\t \n\tintel_hfi_online(cpu);\n\n\t \n\tl = apic_read(APIC_LVTTHMR);\n\tapic_write(APIC_LVTTHMR, l & ~APIC_LVT_MASKED);\n\n\treturn thermal_throttle_add_dev(dev, cpu);\n}\n\nstatic int thermal_throttle_offline(unsigned int cpu)\n{\n\tstruct thermal_state *state = &per_cpu(thermal_state, cpu);\n\tstruct device *dev = get_cpu_device(cpu);\n\tu32 l;\n\n\t \n\tl = apic_read(APIC_LVTTHMR);\n\tapic_write(APIC_LVTTHMR, l | APIC_LVT_MASKED);\n\n\tintel_hfi_offline(cpu);\n\n\tcancel_delayed_work_sync(&state->package_throttle.therm_work);\n\tcancel_delayed_work_sync(&state->core_throttle.therm_work);\n\n\tstate->package_throttle.rate_control_active = false;\n\tstate->core_throttle.rate_control_active = false;\n\n\tthermal_throttle_remove_dev(dev);\n\treturn 0;\n}\n\nstatic __init int thermal_throttle_init_device(void)\n{\n\tint ret;\n\n\tif (!atomic_read(&therm_throt_en))\n\t\treturn 0;\n\n\tintel_hfi_init();\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"x86/therm:online\",\n\t\t\t\tthermal_throttle_online,\n\t\t\t\tthermal_throttle_offline);\n\treturn ret < 0 ? ret : 0;\n}\ndevice_initcall(thermal_throttle_init_device);\n\n#endif  \n\nstatic void notify_package_thresholds(__u64 msr_val)\n{\n\tbool notify_thres_0 = false;\n\tbool notify_thres_1 = false;\n\n\tif (!platform_thermal_package_notify)\n\t\treturn;\n\n\t \n\tif (msr_val & THERM_LOG_THRESHOLD0)\n\t\tnotify_thres_0 = true;\n\t \n\tif (msr_val & THERM_LOG_THRESHOLD1)\n\t\tnotify_thres_1 = true;\n\n\tif (!notify_thres_0 && !notify_thres_1)\n\t\treturn;\n\n\tif (platform_thermal_package_rate_control &&\n\t\tplatform_thermal_package_rate_control()) {\n\t\t \n\t\tplatform_thermal_package_notify(msr_val);\n\t\treturn;\n\t}\n\n\t \n\tif (notify_thres_0 && thresh_event_valid(PACKAGE_LEVEL, 0))\n\t\tplatform_thermal_package_notify(msr_val);\n\t \n\tif (notify_thres_1 && thresh_event_valid(PACKAGE_LEVEL, 1))\n\t\tplatform_thermal_package_notify(msr_val);\n}\n\nstatic void notify_thresholds(__u64 msr_val)\n{\n\t \n\tif (!platform_thermal_notify)\n\t\treturn;\n\n\t \n\tif ((msr_val & THERM_LOG_THRESHOLD0) &&\n\t\t\tthresh_event_valid(CORE_LEVEL, 0))\n\t\tplatform_thermal_notify(msr_val);\n\t \n\tif ((msr_val & THERM_LOG_THRESHOLD1) &&\n\t\t\tthresh_event_valid(CORE_LEVEL, 1))\n\t\tplatform_thermal_notify(msr_val);\n}\n\nvoid __weak notify_hwp_interrupt(void)\n{\n\twrmsrl_safe(MSR_HWP_STATUS, 0);\n}\n\n \nvoid intel_thermal_interrupt(void)\n{\n\t__u64 msr_val;\n\n\tif (static_cpu_has(X86_FEATURE_HWP))\n\t\tnotify_hwp_interrupt();\n\n\trdmsrl(MSR_IA32_THERM_STATUS, msr_val);\n\n\t \n\tnotify_thresholds(msr_val);\n\n\ttherm_throt_process(msr_val & THERM_STATUS_PROCHOT,\n\t\t\t    THERMAL_THROTTLING_EVENT,\n\t\t\t    CORE_LEVEL);\n\n\tif (this_cpu_has(X86_FEATURE_PLN) && int_pln_enable)\n\t\ttherm_throt_process(msr_val & THERM_STATUS_POWER_LIMIT,\n\t\t\t\t\tPOWER_LIMIT_EVENT,\n\t\t\t\t\tCORE_LEVEL);\n\n\tif (this_cpu_has(X86_FEATURE_PTS)) {\n\t\trdmsrl(MSR_IA32_PACKAGE_THERM_STATUS, msr_val);\n\t\t \n\t\tnotify_package_thresholds(msr_val);\n\t\ttherm_throt_process(msr_val & PACKAGE_THERM_STATUS_PROCHOT,\n\t\t\t\t\tTHERMAL_THROTTLING_EVENT,\n\t\t\t\t\tPACKAGE_LEVEL);\n\t\tif (this_cpu_has(X86_FEATURE_PLN) && int_pln_enable)\n\t\t\ttherm_throt_process(msr_val &\n\t\t\t\t\tPACKAGE_THERM_STATUS_POWER_LIMIT,\n\t\t\t\t\tPOWER_LIMIT_EVENT,\n\t\t\t\t\tPACKAGE_LEVEL);\n\n\t\tif (this_cpu_has(X86_FEATURE_HFI))\n\t\t\tintel_hfi_process_event(msr_val &\n\t\t\t\t\t\tPACKAGE_THERM_STATUS_HFI_UPDATED);\n\t}\n}\n\n \nstatic int intel_thermal_supported(struct cpuinfo_x86 *c)\n{\n\tif (!boot_cpu_has(X86_FEATURE_APIC))\n\t\treturn 0;\n\tif (!cpu_has(c, X86_FEATURE_ACPI) || !cpu_has(c, X86_FEATURE_ACC))\n\t\treturn 0;\n\treturn 1;\n}\n\nbool x86_thermal_enabled(void)\n{\n\treturn atomic_read(&therm_throt_en);\n}\n\nvoid __init therm_lvt_init(void)\n{\n\t \n\tif (intel_thermal_supported(&boot_cpu_data))\n\t\tlvtthmr_init = apic_read(APIC_LVTTHMR);\n}\n\nvoid intel_init_thermal(struct cpuinfo_x86 *c)\n{\n\tunsigned int cpu = smp_processor_id();\n\tint tm2 = 0;\n\tu32 l, h;\n\n\tif (!intel_thermal_supported(c))\n\t\treturn;\n\n\t \n\trdmsr(MSR_IA32_MISC_ENABLE, l, h);\n\n\th = lvtthmr_init;\n\t \n\tif ((h & APIC_DM_FIXED_MASK) != APIC_DM_FIXED)\n\t\tapic_write(APIC_LVTTHMR, lvtthmr_init);\n\n\n\tif ((l & MSR_IA32_MISC_ENABLE_TM1) && (h & APIC_DM_SMI)) {\n\t\tif (system_state == SYSTEM_BOOTING)\n\t\t\tpr_debug(\"CPU%d: Thermal monitoring handled by SMI\\n\", cpu);\n\t\treturn;\n\t}\n\n\t \n\tif (cpu_has(c, X86_FEATURE_TM2)) {\n\t\tif (c->x86 == 6 && (c->x86_model == 9 || c->x86_model == 13)) {\n\t\t\trdmsr(MSR_THERM2_CTL, l, h);\n\t\t\tif (l & MSR_THERM2_CTL_TM_SELECT)\n\t\t\t\ttm2 = 1;\n\t\t} else if (l & MSR_IA32_MISC_ENABLE_TM2)\n\t\t\ttm2 = 1;\n\t}\n\n\t \n\th = THERMAL_APIC_VECTOR | APIC_DM_FIXED | APIC_LVT_MASKED;\n\tapic_write(APIC_LVTTHMR, h);\n\n\tthermal_intr_init_core_clear_mask();\n\tthermal_intr_init_pkg_clear_mask();\n\n\trdmsr(MSR_IA32_THERM_INTERRUPT, l, h);\n\tif (cpu_has(c, X86_FEATURE_PLN) && !int_pln_enable)\n\t\twrmsr(MSR_IA32_THERM_INTERRUPT,\n\t\t\t(l | (THERM_INT_LOW_ENABLE\n\t\t\t| THERM_INT_HIGH_ENABLE)) & ~THERM_INT_PLN_ENABLE, h);\n\telse if (cpu_has(c, X86_FEATURE_PLN) && int_pln_enable)\n\t\twrmsr(MSR_IA32_THERM_INTERRUPT,\n\t\t\tl | (THERM_INT_LOW_ENABLE\n\t\t\t| THERM_INT_HIGH_ENABLE | THERM_INT_PLN_ENABLE), h);\n\telse\n\t\twrmsr(MSR_IA32_THERM_INTERRUPT,\n\t\t      l | (THERM_INT_LOW_ENABLE | THERM_INT_HIGH_ENABLE), h);\n\n\tif (cpu_has(c, X86_FEATURE_PTS)) {\n\t\trdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n\t\tif (cpu_has(c, X86_FEATURE_PLN) && !int_pln_enable)\n\t\t\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\t\t(l | (PACKAGE_THERM_INT_LOW_ENABLE\n\t\t\t\t| PACKAGE_THERM_INT_HIGH_ENABLE))\n\t\t\t\t& ~PACKAGE_THERM_INT_PLN_ENABLE, h);\n\t\telse if (cpu_has(c, X86_FEATURE_PLN) && int_pln_enable)\n\t\t\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\t\tl | (PACKAGE_THERM_INT_LOW_ENABLE\n\t\t\t\t| PACKAGE_THERM_INT_HIGH_ENABLE\n\t\t\t\t| PACKAGE_THERM_INT_PLN_ENABLE), h);\n\t\telse\n\t\t\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\t      l | (PACKAGE_THERM_INT_LOW_ENABLE\n\t\t\t\t| PACKAGE_THERM_INT_HIGH_ENABLE), h);\n\n\t\tif (cpu_has(c, X86_FEATURE_HFI)) {\n\t\t\trdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n\t\t\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\t      l | PACKAGE_THERM_INT_HFI_ENABLE, h);\n\t\t}\n\t}\n\n\trdmsr(MSR_IA32_MISC_ENABLE, l, h);\n\twrmsr(MSR_IA32_MISC_ENABLE, l | MSR_IA32_MISC_ENABLE_TM1, h);\n\n\tpr_info_once(\"CPU0: Thermal monitoring enabled (%s)\\n\",\n\t\t      tm2 ? \"TM2\" : \"TM1\");\n\n\t \n\tatomic_set(&therm_throt_en, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}