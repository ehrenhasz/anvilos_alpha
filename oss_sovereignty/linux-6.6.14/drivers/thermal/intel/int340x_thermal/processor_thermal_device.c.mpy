{
  "module_name": "processor_thermal_device.c",
  "hash_id": "f82f9992abca670193da5a4f7c78ab52aaafc71bffae251ebfcc44bd15998514",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/processor_thermal_device.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/intel_tcc.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/thermal.h>\n#include \"int340x_thermal_zone.h\"\n#include \"processor_thermal_device.h\"\n#include \"../intel_soc_dts_iosf.h\"\n\n#define DRV_NAME \"proc_thermal\"\n\n#define POWER_LIMIT_SHOW(index, suffix) \\\nstatic ssize_t power_limit_##index##_##suffix##_show(struct device *dev, \\\n\t\t\t\t\tstruct device_attribute *attr, \\\n\t\t\t\t\tchar *buf) \\\n{ \\\n\tstruct proc_thermal_device *proc_dev = dev_get_drvdata(dev); \\\n\t\\\n\treturn sprintf(buf, \"%lu\\n\",\\\n\t(unsigned long)proc_dev->power_limits[index].suffix * 1000); \\\n}\n\nPOWER_LIMIT_SHOW(0, min_uw)\nPOWER_LIMIT_SHOW(0, max_uw)\nPOWER_LIMIT_SHOW(0, step_uw)\nPOWER_LIMIT_SHOW(0, tmin_us)\nPOWER_LIMIT_SHOW(0, tmax_us)\n\nPOWER_LIMIT_SHOW(1, min_uw)\nPOWER_LIMIT_SHOW(1, max_uw)\nPOWER_LIMIT_SHOW(1, step_uw)\nPOWER_LIMIT_SHOW(1, tmin_us)\nPOWER_LIMIT_SHOW(1, tmax_us)\n\nstatic DEVICE_ATTR_RO(power_limit_0_min_uw);\nstatic DEVICE_ATTR_RO(power_limit_0_max_uw);\nstatic DEVICE_ATTR_RO(power_limit_0_step_uw);\nstatic DEVICE_ATTR_RO(power_limit_0_tmin_us);\nstatic DEVICE_ATTR_RO(power_limit_0_tmax_us);\n\nstatic DEVICE_ATTR_RO(power_limit_1_min_uw);\nstatic DEVICE_ATTR_RO(power_limit_1_max_uw);\nstatic DEVICE_ATTR_RO(power_limit_1_step_uw);\nstatic DEVICE_ATTR_RO(power_limit_1_tmin_us);\nstatic DEVICE_ATTR_RO(power_limit_1_tmax_us);\n\nstatic struct attribute *power_limit_attrs[] = {\n\t&dev_attr_power_limit_0_min_uw.attr,\n\t&dev_attr_power_limit_1_min_uw.attr,\n\t&dev_attr_power_limit_0_max_uw.attr,\n\t&dev_attr_power_limit_1_max_uw.attr,\n\t&dev_attr_power_limit_0_step_uw.attr,\n\t&dev_attr_power_limit_1_step_uw.attr,\n\t&dev_attr_power_limit_0_tmin_us.attr,\n\t&dev_attr_power_limit_1_tmin_us.attr,\n\t&dev_attr_power_limit_0_tmax_us.attr,\n\t&dev_attr_power_limit_1_tmax_us.attr,\n\tNULL\n};\n\nstatic const struct attribute_group power_limit_attribute_group = {\n\t.attrs = power_limit_attrs,\n\t.name = \"power_limits\"\n};\n\nstatic ssize_t tcc_offset_degree_celsius_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tint offset;\n\n\toffset = intel_tcc_get_offset(-1);\n\tif (offset < 0)\n\t\treturn offset;\n\n\treturn sprintf(buf, \"%d\\n\", offset);\n}\n\nstatic ssize_t tcc_offset_degree_celsius_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tunsigned int tcc;\n\tu64 val;\n\tint err;\n\n\terr = rdmsrl_safe(MSR_PLATFORM_INFO, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (!(val & BIT(30)))\n\t\treturn -EACCES;\n\n\tif (kstrtouint(buf, 0, &tcc))\n\t\treturn -EINVAL;\n\n\terr = intel_tcc_set_offset(-1, tcc);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(tcc_offset_degree_celsius);\n\nstatic int proc_thermal_get_zone_temp(struct thermal_zone_device *zone,\n\t\t\t\t\t int *temp)\n{\n\tint cpu;\n\tint curr_temp;\n\n\t*temp = 0;\n\n\tfor_each_online_cpu(cpu) {\n\t\tcurr_temp = intel_tcc_get_temp(cpu, false);\n\t\tif (curr_temp < 0)\n\t\t\treturn curr_temp;\n\t\tif (!*temp || curr_temp > *temp)\n\t\t\t*temp = curr_temp;\n\t}\n\n\t*temp *= 1000;\n\n\treturn 0;\n}\n\nstatic int proc_thermal_read_ppcc(struct proc_thermal_device *proc_priv)\n{\n\tint i;\n\tacpi_status status;\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *elements, *ppcc;\n\tunion acpi_object *p;\n\tint ret = 0;\n\n\tstatus = acpi_evaluate_object(proc_priv->adev->handle, \"PPCC\",\n\t\t\t\t      NULL, &buf);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tp = buf.pointer;\n\tif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\n\t\tdev_err(proc_priv->dev, \"Invalid PPCC data\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_buffer;\n\t}\n\n\tif (!p->package.count) {\n\t\tdev_err(proc_priv->dev, \"Invalid PPCC package size\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_buffer;\n\t}\n\n\tfor (i = 0; i < min((int)p->package.count - 1, 2); ++i) {\n\t\telements = &(p->package.elements[i+1]);\n\t\tif (elements->type != ACPI_TYPE_PACKAGE ||\n\t\t    elements->package.count != 6) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_buffer;\n\t\t}\n\t\tppcc = elements->package.elements;\n\t\tproc_priv->power_limits[i].index = ppcc[0].integer.value;\n\t\tproc_priv->power_limits[i].min_uw = ppcc[1].integer.value;\n\t\tproc_priv->power_limits[i].max_uw = ppcc[2].integer.value;\n\t\tproc_priv->power_limits[i].tmin_us = ppcc[3].integer.value;\n\t\tproc_priv->power_limits[i].tmax_us = ppcc[4].integer.value;\n\t\tproc_priv->power_limits[i].step_uw = ppcc[5].integer.value;\n\t}\n\nfree_buffer:\n\tkfree(buf.pointer);\n\n\treturn ret;\n}\n\n#define PROC_POWER_CAPABILITY_CHANGED\t0x83\nstatic void proc_thermal_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct proc_thermal_device *proc_priv = data;\n\n\tif (!proc_priv)\n\t\treturn;\n\n\tswitch (event) {\n\tcase PROC_POWER_CAPABILITY_CHANGED:\n\t\tproc_thermal_read_ppcc(proc_priv);\n\t\tint340x_thermal_zone_device_update(proc_priv->int340x_zone,\n\t\t\t\tTHERMAL_DEVICE_POWER_CAPABILITY_CHANGED);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(proc_priv->dev, \"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n}\n\nint proc_thermal_add(struct device *dev, struct proc_thermal_device *proc_priv)\n{\n\tstruct acpi_device *adev;\n\tacpi_status status;\n\tunsigned long long tmp;\n\tint (*get_temp) (struct thermal_zone_device *, int *) = NULL;\n\tint ret;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tproc_priv->dev = dev;\n\tproc_priv->adev = adev;\n\n\tret = proc_thermal_read_ppcc(proc_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"_TMP\", NULL, &tmp);\n\tif (ACPI_FAILURE(status)) {\n\t\t \n\t\tif (intel_tcc_get_tjmax(-1) > 0)\n\t\t\tget_temp = proc_thermal_get_zone_temp;\n\t}\n\n\tproc_priv->int340x_zone = int340x_thermal_zone_add(adev, get_temp);\n\tif (IS_ERR(proc_priv->int340x_zone)) {\n\t\treturn PTR_ERR(proc_priv->int340x_zone);\n\t} else\n\t\tret = 0;\n\n\tret = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t  proc_thermal_notify,\n\t\t\t\t\t  (void *)proc_priv);\n\tif (ret)\n\t\tgoto remove_zone;\n\n\tret = sysfs_create_file(&dev->kobj, &dev_attr_tcc_offset_degree_celsius.attr);\n\tif (ret)\n\t\tgoto remove_notify;\n\n\tret = sysfs_create_group(&dev->kobj, &power_limit_attribute_group);\n\tif (ret) {\n\t\tsysfs_remove_file(&dev->kobj, &dev_attr_tcc_offset_degree_celsius.attr);\n\t\tgoto remove_notify;\n\t}\n\n\treturn 0;\n\nremove_notify:\n\tacpi_remove_notify_handler(adev->handle,\n\t\t\t\t    ACPI_DEVICE_NOTIFY, proc_thermal_notify);\nremove_zone:\n\tint340x_thermal_zone_remove(proc_priv->int340x_zone);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(proc_thermal_add);\n\nvoid proc_thermal_remove(struct proc_thermal_device *proc_priv)\n{\n\tacpi_remove_notify_handler(proc_priv->adev->handle,\n\t\t\t\t   ACPI_DEVICE_NOTIFY, proc_thermal_notify);\n\tint340x_thermal_zone_remove(proc_priv->int340x_zone);\n\tsysfs_remove_file(&proc_priv->dev->kobj, &dev_attr_tcc_offset_degree_celsius.attr);\n\tsysfs_remove_group(&proc_priv->dev->kobj,\n\t\t\t   &power_limit_attribute_group);\n}\nEXPORT_SYMBOL_GPL(proc_thermal_remove);\n\nstatic int tcc_offset_save = -1;\n\nint proc_thermal_suspend(struct device *dev)\n{\n\ttcc_offset_save = intel_tcc_get_offset(-1);\n\tif (tcc_offset_save < 0)\n\t\tdev_warn(dev, \"failed to save offset (%d)\\n\", tcc_offset_save);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(proc_thermal_suspend);\n\nint proc_thermal_resume(struct device *dev)\n{\n\tstruct proc_thermal_device *proc_dev;\n\n\tproc_dev = dev_get_drvdata(dev);\n\tproc_thermal_read_ppcc(proc_dev);\n\n\t \n\tif (tcc_offset_save >= 0)\n\t\tintel_tcc_set_offset(-1, tcc_offset_save);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(proc_thermal_resume);\n\n#define MCHBAR 0\n\nstatic int proc_thermal_set_mmio_base(struct pci_dev *pdev, struct proc_thermal_device *proc_priv)\n{\n\tint ret;\n\n\tret = pcim_iomap_regions(pdev, 1 << MCHBAR, DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot reserve PCI memory region\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tproc_priv->mmio_base = pcim_iomap_table(pdev)[MCHBAR];\n\n\treturn 0;\n}\n\nint proc_thermal_mmio_add(struct pci_dev *pdev,\n\t\t\t  struct proc_thermal_device *proc_priv,\n\t\t\t  kernel_ulong_t feature_mask)\n{\n\tint ret;\n\n\tproc_priv->mmio_feature_mask = feature_mask;\n\n\tif (feature_mask) {\n\t\tret = proc_thermal_set_mmio_base(pdev, proc_priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (feature_mask & PROC_THERMAL_FEATURE_RAPL) {\n\t\tret = proc_thermal_rapl_add(pdev, proc_priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to add RAPL MMIO interface\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (feature_mask & PROC_THERMAL_FEATURE_FIVR ||\n\t    feature_mask & PROC_THERMAL_FEATURE_DVFS ||\n\t    feature_mask & PROC_THERMAL_FEATURE_DLVR) {\n\t\tret = proc_thermal_rfim_add(pdev, proc_priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to add RFIM interface\\n\");\n\t\t\tgoto err_rem_rapl;\n\t\t}\n\t}\n\n\tif (feature_mask & PROC_THERMAL_FEATURE_MBOX) {\n\t\tret = proc_thermal_mbox_add(pdev, proc_priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to add MBOX interface\\n\");\n\t\t\tgoto err_rem_rfim;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_rem_rfim:\n\tproc_thermal_rfim_remove(pdev);\nerr_rem_rapl:\n\tproc_thermal_rapl_remove();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(proc_thermal_mmio_add);\n\nvoid proc_thermal_mmio_remove(struct pci_dev *pdev, struct proc_thermal_device *proc_priv)\n{\n\tif (proc_priv->mmio_feature_mask & PROC_THERMAL_FEATURE_RAPL)\n\t\tproc_thermal_rapl_remove();\n\n\tif (proc_priv->mmio_feature_mask & PROC_THERMAL_FEATURE_FIVR ||\n\t    proc_priv->mmio_feature_mask & PROC_THERMAL_FEATURE_DVFS)\n\t\tproc_thermal_rfim_remove(pdev);\n\n\tif (proc_priv->mmio_feature_mask & PROC_THERMAL_FEATURE_MBOX)\n\t\tproc_thermal_mbox_remove(pdev);\n}\nEXPORT_SYMBOL_GPL(proc_thermal_mmio_remove);\n\nMODULE_IMPORT_NS(INTEL_TCC);\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Processor Thermal Reporting Device Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}