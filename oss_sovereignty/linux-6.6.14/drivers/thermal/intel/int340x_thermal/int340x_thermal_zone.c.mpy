{
  "module_name": "int340x_thermal_zone.c",
  "hash_id": "76e4994e29ca7c7645c7cb0fc23b042d0d613369a5d39beb9d84ad26b8c223a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/int340x_thermal_zone.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/thermal.h>\n#include <linux/units.h>\n#include \"int340x_thermal_zone.h\"\n\nstatic int int340x_thermal_get_zone_temp(struct thermal_zone_device *zone,\n\t\t\t\t\t int *temp)\n{\n\tstruct int34x_thermal_zone *d = thermal_zone_device_priv(zone);\n\tunsigned long long tmp;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(d->adev->handle, \"_TMP\", NULL, &tmp);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tif (d->lpat_table) {\n\t\tint conv_temp;\n\n\t\tconv_temp = acpi_lpat_raw_to_temp(d->lpat_table, (int)tmp);\n\t\tif (conv_temp < 0)\n\t\t\treturn conv_temp;\n\n\t\t*temp = conv_temp * 10;\n\t} else {\n\t\t \n\t\t*temp = deci_kelvin_to_millicelsius(tmp);\n\t}\n\n\treturn 0;\n}\n\nstatic int int340x_thermal_set_trip_temp(struct thermal_zone_device *zone,\n\t\t\t\t\t int trip, int temp)\n{\n\tstruct int34x_thermal_zone *d = thermal_zone_device_priv(zone);\n\tchar name[] = {'P', 'A', 'T', '0' + trip, '\\0'};\n\tacpi_status status;\n\n\tif (trip > 9)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_execute_simple_method(d->adev->handle, name,\n\t\t\t\t\t    millicelsius_to_deci_kelvin(temp));\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void int340x_thermal_critical(struct thermal_zone_device *zone)\n{\n\tdev_dbg(&zone->device, \"%s: critical temperature reached\\n\", zone->type);\n}\n\nstatic struct thermal_zone_device_ops int340x_thermal_zone_ops = {\n\t.get_temp       = int340x_thermal_get_zone_temp,\n\t.set_trip_temp\t= int340x_thermal_set_trip_temp,\n\t.critical\t= int340x_thermal_critical,\n};\n\nstatic int int340x_thermal_read_trips(struct acpi_device *zone_adev,\n\t\t\t\t      struct thermal_trip *zone_trips,\n\t\t\t\t      int trip_cnt)\n{\n\tint i, ret;\n\n\tret = thermal_acpi_critical_trip_temp(zone_adev,\n\t\t\t\t\t      &zone_trips[trip_cnt].temperature);\n\tif (!ret) {\n\t\tzone_trips[trip_cnt].type = THERMAL_TRIP_CRITICAL;\n\t\ttrip_cnt++;\n\t}\n\n\tret = thermal_acpi_hot_trip_temp(zone_adev,\n\t\t\t\t\t &zone_trips[trip_cnt].temperature);\n\tif (!ret) {\n\t\tzone_trips[trip_cnt].type = THERMAL_TRIP_HOT;\n\t\ttrip_cnt++;\n\t}\n\n\tret = thermal_acpi_passive_trip_temp(zone_adev,\n\t\t\t\t\t     &zone_trips[trip_cnt].temperature);\n\tif (!ret) {\n\t\tzone_trips[trip_cnt].type = THERMAL_TRIP_PASSIVE;\n\t\ttrip_cnt++;\n\t}\n\n\tfor (i = 0; i < INT340X_THERMAL_MAX_ACT_TRIP_COUNT; i++) {\n\t\tret = thermal_acpi_active_trip_temp(zone_adev, i,\n\t\t\t\t\t\t    &zone_trips[trip_cnt].temperature);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tzone_trips[trip_cnt].type = THERMAL_TRIP_ACTIVE;\n\t\ttrip_cnt++;\n\t}\n\n\treturn trip_cnt;\n}\n\nstatic struct thermal_zone_params int340x_thermal_params = {\n\t.governor_name = \"user_space\",\n\t.no_hwmon = true,\n};\n\nstruct int34x_thermal_zone *int340x_thermal_zone_add(struct acpi_device *adev,\n\t\t\t\t\t\t     int (*get_temp) (struct thermal_zone_device *, int *))\n{\n\tstruct int34x_thermal_zone *int34x_zone;\n\tstruct thermal_trip *zone_trips;\n\tunsigned long long trip_cnt = 0;\n\tunsigned long long hyst;\n\tint trip_mask = 0;\n\tacpi_status status;\n\tint i, ret;\n\n\tint34x_zone = kzalloc(sizeof(*int34x_zone), GFP_KERNEL);\n\tif (!int34x_zone)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tint34x_zone->adev = adev;\n\n\tint34x_zone->ops = kmemdup(&int340x_thermal_zone_ops,\n\t\t\t\t   sizeof(int340x_thermal_zone_ops), GFP_KERNEL);\n\tif (!int34x_zone->ops) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ops_alloc;\n\t}\n\n\tif (get_temp)\n\t\tint34x_zone->ops->get_temp = get_temp;\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"PATC\", NULL, &trip_cnt);\n\tif (ACPI_SUCCESS(status)) {\n\t\tint34x_zone->aux_trip_nr = trip_cnt;\n\t\ttrip_mask = BIT(trip_cnt) - 1;\n\t}\n\n\tzone_trips = kzalloc(sizeof(*zone_trips) * (trip_cnt + INT340X_THERMAL_MAX_TRIP_COUNT),\n\t\t\t     GFP_KERNEL);\n\tif (!zone_trips) {\n\t\tret = -ENOMEM;\n\t\tgoto err_trips_alloc;\n\t}\n\n\tfor (i = 0; i < trip_cnt; i++) {\n\t\tzone_trips[i].type = THERMAL_TRIP_PASSIVE;\n\t\tzone_trips[i].temperature = THERMAL_TEMP_INVALID;\n\t}\n\n\ttrip_cnt = int340x_thermal_read_trips(adev, zone_trips, trip_cnt);\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"GTSH\", NULL, &hyst);\n\tif (ACPI_SUCCESS(status))\n\t\thyst *= 100;\n\telse\n\t\thyst = 0;\n\n\tfor (i = 0; i < trip_cnt; ++i)\n\t\tzone_trips[i].hysteresis = hyst;\n\n\tint34x_zone->trips = zone_trips;\n\n\tint34x_zone->lpat_table = acpi_lpat_get_conversion_table(adev->handle);\n\n\tint34x_zone->zone = thermal_zone_device_register_with_trips(\n\t\t\t\t\t\t\tacpi_device_bid(adev),\n\t\t\t\t\t\t\tzone_trips, trip_cnt,\n\t\t\t\t\t\t\ttrip_mask, int34x_zone,\n\t\t\t\t\t\t\tint34x_zone->ops,\n\t\t\t\t\t\t\t&int340x_thermal_params,\n\t\t\t\t\t\t\t0, 0);\n\tif (IS_ERR(int34x_zone->zone)) {\n\t\tret = PTR_ERR(int34x_zone->zone);\n\t\tgoto err_thermal_zone;\n\t}\n\tret = thermal_zone_device_enable(int34x_zone->zone);\n\tif (ret)\n\t\tgoto err_enable;\n\n\treturn int34x_zone;\n\nerr_enable:\n\tthermal_zone_device_unregister(int34x_zone->zone);\nerr_thermal_zone:\n\tkfree(int34x_zone->trips);\n\tacpi_lpat_free_conversion_table(int34x_zone->lpat_table);\nerr_trips_alloc:\n\tkfree(int34x_zone->ops);\nerr_ops_alloc:\n\tkfree(int34x_zone);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(int340x_thermal_zone_add);\n\nvoid int340x_thermal_zone_remove(struct int34x_thermal_zone *int34x_zone)\n{\n\tthermal_zone_device_unregister(int34x_zone->zone);\n\tacpi_lpat_free_conversion_table(int34x_zone->lpat_table);\n\tkfree(int34x_zone->trips);\n\tkfree(int34x_zone->ops);\n\tkfree(int34x_zone);\n}\nEXPORT_SYMBOL_GPL(int340x_thermal_zone_remove);\n\nvoid int340x_thermal_update_trips(struct int34x_thermal_zone *int34x_zone)\n{\n\tstruct acpi_device *zone_adev = int34x_zone->adev;\n\tstruct thermal_trip *zone_trips = int34x_zone->trips;\n\tint trip_cnt = int34x_zone->zone->num_trips;\n\tint act_trip_nr = 0;\n\tint i;\n\n\tmutex_lock(&int34x_zone->zone->lock);\n\n\tfor (i = int34x_zone->aux_trip_nr; i < trip_cnt; i++) {\n\t\tint temp, err;\n\n\t\tswitch (zone_trips[i].type) {\n\t\tcase THERMAL_TRIP_CRITICAL:\n\t\t\terr = thermal_acpi_critical_trip_temp(zone_adev, &temp);\n\t\t\tbreak;\n\t\tcase THERMAL_TRIP_HOT:\n\t\t\terr = thermal_acpi_hot_trip_temp(zone_adev, &temp);\n\t\t\tbreak;\n\t\tcase THERMAL_TRIP_PASSIVE:\n\t\t\terr = thermal_acpi_passive_trip_temp(zone_adev, &temp);\n\t\t\tbreak;\n\t\tcase THERMAL_TRIP_ACTIVE:\n\t\t\terr = thermal_acpi_active_trip_temp(zone_adev, act_trip_nr++,\n\t\t\t\t\t\t\t    &temp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENODEV;\n\t\t}\n\t\tif (err) {\n\t\t\tzone_trips[i].temperature = THERMAL_TEMP_INVALID;\n\t\t\tcontinue;\n\t\t}\n\n\t\tzone_trips[i].temperature = temp;\n\t}\n\n\tmutex_unlock(&int34x_zone->zone->lock);\n}\nEXPORT_SYMBOL_GPL(int340x_thermal_update_trips);\n\nMODULE_AUTHOR(\"Aaron Lu <aaron.lu@intel.com>\");\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel INT340x common thermal zone handler\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}