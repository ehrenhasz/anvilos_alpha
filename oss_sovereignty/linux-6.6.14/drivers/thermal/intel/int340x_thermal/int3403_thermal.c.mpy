{
  "module_name": "int3403_thermal.c",
  "hash_id": "591ca0acb23fd1099a2bc61754df6c4632b5155ec433b0031f9fd0416662c06f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/int3403_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <linux/thermal.h>\n#include <linux/platform_device.h>\n#include \"int340x_thermal_zone.h\"\n\n#define INT3403_TYPE_SENSOR\t\t0x03\n#define INT3403_TYPE_CHARGER\t\t0x0B\n#define INT3403_TYPE_BATTERY\t\t0x0C\n#define INT3403_PERF_CHANGED_EVENT\t0x80\n#define INT3403_PERF_TRIP_POINT_CHANGED\t0x81\n#define INT3403_THERMAL_EVENT\t\t0x90\n\n \nstruct int3403_sensor {\n\tstruct int34x_thermal_zone *int340x_zone;\n};\n\nstruct int3403_performance_state {\n\tu64 performance;\n\tu64 power;\n\tu64 latency;\n\tu64 linear;\n\tu64 control;\n\tu64 raw_performace;\n\tchar *raw_unit;\n\tint reserved;\n};\n\nstruct int3403_cdev {\n\tstruct thermal_cooling_device *cdev;\n\tunsigned long max_state;\n};\n\nstruct int3403_priv {\n\tstruct platform_device *pdev;\n\tstruct acpi_device *adev;\n\tunsigned long long type;\n\tvoid *priv;\n};\n\nstatic void int3403_notify(acpi_handle handle,\n\t\tu32 event, void *data)\n{\n\tstruct int3403_priv *priv = data;\n\tstruct int3403_sensor *obj;\n\n\tif (!priv)\n\t\treturn;\n\n\tobj = priv->priv;\n\tif (priv->type != INT3403_TYPE_SENSOR || !obj)\n\t\treturn;\n\n\tswitch (event) {\n\tcase INT3403_PERF_CHANGED_EVENT:\n\t\tbreak;\n\tcase INT3403_THERMAL_EVENT:\n\t\tint340x_thermal_zone_device_update(obj->int340x_zone,\n\t\t\t\t\t\t   THERMAL_TRIP_VIOLATED);\n\t\tbreak;\n\tcase INT3403_PERF_TRIP_POINT_CHANGED:\n\t\tint340x_thermal_update_trips(obj->int340x_zone);\n\t\tint340x_thermal_zone_device_update(obj->int340x_zone,\n\t\t\t\t\t\t   THERMAL_TRIP_CHANGED);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->pdev->dev, \"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n}\n\nstatic int int3403_sensor_add(struct int3403_priv *priv)\n{\n\tint result = 0;\n\tstruct int3403_sensor *obj;\n\n\tobj = devm_kzalloc(&priv->pdev->dev, sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn -ENOMEM;\n\n\tpriv->priv = obj;\n\n\tobj->int340x_zone = int340x_thermal_zone_add(priv->adev, NULL);\n\tif (IS_ERR(obj->int340x_zone))\n\t\treturn PTR_ERR(obj->int340x_zone);\n\n\tresult = acpi_install_notify_handler(priv->adev->handle,\n\t\t\tACPI_DEVICE_NOTIFY, int3403_notify,\n\t\t\t(void *)priv);\n\tif (result)\n\t\tgoto err_free_obj;\n\n\treturn 0;\n\n err_free_obj:\n\tint340x_thermal_zone_remove(obj->int340x_zone);\n\treturn result;\n}\n\nstatic int int3403_sensor_remove(struct int3403_priv *priv)\n{\n\tstruct int3403_sensor *obj = priv->priv;\n\n\tacpi_remove_notify_handler(priv->adev->handle,\n\t\t\t\t   ACPI_DEVICE_NOTIFY, int3403_notify);\n\tint340x_thermal_zone_remove(obj->int340x_zone);\n\n\treturn 0;\n}\n\n \nstatic int int3403_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct int3403_priv *priv = cdev->devdata;\n\tstruct int3403_cdev *obj = priv->priv;\n\n\t*state = obj->max_state;\n\treturn 0;\n}\n\nstatic int int3403_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct int3403_priv *priv = cdev->devdata;\n\tunsigned long long level;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(priv->adev->handle, \"PPPC\", NULL, &level);\n\tif (ACPI_SUCCESS(status)) {\n\t\t*state = level;\n\t\treturn 0;\n\t} else\n\t\treturn -EINVAL;\n}\n\nstatic int\nint3403_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)\n{\n\tstruct int3403_priv *priv = cdev->devdata;\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(priv->adev->handle, \"SPPC\", state);\n\tif (ACPI_SUCCESS(status))\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic const struct thermal_cooling_device_ops int3403_cooling_ops = {\n\t.get_max_state = int3403_get_max_state,\n\t.get_cur_state = int3403_get_cur_state,\n\t.set_cur_state = int3403_set_cur_state,\n};\n\nstatic int int3403_cdev_add(struct int3403_priv *priv)\n{\n\tint result = 0;\n\tacpi_status status;\n\tstruct int3403_cdev *obj;\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *p;\n\n\tobj = devm_kzalloc(&priv->pdev->dev, sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn -ENOMEM;\n\n\tstatus = acpi_evaluate_object(priv->adev->handle, \"PPSS\", NULL, &buf);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tp = buf.pointer;\n\tif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\n\t\tpr_warn(\"Invalid PPSS data\\n\");\n\t\tkfree(buf.pointer);\n\t\treturn -EFAULT;\n\t}\n\n\tpriv->priv = obj;\n\tobj->max_state = p->package.count - 1;\n\tobj->cdev =\n\t\tthermal_cooling_device_register(acpi_device_bid(priv->adev),\n\t\t\t\tpriv, &int3403_cooling_ops);\n\tif (IS_ERR(obj->cdev))\n\t\tresult = PTR_ERR(obj->cdev);\n\n\tkfree(buf.pointer);\n\t \n\n\treturn result;\n}\n\nstatic int int3403_cdev_remove(struct int3403_priv *priv)\n{\n\tstruct int3403_cdev *obj = priv->priv;\n\n\tthermal_cooling_device_unregister(obj->cdev);\n\treturn 0;\n}\n\nstatic int int3403_add(struct platform_device *pdev)\n{\n\tstruct int3403_priv *priv;\n\tint result = 0;\n\tunsigned long long tmp;\n\tacpi_status status;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct int3403_priv),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdev = pdev;\n\tpriv->adev = ACPI_COMPANION(&(pdev->dev));\n\tif (!priv->adev) {\n\t\tresult = -EINVAL;\n\t\tgoto err;\n\t}\n\n\n\tstatus = acpi_evaluate_integer(priv->adev->handle, \"_TMP\",\n\t\t\t\t       NULL, &tmp);\n\tif (ACPI_FAILURE(status)) {\n\t\tstatus = acpi_evaluate_integer(priv->adev->handle, \"PTYP\",\n\t\t\t\t       NULL, &priv->type);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tpriv->type = INT3403_TYPE_SENSOR;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tswitch (priv->type) {\n\tcase INT3403_TYPE_SENSOR:\n\t\tresult = int3403_sensor_add(priv);\n\t\tbreak;\n\tcase INT3403_TYPE_CHARGER:\n\tcase INT3403_TYPE_BATTERY:\n\t\tresult = int3403_cdev_add(priv);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\n\tif (result)\n\t\tgoto err;\n\treturn result;\n\nerr:\n\treturn result;\n}\n\nstatic int int3403_remove(struct platform_device *pdev)\n{\n\tstruct int3403_priv *priv = platform_get_drvdata(pdev);\n\n\tswitch (priv->type) {\n\tcase INT3403_TYPE_SENSOR:\n\t\tint3403_sensor_remove(priv);\n\t\tbreak;\n\tcase INT3403_TYPE_CHARGER:\n\tcase INT3403_TYPE_BATTERY:\n\t\tint3403_cdev_remove(priv);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id int3403_device_ids[] = {\n\t{\"INT3403\", 0},\n\t{\"INTC1043\", 0},\n\t{\"INTC1046\", 0},\n\t{\"INTC1062\", 0},\n\t{\"INTC10A1\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, int3403_device_ids);\n\nstatic struct platform_driver int3403_driver = {\n\t.probe = int3403_add,\n\t.remove = int3403_remove,\n\t.driver = {\n\t\t.name = \"int3403 thermal\",\n\t\t.acpi_match_table = int3403_device_ids,\n\t},\n};\n\nmodule_platform_driver(int3403_driver);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ACPI INT3403 thermal driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}