{
  "module_name": "processor_thermal_rapl.c",
  "hash_id": "2416c94eb75c6ae9abc519d5253a8d24cfa792b50ad7d23859bcb01e86e95ee9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/processor_thermal_rapl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include \"processor_thermal_device.h\"\n\nstatic struct rapl_if_priv rapl_mmio_priv;\n\nstatic const struct rapl_mmio_regs rapl_mmio_default = {\n\t.reg_unit = 0x5938,\n\t.regs[RAPL_DOMAIN_PACKAGE] = { 0x59a0, 0x593c, 0x58f0, 0, 0x5930},\n\t.regs[RAPL_DOMAIN_DRAM] = { 0x58e0, 0x58e8, 0x58ec, 0, 0},\n\t.limits[RAPL_DOMAIN_PACKAGE] = BIT(POWER_LIMIT2),\n\t.limits[RAPL_DOMAIN_DRAM] = BIT(POWER_LIMIT2),\n};\n\nstatic int rapl_mmio_cpu_online(unsigned int cpu)\n{\n\tstruct rapl_package *rp;\n\n\t \n\tif (topology_physical_package_id(cpu))\n\t\treturn 0;\n\n\trp = rapl_find_package_domain(cpu, &rapl_mmio_priv, true);\n\tif (!rp) {\n\t\trp = rapl_add_package(cpu, &rapl_mmio_priv, true);\n\t\tif (IS_ERR(rp))\n\t\t\treturn PTR_ERR(rp);\n\t}\n\tcpumask_set_cpu(cpu, &rp->cpumask);\n\treturn 0;\n}\n\nstatic int rapl_mmio_cpu_down_prep(unsigned int cpu)\n{\n\tstruct rapl_package *rp;\n\tint lead_cpu;\n\n\trp = rapl_find_package_domain(cpu, &rapl_mmio_priv, true);\n\tif (!rp)\n\t\treturn 0;\n\n\tcpumask_clear_cpu(cpu, &rp->cpumask);\n\tlead_cpu = cpumask_first(&rp->cpumask);\n\tif (lead_cpu >= nr_cpu_ids)\n\t\trapl_remove_package(rp);\n\telse if (rp->lead_cpu == cpu)\n\t\trp->lead_cpu = lead_cpu;\n\treturn 0;\n}\n\nstatic int rapl_mmio_read_raw(int cpu, struct reg_action *ra)\n{\n\tif (!ra->reg.mmio)\n\t\treturn -EINVAL;\n\n\tra->value = readq(ra->reg.mmio);\n\tra->value &= ra->mask;\n\treturn 0;\n}\n\nstatic int rapl_mmio_write_raw(int cpu, struct reg_action *ra)\n{\n\tu64 val;\n\n\tif (!ra->reg.mmio)\n\t\treturn -EINVAL;\n\n\tval = readq(ra->reg.mmio);\n\tval &= ~ra->mask;\n\tval |= ra->value;\n\twriteq(val, ra->reg.mmio);\n\treturn 0;\n}\n\nint proc_thermal_rapl_add(struct pci_dev *pdev, struct proc_thermal_device *proc_priv)\n{\n\tconst struct rapl_mmio_regs *rapl_regs = &rapl_mmio_default;\n\tenum rapl_domain_reg_id reg;\n\tenum rapl_domain_type domain;\n\tint ret;\n\n\tif (!rapl_regs)\n\t\treturn 0;\n\n\tfor (domain = RAPL_DOMAIN_PACKAGE; domain < RAPL_DOMAIN_MAX; domain++) {\n\t\tfor (reg = RAPL_DOMAIN_REG_LIMIT; reg < RAPL_DOMAIN_REG_MAX; reg++)\n\t\t\tif (rapl_regs->regs[domain][reg])\n\t\t\t\trapl_mmio_priv.regs[domain][reg].mmio =\n\t\t\t\t\t\tproc_priv->mmio_base +\n\t\t\t\t\t\trapl_regs->regs[domain][reg];\n\t\trapl_mmio_priv.limits[domain] = rapl_regs->limits[domain];\n\t}\n\trapl_mmio_priv.type = RAPL_IF_MMIO;\n\trapl_mmio_priv.reg_unit.mmio = proc_priv->mmio_base + rapl_regs->reg_unit;\n\n\trapl_mmio_priv.read_raw = rapl_mmio_read_raw;\n\trapl_mmio_priv.write_raw = rapl_mmio_write_raw;\n\n\trapl_mmio_priv.control_type = powercap_register_control_type(NULL, \"intel-rapl-mmio\", NULL);\n\tif (IS_ERR(rapl_mmio_priv.control_type)) {\n\t\tpr_debug(\"failed to register powercap control_type.\\n\");\n\t\treturn PTR_ERR(rapl_mmio_priv.control_type);\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"powercap/rapl:online\",\n\t\t\t\trapl_mmio_cpu_online, rapl_mmio_cpu_down_prep);\n\tif (ret < 0) {\n\t\tpowercap_unregister_control_type(rapl_mmio_priv.control_type);\n\t\trapl_mmio_priv.control_type = NULL;\n\t\treturn ret;\n\t}\n\trapl_mmio_priv.pcap_rapl_online = ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(proc_thermal_rapl_add);\n\nvoid proc_thermal_rapl_remove(void)\n{\n\tif (IS_ERR_OR_NULL(rapl_mmio_priv.control_type))\n\t\treturn;\n\n\tcpuhp_remove_state(rapl_mmio_priv.pcap_rapl_online);\n\tpowercap_unregister_control_type(rapl_mmio_priv.control_type);\n}\nEXPORT_SYMBOL_GPL(proc_thermal_rapl_remove);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}