{
  "module_name": "processor_thermal_device_pci.c",
  "hash_id": "946d4004a15e8b25b929e6f676e287c9b66da097518c22836e71736490e68ae0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/processor_thermal_device_pci.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/thermal.h>\n\n#include \"int340x_thermal_zone.h\"\n#include \"processor_thermal_device.h\"\n\n#define DRV_NAME \"proc_thermal_pci\"\n\nstruct proc_thermal_pci {\n\tstruct pci_dev *pdev;\n\tstruct proc_thermal_device *proc_priv;\n\tstruct thermal_zone_device *tzone;\n\tstruct delayed_work work;\n\tint stored_thres;\n\tint no_legacy;\n};\n\nenum proc_thermal_mmio_type {\n\tPROC_THERMAL_MMIO_TJMAX,\n\tPROC_THERMAL_MMIO_PP0_TEMP,\n\tPROC_THERMAL_MMIO_PP1_TEMP,\n\tPROC_THERMAL_MMIO_PKG_TEMP,\n\tPROC_THERMAL_MMIO_THRES_0,\n\tPROC_THERMAL_MMIO_THRES_1,\n\tPROC_THERMAL_MMIO_INT_ENABLE_0,\n\tPROC_THERMAL_MMIO_INT_ENABLE_1,\n\tPROC_THERMAL_MMIO_INT_STATUS_0,\n\tPROC_THERMAL_MMIO_INT_STATUS_1,\n\tPROC_THERMAL_MMIO_MAX\n};\n\nstruct proc_thermal_mmio_info {\n\tenum proc_thermal_mmio_type mmio_type;\n\tu64\tmmio_addr;\n\tu64\tshift;\n\tu64\tmask;\n};\n\nstatic struct proc_thermal_mmio_info proc_thermal_mmio_info[] = {\n\t{ PROC_THERMAL_MMIO_TJMAX, 0x599c, 16, 0xff },\n\t{ PROC_THERMAL_MMIO_PP0_TEMP, 0x597c, 0, 0xff },\n\t{ PROC_THERMAL_MMIO_PP1_TEMP, 0x5980, 0, 0xff },\n\t{ PROC_THERMAL_MMIO_PKG_TEMP, 0x5978, 0, 0xff },\n\t{ PROC_THERMAL_MMIO_THRES_0, 0x5820, 8, 0x7F },\n\t{ PROC_THERMAL_MMIO_THRES_1, 0x5820, 16, 0x7F },\n\t{ PROC_THERMAL_MMIO_INT_ENABLE_0, 0x5820, 15, 0x01 },\n\t{ PROC_THERMAL_MMIO_INT_ENABLE_1, 0x5820, 23, 0x01 },\n\t{ PROC_THERMAL_MMIO_INT_STATUS_0, 0x7200, 6, 0x01 },\n\t{ PROC_THERMAL_MMIO_INT_STATUS_1, 0x7200, 8, 0x01 },\n};\n\n#define B0D4_THERMAL_NOTIFY_DELAY\t1000\nstatic int notify_delay_ms = B0D4_THERMAL_NOTIFY_DELAY;\n\nstatic void proc_thermal_mmio_read(struct proc_thermal_pci *pci_info,\n\t\t\t\t    enum proc_thermal_mmio_type type,\n\t\t\t\t    u32 *value)\n{\n\t*value = ioread32(((u8 __iomem *)pci_info->proc_priv->mmio_base +\n\t\t\t\tproc_thermal_mmio_info[type].mmio_addr));\n\t*value >>= proc_thermal_mmio_info[type].shift;\n\t*value &= proc_thermal_mmio_info[type].mask;\n}\n\nstatic void proc_thermal_mmio_write(struct proc_thermal_pci *pci_info,\n\t\t\t\t     enum proc_thermal_mmio_type type,\n\t\t\t\t     u32 value)\n{\n\tu32 current_val;\n\tu32 mask;\n\n\tcurrent_val = ioread32(((u8 __iomem *)pci_info->proc_priv->mmio_base +\n\t\t\t\tproc_thermal_mmio_info[type].mmio_addr));\n\tmask = proc_thermal_mmio_info[type].mask << proc_thermal_mmio_info[type].shift;\n\tcurrent_val &= ~mask;\n\n\tvalue &= proc_thermal_mmio_info[type].mask;\n\tvalue <<= proc_thermal_mmio_info[type].shift;\n\n\tcurrent_val |= value;\n\tiowrite32(current_val, ((u8 __iomem *)pci_info->proc_priv->mmio_base +\n\t\t\t\tproc_thermal_mmio_info[type].mmio_addr));\n}\n\n \nstatic void proc_thermal_threshold_work_fn(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct proc_thermal_pci *pci_info = container_of(delayed_work,\n\t\t\t\t\t\tstruct proc_thermal_pci, work);\n\tstruct thermal_zone_device *tzone = pci_info->tzone;\n\n\tif (tzone)\n\t\tthermal_zone_device_update(tzone, THERMAL_TRIP_VIOLATED);\n\n\t \n\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_INT_ENABLE_0, 1);\n}\n\nstatic void pkg_thermal_schedule_work(struct delayed_work *work)\n{\n\tunsigned long ms = msecs_to_jiffies(notify_delay_ms);\n\n\tschedule_delayed_work(work, ms);\n}\n\nstatic irqreturn_t proc_thermal_irq_handler(int irq, void *devid)\n{\n\tstruct proc_thermal_pci *pci_info = devid;\n\tu32 status;\n\n\tproc_thermal_mmio_read(pci_info, PROC_THERMAL_MMIO_INT_STATUS_0, &status);\n\n\t \n\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_INT_ENABLE_0, 0);\n\tpci_write_config_byte(pci_info->pdev, 0xdc, 0x01);\n\n\tpkg_thermal_schedule_work(&pci_info->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd, int *temp)\n{\n\tstruct proc_thermal_pci *pci_info = thermal_zone_device_priv(tzd);\n\tu32 _temp;\n\n\tproc_thermal_mmio_read(pci_info, PROC_THERMAL_MMIO_PKG_TEMP, &_temp);\n\t*temp = (unsigned long)_temp * 1000;\n\n\treturn 0;\n}\n\nstatic int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip, int temp)\n{\n\tstruct proc_thermal_pci *pci_info = thermal_zone_device_priv(tzd);\n\tint tjmax, _temp;\n\n\tif (temp <= 0) {\n\t\tcancel_delayed_work_sync(&pci_info->work);\n\t\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_INT_ENABLE_0, 0);\n\t\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_THRES_0, 0);\n\t\tpci_info->stored_thres = 0;\n\t\treturn 0;\n\t}\n\n\tproc_thermal_mmio_read(pci_info, PROC_THERMAL_MMIO_TJMAX, &tjmax);\n\t_temp = tjmax - (temp / 1000);\n\tif (_temp < 0)\n\t\treturn -EINVAL;\n\n\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_THRES_0, _temp);\n\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_INT_ENABLE_0, 1);\n\n\tpci_info->stored_thres = temp;\n\n\treturn 0;\n}\n\nstatic int get_trip_temp(struct proc_thermal_pci *pci_info)\n{\n\tint temp, tjmax;\n\n\tproc_thermal_mmio_read(pci_info, PROC_THERMAL_MMIO_THRES_0, &temp);\n\tif (!temp)\n\t\treturn THERMAL_TEMP_INVALID;\n\n\tproc_thermal_mmio_read(pci_info, PROC_THERMAL_MMIO_TJMAX, &tjmax);\n\ttemp = (tjmax - temp) * 1000;\n\n\treturn temp;\n}\n\nstatic struct thermal_trip psv_trip = {\n\t.type = THERMAL_TRIP_PASSIVE,\n};\n\nstatic struct thermal_zone_device_ops tzone_ops = {\n\t.get_temp = sys_get_curr_temp,\n\t.set_trip_temp\t= sys_set_trip_temp,\n};\n\nstatic struct thermal_zone_params tzone_params = {\n\t.governor_name = \"user_space\",\n\t.no_hwmon = true,\n};\n\nstatic int proc_thermal_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct proc_thermal_device *proc_priv;\n\tstruct proc_thermal_pci *pci_info;\n\tint irq_flag = 0, irq, ret;\n\n\tproc_priv = devm_kzalloc(&pdev->dev, sizeof(*proc_priv), GFP_KERNEL);\n\tif (!proc_priv)\n\t\treturn -ENOMEM;\n\n\tpci_info = devm_kzalloc(&pdev->dev, sizeof(*pci_info), GFP_KERNEL);\n\tif (!pci_info)\n\t\treturn -ENOMEM;\n\n\tpci_info->pdev = pdev;\n\tret = pcim_enable_device(pdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"error: could not enable device\\n\");\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\n\tINIT_DELAYED_WORK(&pci_info->work, proc_thermal_threshold_work_fn);\n\n\tret = proc_thermal_add(&pdev->dev, proc_priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"error: proc_thermal_add, will continue\\n\");\n\t\tpci_info->no_legacy = 1;\n\t}\n\n\tproc_priv->priv_data = pci_info;\n\tpci_info->proc_priv = proc_priv;\n\tpci_set_drvdata(pdev, proc_priv);\n\n\tret = proc_thermal_mmio_add(pdev, proc_priv, id->driver_data);\n\tif (ret)\n\t\tgoto err_ret_thermal;\n\n\tpsv_trip.temperature = get_trip_temp(pci_info);\n\n\tpci_info->tzone = thermal_zone_device_register_with_trips(\"TCPU_PCI\", &psv_trip,\n\t\t\t\t\t\t\t1, 1, pci_info,\n\t\t\t\t\t\t\t&tzone_ops,\n\t\t\t\t\t\t\t&tzone_params, 0, 0);\n\tif (IS_ERR(pci_info->tzone)) {\n\t\tret = PTR_ERR(pci_info->tzone);\n\t\tgoto err_ret_mmio;\n\t}\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate vectors!\\n\");\n\t\tgoto err_ret_tzone;\n\t}\n\tif (!pdev->msi_enabled && !pdev->msix_enabled)\n\t\tirq_flag = IRQF_SHARED;\n\n\tirq =  pci_irq_vector(pdev, 0);\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\tproc_thermal_irq_handler, NULL,\n\t\t\t\t\tirq_flag, KBUILD_MODNAME, pci_info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Request IRQ %d failed\\n\", pdev->irq);\n\t\tgoto err_free_vectors;\n\t}\n\n\tret = thermal_zone_device_enable(pci_info->tzone);\n\tif (ret)\n\t\tgoto err_free_vectors;\n\n\treturn 0;\n\nerr_free_vectors:\n\tpci_free_irq_vectors(pdev);\nerr_ret_tzone:\n\tthermal_zone_device_unregister(pci_info->tzone);\nerr_ret_mmio:\n\tproc_thermal_mmio_remove(pdev, proc_priv);\nerr_ret_thermal:\n\tif (!pci_info->no_legacy)\n\t\tproc_thermal_remove(proc_priv);\n\tpci_disable_device(pdev);\n\n\treturn ret;\n}\n\nstatic void proc_thermal_pci_remove(struct pci_dev *pdev)\n{\n\tstruct proc_thermal_device *proc_priv = pci_get_drvdata(pdev);\n\tstruct proc_thermal_pci *pci_info = proc_priv->priv_data;\n\n\tcancel_delayed_work_sync(&pci_info->work);\n\n\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_THRES_0, 0);\n\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_INT_ENABLE_0, 0);\n\n\tdevm_free_irq(&pdev->dev, pdev->irq, pci_info);\n\tpci_free_irq_vectors(pdev);\n\n\tthermal_zone_device_unregister(pci_info->tzone);\n\tproc_thermal_mmio_remove(pdev, pci_info->proc_priv);\n\tif (!pci_info->no_legacy)\n\t\tproc_thermal_remove(proc_priv);\n\tpci_disable_device(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int proc_thermal_pci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct proc_thermal_device *proc_priv;\n\tstruct proc_thermal_pci *pci_info;\n\n\tproc_priv = pci_get_drvdata(pdev);\n\tpci_info = proc_priv->priv_data;\n\n\tif (!pci_info->no_legacy)\n\t\treturn proc_thermal_suspend(dev);\n\n\treturn 0;\n}\nstatic int proc_thermal_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct proc_thermal_device *proc_priv;\n\tstruct proc_thermal_pci *pci_info;\n\n\tproc_priv = pci_get_drvdata(pdev);\n\tpci_info = proc_priv->priv_data;\n\n\tif (pci_info->stored_thres) {\n\t\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_THRES_0,\n\t\t\t\t\t pci_info->stored_thres / 1000);\n\t\tproc_thermal_mmio_write(pci_info, PROC_THERMAL_MMIO_INT_ENABLE_0, 1);\n\t}\n\n\tif (!pci_info->no_legacy)\n\t\treturn proc_thermal_resume(dev);\n\n\treturn 0;\n}\n#else\n#define proc_thermal_pci_suspend NULL\n#define proc_thermal_pci_resume NULL\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(proc_thermal_pci_pm, proc_thermal_pci_suspend,\n\t\t\t proc_thermal_pci_resume);\n\nstatic const struct pci_device_id proc_thermal_pci_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, ADL_THERMAL, PROC_THERMAL_FEATURE_RAPL | PROC_THERMAL_FEATURE_FIVR | PROC_THERMAL_FEATURE_DVFS | PROC_THERMAL_FEATURE_MBOX) },\n\t{ PCI_DEVICE_DATA(INTEL, MTLP_THERMAL, PROC_THERMAL_FEATURE_RAPL | PROC_THERMAL_FEATURE_FIVR | PROC_THERMAL_FEATURE_DVFS | PROC_THERMAL_FEATURE_MBOX | PROC_THERMAL_FEATURE_DLVR) },\n\t{ PCI_DEVICE_DATA(INTEL, RPL_THERMAL, PROC_THERMAL_FEATURE_RAPL | PROC_THERMAL_FEATURE_FIVR | PROC_THERMAL_FEATURE_DVFS | PROC_THERMAL_FEATURE_MBOX) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, proc_thermal_pci_ids);\n\nstatic struct pci_driver proc_thermal_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.probe\t\t= proc_thermal_pci_probe,\n\t.remove\t= proc_thermal_pci_remove,\n\t.id_table\t= proc_thermal_pci_ids,\n\t.driver.pm\t= &proc_thermal_pci_pm,\n};\n\nmodule_pci_driver(proc_thermal_pci_driver);\n\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Processor Thermal Reporting Device Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}