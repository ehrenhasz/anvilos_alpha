{
  "module_name": "int3400_thermal.c",
  "hash_id": "281e280c224be89c4fbba8ad7da5b38f9d5d8bad7a357e03d7dd9fc6285f6e27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/int3400_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <linux/thermal.h>\n#include \"acpi_thermal_rel.h\"\n\n#define INT3400_THERMAL_TABLE_CHANGED 0x83\n#define INT3400_ODVP_CHANGED 0x88\n#define INT3400_KEEP_ALIVE 0xA0\n#define INT3400_FAKE_TEMP (20 * 1000)  \n\nenum int3400_thermal_uuid {\n\tINT3400_THERMAL_ACTIVE = 0,\n\tINT3400_THERMAL_PASSIVE_1,\n\tINT3400_THERMAL_CRITICAL,\n\tINT3400_THERMAL_ADAPTIVE_PERFORMANCE,\n\tINT3400_THERMAL_EMERGENCY_CALL_MODE,\n\tINT3400_THERMAL_PASSIVE_2,\n\tINT3400_THERMAL_POWER_BOSS,\n\tINT3400_THERMAL_VIRTUAL_SENSOR,\n\tINT3400_THERMAL_COOLING_MODE,\n\tINT3400_THERMAL_HARDWARE_DUTY_CYCLING,\n\tINT3400_THERMAL_MAXIMUM_UUID,\n};\n\nstatic char *int3400_thermal_uuids[INT3400_THERMAL_MAXIMUM_UUID] = {\n\t\"3A95C389-E4B8-4629-A526-C52C88626BAE\",\n\t\"42A441D6-AE6A-462b-A84B-4A8CE79027D3\",\n\t\"97C68AE7-15FA-499c-B8C9-5DA81D606E0A\",\n\t\"63BE270F-1C11-48FD-A6F7-3AF253FF3E2D\",\n\t\"5349962F-71E6-431D-9AE8-0A635B710AEE\",\n\t\"9E04115A-AE87-4D1C-9500-0F3E340BFE75\",\n\t\"F5A35014-C209-46A4-993A-EB56DE7530A1\",\n\t\"6ED722A7-9240-48A5-B479-31EEF723D7CF\",\n\t\"16CAF1B7-DD38-40ED-B1C1-1B8A1913D531\",\n\t\"BE84BABF-C4D4-403D-B495-3128FD44dAC1\",\n};\n\nstruct odvp_attr;\n\nstruct int3400_thermal_priv {\n\tstruct acpi_device *adev;\n\tstruct platform_device *pdev;\n\tstruct thermal_zone_device *thermal;\n\tint art_count;\n\tstruct art *arts;\n\tint trt_count;\n\tstruct trt *trts;\n\tu32 uuid_bitmap;\n\tint rel_misc_dev_res;\n\tint current_uuid_index;\n\tchar *data_vault;\n\tint odvp_count;\n\tint *odvp;\n\tu32 os_uuid_mask;\n\tint production_mode;\n\tstruct odvp_attr *odvp_attrs;\n};\n\nstatic int evaluate_odvp(struct int3400_thermal_priv *priv);\n\nstruct odvp_attr {\n\tint odvp;\n\tstruct int3400_thermal_priv *priv;\n\tstruct device_attribute attr;\n};\n\nstatic ssize_t data_vault_read(struct file *file, struct kobject *kobj,\n\t     struct bin_attribute *attr, char *buf, loff_t off, size_t count)\n{\n\tmemcpy(buf, attr->private + off, count);\n\treturn count;\n}\n\nstatic BIN_ATTR_RO(data_vault, 0);\n\nstatic struct bin_attribute *data_attributes[] = {\n\t&bin_attr_data_vault,\n\tNULL,\n};\n\nstatic ssize_t imok_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct int3400_thermal_priv *priv = dev_get_drvdata(dev);\n\tacpi_status status;\n\tint input, ret;\n\n\tret = kstrtouint(buf, 10, &input);\n\tif (ret)\n\t\treturn ret;\n\tstatus = acpi_execute_simple_method(priv->adev->handle, \"IMOK\", input);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(imok);\n\nstatic struct attribute *imok_attr[] = {\n\t&dev_attr_imok.attr,\n\tNULL\n};\n\nstatic const struct attribute_group imok_attribute_group = {\n\t.attrs = imok_attr,\n};\n\nstatic const struct attribute_group data_attribute_group = {\n\t.bin_attrs = data_attributes,\n};\n\nstatic ssize_t available_uuids_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct int3400_thermal_priv *priv = dev_get_drvdata(dev);\n\tint i;\n\tint length = 0;\n\n\tif (!priv->uuid_bitmap)\n\t\treturn sprintf(buf, \"UNKNOWN\\n\");\n\n\tfor (i = 0; i < INT3400_THERMAL_MAXIMUM_UUID; i++) {\n\t\tif (priv->uuid_bitmap & (1 << i))\n\t\t\tlength += sysfs_emit_at(buf, length, \"%s\\n\", int3400_thermal_uuids[i]);\n\t}\n\n\treturn length;\n}\n\nstatic ssize_t current_uuid_show(struct device *dev,\n\t\t\t\t struct device_attribute *devattr, char *buf)\n{\n\tstruct int3400_thermal_priv *priv = dev_get_drvdata(dev);\n\tint i, length = 0;\n\n\tif (priv->current_uuid_index > 0)\n\t\treturn sprintf(buf, \"%s\\n\",\n\t\t\t       int3400_thermal_uuids[priv->current_uuid_index]);\n\n\tfor (i = 0; i <= INT3400_THERMAL_CRITICAL; i++) {\n\t\tif (priv->os_uuid_mask & BIT(i))\n\t\t\tlength += sysfs_emit_at(buf, length, \"%s\\n\", int3400_thermal_uuids[i]);\n\t}\n\n\tif (length)\n\t\treturn length;\n\n\treturn sprintf(buf, \"INVALID\\n\");\n}\n\nstatic int int3400_thermal_run_osc(acpi_handle handle, char *uuid_str, int *enable)\n{\n\tu32 ret, buf[2];\n\tacpi_status status;\n\tint result = 0;\n\tstruct acpi_osc_context context = {\n\t\t.uuid_str = uuid_str,\n\t\t.rev = 1,\n\t\t.cap.length = 8,\n\t\t.cap.pointer = buf,\n\t};\n\n\tbuf[OSC_QUERY_DWORD] = 0;\n\tbuf[OSC_SUPPORT_DWORD] = *enable;\n\n\tstatus = acpi_run_osc(handle, &context);\n\tif (ACPI_SUCCESS(status)) {\n\t\tret = *((u32 *)(context.ret.pointer + 4));\n\t\tif (ret != *enable)\n\t\t\tresult = -EPERM;\n\n\t\tkfree(context.ret.pointer);\n\t} else\n\t\tresult = -EPERM;\n\n\treturn result;\n}\n\nstatic int set_os_uuid_mask(struct int3400_thermal_priv *priv, u32 mask)\n{\n\tint cap = 0;\n\n\t \n\tif (mask)\n\t\tcap = (priv->os_uuid_mask << 1) | 0x01;\n\n\treturn int3400_thermal_run_osc(priv->adev->handle,\n\t\t\t\t       \"b23ba85d-c8b7-3542-88de-8de2ffcfd698\",\n\t\t\t\t       &cap);\n}\n\nstatic ssize_t current_uuid_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct int3400_thermal_priv *priv = dev_get_drvdata(dev);\n\tint ret, i;\n\n\tfor (i = 0; i < INT3400_THERMAL_MAXIMUM_UUID; ++i) {\n\t\tif (!strncmp(buf, int3400_thermal_uuids[i],\n\t\t\t     sizeof(int3400_thermal_uuids[i]) - 1)) {\n\t\t\t \n\t\t\tif (priv->uuid_bitmap & BIT(i)) {\n\t\t\t\tpriv->current_uuid_index = i;\n\t\t\t\treturn count;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (i > INT3400_THERMAL_CRITICAL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tpriv->os_uuid_mask |= BIT(i);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (priv->os_uuid_mask) {\n\t\tret = set_os_uuid_mask(priv, priv->os_uuid_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(current_uuid);\nstatic DEVICE_ATTR_RO(available_uuids);\nstatic struct attribute *uuid_attrs[] = {\n\t&dev_attr_available_uuids.attr,\n\t&dev_attr_current_uuid.attr,\n\tNULL\n};\n\nstatic const struct attribute_group uuid_attribute_group = {\n\t.attrs = uuid_attrs,\n\t.name = \"uuids\"\n};\n\nstatic int int3400_thermal_get_uuids(struct int3400_thermal_priv *priv)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *obja, *objb;\n\tint i, j;\n\tint result = 0;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(priv->adev->handle, \"IDSP\", NULL, &buf);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tobja = (union acpi_object *)buf.pointer;\n\tif (obja->type != ACPI_TYPE_PACKAGE) {\n\t\tresult = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < obja->package.count; i++) {\n\t\tobjb = &obja->package.elements[i];\n\t\tif (objb->type != ACPI_TYPE_BUFFER) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\n\t\t \n\t\tif (objb->buffer.length != 16) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor (j = 0; j < INT3400_THERMAL_MAXIMUM_UUID; j++) {\n\t\t\tguid_t guid;\n\n\t\t\tguid_parse(int3400_thermal_uuids[j], &guid);\n\t\t\tif (guid_equal((guid_t *)objb->buffer.pointer, &guid)) {\n\t\t\t\tpriv->uuid_bitmap |= (1 << j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\tkfree(buf.pointer);\n\treturn result;\n}\n\nstatic ssize_t production_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct int3400_thermal_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->production_mode);\n}\n\nstatic DEVICE_ATTR_RO(production_mode);\n\nstatic int production_mode_init(struct int3400_thermal_priv *priv)\n{\n\tunsigned long long mode;\n\tacpi_status status;\n\tint ret;\n\n\tpriv->production_mode = -1;\n\n\tstatus = acpi_evaluate_integer(priv->adev->handle, \"DCFG\", NULL, &mode);\n\t \n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\tret = sysfs_create_file(&priv->pdev->dev.kobj, &dev_attr_production_mode.attr);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->production_mode = mode;\n\n\treturn 0;\n}\n\nstatic void production_mode_exit(struct int3400_thermal_priv *priv)\n{\n\tif (priv->production_mode >= 0)\n\t\tsysfs_remove_file(&priv->pdev->dev.kobj, &dev_attr_production_mode.attr);\n}\n\nstatic ssize_t odvp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct odvp_attr *odvp_attr;\n\n\todvp_attr = container_of(attr, struct odvp_attr, attr);\n\n\treturn sprintf(buf, \"%d\\n\", odvp_attr->priv->odvp[odvp_attr->odvp]);\n}\n\nstatic void cleanup_odvp(struct int3400_thermal_priv *priv)\n{\n\tint i;\n\n\tif (priv->odvp_attrs) {\n\t\tfor (i = 0; i < priv->odvp_count; i++) {\n\t\t\tsysfs_remove_file(&priv->pdev->dev.kobj,\n\t\t\t\t\t  &priv->odvp_attrs[i].attr.attr);\n\t\t\tkfree(priv->odvp_attrs[i].attr.attr.name);\n\t\t}\n\t\tkfree(priv->odvp_attrs);\n\t}\n\tkfree(priv->odvp);\n\tpriv->odvp_count = 0;\n}\n\nstatic int evaluate_odvp(struct int3400_thermal_priv *priv)\n{\n\tstruct acpi_buffer odvp = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj = NULL;\n\tacpi_status status;\n\tint i, ret;\n\n\tstatus = acpi_evaluate_object(priv->adev->handle, \"ODVP\", NULL, &odvp);\n\tif (ACPI_FAILURE(status)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tobj = odvp.pointer;\n\tif (obj->type != ACPI_TYPE_PACKAGE) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (priv->odvp == NULL) {\n\t\tpriv->odvp_count = obj->package.count;\n\t\tpriv->odvp = kmalloc_array(priv->odvp_count, sizeof(int),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!priv->odvp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (priv->odvp_attrs == NULL) {\n\t\tpriv->odvp_attrs = kcalloc(priv->odvp_count,\n\t\t\t\t\t   sizeof(struct odvp_attr),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!priv->odvp_attrs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tfor (i = 0; i < priv->odvp_count; i++) {\n\t\t\tstruct odvp_attr *odvp = &priv->odvp_attrs[i];\n\n\t\t\tsysfs_attr_init(&odvp->attr.attr);\n\t\t\todvp->priv = priv;\n\t\t\todvp->odvp = i;\n\t\t\todvp->attr.attr.name = kasprintf(GFP_KERNEL,\n\t\t\t\t\t\t\t \"odvp%d\", i);\n\n\t\t\tif (!odvp->attr.attr.name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\todvp->attr.attr.mode = 0444;\n\t\t\todvp->attr.show = odvp_show;\n\t\t\todvp->attr.store = NULL;\n\t\t\tret = sysfs_create_file(&priv->pdev->dev.kobj,\n\t\t\t\t\t\t&odvp->attr.attr);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < obj->package.count; i++) {\n\t\tif (obj->package.elements[i].type == ACPI_TYPE_INTEGER)\n\t\t\tpriv->odvp[i] = obj->package.elements[i].integer.value;\n\t}\n\n\tkfree(obj);\n\treturn 0;\n\nout_err:\n\tcleanup_odvp(priv);\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic void int3400_notify(acpi_handle handle,\n\t\t\tu32 event,\n\t\t\tvoid *data)\n{\n\tstruct int3400_thermal_priv *priv = data;\n\tstruct device *dev;\n\tchar *thermal_prop[5];\n\tint therm_event;\n\n\tif (!priv)\n\t\treturn;\n\n\tswitch (event) {\n\tcase INT3400_THERMAL_TABLE_CHANGED:\n\t\ttherm_event = THERMAL_TABLE_CHANGED;\n\t\tbreak;\n\tcase INT3400_KEEP_ALIVE:\n\t\ttherm_event = THERMAL_EVENT_KEEP_ALIVE;\n\t\tbreak;\n\tcase INT3400_ODVP_CHANGED:\n\t\tevaluate_odvp(priv);\n\t\ttherm_event = THERMAL_DEVICE_POWER_CAPABILITY_CHANGED;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\tdev = thermal_zone_device(priv->thermal);\n\n\tthermal_prop[0] = kasprintf(GFP_KERNEL, \"NAME=%s\", thermal_zone_device_type(priv->thermal));\n\tthermal_prop[1] = kasprintf(GFP_KERNEL, \"TEMP=%d\", INT3400_FAKE_TEMP);\n\tthermal_prop[2] = kasprintf(GFP_KERNEL, \"TRIP=\");\n\tthermal_prop[3] = kasprintf(GFP_KERNEL, \"EVENT=%d\", therm_event);\n\tthermal_prop[4] = NULL;\n\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, thermal_prop);\n\tkfree(thermal_prop[0]);\n\tkfree(thermal_prop[1]);\n\tkfree(thermal_prop[2]);\n\tkfree(thermal_prop[3]);\n}\n\nstatic int int3400_thermal_get_temp(struct thermal_zone_device *thermal,\n\t\t\tint *temp)\n{\n\t*temp = INT3400_FAKE_TEMP;\n\treturn 0;\n}\n\nstatic int int3400_thermal_change_mode(struct thermal_zone_device *thermal,\n\t\t\t\t       enum thermal_device_mode mode)\n{\n\tstruct int3400_thermal_priv *priv = thermal_zone_device_priv(thermal);\n\tint result = 0;\n\tint enabled;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tenabled = mode == THERMAL_DEVICE_ENABLED;\n\n\tif (priv->os_uuid_mask) {\n\t\tif (!enabled) {\n\t\t\tpriv->os_uuid_mask = 0;\n\t\t\tresult = set_os_uuid_mask(priv, priv->os_uuid_mask);\n\t\t}\n\t\tgoto eval_odvp;\n\t}\n\n\tif (priv->current_uuid_index < 0 ||\n\t    priv->current_uuid_index >= INT3400_THERMAL_MAXIMUM_UUID)\n\t\treturn -EINVAL;\n\n\tresult = int3400_thermal_run_osc(priv->adev->handle,\n\t\t\t\t\t int3400_thermal_uuids[priv->current_uuid_index],\n\t\t\t\t\t &enabled);\neval_odvp:\n\tevaluate_odvp(priv);\n\n\treturn result;\n}\n\nstatic struct thermal_zone_device_ops int3400_thermal_ops = {\n\t.get_temp = int3400_thermal_get_temp,\n\t.change_mode = int3400_thermal_change_mode,\n};\n\nstatic struct thermal_zone_params int3400_thermal_params = {\n\t.governor_name = \"user_space\",\n\t.no_hwmon = true,\n};\n\nstatic void int3400_setup_gddv(struct int3400_thermal_priv *priv)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(priv->adev->handle, \"GDDV\", NULL,\n\t\t\t\t      &buffer);\n\tif (ACPI_FAILURE(status) || !buffer.length)\n\t\treturn;\n\n\tobj = buffer.pointer;\n\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count != 1\n\t    || obj->package.elements[0].type != ACPI_TYPE_BUFFER)\n\t\tgoto out_free;\n\n\tpriv->data_vault = kmemdup(obj->package.elements[0].buffer.pointer,\n\t\t\t\t   obj->package.elements[0].buffer.length,\n\t\t\t\t   GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(priv->data_vault))\n\t\tgoto out_free;\n\n\tbin_attr_data_vault.private = priv->data_vault;\n\tbin_attr_data_vault.size = obj->package.elements[0].buffer.length;\nout_free:\n\tkfree(buffer.pointer);\n}\n\nstatic int int3400_thermal_probe(struct platform_device *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tstruct int3400_thermal_priv *priv;\n\tint result;\n\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tpriv = kzalloc(sizeof(struct int3400_thermal_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdev = pdev;\n\tpriv->adev = adev;\n\n\tresult = int3400_thermal_get_uuids(priv);\n\n\t \n\tif (result && result != -ENODEV)\n\t\tgoto free_priv;\n\n\tpriv->current_uuid_index = -1;\n\n\tresult = acpi_parse_art(priv->adev->handle, &priv->art_count,\n\t\t\t\t&priv->arts, true);\n\tif (result)\n\t\tdev_dbg(&pdev->dev, \"_ART table parsing error\\n\");\n\n\tresult = acpi_parse_trt(priv->adev->handle, &priv->trt_count,\n\t\t\t\t&priv->trts, true);\n\tif (result)\n\t\tdev_dbg(&pdev->dev, \"_TRT table parsing error\\n\");\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tint3400_setup_gddv(priv);\n\n\tevaluate_odvp(priv);\n\n\tpriv->thermal = thermal_tripless_zone_device_register(\"INT3400 Thermal\", priv,\n\t\t\t\t\t\t\t      &int3400_thermal_ops,\n\t\t\t\t\t\t\t      &int3400_thermal_params);\n\tif (IS_ERR(priv->thermal)) {\n\t\tresult = PTR_ERR(priv->thermal);\n\t\tgoto free_art_trt;\n\t}\n\n\tpriv->rel_misc_dev_res = acpi_thermal_rel_misc_device_add(\n\t\t\t\t\t\t\tpriv->adev->handle);\n\n\tresult = sysfs_create_group(&pdev->dev.kobj, &uuid_attribute_group);\n\tif (result)\n\t\tgoto free_rel_misc;\n\n\tif (acpi_has_method(priv->adev->handle, \"IMOK\")) {\n\t\tresult = sysfs_create_group(&pdev->dev.kobj, &imok_attribute_group);\n\t\tif (result)\n\t\t\tgoto free_imok;\n\t}\n\n\tif (!ZERO_OR_NULL_PTR(priv->data_vault)) {\n\t\tresult = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t\t    &data_attribute_group);\n\t\tif (result)\n\t\t\tgoto free_uuid;\n\t}\n\n\tresult = acpi_install_notify_handler(\n\t\t\tpriv->adev->handle, ACPI_DEVICE_NOTIFY, int3400_notify,\n\t\t\t(void *)priv);\n\tif (result)\n\t\tgoto free_sysfs;\n\n\tresult = production_mode_init(priv);\n\tif (result)\n\t\tgoto free_notify;\n\n\treturn 0;\n\nfree_notify:\n\tacpi_remove_notify_handler(priv->adev->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t   int3400_notify);\nfree_sysfs:\n\tcleanup_odvp(priv);\n\tif (!ZERO_OR_NULL_PTR(priv->data_vault)) {\n\t\tsysfs_remove_group(&pdev->dev.kobj, &data_attribute_group);\n\t\tkfree(priv->data_vault);\n\t}\nfree_uuid:\n\tsysfs_remove_group(&pdev->dev.kobj, &uuid_attribute_group);\nfree_imok:\n\tsysfs_remove_group(&pdev->dev.kobj, &imok_attribute_group);\nfree_rel_misc:\n\tif (!priv->rel_misc_dev_res)\n\t\tacpi_thermal_rel_misc_device_remove(priv->adev->handle);\n\tthermal_zone_device_unregister(priv->thermal);\nfree_art_trt:\n\tkfree(priv->trts);\n\tkfree(priv->arts);\nfree_priv:\n\tkfree(priv);\n\treturn result;\n}\n\nstatic int int3400_thermal_remove(struct platform_device *pdev)\n{\n\tstruct int3400_thermal_priv *priv = platform_get_drvdata(pdev);\n\n\tproduction_mode_exit(priv);\n\n\tacpi_remove_notify_handler(\n\t\t\tpriv->adev->handle, ACPI_DEVICE_NOTIFY,\n\t\t\tint3400_notify);\n\n\tcleanup_odvp(priv);\n\n\tif (!priv->rel_misc_dev_res)\n\t\tacpi_thermal_rel_misc_device_remove(priv->adev->handle);\n\n\tif (!ZERO_OR_NULL_PTR(priv->data_vault))\n\t\tsysfs_remove_group(&pdev->dev.kobj, &data_attribute_group);\n\tsysfs_remove_group(&pdev->dev.kobj, &uuid_attribute_group);\n\tsysfs_remove_group(&pdev->dev.kobj, &imok_attribute_group);\n\tthermal_zone_device_unregister(priv->thermal);\n\tkfree(priv->data_vault);\n\tkfree(priv->trts);\n\tkfree(priv->arts);\n\tkfree(priv);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id int3400_thermal_match[] = {\n\t{\"INT3400\", 0},\n\t{\"INTC1040\", 0},\n\t{\"INTC1041\", 0},\n\t{\"INTC1042\", 0},\n\t{\"INTC10A0\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, int3400_thermal_match);\n\nstatic struct platform_driver int3400_thermal_driver = {\n\t.probe = int3400_thermal_probe,\n\t.remove = int3400_thermal_remove,\n\t.driver = {\n\t\t   .name = \"int3400 thermal\",\n\t\t   .acpi_match_table = ACPI_PTR(int3400_thermal_match),\n\t\t   },\n};\n\nmodule_platform_driver(int3400_thermal_driver);\n\nMODULE_DESCRIPTION(\"INT3400 Thermal driver\");\nMODULE_AUTHOR(\"Zhang Rui <rui.zhang@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}