{
  "module_name": "processor_thermal_mbox.c",
  "hash_id": "f12d662958ca3e7bacbf11cf3f1cd96888fafa247fa64de5d924ad3226863e11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/processor_thermal_mbox.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include \"processor_thermal_device.h\"\n\n#define MBOX_CMD_WORKLOAD_TYPE_READ\t0x0E\n#define MBOX_CMD_WORKLOAD_TYPE_WRITE\t0x0F\n\n#define MBOX_OFFSET_DATA\t\t0x5810\n#define MBOX_OFFSET_INTERFACE\t\t0x5818\n\n#define MBOX_BUSY_BIT\t\t\t31\n#define MBOX_RETRY_COUNT\t\t100\n\n#define MBOX_DATA_BIT_VALID\t\t31\n#define MBOX_DATA_BIT_AC_DC\t\t30\n\nstatic DEFINE_MUTEX(mbox_lock);\n\nstatic int wait_for_mbox_ready(struct proc_thermal_device *proc_priv)\n{\n\tu32 retries, data;\n\tint ret;\n\n\t \n\tretries = MBOX_RETRY_COUNT;\n\tdo {\n\t\tdata = readl(proc_priv->mmio_base + MBOX_OFFSET_INTERFACE);\n\t\tif (data & BIT_ULL(MBOX_BUSY_BIT)) {\n\t\t\tret = -EBUSY;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\t} while (--retries);\n\n\treturn ret;\n}\n\nstatic int send_mbox_write_cmd(struct pci_dev *pdev, u16 id, u32 data)\n{\n\tstruct proc_thermal_device *proc_priv;\n\tu32 reg_data;\n\tint ret;\n\n\tproc_priv = pci_get_drvdata(pdev);\n\n\tmutex_lock(&mbox_lock);\n\n\tret = wait_for_mbox_ready(proc_priv);\n\tif (ret)\n\t\tgoto unlock_mbox;\n\n\twritel(data, (proc_priv->mmio_base + MBOX_OFFSET_DATA));\n\t \n\treg_data = BIT_ULL(MBOX_BUSY_BIT) | id;\n\twritel(reg_data, (proc_priv->mmio_base + MBOX_OFFSET_INTERFACE));\n\n\tret = wait_for_mbox_ready(proc_priv);\n\nunlock_mbox:\n\tmutex_unlock(&mbox_lock);\n\treturn ret;\n}\n\nstatic int send_mbox_read_cmd(struct pci_dev *pdev, u16 id, u64 *resp)\n{\n\tstruct proc_thermal_device *proc_priv;\n\tu32 reg_data;\n\tint ret;\n\n\tproc_priv = pci_get_drvdata(pdev);\n\n\tmutex_lock(&mbox_lock);\n\n\tret = wait_for_mbox_ready(proc_priv);\n\tif (ret)\n\t\tgoto unlock_mbox;\n\n\t \n\treg_data = BIT_ULL(MBOX_BUSY_BIT) | id;\n\twritel(reg_data, (proc_priv->mmio_base + MBOX_OFFSET_INTERFACE));\n\n\tret = wait_for_mbox_ready(proc_priv);\n\tif (ret)\n\t\tgoto unlock_mbox;\n\n\tif (id == MBOX_CMD_WORKLOAD_TYPE_READ)\n\t\t*resp = readl(proc_priv->mmio_base + MBOX_OFFSET_DATA);\n\telse\n\t\t*resp = readq(proc_priv->mmio_base + MBOX_OFFSET_DATA);\n\nunlock_mbox:\n\tmutex_unlock(&mbox_lock);\n\treturn ret;\n}\n\nint processor_thermal_send_mbox_read_cmd(struct pci_dev *pdev, u16 id, u64 *resp)\n{\n\treturn send_mbox_read_cmd(pdev, id, resp);\n}\nEXPORT_SYMBOL_NS_GPL(processor_thermal_send_mbox_read_cmd, INT340X_THERMAL);\n\nint processor_thermal_send_mbox_write_cmd(struct pci_dev *pdev, u16 id, u32 data)\n{\n\treturn send_mbox_write_cmd(pdev, id, data);\n}\nEXPORT_SYMBOL_NS_GPL(processor_thermal_send_mbox_write_cmd, INT340X_THERMAL);\n\n \nstatic const char * const workload_types[] = {\n\t\"none\",\n\t\"idle\",\n\t\"semi_active\",\n\t\"bursty\",\n\t\"sustained\",\n\t\"battery_life\",\n\tNULL\n};\n\nstatic ssize_t workload_available_types_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tint i = 0;\n\tint ret = 0;\n\n\twhile (workload_types[i] != NULL)\n\t\tret += sprintf(&buf[ret], \"%s \", workload_types[i++]);\n\n\tret += sprintf(&buf[ret], \"\\n\");\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(workload_available_types);\n\nstatic ssize_t workload_type_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tchar str_preference[15];\n\tu32 data = 0;\n\tssize_t ret;\n\n\tret = sscanf(buf, \"%14s\", str_preference);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tret = match_string(workload_types, -1, str_preference);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= 0xff;\n\n\tif (ret)\n\t\tdata = BIT(MBOX_DATA_BIT_VALID) | BIT(MBOX_DATA_BIT_AC_DC);\n\n\tdata |= ret;\n\n\tret = send_mbox_write_cmd(pdev, MBOX_CMD_WORKLOAD_TYPE_WRITE, data);\n\tif (ret)\n\t\treturn false;\n\n\treturn count;\n}\n\nstatic ssize_t workload_type_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu64 cmd_resp;\n\tint ret;\n\n\tret = send_mbox_read_cmd(pdev, MBOX_CMD_WORKLOAD_TYPE_READ, &cmd_resp);\n\tif (ret)\n\t\treturn false;\n\n\tcmd_resp &= 0xff;\n\n\tif (cmd_resp > ARRAY_SIZE(workload_types) - 1)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%s\\n\", workload_types[cmd_resp]);\n}\n\nstatic DEVICE_ATTR_RW(workload_type);\n\nstatic struct attribute *workload_req_attrs[] = {\n\t&dev_attr_workload_available_types.attr,\n\t&dev_attr_workload_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group workload_req_attribute_group = {\n\t.attrs = workload_req_attrs,\n\t.name = \"workload_request\"\n};\n\nstatic bool workload_req_created;\n\nint proc_thermal_mbox_add(struct pci_dev *pdev, struct proc_thermal_device *proc_priv)\n{\n\tu64 cmd_resp;\n\tint ret;\n\n\t \n\tret = send_mbox_read_cmd(pdev, MBOX_CMD_WORKLOAD_TYPE_READ, &cmd_resp);\n\tif (ret)\n\t\treturn 0;\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &workload_req_attribute_group);\n\tif (ret)\n\t\treturn ret;\n\n\tworkload_req_created = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(proc_thermal_mbox_add);\n\nvoid proc_thermal_mbox_remove(struct pci_dev *pdev)\n{\n\tif (workload_req_created)\n\t\tsysfs_remove_group(&pdev->dev.kobj, &workload_req_attribute_group);\n\n\tworkload_req_created = false;\n\n}\nEXPORT_SYMBOL_GPL(proc_thermal_mbox_remove);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}