{
  "module_name": "acpi_thermal_rel.c",
  "hash_id": "cc5856c2f8af405d4a1f87c9b70eb5a888652a4647d4e2234672b3cb4a2864d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/int340x_thermal/acpi_thermal_rel.c",
  "human_readable_source": "\n \n\n \n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include \"acpi_thermal_rel.h\"\n\nstatic acpi_handle acpi_thermal_rel_handle;\nstatic DEFINE_SPINLOCK(acpi_thermal_rel_chrdev_lock);\nstatic int acpi_thermal_rel_chrdev_count;\t \nstatic int acpi_thermal_rel_chrdev_exclu;\t \n\nstatic int acpi_thermal_rel_open(struct inode *inode, struct file *file)\n{\n\tspin_lock(&acpi_thermal_rel_chrdev_lock);\n\tif (acpi_thermal_rel_chrdev_exclu ||\n\t    (acpi_thermal_rel_chrdev_count && (file->f_flags & O_EXCL))) {\n\t\tspin_unlock(&acpi_thermal_rel_chrdev_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (file->f_flags & O_EXCL)\n\t\tacpi_thermal_rel_chrdev_exclu = 1;\n\tacpi_thermal_rel_chrdev_count++;\n\n\tspin_unlock(&acpi_thermal_rel_chrdev_lock);\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int acpi_thermal_rel_release(struct inode *inode, struct file *file)\n{\n\tspin_lock(&acpi_thermal_rel_chrdev_lock);\n\tacpi_thermal_rel_chrdev_count--;\n\tacpi_thermal_rel_chrdev_exclu = 0;\n\tspin_unlock(&acpi_thermal_rel_chrdev_lock);\n\n\treturn 0;\n}\n\n \nint acpi_parse_trt(acpi_handle handle, int *trt_count, struct trt **trtp,\n\t\tbool create_dev)\n{\n\tacpi_status status;\n\tint result = 0;\n\tint i;\n\tint nr_bad_entries = 0;\n\tstruct trt *trts;\n\tunion acpi_object *p;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer element = { 0, NULL };\n\tstruct acpi_buffer trt_format = { sizeof(\"RRNNNNNN\"), \"RRNNNNNN\" };\n\n\tstatus = acpi_evaluate_object(handle, \"_TRT\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tp = buffer.pointer;\n\tif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\n\t\tpr_err(\"Invalid _TRT data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t*trt_count = p->package.count;\n\ttrts = kcalloc(*trt_count, sizeof(struct trt), GFP_KERNEL);\n\tif (!trts) {\n\t\tresult = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < *trt_count; i++) {\n\t\tstruct trt *trt = &trts[i - nr_bad_entries];\n\n\t\telement.length = sizeof(struct trt);\n\t\telement.pointer = trt;\n\n\t\tstatus = acpi_extract_package(&(p->package.elements[i]),\n\t\t\t\t\t      &trt_format, &element);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tnr_bad_entries++;\n\t\t\tpr_warn(\"_TRT package %d is invalid, ignored\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!create_dev)\n\t\t\tcontinue;\n\n\t\tif (!acpi_fetch_acpi_dev(trt->source))\n\t\t\tpr_warn(\"Failed to get source ACPI device\\n\");\n\n\t\tif (!acpi_fetch_acpi_dev(trt->target))\n\t\t\tpr_warn(\"Failed to get target ACPI device\\n\");\n\t}\n\n\tresult = 0;\n\n\t*trtp = trts;\n\t \n\t*trt_count -= nr_bad_entries;\nend:\n\tkfree(buffer.pointer);\n\treturn result;\n}\nEXPORT_SYMBOL(acpi_parse_trt);\n\n \nint acpi_parse_art(acpi_handle handle, int *art_count, struct art **artp,\n\t\tbool create_dev)\n{\n\tacpi_status status;\n\tint result = 0;\n\tint i;\n\tint nr_bad_entries = 0;\n\tstruct art *arts;\n\tunion acpi_object *p;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer element = { 0, NULL };\n\tstruct acpi_buffer art_format =\t{\n\t\tsizeof(\"RRNNNNNNNNNNN\"), \"RRNNNNNNNNNNN\" };\n\n\tstatus = acpi_evaluate_object(handle, \"_ART\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tp = buffer.pointer;\n\tif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\n\t\tpr_err(\"Invalid _ART data\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t \n\t*art_count = p->package.count - 1;\n\tarts = kcalloc(*art_count, sizeof(struct art), GFP_KERNEL);\n\tif (!arts) {\n\t\tresult = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < *art_count; i++) {\n\t\tstruct art *art = &arts[i - nr_bad_entries];\n\n\t\telement.length = sizeof(struct art);\n\t\telement.pointer = art;\n\n\t\tstatus = acpi_extract_package(&(p->package.elements[i + 1]),\n\t\t\t\t\t      &art_format, &element);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_warn(\"_ART package %d is invalid, ignored\", i);\n\t\t\tnr_bad_entries++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!create_dev)\n\t\t\tcontinue;\n\n\t\tif (!acpi_fetch_acpi_dev(art->source))\n\t\t\tpr_warn(\"Failed to get source ACPI device\\n\");\n\n\t\tif (!acpi_fetch_acpi_dev(art->target))\n\t\t\tpr_warn(\"Failed to get target ACPI device\\n\");\n\t}\n\n\t*artp = arts;\n\t \n\t*art_count -= nr_bad_entries;\nend:\n\tkfree(buffer.pointer);\n\treturn result;\n}\nEXPORT_SYMBOL(acpi_parse_art);\n\n \nstatic int acpi_parse_psvt(acpi_handle handle, int *psvt_count, struct psvt **psvtp)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tint nr_bad_entries = 0, revision = 0;\n\tunion acpi_object *p;\n\tacpi_status status;\n\tint i, result = 0;\n\tstruct psvt *psvts;\n\n\tif (!acpi_has_method(handle, \"PSVT\"))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_evaluate_object(handle, \"PSVT\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tp = buffer.pointer;\n\tif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t \n\tif (p->package.count > 0) {\n\t\tunion acpi_object *prev = &(p->package.elements[0]);\n\n\t\tif (prev->type == ACPI_TYPE_INTEGER)\n\t\t\trevision = (int)prev->integer.value;\n\t} else {\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t \n\tif (revision != 2) {\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\t*psvt_count = p->package.count - 1;\n\tif (!*psvt_count) {\n\t\tresult = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tpsvts = kcalloc(*psvt_count, sizeof(*psvts), GFP_KERNEL);\n\tif (!psvts) {\n\t\tresult = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\t \n\tfor (i = 1; i < p->package.count; i++) {\n\t\tstruct acpi_buffer psvt_int_format = { sizeof(\"RRNNNNNNNNNN\"), \"RRNNNNNNNNNN\" };\n\t\tstruct acpi_buffer psvt_str_format = { sizeof(\"RRNNNNNSNNNN\"), \"RRNNNNNSNNNN\" };\n\t\tunion acpi_object *package = &(p->package.elements[i]);\n\t\tstruct psvt *psvt = &psvts[i - 1 - nr_bad_entries];\n\t\tstruct acpi_buffer *psvt_format = &psvt_int_format;\n\t\tstruct acpi_buffer element = { 0, NULL };\n\t\tunion acpi_object *knob;\n\t\tstruct acpi_device *res;\n\t\tstruct psvt *psvt_ptr;\n\n\t\telement.length = ACPI_ALLOCATE_BUFFER;\n\t\telement.pointer = NULL;\n\n\t\tif (package->package.count >= ACPI_NR_PSVT_ELEMENTS) {\n\t\t\tknob = &(package->package.elements[ACPI_PSVT_CONTROL_KNOB]);\n\t\t} else {\n\t\t\tnr_bad_entries++;\n\t\t\tpr_info(\"PSVT package %d is invalid, ignored\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (knob->type == ACPI_TYPE_STRING) {\n\t\t\tpsvt_format = &psvt_str_format;\n\t\t\tif (knob->string.length > ACPI_LIMIT_STR_MAX_LEN - 1) {\n\t\t\t\tpr_info(\"PSVT package %d limit string len exceeds max\\n\", i);\n\t\t\t\tknob->string.length = ACPI_LIMIT_STR_MAX_LEN - 1;\n\t\t\t}\n\t\t}\n\n\t\tstatus = acpi_extract_package(&(p->package.elements[i]), psvt_format, &element);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tnr_bad_entries++;\n\t\t\tpr_info(\"PSVT package %d is invalid, ignored\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpsvt_ptr = (struct psvt *)element.pointer;\n\n\t\tmemcpy(psvt, psvt_ptr, sizeof(*psvt));\n\n\t\t \n\t\tpsvt->control_knob_type = (u64)knob->type;\n\n\t\tif (knob->type == ACPI_TYPE_STRING) {\n\t\t\tmemset(&psvt->limit, 0, sizeof(u64));\n\t\t\tstrncpy(psvt->limit.string, psvt_ptr->limit.str_ptr, knob->string.length);\n\t\t} else {\n\t\t\tpsvt->limit.integer = psvt_ptr->limit.integer;\n\t\t}\n\n\t\tkfree(element.pointer);\n\n\t\tres = acpi_fetch_acpi_dev(psvt->source);\n\t\tif (!res) {\n\t\t\tnr_bad_entries++;\n\t\t\tpr_info(\"Failed to get source ACPI device\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = acpi_fetch_acpi_dev(psvt->target);\n\t\tif (!res) {\n\t\t\tnr_bad_entries++;\n\t\t\tpr_info(\"Failed to get target ACPI device\\n\");\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\t*psvt_count -= nr_bad_entries;\n\n\tif (!*psvt_count) {\n\t\tresult = -EFAULT;\n\t\tkfree(psvts);\n\t\tgoto end;\n\t}\n\n\t*psvtp = psvts;\n\n\treturn 0;\n\nend:\n\tkfree(buffer.pointer);\n\treturn result;\n}\n\n \nstatic void get_single_name(acpi_handle handle, char *name)\n{\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER};\n\n\tif (ACPI_FAILURE(acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer)))\n\t\tpr_warn(\"Failed to get device name from acpi handle\\n\");\n\telse {\n\t\tmemcpy(name, buffer.pointer, ACPI_NAMESEG_SIZE);\n\t\tkfree(buffer.pointer);\n\t}\n}\n\nstatic int fill_art(char __user *ubuf)\n{\n\tint i;\n\tint ret;\n\tint count;\n\tint art_len;\n\tstruct art *arts = NULL;\n\tunion art_object *art_user;\n\n\tret = acpi_parse_art(acpi_thermal_rel_handle, &count, &arts, false);\n\tif (ret)\n\t\tgoto free_art;\n\tart_len = count * sizeof(union art_object);\n\tart_user = kzalloc(art_len, GFP_KERNEL);\n\tif (!art_user) {\n\t\tret = -ENOMEM;\n\t\tgoto free_art;\n\t}\n\t \n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tget_single_name(arts[i].source, art_user[i].source_device);\n\t\tget_single_name(arts[i].target, art_user[i].target_device);\n\t\t \n\t\tBUILD_BUG_ON(sizeof(art_user[i].data) !=\n\t\t\t     sizeof(u64) * (ACPI_NR_ART_ELEMENTS - 2));\n\t\tmemcpy(&art_user[i].data, &arts[i].data, sizeof(art_user[i].data));\n\t}\n\n\tif (copy_to_user(ubuf, art_user, art_len))\n\t\tret = -EFAULT;\n\tkfree(art_user);\nfree_art:\n\tkfree(arts);\n\treturn ret;\n}\n\nstatic int fill_trt(char __user *ubuf)\n{\n\tint i;\n\tint ret;\n\tint count;\n\tint trt_len;\n\tstruct trt *trts = NULL;\n\tunion trt_object *trt_user;\n\n\tret = acpi_parse_trt(acpi_thermal_rel_handle, &count, &trts, false);\n\tif (ret)\n\t\tgoto free_trt;\n\ttrt_len = count * sizeof(union trt_object);\n\ttrt_user = kzalloc(trt_len, GFP_KERNEL);\n\tif (!trt_user) {\n\t\tret = -ENOMEM;\n\t\tgoto free_trt;\n\t}\n\t \n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tget_single_name(trts[i].source, trt_user[i].source_device);\n\t\tget_single_name(trts[i].target, trt_user[i].target_device);\n\t\ttrt_user[i].sample_period = trts[i].sample_period;\n\t\ttrt_user[i].influence = trts[i].influence;\n\t}\n\n\tif (copy_to_user(ubuf, trt_user, trt_len))\n\t\tret = -EFAULT;\n\tkfree(trt_user);\nfree_trt:\n\tkfree(trts);\n\treturn ret;\n}\n\nstatic int fill_psvt(char __user *ubuf)\n{\n\tint i, ret, count, psvt_len;\n\tunion psvt_object *psvt_user;\n\tstruct psvt *psvts;\n\n\tret = acpi_parse_psvt(acpi_thermal_rel_handle, &count, &psvts);\n\tif (ret)\n\t\treturn ret;\n\n\tpsvt_len = count * sizeof(*psvt_user);\n\n\tpsvt_user = kzalloc(psvt_len, GFP_KERNEL);\n\tif (!psvt_user) {\n\t\tret = -ENOMEM;\n\t\tgoto free_psvt;\n\t}\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tget_single_name(psvts[i].source, psvt_user[i].source_device);\n\t\tget_single_name(psvts[i].target, psvt_user[i].target_device);\n\n\t\tpsvt_user[i].priority = psvts[i].priority;\n\t\tpsvt_user[i].sample_period = psvts[i].sample_period;\n\t\tpsvt_user[i].passive_temp = psvts[i].passive_temp;\n\t\tpsvt_user[i].source_domain = psvts[i].source_domain;\n\t\tpsvt_user[i].control_knob = psvts[i].control_knob;\n\t\tpsvt_user[i].step_size = psvts[i].step_size;\n\t\tpsvt_user[i].limit_coeff = psvts[i].limit_coeff;\n\t\tpsvt_user[i].unlimit_coeff = psvts[i].unlimit_coeff;\n\t\tpsvt_user[i].control_knob_type = psvts[i].control_knob_type;\n\t\tif (psvt_user[i].control_knob_type == ACPI_TYPE_STRING)\n\t\t\tstrncpy(psvt_user[i].limit.string, psvts[i].limit.string,\n\t\t\t\tACPI_LIMIT_STR_MAX_LEN);\n\t\telse\n\t\t\tpsvt_user[i].limit.integer = psvts[i].limit.integer;\n\n\t}\n\n\tif (copy_to_user(ubuf, psvt_user, psvt_len))\n\t\tret = -EFAULT;\n\n\tkfree(psvt_user);\n\nfree_psvt:\n\tkfree(psvts);\n\treturn ret;\n}\n\nstatic long acpi_thermal_rel_ioctl(struct file *f, unsigned int cmd,\n\t\t\t\t   unsigned long __arg)\n{\n\tint ret = 0;\n\tunsigned long length = 0;\n\tint count = 0;\n\tchar __user *arg = (void __user *)__arg;\n\tstruct trt *trts = NULL;\n\tstruct art *arts = NULL;\n\tstruct psvt *psvts;\n\n\tswitch (cmd) {\n\tcase ACPI_THERMAL_GET_TRT_COUNT:\n\t\tret = acpi_parse_trt(acpi_thermal_rel_handle, &count,\n\t\t\t\t&trts, false);\n\t\tkfree(trts);\n\t\tif (!ret)\n\t\t\treturn put_user(count, (unsigned long __user *)__arg);\n\t\treturn ret;\n\tcase ACPI_THERMAL_GET_TRT_LEN:\n\t\tret = acpi_parse_trt(acpi_thermal_rel_handle, &count,\n\t\t\t\t&trts, false);\n\t\tkfree(trts);\n\t\tlength = count * sizeof(union trt_object);\n\t\tif (!ret)\n\t\t\treturn put_user(length, (unsigned long __user *)__arg);\n\t\treturn ret;\n\tcase ACPI_THERMAL_GET_TRT:\n\t\treturn fill_trt(arg);\n\tcase ACPI_THERMAL_GET_ART_COUNT:\n\t\tret = acpi_parse_art(acpi_thermal_rel_handle, &count,\n\t\t\t\t&arts, false);\n\t\tkfree(arts);\n\t\tif (!ret)\n\t\t\treturn put_user(count, (unsigned long __user *)__arg);\n\t\treturn ret;\n\tcase ACPI_THERMAL_GET_ART_LEN:\n\t\tret = acpi_parse_art(acpi_thermal_rel_handle, &count,\n\t\t\t\t&arts, false);\n\t\tkfree(arts);\n\t\tlength = count * sizeof(union art_object);\n\t\tif (!ret)\n\t\t\treturn put_user(length, (unsigned long __user *)__arg);\n\t\treturn ret;\n\n\tcase ACPI_THERMAL_GET_ART:\n\t\treturn fill_art(arg);\n\n\tcase ACPI_THERMAL_GET_PSVT_COUNT:\n\t\tret = acpi_parse_psvt(acpi_thermal_rel_handle, &count, &psvts);\n\t\tif (!ret) {\n\t\t\tkfree(psvts);\n\t\t\treturn put_user(count, (unsigned long __user *)__arg);\n\t\t}\n\t\treturn ret;\n\n\tcase ACPI_THERMAL_GET_PSVT_LEN:\n\t\t \n\t\tret = acpi_parse_psvt(acpi_thermal_rel_handle, &count, &psvts);\n\t\tlength = count * sizeof(union psvt_object);\n\t\tif (!ret) {\n\t\t\tkfree(psvts);\n\t\t\treturn put_user(length, (unsigned long __user *)__arg);\n\t\t}\n\t\treturn ret;\n\n\tcase ACPI_THERMAL_GET_PSVT:\n\t\treturn fill_psvt(arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations acpi_thermal_rel_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= acpi_thermal_rel_open,\n\t.release\t= acpi_thermal_rel_release,\n\t.unlocked_ioctl\t= acpi_thermal_rel_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice acpi_thermal_rel_misc_device = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t\"acpi_thermal_rel\",\n\t&acpi_thermal_rel_fops\n};\n\nint acpi_thermal_rel_misc_device_add(acpi_handle handle)\n{\n\tacpi_thermal_rel_handle = handle;\n\n\treturn misc_register(&acpi_thermal_rel_misc_device);\n}\nEXPORT_SYMBOL(acpi_thermal_rel_misc_device_add);\n\nint acpi_thermal_rel_misc_device_remove(acpi_handle handle)\n{\n\tmisc_deregister(&acpi_thermal_rel_misc_device);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_thermal_rel_misc_device_remove);\n\nMODULE_AUTHOR(\"Zhang Rui <rui.zhang@intel.com>\");\nMODULE_AUTHOR(\"Jacob Pan <jacob.jun.pan@intel.com\");\nMODULE_DESCRIPTION(\"Intel acpi thermal rel misc dev driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}