{
  "module_name": "x86_pkg_temp_thermal.c",
  "hash_id": "bea2d0a58be4b78c516850cb6bf76739e3773810dabe6c71ae78e6959bf19db9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/x86_pkg_temp_thermal.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/intel_tcc.h>\n#include <linux/err.h>\n#include <linux/param.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/thermal.h>\n#include <linux/debugfs.h>\n\n#include <asm/cpu_device_id.h>\n\n#include \"thermal_interrupt.h\"\n\n \n#define PKG_TEMP_THERMAL_NOTIFY_DELAY\t5000\nstatic int notify_delay_ms = PKG_TEMP_THERMAL_NOTIFY_DELAY;\nmodule_param(notify_delay_ms, int, 0644);\nMODULE_PARM_DESC(notify_delay_ms,\n\t\"User space notification delay in milli seconds.\");\n\n \n#define MAX_NUMBER_OF_TRIPS\t2\n\nstruct zone_device {\n\tint\t\t\t\tcpu;\n\tbool\t\t\t\twork_scheduled;\n\tu32\t\t\t\tmsr_pkg_therm_low;\n\tu32\t\t\t\tmsr_pkg_therm_high;\n\tstruct delayed_work\t\twork;\n\tstruct thermal_zone_device\t*tzone;\n\tstruct thermal_trip\t\t*trips;\n\tstruct cpumask\t\t\tcpumask;\n};\n\nstatic struct thermal_zone_params pkg_temp_tz_params = {\n\t.no_hwmon\t= true,\n};\n\n \nstatic int max_id __read_mostly;\n \nstatic struct zone_device **zones;\n \nstatic DEFINE_RAW_SPINLOCK(pkg_temp_lock);\n \nstatic DEFINE_MUTEX(thermal_zone_mutex);\n\n \nstatic enum cpuhp_state pkg_thermal_hp_state __read_mostly;\n\n \nstatic struct dentry *debugfs;\nstatic unsigned int pkg_interrupt_cnt;\nstatic unsigned int pkg_work_cnt;\n\nstatic void pkg_temp_debugfs_init(void)\n{\n\tdebugfs = debugfs_create_dir(\"pkg_temp_thermal\", NULL);\n\n\tdebugfs_create_u32(\"pkg_thres_interrupt\", S_IRUGO, debugfs,\n\t\t\t   &pkg_interrupt_cnt);\n\tdebugfs_create_u32(\"pkg_thres_work\", S_IRUGO, debugfs,\n\t\t\t   &pkg_work_cnt);\n}\n\n \nstatic struct zone_device *pkg_temp_thermal_get_dev(unsigned int cpu)\n{\n\tint id = topology_logical_die_id(cpu);\n\n\tif (id >= 0 && id < max_id)\n\t\treturn zones[id];\n\treturn NULL;\n}\n\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd, int *temp)\n{\n\tstruct zone_device *zonedev = thermal_zone_device_priv(tzd);\n\tint val;\n\n\tval = intel_tcc_get_temp(zonedev->cpu, true);\n\tif (val < 0)\n\t\treturn val;\n\n\t*temp = val * 1000;\n\tpr_debug(\"sys_get_curr_temp %d\\n\", *temp);\n\treturn 0;\n}\n\nstatic int\nsys_set_trip_temp(struct thermal_zone_device *tzd, int trip, int temp)\n{\n\tstruct zone_device *zonedev = thermal_zone_device_priv(tzd);\n\tu32 l, h, mask, shift, intr;\n\tint tj_max, val, ret;\n\n\ttj_max = intel_tcc_get_tjmax(zonedev->cpu);\n\tif (tj_max < 0)\n\t\treturn tj_max;\n\ttj_max *= 1000;\n\n\tval = (tj_max - temp)/1000;\n\n\tif (trip >= MAX_NUMBER_OF_TRIPS || val < 0 || val > 0x7f)\n\t\treturn -EINVAL;\n\n\tret = rdmsr_on_cpu(zonedev->cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\t   &l, &h);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (trip) {\n\t\tmask = THERM_MASK_THRESHOLD1;\n\t\tshift = THERM_SHIFT_THRESHOLD1;\n\t\tintr = THERM_INT_THRESHOLD1_ENABLE;\n\t} else {\n\t\tmask = THERM_MASK_THRESHOLD0;\n\t\tshift = THERM_SHIFT_THRESHOLD0;\n\t\tintr = THERM_INT_THRESHOLD0_ENABLE;\n\t}\n\tl &= ~mask;\n\t \n\tif (!temp) {\n\t\tl &= ~intr;\n\t} else {\n\t\tl |= val << shift;\n\t\tl |= intr;\n\t}\n\n\treturn wrmsr_on_cpu(zonedev->cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\tl, h);\n}\n\n \nstatic struct thermal_zone_device_ops tzone_ops = {\n\t.get_temp = sys_get_curr_temp,\n\t.set_trip_temp = sys_set_trip_temp,\n};\n\nstatic bool pkg_thermal_rate_control(void)\n{\n\treturn true;\n}\n\n \nstatic inline void enable_pkg_thres_interrupt(void)\n{\n\tu8 thres_0, thres_1;\n\tu32 l, h;\n\n\trdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n\t \n\tthres_0 = (l & THERM_MASK_THRESHOLD0) >> THERM_SHIFT_THRESHOLD0;\n\tthres_1 = (l & THERM_MASK_THRESHOLD1) >> THERM_SHIFT_THRESHOLD1;\n\tif (thres_0)\n\t\tl |= THERM_INT_THRESHOLD0_ENABLE;\n\tif (thres_1)\n\t\tl |= THERM_INT_THRESHOLD1_ENABLE;\n\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n}\n\n \nstatic inline void disable_pkg_thres_interrupt(void)\n{\n\tu32 l, h;\n\n\trdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n\n\tl &= ~(THERM_INT_THRESHOLD0_ENABLE | THERM_INT_THRESHOLD1_ENABLE);\n\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n}\n\nstatic void pkg_temp_thermal_threshold_work_fn(struct work_struct *work)\n{\n\tstruct thermal_zone_device *tzone = NULL;\n\tint cpu = smp_processor_id();\n\tstruct zone_device *zonedev;\n\n\tmutex_lock(&thermal_zone_mutex);\n\traw_spin_lock_irq(&pkg_temp_lock);\n\t++pkg_work_cnt;\n\n\tzonedev = pkg_temp_thermal_get_dev(cpu);\n\tif (!zonedev) {\n\t\traw_spin_unlock_irq(&pkg_temp_lock);\n\t\tmutex_unlock(&thermal_zone_mutex);\n\t\treturn;\n\t}\n\tzonedev->work_scheduled = false;\n\n\tthermal_clear_package_intr_status(PACKAGE_LEVEL, THERM_LOG_THRESHOLD0 | THERM_LOG_THRESHOLD1);\n\ttzone = zonedev->tzone;\n\n\tenable_pkg_thres_interrupt();\n\traw_spin_unlock_irq(&pkg_temp_lock);\n\n\t \n\tif (tzone)\n\t\tthermal_zone_device_update(tzone, THERMAL_EVENT_UNSPECIFIED);\n\n\tmutex_unlock(&thermal_zone_mutex);\n}\n\nstatic void pkg_thermal_schedule_work(int cpu, struct delayed_work *work)\n{\n\tunsigned long ms = msecs_to_jiffies(notify_delay_ms);\n\n\tschedule_delayed_work_on(cpu, work, ms);\n}\n\nstatic int pkg_thermal_notify(u64 msr_val)\n{\n\tint cpu = smp_processor_id();\n\tstruct zone_device *zonedev;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pkg_temp_lock, flags);\n\t++pkg_interrupt_cnt;\n\n\tdisable_pkg_thres_interrupt();\n\n\t \n\tzonedev = pkg_temp_thermal_get_dev(cpu);\n\tif (zonedev && !zonedev->work_scheduled) {\n\t\tzonedev->work_scheduled = true;\n\t\tpkg_thermal_schedule_work(zonedev->cpu, &zonedev->work);\n\t}\n\n\traw_spin_unlock_irqrestore(&pkg_temp_lock, flags);\n\treturn 0;\n}\n\nstatic struct thermal_trip *pkg_temp_thermal_trips_init(int cpu, int tj_max, int num_trips)\n{\n\tstruct thermal_trip *trips;\n\tunsigned long thres_reg_value;\n\tu32 mask, shift, eax, edx;\n\tint ret, i;\n\n\ttrips = kzalloc(sizeof(*trips) * num_trips, GFP_KERNEL);\n\tif (!trips)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < num_trips; i++) {\n\n\t\tif (i) {\n\t\t\tmask = THERM_MASK_THRESHOLD1;\n\t\t\tshift = THERM_SHIFT_THRESHOLD1;\n\t\t} else {\n\t\t\tmask = THERM_MASK_THRESHOLD0;\n\t\t\tshift = THERM_SHIFT_THRESHOLD0;\n\t\t}\n\n\t\tret = rdmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t\t\t   &eax, &edx);\n\t\tif (ret < 0) {\n\t\t\tkfree(trips);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tthres_reg_value = (eax & mask) >> shift;\n\n\t\ttrips[i].temperature = thres_reg_value ?\n\t\t\ttj_max - thres_reg_value * 1000 : THERMAL_TEMP_INVALID;\n\n\t\ttrips[i].type = THERMAL_TRIP_PASSIVE;\n\n\t\tpr_debug(\"%s: cpu=%d, trip=%d, temp=%d\\n\",\n\t\t\t __func__, cpu, i, trips[i].temperature);\n\t}\n\n\treturn trips;\n}\n\nstatic int pkg_temp_thermal_device_add(unsigned int cpu)\n{\n\tint id = topology_logical_die_id(cpu);\n\tu32 eax, ebx, ecx, edx;\n\tstruct zone_device *zonedev;\n\tint thres_count, err;\n\tint tj_max;\n\n\tif (id >= max_id)\n\t\treturn -ENOMEM;\n\n\tcpuid(6, &eax, &ebx, &ecx, &edx);\n\tthres_count = ebx & 0x07;\n\tif (!thres_count)\n\t\treturn -ENODEV;\n\n\tthres_count = clamp_val(thres_count, 0, MAX_NUMBER_OF_TRIPS);\n\n\ttj_max = intel_tcc_get_tjmax(cpu);\n\tif (tj_max < 0)\n\t\treturn tj_max;\n\n\tzonedev = kzalloc(sizeof(*zonedev), GFP_KERNEL);\n\tif (!zonedev)\n\t\treturn -ENOMEM;\n\n\tzonedev->trips = pkg_temp_thermal_trips_init(cpu, tj_max, thres_count);\n\tif (IS_ERR(zonedev->trips)) {\n\t\terr = PTR_ERR(zonedev->trips);\n\t\tgoto out_kfree_zonedev;\n\t}\n\n\tINIT_DELAYED_WORK(&zonedev->work, pkg_temp_thermal_threshold_work_fn);\n\tzonedev->cpu = cpu;\n\tzonedev->tzone = thermal_zone_device_register_with_trips(\"x86_pkg_temp\",\n\t\t\tzonedev->trips, thres_count,\n\t\t\t(thres_count == MAX_NUMBER_OF_TRIPS) ? 0x03 : 0x01,\n\t\t\tzonedev, &tzone_ops, &pkg_temp_tz_params, 0, 0);\n\tif (IS_ERR(zonedev->tzone)) {\n\t\terr = PTR_ERR(zonedev->tzone);\n\t\tgoto out_kfree_trips;\n\t}\n\terr = thermal_zone_device_enable(zonedev->tzone);\n\tif (err)\n\t\tgoto out_unregister_tz;\n\n\t \n\trdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, zonedev->msr_pkg_therm_low,\n\t      zonedev->msr_pkg_therm_high);\n\n\tcpumask_set_cpu(cpu, &zonedev->cpumask);\n\traw_spin_lock_irq(&pkg_temp_lock);\n\tzones[id] = zonedev;\n\traw_spin_unlock_irq(&pkg_temp_lock);\n\n\treturn 0;\n\nout_unregister_tz:\n\tthermal_zone_device_unregister(zonedev->tzone);\nout_kfree_trips:\n\tkfree(zonedev->trips);\nout_kfree_zonedev:\n\tkfree(zonedev);\n\treturn err;\n}\n\nstatic int pkg_thermal_cpu_offline(unsigned int cpu)\n{\n\tstruct zone_device *zonedev = pkg_temp_thermal_get_dev(cpu);\n\tbool lastcpu, was_target;\n\tint target;\n\n\tif (!zonedev)\n\t\treturn 0;\n\n\ttarget = cpumask_any_but(&zonedev->cpumask, cpu);\n\tcpumask_clear_cpu(cpu, &zonedev->cpumask);\n\tlastcpu = target >= nr_cpu_ids;\n\t \n\tif (lastcpu) {\n\t\tstruct thermal_zone_device *tzone = zonedev->tzone;\n\n\t\t \n\t\tmutex_lock(&thermal_zone_mutex);\n\t\tzonedev->tzone = NULL;\n\t\tmutex_unlock(&thermal_zone_mutex);\n\n\t\tthermal_zone_device_unregister(tzone);\n\t}\n\n\t \n\traw_spin_lock_irq(&pkg_temp_lock);\n\n\t \n\twas_target = zonedev->cpu == cpu;\n\tzonedev->cpu = target;\n\n\t \n\tif (lastcpu) {\n\t\tzones[topology_logical_die_id(cpu)] = NULL;\n\t\t \n\t\twrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\n\t\t      zonedev->msr_pkg_therm_low, zonedev->msr_pkg_therm_high);\n\t}\n\n\t \n\tif (zonedev->work_scheduled && was_target) {\n\t\t \n\t\traw_spin_unlock_irq(&pkg_temp_lock);\n\t\tcancel_delayed_work_sync(&zonedev->work);\n\t\traw_spin_lock_irq(&pkg_temp_lock);\n\t\t \n\t\tif (!lastcpu && zonedev->work_scheduled)\n\t\t\tpkg_thermal_schedule_work(target, &zonedev->work);\n\t}\n\n\traw_spin_unlock_irq(&pkg_temp_lock);\n\n\t \n\tif (lastcpu) {\n\t\tkfree(zonedev->trips);\n\t\tkfree(zonedev);\n\t}\n\treturn 0;\n}\n\nstatic int pkg_thermal_cpu_online(unsigned int cpu)\n{\n\tstruct zone_device *zonedev = pkg_temp_thermal_get_dev(cpu);\n\tstruct cpuinfo_x86 *c = &cpu_data(cpu);\n\n\t \n\tif (!cpu_has(c, X86_FEATURE_DTHERM) || !cpu_has(c, X86_FEATURE_PTS))\n\t\treturn -ENODEV;\n\n\t \n\tif (zonedev) {\n\t\tcpumask_set_cpu(cpu, &zonedev->cpumask);\n\t\treturn 0;\n\t}\n\treturn pkg_temp_thermal_device_add(cpu);\n}\n\nstatic const struct x86_cpu_id __initconst pkg_temp_thermal_ids[] = {\n\tX86_MATCH_VENDOR_FEATURE(INTEL, X86_FEATURE_PTS, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, pkg_temp_thermal_ids);\n\nstatic int __init pkg_temp_thermal_init(void)\n{\n\tint ret;\n\n\tif (!x86_match_cpu(pkg_temp_thermal_ids))\n\t\treturn -ENODEV;\n\n\tmax_id = topology_max_packages() * topology_max_die_per_package();\n\tzones = kcalloc(max_id, sizeof(struct zone_device *),\n\t\t\t   GFP_KERNEL);\n\tif (!zones)\n\t\treturn -ENOMEM;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"thermal/x86_pkg:online\",\n\t\t\t\tpkg_thermal_cpu_online,\tpkg_thermal_cpu_offline);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tpkg_thermal_hp_state = ret;\n\n\tplatform_thermal_package_notify = pkg_thermal_notify;\n\tplatform_thermal_package_rate_control = pkg_thermal_rate_control;\n\n\t  \n\tpkg_temp_debugfs_init();\n\treturn 0;\n\nerr:\n\tkfree(zones);\n\treturn ret;\n}\nmodule_init(pkg_temp_thermal_init)\n\nstatic void __exit pkg_temp_thermal_exit(void)\n{\n\tplatform_thermal_package_notify = NULL;\n\tplatform_thermal_package_rate_control = NULL;\n\n\tcpuhp_remove_state(pkg_thermal_hp_state);\n\tdebugfs_remove_recursive(debugfs);\n\tkfree(zones);\n}\nmodule_exit(pkg_temp_thermal_exit)\n\nMODULE_IMPORT_NS(INTEL_TCC);\nMODULE_DESCRIPTION(\"X86 PKG TEMP Thermal Driver\");\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}