{
  "module_name": "intel_bxt_pmic_thermal.c",
  "hash_id": "9e0171207a6d41b0a7c7109ab7e27dd35db97423ea93544b6462e82dc3646471",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/intel_bxt_pmic_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/thermal.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/mfd/intel_soc_pmic.h>\n\n#define BXTWC_THRM0IRQ\t\t0x4E04\n#define BXTWC_THRM1IRQ\t\t0x4E05\n#define BXTWC_THRM2IRQ\t\t0x4E06\n#define BXTWC_MTHRM0IRQ\t\t0x4E12\n#define BXTWC_MTHRM1IRQ\t\t0x4E13\n#define BXTWC_MTHRM2IRQ\t\t0x4E14\n#define BXTWC_STHRM0IRQ\t\t0x4F19\n#define BXTWC_STHRM1IRQ\t\t0x4F1A\n#define BXTWC_STHRM2IRQ\t\t0x4F1B\n\nstruct trip_config_map {\n\tu16 irq_reg;\n\tu16 irq_en;\n\tu16 evt_stat;\n\tu8 irq_mask;\n\tu8 irq_en_mask;\n\tu8 evt_mask;\n\tu8 trip_num;\n};\n\nstruct thermal_irq_map {\n\tchar handle[20];\n\tint num_trips;\n\tconst struct trip_config_map *trip_config;\n};\n\nstruct pmic_thermal_data {\n\tconst struct thermal_irq_map *maps;\n\tint num_maps;\n};\n\nstatic const struct trip_config_map bxtwc_str0_trip_config[] = {\n\t{\n\t\t.irq_reg = BXTWC_THRM0IRQ,\n\t\t.irq_mask = 0x01,\n\t\t.irq_en = BXTWC_MTHRM0IRQ,\n\t\t.irq_en_mask = 0x01,\n\t\t.evt_stat = BXTWC_STHRM0IRQ,\n\t\t.evt_mask = 0x01,\n\t\t.trip_num = 0\n\t},\n\t{\n\t\t.irq_reg = BXTWC_THRM0IRQ,\n\t\t.irq_mask = 0x10,\n\t\t.irq_en = BXTWC_MTHRM0IRQ,\n\t\t.irq_en_mask = 0x10,\n\t\t.evt_stat = BXTWC_STHRM0IRQ,\n\t\t.evt_mask = 0x10,\n\t\t.trip_num = 1\n\t}\n};\n\nstatic const struct trip_config_map bxtwc_str1_trip_config[] = {\n\t{\n\t\t.irq_reg = BXTWC_THRM0IRQ,\n\t\t.irq_mask = 0x02,\n\t\t.irq_en = BXTWC_MTHRM0IRQ,\n\t\t.irq_en_mask = 0x02,\n\t\t.evt_stat = BXTWC_STHRM0IRQ,\n\t\t.evt_mask = 0x02,\n\t\t.trip_num = 0\n\t},\n\t{\n\t\t.irq_reg = BXTWC_THRM0IRQ,\n\t\t.irq_mask = 0x20,\n\t\t.irq_en = BXTWC_MTHRM0IRQ,\n\t\t.irq_en_mask = 0x20,\n\t\t.evt_stat = BXTWC_STHRM0IRQ,\n\t\t.evt_mask = 0x20,\n\t\t.trip_num = 1\n\t},\n};\n\nstatic const struct trip_config_map bxtwc_str2_trip_config[] = {\n\t{\n\t\t.irq_reg = BXTWC_THRM0IRQ,\n\t\t.irq_mask = 0x04,\n\t\t.irq_en = BXTWC_MTHRM0IRQ,\n\t\t.irq_en_mask = 0x04,\n\t\t.evt_stat = BXTWC_STHRM0IRQ,\n\t\t.evt_mask = 0x04,\n\t\t.trip_num = 0\n\t},\n\t{\n\t\t.irq_reg = BXTWC_THRM0IRQ,\n\t\t.irq_mask = 0x40,\n\t\t.irq_en = BXTWC_MTHRM0IRQ,\n\t\t.irq_en_mask = 0x40,\n\t\t.evt_stat = BXTWC_STHRM0IRQ,\n\t\t.evt_mask = 0x40,\n\t\t.trip_num = 1\n\t},\n};\n\nstatic const struct trip_config_map bxtwc_str3_trip_config[] = {\n\t{\n\t\t.irq_reg = BXTWC_THRM2IRQ,\n\t\t.irq_mask = 0x10,\n\t\t.irq_en = BXTWC_MTHRM2IRQ,\n\t\t.irq_en_mask = 0x10,\n\t\t.evt_stat = BXTWC_STHRM2IRQ,\n\t\t.evt_mask = 0x10,\n\t\t.trip_num = 0\n\t},\n};\n\nstatic const struct thermal_irq_map bxtwc_thermal_irq_map[] = {\n\t{\n\t\t.handle = \"STR0\",\n\t\t.trip_config = bxtwc_str0_trip_config,\n\t\t.num_trips = ARRAY_SIZE(bxtwc_str0_trip_config),\n\t},\n\t{\n\t\t.handle = \"STR1\",\n\t\t.trip_config = bxtwc_str1_trip_config,\n\t\t.num_trips = ARRAY_SIZE(bxtwc_str1_trip_config),\n\t},\n\t{\n\t\t.handle = \"STR2\",\n\t\t.trip_config = bxtwc_str2_trip_config,\n\t\t.num_trips = ARRAY_SIZE(bxtwc_str2_trip_config),\n\t},\n\t{\n\t\t.handle = \"STR3\",\n\t\t.trip_config = bxtwc_str3_trip_config,\n\t\t.num_trips = ARRAY_SIZE(bxtwc_str3_trip_config),\n\t},\n};\n\nstatic const struct pmic_thermal_data bxtwc_thermal_data = {\n\t.maps = bxtwc_thermal_irq_map,\n\t.num_maps = ARRAY_SIZE(bxtwc_thermal_irq_map),\n};\n\nstatic irqreturn_t pmic_thermal_irq_handler(int irq, void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct thermal_zone_device *tzd;\n\tstruct pmic_thermal_data *td;\n\tstruct intel_soc_pmic *pmic;\n\tstruct regmap *regmap;\n\tu8 reg_val, mask, irq_stat;\n\tu16 reg, evt_stat_reg;\n\tint i, j, ret;\n\n\tpmic = dev_get_drvdata(pdev->dev.parent);\n\tregmap = pmic->regmap;\n\ttd = (struct pmic_thermal_data *)\n\t\tplatform_get_device_id(pdev)->driver_data;\n\n\t \n\tfor (i = 0; i < td->num_maps; i++) {\n\t\tfor (j = 0; j < td->maps[i].num_trips; j++) {\n\t\t\treg = td->maps[i].trip_config[j].irq_reg;\n\t\t\tmask = td->maps[i].trip_config[j].irq_mask;\n\t\t\t \n\t\t\tif (regmap_read(regmap, reg, &ret))\n\t\t\t\treturn IRQ_HANDLED;\n\n\t\t\treg_val = (u8)ret;\n\t\t\tirq_stat = ((u8)ret & mask);\n\n\t\t\tif (!irq_stat)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tevt_stat_reg = td->maps[i].trip_config[j].evt_stat;\n\t\t\tif (regmap_read(regmap, evt_stat_reg, &ret))\n\t\t\t\treturn IRQ_HANDLED;\n\n\t\t\ttzd = thermal_zone_get_zone_by_name(td->maps[i].handle);\n\t\t\tif (!IS_ERR(tzd))\n\t\t\t\tthermal_zone_device_update(tzd,\n\t\t\t\t\t\tTHERMAL_EVENT_UNSPECIFIED);\n\n\t\t\t \n\t\t\tregmap_write(regmap, reg, reg_val & mask);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pmic_thermal_probe(struct platform_device *pdev)\n{\n\tstruct regmap_irq_chip_data *regmap_irq_chip;\n\tstruct pmic_thermal_data *thermal_data;\n\tint ret, irq, virq, i, j, pmic_irq_count;\n\tstruct intel_soc_pmic *pmic;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tu16 reg;\n\tu8 mask;\n\n\tdev = &pdev->dev;\n\tpmic = dev_get_drvdata(pdev->dev.parent);\n\tif (!pmic) {\n\t\tdev_err(dev, \"Failed to get struct intel_soc_pmic pointer\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tthermal_data = (struct pmic_thermal_data *)\n\t\t\t\tplatform_get_device_id(pdev)->driver_data;\n\tif (!thermal_data) {\n\t\tdev_err(dev, \"No thermal data initialized!!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregmap = pmic->regmap;\n\tregmap_irq_chip = pmic->irq_chip_data;\n\n\tpmic_irq_count = 0;\n\twhile ((irq = platform_get_irq(pdev, pmic_irq_count)) != -ENXIO) {\n\t\tvirq = regmap_irq_get_virq(regmap_irq_chip, irq);\n\t\tif (virq < 0) {\n\t\t\tdev_err(dev, \"failed to get virq by irq %d\\n\", irq);\n\t\t\treturn virq;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, virq,\n\t\t\t\tNULL, pmic_thermal_irq_handler,\n\t\t\t\tIRQF_ONESHOT, \"pmic_thermal\", pdev);\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"request irq(%d) failed: %d\\n\", virq, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tpmic_irq_count++;\n\t}\n\n\t \n\tfor (i = 0; i < thermal_data->num_maps; i++) {\n\t\tfor (j = 0; j < thermal_data->maps[i].num_trips; j++) {\n\t\t\treg = thermal_data->maps[i].trip_config[j].irq_en;\n\t\t\tmask = thermal_data->maps[i].trip_config[j].irq_en_mask;\n\t\t\tret = regmap_update_bits(regmap, reg, mask, 0x00);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id pmic_thermal_id_table[] = {\n\t{\n\t\t.name = \"bxt_wcove_thermal\",\n\t\t.driver_data = (kernel_ulong_t)&bxtwc_thermal_data,\n\t},\n\t{},\n};\n\nstatic struct platform_driver pmic_thermal_driver = {\n\t.probe = pmic_thermal_probe,\n\t.driver = {\n\t\t.name = \"pmic_thermal\",\n\t},\n\t.id_table = pmic_thermal_id_table,\n};\n\nMODULE_DEVICE_TABLE(platform, pmic_thermal_id_table);\nmodule_platform_driver(pmic_thermal_driver);\n\nMODULE_AUTHOR(\"Yegnesh S Iyer <yegnesh.s.iyer@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Broxton PMIC Thermal Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}