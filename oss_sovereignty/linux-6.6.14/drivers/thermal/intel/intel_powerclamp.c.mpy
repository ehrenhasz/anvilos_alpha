{
  "module_name": "intel_powerclamp.c",
  "hash_id": "3a4c070c8d640ce437f6d9f962a448416a04e6dedef10bde49b213e808431d4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/intel/intel_powerclamp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/thermal.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/idle_inject.h>\n\n#include <asm/msr.h>\n#include <asm/mwait.h>\n#include <asm/cpu_device_id.h>\n\n#define MAX_TARGET_RATIO (100U)\n \n#define CONFIDENCE_OK (3)\n \n#define DEFAULT_DURATION_JIFFIES (6)\n\nstatic unsigned int target_mwait;\nstatic struct dentry *debug_dir;\nstatic bool poll_pkg_cstate_enable;\n\n \nstatic unsigned int current_ratio;\n\n \nstatic bool should_skip;\n\nstruct powerclamp_data {\n\tunsigned int cpu;\n\tunsigned int count;\n\tunsigned int guard;\n\tunsigned int window_size_now;\n\tunsigned int target_ratio;\n\tbool clamping;\n};\n\nstatic struct powerclamp_data powerclamp_data;\n\nstatic struct thermal_cooling_device *cooling_dev;\n\nstatic DEFINE_MUTEX(powerclamp_lock);\n\n \nstatic unsigned int duration;\nstatic unsigned int pkg_cstate_ratio_cur;\nstatic unsigned int window_size;\n\nstatic int duration_set(const char *arg, const struct kernel_param *kp)\n{\n\tint ret = 0;\n\tunsigned long new_duration;\n\n\tret = kstrtoul(arg, 10, &new_duration);\n\tif (ret)\n\t\tgoto exit;\n\tif (new_duration > 25 || new_duration < 6) {\n\t\tpr_err(\"Out of recommended range %lu, between 6-25ms\\n\",\n\t\t\tnew_duration);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&powerclamp_lock);\n\tduration = clamp(new_duration, 6ul, 25ul) * 1000;\n\tmutex_unlock(&powerclamp_lock);\nexit:\n\n\treturn ret;\n}\n\nstatic int duration_get(char *buf, const struct kernel_param *kp)\n{\n\tint ret;\n\n\tmutex_lock(&powerclamp_lock);\n\tret = sysfs_emit(buf, \"%d\\n\", duration / 1000);\n\tmutex_unlock(&powerclamp_lock);\n\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops duration_ops = {\n\t.set = duration_set,\n\t.get = duration_get,\n};\n\nmodule_param_cb(duration, &duration_ops, NULL, 0644);\nMODULE_PARM_DESC(duration, \"forced idle time for each attempt in msec.\");\n\n#define DEFAULT_MAX_IDLE\t50\n#define MAX_ALL_CPU_IDLE\t75\n\nstatic u8 max_idle = DEFAULT_MAX_IDLE;\n\nstatic cpumask_var_t idle_injection_cpu_mask;\n\nstatic int allocate_copy_idle_injection_mask(const struct cpumask *copy_mask)\n{\n\tif (cpumask_available(idle_injection_cpu_mask))\n\t\tgoto copy_mask;\n\n\t \n\tif (!alloc_cpumask_var(&idle_injection_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\ncopy_mask:\n\tcpumask_copy(idle_injection_cpu_mask, copy_mask);\n\n\treturn 0;\n}\n\n \nstatic bool check_invalid(cpumask_var_t mask, u8 idle)\n{\n\tif (cpumask_equal(cpu_present_mask, mask) && idle > MAX_ALL_CPU_IDLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int cpumask_set(const char *arg, const struct kernel_param *kp)\n{\n\tcpumask_var_t new_mask;\n\tint ret;\n\n\tmutex_lock(&powerclamp_lock);\n\n\t \n\tif (powerclamp_data.clamping) {\n\t\tret = -EAGAIN;\n\t\tgoto skip_cpumask_set;\n\t}\n\n\tret = alloc_cpumask_var(&new_mask, GFP_KERNEL);\n\tif (!ret)\n\t\tgoto skip_cpumask_set;\n\n\tret = bitmap_parse(arg, strlen(arg), cpumask_bits(new_mask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret)\n\t\tgoto free_cpumask_set;\n\n\tif (cpumask_empty(new_mask) || check_invalid(new_mask, max_idle)) {\n\t\tret = -EINVAL;\n\t\tgoto free_cpumask_set;\n\t}\n\n\t \n\tret = allocate_copy_idle_injection_mask(new_mask);\n\nfree_cpumask_set:\n\tfree_cpumask_var(new_mask);\nskip_cpumask_set:\n\tmutex_unlock(&powerclamp_lock);\n\n\treturn ret;\n}\n\nstatic int cpumask_get(char *buf, const struct kernel_param *kp)\n{\n\tif (!cpumask_available(idle_injection_cpu_mask))\n\t\treturn -ENODEV;\n\n\treturn bitmap_print_to_pagebuf(false, buf, cpumask_bits(idle_injection_cpu_mask),\n\t\t\t\t       nr_cpumask_bits);\n}\n\nstatic const struct kernel_param_ops cpumask_ops = {\n\t.set = cpumask_set,\n\t.get = cpumask_get,\n};\n\nmodule_param_cb(cpumask, &cpumask_ops, NULL, 0644);\nMODULE_PARM_DESC(cpumask, \"Mask of CPUs to use for idle injection.\");\n\nstatic int max_idle_set(const char *arg, const struct kernel_param *kp)\n{\n\tu8 new_max_idle;\n\tint ret = 0;\n\n\tmutex_lock(&powerclamp_lock);\n\n\t \n\tif (powerclamp_data.clamping) {\n\t\tret = -EAGAIN;\n\t\tgoto skip_limit_set;\n\t}\n\n\tret = kstrtou8(arg, 10, &new_max_idle);\n\tif (ret)\n\t\tgoto skip_limit_set;\n\n\tif (new_max_idle > MAX_TARGET_RATIO) {\n\t\tret = -EINVAL;\n\t\tgoto skip_limit_set;\n\t}\n\n\tif (!cpumask_available(idle_injection_cpu_mask)) {\n\t\tret = allocate_copy_idle_injection_mask(cpu_present_mask);\n\t\tif (ret)\n\t\t\tgoto skip_limit_set;\n\t}\n\n\tif (check_invalid(idle_injection_cpu_mask, new_max_idle)) {\n\t\tret = -EINVAL;\n\t\tgoto skip_limit_set;\n\t}\n\n\tmax_idle = new_max_idle;\n\nskip_limit_set:\n\tmutex_unlock(&powerclamp_lock);\n\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops max_idle_ops = {\n\t.set = max_idle_set,\n\t.get = param_get_byte,\n};\n\nmodule_param_cb(max_idle, &max_idle_ops, &max_idle, 0644);\nMODULE_PARM_DESC(max_idle, \"maximum injected idle time to the total CPU time ratio in percent range:1-100\");\n\nstruct powerclamp_calibration_data {\n\tunsigned long confidence;   \n\tunsigned long steady_comp;  \n\tunsigned long dynamic_comp;  \n};\n\nstatic struct powerclamp_calibration_data cal_data[MAX_TARGET_RATIO];\n\nstatic int window_size_set(const char *arg, const struct kernel_param *kp)\n{\n\tint ret = 0;\n\tunsigned long new_window_size;\n\n\tret = kstrtoul(arg, 10, &new_window_size);\n\tif (ret)\n\t\tgoto exit_win;\n\tif (new_window_size > 10 || new_window_size < 2) {\n\t\tpr_err(\"Out of recommended window size %lu, between 2-10\\n\",\n\t\t\tnew_window_size);\n\t\tret = -EINVAL;\n\t}\n\n\twindow_size = clamp(new_window_size, 2ul, 10ul);\n\tsmp_mb();\n\nexit_win:\n\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops window_size_ops = {\n\t.set = window_size_set,\n\t.get = param_get_int,\n};\n\nmodule_param_cb(window_size, &window_size_ops, &window_size, 0644);\nMODULE_PARM_DESC(window_size, \"sliding window in number of clamping cycles\\n\"\n\t\"\\tpowerclamp controls idle ratio within this window. larger\\n\"\n\t\"\\twindow size results in slower response time but more smooth\\n\"\n\t\"\\tclamping results. default to 2.\");\n\nstatic void find_target_mwait(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned int highest_cstate = 0;\n\tunsigned int highest_subcstate = 0;\n\tint i;\n\n\tif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\n\t\treturn;\n\n\tcpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &edx);\n\n\tif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\n\t    !(ecx & CPUID5_ECX_INTERRUPT_BREAK))\n\t\treturn;\n\n\tedx >>= MWAIT_SUBSTATE_SIZE;\n\tfor (i = 0; i < 7 && edx; i++, edx >>= MWAIT_SUBSTATE_SIZE) {\n\t\tif (edx & MWAIT_SUBSTATE_MASK) {\n\t\t\thighest_cstate = i;\n\t\t\thighest_subcstate = edx & MWAIT_SUBSTATE_MASK;\n\t\t}\n\t}\n\ttarget_mwait = (highest_cstate << MWAIT_SUBSTATE_SIZE) |\n\t\t(highest_subcstate - 1);\n\n}\n\nstruct pkg_cstate_info {\n\tbool skip;\n\tint msr_index;\n\tint cstate_id;\n};\n\n#define PKG_CSTATE_INIT(id) {\t\t\t\t\\\n\t\t.msr_index = MSR_PKG_C##id##_RESIDENCY, \\\n\t\t.cstate_id = id\t\t\t\t\\\n\t\t\t}\n\nstatic struct pkg_cstate_info pkg_cstates[] = {\n\tPKG_CSTATE_INIT(2),\n\tPKG_CSTATE_INIT(3),\n\tPKG_CSTATE_INIT(6),\n\tPKG_CSTATE_INIT(7),\n\tPKG_CSTATE_INIT(8),\n\tPKG_CSTATE_INIT(9),\n\tPKG_CSTATE_INIT(10),\n\t{NULL},\n};\n\nstatic bool has_pkg_state_counter(void)\n{\n\tu64 val;\n\tstruct pkg_cstate_info *info = pkg_cstates;\n\n\t \n\twhile (info->msr_index) {\n\t\tif (!rdmsrl_safe(info->msr_index, &val))\n\t\t\treturn true;\n\t\tinfo++;\n\t}\n\n\treturn false;\n}\n\nstatic u64 pkg_state_counter(void)\n{\n\tu64 val;\n\tu64 count = 0;\n\tstruct pkg_cstate_info *info = pkg_cstates;\n\n\twhile (info->msr_index) {\n\t\tif (!info->skip) {\n\t\t\tif (!rdmsrl_safe(info->msr_index, &val))\n\t\t\t\tcount += val;\n\t\t\telse\n\t\t\t\tinfo->skip = true;\n\t\t}\n\t\tinfo++;\n\t}\n\n\treturn count;\n}\n\nstatic unsigned int get_compensation(int ratio)\n{\n\tunsigned int comp = 0;\n\n\tif (!poll_pkg_cstate_enable)\n\t\treturn 0;\n\n\t \n\tif (ratio == 1 &&\n\t\tcal_data[ratio].confidence >= CONFIDENCE_OK &&\n\t\tcal_data[ratio + 1].confidence >= CONFIDENCE_OK &&\n\t\tcal_data[ratio + 2].confidence >= CONFIDENCE_OK) {\n\t\tcomp = (cal_data[ratio].steady_comp +\n\t\t\tcal_data[ratio + 1].steady_comp +\n\t\t\tcal_data[ratio + 2].steady_comp) / 3;\n\t} else if (ratio == MAX_TARGET_RATIO - 1 &&\n\t\tcal_data[ratio].confidence >= CONFIDENCE_OK &&\n\t\tcal_data[ratio - 1].confidence >= CONFIDENCE_OK &&\n\t\tcal_data[ratio - 2].confidence >= CONFIDENCE_OK) {\n\t\tcomp = (cal_data[ratio].steady_comp +\n\t\t\tcal_data[ratio - 1].steady_comp +\n\t\t\tcal_data[ratio - 2].steady_comp) / 3;\n\t} else if (cal_data[ratio].confidence >= CONFIDENCE_OK &&\n\t\tcal_data[ratio - 1].confidence >= CONFIDENCE_OK &&\n\t\tcal_data[ratio + 1].confidence >= CONFIDENCE_OK) {\n\t\tcomp = (cal_data[ratio].steady_comp +\n\t\t\tcal_data[ratio - 1].steady_comp +\n\t\t\tcal_data[ratio + 1].steady_comp) / 3;\n\t}\n\n\t \n\tif (comp + ratio >= MAX_TARGET_RATIO)\n\t\tcomp = MAX_TARGET_RATIO - ratio - 1;\n\n\treturn comp;\n}\n\nstatic void adjust_compensation(int target_ratio, unsigned int win)\n{\n\tint delta;\n\tstruct powerclamp_calibration_data *d = &cal_data[target_ratio];\n\n\t \n\tif (d->confidence >= CONFIDENCE_OK)\n\t\treturn;\n\n\tdelta = powerclamp_data.target_ratio - current_ratio;\n\t \n\tif (delta >= 0 && delta <= (1+target_ratio/10)) {\n\t\tif (d->steady_comp)\n\t\t\td->steady_comp =\n\t\t\t\troundup(delta+d->steady_comp, 2)/2;\n\t\telse\n\t\t\td->steady_comp = delta;\n\t\td->confidence++;\n\t}\n}\n\nstatic bool powerclamp_adjust_controls(unsigned int target_ratio,\n\t\t\t\tunsigned int guard, unsigned int win)\n{\n\tstatic u64 msr_last, tsc_last;\n\tu64 msr_now, tsc_now;\n\tu64 val64;\n\n\t \n\tmsr_now = pkg_state_counter();\n\ttsc_now = rdtsc();\n\n\t \n\tif (!msr_last || !tsc_last)\n\t\tcurrent_ratio = 1;\n\telse if (tsc_now-tsc_last) {\n\t\tval64 = 100*(msr_now-msr_last);\n\t\tdo_div(val64, (tsc_now-tsc_last));\n\t\tcurrent_ratio = val64;\n\t}\n\n\t \n\tmsr_last = msr_now;\n\ttsc_last = tsc_now;\n\n\tadjust_compensation(target_ratio, win);\n\n\t \n\treturn powerclamp_data.target_ratio + guard <= current_ratio;\n}\n\n \nstatic unsigned int get_run_time(void)\n{\n\tunsigned int compensated_ratio;\n\tunsigned int runtime;\n\n\t \n\tpowerclamp_data.guard = 1 + powerclamp_data.target_ratio / 20;\n\tpowerclamp_data.window_size_now = window_size;\n\n\t \n\tcompensated_ratio = powerclamp_data.target_ratio +\n\t\tget_compensation(powerclamp_data.target_ratio);\n\tif (compensated_ratio <= 0)\n\t\tcompensated_ratio = 1;\n\n\truntime = duration * 100 / compensated_ratio - duration;\n\n\treturn runtime;\n}\n\n \nstatic void poll_pkg_cstate(struct work_struct *dummy);\nstatic DECLARE_DELAYED_WORK(poll_pkg_cstate_work, poll_pkg_cstate);\nstatic void poll_pkg_cstate(struct work_struct *dummy)\n{\n\tstatic u64 msr_last;\n\tstatic u64 tsc_last;\n\n\tu64 msr_now;\n\tu64 tsc_now;\n\tu64 val64;\n\n\tmsr_now = pkg_state_counter();\n\ttsc_now = rdtsc();\n\n\t \n\tif (!msr_last || !tsc_last)\n\t\tpkg_cstate_ratio_cur = 1;\n\telse {\n\t\tif (tsc_now - tsc_last) {\n\t\t\tval64 = 100 * (msr_now - msr_last);\n\t\t\tdo_div(val64, (tsc_now - tsc_last));\n\t\t\tpkg_cstate_ratio_cur = val64;\n\t\t}\n\t}\n\n\t \n\tmsr_last = msr_now;\n\ttsc_last = tsc_now;\n\n\tmutex_lock(&powerclamp_lock);\n\tif (powerclamp_data.clamping)\n\t\tschedule_delayed_work(&poll_pkg_cstate_work, HZ);\n\tmutex_unlock(&powerclamp_lock);\n}\n\nstatic struct idle_inject_device *ii_dev;\n\n \nstatic bool idle_inject_update(void)\n{\n\tbool update = false;\n\n\t \n\tif (!mutex_trylock(&powerclamp_lock))\n\t\treturn true;\n\n\tif (!(powerclamp_data.count % powerclamp_data.window_size_now)) {\n\n\t\tshould_skip = powerclamp_adjust_controls(powerclamp_data.target_ratio,\n\t\t\t\t\t\t\t powerclamp_data.guard,\n\t\t\t\t\t\t\t powerclamp_data.window_size_now);\n\t\tupdate = true;\n\t}\n\n\tif (update) {\n\t\tunsigned int runtime = get_run_time();\n\n\t\tidle_inject_set_duration(ii_dev, runtime, duration);\n\t}\n\n\tpowerclamp_data.count++;\n\n\tmutex_unlock(&powerclamp_lock);\n\n\tif (should_skip)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void trigger_idle_injection(void)\n{\n\tunsigned int runtime = get_run_time();\n\n\tidle_inject_set_duration(ii_dev, runtime, duration);\n\tidle_inject_start(ii_dev);\n\tpowerclamp_data.clamping = true;\n}\n\n \nstatic int powerclamp_idle_injection_register(void)\n{\n\tpoll_pkg_cstate_enable = false;\n\tif (cpumask_equal(cpu_present_mask, idle_injection_cpu_mask)) {\n\t\tii_dev = idle_inject_register_full(idle_injection_cpu_mask, idle_inject_update);\n\t\tif (topology_max_packages() == 1 && topology_max_die_per_package() == 1)\n\t\t\tpoll_pkg_cstate_enable = true;\n\t} else {\n\t\tii_dev = idle_inject_register(idle_injection_cpu_mask);\n\t}\n\n\tif (!ii_dev) {\n\t\tpr_err(\"powerclamp: idle_inject_register failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tidle_inject_set_duration(ii_dev, TICK_USEC, duration);\n\tidle_inject_set_latency(ii_dev, UINT_MAX);\n\n\treturn 0;\n}\n\n \nstatic void remove_idle_injection(void)\n{\n\tif (!powerclamp_data.clamping)\n\t\treturn;\n\n\tpowerclamp_data.clamping = false;\n\tidle_inject_stop(ii_dev);\n}\n\n \nstatic int start_power_clamp(void)\n{\n\tint ret;\n\n\tret = powerclamp_idle_injection_register();\n\tif (!ret) {\n\t\ttrigger_idle_injection();\n\t\tif (poll_pkg_cstate_enable)\n\t\t\tschedule_delayed_work(&poll_pkg_cstate_work, 0);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void end_power_clamp(void)\n{\n\tif (powerclamp_data.clamping) {\n\t\tremove_idle_injection();\n\t\tidle_inject_unregister(ii_dev);\n\t}\n}\n\nstatic int powerclamp_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\t*state = MAX_TARGET_RATIO;\n\n\treturn 0;\n}\n\nstatic int powerclamp_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tmutex_lock(&powerclamp_lock);\n\t*state = powerclamp_data.target_ratio;\n\tmutex_unlock(&powerclamp_lock);\n\n\treturn 0;\n}\n\nstatic int powerclamp_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long new_target_ratio)\n{\n\tint ret = 0;\n\n\tmutex_lock(&powerclamp_lock);\n\n\tnew_target_ratio = clamp(new_target_ratio, 0UL,\n\t\t\t\t(unsigned long) (max_idle - 1));\n\n\tif (powerclamp_data.target_ratio == new_target_ratio)\n\t\tgoto exit_set;\n\n\tif (!powerclamp_data.target_ratio && new_target_ratio > 0) {\n\t\tpr_info(\"Start idle injection to reduce power\\n\");\n\t\tpowerclamp_data.target_ratio = new_target_ratio;\n\t\tret = start_power_clamp();\n\t\tif (ret)\n\t\t\tpowerclamp_data.target_ratio = 0;\n\t\tgoto exit_set;\n\t} else\tif (powerclamp_data.target_ratio > 0 && new_target_ratio == 0) {\n\t\tpr_info(\"Stop forced idle injection\\n\");\n\t\tend_power_clamp();\n\t\tpowerclamp_data.target_ratio = 0;\n\t} else\t  {\n\t\tunsigned int runtime;\n\n\t\tpowerclamp_data.target_ratio = new_target_ratio;\n\t\truntime = get_run_time();\n\t\tidle_inject_set_duration(ii_dev, runtime, duration);\n\t}\n\nexit_set:\n\tmutex_unlock(&powerclamp_lock);\n\n\treturn ret;\n}\n\n \nstatic const struct thermal_cooling_device_ops powerclamp_cooling_ops = {\n\t.get_max_state = powerclamp_get_max_state,\n\t.get_cur_state = powerclamp_get_cur_state,\n\t.set_cur_state = powerclamp_set_cur_state,\n};\n\nstatic const struct x86_cpu_id __initconst intel_powerclamp_ids[] = {\n\tX86_MATCH_VENDOR_FEATURE(INTEL, X86_FEATURE_MWAIT, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, intel_powerclamp_ids);\n\nstatic int __init powerclamp_probe(void)\n{\n\n\tif (!x86_match_cpu(intel_powerclamp_ids)) {\n\t\tpr_err(\"CPU does not support MWAIT\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!has_pkg_state_counter()) {\n\t\tpr_info(\"No package C-state available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfind_target_mwait();\n\n\treturn 0;\n}\n\nstatic int powerclamp_debug_show(struct seq_file *m, void *unused)\n{\n\tint i = 0;\n\n\tseq_printf(m, \"pct confidence steady dynamic (compensation)\\n\");\n\tfor (i = 0; i < MAX_TARGET_RATIO; i++) {\n\t\tseq_printf(m, \"%d\\t%lu\\t%lu\\t%lu\\n\",\n\t\t\ti,\n\t\t\tcal_data[i].confidence,\n\t\t\tcal_data[i].steady_comp,\n\t\t\tcal_data[i].dynamic_comp);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(powerclamp_debug);\n\nstatic inline void powerclamp_create_debug_files(void)\n{\n\tdebug_dir = debugfs_create_dir(\"intel_powerclamp\", NULL);\n\n\tdebugfs_create_file(\"powerclamp_calib\", S_IRUGO, debug_dir, cal_data,\n\t\t\t    &powerclamp_debug_fops);\n}\n\nstatic int __init powerclamp_init(void)\n{\n\tint retval;\n\n\t \n\tretval = powerclamp_probe();\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&powerclamp_lock);\n\tif (!cpumask_available(idle_injection_cpu_mask))\n\t\tretval = allocate_copy_idle_injection_mask(cpu_present_mask);\n\tmutex_unlock(&powerclamp_lock);\n\n\tif (retval)\n\t\treturn retval;\n\n\t \n\twindow_size = 2;\n\n\tcooling_dev = thermal_cooling_device_register(\"intel_powerclamp\", NULL,\n\t\t\t\t\t\t      &powerclamp_cooling_ops);\n\tif (IS_ERR(cooling_dev))\n\t\treturn -ENODEV;\n\n\tif (!duration)\n\t\tduration = jiffies_to_usecs(DEFAULT_DURATION_JIFFIES);\n\n\tpowerclamp_create_debug_files();\n\n\treturn 0;\n}\nmodule_init(powerclamp_init);\n\nstatic void __exit powerclamp_exit(void)\n{\n\tmutex_lock(&powerclamp_lock);\n\tend_power_clamp();\n\tmutex_unlock(&powerclamp_lock);\n\n\tthermal_cooling_device_unregister(cooling_dev);\n\n\tcancel_delayed_work_sync(&poll_pkg_cstate_work);\n\tdebugfs_remove_recursive(debug_dir);\n\n\tif (cpumask_available(idle_injection_cpu_mask))\n\t\tfree_cpumask_var(idle_injection_cpu_mask);\n}\nmodule_exit(powerclamp_exit);\n\nMODULE_IMPORT_NS(IDLE_INJECT);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arjan van de Ven <arjan@linux.intel.com>\");\nMODULE_AUTHOR(\"Jacob Pan <jacob.jun.pan@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Package Level C-state Idle Injection for Intel CPUs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}