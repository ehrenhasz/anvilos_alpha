{
  "module_name": "cpufreq_cooling.c",
  "hash_id": "1cd562c9d289def2d4b6b5f33cd3047ebaabe658840b6c10166098c7dfc0c828",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/cpufreq_cooling.c",
  "human_readable_source": "\n \n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu_cooling.h>\n#include <linux/device.h>\n#include <linux/energy_model.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n#include <linux/units.h>\n\n#include \"thermal_trace.h\"\n\n \n\n \nstruct time_in_idle {\n\tu64 time;\n\tu64 timestamp;\n};\n\n \nstruct cpufreq_cooling_device {\n\tu32 last_load;\n\tunsigned int cpufreq_state;\n\tunsigned int max_level;\n\tstruct em_perf_domain *em;\n\tstruct cpufreq_policy *policy;\n\tstruct thermal_cooling_device_ops cooling_ops;\n#ifndef CONFIG_SMP\n\tstruct time_in_idle *idle_time;\n#endif\n\tstruct freq_qos_request qos_req;\n};\n\n#ifdef CONFIG_THERMAL_GOV_POWER_ALLOCATOR\n \nstatic unsigned long get_level(struct cpufreq_cooling_device *cpufreq_cdev,\n\t\t\t       unsigned int freq)\n{\n\tint i;\n\n\tfor (i = cpufreq_cdev->max_level - 1; i >= 0; i--) {\n\t\tif (freq > cpufreq_cdev->em->table[i].frequency)\n\t\t\tbreak;\n\t}\n\n\treturn cpufreq_cdev->max_level - i - 1;\n}\n\nstatic u32 cpu_freq_to_power(struct cpufreq_cooling_device *cpufreq_cdev,\n\t\t\t     u32 freq)\n{\n\tunsigned long power_mw;\n\tint i;\n\n\tfor (i = cpufreq_cdev->max_level - 1; i >= 0; i--) {\n\t\tif (freq > cpufreq_cdev->em->table[i].frequency)\n\t\t\tbreak;\n\t}\n\n\tpower_mw = cpufreq_cdev->em->table[i + 1].power;\n\tpower_mw /= MICROWATT_PER_MILLIWATT;\n\n\treturn power_mw;\n}\n\nstatic u32 cpu_power_to_freq(struct cpufreq_cooling_device *cpufreq_cdev,\n\t\t\t     u32 power)\n{\n\tunsigned long em_power_mw;\n\tint i;\n\n\tfor (i = cpufreq_cdev->max_level; i > 0; i--) {\n\t\t \n\t\tem_power_mw = cpufreq_cdev->em->table[i].power;\n\t\tem_power_mw /= MICROWATT_PER_MILLIWATT;\n\t\tif (power >= em_power_mw)\n\t\t\tbreak;\n\t}\n\n\treturn cpufreq_cdev->em->table[i].frequency;\n}\n\n \n#ifdef CONFIG_SMP\nstatic u32 get_load(struct cpufreq_cooling_device *cpufreq_cdev, int cpu,\n\t\t    int cpu_idx)\n{\n\tunsigned long util = sched_cpu_util(cpu);\n\n\treturn (util * 100) / arch_scale_cpu_capacity(cpu);\n}\n#else  \nstatic u32 get_load(struct cpufreq_cooling_device *cpufreq_cdev, int cpu,\n\t\t    int cpu_idx)\n{\n\tu32 load;\n\tu64 now, now_idle, delta_time, delta_idle;\n\tstruct time_in_idle *idle_time = &cpufreq_cdev->idle_time[cpu_idx];\n\n\tnow_idle = get_cpu_idle_time(cpu, &now, 0);\n\tdelta_idle = now_idle - idle_time->time;\n\tdelta_time = now - idle_time->timestamp;\n\n\tif (delta_time <= delta_idle)\n\t\tload = 0;\n\telse\n\t\tload = div64_u64(100 * (delta_time - delta_idle), delta_time);\n\n\tidle_time->time = now_idle;\n\tidle_time->timestamp = now;\n\n\treturn load;\n}\n#endif  \n\n \nstatic u32 get_dynamic_power(struct cpufreq_cooling_device *cpufreq_cdev,\n\t\t\t     unsigned long freq)\n{\n\tu32 raw_cpu_power;\n\n\traw_cpu_power = cpu_freq_to_power(cpufreq_cdev, freq);\n\treturn (raw_cpu_power * cpufreq_cdev->last_load) / 100;\n}\n\n \nstatic int cpufreq_get_requested_power(struct thermal_cooling_device *cdev,\n\t\t\t\t       u32 *power)\n{\n\tunsigned long freq;\n\tint i = 0, cpu;\n\tu32 total_load = 0;\n\tstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\n\tstruct cpufreq_policy *policy = cpufreq_cdev->policy;\n\n\tfreq = cpufreq_quick_get(policy->cpu);\n\n\tfor_each_cpu(cpu, policy->related_cpus) {\n\t\tu32 load;\n\n\t\tif (cpu_online(cpu))\n\t\t\tload = get_load(cpufreq_cdev, cpu, i);\n\t\telse\n\t\t\tload = 0;\n\n\t\ttotal_load += load;\n\t}\n\n\tcpufreq_cdev->last_load = total_load;\n\n\t*power = get_dynamic_power(cpufreq_cdev, freq);\n\n\ttrace_thermal_power_cpu_get_power_simple(policy->cpu, *power);\n\n\treturn 0;\n}\n\n \nstatic int cpufreq_state2power(struct thermal_cooling_device *cdev,\n\t\t\t       unsigned long state, u32 *power)\n{\n\tunsigned int freq, num_cpus, idx;\n\tstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\n\n\t \n\tif (state > cpufreq_cdev->max_level)\n\t\treturn -EINVAL;\n\n\tnum_cpus = cpumask_weight(cpufreq_cdev->policy->cpus);\n\n\tidx = cpufreq_cdev->max_level - state;\n\tfreq = cpufreq_cdev->em->table[idx].frequency;\n\t*power = cpu_freq_to_power(cpufreq_cdev, freq) * num_cpus;\n\n\treturn 0;\n}\n\n \nstatic int cpufreq_power2state(struct thermal_cooling_device *cdev,\n\t\t\t       u32 power, unsigned long *state)\n{\n\tunsigned int target_freq;\n\tu32 last_load, normalised_power;\n\tstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\n\tstruct cpufreq_policy *policy = cpufreq_cdev->policy;\n\n\tlast_load = cpufreq_cdev->last_load ?: 1;\n\tnormalised_power = (power * 100) / last_load;\n\ttarget_freq = cpu_power_to_freq(cpufreq_cdev, normalised_power);\n\n\t*state = get_level(cpufreq_cdev, target_freq);\n\ttrace_thermal_power_cpu_limit(policy->related_cpus, target_freq, *state,\n\t\t\t\t      power);\n\treturn 0;\n}\n\nstatic inline bool em_is_sane(struct cpufreq_cooling_device *cpufreq_cdev,\n\t\t\t      struct em_perf_domain *em) {\n\tstruct cpufreq_policy *policy;\n\tunsigned int nr_levels;\n\n\tif (!em || em_is_artificial(em))\n\t\treturn false;\n\n\tpolicy = cpufreq_cdev->policy;\n\tif (!cpumask_equal(policy->related_cpus, em_span_cpus(em))) {\n\t\tpr_err(\"The span of pd %*pbl is misaligned with cpufreq policy %*pbl\\n\",\n\t\t\tcpumask_pr_args(em_span_cpus(em)),\n\t\t\tcpumask_pr_args(policy->related_cpus));\n\t\treturn false;\n\t}\n\n\tnr_levels = cpufreq_cdev->max_level + 1;\n\tif (em_pd_nr_perf_states(em) != nr_levels) {\n\t\tpr_err(\"The number of performance states in pd %*pbl (%u) doesn't match the number of cooling levels (%u)\\n\",\n\t\t\tcpumask_pr_args(em_span_cpus(em)),\n\t\t\tem_pd_nr_perf_states(em), nr_levels);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n#endif  \n\n#ifdef CONFIG_SMP\nstatic inline int allocate_idle_time(struct cpufreq_cooling_device *cpufreq_cdev)\n{\n\treturn 0;\n}\n\nstatic inline void free_idle_time(struct cpufreq_cooling_device *cpufreq_cdev)\n{\n}\n#else\nstatic int allocate_idle_time(struct cpufreq_cooling_device *cpufreq_cdev)\n{\n\tunsigned int num_cpus = cpumask_weight(cpufreq_cdev->policy->related_cpus);\n\n\tcpufreq_cdev->idle_time = kcalloc(num_cpus,\n\t\t\t\t\t  sizeof(*cpufreq_cdev->idle_time),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!cpufreq_cdev->idle_time)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void free_idle_time(struct cpufreq_cooling_device *cpufreq_cdev)\n{\n\tkfree(cpufreq_cdev->idle_time);\n\tcpufreq_cdev->idle_time = NULL;\n}\n#endif  \n\nstatic unsigned int get_state_freq(struct cpufreq_cooling_device *cpufreq_cdev,\n\t\t\t\t   unsigned long state)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned long idx;\n\n#ifdef CONFIG_THERMAL_GOV_POWER_ALLOCATOR\n\t \n\tif (cpufreq_cdev->em) {\n\t\tidx = cpufreq_cdev->max_level - state;\n\t\treturn cpufreq_cdev->em->table[idx].frequency;\n\t}\n#endif\n\n\t \n\tpolicy = cpufreq_cdev->policy;\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\tidx = cpufreq_cdev->max_level - state;\n\telse\n\t\tidx = state;\n\n\treturn policy->freq_table[idx].frequency;\n}\n\n \n\n \nstatic int cpufreq_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\n\n\t*state = cpufreq_cdev->max_level;\n\treturn 0;\n}\n\n \nstatic int cpufreq_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\n\n\t*state = cpufreq_cdev->cpufreq_state;\n\n\treturn 0;\n}\n\n \nstatic int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long state)\n{\n\tstruct cpufreq_cooling_device *cpufreq_cdev = cdev->devdata;\n\tstruct cpumask *cpus;\n\tunsigned int frequency;\n\tint ret;\n\n\t \n\tif (state > cpufreq_cdev->max_level)\n\t\treturn -EINVAL;\n\n\t \n\tif (cpufreq_cdev->cpufreq_state == state)\n\t\treturn 0;\n\n\tfrequency = get_state_freq(cpufreq_cdev, state);\n\n\tret = freq_qos_update_request(&cpufreq_cdev->qos_req, frequency);\n\tif (ret >= 0) {\n\t\tcpufreq_cdev->cpufreq_state = state;\n\t\tcpus = cpufreq_cdev->policy->related_cpus;\n\t\tarch_update_thermal_pressure(cpus, frequency);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct thermal_cooling_device *\n__cpufreq_cooling_register(struct device_node *np,\n\t\t\tstruct cpufreq_policy *policy,\n\t\t\tstruct em_perf_domain *em)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct cpufreq_cooling_device *cpufreq_cdev;\n\tunsigned int i;\n\tstruct device *dev;\n\tint ret;\n\tstruct thermal_cooling_device_ops *cooling_ops;\n\tchar *name;\n\n\tif (IS_ERR_OR_NULL(policy)) {\n\t\tpr_err(\"%s: cpufreq policy isn't valid: %p\\n\", __func__, policy);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdev = get_cpu_device(policy->cpu);\n\tif (unlikely(!dev)) {\n\t\tpr_warn(\"No cpu device for cpu %d\\n\", policy->cpu);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\ti = cpufreq_table_count_valid_entries(policy);\n\tif (!i) {\n\t\tpr_debug(\"%s: CPUFreq table not found or has no valid entries\\n\",\n\t\t\t __func__);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tcpufreq_cdev = kzalloc(sizeof(*cpufreq_cdev), GFP_KERNEL);\n\tif (!cpufreq_cdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcpufreq_cdev->policy = policy;\n\n\tret = allocate_idle_time(cpufreq_cdev);\n\tif (ret) {\n\t\tcdev = ERR_PTR(ret);\n\t\tgoto free_cdev;\n\t}\n\n\t \n\tcpufreq_cdev->max_level = i - 1;\n\n\tcooling_ops = &cpufreq_cdev->cooling_ops;\n\tcooling_ops->get_max_state = cpufreq_get_max_state;\n\tcooling_ops->get_cur_state = cpufreq_get_cur_state;\n\tcooling_ops->set_cur_state = cpufreq_set_cur_state;\n\n#ifdef CONFIG_THERMAL_GOV_POWER_ALLOCATOR\n\tif (em_is_sane(cpufreq_cdev, em)) {\n\t\tcpufreq_cdev->em = em;\n\t\tcooling_ops->get_requested_power = cpufreq_get_requested_power;\n\t\tcooling_ops->state2power = cpufreq_state2power;\n\t\tcooling_ops->power2state = cpufreq_power2state;\n\t} else\n#endif\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_UNSORTED) {\n\t\tpr_err(\"%s: unsorted frequency tables are not supported\\n\",\n\t\t       __func__);\n\t\tcdev = ERR_PTR(-EINVAL);\n\t\tgoto free_idle_time;\n\t}\n\n\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t   &cpufreq_cdev->qos_req, FREQ_QOS_MAX,\n\t\t\t\t   get_state_freq(cpufreq_cdev, 0));\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Failed to add freq constraint (%d)\\n\", __func__,\n\t\t       ret);\n\t\tcdev = ERR_PTR(ret);\n\t\tgoto free_idle_time;\n\t}\n\n\tcdev = ERR_PTR(-ENOMEM);\n\tname = kasprintf(GFP_KERNEL, \"cpufreq-%s\", dev_name(dev));\n\tif (!name)\n\t\tgoto remove_qos_req;\n\n\tcdev = thermal_of_cooling_device_register(np, name, cpufreq_cdev,\n\t\t\t\t\t\t  cooling_ops);\n\tkfree(name);\n\n\tif (IS_ERR(cdev))\n\t\tgoto remove_qos_req;\n\n\treturn cdev;\n\nremove_qos_req:\n\tfreq_qos_remove_request(&cpufreq_cdev->qos_req);\nfree_idle_time:\n\tfree_idle_time(cpufreq_cdev);\nfree_cdev:\n\tkfree(cpufreq_cdev);\n\treturn cdev;\n}\n\n \nstruct thermal_cooling_device *\ncpufreq_cooling_register(struct cpufreq_policy *policy)\n{\n\treturn __cpufreq_cooling_register(NULL, policy, NULL);\n}\nEXPORT_SYMBOL_GPL(cpufreq_cooling_register);\n\n \nstruct thermal_cooling_device *\nof_cpufreq_cooling_register(struct cpufreq_policy *policy)\n{\n\tstruct device_node *np = of_get_cpu_node(policy->cpu, NULL);\n\tstruct thermal_cooling_device *cdev = NULL;\n\n\tif (!np) {\n\t\tpr_err(\"cpufreq_cooling: OF node not available for cpu%d\\n\",\n\t\t       policy->cpu);\n\t\treturn NULL;\n\t}\n\n\tif (of_property_present(np, \"#cooling-cells\")) {\n\t\tstruct em_perf_domain *em = em_cpu_get(policy->cpu);\n\n\t\tcdev = __cpufreq_cooling_register(np, policy, em);\n\t\tif (IS_ERR(cdev)) {\n\t\t\tpr_err(\"cpufreq_cooling: cpu%d failed to register as cooling device: %ld\\n\",\n\t\t\t       policy->cpu, PTR_ERR(cdev));\n\t\t\tcdev = NULL;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\treturn cdev;\n}\nEXPORT_SYMBOL_GPL(of_cpufreq_cooling_register);\n\n \nvoid cpufreq_cooling_unregister(struct thermal_cooling_device *cdev)\n{\n\tstruct cpufreq_cooling_device *cpufreq_cdev;\n\n\tif (!cdev)\n\t\treturn;\n\n\tcpufreq_cdev = cdev->devdata;\n\n\tthermal_cooling_device_unregister(cdev);\n\tfreq_qos_remove_request(&cpufreq_cdev->qos_req);\n\tfree_idle_time(cpufreq_cdev);\n\tkfree(cpufreq_cdev);\n}\nEXPORT_SYMBOL_GPL(cpufreq_cooling_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}