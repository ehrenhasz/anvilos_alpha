{
  "module_name": "sprd_thermal.c",
  "hash_id": "776f1267b0d867c171ec4dbd5b3ebbe358630708156cf1cc5d3d843f41f65692",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/sprd_thermal.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#define SPRD_THM_CTL\t\t\t0x0\n#define SPRD_THM_INT_EN\t\t\t0x4\n#define SPRD_THM_INT_STS\t\t0x8\n#define SPRD_THM_INT_RAW_STS\t\t0xc\n#define SPRD_THM_DET_PERIOD\t\t0x10\n#define SPRD_THM_INT_CLR\t\t0x14\n#define SPRD_THM_INT_CLR_ST\t\t0x18\n#define SPRD_THM_MON_PERIOD\t\t0x4c\n#define SPRD_THM_MON_CTL\t\t0x50\n#define SPRD_THM_INTERNAL_STS1\t\t0x54\n#define SPRD_THM_RAW_READ_MSK\t\t0x3ff\n\n#define SPRD_THM_OFFSET(id)\t\t((id) * 0x4)\n#define SPRD_THM_TEMP(id)\t\t(SPRD_THM_OFFSET(id) + 0x5c)\n#define SPRD_THM_THRES(id)\t\t(SPRD_THM_OFFSET(id) + 0x2c)\n\n#define SPRD_THM_SEN(id)\t\tBIT((id) + 2)\n#define SPRD_THM_SEN_OVERHEAT_EN(id)\tBIT((id) + 8)\n#define SPRD_THM_SEN_OVERHEAT_ALARM_EN(id)\tBIT((id) + 0)\n\n \n#define SPRD_THM_SET_RDY_ST\t\tBIT(13)\n#define SPRD_THM_SET_RDY\t\tBIT(12)\n#define SPRD_THM_MON_EN\t\t\tBIT(1)\n#define SPRD_THM_EN\t\t\tBIT(0)\n\n \n#define SPRD_THM_BIT_INT_EN\t\tBIT(26)\n#define SPRD_THM_OVERHEAT_EN\t\tBIT(25)\n#define SPRD_THM_OTP_TRIP_SHIFT\t\t10\n\n \n#define SPRD_THM_TEMPER_RDY\t\tBIT(0)\n\n#define SPRD_THM_DET_PERIOD_DATA\t0x800\n#define SPRD_THM_DET_PERIOD_MASK\tGENMASK(19, 0)\n#define SPRD_THM_MON_MODE\t\t0x7\n#define SPRD_THM_MON_MODE_MASK\t\tGENMASK(3, 0)\n#define SPRD_THM_MON_PERIOD_DATA\t0x10\n#define SPRD_THM_MON_PERIOD_MASK\tGENMASK(15, 0)\n#define SPRD_THM_THRES_MASK\t\tGENMASK(19, 0)\n#define SPRD_THM_INT_CLR_MASK\t\tGENMASK(24, 0)\n\n \n#define SPRD_THM_TEMP_LOW\t\t-40000\n#define SPRD_THM_TEMP_HIGH\t\t120000\n#define SPRD_THM_OTP_TEMP\t\t120000\n#define SPRD_THM_HOT_TEMP\t\t75000\n#define SPRD_THM_RAW_DATA_LOW\t\t0\n#define SPRD_THM_RAW_DATA_HIGH\t\t1000\n#define SPRD_THM_SEN_NUM\t\t8\n#define SPRD_THM_DT_OFFSET\t\t24\n#define SPRD_THM_RATION_OFFSET\t\t17\n#define SPRD_THM_RATION_SIGN\t\t16\n\n#define SPRD_THM_RDYST_POLLING_TIME\t10\n#define SPRD_THM_RDYST_TIMEOUT\t\t700\n#define SPRD_THM_TEMP_READY_POLL_TIME\t10000\n#define SPRD_THM_TEMP_READY_TIMEOUT\t600000\n#define SPRD_THM_MAX_SENSOR\t\t8\n\nstruct sprd_thermal_sensor {\n\tstruct thermal_zone_device *tzd;\n\tstruct sprd_thermal_data *data;\n\tstruct device *dev;\n\tint cal_slope;\n\tint cal_offset;\n\tint id;\n};\n\nstruct sprd_thermal_data {\n\tconst struct sprd_thm_variant_data *var_data;\n\tstruct sprd_thermal_sensor *sensor[SPRD_THM_MAX_SENSOR];\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tu32 ratio_off;\n\tint ratio_sign;\n\tint nr_sensors;\n};\n\n \nstruct sprd_thm_variant_data {\n\tu32 ideal_k;\n\tu32 ideal_b;\n};\n\nstatic const struct sprd_thm_variant_data ums512_data = {\n\t.ideal_k = 262,\n\t.ideal_b = 66400,\n};\n\nstatic inline void sprd_thm_update_bits(void __iomem *reg, u32 mask, u32 val)\n{\n\tu32 tmp, orig;\n\n\torig = readl(reg);\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\twritel(tmp, reg);\n}\n\nstatic int sprd_thm_cal_read(struct device_node *np, const char *cell_id,\n\t\t\t     u32 *val)\n{\n\tstruct nvmem_cell *cell;\n\tvoid *buf;\n\tsize_t len;\n\n\tcell = of_nvmem_cell_get(np, cell_id);\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tbuf = nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (len > sizeof(u32)) {\n\t\tkfree(buf);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(val, buf, len);\n\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic int sprd_thm_sensor_calibration(struct device_node *np,\n\t\t\t\t       struct sprd_thermal_data *thm,\n\t\t\t\t       struct sprd_thermal_sensor *sen)\n{\n\tint ret;\n\t \n\tint dt_offset = 64, ratio = 1000;\n\n\tret = sprd_thm_cal_read(np, \"sen_delta_cal\", &dt_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tratio += thm->ratio_sign * thm->ratio_off;\n\n\t \n\tsen->cal_slope = (thm->var_data->ideal_k * ratio) / 1000;\n\tsen->cal_offset = thm->var_data->ideal_b + (dt_offset - 128) * 250;\n\n\treturn 0;\n}\n\nstatic int sprd_thm_rawdata_to_temp(struct sprd_thermal_sensor *sen,\n\t\t\t\t    u32 rawdata)\n{\n\tclamp(rawdata, (u32)SPRD_THM_RAW_DATA_LOW, (u32)SPRD_THM_RAW_DATA_HIGH);\n\n\t \n\treturn sen->cal_slope * rawdata - sen->cal_offset;\n}\n\nstatic int sprd_thm_temp_to_rawdata(int temp, struct sprd_thermal_sensor *sen)\n{\n\tu32 val;\n\n\tclamp(temp, (int)SPRD_THM_TEMP_LOW, (int)SPRD_THM_TEMP_HIGH);\n\n\t \n\tval = (temp + sen->cal_offset) / sen->cal_slope;\n\n\treturn clamp(val, val, (u32)(SPRD_THM_RAW_DATA_HIGH - 1));\n}\n\nstatic int sprd_thm_read_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct sprd_thermal_sensor *sen = thermal_zone_device_priv(tz);\n\tu32 data;\n\n\tdata = readl(sen->data->base + SPRD_THM_TEMP(sen->id)) &\n\t\tSPRD_THM_RAW_READ_MSK;\n\n\t*temp = sprd_thm_rawdata_to_temp(sen, data);\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops sprd_thm_ops = {\n\t.get_temp = sprd_thm_read_temp,\n};\n\nstatic int sprd_thm_poll_ready_status(struct sprd_thermal_data *thm)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout(thm->base + SPRD_THM_CTL, val,\n\t\t\t\t !(val & SPRD_THM_SET_RDY_ST),\n\t\t\t\t SPRD_THM_RDYST_POLLING_TIME,\n\t\t\t\t SPRD_THM_RDYST_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL, SPRD_THM_MON_EN,\n\t\t\t     SPRD_THM_MON_EN);\n\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL, SPRD_THM_SET_RDY,\n\t\t\t     SPRD_THM_SET_RDY);\n\treturn 0;\n}\n\nstatic int sprd_thm_wait_temp_ready(struct sprd_thermal_data *thm)\n{\n\tu32 val;\n\n\t \n\treturn readl_poll_timeout(thm->base + SPRD_THM_INTERNAL_STS1, val,\n\t\t\t\t  !(val & SPRD_THM_TEMPER_RDY),\n\t\t\t\t  SPRD_THM_TEMP_READY_POLL_TIME,\n\t\t\t\t  SPRD_THM_TEMP_READY_TIMEOUT);\n}\n\nstatic int sprd_thm_set_ready(struct sprd_thermal_data *thm)\n{\n\tint ret;\n\n\tret = sprd_thm_poll_ready_status(thm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(SPRD_THM_INT_CLR_MASK, thm->base + SPRD_THM_INT_CLR);\n\tsprd_thm_update_bits(thm->base + SPRD_THM_INT_EN,\n\t\t\t     SPRD_THM_BIT_INT_EN, SPRD_THM_BIT_INT_EN);\n\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL,\n\t\t\t     SPRD_THM_EN, SPRD_THM_EN);\n\treturn 0;\n}\n\nstatic void sprd_thm_sensor_init(struct sprd_thermal_data *thm,\n\t\t\t\t struct sprd_thermal_sensor *sen)\n{\n\tu32 otp_rawdata, hot_rawdata;\n\n\totp_rawdata = sprd_thm_temp_to_rawdata(SPRD_THM_OTP_TEMP, sen);\n\thot_rawdata = sprd_thm_temp_to_rawdata(SPRD_THM_HOT_TEMP, sen);\n\n\t \n\tsprd_thm_update_bits(thm->base + SPRD_THM_INT_EN,\n\t\t\t     SPRD_THM_SEN_OVERHEAT_ALARM_EN(sen->id),\n\t\t\t     SPRD_THM_SEN_OVERHEAT_ALARM_EN(sen->id));\n\n\t \n\tsprd_thm_update_bits(thm->base + SPRD_THM_THRES(sen->id),\n\t\t\t     SPRD_THM_THRES_MASK,\n\t\t\t     (otp_rawdata << SPRD_THM_OTP_TRIP_SHIFT) |\n\t\t\t     hot_rawdata);\n\n\t \n\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL, SPRD_THM_SEN(sen->id),\n\t\t\t     SPRD_THM_SEN(sen->id));\n}\n\nstatic void sprd_thm_para_config(struct sprd_thermal_data *thm)\n{\n\t \n\tsprd_thm_update_bits(thm->base + SPRD_THM_DET_PERIOD,\n\t\t\t     SPRD_THM_DET_PERIOD_MASK, SPRD_THM_DET_PERIOD);\n\n\t \n\tsprd_thm_update_bits(thm->base + SPRD_THM_MON_CTL,\n\t\t\t     SPRD_THM_MON_MODE_MASK, SPRD_THM_MON_MODE);\n\n\t \n\tsprd_thm_update_bits(thm->base + SPRD_THM_MON_PERIOD,\n\t\t\t     SPRD_THM_MON_PERIOD_MASK, SPRD_THM_MON_PERIOD);\n}\n\nstatic void sprd_thm_toggle_sensor(struct sprd_thermal_sensor *sen, bool on)\n{\n\tstruct thermal_zone_device *tzd = sen->tzd;\n\n\tif (on)\n\t\tthermal_zone_device_enable(tzd);\n\telse\n\t\tthermal_zone_device_disable(tzd);\n}\n\nstatic int sprd_thm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *sen_child;\n\tstruct sprd_thermal_data *thm;\n\tstruct sprd_thermal_sensor *sen;\n\tconst struct sprd_thm_variant_data *pdata;\n\tint ret, i;\n\tu32 val;\n\n\tpdata = of_device_get_match_data(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tthm = devm_kzalloc(&pdev->dev, sizeof(*thm), GFP_KERNEL);\n\tif (!thm)\n\t\treturn -ENOMEM;\n\n\tthm->var_data = pdata;\n\tthm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(thm->base))\n\t\treturn PTR_ERR(thm->base);\n\n\tthm->nr_sensors = of_get_child_count(np);\n\tif (thm->nr_sensors == 0 || thm->nr_sensors > SPRD_THM_MAX_SENSOR) {\n\t\tdev_err(&pdev->dev, \"incorrect sensor count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tthm->clk = devm_clk_get(&pdev->dev, \"enable\");\n\tif (IS_ERR(thm->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get enable clock\\n\");\n\t\treturn PTR_ERR(thm->clk);\n\t}\n\n\tret = clk_prepare_enable(thm->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_thm_para_config(thm);\n\n\tret = sprd_thm_cal_read(np, \"thm_sign_cal\", &val);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tif (val > 0)\n\t\tthm->ratio_sign = -1;\n\telse\n\t\tthm->ratio_sign = 1;\n\n\tret = sprd_thm_cal_read(np, \"thm_ratio_cal\", &thm->ratio_off);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tfor_each_child_of_node(np, sen_child) {\n\t\tsen = devm_kzalloc(&pdev->dev, sizeof(*sen), GFP_KERNEL);\n\t\tif (!sen) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto of_put;\n\t\t}\n\n\t\tsen->data = thm;\n\t\tsen->dev = &pdev->dev;\n\n\t\tret = of_property_read_u32(sen_child, \"reg\", &sen->id);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"get sensor reg failed\");\n\t\t\tgoto of_put;\n\t\t}\n\n\t\tret = sprd_thm_sensor_calibration(sen_child, thm, sen);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"efuse cal analysis failed\");\n\t\t\tgoto of_put;\n\t\t}\n\n\t\tsprd_thm_sensor_init(thm, sen);\n\n\t\tsen->tzd = devm_thermal_of_zone_register(sen->dev,\n\t\t\t\t\t\t\t sen->id,\n\t\t\t\t\t\t\t sen,\n\t\t\t\t\t\t\t &sprd_thm_ops);\n\t\tif (IS_ERR(sen->tzd)) {\n\t\t\tdev_err(&pdev->dev, \"register thermal zone failed %d\\n\",\n\t\t\t\tsen->id);\n\t\t\tret = PTR_ERR(sen->tzd);\n\t\t\tgoto of_put;\n\t\t}\n\n\t\tthm->sensor[sen->id] = sen;\n\t}\n\t \n\n\tret = sprd_thm_set_ready(thm);\n\tif (ret)\n\t\tgoto of_put;\n\n\tret = sprd_thm_wait_temp_ready(thm);\n\tif (ret)\n\t\tgoto of_put;\n\n\tfor (i = 0; i < thm->nr_sensors; i++)\n\t\tsprd_thm_toggle_sensor(thm->sensor[i], true);\n\n\tplatform_set_drvdata(pdev, thm);\n\treturn 0;\n\nof_put:\n\tof_node_put(sen_child);\ndisable_clk:\n\tclk_disable_unprepare(thm->clk);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void sprd_thm_hw_suspend(struct sprd_thermal_data *thm)\n{\n\tint i;\n\n\tfor (i = 0; i < thm->nr_sensors; i++) {\n\t\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL,\n\t\t\t\t     SPRD_THM_SEN(thm->sensor[i]->id), 0);\n\t}\n\n\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL,\n\t\t\t     SPRD_THM_EN, 0x0);\n}\n\nstatic int sprd_thm_suspend(struct device *dev)\n{\n\tstruct sprd_thermal_data *thm = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < thm->nr_sensors; i++)\n\t\tsprd_thm_toggle_sensor(thm->sensor[i], false);\n\n\tsprd_thm_hw_suspend(thm);\n\tclk_disable_unprepare(thm->clk);\n\n\treturn 0;\n}\n\nstatic int sprd_thm_hw_resume(struct sprd_thermal_data *thm)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < thm->nr_sensors; i++) {\n\t\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL,\n\t\t\t\t     SPRD_THM_SEN(thm->sensor[i]->id),\n\t\t\t\t     SPRD_THM_SEN(thm->sensor[i]->id));\n\t}\n\n\tret = sprd_thm_poll_ready_status(thm);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(SPRD_THM_INT_CLR_MASK, thm->base + SPRD_THM_INT_CLR);\n\tsprd_thm_update_bits(thm->base + SPRD_THM_CTL,\n\t\t\t     SPRD_THM_EN, SPRD_THM_EN);\n\treturn sprd_thm_wait_temp_ready(thm);\n}\n\nstatic int sprd_thm_resume(struct device *dev)\n{\n\tstruct sprd_thermal_data *thm = dev_get_drvdata(dev);\n\tint ret, i;\n\n\tret = clk_prepare_enable(thm->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sprd_thm_hw_resume(thm);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tfor (i = 0; i < thm->nr_sensors; i++)\n\t\tsprd_thm_toggle_sensor(thm->sensor[i], true);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(thm->clk);\n\treturn ret;\n}\n#endif\n\nstatic int sprd_thm_remove(struct platform_device *pdev)\n{\n\tstruct sprd_thermal_data *thm = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < thm->nr_sensors; i++) {\n\t\tsprd_thm_toggle_sensor(thm->sensor[i], false);\n\t\tdevm_thermal_of_zone_unregister(&pdev->dev,\n\t\t\t\t\t\tthm->sensor[i]->tzd);\n\t}\n\n\tclk_disable_unprepare(thm->clk);\n\treturn 0;\n}\n\nstatic const struct of_device_id sprd_thermal_of_match[] = {\n\t{ .compatible = \"sprd,ums512-thermal\", .data = &ums512_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_thermal_of_match);\n\nstatic const struct dev_pm_ops sprd_thermal_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sprd_thm_suspend, sprd_thm_resume)\n};\n\nstatic struct platform_driver sprd_thermal_driver = {\n\t.probe = sprd_thm_probe,\n\t.remove = sprd_thm_remove,\n\t.driver = {\n\t\t.name = \"sprd-thermal\",\n\t\t.pm = &sprd_thermal_pm_ops,\n\t\t.of_match_table = sprd_thermal_of_match,\n\t},\n};\n\nmodule_platform_driver(sprd_thermal_driver);\n\nMODULE_AUTHOR(\"Freeman Liu <freeman.liu@unisoc.com>\");\nMODULE_DESCRIPTION(\"Spreadtrum thermal driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}