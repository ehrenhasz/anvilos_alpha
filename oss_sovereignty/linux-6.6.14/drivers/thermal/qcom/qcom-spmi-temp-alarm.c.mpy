{
  "module_name": "qcom-spmi-temp-alarm.c",
  "hash_id": "5a35fd38b4a3760379c3351a9ec485c82353f95c5768d7aa93a6d2d9bf45a209",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/qcom/qcom-spmi-temp-alarm.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n\n#include \"../thermal_hwmon.h\"\n\n#define QPNP_TM_REG_DIG_MAJOR\t\t0x01\n#define QPNP_TM_REG_TYPE\t\t0x04\n#define QPNP_TM_REG_SUBTYPE\t\t0x05\n#define QPNP_TM_REG_STATUS\t\t0x08\n#define QPNP_TM_REG_SHUTDOWN_CTRL1\t0x40\n#define QPNP_TM_REG_ALARM_CTRL\t\t0x46\n\n#define QPNP_TM_TYPE\t\t\t0x09\n#define QPNP_TM_SUBTYPE_GEN1\t\t0x08\n#define QPNP_TM_SUBTYPE_GEN2\t\t0x09\n\n#define STATUS_GEN1_STAGE_MASK\t\tGENMASK(1, 0)\n#define STATUS_GEN2_STATE_MASK\t\tGENMASK(6, 4)\n#define STATUS_GEN2_STATE_SHIFT\t\t4\n\n#define SHUTDOWN_CTRL1_OVERRIDE_S2\tBIT(6)\n#define SHUTDOWN_CTRL1_THRESHOLD_MASK\tGENMASK(1, 0)\n\n#define SHUTDOWN_CTRL1_RATE_25HZ\tBIT(3)\n\n#define ALARM_CTRL_FORCE_ENABLE\t\tBIT(7)\n\n#define THRESH_COUNT\t\t\t4\n#define STAGE_COUNT\t\t\t3\n\n \nstatic const long temp_map_gen1[THRESH_COUNT][STAGE_COUNT] = {\n\t{ 105000, 125000, 145000 },\n\t{ 110000, 130000, 150000 },\n\t{ 115000, 135000, 155000 },\n\t{ 120000, 140000, 160000 },\n};\n\nstatic const long temp_map_gen2_v1[THRESH_COUNT][STAGE_COUNT] = {\n\t{  90000, 110000, 140000 },\n\t{  95000, 115000, 145000 },\n\t{ 100000, 120000, 150000 },\n\t{ 105000, 125000, 155000 },\n};\n\n#define TEMP_THRESH_STEP\t\t5000  \n\n#define THRESH_MIN\t\t\t0\n#define THRESH_MAX\t\t\t3\n\n#define TEMP_STAGE_HYSTERESIS\t\t2000\n\n \n#define DEFAULT_TEMP\t\t\t37000\n\nstruct qpnp_tm_chip {\n\tstruct regmap\t\t\t*map;\n\tstruct device\t\t\t*dev;\n\tstruct thermal_zone_device\t*tz_dev;\n\tunsigned int\t\t\tsubtype;\n\tlong\t\t\t\ttemp;\n\tunsigned int\t\t\tthresh;\n\tunsigned int\t\t\tstage;\n\tunsigned int\t\t\tprev_stage;\n\tunsigned int\t\t\tbase;\n\t \n\tstruct mutex\t\t\tlock;\n\tbool\t\t\t\tinitialized;\n\n\tstruct iio_channel\t\t*adc;\n\tconst long\t\t\t(*temp_map)[THRESH_COUNT][STAGE_COUNT];\n};\n\n \nstatic const unsigned int alarm_state_map[8] = {0, 1, 1, 2, 2, 3, 3, 3};\n\nstatic int qpnp_tm_read(struct qpnp_tm_chip *chip, u16 addr, u8 *data)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(chip->map, chip->base + addr, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = val;\n\treturn 0;\n}\n\nstatic int qpnp_tm_write(struct qpnp_tm_chip *chip, u16 addr, u8 data)\n{\n\treturn regmap_write(chip->map, chip->base + addr, data);\n}\n\n \nstatic long qpnp_tm_decode_temp(struct qpnp_tm_chip *chip, unsigned int stage)\n{\n\tif (!chip->temp_map || chip->thresh >= THRESH_COUNT || stage == 0 ||\n\t    stage > STAGE_COUNT)\n\t\treturn 0;\n\n\treturn (*chip->temp_map)[chip->thresh][stage - 1];\n}\n\n \nstatic int qpnp_tm_get_temp_stage(struct qpnp_tm_chip *chip)\n{\n\tint ret;\n\tu8 reg = 0;\n\n\tret = qpnp_tm_read(chip, QPNP_TM_REG_STATUS, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (chip->subtype == QPNP_TM_SUBTYPE_GEN1)\n\t\tret = reg & STATUS_GEN1_STAGE_MASK;\n\telse\n\t\tret = (reg & STATUS_GEN2_STATE_MASK) >> STATUS_GEN2_STATE_SHIFT;\n\n\treturn ret;\n}\n\n \nstatic int qpnp_tm_update_temp_no_adc(struct qpnp_tm_chip *chip)\n{\n\tunsigned int stage, stage_new, stage_old;\n\tint ret;\n\n\tWARN_ON(!mutex_is_locked(&chip->lock));\n\n\tret = qpnp_tm_get_temp_stage(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tstage = ret;\n\n\tif (chip->subtype == QPNP_TM_SUBTYPE_GEN1) {\n\t\tstage_new = stage;\n\t\tstage_old = chip->stage;\n\t} else {\n\t\tstage_new = alarm_state_map[stage];\n\t\tstage_old = alarm_state_map[chip->stage];\n\t}\n\n\tif (stage_new > stage_old) {\n\t\t \n\t\tchip->temp = qpnp_tm_decode_temp(chip, stage_new)\n\t\t\t\t+ TEMP_STAGE_HYSTERESIS;\n\t} else if (stage_new < stage_old) {\n\t\t \n\t\tchip->temp = qpnp_tm_decode_temp(chip, stage_new + 1)\n\t\t\t\t- TEMP_STAGE_HYSTERESIS;\n\t}\n\n\tchip->stage = stage;\n\n\treturn 0;\n}\n\nstatic int qpnp_tm_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct qpnp_tm_chip *chip = thermal_zone_device_priv(tz);\n\tint ret, mili_celsius;\n\n\tif (!temp)\n\t\treturn -EINVAL;\n\n\tif (!chip->initialized) {\n\t\t*temp = DEFAULT_TEMP;\n\t\treturn 0;\n\t}\n\n\tif (!chip->adc) {\n\t\tmutex_lock(&chip->lock);\n\t\tret = qpnp_tm_update_temp_no_adc(chip);\n\t\tmutex_unlock(&chip->lock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = iio_read_channel_processed(chip->adc, &mili_celsius);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchip->temp = mili_celsius;\n\t}\n\n\t*temp = chip->temp;\n\n\treturn 0;\n}\n\nstatic int qpnp_tm_update_critical_trip_temp(struct qpnp_tm_chip *chip,\n\t\t\t\t\t     int temp)\n{\n\tlong stage2_threshold_min = (*chip->temp_map)[THRESH_MIN][1];\n\tlong stage2_threshold_max = (*chip->temp_map)[THRESH_MAX][1];\n\tbool disable_s2_shutdown = false;\n\tu8 reg;\n\n\tWARN_ON(!mutex_is_locked(&chip->lock));\n\n\t \n\treg = SHUTDOWN_CTRL1_RATE_25HZ;\n\n\tif (temp == THERMAL_TEMP_INVALID ||\n\t    temp < stage2_threshold_min) {\n\t\tchip->thresh = THRESH_MIN;\n\t\tgoto skip;\n\t}\n\n\tif (temp <= stage2_threshold_max) {\n\t\tchip->thresh = THRESH_MAX -\n\t\t\t((stage2_threshold_max - temp) /\n\t\t\t TEMP_THRESH_STEP);\n\t\tdisable_s2_shutdown = true;\n\t} else {\n\t\tchip->thresh = THRESH_MAX;\n\n\t\tif (chip->adc)\n\t\t\tdisable_s2_shutdown = true;\n\t\telse\n\t\t\tdev_warn(chip->dev,\n\t\t\t\t \"No ADC is configured and critical temperature %d mC is above the maximum stage 2 threshold of %ld mC! Configuring stage 2 shutdown at %ld mC.\\n\",\n\t\t\t\t temp, stage2_threshold_max, stage2_threshold_max);\n\t}\n\nskip:\n\treg |= chip->thresh;\n\tif (disable_s2_shutdown)\n\t\treg |= SHUTDOWN_CTRL1_OVERRIDE_S2;\n\n\treturn qpnp_tm_write(chip, QPNP_TM_REG_SHUTDOWN_CTRL1, reg);\n}\n\nstatic int qpnp_tm_set_trip_temp(struct thermal_zone_device *tz, int trip_id, int temp)\n{\n\tstruct qpnp_tm_chip *chip = thermal_zone_device_priv(tz);\n\tstruct thermal_trip trip;\n\tint ret;\n\n\tret = __thermal_zone_get_trip(chip->tz_dev, trip_id, &trip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trip.type != THERMAL_TRIP_CRITICAL)\n\t\treturn 0;\n\n\tmutex_lock(&chip->lock);\n\tret = qpnp_tm_update_critical_trip_temp(chip, temp);\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic const struct thermal_zone_device_ops qpnp_tm_sensor_ops = {\n\t.get_temp = qpnp_tm_get_temp,\n\t.set_trip_temp = qpnp_tm_set_trip_temp,\n};\n\nstatic irqreturn_t qpnp_tm_isr(int irq, void *data)\n{\n\tstruct qpnp_tm_chip *chip = data;\n\n\tthermal_zone_device_update(chip->tz_dev, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qpnp_tm_get_critical_trip_temp(struct qpnp_tm_chip *chip)\n{\n\tstruct thermal_trip trip;\n\tint i, ret;\n\n\tfor (i = 0; i < thermal_zone_get_num_trips(chip->tz_dev); i++) {\n\n\t\tret = thermal_zone_get_trip(chip->tz_dev, i, &trip);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (trip.type == THERMAL_TRIP_CRITICAL)\n\t\t\treturn trip.temperature;\n\t}\n\n\treturn THERMAL_TEMP_INVALID;\n}\n\n \nstatic int qpnp_tm_init(struct qpnp_tm_chip *chip)\n{\n\tunsigned int stage;\n\tint ret;\n\tu8 reg = 0;\n\tint crit_temp;\n\n\tmutex_lock(&chip->lock);\n\n\tret = qpnp_tm_read(chip, QPNP_TM_REG_SHUTDOWN_CTRL1, &reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tchip->thresh = reg & SHUTDOWN_CTRL1_THRESHOLD_MASK;\n\tchip->temp = DEFAULT_TEMP;\n\n\tret = qpnp_tm_get_temp_stage(chip);\n\tif (ret < 0)\n\t\tgoto out;\n\tchip->stage = ret;\n\n\tstage = chip->subtype == QPNP_TM_SUBTYPE_GEN1\n\t\t? chip->stage : alarm_state_map[chip->stage];\n\n\tif (stage)\n\t\tchip->temp = qpnp_tm_decode_temp(chip, stage);\n\n\tmutex_unlock(&chip->lock);\n\n\tcrit_temp = qpnp_tm_get_critical_trip_temp(chip);\n\n\tmutex_lock(&chip->lock);\n\n\tret = qpnp_tm_update_critical_trip_temp(chip, crit_temp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\treg = ALARM_CTRL_FORCE_ENABLE;\n\tret = qpnp_tm_write(chip, QPNP_TM_REG_ALARM_CTRL, reg);\n\n\tchip->initialized = true;\n\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nstatic int qpnp_tm_probe(struct platform_device *pdev)\n{\n\tstruct qpnp_tm_chip *chip;\n\tstruct device_node *node;\n\tu8 type, subtype, dig_major;\n\tu32 res;\n\tint ret, irq;\n\n\tnode = pdev->dev.of_node;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, chip);\n\tchip->dev = &pdev->dev;\n\n\tmutex_init(&chip->lock);\n\n\tchip->map = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!chip->map)\n\t\treturn -ENXIO;\n\n\tret = of_property_read_u32(node, \"reg\", &res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tchip->adc = devm_iio_channel_get(&pdev->dev, \"thermal\");\n\tif (IS_ERR(chip->adc)) {\n\t\tret = PTR_ERR(chip->adc);\n\t\tchip->adc = NULL;\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tchip->base = res;\n\n\tret = qpnp_tm_read(chip, QPNP_TM_REG_TYPE, &type);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"could not read type\\n\");\n\n\tret = qpnp_tm_read(chip, QPNP_TM_REG_SUBTYPE, &subtype);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"could not read subtype\\n\");\n\n\tret = qpnp_tm_read(chip, QPNP_TM_REG_DIG_MAJOR, &dig_major);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"could not read dig_major\\n\");\n\n\tif (type != QPNP_TM_TYPE || (subtype != QPNP_TM_SUBTYPE_GEN1\n\t\t\t\t     && subtype != QPNP_TM_SUBTYPE_GEN2)) {\n\t\tdev_err(&pdev->dev, \"invalid type 0x%02x or subtype 0x%02x\\n\",\n\t\t\ttype, subtype);\n\t\treturn -ENODEV;\n\t}\n\n\tchip->subtype = subtype;\n\tif (subtype == QPNP_TM_SUBTYPE_GEN2 && dig_major >= 1)\n\t\tchip->temp_map = &temp_map_gen2_v1;\n\telse\n\t\tchip->temp_map = &temp_map_gen1;\n\n\t \n\tchip->tz_dev = devm_thermal_of_zone_register(\n\t\t&pdev->dev, 0, chip, &qpnp_tm_sensor_ops);\n\tif (IS_ERR(chip->tz_dev))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(chip->tz_dev),\n\t\t\t\t     \"failed to register sensor\\n\");\n\n\tret = qpnp_tm_init(chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"init failed\\n\");\n\n\tdevm_thermal_add_hwmon_sysfs(&pdev->dev, chip->tz_dev);\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL, qpnp_tm_isr,\n\t\t\t\t\tIRQF_ONESHOT, node->name, chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tthermal_zone_device_update(chip->tz_dev, THERMAL_EVENT_UNSPECIFIED);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qpnp_tm_match_table[] = {\n\t{ .compatible = \"qcom,spmi-temp-alarm\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qpnp_tm_match_table);\n\nstatic struct platform_driver qpnp_tm_driver = {\n\t.driver = {\n\t\t.name = \"spmi-temp-alarm\",\n\t\t.of_match_table = qpnp_tm_match_table,\n\t},\n\t.probe  = qpnp_tm_probe,\n};\nmodule_platform_driver(qpnp_tm_driver);\n\nMODULE_ALIAS(\"platform:spmi-temp-alarm\");\nMODULE_DESCRIPTION(\"QPNP PMIC Temperature Alarm driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}