{
  "module_name": "tsens-v1.c",
  "hash_id": "eed67f3b5aca42c5b329745ca7e83182d8ce9bd631e5044ee4a347a1cd89aa85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/qcom/tsens-v1.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include \"tsens.h\"\n\n \n#define SROT_HW_VER_OFF\t0x0000\n#define SROT_CTRL_OFF\t\t0x0004\n\n \n#define TM_INT_EN_OFF\t\t\t\t0x0000\n#define TM_Sn_UPPER_LOWER_STATUS_CTRL_OFF\t0x0004\n#define TM_Sn_STATUS_OFF\t\t\t0x0044\n#define TM_TRDY_OFF\t\t\t\t0x0084\n#define TM_HIGH_LOW_INT_STATUS_OFF\t\t0x0088\n#define TM_HIGH_LOW_Sn_INT_THRESHOLD_OFF\t0x0090\n\nstatic struct tsens_legacy_calibration_format tsens_qcs404_nvmem = {\n\t.base_len = 8,\n\t.base_shift = 2,\n\t.sp_len = 6,\n\t.mode = { 4, 0 },\n\t.invalid = { 4, 2 },\n\t.base = { { 4, 3 }, { 4, 11 } },\n\t.sp = {\n\t\t{ { 0, 0 }, { 0, 6 } },\n\t\t{ { 0, 12 }, { 0, 18 } },\n\t\t{ { 0, 24 }, { 0, 30 } },\n\t\t{ { 1, 4 },  { 1, 10 } },\n\t\t{ { 1, 16 }, { 1, 22 } },\n\t\t{ { 2, 0 },  { 2, 6 } },\n\t\t{ { 2, 12 }, { 2, 18 } },\n\t\t{ { 2, 24 }, { 2, 30 } },\n\t\t{ { 3, 4 },  { 3, 10 } },\n\t\t{ { 3, 16 }, { 3, 22 } },\n\t},\n};\n\nstatic int calibrate_v1(struct tsens_priv *priv)\n{\n\tu32 p1[10], p2[10];\n\tu32 *qfprom_cdata;\n\tint mode, ret;\n\n\tret = tsens_calibrate_common(priv);\n\tif (!ret)\n\t\treturn 0;\n\n\tqfprom_cdata = (u32 *)qfprom_read(priv->dev, \"calib\");\n\tif (IS_ERR(qfprom_cdata))\n\t\treturn PTR_ERR(qfprom_cdata);\n\n\tmode = tsens_read_calibration_legacy(priv, &tsens_qcs404_nvmem,\n\t\t\t\t\t     p1, p2,\n\t\t\t\t\t     qfprom_cdata, NULL);\n\n\tcompute_intercept_slope(priv, p1, p2, mode);\n\tkfree(qfprom_cdata);\n\n\treturn 0;\n}\n\n \n\nstatic struct tsens_features tsens_v1_feat = {\n\t.ver_major\t= VER_1_X,\n\t.crit_int\t= 0,\n\t.combo_int\t= 0,\n\t.adc\t\t= 1,\n\t.srot_split\t= 1,\n\t.max_sensors\t= 11,\n\t.trip_min_temp\t= -40000,\n\t.trip_max_temp\t= 120000,\n};\n\nstatic const struct reg_field tsens_v1_regfields[MAX_REGFIELDS] = {\n\t \n\t \n\t[VER_MAJOR] = REG_FIELD(SROT_HW_VER_OFF, 28, 31),\n\t[VER_MINOR] = REG_FIELD(SROT_HW_VER_OFF, 16, 27),\n\t[VER_STEP]  = REG_FIELD(SROT_HW_VER_OFF,  0, 15),\n\t \n\t[TSENS_EN]     = REG_FIELD(SROT_CTRL_OFF, 0,  0),\n\t[TSENS_SW_RST] = REG_FIELD(SROT_CTRL_OFF, 1,  1),\n\t[SENSOR_EN]    = REG_FIELD(SROT_CTRL_OFF, 3, 13),\n\n\t \n\t \n\t[INT_EN]     = REG_FIELD(TM_INT_EN_OFF, 0, 0),\n\n\t \n\tREG_FIELD_FOR_EACH_SENSOR11(LOW_THRESH,    TM_Sn_UPPER_LOWER_STATUS_CTRL_OFF,  0,  9),\n\tREG_FIELD_FOR_EACH_SENSOR11(UP_THRESH,     TM_Sn_UPPER_LOWER_STATUS_CTRL_OFF, 10, 19),\n\n\t \n\tREG_FIELD_FOR_EACH_SENSOR11(LOW_INT_CLEAR, TM_Sn_UPPER_LOWER_STATUS_CTRL_OFF, 20, 20),\n\tREG_FIELD_FOR_EACH_SENSOR11(UP_INT_CLEAR,  TM_Sn_UPPER_LOWER_STATUS_CTRL_OFF, 21, 21),\n\t[LOW_INT_STATUS_0] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  0,  0),\n\t[LOW_INT_STATUS_1] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  1,  1),\n\t[LOW_INT_STATUS_2] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  2,  2),\n\t[LOW_INT_STATUS_3] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  3,  3),\n\t[LOW_INT_STATUS_4] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  4,  4),\n\t[LOW_INT_STATUS_5] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  5,  5),\n\t[LOW_INT_STATUS_6] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  6,  6),\n\t[LOW_INT_STATUS_7] = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  7,  7),\n\t[UP_INT_STATUS_0]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  8,  8),\n\t[UP_INT_STATUS_1]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF,  9,  9),\n\t[UP_INT_STATUS_2]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF, 10, 10),\n\t[UP_INT_STATUS_3]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF, 11, 11),\n\t[UP_INT_STATUS_4]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF, 12, 12),\n\t[UP_INT_STATUS_5]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF, 13, 13),\n\t[UP_INT_STATUS_6]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF, 14, 14),\n\t[UP_INT_STATUS_7]  = REG_FIELD(TM_HIGH_LOW_INT_STATUS_OFF, 15, 15),\n\n\t \n\n\t \n\tREG_FIELD_FOR_EACH_SENSOR11(LAST_TEMP,    TM_Sn_STATUS_OFF,  0,  9),\n\tREG_FIELD_FOR_EACH_SENSOR11(VALID,        TM_Sn_STATUS_OFF, 14, 14),\n\t \n\tREG_FIELD_FOR_EACH_SENSOR11(MIN_STATUS,   TM_Sn_STATUS_OFF, 10, 10),\n\tREG_FIELD_FOR_EACH_SENSOR11(LOWER_STATUS, TM_Sn_STATUS_OFF, 11, 11),\n\tREG_FIELD_FOR_EACH_SENSOR11(UPPER_STATUS, TM_Sn_STATUS_OFF, 12, 12),\n\t \n\tREG_FIELD_FOR_EACH_SENSOR11(MAX_STATUS,   TM_Sn_STATUS_OFF, 13, 13),\n\n\t \n\t[TRDY] = REG_FIELD(TM_TRDY_OFF, 0, 0),\n};\n\nstatic int __init init_8956(struct tsens_priv *priv) {\n\tpriv->sensor[0].slope = 3313;\n\tpriv->sensor[1].slope = 3275;\n\tpriv->sensor[2].slope = 3320;\n\tpriv->sensor[3].slope = 3246;\n\tpriv->sensor[4].slope = 3279;\n\tpriv->sensor[5].slope = 3257;\n\tpriv->sensor[6].slope = 3234;\n\tpriv->sensor[7].slope = 3269;\n\tpriv->sensor[8].slope = 3255;\n\tpriv->sensor[9].slope = 3239;\n\tpriv->sensor[10].slope = 3286;\n\n\treturn init_common(priv);\n}\n\nstatic const struct tsens_ops ops_generic_v1 = {\n\t.init\t\t= init_common,\n\t.calibrate\t= calibrate_v1,\n\t.get_temp\t= get_temp_tsens_valid,\n};\n\nstruct tsens_plat_data data_tsens_v1 = {\n\t.ops\t\t= &ops_generic_v1,\n\t.feat\t\t= &tsens_v1_feat,\n\t.fields\t= tsens_v1_regfields,\n};\n\nstatic const struct tsens_ops ops_8956 = {\n\t.init\t\t= init_8956,\n\t.calibrate\t= tsens_calibrate_common,\n\t.get_temp\t= get_temp_tsens_valid,\n};\n\nstruct tsens_plat_data data_8956 = {\n\t.num_sensors\t= 11,\n\t.ops\t\t= &ops_8956,\n\t.feat\t\t= &tsens_v1_feat,\n\t.fields\t\t= tsens_v1_regfields,\n};\n\nstatic const struct tsens_ops ops_8976 = {\n\t.init\t\t= init_common,\n\t.calibrate\t= tsens_calibrate_common,\n\t.get_temp\t= get_temp_tsens_valid,\n};\n\nstruct tsens_plat_data data_8976 = {\n\t.num_sensors\t= 11,\n\t.ops\t\t= &ops_8976,\n\t.feat\t\t= &tsens_v1_feat,\n\t.fields\t\t= tsens_v1_regfields,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}