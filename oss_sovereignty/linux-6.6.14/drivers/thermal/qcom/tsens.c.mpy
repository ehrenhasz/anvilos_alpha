{
  "module_name": "tsens.c",
  "hash_id": "068afee7ae5b2e009253e9d455c68e4fee7b075278669aa7a4e95430f06579b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/qcom/tsens.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n#include \"../thermal_hwmon.h\"\n#include \"tsens.h\"\n\n \nstruct tsens_irq_data {\n\tu32 up_viol;\n\tint up_thresh;\n\tu32 up_irq_mask;\n\tu32 up_irq_clear;\n\tu32 low_viol;\n\tint low_thresh;\n\tu32 low_irq_mask;\n\tu32 low_irq_clear;\n\tu32 crit_viol;\n\tu32 crit_thresh;\n\tu32 crit_irq_mask;\n\tu32 crit_irq_clear;\n};\n\nchar *qfprom_read(struct device *dev, const char *cname)\n{\n\tstruct nvmem_cell *cell;\n\tssize_t data;\n\tchar *ret;\n\n\tcell = nvmem_cell_get(dev, cname);\n\tif (IS_ERR(cell))\n\t\treturn ERR_CAST(cell);\n\n\tret = nvmem_cell_read(cell, &data);\n\tnvmem_cell_put(cell);\n\n\treturn ret;\n}\n\nint tsens_read_calibration(struct tsens_priv *priv, int shift, u32 *p1, u32 *p2, bool backup)\n{\n\tu32 mode;\n\tu32 base1, base2;\n\tchar name[] = \"sXX_pY_backup\";  \n\tint i, ret;\n\n\tif (priv->num_sensors > MAX_SENSORS)\n\t\treturn -EINVAL;\n\n\tret = snprintf(name, sizeof(name), \"mode%s\", backup ? \"_backup\" : \"\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nvmem_cell_read_variable_le_u32(priv->dev, name, &mode);\n\tif (ret == -ENOENT)\n\t\tdev_warn(priv->dev, \"Please migrate to separate nvmem cells for calibration data\\n\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(priv->dev, \"calibration mode is %d\\n\", mode);\n\n\tret = snprintf(name, sizeof(name), \"base1%s\", backup ? \"_backup\" : \"\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nvmem_cell_read_variable_le_u32(priv->dev, name, &base1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snprintf(name, sizeof(name), \"base2%s\", backup ? \"_backup\" : \"\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nvmem_cell_read_variable_le_u32(priv->dev, name, &base2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\tret = snprintf(name, sizeof(name), \"s%d_p1%s\", priv->sensor[i].hw_id,\n\t\t\t       backup ? \"_backup\" : \"\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = nvmem_cell_read_variable_le_u32(priv->dev, name, &p1[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snprintf(name, sizeof(name), \"s%d_p2%s\", priv->sensor[i].hw_id,\n\t\t\t       backup ? \"_backup\" : \"\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = nvmem_cell_read_variable_le_u32(priv->dev, name, &p2[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (mode) {\n\tcase ONE_PT_CALIB:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp1[i] = p1[i] + (base1 << shift);\n\t\tbreak;\n\tcase TWO_PT_CALIB:\n\tcase TWO_PT_CALIB_NO_OFFSET:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp2[i] = (p2[i] + base2) << shift;\n\t\tfallthrough;\n\tcase ONE_PT_CALIB2:\n\tcase ONE_PT_CALIB2_NO_OFFSET:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp1[i] = (p1[i] + base1) << shift;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(priv->dev, \"calibrationless mode\\n\");\n\t\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\t\tp1[i] = 500;\n\t\t\tp2[i] = 780;\n\t\t}\n\t}\n\n\t \n\tswitch (mode) {\n\tcase TWO_PT_CALIB:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp2[i] += priv->sensor[i].p2_calib_offset;\n\t\tfallthrough;\n\tcase ONE_PT_CALIB2:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp1[i] += priv->sensor[i].p1_calib_offset;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nint tsens_calibrate_nvmem(struct tsens_priv *priv, int shift)\n{\n\tu32 p1[MAX_SENSORS], p2[MAX_SENSORS];\n\tint mode;\n\n\tmode = tsens_read_calibration(priv, shift, p1, p2, false);\n\tif (mode < 0)\n\t\treturn mode;\n\n\tcompute_intercept_slope(priv, p1, p2, mode);\n\n\treturn 0;\n}\n\nint tsens_calibrate_common(struct tsens_priv *priv)\n{\n\treturn tsens_calibrate_nvmem(priv, 2);\n}\n\nstatic u32 tsens_read_cell(const struct tsens_single_value *cell, u8 len, u32 *data0, u32 *data1)\n{\n\tu32 val;\n\tu32 *data = cell->blob ? data1 : data0;\n\n\tif (cell->shift + len <= 32) {\n\t\tval = data[cell->idx] >> cell->shift;\n\t} else {\n\t\tu8 part = 32 - cell->shift;\n\n\t\tval = data[cell->idx] >> cell->shift;\n\t\tval |= data[cell->idx + 1] << part;\n\t}\n\n\treturn val & ((1 << len) - 1);\n}\n\nint tsens_read_calibration_legacy(struct tsens_priv *priv,\n\t\t\t\t  const struct tsens_legacy_calibration_format *format,\n\t\t\t\t  u32 *p1, u32 *p2,\n\t\t\t\t  u32 *cdata0, u32 *cdata1)\n{\n\tu32 mode, invalid;\n\tu32 base1, base2;\n\tint i;\n\n\tmode = tsens_read_cell(&format->mode, 2, cdata0, cdata1);\n\tinvalid = tsens_read_cell(&format->invalid, 1, cdata0, cdata1);\n\tif (invalid)\n\t\tmode = NO_PT_CALIB;\n\tdev_dbg(priv->dev, \"calibration mode is %d\\n\", mode);\n\n\tbase1 = tsens_read_cell(&format->base[0], format->base_len, cdata0, cdata1);\n\tbase2 = tsens_read_cell(&format->base[1], format->base_len, cdata0, cdata1);\n\n\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\tp1[i] = tsens_read_cell(&format->sp[i][0], format->sp_len, cdata0, cdata1);\n\t\tp2[i] = tsens_read_cell(&format->sp[i][1], format->sp_len, cdata0, cdata1);\n\t}\n\n\tswitch (mode) {\n\tcase ONE_PT_CALIB:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp1[i] = p1[i] + (base1 << format->base_shift);\n\t\tbreak;\n\tcase TWO_PT_CALIB:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp2[i] = (p2[i] + base2) << format->base_shift;\n\t\tfallthrough;\n\tcase ONE_PT_CALIB2:\n\t\tfor (i = 0; i < priv->num_sensors; i++)\n\t\t\tp1[i] = (p1[i] + base1) << format->base_shift;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(priv->dev, \"calibrationless mode\\n\");\n\t\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\t\tp1[i] = 500;\n\t\t\tp2[i] = 780;\n\t\t}\n\t}\n\n\treturn mode;\n}\n\n \nvoid compute_intercept_slope(struct tsens_priv *priv, u32 *p1,\n\t\t\t     u32 *p2, u32 mode)\n{\n\tint i;\n\tint num, den;\n\n\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\tdev_dbg(priv->dev,\n\t\t\t\"%s: sensor%d - data_point1:%#x data_point2:%#x\\n\",\n\t\t\t__func__, i, p1[i], p2[i]);\n\n\t\tif (!priv->sensor[i].slope)\n\t\t\tpriv->sensor[i].slope = SLOPE_DEFAULT;\n\t\tif (mode == TWO_PT_CALIB || mode == TWO_PT_CALIB_NO_OFFSET) {\n\t\t\t \n\t\t\tnum = p2[i] - p1[i];\n\t\t\tnum *= SLOPE_FACTOR;\n\t\t\tden = CAL_DEGC_PT2 - CAL_DEGC_PT1;\n\t\t\tpriv->sensor[i].slope = num / den;\n\t\t}\n\n\t\tpriv->sensor[i].offset = (p1[i] * SLOPE_FACTOR) -\n\t\t\t\t(CAL_DEGC_PT1 *\n\t\t\t\tpriv->sensor[i].slope);\n\t\tdev_dbg(priv->dev, \"%s: offset:%d\\n\", __func__,\n\t\t\tpriv->sensor[i].offset);\n\t}\n}\n\nstatic inline u32 degc_to_code(int degc, const struct tsens_sensor *s)\n{\n\tu64 code = div_u64(((u64)degc * s->slope + s->offset), SLOPE_FACTOR);\n\n\tpr_debug(\"%s: raw_code: 0x%llx, degc:%d\\n\", __func__, code, degc);\n\treturn clamp_val(code, THRESHOLD_MIN_ADC_CODE, THRESHOLD_MAX_ADC_CODE);\n}\n\nstatic inline int code_to_degc(u32 adc_code, const struct tsens_sensor *s)\n{\n\tint degc, num, den;\n\n\tnum = (adc_code * SLOPE_FACTOR) - s->offset;\n\tden = s->slope;\n\n\tif (num > 0)\n\t\tdegc = num + (den / 2);\n\telse if (num < 0)\n\t\tdegc = num - (den / 2);\n\telse\n\t\tdegc = num;\n\n\tdegc /= den;\n\n\treturn degc;\n}\n\n \nstatic int tsens_hw_to_mC(const struct tsens_sensor *s, int field)\n{\n\tstruct tsens_priv *priv = s->priv;\n\tu32 resolution;\n\tu32 temp = 0;\n\tint ret;\n\n\tresolution = priv->fields[LAST_TEMP_0].msb -\n\t\tpriv->fields[LAST_TEMP_0].lsb;\n\n\tret = regmap_field_read(priv->rf[field], &temp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->feat->adc)\n\t\treturn code_to_degc(temp, s) * 1000;\n\n\t \n\treturn sign_extend32(temp, resolution) * 100;\n}\n\n \nstatic int tsens_mC_to_hw(const struct tsens_sensor *s, int temp)\n{\n\tstruct tsens_priv *priv = s->priv;\n\n\t \n\tif (priv->feat->adc)\n\t\treturn degc_to_code(temp / 1000, s);\n\n\t \n\treturn temp / 100;\n}\n\nstatic inline enum tsens_ver tsens_version(struct tsens_priv *priv)\n{\n\treturn priv->feat->ver_major;\n}\n\nstatic void tsens_set_interrupt_v1(struct tsens_priv *priv, u32 hw_id,\n\t\t\t\t   enum tsens_irq_type irq_type, bool enable)\n{\n\tu32 index = 0;\n\n\tswitch (irq_type) {\n\tcase UPPER:\n\t\tindex = UP_INT_CLEAR_0 + hw_id;\n\t\tbreak;\n\tcase LOWER:\n\t\tindex = LOW_INT_CLEAR_0 + hw_id;\n\t\tbreak;\n\tcase CRITICAL:\n\t\t \n\t\treturn;\n\t}\n\tregmap_field_write(priv->rf[index], enable ? 0 : 1);\n}\n\nstatic void tsens_set_interrupt_v2(struct tsens_priv *priv, u32 hw_id,\n\t\t\t\t   enum tsens_irq_type irq_type, bool enable)\n{\n\tu32 index_mask = 0, index_clear = 0;\n\n\t \n\tswitch (irq_type) {\n\tcase UPPER:\n\t\tindex_mask  = UP_INT_MASK_0 + hw_id;\n\t\tindex_clear = UP_INT_CLEAR_0 + hw_id;\n\t\tbreak;\n\tcase LOWER:\n\t\tindex_mask  = LOW_INT_MASK_0 + hw_id;\n\t\tindex_clear = LOW_INT_CLEAR_0 + hw_id;\n\t\tbreak;\n\tcase CRITICAL:\n\t\tindex_mask  = CRIT_INT_MASK_0 + hw_id;\n\t\tindex_clear = CRIT_INT_CLEAR_0 + hw_id;\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\tregmap_field_write(priv->rf[index_mask], 0);\n\t} else {\n\t\tregmap_field_write(priv->rf[index_mask],  1);\n\t\tregmap_field_write(priv->rf[index_clear], 1);\n\t\tregmap_field_write(priv->rf[index_clear], 0);\n\t}\n}\n\n \nstatic void tsens_set_interrupt(struct tsens_priv *priv, u32 hw_id,\n\t\t\t\tenum tsens_irq_type irq_type, bool enable)\n{\n\tdev_dbg(priv->dev, \"[%u] %s: %s -> %s\\n\", hw_id, __func__,\n\t\tirq_type ? ((irq_type == 1) ? \"UP\" : \"CRITICAL\") : \"LOW\",\n\t\tenable ? \"en\" : \"dis\");\n\tif (tsens_version(priv) > VER_1_X)\n\t\ttsens_set_interrupt_v2(priv, hw_id, irq_type, enable);\n\telse\n\t\ttsens_set_interrupt_v1(priv, hw_id, irq_type, enable);\n}\n\n \nstatic int tsens_threshold_violated(struct tsens_priv *priv, u32 hw_id,\n\t\t\t\t    struct tsens_irq_data *d)\n{\n\tint ret;\n\n\tret = regmap_field_read(priv->rf[UPPER_STATUS_0 + hw_id], &d->up_viol);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_field_read(priv->rf[LOWER_STATUS_0 + hw_id], &d->low_viol);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->feat->crit_int) {\n\t\tret = regmap_field_read(priv->rf[CRITICAL_STATUS_0 + hw_id],\n\t\t\t\t\t&d->crit_viol);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (d->up_viol || d->low_viol || d->crit_viol)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int tsens_read_irq_state(struct tsens_priv *priv, u32 hw_id,\n\t\t\t\tconst struct tsens_sensor *s,\n\t\t\t\tstruct tsens_irq_data *d)\n{\n\tint ret;\n\n\tret = regmap_field_read(priv->rf[UP_INT_CLEAR_0 + hw_id], &d->up_irq_clear);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_field_read(priv->rf[LOW_INT_CLEAR_0 + hw_id], &d->low_irq_clear);\n\tif (ret)\n\t\treturn ret;\n\tif (tsens_version(priv) > VER_1_X) {\n\t\tret = regmap_field_read(priv->rf[UP_INT_MASK_0 + hw_id], &d->up_irq_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_field_read(priv->rf[LOW_INT_MASK_0 + hw_id], &d->low_irq_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_field_read(priv->rf[CRIT_INT_CLEAR_0 + hw_id],\n\t\t\t\t\t&d->crit_irq_clear);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_field_read(priv->rf[CRIT_INT_MASK_0 + hw_id],\n\t\t\t\t\t&d->crit_irq_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->crit_thresh = tsens_hw_to_mC(s, CRIT_THRESH_0 + hw_id);\n\t} else {\n\t\t \n\t\td->up_irq_mask = 0;\n\t\td->low_irq_mask = 0;\n\t\td->crit_irq_clear = 0;\n\t\td->crit_irq_mask = 0;\n\t\td->crit_thresh = 0;\n\t}\n\n\td->up_thresh  = tsens_hw_to_mC(s, UP_THRESH_0 + hw_id);\n\td->low_thresh = tsens_hw_to_mC(s, LOW_THRESH_0 + hw_id);\n\n\tdev_dbg(priv->dev, \"[%u] %s%s: status(%u|%u|%u) | clr(%u|%u|%u) | mask(%u|%u|%u)\\n\",\n\t\thw_id, __func__,\n\t\t(d->up_viol || d->low_viol || d->crit_viol) ? \"(V)\" : \"\",\n\t\td->low_viol, d->up_viol, d->crit_viol,\n\t\td->low_irq_clear, d->up_irq_clear, d->crit_irq_clear,\n\t\td->low_irq_mask, d->up_irq_mask, d->crit_irq_mask);\n\tdev_dbg(priv->dev, \"[%u] %s%s: thresh: (%d:%d:%d)\\n\", hw_id, __func__,\n\t\t(d->up_viol || d->low_viol || d->crit_viol) ? \"(V)\" : \"\",\n\t\td->low_thresh, d->up_thresh, d->crit_thresh);\n\n\treturn 0;\n}\n\nstatic inline u32 masked_irq(u32 hw_id, u32 mask, enum tsens_ver ver)\n{\n\tif (ver > VER_1_X)\n\t\treturn mask & (1 << hw_id);\n\n\t \n\treturn 0;\n}\n\n \nstatic irqreturn_t tsens_critical_irq_thread(int irq, void *data)\n{\n\tstruct tsens_priv *priv = data;\n\tstruct tsens_irq_data d;\n\tint temp, ret, i;\n\tu32 wdog_status, wdog_count;\n\n\tif (priv->feat->has_watchdog) {\n\t\tret = regmap_field_read(priv->rf[WDOG_BARK_STATUS],\n\t\t\t\t\t&wdog_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (wdog_status) {\n\t\t\t \n\t\t\tregmap_field_write(priv->rf[WDOG_BARK_CLEAR], 1);\n\t\t\tregmap_field_write(priv->rf[WDOG_BARK_CLEAR], 0);\n\t\t\tret = regmap_field_read(priv->rf[WDOG_BARK_COUNT],\n\t\t\t\t\t\t&wdog_count);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (wdog_count)\n\t\t\t\tdev_dbg(priv->dev, \"%s: watchdog count: %d\\n\",\n\t\t\t\t\t__func__, wdog_count);\n\n\t\t\t \n\t\t}\n\t}\n\n\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\tconst struct tsens_sensor *s = &priv->sensor[i];\n\t\tu32 hw_id = s->hw_id;\n\n\t\tif (!s->tzd)\n\t\t\tcontinue;\n\t\tif (!tsens_threshold_violated(priv, hw_id, &d))\n\t\t\tcontinue;\n\t\tret = get_temp_tsens_valid(s, &temp);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"[%u] %s: error reading sensor\\n\",\n\t\t\t\thw_id, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttsens_read_irq_state(priv, hw_id, s, &d);\n\t\tif (d.crit_viol &&\n\t\t    !masked_irq(hw_id, d.crit_irq_mask, tsens_version(priv))) {\n\t\t\t \n\t\t\ttsens_set_interrupt(priv, hw_id, CRITICAL, false);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t tsens_irq_thread(int irq, void *data)\n{\n\tstruct tsens_priv *priv = data;\n\tstruct tsens_irq_data d;\n\tint i;\n\n\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\tconst struct tsens_sensor *s = &priv->sensor[i];\n\t\tu32 hw_id = s->hw_id;\n\n\t\tif (!s->tzd)\n\t\t\tcontinue;\n\t\tif (!tsens_threshold_violated(priv, hw_id, &d))\n\t\t\tcontinue;\n\n\t\tthermal_zone_device_update(s->tzd, THERMAL_EVENT_UNSPECIFIED);\n\n\t\tif (tsens_version(priv) < VER_0_1) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t tsens_combined_irq_thread(int irq, void *data)\n{\n\tirqreturn_t ret;\n\n\tret = tsens_critical_irq_thread(irq, data);\n\tif (ret != IRQ_HANDLED)\n\t\treturn ret;\n\n\treturn tsens_irq_thread(irq, data);\n}\n\nstatic int tsens_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct tsens_sensor *s = thermal_zone_device_priv(tz);\n\tstruct tsens_priv *priv = s->priv;\n\tstruct device *dev = priv->dev;\n\tstruct tsens_irq_data d;\n\tunsigned long flags;\n\tint high_val, low_val, cl_high, cl_low;\n\tu32 hw_id = s->hw_id;\n\n\tif (tsens_version(priv) < VER_0_1) {\n\t\t \n\t\thw_id = 0;\n\t}\n\n\tdev_dbg(dev, \"[%u] %s: proposed thresholds: (%d:%d)\\n\",\n\t\thw_id, __func__, low, high);\n\n\tcl_high = clamp_val(high, priv->feat->trip_min_temp, priv->feat->trip_max_temp);\n\tcl_low  = clamp_val(low, priv->feat->trip_min_temp, priv->feat->trip_max_temp);\n\n\thigh_val = tsens_mC_to_hw(s, cl_high);\n\tlow_val  = tsens_mC_to_hw(s, cl_low);\n\n\tspin_lock_irqsave(&priv->ul_lock, flags);\n\n\ttsens_read_irq_state(priv, hw_id, s, &d);\n\n\t \n\tregmap_field_write(priv->rf[LOW_THRESH_0 + hw_id], low_val);\n\tregmap_field_write(priv->rf[UP_THRESH_0 + hw_id], high_val);\n\ttsens_set_interrupt(priv, hw_id, LOWER, true);\n\ttsens_set_interrupt(priv, hw_id, UPPER, true);\n\n\tspin_unlock_irqrestore(&priv->ul_lock, flags);\n\n\tdev_dbg(dev, \"[%u] %s: (%d:%d)->(%d:%d)\\n\",\n\t\thw_id, __func__, d.low_thresh, d.up_thresh, cl_low, cl_high);\n\n\treturn 0;\n}\n\nstatic int tsens_enable_irq(struct tsens_priv *priv)\n{\n\tint ret;\n\tint val = tsens_version(priv) > VER_1_X ? 7 : 1;\n\n\tret = regmap_field_write(priv->rf[INT_EN], val);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"%s: failed to enable interrupts\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\nstatic void tsens_disable_irq(struct tsens_priv *priv)\n{\n\tregmap_field_write(priv->rf[INT_EN], 0);\n}\n\nint get_temp_tsens_valid(const struct tsens_sensor *s, int *temp)\n{\n\tstruct tsens_priv *priv = s->priv;\n\tint hw_id = s->hw_id;\n\tu32 temp_idx = LAST_TEMP_0 + hw_id;\n\tu32 valid_idx = VALID_0 + hw_id;\n\tu32 valid;\n\tint ret;\n\n\t \n\tif (tsens_version(priv) == VER_0)\n\t\tgoto get_temp;\n\n\t \n\tret = regmap_field_read_poll_timeout(priv->rf[valid_idx], valid,\n\t\t\t\t\t     valid, 1, 20 * USEC_PER_MSEC);\n\tif (ret)\n\t\treturn ret;\n\nget_temp:\n\t \n\t*temp = tsens_hw_to_mC(s, temp_idx);\n\n\treturn 0;\n}\n\nint get_temp_common(const struct tsens_sensor *s, int *temp)\n{\n\tstruct tsens_priv *priv = s->priv;\n\tint hw_id = s->hw_id;\n\tint last_temp = 0, ret, trdy;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + usecs_to_jiffies(TIMEOUT_US);\n\tdo {\n\t\tif (tsens_version(priv) == VER_0) {\n\t\t\tret = regmap_field_read(priv->rf[TRDY], &trdy);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (!trdy)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tret = regmap_field_read(priv->rf[LAST_TEMP_0 + hw_id], &last_temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*temp = code_to_degc(last_temp, s) * 1000;\n\n\t\treturn 0;\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int dbg_sensors_show(struct seq_file *s, void *data)\n{\n\tstruct platform_device *pdev = s->private;\n\tstruct tsens_priv *priv = platform_get_drvdata(pdev);\n\tint i;\n\n\tseq_printf(s, \"max: %2d\\nnum: %2d\\n\\n\",\n\t\t   priv->feat->max_sensors, priv->num_sensors);\n\n\tseq_puts(s, \"      id    slope   offset\\n--------------------------\\n\");\n\tfor (i = 0;  i < priv->num_sensors; i++) {\n\t\tseq_printf(s, \"%8d %8d %8d\\n\", priv->sensor[i].hw_id,\n\t\t\t   priv->sensor[i].slope, priv->sensor[i].offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int dbg_version_show(struct seq_file *s, void *data)\n{\n\tstruct platform_device *pdev = s->private;\n\tstruct tsens_priv *priv = platform_get_drvdata(pdev);\n\tu32 maj_ver, min_ver, step_ver;\n\tint ret;\n\n\tif (tsens_version(priv) > VER_0_1) {\n\t\tret = regmap_field_read(priv->rf[VER_MAJOR], &maj_ver);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_field_read(priv->rf[VER_MINOR], &min_ver);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_field_read(priv->rf[VER_STEP], &step_ver);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tseq_printf(s, \"%d.%d.%d\\n\", maj_ver, min_ver, step_ver);\n\t} else {\n\t\tseq_printf(s, \"0.%d.0\\n\", priv->feat->ver_major);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(dbg_version);\nDEFINE_SHOW_ATTRIBUTE(dbg_sensors);\n\nstatic void tsens_debug_init(struct platform_device *pdev)\n{\n\tstruct tsens_priv *priv = platform_get_drvdata(pdev);\n\n\tpriv->debug_root = debugfs_lookup(\"tsens\", NULL);\n\tif (!priv->debug_root)\n\t\tpriv->debug_root = debugfs_create_dir(\"tsens\", NULL);\n\n\t \n\tpriv->debug = debugfs_create_dir(dev_name(&pdev->dev), priv->debug_root);\n\tdebugfs_create_file(\"version\", 0444, priv->debug, pdev, &dbg_version_fops);\n\tdebugfs_create_file(\"sensors\", 0444, priv->debug, pdev, &dbg_sensors_fops);\n}\n#else\nstatic inline void tsens_debug_init(struct platform_device *pdev) {}\n#endif\n\nstatic const struct regmap_config tsens_config = {\n\t.name\t\t= \"tm\",\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nstatic const struct regmap_config tsens_srot_config = {\n\t.name\t\t= \"srot\",\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nint __init init_common(struct tsens_priv *priv)\n{\n\tvoid __iomem *tm_base, *srot_base;\n\tstruct device *dev = priv->dev;\n\tu32 ver_minor;\n\tstruct resource *res;\n\tu32 enabled;\n\tint ret, i, j;\n\tstruct platform_device *op = of_find_device_by_node(priv->dev->of_node);\n\n\tif (!op)\n\t\treturn -EINVAL;\n\n\tif (op->num_resources > 1) {\n\t\t \n\t\tpriv->tm_offset = 0;\n\t\tres = platform_get_resource(op, IORESOURCE_MEM, 1);\n\t\tsrot_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(srot_base)) {\n\t\t\tret = PTR_ERR(srot_base);\n\t\t\tgoto err_put_device;\n\t\t}\n\n\t\tpriv->srot_map = devm_regmap_init_mmio(dev, srot_base,\n\t\t\t\t\t\t       &tsens_srot_config);\n\t\tif (IS_ERR(priv->srot_map)) {\n\t\t\tret = PTR_ERR(priv->srot_map);\n\t\t\tgoto err_put_device;\n\t\t}\n\t} else {\n\t\t \n\t\tpriv->tm_offset = 0x1000;\n\t}\n\n\tif (tsens_version(priv) >= VER_0_1) {\n\t\tres = platform_get_resource(op, IORESOURCE_MEM, 0);\n\t\ttm_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(tm_base)) {\n\t\t\tret = PTR_ERR(tm_base);\n\t\t\tgoto err_put_device;\n\t\t}\n\n\t\tpriv->tm_map = devm_regmap_init_mmio(dev, tm_base, &tsens_config);\n\t} else {  \n\t\tstruct device *parent = priv->dev->parent;\n\n\t\tif (parent)\n\t\t\tpriv->tm_map = syscon_node_to_regmap(parent->of_node);\n\t}\n\n\tif (IS_ERR_OR_NULL(priv->tm_map)) {\n\t\tif (!priv->tm_map)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tret = PTR_ERR(priv->tm_map);\n\t\tgoto err_put_device;\n\t}\n\n\t \n\tif (!priv->srot_map)\n\t\tpriv->srot_map = priv->tm_map;\n\n\tif (tsens_version(priv) > VER_0_1) {\n\t\tfor (i = VER_MAJOR; i <= VER_STEP; i++) {\n\t\t\tpriv->rf[i] = devm_regmap_field_alloc(dev, priv->srot_map,\n\t\t\t\t\t\t\t      priv->fields[i]);\n\t\t\tif (IS_ERR(priv->rf[i])) {\n\t\t\t\tret = PTR_ERR(priv->rf[i]);\n\t\t\t\tgoto err_put_device;\n\t\t\t}\n\t\t}\n\t\tret = regmap_field_read(priv->rf[VER_MINOR], &ver_minor);\n\t\tif (ret)\n\t\t\tgoto err_put_device;\n\t}\n\n\tpriv->rf[TSENS_EN] = devm_regmap_field_alloc(dev, priv->srot_map,\n\t\t\t\t\t\t     priv->fields[TSENS_EN]);\n\tif (IS_ERR(priv->rf[TSENS_EN])) {\n\t\tret = PTR_ERR(priv->rf[TSENS_EN]);\n\t\tgoto err_put_device;\n\t}\n\t \n\tif (tsens_version(priv) == VER_0)\n\t\tregmap_field_write(priv->rf[TSENS_EN], 1);\n\n\tret = regmap_field_read(priv->rf[TSENS_EN], &enabled);\n\tif (ret)\n\t\tgoto err_put_device;\n\tif (!enabled) {\n\t\tdev_err(dev, \"%s: device not enabled\\n\", __func__);\n\t\tret = -ENODEV;\n\t\tgoto err_put_device;\n\t}\n\n\tpriv->rf[SENSOR_EN] = devm_regmap_field_alloc(dev, priv->srot_map,\n\t\t\t\t\t\t      priv->fields[SENSOR_EN]);\n\tif (IS_ERR(priv->rf[SENSOR_EN])) {\n\t\tret = PTR_ERR(priv->rf[SENSOR_EN]);\n\t\tgoto err_put_device;\n\t}\n\tpriv->rf[INT_EN] = devm_regmap_field_alloc(dev, priv->tm_map,\n\t\t\t\t\t\t   priv->fields[INT_EN]);\n\tif (IS_ERR(priv->rf[INT_EN])) {\n\t\tret = PTR_ERR(priv->rf[INT_EN]);\n\t\tgoto err_put_device;\n\t}\n\n\tpriv->rf[TSENS_SW_RST] =\n\t\tdevm_regmap_field_alloc(dev, priv->srot_map, priv->fields[TSENS_SW_RST]);\n\tif (IS_ERR(priv->rf[TSENS_SW_RST])) {\n\t\tret = PTR_ERR(priv->rf[TSENS_SW_RST]);\n\t\tgoto err_put_device;\n\t}\n\n\tpriv->rf[TRDY] = devm_regmap_field_alloc(dev, priv->tm_map, priv->fields[TRDY]);\n\tif (IS_ERR(priv->rf[TRDY])) {\n\t\tret = PTR_ERR(priv->rf[TRDY]);\n\t\tgoto err_put_device;\n\t}\n\n\t \n\tfor (j = LAST_TEMP_0; j <= UP_THRESH_15; j += 16) {\n\t\tfor (i = 0; i < priv->feat->max_sensors; i++) {\n\t\t\tint idx = j + i;\n\n\t\t\tpriv->rf[idx] = devm_regmap_field_alloc(dev,\n\t\t\t\t\t\t\t\tpriv->tm_map,\n\t\t\t\t\t\t\t\tpriv->fields[idx]);\n\t\t\tif (IS_ERR(priv->rf[idx])) {\n\t\t\t\tret = PTR_ERR(priv->rf[idx]);\n\t\t\t\tgoto err_put_device;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (priv->feat->crit_int || tsens_version(priv) < VER_0_1) {\n\t\t \n\t\tfor (j = CRITICAL_STATUS_0; j <= CRIT_THRESH_15; j += 16) {\n\t\t\tfor (i = 0; i < priv->feat->max_sensors; i++) {\n\t\t\t\tint idx = j + i;\n\n\t\t\t\tpriv->rf[idx] =\n\t\t\t\t\tdevm_regmap_field_alloc(dev,\n\t\t\t\t\t\t\t\tpriv->tm_map,\n\t\t\t\t\t\t\t\tpriv->fields[idx]);\n\t\t\t\tif (IS_ERR(priv->rf[idx])) {\n\t\t\t\t\tret = PTR_ERR(priv->rf[idx]);\n\t\t\t\t\tgoto err_put_device;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tsens_version(priv) > VER_1_X &&  ver_minor > 2) {\n\t\t \n\t\tpriv->feat->has_watchdog = 1;\n\t\tfor (i = WDOG_BARK_STATUS; i <= CC_MON_MASK; i++) {\n\t\t\tpriv->rf[i] = devm_regmap_field_alloc(dev, priv->tm_map,\n\t\t\t\t\t\t\t      priv->fields[i]);\n\t\t\tif (IS_ERR(priv->rf[i])) {\n\t\t\t\tret = PTR_ERR(priv->rf[i]);\n\t\t\t\tgoto err_put_device;\n\t\t\t}\n\t\t}\n\t\t \n\t\tregmap_field_write(priv->rf[WDOG_BARK_MASK], 0);\n\t\tregmap_field_write(priv->rf[CC_MON_MASK], 1);\n\t}\n\n\tspin_lock_init(&priv->ul_lock);\n\n\t \n\tif (tsens_version(priv) >= VER_0_1)\n\t\ttsens_enable_irq(priv);\n\nerr_put_device:\n\tput_device(&op->dev);\n\treturn ret;\n}\n\nstatic int tsens_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct tsens_sensor *s = thermal_zone_device_priv(tz);\n\tstruct tsens_priv *priv = s->priv;\n\n\treturn priv->ops->get_temp(s, temp);\n}\n\nstatic int  __maybe_unused tsens_suspend(struct device *dev)\n{\n\tstruct tsens_priv *priv = dev_get_drvdata(dev);\n\n\tif (priv->ops && priv->ops->suspend)\n\t\treturn priv->ops->suspend(priv);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tsens_resume(struct device *dev)\n{\n\tstruct tsens_priv *priv = dev_get_drvdata(dev);\n\n\tif (priv->ops && priv->ops->resume)\n\t\treturn priv->ops->resume(priv);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tsens_pm_ops, tsens_suspend, tsens_resume);\n\nstatic const struct of_device_id tsens_table[] = {\n\t{\n\t\t.compatible = \"qcom,ipq8064-tsens\",\n\t\t.data = &data_8960,\n\t}, {\n\t\t.compatible = \"qcom,ipq8074-tsens\",\n\t\t.data = &data_ipq8074,\n\t}, {\n\t\t.compatible = \"qcom,mdm9607-tsens\",\n\t\t.data = &data_9607,\n\t}, {\n\t\t.compatible = \"qcom,msm8226-tsens\",\n\t\t.data = &data_8226,\n\t}, {\n\t\t.compatible = \"qcom,msm8909-tsens\",\n\t\t.data = &data_8909,\n\t}, {\n\t\t.compatible = \"qcom,msm8916-tsens\",\n\t\t.data = &data_8916,\n\t}, {\n\t\t.compatible = \"qcom,msm8939-tsens\",\n\t\t.data = &data_8939,\n\t}, {\n\t\t.compatible = \"qcom,msm8956-tsens\",\n\t\t.data = &data_8956,\n\t}, {\n\t\t.compatible = \"qcom,msm8960-tsens\",\n\t\t.data = &data_8960,\n\t}, {\n\t\t.compatible = \"qcom,msm8974-tsens\",\n\t\t.data = &data_8974,\n\t}, {\n\t\t.compatible = \"qcom,msm8976-tsens\",\n\t\t.data = &data_8976,\n\t}, {\n\t\t.compatible = \"qcom,msm8996-tsens\",\n\t\t.data = &data_8996,\n\t}, {\n\t\t.compatible = \"qcom,tsens-v1\",\n\t\t.data = &data_tsens_v1,\n\t}, {\n\t\t.compatible = \"qcom,tsens-v2\",\n\t\t.data = &data_tsens_v2,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tsens_table);\n\nstatic const struct thermal_zone_device_ops tsens_of_ops = {\n\t.get_temp = tsens_get_temp,\n\t.set_trips = tsens_set_trips,\n};\n\nstatic int tsens_register_irq(struct tsens_priv *priv, char *irqname,\n\t\t\t      irq_handler_t thread_fn)\n{\n\tstruct platform_device *pdev;\n\tint ret, irq;\n\n\tpdev = of_find_device_by_node(priv->dev->of_node);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq_byname(pdev, irqname);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\t \n\t\tif (irq == -ENXIO)\n\t\t\tret = 0;\n\t} else {\n\t\t \n\t\tif (tsens_version(priv) == VER_0)\n\t\t\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\t\t\t\tthread_fn, NULL,\n\t\t\t\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\t\t\tdev_name(&pdev->dev),\n\t\t\t\t\t\t\tpriv);\n\t\telse\n\t\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\t\tthread_fn, IRQF_ONESHOT,\n\t\t\t\t\t\t\tdev_name(&pdev->dev),\n\t\t\t\t\t\t\tpriv);\n\n\t\tif (ret)\n\t\t\tdev_err(&pdev->dev, \"%s: failed to get irq\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tenable_irq_wake(irq);\n\t}\n\n\tput_device(&pdev->dev);\n\treturn ret;\n}\n\nstatic int tsens_register(struct tsens_priv *priv)\n{\n\tint i, ret;\n\tstruct thermal_zone_device *tzd;\n\n\tfor (i = 0;  i < priv->num_sensors; i++) {\n\t\tpriv->sensor[i].priv = priv;\n\t\ttzd = devm_thermal_of_zone_register(priv->dev, priv->sensor[i].hw_id,\n\t\t\t\t\t\t    &priv->sensor[i],\n\t\t\t\t\t\t    &tsens_of_ops);\n\t\tif (IS_ERR(tzd))\n\t\t\tcontinue;\n\t\tpriv->sensor[i].tzd = tzd;\n\t\tif (priv->ops->enable)\n\t\t\tpriv->ops->enable(priv, i);\n\n\t\tdevm_thermal_add_hwmon_sysfs(priv->dev, tzd);\n\t}\n\n\t \n\tif (tsens_version(priv) < VER_0_1) {\n\t\tregmap_field_write(priv->rf[CRIT_THRESH_0],\n\t\t\t\t   tsens_mC_to_hw(priv->sensor, 120000));\n\n\t\tregmap_field_write(priv->rf[CRIT_THRESH_1],\n\t\t\t\t   tsens_mC_to_hw(priv->sensor, 0));\n\t}\n\n\tif (priv->feat->combo_int) {\n\t\tret = tsens_register_irq(priv, \"combined\",\n\t\t\t\t\t tsens_combined_irq_thread);\n\t} else {\n\t\tret = tsens_register_irq(priv, \"uplow\", tsens_irq_thread);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (priv->feat->crit_int)\n\t\t\tret = tsens_register_irq(priv, \"critical\",\n\t\t\t\t\t\t tsens_critical_irq_thread);\n\t}\n\n\treturn ret;\n}\n\nstatic int tsens_probe(struct platform_device *pdev)\n{\n\tint ret, i;\n\tstruct device *dev;\n\tstruct device_node *np;\n\tstruct tsens_priv *priv;\n\tconst struct tsens_plat_data *data;\n\tconst struct of_device_id *id;\n\tu32 num_sensors;\n\n\tif (pdev->dev.of_node)\n\t\tdev = &pdev->dev;\n\telse\n\t\tdev = pdev->dev.parent;\n\n\tnp = dev->of_node;\n\n\tid = of_match_node(tsens_table, np);\n\tif (id)\n\t\tdata = id->data;\n\telse\n\t\tdata = &data_8960;\n\n\tnum_sensors = data->num_sensors;\n\n\tif (np)\n\t\tof_property_read_u32(np, \"#qcom,sensors\", &num_sensors);\n\n\tif (num_sensors <= 0) {\n\t\tdev_err(dev, \"%s: invalid number of sensors\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev,\n\t\t\t     struct_size(priv, sensor, num_sensors),\n\t\t\t     GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->num_sensors = num_sensors;\n\tpriv->ops = data->ops;\n\tfor (i = 0;  i < priv->num_sensors; i++) {\n\t\tif (data->hw_ids)\n\t\t\tpriv->sensor[i].hw_id = data->hw_ids[i];\n\t\telse\n\t\t\tpriv->sensor[i].hw_id = i;\n\t}\n\tpriv->feat = data->feat;\n\tpriv->fields = data->fields;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tif (!priv->ops || !priv->ops->init || !priv->ops->get_temp)\n\t\treturn -EINVAL;\n\n\tret = priv->ops->init(priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: init failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (priv->ops->calibrate) {\n\t\tret = priv->ops->calibrate(priv);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"%s: calibration failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = tsens_register(priv);\n\tif (!ret)\n\t\ttsens_debug_init(pdev);\n\n\treturn ret;\n}\n\nstatic int tsens_remove(struct platform_device *pdev)\n{\n\tstruct tsens_priv *priv = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(priv->debug_root);\n\ttsens_disable_irq(priv);\n\tif (priv->ops->disable)\n\t\tpriv->ops->disable(priv);\n\n\treturn 0;\n}\n\nstatic struct platform_driver tsens_driver = {\n\t.probe = tsens_probe,\n\t.remove = tsens_remove,\n\t.driver = {\n\t\t.name = \"qcom-tsens\",\n\t\t.pm\t= &tsens_pm_ops,\n\t\t.of_match_table = tsens_table,\n\t},\n};\nmodule_platform_driver(tsens_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"QCOM Temperature Sensor driver\");\nMODULE_ALIAS(\"platform:qcom-tsens\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}