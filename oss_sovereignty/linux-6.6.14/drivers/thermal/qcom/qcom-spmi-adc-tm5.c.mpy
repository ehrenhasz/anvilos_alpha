{
  "module_name": "qcom-spmi-adc-tm5.c",
  "hash_id": "d8b9c96564d0c820b1eae0ca702ee4ff74f423fa30b83680b10e4f3b8bd16f07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/qcom/qcom-spmi-adc-tm5.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/iio/adc/qcom-vadc-common.h>\n#include <linux/iio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n\n#include <asm/unaligned.h>\n\n#include \"../thermal_hwmon.h\"\n\n \n\n#define ADC5_MAX_CHANNEL                        0xc0\n#define ADC_TM5_NUM_CHANNELS\t\t8\n\n#define ADC_TM5_STATUS_LOW\t\t\t0x0a\n\n#define ADC_TM5_STATUS_HIGH\t\t\t0x0b\n\n#define ADC_TM5_NUM_BTM\t\t\t\t0x0f\n\n#define ADC_TM5_ADC_DIG_PARAM\t\t\t0x42\n\n#define ADC_TM5_FAST_AVG_CTL\t\t\t(ADC_TM5_ADC_DIG_PARAM + 1)\n#define ADC_TM5_FAST_AVG_EN\t\t\t\tBIT(7)\n\n#define ADC_TM5_MEAS_INTERVAL_CTL\t\t(ADC_TM5_ADC_DIG_PARAM + 2)\n#define ADC_TM5_TIMER1\t\t\t\t\t3  \n\n#define ADC_TM5_MEAS_INTERVAL_CTL2\t\t(ADC_TM5_ADC_DIG_PARAM + 3)\n#define ADC_TM5_MEAS_INTERVAL_CTL2_MASK\t\t\t0xf0\n#define ADC_TM5_TIMER2\t\t\t\t\t10  \n#define ADC_TM5_MEAS_INTERVAL_CTL3_MASK\t\t\t0xf\n#define ADC_TM5_TIMER3\t\t\t\t\t4  \n\n#define ADC_TM_EN_CTL1\t\t\t\t0x46\n#define ADC_TM_EN\t\t\t\t\tBIT(7)\n#define ADC_TM_CONV_REQ\t\t\t\t0x47\n#define ADC_TM_CONV_REQ_EN\t\t\t\tBIT(7)\n\n#define ADC_TM5_M_CHAN_BASE\t\t\t0x60\n\n#define ADC_TM5_M_ADC_CH_SEL_CTL(n)\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 0)\n#define ADC_TM5_M_LOW_THR0(n)\t\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 1)\n#define ADC_TM5_M_LOW_THR1(n)\t\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 2)\n#define ADC_TM5_M_HIGH_THR0(n)\t\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 3)\n#define ADC_TM5_M_HIGH_THR1(n)\t\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 4)\n#define ADC_TM5_M_MEAS_INTERVAL_CTL(n)\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 5)\n#define ADC_TM5_M_CTL(n)\t\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 6)\n#define ADC_TM5_M_CTL_HW_SETTLE_DELAY_MASK\t\t0xf\n#define ADC_TM5_M_CTL_CAL_SEL_MASK\t\t\t0x30\n#define ADC_TM5_M_CTL_CAL_VAL\t\t\t\t0x40\n#define ADC_TM5_M_EN(n)\t\t\t\t(ADC_TM5_M_CHAN_BASE + ((n) * 8) + 7)\n#define ADC_TM5_M_MEAS_EN\t\t\t\tBIT(7)\n#define ADC_TM5_M_HIGH_THR_INT_EN\t\t\tBIT(1)\n#define ADC_TM5_M_LOW_THR_INT_EN\t\t\tBIT(0)\n\n#define ADC_TM_GEN2_STATUS1\t\t\t0x08\n#define ADC_TM_GEN2_STATUS_LOW_SET\t\t0x09\n#define ADC_TM_GEN2_STATUS_LOW_CLR\t\t0x0a\n#define ADC_TM_GEN2_STATUS_HIGH_SET\t\t0x0b\n#define ADC_TM_GEN2_STATUS_HIGH_CLR\t\t0x0c\n\n#define ADC_TM_GEN2_CFG_HS_SET\t\t\t0x0d\n#define ADC_TM_GEN2_CFG_HS_FLAG\t\t\tBIT(0)\n#define ADC_TM_GEN2_CFG_HS_CLR\t\t\t0x0e\n\n#define ADC_TM_GEN2_SID\t\t\t\t0x40\n\n#define ADC_TM_GEN2_CH_CTL\t\t\t0x41\n#define ADC_TM_GEN2_TM_CH_SEL\t\t\tGENMASK(7, 5)\n#define ADC_TM_GEN2_MEAS_INT_SEL\t\tGENMASK(3, 2)\n\n#define ADC_TM_GEN2_ADC_DIG_PARAM\t\t0x42\n#define ADC_TM_GEN2_CTL_CAL_SEL\t\t\tGENMASK(5, 4)\n#define ADC_TM_GEN2_CTL_DEC_RATIO_MASK\t\tGENMASK(3, 2)\n\n#define ADC_TM_GEN2_FAST_AVG_CTL\t\t0x43\n#define ADC_TM_GEN2_FAST_AVG_EN\t\t\tBIT(7)\n\n#define ADC_TM_GEN2_ADC_CH_SEL_CTL\t\t0x44\n\n#define ADC_TM_GEN2_DELAY_CTL\t\t\t0x45\n#define ADC_TM_GEN2_HW_SETTLE_DELAY\t\tGENMASK(3, 0)\n\n#define ADC_TM_GEN2_EN_CTL1\t\t\t0x46\n#define ADC_TM_GEN2_EN\t\t\t\tBIT(7)\n\n#define ADC_TM_GEN2_CONV_REQ\t\t\t0x47\n#define ADC_TM_GEN2_CONV_REQ_EN\t\t\tBIT(7)\n\n#define ADC_TM_GEN2_LOW_THR0\t\t\t0x49\n#define ADC_TM_GEN2_LOW_THR1\t\t\t0x4a\n#define ADC_TM_GEN2_HIGH_THR0\t\t\t0x4b\n#define ADC_TM_GEN2_HIGH_THR1\t\t\t0x4c\n#define ADC_TM_GEN2_LOWER_MASK(n)\t\t((n) & GENMASK(7, 0))\n#define ADC_TM_GEN2_UPPER_MASK(n)\t\t(((n) & GENMASK(15, 8)) >> 8)\n\n#define ADC_TM_GEN2_MEAS_IRQ_EN\t\t\t0x4d\n#define ADC_TM_GEN2_MEAS_EN\t\t\tBIT(7)\n#define ADC_TM5_GEN2_HIGH_THR_INT_EN\t\tBIT(1)\n#define ADC_TM5_GEN2_LOW_THR_INT_EN\t\tBIT(0)\n\n#define ADC_TM_GEN2_MEAS_INT_LSB\t\t0x50\n#define ADC_TM_GEN2_MEAS_INT_MSB\t\t0x51\n#define ADC_TM_GEN2_MEAS_INT_MODE\t\t0x52\n\n#define ADC_TM_GEN2_Mn_DATA0(n)\t\t\t((n * 2) + 0xa0)\n#define ADC_TM_GEN2_Mn_DATA1(n)\t\t\t((n * 2) + 0xa1)\n#define ADC_TM_GEN2_DATA_SHIFT\t\t\t8\n\nenum adc5_timer_select {\n\tADC5_TIMER_SEL_1 = 0,\n\tADC5_TIMER_SEL_2,\n\tADC5_TIMER_SEL_3,\n\tADC5_TIMER_SEL_NONE,\n};\n\nenum adc5_gen {\n\tADC_TM5,\n\tADC_TM_HC,\n\tADC_TM5_GEN2,\n\tADC_TM5_MAX\n};\n\nenum adc_tm5_cal_method {\n\tADC_TM5_NO_CAL = 0,\n\tADC_TM5_RATIOMETRIC_CAL,\n\tADC_TM5_ABSOLUTE_CAL\n};\n\nenum adc_tm_gen2_time_select {\n\tMEAS_INT_50MS = 0,\n\tMEAS_INT_100MS,\n\tMEAS_INT_1S,\n\tMEAS_INT_SET,\n\tMEAS_INT_NONE,\n};\n\nstruct adc_tm5_chip;\nstruct adc_tm5_channel;\n\nstruct adc_tm5_data {\n\tconst u32 full_scale_code_volt;\n\tunsigned int *decimation;\n\tunsigned int *hw_settle;\n\tint (*disable_channel)(struct adc_tm5_channel *channel);\n\tint (*configure)(struct adc_tm5_channel *channel, int low, int high);\n\tirqreturn_t (*isr)(int irq, void *data);\n\tint (*init)(struct adc_tm5_chip *chip);\n\tchar *irq_name;\n\tint gen;\n};\n\n \nstruct adc_tm5_channel {\n\tunsigned int\t\tchannel;\n\tunsigned int\t\tadc_channel;\n\tenum adc_tm5_cal_method\tcal_method;\n\tunsigned int\t\tprescale;\n\tunsigned int\t\thw_settle_time;\n\tunsigned int\t\tdecimation;\t \n\tunsigned int\t\tavg_samples;\t \n\tbool\t\t\thigh_thr_en;\t \n\tbool\t\t\tlow_thr_en;\t \n\tbool\t\t\tmeas_en;\t \n\tstruct iio_channel\t*iio;\n\tstruct adc_tm5_chip\t*chip;\n\tstruct thermal_zone_device *tzd;\n};\n\n \nstruct adc_tm5_chip {\n\tstruct regmap\t\t*regmap;\n\tstruct device\t\t*dev;\n\tconst struct adc_tm5_data\t*data;\n\tstruct adc_tm5_channel\t*channels;\n\tunsigned int\t\tnchannels;\n\tunsigned int\t\tdecimation;\n\tunsigned int\t\tavg_samples;\n\tu16\t\t\tbase;\n\tstruct mutex\t\tadc_mutex_lock;\n};\n\nstatic int adc_tm5_read(struct adc_tm5_chip *adc_tm, u16 offset, u8 *data, int len)\n{\n\treturn regmap_bulk_read(adc_tm->regmap, adc_tm->base + offset, data, len);\n}\n\nstatic int adc_tm5_write(struct adc_tm5_chip *adc_tm, u16 offset, u8 *data, int len)\n{\n\treturn regmap_bulk_write(adc_tm->regmap, adc_tm->base + offset, data, len);\n}\n\nstatic int adc_tm5_reg_update(struct adc_tm5_chip *adc_tm, u16 offset, u8 mask, u8 val)\n{\n\treturn regmap_write_bits(adc_tm->regmap, adc_tm->base + offset, mask, val);\n}\n\nstatic irqreturn_t adc_tm5_isr(int irq, void *data)\n{\n\tstruct adc_tm5_chip *chip = data;\n\tu8 status_low, status_high, ctl;\n\tint ret, i;\n\n\tret = adc_tm5_read(chip, ADC_TM5_STATUS_LOW, &status_low, sizeof(status_low));\n\tif (unlikely(ret)) {\n\t\tdev_err(chip->dev, \"read status low failed: %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tret = adc_tm5_read(chip, ADC_TM5_STATUS_HIGH, &status_high, sizeof(status_high));\n\tif (unlikely(ret)) {\n\t\tdev_err(chip->dev, \"read status high failed: %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tfor (i = 0; i < chip->nchannels; i++) {\n\t\tbool upper_set = false, lower_set = false;\n\t\tunsigned int ch = chip->channels[i].channel;\n\n\t\t \n\t\tif (!chip->channels[i].tzd)\n\t\t\tcontinue;\n\n\t\tret = adc_tm5_read(chip, ADC_TM5_M_EN(ch), &ctl, sizeof(ctl));\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(chip->dev, \"ctl read failed: %d, channel %d\\n\", ret, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(ctl & ADC_TM5_M_MEAS_EN))\n\t\t\tcontinue;\n\n\t\tlower_set = (status_low & BIT(ch)) &&\n\t\t\t(ctl & ADC_TM5_M_LOW_THR_INT_EN);\n\n\t\tupper_set = (status_high & BIT(ch)) &&\n\t\t\t(ctl & ADC_TM5_M_HIGH_THR_INT_EN);\n\n\t\tif (upper_set || lower_set)\n\t\t\tthermal_zone_device_update(chip->channels[i].tzd,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t adc_tm5_gen2_isr(int irq, void *data)\n{\n\tstruct adc_tm5_chip *chip = data;\n\tu8 status_low, status_high;\n\tint ret, i;\n\n\tret = adc_tm5_read(chip, ADC_TM_GEN2_STATUS_LOW_CLR, &status_low, sizeof(status_low));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"read status_low failed: %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tret = adc_tm5_read(chip, ADC_TM_GEN2_STATUS_HIGH_CLR, &status_high, sizeof(status_high));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"read status_high failed: %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_STATUS_LOW_CLR, &status_low, sizeof(status_low));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"clear status low failed with %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_STATUS_HIGH_CLR, &status_high, sizeof(status_high));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"clear status high failed with %d\\n\", ret);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tfor (i = 0; i < chip->nchannels; i++) {\n\t\tbool upper_set = false, lower_set = false;\n\t\tunsigned int ch = chip->channels[i].channel;\n\n\t\t \n\t\tif (!chip->channels[i].tzd)\n\t\t\tcontinue;\n\n\t\tif (!chip->channels[i].meas_en)\n\t\t\tcontinue;\n\n\t\tlower_set = (status_low & BIT(ch)) &&\n\t\t\t(chip->channels[i].low_thr_en);\n\n\t\tupper_set = (status_high & BIT(ch)) &&\n\t\t\t(chip->channels[i].high_thr_en);\n\n\t\tif (upper_set || lower_set)\n\t\t\tthermal_zone_device_update(chip->channels[i].tzd,\n\t\t\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adc_tm5_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct adc_tm5_channel *channel = thermal_zone_device_priv(tz);\n\tint ret;\n\n\tif (!channel || !channel->iio)\n\t\treturn -EINVAL;\n\n\tret = iio_read_channel_processed(channel->iio, temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != IIO_VAL_INT)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int adc_tm5_disable_channel(struct adc_tm5_channel *channel)\n{\n\tstruct adc_tm5_chip *chip = channel->chip;\n\tunsigned int reg = ADC_TM5_M_EN(channel->channel);\n\n\treturn adc_tm5_reg_update(chip, reg,\n\t\t\t\t  ADC_TM5_M_MEAS_EN |\n\t\t\t\t  ADC_TM5_M_HIGH_THR_INT_EN |\n\t\t\t\t  ADC_TM5_M_LOW_THR_INT_EN,\n\t\t\t\t  0);\n}\n\n#define ADC_TM_GEN2_POLL_DELAY_MIN_US\t\t100\n#define ADC_TM_GEN2_POLL_DELAY_MAX_US\t\t110\n#define ADC_TM_GEN2_POLL_RETRY_COUNT\t\t3\n\nstatic int32_t adc_tm5_gen2_conv_req(struct adc_tm5_chip *chip)\n{\n\tint ret;\n\tu8 data;\n\tunsigned int count;\n\n\tdata = ADC_TM_GEN2_EN;\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_EN_CTL1, &data, 1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm enable failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata = ADC_TM_GEN2_CFG_HS_FLAG;\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_CFG_HS_SET, &data, 1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm handshake failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata = ADC_TM_GEN2_CONV_REQ_EN;\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_CONV_REQ, &data, 1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm request conversion failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tfor (count = 0; count < ADC_TM_GEN2_POLL_RETRY_COUNT; count++) {\n\t\tret = adc_tm5_read(chip, ADC_TM_GEN2_CFG_HS_SET, &data, sizeof(data));\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"adc-tm read failed with %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(data & ADC_TM_GEN2_CFG_HS_FLAG))\n\t\t\treturn ret;\n\t\tusleep_range(ADC_TM_GEN2_POLL_DELAY_MIN_US,\n\t\t\tADC_TM_GEN2_POLL_DELAY_MAX_US);\n\t}\n\n\tdev_err(chip->dev, \"adc-tm conversion request handshake timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int adc_tm5_gen2_disable_channel(struct adc_tm5_channel *channel)\n{\n\tstruct adc_tm5_chip *chip = channel->chip;\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&chip->adc_mutex_lock);\n\n\tchannel->meas_en = false;\n\tchannel->high_thr_en = false;\n\tchannel->low_thr_en = false;\n\n\tret = adc_tm5_read(chip, ADC_TM_GEN2_CH_CTL, &val, sizeof(val));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm block read failed with %d\\n\", ret);\n\t\tgoto disable_fail;\n\t}\n\n\tval &= ~ADC_TM_GEN2_TM_CH_SEL;\n\tval |= FIELD_PREP(ADC_TM_GEN2_TM_CH_SEL, channel->channel);\n\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_CH_CTL, &val, 1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm channel disable failed with %d\\n\", ret);\n\t\tgoto disable_fail;\n\t}\n\n\tval = 0;\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_MEAS_IRQ_EN, &val, 1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm interrupt disable failed with %d\\n\", ret);\n\t\tgoto disable_fail;\n\t}\n\n\n\tret = adc_tm5_gen2_conv_req(channel->chip);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"adc-tm channel configure failed with %d\\n\", ret);\n\ndisable_fail:\n\tmutex_unlock(&chip->adc_mutex_lock);\n\treturn ret;\n}\n\nstatic int adc_tm5_enable(struct adc_tm5_chip *chip)\n{\n\tint ret;\n\tu8 data;\n\n\tdata = ADC_TM_EN;\n\tret = adc_tm5_write(chip, ADC_TM_EN_CTL1, &data, sizeof(data));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdata = ADC_TM_CONV_REQ_EN;\n\tret = adc_tm5_write(chip, ADC_TM_CONV_REQ, &data, sizeof(data));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm request conversion failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adc_tm5_configure(struct adc_tm5_channel *channel, int low, int high)\n{\n\tstruct adc_tm5_chip *chip = channel->chip;\n\tu8 buf[8];\n\tu16 reg = ADC_TM5_M_ADC_CH_SEL_CTL(channel->channel);\n\tint ret;\n\n\tret = adc_tm5_read(chip, reg, buf, sizeof(buf));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"channel %d params read failed: %d\\n\", channel->channel, ret);\n\t\treturn ret;\n\t}\n\n\tbuf[0] = channel->adc_channel;\n\n\t \n\tif (high != INT_MAX) {\n\t\tu16 adc_code = qcom_adc_tm5_temp_volt_scale(channel->prescale,\n\t\t\t\tchip->data->full_scale_code_volt, high);\n\n\t\tput_unaligned_le16(adc_code, &buf[1]);\n\t\tbuf[7] |= ADC_TM5_M_LOW_THR_INT_EN;\n\t} else {\n\t\tbuf[7] &= ~ADC_TM5_M_LOW_THR_INT_EN;\n\t}\n\n\t \n\tif (low != -INT_MAX) {\n\t\tu16 adc_code = qcom_adc_tm5_temp_volt_scale(channel->prescale,\n\t\t\t\tchip->data->full_scale_code_volt, low);\n\n\t\tput_unaligned_le16(adc_code, &buf[3]);\n\t\tbuf[7] |= ADC_TM5_M_HIGH_THR_INT_EN;\n\t} else {\n\t\tbuf[7] &= ~ADC_TM5_M_HIGH_THR_INT_EN;\n\t}\n\n\tbuf[5] = ADC5_TIMER_SEL_2;\n\n\t \n\tbuf[6] &= ~ADC_TM5_M_CTL_HW_SETTLE_DELAY_MASK;\n\tbuf[6] |= FIELD_PREP(ADC_TM5_M_CTL_HW_SETTLE_DELAY_MASK, channel->hw_settle_time);\n\tbuf[6] &= ~ADC_TM5_M_CTL_CAL_SEL_MASK;\n\tbuf[6] |= FIELD_PREP(ADC_TM5_M_CTL_CAL_SEL_MASK, channel->cal_method);\n\n\tbuf[7] |= ADC_TM5_M_MEAS_EN;\n\n\tret = adc_tm5_write(chip, reg, buf, sizeof(buf));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"channel %d params write failed: %d\\n\", channel->channel, ret);\n\t\treturn ret;\n\t}\n\n\treturn adc_tm5_enable(chip);\n}\n\nstatic int adc_tm5_gen2_configure(struct adc_tm5_channel *channel, int low, int high)\n{\n\tstruct adc_tm5_chip *chip = channel->chip;\n\tint ret;\n\tu8 buf[14];\n\tu16 adc_code;\n\n\tmutex_lock(&chip->adc_mutex_lock);\n\n\tchannel->meas_en = true;\n\n\tret = adc_tm5_read(chip, ADC_TM_GEN2_SID, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"adc-tm block read failed with %d\\n\", ret);\n\t\tgoto config_fail;\n\t}\n\n\t \n\tbuf[0] = channel->adc_channel >> 8;\n\n\t \n\tbuf[1] &= ~ADC_TM_GEN2_TM_CH_SEL;\n\tbuf[1] |= FIELD_PREP(ADC_TM_GEN2_TM_CH_SEL, channel->channel);\n\tbuf[1] &= ~ADC_TM_GEN2_MEAS_INT_SEL;\n\tbuf[1] |= FIELD_PREP(ADC_TM_GEN2_MEAS_INT_SEL, MEAS_INT_1S);\n\n\tbuf[2] &= ~ADC_TM_GEN2_CTL_DEC_RATIO_MASK;\n\tbuf[2] |= FIELD_PREP(ADC_TM_GEN2_CTL_DEC_RATIO_MASK, channel->decimation);\n\tbuf[2] &= ~ADC_TM_GEN2_CTL_CAL_SEL;\n\tbuf[2] |= FIELD_PREP(ADC_TM_GEN2_CTL_CAL_SEL, channel->cal_method);\n\n\tbuf[3] = channel->avg_samples | ADC_TM_GEN2_FAST_AVG_EN;\n\n\tbuf[4] = channel->adc_channel & 0xff;\n\n\tbuf[5] = channel->hw_settle_time & ADC_TM_GEN2_HW_SETTLE_DELAY;\n\n\t \n\tif (high != INT_MAX) {\n\t\tchannel->low_thr_en = true;\n\t\tadc_code = qcom_adc_tm5_gen2_temp_res_scale(high);\n\t\tput_unaligned_le16(adc_code, &buf[9]);\n\t} else {\n\t\tchannel->low_thr_en = false;\n\t}\n\n\t \n\tif (low != -INT_MAX) {\n\t\tchannel->high_thr_en = true;\n\t\tadc_code = qcom_adc_tm5_gen2_temp_res_scale(low);\n\t\tput_unaligned_le16(adc_code, &buf[11]);\n\t} else {\n\t\tchannel->high_thr_en = false;\n\t}\n\n\tbuf[13] = ADC_TM_GEN2_MEAS_EN;\n\tif (channel->high_thr_en)\n\t\tbuf[13] |= ADC_TM5_GEN2_HIGH_THR_INT_EN;\n\tif (channel->low_thr_en)\n\t\tbuf[13] |= ADC_TM5_GEN2_LOW_THR_INT_EN;\n\n\tret = adc_tm5_write(chip, ADC_TM_GEN2_SID, buf, sizeof(buf));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"channel %d params write failed: %d\\n\", channel->channel, ret);\n\t\tgoto config_fail;\n\t}\n\n\tret = adc_tm5_gen2_conv_req(channel->chip);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"adc-tm channel configure failed with %d\\n\", ret);\n\nconfig_fail:\n\tmutex_unlock(&chip->adc_mutex_lock);\n\treturn ret;\n}\n\nstatic int adc_tm5_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct adc_tm5_channel *channel = thermal_zone_device_priv(tz);\n\tstruct adc_tm5_chip *chip;\n\tint ret;\n\n\tif (!channel)\n\t\treturn -EINVAL;\n\n\tchip = channel->chip;\n\tdev_dbg(chip->dev, \"%d:low(mdegC):%d, high(mdegC):%d\\n\",\n\t\tchannel->channel, low, high);\n\n\tif (high == INT_MAX && low <= -INT_MAX)\n\t\tret = chip->data->disable_channel(channel);\n\telse\n\t\tret = chip->data->configure(channel, low, high);\n\n\treturn ret;\n}\n\nstatic const struct thermal_zone_device_ops adc_tm5_thermal_ops = {\n\t.get_temp = adc_tm5_get_temp,\n\t.set_trips = adc_tm5_set_trips,\n};\n\nstatic int adc_tm5_register_tzd(struct adc_tm5_chip *adc_tm)\n{\n\tunsigned int i;\n\tstruct thermal_zone_device *tzd;\n\n\tfor (i = 0; i < adc_tm->nchannels; i++) {\n\t\tadc_tm->channels[i].chip = adc_tm;\n\t\ttzd = devm_thermal_of_zone_register(adc_tm->dev,\n\t\t\t\t\t\t    adc_tm->channels[i].channel,\n\t\t\t\t\t\t    &adc_tm->channels[i],\n\t\t\t\t\t\t    &adc_tm5_thermal_ops);\n\t\tif (IS_ERR(tzd)) {\n\t\t\tif (PTR_ERR(tzd) == -ENODEV) {\n\t\t\t\tdev_dbg(adc_tm->dev, \"thermal sensor on channel %d is not used\\n\",\n\t\t\t\t\t adc_tm->channels[i].channel);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_err(adc_tm->dev, \"Error registering TZ zone for channel %d: %ld\\n\",\n\t\t\t\tadc_tm->channels[i].channel, PTR_ERR(tzd));\n\t\t\treturn PTR_ERR(tzd);\n\t\t}\n\t\tadc_tm->channels[i].tzd = tzd;\n\t\tdevm_thermal_add_hwmon_sysfs(adc_tm->dev, tzd);\n\t}\n\n\treturn 0;\n}\n\nstatic int adc_tm_hc_init(struct adc_tm5_chip *chip)\n{\n\tunsigned int i;\n\tu8 buf[2];\n\tint ret;\n\n\tfor (i = 0; i < chip->nchannels; i++) {\n\t\tif (chip->channels[i].channel >= ADC_TM5_NUM_CHANNELS) {\n\t\t\tdev_err(chip->dev, \"Invalid channel %d\\n\", chip->channels[i].channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbuf[0] = chip->decimation;\n\tbuf[1] = chip->avg_samples | ADC_TM5_FAST_AVG_EN;\n\n\tret = adc_tm5_write(chip, ADC_TM5_ADC_DIG_PARAM, buf, sizeof(buf));\n\tif (ret)\n\t\tdev_err(chip->dev, \"block write failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int adc_tm5_init(struct adc_tm5_chip *chip)\n{\n\tu8 buf[4], channels_available;\n\tint ret;\n\tunsigned int i;\n\n\tret = adc_tm5_read(chip, ADC_TM5_NUM_BTM,\n\t\t\t   &channels_available, sizeof(channels_available));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"read failed for BTM channels\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < chip->nchannels; i++) {\n\t\tif (chip->channels[i].channel >= channels_available) {\n\t\t\tdev_err(chip->dev, \"Invalid channel %d\\n\", chip->channels[i].channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbuf[0] = chip->decimation;\n\tbuf[1] = chip->avg_samples | ADC_TM5_FAST_AVG_EN;\n\tbuf[2] = ADC_TM5_TIMER1;\n\tbuf[3] = FIELD_PREP(ADC_TM5_MEAS_INTERVAL_CTL2_MASK, ADC_TM5_TIMER2) |\n\t\t FIELD_PREP(ADC_TM5_MEAS_INTERVAL_CTL3_MASK, ADC_TM5_TIMER3);\n\n\tret = adc_tm5_write(chip, ADC_TM5_ADC_DIG_PARAM, buf, sizeof(buf));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"block write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int adc_tm5_gen2_init(struct adc_tm5_chip *chip)\n{\n\tu8 channels_available;\n\tint ret;\n\tunsigned int i;\n\n\tret = adc_tm5_read(chip, ADC_TM5_NUM_BTM,\n\t\t\t   &channels_available, sizeof(channels_available));\n\tif (ret) {\n\t\tdev_err(chip->dev, \"read failed for BTM channels\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < chip->nchannels; i++) {\n\t\tif (chip->channels[i].channel >= channels_available) {\n\t\t\tdev_err(chip->dev, \"Invalid channel %d\\n\", chip->channels[i].channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_init(&chip->adc_mutex_lock);\n\n\treturn ret;\n}\n\nstatic int adc_tm5_get_dt_channel_data(struct adc_tm5_chip *adc_tm,\n\t\t\t\t       struct adc_tm5_channel *channel,\n\t\t\t\t       struct device_node *node)\n{\n\tconst char *name = node->name;\n\tu32 chan, value, adc_channel, varr[2];\n\tint ret;\n\tstruct device *dev = adc_tm->dev;\n\tstruct of_phandle_args args;\n\n\tret = of_property_read_u32(node, \"reg\", &chan);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: invalid channel number %d\\n\", name, ret);\n\t\treturn ret;\n\t}\n\n\tif (chan >= ADC_TM5_NUM_CHANNELS) {\n\t\tdev_err(dev, \"%s: channel number too big: %d\\n\", name, chan);\n\t\treturn -EINVAL;\n\t}\n\n\tchannel->channel = chan;\n\n\t \n\tret = of_parse_phandle_with_fixed_args(node, \"io-channels\", 1, 0, &args);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: error parsing ADC channel number %d: %d\\n\", name, chan, ret);\n\t\treturn ret;\n\t}\n\tof_node_put(args.np);\n\n\tif (args.args_count != 1) {\n\t\tdev_err(dev, \"%s: invalid args count for ADC channel %d\\n\", name, chan);\n\t\treturn -EINVAL;\n\t}\n\n\tadc_channel = args.args[0];\n\tif (adc_tm->data->gen == ADC_TM5_GEN2)\n\t\tadc_channel &= 0xff;\n\n\tif (adc_channel >= ADC5_MAX_CHANNEL) {\n\t\tdev_err(dev, \"%s: invalid ADC channel number %d\\n\", name, chan);\n\t\treturn -EINVAL;\n\t}\n\tchannel->adc_channel = args.args[0];\n\n\tchannel->iio = devm_fwnode_iio_channel_get_by_name(adc_tm->dev,\n\t\t\t\t\t\t\t   of_fwnode_handle(node), NULL);\n\tif (IS_ERR(channel->iio)) {\n\t\tret = PTR_ERR(channel->iio);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"%s: error getting channel: %d\\n\", name, ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32_array(node, \"qcom,pre-scaling\", varr, 2);\n\tif (!ret) {\n\t\tret = qcom_adc5_prescaling_from_dt(varr[0], varr[1]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: invalid pre-scaling <%d %d>\\n\",\n\t\t\t\tname, varr[0], varr[1]);\n\t\t\treturn ret;\n\t\t}\n\t\tchannel->prescale = ret;\n\t} else {\n\t\t \n\t\tchannel->prescale = 0;\n\t}\n\n\tret = of_property_read_u32(node, \"qcom,hw-settle-time-us\", &value);\n\tif (!ret) {\n\t\tret = qcom_adc5_hw_settle_time_from_dt(value, adc_tm->data->hw_settle);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s invalid hw-settle-time-us %d us\\n\",\n\t\t\t\tname, value);\n\t\t\treturn ret;\n\t\t}\n\t\tchannel->hw_settle_time = ret;\n\t} else {\n\t\tchannel->hw_settle_time = VADC_DEF_HW_SETTLE_TIME;\n\t}\n\n\tif (of_property_read_bool(node, \"qcom,ratiometric\"))\n\t\tchannel->cal_method = ADC_TM5_RATIOMETRIC_CAL;\n\telse\n\t\tchannel->cal_method = ADC_TM5_ABSOLUTE_CAL;\n\n\tif (adc_tm->data->gen == ADC_TM5_GEN2) {\n\t\tret = of_property_read_u32(node, \"qcom,decimation\", &value);\n\t\tif (!ret) {\n\t\t\tret = qcom_adc5_decimation_from_dt(value, adc_tm->data->decimation);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"invalid decimation %d\\n\", value);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tchannel->decimation = ret;\n\t\t} else {\n\t\t\tchannel->decimation = ADC5_DECIMATION_DEFAULT;\n\t\t}\n\n\t\tret = of_property_read_u32(node, \"qcom,avg-samples\", &value);\n\t\tif (!ret) {\n\t\t\tret = qcom_adc5_avg_samples_from_dt(value);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"invalid avg-samples %d\\n\", value);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tchannel->avg_samples = ret;\n\t\t} else {\n\t\t\tchannel->avg_samples = VADC_DEF_AVG_SAMPLES;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct adc_tm5_data adc_tm5_data_pmic = {\n\t.full_scale_code_volt = 0x70e4,\n\t.decimation = (unsigned int []) { 250, 420, 840 },\n\t.hw_settle = (unsigned int []) { 15, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t\t 1000, 2000, 4000, 8000, 16000, 32000,\n\t\t\t\t\t 64000, 128000 },\n\t.disable_channel = adc_tm5_disable_channel,\n\t.configure = adc_tm5_configure,\n\t.isr = adc_tm5_isr,\n\t.init = adc_tm5_init,\n\t.irq_name = \"pm-adc-tm5\",\n\t.gen = ADC_TM5,\n};\n\nstatic const struct adc_tm5_data adc_tm_hc_data_pmic = {\n\t.full_scale_code_volt = 0x70e4,\n\t.decimation = (unsigned int []) { 256, 512, 1024 },\n\t.hw_settle = (unsigned int []) { 0, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t\t 1000, 2000, 4000, 6000, 8000, 10000 },\n\t.disable_channel = adc_tm5_disable_channel,\n\t.configure = adc_tm5_configure,\n\t.isr = adc_tm5_isr,\n\t.init = adc_tm_hc_init,\n\t.irq_name = \"pm-adc-tm5\",\n\t.gen = ADC_TM_HC,\n};\n\nstatic const struct adc_tm5_data adc_tm5_gen2_data_pmic = {\n\t.full_scale_code_volt = 0x70e4,\n\t.decimation = (unsigned int []) { 85, 340, 1360 },\n\t.hw_settle = (unsigned int []) { 15, 100, 200, 300, 400, 500, 600, 700,\n\t\t\t\t\t 1000, 2000, 4000, 8000, 16000, 32000,\n\t\t\t\t\t 64000, 128000 },\n\t.disable_channel = adc_tm5_gen2_disable_channel,\n\t.configure = adc_tm5_gen2_configure,\n\t.isr = adc_tm5_gen2_isr,\n\t.init = adc_tm5_gen2_init,\n\t.irq_name = \"pm-adc-tm5-gen2\",\n\t.gen = ADC_TM5_GEN2,\n};\n\nstatic int adc_tm5_get_dt_data(struct adc_tm5_chip *adc_tm, struct device_node *node)\n{\n\tstruct adc_tm5_channel *channels;\n\tstruct device_node *child;\n\tu32 value;\n\tint ret;\n\tstruct device *dev = adc_tm->dev;\n\n\tadc_tm->nchannels = of_get_available_child_count(node);\n\tif (!adc_tm->nchannels)\n\t\treturn -EINVAL;\n\n\tadc_tm->channels = devm_kcalloc(dev, adc_tm->nchannels,\n\t\t\t\t\tsizeof(*adc_tm->channels), GFP_KERNEL);\n\tif (!adc_tm->channels)\n\t\treturn -ENOMEM;\n\n\tchannels = adc_tm->channels;\n\n\tadc_tm->data = of_device_get_match_data(dev);\n\tif (!adc_tm->data)\n\t\tadc_tm->data = &adc_tm5_data_pmic;\n\n\tret = of_property_read_u32(node, \"qcom,decimation\", &value);\n\tif (!ret) {\n\t\tret = qcom_adc5_decimation_from_dt(value, adc_tm->data->decimation);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"invalid decimation %d\\n\", value);\n\t\t\treturn ret;\n\t\t}\n\t\tadc_tm->decimation = ret;\n\t} else {\n\t\tadc_tm->decimation = ADC5_DECIMATION_DEFAULT;\n\t}\n\n\tret = of_property_read_u32(node, \"qcom,avg-samples\", &value);\n\tif (!ret) {\n\t\tret = qcom_adc5_avg_samples_from_dt(value);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"invalid avg-samples %d\\n\", value);\n\t\t\treturn ret;\n\t\t}\n\t\tadc_tm->avg_samples = ret;\n\t} else {\n\t\tadc_tm->avg_samples = VADC_DEF_AVG_SAMPLES;\n\t}\n\n\tfor_each_available_child_of_node(node, child) {\n\t\tret = adc_tm5_get_dt_channel_data(adc_tm, channels, child);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tchannels++;\n\t}\n\n\treturn 0;\n}\n\nstatic int adc_tm5_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct adc_tm5_chip *adc_tm;\n\tstruct regmap *regmap;\n\tint ret, irq;\n\tu32 reg;\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap)\n\t\treturn -ENODEV;\n\n\tret = of_property_read_u32(node, \"reg\", &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tadc_tm = devm_kzalloc(&pdev->dev, sizeof(*adc_tm), GFP_KERNEL);\n\tif (!adc_tm)\n\t\treturn -ENOMEM;\n\n\tadc_tm->regmap = regmap;\n\tadc_tm->dev = dev;\n\tadc_tm->base = reg;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = adc_tm5_get_dt_data(adc_tm, node);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"get dt data failed\\n\");\n\n\tret = adc_tm->data->init(adc_tm);\n\tif (ret) {\n\t\tdev_err(dev, \"adc-tm init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = adc_tm5_register_tzd(adc_tm);\n\tif (ret) {\n\t\tdev_err(dev, \"tzd register failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_request_threaded_irq(dev, irq, NULL, adc_tm->data->isr,\n\t\t\tIRQF_ONESHOT, adc_tm->data->irq_name, adc_tm);\n}\n\nstatic const struct of_device_id adc_tm5_match_table[] = {\n\t{\n\t\t.compatible = \"qcom,spmi-adc-tm5\",\n\t\t.data = &adc_tm5_data_pmic,\n\t},\n\t{\n\t\t.compatible = \"qcom,spmi-adc-tm-hc\",\n\t\t.data = &adc_tm_hc_data_pmic,\n\t},\n\t{\n\t\t.compatible = \"qcom,spmi-adc-tm5-gen2\",\n\t\t.data = &adc_tm5_gen2_data_pmic,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adc_tm5_match_table);\n\nstatic struct platform_driver adc_tm5_driver = {\n\t.driver = {\n\t\t.name = \"qcom-spmi-adc-tm5\",\n\t\t.of_match_table = adc_tm5_match_table,\n\t},\n\t.probe = adc_tm5_probe,\n};\nmodule_platform_driver(adc_tm5_driver);\n\nMODULE_DESCRIPTION(\"SPMI PMIC Thermal Monitor ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}