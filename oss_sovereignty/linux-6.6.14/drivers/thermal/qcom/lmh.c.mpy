{
  "module_name": "lmh.c",
  "hash_id": "1f5fa0baa2cff0c90cfc91c796cf3434a298056793d556f9c9f46031f3d9ce04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/qcom/lmh.c",
  "human_readable_source": "\n\n \n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n\n#define LMH_NODE_DCVS\t\t\t0x44435653\n#define LMH_CLUSTER0_NODE_ID\t\t0x6370302D\n#define LMH_CLUSTER1_NODE_ID\t\t0x6370312D\n\n#define LMH_SUB_FN_THERMAL\t\t0x54484D4C\n#define LMH_SUB_FN_CRNT\t\t\t0x43524E54\n#define LMH_SUB_FN_REL\t\t\t0x52454C00\n#define LMH_SUB_FN_BCL\t\t\t0x42434C00\n\n#define LMH_ALGO_MODE_ENABLE\t\t0x454E424C\n#define LMH_TH_HI_THRESHOLD\t\t0x48494748\n#define LMH_TH_LOW_THRESHOLD\t\t0x4C4F5700\n#define LMH_TH_ARM_THRESHOLD\t\t0x41524D00\n\n#define LMH_REG_DCVS_INTR_CLR\t\t0x8\n\n#define LMH_ENABLE_ALGOS\t\t1\n\nstruct lmh_hw_data {\n\tvoid __iomem *base;\n\tstruct irq_domain *domain;\n\tint irq;\n};\n\nstatic irqreturn_t lmh_handle_irq(int hw_irq, void *data)\n{\n\tstruct lmh_hw_data *lmh_data = data;\n\tint irq = irq_find_mapping(lmh_data->domain, 0);\n\n\t \n\tif (irq)\n\t\tgeneric_handle_irq(irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void lmh_enable_interrupt(struct irq_data *d)\n{\n\tstruct lmh_hw_data *lmh_data = irq_data_get_irq_chip_data(d);\n\n\t \n\twritel(0xff, lmh_data->base + LMH_REG_DCVS_INTR_CLR);\n\tenable_irq(lmh_data->irq);\n}\n\nstatic void lmh_disable_interrupt(struct irq_data *d)\n{\n\tstruct lmh_hw_data *lmh_data = irq_data_get_irq_chip_data(d);\n\n\tdisable_irq_nosync(lmh_data->irq);\n}\n\nstatic struct irq_chip lmh_irq_chip = {\n\t.name           = \"lmh\",\n\t.irq_enable\t= lmh_enable_interrupt,\n\t.irq_disable\t= lmh_disable_interrupt\n};\n\nstatic int lmh_irq_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)\n{\n\tstruct lmh_hw_data *lmh_data = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &lmh_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, lmh_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops lmh_irq_ops = {\n\t.map = lmh_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int lmh_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *cpu_node;\n\tstruct lmh_hw_data *lmh_data;\n\tint temp_low, temp_high, temp_arm, cpu_id, ret;\n\tunsigned int enable_alg;\n\tu32 node_id;\n\n\tlmh_data = devm_kzalloc(dev, sizeof(*lmh_data), GFP_KERNEL);\n\tif (!lmh_data)\n\t\treturn -ENOMEM;\n\n\tlmh_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lmh_data->base))\n\t\treturn PTR_ERR(lmh_data->base);\n\n\tcpu_node = of_parse_phandle(np, \"cpus\", 0);\n\tif (!cpu_node)\n\t\treturn -EINVAL;\n\tcpu_id = of_cpu_node_to_id(cpu_node);\n\tof_node_put(cpu_node);\n\n\tret = of_property_read_u32(np, \"qcom,lmh-temp-high-millicelsius\", &temp_high);\n\tif (ret) {\n\t\tdev_err(dev, \"missing qcom,lmh-temp-high-millicelsius property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"qcom,lmh-temp-low-millicelsius\", &temp_low);\n\tif (ret) {\n\t\tdev_err(dev, \"missing qcom,lmh-temp-low-millicelsius property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"qcom,lmh-temp-arm-millicelsius\", &temp_arm);\n\tif (ret) {\n\t\tdev_err(dev, \"missing qcom,lmh-temp-arm-millicelsius property\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (cpu_id == 0) {\n\t\tnode_id = LMH_CLUSTER0_NODE_ID;\n\t} else if (cpu_id == 4) {\n\t\tnode_id = LMH_CLUSTER1_NODE_ID;\n\t} else {\n\t\tdev_err(dev, \"Wrong CPU id associated with LMh node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!qcom_scm_lmh_dcvsh_available())\n\t\treturn -EINVAL;\n\n\tenable_alg = (uintptr_t)of_device_get_match_data(dev);\n\n\tif (enable_alg) {\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_CRNT, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error %d enabling current subfunction\\n\", ret);\n\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_REL, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error %d enabling reliability subfunction\\n\", ret);\n\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_BCL, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error %d enabling BCL subfunction\\n\", ret);\n\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Error %d enabling thermal subfunction\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = qcom_scm_lmh_profile_change(0x1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Error %d changing profile\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_TH_ARM_THRESHOLD, temp_arm,\n\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Error setting thermal ARM threshold%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_TH_HI_THRESHOLD, temp_high,\n\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Error setting thermal HI threshold%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_TH_LOW_THRESHOLD, temp_low,\n\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Error setting thermal ARM threshold%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlmh_data->irq = platform_get_irq(pdev, 0);\n\tlmh_data->domain = irq_domain_add_linear(np, 1, &lmh_irq_ops, lmh_data);\n\tif (!lmh_data->domain) {\n\t\tdev_err(dev, \"Error adding irq_domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq_set_status_flags(lmh_data->irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(dev, lmh_data->irq, lmh_handle_irq,\n\t\t\t       IRQF_ONESHOT | IRQF_NO_SUSPEND,\n\t\t\t       \"lmh-irq\", lmh_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Error %d registering irq %x\\n\", ret, lmh_data->irq);\n\t\tirq_domain_remove(lmh_data->domain);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lmh_table[] = {\n\t{ .compatible = \"qcom,sc8180x-lmh\", },\n\t{ .compatible = \"qcom,sdm845-lmh\", .data = (void *)LMH_ENABLE_ALGOS},\n\t{ .compatible = \"qcom,sm8150-lmh\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lmh_table);\n\nstatic struct platform_driver lmh_driver = {\n\t.probe = lmh_probe,\n\t.driver = {\n\t\t.name = \"qcom-lmh\",\n\t\t.of_match_table = lmh_table,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nmodule_platform_driver(lmh_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"QCOM LMh driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}