{
  "module_name": "lvts_thermal.c",
  "hash_id": "8a4c2d2790b1fdfb3abf5f43c0f3d5854b57219c49dc13b1f69b87f75b920b17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/mediatek/lvts_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/thermal.h>\n#include <dt-bindings/thermal/mediatek,lvts-thermal.h>\n\n#include \"../thermal_hwmon.h\"\n\n#define LVTS_MONCTL0(__base)\t(__base + 0x0000)\n#define LVTS_MONCTL1(__base)\t(__base + 0x0004)\n#define LVTS_MONCTL2(__base)\t(__base + 0x0008)\n#define LVTS_MONINT(__base)\t\t(__base + 0x000C)\n#define LVTS_MONINTSTS(__base)\t(__base + 0x0010)\n#define LVTS_MONIDET0(__base)\t(__base + 0x0014)\n#define LVTS_MONIDET1(__base)\t(__base + 0x0018)\n#define LVTS_MONIDET2(__base)\t(__base + 0x001C)\n#define LVTS_MONIDET3(__base)\t(__base + 0x0020)\n#define LVTS_H2NTHRE(__base)\t(__base + 0x0024)\n#define LVTS_HTHRE(__base)\t\t(__base + 0x0028)\n#define LVTS_OFFSETH(__base)\t(__base + 0x0030)\n#define LVTS_OFFSETL(__base)\t(__base + 0x0034)\n#define LVTS_MSRCTL0(__base)\t(__base + 0x0038)\n#define LVTS_MSRCTL1(__base)\t(__base + 0x003C)\n#define LVTS_TSSEL(__base)\t\t(__base + 0x0040)\n#define LVTS_CALSCALE(__base)\t(__base + 0x0048)\n#define LVTS_ID(__base)\t\t\t(__base + 0x004C)\n#define LVTS_CONFIG(__base)\t\t(__base + 0x0050)\n#define LVTS_EDATA00(__base)\t(__base + 0x0054)\n#define LVTS_EDATA01(__base)\t(__base + 0x0058)\n#define LVTS_EDATA02(__base)\t(__base + 0x005C)\n#define LVTS_EDATA03(__base)\t(__base + 0x0060)\n#define LVTS_MSR0(__base)\t\t(__base + 0x0090)\n#define LVTS_MSR1(__base)\t\t(__base + 0x0094)\n#define LVTS_MSR2(__base)\t\t(__base + 0x0098)\n#define LVTS_MSR3(__base)\t\t(__base + 0x009C)\n#define LVTS_IMMD0(__base)\t\t(__base + 0x00A0)\n#define LVTS_IMMD1(__base)\t\t(__base + 0x00A4)\n#define LVTS_IMMD2(__base)\t\t(__base + 0x00A8)\n#define LVTS_IMMD3(__base)\t\t(__base + 0x00AC)\n#define LVTS_PROTCTL(__base)\t(__base + 0x00C0)\n#define LVTS_PROTTA(__base)\t\t(__base + 0x00C4)\n#define LVTS_PROTTB(__base)\t\t(__base + 0x00C8)\n#define LVTS_PROTTC(__base)\t\t(__base + 0x00CC)\n#define LVTS_CLKEN(__base)\t\t(__base + 0x00E4)\n\n#define LVTS_PERIOD_UNIT\t\t\t0\n#define LVTS_GROUP_INTERVAL\t\t\t0\n#define LVTS_FILTER_INTERVAL\t\t0\n#define LVTS_SENSOR_INTERVAL\t\t0\n#define LVTS_HW_FILTER\t\t\t\t0x0\n#define LVTS_TSSEL_CONF\t\t\t\t0x13121110\n#define LVTS_CALSCALE_CONF\t\t\t0x300\n#define LVTS_MONINT_CONF\t\t\t0x8300318C\n\n#define LVTS_MONINT_OFFSET_SENSOR0\t\t0xC\n#define LVTS_MONINT_OFFSET_SENSOR1\t\t0x180\n#define LVTS_MONINT_OFFSET_SENSOR2\t\t0x3000\n#define LVTS_MONINT_OFFSET_SENSOR3\t\t0x3000000\n\n#define LVTS_INT_SENSOR0\t\t\t0x0009001F\n#define LVTS_INT_SENSOR1\t\t\t0x001203E0\n#define LVTS_INT_SENSOR2\t\t\t0x00247C00\n#define LVTS_INT_SENSOR3\t\t\t0x1FC00000\n\n#define LVTS_SENSOR_MAX\t\t\t\t4\n#define LVTS_GOLDEN_TEMP_MAX\t\t62\n#define LVTS_GOLDEN_TEMP_DEFAULT\t50\n#define LVTS_COEFF_A\t\t\t\t-250460\n#define LVTS_COEFF_B\t\t\t\t250460\n\n#define LVTS_MSR_IMMEDIATE_MODE\t\t0\n#define LVTS_MSR_FILTERED_MODE\t\t1\n\n#define LVTS_MSR_READ_TIMEOUT_US\t400\n#define LVTS_MSR_READ_WAIT_US\t\t(LVTS_MSR_READ_TIMEOUT_US / 2)\n\n#define LVTS_HW_SHUTDOWN_MT8195\t\t105000\n\n#define LVTS_MINIMUM_THRESHOLD\t\t20000\n\nstatic int golden_temp = LVTS_GOLDEN_TEMP_DEFAULT;\nstatic int coeff_b = LVTS_COEFF_B;\n\nstruct lvts_sensor_data {\n\tint dt_id;\n};\n\nstruct lvts_ctrl_data {\n\tstruct lvts_sensor_data lvts_sensor[LVTS_SENSOR_MAX];\n\tint cal_offset[LVTS_SENSOR_MAX];\n\tint hw_tshut_temp;\n\tint num_lvts_sensor;\n\tint offset;\n\tint mode;\n};\n\nstruct lvts_data {\n\tconst struct lvts_ctrl_data *lvts_ctrl;\n\tint num_lvts_ctrl;\n};\n\nstruct lvts_sensor {\n\tstruct thermal_zone_device *tz;\n\tvoid __iomem *msr;\n\tvoid __iomem *base;\n\tint id;\n\tint dt_id;\n\tint low_thresh;\n\tint high_thresh;\n};\n\nstruct lvts_ctrl {\n\tstruct lvts_sensor sensors[LVTS_SENSOR_MAX];\n\tu32 calibration[LVTS_SENSOR_MAX];\n\tu32 hw_tshut_raw_temp;\n\tint num_lvts_sensor;\n\tint mode;\n\tvoid __iomem *base;\n\tint low_thresh;\n\tint high_thresh;\n};\n\nstruct lvts_domain {\n\tstruct lvts_ctrl *lvts_ctrl;\n\tstruct reset_control *reset;\n\tstruct clk *clk;\n\tint num_lvts_ctrl;\n\tvoid __iomem *base;\n\tsize_t calib_len;\n\tu8 *calib;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dom_dentry;\n#endif\n};\n\n#ifdef CONFIG_MTK_LVTS_THERMAL_DEBUGFS\n\n#define LVTS_DEBUG_FS_REGS(__reg)\t\t\\\n{\t\t\t\t\t\t\\\n\t.name = __stringify(__reg),\t\t\\\n\t.offset = __reg(0),\t\t\t\\\n}\n\nstatic const struct debugfs_reg32 lvts_regs[] = {\n\tLVTS_DEBUG_FS_REGS(LVTS_MONCTL0),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONCTL1),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONCTL2),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONINT),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONINTSTS),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONIDET0),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONIDET1),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONIDET2),\n\tLVTS_DEBUG_FS_REGS(LVTS_MONIDET3),\n\tLVTS_DEBUG_FS_REGS(LVTS_H2NTHRE),\n\tLVTS_DEBUG_FS_REGS(LVTS_HTHRE),\n\tLVTS_DEBUG_FS_REGS(LVTS_OFFSETH),\n\tLVTS_DEBUG_FS_REGS(LVTS_OFFSETL),\n\tLVTS_DEBUG_FS_REGS(LVTS_MSRCTL0),\n\tLVTS_DEBUG_FS_REGS(LVTS_MSRCTL1),\n\tLVTS_DEBUG_FS_REGS(LVTS_TSSEL),\n\tLVTS_DEBUG_FS_REGS(LVTS_CALSCALE),\n\tLVTS_DEBUG_FS_REGS(LVTS_ID),\n\tLVTS_DEBUG_FS_REGS(LVTS_CONFIG),\n\tLVTS_DEBUG_FS_REGS(LVTS_EDATA00),\n\tLVTS_DEBUG_FS_REGS(LVTS_EDATA01),\n\tLVTS_DEBUG_FS_REGS(LVTS_EDATA02),\n\tLVTS_DEBUG_FS_REGS(LVTS_EDATA03),\n\tLVTS_DEBUG_FS_REGS(LVTS_MSR0),\n\tLVTS_DEBUG_FS_REGS(LVTS_MSR1),\n\tLVTS_DEBUG_FS_REGS(LVTS_MSR2),\n\tLVTS_DEBUG_FS_REGS(LVTS_MSR3),\n\tLVTS_DEBUG_FS_REGS(LVTS_IMMD0),\n\tLVTS_DEBUG_FS_REGS(LVTS_IMMD1),\n\tLVTS_DEBUG_FS_REGS(LVTS_IMMD2),\n\tLVTS_DEBUG_FS_REGS(LVTS_IMMD3),\n\tLVTS_DEBUG_FS_REGS(LVTS_PROTCTL),\n\tLVTS_DEBUG_FS_REGS(LVTS_PROTTA),\n\tLVTS_DEBUG_FS_REGS(LVTS_PROTTB),\n\tLVTS_DEBUG_FS_REGS(LVTS_PROTTC),\n\tLVTS_DEBUG_FS_REGS(LVTS_CLKEN),\n};\n\nstatic int lvts_debugfs_init(struct device *dev, struct lvts_domain *lvts_td)\n{\n\tstruct debugfs_regset32 *regset;\n\tstruct lvts_ctrl *lvts_ctrl;\n\tstruct dentry *dentry;\n\tchar name[64];\n\tint i;\n\n\tlvts_td->dom_dentry = debugfs_create_dir(dev_name(dev), NULL);\n\tif (IS_ERR(lvts_td->dom_dentry))\n\t\treturn 0;\n\n\tfor (i = 0; i < lvts_td->num_lvts_ctrl; i++) {\n\n\t\tlvts_ctrl = &lvts_td->lvts_ctrl[i];\n\n\t\tsprintf(name, \"controller%d\", i);\n\t\tdentry = debugfs_create_dir(name, lvts_td->dom_dentry);\n\t\tif (!dentry)\n\t\t\tcontinue;\n\n\t\tregset = devm_kzalloc(dev, sizeof(*regset), GFP_KERNEL);\n\t\tif (!regset)\n\t\t\tcontinue;\n\n\t\tregset->base = lvts_ctrl->base;\n\t\tregset->regs = lvts_regs;\n\t\tregset->nregs = ARRAY_SIZE(lvts_regs);\n\n\t\tdebugfs_create_regset32(\"registers\", 0400, dentry, regset);\n\t}\n\n\treturn 0;\n}\n\nstatic void lvts_debugfs_exit(struct lvts_domain *lvts_td)\n{\n\tdebugfs_remove_recursive(lvts_td->dom_dentry);\n}\n\n#else\n\nstatic inline int lvts_debugfs_init(struct device *dev,\n\t\t\t\t    struct lvts_domain *lvts_td)\n{\n\treturn 0;\n}\n\nstatic void lvts_debugfs_exit(struct lvts_domain *lvts_td) { }\n\n#endif\n\nstatic int lvts_raw_to_temp(u32 raw_temp)\n{\n\tint temperature;\n\n\ttemperature = ((s64)(raw_temp & 0xFFFF) * LVTS_COEFF_A) >> 14;\n\ttemperature += coeff_b;\n\n\treturn temperature;\n}\n\nstatic u32 lvts_temp_to_raw(int temperature)\n{\n\tu32 raw_temp = ((s64)(coeff_b - temperature)) << 14;\n\n\traw_temp = div_s64(raw_temp, -LVTS_COEFF_A);\n\n\treturn raw_temp;\n}\n\nstatic int lvts_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct lvts_sensor *lvts_sensor = thermal_zone_device_priv(tz);\n\tvoid __iomem *msr = lvts_sensor->msr;\n\tu32 value;\n\tint rc;\n\n\t \n\trc = readl_poll_timeout(msr, value, value & BIT(16),\n\t\t\t\tLVTS_MSR_READ_WAIT_US, LVTS_MSR_READ_TIMEOUT_US);\n\n\t \n\tif (rc)\n\t\treturn -EAGAIN;\n\n\t*temp = lvts_raw_to_temp(value & 0xFFFF);\n\n\treturn 0;\n}\n\nstatic void lvts_update_irq_mask(struct lvts_ctrl *lvts_ctrl)\n{\n\tu32 masks[] = {\n\t\tLVTS_MONINT_OFFSET_SENSOR0,\n\t\tLVTS_MONINT_OFFSET_SENSOR1,\n\t\tLVTS_MONINT_OFFSET_SENSOR2,\n\t\tLVTS_MONINT_OFFSET_SENSOR3,\n\t};\n\tu32 value = 0;\n\tint i;\n\n\tvalue = readl(LVTS_MONINT(lvts_ctrl->base));\n\n\tfor (i = 0; i < ARRAY_SIZE(masks); i++) {\n\t\tif (lvts_ctrl->sensors[i].high_thresh == lvts_ctrl->high_thresh\n\t\t    && lvts_ctrl->sensors[i].low_thresh == lvts_ctrl->low_thresh)\n\t\t\tvalue |= masks[i];\n\t\telse\n\t\t\tvalue &= ~masks[i];\n\t}\n\n\twritel(value, LVTS_MONINT(lvts_ctrl->base));\n}\n\nstatic bool lvts_should_update_thresh(struct lvts_ctrl *lvts_ctrl, int high)\n{\n\tint i;\n\n\tif (high > lvts_ctrl->high_thresh)\n\t\treturn true;\n\n\tfor (i = 0; i < lvts_ctrl->num_lvts_sensor; i++)\n\t\tif (lvts_ctrl->sensors[i].high_thresh == lvts_ctrl->high_thresh\n\t\t    && lvts_ctrl->sensors[i].low_thresh == lvts_ctrl->low_thresh)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int lvts_set_trips(struct thermal_zone_device *tz, int low, int high)\n{\n\tstruct lvts_sensor *lvts_sensor = thermal_zone_device_priv(tz);\n\tstruct lvts_ctrl *lvts_ctrl = container_of(lvts_sensor, struct lvts_ctrl, sensors[lvts_sensor->id]);\n\tvoid __iomem *base = lvts_sensor->base;\n\tu32 raw_low = lvts_temp_to_raw(low != -INT_MAX ? low : LVTS_MINIMUM_THRESHOLD);\n\tu32 raw_high = lvts_temp_to_raw(high);\n\tbool should_update_thresh;\n\n\tlvts_sensor->low_thresh = low;\n\tlvts_sensor->high_thresh = high;\n\n\tshould_update_thresh = lvts_should_update_thresh(lvts_ctrl, high);\n\tif (should_update_thresh) {\n\t\tlvts_ctrl->high_thresh = high;\n\t\tlvts_ctrl->low_thresh = low;\n\t}\n\tlvts_update_irq_mask(lvts_ctrl);\n\n\tif (!should_update_thresh)\n\t\treturn 0;\n\n\t \n\tpr_debug(\"%s: Setting low limit temperature interrupt: %d\\n\",\n\t\t thermal_zone_device_type(tz), low);\n\twritel(raw_low, LVTS_OFFSETL(base));\n\n\t \n\tpr_debug(\"%s: Setting high limit temperature interrupt: %d\\n\",\n\t\t thermal_zone_device_type(tz), high);\n\twritel(raw_high, LVTS_OFFSETH(base));\n\n\treturn 0;\n}\n\nstatic irqreturn_t lvts_ctrl_irq_handler(struct lvts_ctrl *lvts_ctrl)\n{\n\tirqreturn_t iret = IRQ_NONE;\n\tu32 value;\n\tu32 masks[] = {\n\t\tLVTS_INT_SENSOR0,\n\t\tLVTS_INT_SENSOR1,\n\t\tLVTS_INT_SENSOR2,\n\t\tLVTS_INT_SENSOR3\n\t};\n\tint i;\n\n\t \n\tvalue = readl(LVTS_MONINTSTS(lvts_ctrl->base));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(masks); i++) {\n\n\t\tif (!(value & masks[i]))\n\t\t\tcontinue;\n\n\t\tthermal_zone_device_update(lvts_ctrl->sensors[i].tz,\n\t\t\t\t\t   THERMAL_TRIP_VIOLATED);\n\t\tiret = IRQ_HANDLED;\n\t}\n\n\t \n\twritel(value, LVTS_MONINTSTS(lvts_ctrl->base));\n\n\treturn iret;\n}\n\n \nstatic irqreturn_t lvts_irq_handler(int irq, void *data)\n{\n\tstruct lvts_domain *lvts_td = data;\n\tirqreturn_t aux, iret = IRQ_NONE;\n\tint i;\n\n\tfor (i = 0; i < lvts_td->num_lvts_ctrl; i++) {\n\n\t\taux = lvts_ctrl_irq_handler(&lvts_td->lvts_ctrl[i]);\n\t\tif (aux != IRQ_HANDLED)\n\t\t\tcontinue;\n\n\t\tiret = IRQ_HANDLED;\n\t}\n\n\treturn iret;\n}\n\nstatic struct thermal_zone_device_ops lvts_ops = {\n\t.get_temp = lvts_get_temp,\n\t.set_trips = lvts_set_trips,\n};\n\nstatic int lvts_sensor_init(struct device *dev, struct lvts_ctrl *lvts_ctrl,\n\t\t\t\t\tconst struct lvts_ctrl_data *lvts_ctrl_data)\n{\n\tstruct lvts_sensor *lvts_sensor = lvts_ctrl->sensors;\n\tvoid __iomem *msr_regs[] = {\n\t\tLVTS_MSR0(lvts_ctrl->base),\n\t\tLVTS_MSR1(lvts_ctrl->base),\n\t\tLVTS_MSR2(lvts_ctrl->base),\n\t\tLVTS_MSR3(lvts_ctrl->base)\n\t};\n\n\tvoid __iomem *imm_regs[] = {\n\t\tLVTS_IMMD0(lvts_ctrl->base),\n\t\tLVTS_IMMD1(lvts_ctrl->base),\n\t\tLVTS_IMMD2(lvts_ctrl->base),\n\t\tLVTS_IMMD3(lvts_ctrl->base)\n\t};\n\n\tint i;\n\n\tfor (i = 0; i < lvts_ctrl_data->num_lvts_sensor; i++) {\n\n\t\tint dt_id = lvts_ctrl_data->lvts_sensor[i].dt_id;\n\n\t\t \n\t\tlvts_sensor[i].id = i;\n\n\t\t \n\t\tlvts_sensor[i].dt_id = dt_id;\n\n\t\t \n\t\tlvts_sensor[i].base = lvts_ctrl->base;\n\n\t\t \n\t\tlvts_sensor[i].msr = lvts_ctrl_data->mode == LVTS_MSR_IMMEDIATE_MODE ?\n\t\t\timm_regs[i] : msr_regs[i];\n\n\t\tlvts_sensor[i].low_thresh = INT_MIN;\n\t\tlvts_sensor[i].high_thresh = INT_MIN;\n\t};\n\n\tlvts_ctrl->num_lvts_sensor = lvts_ctrl_data->num_lvts_sensor;\n\n\treturn 0;\n}\n\n \nstatic int lvts_calibration_init(struct device *dev, struct lvts_ctrl *lvts_ctrl,\n\t\t\t\t\tconst struct lvts_ctrl_data *lvts_ctrl_data,\n\t\t\t\t\tu8 *efuse_calibration)\n{\n\tint i;\n\n\tfor (i = 0; i < lvts_ctrl_data->num_lvts_sensor; i++)\n\t\tmemcpy(&lvts_ctrl->calibration[i],\n\t\t       efuse_calibration + lvts_ctrl_data->cal_offset[i], 2);\n\n\treturn 0;\n}\n\n \nstatic int lvts_calibration_read(struct device *dev, struct lvts_domain *lvts_td,\n\t\t\t\t\tconst struct lvts_data *lvts_data)\n{\n\tstruct device_node *np = dev_of_node(dev);\n\tstruct nvmem_cell *cell;\n\tstruct property *prop;\n\tconst char *cell_name;\n\n\tof_property_for_each_string(np, \"nvmem-cell-names\", prop, cell_name) {\n\t\tsize_t len;\n\t\tu8 *efuse;\n\n\t\tcell = of_nvmem_cell_get(np, cell_name);\n\t\tif (IS_ERR(cell)) {\n\t\t\tdev_err(dev, \"Failed to get cell '%s'\\n\", cell_name);\n\t\t\treturn PTR_ERR(cell);\n\t\t}\n\n\t\tefuse = nvmem_cell_read(cell, &len);\n\n\t\tnvmem_cell_put(cell);\n\n\t\tif (IS_ERR(efuse)) {\n\t\t\tdev_err(dev, \"Failed to read cell '%s'\\n\", cell_name);\n\t\t\treturn PTR_ERR(efuse);\n\t\t}\n\n\t\tlvts_td->calib = devm_krealloc(dev, lvts_td->calib,\n\t\t\t\t\t       lvts_td->calib_len + len, GFP_KERNEL);\n\t\tif (!lvts_td->calib)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(lvts_td->calib + lvts_td->calib_len, efuse, len);\n\n\t\tlvts_td->calib_len += len;\n\n\t\tkfree(efuse);\n\t}\n\n\treturn 0;\n}\n\nstatic int lvts_golden_temp_init(struct device *dev, u32 *value)\n{\n\tu32 gt;\n\n\tgt = (*value) >> 24;\n\n\tif (gt && gt < LVTS_GOLDEN_TEMP_MAX)\n\t\tgolden_temp = gt;\n\n\tcoeff_b = golden_temp * 500 + LVTS_COEFF_B;\n\n\treturn 0;\n}\n\nstatic int lvts_ctrl_init(struct device *dev, struct lvts_domain *lvts_td,\n\t\t\t\t\tconst struct lvts_data *lvts_data)\n{\n\tsize_t size = sizeof(*lvts_td->lvts_ctrl) * lvts_data->num_lvts_ctrl;\n\tstruct lvts_ctrl *lvts_ctrl;\n\tint i, ret;\n\n\t \n\tret = lvts_calibration_read(dev, lvts_td, lvts_data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = lvts_golden_temp_init(dev, (u32 *)lvts_td->calib);\n\tif (ret)\n\t\treturn ret;\n\n\tlvts_ctrl = devm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!lvts_ctrl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < lvts_data->num_lvts_ctrl; i++) {\n\n\t\tlvts_ctrl[i].base = lvts_td->base + lvts_data->lvts_ctrl[i].offset;\n\n\t\tret = lvts_sensor_init(dev, &lvts_ctrl[i],\n\t\t\t\t       &lvts_data->lvts_ctrl[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = lvts_calibration_init(dev, &lvts_ctrl[i],\n\t\t\t\t\t    &lvts_data->lvts_ctrl[i],\n\t\t\t\t\t    lvts_td->calib);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tlvts_ctrl[i].mode = lvts_data->lvts_ctrl[i].mode;\n\n\t\t \n\t\tlvts_ctrl[i].hw_tshut_raw_temp =\n\t\t\tlvts_temp_to_raw(lvts_data->lvts_ctrl[i].hw_tshut_temp);\n\n\t\tlvts_ctrl[i].low_thresh = INT_MIN;\n\t\tlvts_ctrl[i].high_thresh = INT_MIN;\n\t}\n\n\t \n\tdevm_kfree(dev, lvts_td->calib);\n\n\tlvts_td->lvts_ctrl = lvts_ctrl;\n\tlvts_td->num_lvts_ctrl = lvts_data->num_lvts_ctrl;\n\n\treturn 0;\n}\n\n \nstatic void lvts_write_config(struct lvts_ctrl *lvts_ctrl, u32 *cmds, int nr_cmds)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nr_cmds; i++) {\n\t\twritel(cmds[i], LVTS_CONFIG(lvts_ctrl->base));\n\t\tusleep_range(2, 4);\n\t}\n}\n\nstatic int lvts_irq_init(struct lvts_ctrl *lvts_ctrl)\n{\n\t \n\twritel(BIT(16), LVTS_PROTCTL(lvts_ctrl->base));\n\n\t \n\twritel(lvts_ctrl->hw_tshut_raw_temp, LVTS_PROTTC(lvts_ctrl->base));\n\n\t \n\twritel(LVTS_MONINT_CONF, LVTS_MONINT(lvts_ctrl->base));\n\n\treturn 0;\n}\n\nstatic int lvts_domain_reset(struct device *dev, struct reset_control *reset)\n{\n\tint ret;\n\n\tret = reset_control_assert(reset);\n\tif (ret)\n\t\treturn ret;\n\n\treturn reset_control_deassert(reset);\n}\n\n \nstatic int lvts_ctrl_set_enable(struct lvts_ctrl *lvts_ctrl, int enable)\n{\n\t \n\twritel(enable, LVTS_CLKEN(lvts_ctrl->base));\n\n\treturn 0;\n}\n\nstatic int lvts_ctrl_connect(struct device *dev, struct lvts_ctrl *lvts_ctrl)\n{\n\tu32 id, cmds[] = { 0xC103FFFF, 0xC502FF55 };\n\n\tlvts_write_config(lvts_ctrl, cmds, ARRAY_SIZE(cmds));\n\n\t \n\tid = readl(LVTS_ID(lvts_ctrl->base));\n\tif (!(id & BIT(7)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int lvts_ctrl_initialize(struct device *dev, struct lvts_ctrl *lvts_ctrl)\n{\n\t \n\tu32 cmds[] = {\n\t\t0xC1030E01, 0xC1030CFC, 0xC1030A8C, 0xC103098D, 0xC10308F1,\n\t\t0xC10307A6, 0xC10306B8, 0xC1030500, 0xC1030420, 0xC1030300,\n\t\t0xC1030030, 0xC10300F6, 0xC1030050, 0xC1030060, 0xC10300AC,\n\t\t0xC10300FC, 0xC103009D, 0xC10300F1, 0xC10300E1\n\t};\n\n\tlvts_write_config(lvts_ctrl, cmds, ARRAY_SIZE(cmds));\n\n\treturn 0;\n}\n\nstatic int lvts_ctrl_calibrate(struct device *dev, struct lvts_ctrl *lvts_ctrl)\n{\n\tint i;\n\tvoid __iomem *lvts_edata[] = {\n\t\tLVTS_EDATA00(lvts_ctrl->base),\n\t\tLVTS_EDATA01(lvts_ctrl->base),\n\t\tLVTS_EDATA02(lvts_ctrl->base),\n\t\tLVTS_EDATA03(lvts_ctrl->base)\n\t};\n\n\t \n\tfor (i = 0; i < LVTS_SENSOR_MAX; i++)\n\t\twritel(lvts_ctrl->calibration[i], lvts_edata[i]);\n\n\treturn 0;\n}\n\nstatic int lvts_ctrl_configure(struct device *dev, struct lvts_ctrl *lvts_ctrl)\n{\n\tu32 value;\n\n\t \n\tvalue = LVTS_TSSEL_CONF;\n\twritel(value, LVTS_TSSEL(lvts_ctrl->base));\n\n\t \n\tvalue = 0x300;\n\tvalue = LVTS_CALSCALE_CONF;\n\n\t \n\tvalue = LVTS_HW_FILTER << 9 |  LVTS_HW_FILTER << 6 |\n\t\t\tLVTS_HW_FILTER << 3 | LVTS_HW_FILTER;\n\twritel(value, LVTS_MSRCTL0(lvts_ctrl->base));\n\n\t \n\tvalue = LVTS_GROUP_INTERVAL << 20 | LVTS_PERIOD_UNIT;\n\twritel(value, LVTS_MONCTL1(lvts_ctrl->base));\n\n\t \n\tvalue = LVTS_FILTER_INTERVAL << 16 | LVTS_SENSOR_INTERVAL;\n\twritel(value, LVTS_MONCTL2(lvts_ctrl->base));\n\n\treturn lvts_irq_init(lvts_ctrl);\n}\n\nstatic int lvts_ctrl_start(struct device *dev, struct lvts_ctrl *lvts_ctrl)\n{\n\tstruct lvts_sensor *lvts_sensors = lvts_ctrl->sensors;\n\tstruct thermal_zone_device *tz;\n\tu32 sensor_map = 0;\n\tint i;\n\t \n\tu32 sensor_imm_bitmap[] = { BIT(4), BIT(5), BIT(6), BIT(9) };\n\tu32 sensor_filt_bitmap[] = { BIT(0), BIT(1), BIT(2), BIT(3) };\n\n\tu32 *sensor_bitmap = lvts_ctrl->mode == LVTS_MSR_IMMEDIATE_MODE ?\n\t\t\t     sensor_imm_bitmap : sensor_filt_bitmap;\n\n\tfor (i = 0; i < lvts_ctrl->num_lvts_sensor; i++) {\n\n\t\tint dt_id = lvts_sensors[i].dt_id;\n\n\t\ttz = devm_thermal_of_zone_register(dev, dt_id, &lvts_sensors[i],\n\t\t\t\t\t\t   &lvts_ops);\n\t\tif (IS_ERR(tz)) {\n\t\t\t \n\t\t\tif (PTR_ERR(tz) == -ENODEV)\n\t\t\t\tcontinue;\n\n\t\t\treturn PTR_ERR(tz);\n\t\t}\n\n\t\tdevm_thermal_add_hwmon_sysfs(dev, tz);\n\n\t\t \n\t\tlvts_sensors[i].tz = tz;\n\n\t\t \n\t\tsensor_map |= sensor_bitmap[i];\n\t}\n\n\t \n\tif (lvts_ctrl->mode == LVTS_MSR_IMMEDIATE_MODE) {\n\t\t \n\t\twritel(sensor_map, LVTS_MSRCTL1(lvts_ctrl->base));\n\t} else {\n\t\t \n\t\twritel(sensor_map | BIT(9), LVTS_MONCTL0(lvts_ctrl->base));\n\t}\n\n\treturn 0;\n}\n\nstatic int lvts_domain_init(struct device *dev, struct lvts_domain *lvts_td,\n\t\t\t\t\tconst struct lvts_data *lvts_data)\n{\n\tstruct lvts_ctrl *lvts_ctrl;\n\tint i, ret;\n\n\tret = lvts_ctrl_init(dev, lvts_td, lvts_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lvts_domain_reset(dev, lvts_td->reset);\n\tif (ret) {\n\t\tdev_dbg(dev, \"Failed to reset domain\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < lvts_td->num_lvts_ctrl; i++) {\n\n\t\tlvts_ctrl = &lvts_td->lvts_ctrl[i];\n\n\t\t \n\t\tret = lvts_ctrl_set_enable(lvts_ctrl, true);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Failed to enable LVTS clock\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lvts_ctrl_connect(dev, lvts_ctrl);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Failed to connect to LVTS controller\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lvts_ctrl_initialize(dev, lvts_ctrl);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Failed to initialize controller\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lvts_ctrl_calibrate(dev, lvts_ctrl);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Failed to calibrate controller\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lvts_ctrl_configure(dev, lvts_ctrl);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Failed to configure controller\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lvts_ctrl_start(dev, lvts_ctrl);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Failed to start controller\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn lvts_debugfs_init(dev, lvts_td);\n}\n\nstatic int lvts_probe(struct platform_device *pdev)\n{\n\tconst struct lvts_data *lvts_data;\n\tstruct lvts_domain *lvts_td;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tlvts_td = devm_kzalloc(dev, sizeof(*lvts_td), GFP_KERNEL);\n\tif (!lvts_td)\n\t\treturn -ENOMEM;\n\n\tlvts_data = of_device_get_match_data(dev);\n\n\tlvts_td->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(lvts_td->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvts_td->clk), \"Failed to retrieve clock\\n\");\n\n\tres = platform_get_mem_or_io(pdev, 0);\n\tif (!res)\n\t\treturn dev_err_probe(dev, (-ENXIO), \"No IO resource\\n\");\n\n\tlvts_td->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(lvts_td->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvts_td->base), \"Failed to map io resource\\n\");\n\n\tlvts_td->reset = devm_reset_control_get_by_index(dev, 0);\n\tif (IS_ERR(lvts_td->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvts_td->reset), \"Failed to get reset control\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = lvts_domain_init(dev, lvts_td, lvts_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to initialize the lvts domain\\n\");\n\n\t \n\tret = devm_request_threaded_irq(dev, irq, NULL, lvts_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), lvts_td);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request interrupt\\n\");\n\n\tplatform_set_drvdata(pdev, lvts_td);\n\n\treturn 0;\n}\n\nstatic int lvts_remove(struct platform_device *pdev)\n{\n\tstruct lvts_domain *lvts_td;\n\tint i;\n\n\tlvts_td = platform_get_drvdata(pdev);\n\n\tfor (i = 0; i < lvts_td->num_lvts_ctrl; i++)\n\t\tlvts_ctrl_set_enable(&lvts_td->lvts_ctrl[i], false);\n\n\tlvts_debugfs_exit(lvts_td);\n\n\treturn 0;\n}\n\nstatic const struct lvts_ctrl_data mt8195_lvts_mcu_data_ctrl[] = {\n\t{\n\t\t.cal_offset = { 0x04, 0x07 },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_MCU_BIG_CPU0 },\n\t\t\t{ .dt_id = MT8195_MCU_BIG_CPU1 }\n\t\t},\n\t\t.num_lvts_sensor = 2,\n\t\t.offset = 0x0,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t},\n\t{\n\t\t.cal_offset = { 0x0d, 0x10 },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_MCU_BIG_CPU2 },\n\t\t\t{ .dt_id = MT8195_MCU_BIG_CPU3 }\n\t\t},\n\t\t.num_lvts_sensor = 2,\n\t\t.offset = 0x100,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t},\n\t{\n\t\t.cal_offset = { 0x16, 0x19, 0x1c, 0x1f },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_MCU_LITTLE_CPU0 },\n\t\t\t{ .dt_id = MT8195_MCU_LITTLE_CPU1 },\n\t\t\t{ .dt_id = MT8195_MCU_LITTLE_CPU2 },\n\t\t\t{ .dt_id = MT8195_MCU_LITTLE_CPU3 }\n\t\t},\n\t\t.num_lvts_sensor = 4,\n\t\t.offset = 0x200,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t}\n};\n\nstatic const struct lvts_ctrl_data mt8195_lvts_ap_data_ctrl[] = {\n\t\t{\n\t\t.cal_offset = { 0x25, 0x28 },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_AP_VPU0 },\n\t\t\t{ .dt_id = MT8195_AP_VPU1 }\n\t\t},\n\t\t.num_lvts_sensor = 2,\n\t\t.offset = 0x0,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t},\n\t{\n\t\t.cal_offset = { 0x2e, 0x31 },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_AP_GPU0 },\n\t\t\t{ .dt_id = MT8195_AP_GPU1 }\n\t\t},\n\t\t.num_lvts_sensor = 2,\n\t\t.offset = 0x100,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t},\n\t{\n\t\t.cal_offset = { 0x37, 0x3a, 0x3d },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_AP_VDEC },\n\t\t\t{ .dt_id = MT8195_AP_IMG },\n\t\t\t{ .dt_id = MT8195_AP_INFRA },\n\t\t},\n\t\t.num_lvts_sensor = 3,\n\t\t.offset = 0x200,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t},\n\t{\n\t\t.cal_offset = { 0x43, 0x46 },\n\t\t.lvts_sensor = {\n\t\t\t{ .dt_id = MT8195_AP_CAM0 },\n\t\t\t{ .dt_id = MT8195_AP_CAM1 }\n\t\t},\n\t\t.num_lvts_sensor = 2,\n\t\t.offset = 0x300,\n\t\t.hw_tshut_temp = LVTS_HW_SHUTDOWN_MT8195,\n\t}\n};\n\nstatic const struct lvts_data mt8195_lvts_mcu_data = {\n\t.lvts_ctrl\t= mt8195_lvts_mcu_data_ctrl,\n\t.num_lvts_ctrl\t= ARRAY_SIZE(mt8195_lvts_mcu_data_ctrl),\n};\n\nstatic const struct lvts_data mt8195_lvts_ap_data = {\n\t.lvts_ctrl\t= mt8195_lvts_ap_data_ctrl,\n\t.num_lvts_ctrl\t= ARRAY_SIZE(mt8195_lvts_ap_data_ctrl),\n};\n\nstatic const struct of_device_id lvts_of_match[] = {\n\t{ .compatible = \"mediatek,mt8195-lvts-mcu\", .data = &mt8195_lvts_mcu_data },\n\t{ .compatible = \"mediatek,mt8195-lvts-ap\", .data = &mt8195_lvts_ap_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lvts_of_match);\n\nstatic struct platform_driver lvts_driver = {\n\t.probe = lvts_probe,\n\t.remove = lvts_remove,\n\t.driver = {\n\t\t.name = \"mtk-lvts-thermal\",\n\t\t.of_match_table = lvts_of_match,\n\t},\n};\nmodule_platform_driver(lvts_driver);\n\nMODULE_AUTHOR(\"Balsam CHIHI <bchihi@baylibre.com>\");\nMODULE_DESCRIPTION(\"MediaTek LVTS Thermal Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}