{
  "module_name": "auxadc_thermal.c",
  "hash_id": "580ffe6a5b899f2a4bf62b011fca423b6d332a7af627197ee8396ffdb0e4150a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/mediatek/auxadc_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/thermal.h>\n#include <linux/reset.h>\n#include <linux/types.h>\n\n#include \"../thermal_hwmon.h\"\n\n \n#define AUXADC_CON1_SET_V\t0x008\n#define AUXADC_CON1_CLR_V\t0x00c\n#define AUXADC_CON2_V\t\t0x010\n#define AUXADC_DATA(channel)\t(0x14 + (channel) * 4)\n\n#define APMIXED_SYS_TS_CON0\t0x600\n#define APMIXED_SYS_TS_CON1\t0x604\n\n \n#define TEMP_MONCTL0\t\t0x000\n#define TEMP_MONCTL1\t\t0x004\n#define TEMP_MONCTL2\t\t0x008\n#define TEMP_MONIDET0\t\t0x014\n#define TEMP_MONIDET1\t\t0x018\n#define TEMP_MSRCTL0\t\t0x038\n#define TEMP_MSRCTL1\t\t0x03c\n#define TEMP_AHBPOLL\t\t0x040\n#define TEMP_AHBTO\t\t0x044\n#define TEMP_ADCPNP0\t\t0x048\n#define TEMP_ADCPNP1\t\t0x04c\n#define TEMP_ADCPNP2\t\t0x050\n#define TEMP_ADCPNP3\t\t0x0b4\n\n#define TEMP_ADCMUX\t\t0x054\n#define TEMP_ADCEN\t\t0x060\n#define TEMP_PNPMUXADDR\t\t0x064\n#define TEMP_ADCMUXADDR\t\t0x068\n#define TEMP_ADCENADDR\t\t0x074\n#define TEMP_ADCVALIDADDR\t0x078\n#define TEMP_ADCVOLTADDR\t0x07c\n#define TEMP_RDCTRL\t\t0x080\n#define TEMP_ADCVALIDMASK\t0x084\n#define TEMP_ADCVOLTAGESHIFT\t0x088\n#define TEMP_ADCWRITECTRL\t0x08c\n#define TEMP_MSR0\t\t0x090\n#define TEMP_MSR1\t\t0x094\n#define TEMP_MSR2\t\t0x098\n#define TEMP_MSR3\t\t0x0B8\n\n#define TEMP_SPARE0\t\t0x0f0\n\n#define TEMP_ADCPNP0_1          0x148\n#define TEMP_ADCPNP1_1          0x14c\n#define TEMP_ADCPNP2_1          0x150\n#define TEMP_MSR0_1             0x190\n#define TEMP_MSR1_1             0x194\n#define TEMP_MSR2_1             0x198\n#define TEMP_ADCPNP3_1          0x1b4\n#define TEMP_MSR3_1             0x1B8\n\n#define PTPCORESEL\t\t0x400\n\n#define TEMP_MONCTL1_PERIOD_UNIT(x)\t((x) & 0x3ff)\n\n#define TEMP_MONCTL2_FILTER_INTERVAL(x)\t(((x) & 0x3ff) << 16)\n#define TEMP_MONCTL2_SENSOR_INTERVAL(x)\t((x) & 0x3ff)\n\n#define TEMP_AHBPOLL_ADC_POLL_INTERVAL(x)\t(x)\n\n#define TEMP_ADCWRITECTRL_ADC_PNP_WRITE\t\tBIT(0)\n#define TEMP_ADCWRITECTRL_ADC_MUX_WRITE\t\tBIT(1)\n\n#define TEMP_ADCVALIDMASK_VALID_HIGH\t\tBIT(5)\n#define TEMP_ADCVALIDMASK_VALID_POS(bit)\t(bit)\n\n \n#define MT8173_TS1\t0\n#define MT8173_TS2\t1\n#define MT8173_TS3\t2\n#define MT8173_TS4\t3\n#define MT8173_TSABB\t4\n\n \n#define MT8173_TEMP_AUXADC_CHANNEL\t11\n\n \n#define MT8173_NUM_SENSORS\t\t5\n\n \n#define MT8173_NUM_ZONES\t\t4\n\n \n#define MT8173_NUM_SENSORS_PER_ZONE\t4\n\n \n#define MT8173_NUM_CONTROLLER\t\t1\n\n \n#define MT8173_CALIBRATION\t165\n\n \n#define MT8173_TEMP_MIN\t\t-20000\n#define MT8173_TEMP_MAX\t\t150000\n\n \n#define CALIB_BUF0_VALID_V1\t\tBIT(0)\n#define CALIB_BUF1_ADC_GE_V1(x)\t\t(((x) >> 22) & 0x3ff)\n#define CALIB_BUF0_VTS_TS1_V1(x)\t(((x) >> 17) & 0x1ff)\n#define CALIB_BUF0_VTS_TS2_V1(x)\t(((x) >> 8) & 0x1ff)\n#define CALIB_BUF1_VTS_TS3_V1(x)\t(((x) >> 0) & 0x1ff)\n#define CALIB_BUF2_VTS_TS4_V1(x)\t(((x) >> 23) & 0x1ff)\n#define CALIB_BUF2_VTS_TS5_V1(x)\t(((x) >> 5) & 0x1ff)\n#define CALIB_BUF2_VTS_TSABB_V1(x)\t(((x) >> 14) & 0x1ff)\n#define CALIB_BUF0_DEGC_CALI_V1(x)\t(((x) >> 1) & 0x3f)\n#define CALIB_BUF0_O_SLOPE_V1(x)\t(((x) >> 26) & 0x3f)\n#define CALIB_BUF0_O_SLOPE_SIGN_V1(x)\t(((x) >> 7) & 0x1)\n#define CALIB_BUF1_ID_V1(x)\t\t(((x) >> 9) & 0x1)\n\n \n#define CALIB_BUF0_ADC_OE_V2(x)\t\t(((x) >> 22) & 0x3ff)\n#define CALIB_BUF0_ADC_GE_V2(x)\t\t(((x) >> 12) & 0x3ff)\n#define CALIB_BUF0_DEGC_CALI_V2(x)\t(((x) >> 6) & 0x3f)\n#define CALIB_BUF0_O_SLOPE_V2(x)\t(((x) >> 0) & 0x3f)\n#define CALIB_BUF1_VTS_TS1_V2(x)\t(((x) >> 23) & 0x1ff)\n#define CALIB_BUF1_VTS_TS2_V2(x)\t(((x) >> 14) & 0x1ff)\n#define CALIB_BUF1_VTS_TSABB_V2(x)\t(((x) >> 5) & 0x1ff)\n#define CALIB_BUF1_VALID_V2(x)\t\t(((x) >> 4) & 0x1)\n#define CALIB_BUF1_O_SLOPE_SIGN_V2(x)\t(((x) >> 3) & 0x1)\n\n \n#define CALIB_BUF0_ADC_GE_V3(x)\t\t(((x) >> 0) & 0x3ff)\n#define CALIB_BUF0_DEGC_CALI_V3(x)\t(((x) >> 20) & 0x3f)\n#define CALIB_BUF0_O_SLOPE_V3(x)\t(((x) >> 26) & 0x3f)\n#define CALIB_BUF1_VTS_TS1_V3(x)\t(((x) >> 0) & 0x1ff)\n#define CALIB_BUF1_VTS_TS2_V3(x)\t(((x) >> 21) & 0x1ff)\n#define CALIB_BUF1_VTS_TSABB_V3(x)\t(((x) >> 9) & 0x1ff)\n#define CALIB_BUF1_VALID_V3(x)\t\t(((x) >> 18) & 0x1)\n#define CALIB_BUF1_O_SLOPE_SIGN_V3(x)\t(((x) >> 19) & 0x1)\n#define CALIB_BUF1_ID_V3(x)\t\t(((x) >> 20) & 0x1)\n\nenum {\n\tVTS1,\n\tVTS2,\n\tVTS3,\n\tVTS4,\n\tVTS5,\n\tVTSABB,\n\tMAX_NUM_VTS,\n};\n\nenum mtk_thermal_version {\n\tMTK_THERMAL_V1 = 1,\n\tMTK_THERMAL_V2,\n\tMTK_THERMAL_V3,\n};\n\n \n#define MT2701_TS1\t0\n#define MT2701_TS2\t1\n#define MT2701_TSABB\t2\n\n \n#define MT2701_TEMP_AUXADC_CHANNEL\t11\n\n \n#define MT2701_NUM_SENSORS\t3\n\n \n#define MT2701_NUM_SENSORS_PER_ZONE\t3\n\n \n#define MT2701_NUM_CONTROLLER\t\t1\n\n \n#define MT2701_CALIBRATION\t165\n\n \n#define MT2712_TS1\t0\n#define MT2712_TS2\t1\n#define MT2712_TS3\t2\n#define MT2712_TS4\t3\n\n \n#define MT2712_TEMP_AUXADC_CHANNEL\t11\n\n \n#define MT2712_NUM_SENSORS\t4\n\n \n#define MT2712_NUM_SENSORS_PER_ZONE\t4\n\n \n#define MT2712_NUM_CONTROLLER\t\t1\n\n \n#define MT2712_CALIBRATION\t165\n\n#define MT7622_TEMP_AUXADC_CHANNEL\t11\n#define MT7622_NUM_SENSORS\t\t1\n#define MT7622_NUM_ZONES\t\t1\n#define MT7622_NUM_SENSORS_PER_ZONE\t1\n#define MT7622_TS1\t0\n#define MT7622_NUM_CONTROLLER\t\t1\n\n \n#define MAX_NUM_ZONES\t\t8\n\n \n#define MT7622_CALIBRATION\t165\n\n \n#define MT8183_TS1\t0\n#define MT8183_TS2\t1\n#define MT8183_TS3\t2\n#define MT8183_TS4\t3\n#define MT8183_TS5\t4\n#define MT8183_TSABB\t5\n\n \n#define MT8183_TEMP_AUXADC_CHANNEL\t11\n\n \n#define MT8183_NUM_SENSORS\t6\n\n \n#define MT8183_NUM_ZONES               1\n\n \n#define MT8183_NUM_SENSORS_PER_ZONE\t 6\n\n \n#define MT8183_NUM_CONTROLLER\t\t2\n\n \n#define MT8183_CALIBRATION\t153\n\n \n#define MT7986_TEMP_AUXADC_CHANNEL\t11\n\n \n#define MT7986_NUM_SENSORS\t\t1\n\n \n#define MT7986_NUM_ZONES\t\t1\n\n \n#define MT7986_NUM_SENSORS_PER_ZONE\t1\n\n \n#define MT7986_TS1\t\t\t0\n\n \n#define MT7986_NUM_CONTROLLER\t\t1\n\n \n#define MT7986_CALIBRATION\t\t165\n\n \n#define MT8365_TEMP_AUXADC_CHANNEL 11\n#define MT8365_CALIBRATION 164\n#define MT8365_NUM_CONTROLLER 1\n#define MT8365_NUM_BANKS 1\n#define MT8365_NUM_SENSORS 3\n#define MT8365_NUM_SENSORS_PER_ZONE 3\n#define MT8365_TS1 0\n#define MT8365_TS2 1\n#define MT8365_TS3 2\n\nstruct mtk_thermal;\n\nstruct thermal_bank_cfg {\n\tunsigned int num_sensors;\n\tconst int *sensors;\n};\n\nstruct mtk_thermal_bank {\n\tstruct mtk_thermal *mt;\n\tint id;\n};\n\nstruct mtk_thermal_data {\n\ts32 num_banks;\n\ts32 num_sensors;\n\ts32 auxadc_channel;\n\tconst int *vts_index;\n\tconst int *sensor_mux_values;\n\tconst int *msr;\n\tconst int *adcpnp;\n\tconst int cali_val;\n\tconst int num_controller;\n\tconst int *controller_offset;\n\tbool need_switch_bank;\n\tstruct thermal_bank_cfg bank_data[MAX_NUM_ZONES];\n\tenum mtk_thermal_version version;\n\tu32 apmixed_buffer_ctl_reg;\n\tu32 apmixed_buffer_ctl_mask;\n\tu32 apmixed_buffer_ctl_set;\n};\n\nstruct mtk_thermal {\n\tstruct device *dev;\n\tvoid __iomem *thermal_base;\n\n\tstruct clk *clk_peri_therm;\n\tstruct clk *clk_auxadc;\n\t \n\tstruct mutex lock;\n\n\t \n\ts32 adc_ge;\n\ts32 adc_oe;\n\ts32 degc_cali;\n\ts32 o_slope;\n\ts32 o_slope_sign;\n\ts32 vts[MAX_NUM_VTS];\n\n\tconst struct mtk_thermal_data *conf;\n\tstruct mtk_thermal_bank banks[MAX_NUM_ZONES];\n\n\tint (*raw_to_mcelsius)(struct mtk_thermal *mt, int sensno, s32 raw);\n};\n\n \nstatic const int mt8183_bank_data[MT8183_NUM_SENSORS] = {\n\tMT8183_TS1, MT8183_TS2, MT8183_TS3, MT8183_TS4, MT8183_TS5, MT8183_TSABB\n};\n\nstatic const int mt8183_msr[MT8183_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_MSR0_1, TEMP_MSR1_1, TEMP_MSR2_1, TEMP_MSR1, TEMP_MSR0, TEMP_MSR3_1\n};\n\nstatic const int mt8183_adcpnp[MT8183_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_ADCPNP0_1, TEMP_ADCPNP1_1, TEMP_ADCPNP2_1,\n\tTEMP_ADCPNP1, TEMP_ADCPNP0, TEMP_ADCPNP3_1\n};\n\nstatic const int mt8183_mux_values[MT8183_NUM_SENSORS] = { 0, 1, 2, 3, 4, 0 };\nstatic const int mt8183_tc_offset[MT8183_NUM_CONTROLLER] = {0x0, 0x100};\n\nstatic const int mt8183_vts_index[MT8183_NUM_SENSORS] = {\n\tVTS1, VTS2, VTS3, VTS4, VTS5, VTSABB\n};\n\n \nstatic const int mt8173_bank_data[MT8173_NUM_ZONES][3] = {\n\t{ MT8173_TS2, MT8173_TS3 },\n\t{ MT8173_TS2, MT8173_TS4 },\n\t{ MT8173_TS1, MT8173_TS2, MT8173_TSABB },\n\t{ MT8173_TS2 },\n};\n\nstatic const int mt8173_msr[MT8173_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_MSR0, TEMP_MSR1, TEMP_MSR2, TEMP_MSR3\n};\n\nstatic const int mt8173_adcpnp[MT8173_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_ADCPNP0, TEMP_ADCPNP1, TEMP_ADCPNP2, TEMP_ADCPNP3\n};\n\nstatic const int mt8173_mux_values[MT8173_NUM_SENSORS] = { 0, 1, 2, 3, 16 };\nstatic const int mt8173_tc_offset[MT8173_NUM_CONTROLLER] = { 0x0, };\n\nstatic const int mt8173_vts_index[MT8173_NUM_SENSORS] = {\n\tVTS1, VTS2, VTS3, VTS4, VTSABB\n};\n\n \nstatic const int mt2701_bank_data[MT2701_NUM_SENSORS] = {\n\tMT2701_TS1, MT2701_TS2, MT2701_TSABB\n};\n\nstatic const int mt2701_msr[MT2701_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_MSR0, TEMP_MSR1, TEMP_MSR2\n};\n\nstatic const int mt2701_adcpnp[MT2701_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_ADCPNP0, TEMP_ADCPNP1, TEMP_ADCPNP2\n};\n\nstatic const int mt2701_mux_values[MT2701_NUM_SENSORS] = { 0, 1, 16 };\nstatic const int mt2701_tc_offset[MT2701_NUM_CONTROLLER] = { 0x0, };\n\nstatic const int mt2701_vts_index[MT2701_NUM_SENSORS] = {\n\tVTS1, VTS2, VTS3\n};\n\n \nstatic const int mt2712_bank_data[MT2712_NUM_SENSORS] = {\n\tMT2712_TS1, MT2712_TS2, MT2712_TS3, MT2712_TS4\n};\n\nstatic const int mt2712_msr[MT2712_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_MSR0, TEMP_MSR1, TEMP_MSR2, TEMP_MSR3\n};\n\nstatic const int mt2712_adcpnp[MT2712_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_ADCPNP0, TEMP_ADCPNP1, TEMP_ADCPNP2, TEMP_ADCPNP3\n};\n\nstatic const int mt2712_mux_values[MT2712_NUM_SENSORS] = { 0, 1, 2, 3 };\nstatic const int mt2712_tc_offset[MT2712_NUM_CONTROLLER] = { 0x0, };\n\nstatic const int mt2712_vts_index[MT2712_NUM_SENSORS] = {\n\tVTS1, VTS2, VTS3, VTS4\n};\n\n \nstatic const int mt7622_bank_data[MT7622_NUM_SENSORS] = { MT7622_TS1, };\nstatic const int mt7622_msr[MT7622_NUM_SENSORS_PER_ZONE] = { TEMP_MSR0, };\nstatic const int mt7622_adcpnp[MT7622_NUM_SENSORS_PER_ZONE] = { TEMP_ADCPNP0, };\nstatic const int mt7622_mux_values[MT7622_NUM_SENSORS] = { 0, };\nstatic const int mt7622_vts_index[MT7622_NUM_SENSORS] = { VTS1 };\nstatic const int mt7622_tc_offset[MT7622_NUM_CONTROLLER] = { 0x0, };\n\n \nstatic const int mt7986_bank_data[MT7986_NUM_SENSORS] = { MT7986_TS1, };\nstatic const int mt7986_msr[MT7986_NUM_SENSORS_PER_ZONE] = { TEMP_MSR0, };\nstatic const int mt7986_adcpnp[MT7986_NUM_SENSORS_PER_ZONE] = { TEMP_ADCPNP0, };\nstatic const int mt7986_mux_values[MT7986_NUM_SENSORS] = { 0, };\nstatic const int mt7986_vts_index[MT7986_NUM_SENSORS] = { VTS1 };\nstatic const int mt7986_tc_offset[MT7986_NUM_CONTROLLER] = { 0x0, };\n\n \nstatic const int mt8365_bank_data[MT8365_NUM_SENSORS] = {\n\tMT8365_TS1, MT8365_TS2, MT8365_TS3\n};\n\nstatic const int mt8365_msr[MT8365_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_MSR0, TEMP_MSR1, TEMP_MSR2\n};\n\nstatic const int mt8365_adcpnp[MT8365_NUM_SENSORS_PER_ZONE] = {\n\tTEMP_ADCPNP0, TEMP_ADCPNP1, TEMP_ADCPNP2\n};\n\nstatic const int mt8365_mux_values[MT8365_NUM_SENSORS] = { 0, 1, 2 };\nstatic const int mt8365_tc_offset[MT8365_NUM_CONTROLLER] = { 0 };\n\nstatic const int mt8365_vts_index[MT8365_NUM_SENSORS] = { VTS1, VTS2, VTS3 };\n\n \nstatic const struct mtk_thermal_data mt8173_thermal_data = {\n\t.auxadc_channel = MT8173_TEMP_AUXADC_CHANNEL,\n\t.num_banks = MT8173_NUM_ZONES,\n\t.num_sensors = MT8173_NUM_SENSORS,\n\t.vts_index = mt8173_vts_index,\n\t.cali_val = MT8173_CALIBRATION,\n\t.num_controller = MT8173_NUM_CONTROLLER,\n\t.controller_offset = mt8173_tc_offset,\n\t.need_switch_bank = true,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = 2,\n\t\t\t.sensors = mt8173_bank_data[0],\n\t\t}, {\n\t\t\t.num_sensors = 2,\n\t\t\t.sensors = mt8173_bank_data[1],\n\t\t}, {\n\t\t\t.num_sensors = 3,\n\t\t\t.sensors = mt8173_bank_data[2],\n\t\t}, {\n\t\t\t.num_sensors = 1,\n\t\t\t.sensors = mt8173_bank_data[3],\n\t\t},\n\t},\n\t.msr = mt8173_msr,\n\t.adcpnp = mt8173_adcpnp,\n\t.sensor_mux_values = mt8173_mux_values,\n\t.version = MTK_THERMAL_V1,\n};\n\n \nstatic const struct mtk_thermal_data mt2701_thermal_data = {\n\t.auxadc_channel = MT2701_TEMP_AUXADC_CHANNEL,\n\t.num_banks = 1,\n\t.num_sensors = MT2701_NUM_SENSORS,\n\t.vts_index = mt2701_vts_index,\n\t.cali_val = MT2701_CALIBRATION,\n\t.num_controller = MT2701_NUM_CONTROLLER,\n\t.controller_offset = mt2701_tc_offset,\n\t.need_switch_bank = true,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = 3,\n\t\t\t.sensors = mt2701_bank_data,\n\t\t},\n\t},\n\t.msr = mt2701_msr,\n\t.adcpnp = mt2701_adcpnp,\n\t.sensor_mux_values = mt2701_mux_values,\n\t.version = MTK_THERMAL_V1,\n};\n\n \nstatic const struct mtk_thermal_data mt8365_thermal_data = {\n\t.auxadc_channel = MT8365_TEMP_AUXADC_CHANNEL,\n\t.num_banks = MT8365_NUM_BANKS,\n\t.num_sensors = MT8365_NUM_SENSORS,\n\t.vts_index = mt8365_vts_index,\n\t.cali_val = MT8365_CALIBRATION,\n\t.num_controller = MT8365_NUM_CONTROLLER,\n\t.controller_offset = mt8365_tc_offset,\n\t.need_switch_bank = false,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = MT8365_NUM_SENSORS,\n\t\t\t.sensors = mt8365_bank_data\n\t\t},\n\t},\n\t.msr = mt8365_msr,\n\t.adcpnp = mt8365_adcpnp,\n\t.sensor_mux_values = mt8365_mux_values,\n\t.version = MTK_THERMAL_V1,\n\t.apmixed_buffer_ctl_reg = APMIXED_SYS_TS_CON0,\n\t.apmixed_buffer_ctl_mask = (u32) ~GENMASK(29, 28),\n\t.apmixed_buffer_ctl_set = 0,\n};\n\n \nstatic const struct mtk_thermal_data mt2712_thermal_data = {\n\t.auxadc_channel = MT2712_TEMP_AUXADC_CHANNEL,\n\t.num_banks = 1,\n\t.num_sensors = MT2712_NUM_SENSORS,\n\t.vts_index = mt2712_vts_index,\n\t.cali_val = MT2712_CALIBRATION,\n\t.num_controller = MT2712_NUM_CONTROLLER,\n\t.controller_offset = mt2712_tc_offset,\n\t.need_switch_bank = true,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = 4,\n\t\t\t.sensors = mt2712_bank_data,\n\t\t},\n\t},\n\t.msr = mt2712_msr,\n\t.adcpnp = mt2712_adcpnp,\n\t.sensor_mux_values = mt2712_mux_values,\n\t.version = MTK_THERMAL_V1,\n};\n\n \nstatic const struct mtk_thermal_data mt7622_thermal_data = {\n\t.auxadc_channel = MT7622_TEMP_AUXADC_CHANNEL,\n\t.num_banks = MT7622_NUM_ZONES,\n\t.num_sensors = MT7622_NUM_SENSORS,\n\t.vts_index = mt7622_vts_index,\n\t.cali_val = MT7622_CALIBRATION,\n\t.num_controller = MT7622_NUM_CONTROLLER,\n\t.controller_offset = mt7622_tc_offset,\n\t.need_switch_bank = true,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = 1,\n\t\t\t.sensors = mt7622_bank_data,\n\t\t},\n\t},\n\t.msr = mt7622_msr,\n\t.adcpnp = mt7622_adcpnp,\n\t.sensor_mux_values = mt7622_mux_values,\n\t.version = MTK_THERMAL_V2,\n\t.apmixed_buffer_ctl_reg = APMIXED_SYS_TS_CON1,\n\t.apmixed_buffer_ctl_mask = GENMASK(31, 6) | BIT(3),\n\t.apmixed_buffer_ctl_set = BIT(0),\n};\n\n \nstatic const struct mtk_thermal_data mt8183_thermal_data = {\n\t.auxadc_channel = MT8183_TEMP_AUXADC_CHANNEL,\n\t.num_banks = MT8183_NUM_ZONES,\n\t.num_sensors = MT8183_NUM_SENSORS,\n\t.vts_index = mt8183_vts_index,\n\t.cali_val = MT8183_CALIBRATION,\n\t.num_controller = MT8183_NUM_CONTROLLER,\n\t.controller_offset = mt8183_tc_offset,\n\t.need_switch_bank = false,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = 6,\n\t\t\t.sensors = mt8183_bank_data,\n\t\t},\n\t},\n\n\t.msr = mt8183_msr,\n\t.adcpnp = mt8183_adcpnp,\n\t.sensor_mux_values = mt8183_mux_values,\n\t.version = MTK_THERMAL_V1,\n};\n\n \nstatic const struct mtk_thermal_data mt7986_thermal_data = {\n\t.auxadc_channel = MT7986_TEMP_AUXADC_CHANNEL,\n\t.num_banks = MT7986_NUM_ZONES,\n\t.num_sensors = MT7986_NUM_SENSORS,\n\t.vts_index = mt7986_vts_index,\n\t.cali_val = MT7986_CALIBRATION,\n\t.num_controller = MT7986_NUM_CONTROLLER,\n\t.controller_offset = mt7986_tc_offset,\n\t.need_switch_bank = true,\n\t.bank_data = {\n\t\t{\n\t\t\t.num_sensors = 1,\n\t\t\t.sensors = mt7986_bank_data,\n\t\t},\n\t},\n\t.msr = mt7986_msr,\n\t.adcpnp = mt7986_adcpnp,\n\t.sensor_mux_values = mt7986_mux_values,\n\t.version = MTK_THERMAL_V3,\n};\n\nstatic bool mtk_thermal_temp_is_valid(int temp)\n{\n\treturn (temp >= MT8173_TEMP_MIN) && (temp <= MT8173_TEMP_MAX);\n}\n\n \nstatic int raw_to_mcelsius_v1(struct mtk_thermal *mt, int sensno, s32 raw)\n{\n\ts32 tmp;\n\n\traw &= 0xfff;\n\n\ttmp = 203450520 << 3;\n\ttmp /= mt->conf->cali_val + mt->o_slope;\n\ttmp /= 10000 + mt->adc_ge;\n\ttmp *= raw - mt->vts[sensno] - 3350;\n\ttmp >>= 3;\n\n\treturn mt->degc_cali * 500 - tmp;\n}\n\nstatic int raw_to_mcelsius_v2(struct mtk_thermal *mt, int sensno, s32 raw)\n{\n\ts32 format_1;\n\ts32 format_2;\n\ts32 g_oe;\n\ts32 g_gain;\n\ts32 g_x_roomt;\n\ts32 tmp;\n\n\tif (raw == 0)\n\t\treturn 0;\n\n\traw &= 0xfff;\n\tg_gain = 10000 + (((mt->adc_ge - 512) * 10000) >> 12);\n\tg_oe = mt->adc_oe - 512;\n\tformat_1 = mt->vts[VTS2] + 3105 - g_oe;\n\tformat_2 = (mt->degc_cali * 10) >> 1;\n\tg_x_roomt = (((format_1 * 10000) >> 12) * 10000) / g_gain;\n\n\ttmp = (((((raw - g_oe) * 10000) >> 12) * 10000) / g_gain) - g_x_roomt;\n\ttmp = tmp * 10 * 100 / 11;\n\n\tif (mt->o_slope_sign == 0)\n\t\ttmp = tmp / (165 - mt->o_slope);\n\telse\n\t\ttmp = tmp / (165 + mt->o_slope);\n\n\treturn (format_2 - tmp) * 100;\n}\n\nstatic int raw_to_mcelsius_v3(struct mtk_thermal *mt, int sensno, s32 raw)\n{\n\ts32 tmp;\n\n\tif (raw == 0)\n\t\treturn 0;\n\n\traw &= 0xfff;\n\ttmp = 100000 * 15 / 16 * 10000;\n\ttmp /= 4096 - 512 + mt->adc_ge;\n\ttmp /= 1490;\n\ttmp *= raw - mt->vts[sensno] - 2900;\n\n\treturn mt->degc_cali * 500 - tmp;\n}\n\n \nstatic void mtk_thermal_get_bank(struct mtk_thermal_bank *bank)\n{\n\tstruct mtk_thermal *mt = bank->mt;\n\tu32 val;\n\n\tif (mt->conf->need_switch_bank) {\n\t\tmutex_lock(&mt->lock);\n\n\t\tval = readl(mt->thermal_base + PTPCORESEL);\n\t\tval &= ~0xf;\n\t\tval |= bank->id;\n\t\twritel(val, mt->thermal_base + PTPCORESEL);\n\t}\n}\n\n \nstatic void mtk_thermal_put_bank(struct mtk_thermal_bank *bank)\n{\n\tstruct mtk_thermal *mt = bank->mt;\n\n\tif (mt->conf->need_switch_bank)\n\t\tmutex_unlock(&mt->lock);\n}\n\n \nstatic int mtk_thermal_bank_temperature(struct mtk_thermal_bank *bank)\n{\n\tstruct mtk_thermal *mt = bank->mt;\n\tconst struct mtk_thermal_data *conf = mt->conf;\n\tint i, temp = INT_MIN, max = INT_MIN;\n\tu32 raw;\n\n\tfor (i = 0; i < conf->bank_data[bank->id].num_sensors; i++) {\n\t\traw = readl(mt->thermal_base + conf->msr[i]);\n\n\t\ttemp = mt->raw_to_mcelsius(\n\t\t\tmt, conf->bank_data[bank->id].sensors[i], raw);\n\n\t\t \n\t\tif (!mtk_thermal_temp_is_valid(temp))\n\t\t\ttemp = THERMAL_TEMP_INVALID;\n\n\t\tif (temp > max)\n\t\t\tmax = temp;\n\t}\n\n\treturn max;\n}\n\nstatic int mtk_read_temp(struct thermal_zone_device *tz, int *temperature)\n{\n\tstruct mtk_thermal *mt = thermal_zone_device_priv(tz);\n\tint i;\n\tint tempmax = INT_MIN;\n\n\tfor (i = 0; i < mt->conf->num_banks; i++) {\n\t\tstruct mtk_thermal_bank *bank = &mt->banks[i];\n\n\t\tmtk_thermal_get_bank(bank);\n\n\t\ttempmax = max(tempmax, mtk_thermal_bank_temperature(bank));\n\n\t\tmtk_thermal_put_bank(bank);\n\t}\n\n\t*temperature = tempmax;\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops mtk_thermal_ops = {\n\t.get_temp = mtk_read_temp,\n};\n\nstatic void mtk_thermal_init_bank(struct mtk_thermal *mt, int num,\n\t\t\t\t  u32 apmixed_phys_base, u32 auxadc_phys_base,\n\t\t\t\t  int ctrl_id)\n{\n\tstruct mtk_thermal_bank *bank = &mt->banks[num];\n\tconst struct mtk_thermal_data *conf = mt->conf;\n\tint i;\n\n\tint offset = mt->conf->controller_offset[ctrl_id];\n\tvoid __iomem *controller_base = mt->thermal_base + offset;\n\n\tbank->id = num;\n\tbank->mt = mt;\n\n\tmtk_thermal_get_bank(bank);\n\n\t \n\twritel(TEMP_MONCTL1_PERIOD_UNIT(12), controller_base + TEMP_MONCTL1);\n\n\t \n\twritel(TEMP_MONCTL2_FILTER_INTERVAL(1) |\n\t\t\tTEMP_MONCTL2_SENSOR_INTERVAL(429),\n\t\t\tcontroller_base + TEMP_MONCTL2);\n\n\t \n\twritel(TEMP_AHBPOLL_ADC_POLL_INTERVAL(768),\n\t       controller_base + TEMP_AHBPOLL);\n\n\t \n\twritel(0x0, controller_base + TEMP_MSRCTL0);\n\n\t \n\twritel(0xffffffff, controller_base + TEMP_AHBTO);\n\n\t \n\twritel(0x0, controller_base + TEMP_MONIDET0);\n\twritel(0x0, controller_base + TEMP_MONIDET1);\n\n\t \n\n\t \n\twritel(BIT(conf->auxadc_channel), controller_base + TEMP_ADCMUX);\n\n\t \n\twritel(auxadc_phys_base + AUXADC_CON1_CLR_V,\n\t       controller_base + TEMP_ADCMUXADDR);\n\n\tif (mt->conf->version == MTK_THERMAL_V1) {\n\t\t \n\t\twritel(apmixed_phys_base + APMIXED_SYS_TS_CON1,\n\t\t       controller_base + TEMP_PNPMUXADDR);\n\t}\n\n\t \n\twritel(BIT(conf->auxadc_channel), controller_base + TEMP_ADCEN);\n\n\t \n\twritel(auxadc_phys_base + AUXADC_CON1_SET_V,\n\t       controller_base + TEMP_ADCENADDR);\n\n\t \n\twritel(auxadc_phys_base + AUXADC_DATA(conf->auxadc_channel),\n\t       controller_base + TEMP_ADCVALIDADDR);\n\n\t \n\twritel(auxadc_phys_base + AUXADC_DATA(conf->auxadc_channel),\n\t       controller_base + TEMP_ADCVOLTADDR);\n\n\t \n\twritel(0x0, controller_base + TEMP_RDCTRL);\n\n\t \n\twritel(TEMP_ADCVALIDMASK_VALID_HIGH | TEMP_ADCVALIDMASK_VALID_POS(12),\n\t       controller_base + TEMP_ADCVALIDMASK);\n\n\t \n\twritel(0x0, controller_base + TEMP_ADCVOLTAGESHIFT);\n\n\t \n\twritel(TEMP_ADCWRITECTRL_ADC_MUX_WRITE,\n\t\tcontroller_base + TEMP_ADCWRITECTRL);\n\n\tfor (i = 0; i < conf->bank_data[num].num_sensors; i++)\n\t\twritel(conf->sensor_mux_values[conf->bank_data[num].sensors[i]],\n\t\t       mt->thermal_base + conf->adcpnp[i]);\n\n\twritel((1 << conf->bank_data[num].num_sensors) - 1,\n\t       controller_base + TEMP_MONCTL0);\n\n\twritel(TEMP_ADCWRITECTRL_ADC_PNP_WRITE |\n\t       TEMP_ADCWRITECTRL_ADC_MUX_WRITE,\n\t       controller_base + TEMP_ADCWRITECTRL);\n\n\tmtk_thermal_put_bank(bank);\n}\n\nstatic u64 of_get_phys_base(struct device_node *np)\n{\n\tstruct resource res;\n\n\tif (of_address_to_resource(np, 0, &res))\n\t\treturn OF_BAD_ADDR;\n\n\treturn res.start;\n}\n\nstatic int mtk_thermal_extract_efuse_v1(struct mtk_thermal *mt, u32 *buf)\n{\n\tint i;\n\n\tif (!(buf[0] & CALIB_BUF0_VALID_V1))\n\t\treturn -EINVAL;\n\n\tmt->adc_ge = CALIB_BUF1_ADC_GE_V1(buf[1]);\n\n\tfor (i = 0; i < mt->conf->num_sensors; i++) {\n\t\tswitch (mt->conf->vts_index[i]) {\n\t\tcase VTS1:\n\t\t\tmt->vts[VTS1] = CALIB_BUF0_VTS_TS1_V1(buf[0]);\n\t\t\tbreak;\n\t\tcase VTS2:\n\t\t\tmt->vts[VTS2] = CALIB_BUF0_VTS_TS2_V1(buf[0]);\n\t\t\tbreak;\n\t\tcase VTS3:\n\t\t\tmt->vts[VTS3] = CALIB_BUF1_VTS_TS3_V1(buf[1]);\n\t\t\tbreak;\n\t\tcase VTS4:\n\t\t\tmt->vts[VTS4] = CALIB_BUF2_VTS_TS4_V1(buf[2]);\n\t\t\tbreak;\n\t\tcase VTS5:\n\t\t\tmt->vts[VTS5] = CALIB_BUF2_VTS_TS5_V1(buf[2]);\n\t\t\tbreak;\n\t\tcase VTSABB:\n\t\t\tmt->vts[VTSABB] =\n\t\t\t\tCALIB_BUF2_VTS_TSABB_V1(buf[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmt->degc_cali = CALIB_BUF0_DEGC_CALI_V1(buf[0]);\n\tif (CALIB_BUF1_ID_V1(buf[1]) &\n\t    CALIB_BUF0_O_SLOPE_SIGN_V1(buf[0]))\n\t\tmt->o_slope = -CALIB_BUF0_O_SLOPE_V1(buf[0]);\n\telse\n\t\tmt->o_slope = CALIB_BUF0_O_SLOPE_V1(buf[0]);\n\n\treturn 0;\n}\n\nstatic int mtk_thermal_extract_efuse_v2(struct mtk_thermal *mt, u32 *buf)\n{\n\tif (!CALIB_BUF1_VALID_V2(buf[1]))\n\t\treturn -EINVAL;\n\n\tmt->adc_oe = CALIB_BUF0_ADC_OE_V2(buf[0]);\n\tmt->adc_ge = CALIB_BUF0_ADC_GE_V2(buf[0]);\n\tmt->degc_cali = CALIB_BUF0_DEGC_CALI_V2(buf[0]);\n\tmt->o_slope = CALIB_BUF0_O_SLOPE_V2(buf[0]);\n\tmt->vts[VTS1] = CALIB_BUF1_VTS_TS1_V2(buf[1]);\n\tmt->vts[VTS2] = CALIB_BUF1_VTS_TS2_V2(buf[1]);\n\tmt->vts[VTSABB] = CALIB_BUF1_VTS_TSABB_V2(buf[1]);\n\tmt->o_slope_sign = CALIB_BUF1_O_SLOPE_SIGN_V2(buf[1]);\n\n\treturn 0;\n}\n\nstatic int mtk_thermal_extract_efuse_v3(struct mtk_thermal *mt, u32 *buf)\n{\n\tif (!CALIB_BUF1_VALID_V3(buf[1]))\n\t\treturn -EINVAL;\n\n\tmt->adc_ge = CALIB_BUF0_ADC_GE_V3(buf[0]);\n\tmt->degc_cali = CALIB_BUF0_DEGC_CALI_V3(buf[0]);\n\tmt->o_slope = CALIB_BUF0_O_SLOPE_V3(buf[0]);\n\tmt->vts[VTS1] = CALIB_BUF1_VTS_TS1_V3(buf[1]);\n\tmt->vts[VTS2] = CALIB_BUF1_VTS_TS2_V3(buf[1]);\n\tmt->vts[VTSABB] = CALIB_BUF1_VTS_TSABB_V3(buf[1]);\n\tmt->o_slope_sign = CALIB_BUF1_O_SLOPE_SIGN_V3(buf[1]);\n\n\tif (CALIB_BUF1_ID_V3(buf[1]) == 0)\n\t\tmt->o_slope = 0;\n\n\treturn 0;\n}\n\nstatic int mtk_thermal_get_calibration_data(struct device *dev,\n\t\t\t\t\t    struct mtk_thermal *mt)\n{\n\tstruct nvmem_cell *cell;\n\tu32 *buf;\n\tsize_t len;\n\tint i, ret = 0;\n\n\t \n\tmt->adc_ge = 512;\n\tmt->adc_oe = 512;\n\tfor (i = 0; i < mt->conf->num_sensors; i++)\n\t\tmt->vts[i] = 260;\n\tmt->degc_cali = 40;\n\tmt->o_slope = 0;\n\n\tcell = nvmem_cell_get(dev, \"calibration-data\");\n\tif (IS_ERR(cell)) {\n\t\tif (PTR_ERR(cell) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(cell);\n\t\treturn 0;\n\t}\n\n\tbuf = (u32 *)nvmem_cell_read(cell, &len);\n\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (len < 3 * sizeof(u32)) {\n\t\tdev_warn(dev, \"invalid calibration data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (mt->conf->version) {\n\tcase MTK_THERMAL_V1:\n\t\tret = mtk_thermal_extract_efuse_v1(mt, buf);\n\t\tbreak;\n\tcase MTK_THERMAL_V2:\n\t\tret = mtk_thermal_extract_efuse_v2(mt, buf);\n\t\tbreak;\n\tcase MTK_THERMAL_V3:\n\t\tret = mtk_thermal_extract_efuse_v3(mt, buf);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdev_info(dev, \"Device not calibrated, using default calibration values\\n\");\n\t\tret = 0;\n\t}\n\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id mtk_thermal_of_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8173-thermal\",\n\t\t.data = (void *)&mt8173_thermal_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt2701-thermal\",\n\t\t.data = (void *)&mt2701_thermal_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt2712-thermal\",\n\t\t.data = (void *)&mt2712_thermal_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt7622-thermal\",\n\t\t.data = (void *)&mt7622_thermal_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt7986-thermal\",\n\t\t.data = (void *)&mt7986_thermal_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8183-thermal\",\n\t\t.data = (void *)&mt8183_thermal_data,\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt8365-thermal\",\n\t\t.data = (void *)&mt8365_thermal_data,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, mtk_thermal_of_match);\n\nstatic void mtk_thermal_turn_on_buffer(struct mtk_thermal *mt,\n\t\t\t\t       void __iomem *apmixed_base)\n{\n\tu32 tmp;\n\n\tif (!mt->conf->apmixed_buffer_ctl_reg)\n\t\treturn;\n\n\ttmp = readl(apmixed_base + mt->conf->apmixed_buffer_ctl_reg);\n\ttmp &= mt->conf->apmixed_buffer_ctl_mask;\n\ttmp |= mt->conf->apmixed_buffer_ctl_set;\n\twritel(tmp, apmixed_base + mt->conf->apmixed_buffer_ctl_reg);\n\tudelay(200);\n}\n\nstatic void mtk_thermal_release_periodic_ts(struct mtk_thermal *mt,\n\t\t\t\t\t    void __iomem *auxadc_base)\n{\n\tint tmp;\n\n\twritel(0x800, auxadc_base + AUXADC_CON1_SET_V);\n\twritel(0x1, mt->thermal_base + TEMP_MONCTL0);\n\ttmp = readl(mt->thermal_base + TEMP_MSRCTL1);\n\twritel((tmp & (~0x10e)), mt->thermal_base + TEMP_MSRCTL1);\n}\n\nstatic int mtk_thermal_probe(struct platform_device *pdev)\n{\n\tint ret, i, ctrl_id;\n\tstruct device_node *auxadc, *apmixedsys, *np = pdev->dev.of_node;\n\tstruct mtk_thermal *mt;\n\tu64 auxadc_phys_base, apmixed_phys_base;\n\tstruct thermal_zone_device *tzdev;\n\tvoid __iomem *apmixed_base, *auxadc_base;\n\n\tmt = devm_kzalloc(&pdev->dev, sizeof(*mt), GFP_KERNEL);\n\tif (!mt)\n\t\treturn -ENOMEM;\n\n\tmt->conf = of_device_get_match_data(&pdev->dev);\n\n\tmt->thermal_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(mt->thermal_base))\n\t\treturn PTR_ERR(mt->thermal_base);\n\n\tret = mtk_thermal_get_calibration_data(&pdev->dev, mt);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&mt->lock);\n\n\tmt->dev = &pdev->dev;\n\n\tauxadc = of_parse_phandle(np, \"mediatek,auxadc\", 0);\n\tif (!auxadc) {\n\t\tdev_err(&pdev->dev, \"missing auxadc node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tauxadc_base = of_iomap(auxadc, 0);\n\tauxadc_phys_base = of_get_phys_base(auxadc);\n\n\tof_node_put(auxadc);\n\n\tif (auxadc_phys_base == OF_BAD_ADDR) {\n\t\tdev_err(&pdev->dev, \"Can't get auxadc phys address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tapmixedsys = of_parse_phandle(np, \"mediatek,apmixedsys\", 0);\n\tif (!apmixedsys) {\n\t\tdev_err(&pdev->dev, \"missing apmixedsys node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tapmixed_base = of_iomap(apmixedsys, 0);\n\tapmixed_phys_base = of_get_phys_base(apmixedsys);\n\n\tof_node_put(apmixedsys);\n\n\tif (apmixed_phys_base == OF_BAD_ADDR) {\n\t\tdev_err(&pdev->dev, \"Can't get auxadc phys address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_reset_optional(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt->clk_auxadc = devm_clk_get_enabled(&pdev->dev, \"auxadc\");\n\tif (IS_ERR(mt->clk_auxadc)) {\n\t\tret = PTR_ERR(mt->clk_auxadc);\n\t\tdev_err(&pdev->dev, \"Can't enable auxadc clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmt->clk_peri_therm = devm_clk_get_enabled(&pdev->dev, \"therm\");\n\tif (IS_ERR(mt->clk_peri_therm)) {\n\t\tret = PTR_ERR(mt->clk_peri_therm);\n\t\tdev_err(&pdev->dev, \"Can't enable peri clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmtk_thermal_turn_on_buffer(mt, apmixed_base);\n\n\tif (mt->conf->version != MTK_THERMAL_V1)\n\t\tmtk_thermal_release_periodic_ts(mt, auxadc_base);\n\n\tif (mt->conf->version == MTK_THERMAL_V1)\n\t\tmt->raw_to_mcelsius = raw_to_mcelsius_v1;\n\telse if (mt->conf->version == MTK_THERMAL_V2)\n\t\tmt->raw_to_mcelsius = raw_to_mcelsius_v2;\n\telse\n\t\tmt->raw_to_mcelsius = raw_to_mcelsius_v3;\n\n\tfor (ctrl_id = 0; ctrl_id < mt->conf->num_controller ; ctrl_id++)\n\t\tfor (i = 0; i < mt->conf->num_banks; i++)\n\t\t\tmtk_thermal_init_bank(mt, i, apmixed_phys_base,\n\t\t\t\t\t      auxadc_phys_base, ctrl_id);\n\n\ttzdev = devm_thermal_of_zone_register(&pdev->dev, 0, mt,\n\t\t\t\t\t      &mtk_thermal_ops);\n\tif (IS_ERR(tzdev))\n\t\treturn PTR_ERR(tzdev);\n\n\tret = devm_thermal_add_hwmon_sysfs(&pdev->dev, tzdev);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"error in thermal_add_hwmon_sysfs\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver mtk_thermal_driver = {\n\t.probe = mtk_thermal_probe,\n\t.driver = {\n\t\t.name = \"mtk-thermal\",\n\t\t.of_match_table = mtk_thermal_of_match,\n\t},\n};\n\nmodule_platform_driver(mtk_thermal_driver);\n\nMODULE_AUTHOR(\"Michael Kao <michael.kao@mediatek.com>\");\nMODULE_AUTHOR(\"Louis Yu <louis.yu@mediatek.com>\");\nMODULE_AUTHOR(\"Dawei Chien <dawei.chien@mediatek.com>\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_AUTHOR(\"Hanyi Wu <hanyi.wu@mediatek.com>\");\nMODULE_DESCRIPTION(\"Mediatek thermal driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}