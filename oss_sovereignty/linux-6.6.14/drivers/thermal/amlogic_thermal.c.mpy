{
  "module_name": "amlogic_thermal.c",
  "hash_id": "c1bdad381d4a2cba4fd015c978c6d26d512542cbfb4ff236f77ef37fc7f6380c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/thermal/amlogic_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n\n#include \"thermal_hwmon.h\"\n\n#define TSENSOR_CFG_REG1\t\t\t0x4\n\t#define TSENSOR_CFG_REG1_RSET_VBG\tBIT(12)\n\t#define TSENSOR_CFG_REG1_RSET_ADC\tBIT(11)\n\t#define TSENSOR_CFG_REG1_VCM_EN\t\tBIT(10)\n\t#define TSENSOR_CFG_REG1_VBG_EN\t\tBIT(9)\n\t#define TSENSOR_CFG_REG1_OUT_CTL\tBIT(6)\n\t#define TSENSOR_CFG_REG1_FILTER_EN\tBIT(5)\n\t#define TSENSOR_CFG_REG1_DEM_EN\t\tBIT(3)\n\t#define TSENSOR_CFG_REG1_CH_SEL\t\tGENMASK(1, 0)\n\t#define TSENSOR_CFG_REG1_ENABLE\t\t\\\n\t\t(TSENSOR_CFG_REG1_FILTER_EN |\t\\\n\t\t TSENSOR_CFG_REG1_VCM_EN |\t\\\n\t\t TSENSOR_CFG_REG1_VBG_EN |\t\\\n\t\t TSENSOR_CFG_REG1_DEM_EN |\t\\\n\t\t TSENSOR_CFG_REG1_CH_SEL)\n\n#define TSENSOR_STAT0\t\t\t0x40\n\n#define TSENSOR_STAT9\t\t\t0x64\n\n#define TSENSOR_READ_TEMP_MASK\t\tGENMASK(15, 0)\n#define TSENSOR_TEMP_MASK\t\tGENMASK(11, 0)\n\n#define TSENSOR_TRIM_SIGN_MASK\t\tBIT(15)\n#define TSENSOR_TRIM_TEMP_MASK\t\tGENMASK(14, 0)\n#define TSENSOR_TRIM_VERSION_MASK\tGENMASK(31, 24)\n\n#define TSENSOR_TRIM_VERSION(_version)\t\\\n\tFIELD_GET(TSENSOR_TRIM_VERSION_MASK, _version)\n\n#define TSENSOR_TRIM_CALIB_VALID_MASK\t(GENMASK(3, 2) | BIT(7))\n\n#define TSENSOR_CALIB_OFFSET\t1\n#define TSENSOR_CALIB_SHIFT\t4\n\n \nstruct amlogic_thermal_soc_calib_data {\n\tint A;\n\tint B;\n\tint m;\n\tint n;\n};\n\n \nstruct amlogic_thermal_data {\n\tint u_efuse_off;\n\tconst struct amlogic_thermal_soc_calib_data *calibration_parameters;\n\tconst struct regmap_config *regmap_config;\n};\n\nstruct amlogic_thermal {\n\tstruct platform_device *pdev;\n\tconst struct amlogic_thermal_data *data;\n\tstruct regmap *regmap;\n\tstruct regmap *sec_ao_map;\n\tstruct clk *clk;\n\tstruct thermal_zone_device *tzd;\n\tu32 trim_info;\n};\n\n \nstatic int amlogic_thermal_code_to_millicelsius(struct amlogic_thermal *pdata,\n\t\t\t\t\t\tint temp_code)\n{\n\tconst struct amlogic_thermal_soc_calib_data *param =\n\t\t\t\t\tpdata->data->calibration_parameters;\n\tint temp;\n\ts64 factor, Uptat, uefuse;\n\n\tuefuse = pdata->trim_info & TSENSOR_TRIM_SIGN_MASK ?\n\t\t\t     ~(pdata->trim_info & TSENSOR_TRIM_TEMP_MASK) + 1 :\n\t\t\t     (pdata->trim_info & TSENSOR_TRIM_TEMP_MASK);\n\n\tfactor = param->n * temp_code;\n\tfactor = div_s64(factor, 100);\n\n\tUptat = temp_code * param->m;\n\tUptat = div_s64(Uptat, 100);\n\tUptat = Uptat * BIT(16);\n\tUptat = div_s64(Uptat, BIT(16) + factor);\n\n\ttemp = (Uptat + uefuse) * param->A;\n\ttemp = div_s64(temp, BIT(16));\n\ttemp = (temp - param->B) * 100;\n\n\treturn temp;\n}\n\nstatic int amlogic_thermal_initialize(struct amlogic_thermal *pdata)\n{\n\tint ret = 0;\n\tint ver;\n\n\tregmap_read(pdata->sec_ao_map, pdata->data->u_efuse_off,\n\t\t    &pdata->trim_info);\n\n\tver = TSENSOR_TRIM_VERSION(pdata->trim_info);\n\n\tif ((ver & TSENSOR_TRIM_CALIB_VALID_MASK) == 0) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdata->pdev->dev,\n\t\t\t\"tsensor thermal calibration not supported: 0x%x!\\n\",\n\t\t\tver);\n\t}\n\n\treturn ret;\n}\n\nstatic int amlogic_thermal_enable(struct amlogic_thermal *data)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(data->regmap, TSENSOR_CFG_REG1,\n\t\t\t   TSENSOR_CFG_REG1_ENABLE, TSENSOR_CFG_REG1_ENABLE);\n\n\treturn 0;\n}\n\nstatic int amlogic_thermal_disable(struct amlogic_thermal *data)\n{\n\tregmap_update_bits(data->regmap, TSENSOR_CFG_REG1,\n\t\t\t   TSENSOR_CFG_REG1_ENABLE, 0);\n\tclk_disable_unprepare(data->clk);\n\n\treturn 0;\n}\n\nstatic int amlogic_thermal_get_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tunsigned int tval;\n\tstruct amlogic_thermal *pdata = thermal_zone_device_priv(tz);\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tregmap_read(pdata->regmap, TSENSOR_STAT0, &tval);\n\t*temp =\n\t   amlogic_thermal_code_to_millicelsius(pdata,\n\t\t\t\t\t\ttval & TSENSOR_READ_TEMP_MASK);\n\n\treturn 0;\n}\n\nstatic const struct thermal_zone_device_ops amlogic_thermal_ops = {\n\t.get_temp\t= amlogic_thermal_get_temp,\n};\n\nstatic const struct regmap_config amlogic_thermal_regmap_config_g12a = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = TSENSOR_STAT9,\n};\n\nstatic const struct amlogic_thermal_soc_calib_data amlogic_thermal_g12a = {\n\t.A = 9411,\n\t.B = 3159,\n\t.m = 424,\n\t.n = 324,\n};\n\nstatic const struct amlogic_thermal_data amlogic_thermal_g12a_cpu_param = {\n\t.u_efuse_off = 0x128,\n\t.calibration_parameters = &amlogic_thermal_g12a,\n\t.regmap_config = &amlogic_thermal_regmap_config_g12a,\n};\n\nstatic const struct amlogic_thermal_data amlogic_thermal_g12a_ddr_param = {\n\t.u_efuse_off = 0xf0,\n\t.calibration_parameters = &amlogic_thermal_g12a,\n\t.regmap_config = &amlogic_thermal_regmap_config_g12a,\n};\n\nstatic const struct of_device_id of_amlogic_thermal_match[] = {\n\t{\n\t\t.compatible = \"amlogic,g12a-ddr-thermal\",\n\t\t.data = &amlogic_thermal_g12a_ddr_param,\n\t},\n\t{\n\t\t.compatible = \"amlogic,g12a-cpu-thermal\",\n\t\t.data = &amlogic_thermal_g12a_cpu_param,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_amlogic_thermal_match);\n\nstatic int amlogic_thermal_probe(struct platform_device *pdev)\n{\n\tstruct amlogic_thermal *pdata;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->data = of_device_get_match_data(dev);\n\tpdata->pdev = pdev;\n\tplatform_set_drvdata(pdev, pdata);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpdata->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t      pdata->data->regmap_config);\n\tif (IS_ERR(pdata->regmap))\n\t\treturn PTR_ERR(pdata->regmap);\n\n\tpdata->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pdata->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pdata->clk), \"failed to get clock\\n\");\n\n\tpdata->sec_ao_map = syscon_regmap_lookup_by_phandle\n\t\t(pdev->dev.of_node, \"amlogic,ao-secure\");\n\tif (IS_ERR(pdata->sec_ao_map)) {\n\t\tdev_err(dev, \"syscon regmap lookup failed.\\n\");\n\t\treturn PTR_ERR(pdata->sec_ao_map);\n\t}\n\n\tpdata->tzd = devm_thermal_of_zone_register(&pdev->dev,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   pdata,\n\t\t\t\t\t\t   &amlogic_thermal_ops);\n\tif (IS_ERR(pdata->tzd)) {\n\t\tret = PTR_ERR(pdata->tzd);\n\t\tdev_err(dev, \"Failed to register tsensor: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevm_thermal_add_hwmon_sysfs(&pdev->dev, pdata->tzd);\n\n\tret = amlogic_thermal_initialize(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amlogic_thermal_enable(pdata);\n\n\treturn ret;\n}\n\nstatic int amlogic_thermal_remove(struct platform_device *pdev)\n{\n\tstruct amlogic_thermal *data = platform_get_drvdata(pdev);\n\n\treturn amlogic_thermal_disable(data);\n}\n\nstatic int __maybe_unused amlogic_thermal_suspend(struct device *dev)\n{\n\tstruct amlogic_thermal *data = dev_get_drvdata(dev);\n\n\treturn amlogic_thermal_disable(data);\n}\n\nstatic int __maybe_unused amlogic_thermal_resume(struct device *dev)\n{\n\tstruct amlogic_thermal *data = dev_get_drvdata(dev);\n\n\treturn amlogic_thermal_enable(data);\n}\n\nstatic SIMPLE_DEV_PM_OPS(amlogic_thermal_pm_ops,\n\t\t\t amlogic_thermal_suspend, amlogic_thermal_resume);\n\nstatic struct platform_driver amlogic_thermal_driver = {\n\t.driver = {\n\t\t.name\t\t= \"amlogic_thermal\",\n\t\t.pm\t\t= &amlogic_thermal_pm_ops,\n\t\t.of_match_table = of_amlogic_thermal_match,\n\t},\n\t.probe\t= amlogic_thermal_probe,\n\t.remove\t= amlogic_thermal_remove,\n};\n\nmodule_platform_driver(amlogic_thermal_driver);\n\nMODULE_AUTHOR(\"Guillaume La Roque <glaroque@baylibre.com>\");\nMODULE_DESCRIPTION(\"Amlogic thermal driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}