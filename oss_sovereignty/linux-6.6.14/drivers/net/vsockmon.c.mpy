{
  "module_name": "vsockmon.c",
  "hash_id": "54fc41cb6d069f4b62ae63be26141ce77c519314748c1be0ec1e6195812507f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vsockmon.c",
  "human_readable_source": "\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <net/rtnetlink.h>\n#include <net/sock.h>\n#include <net/af_vsock.h>\n#include <uapi/linux/vsockmon.h>\n#include <linux/virtio_vsock.h>\n\n \n#define DEFAULT_MTU (VIRTIO_VSOCK_MAX_PKT_BUF_SIZE + \\\n\t\t     sizeof(struct af_vsockmon_hdr))\n\nstatic int vsockmon_dev_init(struct net_device *dev)\n{\n\tdev->lstats = netdev_alloc_pcpu_stats(struct pcpu_lstats);\n\tif (!dev->lstats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void vsockmon_dev_uninit(struct net_device *dev)\n{\n\tfree_percpu(dev->lstats);\n}\n\nstruct vsockmon {\n\tstruct vsock_tap vt;\n};\n\nstatic int vsockmon_open(struct net_device *dev)\n{\n\tstruct vsockmon *vsockmon = netdev_priv(dev);\n\n\tvsockmon->vt.dev = dev;\n\tvsockmon->vt.module = THIS_MODULE;\n\treturn vsock_add_tap(&vsockmon->vt);\n}\n\nstatic int vsockmon_close(struct net_device *dev)\n{\n\tstruct vsockmon *vsockmon = netdev_priv(dev);\n\n\treturn vsock_remove_tap(&vsockmon->vt);\n}\n\nstatic netdev_tx_t vsockmon_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tdev_lstats_add(dev, skb->len);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\nvsockmon_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tdev_lstats_read(dev, &stats->rx_packets, &stats->rx_bytes);\n\n\tstats->tx_packets = 0;\n\tstats->tx_bytes = 0;\n}\n\nstatic int vsockmon_is_valid_mtu(int new_mtu)\n{\n\treturn new_mtu >= (int)sizeof(struct af_vsockmon_hdr);\n}\n\nstatic int vsockmon_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (!vsockmon_is_valid_mtu(new_mtu))\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops vsockmon_ops = {\n\t.ndo_init = vsockmon_dev_init,\n\t.ndo_uninit = vsockmon_dev_uninit,\n\t.ndo_open = vsockmon_open,\n\t.ndo_stop = vsockmon_close,\n\t.ndo_start_xmit = vsockmon_xmit,\n\t.ndo_get_stats64 = vsockmon_get_stats64,\n\t.ndo_change_mtu = vsockmon_change_mtu,\n};\n\nstatic u32 always_on(struct net_device *dev)\n{\n\treturn 1;\n}\n\nstatic const struct ethtool_ops vsockmon_ethtool_ops = {\n\t.get_link = always_on,\n};\n\nstatic void vsockmon_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_VSOCKMON;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\tdev->netdev_ops\t= &vsockmon_ops;\n\tdev->ethtool_ops = &vsockmon_ethtool_ops;\n\tdev->needs_free_netdev = true;\n\n\tdev->features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\tNETIF_F_HIGHDMA | NETIF_F_LLTX;\n\n\tdev->flags = IFF_NOARP;\n\n\tdev->mtu = DEFAULT_MTU;\n}\n\nstatic struct rtnl_link_ops vsockmon_link_ops __read_mostly = {\n\t.kind\t\t\t= \"vsockmon\",\n\t.priv_size\t\t= sizeof(struct vsockmon),\n\t.setup\t\t\t= vsockmon_setup,\n};\n\nstatic __init int vsockmon_register(void)\n{\n\treturn rtnl_link_register(&vsockmon_link_ops);\n}\n\nstatic __exit void vsockmon_unregister(void)\n{\n\trtnl_link_unregister(&vsockmon_link_ops);\n}\n\nmodule_init(vsockmon_register);\nmodule_exit(vsockmon_unregister);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Gerard Garcia <ggarcia@deic.uab.cat>\");\nMODULE_DESCRIPTION(\"Vsock monitoring device. Based on nlmon device.\");\nMODULE_ALIAS_RTNL_LINK(\"vsockmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}