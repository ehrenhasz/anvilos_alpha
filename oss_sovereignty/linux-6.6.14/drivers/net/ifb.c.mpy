{
  "module_name": "ifb.c",
  "hash_id": "021c58b621373240647b8d2bf24f618533e944b0ac6db6927fce54b9b418bc9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ifb.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/netfilter_netdev.h>\n#include <net/pkt_sched.h>\n#include <net/net_namespace.h>\n\n#define TX_Q_LIMIT    32\n\nstruct ifb_q_stats {\n\tu64 packets;\n\tu64 bytes;\n\tstruct u64_stats_sync\tsync;\n};\n\nstruct ifb_q_private {\n\tstruct net_device\t*dev;\n\tstruct tasklet_struct   ifb_tasklet;\n\tint\t\t\ttasklet_pending;\n\tint\t\t\ttxqnum;\n\tstruct sk_buff_head     rq;\n\tstruct sk_buff_head     tq;\n\tstruct ifb_q_stats\trx_stats;\n\tstruct ifb_q_stats\ttx_stats;\n} ____cacheline_aligned_in_smp;\n\nstruct ifb_dev_private {\n\tstruct ifb_q_private *tx_private;\n};\n\n \nstruct ifb_q_stats_desc {\n\tchar\tdesc[ETH_GSTRING_LEN];\n\tsize_t\toffset;\n};\n\n#define IFB_Q_STAT(m)\toffsetof(struct ifb_q_stats, m)\n\nstatic const struct ifb_q_stats_desc ifb_q_stats_desc[] = {\n\t{ \"packets\",\tIFB_Q_STAT(packets) },\n\t{ \"bytes\",\tIFB_Q_STAT(bytes) },\n};\n\n#define IFB_Q_STATS_LEN\tARRAY_SIZE(ifb_q_stats_desc)\n\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic int ifb_open(struct net_device *dev);\nstatic int ifb_close(struct net_device *dev);\n\nstatic void ifb_update_q_stats(struct ifb_q_stats *stats, int len)\n{\n\tu64_stats_update_begin(&stats->sync);\n\tstats->packets++;\n\tstats->bytes += len;\n\tu64_stats_update_end(&stats->sync);\n}\n\nstatic void ifb_ri_tasklet(struct tasklet_struct *t)\n{\n\tstruct ifb_q_private *txp = from_tasklet(txp, t, ifb_tasklet);\n\tstruct netdev_queue *txq;\n\tstruct sk_buff *skb;\n\n\ttxq = netdev_get_tx_queue(txp->dev, txp->txqnum);\n\tskb = skb_peek(&txp->tq);\n\tif (!skb) {\n\t\tif (!__netif_tx_trylock(txq))\n\t\t\tgoto resched;\n\t\tskb_queue_splice_tail_init(&txp->rq, &txp->tq);\n\t\t__netif_tx_unlock(txq);\n\t}\n\n\twhile ((skb = __skb_dequeue(&txp->tq)) != NULL) {\n\t\t \n\t\tskb->redirected = 0;\n#ifdef CONFIG_NET_CLS_ACT\n\t\tskb->tc_skip_classify = 1;\n#endif\n\t\tnf_skip_egress(skb, true);\n\n\t\tifb_update_q_stats(&txp->tx_stats, skb->len);\n\n\t\trcu_read_lock();\n\t\tskb->dev = dev_get_by_index_rcu(dev_net(txp->dev), skb->skb_iif);\n\t\tif (!skb->dev) {\n\t\t\trcu_read_unlock();\n\t\t\tdev_kfree_skb(skb);\n\t\t\ttxp->dev->stats.tx_dropped++;\n\t\t\tif (skb_queue_len(&txp->tq) != 0)\n\t\t\t\tgoto resched;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tskb->skb_iif = txp->dev->ifindex;\n\n\t\tif (!skb->from_ingress) {\n\t\t\tdev_queue_xmit(skb);\n\t\t} else {\n\t\t\tskb_pull_rcsum(skb, skb->mac_len);\n\t\t\tnetif_receive_skb(skb);\n\t\t}\n\t}\n\n\tif (__netif_tx_trylock(txq)) {\n\t\tskb = skb_peek(&txp->rq);\n\t\tif (!skb) {\n\t\t\ttxp->tasklet_pending = 0;\n\t\t\tif (netif_tx_queue_stopped(txq))\n\t\t\t\tnetif_tx_wake_queue(txq);\n\t\t} else {\n\t\t\t__netif_tx_unlock(txq);\n\t\t\tgoto resched;\n\t\t}\n\t\t__netif_tx_unlock(txq);\n\t} else {\nresched:\n\t\ttxp->tasklet_pending = 1;\n\t\ttasklet_schedule(&txp->ifb_tasklet);\n\t}\n\n}\n\nstatic void ifb_stats64(struct net_device *dev,\n\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct ifb_dev_private *dp = netdev_priv(dev);\n\tstruct ifb_q_private *txp = dp->tx_private;\n\tunsigned int start;\n\tu64 packets, bytes;\n\tint i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++,txp++) {\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&txp->rx_stats.sync);\n\t\t\tpackets = txp->rx_stats.packets;\n\t\t\tbytes = txp->rx_stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&txp->rx_stats.sync, start));\n\t\tstats->rx_packets += packets;\n\t\tstats->rx_bytes += bytes;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&txp->tx_stats.sync);\n\t\t\tpackets = txp->tx_stats.packets;\n\t\t\tbytes = txp->tx_stats.bytes;\n\t\t} while (u64_stats_fetch_retry(&txp->tx_stats.sync, start));\n\t\tstats->tx_packets += packets;\n\t\tstats->tx_bytes += bytes;\n\t}\n\tstats->rx_dropped = dev->stats.rx_dropped;\n\tstats->tx_dropped = dev->stats.tx_dropped;\n}\n\nstatic int ifb_dev_init(struct net_device *dev)\n{\n\tstruct ifb_dev_private *dp = netdev_priv(dev);\n\tstruct ifb_q_private *txp;\n\tint i;\n\n\ttxp = kcalloc(dev->num_tx_queues, sizeof(*txp), GFP_KERNEL);\n\tif (!txp)\n\t\treturn -ENOMEM;\n\tdp->tx_private = txp;\n\tfor (i = 0; i < dev->num_tx_queues; i++,txp++) {\n\t\ttxp->txqnum = i;\n\t\ttxp->dev = dev;\n\t\t__skb_queue_head_init(&txp->rq);\n\t\t__skb_queue_head_init(&txp->tq);\n\t\tu64_stats_init(&txp->rx_stats.sync);\n\t\tu64_stats_init(&txp->tx_stats.sync);\n\t\ttasklet_setup(&txp->ifb_tasklet, ifb_ri_tasklet);\n\t\tnetif_tx_start_queue(netdev_get_tx_queue(dev, i));\n\t}\n\treturn 0;\n}\n\nstatic void ifb_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tu8 *p = buf;\n\tint i, j;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < dev->real_num_rx_queues; i++)\n\t\t\tfor (j = 0; j < IFB_Q_STATS_LEN; j++)\n\t\t\t\tethtool_sprintf(&p, \"rx_queue_%u_%.18s\",\n\t\t\t\t\t\ti, ifb_q_stats_desc[j].desc);\n\n\t\tfor (i = 0; i < dev->real_num_tx_queues; i++)\n\t\t\tfor (j = 0; j < IFB_Q_STATS_LEN; j++)\n\t\t\t\tethtool_sprintf(&p, \"tx_queue_%u_%.18s\",\n\t\t\t\t\t\ti, ifb_q_stats_desc[j].desc);\n\n\t\tbreak;\n\t}\n}\n\nstatic int ifb_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn IFB_Q_STATS_LEN * (dev->real_num_rx_queues +\n\t\t\t\t\t  dev->real_num_tx_queues);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void ifb_fill_stats_data(u64 **data,\n\t\t\t\tstruct ifb_q_stats *q_stats)\n{\n\tvoid *stats_base = (void *)q_stats;\n\tunsigned int start;\n\tsize_t offset;\n\tint j;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&q_stats->sync);\n\t\tfor (j = 0; j < IFB_Q_STATS_LEN; j++) {\n\t\t\toffset = ifb_q_stats_desc[j].offset;\n\t\t\t(*data)[j] = *(u64 *)(stats_base + offset);\n\t\t}\n\t} while (u64_stats_fetch_retry(&q_stats->sync, start));\n\n\t*data += IFB_Q_STATS_LEN;\n}\n\nstatic void ifb_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct ifb_dev_private *dp = netdev_priv(dev);\n\tstruct ifb_q_private *txp;\n\tint i;\n\n\tfor (i = 0; i < dev->real_num_rx_queues; i++) {\n\t\ttxp = dp->tx_private + i;\n\t\tifb_fill_stats_data(&data, &txp->rx_stats);\n\t}\n\n\tfor (i = 0; i < dev->real_num_tx_queues; i++) {\n\t\ttxp = dp->tx_private + i;\n\t\tifb_fill_stats_data(&data, &txp->tx_stats);\n\t}\n}\n\nstatic const struct net_device_ops ifb_netdev_ops = {\n\t.ndo_open\t= ifb_open,\n\t.ndo_stop\t= ifb_close,\n\t.ndo_get_stats64 = ifb_stats64,\n\t.ndo_start_xmit\t= ifb_xmit,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_init\t= ifb_dev_init,\n};\n\nstatic const struct ethtool_ops ifb_ethtool_ops = {\n\t.get_strings\t\t= ifb_get_strings,\n\t.get_sset_count\t\t= ifb_get_sset_count,\n\t.get_ethtool_stats\t= ifb_get_ethtool_stats,\n};\n\n#define IFB_FEATURES (NETIF_F_HW_CSUM | NETIF_F_SG  | NETIF_F_FRAGLIST\t| \\\n\t\t      NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL\t| \\\n\t\t      NETIF_F_HIGHDMA | NETIF_F_HW_VLAN_CTAG_TX\t\t| \\\n\t\t      NETIF_F_HW_VLAN_STAG_TX)\n\nstatic void ifb_dev_free(struct net_device *dev)\n{\n\tstruct ifb_dev_private *dp = netdev_priv(dev);\n\tstruct ifb_q_private *txp = dp->tx_private;\n\tint i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++,txp++) {\n\t\ttasklet_kill(&txp->ifb_tasklet);\n\t\t__skb_queue_purge(&txp->rq);\n\t\t__skb_queue_purge(&txp->tq);\n\t}\n\tkfree(dp->tx_private);\n}\n\nstatic void ifb_setup(struct net_device *dev)\n{\n\t \n\tdev->netdev_ops = &ifb_netdev_ops;\n\tdev->ethtool_ops = &ifb_ethtool_ops;\n\n\t \n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->hw_features |= dev->features;\n\tdev->hw_enc_features |= dev->features;\n\tdev->vlan_features |= IFB_FEATURES & ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tnetif_keep_dst(dev);\n\teth_hw_addr_random(dev);\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ifb_dev_free;\n\n\tdev->min_mtu = 0;\n\tdev->max_mtu = 0;\n}\n\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ifb_dev_private *dp = netdev_priv(dev);\n\tstruct ifb_q_private *txp = dp->tx_private + skb_get_queue_mapping(skb);\n\n\tifb_update_q_stats(&txp->rx_stats, skb->len);\n\n\tif (!skb->redirected || !skb->skb_iif) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.rx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb_queue_len(&txp->rq) >= dev->tx_queue_len)\n\t\tnetif_tx_stop_queue(netdev_get_tx_queue(dev, txp->txqnum));\n\n\t__skb_queue_tail(&txp->rq, skb);\n\tif (!txp->tasklet_pending) {\n\t\ttxp->tasklet_pending = 1;\n\t\ttasklet_schedule(&txp->ifb_tasklet);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ifb_close(struct net_device *dev)\n{\n\tnetif_tx_stop_all_queues(dev);\n\treturn 0;\n}\n\nstatic int ifb_open(struct net_device *dev)\n{\n\tnetif_tx_start_all_queues(dev);\n\treturn 0;\n}\n\nstatic int ifb_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops ifb_link_ops __read_mostly = {\n\t.kind\t\t= \"ifb\",\n\t.priv_size\t= sizeof(struct ifb_dev_private),\n\t.setup\t\t= ifb_setup,\n\t.validate\t= ifb_validate,\n};\n\n \nstatic int numifbs = 2;\nmodule_param(numifbs, int, 0);\nMODULE_PARM_DESC(numifbs, \"Number of ifb devices\");\n\nstatic int __init ifb_init_one(int index)\n{\n\tstruct net_device *dev_ifb;\n\tint err;\n\n\tdev_ifb = alloc_netdev(sizeof(struct ifb_dev_private), \"ifb%d\",\n\t\t\t       NET_NAME_UNKNOWN, ifb_setup);\n\n\tif (!dev_ifb)\n\t\treturn -ENOMEM;\n\n\tdev_ifb->rtnl_link_ops = &ifb_link_ops;\n\terr = register_netdevice(dev_ifb);\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tfree_netdev(dev_ifb);\n\treturn err;\n}\n\nstatic int __init ifb_init_module(void)\n{\n\tint i, err;\n\n\tdown_write(&pernet_ops_rwsem);\n\trtnl_lock();\n\terr = __rtnl_link_register(&ifb_link_ops);\n\tif (err < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < numifbs && !err; i++) {\n\t\terr = ifb_init_one(i);\n\t\tcond_resched();\n\t}\n\tif (err)\n\t\t__rtnl_link_unregister(&ifb_link_ops);\n\nout:\n\trtnl_unlock();\n\tup_write(&pernet_ops_rwsem);\n\n\treturn err;\n}\n\nstatic void __exit ifb_cleanup_module(void)\n{\n\trtnl_link_unregister(&ifb_link_ops);\n}\n\nmodule_init(ifb_init_module);\nmodule_exit(ifb_cleanup_module);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jamal Hadi Salim\");\nMODULE_ALIAS_RTNL_LINK(\"ifb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}