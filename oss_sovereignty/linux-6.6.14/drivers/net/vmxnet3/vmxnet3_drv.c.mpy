{
  "module_name": "vmxnet3_drv.c",
  "hash_id": "70235c4788c9cba244f008d1f3fb4b2d4fe4c6117cbee4d7580cd5f72c9050b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vmxnet3/vmxnet3_drv.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <net/ip6_checksum.h>\n\n#include \"vmxnet3_int.h\"\n#include \"vmxnet3_xdp.h\"\n\nchar vmxnet3_driver_name[] = \"vmxnet3\";\n#define VMXNET3_DRIVER_DESC \"VMware vmxnet3 virtual NIC driver\"\n\n \nstatic const struct pci_device_id vmxnet3_pciid_table[] = {\n\t{PCI_VDEVICE(VMWARE, PCI_DEVICE_ID_VMWARE_VMXNET3)},\n\t{0}\n};\n\nMODULE_DEVICE_TABLE(pci, vmxnet3_pciid_table);\n\nstatic int enable_mq = 1;\n\nstatic void\nvmxnet3_write_mac_addr(struct vmxnet3_adapter *adapter, const u8 *mac);\n\n \nstatic void\nvmxnet3_enable_intr(struct vmxnet3_adapter *adapter, unsigned intr_idx)\n{\n\tVMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_IMR + intr_idx * 8, 0);\n}\n\n\nstatic void\nvmxnet3_disable_intr(struct vmxnet3_adapter *adapter, unsigned intr_idx)\n{\n\tVMXNET3_WRITE_BAR0_REG(adapter, VMXNET3_REG_IMR + intr_idx * 8, 1);\n}\n\n\n \nstatic void\nvmxnet3_enable_all_intrs(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->intr.num_intrs; i++)\n\t\tvmxnet3_enable_intr(adapter, i);\n\tif (!VMXNET3_VERSION_GE_6(adapter) ||\n\t    !adapter->queuesExtEnabled) {\n\t\tadapter->shared->devRead.intrConf.intrCtrl &=\n\t\t\t\t\tcpu_to_le32(~VMXNET3_IC_DISABLE_ALL);\n\t} else {\n\t\tadapter->shared->devReadExt.intrConfExt.intrCtrl &=\n\t\t\t\t\tcpu_to_le32(~VMXNET3_IC_DISABLE_ALL);\n\t}\n}\n\n\nstatic void\nvmxnet3_disable_all_intrs(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tif (!VMXNET3_VERSION_GE_6(adapter) ||\n\t    !adapter->queuesExtEnabled) {\n\t\tadapter->shared->devRead.intrConf.intrCtrl |=\n\t\t\t\t\tcpu_to_le32(VMXNET3_IC_DISABLE_ALL);\n\t} else {\n\t\tadapter->shared->devReadExt.intrConfExt.intrCtrl |=\n\t\t\t\t\tcpu_to_le32(VMXNET3_IC_DISABLE_ALL);\n\t}\n\tfor (i = 0; i < adapter->intr.num_intrs; i++)\n\t\tvmxnet3_disable_intr(adapter, i);\n}\n\n\nstatic void\nvmxnet3_ack_events(struct vmxnet3_adapter *adapter, u32 events)\n{\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_ECR, events);\n}\n\n\nstatic bool\nvmxnet3_tq_stopped(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\n{\n\treturn tq->stopped;\n}\n\n\nstatic void\nvmxnet3_tq_start(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\n{\n\ttq->stopped = false;\n\tnetif_start_subqueue(adapter->netdev, tq - adapter->tx_queue);\n}\n\n\nstatic void\nvmxnet3_tq_wake(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\n{\n\ttq->stopped = false;\n\tnetif_wake_subqueue(adapter->netdev, (tq - adapter->tx_queue));\n}\n\n\nstatic void\nvmxnet3_tq_stop(struct vmxnet3_tx_queue *tq, struct vmxnet3_adapter *adapter)\n{\n\ttq->stopped = true;\n\ttq->num_stop++;\n\tnetif_stop_subqueue(adapter->netdev, (tq - adapter->tx_queue));\n}\n\n \nbool\nvmxnet3_check_ptcapability(u32 cap_supported, u32 cap)\n{\n\tif (cap_supported & (1UL << VMXNET3_DCR_ERROR) ||\n\t    cap_supported & (1UL << cap)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n \nstatic void\nvmxnet3_check_link(struct vmxnet3_adapter *adapter, bool affectTxQueue)\n{\n\tu32 ret;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_LINK);\n\tret = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\tadapter->link_speed = ret >> 16;\n\tif (ret & 1) {  \n\t\tnetdev_info(adapter->netdev, \"NIC Link is Up %d Mbps\\n\",\n\t\t\t    adapter->link_speed);\n\t\tnetif_carrier_on(adapter->netdev);\n\n\t\tif (affectTxQueue) {\n\t\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\t\tvmxnet3_tq_start(&adapter->tx_queue[i],\n\t\t\t\t\t\t adapter);\n\t\t}\n\t} else {\n\t\tnetdev_info(adapter->netdev, \"NIC Link is Down\\n\");\n\t\tnetif_carrier_off(adapter->netdev);\n\n\t\tif (affectTxQueue) {\n\t\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\t\tvmxnet3_tq_stop(&adapter->tx_queue[i], adapter);\n\t\t}\n\t}\n}\n\nstatic void\nvmxnet3_process_events(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\tunsigned long flags;\n\tu32 events = le32_to_cpu(adapter->shared->ecr);\n\tif (!events)\n\t\treturn;\n\n\tvmxnet3_ack_events(adapter, events);\n\n\t \n\tif (events & VMXNET3_ECR_LINK)\n\t\tvmxnet3_check_link(adapter, true);\n\n\t \n\tif (events & (VMXNET3_ECR_TQERR | VMXNET3_ECR_RQERR)) {\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_QUEUE_STATUS);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\tif (adapter->tqd_start[i].status.stopped)\n\t\t\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t\t\"%s: tq[%d] error 0x%x\\n\",\n\t\t\t\t\tadapter->netdev->name, i, le32_to_cpu(\n\t\t\t\t\tadapter->tqd_start[i].status.error));\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tif (adapter->rqd_start[i].status.stopped)\n\t\t\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t\t\"%s: rq[%d] error 0x%x\\n\",\n\t\t\t\t\tadapter->netdev->name, i,\n\t\t\t\t\tadapter->rqd_start[i].status.error);\n\n\t\tschedule_work(&adapter->work);\n\t}\n}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n \nstatic void vmxnet3_RxDescToCPU(const struct Vmxnet3_RxDesc *srcDesc,\n\t\t\t\tstruct Vmxnet3_RxDesc *dstDesc)\n{\n\tu32 *src = (u32 *)srcDesc + 2;\n\tu32 *dst = (u32 *)dstDesc + 2;\n\tdstDesc->addr = le64_to_cpu(srcDesc->addr);\n\t*dst = le32_to_cpu(*src);\n\tdstDesc->ext1 = le32_to_cpu(srcDesc->ext1);\n}\n\nstatic void vmxnet3_TxDescToLe(const struct Vmxnet3_TxDesc *srcDesc,\n\t\t\t       struct Vmxnet3_TxDesc *dstDesc)\n{\n\tint i;\n\tu32 *src = (u32 *)(srcDesc + 1);\n\tu32 *dst = (u32 *)(dstDesc + 1);\n\n\t \n\tfor (i = 2; i > 0; i--) {\n\t\tsrc--;\n\t\tdst--;\n\t\t*dst = cpu_to_le32(*src);\n\t}\n}\n\n\nstatic void vmxnet3_RxCompToCPU(const struct Vmxnet3_RxCompDesc *srcDesc,\n\t\t\t\tstruct Vmxnet3_RxCompDesc *dstDesc)\n{\n\tint i = 0;\n\tu32 *src = (u32 *)srcDesc;\n\tu32 *dst = (u32 *)dstDesc;\n\tfor (i = 0; i < sizeof(struct Vmxnet3_RxCompDesc) / sizeof(u32); i++) {\n\t\t*dst = le32_to_cpu(*src);\n\t\tsrc++;\n\t\tdst++;\n\t}\n}\n\n\n \nstatic u32 get_bitfield32(const __le32 *bitfield, u32 pos, u32 size)\n{\n\tu32 temp = le32_to_cpu(*bitfield);\n\tu32 mask = ((1 << size) - 1) << pos;\n\ttemp &= mask;\n\ttemp >>= pos;\n\treturn temp;\n}\n\n\n\n#endif   \n\n#ifdef __BIG_ENDIAN_BITFIELD\n\n#   define VMXNET3_TXDESC_GET_GEN(txdesc) get_bitfield32(((const __le32 *) \\\n\t\t\ttxdesc) + VMXNET3_TXD_GEN_DWORD_SHIFT, \\\n\t\t\tVMXNET3_TXD_GEN_SHIFT, VMXNET3_TXD_GEN_SIZE)\n#   define VMXNET3_TXDESC_GET_EOP(txdesc) get_bitfield32(((const __le32 *) \\\n\t\t\ttxdesc) + VMXNET3_TXD_EOP_DWORD_SHIFT, \\\n\t\t\tVMXNET3_TXD_EOP_SHIFT, VMXNET3_TXD_EOP_SIZE)\n#   define VMXNET3_TCD_GET_GEN(tcd) get_bitfield32(((const __le32 *)tcd) + \\\n\t\t\tVMXNET3_TCD_GEN_DWORD_SHIFT, VMXNET3_TCD_GEN_SHIFT, \\\n\t\t\tVMXNET3_TCD_GEN_SIZE)\n#   define VMXNET3_TCD_GET_TXIDX(tcd) get_bitfield32((const __le32 *)tcd, \\\n\t\t\tVMXNET3_TCD_TXIDX_SHIFT, VMXNET3_TCD_TXIDX_SIZE)\n#   define vmxnet3_getRxComp(dstrcd, rcd, tmp) do { \\\n\t\t\t(dstrcd) = (tmp); \\\n\t\t\tvmxnet3_RxCompToCPU((rcd), (tmp)); \\\n\t\t} while (0)\n#   define vmxnet3_getRxDesc(dstrxd, rxd, tmp) do { \\\n\t\t\t(dstrxd) = (tmp); \\\n\t\t\tvmxnet3_RxDescToCPU((rxd), (tmp)); \\\n\t\t} while (0)\n\n#else\n\n#   define VMXNET3_TXDESC_GET_GEN(txdesc) ((txdesc)->gen)\n#   define VMXNET3_TXDESC_GET_EOP(txdesc) ((txdesc)->eop)\n#   define VMXNET3_TCD_GET_GEN(tcd) ((tcd)->gen)\n#   define VMXNET3_TCD_GET_TXIDX(tcd) ((tcd)->txdIdx)\n#   define vmxnet3_getRxComp(dstrcd, rcd, tmp) (dstrcd) = (rcd)\n#   define vmxnet3_getRxDesc(dstrxd, rxd, tmp) (dstrxd) = (rxd)\n\n#endif  \n\n\nstatic void\nvmxnet3_unmap_tx_buf(struct vmxnet3_tx_buf_info *tbi,\n\t\t     struct pci_dev *pdev)\n{\n\tu32 map_type = tbi->map_type;\n\n\tif (map_type & VMXNET3_MAP_SINGLE)\n\t\tdma_unmap_single(&pdev->dev, tbi->dma_addr, tbi->len,\n\t\t\t\t DMA_TO_DEVICE);\n\telse if (map_type & VMXNET3_MAP_PAGE)\n\t\tdma_unmap_page(&pdev->dev, tbi->dma_addr, tbi->len,\n\t\t\t       DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(map_type & ~VMXNET3_MAP_XDP);\n\n\ttbi->map_type = VMXNET3_MAP_NONE;  \n}\n\n\nstatic int\nvmxnet3_unmap_pkt(u32 eop_idx, struct vmxnet3_tx_queue *tq,\n\t\t  struct pci_dev *pdev,\tstruct vmxnet3_adapter *adapter,\n\t\t  struct xdp_frame_bulk *bq)\n{\n\tstruct vmxnet3_tx_buf_info *tbi;\n\tint entries = 0;\n\tu32 map_type;\n\n\t \n\tBUG_ON(tq->buf_info[eop_idx].sop_idx != tq->tx_ring.next2comp);\n\tBUG_ON(VMXNET3_TXDESC_GET_EOP(&(tq->tx_ring.base[eop_idx].txd)) != 1);\n\n\ttbi = &tq->buf_info[eop_idx];\n\tBUG_ON(!tbi->skb);\n\tmap_type = tbi->map_type;\n\tVMXNET3_INC_RING_IDX_ONLY(eop_idx, tq->tx_ring.size);\n\n\twhile (tq->tx_ring.next2comp != eop_idx) {\n\t\tvmxnet3_unmap_tx_buf(tq->buf_info + tq->tx_ring.next2comp,\n\t\t\t\t     pdev);\n\n\t\t \n\t\tvmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);\n\t\tentries++;\n\t}\n\n\tif (map_type & VMXNET3_MAP_XDP)\n\t\txdp_return_frame_bulk(tbi->xdpf, bq);\n\telse\n\t\tdev_kfree_skb_any(tbi->skb);\n\n\t \n\ttbi->skb = NULL;\n\n\treturn entries;\n}\n\n\nstatic int\nvmxnet3_tq_tx_complete(struct vmxnet3_tx_queue *tq,\n\t\t\tstruct vmxnet3_adapter *adapter)\n{\n\tunion Vmxnet3_GenericDesc *gdesc;\n\tstruct xdp_frame_bulk bq;\n\tint completed = 0;\n\n\txdp_frame_bulk_init(&bq);\n\trcu_read_lock();\n\n\tgdesc = tq->comp_ring.base + tq->comp_ring.next2proc;\n\twhile (VMXNET3_TCD_GET_GEN(&gdesc->tcd) == tq->comp_ring.gen) {\n\t\t \n\t\tdma_rmb();\n\n\t\tcompleted += vmxnet3_unmap_pkt(VMXNET3_TCD_GET_TXIDX(\n\t\t\t\t\t       &gdesc->tcd), tq, adapter->pdev,\n\t\t\t\t\t       adapter, &bq);\n\n\t\tvmxnet3_comp_ring_adv_next2proc(&tq->comp_ring);\n\t\tgdesc = tq->comp_ring.base + tq->comp_ring.next2proc;\n\t}\n\txdp_flush_frame_bulk(&bq);\n\trcu_read_unlock();\n\n\tif (completed) {\n\t\tspin_lock(&tq->tx_lock);\n\t\tif (unlikely(vmxnet3_tq_stopped(tq, adapter) &&\n\t\t\t     vmxnet3_cmd_ring_desc_avail(&tq->tx_ring) >\n\t\t\t     VMXNET3_WAKE_QUEUE_THRESHOLD(tq) &&\n\t\t\t     netif_carrier_ok(adapter->netdev))) {\n\t\t\tvmxnet3_tq_wake(tq, adapter);\n\t\t}\n\t\tspin_unlock(&tq->tx_lock);\n\t}\n\treturn completed;\n}\n\n\nstatic void\nvmxnet3_tq_cleanup(struct vmxnet3_tx_queue *tq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tstruct xdp_frame_bulk bq;\n\tu32 map_type;\n\tint i;\n\n\txdp_frame_bulk_init(&bq);\n\trcu_read_lock();\n\n\twhile (tq->tx_ring.next2comp != tq->tx_ring.next2fill) {\n\t\tstruct vmxnet3_tx_buf_info *tbi;\n\n\t\ttbi = tq->buf_info + tq->tx_ring.next2comp;\n\t\tmap_type = tbi->map_type;\n\n\t\tvmxnet3_unmap_tx_buf(tbi, adapter->pdev);\n\t\tif (tbi->skb) {\n\t\t\tif (map_type & VMXNET3_MAP_XDP)\n\t\t\t\txdp_return_frame_bulk(tbi->xdpf, &bq);\n\t\t\telse\n\t\t\t\tdev_kfree_skb_any(tbi->skb);\n\t\t\ttbi->skb = NULL;\n\t\t}\n\t\tvmxnet3_cmd_ring_adv_next2comp(&tq->tx_ring);\n\t}\n\n\txdp_flush_frame_bulk(&bq);\n\trcu_read_unlock();\n\n\t \n\tfor (i = 0; i < tq->tx_ring.size; i++)\n\t\tBUG_ON(tq->buf_info[i].map_type != VMXNET3_MAP_NONE);\n\n\ttq->tx_ring.gen = VMXNET3_INIT_GEN;\n\ttq->tx_ring.next2fill = tq->tx_ring.next2comp = 0;\n\n\ttq->comp_ring.gen = VMXNET3_INIT_GEN;\n\ttq->comp_ring.next2proc = 0;\n}\n\n\nstatic void\nvmxnet3_tq_destroy(struct vmxnet3_tx_queue *tq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tif (tq->tx_ring.base) {\n\t\tdma_free_coherent(&adapter->pdev->dev, tq->tx_ring.size *\n\t\t\t\t  sizeof(struct Vmxnet3_TxDesc),\n\t\t\t\t  tq->tx_ring.base, tq->tx_ring.basePA);\n\t\ttq->tx_ring.base = NULL;\n\t}\n\tif (tq->data_ring.base) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  tq->data_ring.size * tq->txdata_desc_size,\n\t\t\t\t  tq->data_ring.base, tq->data_ring.basePA);\n\t\ttq->data_ring.base = NULL;\n\t}\n\tif (tq->comp_ring.base) {\n\t\tdma_free_coherent(&adapter->pdev->dev, tq->comp_ring.size *\n\t\t\t\t  sizeof(struct Vmxnet3_TxCompDesc),\n\t\t\t\t  tq->comp_ring.base, tq->comp_ring.basePA);\n\t\ttq->comp_ring.base = NULL;\n\t}\n\tkfree(tq->buf_info);\n\ttq->buf_info = NULL;\n}\n\n\n \nvoid\nvmxnet3_tq_destroy_all(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tvmxnet3_tq_destroy(&adapter->tx_queue[i], adapter);\n}\n\n\nstatic void\nvmxnet3_tq_init(struct vmxnet3_tx_queue *tq,\n\t\tstruct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\t \n\tmemset(tq->tx_ring.base, 0, tq->tx_ring.size *\n\t       sizeof(struct Vmxnet3_TxDesc));\n\ttq->tx_ring.next2fill = tq->tx_ring.next2comp = 0;\n\ttq->tx_ring.gen = VMXNET3_INIT_GEN;\n\n\tmemset(tq->data_ring.base, 0,\n\t       tq->data_ring.size * tq->txdata_desc_size);\n\n\t \n\tmemset(tq->comp_ring.base, 0, tq->comp_ring.size *\n\t       sizeof(struct Vmxnet3_TxCompDesc));\n\ttq->comp_ring.next2proc = 0;\n\ttq->comp_ring.gen = VMXNET3_INIT_GEN;\n\n\t \n\tmemset(tq->buf_info, 0, sizeof(tq->buf_info[0]) * tq->tx_ring.size);\n\tfor (i = 0; i < tq->tx_ring.size; i++)\n\t\ttq->buf_info[i].map_type = VMXNET3_MAP_NONE;\n\n\t \n}\n\n\nstatic int\nvmxnet3_tq_create(struct vmxnet3_tx_queue *tq,\n\t\t  struct vmxnet3_adapter *adapter)\n{\n\tBUG_ON(tq->tx_ring.base || tq->data_ring.base ||\n\t       tq->comp_ring.base || tq->buf_info);\n\n\ttq->tx_ring.base = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\ttq->tx_ring.size * sizeof(struct Vmxnet3_TxDesc),\n\t\t\t&tq->tx_ring.basePA, GFP_KERNEL);\n\tif (!tq->tx_ring.base) {\n\t\tnetdev_err(adapter->netdev, \"failed to allocate tx ring\\n\");\n\t\tgoto err;\n\t}\n\n\ttq->data_ring.base = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\ttq->data_ring.size * tq->txdata_desc_size,\n\t\t\t&tq->data_ring.basePA, GFP_KERNEL);\n\tif (!tq->data_ring.base) {\n\t\tnetdev_err(adapter->netdev, \"failed to allocate tx data ring\\n\");\n\t\tgoto err;\n\t}\n\n\ttq->comp_ring.base = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\ttq->comp_ring.size * sizeof(struct Vmxnet3_TxCompDesc),\n\t\t\t&tq->comp_ring.basePA, GFP_KERNEL);\n\tif (!tq->comp_ring.base) {\n\t\tnetdev_err(adapter->netdev, \"failed to allocate tx comp ring\\n\");\n\t\tgoto err;\n\t}\n\n\ttq->buf_info = kcalloc_node(tq->tx_ring.size, sizeof(tq->buf_info[0]),\n\t\t\t\t    GFP_KERNEL,\n\t\t\t\t    dev_to_node(&adapter->pdev->dev));\n\tif (!tq->buf_info)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tvmxnet3_tq_destroy(tq, adapter);\n\treturn -ENOMEM;\n}\n\nstatic void\nvmxnet3_tq_cleanup_all(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tvmxnet3_tq_cleanup(&adapter->tx_queue[i], adapter);\n}\n\n \n\nstatic int\nvmxnet3_rq_alloc_rx_buf(struct vmxnet3_rx_queue *rq, u32 ring_idx,\n\t\t\tint num_to_alloc, struct vmxnet3_adapter *adapter)\n{\n\tint num_allocated = 0;\n\tstruct vmxnet3_rx_buf_info *rbi_base = rq->buf_info[ring_idx];\n\tstruct vmxnet3_cmd_ring *ring = &rq->rx_ring[ring_idx];\n\tu32 val;\n\n\twhile (num_allocated <= num_to_alloc) {\n\t\tstruct vmxnet3_rx_buf_info *rbi;\n\t\tunion Vmxnet3_GenericDesc *gd;\n\n\t\trbi = rbi_base + ring->next2fill;\n\t\tgd = ring->base + ring->next2fill;\n\t\trbi->comp_state = VMXNET3_RXD_COMP_PENDING;\n\n\t\tif (rbi->buf_type == VMXNET3_RX_BUF_XDP) {\n\t\t\tvoid *data = vmxnet3_pp_get_buff(rq->page_pool,\n\t\t\t\t\t\t\t &rbi->dma_addr,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trbi->page = virt_to_page(data);\n\t\t\tval = VMXNET3_RXD_BTYPE_HEAD << VMXNET3_RXD_BTYPE_SHIFT;\n\t\t} else if (rbi->buf_type == VMXNET3_RX_BUF_SKB) {\n\t\t\tif (rbi->skb == NULL) {\n\t\t\t\trbi->skb = __netdev_alloc_skb_ip_align(adapter->netdev,\n\t\t\t\t\t\t\t\t       rbi->len,\n\t\t\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\tif (unlikely(rbi->skb == NULL)) {\n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\trbi->dma_addr = dma_map_single(\n\t\t\t\t\t\t&adapter->pdev->dev,\n\t\t\t\t\t\trbi->skb->data, rbi->len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&adapter->pdev->dev,\n\t\t\t\t\t\t      rbi->dma_addr)) {\n\t\t\t\t\tdev_kfree_skb_any(rbi->skb);\n\t\t\t\t\trbi->skb = NULL;\n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\t\t\tval = VMXNET3_RXD_BTYPE_HEAD << VMXNET3_RXD_BTYPE_SHIFT;\n\t\t} else {\n\t\t\tBUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE ||\n\t\t\t       rbi->len  != PAGE_SIZE);\n\n\t\t\tif (rbi->page == NULL) {\n\t\t\t\trbi->page = alloc_page(GFP_ATOMIC);\n\t\t\t\tif (unlikely(rbi->page == NULL)) {\n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trbi->dma_addr = dma_map_page(\n\t\t\t\t\t\t&adapter->pdev->dev,\n\t\t\t\t\t\trbi->page, 0, PAGE_SIZE,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&adapter->pdev->dev,\n\t\t\t\t\t\t      rbi->dma_addr)) {\n\t\t\t\t\tput_page(rbi->page);\n\t\t\t\t\trbi->page = NULL;\n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t}\n\t\t\tval = VMXNET3_RXD_BTYPE_BODY << VMXNET3_RXD_BTYPE_SHIFT;\n\t\t}\n\n\t\tgd->rxd.addr = cpu_to_le64(rbi->dma_addr);\n\t\tgd->dword[2] = cpu_to_le32((!ring->gen << VMXNET3_RXD_GEN_SHIFT)\n\t\t\t\t\t   | val | rbi->len);\n\n\t\t \n\t\tif (num_allocated == num_to_alloc) {\n\t\t\trbi->comp_state = VMXNET3_RXD_COMP_DONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tgd->dword[2] |= cpu_to_le32(ring->gen << VMXNET3_RXD_GEN_SHIFT);\n\t\tnum_allocated++;\n\t\tvmxnet3_cmd_ring_adv_next2fill(ring);\n\t}\n\n\tnetdev_dbg(adapter->netdev,\n\t\t\"alloc_rx_buf: %d allocated, next2fill %u, next2comp %u\\n\",\n\t\tnum_allocated, ring->next2fill, ring->next2comp);\n\n\t \n\tBUG_ON(num_allocated != 0 && ring->next2fill == ring->next2comp);\n\n\treturn num_allocated;\n}\n\n\nstatic void\nvmxnet3_append_frag(struct sk_buff *skb, struct Vmxnet3_RxCompDesc *rcd,\n\t\t    struct vmxnet3_rx_buf_info *rbi)\n{\n\tskb_frag_t *frag = skb_shinfo(skb)->frags + skb_shinfo(skb)->nr_frags;\n\n\tBUG_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS);\n\n\tskb_frag_fill_page_desc(frag, rbi->page, 0, rcd->len);\n\tskb->data_len += rcd->len;\n\tskb->truesize += PAGE_SIZE;\n\tskb_shinfo(skb)->nr_frags++;\n}\n\n\nstatic int\nvmxnet3_map_pkt(struct sk_buff *skb, struct vmxnet3_tx_ctx *ctx,\n\t\tstruct vmxnet3_tx_queue *tq, struct pci_dev *pdev,\n\t\tstruct vmxnet3_adapter *adapter)\n{\n\tu32 dw2, len;\n\tunsigned long buf_offset;\n\tint i;\n\tunion Vmxnet3_GenericDesc *gdesc;\n\tstruct vmxnet3_tx_buf_info *tbi = NULL;\n\n\tBUG_ON(ctx->copy_size > skb_headlen(skb));\n\n\t \n\tdw2 = (tq->tx_ring.gen ^ 0x1) << VMXNET3_TXD_GEN_SHIFT;\n\n\tctx->sop_txd = tq->tx_ring.base + tq->tx_ring.next2fill;\n\tgdesc = ctx->sop_txd;  \n\n\t \n\tif (ctx->copy_size) {\n\t\tctx->sop_txd->txd.addr = cpu_to_le64(tq->data_ring.basePA +\n\t\t\t\t\ttq->tx_ring.next2fill *\n\t\t\t\t\ttq->txdata_desc_size);\n\t\tctx->sop_txd->dword[2] = cpu_to_le32(dw2 | ctx->copy_size);\n\t\tctx->sop_txd->dword[3] = 0;\n\n\t\ttbi = tq->buf_info + tq->tx_ring.next2fill;\n\t\ttbi->map_type = VMXNET3_MAP_NONE;\n\n\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\"txd[%u]: 0x%Lx 0x%x 0x%x\\n\",\n\t\t\ttq->tx_ring.next2fill,\n\t\t\tle64_to_cpu(ctx->sop_txd->txd.addr),\n\t\t\tctx->sop_txd->dword[2], ctx->sop_txd->dword[3]);\n\t\tvmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);\n\n\t\t \n\t\tdw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;\n\t}\n\n\t \n\tlen = skb_headlen(skb) - ctx->copy_size;\n\tbuf_offset = ctx->copy_size;\n\twhile (len) {\n\t\tu32 buf_size;\n\n\t\tif (len < VMXNET3_MAX_TX_BUF_SIZE) {\n\t\t\tbuf_size = len;\n\t\t\tdw2 |= len;\n\t\t} else {\n\t\t\tbuf_size = VMXNET3_MAX_TX_BUF_SIZE;\n\t\t\t \n\t\t}\n\n\t\ttbi = tq->buf_info + tq->tx_ring.next2fill;\n\t\ttbi->map_type = VMXNET3_MAP_SINGLE;\n\t\ttbi->dma_addr = dma_map_single(&adapter->pdev->dev,\n\t\t\t\tskb->data + buf_offset, buf_size,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&adapter->pdev->dev, tbi->dma_addr))\n\t\t\treturn -EFAULT;\n\n\t\ttbi->len = buf_size;\n\n\t\tgdesc = tq->tx_ring.base + tq->tx_ring.next2fill;\n\t\tBUG_ON(gdesc->txd.gen == tq->tx_ring.gen);\n\n\t\tgdesc->txd.addr = cpu_to_le64(tbi->dma_addr);\n\t\tgdesc->dword[2] = cpu_to_le32(dw2);\n\t\tgdesc->dword[3] = 0;\n\n\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\"txd[%u]: 0x%Lx 0x%x 0x%x\\n\",\n\t\t\ttq->tx_ring.next2fill, le64_to_cpu(gdesc->txd.addr),\n\t\t\tle32_to_cpu(gdesc->dword[2]), gdesc->dword[3]);\n\t\tvmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);\n\t\tdw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;\n\n\t\tlen -= buf_size;\n\t\tbuf_offset += buf_size;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tu32 buf_size;\n\n\t\tbuf_offset = 0;\n\t\tlen = skb_frag_size(frag);\n\t\twhile (len) {\n\t\t\ttbi = tq->buf_info + tq->tx_ring.next2fill;\n\t\t\tif (len < VMXNET3_MAX_TX_BUF_SIZE) {\n\t\t\t\tbuf_size = len;\n\t\t\t\tdw2 |= len;\n\t\t\t} else {\n\t\t\t\tbuf_size = VMXNET3_MAX_TX_BUF_SIZE;\n\t\t\t\t \n\t\t\t}\n\t\t\ttbi->map_type = VMXNET3_MAP_PAGE;\n\t\t\ttbi->dma_addr = skb_frag_dma_map(&adapter->pdev->dev, frag,\n\t\t\t\t\t\t\t buf_offset, buf_size,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(&adapter->pdev->dev, tbi->dma_addr))\n\t\t\t\treturn -EFAULT;\n\n\t\t\ttbi->len = buf_size;\n\n\t\t\tgdesc = tq->tx_ring.base + tq->tx_ring.next2fill;\n\t\t\tBUG_ON(gdesc->txd.gen == tq->tx_ring.gen);\n\n\t\t\tgdesc->txd.addr = cpu_to_le64(tbi->dma_addr);\n\t\t\tgdesc->dword[2] = cpu_to_le32(dw2);\n\t\t\tgdesc->dword[3] = 0;\n\n\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t\"txd[%u]: 0x%llx %u %u\\n\",\n\t\t\t\ttq->tx_ring.next2fill, le64_to_cpu(gdesc->txd.addr),\n\t\t\t\tle32_to_cpu(gdesc->dword[2]), gdesc->dword[3]);\n\t\t\tvmxnet3_cmd_ring_adv_next2fill(&tq->tx_ring);\n\t\t\tdw2 = tq->tx_ring.gen << VMXNET3_TXD_GEN_SHIFT;\n\n\t\t\tlen -= buf_size;\n\t\t\tbuf_offset += buf_size;\n\t\t}\n\t}\n\n\tctx->eop_txd = gdesc;\n\n\t \n\ttbi->skb = skb;\n\ttbi->sop_idx = ctx->sop_txd - tq->tx_ring.base;\n\n\treturn 0;\n}\n\n\n \nstatic void\nvmxnet3_tq_init_all(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tvmxnet3_tq_init(&adapter->tx_queue[i], adapter);\n}\n\n\n \nstatic int\nvmxnet3_parse_hdr(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,\n\t\t  struct vmxnet3_tx_ctx *ctx,\n\t\t  struct vmxnet3_adapter *adapter)\n{\n\tu8 protocol = 0;\n\n\tif (ctx->mss) {\t \n\t\tif (VMXNET3_VERSION_GE_4(adapter) && skb->encapsulation) {\n\t\t\tctx->l4_offset = skb_inner_transport_offset(skb);\n\t\t\tctx->l4_hdr_size = inner_tcp_hdrlen(skb);\n\t\t\tctx->copy_size = ctx->l4_offset + ctx->l4_hdr_size;\n\t\t} else {\n\t\t\tctx->l4_offset = skb_transport_offset(skb);\n\t\t\tctx->l4_hdr_size = tcp_hdrlen(skb);\n\t\t\tctx->copy_size = ctx->l4_offset + ctx->l4_hdr_size;\n\t\t}\n\t} else {\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t \n\t\t\tctx->l4_offset = skb_checksum_start_offset(skb);\n\n\t\t\tif (VMXNET3_VERSION_GE_4(adapter) &&\n\t\t\t    skb->encapsulation) {\n\t\t\t\tstruct iphdr *iph = inner_ip_hdr(skb);\n\n\t\t\t\tif (iph->version == 4) {\n\t\t\t\t\tprotocol = iph->protocol;\n\t\t\t\t} else {\n\t\t\t\t\tconst struct ipv6hdr *ipv6h;\n\n\t\t\t\t\tipv6h = inner_ipv6_hdr(skb);\n\t\t\t\t\tprotocol = ipv6h->nexthdr;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ctx->ipv4) {\n\t\t\t\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\t\t\t\tprotocol = iph->protocol;\n\t\t\t\t} else if (ctx->ipv6) {\n\t\t\t\t\tconst struct ipv6hdr *ipv6h;\n\n\t\t\t\t\tipv6h = ipv6_hdr(skb);\n\t\t\t\t\tprotocol = ipv6h->nexthdr;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (protocol) {\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\tctx->l4_hdr_size = skb->encapsulation ? inner_tcp_hdrlen(skb) :\n\t\t\t\t\t\t   tcp_hdrlen(skb);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\tctx->l4_hdr_size = sizeof(struct udphdr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tctx->l4_hdr_size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx->copy_size = min(ctx->l4_offset +\n\t\t\t\t\t ctx->l4_hdr_size, skb->len);\n\t\t} else {\n\t\t\tctx->l4_offset = 0;\n\t\t\tctx->l4_hdr_size = 0;\n\t\t\t \n\t\t\tctx->copy_size = min_t(unsigned int,\n\t\t\t\t\t       tq->txdata_desc_size,\n\t\t\t\t\t       skb_headlen(skb));\n\t\t}\n\n\t\tif (skb->len <= VMXNET3_HDR_COPY_SIZE)\n\t\t\tctx->copy_size = skb->len;\n\n\t\t \n\t\tif (unlikely(!pskb_may_pull(skb, ctx->copy_size)))\n\t\t\tgoto err;\n\t}\n\n\tif (unlikely(ctx->copy_size > tq->txdata_desc_size)) {\n\t\ttq->stats.oversized_hdr++;\n\t\tctx->copy_size = 0;\n\t\treturn 0;\n\t}\n\n\treturn 1;\nerr:\n\treturn -1;\n}\n\n \nstatic void\nvmxnet3_copy_hdr(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,\n\t\t struct vmxnet3_tx_ctx *ctx,\n\t\t struct vmxnet3_adapter *adapter)\n{\n\tstruct Vmxnet3_TxDataDesc *tdd;\n\n\ttdd = (struct Vmxnet3_TxDataDesc *)((u8 *)tq->data_ring.base +\n\t\t\t\t\t    tq->tx_ring.next2fill *\n\t\t\t\t\t    tq->txdata_desc_size);\n\n\tmemcpy(tdd->data, skb->data, ctx->copy_size);\n\tnetdev_dbg(adapter->netdev,\n\t\t\"copy %u bytes to dataRing[%u]\\n\",\n\t\tctx->copy_size, tq->tx_ring.next2fill);\n}\n\n\nstatic void\nvmxnet3_prepare_inner_tso(struct sk_buff *skb,\n\t\t\t  struct vmxnet3_tx_ctx *ctx)\n{\n\tstruct tcphdr *tcph = inner_tcp_hdr(skb);\n\tstruct iphdr *iph = inner_ip_hdr(skb);\n\n\tif (iph->version == 4) {\n\t\tiph->check = 0;\n\t\ttcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, 0,\n\t\t\t\t\t\t IPPROTO_TCP, 0);\n\t} else {\n\t\tstruct ipv6hdr *iph = inner_ipv6_hdr(skb);\n\n\t\ttcph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, 0,\n\t\t\t\t\t       IPPROTO_TCP, 0);\n\t}\n}\n\nstatic void\nvmxnet3_prepare_tso(struct sk_buff *skb,\n\t\t    struct vmxnet3_tx_ctx *ctx)\n{\n\tstruct tcphdr *tcph = tcp_hdr(skb);\n\n\tif (ctx->ipv4) {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\n\t\tiph->check = 0;\n\t\ttcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, 0,\n\t\t\t\t\t\t IPPROTO_TCP, 0);\n\t} else if (ctx->ipv6) {\n\t\ttcp_v6_gso_csum_prep(skb);\n\t}\n}\n\nstatic int txd_estimate(const struct sk_buff *skb)\n{\n\tint count = VMXNET3_TXD_NEEDED(skb_headlen(skb)) + 1;\n\tint i;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tcount += VMXNET3_TXD_NEEDED(skb_frag_size(frag));\n\t}\n\treturn count;\n}\n\n \n\nstatic int\nvmxnet3_tq_xmit(struct sk_buff *skb, struct vmxnet3_tx_queue *tq,\n\t\tstruct vmxnet3_adapter *adapter, struct net_device *netdev)\n{\n\tint ret;\n\tu32 count;\n\tint num_pkts;\n\tint tx_num_deferred;\n\tunsigned long flags;\n\tstruct vmxnet3_tx_ctx ctx;\n\tunion Vmxnet3_GenericDesc *gdesc;\n#ifdef __BIG_ENDIAN_BITFIELD\n\t \n\tunion Vmxnet3_GenericDesc tempTxDesc;\n#endif\n\n\tcount = txd_estimate(skb);\n\n\tctx.ipv4 = (vlan_get_protocol(skb) == cpu_to_be16(ETH_P_IP));\n\tctx.ipv6 = (vlan_get_protocol(skb) == cpu_to_be16(ETH_P_IPV6));\n\n\tctx.mss = skb_shinfo(skb)->gso_size;\n\tif (ctx.mss) {\n\t\tif (skb_header_cloned(skb)) {\n\t\t\tif (unlikely(pskb_expand_head(skb, 0, 0,\n\t\t\t\t\t\t      GFP_ATOMIC) != 0)) {\n\t\t\t\ttq->stats.drop_tso++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t\ttq->stats.copy_skb_header++;\n\t\t}\n\t\tif (unlikely(count > VMXNET3_MAX_TSO_TXD_PER_PKT)) {\n\t\t\t \n\t\t\tif (skb_linearize(skb) != 0) {\n\t\t\t\ttq->stats.drop_too_many_frags++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t\ttq->stats.linearized++;\n\n\t\t\t \n\t\t\tcount = VMXNET3_TXD_NEEDED(skb_headlen(skb)) + 1;\n\t\t\tif (unlikely(count > VMXNET3_MAX_TSO_TXD_PER_PKT)) {\n\t\t\t\ttq->stats.drop_too_many_frags++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t}\n\t\tif (skb->encapsulation) {\n\t\t\tvmxnet3_prepare_inner_tso(skb, &ctx);\n\t\t} else {\n\t\t\tvmxnet3_prepare_tso(skb, &ctx);\n\t\t}\n\t} else {\n\t\tif (unlikely(count > VMXNET3_MAX_TXD_PER_PKT)) {\n\n\t\t\t \n\t\t\tif (skb_linearize(skb) != 0) {\n\t\t\t\ttq->stats.drop_too_many_frags++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t\ttq->stats.linearized++;\n\n\t\t\t \n\t\t\tcount = VMXNET3_TXD_NEEDED(skb_headlen(skb)) + 1;\n\t\t}\n\t}\n\n\tret = vmxnet3_parse_hdr(skb, tq, &ctx, adapter);\n\tif (ret >= 0) {\n\t\tBUG_ON(ret <= 0 && ctx.copy_size != 0);\n\t\t \n\t\tif (ctx.mss) {\n\t\t\tif (unlikely(ctx.l4_offset + ctx.l4_hdr_size >\n\t\t\t\t     VMXNET3_MAX_TX_BUF_SIZE)) {\n\t\t\t\ttq->stats.drop_oversized_hdr++;\n\t\t\t\tgoto drop_pkt;\n\t\t\t}\n\t\t} else {\n\t\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\tif (unlikely(ctx.l4_offset +\n\t\t\t\t\t     skb->csum_offset >\n\t\t\t\t\t     VMXNET3_MAX_CSUM_OFFSET)) {\n\t\t\t\t\ttq->stats.drop_oversized_hdr++;\n\t\t\t\t\tgoto drop_pkt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttq->stats.drop_hdr_inspect_err++;\n\t\tgoto drop_pkt;\n\t}\n\n\tspin_lock_irqsave(&tq->tx_lock, flags);\n\n\tif (count > vmxnet3_cmd_ring_desc_avail(&tq->tx_ring)) {\n\t\ttq->stats.tx_ring_full++;\n\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\"tx queue stopped on %s, next2comp %u\"\n\t\t\t\" next2fill %u\\n\", adapter->netdev->name,\n\t\t\ttq->tx_ring.next2comp, tq->tx_ring.next2fill);\n\n\t\tvmxnet3_tq_stop(tq, adapter);\n\t\tspin_unlock_irqrestore(&tq->tx_lock, flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\n\tvmxnet3_copy_hdr(skb, tq, &ctx, adapter);\n\n\t \n\tif (vmxnet3_map_pkt(skb, &ctx, tq, adapter->pdev, adapter))\n\t\tgoto unlock_drop_pkt;\n\n\t \n\tctx.eop_txd->dword[3] = cpu_to_le32(VMXNET3_TXD_CQ | VMXNET3_TXD_EOP);\n\n\t \n#ifdef __BIG_ENDIAN_BITFIELD\n\tgdesc = &tempTxDesc;\n\tgdesc->dword[2] = ctx.sop_txd->dword[2];\n\tgdesc->dword[3] = ctx.sop_txd->dword[3];\n#else\n\tgdesc = ctx.sop_txd;\n#endif\n\ttx_num_deferred = le32_to_cpu(tq->shared->txNumDeferred);\n\tif (ctx.mss) {\n\t\tif (VMXNET3_VERSION_GE_4(adapter) && skb->encapsulation) {\n\t\t\tgdesc->txd.hlen = ctx.l4_offset + ctx.l4_hdr_size;\n\t\t\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\t\t\tgdesc->txd.om = VMXNET3_OM_TSO;\n\t\t\t\tgdesc->txd.ext1 = 1;\n\t\t\t} else {\n\t\t\t\tgdesc->txd.om = VMXNET3_OM_ENCAP;\n\t\t\t}\n\t\t\tgdesc->txd.msscof = ctx.mss;\n\n\t\t\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM)\n\t\t\t\tgdesc->txd.oco = 1;\n\t\t} else {\n\t\t\tgdesc->txd.hlen = ctx.l4_offset + ctx.l4_hdr_size;\n\t\t\tgdesc->txd.om = VMXNET3_OM_TSO;\n\t\t\tgdesc->txd.msscof = ctx.mss;\n\t\t}\n\t\tnum_pkts = (skb->len - gdesc->txd.hlen + ctx.mss - 1) / ctx.mss;\n\t} else {\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tif (VMXNET3_VERSION_GE_4(adapter) &&\n\t\t\t    skb->encapsulation) {\n\t\t\t\tgdesc->txd.hlen = ctx.l4_offset +\n\t\t\t\t\t\t  ctx.l4_hdr_size;\n\t\t\t\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\t\t\t\tgdesc->txd.om = VMXNET3_OM_CSUM;\n\t\t\t\t\tgdesc->txd.msscof = ctx.l4_offset +\n\t\t\t\t\t\t\t    skb->csum_offset;\n\t\t\t\t\tgdesc->txd.ext1 = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgdesc->txd.om = VMXNET3_OM_ENCAP;\n\t\t\t\t\tgdesc->txd.msscof = 0;\t\t \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgdesc->txd.hlen = ctx.l4_offset;\n\t\t\t\tgdesc->txd.om = VMXNET3_OM_CSUM;\n\t\t\t\tgdesc->txd.msscof = ctx.l4_offset +\n\t\t\t\t\t\t    skb->csum_offset;\n\t\t\t}\n\t\t} else {\n\t\t\tgdesc->txd.om = 0;\n\t\t\tgdesc->txd.msscof = 0;\n\t\t}\n\t\tnum_pkts = 1;\n\t}\n\tle32_add_cpu(&tq->shared->txNumDeferred, num_pkts);\n\ttx_num_deferred += num_pkts;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tgdesc->txd.ti = 1;\n\t\tgdesc->txd.tci = skb_vlan_tag_get(skb);\n\t}\n\n\t \n\tdma_wmb();\n\n\t \n\tgdesc->dword[2] = cpu_to_le32(le32_to_cpu(gdesc->dword[2]) ^\n\t\t\t\t\t\t  VMXNET3_TXD_GEN);\n#ifdef __BIG_ENDIAN_BITFIELD\n\t \n\tvmxnet3_TxDescToLe((struct Vmxnet3_TxDesc *)gdesc,\n\t\t\t   (struct Vmxnet3_TxDesc *)ctx.sop_txd);\n\tgdesc = ctx.sop_txd;\n#endif\n\tnetdev_dbg(adapter->netdev,\n\t\t\"txd[%u]: SOP 0x%Lx 0x%x 0x%x\\n\",\n\t\t(u32)(ctx.sop_txd -\n\t\ttq->tx_ring.base), le64_to_cpu(gdesc->txd.addr),\n\t\tle32_to_cpu(gdesc->dword[2]), le32_to_cpu(gdesc->dword[3]));\n\n\tspin_unlock_irqrestore(&tq->tx_lock, flags);\n\n\tif (tx_num_deferred >= le32_to_cpu(tq->shared->txThreshold)) {\n\t\ttq->shared->txNumDeferred = 0;\n\t\tVMXNET3_WRITE_BAR0_REG(adapter,\n\t\t\t\t       adapter->tx_prod_offset + tq->qid * 8,\n\t\t\t\t       tq->tx_ring.next2fill);\n\t}\n\n\treturn NETDEV_TX_OK;\n\nunlock_drop_pkt:\n\tspin_unlock_irqrestore(&tq->tx_lock, flags);\ndrop_pkt:\n\ttq->stats.drop_total++;\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int\nvmxnet3_create_pp(struct vmxnet3_adapter *adapter,\n\t\t  struct vmxnet3_rx_queue *rq, int size)\n{\n\tbool xdp_prog = vmxnet3_xdp_enabled(adapter);\n\tconst struct page_pool_params pp_params = {\n\t\t.order = 0,\n\t\t.flags = PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV,\n\t\t.pool_size = size,\n\t\t.nid = NUMA_NO_NODE,\n\t\t.dev = &adapter->pdev->dev,\n\t\t.offset = VMXNET3_XDP_RX_OFFSET,\n\t\t.max_len = VMXNET3_XDP_MAX_FRSIZE,\n\t\t.dma_dir = xdp_prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE,\n\t};\n\tstruct page_pool *pp;\n\tint err;\n\n\tpp = page_pool_create(&pp_params);\n\tif (IS_ERR(pp))\n\t\treturn PTR_ERR(pp);\n\n\terr = xdp_rxq_info_reg(&rq->xdp_rxq, adapter->netdev, rq->qid,\n\t\t\t       rq->napi.napi_id);\n\tif (err < 0)\n\t\tgoto err_free_pp;\n\n\terr = xdp_rxq_info_reg_mem_model(&rq->xdp_rxq, MEM_TYPE_PAGE_POOL, pp);\n\tif (err)\n\t\tgoto err_unregister_rxq;\n\n\trq->page_pool = pp;\n\n\treturn 0;\n\nerr_unregister_rxq:\n\txdp_rxq_info_unreg(&rq->xdp_rxq);\nerr_free_pp:\n\tpage_pool_destroy(pp);\n\n\treturn err;\n}\n\nvoid *\nvmxnet3_pp_get_buff(struct page_pool *pp, dma_addr_t *dma_addr,\n\t\t    gfp_t gfp_mask)\n{\n\tstruct page *page;\n\n\tpage = page_pool_alloc_pages(pp, gfp_mask | __GFP_NOWARN);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\t*dma_addr = page_pool_get_dma_addr(page) + pp->p.offset;\n\n\treturn page_address(page);\n}\n\nstatic netdev_tx_t\nvmxnet3_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tBUG_ON(skb->queue_mapping > adapter->num_tx_queues);\n\treturn vmxnet3_tq_xmit(skb,\n\t\t\t       &adapter->tx_queue[skb->queue_mapping],\n\t\t\t       adapter, netdev);\n}\n\n\nstatic void\nvmxnet3_rx_csum(struct vmxnet3_adapter *adapter,\n\t\tstruct sk_buff *skb,\n\t\tunion Vmxnet3_GenericDesc *gdesc)\n{\n\tif (!gdesc->rcd.cnc && adapter->netdev->features & NETIF_F_RXCSUM) {\n\t\tif (gdesc->rcd.v4 &&\n\t\t    (le32_to_cpu(gdesc->dword[3]) &\n\t\t     VMXNET3_RCD_CSUM_OK) == VMXNET3_RCD_CSUM_OK) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tif ((le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t     (1UL << VMXNET3_RCD_HDR_INNER_SHIFT))) {\n\t\t\t\tskb->csum_level = 1;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!(gdesc->rcd.tcp || gdesc->rcd.udp) &&\n\t\t\t\t     !(le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t     (1UL << VMXNET3_RCD_HDR_INNER_SHIFT)));\n\t\t\tWARN_ON_ONCE(gdesc->rcd.frg &&\n\t\t\t\t     !(le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t     (1UL << VMXNET3_RCD_HDR_INNER_SHIFT)));\n\t\t} else if (gdesc->rcd.v6 && (le32_to_cpu(gdesc->dword[3]) &\n\t\t\t\t\t     (1 << VMXNET3_RCD_TUC_SHIFT))) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tif ((le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t     (1UL << VMXNET3_RCD_HDR_INNER_SHIFT))) {\n\t\t\t\tskb->csum_level = 1;\n\t\t\t}\n\t\t\tWARN_ON_ONCE(!(gdesc->rcd.tcp || gdesc->rcd.udp) &&\n\t\t\t\t     !(le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t     (1UL << VMXNET3_RCD_HDR_INNER_SHIFT)));\n\t\t\tWARN_ON_ONCE(gdesc->rcd.frg &&\n\t\t\t\t     !(le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t     (1UL << VMXNET3_RCD_HDR_INNER_SHIFT)));\n\t\t} else {\n\t\t\tif (gdesc->rcd.csum) {\n\t\t\t\tskb->csum = htons(gdesc->rcd.csum);\n\t\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\t\t} else {\n\t\t\t\tskb_checksum_none_assert(skb);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tskb_checksum_none_assert(skb);\n\t}\n}\n\n\nstatic void\nvmxnet3_rx_error(struct vmxnet3_rx_queue *rq, struct Vmxnet3_RxCompDesc *rcd,\n\t\t struct vmxnet3_rx_ctx *ctx,  struct vmxnet3_adapter *adapter)\n{\n\trq->stats.drop_err++;\n\tif (!rcd->fcs)\n\t\trq->stats.drop_fcs++;\n\n\trq->stats.drop_total++;\n\n\t \n\n\t \n\tif (ctx->skb)\n\t\tdev_kfree_skb_irq(ctx->skb);\n\n\tctx->skb = NULL;\n}\n\n\nstatic u32\nvmxnet3_get_hdr_len(struct vmxnet3_adapter *adapter, struct sk_buff *skb,\n\t\t    union Vmxnet3_GenericDesc *gdesc)\n{\n\tu32 hlen, maplen;\n\tunion {\n\t\tvoid *ptr;\n\t\tstruct ethhdr *eth;\n\t\tstruct vlan_ethhdr *veth;\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tstruct tcphdr *tcp;\n\t} hdr;\n\tBUG_ON(gdesc->rcd.tcp == 0);\n\n\tmaplen = skb_headlen(skb);\n\tif (unlikely(sizeof(struct iphdr) + sizeof(struct tcphdr) > maplen))\n\t\treturn 0;\n\n\tif (skb->protocol == cpu_to_be16(ETH_P_8021Q) ||\n\t    skb->protocol == cpu_to_be16(ETH_P_8021AD))\n\t\thlen = sizeof(struct vlan_ethhdr);\n\telse\n\t\thlen = sizeof(struct ethhdr);\n\n\thdr.eth = eth_hdr(skb);\n\tif (gdesc->rcd.v4) {\n\t\tBUG_ON(hdr.eth->h_proto != htons(ETH_P_IP) &&\n\t\t       hdr.veth->h_vlan_encapsulated_proto != htons(ETH_P_IP));\n\t\thdr.ptr += hlen;\n\t\tBUG_ON(hdr.ipv4->protocol != IPPROTO_TCP);\n\t\thlen = hdr.ipv4->ihl << 2;\n\t\thdr.ptr += hdr.ipv4->ihl << 2;\n\t} else if (gdesc->rcd.v6) {\n\t\tBUG_ON(hdr.eth->h_proto != htons(ETH_P_IPV6) &&\n\t\t       hdr.veth->h_vlan_encapsulated_proto != htons(ETH_P_IPV6));\n\t\thdr.ptr += hlen;\n\t\t \n\t\tif (hdr.ipv6->nexthdr != IPPROTO_TCP)\n\t\t\treturn sizeof(struct ipv6hdr) + sizeof(struct tcphdr);\n\t\thlen = sizeof(struct ipv6hdr);\n\t\thdr.ptr += sizeof(struct ipv6hdr);\n\t} else {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (hlen + sizeof(struct tcphdr) > maplen)\n\t\treturn 0;\n\n\treturn (hlen + (hdr.tcp->doff << 2));\n}\n\nstatic int\nvmxnet3_rq_rx_complete(struct vmxnet3_rx_queue *rq,\n\t\t       struct vmxnet3_adapter *adapter, int quota)\n{\n\tu32 rxprod_reg[2] = {\n\t\tadapter->rx_prod_offset, adapter->rx_prod2_offset\n\t};\n\tu32 num_pkts = 0;\n\tbool skip_page_frags = false;\n\tbool encap_lro = false;\n\tstruct Vmxnet3_RxCompDesc *rcd;\n\tstruct vmxnet3_rx_ctx *ctx = &rq->rx_ctx;\n\tu16 segCnt = 0, mss = 0;\n\tint comp_offset, fill_offset;\n#ifdef __BIG_ENDIAN_BITFIELD\n\tstruct Vmxnet3_RxDesc rxCmdDesc;\n\tstruct Vmxnet3_RxCompDesc rxComp;\n#endif\n\tbool need_flush = false;\n\n\tvmxnet3_getRxComp(rcd, &rq->comp_ring.base[rq->comp_ring.next2proc].rcd,\n\t\t\t  &rxComp);\n\twhile (rcd->gen == rq->comp_ring.gen) {\n\t\tstruct vmxnet3_rx_buf_info *rbi;\n\t\tstruct sk_buff *skb, *new_skb = NULL;\n\t\tstruct page *new_page = NULL;\n\t\tdma_addr_t new_dma_addr;\n\t\tint num_to_alloc;\n\t\tstruct Vmxnet3_RxDesc *rxd;\n\t\tu32 idx, ring_idx;\n\t\tstruct vmxnet3_cmd_ring\t*ring = NULL;\n\t\tif (num_pkts >= quota) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdma_rmb();\n\n\t\tBUG_ON(rcd->rqID != rq->qid && rcd->rqID != rq->qid2 &&\n\t\t       rcd->rqID != rq->dataRingQid);\n\t\tidx = rcd->rxdIdx;\n\t\tring_idx = VMXNET3_GET_RING_IDX(adapter, rcd->rqID);\n\t\tring = rq->rx_ring + ring_idx;\n\t\tvmxnet3_getRxDesc(rxd, &rq->rx_ring[ring_idx].base[idx].rxd,\n\t\t\t\t  &rxCmdDesc);\n\t\trbi = rq->buf_info[ring_idx] + idx;\n\n\t\tBUG_ON(rxd->addr != rbi->dma_addr ||\n\t\t       rxd->len != rbi->len);\n\n\t\tif (unlikely(rcd->eop && rcd->err)) {\n\t\t\tvmxnet3_rx_error(rq, rcd, ctx, adapter);\n\t\t\tgoto rcd_done;\n\t\t}\n\n\t\tif (rcd->sop && rcd->eop && vmxnet3_xdp_enabled(adapter)) {\n\t\t\tstruct sk_buff *skb_xdp_pass;\n\t\t\tint act;\n\n\t\t\tif (VMXNET3_RX_DATA_RING(adapter, rcd->rqID)) {\n\t\t\t\tctx->skb = NULL;\n\t\t\t\tgoto skip_xdp;  \n\t\t\t}\n\n\t\t\tif (rbi->buf_type != VMXNET3_RX_BUF_XDP)\n\t\t\t\tgoto rcd_done;\n\n\t\t\tact = vmxnet3_process_xdp(adapter, rq, rcd, rbi, rxd,\n\t\t\t\t\t\t  &skb_xdp_pass);\n\t\t\tif (act == XDP_PASS) {\n\t\t\t\tctx->skb = skb_xdp_pass;\n\t\t\t\tgoto sop_done;\n\t\t\t}\n\t\t\tctx->skb = NULL;\n\t\t\tneed_flush |= act == XDP_REDIRECT;\n\n\t\t\tgoto rcd_done;\n\t\t}\nskip_xdp:\n\n\t\tif (rcd->sop) {  \n\t\t\tbool rxDataRingUsed;\n\t\t\tu16 len;\n\n\t\t\tBUG_ON(rxd->btype != VMXNET3_RXD_BTYPE_HEAD ||\n\t\t\t       (rcd->rqID != rq->qid &&\n\t\t\t\trcd->rqID != rq->dataRingQid));\n\n\t\t\tBUG_ON(rbi->buf_type != VMXNET3_RX_BUF_SKB &&\n\t\t\t       rbi->buf_type != VMXNET3_RX_BUF_XDP);\n\t\t\tBUG_ON(ctx->skb != NULL || rbi->skb == NULL);\n\n\t\t\tif (unlikely(rcd->len == 0)) {\n\t\t\t\t \n\t\t\t\tBUG_ON(!(rcd->sop && rcd->eop));\n\t\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t\t\"rxRing[%u][%u] 0 length\\n\",\n\t\t\t\t\tring_idx, idx);\n\t\t\t\tgoto rcd_done;\n\t\t\t}\n\n\t\t\tskip_page_frags = false;\n\t\t\tctx->skb = rbi->skb;\n\n\t\t\trxDataRingUsed =\n\t\t\t\tVMXNET3_RX_DATA_RING(adapter, rcd->rqID);\n\t\t\tlen = rxDataRingUsed ? rcd->len : rbi->len;\n\n\t\t\tif (rxDataRingUsed && vmxnet3_xdp_enabled(adapter)) {\n\t\t\t\tstruct sk_buff *skb_xdp_pass;\n\t\t\t\tsize_t sz;\n\t\t\t\tint act;\n\n\t\t\t\tsz = rcd->rxdIdx * rq->data_ring.desc_size;\n\t\t\t\tact = vmxnet3_process_xdp_small(adapter, rq,\n\t\t\t\t\t\t\t\t&rq->data_ring.base[sz],\n\t\t\t\t\t\t\t\trcd->len,\n\t\t\t\t\t\t\t\t&skb_xdp_pass);\n\t\t\t\tif (act == XDP_PASS) {\n\t\t\t\t\tctx->skb = skb_xdp_pass;\n\t\t\t\t\tgoto sop_done;\n\t\t\t\t}\n\t\t\t\tneed_flush |= act == XDP_REDIRECT;\n\n\t\t\t\tgoto rcd_done;\n\t\t\t}\n\t\t\tnew_skb = netdev_alloc_skb_ip_align(adapter->netdev,\n\t\t\t\t\t\t\t    len);\n\t\t\tif (new_skb == NULL) {\n\t\t\t\t \n\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\tctx->skb = NULL;\n\t\t\t\trq->stats.drop_total++;\n\t\t\t\tskip_page_frags = true;\n\t\t\t\tgoto rcd_done;\n\t\t\t}\n\n\t\t\tif (rxDataRingUsed && adapter->rxdataring_enabled) {\n\t\t\t\tsize_t sz;\n\n\t\t\t\tBUG_ON(rcd->len > rq->data_ring.desc_size);\n\n\t\t\t\tctx->skb = new_skb;\n\t\t\t\tsz = rcd->rxdIdx * rq->data_ring.desc_size;\n\t\t\t\tmemcpy(new_skb->data,\n\t\t\t\t       &rq->data_ring.base[sz], rcd->len);\n\t\t\t} else {\n\t\t\t\tctx->skb = rbi->skb;\n\n\t\t\t\tnew_dma_addr =\n\t\t\t\t\tdma_map_single(&adapter->pdev->dev,\n\t\t\t\t\t\t       new_skb->data, rbi->len,\n\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&adapter->pdev->dev,\n\t\t\t\t\t\t      new_dma_addr)) {\n\t\t\t\t\tdev_kfree_skb(new_skb);\n\t\t\t\t\t \n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tctx->skb = NULL;\n\t\t\t\t\trq->stats.drop_total++;\n\t\t\t\t\tskip_page_frags = true;\n\t\t\t\t\tgoto rcd_done;\n\t\t\t\t}\n\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev,\n\t\t\t\t\t\t rbi->dma_addr,\n\t\t\t\t\t\t rbi->len,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\t\t \n\t\t\t\trbi->skb = new_skb;\n\t\t\t\trbi->dma_addr = new_dma_addr;\n\t\t\t\trxd->addr = cpu_to_le64(rbi->dma_addr);\n\t\t\t\trxd->len = rbi->len;\n\t\t\t}\n\n\t\t\tskb_record_rx_queue(ctx->skb, rq->qid);\n\t\t\tskb_put(ctx->skb, rcd->len);\n\n\t\t\tif (VMXNET3_VERSION_GE_2(adapter) &&\n\t\t\t    rcd->type == VMXNET3_CDTYPE_RXCOMP_LRO) {\n\t\t\t\tstruct Vmxnet3_RxCompDescExt *rcdlro;\n\t\t\t\tunion Vmxnet3_GenericDesc *gdesc;\n\n\t\t\t\trcdlro = (struct Vmxnet3_RxCompDescExt *)rcd;\n\t\t\t\tgdesc = (union Vmxnet3_GenericDesc *)rcd;\n\n\t\t\t\tsegCnt = rcdlro->segCnt;\n\t\t\t\tWARN_ON_ONCE(segCnt == 0);\n\t\t\t\tmss = rcdlro->mss;\n\t\t\t\tif (unlikely(segCnt <= 1))\n\t\t\t\t\tsegCnt = 0;\n\t\t\t\tencap_lro = (le32_to_cpu(gdesc->dword[0]) &\n\t\t\t\t\t(1UL << VMXNET3_RCD_HDR_INNER_SHIFT));\n\t\t\t} else {\n\t\t\t\tsegCnt = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(ctx->skb == NULL && !skip_page_frags);\n\n\t\t\t \n\t\t\tBUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE);\n\t\t\tBUG_ON(rxd->btype != VMXNET3_RXD_BTYPE_BODY);\n\n\t\t\t \n\t\t\tif (skip_page_frags)\n\t\t\t\tgoto rcd_done;\n\n\t\t\tif (rcd->len) {\n\t\t\t\tnew_page = alloc_page(GFP_ATOMIC);\n\t\t\t\t \n\t\t\t\tif (unlikely(!new_page)) {\n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tdev_kfree_skb(ctx->skb);\n\t\t\t\t\tctx->skb = NULL;\n\t\t\t\t\tskip_page_frags = true;\n\t\t\t\t\tgoto rcd_done;\n\t\t\t\t}\n\t\t\t\tnew_dma_addr = dma_map_page(&adapter->pdev->dev,\n\t\t\t\t\t\t\t    new_page,\n\t\t\t\t\t\t\t    0, PAGE_SIZE,\n\t\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&adapter->pdev->dev,\n\t\t\t\t\t\t      new_dma_addr)) {\n\t\t\t\t\tput_page(new_page);\n\t\t\t\t\trq->stats.rx_buf_alloc_failure++;\n\t\t\t\t\tdev_kfree_skb(ctx->skb);\n\t\t\t\t\tctx->skb = NULL;\n\t\t\t\t\tskip_page_frags = true;\n\t\t\t\t\tgoto rcd_done;\n\t\t\t\t}\n\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev,\n\t\t\t\t\t       rbi->dma_addr, rbi->len,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\n\t\t\t\tvmxnet3_append_frag(ctx->skb, rcd, rbi);\n\n\t\t\t\t \n\t\t\t\trbi->page = new_page;\n\t\t\t\trbi->dma_addr = new_dma_addr;\n\t\t\t\trxd->addr = cpu_to_le64(rbi->dma_addr);\n\t\t\t\trxd->len = rbi->len;\n\t\t\t}\n\t\t}\n\n\nsop_done:\n\t\tskb = ctx->skb;\n\t\tif (rcd->eop) {\n\t\t\tu32 mtu = adapter->netdev->mtu;\n\t\t\tskb->len += skb->data_len;\n\n#ifdef VMXNET3_RSS\n\t\t\tif (rcd->rssType != VMXNET3_RCD_RSS_TYPE_NONE &&\n\t\t\t    (adapter->netdev->features & NETIF_F_RXHASH)) {\n\t\t\t\tenum pkt_hash_types hash_type;\n\n\t\t\t\tswitch (rcd->rssType) {\n\t\t\t\tcase VMXNET3_RCD_RSS_TYPE_IPV4:\n\t\t\t\tcase VMXNET3_RCD_RSS_TYPE_IPV6:\n\t\t\t\t\thash_type = PKT_HASH_TYPE_L3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VMXNET3_RCD_RSS_TYPE_TCPIPV4:\n\t\t\t\tcase VMXNET3_RCD_RSS_TYPE_TCPIPV6:\n\t\t\t\tcase VMXNET3_RCD_RSS_TYPE_UDPIPV4:\n\t\t\t\tcase VMXNET3_RCD_RSS_TYPE_UDPIPV6:\n\t\t\t\t\thash_type = PKT_HASH_TYPE_L4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\thash_type = PKT_HASH_TYPE_L3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tskb_set_hash(skb,\n\t\t\t\t\t     le32_to_cpu(rcd->rssHash),\n\t\t\t\t\t     hash_type);\n\t\t\t}\n#endif\n\t\t\tvmxnet3_rx_csum(adapter, skb,\n\t\t\t\t\t(union Vmxnet3_GenericDesc *)rcd);\n\t\t\tskb->protocol = eth_type_trans(skb, adapter->netdev);\n\t\t\tif ((!rcd->tcp && !encap_lro) ||\n\t\t\t    !(adapter->netdev->features & NETIF_F_LRO))\n\t\t\t\tgoto not_lro;\n\n\t\t\tif (segCnt != 0 && mss != 0) {\n\t\t\t\tskb_shinfo(skb)->gso_type = rcd->v4 ?\n\t\t\t\t\tSKB_GSO_TCPV4 : SKB_GSO_TCPV6;\n\t\t\t\tskb_shinfo(skb)->gso_size = mss;\n\t\t\t\tskb_shinfo(skb)->gso_segs = segCnt;\n\t\t\t} else if ((segCnt != 0 || skb->len > mtu) && !encap_lro) {\n\t\t\t\tu32 hlen;\n\n\t\t\t\thlen = vmxnet3_get_hdr_len(adapter, skb,\n\t\t\t\t\t(union Vmxnet3_GenericDesc *)rcd);\n\t\t\t\tif (hlen == 0)\n\t\t\t\t\tgoto not_lro;\n\n\t\t\t\tskb_shinfo(skb)->gso_type =\n\t\t\t\t\trcd->v4 ? SKB_GSO_TCPV4 : SKB_GSO_TCPV6;\n\t\t\t\tif (segCnt != 0) {\n\t\t\t\t\tskb_shinfo(skb)->gso_segs = segCnt;\n\t\t\t\t\tskb_shinfo(skb)->gso_size =\n\t\t\t\t\t\tDIV_ROUND_UP(skb->len -\n\t\t\t\t\t\t\thlen, segCnt);\n\t\t\t\t} else {\n\t\t\t\t\tskb_shinfo(skb)->gso_size = mtu - hlen;\n\t\t\t\t}\n\t\t\t}\nnot_lro:\n\t\t\tif (unlikely(rcd->ts))\n\t\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), rcd->tci);\n\n\t\t\t \n\t\t\tif ((adapter->netdev->features & NETIF_F_LRO) &&\n\t\t\t    !rq->shared->updateRxProd)\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\telse\n\t\t\t\tnapi_gro_receive(&rq->napi, skb);\n\n\t\t\tctx->skb = NULL;\n\t\t\tencap_lro = false;\n\t\t\tnum_pkts++;\n\t\t}\n\nrcd_done:\n\t\t \n\t\tring = rq->rx_ring + ring_idx;\n\t\trbi->comp_state = VMXNET3_RXD_COMP_DONE;\n\n\t\tcomp_offset = vmxnet3_cmd_ring_desc_avail(ring);\n\t\tfill_offset = (idx > ring->next2fill ? 0 : ring->size) +\n\t\t\t      idx - ring->next2fill - 1;\n\t\tif (!ring->isOutOfOrder || fill_offset >= comp_offset)\n\t\t\tring->next2comp = idx;\n\t\tnum_to_alloc = vmxnet3_cmd_ring_desc_avail(ring);\n\n\t\t \n\t\tdma_wmb();\n\n\t\twhile (num_to_alloc) {\n\t\t\trbi = rq->buf_info[ring_idx] + ring->next2fill;\n\t\t\tif (!(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_OOORX_COMP)))\n\t\t\t\tgoto refill_buf;\n\t\t\tif (ring_idx == 0) {\n\t\t\t\t \n\t\t\t\tif (rbi->buf_type != VMXNET3_RX_BUF_SKB)\n\t\t\t\t\tgoto refill_buf;\n\t\t\t}\n\t\t\tif (rbi->comp_state == VMXNET3_RXD_COMP_DONE) {\nrefill_buf:\n\t\t\t\tvmxnet3_getRxDesc(rxd, &ring->base[ring->next2fill].rxd,\n\t\t\t\t\t\t  &rxCmdDesc);\n\t\t\t\tWARN_ON(!rxd->addr);\n\n\t\t\t\t \n\t\t\t\trxd->gen = ring->gen;\n\t\t\t\tvmxnet3_cmd_ring_adv_next2fill(ring);\n\t\t\t\trbi->comp_state = VMXNET3_RXD_COMP_PENDING;\n\t\t\t\tnum_to_alloc--;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tring->isOutOfOrder = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (num_to_alloc == 0) {\n\t\t\tring->isOutOfOrder = 0;\n\t\t}\n\n\t\t \n\t\tif (unlikely(rq->shared->updateRxProd) && (ring->next2fill & 0xf) == 0) {\n\t\t\tVMXNET3_WRITE_BAR0_REG(adapter,\n\t\t\t\t\t       rxprod_reg[ring_idx] + rq->qid * 8,\n\t\t\t\t\t       ring->next2fill);\n\t\t}\n\n\t\tvmxnet3_comp_ring_adv_next2proc(&rq->comp_ring);\n\t\tvmxnet3_getRxComp(rcd,\n\t\t\t\t  &rq->comp_ring.base[rq->comp_ring.next2proc].rcd, &rxComp);\n\t}\n\tif (need_flush)\n\t\txdp_do_flush();\n\n\treturn num_pkts;\n}\n\n\nstatic void\nvmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tu32 i, ring_idx;\n\tstruct Vmxnet3_RxDesc *rxd;\n\n\t \n\tif (!rq->rx_ring[0].base)\n\t\treturn;\n\n\tfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\n\t\tfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\n\t\t\tstruct vmxnet3_rx_buf_info *rbi;\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\t\tstruct Vmxnet3_RxDesc rxDesc;\n#endif\n\n\t\t\trbi = &rq->buf_info[ring_idx][i];\n\t\t\tvmxnet3_getRxDesc(rxd,\n\t\t\t\t&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\n\n\t\t\tif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t    rbi->page && rbi->buf_type == VMXNET3_RX_BUF_XDP) {\n\t\t\t\tpage_pool_recycle_direct(rq->page_pool,\n\t\t\t\t\t\t\t rbi->page);\n\t\t\t\trbi->page = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t\t   rbi->skb) {\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t\t rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(rbi->skb);\n\t\t\t\trbi->skb = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\n\t\t\t\t   rbi->page) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t       rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tput_page(rbi->page);\n\t\t\t\trbi->page = NULL;\n\t\t\t}\n\t\t}\n\n\t\trq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[ring_idx].next2fill =\n\t\t\t\t\trq->rx_ring[ring_idx].next2comp = 0;\n\t}\n\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\trq->comp_ring.next2proc = 0;\n}\n\n\nstatic void\nvmxnet3_rq_cleanup_all(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tvmxnet3_rq_cleanup(&adapter->rx_queue[i], adapter);\n\trcu_assign_pointer(adapter->xdp_bpf_prog, NULL);\n}\n\n\nstatic void vmxnet3_rq_destroy(struct vmxnet3_rx_queue *rq,\n\t\t\t       struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\tint j;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (rq->buf_info[i]) {\n\t\t\tfor (j = 0; j < rq->rx_ring[i].size; j++)\n\t\t\t\tBUG_ON(rq->buf_info[i][j].page != NULL);\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (rq->rx_ring[i].base) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  rq->rx_ring[i].size\n\t\t\t\t\t  * sizeof(struct Vmxnet3_RxDesc),\n\t\t\t\t\t  rq->rx_ring[i].base,\n\t\t\t\t\t  rq->rx_ring[i].basePA);\n\t\t\trq->rx_ring[i].base = NULL;\n\t\t}\n\t}\n\n\tif (xdp_rxq_info_is_reg(&rq->xdp_rxq))\n\t\txdp_rxq_info_unreg(&rq->xdp_rxq);\n\tpage_pool_destroy(rq->page_pool);\n\trq->page_pool = NULL;\n\n\tif (rq->data_ring.base) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  rq->rx_ring[0].size * rq->data_ring.desc_size,\n\t\t\t\t  rq->data_ring.base, rq->data_ring.basePA);\n\t\trq->data_ring.base = NULL;\n\t}\n\n\tif (rq->comp_ring.base) {\n\t\tdma_free_coherent(&adapter->pdev->dev, rq->comp_ring.size\n\t\t\t\t  * sizeof(struct Vmxnet3_RxCompDesc),\n\t\t\t\t  rq->comp_ring.base, rq->comp_ring.basePA);\n\t\trq->comp_ring.base = NULL;\n\t}\n\n\tkfree(rq->buf_info[0]);\n\trq->buf_info[0] = NULL;\n\trq->buf_info[1] = NULL;\n}\n\nstatic void\nvmxnet3_rq_destroy_all_rxdataring(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\n\n\t\tif (rq->data_ring.base) {\n\t\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t\t  (rq->rx_ring[0].size *\n\t\t\t\t\t  rq->data_ring.desc_size),\n\t\t\t\t\t  rq->data_ring.base,\n\t\t\t\t\t  rq->data_ring.basePA);\n\t\t\trq->data_ring.base = NULL;\n\t\t\trq->data_ring.desc_size = 0;\n\t\t}\n\t}\n}\n\nstatic int\nvmxnet3_rq_init(struct vmxnet3_rx_queue *rq,\n\t\tstruct vmxnet3_adapter  *adapter)\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < rq->rx_ring[0].size; i++) {\n\n\t\t \n\t\tif (i % adapter->rx_buf_per_pkt == 0) {\n\t\t\trq->buf_info[0][i].buf_type = vmxnet3_xdp_enabled(adapter) ?\n\t\t\t\t\t\t      VMXNET3_RX_BUF_XDP :\n\t\t\t\t\t\t      VMXNET3_RX_BUF_SKB;\n\t\t\trq->buf_info[0][i].len = adapter->skb_buf_size;\n\t\t} else {  \n\t\t\trq->buf_info[0][i].buf_type = VMXNET3_RX_BUF_PAGE;\n\t\t\trq->buf_info[0][i].len = PAGE_SIZE;\n\t\t}\n\t}\n\tfor (i = 0; i < rq->rx_ring[1].size; i++) {\n\t\trq->buf_info[1][i].buf_type = VMXNET3_RX_BUF_PAGE;\n\t\trq->buf_info[1][i].len = PAGE_SIZE;\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\trq->rx_ring[i].next2fill = rq->rx_ring[i].next2comp = 0;\n\n\t\tmemset(rq->rx_ring[i].base, 0, rq->rx_ring[i].size *\n\t\t       sizeof(struct Vmxnet3_RxDesc));\n\t\trq->rx_ring[i].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[i].isOutOfOrder = 0;\n\t}\n\n\terr = vmxnet3_create_pp(adapter, rq,\n\t\t\t\trq->rx_ring[0].size + rq->rx_ring[1].size);\n\tif (err)\n\t\treturn err;\n\n\tif (vmxnet3_rq_alloc_rx_buf(rq, 0, rq->rx_ring[0].size - 1,\n\t\t\t\t    adapter) == 0) {\n\t\txdp_rxq_info_unreg(&rq->xdp_rxq);\n\t\tpage_pool_destroy(rq->page_pool);\n\t\trq->page_pool = NULL;\n\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\tvmxnet3_rq_alloc_rx_buf(rq, 1, rq->rx_ring[1].size - 1, adapter);\n\n\t \n\trq->comp_ring.next2proc = 0;\n\tmemset(rq->comp_ring.base, 0, rq->comp_ring.size *\n\t       sizeof(struct Vmxnet3_RxCompDesc));\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\n\t \n\trq->rx_ctx.skb = NULL;\n\n\t \n\treturn 0;\n}\n\n\nstatic int\nvmxnet3_rq_init_all(struct vmxnet3_adapter *adapter)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\terr = vmxnet3_rq_init(&adapter->rx_queue[i], adapter);\n\t\tif (unlikely(err)) {\n\t\t\tdev_err(&adapter->netdev->dev, \"%s: failed to \"\n\t\t\t\t\"initialize rx queue%i\\n\",\n\t\t\t\tadapter->netdev->name, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n\n}\n\n\nstatic int\nvmxnet3_rq_create(struct vmxnet3_rx_queue *rq, struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\tsize_t sz;\n\tstruct vmxnet3_rx_buf_info *bi;\n\n\tfor (i = 0; i < 2; i++) {\n\n\t\tsz = rq->rx_ring[i].size * sizeof(struct Vmxnet3_RxDesc);\n\t\trq->rx_ring[i].base = dma_alloc_coherent(\n\t\t\t\t\t\t&adapter->pdev->dev, sz,\n\t\t\t\t\t\t&rq->rx_ring[i].basePA,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!rq->rx_ring[i].base) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"failed to allocate rx ring %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif ((adapter->rxdataring_enabled) && (rq->data_ring.desc_size != 0)) {\n\t\tsz = rq->rx_ring[0].size * rq->data_ring.desc_size;\n\t\trq->data_ring.base =\n\t\t\tdma_alloc_coherent(&adapter->pdev->dev, sz,\n\t\t\t\t\t   &rq->data_ring.basePA,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!rq->data_ring.base) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"rx data ring will be disabled\\n\");\n\t\t\tadapter->rxdataring_enabled = false;\n\t\t}\n\t} else {\n\t\trq->data_ring.base = NULL;\n\t\trq->data_ring.desc_size = 0;\n\t}\n\n\tsz = rq->comp_ring.size * sizeof(struct Vmxnet3_RxCompDesc);\n\trq->comp_ring.base = dma_alloc_coherent(&adapter->pdev->dev, sz,\n\t\t\t\t\t\t&rq->comp_ring.basePA,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!rq->comp_ring.base) {\n\t\tnetdev_err(adapter->netdev, \"failed to allocate rx comp ring\\n\");\n\t\tgoto err;\n\t}\n\n\tbi = kcalloc_node(rq->rx_ring[0].size + rq->rx_ring[1].size,\n\t\t\t  sizeof(rq->buf_info[0][0]), GFP_KERNEL,\n\t\t\t  dev_to_node(&adapter->pdev->dev));\n\tif (!bi)\n\t\tgoto err;\n\n\trq->buf_info[0] = bi;\n\trq->buf_info[1] = bi + rq->rx_ring[0].size;\n\n\treturn 0;\n\nerr:\n\tvmxnet3_rq_destroy(rq, adapter);\n\treturn -ENOMEM;\n}\n\n\nint\nvmxnet3_rq_create_all(struct vmxnet3_adapter *adapter)\n{\n\tint i, err = 0;\n\n\tadapter->rxdataring_enabled = VMXNET3_VERSION_GE_3(adapter);\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\terr = vmxnet3_rq_create(&adapter->rx_queue[i], adapter);\n\t\tif (unlikely(err)) {\n\t\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t\"%s: failed to create rx queue%i\\n\",\n\t\t\t\tadapter->netdev->name, i);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (!adapter->rxdataring_enabled)\n\t\tvmxnet3_rq_destroy_all_rxdataring(adapter);\n\n\treturn err;\nerr_out:\n\tvmxnet3_rq_destroy_all(adapter);\n\treturn err;\n\n}\n\n \n\nstatic int\nvmxnet3_do_poll(struct vmxnet3_adapter *adapter, int budget)\n{\n\tint rcd_done = 0, i;\n\tif (unlikely(adapter->shared->ecr))\n\t\tvmxnet3_process_events(adapter);\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tvmxnet3_tq_tx_complete(&adapter->tx_queue[i], adapter);\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\trcd_done += vmxnet3_rq_rx_complete(&adapter->rx_queue[i],\n\t\t\t\t\t\t   adapter, budget);\n\treturn rcd_done;\n}\n\n\nstatic int\nvmxnet3_poll(struct napi_struct *napi, int budget)\n{\n\tstruct vmxnet3_rx_queue *rx_queue = container_of(napi,\n\t\t\t\t\t  struct vmxnet3_rx_queue, napi);\n\tint rxd_done;\n\n\trxd_done = vmxnet3_do_poll(rx_queue->adapter, budget);\n\n\tif (rxd_done < budget) {\n\t\tnapi_complete_done(napi, rxd_done);\n\t\tvmxnet3_enable_all_intrs(rx_queue->adapter);\n\t}\n\treturn rxd_done;\n}\n\n \n\nstatic int\nvmxnet3_poll_rx_only(struct napi_struct *napi, int budget)\n{\n\tstruct vmxnet3_rx_queue *rq = container_of(napi,\n\t\t\t\t\t\tstruct vmxnet3_rx_queue, napi);\n\tstruct vmxnet3_adapter *adapter = rq->adapter;\n\tint rxd_done;\n\n\t \n\tif (adapter->share_intr == VMXNET3_INTR_BUDDYSHARE) {\n\t\tstruct vmxnet3_tx_queue *tq =\n\t\t\t\t&adapter->tx_queue[rq - adapter->rx_queue];\n\t\tvmxnet3_tq_tx_complete(tq, adapter);\n\t}\n\n\trxd_done = vmxnet3_rq_rx_complete(rq, adapter, budget);\n\n\tif (rxd_done < budget) {\n\t\tnapi_complete_done(napi, rxd_done);\n\t\tvmxnet3_enable_intr(adapter, rq->comp_ring.intr_idx);\n\t}\n\treturn rxd_done;\n}\n\n\n#ifdef CONFIG_PCI_MSI\n\n \n\nstatic irqreturn_t\nvmxnet3_msix_tx(int irq, void *data)\n{\n\tstruct vmxnet3_tx_queue *tq = data;\n\tstruct vmxnet3_adapter *adapter = tq->adapter;\n\n\tif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\n\t\tvmxnet3_disable_intr(adapter, tq->comp_ring.intr_idx);\n\n\t \n\tif (adapter->share_intr == VMXNET3_INTR_TXSHARE) {\n\t\tint i;\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tstruct vmxnet3_tx_queue *txq = &adapter->tx_queue[i];\n\t\t\tvmxnet3_tq_tx_complete(txq, adapter);\n\t\t}\n\t} else {\n\t\tvmxnet3_tq_tx_complete(tq, adapter);\n\t}\n\tvmxnet3_enable_intr(adapter, tq->comp_ring.intr_idx);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic irqreturn_t\nvmxnet3_msix_rx(int irq, void *data)\n{\n\tstruct vmxnet3_rx_queue *rq = data;\n\tstruct vmxnet3_adapter *adapter = rq->adapter;\n\n\t \n\tif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\n\t\tvmxnet3_disable_intr(adapter, rq->comp_ring.intr_idx);\n\tnapi_schedule(&rq->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic irqreturn_t\nvmxnet3_msix_event(int irq, void *data)\n{\n\tstruct net_device *dev = data;\n\tstruct vmxnet3_adapter *adapter = netdev_priv(dev);\n\n\t \n\tif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\n\t\tvmxnet3_disable_intr(adapter, adapter->intr.event_intr_idx);\n\n\tif (adapter->shared->ecr)\n\t\tvmxnet3_process_events(adapter);\n\n\tvmxnet3_enable_intr(adapter, adapter->intr.event_intr_idx);\n\n\treturn IRQ_HANDLED;\n}\n\n#endif  \n\n\n \nstatic irqreturn_t\nvmxnet3_intr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct vmxnet3_adapter *adapter = netdev_priv(dev);\n\n\tif (adapter->intr.type == VMXNET3_IT_INTX) {\n\t\tu32 icr = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_ICR);\n\t\tif (unlikely(icr == 0))\n\t\t\t \n\t\t\treturn IRQ_NONE;\n\t}\n\n\n\t \n\tif (adapter->intr.mask_mode == VMXNET3_IMM_ACTIVE)\n\t\tvmxnet3_disable_all_intrs(adapter);\n\n\tnapi_schedule(&adapter->rx_queue[0].napi);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\n \nstatic void\nvmxnet3_netpoll(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (adapter->intr.type) {\n#ifdef CONFIG_PCI_MSI\n\tcase VMXNET3_IT_MSIX: {\n\t\tint i;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\t\tvmxnet3_msix_rx(0, &adapter->rx_queue[i]);\n\t\tbreak;\n\t}\n#endif\n\tcase VMXNET3_IT_MSI:\n\tdefault:\n\t\tvmxnet3_intr(0, adapter->netdev);\n\t\tbreak;\n\t}\n\n}\n#endif\t \n\nstatic int\nvmxnet3_request_irqs(struct vmxnet3_adapter *adapter)\n{\n\tstruct vmxnet3_intr *intr = &adapter->intr;\n\tint err = 0, i;\n\tint vector = 0;\n\n#ifdef CONFIG_PCI_MSI\n\tif (adapter->intr.type == VMXNET3_IT_MSIX) {\n\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\tif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE) {\n\t\t\t\tsprintf(adapter->tx_queue[i].name, \"%s-tx-%d\",\n\t\t\t\t\tadapter->netdev->name, vector);\n\t\t\t\terr = request_irq(\n\t\t\t\t\t      intr->msix_entries[vector].vector,\n\t\t\t\t\t      vmxnet3_msix_tx, 0,\n\t\t\t\t\t      adapter->tx_queue[i].name,\n\t\t\t\t\t      &adapter->tx_queue[i]);\n\t\t\t} else {\n\t\t\t\tsprintf(adapter->tx_queue[i].name, \"%s-rxtx-%d\",\n\t\t\t\t\tadapter->netdev->name, vector);\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\t\t\"Failed to request irq for MSIX, %s, \"\n\t\t\t\t\t\"error %d\\n\",\n\t\t\t\t\tadapter->tx_queue[i].name, err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (adapter->share_intr == VMXNET3_INTR_TXSHARE) {\n\t\t\t\tfor (; i < adapter->num_tx_queues; i++)\n\t\t\t\t\tadapter->tx_queue[i].comp_ring.intr_idx\n\t\t\t\t\t\t\t\t= vector;\n\t\t\t\tvector++;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tadapter->tx_queue[i].comp_ring.intr_idx\n\t\t\t\t\t\t\t\t= vector++;\n\t\t\t}\n\t\t}\n\t\tif (adapter->share_intr == VMXNET3_INTR_BUDDYSHARE)\n\t\t\tvector = 0;\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE)\n\t\t\t\tsprintf(adapter->rx_queue[i].name, \"%s-rx-%d\",\n\t\t\t\t\tadapter->netdev->name, vector);\n\t\t\telse\n\t\t\t\tsprintf(adapter->rx_queue[i].name, \"%s-rxtx-%d\",\n\t\t\t\t\tadapter->netdev->name, vector);\n\t\t\terr = request_irq(intr->msix_entries[vector].vector,\n\t\t\t\t\t  vmxnet3_msix_rx, 0,\n\t\t\t\t\t  adapter->rx_queue[i].name,\n\t\t\t\t\t  &(adapter->rx_queue[i]));\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t\t   \"Failed to request irq for MSIX, \"\n\t\t\t\t\t   \"%s, error %d\\n\",\n\t\t\t\t\t   adapter->rx_queue[i].name, err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tadapter->rx_queue[i].comp_ring.intr_idx = vector++;\n\t\t}\n\n\t\tsprintf(intr->event_msi_vector_name, \"%s-event-%d\",\n\t\t\tadapter->netdev->name, vector);\n\t\terr = request_irq(intr->msix_entries[vector].vector,\n\t\t\t\t  vmxnet3_msix_event, 0,\n\t\t\t\t  intr->event_msi_vector_name, adapter->netdev);\n\t\tintr->event_intr_idx = vector;\n\n\t} else if (intr->type == VMXNET3_IT_MSI) {\n\t\tadapter->num_rx_queues = 1;\n\t\terr = request_irq(adapter->pdev->irq, vmxnet3_intr, 0,\n\t\t\t\t  adapter->netdev->name, adapter->netdev);\n\t} else {\n#endif\n\t\tadapter->num_rx_queues = 1;\n\t\terr = request_irq(adapter->pdev->irq, vmxnet3_intr,\n\t\t\t\t  IRQF_SHARED, adapter->netdev->name,\n\t\t\t\t  adapter->netdev);\n#ifdef CONFIG_PCI_MSI\n\t}\n#endif\n\tintr->num_intrs = vector + 1;\n\tif (err) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to request irq (intr type:%d), error %d\\n\",\n\t\t\t   intr->type, err);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\n\t\t\trq->qid = i;\n\t\t\trq->qid2 = i + adapter->num_rx_queues;\n\t\t\trq->dataRingQid = i + 2 * adapter->num_rx_queues;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < intr->num_intrs; i++)\n\t\t\tintr->mod_levels[i] = UPT1_IML_ADAPTIVE;\n\t\tif (adapter->intr.type != VMXNET3_IT_MSIX) {\n\t\t\tadapter->intr.event_intr_idx = 0;\n\t\t\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\t\t\tadapter->tx_queue[i].comp_ring.intr_idx = 0;\n\t\t\tadapter->rx_queue[0].comp_ring.intr_idx = 0;\n\t\t}\n\n\t\tnetdev_info(adapter->netdev,\n\t\t\t    \"intr type %u, mode %u, %u vectors allocated\\n\",\n\t\t\t    intr->type, intr->mask_mode, intr->num_intrs);\n\t}\n\n\treturn err;\n}\n\n\nstatic void\nvmxnet3_free_irqs(struct vmxnet3_adapter *adapter)\n{\n\tstruct vmxnet3_intr *intr = &adapter->intr;\n\tBUG_ON(intr->type == VMXNET3_IT_AUTO || intr->num_intrs <= 0);\n\n\tswitch (intr->type) {\n#ifdef CONFIG_PCI_MSI\n\tcase VMXNET3_IT_MSIX:\n\t{\n\t\tint i, vector = 0;\n\n\t\tif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE) {\n\t\t\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\t\t\tfree_irq(intr->msix_entries[vector++].vector,\n\t\t\t\t\t &(adapter->tx_queue[i]));\n\t\t\t\tif (adapter->share_intr == VMXNET3_INTR_TXSHARE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tfree_irq(intr->msix_entries[vector++].vector,\n\t\t\t\t &(adapter->rx_queue[i]));\n\t\t}\n\n\t\tfree_irq(intr->msix_entries[vector].vector,\n\t\t\t adapter->netdev);\n\t\tBUG_ON(vector >= intr->num_intrs);\n\t\tbreak;\n\t}\n#endif\n\tcase VMXNET3_IT_MSI:\n\t\tfree_irq(adapter->pdev->irq, adapter->netdev);\n\t\tbreak;\n\tcase VMXNET3_IT_INTX:\n\t\tfree_irq(adapter->pdev->irq, adapter->netdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n\nstatic void\nvmxnet3_restore_vlan(struct vmxnet3_adapter *adapter)\n{\n\tu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\n\tu16 vid;\n\n\t \n\tVMXNET3_SET_VFTABLE_ENTRY(vfTable, 0);\n\n\tfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\n\t\tVMXNET3_SET_VFTABLE_ENTRY(vfTable, vid);\n}\n\n\nstatic int\nvmxnet3_vlan_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (!(netdev->flags & IFF_PROMISC)) {\n\t\tu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\n\t\tunsigned long flags;\n\n\t\tVMXNET3_SET_VFTABLE_ENTRY(vfTable, vid);\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_UPDATE_VLAN_FILTERS);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t}\n\n\tset_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\n\nstatic int\nvmxnet3_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (!(netdev->flags & IFF_PROMISC)) {\n\t\tu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\n\t\tunsigned long flags;\n\n\t\tVMXNET3_CLEAR_VFTABLE_ENTRY(vfTable, vid);\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_UPDATE_VLAN_FILTERS);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t}\n\n\tclear_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\n\nstatic u8 *\nvmxnet3_copy_mc(struct net_device *netdev)\n{\n\tu8 *buf = NULL;\n\tu32 sz = netdev_mc_count(netdev) * ETH_ALEN;\n\n\t \n\tif (sz <= 0xffff) {\n\t\t \n\t\tbuf = kmalloc(sz, GFP_ATOMIC);\n\t\tif (buf) {\n\t\t\tstruct netdev_hw_addr *ha;\n\t\t\tint i = 0;\n\n\t\t\tnetdev_for_each_mc_addr(ha, netdev)\n\t\t\t\tmemcpy(buf + i++ * ETH_ALEN, ha->addr,\n\t\t\t\t       ETH_ALEN);\n\t\t}\n\t}\n\treturn buf;\n}\n\n\nstatic void\nvmxnet3_set_mc(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tunsigned long flags;\n\tstruct Vmxnet3_RxFilterConf *rxConf =\n\t\t\t\t\t&adapter->shared->devRead.rxFilterConf;\n\tu8 *new_table = NULL;\n\tdma_addr_t new_table_pa = 0;\n\tbool new_table_pa_valid = false;\n\tu32 new_mode = VMXNET3_RXM_UCAST;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tu32 *vfTable = adapter->shared->devRead.rxFilterConf.vfTable;\n\t\tmemset(vfTable, 0, VMXNET3_VFT_SIZE * sizeof(*vfTable));\n\n\t\tnew_mode |= VMXNET3_RXM_PROMISC;\n\t} else {\n\t\tvmxnet3_restore_vlan(adapter);\n\t}\n\n\tif (netdev->flags & IFF_BROADCAST)\n\t\tnew_mode |= VMXNET3_RXM_BCAST;\n\n\tif (netdev->flags & IFF_ALLMULTI)\n\t\tnew_mode |= VMXNET3_RXM_ALL_MULTI;\n\telse\n\t\tif (!netdev_mc_empty(netdev)) {\n\t\t\tnew_table = vmxnet3_copy_mc(netdev);\n\t\t\tif (new_table) {\n\t\t\t\tsize_t sz = netdev_mc_count(netdev) * ETH_ALEN;\n\n\t\t\t\trxConf->mfTableLen = cpu_to_le16(sz);\n\t\t\t\tnew_table_pa = dma_map_single(\n\t\t\t\t\t\t\t&adapter->pdev->dev,\n\t\t\t\t\t\t\tnew_table,\n\t\t\t\t\t\t\tsz,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\t\tif (!dma_mapping_error(&adapter->pdev->dev,\n\t\t\t\t\t\t       new_table_pa)) {\n\t\t\t\t\tnew_mode |= VMXNET3_RXM_MCAST;\n\t\t\t\t\tnew_table_pa_valid = true;\n\t\t\t\t\trxConf->mfTablePA = cpu_to_le64(\n\t\t\t\t\t\t\t\tnew_table_pa);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!new_table_pa_valid) {\n\t\t\t\tnetdev_info(netdev,\n\t\t\t\t\t    \"failed to copy mcast list, setting ALL_MULTI\\n\");\n\t\t\t\tnew_mode |= VMXNET3_RXM_ALL_MULTI;\n\t\t\t}\n\t\t}\n\n\tif (!(new_mode & VMXNET3_RXM_MCAST)) {\n\t\trxConf->mfTableLen = 0;\n\t\trxConf->mfTablePA = 0;\n\t}\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tif (new_mode != rxConf->rxMode) {\n\t\trxConf->rxMode = cpu_to_le32(new_mode);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_UPDATE_RX_MODE);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_UPDATE_VLAN_FILTERS);\n\t}\n\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_UPDATE_MAC_FILTERS);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\tif (new_table_pa_valid)\n\t\tdma_unmap_single(&adapter->pdev->dev, new_table_pa,\n\t\t\t\t rxConf->mfTableLen, DMA_TO_DEVICE);\n\tkfree(new_table);\n}\n\nvoid\nvmxnet3_rq_destroy_all(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tvmxnet3_rq_destroy(&adapter->rx_queue[i], adapter);\n}\n\n\n \n\nstatic void\nvmxnet3_setup_driver_shared(struct vmxnet3_adapter *adapter)\n{\n\tstruct Vmxnet3_DriverShared *shared = adapter->shared;\n\tstruct Vmxnet3_DSDevRead *devRead = &shared->devRead;\n\tstruct Vmxnet3_DSDevReadExt *devReadExt = &shared->devReadExt;\n\tstruct Vmxnet3_TxQueueConf *tqc;\n\tstruct Vmxnet3_RxQueueConf *rqc;\n\tint i;\n\n\tmemset(shared, 0, sizeof(*shared));\n\n\t \n\tshared->magic = cpu_to_le32(VMXNET3_REV1_MAGIC);\n\tdevRead->misc.driverInfo.version = cpu_to_le32(\n\t\t\t\t\t\tVMXNET3_DRIVER_VERSION_NUM);\n\tdevRead->misc.driverInfo.gos.gosBits = (sizeof(void *) == 4 ?\n\t\t\t\tVMXNET3_GOS_BITS_32 : VMXNET3_GOS_BITS_64);\n\tdevRead->misc.driverInfo.gos.gosType = VMXNET3_GOS_TYPE_LINUX;\n\t*((u32 *)&devRead->misc.driverInfo.gos) = cpu_to_le32(\n\t\t\t\t*((u32 *)&devRead->misc.driverInfo.gos));\n\tdevRead->misc.driverInfo.vmxnet3RevSpt = cpu_to_le32(1);\n\tdevRead->misc.driverInfo.uptVerSpt = cpu_to_le32(1);\n\n\tdevRead->misc.ddPA = cpu_to_le64(adapter->adapter_pa);\n\tdevRead->misc.ddLen = cpu_to_le32(sizeof(struct vmxnet3_adapter));\n\n\t \n\tif (adapter->netdev->features & NETIF_F_RXCSUM)\n\t\tdevRead->misc.uptFeatures |= UPT1_F_RXCSUM;\n\n\tif (adapter->netdev->features & NETIF_F_LRO) {\n\t\tdevRead->misc.uptFeatures |= UPT1_F_LRO;\n\t\tdevRead->misc.maxNumRxSG = cpu_to_le16(1 + MAX_SKB_FRAGS);\n\t}\n\tif (adapter->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tdevRead->misc.uptFeatures |= UPT1_F_RXVLAN;\n\n\tif (adapter->netdev->features & (NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t NETIF_F_GSO_UDP_TUNNEL_CSUM))\n\t\tdevRead->misc.uptFeatures |= UPT1_F_RXINNEROFLD;\n\n\tdevRead->misc.mtu = cpu_to_le32(adapter->netdev->mtu);\n\tdevRead->misc.queueDescPA = cpu_to_le64(adapter->queue_desc_pa);\n\tdevRead->misc.queueDescLen = cpu_to_le32(\n\t\tadapter->num_tx_queues * sizeof(struct Vmxnet3_TxQueueDesc) +\n\t\tadapter->num_rx_queues * sizeof(struct Vmxnet3_RxQueueDesc));\n\n\t \n\tdevRead->misc.numTxQueues =  adapter->num_tx_queues;\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct vmxnet3_tx_queue\t*tq = &adapter->tx_queue[i];\n\t\tBUG_ON(adapter->tx_queue[i].tx_ring.base == NULL);\n\t\ttqc = &adapter->tqd_start[i].conf;\n\t\ttqc->txRingBasePA   = cpu_to_le64(tq->tx_ring.basePA);\n\t\ttqc->dataRingBasePA = cpu_to_le64(tq->data_ring.basePA);\n\t\ttqc->compRingBasePA = cpu_to_le64(tq->comp_ring.basePA);\n\t\ttqc->ddPA           = cpu_to_le64(~0ULL);\n\t\ttqc->txRingSize     = cpu_to_le32(tq->tx_ring.size);\n\t\ttqc->dataRingSize   = cpu_to_le32(tq->data_ring.size);\n\t\ttqc->txDataRingDescSize = cpu_to_le32(tq->txdata_desc_size);\n\t\ttqc->compRingSize   = cpu_to_le32(tq->comp_ring.size);\n\t\ttqc->ddLen          = cpu_to_le32(0);\n\t\ttqc->intrIdx        = tq->comp_ring.intr_idx;\n\t}\n\n\t \n\tdevRead->misc.numRxQueues = adapter->num_rx_queues;\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct vmxnet3_rx_queue\t*rq = &adapter->rx_queue[i];\n\t\trqc = &adapter->rqd_start[i].conf;\n\t\trqc->rxRingBasePA[0] = cpu_to_le64(rq->rx_ring[0].basePA);\n\t\trqc->rxRingBasePA[1] = cpu_to_le64(rq->rx_ring[1].basePA);\n\t\trqc->compRingBasePA  = cpu_to_le64(rq->comp_ring.basePA);\n\t\trqc->ddPA            = cpu_to_le64(~0ULL);\n\t\trqc->rxRingSize[0]   = cpu_to_le32(rq->rx_ring[0].size);\n\t\trqc->rxRingSize[1]   = cpu_to_le32(rq->rx_ring[1].size);\n\t\trqc->compRingSize    = cpu_to_le32(rq->comp_ring.size);\n\t\trqc->ddLen           = cpu_to_le32(0);\n\t\trqc->intrIdx         = rq->comp_ring.intr_idx;\n\t\tif (VMXNET3_VERSION_GE_3(adapter)) {\n\t\t\trqc->rxDataRingBasePA =\n\t\t\t\tcpu_to_le64(rq->data_ring.basePA);\n\t\t\trqc->rxDataRingDescSize =\n\t\t\t\tcpu_to_le16(rq->data_ring.desc_size);\n\t\t}\n\t}\n\n#ifdef VMXNET3_RSS\n\tmemset(adapter->rss_conf, 0, sizeof(*adapter->rss_conf));\n\n\tif (adapter->rss) {\n\t\tstruct UPT1_RSSConf *rssConf = adapter->rss_conf;\n\n\t\tdevRead->misc.uptFeatures |= UPT1_F_RSS;\n\t\tdevRead->misc.numRxQueues = adapter->num_rx_queues;\n\t\trssConf->hashType = UPT1_RSS_HASH_TYPE_TCP_IPV4 |\n\t\t\t\t    UPT1_RSS_HASH_TYPE_IPV4 |\n\t\t\t\t    UPT1_RSS_HASH_TYPE_TCP_IPV6 |\n\t\t\t\t    UPT1_RSS_HASH_TYPE_IPV6;\n\t\trssConf->hashFunc = UPT1_RSS_HASH_FUNC_TOEPLITZ;\n\t\trssConf->hashKeySize = UPT1_RSS_MAX_KEY_SIZE;\n\t\trssConf->indTableSize = VMXNET3_RSS_IND_TABLE_SIZE;\n\t\tnetdev_rss_key_fill(rssConf->hashKey, sizeof(rssConf->hashKey));\n\n\t\tfor (i = 0; i < rssConf->indTableSize; i++)\n\t\t\trssConf->indTable[i] = ethtool_rxfh_indir_default(\n\t\t\t\ti, adapter->num_rx_queues);\n\n\t\tdevRead->rssConfDesc.confVer = 1;\n\t\tdevRead->rssConfDesc.confLen = cpu_to_le32(sizeof(*rssConf));\n\t\tdevRead->rssConfDesc.confPA =\n\t\t\tcpu_to_le64(adapter->rss_conf_pa);\n\t}\n\n#endif  \n\n\t \n\tif (!VMXNET3_VERSION_GE_6(adapter) ||\n\t    !adapter->queuesExtEnabled) {\n\t\tdevRead->intrConf.autoMask = adapter->intr.mask_mode ==\n\t\t\t\t\t     VMXNET3_IMM_AUTO;\n\t\tdevRead->intrConf.numIntrs = adapter->intr.num_intrs;\n\t\tfor (i = 0; i < adapter->intr.num_intrs; i++)\n\t\t\tdevRead->intrConf.modLevels[i] = adapter->intr.mod_levels[i];\n\n\t\tdevRead->intrConf.eventIntrIdx = adapter->intr.event_intr_idx;\n\t\tdevRead->intrConf.intrCtrl |= cpu_to_le32(VMXNET3_IC_DISABLE_ALL);\n\t} else {\n\t\tdevReadExt->intrConfExt.autoMask = adapter->intr.mask_mode ==\n\t\t\t\t\t\t   VMXNET3_IMM_AUTO;\n\t\tdevReadExt->intrConfExt.numIntrs = adapter->intr.num_intrs;\n\t\tfor (i = 0; i < adapter->intr.num_intrs; i++)\n\t\t\tdevReadExt->intrConfExt.modLevels[i] = adapter->intr.mod_levels[i];\n\n\t\tdevReadExt->intrConfExt.eventIntrIdx = adapter->intr.event_intr_idx;\n\t\tdevReadExt->intrConfExt.intrCtrl |= cpu_to_le32(VMXNET3_IC_DISABLE_ALL);\n\t}\n\n\t \n\tdevRead->rxFilterConf.rxMode = 0;\n\tvmxnet3_restore_vlan(adapter);\n\tvmxnet3_write_mac_addr(adapter, adapter->netdev->dev_addr);\n\n\t \n}\n\nstatic void\nvmxnet3_init_bufsize(struct vmxnet3_adapter *adapter)\n{\n\tstruct Vmxnet3_DriverShared *shared = adapter->shared;\n\tunion Vmxnet3_CmdInfo *cmdInfo = &shared->cu.cmdInfo;\n\tunsigned long flags;\n\n\tif (!VMXNET3_VERSION_GE_7(adapter))\n\t\treturn;\n\n\tcmdInfo->ringBufSize = adapter->ringBufSize;\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_SET_RING_BUFFER_SIZE);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n}\n\nstatic void\nvmxnet3_init_coalesce(struct vmxnet3_adapter *adapter)\n{\n\tstruct Vmxnet3_DriverShared *shared = adapter->shared;\n\tunion Vmxnet3_CmdInfo *cmdInfo = &shared->cu.cmdInfo;\n\tunsigned long flags;\n\n\tif (!VMXNET3_VERSION_GE_3(adapter))\n\t\treturn;\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tcmdInfo->varConf.confVer = 1;\n\tcmdInfo->varConf.confLen =\n\t\tcpu_to_le32(sizeof(*adapter->coal_conf));\n\tcmdInfo->varConf.confPA  = cpu_to_le64(adapter->coal_conf_pa);\n\n\tif (adapter->default_coal_mode) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_COALESCE);\n\t} else {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_SET_COALESCE);\n\t}\n\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n}\n\nstatic void\nvmxnet3_init_rssfields(struct vmxnet3_adapter *adapter)\n{\n\tstruct Vmxnet3_DriverShared *shared = adapter->shared;\n\tunion Vmxnet3_CmdInfo *cmdInfo = &shared->cu.cmdInfo;\n\tunsigned long flags;\n\n\tif (!VMXNET3_VERSION_GE_4(adapter))\n\t\treturn;\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\n\tif (adapter->default_rss_fields) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_RSS_FIELDS);\n\t\tadapter->rss_fields =\n\t\t\tVMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t} else {\n\t\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\t\tif ((adapter->rss_fields & VMXNET3_RSS_FIELDS_UDPIP4 ||\n\t\t\t     adapter->rss_fields & VMXNET3_RSS_FIELDS_UDPIP6) &&\n\t\t\t    vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t\t       VMXNET3_CAP_UDP_RSS)) {\n\t\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_UDP_RSS;\n\t\t\t} else {\n\t\t\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_UDP_RSS);\n\t\t\t}\n\n\t\t\tif ((adapter->rss_fields & VMXNET3_RSS_FIELDS_ESPIP4) &&\n\t\t\t    vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t\t       VMXNET3_CAP_ESP_RSS_IPV4)) {\n\t\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_ESP_RSS_IPV4;\n\t\t\t} else {\n\t\t\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_ESP_RSS_IPV4);\n\t\t\t}\n\n\t\t\tif ((adapter->rss_fields & VMXNET3_RSS_FIELDS_ESPIP6) &&\n\t\t\t    vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t\t       VMXNET3_CAP_ESP_RSS_IPV6)) {\n\t\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_ESP_RSS_IPV6;\n\t\t\t} else {\n\t\t\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_ESP_RSS_IPV6);\n\t\t\t}\n\n\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DCR, adapter->dev_caps[0]);\n\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_DCR0_REG);\n\t\t\tadapter->dev_caps[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\t}\n\t\tcmdInfo->setRssFields = adapter->rss_fields;\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_SET_RSS_FIELDS);\n\t\t \n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_RSS_FIELDS);\n\t\tadapter->rss_fields =\n\t\t\tVMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t}\n\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n}\n\nint\nvmxnet3_activate_dev(struct vmxnet3_adapter *adapter)\n{\n\tint err, i;\n\tu32 ret;\n\tunsigned long flags;\n\n\tnetdev_dbg(adapter->netdev, \"%s: skb_buf_size %d, rx_buf_per_pkt %d,\"\n\t\t\" ring sizes %u %u %u\\n\", adapter->netdev->name,\n\t\tadapter->skb_buf_size, adapter->rx_buf_per_pkt,\n\t\tadapter->tx_queue[0].tx_ring.size,\n\t\tadapter->rx_queue[0].rx_ring[0].size,\n\t\tadapter->rx_queue[0].rx_ring[1].size);\n\n\tvmxnet3_tq_init_all(adapter);\n\terr = vmxnet3_rq_init_all(adapter);\n\tif (err) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to init rx queue error %d\\n\", err);\n\t\tgoto rq_err;\n\t}\n\n\terr = vmxnet3_request_irqs(adapter);\n\tif (err) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to setup irq for error %d\\n\", err);\n\t\tgoto irq_err;\n\t}\n\n\tvmxnet3_setup_driver_shared(adapter);\n\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAL, VMXNET3_GET_ADDR_LO(\n\t\t\t       adapter->shared_pa));\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAH, VMXNET3_GET_ADDR_HI(\n\t\t\t       adapter->shared_pa));\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_ACTIVATE_DEV);\n\tret = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\tif (ret != 0) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Failed to activate dev: error %u\\n\", ret);\n\t\terr = -EINVAL;\n\t\tgoto activate_err;\n\t}\n\n\tvmxnet3_init_bufsize(adapter);\n\tvmxnet3_init_coalesce(adapter);\n\tvmxnet3_init_rssfields(adapter);\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tVMXNET3_WRITE_BAR0_REG(adapter,\n\t\t\t\tadapter->rx_prod_offset + i * VMXNET3_REG_ALIGN,\n\t\t\t\tadapter->rx_queue[i].rx_ring[0].next2fill);\n\t\tVMXNET3_WRITE_BAR0_REG(adapter, (adapter->rx_prod2_offset +\n\t\t\t\t(i * VMXNET3_REG_ALIGN)),\n\t\t\t\tadapter->rx_queue[i].rx_ring[1].next2fill);\n\t}\n\n\t \n\tvmxnet3_set_mc(adapter->netdev);\n\n\t \n\tvmxnet3_check_link(adapter, true);\n\tnetif_tx_wake_all_queues(adapter->netdev);\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tnapi_enable(&adapter->rx_queue[i].napi);\n\tvmxnet3_enable_all_intrs(adapter);\n\tclear_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);\n\treturn 0;\n\nactivate_err:\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAL, 0);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DSAH, 0);\n\tvmxnet3_free_irqs(adapter);\nirq_err:\nrq_err:\n\t \n\tvmxnet3_rq_cleanup_all(adapter);\n\treturn err;\n}\n\n\nvoid\nvmxnet3_reset_dev(struct vmxnet3_adapter *adapter)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_RESET_DEV);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n}\n\n\nint\nvmxnet3_quiesce_dev(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\tunsigned long flags;\n\tif (test_and_set_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state))\n\t\treturn 0;\n\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_QUIESCE_DEV);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\tvmxnet3_disable_all_intrs(adapter);\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tnapi_disable(&adapter->rx_queue[i].napi);\n\tnetif_tx_disable(adapter->netdev);\n\tadapter->link_speed = 0;\n\tnetif_carrier_off(adapter->netdev);\n\n\tvmxnet3_tq_cleanup_all(adapter);\n\tvmxnet3_rq_cleanup_all(adapter);\n\tvmxnet3_free_irqs(adapter);\n\treturn 0;\n}\n\n\nstatic void\nvmxnet3_write_mac_addr(struct vmxnet3_adapter *adapter, const u8 *mac)\n{\n\tu32 tmp;\n\n\ttmp = *(u32 *)mac;\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_MACL, tmp);\n\n\ttmp = (mac[5] << 8) | mac[4];\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_MACH, tmp);\n}\n\n\nstatic int\nvmxnet3_set_mac_addr(struct net_device *netdev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tdev_addr_set(netdev, addr->sa_data);\n\tvmxnet3_write_mac_addr(adapter, addr->sa_data);\n\n\treturn 0;\n}\n\n\n \n\nstatic int\nvmxnet3_alloc_pci_resources(struct vmxnet3_adapter *adapter)\n{\n\tint err;\n\tunsigned long mmio_start, mmio_len;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable adapter: error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = pci_request_selected_regions(pdev, (1 << 2) - 1,\n\t\t\t\t\t   vmxnet3_driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to request region for adapter: error %d\\n\", err);\n\t\tgoto err_enable_device;\n\t}\n\n\tpci_set_master(pdev);\n\n\tmmio_start = pci_resource_start(pdev, 0);\n\tmmio_len = pci_resource_len(pdev, 0);\n\tadapter->hw_addr0 = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw_addr0) {\n\t\tdev_err(&pdev->dev, \"Failed to map bar0\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tmmio_start = pci_resource_start(pdev, 1);\n\tmmio_len = pci_resource_len(pdev, 1);\n\tadapter->hw_addr1 = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw_addr1) {\n\t\tdev_err(&pdev->dev, \"Failed to map bar1\\n\");\n\t\terr = -EIO;\n\t\tgoto err_bar1;\n\t}\n\treturn 0;\n\nerr_bar1:\n\tiounmap(adapter->hw_addr0);\nerr_ioremap:\n\tpci_release_selected_regions(pdev, (1 << 2) - 1);\nerr_enable_device:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n\nstatic void\nvmxnet3_free_pci_resources(struct vmxnet3_adapter *adapter)\n{\n\tBUG_ON(!adapter->pdev);\n\n\tiounmap(adapter->hw_addr0);\n\tiounmap(adapter->hw_addr1);\n\tpci_release_selected_regions(adapter->pdev, (1 << 2) - 1);\n\tpci_disable_device(adapter->pdev);\n}\n\n\nvoid\nvmxnet3_adjust_rx_ring_size(struct vmxnet3_adapter *adapter)\n{\n\tsize_t sz, i, ring0_size, ring1_size, comp_size;\n\t \n\tif (!VMXNET3_VERSION_GE_7(adapter)) {\n\t\tif (adapter->netdev->mtu <= VMXNET3_MAX_SKB_BUF_SIZE -\n\t\t\t\t\t    VMXNET3_MAX_ETH_HDR_SIZE) {\n\t\t\tadapter->skb_buf_size = adapter->netdev->mtu +\n\t\t\t\t\t\tVMXNET3_MAX_ETH_HDR_SIZE;\n\t\t\tif (adapter->skb_buf_size < VMXNET3_MIN_T0_BUF_SIZE)\n\t\t\t\tadapter->skb_buf_size = VMXNET3_MIN_T0_BUF_SIZE;\n\n\t\t\tadapter->rx_buf_per_pkt = 1;\n\t\t} else {\n\t\t\tadapter->skb_buf_size = VMXNET3_MAX_SKB_BUF_SIZE;\n\t\t\tsz = adapter->netdev->mtu - VMXNET3_MAX_SKB_BUF_SIZE +\n\t\t\t\t\t\t    VMXNET3_MAX_ETH_HDR_SIZE;\n\t\t\tadapter->rx_buf_per_pkt = 1 + (sz + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\t}\n\t} else {\n\t\tadapter->skb_buf_size = min((int)adapter->netdev->mtu + VMXNET3_MAX_ETH_HDR_SIZE,\n\t\t\t\t\t    VMXNET3_MAX_SKB_BUF_SIZE);\n\t\tadapter->rx_buf_per_pkt = 1;\n\t\tadapter->ringBufSize.ring1BufSizeType0 = cpu_to_le16(adapter->skb_buf_size);\n\t\tadapter->ringBufSize.ring1BufSizeType1 = 0;\n\t\tadapter->ringBufSize.ring2BufSizeType1 = cpu_to_le16(PAGE_SIZE);\n\t}\n\n\t \n\tsz = adapter->rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN;\n\tring0_size = adapter->rx_queue[0].rx_ring[0].size;\n\tring0_size = (ring0_size + sz - 1) / sz * sz;\n\tring0_size = min_t(u32, ring0_size, VMXNET3_RX_RING_MAX_SIZE /\n\t\t\t   sz * sz);\n\tring1_size = adapter->rx_queue[0].rx_ring[1].size;\n\tring1_size = (ring1_size + sz - 1) / sz * sz;\n\tring1_size = min_t(u32, ring1_size, VMXNET3_RX_RING2_MAX_SIZE /\n\t\t\t   sz * sz);\n\t \n\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\tring0_size = rounddown_pow_of_two(ring0_size);\n\t\tring1_size = rounddown_pow_of_two(ring1_size);\n\t}\n\tcomp_size = ring0_size + ring1_size;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct vmxnet3_rx_queue\t*rq = &adapter->rx_queue[i];\n\n\t\trq->rx_ring[0].size = ring0_size;\n\t\trq->rx_ring[1].size = ring1_size;\n\t\trq->comp_ring.size = comp_size;\n\t}\n}\n\n\nint\nvmxnet3_create_queues(struct vmxnet3_adapter *adapter, u32 tx_ring_size,\n\t\t      u32 rx_ring_size, u32 rx_ring2_size,\n\t\t      u16 txdata_desc_size, u16 rxdata_desc_size)\n{\n\tint err = 0, i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct vmxnet3_tx_queue\t*tq = &adapter->tx_queue[i];\n\t\ttq->tx_ring.size   = tx_ring_size;\n\t\ttq->data_ring.size = tx_ring_size;\n\t\ttq->comp_ring.size = tx_ring_size;\n\t\ttq->txdata_desc_size = txdata_desc_size;\n\t\ttq->shared = &adapter->tqd_start[i].ctrl;\n\t\ttq->stopped = true;\n\t\ttq->adapter = adapter;\n\t\ttq->qid = i;\n\t\terr = vmxnet3_tq_create(tq, adapter);\n\t\t \n\t\tif (err)\n\t\t\tgoto queue_err;\n\t}\n\n\tadapter->rx_queue[0].rx_ring[0].size = rx_ring_size;\n\tadapter->rx_queue[0].rx_ring[1].size = rx_ring2_size;\n\tvmxnet3_adjust_rx_ring_size(adapter);\n\n\tadapter->rxdataring_enabled = VMXNET3_VERSION_GE_3(adapter);\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\n\t\t \n\t\trq->shared = &adapter->rqd_start[i].ctrl;\n\t\trq->adapter = adapter;\n\t\trq->data_ring.desc_size = rxdata_desc_size;\n\t\terr = vmxnet3_rq_create(rq, adapter);\n\t\tif (err) {\n\t\t\tif (i == 0) {\n\t\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t\t   \"Could not allocate any rx queues. \"\n\t\t\t\t\t   \"Aborting.\\n\");\n\t\t\t\tgoto queue_err;\n\t\t\t} else {\n\t\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t\t    \"Number of rx queues changed \"\n\t\t\t\t\t    \"to : %d.\\n\", i);\n\t\t\t\tadapter->num_rx_queues = i;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!adapter->rxdataring_enabled)\n\t\tvmxnet3_rq_destroy_all_rxdataring(adapter);\n\n\treturn err;\nqueue_err:\n\tvmxnet3_tq_destroy_all(adapter);\n\treturn err;\n}\n\nstatic int\nvmxnet3_open(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter;\n\tint err, i;\n\n\tadapter = netdev_priv(netdev);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tspin_lock_init(&adapter->tx_queue[i].tx_lock);\n\n\tif (VMXNET3_VERSION_GE_3(adapter)) {\n\t\tunsigned long flags;\n\t\tu16 txdata_desc_size;\n\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_TXDATA_DESC_SIZE);\n\t\ttxdata_desc_size = VMXNET3_READ_BAR1_REG(adapter,\n\t\t\t\t\t\t\t VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\t\tif ((txdata_desc_size < VMXNET3_TXDATA_DESC_MIN_SIZE) ||\n\t\t    (txdata_desc_size > VMXNET3_TXDATA_DESC_MAX_SIZE) ||\n\t\t    (txdata_desc_size & VMXNET3_TXDATA_DESC_SIZE_MASK)) {\n\t\t\tadapter->txdata_desc_size =\n\t\t\t\tsizeof(struct Vmxnet3_TxDataDesc);\n\t\t} else {\n\t\t\tadapter->txdata_desc_size = txdata_desc_size;\n\t\t}\n\t} else {\n\t\tadapter->txdata_desc_size = sizeof(struct Vmxnet3_TxDataDesc);\n\t}\n\n\terr = vmxnet3_create_queues(adapter,\n\t\t\t\t    adapter->tx_ring_size,\n\t\t\t\t    adapter->rx_ring_size,\n\t\t\t\t    adapter->rx_ring2_size,\n\t\t\t\t    adapter->txdata_desc_size,\n\t\t\t\t    adapter->rxdata_desc_size);\n\tif (err)\n\t\tgoto queue_err;\n\n\terr = vmxnet3_activate_dev(adapter);\n\tif (err)\n\t\tgoto activate_err;\n\n\treturn 0;\n\nactivate_err:\n\tvmxnet3_rq_destroy_all(adapter);\n\tvmxnet3_tq_destroy_all(adapter);\nqueue_err:\n\treturn err;\n}\n\n\nstatic int\nvmxnet3_close(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\t \n\twhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tvmxnet3_quiesce_dev(adapter);\n\n\tvmxnet3_rq_destroy_all(adapter);\n\tvmxnet3_tq_destroy_all(adapter);\n\n\tclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\n\n\n\treturn 0;\n}\n\n\nvoid\nvmxnet3_force_close(struct vmxnet3_adapter *adapter)\n{\n\tint i;\n\n\t \n\tBUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));\n\n\t \n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tnapi_enable(&adapter->rx_queue[i].napi);\n\t \n\tclear_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);\n\tdev_close(adapter->netdev);\n}\n\n\nstatic int\nvmxnet3_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tnetdev->mtu = new_mtu;\n\n\t \n\twhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (netif_running(netdev)) {\n\t\tvmxnet3_quiesce_dev(adapter);\n\t\tvmxnet3_reset_dev(adapter);\n\n\t\t \n\t\tvmxnet3_rq_destroy_all(adapter);\n\t\tvmxnet3_adjust_rx_ring_size(adapter);\n\t\terr = vmxnet3_rq_create_all(adapter);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"failed to re-create rx queues, \"\n\t\t\t\t   \" error %d. Closing it.\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = vmxnet3_activate_dev(adapter);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"failed to re-activate, error %d. \"\n\t\t\t\t   \"Closing it\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\n\tif (err)\n\t\tvmxnet3_force_close(adapter);\n\n\treturn err;\n}\n\n\nstatic void\nvmxnet3_declare_features(struct vmxnet3_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM |\n\t\tNETIF_F_HW_CSUM | NETIF_F_HW_VLAN_CTAG_TX |\n\t\tNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_TSO | NETIF_F_TSO6 |\n\t\tNETIF_F_LRO | NETIF_F_HIGHDMA;\n\n\tif (VMXNET3_VERSION_GE_4(adapter)) {\n\t\tnetdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\tNETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\t\tnetdev->hw_enc_features = NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\tNETIF_F_HW_CSUM | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\tNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\tNETIF_F_LRO | NETIF_F_GSO_UDP_TUNNEL |\n\t\t\tNETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t}\n\n\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\tunsigned long flags;\n\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_GENEVE_TSO)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_GENEVE_TSO;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_VXLAN_TSO)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_VXLAN_TSO;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD;\n\t\t}\n\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DCR, adapter->dev_caps[0]);\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_DCR0_REG);\n\t\tadapter->dev_caps[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\t\tif (!(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_GENEVE_TSO)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_VXLAN_TSO))) {\n\t\t\tnetdev->hw_enc_features &= ~NETIF_F_GSO_UDP_TUNNEL;\n\t\t\tnetdev->hw_features &= ~NETIF_F_GSO_UDP_TUNNEL;\n\t\t}\n\t\tif (!(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD))) {\n\t\t\tnetdev->hw_enc_features &= ~NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t\t\tnetdev->hw_features &= ~NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t\t}\n\t}\n\n\tnetdev->vlan_features = netdev->hw_features &\n\t\t\t\t~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t  NETIF_F_HW_VLAN_CTAG_RX);\n\tnetdev->features = netdev->hw_features | NETIF_F_HW_VLAN_CTAG_FILTER;\n}\n\n\nstatic void\nvmxnet3_read_mac_addr(struct vmxnet3_adapter *adapter, u8 *mac)\n{\n\tu32 tmp;\n\n\ttmp = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACL);\n\t*(u32 *)mac = tmp;\n\n\ttmp = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACH);\n\tmac[4] = tmp & 0xff;\n\tmac[5] = (tmp >> 8) & 0xff;\n}\n\n#ifdef CONFIG_PCI_MSI\n\n \n\nstatic int\nvmxnet3_acquire_msix_vectors(struct vmxnet3_adapter *adapter, int nvec)\n{\n\tint ret = pci_enable_msix_range(adapter->pdev,\n\t\t\t\t\tadapter->intr.msix_entries, nvec, nvec);\n\n\tif (ret == -ENOSPC && nvec > VMXNET3_LINUX_MIN_MSIX_VECT) {\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\"Failed to enable %d MSI-X, trying %d\\n\",\n\t\t\tnvec, VMXNET3_LINUX_MIN_MSIX_VECT);\n\n\t\tret = pci_enable_msix_range(adapter->pdev,\n\t\t\t\t\t    adapter->intr.msix_entries,\n\t\t\t\t\t    VMXNET3_LINUX_MIN_MSIX_VECT,\n\t\t\t\t\t    VMXNET3_LINUX_MIN_MSIX_VECT);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(&adapter->netdev->dev,\n\t\t\t\"Failed to enable MSI-X, error: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\n\n#endif  \n\nstatic void\nvmxnet3_alloc_intr_resources(struct vmxnet3_adapter *adapter)\n{\n\tu32 cfg;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_GET_CONF_INTR);\n\tcfg = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\tadapter->intr.type = cfg & 0x3;\n\tadapter->intr.mask_mode = (cfg >> 2) & 0x3;\n\n\tif (adapter->intr.type == VMXNET3_IT_AUTO) {\n\t\tadapter->intr.type = VMXNET3_IT_MSIX;\n\t}\n\n#ifdef CONFIG_PCI_MSI\n\tif (adapter->intr.type == VMXNET3_IT_MSIX) {\n\t\tint i, nvec, nvec_allocated;\n\n\t\tnvec  = adapter->share_intr == VMXNET3_INTR_TXSHARE ?\n\t\t\t1 : adapter->num_tx_queues;\n\t\tnvec += adapter->share_intr == VMXNET3_INTR_BUDDYSHARE ?\n\t\t\t0 : adapter->num_rx_queues;\n\t\tnvec += 1;\t \n\t\tnvec = nvec > VMXNET3_LINUX_MIN_MSIX_VECT ?\n\t\t       nvec : VMXNET3_LINUX_MIN_MSIX_VECT;\n\n\t\tfor (i = 0; i < nvec; i++)\n\t\t\tadapter->intr.msix_entries[i].entry = i;\n\n\t\tnvec_allocated = vmxnet3_acquire_msix_vectors(adapter, nvec);\n\t\tif (nvec_allocated < 0)\n\t\t\tgoto msix_err;\n\n\t\t \n\t\tif (nvec_allocated == VMXNET3_LINUX_MIN_MSIX_VECT &&\n\t\t    nvec != VMXNET3_LINUX_MIN_MSIX_VECT) {\n\t\t\tif (adapter->share_intr != VMXNET3_INTR_BUDDYSHARE\n\t\t\t    || adapter->num_rx_queues != 1) {\n\t\t\t\tadapter->share_intr = VMXNET3_INTR_TXSHARE;\n\t\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t\t   \"Number of rx queues : 1\\n\");\n\t\t\t\tadapter->num_rx_queues = 1;\n\t\t\t}\n\t\t}\n\n\t\tadapter->intr.num_intrs = nvec_allocated;\n\t\treturn;\n\nmsix_err:\n\t\t \n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Failed to enable MSI-X, error %d. \"\n\t\t\t \"Limiting #rx queues to 1, try MSI.\\n\", nvec_allocated);\n\n\t\tadapter->intr.type = VMXNET3_IT_MSI;\n\t}\n\n\tif (adapter->intr.type == VMXNET3_IT_MSI) {\n\t\tif (!pci_enable_msi(adapter->pdev)) {\n\t\t\tadapter->num_rx_queues = 1;\n\t\t\tadapter->intr.num_intrs = 1;\n\t\t\treturn;\n\t\t}\n\t}\n#endif  \n\n\tadapter->num_rx_queues = 1;\n\tdev_info(&adapter->netdev->dev,\n\t\t \"Using INTx interrupt, #Rx queues: 1.\\n\");\n\tadapter->intr.type = VMXNET3_IT_INTX;\n\n\t \n\tadapter->intr.num_intrs = 1;\n}\n\n\nstatic void\nvmxnet3_free_intr_resources(struct vmxnet3_adapter *adapter)\n{\n\tif (adapter->intr.type == VMXNET3_IT_MSIX)\n\t\tpci_disable_msix(adapter->pdev);\n\telse if (adapter->intr.type == VMXNET3_IT_MSI)\n\t\tpci_disable_msi(adapter->pdev);\n\telse\n\t\tBUG_ON(adapter->intr.type != VMXNET3_IT_INTX);\n}\n\n\nstatic void\nvmxnet3_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tadapter->tx_timeout_count++;\n\n\tnetdev_err(adapter->netdev, \"tx hang\\n\");\n\tschedule_work(&adapter->work);\n}\n\n\nstatic void\nvmxnet3_reset_work(struct work_struct *data)\n{\n\tstruct vmxnet3_adapter *adapter;\n\n\tadapter = container_of(data, struct vmxnet3_adapter, work);\n\n\t \n\tif (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\n\t\treturn;\n\n\t \n\trtnl_lock();\n\tif (netif_running(adapter->netdev)) {\n\t\tnetdev_notice(adapter->netdev, \"resetting\\n\");\n\t\tvmxnet3_quiesce_dev(adapter);\n\t\tvmxnet3_reset_dev(adapter);\n\t\tvmxnet3_activate_dev(adapter);\n\t} else {\n\t\tnetdev_info(adapter->netdev, \"already closed\\n\");\n\t}\n\trtnl_unlock();\n\n\tnetif_wake_queue(adapter->netdev);\n\tclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\n}\n\n\nstatic int\nvmxnet3_probe_device(struct pci_dev *pdev,\n\t\t     const struct pci_device_id *id)\n{\n\tstatic const struct net_device_ops vmxnet3_netdev_ops = {\n\t\t.ndo_open = vmxnet3_open,\n\t\t.ndo_stop = vmxnet3_close,\n\t\t.ndo_start_xmit = vmxnet3_xmit_frame,\n\t\t.ndo_set_mac_address = vmxnet3_set_mac_addr,\n\t\t.ndo_change_mtu = vmxnet3_change_mtu,\n\t\t.ndo_fix_features = vmxnet3_fix_features,\n\t\t.ndo_set_features = vmxnet3_set_features,\n\t\t.ndo_features_check = vmxnet3_features_check,\n\t\t.ndo_get_stats64 = vmxnet3_get_stats64,\n\t\t.ndo_tx_timeout = vmxnet3_tx_timeout,\n\t\t.ndo_set_rx_mode = vmxnet3_set_mc,\n\t\t.ndo_vlan_rx_add_vid = vmxnet3_vlan_rx_add_vid,\n\t\t.ndo_vlan_rx_kill_vid = vmxnet3_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t\t.ndo_poll_controller = vmxnet3_netpoll,\n#endif\n\t\t.ndo_bpf = vmxnet3_xdp,\n\t\t.ndo_xdp_xmit = vmxnet3_xdp_xmit,\n\t};\n\tint err;\n\tu32 ver;\n\tstruct net_device *netdev;\n\tstruct vmxnet3_adapter *adapter;\n\tu8 mac[ETH_ALEN];\n\tint size;\n\tint num_tx_queues;\n\tint num_rx_queues;\n\tint queues;\n\tunsigned long flags;\n\n\tif (!pci_msi_enabled())\n\t\tenable_mq = 0;\n\n#ifdef VMXNET3_RSS\n\tif (enable_mq)\n\t\tnum_rx_queues = min(VMXNET3_DEVICE_MAX_RX_QUEUES,\n\t\t\t\t    (int)num_online_cpus());\n\telse\n#endif\n\t\tnum_rx_queues = 1;\n\n\tif (enable_mq)\n\t\tnum_tx_queues = min(VMXNET3_DEVICE_MAX_TX_QUEUES,\n\t\t\t\t    (int)num_online_cpus());\n\telse\n\t\tnum_tx_queues = 1;\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct vmxnet3_adapter),\n\t\t\t\t   max(num_tx_queues, num_rx_queues));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\n\tadapter->tx_ring_size = VMXNET3_DEF_TX_RING_SIZE;\n\tadapter->rx_ring_size = VMXNET3_DEF_RX_RING_SIZE;\n\tadapter->rx_ring2_size = VMXNET3_DEF_RX_RING2_SIZE;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"dma_set_mask failed\\n\");\n\t\tgoto err_set_mask;\n\t}\n\n\tspin_lock_init(&adapter->cmd_lock);\n\tadapter->adapter_pa = dma_map_single(&adapter->pdev->dev, adapter,\n\t\t\t\t\t     sizeof(struct vmxnet3_adapter),\n\t\t\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(&adapter->pdev->dev, adapter->adapter_pa)) {\n\t\tdev_err(&pdev->dev, \"Failed to map dma\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_set_mask;\n\t}\n\tadapter->shared = dma_alloc_coherent(\n\t\t\t\t&adapter->pdev->dev,\n\t\t\t\tsizeof(struct Vmxnet3_DriverShared),\n\t\t\t\t&adapter->shared_pa, GFP_KERNEL);\n\tif (!adapter->shared) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_shared;\n\t}\n\n\terr = vmxnet3_alloc_pci_resources(adapter);\n\tif (err < 0)\n\t\tgoto err_alloc_pci;\n\n\tver = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_VRRS);\n\tif (ver & (1 << VMXNET3_REV_7)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_7);\n\t\tadapter->version = VMXNET3_REV_7 + 1;\n\t} else if (ver & (1 << VMXNET3_REV_6)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_6);\n\t\tadapter->version = VMXNET3_REV_6 + 1;\n\t} else if (ver & (1 << VMXNET3_REV_5)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_5);\n\t\tadapter->version = VMXNET3_REV_5 + 1;\n\t} else if (ver & (1 << VMXNET3_REV_4)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_4);\n\t\tadapter->version = VMXNET3_REV_4 + 1;\n\t} else if (ver & (1 << VMXNET3_REV_3)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_3);\n\t\tadapter->version = VMXNET3_REV_3 + 1;\n\t} else if (ver & (1 << VMXNET3_REV_2)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_2);\n\t\tadapter->version = VMXNET3_REV_2 + 1;\n\t} else if (ver & (1 << VMXNET3_REV_1)) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter,\n\t\t\t\t       VMXNET3_REG_VRRS,\n\t\t\t\t       1 << VMXNET3_REV_1);\n\t\tadapter->version = VMXNET3_REV_1 + 1;\n\t} else {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Incompatible h/w version (0x%x) for adapter\\n\", ver);\n\t\terr = -EBUSY;\n\t\tgoto err_ver;\n\t}\n\tdev_dbg(&pdev->dev, \"Using device version %d\\n\", adapter->version);\n\n\tver = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_UVRS);\n\tif (ver & 1) {\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_UVRS, 1);\n\t} else {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Incompatible upt version (0x%x) for adapter\\n\", ver);\n\t\terr = -EBUSY;\n\t\tgoto err_ver;\n\t}\n\n\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\tadapter->devcap_supported[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_DCR);\n\t\tadapter->ptcap_supported[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_PTCR);\n\t\tif (adapter->devcap_supported[0] & (1UL << VMXNET3_CAP_LARGE_BAR)) {\n\t\t\tadapter->dev_caps[0] = adapter->devcap_supported[0] &\n\t\t\t\t\t\t\t(1UL << VMXNET3_CAP_LARGE_BAR);\n\t\t}\n\t\tif (!(adapter->ptcap_supported[0] & (1UL << VMXNET3_DCR_ERROR)) &&\n\t\t    adapter->ptcap_supported[0] & (1UL << VMXNET3_CAP_OOORX_COMP) &&\n\t\t    adapter->devcap_supported[0] & (1UL << VMXNET3_CAP_OOORX_COMP)) {\n\t\t\tadapter->dev_caps[0] |= adapter->devcap_supported[0] &\n\t\t\t\t\t\t(1UL << VMXNET3_CAP_OOORX_COMP);\n\t\t}\n\t\tif (adapter->dev_caps[0])\n\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DCR, adapter->dev_caps[0]);\n\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_DCR0_REG);\n\t\tadapter->dev_caps[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t}\n\n\tif (VMXNET3_VERSION_GE_7(adapter) &&\n\t    adapter->dev_caps[0] & (1UL << VMXNET3_CAP_LARGE_BAR)) {\n\t\tadapter->tx_prod_offset = VMXNET3_REG_LB_TXPROD;\n\t\tadapter->rx_prod_offset = VMXNET3_REG_LB_RXPROD;\n\t\tadapter->rx_prod2_offset = VMXNET3_REG_LB_RXPROD2;\n\t} else {\n\t\tadapter->tx_prod_offset = VMXNET3_REG_TXPROD;\n\t\tadapter->rx_prod_offset = VMXNET3_REG_RXPROD;\n\t\tadapter->rx_prod2_offset = VMXNET3_REG_RXPROD2;\n\t}\n\n\tif (VMXNET3_VERSION_GE_6(adapter)) {\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_MAX_QUEUES_CONF);\n\t\tqueues = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t\tif (queues > 0) {\n\t\t\tadapter->num_rx_queues = min(num_rx_queues, ((queues >> 8) & 0xff));\n\t\t\tadapter->num_tx_queues = min(num_tx_queues, (queues & 0xff));\n\t\t} else {\n\t\t\tadapter->num_rx_queues = min(num_rx_queues,\n\t\t\t\t\t\t     VMXNET3_DEVICE_DEFAULT_RX_QUEUES);\n\t\t\tadapter->num_tx_queues = min(num_tx_queues,\n\t\t\t\t\t\t     VMXNET3_DEVICE_DEFAULT_TX_QUEUES);\n\t\t}\n\t\tif (adapter->num_rx_queues > VMXNET3_MAX_RX_QUEUES ||\n\t\t    adapter->num_tx_queues > VMXNET3_MAX_TX_QUEUES) {\n\t\t\tadapter->queuesExtEnabled = true;\n\t\t} else {\n\t\t\tadapter->queuesExtEnabled = false;\n\t\t}\n\t} else {\n\t\tadapter->queuesExtEnabled = false;\n\t\tnum_rx_queues = rounddown_pow_of_two(num_rx_queues);\n\t\tnum_tx_queues = rounddown_pow_of_two(num_tx_queues);\n\t\tadapter->num_rx_queues = min(num_rx_queues,\n\t\t\t\t\t     VMXNET3_DEVICE_DEFAULT_RX_QUEUES);\n\t\tadapter->num_tx_queues = min(num_tx_queues,\n\t\t\t\t\t     VMXNET3_DEVICE_DEFAULT_TX_QUEUES);\n\t}\n\tdev_info(&pdev->dev,\n\t\t \"# of Tx queues : %d, # of Rx queues : %d\\n\",\n\t\t adapter->num_tx_queues, adapter->num_rx_queues);\n\n\tadapter->rx_buf_per_pkt = 1;\n\n\tsize = sizeof(struct Vmxnet3_TxQueueDesc) * adapter->num_tx_queues;\n\tsize += sizeof(struct Vmxnet3_RxQueueDesc) * adapter->num_rx_queues;\n\tadapter->tqd_start = dma_alloc_coherent(&adapter->pdev->dev, size,\n\t\t\t\t\t\t&adapter->queue_desc_pa,\n\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!adapter->tqd_start) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_ver;\n\t}\n\tadapter->rqd_start = (struct Vmxnet3_RxQueueDesc *)(adapter->tqd_start +\n\t\t\t\t\t\t\t    adapter->num_tx_queues);\n\n\tadapter->pm_conf = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t      sizeof(struct Vmxnet3_PMConf),\n\t\t\t\t\t      &adapter->pm_conf_pa,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (adapter->pm_conf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_pm;\n\t}\n\n#ifdef VMXNET3_RSS\n\n\tadapter->rss_conf = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t       sizeof(struct UPT1_RSSConf),\n\t\t\t\t\t       &adapter->rss_conf_pa,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (adapter->rss_conf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_rss;\n\t}\n#endif  \n\n\tif (VMXNET3_VERSION_GE_3(adapter)) {\n\t\tadapter->coal_conf =\n\t\t\tdma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t   sizeof(struct Vmxnet3_CoalesceScheme)\n\t\t\t\t\t   ,\n\t\t\t\t\t   &adapter->coal_conf_pa,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!adapter->coal_conf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_coal_conf;\n\t\t}\n\t\tadapter->coal_conf->coalMode = VMXNET3_COALESCE_DISABLED;\n\t\tadapter->default_coal_mode = true;\n\t}\n\n\tif (VMXNET3_VERSION_GE_4(adapter)) {\n\t\tadapter->default_rss_fields = true;\n\t\tadapter->rss_fields = VMXNET3_RSS_FIELDS_DEFAULT;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tvmxnet3_declare_features(adapter);\n\tnetdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t\t       NETDEV_XDP_ACT_NDO_XMIT;\n\n\tadapter->rxdata_desc_size = VMXNET3_VERSION_GE_3(adapter) ?\n\t\tVMXNET3_DEF_RXDATA_DESC_SIZE : 0;\n\n\tif (adapter->num_tx_queues == adapter->num_rx_queues)\n\t\tadapter->share_intr = VMXNET3_INTR_BUDDYSHARE;\n\telse\n\t\tadapter->share_intr = VMXNET3_INTR_DONTSHARE;\n\n\tvmxnet3_alloc_intr_resources(adapter);\n\n#ifdef VMXNET3_RSS\n\tif (adapter->num_rx_queues > 1 &&\n\t    adapter->intr.type == VMXNET3_IT_MSIX) {\n\t\tadapter->rss = true;\n\t\tnetdev->hw_features |= NETIF_F_RXHASH;\n\t\tnetdev->features |= NETIF_F_RXHASH;\n\t\tdev_dbg(&pdev->dev, \"RSS is enabled.\\n\");\n\t} else {\n\t\tadapter->rss = false;\n\t}\n#endif\n\n\tvmxnet3_read_mac_addr(adapter, mac);\n\tdev_addr_set(netdev, mac);\n\n\tnetdev->netdev_ops = &vmxnet3_netdev_ops;\n\tvmxnet3_set_ethtool_ops(netdev);\n\tnetdev->watchdog_timeo = 5 * HZ;\n\n\t \n\tnetdev->min_mtu = VMXNET3_MIN_MTU;\n\tif (VMXNET3_VERSION_GE_6(adapter))\n\t\tnetdev->max_mtu = VMXNET3_V6_MAX_MTU;\n\telse\n\t\tnetdev->max_mtu = VMXNET3_MAX_MTU;\n\n\tINIT_WORK(&adapter->work, vmxnet3_reset_work);\n\tset_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);\n\n\tif (adapter->intr.type == VMXNET3_IT_MSIX) {\n\t\tint i;\n\t\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\t\tnetif_napi_add(adapter->netdev,\n\t\t\t\t       &adapter->rx_queue[i].napi,\n\t\t\t\t       vmxnet3_poll_rx_only);\n\t\t}\n\t} else {\n\t\tnetif_napi_add(adapter->netdev, &adapter->rx_queue[0].napi,\n\t\t\t       vmxnet3_poll);\n\t}\n\n\tnetif_set_real_num_tx_queues(adapter->netdev, adapter->num_tx_queues);\n\tnetif_set_real_num_rx_queues(adapter->netdev, adapter->num_rx_queues);\n\n\tnetif_carrier_off(netdev);\n\terr = register_netdev(netdev);\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register adapter\\n\");\n\t\tgoto err_register;\n\t}\n\n\tvmxnet3_check_link(adapter, false);\n\treturn 0;\n\nerr_register:\n\tif (VMXNET3_VERSION_GE_3(adapter)) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  sizeof(struct Vmxnet3_CoalesceScheme),\n\t\t\t\t  adapter->coal_conf, adapter->coal_conf_pa);\n\t}\n\tvmxnet3_free_intr_resources(adapter);\nerr_coal_conf:\n#ifdef VMXNET3_RSS\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(struct UPT1_RSSConf),\n\t\t\t  adapter->rss_conf, adapter->rss_conf_pa);\nerr_alloc_rss:\n#endif\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(struct Vmxnet3_PMConf),\n\t\t\t  adapter->pm_conf, adapter->pm_conf_pa);\nerr_alloc_pm:\n\tdma_free_coherent(&adapter->pdev->dev, size, adapter->tqd_start,\n\t\t\t  adapter->queue_desc_pa);\nerr_ver:\n\tvmxnet3_free_pci_resources(adapter);\nerr_alloc_pci:\n\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t  sizeof(struct Vmxnet3_DriverShared),\n\t\t\t  adapter->shared, adapter->shared_pa);\nerr_alloc_shared:\n\tdma_unmap_single(&adapter->pdev->dev, adapter->adapter_pa,\n\t\t\t sizeof(struct vmxnet3_adapter), DMA_TO_DEVICE);\nerr_set_mask:\n\tfree_netdev(netdev);\n\treturn err;\n}\n\n\nstatic void\nvmxnet3_remove_device(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tint size = 0;\n\tint num_rx_queues, rx_queues;\n\tunsigned long flags;\n\n#ifdef VMXNET3_RSS\n\tif (enable_mq)\n\t\tnum_rx_queues = min(VMXNET3_DEVICE_MAX_RX_QUEUES,\n\t\t\t\t    (int)num_online_cpus());\n\telse\n#endif\n\t\tnum_rx_queues = 1;\n\tif (!VMXNET3_VERSION_GE_6(adapter)) {\n\t\tnum_rx_queues = rounddown_pow_of_two(num_rx_queues);\n\t}\n\tif (VMXNET3_VERSION_GE_6(adapter)) {\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_MAX_QUEUES_CONF);\n\t\trx_queues = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t\tif (rx_queues > 0)\n\t\t\trx_queues = (rx_queues >> 8) & 0xff;\n\t\telse\n\t\t\trx_queues = min(num_rx_queues, VMXNET3_DEVICE_DEFAULT_RX_QUEUES);\n\t\tnum_rx_queues = min(num_rx_queues, rx_queues);\n\t} else {\n\t\tnum_rx_queues = min(num_rx_queues,\n\t\t\t\t    VMXNET3_DEVICE_DEFAULT_RX_QUEUES);\n\t}\n\n\tcancel_work_sync(&adapter->work);\n\n\tunregister_netdev(netdev);\n\n\tvmxnet3_free_intr_resources(adapter);\n\tvmxnet3_free_pci_resources(adapter);\n\tif (VMXNET3_VERSION_GE_3(adapter)) {\n\t\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t\t  sizeof(struct Vmxnet3_CoalesceScheme),\n\t\t\t\t  adapter->coal_conf, adapter->coal_conf_pa);\n\t}\n#ifdef VMXNET3_RSS\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(struct UPT1_RSSConf),\n\t\t\t  adapter->rss_conf, adapter->rss_conf_pa);\n#endif\n\tdma_free_coherent(&adapter->pdev->dev, sizeof(struct Vmxnet3_PMConf),\n\t\t\t  adapter->pm_conf, adapter->pm_conf_pa);\n\n\tsize = sizeof(struct Vmxnet3_TxQueueDesc) * adapter->num_tx_queues;\n\tsize += sizeof(struct Vmxnet3_RxQueueDesc) * num_rx_queues;\n\tdma_free_coherent(&adapter->pdev->dev, size, adapter->tqd_start,\n\t\t\t  adapter->queue_desc_pa);\n\tdma_free_coherent(&adapter->pdev->dev,\n\t\t\t  sizeof(struct Vmxnet3_DriverShared),\n\t\t\t  adapter->shared, adapter->shared_pa);\n\tdma_unmap_single(&adapter->pdev->dev, adapter->adapter_pa,\n\t\t\t sizeof(struct vmxnet3_adapter), DMA_TO_DEVICE);\n\tfree_netdev(netdev);\n}\n\nstatic void vmxnet3_shutdown_device(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tunsigned long flags;\n\n\t \n\twhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (test_and_set_bit(VMXNET3_STATE_BIT_QUIESCED,\n\t\t\t     &adapter->state)) {\n\t\tclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_QUIESCE_DEV);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\tvmxnet3_disable_all_intrs(adapter);\n\n\tclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\n}\n\n\n#ifdef CONFIG_PM\n\nstatic int\nvmxnet3_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tstruct Vmxnet3_PMConf *pmConf;\n\tstruct ethhdr *ehdr;\n\tstruct arphdr *ahdr;\n\tu8 *arpreq;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa;\n\tunsigned long flags;\n\tint i = 0;\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tnapi_disable(&adapter->rx_queue[i].napi);\n\n\tvmxnet3_disable_all_intrs(adapter);\n\tvmxnet3_free_irqs(adapter);\n\tvmxnet3_free_intr_resources(adapter);\n\n\tnetif_device_detach(netdev);\n\n\t \n\tpmConf = adapter->pm_conf;\n\tmemset(pmConf, 0, sizeof(*pmConf));\n\n\tif (adapter->wol & WAKE_UCAST) {\n\t\tpmConf->filters[i].patternSize = ETH_ALEN;\n\t\tpmConf->filters[i].maskSize = 1;\n\t\tmemcpy(pmConf->filters[i].pattern, netdev->dev_addr, ETH_ALEN);\n\t\tpmConf->filters[i].mask[0] = 0x3F;  \n\n\t\tpmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_FILTER;\n\t\ti++;\n\t}\n\n\tif (adapter->wol & WAKE_ARP) {\n\t\trcu_read_lock();\n\n\t\tin_dev = __in_dev_get_rcu(netdev);\n\t\tif (!in_dev) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto skip_arp;\n\t\t}\n\n\t\tifa = rcu_dereference(in_dev->ifa_list);\n\t\tif (!ifa) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto skip_arp;\n\t\t}\n\n\t\tpmConf->filters[i].patternSize = ETH_HLEN +  \n\t\t\tsizeof(struct arphdr) +\t\t \n\t\t\t2 * ETH_ALEN +\t\t \n\t\t\t2 * sizeof(u32);\t \n\t\tpmConf->filters[i].maskSize =\n\t\t\t(pmConf->filters[i].patternSize - 1) / 8 + 1;\n\n\t\t \n\t\tehdr = (struct ethhdr *)pmConf->filters[i].pattern;\n\t\tehdr->h_proto = htons(ETH_P_ARP);\n\n\t\t \n\t\tahdr = (struct arphdr *)&pmConf->filters[i].pattern[ETH_HLEN];\n\t\tahdr->ar_op = htons(ARPOP_REQUEST);\n\t\tarpreq = (u8 *)(ahdr + 1);\n\n\t\t \n\t\tarpreq += 2 * ETH_ALEN + sizeof(u32);\n\t\t*(__be32 *)arpreq = ifa->ifa_address;\n\n\t\trcu_read_unlock();\n\n\t\t \n\t\tpmConf->filters[i].mask[0] = 0x00;\n\t\tpmConf->filters[i].mask[1] = 0x30;  \n\t\tpmConf->filters[i].mask[2] = 0x30;  \n\t\tpmConf->filters[i].mask[3] = 0x00;\n\t\tpmConf->filters[i].mask[4] = 0xC0;  \n\t\tpmConf->filters[i].mask[5] = 0x03;  \n\n\t\tpmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_FILTER;\n\t\ti++;\n\t}\n\nskip_arp:\n\tif (adapter->wol & WAKE_MAGIC)\n\t\tpmConf->wakeUpEvents |= VMXNET3_PM_WAKEUP_MAGIC;\n\n\tpmConf->numFilters = i;\n\n\tadapter->shared->devRead.pmConfDesc.confVer = cpu_to_le32(1);\n\tadapter->shared->devRead.pmConfDesc.confLen = cpu_to_le32(sizeof(\n\t\t\t\t\t\t\t\t  *pmConf));\n\tadapter->shared->devRead.pmConfDesc.confPA =\n\t\tcpu_to_le64(adapter->pm_conf_pa);\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_UPDATE_PMCFG);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\tpci_save_state(pdev);\n\tpci_enable_wake(pdev, pci_choose_state(pdev, PMSG_SUSPEND),\n\t\t\tadapter->wol);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, PMSG_SUSPEND));\n\n\treturn 0;\n}\n\n\nstatic int\nvmxnet3_resume(struct device *device)\n{\n\tint err;\n\tunsigned long flags;\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\terr = pci_enable_device_mem(pdev);\n\tif (err != 0)\n\t\treturn err;\n\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\n\tvmxnet3_alloc_intr_resources(adapter);\n\n\t \n\n\t \n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_QUIESCE_DEV);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\tvmxnet3_tq_cleanup_all(adapter);\n\tvmxnet3_rq_cleanup_all(adapter);\n\n\tvmxnet3_reset_dev(adapter);\n\terr = vmxnet3_activate_dev(adapter);\n\tif (err != 0) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"failed to re-activate on resume, error: %d\", err);\n\t\tvmxnet3_force_close(adapter);\n\t\treturn err;\n\t}\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops vmxnet3_pm_ops = {\n\t.suspend = vmxnet3_suspend,\n\t.resume = vmxnet3_resume,\n\t.freeze = vmxnet3_suspend,\n\t.restore = vmxnet3_resume,\n};\n#endif\n\nstatic struct pci_driver vmxnet3_driver = {\n\t.name\t\t= vmxnet3_driver_name,\n\t.id_table\t= vmxnet3_pciid_table,\n\t.probe\t\t= vmxnet3_probe_device,\n\t.remove\t\t= vmxnet3_remove_device,\n\t.shutdown\t= vmxnet3_shutdown_device,\n#ifdef CONFIG_PM\n\t.driver.pm\t= &vmxnet3_pm_ops,\n#endif\n};\n\n\nstatic int __init\nvmxnet3_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", VMXNET3_DRIVER_DESC,\n\t\tVMXNET3_DRIVER_VERSION_REPORT);\n\treturn pci_register_driver(&vmxnet3_driver);\n}\n\nmodule_init(vmxnet3_init_module);\n\n\nstatic void\nvmxnet3_exit_module(void)\n{\n\tpci_unregister_driver(&vmxnet3_driver);\n}\n\nmodule_exit(vmxnet3_exit_module);\n\nMODULE_AUTHOR(\"VMware, Inc.\");\nMODULE_DESCRIPTION(VMXNET3_DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(VMXNET3_DRIVER_VERSION_STRING);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}