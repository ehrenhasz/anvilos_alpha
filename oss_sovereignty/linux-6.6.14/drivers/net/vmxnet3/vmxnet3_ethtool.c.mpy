{
  "module_name": "vmxnet3_ethtool.c",
  "hash_id": "3a9556ff559220c814d6a31f4c684f6036c0338abb2ec50d1bdb9e501e5db428",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vmxnet3/vmxnet3_ethtool.c",
  "human_readable_source": " \n\n\n#include \"vmxnet3_int.h\"\n#include <net/vxlan.h>\n#include <net/geneve.h>\n#include \"vmxnet3_xdp.h\"\n\n#define VXLAN_UDP_PORT 8472\n\nstruct vmxnet3_stat_desc {\n\tchar desc[ETH_GSTRING_LEN];\n\tint  offset;\n};\n\n\n \nstatic const struct vmxnet3_stat_desc\nvmxnet3_tq_dev_stats[] = {\n\t \n\t{ \"Tx Queue#\",        0 },\n\t{ \"  TSO pkts tx\",\toffsetof(struct UPT1_TxStats, TSOPktsTxOK) },\n\t{ \"  TSO bytes tx\",\toffsetof(struct UPT1_TxStats, TSOBytesTxOK) },\n\t{ \"  ucast pkts tx\",\toffsetof(struct UPT1_TxStats, ucastPktsTxOK) },\n\t{ \"  ucast bytes tx\",\toffsetof(struct UPT1_TxStats, ucastBytesTxOK) },\n\t{ \"  mcast pkts tx\",\toffsetof(struct UPT1_TxStats, mcastPktsTxOK) },\n\t{ \"  mcast bytes tx\",\toffsetof(struct UPT1_TxStats, mcastBytesTxOK) },\n\t{ \"  bcast pkts tx\",\toffsetof(struct UPT1_TxStats, bcastPktsTxOK) },\n\t{ \"  bcast bytes tx\",\toffsetof(struct UPT1_TxStats, bcastBytesTxOK) },\n\t{ \"  pkts tx err\",\toffsetof(struct UPT1_TxStats, pktsTxError) },\n\t{ \"  pkts tx discard\",\toffsetof(struct UPT1_TxStats, pktsTxDiscard) },\n};\n\n \nstatic const struct vmxnet3_stat_desc\nvmxnet3_tq_driver_stats[] = {\n\t \n\t{\"  drv dropped tx total\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t\t drop_total) },\n\t{ \"     too many frags\", offsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t  drop_too_many_frags) },\n\t{ \"     giant hdr\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t drop_oversized_hdr) },\n\t{ \"     hdr err\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t drop_hdr_inspect_err) },\n\t{ \"     tso\",\t\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t drop_tso) },\n\t{ \"  ring full\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t tx_ring_full) },\n\t{ \"  pkts linearized\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t linearized) },\n\t{ \"  hdr cloned\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t copy_skb_header) },\n\t{ \"  giant hdr\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t oversized_hdr) },\n\t{ \"  xdp xmit\",\t\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t xdp_xmit) },\n\t{ \"  xdp xmit err\",\toffsetof(struct vmxnet3_tq_driver_stats,\n\t\t\t\t\t xdp_xmit_err) },\n};\n\n \nstatic const struct vmxnet3_stat_desc\nvmxnet3_rq_dev_stats[] = {\n\t{ \"Rx Queue#\",        0 },\n\t{ \"  LRO pkts rx\",\toffsetof(struct UPT1_RxStats, LROPktsRxOK) },\n\t{ \"  LRO byte rx\",\toffsetof(struct UPT1_RxStats, LROBytesRxOK) },\n\t{ \"  ucast pkts rx\",\toffsetof(struct UPT1_RxStats, ucastPktsRxOK) },\n\t{ \"  ucast bytes rx\",\toffsetof(struct UPT1_RxStats, ucastBytesRxOK) },\n\t{ \"  mcast pkts rx\",\toffsetof(struct UPT1_RxStats, mcastPktsRxOK) },\n\t{ \"  mcast bytes rx\",\toffsetof(struct UPT1_RxStats, mcastBytesRxOK) },\n\t{ \"  bcast pkts rx\",\toffsetof(struct UPT1_RxStats, bcastPktsRxOK) },\n\t{ \"  bcast bytes rx\",\toffsetof(struct UPT1_RxStats, bcastBytesRxOK) },\n\t{ \"  pkts rx OOB\",\toffsetof(struct UPT1_RxStats, pktsRxOutOfBuf) },\n\t{ \"  pkts rx err\",\toffsetof(struct UPT1_RxStats, pktsRxError) },\n};\n\n \nstatic const struct vmxnet3_stat_desc\nvmxnet3_rq_driver_stats[] = {\n\t \n\t{ \"  drv dropped rx total\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t\t     drop_total) },\n\t{ \"     err\",\t\toffsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t\t drop_err) },\n\t{ \"     fcs\",\t\toffsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t\t drop_fcs) },\n\t{ \"  rx buf alloc fail\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t\t  rx_buf_alloc_failure) },\n\t{ \"     xdp packets\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t       xdp_packets) },\n\t{ \"     xdp tx\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t  xdp_tx) },\n\t{ \"     xdp redirects\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t\t xdp_redirects) },\n\t{ \"     xdp drops\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t     xdp_drops) },\n\t{ \"     xdp aborted\", offsetof(struct vmxnet3_rq_driver_stats,\n\t\t\t\t       xdp_aborted) },\n};\n\n \nstatic const struct vmxnet3_stat_desc\nvmxnet3_global_stats[] = {\n\t \n\t{ \"tx timeout count\",\toffsetof(struct vmxnet3_adapter,\n\t\t\t\t\t tx_timeout_count) }\n};\n\n\nvoid\nvmxnet3_get_stats64(struct net_device *netdev,\n\t\t   struct rtnl_link_stats64 *stats)\n{\n\tstruct vmxnet3_adapter *adapter;\n\tstruct vmxnet3_tq_driver_stats *drvTxStats;\n\tstruct vmxnet3_rq_driver_stats *drvRxStats;\n\tstruct UPT1_TxStats *devTxStats;\n\tstruct UPT1_RxStats *devRxStats;\n\tunsigned long flags;\n\tint i;\n\n\tadapter = netdev_priv(netdev);\n\n\t \n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_STATS);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tdevTxStats = &adapter->tqd_start[i].stats;\n\t\tdrvTxStats = &adapter->tx_queue[i].stats;\n\t\tstats->tx_packets += devTxStats->ucastPktsTxOK +\n\t\t\t\t     devTxStats->mcastPktsTxOK +\n\t\t\t\t     devTxStats->bcastPktsTxOK;\n\t\tstats->tx_bytes += devTxStats->ucastBytesTxOK +\n\t\t\t\t   devTxStats->mcastBytesTxOK +\n\t\t\t\t   devTxStats->bcastBytesTxOK;\n\t\tstats->tx_errors += devTxStats->pktsTxError;\n\t\tstats->tx_dropped += drvTxStats->drop_total;\n\t}\n\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tdevRxStats = &adapter->rqd_start[i].stats;\n\t\tdrvRxStats = &adapter->rx_queue[i].stats;\n\t\tstats->rx_packets += devRxStats->ucastPktsRxOK +\n\t\t\t\t     devRxStats->mcastPktsRxOK +\n\t\t\t\t     devRxStats->bcastPktsRxOK;\n\n\t\tstats->rx_bytes += devRxStats->ucastBytesRxOK +\n\t\t\t\t   devRxStats->mcastBytesRxOK +\n\t\t\t\t   devRxStats->bcastBytesRxOK;\n\n\t\tstats->rx_errors += devRxStats->pktsRxError;\n\t\tstats->rx_dropped += drvRxStats->drop_total;\n\t\tstats->multicast +=  devRxStats->mcastPktsRxOK;\n\t}\n}\n\nstatic int\nvmxnet3_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn (ARRAY_SIZE(vmxnet3_tq_dev_stats) +\n\t\t\tARRAY_SIZE(vmxnet3_tq_driver_stats)) *\n\t\t       adapter->num_tx_queues +\n\t\t       (ARRAY_SIZE(vmxnet3_rq_dev_stats) +\n\t\t\tARRAY_SIZE(vmxnet3_rq_driver_stats)) *\n\t\t       adapter->num_rx_queues +\n\t\t\tARRAY_SIZE(vmxnet3_global_stats);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n\n \nstatic int\nvmxnet3_get_regs_len(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\treturn ((9   +\n\t\t(1 + adapter->intr.num_intrs) +\n\t\t(1 + adapter->num_tx_queues * 17  ) +\n\t\t(1 + adapter->num_rx_queues * 23  )) *\n\t\tsizeof(u32));\n}\n\n\nstatic void\nvmxnet3_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, vmxnet3_driver_name, sizeof(drvinfo->driver));\n\n\tstrscpy(drvinfo->version, VMXNET3_DRIVER_VERSION_REPORT,\n\t\tsizeof(drvinfo->version));\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\n\nstatic void\nvmxnet3_get_strings(struct net_device *netdev, u32 stringset, u8 *buf)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tint i, j;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (j = 0; j < adapter->num_tx_queues; j++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_tq_dev_stats); i++)\n\t\t\tethtool_sprintf(&buf, vmxnet3_tq_dev_stats[i].desc);\n\t\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_tq_driver_stats); i++)\n\t\t\tethtool_sprintf(&buf, vmxnet3_tq_driver_stats[i].desc);\n\t}\n\n\tfor (j = 0; j < adapter->num_rx_queues; j++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_rq_dev_stats); i++)\n\t\t\tethtool_sprintf(&buf, vmxnet3_rq_dev_stats[i].desc);\n\t\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_rq_driver_stats); i++)\n\t\t\tethtool_sprintf(&buf, vmxnet3_rq_driver_stats[i].desc);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_global_stats); i++)\n\t\tethtool_sprintf(&buf, vmxnet3_global_stats[i].desc);\n}\n\nnetdev_features_t vmxnet3_fix_features(struct net_device *netdev,\n\t\t\t\t       netdev_features_t features)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (!(features & NETIF_F_RXCSUM))\n\t\tfeatures &= ~NETIF_F_LRO;\n\n\t \n\tif (vmxnet3_xdp_enabled(adapter) && (features & NETIF_F_LRO)) {\n\t\tnetdev_err(netdev, \"LRO is not supported with XDP\");\n\t\tfeatures &= ~NETIF_F_LRO;\n\t}\n\n\treturn features;\n}\n\nnetdev_features_t vmxnet3_features_check(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tif (VMXNET3_VERSION_GE_4(adapter) &&\n\t    skb->encapsulation && skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tu8 l4_proto = 0;\n\t\tu16 port;\n\t\tstruct udphdr *udph;\n\n\t\tswitch (vlan_get_protocol(skb)) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tl4_proto = ip_hdr(skb)->protocol;\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tl4_proto = ipv6_hdr(skb)->nexthdr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\t\t}\n\n\t\tswitch (l4_proto) {\n\t\tcase IPPROTO_UDP:\n\t\t\tudph = udp_hdr(skb);\n\t\t\tport = be16_to_cpu(udph->dest);\n\t\t\t \n\t\t\tif (port != GENEVE_UDP_PORT &&\n\t\t\t    port != IANA_VXLAN_UDP_PORT &&\n\t\t\t    port != VXLAN_UDP_PORT) {\n\t\t\t\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\t\t}\n\t}\n\treturn features;\n}\n\nstatic void vmxnet3_enable_encap_offloads(struct net_device *netdev, netdev_features_t features)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (VMXNET3_VERSION_GE_4(adapter)) {\n\t\tnetdev->hw_enc_features |= NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\tNETIF_F_HW_CSUM | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\tNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\tNETIF_F_LRO;\n\t\tif (features & NETIF_F_GSO_UDP_TUNNEL)\n\t\t\tnetdev->hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL;\n\t\tif (features & NETIF_F_GSO_UDP_TUNNEL_CSUM)\n\t\t\tnetdev->hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t}\n\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\tunsigned long flags;\n\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_GENEVE_TSO)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_GENEVE_TSO;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_VXLAN_TSO)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_VXLAN_TSO;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD;\n\t\t}\n\t\tif (vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t       VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD)) {\n\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD;\n\t\t}\n\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DCR, adapter->dev_caps[0]);\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_DCR0_REG);\n\t\tadapter->dev_caps[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\t\tif (!(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_GENEVE_TSO)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_VXLAN_TSO))) {\n\t\t\tnetdev->hw_enc_features &= ~NETIF_F_GSO_UDP_TUNNEL;\n\t\t}\n\t\tif (!(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD)) &&\n\t\t    !(adapter->dev_caps[0] & (1UL << VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD))) {\n\t\t\tnetdev->hw_enc_features &= ~NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t\t}\n\t}\n}\n\nstatic void vmxnet3_disable_encap_offloads(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (VMXNET3_VERSION_GE_4(adapter)) {\n\t\tnetdev->hw_enc_features &= ~(NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\tNETIF_F_HW_CSUM | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\tNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\tNETIF_F_LRO | NETIF_F_GSO_UDP_TUNNEL |\n\t\t\tNETIF_F_GSO_UDP_TUNNEL_CSUM);\n\t}\n\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\tunsigned long flags;\n\n\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_GENEVE_CHECKSUM_OFFLOAD |\n\t\t\t\t\t  1UL << VMXNET3_CAP_VXLAN_CHECKSUM_OFFLOAD  |\n\t\t\t\t\t  1UL << VMXNET3_CAP_GENEVE_TSO |\n\t\t\t\t\t  1UL << VMXNET3_CAP_VXLAN_TSO  |\n\t\t\t\t\t  1UL << VMXNET3_CAP_GENEVE_OUTER_CHECKSUM_OFFLOAD |\n\t\t\t\t\t  1UL << VMXNET3_CAP_VXLAN_OUTER_CHECKSUM_OFFLOAD);\n\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DCR, adapter->dev_caps[0]);\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_DCR0_REG);\n\t\tadapter->dev_caps[0] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t}\n}\n\nint vmxnet3_set_features(struct net_device *netdev, netdev_features_t features)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tunsigned long flags;\n\tnetdev_features_t changed = features ^ netdev->features;\n\tnetdev_features_t tun_offload_mask = NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t     NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\tu8 udp_tun_enabled = (netdev->features & tun_offload_mask) != 0;\n\n\tif (changed & (NETIF_F_RXCSUM | NETIF_F_LRO |\n\t\t       NETIF_F_HW_VLAN_CTAG_RX | tun_offload_mask)) {\n\t\tif (features & NETIF_F_RXCSUM)\n\t\t\tadapter->shared->devRead.misc.uptFeatures |=\n\t\t\tUPT1_F_RXCSUM;\n\t\telse\n\t\t\tadapter->shared->devRead.misc.uptFeatures &=\n\t\t\t~UPT1_F_RXCSUM;\n\n\t\t \n\t\tif (features & NETIF_F_LRO)\n\t\t\tadapter->shared->devRead.misc.uptFeatures |=\n\t\t\t\t\t\t\tUPT1_F_LRO;\n\t\telse\n\t\t\tadapter->shared->devRead.misc.uptFeatures &=\n\t\t\t\t\t\t\t~UPT1_F_LRO;\n\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\tadapter->shared->devRead.misc.uptFeatures |=\n\t\t\tUPT1_F_RXVLAN;\n\t\telse\n\t\t\tadapter->shared->devRead.misc.uptFeatures &=\n\t\t\t~UPT1_F_RXVLAN;\n\n\t\tif ((features & tun_offload_mask) != 0) {\n\t\t\tvmxnet3_enable_encap_offloads(netdev, features);\n\t\t\tadapter->shared->devRead.misc.uptFeatures |=\n\t\t\tUPT1_F_RXINNEROFLD;\n\t\t} else if ((features & tun_offload_mask) == 0 &&\n\t\t\t   udp_tun_enabled) {\n\t\t\tvmxnet3_disable_encap_offloads(netdev);\n\t\t\tadapter->shared->devRead.misc.uptFeatures &=\n\t\t\t~UPT1_F_RXINNEROFLD;\n\t\t}\n\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_UPDATE_FEATURE);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t}\n\treturn 0;\n}\n\nstatic void\nvmxnet3_get_ethtool_stats(struct net_device *netdev,\n\t\t\t  struct ethtool_stats *stats, u64  *buf)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tunsigned long flags;\n\tu8 *base;\n\tint i;\n\tint j = 0;\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD, VMXNET3_CMD_GET_STATS);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\t \n\tfor (j = 0; j < adapter->num_tx_queues; j++) {\n\t\tbase = (u8 *)&adapter->tqd_start[j].stats;\n\t\t*buf++ = (u64)j;\n\t\tfor (i = 1; i < ARRAY_SIZE(vmxnet3_tq_dev_stats); i++)\n\t\t\t*buf++ = *(u64 *)(base +\n\t\t\t\t\t  vmxnet3_tq_dev_stats[i].offset);\n\n\t\tbase = (u8 *)&adapter->tx_queue[j].stats;\n\t\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_tq_driver_stats); i++)\n\t\t\t*buf++ = *(u64 *)(base +\n\t\t\t\t\t  vmxnet3_tq_driver_stats[i].offset);\n\t}\n\n\tfor (j = 0; j < adapter->num_rx_queues; j++) {\n\t\tbase = (u8 *)&adapter->rqd_start[j].stats;\n\t\t*buf++ = (u64) j;\n\t\tfor (i = 1; i < ARRAY_SIZE(vmxnet3_rq_dev_stats); i++)\n\t\t\t*buf++ = *(u64 *)(base +\n\t\t\t\t\t  vmxnet3_rq_dev_stats[i].offset);\n\n\t\tbase = (u8 *)&adapter->rx_queue[j].stats;\n\t\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_rq_driver_stats); i++)\n\t\t\t*buf++ = *(u64 *)(base +\n\t\t\t\t\t  vmxnet3_rq_driver_stats[i].offset);\n\t}\n\n\tbase = (u8 *)adapter;\n\tfor (i = 0; i < ARRAY_SIZE(vmxnet3_global_stats); i++)\n\t\t*buf++ = *(u64 *)(base + vmxnet3_global_stats[i].offset);\n}\n\n\n \nstatic void\nvmxnet3_get_regs(struct net_device *netdev, struct ethtool_regs *regs, void *p)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tu32 *buf = p;\n\tint i = 0, j = 0;\n\n\tmemset(p, 0, vmxnet3_get_regs_len(netdev));\n\n\tregs->version = 2;\n\n\t \n\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_VRRS);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_UVRS);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_DSAL);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_DSAH);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACL);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_MACH);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_ICR);\n\tbuf[j++] = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_ECR);\n\n\tbuf[j++] = adapter->intr.num_intrs;\n\tfor (i = 0; i < adapter->intr.num_intrs; i++) {\n\t\tbuf[j++] = VMXNET3_READ_BAR0_REG(adapter, VMXNET3_REG_IMR\n\t\t\t\t\t\t + i * VMXNET3_REG_ALIGN);\n\t}\n\n\tbuf[j++] = adapter->num_tx_queues;\n\tfor (i = 0; i < adapter->num_tx_queues; i++) {\n\t\tstruct vmxnet3_tx_queue *tq = &adapter->tx_queue[i];\n\n\t\tbuf[j++] = VMXNET3_READ_BAR0_REG(adapter, adapter->tx_prod_offset +\n\t\t\t\t\t\t i * VMXNET3_REG_ALIGN);\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(tq->tx_ring.basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(tq->tx_ring.basePA);\n\t\tbuf[j++] = tq->tx_ring.size;\n\t\tbuf[j++] = tq->tx_ring.next2fill;\n\t\tbuf[j++] = tq->tx_ring.next2comp;\n\t\tbuf[j++] = tq->tx_ring.gen;\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(tq->data_ring.basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(tq->data_ring.basePA);\n\t\tbuf[j++] = tq->data_ring.size;\n\t\tbuf[j++] = tq->txdata_desc_size;\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(tq->comp_ring.basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(tq->comp_ring.basePA);\n\t\tbuf[j++] = tq->comp_ring.size;\n\t\tbuf[j++] = tq->comp_ring.next2proc;\n\t\tbuf[j++] = tq->comp_ring.gen;\n\n\t\tbuf[j++] = tq->stopped;\n\t}\n\n\tbuf[j++] = adapter->num_rx_queues;\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct vmxnet3_rx_queue *rq = &adapter->rx_queue[i];\n\n\t\tbuf[j++] =  VMXNET3_READ_BAR0_REG(adapter, adapter->rx_prod_offset +\n\t\t\t\t\t\t  i * VMXNET3_REG_ALIGN);\n\t\tbuf[j++] =  VMXNET3_READ_BAR0_REG(adapter, adapter->rx_prod2_offset +\n\t\t\t\t\t\t  i * VMXNET3_REG_ALIGN);\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(rq->rx_ring[0].basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(rq->rx_ring[0].basePA);\n\t\tbuf[j++] = rq->rx_ring[0].size;\n\t\tbuf[j++] = rq->rx_ring[0].next2fill;\n\t\tbuf[j++] = rq->rx_ring[0].next2comp;\n\t\tbuf[j++] = rq->rx_ring[0].gen;\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(rq->rx_ring[1].basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(rq->rx_ring[1].basePA);\n\t\tbuf[j++] = rq->rx_ring[1].size;\n\t\tbuf[j++] = rq->rx_ring[1].next2fill;\n\t\tbuf[j++] = rq->rx_ring[1].next2comp;\n\t\tbuf[j++] = rq->rx_ring[1].gen;\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(rq->data_ring.basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(rq->data_ring.basePA);\n\t\tbuf[j++] = rq->rx_ring[0].size;\n\t\tbuf[j++] = rq->data_ring.desc_size;\n\n\t\tbuf[j++] = VMXNET3_GET_ADDR_LO(rq->comp_ring.basePA);\n\t\tbuf[j++] = VMXNET3_GET_ADDR_HI(rq->comp_ring.basePA);\n\t\tbuf[j++] = rq->comp_ring.size;\n\t\tbuf[j++] = rq->comp_ring.next2proc;\n\t\tbuf[j++] = rq->comp_ring.gen;\n\t}\n}\n\n\nstatic void\nvmxnet3_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = WAKE_UCAST | WAKE_ARP | WAKE_MAGIC;\n\twol->wolopts = adapter->wol;\n}\n\n\nstatic int\nvmxnet3_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_PHY | WAKE_MCAST | WAKE_BCAST |\n\t\t\t    WAKE_MAGICSECURE)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tadapter->wol = wol->wolopts;\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\n\nstatic int\nvmxnet3_get_link_ksettings(struct net_device *netdev,\n\t\t\t   struct ethtool_link_ksettings *ecmd)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tethtool_link_ksettings_zero_link_mode(ecmd, supported);\n\tethtool_link_ksettings_add_link_mode(ecmd, supported, 10000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(ecmd, supported, 1000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(ecmd, supported, TP);\n\tethtool_link_ksettings_zero_link_mode(ecmd, advertising);\n\tethtool_link_ksettings_add_link_mode(ecmd, advertising, TP);\n\tecmd->base.port = PORT_TP;\n\n\tif (adapter->link_speed) {\n\t\tecmd->base.speed = adapter->link_speed;\n\t\tecmd->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tecmd->base.speed = SPEED_UNKNOWN;\n\t\tecmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic void\nvmxnet3_get_ringparam(struct net_device *netdev,\n\t\t      struct ethtool_ringparam *param,\n\t\t      struct kernel_ethtool_ringparam *kernel_param,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tparam->rx_max_pending = VMXNET3_RX_RING_MAX_SIZE;\n\tparam->tx_max_pending = VMXNET3_TX_RING_MAX_SIZE;\n\tparam->rx_mini_max_pending = VMXNET3_VERSION_GE_3(adapter) ?\n\t\tVMXNET3_RXDATA_DESC_MAX_SIZE : 0;\n\tparam->rx_jumbo_max_pending = VMXNET3_RX_RING2_MAX_SIZE;\n\n\tparam->rx_pending = adapter->rx_ring_size;\n\tparam->tx_pending = adapter->tx_ring_size;\n\tparam->rx_mini_pending = VMXNET3_VERSION_GE_3(adapter) ?\n\t\tadapter->rxdata_desc_size : 0;\n\tparam->rx_jumbo_pending = adapter->rx_ring2_size;\n}\n\nstatic int\nvmxnet3_set_ringparam(struct net_device *netdev,\n\t\t      struct ethtool_ringparam *param,\n\t\t      struct kernel_ethtool_ringparam *kernel_param,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tu32 new_tx_ring_size, new_rx_ring_size, new_rx_ring2_size;\n\tu16 new_rxdata_desc_size;\n\tu32 sz;\n\tint err = 0;\n\n\tif (param->tx_pending == 0 || param->tx_pending >\n\t\t\t\t\t\tVMXNET3_TX_RING_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\tif (param->rx_pending == 0 || param->rx_pending >\n\t\t\t\t\t\tVMXNET3_RX_RING_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\tif (param->rx_jumbo_pending == 0 ||\n\t    param->rx_jumbo_pending > VMXNET3_RX_RING2_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif (adapter->rx_buf_per_pkt == 0) {\n\t\tnetdev_err(netdev, \"adapter not completely initialized, \"\n\t\t\t   \"ring size cannot be changed yet\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (VMXNET3_VERSION_GE_3(adapter)) {\n\t\tif (param->rx_mini_pending > VMXNET3_RXDATA_DESC_MAX_SIZE)\n\t\t\treturn -EINVAL;\n\t} else if (param->rx_mini_pending != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnew_tx_ring_size = (param->tx_pending + VMXNET3_RING_SIZE_MASK) &\n\t\t\t\t\t\t\t~VMXNET3_RING_SIZE_MASK;\n\tnew_tx_ring_size = min_t(u32, new_tx_ring_size,\n\t\t\t\t VMXNET3_TX_RING_MAX_SIZE);\n\tif (new_tx_ring_size > VMXNET3_TX_RING_MAX_SIZE || (new_tx_ring_size %\n\t\t\t\t\t\tVMXNET3_RING_SIZE_ALIGN) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tsz = adapter->rx_buf_per_pkt * VMXNET3_RING_SIZE_ALIGN;\n\tnew_rx_ring_size = (param->rx_pending + sz - 1) / sz * sz;\n\tnew_rx_ring_size = min_t(u32, new_rx_ring_size,\n\t\t\t\t VMXNET3_RX_RING_MAX_SIZE / sz * sz);\n\tif (new_rx_ring_size > VMXNET3_RX_RING_MAX_SIZE || (new_rx_ring_size %\n\t\t\t\t\t\t\t   sz) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tnew_rx_ring2_size = (param->rx_jumbo_pending + VMXNET3_RING_SIZE_MASK) &\n\t\t\t\t~VMXNET3_RING_SIZE_MASK;\n\tnew_rx_ring2_size = min_t(u32, new_rx_ring2_size,\n\t\t\t\t  VMXNET3_RX_RING2_MAX_SIZE);\n\n\t \n\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\tnew_tx_ring_size = rounddown_pow_of_two(new_tx_ring_size);\n\t\tnew_rx_ring_size = rounddown_pow_of_two(new_rx_ring_size);\n\t\tnew_rx_ring2_size = rounddown_pow_of_two(new_rx_ring2_size);\n\t}\n\n\t \n\tnew_rxdata_desc_size =\n\t\t(param->rx_mini_pending + VMXNET3_RXDATA_DESC_SIZE_MASK) &\n\t\t~VMXNET3_RXDATA_DESC_SIZE_MASK;\n\tnew_rxdata_desc_size = min_t(u16, new_rxdata_desc_size,\n\t\t\t\t     VMXNET3_RXDATA_DESC_MAX_SIZE);\n\n\tif (new_tx_ring_size == adapter->tx_ring_size &&\n\t    new_rx_ring_size == adapter->rx_ring_size &&\n\t    new_rx_ring2_size == adapter->rx_ring2_size &&\n\t    new_rxdata_desc_size == adapter->rxdata_desc_size) {\n\t\treturn 0;\n\t}\n\n\t \n\twhile (test_and_set_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (netif_running(netdev)) {\n\t\tvmxnet3_quiesce_dev(adapter);\n\t\tvmxnet3_reset_dev(adapter);\n\n\t\t \n\t\tvmxnet3_tq_destroy_all(adapter);\n\t\tvmxnet3_rq_destroy_all(adapter);\n\n\t\terr = vmxnet3_create_queues(adapter, new_tx_ring_size,\n\t\t\t\t\t    new_rx_ring_size, new_rx_ring2_size,\n\t\t\t\t\t    adapter->txdata_desc_size,\n\t\t\t\t\t    new_rxdata_desc_size);\n\t\tif (err) {\n\t\t\t \n\t\t\tnetdev_err(netdev, \"failed to apply new sizes, \"\n\t\t\t\t   \"try the default ones\\n\");\n\t\t\tnew_rx_ring_size = VMXNET3_DEF_RX_RING_SIZE;\n\t\t\tnew_rx_ring2_size = VMXNET3_DEF_RX_RING2_SIZE;\n\t\t\tnew_tx_ring_size = VMXNET3_DEF_TX_RING_SIZE;\n\t\t\tnew_rxdata_desc_size = VMXNET3_VERSION_GE_3(adapter) ?\n\t\t\t\tVMXNET3_DEF_RXDATA_DESC_SIZE : 0;\n\n\t\t\terr = vmxnet3_create_queues(adapter,\n\t\t\t\t\t\t    new_tx_ring_size,\n\t\t\t\t\t\t    new_rx_ring_size,\n\t\t\t\t\t\t    new_rx_ring2_size,\n\t\t\t\t\t\t    adapter->txdata_desc_size,\n\t\t\t\t\t\t    new_rxdata_desc_size);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(netdev, \"failed to create queues \"\n\t\t\t\t\t   \"with default sizes. Closing it\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\terr = vmxnet3_activate_dev(adapter);\n\t\tif (err)\n\t\t\tnetdev_err(netdev, \"failed to re-activate, error %d.\"\n\t\t\t\t   \" Closing it\\n\", err);\n\t}\n\tadapter->tx_ring_size = new_tx_ring_size;\n\tadapter->rx_ring_size = new_rx_ring_size;\n\tadapter->rx_ring2_size = new_rx_ring2_size;\n\tadapter->rxdata_desc_size = new_rxdata_desc_size;\n\nout:\n\tclear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);\n\tif (err)\n\t\tvmxnet3_force_close(adapter);\n\n\treturn err;\n}\n\nstatic int\nvmxnet3_get_rss_hash_opts(struct vmxnet3_adapter *adapter,\n\t\t\t  struct ethtool_rxnfc *info)\n{\n\tenum Vmxnet3_RSSField rss_fields;\n\n\tif (netif_running(adapter->netdev)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_GET_RSS_FIELDS);\n\t\trss_fields = VMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t} else {\n\t\trss_fields = adapter->rss_fields;\n\t}\n\n\tinfo->data = 0;\n\n\t \n\tswitch (info->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3 |\n\t\t\t      RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (rss_fields & VMXNET3_RSS_FIELDS_UDPIP4)\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tif (rss_fields & VMXNET3_RSS_FIELDS_ESPIP4)\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (rss_fields & VMXNET3_RSS_FIELDS_UDPIP6)\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\tif (VMXNET3_VERSION_GE_6(adapter) &&\n\t\t    (rss_fields & VMXNET3_RSS_FIELDS_ESPIP6))\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvmxnet3_set_rss_hash_opt(struct net_device *netdev,\n\t\t\t struct vmxnet3_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *nfc)\n{\n\tenum Vmxnet3_RSSField rss_fields = adapter->rss_fields;\n\n\t \n\tif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    !(nfc->data & RXH_L4_B_0_1) ||\n\t\t    !(nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_fields &= ~VMXNET3_RSS_FIELDS_UDPIP4;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_fields |= VMXNET3_RSS_FIELDS_UDPIP4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_fields &= ~VMXNET3_RSS_FIELDS_UDPIP6;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_fields |= VMXNET3_RSS_FIELDS_UDPIP6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_fields &= ~VMXNET3_RSS_FIELDS_ESPIP4;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_fields |= VMXNET3_RSS_FIELDS_ESPIP4;\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\t\tif (!VMXNET3_VERSION_GE_6(adapter))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST))\n\t\t\treturn -EINVAL;\n\t\tswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\n\t\tcase 0:\n\t\t\trss_fields &= ~VMXNET3_RSS_FIELDS_ESPIP6;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_fields |= VMXNET3_RSS_FIELDS_ESPIP6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif (!(nfc->data & RXH_IP_SRC) ||\n\t\t    !(nfc->data & RXH_IP_DST) ||\n\t\t    (nfc->data & RXH_L4_B_0_1) ||\n\t\t    (nfc->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rss_fields != adapter->rss_fields) {\n\t\tadapter->default_rss_fields = false;\n\t\tif (netif_running(netdev)) {\n\t\t\tstruct Vmxnet3_DriverShared *shared = adapter->shared;\n\t\t\tunion Vmxnet3_CmdInfo *cmdInfo = &shared->cu.cmdInfo;\n\t\t\tunsigned long flags;\n\n\t\t\tif (VMXNET3_VERSION_GE_7(adapter)) {\n\t\t\t\tif ((rss_fields & VMXNET3_RSS_FIELDS_UDPIP4 ||\n\t\t\t\t     rss_fields & VMXNET3_RSS_FIELDS_UDPIP6) &&\n\t\t\t\t    vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t\t\t       VMXNET3_CAP_UDP_RSS)) {\n\t\t\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_UDP_RSS;\n\t\t\t\t} else {\n\t\t\t\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_UDP_RSS);\n\t\t\t\t}\n\t\t\t\tif ((rss_fields & VMXNET3_RSS_FIELDS_ESPIP4) &&\n\t\t\t\t    vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t\t\t       VMXNET3_CAP_ESP_RSS_IPV4)) {\n\t\t\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_ESP_RSS_IPV4;\n\t\t\t\t} else {\n\t\t\t\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_ESP_RSS_IPV4);\n\t\t\t\t}\n\t\t\t\tif ((rss_fields & VMXNET3_RSS_FIELDS_ESPIP6) &&\n\t\t\t\t    vmxnet3_check_ptcapability(adapter->ptcap_supported[0],\n\t\t\t\t\t\t\t       VMXNET3_CAP_ESP_RSS_IPV6)) {\n\t\t\t\t\tadapter->dev_caps[0] |= 1UL << VMXNET3_CAP_ESP_RSS_IPV6;\n\t\t\t\t} else {\n\t\t\t\t\tadapter->dev_caps[0] &= ~(1UL << VMXNET3_CAP_ESP_RSS_IPV6);\n\t\t\t\t}\n\n\t\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_DCR,\n\t\t\t\t\t\t       adapter->dev_caps[0]);\n\t\t\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t\t\t       VMXNET3_CMD_GET_DCR0_REG);\n\t\t\t\tadapter->dev_caps[0] = VMXNET3_READ_BAR1_REG(adapter,\n\t\t\t\t\t\t\t\t\t     VMXNET3_REG_CMD);\n\t\t\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t\t\t}\n\t\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\t\tcmdInfo->setRssFields = rss_fields;\n\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t\t       VMXNET3_CMD_SET_RSS_FIELDS);\n\n\t\t\t \n\t\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t\t       VMXNET3_CMD_GET_RSS_FIELDS);\n\t\t\tadapter->rss_fields =\n\t\t\t\tVMXNET3_READ_BAR1_REG(adapter, VMXNET3_REG_CMD);\n\t\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t\t} else {\n\t\t\t \n\t\t\tadapter->rss_fields = rss_fields;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nvmxnet3_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info,\n\t\t  u32 *rules)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = adapter->num_rx_queues;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tif (!VMXNET3_VERSION_GE_4(adapter)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n#ifdef VMXNET3_RSS\n\t\tif (!adapter->rss) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\terr = vmxnet3_get_rss_hash_opts(adapter, info);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int\nvmxnet3_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tint err = 0;\n\n\tif (!VMXNET3_VERSION_GE_4(adapter)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n#ifdef VMXNET3_RSS\n\tif (!adapter->rss) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n#endif\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\terr = vmxnet3_set_rss_hash_opt(netdev, adapter, info);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\ndone:\n\treturn err;\n}\n\n#ifdef VMXNET3_RSS\nstatic u32\nvmxnet3_get_rss_indir_size(struct net_device *netdev)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tstruct UPT1_RSSConf *rssConf = adapter->rss_conf;\n\n\treturn rssConf->indTableSize;\n}\n\nstatic int\nvmxnet3_get_rss(struct net_device *netdev, u32 *p, u8 *key, u8 *hfunc)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tstruct UPT1_RSSConf *rssConf = adapter->rss_conf;\n\tunsigned int n = rssConf->indTableSize;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (!p)\n\t\treturn 0;\n\tif (n > UPT1_RSS_MAX_IND_TABLE_SIZE)\n\t\treturn 0;\n\twhile (n--)\n\t\tp[n] = rssConf->indTable[n];\n\treturn 0;\n\n}\n\nstatic int\nvmxnet3_set_rss(struct net_device *netdev, const u32 *p, const u8 *key,\n\t\tconst u8 hfunc)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tstruct UPT1_RSSConf *rssConf = adapter->rss_conf;\n\n\t \n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\tif (!p)\n\t\treturn 0;\n\tfor (i = 0; i < rssConf->indTableSize; i++)\n\t\trssConf->indTable[i] = p[i];\n\n\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t       VMXNET3_CMD_UPDATE_RSSIDT);\n\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\n\treturn 0;\n\n}\n#endif\n\nstatic int vmxnet3_get_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *ec,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (!VMXNET3_VERSION_GE_3(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (adapter->coal_conf->coalMode) {\n\tcase VMXNET3_COALESCE_DISABLED:\n\t\t \n\t\tbreak;\n\tcase VMXNET3_COALESCE_ADAPT:\n\t\tec->use_adaptive_rx_coalesce = true;\n\t\tbreak;\n\tcase VMXNET3_COALESCE_STATIC:\n\t\tec->tx_max_coalesced_frames =\n\t\t\tadapter->coal_conf->coalPara.coalStatic.tx_comp_depth;\n\t\tec->rx_max_coalesced_frames =\n\t\t\tadapter->coal_conf->coalPara.coalStatic.rx_depth;\n\t\tbreak;\n\tcase VMXNET3_COALESCE_RBC: {\n\t\tu32 rbc_rate;\n\n\t\trbc_rate = adapter->coal_conf->coalPara.coalRbc.rbc_rate;\n\t\tec->rx_coalesce_usecs = VMXNET3_COAL_RBC_USECS(rbc_rate);\n\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int vmxnet3_set_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *ec,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\tstruct Vmxnet3_DriverShared *shared = adapter->shared;\n\tunion Vmxnet3_CmdInfo *cmdInfo = &shared->cu.cmdInfo;\n\tunsigned long flags;\n\n\tif (!VMXNET3_VERSION_GE_3(adapter))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ec->rx_coalesce_usecs == 0) &&\n\t    (ec->use_adaptive_rx_coalesce == 0) &&\n\t    (ec->tx_max_coalesced_frames == 0) &&\n\t    (ec->rx_max_coalesced_frames == 0)) {\n\t\tmemset(adapter->coal_conf, 0, sizeof(*adapter->coal_conf));\n\t\tadapter->coal_conf->coalMode = VMXNET3_COALESCE_DISABLED;\n\t\tgoto done;\n\t}\n\n\tif (ec->rx_coalesce_usecs != 0) {\n\t\tu32 rbc_rate;\n\n\t\tif ((ec->use_adaptive_rx_coalesce != 0) ||\n\t\t    (ec->tx_max_coalesced_frames != 0) ||\n\t\t    (ec->rx_max_coalesced_frames != 0)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trbc_rate = VMXNET3_COAL_RBC_RATE(ec->rx_coalesce_usecs);\n\t\tif (rbc_rate < VMXNET3_COAL_RBC_MIN_RATE ||\n\t\t    rbc_rate > VMXNET3_COAL_RBC_MAX_RATE) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemset(adapter->coal_conf, 0, sizeof(*adapter->coal_conf));\n\t\tadapter->coal_conf->coalMode = VMXNET3_COALESCE_RBC;\n\t\tadapter->coal_conf->coalPara.coalRbc.rbc_rate = rbc_rate;\n\t\tgoto done;\n\t}\n\n\tif (ec->use_adaptive_rx_coalesce != 0) {\n\t\tif (ec->tx_max_coalesced_frames != 0 ||\n\t\t    ec->rx_max_coalesced_frames != 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemset(adapter->coal_conf, 0, sizeof(*adapter->coal_conf));\n\t\tadapter->coal_conf->coalMode = VMXNET3_COALESCE_ADAPT;\n\t\tgoto done;\n\t}\n\n\tif ((ec->tx_max_coalesced_frames != 0) ||\n\t    (ec->rx_max_coalesced_frames != 0)) {\n\t\tif ((ec->tx_max_coalesced_frames >\n\t\t    VMXNET3_COAL_STATIC_MAX_DEPTH) ||\n\t\t    (ec->rx_max_coalesced_frames >\n\t\t     VMXNET3_COAL_STATIC_MAX_DEPTH)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemset(adapter->coal_conf, 0, sizeof(*adapter->coal_conf));\n\t\tadapter->coal_conf->coalMode = VMXNET3_COALESCE_STATIC;\n\n\t\tadapter->coal_conf->coalPara.coalStatic.tx_comp_depth =\n\t\t\t(ec->tx_max_coalesced_frames ?\n\t\t\t ec->tx_max_coalesced_frames :\n\t\t\t VMXNET3_COAL_STATIC_DEFAULT_DEPTH);\n\n\t\tadapter->coal_conf->coalPara.coalStatic.rx_depth =\n\t\t\t(ec->rx_max_coalesced_frames ?\n\t\t\t ec->rx_max_coalesced_frames :\n\t\t\t VMXNET3_COAL_STATIC_DEFAULT_DEPTH);\n\n\t\tadapter->coal_conf->coalPara.coalStatic.tx_depth =\n\t\t\t VMXNET3_COAL_STATIC_DEFAULT_DEPTH;\n\t\tgoto done;\n\t}\n\ndone:\n\tadapter->default_coal_mode = false;\n\tif (netif_running(netdev)) {\n\t\tspin_lock_irqsave(&adapter->cmd_lock, flags);\n\t\tcmdInfo->varConf.confVer = 1;\n\t\tcmdInfo->varConf.confLen =\n\t\t\tcpu_to_le32(sizeof(*adapter->coal_conf));\n\t\tcmdInfo->varConf.confPA  = cpu_to_le64(adapter->coal_conf_pa);\n\t\tVMXNET3_WRITE_BAR1_REG(adapter, VMXNET3_REG_CMD,\n\t\t\t\t       VMXNET3_CMD_SET_COALESCE);\n\t\tspin_unlock_irqrestore(&adapter->cmd_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void vmxnet3_get_channels(struct net_device *netdev,\n\t\t\t\t struct ethtool_channels *ec)\n{\n\tstruct vmxnet3_adapter *adapter = netdev_priv(netdev);\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI) && adapter->intr.type == VMXNET3_IT_MSIX) {\n\t\tif (adapter->share_intr == VMXNET3_INTR_BUDDYSHARE) {\n\t\t\tec->combined_count = adapter->num_tx_queues;\n\t\t} else {\n\t\t\tec->rx_count = adapter->num_rx_queues;\n\t\t\tec->tx_count =\n\t\t\t\tadapter->share_intr == VMXNET3_INTR_TXSHARE ?\n\t\t\t\t\t       1 : adapter->num_tx_queues;\n\t\t}\n\t} else {\n\t\tec->combined_count = 1;\n\t}\n\n\tec->other_count = 1;\n\n\t \n\t \n\tec->max_rx = ec->rx_count;\n\tec->max_tx = ec->tx_count;\n\tec->max_combined = ec->combined_count;\n\tec->max_other = ec->other_count;\n}\n\nstatic const struct ethtool_ops vmxnet3_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_drvinfo       = vmxnet3_get_drvinfo,\n\t.get_regs_len      = vmxnet3_get_regs_len,\n\t.get_regs          = vmxnet3_get_regs,\n\t.get_wol           = vmxnet3_get_wol,\n\t.set_wol           = vmxnet3_set_wol,\n\t.get_link          = ethtool_op_get_link,\n\t.get_coalesce      = vmxnet3_get_coalesce,\n\t.set_coalesce      = vmxnet3_set_coalesce,\n\t.get_strings       = vmxnet3_get_strings,\n\t.get_sset_count\t   = vmxnet3_get_sset_count,\n\t.get_ethtool_stats = vmxnet3_get_ethtool_stats,\n\t.get_ringparam     = vmxnet3_get_ringparam,\n\t.set_ringparam     = vmxnet3_set_ringparam,\n\t.get_rxnfc         = vmxnet3_get_rxnfc,\n\t.set_rxnfc         = vmxnet3_set_rxnfc,\n#ifdef VMXNET3_RSS\n\t.get_rxfh_indir_size = vmxnet3_get_rss_indir_size,\n\t.get_rxfh          = vmxnet3_get_rss,\n\t.set_rxfh          = vmxnet3_set_rss,\n#endif\n\t.get_link_ksettings = vmxnet3_get_link_ksettings,\n\t.get_channels      = vmxnet3_get_channels,\n};\n\nvoid vmxnet3_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &vmxnet3_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}