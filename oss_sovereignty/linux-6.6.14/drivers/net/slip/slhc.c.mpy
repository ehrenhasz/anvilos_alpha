{
  "module_name": "slhc.c",
  "hash_id": "6a87417c903c4bb6dd41a19e0d978a36e4c2faa26e26836e6933fd939d5d7393",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/slip/slhc.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <net/slhc_vj.h>\n\n#ifdef CONFIG_INET\n \n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/termios.h>\n#include <linux/in.h>\n#include <linux/fcntl.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/icmp.h>\n#include <net/tcp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/timer.h>\n#include <linux/uaccess.h>\n#include <net/checksum.h>\n#include <asm/unaligned.h>\n\nstatic unsigned char *encode(unsigned char *cp, unsigned short n);\nstatic long decode(unsigned char **cpp);\nstatic unsigned char * put16(unsigned char *cp, unsigned short x);\nstatic unsigned short pull16(unsigned char **cpp);\n\n \nstruct slcompress *\nslhc_init(int rslots, int tslots)\n{\n\tshort i;\n\tstruct cstate *ts;\n\tstruct slcompress *comp;\n\n\tif (rslots < 0 || rslots > 255 || tslots < 0 || tslots > 255)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcomp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);\n\tif (! comp)\n\t\tgoto out_fail;\n\n\tif (rslots > 0) {\n\t\tsize_t rsize = rslots * sizeof(struct cstate);\n\t\tcomp->rstate = kzalloc(rsize, GFP_KERNEL);\n\t\tif (! comp->rstate)\n\t\t\tgoto out_free;\n\t\tcomp->rslot_limit = rslots - 1;\n\t}\n\n\tif (tslots > 0) {\n\t\tsize_t tsize = tslots * sizeof(struct cstate);\n\t\tcomp->tstate = kzalloc(tsize, GFP_KERNEL);\n\t\tif (! comp->tstate)\n\t\t\tgoto out_free2;\n\t\tcomp->tslot_limit = tslots - 1;\n\t}\n\n\tcomp->xmit_oldest = 0;\n\tcomp->xmit_current = 255;\n\tcomp->recv_current = 255;\n\t \n\tcomp->flags |= SLF_TOSS;\n\n\tif ( tslots > 0 ) {\n\t\tts = comp->tstate;\n\t\tfor(i = comp->tslot_limit; i > 0; --i){\n\t\t\tts[i].cs_this = i;\n\t\t\tts[i].next = &(ts[i - 1]);\n\t\t}\n\t\tts[0].next = &(ts[comp->tslot_limit]);\n\t\tts[0].cs_this = 0;\n\t}\n\treturn comp;\n\nout_free2:\n\tkfree(comp->rstate);\nout_free:\n\tkfree(comp);\nout_fail:\n\treturn ERR_PTR(-ENOMEM);\n}\n\n\n \nvoid\nslhc_free(struct slcompress *comp)\n{\n\tif ( IS_ERR_OR_NULL(comp) )\n\t\treturn;\n\n\tif ( comp->tstate != NULLSLSTATE )\n\t\tkfree( comp->tstate );\n\n\tif ( comp->rstate != NULLSLSTATE )\n\t\tkfree( comp->rstate );\n\n\tkfree( comp );\n}\n\n\n \nstatic inline unsigned char *\nput16(unsigned char *cp, unsigned short x)\n{\n\t*cp++ = x >> 8;\n\t*cp++ = x;\n\n\treturn cp;\n}\n\n\n \nstatic unsigned char *\nencode(unsigned char *cp, unsigned short n)\n{\n\tif(n >= 256 || n == 0){\n\t\t*cp++ = 0;\n\t\tcp = put16(cp,n);\n\t} else {\n\t\t*cp++ = n;\n\t}\n\treturn cp;\n}\n\n \nstatic unsigned short\npull16(unsigned char **cpp)\n{\n\tshort rval;\n\n\trval = *(*cpp)++;\n\trval <<= 8;\n\trval |= *(*cpp)++;\n\treturn rval;\n}\n\n \nstatic long\ndecode(unsigned char **cpp)\n{\n\tint x;\n\n\tx = *(*cpp)++;\n\tif(x == 0){\n\t\treturn pull16(cpp) & 0xffff;\t \n\t} else {\n\t\treturn x & 0xff;\t\t \n\t}\n}\n\n \n\nint\nslhc_compress(struct slcompress *comp, unsigned char *icp, int isize,\n\tunsigned char *ocp, unsigned char **cpp, int compress_cid)\n{\n\tstruct cstate *ocs = &(comp->tstate[comp->xmit_oldest]);\n\tstruct cstate *lcs = ocs;\n\tstruct cstate *cs = lcs->next;\n\tunsigned long deltaS, deltaA;\n\tshort changes = 0;\n\tint nlen, hlen;\n\tunsigned char new_seq[16];\n\tunsigned char *cp = new_seq;\n\tstruct iphdr *ip;\n\tstruct tcphdr *th, *oth;\n\t__sum16 csum;\n\n\n\t \n\n\tif(isize<sizeof(struct iphdr))\n\t\treturn isize;\n\n\tip = (struct iphdr *) icp;\n\tif (ip->version != 4 || ip->ihl < 5)\n\t\treturn isize;\n\n\t \n\tif (ip->protocol != IPPROTO_TCP || (ntohs(ip->frag_off) & 0x3fff)) {\n\t\t \n\t\tif(ip->protocol != IPPROTO_TCP)\n\t\t\tcomp->sls_o_nontcp++;\n\t\telse\n\t\t\tcomp->sls_o_tcp++;\n\t\treturn isize;\n\t}\n\tnlen = ip->ihl * 4;\n\tif (isize < nlen + sizeof(*th))\n\t\treturn isize;\n\n\tth = (struct tcphdr *)(icp + nlen);\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn isize;\n\thlen = nlen + th->doff * 4;\n\n\t \n\tif(hlen > isize || th->syn || th->fin || th->rst ||\n\t    ! (th->ack)){\n\t\t \n\t\tcomp->sls_o_tcp++;\n\t\treturn isize;\n\t}\n\t \n\tfor ( ; ; ) {\n\t\tif( ip->saddr == cs->cs_ip.saddr\n\t\t && ip->daddr == cs->cs_ip.daddr\n\t\t && th->source == cs->cs_tcp.source\n\t\t && th->dest == cs->cs_tcp.dest)\n\t\t\tgoto found;\n\n\t\t \n\t\tif ( cs == ocs )\n\t\t\tbreak;\n\t\tlcs = cs;\n\t\tcs = cs->next;\n\t\tcomp->sls_o_searches++;\n\t}\n\t \n\tcomp->sls_o_misses++;\n\tcomp->xmit_oldest = lcs->cs_this;\n\tgoto uncompressed;\n\nfound:\n\t \n\tif(lcs == ocs) {\n\t\t \n\t} else if (cs == ocs) {\n\t\t \n\t\tcomp->xmit_oldest = lcs->cs_this;\n\t} else {\n\t\t \n\t\tlcs->next = cs->next;\n\t\tcs->next = ocs->next;\n\t\tocs->next = cs;\n\t}\n\n\t \n\toth = &cs->cs_tcp;\n\n\tif(ip->version != cs->cs_ip.version || ip->ihl != cs->cs_ip.ihl\n\t || ip->tos != cs->cs_ip.tos\n\t || (ip->frag_off & htons(0x4000)) != (cs->cs_ip.frag_off & htons(0x4000))\n\t || ip->ttl != cs->cs_ip.ttl\n\t || th->doff != cs->cs_tcp.doff\n\t || (ip->ihl > 5 && memcmp(ip+1,cs->cs_ipopt,((ip->ihl)-5)*4) != 0)\n\t || (th->doff > 5 && memcmp(th+1,cs->cs_tcpopt,((th->doff)-5)*4) != 0)){\n\t\tgoto uncompressed;\n\t}\n\n\t \n\tif(th->urg){\n\t\tdeltaS = ntohs(th->urg_ptr);\n\t\tcp = encode(cp,deltaS);\n\t\tchanges |= NEW_U;\n\t} else if(th->urg_ptr != oth->urg_ptr){\n\t\t \n\t\tgoto uncompressed;\n\t}\n\tif((deltaS = ntohs(th->window) - ntohs(oth->window)) != 0){\n\t\tcp = encode(cp,deltaS);\n\t\tchanges |= NEW_W;\n\t}\n\tif((deltaA = ntohl(th->ack_seq) - ntohl(oth->ack_seq)) != 0L){\n\t\tif(deltaA > 0x0000ffff)\n\t\t\tgoto uncompressed;\n\t\tcp = encode(cp,deltaA);\n\t\tchanges |= NEW_A;\n\t}\n\tif((deltaS = ntohl(th->seq) - ntohl(oth->seq)) != 0L){\n\t\tif(deltaS > 0x0000ffff)\n\t\t\tgoto uncompressed;\n\t\tcp = encode(cp,deltaS);\n\t\tchanges |= NEW_S;\n\t}\n\n\tswitch(changes){\n\tcase 0:\t \n\t\tif(ip->tot_len != cs->cs_ip.tot_len &&\n\t\t   ntohs(cs->cs_ip.tot_len) == hlen)\n\t\t\tbreak;\n\t\tgoto uncompressed;\n\tcase SPECIAL_I:\n\tcase SPECIAL_D:\n\t\t \n\t\tgoto uncompressed;\n\tcase NEW_S|NEW_A:\n\t\tif(deltaS == deltaA &&\n\t\t    deltaS == ntohs(cs->cs_ip.tot_len) - hlen){\n\t\t\t \n\t\t\tchanges = SPECIAL_I;\n\t\t\tcp = new_seq;\n\t\t}\n\t\tbreak;\n\tcase NEW_S:\n\t\tif(deltaS == ntohs(cs->cs_ip.tot_len) - hlen){\n\t\t\t \n\t\t\tchanges = SPECIAL_D;\n\t\t\tcp = new_seq;\n\t\t}\n\t\tbreak;\n\t}\n\tdeltaS = ntohs(ip->id) - ntohs(cs->cs_ip.id);\n\tif(deltaS != 1){\n\t\tcp = encode(cp,deltaS);\n\t\tchanges |= NEW_I;\n\t}\n\tif(th->psh)\n\t\tchanges |= TCP_PUSH_BIT;\n\t \n\tcsum = th->check;\n\tmemcpy(&cs->cs_ip,ip,20);\n\tmemcpy(&cs->cs_tcp,th,20);\n\t \n\tdeltaS = cp - new_seq;\n\tif(compress_cid == 0 || comp->xmit_current != cs->cs_this){\n\t\tcp = ocp;\n\t\t*cpp = ocp;\n\t\t*cp++ = changes | NEW_C;\n\t\t*cp++ = cs->cs_this;\n\t\tcomp->xmit_current = cs->cs_this;\n\t} else {\n\t\tcp = ocp;\n\t\t*cpp = ocp;\n\t\t*cp++ = changes;\n\t}\n\t*(__sum16 *)cp = csum;\n\tcp += 2;\n \n\tmemcpy(cp,new_seq,deltaS);\t \n\tmemcpy(cp+deltaS,icp+hlen,isize-hlen);\n\tcomp->sls_o_compressed++;\n\tocp[0] |= SL_TYPE_COMPRESSED_TCP;\n\treturn isize - hlen + deltaS + (cp - ocp);\n\n\t \nuncompressed:\n\tmemcpy(&cs->cs_ip,ip,20);\n\tmemcpy(&cs->cs_tcp,th,20);\n\tif (ip->ihl > 5)\n\t  memcpy(cs->cs_ipopt, ip+1, ((ip->ihl) - 5) * 4);\n\tif (th->doff > 5)\n\t  memcpy(cs->cs_tcpopt, th+1, ((th->doff) - 5) * 4);\n\tcomp->xmit_current = cs->cs_this;\n\tcomp->sls_o_uncompressed++;\n\tmemcpy(ocp, icp, isize);\n\t*cpp = ocp;\n\tocp[9] = cs->cs_this;\n\tocp[0] |= SL_TYPE_UNCOMPRESSED_TCP;\n\treturn isize;\n}\n\n\nint\nslhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)\n{\n\tint changes;\n\tlong x;\n\tstruct tcphdr *thp;\n\tstruct iphdr *ip;\n\tstruct cstate *cs;\n\tint len, hdrlen;\n\tunsigned char *cp = icp;\n\n\t \n\tcomp->sls_i_compressed++;\n\tif(isize < 3){\n\t\tcomp->sls_i_error++;\n\t\treturn 0;\n\t}\n\tchanges = *cp++;\n\tif(changes & NEW_C){\n\t\t \n\t\tx = *cp++;\t \n\t\tif(x < 0 || x > comp->rslot_limit)\n\t\t\tgoto bad;\n\n\t\t \n\t\tif (!comp->rstate[x].initialized)\n\t\t\tgoto bad;\n\n\t\tcomp->flags &=~ SLF_TOSS;\n\t\tcomp->recv_current = x;\n\t} else {\n\t\t \n\t\tif(comp->flags & SLF_TOSS){\n\t\t\tcomp->sls_i_tossed++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcs = &comp->rstate[comp->recv_current];\n\tthp = &cs->cs_tcp;\n\tip = &cs->cs_ip;\n\n\tthp->check = *(__sum16 *)cp;\n\tcp += 2;\n\n\tthp->psh = (changes & TCP_PUSH_BIT) ? 1 : 0;\n \n\n\thdrlen = ip->ihl * 4 + thp->doff * 4;\n\n\tswitch(changes & SPECIALS_MASK){\n\tcase SPECIAL_I:\t\t \n\t\t{\n\t\tshort i;\n\t\ti = ntohs(ip->tot_len) - hdrlen;\n\t\tthp->ack_seq = htonl( ntohl(thp->ack_seq) + i);\n\t\tthp->seq = htonl( ntohl(thp->seq) + i);\n\t\t}\n\t\tbreak;\n\n\tcase SPECIAL_D:\t\t\t \n\t\tthp->seq = htonl( ntohl(thp->seq) +\n\t\t\t\t  ntohs(ip->tot_len) - hdrlen);\n\t\tbreak;\n\n\tdefault:\n\t\tif(changes & NEW_U){\n\t\t\tthp->urg = 1;\n\t\t\tif((x = decode(&cp)) == -1) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tthp->urg_ptr = htons(x);\n\t\t} else\n\t\t\tthp->urg = 0;\n\t\tif(changes & NEW_W){\n\t\t\tif((x = decode(&cp)) == -1) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tthp->window = htons( ntohs(thp->window) + x);\n\t\t}\n\t\tif(changes & NEW_A){\n\t\t\tif((x = decode(&cp)) == -1) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tthp->ack_seq = htonl( ntohl(thp->ack_seq) + x);\n\t\t}\n\t\tif(changes & NEW_S){\n\t\t\tif((x = decode(&cp)) == -1) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tthp->seq = htonl( ntohl(thp->seq) + x);\n\t\t}\n\t\tbreak;\n\t}\n\tif(changes & NEW_I){\n\t\tif((x = decode(&cp)) == -1) {\n\t\t\tgoto bad;\n\t\t}\n\t\tip->id = htons (ntohs (ip->id) + x);\n\t} else\n\t\tip->id = htons (ntohs (ip->id) + 1);\n\n\t \n\n\tlen = isize - (cp - icp);\n\tif (len < 0)\n\t\tgoto bad;\n\tlen += hdrlen;\n\tip->tot_len = htons(len);\n\tip->check = 0;\n\n\tmemmove(icp + hdrlen, cp, len - hdrlen);\n\n\tcp = icp;\n\tmemcpy(cp, ip, 20);\n\tcp += 20;\n\n\tif (ip->ihl > 5) {\n\t  memcpy(cp, cs->cs_ipopt, (ip->ihl - 5) * 4);\n\t  cp += (ip->ihl - 5) * 4;\n\t}\n\n\tput_unaligned(ip_fast_csum(icp, ip->ihl),\n\t\t      &((struct iphdr *)icp)->check);\n\n\tmemcpy(cp, thp, 20);\n\tcp += 20;\n\n\tif (thp->doff > 5) {\n\t  memcpy(cp, cs->cs_tcpopt, ((thp->doff) - 5) * 4);\n\t  cp += ((thp->doff) - 5) * 4;\n\t}\n\n\treturn len;\nbad:\n\tcomp->sls_i_error++;\n\treturn slhc_toss( comp );\n}\n\n\nint\nslhc_remember(struct slcompress *comp, unsigned char *icp, int isize)\n{\n\tstruct cstate *cs;\n\tunsigned ihl;\n\n\tunsigned char index;\n\n\tif(isize < 20) {\n\t\t \n\t\tcomp->sls_i_runt++;\n\t\treturn slhc_toss( comp );\n\t}\n\t \n\tihl = icp[0] & 0xf;\n\tif(ihl < 20 / 4){\n\t\t \n\t\tcomp->sls_i_runt++;\n\t\treturn slhc_toss( comp );\n\t}\n\tindex = icp[9];\n\ticp[9] = IPPROTO_TCP;\n\n\tif (ip_fast_csum(icp, ihl)) {\n\t\t \n\t\tcomp->sls_i_badcheck++;\n\t\treturn slhc_toss( comp );\n\t}\n\tif(index > comp->rslot_limit) {\n\t\tcomp->sls_i_error++;\n\t\treturn slhc_toss(comp);\n\t}\n\n\t \n\tcs = &comp->rstate[comp->recv_current = index];\n\tcomp->flags &=~ SLF_TOSS;\n\tmemcpy(&cs->cs_ip,icp,20);\n\tmemcpy(&cs->cs_tcp,icp + ihl*4,20);\n\tif (ihl > 5)\n\t  memcpy(cs->cs_ipopt, icp + sizeof(struct iphdr), (ihl - 5) * 4);\n\tif (cs->cs_tcp.doff > 5)\n\t  memcpy(cs->cs_tcpopt, icp + ihl*4 + sizeof(struct tcphdr), (cs->cs_tcp.doff - 5) * 4);\n\tcs->cs_hsize = ihl*2 + cs->cs_tcp.doff*2;\n\tcs->initialized = true;\n\t \n\tcomp->sls_i_uncompressed++;\n\treturn isize;\n}\n\nint\nslhc_toss(struct slcompress *comp)\n{\n\tif ( comp == NULLSLCOMPR )\n\t\treturn 0;\n\n\tcomp->flags |= SLF_TOSS;\n\treturn 0;\n}\n\n#else  \n\nint\nslhc_toss(struct slcompress *comp)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_toss\");\n  return -EINVAL;\n}\nint\nslhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_uncompress\");\n  return -EINVAL;\n}\nint\nslhc_compress(struct slcompress *comp, unsigned char *icp, int isize,\n\tunsigned char *ocp, unsigned char **cpp, int compress_cid)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_compress\");\n  return -EINVAL;\n}\n\nint\nslhc_remember(struct slcompress *comp, unsigned char *icp, int isize)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_remember\");\n  return -EINVAL;\n}\n\nvoid\nslhc_free(struct slcompress *comp)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_free\");\n}\nstruct slcompress *\nslhc_init(int rslots, int tslots)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_init\");\n  return NULL;\n}\n\n#endif  \n\n \nEXPORT_SYMBOL(slhc_init);\nEXPORT_SYMBOL(slhc_free);\nEXPORT_SYMBOL(slhc_remember);\nEXPORT_SYMBOL(slhc_compress);\nEXPORT_SYMBOL(slhc_uncompress);\nEXPORT_SYMBOL(slhc_toss);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}