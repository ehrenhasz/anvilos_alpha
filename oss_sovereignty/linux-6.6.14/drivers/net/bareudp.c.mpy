{
  "module_name": "bareudp.c",
  "hash_id": "9f7f7c0f33afed5126ea355b39e86e13a21baa207569c3b831c367c62eb99f6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bareudp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/hash.h>\n#include <net/dst_metadata.h>\n#include <net/gro_cells.h>\n#include <net/rtnetlink.h>\n#include <net/protocol.h>\n#include <net/ip6_tunnel.h>\n#include <net/ip_tunnels.h>\n#include <net/udp_tunnel.h>\n#include <net/bareudp.h>\n\n#define BAREUDP_BASE_HLEN sizeof(struct udphdr)\n#define BAREUDP_IPV4_HLEN (sizeof(struct iphdr) + \\\n\t\t\t   sizeof(struct udphdr))\n#define BAREUDP_IPV6_HLEN (sizeof(struct ipv6hdr) + \\\n\t\t\t   sizeof(struct udphdr))\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\n \n\nstatic unsigned int bareudp_net_id;\n\nstruct bareudp_net {\n\tstruct list_head        bareudp_list;\n};\n\nstruct bareudp_conf {\n\t__be16 ethertype;\n\t__be16 port;\n\tu16 sport_min;\n\tbool multi_proto_mode;\n};\n\n \nstruct bareudp_dev {\n\tstruct net         *net;         \n\tstruct net_device  *dev;         \n\t__be16\t\t   ethertype;\n\t__be16             port;\n\tu16\t           sport_min;\n\tbool               multi_proto_mode;\n\tstruct socket      __rcu *sock;\n\tstruct list_head   next;         \n\tstruct gro_cells   gro_cells;\n};\n\nstatic int bareudp_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct metadata_dst *tun_dst = NULL;\n\tstruct bareudp_dev *bareudp;\n\tunsigned short family;\n\tunsigned int len;\n\t__be16 proto;\n\tvoid *oiph;\n\tint err;\n\n\tbareudp = rcu_dereference_sk_user_data(sk);\n\tif (!bareudp)\n\t\tgoto drop;\n\n\tif (skb->protocol ==  htons(ETH_P_IP))\n\t\tfamily = AF_INET;\n\telse\n\t\tfamily = AF_INET6;\n\n\tif (bareudp->ethertype == htons(ETH_P_IP)) {\n\t\t__u8 ipversion;\n\n\t\tif (skb_copy_bits(skb, BAREUDP_BASE_HLEN, &ipversion,\n\t\t\t\t  sizeof(ipversion))) {\n\t\t\tbareudp->dev->stats.rx_dropped++;\n\t\t\tgoto drop;\n\t\t}\n\t\tipversion >>= 4;\n\n\t\tif (ipversion == 4) {\n\t\t\tproto = htons(ETH_P_IP);\n\t\t} else if (ipversion == 6 && bareudp->multi_proto_mode) {\n\t\t\tproto = htons(ETH_P_IPV6);\n\t\t} else {\n\t\t\tbareudp->dev->stats.rx_dropped++;\n\t\t\tgoto drop;\n\t\t}\n\t} else if (bareudp->ethertype == htons(ETH_P_MPLS_UC)) {\n\t\tstruct iphdr *tunnel_hdr;\n\n\t\ttunnel_hdr = (struct iphdr *)skb_network_header(skb);\n\t\tif (tunnel_hdr->version == 4) {\n\t\t\tif (!ipv4_is_multicast(tunnel_hdr->daddr)) {\n\t\t\t\tproto = bareudp->ethertype;\n\t\t\t} else if (bareudp->multi_proto_mode &&\n\t\t\t\t   ipv4_is_multicast(tunnel_hdr->daddr)) {\n\t\t\t\tproto = htons(ETH_P_MPLS_MC);\n\t\t\t} else {\n\t\t\t\tbareudp->dev->stats.rx_dropped++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t} else {\n\t\t\tint addr_type;\n\t\t\tstruct ipv6hdr *tunnel_hdr_v6;\n\n\t\t\ttunnel_hdr_v6 = (struct ipv6hdr *)skb_network_header(skb);\n\t\t\taddr_type =\n\t\t\tipv6_addr_type((struct in6_addr *)&tunnel_hdr_v6->daddr);\n\t\t\tif (!(addr_type & IPV6_ADDR_MULTICAST)) {\n\t\t\t\tproto = bareudp->ethertype;\n\t\t\t} else if (bareudp->multi_proto_mode &&\n\t\t\t\t   (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\t\t\tproto = htons(ETH_P_MPLS_MC);\n\t\t\t} else {\n\t\t\t\tbareudp->dev->stats.rx_dropped++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tproto = bareudp->ethertype;\n\t}\n\n\tif (iptunnel_pull_header(skb, BAREUDP_BASE_HLEN,\n\t\t\t\t proto,\n\t\t\t\t !net_eq(bareudp->net,\n\t\t\t\t dev_net(bareudp->dev)))) {\n\t\tbareudp->dev->stats.rx_dropped++;\n\t\tgoto drop;\n\t}\n\ttun_dst = udp_tun_rx_dst(skb, family, TUNNEL_KEY, 0, 0);\n\tif (!tun_dst) {\n\t\tbareudp->dev->stats.rx_dropped++;\n\t\tgoto drop;\n\t}\n\tskb_dst_set(skb, &tun_dst->dst);\n\tskb->dev = bareudp->dev;\n\toiph = skb_network_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\tif (!ipv6_mod_enabled() || family == AF_INET)\n\t\terr = IP_ECN_decapsulate(oiph, skb);\n\telse\n\t\terr = IP6_ECN_decapsulate(oiph, skb);\n\n\tif (unlikely(err)) {\n\t\tif (log_ecn_error) {\n\t\t\tif  (!ipv6_mod_enabled() || family == AF_INET)\n\t\t\t\tnet_info_ratelimited(\"non-ECT from %pI4 \"\n\t\t\t\t\t\t     \"with TOS=%#x\\n\",\n\t\t\t\t\t\t     &((struct iphdr *)oiph)->saddr,\n\t\t\t\t\t\t     ((struct iphdr *)oiph)->tos);\n\t\t\telse\n\t\t\t\tnet_info_ratelimited(\"non-ECT from %pI6\\n\",\n\t\t\t\t\t\t     &((struct ipv6hdr *)oiph)->saddr);\n\t\t}\n\t\tif (err > 1) {\n\t\t\t++bareudp->dev->stats.rx_frame_errors;\n\t\t\t++bareudp->dev->stats.rx_errors;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tlen = skb->len;\n\terr = gro_cells_receive(&bareudp->gro_cells, skb);\n\tif (likely(err == NET_RX_SUCCESS))\n\t\tdev_sw_netstats_rx_add(bareudp->dev, len);\n\n\treturn 0;\ndrop:\n\t \n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int bareudp_err_lookup(struct sock *sk, struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic int bareudp_init(struct net_device *dev)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\tint err;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = gro_cells_init(&bareudp->gro_cells, dev);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void bareudp_uninit(struct net_device *dev)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\n\tgro_cells_destroy(&bareudp->gro_cells);\n\tfree_percpu(dev->tstats);\n}\n\nstatic struct socket *bareudp_create_sock(struct net *net, __be16 port)\n{\n\tstruct udp_port_cfg udp_conf;\n\tstruct socket *sock;\n\tint err;\n\n\tmemset(&udp_conf, 0, sizeof(udp_conf));\n\n\tif (ipv6_mod_enabled())\n\t\tudp_conf.family = AF_INET6;\n\telse\n\t\tudp_conf.family = AF_INET;\n\n\tudp_conf.local_udp_port = port;\n\t \n\terr = udp_sock_create(net, &udp_conf, &sock);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tudp_allow_gso(sock->sk);\n\treturn sock;\n}\n\n \nstatic int bareudp_socket_create(struct bareudp_dev *bareudp, __be16 port)\n{\n\tstruct udp_tunnel_sock_cfg tunnel_cfg;\n\tstruct socket *sock;\n\n\tsock = bareudp_create_sock(bareudp->net, port);\n\tif (IS_ERR(sock))\n\t\treturn PTR_ERR(sock);\n\n\t \n\tmemset(&tunnel_cfg, 0, sizeof(tunnel_cfg));\n\ttunnel_cfg.sk_user_data = bareudp;\n\ttunnel_cfg.encap_type = 1;\n\ttunnel_cfg.encap_rcv = bareudp_udp_encap_recv;\n\ttunnel_cfg.encap_err_lookup = bareudp_err_lookup;\n\ttunnel_cfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(bareudp->net, sock, &tunnel_cfg);\n\n\trcu_assign_pointer(bareudp->sock, sock);\n\treturn 0;\n}\n\nstatic int bareudp_open(struct net_device *dev)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\tint ret = 0;\n\n\tret =  bareudp_socket_create(bareudp, bareudp->port);\n\treturn ret;\n}\n\nstatic void bareudp_sock_release(struct bareudp_dev *bareudp)\n{\n\tstruct socket *sock;\n\n\tsock = bareudp->sock;\n\trcu_assign_pointer(bareudp->sock, NULL);\n\tsynchronize_net();\n\tudp_tunnel_sock_release(sock);\n}\n\nstatic int bareudp_stop(struct net_device *dev)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\n\tbareudp_sock_release(bareudp);\n\treturn 0;\n}\n\nstatic int bareudp_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    struct bareudp_dev *bareudp,\n\t\t\t    const struct ip_tunnel_info *info)\n{\n\tbool xnet = !net_eq(bareudp->net, dev_net(bareudp->dev));\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct socket *sock = rcu_dereference(bareudp->sock);\n\tbool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\tconst struct ip_tunnel_key *key = &info->key;\n\tstruct rtable *rt;\n\t__be16 sport, df;\n\tint min_headroom;\n\t__u8 tos, ttl;\n\t__be32 saddr;\n\tint err;\n\n\tif (!sock)\n\t\treturn -ESHUTDOWN;\n\n\trt = ip_route_output_tunnel(skb, dev, bareudp->net, &saddr, info,\n\t\t\t\t    IPPROTO_UDP, use_cache);\n\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tskb_tunnel_check_pmtu(skb, &rt->dst,\n\t\t\t      BAREUDP_IPV4_HLEN + info->options_len, false);\n\n\tsport = udp_flow_src_port(bareudp->net, skb,\n\t\t\t\t  bareudp->sport_min, USHRT_MAX,\n\t\t\t\t  true);\n\ttos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\tttl = key->ttl;\n\tdf = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\n\tskb_scrub_packet(skb, xnet);\n\n\terr = -ENOSPC;\n\tif (!skb_pull(skb, skb_network_offset(skb)))\n\t\tgoto free_dst;\n\n\tmin_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len +\n\t\tBAREUDP_BASE_HLEN + info->options_len + sizeof(struct iphdr);\n\n\terr = skb_cow_head(skb, min_headroom);\n\tif (unlikely(err))\n\t\tgoto free_dst;\n\n\terr = udp_tunnel_handle_offloads(skb, udp_sum);\n\tif (err)\n\t\tgoto free_dst;\n\n\tskb_set_inner_protocol(skb, bareudp->ethertype);\n\tudp_tunnel_xmit_skb(rt, sock->sk, skb, saddr, info->key.u.ipv4.dst,\n\t\t\t    tos, ttl, df, sport, bareudp->port,\n\t\t\t    !net_eq(bareudp->net, dev_net(bareudp->dev)),\n\t\t\t    !(info->key.tun_flags & TUNNEL_CSUM));\n\treturn 0;\n\nfree_dst:\n\tdst_release(&rt->dst);\n\treturn err;\n}\n\nstatic int bareudp6_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct bareudp_dev *bareudp,\n\t\t\t     const struct ip_tunnel_info *info)\n{\n\tbool xnet = !net_eq(bareudp->net, dev_net(bareudp->dev));\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct socket *sock  = rcu_dereference(bareudp->sock);\n\tbool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\tconst struct ip_tunnel_key *key = &info->key;\n\tstruct dst_entry *dst = NULL;\n\tstruct in6_addr saddr, daddr;\n\tint min_headroom;\n\t__u8 prio, ttl;\n\t__be16 sport;\n\tint err;\n\n\tif (!sock)\n\t\treturn -ESHUTDOWN;\n\n\tdst = ip6_dst_lookup_tunnel(skb, dev, bareudp->net, sock, &saddr, info,\n\t\t\t\t    IPPROTO_UDP, use_cache);\n\tif (IS_ERR(dst))\n\t\treturn PTR_ERR(dst);\n\n\tskb_tunnel_check_pmtu(skb, dst, BAREUDP_IPV6_HLEN + info->options_len,\n\t\t\t      false);\n\n\tsport = udp_flow_src_port(bareudp->net, skb,\n\t\t\t\t  bareudp->sport_min, USHRT_MAX,\n\t\t\t\t  true);\n\tprio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\tttl = key->ttl;\n\n\tskb_scrub_packet(skb, xnet);\n\n\terr = -ENOSPC;\n\tif (!skb_pull(skb, skb_network_offset(skb)))\n\t\tgoto free_dst;\n\n\tmin_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len +\n\t\tBAREUDP_BASE_HLEN + info->options_len + sizeof(struct ipv6hdr);\n\n\terr = skb_cow_head(skb, min_headroom);\n\tif (unlikely(err))\n\t\tgoto free_dst;\n\n\terr = udp_tunnel_handle_offloads(skb, udp_sum);\n\tif (err)\n\t\tgoto free_dst;\n\n\tdaddr = info->key.u.ipv6.dst;\n\tudp_tunnel6_xmit_skb(dst, sock->sk, skb, dev,\n\t\t\t     &saddr, &daddr, prio, ttl,\n\t\t\t     info->key.label, sport, bareudp->port,\n\t\t\t     !(info->key.tun_flags & TUNNEL_CSUM));\n\treturn 0;\n\nfree_dst:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic bool bareudp_proto_valid(struct bareudp_dev *bareudp, __be16 proto)\n{\n\tif (bareudp->ethertype == proto)\n\t\treturn true;\n\n\tif (!bareudp->multi_proto_mode)\n\t\treturn false;\n\n\tif (bareudp->ethertype == htons(ETH_P_MPLS_UC) &&\n\t    proto == htons(ETH_P_MPLS_MC))\n\t\treturn true;\n\n\tif (bareudp->ethertype == htons(ETH_P_IP) &&\n\t    proto == htons(ETH_P_IPV6))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic netdev_tx_t bareudp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\tstruct ip_tunnel_info *info = NULL;\n\tint err;\n\n\tif (!bareudp_proto_valid(bareudp, skb->protocol)) {\n\t\terr = -EINVAL;\n\t\tgoto tx_error;\n\t}\n\n\tinfo = skb_tunnel_info(skb);\n\tif (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {\n\t\terr = -EINVAL;\n\t\tgoto tx_error;\n\t}\n\n\trcu_read_lock();\n\tif (ipv6_mod_enabled() && info->mode & IP_TUNNEL_INFO_IPV6)\n\t\terr = bareudp6_xmit_skb(skb, dev, bareudp, info);\n\telse\n\t\terr = bareudp_xmit_skb(skb, dev, bareudp, info);\n\n\trcu_read_unlock();\n\n\tif (likely(!err))\n\t\treturn NETDEV_TX_OK;\ntx_error:\n\tdev_kfree_skb(skb);\n\n\tif (err == -ELOOP)\n\t\tdev->stats.collisions++;\n\telse if (err == -ENETUNREACH)\n\t\tdev->stats.tx_carrier_errors++;\n\n\tdev->stats.tx_errors++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int bareudp_fill_metadata_dst(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ip_tunnel_info *info = skb_tunnel_info(skb);\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\tbool use_cache;\n\n\tuse_cache = ip_tunnel_dst_cache_usable(skb, info);\n\n\tif (!ipv6_mod_enabled() || ip_tunnel_info_af(info) == AF_INET) {\n\t\tstruct rtable *rt;\n\t\t__be32 saddr;\n\n\t\trt = ip_route_output_tunnel(skb, dev, bareudp->net, &saddr,\n\t\t\t\t\t    info, IPPROTO_UDP, use_cache);\n\t\tif (IS_ERR(rt))\n\t\t\treturn PTR_ERR(rt);\n\n\t\tip_rt_put(rt);\n\t\tinfo->key.u.ipv4.src = saddr;\n\t} else if (ip_tunnel_info_af(info) == AF_INET6) {\n\t\tstruct dst_entry *dst;\n\t\tstruct in6_addr saddr;\n\t\tstruct socket *sock = rcu_dereference(bareudp->sock);\n\n\t\tdst = ip6_dst_lookup_tunnel(skb, dev, bareudp->net, sock,\n\t\t\t\t\t    &saddr, info, IPPROTO_UDP,\n\t\t\t\t\t    use_cache);\n\t\tif (IS_ERR(dst))\n\t\t\treturn PTR_ERR(dst);\n\n\t\tdst_release(dst);\n\t\tinfo->key.u.ipv6.src = saddr;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->key.tp_src = udp_flow_src_port(bareudp->net, skb,\n\t\t\t\t\t     bareudp->sport_min,\n\t\t\tUSHRT_MAX, true);\n\tinfo->key.tp_dst = bareudp->port;\n\treturn 0;\n}\n\nstatic const struct net_device_ops bareudp_netdev_ops = {\n\t.ndo_init               = bareudp_init,\n\t.ndo_uninit             = bareudp_uninit,\n\t.ndo_open               = bareudp_open,\n\t.ndo_stop               = bareudp_stop,\n\t.ndo_start_xmit         = bareudp_xmit,\n\t.ndo_get_stats64        = dev_get_tstats64,\n\t.ndo_fill_metadata_dst  = bareudp_fill_metadata_dst,\n};\n\nstatic const struct nla_policy bareudp_policy[IFLA_BAREUDP_MAX + 1] = {\n\t[IFLA_BAREUDP_PORT]                = { .type = NLA_U16 },\n\t[IFLA_BAREUDP_ETHERTYPE]\t   = { .type = NLA_U16 },\n\t[IFLA_BAREUDP_SRCPORT_MIN]         = { .type = NLA_U16 },\n\t[IFLA_BAREUDP_MULTIPROTO_MODE]     = { .type = NLA_FLAG },\n};\n\n \nstatic const struct device_type bareudp_type = {\n\t.name = \"bareudp\",\n};\n\n \nstatic void bareudp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &bareudp_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tSET_NETDEV_DEVTYPE(dev, &bareudp_type);\n\tdev->features    |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;\n\tdev->features    |= NETIF_F_RXCSUM;\n\tdev->features    |= NETIF_F_LLTX;\n\tdev->features    |= NETIF_F_GSO_SOFTWARE;\n\tdev->hw_features |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;\n\tdev->hw_features |= NETIF_F_RXCSUM;\n\tdev->hw_features |= NETIF_F_GSO_SOFTWARE;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 0;\n\tdev->mtu = ETH_DATA_LEN;\n\tdev->min_mtu = IPV4_MIN_MTU;\n\tdev->max_mtu = IP_MAX_MTU - BAREUDP_BASE_HLEN;\n\tdev->type = ARPHRD_NONE;\n\tnetif_keep_dst(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n}\n\nstatic int bareudp_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (!data) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Not enough attributes provided to perform the operation\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int bareudp2info(struct nlattr *data[], struct bareudp_conf *conf,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tmemset(conf, 0, sizeof(*conf));\n\n\tif (!data[IFLA_BAREUDP_PORT]) {\n\t\tNL_SET_ERR_MSG(extack, \"port not specified\");\n\t\treturn -EINVAL;\n\t}\n\tif (!data[IFLA_BAREUDP_ETHERTYPE]) {\n\t\tNL_SET_ERR_MSG(extack, \"ethertype not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tconf->port = nla_get_u16(data[IFLA_BAREUDP_PORT]);\n\tconf->ethertype = nla_get_u16(data[IFLA_BAREUDP_ETHERTYPE]);\n\n\tif (data[IFLA_BAREUDP_SRCPORT_MIN])\n\t\tconf->sport_min =  nla_get_u16(data[IFLA_BAREUDP_SRCPORT_MIN]);\n\n\tif (data[IFLA_BAREUDP_MULTIPROTO_MODE])\n\t\tconf->multi_proto_mode = true;\n\n\treturn 0;\n}\n\nstatic struct bareudp_dev *bareudp_find_dev(struct bareudp_net *bn,\n\t\t\t\t\t    const struct bareudp_conf *conf)\n{\n\tstruct bareudp_dev *bareudp, *t = NULL;\n\n\tlist_for_each_entry(bareudp, &bn->bareudp_list, next) {\n\t\tif (conf->port == bareudp->port)\n\t\t\tt = bareudp;\n\t}\n\treturn t;\n}\n\nstatic int bareudp_configure(struct net *net, struct net_device *dev,\n\t\t\t     struct bareudp_conf *conf,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bareudp_net *bn = net_generic(net, bareudp_net_id);\n\tstruct bareudp_dev *t, *bareudp = netdev_priv(dev);\n\tint err;\n\n\tbareudp->net = net;\n\tbareudp->dev = dev;\n\tt = bareudp_find_dev(bn, conf);\n\tif (t) {\n\t\tNL_SET_ERR_MSG(extack, \"Another bareudp device using the same port already exists\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (conf->multi_proto_mode &&\n\t    (conf->ethertype != htons(ETH_P_MPLS_UC) &&\n\t     conf->ethertype != htons(ETH_P_IP))) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot set multiproto mode for this ethertype (only IPv4 and unicast MPLS are supported)\");\n\t\treturn -EINVAL;\n\t}\n\n\tbareudp->port = conf->port;\n\tbareudp->ethertype = conf->ethertype;\n\tbareudp->sport_min = conf->sport_min;\n\tbareudp->multi_proto_mode = conf->multi_proto_mode;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\treturn err;\n\n\tlist_add(&bareudp->next, &bn->bareudp_list);\n\treturn 0;\n}\n\nstatic int bareudp_link_config(struct net_device *dev,\n\t\t\t       struct nlattr *tb[])\n{\n\tint err;\n\n\tif (tb[IFLA_MTU]) {\n\t\terr = dev_set_mtu(dev, nla_get_u32(tb[IFLA_MTU]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void bareudp_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\n\tlist_del(&bareudp->next);\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic int bareudp_newlink(struct net *net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct bareudp_conf conf;\n\tint err;\n\n\terr = bareudp2info(data, &conf, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = bareudp_configure(net, dev, &conf, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = bareudp_link_config(dev, tb);\n\tif (err)\n\t\tgoto err_unconfig;\n\n\treturn 0;\n\nerr_unconfig:\n\tbareudp_dellink(dev, NULL);\n\treturn err;\n}\n\nstatic size_t bareudp_get_size(const struct net_device *dev)\n{\n\treturn  nla_total_size(sizeof(__be16)) +   \n\t\tnla_total_size(sizeof(__be16)) +   \n\t\tnla_total_size(sizeof(__u16))  +   \n\t\tnla_total_size(0)              +   \n\t\t0;\n}\n\nstatic int bareudp_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct bareudp_dev *bareudp = netdev_priv(dev);\n\n\tif (nla_put_be16(skb, IFLA_BAREUDP_PORT, bareudp->port))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be16(skb, IFLA_BAREUDP_ETHERTYPE, bareudp->ethertype))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(skb, IFLA_BAREUDP_SRCPORT_MIN, bareudp->sport_min))\n\t\tgoto nla_put_failure;\n\tif (bareudp->multi_proto_mode &&\n\t    nla_put_flag(skb, IFLA_BAREUDP_MULTIPROTO_MODE))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_link_ops bareudp_link_ops __read_mostly = {\n\t.kind           = \"bareudp\",\n\t.maxtype        = IFLA_BAREUDP_MAX,\n\t.policy         = bareudp_policy,\n\t.priv_size      = sizeof(struct bareudp_dev),\n\t.setup          = bareudp_setup,\n\t.validate       = bareudp_validate,\n\t.newlink        = bareudp_newlink,\n\t.dellink        = bareudp_dellink,\n\t.get_size       = bareudp_get_size,\n\t.fill_info      = bareudp_fill_info,\n};\n\nstatic __net_init int bareudp_init_net(struct net *net)\n{\n\tstruct bareudp_net *bn = net_generic(net, bareudp_net_id);\n\n\tINIT_LIST_HEAD(&bn->bareudp_list);\n\treturn 0;\n}\n\nstatic void bareudp_destroy_tunnels(struct net *net, struct list_head *head)\n{\n\tstruct bareudp_net *bn = net_generic(net, bareudp_net_id);\n\tstruct bareudp_dev *bareudp, *next;\n\n\tlist_for_each_entry_safe(bareudp, next, &bn->bareudp_list, next)\n\t\tunregister_netdevice_queue(bareudp->dev, head);\n}\n\nstatic void __net_exit bareudp_exit_batch_net(struct list_head *net_list)\n{\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tbareudp_destroy_tunnels(net, &list);\n\n\t \n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations bareudp_net_ops = {\n\t.init = bareudp_init_net,\n\t.exit_batch = bareudp_exit_batch_net,\n\t.id   = &bareudp_net_id,\n\t.size = sizeof(struct bareudp_net),\n};\n\nstatic int __init bareudp_init_module(void)\n{\n\tint rc;\n\n\trc = register_pernet_subsys(&bareudp_net_ops);\n\tif (rc)\n\t\tgoto out1;\n\n\trc = rtnl_link_register(&bareudp_link_ops);\n\tif (rc)\n\t\tgoto out2;\n\n\treturn 0;\nout2:\n\tunregister_pernet_subsys(&bareudp_net_ops);\nout1:\n\treturn rc;\n}\nlate_initcall(bareudp_init_module);\n\nstatic void __exit bareudp_cleanup_module(void)\n{\n\trtnl_link_unregister(&bareudp_link_ops);\n\tunregister_pernet_subsys(&bareudp_net_ops);\n}\nmodule_exit(bareudp_cleanup_module);\n\nMODULE_ALIAS_RTNL_LINK(\"bareudp\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Martin Varghese <martin.varghese@nokia.com>\");\nMODULE_DESCRIPTION(\"Interface driver for UDP encapsulated traffic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}