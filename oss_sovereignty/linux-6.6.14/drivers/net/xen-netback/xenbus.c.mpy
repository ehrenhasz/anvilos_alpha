{
  "module_name": "xenbus.c",
  "hash_id": "828e53778ce79cdb56535fd4deabe947d01200c02fa8efb12544ad30b873056a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/xen-netback/xenbus.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include <linux/vmalloc.h>\n#include <linux/rtnetlink.h>\n\nstatic int connect_data_rings(struct backend_info *be,\n\t\t\t      struct xenvif_queue *queue);\nstatic void connect(struct backend_info *be);\nstatic int read_xenbus_vif_flags(struct backend_info *be);\nstatic int backend_create_xenvif(struct backend_info *be);\nstatic void unregister_hotplug_status_watch(struct backend_info *be);\nstatic void xen_unregister_watchers(struct xenvif *vif);\nstatic void set_backend_state(struct backend_info *be,\n\t\t\t      enum xenbus_state state);\n\n#ifdef CONFIG_DEBUG_FS\nstruct dentry *xen_netback_dbg_root = NULL;\n\nstatic int xenvif_read_io_ring(struct seq_file *m, void *v)\n{\n\tstruct xenvif_queue *queue = m->private;\n\tstruct xen_netif_tx_back_ring *tx_ring = &queue->tx;\n\tstruct xen_netif_rx_back_ring *rx_ring = &queue->rx;\n\tstruct netdev_queue *dev_queue;\n\n\tif (tx_ring->sring) {\n\t\tstruct xen_netif_tx_sring *sring = tx_ring->sring;\n\n\t\tseq_printf(m, \"Queue %d\\nTX: nr_ents %u\\n\", queue->id,\n\t\t\t   tx_ring->nr_ents);\n\t\tseq_printf(m, \"req prod %u (%d) cons %u (%d) event %u (%d)\\n\",\n\t\t\t   sring->req_prod,\n\t\t\t   sring->req_prod - sring->rsp_prod,\n\t\t\t   tx_ring->req_cons,\n\t\t\t   tx_ring->req_cons - sring->rsp_prod,\n\t\t\t   sring->req_event,\n\t\t\t   sring->req_event - sring->rsp_prod);\n\t\tseq_printf(m, \"rsp prod %u (base) pvt %u (%d) event %u (%d)\\n\",\n\t\t\t   sring->rsp_prod,\n\t\t\t   tx_ring->rsp_prod_pvt,\n\t\t\t   tx_ring->rsp_prod_pvt - sring->rsp_prod,\n\t\t\t   sring->rsp_event,\n\t\t\t   sring->rsp_event - sring->rsp_prod);\n\t\tseq_printf(m, \"pending prod %u pending cons %u nr_pending_reqs %u\\n\",\n\t\t\t   queue->pending_prod,\n\t\t\t   queue->pending_cons,\n\t\t\t   nr_pending_reqs(queue));\n\t\tseq_printf(m, \"dealloc prod %u dealloc cons %u dealloc_queue %u\\n\\n\",\n\t\t\t   queue->dealloc_prod,\n\t\t\t   queue->dealloc_cons,\n\t\t\t   queue->dealloc_prod - queue->dealloc_cons);\n\t}\n\n\tif (rx_ring->sring) {\n\t\tstruct xen_netif_rx_sring *sring = rx_ring->sring;\n\n\t\tseq_printf(m, \"RX: nr_ents %u\\n\", rx_ring->nr_ents);\n\t\tseq_printf(m, \"req prod %u (%d) cons %u (%d) event %u (%d)\\n\",\n\t\t\t   sring->req_prod,\n\t\t\t   sring->req_prod - sring->rsp_prod,\n\t\t\t   rx_ring->req_cons,\n\t\t\t   rx_ring->req_cons - sring->rsp_prod,\n\t\t\t   sring->req_event,\n\t\t\t   sring->req_event - sring->rsp_prod);\n\t\tseq_printf(m, \"rsp prod %u (base) pvt %u (%d) event %u (%d)\\n\\n\",\n\t\t\t   sring->rsp_prod,\n\t\t\t   rx_ring->rsp_prod_pvt,\n\t\t\t   rx_ring->rsp_prod_pvt - sring->rsp_prod,\n\t\t\t   sring->rsp_event,\n\t\t\t   sring->rsp_event - sring->rsp_prod);\n\t}\n\n\tseq_printf(m, \"NAPI state: %lx NAPI weight: %d TX queue len %u\\n\"\n\t\t   \"Credit timer_pending: %d, credit: %lu, usec: %lu\\n\"\n\t\t   \"remaining: %lu, expires: %lu, now: %lu\\n\",\n\t\t   queue->napi.state, queue->napi.weight,\n\t\t   skb_queue_len(&queue->tx_queue),\n\t\t   timer_pending(&queue->credit_timeout),\n\t\t   queue->credit_bytes,\n\t\t   queue->credit_usec,\n\t\t   queue->remaining_credit,\n\t\t   queue->credit_timeout.expires,\n\t\t   jiffies);\n\n\tdev_queue = netdev_get_tx_queue(queue->vif->dev, queue->id);\n\n\tseq_printf(m, \"\\nRx internal queue: len %u max %u pkts %u %s\\n\",\n\t\t   queue->rx_queue_len, queue->rx_queue_max,\n\t\t   skb_queue_len(&queue->rx_queue),\n\t\t   netif_tx_queue_stopped(dev_queue) ? \"stopped\" : \"running\");\n\n\treturn 0;\n}\n\n#define XENVIF_KICK_STR \"kick\"\n#define BUFFER_SIZE     32\n\nstatic ssize_t\nxenvif_write_io_ring(struct file *filp, const char __user *buf, size_t count,\n\t\t     loff_t *ppos)\n{\n\tstruct xenvif_queue *queue =\n\t\t((struct seq_file *)filp->private_data)->private;\n\tint len;\n\tchar write[BUFFER_SIZE];\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\tif (count >= sizeof(write))\n\t\treturn -ENOSPC;\n\n\tlen = simple_write_to_buffer(write,\n\t\t\t\t     sizeof(write) - 1,\n\t\t\t\t     ppos,\n\t\t\t\t     buf,\n\t\t\t\t     count);\n\tif (len < 0)\n\t\treturn len;\n\n\twrite[len] = '\\0';\n\n\tif (!strncmp(write, XENVIF_KICK_STR, sizeof(XENVIF_KICK_STR) - 1))\n\t\txenvif_interrupt(0, (void *)queue);\n\telse {\n\t\tpr_warn(\"Unknown command to io_ring_q%d. Available: kick\\n\",\n\t\t\tqueue->id);\n\t\tcount = -EINVAL;\n\t}\n\treturn count;\n}\n\nstatic int xenvif_io_ring_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\tvoid *queue = NULL;\n\n\tif (inode->i_private)\n\t\tqueue = inode->i_private;\n\tret = single_open(filp, xenvif_read_io_ring, queue);\n\tfilp->f_mode |= FMODE_PWRITE;\n\treturn ret;\n}\n\nstatic const struct file_operations xenvif_dbg_io_ring_ops_fops = {\n\t.owner = THIS_MODULE,\n\t.open = xenvif_io_ring_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n\t.write = xenvif_write_io_ring,\n};\n\nstatic int xenvif_ctrl_show(struct seq_file *m, void *v)\n{\n\tstruct xenvif *vif = m->private;\n\n\txenvif_dump_hash_info(vif, m);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(xenvif_ctrl);\n\nstatic void xenvif_debugfs_addif(struct xenvif *vif)\n{\n\tint i;\n\n\tvif->xenvif_dbg_root = debugfs_create_dir(vif->dev->name,\n\t\t\t\t\t\t  xen_netback_dbg_root);\n\tfor (i = 0; i < vif->num_queues; ++i) {\n\t\tchar filename[sizeof(\"io_ring_q\") + 4];\n\n\t\tsnprintf(filename, sizeof(filename), \"io_ring_q%d\", i);\n\t\tdebugfs_create_file(filename, 0600, vif->xenvif_dbg_root,\n\t\t\t\t    &vif->queues[i],\n\t\t\t\t    &xenvif_dbg_io_ring_ops_fops);\n\t}\n\n\tif (vif->ctrl_irq)\n\t\tdebugfs_create_file(\"ctrl\", 0400, vif->xenvif_dbg_root, vif,\n\t\t\t\t    &xenvif_ctrl_fops);\n}\n\nstatic void xenvif_debugfs_delif(struct xenvif *vif)\n{\n\tdebugfs_remove_recursive(vif->xenvif_dbg_root);\n\tvif->xenvif_dbg_root = NULL;\n}\n#endif  \n\n \nstatic int netback_uevent(const struct xenbus_device *xdev,\n\t\t\t  struct kobj_uevent_env *env)\n{\n\tstruct backend_info *be = dev_get_drvdata(&xdev->dev);\n\n\tif (!be)\n\t\treturn 0;\n\n\tif (add_uevent_var(env, \"script=%s\", be->hotplug_script))\n\t\treturn -ENOMEM;\n\n\tif (!be->vif)\n\t\treturn 0;\n\n\treturn add_uevent_var(env, \"vif=%s\", be->vif->dev->name);\n}\n\n\nstatic int backend_create_xenvif(struct backend_info *be)\n{\n\tint err;\n\tlong handle;\n\tstruct xenbus_device *dev = be->dev;\n\tstruct xenvif *vif;\n\n\tif (be->vif != NULL)\n\t\treturn 0;\n\n\terr = xenbus_scanf(XBT_NIL, dev->nodename, \"handle\", \"%li\", &handle);\n\tif (err != 1) {\n\t\txenbus_dev_fatal(dev, err, \"reading handle\");\n\t\treturn (err < 0) ? err : -EINVAL;\n\t}\n\n\tvif = xenvif_alloc(&dev->dev, dev->otherend_id, handle);\n\tif (IS_ERR(vif)) {\n\t\terr = PTR_ERR(vif);\n\t\txenbus_dev_fatal(dev, err, \"creating interface\");\n\t\treturn err;\n\t}\n\tbe->vif = vif;\n\tvif->be = be;\n\n\tkobject_uevent(&dev->dev.kobj, KOBJ_ONLINE);\n\treturn 0;\n}\n\nstatic void backend_disconnect(struct backend_info *be)\n{\n\tstruct xenvif *vif = be->vif;\n\n\tif (vif) {\n\t\tunsigned int num_queues = vif->num_queues;\n\t\tunsigned int queue_index;\n\n\t\txen_unregister_watchers(vif);\n#ifdef CONFIG_DEBUG_FS\n\t\txenvif_debugfs_delif(vif);\n#endif  \n\t\txenvif_disconnect_data(vif);\n\n\t\t \n\t\tvif->num_queues = 0;\n\t\tsynchronize_net();\n\n\t\tfor (queue_index = 0; queue_index < num_queues; ++queue_index)\n\t\t\txenvif_deinit_queue(&vif->queues[queue_index]);\n\n\t\tvfree(vif->queues);\n\t\tvif->queues = NULL;\n\n\t\txenvif_disconnect_ctrl(vif);\n\t}\n}\n\nstatic void backend_connect(struct backend_info *be)\n{\n\tif (be->vif)\n\t\tconnect(be);\n}\n\nstatic inline void backend_switch_state(struct backend_info *be,\n\t\t\t\t\tenum xenbus_state state)\n{\n\tstruct xenbus_device *dev = be->dev;\n\n\tpr_debug(\"%s -> %s\\n\", dev->nodename, xenbus_strstate(state));\n\tbe->state = state;\n\n\t \n\tif (!be->have_hotplug_status_watch)\n\t\txenbus_switch_state(dev, state);\n}\n\n \nstatic void set_backend_state(struct backend_info *be,\n\t\t\t      enum xenbus_state state)\n{\n\twhile (be->state != state) {\n\t\tswitch (be->state) {\n\t\tcase XenbusStateInitialising:\n\t\t\tswitch (state) {\n\t\t\tcase XenbusStateInitWait:\n\t\t\tcase XenbusStateConnected:\n\t\t\tcase XenbusStateClosing:\n\t\t\t\tbackend_switch_state(be, XenbusStateInitWait);\n\t\t\t\tbreak;\n\t\t\tcase XenbusStateClosed:\n\t\t\t\tbackend_switch_state(be, XenbusStateClosed);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase XenbusStateClosed:\n\t\t\tswitch (state) {\n\t\t\tcase XenbusStateInitWait:\n\t\t\tcase XenbusStateConnected:\n\t\t\t\tbackend_switch_state(be, XenbusStateInitWait);\n\t\t\t\tbreak;\n\t\t\tcase XenbusStateClosing:\n\t\t\t\tbackend_switch_state(be, XenbusStateClosing);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase XenbusStateInitWait:\n\t\t\tswitch (state) {\n\t\t\tcase XenbusStateConnected:\n\t\t\t\tbackend_connect(be);\n\t\t\t\tbackend_switch_state(be, XenbusStateConnected);\n\t\t\t\tbreak;\n\t\t\tcase XenbusStateClosing:\n\t\t\tcase XenbusStateClosed:\n\t\t\t\tbackend_switch_state(be, XenbusStateClosing);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase XenbusStateConnected:\n\t\t\tswitch (state) {\n\t\t\tcase XenbusStateInitWait:\n\t\t\tcase XenbusStateClosing:\n\t\t\tcase XenbusStateClosed:\n\t\t\t\tbackend_disconnect(be);\n\t\t\t\tbackend_switch_state(be, XenbusStateClosing);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase XenbusStateClosing:\n\t\t\tswitch (state) {\n\t\t\tcase XenbusStateInitWait:\n\t\t\tcase XenbusStateConnected:\n\t\t\tcase XenbusStateClosed:\n\t\t\t\tbackend_switch_state(be, XenbusStateClosed);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}\n\nstatic void read_xenbus_frontend_xdp(struct backend_info *be,\n\t\t\t\t      struct xenbus_device *dev)\n{\n\tstruct xenvif *vif = be->vif;\n\tu16 headroom;\n\tint err;\n\n\terr = xenbus_scanf(XBT_NIL, dev->otherend,\n\t\t\t   \"xdp-headroom\", \"%hu\", &headroom);\n\tif (err != 1) {\n\t\tvif->xdp_headroom = 0;\n\t\treturn;\n\t}\n\tif (headroom > XEN_NETIF_MAX_XDP_HEADROOM)\n\t\theadroom = XEN_NETIF_MAX_XDP_HEADROOM;\n\tvif->xdp_headroom = headroom;\n}\n\n \nstatic void frontend_changed(struct xenbus_device *dev,\n\t\t\t     enum xenbus_state frontend_state)\n{\n\tstruct backend_info *be = dev_get_drvdata(&dev->dev);\n\n\tpr_debug(\"%s -> %s\\n\", dev->otherend, xenbus_strstate(frontend_state));\n\n\tbe->frontend_state = frontend_state;\n\n\tswitch (frontend_state) {\n\tcase XenbusStateInitialising:\n\t\tset_backend_state(be, XenbusStateInitWait);\n\t\tbreak;\n\n\tcase XenbusStateInitialised:\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\tset_backend_state(be, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateReconfiguring:\n\t\tread_xenbus_frontend_xdp(be, dev);\n\t\txenbus_switch_state(dev, XenbusStateReconfigured);\n\t\tbreak;\n\n\tcase XenbusStateClosing:\n\t\tset_backend_state(be, XenbusStateClosing);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tset_backend_state(be, XenbusStateClosed);\n\t\tif (xenbus_dev_is_online(dev))\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateUnknown:\n\t\tset_backend_state(be, XenbusStateClosed);\n\t\tdevice_unregister(&dev->dev);\n\t\tbreak;\n\n\tdefault:\n\t\txenbus_dev_fatal(dev, -EINVAL, \"saw state %d at frontend\",\n\t\t\t\t frontend_state);\n\t\tbreak;\n\t}\n}\n\n\nstatic void xen_net_read_rate(struct xenbus_device *dev,\n\t\t\t      unsigned long *bytes, unsigned long *usec)\n{\n\tchar *s, *e;\n\tunsigned long b, u;\n\tchar *ratestr;\n\n\t \n\t*bytes = ~0UL;\n\t*usec = 0;\n\n\tratestr = xenbus_read(XBT_NIL, dev->nodename, \"rate\", NULL);\n\tif (IS_ERR(ratestr))\n\t\treturn;\n\n\ts = ratestr;\n\tb = simple_strtoul(s, &e, 10);\n\tif ((s == e) || (*e != ','))\n\t\tgoto fail;\n\n\ts = e + 1;\n\tu = simple_strtoul(s, &e, 10);\n\tif ((s == e) || (*e != '\\0'))\n\t\tgoto fail;\n\n\t*bytes = b;\n\t*usec = u;\n\n\tkfree(ratestr);\n\treturn;\n\n fail:\n\tpr_warn(\"Failed to parse network rate limit. Traffic unlimited.\\n\");\n\tkfree(ratestr);\n}\n\nstatic int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\n{\n\tchar *s, *e, *macstr;\n\tint i;\n\n\tmacstr = s = xenbus_read(XBT_NIL, dev->nodename, \"mac\", NULL);\n\tif (IS_ERR(macstr))\n\t\treturn PTR_ERR(macstr);\n\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tmac[i] = simple_strtoul(s, &e, 16);\n\t\tif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\\0' : ':'))) {\n\t\t\tkfree(macstr);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\ts = e+1;\n\t}\n\n\tkfree(macstr);\n\treturn 0;\n}\n\nstatic void xen_net_rate_changed(struct xenbus_watch *watch,\n\t\t\t\t const char *path, const char *token)\n{\n\tstruct xenvif *vif = container_of(watch, struct xenvif, credit_watch);\n\tstruct xenbus_device *dev = xenvif_to_xenbus_device(vif);\n\tunsigned long   credit_bytes;\n\tunsigned long   credit_usec;\n\tunsigned int queue_index;\n\n\txen_net_read_rate(dev, &credit_bytes, &credit_usec);\n\tfor (queue_index = 0; queue_index < vif->num_queues; queue_index++) {\n\t\tstruct xenvif_queue *queue = &vif->queues[queue_index];\n\n\t\tqueue->credit_bytes = credit_bytes;\n\t\tqueue->credit_usec = credit_usec;\n\t\tif (!mod_timer_pending(&queue->credit_timeout, jiffies) &&\n\t\t\tqueue->remaining_credit > queue->credit_bytes) {\n\t\t\tqueue->remaining_credit = queue->credit_bytes;\n\t\t}\n\t}\n}\n\nstatic int xen_register_credit_watch(struct xenbus_device *dev,\n\t\t\t\t     struct xenvif *vif)\n{\n\tint err = 0;\n\tchar *node;\n\tunsigned maxlen = strlen(dev->nodename) + sizeof(\"/rate\");\n\n\tif (vif->credit_watch.node)\n\t\treturn -EADDRINUSE;\n\n\tnode = kmalloc(maxlen, GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\tsnprintf(node, maxlen, \"%s/rate\", dev->nodename);\n\tvif->credit_watch.node = node;\n\tvif->credit_watch.will_handle = NULL;\n\tvif->credit_watch.callback = xen_net_rate_changed;\n\terr = register_xenbus_watch(&vif->credit_watch);\n\tif (err) {\n\t\tpr_err(\"Failed to set watcher %s\\n\", vif->credit_watch.node);\n\t\tkfree(node);\n\t\tvif->credit_watch.node = NULL;\n\t\tvif->credit_watch.will_handle = NULL;\n\t\tvif->credit_watch.callback = NULL;\n\t}\n\treturn err;\n}\n\nstatic void xen_unregister_credit_watch(struct xenvif *vif)\n{\n\tif (vif->credit_watch.node) {\n\t\tunregister_xenbus_watch(&vif->credit_watch);\n\t\tkfree(vif->credit_watch.node);\n\t\tvif->credit_watch.node = NULL;\n\t}\n}\n\nstatic void xen_mcast_ctrl_changed(struct xenbus_watch *watch,\n\t\t\t\t   const char *path, const char *token)\n{\n\tstruct xenvif *vif = container_of(watch, struct xenvif,\n\t\t\t\t\t  mcast_ctrl_watch);\n\tstruct xenbus_device *dev = xenvif_to_xenbus_device(vif);\n\n\tvif->multicast_control = !!xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t\"request-multicast-control\", 0);\n}\n\nstatic int xen_register_mcast_ctrl_watch(struct xenbus_device *dev,\n\t\t\t\t\t struct xenvif *vif)\n{\n\tint err = 0;\n\tchar *node;\n\tunsigned maxlen = strlen(dev->otherend) +\n\t\tsizeof(\"/request-multicast-control\");\n\n\tif (vif->mcast_ctrl_watch.node) {\n\t\tpr_err_ratelimited(\"Watch is already registered\\n\");\n\t\treturn -EADDRINUSE;\n\t}\n\n\tnode = kmalloc(maxlen, GFP_KERNEL);\n\tif (!node) {\n\t\tpr_err(\"Failed to allocate memory for watch\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsnprintf(node, maxlen, \"%s/request-multicast-control\",\n\t\t dev->otherend);\n\tvif->mcast_ctrl_watch.node = node;\n\tvif->mcast_ctrl_watch.will_handle = NULL;\n\tvif->mcast_ctrl_watch.callback = xen_mcast_ctrl_changed;\n\terr = register_xenbus_watch(&vif->mcast_ctrl_watch);\n\tif (err) {\n\t\tpr_err(\"Failed to set watcher %s\\n\",\n\t\t       vif->mcast_ctrl_watch.node);\n\t\tkfree(node);\n\t\tvif->mcast_ctrl_watch.node = NULL;\n\t\tvif->mcast_ctrl_watch.will_handle = NULL;\n\t\tvif->mcast_ctrl_watch.callback = NULL;\n\t}\n\treturn err;\n}\n\nstatic void xen_unregister_mcast_ctrl_watch(struct xenvif *vif)\n{\n\tif (vif->mcast_ctrl_watch.node) {\n\t\tunregister_xenbus_watch(&vif->mcast_ctrl_watch);\n\t\tkfree(vif->mcast_ctrl_watch.node);\n\t\tvif->mcast_ctrl_watch.node = NULL;\n\t}\n}\n\nstatic void xen_register_watchers(struct xenbus_device *dev,\n\t\t\t\t  struct xenvif *vif)\n{\n\txen_register_credit_watch(dev, vif);\n\txen_register_mcast_ctrl_watch(dev, vif);\n}\n\nstatic void xen_unregister_watchers(struct xenvif *vif)\n{\n\txen_unregister_mcast_ctrl_watch(vif);\n\txen_unregister_credit_watch(vif);\n}\n\nstatic void unregister_hotplug_status_watch(struct backend_info *be)\n{\n\tif (be->have_hotplug_status_watch) {\n\t\tunregister_xenbus_watch(&be->hotplug_status_watch);\n\t\tkfree(be->hotplug_status_watch.node);\n\t}\n\tbe->have_hotplug_status_watch = 0;\n}\n\nstatic void hotplug_status_changed(struct xenbus_watch *watch,\n\t\t\t\t   const char *path,\n\t\t\t\t   const char *token)\n{\n\tstruct backend_info *be = container_of(watch,\n\t\t\t\t\t       struct backend_info,\n\t\t\t\t\t       hotplug_status_watch);\n\tchar *str;\n\tunsigned int len;\n\n\tstr = xenbus_read(XBT_NIL, be->dev->nodename, \"hotplug-status\", &len);\n\tif (IS_ERR(str))\n\t\treturn;\n\tif (len == sizeof(\"connected\")-1 && !memcmp(str, \"connected\", len)) {\n\t\t \n\t\txenbus_switch_state(be->dev, be->state);\n\n\t\t \n\t\tunregister_hotplug_status_watch(be);\n\t}\n\tkfree(str);\n}\n\nstatic int connect_ctrl_ring(struct backend_info *be)\n{\n\tstruct xenbus_device *dev = be->dev;\n\tstruct xenvif *vif = be->vif;\n\tunsigned int val;\n\tgrant_ref_t ring_ref;\n\tunsigned int evtchn;\n\tint err;\n\n\terr = xenbus_scanf(XBT_NIL, dev->otherend,\n\t\t\t   \"ctrl-ring-ref\", \"%u\", &val);\n\tif (err < 0)\n\t\tgoto done;  \n\n\tring_ref = val;\n\n\terr = xenbus_scanf(XBT_NIL, dev->otherend,\n\t\t\t   \"event-channel-ctrl\", \"%u\", &val);\n\tif (err < 0) {\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"reading %s/event-channel-ctrl\",\n\t\t\t\t dev->otherend);\n\t\tgoto fail;\n\t}\n\n\tevtchn = val;\n\n\terr = xenvif_connect_ctrl(vif, ring_ref, evtchn);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"mapping shared-frame %u port %u\",\n\t\t\t\t ring_ref, evtchn);\n\t\tgoto fail;\n\t}\n\ndone:\n\treturn 0;\n\nfail:\n\treturn err;\n}\n\nstatic void connect(struct backend_info *be)\n{\n\tint err;\n\tstruct xenbus_device *dev = be->dev;\n\tunsigned long credit_bytes, credit_usec;\n\tunsigned int queue_index;\n\tunsigned int requested_num_queues;\n\tstruct xenvif_queue *queue;\n\n\t \n\trequested_num_queues = xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t\"multi-queue-num-queues\", 1);\n\tif (requested_num_queues > xenvif_max_queues) {\n\t\t \n\t\txenbus_dev_fatal(dev, -EINVAL,\n\t\t\t\t \"guest requested %u queues, exceeding the maximum of %u.\",\n\t\t\t\t requested_num_queues, xenvif_max_queues);\n\t\treturn;\n\t}\n\n\terr = xen_net_read_mac(dev, be->vif->fe_dev_addr);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"parsing %s/mac\", dev->nodename);\n\t\treturn;\n\t}\n\n\txen_net_read_rate(dev, &credit_bytes, &credit_usec);\n\txen_unregister_watchers(be->vif);\n\txen_register_watchers(dev, be->vif);\n\tread_xenbus_vif_flags(be);\n\n\terr = connect_ctrl_ring(be);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"connecting control ring\");\n\t\treturn;\n\t}\n\n\t \n\tbe->vif->queues = vzalloc(array_size(requested_num_queues,\n\t\t\t\t\t     sizeof(struct xenvif_queue)));\n\tif (!be->vif->queues) {\n\t\txenbus_dev_fatal(dev, -ENOMEM,\n\t\t\t\t \"allocating queues\");\n\t\treturn;\n\t}\n\n\tbe->vif->num_queues = requested_num_queues;\n\tbe->vif->stalled_queues = requested_num_queues;\n\n\tfor (queue_index = 0; queue_index < requested_num_queues; ++queue_index) {\n\t\tqueue = &be->vif->queues[queue_index];\n\t\tqueue->vif = be->vif;\n\t\tqueue->id = queue_index;\n\t\tsnprintf(queue->name, sizeof(queue->name), \"%s-q%u\",\n\t\t\t\tbe->vif->dev->name, queue->id);\n\n\t\terr = xenvif_init_queue(queue);\n\t\tif (err) {\n\t\t\t \n\t\t\tbe->vif->num_queues = queue_index;\n\t\t\tgoto err;\n\t\t}\n\n\t\tqueue->credit_bytes = credit_bytes;\n\t\tqueue->remaining_credit = credit_bytes;\n\t\tqueue->credit_usec = credit_usec;\n\n\t\terr = connect_data_rings(be, queue);\n\t\tif (err) {\n\t\t\t \n\t\t\txenvif_deinit_queue(queue);\n\t\t\tbe->vif->num_queues = queue_index;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\txenvif_debugfs_addif(be->vif);\n#endif  \n\n\t \n\trtnl_lock();\n\tnetif_set_real_num_tx_queues(be->vif->dev, requested_num_queues);\n\tnetif_set_real_num_rx_queues(be->vif->dev, requested_num_queues);\n\trtnl_unlock();\n\n\txenvif_carrier_on(be->vif);\n\n\tunregister_hotplug_status_watch(be);\n\terr = xenbus_watch_pathfmt(dev, &be->hotplug_status_watch, NULL,\n\t\t\t\t   hotplug_status_changed,\n\t\t\t\t   \"%s/%s\", dev->nodename, \"hotplug-status\");\n\tif (!err)\n\t\tbe->have_hotplug_status_watch = 1;\n\n\tnetif_tx_wake_all_queues(be->vif->dev);\n\n\treturn;\n\nerr:\n\tif (be->vif->num_queues > 0)\n\t\txenvif_disconnect_data(be->vif);  \n\tfor (queue_index = 0; queue_index < be->vif->num_queues; ++queue_index)\n\t\txenvif_deinit_queue(&be->vif->queues[queue_index]);\n\tvfree(be->vif->queues);\n\tbe->vif->queues = NULL;\n\tbe->vif->num_queues = 0;\n\txenvif_disconnect_ctrl(be->vif);\n\treturn;\n}\n\n\nstatic int connect_data_rings(struct backend_info *be,\n\t\t\t      struct xenvif_queue *queue)\n{\n\tstruct xenbus_device *dev = be->dev;\n\tunsigned int num_queues = queue->vif->num_queues;\n\tunsigned long tx_ring_ref, rx_ring_ref;\n\tunsigned int tx_evtchn, rx_evtchn;\n\tint err;\n\tchar *xspath;\n\tsize_t xspathsize;\n\tconst size_t xenstore_path_ext_size = 11;  \n\n\t \n\tif (num_queues == 1) {\n\t\txspath = kstrdup(dev->otherend, GFP_KERNEL);\n\t\tif (!xspath) {\n\t\t\txenbus_dev_fatal(dev, -ENOMEM,\n\t\t\t\t\t \"reading ring references\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\txspathsize = strlen(dev->otherend) + xenstore_path_ext_size;\n\t\txspath = kzalloc(xspathsize, GFP_KERNEL);\n\t\tif (!xspath) {\n\t\t\txenbus_dev_fatal(dev, -ENOMEM,\n\t\t\t\t\t \"reading ring references\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsnprintf(xspath, xspathsize, \"%s/queue-%u\", dev->otherend,\n\t\t\t queue->id);\n\t}\n\n\terr = xenbus_gather(XBT_NIL, xspath,\n\t\t\t    \"tx-ring-ref\", \"%lu\", &tx_ring_ref,\n\t\t\t    \"rx-ring-ref\", \"%lu\", &rx_ring_ref, NULL);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"reading %s/ring-ref\",\n\t\t\t\t xspath);\n\t\tgoto err;\n\t}\n\n\t \n\terr = xenbus_gather(XBT_NIL, xspath,\n\t\t\t    \"event-channel-tx\", \"%u\", &tx_evtchn,\n\t\t\t    \"event-channel-rx\", \"%u\", &rx_evtchn, NULL);\n\tif (err < 0) {\n\t\terr = xenbus_scanf(XBT_NIL, xspath,\n\t\t\t\t   \"event-channel\", \"%u\", &tx_evtchn);\n\t\tif (err < 0) {\n\t\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t\t \"reading %s/event-channel(-tx/rx)\",\n\t\t\t\t\t xspath);\n\t\t\tgoto err;\n\t\t}\n\t\trx_evtchn = tx_evtchn;\n\t}\n\n\t \n\terr = xenvif_connect_data(queue, tx_ring_ref, rx_ring_ref,\n\t\t\t\t  tx_evtchn, rx_evtchn);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"mapping shared-frames %lu/%lu port tx %u rx %u\",\n\t\t\t\t tx_ring_ref, rx_ring_ref,\n\t\t\t\t tx_evtchn, rx_evtchn);\n\t\tgoto err;\n\t}\n\n\terr = 0;\nerr:  \n\tkfree(xspath);\n\treturn err;\n}\n\nstatic int read_xenbus_vif_flags(struct backend_info *be)\n{\n\tstruct xenvif *vif = be->vif;\n\tstruct xenbus_device *dev = be->dev;\n\tunsigned int rx_copy;\n\tint err;\n\n\terr = xenbus_scanf(XBT_NIL, dev->otherend, \"request-rx-copy\", \"%u\",\n\t\t\t   &rx_copy);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\trx_copy = 0;\n\t}\n\tif (err < 0) {\n\t\txenbus_dev_fatal(dev, err, \"reading %s/request-rx-copy\",\n\t\t\t\t dev->otherend);\n\t\treturn err;\n\t}\n\tif (!rx_copy)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!xenbus_read_unsigned(dev->otherend, \"feature-rx-notify\", 0)) {\n\t\t \n\t\tbe->vif->drain_timeout = msecs_to_jiffies(30);\n\t\tbe->vif->stall_timeout = 0;\n\t}\n\n\tvif->can_sg = !!xenbus_read_unsigned(dev->otherend, \"feature-sg\", 0);\n\n\tvif->gso_mask = 0;\n\n\tif (xenbus_read_unsigned(dev->otherend, \"feature-gso-tcpv4\", 0))\n\t\tvif->gso_mask |= GSO_BIT(TCPV4);\n\n\tif (xenbus_read_unsigned(dev->otherend, \"feature-gso-tcpv6\", 0))\n\t\tvif->gso_mask |= GSO_BIT(TCPV6);\n\n\tvif->ip_csum = !xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t     \"feature-no-csum-offload\", 0);\n\n\tvif->ipv6_csum = !!xenbus_read_unsigned(dev->otherend,\n\t\t\t\t\t\t\"feature-ipv6-csum-offload\", 0);\n\n\tread_xenbus_frontend_xdp(be, dev);\n\n\treturn 0;\n}\n\nstatic void netback_remove(struct xenbus_device *dev)\n{\n\tstruct backend_info *be = dev_get_drvdata(&dev->dev);\n\n\tunregister_hotplug_status_watch(be);\n\txenbus_rm(XBT_NIL, dev->nodename, \"hotplug-status\");\n\tif (be->vif) {\n\t\tkobject_uevent(&dev->dev.kobj, KOBJ_OFFLINE);\n\t\tbackend_disconnect(be);\n\t\txenvif_free(be->vif);\n\t\tbe->vif = NULL;\n\t}\n\tkfree(be->hotplug_script);\n\tkfree(be);\n\tdev_set_drvdata(&dev->dev, NULL);\n}\n\n \nstatic int netback_probe(struct xenbus_device *dev,\n\t\t\t const struct xenbus_device_id *id)\n{\n\tconst char *message;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\tint sg;\n\tconst char *script;\n\tstruct backend_info *be = kzalloc(sizeof(*be), GFP_KERNEL);\n\n\tif (!be) {\n\t\txenbus_dev_fatal(dev, -ENOMEM,\n\t\t\t\t \"allocating backend structure\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbe->dev = dev;\n\tdev_set_drvdata(&dev->dev, be);\n\n\tsg = 1;\n\n\tdo {\n\t\terr = xenbus_transaction_start(&xbt);\n\t\tif (err) {\n\t\t\txenbus_dev_fatal(dev, err, \"starting transaction\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\terr = xenbus_printf(xbt, dev->nodename, \"feature-sg\", \"%d\", sg);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-sg\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\terr = xenbus_printf(xbt, dev->nodename, \"feature-gso-tcpv4\",\n\t\t\t\t    \"%d\", sg);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-gso-tcpv4\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\terr = xenbus_printf(xbt, dev->nodename, \"feature-gso-tcpv6\",\n\t\t\t\t    \"%d\", sg);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-gso-tcpv6\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\t \n\t\terr = xenbus_printf(xbt, dev->nodename,\n\t\t\t\t    \"feature-ipv6-csum-offload\",\n\t\t\t\t    \"%d\", 1);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-ipv6-csum-offload\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\t \n\t\terr = xenbus_printf(xbt, dev->nodename,\n\t\t\t\t    \"feature-rx-copy\", \"%d\", 1);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-rx-copy\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\t \n\t\terr = xenbus_printf(xbt, dev->nodename,\n\t\t\t\t    \"feature-xdp-headroom\", \"%d\",\n\t\t\t\t    provides_xdp_headroom);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-xdp-headroom\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\t \n\t\terr = xenbus_printf(xbt, dev->nodename,\n\t\t\t\t    \"feature-rx-flip\", \"%d\", 0);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-rx-flip\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\t \n\t\terr = xenbus_printf(xbt, dev->nodename,\n\t\t\t\t    \"feature-multicast-control\", \"%d\", 1);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-multicast-control\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\terr = xenbus_printf(xbt, dev->nodename,\n\t\t\t\t    \"feature-dynamic-multicast-control\",\n\t\t\t\t    \"%d\", 1);\n\t\tif (err) {\n\t\t\tmessage = \"writing feature-dynamic-multicast-control\";\n\t\t\tgoto abort_transaction;\n\t\t}\n\n\t\terr = xenbus_transaction_end(xbt, 0);\n\t} while (err == -EAGAIN);\n\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"completing transaction\");\n\t\tgoto fail;\n\t}\n\n\t \n\terr = xenbus_printf(XBT_NIL, dev->nodename,\n\t\t\t    \"feature-split-event-channels\",\n\t\t\t    \"%u\", separate_tx_rx_irq);\n\tif (err)\n\t\tpr_debug(\"Error writing feature-split-event-channels\\n\");\n\n\t \n\terr = xenbus_printf(XBT_NIL, dev->nodename,\n\t\t\t    \"multi-queue-max-queues\", \"%u\", xenvif_max_queues);\n\tif (err)\n\t\tpr_debug(\"Error writing multi-queue-max-queues\\n\");\n\n\terr = xenbus_printf(XBT_NIL, dev->nodename,\n\t\t\t    \"feature-ctrl-ring\",\n\t\t\t    \"%u\", true);\n\tif (err)\n\t\tpr_debug(\"Error writing feature-ctrl-ring\\n\");\n\n\tbackend_switch_state(be, XenbusStateInitWait);\n\n\tscript = xenbus_read(XBT_NIL, dev->nodename, \"script\", NULL);\n\tif (IS_ERR(script)) {\n\t\terr = PTR_ERR(script);\n\t\txenbus_dev_fatal(dev, err, \"reading script\");\n\t\tgoto fail;\n\t}\n\n\tbe->hotplug_script = script;\n\n\t \n\terr = backend_create_xenvif(be);\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\nabort_transaction:\n\txenbus_transaction_end(xbt, 1);\n\txenbus_dev_fatal(dev, err, \"%s\", message);\nfail:\n\tpr_debug(\"failed\\n\");\n\tnetback_remove(dev);\n\treturn err;\n}\n\nstatic const struct xenbus_device_id netback_ids[] = {\n\t{ \"vif\" },\n\t{ \"\" }\n};\n\nstatic struct xenbus_driver netback_driver = {\n\t.ids = netback_ids,\n\t.probe = netback_probe,\n\t.remove = netback_remove,\n\t.uevent = netback_uevent,\n\t.otherend_changed = frontend_changed,\n\t.allow_rebind = true,\n};\n\nint xenvif_xenbus_init(void)\n{\n\treturn xenbus_register_backend(&netback_driver);\n}\n\nvoid xenvif_xenbus_fini(void)\n{\n\treturn xenbus_unregister_driver(&netback_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}