{
  "module_name": "common.h",
  "hash_id": "cd6755a01cc85b6da554ad347082884b2a1ec77788f34bebb473fc6069825ca6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/xen-netback/common.h",
  "human_readable_source": " \n\n#ifndef __XEN_NETBACK__COMMON_H__\n#define __XEN_NETBACK__COMMON_H__\n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#include <xen/interface/io/netif.h>\n#include <xen/interface/grant_table.h>\n#include <xen/grant_table.h>\n#include <xen/xenbus.h>\n#include <xen/page.h>\n#include <linux/debugfs.h>\n\ntypedef unsigned int pending_ring_idx_t;\n\nstruct pending_tx_info {\n\tstruct xen_netif_tx_request req;  \n\tunsigned int extra_count;\n\t \n\tstruct ubuf_info_msgzc callback_struct;\n};\n\n#define XEN_NETIF_TX_RING_SIZE __CONST_RING_SIZE(xen_netif_tx, XEN_PAGE_SIZE)\n#define XEN_NETIF_RX_RING_SIZE __CONST_RING_SIZE(xen_netif_rx, XEN_PAGE_SIZE)\n\nstruct xenvif_rx_meta {\n\tint id;\n\tint size;\n\tint gso_type;\n\tint gso_size;\n};\n\n#define GSO_BIT(type) \\\n\t(1 << XEN_NETIF_GSO_TYPE_ ## type)\n\n \n#define INVALID_PENDING_IDX 0xFFFF\n\n#define MAX_PENDING_REQS XEN_NETIF_TX_RING_SIZE\n\n \n#define MAX_XEN_SKB_FRAGS (65536 / XEN_PAGE_SIZE + 1)\n\n#define NETBACK_INVALID_HANDLE -1\n\n \n#define XEN_NETBK_LEGACY_SLOTS_MAX XEN_NETIF_NR_SLOTS_MIN\n\n \n#define QUEUE_NAME_SIZE (IFNAMSIZ + 5)\n\n \n#define IRQ_NAME_SIZE (QUEUE_NAME_SIZE + 3)\n\nstruct xenvif;\n\nstruct xenvif_stats {\n\t \n\tu64 rx_bytes;\n\tu64 rx_packets;\n\tu64 tx_bytes;\n\tu64 tx_packets;\n\n\t \n\tunsigned long rx_gso_checksum_fixup;\n\tunsigned long tx_zerocopy_sent;\n\tunsigned long tx_zerocopy_success;\n\tunsigned long tx_zerocopy_fail;\n\tunsigned long tx_frag_overflow;\n};\n\n#define COPY_BATCH_SIZE 64\n\nstruct xenvif_copy_state {\n\tstruct gnttab_copy op[COPY_BATCH_SIZE];\n\tRING_IDX idx[COPY_BATCH_SIZE];\n\tunsigned int num;\n\tstruct sk_buff_head *completed;\n};\n\nstruct xenvif_queue {  \n\tunsigned int id;  \n\tchar name[QUEUE_NAME_SIZE];  \n\tstruct xenvif *vif;  \n\n\t \n\tatomic_t eoi_pending;\n#define NETBK_RX_EOI\t\t0x01\n#define NETBK_TX_EOI\t\t0x02\n#define NETBK_COMMON_EOI\t0x04\n\n\t \n\tstruct napi_struct napi;\n\t \n\tunsigned int tx_irq;\n\t \n\tchar tx_irq_name[IRQ_NAME_SIZE];  \n\tstruct xen_netif_tx_back_ring tx;\n\tstruct sk_buff_head tx_queue;\n\tstruct page *mmap_pages[MAX_PENDING_REQS];\n\tpending_ring_idx_t pending_prod;\n\tpending_ring_idx_t pending_cons;\n\tu16 pending_ring[MAX_PENDING_REQS];\n\tstruct pending_tx_info pending_tx_info[MAX_PENDING_REQS];\n\tgrant_handle_t grant_tx_handle[MAX_PENDING_REQS];\n\n\tstruct gnttab_copy tx_copy_ops[2 * MAX_PENDING_REQS];\n\tstruct gnttab_map_grant_ref tx_map_ops[MAX_PENDING_REQS];\n\tstruct gnttab_unmap_grant_ref tx_unmap_ops[MAX_PENDING_REQS];\n\t \n\tstruct page *pages_to_map[MAX_PENDING_REQS];\n\tstruct page *pages_to_unmap[MAX_PENDING_REQS];\n\n\t \n\tspinlock_t callback_lock;\n\t \n\tspinlock_t response_lock;\n\tpending_ring_idx_t dealloc_prod;\n\tpending_ring_idx_t dealloc_cons;\n\tu16 dealloc_ring[MAX_PENDING_REQS];\n\tstruct task_struct *dealloc_task;\n\twait_queue_head_t dealloc_wq;\n\tatomic_t inflight_packets;\n\n\t \n\tstruct task_struct *task;\n\twait_queue_head_t wq;\n\t \n\tunsigned int rx_irq;\n\t \n\tchar rx_irq_name[IRQ_NAME_SIZE];  \n\tstruct xen_netif_rx_back_ring rx;\n\tstruct sk_buff_head rx_queue;\n\n\tunsigned int rx_queue_max;\n\tunsigned int rx_queue_len;\n\tunsigned long last_rx_time;\n\tunsigned int rx_slots_needed;\n\tbool stalled;\n\n\tstruct xenvif_copy_state rx_copy;\n\n\t \n\tunsigned long   credit_bytes;\n\tunsigned long   credit_usec;\n\tunsigned long   remaining_credit;\n\tstruct timer_list credit_timeout;\n\tu64 credit_window_start;\n\tbool rate_limited;\n\n\t \n\tstruct xenvif_stats stats;\n};\n\nenum state_bit_shift {\n\t \n\tVIF_STATUS_CONNECTED,\n};\n\nstruct xenvif_mcast_addr {\n\tstruct list_head entry;\n\tstruct rcu_head rcu;\n\tu8 addr[6];\n};\n\n#define XEN_NETBK_MCAST_MAX 64\n\n#define XEN_NETBK_MAX_HASH_KEY_SIZE 40\n#define XEN_NETBK_MAX_HASH_MAPPING_SIZE 128\n#define XEN_NETBK_HASH_TAG_SIZE 40\n\nstruct xenvif_hash_cache_entry {\n\tstruct list_head link;\n\tstruct rcu_head rcu;\n\tu8 tag[XEN_NETBK_HASH_TAG_SIZE];\n\tunsigned int len;\n\tu32 val;\n\tint seq;\n};\n\nstruct xenvif_hash_cache {\n\tspinlock_t lock;\n\tstruct list_head list;\n\tunsigned int count;\n\tatomic_t seq;\n};\n\nstruct xenvif_hash {\n\tunsigned int alg;\n\tu32 flags;\n\tbool mapping_sel;\n\tu8 key[XEN_NETBK_MAX_HASH_KEY_SIZE];\n\tu32 mapping[2][XEN_NETBK_MAX_HASH_MAPPING_SIZE];\n\tunsigned int size;\n\tstruct xenvif_hash_cache cache;\n};\n\nstruct backend_info {\n\tstruct xenbus_device *dev;\n\tstruct xenvif *vif;\n\n\t \n\tenum xenbus_state state;\n\n\tenum xenbus_state frontend_state;\n\tstruct xenbus_watch hotplug_status_watch;\n\tu8 have_hotplug_status_watch:1;\n\n\tconst char *hotplug_script;\n};\n\nstruct xenvif {\n\t \n\tdomid_t          domid;\n\tunsigned int     handle;\n\n\tu8               fe_dev_addr[6];\n\tstruct list_head fe_mcast_addr;\n\tunsigned int     fe_mcast_count;\n\n\t \n\tint gso_mask;\n\n\tu8 can_sg:1;\n\tu8 ip_csum:1;\n\tu8 ipv6_csum:1;\n\tu8 multicast_control:1;\n\n\t \n\tu16 xdp_headroom;\n\n\t \n\tbool disabled;\n\tunsigned long status;\n\tunsigned long drain_timeout;\n\tunsigned long stall_timeout;\n\n\t \n\tstruct xenvif_queue *queues;\n\tunsigned int num_queues;  \n\tunsigned int stalled_queues;\n\n\tstruct xenvif_hash hash;\n\n\tstruct xenbus_watch credit_watch;\n\tstruct xenbus_watch mcast_ctrl_watch;\n\n\tstruct backend_info *be;\n\n\tspinlock_t lock;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *xenvif_dbg_root;\n#endif\n\n\tstruct xen_netif_ctrl_back_ring ctrl;\n\tunsigned int ctrl_irq;\n\n\t \n\tstruct net_device *dev;\n};\n\nstruct xenvif_rx_cb {\n\tunsigned long expires;\n\tint meta_slots_used;\n};\n\n#define XENVIF_RX_CB(skb) ((struct xenvif_rx_cb *)(skb)->cb)\n\nstatic inline struct xenbus_device *xenvif_to_xenbus_device(struct xenvif *vif)\n{\n\treturn to_xenbus_device(vif->dev->dev.parent);\n}\n\nvoid xenvif_tx_credit_callback(struct timer_list *t);\n\nstruct xenvif *xenvif_alloc(struct device *parent,\n\t\t\t    domid_t domid,\n\t\t\t    unsigned int handle);\n\nint xenvif_init_queue(struct xenvif_queue *queue);\nvoid xenvif_deinit_queue(struct xenvif_queue *queue);\n\nint xenvif_connect_data(struct xenvif_queue *queue,\n\t\t\tunsigned long tx_ring_ref,\n\t\t\tunsigned long rx_ring_ref,\n\t\t\tunsigned int tx_evtchn,\n\t\t\tunsigned int rx_evtchn);\nvoid xenvif_disconnect_data(struct xenvif *vif);\nint xenvif_connect_ctrl(struct xenvif *vif, grant_ref_t ring_ref,\n\t\t\tunsigned int evtchn);\nvoid xenvif_disconnect_ctrl(struct xenvif *vif);\nvoid xenvif_free(struct xenvif *vif);\n\nint xenvif_xenbus_init(void);\nvoid xenvif_xenbus_fini(void);\n\n \nvoid xenvif_unmap_frontend_data_rings(struct xenvif_queue *queue);\nint xenvif_map_frontend_data_rings(struct xenvif_queue *queue,\n\t\t\t\t   grant_ref_t tx_ring_ref,\n\t\t\t\t   grant_ref_t rx_ring_ref);\n\n \nvoid xenvif_napi_schedule_or_enable_events(struct xenvif_queue *queue);\n\n \nvoid xenvif_carrier_off(struct xenvif *vif);\n\nint xenvif_tx_action(struct xenvif_queue *queue, int budget);\n\nint xenvif_kthread_guest_rx(void *data);\nvoid xenvif_kick_thread(struct xenvif_queue *queue);\n\nint xenvif_dealloc_kthread(void *data);\n\nirqreturn_t xenvif_ctrl_irq_fn(int irq, void *data);\n\nbool xenvif_have_rx_work(struct xenvif_queue *queue, bool test_kthread);\nbool xenvif_rx_queue_tail(struct xenvif_queue *queue, struct sk_buff *skb);\n\nvoid xenvif_carrier_on(struct xenvif *vif);\n\n \nvoid xenvif_zerocopy_callback(struct sk_buff *skb, struct ubuf_info *ubuf,\n\t\t\t      bool zerocopy_success);\n\nstatic inline pending_ring_idx_t nr_pending_reqs(struct xenvif_queue *queue)\n{\n\treturn MAX_PENDING_REQS -\n\t\tqueue->pending_prod + queue->pending_cons;\n}\n\nirqreturn_t xenvif_interrupt(int irq, void *dev_id);\n\nextern bool separate_tx_rx_irq;\nextern bool provides_xdp_headroom;\n\nextern unsigned int rx_drain_timeout_msecs;\nextern unsigned int rx_stall_timeout_msecs;\nextern unsigned int xenvif_max_queues;\nextern unsigned int xenvif_hash_cache_size;\n\n#ifdef CONFIG_DEBUG_FS\nextern struct dentry *xen_netback_dbg_root;\n#endif\n\nvoid xenvif_skb_zerocopy_prepare(struct xenvif_queue *queue,\n\t\t\t\t struct sk_buff *skb);\nvoid xenvif_skb_zerocopy_complete(struct xenvif_queue *queue);\n\n \nbool xenvif_mcast_match(struct xenvif *vif, const u8 *addr);\nvoid xenvif_mcast_addr_list_free(struct xenvif *vif);\n\n \nvoid xenvif_init_hash(struct xenvif *vif);\nvoid xenvif_deinit_hash(struct xenvif *vif);\n\nu32 xenvif_set_hash_alg(struct xenvif *vif, u32 alg);\nu32 xenvif_get_hash_flags(struct xenvif *vif, u32 *flags);\nu32 xenvif_set_hash_flags(struct xenvif *vif, u32 flags);\nu32 xenvif_set_hash_key(struct xenvif *vif, u32 gref, u32 len);\nu32 xenvif_set_hash_mapping_size(struct xenvif *vif, u32 size);\nu32 xenvif_set_hash_mapping(struct xenvif *vif, u32 gref, u32 len,\n\t\t\t    u32 off);\n\nvoid xenvif_set_skb_hash(struct xenvif *vif, struct sk_buff *skb);\n\n#ifdef CONFIG_DEBUG_FS\nvoid xenvif_dump_hash_info(struct xenvif *vif, struct seq_file *m);\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}