{
  "module_name": "hash.c",
  "hash_id": "48f4dfa0672633b4fe6ed40cf1c4a946f18ddb62a80155fd7f9e48652ebe73c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/xen-netback/hash.c",
  "human_readable_source": " \n\n#define XEN_NETIF_DEFINE_TOEPLITZ\n\n#include \"common.h\"\n#include <linux/vmalloc.h>\n#include <linux/rculist.h>\n\nstatic void xenvif_add_hash(struct xenvif *vif, const u8 *tag,\n\t\t\t    unsigned int len, u32 val)\n{\n\tstruct xenvif_hash_cache_entry *new, *entry, *oldest;\n\tunsigned long flags;\n\tbool found;\n\n\tnew = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!new)\n\t\treturn;\n\n\tmemcpy(new->tag, tag, len);\n\tnew->len = len;\n\tnew->val = val;\n\n\tspin_lock_irqsave(&vif->hash.cache.lock, flags);\n\n\tfound = false;\n\toldest = NULL;\n\tlist_for_each_entry_rcu(entry, &vif->hash.cache.list, link,\n\t\t\t\tlockdep_is_held(&vif->hash.cache.lock)) {\n\t\t \n\t\tif (entry->len == len &&\n\t\t    memcmp(entry->tag, tag, len) == 0)\n\t\t\tfound = true;\n\t\tif (!oldest || entry->seq < oldest->seq)\n\t\t\toldest = entry;\n\t}\n\n\tif (!found) {\n\t\tnew->seq = atomic_inc_return(&vif->hash.cache.seq);\n\t\tlist_add_rcu(&new->link, &vif->hash.cache.list);\n\n\t\tif (++vif->hash.cache.count > xenvif_hash_cache_size) {\n\t\t\tlist_del_rcu(&oldest->link);\n\t\t\tvif->hash.cache.count--;\n\t\t\tkfree_rcu(oldest, rcu);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&vif->hash.cache.lock, flags);\n\n\tif (found)\n\t\tkfree(new);\n}\n\nstatic u32 xenvif_new_hash(struct xenvif *vif, const u8 *data,\n\t\t\t   unsigned int len)\n{\n\tu32 val;\n\n\tval = xen_netif_toeplitz_hash(vif->hash.key,\n\t\t\t\t      sizeof(vif->hash.key),\n\t\t\t\t      data, len);\n\n\tif (xenvif_hash_cache_size != 0)\n\t\txenvif_add_hash(vif, data, len, val);\n\n\treturn val;\n}\n\nstatic void xenvif_flush_hash(struct xenvif *vif)\n{\n\tstruct xenvif_hash_cache_entry *entry;\n\tunsigned long flags;\n\n\tif (xenvif_hash_cache_size == 0)\n\t\treturn;\n\n\tspin_lock_irqsave(&vif->hash.cache.lock, flags);\n\n\tlist_for_each_entry_rcu(entry, &vif->hash.cache.list, link,\n\t\t\t\tlockdep_is_held(&vif->hash.cache.lock)) {\n\t\tlist_del_rcu(&entry->link);\n\t\tvif->hash.cache.count--;\n\t\tkfree_rcu(entry, rcu);\n\t}\n\n\tspin_unlock_irqrestore(&vif->hash.cache.lock, flags);\n}\n\nstatic u32 xenvif_find_hash(struct xenvif *vif, const u8 *data,\n\t\t\t    unsigned int len)\n{\n\tstruct xenvif_hash_cache_entry *entry;\n\tu32 val;\n\tbool found;\n\n\tif (len >= XEN_NETBK_HASH_TAG_SIZE)\n\t\treturn 0;\n\n\tif (xenvif_hash_cache_size == 0)\n\t\treturn xenvif_new_hash(vif, data, len);\n\n\trcu_read_lock();\n\n\tfound = false;\n\n\tlist_for_each_entry_rcu(entry, &vif->hash.cache.list, link) {\n\t\tif (entry->len == len &&\n\t\t    memcmp(entry->tag, data, len) == 0) {\n\t\t\tval = entry->val;\n\t\t\tentry->seq = atomic_inc_return(&vif->hash.cache.seq);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (!found)\n\t\tval = xenvif_new_hash(vif, data, len);\n\n\treturn val;\n}\n\nvoid xenvif_set_skb_hash(struct xenvif *vif, struct sk_buff *skb)\n{\n\tstruct flow_keys flow;\n\tu32 hash = 0;\n\tenum pkt_hash_types type = PKT_HASH_TYPE_NONE;\n\tu32 flags = vif->hash.flags;\n\tbool has_tcp_hdr;\n\n\t \n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tif (flags & (XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP |\n\t\t\t     XEN_NETIF_CTRL_HASH_TYPE_IPV4))\n\t\t\tbreak;\n\n\t\tgoto done;\n\n\tcase htons(ETH_P_IPV6):\n\t\tif (flags & (XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP |\n\t\t\t     XEN_NETIF_CTRL_HASH_TYPE_IPV6))\n\t\t\tbreak;\n\n\t\tgoto done;\n\n\tdefault:\n\t\tgoto done;\n\t}\n\n\tmemset(&flow, 0, sizeof(flow));\n\tif (!skb_flow_dissect_flow_keys(skb, &flow, 0))\n\t\tgoto done;\n\n\thas_tcp_hdr = (flow.basic.ip_proto == IPPROTO_TCP) &&\n\t\t      !(flow.control.flags & FLOW_DIS_IS_FRAGMENT);\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tif (has_tcp_hdr &&\n\t\t    (flags & XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP)) {\n\t\t\tu8 data[12];\n\n\t\t\tmemcpy(&data[0], &flow.addrs.v4addrs.src, 4);\n\t\t\tmemcpy(&data[4], &flow.addrs.v4addrs.dst, 4);\n\t\t\tmemcpy(&data[8], &flow.ports.src, 2);\n\t\t\tmemcpy(&data[10], &flow.ports.dst, 2);\n\n\t\t\thash = xenvif_find_hash(vif, data, sizeof(data));\n\t\t\ttype = PKT_HASH_TYPE_L4;\n\t\t} else if (flags & XEN_NETIF_CTRL_HASH_TYPE_IPV4) {\n\t\t\tu8 data[8];\n\n\t\t\tmemcpy(&data[0], &flow.addrs.v4addrs.src, 4);\n\t\t\tmemcpy(&data[4], &flow.addrs.v4addrs.dst, 4);\n\n\t\t\thash = xenvif_find_hash(vif, data, sizeof(data));\n\t\t\ttype = PKT_HASH_TYPE_L3;\n\t\t}\n\n\t\tbreak;\n\n\tcase htons(ETH_P_IPV6):\n\t\tif (has_tcp_hdr &&\n\t\t    (flags & XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP)) {\n\t\t\tu8 data[36];\n\n\t\t\tmemcpy(&data[0], &flow.addrs.v6addrs.src, 16);\n\t\t\tmemcpy(&data[16], &flow.addrs.v6addrs.dst, 16);\n\t\t\tmemcpy(&data[32], &flow.ports.src, 2);\n\t\t\tmemcpy(&data[34], &flow.ports.dst, 2);\n\n\t\t\thash = xenvif_find_hash(vif, data, sizeof(data));\n\t\t\ttype = PKT_HASH_TYPE_L4;\n\t\t} else if (flags & XEN_NETIF_CTRL_HASH_TYPE_IPV6) {\n\t\t\tu8 data[32];\n\n\t\t\tmemcpy(&data[0], &flow.addrs.v6addrs.src, 16);\n\t\t\tmemcpy(&data[16], &flow.addrs.v6addrs.dst, 16);\n\n\t\t\thash = xenvif_find_hash(vif, data, sizeof(data));\n\t\t\ttype = PKT_HASH_TYPE_L3;\n\t\t}\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (type == PKT_HASH_TYPE_NONE)\n\t\tskb_clear_hash(skb);\n\telse\n\t\t__skb_set_sw_hash(skb, hash, type == PKT_HASH_TYPE_L4);\n}\n\nu32 xenvif_set_hash_alg(struct xenvif *vif, u32 alg)\n{\n\tswitch (alg) {\n\tcase XEN_NETIF_CTRL_HASH_ALGORITHM_NONE:\n\tcase XEN_NETIF_CTRL_HASH_ALGORITHM_TOEPLITZ:\n\t\tbreak;\n\n\tdefault:\n\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\t}\n\n\tvif->hash.alg = alg;\n\n\treturn XEN_NETIF_CTRL_STATUS_SUCCESS;\n}\n\nu32 xenvif_get_hash_flags(struct xenvif *vif, u32 *flags)\n{\n\tif (vif->hash.alg == XEN_NETIF_CTRL_HASH_ALGORITHM_NONE)\n\t\treturn XEN_NETIF_CTRL_STATUS_NOT_SUPPORTED;\n\n\t*flags = XEN_NETIF_CTRL_HASH_TYPE_IPV4 |\n\t\t XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP |\n\t\t XEN_NETIF_CTRL_HASH_TYPE_IPV6 |\n\t\t XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP;\n\n\treturn XEN_NETIF_CTRL_STATUS_SUCCESS;\n}\n\nu32 xenvif_set_hash_flags(struct xenvif *vif, u32 flags)\n{\n\tif (flags & ~(XEN_NETIF_CTRL_HASH_TYPE_IPV4 |\n\t\t      XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP |\n\t\t      XEN_NETIF_CTRL_HASH_TYPE_IPV6 |\n\t\t      XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP))\n\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\n\tif (vif->hash.alg == XEN_NETIF_CTRL_HASH_ALGORITHM_NONE)\n\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\n\tvif->hash.flags = flags;\n\n\treturn XEN_NETIF_CTRL_STATUS_SUCCESS;\n}\n\nu32 xenvif_set_hash_key(struct xenvif *vif, u32 gref, u32 len)\n{\n\tu8 *key = vif->hash.key;\n\tstruct gnttab_copy copy_op = {\n\t\t.source.u.ref = gref,\n\t\t.source.domid = vif->domid,\n\t\t.dest.u.gmfn = virt_to_gfn(key),\n\t\t.dest.domid = DOMID_SELF,\n\t\t.dest.offset = xen_offset_in_page(key),\n\t\t.len = len,\n\t\t.flags = GNTCOPY_source_gref\n\t};\n\n\tif (len > XEN_NETBK_MAX_HASH_KEY_SIZE)\n\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\n\tif (copy_op.len != 0) {\n\t\tgnttab_batch_copy(&copy_op, 1);\n\n\t\tif (copy_op.status != GNTST_okay)\n\t\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\t}\n\n\t \n\tif (len < XEN_NETBK_MAX_HASH_KEY_SIZE)\n\t\tmemset(key + len, 0, XEN_NETBK_MAX_HASH_KEY_SIZE - len);\n\n\txenvif_flush_hash(vif);\n\n\treturn XEN_NETIF_CTRL_STATUS_SUCCESS;\n}\n\nu32 xenvif_set_hash_mapping_size(struct xenvif *vif, u32 size)\n{\n\tif (size > XEN_NETBK_MAX_HASH_MAPPING_SIZE)\n\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\n\tvif->hash.size = size;\n\tmemset(vif->hash.mapping[vif->hash.mapping_sel], 0,\n\t       sizeof(u32) * size);\n\n\treturn XEN_NETIF_CTRL_STATUS_SUCCESS;\n}\n\nu32 xenvif_set_hash_mapping(struct xenvif *vif, u32 gref, u32 len,\n\t\t\t    u32 off)\n{\n\tu32 *mapping = vif->hash.mapping[!vif->hash.mapping_sel];\n\tunsigned int nr = 1;\n\tstruct gnttab_copy copy_op[2] = {{\n\t\t.source.u.ref = gref,\n\t\t.source.domid = vif->domid,\n\t\t.dest.domid = DOMID_SELF,\n\t\t.len = len * sizeof(*mapping),\n\t\t.flags = GNTCOPY_source_gref\n\t}};\n\n\tif ((off + len < off) || (off + len > vif->hash.size) ||\n\t    len > XEN_PAGE_SIZE / sizeof(*mapping))\n\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\n\tcopy_op[0].dest.u.gmfn = virt_to_gfn(mapping + off);\n\tcopy_op[0].dest.offset = xen_offset_in_page(mapping + off);\n\tif (copy_op[0].dest.offset + copy_op[0].len > XEN_PAGE_SIZE) {\n\t\tcopy_op[1] = copy_op[0];\n\t\tcopy_op[1].source.offset = XEN_PAGE_SIZE - copy_op[0].dest.offset;\n\t\tcopy_op[1].dest.u.gmfn = virt_to_gfn(mapping + off + len);\n\t\tcopy_op[1].dest.offset = 0;\n\t\tcopy_op[1].len = copy_op[0].len - copy_op[1].source.offset;\n\t\tcopy_op[0].len = copy_op[1].source.offset;\n\t\tnr = 2;\n\t}\n\n\tmemcpy(mapping, vif->hash.mapping[vif->hash.mapping_sel],\n\t       vif->hash.size * sizeof(*mapping));\n\n\tif (copy_op[0].len != 0) {\n\t\tgnttab_batch_copy(copy_op, nr);\n\n\t\tif (copy_op[0].status != GNTST_okay ||\n\t\t    copy_op[nr - 1].status != GNTST_okay)\n\t\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\t}\n\n\twhile (len-- != 0)\n\t\tif (mapping[off++] >= vif->num_queues)\n\t\t\treturn XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER;\n\n\tvif->hash.mapping_sel = !vif->hash.mapping_sel;\n\n\treturn XEN_NETIF_CTRL_STATUS_SUCCESS;\n}\n\n#ifdef CONFIG_DEBUG_FS\nvoid xenvif_dump_hash_info(struct xenvif *vif, struct seq_file *m)\n{\n\tunsigned int i;\n\n\tswitch (vif->hash.alg) {\n\tcase XEN_NETIF_CTRL_HASH_ALGORITHM_TOEPLITZ:\n\t\tseq_puts(m, \"Hash Algorithm: TOEPLITZ\\n\");\n\t\tbreak;\n\n\tcase XEN_NETIF_CTRL_HASH_ALGORITHM_NONE:\n\t\tseq_puts(m, \"Hash Algorithm: NONE\\n\");\n\t\tfallthrough;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (vif->hash.flags) {\n\t\tseq_puts(m, \"\\nHash Flags:\\n\");\n\n\t\tif (vif->hash.flags & XEN_NETIF_CTRL_HASH_TYPE_IPV4)\n\t\t\tseq_puts(m, \"- IPv4\\n\");\n\t\tif (vif->hash.flags & XEN_NETIF_CTRL_HASH_TYPE_IPV4_TCP)\n\t\t\tseq_puts(m, \"- IPv4 + TCP\\n\");\n\t\tif (vif->hash.flags & XEN_NETIF_CTRL_HASH_TYPE_IPV6)\n\t\t\tseq_puts(m, \"- IPv6\\n\");\n\t\tif (vif->hash.flags & XEN_NETIF_CTRL_HASH_TYPE_IPV6_TCP)\n\t\t\tseq_puts(m, \"- IPv6 + TCP\\n\");\n\t}\n\n\tseq_puts(m, \"\\nHash Key:\\n\");\n\n\tfor (i = 0; i < XEN_NETBK_MAX_HASH_KEY_SIZE; ) {\n\t\tunsigned int j, n;\n\n\t\tn = 8;\n\t\tif (i + n >= XEN_NETBK_MAX_HASH_KEY_SIZE)\n\t\t\tn = XEN_NETBK_MAX_HASH_KEY_SIZE - i;\n\n\t\tseq_printf(m, \"[%2u - %2u]: \", i, i + n - 1);\n\n\t\tfor (j = 0; j < n; j++, i++)\n\t\t\tseq_printf(m, \"%02x \", vif->hash.key[i]);\n\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (vif->hash.size != 0) {\n\t\tconst u32 *mapping = vif->hash.mapping[vif->hash.mapping_sel];\n\n\t\tseq_puts(m, \"\\nHash Mapping:\\n\");\n\n\t\tfor (i = 0; i < vif->hash.size; ) {\n\t\t\tunsigned int j, n;\n\n\t\t\tn = 8;\n\t\t\tif (i + n >= vif->hash.size)\n\t\t\t\tn = vif->hash.size - i;\n\n\t\t\tseq_printf(m, \"[%4u - %4u]: \", i, i + n - 1);\n\n\t\t\tfor (j = 0; j < n; j++, i++)\n\t\t\t\tseq_printf(m, \"%4u \", mapping[i]);\n\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t}\n}\n#endif  \n\nvoid xenvif_init_hash(struct xenvif *vif)\n{\n\tif (xenvif_hash_cache_size == 0)\n\t\treturn;\n\n\tBUG_ON(vif->hash.cache.count);\n\n\tspin_lock_init(&vif->hash.cache.lock);\n\tINIT_LIST_HEAD(&vif->hash.cache.list);\n}\n\nvoid xenvif_deinit_hash(struct xenvif *vif)\n{\n\txenvif_flush_hash(vif);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}