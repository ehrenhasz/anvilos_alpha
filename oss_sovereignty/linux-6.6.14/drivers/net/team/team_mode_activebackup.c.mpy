{
  "module_name": "team_mode_activebackup.c",
  "hash_id": "0e3e71db1f58309143a4bceb6e6b58e30fd19ffff4712b91211e2281d2eb8adf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/team/team_mode_activebackup.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <net/rtnetlink.h>\n#include <linux/if_team.h>\n\nstruct ab_priv {\n\tstruct team_port __rcu *active_port;\n\tstruct team_option_inst_info *ap_opt_inst_info;\n};\n\nstatic struct ab_priv *ab_priv(struct team *team)\n{\n\treturn (struct ab_priv *) &team->mode_priv;\n}\n\nstatic rx_handler_result_t ab_receive(struct team *team, struct team_port *port,\n\t\t\t\t      struct sk_buff *skb) {\n\tstruct team_port *active_port;\n\n\tactive_port = rcu_dereference(ab_priv(team)->active_port);\n\tif (active_port != port)\n\t\treturn RX_HANDLER_EXACT;\n\treturn RX_HANDLER_ANOTHER;\n}\n\nstatic bool ab_transmit(struct team *team, struct sk_buff *skb)\n{\n\tstruct team_port *active_port;\n\n\tactive_port = rcu_dereference_bh(ab_priv(team)->active_port);\n\tif (unlikely(!active_port))\n\t\tgoto drop;\n\tif (team_dev_queue_xmit(team, active_port, skb))\n\t\treturn false;\n\treturn true;\n\ndrop:\n\tdev_kfree_skb_any(skb);\n\treturn false;\n}\n\nstatic void ab_port_leave(struct team *team, struct team_port *port)\n{\n\tif (ab_priv(team)->active_port == port) {\n\t\tRCU_INIT_POINTER(ab_priv(team)->active_port, NULL);\n\t\tteam_option_inst_set_change(ab_priv(team)->ap_opt_inst_info);\n\t}\n}\n\nstatic void ab_active_port_init(struct team *team,\n\t\t\t\tstruct team_option_inst_info *info)\n{\n\tab_priv(team)->ap_opt_inst_info = info;\n}\n\nstatic void ab_active_port_get(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *active_port;\n\n\tactive_port = rcu_dereference_protected(ab_priv(team)->active_port,\n\t\t\t\t\t\tlockdep_is_held(&team->lock));\n\tif (active_port)\n\t\tctx->data.u32_val = active_port->dev->ifindex;\n\telse\n\t\tctx->data.u32_val = 0;\n}\n\nstatic int ab_active_port_set(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port;\n\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\tif (port->dev->ifindex == ctx->data.u32_val) {\n\t\t\trcu_assign_pointer(ab_priv(team)->active_port, port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic const struct team_option ab_options[] = {\n\t{\n\t\t.name = \"activeport\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.init = ab_active_port_init,\n\t\t.getter = ab_active_port_get,\n\t\t.setter = ab_active_port_set,\n\t},\n};\n\nstatic int ab_init(struct team *team)\n{\n\treturn team_options_register(team, ab_options, ARRAY_SIZE(ab_options));\n}\n\nstatic void ab_exit(struct team *team)\n{\n\tteam_options_unregister(team, ab_options, ARRAY_SIZE(ab_options));\n}\n\nstatic const struct team_mode_ops ab_mode_ops = {\n\t.init\t\t\t= ab_init,\n\t.exit\t\t\t= ab_exit,\n\t.receive\t\t= ab_receive,\n\t.transmit\t\t= ab_transmit,\n\t.port_leave\t\t= ab_port_leave,\n};\n\nstatic const struct team_mode ab_mode = {\n\t.kind\t\t= \"activebackup\",\n\t.owner\t\t= THIS_MODULE,\n\t.priv_size\t= sizeof(struct ab_priv),\n\t.ops\t\t= &ab_mode_ops,\n\t.lag_tx_type\t= NETDEV_LAG_TX_TYPE_ACTIVEBACKUP,\n};\n\nstatic int __init ab_init_module(void)\n{\n\treturn team_mode_register(&ab_mode);\n}\n\nstatic void __exit ab_cleanup_module(void)\n{\n\tteam_mode_unregister(&ab_mode);\n}\n\nmodule_init(ab_init_module);\nmodule_exit(ab_cleanup_module);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jiri Pirko <jpirko@redhat.com>\");\nMODULE_DESCRIPTION(\"Active-backup mode for team\");\nMODULE_ALIAS_TEAM_MODE(\"activebackup\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}