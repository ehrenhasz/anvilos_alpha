{
  "module_name": "team.c",
  "hash_id": "4b8fc92e46aea79f47c4ed3d84ec4431662a4a207b92068cb18080d163eef710",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/team/team.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/netpoll.h>\n#include <linux/if_vlan.h>\n#include <linux/if_arp.h>\n#include <linux/socket.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/rtnetlink.h>\n#include <net/genetlink.h>\n#include <net/netlink.h>\n#include <net/sch_generic.h>\n#include <generated/utsrelease.h>\n#include <linux/if_team.h>\n\n#define DRV_NAME \"team\"\n\n\n \n\nstatic struct team_port *team_port_get_rtnl(const struct net_device *dev)\n{\n\tstruct team_port *port = rtnl_dereference(dev->rx_handler_data);\n\n\treturn netif_is_team_port(dev) ? port : NULL;\n}\n\n \nstatic int __set_port_dev_addr(struct net_device *port_dev,\n\t\t\t       const unsigned char *dev_addr)\n{\n\tstruct sockaddr_storage addr;\n\n\tmemcpy(addr.__data, dev_addr, port_dev->addr_len);\n\taddr.ss_family = port_dev->type;\n\treturn dev_set_mac_address(port_dev, (struct sockaddr *)&addr, NULL);\n}\n\nstatic int team_port_set_orig_dev_addr(struct team_port *port)\n{\n\treturn __set_port_dev_addr(port->dev, port->orig.dev_addr);\n}\n\nstatic int team_port_set_team_dev_addr(struct team *team,\n\t\t\t\t       struct team_port *port)\n{\n\treturn __set_port_dev_addr(port->dev, team->dev->dev_addr);\n}\n\nint team_modeop_port_enter(struct team *team, struct team_port *port)\n{\n\treturn team_port_set_team_dev_addr(team, port);\n}\nEXPORT_SYMBOL(team_modeop_port_enter);\n\nvoid team_modeop_port_change_dev_addr(struct team *team,\n\t\t\t\t      struct team_port *port)\n{\n\tteam_port_set_team_dev_addr(team, port);\n}\nEXPORT_SYMBOL(team_modeop_port_change_dev_addr);\n\nstatic void team_lower_state_changed(struct team_port *port)\n{\n\tstruct netdev_lag_lower_state_info info;\n\n\tinfo.link_up = port->linkup;\n\tinfo.tx_enabled = team_port_enabled(port);\n\tnetdev_lower_state_changed(port->dev, &info);\n}\n\nstatic void team_refresh_port_linkup(struct team_port *port)\n{\n\tbool new_linkup = port->user.linkup_enabled ? port->user.linkup :\n\t\t\t\t\t\t      port->state.linkup;\n\n\tif (port->linkup != new_linkup) {\n\t\tport->linkup = new_linkup;\n\t\tteam_lower_state_changed(port);\n\t}\n}\n\n\n \n\nstruct team_option_inst {  \n\tstruct list_head list;\n\tstruct list_head tmp_list;\n\tstruct team_option *option;\n\tstruct team_option_inst_info info;\n\tbool changed;\n\tbool removed;\n};\n\nstatic struct team_option *__team_find_option(struct team *team,\n\t\t\t\t\t      const char *opt_name)\n{\n\tstruct team_option *option;\n\n\tlist_for_each_entry(option, &team->option_list, list) {\n\t\tif (strcmp(option->name, opt_name) == 0)\n\t\t\treturn option;\n\t}\n\treturn NULL;\n}\n\nstatic void __team_option_inst_del(struct team_option_inst *opt_inst)\n{\n\tlist_del(&opt_inst->list);\n\tkfree(opt_inst);\n}\n\nstatic void __team_option_inst_del_option(struct team *team,\n\t\t\t\t\t  struct team_option *option)\n{\n\tstruct team_option_inst *opt_inst, *tmp;\n\n\tlist_for_each_entry_safe(opt_inst, tmp, &team->option_inst_list, list) {\n\t\tif (opt_inst->option == option)\n\t\t\t__team_option_inst_del(opt_inst);\n\t}\n}\n\nstatic int __team_option_inst_add(struct team *team, struct team_option *option,\n\t\t\t\t  struct team_port *port)\n{\n\tstruct team_option_inst *opt_inst;\n\tunsigned int array_size;\n\tunsigned int i;\n\n\tarray_size = option->array_size;\n\tif (!array_size)\n\t\tarray_size = 1;  \n\n\tfor (i = 0; i < array_size; i++) {\n\t\topt_inst = kmalloc(sizeof(*opt_inst), GFP_KERNEL);\n\t\tif (!opt_inst)\n\t\t\treturn -ENOMEM;\n\t\topt_inst->option = option;\n\t\topt_inst->info.port = port;\n\t\topt_inst->info.array_index = i;\n\t\topt_inst->changed = true;\n\t\topt_inst->removed = false;\n\t\tlist_add_tail(&opt_inst->list, &team->option_inst_list);\n\t\tif (option->init)\n\t\t\toption->init(team, &opt_inst->info);\n\n\t}\n\treturn 0;\n}\n\nstatic int __team_option_inst_add_option(struct team *team,\n\t\t\t\t\t struct team_option *option)\n{\n\tint err;\n\n\tif (!option->per_port) {\n\t\terr = __team_option_inst_add(team, option, NULL);\n\t\tif (err)\n\t\t\tgoto inst_del_option;\n\t}\n\treturn 0;\n\ninst_del_option:\n\t__team_option_inst_del_option(team, option);\n\treturn err;\n}\n\nstatic void __team_option_inst_mark_removed_option(struct team *team,\n\t\t\t\t\t\t   struct team_option *option)\n{\n\tstruct team_option_inst *opt_inst;\n\n\tlist_for_each_entry(opt_inst, &team->option_inst_list, list) {\n\t\tif (opt_inst->option == option) {\n\t\t\topt_inst->changed = true;\n\t\t\topt_inst->removed = true;\n\t\t}\n\t}\n}\n\nstatic void __team_option_inst_del_port(struct team *team,\n\t\t\t\t\tstruct team_port *port)\n{\n\tstruct team_option_inst *opt_inst, *tmp;\n\n\tlist_for_each_entry_safe(opt_inst, tmp, &team->option_inst_list, list) {\n\t\tif (opt_inst->option->per_port &&\n\t\t    opt_inst->info.port == port)\n\t\t\t__team_option_inst_del(opt_inst);\n\t}\n}\n\nstatic int __team_option_inst_add_port(struct team *team,\n\t\t\t\t       struct team_port *port)\n{\n\tstruct team_option *option;\n\tint err;\n\n\tlist_for_each_entry(option, &team->option_list, list) {\n\t\tif (!option->per_port)\n\t\t\tcontinue;\n\t\terr = __team_option_inst_add(team, option, port);\n\t\tif (err)\n\t\t\tgoto inst_del_port;\n\t}\n\treturn 0;\n\ninst_del_port:\n\t__team_option_inst_del_port(team, port);\n\treturn err;\n}\n\nstatic void __team_option_inst_mark_removed_port(struct team *team,\n\t\t\t\t\t\t struct team_port *port)\n{\n\tstruct team_option_inst *opt_inst;\n\n\tlist_for_each_entry(opt_inst, &team->option_inst_list, list) {\n\t\tif (opt_inst->info.port == port) {\n\t\t\topt_inst->changed = true;\n\t\t\topt_inst->removed = true;\n\t\t}\n\t}\n}\n\nstatic int __team_options_register(struct team *team,\n\t\t\t\t   const struct team_option *option,\n\t\t\t\t   size_t option_count)\n{\n\tint i;\n\tstruct team_option **dst_opts;\n\tint err;\n\n\tdst_opts = kcalloc(option_count, sizeof(struct team_option *),\n\t\t\t   GFP_KERNEL);\n\tif (!dst_opts)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < option_count; i++, option++) {\n\t\tif (__team_find_option(team, option->name)) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto alloc_rollback;\n\t\t}\n\t\tdst_opts[i] = kmemdup(option, sizeof(*option), GFP_KERNEL);\n\t\tif (!dst_opts[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto alloc_rollback;\n\t\t}\n\t}\n\n\tfor (i = 0; i < option_count; i++) {\n\t\terr = __team_option_inst_add_option(team, dst_opts[i]);\n\t\tif (err)\n\t\t\tgoto inst_rollback;\n\t\tlist_add_tail(&dst_opts[i]->list, &team->option_list);\n\t}\n\n\tkfree(dst_opts);\n\treturn 0;\n\ninst_rollback:\n\tfor (i--; i >= 0; i--) {\n\t\t__team_option_inst_del_option(team, dst_opts[i]);\n\t\tlist_del(&dst_opts[i]->list);\n\t}\n\n\ti = option_count;\nalloc_rollback:\n\tfor (i--; i >= 0; i--)\n\t\tkfree(dst_opts[i]);\n\n\tkfree(dst_opts);\n\treturn err;\n}\n\nstatic void __team_options_mark_removed(struct team *team,\n\t\t\t\t\tconst struct team_option *option,\n\t\t\t\t\tsize_t option_count)\n{\n\tint i;\n\n\tfor (i = 0; i < option_count; i++, option++) {\n\t\tstruct team_option *del_opt;\n\n\t\tdel_opt = __team_find_option(team, option->name);\n\t\tif (del_opt)\n\t\t\t__team_option_inst_mark_removed_option(team, del_opt);\n\t}\n}\n\nstatic void __team_options_unregister(struct team *team,\n\t\t\t\t      const struct team_option *option,\n\t\t\t\t      size_t option_count)\n{\n\tint i;\n\n\tfor (i = 0; i < option_count; i++, option++) {\n\t\tstruct team_option *del_opt;\n\n\t\tdel_opt = __team_find_option(team, option->name);\n\t\tif (del_opt) {\n\t\t\t__team_option_inst_del_option(team, del_opt);\n\t\t\tlist_del(&del_opt->list);\n\t\t\tkfree(del_opt);\n\t\t}\n\t}\n}\n\nstatic void __team_options_change_check(struct team *team);\n\nint team_options_register(struct team *team,\n\t\t\t  const struct team_option *option,\n\t\t\t  size_t option_count)\n{\n\tint err;\n\n\terr = __team_options_register(team, option, option_count);\n\tif (err)\n\t\treturn err;\n\t__team_options_change_check(team);\n\treturn 0;\n}\nEXPORT_SYMBOL(team_options_register);\n\nvoid team_options_unregister(struct team *team,\n\t\t\t     const struct team_option *option,\n\t\t\t     size_t option_count)\n{\n\t__team_options_mark_removed(team, option, option_count);\n\t__team_options_change_check(team);\n\t__team_options_unregister(team, option, option_count);\n}\nEXPORT_SYMBOL(team_options_unregister);\n\nstatic int team_option_get(struct team *team,\n\t\t\t   struct team_option_inst *opt_inst,\n\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tif (!opt_inst->option->getter)\n\t\treturn -EOPNOTSUPP;\n\n\topt_inst->option->getter(team, ctx);\n\treturn 0;\n}\n\nstatic int team_option_set(struct team *team,\n\t\t\t   struct team_option_inst *opt_inst,\n\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tif (!opt_inst->option->setter)\n\t\treturn -EOPNOTSUPP;\n\treturn opt_inst->option->setter(team, ctx);\n}\n\nvoid team_option_inst_set_change(struct team_option_inst_info *opt_inst_info)\n{\n\tstruct team_option_inst *opt_inst;\n\n\topt_inst = container_of(opt_inst_info, struct team_option_inst, info);\n\topt_inst->changed = true;\n}\nEXPORT_SYMBOL(team_option_inst_set_change);\n\nvoid team_options_change_check(struct team *team)\n{\n\t__team_options_change_check(team);\n}\nEXPORT_SYMBOL(team_options_change_check);\n\n\n \n\nstatic LIST_HEAD(mode_list);\nstatic DEFINE_SPINLOCK(mode_list_lock);\n\nstruct team_mode_item {\n\tstruct list_head list;\n\tconst struct team_mode *mode;\n};\n\nstatic struct team_mode_item *__find_mode(const char *kind)\n{\n\tstruct team_mode_item *mitem;\n\n\tlist_for_each_entry(mitem, &mode_list, list) {\n\t\tif (strcmp(mitem->mode->kind, kind) == 0)\n\t\t\treturn mitem;\n\t}\n\treturn NULL;\n}\n\nstatic bool is_good_mode_name(const char *name)\n{\n\twhile (*name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t\tname++;\n\t}\n\treturn true;\n}\n\nint team_mode_register(const struct team_mode *mode)\n{\n\tint err = 0;\n\tstruct team_mode_item *mitem;\n\n\tif (!is_good_mode_name(mode->kind) ||\n\t    mode->priv_size > TEAM_MODE_PRIV_SIZE)\n\t\treturn -EINVAL;\n\n\tmitem = kmalloc(sizeof(*mitem), GFP_KERNEL);\n\tif (!mitem)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&mode_list_lock);\n\tif (__find_mode(mode->kind)) {\n\t\terr = -EEXIST;\n\t\tkfree(mitem);\n\t\tgoto unlock;\n\t}\n\tmitem->mode = mode;\n\tlist_add_tail(&mitem->list, &mode_list);\nunlock:\n\tspin_unlock(&mode_list_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(team_mode_register);\n\nvoid team_mode_unregister(const struct team_mode *mode)\n{\n\tstruct team_mode_item *mitem;\n\n\tspin_lock(&mode_list_lock);\n\tmitem = __find_mode(mode->kind);\n\tif (mitem) {\n\t\tlist_del_init(&mitem->list);\n\t\tkfree(mitem);\n\t}\n\tspin_unlock(&mode_list_lock);\n}\nEXPORT_SYMBOL(team_mode_unregister);\n\nstatic const struct team_mode *team_mode_get(const char *kind)\n{\n\tstruct team_mode_item *mitem;\n\tconst struct team_mode *mode = NULL;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn NULL;\n\n\tspin_lock(&mode_list_lock);\n\tmitem = __find_mode(kind);\n\tif (!mitem) {\n\t\tspin_unlock(&mode_list_lock);\n\t\trequest_module(\"team-mode-%s\", kind);\n\t\tspin_lock(&mode_list_lock);\n\t\tmitem = __find_mode(kind);\n\t}\n\tif (mitem) {\n\t\tmode = mitem->mode;\n\t\tif (!try_module_get(mode->owner))\n\t\t\tmode = NULL;\n\t}\n\n\tspin_unlock(&mode_list_lock);\n\tmodule_put(THIS_MODULE);\n\treturn mode;\n}\n\nstatic void team_mode_put(const struct team_mode *mode)\n{\n\tmodule_put(mode->owner);\n}\n\nstatic bool team_dummy_transmit(struct team *team, struct sk_buff *skb)\n{\n\tdev_kfree_skb_any(skb);\n\treturn false;\n}\n\nstatic rx_handler_result_t team_dummy_receive(struct team *team,\n\t\t\t\t\t      struct team_port *port,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\treturn RX_HANDLER_ANOTHER;\n}\n\nstatic const struct team_mode __team_no_mode = {\n\t.kind\t\t= \"*NOMODE*\",\n};\n\nstatic bool team_is_mode_set(struct team *team)\n{\n\treturn team->mode != &__team_no_mode;\n}\n\nstatic void team_set_no_mode(struct team *team)\n{\n\tteam->user_carrier_enabled = false;\n\tteam->mode = &__team_no_mode;\n}\n\nstatic void team_adjust_ops(struct team *team)\n{\n\t \n\n\tif (!team->en_port_count || !team_is_mode_set(team) ||\n\t    !team->mode->ops->transmit)\n\t\tteam->ops.transmit = team_dummy_transmit;\n\telse\n\t\tteam->ops.transmit = team->mode->ops->transmit;\n\n\tif (!team->en_port_count || !team_is_mode_set(team) ||\n\t    !team->mode->ops->receive)\n\t\tteam->ops.receive = team_dummy_receive;\n\telse\n\t\tteam->ops.receive = team->mode->ops->receive;\n}\n\n \nstatic int __team_change_mode(struct team *team,\n\t\t\t      const struct team_mode *new_mode)\n{\n\t \n\tif (team_is_mode_set(team)) {\n\t\tvoid (*exit_op)(struct team *team) = team->ops.exit;\n\n\t\t \n\t\tmemset(&team->ops, 0, sizeof(struct team_mode_ops));\n\t\tteam_adjust_ops(team);\n\n\t\tif (exit_op)\n\t\t\texit_op(team);\n\t\tteam_mode_put(team->mode);\n\t\tteam_set_no_mode(team);\n\t\t \n\t\tmemset(&team->mode_priv, 0,\n\t\t       sizeof(struct team) - offsetof(struct team, mode_priv));\n\t}\n\n\tif (!new_mode)\n\t\treturn 0;\n\n\tif (new_mode->ops->init) {\n\t\tint err;\n\n\t\terr = new_mode->ops->init(team);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tteam->mode = new_mode;\n\tmemcpy(&team->ops, new_mode->ops, sizeof(struct team_mode_ops));\n\tteam_adjust_ops(team);\n\n\treturn 0;\n}\n\nstatic int team_change_mode(struct team *team, const char *kind)\n{\n\tconst struct team_mode *new_mode;\n\tstruct net_device *dev = team->dev;\n\tint err;\n\n\tif (!list_empty(&team->port_list)) {\n\t\tnetdev_err(dev, \"No ports can be present during mode change\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (team_is_mode_set(team) && strcmp(team->mode->kind, kind) == 0) {\n\t\tnetdev_err(dev, \"Unable to change to the same mode the team is in\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_mode = team_mode_get(kind);\n\tif (!new_mode) {\n\t\tnetdev_err(dev, \"Mode \\\"%s\\\" not found\\n\", kind);\n\t\treturn -EINVAL;\n\t}\n\n\terr = __team_change_mode(team, new_mode);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to change to mode \\\"%s\\\"\\n\", kind);\n\t\tteam_mode_put(new_mode);\n\t\treturn err;\n\t}\n\n\tnetdev_info(dev, \"Mode changed to \\\"%s\\\"\\n\", kind);\n\treturn 0;\n}\n\n\n \n\nstatic void team_notify_peers_work(struct work_struct *work)\n{\n\tstruct team *team;\n\tint val;\n\n\tteam = container_of(work, struct team, notify_peers.dw.work);\n\n\tif (!rtnl_trylock()) {\n\t\tschedule_delayed_work(&team->notify_peers.dw, 0);\n\t\treturn;\n\t}\n\tval = atomic_dec_if_positive(&team->notify_peers.count_pending);\n\tif (val < 0) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\tcall_netdevice_notifiers(NETDEV_NOTIFY_PEERS, team->dev);\n\trtnl_unlock();\n\tif (val)\n\t\tschedule_delayed_work(&team->notify_peers.dw,\n\t\t\t\t      msecs_to_jiffies(team->notify_peers.interval));\n}\n\nstatic void team_notify_peers(struct team *team)\n{\n\tif (!team->notify_peers.count || !netif_running(team->dev))\n\t\treturn;\n\tatomic_add(team->notify_peers.count, &team->notify_peers.count_pending);\n\tschedule_delayed_work(&team->notify_peers.dw, 0);\n}\n\nstatic void team_notify_peers_init(struct team *team)\n{\n\tINIT_DELAYED_WORK(&team->notify_peers.dw, team_notify_peers_work);\n}\n\nstatic void team_notify_peers_fini(struct team *team)\n{\n\tcancel_delayed_work_sync(&team->notify_peers.dw);\n}\n\n\n \n\nstatic void team_mcast_rejoin_work(struct work_struct *work)\n{\n\tstruct team *team;\n\tint val;\n\n\tteam = container_of(work, struct team, mcast_rejoin.dw.work);\n\n\tif (!rtnl_trylock()) {\n\t\tschedule_delayed_work(&team->mcast_rejoin.dw, 0);\n\t\treturn;\n\t}\n\tval = atomic_dec_if_positive(&team->mcast_rejoin.count_pending);\n\tif (val < 0) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\tcall_netdevice_notifiers(NETDEV_RESEND_IGMP, team->dev);\n\trtnl_unlock();\n\tif (val)\n\t\tschedule_delayed_work(&team->mcast_rejoin.dw,\n\t\t\t\t      msecs_to_jiffies(team->mcast_rejoin.interval));\n}\n\nstatic void team_mcast_rejoin(struct team *team)\n{\n\tif (!team->mcast_rejoin.count || !netif_running(team->dev))\n\t\treturn;\n\tatomic_add(team->mcast_rejoin.count, &team->mcast_rejoin.count_pending);\n\tschedule_delayed_work(&team->mcast_rejoin.dw, 0);\n}\n\nstatic void team_mcast_rejoin_init(struct team *team)\n{\n\tINIT_DELAYED_WORK(&team->mcast_rejoin.dw, team_mcast_rejoin_work);\n}\n\nstatic void team_mcast_rejoin_fini(struct team *team)\n{\n\tcancel_delayed_work_sync(&team->mcast_rejoin.dw);\n}\n\n\n \n\n \nstatic rx_handler_result_t team_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct team_port *port;\n\tstruct team *team;\n\trx_handler_result_t res;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn RX_HANDLER_CONSUMED;\n\n\t*pskb = skb;\n\n\tport = team_port_get_rcu(skb->dev);\n\tteam = port->team;\n\tif (!team_port_enabled(port)) {\n\t\tif (is_link_local_ether_addr(eth_hdr(skb)->h_dest))\n\t\t\t \n\t\t\treturn RX_HANDLER_PASS;\n\t\t \n\t\tres = RX_HANDLER_EXACT;\n\t} else {\n\t\tres = team->ops.receive(team, port, skb);\n\t}\n\tif (res == RX_HANDLER_ANOTHER) {\n\t\tstruct team_pcpu_stats *pcpu_stats;\n\n\t\tpcpu_stats = this_cpu_ptr(team->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tu64_stats_inc(&pcpu_stats->rx_packets);\n\t\tu64_stats_add(&pcpu_stats->rx_bytes, skb->len);\n\t\tif (skb->pkt_type == PACKET_MULTICAST)\n\t\t\tu64_stats_inc(&pcpu_stats->rx_multicast);\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\n\t\tskb->dev = team->dev;\n\t} else if (res == RX_HANDLER_EXACT) {\n\t\tthis_cpu_inc(team->pcpu_stats->rx_nohandler);\n\t} else {\n\t\tthis_cpu_inc(team->pcpu_stats->rx_dropped);\n\t}\n\n\treturn res;\n}\n\n\n \n\nstatic int team_queue_override_init(struct team *team)\n{\n\tstruct list_head *listarr;\n\tunsigned int queue_cnt = team->dev->num_tx_queues - 1;\n\tunsigned int i;\n\n\tif (!queue_cnt)\n\t\treturn 0;\n\tlistarr = kmalloc_array(queue_cnt, sizeof(struct list_head),\n\t\t\t\tGFP_KERNEL);\n\tif (!listarr)\n\t\treturn -ENOMEM;\n\tteam->qom_lists = listarr;\n\tfor (i = 0; i < queue_cnt; i++)\n\t\tINIT_LIST_HEAD(listarr++);\n\treturn 0;\n}\n\nstatic void team_queue_override_fini(struct team *team)\n{\n\tkfree(team->qom_lists);\n}\n\nstatic struct list_head *__team_get_qom_list(struct team *team, u16 queue_id)\n{\n\treturn &team->qom_lists[queue_id - 1];\n}\n\n \nstatic bool team_queue_override_transmit(struct team *team, struct sk_buff *skb)\n{\n\tstruct list_head *qom_list;\n\tstruct team_port *port;\n\n\tif (!team->queue_override_enabled || !skb->queue_mapping)\n\t\treturn false;\n\tqom_list = __team_get_qom_list(team, skb->queue_mapping);\n\tlist_for_each_entry_rcu(port, qom_list, qom_list) {\n\t\tif (!team_dev_queue_xmit(team, port, skb))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void __team_queue_override_port_del(struct team *team,\n\t\t\t\t\t   struct team_port *port)\n{\n\tif (!port->queue_id)\n\t\treturn;\n\tlist_del_rcu(&port->qom_list);\n}\n\nstatic bool team_queue_override_port_has_gt_prio_than(struct team_port *port,\n\t\t\t\t\t\t      struct team_port *cur)\n{\n\tif (port->priority < cur->priority)\n\t\treturn true;\n\tif (port->priority > cur->priority)\n\t\treturn false;\n\tif (port->index < cur->index)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void __team_queue_override_port_add(struct team *team,\n\t\t\t\t\t   struct team_port *port)\n{\n\tstruct team_port *cur;\n\tstruct list_head *qom_list;\n\tstruct list_head *node;\n\n\tif (!port->queue_id)\n\t\treturn;\n\tqom_list = __team_get_qom_list(team, port->queue_id);\n\tnode = qom_list;\n\tlist_for_each_entry(cur, qom_list, qom_list) {\n\t\tif (team_queue_override_port_has_gt_prio_than(port, cur))\n\t\t\tbreak;\n\t\tnode = &cur->qom_list;\n\t}\n\tlist_add_tail_rcu(&port->qom_list, node);\n}\n\nstatic void __team_queue_override_enabled_check(struct team *team)\n{\n\tstruct team_port *port;\n\tbool enabled = false;\n\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\tif (port->queue_id) {\n\t\t\tenabled = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (enabled == team->queue_override_enabled)\n\t\treturn;\n\tnetdev_dbg(team->dev, \"%s queue override\\n\",\n\t\t   enabled ? \"Enabling\" : \"Disabling\");\n\tteam->queue_override_enabled = enabled;\n}\n\nstatic void team_queue_override_port_prio_changed(struct team *team,\n\t\t\t\t\t\t  struct team_port *port)\n{\n\tif (!port->queue_id || team_port_enabled(port))\n\t\treturn;\n\t__team_queue_override_port_del(team, port);\n\t__team_queue_override_port_add(team, port);\n\t__team_queue_override_enabled_check(team);\n}\n\nstatic void team_queue_override_port_change_queue_id(struct team *team,\n\t\t\t\t\t\t     struct team_port *port,\n\t\t\t\t\t\t     u16 new_queue_id)\n{\n\tif (team_port_enabled(port)) {\n\t\t__team_queue_override_port_del(team, port);\n\t\tport->queue_id = new_queue_id;\n\t\t__team_queue_override_port_add(team, port);\n\t\t__team_queue_override_enabled_check(team);\n\t} else {\n\t\tport->queue_id = new_queue_id;\n\t}\n}\n\nstatic void team_queue_override_port_add(struct team *team,\n\t\t\t\t\t struct team_port *port)\n{\n\t__team_queue_override_port_add(team, port);\n\t__team_queue_override_enabled_check(team);\n}\n\nstatic void team_queue_override_port_del(struct team *team,\n\t\t\t\t\t struct team_port *port)\n{\n\t__team_queue_override_port_del(team, port);\n\t__team_queue_override_enabled_check(team);\n}\n\n\n \n\nstatic bool team_port_find(const struct team *team,\n\t\t\t   const struct team_port *port)\n{\n\tstruct team_port *cur;\n\n\tlist_for_each_entry(cur, &team->port_list, list)\n\t\tif (cur == port)\n\t\t\treturn true;\n\treturn false;\n}\n\n \nstatic void team_port_enable(struct team *team,\n\t\t\t     struct team_port *port)\n{\n\tif (team_port_enabled(port))\n\t\treturn;\n\tport->index = team->en_port_count++;\n\thlist_add_head_rcu(&port->hlist,\n\t\t\t   team_port_index_hash(team, port->index));\n\tteam_adjust_ops(team);\n\tteam_queue_override_port_add(team, port);\n\tif (team->ops.port_enabled)\n\t\tteam->ops.port_enabled(team, port);\n\tteam_notify_peers(team);\n\tteam_mcast_rejoin(team);\n\tteam_lower_state_changed(port);\n}\n\nstatic void __reconstruct_port_hlist(struct team *team, int rm_index)\n{\n\tint i;\n\tstruct team_port *port;\n\n\tfor (i = rm_index + 1; i < team->en_port_count; i++) {\n\t\tport = team_get_port_by_index(team, i);\n\t\thlist_del_rcu(&port->hlist);\n\t\tport->index--;\n\t\thlist_add_head_rcu(&port->hlist,\n\t\t\t\t   team_port_index_hash(team, port->index));\n\t}\n}\n\nstatic void team_port_disable(struct team *team,\n\t\t\t      struct team_port *port)\n{\n\tif (!team_port_enabled(port))\n\t\treturn;\n\tif (team->ops.port_disabled)\n\t\tteam->ops.port_disabled(team, port);\n\thlist_del_rcu(&port->hlist);\n\t__reconstruct_port_hlist(team, port->index);\n\tport->index = -1;\n\tteam->en_port_count--;\n\tteam_queue_override_port_del(team, port);\n\tteam_adjust_ops(team);\n\tteam_lower_state_changed(port);\n}\n\n#define TEAM_VLAN_FEATURES (NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t    NETIF_F_FRAGLIST | NETIF_F_GSO_SOFTWARE | \\\n\t\t\t    NETIF_F_HIGHDMA | NETIF_F_LRO)\n\n#define TEAM_ENC_FEATURES\t(NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t\t NETIF_F_RXCSUM | NETIF_F_GSO_SOFTWARE)\n\nstatic void __team_compute_features(struct team *team)\n{\n\tstruct team_port *port;\n\tnetdev_features_t vlan_features = TEAM_VLAN_FEATURES &\n\t\t\t\t\t  NETIF_F_ALL_FOR_ALL;\n\tnetdev_features_t enc_features  = TEAM_ENC_FEATURES;\n\tunsigned short max_hard_header_len = ETH_HLEN;\n\tunsigned int dst_release_flag = IFF_XMIT_DST_RELEASE |\n\t\t\t\t\tIFF_XMIT_DST_RELEASE_PERM;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &team->port_list, list) {\n\t\tvlan_features = netdev_increment_features(vlan_features,\n\t\t\t\t\tport->dev->vlan_features,\n\t\t\t\t\tTEAM_VLAN_FEATURES);\n\t\tenc_features =\n\t\t\tnetdev_increment_features(enc_features,\n\t\t\t\t\t\t  port->dev->hw_enc_features,\n\t\t\t\t\t\t  TEAM_ENC_FEATURES);\n\n\n\t\tdst_release_flag &= port->dev->priv_flags;\n\t\tif (port->dev->hard_header_len > max_hard_header_len)\n\t\t\tmax_hard_header_len = port->dev->hard_header_len;\n\t}\n\trcu_read_unlock();\n\n\tteam->dev->vlan_features = vlan_features;\n\tteam->dev->hw_enc_features = enc_features | NETIF_F_GSO_ENCAP_ALL |\n\t\t\t\t     NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t     NETIF_F_HW_VLAN_STAG_TX;\n\tteam->dev->hard_header_len = max_hard_header_len;\n\n\tteam->dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tif (dst_release_flag == (IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM))\n\t\tteam->dev->priv_flags |= IFF_XMIT_DST_RELEASE;\n}\n\nstatic void team_compute_features(struct team *team)\n{\n\t__team_compute_features(team);\n\tnetdev_change_features(team->dev);\n}\n\nstatic int team_port_enter(struct team *team, struct team_port *port)\n{\n\tint err = 0;\n\n\tdev_hold(team->dev);\n\tif (team->ops.port_enter) {\n\t\terr = team->ops.port_enter(team, port);\n\t\tif (err) {\n\t\t\tnetdev_err(team->dev, \"Device %s failed to enter team mode\\n\",\n\t\t\t\t   port->dev->name);\n\t\t\tgoto err_port_enter;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_port_enter:\n\tdev_put(team->dev);\n\n\treturn err;\n}\n\nstatic void team_port_leave(struct team *team, struct team_port *port)\n{\n\tif (team->ops.port_leave)\n\t\tteam->ops.port_leave(team, port);\n\tdev_put(team->dev);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic int __team_port_enable_netpoll(struct team_port *port)\n{\n\tstruct netpoll *np;\n\tint err;\n\n\tnp = kzalloc(sizeof(*np), GFP_KERNEL);\n\tif (!np)\n\t\treturn -ENOMEM;\n\n\terr = __netpoll_setup(np, port->dev);\n\tif (err) {\n\t\tkfree(np);\n\t\treturn err;\n\t}\n\tport->np = np;\n\treturn err;\n}\n\nstatic int team_port_enable_netpoll(struct team_port *port)\n{\n\tif (!port->team->dev->npinfo)\n\t\treturn 0;\n\n\treturn __team_port_enable_netpoll(port);\n}\n\nstatic void team_port_disable_netpoll(struct team_port *port)\n{\n\tstruct netpoll *np = port->np;\n\n\tif (!np)\n\t\treturn;\n\tport->np = NULL;\n\n\t__netpoll_free(np);\n}\n#else\nstatic int team_port_enable_netpoll(struct team_port *port)\n{\n\treturn 0;\n}\nstatic void team_port_disable_netpoll(struct team_port *port)\n{\n}\n#endif\n\nstatic int team_upper_dev_link(struct team *team, struct team_port *port,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct netdev_lag_upper_info lag_upper_info;\n\tint err;\n\n\tlag_upper_info.tx_type = team->mode->lag_tx_type;\n\tlag_upper_info.hash_type = NETDEV_LAG_HASH_UNKNOWN;\n\terr = netdev_master_upper_dev_link(port->dev, team->dev, NULL,\n\t\t\t\t\t   &lag_upper_info, extack);\n\tif (err)\n\t\treturn err;\n\tport->dev->priv_flags |= IFF_TEAM_PORT;\n\treturn 0;\n}\n\nstatic void team_upper_dev_unlink(struct team *team, struct team_port *port)\n{\n\tnetdev_upper_dev_unlink(port->dev, team->dev);\n\tport->dev->priv_flags &= ~IFF_TEAM_PORT;\n}\n\nstatic void __team_port_change_port_added(struct team_port *port, bool linkup);\nstatic int team_dev_type_check_change(struct net_device *dev,\n\t\t\t\t      struct net_device *port_dev);\n\nstatic int team_port_add(struct team *team, struct net_device *port_dev,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = team->dev;\n\tstruct team_port *port;\n\tchar *portname = port_dev->name;\n\tint err;\n\n\tif (port_dev->flags & IFF_LOOPBACK) {\n\t\tNL_SET_ERR_MSG(extack, \"Loopback device can't be added as a team port\");\n\t\tnetdev_err(dev, \"Device %s is loopback device. Loopback devices can't be added as a team port\\n\",\n\t\t\t   portname);\n\t\treturn -EINVAL;\n\t}\n\n\tif (netif_is_team_port(port_dev)) {\n\t\tNL_SET_ERR_MSG(extack, \"Device is already a port of a team device\");\n\t\tnetdev_err(dev, \"Device %s is already a port \"\n\t\t\t\t\"of a team device\\n\", portname);\n\t\treturn -EBUSY;\n\t}\n\n\tif (dev == port_dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot enslave team device to itself\");\n\t\tnetdev_err(dev, \"Cannot enslave team device to itself\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (netdev_has_upper_dev(dev, port_dev)) {\n\t\tNL_SET_ERR_MSG(extack, \"Device is already an upper device of the team interface\");\n\t\tnetdev_err(dev, \"Device %s is already an upper device of the team interface\\n\",\n\t\t\t   portname);\n\t\treturn -EBUSY;\n\t}\n\n\tif (port_dev->features & NETIF_F_VLAN_CHALLENGED &&\n\t    vlan_uses_dev(dev)) {\n\t\tNL_SET_ERR_MSG(extack, \"Device is VLAN challenged and team device has VLAN set up\");\n\t\tnetdev_err(dev, \"Device %s is VLAN challenged and team device has VLAN set up\\n\",\n\t\t\t   portname);\n\t\treturn -EPERM;\n\t}\n\n\terr = team_dev_type_check_change(dev, port_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (port_dev->flags & IFF_UP) {\n\t\tNL_SET_ERR_MSG(extack, \"Device is up. Set it down before adding it as a team port\");\n\t\tnetdev_err(dev, \"Device %s is up. Set it down before adding it as a team port\\n\",\n\t\t\t   portname);\n\t\treturn -EBUSY;\n\t}\n\n\tport = kzalloc(sizeof(struct team_port) + team->mode->port_priv_size,\n\t\t       GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->dev = port_dev;\n\tport->team = team;\n\tINIT_LIST_HEAD(&port->qom_list);\n\n\tport->orig.mtu = port_dev->mtu;\n\terr = dev_set_mtu(port_dev, dev->mtu);\n\tif (err) {\n\t\tnetdev_dbg(dev, \"Error %d calling dev_set_mtu\\n\", err);\n\t\tgoto err_set_mtu;\n\t}\n\n\tmemcpy(port->orig.dev_addr, port_dev->dev_addr, port_dev->addr_len);\n\n\terr = team_port_enter(team, port);\n\tif (err) {\n\t\tnetdev_err(dev, \"Device %s failed to enter team mode\\n\",\n\t\t\t   portname);\n\t\tgoto err_port_enter;\n\t}\n\n\terr = dev_open(port_dev, extack);\n\tif (err) {\n\t\tnetdev_dbg(dev, \"Device %s opening failed\\n\",\n\t\t\t   portname);\n\t\tgoto err_dev_open;\n\t}\n\n\terr = vlan_vids_add_by_dev(port_dev, dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to add vlan ids to device %s\\n\",\n\t\t\t\tportname);\n\t\tgoto err_vids_add;\n\t}\n\n\terr = team_port_enable_netpoll(port);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to enable netpoll on device %s\\n\",\n\t\t\t   portname);\n\t\tgoto err_enable_netpoll;\n\t}\n\n\tif (!(dev->features & NETIF_F_LRO))\n\t\tdev_disable_lro(port_dev);\n\n\terr = netdev_rx_handler_register(port_dev, team_handle_frame,\n\t\t\t\t\t port);\n\tif (err) {\n\t\tnetdev_err(dev, \"Device %s failed to register rx_handler\\n\",\n\t\t\t   portname);\n\t\tgoto err_handler_register;\n\t}\n\n\terr = team_upper_dev_link(team, port, extack);\n\tif (err) {\n\t\tnetdev_err(dev, \"Device %s failed to set upper link\\n\",\n\t\t\t   portname);\n\t\tgoto err_set_upper_link;\n\t}\n\n\terr = __team_option_inst_add_port(team, port);\n\tif (err) {\n\t\tnetdev_err(dev, \"Device %s failed to add per-port options\\n\",\n\t\t\t   portname);\n\t\tgoto err_option_port_add;\n\t}\n\n\t \n\tif (dev->flags & IFF_PROMISC) {\n\t\terr = dev_set_promiscuity(port_dev, 1);\n\t\tif (err)\n\t\t\tgoto err_set_slave_promisc;\n\t}\n\n\t \n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(port_dev, 1);\n\t\tif (err) {\n\t\t\tif (dev->flags & IFF_PROMISC)\n\t\t\t\tdev_set_promiscuity(port_dev, -1);\n\t\t\tgoto err_set_slave_promisc;\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_UP) {\n\t\tnetif_addr_lock_bh(dev);\n\t\tdev_uc_sync_multiple(port_dev, dev);\n\t\tdev_mc_sync_multiple(port_dev, dev);\n\t\tnetif_addr_unlock_bh(dev);\n\t}\n\n\tport->index = -1;\n\tlist_add_tail_rcu(&port->list, &team->port_list);\n\tteam_port_enable(team, port);\n\t__team_compute_features(team);\n\t__team_port_change_port_added(port, !!netif_oper_up(port_dev));\n\t__team_options_change_check(team);\n\n\tnetdev_info(dev, \"Port device %s added\\n\", portname);\n\n\treturn 0;\n\nerr_set_slave_promisc:\n\t__team_option_inst_del_port(team, port);\n\nerr_option_port_add:\n\tteam_upper_dev_unlink(team, port);\n\nerr_set_upper_link:\n\tnetdev_rx_handler_unregister(port_dev);\n\nerr_handler_register:\n\tteam_port_disable_netpoll(port);\n\nerr_enable_netpoll:\n\tvlan_vids_del_by_dev(port_dev, dev);\n\nerr_vids_add:\n\tdev_close(port_dev);\n\nerr_dev_open:\n\tteam_port_leave(team, port);\n\tteam_port_set_orig_dev_addr(port);\n\nerr_port_enter:\n\tdev_set_mtu(port_dev, port->orig.mtu);\n\nerr_set_mtu:\n\tkfree(port);\n\n\treturn err;\n}\n\nstatic void __team_port_change_port_removed(struct team_port *port);\n\nstatic int team_port_del(struct team *team, struct net_device *port_dev)\n{\n\tstruct net_device *dev = team->dev;\n\tstruct team_port *port;\n\tchar *portname = port_dev->name;\n\n\tport = team_port_get_rtnl(port_dev);\n\tif (!port || !team_port_find(team, port)) {\n\t\tnetdev_err(dev, \"Device %s does not act as a port of this team\\n\",\n\t\t\t   portname);\n\t\treturn -ENOENT;\n\t}\n\n\tteam_port_disable(team, port);\n\tlist_del_rcu(&port->list);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\tdev_set_promiscuity(port_dev, -1);\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(port_dev, -1);\n\n\tteam_upper_dev_unlink(team, port);\n\tnetdev_rx_handler_unregister(port_dev);\n\tteam_port_disable_netpoll(port);\n\tvlan_vids_del_by_dev(port_dev, dev);\n\tif (dev->flags & IFF_UP) {\n\t\tdev_uc_unsync(port_dev, dev);\n\t\tdev_mc_unsync(port_dev, dev);\n\t}\n\tdev_close(port_dev);\n\tteam_port_leave(team, port);\n\n\t__team_option_inst_mark_removed_port(team, port);\n\t__team_options_change_check(team);\n\t__team_option_inst_del_port(team, port);\n\t__team_port_change_port_removed(port);\n\n\tteam_port_set_orig_dev_addr(port);\n\tdev_set_mtu(port_dev, port->orig.mtu);\n\tkfree_rcu(port, rcu);\n\tnetdev_info(dev, \"Port device %s removed\\n\", portname);\n\t__team_compute_features(team);\n\n\treturn 0;\n}\n\n\n \n\nstatic void team_mode_option_get(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tctx->data.str_val = team->mode->kind;\n}\n\nstatic int team_mode_option_set(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\treturn team_change_mode(team, ctx->data.str_val);\n}\n\nstatic void team_notify_peers_count_get(struct team *team,\n\t\t\t\t\tstruct team_gsetter_ctx *ctx)\n{\n\tctx->data.u32_val = team->notify_peers.count;\n}\n\nstatic int team_notify_peers_count_set(struct team *team,\n\t\t\t\t       struct team_gsetter_ctx *ctx)\n{\n\tteam->notify_peers.count = ctx->data.u32_val;\n\treturn 0;\n}\n\nstatic void team_notify_peers_interval_get(struct team *team,\n\t\t\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tctx->data.u32_val = team->notify_peers.interval;\n}\n\nstatic int team_notify_peers_interval_set(struct team *team,\n\t\t\t\t\t  struct team_gsetter_ctx *ctx)\n{\n\tteam->notify_peers.interval = ctx->data.u32_val;\n\treturn 0;\n}\n\nstatic void team_mcast_rejoin_count_get(struct team *team,\n\t\t\t\t\tstruct team_gsetter_ctx *ctx)\n{\n\tctx->data.u32_val = team->mcast_rejoin.count;\n}\n\nstatic int team_mcast_rejoin_count_set(struct team *team,\n\t\t\t\t       struct team_gsetter_ctx *ctx)\n{\n\tteam->mcast_rejoin.count = ctx->data.u32_val;\n\treturn 0;\n}\n\nstatic void team_mcast_rejoin_interval_get(struct team *team,\n\t\t\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tctx->data.u32_val = team->mcast_rejoin.interval;\n}\n\nstatic int team_mcast_rejoin_interval_set(struct team *team,\n\t\t\t\t\t  struct team_gsetter_ctx *ctx)\n{\n\tteam->mcast_rejoin.interval = ctx->data.u32_val;\n\treturn 0;\n}\n\nstatic void team_port_en_option_get(struct team *team,\n\t\t\t\t    struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tctx->data.bool_val = team_port_enabled(port);\n}\n\nstatic int team_port_en_option_set(struct team *team,\n\t\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tif (ctx->data.bool_val)\n\t\tteam_port_enable(team, port);\n\telse\n\t\tteam_port_disable(team, port);\n\treturn 0;\n}\n\nstatic void team_user_linkup_option_get(struct team *team,\n\t\t\t\t\tstruct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tctx->data.bool_val = port->user.linkup;\n}\n\nstatic void __team_carrier_check(struct team *team);\n\nstatic int team_user_linkup_option_set(struct team *team,\n\t\t\t\t       struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tport->user.linkup = ctx->data.bool_val;\n\tteam_refresh_port_linkup(port);\n\t__team_carrier_check(port->team);\n\treturn 0;\n}\n\nstatic void team_user_linkup_en_option_get(struct team *team,\n\t\t\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tctx->data.bool_val = port->user.linkup_enabled;\n}\n\nstatic int team_user_linkup_en_option_set(struct team *team,\n\t\t\t\t\t  struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tport->user.linkup_enabled = ctx->data.bool_val;\n\tteam_refresh_port_linkup(port);\n\t__team_carrier_check(port->team);\n\treturn 0;\n}\n\nstatic void team_priority_option_get(struct team *team,\n\t\t\t\t     struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tctx->data.s32_val = port->priority;\n}\n\nstatic int team_priority_option_set(struct team *team,\n\t\t\t\t    struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\ts32 priority = ctx->data.s32_val;\n\n\tif (port->priority == priority)\n\t\treturn 0;\n\tport->priority = priority;\n\tteam_queue_override_port_prio_changed(team, port);\n\treturn 0;\n}\n\nstatic void team_queue_id_option_get(struct team *team,\n\t\t\t\t     struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\n\tctx->data.u32_val = port->queue_id;\n}\n\nstatic int team_queue_id_option_set(struct team *team,\n\t\t\t\t    struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\tu16 new_queue_id = ctx->data.u32_val;\n\n\tif (port->queue_id == new_queue_id)\n\t\treturn 0;\n\tif (new_queue_id >= team->dev->real_num_tx_queues)\n\t\treturn -EINVAL;\n\tteam_queue_override_port_change_queue_id(team, port, new_queue_id);\n\treturn 0;\n}\n\nstatic const struct team_option team_options[] = {\n\t{\n\t\t.name = \"mode\",\n\t\t.type = TEAM_OPTION_TYPE_STRING,\n\t\t.getter = team_mode_option_get,\n\t\t.setter = team_mode_option_set,\n\t},\n\t{\n\t\t.name = \"notify_peers_count\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.getter = team_notify_peers_count_get,\n\t\t.setter = team_notify_peers_count_set,\n\t},\n\t{\n\t\t.name = \"notify_peers_interval\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.getter = team_notify_peers_interval_get,\n\t\t.setter = team_notify_peers_interval_set,\n\t},\n\t{\n\t\t.name = \"mcast_rejoin_count\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.getter = team_mcast_rejoin_count_get,\n\t\t.setter = team_mcast_rejoin_count_set,\n\t},\n\t{\n\t\t.name = \"mcast_rejoin_interval\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.getter = team_mcast_rejoin_interval_get,\n\t\t.setter = team_mcast_rejoin_interval_set,\n\t},\n\t{\n\t\t.name = \"enabled\",\n\t\t.type = TEAM_OPTION_TYPE_BOOL,\n\t\t.per_port = true,\n\t\t.getter = team_port_en_option_get,\n\t\t.setter = team_port_en_option_set,\n\t},\n\t{\n\t\t.name = \"user_linkup\",\n\t\t.type = TEAM_OPTION_TYPE_BOOL,\n\t\t.per_port = true,\n\t\t.getter = team_user_linkup_option_get,\n\t\t.setter = team_user_linkup_option_set,\n\t},\n\t{\n\t\t.name = \"user_linkup_enabled\",\n\t\t.type = TEAM_OPTION_TYPE_BOOL,\n\t\t.per_port = true,\n\t\t.getter = team_user_linkup_en_option_get,\n\t\t.setter = team_user_linkup_en_option_set,\n\t},\n\t{\n\t\t.name = \"priority\",\n\t\t.type = TEAM_OPTION_TYPE_S32,\n\t\t.per_port = true,\n\t\t.getter = team_priority_option_get,\n\t\t.setter = team_priority_option_set,\n\t},\n\t{\n\t\t.name = \"queue_id\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.per_port = true,\n\t\t.getter = team_queue_id_option_get,\n\t\t.setter = team_queue_id_option_set,\n\t},\n};\n\n\nstatic int team_init(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tint i;\n\tint err;\n\n\tteam->dev = dev;\n\tteam_set_no_mode(team);\n\tteam->notifier_ctx = false;\n\n\tteam->pcpu_stats = netdev_alloc_pcpu_stats(struct team_pcpu_stats);\n\tif (!team->pcpu_stats)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < TEAM_PORT_HASHENTRIES; i++)\n\t\tINIT_HLIST_HEAD(&team->en_port_hlist[i]);\n\tINIT_LIST_HEAD(&team->port_list);\n\terr = team_queue_override_init(team);\n\tif (err)\n\t\tgoto err_team_queue_override_init;\n\n\tteam_adjust_ops(team);\n\n\tINIT_LIST_HEAD(&team->option_list);\n\tINIT_LIST_HEAD(&team->option_inst_list);\n\n\tteam_notify_peers_init(team);\n\tteam_mcast_rejoin_init(team);\n\n\terr = team_options_register(team, team_options, ARRAY_SIZE(team_options));\n\tif (err)\n\t\tgoto err_options_register;\n\tnetif_carrier_off(dev);\n\n\tlockdep_register_key(&team->team_lock_key);\n\t__mutex_init(&team->lock, \"team->team_lock_key\", &team->team_lock_key);\n\tnetdev_lockdep_set_classes(dev);\n\n\treturn 0;\n\nerr_options_register:\n\tteam_mcast_rejoin_fini(team);\n\tteam_notify_peers_fini(team);\n\tteam_queue_override_fini(team);\nerr_team_queue_override_init:\n\tfree_percpu(team->pcpu_stats);\n\n\treturn err;\n}\n\nstatic void team_uninit(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\tstruct team_port *tmp;\n\n\tmutex_lock(&team->lock);\n\tlist_for_each_entry_safe(port, tmp, &team->port_list, list)\n\t\tteam_port_del(team, port->dev);\n\n\t__team_change_mode(team, NULL);  \n\t__team_options_unregister(team, team_options, ARRAY_SIZE(team_options));\n\tteam_mcast_rejoin_fini(team);\n\tteam_notify_peers_fini(team);\n\tteam_queue_override_fini(team);\n\tmutex_unlock(&team->lock);\n\tnetdev_change_features(dev);\n\tlockdep_unregister_key(&team->team_lock_key);\n}\n\nstatic void team_destructor(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\n\tfree_percpu(team->pcpu_stats);\n}\n\nstatic int team_open(struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic int team_close(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\tdev_uc_unsync(port->dev, dev);\n\t\tdev_mc_unsync(port->dev, dev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t team_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tbool tx_success;\n\tunsigned int len = skb->len;\n\n\ttx_success = team_queue_override_transmit(team, skb);\n\tif (!tx_success)\n\t\ttx_success = team->ops.transmit(team, skb);\n\tif (tx_success) {\n\t\tstruct team_pcpu_stats *pcpu_stats;\n\n\t\tpcpu_stats = this_cpu_ptr(team->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tu64_stats_inc(&pcpu_stats->tx_packets);\n\t\tu64_stats_add(&pcpu_stats->tx_bytes, len);\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(team->pcpu_stats->tx_dropped);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic u16 team_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t     struct net_device *sb_dev)\n{\n\t \n\tu16 txq = skb_rx_queue_recorded(skb) ? skb_get_rx_queue(skb) : 0;\n\n\t \n\tqdisc_skb_cb(skb)->slave_dev_queue_mapping = skb->queue_mapping;\n\n\tif (unlikely(txq >= dev->real_num_tx_queues)) {\n\t\tdo {\n\t\t\ttxq -= dev->real_num_tx_queues;\n\t\t} while (txq >= dev->real_num_tx_queues);\n\t}\n\treturn txq;\n}\n\nstatic void team_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\tint inc;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &team->port_list, list) {\n\t\tif (change & IFF_PROMISC) {\n\t\t\tinc = dev->flags & IFF_PROMISC ? 1 : -1;\n\t\t\tdev_set_promiscuity(port->dev, inc);\n\t\t}\n\t\tif (change & IFF_ALLMULTI) {\n\t\t\tinc = dev->flags & IFF_ALLMULTI ? 1 : -1;\n\t\t\tdev_set_allmulti(port->dev, inc);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic void team_set_rx_mode(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &team->port_list, list) {\n\t\tdev_uc_sync_multiple(port->dev, dev);\n\t\tdev_mc_sync_multiple(port->dev, dev);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int team_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\n\tif (dev->type == ARPHRD_ETHER && !is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\tdev_addr_set(dev, addr->sa_data);\n\tmutex_lock(&team->lock);\n\tlist_for_each_entry(port, &team->port_list, list)\n\t\tif (team->ops.port_change_dev_addr)\n\t\t\tteam->ops.port_change_dev_addr(team, port);\n\tmutex_unlock(&team->lock);\n\treturn 0;\n}\n\nstatic int team_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\tint err;\n\n\t \n\tmutex_lock(&team->lock);\n\tteam->port_mtu_change_allowed = true;\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\terr = dev_set_mtu(port->dev, new_mtu);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Device %s failed to change mtu\",\n\t\t\t\t   port->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\tteam->port_mtu_change_allowed = false;\n\tmutex_unlock(&team->lock);\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n\nunwind:\n\tlist_for_each_entry_continue_reverse(port, &team->port_list, list)\n\t\tdev_set_mtu(port->dev, dev->mtu);\n\tteam->port_mtu_change_allowed = false;\n\tmutex_unlock(&team->lock);\n\n\treturn err;\n}\n\nstatic void\nteam_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_pcpu_stats *p;\n\tu64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;\n\tu32 rx_dropped = 0, tx_dropped = 0, rx_nohandler = 0;\n\tunsigned int start;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tp = per_cpu_ptr(team->pcpu_stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t\trx_packets\t= u64_stats_read(&p->rx_packets);\n\t\t\trx_bytes\t= u64_stats_read(&p->rx_bytes);\n\t\t\trx_multicast\t= u64_stats_read(&p->rx_multicast);\n\t\t\ttx_packets\t= u64_stats_read(&p->tx_packets);\n\t\t\ttx_bytes\t= u64_stats_read(&p->tx_bytes);\n\t\t} while (u64_stats_fetch_retry(&p->syncp, start));\n\n\t\tstats->rx_packets\t+= rx_packets;\n\t\tstats->rx_bytes\t\t+= rx_bytes;\n\t\tstats->multicast\t+= rx_multicast;\n\t\tstats->tx_packets\t+= tx_packets;\n\t\tstats->tx_bytes\t\t+= tx_bytes;\n\t\t \n\t\trx_dropped\t+= READ_ONCE(p->rx_dropped);\n\t\ttx_dropped\t+= READ_ONCE(p->tx_dropped);\n\t\trx_nohandler\t+= READ_ONCE(p->rx_nohandler);\n\t}\n\tstats->rx_dropped\t= rx_dropped;\n\tstats->tx_dropped\t= tx_dropped;\n\tstats->rx_nohandler\t= rx_nohandler;\n}\n\nstatic int team_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\tint err;\n\n\t \n\tmutex_lock(&team->lock);\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\terr = vlan_vid_add(port->dev, proto, vid);\n\t\tif (err)\n\t\t\tgoto unwind;\n\t}\n\tmutex_unlock(&team->lock);\n\n\treturn 0;\n\nunwind:\n\tlist_for_each_entry_continue_reverse(port, &team->port_list, list)\n\t\tvlan_vid_del(port->dev, proto, vid);\n\tmutex_unlock(&team->lock);\n\n\treturn err;\n}\n\nstatic int team_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\n\tmutex_lock(&team->lock);\n\tlist_for_each_entry(port, &team->port_list, list)\n\t\tvlan_vid_del(port->dev, proto, vid);\n\tmutex_unlock(&team->lock);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void team_poll_controller(struct net_device *dev)\n{\n}\n\nstatic void __team_netpoll_cleanup(struct team *team)\n{\n\tstruct team_port *port;\n\n\tlist_for_each_entry(port, &team->port_list, list)\n\t\tteam_port_disable_netpoll(port);\n}\n\nstatic void team_netpoll_cleanup(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\n\tmutex_lock(&team->lock);\n\t__team_netpoll_cleanup(team);\n\tmutex_unlock(&team->lock);\n}\n\nstatic int team_netpoll_setup(struct net_device *dev,\n\t\t\t      struct netpoll_info *npifo)\n{\n\tstruct team *team = netdev_priv(dev);\n\tstruct team_port *port;\n\tint err = 0;\n\n\tmutex_lock(&team->lock);\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\terr = __team_port_enable_netpoll(port);\n\t\tif (err) {\n\t\t\t__team_netpoll_cleanup(team);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&team->lock);\n\treturn err;\n}\n#endif\n\nstatic int team_add_slave(struct net_device *dev, struct net_device *port_dev,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct team *team = netdev_priv(dev);\n\tint err;\n\n\tmutex_lock(&team->lock);\n\terr = team_port_add(team, port_dev, extack);\n\tmutex_unlock(&team->lock);\n\n\tif (!err)\n\t\tnetdev_change_features(dev);\n\n\treturn err;\n}\n\nstatic int team_del_slave(struct net_device *dev, struct net_device *port_dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tint err;\n\n\tmutex_lock(&team->lock);\n\terr = team_port_del(team, port_dev);\n\tmutex_unlock(&team->lock);\n\n\tif (err)\n\t\treturn err;\n\n\tif (netif_is_team_master(port_dev)) {\n\t\tlockdep_unregister_key(&team->team_lock_key);\n\t\tlockdep_register_key(&team->team_lock_key);\n\t\tlockdep_set_class(&team->lock, &team->team_lock_key);\n\t}\n\tnetdev_change_features(dev);\n\n\treturn err;\n}\n\nstatic netdev_features_t team_fix_features(struct net_device *dev,\n\t\t\t\t\t   netdev_features_t features)\n{\n\tstruct team_port *port;\n\tstruct team *team = netdev_priv(dev);\n\tnetdev_features_t mask;\n\n\tmask = features;\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\tfeatures |= NETIF_F_ALL_FOR_ALL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &team->port_list, list) {\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     port->dev->features,\n\t\t\t\t\t\t     mask);\n\t}\n\trcu_read_unlock();\n\n\tfeatures = netdev_add_tso_features(features, mask);\n\n\treturn features;\n}\n\nstatic int team_change_carrier(struct net_device *dev, bool new_carrier)\n{\n\tstruct team *team = netdev_priv(dev);\n\n\tteam->user_carrier_enabled = true;\n\n\tif (new_carrier)\n\t\tnetif_carrier_on(dev);\n\telse\n\t\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\nstatic const struct net_device_ops team_netdev_ops = {\n\t.ndo_init\t\t= team_init,\n\t.ndo_uninit\t\t= team_uninit,\n\t.ndo_open\t\t= team_open,\n\t.ndo_stop\t\t= team_close,\n\t.ndo_start_xmit\t\t= team_xmit,\n\t.ndo_select_queue\t= team_select_queue,\n\t.ndo_change_rx_flags\t= team_change_rx_flags,\n\t.ndo_set_rx_mode\t= team_set_rx_mode,\n\t.ndo_set_mac_address\t= team_set_mac_address,\n\t.ndo_change_mtu\t\t= team_change_mtu,\n\t.ndo_get_stats64\t= team_get_stats64,\n\t.ndo_vlan_rx_add_vid\t= team_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= team_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= team_poll_controller,\n\t.ndo_netpoll_setup\t= team_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= team_netpoll_cleanup,\n#endif\n\t.ndo_add_slave\t\t= team_add_slave,\n\t.ndo_del_slave\t\t= team_del_slave,\n\t.ndo_fix_features\t= team_fix_features,\n\t.ndo_change_carrier     = team_change_carrier,\n\t.ndo_features_check\t= passthru_features_check,\n};\n\n \n\nstatic void team_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, UTS_RELEASE, sizeof(drvinfo->version));\n}\n\nstatic int team_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct team *team= netdev_priv(dev);\n\tunsigned long speed = 0;\n\tstruct team_port *port;\n\n\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\tcmd->base.port = PORT_OTHER;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &team->port_list, list) {\n\t\tif (team_port_txable(port)) {\n\t\t\tif (port->state.speed != SPEED_UNKNOWN)\n\t\t\t\tspeed += port->state.speed;\n\t\t\tif (cmd->base.duplex == DUPLEX_UNKNOWN &&\n\t\t\t    port->state.duplex != DUPLEX_UNKNOWN)\n\t\t\t\tcmd->base.duplex = port->state.duplex;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tcmd->base.speed = speed ? : SPEED_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops team_ethtool_ops = {\n\t.get_drvinfo\t\t= team_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= team_ethtool_get_link_ksettings,\n};\n\n \n\nstatic void team_setup_by_port(struct net_device *dev,\n\t\t\t       struct net_device *port_dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\n\tif (port_dev->type == ARPHRD_ETHER)\n\t\tdev->header_ops\t= team->header_ops_cache;\n\telse\n\t\tdev->header_ops\t= port_dev->header_ops;\n\tdev->type = port_dev->type;\n\tdev->hard_header_len = port_dev->hard_header_len;\n\tdev->needed_headroom = port_dev->needed_headroom;\n\tdev->addr_len = port_dev->addr_len;\n\tdev->mtu = port_dev->mtu;\n\tmemcpy(dev->broadcast, port_dev->broadcast, port_dev->addr_len);\n\teth_hw_addr_inherit(dev, port_dev);\n\n\tif (port_dev->flags & IFF_POINTOPOINT) {\n\t\tdev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);\n\t\tdev->flags |= (IFF_POINTOPOINT | IFF_NOARP);\n\t} else if ((port_dev->flags & (IFF_BROADCAST | IFF_MULTICAST)) ==\n\t\t    (IFF_BROADCAST | IFF_MULTICAST)) {\n\t\tdev->flags |= (IFF_BROADCAST | IFF_MULTICAST);\n\t\tdev->flags &= ~(IFF_POINTOPOINT | IFF_NOARP);\n\t}\n}\n\nstatic int team_dev_type_check_change(struct net_device *dev,\n\t\t\t\t      struct net_device *port_dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\tchar *portname = port_dev->name;\n\tint err;\n\n\tif (dev->type == port_dev->type)\n\t\treturn 0;\n\tif (!list_empty(&team->port_list)) {\n\t\tnetdev_err(dev, \"Device %s is of different type\\n\", portname);\n\t\treturn -EBUSY;\n\t}\n\terr = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE, dev);\n\terr = notifier_to_errno(err);\n\tif (err) {\n\t\tnetdev_err(dev, \"Refused to change device type\\n\");\n\t\treturn err;\n\t}\n\tdev_uc_flush(dev);\n\tdev_mc_flush(dev);\n\tteam_setup_by_port(dev, port_dev);\n\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\n\treturn 0;\n}\n\nstatic void team_setup(struct net_device *dev)\n{\n\tstruct team *team = netdev_priv(dev);\n\n\tether_setup(dev);\n\tdev->max_mtu = ETH_MAX_MTU;\n\tteam->header_ops_cache = dev->header_ops;\n\n\tdev->netdev_ops = &team_netdev_ops;\n\tdev->ethtool_ops = &team_ethtool_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = team_destructor;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->priv_flags |= IFF_TEAM;\n\n\t \n\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\n\tdev->features |= NETIF_F_LLTX;\n\tdev->features |= NETIF_F_GRO;\n\n\t \n\tdev->features |= NETIF_F_NETNS_LOCAL;\n\n\tdev->hw_features = TEAM_VLAN_FEATURES |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t   NETIF_F_HW_VLAN_STAG_RX |\n\t\t\t   NETIF_F_HW_VLAN_STAG_FILTER;\n\n\tdev->hw_features |= NETIF_F_GSO_ENCAP_ALL;\n\tdev->features |= dev->hw_features;\n\tdev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX;\n}\n\nstatic int team_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS] == NULL)\n\t\teth_hw_addr_random(dev);\n\n\treturn register_netdevice(dev);\n}\n\nstatic int team_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int team_get_num_tx_queues(void)\n{\n\treturn TEAM_DEFAULT_NUM_TX_QUEUES;\n}\n\nstatic unsigned int team_get_num_rx_queues(void)\n{\n\treturn TEAM_DEFAULT_NUM_RX_QUEUES;\n}\n\nstatic struct rtnl_link_ops team_link_ops __read_mostly = {\n\t.kind\t\t\t= DRV_NAME,\n\t.priv_size\t\t= sizeof(struct team),\n\t.setup\t\t\t= team_setup,\n\t.newlink\t\t= team_newlink,\n\t.validate\t\t= team_validate,\n\t.get_num_tx_queues\t= team_get_num_tx_queues,\n\t.get_num_rx_queues\t= team_get_num_rx_queues,\n};\n\n\n \n\nstatic struct genl_family team_nl_family;\n\nstatic const struct nla_policy team_nl_policy[TEAM_ATTR_MAX + 1] = {\n\t[TEAM_ATTR_UNSPEC]\t\t\t= { .type = NLA_UNSPEC, },\n\t[TEAM_ATTR_TEAM_IFINDEX]\t\t= { .type = NLA_U32 },\n\t[TEAM_ATTR_LIST_OPTION]\t\t\t= { .type = NLA_NESTED },\n\t[TEAM_ATTR_LIST_PORT]\t\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nteam_nl_option_policy[TEAM_ATTR_OPTION_MAX + 1] = {\n\t[TEAM_ATTR_OPTION_UNSPEC]\t\t= { .type = NLA_UNSPEC, },\n\t[TEAM_ATTR_OPTION_NAME] = {\n\t\t.type = NLA_STRING,\n\t\t.len = TEAM_STRING_MAX_LEN,\n\t},\n\t[TEAM_ATTR_OPTION_CHANGED]\t\t= { .type = NLA_FLAG },\n\t[TEAM_ATTR_OPTION_TYPE]\t\t\t= { .type = NLA_U8 },\n\t[TEAM_ATTR_OPTION_DATA]\t\t\t= { .type = NLA_BINARY },\n\t[TEAM_ATTR_OPTION_PORT_IFINDEX]\t\t= { .type = NLA_U32 },\n\t[TEAM_ATTR_OPTION_ARRAY_INDEX]\t\t= { .type = NLA_U32 },\n};\n\nstatic int team_nl_cmd_noop(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, info->snd_portid, info->snd_seq,\n\t\t\t  &team_nl_family, 0, TEAM_CMD_NOOP);\n\tif (!hdr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto err_msg_put;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(genl_info_net(info), msg, info->snd_portid);\n\nerr_msg_put:\n\tnlmsg_free(msg);\n\n\treturn err;\n}\n\n \nstatic struct team *team_nl_team_get(struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tint ifindex;\n\tstruct net_device *dev;\n\tstruct team *team;\n\n\tif (!info->attrs[TEAM_ATTR_TEAM_IFINDEX])\n\t\treturn NULL;\n\n\tifindex = nla_get_u32(info->attrs[TEAM_ATTR_TEAM_IFINDEX]);\n\tdev = dev_get_by_index(net, ifindex);\n\tif (!dev || dev->netdev_ops != &team_netdev_ops) {\n\t\tdev_put(dev);\n\t\treturn NULL;\n\t}\n\n\tteam = netdev_priv(dev);\n\tmutex_lock(&team->lock);\n\treturn team;\n}\n\nstatic void team_nl_team_put(struct team *team)\n{\n\tmutex_unlock(&team->lock);\n\tdev_put(team->dev);\n}\n\ntypedef int team_nl_send_func_t(struct sk_buff *skb,\n\t\t\t\tstruct team *team, u32 portid);\n\nstatic int team_nl_send_unicast(struct sk_buff *skb, struct team *team, u32 portid)\n{\n\treturn genlmsg_unicast(dev_net(team->dev), skb, portid);\n}\n\nstatic int team_nl_fill_one_option_get(struct sk_buff *skb, struct team *team,\n\t\t\t\t       struct team_option_inst *opt_inst)\n{\n\tstruct nlattr *option_item;\n\tstruct team_option *option = opt_inst->option;\n\tstruct team_option_inst_info *opt_inst_info = &opt_inst->info;\n\tstruct team_gsetter_ctx ctx;\n\tint err;\n\n\tctx.info = opt_inst_info;\n\terr = team_option_get(team, opt_inst, &ctx);\n\tif (err)\n\t\treturn err;\n\n\toption_item = nla_nest_start_noflag(skb, TEAM_ATTR_ITEM_OPTION);\n\tif (!option_item)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TEAM_ATTR_OPTION_NAME, option->name))\n\t\tgoto nest_cancel;\n\tif (opt_inst_info->port &&\n\t    nla_put_u32(skb, TEAM_ATTR_OPTION_PORT_IFINDEX,\n\t\t\topt_inst_info->port->dev->ifindex))\n\t\tgoto nest_cancel;\n\tif (opt_inst->option->array_size &&\n\t    nla_put_u32(skb, TEAM_ATTR_OPTION_ARRAY_INDEX,\n\t\t\topt_inst_info->array_index))\n\t\tgoto nest_cancel;\n\n\tswitch (option->type) {\n\tcase TEAM_OPTION_TYPE_U32:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_U32))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_u32(skb, TEAM_ATTR_OPTION_DATA, ctx.data.u32_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_STRING:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_STRING))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_string(skb, TEAM_ATTR_OPTION_DATA,\n\t\t\t\t   ctx.data.str_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_BINARY:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_BINARY))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put(skb, TEAM_ATTR_OPTION_DATA, ctx.data.bin_val.len,\n\t\t\t    ctx.data.bin_val.ptr))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_BOOL:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_FLAG))\n\t\t\tgoto nest_cancel;\n\t\tif (ctx.data.bool_val &&\n\t\t    nla_put_flag(skb, TEAM_ATTR_OPTION_DATA))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tcase TEAM_OPTION_TYPE_S32:\n\t\tif (nla_put_u8(skb, TEAM_ATTR_OPTION_TYPE, NLA_S32))\n\t\t\tgoto nest_cancel;\n\t\tif (nla_put_s32(skb, TEAM_ATTR_OPTION_DATA, ctx.data.s32_val))\n\t\t\tgoto nest_cancel;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (opt_inst->removed && nla_put_flag(skb, TEAM_ATTR_OPTION_REMOVED))\n\t\tgoto nest_cancel;\n\tif (opt_inst->changed) {\n\t\tif (nla_put_flag(skb, TEAM_ATTR_OPTION_CHANGED))\n\t\t\tgoto nest_cancel;\n\t\topt_inst->changed = false;\n\t}\n\tnla_nest_end(skb, option_item);\n\treturn 0;\n\nnest_cancel:\n\tnla_nest_cancel(skb, option_item);\n\treturn -EMSGSIZE;\n}\n\nstatic int __send_and_alloc_skb(struct sk_buff **pskb,\n\t\t\t\tstruct team *team, u32 portid,\n\t\t\t\tteam_nl_send_func_t *send_func)\n{\n\tint err;\n\n\tif (*pskb) {\n\t\terr = send_func(*pskb, team, portid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t*pskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!*pskb)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int team_nl_send_options_get(struct team *team, u32 portid, u32 seq,\n\t\t\t\t    int flags, team_nl_send_func_t *send_func,\n\t\t\t\t    struct list_head *sel_opt_inst_list)\n{\n\tstruct nlattr *option_list;\n\tstruct nlmsghdr *nlh;\n\tvoid *hdr;\n\tstruct team_option_inst *opt_inst;\n\tint err;\n\tstruct sk_buff *skb = NULL;\n\tbool incomplete;\n\tint i;\n\n\topt_inst = list_first_entry(sel_opt_inst_list,\n\t\t\t\t    struct team_option_inst, tmp_list);\n\nstart_again:\n\terr = __send_and_alloc_skb(&skb, team, portid, send_func);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(skb, portid, seq, &team_nl_family, flags | NLM_F_MULTI,\n\t\t\t  TEAM_CMD_OPTIONS_GET);\n\tif (!hdr) {\n\t\tnlmsg_free(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team->dev->ifindex))\n\t\tgoto nla_put_failure;\n\toption_list = nla_nest_start_noflag(skb, TEAM_ATTR_LIST_OPTION);\n\tif (!option_list)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\tincomplete = false;\n\tlist_for_each_entry_from(opt_inst, sel_opt_inst_list, tmp_list) {\n\t\terr = team_nl_fill_one_option_get(skb, team, opt_inst);\n\t\tif (err) {\n\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\tif (!i)\n\t\t\t\t\tgoto errout;\n\t\t\t\tincomplete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto errout;\n\t\t}\n\t\ti++;\n\t}\n\n\tnla_nest_end(skb, option_list);\n\tgenlmsg_end(skb, hdr);\n\tif (incomplete)\n\t\tgoto start_again;\n\nsend_done:\n\tnlh = nlmsg_put(skb, portid, seq, NLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = __send_and_alloc_skb(&skb, team, portid, send_func);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto send_done;\n\t}\n\n\treturn send_func(skb, team, portid);\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nerrout:\n\tnlmsg_free(skb);\n\treturn err;\n}\n\nstatic int team_nl_cmd_options_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct team *team;\n\tstruct team_option_inst *opt_inst;\n\tint err;\n\tLIST_HEAD(sel_opt_inst_list);\n\n\tteam = team_nl_team_get(info);\n\tif (!team)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(opt_inst, &team->option_inst_list, list)\n\t\tlist_add_tail(&opt_inst->tmp_list, &sel_opt_inst_list);\n\terr = team_nl_send_options_get(team, info->snd_portid, info->snd_seq,\n\t\t\t\t       NLM_F_ACK, team_nl_send_unicast,\n\t\t\t\t       &sel_opt_inst_list);\n\n\tteam_nl_team_put(team);\n\n\treturn err;\n}\n\nstatic int team_nl_send_event_options_get(struct team *team,\n\t\t\t\t\t  struct list_head *sel_opt_inst_list);\n\nstatic int team_nl_cmd_options_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct team *team;\n\tint err = 0;\n\tint i;\n\tstruct nlattr *nl_option;\n\n\trtnl_lock();\n\n\tteam = team_nl_team_get(info);\n\tif (!team) {\n\t\terr = -EINVAL;\n\t\tgoto rtnl_unlock;\n\t}\n\n\terr = -EINVAL;\n\tif (!info->attrs[TEAM_ATTR_LIST_OPTION]) {\n\t\terr = -EINVAL;\n\t\tgoto team_put;\n\t}\n\n\tnla_for_each_nested(nl_option, info->attrs[TEAM_ATTR_LIST_OPTION], i) {\n\t\tstruct nlattr *opt_attrs[TEAM_ATTR_OPTION_MAX + 1];\n\t\tstruct nlattr *attr;\n\t\tstruct nlattr *attr_data;\n\t\tLIST_HEAD(opt_inst_list);\n\t\tenum team_option_type opt_type;\n\t\tint opt_port_ifindex = 0;  \n\t\tu32 opt_array_index = 0;\n\t\tbool opt_is_array = false;\n\t\tstruct team_option_inst *opt_inst;\n\t\tchar *opt_name;\n\t\tbool opt_found = false;\n\n\t\tif (nla_type(nl_option) != TEAM_ATTR_ITEM_OPTION) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto team_put;\n\t\t}\n\t\terr = nla_parse_nested_deprecated(opt_attrs,\n\t\t\t\t\t\t  TEAM_ATTR_OPTION_MAX,\n\t\t\t\t\t\t  nl_option,\n\t\t\t\t\t\t  team_nl_option_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\tgoto team_put;\n\t\tif (!opt_attrs[TEAM_ATTR_OPTION_NAME] ||\n\t\t    !opt_attrs[TEAM_ATTR_OPTION_TYPE]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto team_put;\n\t\t}\n\t\tswitch (nla_get_u8(opt_attrs[TEAM_ATTR_OPTION_TYPE])) {\n\t\tcase NLA_U32:\n\t\t\topt_type = TEAM_OPTION_TYPE_U32;\n\t\t\tbreak;\n\t\tcase NLA_STRING:\n\t\t\topt_type = TEAM_OPTION_TYPE_STRING;\n\t\t\tbreak;\n\t\tcase NLA_BINARY:\n\t\t\topt_type = TEAM_OPTION_TYPE_BINARY;\n\t\t\tbreak;\n\t\tcase NLA_FLAG:\n\t\t\topt_type = TEAM_OPTION_TYPE_BOOL;\n\t\t\tbreak;\n\t\tcase NLA_S32:\n\t\t\topt_type = TEAM_OPTION_TYPE_S32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto team_put;\n\t\t}\n\n\t\tattr_data = opt_attrs[TEAM_ATTR_OPTION_DATA];\n\t\tif (opt_type != TEAM_OPTION_TYPE_BOOL && !attr_data) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto team_put;\n\t\t}\n\n\t\topt_name = nla_data(opt_attrs[TEAM_ATTR_OPTION_NAME]);\n\t\tattr = opt_attrs[TEAM_ATTR_OPTION_PORT_IFINDEX];\n\t\tif (attr)\n\t\t\topt_port_ifindex = nla_get_u32(attr);\n\n\t\tattr = opt_attrs[TEAM_ATTR_OPTION_ARRAY_INDEX];\n\t\tif (attr) {\n\t\t\topt_is_array = true;\n\t\t\topt_array_index = nla_get_u32(attr);\n\t\t}\n\n\t\tlist_for_each_entry(opt_inst, &team->option_inst_list, list) {\n\t\t\tstruct team_option *option = opt_inst->option;\n\t\t\tstruct team_gsetter_ctx ctx;\n\t\t\tstruct team_option_inst_info *opt_inst_info;\n\t\t\tint tmp_ifindex;\n\n\t\t\topt_inst_info = &opt_inst->info;\n\t\t\ttmp_ifindex = opt_inst_info->port ?\n\t\t\t\t      opt_inst_info->port->dev->ifindex : 0;\n\t\t\tif (option->type != opt_type ||\n\t\t\t    strcmp(option->name, opt_name) ||\n\t\t\t    tmp_ifindex != opt_port_ifindex ||\n\t\t\t    (option->array_size && !opt_is_array) ||\n\t\t\t    opt_inst_info->array_index != opt_array_index)\n\t\t\t\tcontinue;\n\t\t\topt_found = true;\n\t\t\tctx.info = opt_inst_info;\n\t\t\tswitch (opt_type) {\n\t\t\tcase TEAM_OPTION_TYPE_U32:\n\t\t\t\tctx.data.u32_val = nla_get_u32(attr_data);\n\t\t\t\tbreak;\n\t\t\tcase TEAM_OPTION_TYPE_STRING:\n\t\t\t\tif (nla_len(attr_data) > TEAM_STRING_MAX_LEN) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto team_put;\n\t\t\t\t}\n\t\t\t\tctx.data.str_val = nla_data(attr_data);\n\t\t\t\tbreak;\n\t\t\tcase TEAM_OPTION_TYPE_BINARY:\n\t\t\t\tctx.data.bin_val.len = nla_len(attr_data);\n\t\t\t\tctx.data.bin_val.ptr = nla_data(attr_data);\n\t\t\t\tbreak;\n\t\t\tcase TEAM_OPTION_TYPE_BOOL:\n\t\t\t\tctx.data.bool_val = attr_data ? true : false;\n\t\t\t\tbreak;\n\t\t\tcase TEAM_OPTION_TYPE_S32:\n\t\t\t\tctx.data.s32_val = nla_get_s32(attr_data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\terr = team_option_set(team, opt_inst, &ctx);\n\t\t\tif (err)\n\t\t\t\tgoto team_put;\n\t\t\topt_inst->changed = true;\n\t\t\tlist_add(&opt_inst->tmp_list, &opt_inst_list);\n\t\t}\n\t\tif (!opt_found) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto team_put;\n\t\t}\n\n\t\terr = team_nl_send_event_options_get(team, &opt_inst_list);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nteam_put:\n\tteam_nl_team_put(team);\nrtnl_unlock:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int team_nl_fill_one_port_get(struct sk_buff *skb,\n\t\t\t\t     struct team_port *port)\n{\n\tstruct nlattr *port_item;\n\n\tport_item = nla_nest_start_noflag(skb, TEAM_ATTR_ITEM_PORT);\n\tif (!port_item)\n\t\tgoto nest_cancel;\n\tif (nla_put_u32(skb, TEAM_ATTR_PORT_IFINDEX, port->dev->ifindex))\n\t\tgoto nest_cancel;\n\tif (port->changed) {\n\t\tif (nla_put_flag(skb, TEAM_ATTR_PORT_CHANGED))\n\t\t\tgoto nest_cancel;\n\t\tport->changed = false;\n\t}\n\tif ((port->removed &&\n\t     nla_put_flag(skb, TEAM_ATTR_PORT_REMOVED)) ||\n\t    (port->state.linkup &&\n\t     nla_put_flag(skb, TEAM_ATTR_PORT_LINKUP)) ||\n\t    nla_put_u32(skb, TEAM_ATTR_PORT_SPEED, port->state.speed) ||\n\t    nla_put_u8(skb, TEAM_ATTR_PORT_DUPLEX, port->state.duplex))\n\t\tgoto nest_cancel;\n\tnla_nest_end(skb, port_item);\n\treturn 0;\n\nnest_cancel:\n\tnla_nest_cancel(skb, port_item);\n\treturn -EMSGSIZE;\n}\n\nstatic int team_nl_send_port_list_get(struct team *team, u32 portid, u32 seq,\n\t\t\t\t      int flags, team_nl_send_func_t *send_func,\n\t\t\t\t      struct team_port *one_port)\n{\n\tstruct nlattr *port_list;\n\tstruct nlmsghdr *nlh;\n\tvoid *hdr;\n\tstruct team_port *port;\n\tint err;\n\tstruct sk_buff *skb = NULL;\n\tbool incomplete;\n\tint i;\n\n\tport = list_first_entry_or_null(&team->port_list,\n\t\t\t\t\tstruct team_port, list);\n\nstart_again:\n\terr = __send_and_alloc_skb(&skb, team, portid, send_func);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(skb, portid, seq, &team_nl_family, flags | NLM_F_MULTI,\n\t\t\t  TEAM_CMD_PORT_LIST_GET);\n\tif (!hdr) {\n\t\tnlmsg_free(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team->dev->ifindex))\n\t\tgoto nla_put_failure;\n\tport_list = nla_nest_start_noflag(skb, TEAM_ATTR_LIST_PORT);\n\tif (!port_list)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\tincomplete = false;\n\n\t \n\tif (one_port) {\n\t\terr = team_nl_fill_one_port_get(skb, one_port);\n\t\tif (err)\n\t\t\tgoto errout;\n\t} else if (port) {\n\t\tlist_for_each_entry_from(port, &team->port_list, list) {\n\t\t\terr = team_nl_fill_one_port_get(skb, port);\n\t\t\tif (err) {\n\t\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\t\tif (!i)\n\t\t\t\t\t\tgoto errout;\n\t\t\t\t\tincomplete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tnla_nest_end(skb, port_list);\n\tgenlmsg_end(skb, hdr);\n\tif (incomplete)\n\t\tgoto start_again;\n\nsend_done:\n\tnlh = nlmsg_put(skb, portid, seq, NLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = __send_and_alloc_skb(&skb, team, portid, send_func);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto send_done;\n\t}\n\n\treturn send_func(skb, team, portid);\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nerrout:\n\tnlmsg_free(skb);\n\treturn err;\n}\n\nstatic int team_nl_cmd_port_list_get(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct team *team;\n\tint err;\n\n\tteam = team_nl_team_get(info);\n\tif (!team)\n\t\treturn -EINVAL;\n\n\terr = team_nl_send_port_list_get(team, info->snd_portid, info->snd_seq,\n\t\t\t\t\t NLM_F_ACK, team_nl_send_unicast, NULL);\n\n\tteam_nl_team_put(team);\n\n\treturn err;\n}\n\nstatic const struct genl_small_ops team_nl_ops[] = {\n\t{\n\t\t.cmd = TEAM_CMD_NOOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = team_nl_cmd_noop,\n\t},\n\t{\n\t\t.cmd = TEAM_CMD_OPTIONS_SET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = team_nl_cmd_options_set,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = TEAM_CMD_OPTIONS_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = team_nl_cmd_options_get,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = TEAM_CMD_PORT_LIST_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = team_nl_cmd_port_list_get,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic const struct genl_multicast_group team_nl_mcgrps[] = {\n\t{ .name = TEAM_GENL_CHANGE_EVENT_MC_GRP_NAME, },\n};\n\nstatic struct genl_family team_nl_family __ro_after_init = {\n\t.name\t\t= TEAM_GENL_NAME,\n\t.version\t= TEAM_GENL_VERSION,\n\t.maxattr\t= TEAM_ATTR_MAX,\n\t.policy = team_nl_policy,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= team_nl_ops,\n\t.n_small_ops\t= ARRAY_SIZE(team_nl_ops),\n\t.resv_start_op\t= TEAM_CMD_PORT_LIST_GET + 1,\n\t.mcgrps\t\t= team_nl_mcgrps,\n\t.n_mcgrps\t= ARRAY_SIZE(team_nl_mcgrps),\n};\n\nstatic int team_nl_send_multicast(struct sk_buff *skb,\n\t\t\t\t  struct team *team, u32 portid)\n{\n\treturn genlmsg_multicast_netns(&team_nl_family, dev_net(team->dev),\n\t\t\t\t       skb, 0, 0, GFP_KERNEL);\n}\n\nstatic int team_nl_send_event_options_get(struct team *team,\n\t\t\t\t\t  struct list_head *sel_opt_inst_list)\n{\n\treturn team_nl_send_options_get(team, 0, 0, 0, team_nl_send_multicast,\n\t\t\t\t\tsel_opt_inst_list);\n}\n\nstatic int team_nl_send_event_port_get(struct team *team,\n\t\t\t\t       struct team_port *port)\n{\n\treturn team_nl_send_port_list_get(team, 0, 0, 0, team_nl_send_multicast,\n\t\t\t\t\t  port);\n}\n\nstatic int __init team_nl_init(void)\n{\n\treturn genl_register_family(&team_nl_family);\n}\n\nstatic void __exit team_nl_fini(void)\n{\n\tgenl_unregister_family(&team_nl_family);\n}\n\n\n \n\nstatic void __team_options_change_check(struct team *team)\n{\n\tint err;\n\tstruct team_option_inst *opt_inst;\n\tLIST_HEAD(sel_opt_inst_list);\n\n\tlist_for_each_entry(opt_inst, &team->option_inst_list, list) {\n\t\tif (opt_inst->changed)\n\t\t\tlist_add_tail(&opt_inst->tmp_list, &sel_opt_inst_list);\n\t}\n\terr = team_nl_send_event_options_get(team, &sel_opt_inst_list);\n\tif (err && err != -ESRCH)\n\t\tnetdev_warn(team->dev, \"Failed to send options change via netlink (err %d)\\n\",\n\t\t\t    err);\n}\n\n \n\nstatic void __team_port_change_send(struct team_port *port, bool linkup)\n{\n\tint err;\n\n\tport->changed = true;\n\tport->state.linkup = linkup;\n\tteam_refresh_port_linkup(port);\n\tif (linkup) {\n\t\tstruct ethtool_link_ksettings ecmd;\n\n\t\terr = __ethtool_get_link_ksettings(port->dev, &ecmd);\n\t\tif (!err) {\n\t\t\tport->state.speed = ecmd.base.speed;\n\t\t\tport->state.duplex = ecmd.base.duplex;\n\t\t\tgoto send_event;\n\t\t}\n\t}\n\tport->state.speed = 0;\n\tport->state.duplex = 0;\n\nsend_event:\n\terr = team_nl_send_event_port_get(port->team, port);\n\tif (err && err != -ESRCH)\n\t\tnetdev_warn(port->team->dev, \"Failed to send port change of device %s via netlink (err %d)\\n\",\n\t\t\t    port->dev->name, err);\n\n}\n\nstatic void __team_carrier_check(struct team *team)\n{\n\tstruct team_port *port;\n\tbool team_linkup;\n\n\tif (team->user_carrier_enabled)\n\t\treturn;\n\n\tteam_linkup = false;\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\tif (port->linkup) {\n\t\t\tteam_linkup = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (team_linkup)\n\t\tnetif_carrier_on(team->dev);\n\telse\n\t\tnetif_carrier_off(team->dev);\n}\n\nstatic void __team_port_change_check(struct team_port *port, bool linkup)\n{\n\tif (port->state.linkup != linkup)\n\t\t__team_port_change_send(port, linkup);\n\t__team_carrier_check(port->team);\n}\n\nstatic void __team_port_change_port_added(struct team_port *port, bool linkup)\n{\n\t__team_port_change_send(port, linkup);\n\t__team_carrier_check(port->team);\n}\n\nstatic void __team_port_change_port_removed(struct team_port *port)\n{\n\tport->removed = true;\n\t__team_port_change_send(port, false);\n\t__team_carrier_check(port->team);\n}\n\nstatic void team_port_change_check(struct team_port *port, bool linkup)\n{\n\tstruct team *team = port->team;\n\n\tmutex_lock(&team->lock);\n\t__team_port_change_check(port, linkup);\n\tmutex_unlock(&team->lock);\n}\n\n\n \n\nstatic int team_device_event(struct notifier_block *unused,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct team_port *port;\n\n\tport = team_port_get_rtnl(dev);\n\tif (!port)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (netif_oper_up(dev))\n\t\t\tteam_port_change_check(port, true);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tteam_port_change_check(port, false);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tif (netif_running(port->dev))\n\t\t\tteam_port_change_check(port,\n\t\t\t\t\t       !!netif_oper_up(port->dev));\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tteam_del_slave(port->team->dev, dev);\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tif (!port->team->notifier_ctx) {\n\t\t\tport->team->notifier_ctx = true;\n\t\t\tteam_compute_features(port->team);\n\t\t\tport->team->notifier_ctx = false;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_PRECHANGEMTU:\n\t\t \n\t\tif (!port->team->port_mtu_change_allowed)\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t \n\t\treturn NOTIFY_BAD;\n\tcase NETDEV_RESEND_IGMP:\n\t\t \n\t\tcall_netdevice_notifiers(event, port->team->dev);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block team_notifier_block __read_mostly = {\n\t.notifier_call = team_device_event,\n};\n\n\n \n\nstatic int __init team_module_init(void)\n{\n\tint err;\n\n\tregister_netdevice_notifier(&team_notifier_block);\n\n\terr = rtnl_link_register(&team_link_ops);\n\tif (err)\n\t\tgoto err_rtnl_reg;\n\n\terr = team_nl_init();\n\tif (err)\n\t\tgoto err_nl_init;\n\n\treturn 0;\n\nerr_nl_init:\n\trtnl_link_unregister(&team_link_ops);\n\nerr_rtnl_reg:\n\tunregister_netdevice_notifier(&team_notifier_block);\n\n\treturn err;\n}\n\nstatic void __exit team_module_exit(void)\n{\n\tteam_nl_fini();\n\trtnl_link_unregister(&team_link_ops);\n\tunregister_netdevice_notifier(&team_notifier_block);\n}\n\nmodule_init(team_module_init);\nmodule_exit(team_module_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jiri Pirko <jpirko@redhat.com>\");\nMODULE_DESCRIPTION(\"Ethernet team device driver\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}