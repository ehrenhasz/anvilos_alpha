{
  "module_name": "team_mode_loadbalance.c",
  "hash_id": "359164300363cf1cebab7aae987c38f8bc895d12fad88b33f3d025fb731dafc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/team/team_mode_loadbalance.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/filter.h>\n#include <linux/if_team.h>\n\nstatic rx_handler_result_t lb_receive(struct team *team, struct team_port *port,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tif (unlikely(skb->protocol == htons(ETH_P_SLOW))) {\n\t\t \n\t\tconst unsigned char *dest = eth_hdr(skb)->h_dest;\n\n\t\tif (is_link_local_ether_addr(dest) && dest[5] == 0x02)\n\t\t\treturn RX_HANDLER_EXACT;\n\t}\n\treturn RX_HANDLER_ANOTHER;\n}\n\nstruct lb_priv;\n\ntypedef struct team_port *lb_select_tx_port_func_t(struct team *,\n\t\t\t\t\t\t   unsigned char);\n\n#define LB_TX_HASHTABLE_SIZE 256  \n\nstruct lb_stats {\n\tu64 tx_bytes;\n};\n\nstruct lb_pcpu_stats {\n\tstruct lb_stats hash_stats[LB_TX_HASHTABLE_SIZE];\n\tstruct u64_stats_sync syncp;\n};\n\nstruct lb_stats_info {\n\tstruct lb_stats stats;\n\tstruct lb_stats last_stats;\n\tstruct team_option_inst_info *opt_inst_info;\n};\n\nstruct lb_port_mapping {\n\tstruct team_port __rcu *port;\n\tstruct team_option_inst_info *opt_inst_info;\n};\n\nstruct lb_priv_ex {\n\tstruct team *team;\n\tstruct lb_port_mapping tx_hash_to_port_mapping[LB_TX_HASHTABLE_SIZE];\n\tstruct sock_fprog_kern *orig_fprog;\n\tstruct {\n\t\tunsigned int refresh_interval;  \n\t\tstruct delayed_work refresh_dw;\n\t\tstruct lb_stats_info info[LB_TX_HASHTABLE_SIZE];\n\t} stats;\n};\n\nstruct lb_priv {\n\tstruct bpf_prog __rcu *fp;\n\tlb_select_tx_port_func_t __rcu *select_tx_port_func;\n\tstruct lb_pcpu_stats __percpu *pcpu_stats;\n\tstruct lb_priv_ex *ex;  \n};\n\nstatic struct lb_priv *get_lb_priv(struct team *team)\n{\n\treturn (struct lb_priv *) &team->mode_priv;\n}\n\nstruct lb_port_priv {\n\tstruct lb_stats __percpu *pcpu_stats;\n\tstruct lb_stats_info stats_info;\n};\n\nstatic struct lb_port_priv *get_lb_port_priv(struct team_port *port)\n{\n\treturn (struct lb_port_priv *) &port->mode_priv;\n}\n\n#define LB_HTPM_PORT_BY_HASH(lp_priv, hash) \\\n\t(lb_priv)->ex->tx_hash_to_port_mapping[hash].port\n\n#define LB_HTPM_OPT_INST_INFO_BY_HASH(lp_priv, hash) \\\n\t(lb_priv)->ex->tx_hash_to_port_mapping[hash].opt_inst_info\n\nstatic void lb_tx_hash_to_port_mapping_null_port(struct team *team,\n\t\t\t\t\t\t struct team_port *port)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tbool changed = false;\n\tint i;\n\n\tfor (i = 0; i < LB_TX_HASHTABLE_SIZE; i++) {\n\t\tstruct lb_port_mapping *pm;\n\n\t\tpm = &lb_priv->ex->tx_hash_to_port_mapping[i];\n\t\tif (rcu_access_pointer(pm->port) == port) {\n\t\t\tRCU_INIT_POINTER(pm->port, NULL);\n\t\t\tteam_option_inst_set_change(pm->opt_inst_info);\n\t\t\tchanged = true;\n\t\t}\n\t}\n\tif (changed)\n\t\tteam_options_change_check(team);\n}\n\n \nstatic struct team_port *lb_hash_select_tx_port(struct team *team,\n\t\t\t\t\t\tunsigned char hash)\n{\n\tint port_index = team_num_to_port_index(team, hash);\n\n\treturn team_get_port_by_index_rcu(team, port_index);\n}\n\n \nstatic struct team_port *lb_htpm_select_tx_port(struct team *team,\n\t\t\t\t\t\tunsigned char hash)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tstruct team_port *port;\n\n\tport = rcu_dereference_bh(LB_HTPM_PORT_BY_HASH(lb_priv, hash));\n\tif (likely(port))\n\t\treturn port;\n\t \n\treturn lb_hash_select_tx_port(team, hash);\n}\n\nstruct lb_select_tx_port {\n\tchar *name;\n\tlb_select_tx_port_func_t *func;\n};\n\nstatic const struct lb_select_tx_port lb_select_tx_port_list[] = {\n\t{\n\t\t.name = \"hash\",\n\t\t.func = lb_hash_select_tx_port,\n\t},\n\t{\n\t\t.name = \"hash_to_port_mapping\",\n\t\t.func = lb_htpm_select_tx_port,\n\t},\n};\n#define LB_SELECT_TX_PORT_LIST_COUNT ARRAY_SIZE(lb_select_tx_port_list)\n\nstatic char *lb_select_tx_port_get_name(lb_select_tx_port_func_t *func)\n{\n\tint i;\n\n\tfor (i = 0; i < LB_SELECT_TX_PORT_LIST_COUNT; i++) {\n\t\tconst struct lb_select_tx_port *item;\n\n\t\titem = &lb_select_tx_port_list[i];\n\t\tif (item->func == func)\n\t\t\treturn item->name;\n\t}\n\treturn NULL;\n}\n\nstatic lb_select_tx_port_func_t *lb_select_tx_port_get_func(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < LB_SELECT_TX_PORT_LIST_COUNT; i++) {\n\t\tconst struct lb_select_tx_port *item;\n\n\t\titem = &lb_select_tx_port_list[i];\n\t\tif (!strcmp(item->name, name))\n\t\t\treturn item->func;\n\t}\n\treturn NULL;\n}\n\nstatic unsigned int lb_get_skb_hash(struct lb_priv *lb_priv,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct bpf_prog *fp;\n\tuint32_t lhash;\n\tunsigned char *c;\n\n\tfp = rcu_dereference_bh(lb_priv->fp);\n\tif (unlikely(!fp))\n\t\treturn 0;\n\tlhash = bpf_prog_run(fp, skb);\n\tc = (char *) &lhash;\n\treturn c[0] ^ c[1] ^ c[2] ^ c[3];\n}\n\nstatic void lb_update_tx_stats(unsigned int tx_bytes, struct lb_priv *lb_priv,\n\t\t\t       struct lb_port_priv *lb_port_priv,\n\t\t\t       unsigned char hash)\n{\n\tstruct lb_pcpu_stats *pcpu_stats;\n\tstruct lb_stats *port_stats;\n\tstruct lb_stats *hash_stats;\n\n\tpcpu_stats = this_cpu_ptr(lb_priv->pcpu_stats);\n\tport_stats = this_cpu_ptr(lb_port_priv->pcpu_stats);\n\thash_stats = &pcpu_stats->hash_stats[hash];\n\tu64_stats_update_begin(&pcpu_stats->syncp);\n\tport_stats->tx_bytes += tx_bytes;\n\thash_stats->tx_bytes += tx_bytes;\n\tu64_stats_update_end(&pcpu_stats->syncp);\n}\n\nstatic bool lb_transmit(struct team *team, struct sk_buff *skb)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tlb_select_tx_port_func_t *select_tx_port_func;\n\tstruct team_port *port;\n\tunsigned char hash;\n\tunsigned int tx_bytes = skb->len;\n\n\thash = lb_get_skb_hash(lb_priv, skb);\n\tselect_tx_port_func = rcu_dereference_bh(lb_priv->select_tx_port_func);\n\tport = select_tx_port_func(team, hash);\n\tif (unlikely(!port))\n\t\tgoto drop;\n\tif (team_dev_queue_xmit(team, port, skb))\n\t\treturn false;\n\tlb_update_tx_stats(tx_bytes, lb_priv, get_lb_port_priv(port), hash);\n\treturn true;\n\ndrop:\n\tdev_kfree_skb_any(skb);\n\treturn false;\n}\n\nstatic void lb_bpf_func_get(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\n\tif (!lb_priv->ex->orig_fprog) {\n\t\tctx->data.bin_val.len = 0;\n\t\tctx->data.bin_val.ptr = NULL;\n\t\treturn;\n\t}\n\tctx->data.bin_val.len = lb_priv->ex->orig_fprog->len *\n\t\t\t\tsizeof(struct sock_filter);\n\tctx->data.bin_val.ptr = lb_priv->ex->orig_fprog->filter;\n}\n\nstatic int __fprog_create(struct sock_fprog_kern **pfprog, u32 data_len,\n\t\t\t  const void *data)\n{\n\tstruct sock_fprog_kern *fprog;\n\tstruct sock_filter *filter = (struct sock_filter *) data;\n\n\tif (data_len % sizeof(struct sock_filter))\n\t\treturn -EINVAL;\n\tfprog = kmalloc(sizeof(*fprog), GFP_KERNEL);\n\tif (!fprog)\n\t\treturn -ENOMEM;\n\tfprog->filter = kmemdup(filter, data_len, GFP_KERNEL);\n\tif (!fprog->filter) {\n\t\tkfree(fprog);\n\t\treturn -ENOMEM;\n\t}\n\tfprog->len = data_len / sizeof(struct sock_filter);\n\t*pfprog = fprog;\n\treturn 0;\n}\n\nstatic void __fprog_destroy(struct sock_fprog_kern *fprog)\n{\n\tkfree(fprog->filter);\n\tkfree(fprog);\n}\n\nstatic int lb_bpf_func_set(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tstruct bpf_prog *fp = NULL;\n\tstruct bpf_prog *orig_fp = NULL;\n\tstruct sock_fprog_kern *fprog = NULL;\n\tint err;\n\n\tif (ctx->data.bin_val.len) {\n\t\terr = __fprog_create(&fprog, ctx->data.bin_val.len,\n\t\t\t\t     ctx->data.bin_val.ptr);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = bpf_prog_create(&fp, fprog);\n\t\tif (err) {\n\t\t\t__fprog_destroy(fprog);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (lb_priv->ex->orig_fprog) {\n\t\t \n\t\t__fprog_destroy(lb_priv->ex->orig_fprog);\n\t\torig_fp = rcu_dereference_protected(lb_priv->fp,\n\t\t\t\t\t\tlockdep_is_held(&team->lock));\n\t}\n\n\trcu_assign_pointer(lb_priv->fp, fp);\n\tlb_priv->ex->orig_fprog = fprog;\n\n\tif (orig_fp) {\n\t\tsynchronize_rcu();\n\t\tbpf_prog_destroy(orig_fp);\n\t}\n\treturn 0;\n}\n\nstatic void lb_bpf_func_free(struct team *team)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tstruct bpf_prog *fp;\n\n\tif (!lb_priv->ex->orig_fprog)\n\t\treturn;\n\n\t__fprog_destroy(lb_priv->ex->orig_fprog);\n\tfp = rcu_dereference_protected(lb_priv->fp,\n\t\t\t\t       lockdep_is_held(&team->lock));\n\tbpf_prog_destroy(fp);\n}\n\nstatic void lb_tx_method_get(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tlb_select_tx_port_func_t *func;\n\tchar *name;\n\n\tfunc = rcu_dereference_protected(lb_priv->select_tx_port_func,\n\t\t\t\t\t lockdep_is_held(&team->lock));\n\tname = lb_select_tx_port_get_name(func);\n\tBUG_ON(!name);\n\tctx->data.str_val = name;\n}\n\nstatic int lb_tx_method_set(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tlb_select_tx_port_func_t *func;\n\n\tfunc = lb_select_tx_port_get_func(ctx->data.str_val);\n\tif (!func)\n\t\treturn -EINVAL;\n\trcu_assign_pointer(lb_priv->select_tx_port_func, func);\n\treturn 0;\n}\n\nstatic void lb_tx_hash_to_port_mapping_init(struct team *team,\n\t\t\t\t\t    struct team_option_inst_info *info)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tunsigned char hash = info->array_index;\n\n\tLB_HTPM_OPT_INST_INFO_BY_HASH(lb_priv, hash) = info;\n}\n\nstatic void lb_tx_hash_to_port_mapping_get(struct team *team,\n\t\t\t\t\t   struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tstruct team_port *port;\n\tunsigned char hash = ctx->info->array_index;\n\n\tport = LB_HTPM_PORT_BY_HASH(lb_priv, hash);\n\tctx->data.u32_val = port ? port->dev->ifindex : 0;\n}\n\nstatic int lb_tx_hash_to_port_mapping_set(struct team *team,\n\t\t\t\t\t  struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tstruct team_port *port;\n\tunsigned char hash = ctx->info->array_index;\n\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\tif (ctx->data.u32_val == port->dev->ifindex &&\n\t\t    team_port_enabled(port)) {\n\t\t\trcu_assign_pointer(LB_HTPM_PORT_BY_HASH(lb_priv, hash),\n\t\t\t\t\t   port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic void lb_hash_stats_init(struct team *team,\n\t\t\t       struct team_option_inst_info *info)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tunsigned char hash = info->array_index;\n\n\tlb_priv->ex->stats.info[hash].opt_inst_info = info;\n}\n\nstatic void lb_hash_stats_get(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tunsigned char hash = ctx->info->array_index;\n\n\tctx->data.bin_val.ptr = &lb_priv->ex->stats.info[hash].stats;\n\tctx->data.bin_val.len = sizeof(struct lb_stats);\n}\n\nstatic void lb_port_stats_init(struct team *team,\n\t\t\t       struct team_option_inst_info *info)\n{\n\tstruct team_port *port = info->port;\n\tstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\n\n\tlb_port_priv->stats_info.opt_inst_info = info;\n}\n\nstatic void lb_port_stats_get(struct team *team, struct team_gsetter_ctx *ctx)\n{\n\tstruct team_port *port = ctx->info->port;\n\tstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\n\n\tctx->data.bin_val.ptr = &lb_port_priv->stats_info.stats;\n\tctx->data.bin_val.len = sizeof(struct lb_stats);\n}\n\nstatic void __lb_stats_info_refresh_prepare(struct lb_stats_info *s_info)\n{\n\tmemcpy(&s_info->last_stats, &s_info->stats, sizeof(struct lb_stats));\n\tmemset(&s_info->stats, 0, sizeof(struct lb_stats));\n}\n\nstatic bool __lb_stats_info_refresh_check(struct lb_stats_info *s_info,\n\t\t\t\t\t  struct team *team)\n{\n\tif (memcmp(&s_info->last_stats, &s_info->stats,\n\t    sizeof(struct lb_stats))) {\n\t\tteam_option_inst_set_change(s_info->opt_inst_info);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void __lb_one_cpu_stats_add(struct lb_stats *acc_stats,\n\t\t\t\t   struct lb_stats *cpu_stats,\n\t\t\t\t   struct u64_stats_sync *syncp)\n{\n\tunsigned int start;\n\tstruct lb_stats tmp;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(syncp);\n\t\ttmp.tx_bytes = cpu_stats->tx_bytes;\n\t} while (u64_stats_fetch_retry(syncp, start));\n\tacc_stats->tx_bytes += tmp.tx_bytes;\n}\n\nstatic void lb_stats_refresh(struct work_struct *work)\n{\n\tstruct team *team;\n\tstruct lb_priv *lb_priv;\n\tstruct lb_priv_ex *lb_priv_ex;\n\tstruct lb_pcpu_stats *pcpu_stats;\n\tstruct lb_stats *stats;\n\tstruct lb_stats_info *s_info;\n\tstruct team_port *port;\n\tbool changed = false;\n\tint i;\n\tint j;\n\n\tlb_priv_ex = container_of(work, struct lb_priv_ex,\n\t\t\t\t  stats.refresh_dw.work);\n\n\tteam = lb_priv_ex->team;\n\tlb_priv = get_lb_priv(team);\n\n\tif (!mutex_trylock(&team->lock)) {\n\t\tschedule_delayed_work(&lb_priv_ex->stats.refresh_dw, 0);\n\t\treturn;\n\t}\n\n\tfor (j = 0; j < LB_TX_HASHTABLE_SIZE; j++) {\n\t\ts_info = &lb_priv->ex->stats.info[j];\n\t\t__lb_stats_info_refresh_prepare(s_info);\n\t\tfor_each_possible_cpu(i) {\n\t\t\tpcpu_stats = per_cpu_ptr(lb_priv->pcpu_stats, i);\n\t\t\tstats = &pcpu_stats->hash_stats[j];\n\t\t\t__lb_one_cpu_stats_add(&s_info->stats, stats,\n\t\t\t\t\t       &pcpu_stats->syncp);\n\t\t}\n\t\tchanged |= __lb_stats_info_refresh_check(s_info, team);\n\t}\n\n\tlist_for_each_entry(port, &team->port_list, list) {\n\t\tstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\n\n\t\ts_info = &lb_port_priv->stats_info;\n\t\t__lb_stats_info_refresh_prepare(s_info);\n\t\tfor_each_possible_cpu(i) {\n\t\t\tpcpu_stats = per_cpu_ptr(lb_priv->pcpu_stats, i);\n\t\t\tstats = per_cpu_ptr(lb_port_priv->pcpu_stats, i);\n\t\t\t__lb_one_cpu_stats_add(&s_info->stats, stats,\n\t\t\t\t\t       &pcpu_stats->syncp);\n\t\t}\n\t\tchanged |= __lb_stats_info_refresh_check(s_info, team);\n\t}\n\n\tif (changed)\n\t\tteam_options_change_check(team);\n\n\tschedule_delayed_work(&lb_priv_ex->stats.refresh_dw,\n\t\t\t      (lb_priv_ex->stats.refresh_interval * HZ) / 10);\n\n\tmutex_unlock(&team->lock);\n}\n\nstatic void lb_stats_refresh_interval_get(struct team *team,\n\t\t\t\t\t  struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\n\tctx->data.u32_val = lb_priv->ex->stats.refresh_interval;\n}\n\nstatic int lb_stats_refresh_interval_set(struct team *team,\n\t\t\t\t\t struct team_gsetter_ctx *ctx)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tunsigned int interval;\n\n\tinterval = ctx->data.u32_val;\n\tif (lb_priv->ex->stats.refresh_interval == interval)\n\t\treturn 0;\n\tlb_priv->ex->stats.refresh_interval = interval;\n\tif (interval)\n\t\tschedule_delayed_work(&lb_priv->ex->stats.refresh_dw, 0);\n\telse\n\t\tcancel_delayed_work(&lb_priv->ex->stats.refresh_dw);\n\treturn 0;\n}\n\nstatic const struct team_option lb_options[] = {\n\t{\n\t\t.name = \"bpf_hash_func\",\n\t\t.type = TEAM_OPTION_TYPE_BINARY,\n\t\t.getter = lb_bpf_func_get,\n\t\t.setter = lb_bpf_func_set,\n\t},\n\t{\n\t\t.name = \"lb_tx_method\",\n\t\t.type = TEAM_OPTION_TYPE_STRING,\n\t\t.getter = lb_tx_method_get,\n\t\t.setter = lb_tx_method_set,\n\t},\n\t{\n\t\t.name = \"lb_tx_hash_to_port_mapping\",\n\t\t.array_size = LB_TX_HASHTABLE_SIZE,\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.init = lb_tx_hash_to_port_mapping_init,\n\t\t.getter = lb_tx_hash_to_port_mapping_get,\n\t\t.setter = lb_tx_hash_to_port_mapping_set,\n\t},\n\t{\n\t\t.name = \"lb_hash_stats\",\n\t\t.array_size = LB_TX_HASHTABLE_SIZE,\n\t\t.type = TEAM_OPTION_TYPE_BINARY,\n\t\t.init = lb_hash_stats_init,\n\t\t.getter = lb_hash_stats_get,\n\t},\n\t{\n\t\t.name = \"lb_port_stats\",\n\t\t.per_port = true,\n\t\t.type = TEAM_OPTION_TYPE_BINARY,\n\t\t.init = lb_port_stats_init,\n\t\t.getter = lb_port_stats_get,\n\t},\n\t{\n\t\t.name = \"lb_stats_refresh_interval\",\n\t\t.type = TEAM_OPTION_TYPE_U32,\n\t\t.getter = lb_stats_refresh_interval_get,\n\t\t.setter = lb_stats_refresh_interval_set,\n\t},\n};\n\nstatic int lb_init(struct team *team)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\tlb_select_tx_port_func_t *func;\n\tint i, err;\n\n\t \n\tfunc = lb_select_tx_port_get_func(\"hash\");\n\tBUG_ON(!func);\n\trcu_assign_pointer(lb_priv->select_tx_port_func, func);\n\n\tlb_priv->ex = kzalloc(sizeof(*lb_priv->ex), GFP_KERNEL);\n\tif (!lb_priv->ex)\n\t\treturn -ENOMEM;\n\tlb_priv->ex->team = team;\n\n\tlb_priv->pcpu_stats = alloc_percpu(struct lb_pcpu_stats);\n\tif (!lb_priv->pcpu_stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_pcpu_stats;\n\t}\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct lb_pcpu_stats *team_lb_stats;\n\t\tteam_lb_stats = per_cpu_ptr(lb_priv->pcpu_stats, i);\n\t\tu64_stats_init(&team_lb_stats->syncp);\n\t}\n\n\n\tINIT_DELAYED_WORK(&lb_priv->ex->stats.refresh_dw, lb_stats_refresh);\n\n\terr = team_options_register(team, lb_options, ARRAY_SIZE(lb_options));\n\tif (err)\n\t\tgoto err_options_register;\n\treturn 0;\n\nerr_options_register:\n\tfree_percpu(lb_priv->pcpu_stats);\nerr_alloc_pcpu_stats:\n\tkfree(lb_priv->ex);\n\treturn err;\n}\n\nstatic void lb_exit(struct team *team)\n{\n\tstruct lb_priv *lb_priv = get_lb_priv(team);\n\n\tteam_options_unregister(team, lb_options,\n\t\t\t\tARRAY_SIZE(lb_options));\n\tlb_bpf_func_free(team);\n\tcancel_delayed_work_sync(&lb_priv->ex->stats.refresh_dw);\n\tfree_percpu(lb_priv->pcpu_stats);\n\tkfree(lb_priv->ex);\n}\n\nstatic int lb_port_enter(struct team *team, struct team_port *port)\n{\n\tstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\n\n\tlb_port_priv->pcpu_stats = alloc_percpu(struct lb_stats);\n\tif (!lb_port_priv->pcpu_stats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void lb_port_leave(struct team *team, struct team_port *port)\n{\n\tstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\n\n\tfree_percpu(lb_port_priv->pcpu_stats);\n}\n\nstatic void lb_port_disabled(struct team *team, struct team_port *port)\n{\n\tlb_tx_hash_to_port_mapping_null_port(team, port);\n}\n\nstatic const struct team_mode_ops lb_mode_ops = {\n\t.init\t\t\t= lb_init,\n\t.exit\t\t\t= lb_exit,\n\t.port_enter\t\t= lb_port_enter,\n\t.port_leave\t\t= lb_port_leave,\n\t.port_disabled\t\t= lb_port_disabled,\n\t.receive\t\t= lb_receive,\n\t.transmit\t\t= lb_transmit,\n};\n\nstatic const struct team_mode lb_mode = {\n\t.kind\t\t= \"loadbalance\",\n\t.owner\t\t= THIS_MODULE,\n\t.priv_size\t= sizeof(struct lb_priv),\n\t.port_priv_size\t= sizeof(struct lb_port_priv),\n\t.ops\t\t= &lb_mode_ops,\n\t.lag_tx_type\t= NETDEV_LAG_TX_TYPE_HASH,\n};\n\nstatic int __init lb_init_module(void)\n{\n\treturn team_mode_register(&lb_mode);\n}\n\nstatic void __exit lb_cleanup_module(void)\n{\n\tteam_mode_unregister(&lb_mode);\n}\n\nmodule_init(lb_init_module);\nmodule_exit(lb_cleanup_module);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jiri Pirko <jpirko@redhat.com>\");\nMODULE_DESCRIPTION(\"Load-balancing mode for team\");\nMODULE_ALIAS_TEAM_MODE(\"loadbalance\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}