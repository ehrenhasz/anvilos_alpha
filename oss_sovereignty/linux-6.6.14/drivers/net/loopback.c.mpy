{
  "module_name": "loopback.c",
  "hash_id": "0d519f62a790a4e4b42306e33033e0e5101b51ec3da131190b116c4c52565926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/loopback.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <net/sch_generic.h>\n#include <net/sock.h>\n#include <net/checksum.h>\n#include <linux/if_ether.h>\t \n#include <linux/if_arp.h>\t \n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/percpu.h>\n#include <linux/net_tstamp.h>\n#include <net/net_namespace.h>\n#include <linux/u64_stats_sync.h>\n\n \nstruct net_device *blackhole_netdev;\nEXPORT_SYMBOL(blackhole_netdev);\n\n \nstatic netdev_tx_t loopback_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tint len;\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tskb_clear_tstamp(skb);\n\n\tskb_orphan(skb);\n\n\t \n\tskb_dst_force(skb);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\tlen = skb->len;\n\tif (likely(__netif_rx(skb) == NET_RX_SUCCESS))\n\t\tdev_lstats_add(dev, len);\n\n\treturn NETDEV_TX_OK;\n}\n\nvoid dev_lstats_read(struct net_device *dev, u64 *packets, u64 *bytes)\n{\n\tint i;\n\n\t*packets = 0;\n\t*bytes = 0;\n\n\tfor_each_possible_cpu(i) {\n\t\tconst struct pcpu_lstats *lb_stats;\n\t\tu64 tbytes, tpackets;\n\t\tunsigned int start;\n\n\t\tlb_stats = per_cpu_ptr(dev->lstats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&lb_stats->syncp);\n\t\t\ttpackets = u64_stats_read(&lb_stats->packets);\n\t\t\ttbytes = u64_stats_read(&lb_stats->bytes);\n\t\t} while (u64_stats_fetch_retry(&lb_stats->syncp, start));\n\t\t*bytes   += tbytes;\n\t\t*packets += tpackets;\n\t}\n}\nEXPORT_SYMBOL(dev_lstats_read);\n\nstatic void loopback_get_stats64(struct net_device *dev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tu64 packets, bytes;\n\n\tdev_lstats_read(dev, &packets, &bytes);\n\n\tstats->rx_packets = packets;\n\tstats->tx_packets = packets;\n\tstats->rx_bytes   = bytes;\n\tstats->tx_bytes   = bytes;\n}\n\nstatic u32 always_on(struct net_device *dev)\n{\n\treturn 1;\n}\n\nstatic const struct ethtool_ops loopback_ethtool_ops = {\n\t.get_link\t\t= always_on,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n};\n\nstatic int loopback_dev_init(struct net_device *dev)\n{\n\tdev->lstats = netdev_alloc_pcpu_stats(struct pcpu_lstats);\n\tif (!dev->lstats)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void loopback_dev_free(struct net_device *dev)\n{\n\tdev_net(dev)->loopback_dev = NULL;\n\tfree_percpu(dev->lstats);\n}\n\nstatic const struct net_device_ops loopback_ops = {\n\t.ndo_init        = loopback_dev_init,\n\t.ndo_start_xmit  = loopback_xmit,\n\t.ndo_get_stats64 = loopback_get_stats64,\n\t.ndo_set_mac_address = eth_mac_addr,\n};\n\nstatic void gen_lo_setup(struct net_device *dev,\n\t\t\t unsigned int mtu,\n\t\t\t const struct ethtool_ops *eth_ops,\n\t\t\t const struct header_ops *hdr_ops,\n\t\t\t const struct net_device_ops *dev_ops,\n\t\t\t void (*dev_destructor)(struct net_device *dev))\n{\n\tdev->mtu\t\t= mtu;\n\tdev->hard_header_len\t= ETH_HLEN;\t \n\tdev->min_header_len\t= ETH_HLEN;\t \n\tdev->addr_len\t\t= ETH_ALEN;\t \n\tdev->type\t\t= ARPHRD_LOOPBACK;\t \n\tdev->flags\t\t= IFF_LOOPBACK;\n\tdev->priv_flags\t\t|= IFF_LIVE_ADDR_CHANGE | IFF_NO_QUEUE;\n\tnetif_keep_dst(dev);\n\tdev->hw_features\t= NETIF_F_GSO_SOFTWARE;\n\tdev->features\t\t= NETIF_F_SG | NETIF_F_FRAGLIST\n\t\t| NETIF_F_GSO_SOFTWARE\n\t\t| NETIF_F_HW_CSUM\n\t\t| NETIF_F_RXCSUM\n\t\t| NETIF_F_SCTP_CRC\n\t\t| NETIF_F_HIGHDMA\n\t\t| NETIF_F_LLTX\n\t\t| NETIF_F_NETNS_LOCAL\n\t\t| NETIF_F_VLAN_CHALLENGED\n\t\t| NETIF_F_LOOPBACK;\n\tdev->ethtool_ops\t= eth_ops;\n\tdev->header_ops\t\t= hdr_ops;\n\tdev->netdev_ops\t\t= dev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= dev_destructor;\n\n\tnetif_set_tso_max_size(dev, GSO_MAX_SIZE);\n}\n\n \nstatic void loopback_setup(struct net_device *dev)\n{\n\tgen_lo_setup(dev, (64 * 1024), &loopback_ethtool_ops, &eth_header_ops,\n\t\t     &loopback_ops, loopback_dev_free);\n}\n\n \nstatic __net_init int loopback_net_init(struct net *net)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\terr = -ENOMEM;\n\tdev = alloc_netdev(0, \"lo\", NET_NAME_PREDICTABLE, loopback_setup);\n\tif (!dev)\n\t\tgoto out;\n\n\tdev_net_set(dev, net);\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_free_netdev;\n\n\tBUG_ON(dev->ifindex != LOOPBACK_IFINDEX);\n\tnet->loopback_dev = dev;\n\treturn 0;\n\nout_free_netdev:\n\tfree_netdev(dev);\nout:\n\tif (net_eq(net, &init_net))\n\t\tpanic(\"loopback: Failed to register netdevice: %d\\n\", err);\n\treturn err;\n}\n\n \nstruct pernet_operations __net_initdata loopback_net_ops = {\n\t.init = loopback_net_init,\n};\n\n \nstatic netdev_tx_t blackhole_netdev_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tkfree_skb(skb);\n\tnet_warn_ratelimited(\"%s(): Dropping skb.\\n\", __func__);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops blackhole_netdev_ops = {\n\t.ndo_start_xmit = blackhole_netdev_xmit,\n};\n\n \nstatic void blackhole_netdev_setup(struct net_device *dev)\n{\n\tgen_lo_setup(dev, ETH_MIN_MTU, NULL, NULL, &blackhole_netdev_ops, NULL);\n}\n\n \nstatic int __init blackhole_netdev_init(void)\n{\n\tblackhole_netdev = alloc_netdev(0, \"blackhole_dev\", NET_NAME_UNKNOWN,\n\t\t\t\t\tblackhole_netdev_setup);\n\tif (!blackhole_netdev)\n\t\treturn -ENOMEM;\n\n\trtnl_lock();\n\tdev_init_scheduler(blackhole_netdev);\n\tdev_activate(blackhole_netdev);\n\trtnl_unlock();\n\n\tblackhole_netdev->flags |= IFF_UP | IFF_RUNNING;\n\tdev_net_set(blackhole_netdev, &init_net);\n\n\treturn 0;\n}\n\ndevice_initcall(blackhole_netdev_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}