{
  "module_name": "bond_main.c",
  "hash_id": "9e9c5aae25d50c3b362d78b1d4562df493184a1b4d1d03f0c618e98641c16270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/filter.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/socket.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/rtnetlink.h>\n#include <linux/smp.h>\n#include <linux/if_ether.h>\n#include <net/arp.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bonding.h>\n#include <linux/phy.h>\n#include <linux/jiffies.h>\n#include <linux/preempt.h>\n#include <net/route.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/pkt_sched.h>\n#include <linux/rculist.h>\n#include <net/flow_dissector.h>\n#include <net/xfrm.h>\n#include <net/bonding.h>\n#include <net/bond_3ad.h>\n#include <net/bond_alb.h>\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\n#include <net/tls.h>\n#endif\n#include <net/ip6_route.h>\n#include <net/xdp.h>\n\n#include \"bonding_priv.h\"\n\n \n\n \n\nstatic int max_bonds\t= BOND_DEFAULT_MAX_BONDS;\nstatic int tx_queues\t= BOND_DEFAULT_TX_QUEUES;\nstatic int num_peer_notif = 1;\nstatic int miimon;\nstatic int updelay;\nstatic int downdelay;\nstatic int use_carrier\t= 1;\nstatic char *mode;\nstatic char *primary;\nstatic char *primary_reselect;\nstatic char *lacp_rate;\nstatic int min_links;\nstatic char *ad_select;\nstatic char *xmit_hash_policy;\nstatic int arp_interval;\nstatic char *arp_ip_target[BOND_MAX_ARP_TARGETS];\nstatic char *arp_validate;\nstatic char *arp_all_targets;\nstatic char *fail_over_mac;\nstatic int all_slaves_active;\nstatic struct bond_params bonding_defaults;\nstatic int resend_igmp = BOND_DEFAULT_RESEND_IGMP;\nstatic int packets_per_slave = 1;\nstatic int lp_interval = BOND_ALB_DEFAULT_LP_INTERVAL;\n\nmodule_param(max_bonds, int, 0);\nMODULE_PARM_DESC(max_bonds, \"Max number of bonded devices\");\nmodule_param(tx_queues, int, 0);\nMODULE_PARM_DESC(tx_queues, \"Max number of transmit queues (default = 16)\");\nmodule_param_named(num_grat_arp, num_peer_notif, int, 0644);\nMODULE_PARM_DESC(num_grat_arp, \"Number of peer notifications to send on \"\n\t\t\t       \"failover event (alias of num_unsol_na)\");\nmodule_param_named(num_unsol_na, num_peer_notif, int, 0644);\nMODULE_PARM_DESC(num_unsol_na, \"Number of peer notifications to send on \"\n\t\t\t       \"failover event (alias of num_grat_arp)\");\nmodule_param(miimon, int, 0);\nMODULE_PARM_DESC(miimon, \"Link check interval in milliseconds\");\nmodule_param(updelay, int, 0);\nMODULE_PARM_DESC(updelay, \"Delay before considering link up, in milliseconds\");\nmodule_param(downdelay, int, 0);\nMODULE_PARM_DESC(downdelay, \"Delay before considering link down, \"\n\t\t\t    \"in milliseconds\");\nmodule_param(use_carrier, int, 0);\nMODULE_PARM_DESC(use_carrier, \"Use netif_carrier_ok (vs MII ioctls) in miimon; \"\n\t\t\t      \"0 for off, 1 for on (default)\");\nmodule_param(mode, charp, 0);\nMODULE_PARM_DESC(mode, \"Mode of operation; 0 for balance-rr, \"\n\t\t       \"1 for active-backup, 2 for balance-xor, \"\n\t\t       \"3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, \"\n\t\t       \"6 for balance-alb\");\nmodule_param(primary, charp, 0);\nMODULE_PARM_DESC(primary, \"Primary network device to use\");\nmodule_param(primary_reselect, charp, 0);\nMODULE_PARM_DESC(primary_reselect, \"Reselect primary slave \"\n\t\t\t\t   \"once it comes up; \"\n\t\t\t\t   \"0 for always (default), \"\n\t\t\t\t   \"1 for only if speed of primary is \"\n\t\t\t\t   \"better, \"\n\t\t\t\t   \"2 for only on active slave \"\n\t\t\t\t   \"failure\");\nmodule_param(lacp_rate, charp, 0);\nMODULE_PARM_DESC(lacp_rate, \"LACPDU tx rate to request from 802.3ad partner; \"\n\t\t\t    \"0 for slow, 1 for fast\");\nmodule_param(ad_select, charp, 0);\nMODULE_PARM_DESC(ad_select, \"802.3ad aggregation selection logic; \"\n\t\t\t    \"0 for stable (default), 1 for bandwidth, \"\n\t\t\t    \"2 for count\");\nmodule_param(min_links, int, 0);\nMODULE_PARM_DESC(min_links, \"Minimum number of available links before turning on carrier\");\n\nmodule_param(xmit_hash_policy, charp, 0);\nMODULE_PARM_DESC(xmit_hash_policy, \"balance-alb, balance-tlb, balance-xor, 802.3ad hashing method; \"\n\t\t\t\t   \"0 for layer 2 (default), 1 for layer 3+4, \"\n\t\t\t\t   \"2 for layer 2+3, 3 for encap layer 2+3, \"\n\t\t\t\t   \"4 for encap layer 3+4, 5 for vlan+srcmac\");\nmodule_param(arp_interval, int, 0);\nMODULE_PARM_DESC(arp_interval, \"arp interval in milliseconds\");\nmodule_param_array(arp_ip_target, charp, NULL, 0);\nMODULE_PARM_DESC(arp_ip_target, \"arp targets in n.n.n.n form\");\nmodule_param(arp_validate, charp, 0);\nMODULE_PARM_DESC(arp_validate, \"validate src/dst of ARP probes; \"\n\t\t\t       \"0 for none (default), 1 for active, \"\n\t\t\t       \"2 for backup, 3 for all\");\nmodule_param(arp_all_targets, charp, 0);\nMODULE_PARM_DESC(arp_all_targets, \"fail on any/all arp targets timeout; 0 for any (default), 1 for all\");\nmodule_param(fail_over_mac, charp, 0);\nMODULE_PARM_DESC(fail_over_mac, \"For active-backup, do not set all slaves to \"\n\t\t\t\t\"the same MAC; 0 for none (default), \"\n\t\t\t\t\"1 for active, 2 for follow\");\nmodule_param(all_slaves_active, int, 0);\nMODULE_PARM_DESC(all_slaves_active, \"Keep all frames received on an interface \"\n\t\t\t\t     \"by setting active flag for all slaves; \"\n\t\t\t\t     \"0 for never (default), 1 for always.\");\nmodule_param(resend_igmp, int, 0);\nMODULE_PARM_DESC(resend_igmp, \"Number of IGMP membership reports to send on \"\n\t\t\t      \"link failure\");\nmodule_param(packets_per_slave, int, 0);\nMODULE_PARM_DESC(packets_per_slave, \"Packets to send per slave in balance-rr \"\n\t\t\t\t    \"mode; 0 for a random slave, 1 packet per \"\n\t\t\t\t    \"slave (default), >1 packets per slave.\");\nmodule_param(lp_interval, uint, 0);\nMODULE_PARM_DESC(lp_interval, \"The number of seconds between instances where \"\n\t\t\t      \"the bonding driver sends learning packets to \"\n\t\t\t      \"each slaves peer switch. The default is 1.\");\n\n \n\n#ifdef CONFIG_NET_POLL_CONTROLLER\natomic_t netpoll_block_tx = ATOMIC_INIT(0);\n#endif\n\nunsigned int bond_net_id __read_mostly;\n\nstatic const struct flow_dissector_key flow_keys_bonding_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v4addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v6addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_TIPC,\n\t\t.offset = offsetof(struct flow_keys, addrs.tipckey),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_PORTS,\n\t\t.offset = offsetof(struct flow_keys, ports),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_ICMP,\n\t\t.offset = offsetof(struct flow_keys, icmp),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_VLAN,\n\t\t.offset = offsetof(struct flow_keys, vlan),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t.offset = offsetof(struct flow_keys, tags),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t.offset = offsetof(struct flow_keys, keyid),\n\t},\n};\n\nstatic struct flow_dissector flow_keys_bonding __read_mostly;\n\n \n\nstatic int bond_init(struct net_device *bond_dev);\nstatic void bond_uninit(struct net_device *bond_dev);\nstatic void bond_get_stats(struct net_device *bond_dev,\n\t\t\t   struct rtnl_link_stats64 *stats);\nstatic void bond_slave_arr_handler(struct work_struct *work);\nstatic bool bond_time_in_interval(struct bonding *bond, unsigned long last_act,\n\t\t\t\t  int mod);\nstatic void bond_netdev_notify_work(struct work_struct *work);\n\n \n\nconst char *bond_mode_name(int mode)\n{\n\tstatic const char *names[] = {\n\t\t[BOND_MODE_ROUNDROBIN] = \"load balancing (round-robin)\",\n\t\t[BOND_MODE_ACTIVEBACKUP] = \"fault-tolerance (active-backup)\",\n\t\t[BOND_MODE_XOR] = \"load balancing (xor)\",\n\t\t[BOND_MODE_BROADCAST] = \"fault-tolerance (broadcast)\",\n\t\t[BOND_MODE_8023AD] = \"IEEE 802.3ad Dynamic link aggregation\",\n\t\t[BOND_MODE_TLB] = \"transmit load balancing\",\n\t\t[BOND_MODE_ALB] = \"adaptive load balancing\",\n\t};\n\n\tif (mode < BOND_MODE_ROUNDROBIN || mode > BOND_MODE_ALB)\n\t\treturn \"unknown\";\n\n\treturn names[mode];\n}\n\n \nnetdev_tx_t bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb,\n\t\t\tstruct net_device *slave_dev)\n{\n\tskb->dev = slave_dev;\n\n\tBUILD_BUG_ON(sizeof(skb->queue_mapping) !=\n\t\t     sizeof(qdisc_skb_cb(skb)->slave_dev_queue_mapping));\n\tskb_set_queue_mapping(skb, qdisc_skb_cb(skb)->slave_dev_queue_mapping);\n\n\tif (unlikely(netpoll_tx_running(bond->dev)))\n\t\treturn bond_netpoll_send_skb(bond_get_slave_by_dev(bond, slave_dev), skb);\n\n\treturn dev_queue_xmit(skb);\n}\n\nstatic bool bond_sk_check(struct bonding *bond)\n{\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_8023AD:\n\tcase BOND_MODE_XOR:\n\t\tif (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool bond_xdp_check(struct bonding *bond)\n{\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_ROUNDROBIN:\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\treturn true;\n\tcase BOND_MODE_8023AD:\n\tcase BOND_MODE_XOR:\n\t\t \n\t\tif (bond->params.xmit_policy != BOND_XMIT_POLICY_VLAN_SRCMAC)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \n\n \n\n \nstatic int bond_vlan_rx_add_vid(struct net_device *bond_dev,\n\t\t\t\t__be16 proto, u16 vid)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *rollback_slave;\n\tstruct list_head *iter;\n\tint res;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tres = vlan_vid_add(slave->dev, proto, vid);\n\t\tif (res)\n\t\t\tgoto unwind;\n\t}\n\n\treturn 0;\n\nunwind:\n\t \n\tbond_for_each_slave(bond, rollback_slave, iter) {\n\t\tif (rollback_slave == slave)\n\t\t\tbreak;\n\n\t\tvlan_vid_del(rollback_slave->dev, proto, vid);\n\t}\n\n\treturn res;\n}\n\n \nstatic int bond_vlan_rx_kill_vid(struct net_device *bond_dev,\n\t\t\t\t __be16 proto, u16 vid)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tbond_for_each_slave(bond, slave, iter)\n\t\tvlan_vid_del(slave->dev, proto, vid);\n\n\tif (bond_is_lb(bond))\n\t\tbond_alb_clear_vlan(bond, vid);\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_XFRM_OFFLOAD\n \nstatic int bond_ipsec_add_sa(struct xfrm_state *xs,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct bond_ipsec *ipsec;\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\tint err;\n\n\tif (!bond_dev)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tbond = netdev_priv(bond_dev);\n\tslave = rcu_dereference(bond->curr_active_slave);\n\tif (!slave) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\tif (!slave->dev->xfrmdev_ops ||\n\t    !slave->dev->xfrmdev_ops->xdo_dev_state_add ||\n\t    netif_is_bond_master(slave->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Slave does not support ipsec offload\");\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tipsec = kmalloc(sizeof(*ipsec), GFP_ATOMIC);\n\tif (!ipsec) {\n\t\trcu_read_unlock();\n\t\treturn -ENOMEM;\n\t}\n\txs->xso.real_dev = slave->dev;\n\n\terr = slave->dev->xfrmdev_ops->xdo_dev_state_add(xs, extack);\n\tif (!err) {\n\t\tipsec->xs = xs;\n\t\tINIT_LIST_HEAD(&ipsec->list);\n\t\tspin_lock_bh(&bond->ipsec_lock);\n\t\tlist_add(&ipsec->list, &bond->ipsec_list);\n\t\tspin_unlock_bh(&bond->ipsec_lock);\n\t} else {\n\t\tkfree(ipsec);\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic void bond_ipsec_add_sa_all(struct bonding *bond)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\tstruct bond_ipsec *ipsec;\n\tstruct slave *slave;\n\n\trcu_read_lock();\n\tslave = rcu_dereference(bond->curr_active_slave);\n\tif (!slave)\n\t\tgoto out;\n\n\tif (!slave->dev->xfrmdev_ops ||\n\t    !slave->dev->xfrmdev_ops->xdo_dev_state_add ||\n\t    netif_is_bond_master(slave->dev)) {\n\t\tspin_lock_bh(&bond->ipsec_lock);\n\t\tif (!list_empty(&bond->ipsec_list))\n\t\t\tslave_warn(bond_dev, slave->dev,\n\t\t\t\t   \"%s: no slave xdo_dev_state_add\\n\",\n\t\t\t\t   __func__);\n\t\tspin_unlock_bh(&bond->ipsec_lock);\n\t\tgoto out;\n\t}\n\n\tspin_lock_bh(&bond->ipsec_lock);\n\tlist_for_each_entry(ipsec, &bond->ipsec_list, list) {\n\t\tipsec->xs->xso.real_dev = slave->dev;\n\t\tif (slave->dev->xfrmdev_ops->xdo_dev_state_add(ipsec->xs, NULL)) {\n\t\t\tslave_warn(bond_dev, slave->dev, \"%s: failed to add SA\\n\", __func__);\n\t\t\tipsec->xs->xso.real_dev = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&bond->ipsec_lock);\nout:\n\trcu_read_unlock();\n}\n\n \nstatic void bond_ipsec_del_sa(struct xfrm_state *xs)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct bond_ipsec *ipsec;\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\n\tif (!bond_dev)\n\t\treturn;\n\n\trcu_read_lock();\n\tbond = netdev_priv(bond_dev);\n\tslave = rcu_dereference(bond->curr_active_slave);\n\n\tif (!slave)\n\t\tgoto out;\n\n\tif (!xs->xso.real_dev)\n\t\tgoto out;\n\n\tWARN_ON(xs->xso.real_dev != slave->dev);\n\n\tif (!slave->dev->xfrmdev_ops ||\n\t    !slave->dev->xfrmdev_ops->xdo_dev_state_delete ||\n\t    netif_is_bond_master(slave->dev)) {\n\t\tslave_warn(bond_dev, slave->dev, \"%s: no slave xdo_dev_state_delete\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tslave->dev->xfrmdev_ops->xdo_dev_state_delete(xs);\nout:\n\tspin_lock_bh(&bond->ipsec_lock);\n\tlist_for_each_entry(ipsec, &bond->ipsec_list, list) {\n\t\tif (ipsec->xs == xs) {\n\t\t\tlist_del(&ipsec->list);\n\t\t\tkfree(ipsec);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&bond->ipsec_lock);\n\trcu_read_unlock();\n}\n\nstatic void bond_ipsec_del_sa_all(struct bonding *bond)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\tstruct bond_ipsec *ipsec;\n\tstruct slave *slave;\n\n\trcu_read_lock();\n\tslave = rcu_dereference(bond->curr_active_slave);\n\tif (!slave) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&bond->ipsec_lock);\n\tlist_for_each_entry(ipsec, &bond->ipsec_list, list) {\n\t\tif (!ipsec->xs->xso.real_dev)\n\t\t\tcontinue;\n\n\t\tif (!slave->dev->xfrmdev_ops ||\n\t\t    !slave->dev->xfrmdev_ops->xdo_dev_state_delete ||\n\t\t    netif_is_bond_master(slave->dev)) {\n\t\t\tslave_warn(bond_dev, slave->dev,\n\t\t\t\t   \"%s: no slave xdo_dev_state_delete\\n\",\n\t\t\t\t   __func__);\n\t\t} else {\n\t\t\tslave->dev->xfrmdev_ops->xdo_dev_state_delete(ipsec->xs);\n\t\t}\n\t\tipsec->xs->xso.real_dev = NULL;\n\t}\n\tspin_unlock_bh(&bond->ipsec_lock);\n\trcu_read_unlock();\n}\n\n \nstatic bool bond_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct net_device *real_dev;\n\tstruct slave *curr_active;\n\tstruct bonding *bond;\n\tint err;\n\n\tbond = netdev_priv(bond_dev);\n\trcu_read_lock();\n\tcurr_active = rcu_dereference(bond->curr_active_slave);\n\treal_dev = curr_active->dev;\n\n\tif (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\terr = false;\n\t\tgoto out;\n\t}\n\n\tif (!xs->xso.real_dev) {\n\t\terr = false;\n\t\tgoto out;\n\t}\n\n\tif (!real_dev->xfrmdev_ops ||\n\t    !real_dev->xfrmdev_ops->xdo_dev_offload_ok ||\n\t    netif_is_bond_master(real_dev)) {\n\t\terr = false;\n\t\tgoto out;\n\t}\n\n\terr = real_dev->xfrmdev_ops->xdo_dev_offload_ok(skb, xs);\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic const struct xfrmdev_ops bond_xfrmdev_ops = {\n\t.xdo_dev_state_add = bond_ipsec_add_sa,\n\t.xdo_dev_state_delete = bond_ipsec_del_sa,\n\t.xdo_dev_offload_ok = bond_ipsec_offload_ok,\n};\n#endif  \n\n \n\n \nint bond_set_carrier(struct bonding *bond)\n{\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (!bond_has_slaves(bond))\n\t\tgoto down;\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\treturn bond_3ad_set_carrier(bond);\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\tif (!netif_carrier_ok(bond->dev)) {\n\t\t\t\tnetif_carrier_on(bond->dev);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\ndown:\n\tif (netif_carrier_ok(bond->dev)) {\n\t\tnetif_carrier_off(bond->dev);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int bond_update_speed_duplex(struct slave *slave)\n{\n\tstruct net_device *slave_dev = slave->dev;\n\tstruct ethtool_link_ksettings ecmd;\n\tint res;\n\n\tslave->speed = SPEED_UNKNOWN;\n\tslave->duplex = DUPLEX_UNKNOWN;\n\n\tres = __ethtool_get_link_ksettings(slave_dev, &ecmd);\n\tif (res < 0)\n\t\treturn 1;\n\tif (ecmd.base.speed == 0 || ecmd.base.speed == ((__u32)-1))\n\t\treturn 1;\n\tswitch (ecmd.base.duplex) {\n\tcase DUPLEX_FULL:\n\tcase DUPLEX_HALF:\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\tslave->speed = ecmd.base.speed;\n\tslave->duplex = ecmd.base.duplex;\n\n\treturn 0;\n}\n\nconst char *bond_slave_link_status(s8 link)\n{\n\tswitch (link) {\n\tcase BOND_LINK_UP:\n\t\treturn \"up\";\n\tcase BOND_LINK_FAIL:\n\t\treturn \"going down\";\n\tcase BOND_LINK_DOWN:\n\t\treturn \"down\";\n\tcase BOND_LINK_BACK:\n\t\treturn \"going back\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstatic int bond_check_dev_link(struct bonding *bond,\n\t\t\t       struct net_device *slave_dev, int reporting)\n{\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tint (*ioctl)(struct net_device *, struct ifreq *, int);\n\tstruct ifreq ifr;\n\tstruct mii_ioctl_data *mii;\n\n\tif (!reporting && !netif_running(slave_dev))\n\t\treturn 0;\n\n\tif (bond->params.use_carrier)\n\t\treturn netif_carrier_ok(slave_dev) ? BMSR_LSTATUS : 0;\n\n\t \n\tif (slave_dev->ethtool_ops->get_link)\n\t\treturn slave_dev->ethtool_ops->get_link(slave_dev) ?\n\t\t\tBMSR_LSTATUS : 0;\n\n\t \n\tioctl = slave_ops->ndo_eth_ioctl;\n\tif (ioctl) {\n\t\t \n\n\t\t \n\n\t\t \n\t\tstrscpy_pad(ifr.ifr_name, slave_dev->name, IFNAMSIZ);\n\t\tmii = if_mii(&ifr);\n\t\tif (ioctl(slave_dev, &ifr, SIOCGMIIPHY) == 0) {\n\t\t\tmii->reg_num = MII_BMSR;\n\t\t\tif (ioctl(slave_dev, &ifr, SIOCGMIIREG) == 0)\n\t\t\t\treturn mii->val_out & BMSR_LSTATUS;\n\t\t}\n\t}\n\n\t \n\treturn reporting ? -1 : BMSR_LSTATUS;\n}\n\n \n\n \nstatic int bond_set_promiscuity(struct bonding *bond, int inc)\n{\n\tstruct list_head *iter;\n\tint err = 0;\n\n\tif (bond_uses_primary(bond)) {\n\t\tstruct slave *curr_active = rtnl_dereference(bond->curr_active_slave);\n\n\t\tif (curr_active)\n\t\t\terr = dev_set_promiscuity(curr_active->dev, inc);\n\t} else {\n\t\tstruct slave *slave;\n\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\terr = dev_set_promiscuity(slave->dev, inc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic int bond_set_allmulti(struct bonding *bond, int inc)\n{\n\tstruct list_head *iter;\n\tint err = 0;\n\n\tif (bond_uses_primary(bond)) {\n\t\tstruct slave *curr_active = rtnl_dereference(bond->curr_active_slave);\n\n\t\tif (curr_active)\n\t\t\terr = dev_set_allmulti(curr_active->dev, inc);\n\t} else {\n\t\tstruct slave *slave;\n\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\terr = dev_set_allmulti(slave->dev, inc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic void bond_resend_igmp_join_requests_delayed(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    mcast_work.work);\n\n\tif (!rtnl_trylock()) {\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, 1);\n\t\treturn;\n\t}\n\tcall_netdevice_notifiers(NETDEV_RESEND_IGMP, bond->dev);\n\n\tif (bond->igmp_retrans > 1) {\n\t\tbond->igmp_retrans--;\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, HZ/5);\n\t}\n\trtnl_unlock();\n}\n\n \nstatic void bond_hw_addr_flush(struct net_device *bond_dev,\n\t\t\t       struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tdev_uc_unsync(slave_dev, bond_dev);\n\tdev_mc_unsync(slave_dev, bond_dev);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\tdev_mc_del(slave_dev, lacpdu_mcast_addr);\n}\n\n \n\n \nstatic void bond_hw_addr_swap(struct bonding *bond, struct slave *new_active,\n\t\t\t      struct slave *old_active)\n{\n\tif (old_active) {\n\t\tif (bond->dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(old_active->dev, -1);\n\n\t\tif (bond->dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(old_active->dev, -1);\n\n\t\tif (bond->dev->flags & IFF_UP)\n\t\t\tbond_hw_addr_flush(bond->dev, old_active->dev);\n\t}\n\n\tif (new_active) {\n\t\t \n\t\tif (bond->dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(new_active->dev, 1);\n\n\t\tif (bond->dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(new_active->dev, 1);\n\n\t\tif (bond->dev->flags & IFF_UP) {\n\t\t\tnetif_addr_lock_bh(bond->dev);\n\t\t\tdev_uc_sync(new_active->dev, bond->dev);\n\t\t\tdev_mc_sync(new_active->dev, bond->dev);\n\t\t\tnetif_addr_unlock_bh(bond->dev);\n\t\t}\n\t}\n}\n\n \nstatic int bond_set_dev_addr(struct net_device *bond_dev,\n\t\t\t     struct net_device *slave_dev)\n{\n\tint err;\n\n\tslave_dbg(bond_dev, slave_dev, \"bond_dev=%p slave_dev=%p slave_dev->addr_len=%d\\n\",\n\t\t  bond_dev, slave_dev, slave_dev->addr_len);\n\terr = dev_pre_changeaddr_notify(bond_dev, slave_dev->dev_addr, NULL);\n\tif (err)\n\t\treturn err;\n\n\t__dev_addr_set(bond_dev, slave_dev->dev_addr, slave_dev->addr_len);\n\tbond_dev->addr_assign_type = NET_ADDR_STOLEN;\n\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, bond_dev);\n\treturn 0;\n}\n\nstatic struct slave *bond_get_old_active(struct bonding *bond,\n\t\t\t\t\t struct slave *new_active)\n{\n\tstruct slave *slave;\n\tstruct list_head *iter;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (slave == new_active)\n\t\t\tcontinue;\n\n\t\tif (ether_addr_equal(bond->dev->dev_addr, slave->dev->dev_addr))\n\t\t\treturn slave;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void bond_do_fail_over_mac(struct bonding *bond,\n\t\t\t\t  struct slave *new_active,\n\t\t\t\t  struct slave *old_active)\n{\n\tu8 tmp_mac[MAX_ADDR_LEN];\n\tstruct sockaddr_storage ss;\n\tint rv;\n\n\tswitch (bond->params.fail_over_mac) {\n\tcase BOND_FOM_ACTIVE:\n\t\tif (new_active) {\n\t\t\trv = bond_set_dev_addr(bond->dev, new_active->dev);\n\t\t\tif (rv)\n\t\t\t\tslave_err(bond->dev, new_active->dev, \"Error %d setting bond MAC from slave\\n\",\n\t\t\t\t\t  -rv);\n\t\t}\n\t\tbreak;\n\tcase BOND_FOM_FOLLOW:\n\t\t \n\t\tif (!new_active)\n\t\t\treturn;\n\n\t\tif (!old_active)\n\t\t\told_active = bond_get_old_active(bond, new_active);\n\n\t\tif (old_active) {\n\t\t\tbond_hw_addr_copy(tmp_mac, new_active->dev->dev_addr,\n\t\t\t\t\t  new_active->dev->addr_len);\n\t\t\tbond_hw_addr_copy(ss.__data,\n\t\t\t\t\t  old_active->dev->dev_addr,\n\t\t\t\t\t  old_active->dev->addr_len);\n\t\t\tss.ss_family = new_active->dev->type;\n\t\t} else {\n\t\t\tbond_hw_addr_copy(ss.__data, bond->dev->dev_addr,\n\t\t\t\t\t  bond->dev->addr_len);\n\t\t\tss.ss_family = bond->dev->type;\n\t\t}\n\n\t\trv = dev_set_mac_address(new_active->dev,\n\t\t\t\t\t (struct sockaddr *)&ss, NULL);\n\t\tif (rv) {\n\t\t\tslave_err(bond->dev, new_active->dev, \"Error %d setting MAC of new active slave\\n\",\n\t\t\t\t  -rv);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!old_active)\n\t\t\tgoto out;\n\n\t\tbond_hw_addr_copy(ss.__data, tmp_mac,\n\t\t\t\t  new_active->dev->addr_len);\n\t\tss.ss_family = old_active->dev->type;\n\n\t\trv = dev_set_mac_address(old_active->dev,\n\t\t\t\t\t (struct sockaddr *)&ss, NULL);\n\t\tif (rv)\n\t\t\tslave_err(bond->dev, old_active->dev, \"Error %d setting MAC of old active slave\\n\",\n\t\t\t\t  -rv);\nout:\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(bond->dev, \"bond_do_fail_over_mac impossible: bad policy %d\\n\",\n\t\t\t   bond->params.fail_over_mac);\n\t\tbreak;\n\t}\n\n}\n\n \nstatic struct slave *bond_choose_primary_or_current(struct bonding *bond)\n{\n\tstruct slave *prim = rtnl_dereference(bond->primary_slave);\n\tstruct slave *curr = rtnl_dereference(bond->curr_active_slave);\n\tstruct slave *slave, *hprio = NULL;\n\tstruct list_head *iter;\n\n\tif (!prim || prim->link != BOND_LINK_UP) {\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\t\thprio = hprio ?: slave;\n\t\t\t\tif (slave->prio > hprio->prio)\n\t\t\t\t\thprio = slave;\n\t\t\t}\n\t\t}\n\n\t\tif (hprio && hprio != curr) {\n\t\t\tprim = hprio;\n\t\t\tgoto link_reselect;\n\t\t}\n\n\t\tif (!curr || curr->link != BOND_LINK_UP)\n\t\t\treturn NULL;\n\t\treturn curr;\n\t}\n\n\tif (bond->force_primary) {\n\t\tbond->force_primary = false;\n\t\treturn prim;\n\t}\n\nlink_reselect:\n\tif (!curr || curr->link != BOND_LINK_UP)\n\t\treturn prim;\n\n\t \n\tswitch (bond->params.primary_reselect) {\n\tcase BOND_PRI_RESELECT_ALWAYS:\n\t\treturn prim;\n\tcase BOND_PRI_RESELECT_BETTER:\n\t\tif (prim->speed < curr->speed)\n\t\t\treturn curr;\n\t\tif (prim->speed == curr->speed && prim->duplex <= curr->duplex)\n\t\t\treturn curr;\n\t\treturn prim;\n\tcase BOND_PRI_RESELECT_FAILURE:\n\t\treturn curr;\n\tdefault:\n\t\tnetdev_err(bond->dev, \"impossible primary_reselect %d\\n\",\n\t\t\t   bond->params.primary_reselect);\n\t\treturn curr;\n\t}\n}\n\n \nstatic struct slave *bond_find_best_slave(struct bonding *bond)\n{\n\tstruct slave *slave, *bestslave = NULL;\n\tstruct list_head *iter;\n\tint mintime = bond->params.updelay;\n\n\tslave = bond_choose_primary_or_current(bond);\n\tif (slave)\n\t\treturn slave;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (slave->link == BOND_LINK_UP)\n\t\t\treturn slave;\n\t\tif (slave->link == BOND_LINK_BACK && bond_slave_is_up(slave) &&\n\t\t    slave->delay < mintime) {\n\t\t\tmintime = slave->delay;\n\t\t\tbestslave = slave;\n\t\t}\n\t}\n\n\treturn bestslave;\n}\n\nstatic bool bond_should_notify_peers(struct bonding *bond)\n{\n\tstruct slave *slave;\n\n\trcu_read_lock();\n\tslave = rcu_dereference(bond->curr_active_slave);\n\trcu_read_unlock();\n\n\tif (!slave || !bond->send_peer_notif ||\n\t    bond->send_peer_notif %\n\t    max(1, bond->params.peer_notif_delay) != 0 ||\n\t    !netif_carrier_ok(bond->dev) ||\n\t    test_bit(__LINK_STATE_LINKWATCH_PENDING, &slave->dev->state))\n\t\treturn false;\n\n\tnetdev_dbg(bond->dev, \"bond_should_notify_peers: slave %s\\n\",\n\t\t   slave ? slave->dev->name : \"NULL\");\n\n\treturn true;\n}\n\n \nvoid bond_change_active_slave(struct bonding *bond, struct slave *new_active)\n{\n\tstruct slave *old_active;\n\n\tASSERT_RTNL();\n\n\told_active = rtnl_dereference(bond->curr_active_slave);\n\n\tif (old_active == new_active)\n\t\treturn;\n\n#ifdef CONFIG_XFRM_OFFLOAD\n\tbond_ipsec_del_sa_all(bond);\n#endif  \n\n\tif (new_active) {\n\t\tnew_active->last_link_up = jiffies;\n\n\t\tif (new_active->link == BOND_LINK_BACK) {\n\t\t\tif (bond_uses_primary(bond)) {\n\t\t\t\tslave_info(bond->dev, new_active->dev, \"making interface the new active one %d ms earlier\\n\",\n\t\t\t\t\t   (bond->params.updelay - new_active->delay) * bond->params.miimon);\n\t\t\t}\n\n\t\t\tnew_active->delay = 0;\n\t\t\tbond_set_slave_link_state(new_active, BOND_LINK_UP,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\n\t\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(new_active, BOND_LINK_UP);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);\n\t\t} else {\n\t\t\tif (bond_uses_primary(bond))\n\t\t\t\tslave_info(bond->dev, new_active->dev, \"making interface the new active one\\n\");\n\t\t}\n\t}\n\n\tif (bond_uses_primary(bond))\n\t\tbond_hw_addr_swap(bond, new_active, old_active);\n\n\tif (bond_is_lb(bond)) {\n\t\tbond_alb_handle_active_change(bond, new_active);\n\t\tif (old_active)\n\t\t\tbond_set_slave_inactive_flags(old_active,\n\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\t\tif (new_active)\n\t\t\tbond_set_slave_active_flags(new_active,\n\t\t\t\t\t\t    BOND_SLAVE_NOTIFY_NOW);\n\t} else {\n\t\trcu_assign_pointer(bond->curr_active_slave, new_active);\n\t}\n\n\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP) {\n\t\tif (old_active)\n\t\t\tbond_set_slave_inactive_flags(old_active,\n\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\n\t\tif (new_active) {\n\t\t\tbool should_notify_peers = false;\n\n\t\t\tbond_set_slave_active_flags(new_active,\n\t\t\t\t\t\t    BOND_SLAVE_NOTIFY_NOW);\n\n\t\t\tif (bond->params.fail_over_mac)\n\t\t\t\tbond_do_fail_over_mac(bond, new_active,\n\t\t\t\t\t\t      old_active);\n\n\t\t\tif (netif_running(bond->dev)) {\n\t\t\t\tbond->send_peer_notif =\n\t\t\t\t\tbond->params.num_peer_notif *\n\t\t\t\t\tmax(1, bond->params.peer_notif_delay);\n\t\t\t\tshould_notify_peers =\n\t\t\t\t\tbond_should_notify_peers(bond);\n\t\t\t}\n\n\t\t\tcall_netdevice_notifiers(NETDEV_BONDING_FAILOVER, bond->dev);\n\t\t\tif (should_notify_peers) {\n\t\t\t\tbond->send_peer_notif--;\n\t\t\t\tcall_netdevice_notifiers(NETDEV_NOTIFY_PEERS,\n\t\t\t\t\t\t\t bond->dev);\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_XFRM_OFFLOAD\n\tbond_ipsec_add_sa_all(bond);\n#endif  \n\n\t \n\tif (netif_running(bond->dev) && (bond->params.resend_igmp > 0) &&\n\t    ((bond_uses_primary(bond) && new_active) ||\n\t     BOND_MODE(bond) == BOND_MODE_ROUNDROBIN)) {\n\t\tbond->igmp_retrans = bond->params.resend_igmp;\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, 1);\n\t}\n}\n\n \nvoid bond_select_active_slave(struct bonding *bond)\n{\n\tstruct slave *best_slave;\n\tint rv;\n\n\tASSERT_RTNL();\n\n\tbest_slave = bond_find_best_slave(bond);\n\tif (best_slave != rtnl_dereference(bond->curr_active_slave)) {\n\t\tbond_change_active_slave(bond, best_slave);\n\t\trv = bond_set_carrier(bond);\n\t\tif (!rv)\n\t\t\treturn;\n\n\t\tif (netif_carrier_ok(bond->dev))\n\t\t\tnetdev_info(bond->dev, \"active interface up!\\n\");\n\t\telse\n\t\t\tnetdev_info(bond->dev, \"now running without any active interface!\\n\");\n\t}\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic inline int slave_enable_netpoll(struct slave *slave)\n{\n\tstruct netpoll *np;\n\tint err = 0;\n\n\tnp = kzalloc(sizeof(*np), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!np)\n\t\tgoto out;\n\n\terr = __netpoll_setup(np, slave->dev);\n\tif (err) {\n\t\tkfree(np);\n\t\tgoto out;\n\t}\n\tslave->np = np;\nout:\n\treturn err;\n}\nstatic inline void slave_disable_netpoll(struct slave *slave)\n{\n\tstruct netpoll *np = slave->np;\n\n\tif (!np)\n\t\treturn;\n\n\tslave->np = NULL;\n\n\t__netpoll_free(np);\n}\n\nstatic void bond_poll_controller(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave = NULL;\n\tstruct list_head *iter;\n\tstruct ad_info ad_info;\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\tif (bond_3ad_get_active_agg_info(bond, &ad_info))\n\t\t\treturn;\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (!bond_slave_is_up(slave))\n\t\t\tcontinue;\n\n\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\t\tstruct aggregator *agg =\n\t\t\t    SLAVE_AD_INFO(slave)->port.aggregator;\n\n\t\t\tif (agg &&\n\t\t\t    agg->aggregator_identifier != ad_info.aggregator_id)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tnetpoll_poll_dev(slave->dev);\n\t}\n}\n\nstatic void bond_netpoll_cleanup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tbond_for_each_slave(bond, slave, iter)\n\t\tif (bond_slave_is_up(slave))\n\t\t\tslave_disable_netpoll(slave);\n}\n\nstatic int bond_netpoll_setup(struct net_device *dev, struct netpoll_info *ni)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint err = 0;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\terr = slave_enable_netpoll(slave);\n\t\tif (err) {\n\t\t\tbond_netpoll_cleanup(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n#else\nstatic inline int slave_enable_netpoll(struct slave *slave)\n{\n\treturn 0;\n}\nstatic inline void slave_disable_netpoll(struct slave *slave)\n{\n}\nstatic void bond_netpoll_cleanup(struct net_device *bond_dev)\n{\n}\n#endif\n\n \n\nstatic netdev_features_t bond_fix_features(struct net_device *dev,\n\t\t\t\t\t   netdev_features_t features)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct list_head *iter;\n\tnetdev_features_t mask;\n\tstruct slave *slave;\n\n\tmask = features;\n\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\tfeatures |= NETIF_F_ALL_FOR_ALL;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     slave->dev->features,\n\t\t\t\t\t\t     mask);\n\t}\n\tfeatures = netdev_add_tso_features(features, mask);\n\n\treturn features;\n}\n\n#define BOND_VLAN_FEATURES\t(NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t\t NETIF_F_FRAGLIST | NETIF_F_GSO_SOFTWARE | \\\n\t\t\t\t NETIF_F_HIGHDMA | NETIF_F_LRO)\n\n#define BOND_ENC_FEATURES\t(NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t\t NETIF_F_RXCSUM | NETIF_F_GSO_SOFTWARE)\n\n#define BOND_MPLS_FEATURES\t(NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t\t NETIF_F_GSO_SOFTWARE)\n\n\nstatic void bond_compute_features(struct bonding *bond)\n{\n\tunsigned int dst_release_flag = IFF_XMIT_DST_RELEASE |\n\t\t\t\t\tIFF_XMIT_DST_RELEASE_PERM;\n\tnetdev_features_t vlan_features = BOND_VLAN_FEATURES;\n\tnetdev_features_t enc_features  = BOND_ENC_FEATURES;\n#ifdef CONFIG_XFRM_OFFLOAD\n\tnetdev_features_t xfrm_features  = BOND_XFRM_FEATURES;\n#endif  \n\tnetdev_features_t mpls_features  = BOND_MPLS_FEATURES;\n\tstruct net_device *bond_dev = bond->dev;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tunsigned short max_hard_header_len = ETH_HLEN;\n\tunsigned int tso_max_size = TSO_MAX_SIZE;\n\tu16 tso_max_segs = TSO_MAX_SEGS;\n\n\tif (!bond_has_slaves(bond))\n\t\tgoto done;\n\tvlan_features &= NETIF_F_ALL_FOR_ALL;\n\tmpls_features &= NETIF_F_ALL_FOR_ALL;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tvlan_features = netdev_increment_features(vlan_features,\n\t\t\tslave->dev->vlan_features, BOND_VLAN_FEATURES);\n\n\t\tenc_features = netdev_increment_features(enc_features,\n\t\t\t\t\t\t\t slave->dev->hw_enc_features,\n\t\t\t\t\t\t\t BOND_ENC_FEATURES);\n\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\txfrm_features = netdev_increment_features(xfrm_features,\n\t\t\t\t\t\t\t  slave->dev->hw_enc_features,\n\t\t\t\t\t\t\t  BOND_XFRM_FEATURES);\n#endif  \n\n\t\tmpls_features = netdev_increment_features(mpls_features,\n\t\t\t\t\t\t\t  slave->dev->mpls_features,\n\t\t\t\t\t\t\t  BOND_MPLS_FEATURES);\n\n\t\tdst_release_flag &= slave->dev->priv_flags;\n\t\tif (slave->dev->hard_header_len > max_hard_header_len)\n\t\t\tmax_hard_header_len = slave->dev->hard_header_len;\n\n\t\ttso_max_size = min(tso_max_size, slave->dev->tso_max_size);\n\t\ttso_max_segs = min(tso_max_segs, slave->dev->tso_max_segs);\n\t}\n\tbond_dev->hard_header_len = max_hard_header_len;\n\ndone:\n\tbond_dev->vlan_features = vlan_features;\n\tbond_dev->hw_enc_features = enc_features | NETIF_F_GSO_ENCAP_ALL |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t    NETIF_F_HW_VLAN_STAG_TX;\n#ifdef CONFIG_XFRM_OFFLOAD\n\tbond_dev->hw_enc_features |= xfrm_features;\n#endif  \n\tbond_dev->mpls_features = mpls_features;\n\tnetif_set_tso_max_segs(bond_dev, tso_max_segs);\n\tnetif_set_tso_max_size(bond_dev, tso_max_size);\n\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tif ((bond_dev->priv_flags & IFF_XMIT_DST_RELEASE_PERM) &&\n\t    dst_release_flag == (IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM))\n\t\tbond_dev->priv_flags |= IFF_XMIT_DST_RELEASE;\n\n\tnetdev_change_features(bond_dev);\n}\n\nstatic void bond_setup_by_slave(struct net_device *bond_dev,\n\t\t\t\tstruct net_device *slave_dev)\n{\n\tbool was_up = !!(bond_dev->flags & IFF_UP);\n\n\tdev_close(bond_dev);\n\n\tbond_dev->header_ops\t    = slave_dev->header_ops;\n\n\tbond_dev->type\t\t    = slave_dev->type;\n\tbond_dev->hard_header_len   = slave_dev->hard_header_len;\n\tbond_dev->needed_headroom   = slave_dev->needed_headroom;\n\tbond_dev->addr_len\t    = slave_dev->addr_len;\n\n\tmemcpy(bond_dev->broadcast, slave_dev->broadcast,\n\t\tslave_dev->addr_len);\n\n\tif (slave_dev->flags & IFF_POINTOPOINT) {\n\t\tbond_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);\n\t\tbond_dev->flags |= (IFF_POINTOPOINT | IFF_NOARP);\n\t}\n\tif (was_up)\n\t\tdev_open(bond_dev, NULL);\n}\n\n \nstatic bool bond_should_deliver_exact_match(struct sk_buff *skb,\n\t\t\t\t\t    struct slave *slave,\n\t\t\t\t\t    struct bonding *bond)\n{\n\tif (bond_is_slave_inactive(slave)) {\n\t\tif (BOND_MODE(bond) == BOND_MODE_ALB &&\n\t\t    skb->pkt_type != PACKET_BROADCAST &&\n\t\t    skb->pkt_type != PACKET_MULTICAST)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic rx_handler_result_t bond_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct slave *slave;\n\tstruct bonding *bond;\n\tint (*recv_probe)(const struct sk_buff *, struct bonding *,\n\t\t\t  struct slave *);\n\tint ret = RX_HANDLER_ANOTHER;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn RX_HANDLER_CONSUMED;\n\n\t*pskb = skb;\n\n\tslave = bond_slave_get_rcu(skb->dev);\n\tbond = slave->bond;\n\n\trecv_probe = READ_ONCE(bond->recv_probe);\n\tif (recv_probe) {\n\t\tret = recv_probe(skb, bond, slave);\n\t\tif (ret == RX_HANDLER_CONSUMED) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (bond_should_deliver_exact_match(skb, slave, bond)) {\n\t\tif (is_link_local_ether_addr(eth_hdr(skb)->h_dest))\n\t\t\treturn RX_HANDLER_PASS;\n\t\treturn RX_HANDLER_EXACT;\n\t}\n\n\tskb->dev = bond->dev;\n\n\tif (BOND_MODE(bond) == BOND_MODE_ALB &&\n\t    netif_is_bridge_port(bond->dev) &&\n\t    skb->pkt_type == PACKET_HOST) {\n\n\t\tif (unlikely(skb_cow_head(skb,\n\t\t\t\t\t  skb->data - skb_mac_header(skb)))) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t\tbond_hw_addr_copy(eth_hdr(skb)->h_dest, bond->dev->dev_addr,\n\t\t\t\t  bond->dev->addr_len);\n\t}\n\n\treturn ret;\n}\n\nstatic enum netdev_lag_tx_type bond_lag_tx_type(struct bonding *bond)\n{\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\treturn NETDEV_LAG_TX_TYPE_ROUNDROBIN;\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\treturn NETDEV_LAG_TX_TYPE_ACTIVEBACKUP;\n\tcase BOND_MODE_BROADCAST:\n\t\treturn NETDEV_LAG_TX_TYPE_BROADCAST;\n\tcase BOND_MODE_XOR:\n\tcase BOND_MODE_8023AD:\n\t\treturn NETDEV_LAG_TX_TYPE_HASH;\n\tdefault:\n\t\treturn NETDEV_LAG_TX_TYPE_UNKNOWN;\n\t}\n}\n\nstatic enum netdev_lag_hash bond_lag_hash_type(struct bonding *bond,\n\t\t\t\t\t       enum netdev_lag_tx_type type)\n{\n\tif (type != NETDEV_LAG_TX_TYPE_HASH)\n\t\treturn NETDEV_LAG_HASH_NONE;\n\n\tswitch (bond->params.xmit_policy) {\n\tcase BOND_XMIT_POLICY_LAYER2:\n\t\treturn NETDEV_LAG_HASH_L2;\n\tcase BOND_XMIT_POLICY_LAYER34:\n\t\treturn NETDEV_LAG_HASH_L34;\n\tcase BOND_XMIT_POLICY_LAYER23:\n\t\treturn NETDEV_LAG_HASH_L23;\n\tcase BOND_XMIT_POLICY_ENCAP23:\n\t\treturn NETDEV_LAG_HASH_E23;\n\tcase BOND_XMIT_POLICY_ENCAP34:\n\t\treturn NETDEV_LAG_HASH_E34;\n\tcase BOND_XMIT_POLICY_VLAN_SRCMAC:\n\t\treturn NETDEV_LAG_HASH_VLAN_SRCMAC;\n\tdefault:\n\t\treturn NETDEV_LAG_HASH_UNKNOWN;\n\t}\n}\n\nstatic int bond_master_upper_dev_link(struct bonding *bond, struct slave *slave,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct netdev_lag_upper_info lag_upper_info;\n\tenum netdev_lag_tx_type type;\n\tint err;\n\n\ttype = bond_lag_tx_type(bond);\n\tlag_upper_info.tx_type = type;\n\tlag_upper_info.hash_type = bond_lag_hash_type(bond, type);\n\n\terr = netdev_master_upper_dev_link(slave->dev, bond->dev, slave,\n\t\t\t\t\t   &lag_upper_info, extack);\n\tif (err)\n\t\treturn err;\n\n\tslave->dev->flags |= IFF_SLAVE;\n\treturn 0;\n}\n\nstatic void bond_upper_dev_unlink(struct bonding *bond, struct slave *slave)\n{\n\tnetdev_upper_dev_unlink(slave->dev, bond->dev);\n\tslave->dev->flags &= ~IFF_SLAVE;\n}\n\nstatic void slave_kobj_release(struct kobject *kobj)\n{\n\tstruct slave *slave = to_slave(kobj);\n\tstruct bonding *bond = bond_get_bond_by_slave(slave);\n\n\tcancel_delayed_work_sync(&slave->notify_work);\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\tkfree(SLAVE_AD_INFO(slave));\n\n\tkfree(slave);\n}\n\nstatic struct kobj_type slave_ktype = {\n\t.release = slave_kobj_release,\n#ifdef CONFIG_SYSFS\n\t.sysfs_ops = &slave_sysfs_ops,\n#endif\n};\n\nstatic int bond_kobj_init(struct slave *slave)\n{\n\tint err;\n\n\terr = kobject_init_and_add(&slave->kobj, &slave_ktype,\n\t\t\t\t   &(slave->dev->dev.kobj), \"bonding_slave\");\n\tif (err)\n\t\tkobject_put(&slave->kobj);\n\n\treturn err;\n}\n\nstatic struct slave *bond_alloc_slave(struct bonding *bond,\n\t\t\t\t      struct net_device *slave_dev)\n{\n\tstruct slave *slave = NULL;\n\n\tslave = kzalloc(sizeof(*slave), GFP_KERNEL);\n\tif (!slave)\n\t\treturn NULL;\n\n\tslave->bond = bond;\n\tslave->dev = slave_dev;\n\tINIT_DELAYED_WORK(&slave->notify_work, bond_netdev_notify_work);\n\n\tif (bond_kobj_init(slave))\n\t\treturn NULL;\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tSLAVE_AD_INFO(slave) = kzalloc(sizeof(struct ad_slave_info),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!SLAVE_AD_INFO(slave)) {\n\t\t\tkobject_put(&slave->kobj);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn slave;\n}\n\nstatic void bond_fill_ifbond(struct bonding *bond, struct ifbond *info)\n{\n\tinfo->bond_mode = BOND_MODE(bond);\n\tinfo->miimon = bond->params.miimon;\n\tinfo->num_slaves = bond->slave_cnt;\n}\n\nstatic void bond_fill_ifslave(struct slave *slave, struct ifslave *info)\n{\n\tstrcpy(info->slave_name, slave->dev->name);\n\tinfo->link = slave->link;\n\tinfo->state = bond_slave_state(slave);\n\tinfo->link_failure_count = slave->link_failure_count;\n}\n\nstatic void bond_netdev_notify_work(struct work_struct *_work)\n{\n\tstruct slave *slave = container_of(_work, struct slave,\n\t\t\t\t\t   notify_work.work);\n\n\tif (rtnl_trylock()) {\n\t\tstruct netdev_bonding_info binfo;\n\n\t\tbond_fill_ifslave(slave, &binfo.slave);\n\t\tbond_fill_ifbond(slave->bond, &binfo.master);\n\t\tnetdev_bonding_info_change(slave->dev, &binfo);\n\t\trtnl_unlock();\n\t} else {\n\t\tqueue_delayed_work(slave->bond->wq, &slave->notify_work, 1);\n\t}\n}\n\nvoid bond_queue_slave_event(struct slave *slave)\n{\n\tqueue_delayed_work(slave->bond->wq, &slave->notify_work, 0);\n}\n\nvoid bond_lower_state_changed(struct slave *slave)\n{\n\tstruct netdev_lag_lower_state_info info;\n\n\tinfo.link_up = slave->link == BOND_LINK_UP ||\n\t\t       slave->link == BOND_LINK_FAIL;\n\tinfo.tx_enabled = bond_is_active_slave(slave);\n\tnetdev_lower_state_changed(slave->dev, &info);\n}\n\n#define BOND_NL_ERR(bond_dev, extack, errmsg) do {\t\t\\\n\tif (extack)\t\t\t\t\t\t\\\n\t\tNL_SET_ERR_MSG(extack, errmsg);\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\tnetdev_err(bond_dev, \"Error: %s\\n\", errmsg);\t\\\n} while (0)\n\n#define SLAVE_NL_ERR(bond_dev, slave_dev, extack, errmsg) do {\t\t\\\n\tif (extack)\t\t\t\t\t\t\t\\\n\t\tNL_SET_ERR_MSG(extack, errmsg);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tslave_err(bond_dev, slave_dev, \"Error: %s\\n\", errmsg);\t\\\n} while (0)\n\n \nstatic void bond_ether_setup(struct net_device *bond_dev)\n{\n\tunsigned int flags = bond_dev->flags & (IFF_SLAVE | IFF_UP);\n\n\tether_setup(bond_dev);\n\tbond_dev->flags |= IFF_MASTER | flags;\n\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n}\n\nvoid bond_xdp_set_features(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\txdp_features_t val = NETDEV_XDP_ACT_MASK;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tASSERT_RTNL();\n\n\tif (!bond_xdp_check(bond)) {\n\t\txdp_clear_features_flag(bond_dev);\n\t\treturn;\n\t}\n\n\tbond_for_each_slave(bond, slave, iter)\n\t\tval &= slave->dev->xdp_features;\n\n\txdp_set_features_flag(bond_dev, val);\n}\n\n \nint bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev,\n\t\t struct netlink_ext_ack *extack)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tstruct slave *new_slave = NULL, *prev_slave;\n\tstruct sockaddr_storage ss;\n\tint link_reporting;\n\tint res = 0, i;\n\n\tif (slave_dev->flags & IFF_MASTER &&\n\t    !netif_is_bond_master(slave_dev)) {\n\t\tBOND_NL_ERR(bond_dev, extack,\n\t\t\t    \"Device type (master device) cannot be enslaved\");\n\t\treturn -EPERM;\n\t}\n\n\tif (!bond->params.use_carrier &&\n\t    slave_dev->ethtool_ops->get_link == NULL &&\n\t    slave_ops->ndo_eth_ioctl == NULL) {\n\t\tslave_warn(bond_dev, slave_dev, \"no link monitoring support\\n\");\n\t}\n\n\t \n\tif (netdev_is_rx_handler_busy(slave_dev)) {\n\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t     \"Device is in use and cannot be enslaved\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (bond_dev == slave_dev) {\n\t\tBOND_NL_ERR(bond_dev, extack, \"Cannot enslave bond to itself.\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\t \n\tif (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {\n\t\tslave_dbg(bond_dev, slave_dev, \"is NETIF_F_VLAN_CHALLENGED\\n\");\n\t\tif (vlan_uses_dev(bond_dev)) {\n\t\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t\t     \"Can not enslave VLAN challenged device to VLAN enabled bond\");\n\t\t\treturn -EPERM;\n\t\t} else {\n\t\t\tslave_warn(bond_dev, slave_dev, \"enslaved VLAN challenged slave. Adding VLANs will be blocked as long as it is part of bond.\\n\");\n\t\t}\n\t} else {\n\t\tslave_dbg(bond_dev, slave_dev, \"is !NETIF_F_VLAN_CHALLENGED\\n\");\n\t}\n\n\tif (slave_dev->features & NETIF_F_HW_ESP)\n\t\tslave_dbg(bond_dev, slave_dev, \"is esp-hw-offload capable\\n\");\n\n\t \n\tif (slave_dev->flags & IFF_UP) {\n\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t     \"Device can not be enslaved while up\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (!bond_has_slaves(bond)) {\n\t\tif (bond_dev->type != slave_dev->type) {\n\t\t\tslave_dbg(bond_dev, slave_dev, \"change device type from %d to %d\\n\",\n\t\t\t\t  bond_dev->type, slave_dev->type);\n\n\t\t\tres = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE,\n\t\t\t\t\t\t       bond_dev);\n\t\t\tres = notifier_to_errno(res);\n\t\t\tif (res) {\n\t\t\t\tslave_err(bond_dev, slave_dev, \"refused to change device type\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\t \n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tbond_ether_setup(bond_dev);\n\n\t\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE,\n\t\t\t\t\t\t bond_dev);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t     \"Device type is different from other slaves\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (slave_dev->type == ARPHRD_INFINIBAND &&\n\t    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t     \"Only active-backup mode is supported for infiniband slaves\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto err_undo_flags;\n\t}\n\n\tif (!slave_ops->ndo_set_mac_address ||\n\t    slave_dev->type == ARPHRD_INFINIBAND) {\n\t\tslave_warn(bond_dev, slave_dev, \"The slave device specified does not support setting the MAC address\\n\");\n\t\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP &&\n\t\t    bond->params.fail_over_mac != BOND_FOM_ACTIVE) {\n\t\t\tif (!bond_has_slaves(bond)) {\n\t\t\t\tbond->params.fail_over_mac = BOND_FOM_ACTIVE;\n\t\t\t\tslave_warn(bond_dev, slave_dev, \"Setting fail_over_mac to active for active-backup mode\\n\");\n\t\t\t} else {\n\t\t\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t\t\t     \"Slave device does not support setting the MAC address, but fail_over_mac is not set to active\");\n\t\t\t\tres = -EOPNOTSUPP;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\t\t}\n\t}\n\n\tcall_netdevice_notifiers(NETDEV_JOIN, slave_dev);\n\n\t \n\tif (!bond_has_slaves(bond) &&\n\t    bond->dev->addr_assign_type == NET_ADDR_RANDOM) {\n\t\tres = bond_set_dev_addr(bond->dev, slave_dev);\n\t\tif (res)\n\t\t\tgoto err_undo_flags;\n\t}\n\n\tnew_slave = bond_alloc_slave(bond, slave_dev);\n\tif (!new_slave) {\n\t\tres = -ENOMEM;\n\t\tgoto err_undo_flags;\n\t}\n\n\t \n\tnew_slave->queue_id = 0;\n\n\t \n\tnew_slave->original_mtu = slave_dev->mtu;\n\tres = dev_set_mtu(slave_dev, bond->dev->mtu);\n\tif (res) {\n\t\tslave_err(bond_dev, slave_dev, \"Error %d calling dev_set_mtu\\n\", res);\n\t\tgoto err_free;\n\t}\n\n\t \n\tbond_hw_addr_copy(new_slave->perm_hwaddr, slave_dev->dev_addr,\n\t\t\t  slave_dev->addr_len);\n\n\tif (!bond->params.fail_over_mac ||\n\t    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\t \n\t\tmemcpy(ss.__data, bond_dev->dev_addr, bond_dev->addr_len);\n\t\tss.ss_family = slave_dev->type;\n\t\tres = dev_set_mac_address(slave_dev, (struct sockaddr *)&ss,\n\t\t\t\t\t  extack);\n\t\tif (res) {\n\t\t\tslave_err(bond_dev, slave_dev, \"Error %d calling set_mac_address\\n\", res);\n\t\t\tgoto err_restore_mtu;\n\t\t}\n\t}\n\n\t \n\tslave_dev->priv_flags |= IFF_NO_ADDRCONF;\n\n\t \n\tres = dev_open(slave_dev, extack);\n\tif (res) {\n\t\tslave_err(bond_dev, slave_dev, \"Opening slave failed\\n\");\n\t\tgoto err_restore_mac;\n\t}\n\n\tslave_dev->priv_flags |= IFF_BONDING;\n\t \n\tdev_get_stats(new_slave->dev, &new_slave->slave_stats);\n\n\tif (bond_is_lb(bond)) {\n\t\t \n\t\tres = bond_alb_init_slave(bond, new_slave);\n\t\tif (res)\n\t\t\tgoto err_close;\n\t}\n\n\tres = vlan_vids_add_by_dev(slave_dev, bond_dev);\n\tif (res) {\n\t\tslave_err(bond_dev, slave_dev, \"Couldn't add bond vlan ids\\n\");\n\t\tgoto err_close;\n\t}\n\n\tprev_slave = bond_last_slave(bond);\n\n\tnew_slave->delay = 0;\n\tnew_slave->link_failure_count = 0;\n\n\tif (bond_update_speed_duplex(new_slave) &&\n\t    bond_needs_speed_duplex(bond))\n\t\tnew_slave->link = BOND_LINK_DOWN;\n\n\tnew_slave->last_rx = jiffies -\n\t\t(msecs_to_jiffies(bond->params.arp_interval) + 1);\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++)\n\t\tnew_slave->target_last_arp_rx[i] = new_slave->last_rx;\n\n\tnew_slave->last_tx = new_slave->last_rx;\n\n\tif (bond->params.miimon && !bond->params.use_carrier) {\n\t\tlink_reporting = bond_check_dev_link(bond, slave_dev, 1);\n\n\t\tif ((link_reporting == -1) && !bond->params.arp_interval) {\n\t\t\t \n\t\t\tslave_warn(bond_dev, slave_dev, \"MII and ETHTOOL support not available for slave, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details\\n\");\n\t\t} else if (link_reporting == -1) {\n\t\t\t \n\t\t\tslave_warn(bond_dev, slave_dev, \"can't get link status from slave; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface\\n\");\n\t\t}\n\t}\n\n\t \n\tnew_slave->link = BOND_LINK_NOCHANGE;\n\tif (bond->params.miimon) {\n\t\tif (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS) {\n\t\t\tif (bond->params.updelay) {\n\t\t\t\tbond_set_slave_link_state(new_slave,\n\t\t\t\t\t\t\t  BOND_LINK_BACK,\n\t\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\t\tnew_slave->delay = bond->params.updelay;\n\t\t\t} else {\n\t\t\t\tbond_set_slave_link_state(new_slave,\n\t\t\t\t\t\t\t  BOND_LINK_UP,\n\t\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\t}\n\t\t} else {\n\t\t\tbond_set_slave_link_state(new_slave, BOND_LINK_DOWN,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t}\n\t} else if (bond->params.arp_interval) {\n\t\tbond_set_slave_link_state(new_slave,\n\t\t\t\t\t  (netif_carrier_ok(slave_dev) ?\n\t\t\t\t\t  BOND_LINK_UP : BOND_LINK_DOWN),\n\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t} else {\n\t\tbond_set_slave_link_state(new_slave, BOND_LINK_UP,\n\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t}\n\n\tif (new_slave->link != BOND_LINK_DOWN)\n\t\tnew_slave->last_link_up = jiffies;\n\tslave_dbg(bond_dev, slave_dev, \"Initial state of slave is BOND_LINK_%s\\n\",\n\t\t  new_slave->link == BOND_LINK_DOWN ? \"DOWN\" :\n\t\t  (new_slave->link == BOND_LINK_UP ? \"UP\" : \"BACK\"));\n\n\tif (bond_uses_primary(bond) && bond->params.primary[0]) {\n\t\t \n\t\tif (strcmp(bond->params.primary, new_slave->dev->name) == 0) {\n\t\t\trcu_assign_pointer(bond->primary_slave, new_slave);\n\t\t\tbond->force_primary = true;\n\t\t}\n\t}\n\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tbond_set_slave_inactive_flags(new_slave,\n\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\t\tbreak;\n\tcase BOND_MODE_8023AD:\n\t\t \n\t\tbond_set_slave_inactive_flags(new_slave, BOND_SLAVE_NOTIFY_NOW);\n\t\t \n\t\tif (!prev_slave) {\n\t\t\tSLAVE_AD_INFO(new_slave)->id = 1;\n\t\t\t \n\t\t\tbond_3ad_initialize(bond);\n\t\t} else {\n\t\t\tSLAVE_AD_INFO(new_slave)->id =\n\t\t\t\tSLAVE_AD_INFO(prev_slave)->id + 1;\n\t\t}\n\n\t\tbond_3ad_bind_slave(new_slave);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\tcase BOND_MODE_ALB:\n\t\tbond_set_active_slave(new_slave);\n\t\tbond_set_slave_inactive_flags(new_slave, BOND_SLAVE_NOTIFY_NOW);\n\t\tbreak;\n\tdefault:\n\t\tslave_dbg(bond_dev, slave_dev, \"This slave is always active in trunk mode\\n\");\n\n\t\t \n\t\tbond_set_active_slave(new_slave);\n\n\t\t \n\t\tif (!rcu_access_pointer(bond->curr_active_slave) &&\n\t\t    new_slave->link == BOND_LINK_UP)\n\t\t\trcu_assign_pointer(bond->curr_active_slave, new_slave);\n\n\t\tbreak;\n\t}  \n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tif (bond->dev->npinfo) {\n\t\tif (slave_enable_netpoll(new_slave)) {\n\t\t\tslave_info(bond_dev, slave_dev, \"master_dev is using netpoll, but new slave device does not support netpoll\\n\");\n\t\t\tres = -EBUSY;\n\t\t\tgoto err_detach;\n\t\t}\n\t}\n#endif\n\n\tif (!(bond_dev->features & NETIF_F_LRO))\n\t\tdev_disable_lro(slave_dev);\n\n\tres = netdev_rx_handler_register(slave_dev, bond_handle_frame,\n\t\t\t\t\t new_slave);\n\tif (res) {\n\t\tslave_dbg(bond_dev, slave_dev, \"Error %d calling netdev_rx_handler_register\\n\", res);\n\t\tgoto err_detach;\n\t}\n\n\tres = bond_master_upper_dev_link(bond, new_slave, extack);\n\tif (res) {\n\t\tslave_dbg(bond_dev, slave_dev, \"Error %d calling bond_master_upper_dev_link\\n\", res);\n\t\tgoto err_unregister;\n\t}\n\n\tbond_lower_state_changed(new_slave);\n\n\tres = bond_sysfs_slave_add(new_slave);\n\tif (res) {\n\t\tslave_dbg(bond_dev, slave_dev, \"Error %d calling bond_sysfs_slave_add\\n\", res);\n\t\tgoto err_upper_unlink;\n\t}\n\n\t \n\tif (!bond_uses_primary(bond)) {\n\t\t \n\t\tif (bond_dev->flags & IFF_PROMISC) {\n\t\t\tres = dev_set_promiscuity(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_sysfs_del;\n\t\t}\n\n\t\t \n\t\tif (bond_dev->flags & IFF_ALLMULTI) {\n\t\t\tres = dev_set_allmulti(slave_dev, 1);\n\t\t\tif (res) {\n\t\t\t\tif (bond_dev->flags & IFF_PROMISC)\n\t\t\t\t\tdev_set_promiscuity(slave_dev, -1);\n\t\t\t\tgoto err_sysfs_del;\n\t\t\t}\n\t\t}\n\n\t\tif (bond_dev->flags & IFF_UP) {\n\t\t\tnetif_addr_lock_bh(bond_dev);\n\t\t\tdev_mc_sync_multiple(slave_dev, bond_dev);\n\t\t\tdev_uc_sync_multiple(slave_dev, bond_dev);\n\t\t\tnetif_addr_unlock_bh(bond_dev);\n\n\t\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\t\t\tdev_mc_add(slave_dev, lacpdu_mcast_addr);\n\t\t}\n\t}\n\n\tbond->slave_cnt++;\n\tbond_compute_features(bond);\n\tbond_set_carrier(bond);\n\n\tif (bond_uses_primary(bond)) {\n\t\tblock_netpoll_tx();\n\t\tbond_select_active_slave(bond);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tif (bond_mode_can_use_xmit_hash(bond))\n\t\tbond_update_slave_arr(bond, NULL);\n\n\n\tif (!slave_dev->netdev_ops->ndo_bpf ||\n\t    !slave_dev->netdev_ops->ndo_xdp_xmit) {\n\t\tif (bond->xdp_prog) {\n\t\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t\t     \"Slave does not support XDP\");\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto err_sysfs_del;\n\t\t}\n\t} else if (bond->xdp_prog) {\n\t\tstruct netdev_bpf xdp = {\n\t\t\t.command = XDP_SETUP_PROG,\n\t\t\t.flags   = 0,\n\t\t\t.prog    = bond->xdp_prog,\n\t\t\t.extack  = extack,\n\t\t};\n\n\t\tif (dev_xdp_prog_count(slave_dev) > 0) {\n\t\t\tSLAVE_NL_ERR(bond_dev, slave_dev, extack,\n\t\t\t\t     \"Slave has XDP program loaded, please unload before enslaving\");\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto err_sysfs_del;\n\t\t}\n\n\t\tres = slave_dev->netdev_ops->ndo_bpf(slave_dev, &xdp);\n\t\tif (res < 0) {\n\t\t\t \n\t\t\tslave_dbg(bond_dev, slave_dev, \"Error %d calling ndo_bpf\\n\", res);\n\t\t\tgoto err_sysfs_del;\n\t\t}\n\t\tif (bond->xdp_prog)\n\t\t\tbpf_prog_inc(bond->xdp_prog);\n\t}\n\n\tbond_xdp_set_features(bond_dev);\n\n\tslave_info(bond_dev, slave_dev, \"Enslaving as %s interface with %s link\\n\",\n\t\t   bond_is_active_slave(new_slave) ? \"an active\" : \"a backup\",\n\t\t   new_slave->link != BOND_LINK_DOWN ? \"an up\" : \"a down\");\n\n\t \n\tbond_queue_slave_event(new_slave);\n\treturn 0;\n\n \nerr_sysfs_del:\n\tbond_sysfs_slave_del(new_slave);\n\nerr_upper_unlink:\n\tbond_upper_dev_unlink(bond, new_slave);\n\nerr_unregister:\n\tnetdev_rx_handler_unregister(slave_dev);\n\nerr_detach:\n\tvlan_vids_del_by_dev(slave_dev, bond_dev);\n\tif (rcu_access_pointer(bond->primary_slave) == new_slave)\n\t\tRCU_INIT_POINTER(bond->primary_slave, NULL);\n\tif (rcu_access_pointer(bond->curr_active_slave) == new_slave) {\n\t\tblock_netpoll_tx();\n\t\tbond_change_active_slave(bond, NULL);\n\t\tbond_select_active_slave(bond);\n\t\tunblock_netpoll_tx();\n\t}\n\t \n\tsynchronize_rcu();\n\tslave_disable_netpoll(new_slave);\n\nerr_close:\n\tif (!netif_is_bond_master(slave_dev))\n\t\tslave_dev->priv_flags &= ~IFF_BONDING;\n\tdev_close(slave_dev);\n\nerr_restore_mac:\n\tslave_dev->priv_flags &= ~IFF_NO_ADDRCONF;\n\tif (!bond->params.fail_over_mac ||\n\t    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\t \n\t\tbond_hw_addr_copy(ss.__data, new_slave->perm_hwaddr,\n\t\t\t\t  new_slave->dev->addr_len);\n\t\tss.ss_family = slave_dev->type;\n\t\tdev_set_mac_address(slave_dev, (struct sockaddr *)&ss, NULL);\n\t}\n\nerr_restore_mtu:\n\tdev_set_mtu(slave_dev, new_slave->original_mtu);\n\nerr_free:\n\tkobject_put(&new_slave->kobj);\n\nerr_undo_flags:\n\t \n\tif (!bond_has_slaves(bond)) {\n\t\tif (ether_addr_equal_64bits(bond_dev->dev_addr,\n\t\t\t\t\t    slave_dev->dev_addr))\n\t\t\teth_hw_addr_random(bond_dev);\n\t\tif (bond_dev->type != ARPHRD_ETHER) {\n\t\t\tdev_close(bond_dev);\n\t\t\tbond_ether_setup(bond_dev);\n\t\t}\n\t}\n\n\treturn res;\n}\n\n \nstatic int __bond_release_one(struct net_device *bond_dev,\n\t\t\t      struct net_device *slave_dev,\n\t\t\t      bool all, bool unregister)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *oldcurrent;\n\tstruct sockaddr_storage ss;\n\tint old_flags = bond_dev->flags;\n\tnetdev_features_t old_features = bond_dev->features;\n\n\t \n\tif (!(slave_dev->flags & IFF_SLAVE) ||\n\t    !netdev_has_upper_dev(slave_dev, bond_dev)) {\n\t\tslave_dbg(bond_dev, slave_dev, \"cannot release slave\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tblock_netpoll_tx();\n\n\tslave = bond_get_slave_by_dev(bond, slave_dev);\n\tif (!slave) {\n\t\t \n\t\tslave_info(bond_dev, slave_dev, \"interface not enslaved\\n\");\n\t\tunblock_netpoll_tx();\n\t\treturn -EINVAL;\n\t}\n\n\tbond_set_slave_inactive_flags(slave, BOND_SLAVE_NOTIFY_NOW);\n\n\tbond_sysfs_slave_del(slave);\n\n\t \n\tbond_get_stats(bond->dev, &bond->bond_stats);\n\n\tif (bond->xdp_prog) {\n\t\tstruct netdev_bpf xdp = {\n\t\t\t.command = XDP_SETUP_PROG,\n\t\t\t.flags   = 0,\n\t\t\t.prog\t = NULL,\n\t\t\t.extack  = NULL,\n\t\t};\n\t\tif (slave_dev->netdev_ops->ndo_bpf(slave_dev, &xdp))\n\t\t\tslave_warn(bond_dev, slave_dev, \"failed to unload XDP program\\n\");\n\t}\n\n\t \n\tnetdev_rx_handler_unregister(slave_dev);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\tbond_3ad_unbind_slave(slave);\n\n\tbond_upper_dev_unlink(bond, slave);\n\n\tif (bond_mode_can_use_xmit_hash(bond))\n\t\tbond_update_slave_arr(bond, slave);\n\n\tslave_info(bond_dev, slave_dev, \"Releasing %s interface\\n\",\n\t\t    bond_is_active_slave(slave) ? \"active\" : \"backup\");\n\n\toldcurrent = rcu_access_pointer(bond->curr_active_slave);\n\n\tRCU_INIT_POINTER(bond->current_arp_slave, NULL);\n\n\tif (!all && (!bond->params.fail_over_mac ||\n\t\t     BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)) {\n\t\tif (ether_addr_equal_64bits(bond_dev->dev_addr, slave->perm_hwaddr) &&\n\t\t    bond_has_slaves(bond))\n\t\t\tslave_warn(bond_dev, slave_dev, \"the permanent HWaddr of slave - %pM - is still in use by bond - set the HWaddr of slave to a different address to avoid conflicts\\n\",\n\t\t\t\t   slave->perm_hwaddr);\n\t}\n\n\tif (rtnl_dereference(bond->primary_slave) == slave)\n\t\tRCU_INIT_POINTER(bond->primary_slave, NULL);\n\n\tif (oldcurrent == slave)\n\t\tbond_change_active_slave(bond, NULL);\n\n\tif (bond_is_lb(bond)) {\n\t\t \n\t\tbond_alb_deinit_slave(bond, slave);\n\t}\n\n\tif (all) {\n\t\tRCU_INIT_POINTER(bond->curr_active_slave, NULL);\n\t} else if (oldcurrent == slave) {\n\t\t \n\t\tbond_select_active_slave(bond);\n\t}\n\n\tbond_set_carrier(bond);\n\tif (!bond_has_slaves(bond))\n\t\teth_hw_addr_random(bond_dev);\n\n\tunblock_netpoll_tx();\n\tsynchronize_rcu();\n\tbond->slave_cnt--;\n\n\tif (!bond_has_slaves(bond)) {\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, bond->dev);\n\t\tcall_netdevice_notifiers(NETDEV_RELEASE, bond->dev);\n\t}\n\n\tbond_compute_features(bond);\n\tif (!(bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&\n\t    (old_features & NETIF_F_VLAN_CHALLENGED))\n\t\tslave_info(bond_dev, slave_dev, \"last VLAN challenged slave left bond - VLAN blocking is removed\\n\");\n\n\tvlan_vids_del_by_dev(slave_dev, bond_dev);\n\n\t \n\tif (!bond_uses_primary(bond)) {\n\t\t \n\t\tif (old_flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(slave_dev, -1);\n\n\t\t \n\t\tif (old_flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(slave_dev, -1);\n\n\t\tif (old_flags & IFF_UP)\n\t\t\tbond_hw_addr_flush(bond_dev, slave_dev);\n\t}\n\n\tslave_disable_netpoll(slave);\n\n\t \n\tdev_close(slave_dev);\n\n\tslave_dev->priv_flags &= ~IFF_NO_ADDRCONF;\n\n\tif (bond->params.fail_over_mac != BOND_FOM_ACTIVE ||\n\t    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\t \n\t\tbond_hw_addr_copy(ss.__data, slave->perm_hwaddr,\n\t\t\t\t  slave->dev->addr_len);\n\t\tss.ss_family = slave_dev->type;\n\t\tdev_set_mac_address(slave_dev, (struct sockaddr *)&ss, NULL);\n\t}\n\n\tif (unregister)\n\t\t__dev_set_mtu(slave_dev, slave->original_mtu);\n\telse\n\t\tdev_set_mtu(slave_dev, slave->original_mtu);\n\n\tif (!netif_is_bond_master(slave_dev))\n\t\tslave_dev->priv_flags &= ~IFF_BONDING;\n\n\tbond_xdp_set_features(bond_dev);\n\tkobject_put(&slave->kobj);\n\n\treturn 0;\n}\n\n \nint bond_release(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\treturn __bond_release_one(bond_dev, slave_dev, false, false);\n}\n\n \nstatic int bond_release_and_destroy(struct net_device *bond_dev,\n\t\t\t\t    struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tint ret;\n\n\tret = __bond_release_one(bond_dev, slave_dev, false, true);\n\tif (ret == 0 && !bond_has_slaves(bond) &&\n\t    bond_dev->reg_state != NETREG_UNREGISTERING) {\n\t\tbond_dev->priv_flags |= IFF_DISABLE_NETPOLL;\n\t\tnetdev_info(bond_dev, \"Destroying bond\\n\");\n\t\tbond_remove_proc_entry(bond);\n\t\tunregister_netdevice(bond_dev);\n\t}\n\treturn ret;\n}\n\nstatic void bond_info_query(struct net_device *bond_dev, struct ifbond *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tbond_fill_ifbond(bond, info);\n}\n\nstatic int bond_slave_info_query(struct net_device *bond_dev, struct ifslave *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tint i = 0, res = -ENODEV;\n\tstruct slave *slave;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (i++ == (int)info->slave_id) {\n\t\t\tres = 0;\n\t\t\tbond_fill_ifslave(slave, info);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n \n\n \nstatic int bond_miimon_inspect(struct bonding *bond)\n{\n\tbool ignore_updelay = false;\n\tint link_state, commit = 0;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP) {\n\t\tignore_updelay = !rcu_dereference(bond->curr_active_slave);\n\t} else {\n\t\tstruct bond_up_slave *usable_slaves;\n\n\t\tusable_slaves = rcu_dereference(bond->usable_slaves);\n\n\t\tif (usable_slaves && usable_slaves->count == 0)\n\t\t\tignore_updelay = true;\n\t}\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tbond_propose_link_state(slave, BOND_LINK_NOCHANGE);\n\n\t\tlink_state = bond_check_dev_link(bond, slave->dev, 0);\n\n\t\tswitch (slave->link) {\n\t\tcase BOND_LINK_UP:\n\t\t\tif (link_state)\n\t\t\t\tcontinue;\n\n\t\t\tbond_propose_link_state(slave, BOND_LINK_FAIL);\n\t\t\tcommit++;\n\t\t\tslave->delay = bond->params.downdelay;\n\t\t\tif (slave->delay) {\n\t\t\t\tslave_info(bond->dev, slave->dev, \"link status down for %sinterface, disabling it in %d ms\\n\",\n\t\t\t\t\t   (BOND_MODE(bond) ==\n\t\t\t\t\t    BOND_MODE_ACTIVEBACKUP) ?\n\t\t\t\t\t    (bond_is_active_slave(slave) ?\n\t\t\t\t\t     \"active \" : \"backup \") : \"\",\n\t\t\t\t\t   bond->params.downdelay * bond->params.miimon);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase BOND_LINK_FAIL:\n\t\t\tif (link_state) {\n\t\t\t\t \n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_UP);\n\t\t\t\tslave->last_link_up = jiffies;\n\t\t\t\tslave_info(bond->dev, slave->dev, \"link status up again after %d ms\\n\",\n\t\t\t\t\t   (bond->params.downdelay - slave->delay) *\n\t\t\t\t\t   bond->params.miimon);\n\t\t\t\tcommit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (slave->delay <= 0) {\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_DOWN);\n\t\t\t\tcommit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslave->delay--;\n\t\t\tbreak;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (!link_state)\n\t\t\t\tcontinue;\n\n\t\t\tbond_propose_link_state(slave, BOND_LINK_BACK);\n\t\t\tcommit++;\n\t\t\tslave->delay = bond->params.updelay;\n\n\t\t\tif (slave->delay) {\n\t\t\t\tslave_info(bond->dev, slave->dev, \"link status up, enabling it in %d ms\\n\",\n\t\t\t\t\t   ignore_updelay ? 0 :\n\t\t\t\t\t   bond->params.updelay *\n\t\t\t\t\t   bond->params.miimon);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase BOND_LINK_BACK:\n\t\t\tif (!link_state) {\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_DOWN);\n\t\t\t\tslave_info(bond->dev, slave->dev, \"link status down again after %d ms\\n\",\n\t\t\t\t\t   (bond->params.updelay - slave->delay) *\n\t\t\t\t\t   bond->params.miimon);\n\t\t\t\tcommit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ignore_updelay)\n\t\t\t\tslave->delay = 0;\n\n\t\t\tif (slave->delay <= 0) {\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_UP);\n\t\t\t\tcommit++;\n\t\t\t\tignore_updelay = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslave->delay--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn commit;\n}\n\nstatic void bond_miimon_link_change(struct bonding *bond,\n\t\t\t\t    struct slave *slave,\n\t\t\t\t    char link)\n{\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_8023AD:\n\t\tbond_3ad_handle_link_change(slave, link);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\tcase BOND_MODE_ALB:\n\t\tbond_alb_handle_link_change(bond, slave, link);\n\t\tbreak;\n\tcase BOND_MODE_XOR:\n\t\tbond_update_slave_arr(bond, NULL);\n\t\tbreak;\n\t}\n}\n\nstatic void bond_miimon_commit(struct bonding *bond)\n{\n\tstruct slave *slave, *primary, *active;\n\tbool do_failover = false;\n\tstruct list_head *iter;\n\n\tASSERT_RTNL();\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tswitch (slave->link_new_state) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\t \n\t\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD &&\n\t\t\t    slave->link == BOND_LINK_UP)\n\t\t\t\tbond_3ad_adapter_speed_duplex_changed(slave);\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\tif (bond_update_speed_duplex(slave) &&\n\t\t\t    bond_needs_speed_duplex(bond)) {\n\t\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tslave_warn(bond->dev, slave->dev,\n\t\t\t\t\t\t   \"failed to get link speed/duplex\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbond_set_slave_link_state(slave, BOND_LINK_UP,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\tslave->last_link_up = jiffies;\n\n\t\t\tprimary = rtnl_dereference(bond->primary_slave);\n\t\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\t\t\t \n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t} else if (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {\n\t\t\t\t \n\t\t\t\tbond_set_active_slave(slave);\n\t\t\t}\n\n\t\t\tslave_info(bond->dev, slave->dev, \"link status definitely up, %u Mbps %s duplex\\n\",\n\t\t\t\t   slave->speed == SPEED_UNKNOWN ? 0 : slave->speed,\n\t\t\t\t   slave->duplex ? \"full\" : \"half\");\n\n\t\t\tbond_miimon_link_change(bond, slave, BOND_LINK_UP);\n\n\t\t\tactive = rtnl_dereference(bond->curr_active_slave);\n\t\t\tif (!active || slave == primary || slave->prio > active->prio)\n\t\t\t\tdo_failover = true;\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tbond_set_slave_link_state(slave, BOND_LINK_DOWN,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\n\t\t\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||\n\t\t\t    BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\t\t\tbond_set_slave_inactive_flags(slave,\n\t\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\n\t\t\tslave_info(bond->dev, slave->dev, \"link status definitely down, disabling slave\\n\");\n\n\t\t\tbond_miimon_link_change(bond, slave, BOND_LINK_DOWN);\n\n\t\t\tif (slave == rcu_access_pointer(bond->curr_active_slave))\n\t\t\t\tdo_failover = true;\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tslave_err(bond->dev, slave->dev, \"invalid new link %d on slave\\n\",\n\t\t\t\t  slave->link_new_state);\n\t\t\tbond_propose_link_state(slave, BOND_LINK_NOCHANGE);\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (do_failover) {\n\t\tblock_netpoll_tx();\n\t\tbond_select_active_slave(bond);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tbond_set_carrier(bond);\n}\n\n \nstatic void bond_mii_monitor(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    mii_work.work);\n\tbool should_notify_peers = false;\n\tbool commit;\n\tunsigned long delay;\n\tstruct slave *slave;\n\tstruct list_head *iter;\n\n\tdelay = msecs_to_jiffies(bond->params.miimon);\n\n\tif (!bond_has_slaves(bond))\n\t\tgoto re_arm;\n\n\trcu_read_lock();\n\tshould_notify_peers = bond_should_notify_peers(bond);\n\tcommit = !!bond_miimon_inspect(bond);\n\tif (bond->send_peer_notif) {\n\t\trcu_read_unlock();\n\t\tif (rtnl_trylock()) {\n\t\t\tbond->send_peer_notif--;\n\t\t\trtnl_unlock();\n\t\t}\n\t} else {\n\t\trcu_read_unlock();\n\t}\n\n\tif (commit) {\n\t\t \n\t\tif (!rtnl_trylock()) {\n\t\t\tdelay = 1;\n\t\t\tshould_notify_peers = false;\n\t\t\tgoto re_arm;\n\t\t}\n\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\tbond_commit_link_state(slave, BOND_SLAVE_NOTIFY_LATER);\n\t\t}\n\t\tbond_miimon_commit(bond);\n\n\t\trtnl_unlock();\t \n\t}\n\nre_arm:\n\tif (bond->params.miimon)\n\t\tqueue_delayed_work(bond->wq, &bond->mii_work, delay);\n\n\tif (should_notify_peers) {\n\t\tif (!rtnl_trylock())\n\t\t\treturn;\n\t\tcall_netdevice_notifiers(NETDEV_NOTIFY_PEERS, bond->dev);\n\t\trtnl_unlock();\n\t}\n}\n\nstatic int bond_upper_dev_walk(struct net_device *upper,\n\t\t\t       struct netdev_nested_priv *priv)\n{\n\t__be32 ip = *(__be32 *)priv->data;\n\n\treturn ip == bond_confirm_addr(upper, 0, ip);\n}\n\nstatic bool bond_has_this_ip(struct bonding *bond, __be32 ip)\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)&ip,\n\t};\n\tbool ret = false;\n\n\tif (ip == bond_confirm_addr(bond->dev, 0, ip))\n\t\treturn true;\n\n\trcu_read_lock();\n\tif (netdev_walk_all_upper_dev_rcu(bond->dev, bond_upper_dev_walk, &priv))\n\t\tret = true;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n#define BOND_VLAN_PROTO_NONE cpu_to_be16(0xffff)\n\nstatic bool bond_handle_vlan(struct slave *slave, struct bond_vlan_tag *tags,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct net_device *bond_dev = slave->bond->dev;\n\tstruct net_device *slave_dev = slave->dev;\n\tstruct bond_vlan_tag *outer_tag = tags;\n\n\tif (!tags || tags->vlan_proto == BOND_VLAN_PROTO_NONE)\n\t\treturn true;\n\n\ttags++;\n\n\t \n\twhile (tags->vlan_proto != BOND_VLAN_PROTO_NONE) {\n\t\tif (!tags->vlan_id) {\n\t\t\ttags++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tslave_dbg(bond_dev, slave_dev, \"inner tag: proto %X vid %X\\n\",\n\t\t\t  ntohs(outer_tag->vlan_proto), tags->vlan_id);\n\t\tskb = vlan_insert_tag_set_proto(skb, tags->vlan_proto,\n\t\t\t\t\t\ttags->vlan_id);\n\t\tif (!skb) {\n\t\t\tnet_err_ratelimited(\"failed to insert inner VLAN tag\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\ttags++;\n\t}\n\t \n\tif (outer_tag->vlan_id) {\n\t\tslave_dbg(bond_dev, slave_dev, \"outer tag: proto %X vid %X\\n\",\n\t\t\t  ntohs(outer_tag->vlan_proto), outer_tag->vlan_id);\n\t\t__vlan_hwaccel_put_tag(skb, outer_tag->vlan_proto,\n\t\t\t\t       outer_tag->vlan_id);\n\t}\n\n\treturn true;\n}\n\n \nstatic void bond_arp_send(struct slave *slave, int arp_op, __be32 dest_ip,\n\t\t\t  __be32 src_ip, struct bond_vlan_tag *tags)\n{\n\tstruct net_device *bond_dev = slave->bond->dev;\n\tstruct net_device *slave_dev = slave->dev;\n\tstruct sk_buff *skb;\n\n\tslave_dbg(bond_dev, slave_dev, \"arp %d on slave: dst %pI4 src %pI4\\n\",\n\t\t  arp_op, &dest_ip, &src_ip);\n\n\tskb = arp_create(arp_op, ETH_P_ARP, dest_ip, slave_dev, src_ip,\n\t\t\t NULL, slave_dev->dev_addr, NULL);\n\n\tif (!skb) {\n\t\tnet_err_ratelimited(\"ARP packet allocation failed\\n\");\n\t\treturn;\n\t}\n\n\tif (bond_handle_vlan(slave, tags, skb)) {\n\t\tslave_update_last_tx(slave);\n\t\tarp_xmit(skb);\n\t}\n\n\treturn;\n}\n\n \nstruct bond_vlan_tag *bond_verify_device_path(struct net_device *start_dev,\n\t\t\t\t\t      struct net_device *end_dev,\n\t\t\t\t\t      int level)\n{\n\tstruct bond_vlan_tag *tags;\n\tstruct net_device *upper;\n\tstruct list_head  *iter;\n\n\tif (start_dev == end_dev) {\n\t\ttags = kcalloc(level + 1, sizeof(*tags), GFP_ATOMIC);\n\t\tif (!tags)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\ttags[level].vlan_proto = BOND_VLAN_PROTO_NONE;\n\t\treturn tags;\n\t}\n\n\tnetdev_for_each_upper_dev_rcu(start_dev, upper, iter) {\n\t\ttags = bond_verify_device_path(upper, end_dev, level + 1);\n\t\tif (IS_ERR_OR_NULL(tags)) {\n\t\t\tif (IS_ERR(tags))\n\t\t\t\treturn tags;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_vlan_dev(upper)) {\n\t\t\ttags[level].vlan_proto = vlan_dev_vlan_proto(upper);\n\t\t\ttags[level].vlan_id = vlan_dev_vlan_id(upper);\n\t\t}\n\n\t\treturn tags;\n\t}\n\n\treturn NULL;\n}\n\nstatic void bond_arp_send_all(struct bonding *bond, struct slave *slave)\n{\n\tstruct rtable *rt;\n\tstruct bond_vlan_tag *tags;\n\t__be32 *targets = bond->params.arp_targets, addr;\n\tint i;\n\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS && targets[i]; i++) {\n\t\tslave_dbg(bond->dev, slave->dev, \"%s: target %pI4\\n\",\n\t\t\t  __func__, &targets[i]);\n\t\ttags = NULL;\n\n\t\t \n\t\trt = ip_route_output(dev_net(bond->dev), targets[i], 0,\n\t\t\t\t     RTO_ONLINK, 0);\n\t\tif (IS_ERR(rt)) {\n\t\t\t \n\t\t\tif (bond->params.arp_validate)\n\t\t\t\tpr_warn_once(\"%s: no route to arp_ip_target %pI4 and arp_validate is set\\n\",\n\t\t\t\t\t     bond->dev->name,\n\t\t\t\t\t     &targets[i]);\n\t\t\tbond_arp_send(slave, ARPOP_REQUEST, targets[i],\n\t\t\t\t      0, tags);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (rt->dst.dev == bond->dev)\n\t\t\tgoto found;\n\n\t\trcu_read_lock();\n\t\ttags = bond_verify_device_path(bond->dev, rt->dst.dev, 0);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR_OR_NULL(tags))\n\t\t\tgoto found;\n\n\t\t \n\t\tslave_dbg(bond->dev, slave->dev, \"no path to arp_ip_target %pI4 via rt.dev %s\\n\",\n\t\t\t   &targets[i], rt->dst.dev ? rt->dst.dev->name : \"NULL\");\n\n\t\tip_rt_put(rt);\n\t\tcontinue;\n\nfound:\n\t\taddr = bond_confirm_addr(rt->dst.dev, targets[i], 0);\n\t\tip_rt_put(rt);\n\t\tbond_arp_send(slave, ARPOP_REQUEST, targets[i], addr, tags);\n\t\tkfree(tags);\n\t}\n}\n\nstatic void bond_validate_arp(struct bonding *bond, struct slave *slave, __be32 sip, __be32 tip)\n{\n\tint i;\n\n\tif (!sip || !bond_has_this_ip(bond, tip)) {\n\t\tslave_dbg(bond->dev, slave->dev, \"%s: sip %pI4 tip %pI4 not found\\n\",\n\t\t\t   __func__, &sip, &tip);\n\t\treturn;\n\t}\n\n\ti = bond_get_targets_ip(bond->params.arp_targets, sip);\n\tif (i == -1) {\n\t\tslave_dbg(bond->dev, slave->dev, \"%s: sip %pI4 not found in targets\\n\",\n\t\t\t   __func__, &sip);\n\t\treturn;\n\t}\n\tslave->last_rx = jiffies;\n\tslave->target_last_arp_rx[i] = jiffies;\n}\n\nstatic int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond,\n\t\t\tstruct slave *slave)\n{\n\tstruct arphdr *arp = (struct arphdr *)skb->data;\n\tstruct slave *curr_active_slave, *curr_arp_slave;\n\tunsigned char *arp_ptr;\n\t__be32 sip, tip;\n\tunsigned int alen;\n\n\talen = arp_hdr_len(bond->dev);\n\n\tif (alen > skb_headlen(skb)) {\n\t\tarp = kmalloc(alen, GFP_ATOMIC);\n\t\tif (!arp)\n\t\t\tgoto out_unlock;\n\t\tif (skb_copy_bits(skb, 0, arp, alen) < 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (arp->ar_hln != bond->dev->addr_len ||\n\t    skb->pkt_type == PACKET_OTHERHOST ||\n\t    skb->pkt_type == PACKET_LOOPBACK ||\n\t    arp->ar_hrd != htons(ARPHRD_ETHER) ||\n\t    arp->ar_pro != htons(ETH_P_IP) ||\n\t    arp->ar_pln != 4)\n\t\tgoto out_unlock;\n\n\tarp_ptr = (unsigned char *)(arp + 1);\n\tarp_ptr += bond->dev->addr_len;\n\tmemcpy(&sip, arp_ptr, 4);\n\tarp_ptr += 4 + bond->dev->addr_len;\n\tmemcpy(&tip, arp_ptr, 4);\n\n\tslave_dbg(bond->dev, slave->dev, \"%s: %s/%d av %d sv %d sip %pI4 tip %pI4\\n\",\n\t\t  __func__, slave->dev->name, bond_slave_state(slave),\n\t\t  bond->params.arp_validate, slave_do_arp_validate(bond, slave),\n\t\t  &sip, &tip);\n\n\tcurr_active_slave = rcu_dereference(bond->curr_active_slave);\n\tcurr_arp_slave = rcu_dereference(bond->current_arp_slave);\n\n\t \n\tif (bond_is_active_slave(slave))\n\t\tbond_validate_arp(bond, slave, sip, tip);\n\telse if (curr_active_slave &&\n\t\t time_after(slave_last_rx(bond, curr_active_slave),\n\t\t\t    curr_active_slave->last_link_up))\n\t\tbond_validate_arp(bond, slave, tip, sip);\n\telse if (curr_arp_slave && (arp->ar_op == htons(ARPOP_REPLY)) &&\n\t\t bond_time_in_interval(bond, slave_last_tx(curr_arp_slave), 1))\n\t\tbond_validate_arp(bond, slave, sip, tip);\n\nout_unlock:\n\tif (arp != (struct arphdr *)skb->data)\n\t\tkfree(arp);\n\treturn RX_HANDLER_ANOTHER;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void bond_ns_send(struct slave *slave, const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr, struct bond_vlan_tag *tags)\n{\n\tstruct net_device *bond_dev = slave->bond->dev;\n\tstruct net_device *slave_dev = slave->dev;\n\tstruct in6_addr mcaddr;\n\tstruct sk_buff *skb;\n\n\tslave_dbg(bond_dev, slave_dev, \"NS on slave: dst %pI6c src %pI6c\\n\",\n\t\t  daddr, saddr);\n\n\tskb = ndisc_ns_create(slave_dev, daddr, saddr, 0);\n\tif (!skb) {\n\t\tnet_err_ratelimited(\"NS packet allocation failed\\n\");\n\t\treturn;\n\t}\n\n\taddrconf_addr_solict_mult(daddr, &mcaddr);\n\tif (bond_handle_vlan(slave, tags, skb)) {\n\t\tslave_update_last_tx(slave);\n\t\tndisc_send_skb(skb, &mcaddr, saddr);\n\t}\n}\n\nstatic void bond_ns_send_all(struct bonding *bond, struct slave *slave)\n{\n\tstruct in6_addr *targets = bond->params.ns_targets;\n\tstruct bond_vlan_tag *tags;\n\tstruct dst_entry *dst;\n\tstruct in6_addr saddr;\n\tstruct flowi6 fl6;\n\tint i;\n\n\tfor (i = 0; i < BOND_MAX_NS_TARGETS && !ipv6_addr_any(&targets[i]); i++) {\n\t\tslave_dbg(bond->dev, slave->dev, \"%s: target %pI6c\\n\",\n\t\t\t  __func__, &targets[i]);\n\t\ttags = NULL;\n\n\t\t \n\t\tmemset(&fl6, 0, sizeof(struct flowi6));\n\t\tfl6.daddr = targets[i];\n\t\tfl6.flowi6_oif = bond->dev->ifindex;\n\n\t\tdst = ip6_route_output(dev_net(bond->dev), NULL, &fl6);\n\t\tif (dst->error) {\n\t\t\tdst_release(dst);\n\t\t\t \n\t\t\tif (bond->params.arp_validate)\n\t\t\t\tpr_warn_once(\"%s: no route to ns_ip6_target %pI6c and arp_validate is set\\n\",\n\t\t\t\t\t     bond->dev->name,\n\t\t\t\t\t     &targets[i]);\n\t\t\tbond_ns_send(slave, &targets[i], &in6addr_any, tags);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dst->dev == bond->dev)\n\t\t\tgoto found;\n\n\t\trcu_read_lock();\n\t\ttags = bond_verify_device_path(bond->dev, dst->dev, 0);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR_OR_NULL(tags))\n\t\t\tgoto found;\n\n\t\t \n\t\tslave_dbg(bond->dev, slave->dev, \"no path to ns_ip6_target %pI6c via dst->dev %s\\n\",\n\t\t\t  &targets[i], dst->dev ? dst->dev->name : \"NULL\");\n\n\t\tdst_release(dst);\n\t\tcontinue;\n\nfound:\n\t\tif (!ipv6_dev_get_saddr(dev_net(dst->dev), dst->dev, &targets[i], 0, &saddr))\n\t\t\tbond_ns_send(slave, &targets[i], &saddr, tags);\n\t\telse\n\t\t\tbond_ns_send(slave, &targets[i], &in6addr_any, tags);\n\n\t\tdst_release(dst);\n\t\tkfree(tags);\n\t}\n}\n\nstatic int bond_confirm_addr6(struct net_device *dev,\n\t\t\t      struct netdev_nested_priv *priv)\n{\n\tstruct in6_addr *addr = (struct in6_addr *)priv->data;\n\n\treturn ipv6_chk_addr(dev_net(dev), addr, dev, 0);\n}\n\nstatic bool bond_has_this_ip6(struct bonding *bond, struct in6_addr *addr)\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = addr,\n\t};\n\tint ret = false;\n\n\tif (bond_confirm_addr6(bond->dev, &priv))\n\t\treturn true;\n\n\trcu_read_lock();\n\tif (netdev_walk_all_upper_dev_rcu(bond->dev, bond_confirm_addr6, &priv))\n\t\tret = true;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void bond_validate_na(struct bonding *bond, struct slave *slave,\n\t\t\t     struct in6_addr *saddr, struct in6_addr *daddr)\n{\n\tint i;\n\n\t \n\tif (ipv6_addr_any(saddr) ||\n\t    (!ipv6_addr_equal(daddr, &in6addr_linklocal_allnodes) &&\n\t     !bond_has_this_ip6(bond, daddr))) {\n\t\tslave_dbg(bond->dev, slave->dev, \"%s: sip %pI6c tip %pI6c not found\\n\",\n\t\t\t  __func__, saddr, daddr);\n\t\treturn;\n\t}\n\n\ti = bond_get_targets_ip6(bond->params.ns_targets, saddr);\n\tif (i == -1) {\n\t\tslave_dbg(bond->dev, slave->dev, \"%s: sip %pI6c not found in targets\\n\",\n\t\t\t  __func__, saddr);\n\t\treturn;\n\t}\n\tslave->last_rx = jiffies;\n\tslave->target_last_arp_rx[i] = jiffies;\n}\n\nstatic int bond_na_rcv(const struct sk_buff *skb, struct bonding *bond,\n\t\t       struct slave *slave)\n{\n\tstruct slave *curr_active_slave, *curr_arp_slave;\n\tstruct in6_addr *saddr, *daddr;\n\tstruct {\n\t\tstruct ipv6hdr ip6;\n\t\tstruct icmp6hdr icmp6;\n\t} *combined, _combined;\n\n\tif (skb->pkt_type == PACKET_OTHERHOST ||\n\t    skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto out;\n\n\tcombined = skb_header_pointer(skb, 0, sizeof(_combined), &_combined);\n\tif (!combined || combined->ip6.nexthdr != NEXTHDR_ICMP ||\n\t    (combined->icmp6.icmp6_type != NDISC_NEIGHBOUR_SOLICITATION &&\n\t     combined->icmp6.icmp6_type != NDISC_NEIGHBOUR_ADVERTISEMENT))\n\t\tgoto out;\n\n\tsaddr = &combined->ip6.saddr;\n\tdaddr = &combined->ip6.daddr;\n\n\tslave_dbg(bond->dev, slave->dev, \"%s: %s/%d av %d sv %d sip %pI6c tip %pI6c\\n\",\n\t\t  __func__, slave->dev->name, bond_slave_state(slave),\n\t\t  bond->params.arp_validate, slave_do_arp_validate(bond, slave),\n\t\t  saddr, daddr);\n\n\tcurr_active_slave = rcu_dereference(bond->curr_active_slave);\n\tcurr_arp_slave = rcu_dereference(bond->current_arp_slave);\n\n\t \n\tif (bond_is_active_slave(slave))\n\t\tbond_validate_na(bond, slave, saddr, daddr);\n\telse if (curr_active_slave &&\n\t\t time_after(slave_last_rx(bond, curr_active_slave),\n\t\t\t    curr_active_slave->last_link_up))\n\t\tbond_validate_na(bond, slave, daddr, saddr);\n\telse if (curr_arp_slave &&\n\t\t bond_time_in_interval(bond, slave_last_tx(curr_arp_slave), 1))\n\t\tbond_validate_na(bond, slave, saddr, daddr);\n\nout:\n\treturn RX_HANDLER_ANOTHER;\n}\n#endif\n\nint bond_rcv_validate(const struct sk_buff *skb, struct bonding *bond,\n\t\t      struct slave *slave)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tbool is_ipv6 = skb->protocol == __cpu_to_be16(ETH_P_IPV6);\n#endif\n\tbool is_arp = skb->protocol == __cpu_to_be16(ETH_P_ARP);\n\n\tslave_dbg(bond->dev, slave->dev, \"%s: skb->dev %s\\n\",\n\t\t  __func__, skb->dev->name);\n\n\t \n\tif (!slave_do_arp_validate(bond, slave)) {\n\t\tif ((slave_do_arp_validate_only(bond) && is_arp) ||\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t    (slave_do_arp_validate_only(bond) && is_ipv6) ||\n#endif\n\t\t    !slave_do_arp_validate_only(bond))\n\t\t\tslave->last_rx = jiffies;\n\t\treturn RX_HANDLER_ANOTHER;\n\t} else if (is_arp) {\n\t\treturn bond_arp_rcv(skb, bond, slave);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (is_ipv6) {\n\t\treturn bond_na_rcv(skb, bond, slave);\n#endif\n\t} else {\n\t\treturn RX_HANDLER_ANOTHER;\n\t}\n}\n\nstatic void bond_send_validate(struct bonding *bond, struct slave *slave)\n{\n\tbond_arp_send_all(bond, slave);\n#if IS_ENABLED(CONFIG_IPV6)\n\tbond_ns_send_all(bond, slave);\n#endif\n}\n\n \nstatic bool bond_time_in_interval(struct bonding *bond, unsigned long last_act,\n\t\t\t\t  int mod)\n{\n\tint delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);\n\n\treturn time_in_range(jiffies,\n\t\t\t     last_act - delta_in_ticks,\n\t\t\t     last_act + mod * delta_in_ticks + delta_in_ticks/2);\n}\n\n \nstatic void bond_loadbalance_arp_mon(struct bonding *bond)\n{\n\tstruct slave *slave, *oldcurrent;\n\tstruct list_head *iter;\n\tint do_failover = 0, slave_state_changed = 0;\n\n\tif (!bond_has_slaves(bond))\n\t\tgoto re_arm;\n\n\trcu_read_lock();\n\n\toldcurrent = rcu_dereference(bond->curr_active_slave);\n\t \n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tunsigned long last_tx = slave_last_tx(slave);\n\n\t\tbond_propose_link_state(slave, BOND_LINK_NOCHANGE);\n\n\t\tif (slave->link != BOND_LINK_UP) {\n\t\t\tif (bond_time_in_interval(bond, last_tx, 1) &&\n\t\t\t    bond_time_in_interval(bond, slave->last_rx, 1)) {\n\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_UP);\n\t\t\t\tslave_state_changed = 1;\n\n\t\t\t\t \n\t\t\t\tif (!oldcurrent) {\n\t\t\t\t\tslave_info(bond->dev, slave->dev, \"link status definitely up\\n\");\n\t\t\t\t\tdo_failover = 1;\n\t\t\t\t} else {\n\t\t\t\t\tslave_info(bond->dev, slave->dev, \"interface is now up\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tif (!bond_time_in_interval(bond, last_tx, bond->params.missed_max) ||\n\t\t\t    !bond_time_in_interval(bond, slave->last_rx, bond->params.missed_max)) {\n\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_DOWN);\n\t\t\t\tslave_state_changed = 1;\n\n\t\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\t\tslave->link_failure_count++;\n\n\t\t\t\tslave_info(bond->dev, slave->dev, \"interface is now down\\n\");\n\n\t\t\t\tif (slave == oldcurrent)\n\t\t\t\t\tdo_failover = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (bond_slave_is_up(slave))\n\t\t\tbond_send_validate(bond, slave);\n\t}\n\n\trcu_read_unlock();\n\n\tif (do_failover || slave_state_changed) {\n\t\tif (!rtnl_trylock())\n\t\t\tgoto re_arm;\n\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\tif (slave->link_new_state != BOND_LINK_NOCHANGE)\n\t\t\t\tslave->link = slave->link_new_state;\n\t\t}\n\n\t\tif (slave_state_changed) {\n\t\t\tbond_slave_state_change(bond);\n\t\t\tif (BOND_MODE(bond) == BOND_MODE_XOR)\n\t\t\t\tbond_update_slave_arr(bond, NULL);\n\t\t}\n\t\tif (do_failover) {\n\t\t\tblock_netpoll_tx();\n\t\t\tbond_select_active_slave(bond);\n\t\t\tunblock_netpoll_tx();\n\t\t}\n\t\trtnl_unlock();\n\t}\n\nre_arm:\n\tif (bond->params.arp_interval)\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work,\n\t\t\t\t   msecs_to_jiffies(bond->params.arp_interval));\n}\n\n \nstatic int bond_ab_arp_inspect(struct bonding *bond)\n{\n\tunsigned long last_tx, last_rx;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint commit = 0;\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tbond_propose_link_state(slave, BOND_LINK_NOCHANGE);\n\t\tlast_rx = slave_last_rx(bond, slave);\n\n\t\tif (slave->link != BOND_LINK_UP) {\n\t\t\tif (bond_time_in_interval(bond, last_rx, 1)) {\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_UP);\n\t\t\t\tcommit++;\n\t\t\t} else if (slave->link == BOND_LINK_BACK) {\n\t\t\t\tbond_propose_link_state(slave, BOND_LINK_FAIL);\n\t\t\t\tcommit++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (bond_time_in_interval(bond, slave->last_link_up, 2))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!bond_is_active_slave(slave) &&\n\t\t    !rcu_access_pointer(bond->current_arp_slave) &&\n\t\t    !bond_time_in_interval(bond, last_rx, bond->params.missed_max + 1)) {\n\t\t\tbond_propose_link_state(slave, BOND_LINK_DOWN);\n\t\t\tcommit++;\n\t\t}\n\n\t\t \n\t\tlast_tx = slave_last_tx(slave);\n\t\tif (bond_is_active_slave(slave) &&\n\t\t    (!bond_time_in_interval(bond, last_tx, bond->params.missed_max) ||\n\t\t     !bond_time_in_interval(bond, last_rx, bond->params.missed_max))) {\n\t\t\tbond_propose_link_state(slave, BOND_LINK_DOWN);\n\t\t\tcommit++;\n\t\t}\n\t}\n\n\treturn commit;\n}\n\n \nstatic void bond_ab_arp_commit(struct bonding *bond)\n{\n\tbool do_failover = false;\n\tstruct list_head *iter;\n\tunsigned long last_tx;\n\tstruct slave *slave;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tswitch (slave->link_new_state) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\tlast_tx = slave_last_tx(slave);\n\t\t\tif (rtnl_dereference(bond->curr_active_slave) != slave ||\n\t\t\t    (!rtnl_dereference(bond->curr_active_slave) &&\n\t\t\t     bond_time_in_interval(bond, last_tx, 1))) {\n\t\t\t\tstruct slave *current_arp_slave;\n\n\t\t\t\tcurrent_arp_slave = rtnl_dereference(bond->current_arp_slave);\n\t\t\t\tbond_set_slave_link_state(slave, BOND_LINK_UP,\n\t\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\t\tif (current_arp_slave) {\n\t\t\t\t\tbond_set_slave_inactive_flags(\n\t\t\t\t\t\tcurrent_arp_slave,\n\t\t\t\t\t\tBOND_SLAVE_NOTIFY_NOW);\n\t\t\t\t\tRCU_INIT_POINTER(bond->current_arp_slave, NULL);\n\t\t\t\t}\n\n\t\t\t\tslave_info(bond->dev, slave->dev, \"link status definitely up\\n\");\n\n\t\t\t\tif (!rtnl_dereference(bond->curr_active_slave) ||\n\t\t\t\t    slave == rtnl_dereference(bond->primary_slave) ||\n\t\t\t\t    slave->prio > rtnl_dereference(bond->curr_active_slave)->prio)\n\t\t\t\t\tdo_failover = true;\n\n\t\t\t}\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tbond_set_slave_link_state(slave, BOND_LINK_DOWN,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\tbond_set_slave_inactive_flags(slave,\n\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\n\t\t\tslave_info(bond->dev, slave->dev, \"link status definitely down, disabling slave\\n\");\n\n\t\t\tif (slave == rtnl_dereference(bond->curr_active_slave)) {\n\t\t\t\tRCU_INIT_POINTER(bond->current_arp_slave, NULL);\n\t\t\t\tdo_failover = true;\n\t\t\t}\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_FAIL:\n\t\t\tbond_set_slave_link_state(slave, BOND_LINK_FAIL,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_NOW);\n\t\t\tbond_set_slave_inactive_flags(slave,\n\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\n\t\t\t \n\t\t\tif (rtnl_dereference(bond->curr_active_slave))\n\t\t\t\tRCU_INIT_POINTER(bond->current_arp_slave, NULL);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tslave_err(bond->dev, slave->dev,\n\t\t\t\t  \"impossible: link_new_state %d on slave\\n\",\n\t\t\t\t  slave->link_new_state);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (do_failover) {\n\t\tblock_netpoll_tx();\n\t\tbond_select_active_slave(bond);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tbond_set_carrier(bond);\n}\n\n \nstatic bool bond_ab_arp_probe(struct bonding *bond)\n{\n\tstruct slave *slave, *before = NULL, *new_slave = NULL,\n\t\t     *curr_arp_slave = rcu_dereference(bond->current_arp_slave),\n\t\t     *curr_active_slave = rcu_dereference(bond->curr_active_slave);\n\tstruct list_head *iter;\n\tbool found = false;\n\tbool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;\n\n\tif (curr_arp_slave && curr_active_slave)\n\t\tnetdev_info(bond->dev, \"PROBE: c_arp %s && cas %s BAD\\n\",\n\t\t\t    curr_arp_slave->dev->name,\n\t\t\t    curr_active_slave->dev->name);\n\n\tif (curr_active_slave) {\n\t\tbond_send_validate(bond, curr_active_slave);\n\t\treturn should_notify_rtnl;\n\t}\n\n\t \n\n\tif (!curr_arp_slave) {\n\t\tcurr_arp_slave = bond_first_slave_rcu(bond);\n\t\tif (!curr_arp_slave)\n\t\t\treturn should_notify_rtnl;\n\t}\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (!found && !before && bond_slave_is_up(slave))\n\t\t\tbefore = slave;\n\n\t\tif (found && !new_slave && bond_slave_is_up(slave))\n\t\t\tnew_slave = slave;\n\t\t \n\t\tif (!bond_slave_is_up(slave) && slave->link == BOND_LINK_UP) {\n\t\t\tbond_set_slave_link_state(slave, BOND_LINK_DOWN,\n\t\t\t\t\t\t  BOND_SLAVE_NOTIFY_LATER);\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tbond_set_slave_inactive_flags(slave,\n\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_LATER);\n\n\t\t\tslave_info(bond->dev, slave->dev, \"backup interface is now down\\n\");\n\t\t}\n\t\tif (slave == curr_arp_slave)\n\t\t\tfound = true;\n\t}\n\n\tif (!new_slave && before)\n\t\tnew_slave = before;\n\n\tif (!new_slave)\n\t\tgoto check_state;\n\n\tbond_set_slave_link_state(new_slave, BOND_LINK_BACK,\n\t\t\t\t  BOND_SLAVE_NOTIFY_LATER);\n\tbond_set_slave_active_flags(new_slave, BOND_SLAVE_NOTIFY_LATER);\n\tbond_send_validate(bond, new_slave);\n\tnew_slave->last_link_up = jiffies;\n\trcu_assign_pointer(bond->current_arp_slave, new_slave);\n\ncheck_state:\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (slave->should_notify || slave->should_notify_link) {\n\t\t\tshould_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn should_notify_rtnl;\n}\n\nstatic void bond_activebackup_arp_mon(struct bonding *bond)\n{\n\tbool should_notify_peers = false;\n\tbool should_notify_rtnl = false;\n\tint delta_in_ticks;\n\n\tdelta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);\n\n\tif (!bond_has_slaves(bond))\n\t\tgoto re_arm;\n\n\trcu_read_lock();\n\n\tshould_notify_peers = bond_should_notify_peers(bond);\n\n\tif (bond_ab_arp_inspect(bond)) {\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (!rtnl_trylock()) {\n\t\t\tdelta_in_ticks = 1;\n\t\t\tshould_notify_peers = false;\n\t\t\tgoto re_arm;\n\t\t}\n\n\t\tbond_ab_arp_commit(bond);\n\n\t\trtnl_unlock();\n\t\trcu_read_lock();\n\t}\n\n\tshould_notify_rtnl = bond_ab_arp_probe(bond);\n\trcu_read_unlock();\n\nre_arm:\n\tif (bond->params.arp_interval)\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);\n\n\tif (should_notify_peers || should_notify_rtnl) {\n\t\tif (!rtnl_trylock())\n\t\t\treturn;\n\n\t\tif (should_notify_peers) {\n\t\t\tbond->send_peer_notif--;\n\t\t\tcall_netdevice_notifiers(NETDEV_NOTIFY_PEERS,\n\t\t\t\t\t\t bond->dev);\n\t\t}\n\t\tif (should_notify_rtnl) {\n\t\t\tbond_slave_state_notify(bond);\n\t\t\tbond_slave_link_notify(bond);\n\t\t}\n\n\t\trtnl_unlock();\n\t}\n}\n\nstatic void bond_arp_monitor(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    arp_work.work);\n\n\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP)\n\t\tbond_activebackup_arp_mon(bond);\n\telse\n\t\tbond_loadbalance_arp_mon(bond);\n}\n\n \n\n \nstatic int bond_event_changename(struct bonding *bond)\n{\n\tbond_remove_proc_entry(bond);\n\tbond_create_proc_entry(bond);\n\n\tbond_debug_reregister(bond);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int bond_master_netdev_event(unsigned long event,\n\t\t\t\t    struct net_device *bond_dev)\n{\n\tstruct bonding *event_bond = netdev_priv(bond_dev);\n\n\tnetdev_dbg(bond_dev, \"%s called\\n\", __func__);\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\treturn bond_event_changename(event_bond);\n\tcase NETDEV_UNREGISTER:\n\t\tbond_remove_proc_entry(event_bond);\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\txfrm_dev_state_flush(dev_net(bond_dev), bond_dev, true);\n#endif  \n\t\tbreak;\n\tcase NETDEV_REGISTER:\n\t\tbond_create_proc_entry(event_bond);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int bond_slave_netdev_event(unsigned long event,\n\t\t\t\t   struct net_device *slave_dev)\n{\n\tstruct slave *slave = bond_slave_get_rtnl(slave_dev), *primary;\n\tstruct bonding *bond;\n\tstruct net_device *bond_dev;\n\n\t \n\tif (!slave) {\n\t\tnetdev_dbg(slave_dev, \"%s called on NULL slave\\n\", __func__);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tbond_dev = slave->bond->dev;\n\tbond = slave->bond;\n\tprimary = rtnl_dereference(bond->primary_slave);\n\n\tslave_dbg(bond_dev, slave_dev, \"%s called\\n\", __func__);\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tif (bond_dev->type != ARPHRD_ETHER)\n\t\t\tbond_release_and_destroy(bond_dev, slave_dev);\n\t\telse\n\t\t\t__bond_release_one(bond_dev, slave_dev, false, true);\n\t\tbreak;\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\t\t \n\t\tif (bond_update_speed_duplex(slave) &&\n\t\t    BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\t\tif (slave->last_link_up)\n\t\t\t\tslave->link = BOND_LINK_FAIL;\n\t\t\telse\n\t\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t}\n\n\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD)\n\t\t\tbond_3ad_adapter_speed_duplex_changed(slave);\n\t\tfallthrough;\n\tcase NETDEV_DOWN:\n\t\t \n\t\tif (bond_mode_can_use_xmit_hash(bond))\n\t\t\tbond_update_slave_arr(bond, NULL);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\t \n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\t \n\t\tif (!bond_uses_primary(bond) ||\n\t\t    !bond->params.primary[0])\n\t\t\tbreak;\n\n\t\tif (slave == primary) {\n\t\t\t \n\t\t\tRCU_INIT_POINTER(bond->primary_slave, NULL);\n\t\t} else if (!strcmp(slave_dev->name, bond->params.primary)) {\n\t\t\t \n\t\t\trcu_assign_pointer(bond->primary_slave, slave);\n\t\t} else {  \n\t\t\tbreak;\n\t\t}\n\n\t\tnetdev_info(bond->dev, \"Primary slave changed to %s, reselecting active slave\\n\",\n\t\t\t    primary ? slave_dev->name : \"none\");\n\n\t\tblock_netpoll_tx();\n\t\tbond_select_active_slave(bond);\n\t\tunblock_netpoll_tx();\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tif (!bond->notifier_ctx) {\n\t\t\tbond->notifier_ctx = true;\n\t\t\tbond_compute_features(bond);\n\t\t\tbond->notifier_ctx = false;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_RESEND_IGMP:\n\t\t \n\t\tcall_netdevice_notifiers(event, slave->bond->dev);\n\t\tbreak;\n\tcase NETDEV_XDP_FEAT_CHANGE:\n\t\tbond_xdp_set_features(bond_dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int bond_netdev_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *event_dev = netdev_notifier_info_to_dev(ptr);\n\n\tnetdev_dbg(event_dev, \"%s received %s\\n\",\n\t\t   __func__, netdev_cmd_to_name(event));\n\n\tif (!(event_dev->priv_flags & IFF_BONDING))\n\t\treturn NOTIFY_DONE;\n\n\tif (event_dev->flags & IFF_MASTER) {\n\t\tint ret;\n\n\t\tret = bond_master_netdev_event(event, event_dev);\n\t\tif (ret != NOTIFY_DONE)\n\t\t\treturn ret;\n\t}\n\n\tif (event_dev->flags & IFF_SLAVE)\n\t\treturn bond_slave_netdev_event(event, event_dev);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block bond_netdev_notifier = {\n\t.notifier_call = bond_netdev_event,\n};\n\n \n\n \nstatic inline const void *bond_pull_data(struct sk_buff *skb,\n\t\t\t\t\t const void *data, int hlen, int n)\n{\n\tif (likely(n <= hlen))\n\t\treturn data;\n\telse if (skb && likely(pskb_may_pull(skb, n)))\n\t\treturn skb->data;\n\n\treturn NULL;\n}\n\n \nstatic inline u32 bond_eth_hash(struct sk_buff *skb, const void *data, int mhoff, int hlen)\n{\n\tstruct ethhdr *ep;\n\n\tdata = bond_pull_data(skb, data, hlen, mhoff + sizeof(struct ethhdr));\n\tif (!data)\n\t\treturn 0;\n\n\tep = (struct ethhdr *)(data + mhoff);\n\treturn ep->h_dest[5] ^ ep->h_source[5] ^ be16_to_cpu(ep->h_proto);\n}\n\nstatic bool bond_flow_ip(struct sk_buff *skb, struct flow_keys *fk, const void *data,\n\t\t\t int hlen, __be16 l2_proto, int *nhoff, int *ip_proto, bool l34)\n{\n\tconst struct ipv6hdr *iph6;\n\tconst struct iphdr *iph;\n\n\tif (l2_proto == htons(ETH_P_IP)) {\n\t\tdata = bond_pull_data(skb, data, hlen, *nhoff + sizeof(*iph));\n\t\tif (!data)\n\t\t\treturn false;\n\n\t\tiph = (const struct iphdr *)(data + *nhoff);\n\t\tiph_to_flow_copy_v4addrs(fk, iph);\n\t\t*nhoff += iph->ihl << 2;\n\t\tif (!ip_is_fragment(iph))\n\t\t\t*ip_proto = iph->protocol;\n\t} else if (l2_proto == htons(ETH_P_IPV6)) {\n\t\tdata = bond_pull_data(skb, data, hlen, *nhoff + sizeof(*iph6));\n\t\tif (!data)\n\t\t\treturn false;\n\n\t\tiph6 = (const struct ipv6hdr *)(data + *nhoff);\n\t\tiph_to_flow_copy_v6addrs(fk, iph6);\n\t\t*nhoff += sizeof(*iph6);\n\t\t*ip_proto = iph6->nexthdr;\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (l34 && *ip_proto >= 0)\n\t\tfk->ports.ports = __skb_flow_get_ports(skb, *nhoff, *ip_proto, data, hlen);\n\n\treturn true;\n}\n\nstatic u32 bond_vlan_srcmac_hash(struct sk_buff *skb, const void *data, int mhoff, int hlen)\n{\n\tu32 srcmac_vendor = 0, srcmac_dev = 0;\n\tstruct ethhdr *mac_hdr;\n\tu16 vlan = 0;\n\tint i;\n\n\tdata = bond_pull_data(skb, data, hlen, mhoff + sizeof(struct ethhdr));\n\tif (!data)\n\t\treturn 0;\n\tmac_hdr = (struct ethhdr *)(data + mhoff);\n\n\tfor (i = 0; i < 3; i++)\n\t\tsrcmac_vendor = (srcmac_vendor << 8) | mac_hdr->h_source[i];\n\n\tfor (i = 3; i < ETH_ALEN; i++)\n\t\tsrcmac_dev = (srcmac_dev << 8) | mac_hdr->h_source[i];\n\n\tif (skb && skb_vlan_tag_present(skb))\n\t\tvlan = skb_vlan_tag_get(skb);\n\n\treturn vlan ^ srcmac_vendor ^ srcmac_dev;\n}\n\n \nstatic bool bond_flow_dissect(struct bonding *bond, struct sk_buff *skb, const void *data,\n\t\t\t      __be16 l2_proto, int nhoff, int hlen, struct flow_keys *fk)\n{\n\tbool l34 = bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34;\n\tint ip_proto = -1;\n\n\tswitch (bond->params.xmit_policy) {\n\tcase BOND_XMIT_POLICY_ENCAP23:\n\tcase BOND_XMIT_POLICY_ENCAP34:\n\t\tmemset(fk, 0, sizeof(*fk));\n\t\treturn __skb_flow_dissect(NULL, skb, &flow_keys_bonding,\n\t\t\t\t\t  fk, data, l2_proto, nhoff, hlen, 0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfk->ports.ports = 0;\n\tmemset(&fk->icmp, 0, sizeof(fk->icmp));\n\tif (!bond_flow_ip(skb, fk, data, hlen, l2_proto, &nhoff, &ip_proto, l34))\n\t\treturn false;\n\n\t \n\tif (ip_proto == IPPROTO_ICMP || ip_proto == IPPROTO_ICMPV6) {\n\t\tskb_flow_get_icmp_tci(skb, &fk->icmp, data, nhoff, hlen);\n\t\tif (ip_proto == IPPROTO_ICMP) {\n\t\t\tif (!icmp_is_err(fk->icmp.type))\n\t\t\t\treturn true;\n\n\t\t\tnhoff += sizeof(struct icmphdr);\n\t\t} else if (ip_proto == IPPROTO_ICMPV6) {\n\t\t\tif (!icmpv6_is_err(fk->icmp.type))\n\t\t\t\treturn true;\n\n\t\t\tnhoff += sizeof(struct icmp6hdr);\n\t\t}\n\t\treturn bond_flow_ip(skb, fk, data, hlen, l2_proto, &nhoff, &ip_proto, l34);\n\t}\n\n\treturn true;\n}\n\nstatic u32 bond_ip_hash(u32 hash, struct flow_keys *flow, int xmit_policy)\n{\n\thash ^= (__force u32)flow_get_u32_dst(flow) ^\n\t\t(__force u32)flow_get_u32_src(flow);\n\thash ^= (hash >> 16);\n\thash ^= (hash >> 8);\n\n\t \n\tif (xmit_policy == BOND_XMIT_POLICY_LAYER34 ||\n\t\txmit_policy == BOND_XMIT_POLICY_ENCAP34)\n\t\treturn hash >> 1;\n\n\treturn hash;\n}\n\n \nstatic u32 __bond_xmit_hash(struct bonding *bond, struct sk_buff *skb, const void *data,\n\t\t\t    __be16 l2_proto, int mhoff, int nhoff, int hlen)\n{\n\tstruct flow_keys flow;\n\tu32 hash;\n\n\tif (bond->params.xmit_policy == BOND_XMIT_POLICY_VLAN_SRCMAC)\n\t\treturn bond_vlan_srcmac_hash(skb, data, mhoff, hlen);\n\n\tif (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER2 ||\n\t    !bond_flow_dissect(bond, skb, data, l2_proto, nhoff, hlen, &flow))\n\t\treturn bond_eth_hash(skb, data, mhoff, hlen);\n\n\tif (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER23 ||\n\t    bond->params.xmit_policy == BOND_XMIT_POLICY_ENCAP23) {\n\t\thash = bond_eth_hash(skb, data, mhoff, hlen);\n\t} else {\n\t\tif (flow.icmp.id)\n\t\t\tmemcpy(&hash, &flow.icmp, sizeof(hash));\n\t\telse\n\t\t\tmemcpy(&hash, &flow.ports.ports, sizeof(hash));\n\t}\n\n\treturn bond_ip_hash(hash, &flow, bond->params.xmit_policy);\n}\n\n \nu32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb)\n{\n\tif (bond->params.xmit_policy == BOND_XMIT_POLICY_ENCAP34 &&\n\t    skb->l4_hash)\n\t\treturn skb->hash;\n\n\treturn __bond_xmit_hash(bond, skb, skb->data, skb->protocol,\n\t\t\t\t0, skb_network_offset(skb),\n\t\t\t\tskb_headlen(skb));\n}\n\n \nstatic u32 bond_xmit_hash_xdp(struct bonding *bond, struct xdp_buff *xdp)\n{\n\tstruct ethhdr *eth;\n\n\tif (xdp->data + sizeof(struct ethhdr) > xdp->data_end)\n\t\treturn 0;\n\n\teth = (struct ethhdr *)xdp->data;\n\n\treturn __bond_xmit_hash(bond, NULL, xdp->data, eth->h_proto, 0,\n\t\t\t\tsizeof(struct ethhdr), xdp->data_end - xdp->data);\n}\n\n \n\nvoid bond_work_init_all(struct bonding *bond)\n{\n\tINIT_DELAYED_WORK(&bond->mcast_work,\n\t\t\t  bond_resend_igmp_join_requests_delayed);\n\tINIT_DELAYED_WORK(&bond->alb_work, bond_alb_monitor);\n\tINIT_DELAYED_WORK(&bond->mii_work, bond_mii_monitor);\n\tINIT_DELAYED_WORK(&bond->arp_work, bond_arp_monitor);\n\tINIT_DELAYED_WORK(&bond->ad_work, bond_3ad_state_machine_handler);\n\tINIT_DELAYED_WORK(&bond->slave_arr_work, bond_slave_arr_handler);\n}\n\nstatic void bond_work_cancel_all(struct bonding *bond)\n{\n\tcancel_delayed_work_sync(&bond->mii_work);\n\tcancel_delayed_work_sync(&bond->arp_work);\n\tcancel_delayed_work_sync(&bond->alb_work);\n\tcancel_delayed_work_sync(&bond->ad_work);\n\tcancel_delayed_work_sync(&bond->mcast_work);\n\tcancel_delayed_work_sync(&bond->slave_arr_work);\n}\n\nstatic int bond_open(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (BOND_MODE(bond) == BOND_MODE_ROUNDROBIN && !bond->rr_tx_counter) {\n\t\tbond->rr_tx_counter = alloc_percpu(u32);\n\t\tif (!bond->rr_tx_counter)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (bond_has_slaves(bond)) {\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\tif (bond_uses_primary(bond) &&\n\t\t\t    slave != rcu_access_pointer(bond->curr_active_slave)) {\n\t\t\t\tbond_set_slave_inactive_flags(slave,\n\t\t\t\t\t\t\t      BOND_SLAVE_NOTIFY_NOW);\n\t\t\t} else if (BOND_MODE(bond) != BOND_MODE_8023AD) {\n\t\t\t\tbond_set_slave_active_flags(slave,\n\t\t\t\t\t\t\t    BOND_SLAVE_NOTIFY_NOW);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bond_is_lb(bond)) {\n\t\t \n\t\tif (bond_alb_initialize(bond, (BOND_MODE(bond) == BOND_MODE_ALB)))\n\t\t\treturn -ENOMEM;\n\t\tif (bond->params.tlb_dynamic_lb || BOND_MODE(bond) == BOND_MODE_ALB)\n\t\t\tqueue_delayed_work(bond->wq, &bond->alb_work, 0);\n\t}\n\n\tif (bond->params.miimon)   \n\t\tqueue_delayed_work(bond->wq, &bond->mii_work, 0);\n\n\tif (bond->params.arp_interval) {   \n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, 0);\n\t\tbond->recv_probe = bond_rcv_validate;\n\t}\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tqueue_delayed_work(bond->wq, &bond->ad_work, 0);\n\t\t \n\t\tbond->recv_probe = bond_3ad_lacpdu_recv;\n\t\tbond_3ad_initiate_agg_selection(bond, 1);\n\n\t\tbond_for_each_slave(bond, slave, iter)\n\t\t\tdev_mc_add(slave->dev, lacpdu_mcast_addr);\n\t}\n\n\tif (bond_mode_can_use_xmit_hash(bond))\n\t\tbond_update_slave_arr(bond, NULL);\n\n\treturn 0;\n}\n\nstatic int bond_close(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\n\tbond_work_cancel_all(bond);\n\tbond->send_peer_notif = 0;\n\tif (bond_is_lb(bond))\n\t\tbond_alb_deinitialize(bond);\n\tbond->recv_probe = NULL;\n\n\tif (bond_uses_primary(bond)) {\n\t\trcu_read_lock();\n\t\tslave = rcu_dereference(bond->curr_active_slave);\n\t\tif (slave)\n\t\t\tbond_hw_addr_flush(bond_dev, slave->dev);\n\t\trcu_read_unlock();\n\t} else {\n\t\tstruct list_head *iter;\n\n\t\tbond_for_each_slave(bond, slave, iter)\n\t\t\tbond_hw_addr_flush(bond_dev, slave->dev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void bond_fold_stats(struct rtnl_link_stats64 *_res,\n\t\t\t    const struct rtnl_link_stats64 *_new,\n\t\t\t    const struct rtnl_link_stats64 *_old)\n{\n\tconst u64 *new = (const u64 *)_new;\n\tconst u64 *old = (const u64 *)_old;\n\tu64 *res = (u64 *)_res;\n\tint i;\n\n\tfor (i = 0; i < sizeof(*_res) / sizeof(u64); i++) {\n\t\tu64 nv = new[i];\n\t\tu64 ov = old[i];\n\t\ts64 delta = nv - ov;\n\n\t\t \n\t\tif (((nv | ov) >> 32) == 0)\n\t\t\tdelta = (s64)(s32)((u32)nv - (u32)ov);\n\n\t\t \n\t\tif (delta > 0)\n\t\t\tres[i] += delta;\n\t}\n}\n\n#ifdef CONFIG_LOCKDEP\nstatic int bond_get_lowest_level_rcu(struct net_device *dev)\n{\n\tstruct net_device *ldev, *next, *now, *dev_stack[MAX_NEST_DEV + 1];\n\tstruct list_head *niter, *iter, *iter_stack[MAX_NEST_DEV + 1];\n\tint cur = 0, max = 0;\n\n\tnow = dev;\n\titer = &dev->adj_list.lower;\n\n\twhile (1) {\n\t\tnext = NULL;\n\t\twhile (1) {\n\t\t\tldev = netdev_next_lower_dev_rcu(now, &iter);\n\t\t\tif (!ldev)\n\t\t\t\tbreak;\n\n\t\t\tnext = ldev;\n\t\t\tniter = &ldev->adj_list.lower;\n\t\t\tdev_stack[cur] = now;\n\t\t\titer_stack[cur++] = iter;\n\t\t\tif (max <= cur)\n\t\t\t\tmax = cur;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!next) {\n\t\t\tif (!cur)\n\t\t\t\treturn max;\n\t\t\tnext = dev_stack[--cur];\n\t\t\tniter = iter_stack[cur];\n\t\t}\n\n\t\tnow = next;\n\t\titer = niter;\n\t}\n\n\treturn max;\n}\n#endif\n\nstatic void bond_get_stats(struct net_device *bond_dev,\n\t\t\t   struct rtnl_link_stats64 *stats)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct rtnl_link_stats64 temp;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint nest_level = 0;\n\n\n\trcu_read_lock();\n#ifdef CONFIG_LOCKDEP\n\tnest_level = bond_get_lowest_level_rcu(bond_dev);\n#endif\n\n\tspin_lock_nested(&bond->stats_lock, nest_level);\n\tmemcpy(stats, &bond->bond_stats, sizeof(*stats));\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tconst struct rtnl_link_stats64 *new =\n\t\t\tdev_get_stats(slave->dev, &temp);\n\n\t\tbond_fold_stats(stats, new, &slave->slave_stats);\n\n\t\t \n\t\tmemcpy(&slave->slave_stats, new, sizeof(*new));\n\t}\n\n\tmemcpy(&bond->bond_stats, stats, sizeof(*stats));\n\tspin_unlock(&bond->stats_lock);\n\trcu_read_unlock();\n}\n\nstatic int bond_eth_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct mii_ioctl_data *mii = NULL;\n\n\tnetdev_dbg(bond_dev, \"bond_eth_ioctl: cmd=%d\\n\", cmd);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmii = if_mii(ifr);\n\t\tif (!mii)\n\t\t\treturn -EINVAL;\n\n\t\tmii->phy_id = 0;\n\t\tfallthrough;\n\tcase SIOCGMIIREG:\n\t\t \n\t\tmii = if_mii(ifr);\n\t\tif (!mii)\n\t\t\treturn -EINVAL;\n\n\t\tif (mii->reg_num == 1) {\n\t\t\tmii->val_out = 0;\n\t\t\tif (netif_carrier_ok(bond->dev))\n\t\t\t\tmii->val_out = BMSR_LSTATUS;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct net_device *slave_dev = NULL;\n\tstruct ifbond k_binfo;\n\tstruct ifbond __user *u_binfo = NULL;\n\tstruct ifslave k_sinfo;\n\tstruct ifslave __user *u_sinfo = NULL;\n\tstruct bond_opt_value newval;\n\tstruct net *net;\n\tint res = 0;\n\n\tnetdev_dbg(bond_dev, \"bond_ioctl: cmd=%d\\n\", cmd);\n\n\tswitch (cmd) {\n\tcase SIOCBONDINFOQUERY:\n\t\tu_binfo = (struct ifbond __user *)ifr->ifr_data;\n\n\t\tif (copy_from_user(&k_binfo, u_binfo, sizeof(ifbond)))\n\t\t\treturn -EFAULT;\n\n\t\tbond_info_query(bond_dev, &k_binfo);\n\t\tif (copy_to_user(u_binfo, &k_binfo, sizeof(ifbond)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\tcase SIOCBONDSLAVEINFOQUERY:\n\t\tu_sinfo = (struct ifslave __user *)ifr->ifr_data;\n\n\t\tif (copy_from_user(&k_sinfo, u_sinfo, sizeof(ifslave)))\n\t\t\treturn -EFAULT;\n\n\t\tres = bond_slave_info_query(bond_dev, &k_sinfo);\n\t\tif (res == 0 &&\n\t\t    copy_to_user(u_sinfo, &k_sinfo, sizeof(ifslave)))\n\t\t\treturn -EFAULT;\n\n\t\treturn res;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnet = dev_net(bond_dev);\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tslave_dev = __dev_get_by_name(net, ifr->ifr_slave);\n\n\tslave_dbg(bond_dev, slave_dev, \"slave_dev=%p:\\n\", slave_dev);\n\n\tif (!slave_dev)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase SIOCBONDENSLAVE:\n\t\tres = bond_enslave(bond_dev, slave_dev, NULL);\n\t\tbreak;\n\tcase SIOCBONDRELEASE:\n\t\tres = bond_release(bond_dev, slave_dev);\n\t\tbreak;\n\tcase SIOCBONDSETHWADDR:\n\t\tres = bond_set_dev_addr(bond_dev, slave_dev);\n\t\tbreak;\n\tcase SIOCBONDCHANGEACTIVE:\n\t\tbond_opt_initstr(&newval, slave_dev->name);\n\t\tres = __bond_opt_set_notify(bond, BOND_OPT_ACTIVE_SLAVE,\n\t\t\t\t\t    &newval);\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\n\treturn res;\n}\n\nstatic int bond_siocdevprivate(struct net_device *bond_dev, struct ifreq *ifr,\n\t\t\t       void __user *data, int cmd)\n{\n\tstruct ifreq ifrdata = { .ifr_data = data };\n\n\tswitch (cmd) {\n\tcase BOND_INFO_QUERY_OLD:\n\t\treturn bond_do_ioctl(bond_dev, &ifrdata, SIOCBONDINFOQUERY);\n\tcase BOND_SLAVE_INFO_QUERY_OLD:\n\t\treturn bond_do_ioctl(bond_dev, &ifrdata, SIOCBONDSLAVEINFOQUERY);\n\tcase BOND_ENSLAVE_OLD:\n\t\treturn bond_do_ioctl(bond_dev, ifr, SIOCBONDENSLAVE);\n\tcase BOND_RELEASE_OLD:\n\t\treturn bond_do_ioctl(bond_dev, ifr, SIOCBONDRELEASE);\n\tcase BOND_SETHWADDR_OLD:\n\t\treturn bond_do_ioctl(bond_dev, ifr, SIOCBONDSETHWADDR);\n\tcase BOND_CHANGE_ACTIVE_OLD:\n\t\treturn bond_do_ioctl(bond_dev, ifr, SIOCBONDCHANGEACTIVE);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void bond_change_rx_flags(struct net_device *bond_dev, int change)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tif (change & IFF_PROMISC)\n\t\tbond_set_promiscuity(bond,\n\t\t\t\t     bond_dev->flags & IFF_PROMISC ? 1 : -1);\n\n\tif (change & IFF_ALLMULTI)\n\t\tbond_set_allmulti(bond,\n\t\t\t\t  bond_dev->flags & IFF_ALLMULTI ? 1 : -1);\n}\n\nstatic void bond_set_rx_mode(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\trcu_read_lock();\n\tif (bond_uses_primary(bond)) {\n\t\tslave = rcu_dereference(bond->curr_active_slave);\n\t\tif (slave) {\n\t\t\tdev_uc_sync(slave->dev, bond_dev);\n\t\t\tdev_mc_sync(slave->dev, bond_dev);\n\t\t}\n\t} else {\n\t\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\t\tdev_uc_sync_multiple(slave->dev, bond_dev);\n\t\t\tdev_mc_sync_multiple(slave->dev, bond_dev);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic int bond_neigh_init(struct neighbour *n)\n{\n\tstruct bonding *bond = netdev_priv(n->dev);\n\tconst struct net_device_ops *slave_ops;\n\tstruct neigh_parms parms;\n\tstruct slave *slave;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tslave = bond_first_slave_rcu(bond);\n\tif (!slave)\n\t\tgoto out;\n\tslave_ops = slave->dev->netdev_ops;\n\tif (!slave_ops->ndo_neigh_setup)\n\t\tgoto out;\n\n\t \n\tmemset(&parms, 0, sizeof(parms));\n\tret = slave_ops->ndo_neigh_setup(slave->dev, &parms);\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (parms.neigh_setup)\n\t\tret = parms.neigh_setup(n);\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int bond_neigh_setup(struct net_device *dev,\n\t\t\t    struct neigh_parms *parms)\n{\n\t \n\tif (parms->dev == dev)\n\t\tparms->neigh_setup = bond_neigh_init;\n\n\treturn 0;\n}\n\n \nstatic int bond_change_mtu(struct net_device *bond_dev, int new_mtu)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *rollback_slave;\n\tstruct list_head *iter;\n\tint res = 0;\n\n\tnetdev_dbg(bond_dev, \"bond=%p, new_mtu=%d\\n\", bond, new_mtu);\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tslave_dbg(bond_dev, slave->dev, \"s %p c_m %p\\n\",\n\t\t\t   slave, slave->dev->netdev_ops->ndo_change_mtu);\n\n\t\tres = dev_set_mtu(slave->dev, new_mtu);\n\n\t\tif (res) {\n\t\t\t \n\t\t\tslave_dbg(bond_dev, slave->dev, \"err %d setting mtu to %d\\n\",\n\t\t\t\t  res, new_mtu);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tbond_dev->mtu = new_mtu;\n\n\treturn 0;\n\nunwind:\n\t \n\tbond_for_each_slave(bond, rollback_slave, iter) {\n\t\tint tmp_res;\n\n\t\tif (rollback_slave == slave)\n\t\t\tbreak;\n\n\t\ttmp_res = dev_set_mtu(rollback_slave->dev, bond_dev->mtu);\n\t\tif (tmp_res)\n\t\t\tslave_dbg(bond_dev, rollback_slave->dev, \"unwind err %d\\n\",\n\t\t\t\t  tmp_res);\n\t}\n\n\treturn res;\n}\n\n \nstatic int bond_set_mac_address(struct net_device *bond_dev, void *addr)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *rollback_slave;\n\tstruct sockaddr_storage *ss = addr, tmp_ss;\n\tstruct list_head *iter;\n\tint res = 0;\n\n\tif (BOND_MODE(bond) == BOND_MODE_ALB)\n\t\treturn bond_alb_set_mac_address(bond_dev, addr);\n\n\n\tnetdev_dbg(bond_dev, \"%s: bond=%p\\n\", __func__, bond);\n\n\t \n\tif (bond->params.fail_over_mac &&\n\t    BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP)\n\t\treturn 0;\n\n\tif (!is_valid_ether_addr(ss->__data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tslave_dbg(bond_dev, slave->dev, \"%s: slave=%p\\n\",\n\t\t\t  __func__, slave);\n\t\tres = dev_set_mac_address(slave->dev, addr, NULL);\n\t\tif (res) {\n\t\t\t \n\t\t\tslave_dbg(bond_dev, slave->dev, \"%s: err %d\\n\",\n\t\t\t\t  __func__, res);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t \n\tdev_addr_set(bond_dev, ss->__data);\n\treturn 0;\n\nunwind:\n\tmemcpy(tmp_ss.__data, bond_dev->dev_addr, bond_dev->addr_len);\n\ttmp_ss.ss_family = bond_dev->type;\n\n\t \n\tbond_for_each_slave(bond, rollback_slave, iter) {\n\t\tint tmp_res;\n\n\t\tif (rollback_slave == slave)\n\t\t\tbreak;\n\n\t\ttmp_res = dev_set_mac_address(rollback_slave->dev,\n\t\t\t\t\t      (struct sockaddr *)&tmp_ss, NULL);\n\t\tif (tmp_res) {\n\t\t\tslave_dbg(bond_dev, rollback_slave->dev, \"%s: unwind err %d\\n\",\n\t\t\t\t   __func__, tmp_res);\n\t\t}\n\t}\n\n\treturn res;\n}\n\n \nstatic struct slave *bond_get_slave_by_id(struct bonding *bond,\n\t\t\t\t\t  int slave_id)\n{\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint i = slave_id;\n\n\t \n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (--i < 0) {\n\t\t\tif (bond_slave_can_tx(slave))\n\t\t\t\treturn slave;\n\t\t}\n\t}\n\n\t \n\ti = slave_id;\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (--i < 0)\n\t\t\tbreak;\n\t\tif (bond_slave_can_tx(slave))\n\t\t\treturn slave;\n\t}\n\t \n\treturn NULL;\n}\n\n \nstatic u32 bond_rr_gen_slave_id(struct bonding *bond)\n{\n\tu32 slave_id;\n\tstruct reciprocal_value reciprocal_packets_per_slave;\n\tint packets_per_slave = bond->params.packets_per_slave;\n\n\tswitch (packets_per_slave) {\n\tcase 0:\n\t\tslave_id = get_random_u32();\n\t\tbreak;\n\tcase 1:\n\t\tslave_id = this_cpu_inc_return(*bond->rr_tx_counter);\n\t\tbreak;\n\tdefault:\n\t\treciprocal_packets_per_slave =\n\t\t\tbond->params.reciprocal_packets_per_slave;\n\t\tslave_id = this_cpu_inc_return(*bond->rr_tx_counter);\n\t\tslave_id = reciprocal_divide(slave_id,\n\t\t\t\t\t     reciprocal_packets_per_slave);\n\t\tbreak;\n\t}\n\n\treturn slave_id;\n}\n\nstatic struct slave *bond_xmit_roundrobin_slave_get(struct bonding *bond,\n\t\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct slave *slave;\n\tint slave_cnt;\n\tu32 slave_id;\n\n\t \n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tint noff = skb_network_offset(skb);\n\t\tstruct iphdr *iph;\n\n\t\tif (unlikely(!pskb_may_pull(skb, noff + sizeof(*iph))))\n\t\t\tgoto non_igmp;\n\n\t\tiph = ip_hdr(skb);\n\t\tif (iph->protocol == IPPROTO_IGMP) {\n\t\t\tslave = rcu_dereference(bond->curr_active_slave);\n\t\t\tif (slave)\n\t\t\t\treturn slave;\n\t\t\treturn bond_get_slave_by_id(bond, 0);\n\t\t}\n\t}\n\nnon_igmp:\n\tslave_cnt = READ_ONCE(bond->slave_cnt);\n\tif (likely(slave_cnt)) {\n\t\tslave_id = bond_rr_gen_slave_id(bond) % slave_cnt;\n\t\treturn bond_get_slave_by_id(bond, slave_id);\n\t}\n\treturn NULL;\n}\n\nstatic struct slave *bond_xdp_xmit_roundrobin_slave_get(struct bonding *bond,\n\t\t\t\t\t\t\tstruct xdp_buff *xdp)\n{\n\tstruct slave *slave;\n\tint slave_cnt;\n\tu32 slave_id;\n\tconst struct ethhdr *eth;\n\tvoid *data = xdp->data;\n\n\tif (data + sizeof(struct ethhdr) > xdp->data_end)\n\t\tgoto non_igmp;\n\n\teth = (struct ethhdr *)data;\n\tdata += sizeof(struct ethhdr);\n\n\t \n\tif (eth->h_proto == htons(ETH_P_IP)) {\n\t\tconst struct iphdr *iph;\n\n\t\tif (data + sizeof(struct iphdr) > xdp->data_end)\n\t\t\tgoto non_igmp;\n\n\t\tiph = (struct iphdr *)data;\n\n\t\tif (iph->protocol == IPPROTO_IGMP) {\n\t\t\tslave = rcu_dereference(bond->curr_active_slave);\n\t\t\tif (slave)\n\t\t\t\treturn slave;\n\t\t\treturn bond_get_slave_by_id(bond, 0);\n\t\t}\n\t}\n\nnon_igmp:\n\tslave_cnt = READ_ONCE(bond->slave_cnt);\n\tif (likely(slave_cnt)) {\n\t\tslave_id = bond_rr_gen_slave_id(bond) % slave_cnt;\n\t\treturn bond_get_slave_by_id(bond, slave_id);\n\t}\n\treturn NULL;\n}\n\nstatic netdev_tx_t bond_xmit_roundrobin(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\n\tslave = bond_xmit_roundrobin_slave_get(bond, skb);\n\tif (likely(slave))\n\t\treturn bond_dev_queue_xmit(bond, skb, slave->dev);\n\n\treturn bond_tx_drop(bond_dev, skb);\n}\n\nstatic struct slave *bond_xmit_activebackup_slave_get(struct bonding *bond)\n{\n\treturn rcu_dereference(bond->curr_active_slave);\n}\n\n \nstatic netdev_tx_t bond_xmit_activebackup(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\n\tslave = bond_xmit_activebackup_slave_get(bond);\n\tif (slave)\n\t\treturn bond_dev_queue_xmit(bond, skb, slave->dev);\n\n\treturn bond_tx_drop(bond_dev, skb);\n}\n\n \nvoid bond_slave_arr_work_rearm(struct bonding *bond, unsigned long delay)\n{\n\tqueue_delayed_work(bond->wq, &bond->slave_arr_work, delay);\n}\n\n \nstatic void bond_slave_arr_handler(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    slave_arr_work.work);\n\tint ret;\n\n\tif (!rtnl_trylock())\n\t\tgoto err;\n\n\tret = bond_update_slave_arr(bond, NULL);\n\trtnl_unlock();\n\tif (ret) {\n\t\tpr_warn_ratelimited(\"Failed to update slave array from WT\\n\");\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tbond_slave_arr_work_rearm(bond, 1);\n}\n\nstatic void bond_skip_slave(struct bond_up_slave *slaves,\n\t\t\t    struct slave *skipslave)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; slaves && idx < slaves->count; idx++) {\n\t\tif (skipslave == slaves->arr[idx]) {\n\t\t\tslaves->arr[idx] =\n\t\t\t\tslaves->arr[slaves->count - 1];\n\t\t\tslaves->count--;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void bond_set_slave_arr(struct bonding *bond,\n\t\t\t       struct bond_up_slave *usable_slaves,\n\t\t\t       struct bond_up_slave *all_slaves)\n{\n\tstruct bond_up_slave *usable, *all;\n\n\tusable = rtnl_dereference(bond->usable_slaves);\n\trcu_assign_pointer(bond->usable_slaves, usable_slaves);\n\tkfree_rcu(usable, rcu);\n\n\tall = rtnl_dereference(bond->all_slaves);\n\trcu_assign_pointer(bond->all_slaves, all_slaves);\n\tkfree_rcu(all, rcu);\n}\n\nstatic void bond_reset_slave_arr(struct bonding *bond)\n{\n\tbond_set_slave_arr(bond, NULL, NULL);\n}\n\n \nint bond_update_slave_arr(struct bonding *bond, struct slave *skipslave)\n{\n\tstruct bond_up_slave *usable_slaves = NULL, *all_slaves = NULL;\n\tstruct slave *slave;\n\tstruct list_head *iter;\n\tint agg_id = 0;\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tusable_slaves = kzalloc(struct_size(usable_slaves, arr,\n\t\t\t\t\t    bond->slave_cnt), GFP_KERNEL);\n\tall_slaves = kzalloc(struct_size(all_slaves, arr,\n\t\t\t\t\t bond->slave_cnt), GFP_KERNEL);\n\tif (!usable_slaves || !all_slaves) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tstruct ad_info ad_info;\n\n\t\tspin_lock_bh(&bond->mode_lock);\n\t\tif (bond_3ad_get_active_agg_info(bond, &ad_info)) {\n\t\t\tspin_unlock_bh(&bond->mode_lock);\n\t\t\tpr_debug(\"bond_3ad_get_active_agg_info failed\\n\");\n\t\t\t \n\t\t\tbond_reset_slave_arr(bond);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock_bh(&bond->mode_lock);\n\t\tagg_id = ad_info.aggregator_id;\n\t}\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (skipslave == slave)\n\t\t\tcontinue;\n\n\t\tall_slaves->arr[all_slaves->count++] = slave;\n\t\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\t\tstruct aggregator *agg;\n\n\t\t\tagg = SLAVE_AD_INFO(slave)->port.aggregator;\n\t\t\tif (!agg || agg->aggregator_identifier != agg_id)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!bond_slave_can_tx(slave))\n\t\t\tcontinue;\n\n\t\tslave_dbg(bond->dev, slave->dev, \"Adding slave to tx hash array[%d]\\n\",\n\t\t\t  usable_slaves->count);\n\n\t\tusable_slaves->arr[usable_slaves->count++] = slave;\n\t}\n\n\tbond_set_slave_arr(bond, usable_slaves, all_slaves);\n\treturn ret;\nout:\n\tif (ret != 0 && skipslave) {\n\t\tbond_skip_slave(rtnl_dereference(bond->all_slaves),\n\t\t\t\tskipslave);\n\t\tbond_skip_slave(rtnl_dereference(bond->usable_slaves),\n\t\t\t\tskipslave);\n\t}\n\tkfree_rcu(all_slaves, rcu);\n\tkfree_rcu(usable_slaves, rcu);\n\n\treturn ret;\n}\n\nstatic struct slave *bond_xmit_3ad_xor_slave_get(struct bonding *bond,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct bond_up_slave *slaves)\n{\n\tstruct slave *slave;\n\tunsigned int count;\n\tu32 hash;\n\n\thash = bond_xmit_hash(bond, skb);\n\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\tif (unlikely(!count))\n\t\treturn NULL;\n\n\tslave = slaves->arr[hash % count];\n\treturn slave;\n}\n\nstatic struct slave *bond_xdp_xmit_3ad_xor_slave_get(struct bonding *bond,\n\t\t\t\t\t\t     struct xdp_buff *xdp)\n{\n\tstruct bond_up_slave *slaves;\n\tunsigned int count;\n\tu32 hash;\n\n\thash = bond_xmit_hash_xdp(bond, xdp);\n\tslaves = rcu_dereference(bond->usable_slaves);\n\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\tif (unlikely(!count))\n\t\treturn NULL;\n\n\treturn slaves->arr[hash % count];\n}\n\n \nstatic netdev_tx_t bond_3ad_xor_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct bond_up_slave *slaves;\n\tstruct slave *slave;\n\n\tslaves = rcu_dereference(bond->usable_slaves);\n\tslave = bond_xmit_3ad_xor_slave_get(bond, skb, slaves);\n\tif (likely(slave))\n\t\treturn bond_dev_queue_xmit(bond, skb, slave->dev);\n\n\treturn bond_tx_drop(dev, skb);\n}\n\n \nstatic netdev_tx_t bond_xmit_broadcast(struct sk_buff *skb,\n\t\t\t\t       struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave = NULL;\n\tstruct list_head *iter;\n\tbool xmit_suc = false;\n\tbool skb_used = false;\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tstruct sk_buff *skb2;\n\n\t\tif (!(bond_slave_is_up(slave) && slave->link == BOND_LINK_UP))\n\t\t\tcontinue;\n\n\t\tif (bond_is_last_slave(bond, slave)) {\n\t\t\tskb2 = skb;\n\t\t\tskb_used = true;\n\t\t} else {\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!skb2) {\n\t\t\t\tnet_err_ratelimited(\"%s: Error: %s: skb_clone() failed\\n\",\n\t\t\t\t\t\t    bond_dev->name, __func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (bond_dev_queue_xmit(bond, skb2, slave->dev) == NETDEV_TX_OK)\n\t\t\txmit_suc = true;\n\t}\n\n\tif (!skb_used)\n\t\tdev_kfree_skb_any(skb);\n\n\tif (xmit_suc)\n\t\treturn NETDEV_TX_OK;\n\n\tdev_core_stats_tx_dropped_inc(bond_dev);\n\treturn NET_XMIT_DROP;\n}\n\n \n\n \nstatic inline int bond_slave_override(struct bonding *bond,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct slave *slave = NULL;\n\tstruct list_head *iter;\n\n\tif (!skb_rx_queue_recorded(skb))\n\t\treturn 1;\n\n\t \n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (slave->queue_id == skb_get_queue_mapping(skb)) {\n\t\t\tif (bond_slave_is_up(slave) &&\n\t\t\t    slave->link == BOND_LINK_UP) {\n\t\t\t\tbond_dev_queue_xmit(bond, skb, slave->dev);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nstatic u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t     struct net_device *sb_dev)\n{\n\t \n\tu16 txq = skb_rx_queue_recorded(skb) ? skb_get_rx_queue(skb) : 0;\n\n\t \n\tqdisc_skb_cb(skb)->slave_dev_queue_mapping = skb_get_queue_mapping(skb);\n\n\tif (unlikely(txq >= dev->real_num_tx_queues)) {\n\t\tdo {\n\t\t\ttxq -= dev->real_num_tx_queues;\n\t\t} while (txq >= dev->real_num_tx_queues);\n\t}\n\treturn txq;\n}\n\nstatic struct net_device *bond_xmit_get_slave(struct net_device *master_dev,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      bool all_slaves)\n{\n\tstruct bonding *bond = netdev_priv(master_dev);\n\tstruct bond_up_slave *slaves;\n\tstruct slave *slave = NULL;\n\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\tslave = bond_xmit_roundrobin_slave_get(bond, skb);\n\t\tbreak;\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tslave = bond_xmit_activebackup_slave_get(bond);\n\t\tbreak;\n\tcase BOND_MODE_8023AD:\n\tcase BOND_MODE_XOR:\n\t\tif (all_slaves)\n\t\t\tslaves = rcu_dereference(bond->all_slaves);\n\t\telse\n\t\t\tslaves = rcu_dereference(bond->usable_slaves);\n\t\tslave = bond_xmit_3ad_xor_slave_get(bond, skb, slaves);\n\t\tbreak;\n\tcase BOND_MODE_BROADCAST:\n\t\tbreak;\n\tcase BOND_MODE_ALB:\n\t\tslave = bond_xmit_alb_slave_get(bond, skb);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\t\tslave = bond_xmit_tlb_slave_get(bond, skb);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ONCE(true, \"Unknown bonding mode\");\n\t\tbreak;\n\t}\n\n\tif (slave)\n\t\treturn slave->dev;\n\treturn NULL;\n}\n\nstatic void bond_sk_to_flow(struct sock *sk, struct flow_keys *flow)\n{\n\tswitch (sk->sk_family) {\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (ipv6_only_sock(sk) ||\n\t\t    ipv6_addr_type(&sk->sk_v6_daddr) != IPV6_ADDR_MAPPED) {\n\t\t\tflow->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\tflow->addrs.v6addrs.src = inet6_sk(sk)->saddr;\n\t\t\tflow->addrs.v6addrs.dst = sk->sk_v6_daddr;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n#endif\n\tdefault:  \n\t\tflow->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tflow->addrs.v4addrs.src = inet_sk(sk)->inet_rcv_saddr;\n\t\tflow->addrs.v4addrs.dst = inet_sk(sk)->inet_daddr;\n\t\tbreak;\n\t}\n\n\tflow->ports.src = inet_sk(sk)->inet_sport;\n\tflow->ports.dst = inet_sk(sk)->inet_dport;\n}\n\n \nstatic u32 bond_sk_hash_l34(struct sock *sk)\n{\n\tstruct flow_keys flow;\n\tu32 hash;\n\n\tbond_sk_to_flow(sk, &flow);\n\n\t \n\tmemcpy(&hash, &flow.ports.ports, sizeof(hash));\n\t \n\treturn bond_ip_hash(hash, &flow, BOND_XMIT_POLICY_LAYER34);\n}\n\nstatic struct net_device *__bond_sk_get_lower_dev(struct bonding *bond,\n\t\t\t\t\t\t  struct sock *sk)\n{\n\tstruct bond_up_slave *slaves;\n\tstruct slave *slave;\n\tunsigned int count;\n\tu32 hash;\n\n\tslaves = rcu_dereference(bond->usable_slaves);\n\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\tif (unlikely(!count))\n\t\treturn NULL;\n\n\thash = bond_sk_hash_l34(sk);\n\tslave = slaves->arr[hash % count];\n\n\treturn slave->dev;\n}\n\nstatic struct net_device *bond_sk_get_lower_dev(struct net_device *dev,\n\t\t\t\t\t\tstruct sock *sk)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct net_device *lower = NULL;\n\n\trcu_read_lock();\n\tif (bond_sk_check(bond))\n\t\tlower = __bond_sk_get_lower_dev(bond, sk);\n\trcu_read_unlock();\n\n\treturn lower;\n}\n\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\nstatic netdev_tx_t bond_tls_device_xmit(struct bonding *bond, struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct net_device *tls_netdev = rcu_dereference(tls_get_ctx(skb->sk)->netdev);\n\n\t \n\tif (likely(bond_get_slave_by_dev(bond, tls_netdev)))\n\t\treturn bond_dev_queue_xmit(bond, skb, tls_netdev);\n\treturn bond_tx_drop(dev, skb);\n}\n#endif\n\nstatic netdev_tx_t __bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\n\tif (bond_should_override_tx_queue(bond) &&\n\t    !bond_slave_override(bond, skb))\n\t\treturn NETDEV_TX_OK;\n\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\n\tif (tls_is_skb_tx_device_offloaded(skb))\n\t\treturn bond_tls_device_xmit(bond, skb, dev);\n#endif\n\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\treturn bond_xmit_roundrobin(skb, dev);\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\treturn bond_xmit_activebackup(skb, dev);\n\tcase BOND_MODE_8023AD:\n\tcase BOND_MODE_XOR:\n\t\treturn bond_3ad_xor_xmit(skb, dev);\n\tcase BOND_MODE_BROADCAST:\n\t\treturn bond_xmit_broadcast(skb, dev);\n\tcase BOND_MODE_ALB:\n\t\treturn bond_alb_xmit(skb, dev);\n\tcase BOND_MODE_TLB:\n\t\treturn bond_tlb_xmit(skb, dev);\n\tdefault:\n\t\t \n\t\tnetdev_err(dev, \"Unknown bonding mode %d\\n\", BOND_MODE(bond));\n\t\tWARN_ON_ONCE(1);\n\t\treturn bond_tx_drop(dev, skb);\n\t}\n}\n\nstatic netdev_tx_t bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\t \n\tif (unlikely(is_netpoll_tx_blocked(dev)))\n\t\treturn NETDEV_TX_BUSY;\n\n\trcu_read_lock();\n\tif (bond_has_slaves(bond))\n\t\tret = __bond_start_xmit(skb, dev);\n\telse\n\t\tret = bond_tx_drop(dev, skb);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic struct net_device *\nbond_xdp_get_xmit_slave(struct net_device *bond_dev, struct xdp_buff *xdp)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\n\t \n\n\tswitch (BOND_MODE(bond)) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\tslave = bond_xdp_xmit_roundrobin_slave_get(bond, xdp);\n\t\tbreak;\n\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tslave = bond_xmit_activebackup_slave_get(bond);\n\t\tbreak;\n\n\tcase BOND_MODE_8023AD:\n\tcase BOND_MODE_XOR:\n\t\tslave = bond_xdp_xmit_3ad_xor_slave_get(bond, xdp);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tnetdev_err(bond_dev, \"Unknown bonding mode %d for xdp xmit\\n\", BOND_MODE(bond));\n\t\tWARN_ON_ONCE(1);\n\t\treturn NULL;\n\t}\n\n\tif (slave)\n\t\treturn slave->dev;\n\n\treturn NULL;\n}\n\nstatic int bond_xdp_xmit(struct net_device *bond_dev,\n\t\t\t int n, struct xdp_frame **frames, u32 flags)\n{\n\tint nxmit, err = -ENXIO;\n\n\trcu_read_lock();\n\n\tfor (nxmit = 0; nxmit < n; nxmit++) {\n\t\tstruct xdp_frame *frame = frames[nxmit];\n\t\tstruct xdp_frame *frames1[] = {frame};\n\t\tstruct net_device *slave_dev;\n\t\tstruct xdp_buff xdp;\n\n\t\txdp_convert_frame_to_buff(frame, &xdp);\n\n\t\tslave_dev = bond_xdp_get_xmit_slave(bond_dev, &xdp);\n\t\tif (!slave_dev) {\n\t\t\terr = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = slave_dev->netdev_ops->ndo_xdp_xmit(slave_dev, 1, frames1, flags);\n\t\tif (err < 1)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tif (err < 0)\n\t\treturn (nxmit == 0 ? err : nxmit);\n\n\treturn nxmit;\n}\n\nstatic int bond_xdp_set(struct net_device *dev, struct bpf_prog *prog,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct list_head *iter;\n\tstruct slave *slave, *rollback_slave;\n\tstruct bpf_prog *old_prog;\n\tstruct netdev_bpf xdp = {\n\t\t.command = XDP_SETUP_PROG,\n\t\t.flags   = 0,\n\t\t.prog    = prog,\n\t\t.extack  = extack,\n\t};\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!bond_xdp_check(bond))\n\t\treturn -EOPNOTSUPP;\n\n\told_prog = bond->xdp_prog;\n\tbond->xdp_prog = prog;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tstruct net_device *slave_dev = slave->dev;\n\n\t\tif (!slave_dev->netdev_ops->ndo_bpf ||\n\t\t    !slave_dev->netdev_ops->ndo_xdp_xmit) {\n\t\t\tSLAVE_NL_ERR(dev, slave_dev, extack,\n\t\t\t\t     \"Slave device does not support XDP\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dev_xdp_prog_count(slave_dev) > 0) {\n\t\t\tSLAVE_NL_ERR(dev, slave_dev, extack,\n\t\t\t\t     \"Slave has XDP program loaded, please unload before enslaving\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\n\t\terr = slave_dev->netdev_ops->ndo_bpf(slave_dev, &xdp);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tslave_err(dev, slave_dev, \"Error %d calling ndo_bpf\\n\", err);\n\t\t\tgoto err;\n\t\t}\n\t\tif (prog)\n\t\t\tbpf_prog_inc(prog);\n\t}\n\n\tif (prog) {\n\t\tstatic_branch_inc(&bpf_master_redirect_enabled_key);\n\t} else if (old_prog) {\n\t\tbpf_prog_put(old_prog);\n\t\tstatic_branch_dec(&bpf_master_redirect_enabled_key);\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\tbond->xdp_prog = old_prog;\n\txdp.prog = old_prog;\n\txdp.extack = NULL;  \n\n\tbond_for_each_slave(bond, rollback_slave, iter) {\n\t\tstruct net_device *slave_dev = rollback_slave->dev;\n\t\tint err_unwind;\n\n\t\tif (slave == rollback_slave)\n\t\t\tbreak;\n\n\t\terr_unwind = slave_dev->netdev_ops->ndo_bpf(slave_dev, &xdp);\n\t\tif (err_unwind < 0)\n\t\t\tslave_err(dev, slave_dev,\n\t\t\t\t  \"Error %d when unwinding XDP program change\\n\", err_unwind);\n\t\telse if (xdp.prog)\n\t\t\tbpf_prog_inc(xdp.prog);\n\t}\n\treturn err;\n}\n\nstatic int bond_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn bond_xdp_set(dev, xdp->prog, xdp->extack);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 bond_mode_bcast_speed(struct slave *slave, u32 speed)\n{\n\tif (speed == 0 || speed == SPEED_UNKNOWN)\n\t\tspeed = slave->speed;\n\telse\n\t\tspeed = min(speed, slave->speed);\n\n\treturn speed;\n}\n\n \nstatic int bond_set_phc_index_flag(struct kernel_hwtstamp_config *kernel_cfg)\n{\n\tstruct ifreq *ifr = kernel_cfg->ifr;\n\tstruct hwtstamp_config cfg;\n\n\tif (kernel_cfg->copied_to_user) {\n\t\t \n\t\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\t\treturn -EFAULT;\n\n\t\tcfg.flags |= HWTSTAMP_FLAG_BONDED_PHC_INDEX;\n\t\tif (copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tkernel_cfg->flags |= HWTSTAMP_FLAG_BONDED_PHC_INDEX;\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_hwtstamp_get(struct net_device *dev,\n\t\t\t     struct kernel_hwtstamp_config *cfg)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct net_device *real_dev;\n\tint err;\n\n\treal_dev = bond_option_active_slave_get_rcu(bond);\n\tif (!real_dev)\n\t\treturn -EOPNOTSUPP;\n\n\terr = generic_hwtstamp_get_lower(real_dev, cfg);\n\tif (err)\n\t\treturn err;\n\n\treturn bond_set_phc_index_flag(cfg);\n}\n\nstatic int bond_hwtstamp_set(struct net_device *dev,\n\t\t\t     struct kernel_hwtstamp_config *cfg,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct net_device *real_dev;\n\tint err;\n\n\tif (!(cfg->flags & HWTSTAMP_FLAG_BONDED_PHC_INDEX))\n\t\treturn -EOPNOTSUPP;\n\n\treal_dev = bond_option_active_slave_get_rcu(bond);\n\tif (!real_dev)\n\t\treturn -EOPNOTSUPP;\n\n\terr = generic_hwtstamp_set_lower(real_dev, cfg, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn bond_set_phc_index_flag(cfg);\n}\n\nstatic int bond_ethtool_get_link_ksettings(struct net_device *bond_dev,\n\t\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tu32 speed = 0;\n\n\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\tcmd->base.port = PORT_OTHER;\n\n\t \n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (bond_slave_can_tx(slave)) {\n\t\t\tbond_update_speed_duplex(slave);\n\t\t\tif (slave->speed != SPEED_UNKNOWN) {\n\t\t\t\tif (BOND_MODE(bond) == BOND_MODE_BROADCAST)\n\t\t\t\t\tspeed = bond_mode_bcast_speed(slave,\n\t\t\t\t\t\t\t\t      speed);\n\t\t\t\telse\n\t\t\t\t\tspeed += slave->speed;\n\t\t\t}\n\t\t\tif (cmd->base.duplex == DUPLEX_UNKNOWN &&\n\t\t\t    slave->duplex != DUPLEX_UNKNOWN)\n\t\t\t\tcmd->base.duplex = slave->duplex;\n\t\t}\n\t}\n\tcmd->base.speed = speed ? : SPEED_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic void bond_ethtool_get_drvinfo(struct net_device *bond_dev,\n\t\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), \"%d\",\n\t\t BOND_ABI_VERSION);\n}\n\nstatic int bond_ethtool_get_ts_info(struct net_device *bond_dev,\n\t\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct ethtool_ts_info ts_info;\n\tconst struct ethtool_ops *ops;\n\tstruct net_device *real_dev;\n\tbool sw_tx_support = false;\n\tstruct phy_device *phydev;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint ret = 0;\n\n\trcu_read_lock();\n\treal_dev = bond_option_active_slave_get_rcu(bond);\n\tdev_hold(real_dev);\n\trcu_read_unlock();\n\n\tif (real_dev) {\n\t\tops = real_dev->ethtool_ops;\n\t\tphydev = real_dev->phydev;\n\n\t\tif (phy_has_tsinfo(phydev)) {\n\t\t\tret = phy_ts_info(phydev, info);\n\t\t\tgoto out;\n\t\t} else if (ops->get_ts_info) {\n\t\t\tret = ops->get_ts_info(real_dev, info);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\trcu_read_lock();\n\t\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\t\tret = -1;\n\t\t\tops = slave->dev->ethtool_ops;\n\t\t\tphydev = slave->dev->phydev;\n\n\t\t\tif (phy_has_tsinfo(phydev))\n\t\t\t\tret = phy_ts_info(phydev, &ts_info);\n\t\t\telse if (ops->get_ts_info)\n\t\t\t\tret = ops->get_ts_info(slave->dev, &ts_info);\n\n\t\t\tif (!ret && (ts_info.so_timestamping & SOF_TIMESTAMPING_TX_SOFTWARE)) {\n\t\t\t\tsw_tx_support = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsw_tx_support = false;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tret = 0;\n\tinfo->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\tif (sw_tx_support)\n\t\tinfo->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE;\n\n\tinfo->phc_index = -1;\n\nout:\n\tdev_put(real_dev);\n\treturn ret;\n}\n\nstatic const struct ethtool_ops bond_ethtool_ops = {\n\t.get_drvinfo\t\t= bond_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= bond_ethtool_get_link_ksettings,\n\t.get_ts_info\t\t= bond_ethtool_get_ts_info,\n};\n\nstatic const struct net_device_ops bond_netdev_ops = {\n\t.ndo_init\t\t= bond_init,\n\t.ndo_uninit\t\t= bond_uninit,\n\t.ndo_open\t\t= bond_open,\n\t.ndo_stop\t\t= bond_close,\n\t.ndo_start_xmit\t\t= bond_start_xmit,\n\t.ndo_select_queue\t= bond_select_queue,\n\t.ndo_get_stats64\t= bond_get_stats,\n\t.ndo_eth_ioctl\t\t= bond_eth_ioctl,\n\t.ndo_siocbond\t\t= bond_do_ioctl,\n\t.ndo_siocdevprivate\t= bond_siocdevprivate,\n\t.ndo_change_rx_flags\t= bond_change_rx_flags,\n\t.ndo_set_rx_mode\t= bond_set_rx_mode,\n\t.ndo_change_mtu\t\t= bond_change_mtu,\n\t.ndo_set_mac_address\t= bond_set_mac_address,\n\t.ndo_neigh_setup\t= bond_neigh_setup,\n\t.ndo_vlan_rx_add_vid\t= bond_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= bond_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_netpoll_setup\t= bond_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= bond_netpoll_cleanup,\n\t.ndo_poll_controller\t= bond_poll_controller,\n#endif\n\t.ndo_add_slave\t\t= bond_enslave,\n\t.ndo_del_slave\t\t= bond_release,\n\t.ndo_fix_features\t= bond_fix_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_get_xmit_slave\t= bond_xmit_get_slave,\n\t.ndo_sk_get_lower_dev\t= bond_sk_get_lower_dev,\n\t.ndo_bpf\t\t= bond_xdp,\n\t.ndo_xdp_xmit           = bond_xdp_xmit,\n\t.ndo_xdp_get_xmit_slave = bond_xdp_get_xmit_slave,\n\t.ndo_hwtstamp_get\t= bond_hwtstamp_get,\n\t.ndo_hwtstamp_set\t= bond_hwtstamp_set,\n};\n\nstatic const struct device_type bond_type = {\n\t.name = \"bond\",\n};\n\nstatic void bond_destructor(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tif (bond->wq)\n\t\tdestroy_workqueue(bond->wq);\n\n\tfree_percpu(bond->rr_tx_counter);\n}\n\nvoid bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tspin_lock_init(&bond->mode_lock);\n\tbond->params = bonding_defaults;\n\n\t \n\tbond->dev = bond_dev;\n\n\t \n\tether_setup(bond_dev);\n\tbond_dev->max_mtu = ETH_MAX_MTU;\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\n\tbond_dev->needs_free_netdev = true;\n\tbond_dev->priv_destructor = bond_destructor;\n\n\tSET_NETDEV_DEVTYPE(bond_dev, &bond_type);\n\n\t \n\tbond_dev->flags |= IFF_MASTER;\n\tbond_dev->priv_flags |= IFF_BONDING | IFF_UNICAST_FLT | IFF_NO_QUEUE;\n\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\n#ifdef CONFIG_XFRM_OFFLOAD\n\t \n\tbond_dev->xfrmdev_ops = &bond_xfrmdev_ops;\n\tINIT_LIST_HEAD(&bond->ipsec_list);\n\tspin_lock_init(&bond->ipsec_lock);\n#endif  \n\n\t \n\tbond_dev->features |= NETIF_F_LLTX;\n\n\t \n\n\t \n\tbond_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t\tNETIF_F_HW_VLAN_STAG_RX |\n\t\t\t\tNETIF_F_HW_VLAN_STAG_FILTER;\n\n\tbond_dev->hw_features |= NETIF_F_GSO_ENCAP_ALL;\n\tbond_dev->features |= bond_dev->hw_features;\n\tbond_dev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX;\n#ifdef CONFIG_XFRM_OFFLOAD\n\tbond_dev->hw_features |= BOND_XFRM_FEATURES;\n\t \n\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP)\n\t\tbond_dev->features |= BOND_XFRM_FEATURES;\n#endif  \n\n\tif (bond_xdp_check(bond))\n\t\tbond_dev->xdp_features = NETDEV_XDP_ACT_MASK;\n}\n\n \nstatic void bond_uninit(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tbond_netpoll_cleanup(bond_dev);\n\n\t \n\tbond_for_each_slave(bond, slave, iter)\n\t\t__bond_release_one(bond_dev, slave->dev, true, true);\n\tnetdev_info(bond_dev, \"Released all slaves\\n\");\n\n\tbond_set_slave_arr(bond, NULL, NULL);\n\n\tlist_del(&bond->bond_list);\n\n\tbond_debug_unregister(bond);\n}\n\n \n\nstatic int __init bond_check_params(struct bond_params *params)\n{\n\tint arp_validate_value, fail_over_mac_value, primary_reselect_value, i;\n\tstruct bond_opt_value newval;\n\tconst struct bond_opt_value *valptr;\n\tint arp_all_targets_value = 0;\n\tu16 ad_actor_sys_prio = 0;\n\tu16 ad_user_port_key = 0;\n\t__be32 arp_target[BOND_MAX_ARP_TARGETS] = { 0 };\n\tint arp_ip_count;\n\tint bond_mode\t= BOND_MODE_ROUNDROBIN;\n\tint xmit_hashtype = BOND_XMIT_POLICY_LAYER2;\n\tint lacp_fast = 0;\n\tint tlb_dynamic_lb;\n\n\t \n\tif (mode) {\n\t\tbond_opt_initstr(&newval, mode);\n\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_MODE), &newval);\n\t\tif (!valptr) {\n\t\t\tpr_err(\"Error: Invalid bonding mode \\\"%s\\\"\\n\", mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbond_mode = valptr->value;\n\t}\n\n\tif (xmit_hash_policy) {\n\t\tif (bond_mode == BOND_MODE_ROUNDROBIN ||\n\t\t    bond_mode == BOND_MODE_ACTIVEBACKUP ||\n\t\t    bond_mode == BOND_MODE_BROADCAST) {\n\t\t\tpr_info(\"xmit_hash_policy param is irrelevant in mode %s\\n\",\n\t\t\t\tbond_mode_name(bond_mode));\n\t\t} else {\n\t\t\tbond_opt_initstr(&newval, xmit_hash_policy);\n\t\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_XMIT_HASH),\n\t\t\t\t\t\t&newval);\n\t\t\tif (!valptr) {\n\t\t\t\tpr_err(\"Error: Invalid xmit_hash_policy \\\"%s\\\"\\n\",\n\t\t\t\t       xmit_hash_policy);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\txmit_hashtype = valptr->value;\n\t\t}\n\t}\n\n\tif (lacp_rate) {\n\t\tif (bond_mode != BOND_MODE_8023AD) {\n\t\t\tpr_info(\"lacp_rate param is irrelevant in mode %s\\n\",\n\t\t\t\tbond_mode_name(bond_mode));\n\t\t} else {\n\t\t\tbond_opt_initstr(&newval, lacp_rate);\n\t\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_LACP_RATE),\n\t\t\t\t\t\t&newval);\n\t\t\tif (!valptr) {\n\t\t\t\tpr_err(\"Error: Invalid lacp rate \\\"%s\\\"\\n\",\n\t\t\t\t       lacp_rate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlacp_fast = valptr->value;\n\t\t}\n\t}\n\n\tif (ad_select) {\n\t\tbond_opt_initstr(&newval, ad_select);\n\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_AD_SELECT),\n\t\t\t\t\t&newval);\n\t\tif (!valptr) {\n\t\t\tpr_err(\"Error: Invalid ad_select \\\"%s\\\"\\n\", ad_select);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparams->ad_select = valptr->value;\n\t\tif (bond_mode != BOND_MODE_8023AD)\n\t\t\tpr_warn(\"ad_select param only affects 802.3ad mode\\n\");\n\t} else {\n\t\tparams->ad_select = BOND_AD_STABLE;\n\t}\n\n\tif (max_bonds < 0) {\n\t\tpr_warn(\"Warning: max_bonds (%d) not in range %d-%d, so it was reset to BOND_DEFAULT_MAX_BONDS (%d)\\n\",\n\t\t\tmax_bonds, 0, INT_MAX, BOND_DEFAULT_MAX_BONDS);\n\t\tmax_bonds = BOND_DEFAULT_MAX_BONDS;\n\t}\n\n\tif (miimon < 0) {\n\t\tpr_warn(\"Warning: miimon module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\tmiimon, INT_MAX);\n\t\tmiimon = 0;\n\t}\n\n\tif (updelay < 0) {\n\t\tpr_warn(\"Warning: updelay module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\tupdelay, INT_MAX);\n\t\tupdelay = 0;\n\t}\n\n\tif (downdelay < 0) {\n\t\tpr_warn(\"Warning: downdelay module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\tdowndelay, INT_MAX);\n\t\tdowndelay = 0;\n\t}\n\n\tif ((use_carrier != 0) && (use_carrier != 1)) {\n\t\tpr_warn(\"Warning: use_carrier module parameter (%d), not of valid value (0/1), so it was set to 1\\n\",\n\t\t\tuse_carrier);\n\t\tuse_carrier = 1;\n\t}\n\n\tif (num_peer_notif < 0 || num_peer_notif > 255) {\n\t\tpr_warn(\"Warning: num_grat_arp/num_unsol_na (%d) not in range 0-255 so it was reset to 1\\n\",\n\t\t\tnum_peer_notif);\n\t\tnum_peer_notif = 1;\n\t}\n\n\t \n\tif (!bond_mode_uses_arp(bond_mode)) {\n\t\tif (!miimon) {\n\t\t\tpr_warn(\"Warning: miimon must be specified, otherwise bonding will not detect link failure, speed and duplex which are essential for 802.3ad operation\\n\");\n\t\t\tpr_warn(\"Forcing miimon to 100msec\\n\");\n\t\t\tmiimon = BOND_DEFAULT_MIIMON;\n\t\t}\n\t}\n\n\tif (tx_queues < 1 || tx_queues > 255) {\n\t\tpr_warn(\"Warning: tx_queues (%d) should be between 1 and 255, resetting to %d\\n\",\n\t\t\ttx_queues, BOND_DEFAULT_TX_QUEUES);\n\t\ttx_queues = BOND_DEFAULT_TX_QUEUES;\n\t}\n\n\tif ((all_slaves_active != 0) && (all_slaves_active != 1)) {\n\t\tpr_warn(\"Warning: all_slaves_active module parameter (%d), not of valid value (0/1), so it was set to 0\\n\",\n\t\t\tall_slaves_active);\n\t\tall_slaves_active = 0;\n\t}\n\n\tif (resend_igmp < 0 || resend_igmp > 255) {\n\t\tpr_warn(\"Warning: resend_igmp (%d) should be between 0 and 255, resetting to %d\\n\",\n\t\t\tresend_igmp, BOND_DEFAULT_RESEND_IGMP);\n\t\tresend_igmp = BOND_DEFAULT_RESEND_IGMP;\n\t}\n\n\tbond_opt_initval(&newval, packets_per_slave);\n\tif (!bond_opt_parse(bond_opt_get(BOND_OPT_PACKETS_PER_SLAVE), &newval)) {\n\t\tpr_warn(\"Warning: packets_per_slave (%d) should be between 0 and %u resetting to 1\\n\",\n\t\t\tpackets_per_slave, USHRT_MAX);\n\t\tpackets_per_slave = 1;\n\t}\n\n\tif (bond_mode == BOND_MODE_ALB) {\n\t\tpr_notice(\"In ALB mode you might experience client disconnections upon reconnection of a link if the bonding module updelay parameter (%d msec) is incompatible with the forwarding delay time of the switch\\n\",\n\t\t\t  updelay);\n\t}\n\n\tif (!miimon) {\n\t\tif (updelay || downdelay) {\n\t\t\t \n\t\t\tpr_warn(\"Warning: miimon module parameter not set and updelay (%d) or downdelay (%d) module parameter is set; updelay and downdelay have no effect unless miimon is set\\n\",\n\t\t\t\tupdelay, downdelay);\n\t\t}\n\t} else {\n\t\t \n\t\tif (arp_interval) {\n\t\t\tpr_warn(\"Warning: miimon (%d) and arp_interval (%d) can't be used simultaneously, disabling ARP monitoring\\n\",\n\t\t\t\tmiimon, arp_interval);\n\t\t\tarp_interval = 0;\n\t\t}\n\n\t\tif ((updelay % miimon) != 0) {\n\t\t\tpr_warn(\"Warning: updelay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\\n\",\n\t\t\t\tupdelay, miimon, (updelay / miimon) * miimon);\n\t\t}\n\n\t\tupdelay /= miimon;\n\n\t\tif ((downdelay % miimon) != 0) {\n\t\t\tpr_warn(\"Warning: downdelay (%d) is not a multiple of miimon (%d), downdelay rounded to %d ms\\n\",\n\t\t\t\tdowndelay, miimon,\n\t\t\t\t(downdelay / miimon) * miimon);\n\t\t}\n\n\t\tdowndelay /= miimon;\n\t}\n\n\tif (arp_interval < 0) {\n\t\tpr_warn(\"Warning: arp_interval module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\tarp_interval, INT_MAX);\n\t\tarp_interval = 0;\n\t}\n\n\tfor (arp_ip_count = 0, i = 0;\n\t     (arp_ip_count < BOND_MAX_ARP_TARGETS) && arp_ip_target[i]; i++) {\n\t\t__be32 ip;\n\n\t\t \n\t\tif (!in4_pton(arp_ip_target[i], -1, (u8 *)&ip, -1, NULL) ||\n\t\t    !bond_is_ip_target_ok(ip)) {\n\t\t\tpr_warn(\"Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed\\n\",\n\t\t\t\tarp_ip_target[i]);\n\t\t\tarp_interval = 0;\n\t\t} else {\n\t\t\tif (bond_get_targets_ip(arp_target, ip) == -1)\n\t\t\t\tarp_target[arp_ip_count++] = ip;\n\t\t\telse\n\t\t\t\tpr_warn(\"Warning: duplicate address %pI4 in arp_ip_target, skipping\\n\",\n\t\t\t\t\t&ip);\n\t\t}\n\t}\n\n\tif (arp_interval && !arp_ip_count) {\n\t\t \n\t\tpr_warn(\"Warning: arp_interval module parameter (%d) specified without providing an arp_ip_target parameter, arp_interval was reset to 0\\n\",\n\t\t\tarp_interval);\n\t\tarp_interval = 0;\n\t}\n\n\tif (arp_validate) {\n\t\tif (!arp_interval) {\n\t\t\tpr_err(\"arp_validate requires arp_interval\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbond_opt_initstr(&newval, arp_validate);\n\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_ARP_VALIDATE),\n\t\t\t\t\t&newval);\n\t\tif (!valptr) {\n\t\t\tpr_err(\"Error: invalid arp_validate \\\"%s\\\"\\n\",\n\t\t\t       arp_validate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tarp_validate_value = valptr->value;\n\t} else {\n\t\tarp_validate_value = 0;\n\t}\n\n\tif (arp_all_targets) {\n\t\tbond_opt_initstr(&newval, arp_all_targets);\n\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_ARP_ALL_TARGETS),\n\t\t\t\t\t&newval);\n\t\tif (!valptr) {\n\t\t\tpr_err(\"Error: invalid arp_all_targets_value \\\"%s\\\"\\n\",\n\t\t\t       arp_all_targets);\n\t\t\tarp_all_targets_value = 0;\n\t\t} else {\n\t\t\tarp_all_targets_value = valptr->value;\n\t\t}\n\t}\n\n\tif (miimon) {\n\t\tpr_info(\"MII link monitoring set to %d ms\\n\", miimon);\n\t} else if (arp_interval) {\n\t\tvalptr = bond_opt_get_val(BOND_OPT_ARP_VALIDATE,\n\t\t\t\t\t  arp_validate_value);\n\t\tpr_info(\"ARP monitoring set to %d ms, validate %s, with %d target(s):\",\n\t\t\tarp_interval, valptr->string, arp_ip_count);\n\n\t\tfor (i = 0; i < arp_ip_count; i++)\n\t\t\tpr_cont(\" %s\", arp_ip_target[i]);\n\n\t\tpr_cont(\"\\n\");\n\n\t} else if (max_bonds) {\n\t\t \n\t\tpr_debug(\"Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details\\n\");\n\t}\n\n\tif (primary && !bond_mode_uses_primary(bond_mode)) {\n\t\t \n\t\tpr_warn(\"Warning: %s primary device specified but has no effect in %s mode\\n\",\n\t\t\tprimary, bond_mode_name(bond_mode));\n\t\tprimary = NULL;\n\t}\n\n\tif (primary && primary_reselect) {\n\t\tbond_opt_initstr(&newval, primary_reselect);\n\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_PRIMARY_RESELECT),\n\t\t\t\t\t&newval);\n\t\tif (!valptr) {\n\t\t\tpr_err(\"Error: Invalid primary_reselect \\\"%s\\\"\\n\",\n\t\t\t       primary_reselect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprimary_reselect_value = valptr->value;\n\t} else {\n\t\tprimary_reselect_value = BOND_PRI_RESELECT_ALWAYS;\n\t}\n\n\tif (fail_over_mac) {\n\t\tbond_opt_initstr(&newval, fail_over_mac);\n\t\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_FAIL_OVER_MAC),\n\t\t\t\t\t&newval);\n\t\tif (!valptr) {\n\t\t\tpr_err(\"Error: invalid fail_over_mac \\\"%s\\\"\\n\",\n\t\t\t       fail_over_mac);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfail_over_mac_value = valptr->value;\n\t\tif (bond_mode != BOND_MODE_ACTIVEBACKUP)\n\t\t\tpr_warn(\"Warning: fail_over_mac only affects active-backup mode\\n\");\n\t} else {\n\t\tfail_over_mac_value = BOND_FOM_NONE;\n\t}\n\n\tbond_opt_initstr(&newval, \"default\");\n\tvalptr = bond_opt_parse(\n\t\t\tbond_opt_get(BOND_OPT_AD_ACTOR_SYS_PRIO),\n\t\t\t\t     &newval);\n\tif (!valptr) {\n\t\tpr_err(\"Error: No ad_actor_sys_prio default value\");\n\t\treturn -EINVAL;\n\t}\n\tad_actor_sys_prio = valptr->value;\n\n\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_AD_USER_PORT_KEY),\n\t\t\t\t&newval);\n\tif (!valptr) {\n\t\tpr_err(\"Error: No ad_user_port_key default value\");\n\t\treturn -EINVAL;\n\t}\n\tad_user_port_key = valptr->value;\n\n\tbond_opt_initstr(&newval, \"default\");\n\tvalptr = bond_opt_parse(bond_opt_get(BOND_OPT_TLB_DYNAMIC_LB), &newval);\n\tif (!valptr) {\n\t\tpr_err(\"Error: No tlb_dynamic_lb default value\");\n\t\treturn -EINVAL;\n\t}\n\ttlb_dynamic_lb = valptr->value;\n\n\tif (lp_interval == 0) {\n\t\tpr_warn(\"Warning: ip_interval must be between 1 and %d, so it was reset to %d\\n\",\n\t\t\tINT_MAX, BOND_ALB_DEFAULT_LP_INTERVAL);\n\t\tlp_interval = BOND_ALB_DEFAULT_LP_INTERVAL;\n\t}\n\n\t \n\tparams->mode = bond_mode;\n\tparams->xmit_policy = xmit_hashtype;\n\tparams->miimon = miimon;\n\tparams->num_peer_notif = num_peer_notif;\n\tparams->arp_interval = arp_interval;\n\tparams->arp_validate = arp_validate_value;\n\tparams->arp_all_targets = arp_all_targets_value;\n\tparams->missed_max = 2;\n\tparams->updelay = updelay;\n\tparams->downdelay = downdelay;\n\tparams->peer_notif_delay = 0;\n\tparams->use_carrier = use_carrier;\n\tparams->lacp_active = 1;\n\tparams->lacp_fast = lacp_fast;\n\tparams->primary[0] = 0;\n\tparams->primary_reselect = primary_reselect_value;\n\tparams->fail_over_mac = fail_over_mac_value;\n\tparams->tx_queues = tx_queues;\n\tparams->all_slaves_active = all_slaves_active;\n\tparams->resend_igmp = resend_igmp;\n\tparams->min_links = min_links;\n\tparams->lp_interval = lp_interval;\n\tparams->packets_per_slave = packets_per_slave;\n\tparams->tlb_dynamic_lb = tlb_dynamic_lb;\n\tparams->ad_actor_sys_prio = ad_actor_sys_prio;\n\teth_zero_addr(params->ad_actor_system);\n\tparams->ad_user_port_key = ad_user_port_key;\n\tif (packets_per_slave > 0) {\n\t\tparams->reciprocal_packets_per_slave =\n\t\t\treciprocal_value(packets_per_slave);\n\t} else {\n\t\t \n\t\tparams->reciprocal_packets_per_slave =\n\t\t\t(struct reciprocal_value) { 0 };\n\t}\n\n\tif (primary)\n\t\tstrscpy_pad(params->primary, primary, sizeof(params->primary));\n\n\tmemcpy(params->arp_targets, arp_target, sizeof(arp_target));\n#if IS_ENABLED(CONFIG_IPV6)\n\tmemset(params->ns_targets, 0, sizeof(struct in6_addr) * BOND_MAX_NS_TARGETS);\n#endif\n\n\treturn 0;\n}\n\n \nstatic int bond_init(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\n\n\tnetdev_dbg(bond_dev, \"Begin bond_init\\n\");\n\n\tbond->wq = alloc_ordered_workqueue(bond_dev->name, WQ_MEM_RECLAIM);\n\tif (!bond->wq)\n\t\treturn -ENOMEM;\n\n\tbond->notifier_ctx = false;\n\n\tspin_lock_init(&bond->stats_lock);\n\tnetdev_lockdep_set_classes(bond_dev);\n\n\tlist_add_tail(&bond->bond_list, &bn->dev_list);\n\n\tbond_prepare_sysfs_group(bond);\n\n\tbond_debug_register(bond);\n\n\t \n\tif (is_zero_ether_addr(bond_dev->dev_addr) &&\n\t    bond_dev->addr_assign_type == NET_ADDR_PERM)\n\t\teth_hw_addr_random(bond_dev);\n\n\treturn 0;\n}\n\nunsigned int bond_get_num_tx_queues(void)\n{\n\treturn tx_queues;\n}\n\n \nint bond_create(struct net *net, const char *name)\n{\n\tstruct net_device *bond_dev;\n\tstruct bonding *bond;\n\tint res = -ENOMEM;\n\n\trtnl_lock();\n\n\tbond_dev = alloc_netdev_mq(sizeof(struct bonding),\n\t\t\t\t   name ? name : \"bond%d\", NET_NAME_UNKNOWN,\n\t\t\t\t   bond_setup, tx_queues);\n\tif (!bond_dev)\n\t\tgoto out;\n\n\tbond = netdev_priv(bond_dev);\n\tdev_net_set(bond_dev, net);\n\tbond_dev->rtnl_link_ops = &bond_link_ops;\n\n\tres = register_netdevice(bond_dev);\n\tif (res < 0) {\n\t\tfree_netdev(bond_dev);\n\t\tgoto out;\n\t}\n\n\tnetif_carrier_off(bond_dev);\n\n\tbond_work_init_all(bond);\n\nout:\n\trtnl_unlock();\n\treturn res;\n}\n\nstatic int __net_init bond_net_init(struct net *net)\n{\n\tstruct bond_net *bn = net_generic(net, bond_net_id);\n\n\tbn->net = net;\n\tINIT_LIST_HEAD(&bn->dev_list);\n\n\tbond_create_proc_dir(bn);\n\tbond_create_sysfs(bn);\n\n\treturn 0;\n}\n\nstatic void __net_exit bond_net_exit_batch(struct list_head *net_list)\n{\n\tstruct bond_net *bn;\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tbn = net_generic(net, bond_net_id);\n\t\tbond_destroy_sysfs(bn);\n\t}\n\n\t \n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tstruct bonding *bond, *tmp_bond;\n\n\t\tbn = net_generic(net, bond_net_id);\n\t\tlist_for_each_entry_safe(bond, tmp_bond, &bn->dev_list, bond_list)\n\t\t\tunregister_netdevice_queue(bond->dev, &list);\n\t}\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tbn = net_generic(net, bond_net_id);\n\t\tbond_destroy_proc_dir(bn);\n\t}\n}\n\nstatic struct pernet_operations bond_net_ops = {\n\t.init = bond_net_init,\n\t.exit_batch = bond_net_exit_batch,\n\t.id   = &bond_net_id,\n\t.size = sizeof(struct bond_net),\n};\n\nstatic int __init bonding_init(void)\n{\n\tint i;\n\tint res;\n\n\tres = bond_check_params(&bonding_defaults);\n\tif (res)\n\t\tgoto out;\n\n\tres = register_pernet_subsys(&bond_net_ops);\n\tif (res)\n\t\tgoto out;\n\n\tres = bond_netlink_init();\n\tif (res)\n\t\tgoto err_link;\n\n\tbond_create_debugfs();\n\n\tfor (i = 0; i < max_bonds; i++) {\n\t\tres = bond_create(&init_net, NULL);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\tskb_flow_dissector_init(&flow_keys_bonding,\n\t\t\t\tflow_keys_bonding_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_bonding_keys));\n\n\tregister_netdevice_notifier(&bond_netdev_notifier);\nout:\n\treturn res;\nerr:\n\tbond_destroy_debugfs();\n\tbond_netlink_fini();\nerr_link:\n\tunregister_pernet_subsys(&bond_net_ops);\n\tgoto out;\n\n}\n\nstatic void __exit bonding_exit(void)\n{\n\tunregister_netdevice_notifier(&bond_netdev_notifier);\n\n\tbond_destroy_debugfs();\n\n\tbond_netlink_fini();\n\tunregister_pernet_subsys(&bond_net_ops);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t \n\tWARN_ON(atomic_read(&netpoll_block_tx));\n#endif\n}\n\nmodule_init(bonding_init);\nmodule_exit(bonding_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(\"Thomas Davis, tadavis@lbl.gov and many others\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}