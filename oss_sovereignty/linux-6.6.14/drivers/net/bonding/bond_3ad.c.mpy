{
  "module_name": "bond_3ad.c",
  "hash_id": "87458c150a26df6f8fa4e8f48ea080b5e2da3c3840c5b3529db54f71df9e1768",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_3ad.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bonding.h>\n#include <linux/pkt_sched.h>\n#include <net/net_namespace.h>\n#include <net/bonding.h>\n#include <net/bond_3ad.h>\n#include <net/netlink.h>\n\n \n#define AD_SHORT_TIMEOUT           1\n#define AD_LONG_TIMEOUT            0\n#define AD_STANDBY                 0x2\n#define AD_MAX_TX_IN_SECOND        3\n#define AD_COLLECTOR_MAX_DELAY     0\n\n \n#define AD_FAST_PERIODIC_TIME      1\n#define AD_SLOW_PERIODIC_TIME      30\n#define AD_SHORT_TIMEOUT_TIME      (3*AD_FAST_PERIODIC_TIME)\n#define AD_LONG_TIMEOUT_TIME       (3*AD_SLOW_PERIODIC_TIME)\n#define AD_CHURN_DETECTION_TIME    60\n#define AD_AGGREGATE_WAIT_TIME     2\n\n \n#define AD_PORT_BEGIN           0x1\n#define AD_PORT_LACP_ENABLED    0x2\n#define AD_PORT_ACTOR_CHURN     0x4\n#define AD_PORT_PARTNER_CHURN   0x8\n#define AD_PORT_READY           0x10\n#define AD_PORT_READY_N         0x20\n#define AD_PORT_MATCHED         0x40\n#define AD_PORT_STANDBY         0x80\n#define AD_PORT_SELECTED        0x100\n#define AD_PORT_MOVED           0x200\n#define AD_PORT_CHURNED         (AD_PORT_ACTOR_CHURN | AD_PORT_PARTNER_CHURN)\n\n \n#define  AD_DUPLEX_KEY_MASKS    0x1\n#define  AD_SPEED_KEY_MASKS     0x3E\n#define  AD_USER_KEY_MASKS      0xFFC0\n\nenum ad_link_speed_type {\n\tAD_LINK_SPEED_1MBPS = 1,\n\tAD_LINK_SPEED_10MBPS,\n\tAD_LINK_SPEED_100MBPS,\n\tAD_LINK_SPEED_1000MBPS,\n\tAD_LINK_SPEED_2500MBPS,\n\tAD_LINK_SPEED_5000MBPS,\n\tAD_LINK_SPEED_10000MBPS,\n\tAD_LINK_SPEED_14000MBPS,\n\tAD_LINK_SPEED_20000MBPS,\n\tAD_LINK_SPEED_25000MBPS,\n\tAD_LINK_SPEED_40000MBPS,\n\tAD_LINK_SPEED_50000MBPS,\n\tAD_LINK_SPEED_56000MBPS,\n\tAD_LINK_SPEED_100000MBPS,\n\tAD_LINK_SPEED_200000MBPS,\n\tAD_LINK_SPEED_400000MBPS,\n\tAD_LINK_SPEED_800000MBPS,\n};\n\n \n#define MAC_ADDRESS_EQUAL(A, B)\t\\\n\tether_addr_equal_64bits((const u8 *)A, (const u8 *)B)\n\nstatic const u8 null_mac_addr[ETH_ALEN + 2] __long_aligned = {\n\t0, 0, 0, 0, 0, 0\n};\n\nstatic const u16 ad_ticks_per_sec = 1000 / AD_TIMER_INTERVAL;\nstatic const int ad_delta_in_ticks = (AD_TIMER_INTERVAL * HZ) / 1000;\n\nconst u8 lacpdu_mcast_addr[ETH_ALEN + 2] __long_aligned = {\n\t0x01, 0x80, 0xC2, 0x00, 0x00, 0x02\n};\n\n \nstatic int ad_lacpdu_send(struct port *port);\nstatic int ad_marker_send(struct port *port, struct bond_marker *marker);\nstatic void ad_mux_machine(struct port *port, bool *update_slave_arr);\nstatic void ad_rx_machine(struct lacpdu *lacpdu, struct port *port);\nstatic void ad_tx_machine(struct port *port);\nstatic void ad_periodic_machine(struct port *port, struct bond_params *bond_params);\nstatic void ad_port_selection_logic(struct port *port, bool *update_slave_arr);\nstatic void ad_agg_selection_logic(struct aggregator *aggregator,\n\t\t\t\t   bool *update_slave_arr);\nstatic void ad_clear_agg(struct aggregator *aggregator);\nstatic void ad_initialize_agg(struct aggregator *aggregator);\nstatic void ad_initialize_port(struct port *port, int lacp_fast);\nstatic void ad_enable_collecting_distributing(struct port *port,\n\t\t\t\t\t      bool *update_slave_arr);\nstatic void ad_disable_collecting_distributing(struct port *port,\n\t\t\t\t\t       bool *update_slave_arr);\nstatic void ad_marker_info_received(struct bond_marker *marker_info,\n\t\t\t\t    struct port *port);\nstatic void ad_marker_response_received(struct bond_marker *marker,\n\t\t\t\t\tstruct port *port);\nstatic void ad_update_actor_keys(struct port *port, bool reset);\n\n\n \n\n \nstatic inline struct bonding *__get_bond_by_port(struct port *port)\n{\n\tif (port->slave == NULL)\n\t\treturn NULL;\n\n\treturn bond_get_bond_by_slave(port->slave);\n}\n\n \nstatic inline struct aggregator *__get_first_agg(struct port *port)\n{\n\tstruct bonding *bond = __get_bond_by_port(port);\n\tstruct slave *first_slave;\n\tstruct aggregator *agg;\n\n\t \n\tif (bond == NULL)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfirst_slave = bond_first_slave_rcu(bond);\n\tagg = first_slave ? &(SLAVE_AD_INFO(first_slave)->aggregator) : NULL;\n\trcu_read_unlock();\n\n\treturn agg;\n}\n\n \nstatic inline int __agg_has_partner(struct aggregator *agg)\n{\n\treturn !is_zero_ether_addr(agg->partner_system.mac_addr_value);\n}\n\n \nstatic inline void __disable_port(struct port *port)\n{\n\tbond_set_slave_inactive_flags(port->slave, BOND_SLAVE_NOTIFY_LATER);\n}\n\n \nstatic inline void __enable_port(struct port *port)\n{\n\tstruct slave *slave = port->slave;\n\n\tif ((slave->link == BOND_LINK_UP) && bond_slave_is_up(slave))\n\t\tbond_set_slave_active_flags(slave, BOND_SLAVE_NOTIFY_LATER);\n}\n\n \nstatic inline int __port_is_enabled(struct port *port)\n{\n\treturn bond_is_active_slave(port->slave);\n}\n\n \nstatic inline u32 __get_agg_selection_mode(struct port *port)\n{\n\tstruct bonding *bond = __get_bond_by_port(port);\n\n\tif (bond == NULL)\n\t\treturn BOND_AD_STABLE;\n\n\treturn bond->params.ad_select;\n}\n\n \nstatic inline int __check_agg_selection_timer(struct port *port)\n{\n\tstruct bonding *bond = __get_bond_by_port(port);\n\n\tif (bond == NULL)\n\t\treturn 0;\n\n\treturn atomic_read(&BOND_AD_INFO(bond).agg_select_timer) ? 1 : 0;\n}\n\n \nstatic u16 __get_link_speed(struct port *port)\n{\n\tstruct slave *slave = port->slave;\n\tu16 speed;\n\n\t \n\tif (slave->link != BOND_LINK_UP)\n\t\tspeed = 0;\n\telse {\n\t\tswitch (slave->speed) {\n\t\tcase SPEED_10:\n\t\t\tspeed = AD_LINK_SPEED_10MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_100:\n\t\t\tspeed = AD_LINK_SPEED_100MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_1000:\n\t\t\tspeed = AD_LINK_SPEED_1000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_2500:\n\t\t\tspeed = AD_LINK_SPEED_2500MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_5000:\n\t\t\tspeed = AD_LINK_SPEED_5000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_10000:\n\t\t\tspeed = AD_LINK_SPEED_10000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_14000:\n\t\t\tspeed = AD_LINK_SPEED_14000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_20000:\n\t\t\tspeed = AD_LINK_SPEED_20000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_25000:\n\t\t\tspeed = AD_LINK_SPEED_25000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_40000:\n\t\t\tspeed = AD_LINK_SPEED_40000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_50000:\n\t\t\tspeed = AD_LINK_SPEED_50000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_56000:\n\t\t\tspeed = AD_LINK_SPEED_56000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_100000:\n\t\t\tspeed = AD_LINK_SPEED_100000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_200000:\n\t\t\tspeed = AD_LINK_SPEED_200000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_400000:\n\t\t\tspeed = AD_LINK_SPEED_400000MBPS;\n\t\t\tbreak;\n\n\t\tcase SPEED_800000:\n\t\t\tspeed = AD_LINK_SPEED_800000MBPS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (slave->speed != SPEED_UNKNOWN)\n\t\t\t\tpr_err_once(\"%s: (slave %s): unknown ethtool speed (%d) for port %d (set it to 0)\\n\",\n\t\t\t\t\t    slave->bond->dev->name,\n\t\t\t\t\t    slave->dev->name, slave->speed,\n\t\t\t\t\t    port->actor_port_number);\n\t\t\tspeed = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tslave_dbg(slave->bond->dev, slave->dev, \"Port %d Received link speed %d update from adapter\\n\",\n\t\t  port->actor_port_number, speed);\n\treturn speed;\n}\n\n \nstatic u8 __get_duplex(struct port *port)\n{\n\tstruct slave *slave = port->slave;\n\tu8 retval = 0x0;\n\n\t \n\tif (slave->link == BOND_LINK_UP) {\n\t\tswitch (slave->duplex) {\n\t\tcase DUPLEX_FULL:\n\t\t\tretval = 0x1;\n\t\t\tslave_dbg(slave->bond->dev, slave->dev, \"Port %d Received status full duplex update from adapter\\n\",\n\t\t\t\t  port->actor_port_number);\n\t\t\tbreak;\n\t\tcase DUPLEX_HALF:\n\t\tdefault:\n\t\t\tretval = 0x0;\n\t\t\tslave_dbg(slave->bond->dev, slave->dev, \"Port %d Received status NOT full duplex update from adapter\\n\",\n\t\t\t\t  port->actor_port_number);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn retval;\n}\n\nstatic void __ad_actor_update_port(struct port *port)\n{\n\tconst struct bonding *bond = bond_get_bond_by_slave(port->slave);\n\n\tport->actor_system = BOND_AD_INFO(bond).system.sys_mac_addr;\n\tport->actor_system_priority = BOND_AD_INFO(bond).system.sys_priority;\n}\n\n \n\n \nstatic u16 __ad_timer_to_ticks(u16 timer_type, u16 par)\n{\n\tu16 retval = 0;  \n\n\tswitch (timer_type) {\n\tcase AD_CURRENT_WHILE_TIMER:\t \n\t\tif (par)\n\t\t\tretval = (AD_SHORT_TIMEOUT_TIME*ad_ticks_per_sec);\n\t\telse\n\t\t\tretval = (AD_LONG_TIMEOUT_TIME*ad_ticks_per_sec);\n\t\tbreak;\n\tcase AD_ACTOR_CHURN_TIMER:\t \n\t\tretval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);\n\t\tbreak;\n\tcase AD_PERIODIC_TIMER:\t\t \n\t\tretval = (par*ad_ticks_per_sec);  \n\t\tbreak;\n\tcase AD_PARTNER_CHURN_TIMER:\t \n\t\tretval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);\n\t\tbreak;\n\tcase AD_WAIT_WHILE_TIMER:\t \n\t\tretval = (AD_AGGREGATE_WAIT_TIME*ad_ticks_per_sec);\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n\n \n\n \nstatic void __choose_matched(struct lacpdu *lacpdu, struct port *port)\n{\n\t \n\tif (((ntohs(lacpdu->partner_port) == port->actor_port_number) &&\n\t     (ntohs(lacpdu->partner_port_priority) == port->actor_port_priority) &&\n\t     MAC_ADDRESS_EQUAL(&(lacpdu->partner_system), &(port->actor_system)) &&\n\t     (ntohs(lacpdu->partner_system_priority) == port->actor_system_priority) &&\n\t     (ntohs(lacpdu->partner_key) == port->actor_oper_port_key) &&\n\t     ((lacpdu->partner_state & LACP_STATE_AGGREGATION) == (port->actor_oper_port_state & LACP_STATE_AGGREGATION))) ||\n\t    ((lacpdu->actor_state & LACP_STATE_AGGREGATION) == 0)\n\t\t) {\n\t\tport->sm_vars |= AD_PORT_MATCHED;\n\t} else {\n\t\tport->sm_vars &= ~AD_PORT_MATCHED;\n\t}\n}\n\n \nstatic void __record_pdu(struct lacpdu *lacpdu, struct port *port)\n{\n\tif (lacpdu && port) {\n\t\tstruct port_params *partner = &port->partner_oper;\n\n\t\t__choose_matched(lacpdu, port);\n\t\t \n\t\tpartner->port_number = ntohs(lacpdu->actor_port);\n\t\tpartner->port_priority = ntohs(lacpdu->actor_port_priority);\n\t\tpartner->system = lacpdu->actor_system;\n\t\tpartner->system_priority = ntohs(lacpdu->actor_system_priority);\n\t\tpartner->key = ntohs(lacpdu->actor_key);\n\t\tpartner->port_state = lacpdu->actor_state;\n\n\t\t \n\t\tport->actor_oper_port_state &= ~LACP_STATE_DEFAULTED;\n\n\t\t \n\t\tif ((port->sm_vars & AD_PORT_MATCHED) &&\n\t\t    (lacpdu->actor_state & LACP_STATE_SYNCHRONIZATION)) {\n\t\t\tpartner->port_state |= LACP_STATE_SYNCHRONIZATION;\n\t\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t\t  \"partner sync=1\\n\");\n\t\t} else {\n\t\t\tpartner->port_state &= ~LACP_STATE_SYNCHRONIZATION;\n\t\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t\t  \"partner sync=0\\n\");\n\t\t}\n\t}\n}\n\n \nstatic void __record_default(struct port *port)\n{\n\tif (port) {\n\t\t \n\t\tmemcpy(&port->partner_oper, &port->partner_admin,\n\t\t       sizeof(struct port_params));\n\n\t\t \n\t\tport->actor_oper_port_state |= LACP_STATE_DEFAULTED;\n\t}\n}\n\n \nstatic void __update_selected(struct lacpdu *lacpdu, struct port *port)\n{\n\tif (lacpdu && port) {\n\t\tconst struct port_params *partner = &port->partner_oper;\n\n\t\t \n\t\tif (ntohs(lacpdu->actor_port) != partner->port_number ||\n\t\t    ntohs(lacpdu->actor_port_priority) != partner->port_priority ||\n\t\t    !MAC_ADDRESS_EQUAL(&lacpdu->actor_system, &partner->system) ||\n\t\t    ntohs(lacpdu->actor_system_priority) != partner->system_priority ||\n\t\t    ntohs(lacpdu->actor_key) != partner->key ||\n\t\t    (lacpdu->actor_state & LACP_STATE_AGGREGATION) != (partner->port_state & LACP_STATE_AGGREGATION)) {\n\t\t\tport->sm_vars &= ~AD_PORT_SELECTED;\n\t\t}\n\t}\n}\n\n \nstatic void __update_default_selected(struct port *port)\n{\n\tif (port) {\n\t\tconst struct port_params *admin = &port->partner_admin;\n\t\tconst struct port_params *oper = &port->partner_oper;\n\n\t\t \n\t\tif (admin->port_number != oper->port_number ||\n\t\t    admin->port_priority != oper->port_priority ||\n\t\t    !MAC_ADDRESS_EQUAL(&admin->system, &oper->system) ||\n\t\t    admin->system_priority != oper->system_priority ||\n\t\t    admin->key != oper->key ||\n\t\t    (admin->port_state & LACP_STATE_AGGREGATION)\n\t\t\t!= (oper->port_state & LACP_STATE_AGGREGATION)) {\n\t\t\tport->sm_vars &= ~AD_PORT_SELECTED;\n\t\t}\n\t}\n}\n\n \nstatic void __update_ntt(struct lacpdu *lacpdu, struct port *port)\n{\n\t \n\tif (lacpdu && port) {\n\t\t \n\t\tif ((ntohs(lacpdu->partner_port) != port->actor_port_number) ||\n\t\t    (ntohs(lacpdu->partner_port_priority) != port->actor_port_priority) ||\n\t\t    !MAC_ADDRESS_EQUAL(&(lacpdu->partner_system), &(port->actor_system)) ||\n\t\t    (ntohs(lacpdu->partner_system_priority) != port->actor_system_priority) ||\n\t\t    (ntohs(lacpdu->partner_key) != port->actor_oper_port_key) ||\n\t\t    ((lacpdu->partner_state & LACP_STATE_LACP_ACTIVITY) != (port->actor_oper_port_state & LACP_STATE_LACP_ACTIVITY)) ||\n\t\t    ((lacpdu->partner_state & LACP_STATE_LACP_TIMEOUT) != (port->actor_oper_port_state & LACP_STATE_LACP_TIMEOUT)) ||\n\t\t    ((lacpdu->partner_state & LACP_STATE_SYNCHRONIZATION) != (port->actor_oper_port_state & LACP_STATE_SYNCHRONIZATION)) ||\n\t\t    ((lacpdu->partner_state & LACP_STATE_AGGREGATION) != (port->actor_oper_port_state & LACP_STATE_AGGREGATION))\n\t\t   ) {\n\t\t\tport->ntt = true;\n\t\t}\n\t}\n}\n\n \nstatic int __agg_ports_are_ready(struct aggregator *aggregator)\n{\n\tstruct port *port;\n\tint retval = 1;\n\n\tif (aggregator) {\n\t\t \n\t\tfor (port = aggregator->lag_ports;\n\t\t     port;\n\t\t     port = port->next_port_in_aggregator) {\n\t\t\tif (!(port->sm_vars & AD_PORT_READY_N)) {\n\t\t\t\tretval = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nstatic void __set_agg_ports_ready(struct aggregator *aggregator, int val)\n{\n\tstruct port *port;\n\n\tfor (port = aggregator->lag_ports; port;\n\t     port = port->next_port_in_aggregator) {\n\t\tif (val)\n\t\t\tport->sm_vars |= AD_PORT_READY;\n\t\telse\n\t\t\tport->sm_vars &= ~AD_PORT_READY;\n\t}\n}\n\nstatic int __agg_active_ports(struct aggregator *agg)\n{\n\tstruct port *port;\n\tint active = 0;\n\n\tfor (port = agg->lag_ports; port;\n\t     port = port->next_port_in_aggregator) {\n\t\tif (port->is_enabled)\n\t\t\tactive++;\n\t}\n\n\treturn active;\n}\n\n \nstatic u32 __get_agg_bandwidth(struct aggregator *aggregator)\n{\n\tint nports = __agg_active_ports(aggregator);\n\tu32 bandwidth = 0;\n\n\tif (nports) {\n\t\tswitch (__get_link_speed(aggregator->lag_ports)) {\n\t\tcase AD_LINK_SPEED_1MBPS:\n\t\t\tbandwidth = nports;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_10MBPS:\n\t\t\tbandwidth = nports * 10;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_100MBPS:\n\t\t\tbandwidth = nports * 100;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_1000MBPS:\n\t\t\tbandwidth = nports * 1000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_2500MBPS:\n\t\t\tbandwidth = nports * 2500;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_5000MBPS:\n\t\t\tbandwidth = nports * 5000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_10000MBPS:\n\t\t\tbandwidth = nports * 10000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_14000MBPS:\n\t\t\tbandwidth = nports * 14000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_20000MBPS:\n\t\t\tbandwidth = nports * 20000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_25000MBPS:\n\t\t\tbandwidth = nports * 25000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_40000MBPS:\n\t\t\tbandwidth = nports * 40000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_50000MBPS:\n\t\t\tbandwidth = nports * 50000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_56000MBPS:\n\t\t\tbandwidth = nports * 56000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_100000MBPS:\n\t\t\tbandwidth = nports * 100000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_200000MBPS:\n\t\t\tbandwidth = nports * 200000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_400000MBPS:\n\t\t\tbandwidth = nports * 400000;\n\t\t\tbreak;\n\t\tcase AD_LINK_SPEED_800000MBPS:\n\t\t\tbandwidth = nports * 800000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbandwidth = 0;  \n\t\t}\n\t}\n\treturn bandwidth;\n}\n\n \nstatic struct aggregator *__get_active_agg(struct aggregator *aggregator)\n{\n\tstruct bonding *bond = aggregator->slave->bond;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tbond_for_each_slave_rcu(bond, slave, iter)\n\t\tif (SLAVE_AD_INFO(slave)->aggregator.is_active)\n\t\t\treturn &(SLAVE_AD_INFO(slave)->aggregator);\n\n\treturn NULL;\n}\n\n \nstatic inline void __update_lacpdu_from_port(struct port *port)\n{\n\tstruct lacpdu *lacpdu = &port->lacpdu;\n\tconst struct port_params *partner = &port->partner_oper;\n\n\t \n\n\tlacpdu->actor_system_priority = htons(port->actor_system_priority);\n\tlacpdu->actor_system = port->actor_system;\n\tlacpdu->actor_key = htons(port->actor_oper_port_key);\n\tlacpdu->actor_port_priority = htons(port->actor_port_priority);\n\tlacpdu->actor_port = htons(port->actor_port_number);\n\tlacpdu->actor_state = port->actor_oper_port_state;\n\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t  \"update lacpdu: actor port state %x\\n\",\n\t\t  port->actor_oper_port_state);\n\n\t \n\n\tlacpdu->partner_system_priority = htons(partner->system_priority);\n\tlacpdu->partner_system = partner->system;\n\tlacpdu->partner_key = htons(partner->key);\n\tlacpdu->partner_port_priority = htons(partner->port_priority);\n\tlacpdu->partner_port = htons(partner->port_number);\n\tlacpdu->partner_state = partner->port_state;\n\n\t \n}\n\n \n\n \nstatic int ad_lacpdu_send(struct port *port)\n{\n\tstruct slave *slave = port->slave;\n\tstruct sk_buff *skb;\n\tstruct lacpdu_header *lacpdu_header;\n\tint length = sizeof(struct lacpdu_header);\n\n\tskb = dev_alloc_skb(length);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tatomic64_inc(&SLAVE_AD_INFO(slave)->stats.lacpdu_tx);\n\tatomic64_inc(&BOND_AD_INFO(slave->bond).stats.lacpdu_tx);\n\n\tskb->dev = slave->dev;\n\tskb_reset_mac_header(skb);\n\tskb->network_header = skb->mac_header + ETH_HLEN;\n\tskb->protocol = PKT_TYPE_LACPDU;\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tlacpdu_header = skb_put(skb, length);\n\n\tether_addr_copy(lacpdu_header->hdr.h_dest, lacpdu_mcast_addr);\n\t \n\tether_addr_copy(lacpdu_header->hdr.h_source, slave->perm_hwaddr);\n\tlacpdu_header->hdr.h_proto = PKT_TYPE_LACPDU;\n\n\tlacpdu_header->lacpdu = port->lacpdu;\n\n\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n \nstatic int ad_marker_send(struct port *port, struct bond_marker *marker)\n{\n\tstruct slave *slave = port->slave;\n\tstruct sk_buff *skb;\n\tstruct bond_marker_header *marker_header;\n\tint length = sizeof(struct bond_marker_header);\n\n\tskb = dev_alloc_skb(length + 16);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tswitch (marker->tlv_type) {\n\tcase AD_MARKER_INFORMATION_SUBTYPE:\n\t\tatomic64_inc(&SLAVE_AD_INFO(slave)->stats.marker_tx);\n\t\tatomic64_inc(&BOND_AD_INFO(slave->bond).stats.marker_tx);\n\t\tbreak;\n\tcase AD_MARKER_RESPONSE_SUBTYPE:\n\t\tatomic64_inc(&SLAVE_AD_INFO(slave)->stats.marker_resp_tx);\n\t\tatomic64_inc(&BOND_AD_INFO(slave->bond).stats.marker_resp_tx);\n\t\tbreak;\n\t}\n\n\tskb_reserve(skb, 16);\n\n\tskb->dev = slave->dev;\n\tskb_reset_mac_header(skb);\n\tskb->network_header = skb->mac_header + ETH_HLEN;\n\tskb->protocol = PKT_TYPE_LACPDU;\n\n\tmarker_header = skb_put(skb, length);\n\n\tether_addr_copy(marker_header->hdr.h_dest, lacpdu_mcast_addr);\n\t \n\tether_addr_copy(marker_header->hdr.h_source, slave->perm_hwaddr);\n\tmarker_header->hdr.h_proto = PKT_TYPE_LACPDU;\n\n\tmarker_header->marker = *marker;\n\n\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n \nstatic void ad_mux_machine(struct port *port, bool *update_slave_arr)\n{\n\tmux_states_t last_state;\n\n\t \n\tlast_state = port->sm_mux_state;\n\n\tif (port->sm_vars & AD_PORT_BEGIN) {\n\t\tport->sm_mux_state = AD_MUX_DETACHED;\n\t} else {\n\t\tswitch (port->sm_mux_state) {\n\t\tcase AD_MUX_DETACHED:\n\t\t\tif ((port->sm_vars & AD_PORT_SELECTED)\n\t\t\t    || (port->sm_vars & AD_PORT_STANDBY))\n\t\t\t\t \n\t\t\t\tport->sm_mux_state = AD_MUX_WAITING;\n\t\t\tbreak;\n\t\tcase AD_MUX_WAITING:\n\t\t\t \n\t\t\tif (!(port->sm_vars & AD_PORT_SELECTED)) {\n\t\t\t\tport->sm_vars &= ~AD_PORT_READY_N;\n\t\t\t\t \n\t\t\t\t__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\n\t\t\t\tport->sm_mux_state = AD_MUX_DETACHED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (port->sm_mux_timer_counter\n\t\t\t    && !(--port->sm_mux_timer_counter))\n\t\t\t\tport->sm_vars |= AD_PORT_READY_N;\n\n\t\t\t \n\t\t\t__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\n\n\t\t\t \n\t\t\tif ((port->sm_vars & AD_PORT_READY)\n\t\t\t    && !port->sm_mux_timer_counter)\n\t\t\t\tport->sm_mux_state = AD_MUX_ATTACHED;\n\t\t\tbreak;\n\t\tcase AD_MUX_ATTACHED:\n\t\t\t \n\t\t\tif ((port->sm_vars & AD_PORT_SELECTED) &&\n\t\t\t    (port->partner_oper.port_state & LACP_STATE_SYNCHRONIZATION) &&\n\t\t\t    !__check_agg_selection_timer(port)) {\n\t\t\t\tif (port->aggregator->is_active)\n\t\t\t\t\tport->sm_mux_state =\n\t\t\t\t\t    AD_MUX_COLLECTING_DISTRIBUTING;\n\t\t\t} else if (!(port->sm_vars & AD_PORT_SELECTED) ||\n\t\t\t\t   (port->sm_vars & AD_PORT_STANDBY)) {\n\t\t\t\t \n\t\t\t\tport->sm_vars &= ~AD_PORT_READY_N;\n\t\t\t\t \n\t\t\t\t__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\n\t\t\t\tport->sm_mux_state = AD_MUX_DETACHED;\n\t\t\t} else if (port->aggregator->is_active) {\n\t\t\t\tport->actor_oper_port_state |=\n\t\t\t\t    LACP_STATE_SYNCHRONIZATION;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AD_MUX_COLLECTING_DISTRIBUTING:\n\t\t\tif (!(port->sm_vars & AD_PORT_SELECTED) ||\n\t\t\t    (port->sm_vars & AD_PORT_STANDBY) ||\n\t\t\t    !(port->partner_oper.port_state & LACP_STATE_SYNCHRONIZATION) ||\n\t\t\t    !(port->actor_oper_port_state & LACP_STATE_SYNCHRONIZATION)) {\n\t\t\t\tport->sm_mux_state = AD_MUX_ATTACHED;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (port->aggregator &&\n\t\t\t\t    port->aggregator->is_active &&\n\t\t\t\t    !__port_is_enabled(port)) {\n\t\t\t\t\t__enable_port(port);\n\t\t\t\t\t*update_slave_arr = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (port->sm_mux_state != last_state) {\n\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t  \"Mux Machine: Port=%d, Last State=%d, Curr State=%d\\n\",\n\t\t\t  port->actor_port_number,\n\t\t\t  last_state,\n\t\t\t  port->sm_mux_state);\n\t\tswitch (port->sm_mux_state) {\n\t\tcase AD_MUX_DETACHED:\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_SYNCHRONIZATION;\n\t\t\tad_disable_collecting_distributing(port,\n\t\t\t\t\t\t\t   update_slave_arr);\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_COLLECTING;\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_DISTRIBUTING;\n\t\t\tport->ntt = true;\n\t\t\tbreak;\n\t\tcase AD_MUX_WAITING:\n\t\t\tport->sm_mux_timer_counter = __ad_timer_to_ticks(AD_WAIT_WHILE_TIMER, 0);\n\t\t\tbreak;\n\t\tcase AD_MUX_ATTACHED:\n\t\t\tif (port->aggregator->is_active)\n\t\t\t\tport->actor_oper_port_state |=\n\t\t\t\t    LACP_STATE_SYNCHRONIZATION;\n\t\t\telse\n\t\t\t\tport->actor_oper_port_state &=\n\t\t\t\t    ~LACP_STATE_SYNCHRONIZATION;\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_COLLECTING;\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_DISTRIBUTING;\n\t\t\tad_disable_collecting_distributing(port,\n\t\t\t\t\t\t\t   update_slave_arr);\n\t\t\tport->ntt = true;\n\t\t\tbreak;\n\t\tcase AD_MUX_COLLECTING_DISTRIBUTING:\n\t\t\tport->actor_oper_port_state |= LACP_STATE_COLLECTING;\n\t\t\tport->actor_oper_port_state |= LACP_STATE_DISTRIBUTING;\n\t\t\tport->actor_oper_port_state |= LACP_STATE_SYNCHRONIZATION;\n\t\t\tad_enable_collecting_distributing(port,\n\t\t\t\t\t\t\t  update_slave_arr);\n\t\t\tport->ntt = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void ad_rx_machine(struct lacpdu *lacpdu, struct port *port)\n{\n\trx_states_t last_state;\n\n\t \n\tlast_state = port->sm_rx_state;\n\n\tif (lacpdu) {\n\t\tatomic64_inc(&SLAVE_AD_INFO(port->slave)->stats.lacpdu_rx);\n\t\tatomic64_inc(&BOND_AD_INFO(port->slave->bond).stats.lacpdu_rx);\n\t}\n\t \n\n\t \n\tif (port->sm_vars & AD_PORT_BEGIN) {\n\t\tport->sm_rx_state = AD_RX_INITIALIZE;\n\t\tport->sm_vars |= AD_PORT_CHURNED;\n\t \n\t} else if (!(port->sm_vars & AD_PORT_BEGIN) && !port->is_enabled)\n\t\tport->sm_rx_state = AD_RX_PORT_DISABLED;\n\t \n\telse if (lacpdu && ((port->sm_rx_state == AD_RX_EXPIRED) ||\n\t\t (port->sm_rx_state == AD_RX_DEFAULTED) ||\n\t\t (port->sm_rx_state == AD_RX_CURRENT))) {\n\t\tif (port->sm_rx_state != AD_RX_CURRENT)\n\t\t\tport->sm_vars |= AD_PORT_CHURNED;\n\t\tport->sm_rx_timer_counter = 0;\n\t\tport->sm_rx_state = AD_RX_CURRENT;\n\t} else {\n\t\t \n\t\tif (port->sm_rx_timer_counter &&\n\t\t    !(--port->sm_rx_timer_counter)) {\n\t\t\tswitch (port->sm_rx_state) {\n\t\t\tcase AD_RX_EXPIRED:\n\t\t\t\tport->sm_rx_state = AD_RX_DEFAULTED;\n\t\t\t\tbreak;\n\t\t\tcase AD_RX_CURRENT:\n\t\t\t\tport->sm_rx_state = AD_RX_EXPIRED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (port->sm_rx_state) {\n\t\t\tcase AD_RX_PORT_DISABLED:\n\t\t\t\tif (port->is_enabled &&\n\t\t\t\t    (port->sm_vars & AD_PORT_LACP_ENABLED))\n\t\t\t\t\tport->sm_rx_state = AD_RX_EXPIRED;\n\t\t\t\telse if (port->is_enabled\n\t\t\t\t\t && ((port->sm_vars\n\t\t\t\t\t      & AD_PORT_LACP_ENABLED) == 0))\n\t\t\t\t\tport->sm_rx_state = AD_RX_LACP_DISABLED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((port->sm_rx_state != last_state) || (lacpdu)) {\n\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t  \"Rx Machine: Port=%d, Last State=%d, Curr State=%d\\n\",\n\t\t\t  port->actor_port_number,\n\t\t\t  last_state,\n\t\t\t  port->sm_rx_state);\n\t\tswitch (port->sm_rx_state) {\n\t\tcase AD_RX_INITIALIZE:\n\t\t\tif (!(port->actor_oper_port_key & AD_DUPLEX_KEY_MASKS))\n\t\t\t\tport->sm_vars &= ~AD_PORT_LACP_ENABLED;\n\t\t\telse\n\t\t\t\tport->sm_vars |= AD_PORT_LACP_ENABLED;\n\t\t\tport->sm_vars &= ~AD_PORT_SELECTED;\n\t\t\t__record_default(port);\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_EXPIRED;\n\t\t\tport->sm_rx_state = AD_RX_PORT_DISABLED;\n\n\t\t\tfallthrough;\n\t\tcase AD_RX_PORT_DISABLED:\n\t\t\tport->sm_vars &= ~AD_PORT_MATCHED;\n\t\t\tbreak;\n\t\tcase AD_RX_LACP_DISABLED:\n\t\t\tport->sm_vars &= ~AD_PORT_SELECTED;\n\t\t\t__record_default(port);\n\t\t\tport->partner_oper.port_state &= ~LACP_STATE_AGGREGATION;\n\t\t\tport->sm_vars |= AD_PORT_MATCHED;\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_EXPIRED;\n\t\t\tbreak;\n\t\tcase AD_RX_EXPIRED:\n\t\t\t \n\t\t\tport->partner_oper.port_state &= ~LACP_STATE_SYNCHRONIZATION;\n\t\t\tport->sm_vars &= ~AD_PORT_MATCHED;\n\t\t\tport->partner_oper.port_state |= LACP_STATE_LACP_TIMEOUT;\n\t\t\tport->partner_oper.port_state |= LACP_STATE_LACP_ACTIVITY;\n\t\t\tport->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(AD_SHORT_TIMEOUT));\n\t\t\tport->actor_oper_port_state |= LACP_STATE_EXPIRED;\n\t\t\tport->sm_vars |= AD_PORT_CHURNED;\n\t\t\tbreak;\n\t\tcase AD_RX_DEFAULTED:\n\t\t\t__update_default_selected(port);\n\t\t\t__record_default(port);\n\t\t\tport->sm_vars |= AD_PORT_MATCHED;\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_EXPIRED;\n\t\t\tbreak;\n\t\tcase AD_RX_CURRENT:\n\t\t\t \n\t\t\tif (MAC_ADDRESS_EQUAL(&(lacpdu->actor_system),\n\t\t\t\t\t      &(port->actor_system))) {\n\t\t\t\tslave_err(port->slave->bond->dev, port->slave->dev, \"An illegal loopback occurred on slave\\n\"\n\t\t\t\t\t  \"Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t__update_selected(lacpdu, port);\n\t\t\t__update_ntt(lacpdu, port);\n\t\t\t__record_pdu(lacpdu, port);\n\t\t\tport->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(port->actor_oper_port_state & LACP_STATE_LACP_TIMEOUT));\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_EXPIRED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void ad_churn_machine(struct port *port)\n{\n\tif (port->sm_vars & AD_PORT_CHURNED) {\n\t\tport->sm_vars &= ~AD_PORT_CHURNED;\n\t\tport->sm_churn_actor_state = AD_CHURN_MONITOR;\n\t\tport->sm_churn_partner_state = AD_CHURN_MONITOR;\n\t\tport->sm_churn_actor_timer_counter =\n\t\t\t__ad_timer_to_ticks(AD_ACTOR_CHURN_TIMER, 0);\n\t\tport->sm_churn_partner_timer_counter =\n\t\t\t __ad_timer_to_ticks(AD_PARTNER_CHURN_TIMER, 0);\n\t\treturn;\n\t}\n\tif (port->sm_churn_actor_timer_counter &&\n\t    !(--port->sm_churn_actor_timer_counter) &&\n\t    port->sm_churn_actor_state == AD_CHURN_MONITOR) {\n\t\tif (port->actor_oper_port_state & LACP_STATE_SYNCHRONIZATION) {\n\t\t\tport->sm_churn_actor_state = AD_NO_CHURN;\n\t\t} else {\n\t\t\tport->churn_actor_count++;\n\t\t\tport->sm_churn_actor_state = AD_CHURN;\n\t\t}\n\t}\n\tif (port->sm_churn_partner_timer_counter &&\n\t    !(--port->sm_churn_partner_timer_counter) &&\n\t    port->sm_churn_partner_state == AD_CHURN_MONITOR) {\n\t\tif (port->partner_oper.port_state & LACP_STATE_SYNCHRONIZATION) {\n\t\t\tport->sm_churn_partner_state = AD_NO_CHURN;\n\t\t} else {\n\t\t\tport->churn_partner_count++;\n\t\t\tport->sm_churn_partner_state = AD_CHURN;\n\t\t}\n\t}\n}\n\n \nstatic void ad_tx_machine(struct port *port)\n{\n\t \n\tif (port->sm_tx_timer_counter && !(--port->sm_tx_timer_counter)) {\n\t\t \n\t\tif (port->ntt && (port->sm_vars & AD_PORT_LACP_ENABLED)) {\n\t\t\t__update_lacpdu_from_port(port);\n\n\t\t\tif (ad_lacpdu_send(port) >= 0) {\n\t\t\t\tslave_dbg(port->slave->bond->dev,\n\t\t\t\t\t  port->slave->dev,\n\t\t\t\t\t  \"Sent LACPDU on port %d\\n\",\n\t\t\t\t\t  port->actor_port_number);\n\n\t\t\t\t \n\t\t\t\tport->ntt = false;\n\t\t\t}\n\t\t}\n\t\t \n\t\tport->sm_tx_timer_counter = ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;\n\t}\n}\n\n \nstatic void ad_periodic_machine(struct port *port, struct bond_params *bond_params)\n{\n\tperiodic_states_t last_state;\n\n\t \n\tlast_state = port->sm_periodic_state;\n\n\t \n\tif (((port->sm_vars & AD_PORT_BEGIN) || !(port->sm_vars & AD_PORT_LACP_ENABLED) || !port->is_enabled) ||\n\t    (!(port->actor_oper_port_state & LACP_STATE_LACP_ACTIVITY) && !(port->partner_oper.port_state & LACP_STATE_LACP_ACTIVITY)) ||\n\t    !bond_params->lacp_active) {\n\t\tport->sm_periodic_state = AD_NO_PERIODIC;\n\t}\n\t \n\telse if (port->sm_periodic_timer_counter) {\n\t\t \n\t\tif (!(--port->sm_periodic_timer_counter)) {\n\t\t\t \n\t\t\tport->sm_periodic_state = AD_PERIODIC_TX;\n\t\t} else {\n\t\t\t \n\t\t\tswitch (port->sm_periodic_state) {\n\t\t\tcase AD_FAST_PERIODIC:\n\t\t\t\tif (!(port->partner_oper.port_state\n\t\t\t\t      & LACP_STATE_LACP_TIMEOUT))\n\t\t\t\t\tport->sm_periodic_state = AD_SLOW_PERIODIC;\n\t\t\t\tbreak;\n\t\t\tcase AD_SLOW_PERIODIC:\n\t\t\t\tif ((port->partner_oper.port_state & LACP_STATE_LACP_TIMEOUT)) {\n\t\t\t\t\tport->sm_periodic_timer_counter = 0;\n\t\t\t\t\tport->sm_periodic_state = AD_PERIODIC_TX;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (port->sm_periodic_state) {\n\t\tcase AD_NO_PERIODIC:\n\t\t\tport->sm_periodic_state = AD_FAST_PERIODIC;\n\t\t\tbreak;\n\t\tcase AD_PERIODIC_TX:\n\t\t\tif (!(port->partner_oper.port_state &\n\t\t\t    LACP_STATE_LACP_TIMEOUT))\n\t\t\t\tport->sm_periodic_state = AD_SLOW_PERIODIC;\n\t\t\telse\n\t\t\t\tport->sm_periodic_state = AD_FAST_PERIODIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (port->sm_periodic_state != last_state) {\n\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t  \"Periodic Machine: Port=%d, Last State=%d, Curr State=%d\\n\",\n\t\t\t  port->actor_port_number, last_state,\n\t\t\t  port->sm_periodic_state);\n\t\tswitch (port->sm_periodic_state) {\n\t\tcase AD_NO_PERIODIC:\n\t\t\tport->sm_periodic_timer_counter = 0;\n\t\t\tbreak;\n\t\tcase AD_FAST_PERIODIC:\n\t\t\t \n\t\t\tport->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_FAST_PERIODIC_TIME))-1;\n\t\t\tbreak;\n\t\tcase AD_SLOW_PERIODIC:\n\t\t\t \n\t\t\tport->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_SLOW_PERIODIC_TIME))-1;\n\t\t\tbreak;\n\t\tcase AD_PERIODIC_TX:\n\t\t\tport->ntt = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void ad_port_selection_logic(struct port *port, bool *update_slave_arr)\n{\n\tstruct aggregator *aggregator, *free_aggregator = NULL, *temp_aggregator;\n\tstruct port *last_port = NULL, *curr_port;\n\tstruct list_head *iter;\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\tint found = 0;\n\n\t \n\tif (port->sm_vars & AD_PORT_SELECTED)\n\t\treturn;\n\n\tbond = __get_bond_by_port(port);\n\n\t \n\tif (port->aggregator) {\n\t\t \n\t\ttemp_aggregator = port->aggregator;\n\t\tfor (curr_port = temp_aggregator->lag_ports; curr_port;\n\t\t     last_port = curr_port,\n\t\t     curr_port = curr_port->next_port_in_aggregator) {\n\t\t\tif (curr_port == port) {\n\t\t\t\ttemp_aggregator->num_of_ports--;\n\t\t\t\t \n\t\t\t\tif (!last_port) {\n\t\t\t\t\ttemp_aggregator->lag_ports =\n\t\t\t\t\t\tport->next_port_in_aggregator;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tlast_port->next_port_in_aggregator =\n\t\t\t\t\t\tport->next_port_in_aggregator;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tport->aggregator = NULL;\n\t\t\t\tport->next_port_in_aggregator = NULL;\n\t\t\t\tport->actor_port_aggregator_identifier = 0;\n\n\t\t\t\tslave_dbg(bond->dev, port->slave->dev, \"Port %d left LAG %d\\n\",\n\t\t\t\t\t  port->actor_port_number,\n\t\t\t\t\t  temp_aggregator->aggregator_identifier);\n\t\t\t\t \n\t\t\t\tif (!temp_aggregator->lag_ports)\n\t\t\t\t\tad_clear_agg(temp_aggregator);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!curr_port) {\n\t\t\t \n\t\t\tnet_warn_ratelimited(\"%s: (slave %s): Warning: Port %d was related to aggregator %d but was not on its port list\\n\",\n\t\t\t\t\t     port->slave->bond->dev->name,\n\t\t\t\t\t     port->slave->dev->name,\n\t\t\t\t\t     port->actor_port_number,\n\t\t\t\t\t     port->aggregator->aggregator_identifier);\n\t\t}\n\t}\n\t \n\tbond_for_each_slave(bond, slave, iter) {\n\t\taggregator = &(SLAVE_AD_INFO(slave)->aggregator);\n\n\t\t \n\t\tif (!aggregator->lag_ports) {\n\t\t\tif (!free_aggregator)\n\t\t\t\tfree_aggregator = aggregator;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (((aggregator->actor_oper_aggregator_key == port->actor_oper_port_key) &&  \n\t\t     MAC_ADDRESS_EQUAL(&(aggregator->partner_system), &(port->partner_oper.system)) &&\n\t\t     (aggregator->partner_system_priority == port->partner_oper.system_priority) &&\n\t\t     (aggregator->partner_oper_aggregator_key == port->partner_oper.key)\n\t\t    ) &&\n\t\t    ((!MAC_ADDRESS_EQUAL(&(port->partner_oper.system), &(null_mac_addr)) &&  \n\t\t      !aggregator->is_individual)   \n\t\t    )\n\t\t   ) {\n\t\t\t \n\t\t\tport->aggregator = aggregator;\n\t\t\tport->actor_port_aggregator_identifier =\n\t\t\t\tport->aggregator->aggregator_identifier;\n\t\t\tport->next_port_in_aggregator = aggregator->lag_ports;\n\t\t\tport->aggregator->num_of_ports++;\n\t\t\taggregator->lag_ports = port;\n\t\t\tslave_dbg(bond->dev, slave->dev, \"Port %d joined LAG %d (existing LAG)\\n\",\n\t\t\t\t  port->actor_port_number,\n\t\t\t\t  port->aggregator->aggregator_identifier);\n\n\t\t\t \n\t\t\tport->sm_vars |= AD_PORT_SELECTED;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!found) {\n\t\tif (free_aggregator) {\n\t\t\t \n\t\t\tport->aggregator = free_aggregator;\n\t\t\tport->actor_port_aggregator_identifier =\n\t\t\t\tport->aggregator->aggregator_identifier;\n\n\t\t\t \n\t\t\tif (port->actor_oper_port_key & AD_DUPLEX_KEY_MASKS)\n\t\t\t\t \n\t\t\t\tport->aggregator->is_individual = false;\n\t\t\telse\n\t\t\t\tport->aggregator->is_individual = true;\n\n\t\t\tport->aggregator->actor_admin_aggregator_key =\n\t\t\t\tport->actor_admin_port_key;\n\t\t\tport->aggregator->actor_oper_aggregator_key =\n\t\t\t\tport->actor_oper_port_key;\n\t\t\tport->aggregator->partner_system =\n\t\t\t\tport->partner_oper.system;\n\t\t\tport->aggregator->partner_system_priority =\n\t\t\t\tport->partner_oper.system_priority;\n\t\t\tport->aggregator->partner_oper_aggregator_key = port->partner_oper.key;\n\t\t\tport->aggregator->receive_state = 1;\n\t\t\tport->aggregator->transmit_state = 1;\n\t\t\tport->aggregator->lag_ports = port;\n\t\t\tport->aggregator->num_of_ports++;\n\n\t\t\t \n\t\t\tport->sm_vars |= AD_PORT_SELECTED;\n\n\t\t\tslave_dbg(bond->dev, port->slave->dev, \"Port %d joined LAG %d (new LAG)\\n\",\n\t\t\t\t  port->actor_port_number,\n\t\t\t\t  port->aggregator->aggregator_identifier);\n\t\t} else {\n\t\t\tslave_err(bond->dev, port->slave->dev,\n\t\t\t\t  \"Port %d did not find a suitable aggregator\\n\",\n\t\t\t\t  port->actor_port_number);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\t__set_agg_ports_ready(port->aggregator,\n\t\t\t      __agg_ports_are_ready(port->aggregator));\n\n\taggregator = __get_first_agg(port);\n\tad_agg_selection_logic(aggregator, update_slave_arr);\n\n\tif (!port->aggregator->is_active)\n\t\tport->actor_oper_port_state &= ~LACP_STATE_SYNCHRONIZATION;\n}\n\n \nstatic struct aggregator *ad_agg_selection_test(struct aggregator *best,\n\t\t\t\t\t\tstruct aggregator *curr)\n{\n\t \n\tif (!best)\n\t\treturn curr;\n\n\tif (!curr->is_individual && best->is_individual)\n\t\treturn curr;\n\n\tif (curr->is_individual && !best->is_individual)\n\t\treturn best;\n\n\tif (__agg_has_partner(curr) && !__agg_has_partner(best))\n\t\treturn curr;\n\n\tif (!__agg_has_partner(curr) && __agg_has_partner(best))\n\t\treturn best;\n\n\tswitch (__get_agg_selection_mode(curr->lag_ports)) {\n\tcase BOND_AD_COUNT:\n\t\tif (__agg_active_ports(curr) > __agg_active_ports(best))\n\t\t\treturn curr;\n\n\t\tif (__agg_active_ports(curr) < __agg_active_ports(best))\n\t\t\treturn best;\n\n\t\tfallthrough;\n\tcase BOND_AD_STABLE:\n\tcase BOND_AD_BANDWIDTH:\n\t\tif (__get_agg_bandwidth(curr) > __get_agg_bandwidth(best))\n\t\t\treturn curr;\n\n\t\tbreak;\n\n\tdefault:\n\t\tnet_warn_ratelimited(\"%s: (slave %s): Impossible agg select mode %d\\n\",\n\t\t\t\t     curr->slave->bond->dev->name,\n\t\t\t\t     curr->slave->dev->name,\n\t\t\t\t     __get_agg_selection_mode(curr->lag_ports));\n\t\tbreak;\n\t}\n\n\treturn best;\n}\n\nstatic int agg_device_up(const struct aggregator *agg)\n{\n\tstruct port *port = agg->lag_ports;\n\n\tif (!port)\n\t\treturn 0;\n\n\tfor (port = agg->lag_ports; port;\n\t     port = port->next_port_in_aggregator) {\n\t\tif (netif_running(port->slave->dev) &&\n\t\t    netif_carrier_ok(port->slave->dev))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ad_agg_selection_logic(struct aggregator *agg,\n\t\t\t\t   bool *update_slave_arr)\n{\n\tstruct aggregator *best, *active, *origin;\n\tstruct bonding *bond = agg->slave->bond;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tstruct port *port;\n\n\trcu_read_lock();\n\torigin = agg;\n\tactive = __get_active_agg(agg);\n\tbest = (active && agg_device_up(active)) ? active : NULL;\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tagg = &(SLAVE_AD_INFO(slave)->aggregator);\n\n\t\tagg->is_active = 0;\n\n\t\tif (__agg_active_ports(agg) && agg_device_up(agg))\n\t\t\tbest = ad_agg_selection_test(best, agg);\n\t}\n\n\tif (best &&\n\t    __get_agg_selection_mode(best->lag_ports) == BOND_AD_STABLE) {\n\t\t \n\t\tif (active && active->lag_ports &&\n\t\t    __agg_active_ports(active) &&\n\t\t    (__agg_has_partner(active) ||\n\t\t     (!__agg_has_partner(active) &&\n\t\t     !__agg_has_partner(best)))) {\n\t\t\tif (!(!active->actor_oper_aggregator_key &&\n\t\t\t      best->actor_oper_aggregator_key)) {\n\t\t\t\tbest = NULL;\n\t\t\t\tactive->is_active = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best && (best == active)) {\n\t\tbest = NULL;\n\t\tactive->is_active = 1;\n\t}\n\n\t \n\tif (best) {\n\t\tnetdev_dbg(bond->dev, \"(slave %s): best Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\\n\",\n\t\t\t   best->slave ? best->slave->dev->name : \"NULL\",\n\t\t\t   best->aggregator_identifier, best->num_of_ports,\n\t\t\t   best->actor_oper_aggregator_key,\n\t\t\t   best->partner_oper_aggregator_key,\n\t\t\t   best->is_individual, best->is_active);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): best ports %p slave %p\\n\",\n\t\t\t   best->slave ? best->slave->dev->name : \"NULL\",\n\t\t\t   best->lag_ports, best->slave);\n\n\t\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\t\tagg = &(SLAVE_AD_INFO(slave)->aggregator);\n\n\t\t\tslave_dbg(bond->dev, slave->dev, \"Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\\n\",\n\t\t\t\t  agg->aggregator_identifier, agg->num_of_ports,\n\t\t\t\t  agg->actor_oper_aggregator_key,\n\t\t\t\t  agg->partner_oper_aggregator_key,\n\t\t\t\t  agg->is_individual, agg->is_active);\n\t\t}\n\n\t\t \n\t\tif (best->is_individual)\n\t\t\tnet_warn_ratelimited(\"%s: Warning: No 802.3ad response from the link partner for any adapters in the bond\\n\",\n\t\t\t\t\t     bond->dev->name);\n\n\t\tbest->is_active = 1;\n\t\tnetdev_dbg(bond->dev, \"(slave %s): LAG %d chosen as the active LAG\\n\",\n\t\t\t   best->slave ? best->slave->dev->name : \"NULL\",\n\t\t\t   best->aggregator_identifier);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\\n\",\n\t\t\t   best->slave ? best->slave->dev->name : \"NULL\",\n\t\t\t   best->aggregator_identifier, best->num_of_ports,\n\t\t\t   best->actor_oper_aggregator_key,\n\t\t\t   best->partner_oper_aggregator_key,\n\t\t\t   best->is_individual, best->is_active);\n\n\t\t \n\t\tif (active) {\n\t\t\tfor (port = active->lag_ports; port;\n\t\t\t     port = port->next_port_in_aggregator) {\n\t\t\t\t__disable_port(port);\n\t\t\t}\n\t\t}\n\t\t \n\t\t*update_slave_arr = true;\n\t}\n\n\t \n\tactive = __get_active_agg(origin);\n\n\tif (active) {\n\t\tif (!__agg_has_partner(active)) {\n\t\t\tfor (port = active->lag_ports; port;\n\t\t\t     port = port->next_port_in_aggregator) {\n\t\t\t\t__enable_port(port);\n\t\t\t}\n\t\t\t*update_slave_arr = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tbond_3ad_set_carrier(bond);\n}\n\n \nstatic void ad_clear_agg(struct aggregator *aggregator)\n{\n\tif (aggregator) {\n\t\taggregator->is_individual = false;\n\t\taggregator->actor_admin_aggregator_key = 0;\n\t\taggregator->actor_oper_aggregator_key = 0;\n\t\teth_zero_addr(aggregator->partner_system.mac_addr_value);\n\t\taggregator->partner_system_priority = 0;\n\t\taggregator->partner_oper_aggregator_key = 0;\n\t\taggregator->receive_state = 0;\n\t\taggregator->transmit_state = 0;\n\t\taggregator->lag_ports = NULL;\n\t\taggregator->is_active = 0;\n\t\taggregator->num_of_ports = 0;\n\t\tpr_debug(\"%s: LAG %d was cleared\\n\",\n\t\t\t aggregator->slave ?\n\t\t\t aggregator->slave->dev->name : \"NULL\",\n\t\t\t aggregator->aggregator_identifier);\n\t}\n}\n\n \nstatic void ad_initialize_agg(struct aggregator *aggregator)\n{\n\tif (aggregator) {\n\t\tad_clear_agg(aggregator);\n\n\t\teth_zero_addr(aggregator->aggregator_mac_address.mac_addr_value);\n\t\taggregator->aggregator_identifier = 0;\n\t\taggregator->slave = NULL;\n\t}\n}\n\n \nstatic void ad_initialize_port(struct port *port, int lacp_fast)\n{\n\tstatic const struct port_params tmpl = {\n\t\t.system_priority = 0xffff,\n\t\t.key             = 1,\n\t\t.port_number     = 1,\n\t\t.port_priority   = 0xff,\n\t\t.port_state      = 1,\n\t};\n\tstatic const struct lacpdu lacpdu = {\n\t\t.subtype\t\t= 0x01,\n\t\t.version_number = 0x01,\n\t\t.tlv_type_actor_info = 0x01,\n\t\t.actor_information_length = 0x14,\n\t\t.tlv_type_partner_info = 0x02,\n\t\t.partner_information_length = 0x14,\n\t\t.tlv_type_collector_info = 0x03,\n\t\t.collector_information_length = 0x10,\n\t\t.collector_max_delay = htons(AD_COLLECTOR_MAX_DELAY),\n\t};\n\n\tif (port) {\n\t\tport->actor_port_priority = 0xff;\n\t\tport->actor_port_aggregator_identifier = 0;\n\t\tport->ntt = false;\n\t\tport->actor_admin_port_state = LACP_STATE_AGGREGATION |\n\t\t\t\t\t       LACP_STATE_LACP_ACTIVITY;\n\t\tport->actor_oper_port_state  = LACP_STATE_AGGREGATION |\n\t\t\t\t\t       LACP_STATE_LACP_ACTIVITY;\n\n\t\tif (lacp_fast)\n\t\t\tport->actor_oper_port_state |= LACP_STATE_LACP_TIMEOUT;\n\n\t\tmemcpy(&port->partner_admin, &tmpl, sizeof(tmpl));\n\t\tmemcpy(&port->partner_oper, &tmpl, sizeof(tmpl));\n\n\t\tport->is_enabled = true;\n\t\t \n\t\tport->sm_vars = AD_PORT_BEGIN | AD_PORT_LACP_ENABLED;\n\t\tport->sm_rx_state = 0;\n\t\tport->sm_rx_timer_counter = 0;\n\t\tport->sm_periodic_state = 0;\n\t\tport->sm_periodic_timer_counter = 0;\n\t\tport->sm_mux_state = 0;\n\t\tport->sm_mux_timer_counter = 0;\n\t\tport->sm_tx_state = 0;\n\t\tport->aggregator = NULL;\n\t\tport->next_port_in_aggregator = NULL;\n\t\tport->transaction_id = 0;\n\n\t\tport->sm_churn_actor_timer_counter = 0;\n\t\tport->sm_churn_actor_state = 0;\n\t\tport->churn_actor_count = 0;\n\t\tport->sm_churn_partner_timer_counter = 0;\n\t\tport->sm_churn_partner_state = 0;\n\t\tport->churn_partner_count = 0;\n\n\t\tmemcpy(&port->lacpdu, &lacpdu, sizeof(lacpdu));\n\t}\n}\n\n \nstatic void ad_enable_collecting_distributing(struct port *port,\n\t\t\t\t\t      bool *update_slave_arr)\n{\n\tif (port->aggregator->is_active) {\n\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t  \"Enabling port %d (LAG %d)\\n\",\n\t\t\t  port->actor_port_number,\n\t\t\t  port->aggregator->aggregator_identifier);\n\t\t__enable_port(port);\n\t\t \n\t\t*update_slave_arr = true;\n\t}\n}\n\n \nstatic void ad_disable_collecting_distributing(struct port *port,\n\t\t\t\t\t       bool *update_slave_arr)\n{\n\tif (port->aggregator &&\n\t    !MAC_ADDRESS_EQUAL(&(port->aggregator->partner_system),\n\t\t\t       &(null_mac_addr))) {\n\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t  \"Disabling port %d (LAG %d)\\n\",\n\t\t\t  port->actor_port_number,\n\t\t\t  port->aggregator->aggregator_identifier);\n\t\t__disable_port(port);\n\t\t \n\t\t*update_slave_arr = true;\n\t}\n}\n\n \nstatic void ad_marker_info_received(struct bond_marker *marker_info,\n\t\t\t\t    struct port *port)\n{\n\tstruct bond_marker marker;\n\n\tatomic64_inc(&SLAVE_AD_INFO(port->slave)->stats.marker_rx);\n\tatomic64_inc(&BOND_AD_INFO(port->slave->bond).stats.marker_rx);\n\n\t \n\tmemcpy(&marker, marker_info, sizeof(struct bond_marker));\n\t \n\tmarker.tlv_type = AD_MARKER_RESPONSE_SUBTYPE;\n\n\t \n\tif (ad_marker_send(port, &marker) >= 0)\n\t\tslave_dbg(port->slave->bond->dev, port->slave->dev,\n\t\t\t  \"Sent Marker Response on port %d\\n\",\n\t\t\t  port->actor_port_number);\n}\n\n \nstatic void ad_marker_response_received(struct bond_marker *marker,\n\t\t\t\t\tstruct port *port)\n{\n\tatomic64_inc(&SLAVE_AD_INFO(port->slave)->stats.marker_resp_rx);\n\tatomic64_inc(&BOND_AD_INFO(port->slave->bond).stats.marker_resp_rx);\n\n\t \n}\n\n \n\n \n#define AD_AGGREGATOR_SELECTION_TIMER  8\n\n \nvoid bond_3ad_initiate_agg_selection(struct bonding *bond, int timeout)\n{\n\tatomic_set(&BOND_AD_INFO(bond).agg_select_timer, timeout);\n}\n\n \nvoid bond_3ad_initialize(struct bonding *bond)\n{\n\tBOND_AD_INFO(bond).aggregator_identifier = 0;\n\tBOND_AD_INFO(bond).system.sys_priority =\n\t\tbond->params.ad_actor_sys_prio;\n\tif (is_zero_ether_addr(bond->params.ad_actor_system))\n\t\tBOND_AD_INFO(bond).system.sys_mac_addr =\n\t\t    *((struct mac_addr *)bond->dev->dev_addr);\n\telse\n\t\tBOND_AD_INFO(bond).system.sys_mac_addr =\n\t\t    *((struct mac_addr *)bond->params.ad_actor_system);\n\n\tbond_3ad_initiate_agg_selection(bond,\n\t\t\t\t\tAD_AGGREGATOR_SELECTION_TIMER *\n\t\t\t\t\tad_ticks_per_sec);\n}\n\n \nvoid bond_3ad_bind_slave(struct slave *slave)\n{\n\tstruct bonding *bond = bond_get_bond_by_slave(slave);\n\tstruct port *port;\n\tstruct aggregator *aggregator;\n\n\t \n\tif (SLAVE_AD_INFO(slave)->port.slave != slave) {\n\n\t\t \n\t\tport = &(SLAVE_AD_INFO(slave)->port);\n\n\t\tad_initialize_port(port, bond->params.lacp_fast);\n\n\t\tport->slave = slave;\n\t\tport->actor_port_number = SLAVE_AD_INFO(slave)->id;\n\t\t \n\t\tport->actor_admin_port_key = bond->params.ad_user_port_key << 6;\n\t\tad_update_actor_keys(port, false);\n\t\t \n\t\t__ad_actor_update_port(port);\n\t\t \n\t\tport->sm_tx_timer_counter = ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;\n\n\t\t__disable_port(port);\n\n\t\t \n\t\taggregator = &(SLAVE_AD_INFO(slave)->aggregator);\n\n\t\tad_initialize_agg(aggregator);\n\n\t\taggregator->aggregator_mac_address = *((struct mac_addr *)bond->dev->dev_addr);\n\t\taggregator->aggregator_identifier = ++BOND_AD_INFO(bond).aggregator_identifier;\n\t\taggregator->slave = slave;\n\t\taggregator->is_active = 0;\n\t\taggregator->num_of_ports = 0;\n\t}\n}\n\n \nvoid bond_3ad_unbind_slave(struct slave *slave)\n{\n\tstruct port *port, *prev_port, *temp_port;\n\tstruct aggregator *aggregator, *new_aggregator, *temp_aggregator;\n\tint select_new_active_agg = 0;\n\tstruct bonding *bond = slave->bond;\n\tstruct slave *slave_iter;\n\tstruct list_head *iter;\n\tbool dummy_slave_update;  \n\n\t \n\tspin_lock_bh(&bond->mode_lock);\n\taggregator = &(SLAVE_AD_INFO(slave)->aggregator);\n\tport = &(SLAVE_AD_INFO(slave)->port);\n\n\t \n\tif (!port->slave) {\n\t\tslave_warn(bond->dev, slave->dev, \"Trying to unbind an uninitialized port\\n\");\n\t\tgoto out;\n\t}\n\n\tslave_dbg(bond->dev, slave->dev, \"Unbinding Link Aggregation Group %d\\n\",\n\t\t  aggregator->aggregator_identifier);\n\n\t \n\tport->actor_oper_port_state &= ~LACP_STATE_SYNCHRONIZATION;\n\tport->actor_oper_port_state &= ~LACP_STATE_COLLECTING;\n\tport->actor_oper_port_state &= ~LACP_STATE_DISTRIBUTING;\n\tport->actor_oper_port_state &= ~LACP_STATE_AGGREGATION;\n\t__update_lacpdu_from_port(port);\n\tad_lacpdu_send(port);\n\n\t \n\tif (aggregator->lag_ports) {\n\t\t \n\t\tif ((aggregator->lag_ports != port) ||\n\t\t    (aggregator->lag_ports->next_port_in_aggregator)) {\n\t\t\t \n\t\t\tbond_for_each_slave(bond, slave_iter, iter) {\n\t\t\t\tnew_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);\n\t\t\t\t \n\t\t\t\tif (!new_aggregator->lag_ports ||\n\t\t\t\t    ((new_aggregator->lag_ports == port) &&\n\t\t\t\t     !new_aggregator->lag_ports->next_port_in_aggregator))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!slave_iter)\n\t\t\t\tnew_aggregator = NULL;\n\n\t\t\t \n\t\t\tif ((new_aggregator) && ((!new_aggregator->lag_ports) || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator))) {\n\t\t\t\tslave_dbg(bond->dev, slave->dev, \"Some port(s) related to LAG %d - replacing with LAG %d\\n\",\n\t\t\t\t\t  aggregator->aggregator_identifier,\n\t\t\t\t\t  new_aggregator->aggregator_identifier);\n\n\t\t\t\tif ((new_aggregator->lag_ports == port) &&\n\t\t\t\t    new_aggregator->is_active) {\n\t\t\t\t\tslave_info(bond->dev, slave->dev, \"Removing an active aggregator\\n\");\n\t\t\t\t\tselect_new_active_agg = 1;\n\t\t\t\t}\n\n\t\t\t\tnew_aggregator->is_individual = aggregator->is_individual;\n\t\t\t\tnew_aggregator->actor_admin_aggregator_key = aggregator->actor_admin_aggregator_key;\n\t\t\t\tnew_aggregator->actor_oper_aggregator_key = aggregator->actor_oper_aggregator_key;\n\t\t\t\tnew_aggregator->partner_system = aggregator->partner_system;\n\t\t\t\tnew_aggregator->partner_system_priority = aggregator->partner_system_priority;\n\t\t\t\tnew_aggregator->partner_oper_aggregator_key = aggregator->partner_oper_aggregator_key;\n\t\t\t\tnew_aggregator->receive_state = aggregator->receive_state;\n\t\t\t\tnew_aggregator->transmit_state = aggregator->transmit_state;\n\t\t\t\tnew_aggregator->lag_ports = aggregator->lag_ports;\n\t\t\t\tnew_aggregator->is_active = aggregator->is_active;\n\t\t\t\tnew_aggregator->num_of_ports = aggregator->num_of_ports;\n\n\t\t\t\t \n\t\t\t\tfor (temp_port = aggregator->lag_ports; temp_port;\n\t\t\t\t     temp_port = temp_port->next_port_in_aggregator) {\n\t\t\t\t\ttemp_port->aggregator = new_aggregator;\n\t\t\t\t\ttemp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;\n\t\t\t\t}\n\n\t\t\t\tad_clear_agg(aggregator);\n\n\t\t\t\tif (select_new_active_agg)\n\t\t\t\t\tad_agg_selection_logic(__get_first_agg(port),\n\t\t\t\t\t\t\t       &dummy_slave_update);\n\t\t\t} else {\n\t\t\t\tslave_warn(bond->dev, slave->dev, \"unbinding aggregator, and could not find a new aggregator for its ports\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tselect_new_active_agg = aggregator->is_active;\n\t\t\tad_clear_agg(aggregator);\n\t\t\tif (select_new_active_agg) {\n\t\t\t\tslave_info(bond->dev, slave->dev, \"Removing an active aggregator\\n\");\n\t\t\t\t \n\t\t\t\ttemp_aggregator = __get_first_agg(port);\n\t\t\t\tif (temp_aggregator)\n\t\t\t\t\tad_agg_selection_logic(temp_aggregator,\n\t\t\t\t\t\t\t       &dummy_slave_update);\n\t\t\t}\n\t\t}\n\t}\n\n\tslave_dbg(bond->dev, slave->dev, \"Unbinding port %d\\n\", port->actor_port_number);\n\n\t \n\tbond_for_each_slave(bond, slave_iter, iter) {\n\t\ttemp_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);\n\t\tprev_port = NULL;\n\t\t \n\t\tfor (temp_port = temp_aggregator->lag_ports; temp_port;\n\t\t     prev_port = temp_port,\n\t\t     temp_port = temp_port->next_port_in_aggregator) {\n\t\t\tif (temp_port == port) {\n\t\t\t\t \n\t\t\t\tif (prev_port)\n\t\t\t\t\tprev_port->next_port_in_aggregator = temp_port->next_port_in_aggregator;\n\t\t\t\telse\n\t\t\t\t\ttemp_aggregator->lag_ports = temp_port->next_port_in_aggregator;\n\t\t\t\ttemp_aggregator->num_of_ports--;\n\t\t\t\tif (__agg_active_ports(temp_aggregator) == 0) {\n\t\t\t\t\tselect_new_active_agg = temp_aggregator->is_active;\n\t\t\t\t\tif (temp_aggregator->num_of_ports == 0)\n\t\t\t\t\t\tad_clear_agg(temp_aggregator);\n\t\t\t\t\tif (select_new_active_agg) {\n\t\t\t\t\t\tslave_info(bond->dev, slave->dev, \"Removing an active aggregator\\n\");\n\t\t\t\t\t\t \n\t\t\t\t\t\tad_agg_selection_logic(__get_first_agg(port),\n\t\t\t\t\t\t\t               &dummy_slave_update);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tport->slave = NULL;\n\nout:\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \nvoid bond_3ad_update_ad_actor_settings(struct bonding *bond)\n{\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tASSERT_RTNL();\n\n\tBOND_AD_INFO(bond).system.sys_priority = bond->params.ad_actor_sys_prio;\n\tif (is_zero_ether_addr(bond->params.ad_actor_system))\n\t\tBOND_AD_INFO(bond).system.sys_mac_addr =\n\t\t    *((struct mac_addr *)bond->dev->dev_addr);\n\telse\n\t\tBOND_AD_INFO(bond).system.sys_mac_addr =\n\t\t    *((struct mac_addr *)bond->params.ad_actor_system);\n\n\tspin_lock_bh(&bond->mode_lock);\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tstruct port *port = &(SLAVE_AD_INFO(slave))->port;\n\n\t\t__ad_actor_update_port(port);\n\t\tport->ntt = true;\n\t}\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \nstatic bool bond_agg_timer_advance(struct bonding *bond)\n{\n\tint val, nval;\n\n\twhile (1) {\n\t\tval = atomic_read(&BOND_AD_INFO(bond).agg_select_timer);\n\t\tif (!val)\n\t\t\treturn false;\n\t\tnval = val - 1;\n\t\tif (atomic_cmpxchg(&BOND_AD_INFO(bond).agg_select_timer,\n\t\t\t\t   val, nval) == val)\n\t\t\tbreak;\n\t}\n\treturn nval == 0;\n}\n\n \nvoid bond_3ad_state_machine_handler(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    ad_work.work);\n\tstruct aggregator *aggregator;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tstruct port *port;\n\tbool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;\n\tbool update_slave_arr = false;\n\n\t \n\tspin_lock_bh(&bond->mode_lock);\n\trcu_read_lock();\n\n\t \n\tif (!bond_has_slaves(bond))\n\t\tgoto re_arm;\n\n\tif (bond_agg_timer_advance(bond)) {\n\t\tslave = bond_first_slave_rcu(bond);\n\t\tport = slave ? &(SLAVE_AD_INFO(slave)->port) : NULL;\n\n\t\t \n\t\tif (port) {\n\t\t\tif (!port->slave) {\n\t\t\t\tnet_warn_ratelimited(\"%s: Warning: bond's first port is uninitialized\\n\",\n\t\t\t\t\t\t     bond->dev->name);\n\t\t\t\tgoto re_arm;\n\t\t\t}\n\n\t\t\taggregator = __get_first_agg(port);\n\t\t\tad_agg_selection_logic(aggregator, &update_slave_arr);\n\t\t}\n\t\tbond_3ad_set_carrier(bond);\n\t}\n\n\t \n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tport = &(SLAVE_AD_INFO(slave)->port);\n\t\tif (!port->slave) {\n\t\t\tnet_warn_ratelimited(\"%s: Warning: Found an uninitialized port\\n\",\n\t\t\t\t\t    bond->dev->name);\n\t\t\tgoto re_arm;\n\t\t}\n\n\t\tad_rx_machine(NULL, port);\n\t\tad_periodic_machine(port, &bond->params);\n\t\tad_port_selection_logic(port, &update_slave_arr);\n\t\tad_mux_machine(port, &update_slave_arr);\n\t\tad_tx_machine(port);\n\t\tad_churn_machine(port);\n\n\t\t \n\t\tif (port->sm_vars & AD_PORT_BEGIN)\n\t\t\tport->sm_vars &= ~AD_PORT_BEGIN;\n\t}\n\nre_arm:\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (slave->should_notify) {\n\t\t\tshould_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tspin_unlock_bh(&bond->mode_lock);\n\n\tif (update_slave_arr)\n\t\tbond_slave_arr_work_rearm(bond, 0);\n\n\tif (should_notify_rtnl && rtnl_trylock()) {\n\t\tbond_slave_state_notify(bond);\n\t\trtnl_unlock();\n\t}\n\tqueue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);\n}\n\n \nstatic int bond_3ad_rx_indication(struct lacpdu *lacpdu, struct slave *slave)\n{\n\tstruct bonding *bond = slave->bond;\n\tint ret = RX_HANDLER_ANOTHER;\n\tstruct bond_marker *marker;\n\tstruct port *port;\n\tatomic64_t *stat;\n\n\tport = &(SLAVE_AD_INFO(slave)->port);\n\tif (!port->slave) {\n\t\tnet_warn_ratelimited(\"%s: Warning: port of slave %s is uninitialized\\n\",\n\t\t\t\t     slave->dev->name, slave->bond->dev->name);\n\t\treturn ret;\n\t}\n\n\tswitch (lacpdu->subtype) {\n\tcase AD_TYPE_LACPDU:\n\t\tret = RX_HANDLER_CONSUMED;\n\t\tslave_dbg(slave->bond->dev, slave->dev,\n\t\t\t  \"Received LACPDU on port %d\\n\",\n\t\t\t  port->actor_port_number);\n\t\t \n\t\tspin_lock(&slave->bond->mode_lock);\n\t\tad_rx_machine(lacpdu, port);\n\t\tspin_unlock(&slave->bond->mode_lock);\n\t\tbreak;\n\tcase AD_TYPE_MARKER:\n\t\tret = RX_HANDLER_CONSUMED;\n\t\t \n\t\tmarker = (struct bond_marker *)lacpdu;\n\t\tswitch (marker->tlv_type) {\n\t\tcase AD_MARKER_INFORMATION_SUBTYPE:\n\t\t\tslave_dbg(slave->bond->dev, slave->dev, \"Received Marker Information on port %d\\n\",\n\t\t\t\t  port->actor_port_number);\n\t\t\tad_marker_info_received(marker, port);\n\t\t\tbreak;\n\t\tcase AD_MARKER_RESPONSE_SUBTYPE:\n\t\t\tslave_dbg(slave->bond->dev, slave->dev, \"Received Marker Response on port %d\\n\",\n\t\t\t\t  port->actor_port_number);\n\t\t\tad_marker_response_received(marker, port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tslave_dbg(slave->bond->dev, slave->dev, \"Received an unknown Marker subtype on port %d\\n\",\n\t\t\t\t  port->actor_port_number);\n\t\t\tstat = &SLAVE_AD_INFO(slave)->stats.marker_unknown_rx;\n\t\t\tatomic64_inc(stat);\n\t\t\tstat = &BOND_AD_INFO(bond).stats.marker_unknown_rx;\n\t\t\tatomic64_inc(stat);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tatomic64_inc(&SLAVE_AD_INFO(slave)->stats.lacpdu_unknown_rx);\n\t\tatomic64_inc(&BOND_AD_INFO(bond).stats.lacpdu_unknown_rx);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ad_update_actor_keys(struct port *port, bool reset)\n{\n\tu8 duplex = 0;\n\tu16 ospeed = 0, speed = 0;\n\tu16 old_oper_key = port->actor_oper_port_key;\n\n\tport->actor_admin_port_key &= ~(AD_SPEED_KEY_MASKS|AD_DUPLEX_KEY_MASKS);\n\tif (!reset) {\n\t\tspeed = __get_link_speed(port);\n\t\tospeed = (old_oper_key & AD_SPEED_KEY_MASKS) >> 1;\n\t\tduplex = __get_duplex(port);\n\t\tport->actor_admin_port_key |= (speed << 1) | duplex;\n\t}\n\tport->actor_oper_port_key = port->actor_admin_port_key;\n\n\tif (old_oper_key != port->actor_oper_port_key) {\n\t\t \n\t\tif (duplex)\n\t\t\tport->sm_vars |= AD_PORT_LACP_ENABLED;\n\t\telse\n\t\t\tport->sm_vars &= ~AD_PORT_LACP_ENABLED;\n\n\t\tif (!reset) {\n\t\t\tif (!speed) {\n\t\t\t\tslave_err(port->slave->bond->dev,\n\t\t\t\t\t  port->slave->dev,\n\t\t\t\t\t  \"speed changed to 0 on port %d\\n\",\n\t\t\t\t\t  port->actor_port_number);\n\t\t\t} else if (duplex && ospeed != speed) {\n\t\t\t\t \n\t\t\t\tport->sm_vars |= AD_PORT_BEGIN;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid bond_3ad_adapter_speed_duplex_changed(struct slave *slave)\n{\n\tstruct port *port;\n\n\tport = &(SLAVE_AD_INFO(slave)->port);\n\n\t \n\tif (!port->slave) {\n\t\tslave_warn(slave->bond->dev, slave->dev,\n\t\t\t   \"speed/duplex changed for uninitialized port\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&slave->bond->mode_lock);\n\tad_update_actor_keys(port, false);\n\tspin_unlock_bh(&slave->bond->mode_lock);\n\tslave_dbg(slave->bond->dev, slave->dev, \"Port %d changed speed/duplex\\n\",\n\t\t  port->actor_port_number);\n}\n\n \nvoid bond_3ad_handle_link_change(struct slave *slave, char link)\n{\n\tstruct aggregator *agg;\n\tstruct port *port;\n\tbool dummy;\n\n\tport = &(SLAVE_AD_INFO(slave)->port);\n\n\t \n\tif (!port->slave) {\n\t\tslave_warn(slave->bond->dev, slave->dev, \"link status changed for uninitialized port\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&slave->bond->mode_lock);\n\t \n\tif (link == BOND_LINK_UP) {\n\t\tport->is_enabled = true;\n\t\tad_update_actor_keys(port, false);\n\t} else {\n\t\t \n\t\tport->is_enabled = false;\n\t\tad_update_actor_keys(port, true);\n\t}\n\tagg = __get_first_agg(port);\n\tad_agg_selection_logic(agg, &dummy);\n\n\tspin_unlock_bh(&slave->bond->mode_lock);\n\n\tslave_dbg(slave->bond->dev, slave->dev, \"Port %d changed link status to %s\\n\",\n\t\t  port->actor_port_number,\n\t\t  link == BOND_LINK_UP ? \"UP\" : \"DOWN\");\n\n\t \n\tbond_update_slave_arr(slave->bond, NULL);\n}\n\n \nint bond_3ad_set_carrier(struct bonding *bond)\n{\n\tstruct aggregator *active;\n\tstruct slave *first_slave;\n\tint ret = 1;\n\n\trcu_read_lock();\n\tfirst_slave = bond_first_slave_rcu(bond);\n\tif (!first_slave) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tactive = __get_active_agg(&(SLAVE_AD_INFO(first_slave)->aggregator));\n\tif (active) {\n\t\t \n\t\tif (__agg_active_ports(active) < bond->params.min_links) {\n\t\t\tif (netif_carrier_ok(bond->dev)) {\n\t\t\t\tnetif_carrier_off(bond->dev);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!netif_carrier_ok(bond->dev)) {\n\t\t\tnetif_carrier_on(bond->dev);\n\t\t\tgoto out;\n\t\t}\n\t} else if (netif_carrier_ok(bond->dev)) {\n\t\tnetif_carrier_off(bond->dev);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nint __bond_3ad_get_active_agg_info(struct bonding *bond,\n\t\t\t\t   struct ad_info *ad_info)\n{\n\tstruct aggregator *aggregator = NULL;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tstruct port *port;\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tport = &(SLAVE_AD_INFO(slave)->port);\n\t\tif (port->aggregator && port->aggregator->is_active) {\n\t\t\taggregator = port->aggregator;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!aggregator)\n\t\treturn -1;\n\n\tad_info->aggregator_id = aggregator->aggregator_identifier;\n\tad_info->ports = __agg_active_ports(aggregator);\n\tad_info->actor_key = aggregator->actor_oper_aggregator_key;\n\tad_info->partner_key = aggregator->partner_oper_aggregator_key;\n\tether_addr_copy(ad_info->partner_system,\n\t\t\taggregator->partner_system.mac_addr_value);\n\treturn 0;\n}\n\nint bond_3ad_get_active_agg_info(struct bonding *bond, struct ad_info *ad_info)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = __bond_3ad_get_active_agg_info(bond, ad_info);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nint bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,\n\t\t\t struct slave *slave)\n{\n\tstruct lacpdu *lacpdu, _lacpdu;\n\n\tif (skb->protocol != PKT_TYPE_LACPDU)\n\t\treturn RX_HANDLER_ANOTHER;\n\n\tif (!MAC_ADDRESS_EQUAL(eth_hdr(skb)->h_dest, lacpdu_mcast_addr))\n\t\treturn RX_HANDLER_ANOTHER;\n\n\tlacpdu = skb_header_pointer(skb, 0, sizeof(_lacpdu), &_lacpdu);\n\tif (!lacpdu) {\n\t\tatomic64_inc(&SLAVE_AD_INFO(slave)->stats.lacpdu_illegal_rx);\n\t\tatomic64_inc(&BOND_AD_INFO(bond).stats.lacpdu_illegal_rx);\n\t\treturn RX_HANDLER_ANOTHER;\n\t}\n\n\treturn bond_3ad_rx_indication(lacpdu, slave);\n}\n\n \nvoid bond_3ad_update_lacp_rate(struct bonding *bond)\n{\n\tstruct port *port = NULL;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint lacp_fast;\n\n\tlacp_fast = bond->params.lacp_fast;\n\tspin_lock_bh(&bond->mode_lock);\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tport = &(SLAVE_AD_INFO(slave)->port);\n\t\tif (lacp_fast)\n\t\t\tport->actor_oper_port_state |= LACP_STATE_LACP_TIMEOUT;\n\t\telse\n\t\t\tport->actor_oper_port_state &= ~LACP_STATE_LACP_TIMEOUT;\n\t}\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\nsize_t bond_3ad_stats_size(void)\n{\n\treturn nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size_64bit(sizeof(u64));  \n}\n\nint bond_3ad_stats_fill(struct sk_buff *skb, struct bond_3ad_stats *stats)\n{\n\tu64 val;\n\n\tval = atomic64_read(&stats->lacpdu_rx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_LACPDU_RX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->lacpdu_tx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_LACPDU_TX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->lacpdu_unknown_rx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_LACPDU_UNKNOWN_RX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->lacpdu_illegal_rx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_LACPDU_ILLEGAL_RX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\n\tval = atomic64_read(&stats->marker_rx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_MARKER_RX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->marker_tx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_MARKER_TX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->marker_resp_rx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_MARKER_RESP_RX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->marker_resp_tx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_MARKER_RESP_TX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\tval = atomic64_read(&stats->marker_unknown_rx);\n\tif (nla_put_u64_64bit(skb, BOND_3AD_STAT_MARKER_UNKNOWN_RX, val,\n\t\t\t      BOND_3AD_STAT_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}