{
  "module_name": "bond_sysfs.c",
  "hash_id": "bf54e1b2d88ae1d423d0894761112db893f76d19f5c7a1e4a96aebc27528a3fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_sysfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/in.h>\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/nsproxy.h>\n\n#include <net/bonding.h>\n\n#define to_bond(cd)\t((struct bonding *)(netdev_priv(to_net_dev(cd))))\n\n \nstatic ssize_t bonding_show_bonds(const struct class *cls,\n\t\t\t\t  const struct class_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tconst struct bond_net *bn =\n\t\tcontainer_of_const(attr, struct bond_net, class_attr_bonding_masters);\n\tint res = 0;\n\tstruct bonding *bond;\n\n\trtnl_lock();\n\n\tlist_for_each_entry(bond, &bn->dev_list, bond_list) {\n\t\tif (res > (PAGE_SIZE - IFNAMSIZ)) {\n\t\t\t \n\t\t\tif ((PAGE_SIZE - res) > 10)\n\t\t\t\tres = PAGE_SIZE - 10;\n\t\t\tres += sysfs_emit_at(buf, res, \"++more++ \");\n\t\t\tbreak;\n\t\t}\n\t\tres += sysfs_emit_at(buf, res, \"%s \", bond->dev->name);\n\t}\n\tif (res)\n\t\tbuf[res-1] = '\\n';  \n\n\trtnl_unlock();\n\treturn res;\n}\n\nstatic struct net_device *bond_get_by_name(const struct bond_net *bn, const char *ifname)\n{\n\tstruct bonding *bond;\n\n\tlist_for_each_entry(bond, &bn->dev_list, bond_list) {\n\t\tif (strncmp(bond->dev->name, ifname, IFNAMSIZ) == 0)\n\t\t\treturn bond->dev;\n\t}\n\treturn NULL;\n}\n\n \nstatic ssize_t bonding_store_bonds(const struct class *cls,\n\t\t\t\t   const struct class_attribute *attr,\n\t\t\t\t   const char *buffer, size_t count)\n{\n\tconst struct bond_net *bn =\n\t\tcontainer_of_const(attr, struct bond_net, class_attr_bonding_masters);\n\tchar command[IFNAMSIZ + 1] = {0, };\n\tchar *ifname;\n\tint rv, res = count;\n\n\tsscanf(buffer, \"%16s\", command);  \n\tifname = command + 1;\n\tif ((strlen(command) <= 1) ||\n\t    !dev_valid_name(ifname))\n\t\tgoto err_no_cmd;\n\n\tif (command[0] == '+') {\n\t\tpr_info(\"%s is being created...\\n\", ifname);\n\t\trv = bond_create(bn->net, ifname);\n\t\tif (rv) {\n\t\t\tif (rv == -EEXIST)\n\t\t\t\tpr_info(\"%s already exists\\n\", ifname);\n\t\t\telse\n\t\t\t\tpr_info(\"%s creation failed\\n\", ifname);\n\t\t\tres = rv;\n\t\t}\n\t} else if (command[0] == '-') {\n\t\tstruct net_device *bond_dev;\n\n\t\trtnl_lock();\n\t\tbond_dev = bond_get_by_name(bn, ifname);\n\t\tif (bond_dev) {\n\t\t\tpr_info(\"%s is being deleted...\\n\", ifname);\n\t\t\tunregister_netdevice(bond_dev);\n\t\t} else {\n\t\t\tpr_err(\"unable to delete non-existent %s\\n\", ifname);\n\t\t\tres = -ENODEV;\n\t\t}\n\t\trtnl_unlock();\n\t} else\n\t\tgoto err_no_cmd;\n\n\t \n\treturn res;\n\nerr_no_cmd:\n\tpr_err(\"no command found in bonding_masters - use +ifname or -ifname\\n\");\n\treturn -EPERM;\n}\n\n \nstatic const struct class_attribute class_attr_bonding_masters = {\n\t.attr = {\n\t\t.name = \"bonding_masters\",\n\t\t.mode = 0644,\n\t},\n\t.show = bonding_show_bonds,\n\t.store = bonding_store_bonds,\n};\n\n \nstatic ssize_t bonding_sysfs_store_option(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buffer, size_t count)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_option *opt;\n\tchar *buffer_clone;\n\tint ret;\n\n\topt = bond_opt_get_by_name(attr->attr.name);\n\tif (WARN_ON(!opt))\n\t\treturn -ENOENT;\n\tbuffer_clone = kstrndup(buffer, count, GFP_KERNEL);\n\tif (!buffer_clone)\n\t\treturn -ENOMEM;\n\tret = bond_opt_tryset_rtnl(bond, opt->id, buffer_clone);\n\tif (!ret)\n\t\tret = count;\n\tkfree(buffer_clone);\n\n\treturn ret;\n}\n\n \nstatic ssize_t bonding_show_slaves(struct device *d,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint res = 0;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (res > (PAGE_SIZE - IFNAMSIZ)) {\n\t\t\t \n\t\t\tif ((PAGE_SIZE - res) > 10)\n\t\t\t\tres = PAGE_SIZE - 10;\n\t\t\tres += sysfs_emit_at(buf, res, \"++more++ \");\n\t\t\tbreak;\n\t\t}\n\t\tres += sysfs_emit_at(buf, res, \"%s \", slave->dev->name);\n\t}\n\n\trtnl_unlock();\n\n\tif (res)\n\t\tbuf[res-1] = '\\n';  \n\n\treturn res;\n}\nstatic DEVICE_ATTR(slaves, 0644, bonding_show_slaves,\n\t\t   bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_mode(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_MODE, BOND_MODE(bond));\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, BOND_MODE(bond));\n}\nstatic DEVICE_ATTR(mode, 0644, bonding_show_mode, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_xmit_hash(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_XMIT_HASH, bond->params.xmit_policy);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, bond->params.xmit_policy);\n}\nstatic DEVICE_ATTR(xmit_hash_policy, 0644,\n\t\t   bonding_show_xmit_hash, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_arp_validate(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_ARP_VALIDATE,\n\t\t\t       bond->params.arp_validate);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, bond->params.arp_validate);\n}\nstatic DEVICE_ATTR(arp_validate, 0644, bonding_show_arp_validate,\n\t\t   bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_arp_all_targets(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_ARP_ALL_TARGETS,\n\t\t\t       bond->params.arp_all_targets);\n\treturn sysfs_emit(buf, \"%s %d\\n\",\n\t\t       val->string, bond->params.arp_all_targets);\n}\nstatic DEVICE_ATTR(arp_all_targets, 0644,\n\t\t   bonding_show_arp_all_targets, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_fail_over_mac(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_FAIL_OVER_MAC,\n\t\t\t       bond->params.fail_over_mac);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, bond->params.fail_over_mac);\n}\nstatic DEVICE_ATTR(fail_over_mac, 0644,\n\t\t   bonding_show_fail_over_mac, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_arp_interval(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.arp_interval);\n}\nstatic DEVICE_ATTR(arp_interval, 0644,\n\t\t   bonding_show_arp_interval, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_arp_targets(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tint i, res = 0;\n\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++) {\n\t\tif (bond->params.arp_targets[i])\n\t\t\tres += sysfs_emit_at(buf, res, \"%pI4 \",\n\t\t\t\t\t     &bond->params.arp_targets[i]);\n\t}\n\tif (res)\n\t\tbuf[res-1] = '\\n';  \n\n\treturn res;\n}\nstatic DEVICE_ATTR(arp_ip_target, 0644,\n\t\t   bonding_show_arp_targets, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_missed_max(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%u\\n\", bond->params.missed_max);\n}\nstatic DEVICE_ATTR(arp_missed_max, 0644,\n\t\t   bonding_show_missed_max, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_downdelay(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.downdelay * bond->params.miimon);\n}\nstatic DEVICE_ATTR(downdelay, 0644,\n\t\t   bonding_show_downdelay, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_updelay(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.updelay * bond->params.miimon);\n\n}\nstatic DEVICE_ATTR(updelay, 0644,\n\t\t   bonding_show_updelay, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_peer_notif_delay(struct device *d,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  bond->params.peer_notif_delay * bond->params.miimon);\n}\nstatic DEVICE_ATTR(peer_notif_delay, 0644,\n\t\t   bonding_show_peer_notif_delay, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_lacp_active(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_LACP_ACTIVE, bond->params.lacp_active);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, bond->params.lacp_active);\n}\nstatic DEVICE_ATTR(lacp_active, 0644,\n\t\t   bonding_show_lacp_active, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_lacp_rate(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_LACP_RATE, bond->params.lacp_fast);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, bond->params.lacp_fast);\n}\nstatic DEVICE_ATTR(lacp_rate, 0644,\n\t\t   bonding_show_lacp_rate, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_min_links(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%u\\n\", bond->params.min_links);\n}\nstatic DEVICE_ATTR(min_links, 0644,\n\t\t   bonding_show_min_links, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_ad_select(struct device *d,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_AD_SELECT, bond->params.ad_select);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\", val->string, bond->params.ad_select);\n}\nstatic DEVICE_ATTR(ad_select, 0644,\n\t\t   bonding_show_ad_select, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_num_peer_notif(struct device *d,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.num_peer_notif);\n}\nstatic DEVICE_ATTR(num_grat_arp, 0644,\n\t\t   bonding_show_num_peer_notif, bonding_sysfs_store_option);\nstatic DEVICE_ATTR(num_unsol_na, 0644,\n\t\t   bonding_show_num_peer_notif, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_miimon(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.miimon);\n}\nstatic DEVICE_ATTR(miimon, 0644,\n\t\t   bonding_show_miimon, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_primary(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tstruct slave *primary;\n\tint count = 0;\n\n\trcu_read_lock();\n\tprimary = rcu_dereference(bond->primary_slave);\n\tif (primary)\n\t\tcount = sysfs_emit(buf, \"%s\\n\", primary->dev->name);\n\trcu_read_unlock();\n\n\treturn count;\n}\nstatic DEVICE_ATTR(primary, 0644,\n\t\t   bonding_show_primary, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_primary_reselect(struct device *d,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tconst struct bond_opt_value *val;\n\n\tval = bond_opt_get_val(BOND_OPT_PRIMARY_RESELECT,\n\t\t\t       bond->params.primary_reselect);\n\n\treturn sysfs_emit(buf, \"%s %d\\n\",\n\t\t\t  val->string, bond->params.primary_reselect);\n}\nstatic DEVICE_ATTR(primary_reselect, 0644,\n\t\t   bonding_show_primary_reselect, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_carrier(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.use_carrier);\n}\nstatic DEVICE_ATTR(use_carrier, 0644,\n\t\t   bonding_show_carrier, bonding_sysfs_store_option);\n\n\n \nstatic ssize_t bonding_show_active_slave(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tstruct net_device *slave_dev;\n\tint count = 0;\n\n\trcu_read_lock();\n\tslave_dev = bond_option_active_slave_get_rcu(bond);\n\tif (slave_dev)\n\t\tcount = sysfs_emit(buf, \"%s\\n\", slave_dev->name);\n\trcu_read_unlock();\n\n\treturn count;\n}\nstatic DEVICE_ATTR(active_slave, 0644,\n\t\t   bonding_show_active_slave, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_mii_status(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tbool active = netif_carrier_ok(bond->dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", active ? \"up\" : \"down\");\n}\nstatic DEVICE_ATTR(mii_status, 0444, bonding_show_mii_status, NULL);\n\n \nstatic ssize_t bonding_show_ad_aggregator(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tint count = 0;\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tstruct ad_info ad_info;\n\n\t\tcount = sysfs_emit(buf, \"%d\\n\",\n\t\t\t\t   bond_3ad_get_active_agg_info(bond, &ad_info)\n\t\t\t\t   ?  0 : ad_info.aggregator_id);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(ad_aggregator, 0444, bonding_show_ad_aggregator, NULL);\n\n\n \nstatic ssize_t bonding_show_ad_num_ports(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tint count = 0;\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tstruct ad_info ad_info;\n\n\t\tcount = sysfs_emit(buf, \"%d\\n\",\n\t\t\t\t   bond_3ad_get_active_agg_info(bond, &ad_info)\n\t\t\t\t   ?  0 : ad_info.ports);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(ad_num_ports, 0444, bonding_show_ad_num_ports, NULL);\n\n\n \nstatic ssize_t bonding_show_ad_actor_key(struct device *d,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tint count = 0;\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN)) {\n\t\tstruct ad_info ad_info;\n\n\t\tcount = sysfs_emit(buf, \"%d\\n\",\n\t\t\t\t   bond_3ad_get_active_agg_info(bond, &ad_info)\n\t\t\t\t   ?  0 : ad_info.actor_key);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(ad_actor_key, 0444, bonding_show_ad_actor_key, NULL);\n\n\n \nstatic ssize_t bonding_show_ad_partner_key(struct device *d,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tint count = 0;\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN)) {\n\t\tstruct ad_info ad_info;\n\n\t\tcount = sysfs_emit(buf, \"%d\\n\",\n\t\t\t\t   bond_3ad_get_active_agg_info(bond, &ad_info)\n\t\t\t\t   ?  0 : ad_info.partner_key);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(ad_partner_key, 0444, bonding_show_ad_partner_key, NULL);\n\n\n \nstatic ssize_t bonding_show_ad_partner_mac(struct device *d,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tint count = 0;\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN)) {\n\t\tstruct ad_info ad_info;\n\n\t\tif (!bond_3ad_get_active_agg_info(bond, &ad_info))\n\t\t\tcount = sysfs_emit(buf, \"%pM\\n\", ad_info.partner_system);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(ad_partner_mac, 0444, bonding_show_ad_partner_mac, NULL);\n\n \nstatic ssize_t bonding_show_queue_id(struct device *d,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tint res = 0;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (res > (PAGE_SIZE - IFNAMSIZ - 6)) {\n\t\t\t \n\t\t\tif ((PAGE_SIZE - res) > 10)\n\t\t\t\tres = PAGE_SIZE - 10;\n\t\t\tres += sysfs_emit_at(buf, res, \"++more++ \");\n\t\t\tbreak;\n\t\t}\n\t\tres += sysfs_emit_at(buf, res, \"%s:%d \",\n\t\t\t\t     slave->dev->name, slave->queue_id);\n\t}\n\tif (res)\n\t\tbuf[res-1] = '\\n';  \n\n\trtnl_unlock();\n\n\treturn res;\n}\nstatic DEVICE_ATTR(queue_id, 0644, bonding_show_queue_id,\n\t\t   bonding_sysfs_store_option);\n\n\n \nstatic ssize_t bonding_show_slaves_active(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.all_slaves_active);\n}\nstatic DEVICE_ATTR(all_slaves_active, 0644,\n\t\t   bonding_show_slaves_active, bonding_sysfs_store_option);\n\n \nstatic ssize_t bonding_show_resend_igmp(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.resend_igmp);\n}\nstatic DEVICE_ATTR(resend_igmp, 0644,\n\t\t   bonding_show_resend_igmp, bonding_sysfs_store_option);\n\n\nstatic ssize_t bonding_show_lp_interval(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.lp_interval);\n}\nstatic DEVICE_ATTR(lp_interval, 0644,\n\t\t   bonding_show_lp_interval, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_tlb_dynamic_lb(struct device *d,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\treturn sysfs_emit(buf, \"%d\\n\", bond->params.tlb_dynamic_lb);\n}\nstatic DEVICE_ATTR(tlb_dynamic_lb, 0644,\n\t\t   bonding_show_tlb_dynamic_lb, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_packets_per_slave(struct device *d,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\tunsigned int packets_per_slave = bond->params.packets_per_slave;\n\n\treturn sysfs_emit(buf, \"%u\\n\", packets_per_slave);\n}\nstatic DEVICE_ATTR(packets_per_slave, 0644,\n\t\t   bonding_show_packets_per_slave, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_ad_actor_sys_prio(struct device *d,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN))\n\t\treturn sysfs_emit(buf, \"%hu\\n\", bond->params.ad_actor_sys_prio);\n\n\treturn 0;\n}\nstatic DEVICE_ATTR(ad_actor_sys_prio, 0644,\n\t\t   bonding_show_ad_actor_sys_prio, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_ad_actor_system(struct device *d,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN))\n\t\treturn sysfs_emit(buf, \"%pM\\n\", bond->params.ad_actor_system);\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR(ad_actor_system, 0644,\n\t\t   bonding_show_ad_actor_system, bonding_sysfs_store_option);\n\nstatic ssize_t bonding_show_ad_user_port_key(struct device *d,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct bonding *bond = to_bond(d);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD && capable(CAP_NET_ADMIN))\n\t\treturn sysfs_emit(buf, \"%hu\\n\", bond->params.ad_user_port_key);\n\n\treturn 0;\n}\nstatic DEVICE_ATTR(ad_user_port_key, 0644,\n\t\t   bonding_show_ad_user_port_key, bonding_sysfs_store_option);\n\nstatic struct attribute *per_bond_attrs[] = {\n\t&dev_attr_slaves.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_fail_over_mac.attr,\n\t&dev_attr_arp_validate.attr,\n\t&dev_attr_arp_all_targets.attr,\n\t&dev_attr_arp_interval.attr,\n\t&dev_attr_arp_ip_target.attr,\n\t&dev_attr_downdelay.attr,\n\t&dev_attr_updelay.attr,\n\t&dev_attr_peer_notif_delay.attr,\n\t&dev_attr_lacp_active.attr,\n\t&dev_attr_lacp_rate.attr,\n\t&dev_attr_ad_select.attr,\n\t&dev_attr_xmit_hash_policy.attr,\n\t&dev_attr_num_grat_arp.attr,\n\t&dev_attr_num_unsol_na.attr,\n\t&dev_attr_miimon.attr,\n\t&dev_attr_primary.attr,\n\t&dev_attr_primary_reselect.attr,\n\t&dev_attr_use_carrier.attr,\n\t&dev_attr_active_slave.attr,\n\t&dev_attr_mii_status.attr,\n\t&dev_attr_ad_aggregator.attr,\n\t&dev_attr_ad_num_ports.attr,\n\t&dev_attr_ad_actor_key.attr,\n\t&dev_attr_ad_partner_key.attr,\n\t&dev_attr_ad_partner_mac.attr,\n\t&dev_attr_queue_id.attr,\n\t&dev_attr_all_slaves_active.attr,\n\t&dev_attr_resend_igmp.attr,\n\t&dev_attr_min_links.attr,\n\t&dev_attr_lp_interval.attr,\n\t&dev_attr_packets_per_slave.attr,\n\t&dev_attr_tlb_dynamic_lb.attr,\n\t&dev_attr_ad_actor_sys_prio.attr,\n\t&dev_attr_ad_actor_system.attr,\n\t&dev_attr_ad_user_port_key.attr,\n\t&dev_attr_arp_missed_max.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bonding_group = {\n\t.name = \"bonding\",\n\t.attrs = per_bond_attrs,\n};\n\n \nint __net_init bond_create_sysfs(struct bond_net *bn)\n{\n\tint ret;\n\n\tbn->class_attr_bonding_masters = class_attr_bonding_masters;\n\tsysfs_attr_init(&bn->class_attr_bonding_masters.attr);\n\n\tret = netdev_class_create_file_ns(&bn->class_attr_bonding_masters,\n\t\t\t\t\t  bn->net);\n\t \n\tif (ret == -EEXIST) {\n\t\t \n\t\tif (netdev_name_in_use(bn->net,\n\t\t\t\t       class_attr_bonding_masters.attr.name))\n\t\t\tpr_err(\"network device named %s already exists in sysfs\\n\",\n\t\t\t       class_attr_bonding_masters.attr.name);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\n}\n\n \nvoid __net_exit bond_destroy_sysfs(struct bond_net *bn)\n{\n\tnetdev_class_remove_file_ns(&bn->class_attr_bonding_masters, bn->net);\n}\n\n \nvoid bond_prepare_sysfs_group(struct bonding *bond)\n{\n\tbond->dev->sysfs_groups[0] = &bonding_group;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}