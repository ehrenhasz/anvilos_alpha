{
  "module_name": "bond_procfs.c",
  "hash_id": "dedac2f2d92caac31e9a94205d927659e591bf0ac72a8ddadc3db045a860eb1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_procfs.c",
  "human_readable_source": "\n#include <linux/proc_fs.h>\n#include <linux/ethtool.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/bonding.h>\n\n#include \"bonding_priv.h\"\n\nstatic void *bond_info_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct bonding *bond = pde_data(file_inode(seq->file));\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tloff_t off = 0;\n\n\trcu_read_lock();\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tbond_for_each_slave_rcu(bond, slave, iter)\n\t\tif (++off == *pos)\n\t\t\treturn slave;\n\n\treturn NULL;\n}\n\nstatic void *bond_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bonding *bond = pde_data(file_inode(seq->file));\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tbool found = false;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn bond_first_slave_rcu(bond);\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (found)\n\t\t\treturn slave;\n\t\tif (slave == v)\n\t\t\tfound = true;\n\t}\n\n\treturn NULL;\n}\n\nstatic void bond_info_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic void bond_info_show_master(struct seq_file *seq)\n{\n\tstruct bonding *bond = pde_data(file_inode(seq->file));\n\tconst struct bond_opt_value *optval;\n\tstruct slave *curr, *primary;\n\tint i;\n\n\tcurr = rcu_dereference(bond->curr_active_slave);\n\n\tseq_printf(seq, \"Bonding Mode: %s\",\n\t\t   bond_mode_name(BOND_MODE(bond)));\n\n\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP &&\n\t    bond->params.fail_over_mac) {\n\t\toptval = bond_opt_get_val(BOND_OPT_FAIL_OVER_MAC,\n\t\t\t\t\t  bond->params.fail_over_mac);\n\t\tseq_printf(seq, \" (fail_over_mac %s)\", optval->string);\n\t}\n\n\tseq_printf(seq, \"\\n\");\n\n\tif (bond_mode_uses_xmit_hash(bond)) {\n\t\toptval = bond_opt_get_val(BOND_OPT_XMIT_HASH,\n\t\t\t\t\t  bond->params.xmit_policy);\n\t\tseq_printf(seq, \"Transmit Hash Policy: %s (%d)\\n\",\n\t\t\t   optval->string, bond->params.xmit_policy);\n\t}\n\n\tif (bond_uses_primary(bond)) {\n\t\tprimary = rcu_dereference(bond->primary_slave);\n\t\tseq_printf(seq, \"Primary Slave: %s\",\n\t\t\t   primary ? primary->dev->name : \"None\");\n\t\tif (primary) {\n\t\t\toptval = bond_opt_get_val(BOND_OPT_PRIMARY_RESELECT,\n\t\t\t\t\t\t  bond->params.primary_reselect);\n\t\t\tseq_printf(seq, \" (primary_reselect %s)\",\n\t\t\t\t   optval->string);\n\t\t}\n\n\t\tseq_printf(seq, \"\\nCurrently Active Slave: %s\\n\",\n\t\t\t   (curr) ? curr->dev->name : \"None\");\n\t}\n\n\tseq_printf(seq, \"MII Status: %s\\n\", netif_carrier_ok(bond->dev) ?\n\t\t   \"up\" : \"down\");\n\tseq_printf(seq, \"MII Polling Interval (ms): %d\\n\", bond->params.miimon);\n\tseq_printf(seq, \"Up Delay (ms): %d\\n\",\n\t\t   bond->params.updelay * bond->params.miimon);\n\tseq_printf(seq, \"Down Delay (ms): %d\\n\",\n\t\t   bond->params.downdelay * bond->params.miimon);\n\tseq_printf(seq, \"Peer Notification Delay (ms): %d\\n\",\n\t\t   bond->params.peer_notif_delay * bond->params.miimon);\n\n\n\t \n\tif (bond->params.arp_interval > 0) {\n\t\tint printed = 0;\n\n\t\tseq_printf(seq, \"ARP Polling Interval (ms): %d\\n\",\n\t\t\t\tbond->params.arp_interval);\n\t\tseq_printf(seq, \"ARP Missed Max: %u\\n\",\n\t\t\t\tbond->params.missed_max);\n\n\t\tseq_printf(seq, \"ARP IP target/s (n.n.n.n form):\");\n\n\t\tfor (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {\n\t\t\tif (!bond->params.arp_targets[i])\n\t\t\t\tbreak;\n\t\t\tif (printed)\n\t\t\t\tseq_printf(seq, \",\");\n\t\t\tseq_printf(seq, \" %pI4\", &bond->params.arp_targets[i]);\n\t\t\tprinted = 1;\n\t\t}\n\t\tseq_printf(seq, \"\\n\");\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tprinted = 0;\n\t\tseq_printf(seq, \"NS IPv6 target/s (xx::xx form):\");\n\n\t\tfor (i = 0; (i < BOND_MAX_NS_TARGETS); i++) {\n\t\t\tif (ipv6_addr_any(&bond->params.ns_targets[i]))\n\t\t\t\tbreak;\n\t\t\tif (printed)\n\t\t\t\tseq_printf(seq, \",\");\n\t\t\tseq_printf(seq, \" %pI6c\", &bond->params.ns_targets[i]);\n\t\t\tprinted = 1;\n\t\t}\n\t\tseq_printf(seq, \"\\n\");\n#endif\n\t}\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tstruct ad_info ad_info;\n\n\t\tseq_puts(seq, \"\\n802.3ad info\\n\");\n\t\tseq_printf(seq, \"LACP active: %s\\n\",\n\t\t\t   (bond->params.lacp_active) ? \"on\" : \"off\");\n\t\tseq_printf(seq, \"LACP rate: %s\\n\",\n\t\t\t   (bond->params.lacp_fast) ? \"fast\" : \"slow\");\n\t\tseq_printf(seq, \"Min links: %d\\n\", bond->params.min_links);\n\t\toptval = bond_opt_get_val(BOND_OPT_AD_SELECT,\n\t\t\t\t\t  bond->params.ad_select);\n\t\tseq_printf(seq, \"Aggregator selection policy (ad_select): %s\\n\",\n\t\t\t   optval->string);\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tseq_printf(seq, \"System priority: %d\\n\",\n\t\t\t\t   BOND_AD_INFO(bond).system.sys_priority);\n\t\t\tseq_printf(seq, \"System MAC address: %pM\\n\",\n\t\t\t\t   &BOND_AD_INFO(bond).system.sys_mac_addr);\n\n\t\t\tif (__bond_3ad_get_active_agg_info(bond, &ad_info)) {\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"bond %s has no active aggregator\\n\",\n\t\t\t\t\t   bond->dev->name);\n\t\t\t} else {\n\t\t\t\tseq_printf(seq, \"Active Aggregator Info:\\n\");\n\n\t\t\t\tseq_printf(seq, \"\\tAggregator ID: %d\\n\",\n\t\t\t\t\t   ad_info.aggregator_id);\n\t\t\t\tseq_printf(seq, \"\\tNumber of ports: %d\\n\",\n\t\t\t\t\t   ad_info.ports);\n\t\t\t\tseq_printf(seq, \"\\tActor Key: %d\\n\",\n\t\t\t\t\t   ad_info.actor_key);\n\t\t\t\tseq_printf(seq, \"\\tPartner Key: %d\\n\",\n\t\t\t\t\t   ad_info.partner_key);\n\t\t\t\tseq_printf(seq, \"\\tPartner Mac Address: %pM\\n\",\n\t\t\t\t\t   ad_info.partner_system);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bond_info_show_slave(struct seq_file *seq,\n\t\t\t\t const struct slave *slave)\n{\n\tstruct bonding *bond = pde_data(file_inode(seq->file));\n\n\tseq_printf(seq, \"\\nSlave Interface: %s\\n\", slave->dev->name);\n\tseq_printf(seq, \"MII Status: %s\\n\", bond_slave_link_status(slave->link));\n\tif (slave->speed == SPEED_UNKNOWN)\n\t\tseq_printf(seq, \"Speed: %s\\n\", \"Unknown\");\n\telse\n\t\tseq_printf(seq, \"Speed: %d Mbps\\n\", slave->speed);\n\n\tif (slave->duplex == DUPLEX_UNKNOWN)\n\t\tseq_printf(seq, \"Duplex: %s\\n\", \"Unknown\");\n\telse\n\t\tseq_printf(seq, \"Duplex: %s\\n\", slave->duplex ? \"full\" : \"half\");\n\n\tseq_printf(seq, \"Link Failure Count: %u\\n\",\n\t\t   slave->link_failure_count);\n\n\tseq_printf(seq, \"Permanent HW addr: %*phC\\n\",\n\t\t   slave->dev->addr_len, slave->perm_hwaddr);\n\tseq_printf(seq, \"Slave queue ID: %d\\n\", slave->queue_id);\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tconst struct port *port = &SLAVE_AD_INFO(slave)->port;\n\t\tconst struct aggregator *agg = port->aggregator;\n\n\t\tif (agg) {\n\t\t\tseq_printf(seq, \"Aggregator ID: %d\\n\",\n\t\t\t\t   agg->aggregator_identifier);\n\t\t\tseq_printf(seq, \"Actor Churn State: %s\\n\",\n\t\t\t\t   bond_3ad_churn_desc(port->sm_churn_actor_state));\n\t\t\tseq_printf(seq, \"Partner Churn State: %s\\n\",\n\t\t\t\t   bond_3ad_churn_desc(port->sm_churn_partner_state));\n\t\t\tseq_printf(seq, \"Actor Churned Count: %d\\n\",\n\t\t\t\t   port->churn_actor_count);\n\t\t\tseq_printf(seq, \"Partner Churned Count: %d\\n\",\n\t\t\t\t   port->churn_partner_count);\n\n\t\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\t\tseq_puts(seq, \"details actor lacp pdu:\\n\");\n\t\t\t\tseq_printf(seq, \"    system priority: %d\\n\",\n\t\t\t\t\t   port->actor_system_priority);\n\t\t\t\tseq_printf(seq, \"    system mac address: %pM\\n\",\n\t\t\t\t\t   &port->actor_system);\n\t\t\t\tseq_printf(seq, \"    port key: %d\\n\",\n\t\t\t\t\t   port->actor_oper_port_key);\n\t\t\t\tseq_printf(seq, \"    port priority: %d\\n\",\n\t\t\t\t\t   port->actor_port_priority);\n\t\t\t\tseq_printf(seq, \"    port number: %d\\n\",\n\t\t\t\t\t   port->actor_port_number);\n\t\t\t\tseq_printf(seq, \"    port state: %d\\n\",\n\t\t\t\t\t   port->actor_oper_port_state);\n\n\t\t\t\tseq_puts(seq, \"details partner lacp pdu:\\n\");\n\t\t\t\tseq_printf(seq, \"    system priority: %d\\n\",\n\t\t\t\t\t   port->partner_oper.system_priority);\n\t\t\t\tseq_printf(seq, \"    system mac address: %pM\\n\",\n\t\t\t\t\t   &port->partner_oper.system);\n\t\t\t\tseq_printf(seq, \"    oper key: %d\\n\",\n\t\t\t\t\t   port->partner_oper.key);\n\t\t\t\tseq_printf(seq, \"    port priority: %d\\n\",\n\t\t\t\t\t   port->partner_oper.port_priority);\n\t\t\t\tseq_printf(seq, \"    port number: %d\\n\",\n\t\t\t\t\t   port->partner_oper.port_number);\n\t\t\t\tseq_printf(seq, \"    port state: %d\\n\",\n\t\t\t\t\t   port->partner_oper.port_state);\n\t\t\t}\n\t\t} else {\n\t\t\tseq_puts(seq, \"Aggregator ID: N/A\\n\");\n\t\t}\n\t}\n}\n\nstatic int bond_info_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq, \"%s\\n\", bond_version);\n\t\tbond_info_show_master(seq);\n\t} else\n\t\tbond_info_show_slave(seq, v);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations bond_info_seq_ops = {\n\t.start = bond_info_seq_start,\n\t.next  = bond_info_seq_next,\n\t.stop  = bond_info_seq_stop,\n\t.show  = bond_info_seq_show,\n};\n\nvoid bond_create_proc_entry(struct bonding *bond)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\tstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\n\n\tif (bn->proc_dir) {\n\t\tbond->proc_entry = proc_create_seq_data(bond_dev->name, 0444,\n\t\t\t\tbn->proc_dir, &bond_info_seq_ops, bond);\n\t\tif (bond->proc_entry == NULL)\n\t\t\tnetdev_warn(bond_dev, \"Cannot create /proc/net/%s/%s\\n\",\n\t\t\t\t    DRV_NAME, bond_dev->name);\n\t\telse\n\t\t\tmemcpy(bond->proc_file_name, bond_dev->name, IFNAMSIZ);\n\t}\n}\n\nvoid bond_remove_proc_entry(struct bonding *bond)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\tstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\n\n\tif (bn->proc_dir && bond->proc_entry) {\n\t\tremove_proc_entry(bond->proc_file_name, bn->proc_dir);\n\t\tmemset(bond->proc_file_name, 0, IFNAMSIZ);\n\t\tbond->proc_entry = NULL;\n\t}\n}\n\n \nvoid __net_init bond_create_proc_dir(struct bond_net *bn)\n{\n\tif (!bn->proc_dir) {\n\t\tbn->proc_dir = proc_mkdir(DRV_NAME, bn->net->proc_net);\n\t\tif (!bn->proc_dir)\n\t\t\tpr_warn(\"Warning: Cannot create /proc/net/%s\\n\",\n\t\t\t\tDRV_NAME);\n\t}\n}\n\n \nvoid __net_exit bond_destroy_proc_dir(struct bond_net *bn)\n{\n\tif (bn->proc_dir) {\n\t\tremove_proc_entry(DRV_NAME, bn->net->proc_net);\n\t\tbn->proc_dir = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}