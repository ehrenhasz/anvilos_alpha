{
  "module_name": "bond_options.c",
  "hash_id": "4ebfe552dec667998dd38f01e03ef6b98dd484e32981cbf204dee2b7d6387e68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_options.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/if.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/sched/signal.h>\n\n#include <net/bonding.h>\n\nstatic int bond_option_active_slave_set(struct bonding *bond,\n\t\t\t\t\tconst struct bond_opt_value *newval);\nstatic int bond_option_miimon_set(struct bonding *bond,\n\t\t\t\t  const struct bond_opt_value *newval);\nstatic int bond_option_updelay_set(struct bonding *bond,\n\t\t\t\t   const struct bond_opt_value *newval);\nstatic int bond_option_downdelay_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval);\nstatic int bond_option_peer_notif_delay_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval);\nstatic int bond_option_use_carrier_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval);\nstatic int bond_option_arp_interval_set(struct bonding *bond,\n\t\t\t\t\tconst struct bond_opt_value *newval);\nstatic int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target);\nstatic int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target);\nstatic int bond_option_arp_ip_targets_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval);\nstatic int bond_option_ns_ip6_targets_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval);\nstatic int bond_option_arp_validate_set(struct bonding *bond,\n\t\t\t\t\tconst struct bond_opt_value *newval);\nstatic int bond_option_arp_all_targets_set(struct bonding *bond,\n\t\t\t\t\t   const struct bond_opt_value *newval);\nstatic int bond_option_prio_set(struct bonding *bond,\n\t\t\t\tconst struct bond_opt_value *newval);\nstatic int bond_option_primary_set(struct bonding *bond,\n\t\t\t\t   const struct bond_opt_value *newval);\nstatic int bond_option_primary_reselect_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval);\nstatic int bond_option_fail_over_mac_set(struct bonding *bond,\n\t\t\t\t\t const struct bond_opt_value *newval);\nstatic int bond_option_xmit_hash_policy_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval);\nstatic int bond_option_resend_igmp_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval);\nstatic int bond_option_num_peer_notif_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval);\nstatic int bond_option_all_slaves_active_set(struct bonding *bond,\n\t\t\t\t\t     const struct bond_opt_value *newval);\nstatic int bond_option_min_links_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval);\nstatic int bond_option_lp_interval_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval);\nstatic int bond_option_pps_set(struct bonding *bond,\n\t\t\t       const struct bond_opt_value *newval);\nstatic int bond_option_lacp_active_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval);\nstatic int bond_option_lacp_rate_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval);\nstatic int bond_option_ad_select_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval);\nstatic int bond_option_queue_id_set(struct bonding *bond,\n\t\t\t\t    const struct bond_opt_value *newval);\nstatic int bond_option_mode_set(struct bonding *bond,\n\t\t\t\tconst struct bond_opt_value *newval);\nstatic int bond_option_slaves_set(struct bonding *bond,\n\t\t\t\t  const struct bond_opt_value *newval);\nstatic int bond_option_tlb_dynamic_lb_set(struct bonding *bond,\n\t\t\t\t  const struct bond_opt_value *newval);\nstatic int bond_option_ad_actor_sys_prio_set(struct bonding *bond,\n\t\t\t\t\t     const struct bond_opt_value *newval);\nstatic int bond_option_ad_actor_system_set(struct bonding *bond,\n\t\t\t\t\t   const struct bond_opt_value *newval);\nstatic int bond_option_ad_user_port_key_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval);\nstatic int bond_option_missed_max_set(struct bonding *bond,\n\t\t\t\t      const struct bond_opt_value *newval);\n\n\nstatic const struct bond_opt_value bond_mode_tbl[] = {\n\t{ \"balance-rr\",    BOND_MODE_ROUNDROBIN,   BOND_VALFLAG_DEFAULT},\n\t{ \"active-backup\", BOND_MODE_ACTIVEBACKUP, 0},\n\t{ \"balance-xor\",   BOND_MODE_XOR,          0},\n\t{ \"broadcast\",     BOND_MODE_BROADCAST,    0},\n\t{ \"802.3ad\",       BOND_MODE_8023AD,       0},\n\t{ \"balance-tlb\",   BOND_MODE_TLB,          0},\n\t{ \"balance-alb\",   BOND_MODE_ALB,          0},\n\t{ NULL,            -1,                     0},\n};\n\nstatic const struct bond_opt_value bond_pps_tbl[] = {\n\t{ \"default\", 1,         BOND_VALFLAG_DEFAULT},\n\t{ \"maxval\",  USHRT_MAX, BOND_VALFLAG_MAX},\n\t{ NULL,      -1,        0},\n};\n\nstatic const struct bond_opt_value bond_xmit_hashtype_tbl[] = {\n\t{ \"layer2\",      BOND_XMIT_POLICY_LAYER2,      BOND_VALFLAG_DEFAULT},\n\t{ \"layer3+4\",    BOND_XMIT_POLICY_LAYER34,     0},\n\t{ \"layer2+3\",    BOND_XMIT_POLICY_LAYER23,     0},\n\t{ \"encap2+3\",    BOND_XMIT_POLICY_ENCAP23,     0},\n\t{ \"encap3+4\",    BOND_XMIT_POLICY_ENCAP34,     0},\n\t{ \"vlan+srcmac\", BOND_XMIT_POLICY_VLAN_SRCMAC, 0},\n\t{ NULL,          -1,                           0},\n};\n\nstatic const struct bond_opt_value bond_arp_validate_tbl[] = {\n\t{ \"none\",\t\tBOND_ARP_VALIDATE_NONE,\t\tBOND_VALFLAG_DEFAULT},\n\t{ \"active\",\t\tBOND_ARP_VALIDATE_ACTIVE,\t0},\n\t{ \"backup\",\t\tBOND_ARP_VALIDATE_BACKUP,\t0},\n\t{ \"all\",\t\tBOND_ARP_VALIDATE_ALL,\t\t0},\n\t{ \"filter\",\t\tBOND_ARP_FILTER,\t\t0},\n\t{ \"filter_active\",\tBOND_ARP_FILTER_ACTIVE,\t\t0},\n\t{ \"filter_backup\",\tBOND_ARP_FILTER_BACKUP,\t\t0},\n\t{ NULL,\t\t\t-1,\t\t\t\t0},\n};\n\nstatic const struct bond_opt_value bond_arp_all_targets_tbl[] = {\n\t{ \"any\", BOND_ARP_TARGETS_ANY, BOND_VALFLAG_DEFAULT},\n\t{ \"all\", BOND_ARP_TARGETS_ALL, 0},\n\t{ NULL,  -1,                   0},\n};\n\nstatic const struct bond_opt_value bond_fail_over_mac_tbl[] = {\n\t{ \"none\",   BOND_FOM_NONE,   BOND_VALFLAG_DEFAULT},\n\t{ \"active\", BOND_FOM_ACTIVE, 0},\n\t{ \"follow\", BOND_FOM_FOLLOW, 0},\n\t{ NULL,     -1,              0},\n};\n\nstatic const struct bond_opt_value bond_intmax_tbl[] = {\n\t{ \"off\",     0,       BOND_VALFLAG_DEFAULT},\n\t{ \"maxval\",  INT_MAX, BOND_VALFLAG_MAX},\n\t{ NULL,      -1,      0}\n};\n\nstatic const struct bond_opt_value bond_lacp_active[] = {\n\t{ \"off\", 0,  0},\n\t{ \"on\",  1,  BOND_VALFLAG_DEFAULT},\n\t{ NULL,  -1, 0}\n};\n\nstatic const struct bond_opt_value bond_lacp_rate_tbl[] = {\n\t{ \"slow\", AD_LACP_SLOW, 0},\n\t{ \"fast\", AD_LACP_FAST, 0},\n\t{ NULL,   -1,           0},\n};\n\nstatic const struct bond_opt_value bond_ad_select_tbl[] = {\n\t{ \"stable\",    BOND_AD_STABLE,    BOND_VALFLAG_DEFAULT},\n\t{ \"bandwidth\", BOND_AD_BANDWIDTH, 0},\n\t{ \"count\",     BOND_AD_COUNT,     0},\n\t{ NULL,        -1,                0},\n};\n\nstatic const struct bond_opt_value bond_num_peer_notif_tbl[] = {\n\t{ \"off\",     0,   0},\n\t{ \"maxval\",  255, BOND_VALFLAG_MAX},\n\t{ \"default\", 1,   BOND_VALFLAG_DEFAULT},\n\t{ NULL,      -1,  0}\n};\n\nstatic const struct bond_opt_value bond_peer_notif_delay_tbl[] = {\n\t{ \"off\",     0,   0},\n\t{ \"maxval\",  300000, BOND_VALFLAG_MAX},\n\t{ NULL,      -1,  0}\n};\n\nstatic const struct bond_opt_value bond_primary_reselect_tbl[] = {\n\t{ \"always\",  BOND_PRI_RESELECT_ALWAYS,  BOND_VALFLAG_DEFAULT},\n\t{ \"better\",  BOND_PRI_RESELECT_BETTER,  0},\n\t{ \"failure\", BOND_PRI_RESELECT_FAILURE, 0},\n\t{ NULL,      -1},\n};\n\nstatic const struct bond_opt_value bond_use_carrier_tbl[] = {\n\t{ \"off\", 0,  0},\n\t{ \"on\",  1,  BOND_VALFLAG_DEFAULT},\n\t{ NULL,  -1, 0}\n};\n\nstatic const struct bond_opt_value bond_all_slaves_active_tbl[] = {\n\t{ \"off\", 0,  BOND_VALFLAG_DEFAULT},\n\t{ \"on\",  1,  0},\n\t{ NULL,  -1, 0}\n};\n\nstatic const struct bond_opt_value bond_resend_igmp_tbl[] = {\n\t{ \"off\",     0,   0},\n\t{ \"maxval\",  255, BOND_VALFLAG_MAX},\n\t{ \"default\", 1,   BOND_VALFLAG_DEFAULT},\n\t{ NULL,      -1,  0}\n};\n\nstatic const struct bond_opt_value bond_lp_interval_tbl[] = {\n\t{ \"minval\",  1,       BOND_VALFLAG_MIN | BOND_VALFLAG_DEFAULT},\n\t{ \"maxval\",  INT_MAX, BOND_VALFLAG_MAX},\n\t{ NULL,      -1,      0},\n};\n\nstatic const struct bond_opt_value bond_tlb_dynamic_lb_tbl[] = {\n\t{ \"off\", 0,  0},\n\t{ \"on\",  1,  BOND_VALFLAG_DEFAULT},\n\t{ NULL,  -1, 0}\n};\n\nstatic const struct bond_opt_value bond_ad_actor_sys_prio_tbl[] = {\n\t{ \"minval\",  1,     BOND_VALFLAG_MIN},\n\t{ \"maxval\",  65535, BOND_VALFLAG_MAX | BOND_VALFLAG_DEFAULT},\n\t{ NULL,      -1,    0},\n};\n\nstatic const struct bond_opt_value bond_ad_user_port_key_tbl[] = {\n\t{ \"minval\",  0,     BOND_VALFLAG_MIN | BOND_VALFLAG_DEFAULT},\n\t{ \"maxval\",  1023,  BOND_VALFLAG_MAX},\n\t{ NULL,      -1,    0},\n};\n\nstatic const struct bond_opt_value bond_missed_max_tbl[] = {\n\t{ \"minval\",\t1,\tBOND_VALFLAG_MIN},\n\t{ \"maxval\",\t255,\tBOND_VALFLAG_MAX},\n\t{ \"default\",\t2,\tBOND_VALFLAG_DEFAULT},\n\t{ NULL,\t\t-1,\t0},\n};\n\nstatic const struct bond_option bond_opts[BOND_OPT_LAST] = {\n\t[BOND_OPT_MODE] = {\n\t\t.id = BOND_OPT_MODE,\n\t\t.name = \"mode\",\n\t\t.desc = \"bond device mode\",\n\t\t.flags = BOND_OPTFLAG_NOSLAVES | BOND_OPTFLAG_IFDOWN,\n\t\t.values = bond_mode_tbl,\n\t\t.set = bond_option_mode_set\n\t},\n\t[BOND_OPT_PACKETS_PER_SLAVE] = {\n\t\t.id = BOND_OPT_PACKETS_PER_SLAVE,\n\t\t.name = \"packets_per_slave\",\n\t\t.desc = \"Packets to send per slave in RR mode\",\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ROUNDROBIN)),\n\t\t.values = bond_pps_tbl,\n\t\t.set = bond_option_pps_set\n\t},\n\t[BOND_OPT_XMIT_HASH] = {\n\t\t.id = BOND_OPT_XMIT_HASH,\n\t\t.name = \"xmit_hash_policy\",\n\t\t.desc = \"balance-xor, 802.3ad, and tlb hashing method\",\n\t\t.values = bond_xmit_hashtype_tbl,\n\t\t.set = bond_option_xmit_hash_policy_set\n\t},\n\t[BOND_OPT_ARP_VALIDATE] = {\n\t\t.id = BOND_OPT_ARP_VALIDATE,\n\t\t.name = \"arp_validate\",\n\t\t.desc = \"validate src/dst of ARP probes\",\n\t\t.unsuppmodes = BIT(BOND_MODE_8023AD) | BIT(BOND_MODE_TLB) |\n\t\t\t       BIT(BOND_MODE_ALB),\n\t\t.values = bond_arp_validate_tbl,\n\t\t.set = bond_option_arp_validate_set\n\t},\n\t[BOND_OPT_ARP_ALL_TARGETS] = {\n\t\t.id = BOND_OPT_ARP_ALL_TARGETS,\n\t\t.name = \"arp_all_targets\",\n\t\t.desc = \"fail on any/all arp targets timeout\",\n\t\t.values = bond_arp_all_targets_tbl,\n\t\t.set = bond_option_arp_all_targets_set\n\t},\n\t[BOND_OPT_FAIL_OVER_MAC] = {\n\t\t.id = BOND_OPT_FAIL_OVER_MAC,\n\t\t.name = \"fail_over_mac\",\n\t\t.desc = \"For active-backup, do not set all slaves to the same MAC\",\n\t\t.flags = BOND_OPTFLAG_NOSLAVES,\n\t\t.values = bond_fail_over_mac_tbl,\n\t\t.set = bond_option_fail_over_mac_set\n\t},\n\t[BOND_OPT_ARP_INTERVAL] = {\n\t\t.id = BOND_OPT_ARP_INTERVAL,\n\t\t.name = \"arp_interval\",\n\t\t.desc = \"arp interval in milliseconds\",\n\t\t.unsuppmodes = BIT(BOND_MODE_8023AD) | BIT(BOND_MODE_TLB) |\n\t\t\t       BIT(BOND_MODE_ALB),\n\t\t.values = bond_intmax_tbl,\n\t\t.set = bond_option_arp_interval_set\n\t},\n\t[BOND_OPT_MISSED_MAX] = {\n\t\t.id = BOND_OPT_MISSED_MAX,\n\t\t.name = \"arp_missed_max\",\n\t\t.desc = \"Maximum number of missed ARP interval\",\n\t\t.unsuppmodes = BIT(BOND_MODE_8023AD) | BIT(BOND_MODE_TLB) |\n\t\t\t       BIT(BOND_MODE_ALB),\n\t\t.values = bond_missed_max_tbl,\n\t\t.set = bond_option_missed_max_set\n\t},\n\t[BOND_OPT_ARP_TARGETS] = {\n\t\t.id = BOND_OPT_ARP_TARGETS,\n\t\t.name = \"arp_ip_target\",\n\t\t.desc = \"arp targets in n.n.n.n form\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.set = bond_option_arp_ip_targets_set\n\t},\n\t[BOND_OPT_NS_TARGETS] = {\n\t\t.id = BOND_OPT_NS_TARGETS,\n\t\t.name = \"ns_ip6_target\",\n\t\t.desc = \"NS targets in ffff:ffff::ffff:ffff form\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.set = bond_option_ns_ip6_targets_set\n\t},\n\t[BOND_OPT_DOWNDELAY] = {\n\t\t.id = BOND_OPT_DOWNDELAY,\n\t\t.name = \"downdelay\",\n\t\t.desc = \"Delay before considering link down, in milliseconds\",\n\t\t.values = bond_intmax_tbl,\n\t\t.set = bond_option_downdelay_set\n\t},\n\t[BOND_OPT_UPDELAY] = {\n\t\t.id = BOND_OPT_UPDELAY,\n\t\t.name = \"updelay\",\n\t\t.desc = \"Delay before considering link up, in milliseconds\",\n\t\t.values = bond_intmax_tbl,\n\t\t.set = bond_option_updelay_set\n\t},\n\t[BOND_OPT_LACP_ACTIVE] = {\n\t\t.id = BOND_OPT_LACP_ACTIVE,\n\t\t.name = \"lacp_active\",\n\t\t.desc = \"Send LACPDU frames with configured lacp rate or acts as speak when spoken to\",\n\t\t.flags = BOND_OPTFLAG_IFDOWN,\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),\n\t\t.values = bond_lacp_active,\n\t\t.set = bond_option_lacp_active_set\n\t},\n\t[BOND_OPT_LACP_RATE] = {\n\t\t.id = BOND_OPT_LACP_RATE,\n\t\t.name = \"lacp_rate\",\n\t\t.desc = \"LACPDU tx rate to request from 802.3ad partner\",\n\t\t.flags = BOND_OPTFLAG_IFDOWN,\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),\n\t\t.values = bond_lacp_rate_tbl,\n\t\t.set = bond_option_lacp_rate_set\n\t},\n\t[BOND_OPT_MINLINKS] = {\n\t\t.id = BOND_OPT_MINLINKS,\n\t\t.name = \"min_links\",\n\t\t.desc = \"Minimum number of available links before turning on carrier\",\n\t\t.values = bond_intmax_tbl,\n\t\t.set = bond_option_min_links_set\n\t},\n\t[BOND_OPT_AD_SELECT] = {\n\t\t.id = BOND_OPT_AD_SELECT,\n\t\t.name = \"ad_select\",\n\t\t.desc = \"803.ad aggregation selection logic\",\n\t\t.flags = BOND_OPTFLAG_IFDOWN,\n\t\t.values = bond_ad_select_tbl,\n\t\t.set = bond_option_ad_select_set\n\t},\n\t[BOND_OPT_NUM_PEER_NOTIF] = {\n\t\t.id = BOND_OPT_NUM_PEER_NOTIF,\n\t\t.name = \"num_unsol_na\",\n\t\t.desc = \"Number of peer notifications to send on failover event\",\n\t\t.values = bond_num_peer_notif_tbl,\n\t\t.set = bond_option_num_peer_notif_set\n\t},\n\t[BOND_OPT_MIIMON] = {\n\t\t.id = BOND_OPT_MIIMON,\n\t\t.name = \"miimon\",\n\t\t.desc = \"Link check interval in milliseconds\",\n\t\t.values = bond_intmax_tbl,\n\t\t.set = bond_option_miimon_set\n\t},\n\t[BOND_OPT_PRIO] = {\n\t\t.id = BOND_OPT_PRIO,\n\t\t.name = \"prio\",\n\t\t.desc = \"Link priority for failover re-selection\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP) |\n\t\t\t\t\t\tBIT(BOND_MODE_TLB) |\n\t\t\t\t\t\tBIT(BOND_MODE_ALB)),\n\t\t.set = bond_option_prio_set\n\t},\n\t[BOND_OPT_PRIMARY] = {\n\t\t.id = BOND_OPT_PRIMARY,\n\t\t.name = \"primary\",\n\t\t.desc = \"Primary network device to use\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP) |\n\t\t\t\t\t\tBIT(BOND_MODE_TLB) |\n\t\t\t\t\t\tBIT(BOND_MODE_ALB)),\n\t\t.set = bond_option_primary_set\n\t},\n\t[BOND_OPT_PRIMARY_RESELECT] = {\n\t\t.id = BOND_OPT_PRIMARY_RESELECT,\n\t\t.name = \"primary_reselect\",\n\t\t.desc = \"Reselect primary slave once it comes up\",\n\t\t.values = bond_primary_reselect_tbl,\n\t\t.set = bond_option_primary_reselect_set\n\t},\n\t[BOND_OPT_USE_CARRIER] = {\n\t\t.id = BOND_OPT_USE_CARRIER,\n\t\t.name = \"use_carrier\",\n\t\t.desc = \"Use netif_carrier_ok (vs MII ioctls) in miimon\",\n\t\t.values = bond_use_carrier_tbl,\n\t\t.set = bond_option_use_carrier_set\n\t},\n\t[BOND_OPT_ACTIVE_SLAVE] = {\n\t\t.id = BOND_OPT_ACTIVE_SLAVE,\n\t\t.name = \"active_slave\",\n\t\t.desc = \"Currently active slave\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP) |\n\t\t\t\t\t\tBIT(BOND_MODE_TLB) |\n\t\t\t\t\t\tBIT(BOND_MODE_ALB)),\n\t\t.set = bond_option_active_slave_set\n\t},\n\t[BOND_OPT_QUEUE_ID] = {\n\t\t.id = BOND_OPT_QUEUE_ID,\n\t\t.name = \"queue_id\",\n\t\t.desc = \"Set queue id of a slave\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.set = bond_option_queue_id_set\n\t},\n\t[BOND_OPT_ALL_SLAVES_ACTIVE] = {\n\t\t.id = BOND_OPT_ALL_SLAVES_ACTIVE,\n\t\t.name = \"all_slaves_active\",\n\t\t.desc = \"Keep all frames received on an interface by setting active flag for all slaves\",\n\t\t.values = bond_all_slaves_active_tbl,\n\t\t.set = bond_option_all_slaves_active_set\n\t},\n\t[BOND_OPT_RESEND_IGMP] = {\n\t\t.id = BOND_OPT_RESEND_IGMP,\n\t\t.name = \"resend_igmp\",\n\t\t.desc = \"Number of IGMP membership reports to send on link failure\",\n\t\t.values = bond_resend_igmp_tbl,\n\t\t.set = bond_option_resend_igmp_set\n\t},\n\t[BOND_OPT_LP_INTERVAL] = {\n\t\t.id = BOND_OPT_LP_INTERVAL,\n\t\t.name = \"lp_interval\",\n\t\t.desc = \"The number of seconds between instances where the bonding driver sends learning packets to each slave's peer switch\",\n\t\t.values = bond_lp_interval_tbl,\n\t\t.set = bond_option_lp_interval_set\n\t},\n\t[BOND_OPT_SLAVES] = {\n\t\t.id = BOND_OPT_SLAVES,\n\t\t.name = \"slaves\",\n\t\t.desc = \"Slave membership management\",\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.set = bond_option_slaves_set\n\t},\n\t[BOND_OPT_TLB_DYNAMIC_LB] = {\n\t\t.id = BOND_OPT_TLB_DYNAMIC_LB,\n\t\t.name = \"tlb_dynamic_lb\",\n\t\t.desc = \"Enable dynamic flow shuffling\",\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_TLB) | BIT(BOND_MODE_ALB)),\n\t\t.values = bond_tlb_dynamic_lb_tbl,\n\t\t.flags = BOND_OPTFLAG_IFDOWN,\n\t\t.set = bond_option_tlb_dynamic_lb_set,\n\t},\n\t[BOND_OPT_AD_ACTOR_SYS_PRIO] = {\n\t\t.id = BOND_OPT_AD_ACTOR_SYS_PRIO,\n\t\t.name = \"ad_actor_sys_prio\",\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),\n\t\t.values = bond_ad_actor_sys_prio_tbl,\n\t\t.set = bond_option_ad_actor_sys_prio_set,\n\t},\n\t[BOND_OPT_AD_ACTOR_SYSTEM] = {\n\t\t.id = BOND_OPT_AD_ACTOR_SYSTEM,\n\t\t.name = \"ad_actor_system\",\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),\n\t\t.flags = BOND_OPTFLAG_RAWVAL,\n\t\t.set = bond_option_ad_actor_system_set,\n\t},\n\t[BOND_OPT_AD_USER_PORT_KEY] = {\n\t\t.id = BOND_OPT_AD_USER_PORT_KEY,\n\t\t.name = \"ad_user_port_key\",\n\t\t.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),\n\t\t.flags = BOND_OPTFLAG_IFDOWN,\n\t\t.values = bond_ad_user_port_key_tbl,\n\t\t.set = bond_option_ad_user_port_key_set,\n\t},\n\t[BOND_OPT_NUM_PEER_NOTIF_ALIAS] = {\n\t\t.id = BOND_OPT_NUM_PEER_NOTIF_ALIAS,\n\t\t.name = \"num_grat_arp\",\n\t\t.desc = \"Number of peer notifications to send on failover event\",\n\t\t.values = bond_num_peer_notif_tbl,\n\t\t.set = bond_option_num_peer_notif_set\n\t},\n\t[BOND_OPT_PEER_NOTIF_DELAY] = {\n\t\t.id = BOND_OPT_PEER_NOTIF_DELAY,\n\t\t.name = \"peer_notif_delay\",\n\t\t.desc = \"Delay between each peer notification on failover event, in milliseconds\",\n\t\t.values = bond_peer_notif_delay_tbl,\n\t\t.set = bond_option_peer_notif_delay_set\n\t}\n};\n\n \nconst struct bond_option *bond_opt_get_by_name(const char *name)\n{\n\tconst struct bond_option *opt;\n\tint option;\n\n\tfor (option = 0; option < BOND_OPT_LAST; option++) {\n\t\topt = bond_opt_get(option);\n\t\tif (opt && !strcmp(opt->name, name))\n\t\t\treturn opt;\n\t}\n\n\treturn NULL;\n}\n\n \nconst struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)\n{\n\tconst struct bond_option *opt;\n\tint i;\n\n\topt = bond_opt_get(option);\n\tif (WARN_ON(!opt))\n\t\treturn NULL;\n\tfor (i = 0; opt->values && opt->values[i].string; i++)\n\t\tif (opt->values[i].value == val)\n\t\t\treturn &opt->values[i];\n\n\treturn NULL;\n}\n\n \nstatic const struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,\n\t\t\t\t\t\t       u32 flagmask)\n{\n\tint i;\n\n\tfor (i = 0; opt->values && opt->values[i].string; i++)\n\t\tif (opt->values[i].flags & flagmask)\n\t\t\treturn &opt->values[i];\n\n\treturn NULL;\n}\n\n \nstatic bool bond_opt_check_range(const struct bond_option *opt, u64 val)\n{\n\tconst struct bond_opt_value *minval, *maxval;\n\n\tminval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);\n\tmaxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);\n\tif (!maxval || (minval && val < minval->value) || val > maxval->value)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nconst struct bond_opt_value *bond_opt_parse(const struct bond_option *opt,\n\t\t\t\t\t    struct bond_opt_value *val)\n{\n\tchar *p, valstr[BOND_OPT_MAX_NAMELEN + 1] = { 0, };\n\tconst struct bond_opt_value *tbl;\n\tconst struct bond_opt_value *ret = NULL;\n\tbool checkval;\n\tint i, rv;\n\n\t \n\tif (opt->flags & BOND_OPTFLAG_RAWVAL)\n\t\treturn val;\n\n\ttbl = opt->values;\n\tif (!tbl)\n\t\tgoto out;\n\n\t \n\tcheckval = val->value != ULLONG_MAX;\n\tif (!checkval) {\n\t\tif (!val->string)\n\t\t\tgoto out;\n\t\tp = strchr(val->string, '\\n');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t\tfor (p = val->string; *p; p++)\n\t\t\tif (!(isdigit(*p) || isspace(*p)))\n\t\t\t\tbreak;\n\t\t \n\t\tif (*p) {\n\t\t\trv = sscanf(val->string, \"%32s\", valstr);\n\t\t} else {\n\t\t\trv = sscanf(val->string, \"%llu\", &val->value);\n\t\t\tcheckval = true;\n\t\t}\n\t\tif (!rv)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; tbl[i].string; i++) {\n\t\t \n\t\tif (checkval) {\n\t\t\tif (val->value == tbl[i].value)\n\t\t\t\tret = &tbl[i];\n\t\t} else {\n\t\t\tif (!strcmp(valstr, \"default\") &&\n\t\t\t    (tbl[i].flags & BOND_VALFLAG_DEFAULT))\n\t\t\t\tret = &tbl[i];\n\n\t\t\tif (!strcmp(valstr, tbl[i].string))\n\t\t\t\tret = &tbl[i];\n\t\t}\n\t\t \n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t \n\tif (checkval && bond_opt_check_range(opt, val->value))\n\t\tret = val;\nout:\n\treturn ret;\n}\n\n \nstatic int bond_opt_check_deps(struct bonding *bond,\n\t\t\t       const struct bond_option *opt)\n{\n\tstruct bond_params *params = &bond->params;\n\n\tif (test_bit(params->mode, &opt->unsuppmodes))\n\t\treturn -EACCES;\n\tif ((opt->flags & BOND_OPTFLAG_NOSLAVES) && bond_has_slaves(bond))\n\t\treturn -ENOTEMPTY;\n\tif ((opt->flags & BOND_OPTFLAG_IFDOWN) && (bond->dev->flags & IFF_UP))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void bond_opt_dep_print(struct bonding *bond,\n\t\t\t       const struct bond_option *opt,\n\t\t\t       struct nlattr *bad_attr,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tconst struct bond_opt_value *modeval;\n\tstruct bond_params *params;\n\n\tparams = &bond->params;\n\tmodeval = bond_opt_get_val(BOND_OPT_MODE, params->mode);\n\tif (test_bit(params->mode, &opt->unsuppmodes)) {\n\t\tnetdev_err(bond->dev, \"option %s: mode dependency failed, not supported in mode %s(%llu)\\n\",\n\t\t\t   opt->name, modeval->string, modeval->value);\n\t\tNL_SET_ERR_MSG_ATTR(extack, bad_attr,\n\t\t\t\t    \"option not supported in mode\");\n\t}\n}\n\nstatic void bond_opt_error_interpret(struct bonding *bond,\n\t\t\t\t     const struct bond_option *opt,\n\t\t\t\t     int error, const struct bond_opt_value *val,\n\t\t\t\t     struct nlattr *bad_attr,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tconst struct bond_opt_value *minval, *maxval;\n\tchar *p;\n\n\tswitch (error) {\n\tcase -EINVAL:\n\t\tNL_SET_ERR_MSG_ATTR(extack, bad_attr, \"invalid option value\");\n\t\tif (val) {\n\t\t\tif (val->string) {\n\t\t\t\t \n\t\t\t\tp = strchr(val->string, '\\n');\n\t\t\t\tif (p)\n\t\t\t\t\t*p = '\\0';\n\t\t\t\tnetdev_err(bond->dev, \"option %s: invalid value (%s)\\n\",\n\t\t\t\t\t   opt->name, val->string);\n\t\t\t} else {\n\t\t\t\tnetdev_err(bond->dev, \"option %s: invalid value (%llu)\\n\",\n\t\t\t\t\t   opt->name, val->value);\n\t\t\t}\n\t\t}\n\t\tminval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);\n\t\tmaxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);\n\t\tif (!maxval)\n\t\t\tbreak;\n\t\tnetdev_err(bond->dev, \"option %s: allowed values %llu - %llu\\n\",\n\t\t\t   opt->name, minval ? minval->value : 0, maxval->value);\n\t\tbreak;\n\tcase -EACCES:\n\t\tbond_opt_dep_print(bond, opt, bad_attr, extack);\n\t\tbreak;\n\tcase -ENOTEMPTY:\n\t\tNL_SET_ERR_MSG_ATTR(extack, bad_attr,\n\t\t\t\t    \"unable to set option because the bond device has slaves\");\n\t\tnetdev_err(bond->dev, \"option %s: unable to set because the bond device has slaves\\n\",\n\t\t\t   opt->name);\n\t\tbreak;\n\tcase -EBUSY:\n\t\tNL_SET_ERR_MSG_ATTR(extack, bad_attr,\n\t\t\t\t    \"unable to set option because the bond is up\");\n\t\tnetdev_err(bond->dev, \"option %s: unable to set because the bond device is up\\n\",\n\t\t\t   opt->name);\n\t\tbreak;\n\tcase -ENODEV:\n\t\tif (val && val->string) {\n\t\t\tp = strchr(val->string, '\\n');\n\t\t\tif (p)\n\t\t\t\t*p = '\\0';\n\t\t\tnetdev_err(bond->dev, \"option %s: interface %s does not exist!\\n\",\n\t\t\t\t   opt->name, val->string);\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, bad_attr,\n\t\t\t\t\t    \"interface does not exist\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nint __bond_opt_set(struct bonding *bond,\n\t\t   unsigned int option, struct bond_opt_value *val,\n\t\t   struct nlattr *bad_attr, struct netlink_ext_ack *extack)\n{\n\tconst struct bond_opt_value *retval = NULL;\n\tconst struct bond_option *opt;\n\tint ret = -ENOENT;\n\n\tASSERT_RTNL();\n\n\topt = bond_opt_get(option);\n\tif (WARN_ON(!val) || WARN_ON(!opt))\n\t\tgoto out;\n\tret = bond_opt_check_deps(bond, opt);\n\tif (ret)\n\t\tgoto out;\n\tretval = bond_opt_parse(opt, val);\n\tif (!retval) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = opt->set(bond, retval);\nout:\n\tif (ret)\n\t\tbond_opt_error_interpret(bond, opt, ret, val, bad_attr, extack);\n\n\treturn ret;\n}\n \nint __bond_opt_set_notify(struct bonding *bond,\n\t\t\t  unsigned int option, struct bond_opt_value *val)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tret = __bond_opt_set(bond, option, val, NULL, NULL);\n\n\tif (!ret && (bond->dev->reg_state == NETREG_REGISTERED))\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond->dev);\n\n\treturn ret;\n}\n\n \nint bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf)\n{\n\tstruct bond_opt_value optval;\n\tint ret;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\tbond_opt_initstr(&optval, buf);\n\tret = __bond_opt_set_notify(bond, option, &optval);\n\trtnl_unlock();\n\n\treturn ret;\n}\n\n \nconst struct bond_option *bond_opt_get(unsigned int option)\n{\n\tif (!BOND_OPT_VALID(option))\n\t\treturn NULL;\n\n\treturn &bond_opts[option];\n}\n\nstatic bool bond_set_xfrm_features(struct bonding *bond)\n{\n\tif (!IS_ENABLED(CONFIG_XFRM_OFFLOAD))\n\t\treturn false;\n\n\tif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP)\n\t\tbond->dev->wanted_features |= BOND_XFRM_FEATURES;\n\telse\n\t\tbond->dev->wanted_features &= ~BOND_XFRM_FEATURES;\n\n\treturn true;\n}\n\nstatic int bond_option_mode_set(struct bonding *bond,\n\t\t\t\tconst struct bond_opt_value *newval)\n{\n\tif (!bond_mode_uses_arp(newval->value)) {\n\t\tif (bond->params.arp_interval) {\n\t\t\tnetdev_dbg(bond->dev, \"%s mode is incompatible with arp monitoring, start mii monitoring\\n\",\n\t\t\t\t   newval->string);\n\t\t\t \n\t\t\tbond->params.arp_interval = 0;\n\t\t}\n\n\t\tif (!bond->params.miimon) {\n\t\t\t \n\t\t\tbond->params.miimon = BOND_DEFAULT_MIIMON;\n\t\t\tnetdev_dbg(bond->dev, \"Setting MII monitoring interval to %d\\n\",\n\t\t\t\t   bond->params.miimon);\n\t\t}\n\t}\n\n\tif (newval->value == BOND_MODE_ALB)\n\t\tbond->params.tlb_dynamic_lb = 1;\n\n\t \n\tbond->params.arp_validate = BOND_ARP_VALIDATE_NONE;\n\tbond->params.mode = newval->value;\n\n\tif (bond->dev->reg_state == NETREG_REGISTERED) {\n\t\tbool update = false;\n\n\t\tupdate |= bond_set_xfrm_features(bond);\n\n\t\tif (update)\n\t\t\tnetdev_update_features(bond->dev);\n\t}\n\n\tbond_xdp_set_features(bond->dev);\n\n\treturn 0;\n}\n\nstatic int bond_option_active_slave_set(struct bonding *bond,\n\t\t\t\t\tconst struct bond_opt_value *newval)\n{\n\tchar ifname[IFNAMSIZ] = { 0, };\n\tstruct net_device *slave_dev;\n\tint ret = 0;\n\n\tsscanf(newval->string, \"%15s\", ifname);  \n\tif (!strlen(ifname) || newval->string[0] == '\\n') {\n\t\tslave_dev = NULL;\n\t} else {\n\t\tslave_dev = __dev_get_by_name(dev_net(bond->dev), ifname);\n\t\tif (!slave_dev)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (slave_dev) {\n\t\tif (!netif_is_bond_slave(slave_dev)) {\n\t\t\tslave_err(bond->dev, slave_dev, \"Device is not bonding slave\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bond->dev != netdev_master_upper_dev_get(slave_dev)) {\n\t\t\tslave_err(bond->dev, slave_dev, \"Device is not our slave\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tblock_netpoll_tx();\n\t \n\tif (!slave_dev) {\n\t\tnetdev_dbg(bond->dev, \"Clearing current active slave\\n\");\n\t\tRCU_INIT_POINTER(bond->curr_active_slave, NULL);\n\t\tbond_select_active_slave(bond);\n\t} else {\n\t\tstruct slave *old_active = rtnl_dereference(bond->curr_active_slave);\n\t\tstruct slave *new_active = bond_slave_get_rtnl(slave_dev);\n\n\t\tBUG_ON(!new_active);\n\n\t\tif (new_active == old_active) {\n\t\t\t \n\t\t\tslave_dbg(bond->dev, new_active->dev, \"is already the current active slave\\n\");\n\t\t} else {\n\t\t\tif (old_active && (new_active->link == BOND_LINK_UP) &&\n\t\t\t    bond_slave_is_up(new_active)) {\n\t\t\t\tslave_dbg(bond->dev, new_active->dev, \"Setting as active slave\\n\");\n\t\t\t\tbond_change_active_slave(bond, new_active);\n\t\t\t} else {\n\t\t\t\tslave_err(bond->dev, new_active->dev, \"Could not set as active slave; either %s is down or the link is down\\n\",\n\t\t\t\t\t  new_active->dev->name);\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tunblock_netpoll_tx();\n\n\treturn ret;\n}\n\n \nstatic int bond_option_miimon_set(struct bonding *bond,\n\t\t\t\t  const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting MII monitoring interval to %llu\\n\",\n\t\t   newval->value);\n\tbond->params.miimon = newval->value;\n\tif (bond->params.updelay)\n\t\tnetdev_dbg(bond->dev, \"Note: Updating updelay (to %d) since it is a multiple of the miimon value\\n\",\n\t\t\t   bond->params.updelay * bond->params.miimon);\n\tif (bond->params.downdelay)\n\t\tnetdev_dbg(bond->dev, \"Note: Updating downdelay (to %d) since it is a multiple of the miimon value\\n\",\n\t\t\t   bond->params.downdelay * bond->params.miimon);\n\tif (bond->params.peer_notif_delay)\n\t\tnetdev_dbg(bond->dev, \"Note: Updating peer_notif_delay (to %d) since it is a multiple of the miimon value\\n\",\n\t\t\t   bond->params.peer_notif_delay * bond->params.miimon);\n\tif (newval->value && bond->params.arp_interval) {\n\t\tnetdev_dbg(bond->dev, \"MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\\n\");\n\t\tbond->params.arp_interval = 0;\n\t\tif (bond->params.arp_validate)\n\t\t\tbond->params.arp_validate = BOND_ARP_VALIDATE_NONE;\n\t}\n\tif (bond->dev->flags & IFF_UP) {\n\t\t \n\t\tif (!newval->value) {\n\t\t\tcancel_delayed_work_sync(&bond->mii_work);\n\t\t} else {\n\t\t\tcancel_delayed_work_sync(&bond->arp_work);\n\t\t\tqueue_delayed_work(bond->wq, &bond->mii_work, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int _bond_option_delay_set(struct bonding *bond,\n\t\t\t\t  const struct bond_opt_value *newval,\n\t\t\t\t  const char *name,\n\t\t\t\t  int *target)\n{\n\tint value = newval->value;\n\n\tif (!bond->params.miimon) {\n\t\tnetdev_err(bond->dev, \"Unable to set %s as MII monitoring is disabled\\n\",\n\t\t\t   name);\n\t\treturn -EPERM;\n\t}\n\tif ((value % bond->params.miimon) != 0) {\n\t\tnetdev_warn(bond->dev,\n\t\t\t    \"%s (%d) is not a multiple of miimon (%d), value rounded to %d ms\\n\",\n\t\t\t    name,\n\t\t\t    value, bond->params.miimon,\n\t\t\t    (value / bond->params.miimon) *\n\t\t\t    bond->params.miimon);\n\t}\n\t*target = value / bond->params.miimon;\n\tnetdev_dbg(bond->dev, \"Setting %s to %d\\n\",\n\t\t   name,\n\t\t   *target * bond->params.miimon);\n\n\treturn 0;\n}\n\nstatic int bond_option_updelay_set(struct bonding *bond,\n\t\t\t\t   const struct bond_opt_value *newval)\n{\n\treturn _bond_option_delay_set(bond, newval, \"up delay\",\n\t\t\t\t      &bond->params.updelay);\n}\n\nstatic int bond_option_downdelay_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval)\n{\n\treturn _bond_option_delay_set(bond, newval, \"down delay\",\n\t\t\t\t      &bond->params.downdelay);\n}\n\nstatic int bond_option_peer_notif_delay_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval)\n{\n\tint ret = _bond_option_delay_set(bond, newval,\n\t\t\t\t\t \"peer notification delay\",\n\t\t\t\t\t &bond->params.peer_notif_delay);\n\treturn ret;\n}\n\nstatic int bond_option_use_carrier_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting use_carrier to %llu\\n\",\n\t\t   newval->value);\n\tbond->params.use_carrier = newval->value;\n\n\treturn 0;\n}\n\n \nstatic int bond_option_arp_interval_set(struct bonding *bond,\n\t\t\t\t\tconst struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting ARP monitoring interval to %llu\\n\",\n\t\t   newval->value);\n\tbond->params.arp_interval = newval->value;\n\tif (newval->value) {\n\t\tif (bond->params.miimon) {\n\t\t\tnetdev_dbg(bond->dev, \"ARP monitoring cannot be used with MII monitoring. Disabling MII monitoring\\n\");\n\t\t\tbond->params.miimon = 0;\n\t\t}\n\t\tif (!bond->params.arp_targets[0])\n\t\t\tnetdev_dbg(bond->dev, \"ARP monitoring has been set up, but no ARP targets have been specified\\n\");\n\t}\n\tif (bond->dev->flags & IFF_UP) {\n\t\t \n\t\tif (!newval->value) {\n\t\t\tif (bond->params.arp_validate)\n\t\t\t\tbond->recv_probe = NULL;\n\t\t\tcancel_delayed_work_sync(&bond->arp_work);\n\t\t} else {\n\t\t\t \n\t\t\tbond->recv_probe = bond_rcv_validate;\n\t\t\tcancel_delayed_work_sync(&bond->mii_work);\n\t\t\tqueue_delayed_work(bond->wq, &bond->arp_work, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void _bond_options_arp_ip_target_set(struct bonding *bond, int slot,\n\t\t\t\t\t    __be32 target,\n\t\t\t\t\t    unsigned long last_rx)\n{\n\t__be32 *targets = bond->params.arp_targets;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (slot >= 0 && slot < BOND_MAX_ARP_TARGETS) {\n\t\tbond_for_each_slave(bond, slave, iter)\n\t\t\tslave->target_last_arp_rx[slot] = last_rx;\n\t\ttargets[slot] = target;\n\t}\n}\n\nstatic int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)\n{\n\t__be32 *targets = bond->params.arp_targets;\n\tint ind;\n\n\tif (!bond_is_ip_target_ok(target)) {\n\t\tnetdev_err(bond->dev, \"invalid ARP target %pI4 specified for addition\\n\",\n\t\t\t   &target);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bond_get_targets_ip(targets, target) != -1) {  \n\t\tnetdev_err(bond->dev, \"ARP target %pI4 is already present\\n\",\n\t\t\t   &target);\n\t\treturn -EINVAL;\n\t}\n\n\tind = bond_get_targets_ip(targets, 0);  \n\tif (ind == -1) {\n\t\tnetdev_err(bond->dev, \"ARP target table is full!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev_dbg(bond->dev, \"Adding ARP target %pI4\\n\", &target);\n\n\t_bond_options_arp_ip_target_set(bond, ind, target, jiffies);\n\n\treturn 0;\n}\n\nstatic int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)\n{\n\treturn _bond_option_arp_ip_target_add(bond, target);\n}\n\nstatic int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)\n{\n\t__be32 *targets = bond->params.arp_targets;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\tunsigned long *targets_rx;\n\tint ind, i;\n\n\tif (!bond_is_ip_target_ok(target)) {\n\t\tnetdev_err(bond->dev, \"invalid ARP target %pI4 specified for removal\\n\",\n\t\t\t   &target);\n\t\treturn -EINVAL;\n\t}\n\n\tind = bond_get_targets_ip(targets, target);\n\tif (ind == -1) {\n\t\tnetdev_err(bond->dev, \"unable to remove nonexistent ARP target %pI4\\n\",\n\t\t\t   &target);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ind == 0 && !targets[1] && bond->params.arp_interval)\n\t\tnetdev_warn(bond->dev, \"Removing last arp target with arp_interval on\\n\");\n\n\tnetdev_dbg(bond->dev, \"Removing ARP target %pI4\\n\", &target);\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\ttargets_rx = slave->target_last_arp_rx;\n\t\tfor (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)\n\t\t\ttargets_rx[i] = targets_rx[i+1];\n\t\ttargets_rx[i] = 0;\n\t}\n\tfor (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)\n\t\ttargets[i] = targets[i+1];\n\ttargets[i] = 0;\n\n\treturn 0;\n}\n\nvoid bond_option_arp_ip_targets_clear(struct bonding *bond)\n{\n\tint i;\n\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++)\n\t\t_bond_options_arp_ip_target_set(bond, i, 0, 0);\n}\n\nstatic int bond_option_arp_ip_targets_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval)\n{\n\tint ret = -EPERM;\n\t__be32 target;\n\n\tif (newval->string) {\n\t\tif (!in4_pton(newval->string+1, -1, (u8 *)&target, -1, NULL)) {\n\t\t\tnetdev_err(bond->dev, \"invalid ARP target %pI4 specified\\n\",\n\t\t\t\t   &target);\n\t\t\treturn ret;\n\t\t}\n\t\tif (newval->string[0] == '+')\n\t\t\tret = bond_option_arp_ip_target_add(bond, target);\n\t\telse if (newval->string[0] == '-')\n\t\t\tret = bond_option_arp_ip_target_rem(bond, target);\n\t\telse\n\t\t\tnetdev_err(bond->dev, \"no command found in arp_ip_targets file - use +<addr> or -<addr>\\n\");\n\t} else {\n\t\ttarget = newval->value;\n\t\tret = bond_option_arp_ip_target_add(bond, target);\n\t}\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void _bond_options_ns_ip6_target_set(struct bonding *bond, int slot,\n\t\t\t\t\t    struct in6_addr *target,\n\t\t\t\t\t    unsigned long last_rx)\n{\n\tstruct in6_addr *targets = bond->params.ns_targets;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (slot >= 0 && slot < BOND_MAX_NS_TARGETS) {\n\t\tbond_for_each_slave(bond, slave, iter)\n\t\t\tslave->target_last_arp_rx[slot] = last_rx;\n\t\ttargets[slot] = *target;\n\t}\n}\n\nvoid bond_option_ns_ip6_targets_clear(struct bonding *bond)\n{\n\tstruct in6_addr addr_any = in6addr_any;\n\tint i;\n\n\tfor (i = 0; i < BOND_MAX_NS_TARGETS; i++)\n\t\t_bond_options_ns_ip6_target_set(bond, i, &addr_any, 0);\n}\n\nstatic int bond_option_ns_ip6_targets_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval)\n{\n\tstruct in6_addr *target = (struct in6_addr *)newval->extra;\n\tstruct in6_addr *targets = bond->params.ns_targets;\n\tstruct in6_addr addr_any = in6addr_any;\n\tint index;\n\n\tif (!bond_is_ip6_target_ok(target)) {\n\t\tnetdev_err(bond->dev, \"invalid NS target %pI6c specified for addition\\n\",\n\t\t\t   target);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bond_get_targets_ip6(targets, target) != -1) {  \n\t\tnetdev_err(bond->dev, \"NS target %pI6c is already present\\n\",\n\t\t\t   target);\n\t\treturn -EINVAL;\n\t}\n\n\tindex = bond_get_targets_ip6(targets, &addr_any);  \n\tif (index == -1) {\n\t\tnetdev_err(bond->dev, \"NS target table is full!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev_dbg(bond->dev, \"Adding NS target %pI6c\\n\", target);\n\n\t_bond_options_ns_ip6_target_set(bond, index, target, jiffies);\n\n\treturn 0;\n}\n#else\nstatic int bond_option_ns_ip6_targets_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval)\n{\n\treturn -EPERM;\n}\n#endif\n\nstatic int bond_option_arp_validate_set(struct bonding *bond,\n\t\t\t\t\tconst struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting arp_validate to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.arp_validate = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_arp_all_targets_set(struct bonding *bond,\n\t\t\t\t\t   const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting arp_all_targets to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.arp_all_targets = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_missed_max_set(struct bonding *bond,\n\t\t\t\t      const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting missed max to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.missed_max = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_prio_set(struct bonding *bond,\n\t\t\t\tconst struct bond_opt_value *newval)\n{\n\tstruct slave *slave;\n\n\tslave = bond_slave_get_rtnl(newval->slave_dev);\n\tif (!slave) {\n\t\tnetdev_dbg(newval->slave_dev, \"%s called on NULL slave\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tslave->prio = newval->value;\n\n\tif (rtnl_dereference(bond->primary_slave))\n\t\tslave_warn(bond->dev, slave->dev,\n\t\t\t   \"prio updated, but will not affect failover re-selection as primary slave have been set\\n\");\n\telse\n\t\tbond_select_active_slave(bond);\n\n\treturn 0;\n}\n\nstatic int bond_option_primary_set(struct bonding *bond,\n\t\t\t\t   const struct bond_opt_value *newval)\n{\n\tchar *p, *primary = newval->string;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tblock_netpoll_tx();\n\n\tp = strchr(primary, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\t \n\tif (!strlen(primary)) {\n\t\tnetdev_dbg(bond->dev, \"Setting primary slave to None\\n\");\n\t\tRCU_INIT_POINTER(bond->primary_slave, NULL);\n\t\tmemset(bond->params.primary, 0, sizeof(bond->params.primary));\n\t\tbond_select_active_slave(bond);\n\t\tgoto out;\n\t}\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {\n\t\t\tslave_dbg(bond->dev, slave->dev, \"Setting as primary slave\\n\");\n\t\t\trcu_assign_pointer(bond->primary_slave, slave);\n\t\t\tstrcpy(bond->params.primary, slave->dev->name);\n\t\t\tbond->force_primary = true;\n\t\t\tbond_select_active_slave(bond);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rtnl_dereference(bond->primary_slave)) {\n\t\tnetdev_dbg(bond->dev, \"Setting primary slave to None\\n\");\n\t\tRCU_INIT_POINTER(bond->primary_slave, NULL);\n\t\tbond_select_active_slave(bond);\n\t}\n\tstrscpy_pad(bond->params.primary, primary, IFNAMSIZ);\n\n\tnetdev_dbg(bond->dev, \"Recording %s as primary, but it has not been enslaved yet\\n\",\n\t\t   primary);\n\nout:\n\tunblock_netpoll_tx();\n\n\treturn 0;\n}\n\nstatic int bond_option_primary_reselect_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting primary_reselect to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.primary_reselect = newval->value;\n\n\tblock_netpoll_tx();\n\tbond_select_active_slave(bond);\n\tunblock_netpoll_tx();\n\n\treturn 0;\n}\n\nstatic int bond_option_fail_over_mac_set(struct bonding *bond,\n\t\t\t\t\t const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting fail_over_mac to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.fail_over_mac = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_xmit_hash_policy_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting xmit hash policy to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.xmit_policy = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_resend_igmp_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting resend_igmp to %llu\\n\",\n\t\t   newval->value);\n\tbond->params.resend_igmp = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_num_peer_notif_set(struct bonding *bond,\n\t\t\t\t   const struct bond_opt_value *newval)\n{\n\tbond->params.num_peer_notif = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_all_slaves_active_set(struct bonding *bond,\n\t\t\t\t\t     const struct bond_opt_value *newval)\n{\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (newval->value == bond->params.all_slaves_active)\n\t\treturn 0;\n\tbond->params.all_slaves_active = newval->value;\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (!bond_is_active_slave(slave)) {\n\t\t\tif (newval->value)\n\t\t\t\tslave->inactive = 0;\n\t\t\telse\n\t\t\t\tslave->inactive = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_option_min_links_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting min links value to %llu\\n\",\n\t\t   newval->value);\n\tbond->params.min_links = newval->value;\n\tbond_set_carrier(bond);\n\n\treturn 0;\n}\n\nstatic int bond_option_lp_interval_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval)\n{\n\tbond->params.lp_interval = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_pps_set(struct bonding *bond,\n\t\t\t       const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting packets per slave to %llu\\n\",\n\t\t   newval->value);\n\tbond->params.packets_per_slave = newval->value;\n\tif (newval->value > 0) {\n\t\tbond->params.reciprocal_packets_per_slave =\n\t\t\treciprocal_value(newval->value);\n\t} else {\n\t\t \n\t\tbond->params.reciprocal_packets_per_slave =\n\t\t\t(struct reciprocal_value) { 0 };\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_option_lacp_active_set(struct bonding *bond,\n\t\t\t\t       const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting LACP active to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.lacp_active = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_lacp_rate_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting LACP rate to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.lacp_fast = newval->value;\n\tbond_3ad_update_lacp_rate(bond);\n\n\treturn 0;\n}\n\nstatic int bond_option_ad_select_set(struct bonding *bond,\n\t\t\t\t     const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting ad_select to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.ad_select = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_queue_id_set(struct bonding *bond,\n\t\t\t\t    const struct bond_opt_value *newval)\n{\n\tstruct slave *slave, *update_slave;\n\tstruct net_device *sdev;\n\tstruct list_head *iter;\n\tchar *delim;\n\tint ret = 0;\n\tu16 qid;\n\n\t \n\tdelim = strchr(newval->string, ':');\n\tif (!delim)\n\t\tgoto err_no_cmd;\n\n\t \n\t*delim = '\\0';\n\tif (sscanf(++delim, \"%hd\\n\", &qid) != 1)\n\t\tgoto err_no_cmd;\n\n\t \n\tif (!dev_valid_name(newval->string) ||\n\t    qid > bond->dev->real_num_tx_queues)\n\t\tgoto err_no_cmd;\n\n\t \n\tsdev = __dev_get_by_name(dev_net(bond->dev), newval->string);\n\tif (!sdev)\n\t\tgoto err_no_cmd;\n\n\t \n\tupdate_slave = NULL;\n\tbond_for_each_slave(bond, slave, iter) {\n\t\tif (sdev == slave->dev)\n\t\t\t \n\t\t\tupdate_slave = slave;\n\t\telse if (qid && qid == slave->queue_id) {\n\t\t\tgoto err_no_cmd;\n\t\t}\n\t}\n\n\tif (!update_slave)\n\t\tgoto err_no_cmd;\n\n\t \n\tupdate_slave->queue_id = qid;\n\nout:\n\treturn ret;\n\nerr_no_cmd:\n\tnetdev_dbg(bond->dev, \"invalid input for queue_id set\\n\");\n\tret = -EPERM;\n\tgoto out;\n\n}\n\nstatic int bond_option_slaves_set(struct bonding *bond,\n\t\t\t\t  const struct bond_opt_value *newval)\n{\n\tchar command[IFNAMSIZ + 1] = { 0, };\n\tstruct net_device *dev;\n\tchar *ifname;\n\tint ret;\n\n\tsscanf(newval->string, \"%16s\", command);  \n\tifname = command + 1;\n\tif ((strlen(command) <= 1) ||\n\t    (command[0] != '+' && command[0] != '-') ||\n\t    !dev_valid_name(ifname))\n\t\tgoto err_no_cmd;\n\n\tdev = __dev_get_by_name(dev_net(bond->dev), ifname);\n\tif (!dev) {\n\t\tnetdev_dbg(bond->dev, \"interface %s does not exist!\\n\",\n\t\t\t   ifname);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (command[0]) {\n\tcase '+':\n\t\tslave_dbg(bond->dev, dev, \"Enslaving interface\\n\");\n\t\tret = bond_enslave(bond->dev, dev, NULL);\n\t\tbreak;\n\n\tcase '-':\n\t\tslave_dbg(bond->dev, dev, \"Releasing interface\\n\");\n\t\tret = bond_release(bond->dev, dev);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tgoto err_no_cmd;\n\t}\n\nout:\n\treturn ret;\n\nerr_no_cmd:\n\tnetdev_err(bond->dev, \"no command found in slaves file - use +ifname or -ifname\\n\");\n\tret = -EPERM;\n\tgoto out;\n}\n\nstatic int bond_option_tlb_dynamic_lb_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting dynamic-lb to %s (%llu)\\n\",\n\t\t   newval->string, newval->value);\n\tbond->params.tlb_dynamic_lb = newval->value;\n\n\treturn 0;\n}\n\nstatic int bond_option_ad_actor_sys_prio_set(struct bonding *bond,\n\t\t\t\t\t     const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting ad_actor_sys_prio to %llu\\n\",\n\t\t   newval->value);\n\n\tbond->params.ad_actor_sys_prio = newval->value;\n\tbond_3ad_update_ad_actor_settings(bond);\n\n\treturn 0;\n}\n\nstatic int bond_option_ad_actor_system_set(struct bonding *bond,\n\t\t\t\t\t   const struct bond_opt_value *newval)\n{\n\tu8 macaddr[ETH_ALEN];\n\tu8 *mac;\n\n\tif (newval->string) {\n\t\tif (!mac_pton(newval->string, macaddr))\n\t\t\tgoto err;\n\t\tmac = macaddr;\n\t} else {\n\t\tmac = (u8 *)&newval->value;\n\t}\n\n\tif (is_multicast_ether_addr(mac))\n\t\tgoto err;\n\n\tnetdev_dbg(bond->dev, \"Setting ad_actor_system to %pM\\n\", mac);\n\tether_addr_copy(bond->params.ad_actor_system, mac);\n\tbond_3ad_update_ad_actor_settings(bond);\n\n\treturn 0;\n\nerr:\n\tnetdev_err(bond->dev, \"Invalid ad_actor_system MAC address.\\n\");\n\treturn -EINVAL;\n}\n\nstatic int bond_option_ad_user_port_key_set(struct bonding *bond,\n\t\t\t\t\t    const struct bond_opt_value *newval)\n{\n\tnetdev_dbg(bond->dev, \"Setting ad_user_port_key to %llu\\n\",\n\t\t   newval->value);\n\n\tbond->params.ad_user_port_key = newval->value;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}