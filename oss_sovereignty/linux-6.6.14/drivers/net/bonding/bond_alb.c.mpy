{
  "module_name": "bond_alb.c",
  "hash_id": "373d53b217e4d417ac5431ea8e18c8cb04af0ff1ef568c262e44abc125850441",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_alb.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/pkt_sched.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_bonding.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <net/arp.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <asm/byteorder.h>\n#include <net/bonding.h>\n#include <net/bond_alb.h>\n\nstatic const u8 mac_v6_allmcast[ETH_ALEN + 2] __long_aligned = {\n\t0x33, 0x33, 0x00, 0x00, 0x00, 0x01\n};\nstatic const int alb_delta_in_ticks = HZ / ALB_TIMER_TICKS_PER_SEC;\n\n#pragma pack(1)\nstruct learning_pkt {\n\tu8 mac_dst[ETH_ALEN];\n\tu8 mac_src[ETH_ALEN];\n\t__be16 type;\n\tu8 padding[ETH_ZLEN - ETH_HLEN];\n};\n\nstruct arp_pkt {\n\t__be16  hw_addr_space;\n\t__be16  prot_addr_space;\n\tu8      hw_addr_len;\n\tu8      prot_addr_len;\n\t__be16  op_code;\n\tu8      mac_src[ETH_ALEN];\t \n\t__be32  ip_src;\t\t\t \n\tu8      mac_dst[ETH_ALEN];\t \n\t__be32  ip_dst;\t\t\t \n};\n#pragma pack()\n\n \nstatic void alb_send_learning_packets(struct slave *slave, const u8 mac_addr[],\n\t\t\t\t      bool strict_match);\nstatic void rlb_purge_src_ip(struct bonding *bond, struct arp_pkt *arp);\nstatic void rlb_src_unlink(struct bonding *bond, u32 index);\nstatic void rlb_src_link(struct bonding *bond, u32 ip_src_hash,\n\t\t\t u32 ip_dst_hash);\n\nstatic inline u8 _simple_hash(const u8 *hash_start, int hash_size)\n{\n\tint i;\n\tu8 hash = 0;\n\n\tfor (i = 0; i < hash_size; i++)\n\t\thash ^= hash_start[i];\n\n\treturn hash;\n}\n\n \n\nstatic inline void tlb_init_table_entry(struct tlb_client_info *entry, int save_load)\n{\n\tif (save_load) {\n\t\tentry->load_history = 1 + entry->tx_bytes /\n\t\t\t\t      BOND_TLB_REBALANCE_INTERVAL;\n\t\tentry->tx_bytes = 0;\n\t}\n\n\tentry->tx_slave = NULL;\n\tentry->next = TLB_NULL_INDEX;\n\tentry->prev = TLB_NULL_INDEX;\n}\n\nstatic inline void tlb_init_slave(struct slave *slave)\n{\n\tSLAVE_TLB_INFO(slave).load = 0;\n\tSLAVE_TLB_INFO(slave).head = TLB_NULL_INDEX;\n}\n\nstatic void __tlb_clear_slave(struct bonding *bond, struct slave *slave,\n\t\t\t int save_load)\n{\n\tstruct tlb_client_info *tx_hash_table;\n\tu32 index;\n\n\t \n\ttx_hash_table = BOND_ALB_INFO(bond).tx_hashtbl;\n\n\t \n\tif (tx_hash_table) {\n\t\tindex = SLAVE_TLB_INFO(slave).head;\n\t\twhile (index != TLB_NULL_INDEX) {\n\t\t\tu32 next_index = tx_hash_table[index].next;\n\n\t\t\ttlb_init_table_entry(&tx_hash_table[index], save_load);\n\t\t\tindex = next_index;\n\t\t}\n\t}\n\n\ttlb_init_slave(slave);\n}\n\nstatic void tlb_clear_slave(struct bonding *bond, struct slave *slave,\n\t\t\t int save_load)\n{\n\tspin_lock_bh(&bond->mode_lock);\n\t__tlb_clear_slave(bond, slave, save_load);\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \nstatic int tlb_initialize(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tint size = TLB_HASH_TABLE_SIZE * sizeof(struct tlb_client_info);\n\tstruct tlb_client_info *new_hashtbl;\n\tint i;\n\n\tnew_hashtbl = kzalloc(size, GFP_KERNEL);\n\tif (!new_hashtbl)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tbond_info->tx_hashtbl = new_hashtbl;\n\n\tfor (i = 0; i < TLB_HASH_TABLE_SIZE; i++)\n\t\ttlb_init_table_entry(&bond_info->tx_hashtbl[i], 0);\n\n\tspin_unlock_bh(&bond->mode_lock);\n\n\treturn 0;\n}\n\n \nstatic void tlb_deinitialize(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tkfree(bond_info->tx_hashtbl);\n\tbond_info->tx_hashtbl = NULL;\n\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\nstatic long long compute_gap(struct slave *slave)\n{\n\treturn (s64) (slave->speed << 20) -  \n\t       (s64) (SLAVE_TLB_INFO(slave).load << 3);  \n}\n\nstatic struct slave *tlb_get_least_loaded_slave(struct bonding *bond)\n{\n\tstruct slave *slave, *least_loaded;\n\tstruct list_head *iter;\n\tlong long max_gap;\n\n\tleast_loaded = NULL;\n\tmax_gap = LLONG_MIN;\n\n\t \n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (bond_slave_can_tx(slave)) {\n\t\t\tlong long gap = compute_gap(slave);\n\n\t\t\tif (max_gap < gap) {\n\t\t\t\tleast_loaded = slave;\n\t\t\t\tmax_gap = gap;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn least_loaded;\n}\n\nstatic struct slave *__tlb_choose_channel(struct bonding *bond, u32 hash_index,\n\t\t\t\t\t\tu32 skb_len)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct tlb_client_info *hash_table;\n\tstruct slave *assigned_slave;\n\n\thash_table = bond_info->tx_hashtbl;\n\tassigned_slave = hash_table[hash_index].tx_slave;\n\tif (!assigned_slave) {\n\t\tassigned_slave = tlb_get_least_loaded_slave(bond);\n\n\t\tif (assigned_slave) {\n\t\t\tstruct tlb_slave_info *slave_info =\n\t\t\t\t&(SLAVE_TLB_INFO(assigned_slave));\n\t\t\tu32 next_index = slave_info->head;\n\n\t\t\thash_table[hash_index].tx_slave = assigned_slave;\n\t\t\thash_table[hash_index].next = next_index;\n\t\t\thash_table[hash_index].prev = TLB_NULL_INDEX;\n\n\t\t\tif (next_index != TLB_NULL_INDEX)\n\t\t\t\thash_table[next_index].prev = hash_index;\n\n\t\t\tslave_info->head = hash_index;\n\t\t\tslave_info->load +=\n\t\t\t\thash_table[hash_index].load_history;\n\t\t}\n\t}\n\n\tif (assigned_slave)\n\t\thash_table[hash_index].tx_bytes += skb_len;\n\n\treturn assigned_slave;\n}\n\nstatic struct slave *tlb_choose_channel(struct bonding *bond, u32 hash_index,\n\t\t\t\t\tu32 skb_len)\n{\n\tstruct slave *tx_slave;\n\n\t \n\tspin_lock(&bond->mode_lock);\n\ttx_slave = __tlb_choose_channel(bond, hash_index, skb_len);\n\tspin_unlock(&bond->mode_lock);\n\n\treturn tx_slave;\n}\n\n \n\n \nstatic void rlb_update_entry_from_arp(struct bonding *bond, struct arp_pkt *arp)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info *client_info;\n\tu32 hash_index;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\thash_index = _simple_hash((u8 *)&(arp->ip_src), sizeof(arp->ip_src));\n\tclient_info = &(bond_info->rx_hashtbl[hash_index]);\n\n\tif ((client_info->assigned) &&\n\t    (client_info->ip_src == arp->ip_dst) &&\n\t    (client_info->ip_dst == arp->ip_src) &&\n\t    (!ether_addr_equal_64bits(client_info->mac_dst, arp->mac_src))) {\n\t\t \n\t\tether_addr_copy(client_info->mac_dst, arp->mac_src);\n\t\tclient_info->ntt = 1;\n\t\tbond_info->rx_ntt = 1;\n\t}\n\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\nstatic int rlb_arp_recv(const struct sk_buff *skb, struct bonding *bond,\n\t\t\tstruct slave *slave)\n{\n\tstruct arp_pkt *arp, _arp;\n\n\tif (skb->protocol != cpu_to_be16(ETH_P_ARP))\n\t\tgoto out;\n\n\tarp = skb_header_pointer(skb, 0, sizeof(_arp), &_arp);\n\tif (!arp)\n\t\tgoto out;\n\n\t \n\trlb_purge_src_ip(bond, arp);\n\n\tif (arp->op_code == htons(ARPOP_REPLY)) {\n\t\t \n\t\trlb_update_entry_from_arp(bond, arp);\n\t\tslave_dbg(bond->dev, slave->dev, \"Server received an ARP Reply from client\\n\");\n\t}\nout:\n\treturn RX_HANDLER_ANOTHER;\n}\n\n \nstatic struct slave *__rlb_next_rx_slave(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct slave *before = NULL, *rx_slave = NULL, *slave;\n\tstruct list_head *iter;\n\tbool found = false;\n\n\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\tif (!bond_slave_can_tx(slave))\n\t\t\tcontinue;\n\t\tif (!found) {\n\t\t\tif (!before || before->speed < slave->speed)\n\t\t\t\tbefore = slave;\n\t\t} else {\n\t\t\tif (!rx_slave || rx_slave->speed < slave->speed)\n\t\t\t\trx_slave = slave;\n\t\t}\n\t\tif (slave == bond_info->rx_slave)\n\t\t\tfound = true;\n\t}\n\t \n\tif (!rx_slave || (before && rx_slave->speed < before->speed))\n\t\trx_slave = before;\n\n\tif (rx_slave)\n\t\tbond_info->rx_slave = rx_slave;\n\n\treturn rx_slave;\n}\n\n \nstatic struct slave *rlb_next_rx_slave(struct bonding *bond)\n{\n\tstruct slave *rx_slave;\n\n\tASSERT_RTNL();\n\n\trcu_read_lock();\n\trx_slave = __rlb_next_rx_slave(bond);\n\trcu_read_unlock();\n\n\treturn rx_slave;\n}\n\n \nstatic void rlb_teach_disabled_mac_on_primary(struct bonding *bond,\n\t\t\t\t\t      const u8 addr[])\n{\n\tstruct slave *curr_active = rtnl_dereference(bond->curr_active_slave);\n\n\tif (!curr_active)\n\t\treturn;\n\n\tif (!bond->alb_info.primary_is_promisc) {\n\t\tif (!dev_set_promiscuity(curr_active->dev, 1))\n\t\t\tbond->alb_info.primary_is_promisc = 1;\n\t\telse\n\t\t\tbond->alb_info.primary_is_promisc = 0;\n\t}\n\n\tbond->alb_info.rlb_promisc_timeout_counter = 0;\n\n\talb_send_learning_packets(curr_active, addr, true);\n}\n\n \nstatic void rlb_clear_slave(struct bonding *bond, struct slave *slave)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info *rx_hash_table;\n\tu32 index, next_index;\n\n\t \n\tspin_lock_bh(&bond->mode_lock);\n\n\trx_hash_table = bond_info->rx_hashtbl;\n\tindex = bond_info->rx_hashtbl_used_head;\n\tfor (; index != RLB_NULL_INDEX; index = next_index) {\n\t\tnext_index = rx_hash_table[index].used_next;\n\t\tif (rx_hash_table[index].slave == slave) {\n\t\t\tstruct slave *assigned_slave = rlb_next_rx_slave(bond);\n\n\t\t\tif (assigned_slave) {\n\t\t\t\trx_hash_table[index].slave = assigned_slave;\n\t\t\t\tif (is_valid_ether_addr(rx_hash_table[index].mac_dst)) {\n\t\t\t\t\tbond_info->rx_hashtbl[index].ntt = 1;\n\t\t\t\t\tbond_info->rx_ntt = 1;\n\t\t\t\t\t \n\t\t\t\t\tbond_info->rlb_update_retry_counter =\n\t\t\t\t\t\tRLB_UPDATE_RETRY;\n\t\t\t\t}\n\t\t\t} else {   \n\t\t\t\trx_hash_table[index].slave = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&bond->mode_lock);\n\n\tif (slave != rtnl_dereference(bond->curr_active_slave))\n\t\trlb_teach_disabled_mac_on_primary(bond, slave->dev->dev_addr);\n}\n\nstatic void rlb_update_client(struct rlb_client_info *client_info)\n{\n\tint i;\n\n\tif (!client_info->slave || !is_valid_ether_addr(client_info->mac_dst))\n\t\treturn;\n\n\tfor (i = 0; i < RLB_ARP_BURST_SIZE; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = arp_create(ARPOP_REPLY, ETH_P_ARP,\n\t\t\t\t client_info->ip_dst,\n\t\t\t\t client_info->slave->dev,\n\t\t\t\t client_info->ip_src,\n\t\t\t\t client_info->mac_dst,\n\t\t\t\t client_info->slave->dev->dev_addr,\n\t\t\t\t client_info->mac_dst);\n\t\tif (!skb) {\n\t\t\tslave_err(client_info->slave->bond->dev,\n\t\t\t\t  client_info->slave->dev,\n\t\t\t\t  \"failed to create an ARP packet\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb->dev = client_info->slave->dev;\n\n\t\tif (client_info->vlan_id) {\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       client_info->vlan_id);\n\t\t}\n\n\t\tarp_xmit(skb);\n\t}\n}\n\n \nstatic void rlb_update_rx_clients(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info *client_info;\n\tu32 hash_index;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\thash_index = bond_info->rx_hashtbl_used_head;\n\tfor (; hash_index != RLB_NULL_INDEX;\n\t     hash_index = client_info->used_next) {\n\t\tclient_info = &(bond_info->rx_hashtbl[hash_index]);\n\t\tif (client_info->ntt) {\n\t\t\trlb_update_client(client_info);\n\t\t\tif (bond_info->rlb_update_retry_counter == 0)\n\t\t\t\tclient_info->ntt = 0;\n\t\t}\n\t}\n\n\t \n\tbond_info->rlb_update_delay_counter = RLB_UPDATE_DELAY;\n\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \nstatic void rlb_req_update_slave_clients(struct bonding *bond, struct slave *slave)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info *client_info;\n\tint ntt = 0;\n\tu32 hash_index;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\thash_index = bond_info->rx_hashtbl_used_head;\n\tfor (; hash_index != RLB_NULL_INDEX;\n\t     hash_index = client_info->used_next) {\n\t\tclient_info = &(bond_info->rx_hashtbl[hash_index]);\n\n\t\tif ((client_info->slave == slave) &&\n\t\t    is_valid_ether_addr(client_info->mac_dst)) {\n\t\t\tclient_info->ntt = 1;\n\t\t\tntt = 1;\n\t\t}\n\t}\n\n\t \n\tif (ntt) {\n\t\tbond_info->rx_ntt = 1;\n\t\t \n\t\tbond_info->rlb_update_retry_counter = RLB_UPDATE_RETRY;\n\t}\n\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \nstatic void rlb_req_update_subnet_clients(struct bonding *bond, __be32 src_ip)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info *client_info;\n\tu32 hash_index;\n\n\tspin_lock(&bond->mode_lock);\n\n\thash_index = bond_info->rx_hashtbl_used_head;\n\tfor (; hash_index != RLB_NULL_INDEX;\n\t     hash_index = client_info->used_next) {\n\t\tclient_info = &(bond_info->rx_hashtbl[hash_index]);\n\n\t\tif (!client_info->slave) {\n\t\t\tnetdev_err(bond->dev, \"found a client with no channel in the client's hash table\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif ((client_info->ip_src == src_ip) &&\n\t\t    !ether_addr_equal_64bits(client_info->slave->dev->dev_addr,\n\t\t\t\t\t     bond->dev->dev_addr) &&\n\t\t    is_valid_ether_addr(client_info->mac_dst)) {\n\t\t\tclient_info->ntt = 1;\n\t\t\tbond_info->rx_ntt = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&bond->mode_lock);\n}\n\nstatic struct slave *rlb_choose_channel(struct sk_buff *skb,\n\t\t\t\t\tstruct bonding *bond,\n\t\t\t\t\tconst struct arp_pkt *arp)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct slave *assigned_slave, *curr_active_slave;\n\tstruct rlb_client_info *client_info;\n\tu32 hash_index = 0;\n\n\tspin_lock(&bond->mode_lock);\n\n\tcurr_active_slave = rcu_dereference(bond->curr_active_slave);\n\n\thash_index = _simple_hash((u8 *)&arp->ip_dst, sizeof(arp->ip_dst));\n\tclient_info = &(bond_info->rx_hashtbl[hash_index]);\n\n\tif (client_info->assigned) {\n\t\tif ((client_info->ip_src == arp->ip_src) &&\n\t\t    (client_info->ip_dst == arp->ip_dst)) {\n\t\t\t \n\t\t\tif (!is_broadcast_ether_addr(arp->mac_dst)) {\n\t\t\t\t \n\t\t\t\tether_addr_copy(client_info->mac_dst, arp->mac_dst);\n\t\t\t}\n\t\t\tether_addr_copy(client_info->mac_src, arp->mac_src);\n\n\t\t\tassigned_slave = client_info->slave;\n\t\t\tif (assigned_slave) {\n\t\t\t\tspin_unlock(&bond->mode_lock);\n\t\t\t\treturn assigned_slave;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (curr_active_slave &&\n\t\t\t    client_info->slave != curr_active_slave) {\n\t\t\t\tclient_info->slave = curr_active_slave;\n\t\t\t\trlb_update_client(client_info);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tassigned_slave = __rlb_next_rx_slave(bond);\n\n\tif (assigned_slave) {\n\t\tif (!(client_info->assigned &&\n\t\t      client_info->ip_src == arp->ip_src)) {\n\t\t\t \n\t\t\tu32 hash_src = _simple_hash((u8 *)&arp->ip_src,\n\t\t\t\t\t\t    sizeof(arp->ip_src));\n\t\t\trlb_src_unlink(bond, hash_index);\n\t\t\trlb_src_link(bond, hash_src, hash_index);\n\t\t}\n\n\t\tclient_info->ip_src = arp->ip_src;\n\t\tclient_info->ip_dst = arp->ip_dst;\n\t\t \n\t\tether_addr_copy(client_info->mac_dst, arp->mac_dst);\n\t\tether_addr_copy(client_info->mac_src, arp->mac_src);\n\t\tclient_info->slave = assigned_slave;\n\n\t\tif (is_valid_ether_addr(client_info->mac_dst)) {\n\t\t\tclient_info->ntt = 1;\n\t\t\tbond->alb_info.rx_ntt = 1;\n\t\t} else {\n\t\t\tclient_info->ntt = 0;\n\t\t}\n\n\t\tif (vlan_get_tag(skb, &client_info->vlan_id))\n\t\t\tclient_info->vlan_id = 0;\n\n\t\tif (!client_info->assigned) {\n\t\t\tu32 prev_tbl_head = bond_info->rx_hashtbl_used_head;\n\n\t\t\tbond_info->rx_hashtbl_used_head = hash_index;\n\t\t\tclient_info->used_next = prev_tbl_head;\n\t\t\tif (prev_tbl_head != RLB_NULL_INDEX) {\n\t\t\t\tbond_info->rx_hashtbl[prev_tbl_head].used_prev =\n\t\t\t\t\thash_index;\n\t\t\t}\n\t\t\tclient_info->assigned = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&bond->mode_lock);\n\n\treturn assigned_slave;\n}\n\n \nstatic struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)\n{\n\tstruct slave *tx_slave = NULL;\n\tstruct net_device *dev;\n\tstruct arp_pkt *arp;\n\n\tif (!pskb_network_may_pull(skb, sizeof(*arp)))\n\t\treturn NULL;\n\tarp = (struct arp_pkt *)skb_network_header(skb);\n\n\t \n\tif (!bond_slave_has_mac_rcu(bond, arp->mac_src))\n\t\treturn NULL;\n\n\tdev = ip_dev_find(dev_net(bond->dev), arp->ip_src);\n\tif (dev) {\n\t\tif (netif_is_any_bridge_master(dev)) {\n\t\t\tdev_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_put(dev);\n\t}\n\n\tif (arp->op_code == htons(ARPOP_REPLY)) {\n\t\t \n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\t\tif (tx_slave)\n\t\t\tbond_hw_addr_copy(arp->mac_src, tx_slave->dev->dev_addr,\n\t\t\t\t\t  tx_slave->dev->addr_len);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Reply packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t} else if (arp->op_code == htons(ARPOP_REQUEST)) {\n\t\t \n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\n\t\t \n\t\tbond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;\n\n\t\t \n\t\trlb_req_update_subnet_clients(bond, arp->ip_src);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Request packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t}\n\n\treturn tx_slave;\n}\n\nstatic void rlb_rebalance(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct slave *assigned_slave;\n\tstruct rlb_client_info *client_info;\n\tint ntt;\n\tu32 hash_index;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tntt = 0;\n\thash_index = bond_info->rx_hashtbl_used_head;\n\tfor (; hash_index != RLB_NULL_INDEX;\n\t     hash_index = client_info->used_next) {\n\t\tclient_info = &(bond_info->rx_hashtbl[hash_index]);\n\t\tassigned_slave = __rlb_next_rx_slave(bond);\n\t\tif (assigned_slave && (client_info->slave != assigned_slave)) {\n\t\t\tclient_info->slave = assigned_slave;\n\t\t\tif (!is_zero_ether_addr(client_info->mac_dst)) {\n\t\t\t\tclient_info->ntt = 1;\n\t\t\t\tntt = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ntt)\n\t\tbond_info->rx_ntt = 1;\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \nstatic void rlb_init_table_entry_dst(struct rlb_client_info *entry)\n{\n\tentry->used_next = RLB_NULL_INDEX;\n\tentry->used_prev = RLB_NULL_INDEX;\n\tentry->assigned = 0;\n\tentry->slave = NULL;\n\tentry->vlan_id = 0;\n}\nstatic void rlb_init_table_entry_src(struct rlb_client_info *entry)\n{\n\tentry->src_first = RLB_NULL_INDEX;\n\tentry->src_prev = RLB_NULL_INDEX;\n\tentry->src_next = RLB_NULL_INDEX;\n}\n\nstatic void rlb_init_table_entry(struct rlb_client_info *entry)\n{\n\tmemset(entry, 0, sizeof(struct rlb_client_info));\n\trlb_init_table_entry_dst(entry);\n\trlb_init_table_entry_src(entry);\n}\n\nstatic void rlb_delete_table_entry_dst(struct bonding *bond, u32 index)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tu32 next_index = bond_info->rx_hashtbl[index].used_next;\n\tu32 prev_index = bond_info->rx_hashtbl[index].used_prev;\n\n\tif (index == bond_info->rx_hashtbl_used_head)\n\t\tbond_info->rx_hashtbl_used_head = next_index;\n\tif (prev_index != RLB_NULL_INDEX)\n\t\tbond_info->rx_hashtbl[prev_index].used_next = next_index;\n\tif (next_index != RLB_NULL_INDEX)\n\t\tbond_info->rx_hashtbl[next_index].used_prev = prev_index;\n}\n\n \nstatic void rlb_src_unlink(struct bonding *bond, u32 index)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tu32 next_index = bond_info->rx_hashtbl[index].src_next;\n\tu32 prev_index = bond_info->rx_hashtbl[index].src_prev;\n\n\tbond_info->rx_hashtbl[index].src_next = RLB_NULL_INDEX;\n\tbond_info->rx_hashtbl[index].src_prev = RLB_NULL_INDEX;\n\n\tif (next_index != RLB_NULL_INDEX)\n\t\tbond_info->rx_hashtbl[next_index].src_prev = prev_index;\n\n\tif (prev_index == RLB_NULL_INDEX)\n\t\treturn;\n\n\t \n\tif (bond_info->rx_hashtbl[prev_index].src_first == index)\n\t\tbond_info->rx_hashtbl[prev_index].src_first = next_index;\n\telse\n\t\tbond_info->rx_hashtbl[prev_index].src_next = next_index;\n\n}\n\nstatic void rlb_delete_table_entry(struct bonding *bond, u32 index)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info *entry = &(bond_info->rx_hashtbl[index]);\n\n\trlb_delete_table_entry_dst(bond, index);\n\trlb_init_table_entry_dst(entry);\n\n\trlb_src_unlink(bond, index);\n}\n\n \nstatic void rlb_src_link(struct bonding *bond, u32 ip_src_hash, u32 ip_dst_hash)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tu32 next;\n\n\tbond_info->rx_hashtbl[ip_dst_hash].src_prev = ip_src_hash;\n\tnext = bond_info->rx_hashtbl[ip_src_hash].src_first;\n\tbond_info->rx_hashtbl[ip_dst_hash].src_next = next;\n\tif (next != RLB_NULL_INDEX)\n\t\tbond_info->rx_hashtbl[next].src_prev = ip_dst_hash;\n\tbond_info->rx_hashtbl[ip_src_hash].src_first = ip_dst_hash;\n}\n\n \nstatic void rlb_purge_src_ip(struct bonding *bond, struct arp_pkt *arp)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tu32 ip_src_hash = _simple_hash((u8 *)&(arp->ip_src), sizeof(arp->ip_src));\n\tu32 index;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tindex = bond_info->rx_hashtbl[ip_src_hash].src_first;\n\twhile (index != RLB_NULL_INDEX) {\n\t\tstruct rlb_client_info *entry = &(bond_info->rx_hashtbl[index]);\n\t\tu32 next_index = entry->src_next;\n\n\t\tif (entry->ip_src == arp->ip_src &&\n\t\t    !ether_addr_equal_64bits(arp->mac_src, entry->mac_src))\n\t\t\trlb_delete_table_entry(bond, index);\n\t\tindex = next_index;\n\t}\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\nstatic int rlb_initialize(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct rlb_client_info\t*new_hashtbl;\n\tint size = RLB_HASH_TABLE_SIZE * sizeof(struct rlb_client_info);\n\tint i;\n\n\tnew_hashtbl = kmalloc(size, GFP_KERNEL);\n\tif (!new_hashtbl)\n\t\treturn -1;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tbond_info->rx_hashtbl = new_hashtbl;\n\n\tbond_info->rx_hashtbl_used_head = RLB_NULL_INDEX;\n\n\tfor (i = 0; i < RLB_HASH_TABLE_SIZE; i++)\n\t\trlb_init_table_entry(bond_info->rx_hashtbl + i);\n\n\tspin_unlock_bh(&bond->mode_lock);\n\n\t \n\tbond->recv_probe = rlb_arp_recv;\n\n\treturn 0;\n}\n\nstatic void rlb_deinitialize(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tkfree(bond_info->rx_hashtbl);\n\tbond_info->rx_hashtbl = NULL;\n\tbond_info->rx_hashtbl_used_head = RLB_NULL_INDEX;\n\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\nstatic void rlb_clear_vlan(struct bonding *bond, unsigned short vlan_id)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tu32 curr_index;\n\n\tspin_lock_bh(&bond->mode_lock);\n\n\tcurr_index = bond_info->rx_hashtbl_used_head;\n\twhile (curr_index != RLB_NULL_INDEX) {\n\t\tstruct rlb_client_info *curr = &(bond_info->rx_hashtbl[curr_index]);\n\t\tu32 next_index = bond_info->rx_hashtbl[curr_index].used_next;\n\n\t\tif (curr->vlan_id == vlan_id)\n\t\t\trlb_delete_table_entry(bond, curr_index);\n\n\t\tcurr_index = next_index;\n\t}\n\n\tspin_unlock_bh(&bond->mode_lock);\n}\n\n \n\nstatic void alb_send_lp_vid(struct slave *slave, const u8 mac_addr[],\n\t\t\t    __be16 vlan_proto, u16 vid)\n{\n\tstruct learning_pkt pkt;\n\tstruct sk_buff *skb;\n\tint size = sizeof(struct learning_pkt);\n\n\tmemset(&pkt, 0, size);\n\tether_addr_copy(pkt.mac_dst, mac_addr);\n\tether_addr_copy(pkt.mac_src, mac_addr);\n\tpkt.type = cpu_to_be16(ETH_P_LOOPBACK);\n\n\tskb = dev_alloc_skb(size);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, &pkt, size);\n\n\tskb_reset_mac_header(skb);\n\tskb->network_header = skb->mac_header + ETH_HLEN;\n\tskb->protocol = pkt.type;\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->dev = slave->dev;\n\n\tslave_dbg(slave->bond->dev, slave->dev,\n\t\t  \"Send learning packet: mac %pM vlan %d\\n\", mac_addr, vid);\n\n\tif (vid)\n\t\t__vlan_hwaccel_put_tag(skb, vlan_proto, vid);\n\n\tdev_queue_xmit(skb);\n}\n\nstruct alb_walk_data {\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\tconst u8 *mac_addr;\n\tbool strict_match;\n};\n\nstatic int alb_upper_dev_walk(struct net_device *upper,\n\t\t\t      struct netdev_nested_priv *priv)\n{\n\tstruct alb_walk_data *data = (struct alb_walk_data *)priv->data;\n\tbool strict_match = data->strict_match;\n\tconst u8 *mac_addr = data->mac_addr;\n\tstruct bonding *bond = data->bond;\n\tstruct slave *slave = data->slave;\n\tstruct bond_vlan_tag *tags;\n\n\tif (is_vlan_dev(upper) &&\n\t    bond->dev->lower_level == upper->lower_level - 1) {\n\t\tif (upper->addr_assign_type == NET_ADDR_STOLEN) {\n\t\t\talb_send_lp_vid(slave, mac_addr,\n\t\t\t\t\tvlan_dev_vlan_proto(upper),\n\t\t\t\t\tvlan_dev_vlan_id(upper));\n\t\t} else {\n\t\t\talb_send_lp_vid(slave, upper->dev_addr,\n\t\t\t\t\tvlan_dev_vlan_proto(upper),\n\t\t\t\t\tvlan_dev_vlan_id(upper));\n\t\t}\n\t}\n\n\t \n\tif (netif_is_macvlan(upper) && !strict_match) {\n\t\ttags = bond_verify_device_path(bond->dev, upper, 0);\n\t\tif (IS_ERR_OR_NULL(tags))\n\t\t\tBUG();\n\t\talb_send_lp_vid(slave, upper->dev_addr,\n\t\t\t\ttags[0].vlan_proto, tags[0].vlan_id);\n\t\tkfree(tags);\n\t}\n\n\treturn 0;\n}\n\nstatic void alb_send_learning_packets(struct slave *slave, const u8 mac_addr[],\n\t\t\t\t      bool strict_match)\n{\n\tstruct bonding *bond = bond_get_bond_by_slave(slave);\n\tstruct netdev_nested_priv priv;\n\tstruct alb_walk_data data = {\n\t\t.strict_match = strict_match,\n\t\t.mac_addr = mac_addr,\n\t\t.slave = slave,\n\t\t.bond = bond,\n\t};\n\n\tpriv.data = (void *)&data;\n\t \n\talb_send_lp_vid(slave, mac_addr, 0, 0);\n\n\t \n\trcu_read_lock();\n\tnetdev_walk_all_upper_dev_rcu(bond->dev, alb_upper_dev_walk, &priv);\n\trcu_read_unlock();\n}\n\nstatic int alb_set_slave_mac_addr(struct slave *slave, const u8 addr[],\n\t\t\t\t  unsigned int len)\n{\n\tstruct net_device *dev = slave->dev;\n\tstruct sockaddr_storage ss;\n\n\tif (BOND_MODE(slave->bond) == BOND_MODE_TLB) {\n\t\t__dev_addr_set(dev, addr, len);\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(ss.__data, addr, len);\n\tss.ss_family = dev->type;\n\tif (dev_set_mac_address(dev, (struct sockaddr *)&ss, NULL)) {\n\t\tslave_err(slave->bond->dev, dev, \"dev_set_mac_address on slave failed! ALB mode requires that the base driver support setting the hw address also when the network device's interface is open\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic void alb_swap_mac_addr(struct slave *slave1, struct slave *slave2)\n{\n\tu8 tmp_mac_addr[MAX_ADDR_LEN];\n\n\tbond_hw_addr_copy(tmp_mac_addr, slave1->dev->dev_addr,\n\t\t\t  slave1->dev->addr_len);\n\talb_set_slave_mac_addr(slave1, slave2->dev->dev_addr,\n\t\t\t       slave2->dev->addr_len);\n\talb_set_slave_mac_addr(slave2, tmp_mac_addr,\n\t\t\t       slave1->dev->addr_len);\n\n}\n\n \nstatic void alb_fasten_mac_swap(struct bonding *bond, struct slave *slave1,\n\t\t\t\tstruct slave *slave2)\n{\n\tint slaves_state_differ = (bond_slave_can_tx(slave1) != bond_slave_can_tx(slave2));\n\tstruct slave *disabled_slave = NULL;\n\n\tASSERT_RTNL();\n\n\t \n\tif (bond_slave_can_tx(slave1)) {\n\t\talb_send_learning_packets(slave1, slave1->dev->dev_addr, false);\n\t\tif (bond->alb_info.rlb_enabled) {\n\t\t\t \n\t\t\trlb_req_update_slave_clients(bond, slave1);\n\t\t}\n\t} else {\n\t\tdisabled_slave = slave1;\n\t}\n\n\tif (bond_slave_can_tx(slave2)) {\n\t\talb_send_learning_packets(slave2, slave2->dev->dev_addr, false);\n\t\tif (bond->alb_info.rlb_enabled) {\n\t\t\t \n\t\t\trlb_req_update_slave_clients(bond, slave2);\n\t\t}\n\t} else {\n\t\tdisabled_slave = slave2;\n\t}\n\n\tif (bond->alb_info.rlb_enabled && slaves_state_differ) {\n\t\t \n\t\trlb_teach_disabled_mac_on_primary(bond,\n\t\t\t\t\t\t  disabled_slave->dev->dev_addr);\n\t}\n}\n\n \nstatic void alb_change_hw_addr_on_detach(struct bonding *bond, struct slave *slave)\n{\n\tint perm_curr_diff;\n\tint perm_bond_diff;\n\tstruct slave *found_slave;\n\n\tperm_curr_diff = !ether_addr_equal_64bits(slave->perm_hwaddr,\n\t\t\t\t\t\t  slave->dev->dev_addr);\n\tperm_bond_diff = !ether_addr_equal_64bits(slave->perm_hwaddr,\n\t\t\t\t\t\t  bond->dev->dev_addr);\n\n\tif (perm_curr_diff && perm_bond_diff) {\n\t\tfound_slave = bond_slave_has_mac(bond, slave->perm_hwaddr);\n\n\t\tif (found_slave) {\n\t\t\talb_swap_mac_addr(slave, found_slave);\n\t\t\talb_fasten_mac_swap(bond, slave, found_slave);\n\t\t}\n\t}\n}\n\n \nstatic int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)\n{\n\tstruct slave *has_bond_addr = rcu_access_pointer(bond->curr_active_slave);\n\tstruct slave *tmp_slave1, *free_mac_slave = NULL;\n\tstruct list_head *iter;\n\n\tif (!bond_has_slaves(bond)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (!ether_addr_equal_64bits(slave->perm_hwaddr, bond->dev->dev_addr)) {\n\t\tif (!bond_slave_has_mac(bond, slave->dev->dev_addr))\n\t\t\treturn 0;\n\n\t\t \n\t\talb_set_slave_mac_addr(slave, bond->dev->dev_addr,\n\t\t\t\t       bond->dev->addr_len);\n\t}\n\n\t \n\tbond_for_each_slave(bond, tmp_slave1, iter) {\n\t\tif (!bond_slave_has_mac(bond, tmp_slave1->perm_hwaddr)) {\n\t\t\t \n\t\t\tfree_mac_slave = tmp_slave1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!has_bond_addr) {\n\t\t\tif (ether_addr_equal_64bits(tmp_slave1->dev->dev_addr,\n\t\t\t\t\t\t    bond->dev->dev_addr)) {\n\n\t\t\t\thas_bond_addr = tmp_slave1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (free_mac_slave) {\n\t\talb_set_slave_mac_addr(slave, free_mac_slave->perm_hwaddr,\n\t\t\t\t       free_mac_slave->dev->addr_len);\n\n\t\tslave_warn(bond->dev, slave->dev, \"the slave hw address is in use by the bond; giving it the hw address of %s\\n\",\n\t\t\t   free_mac_slave->dev->name);\n\n\t} else if (has_bond_addr) {\n\t\tslave_err(bond->dev, slave->dev, \"the slave hw address is in use by the bond; couldn't find a slave with a free hw address to give it (this should not have happened)\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int alb_set_mac_address(struct bonding *bond, void *addr)\n{\n\tstruct slave *slave, *rollback_slave;\n\tstruct list_head *iter;\n\tstruct sockaddr_storage ss;\n\tchar tmp_addr[MAX_ADDR_LEN];\n\tint res;\n\n\tif (bond->alb_info.rlb_enabled)\n\t\treturn 0;\n\n\tbond_for_each_slave(bond, slave, iter) {\n\t\t \n\t\tbond_hw_addr_copy(tmp_addr, slave->dev->dev_addr,\n\t\t\t\t  slave->dev->addr_len);\n\n\t\tres = dev_set_mac_address(slave->dev, addr, NULL);\n\n\t\t \n\t\tdev_addr_set(slave->dev, tmp_addr);\n\n\t\tif (res)\n\t\t\tgoto unwind;\n\t}\n\n\treturn 0;\n\nunwind:\n\tmemcpy(ss.__data, bond->dev->dev_addr, bond->dev->addr_len);\n\tss.ss_family = bond->dev->type;\n\n\t \n\tbond_for_each_slave(bond, rollback_slave, iter) {\n\t\tif (rollback_slave == slave)\n\t\t\tbreak;\n\t\tbond_hw_addr_copy(tmp_addr, rollback_slave->dev->dev_addr,\n\t\t\t\t  rollback_slave->dev->addr_len);\n\t\tdev_set_mac_address(rollback_slave->dev,\n\t\t\t\t    (struct sockaddr *)&ss, NULL);\n\t\tdev_addr_set(rollback_slave->dev, tmp_addr);\n\t}\n\n\treturn res;\n}\n\n \nstatic bool alb_determine_nd(struct sk_buff *skb, struct bonding *bond)\n{\n\tstruct ipv6hdr *ip6hdr;\n\tstruct icmp6hdr *hdr;\n\n\tif (!pskb_network_may_pull(skb, sizeof(*ip6hdr)))\n\t\treturn true;\n\n\tip6hdr = ipv6_hdr(skb);\n\tif (ip6hdr->nexthdr != IPPROTO_ICMPV6)\n\t\treturn false;\n\n\tif (!pskb_network_may_pull(skb, sizeof(*ip6hdr) + sizeof(*hdr)))\n\t\treturn true;\n\n\thdr = icmp6_hdr(skb);\n\treturn hdr->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT ||\n\t\thdr->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION;\n}\n\n \n\nint bond_alb_initialize(struct bonding *bond, int rlb_enabled)\n{\n\tint res;\n\n\tres = tlb_initialize(bond);\n\tif (res)\n\t\treturn res;\n\n\tif (rlb_enabled) {\n\t\tres = rlb_initialize(bond);\n\t\tif (res) {\n\t\t\ttlb_deinitialize(bond);\n\t\t\treturn res;\n\t\t}\n\t\tbond->alb_info.rlb_enabled = 1;\n\t} else {\n\t\tbond->alb_info.rlb_enabled = 0;\n\t}\n\n\treturn 0;\n}\n\nvoid bond_alb_deinitialize(struct bonding *bond)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\ttlb_deinitialize(bond);\n\n\tif (bond_info->rlb_enabled)\n\t\trlb_deinitialize(bond);\n}\n\nstatic netdev_tx_t bond_do_alb_xmit(struct sk_buff *skb, struct bonding *bond,\n\t\t\t\t    struct slave *tx_slave)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct ethhdr *eth_data = eth_hdr(skb);\n\n\tif (!tx_slave) {\n\t\t \n\t\ttx_slave = rcu_dereference(bond->curr_active_slave);\n\t\tif (bond->params.tlb_dynamic_lb)\n\t\t\tbond_info->unbalanced_load += skb->len;\n\t}\n\n\tif (tx_slave && bond_slave_can_tx(tx_slave)) {\n\t\tif (tx_slave != rcu_access_pointer(bond->curr_active_slave)) {\n\t\t\tether_addr_copy(eth_data->h_source,\n\t\t\t\t\ttx_slave->dev->dev_addr);\n\t\t}\n\n\t\treturn bond_dev_queue_xmit(bond, skb, tx_slave->dev);\n\t}\n\n\tif (tx_slave && bond->params.tlb_dynamic_lb) {\n\t\tspin_lock(&bond->mode_lock);\n\t\t__tlb_clear_slave(bond, tx_slave, 0);\n\t\tspin_unlock(&bond->mode_lock);\n\t}\n\n\t \n\treturn bond_tx_drop(bond->dev, skb);\n}\n\nstruct slave *bond_xmit_tlb_slave_get(struct bonding *bond,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct slave *tx_slave = NULL;\n\tstruct ethhdr *eth_data;\n\tu32 hash_index;\n\n\tskb_reset_mac_header(skb);\n\teth_data = eth_hdr(skb);\n\n\t \n\tif (!is_multicast_ether_addr(eth_data->h_dest)) {\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tif (alb_determine_nd(skb, bond))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase htons(ETH_P_IP):\n\t\t\thash_index = bond_xmit_hash(bond, skb);\n\t\t\tif (bond->params.tlb_dynamic_lb) {\n\t\t\t\ttx_slave = tlb_choose_channel(bond,\n\t\t\t\t\t\t\t      hash_index & 0xFF,\n\t\t\t\t\t\t\t      skb->len);\n\t\t\t} else {\n\t\t\t\tstruct bond_up_slave *slaves;\n\t\t\t\tunsigned int count;\n\n\t\t\t\tslaves = rcu_dereference(bond->usable_slaves);\n\t\t\t\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\t\t\t\tif (likely(count))\n\t\t\t\t\ttx_slave = slaves->arr[hash_index %\n\t\t\t\t\t\t\t       count];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn tx_slave;\n}\n\nnetdev_tx_t bond_tlb_xmit(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *tx_slave;\n\n\ttx_slave = bond_xmit_tlb_slave_get(bond, skb);\n\treturn bond_do_alb_xmit(skb, bond, tx_slave);\n}\n\nstruct slave *bond_xmit_alb_slave_get(struct bonding *bond,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstatic const __be32 ip_bcast = htonl(0xffffffff);\n\tstruct slave *tx_slave = NULL;\n\tconst u8 *hash_start = NULL;\n\tbool do_tx_balance = true;\n\tstruct ethhdr *eth_data;\n\tu32 hash_index = 0;\n\tint hash_size = 0;\n\n\tskb_reset_mac_header(skb);\n\teth_data = eth_hdr(skb);\n\n\tswitch (ntohs(skb->protocol)) {\n\tcase ETH_P_IP: {\n\t\tconst struct iphdr *iph;\n\n\t\tif (is_broadcast_ether_addr(eth_data->h_dest) ||\n\t\t    !pskb_network_may_pull(skb, sizeof(*iph))) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\t\tiph = ip_hdr(skb);\n\t\tif (iph->daddr == ip_bcast || iph->protocol == IPPROTO_IGMP) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\t\thash_start = (char *)&(iph->daddr);\n\t\thash_size = sizeof(iph->daddr);\n\t\tbreak;\n\t}\n\tcase ETH_P_IPV6: {\n\t\tconst struct ipv6hdr *ip6hdr;\n\n\t\t \n\t\tif (is_broadcast_ether_addr(eth_data->h_dest)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ether_addr_equal_64bits(eth_data->h_dest, mac_v6_allmcast)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (alb_determine_nd(skb, bond)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t \n\t\tip6hdr = ipv6_hdr(skb);\n\t\tif (ipv6_addr_any(&ip6hdr->saddr)) {\n\t\t\tdo_tx_balance = false;\n\t\t\tbreak;\n\t\t}\n\n\t\thash_start = (char *)&ip6hdr->daddr;\n\t\thash_size = sizeof(ip6hdr->daddr);\n\t\tbreak;\n\t}\n\tcase ETH_P_ARP:\n\t\tdo_tx_balance = false;\n\t\tif (bond_info->rlb_enabled)\n\t\t\ttx_slave = rlb_arp_xmit(skb, bond);\n\t\tbreak;\n\tdefault:\n\t\tdo_tx_balance = false;\n\t\tbreak;\n\t}\n\n\tif (do_tx_balance) {\n\t\tif (bond->params.tlb_dynamic_lb) {\n\t\t\thash_index = _simple_hash(hash_start, hash_size);\n\t\t\ttx_slave = tlb_choose_channel(bond, hash_index, skb->len);\n\t\t} else {\n\t\t\t \n\n\t\t\tstruct bond_up_slave *slaves;\n\t\t\tunsigned int count;\n\n\t\t\tslaves = rcu_dereference(bond->usable_slaves);\n\t\t\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\t\t\tif (likely(count))\n\t\t\t\ttx_slave = slaves->arr[bond_xmit_hash(bond, skb) %\n\t\t\t\t\t\t       count];\n\t\t}\n\t}\n\treturn tx_slave;\n}\n\nnetdev_tx_t bond_alb_xmit(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *tx_slave = NULL;\n\n\ttx_slave = bond_xmit_alb_slave_get(bond, skb);\n\treturn bond_do_alb_xmit(skb, bond, tx_slave);\n}\n\nvoid bond_alb_monitor(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    alb_work.work);\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tif (!bond_has_slaves(bond)) {\n\t\tatomic_set(&bond_info->tx_rebalance_counter, 0);\n\t\tbond_info->lp_counter = 0;\n\t\tgoto re_arm;\n\t}\n\n\trcu_read_lock();\n\n\tatomic_inc(&bond_info->tx_rebalance_counter);\n\tbond_info->lp_counter++;\n\n\t \n\tif (bond_info->lp_counter >= BOND_ALB_LP_TICKS(bond)) {\n\t\tbool strict_match;\n\n\t\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\t\t \n\t\t\tstrict_match = (slave != rcu_access_pointer(bond->curr_active_slave) ||\n\t\t\t\t\tbond_info->rlb_enabled);\n\t\t\talb_send_learning_packets(slave, slave->dev->dev_addr,\n\t\t\t\t\t\t  strict_match);\n\t\t}\n\t\tbond_info->lp_counter = 0;\n\t}\n\n\t \n\tif (atomic_read(&bond_info->tx_rebalance_counter) >= BOND_TLB_REBALANCE_TICKS) {\n\t\tbond_for_each_slave_rcu(bond, slave, iter) {\n\t\t\ttlb_clear_slave(bond, slave, 1);\n\t\t\tif (slave == rcu_access_pointer(bond->curr_active_slave)) {\n\t\t\t\tSLAVE_TLB_INFO(slave).load =\n\t\t\t\t\tbond_info->unbalanced_load /\n\t\t\t\t\t\tBOND_TLB_REBALANCE_INTERVAL;\n\t\t\t\tbond_info->unbalanced_load = 0;\n\t\t\t}\n\t\t}\n\t\tatomic_set(&bond_info->tx_rebalance_counter, 0);\n\t}\n\n\tif (bond_info->rlb_enabled) {\n\t\tif (bond_info->primary_is_promisc &&\n\t\t    (++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {\n\n\t\t\t \n\t\t\trcu_read_unlock();\n\t\t\tif (!rtnl_trylock())\n\t\t\t\tgoto re_arm;\n\n\t\t\tbond_info->rlb_promisc_timeout_counter = 0;\n\n\t\t\t \n\t\t\tdev_set_promiscuity(rtnl_dereference(bond->curr_active_slave)->dev,\n\t\t\t\t\t    -1);\n\t\t\tbond_info->primary_is_promisc = 0;\n\n\t\t\trtnl_unlock();\n\t\t\trcu_read_lock();\n\t\t}\n\n\t\tif (bond_info->rlb_rebalance) {\n\t\t\tbond_info->rlb_rebalance = 0;\n\t\t\trlb_rebalance(bond);\n\t\t}\n\n\t\t \n\t\tif (bond_info->rx_ntt) {\n\t\t\tif (bond_info->rlb_update_delay_counter) {\n\t\t\t\t--bond_info->rlb_update_delay_counter;\n\t\t\t} else {\n\t\t\t\trlb_update_rx_clients(bond);\n\t\t\t\tif (bond_info->rlb_update_retry_counter)\n\t\t\t\t\t--bond_info->rlb_update_retry_counter;\n\t\t\t\telse\n\t\t\t\t\tbond_info->rx_ntt = 0;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\nre_arm:\n\tqueue_delayed_work(bond->wq, &bond->alb_work, alb_delta_in_ticks);\n}\n\n \nint bond_alb_init_slave(struct bonding *bond, struct slave *slave)\n{\n\tint res;\n\n\tres = alb_set_slave_mac_addr(slave, slave->perm_hwaddr,\n\t\t\t\t     slave->dev->addr_len);\n\tif (res)\n\t\treturn res;\n\n\tres = alb_handle_addr_collision_on_attach(bond, slave);\n\tif (res)\n\t\treturn res;\n\n\ttlb_init_slave(slave);\n\n\t \n\tatomic_set(&bond->alb_info.tx_rebalance_counter,\n\t\t   BOND_TLB_REBALANCE_TICKS);\n\n\tif (bond->alb_info.rlb_enabled)\n\t\tbond->alb_info.rlb_rebalance = 1;\n\n\treturn 0;\n}\n\n \nvoid bond_alb_deinit_slave(struct bonding *bond, struct slave *slave)\n{\n\tif (bond_has_slaves(bond))\n\t\talb_change_hw_addr_on_detach(bond, slave);\n\n\ttlb_clear_slave(bond, slave, 0);\n\n\tif (bond->alb_info.rlb_enabled) {\n\t\tbond->alb_info.rx_slave = NULL;\n\t\trlb_clear_slave(bond, slave);\n\t}\n\n}\n\nvoid bond_alb_handle_link_change(struct bonding *bond, struct slave *slave, char link)\n{\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\tif (link == BOND_LINK_DOWN) {\n\t\ttlb_clear_slave(bond, slave, 0);\n\t\tif (bond->alb_info.rlb_enabled)\n\t\t\trlb_clear_slave(bond, slave);\n\t} else if (link == BOND_LINK_UP) {\n\t\t \n\t\tatomic_set(&bond_info->tx_rebalance_counter,\n\t\t\t   BOND_TLB_REBALANCE_TICKS);\n\t\tif (bond->alb_info.rlb_enabled) {\n\t\t\tbond->alb_info.rlb_rebalance = 1;\n\t\t\t \n\t\t}\n\t}\n\n\tif (bond_is_nondyn_tlb(bond)) {\n\t\tif (bond_update_slave_arr(bond, NULL))\n\t\t\tpr_err(\"Failed to build slave-array for TLB mode.\\n\");\n\t}\n}\n\n \nvoid bond_alb_handle_active_change(struct bonding *bond, struct slave *new_slave)\n{\n\tstruct slave *swap_slave;\n\tstruct slave *curr_active;\n\n\tcurr_active = rtnl_dereference(bond->curr_active_slave);\n\tif (curr_active == new_slave)\n\t\treturn;\n\n\tif (curr_active && bond->alb_info.primary_is_promisc) {\n\t\tdev_set_promiscuity(curr_active->dev, -1);\n\t\tbond->alb_info.primary_is_promisc = 0;\n\t\tbond->alb_info.rlb_promisc_timeout_counter = 0;\n\t}\n\n\tswap_slave = curr_active;\n\trcu_assign_pointer(bond->curr_active_slave, new_slave);\n\n\tif (!new_slave || !bond_has_slaves(bond))\n\t\treturn;\n\n\t \n\tif (!swap_slave)\n\t\tswap_slave = bond_slave_has_mac(bond, bond->dev->dev_addr);\n\n\t \n\tif (swap_slave)\n\t\ttlb_clear_slave(bond, swap_slave, 1);\n\ttlb_clear_slave(bond, new_slave, 1);\n\n\t \n\tif (BOND_MODE(bond) == BOND_MODE_TLB) {\n\t\tstruct sockaddr_storage ss;\n\t\tu8 tmp_addr[MAX_ADDR_LEN];\n\n\t\tbond_hw_addr_copy(tmp_addr, new_slave->dev->dev_addr,\n\t\t\t\t  new_slave->dev->addr_len);\n\n\t\tbond_hw_addr_copy(ss.__data, bond->dev->dev_addr,\n\t\t\t\t  bond->dev->addr_len);\n\t\tss.ss_family = bond->dev->type;\n\t\t \n\t\tdev_set_mac_address(new_slave->dev, (struct sockaddr *)&ss,\n\t\t\t\t    NULL);\n\n\t\tdev_addr_set(new_slave->dev, tmp_addr);\n\t}\n\n\t \n\tif (swap_slave) {\n\t\t \n\t\talb_swap_mac_addr(swap_slave, new_slave);\n\t\talb_fasten_mac_swap(bond, swap_slave, new_slave);\n\t} else {\n\t\t \n\t\talb_set_slave_mac_addr(new_slave, bond->dev->dev_addr,\n\t\t\t\t       bond->dev->addr_len);\n\t\talb_send_learning_packets(new_slave, bond->dev->dev_addr,\n\t\t\t\t\t  false);\n\t}\n}\n\n \nint bond_alb_set_mac_address(struct net_device *bond_dev, void *addr)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct sockaddr_storage *ss = addr;\n\tstruct slave *curr_active;\n\tstruct slave *swap_slave;\n\tint res;\n\n\tif (!is_valid_ether_addr(ss->__data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tres = alb_set_mac_address(bond, addr);\n\tif (res)\n\t\treturn res;\n\n\tdev_addr_set(bond_dev, ss->__data);\n\n\t \n\tcurr_active = rtnl_dereference(bond->curr_active_slave);\n\tif (!curr_active)\n\t\treturn 0;\n\n\tswap_slave = bond_slave_has_mac(bond, bond_dev->dev_addr);\n\n\tif (swap_slave) {\n\t\talb_swap_mac_addr(swap_slave, curr_active);\n\t\talb_fasten_mac_swap(bond, swap_slave, curr_active);\n\t} else {\n\t\talb_set_slave_mac_addr(curr_active, bond_dev->dev_addr,\n\t\t\t\t       bond_dev->addr_len);\n\n\t\talb_send_learning_packets(curr_active,\n\t\t\t\t\t  bond_dev->dev_addr, false);\n\t\tif (bond->alb_info.rlb_enabled) {\n\t\t\t \n\t\t\trlb_req_update_slave_clients(bond, curr_active);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid bond_alb_clear_vlan(struct bonding *bond, unsigned short vlan_id)\n{\n\tif (bond->alb_info.rlb_enabled)\n\t\trlb_clear_vlan(bond, vlan_id);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}