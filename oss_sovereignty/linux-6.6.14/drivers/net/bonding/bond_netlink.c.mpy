{
  "module_name": "bond_netlink.c",
  "hash_id": "dd3784b46383253acd30e5e92e776a1a42470e39c0f6fae70c4c2d21210bf1f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/bonding/bond_netlink.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_link.h>\n#include <linux/if_ether.h>\n#include <net/netlink.h>\n#include <net/rtnetlink.h>\n#include <net/bonding.h>\n#include <net/ipv6.h>\n\nstatic size_t bond_get_slave_size(const struct net_device *bond_dev,\n\t\t\t\t  const struct net_device *slave_dev)\n{\n\treturn nla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(MAX_ADDR_LEN) +\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u16)) +\t \n\t\tnla_total_size(sizeof(s32)) +\t \n\t\t0;\n}\n\nstatic int bond_fill_slave_info(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *bond_dev,\n\t\t\t\tconst struct net_device *slave_dev)\n{\n\tstruct slave *slave = bond_slave_get_rtnl(slave_dev);\n\n\tif (nla_put_u8(skb, IFLA_BOND_SLAVE_STATE, bond_slave_state(slave)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_SLAVE_MII_STATUS, slave->link))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,\n\t\t\tslave->link_failure_count))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, IFLA_BOND_SLAVE_PERM_HWADDR,\n\t\t    slave_dev->addr_len, slave->perm_hwaddr))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_BOND_SLAVE_QUEUE_ID, slave->queue_id))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_s32(skb, IFLA_BOND_SLAVE_PRIO, slave->prio))\n\t\tgoto nla_put_failure;\n\n\tif (BOND_MODE(slave->bond) == BOND_MODE_8023AD) {\n\t\tconst struct aggregator *agg;\n\t\tconst struct port *ad_port;\n\n\t\tad_port = &SLAVE_AD_INFO(slave)->port;\n\t\tagg = SLAVE_AD_INFO(slave)->port.aggregator;\n\t\tif (agg) {\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,\n\t\t\t\t\tagg->aggregator_identifier))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u8(skb,\n\t\t\t\t       IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE,\n\t\t\t\t       ad_port->actor_oper_port_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u16(skb,\n\t\t\t\t\tIFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE,\n\t\t\t\t\tad_port->partner_oper.port_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\n \nstatic struct netlink_range_validation delay_range = {\n\t.max = 300000,\n};\n\nstatic const struct nla_policy bond_policy[IFLA_BOND_MAX + 1] = {\n\t[IFLA_BOND_MODE]\t\t= { .type = NLA_U8 },\n\t[IFLA_BOND_ACTIVE_SLAVE]\t= { .type = NLA_U32 },\n\t[IFLA_BOND_MIIMON]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_UPDELAY]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_DOWNDELAY]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_USE_CARRIER]\t\t= { .type = NLA_U8 },\n\t[IFLA_BOND_ARP_INTERVAL]\t= { .type = NLA_U32 },\n\t[IFLA_BOND_ARP_IP_TARGET]\t= { .type = NLA_NESTED },\n\t[IFLA_BOND_ARP_VALIDATE]\t= { .type = NLA_U32 },\n\t[IFLA_BOND_ARP_ALL_TARGETS]\t= { .type = NLA_U32 },\n\t[IFLA_BOND_PRIMARY]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_PRIMARY_RESELECT]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_FAIL_OVER_MAC]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_XMIT_HASH_POLICY]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_RESEND_IGMP]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_NUM_PEER_NOTIF]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_ALL_SLAVES_ACTIVE]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_MIN_LINKS]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_LP_INTERVAL]\t\t= { .type = NLA_U32 },\n\t[IFLA_BOND_PACKETS_PER_SLAVE]\t= { .type = NLA_U32 },\n\t[IFLA_BOND_AD_LACP_ACTIVE]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_AD_LACP_RATE]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_AD_SELECT]\t\t= { .type = NLA_U8 },\n\t[IFLA_BOND_AD_INFO]\t\t= { .type = NLA_NESTED },\n\t[IFLA_BOND_AD_ACTOR_SYS_PRIO]\t= { .type = NLA_U16 },\n\t[IFLA_BOND_AD_USER_PORT_KEY]\t= { .type = NLA_U16 },\n\t[IFLA_BOND_AD_ACTOR_SYSTEM]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len  = ETH_ALEN },\n\t[IFLA_BOND_TLB_DYNAMIC_LB]\t= { .type = NLA_U8 },\n\t[IFLA_BOND_PEER_NOTIF_DELAY]    = NLA_POLICY_FULL_RANGE(NLA_U32, &delay_range),\n\t[IFLA_BOND_MISSED_MAX]\t\t= { .type = NLA_U8 },\n\t[IFLA_BOND_NS_IP6_TARGET]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy bond_slave_policy[IFLA_BOND_SLAVE_MAX + 1] = {\n\t[IFLA_BOND_SLAVE_QUEUE_ID]\t= { .type = NLA_U16 },\n\t[IFLA_BOND_SLAVE_PRIO]\t\t= { .type = NLA_S32 },\n};\n\nstatic int bond_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic int bond_slave_changelink(struct net_device *bond_dev,\n\t\t\t\t struct net_device *slave_dev,\n\t\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_opt_value newval;\n\tint err;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_BOND_SLAVE_QUEUE_ID]) {\n\t\tu16 queue_id = nla_get_u16(data[IFLA_BOND_SLAVE_QUEUE_ID]);\n\t\tchar queue_id_str[IFNAMSIZ + 7];\n\n\t\t \n\t\tsnprintf(queue_id_str, sizeof(queue_id_str), \"%s:%u\\n\",\n\t\t\t slave_dev->name, queue_id);\n\t\tbond_opt_initstr(&newval, queue_id_str);\n\t\terr = __bond_opt_set(bond, BOND_OPT_QUEUE_ID, &newval,\n\t\t\t\t     data[IFLA_BOND_SLAVE_QUEUE_ID], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BOND_SLAVE_PRIO]) {\n\t\tint prio = nla_get_s32(data[IFLA_BOND_SLAVE_PRIO]);\n\n\t\tbond_opt_slave_initval(&newval, &slave_dev, prio);\n\t\terr = __bond_opt_set(bond, BOND_OPT_PRIO, &newval,\n\t\t\t\t     data[IFLA_BOND_SLAVE_PRIO], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_changelink(struct net_device *bond_dev, struct nlattr *tb[],\n\t\t\t   struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_opt_value newval;\n\tint miimon = 0;\n\tint err;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_BOND_MODE]) {\n\t\tint mode = nla_get_u8(data[IFLA_BOND_MODE]);\n\n\t\tbond_opt_initval(&newval, mode);\n\t\terr = __bond_opt_set(bond, BOND_OPT_MODE, &newval,\n\t\t\t\t     data[IFLA_BOND_MODE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_ACTIVE_SLAVE]) {\n\t\tint ifindex = nla_get_u32(data[IFLA_BOND_ACTIVE_SLAVE]);\n\t\tstruct net_device *slave_dev;\n\t\tchar *active_slave = \"\";\n\n\t\tif (ifindex != 0) {\n\t\t\tslave_dev = __dev_get_by_index(dev_net(bond_dev),\n\t\t\t\t\t\t       ifindex);\n\t\t\tif (!slave_dev)\n\t\t\t\treturn -ENODEV;\n\t\t\tactive_slave = slave_dev->name;\n\t\t}\n\t\tbond_opt_initstr(&newval, active_slave);\n\t\terr = __bond_opt_set(bond, BOND_OPT_ACTIVE_SLAVE, &newval,\n\t\t\t\t     data[IFLA_BOND_ACTIVE_SLAVE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_MIIMON]) {\n\t\tmiimon = nla_get_u32(data[IFLA_BOND_MIIMON]);\n\n\t\tbond_opt_initval(&newval, miimon);\n\t\terr = __bond_opt_set(bond, BOND_OPT_MIIMON, &newval,\n\t\t\t\t     data[IFLA_BOND_MIIMON], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_UPDELAY]) {\n\t\tint updelay = nla_get_u32(data[IFLA_BOND_UPDELAY]);\n\n\t\tbond_opt_initval(&newval, updelay);\n\t\terr = __bond_opt_set(bond, BOND_OPT_UPDELAY, &newval,\n\t\t\t\t     data[IFLA_BOND_UPDELAY], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_DOWNDELAY]) {\n\t\tint downdelay = nla_get_u32(data[IFLA_BOND_DOWNDELAY]);\n\n\t\tbond_opt_initval(&newval, downdelay);\n\t\terr = __bond_opt_set(bond, BOND_OPT_DOWNDELAY, &newval,\n\t\t\t\t     data[IFLA_BOND_DOWNDELAY], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_PEER_NOTIF_DELAY]) {\n\t\tint delay = nla_get_u32(data[IFLA_BOND_PEER_NOTIF_DELAY]);\n\n\t\tbond_opt_initval(&newval, delay);\n\t\terr = __bond_opt_set(bond, BOND_OPT_PEER_NOTIF_DELAY, &newval,\n\t\t\t\t     data[IFLA_BOND_PEER_NOTIF_DELAY], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_USE_CARRIER]) {\n\t\tint use_carrier = nla_get_u8(data[IFLA_BOND_USE_CARRIER]);\n\n\t\tbond_opt_initval(&newval, use_carrier);\n\t\terr = __bond_opt_set(bond, BOND_OPT_USE_CARRIER, &newval,\n\t\t\t\t     data[IFLA_BOND_USE_CARRIER], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_ARP_INTERVAL]) {\n\t\tint arp_interval = nla_get_u32(data[IFLA_BOND_ARP_INTERVAL]);\n\n\t\tif (arp_interval && miimon) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_BOND_ARP_INTERVAL],\n\t\t\t\t\t    \"ARP monitoring cannot be used with MII monitoring\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbond_opt_initval(&newval, arp_interval);\n\t\terr = __bond_opt_set(bond, BOND_OPT_ARP_INTERVAL, &newval,\n\t\t\t\t     data[IFLA_BOND_ARP_INTERVAL], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_ARP_IP_TARGET]) {\n\t\tstruct nlattr *attr;\n\t\tint i = 0, rem;\n\n\t\tbond_option_arp_ip_targets_clear(bond);\n\t\tnla_for_each_nested(attr, data[IFLA_BOND_ARP_IP_TARGET], rem) {\n\t\t\t__be32 target;\n\n\t\t\tif (nla_len(attr) < sizeof(target))\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttarget = nla_get_be32(attr);\n\n\t\t\tbond_opt_initval(&newval, (__force u64)target);\n\t\t\terr = __bond_opt_set(bond, BOND_OPT_ARP_TARGETS,\n\t\t\t\t\t     &newval,\n\t\t\t\t\t     data[IFLA_BOND_ARP_IP_TARGET],\n\t\t\t\t\t     extack);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == 0 && bond->params.arp_interval)\n\t\t\tnetdev_warn(bond->dev, \"Removing last arp target with arp_interval on\\n\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (data[IFLA_BOND_NS_IP6_TARGET]) {\n\t\tstruct nlattr *attr;\n\t\tint i = 0, rem;\n\n\t\tbond_option_ns_ip6_targets_clear(bond);\n\t\tnla_for_each_nested(attr, data[IFLA_BOND_NS_IP6_TARGET], rem) {\n\t\t\tstruct in6_addr addr6;\n\n\t\t\tif (nla_len(attr) < sizeof(addr6)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid IPv6 address\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\taddr6 = nla_get_in6_addr(attr);\n\n\t\t\tbond_opt_initextra(&newval, &addr6, sizeof(addr6));\n\t\t\terr = __bond_opt_set(bond, BOND_OPT_NS_TARGETS,\n\t\t\t\t\t     &newval,\n\t\t\t\t\t     data[IFLA_BOND_NS_IP6_TARGET],\n\t\t\t\t\t     extack);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == 0 && bond->params.arp_interval)\n\t\t\tnetdev_warn(bond->dev, \"Removing last ns target with arp_interval on\\n\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n\tif (data[IFLA_BOND_ARP_VALIDATE]) {\n\t\tint arp_validate = nla_get_u32(data[IFLA_BOND_ARP_VALIDATE]);\n\n\t\tif (arp_validate && miimon) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_BOND_ARP_INTERVAL],\n\t\t\t\t\t    \"ARP validating cannot be used with MII monitoring\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbond_opt_initval(&newval, arp_validate);\n\t\terr = __bond_opt_set(bond, BOND_OPT_ARP_VALIDATE, &newval,\n\t\t\t\t     data[IFLA_BOND_ARP_VALIDATE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_ARP_ALL_TARGETS]) {\n\t\tint arp_all_targets =\n\t\t\tnla_get_u32(data[IFLA_BOND_ARP_ALL_TARGETS]);\n\n\t\tbond_opt_initval(&newval, arp_all_targets);\n\t\terr = __bond_opt_set(bond, BOND_OPT_ARP_ALL_TARGETS, &newval,\n\t\t\t\t     data[IFLA_BOND_ARP_ALL_TARGETS], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_PRIMARY]) {\n\t\tint ifindex = nla_get_u32(data[IFLA_BOND_PRIMARY]);\n\t\tstruct net_device *dev;\n\t\tchar *primary = \"\";\n\n\t\tdev = __dev_get_by_index(dev_net(bond_dev), ifindex);\n\t\tif (dev)\n\t\t\tprimary = dev->name;\n\n\t\tbond_opt_initstr(&newval, primary);\n\t\terr = __bond_opt_set(bond, BOND_OPT_PRIMARY, &newval,\n\t\t\t\t     data[IFLA_BOND_PRIMARY], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_PRIMARY_RESELECT]) {\n\t\tint primary_reselect =\n\t\t\tnla_get_u8(data[IFLA_BOND_PRIMARY_RESELECT]);\n\n\t\tbond_opt_initval(&newval, primary_reselect);\n\t\terr = __bond_opt_set(bond, BOND_OPT_PRIMARY_RESELECT, &newval,\n\t\t\t\t     data[IFLA_BOND_PRIMARY_RESELECT], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_FAIL_OVER_MAC]) {\n\t\tint fail_over_mac =\n\t\t\tnla_get_u8(data[IFLA_BOND_FAIL_OVER_MAC]);\n\n\t\tbond_opt_initval(&newval, fail_over_mac);\n\t\terr = __bond_opt_set(bond, BOND_OPT_FAIL_OVER_MAC, &newval,\n\t\t\t\t     data[IFLA_BOND_FAIL_OVER_MAC], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_XMIT_HASH_POLICY]) {\n\t\tint xmit_hash_policy =\n\t\t\tnla_get_u8(data[IFLA_BOND_XMIT_HASH_POLICY]);\n\n\t\tbond_opt_initval(&newval, xmit_hash_policy);\n\t\terr = __bond_opt_set(bond, BOND_OPT_XMIT_HASH, &newval,\n\t\t\t\t     data[IFLA_BOND_XMIT_HASH_POLICY], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_RESEND_IGMP]) {\n\t\tint resend_igmp =\n\t\t\tnla_get_u32(data[IFLA_BOND_RESEND_IGMP]);\n\n\t\tbond_opt_initval(&newval, resend_igmp);\n\t\terr = __bond_opt_set(bond, BOND_OPT_RESEND_IGMP, &newval,\n\t\t\t\t     data[IFLA_BOND_RESEND_IGMP], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_NUM_PEER_NOTIF]) {\n\t\tint num_peer_notif =\n\t\t\tnla_get_u8(data[IFLA_BOND_NUM_PEER_NOTIF]);\n\n\t\tbond_opt_initval(&newval, num_peer_notif);\n\t\terr = __bond_opt_set(bond, BOND_OPT_NUM_PEER_NOTIF, &newval,\n\t\t\t\t     data[IFLA_BOND_NUM_PEER_NOTIF], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_ALL_SLAVES_ACTIVE]) {\n\t\tint all_slaves_active =\n\t\t\tnla_get_u8(data[IFLA_BOND_ALL_SLAVES_ACTIVE]);\n\n\t\tbond_opt_initval(&newval, all_slaves_active);\n\t\terr = __bond_opt_set(bond, BOND_OPT_ALL_SLAVES_ACTIVE, &newval,\n\t\t\t\t     data[IFLA_BOND_ALL_SLAVES_ACTIVE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_MIN_LINKS]) {\n\t\tint min_links =\n\t\t\tnla_get_u32(data[IFLA_BOND_MIN_LINKS]);\n\n\t\tbond_opt_initval(&newval, min_links);\n\t\terr = __bond_opt_set(bond, BOND_OPT_MINLINKS, &newval,\n\t\t\t\t     data[IFLA_BOND_MIN_LINKS], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_LP_INTERVAL]) {\n\t\tint lp_interval =\n\t\t\tnla_get_u32(data[IFLA_BOND_LP_INTERVAL]);\n\n\t\tbond_opt_initval(&newval, lp_interval);\n\t\terr = __bond_opt_set(bond, BOND_OPT_LP_INTERVAL, &newval,\n\t\t\t\t     data[IFLA_BOND_LP_INTERVAL], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_PACKETS_PER_SLAVE]) {\n\t\tint packets_per_slave =\n\t\t\tnla_get_u32(data[IFLA_BOND_PACKETS_PER_SLAVE]);\n\n\t\tbond_opt_initval(&newval, packets_per_slave);\n\t\terr = __bond_opt_set(bond, BOND_OPT_PACKETS_PER_SLAVE, &newval,\n\t\t\t\t     data[IFLA_BOND_PACKETS_PER_SLAVE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BOND_AD_LACP_ACTIVE]) {\n\t\tint lacp_active = nla_get_u8(data[IFLA_BOND_AD_LACP_ACTIVE]);\n\n\t\tbond_opt_initval(&newval, lacp_active);\n\t\terr = __bond_opt_set(bond, BOND_OPT_LACP_ACTIVE, &newval,\n\t\t\t\t     data[IFLA_BOND_AD_LACP_ACTIVE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BOND_AD_LACP_RATE]) {\n\t\tint lacp_rate =\n\t\t\tnla_get_u8(data[IFLA_BOND_AD_LACP_RATE]);\n\n\t\tbond_opt_initval(&newval, lacp_rate);\n\t\terr = __bond_opt_set(bond, BOND_OPT_LACP_RATE, &newval,\n\t\t\t\t     data[IFLA_BOND_AD_LACP_RATE], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_AD_SELECT]) {\n\t\tint ad_select =\n\t\t\tnla_get_u8(data[IFLA_BOND_AD_SELECT]);\n\n\t\tbond_opt_initval(&newval, ad_select);\n\t\terr = __bond_opt_set(bond, BOND_OPT_AD_SELECT, &newval,\n\t\t\t\t     data[IFLA_BOND_AD_SELECT], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_AD_ACTOR_SYS_PRIO]) {\n\t\tint actor_sys_prio =\n\t\t\tnla_get_u16(data[IFLA_BOND_AD_ACTOR_SYS_PRIO]);\n\n\t\tbond_opt_initval(&newval, actor_sys_prio);\n\t\terr = __bond_opt_set(bond, BOND_OPT_AD_ACTOR_SYS_PRIO, &newval,\n\t\t\t\t     data[IFLA_BOND_AD_ACTOR_SYS_PRIO], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_AD_USER_PORT_KEY]) {\n\t\tint port_key =\n\t\t\tnla_get_u16(data[IFLA_BOND_AD_USER_PORT_KEY]);\n\n\t\tbond_opt_initval(&newval, port_key);\n\t\terr = __bond_opt_set(bond, BOND_OPT_AD_USER_PORT_KEY, &newval,\n\t\t\t\t     data[IFLA_BOND_AD_USER_PORT_KEY], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_AD_ACTOR_SYSTEM]) {\n\t\tif (nla_len(data[IFLA_BOND_AD_ACTOR_SYSTEM]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tbond_opt_initval(&newval,\n\t\t\t\t nla_get_u64(data[IFLA_BOND_AD_ACTOR_SYSTEM]));\n\t\terr = __bond_opt_set(bond, BOND_OPT_AD_ACTOR_SYSTEM, &newval,\n\t\t\t\t     data[IFLA_BOND_AD_ACTOR_SYSTEM], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_BOND_TLB_DYNAMIC_LB]) {\n\t\tint dynamic_lb = nla_get_u8(data[IFLA_BOND_TLB_DYNAMIC_LB]);\n\n\t\tbond_opt_initval(&newval, dynamic_lb);\n\t\terr = __bond_opt_set(bond, BOND_OPT_TLB_DYNAMIC_LB, &newval,\n\t\t\t\t     data[IFLA_BOND_TLB_DYNAMIC_LB], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_BOND_MISSED_MAX]) {\n\t\tint missed_max = nla_get_u8(data[IFLA_BOND_MISSED_MAX]);\n\n\t\tbond_opt_initval(&newval, missed_max);\n\t\terr = __bond_opt_set(bond, BOND_OPT_MISSED_MAX, &newval,\n\t\t\t\t     data[IFLA_BOND_MISSED_MAX], extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_newlink(struct net *src_net, struct net_device *bond_dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = bond_changelink(bond_dev, tb, data, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = register_netdevice(bond_dev);\n\tif (!err) {\n\t\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\t\tnetif_carrier_off(bond_dev);\n\t\tbond_work_init_all(bond);\n\t}\n\n\treturn err;\n}\n\nstatic size_t bond_get_size(const struct net_device *bond_dev)\n{\n\treturn nla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\t\t\t\t\t \n\t\tnla_total_size(sizeof(struct nlattr)) +\n\t\tnla_total_size(sizeof(u32)) * BOND_MAX_ARP_TARGETS +\n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u8)) +    \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u32)) +   \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\tnla_total_size(sizeof(struct nlattr)) +  \n\t\tnla_total_size(sizeof(u16)) +  \n\t\tnla_total_size(sizeof(u16)) +  \n\t\tnla_total_size(sizeof(u16)) +  \n\t\tnla_total_size(sizeof(u16)) +  \n\t\tnla_total_size(ETH_ALEN) +     \n\t\tnla_total_size(sizeof(u16)) +  \n\t\tnla_total_size(sizeof(u16)) +  \n\t\tnla_total_size(ETH_ALEN) +  \n\t\tnla_total_size(sizeof(u8)) +  \n\t\tnla_total_size(sizeof(u32)) +\t \n\t\tnla_total_size(sizeof(u8)) +\t \n\t\t\t\t\t\t \n\t\tnla_total_size(sizeof(struct nlattr)) +\n\t\tnla_total_size(sizeof(struct in6_addr)) * BOND_MAX_NS_TARGETS +\n\t\t0;\n}\n\nstatic int bond_option_active_slave_get_ifindex(struct bonding *bond)\n{\n\tconst struct net_device *slave;\n\tint ifindex;\n\n\trcu_read_lock();\n\tslave = bond_option_active_slave_get_rcu(bond);\n\tifindex = slave ? slave->ifindex : 0;\n\trcu_read_unlock();\n\treturn ifindex;\n}\n\nstatic int bond_fill_info(struct sk_buff *skb,\n\t\t\t  const struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tunsigned int packets_per_slave;\n\tint ifindex, i, targets_added;\n\tstruct nlattr *targets;\n\tstruct slave *primary;\n\n\tif (nla_put_u8(skb, IFLA_BOND_MODE, BOND_MODE(bond)))\n\t\tgoto nla_put_failure;\n\n\tifindex = bond_option_active_slave_get_ifindex(bond);\n\tif (ifindex && nla_put_u32(skb, IFLA_BOND_ACTIVE_SLAVE, ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_MIIMON, bond->params.miimon))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_UPDELAY,\n\t\t\tbond->params.updelay * bond->params.miimon))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_DOWNDELAY,\n\t\t\tbond->params.downdelay * bond->params.miimon))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_PEER_NOTIF_DELAY,\n\t\t\tbond->params.peer_notif_delay * bond->params.miimon))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_USE_CARRIER, bond->params.use_carrier))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_ARP_INTERVAL, bond->params.arp_interval))\n\t\tgoto nla_put_failure;\n\n\ttargets = nla_nest_start_noflag(skb, IFLA_BOND_ARP_IP_TARGET);\n\tif (!targets)\n\t\tgoto nla_put_failure;\n\n\ttargets_added = 0;\n\tfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++) {\n\t\tif (bond->params.arp_targets[i]) {\n\t\t\tif (nla_put_be32(skb, i, bond->params.arp_targets[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t\ttargets_added = 1;\n\t\t}\n\t}\n\n\tif (targets_added)\n\t\tnla_nest_end(skb, targets);\n\telse\n\t\tnla_nest_cancel(skb, targets);\n\n\tif (nla_put_u32(skb, IFLA_BOND_ARP_VALIDATE, bond->params.arp_validate))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_ARP_ALL_TARGETS,\n\t\t\tbond->params.arp_all_targets))\n\t\tgoto nla_put_failure;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\ttargets = nla_nest_start(skb, IFLA_BOND_NS_IP6_TARGET);\n\tif (!targets)\n\t\tgoto nla_put_failure;\n\n\ttargets_added = 0;\n\tfor (i = 0; i < BOND_MAX_NS_TARGETS; i++) {\n\t\tif (!ipv6_addr_any(&bond->params.ns_targets[i])) {\n\t\t\tif (nla_put_in6_addr(skb, i, &bond->params.ns_targets[i]))\n\t\t\t\tgoto nla_put_failure;\n\t\t\ttargets_added = 1;\n\t\t}\n\t}\n\n\tif (targets_added)\n\t\tnla_nest_end(skb, targets);\n\telse\n\t\tnla_nest_cancel(skb, targets);\n#endif\n\n\tprimary = rtnl_dereference(bond->primary_slave);\n\tif (primary &&\n\t    nla_put_u32(skb, IFLA_BOND_PRIMARY, primary->dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_PRIMARY_RESELECT,\n\t\t       bond->params.primary_reselect))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_FAIL_OVER_MAC,\n\t\t       bond->params.fail_over_mac))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_XMIT_HASH_POLICY,\n\t\t       bond->params.xmit_policy))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_RESEND_IGMP,\n\t\t\tbond->params.resend_igmp))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_NUM_PEER_NOTIF,\n\t\t       bond->params.num_peer_notif))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_ALL_SLAVES_ACTIVE,\n\t\t       bond->params.all_slaves_active))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_MIN_LINKS,\n\t\t\tbond->params.min_links))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, IFLA_BOND_LP_INTERVAL,\n\t\t\tbond->params.lp_interval))\n\t\tgoto nla_put_failure;\n\n\tpackets_per_slave = bond->params.packets_per_slave;\n\tif (nla_put_u32(skb, IFLA_BOND_PACKETS_PER_SLAVE,\n\t\t\tpackets_per_slave))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_AD_LACP_ACTIVE,\n\t\t       bond->params.lacp_active))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_AD_LACP_RATE,\n\t\t       bond->params.lacp_fast))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_AD_SELECT,\n\t\t       bond->params.ad_select))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_TLB_DYNAMIC_LB,\n\t\t       bond->params.tlb_dynamic_lb))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_BOND_MISSED_MAX,\n\t\t       bond->params.missed_max))\n\t\tgoto nla_put_failure;\n\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tstruct ad_info info;\n\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_AD_ACTOR_SYS_PRIO,\n\t\t\t\t\tbond->params.ad_actor_sys_prio))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_AD_USER_PORT_KEY,\n\t\t\t\t\tbond->params.ad_user_port_key))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put(skb, IFLA_BOND_AD_ACTOR_SYSTEM,\n\t\t\t\t    ETH_ALEN, &bond->params.ad_actor_system))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tif (!bond_3ad_get_active_agg_info(bond, &info)) {\n\t\t\tstruct nlattr *nest;\n\n\t\t\tnest = nla_nest_start_noflag(skb, IFLA_BOND_AD_INFO);\n\t\t\tif (!nest)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_AD_INFO_AGGREGATOR,\n\t\t\t\t\tinfo.aggregator_id))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_AD_INFO_NUM_PORTS,\n\t\t\t\t\tinfo.ports))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_AD_INFO_ACTOR_KEY,\n\t\t\t\t\tinfo.actor_key))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u16(skb, IFLA_BOND_AD_INFO_PARTNER_KEY,\n\t\t\t\t\tinfo.partner_key))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put(skb, IFLA_BOND_AD_INFO_PARTNER_MAC,\n\t\t\t\t    sizeof(info.partner_system),\n\t\t\t\t    &info.partner_system))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic size_t bond_get_linkxstats_size(const struct net_device *dev, int attr)\n{\n\tswitch (attr) {\n\tcase IFLA_STATS_LINK_XSTATS:\n\tcase IFLA_STATS_LINK_XSTATS_SLAVE:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn bond_3ad_stats_size() + nla_total_size(0);\n}\n\nstatic int bond_fill_linkxstats(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev,\n\t\t\t\tint *prividx, int attr)\n{\n\tstruct nlattr *nla __maybe_unused;\n\tstruct slave *slave = NULL;\n\tstruct nlattr *nest, *nest2;\n\tstruct bonding *bond;\n\n\tswitch (attr) {\n\tcase IFLA_STATS_LINK_XSTATS:\n\t\tbond = netdev_priv(dev);\n\t\tbreak;\n\tcase IFLA_STATS_LINK_XSTATS_SLAVE:\n\t\tslave = bond_slave_get_rtnl(dev);\n\t\tif (!slave)\n\t\t\treturn 0;\n\t\tbond = slave->bond;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnest = nla_nest_start_noflag(skb, LINK_XSTATS_TYPE_BOND);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\tif (BOND_MODE(bond) == BOND_MODE_8023AD) {\n\t\tstruct bond_3ad_stats *stats;\n\n\t\tif (slave)\n\t\t\tstats = &SLAVE_AD_INFO(slave)->stats;\n\t\telse\n\t\t\tstats = &BOND_AD_INFO(bond).stats;\n\n\t\tnest2 = nla_nest_start_noflag(skb, BOND_XSTATS_3AD);\n\t\tif (!nest2) {\n\t\t\tnla_nest_end(skb, nest);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (bond_3ad_stats_fill(skb, stats)) {\n\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\tnla_nest_end(skb, nest);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tnla_nest_end(skb, nest2);\n\t}\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n}\n\nstruct rtnl_link_ops bond_link_ops __read_mostly = {\n\t.kind\t\t\t= \"bond\",\n\t.priv_size\t\t= sizeof(struct bonding),\n\t.setup\t\t\t= bond_setup,\n\t.maxtype\t\t= IFLA_BOND_MAX,\n\t.policy\t\t\t= bond_policy,\n\t.validate\t\t= bond_validate,\n\t.newlink\t\t= bond_newlink,\n\t.changelink\t\t= bond_changelink,\n\t.get_size\t\t= bond_get_size,\n\t.fill_info\t\t= bond_fill_info,\n\t.get_num_tx_queues\t= bond_get_num_tx_queues,\n\t.get_num_rx_queues\t= bond_get_num_tx_queues,  \n\t.fill_linkxstats        = bond_fill_linkxstats,\n\t.get_linkxstats_size    = bond_get_linkxstats_size,\n\t.slave_maxtype\t\t= IFLA_BOND_SLAVE_MAX,\n\t.slave_policy\t\t= bond_slave_policy,\n\t.slave_changelink\t= bond_slave_changelink,\n\t.get_slave_size\t\t= bond_get_slave_size,\n\t.fill_slave_info\t= bond_fill_slave_info,\n};\n\nint __init bond_netlink_init(void)\n{\n\treturn rtnl_link_register(&bond_link_ops);\n}\n\nvoid bond_netlink_fini(void)\n{\n\trtnl_link_unregister(&bond_link_ops);\n}\n\nMODULE_ALIAS_RTNL_LINK(\"bond\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}