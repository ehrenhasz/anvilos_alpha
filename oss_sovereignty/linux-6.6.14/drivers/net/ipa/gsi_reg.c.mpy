{
  "module_name": "gsi_reg.c",
  "hash_id": "12e72882f3b6fb06aec3954e3dba6513670f444827583c709293c63ddb2110e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/gsi_reg.c",
  "human_readable_source": "\n\n \n\n#include <linux/platform_device.h>\n#include <linux/io.h>\n\n#include \"gsi.h\"\n#include \"reg.h\"\n#include \"gsi_reg.h\"\n\n \nstatic bool gsi_reg_id_valid(struct gsi *gsi, enum gsi_reg_id reg_id)\n{\n\tswitch (reg_id) {\n\tcase INTER_EE_SRC_CH_IRQ_MSK:\n\tcase INTER_EE_SRC_EV_CH_IRQ_MSK:\n\t\treturn gsi->version >= IPA_VERSION_3_5;\n\n\tcase HW_PARAM_2:\n\t\treturn gsi->version >= IPA_VERSION_3_5_1;\n\n\tcase HW_PARAM_4:\n\t\treturn gsi->version >= IPA_VERSION_5_0;\n\n\tcase CH_C_CNTXT_0:\n\tcase CH_C_CNTXT_1:\n\tcase CH_C_CNTXT_2:\n\tcase CH_C_CNTXT_3:\n\tcase CH_C_QOS:\n\tcase CH_C_SCRATCH_0:\n\tcase CH_C_SCRATCH_1:\n\tcase CH_C_SCRATCH_2:\n\tcase CH_C_SCRATCH_3:\n\tcase EV_CH_E_CNTXT_0:\n\tcase EV_CH_E_CNTXT_1:\n\tcase EV_CH_E_CNTXT_2:\n\tcase EV_CH_E_CNTXT_3:\n\tcase EV_CH_E_CNTXT_4:\n\tcase EV_CH_E_CNTXT_8:\n\tcase EV_CH_E_CNTXT_9:\n\tcase EV_CH_E_CNTXT_10:\n\tcase EV_CH_E_CNTXT_11:\n\tcase EV_CH_E_CNTXT_12:\n\tcase EV_CH_E_CNTXT_13:\n\tcase EV_CH_E_SCRATCH_0:\n\tcase EV_CH_E_SCRATCH_1:\n\tcase CH_C_DOORBELL_0:\n\tcase EV_CH_E_DOORBELL_0:\n\tcase GSI_STATUS:\n\tcase CH_CMD:\n\tcase EV_CH_CMD:\n\tcase GENERIC_CMD:\n\tcase CNTXT_TYPE_IRQ:\n\tcase CNTXT_TYPE_IRQ_MSK:\n\tcase CNTXT_SRC_CH_IRQ:\n\tcase CNTXT_SRC_CH_IRQ_MSK:\n\tcase CNTXT_SRC_CH_IRQ_CLR:\n\tcase CNTXT_SRC_EV_CH_IRQ:\n\tcase CNTXT_SRC_EV_CH_IRQ_MSK:\n\tcase CNTXT_SRC_EV_CH_IRQ_CLR:\n\tcase CNTXT_SRC_IEOB_IRQ:\n\tcase CNTXT_SRC_IEOB_IRQ_MSK:\n\tcase CNTXT_SRC_IEOB_IRQ_CLR:\n\tcase CNTXT_GLOB_IRQ_STTS:\n\tcase CNTXT_GLOB_IRQ_EN:\n\tcase CNTXT_GLOB_IRQ_CLR:\n\tcase CNTXT_GSI_IRQ_STTS:\n\tcase CNTXT_GSI_IRQ_EN:\n\tcase CNTXT_GSI_IRQ_CLR:\n\tcase CNTXT_INTSET:\n\tcase ERROR_LOG:\n\tcase ERROR_LOG_CLR:\n\tcase CNTXT_SCRATCH_0:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nconst struct reg *gsi_reg(struct gsi *gsi, enum gsi_reg_id reg_id)\n{\n\tif (WARN(!gsi_reg_id_valid(gsi, reg_id), \"invalid reg %u\\n\", reg_id))\n\t\treturn NULL;\n\n\treturn reg(gsi->regs, reg_id);\n}\n\nstatic const struct regs *gsi_regs(struct gsi *gsi)\n{\n\tswitch (gsi->version) {\n\tcase IPA_VERSION_3_1:\n\t\treturn &gsi_regs_v3_1;\n\n\tcase IPA_VERSION_3_5_1:\n\t\treturn &gsi_regs_v3_5_1;\n\n\tcase IPA_VERSION_4_2:\n\t\treturn &gsi_regs_v4_0;\n\n\tcase IPA_VERSION_4_5:\n\tcase IPA_VERSION_4_7:\n\t\treturn &gsi_regs_v4_5;\n\n\tcase IPA_VERSION_4_9:\n\t\treturn &gsi_regs_v4_9;\n\n\tcase IPA_VERSION_4_11:\n\t\treturn &gsi_regs_v4_11;\n\n\tcase IPA_VERSION_5_0:\n\t\treturn &gsi_regs_v5_0;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nint gsi_reg_init(struct gsi *gsi, struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tresource_size_t size;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"gsi\");\n\tif (!res) {\n\t\tdev_err(dev, \"DT error getting \\\"gsi\\\" memory property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsize = resource_size(res);\n\tif (res->start > U32_MAX || size > U32_MAX - res->start) {\n\t\tdev_err(dev, \"DT memory resource \\\"gsi\\\" out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgsi->regs = gsi_regs(gsi);\n\tif (!gsi->regs) {\n\t\tdev_err(dev, \"unsupported IPA version %u (?)\\n\", gsi->version);\n\t\treturn -EINVAL;\n\t}\n\n\tgsi->virt = ioremap(res->start, size);\n\tif (!gsi->virt) {\n\t\tdev_err(dev, \"unable to remap \\\"gsi\\\" memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nvoid gsi_reg_exit(struct gsi *gsi)\n{\n\tiounmap(gsi->virt);\n\tgsi->virt = NULL;\n\tgsi->regs = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}