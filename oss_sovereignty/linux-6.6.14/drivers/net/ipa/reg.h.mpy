{
  "module_name": "reg.h",
  "hash_id": "c4573b46086632cfbcefe1b2d28448937fb82e1ef2ec8a9e5f221665535642d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/reg.h",
  "human_readable_source": " \n\n \n\n#ifndef _REG_H_\n#define _REG_H_\n\n#include <linux/types.h>\n#include <linux/log2.h>\n#include <linux/bug.h>\n\n \nstruct reg {\n\tu32 offset;\n\tu32 stride;\n\tu32 fcount;\n\tconst u32 *fmask;\t\t\t \n\tconst char *name;\n};\n\n \n#define REG(__NAME, __reg_id, __offset)\t\t\t\t\t\\\n\tREG_STRIDE(__NAME, __reg_id, __offset, 0)\n\n \n#define REG_STRIDE(__NAME, __reg_id, __offset, __stride)\t\t\\\n\tstatic const struct reg reg_ ## __reg_id = {\t\t\t\\\n\t\t.name\t= #__NAME,\t\t\t\t\t\\\n\t\t.offset\t= __offset,\t\t\t\t\t\\\n\t\t.stride\t= __stride,\t\t\t\t\t\\\n\t}\n\n#define REG_FIELDS(__NAME, __name, __offset)\t\t\t\t\\\n\tREG_STRIDE_FIELDS(__NAME, __name, __offset, 0)\n\n#define REG_STRIDE_FIELDS(__NAME, __name, __offset, __stride)\t\t\\\n\tstatic const struct reg reg_ ## __name = {\t\t\t\\\n\t\t.name   = #__NAME,\t\t\t\t\t\\\n\t\t.offset = __offset,\t\t\t\t\t\\\n\t\t.stride = __stride,\t\t\t\t\t\\\n\t\t.fcount = ARRAY_SIZE(reg_ ## __name ## _fmask),\t\t\\\n\t\t.fmask  = reg_ ## __name ## _fmask,\t\t\t\\\n\t}\n\n \nstruct regs {\n\tu32 reg_count;\n\tconst struct reg **reg;\n};\n\nstatic inline const struct reg *reg(const struct regs *regs, u32 reg_id)\n{\n\tif (WARN(reg_id >= regs->reg_count,\n\t\t \"reg out of range (%u > %u)\\n\", reg_id, regs->reg_count - 1))\n\t\treturn NULL;\n\n\treturn regs->reg[reg_id];\n}\n\n \nstatic inline u32 reg_fmask(const struct reg *reg, u32 field_id)\n{\n\tif (!reg || WARN_ON(field_id >= reg->fcount))\n\t\treturn 0;\n\n\treturn reg->fmask[field_id];\n}\n\n \nstatic inline u32 reg_bit(const struct reg *reg, u32 field_id)\n{\n\tu32 fmask = reg_fmask(reg, field_id);\n\n\tif (WARN_ON(!is_power_of_2(fmask)))\n\t\treturn 0;\n\n\treturn fmask;\n}\n\n \nstatic inline u32 reg_field_max(const struct reg *reg, u32 field_id)\n{\n\tu32 fmask = reg_fmask(reg, field_id);\n\n\treturn fmask ? fmask >> __ffs(fmask) : 0;\n}\n\n \nstatic inline u32 reg_encode(const struct reg *reg, u32 field_id, u32 val)\n{\n\tu32 fmask = reg_fmask(reg, field_id);\n\n\tif (!fmask)\n\t\treturn 0;\n\n\tval <<= __ffs(fmask);\n\tif (WARN_ON(val & ~fmask))\n\t\treturn 0;\n\n\treturn val;\n}\n\n \nstatic inline u32 reg_decode(const struct reg *reg, u32 field_id, u32 val)\n{\n\tu32 fmask = reg_fmask(reg, field_id);\n\n\treturn fmask ? (val & fmask) >> __ffs(fmask) : 0;\n}\n\n \nstatic inline u32 reg_offset(const struct reg *reg)\n{\n\treturn reg ? reg->offset : 0;\n}\n\n \nstatic inline u32 reg_n_offset(const struct reg *reg, u32 n)\n{\n\treturn reg ? reg->offset + n * reg->stride : 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}