{
  "module_name": "ipa_interrupt.c",
  "hash_id": "f1e1305513f077af28c385f2e5bcafa5cfbca80f0effbdd968cca3069da861fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_interrupt.c",
  "human_readable_source": "\n\n \n\n \n\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n\n#include \"ipa.h\"\n#include \"ipa_reg.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_power.h\"\n#include \"ipa_uc.h\"\n#include \"ipa_interrupt.h\"\n\n \nstruct ipa_interrupt {\n\tstruct ipa *ipa;\n\tu32 irq;\n\tu32 enabled;\n};\n\n \nstatic void ipa_interrupt_process(struct ipa_interrupt *interrupt, u32 irq_id)\n{\n\tstruct ipa *ipa = interrupt->ipa;\n\tconst struct reg *reg;\n\tu32 mask = BIT(irq_id);\n\tu32 offset;\n\n\treg = ipa_reg(ipa, IPA_IRQ_CLR);\n\toffset = reg_offset(reg);\n\n\tswitch (irq_id) {\n\tcase IPA_IRQ_UC_0:\n\tcase IPA_IRQ_UC_1:\n\t\t \n\t\tiowrite32(mask, ipa->reg_virt + offset);\n\t\tipa_uc_interrupt_handler(ipa, irq_id);\n\t\tbreak;\n\n\tcase IPA_IRQ_TX_SUSPEND:\n\t\t \n\t\tipa_power_suspend_handler(ipa, irq_id);\n\t\tfallthrough;\n\n\tdefault:\t \n\t\tiowrite32(mask, ipa->reg_virt + offset);\n\t\tbreak;\n\t}\n}\n\n \nstatic irqreturn_t ipa_isr_thread(int irq, void *dev_id)\n{\n\tstruct ipa_interrupt *interrupt = dev_id;\n\tstruct ipa *ipa = interrupt->ipa;\n\tu32 enabled = interrupt->enabled;\n\tconst struct reg *reg;\n\tstruct device *dev;\n\tu32 pending;\n\tu32 offset;\n\tu32 mask;\n\tint ret;\n\n\tdev = &ipa->pdev->dev;\n\tret = pm_runtime_get_sync(dev);\n\tif (WARN_ON(ret < 0))\n\t\tgoto out_power_put;\n\n\t \n\treg = ipa_reg(ipa, IPA_IRQ_STTS);\n\toffset = reg_offset(reg);\n\tpending = ioread32(ipa->reg_virt + offset);\n\twhile ((mask = pending & enabled)) {\n\t\tdo {\n\t\t\tu32 irq_id = __ffs(mask);\n\n\t\t\tmask ^= BIT(irq_id);\n\n\t\t\tipa_interrupt_process(interrupt, irq_id);\n\t\t} while (mask);\n\t\tpending = ioread32(ipa->reg_virt + offset);\n\t}\n\n\t \n\tif (pending) {\n\t\tdev_dbg(dev, \"clearing disabled IPA interrupts 0x%08x\\n\",\n\t\t\tpending);\n\t\treg = ipa_reg(ipa, IPA_IRQ_CLR);\n\t\tiowrite32(pending, ipa->reg_virt + reg_offset(reg));\n\t}\nout_power_put:\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ipa_interrupt_enabled_update(struct ipa *ipa)\n{\n\tconst struct reg *reg = ipa_reg(ipa, IPA_IRQ_EN);\n\n\tiowrite32(ipa->interrupt->enabled, ipa->reg_virt + reg_offset(reg));\n}\n\n \nvoid ipa_interrupt_enable(struct ipa *ipa, enum ipa_irq_id ipa_irq)\n{\n\t \n\tipa->interrupt->enabled |= BIT(ipa_irq);\n\tipa_interrupt_enabled_update(ipa);\n}\n\n \nvoid ipa_interrupt_disable(struct ipa *ipa, enum ipa_irq_id ipa_irq)\n{\n\t \n\tipa->interrupt->enabled &= ~BIT(ipa_irq);\n\tipa_interrupt_enabled_update(ipa);\n}\n\nvoid ipa_interrupt_irq_disable(struct ipa *ipa)\n{\n\tdisable_irq(ipa->interrupt->irq);\n}\n\nvoid ipa_interrupt_irq_enable(struct ipa *ipa)\n{\n\tenable_irq(ipa->interrupt->irq);\n}\n\n \nstatic void ipa_interrupt_suspend_control(struct ipa_interrupt *interrupt,\n\t\t\t\t\t  u32 endpoint_id, bool enable)\n{\n\tstruct ipa *ipa = interrupt->ipa;\n\tu32 mask = BIT(endpoint_id % 32);\n\tu32 unit = endpoint_id / 32;\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 val;\n\n\tWARN_ON(!test_bit(endpoint_id, ipa->available));\n\n\t \n\tif (ipa->version == IPA_VERSION_3_0)\n\t\treturn;\n\n\treg = ipa_reg(ipa, IRQ_SUSPEND_EN);\n\toffset = reg_n_offset(reg, unit);\n\tval = ioread32(ipa->reg_virt + offset);\n\n\tif (enable)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\tiowrite32(val, ipa->reg_virt + offset);\n}\n\n \nvoid\nipa_interrupt_suspend_enable(struct ipa_interrupt *interrupt, u32 endpoint_id)\n{\n\tipa_interrupt_suspend_control(interrupt, endpoint_id, true);\n}\n\n \nvoid\nipa_interrupt_suspend_disable(struct ipa_interrupt *interrupt, u32 endpoint_id)\n{\n\tipa_interrupt_suspend_control(interrupt, endpoint_id, false);\n}\n\n \nvoid ipa_interrupt_suspend_clear_all(struct ipa_interrupt *interrupt)\n{\n\tstruct ipa *ipa = interrupt->ipa;\n\tu32 unit_count;\n\tu32 unit;\n\n\tunit_count = roundup(ipa->endpoint_count, 32);\n\tfor (unit = 0; unit < unit_count; unit++) {\n\t\tconst struct reg *reg;\n\t\tu32 val;\n\n\t\treg = ipa_reg(ipa, IRQ_SUSPEND_INFO);\n\t\tval = ioread32(ipa->reg_virt + reg_n_offset(reg, unit));\n\n\t\t \n\t\tif (ipa->version == IPA_VERSION_3_0)\n\t\t\tcontinue;\n\n\t\treg = ipa_reg(ipa, IRQ_SUSPEND_CLR);\n\t\tiowrite32(val, ipa->reg_virt + reg_n_offset(reg, unit));\n\t}\n}\n\n \nvoid ipa_interrupt_simulate_suspend(struct ipa_interrupt *interrupt)\n{\n\tipa_interrupt_process(interrupt, IPA_IRQ_TX_SUSPEND);\n}\n\n \nstruct ipa_interrupt *ipa_interrupt_config(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tstruct ipa_interrupt *interrupt;\n\tconst struct reg *reg;\n\tunsigned int irq;\n\tint ret;\n\n\tret = platform_get_irq_byname(ipa->pdev, \"ipa\");\n\tif (ret <= 0) {\n\t\tdev_err(dev, \"DT error %d getting \\\"ipa\\\" IRQ property\\n\",\n\t\t\tret);\n\t\treturn ERR_PTR(ret ? : -EINVAL);\n\t}\n\tirq = ret;\n\n\tinterrupt = kzalloc(sizeof(*interrupt), GFP_KERNEL);\n\tif (!interrupt)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinterrupt->ipa = ipa;\n\tinterrupt->irq = irq;\n\n\t \n\treg = ipa_reg(ipa, IPA_IRQ_EN);\n\tiowrite32(0, ipa->reg_virt + reg_offset(reg));\n\n\tret = request_threaded_irq(irq, NULL, ipa_isr_thread, IRQF_ONESHOT,\n\t\t\t\t   \"ipa\", interrupt);\n\tif (ret) {\n\t\tdev_err(dev, \"error %d requesting \\\"ipa\\\" IRQ\\n\", ret);\n\t\tgoto err_kfree;\n\t}\n\n\tret = dev_pm_set_wake_irq(dev, irq);\n\tif (ret) {\n\t\tdev_err(dev, \"error %d registering \\\"ipa\\\" IRQ as wakeirq\\n\", ret);\n\t\tgoto err_free_irq;\n\t}\n\n\treturn interrupt;\n\nerr_free_irq:\n\tfree_irq(interrupt->irq, interrupt);\nerr_kfree:\n\tkfree(interrupt);\n\n\treturn ERR_PTR(ret);\n}\n\n \nvoid ipa_interrupt_deconfig(struct ipa_interrupt *interrupt)\n{\n\tstruct device *dev = &interrupt->ipa->pdev->dev;\n\n\tdev_pm_clear_wake_irq(dev);\n\tfree_irq(interrupt->irq, interrupt);\n\tkfree(interrupt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}