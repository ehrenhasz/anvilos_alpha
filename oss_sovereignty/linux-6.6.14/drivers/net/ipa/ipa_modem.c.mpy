{
  "module_name": "ipa_modem.c",
  "hash_id": "67398f3bc914ab9ad02cd444a2479e337e9c19a3e84ef7f9a8f0babab9f980e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_modem.c",
  "human_readable_source": "\n\n \n\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_rmnet.h>\n#include <linux/etherdevice.h>\n#include <net/pkt_sched.h>\n#include <linux/pm_runtime.h>\n#include <linux/remoteproc/qcom_rproc.h>\n\n#include \"ipa.h\"\n#include \"ipa_data.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_table.h\"\n#include \"ipa_mem.h\"\n#include \"ipa_modem.h\"\n#include \"ipa_smp2p.h\"\n#include \"ipa_qmi.h\"\n#include \"ipa_uc.h\"\n#include \"ipa_power.h\"\n\n#define IPA_NETDEV_NAME\t\t\"rmnet_ipa%d\"\n#define IPA_NETDEV_TAILROOM\t0\t \n#define IPA_NETDEV_TIMEOUT\t10\t \n\nenum ipa_modem_state {\n\tIPA_MODEM_STATE_STOPPED\t= 0,\n\tIPA_MODEM_STATE_STARTING,\n\tIPA_MODEM_STATE_RUNNING,\n\tIPA_MODEM_STATE_STOPPING,\n};\n\n \nstruct ipa_priv {\n\tstruct ipa *ipa;\n\tstruct work_struct work;\n};\n\n \nstatic int ipa_open(struct net_device *netdev)\n{\n\tstruct ipa_priv *priv = netdev_priv(netdev);\n\tstruct ipa *ipa = priv->ipa;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ipa->pdev->dev;\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tgoto err_power_put;\n\n\tret = ipa_endpoint_enable_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]);\n\tif (ret)\n\t\tgoto err_power_put;\n\n\tret = ipa_endpoint_enable_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]);\n\tif (ret)\n\t\tgoto err_disable_tx;\n\n\tnetif_start_queue(netdev);\n\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_disable_tx:\n\tipa_endpoint_disable_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]);\nerr_power_put:\n\tpm_runtime_put_noidle(dev);\n\n\treturn ret;\n}\n\n \nstatic int ipa_stop(struct net_device *netdev)\n{\n\tstruct ipa_priv *priv = netdev_priv(netdev);\n\tstruct ipa *ipa = priv->ipa;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ipa->pdev->dev;\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tgoto out_power_put;\n\n\tnetif_stop_queue(netdev);\n\n\tipa_endpoint_disable_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]);\n\tipa_endpoint_disable_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]);\nout_power_put:\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t\nipa_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct ipa_priv *priv = netdev_priv(netdev);\n\tstruct ipa_endpoint *endpoint;\n\tstruct ipa *ipa = priv->ipa;\n\tu32 skb_len = skb->len;\n\tstruct device *dev;\n\tint ret;\n\n\tif (!skb_len)\n\t\tgoto err_drop_skb;\n\n\tendpoint = ipa->name_map[IPA_ENDPOINT_AP_MODEM_TX];\n\tif (endpoint->config.qmap && skb->protocol != htons(ETH_P_MAP))\n\t\tgoto err_drop_skb;\n\n\t \n\tdev = &ipa->pdev->dev;\n\tret = pm_runtime_get(dev);\n\tif (ret < 1) {\n\t\t \n\t\tif (ret < 0 && ret != -EINPROGRESS) {\n\t\t\tipa_power_modem_queue_active(ipa);\n\t\t\tpm_runtime_put_noidle(dev);\n\t\t\tgoto err_drop_skb;\n\t\t}\n\n\t\t \n\t\tipa_power_modem_queue_stop(ipa);\n\n\t\tpm_runtime_put_noidle(dev);\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tipa_power_modem_queue_active(ipa);\n\n\tret = ipa_endpoint_skb_tx(endpoint, skb);\n\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\n\tif (ret) {\n\t\tif (ret != -E2BIG)\n\t\t\treturn NETDEV_TX_BUSY;\n\t\tgoto err_drop_skb;\n\t}\n\n\tstats->tx_packets++;\n\tstats->tx_bytes += skb_len;\n\n\treturn NETDEV_TX_OK;\n\nerr_drop_skb:\n\tdev_kfree_skb_any(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nvoid ipa_modem_skb_rx(struct net_device *netdev, struct sk_buff *skb)\n{\n\tstruct net_device_stats *stats = &netdev->stats;\n\n\tif (skb) {\n\t\tskb->dev = netdev;\n\t\tskb->protocol = htons(ETH_P_MAP);\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\n\t\t(void)netif_receive_skb(skb);\n\t} else {\n\t\tstats->rx_dropped++;\n\t}\n}\n\nstatic const struct net_device_ops ipa_modem_ops = {\n\t.ndo_open\t= ipa_open,\n\t.ndo_stop\t= ipa_stop,\n\t.ndo_start_xmit\t= ipa_start_xmit,\n};\n\n \nstatic void ipa_modem_netdev_setup(struct net_device *netdev)\n{\n\tnetdev->netdev_ops = &ipa_modem_ops;\n\n\tnetdev->header_ops = NULL;\n\tnetdev->type = ARPHRD_RAWIP;\n\tnetdev->hard_header_len = 0;\n\tnetdev->min_header_len = ETH_HLEN;\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = IPA_MTU;\n\tnetdev->mtu = netdev->max_mtu;\n\tnetdev->addr_len = 0;\n\tnetdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;\n\tnetdev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);\n\tnetdev->priv_flags |= IFF_TX_SKB_SHARING;\n\teth_broadcast_addr(netdev->broadcast);\n\n\t \n\tnetdev->needed_headroom = sizeof(struct rmnet_map_header);\n\tnetdev->needed_tailroom = IPA_NETDEV_TAILROOM;\n\tnetdev->watchdog_timeo = IPA_NETDEV_TIMEOUT * HZ;\n\tnetdev->hw_features = NETIF_F_SG;\n}\n\n \nvoid ipa_modem_suspend(struct net_device *netdev)\n{\n\tstruct ipa_priv *priv = netdev_priv(netdev);\n\tstruct ipa *ipa = priv->ipa;\n\n\tif (!(netdev->flags & IFF_UP))\n\t\treturn;\n\n\tipa_endpoint_suspend_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]);\n\tipa_endpoint_suspend_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]);\n}\n\n \nstatic void ipa_modem_wake_queue_work(struct work_struct *work)\n{\n\tstruct ipa_priv *priv = container_of(work, struct ipa_priv, work);\n\n\tipa_power_modem_queue_wake(priv->ipa);\n}\n\n \nvoid ipa_modem_resume(struct net_device *netdev)\n{\n\tstruct ipa_priv *priv = netdev_priv(netdev);\n\tstruct ipa *ipa = priv->ipa;\n\n\tif (!(netdev->flags & IFF_UP))\n\t\treturn;\n\n\tipa_endpoint_resume_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]);\n\tipa_endpoint_resume_one(ipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]);\n\n\t \n\t(void)queue_pm_work(&priv->work);\n}\n\nint ipa_modem_start(struct ipa *ipa)\n{\n\tenum ipa_modem_state state;\n\tstruct net_device *netdev;\n\tstruct ipa_priv *priv;\n\tint ret;\n\n\t \n\tstate = atomic_cmpxchg(&ipa->modem_state, IPA_MODEM_STATE_STOPPED,\n\t\t\t       IPA_MODEM_STATE_STARTING);\n\n\t \n\tif (state != IPA_MODEM_STATE_STOPPED)\n\t\treturn 0;\n\n\tnetdev = alloc_netdev(sizeof(struct ipa_priv), IPA_NETDEV_NAME,\n\t\t\t      NET_NAME_UNKNOWN, ipa_modem_netdev_setup);\n\tif (!netdev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_set_state;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &ipa->pdev->dev);\n\tpriv = netdev_priv(netdev);\n\tpriv->ipa = ipa;\n\tINIT_WORK(&priv->work, ipa_modem_wake_queue_work);\n\tipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]->netdev = netdev;\n\tipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]->netdev = netdev;\n\tipa->modem_netdev = netdev;\n\n\tret = register_netdev(netdev);\n\tif (ret) {\n\t\tipa->modem_netdev = NULL;\n\t\tipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]->netdev = NULL;\n\t\tipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]->netdev = NULL;\n\t\tfree_netdev(netdev);\n\t}\n\nout_set_state:\n\tif (ret)\n\t\tatomic_set(&ipa->modem_state, IPA_MODEM_STATE_STOPPED);\n\telse\n\t\tatomic_set(&ipa->modem_state, IPA_MODEM_STATE_RUNNING);\n\tsmp_mb__after_atomic();\n\n\treturn ret;\n}\n\nint ipa_modem_stop(struct ipa *ipa)\n{\n\tstruct net_device *netdev = ipa->modem_netdev;\n\tenum ipa_modem_state state;\n\n\t \n\tstate = atomic_cmpxchg(&ipa->modem_state, IPA_MODEM_STATE_RUNNING,\n\t\t\t       IPA_MODEM_STATE_STOPPING);\n\n\t \n\tif (state == IPA_MODEM_STATE_STOPPED)\n\t\treturn 0;\n\n\t \n\tif (state != IPA_MODEM_STATE_RUNNING)\n\t\treturn -EBUSY;\n\n\t \n\tif (netdev) {\n\t\tstruct ipa_priv *priv = netdev_priv(netdev);\n\n\t\tcancel_work_sync(&priv->work);\n\t\t \n\t\tif (netdev->flags & IFF_UP)\n\t\t\t(void)ipa_stop(netdev);\n\t\tunregister_netdev(netdev);\n\t\tipa->modem_netdev = NULL;\n\t\tipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]->netdev = NULL;\n\t\tipa->name_map[IPA_ENDPOINT_AP_MODEM_TX]->netdev = NULL;\n\t\tfree_netdev(netdev);\n\t}\n\n\tatomic_set(&ipa->modem_state, IPA_MODEM_STATE_STOPPED);\n\tsmp_mb__after_atomic();\n\n\treturn 0;\n}\n\n \nstatic void ipa_modem_crashed(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tint ret;\n\n\t \n\tipa_smp2p_irq_disable_setup(ipa);\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error %d getting power to handle crash\\n\", ret);\n\t\tgoto out_power_put;\n\t}\n\n\tipa_endpoint_modem_pause_all(ipa, true);\n\n\tipa_endpoint_modem_hol_block_clear_all(ipa);\n\n\tipa_table_reset(ipa, true);\n\n\tret = ipa_table_hash_flush(ipa);\n\tif (ret)\n\t\tdev_err(dev, \"error %d flushing hash caches\\n\", ret);\n\n\tret = ipa_endpoint_modem_exception_reset_all(ipa);\n\tif (ret)\n\t\tdev_err(dev, \"error %d resetting exception endpoint\\n\", ret);\n\n\tipa_endpoint_modem_pause_all(ipa, false);\n\n\tret = ipa_modem_stop(ipa);\n\tif (ret)\n\t\tdev_err(dev, \"error %d stopping modem\\n\", ret);\n\n\t \n\tret = ipa_mem_zero_modem(ipa);\n\tif (ret)\n\t\tdev_err(dev, \"error %d zeroing modem memory regions\\n\", ret);\n\nout_power_put:\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n}\n\nstatic int ipa_modem_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t    void *data)\n{\n\tstruct ipa *ipa = container_of(nb, struct ipa, nb);\n\tstruct qcom_ssr_notify_data *notify_data = data;\n\tstruct device *dev = &ipa->pdev->dev;\n\n\tswitch (action) {\n\tcase QCOM_SSR_BEFORE_POWERUP:\n\t\tdev_info(dev, \"received modem starting event\\n\");\n\t\tipa_uc_power(ipa);\n\t\tipa_smp2p_notify_reset(ipa);\n\t\tbreak;\n\n\tcase QCOM_SSR_AFTER_POWERUP:\n\t\tdev_info(dev, \"received modem running event\\n\");\n\t\tbreak;\n\n\tcase QCOM_SSR_BEFORE_SHUTDOWN:\n\t\tdev_info(dev, \"received modem %s event\\n\",\n\t\t\t notify_data->crashed ? \"crashed\" : \"stopping\");\n\t\tif (ipa->setup_complete)\n\t\t\tipa_modem_crashed(ipa);\n\t\tbreak;\n\n\tcase QCOM_SSR_AFTER_SHUTDOWN:\n\t\tdev_info(dev, \"received modem offline event\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"received unrecognized event %lu\\n\", action);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nint ipa_modem_config(struct ipa *ipa)\n{\n\tvoid *notifier;\n\n\tipa->nb.notifier_call = ipa_modem_notify;\n\n\tnotifier = qcom_register_ssr_notifier(\"mpss\", &ipa->nb);\n\tif (IS_ERR(notifier))\n\t\treturn PTR_ERR(notifier);\n\n\tipa->notifier = notifier;\n\n\treturn 0;\n}\n\nvoid ipa_modem_deconfig(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tint ret;\n\n\tret = qcom_unregister_ssr_notifier(ipa->notifier, &ipa->nb);\n\tif (ret)\n\t\tdev_err(dev, \"error %d unregistering notifier\", ret);\n\n\tipa->notifier = NULL;\n\tmemset(&ipa->nb, 0, sizeof(ipa->nb));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}