{
  "module_name": "gsi_trans.c",
  "hash_id": "baa26089e28dbb90f4c34e4fb0da580b7b38f08ce02d5a587a43229a81f6fa05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/gsi_trans.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/refcount.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-direction.h>\n\n#include \"gsi.h\"\n#include \"gsi_private.h\"\n#include \"gsi_trans.h\"\n#include \"ipa_gsi.h\"\n#include \"ipa_data.h\"\n#include \"ipa_cmd.h\"\n\n \n\n \nenum gsi_tre_type {\n\tGSI_RE_XFER\t= 0x2,\n\tGSI_RE_IMMD_CMD\t= 0x3,\n};\n\n \nstruct gsi_tre {\n\t__le64 addr;\t\t \n\t__le16 len_opcode;\t \n\t__le16 reserved;\n\t__le32 flags;\t\t \n};\n\n \n#define TRE_FLAGS_CHAIN_FMASK\tGENMASK(0, 0)\n#define TRE_FLAGS_IEOT_FMASK\tGENMASK(9, 9)\n#define TRE_FLAGS_BEI_FMASK\tGENMASK(10, 10)\n#define TRE_FLAGS_TYPE_FMASK\tGENMASK(23, 16)\n\nint gsi_trans_pool_init(struct gsi_trans_pool *pool, size_t size, u32 count,\n\t\t\tu32 max_alloc)\n{\n\tsize_t alloc_size;\n\tvoid *virt;\n\n\tif (!size)\n\t\treturn -EINVAL;\n\tif (count < max_alloc)\n\t\treturn -EINVAL;\n\tif (!max_alloc)\n\t\treturn -EINVAL;\n\n\t \n\talloc_size = size_mul(count + max_alloc - 1, size);\n\talloc_size = kmalloc_size_roundup(alloc_size);\n\tvirt = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!virt)\n\t\treturn -ENOMEM;\n\n\tpool->base = virt;\n\t \n\tpool->count = alloc_size / size;\n\tpool->free = 0;\n\tpool->max_alloc = max_alloc;\n\tpool->size = size;\n\tpool->addr = 0;\t\t \n\n\treturn 0;\n}\n\nvoid gsi_trans_pool_exit(struct gsi_trans_pool *pool)\n{\n\tkfree(pool->base);\n\tmemset(pool, 0, sizeof(*pool));\n}\n\n \nint gsi_trans_pool_init_dma(struct device *dev, struct gsi_trans_pool *pool,\n\t\t\t    size_t size, u32 count, u32 max_alloc)\n{\n\tsize_t total_size;\n\tdma_addr_t addr;\n\tvoid *virt;\n\n\tif (!size)\n\t\treturn -EINVAL;\n\tif (count < max_alloc)\n\t\treturn -EINVAL;\n\tif (!max_alloc)\n\t\treturn -EINVAL;\n\n\t \n\tsize = __roundup_pow_of_two(size);\n\ttotal_size = (count + max_alloc - 1) * size;\n\n\t \n\ttotal_size = PAGE_SIZE << get_order(total_size);\n\n\tvirt = dma_alloc_coherent(dev, total_size, &addr, GFP_KERNEL);\n\tif (!virt)\n\t\treturn -ENOMEM;\n\n\tpool->base = virt;\n\tpool->count = total_size / size;\n\tpool->free = 0;\n\tpool->size = size;\n\tpool->max_alloc = max_alloc;\n\tpool->addr = addr;\n\n\treturn 0;\n}\n\nvoid gsi_trans_pool_exit_dma(struct device *dev, struct gsi_trans_pool *pool)\n{\n\tsize_t total_size = pool->count * pool->size;\n\n\tdma_free_coherent(dev, total_size, pool->base, pool->addr);\n\tmemset(pool, 0, sizeof(*pool));\n}\n\n \nstatic u32 gsi_trans_pool_alloc_common(struct gsi_trans_pool *pool, u32 count)\n{\n\tu32 offset;\n\n\tWARN_ON(!count);\n\tWARN_ON(count > pool->max_alloc);\n\n\t \n\tif (count > pool->count - pool->free)\n\t\tpool->free = 0;\n\n\toffset = pool->free * pool->size;\n\tpool->free += count;\n\tmemset(pool->base + offset, 0, count * pool->size);\n\n\treturn offset;\n}\n\n \nvoid *gsi_trans_pool_alloc(struct gsi_trans_pool *pool, u32 count)\n{\n\treturn pool->base + gsi_trans_pool_alloc_common(pool, count);\n}\n\n \nvoid *gsi_trans_pool_alloc_dma(struct gsi_trans_pool *pool, dma_addr_t *addr)\n{\n\tu32 offset = gsi_trans_pool_alloc_common(pool, 1);\n\n\t*addr = pool->addr + offset;\n\n\treturn pool->base + offset;\n}\n\n \nstatic void gsi_trans_map(struct gsi_trans *trans, u32 index)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\n\t \n\tindex += trans->used_count - 1;\n\n\t \n\tchannel->trans_info.map[index % channel->tre_ring.count] = trans;\n}\n\n \nstruct gsi_trans *\ngsi_channel_trans_mapped(struct gsi_channel *channel, u32 index)\n{\n\t \n\treturn channel->trans_info.map[index % channel->tre_ring.count];\n}\n\n \nstruct gsi_trans *gsi_channel_trans_complete(struct gsi_channel *channel)\n{\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tu16 trans_id = trans_info->completed_id;\n\n\tif (trans_id == trans_info->pending_id) {\n\t\tgsi_channel_update(channel);\n\t\tif (trans_id == trans_info->pending_id)\n\t\t\treturn NULL;\n\t}\n\n\treturn &trans_info->trans[trans_id %= channel->tre_count];\n}\n\n \nstatic void gsi_trans_move_committed(struct gsi_trans *trans)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\n\t \n\ttrans_info->allocated_id++;\n}\n\n \nstatic void gsi_trans_move_pending(struct gsi_trans *trans)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tu16 trans_index = trans - &trans_info->trans[0];\n\tu16 delta;\n\n\t \n\tdelta = trans_index - trans_info->committed_id + 1;\n\ttrans_info->committed_id += delta % channel->tre_count;\n}\n\n \nvoid gsi_trans_move_complete(struct gsi_trans *trans)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tu16 trans_index = trans - trans_info->trans;\n\tu16 delta;\n\n\t \n\tdelta = trans_index - trans_info->pending_id + 1;\n\tdelta %= channel->tre_count;\n\ttrans_info->pending_id += delta;\n}\n\n \nvoid gsi_trans_move_polled(struct gsi_trans *trans)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\n\t \n\ttrans_info->completed_id++;\n}\n\n \nstatic bool\ngsi_trans_tre_reserve(struct gsi_trans_info *trans_info, u32 tre_count)\n{\n\tint avail = atomic_read(&trans_info->tre_avail);\n\tint new;\n\n\tdo {\n\t\tnew = avail - (int)tre_count;\n\t\tif (unlikely(new < 0))\n\t\t\treturn false;\n\t} while (!atomic_try_cmpxchg(&trans_info->tre_avail, &avail, new));\n\n\treturn true;\n}\n\n \nstatic void\ngsi_trans_tre_release(struct gsi_trans_info *trans_info, u32 tre_count)\n{\n\tatomic_add(tre_count, &trans_info->tre_avail);\n}\n\n \nbool gsi_channel_trans_idle(struct gsi *gsi, u32 channel_id)\n{\n\tu32 tre_max = gsi_channel_tre_max(gsi, channel_id);\n\tstruct gsi_trans_info *trans_info;\n\n\ttrans_info = &gsi->channel[channel_id].trans_info;\n\n\treturn atomic_read(&trans_info->tre_avail) == tre_max;\n}\n\n \nstruct gsi_trans *gsi_channel_trans_alloc(struct gsi *gsi, u32 channel_id,\n\t\t\t\t\t  u32 tre_count,\n\t\t\t\t\t  enum dma_data_direction direction)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tstruct gsi_trans_info *trans_info;\n\tstruct gsi_trans *trans;\n\tu16 trans_index;\n\n\tif (WARN_ON(tre_count > channel->trans_tre_max))\n\t\treturn NULL;\n\n\ttrans_info = &channel->trans_info;\n\n\t \n\tif (!gsi_trans_tre_reserve(trans_info, tre_count))\n\t\treturn NULL;\n\n\ttrans_index = trans_info->free_id % channel->tre_count;\n\ttrans = &trans_info->trans[trans_index];\n\tmemset(trans, 0, sizeof(*trans));\n\n\t \n\ttrans->gsi = gsi;\n\ttrans->channel_id = channel_id;\n\ttrans->rsvd_count = tre_count;\n\tinit_completion(&trans->completion);\n\n\t \n\ttrans->sgl = gsi_trans_pool_alloc(&trans_info->sg_pool, tre_count);\n\tsg_init_marker(trans->sgl, tre_count);\n\n\ttrans->direction = direction;\n\trefcount_set(&trans->refcount, 1);\n\n\t \n\ttrans_info->free_id++;\n\n\treturn trans;\n}\n\n \nvoid gsi_trans_free(struct gsi_trans *trans)\n{\n\tstruct gsi_trans_info *trans_info;\n\n\tif (!refcount_dec_and_test(&trans->refcount))\n\t\treturn;\n\n\t \n\ttrans_info = &trans->gsi->channel[trans->channel_id].trans_info;\n\tif (!trans->used_count) {\n\t\ttrans_info->allocated_id++;\n\t\ttrans_info->committed_id++;\n\t\ttrans_info->pending_id++;\n\t\ttrans_info->completed_id++;\n\t} else {\n\t\tipa_gsi_trans_release(trans);\n\t}\n\n\t \n\ttrans_info->polled_id++;\n\n\t \n\tgsi_trans_tre_release(trans_info, trans->rsvd_count);\n}\n\n \nvoid gsi_trans_cmd_add(struct gsi_trans *trans, void *buf, u32 size,\n\t\t       dma_addr_t addr, enum ipa_cmd_opcode opcode)\n{\n\tu32 which = trans->used_count++;\n\tstruct scatterlist *sg;\n\n\tWARN_ON(which >= trans->rsvd_count);\n\n\t \n\tsg = &trans->sgl[which];\n\tsg_assign_page(sg, NULL);\n\tsg_dma_address(sg) = addr;\n\tsg_dma_len(sg) = size;\n\n\ttrans->cmd_opcode[which] = opcode;\n}\n\n \nint gsi_trans_page_add(struct gsi_trans *trans, struct page *page, u32 size,\n\t\t       u32 offset)\n{\n\tstruct scatterlist *sg = &trans->sgl[0];\n\tint ret;\n\n\tif (WARN_ON(trans->rsvd_count != 1))\n\t\treturn -EINVAL;\n\tif (WARN_ON(trans->used_count))\n\t\treturn -EINVAL;\n\n\tsg_set_page(sg, page, size, offset);\n\tret = dma_map_sg(trans->gsi->dev, sg, 1, trans->direction);\n\tif (!ret)\n\t\treturn -ENOMEM;\n\n\ttrans->used_count++;\t \n\n\treturn 0;\n}\n\n \nint gsi_trans_skb_add(struct gsi_trans *trans, struct sk_buff *skb)\n{\n\tstruct scatterlist *sg = &trans->sgl[0];\n\tu32 used_count;\n\tint ret;\n\n\tif (WARN_ON(trans->rsvd_count != 1))\n\t\treturn -EINVAL;\n\tif (WARN_ON(trans->used_count))\n\t\treturn -EINVAL;\n\n\t \n\tret = skb_to_sgvec(skb, sg, 0, skb->len);\n\tif (ret < 0)\n\t\treturn ret;\n\tused_count = ret;\n\n\tret = dma_map_sg(trans->gsi->dev, sg, used_count, trans->direction);\n\tif (!ret)\n\t\treturn -ENOMEM;\n\n\t \n\ttrans->used_count += used_count;\n\n\treturn 0;\n}\n\n \nstatic __le16 gsi_tre_len_opcode(enum ipa_cmd_opcode opcode, u32 len)\n{\n\treturn opcode == IPA_CMD_NONE ? cpu_to_le16((u16)len)\n\t\t\t\t      : cpu_to_le16((u16)opcode);\n}\n\n \nstatic __le32 gsi_tre_flags(bool last_tre, bool bei, enum ipa_cmd_opcode opcode)\n{\n\tenum gsi_tre_type tre_type;\n\tu32 tre_flags;\n\n\ttre_type = opcode == IPA_CMD_NONE ? GSI_RE_XFER : GSI_RE_IMMD_CMD;\n\ttre_flags = u32_encode_bits(tre_type, TRE_FLAGS_TYPE_FMASK);\n\n\t \n\tif (last_tre) {\n\t\t \n\t\ttre_flags |= TRE_FLAGS_IEOT_FMASK;\n\t\t \n\t\tif (bei)\n\t\t\ttre_flags |= TRE_FLAGS_BEI_FMASK;\n\t} else {\t \n\t\ttre_flags |= TRE_FLAGS_CHAIN_FMASK;\n\t}\n\n\treturn cpu_to_le32(tre_flags);\n}\n\nstatic void gsi_trans_tre_fill(struct gsi_tre *dest_tre, dma_addr_t addr,\n\t\t\t       u32 len, bool last_tre, bool bei,\n\t\t\t       enum ipa_cmd_opcode opcode)\n{\n\tstruct gsi_tre tre;\n\n\ttre.addr = cpu_to_le64(addr);\n\ttre.len_opcode = gsi_tre_len_opcode(opcode, len);\n\ttre.reserved = 0;\n\ttre.flags = gsi_tre_flags(last_tre, bei, opcode);\n\n\t \n\t*dest_tre = tre;\n}\n\n \nstatic void __gsi_trans_commit(struct gsi_trans *trans, bool ring_db)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\tstruct gsi_ring *tre_ring = &channel->tre_ring;\n\tenum ipa_cmd_opcode opcode = IPA_CMD_NONE;\n\tbool bei = channel->toward_ipa;\n\tstruct gsi_tre *dest_tre;\n\tstruct scatterlist *sg;\n\tu32 byte_count = 0;\n\tu8 *cmd_opcode;\n\tu32 avail;\n\tu32 i;\n\n\tWARN_ON(!trans->used_count);\n\n\t \n\tcmd_opcode = channel->command ? &trans->cmd_opcode[0] : NULL;\n\tavail = tre_ring->count - tre_ring->index % tre_ring->count;\n\tdest_tre = gsi_ring_virt(tre_ring, tre_ring->index);\n\tfor_each_sg(trans->sgl, sg, trans->used_count, i) {\n\t\tbool last_tre = i == trans->used_count - 1;\n\t\tdma_addr_t addr = sg_dma_address(sg);\n\t\tu32 len = sg_dma_len(sg);\n\n\t\tbyte_count += len;\n\t\tif (!avail--)\n\t\t\tdest_tre = gsi_ring_virt(tre_ring, 0);\n\t\tif (cmd_opcode)\n\t\t\topcode = *cmd_opcode++;\n\n\t\tgsi_trans_tre_fill(dest_tre, addr, len, last_tre, bei, opcode);\n\t\tdest_tre++;\n\t}\n\t \n\tgsi_trans_map(trans, tre_ring->index);\n\n\ttre_ring->index += trans->used_count;\n\n\ttrans->len = byte_count;\n\tif (channel->toward_ipa)\n\t\tgsi_trans_tx_committed(trans);\n\n\tgsi_trans_move_committed(trans);\n\n\t \n\tif (ring_db || !atomic_read(&channel->trans_info.tre_avail)) {\n\t\t \n\t\tif (channel->toward_ipa)\n\t\t\tgsi_trans_tx_queued(trans);\n\t\tgsi_trans_move_pending(trans);\n\t\tgsi_channel_doorbell(channel);\n\t}\n}\n\n \nvoid gsi_trans_commit(struct gsi_trans *trans, bool ring_db)\n{\n\tif (trans->used_count)\n\t\t__gsi_trans_commit(trans, ring_db);\n\telse\n\t\tgsi_trans_free(trans);\n}\n\n \nvoid gsi_trans_commit_wait(struct gsi_trans *trans)\n{\n\tif (!trans->used_count)\n\t\tgoto out_trans_free;\n\n\trefcount_inc(&trans->refcount);\n\n\t__gsi_trans_commit(trans, true);\n\n\twait_for_completion(&trans->completion);\n\nout_trans_free:\n\tgsi_trans_free(trans);\n}\n\n \nvoid gsi_trans_complete(struct gsi_trans *trans)\n{\n\t \n\tif (trans->direction != DMA_NONE)\n\t\tdma_unmap_sg(trans->gsi->dev, trans->sgl, trans->used_count,\n\t\t\t     trans->direction);\n\n\tipa_gsi_trans_complete(trans);\n\n\tcomplete(&trans->completion);\n\n\tgsi_trans_free(trans);\n}\n\n \nvoid gsi_channel_trans_cancel_pending(struct gsi_channel *channel)\n{\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tu16 trans_id = trans_info->pending_id;\n\n\t \n\n\t \n\tif (trans_id == trans_info->committed_id)\n\t\treturn;\n\n\t \n\tdo {\n\t\tstruct gsi_trans *trans;\n\n\t\ttrans = &trans_info->trans[trans_id % channel->tre_count];\n\t\ttrans->cancelled = true;\n\t} while (++trans_id != trans_info->committed_id);\n\n\t \n\ttrans_info->pending_id = trans_info->committed_id;\n\n\t \n\tnapi_schedule(&channel->napi);\n}\n\n \nint gsi_trans_read_byte(struct gsi *gsi, u32 channel_id, dma_addr_t addr)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tstruct gsi_ring *tre_ring = &channel->tre_ring;\n\tstruct gsi_trans_info *trans_info;\n\tstruct gsi_tre *dest_tre;\n\n\ttrans_info = &channel->trans_info;\n\n\t \n\tif (!gsi_trans_tre_reserve(trans_info, 1))\n\t\treturn -EBUSY;\n\n\t \n\n\tdest_tre = gsi_ring_virt(tre_ring, tre_ring->index);\n\tgsi_trans_tre_fill(dest_tre, addr, 1, true, false, IPA_CMD_NONE);\n\n\ttre_ring->index++;\n\tgsi_channel_doorbell(channel);\n\n\treturn 0;\n}\n\n \nvoid gsi_trans_read_byte_done(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\n\tgsi_trans_tre_release(&channel->trans_info, 1);\n}\n\n \nint gsi_channel_trans_init(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tu32 tre_count = channel->tre_count;\n\tstruct gsi_trans_info *trans_info;\n\tu32 tre_max;\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(sizeof(struct gsi_tre) != GSI_RING_ELEMENT_SIZE);\n\n\ttrans_info = &channel->trans_info;\n\n\t \n\ttre_max = gsi_channel_tre_max(channel->gsi, channel_id);\n\tatomic_set(&trans_info->tre_avail, tre_max);\n\n\t \n\ttrans_info->trans = kcalloc(tre_count, sizeof(*trans_info->trans),\n\t\t\t\t    GFP_KERNEL);\n\tif (!trans_info->trans)\n\t\treturn -ENOMEM;\n\ttrans_info->free_id = 0;\t \n\ttrans_info->allocated_id = 0;\n\ttrans_info->committed_id = 0;\n\ttrans_info->pending_id = 0;\n\ttrans_info->completed_id = 0;\n\ttrans_info->polled_id = 0;\n\n\t \n\ttrans_info->map = kcalloc(tre_count, sizeof(*trans_info->map),\n\t\t\t\t  GFP_KERNEL);\n\tif (!trans_info->map) {\n\t\tret = -ENOMEM;\n\t\tgoto err_trans_free;\n\t}\n\n\t \n\tret = gsi_trans_pool_init(&trans_info->sg_pool,\n\t\t\t\t  sizeof(struct scatterlist),\n\t\t\t\t  tre_max, channel->trans_tre_max);\n\tif (ret)\n\t\tgoto err_map_free;\n\n\n\treturn 0;\n\nerr_map_free:\n\tkfree(trans_info->map);\nerr_trans_free:\n\tkfree(trans_info->trans);\n\n\tdev_err(gsi->dev, \"error %d initializing channel %u transactions\\n\",\n\t\tret, channel_id);\n\n\treturn ret;\n}\n\n \nvoid gsi_channel_trans_exit(struct gsi_channel *channel)\n{\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\n\tgsi_trans_pool_exit(&trans_info->sg_pool);\n\tkfree(trans_info->trans);\n\tkfree(trans_info->map);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}