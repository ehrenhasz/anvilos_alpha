{
  "module_name": "gsi.c",
  "hash_id": "0df58b4ee368c64ca40e02fe44a0f025ff150d82665fb39ef814b8ad660f5a55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/gsi.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/io.h>\n#include <linux/bug.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n\n#include \"gsi.h\"\n#include \"reg.h\"\n#include \"gsi_reg.h\"\n#include \"gsi_private.h\"\n#include \"gsi_trans.h\"\n#include \"ipa_gsi.h\"\n#include \"ipa_data.h\"\n#include \"ipa_version.h\"\n\n \n\n \n#define GSI_EVT_RING_INT_MODT\t\t(32 * 1)  \n\n#define GSI_CMD_TIMEOUT\t\t\t50\t \n\n#define GSI_CHANNEL_STOP_RETRIES\t10\n#define GSI_CHANNEL_MODEM_HALT_RETRIES\t10\n#define GSI_CHANNEL_MODEM_FLOW_RETRIES\t5\t \n\n#define GSI_MHI_EVENT_ID_START\t\t10\t \n#define GSI_MHI_EVENT_ID_END\t\t16\t \n\n#define GSI_ISR_MAX_ITER\t\t50\t \n\n \nstruct gsi_event {\n\t__le64 xfer_ptr;\n\t__le16 len;\n\tu8 reserved1;\n\tu8 code;\n\t__le16 reserved2;\n\tu8 type;\n\tu8 chid;\n};\n\n \nstruct gsi_channel_scratch_gpi {\n\tu64 reserved1;\n\tu16 reserved2;\n\tu16 max_outstanding_tre;\n\tu16 reserved3;\n\tu16 outstanding_threshold;\n};\n\n \nunion gsi_channel_scratch {\n\tstruct gsi_channel_scratch_gpi gpi;\n\tstruct {\n\t\tu32 word1;\n\t\tu32 word2;\n\t\tu32 word3;\n\t\tu32 word4;\n\t} data;\n};\n\n \nstatic void gsi_validate_build(void)\n{\n\t \n\tBUILD_BUG_ON(!GSI_RING_ELEMENT_SIZE);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct gsi_event) != GSI_RING_ELEMENT_SIZE);\n\n\t \n\tBUILD_BUG_ON(!is_power_of_2(GSI_RING_ELEMENT_SIZE));\n}\n\n \nstatic u32 gsi_channel_id(struct gsi_channel *channel)\n{\n\treturn channel - &channel->gsi->channel[0];\n}\n\n \nstatic bool gsi_channel_initialized(struct gsi_channel *channel)\n{\n\treturn !!channel->gsi;\n}\n\n \nstatic u32 ch_c_cntxt_0_type_encode(enum ipa_version version,\n\t\t\t\t    const struct reg *reg,\n\t\t\t\t    enum gsi_channel_type type)\n{\n\tu32 val;\n\n\tval = reg_encode(reg, CHTYPE_PROTOCOL, type);\n\tif (version < IPA_VERSION_4_5 || version >= IPA_VERSION_5_0)\n\t\treturn val;\n\n\ttype >>= hweight32(reg_fmask(reg, CHTYPE_PROTOCOL));\n\n\treturn val | reg_encode(reg, CHTYPE_PROTOCOL_MSB, type);\n}\n\n \nstatic void gsi_irq_type_update(struct gsi *gsi, u32 val)\n{\n\tconst struct reg *reg = gsi_reg(gsi, CNTXT_TYPE_IRQ_MSK);\n\n\tgsi->type_enabled_bitmap = val;\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n}\n\nstatic void gsi_irq_type_enable(struct gsi *gsi, enum gsi_irq_type_id type_id)\n{\n\tgsi_irq_type_update(gsi, gsi->type_enabled_bitmap | type_id);\n}\n\nstatic void gsi_irq_type_disable(struct gsi *gsi, enum gsi_irq_type_id type_id)\n{\n\tgsi_irq_type_update(gsi, gsi->type_enabled_bitmap & ~type_id);\n}\n\n \nstatic void gsi_irq_ev_ctrl_enable(struct gsi *gsi, u32 evt_ring_id)\n{\n\tu32 val = BIT(evt_ring_id);\n\tconst struct reg *reg;\n\n\t \n\treg = gsi_reg(gsi, CNTXT_SRC_EV_CH_IRQ_CLR);\n\tiowrite32(~0, gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_SRC_EV_CH_IRQ_MSK);\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\tgsi_irq_type_enable(gsi, GSI_EV_CTRL);\n}\n\n \nstatic void gsi_irq_ev_ctrl_disable(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\n\tgsi_irq_type_disable(gsi, GSI_EV_CTRL);\n\n\treg = gsi_reg(gsi, CNTXT_SRC_EV_CH_IRQ_MSK);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n}\n\n \nstatic void gsi_irq_ch_ctrl_enable(struct gsi *gsi, u32 channel_id)\n{\n\tu32 val = BIT(channel_id);\n\tconst struct reg *reg;\n\n\t \n\treg = gsi_reg(gsi, CNTXT_SRC_CH_IRQ_CLR);\n\tiowrite32(~0, gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_SRC_CH_IRQ_MSK);\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\n\tgsi_irq_type_enable(gsi, GSI_CH_CTRL);\n}\n\n \nstatic void gsi_irq_ch_ctrl_disable(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\n\tgsi_irq_type_disable(gsi, GSI_CH_CTRL);\n\n\treg = gsi_reg(gsi, CNTXT_SRC_CH_IRQ_MSK);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n}\n\nstatic void gsi_irq_ieob_enable_one(struct gsi *gsi, u32 evt_ring_id)\n{\n\tbool enable_ieob = !gsi->ieob_enabled_bitmap;\n\tconst struct reg *reg;\n\tu32 val;\n\n\tgsi->ieob_enabled_bitmap |= BIT(evt_ring_id);\n\n\treg = gsi_reg(gsi, CNTXT_SRC_IEOB_IRQ_MSK);\n\tval = gsi->ieob_enabled_bitmap;\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\n\t \n\tif (enable_ieob)\n\t\tgsi_irq_type_enable(gsi, GSI_IEOB);\n}\n\nstatic void gsi_irq_ieob_disable(struct gsi *gsi, u32 event_mask)\n{\n\tconst struct reg *reg;\n\tu32 val;\n\n\tgsi->ieob_enabled_bitmap &= ~event_mask;\n\n\t \n\tif (!gsi->ieob_enabled_bitmap)\n\t\tgsi_irq_type_disable(gsi, GSI_IEOB);\n\n\treg = gsi_reg(gsi, CNTXT_SRC_IEOB_IRQ_MSK);\n\tval = gsi->ieob_enabled_bitmap;\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n}\n\nstatic void gsi_irq_ieob_disable_one(struct gsi *gsi, u32 evt_ring_id)\n{\n\tgsi_irq_ieob_disable(gsi, BIT(evt_ring_id));\n}\n\n \nstatic void gsi_irq_enable(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 val;\n\n\t \n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_EN);\n\tiowrite32(ERROR_INT, gsi->virt + reg_offset(reg));\n\n\tgsi_irq_type_update(gsi, gsi->type_enabled_bitmap | GSI_GLOB_EE);\n\n\t \n\treg = gsi_reg(gsi, CNTXT_GSI_IRQ_EN);\n\tval = BUS_ERROR;\n\tval |= CMD_FIFO_OVRFLOW;\n\tval |= MCS_STACK_OVRFLOW;\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\n\tgsi_irq_type_update(gsi, gsi->type_enabled_bitmap | GSI_GENERAL);\n}\n\n \nstatic void gsi_irq_disable(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\n\tgsi_irq_type_update(gsi, 0);\n\n\t \n\treg = gsi_reg(gsi, CNTXT_GSI_IRQ_EN);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_EN);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n}\n\n \nvoid *gsi_ring_virt(struct gsi_ring *ring, u32 index)\n{\n\t \n\treturn ring->virt + (index % ring->count) * GSI_RING_ELEMENT_SIZE;\n}\n\n \nstatic u32 gsi_ring_addr(struct gsi_ring *ring, u32 index)\n{\n\treturn lower_32_bits(ring->addr) + index * GSI_RING_ELEMENT_SIZE;\n}\n\n \nstatic u32 gsi_ring_index(struct gsi_ring *ring, u32 offset)\n{\n\treturn (offset - gsi_ring_addr(ring, 0)) / GSI_RING_ELEMENT_SIZE;\n}\n\n \nstatic bool gsi_command(struct gsi *gsi, u32 reg, u32 val)\n{\n\tunsigned long timeout = msecs_to_jiffies(GSI_CMD_TIMEOUT);\n\tstruct completion *completion = &gsi->completion;\n\n\treinit_completion(completion);\n\n\tiowrite32(val, gsi->virt + reg);\n\n\treturn !!wait_for_completion_timeout(completion, timeout);\n}\n\n \nstatic enum gsi_evt_ring_state\ngsi_evt_ring_state(struct gsi *gsi, u32 evt_ring_id)\n{\n\tconst struct reg *reg = gsi_reg(gsi, EV_CH_E_CNTXT_0);\n\tu32 val;\n\n\tval = ioread32(gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\treturn reg_decode(reg, EV_CHSTATE, val);\n}\n\n \nstatic void gsi_evt_ring_command(struct gsi *gsi, u32 evt_ring_id,\n\t\t\t\t enum gsi_evt_cmd_opcode opcode)\n{\n\tstruct device *dev = gsi->dev;\n\tconst struct reg *reg;\n\tbool timeout;\n\tu32 val;\n\n\t \n\tgsi_irq_ev_ctrl_enable(gsi, evt_ring_id);\n\n\treg = gsi_reg(gsi, EV_CH_CMD);\n\tval = reg_encode(reg, EV_CHID, evt_ring_id);\n\tval |= reg_encode(reg, EV_OPCODE, opcode);\n\n\ttimeout = !gsi_command(gsi, reg_offset(reg), val);\n\n\tgsi_irq_ev_ctrl_disable(gsi);\n\n\tif (!timeout)\n\t\treturn;\n\n\tdev_err(dev, \"GSI command %u for event ring %u timed out, state %u\\n\",\n\t\topcode, evt_ring_id, gsi_evt_ring_state(gsi, evt_ring_id));\n}\n\n \nstatic int gsi_evt_ring_alloc_command(struct gsi *gsi, u32 evt_ring_id)\n{\n\tenum gsi_evt_ring_state state;\n\n\t \n\tstate = gsi_evt_ring_state(gsi, evt_ring_id);\n\tif (state != GSI_EVT_RING_STATE_NOT_ALLOCATED) {\n\t\tdev_err(gsi->dev, \"event ring %u bad state %u before alloc\\n\",\n\t\t\tevt_ring_id, state);\n\t\treturn -EINVAL;\n\t}\n\n\tgsi_evt_ring_command(gsi, evt_ring_id, GSI_EVT_ALLOCATE);\n\n\t \n\tstate = gsi_evt_ring_state(gsi, evt_ring_id);\n\tif (state == GSI_EVT_RING_STATE_ALLOCATED)\n\t\treturn 0;\n\n\tdev_err(gsi->dev, \"event ring %u bad state %u after alloc\\n\",\n\t\tevt_ring_id, state);\n\n\treturn -EIO;\n}\n\n \nstatic void gsi_evt_ring_reset_command(struct gsi *gsi, u32 evt_ring_id)\n{\n\tenum gsi_evt_ring_state state;\n\n\tstate = gsi_evt_ring_state(gsi, evt_ring_id);\n\tif (state != GSI_EVT_RING_STATE_ALLOCATED &&\n\t    state != GSI_EVT_RING_STATE_ERROR) {\n\t\tdev_err(gsi->dev, \"event ring %u bad state %u before reset\\n\",\n\t\t\tevt_ring_id, state);\n\t\treturn;\n\t}\n\n\tgsi_evt_ring_command(gsi, evt_ring_id, GSI_EVT_RESET);\n\n\t \n\tstate = gsi_evt_ring_state(gsi, evt_ring_id);\n\tif (state == GSI_EVT_RING_STATE_ALLOCATED)\n\t\treturn;\n\n\tdev_err(gsi->dev, \"event ring %u bad state %u after reset\\n\",\n\t\tevt_ring_id, state);\n}\n\n \nstatic void gsi_evt_ring_de_alloc_command(struct gsi *gsi, u32 evt_ring_id)\n{\n\tenum gsi_evt_ring_state state;\n\n\tstate = gsi_evt_ring_state(gsi, evt_ring_id);\n\tif (state != GSI_EVT_RING_STATE_ALLOCATED) {\n\t\tdev_err(gsi->dev, \"event ring %u state %u before dealloc\\n\",\n\t\t\tevt_ring_id, state);\n\t\treturn;\n\t}\n\n\tgsi_evt_ring_command(gsi, evt_ring_id, GSI_EVT_DE_ALLOC);\n\n\t \n\tstate = gsi_evt_ring_state(gsi, evt_ring_id);\n\tif (state == GSI_EVT_RING_STATE_NOT_ALLOCATED)\n\t\treturn;\n\n\tdev_err(gsi->dev, \"event ring %u bad state %u after dealloc\\n\",\n\t\tevt_ring_id, state);\n}\n\n \nstatic enum gsi_channel_state gsi_channel_state(struct gsi_channel *channel)\n{\n\tconst struct reg *reg = gsi_reg(channel->gsi, CH_C_CNTXT_0);\n\tu32 channel_id = gsi_channel_id(channel);\n\tstruct gsi *gsi = channel->gsi;\n\tvoid __iomem *virt = gsi->virt;\n\tu32 val;\n\n\treg = gsi_reg(gsi, CH_C_CNTXT_0);\n\tval = ioread32(virt + reg_n_offset(reg, channel_id));\n\n\treturn reg_decode(reg, CHSTATE, val);\n}\n\n \nstatic void\ngsi_channel_command(struct gsi_channel *channel, enum gsi_ch_cmd_opcode opcode)\n{\n\tu32 channel_id = gsi_channel_id(channel);\n\tstruct gsi *gsi = channel->gsi;\n\tstruct device *dev = gsi->dev;\n\tconst struct reg *reg;\n\tbool timeout;\n\tu32 val;\n\n\t \n\tgsi_irq_ch_ctrl_enable(gsi, channel_id);\n\n\treg = gsi_reg(gsi, CH_CMD);\n\tval = reg_encode(reg, CH_CHID, channel_id);\n\tval |= reg_encode(reg, CH_OPCODE, opcode);\n\n\ttimeout = !gsi_command(gsi, reg_offset(reg), val);\n\n\tgsi_irq_ch_ctrl_disable(gsi);\n\n\tif (!timeout)\n\t\treturn;\n\n\tdev_err(dev, \"GSI command %u for channel %u timed out, state %u\\n\",\n\t\topcode, channel_id, gsi_channel_state(channel));\n}\n\n \nstatic int gsi_channel_alloc_command(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tstruct device *dev = gsi->dev;\n\tenum gsi_channel_state state;\n\n\t \n\tstate = gsi_channel_state(channel);\n\tif (state != GSI_CHANNEL_STATE_NOT_ALLOCATED) {\n\t\tdev_err(dev, \"channel %u bad state %u before alloc\\n\",\n\t\t\tchannel_id, state);\n\t\treturn -EINVAL;\n\t}\n\n\tgsi_channel_command(channel, GSI_CH_ALLOCATE);\n\n\t \n\tstate = gsi_channel_state(channel);\n\tif (state == GSI_CHANNEL_STATE_ALLOCATED)\n\t\treturn 0;\n\n\tdev_err(dev, \"channel %u bad state %u after alloc\\n\",\n\t\tchannel_id, state);\n\n\treturn -EIO;\n}\n\n \nstatic int gsi_channel_start_command(struct gsi_channel *channel)\n{\n\tstruct device *dev = channel->gsi->dev;\n\tenum gsi_channel_state state;\n\n\tstate = gsi_channel_state(channel);\n\tif (state != GSI_CHANNEL_STATE_ALLOCATED &&\n\t    state != GSI_CHANNEL_STATE_STOPPED) {\n\t\tdev_err(dev, \"channel %u bad state %u before start\\n\",\n\t\t\tgsi_channel_id(channel), state);\n\t\treturn -EINVAL;\n\t}\n\n\tgsi_channel_command(channel, GSI_CH_START);\n\n\t \n\tstate = gsi_channel_state(channel);\n\tif (state == GSI_CHANNEL_STATE_STARTED)\n\t\treturn 0;\n\n\tdev_err(dev, \"channel %u bad state %u after start\\n\",\n\t\tgsi_channel_id(channel), state);\n\n\treturn -EIO;\n}\n\n \nstatic int gsi_channel_stop_command(struct gsi_channel *channel)\n{\n\tstruct device *dev = channel->gsi->dev;\n\tenum gsi_channel_state state;\n\n\tstate = gsi_channel_state(channel);\n\n\t \n\tif (state == GSI_CHANNEL_STATE_STOPPED)\n\t\treturn 0;\n\n\tif (state != GSI_CHANNEL_STATE_STARTED &&\n\t    state != GSI_CHANNEL_STATE_STOP_IN_PROC) {\n\t\tdev_err(dev, \"channel %u bad state %u before stop\\n\",\n\t\t\tgsi_channel_id(channel), state);\n\t\treturn -EINVAL;\n\t}\n\n\tgsi_channel_command(channel, GSI_CH_STOP);\n\n\t \n\tstate = gsi_channel_state(channel);\n\tif (state == GSI_CHANNEL_STATE_STOPPED)\n\t\treturn 0;\n\n\t \n\tif (state == GSI_CHANNEL_STATE_STOP_IN_PROC)\n\t\treturn -EAGAIN;\n\n\tdev_err(dev, \"channel %u bad state %u after stop\\n\",\n\t\tgsi_channel_id(channel), state);\n\n\treturn -EIO;\n}\n\n \nstatic void gsi_channel_reset_command(struct gsi_channel *channel)\n{\n\tstruct device *dev = channel->gsi->dev;\n\tenum gsi_channel_state state;\n\n\t \n\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\n\tstate = gsi_channel_state(channel);\n\tif (state != GSI_CHANNEL_STATE_STOPPED &&\n\t    state != GSI_CHANNEL_STATE_ERROR) {\n\t\t \n\t\tif (state != GSI_CHANNEL_STATE_ALLOCATED)\n\t\t\tdev_err(dev, \"channel %u bad state %u before reset\\n\",\n\t\t\t\tgsi_channel_id(channel), state);\n\t\treturn;\n\t}\n\n\tgsi_channel_command(channel, GSI_CH_RESET);\n\n\t \n\tstate = gsi_channel_state(channel);\n\tif (state != GSI_CHANNEL_STATE_ALLOCATED)\n\t\tdev_err(dev, \"channel %u bad state %u after reset\\n\",\n\t\t\tgsi_channel_id(channel), state);\n}\n\n \nstatic void gsi_channel_de_alloc_command(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tstruct device *dev = gsi->dev;\n\tenum gsi_channel_state state;\n\n\tstate = gsi_channel_state(channel);\n\tif (state != GSI_CHANNEL_STATE_ALLOCATED) {\n\t\tdev_err(dev, \"channel %u bad state %u before dealloc\\n\",\n\t\t\tchannel_id, state);\n\t\treturn;\n\t}\n\n\tgsi_channel_command(channel, GSI_CH_DE_ALLOC);\n\n\t \n\tstate = gsi_channel_state(channel);\n\n\tif (state != GSI_CHANNEL_STATE_NOT_ALLOCATED)\n\t\tdev_err(dev, \"channel %u bad state %u after dealloc\\n\",\n\t\t\tchannel_id, state);\n}\n\n \nstatic void gsi_evt_ring_doorbell(struct gsi *gsi, u32 evt_ring_id, u32 index)\n{\n\tconst struct reg *reg = gsi_reg(gsi, EV_CH_E_DOORBELL_0);\n\tstruct gsi_ring *ring = &gsi->evt_ring[evt_ring_id].ring;\n\tu32 val;\n\n\tring->index = index;\t \n\n\t \n\tval = gsi_ring_addr(ring, (index - 1) % ring->count);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, evt_ring_id));\n}\n\n \nstatic void gsi_evt_ring_program(struct gsi *gsi, u32 evt_ring_id)\n{\n\tstruct gsi_evt_ring *evt_ring = &gsi->evt_ring[evt_ring_id];\n\tstruct gsi_ring *ring = &evt_ring->ring;\n\tconst struct reg *reg;\n\tu32 val;\n\n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_0);\n\t \n\tval = reg_encode(reg, EV_CHTYPE, GSI_CHANNEL_TYPE_GPI);\n\t \n\tval |= reg_bit(reg, EV_INTYPE);\n\tval |= reg_encode(reg, EV_ELEMENT_SIZE, GSI_RING_ELEMENT_SIZE);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_1);\n\tval = reg_encode(reg, R_LENGTH, ring->count * GSI_RING_ELEMENT_SIZE);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\t \n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_2);\n\tval = lower_32_bits(ring->addr);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_3);\n\tval = upper_32_bits(ring->addr);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\t \n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_8);\n\tval = reg_encode(reg, EV_MODT, GSI_EVT_RING_INT_MODT);\n\tval |= reg_encode(reg, EV_MODC, 1);\t \n\t \n\tiowrite32(val, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\t \n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_9);\n\tiowrite32(0, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_10);\n\tiowrite32(0, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_11);\n\tiowrite32(0, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\t \n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_12);\n\tiowrite32(0, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_13);\n\tiowrite32(0, gsi->virt + reg_n_offset(reg, evt_ring_id));\n\n\t \n\tgsi_evt_ring_doorbell(gsi, evt_ring_id, ring->index);\n}\n\n \nstatic struct gsi_trans *gsi_channel_trans_last(struct gsi_channel *channel)\n{\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tu32 pending_id = trans_info->pending_id;\n\tstruct gsi_trans *trans;\n\tu16 trans_id;\n\n\tif (channel->toward_ipa && pending_id != trans_info->free_id) {\n\t\t \n\t\ttrans_id = trans_info->free_id - 1;\n\t} else if (trans_info->polled_id != pending_id) {\n\t\t \n\t\ttrans_id = pending_id - 1;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t \n\ttrans = &trans_info->trans[trans_id % channel->tre_count];\n\trefcount_inc(&trans->refcount);\n\n\treturn trans;\n}\n\n \nstatic void gsi_channel_trans_quiesce(struct gsi_channel *channel)\n{\n\tstruct gsi_trans *trans;\n\n\t \n\ttrans = gsi_channel_trans_last(channel);\n\tif (trans) {\n\t\twait_for_completion(&trans->completion);\n\t\tgsi_trans_free(trans);\n\t}\n}\n\n \nstatic void gsi_channel_program(struct gsi_channel *channel, bool doorbell)\n{\n\tsize_t size = channel->tre_ring.count * GSI_RING_ELEMENT_SIZE;\n\tu32 channel_id = gsi_channel_id(channel);\n\tunion gsi_channel_scratch scr = { };\n\tstruct gsi_channel_scratch_gpi *gpi;\n\tstruct gsi *gsi = channel->gsi;\n\tconst struct reg *reg;\n\tu32 wrr_weight = 0;\n\tu32 offset;\n\tu32 val;\n\n\treg = gsi_reg(gsi, CH_C_CNTXT_0);\n\n\t \n\tval = ch_c_cntxt_0_type_encode(gsi->version, reg, GSI_CHANNEL_TYPE_GPI);\n\tif (channel->toward_ipa)\n\t\tval |= reg_bit(reg, CHTYPE_DIR);\n\tif (gsi->version < IPA_VERSION_5_0)\n\t\tval |= reg_encode(reg, ERINDEX, channel->evt_ring_id);\n\tval |= reg_encode(reg, ELEMENT_SIZE, GSI_RING_ELEMENT_SIZE);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\treg = gsi_reg(gsi, CH_C_CNTXT_1);\n\tval = reg_encode(reg, CH_R_LENGTH, size);\n\tif (gsi->version >= IPA_VERSION_5_0)\n\t\tval |= reg_encode(reg, CH_ERINDEX, channel->evt_ring_id);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\t \n\treg = gsi_reg(gsi, CH_C_CNTXT_2);\n\tval = lower_32_bits(channel->tre_ring.addr);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\treg = gsi_reg(gsi, CH_C_CNTXT_3);\n\tval = upper_32_bits(channel->tre_ring.addr);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\treg = gsi_reg(gsi, CH_C_QOS);\n\n\t \n\tif (channel->command)\n\t\twrr_weight = reg_field_max(reg, WRR_WEIGHT);\n\tval = reg_encode(reg, WRR_WEIGHT, wrr_weight);\n\n\t \n\n\t \n\tif (gsi->version < IPA_VERSION_4_0 && doorbell)\n\t\tval |= reg_bit(reg, USE_DB_ENG);\n\n\t \n\tif (gsi->version >= IPA_VERSION_4_0 && !channel->command) {\n\t\t \n\t\tif (gsi->version < IPA_VERSION_4_5)\n\t\t\tval |= reg_bit(reg, USE_ESCAPE_BUF_ONLY);\n\t\telse\n\t\t\tval |= reg_encode(reg, PREFETCH_MODE, ESCAPE_BUF_ONLY);\n\t}\n\t \n\tif (gsi->version >= IPA_VERSION_4_9)\n\t\tval |= reg_bit(reg, DB_IN_BYTES);\n\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\t \n\tgpi = &scr.gpi;\n\tgpi->max_outstanding_tre = channel->trans_tre_max *\n\t\t\t\t\tGSI_RING_ELEMENT_SIZE;\n\tgpi->outstanding_threshold = 2 * GSI_RING_ELEMENT_SIZE;\n\n\treg = gsi_reg(gsi, CH_C_SCRATCH_0);\n\tval = scr.data.word1;\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\treg = gsi_reg(gsi, CH_C_SCRATCH_1);\n\tval = scr.data.word2;\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\treg = gsi_reg(gsi, CH_C_SCRATCH_2);\n\tval = scr.data.word3;\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n\n\t \n\treg = gsi_reg(gsi, CH_C_SCRATCH_3);\n\toffset = reg_n_offset(reg, channel_id);\n\tval = ioread32(gsi->virt + offset);\n\tval = (scr.data.word4 & GENMASK(31, 16)) | (val & GENMASK(15, 0));\n\tiowrite32(val, gsi->virt + offset);\n\n\t \n}\n\nstatic int __gsi_channel_start(struct gsi_channel *channel, bool resume)\n{\n\tstruct gsi *gsi = channel->gsi;\n\tint ret;\n\n\t \n\tif (resume && gsi->version < IPA_VERSION_4_0)\n\t\treturn 0;\n\n\tmutex_lock(&gsi->mutex);\n\n\tret = gsi_channel_start_command(channel);\n\n\tmutex_unlock(&gsi->mutex);\n\n\treturn ret;\n}\n\n \nint gsi_channel_start(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tint ret;\n\n\t \n\tnapi_enable(&channel->napi);\n\tgsi_irq_ieob_enable_one(gsi, channel->evt_ring_id);\n\n\tret = __gsi_channel_start(channel, false);\n\tif (ret) {\n\t\tgsi_irq_ieob_disable_one(gsi, channel->evt_ring_id);\n\t\tnapi_disable(&channel->napi);\n\t}\n\n\treturn ret;\n}\n\nstatic int gsi_channel_stop_retry(struct gsi_channel *channel)\n{\n\tu32 retries = GSI_CHANNEL_STOP_RETRIES;\n\tint ret;\n\n\tdo {\n\t\tret = gsi_channel_stop_command(channel);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\tusleep_range(3 * USEC_PER_MSEC, 5 * USEC_PER_MSEC);\n\t} while (retries--);\n\n\treturn ret;\n}\n\nstatic int __gsi_channel_stop(struct gsi_channel *channel, bool suspend)\n{\n\tstruct gsi *gsi = channel->gsi;\n\tint ret;\n\n\t \n\tgsi_channel_trans_quiesce(channel);\n\n\t \n\tif (suspend && gsi->version < IPA_VERSION_4_0)\n\t\treturn 0;\n\n\tmutex_lock(&gsi->mutex);\n\n\tret = gsi_channel_stop_retry(channel);\n\n\tmutex_unlock(&gsi->mutex);\n\n\treturn ret;\n}\n\n \nint gsi_channel_stop(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tint ret;\n\n\tret = __gsi_channel_stop(channel, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgsi_irq_ieob_disable_one(gsi, channel->evt_ring_id);\n\tnapi_disable(&channel->napi);\n\n\treturn 0;\n}\n\n \nvoid gsi_channel_reset(struct gsi *gsi, u32 channel_id, bool doorbell)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\n\tmutex_lock(&gsi->mutex);\n\n\tgsi_channel_reset_command(channel);\n\t \n\tif (gsi->version < IPA_VERSION_4_0 && !channel->toward_ipa)\n\t\tgsi_channel_reset_command(channel);\n\n\t \n\tchannel->tre_ring.index = 0;\n\tgsi_channel_program(channel, doorbell);\n\tgsi_channel_trans_cancel_pending(channel);\n\n\tmutex_unlock(&gsi->mutex);\n}\n\n \nint gsi_channel_suspend(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tint ret;\n\n\tret = __gsi_channel_stop(channel, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnapi_synchronize(&channel->napi);\n\n\treturn 0;\n}\n\n \nint gsi_channel_resume(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\n\treturn __gsi_channel_start(channel, true);\n}\n\n \nvoid gsi_suspend(struct gsi *gsi)\n{\n\tdisable_irq(gsi->irq);\n}\n\n \nvoid gsi_resume(struct gsi *gsi)\n{\n\tenable_irq(gsi->irq);\n}\n\nvoid gsi_trans_tx_committed(struct gsi_trans *trans)\n{\n\tstruct gsi_channel *channel = &trans->gsi->channel[trans->channel_id];\n\n\tchannel->trans_count++;\n\tchannel->byte_count += trans->len;\n\n\ttrans->trans_count = channel->trans_count;\n\ttrans->byte_count = channel->byte_count;\n}\n\nvoid gsi_trans_tx_queued(struct gsi_trans *trans)\n{\n\tu32 channel_id = trans->channel_id;\n\tstruct gsi *gsi = trans->gsi;\n\tstruct gsi_channel *channel;\n\tu32 trans_count;\n\tu32 byte_count;\n\n\tchannel = &gsi->channel[channel_id];\n\n\tbyte_count = channel->byte_count - channel->queued_byte_count;\n\ttrans_count = channel->trans_count - channel->queued_trans_count;\n\tchannel->queued_byte_count = channel->byte_count;\n\tchannel->queued_trans_count = channel->trans_count;\n\n\tipa_gsi_channel_tx_queued(gsi, channel_id, trans_count, byte_count);\n}\n\n \nstatic void gsi_trans_tx_completed(struct gsi_trans *trans)\n{\n\tu32 channel_id = trans->channel_id;\n\tstruct gsi *gsi = trans->gsi;\n\tstruct gsi_channel *channel;\n\tu32 trans_count;\n\tu32 byte_count;\n\n\tchannel = &gsi->channel[channel_id];\n\ttrans_count = trans->trans_count - channel->compl_trans_count;\n\tbyte_count = trans->byte_count - channel->compl_byte_count;\n\n\tchannel->compl_trans_count += trans_count;\n\tchannel->compl_byte_count += byte_count;\n\n\tipa_gsi_channel_tx_completed(gsi, channel_id, trans_count, byte_count);\n}\n\n \nstatic void gsi_isr_chan_ctrl(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 channel_mask;\n\n\treg = gsi_reg(gsi, CNTXT_SRC_CH_IRQ);\n\tchannel_mask = ioread32(gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_SRC_CH_IRQ_CLR);\n\tiowrite32(channel_mask, gsi->virt + reg_offset(reg));\n\n\twhile (channel_mask) {\n\t\tu32 channel_id = __ffs(channel_mask);\n\n\t\tchannel_mask ^= BIT(channel_id);\n\n\t\tcomplete(&gsi->completion);\n\t}\n}\n\n \nstatic void gsi_isr_evt_ctrl(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 event_mask;\n\n\treg = gsi_reg(gsi, CNTXT_SRC_EV_CH_IRQ);\n\tevent_mask = ioread32(gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_SRC_EV_CH_IRQ_CLR);\n\tiowrite32(event_mask, gsi->virt + reg_offset(reg));\n\n\twhile (event_mask) {\n\t\tu32 evt_ring_id = __ffs(event_mask);\n\n\t\tevent_mask ^= BIT(evt_ring_id);\n\n\t\tcomplete(&gsi->completion);\n\t}\n}\n\n \nstatic void\ngsi_isr_glob_chan_err(struct gsi *gsi, u32 err_ee, u32 channel_id, u32 code)\n{\n\tif (code == GSI_OUT_OF_RESOURCES) {\n\t\tdev_err(gsi->dev, \"channel %u out of resources\\n\", channel_id);\n\t\tcomplete(&gsi->completion);\n\t\treturn;\n\t}\n\n\t \n\tdev_err(gsi->dev, \"channel %u global error ee 0x%08x code 0x%08x\\n\",\n\t\tchannel_id, err_ee, code);\n}\n\n \nstatic void\ngsi_isr_glob_evt_err(struct gsi *gsi, u32 err_ee, u32 evt_ring_id, u32 code)\n{\n\tif (code == GSI_OUT_OF_RESOURCES) {\n\t\tstruct gsi_evt_ring *evt_ring = &gsi->evt_ring[evt_ring_id];\n\t\tu32 channel_id = gsi_channel_id(evt_ring->channel);\n\n\t\tcomplete(&gsi->completion);\n\t\tdev_err(gsi->dev, \"evt_ring for channel %u out of resources\\n\",\n\t\t\tchannel_id);\n\t\treturn;\n\t}\n\n\t \n\tdev_err(gsi->dev, \"event ring %u global error ee %u code 0x%08x\\n\",\n\t\tevt_ring_id, err_ee, code);\n}\n\n \nstatic void gsi_isr_glob_err(struct gsi *gsi)\n{\n\tconst struct reg *log_reg;\n\tconst struct reg *clr_reg;\n\tenum gsi_err_type type;\n\tenum gsi_err_code code;\n\tu32 offset;\n\tu32 which;\n\tu32 val;\n\tu32 ee;\n\n\t \n\tlog_reg = gsi_reg(gsi, ERROR_LOG);\n\toffset = reg_offset(log_reg);\n\tval = ioread32(gsi->virt + offset);\n\tiowrite32(0, gsi->virt + offset);\n\n\tclr_reg = gsi_reg(gsi, ERROR_LOG_CLR);\n\tiowrite32(~0, gsi->virt + reg_offset(clr_reg));\n\n\t \n\tee = reg_decode(log_reg, ERR_EE, val);\n\ttype = reg_decode(log_reg, ERR_TYPE, val);\n\twhich = reg_decode(log_reg, ERR_VIRT_IDX, val);\n\tcode = reg_decode(log_reg, ERR_CODE, val);\n\n\tif (type == GSI_ERR_TYPE_CHAN)\n\t\tgsi_isr_glob_chan_err(gsi, ee, which, code);\n\telse if (type == GSI_ERR_TYPE_EVT)\n\t\tgsi_isr_glob_evt_err(gsi, ee, which, code);\n\telse\t \n\t\tdev_err(gsi->dev, \"unexpected global error 0x%08x\\n\", type);\n}\n\n \nstatic void gsi_isr_gp_int1(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 result;\n\tu32 val;\n\n\t \n\treg = gsi_reg(gsi, CNTXT_SCRATCH_0);\n\tval = ioread32(gsi->virt + reg_offset(reg));\n\tresult = reg_decode(reg, GENERIC_EE_RESULT, val);\n\n\tswitch (result) {\n\tcase GENERIC_EE_SUCCESS:\n\tcase GENERIC_EE_INCORRECT_CHANNEL_STATE:\n\t\tgsi->result = 0;\n\t\tbreak;\n\n\tcase GENERIC_EE_RETRY:\n\t\tgsi->result = -EAGAIN;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(gsi->dev, \"global INT1 generic result %u\\n\", result);\n\t\tgsi->result = -EIO;\n\t\tbreak;\n\t}\n\n\tcomplete(&gsi->completion);\n}\n\n \nstatic void gsi_isr_glob_ee(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 val;\n\n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_STTS);\n\tval = ioread32(gsi->virt + reg_offset(reg));\n\n\tif (val & ERROR_INT)\n\t\tgsi_isr_glob_err(gsi);\n\n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_CLR);\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\n\tval &= ~ERROR_INT;\n\n\tif (val & GP_INT1) {\n\t\tval ^= GP_INT1;\n\t\tgsi_isr_gp_int1(gsi);\n\t}\n\n\tif (val)\n\t\tdev_err(gsi->dev, \"unexpected global interrupt 0x%08x\\n\", val);\n}\n\n \nstatic void gsi_isr_ieob(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 event_mask;\n\n\treg = gsi_reg(gsi, CNTXT_SRC_IEOB_IRQ);\n\tevent_mask = ioread32(gsi->virt + reg_offset(reg));\n\n\tgsi_irq_ieob_disable(gsi, event_mask);\n\n\treg = gsi_reg(gsi, CNTXT_SRC_IEOB_IRQ_CLR);\n\tiowrite32(event_mask, gsi->virt + reg_offset(reg));\n\n\twhile (event_mask) {\n\t\tu32 evt_ring_id = __ffs(event_mask);\n\n\t\tevent_mask ^= BIT(evt_ring_id);\n\n\t\tnapi_schedule(&gsi->evt_ring[evt_ring_id].channel->napi);\n\t}\n}\n\n \nstatic void gsi_isr_general(struct gsi *gsi)\n{\n\tstruct device *dev = gsi->dev;\n\tconst struct reg *reg;\n\tu32 val;\n\n\treg = gsi_reg(gsi, CNTXT_GSI_IRQ_STTS);\n\tval = ioread32(gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_GSI_IRQ_CLR);\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\n\tdev_err(dev, \"unexpected general interrupt 0x%08x\\n\", val);\n}\n\n \nstatic irqreturn_t gsi_isr(int irq, void *dev_id)\n{\n\tstruct gsi *gsi = dev_id;\n\tconst struct reg *reg;\n\tu32 intr_mask;\n\tu32 cnt = 0;\n\tu32 offset;\n\n\treg = gsi_reg(gsi, CNTXT_TYPE_IRQ);\n\toffset = reg_offset(reg);\n\n\t \n\twhile ((intr_mask = ioread32(gsi->virt + offset))) {\n\t\t \n\t\tdo {\n\t\t\tu32 gsi_intr = BIT(__ffs(intr_mask));\n\n\t\t\tintr_mask ^= gsi_intr;\n\n\t\t\t \n\t\t\tswitch (gsi_intr) {\n\t\t\tcase GSI_CH_CTRL:\n\t\t\t\tgsi_isr_chan_ctrl(gsi);\n\t\t\t\tbreak;\n\t\t\tcase GSI_EV_CTRL:\n\t\t\t\tgsi_isr_evt_ctrl(gsi);\n\t\t\t\tbreak;\n\t\t\tcase GSI_GLOB_EE:\n\t\t\t\tgsi_isr_glob_ee(gsi);\n\t\t\t\tbreak;\n\t\t\tcase GSI_IEOB:\n\t\t\t\tgsi_isr_ieob(gsi);\n\t\t\t\tbreak;\n\t\t\tcase GSI_GENERAL:\n\t\t\t\tgsi_isr_general(gsi);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(gsi->dev,\n\t\t\t\t\t\"unrecognized interrupt type 0x%08x\\n\",\n\t\t\t\t\tgsi_intr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (intr_mask);\n\n\t\tif (++cnt > GSI_ISR_MAX_ITER) {\n\t\t\tdev_err(gsi->dev, \"interrupt flood\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int gsi_irq_init(struct gsi *gsi, struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = platform_get_irq_byname(pdev, \"gsi\");\n\tif (ret <= 0)\n\t\treturn ret ? : -EINVAL;\n\n\tgsi->irq = ret;\n\n\treturn 0;\n}\n\n \nstatic struct gsi_trans *\ngsi_event_trans(struct gsi *gsi, struct gsi_event *event)\n{\n\tu32 channel_id = event->chid;\n\tstruct gsi_channel *channel;\n\tstruct gsi_trans *trans;\n\tu32 tre_offset;\n\tu32 tre_index;\n\n\tchannel = &gsi->channel[channel_id];\n\tif (WARN(!channel->gsi, \"event has bad channel %u\\n\", channel_id))\n\t\treturn NULL;\n\n\t \n\ttre_offset = lower_32_bits(le64_to_cpu(event->xfer_ptr));\n\ttre_index = gsi_ring_index(&channel->tre_ring, tre_offset);\n\n\ttrans = gsi_channel_trans_mapped(channel, tre_index);\n\n\tif (WARN(!trans, \"channel %u event with no transaction\\n\", channel_id))\n\t\treturn NULL;\n\n\treturn trans;\n}\n\n \nstatic void gsi_evt_ring_update(struct gsi *gsi, u32 evt_ring_id, u32 index)\n{\n\tstruct gsi_evt_ring *evt_ring = &gsi->evt_ring[evt_ring_id];\n\tstruct gsi_ring *ring = &evt_ring->ring;\n\tstruct gsi_event *event_done;\n\tstruct gsi_event *event;\n\tu32 event_avail;\n\tu32 old_index;\n\n\t \n\told_index = ring->index;\n\tevent = gsi_ring_virt(ring, old_index);\n\n\t \n\tevent_avail = ring->count - old_index % ring->count;\n\tevent_done = gsi_ring_virt(ring, index);\n\tdo {\n\t\tstruct gsi_trans *trans;\n\n\t\ttrans = gsi_event_trans(gsi, event);\n\t\tif (!trans)\n\t\t\treturn;\n\n\t\tif (trans->direction == DMA_FROM_DEVICE)\n\t\t\ttrans->len = __le16_to_cpu(event->len);\n\t\telse\n\t\t\tgsi_trans_tx_completed(trans);\n\n\t\tgsi_trans_move_complete(trans);\n\n\t\t \n\t\tif (--event_avail)\n\t\t\tevent++;\n\t\telse\n\t\t\tevent = gsi_ring_virt(ring, 0);\n\t} while (event != event_done);\n\n\t \n\tgsi_evt_ring_doorbell(gsi, evt_ring_id, index);\n}\n\n \nstatic int gsi_ring_alloc(struct gsi *gsi, struct gsi_ring *ring, u32 count)\n{\n\tu32 size = count * GSI_RING_ELEMENT_SIZE;\n\tstruct device *dev = gsi->dev;\n\tdma_addr_t addr;\n\n\t \n\tring->virt = dma_alloc_coherent(dev, size, &addr, GFP_KERNEL);\n\tif (!ring->virt)\n\t\treturn -ENOMEM;\n\n\tring->addr = addr;\n\tring->count = count;\n\tring->index = 0;\n\n\treturn 0;\n}\n\n \nstatic void gsi_ring_free(struct gsi *gsi, struct gsi_ring *ring)\n{\n\tsize_t size = ring->count * GSI_RING_ELEMENT_SIZE;\n\n\tdma_free_coherent(gsi->dev, size, ring->virt, ring->addr);\n}\n\n \nstatic int gsi_evt_ring_id_alloc(struct gsi *gsi)\n{\n\tu32 evt_ring_id;\n\n\tif (gsi->event_bitmap == ~0U) {\n\t\tdev_err(gsi->dev, \"event rings exhausted\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tevt_ring_id = ffz(gsi->event_bitmap);\n\tgsi->event_bitmap |= BIT(evt_ring_id);\n\n\treturn (int)evt_ring_id;\n}\n\n \nstatic void gsi_evt_ring_id_free(struct gsi *gsi, u32 evt_ring_id)\n{\n\tgsi->event_bitmap &= ~BIT(evt_ring_id);\n}\n\n \nvoid gsi_channel_doorbell(struct gsi_channel *channel)\n{\n\tstruct gsi_ring *tre_ring = &channel->tre_ring;\n\tu32 channel_id = gsi_channel_id(channel);\n\tstruct gsi *gsi = channel->gsi;\n\tconst struct reg *reg;\n\tu32 val;\n\n\treg = gsi_reg(gsi, CH_C_DOORBELL_0);\n\t \n\tval = gsi_ring_addr(tre_ring, tre_ring->index % tre_ring->count);\n\tiowrite32(val, gsi->virt + reg_n_offset(reg, channel_id));\n}\n\n \nvoid gsi_channel_update(struct gsi_channel *channel)\n{\n\tu32 evt_ring_id = channel->evt_ring_id;\n\tstruct gsi *gsi = channel->gsi;\n\tstruct gsi_evt_ring *evt_ring;\n\tstruct gsi_trans *trans;\n\tstruct gsi_ring *ring;\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 index;\n\n\tevt_ring = &gsi->evt_ring[evt_ring_id];\n\tring = &evt_ring->ring;\n\n\t \n\treg = gsi_reg(gsi, EV_CH_E_CNTXT_4);\n\toffset = reg_n_offset(reg, evt_ring_id);\n\tindex = gsi_ring_index(ring, ioread32(gsi->virt + offset));\n\tif (index == ring->index % ring->count)\n\t\treturn;\n\n\t \n\ttrans = gsi_event_trans(gsi, gsi_ring_virt(ring, index - 1));\n\tif (!trans)\n\t\treturn;\n\n\t \n\tgsi_evt_ring_update(gsi, evt_ring_id, index);\n}\n\n \nstatic struct gsi_trans *gsi_channel_poll_one(struct gsi_channel *channel)\n{\n\tstruct gsi_trans *trans;\n\n\t \n\ttrans = gsi_channel_trans_complete(channel);\n\tif (trans)\n\t\tgsi_trans_move_polled(trans);\n\n\treturn trans;\n}\n\n \nstatic int gsi_channel_poll(struct napi_struct *napi, int budget)\n{\n\tstruct gsi_channel *channel;\n\tint count;\n\n\tchannel = container_of(napi, struct gsi_channel, napi);\n\tfor (count = 0; count < budget; count++) {\n\t\tstruct gsi_trans *trans;\n\n\t\ttrans = gsi_channel_poll_one(channel);\n\t\tif (!trans)\n\t\t\tbreak;\n\t\tgsi_trans_complete(trans);\n\t}\n\n\tif (count < budget && napi_complete(napi))\n\t\tgsi_irq_ieob_enable_one(channel->gsi, channel->evt_ring_id);\n\n\treturn count;\n}\n\n \nstatic u32 gsi_event_bitmap_init(u32 evt_ring_max)\n{\n\tu32 event_bitmap = GENMASK(BITS_PER_LONG - 1, evt_ring_max);\n\n\tevent_bitmap |= GENMASK(GSI_MHI_EVENT_ID_END, GSI_MHI_EVENT_ID_START);\n\n\treturn event_bitmap;\n}\n\n \nstatic int gsi_channel_setup_one(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tu32 evt_ring_id = channel->evt_ring_id;\n\tint ret;\n\n\tif (!gsi_channel_initialized(channel))\n\t\treturn 0;\n\n\tret = gsi_evt_ring_alloc_command(gsi, evt_ring_id);\n\tif (ret)\n\t\treturn ret;\n\n\tgsi_evt_ring_program(gsi, evt_ring_id);\n\n\tret = gsi_channel_alloc_command(gsi, channel_id);\n\tif (ret)\n\t\tgoto err_evt_ring_de_alloc;\n\n\tgsi_channel_program(channel, true);\n\n\tif (channel->toward_ipa)\n\t\tnetif_napi_add_tx(&gsi->dummy_dev, &channel->napi,\n\t\t\t\t  gsi_channel_poll);\n\telse\n\t\tnetif_napi_add(&gsi->dummy_dev, &channel->napi,\n\t\t\t       gsi_channel_poll);\n\n\treturn 0;\n\nerr_evt_ring_de_alloc:\n\t \n\tgsi_evt_ring_de_alloc_command(gsi, evt_ring_id);\n\n\treturn ret;\n}\n\n \nstatic void gsi_channel_teardown_one(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\tu32 evt_ring_id = channel->evt_ring_id;\n\n\tif (!gsi_channel_initialized(channel))\n\t\treturn;\n\n\tnetif_napi_del(&channel->napi);\n\n\tgsi_channel_de_alloc_command(gsi, channel_id);\n\tgsi_evt_ring_reset_command(gsi, evt_ring_id);\n\tgsi_evt_ring_de_alloc_command(gsi, evt_ring_id);\n}\n\n \nstatic int gsi_generic_command(struct gsi *gsi, u32 channel_id,\n\t\t\t       enum gsi_generic_cmd_opcode opcode,\n\t\t\t       u8 params)\n{\n\tconst struct reg *reg;\n\tbool timeout;\n\tu32 offset;\n\tu32 val;\n\n\t \n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_EN);\n\tval = ERROR_INT | GP_INT1;\n\tiowrite32(val, gsi->virt + reg_offset(reg));\n\n\t \n\treg = gsi_reg(gsi, CNTXT_SCRATCH_0);\n\toffset = reg_offset(reg);\n\tval = ioread32(gsi->virt + offset);\n\n\tval &= ~reg_fmask(reg, GENERIC_EE_RESULT);\n\tiowrite32(val, gsi->virt + offset);\n\n\t \n\treg = gsi_reg(gsi, GENERIC_CMD);\n\tval = reg_encode(reg, GENERIC_OPCODE, opcode);\n\tval |= reg_encode(reg, GENERIC_CHID, channel_id);\n\tval |= reg_encode(reg, GENERIC_EE, GSI_EE_MODEM);\n\tif (gsi->version >= IPA_VERSION_4_11)\n\t\tval |= reg_encode(reg, GENERIC_PARAMS, params);\n\n\ttimeout = !gsi_command(gsi, reg_offset(reg), val);\n\n\t \n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_EN);\n\tiowrite32(ERROR_INT, gsi->virt + reg_offset(reg));\n\n\tif (!timeout)\n\t\treturn gsi->result;\n\n\tdev_err(gsi->dev, \"GSI generic command %u to channel %u timed out\\n\",\n\t\topcode, channel_id);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int gsi_modem_channel_alloc(struct gsi *gsi, u32 channel_id)\n{\n\treturn gsi_generic_command(gsi, channel_id,\n\t\t\t\t   GSI_GENERIC_ALLOCATE_CHANNEL, 0);\n}\n\nstatic void gsi_modem_channel_halt(struct gsi *gsi, u32 channel_id)\n{\n\tu32 retries = GSI_CHANNEL_MODEM_HALT_RETRIES;\n\tint ret;\n\n\tdo\n\t\tret = gsi_generic_command(gsi, channel_id,\n\t\t\t\t\t  GSI_GENERIC_HALT_CHANNEL, 0);\n\twhile (ret == -EAGAIN && retries--);\n\n\tif (ret)\n\t\tdev_err(gsi->dev, \"error %d halting modem channel %u\\n\",\n\t\t\tret, channel_id);\n}\n\n \nvoid\ngsi_modem_channel_flow_control(struct gsi *gsi, u32 channel_id, bool enable)\n{\n\tu32 retries = 0;\n\tu32 command;\n\tint ret;\n\n\tcommand = enable ? GSI_GENERIC_ENABLE_FLOW_CONTROL\n\t\t\t : GSI_GENERIC_DISABLE_FLOW_CONTROL;\n\t \n\tif (!enable && gsi->version >= IPA_VERSION_4_11)\n\t\tretries = GSI_CHANNEL_MODEM_FLOW_RETRIES;\n\n\tdo\n\t\tret = gsi_generic_command(gsi, channel_id, command, 0);\n\twhile (ret == -EAGAIN && retries--);\n\n\tif (ret)\n\t\tdev_err(gsi->dev,\n\t\t\t\"error %d %sabling mode channel %u flow control\\n\",\n\t\t\tret, enable ? \"en\" : \"dis\", channel_id);\n}\n\n \nstatic int gsi_channel_setup(struct gsi *gsi)\n{\n\tu32 channel_id = 0;\n\tu32 mask;\n\tint ret;\n\n\tgsi_irq_enable(gsi);\n\n\tmutex_lock(&gsi->mutex);\n\n\tdo {\n\t\tret = gsi_channel_setup_one(gsi, channel_id);\n\t\tif (ret)\n\t\t\tgoto err_unwind;\n\t} while (++channel_id < gsi->channel_count);\n\n\t \n\twhile (channel_id < GSI_CHANNEL_COUNT_MAX) {\n\t\tstruct gsi_channel *channel = &gsi->channel[channel_id++];\n\n\t\tif (!gsi_channel_initialized(channel))\n\t\t\tcontinue;\n\n\t\tret = -EINVAL;\n\t\tdev_err(gsi->dev, \"channel %u not supported by hardware\\n\",\n\t\t\tchannel_id - 1);\n\t\tchannel_id = gsi->channel_count;\n\t\tgoto err_unwind;\n\t}\n\n\t \n\tmask = gsi->modem_channel_bitmap;\n\twhile (mask) {\n\t\tu32 modem_channel_id = __ffs(mask);\n\n\t\tret = gsi_modem_channel_alloc(gsi, modem_channel_id);\n\t\tif (ret)\n\t\t\tgoto err_unwind_modem;\n\n\t\t \n\t\tmask ^= BIT(modem_channel_id);\n\t}\n\n\tmutex_unlock(&gsi->mutex);\n\n\treturn 0;\n\nerr_unwind_modem:\n\t \n\tmask ^= gsi->modem_channel_bitmap;\n\twhile (mask) {\n\t\tchannel_id = __fls(mask);\n\n\t\tmask ^= BIT(channel_id);\n\n\t\tgsi_modem_channel_halt(gsi, channel_id);\n\t}\n\nerr_unwind:\n\twhile (channel_id--)\n\t\tgsi_channel_teardown_one(gsi, channel_id);\n\n\tmutex_unlock(&gsi->mutex);\n\n\tgsi_irq_disable(gsi);\n\n\treturn ret;\n}\n\n \nstatic void gsi_channel_teardown(struct gsi *gsi)\n{\n\tu32 mask = gsi->modem_channel_bitmap;\n\tu32 channel_id;\n\n\tmutex_lock(&gsi->mutex);\n\n\twhile (mask) {\n\t\tchannel_id = __fls(mask);\n\n\t\tmask ^= BIT(channel_id);\n\n\t\tgsi_modem_channel_halt(gsi, channel_id);\n\t}\n\n\tchannel_id = gsi->channel_count - 1;\n\tdo\n\t\tgsi_channel_teardown_one(gsi, channel_id);\n\twhile (channel_id--);\n\n\tmutex_unlock(&gsi->mutex);\n\n\tgsi_irq_disable(gsi);\n}\n\n \nstatic int gsi_irq_setup(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tint ret;\n\n\t \n\treg = gsi_reg(gsi, CNTXT_INTSET);\n\tiowrite32(reg_bit(reg, INTYPE), gsi->virt + reg_offset(reg));\n\n\t \n\tgsi_irq_type_update(gsi, 0);\n\n\t \n\treg = gsi_reg(gsi, CNTXT_SRC_CH_IRQ_MSK);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_SRC_EV_CH_IRQ_MSK);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_GLOB_IRQ_EN);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\treg = gsi_reg(gsi, CNTXT_SRC_IEOB_IRQ_MSK);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\t \n\tif (gsi->version > IPA_VERSION_3_1) {\n\t\treg = gsi_reg(gsi, INTER_EE_SRC_CH_IRQ_MSK);\n\t\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\t\treg = gsi_reg(gsi, INTER_EE_SRC_EV_CH_IRQ_MSK);\n\t\tiowrite32(0, gsi->virt + reg_offset(reg));\n\t}\n\n\treg = gsi_reg(gsi, CNTXT_GSI_IRQ_EN);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\tret = request_irq(gsi->irq, gsi_isr, 0, \"gsi\", gsi);\n\tif (ret)\n\t\tdev_err(gsi->dev, \"error %d requesting \\\"gsi\\\" IRQ\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void gsi_irq_teardown(struct gsi *gsi)\n{\n\tfree_irq(gsi->irq, gsi);\n}\n\n \nstatic int gsi_ring_setup(struct gsi *gsi)\n{\n\tstruct device *dev = gsi->dev;\n\tconst struct reg *reg;\n\tu32 count;\n\tu32 val;\n\n\tif (gsi->version < IPA_VERSION_3_5_1) {\n\t\t \n\t\tgsi->channel_count = GSI_CHANNEL_COUNT_MAX;\n\t\tgsi->evt_ring_count = GSI_EVT_RING_COUNT_MAX;\n\n\t\treturn 0;\n\t}\n\n\treg = gsi_reg(gsi, HW_PARAM_2);\n\tval = ioread32(gsi->virt + reg_offset(reg));\n\n\tcount = reg_decode(reg, NUM_CH_PER_EE, val);\n\tif (!count) {\n\t\tdev_err(dev, \"GSI reports zero channels supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (count > GSI_CHANNEL_COUNT_MAX) {\n\t\tdev_warn(dev, \"limiting to %u channels; hardware supports %u\\n\",\n\t\t\t GSI_CHANNEL_COUNT_MAX, count);\n\t\tcount = GSI_CHANNEL_COUNT_MAX;\n\t}\n\tgsi->channel_count = count;\n\n\tif (gsi->version < IPA_VERSION_5_0) {\n\t\tcount = reg_decode(reg, NUM_EV_PER_EE, val);\n\t} else {\n\t\treg = gsi_reg(gsi, HW_PARAM_4);\n\t\tcount = reg_decode(reg, EV_PER_EE, val);\n\t}\n\tif (!count) {\n\t\tdev_err(dev, \"GSI reports zero event rings supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (count > GSI_EVT_RING_COUNT_MAX) {\n\t\tdev_warn(dev,\n\t\t\t \"limiting to %u event rings; hardware supports %u\\n\",\n\t\t\t GSI_EVT_RING_COUNT_MAX, count);\n\t\tcount = GSI_EVT_RING_COUNT_MAX;\n\t}\n\tgsi->evt_ring_count = count;\n\n\treturn 0;\n}\n\n \nint gsi_setup(struct gsi *gsi)\n{\n\tconst struct reg *reg;\n\tu32 val;\n\tint ret;\n\n\t \n\treg = gsi_reg(gsi, GSI_STATUS);\n\tval = ioread32(gsi->virt + reg_offset(reg));\n\tif (!(val & reg_bit(reg, ENABLED))) {\n\t\tdev_err(gsi->dev, \"GSI has not been enabled\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = gsi_irq_setup(gsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gsi_ring_setup(gsi);\t \n\tif (ret)\n\t\tgoto err_irq_teardown;\n\n\t \n\treg = gsi_reg(gsi, ERROR_LOG);\n\tiowrite32(0, gsi->virt + reg_offset(reg));\n\n\tret = gsi_channel_setup(gsi);\n\tif (ret)\n\t\tgoto err_irq_teardown;\n\n\treturn 0;\n\nerr_irq_teardown:\n\tgsi_irq_teardown(gsi);\n\n\treturn ret;\n}\n\n \nvoid gsi_teardown(struct gsi *gsi)\n{\n\tgsi_channel_teardown(gsi);\n\tgsi_irq_teardown(gsi);\n}\n\n \nstatic int gsi_channel_evt_ring_init(struct gsi_channel *channel)\n{\n\tstruct gsi *gsi = channel->gsi;\n\tstruct gsi_evt_ring *evt_ring;\n\tint ret;\n\n\tret = gsi_evt_ring_id_alloc(gsi);\n\tif (ret < 0)\n\t\treturn ret;\n\tchannel->evt_ring_id = ret;\n\n\tevt_ring = &gsi->evt_ring[channel->evt_ring_id];\n\tevt_ring->channel = channel;\n\n\tret = gsi_ring_alloc(gsi, &evt_ring->ring, channel->event_count);\n\tif (!ret)\n\t\treturn 0;\t \n\n\tdev_err(gsi->dev, \"error %d allocating channel %u event ring\\n\",\n\t\tret, gsi_channel_id(channel));\n\n\tgsi_evt_ring_id_free(gsi, channel->evt_ring_id);\n\n\treturn ret;\n}\n\n \nstatic void gsi_channel_evt_ring_exit(struct gsi_channel *channel)\n{\n\tu32 evt_ring_id = channel->evt_ring_id;\n\tstruct gsi *gsi = channel->gsi;\n\tstruct gsi_evt_ring *evt_ring;\n\n\tevt_ring = &gsi->evt_ring[evt_ring_id];\n\tgsi_ring_free(gsi, &evt_ring->ring);\n\tgsi_evt_ring_id_free(gsi, evt_ring_id);\n}\n\nstatic bool gsi_channel_data_valid(struct gsi *gsi, bool command,\n\t\t\t\t   const struct ipa_gsi_endpoint_data *data)\n{\n\tconst struct gsi_channel_data *channel_data;\n\tu32 channel_id = data->channel_id;\n\tstruct device *dev = gsi->dev;\n\n\t \n\tif (channel_id >= GSI_CHANNEL_COUNT_MAX) {\n\t\tdev_err(dev, \"bad channel id %u; must be less than %u\\n\",\n\t\t\tchannel_id, GSI_CHANNEL_COUNT_MAX);\n\t\treturn false;\n\t}\n\n\tif (data->ee_id != GSI_EE_AP && data->ee_id != GSI_EE_MODEM) {\n\t\tdev_err(dev, \"bad EE id %u; not AP or modem\\n\", data->ee_id);\n\t\treturn false;\n\t}\n\n\tif (command && !data->toward_ipa) {\n\t\tdev_err(dev, \"command channel %u is not TX\\n\", channel_id);\n\t\treturn false;\n\t}\n\n\tchannel_data = &data->channel;\n\n\tif (!channel_data->tlv_count ||\n\t    channel_data->tlv_count > GSI_TLV_MAX) {\n\t\tdev_err(dev, \"channel %u bad tlv_count %u; must be 1..%u\\n\",\n\t\t\tchannel_id, channel_data->tlv_count, GSI_TLV_MAX);\n\t\treturn false;\n\t}\n\n\tif (command && IPA_COMMAND_TRANS_TRE_MAX > channel_data->tlv_count) {\n\t\tdev_err(dev, \"command TRE max too big for channel %u (%u > %u)\\n\",\n\t\t\tchannel_id, IPA_COMMAND_TRANS_TRE_MAX,\n\t\t\tchannel_data->tlv_count);\n\t\treturn false;\n\t}\n\n\t \n\tif (channel_data->tre_count < 2 * channel_data->tlv_count - 1) {\n\t\tdev_err(dev, \"channel %u TLV count %u exceeds TRE count %u\\n\",\n\t\t\tchannel_id, channel_data->tlv_count,\n\t\t\tchannel_data->tre_count);\n\t\treturn false;\n\t}\n\n\tif (!is_power_of_2(channel_data->tre_count)) {\n\t\tdev_err(dev, \"channel %u bad tre_count %u; not power of 2\\n\",\n\t\t\tchannel_id, channel_data->tre_count);\n\t\treturn false;\n\t}\n\n\tif (!is_power_of_2(channel_data->event_count)) {\n\t\tdev_err(dev, \"channel %u bad event_count %u; not power of 2\\n\",\n\t\t\tchannel_id, channel_data->event_count);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int gsi_channel_init_one(struct gsi *gsi,\n\t\t\t\tconst struct ipa_gsi_endpoint_data *data,\n\t\t\t\tbool command)\n{\n\tstruct gsi_channel *channel;\n\tu32 tre_count;\n\tint ret;\n\n\tif (!gsi_channel_data_valid(gsi, command, data))\n\t\treturn -EINVAL;\n\n\t \n\tif (data->channel.tre_count > data->channel.event_count) {\n\t\ttre_count = data->channel.event_count;\n\t\tdev_warn(gsi->dev, \"channel %u limited to %u TREs\\n\",\n\t\t\t data->channel_id, tre_count);\n\t} else {\n\t\ttre_count = data->channel.tre_count;\n\t}\n\n\tchannel = &gsi->channel[data->channel_id];\n\tmemset(channel, 0, sizeof(*channel));\n\n\tchannel->gsi = gsi;\n\tchannel->toward_ipa = data->toward_ipa;\n\tchannel->command = command;\n\tchannel->trans_tre_max = data->channel.tlv_count;\n\tchannel->tre_count = tre_count;\n\tchannel->event_count = data->channel.event_count;\n\n\tret = gsi_channel_evt_ring_init(channel);\n\tif (ret)\n\t\tgoto err_clear_gsi;\n\n\tret = gsi_ring_alloc(gsi, &channel->tre_ring, data->channel.tre_count);\n\tif (ret) {\n\t\tdev_err(gsi->dev, \"error %d allocating channel %u ring\\n\",\n\t\t\tret, data->channel_id);\n\t\tgoto err_channel_evt_ring_exit;\n\t}\n\n\tret = gsi_channel_trans_init(gsi, data->channel_id);\n\tif (ret)\n\t\tgoto err_ring_free;\n\n\tif (command) {\n\t\tu32 tre_max = gsi_channel_tre_max(gsi, data->channel_id);\n\n\t\tret = ipa_cmd_pool_init(channel, tre_max);\n\t}\n\tif (!ret)\n\t\treturn 0;\t \n\n\tgsi_channel_trans_exit(channel);\nerr_ring_free:\n\tgsi_ring_free(gsi, &channel->tre_ring);\nerr_channel_evt_ring_exit:\n\tgsi_channel_evt_ring_exit(channel);\nerr_clear_gsi:\n\tchannel->gsi = NULL;\t \n\n\treturn ret;\n}\n\n \nstatic void gsi_channel_exit_one(struct gsi_channel *channel)\n{\n\tif (!gsi_channel_initialized(channel))\n\t\treturn;\n\n\tif (channel->command)\n\t\tipa_cmd_pool_exit(channel);\n\tgsi_channel_trans_exit(channel);\n\tgsi_ring_free(channel->gsi, &channel->tre_ring);\n\tgsi_channel_evt_ring_exit(channel);\n}\n\n \nstatic int gsi_channel_init(struct gsi *gsi, u32 count,\n\t\t\t    const struct ipa_gsi_endpoint_data *data)\n{\n\tbool modem_alloc;\n\tint ret = 0;\n\tu32 i;\n\n\t \n\tmodem_alloc = gsi->version == IPA_VERSION_4_2;\n\n\tgsi->event_bitmap = gsi_event_bitmap_init(GSI_EVT_RING_COUNT_MAX);\n\tgsi->ieob_enabled_bitmap = 0;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tbool command = i == IPA_ENDPOINT_AP_COMMAND_TX;\n\n\t\tif (ipa_gsi_endpoint_data_empty(&data[i]))\n\t\t\tcontinue;\t \n\n\t\t \n\t\tif (data[i].ee_id == GSI_EE_MODEM) {\n\t\t\tif (modem_alloc)\n\t\t\t\tgsi->modem_channel_bitmap |=\n\t\t\t\t\t\tBIT(data[i].channel_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = gsi_channel_init_one(gsi, &data[i], command);\n\t\tif (ret)\n\t\t\tgoto err_unwind;\n\t}\n\n\treturn ret;\n\nerr_unwind:\n\twhile (i--) {\n\t\tif (ipa_gsi_endpoint_data_empty(&data[i]))\n\t\t\tcontinue;\n\t\tif (modem_alloc && data[i].ee_id == GSI_EE_MODEM) {\n\t\t\tgsi->modem_channel_bitmap &= ~BIT(data[i].channel_id);\n\t\t\tcontinue;\n\t\t}\n\t\tgsi_channel_exit_one(&gsi->channel[data->channel_id]);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void gsi_channel_exit(struct gsi *gsi)\n{\n\tu32 channel_id = GSI_CHANNEL_COUNT_MAX - 1;\n\n\tdo\n\t\tgsi_channel_exit_one(&gsi->channel[channel_id]);\n\twhile (channel_id--);\n\tgsi->modem_channel_bitmap = 0;\n}\n\n \nint gsi_init(struct gsi *gsi, struct platform_device *pdev,\n\t     enum ipa_version version, u32 count,\n\t     const struct ipa_gsi_endpoint_data *data)\n{\n\tint ret;\n\n\tgsi_validate_build();\n\n\tgsi->dev = &pdev->dev;\n\tgsi->version = version;\n\n\t \n\tinit_dummy_netdev(&gsi->dummy_dev);\n\tinit_completion(&gsi->completion);\n\n\tret = gsi_reg_init(gsi, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gsi_irq_init(gsi, pdev);\t \n\tif (ret)\n\t\tgoto err_reg_exit;\n\n\tret = gsi_channel_init(gsi, count, data);\n\tif (ret)\n\t\tgoto err_reg_exit;\n\n\tmutex_init(&gsi->mutex);\n\n\treturn 0;\n\nerr_reg_exit:\n\tgsi_reg_exit(gsi);\n\n\treturn ret;\n}\n\n \nvoid gsi_exit(struct gsi *gsi)\n{\n\tmutex_destroy(&gsi->mutex);\n\tgsi_channel_exit(gsi);\n\tgsi_reg_exit(gsi);\n}\n\n \nu32 gsi_channel_tre_max(struct gsi *gsi, u32 channel_id)\n{\n\tstruct gsi_channel *channel = &gsi->channel[channel_id];\n\n\t \n\treturn channel->tre_count - (channel->trans_tre_max - 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}