{
  "module_name": "ipa_main.c",
  "hash_id": "f5d15b9341e2ccd0002bc7963edec789b38e93dd04df60554bdc88ebdbbd7968",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_main.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/bug.h>\n#include <linux/io.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/soc/qcom/mdt_loader.h>\n\n#include \"ipa.h\"\n#include \"ipa_power.h\"\n#include \"ipa_data.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_resource.h\"\n#include \"ipa_cmd.h\"\n#include \"ipa_reg.h\"\n#include \"ipa_mem.h\"\n#include \"ipa_table.h\"\n#include \"ipa_smp2p.h\"\n#include \"ipa_modem.h\"\n#include \"ipa_uc.h\"\n#include \"ipa_interrupt.h\"\n#include \"gsi_trans.h\"\n#include \"ipa_sysfs.h\"\n\n \n\n \n#define IPA_FW_PATH_DEFAULT\t\"ipa_fws.mdt\"\n#define IPA_PAS_ID\t\t15\n\n \n#define DPL_TIMESTAMP_SHIFT\t14\t \n#define TAG_TIMESTAMP_SHIFT\t14\n#define NAT_TIMESTAMP_SHIFT\t24\t \n\n \n#define IPA_XO_CLOCK_DIVIDER\t192\t \n\n \nenum ipa_firmware_loader {\n\tIPA_LOADER_DEFER,\n\tIPA_LOADER_SELF,\n\tIPA_LOADER_MODEM,\n\tIPA_LOADER_SKIP,\n\tIPA_LOADER_INVALID,\n};\n\n \nint ipa_setup(struct ipa *ipa)\n{\n\tstruct ipa_endpoint *exception_endpoint;\n\tstruct ipa_endpoint *command_endpoint;\n\tstruct device *dev = &ipa->pdev->dev;\n\tint ret;\n\n\tret = gsi_setup(&ipa->gsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ipa_power_setup(ipa);\n\tif (ret)\n\t\tgoto err_gsi_teardown;\n\n\tipa_endpoint_setup(ipa);\n\n\t \n\tcommand_endpoint = ipa->name_map[IPA_ENDPOINT_AP_COMMAND_TX];\n\tret = ipa_endpoint_enable_one(command_endpoint);\n\tif (ret)\n\t\tgoto err_endpoint_teardown;\n\n\tret = ipa_mem_setup(ipa);\t \n\tif (ret)\n\t\tgoto err_command_disable;\n\n\tret = ipa_table_setup(ipa);\t \n\tif (ret)\n\t\tgoto err_command_disable;\n\n\t \n\texception_endpoint = ipa->name_map[IPA_ENDPOINT_AP_LAN_RX];\n\tret = ipa_endpoint_enable_one(exception_endpoint);\n\tif (ret)\n\t\tgoto err_command_disable;\n\n\tipa_endpoint_default_route_set(ipa, exception_endpoint->endpoint_id);\n\n\t \n\tret = ipa_qmi_setup(ipa);\n\tif (ret)\n\t\tgoto err_default_route_clear;\n\n\tipa->setup_complete = true;\n\n\tdev_info(dev, \"IPA driver setup completed successfully\\n\");\n\n\treturn 0;\n\nerr_default_route_clear:\n\tipa_endpoint_default_route_clear(ipa);\n\tipa_endpoint_disable_one(exception_endpoint);\nerr_command_disable:\n\tipa_endpoint_disable_one(command_endpoint);\nerr_endpoint_teardown:\n\tipa_endpoint_teardown(ipa);\n\tipa_power_teardown(ipa);\nerr_gsi_teardown:\n\tgsi_teardown(&ipa->gsi);\n\n\treturn ret;\n}\n\n \nstatic void ipa_teardown(struct ipa *ipa)\n{\n\tstruct ipa_endpoint *exception_endpoint;\n\tstruct ipa_endpoint *command_endpoint;\n\n\t \n\tipa->setup_complete = false;\n\n\tipa_qmi_teardown(ipa);\n\tipa_endpoint_default_route_clear(ipa);\n\texception_endpoint = ipa->name_map[IPA_ENDPOINT_AP_LAN_RX];\n\tipa_endpoint_disable_one(exception_endpoint);\n\tcommand_endpoint = ipa->name_map[IPA_ENDPOINT_AP_COMMAND_TX];\n\tipa_endpoint_disable_one(command_endpoint);\n\tipa_endpoint_teardown(ipa);\n\tipa_power_teardown(ipa);\n\tgsi_teardown(&ipa->gsi);\n}\n\nstatic void\nipa_hardware_config_bcr(struct ipa *ipa, const struct ipa_data *data)\n{\n\tconst struct reg *reg;\n\tu32 val;\n\n\t \n\tif (ipa->version >= IPA_VERSION_4_5)\n\t\treturn;\n\n\treg = ipa_reg(ipa, IPA_BCR);\n\tval = data->backward_compat;\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n}\n\nstatic void ipa_hardware_config_tx(struct ipa *ipa)\n{\n\tenum ipa_version version = ipa->version;\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 val;\n\n\tif (version <= IPA_VERSION_4_0 || version >= IPA_VERSION_4_5)\n\t\treturn;\n\n\t \n\treg = ipa_reg(ipa, IPA_TX_CFG);\n\toffset = reg_offset(reg);\n\n\tval = ioread32(ipa->reg_virt + offset);\n\n\tval &= ~reg_bit(reg, PA_MASK_EN);\n\n\tiowrite32(val, ipa->reg_virt + offset);\n}\n\nstatic void ipa_hardware_config_clkon(struct ipa *ipa)\n{\n\tenum ipa_version version = ipa->version;\n\tconst struct reg *reg;\n\tu32 val;\n\n\tif (version >= IPA_VERSION_4_5)\n\t\treturn;\n\n\tif (version < IPA_VERSION_4_0 && version != IPA_VERSION_3_1)\n\t\treturn;\n\n\t \n\treg = ipa_reg(ipa, CLKON_CFG);\n\tif (version == IPA_VERSION_3_1) {\n\t\t \n\t\tval = reg_bit(reg, CLKON_MISC);\n\t} else {\t \n\t\t \n\t\tval = reg_bit(reg, CLKON_GLOBAL);\n\t\tval |= reg_bit(reg, GLOBAL_2X_CLK);\n\t}\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n}\n\n \nstatic void ipa_hardware_config_comp(struct ipa *ipa)\n{\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 val;\n\n\t \n\tif (ipa->version < IPA_VERSION_4_0)\n\t\treturn;\n\n\treg = ipa_reg(ipa, COMP_CFG);\n\toffset = reg_offset(reg);\n\n\tval = ioread32(ipa->reg_virt + offset);\n\n\tif (ipa->version == IPA_VERSION_4_0) {\n\t\tval &= ~reg_bit(reg, IPA_QMB_SELECT_CONS_EN);\n\t\tval &= ~reg_bit(reg, IPA_QMB_SELECT_PROD_EN);\n\t\tval &= ~reg_bit(reg, IPA_QMB_SELECT_GLOBAL_EN);\n\t} else if (ipa->version < IPA_VERSION_4_5) {\n\t\tval |= reg_bit(reg, GSI_MULTI_AXI_MASTERS_DIS);\n\t} else {\n\t\t \n\t}\n\n\tval |= reg_bit(reg, GSI_MULTI_INORDER_RD_DIS);\n\tval |= reg_bit(reg, GSI_MULTI_INORDER_WR_DIS);\n\n\tiowrite32(val, ipa->reg_virt + offset);\n}\n\n \nstatic void\nipa_hardware_config_qsb(struct ipa *ipa, const struct ipa_data *data)\n{\n\tconst struct ipa_qsb_data *data0;\n\tconst struct ipa_qsb_data *data1;\n\tconst struct reg *reg;\n\tu32 val;\n\n\t \n\tdata0 = &data->qsb_data[IPA_QSB_MASTER_DDR];\n\tif (data->qsb_count > 1)\n\t\tdata1 = &data->qsb_data[IPA_QSB_MASTER_PCIE];\n\n\t \n\treg = ipa_reg(ipa, QSB_MAX_WRITES);\n\n\tval = reg_encode(reg, GEN_QMB_0_MAX_WRITES, data0->max_writes);\n\tif (data->qsb_count > 1)\n\t\tval |= reg_encode(reg, GEN_QMB_1_MAX_WRITES, data1->max_writes);\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n\n\t \n\treg = ipa_reg(ipa, QSB_MAX_READS);\n\n\tval = reg_encode(reg, GEN_QMB_0_MAX_READS, data0->max_reads);\n\tif (ipa->version >= IPA_VERSION_4_0)\n\t\tval |= reg_encode(reg, GEN_QMB_0_MAX_READS_BEATS,\n\t\t\t\t  data0->max_reads_beats);\n\tif (data->qsb_count > 1) {\n\t\tval = reg_encode(reg, GEN_QMB_1_MAX_READS, data1->max_reads);\n\t\tif (ipa->version >= IPA_VERSION_4_0)\n\t\t\tval |= reg_encode(reg, GEN_QMB_1_MAX_READS_BEATS,\n\t\t\t\t\t  data1->max_reads_beats);\n\t}\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n}\n\n \n#define TIMER_FREQUENCY\t32000\t\t \n\n \nstatic __always_inline u32 ipa_aggr_granularity_val(u32 usec)\n{\n\treturn DIV_ROUND_CLOSEST(usec * TIMER_FREQUENCY, USEC_PER_SEC) - 1;\n}\n\n \nstatic void ipa_qtime_config(struct ipa *ipa)\n{\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 val;\n\n\t \n\treg = ipa_reg(ipa, TIMERS_XO_CLK_DIV_CFG);\n\tiowrite32(0, ipa->reg_virt + reg_offset(reg));\n\n\treg = ipa_reg(ipa, QTIME_TIMESTAMP_CFG);\n\t \n\tval = reg_encode(reg, DPL_TIMESTAMP_LSB, DPL_TIMESTAMP_SHIFT);\n\tval |= reg_bit(reg, DPL_TIMESTAMP_SEL);\n\t \n\tval = reg_encode(reg, TAG_TIMESTAMP_LSB, TAG_TIMESTAMP_SHIFT);\n\tval = reg_encode(reg, NAT_TIMESTAMP_LSB, NAT_TIMESTAMP_SHIFT);\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n\n\t \n\treg = ipa_reg(ipa, TIMERS_PULSE_GRAN_CFG);\n\tval = reg_encode(reg, PULSE_GRAN_0, IPA_GRAN_100_US);\n\tval |= reg_encode(reg, PULSE_GRAN_1, IPA_GRAN_1_MS);\n\tif (ipa->version >= IPA_VERSION_5_0) {\n\t\tval |= reg_encode(reg, PULSE_GRAN_2, IPA_GRAN_10_MS);\n\t\tval |= reg_encode(reg, PULSE_GRAN_3, IPA_GRAN_10_MS);\n\t} else {\n\t\tval |= reg_encode(reg, PULSE_GRAN_2, IPA_GRAN_1_MS);\n\t}\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n\n\t \n\treg = ipa_reg(ipa, TIMERS_XO_CLK_DIV_CFG);\n\toffset = reg_offset(reg);\n\n\tval = reg_encode(reg, DIV_VALUE, IPA_XO_CLOCK_DIVIDER - 1);\n\n\tiowrite32(val, ipa->reg_virt + offset);\n\n\t \n\tval |= reg_bit(reg, DIV_ENABLE);\n\n\tiowrite32(val, ipa->reg_virt + offset);\n}\n\n \nstatic void ipa_hardware_config_counter(struct ipa *ipa)\n{\n\tu32 granularity = ipa_aggr_granularity_val(IPA_AGGR_GRANULARITY);\n\tconst struct reg *reg;\n\tu32 val;\n\n\treg = ipa_reg(ipa, COUNTER_CFG);\n\t \n\tval = reg_encode(reg, AGGR_GRANULARITY, granularity);\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n}\n\nstatic void ipa_hardware_config_timing(struct ipa *ipa)\n{\n\tif (ipa->version < IPA_VERSION_4_5)\n\t\tipa_hardware_config_counter(ipa);\n\telse\n\t\tipa_qtime_config(ipa);\n}\n\nstatic void ipa_hardware_config_hashing(struct ipa *ipa)\n{\n\tconst struct reg *reg;\n\n\t \n\tif (ipa->version != IPA_VERSION_4_2)\n\t\treturn;\n\n\t \n\treg = ipa_reg(ipa, FILT_ROUT_HASH_EN);\n\n\t \n\tiowrite32(0, ipa->reg_virt + reg_offset(reg));\n}\n\nstatic void ipa_idle_indication_cfg(struct ipa *ipa,\n\t\t\t\t    u32 enter_idle_debounce_thresh,\n\t\t\t\t    bool const_non_idle_enable)\n{\n\tconst struct reg *reg;\n\tu32 val;\n\n\tif (ipa->version < IPA_VERSION_3_5_1)\n\t\treturn;\n\n\treg = ipa_reg(ipa, IDLE_INDICATION_CFG);\n\tval = reg_encode(reg, ENTER_IDLE_DEBOUNCE_THRESH,\n\t\t\t enter_idle_debounce_thresh);\n\tif (const_non_idle_enable)\n\t\tval |= reg_bit(reg, CONST_NON_IDLE_ENABLE);\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n}\n\n \nstatic void ipa_hardware_dcd_config(struct ipa *ipa)\n{\n\t \n\tipa_idle_indication_cfg(ipa, 256, false);\n}\n\nstatic void ipa_hardware_dcd_deconfig(struct ipa *ipa)\n{\n\t \n\tipa_idle_indication_cfg(ipa, 0, true);\n}\n\n \nstatic void ipa_hardware_config(struct ipa *ipa, const struct ipa_data *data)\n{\n\tipa_hardware_config_bcr(ipa, data);\n\tipa_hardware_config_tx(ipa);\n\tipa_hardware_config_clkon(ipa);\n\tipa_hardware_config_comp(ipa);\n\tipa_hardware_config_qsb(ipa, data);\n\tipa_hardware_config_timing(ipa);\n\tipa_hardware_config_hashing(ipa);\n\tipa_hardware_dcd_config(ipa);\n}\n\n \nstatic void ipa_hardware_deconfig(struct ipa *ipa)\n{\n\t \n\tipa_hardware_dcd_deconfig(ipa);\n}\n\n \nstatic int ipa_config(struct ipa *ipa, const struct ipa_data *data)\n{\n\tint ret;\n\n\tipa_hardware_config(ipa, data);\n\n\tret = ipa_mem_config(ipa);\n\tif (ret)\n\t\tgoto err_hardware_deconfig;\n\n\tipa->interrupt = ipa_interrupt_config(ipa);\n\tif (IS_ERR(ipa->interrupt)) {\n\t\tret = PTR_ERR(ipa->interrupt);\n\t\tipa->interrupt = NULL;\n\t\tgoto err_mem_deconfig;\n\t}\n\n\tipa_uc_config(ipa);\n\n\tret = ipa_endpoint_config(ipa);\n\tif (ret)\n\t\tgoto err_uc_deconfig;\n\n\tipa_table_config(ipa);\t\t \n\n\t \n\tret = ipa_resource_config(ipa, data->resource_data);\n\tif (ret)\n\t\tgoto err_endpoint_deconfig;\n\n\tret = ipa_modem_config(ipa);\n\tif (ret)\n\t\tgoto err_endpoint_deconfig;\n\n\treturn 0;\n\nerr_endpoint_deconfig:\n\tipa_endpoint_deconfig(ipa);\nerr_uc_deconfig:\n\tipa_uc_deconfig(ipa);\n\tipa_interrupt_deconfig(ipa->interrupt);\n\tipa->interrupt = NULL;\nerr_mem_deconfig:\n\tipa_mem_deconfig(ipa);\nerr_hardware_deconfig:\n\tipa_hardware_deconfig(ipa);\n\n\treturn ret;\n}\n\n \nstatic void ipa_deconfig(struct ipa *ipa)\n{\n\tipa_modem_deconfig(ipa);\n\tipa_endpoint_deconfig(ipa);\n\tipa_uc_deconfig(ipa);\n\tipa_interrupt_deconfig(ipa->interrupt);\n\tipa->interrupt = NULL;\n\tipa_mem_deconfig(ipa);\n\tipa_hardware_deconfig(ipa);\n}\n\nstatic int ipa_firmware_load(struct device *dev)\n{\n\tconst struct firmware *fw;\n\tstruct device_node *node;\n\tstruct resource res;\n\tphys_addr_t phys;\n\tconst char *path;\n\tssize_t size;\n\tvoid *virt;\n\tint ret;\n\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (!node) {\n\t\tdev_err(dev, \"DT error getting \\\"memory-region\\\" property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_address_to_resource(node, 0, &res);\n\tof_node_put(node);\n\tif (ret) {\n\t\tdev_err(dev, \"error %d getting \\\"memory-region\\\" resource\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = of_property_read_string(dev->of_node, \"firmware-name\", &path);\n\tif (ret) {\n\t\tdev_dbg(dev, \"error %d getting \\\"firmware-name\\\" resource\\n\",\n\t\t\tret);\n\t\tpath = IPA_FW_PATH_DEFAULT;\n\t}\n\n\tret = request_firmware(&fw, path, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"error %d requesting \\\"%s\\\"\\n\", ret, path);\n\t\treturn ret;\n\t}\n\n\tphys = res.start;\n\tsize = (size_t)resource_size(&res);\n\tvirt = memremap(phys, size, MEMREMAP_WC);\n\tif (!virt) {\n\t\tdev_err(dev, \"unable to remap firmware memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_release_firmware;\n\t}\n\n\tret = qcom_mdt_load(dev, fw, path, IPA_PAS_ID, virt, phys, size, NULL);\n\tif (ret)\n\t\tdev_err(dev, \"error %d loading \\\"%s\\\"\\n\", ret, path);\n\telse if ((ret = qcom_scm_pas_auth_and_reset(IPA_PAS_ID)))\n\t\tdev_err(dev, \"error %d authenticating \\\"%s\\\"\\n\", ret, path);\n\n\tmemunmap(virt);\nout_release_firmware:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id ipa_match[] = {\n\t{\n\t\t.compatible\t= \"qcom,msm8998-ipa\",\n\t\t.data\t\t= &ipa_data_v3_1,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sdm845-ipa\",\n\t\t.data\t\t= &ipa_data_v3_5_1,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sc7180-ipa\",\n\t\t.data\t\t= &ipa_data_v4_2,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sdx55-ipa\",\n\t\t.data\t\t= &ipa_data_v4_5,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sm6350-ipa\",\n\t\t.data\t\t= &ipa_data_v4_7,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sm8350-ipa\",\n\t\t.data\t\t= &ipa_data_v4_9,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sc7280-ipa\",\n\t\t.data\t\t= &ipa_data_v4_11,\n\t},\n\t{\n\t\t.compatible\t= \"qcom,sdx65-ipa\",\n\t\t.data\t\t= &ipa_data_v5_0,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ipa_match);\n\n \nstatic void ipa_validate_build(void)\n{\n\t \n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_64BIT) && sizeof(size_t) != 4);\n\n\t \n\tBUILD_BUG_ON(GSI_EE_AP != 0);\n\n\t \n\tBUILD_BUG_ON(!GSI_CHANNEL_COUNT_MAX);\n\tBUILD_BUG_ON(!GSI_EVT_RING_COUNT_MAX);\n\n\t \n\tBUILD_BUG_ON(GSI_CHANNEL_COUNT_MAX > 32);\n\tBUILD_BUG_ON(GSI_EVT_RING_COUNT_MAX > 31);\n\n\t \n\tBUILD_BUG_ON(GSI_TLV_MAX > U8_MAX);\n\n\t \n\tBUILD_BUG_ON(!IPA_AGGR_GRANULARITY);\n\n\t \n\tBUILD_BUG_ON(!ipa_aggr_granularity_val(IPA_AGGR_GRANULARITY));\n}\n\nstatic enum ipa_firmware_loader ipa_firmware_loader(struct device *dev)\n{\n\tbool modem_init;\n\tconst char *str;\n\tint ret;\n\n\t \n\tmodem_init = of_property_read_bool(dev->of_node, \"modem-init\");\n\tret = of_property_read_string(dev->of_node, \"qcom,gsi-loader\", &str);\n\n\t \n\tif (ret == -EINVAL) {\n\t\tif (modem_init)\n\t\t\treturn IPA_LOADER_MODEM;\n\t\tgoto out_self;\n\t}\n\n\t \n\tif (ret)\n\t\treturn IPA_LOADER_INVALID;\n\n\t \n\tif (modem_init)\n\t\treturn IPA_LOADER_INVALID;\n\n\t \n\tif (!strcmp(str, \"modem\"))\n\t\treturn IPA_LOADER_MODEM;\n\n\t \n\tif (!strcmp(str, \"skip\"))\n\t\treturn IPA_LOADER_SKIP;\n\n\t \n\tif (strcmp(str, \"self\"))\n\t\treturn IPA_LOADER_INVALID;\nout_self:\n\t \n\tif (qcom_scm_is_available())\n\t\treturn IPA_LOADER_SELF;\n\n\treturn IPA_LOADER_DEFER;\n}\n\n \nstatic int ipa_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tenum ipa_firmware_loader loader;\n\tconst struct ipa_data *data;\n\tstruct ipa_power *power;\n\tstruct ipa *ipa;\n\tint ret;\n\n\tipa_validate_build();\n\n\t \n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"matched hardware not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!ipa_version_supported(data->version)) {\n\t\tdev_err(dev, \"unsupported IPA version %u\\n\", data->version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data->modem_route_count) {\n\t\tdev_err(dev, \"modem_route_count cannot be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tloader = ipa_firmware_loader(dev);\n\tif (loader == IPA_LOADER_INVALID)\n\t\treturn -EINVAL;\n\tif (loader == IPA_LOADER_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tpower = ipa_power_init(dev, data->power_data);\n\tif (IS_ERR(power))\n\t\treturn PTR_ERR(power);\n\n\t \n\tipa = kzalloc(sizeof(*ipa), GFP_KERNEL);\n\tif (!ipa) {\n\t\tret = -ENOMEM;\n\t\tgoto err_power_exit;\n\t}\n\n\tipa->pdev = pdev;\n\tdev_set_drvdata(dev, ipa);\n\tipa->power = power;\n\tipa->version = data->version;\n\tipa->modem_route_count = data->modem_route_count;\n\tinit_completion(&ipa->completion);\n\n\tret = ipa_reg_init(ipa);\n\tif (ret)\n\t\tgoto err_kfree_ipa;\n\n\tret = ipa_mem_init(ipa, data->mem_data);\n\tif (ret)\n\t\tgoto err_reg_exit;\n\n\tret = gsi_init(&ipa->gsi, pdev, ipa->version, data->endpoint_count,\n\t\t       data->endpoint_data);\n\tif (ret)\n\t\tgoto err_mem_exit;\n\n\t \n\tret = ipa_endpoint_init(ipa, data->endpoint_count, data->endpoint_data);\n\tif (ret)\n\t\tgoto err_gsi_exit;\n\n\tret = ipa_table_init(ipa);\n\tif (ret)\n\t\tgoto err_endpoint_exit;\n\n\tret = ipa_smp2p_init(ipa, loader == IPA_LOADER_MODEM);\n\tif (ret)\n\t\tgoto err_table_exit;\n\n\t \n\tret = pm_runtime_get_sync(dev);\n\tif (WARN_ON(ret < 0))\n\t\tgoto err_power_put;\n\n\tret = ipa_config(ipa, data);\n\tif (ret)\n\t\tgoto err_power_put;\n\n\tdev_info(dev, \"IPA driver initialized\");\n\n\t \n\tif (loader == IPA_LOADER_MODEM)\n\t\tgoto done;\n\n\tif (loader == IPA_LOADER_SELF) {\n\t\t \n\t\tret = ipa_firmware_load(dev);\n\t\tif (ret)\n\t\t\tgoto err_deconfig;\n\t}  \n\n\t \n\tret = ipa_setup(ipa);\n\tif (ret)\n\t\tgoto err_deconfig;\ndone:\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_deconfig:\n\tipa_deconfig(ipa);\nerr_power_put:\n\tpm_runtime_put_noidle(dev);\n\tipa_smp2p_exit(ipa);\nerr_table_exit:\n\tipa_table_exit(ipa);\nerr_endpoint_exit:\n\tipa_endpoint_exit(ipa);\nerr_gsi_exit:\n\tgsi_exit(&ipa->gsi);\nerr_mem_exit:\n\tipa_mem_exit(ipa);\nerr_reg_exit:\n\tipa_reg_exit(ipa);\nerr_kfree_ipa:\n\tkfree(ipa);\nerr_power_exit:\n\tipa_power_exit(power);\n\n\treturn ret;\n}\n\nstatic int ipa_remove(struct platform_device *pdev)\n{\n\tstruct ipa *ipa = dev_get_drvdata(&pdev->dev);\n\tstruct ipa_power *power = ipa->power;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\t \n\tipa_smp2p_irq_disable_setup(ipa);\n\n\tret = pm_runtime_get_sync(dev);\n\tif (WARN_ON(ret < 0))\n\t\tgoto out_power_put;\n\n\tif (ipa->setup_complete) {\n\t\tret = ipa_modem_stop(ipa);\n\t\t \n\t\tif (ret == -EBUSY) {\n\t\t\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\t\t\tret = ipa_modem_stop(ipa);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tipa_teardown(ipa);\n\t}\n\n\tipa_deconfig(ipa);\nout_power_put:\n\tpm_runtime_put_noidle(dev);\n\tipa_smp2p_exit(ipa);\n\tipa_table_exit(ipa);\n\tipa_endpoint_exit(ipa);\n\tgsi_exit(&ipa->gsi);\n\tipa_mem_exit(ipa);\n\tipa_reg_exit(ipa);\n\tkfree(ipa);\n\tipa_power_exit(power);\n\n\tdev_info(dev, \"IPA driver removed\");\n\n\treturn 0;\n}\n\nstatic void ipa_shutdown(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = ipa_remove(pdev);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"shutdown: remove returned %d\\n\", ret);\n}\n\nstatic const struct attribute_group *ipa_attribute_groups[] = {\n\t&ipa_attribute_group,\n\t&ipa_feature_attribute_group,\n\t&ipa_endpoint_id_attribute_group,\n\t&ipa_modem_attribute_group,\n\tNULL,\n};\n\nstatic struct platform_driver ipa_driver = {\n\t.probe\t\t= ipa_probe,\n\t.remove\t\t= ipa_remove,\n\t.shutdown\t= ipa_shutdown,\n\t.driver\t= {\n\t\t.name\t\t= \"ipa\",\n\t\t.pm\t\t= &ipa_pm_ops,\n\t\t.of_match_table\t= ipa_match,\n\t\t.dev_groups\t= ipa_attribute_groups,\n\t},\n};\n\nmodule_platform_driver(ipa_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm IP Accelerator device driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}