{
  "module_name": "ipa_resource.c",
  "hash_id": "60d3b67f5de49aea39de5acc4ef420f1994de84f79b65a576f9a2cf81d85b97f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_resource.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#include \"ipa.h\"\n#include \"ipa_data.h\"\n#include \"ipa_reg.h\"\n#include \"ipa_resource.h\"\n\n \n\nstatic bool ipa_resource_limits_valid(struct ipa *ipa,\n\t\t\t\t      const struct ipa_resource_data *data)\n{\n\tu32 group_count;\n\tu32 i;\n\tu32 j;\n\n\t \n\tBUILD_BUG_ON(IPA_RESOURCE_GROUP_MAX > 8);\n\n\tgroup_count = data->rsrc_group_src_count;\n\tif (!group_count || group_count > IPA_RESOURCE_GROUP_MAX)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < data->resource_src_count; i++) {\n\t\tconst struct ipa_resource *resource;\n\n\t\tresource = &data->resource_src[i];\n\t\tfor (j = group_count; j < IPA_RESOURCE_GROUP_MAX; j++)\n\t\t\tif (resource->limits[j].min || resource->limits[j].max)\n\t\t\t\treturn false;\n\t}\n\n\tgroup_count = data->rsrc_group_dst_count;\n\tif (!group_count || group_count > IPA_RESOURCE_GROUP_MAX)\n\t\treturn false;\n\n\tfor (i = 0; i < data->resource_dst_count; i++) {\n\t\tconst struct ipa_resource *resource;\n\n\t\tresource = &data->resource_dst[i];\n\t\tfor (j = group_count; j < IPA_RESOURCE_GROUP_MAX; j++)\n\t\t\tif (resource->limits[j].min || resource->limits[j].max)\n\t\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nipa_resource_config_common(struct ipa *ipa, u32 resource_type,\n\t\t\t   const struct reg *reg,\n\t\t\t   const struct ipa_resource_limits *xlimits,\n\t\t\t   const struct ipa_resource_limits *ylimits)\n{\n\tu32 val;\n\n\tval = reg_encode(reg, X_MIN_LIM, xlimits->min);\n\tval |= reg_encode(reg, X_MAX_LIM, xlimits->max);\n\tif (ylimits) {\n\t\tval |= reg_encode(reg, Y_MIN_LIM, ylimits->min);\n\t\tval |= reg_encode(reg, Y_MAX_LIM, ylimits->max);\n\t}\n\n\tiowrite32(val, ipa->reg_virt + reg_n_offset(reg, resource_type));\n}\n\nstatic void ipa_resource_config_src(struct ipa *ipa, u32 resource_type,\n\t\t\t\t    const struct ipa_resource_data *data)\n{\n\tu32 group_count = data->rsrc_group_src_count;\n\tconst struct ipa_resource_limits *ylimits;\n\tconst struct ipa_resource *resource;\n\tconst struct reg *reg;\n\n\tresource = &data->resource_src[resource_type];\n\n\treg = ipa_reg(ipa, SRC_RSRC_GRP_01_RSRC_TYPE);\n\tylimits = group_count == 1 ? NULL : &resource->limits[1];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[0], ylimits);\n\tif (group_count < 3)\n\t\treturn;\n\n\treg = ipa_reg(ipa, SRC_RSRC_GRP_23_RSRC_TYPE);\n\tylimits = group_count == 3 ? NULL : &resource->limits[3];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[2], ylimits);\n\tif (group_count < 5)\n\t\treturn;\n\n\treg = ipa_reg(ipa, SRC_RSRC_GRP_45_RSRC_TYPE);\n\tylimits = group_count == 5 ? NULL : &resource->limits[5];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[4], ylimits);\n\tif (group_count < 7)\n\t\treturn;\n\n\treg = ipa_reg(ipa, SRC_RSRC_GRP_67_RSRC_TYPE);\n\tylimits = group_count == 7 ? NULL : &resource->limits[7];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[6], ylimits);\n}\n\nstatic void ipa_resource_config_dst(struct ipa *ipa, u32 resource_type,\n\t\t\t\t    const struct ipa_resource_data *data)\n{\n\tu32 group_count = data->rsrc_group_dst_count;\n\tconst struct ipa_resource_limits *ylimits;\n\tconst struct ipa_resource *resource;\n\tconst struct reg *reg;\n\n\tresource = &data->resource_dst[resource_type];\n\n\treg = ipa_reg(ipa, DST_RSRC_GRP_01_RSRC_TYPE);\n\tylimits = group_count == 1 ? NULL : &resource->limits[1];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[0], ylimits);\n\tif (group_count < 3)\n\t\treturn;\n\n\treg = ipa_reg(ipa, DST_RSRC_GRP_23_RSRC_TYPE);\n\tylimits = group_count == 3 ? NULL : &resource->limits[3];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[2], ylimits);\n\tif (group_count < 5)\n\t\treturn;\n\n\treg = ipa_reg(ipa, DST_RSRC_GRP_45_RSRC_TYPE);\n\tylimits = group_count == 5 ? NULL : &resource->limits[5];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[4], ylimits);\n\tif (group_count < 7)\n\t\treturn;\n\n\treg = ipa_reg(ipa, DST_RSRC_GRP_67_RSRC_TYPE);\n\tylimits = group_count == 7 ? NULL : &resource->limits[7];\n\tipa_resource_config_common(ipa, resource_type, reg,\n\t\t\t\t   &resource->limits[6], ylimits);\n}\n\n \nint ipa_resource_config(struct ipa *ipa, const struct ipa_resource_data *data)\n{\n\tu32 i;\n\n\tif (!ipa_resource_limits_valid(ipa, data))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < data->resource_src_count; i++)\n\t\tipa_resource_config_src(ipa, i, data);\n\n\tfor (i = 0; i < data->resource_dst_count; i++)\n\t\tipa_resource_config_dst(ipa, i, data);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}