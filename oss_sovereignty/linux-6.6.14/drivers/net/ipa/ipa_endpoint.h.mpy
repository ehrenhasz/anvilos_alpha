{
  "module_name": "ipa_endpoint.h",
  "hash_id": "42794055bfa16badcaf4456f9b94cbc262d5ba3beb86ab43bc915c6a572a0a54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_endpoint.h",
  "human_readable_source": " \n\n \n#ifndef _IPA_ENDPOINT_H_\n#define _IPA_ENDPOINT_H_\n\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/if_ether.h>\n\n#include \"gsi.h\"\n#include \"ipa_reg.h\"\n\nstruct net_device;\nstruct sk_buff;\n\nstruct ipa;\nstruct ipa_gsi_endpoint_data;\n\n \n#define IPA_AGGR_GRANULARITY\t\t500\t \n\n#define IPA_MTU\t\t\tETH_DATA_LEN\n\nenum ipa_endpoint_name {\n\tIPA_ENDPOINT_AP_COMMAND_TX,\n\tIPA_ENDPOINT_AP_LAN_RX,\n\tIPA_ENDPOINT_AP_MODEM_TX,\n\tIPA_ENDPOINT_AP_MODEM_RX,\n\tIPA_ENDPOINT_MODEM_COMMAND_TX,\n\tIPA_ENDPOINT_MODEM_LAN_TX,\n\tIPA_ENDPOINT_MODEM_LAN_RX,\n\tIPA_ENDPOINT_MODEM_AP_TX,\n\tIPA_ENDPOINT_MODEM_AP_RX,\n\tIPA_ENDPOINT_MODEM_DL_NLO_TX,\n\tIPA_ENDPOINT_COUNT,\t \n};\n\n#define IPA_ENDPOINT_MAX\t\t36\t \n\n \nstruct ipa_endpoint_tx {\n\tenum ipa_seq_type seq_type;\n\tenum ipa_seq_rep_type seq_rep_type;\n\tenum ipa_endpoint_name status_endpoint;\n};\n\n \nstruct ipa_endpoint_rx {\n\tu32 buffer_size;\n\tu32 pad_align;\n\tu32 aggr_time_limit;\n\tbool aggr_hard_limit;\n\tbool aggr_close_eof;\n\tbool holb_drop;\n};\n\n \nstruct ipa_endpoint_config {\n\tu32 resource_group;\n\tbool checksum;\n\tbool qmap;\n\tbool aggregation;\n\tbool status_enable;\n\tbool dma_mode;\n\tenum ipa_endpoint_name dma_endpoint;\n\tunion {\n\t\tstruct ipa_endpoint_tx tx;\n\t\tstruct ipa_endpoint_rx rx;\n\t};\n};\n\n \nenum ipa_replenish_flag {\n\tIPA_REPLENISH_ENABLED,\n\tIPA_REPLENISH_ACTIVE,\n\tIPA_REPLENISH_COUNT,\t \n};\n\n \nstruct ipa_endpoint {\n\tstruct ipa *ipa;\n\tenum gsi_ee_id ee_id;\n\tu32 channel_id;\n\tu32 endpoint_id;\n\tbool toward_ipa;\n\tstruct ipa_endpoint_config config;\n\n\tu32 skb_frag_max;\t \n\tu32 evt_ring_id;\n\n\t \n\tstruct net_device *netdev;\n\n\t \n\tDECLARE_BITMAP(replenish_flags, IPA_REPLENISH_COUNT);\n\tu64 replenish_count;\n\tstruct delayed_work replenish_work;\t\t \n};\n\nvoid ipa_endpoint_modem_hol_block_clear_all(struct ipa *ipa);\n\nvoid ipa_endpoint_modem_pause_all(struct ipa *ipa, bool enable);\n\nint ipa_endpoint_modem_exception_reset_all(struct ipa *ipa);\n\nint ipa_endpoint_skb_tx(struct ipa_endpoint *endpoint, struct sk_buff *skb);\n\nint ipa_endpoint_enable_one(struct ipa_endpoint *endpoint);\nvoid ipa_endpoint_disable_one(struct ipa_endpoint *endpoint);\n\nvoid ipa_endpoint_suspend_one(struct ipa_endpoint *endpoint);\nvoid ipa_endpoint_resume_one(struct ipa_endpoint *endpoint);\n\nvoid ipa_endpoint_suspend(struct ipa *ipa);\nvoid ipa_endpoint_resume(struct ipa *ipa);\n\nvoid ipa_endpoint_setup(struct ipa *ipa);\nvoid ipa_endpoint_teardown(struct ipa *ipa);\n\nint ipa_endpoint_config(struct ipa *ipa);\nvoid ipa_endpoint_deconfig(struct ipa *ipa);\n\nvoid ipa_endpoint_default_route_set(struct ipa *ipa, u32 endpoint_id);\nvoid ipa_endpoint_default_route_clear(struct ipa *ipa);\n\nint ipa_endpoint_init(struct ipa *ipa, u32 count,\n\t\t      const struct ipa_gsi_endpoint_data *data);\nvoid ipa_endpoint_exit(struct ipa *ipa);\n\nvoid ipa_endpoint_trans_complete(struct ipa_endpoint *ipa,\n\t\t\t\t struct gsi_trans *trans);\nvoid ipa_endpoint_trans_release(struct ipa_endpoint *ipa,\n\t\t\t\tstruct gsi_trans *trans);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}