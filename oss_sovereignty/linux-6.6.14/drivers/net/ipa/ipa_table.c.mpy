{
  "module_name": "ipa_table.c",
  "hash_id": "b0fbfd45d215f30ac3c4de50d9c7be81d5cb84f60b5ba4d2580195af844a3079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_table.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bits.h>\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/io.h>\n#include <linux/build_bug.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n\n#include \"ipa.h\"\n#include \"ipa_version.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_table.h\"\n#include \"ipa_reg.h\"\n#include \"ipa_mem.h\"\n#include \"ipa_cmd.h\"\n#include \"gsi.h\"\n#include \"gsi_trans.h\"\n\n \n\n \n#define IPA_ZERO_RULE_SIZE\t\t(2 * sizeof(__le32))\n\n \nstatic void ipa_table_validate_build(void)\n{\n\t \n\tBUILD_BUG_ON(sizeof(dma_addr_t) > sizeof(__le64));\n\n\t \n\tBUILD_BUG_ON(IPA_ZERO_RULE_SIZE != sizeof(__le64));\n}\n\nstatic const struct ipa_mem *\nipa_table_mem(struct ipa *ipa, bool filter, bool hashed, bool ipv6)\n{\n\tenum ipa_mem_id mem_id;\n\n\tmem_id = filter ? hashed ? ipv6 ? IPA_MEM_V6_FILTER_HASHED\n\t\t\t\t\t: IPA_MEM_V4_FILTER_HASHED\n\t\t\t\t : ipv6 ? IPA_MEM_V6_FILTER\n\t\t\t\t\t: IPA_MEM_V4_FILTER\n\t\t\t: hashed ? ipv6 ? IPA_MEM_V6_ROUTE_HASHED\n\t\t\t\t\t: IPA_MEM_V4_ROUTE_HASHED\n\t\t\t\t : ipv6 ? IPA_MEM_V6_ROUTE\n\t\t\t\t\t: IPA_MEM_V4_ROUTE;\n\n\treturn ipa_mem_find(ipa, mem_id);\n}\n\nbool ipa_filtered_valid(struct ipa *ipa, u64 filtered)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tu32 count;\n\n\tif (!filtered) {\n\t\tdev_err(dev, \"at least one filtering endpoint is required\\n\");\n\n\t\treturn false;\n\t}\n\n\tcount = hweight64(filtered);\n\tif (count > ipa->filter_count) {\n\t\tdev_err(dev, \"too many filtering endpoints (%u > %u)\\n\",\n\t\t\tcount, ipa->filter_count);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic dma_addr_t ipa_table_addr(struct ipa *ipa, bool filter_mask, u16 count)\n{\n\tu32 skip;\n\n\tif (!count)\n\t\treturn 0;\n\n\tWARN_ON(count > max_t(u32, ipa->filter_count, ipa->route_count));\n\n\t \n\tskip = filter_mask ? 1 : 2;\n\n\treturn ipa->table_addr + skip * sizeof(*ipa->table_virt);\n}\n\nstatic void ipa_table_reset_add(struct gsi_trans *trans, bool filter,\n\t\t\t\tbool hashed, bool ipv6, u16 first, u16 count)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tconst struct ipa_mem *mem;\n\tdma_addr_t addr;\n\tu32 offset;\n\tu16 size;\n\n\t \n\tmem = ipa_table_mem(ipa, filter, hashed, ipv6);\n\tif (!mem || !mem->size)\n\t\treturn;\n\n\tif (filter)\n\t\tfirst++;\t \n\n\toffset = mem->offset + first * sizeof(__le64);\n\tsize = count * sizeof(__le64);\n\taddr = ipa_table_addr(ipa, false, count);\n\n\tipa_cmd_dma_shared_mem_add(trans, offset, size, addr, true);\n}\n\n \nstatic int\nipa_filter_reset_table(struct ipa *ipa, bool hashed, bool ipv6, bool modem)\n{\n\tu64 ep_mask = ipa->filtered;\n\tstruct gsi_trans *trans;\n\tenum gsi_ee_id ee_id;\n\n\ttrans = ipa_cmd_trans_alloc(ipa, hweight64(ep_mask));\n\tif (!trans) {\n\t\tdev_err(&ipa->pdev->dev,\n\t\t\t\"no transaction for %s filter reset\\n\",\n\t\t\tmodem ? \"modem\" : \"AP\");\n\t\treturn -EBUSY;\n\t}\n\n\tee_id = modem ? GSI_EE_MODEM : GSI_EE_AP;\n\twhile (ep_mask) {\n\t\tu32 endpoint_id = __ffs(ep_mask);\n\t\tstruct ipa_endpoint *endpoint;\n\n\t\tep_mask ^= BIT(endpoint_id);\n\n\t\tendpoint = &ipa->endpoint[endpoint_id];\n\t\tif (endpoint->ee_id != ee_id)\n\t\t\tcontinue;\n\n\t\tipa_table_reset_add(trans, true, hashed, ipv6, endpoint_id, 1);\n\t}\n\n\tgsi_trans_commit_wait(trans);\n\n\treturn 0;\n}\n\n \nstatic int ipa_filter_reset(struct ipa *ipa, bool modem)\n{\n\tint ret;\n\n\tret = ipa_filter_reset_table(ipa, false, false, modem);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ipa_filter_reset_table(ipa, false, true, modem);\n\tif (ret || !ipa_table_hash_support(ipa))\n\t\treturn ret;\n\n\tret = ipa_filter_reset_table(ipa, true, false, modem);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ipa_filter_reset_table(ipa, true, true, modem);\n}\n\n \nstatic int ipa_route_reset(struct ipa *ipa, bool modem)\n{\n\tbool hash_support = ipa_table_hash_support(ipa);\n\tu32 modem_route_count = ipa->modem_route_count;\n\tstruct gsi_trans *trans;\n\tu16 first;\n\tu16 count;\n\n\ttrans = ipa_cmd_trans_alloc(ipa, hash_support ? 4 : 2);\n\tif (!trans) {\n\t\tdev_err(&ipa->pdev->dev,\n\t\t\t\"no transaction for %s route reset\\n\",\n\t\t\tmodem ? \"modem\" : \"AP\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (modem) {\n\t\tfirst = 0;\n\t\tcount = modem_route_count;\n\t} else {\n\t\tfirst = modem_route_count;\n\t\tcount = ipa->route_count - modem_route_count;\n\t}\n\n\tipa_table_reset_add(trans, false, false, false, first, count);\n\tipa_table_reset_add(trans, false, false, true, first, count);\n\n\tif (hash_support) {\n\t\tipa_table_reset_add(trans, false, true, false, first, count);\n\t\tipa_table_reset_add(trans, false, true, true, first, count);\n\t}\n\n\tgsi_trans_commit_wait(trans);\n\n\treturn 0;\n}\n\nvoid ipa_table_reset(struct ipa *ipa, bool modem)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tconst char *ee_name;\n\tint ret;\n\n\tee_name = modem ? \"modem\" : \"AP\";\n\n\t \n\tret = ipa_filter_reset(ipa, modem);\n\tif (ret)\n\t\tdev_err(dev, \"error %d resetting filter table for %s\\n\",\n\t\t\t\tret, ee_name);\n\n\tret = ipa_route_reset(ipa, modem);\n\tif (ret)\n\t\tdev_err(dev, \"error %d resetting route table for %s\\n\",\n\t\t\t\tret, ee_name);\n}\n\nint ipa_table_hash_flush(struct ipa *ipa)\n{\n\tstruct gsi_trans *trans;\n\tconst struct reg *reg;\n\tu32 val;\n\n\tif (!ipa_table_hash_support(ipa))\n\t\treturn 0;\n\n\ttrans = ipa_cmd_trans_alloc(ipa, 1);\n\tif (!trans) {\n\t\tdev_err(&ipa->pdev->dev, \"no transaction for hash flush\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (ipa->version < IPA_VERSION_5_0) {\n\t\treg = ipa_reg(ipa, FILT_ROUT_HASH_FLUSH);\n\n\t\tval = reg_bit(reg, IPV6_ROUTER_HASH);\n\t\tval |= reg_bit(reg, IPV6_FILTER_HASH);\n\t\tval |= reg_bit(reg, IPV4_ROUTER_HASH);\n\t\tval |= reg_bit(reg, IPV4_FILTER_HASH);\n\t} else {\n\t\treg = ipa_reg(ipa, FILT_ROUT_CACHE_FLUSH);\n\n\t\t \n\t\tval = reg_bit(reg, ROUTER_CACHE);\n\t\tval |= reg_bit(reg, FILTER_CACHE);\n\t}\n\n\tipa_cmd_register_write_add(trans, reg_offset(reg), val, val, false);\n\n\tgsi_trans_commit_wait(trans);\n\n\treturn 0;\n}\n\nstatic void ipa_table_init_add(struct gsi_trans *trans, bool filter, bool ipv6)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tconst struct ipa_mem *hash_mem;\n\tenum ipa_cmd_opcode opcode;\n\tconst struct ipa_mem *mem;\n\tdma_addr_t hash_addr;\n\tdma_addr_t addr;\n\tu32 hash_offset;\n\tu32 zero_offset;\n\tu16 hash_count;\n\tu32 zero_size;\n\tu16 hash_size;\n\tu16 count;\n\tu16 size;\n\n\topcode = filter ? ipv6 ? IPA_CMD_IP_V6_FILTER_INIT\n\t\t\t       : IPA_CMD_IP_V4_FILTER_INIT\n\t\t\t: ipv6 ? IPA_CMD_IP_V6_ROUTING_INIT\n\t\t\t       : IPA_CMD_IP_V4_ROUTING_INIT;\n\n\t \n\tmem = ipa_table_mem(ipa, filter, false, ipv6);\n\thash_mem = ipa_table_mem(ipa, filter, true, ipv6);\n\thash_offset = hash_mem ? hash_mem->offset : 0;\n\n\t \n\tif (filter) {\n\t\t \n\t\tcount = 1 + hweight64(ipa->filtered);\n\t\thash_count = hash_mem && hash_mem->size ? count : 0;\n\t} else {\n\t\t \n\t\tcount = mem->size / sizeof(__le64);\n\t\thash_count = hash_mem ? hash_mem->size / sizeof(__le64) : 0;\n\t}\n\tsize = count * sizeof(__le64);\n\thash_size = hash_count * sizeof(__le64);\n\n\taddr = ipa_table_addr(ipa, filter, count);\n\thash_addr = ipa_table_addr(ipa, filter, hash_count);\n\n\tipa_cmd_table_init_add(trans, opcode, size, mem->offset, addr,\n\t\t\t       hash_size, hash_offset, hash_addr);\n\tif (!filter)\n\t\treturn;\n\n\t \n\tzero_offset = mem->offset + size;\n\tzero_size = mem->size - size;\n\tipa_cmd_dma_shared_mem_add(trans, zero_offset, zero_size,\n\t\t\t\t   ipa->zero_addr, true);\n\tif (!hash_size)\n\t\treturn;\n\n\t \n\tzero_offset = hash_offset + hash_size;\n\tzero_size = hash_mem->size - hash_size;\n\tipa_cmd_dma_shared_mem_add(trans, zero_offset, zero_size,\n\t\t\t\t   ipa->zero_addr, true);\n}\n\nint ipa_table_setup(struct ipa *ipa)\n{\n\tstruct gsi_trans *trans;\n\n\t \n\ttrans = ipa_cmd_trans_alloc(ipa, 8);\n\tif (!trans) {\n\t\tdev_err(&ipa->pdev->dev, \"no transaction for table setup\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tipa_table_init_add(trans, false, false);\n\tipa_table_init_add(trans, false, true);\n\tipa_table_init_add(trans, true, false);\n\tipa_table_init_add(trans, true, true);\n\n\tgsi_trans_commit_wait(trans);\n\n\treturn 0;\n}\n\n \nstatic void ipa_filter_tuple_zero(struct ipa_endpoint *endpoint)\n{\n\tu32 endpoint_id = endpoint->endpoint_id;\n\tstruct ipa *ipa = endpoint->ipa;\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 val;\n\n\tif (ipa->version < IPA_VERSION_5_0) {\n\t\treg = ipa_reg(ipa, ENDP_FILTER_ROUTER_HSH_CFG);\n\n\t\toffset = reg_n_offset(reg, endpoint_id);\n\t\tval = ioread32(endpoint->ipa->reg_virt + offset);\n\n\t\t \n\t\tval &= ~reg_fmask(reg, FILTER_HASH_MSK_ALL);\n\t} else {\n\t\t \n\t\treg = ipa_reg(ipa, ENDP_FILTER_CACHE_CFG);\n\t\toffset = reg_n_offset(reg, endpoint_id);\n\n\t\t \n\t\tval = 0;\n\t}\n\n\tiowrite32(val, endpoint->ipa->reg_virt + offset);\n}\n\n \nstatic void ipa_filter_config(struct ipa *ipa, bool modem)\n{\n\tenum gsi_ee_id ee_id = modem ? GSI_EE_MODEM : GSI_EE_AP;\n\tu64 ep_mask = ipa->filtered;\n\n\tif (!ipa_table_hash_support(ipa))\n\t\treturn;\n\n\twhile (ep_mask) {\n\t\tu32 endpoint_id = __ffs(ep_mask);\n\t\tstruct ipa_endpoint *endpoint;\n\n\t\tep_mask ^= BIT(endpoint_id);\n\n\t\tendpoint = &ipa->endpoint[endpoint_id];\n\t\tif (endpoint->ee_id == ee_id)\n\t\t\tipa_filter_tuple_zero(endpoint);\n\t}\n}\n\nstatic bool ipa_route_id_modem(struct ipa *ipa, u32 route_id)\n{\n\treturn route_id < ipa->modem_route_count;\n}\n\n \nstatic void ipa_route_tuple_zero(struct ipa *ipa, u32 route_id)\n{\n\tconst struct reg *reg;\n\tu32 offset;\n\tu32 val;\n\n\tif (ipa->version < IPA_VERSION_5_0) {\n\t\treg = ipa_reg(ipa, ENDP_FILTER_ROUTER_HSH_CFG);\n\t\toffset = reg_n_offset(reg, route_id);\n\n\t\tval = ioread32(ipa->reg_virt + offset);\n\n\t\t \n\t\tval &= ~reg_fmask(reg, ROUTER_HASH_MSK_ALL);\n\t} else {\n\t\t \n\t\treg = ipa_reg(ipa, ENDP_ROUTER_CACHE_CFG);\n\t\toffset = reg_n_offset(reg, route_id);\n\n\t\t \n\t\tval = 0;\n\t}\n\n\tiowrite32(val, ipa->reg_virt + offset);\n}\n\n \nstatic void ipa_route_config(struct ipa *ipa, bool modem)\n{\n\tu32 route_id;\n\n\tif (!ipa_table_hash_support(ipa))\n\t\treturn;\n\n\tfor (route_id = 0; route_id < ipa->route_count; route_id++)\n\t\tif (ipa_route_id_modem(ipa, route_id) == modem)\n\t\t\tipa_route_tuple_zero(ipa, route_id);\n}\n\n \nvoid ipa_table_config(struct ipa *ipa)\n{\n\tipa_filter_config(ipa, false);\n\tipa_filter_config(ipa, true);\n\tipa_route_config(ipa, false);\n\tipa_route_config(ipa, true);\n}\n\n \nbool ipa_table_mem_valid(struct ipa *ipa, bool filter)\n{\n\tbool hash_support = ipa_table_hash_support(ipa);\n\tconst struct ipa_mem *mem_hashed;\n\tconst struct ipa_mem *mem_ipv4;\n\tconst struct ipa_mem *mem_ipv6;\n\tu32 count;\n\n\t \n\tmem_ipv4 = ipa_table_mem(ipa, filter, false, false);\n\tif (!mem_ipv4)\n\t\treturn false;\n\n\tmem_ipv6 = ipa_table_mem(ipa, filter, false, true);\n\tif (!mem_ipv6)\n\t\treturn false;\n\n\tif (mem_ipv4->size != mem_ipv6->size)\n\t\treturn false;\n\n\t \n\tcount = mem_ipv4->size / sizeof(__le64);\n\tif (count < 2)\n\t\treturn false;\n\tif (filter)\n\t\tipa->filter_count = count - 1;\t \n\telse\n\t\tipa->route_count = count;\n\n\t \n\tif (!ipa_cmd_table_init_valid(ipa, mem_ipv4, !filter))\n\t\treturn false;\n\n\t \n\tif (filter) {\n\t\t \n\t\tif (count < 1 + hweight64(ipa->filtered))\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\tif (count < ipa->modem_route_count + 1)\n\t\t\treturn false;\n\t}\n\n\t \n\tmem_hashed = ipa_table_mem(ipa, filter, true, false);\n\tif (hash_support) {\n\t\tif (!mem_hashed || mem_hashed->size != mem_ipv4->size)\n\t\t\treturn false;\n\t} else {\n\t\tif (mem_hashed && mem_hashed->size)\n\t\t\treturn false;\n\t}\n\n\t \n\tmem_hashed = ipa_table_mem(ipa, filter, true, true);\n\tif (hash_support) {\n\t\tif (!mem_hashed || mem_hashed->size != mem_ipv6->size)\n\t\t\treturn false;\n\t} else {\n\t\tif (mem_hashed && mem_hashed->size)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint ipa_table_init(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tdma_addr_t addr;\n\t__le64 le_addr;\n\t__le64 *virt;\n\tsize_t size;\n\tu32 count;\n\n\tipa_table_validate_build();\n\n\tcount = max_t(u32, ipa->filter_count, ipa->route_count);\n\n\t \n\tsize = IPA_ZERO_RULE_SIZE + (1 + count) * sizeof(__le64);\n\tvirt = dma_alloc_coherent(dev, size, &addr, GFP_KERNEL);\n\tif (!virt)\n\t\treturn -ENOMEM;\n\n\tipa->table_virt = virt;\n\tipa->table_addr = addr;\n\n\t \n\t*virt++ = 0;\n\n\t \n\tif (ipa->version < IPA_VERSION_5_0)\n\t\t*virt++ = cpu_to_le64(ipa->filtered << 1);\n\telse\n\t\t*virt++ = cpu_to_le64(ipa->filtered);\n\n\t \n\tle_addr = cpu_to_le64(addr);\n\twhile (count--)\n\t\t*virt++ = le_addr;\n\n\treturn 0;\n}\n\nvoid ipa_table_exit(struct ipa *ipa)\n{\n\tu32 count = max_t(u32, 1 + ipa->filter_count, ipa->route_count);\n\tstruct device *dev = &ipa->pdev->dev;\n\tsize_t size;\n\n\tsize = IPA_ZERO_RULE_SIZE + (1 + count) * sizeof(__le64);\n\n\tdma_free_coherent(dev, size, ipa->table_virt, ipa->table_addr);\n\tipa->table_addr = 0;\n\tipa->table_virt = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}