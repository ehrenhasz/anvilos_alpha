{
  "module_name": "ipa_qmi.c",
  "hash_id": "2d86ce7dc80d681b1346b2a5b103d2705fde6b103a5f8e6b5b042a4937d1b43c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_qmi.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/qrtr.h>\n#include <linux/soc/qcom/qmi.h>\n\n#include \"ipa.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_mem.h\"\n#include \"ipa_table.h\"\n#include \"ipa_modem.h\"\n#include \"ipa_qmi_msg.h\"\n\n \n\n#define IPA_HOST_SERVICE_SVC_ID\t\t0x31\n#define IPA_HOST_SVC_VERS\t\t1\n#define IPA_HOST_SERVICE_INS_ID\t\t1\n\n#define IPA_MODEM_SERVICE_SVC_ID\t0x31\n#define IPA_MODEM_SERVICE_INS_ID\t2\n#define IPA_MODEM_SVC_VERS\t\t1\n\n#define QMI_INIT_DRIVER_TIMEOUT\t\t60000\t \n\n \nstatic void ipa_server_init_complete(struct ipa_qmi *ipa_qmi)\n{\n\tstruct ipa *ipa = container_of(ipa_qmi, struct ipa, qmi);\n\tstruct qmi_handle *qmi = &ipa_qmi->server_handle;\n\tstruct sockaddr_qrtr *sq = &ipa_qmi->modem_sq;\n\tstruct ipa_init_complete_ind ind = { };\n\tint ret;\n\n\tind.status.result = QMI_RESULT_SUCCESS_V01;\n\tind.status.error = QMI_ERR_NONE_V01;\n\n\tret = qmi_send_indication(qmi, sq, IPA_QMI_INIT_COMPLETE,\n\t\t\t\t   IPA_QMI_INIT_COMPLETE_IND_SZ,\n\t\t\t\t   ipa_init_complete_ind_ei, &ind);\n\tif (ret)\n\t\tdev_err(&ipa->pdev->dev,\n\t\t\t\"error %d sending init complete indication\\n\", ret);\n\telse\n\t\tipa_qmi->indication_sent = true;\n}\n\n \nstatic void ipa_qmi_indication(struct ipa_qmi *ipa_qmi)\n{\n\tif (!ipa_qmi->indication_requested)\n\t\treturn;\n\n\tif (ipa_qmi->indication_sent)\n\t\treturn;\n\n\tipa_server_init_complete(ipa_qmi);\n}\n\n \nstatic void ipa_qmi_ready(struct ipa_qmi *ipa_qmi)\n{\n\tstruct ipa *ipa;\n\tint ret;\n\n\t \n\tif (!ipa_qmi->modem_ready || !ipa_qmi->uc_ready)\n\t\treturn;\n\n\t \n\tipa_qmi_indication(ipa_qmi);\n\n\t \n\tif (ipa_qmi->initial_boot) {\n\t\tif (!ipa_qmi->indication_sent)\n\t\t\treturn;\n\n\t\t \n\t\tipa_qmi->initial_boot = false;\n\t}\n\n\t \n\tipa = container_of(ipa_qmi, struct ipa, qmi);\n\tret = ipa_modem_start(ipa);\n\tif (ret)\n\t\tdev_err(&ipa->pdev->dev, \"error %d starting modem\\n\", ret);\n}\n\n \nstatic void ipa_server_bye(struct qmi_handle *qmi, unsigned int node)\n{\n\tstruct ipa_qmi *ipa_qmi;\n\n\tipa_qmi = container_of(qmi, struct ipa_qmi, server_handle);\n\n\t \n\tmemset(&ipa_qmi->modem_sq, 0, sizeof(ipa_qmi->modem_sq));\n\n\t \n\t \n\tipa_qmi->modem_ready = false;\n\tipa_qmi->indication_requested = false;\n\tipa_qmi->indication_sent = false;\n}\n\nstatic const struct qmi_ops ipa_server_ops = {\n\t.bye\t\t= ipa_server_bye,\n};\n\n \nstatic void ipa_server_indication_register(struct qmi_handle *qmi,\n\t\t\t\t\t   struct sockaddr_qrtr *sq,\n\t\t\t\t\t   struct qmi_txn *txn,\n\t\t\t\t\t   const void *decoded)\n{\n\tstruct ipa_indication_register_rsp rsp = { };\n\tstruct ipa_qmi *ipa_qmi;\n\tstruct ipa *ipa;\n\tint ret;\n\n\tipa_qmi = container_of(qmi, struct ipa_qmi, server_handle);\n\tipa = container_of(ipa_qmi, struct ipa, qmi);\n\n\trsp.rsp.result = QMI_RESULT_SUCCESS_V01;\n\trsp.rsp.error = QMI_ERR_NONE_V01;\n\n\tret = qmi_send_response(qmi, sq, txn, IPA_QMI_INDICATION_REGISTER,\n\t\t\t\tIPA_QMI_INDICATION_REGISTER_RSP_SZ,\n\t\t\t\tipa_indication_register_rsp_ei, &rsp);\n\tif (!ret) {\n\t\tipa_qmi->indication_requested = true;\n\t\tipa_qmi_ready(ipa_qmi);\t\t \n\t} else {\n\t\tdev_err(&ipa->pdev->dev,\n\t\t\t\"error %d sending register indication response\\n\", ret);\n\t}\n}\n\n \nstatic void ipa_server_driver_init_complete(struct qmi_handle *qmi,\n\t\t\t\t\t    struct sockaddr_qrtr *sq,\n\t\t\t\t\t    struct qmi_txn *txn,\n\t\t\t\t\t    const void *decoded)\n{\n\tstruct ipa_driver_init_complete_rsp rsp = { };\n\tstruct ipa_qmi *ipa_qmi;\n\tstruct ipa *ipa;\n\tint ret;\n\n\tipa_qmi = container_of(qmi, struct ipa_qmi, server_handle);\n\tipa = container_of(ipa_qmi, struct ipa, qmi);\n\n\trsp.rsp.result = QMI_RESULT_SUCCESS_V01;\n\trsp.rsp.error = QMI_ERR_NONE_V01;\n\n\tret = qmi_send_response(qmi, sq, txn, IPA_QMI_DRIVER_INIT_COMPLETE,\n\t\t\t\tIPA_QMI_DRIVER_INIT_COMPLETE_RSP_SZ,\n\t\t\t\tipa_driver_init_complete_rsp_ei, &rsp);\n\tif (!ret) {\n\t\tipa_qmi->uc_ready = true;\n\t\tipa_qmi_ready(ipa_qmi);\t\t \n\t} else {\n\t\tdev_err(&ipa->pdev->dev,\n\t\t\t\"error %d sending init complete response\\n\", ret);\n\t}\n}\n\n \nstatic const struct qmi_msg_handler ipa_server_msg_handlers[] = {\n\t{\n\t\t.type\t\t= QMI_REQUEST,\n\t\t.msg_id\t\t= IPA_QMI_INDICATION_REGISTER,\n\t\t.ei\t\t= ipa_indication_register_req_ei,\n\t\t.decoded_size\t= IPA_QMI_INDICATION_REGISTER_REQ_SZ,\n\t\t.fn\t\t= ipa_server_indication_register,\n\t},\n\t{\n\t\t.type\t\t= QMI_REQUEST,\n\t\t.msg_id\t\t= IPA_QMI_DRIVER_INIT_COMPLETE,\n\t\t.ei\t\t= ipa_driver_init_complete_req_ei,\n\t\t.decoded_size\t= IPA_QMI_DRIVER_INIT_COMPLETE_REQ_SZ,\n\t\t.fn\t\t= ipa_server_driver_init_complete,\n\t},\n\t{ },\n};\n\n \nstatic void ipa_client_init_driver(struct qmi_handle *qmi,\n\t\t\t\t   struct sockaddr_qrtr *sq,\n\t\t\t\t   struct qmi_txn *txn, const void *decoded)\n{\n\ttxn->result = 0;\t \n\tcomplete(&txn->completion);\n}\n\n \nstatic const struct qmi_msg_handler ipa_client_msg_handlers[] = {\n\t{\n\t\t.type\t\t= QMI_RESPONSE,\n\t\t.msg_id\t\t= IPA_QMI_INIT_DRIVER,\n\t\t.ei\t\t= ipa_init_modem_driver_rsp_ei,\n\t\t.decoded_size\t= IPA_QMI_INIT_DRIVER_RSP_SZ,\n\t\t.fn\t\t= ipa_client_init_driver,\n\t},\n\t{ },\n};\n\n \nstatic const struct ipa_init_modem_driver_req *\ninit_modem_driver_req(struct ipa_qmi *ipa_qmi)\n{\n\tstruct ipa *ipa = container_of(ipa_qmi, struct ipa, qmi);\n\tu32 modem_route_count = ipa->modem_route_count;\n\tstatic struct ipa_init_modem_driver_req req;\n\tconst struct ipa_mem *mem;\n\n\t \n\treq.skip_uc_load_valid = 1;\n\treq.skip_uc_load = ipa->uc_loaded ? 1 : 0;\n\n\t \n\tif (req.platform_type_valid)\n\t\treturn &req;\n\n\treq.platform_type_valid = 1;\n\treq.platform_type = IPA_QMI_PLATFORM_TYPE_MSM_ANDROID;\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_MODEM_HEADER);\n\tif (mem->size) {\n\t\treq.hdr_tbl_info_valid = 1;\n\t\treq.hdr_tbl_info.start = ipa->mem_offset + mem->offset;\n\t\treq.hdr_tbl_info.end = req.hdr_tbl_info.start + mem->size - 1;\n\t}\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V4_ROUTE);\n\treq.v4_route_tbl_info_valid = 1;\n\treq.v4_route_tbl_info.start = ipa->mem_offset + mem->offset;\n\treq.v4_route_tbl_info.end = modem_route_count - 1;\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V6_ROUTE);\n\treq.v6_route_tbl_info_valid = 1;\n\treq.v6_route_tbl_info.start = ipa->mem_offset + mem->offset;\n\treq.v6_route_tbl_info.end = modem_route_count - 1;\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V4_FILTER);\n\treq.v4_filter_tbl_start_valid = 1;\n\treq.v4_filter_tbl_start = ipa->mem_offset + mem->offset;\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V6_FILTER);\n\treq.v6_filter_tbl_start_valid = 1;\n\treq.v6_filter_tbl_start = ipa->mem_offset + mem->offset;\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_MODEM);\n\tif (mem->size) {\n\t\treq.modem_mem_info_valid = 1;\n\t\treq.modem_mem_info.start = ipa->mem_offset + mem->offset;\n\t\treq.modem_mem_info.size = mem->size;\n\t}\n\n\treq.ctrl_comm_dest_end_pt_valid = 1;\n\treq.ctrl_comm_dest_end_pt =\n\t\tipa->name_map[IPA_ENDPOINT_AP_MODEM_RX]->endpoint_id;\n\n\t \n\n\tmem = ipa_mem_find(ipa, IPA_MEM_MODEM_PROC_CTX);\n\tif (mem->size) {\n\t\treq.hdr_proc_ctx_tbl_info_valid = 1;\n\t\treq.hdr_proc_ctx_tbl_info.start =\n\t\t\tipa->mem_offset + mem->offset;\n\t\treq.hdr_proc_ctx_tbl_info.end =\n\t\t\treq.hdr_proc_ctx_tbl_info.start + mem->size - 1;\n\t}\n\n\t \n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V4_ROUTE_HASHED);\n\tif (mem->size) {\n\t\treq.v4_hash_route_tbl_info_valid = 1;\n\t\treq.v4_hash_route_tbl_info.start =\n\t\t\t\tipa->mem_offset + mem->offset;\n\t\treq.v4_hash_route_tbl_info.end = modem_route_count - 1;\n\t}\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V6_ROUTE_HASHED);\n\tif (mem->size) {\n\t\treq.v6_hash_route_tbl_info_valid = 1;\n\t\treq.v6_hash_route_tbl_info.start =\n\t\t\tipa->mem_offset + mem->offset;\n\t\treq.v6_hash_route_tbl_info.end = modem_route_count - 1;\n\t}\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V4_FILTER_HASHED);\n\tif (mem->size) {\n\t\treq.v4_hash_filter_tbl_start_valid = 1;\n\t\treq.v4_hash_filter_tbl_start = ipa->mem_offset + mem->offset;\n\t}\n\n\tmem = ipa_mem_find(ipa, IPA_MEM_V6_FILTER_HASHED);\n\tif (mem->size) {\n\t\treq.v6_hash_filter_tbl_start_valid = 1;\n\t\treq.v6_hash_filter_tbl_start = ipa->mem_offset + mem->offset;\n\t}\n\n\t \n\tif (ipa->version >= IPA_VERSION_4_0) {\n\t\tmem = ipa_mem_find(ipa, IPA_MEM_STATS_QUOTA_MODEM);\n\t\tif (mem->size) {\n\t\t\treq.hw_stats_quota_base_addr_valid = 1;\n\t\t\treq.hw_stats_quota_base_addr =\n\t\t\t\tipa->mem_offset + mem->offset;\n\t\t\treq.hw_stats_quota_size_valid = 1;\n\t\t\treq.hw_stats_quota_size = ipa->mem_offset + mem->size;\n\t\t}\n\n\t\t \n\t\tmem = ipa_mem_find(ipa, IPA_MEM_STATS_DROP);\n\t\tif (mem && mem->size) {\n\t\t\treq.hw_stats_drop_base_addr_valid = 1;\n\t\t\treq.hw_stats_drop_base_addr =\n\t\t\t\tipa->mem_offset + mem->offset;\n\t\t\treq.hw_stats_drop_size_valid = 1;\n\t\t\treq.hw_stats_drop_size = ipa->mem_offset + mem->size;\n\t\t}\n\t}\n\n\treturn &req;\n}\n\n \nstatic void ipa_client_init_driver_work(struct work_struct *work)\n{\n\tunsigned long timeout = msecs_to_jiffies(QMI_INIT_DRIVER_TIMEOUT);\n\tconst struct ipa_init_modem_driver_req *req;\n\tstruct ipa_qmi *ipa_qmi;\n\tstruct qmi_handle *qmi;\n\tstruct qmi_txn txn;\n\tstruct device *dev;\n\tstruct ipa *ipa;\n\tint ret;\n\n\tipa_qmi = container_of(work, struct ipa_qmi, init_driver_work);\n\tqmi = &ipa_qmi->client_handle;\n\n\tipa = container_of(ipa_qmi, struct ipa, qmi);\n\tdev = &ipa->pdev->dev;\n\n\tret = qmi_txn_init(qmi, &txn, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error %d preparing init driver request\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\treq = init_modem_driver_req(ipa_qmi);\n\tret = qmi_send_request(qmi, &ipa_qmi->modem_sq, &txn,\n\t\t\t       IPA_QMI_INIT_DRIVER, IPA_QMI_INIT_DRIVER_REQ_SZ,\n\t\t\t       ipa_init_modem_driver_req_ei, req);\n\tif (ret)\n\t\tdev_err(dev, \"error %d sending init driver request\\n\", ret);\n\telse if ((ret = qmi_txn_wait(&txn, timeout)))\n\t\tdev_err(dev, \"error %d awaiting init driver response\\n\", ret);\n\n\tif (!ret) {\n\t\tipa_qmi->modem_ready = true;\n\t\tipa_qmi_ready(ipa_qmi);\t\t \n\t} else {\n\t\t \n\t\tqmi_txn_cancel(&txn);\n\t}\n}\n\n \nstatic int\nipa_client_new_server(struct qmi_handle *qmi, struct qmi_service *svc)\n{\n\tstruct ipa_qmi *ipa_qmi;\n\n\tipa_qmi = container_of(qmi, struct ipa_qmi, client_handle);\n\n\tipa_qmi->modem_sq.sq_family = AF_QIPCRTR;\n\tipa_qmi->modem_sq.sq_node = svc->node;\n\tipa_qmi->modem_sq.sq_port = svc->port;\n\n\tschedule_work(&ipa_qmi->init_driver_work);\n\n\treturn 0;\n}\n\nstatic const struct qmi_ops ipa_client_ops = {\n\t.new_server\t= ipa_client_new_server,\n};\n\n \nint ipa_qmi_setup(struct ipa *ipa)\n{\n\tstruct ipa_qmi *ipa_qmi = &ipa->qmi;\n\tint ret;\n\n\tipa_qmi->initial_boot = true;\n\n\t \n\tret = qmi_handle_init(&ipa_qmi->server_handle,\n\t\t\t      IPA_QMI_SERVER_MAX_RCV_SZ, &ipa_server_ops,\n\t\t\t      ipa_server_msg_handlers);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qmi_add_server(&ipa_qmi->server_handle, IPA_HOST_SERVICE_SVC_ID,\n\t\t\t     IPA_HOST_SVC_VERS, IPA_HOST_SERVICE_INS_ID);\n\tif (ret)\n\t\tgoto err_server_handle_release;\n\n\t \n\tret = qmi_handle_init(&ipa_qmi->client_handle,\n\t\t\t      IPA_QMI_CLIENT_MAX_RCV_SZ, &ipa_client_ops,\n\t\t\t      ipa_client_msg_handlers);\n\tif (ret)\n\t\tgoto err_server_handle_release;\n\n\t \n\tINIT_WORK(&ipa_qmi->init_driver_work, ipa_client_init_driver_work);\n\n\tret = qmi_add_lookup(&ipa_qmi->client_handle, IPA_MODEM_SERVICE_SVC_ID,\n\t\t\t     IPA_MODEM_SVC_VERS, IPA_MODEM_SERVICE_INS_ID);\n\tif (ret)\n\t\tgoto err_client_handle_release;\n\n\treturn 0;\n\nerr_client_handle_release:\n\t \n\tqmi_handle_release(&ipa_qmi->client_handle);\n\tmemset(&ipa_qmi->client_handle, 0, sizeof(ipa_qmi->client_handle));\nerr_server_handle_release:\n\t \n\tqmi_handle_release(&ipa_qmi->server_handle);\n\tmemset(&ipa_qmi->server_handle, 0, sizeof(ipa_qmi->server_handle));\n\n\treturn ret;\n}\n\n \nvoid ipa_qmi_teardown(struct ipa *ipa)\n{\n\tcancel_work_sync(&ipa->qmi.init_driver_work);\n\n\tqmi_handle_release(&ipa->qmi.client_handle);\n\tmemset(&ipa->qmi.client_handle, 0, sizeof(ipa->qmi.client_handle));\n\n\tqmi_handle_release(&ipa->qmi.server_handle);\n\tmemset(&ipa->qmi.server_handle, 0, sizeof(ipa->qmi.server_handle));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}