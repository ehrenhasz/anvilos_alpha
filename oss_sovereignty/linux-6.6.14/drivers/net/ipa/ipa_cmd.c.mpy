{
  "module_name": "ipa_cmd.c",
  "hash_id": "ba500d7d7d0879aa69db51efb862e654f69ca7a986bc15e6a80904608b6fc698",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_cmd.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/bitfield.h>\n#include <linux/dma-direction.h>\n\n#include \"gsi.h\"\n#include \"gsi_trans.h\"\n#include \"ipa.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_table.h\"\n#include \"ipa_cmd.h\"\n#include \"ipa_mem.h\"\n\n \n\n \nenum pipeline_clear_options {\n\tpipeline_clear_hps\t\t= 0x0,\n\tpipeline_clear_src_grp\t\t= 0x1,\n\tpipeline_clear_full\t\t= 0x2,\n};\n\n \n\nstruct ipa_cmd_hw_ip_fltrt_init {\n\t__le64 hash_rules_addr;\n\t__le64 flags;\n\t__le64 nhash_rules_addr;\n};\n\n \n#define IP_FLTRT_FLAGS_HASH_SIZE_FMASK\t\t\tGENMASK_ULL(11, 0)\n#define IP_FLTRT_FLAGS_HASH_ADDR_FMASK\t\t\tGENMASK_ULL(27, 12)\n#define IP_FLTRT_FLAGS_NHASH_SIZE_FMASK\t\t\tGENMASK_ULL(39, 28)\n#define IP_FLTRT_FLAGS_NHASH_ADDR_FMASK\t\t\tGENMASK_ULL(55, 40)\n\n \n\nstruct ipa_cmd_hw_hdr_init_local {\n\t__le64 hdr_table_addr;\n\t__le32 flags;\n\t__le32 reserved;\n};\n\n \n#define HDR_INIT_LOCAL_FLAGS_TABLE_SIZE_FMASK\t\tGENMASK(11, 0)\n#define HDR_INIT_LOCAL_FLAGS_HDR_ADDR_FMASK\t\tGENMASK(27, 12)\n\n \n\n \n#define REGISTER_WRITE_OPCODE_SKIP_CLEAR_FMASK\t\tGENMASK(8, 8)\n#define REGISTER_WRITE_OPCODE_CLEAR_OPTION_FMASK\tGENMASK(10, 9)\n\nstruct ipa_cmd_register_write {\n\t__le16 flags;\t\t \n\t__le16 offset;\n\t__le32 value;\n\t__le32 value_mask;\n\t__le32 clear_options;\t \n};\n\n \n \n#define REGISTER_WRITE_FLAGS_OFFSET_HIGH_FMASK\t\tGENMASK(14, 11)\n \n#define REGISTER_WRITE_FLAGS_SKIP_CLEAR_FMASK\t\tGENMASK(15, 15)\n\n \n#define REGISTER_WRITE_CLEAR_OPTIONS_FMASK\t\tGENMASK(1, 0)\n\n \n\nstruct ipa_cmd_ip_packet_init {\n\tu8 dest_endpoint;\t \n\tu8 reserved[7];\n};\n\n \n#define IPA_PACKET_INIT_DEST_ENDPOINT_FMASK\t\tGENMASK(4, 0)\n\n \n\n \n\n#define DMA_SHARED_MEM_OPCODE_SKIP_CLEAR_FMASK\t\tGENMASK(8, 8)\n#define DMA_SHARED_MEM_OPCODE_CLEAR_OPTION_FMASK\tGENMASK(10, 9)\n\nstruct ipa_cmd_hw_dma_mem_mem {\n\t__le16 clear_after_read;  \n\t__le16 size;\n\t__le16 local_addr;\n\t__le16 flags;\n\t__le64 system_addr;\n};\n\n \n#define DMA_SHARED_MEM_CLEAR_AFTER_READ\t\t\tGENMASK(15, 15)\n\n \n#define DMA_SHARED_MEM_FLAGS_DIRECTION_FMASK\t\tGENMASK(0, 0)\n \n#define DMA_SHARED_MEM_FLAGS_SKIP_CLEAR_FMASK\t\tGENMASK(1, 1)\n#define DMA_SHARED_MEM_FLAGS_CLEAR_OPTIONS_FMASK\tGENMASK(3, 2)\n\n \n\nstruct ipa_cmd_ip_packet_tag_status {\n\t__le64 tag;\n};\n\n#define IP_PACKET_TAG_STATUS_TAG_FMASK\t\t\tGENMASK_ULL(63, 16)\n\n \nunion ipa_cmd_payload {\n\tstruct ipa_cmd_hw_ip_fltrt_init table_init;\n\tstruct ipa_cmd_hw_hdr_init_local hdr_init_local;\n\tstruct ipa_cmd_register_write register_write;\n\tstruct ipa_cmd_ip_packet_init ip_packet_init;\n\tstruct ipa_cmd_hw_dma_mem_mem dma_shared_mem;\n\tstruct ipa_cmd_ip_packet_tag_status ip_packet_tag_status;\n};\n\nstatic void ipa_cmd_validate_build(void)\n{\n\t \n\t \n\tBUILD_BUG_ON(field_max(IP_FLTRT_FLAGS_HASH_SIZE_FMASK) !=\n\t\t     field_max(IP_FLTRT_FLAGS_NHASH_SIZE_FMASK));\n\tBUILD_BUG_ON(field_max(IP_FLTRT_FLAGS_HASH_ADDR_FMASK) !=\n\t\t     field_max(IP_FLTRT_FLAGS_NHASH_ADDR_FMASK));\n\n\t \n\tBUILD_BUG_ON(IPA_ENDPOINT_MAX - 1 > U8_MAX);\n}\n\n \nbool ipa_cmd_table_init_valid(struct ipa *ipa, const struct ipa_mem *mem,\n\t\t\t      bool route)\n{\n\tu32 offset_max = field_max(IP_FLTRT_FLAGS_NHASH_ADDR_FMASK);\n\tu32 size_max = field_max(IP_FLTRT_FLAGS_NHASH_SIZE_FMASK);\n\tconst char *table = route ? \"route\" : \"filter\";\n\tstruct device *dev = &ipa->pdev->dev;\n\tu32 size;\n\n\tsize = route ? ipa->route_count : ipa->filter_count + 1;\n\tsize *= sizeof(__le64);\n\n\t \n\tif (size > size_max) {\n\t\tdev_err(dev, \"%s table region size too large\\n\", table);\n\t\tdev_err(dev, \"    (0x%04x > 0x%04x)\\n\", size, size_max);\n\n\t\treturn false;\n\t}\n\n\t \n\tif (mem->offset > offset_max ||\n\t    ipa->mem_offset > offset_max - mem->offset) {\n\t\tdev_err(dev, \"%s table region offset too large\\n\", table);\n\t\tdev_err(dev, \"    (0x%04x + 0x%04x > 0x%04x)\\n\",\n\t\t\tipa->mem_offset, mem->offset, offset_max);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool ipa_cmd_header_init_local_valid(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\tconst struct ipa_mem *mem;\n\tu32 offset_max;\n\tu32 size_max;\n\tu32 offset;\n\tu32 size;\n\n\t \n\toffset_max = field_max(HDR_INIT_LOCAL_FLAGS_HDR_ADDR_FMASK);\n\tsize_max = field_max(HDR_INIT_LOCAL_FLAGS_TABLE_SIZE_FMASK);\n\n\t \n\tmem = ipa_mem_find(ipa, IPA_MEM_MODEM_HEADER);\n\toffset = mem->offset;\n\tsize = mem->size;\n\n\t \n\tif (offset > offset_max || ipa->mem_offset > offset_max - offset) {\n\t\tdev_err(dev, \"header table region offset too large\\n\");\n\t\tdev_err(dev, \"    (0x%04x + 0x%04x > 0x%04x)\\n\",\n\t\t\tipa->mem_offset, offset, offset_max);\n\n\t\treturn false;\n\t}\n\n\t \n\tmem = ipa_mem_find(ipa, IPA_MEM_AP_HEADER);\n\tif (mem)\n\t\tsize += mem->size;\n\n\t \n\tif (size > size_max) {\n\t\tdev_err(dev, \"header table region size too large\\n\");\n\t\tdev_err(dev, \"    (0x%04x > 0x%08x)\\n\", size, size_max);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool ipa_cmd_register_write_offset_valid(struct ipa *ipa,\n\t\t\t\t\t\tconst char *name, u32 offset)\n{\n\tstruct ipa_cmd_register_write *payload;\n\tstruct device *dev = &ipa->pdev->dev;\n\tu32 offset_max;\n\tu32 bit_count;\n\n\t \n\tbit_count = BITS_PER_BYTE * sizeof(payload->offset);\n\tif (ipa->version >= IPA_VERSION_4_0)\n\t\tbit_count += hweight32(REGISTER_WRITE_FLAGS_OFFSET_HIGH_FMASK);\n\tBUILD_BUG_ON(bit_count > 32);\n\toffset_max = ~0U >> (32 - bit_count);\n\n\t \n\tif (offset > offset_max || ipa->mem_offset > offset_max - offset) {\n\t\tdev_err(dev, \"%s offset too large 0x%04x + 0x%04x > 0x%04x)\\n\",\n\t\t\tname, ipa->mem_offset, offset, offset_max);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool ipa_cmd_register_write_valid(struct ipa *ipa)\n{\n\tconst struct reg *reg;\n\tconst char *name;\n\tu32 offset;\n\n\t \n\tif (ipa_table_hash_support(ipa)) {\n\t\tif (ipa->version < IPA_VERSION_5_0)\n\t\t\treg = ipa_reg(ipa, FILT_ROUT_HASH_FLUSH);\n\t\telse\n\t\t\treg = ipa_reg(ipa, FILT_ROUT_CACHE_FLUSH);\n\n\t\toffset = reg_offset(reg);\n\t\tname = \"filter/route hash flush\";\n\t\tif (!ipa_cmd_register_write_offset_valid(ipa, name, offset))\n\t\t\treturn false;\n\t}\n\n\t \n\treg = ipa_reg(ipa, ENDP_STATUS);\n\toffset = reg_n_offset(reg, IPA_ENDPOINT_COUNT - 1);\n\tname = \"maximal endpoint status\";\n\tif (!ipa_cmd_register_write_offset_valid(ipa, name, offset))\n\t\treturn false;\n\n\treturn true;\n}\n\nint ipa_cmd_pool_init(struct gsi_channel *channel, u32 tre_max)\n{\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tstruct device *dev = channel->gsi->dev;\n\n\t \n\treturn gsi_trans_pool_init_dma(dev, &trans_info->cmd_pool,\n\t\t\t\t       sizeof(union ipa_cmd_payload),\n\t\t\t\t       tre_max, channel->trans_tre_max);\n}\n\nvoid ipa_cmd_pool_exit(struct gsi_channel *channel)\n{\n\tstruct gsi_trans_info *trans_info = &channel->trans_info;\n\tstruct device *dev = channel->gsi->dev;\n\n\tgsi_trans_pool_exit_dma(dev, &trans_info->cmd_pool);\n}\n\nstatic union ipa_cmd_payload *\nipa_cmd_payload_alloc(struct ipa *ipa, dma_addr_t *addr)\n{\n\tstruct gsi_trans_info *trans_info;\n\tstruct ipa_endpoint *endpoint;\n\n\tendpoint = ipa->name_map[IPA_ENDPOINT_AP_COMMAND_TX];\n\ttrans_info = &ipa->gsi.channel[endpoint->channel_id].trans_info;\n\n\treturn gsi_trans_pool_alloc_dma(&trans_info->cmd_pool, addr);\n}\n\n \nvoid ipa_cmd_table_init_add(struct gsi_trans *trans,\n\t\t\t    enum ipa_cmd_opcode opcode, u16 size, u32 offset,\n\t\t\t    dma_addr_t addr, u16 hash_size, u32 hash_offset,\n\t\t\t    dma_addr_t hash_addr)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tstruct ipa_cmd_hw_ip_fltrt_init *payload;\n\tunion ipa_cmd_payload *cmd_payload;\n\tdma_addr_t payload_addr;\n\tu64 val;\n\n\t \n\toffset += ipa->mem_offset;\n\tval = u64_encode_bits(offset, IP_FLTRT_FLAGS_NHASH_ADDR_FMASK);\n\tval |= u64_encode_bits(size, IP_FLTRT_FLAGS_NHASH_SIZE_FMASK);\n\n\t \n\tif (hash_size) {\n\t\t \n\t\thash_offset += ipa->mem_offset;\n\t\tval |= u64_encode_bits(hash_offset,\n\t\t\t\t       IP_FLTRT_FLAGS_HASH_ADDR_FMASK);\n\t\tval |= u64_encode_bits(hash_size,\n\t\t\t\t       IP_FLTRT_FLAGS_HASH_SIZE_FMASK);\n\t}\n\n\tcmd_payload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\tpayload = &cmd_payload->table_init;\n\n\t \n\tif (hash_size)\n\t\tpayload->hash_rules_addr = cpu_to_le64(hash_addr);\n\tpayload->flags = cpu_to_le64(val);\n\tpayload->nhash_rules_addr = cpu_to_le64(addr);\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\n \nvoid ipa_cmd_hdr_init_local_add(struct gsi_trans *trans, u32 offset, u16 size,\n\t\t\t\tdma_addr_t addr)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tenum ipa_cmd_opcode opcode = IPA_CMD_HDR_INIT_LOCAL;\n\tstruct ipa_cmd_hw_hdr_init_local *payload;\n\tunion ipa_cmd_payload *cmd_payload;\n\tdma_addr_t payload_addr;\n\tu32 flags;\n\n\toffset += ipa->mem_offset;\n\n\t \n\tcmd_payload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\tpayload = &cmd_payload->hdr_init_local;\n\n\tpayload->hdr_table_addr = cpu_to_le64(addr);\n\tflags = u32_encode_bits(size, HDR_INIT_LOCAL_FLAGS_TABLE_SIZE_FMASK);\n\tflags |= u32_encode_bits(offset, HDR_INIT_LOCAL_FLAGS_HDR_ADDR_FMASK);\n\tpayload->flags = cpu_to_le32(flags);\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\nvoid ipa_cmd_register_write_add(struct gsi_trans *trans, u32 offset, u32 value,\n\t\t\t\tu32 mask, bool clear_full)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tstruct ipa_cmd_register_write *payload;\n\tunion ipa_cmd_payload *cmd_payload;\n\tu32 opcode = IPA_CMD_REGISTER_WRITE;\n\tdma_addr_t payload_addr;\n\tu32 clear_option;\n\tu32 options;\n\tu16 flags;\n\n\t \n\tclear_option = clear_full ? pipeline_clear_full : pipeline_clear_hps;\n\n\t \n\tif (ipa->version >= IPA_VERSION_4_0) {\n\t\tu16 offset_high;\n\t\tu32 val;\n\n\t\t \n\t\t \n\t\tval = u16_encode_bits(clear_option,\n\t\t\t\t      REGISTER_WRITE_OPCODE_CLEAR_OPTION_FMASK);\n\t\topcode |= val;\n\n\t\t \n\t\toffset_high = (u16)u32_get_bits(offset, GENMASK(19, 16));\n\t\toffset &= (1 << 16) - 1;\n\n\t\t \n\t\tflags = u16_encode_bits(offset_high,\n\t\t\t\tREGISTER_WRITE_FLAGS_OFFSET_HIGH_FMASK);\n\t\toptions = 0;\t \n\n\t} else {\n\t\tflags = 0;\t \n\t\toptions = u16_encode_bits(clear_option,\n\t\t\t\t\t  REGISTER_WRITE_CLEAR_OPTIONS_FMASK);\n\t}\n\n\tcmd_payload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\tpayload = &cmd_payload->register_write;\n\n\tpayload->flags = cpu_to_le16(flags);\n\tpayload->offset = cpu_to_le16((u16)offset);\n\tpayload->value = cpu_to_le32(value);\n\tpayload->value_mask = cpu_to_le32(mask);\n\tpayload->clear_options = cpu_to_le32(options);\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\n \nstatic void ipa_cmd_ip_packet_init_add(struct gsi_trans *trans, u8 endpoint_id)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tenum ipa_cmd_opcode opcode = IPA_CMD_IP_PACKET_INIT;\n\tstruct ipa_cmd_ip_packet_init *payload;\n\tunion ipa_cmd_payload *cmd_payload;\n\tdma_addr_t payload_addr;\n\n\tcmd_payload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\tpayload = &cmd_payload->ip_packet_init;\n\n\tif (ipa->version < IPA_VERSION_5_0) {\n\t\tpayload->dest_endpoint =\n\t\t\tu8_encode_bits(endpoint_id,\n\t\t\t\t       IPA_PACKET_INIT_DEST_ENDPOINT_FMASK);\n\t} else {\n\t\tpayload->dest_endpoint = endpoint_id;\n\t}\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\n \nvoid ipa_cmd_dma_shared_mem_add(struct gsi_trans *trans, u32 offset, u16 size,\n\t\t\t\tdma_addr_t addr, bool toward_ipa)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tenum ipa_cmd_opcode opcode = IPA_CMD_DMA_SHARED_MEM;\n\tstruct ipa_cmd_hw_dma_mem_mem *payload;\n\tunion ipa_cmd_payload *cmd_payload;\n\tdma_addr_t payload_addr;\n\tu16 flags;\n\n\t \n\tWARN_ON(!size);\n\tWARN_ON(size > U16_MAX);\n\tWARN_ON(offset > U16_MAX || ipa->mem_offset > U16_MAX - offset);\n\n\toffset += ipa->mem_offset;\n\n\tcmd_payload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\tpayload = &cmd_payload->dma_shared_mem;\n\n\t \n\tpayload->size = cpu_to_le16(size);\n\tpayload->local_addr = cpu_to_le16(offset);\n\t \n\tflags = toward_ipa ? 0 : DMA_SHARED_MEM_FLAGS_DIRECTION_FMASK;\n\tpayload->flags = cpu_to_le16(flags);\n\tpayload->system_addr = cpu_to_le64(addr);\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\nstatic void ipa_cmd_ip_tag_status_add(struct gsi_trans *trans)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tenum ipa_cmd_opcode opcode = IPA_CMD_IP_PACKET_TAG_STATUS;\n\tstruct ipa_cmd_ip_packet_tag_status *payload;\n\tunion ipa_cmd_payload *cmd_payload;\n\tdma_addr_t payload_addr;\n\n\tcmd_payload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\tpayload = &cmd_payload->ip_packet_tag_status;\n\n\tpayload->tag = le64_encode_bits(0, IP_PACKET_TAG_STATUS_TAG_FMASK);\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\n \nstatic void ipa_cmd_transfer_add(struct gsi_trans *trans)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tenum ipa_cmd_opcode opcode = IPA_CMD_NONE;\n\tunion ipa_cmd_payload *payload;\n\tdma_addr_t payload_addr;\n\n\t \n\tpayload = ipa_cmd_payload_alloc(ipa, &payload_addr);\n\n\tgsi_trans_cmd_add(trans, payload, sizeof(*payload), payload_addr,\n\t\t\t  opcode);\n}\n\n \nvoid ipa_cmd_pipeline_clear_add(struct gsi_trans *trans)\n{\n\tstruct ipa *ipa = container_of(trans->gsi, struct ipa, gsi);\n\tstruct ipa_endpoint *endpoint;\n\n\t \n\treinit_completion(&ipa->completion);\n\n\t \n\tipa_cmd_register_write_add(trans, 0, 0, 0, true);\n\n\t \n\tendpoint = ipa->name_map[IPA_ENDPOINT_AP_LAN_RX];\n\tipa_cmd_ip_packet_init_add(trans, endpoint->endpoint_id);\n\tipa_cmd_ip_tag_status_add(trans);\n\tipa_cmd_transfer_add(trans);\n}\n\n \nu32 ipa_cmd_pipeline_clear_count(void)\n{\n\treturn 4;\n}\n\nvoid ipa_cmd_pipeline_clear_wait(struct ipa *ipa)\n{\n\twait_for_completion(&ipa->completion);\n}\n\n \nstruct gsi_trans *ipa_cmd_trans_alloc(struct ipa *ipa, u32 tre_count)\n{\n\tstruct ipa_endpoint *endpoint;\n\n\tif (WARN_ON(tre_count > IPA_COMMAND_TRANS_TRE_MAX))\n\t\treturn NULL;\n\n\tendpoint = ipa->name_map[IPA_ENDPOINT_AP_COMMAND_TX];\n\n\treturn gsi_channel_trans_alloc(&ipa->gsi, endpoint->channel_id,\n\t\t\t\t       tre_count, DMA_NONE);\n}\n\n \nint ipa_cmd_init(struct ipa *ipa)\n{\n\tipa_cmd_validate_build();\n\n\tif (!ipa_cmd_header_init_local_valid(ipa))\n\t\treturn -EINVAL;\n\n\tif (!ipa_cmd_register_write_valid(ipa))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}