{
  "module_name": "ipa_smp2p.c",
  "hash_id": "a146a417d7da5079456209504cadbb9502cc00766df7fda41a762c716722e94e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_smp2p.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/panic_notifier.h>\n#include <linux/pm_runtime.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n\n#include \"ipa_smp2p.h\"\n#include \"ipa.h\"\n#include \"ipa_uc.h\"\n\n \n\n \nstruct ipa_smp2p {\n\tstruct ipa *ipa;\n\tstruct qcom_smem_state *valid_state;\n\tstruct qcom_smem_state *enabled_state;\n\tu32 valid_bit;\n\tu32 enabled_bit;\n\tu32 clock_query_irq;\n\tu32 setup_ready_irq;\n\tbool power_on;\n\tbool notified;\n\tbool setup_disabled;\n\tstruct mutex mutex;\n\tstruct notifier_block panic_notifier;\n};\n\n \nstatic void ipa_smp2p_notify(struct ipa_smp2p *smp2p)\n{\n\tstruct device *dev;\n\tu32 value;\n\tu32 mask;\n\n\tif (smp2p->notified)\n\t\treturn;\n\n\tdev = &smp2p->ipa->pdev->dev;\n\tsmp2p->power_on = pm_runtime_get_if_active(dev, true) > 0;\n\n\t \n\tmask = BIT(smp2p->enabled_bit);\n\tvalue = smp2p->power_on ? mask : 0;\n\tqcom_smem_state_update_bits(smp2p->enabled_state, mask, value);\n\n\t \n\tmask = BIT(smp2p->valid_bit);\n\tvalue = mask;\n\tqcom_smem_state_update_bits(smp2p->valid_state, mask, value);\n\n\tsmp2p->notified = true;\n}\n\n \nstatic irqreturn_t ipa_smp2p_modem_clk_query_isr(int irq, void *dev_id)\n{\n\tstruct ipa_smp2p *smp2p = dev_id;\n\n\tipa_smp2p_notify(smp2p);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ipa_smp2p_panic_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long action, void *data)\n{\n\tstruct ipa_smp2p *smp2p;\n\n\tsmp2p = container_of(nb, struct ipa_smp2p, panic_notifier);\n\n\tipa_smp2p_notify(smp2p);\n\n\tif (smp2p->power_on)\n\t\tipa_uc_panic_notifier(smp2p->ipa);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int ipa_smp2p_panic_notifier_register(struct ipa_smp2p *smp2p)\n{\n\t \n\tsmp2p->panic_notifier.notifier_call = ipa_smp2p_panic_notifier;\n\tsmp2p->panic_notifier.priority = INT_MAX;\t \n\n\treturn atomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t      &smp2p->panic_notifier);\n}\n\nstatic void ipa_smp2p_panic_notifier_unregister(struct ipa_smp2p *smp2p)\n{\n\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t &smp2p->panic_notifier);\n}\n\n \nstatic irqreturn_t ipa_smp2p_modem_setup_ready_isr(int irq, void *dev_id)\n{\n\tstruct ipa_smp2p *smp2p = dev_id;\n\tstruct device *dev;\n\tint ret;\n\n\t \n\tif (smp2p->ipa->setup_complete)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tdev = &smp2p->ipa->pdev->dev;\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error %d getting power for setup\\n\", ret);\n\t\tgoto out_power_put;\n\t}\n\n\t \n\tret = ipa_setup(smp2p->ipa);\n\tWARN(ret != 0, \"error %d from ipa_setup()\\n\", ret);\n\nout_power_put:\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ipa_smp2p_irq_init(struct ipa_smp2p *smp2p, const char *name,\n\t\t\t      irq_handler_t handler)\n{\n\tstruct device *dev = &smp2p->ipa->pdev->dev;\n\tunsigned int irq;\n\tint ret;\n\n\tret = platform_get_irq_byname(smp2p->ipa->pdev, name);\n\tif (ret <= 0)\n\t\treturn ret ? : -EINVAL;\n\tirq = ret;\n\n\tret = request_threaded_irq(irq, NULL, handler, 0, name, smp2p);\n\tif (ret) {\n\t\tdev_err(dev, \"error %d requesting \\\"%s\\\" IRQ\\n\", ret, name);\n\t\treturn ret;\n\t}\n\n\treturn irq;\n}\n\nstatic void ipa_smp2p_irq_exit(struct ipa_smp2p *smp2p, u32 irq)\n{\n\tfree_irq(irq, smp2p);\n}\n\n \nstatic void ipa_smp2p_power_release(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\n\tif (!ipa->smp2p->power_on)\n\t\treturn;\n\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n\tipa->smp2p->power_on = false;\n}\n\n \nint ipa_smp2p_init(struct ipa *ipa, bool modem_init)\n{\n\tstruct qcom_smem_state *enabled_state;\n\tstruct device *dev = &ipa->pdev->dev;\n\tstruct qcom_smem_state *valid_state;\n\tstruct ipa_smp2p *smp2p;\n\tu32 enabled_bit;\n\tu32 valid_bit;\n\tint ret;\n\n\tvalid_state = qcom_smem_state_get(dev, \"ipa-clock-enabled-valid\",\n\t\t\t\t\t  &valid_bit);\n\tif (IS_ERR(valid_state))\n\t\treturn PTR_ERR(valid_state);\n\tif (valid_bit >= 32)\t\t \n\t\treturn -EINVAL;\n\n\tenabled_state = qcom_smem_state_get(dev, \"ipa-clock-enabled\",\n\t\t\t\t\t    &enabled_bit);\n\tif (IS_ERR(enabled_state))\n\t\treturn PTR_ERR(enabled_state);\n\tif (enabled_bit >= 32)\t\t \n\t\treturn -EINVAL;\n\n\tsmp2p = kzalloc(sizeof(*smp2p), GFP_KERNEL);\n\tif (!smp2p)\n\t\treturn -ENOMEM;\n\n\tsmp2p->ipa = ipa;\n\n\t \n\tmutex_init(&smp2p->mutex);\n\tsmp2p->valid_state = valid_state;\n\tsmp2p->valid_bit = valid_bit;\n\tsmp2p->enabled_state = enabled_state;\n\tsmp2p->enabled_bit = enabled_bit;\n\n\t \n\tipa->smp2p = smp2p;\n\n\tret = ipa_smp2p_irq_init(smp2p, \"ipa-clock-query\",\n\t\t\t\t ipa_smp2p_modem_clk_query_isr);\n\tif (ret < 0)\n\t\tgoto err_null_smp2p;\n\tsmp2p->clock_query_irq = ret;\n\n\tret = ipa_smp2p_panic_notifier_register(smp2p);\n\tif (ret)\n\t\tgoto err_irq_exit;\n\n\tif (modem_init) {\n\t\t \n\t\tret = ipa_smp2p_irq_init(smp2p, \"ipa-setup-ready\",\n\t\t\t\t\t ipa_smp2p_modem_setup_ready_isr);\n\t\tif (ret < 0)\n\t\t\tgoto err_notifier_unregister;\n\t\tsmp2p->setup_ready_irq = ret;\n\t}\n\n\treturn 0;\n\nerr_notifier_unregister:\n\tipa_smp2p_panic_notifier_unregister(smp2p);\nerr_irq_exit:\n\tipa_smp2p_irq_exit(smp2p, smp2p->clock_query_irq);\nerr_null_smp2p:\n\tipa->smp2p = NULL;\n\tmutex_destroy(&smp2p->mutex);\n\tkfree(smp2p);\n\n\treturn ret;\n}\n\nvoid ipa_smp2p_exit(struct ipa *ipa)\n{\n\tstruct ipa_smp2p *smp2p = ipa->smp2p;\n\n\tif (smp2p->setup_ready_irq)\n\t\tipa_smp2p_irq_exit(smp2p, smp2p->setup_ready_irq);\n\tipa_smp2p_panic_notifier_unregister(smp2p);\n\tipa_smp2p_irq_exit(smp2p, smp2p->clock_query_irq);\n\t \n\tipa_smp2p_power_release(ipa);\n\tipa->smp2p = NULL;\n\tmutex_destroy(&smp2p->mutex);\n\tkfree(smp2p);\n}\n\nvoid ipa_smp2p_irq_disable_setup(struct ipa *ipa)\n{\n\tstruct ipa_smp2p *smp2p = ipa->smp2p;\n\n\tif (!smp2p->setup_ready_irq)\n\t\treturn;\n\n\tmutex_lock(&smp2p->mutex);\n\n\tif (!smp2p->setup_disabled) {\n\t\tdisable_irq(smp2p->setup_ready_irq);\n\t\tsmp2p->setup_disabled = true;\n\t}\n\n\tmutex_unlock(&smp2p->mutex);\n}\n\n \nvoid ipa_smp2p_notify_reset(struct ipa *ipa)\n{\n\tstruct ipa_smp2p *smp2p = ipa->smp2p;\n\tu32 mask;\n\n\tif (!smp2p->notified)\n\t\treturn;\n\n\tipa_smp2p_power_release(ipa);\n\n\t \n\tmask = BIT(smp2p->valid_bit);\n\tqcom_smem_state_update_bits(smp2p->valid_state, mask, 0);\n\n\t \n\tmask = BIT(smp2p->enabled_bit);\n\tqcom_smem_state_update_bits(smp2p->enabled_state, mask, 0);\n\n\tsmp2p->notified = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}