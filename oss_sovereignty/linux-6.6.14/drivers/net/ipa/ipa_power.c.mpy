{
  "module_name": "ipa_power.c",
  "hash_id": "31717774e85b9f3d5c65be9f489167d09af65f2d3c66e85e37703a11c0c6f393",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_power.c",
  "human_readable_source": "\n\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/interconnect.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/bitops.h>\n\n#include \"linux/soc/qcom/qcom_aoss.h\"\n\n#include \"ipa.h\"\n#include \"ipa_power.h\"\n#include \"ipa_endpoint.h\"\n#include \"ipa_modem.h\"\n#include \"ipa_data.h\"\n\n \n\n#define IPA_AUTOSUSPEND_DELAY\t500\t \n\n \nenum ipa_power_flag {\n\tIPA_POWER_FLAG_RESUMED,\n\tIPA_POWER_FLAG_SYSTEM,\n\tIPA_POWER_FLAG_STOPPED,\n\tIPA_POWER_FLAG_STARTED,\n\tIPA_POWER_FLAG_COUNT,\t\t \n};\n\n \nstruct ipa_power {\n\tstruct device *dev;\n\tstruct clk *core;\n\tstruct qmp *qmp;\n\tspinlock_t spinlock;\t \n\tDECLARE_BITMAP(flags, IPA_POWER_FLAG_COUNT);\n\tu32 interconnect_count;\n\tstruct icc_bulk_data interconnect[];\n};\n\n \nstatic int ipa_interconnect_init(struct ipa_power *power,\n\t\t\t\t const struct ipa_interconnect_data *data)\n{\n\tstruct icc_bulk_data *interconnect;\n\tint ret;\n\tu32 i;\n\n\t \n\tinterconnect = &power->interconnect[0];\n\tfor (i = 0; i < power->interconnect_count; i++) {\n\t\t \n\t\tinterconnect->name = data->name;\n\t\tinterconnect->avg_bw = data->average_bandwidth;\n\t\tinterconnect->peak_bw = data->peak_bandwidth;\n\t\tdata++;\n\t\tinterconnect++;\n\t}\n\n\tret = of_icc_bulk_get(power->dev, power->interconnect_count,\n\t\t\t      power->interconnect);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ticc_bulk_disable(power->interconnect_count, power->interconnect);\n\n\t \n\tret = icc_bulk_set_bw(power->interconnect_count, power->interconnect);\n\tif (ret)\n\t\ticc_bulk_put(power->interconnect_count, power->interconnect);\n\n\treturn ret;\n}\n\n \nstatic void ipa_interconnect_exit(struct ipa_power *power)\n{\n\ticc_bulk_put(power->interconnect_count, power->interconnect);\n}\n\n \nstatic int ipa_power_enable(struct ipa *ipa)\n{\n\tstruct ipa_power *power = ipa->power;\n\tint ret;\n\n\tret = icc_bulk_enable(power->interconnect_count, power->interconnect);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(power->core);\n\tif (ret) {\n\t\tdev_err(power->dev, \"error %d enabling core clock\\n\", ret);\n\t\ticc_bulk_disable(power->interconnect_count,\n\t\t\t\t power->interconnect);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ipa_power_disable(struct ipa *ipa)\n{\n\tstruct ipa_power *power = ipa->power;\n\n\tclk_disable_unprepare(power->core);\n\n\ticc_bulk_disable(power->interconnect_count, power->interconnect);\n}\n\nstatic int ipa_runtime_suspend(struct device *dev)\n{\n\tstruct ipa *ipa = dev_get_drvdata(dev);\n\n\t \n\tif (ipa->setup_complete) {\n\t\t__clear_bit(IPA_POWER_FLAG_RESUMED, ipa->power->flags);\n\t\tipa_endpoint_suspend(ipa);\n\t\tgsi_suspend(&ipa->gsi);\n\t}\n\n\tipa_power_disable(ipa);\n\n\treturn 0;\n}\n\nstatic int ipa_runtime_resume(struct device *dev)\n{\n\tstruct ipa *ipa = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = ipa_power_enable(ipa);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\n\t \n\tif (ipa->setup_complete) {\n\t\tgsi_resume(&ipa->gsi);\n\t\tipa_endpoint_resume(ipa);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipa_suspend(struct device *dev)\n{\n\tstruct ipa *ipa = dev_get_drvdata(dev);\n\n\t__set_bit(IPA_POWER_FLAG_SYSTEM, ipa->power->flags);\n\n\t \n\tipa_interrupt_irq_disable(ipa);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int ipa_resume(struct device *dev)\n{\n\tstruct ipa *ipa = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\n\t__clear_bit(IPA_POWER_FLAG_SYSTEM, ipa->power->flags);\n\n\t \n\tipa_interrupt_irq_enable(ipa);\n\n\treturn ret;\n}\n\n \nu32 ipa_core_clock_rate(struct ipa *ipa)\n{\n\treturn ipa->power ? (u32)clk_get_rate(ipa->power->core) : 0;\n}\n\nvoid ipa_power_suspend_handler(struct ipa *ipa, enum ipa_irq_id irq_id)\n{\n\t \n\tif (!__test_and_set_bit(IPA_POWER_FLAG_RESUMED, ipa->power->flags))\n\t\tif (test_bit(IPA_POWER_FLAG_SYSTEM, ipa->power->flags))\n\t\t\tpm_wakeup_dev_event(&ipa->pdev->dev, 0, true);\n\n\t \n\tipa_interrupt_suspend_clear_all(ipa->interrupt);\n}\n\n \nvoid ipa_power_modem_queue_stop(struct ipa *ipa)\n{\n\tstruct ipa_power *power = ipa->power;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&power->spinlock, flags);\n\n\tif (!__test_and_clear_bit(IPA_POWER_FLAG_STARTED, power->flags)) {\n\t\tnetif_stop_queue(ipa->modem_netdev);\n\t\t__set_bit(IPA_POWER_FLAG_STOPPED, power->flags);\n\t}\n\n\tspin_unlock_irqrestore(&power->spinlock, flags);\n}\n\n \nvoid ipa_power_modem_queue_wake(struct ipa *ipa)\n{\n\tstruct ipa_power *power = ipa->power;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&power->spinlock, flags);\n\n\tif (__test_and_clear_bit(IPA_POWER_FLAG_STOPPED, power->flags)) {\n\t\t__set_bit(IPA_POWER_FLAG_STARTED, power->flags);\n\t\tnetif_wake_queue(ipa->modem_netdev);\n\t}\n\n\tspin_unlock_irqrestore(&power->spinlock, flags);\n}\n\n \nvoid ipa_power_modem_queue_active(struct ipa *ipa)\n{\n\tclear_bit(IPA_POWER_FLAG_STARTED, ipa->power->flags);\n}\n\nstatic int ipa_power_retention_init(struct ipa_power *power)\n{\n\tstruct qmp *qmp = qmp_get(power->dev);\n\n\tif (IS_ERR(qmp)) {\n\t\tif (PTR_ERR(qmp) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\t \n\t\tqmp = NULL;\n\t}\n\tpower->qmp = qmp;\n\n\treturn 0;\n}\n\nstatic void ipa_power_retention_exit(struct ipa_power *power)\n{\n\tqmp_put(power->qmp);\n\tpower->qmp = NULL;\n}\n\n \nvoid ipa_power_retention(struct ipa *ipa, bool enable)\n{\n\tstatic const char fmt[] = \"{ class: bcm, res: ipa_pc, val: %c }\";\n\tstruct ipa_power *power = ipa->power;\n\tint ret;\n\n\tif (!power->qmp)\n\t\treturn;\t\t \n\n\tret = qmp_send(power->qmp, fmt, enable ? '1' : '0');\n\tif (ret)\n\t\tdev_err(power->dev, \"error %d sending QMP %sable request\\n\",\n\t\t\tret, enable ? \"en\" : \"dis\");\n}\n\nint ipa_power_setup(struct ipa *ipa)\n{\n\tint ret;\n\n\tipa_interrupt_enable(ipa, IPA_IRQ_TX_SUSPEND);\n\n\tret = device_init_wakeup(&ipa->pdev->dev, true);\n\tif (ret)\n\t\tipa_interrupt_disable(ipa, IPA_IRQ_TX_SUSPEND);\n\n\treturn ret;\n}\n\nvoid ipa_power_teardown(struct ipa *ipa)\n{\n\t(void)device_init_wakeup(&ipa->pdev->dev, false);\n\tipa_interrupt_disable(ipa, IPA_IRQ_TX_SUSPEND);\n}\n\n \nstruct ipa_power *\nipa_power_init(struct device *dev, const struct ipa_power_data *data)\n{\n\tstruct ipa_power *power;\n\tstruct clk *clk;\n\tsize_t size;\n\tint ret;\n\n\tclk = clk_get(dev, \"core\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err_probe(dev, PTR_ERR(clk), \"error getting core clock\\n\");\n\n\t\treturn ERR_CAST(clk);\n\t}\n\n\tret = clk_set_rate(clk, data->core_clock_rate);\n\tif (ret) {\n\t\tdev_err(dev, \"error %d setting core clock rate to %u\\n\",\n\t\t\tret, data->core_clock_rate);\n\t\tgoto err_clk_put;\n\t}\n\n\tsize = struct_size(power, interconnect, data->interconnect_count);\n\tpower = kzalloc(size, GFP_KERNEL);\n\tif (!power) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_put;\n\t}\n\tpower->dev = dev;\n\tpower->core = clk;\n\tspin_lock_init(&power->spinlock);\n\tpower->interconnect_count = data->interconnect_count;\n\n\tret = ipa_interconnect_init(power, data->interconnect_data);\n\tif (ret)\n\t\tgoto err_kfree;\n\n\tret = ipa_power_retention_init(power);\n\tif (ret)\n\t\tgoto err_interconnect_exit;\n\n\tpm_runtime_set_autosuspend_delay(dev, IPA_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\n\treturn power;\n\nerr_interconnect_exit:\n\tipa_interconnect_exit(power);\nerr_kfree:\n\tkfree(power);\nerr_clk_put:\n\tclk_put(clk);\n\n\treturn ERR_PTR(ret);\n}\n\n \nvoid ipa_power_exit(struct ipa_power *power)\n{\n\tstruct device *dev = power->dev;\n\tstruct clk *clk = power->core;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tipa_power_retention_exit(power);\n\tipa_interconnect_exit(power);\n\tkfree(power);\n\tclk_put(clk);\n}\n\nconst struct dev_pm_ops ipa_pm_ops = {\n\t.suspend\t\t= ipa_suspend,\n\t.resume\t\t\t= ipa_resume,\n\t.runtime_suspend\t= ipa_runtime_suspend,\n\t.runtime_resume\t\t= ipa_runtime_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}