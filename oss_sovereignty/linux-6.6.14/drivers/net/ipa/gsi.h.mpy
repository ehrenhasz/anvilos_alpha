{
  "module_name": "gsi.h",
  "hash_id": "716723f74eaa727784d2a29910e64bbe905fdb432caf44f3b479f330f9665410",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/gsi.h",
  "human_readable_source": " \n\n \n#ifndef _GSI_H_\n#define _GSI_H_\n\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n\n#include \"ipa_version.h\"\n\n \n#define GSI_CHANNEL_COUNT_MAX\t28\n#define GSI_EVT_RING_COUNT_MAX\t28\n\n \n#define GSI_TLV_MAX\t\t64\n\nstruct device;\nstruct scatterlist;\nstruct platform_device;\n\nstruct gsi;\nstruct gsi_trans;\nstruct gsi_channel_data;\nstruct ipa_gsi_endpoint_data;\n\nstruct gsi_ring {\n\tvoid *virt;\t\t\t \n\tdma_addr_t addr;\t\t \n\tu32 count;\t\t\t \n\n\t \n\tu32 index;\n};\n\n \nstruct gsi_trans_pool {\n\tvoid *base;\t\t\t \n\tu32 count;\t\t\t \n\tu32 free;\t\t\t \n\tu32 size;\t\t\t \n\tu32 max_alloc;\t\t\t \n\tdma_addr_t addr;\t\t \n};\n\nstruct gsi_trans_info {\n\tatomic_t tre_avail;\t\t \n\n\tu16 free_id;\t\t\t \n\tu16 allocated_id;\t\t \n\tu16 committed_id;\t\t \n\tu16 pending_id;\t\t\t \n\tu16 completed_id;\t\t \n\tu16 polled_id;\t\t\t \n\tstruct gsi_trans *trans;\t \n\tstruct gsi_trans **map;\t\t \n\n\tstruct gsi_trans_pool sg_pool;\t \n\tstruct gsi_trans_pool cmd_pool;\t \n};\n\n \nenum gsi_channel_state {\n\tGSI_CHANNEL_STATE_NOT_ALLOCATED\t\t= 0x0,\n\tGSI_CHANNEL_STATE_ALLOCATED\t\t= 0x1,\n\tGSI_CHANNEL_STATE_STARTED\t\t= 0x2,\n\tGSI_CHANNEL_STATE_STOPPED\t\t= 0x3,\n\tGSI_CHANNEL_STATE_STOP_IN_PROC\t\t= 0x4,\n\tGSI_CHANNEL_STATE_FLOW_CONTROLLED\t= 0x5,\t \n\tGSI_CHANNEL_STATE_ERROR\t\t\t= 0xf,\n};\n\n \nstruct gsi_channel {\n\tstruct gsi *gsi;\n\tbool toward_ipa;\n\tbool command;\t\t\t \n\n\tu8 trans_tre_max;\t\t \n\tu16 tre_count;\n\tu16 event_count;\n\n\tstruct gsi_ring tre_ring;\n\tu32 evt_ring_id;\n\n\t \n\tu64 byte_count;\t\t\t \n\tu64 trans_count;\t\t \n\tu64 queued_byte_count;\t\t \n\tu64 queued_trans_count;\t\t \n\tu64 compl_byte_count;\t\t \n\tu64 compl_trans_count;\t\t \n\n\tstruct gsi_trans_info trans_info;\n\n\tstruct napi_struct napi;\n};\n\n \nenum gsi_evt_ring_state {\n\tGSI_EVT_RING_STATE_NOT_ALLOCATED\t= 0x0,\n\tGSI_EVT_RING_STATE_ALLOCATED\t\t= 0x1,\n\tGSI_EVT_RING_STATE_ERROR\t\t= 0xf,\n};\n\nstruct gsi_evt_ring {\n\tstruct gsi_channel *channel;\n\tstruct gsi_ring ring;\n};\n\nstruct gsi {\n\tstruct device *dev;\t\t \n\tenum ipa_version version;\n\tvoid __iomem *virt;\t\t \n\tconst struct regs *regs;\n\n\tu32 irq;\n\tu32 channel_count;\n\tu32 evt_ring_count;\n\tu32 event_bitmap;\t\t \n\tu32 modem_channel_bitmap;\t \n\tu32 type_enabled_bitmap;\t \n\tu32 ieob_enabled_bitmap;\t \n\tint result;\t\t\t \n\tstruct completion completion;\t \n\tstruct mutex mutex;\t\t \n\tstruct gsi_channel channel[GSI_CHANNEL_COUNT_MAX];\n\tstruct gsi_evt_ring evt_ring[GSI_EVT_RING_COUNT_MAX];\n\tstruct net_device dummy_dev;\t \n};\n\n \nint gsi_setup(struct gsi *gsi);\n\n \nvoid gsi_teardown(struct gsi *gsi);\n\n \nu32 gsi_channel_tre_max(struct gsi *gsi, u32 channel_id);\n\n \nint gsi_channel_start(struct gsi *gsi, u32 channel_id);\n\n \nint gsi_channel_stop(struct gsi *gsi, u32 channel_id);\n\n \nvoid gsi_modem_channel_flow_control(struct gsi *gsi, u32 channel_id,\n\t\t\t\t    bool enable);\n\n \nvoid gsi_channel_reset(struct gsi *gsi, u32 channel_id, bool doorbell);\n\n \nvoid gsi_suspend(struct gsi *gsi);\n\n \nvoid gsi_resume(struct gsi *gsi);\n\n \nint gsi_channel_suspend(struct gsi *gsi, u32 channel_id);\n\n \nint gsi_channel_resume(struct gsi *gsi, u32 channel_id);\n\n \nint gsi_init(struct gsi *gsi, struct platform_device *pdev,\n\t     enum ipa_version version, u32 count,\n\t     const struct ipa_gsi_endpoint_data *data);\n\n \nvoid gsi_exit(struct gsi *gsi);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}