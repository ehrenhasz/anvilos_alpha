{
  "module_name": "ipa_uc.c",
  "hash_id": "170366d072bc3116c5182b4821b61f7520f68d626036c35cc5b3a7f3ce09cd0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipa/ipa_uc.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n\n#include \"ipa.h\"\n#include \"ipa_uc.h\"\n#include \"ipa_power.h\"\n\n \n \n\n \n#define IPA_SEND_DELAY\t\t100\t \n\n \nstruct ipa_uc_mem_area {\n\tu8 command;\t\t \n\tu8 reserved0[3];\n\t__le32 command_param;\n\t__le32 command_param_hi;\n\tu8 response;\t\t \n\tu8 reserved1[3];\n\t__le32 response_param;\n\tu8 event;\t\t \n\tu8 reserved2[3];\n\n\t__le32 event_param;\n\t__le32 first_error_address;\n\tu8 hw_state;\n\tu8 warning_counter;\n\t__le16 reserved3;\n\t__le16 interface_version;\n\t__le16 reserved4;\n};\n\n \nenum ipa_uc_command {\n\tIPA_UC_COMMAND_NO_OP\t\t= 0x0,\n\tIPA_UC_COMMAND_UPDATE_FLAGS\t= 0x1,\n\tIPA_UC_COMMAND_DEBUG_RUN_TEST\t= 0x2,\n\tIPA_UC_COMMAND_DEBUG_GET_INFO\t= 0x3,\n\tIPA_UC_COMMAND_ERR_FATAL\t= 0x4,\n\tIPA_UC_COMMAND_CLK_GATE\t\t= 0x5,\n\tIPA_UC_COMMAND_CLK_UNGATE\t= 0x6,\n\tIPA_UC_COMMAND_MEMCPY\t\t= 0x7,\n\tIPA_UC_COMMAND_RESET_PIPE\t= 0x8,\n\tIPA_UC_COMMAND_REG_WRITE\t= 0x9,\n\tIPA_UC_COMMAND_GSI_CH_EMPTY\t= 0xa,\n};\n\n \nenum ipa_uc_response {\n\tIPA_UC_RESPONSE_NO_OP\t\t= 0x0,\n\tIPA_UC_RESPONSE_INIT_COMPLETED\t= 0x1,\n\tIPA_UC_RESPONSE_CMD_COMPLETED\t= 0x2,\n\tIPA_UC_RESPONSE_DEBUG_GET_INFO\t= 0x3,\n};\n\n \nenum ipa_uc_event {\n\tIPA_UC_EVENT_NO_OP\t\t= 0x0,\n\tIPA_UC_EVENT_ERROR\t\t= 0x1,\n\tIPA_UC_EVENT_LOG_INFO\t\t= 0x2,\n};\n\nstatic struct ipa_uc_mem_area *ipa_uc_shared(struct ipa *ipa)\n{\n\tconst struct ipa_mem *mem = ipa_mem_find(ipa, IPA_MEM_UC_SHARED);\n\tu32 offset = ipa->mem_offset + mem->offset;\n\n\treturn ipa->mem_virt + offset;\n}\n\n \nstatic void ipa_uc_event_handler(struct ipa *ipa)\n{\n\tstruct ipa_uc_mem_area *shared = ipa_uc_shared(ipa);\n\tstruct device *dev = &ipa->pdev->dev;\n\n\tif (shared->event == IPA_UC_EVENT_ERROR)\n\t\tdev_err(dev, \"microcontroller error event\\n\");\n\telse if (shared->event != IPA_UC_EVENT_LOG_INFO)\n\t\tdev_err(dev, \"unsupported microcontroller event %u\\n\",\n\t\t\tshared->event);\n\t \n}\n\n \nstatic void ipa_uc_response_hdlr(struct ipa *ipa)\n{\n\tstruct ipa_uc_mem_area *shared = ipa_uc_shared(ipa);\n\tstruct device *dev = &ipa->pdev->dev;\n\n\t \n\tswitch (shared->response) {\n\tcase IPA_UC_RESPONSE_INIT_COMPLETED:\n\t\tif (ipa->uc_powered) {\n\t\t\tipa->uc_loaded = true;\n\t\t\tipa_power_retention(ipa, true);\n\t\t\tpm_runtime_mark_last_busy(dev);\n\t\t\t(void)pm_runtime_put_autosuspend(dev);\n\t\t\tipa->uc_powered = false;\n\t\t} else {\n\t\t\tdev_warn(dev, \"unexpected init_completed response\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unsupported microcontroller response %u\\n\",\n\t\t\t shared->response);\n\t\tbreak;\n\t}\n}\n\nvoid ipa_uc_interrupt_handler(struct ipa *ipa, enum ipa_irq_id irq_id)\n{\n\t \n\tif (irq_id == IPA_IRQ_UC_0)\n\t\tipa_uc_event_handler(ipa);\n\telse if (irq_id == IPA_IRQ_UC_1)\n\t\tipa_uc_response_hdlr(ipa);\n}\n\n \nvoid ipa_uc_config(struct ipa *ipa)\n{\n\tipa->uc_powered = false;\n\tipa->uc_loaded = false;\n\tipa_interrupt_enable(ipa, IPA_IRQ_UC_0);\n\tipa_interrupt_enable(ipa, IPA_IRQ_UC_1);\n}\n\n \nvoid ipa_uc_deconfig(struct ipa *ipa)\n{\n\tstruct device *dev = &ipa->pdev->dev;\n\n\tipa_interrupt_disable(ipa, IPA_IRQ_UC_1);\n\tipa_interrupt_disable(ipa, IPA_IRQ_UC_0);\n\tif (ipa->uc_loaded)\n\t\tipa_power_retention(ipa, false);\n\n\tif (!ipa->uc_powered)\n\t\treturn;\n\n\tpm_runtime_mark_last_busy(dev);\n\t(void)pm_runtime_put_autosuspend(dev);\n}\n\n \nvoid ipa_uc_power(struct ipa *ipa)\n{\n\tstatic bool already;\n\tstruct device *dev;\n\tint ret;\n\n\tif (already)\n\t\treturn;\n\talready = true;\t\t \n\n\t \n\tdev = &ipa->pdev->dev;\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\tdev_err(dev, \"error %d getting proxy power\\n\", ret);\n\t} else {\n\t\tipa->uc_powered = true;\n\t}\n}\n\n \nstatic void send_uc_command(struct ipa *ipa, u32 command, u32 command_param)\n{\n\tstruct ipa_uc_mem_area *shared = ipa_uc_shared(ipa);\n\tconst struct reg *reg;\n\tu32 val;\n\n\t \n\tshared->command = command;\n\tshared->command_param = cpu_to_le32(command_param);\n\tshared->command_param_hi = 0;\n\tshared->response = 0;\n\tshared->response_param = 0;\n\n\t \n\treg = ipa_reg(ipa, IPA_IRQ_UC);\n\tval = reg_bit(reg, UC_INTR);\n\n\tiowrite32(val, ipa->reg_virt + reg_offset(reg));\n}\n\n \nvoid ipa_uc_panic_notifier(struct ipa *ipa)\n{\n\tif (!ipa->uc_loaded)\n\t\treturn;\n\n\tsend_uc_command(ipa, IPA_UC_COMMAND_ERR_FATAL, 0);\n\n\t \n\tudelay(IPA_SEND_DELAY);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}