{
  "module_name": "pcs-mtk-lynxi.c",
  "hash_id": "a5eca938329a782768a2e674bc7a258c4d0f82a4fcce68c627adb75d1059a753",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/pcs/pcs-mtk-lynxi.c",
  "human_readable_source": "\n\n \n\n#include <linux/mdio.h>\n#include <linux/of.h>\n#include <linux/pcs/pcs-mtk-lynxi.h>\n#include <linux/phylink.h>\n#include <linux/regmap.h>\n\n \n \n#define SGMSYS_PCS_CONTROL_1\t\t0x0\n#define SGMII_BMCR\t\t\tGENMASK(15, 0)\n#define SGMII_BMSR\t\t\tGENMASK(31, 16)\n\n#define SGMSYS_PCS_DEVICE_ID\t\t0x4\n#define SGMII_LYNXI_DEV_ID\t\t0x4d544950\n\n#define SGMSYS_PCS_ADVERTISE\t\t0x8\n#define SGMII_ADVERTISE\t\t\tGENMASK(15, 0)\n#define SGMII_LPA\t\t\tGENMASK(31, 16)\n\n#define SGMSYS_PCS_SCRATCH\t\t0x14\n#define SGMII_DEV_VERSION\t\tGENMASK(31, 16)\n\n \n#define SGMSYS_PCS_LINK_TIMER\t\t0x18\n#define SGMII_LINK_TIMER_MASK\t\tGENMASK(19, 0)\n#define SGMII_LINK_TIMER_VAL(ns)\tFIELD_PREP(SGMII_LINK_TIMER_MASK, \\\n\t\t\t\t\t\t   ((ns) / 2 / 8))\n\n \n#define SGMSYS_SGMII_MODE\t\t0x20\n#define SGMII_IF_MODE_SGMII\t\tBIT(0)\n#define SGMII_SPEED_DUPLEX_AN\t\tBIT(1)\n#define SGMII_SPEED_MASK\t\tGENMASK(3, 2)\n#define SGMII_SPEED_10\t\t\tFIELD_PREP(SGMII_SPEED_MASK, 0)\n#define SGMII_SPEED_100\t\t\tFIELD_PREP(SGMII_SPEED_MASK, 1)\n#define SGMII_SPEED_1000\t\tFIELD_PREP(SGMII_SPEED_MASK, 2)\n#define SGMII_DUPLEX_HALF\t\tBIT(4)\n#define SGMII_REMOTE_FAULT_DIS\t\tBIT(8)\n\n \n#define SGMSYS_RESERVED_0\t\t0x34\n#define SGMII_SW_RESET\t\t\tBIT(0)\n\n \n#define SGMII_PHY_SPEED_MASK\t\tGENMASK(3, 2)\n#define SGMII_PHY_SPEED_1_25G\t\tFIELD_PREP(SGMII_PHY_SPEED_MASK, 0)\n#define SGMII_PHY_SPEED_3_125G\t\tFIELD_PREP(SGMII_PHY_SPEED_MASK, 1)\n\n \n#define SGMSYS_QPHY_PWR_STATE_CTRL\t0xe8\n#define\tSGMII_PHYA_PWD\t\t\tBIT(4)\n\n \n#define SGMSYS_QPHY_WRAP_CTRL\t\t0xec\n#define SGMII_PN_SWAP_MASK\t\tGENMASK(1, 0)\n#define SGMII_PN_SWAP_TX_RX\t\t(BIT(0) | BIT(1))\n\n \nstruct mtk_pcs_lynxi {\n\tstruct regmap\t\t*regmap;\n\tu32\t\t\tana_rgc3;\n\tphy_interface_t\t\tinterface;\n\tstruct\t\t\tphylink_pcs pcs;\n\tu32\t\t\tflags;\n};\n\nstatic struct mtk_pcs_lynxi *pcs_to_mtk_pcs_lynxi(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct mtk_pcs_lynxi, pcs);\n}\n\nstatic void mtk_pcs_lynxi_get_state(struct phylink_pcs *pcs,\n\t\t\t\t    struct phylink_link_state *state)\n{\n\tstruct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);\n\tunsigned int bm, adv;\n\n\t \n\tregmap_read(mpcs->regmap, SGMSYS_PCS_CONTROL_1, &bm);\n\tregmap_read(mpcs->regmap, SGMSYS_PCS_ADVERTISE, &adv);\n\n\tphylink_mii_c22_pcs_decode_state(state, FIELD_GET(SGMII_BMSR, bm),\n\t\t\t\t\t FIELD_GET(SGMII_LPA, adv));\n}\n\nstatic int mtk_pcs_lynxi_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t\tphy_interface_t interface,\n\t\t\t\tconst unsigned long *advertising,\n\t\t\t\tbool permit_pause_to_mac)\n{\n\tstruct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);\n\tbool mode_changed = false, changed;\n\tunsigned int rgc3, sgm_mode, bmcr;\n\tint advertise, link_timer;\n\n\tadvertise = phylink_mii_c22_pcs_encode_advertisement(interface,\n\t\t\t\t\t\t\t     advertising);\n\tif (advertise < 0)\n\t\treturn advertise;\n\n\t \n\tif (interface == PHY_INTERFACE_MODE_SGMII)\n\t\tsgm_mode = SGMII_IF_MODE_SGMII;\n\telse\n\t\tsgm_mode = 0;\n\n\tif (neg_mode & PHYLINK_PCS_NEG_INBAND)\n\t\tsgm_mode |= SGMII_REMOTE_FAULT_DIS;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\tif (interface == PHY_INTERFACE_MODE_SGMII)\n\t\t\tsgm_mode |= SGMII_SPEED_DUPLEX_AN;\n\t\tbmcr = BMCR_ANENABLE;\n\t} else {\n\t\tbmcr = 0;\n\t}\n\n\tif (mpcs->interface != interface) {\n\t\tlink_timer = phylink_get_link_timer_ns(interface);\n\t\tif (link_timer < 0)\n\t\t\treturn link_timer;\n\n\t\t \n\t\tregmap_set_bits(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL,\n\t\t\t\tSGMII_PHYA_PWD);\n\n\t\t \n\t\tregmap_set_bits(mpcs->regmap, SGMSYS_RESERVED_0,\n\t\t\t\tSGMII_SW_RESET);\n\n\t\tif (mpcs->flags & MTK_SGMII_FLAG_PN_SWAP)\n\t\t\tregmap_update_bits(mpcs->regmap, SGMSYS_QPHY_WRAP_CTRL,\n\t\t\t\t\t   SGMII_PN_SWAP_MASK,\n\t\t\t\t\t   SGMII_PN_SWAP_TX_RX);\n\n\t\tif (interface == PHY_INTERFACE_MODE_2500BASEX)\n\t\t\trgc3 = SGMII_PHY_SPEED_3_125G;\n\t\telse\n\t\t\trgc3 = SGMII_PHY_SPEED_1_25G;\n\n\t\t \n\t\tregmap_update_bits(mpcs->regmap, mpcs->ana_rgc3,\n\t\t\t\t   SGMII_PHY_SPEED_MASK, rgc3);\n\n\t\t \n\t\tregmap_write(mpcs->regmap, SGMSYS_PCS_LINK_TIMER,\n\t\t\t     SGMII_LINK_TIMER_VAL(link_timer));\n\n\t\tmpcs->interface = interface;\n\t\tmode_changed = true;\n\t}\n\n\t \n\tregmap_update_bits_check(mpcs->regmap, SGMSYS_PCS_ADVERTISE,\n\t\t\t\t SGMII_ADVERTISE, advertise, &changed);\n\n\t \n\tregmap_update_bits(mpcs->regmap, SGMSYS_SGMII_MODE,\n\t\t\t   SGMII_REMOTE_FAULT_DIS | SGMII_SPEED_DUPLEX_AN |\n\t\t\t   SGMII_IF_MODE_SGMII, sgm_mode);\n\n\t \n\tregmap_update_bits(mpcs->regmap, SGMSYS_PCS_CONTROL_1,\n\t\t\t   BMCR_ANENABLE, bmcr);\n\n\t \n\tusleep_range(50, 100);\n\tregmap_write(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL, 0);\n\n\treturn changed || mode_changed;\n}\n\nstatic void mtk_pcs_lynxi_restart_an(struct phylink_pcs *pcs)\n{\n\tstruct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);\n\n\tregmap_set_bits(mpcs->regmap, SGMSYS_PCS_CONTROL_1, BMCR_ANRESTART);\n}\n\nstatic void mtk_pcs_lynxi_link_up(struct phylink_pcs *pcs,\n\t\t\t\t  unsigned int neg_mode,\n\t\t\t\t  phy_interface_t interface, int speed,\n\t\t\t\t  int duplex)\n{\n\tstruct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);\n\tunsigned int sgm_mode;\n\n\tif (neg_mode != PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\t \n\t\tif (speed == SPEED_10)\n\t\t\tsgm_mode = SGMII_SPEED_10;\n\t\telse if (speed == SPEED_100)\n\t\t\tsgm_mode = SGMII_SPEED_100;\n\t\telse\n\t\t\tsgm_mode = SGMII_SPEED_1000;\n\n\t\tif (duplex != DUPLEX_FULL)\n\t\t\tsgm_mode |= SGMII_DUPLEX_HALF;\n\n\t\tregmap_update_bits(mpcs->regmap, SGMSYS_SGMII_MODE,\n\t\t\t\t   SGMII_DUPLEX_HALF | SGMII_SPEED_MASK,\n\t\t\t\t   sgm_mode);\n\t}\n}\n\nstatic void mtk_pcs_lynxi_disable(struct phylink_pcs *pcs)\n{\n\tstruct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);\n\n\tmpcs->interface = PHY_INTERFACE_MODE_NA;\n}\n\nstatic const struct phylink_pcs_ops mtk_pcs_lynxi_ops = {\n\t.pcs_get_state = mtk_pcs_lynxi_get_state,\n\t.pcs_config = mtk_pcs_lynxi_config,\n\t.pcs_an_restart = mtk_pcs_lynxi_restart_an,\n\t.pcs_link_up = mtk_pcs_lynxi_link_up,\n\t.pcs_disable = mtk_pcs_lynxi_disable,\n};\n\nstruct phylink_pcs *mtk_pcs_lynxi_create(struct device *dev,\n\t\t\t\t\t struct regmap *regmap, u32 ana_rgc3,\n\t\t\t\t\t u32 flags)\n{\n\tstruct mtk_pcs_lynxi *mpcs;\n\tu32 id, ver;\n\tint ret;\n\n\tret = regmap_read(regmap, SGMSYS_PCS_DEVICE_ID, &id);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tif (id != SGMII_LYNXI_DEV_ID) {\n\t\tdev_err(dev, \"unknown PCS device id %08x\\n\", id);\n\t\treturn NULL;\n\t}\n\n\tret = regmap_read(regmap, SGMSYS_PCS_SCRATCH, &ver);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tver = FIELD_GET(SGMII_DEV_VERSION, ver);\n\tif (ver != 0x1) {\n\t\tdev_err(dev, \"unknown PCS device version %04x\\n\", ver);\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(dev, \"MediaTek LynxI SGMII PCS (id 0x%08x, ver 0x%04x)\\n\", id,\n\t\tver);\n\n\tmpcs = kzalloc(sizeof(*mpcs), GFP_KERNEL);\n\tif (!mpcs)\n\t\treturn NULL;\n\n\tmpcs->ana_rgc3 = ana_rgc3;\n\tmpcs->regmap = regmap;\n\tmpcs->flags = flags;\n\tmpcs->pcs.ops = &mtk_pcs_lynxi_ops;\n\tmpcs->pcs.neg_mode = true;\n\tmpcs->pcs.poll = true;\n\tmpcs->interface = PHY_INTERFACE_MODE_NA;\n\n\treturn &mpcs->pcs;\n}\nEXPORT_SYMBOL(mtk_pcs_lynxi_create);\n\nvoid mtk_pcs_lynxi_destroy(struct phylink_pcs *pcs)\n{\n\tif (!pcs)\n\t\treturn;\n\n\tkfree(pcs_to_mtk_pcs_lynxi(pcs));\n}\nEXPORT_SYMBOL(mtk_pcs_lynxi_destroy);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}