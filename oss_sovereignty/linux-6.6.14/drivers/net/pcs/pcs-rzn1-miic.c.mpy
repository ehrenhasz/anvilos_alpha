{
  "module_name": "pcs-rzn1-miic.c",
  "hash_id": "c69db14731ad86d7eb05e13cee791b61d0794c45f5aebd53199e175aa7627c05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/pcs/pcs-rzn1-miic.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/mdio.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pcs-rzn1-miic.h>\n#include <linux/phylink.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <dt-bindings/net/pcs-rzn1-miic.h>\n\n#define MIIC_PRCMD\t\t\t0x0\n#define MIIC_ESID_CODE\t\t\t0x4\n\n#define MIIC_MODCTRL\t\t\t0x20\n#define MIIC_MODCTRL_SW_MODE\t\tGENMASK(4, 0)\n\n#define MIIC_CONVCTRL(port)\t\t(0x100 + (port) * 4)\n\n#define MIIC_CONVCTRL_CONV_SPEED\tGENMASK(1, 0)\n#define CONV_MODE_10MBPS\t\t0\n#define CONV_MODE_100MBPS\t\t1\n#define CONV_MODE_1000MBPS\t\t2\n\n#define MIIC_CONVCTRL_CONV_MODE\t\tGENMASK(3, 2)\n#define CONV_MODE_MII\t\t\t0\n#define CONV_MODE_RMII\t\t\t1\n#define CONV_MODE_RGMII\t\t\t2\n\n#define MIIC_CONVCTRL_FULLD\t\tBIT(8)\n#define MIIC_CONVCTRL_RGMII_LINK\tBIT(12)\n#define MIIC_CONVCTRL_RGMII_DUPLEX\tBIT(13)\n#define MIIC_CONVCTRL_RGMII_SPEED\tGENMASK(15, 14)\n\n#define MIIC_CONVRST\t\t\t0x114\n#define MIIC_CONVRST_PHYIF_RST(port)\tBIT(port)\n#define MIIC_CONVRST_PHYIF_RST_MASK\tGENMASK(4, 0)\n\n#define MIIC_SWCTRL\t\t\t0x304\n#define MIIC_SWDUPC\t\t\t0x308\n\n#define MIIC_MAX_NR_PORTS\t\t5\n\n#define MIIC_MODCTRL_CONF_CONV_NUM\t6\n#define MIIC_MODCTRL_CONF_NONE\t\t-1\n\n \nstruct modctrl_match {\n\tu32 mode_cfg;\n\tu8 conv[MIIC_MODCTRL_CONF_CONV_NUM];\n};\n\nstatic struct modctrl_match modctrl_match_table[] = {\n\t{0x0, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_SWITCH_PORTC, MIIC_SERCOS_PORTB, MIIC_SERCOS_PORTA}},\n\t{0x1, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_SWITCH_PORTC, MIIC_ETHERCAT_PORTB, MIIC_ETHERCAT_PORTA}},\n\t{0x2, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_ETHERCAT_PORTC, MIIC_ETHERCAT_PORTB, MIIC_ETHERCAT_PORTA}},\n\t{0x3, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_SWITCH_PORTC, MIIC_SWITCH_PORTB, MIIC_SWITCH_PORTA}},\n\n\t{0x8, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_SWITCH_PORTC, MIIC_SERCOS_PORTB, MIIC_SERCOS_PORTA}},\n\t{0x9, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_SWITCH_PORTC, MIIC_ETHERCAT_PORTB, MIIC_ETHERCAT_PORTA}},\n\t{0xA, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_ETHERCAT_PORTC, MIIC_ETHERCAT_PORTB, MIIC_ETHERCAT_PORTA}},\n\t{0xB, {MIIC_RTOS_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t       MIIC_SWITCH_PORTC, MIIC_SWITCH_PORTB, MIIC_SWITCH_PORTA}},\n\n\t{0x10, {MIIC_GMAC2_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t\tMIIC_SWITCH_PORTC, MIIC_SERCOS_PORTB, MIIC_SERCOS_PORTA}},\n\t{0x11, {MIIC_GMAC2_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t\tMIIC_SWITCH_PORTC, MIIC_ETHERCAT_PORTB, MIIC_ETHERCAT_PORTA}},\n\t{0x12, {MIIC_GMAC2_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t\tMIIC_ETHERCAT_PORTC, MIIC_ETHERCAT_PORTB, MIIC_ETHERCAT_PORTA}},\n\t{0x13, {MIIC_GMAC2_PORT, MIIC_GMAC1_PORT, MIIC_SWITCH_PORTD,\n\t\tMIIC_SWITCH_PORTC, MIIC_SWITCH_PORTB, MIIC_SWITCH_PORTA}}\n};\n\nstatic const char * const conf_to_string[] = {\n\t[MIIC_GMAC1_PORT]\t= \"GMAC1_PORT\",\n\t[MIIC_GMAC2_PORT]\t= \"GMAC2_PORT\",\n\t[MIIC_RTOS_PORT]\t= \"RTOS_PORT\",\n\t[MIIC_SERCOS_PORTA]\t= \"SERCOS_PORTA\",\n\t[MIIC_SERCOS_PORTB]\t= \"SERCOS_PORTB\",\n\t[MIIC_ETHERCAT_PORTA]\t= \"ETHERCAT_PORTA\",\n\t[MIIC_ETHERCAT_PORTB]\t= \"ETHERCAT_PORTB\",\n\t[MIIC_ETHERCAT_PORTC]\t= \"ETHERCAT_PORTC\",\n\t[MIIC_SWITCH_PORTA]\t= \"SWITCH_PORTA\",\n\t[MIIC_SWITCH_PORTB]\t= \"SWITCH_PORTB\",\n\t[MIIC_SWITCH_PORTC]\t= \"SWITCH_PORTC\",\n\t[MIIC_SWITCH_PORTD]\t= \"SWITCH_PORTD\",\n\t[MIIC_HSR_PORTA]\t= \"HSR_PORTA\",\n\t[MIIC_HSR_PORTB]\t= \"HSR_PORTB\",\n};\n\nstatic const char *index_to_string[MIIC_MODCTRL_CONF_CONV_NUM] = {\n\t\"SWITCH_PORTIN\",\n\t\"CONV1\",\n\t\"CONV2\",\n\t\"CONV3\",\n\t\"CONV4\",\n\t\"CONV5\",\n};\n\n \nstruct miic {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tspinlock_t lock;\n};\n\n \nstruct miic_port {\n\tstruct miic *miic;\n\tstruct phylink_pcs pcs;\n\tint port;\n\tphy_interface_t interface;\n};\n\nstatic struct miic_port *phylink_pcs_to_miic_port(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct miic_port, pcs);\n}\n\nstatic void miic_reg_writel(struct miic *miic, int offset, u32 value)\n{\n\twritel(value, miic->base + offset);\n}\n\nstatic u32 miic_reg_readl(struct miic *miic, int offset)\n{\n\treturn readl(miic->base + offset);\n}\n\nstatic void miic_reg_rmw(struct miic *miic, int offset, u32 mask, u32 val)\n{\n\tu32 reg;\n\n\tspin_lock(&miic->lock);\n\n\treg = miic_reg_readl(miic, offset);\n\treg &= ~mask;\n\treg |= val;\n\tmiic_reg_writel(miic, offset, reg);\n\n\tspin_unlock(&miic->lock);\n}\n\nstatic void miic_converter_enable(struct miic *miic, int port, int enable)\n{\n\tu32 val = 0;\n\n\tif (enable)\n\t\tval = MIIC_CONVRST_PHYIF_RST(port);\n\n\tmiic_reg_rmw(miic, MIIC_CONVRST, MIIC_CONVRST_PHYIF_RST(port), val);\n}\n\nstatic int miic_config(struct phylink_pcs *pcs, unsigned int mode,\n\t\t       phy_interface_t interface,\n\t\t       const unsigned long *advertising, bool permit)\n{\n\tstruct miic_port *miic_port = phylink_pcs_to_miic_port(pcs);\n\tstruct miic *miic = miic_port->miic;\n\tu32 speed, conv_mode, val, mask;\n\tint port = miic_port->port;\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tconv_mode = CONV_MODE_RMII;\n\t\tspeed = CONV_MODE_100MBPS;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tconv_mode = CONV_MODE_RGMII;\n\t\tspeed = CONV_MODE_1000MBPS;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tconv_mode = CONV_MODE_MII;\n\t\t \n\t\tspeed = CONV_MODE_10MBPS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tval = FIELD_PREP(MIIC_CONVCTRL_CONV_MODE, conv_mode);\n\tmask = MIIC_CONVCTRL_CONV_MODE;\n\n\t \n\tif (interface != miic_port->interface) {\n\t\tval |= FIELD_PREP(MIIC_CONVCTRL_CONV_SPEED, speed);\n\t\tmask |= MIIC_CONVCTRL_CONV_SPEED;\n\t\tmiic_port->interface = interface;\n\t}\n\n\tmiic_reg_rmw(miic, MIIC_CONVCTRL(port), mask, val);\n\tmiic_converter_enable(miic, miic_port->port, 1);\n\n\treturn 0;\n}\n\nstatic void miic_link_up(struct phylink_pcs *pcs, unsigned int mode,\n\t\t\t phy_interface_t interface, int speed, int duplex)\n{\n\tstruct miic_port *miic_port = phylink_pcs_to_miic_port(pcs);\n\tstruct miic *miic = miic_port->miic;\n\tu32 conv_speed = 0, val = 0;\n\tint port = miic_port->port;\n\n\tif (duplex == DUPLEX_FULL)\n\t\tval |= MIIC_CONVCTRL_FULLD;\n\n\t \n\tif (interface != PHY_INTERFACE_MODE_MII) {\n\t\tswitch (speed) {\n\t\tcase SPEED_1000:\n\t\t\tconv_speed = CONV_MODE_1000MBPS;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tconv_speed = CONV_MODE_100MBPS;\n\t\t\tbreak;\n\t\tcase SPEED_10:\n\t\t\tconv_speed = CONV_MODE_10MBPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n\n\tval |= FIELD_PREP(MIIC_CONVCTRL_CONV_SPEED, conv_speed);\n\n\tmiic_reg_rmw(miic, MIIC_CONVCTRL(port),\n\t\t     (MIIC_CONVCTRL_CONV_SPEED | MIIC_CONVCTRL_FULLD), val);\n}\n\nstatic int miic_validate(struct phylink_pcs *pcs, unsigned long *supported,\n\t\t\t const struct phylink_link_state *state)\n{\n\tif (phy_interface_mode_is_rgmii(state->interface) ||\n\t    state->interface == PHY_INTERFACE_MODE_RMII ||\n\t    state->interface == PHY_INTERFACE_MODE_MII)\n\t\treturn 1;\n\n\treturn -EINVAL;\n}\n\nstatic const struct phylink_pcs_ops miic_phylink_ops = {\n\t.pcs_validate = miic_validate,\n\t.pcs_config = miic_config,\n\t.pcs_link_up = miic_link_up,\n};\n\nstruct phylink_pcs *miic_create(struct device *dev, struct device_node *np)\n{\n\tstruct platform_device *pdev;\n\tstruct miic_port *miic_port;\n\tstruct device_node *pcs_np;\n\tstruct miic *miic;\n\tu32 port;\n\n\tif (!of_device_is_available(np))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (of_property_read_u32(np, \"reg\", &port))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (port > MIIC_MAX_NR_PORTS || port < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tpcs_np = of_get_parent(np);\n\tif (!pcs_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!of_device_is_available(pcs_np)) {\n\t\tof_node_put(pcs_np);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tpdev = of_find_device_by_node(pcs_np);\n\tof_node_put(pcs_np);\n\tif (!pdev || !platform_get_drvdata(pdev)) {\n\t\tif (pdev)\n\t\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tmiic_port = kzalloc(sizeof(*miic_port), GFP_KERNEL);\n\tif (!miic_port) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmiic = platform_get_drvdata(pdev);\n\tdevice_link_add(dev, miic->dev, DL_FLAG_AUTOREMOVE_CONSUMER);\n\tput_device(&pdev->dev);\n\n\tmiic_port->miic = miic;\n\tmiic_port->port = port - 1;\n\tmiic_port->pcs.ops = &miic_phylink_ops;\n\n\treturn &miic_port->pcs;\n}\nEXPORT_SYMBOL(miic_create);\n\nvoid miic_destroy(struct phylink_pcs *pcs)\n{\n\tstruct miic_port *miic_port = phylink_pcs_to_miic_port(pcs);\n\n\tmiic_converter_enable(miic_port->miic, miic_port->port, 0);\n\tkfree(miic_port);\n}\nEXPORT_SYMBOL(miic_destroy);\n\nstatic int miic_init_hw(struct miic *miic, u32 cfg_mode)\n{\n\tint port;\n\n\t \n\tmiic_reg_writel(miic, MIIC_PRCMD, 0x00A5);\n\tmiic_reg_writel(miic, MIIC_PRCMD, 0x0001);\n\tmiic_reg_writel(miic, MIIC_PRCMD, 0xFFFE);\n\tmiic_reg_writel(miic, MIIC_PRCMD, 0x0001);\n\n\tmiic_reg_writel(miic, MIIC_MODCTRL,\n\t\t\tFIELD_PREP(MIIC_MODCTRL_SW_MODE, cfg_mode));\n\n\tfor (port = 0; port < MIIC_MAX_NR_PORTS; port++) {\n\t\tmiic_converter_enable(miic, port, 0);\n\t\t \n\t\tmiic_reg_writel(miic, MIIC_SWCTRL, 0x0);\n\t\tmiic_reg_writel(miic, MIIC_SWDUPC, 0x0);\n\t}\n\n\treturn 0;\n}\n\nstatic bool miic_modctrl_match(s8 table_val[MIIC_MODCTRL_CONF_CONV_NUM],\n\t\t\t       s8 dt_val[MIIC_MODCTRL_CONF_CONV_NUM])\n{\n\tint i;\n\n\tfor (i = 0; i < MIIC_MODCTRL_CONF_CONV_NUM; i++) {\n\t\tif (dt_val[i] == MIIC_MODCTRL_CONF_NONE)\n\t\t\tcontinue;\n\n\t\tif (dt_val[i] != table_val[i])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void miic_dump_conf(struct device *dev,\n\t\t\t   s8 conf[MIIC_MODCTRL_CONF_CONV_NUM])\n{\n\tconst char *conf_name;\n\tint i;\n\n\tfor (i = 0; i < MIIC_MODCTRL_CONF_CONV_NUM; i++) {\n\t\tif (conf[i] != MIIC_MODCTRL_CONF_NONE)\n\t\t\tconf_name = conf_to_string[conf[i]];\n\t\telse\n\t\t\tconf_name = \"NONE\";\n\n\t\tdev_err(dev, \"%s: %s\\n\", index_to_string[i], conf_name);\n\t}\n}\n\nstatic int miic_match_dt_conf(struct device *dev,\n\t\t\t      s8 dt_val[MIIC_MODCTRL_CONF_CONV_NUM],\n\t\t\t      u32 *mode_cfg)\n{\n\tstruct modctrl_match *table_entry;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(modctrl_match_table); i++) {\n\t\ttable_entry = &modctrl_match_table[i];\n\n\t\tif (miic_modctrl_match(table_entry->conv, dt_val)) {\n\t\t\t*mode_cfg = table_entry->mode_cfg;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(dev, \"Failed to apply requested configuration\\n\");\n\tmiic_dump_conf(dev, dt_val);\n\n\treturn -EINVAL;\n}\n\nstatic int miic_parse_dt(struct device *dev, u32 *mode_cfg)\n{\n\ts8 dt_val[MIIC_MODCTRL_CONF_CONV_NUM];\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *conv;\n\tu32 conf;\n\tint port;\n\n\tmemset(dt_val, MIIC_MODCTRL_CONF_NONE, sizeof(dt_val));\n\n\tif (of_property_read_u32(np, \"renesas,miic-switch-portin\", &conf) == 0)\n\t\tdt_val[0] = conf;\n\n\tfor_each_child_of_node(np, conv) {\n\t\tif (of_property_read_u32(conv, \"reg\", &port))\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(conv))\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(conv, \"renesas,miic-input\", &conf) == 0)\n\t\t\tdt_val[port] = conf;\n\t}\n\n\treturn miic_match_dt_conf(dev, dt_val, mode_cfg);\n}\n\nstatic int miic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct miic *miic;\n\tu32 mode_cfg;\n\tint ret;\n\n\tret = miic_parse_dt(dev, &mode_cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmiic = devm_kzalloc(dev, sizeof(*miic), GFP_KERNEL);\n\tif (!miic)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&miic->lock);\n\tmiic->dev = dev;\n\tmiic->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(miic->base))\n\t\treturn PTR_ERR(miic->base);\n\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = miic_init_hw(miic, mode_cfg);\n\tif (ret)\n\t\tgoto disable_runtime_pm;\n\n\t \n\tplatform_set_drvdata(pdev, miic);\n\n\treturn 0;\n\ndisable_runtime_pm:\n\tpm_runtime_put(dev);\n\n\treturn ret;\n}\n\nstatic int miic_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id miic_of_mtable[] = {\n\t{ .compatible = \"renesas,rzn1-miic\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, miic_of_mtable);\n\nstatic struct platform_driver miic_driver = {\n\t.driver = {\n\t\t.name\t = \"rzn1_miic\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = miic_of_mtable,\n\t},\n\t.probe = miic_probe,\n\t.remove = miic_remove,\n};\nmodule_platform_driver(miic_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Renesas MII converter PCS driver\");\nMODULE_AUTHOR(\"Cl\u00e9ment L\u00e9ger <clement.leger@bootlin.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}