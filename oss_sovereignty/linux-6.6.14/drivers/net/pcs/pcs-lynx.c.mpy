{
  "module_name": "pcs-lynx.c",
  "hash_id": "06b3c2ab1900866b0f70b8945874fa0dcb90b145749b4b3ef2095e528e671e25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/pcs/pcs-lynx.c",
  "human_readable_source": "\n \n\n#include <linux/mdio.h>\n#include <linux/phylink.h>\n#include <linux/pcs-lynx.h>\n#include <linux/property.h>\n\n#define SGMII_CLOCK_PERIOD_NS\t\t8  \n#define LINK_TIMER_VAL(ns)\t\t((u32)((ns) / SGMII_CLOCK_PERIOD_NS))\n\n#define LINK_TIMER_LO\t\t\t0x12\n#define LINK_TIMER_HI\t\t\t0x13\n#define IF_MODE\t\t\t\t0x14\n#define IF_MODE_SGMII_EN\t\tBIT(0)\n#define IF_MODE_USE_SGMII_AN\t\tBIT(1)\n#define IF_MODE_SPEED(x)\t\t(((x) << 2) & GENMASK(3, 2))\n#define IF_MODE_SPEED_MSK\t\tGENMASK(3, 2)\n#define IF_MODE_HALF_DUPLEX\t\tBIT(4)\n\nstruct lynx_pcs {\n\tstruct phylink_pcs pcs;\n\tstruct mdio_device *mdio;\n};\n\nenum sgmii_speed {\n\tSGMII_SPEED_10\t\t= 0,\n\tSGMII_SPEED_100\t\t= 1,\n\tSGMII_SPEED_1000\t= 2,\n\tSGMII_SPEED_2500\t= 2,\n};\n\n#define phylink_pcs_to_lynx(pl_pcs) container_of((pl_pcs), struct lynx_pcs, pcs)\n#define lynx_to_phylink_pcs(lynx) (&(lynx)->pcs)\n\nstatic void lynx_pcs_get_state_usxgmii(struct mdio_device *pcs,\n\t\t\t\t       struct phylink_link_state *state)\n{\n\tstruct mii_bus *bus = pcs->bus;\n\tint addr = pcs->addr;\n\tint status, lpa;\n\n\tstatus = mdiobus_c45_read(bus, addr, MDIO_MMD_VEND2, MII_BMSR);\n\tif (status < 0)\n\t\treturn;\n\n\tstate->link = !!(status & MDIO_STAT1_LSTATUS);\n\tstate->an_complete = !!(status & MDIO_AN_STAT1_COMPLETE);\n\tif (!state->link || !state->an_complete)\n\t\treturn;\n\n\tlpa = mdiobus_c45_read(bus, addr, MDIO_MMD_VEND2, MII_LPA);\n\tif (lpa < 0)\n\t\treturn;\n\n\tphylink_decode_usxgmii_word(state, lpa);\n}\n\nstatic void lynx_pcs_get_state_2500basex(struct mdio_device *pcs,\n\t\t\t\t\t struct phylink_link_state *state)\n{\n\tint bmsr, lpa;\n\n\tbmsr = mdiodev_read(pcs, MII_BMSR);\n\tlpa = mdiodev_read(pcs, MII_LPA);\n\tif (bmsr < 0 || lpa < 0) {\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tstate->link = !!(bmsr & BMSR_LSTATUS);\n\tstate->an_complete = !!(bmsr & BMSR_ANEGCOMPLETE);\n\tif (!state->link)\n\t\treturn;\n\n\tstate->speed = SPEED_2500;\n\tstate->pause |= MLO_PAUSE_TX | MLO_PAUSE_RX;\n\tstate->duplex = DUPLEX_FULL;\n}\n\nstatic void lynx_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t       struct phylink_link_state *state)\n{\n\tstruct lynx_pcs *lynx = phylink_pcs_to_lynx(pcs);\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\tphylink_mii_c22_pcs_get_state(lynx->mdio, state);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tlynx_pcs_get_state_2500basex(lynx->mdio, state);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tlynx_pcs_get_state_usxgmii(lynx->mdio, state);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tphylink_mii_c45_pcs_get_state(lynx->mdio, state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(&lynx->mdio->dev,\n\t\t\"mode=%s/%s/%s link=%u an_complete=%u\\n\",\n\t\tphy_modes(state->interface),\n\t\tphy_speed_to_str(state->speed),\n\t\tphy_duplex_to_str(state->duplex),\n\t\tstate->link, state->an_complete);\n}\n\nstatic int lynx_pcs_config_giga(struct mdio_device *pcs,\n\t\t\t\tphy_interface_t interface,\n\t\t\t\tconst unsigned long *advertising,\n\t\t\t\tunsigned int neg_mode)\n{\n\tint link_timer_ns;\n\tu32 link_timer;\n\tu16 if_mode;\n\tint err;\n\n\tlink_timer_ns = phylink_get_link_timer_ns(interface);\n\tif (link_timer_ns > 0) {\n\t\tlink_timer = LINK_TIMER_VAL(link_timer_ns);\n\n\t\tmdiodev_write(pcs, LINK_TIMER_LO, link_timer & 0xffff);\n\t\tmdiodev_write(pcs, LINK_TIMER_HI, link_timer >> 16);\n\t}\n\n\tif (interface == PHY_INTERFACE_MODE_1000BASEX) {\n\t\tif_mode = 0;\n\t} else {\n\t\t \n\t\tif_mode = IF_MODE_SGMII_EN;\n\t\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\t\tif_mode |= IF_MODE_USE_SGMII_AN;\n\t}\n\n\terr = mdiodev_modify(pcs, IF_MODE,\n\t\t\t     IF_MODE_SGMII_EN | IF_MODE_USE_SGMII_AN,\n\t\t\t     if_mode);\n\tif (err)\n\t\treturn err;\n\n\treturn phylink_mii_c22_pcs_config(pcs, interface, advertising,\n\t\t\t\t\t  neg_mode);\n}\n\nstatic int lynx_pcs_config_usxgmii(struct mdio_device *pcs,\n\t\t\t\t   const unsigned long *advertising,\n\t\t\t\t   unsigned int neg_mode)\n{\n\tstruct mii_bus *bus = pcs->bus;\n\tint addr = pcs->addr;\n\n\tif (neg_mode != PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\tdev_err(&pcs->dev, \"USXGMII only supports in-band AN for now\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\treturn mdiobus_c45_write(bus, addr, MDIO_MMD_VEND2, MII_ADVERTISE,\n\t\t\t\t MDIO_USXGMII_10G | MDIO_USXGMII_LINK |\n\t\t\t\t MDIO_USXGMII_FULL_DUPLEX |\n\t\t\t\t ADVERTISE_SGMII | ADVERTISE_LPACK);\n}\n\nstatic int lynx_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t   phy_interface_t ifmode,\n\t\t\t   const unsigned long *advertising, bool permit)\n{\n\tstruct lynx_pcs *lynx = phylink_pcs_to_lynx(pcs);\n\n\tswitch (ifmode) {\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\treturn lynx_pcs_config_giga(lynx->mdio, ifmode, advertising,\n\t\t\t\t\t    neg_mode);\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\t\tdev_err(&lynx->mdio->dev,\n\t\t\t\t\"AN not supported on 3.125GHz SerDes lane\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\treturn lynx_pcs_config_usxgmii(lynx->mdio, advertising,\n\t\t\t\t\t       neg_mode);\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void lynx_pcs_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct lynx_pcs *lynx = phylink_pcs_to_lynx(pcs);\n\n\tphylink_mii_c22_pcs_an_restart(lynx->mdio);\n}\n\nstatic void lynx_pcs_link_up_sgmii(struct mdio_device *pcs,\n\t\t\t\t   unsigned int neg_mode,\n\t\t\t\t   int speed, int duplex)\n{\n\tu16 if_mode = 0, sgmii_speed;\n\n\t \n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\treturn;\n\n\tif (duplex == DUPLEX_HALF)\n\t\tif_mode |= IF_MODE_HALF_DUPLEX;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tsgmii_speed = SGMII_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tsgmii_speed = SGMII_SPEED_100;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tsgmii_speed = SGMII_SPEED_10;\n\t\tbreak;\n\tcase SPEED_UNKNOWN:\n\t\t \n\t\treturn;\n\tdefault:\n\t\tdev_err(&pcs->dev, \"Invalid PCS speed %d\\n\", speed);\n\t\treturn;\n\t}\n\tif_mode |= IF_MODE_SPEED(sgmii_speed);\n\n\tmdiodev_modify(pcs, IF_MODE,\n\t\t       IF_MODE_HALF_DUPLEX | IF_MODE_SPEED_MSK,\n\t\t       if_mode);\n}\n\n \nstatic void lynx_pcs_link_up_2500basex(struct mdio_device *pcs,\n\t\t\t\t       unsigned int neg_mode,\n\t\t\t\t       int speed, int duplex)\n{\n\tu16 if_mode = 0;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\tdev_err(&pcs->dev, \"AN not supported for 2500BaseX\\n\");\n\t\treturn;\n\t}\n\n\tif (duplex == DUPLEX_HALF)\n\t\tif_mode |= IF_MODE_HALF_DUPLEX;\n\tif_mode |= IF_MODE_SPEED(SGMII_SPEED_2500);\n\n\tmdiodev_modify(pcs, IF_MODE,\n\t\t       IF_MODE_HALF_DUPLEX | IF_MODE_SPEED_MSK,\n\t\t       if_mode);\n}\n\nstatic void lynx_pcs_link_up(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t     phy_interface_t interface,\n\t\t\t     int speed, int duplex)\n{\n\tstruct lynx_pcs *lynx = phylink_pcs_to_lynx(pcs);\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\tlynx_pcs_link_up_sgmii(lynx->mdio, neg_mode, speed, duplex);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tlynx_pcs_link_up_2500basex(lynx->mdio, neg_mode, speed, duplex);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct phylink_pcs_ops lynx_pcs_phylink_ops = {\n\t.pcs_get_state = lynx_pcs_get_state,\n\t.pcs_config = lynx_pcs_config,\n\t.pcs_an_restart = lynx_pcs_an_restart,\n\t.pcs_link_up = lynx_pcs_link_up,\n};\n\nstatic struct phylink_pcs *lynx_pcs_create(struct mdio_device *mdio)\n{\n\tstruct lynx_pcs *lynx;\n\n\tlynx = kzalloc(sizeof(*lynx), GFP_KERNEL);\n\tif (!lynx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmdio_device_get(mdio);\n\tlynx->mdio = mdio;\n\tlynx->pcs.ops = &lynx_pcs_phylink_ops;\n\tlynx->pcs.neg_mode = true;\n\tlynx->pcs.poll = true;\n\n\treturn lynx_to_phylink_pcs(lynx);\n}\n\nstruct phylink_pcs *lynx_pcs_create_mdiodev(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdio;\n\tstruct phylink_pcs *pcs;\n\n\tmdio = mdio_device_create(bus, addr);\n\tif (IS_ERR(mdio))\n\t\treturn ERR_CAST(mdio);\n\n\tpcs = lynx_pcs_create(mdio);\n\n\t \n\tmdio_device_put(mdio);\n\n\treturn pcs;\n}\nEXPORT_SYMBOL(lynx_pcs_create_mdiodev);\n\n \nstruct phylink_pcs *lynx_pcs_create_fwnode(struct fwnode_handle *node)\n{\n\tstruct mdio_device *mdio;\n\tstruct phylink_pcs *pcs;\n\n\tif (!fwnode_device_is_available(node))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmdio = fwnode_mdio_find_device(node);\n\tif (!mdio)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tpcs = lynx_pcs_create(mdio);\n\n\t \n\tmdio_device_put(mdio);\n\n\treturn pcs;\n}\nEXPORT_SYMBOL_GPL(lynx_pcs_create_fwnode);\n\nvoid lynx_pcs_destroy(struct phylink_pcs *pcs)\n{\n\tstruct lynx_pcs *lynx = phylink_pcs_to_lynx(pcs);\n\n\tmdio_device_put(lynx->mdio);\n\tkfree(lynx);\n}\nEXPORT_SYMBOL(lynx_pcs_destroy);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}