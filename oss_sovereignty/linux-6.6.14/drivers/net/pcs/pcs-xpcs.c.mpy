{
  "module_name": "pcs-xpcs.c",
  "hash_id": "c87f94e9b4c54ed5c49608ddc4d263222a2ea124fe2f04f988b85c1e9be01e8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/pcs/pcs-xpcs.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pcs/pcs-xpcs.h>\n#include <linux/mdio.h>\n#include <linux/phylink.h>\n#include <linux/workqueue.h>\n#include \"pcs-xpcs.h\"\n\n#define phylink_pcs_to_xpcs(pl_pcs) \\\n\tcontainer_of((pl_pcs), struct dw_xpcs, pcs)\n\nstatic const int xpcs_usxgmii_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_Autoneg_BIT,\n\tETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\tETHTOOL_LINK_MODE_2500baseX_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const int xpcs_10gkr_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const int xpcs_xlgmii_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\tETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\tETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,\n\tETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseCR2_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseKR2_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseSR2_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseKR_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseSR_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseCR_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\tETHTOOL_LINK_MODE_50000baseDR_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseKR4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseSR4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseKR2_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseSR2_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseCR2_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT,\n\tETHTOOL_LINK_MODE_100000baseDR2_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const int xpcs_10gbaser_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseLRM_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseER_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const int xpcs_sgmii_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_Autoneg_BIT,\n\tETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\tETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\tETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\tETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const int xpcs_1000basex_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_Autoneg_BIT,\n\tETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const int xpcs_2500basex_features[] = {\n\tETHTOOL_LINK_MODE_Pause_BIT,\n\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\tETHTOOL_LINK_MODE_Autoneg_BIT,\n\tETHTOOL_LINK_MODE_2500baseX_Full_BIT,\n\tETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t__ETHTOOL_LINK_MODE_MASK_NBITS,\n};\n\nstatic const phy_interface_t xpcs_usxgmii_interfaces[] = {\n\tPHY_INTERFACE_MODE_USXGMII,\n};\n\nstatic const phy_interface_t xpcs_10gkr_interfaces[] = {\n\tPHY_INTERFACE_MODE_10GKR,\n};\n\nstatic const phy_interface_t xpcs_xlgmii_interfaces[] = {\n\tPHY_INTERFACE_MODE_XLGMII,\n};\n\nstatic const phy_interface_t xpcs_10gbaser_interfaces[] = {\n\tPHY_INTERFACE_MODE_10GBASER,\n};\n\nstatic const phy_interface_t xpcs_sgmii_interfaces[] = {\n\tPHY_INTERFACE_MODE_SGMII,\n};\n\nstatic const phy_interface_t xpcs_1000basex_interfaces[] = {\n\tPHY_INTERFACE_MODE_1000BASEX,\n};\n\nstatic const phy_interface_t xpcs_2500basex_interfaces[] = {\n\tPHY_INTERFACE_MODE_2500BASEX,\n\tPHY_INTERFACE_MODE_MAX,\n};\n\nenum {\n\tDW_XPCS_USXGMII,\n\tDW_XPCS_10GKR,\n\tDW_XPCS_XLGMII,\n\tDW_XPCS_10GBASER,\n\tDW_XPCS_SGMII,\n\tDW_XPCS_1000BASEX,\n\tDW_XPCS_2500BASEX,\n\tDW_XPCS_INTERFACE_MAX,\n};\n\nstruct xpcs_compat {\n\tconst int *supported;\n\tconst phy_interface_t *interface;\n\tint num_interfaces;\n\tint an_mode;\n\tint (*pma_config)(struct dw_xpcs *xpcs);\n};\n\nstruct xpcs_id {\n\tu32 id;\n\tu32 mask;\n\tconst struct xpcs_compat *compat;\n};\n\nstatic const struct xpcs_compat *xpcs_find_compat(const struct xpcs_id *id,\n\t\t\t\t\t\t  phy_interface_t interface)\n{\n\tint i, j;\n\n\tfor (i = 0; i < DW_XPCS_INTERFACE_MAX; i++) {\n\t\tconst struct xpcs_compat *compat = &id->compat[i];\n\n\t\tfor (j = 0; j < compat->num_interfaces; j++)\n\t\t\tif (compat->interface[j] == interface)\n\t\t\t\treturn compat;\n\t}\n\n\treturn NULL;\n}\n\nint xpcs_get_an_mode(struct dw_xpcs *xpcs, phy_interface_t interface)\n{\n\tconst struct xpcs_compat *compat;\n\n\tcompat = xpcs_find_compat(xpcs->id, interface);\n\tif (!compat)\n\t\treturn -ENODEV;\n\n\treturn compat->an_mode;\n}\nEXPORT_SYMBOL_GPL(xpcs_get_an_mode);\n\nstatic bool __xpcs_linkmode_supported(const struct xpcs_compat *compat,\n\t\t\t\t      enum ethtool_link_mode_bit_indices linkmode)\n{\n\tint i;\n\n\tfor (i = 0; compat->supported[i] != __ETHTOOL_LINK_MODE_MASK_NBITS; i++)\n\t\tif (compat->supported[i] == linkmode)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n#define xpcs_linkmode_supported(compat, mode) \\\n\t__xpcs_linkmode_supported(compat, ETHTOOL_LINK_MODE_ ## mode ## _BIT)\n\nint xpcs_read(struct dw_xpcs *xpcs, int dev, u32 reg)\n{\n\treturn mdiodev_c45_read(xpcs->mdiodev, dev, reg);\n}\n\nint xpcs_write(struct dw_xpcs *xpcs, int dev, u32 reg, u16 val)\n{\n\treturn mdiodev_c45_write(xpcs->mdiodev, dev, reg, val);\n}\n\nstatic int xpcs_modify_changed(struct dw_xpcs *xpcs, int dev, u32 reg,\n\t\t\t       u16 mask, u16 set)\n{\n\treturn mdiodev_c45_modify_changed(xpcs->mdiodev, dev, reg, mask, set);\n}\n\nstatic int xpcs_read_vendor(struct dw_xpcs *xpcs, int dev, u32 reg)\n{\n\treturn xpcs_read(xpcs, dev, DW_VENDOR | reg);\n}\n\nstatic int xpcs_write_vendor(struct dw_xpcs *xpcs, int dev, int reg,\n\t\t\t     u16 val)\n{\n\treturn xpcs_write(xpcs, dev, DW_VENDOR | reg, val);\n}\n\nint xpcs_read_vpcs(struct dw_xpcs *xpcs, int reg)\n{\n\treturn xpcs_read_vendor(xpcs, MDIO_MMD_PCS, reg);\n}\n\nint xpcs_write_vpcs(struct dw_xpcs *xpcs, int reg, u16 val)\n{\n\treturn xpcs_write_vendor(xpcs, MDIO_MMD_PCS, reg, val);\n}\n\nstatic int xpcs_dev_flag(struct dw_xpcs *xpcs)\n{\n\tint ret, oui;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_PMAPMD, MDIO_DEVID1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\toui = ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_PMAPMD, MDIO_DEVID2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = (ret >> 10) & 0x3F;\n\toui |= ret << 16;\n\n\tif (oui == DW_OUI_WX)\n\t\txpcs->dev_flag = DW_DEV_TXGBE;\n\n\treturn 0;\n}\n\nstatic int xpcs_poll_reset(struct dw_xpcs *xpcs, int dev)\n{\n\t \n\tunsigned int retries = 12;\n\tint ret;\n\n\tdo {\n\t\tmsleep(50);\n\t\tret = xpcs_read(xpcs, dev, MDIO_CTRL1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} while (ret & MDIO_CTRL1_RESET && --retries);\n\n\treturn (ret & MDIO_CTRL1_RESET) ? -ETIMEDOUT : 0;\n}\n\nstatic int xpcs_soft_reset(struct dw_xpcs *xpcs,\n\t\t\t   const struct xpcs_compat *compat)\n{\n\tint ret, dev;\n\n\tswitch (compat->an_mode) {\n\tcase DW_AN_C73:\n\tcase DW_10GBASER:\n\t\tdev = MDIO_MMD_PCS;\n\t\tbreak;\n\tcase DW_AN_C37_SGMII:\n\tcase DW_2500BASEX:\n\tcase DW_AN_C37_1000BASEX:\n\t\tdev = MDIO_MMD_VEND2;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tret = xpcs_write(xpcs, dev, MDIO_CTRL1, MDIO_CTRL1_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn xpcs_poll_reset(xpcs, dev);\n}\n\n#define xpcs_warn(__xpcs, __state, __args...) \\\n({ \\\n\tif ((__state)->link) \\\n\t\tdev_warn(&(__xpcs)->mdiodev->dev, ##__args); \\\n})\n\nstatic int xpcs_read_fault_c73(struct dw_xpcs *xpcs,\n\t\t\t       struct phylink_link_state *state,\n\t\t\t       u16 pcs_stat1)\n{\n\tint ret;\n\n\tif (pcs_stat1 & MDIO_STAT1_FAULT) {\n\t\txpcs_warn(xpcs, state, \"Link fault condition detected!\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tret = xpcs_read(xpcs, MDIO_MMD_PCS, MDIO_STAT2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & MDIO_STAT2_RXFAULT)\n\t\txpcs_warn(xpcs, state, \"Receiver fault detected!\\n\");\n\tif (ret & MDIO_STAT2_TXFAULT)\n\t\txpcs_warn(xpcs, state, \"Transmitter fault detected!\\n\");\n\n\tret = xpcs_read_vendor(xpcs, MDIO_MMD_PCS, DW_VR_XS_PCS_DIG_STS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & DW_RXFIFO_ERR) {\n\t\txpcs_warn(xpcs, state, \"FIFO fault condition detected!\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tret = xpcs_read(xpcs, MDIO_MMD_PCS, MDIO_PCS_10GBRT_STAT1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(ret & MDIO_PCS_10GBRT_STAT1_BLKLK))\n\t\txpcs_warn(xpcs, state, \"Link is not locked!\\n\");\n\n\tret = xpcs_read(xpcs, MDIO_MMD_PCS, MDIO_PCS_10GBRT_STAT2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & MDIO_PCS_10GBRT_STAT2_ERR) {\n\t\txpcs_warn(xpcs, state, \"Link has errors!\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic void xpcs_config_usxgmii(struct dw_xpcs *xpcs, int speed)\n{\n\tint ret, speed_sel;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tspeed_sel = DW_USXGMII_10;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tspeed_sel = DW_USXGMII_100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tspeed_sel = DW_USXGMII_1000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tspeed_sel = DW_USXGMII_2500;\n\t\tbreak;\n\tcase SPEED_5000:\n\t\tspeed_sel = DW_USXGMII_5000;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\tspeed_sel = DW_USXGMII_10000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\tret = xpcs_read_vpcs(xpcs, MDIO_CTRL1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = xpcs_write_vpcs(xpcs, MDIO_CTRL1, ret | DW_USXGMII_EN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret &= ~DW_USXGMII_SS_MASK;\n\tret |= speed_sel | DW_USXGMII_FULL;\n\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = xpcs_read_vpcs(xpcs, MDIO_CTRL1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = xpcs_write_vpcs(xpcs, MDIO_CTRL1, ret | DW_USXGMII_RST);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn;\n\nout:\n\tpr_err(\"%s: XPCS access returned %pe\\n\", __func__, ERR_PTR(ret));\n}\n\nstatic int _xpcs_config_aneg_c73(struct dw_xpcs *xpcs,\n\t\t\t\t const struct xpcs_compat *compat)\n{\n\tint ret, adv;\n\n\t \n\n\t \n\tadv = 0;\n\tif (xpcs_linkmode_supported(compat, 2500baseX_Full))\n\t\tadv |= DW_C73_2500KX;\n\n\t \n\n\tret = xpcs_write(xpcs, MDIO_MMD_AN, DW_SR_AN_ADV3, adv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tadv = 0;\n\tif (xpcs_linkmode_supported(compat, 1000baseKX_Full))\n\t\tadv |= DW_C73_1000KX;\n\tif (xpcs_linkmode_supported(compat, 10000baseKX4_Full))\n\t\tadv |= DW_C73_10000KX4;\n\tif (xpcs_linkmode_supported(compat, 10000baseKR_Full))\n\t\tadv |= DW_C73_10000KR;\n\n\tret = xpcs_write(xpcs, MDIO_MMD_AN, DW_SR_AN_ADV2, adv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tadv = DW_C73_AN_ADV_SF;\n\tif (xpcs_linkmode_supported(compat, Pause))\n\t\tadv |= DW_C73_PAUSE;\n\tif (xpcs_linkmode_supported(compat, Asym_Pause))\n\t\tadv |= DW_C73_ASYM_PAUSE;\n\n\treturn xpcs_write(xpcs, MDIO_MMD_AN, DW_SR_AN_ADV1, adv);\n}\n\nstatic int xpcs_config_aneg_c73(struct dw_xpcs *xpcs,\n\t\t\t\tconst struct xpcs_compat *compat)\n{\n\tint ret;\n\n\tret = _xpcs_config_aneg_c73(xpcs, compat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_AN, MDIO_CTRL1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret |= MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART;\n\n\treturn xpcs_write(xpcs, MDIO_MMD_AN, MDIO_CTRL1, ret);\n}\n\nstatic int xpcs_aneg_done_c73(struct dw_xpcs *xpcs,\n\t\t\t      struct phylink_link_state *state,\n\t\t\t      const struct xpcs_compat *compat, u16 an_stat1)\n{\n\tint ret;\n\n\tif (an_stat1 & MDIO_AN_STAT1_COMPLETE) {\n\t\tret = xpcs_read(xpcs, MDIO_MMD_AN, MDIO_AN_LPA);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!(ret & DW_C73_AN_ADV_SF)) {\n\t\t\txpcs_config_aneg_c73(xpcs, compat);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int xpcs_read_lpa_c73(struct dw_xpcs *xpcs,\n\t\t\t     struct phylink_link_state *state, u16 an_stat1)\n{\n\tu16 lpa[3];\n\tint i, ret;\n\n\tif (!(an_stat1 & MDIO_AN_STAT1_LPABLE)) {\n\t\tphylink_clear(state->lp_advertising, Autoneg);\n\t\treturn 0;\n\t}\n\n\tphylink_set(state->lp_advertising, Autoneg);\n\n\t \n\tfor (i = ARRAY_SIZE(lpa); --i >= 0; ) {\n\t\tret = xpcs_read(xpcs, MDIO_MMD_AN, MDIO_AN_LPA + i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tlpa[i] = ret;\n\t}\n\n\tmii_c73_mod_linkmode(state->lp_advertising, lpa);\n\n\treturn 0;\n}\n\nstatic int xpcs_get_max_xlgmii_speed(struct dw_xpcs *xpcs,\n\t\t\t\t     struct phylink_link_state *state)\n{\n\tunsigned long *adv = state->advertising;\n\tint speed = SPEED_UNKNOWN;\n\tint bit;\n\n\tfor_each_set_bit(bit, adv, __ETHTOOL_LINK_MODE_MASK_NBITS) {\n\t\tint new_speed = SPEED_UNKNOWN;\n\n\t\tswitch (bit) {\n\t\tcase ETHTOOL_LINK_MODE_25000baseCR_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_25000baseKR_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_25000baseSR_Full_BIT:\n\t\t\tnew_speed = SPEED_25000;\n\t\t\tbreak;\n\t\tcase ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT:\n\t\t\tnew_speed = SPEED_40000;\n\t\t\tbreak;\n\t\tcase ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseKR_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseSR_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseCR_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_50000baseDR_Full_BIT:\n\t\t\tnew_speed = SPEED_50000;\n\t\t\tbreak;\n\t\tcase ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT:\n\t\tcase ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT:\n\t\t\tnew_speed = SPEED_100000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_speed > speed)\n\t\t\tspeed = new_speed;\n\t}\n\n\treturn speed;\n}\n\nstatic void xpcs_resolve_pma(struct dw_xpcs *xpcs,\n\t\t\t     struct phylink_link_state *state)\n{\n\tstate->pause = MLO_PAUSE_TX | MLO_PAUSE_RX;\n\tstate->duplex = DUPLEX_FULL;\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_10GKR:\n\t\tstate->speed = SPEED_10000;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_XLGMII:\n\t\tstate->speed = xpcs_get_max_xlgmii_speed(xpcs, state);\n\t\tbreak;\n\tdefault:\n\t\tstate->speed = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\nstatic int xpcs_validate(struct phylink_pcs *pcs, unsigned long *supported,\n\t\t\t const struct phylink_link_state *state)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(xpcs_supported) = { 0, };\n\tconst struct xpcs_compat *compat;\n\tstruct dw_xpcs *xpcs;\n\tint i;\n\n\txpcs = phylink_pcs_to_xpcs(pcs);\n\tcompat = xpcs_find_compat(xpcs->id, state->interface);\n\n\t \n\tif (compat)\n\t\tfor (i = 0; compat->supported[i] != __ETHTOOL_LINK_MODE_MASK_NBITS; i++)\n\t\t\tset_bit(compat->supported[i], xpcs_supported);\n\n\tlinkmode_and(supported, supported, xpcs_supported);\n\n\treturn 0;\n}\n\nvoid xpcs_get_interfaces(struct dw_xpcs *xpcs, unsigned long *interfaces)\n{\n\tint i, j;\n\n\tfor (i = 0; i < DW_XPCS_INTERFACE_MAX; i++) {\n\t\tconst struct xpcs_compat *compat = &xpcs->id->compat[i];\n\n\t\tfor (j = 0; j < compat->num_interfaces; j++)\n\t\t\tif (compat->interface[j] < PHY_INTERFACE_MODE_MAX)\n\t\t\t\t__set_bit(compat->interface[j], interfaces);\n\t}\n}\nEXPORT_SYMBOL_GPL(xpcs_get_interfaces);\n\nint xpcs_config_eee(struct dw_xpcs *xpcs, int mult_fact_100ns, int enable)\n{\n\tint ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_EEE_MCTRL0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable) {\n\t \n\t\tret = DW_VR_MII_EEE_LTX_EN | DW_VR_MII_EEE_LRX_EN |\n\t\t      DW_VR_MII_EEE_TX_QUIET_EN | DW_VR_MII_EEE_RX_QUIET_EN |\n\t\t      DW_VR_MII_EEE_TX_EN_CTRL | DW_VR_MII_EEE_RX_EN_CTRL |\n\t\t      mult_fact_100ns << DW_VR_MII_EEE_MULT_FACT_100NS_SHIFT;\n\t} else {\n\t\tret &= ~(DW_VR_MII_EEE_LTX_EN | DW_VR_MII_EEE_LRX_EN |\n\t\t       DW_VR_MII_EEE_TX_QUIET_EN | DW_VR_MII_EEE_RX_QUIET_EN |\n\t\t       DW_VR_MII_EEE_TX_EN_CTRL | DW_VR_MII_EEE_RX_EN_CTRL |\n\t\t       DW_VR_MII_EEE_MULT_FACT_100NS);\n\t}\n\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_EEE_MCTRL0, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_EEE_MCTRL1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enable)\n\t\tret |= DW_VR_MII_EEE_TRN_LPI;\n\telse\n\t\tret &= ~DW_VR_MII_EEE_TRN_LPI;\n\n\treturn xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_EEE_MCTRL1, ret);\n}\nEXPORT_SYMBOL_GPL(xpcs_config_eee);\n\nstatic int xpcs_config_aneg_c37_sgmii(struct dw_xpcs *xpcs,\n\t\t\t\t      unsigned int neg_mode)\n{\n\tint ret, mdio_ctrl, tx_conf;\n\n\tif (xpcs->dev_flag == DW_DEV_TXGBE)\n\t\txpcs_write_vpcs(xpcs, DW_VR_XS_PCS_DIG_CTRL1, DW_CL37_BP | DW_EN_VSMMD1);\n\n\t \n\tmdio_ctrl = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL);\n\tif (mdio_ctrl < 0)\n\t\treturn mdio_ctrl;\n\n\tif (mdio_ctrl & AN_CL37_EN) {\n\t\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL,\n\t\t\t\t mdio_ctrl & ~AN_CL37_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~(DW_VR_MII_PCS_MODE_MASK | DW_VR_MII_TX_CONFIG_MASK);\n\tret |= (DW_VR_MII_PCS_MODE_C37_SGMII <<\n\t\tDW_VR_MII_AN_CTRL_PCS_MODE_SHIFT &\n\t\tDW_VR_MII_PCS_MODE_MASK);\n\tif (xpcs->dev_flag == DW_DEV_TXGBE) {\n\t\tret |= DW_VR_MII_AN_CTRL_8BIT;\n\t\t \n\t\ttx_conf = DW_VR_MII_TX_CONFIG_PHY_SIDE_SGMII;\n\t} else {\n\t\ttx_conf = DW_VR_MII_TX_CONFIG_MAC_SIDE_SGMII;\n\t}\n\tret |= tx_conf << DW_VR_MII_AN_CTRL_TX_CONFIG_SHIFT &\n\t\tDW_VR_MII_TX_CONFIG_MASK;\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_CTRL, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_DIG_CTRL1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\tret |= DW_VR_MII_DIG_CTRL1_MAC_AUTO_SW;\n\telse\n\t\tret &= ~DW_VR_MII_DIG_CTRL1_MAC_AUTO_SW;\n\n\tif (xpcs->dev_flag == DW_DEV_TXGBE)\n\t\tret |= DW_VR_MII_DIG_CTRL1_PHY_MODE_CTRL;\n\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_DIG_CTRL1, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL,\n\t\t\t\t mdio_ctrl | AN_CL37_EN);\n\n\treturn ret;\n}\n\nstatic int xpcs_config_aneg_c37_1000basex(struct dw_xpcs *xpcs,\n\t\t\t\t\t  unsigned int neg_mode,\n\t\t\t\t\t  const unsigned long *advertising)\n{\n\tphy_interface_t interface = PHY_INTERFACE_MODE_1000BASEX;\n\tint ret, mdio_ctrl, adv;\n\tbool changed = 0;\n\n\tif (xpcs->dev_flag == DW_DEV_TXGBE)\n\t\txpcs_write_vpcs(xpcs, DW_VR_XS_PCS_DIG_CTRL1, DW_CL37_BP | DW_EN_VSMMD1);\n\n\t \n\tmdio_ctrl = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL);\n\tif (mdio_ctrl < 0)\n\t\treturn mdio_ctrl;\n\n\tif (mdio_ctrl & AN_CL37_EN) {\n\t\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL,\n\t\t\t\t mdio_ctrl & ~AN_CL37_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~DW_VR_MII_PCS_MODE_MASK;\n\tif (!xpcs->pcs.poll)\n\t\tret |= DW_VR_MII_AN_INTR_EN;\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_CTRL, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tadv = phylink_mii_c22_pcs_encode_advertisement(interface,\n\t\t\t\t\t\t       advertising);\n\tif (adv >= 0) {\n\t\tret = xpcs_modify_changed(xpcs, MDIO_MMD_VEND2,\n\t\t\t\t\t  MII_ADVERTISE, 0xffff, adv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchanged = ret;\n\t}\n\n\t \n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_INTR_STS, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL,\n\t\t\t\t mdio_ctrl | AN_CL37_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn changed;\n}\n\nstatic int xpcs_config_2500basex(struct dw_xpcs *xpcs)\n{\n\tint ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_DIG_CTRL1);\n\tif (ret < 0)\n\t\treturn ret;\n\tret |= DW_VR_MII_DIG_CTRL1_2G5_EN;\n\tret &= ~DW_VR_MII_DIG_CTRL1_MAC_AUTO_SW;\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_DIG_CTRL1, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\tret &= ~AN_CL37_EN;\n\tret |= SGMII_SPEED_SS6;\n\tret &= ~SGMII_SPEED_SS13;\n\treturn xpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_MMD_CTRL, ret);\n}\n\nint xpcs_do_config(struct dw_xpcs *xpcs, phy_interface_t interface,\n\t\t   const unsigned long *advertising, unsigned int neg_mode)\n{\n\tconst struct xpcs_compat *compat;\n\tint ret;\n\n\tcompat = xpcs_find_compat(xpcs->id, interface);\n\tif (!compat)\n\t\treturn -ENODEV;\n\n\tif (xpcs->dev_flag == DW_DEV_TXGBE) {\n\t\tret = txgbe_xpcs_switch_mode(xpcs, interface);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (compat->an_mode) {\n\tcase DW_10GBASER:\n\t\tbreak;\n\tcase DW_AN_C73:\n\t\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED) {\n\t\t\tret = xpcs_config_aneg_c73(xpcs, compat);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase DW_AN_C37_SGMII:\n\t\tret = xpcs_config_aneg_c37_sgmii(xpcs, neg_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DW_AN_C37_1000BASEX:\n\t\tret = xpcs_config_aneg_c37_1000basex(xpcs, neg_mode,\n\t\t\t\t\t\t     advertising);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DW_2500BASEX:\n\t\tret = xpcs_config_2500basex(xpcs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tif (compat->pma_config) {\n\t\tret = compat->pma_config(xpcs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xpcs_do_config);\n\nstatic int xpcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t       phy_interface_t interface,\n\t\t       const unsigned long *advertising,\n\t\t       bool permit_pause_to_mac)\n{\n\tstruct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);\n\n\treturn xpcs_do_config(xpcs, interface, advertising, neg_mode);\n}\n\nstatic int xpcs_get_state_c73(struct dw_xpcs *xpcs,\n\t\t\t      struct phylink_link_state *state,\n\t\t\t      const struct xpcs_compat *compat)\n{\n\tbool an_enabled;\n\tint pcs_stat1;\n\tint an_stat1;\n\tint ret;\n\n\t \n\tpcs_stat1 = xpcs_read(xpcs, MDIO_MMD_PCS, MDIO_STAT1);\n\tif (pcs_stat1 < 0) {\n\t\tstate->link = false;\n\t\treturn pcs_stat1;\n\t}\n\n\t \n\tstate->link = !!(pcs_stat1 & MDIO_STAT1_LSTATUS);\n\n\t \n\tret = xpcs_read_fault_c73(xpcs, state, pcs_stat1);\n\tif (ret) {\n\t\tret = xpcs_soft_reset(xpcs, compat);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstate->link = 0;\n\n\t\treturn xpcs_do_config(xpcs, state->interface, NULL,\n\t\t\t\t      PHYLINK_PCS_NEG_INBAND_ENABLED);\n\t}\n\n\t \n\tif (!state->link)\n\t\treturn 0;\n\n\tan_enabled = linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t       state->advertising);\n\tif (an_enabled) {\n\t\t \n\t\tan_stat1 = xpcs_read(xpcs, MDIO_MMD_AN, MDIO_STAT1);\n\t\tif (an_stat1 < 0) {\n\t\t\tstate->link = false;\n\t\t\treturn an_stat1;\n\t\t}\n\n\t\tstate->an_complete = xpcs_aneg_done_c73(xpcs, state, compat,\n\t\t\t\t\t\t\tan_stat1);\n\t\tif (!state->an_complete) {\n\t\t\tstate->link = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = xpcs_read_lpa_c73(xpcs, state, an_stat1);\n\t\tif (ret < 0) {\n\t\t\tstate->link = false;\n\t\t\treturn ret;\n\t\t}\n\n\t\tphylink_resolve_c73(state);\n\t} else {\n\t\txpcs_resolve_pma(xpcs, state);\n\t}\n\n\treturn 0;\n}\n\nstatic int xpcs_get_state_c37_sgmii(struct dw_xpcs *xpcs,\n\t\t\t\t    struct phylink_link_state *state)\n{\n\tint ret;\n\n\t \n\tstate->link = false;\n\tstate->speed = SPEED_UNKNOWN;\n\tstate->duplex = DUPLEX_UNKNOWN;\n\tstate->pause = 0;\n\n\t \n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_INTR_STS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & DW_VR_MII_C37_ANSGM_SP_LNKSTS) {\n\t\tint speed_value;\n\n\t\tstate->link = true;\n\n\t\tspeed_value = (ret & DW_VR_MII_AN_STS_C37_ANSGM_SP) >>\n\t\t\t      DW_VR_MII_AN_STS_C37_ANSGM_SP_SHIFT;\n\t\tif (speed_value == DW_VR_MII_C37_ANSGM_SP_1000)\n\t\t\tstate->speed = SPEED_1000;\n\t\telse if (speed_value == DW_VR_MII_C37_ANSGM_SP_100)\n\t\t\tstate->speed = SPEED_100;\n\t\telse\n\t\t\tstate->speed = SPEED_10;\n\n\t\tif (ret & DW_VR_MII_AN_STS_C37_ANSGM_FD)\n\t\t\tstate->duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tstate->duplex = DUPLEX_HALF;\n\t} else if (ret == DW_VR_MII_AN_STS_C37_ANCMPLT_INTR) {\n\t\tint speed, duplex;\n\n\t\tstate->link = true;\n\n\t\tspeed = xpcs_read(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1);\n\t\tif (speed < 0)\n\t\t\treturn speed;\n\n\t\tspeed &= SGMII_SPEED_SS13 | SGMII_SPEED_SS6;\n\t\tif (speed == SGMII_SPEED_SS6)\n\t\t\tstate->speed = SPEED_1000;\n\t\telse if (speed == SGMII_SPEED_SS13)\n\t\t\tstate->speed = SPEED_100;\n\t\telse if (speed == 0)\n\t\t\tstate->speed = SPEED_10;\n\n\t\tduplex = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_ADVERTISE);\n\t\tif (duplex < 0)\n\t\t\treturn duplex;\n\n\t\tif (duplex & DW_FULL_DUPLEX)\n\t\t\tstate->duplex = DUPLEX_FULL;\n\t\telse if (duplex & DW_HALF_DUPLEX)\n\t\t\tstate->duplex = DUPLEX_HALF;\n\n\t\txpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_INTR_STS, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int xpcs_get_state_c37_1000basex(struct dw_xpcs *xpcs,\n\t\t\t\t\tstruct phylink_link_state *state)\n{\n\tint lpa, bmsr;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t      state->advertising)) {\n\t\t \n\t\tstate->link = false;\n\n\t\tlpa = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_LPA);\n\t\tif (lpa < 0 || lpa & LPA_RFAULT)\n\t\t\treturn lpa;\n\n\t\tbmsr = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_BMSR);\n\t\tif (bmsr < 0)\n\t\t\treturn bmsr;\n\n\t\t \n\t\tif (!xpcs->pcs.poll) {\n\t\t\tint an_intr;\n\n\t\t\tan_intr = xpcs_read(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_INTR_STS);\n\t\t\tif (an_intr & DW_VR_MII_AN_STS_C37_ANCMPLT_INTR) {\n\t\t\t\tan_intr &= ~DW_VR_MII_AN_STS_C37_ANCMPLT_INTR;\n\t\t\t\txpcs_write(xpcs, MDIO_MMD_VEND2, DW_VR_MII_AN_INTR_STS, an_intr);\n\t\t\t}\n\t\t}\n\n\t\tphylink_mii_c22_pcs_decode_state(state, bmsr, lpa);\n\t}\n\n\treturn 0;\n}\n\nstatic void xpcs_get_state(struct phylink_pcs *pcs,\n\t\t\t   struct phylink_link_state *state)\n{\n\tstruct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);\n\tconst struct xpcs_compat *compat;\n\tint ret;\n\n\tcompat = xpcs_find_compat(xpcs->id, state->interface);\n\tif (!compat)\n\t\treturn;\n\n\tswitch (compat->an_mode) {\n\tcase DW_10GBASER:\n\t\tphylink_mii_c45_pcs_get_state(xpcs->mdiodev, state);\n\t\tbreak;\n\tcase DW_AN_C73:\n\t\tret = xpcs_get_state_c73(xpcs, state, compat);\n\t\tif (ret) {\n\t\t\tpr_err(\"xpcs_get_state_c73 returned %pe\\n\",\n\t\t\t       ERR_PTR(ret));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DW_AN_C37_SGMII:\n\t\tret = xpcs_get_state_c37_sgmii(xpcs, state);\n\t\tif (ret) {\n\t\t\tpr_err(\"xpcs_get_state_c37_sgmii returned %pe\\n\",\n\t\t\t       ERR_PTR(ret));\n\t\t}\n\t\tbreak;\n\tcase DW_AN_C37_1000BASEX:\n\t\tret = xpcs_get_state_c37_1000basex(xpcs, state);\n\t\tif (ret) {\n\t\t\tpr_err(\"xpcs_get_state_c37_1000basex returned %pe\\n\",\n\t\t\t       ERR_PTR(ret));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic void xpcs_link_up_sgmii(struct dw_xpcs *xpcs, unsigned int neg_mode,\n\t\t\t       int speed, int duplex)\n{\n\tint val, ret;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\treturn;\n\n\tval = mii_bmcr_encode_fixed(speed, duplex);\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, val);\n\tif (ret)\n\t\tpr_err(\"%s: xpcs_write returned %pe\\n\", __func__, ERR_PTR(ret));\n}\n\nstatic void xpcs_link_up_1000basex(struct dw_xpcs *xpcs, unsigned int neg_mode,\n\t\t\t\t   int speed, int duplex)\n{\n\tint val, ret;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\treturn;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tval = BMCR_SPEED1000;\n\t\tbreak;\n\tcase SPEED_100:\n\tcase SPEED_10:\n\tdefault:\n\t\tpr_err(\"%s: speed = %d\\n\", __func__, speed);\n\t\treturn;\n\t}\n\n\tif (duplex == DUPLEX_FULL)\n\t\tval |= BMCR_FULLDPLX;\n\telse\n\t\tpr_err(\"%s: half duplex not supported\\n\", __func__);\n\n\tret = xpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, val);\n\tif (ret)\n\t\tpr_err(\"%s: xpcs_write returned %pe\\n\", __func__, ERR_PTR(ret));\n}\n\nvoid xpcs_link_up(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t  phy_interface_t interface, int speed, int duplex)\n{\n\tstruct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);\n\n\tif (interface == PHY_INTERFACE_MODE_USXGMII)\n\t\treturn xpcs_config_usxgmii(xpcs, speed);\n\tif (interface == PHY_INTERFACE_MODE_SGMII)\n\t\treturn xpcs_link_up_sgmii(xpcs, neg_mode, speed, duplex);\n\tif (interface == PHY_INTERFACE_MODE_1000BASEX)\n\t\treturn xpcs_link_up_1000basex(xpcs, neg_mode, speed, duplex);\n}\nEXPORT_SYMBOL_GPL(xpcs_link_up);\n\nstatic void xpcs_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct dw_xpcs *xpcs = phylink_pcs_to_xpcs(pcs);\n\tint ret;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1);\n\tif (ret >= 0) {\n\t\tret |= BMCR_ANRESTART;\n\t\txpcs_write(xpcs, MDIO_MMD_VEND2, MDIO_CTRL1, ret);\n\t}\n}\n\nstatic u32 xpcs_get_id(struct dw_xpcs *xpcs)\n{\n\tint ret;\n\tu32 id;\n\n\t \n\tret = xpcs_read(xpcs, MDIO_MMD_PCS, MII_PHYSID1);\n\tif (ret < 0)\n\t\treturn 0xffffffff;\n\n\tid = ret << 16;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_PCS, MII_PHYSID2);\n\tif (ret < 0)\n\t\treturn 0xffffffff;\n\n\t \n\tif ((id | ret) && (id | ret) != 0xffffffff)\n\t\treturn id | ret;\n\n\t \n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_PHYSID1);\n\tif (ret < 0)\n\t\treturn 0xffffffff;\n\n\tid = ret << 16;\n\n\tret = xpcs_read(xpcs, MDIO_MMD_VEND2, MII_PHYSID2);\n\tif (ret < 0)\n\t\treturn 0xffffffff;\n\n\t \n\tif (id | ret)\n\t\treturn id | ret;\n\n\treturn 0xffffffff;\n}\n\nstatic const struct xpcs_compat synopsys_xpcs_compat[DW_XPCS_INTERFACE_MAX] = {\n\t[DW_XPCS_USXGMII] = {\n\t\t.supported = xpcs_usxgmii_features,\n\t\t.interface = xpcs_usxgmii_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_usxgmii_interfaces),\n\t\t.an_mode = DW_AN_C73,\n\t},\n\t[DW_XPCS_10GKR] = {\n\t\t.supported = xpcs_10gkr_features,\n\t\t.interface = xpcs_10gkr_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_10gkr_interfaces),\n\t\t.an_mode = DW_AN_C73,\n\t},\n\t[DW_XPCS_XLGMII] = {\n\t\t.supported = xpcs_xlgmii_features,\n\t\t.interface = xpcs_xlgmii_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_xlgmii_interfaces),\n\t\t.an_mode = DW_AN_C73,\n\t},\n\t[DW_XPCS_10GBASER] = {\n\t\t.supported = xpcs_10gbaser_features,\n\t\t.interface = xpcs_10gbaser_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_10gbaser_interfaces),\n\t\t.an_mode = DW_10GBASER,\n\t},\n\t[DW_XPCS_SGMII] = {\n\t\t.supported = xpcs_sgmii_features,\n\t\t.interface = xpcs_sgmii_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_sgmii_interfaces),\n\t\t.an_mode = DW_AN_C37_SGMII,\n\t},\n\t[DW_XPCS_1000BASEX] = {\n\t\t.supported = xpcs_1000basex_features,\n\t\t.interface = xpcs_1000basex_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_1000basex_interfaces),\n\t\t.an_mode = DW_AN_C37_1000BASEX,\n\t},\n\t[DW_XPCS_2500BASEX] = {\n\t\t.supported = xpcs_2500basex_features,\n\t\t.interface = xpcs_2500basex_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_2500basex_interfaces),\n\t\t.an_mode = DW_2500BASEX,\n\t},\n};\n\nstatic const struct xpcs_compat nxp_sja1105_xpcs_compat[DW_XPCS_INTERFACE_MAX] = {\n\t[DW_XPCS_SGMII] = {\n\t\t.supported = xpcs_sgmii_features,\n\t\t.interface = xpcs_sgmii_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_sgmii_interfaces),\n\t\t.an_mode = DW_AN_C37_SGMII,\n\t\t.pma_config = nxp_sja1105_sgmii_pma_config,\n\t},\n};\n\nstatic const struct xpcs_compat nxp_sja1110_xpcs_compat[DW_XPCS_INTERFACE_MAX] = {\n\t[DW_XPCS_SGMII] = {\n\t\t.supported = xpcs_sgmii_features,\n\t\t.interface = xpcs_sgmii_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_sgmii_interfaces),\n\t\t.an_mode = DW_AN_C37_SGMII,\n\t\t.pma_config = nxp_sja1110_sgmii_pma_config,\n\t},\n\t[DW_XPCS_2500BASEX] = {\n\t\t.supported = xpcs_2500basex_features,\n\t\t.interface = xpcs_2500basex_interfaces,\n\t\t.num_interfaces = ARRAY_SIZE(xpcs_2500basex_interfaces),\n\t\t.an_mode = DW_2500BASEX,\n\t\t.pma_config = nxp_sja1110_2500basex_pma_config,\n\t},\n};\n\nstatic const struct xpcs_id xpcs_id_list[] = {\n\t{\n\t\t.id = SYNOPSYS_XPCS_ID,\n\t\t.mask = SYNOPSYS_XPCS_MASK,\n\t\t.compat = synopsys_xpcs_compat,\n\t}, {\n\t\t.id = NXP_SJA1105_XPCS_ID,\n\t\t.mask = SYNOPSYS_XPCS_MASK,\n\t\t.compat = nxp_sja1105_xpcs_compat,\n\t}, {\n\t\t.id = NXP_SJA1110_XPCS_ID,\n\t\t.mask = SYNOPSYS_XPCS_MASK,\n\t\t.compat = nxp_sja1110_xpcs_compat,\n\t},\n};\n\nstatic const struct phylink_pcs_ops xpcs_phylink_ops = {\n\t.pcs_validate = xpcs_validate,\n\t.pcs_config = xpcs_config,\n\t.pcs_get_state = xpcs_get_state,\n\t.pcs_an_restart = xpcs_an_restart,\n\t.pcs_link_up = xpcs_link_up,\n};\n\nstatic struct dw_xpcs *xpcs_create(struct mdio_device *mdiodev,\n\t\t\t\t   phy_interface_t interface)\n{\n\tstruct dw_xpcs *xpcs;\n\tu32 xpcs_id;\n\tint i, ret;\n\n\txpcs = kzalloc(sizeof(*xpcs), GFP_KERNEL);\n\tif (!xpcs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmdio_device_get(mdiodev);\n\txpcs->mdiodev = mdiodev;\n\n\txpcs_id = xpcs_get_id(xpcs);\n\n\tfor (i = 0; i < ARRAY_SIZE(xpcs_id_list); i++) {\n\t\tconst struct xpcs_id *entry = &xpcs_id_list[i];\n\t\tconst struct xpcs_compat *compat;\n\n\t\tif ((xpcs_id & entry->mask) != entry->id)\n\t\t\tcontinue;\n\n\t\txpcs->id = entry;\n\n\t\tcompat = xpcs_find_compat(entry, interface);\n\t\tif (!compat) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = xpcs_dev_flag(xpcs);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\txpcs->pcs.ops = &xpcs_phylink_ops;\n\t\txpcs->pcs.neg_mode = true;\n\n\t\tif (xpcs->dev_flag != DW_DEV_TXGBE) {\n\t\t\txpcs->pcs.poll = true;\n\n\t\t\tret = xpcs_soft_reset(xpcs, compat);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\treturn xpcs;\n\t}\n\n\tret = -ENODEV;\n\nout:\n\tmdio_device_put(mdiodev);\n\tkfree(xpcs);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid xpcs_destroy(struct dw_xpcs *xpcs)\n{\n\tif (xpcs)\n\t\tmdio_device_put(xpcs->mdiodev);\n\tkfree(xpcs);\n}\nEXPORT_SYMBOL_GPL(xpcs_destroy);\n\nstruct dw_xpcs *xpcs_create_mdiodev(struct mii_bus *bus, int addr,\n\t\t\t\t    phy_interface_t interface)\n{\n\tstruct mdio_device *mdiodev;\n\tstruct dw_xpcs *xpcs;\n\n\tmdiodev = mdio_device_create(bus, addr);\n\tif (IS_ERR(mdiodev))\n\t\treturn ERR_CAST(mdiodev);\n\n\txpcs = xpcs_create(mdiodev, interface);\n\n\t \n\tmdio_device_put(mdiodev);\n\n\treturn xpcs;\n}\nEXPORT_SYMBOL_GPL(xpcs_create_mdiodev);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}