{
  "module_name": "slicoss.c",
  "hash_id": "159c821478e7ef0980e4e303aed05d8869a2bde3738d3b7ef11bff993a54e93f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/alacritech/slicoss.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/crc32.h>\n#include <linux/dma-mapping.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/list.h>\n#include <linux/u64_stats_sync.h>\n\n#include \"slic.h\"\n\n#define DRV_NAME\t\t\t\"slicoss\"\n\nstatic const struct pci_device_id slic_id_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ALACRITECH,\n\t\t     PCI_DEVICE_ID_ALACRITECH_MOJAVE) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ALACRITECH,\n\t\t     PCI_DEVICE_ID_ALACRITECH_OASIS) },\n\t{ 0 }\n};\n\nstatic const char slic_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\",\n\t\"rx_bytes\",\n\t\"rx_multicasts\",\n\t\"rx_errors\",\n\t\"rx_buff_miss\",\n\t\"rx_tp_csum\",\n\t\"rx_tp_oflow\",\n\t\"rx_tp_hlen\",\n\t\"rx_ip_csum\",\n\t\"rx_ip_len\",\n\t\"rx_ip_hdr_len\",\n\t\"rx_early\",\n\t\"rx_buff_oflow\",\n\t\"rx_lcode\",\n\t\"rx_drbl\",\n\t\"rx_crc\",\n\t\"rx_oflow_802\",\n\t\"rx_uflow_802\",\n\t\"tx_packets\",\n\t\"tx_bytes\",\n\t\"tx_carrier\",\n\t\"tx_dropped\",\n\t\"irq_errs\",\n};\n\nstatic inline int slic_next_queue_idx(unsigned int idx, unsigned int qlen)\n{\n\treturn (idx + 1) & (qlen - 1);\n}\n\nstatic inline int slic_get_free_queue_descs(unsigned int put_idx,\n\t\t\t\t\t    unsigned int done_idx,\n\t\t\t\t\t    unsigned int qlen)\n{\n\tif (put_idx >= done_idx)\n\t\treturn (qlen - (put_idx - done_idx) - 1);\n\treturn (done_idx - put_idx - 1);\n}\n\nstatic unsigned int slic_next_compl_idx(struct slic_device *sdev)\n{\n\tstruct slic_stat_queue *stq = &sdev->stq;\n\tunsigned int active = stq->active_array;\n\tstruct slic_stat_desc *descs;\n\tstruct slic_stat_desc *stat;\n\tunsigned int idx;\n\n\tdescs = stq->descs[active];\n\tstat = &descs[stq->done_idx];\n\n\tif (!stat->status)\n\t\treturn SLIC_INVALID_STAT_DESC_IDX;\n\n\tidx = (le32_to_cpu(stat->hnd) & 0xffff) - 1;\n\t \n\tstat->hnd = 0;\n\tstat->status = 0;\n\n\tstq->done_idx = slic_next_queue_idx(stq->done_idx, stq->len);\n\t \n\tif (!stq->done_idx) {\n\t\tdma_addr_t paddr = stq->paddr[active];\n\n\t\tslic_write(sdev, SLIC_REG_RBAR, lower_32_bits(paddr) |\n\t\t\t\t\t\tstq->len);\n\t\t \n\t\tslic_flush_write(sdev);\n\t\tactive++;\n\t\tactive &= (SLIC_NUM_STAT_DESC_ARRAYS - 1);\n\t\tstq->active_array = active;\n\t}\n\treturn idx;\n}\n\nstatic unsigned int slic_get_free_tx_descs(struct slic_tx_queue *txq)\n{\n\t \n\tsmp_mb();\n\treturn slic_get_free_queue_descs(txq->put_idx, txq->done_idx, txq->len);\n}\n\nstatic unsigned int slic_get_free_rx_descs(struct slic_rx_queue *rxq)\n{\n\treturn slic_get_free_queue_descs(rxq->put_idx, rxq->done_idx, rxq->len);\n}\n\nstatic void slic_clear_upr_list(struct slic_upr_list *upr_list)\n{\n\tstruct slic_upr *upr;\n\tstruct slic_upr *tmp;\n\n\tspin_lock_bh(&upr_list->lock);\n\tlist_for_each_entry_safe(upr, tmp, &upr_list->list, list) {\n\t\tlist_del(&upr->list);\n\t\tkfree(upr);\n\t}\n\tupr_list->pending = false;\n\tspin_unlock_bh(&upr_list->lock);\n}\n\nstatic void slic_start_upr(struct slic_device *sdev, struct slic_upr *upr)\n{\n\tu32 reg;\n\n\treg = (upr->type == SLIC_UPR_CONFIG) ? SLIC_REG_RCONFIG :\n\t\t\t\t\t       SLIC_REG_LSTAT;\n\tslic_write(sdev, reg, lower_32_bits(upr->paddr));\n\tslic_flush_write(sdev);\n}\n\nstatic void slic_queue_upr(struct slic_device *sdev, struct slic_upr *upr)\n{\n\tstruct slic_upr_list *upr_list = &sdev->upr_list;\n\tbool pending;\n\n\tspin_lock_bh(&upr_list->lock);\n\tpending = upr_list->pending;\n\tINIT_LIST_HEAD(&upr->list);\n\tlist_add_tail(&upr->list, &upr_list->list);\n\tupr_list->pending = true;\n\tspin_unlock_bh(&upr_list->lock);\n\n\tif (!pending)\n\t\tslic_start_upr(sdev, upr);\n}\n\nstatic struct slic_upr *slic_dequeue_upr(struct slic_device *sdev)\n{\n\tstruct slic_upr_list *upr_list = &sdev->upr_list;\n\tstruct slic_upr *next_upr = NULL;\n\tstruct slic_upr *upr = NULL;\n\n\tspin_lock_bh(&upr_list->lock);\n\tif (!list_empty(&upr_list->list)) {\n\t\tupr = list_first_entry(&upr_list->list, struct slic_upr, list);\n\t\tlist_del(&upr->list);\n\n\t\tif (list_empty(&upr_list->list))\n\t\t\tupr_list->pending = false;\n\t\telse\n\t\t\tnext_upr = list_first_entry(&upr_list->list,\n\t\t\t\t\t\t    struct slic_upr, list);\n\t}\n\tspin_unlock_bh(&upr_list->lock);\n\t \n\tif (next_upr)\n\t\tslic_start_upr(sdev, next_upr);\n\n\treturn upr;\n}\n\nstatic int slic_new_upr(struct slic_device *sdev, unsigned int type,\n\t\t\tdma_addr_t paddr)\n{\n\tstruct slic_upr *upr;\n\n\tupr = kmalloc(sizeof(*upr), GFP_ATOMIC);\n\tif (!upr)\n\t\treturn -ENOMEM;\n\tupr->type = type;\n\tupr->paddr = paddr;\n\n\tslic_queue_upr(sdev, upr);\n\n\treturn 0;\n}\n\nstatic void slic_set_mcast_bit(u64 *mcmask, unsigned char const *addr)\n{\n\tu64 mask = *mcmask;\n\tu8 crc;\n\t \n\tcrc = ether_crc(ETH_ALEN, addr) >> 23;\n\t  \n\tcrc &= 0x3F;\n\tmask |= (u64)1 << crc;\n\t*mcmask = mask;\n}\n\n \nstatic void slic_configure_rcv(struct slic_device *sdev)\n{\n\tu32 val;\n\n\tval = SLIC_GRCR_RESET | SLIC_GRCR_ADDRAEN | SLIC_GRCR_RCVEN |\n\t      SLIC_GRCR_HASHSIZE << SLIC_GRCR_HASHSIZE_SHIFT | SLIC_GRCR_RCVBAD;\n\n\tif (sdev->duplex == DUPLEX_FULL)\n\t\tval |= SLIC_GRCR_CTLEN;\n\n\tif (sdev->promisc)\n\t\tval |= SLIC_GRCR_RCVALL;\n\n\tslic_write(sdev, SLIC_REG_WRCFG, val);\n}\n\n \nstatic void slic_configure_xmt(struct slic_device *sdev)\n{\n\tu32 val;\n\n\tval = SLIC_GXCR_RESET | SLIC_GXCR_XMTEN;\n\n\tif (sdev->duplex == DUPLEX_FULL)\n\t\tval |= SLIC_GXCR_PAUSEEN;\n\n\tslic_write(sdev, SLIC_REG_WXCFG, val);\n}\n\n \nstatic void slic_configure_mac(struct slic_device *sdev)\n{\n\tu32 val;\n\n\tif (sdev->speed == SPEED_1000) {\n\t\tval = SLIC_GMCR_GAPBB_1000 << SLIC_GMCR_GAPBB_SHIFT |\n\t\t      SLIC_GMCR_GAPR1_1000 << SLIC_GMCR_GAPR1_SHIFT |\n\t\t      SLIC_GMCR_GAPR2_1000 << SLIC_GMCR_GAPR2_SHIFT |\n\t\t      SLIC_GMCR_GBIT;  \n\t} else {\n\t\tval = SLIC_GMCR_GAPBB_100 << SLIC_GMCR_GAPBB_SHIFT |\n\t\t      SLIC_GMCR_GAPR1_100 << SLIC_GMCR_GAPR1_SHIFT |\n\t\t      SLIC_GMCR_GAPR2_100 << SLIC_GMCR_GAPR2_SHIFT;\n\t}\n\n\tif (sdev->duplex == DUPLEX_FULL)\n\t\tval |= SLIC_GMCR_FULLD;\n\n\tslic_write(sdev, SLIC_REG_WMCFG, val);\n}\n\nstatic void slic_configure_link_locked(struct slic_device *sdev, int speed,\n\t\t\t\t       unsigned int duplex)\n{\n\tstruct net_device *dev = sdev->netdev;\n\n\tif (sdev->speed == speed && sdev->duplex == duplex)\n\t\treturn;\n\n\tsdev->speed = speed;\n\tsdev->duplex = duplex;\n\n\tif (sdev->speed == SPEED_UNKNOWN) {\n\t\tif (netif_carrier_ok(dev))\n\t\t\tnetif_carrier_off(dev);\n\t} else {\n\t\t \n\t\tslic_configure_mac(sdev);\n\t\tslic_configure_xmt(sdev);\n\t\tslic_configure_rcv(sdev);\n\t\tslic_flush_write(sdev);\n\n\t\tif (!netif_carrier_ok(dev))\n\t\t\tnetif_carrier_on(dev);\n\t}\n}\n\nstatic void slic_configure_link(struct slic_device *sdev, int speed,\n\t\t\t\tunsigned int duplex)\n{\n\tspin_lock_bh(&sdev->link_lock);\n\tslic_configure_link_locked(sdev, speed, duplex);\n\tspin_unlock_bh(&sdev->link_lock);\n}\n\nstatic void slic_set_rx_mode(struct net_device *dev)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\tstruct netdev_hw_addr *hwaddr;\n\tbool set_promisc;\n\tu64 mcmask;\n\n\tif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\n\t\t \n\t\tmcmask = ~(u64)0;\n\t} else  {\n\t\tmcmask = 0;\n\n\t\tnetdev_for_each_mc_addr(hwaddr, dev) {\n\t\t\tslic_set_mcast_bit(&mcmask, hwaddr->addr);\n\t\t}\n\t}\n\n\tslic_write(sdev, SLIC_REG_MCASTLOW, lower_32_bits(mcmask));\n\tslic_write(sdev, SLIC_REG_MCASTHIGH, upper_32_bits(mcmask));\n\n\tset_promisc = !!(dev->flags & IFF_PROMISC);\n\n\tspin_lock_bh(&sdev->link_lock);\n\tif (sdev->promisc != set_promisc) {\n\t\tsdev->promisc = set_promisc;\n\t\tslic_configure_rcv(sdev);\n\t}\n\tspin_unlock_bh(&sdev->link_lock);\n}\n\nstatic void slic_xmit_complete(struct slic_device *sdev)\n{\n\tstruct slic_tx_queue *txq = &sdev->txq;\n\tstruct net_device *dev = sdev->netdev;\n\tstruct slic_tx_buffer *buff;\n\tunsigned int frames = 0;\n\tunsigned int bytes = 0;\n\tunsigned int idx;\n\n\t \n\tdo {\n\t\tidx = slic_next_compl_idx(sdev);\n\t\tif (idx == SLIC_INVALID_STAT_DESC_IDX)\n\t\t\tbreak;\n\n\t\ttxq->done_idx = idx;\n\t\tbuff = &txq->txbuffs[idx];\n\n\t\tif (unlikely(!buff->skb)) {\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"no skb found for desc idx %i\\n\", idx);\n\t\t\tcontinue;\n\t\t}\n\t\tdma_unmap_single(&sdev->pdev->dev,\n\t\t\t\t dma_unmap_addr(buff, map_addr),\n\t\t\t\t dma_unmap_len(buff, map_len), DMA_TO_DEVICE);\n\n\t\tbytes += buff->skb->len;\n\t\tframes++;\n\n\t\tdev_kfree_skb_any(buff->skb);\n\t\tbuff->skb = NULL;\n\t} while (frames < SLIC_MAX_TX_COMPLETIONS);\n\t \n\tsmp_wmb();\n\n\tu64_stats_update_begin(&sdev->stats.syncp);\n\tsdev->stats.tx_bytes += bytes;\n\tsdev->stats.tx_packets += frames;\n\tu64_stats_update_end(&sdev->stats.syncp);\n\n\tnetif_tx_lock(dev);\n\tif (netif_queue_stopped(dev) &&\n\t    (slic_get_free_tx_descs(txq) >= SLIC_MIN_TX_WAKEUP_DESCS))\n\t\tnetif_wake_queue(dev);\n\tnetif_tx_unlock(dev);\n}\n\nstatic void slic_refill_rx_queue(struct slic_device *sdev, gfp_t gfp)\n{\n\tconst unsigned int ALIGN_MASK = SLIC_RX_BUFF_ALIGN - 1;\n\tunsigned int maplen = SLIC_RX_BUFF_SIZE;\n\tstruct slic_rx_queue *rxq = &sdev->rxq;\n\tstruct net_device *dev = sdev->netdev;\n\tstruct slic_rx_buffer *buff;\n\tstruct slic_rx_desc *desc;\n\tunsigned int misalign;\n\tunsigned int offset;\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\n\twhile (slic_get_free_rx_descs(rxq) > SLIC_MAX_REQ_RX_DESCS) {\n\t\tskb = alloc_skb(maplen + ALIGN_MASK, gfp);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tpaddr = dma_map_single(&sdev->pdev->dev, skb->data, maplen,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&sdev->pdev->dev, paddr)) {\n\t\t\tnetdev_err(dev, \"mapping rx packet failed\\n\");\n\t\t\t \n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\toffset = 0;\n\t\tmisalign = paddr & ALIGN_MASK;\n\t\tif (misalign) {\n\t\t\toffset = SLIC_RX_BUFF_ALIGN - misalign;\n\t\t\tskb_reserve(skb, offset);\n\t\t}\n\t\t \n\t\tdesc = (struct slic_rx_desc *)skb->data;\n\t\t \n\t\tdma_sync_single_for_cpu(&sdev->pdev->dev, paddr,\n\t\t\t\t\toffset + sizeof(*desc),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tdesc->status = 0;\n\t\t \n\t\tdma_sync_single_for_device(&sdev->pdev->dev, paddr,\n\t\t\t\t\t   offset + sizeof(*desc),\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\tbuff = &rxq->rxbuffs[rxq->put_idx];\n\t\tbuff->skb = skb;\n\t\tdma_unmap_addr_set(buff, map_addr, paddr);\n\t\tdma_unmap_len_set(buff, map_len, maplen);\n\t\tbuff->addr_offset = offset;\n\t\t \n\t\twmb();\n\t\t \n\t\tslic_write(sdev, SLIC_REG_HBAR, lower_32_bits(paddr) + offset);\n\t\trxq->put_idx = slic_next_queue_idx(rxq->put_idx, rxq->len);\n\t}\n}\n\nstatic void slic_handle_frame_error(struct slic_device *sdev,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct slic_stats *stats = &sdev->stats;\n\n\tif (sdev->model == SLIC_MODEL_OASIS) {\n\t\tstruct slic_rx_info_oasis *info;\n\t\tu32 status_b;\n\t\tu32 status;\n\n\t\tinfo = (struct slic_rx_info_oasis *)skb->data;\n\t\tstatus = le32_to_cpu(info->frame_status);\n\t\tstatus_b = le32_to_cpu(info->frame_status_b);\n\t\t \n\t\tif (status_b & SLIC_VRHSTATB_TPCSUM)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_tpcsum);\n\t\tif (status & SLIC_VRHSTAT_TPOFLO)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_tpoflow);\n\t\tif (status_b & SLIC_VRHSTATB_TPHLEN)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_tphlen);\n\t\t \n\t\tif (status_b & SLIC_VRHSTATB_IPCSUM)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_ipcsum);\n\t\tif (status_b & SLIC_VRHSTATB_IPLERR)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_iplen);\n\t\tif (status_b & SLIC_VRHSTATB_IPHERR)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_iphlen);\n\t\t \n\t\tif (status_b & SLIC_VRHSTATB_RCVE)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_early);\n\t\tif (status_b & SLIC_VRHSTATB_BUFF)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_buffoflow);\n\t\tif (status_b & SLIC_VRHSTATB_CODE)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_lcode);\n\t\tif (status_b & SLIC_VRHSTATB_DRBL)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_drbl);\n\t\tif (status_b & SLIC_VRHSTATB_CRC)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_crc);\n\t\tif (status & SLIC_VRHSTAT_802OE)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_oflow802);\n\t\tif (status_b & SLIC_VRHSTATB_802UE)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_uflow802);\n\t\tif (status_b & SLIC_VRHSTATB_CARRE)\n\t\t\tSLIC_INC_STATS_COUNTER(stats, tx_carrier);\n\t} else {  \n\t\tstruct slic_rx_info_mojave *info;\n\t\tu32 status;\n\n\t\tinfo = (struct slic_rx_info_mojave *)skb->data;\n\t\tstatus = le32_to_cpu(info->frame_status);\n\t\t \n\t\tif (status & SLIC_VGBSTAT_XPERR) {\n\t\t\tu32 xerr = status >> SLIC_VGBSTAT_XERRSHFT;\n\n\t\t\tif (xerr == SLIC_VGBSTAT_XCSERR)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_tpcsum);\n\t\t\tif (xerr == SLIC_VGBSTAT_XUFLOW)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_tpoflow);\n\t\t\tif (xerr == SLIC_VGBSTAT_XHLEN)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_tphlen);\n\t\t}\n\t\t \n\t\tif (status & SLIC_VGBSTAT_NETERR) {\n\t\t\tu32 nerr = status >> SLIC_VGBSTAT_NERRSHFT &\n\t\t\t\t   SLIC_VGBSTAT_NERRMSK;\n\n\t\t\tif (nerr == SLIC_VGBSTAT_NCSERR)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_ipcsum);\n\t\t\tif (nerr == SLIC_VGBSTAT_NUFLOW)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_iplen);\n\t\t\tif (nerr == SLIC_VGBSTAT_NHLEN)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_iphlen);\n\t\t}\n\t\t \n\t\tif (status & SLIC_VGBSTAT_LNKERR) {\n\t\t\tu32 lerr = status & SLIC_VGBSTAT_LERRMSK;\n\n\t\t\tif (lerr == SLIC_VGBSTAT_LDEARLY)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_early);\n\t\t\tif (lerr == SLIC_VGBSTAT_LBOFLO)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_buffoflow);\n\t\t\tif (lerr == SLIC_VGBSTAT_LCODERR)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_lcode);\n\t\t\tif (lerr == SLIC_VGBSTAT_LDBLNBL)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_drbl);\n\t\t\tif (lerr == SLIC_VGBSTAT_LCRCERR)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_crc);\n\t\t\tif (lerr == SLIC_VGBSTAT_LOFLO)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_oflow802);\n\t\t\tif (lerr == SLIC_VGBSTAT_LUFLO)\n\t\t\t\tSLIC_INC_STATS_COUNTER(stats, rx_uflow802);\n\t\t}\n\t}\n\tSLIC_INC_STATS_COUNTER(stats, rx_errors);\n}\n\nstatic void slic_handle_receive(struct slic_device *sdev, unsigned int todo,\n\t\t\t\tunsigned int *done)\n{\n\tstruct slic_rx_queue *rxq = &sdev->rxq;\n\tstruct net_device *dev = sdev->netdev;\n\tstruct slic_rx_buffer *buff;\n\tstruct slic_rx_desc *desc;\n\tunsigned int frames = 0;\n\tunsigned int bytes = 0;\n\tstruct sk_buff *skb;\n\tu32 status;\n\tu32 len;\n\n\twhile (todo && (rxq->done_idx != rxq->put_idx)) {\n\t\tbuff = &rxq->rxbuffs[rxq->done_idx];\n\n\t\tskb = buff->skb;\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tdesc = (struct slic_rx_desc *)skb->data;\n\n\t\tdma_sync_single_for_cpu(&sdev->pdev->dev,\n\t\t\t\t\tdma_unmap_addr(buff, map_addr),\n\t\t\t\t\tbuff->addr_offset + sizeof(*desc),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tstatus = le32_to_cpu(desc->status);\n\t\tif (!(status & SLIC_IRHDDR_SVALID)) {\n\t\t\tdma_sync_single_for_device(&sdev->pdev->dev,\n\t\t\t\t\t\t   dma_unmap_addr(buff,\n\t\t\t\t\t\t\t\t  map_addr),\n\t\t\t\t\t\t   buff->addr_offset +\n\t\t\t\t\t\t   sizeof(*desc),\n\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuff->skb = NULL;\n\n\t\tdma_unmap_single(&sdev->pdev->dev,\n\t\t\t\t dma_unmap_addr(buff, map_addr),\n\t\t\t\t dma_unmap_len(buff, map_len),\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t \n\t\tskb_reserve(skb, SLIC_RX_BUFF_HDR_SIZE);\n\n\t\tif (unlikely(status & SLIC_IRHDDR_ERR)) {\n\t\t\tslic_handle_frame_error(sdev, skb);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tstruct ethhdr *eh = (struct ethhdr *)skb->data;\n\n\t\t\tif (is_multicast_ether_addr(eh->h_dest))\n\t\t\t\tSLIC_INC_STATS_COUNTER(&sdev->stats, rx_mcasts);\n\n\t\t\tlen = le32_to_cpu(desc->length) & SLIC_IRHDDR_FLEN_MSK;\n\t\t\tskb_put(skb, len);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t\tnapi_gro_receive(&sdev->napi, skb);\n\n\t\t\tbytes += len;\n\t\t\tframes++;\n\t\t}\n\t\trxq->done_idx = slic_next_queue_idx(rxq->done_idx, rxq->len);\n\t\ttodo--;\n\t}\n\n\tu64_stats_update_begin(&sdev->stats.syncp);\n\tsdev->stats.rx_bytes += bytes;\n\tsdev->stats.rx_packets += frames;\n\tu64_stats_update_end(&sdev->stats.syncp);\n\n\tslic_refill_rx_queue(sdev, GFP_ATOMIC);\n}\n\nstatic void slic_handle_link_irq(struct slic_device *sdev)\n{\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tstruct slic_shmem_data *sm_data = sm->shmem_data;\n\tunsigned int duplex;\n\tint speed;\n\tu32 link;\n\n\tlink = le32_to_cpu(sm_data->link);\n\n\tif (link & SLIC_GIG_LINKUP) {\n\t\tif (link & SLIC_GIG_SPEED_1000)\n\t\t\tspeed = SPEED_1000;\n\t\telse if (link & SLIC_GIG_SPEED_100)\n\t\t\tspeed = SPEED_100;\n\t\telse\n\t\t\tspeed = SPEED_10;\n\n\t\tduplex = (link & SLIC_GIG_FULLDUPLEX) ? DUPLEX_FULL :\n\t\t\t\t\t\t\tDUPLEX_HALF;\n\t} else {\n\t\tduplex = DUPLEX_UNKNOWN;\n\t\tspeed = SPEED_UNKNOWN;\n\t}\n\tslic_configure_link(sdev, speed, duplex);\n}\n\nstatic void slic_handle_upr_irq(struct slic_device *sdev, u32 irqs)\n{\n\tstruct slic_upr *upr;\n\n\t \n\tupr = slic_dequeue_upr(sdev);\n\tif (!upr) {\n\t\tnetdev_warn(sdev->netdev, \"no upr found on list\\n\");\n\t\treturn;\n\t}\n\n\tif (upr->type == SLIC_UPR_LSTAT) {\n\t\tif (unlikely(irqs & SLIC_ISR_UPCERR_MASK)) {\n\t\t\t \n\t\t\tslic_queue_upr(sdev, upr);\n\t\t\treturn;\n\t\t}\n\t\tslic_handle_link_irq(sdev);\n\t}\n\tkfree(upr);\n}\n\nstatic int slic_handle_link_change(struct slic_device *sdev)\n{\n\treturn slic_new_upr(sdev, SLIC_UPR_LSTAT, sdev->shmem.link_paddr);\n}\n\nstatic void slic_handle_err_irq(struct slic_device *sdev, u32 isr)\n{\n\tstruct slic_stats *stats = &sdev->stats;\n\n\tif (isr & SLIC_ISR_RMISS)\n\t\tSLIC_INC_STATS_COUNTER(stats, rx_buff_miss);\n\tif (isr & SLIC_ISR_XDROP)\n\t\tSLIC_INC_STATS_COUNTER(stats, tx_dropped);\n\tif (!(isr & (SLIC_ISR_RMISS | SLIC_ISR_XDROP)))\n\t\tSLIC_INC_STATS_COUNTER(stats, irq_errs);\n}\n\nstatic void slic_handle_irq(struct slic_device *sdev, u32 isr,\n\t\t\t    unsigned int todo, unsigned int *done)\n{\n\tif (isr & SLIC_ISR_ERR)\n\t\tslic_handle_err_irq(sdev, isr);\n\n\tif (isr & SLIC_ISR_LEVENT)\n\t\tslic_handle_link_change(sdev);\n\n\tif (isr & SLIC_ISR_UPC_MASK)\n\t\tslic_handle_upr_irq(sdev, isr);\n\n\tif (isr & SLIC_ISR_RCV)\n\t\tslic_handle_receive(sdev, todo, done);\n\n\tif (isr & SLIC_ISR_CMD)\n\t\tslic_xmit_complete(sdev);\n}\n\nstatic int slic_poll(struct napi_struct *napi, int todo)\n{\n\tstruct slic_device *sdev = container_of(napi, struct slic_device, napi);\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tstruct slic_shmem_data *sm_data = sm->shmem_data;\n\tu32 isr = le32_to_cpu(sm_data->isr);\n\tint done = 0;\n\n\tslic_handle_irq(sdev, isr, todo, &done);\n\n\tif (done < todo) {\n\t\tnapi_complete_done(napi, done);\n\t\t \n\t\tsm_data->isr = 0;\n\t\t \n\t\twmb();\n\t\tslic_write(sdev, SLIC_REG_ISR, 0);\n\t\tslic_flush_write(sdev);\n\t}\n\n\treturn done;\n}\n\nstatic irqreturn_t slic_irq(int irq, void *dev_id)\n{\n\tstruct slic_device *sdev = dev_id;\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tstruct slic_shmem_data *sm_data = sm->shmem_data;\n\n\tslic_write(sdev, SLIC_REG_ICR, SLIC_ICR_INT_MASK);\n\tslic_flush_write(sdev);\n\t \n\twmb();\n\n\tif (!sm_data->isr) {\n\t\tdma_rmb();\n\t\t \n\t\tslic_write(sdev, SLIC_REG_ISR, 0);\n\t\tslic_flush_write(sdev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tnapi_schedule_irqoff(&sdev->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void slic_card_reset(struct slic_device *sdev)\n{\n\tu16 cmd;\n\n\tslic_write(sdev, SLIC_REG_RESET, SLIC_RESET_MAGIC);\n\t \n\tpci_read_config_word(sdev->pdev, PCI_COMMAND, &cmd);\n\tmdelay(1);\n}\n\nstatic int slic_init_stat_queue(struct slic_device *sdev)\n{\n\tconst unsigned int DESC_ALIGN_MASK = SLIC_STATS_DESC_ALIGN - 1;\n\tstruct slic_stat_queue *stq = &sdev->stq;\n\tstruct slic_stat_desc *descs;\n\tunsigned int misalign;\n\tunsigned int offset;\n\tdma_addr_t paddr;\n\tsize_t size;\n\tint err;\n\tint i;\n\n\tstq->len = SLIC_NUM_STAT_DESCS;\n\tstq->active_array = 0;\n\tstq->done_idx = 0;\n\n\tsize = stq->len * sizeof(*descs) + DESC_ALIGN_MASK;\n\n\tfor (i = 0; i < SLIC_NUM_STAT_DESC_ARRAYS; i++) {\n\t\tdescs = dma_alloc_coherent(&sdev->pdev->dev, size, &paddr,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!descs) {\n\t\t\tnetdev_err(sdev->netdev,\n\t\t\t\t   \"failed to allocate status descriptors\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_descs;\n\t\t}\n\t\t \n\t\toffset = 0;\n\t\tmisalign = paddr & DESC_ALIGN_MASK;\n\t\tif (misalign) {\n\t\t\toffset = SLIC_STATS_DESC_ALIGN - misalign;\n\t\t\tdescs += offset;\n\t\t\tpaddr += offset;\n\t\t}\n\n\t\tslic_write(sdev, SLIC_REG_RBAR, lower_32_bits(paddr) |\n\t\t\t\t\t\tstq->len);\n\t\tstq->descs[i] = descs;\n\t\tstq->paddr[i] = paddr;\n\t\tstq->addr_offset[i] = offset;\n\t}\n\n\tstq->mem_size = size;\n\n\treturn 0;\n\nfree_descs:\n\twhile (i--) {\n\t\tdma_free_coherent(&sdev->pdev->dev, stq->mem_size,\n\t\t\t\t  stq->descs[i] - stq->addr_offset[i],\n\t\t\t\t  stq->paddr[i] - stq->addr_offset[i]);\n\t}\n\n\treturn err;\n}\n\nstatic void slic_free_stat_queue(struct slic_device *sdev)\n{\n\tstruct slic_stat_queue *stq = &sdev->stq;\n\tint i;\n\n\tfor (i = 0; i < SLIC_NUM_STAT_DESC_ARRAYS; i++) {\n\t\tdma_free_coherent(&sdev->pdev->dev, stq->mem_size,\n\t\t\t\t  stq->descs[i] - stq->addr_offset[i],\n\t\t\t\t  stq->paddr[i] - stq->addr_offset[i]);\n\t}\n}\n\nstatic int slic_init_tx_queue(struct slic_device *sdev)\n{\n\tstruct slic_tx_queue *txq = &sdev->txq;\n\tstruct slic_tx_buffer *buff;\n\tstruct slic_tx_desc *desc;\n\tunsigned int i;\n\tint err;\n\n\ttxq->len = SLIC_NUM_TX_DESCS;\n\ttxq->put_idx = 0;\n\ttxq->done_idx = 0;\n\n\ttxq->txbuffs = kcalloc(txq->len, sizeof(*buff), GFP_KERNEL);\n\tif (!txq->txbuffs)\n\t\treturn -ENOMEM;\n\n\ttxq->dma_pool = dma_pool_create(\"slic_pool\", &sdev->pdev->dev,\n\t\t\t\t\tsizeof(*desc), SLIC_TX_DESC_ALIGN,\n\t\t\t\t\t4096);\n\tif (!txq->dma_pool) {\n\t\terr = -ENOMEM;\n\t\tnetdev_err(sdev->netdev, \"failed to create dma pool\\n\");\n\t\tgoto free_buffs;\n\t}\n\n\tfor (i = 0; i < txq->len; i++) {\n\t\tbuff = &txq->txbuffs[i];\n\t\tdesc = dma_pool_zalloc(txq->dma_pool, GFP_KERNEL,\n\t\t\t\t       &buff->desc_paddr);\n\t\tif (!desc) {\n\t\t\tnetdev_err(sdev->netdev,\n\t\t\t\t   \"failed to alloc pool chunk (%i)\\n\", i);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_descs;\n\t\t}\n\n\t\tdesc->hnd = cpu_to_le32((u32)(i + 1));\n\t\tdesc->cmd = SLIC_CMD_XMT_REQ;\n\t\tdesc->flags = 0;\n\t\tdesc->type = cpu_to_le32(SLIC_CMD_TYPE_DUMB);\n\t\tbuff->desc = desc;\n\t}\n\n\treturn 0;\n\nfree_descs:\n\twhile (i--) {\n\t\tbuff = &txq->txbuffs[i];\n\t\tdma_pool_free(txq->dma_pool, buff->desc, buff->desc_paddr);\n\t}\n\tdma_pool_destroy(txq->dma_pool);\n\nfree_buffs:\n\tkfree(txq->txbuffs);\n\n\treturn err;\n}\n\nstatic void slic_free_tx_queue(struct slic_device *sdev)\n{\n\tstruct slic_tx_queue *txq = &sdev->txq;\n\tstruct slic_tx_buffer *buff;\n\tunsigned int i;\n\n\tfor (i = 0; i < txq->len; i++) {\n\t\tbuff = &txq->txbuffs[i];\n\t\tdma_pool_free(txq->dma_pool, buff->desc, buff->desc_paddr);\n\t\tif (!buff->skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(&sdev->pdev->dev,\n\t\t\t\t dma_unmap_addr(buff, map_addr),\n\t\t\t\t dma_unmap_len(buff, map_len), DMA_TO_DEVICE);\n\t\tconsume_skb(buff->skb);\n\t}\n\tdma_pool_destroy(txq->dma_pool);\n\n\tkfree(txq->txbuffs);\n}\n\nstatic int slic_init_rx_queue(struct slic_device *sdev)\n{\n\tstruct slic_rx_queue *rxq = &sdev->rxq;\n\tstruct slic_rx_buffer *buff;\n\n\trxq->len = SLIC_NUM_RX_LES;\n\trxq->done_idx = 0;\n\trxq->put_idx = 0;\n\n\tbuff = kcalloc(rxq->len, sizeof(*buff), GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\trxq->rxbuffs = buff;\n\tslic_refill_rx_queue(sdev, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic void slic_free_rx_queue(struct slic_device *sdev)\n{\n\tstruct slic_rx_queue *rxq = &sdev->rxq;\n\tstruct slic_rx_buffer *buff;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < rxq->len; i++) {\n\t\tbuff = &rxq->rxbuffs[i];\n\n\t\tif (!buff->skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(&sdev->pdev->dev,\n\t\t\t\t dma_unmap_addr(buff, map_addr),\n\t\t\t\t dma_unmap_len(buff, map_len),\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tconsume_skb(buff->skb);\n\t}\n\tkfree(rxq->rxbuffs);\n}\n\nstatic void slic_set_link_autoneg(struct slic_device *sdev)\n{\n\tunsigned int subid = sdev->pdev->subsystem_device;\n\tu32 val;\n\n\tif (sdev->is_fiber) {\n\t\t \n\t\t \n\t\tval = MII_ADVERTISE << 16 | ADVERTISE_1000XFULL |\n\t\t      ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM;\n\t\t \n\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\t\t \n\t\tval = MII_BMCR << 16 | BMCR_RESET | BMCR_ANENABLE |\n\t\t      BMCR_ANRESTART;\n\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\t} else {\t \n\t\t \n\t\t \n\t\tval = MII_ADVERTISE << 16 | ADVERTISE_100FULL |\n\t\t      ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF;\n\t\t \n\t\tval |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t\t \n\t\tval |= ADVERTISE_CSMA;\n\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\n\t\t \n\t\tval = MII_CTRL1000 << 16 | ADVERTISE_1000FULL;\n\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\n\t\tif (subid != PCI_SUBDEVICE_ID_ALACRITECH_CICADA) {\n\t\t\t  \n\t\t\tval = SLIC_MIICR_REG_16 | SLIC_MRV_REG16_XOVERON;\n\t\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\n\t\t\t \n\t\t\tval = MII_BMCR << 16 | BMCR_RESET | BMCR_ANENABLE |\n\t\t\t      BMCR_ANRESTART;\n\t\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\t\t} else {\n\t\t\t \n\t\t\tval = MII_BMCR << 16 | BMCR_ANENABLE | BMCR_ANRESTART;\n\t\t\tslic_write(sdev, SLIC_REG_WPHY, val);\n\t\t}\n\t}\n}\n\nstatic void slic_set_mac_address(struct slic_device *sdev)\n{\n\tconst u8 *addr = sdev->netdev->dev_addr;\n\tu32 val;\n\n\tval = addr[5] | addr[4] << 8 | addr[3] << 16 | addr[2] << 24;\n\n\tslic_write(sdev, SLIC_REG_WRADDRAL, val);\n\tslic_write(sdev, SLIC_REG_WRADDRBL, val);\n\n\tval = addr[0] << 8 | addr[1];\n\n\tslic_write(sdev, SLIC_REG_WRADDRAH, val);\n\tslic_write(sdev, SLIC_REG_WRADDRBH, val);\n\tslic_flush_write(sdev);\n}\n\nstatic u32 slic_read_dword_from_firmware(const struct firmware *fw, int *offset)\n{\n\tint idx = *offset;\n\t__le32 val;\n\n\tmemcpy(&val, fw->data + *offset, sizeof(val));\n\tidx += 4;\n\t*offset = idx;\n\n\treturn le32_to_cpu(val);\n}\n\nMODULE_FIRMWARE(SLIC_RCV_FIRMWARE_MOJAVE);\nMODULE_FIRMWARE(SLIC_RCV_FIRMWARE_OASIS);\n\nstatic int slic_load_rcvseq_firmware(struct slic_device *sdev)\n{\n\tconst struct firmware *fw;\n\tconst char *file;\n\tu32 codelen;\n\tint idx = 0;\n\tu32 instr;\n\tu32 addr;\n\tint err;\n\n\tfile = (sdev->model == SLIC_MODEL_OASIS) ?  SLIC_RCV_FIRMWARE_OASIS :\n\t\t\t\t\t\t    SLIC_RCV_FIRMWARE_MOJAVE;\n\terr = request_firmware(&fw, file, &sdev->pdev->dev);\n\tif (err) {\n\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\"failed to load receive sequencer firmware %s\\n\", file);\n\t\treturn err;\n\t}\n\t \n\tif (fw->size < SLIC_FIRMWARE_MIN_SIZE) {\n\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\"invalid firmware size %zu (min %u expected)\\n\",\n\t\t\tfw->size, SLIC_FIRMWARE_MIN_SIZE);\n\t\terr = -EINVAL;\n\t\tgoto release;\n\t}\n\n\tcodelen = slic_read_dword_from_firmware(fw, &idx);\n\n\t \n\tif ((codelen + 4) > fw->size) {\n\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\"invalid rcv-sequencer firmware size %zu\\n\", fw->size);\n\t\terr = -EINVAL;\n\t\tgoto release;\n\t}\n\n\t \n\tslic_write(sdev, SLIC_REG_RCV_WCS, SLIC_RCVWCS_BEGIN);\n\tfor (addr = 0; addr < codelen; addr++) {\n\t\t__le32 val;\n\t\t \n\t\tslic_write(sdev, SLIC_REG_RCV_WCS, addr);\n\n\t\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\t\t \n\t\tslic_write(sdev, SLIC_REG_RCV_WCS, instr);\n\n\t\tval = (__le32)fw->data[idx];\n\t\tinstr = le32_to_cpu(val);\n\t\tidx++;\n\t\t \n\t\tslic_write(sdev, SLIC_REG_RCV_WCS, instr);\n\t}\n\t \n\tslic_write(sdev, SLIC_REG_RCV_WCS, SLIC_RCVWCS_FINISH);\n\tslic_flush_write(sdev);\nrelease:\n\trelease_firmware(fw);\n\n\treturn err;\n}\n\nMODULE_FIRMWARE(SLIC_FIRMWARE_MOJAVE);\nMODULE_FIRMWARE(SLIC_FIRMWARE_OASIS);\n\nstatic int slic_load_firmware(struct slic_device *sdev)\n{\n\tu32 sectstart[SLIC_FIRMWARE_MAX_SECTIONS];\n\tu32 sectsize[SLIC_FIRMWARE_MAX_SECTIONS];\n\tconst struct firmware *fw;\n\tunsigned int datalen;\n\tconst char *file;\n\tint code_start;\n\tunsigned int i;\n\tu32 numsects;\n\tint idx = 0;\n\tu32 sect;\n\tu32 instr;\n\tu32 addr;\n\tu32 base;\n\tint err;\n\n\tfile = (sdev->model == SLIC_MODEL_OASIS) ?  SLIC_FIRMWARE_OASIS :\n\t\t\t\t\t\t    SLIC_FIRMWARE_MOJAVE;\n\terr = request_firmware(&fw, file, &sdev->pdev->dev);\n\tif (err) {\n\t\tdev_err(&sdev->pdev->dev, \"failed to load firmware %s\\n\", file);\n\t\treturn err;\n\t}\n\t \n\tif (fw->size < SLIC_FIRMWARE_MIN_SIZE) {\n\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\"invalid firmware size %zu (min is %u)\\n\", fw->size,\n\t\t\tSLIC_FIRMWARE_MIN_SIZE);\n\t\terr = -EINVAL;\n\t\tgoto release;\n\t}\n\n\tnumsects = slic_read_dword_from_firmware(fw, &idx);\n\tif (numsects == 0 || numsects > SLIC_FIRMWARE_MAX_SECTIONS) {\n\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\"invalid number of sections in firmware: %u\", numsects);\n\t\terr = -EINVAL;\n\t\tgoto release;\n\t}\n\n\tdatalen = numsects * 8 + 4;\n\tfor (i = 0; i < numsects; i++) {\n\t\tsectsize[i] = slic_read_dword_from_firmware(fw, &idx);\n\t\tdatalen += sectsize[i];\n\t}\n\n\t \n\tif (datalen > fw->size) {\n\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\"invalid firmware size %zu (expected >= %u)\\n\",\n\t\t\tfw->size, datalen);\n\t\terr = -EINVAL;\n\t\tgoto release;\n\t}\n\t \n\tfor (i = 0; i < numsects; i++)\n\t\tsectstart[i] = slic_read_dword_from_firmware(fw, &idx);\n\n\tcode_start = idx;\n\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\n\tfor (sect = 0; sect < numsects; sect++) {\n\t\tunsigned int ssize = sectsize[sect] >> 3;\n\n\t\tbase = sectstart[sect];\n\n\t\tfor (addr = 0; addr < ssize; addr++) {\n\t\t\t \n\t\t\tslic_write(sdev, SLIC_REG_WCS, base + addr);\n\t\t\t \n\t\t\tslic_write(sdev, SLIC_REG_WCS, instr);\n\t\t\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\t\t\t \n\t\t\tslic_write(sdev, SLIC_REG_WCS, instr);\n\t\t\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\t\t}\n\t}\n\n\tidx = code_start;\n\n\tfor (sect = 0; sect < numsects; sect++) {\n\t\tunsigned int ssize = sectsize[sect] >> 3;\n\n\t\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\t\tbase = sectstart[sect];\n\t\tif (base < 0x8000)\n\t\t\tcontinue;\n\n\t\tfor (addr = 0; addr < ssize; addr++) {\n\t\t\t \n\t\t\tslic_write(sdev, SLIC_REG_WCS,\n\t\t\t\t   SLIC_WCS_COMPARE | (base + addr));\n\t\t\t \n\t\t\tslic_write(sdev, SLIC_REG_WCS, instr);\n\t\t\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\t\t\t \n\t\t\tslic_write(sdev, SLIC_REG_WCS, instr);\n\t\t\tinstr = slic_read_dword_from_firmware(fw, &idx);\n\t\t}\n\t}\n\tslic_flush_write(sdev);\n\tmdelay(10);\n\t \n\tslic_write(sdev, SLIC_REG_WCS, SLIC_WCS_START);\n\tslic_flush_write(sdev);\n\t \n\tmdelay(20);\nrelease:\n\trelease_firmware(fw);\n\n\treturn err;\n}\n\nstatic int slic_init_shmem(struct slic_device *sdev)\n{\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tstruct slic_shmem_data *sm_data;\n\tdma_addr_t paddr;\n\n\tsm_data = dma_alloc_coherent(&sdev->pdev->dev, sizeof(*sm_data),\n\t\t\t\t     &paddr, GFP_KERNEL);\n\tif (!sm_data) {\n\t\tdev_err(&sdev->pdev->dev, \"failed to allocate shared memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsm->shmem_data = sm_data;\n\tsm->isr_paddr = paddr;\n\tsm->link_paddr = paddr + offsetof(struct slic_shmem_data, link);\n\n\treturn 0;\n}\n\nstatic void slic_free_shmem(struct slic_device *sdev)\n{\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tstruct slic_shmem_data *sm_data = sm->shmem_data;\n\n\tdma_free_coherent(&sdev->pdev->dev, sizeof(*sm_data), sm_data,\n\t\t\t  sm->isr_paddr);\n}\n\nstatic int slic_init_iface(struct slic_device *sdev)\n{\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tint err;\n\n\tsdev->upr_list.pending = false;\n\n\terr = slic_init_shmem(sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev, \"failed to init shared memory\\n\");\n\t\treturn err;\n\t}\n\n\terr = slic_load_firmware(sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev, \"failed to load firmware\\n\");\n\t\tgoto free_sm;\n\t}\n\n\terr = slic_load_rcvseq_firmware(sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev,\n\t\t\t   \"failed to load firmware for receive sequencer\\n\");\n\t\tgoto free_sm;\n\t}\n\n\tslic_write(sdev, SLIC_REG_ICR, SLIC_ICR_INT_OFF);\n\tslic_flush_write(sdev);\n\tmdelay(1);\n\n\terr = slic_init_rx_queue(sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev, \"failed to init rx queue: %u\\n\", err);\n\t\tgoto free_sm;\n\t}\n\n\terr = slic_init_tx_queue(sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev, \"failed to init tx queue: %u\\n\", err);\n\t\tgoto free_rxq;\n\t}\n\n\terr = slic_init_stat_queue(sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev, \"failed to init status queue: %u\\n\",\n\t\t\t   err);\n\t\tgoto free_txq;\n\t}\n\n\tslic_write(sdev, SLIC_REG_ISP, lower_32_bits(sm->isr_paddr));\n\tnapi_enable(&sdev->napi);\n\t \n\tslic_write(sdev, SLIC_REG_INTAGG, 0);\n\tslic_write(sdev, SLIC_REG_ISR, 0);\n\tslic_flush_write(sdev);\n\n\tslic_set_mac_address(sdev);\n\n\tspin_lock_bh(&sdev->link_lock);\n\tsdev->duplex = DUPLEX_UNKNOWN;\n\tsdev->speed = SPEED_UNKNOWN;\n\tspin_unlock_bh(&sdev->link_lock);\n\n\tslic_set_link_autoneg(sdev);\n\n\terr = request_irq(sdev->pdev->irq, slic_irq, IRQF_SHARED, DRV_NAME,\n\t\t\t  sdev);\n\tif (err) {\n\t\tnetdev_err(sdev->netdev, \"failed to request irq: %u\\n\", err);\n\t\tgoto disable_napi;\n\t}\n\n\tslic_write(sdev, SLIC_REG_ICR, SLIC_ICR_INT_ON);\n\tslic_flush_write(sdev);\n\t \n\terr = slic_handle_link_change(sdev);\n\tif (err)\n\t\tnetdev_warn(sdev->netdev,\n\t\t\t    \"failed to set initial link state: %u\\n\", err);\n\treturn 0;\n\ndisable_napi:\n\tnapi_disable(&sdev->napi);\n\tslic_free_stat_queue(sdev);\nfree_txq:\n\tslic_free_tx_queue(sdev);\nfree_rxq:\n\tslic_free_rx_queue(sdev);\nfree_sm:\n\tslic_free_shmem(sdev);\n\tslic_card_reset(sdev);\n\n\treturn err;\n}\n\nstatic int slic_open(struct net_device *dev)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\tint err;\n\n\tnetif_carrier_off(dev);\n\n\terr = slic_init_iface(sdev);\n\tif (err) {\n\t\tnetdev_err(dev, \"failed to initialize interface: %i\\n\", err);\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int slic_close(struct net_device *dev)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\tu32 val;\n\n\tnetif_stop_queue(dev);\n\n\t \n\tnapi_disable(&sdev->napi);\n\tslic_write(sdev, SLIC_REG_ICR, SLIC_ICR_INT_OFF);\n\tslic_write(sdev, SLIC_REG_ISR, 0);\n\tslic_flush_write(sdev);\n\n\tfree_irq(sdev->pdev->irq, sdev);\n\t \n\tval = SLIC_GXCR_RESET | SLIC_GXCR_PAUSEEN;\n\tslic_write(sdev, SLIC_REG_WXCFG, val);\n\n\tval = SLIC_GRCR_RESET | SLIC_GRCR_CTLEN | SLIC_GRCR_ADDRAEN |\n\t      SLIC_GRCR_HASHSIZE << SLIC_GRCR_HASHSIZE_SHIFT;\n\tslic_write(sdev, SLIC_REG_WRCFG, val);\n\n\tval = MII_BMCR << 16 | BMCR_PDOWN;\n\tslic_write(sdev, SLIC_REG_WPHY, val);\n\tslic_flush_write(sdev);\n\n\tslic_clear_upr_list(&sdev->upr_list);\n\tslic_write(sdev, SLIC_REG_QUIESCE, 0);\n\n\tslic_free_stat_queue(sdev);\n\tslic_free_tx_queue(sdev);\n\tslic_free_rx_queue(sdev);\n\tslic_free_shmem(sdev);\n\n\tslic_card_reset(sdev);\n\tnetif_carrier_off(dev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t slic_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\tstruct slic_tx_queue *txq = &sdev->txq;\n\tstruct slic_tx_buffer *buff;\n\tstruct slic_tx_desc *desc;\n\tdma_addr_t paddr;\n\tu32 cbar_val;\n\tu32 maplen;\n\n\tif (unlikely(slic_get_free_tx_descs(txq) < SLIC_MAX_REQ_TX_DESCS)) {\n\t\tnetdev_err(dev, \"BUG! not enough tx LEs left: %u\\n\",\n\t\t\t   slic_get_free_tx_descs(txq));\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tmaplen = skb_headlen(skb);\n\tpaddr = dma_map_single(&sdev->pdev->dev, skb->data, maplen,\n\t\t\t       DMA_TO_DEVICE);\n\tif (dma_mapping_error(&sdev->pdev->dev, paddr)) {\n\t\tnetdev_err(dev, \"failed to map tx buffer\\n\");\n\t\tgoto drop_skb;\n\t}\n\n\tbuff = &txq->txbuffs[txq->put_idx];\n\tbuff->skb = skb;\n\tdma_unmap_addr_set(buff, map_addr, paddr);\n\tdma_unmap_len_set(buff, map_len, maplen);\n\n\tdesc = buff->desc;\n\tdesc->totlen = cpu_to_le32(maplen);\n\tdesc->paddrl = cpu_to_le32(lower_32_bits(paddr));\n\tdesc->paddrh = cpu_to_le32(upper_32_bits(paddr));\n\tdesc->len = cpu_to_le32(maplen);\n\n\ttxq->put_idx = slic_next_queue_idx(txq->put_idx, txq->len);\n\n\tcbar_val = lower_32_bits(buff->desc_paddr) | 1;\n\t \n\twmb();\n\n\tslic_write(sdev, SLIC_REG_CBAR, cbar_val);\n\n\tif (slic_get_free_tx_descs(txq) < SLIC_MAX_REQ_TX_DESCS)\n\t\tnetif_stop_queue(dev);\n\n\treturn NETDEV_TX_OK;\ndrop_skb:\n\tdev_kfree_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void slic_get_stats(struct net_device *dev,\n\t\t\t   struct rtnl_link_stats64 *lst)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\tstruct slic_stats *stats = &sdev->stats;\n\n\tSLIC_GET_STATS_COUNTER(lst->rx_packets, stats, rx_packets);\n\tSLIC_GET_STATS_COUNTER(lst->tx_packets, stats, tx_packets);\n\tSLIC_GET_STATS_COUNTER(lst->rx_bytes, stats, rx_bytes);\n\tSLIC_GET_STATS_COUNTER(lst->tx_bytes, stats, tx_bytes);\n\tSLIC_GET_STATS_COUNTER(lst->rx_errors, stats, rx_errors);\n\tSLIC_GET_STATS_COUNTER(lst->rx_dropped, stats, rx_buff_miss);\n\tSLIC_GET_STATS_COUNTER(lst->tx_dropped, stats, tx_dropped);\n\tSLIC_GET_STATS_COUNTER(lst->multicast, stats, rx_mcasts);\n\tSLIC_GET_STATS_COUNTER(lst->rx_over_errors, stats, rx_buffoflow);\n\tSLIC_GET_STATS_COUNTER(lst->rx_crc_errors, stats, rx_crc);\n\tSLIC_GET_STATS_COUNTER(lst->rx_fifo_errors, stats, rx_oflow802);\n\tSLIC_GET_STATS_COUNTER(lst->tx_carrier_errors, stats, tx_carrier);\n}\n\nstatic int slic_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(slic_stats_strings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void slic_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *eth_stats, u64 *data)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\tstruct slic_stats *stats = &sdev->stats;\n\n\tSLIC_GET_STATS_COUNTER(data[0], stats, rx_packets);\n\tSLIC_GET_STATS_COUNTER(data[1], stats, rx_bytes);\n\tSLIC_GET_STATS_COUNTER(data[2], stats, rx_mcasts);\n\tSLIC_GET_STATS_COUNTER(data[3], stats, rx_errors);\n\tSLIC_GET_STATS_COUNTER(data[4], stats, rx_buff_miss);\n\tSLIC_GET_STATS_COUNTER(data[5], stats, rx_tpcsum);\n\tSLIC_GET_STATS_COUNTER(data[6], stats, rx_tpoflow);\n\tSLIC_GET_STATS_COUNTER(data[7], stats, rx_tphlen);\n\tSLIC_GET_STATS_COUNTER(data[8], stats, rx_ipcsum);\n\tSLIC_GET_STATS_COUNTER(data[9], stats, rx_iplen);\n\tSLIC_GET_STATS_COUNTER(data[10], stats, rx_iphlen);\n\tSLIC_GET_STATS_COUNTER(data[11], stats, rx_early);\n\tSLIC_GET_STATS_COUNTER(data[12], stats, rx_buffoflow);\n\tSLIC_GET_STATS_COUNTER(data[13], stats, rx_lcode);\n\tSLIC_GET_STATS_COUNTER(data[14], stats, rx_drbl);\n\tSLIC_GET_STATS_COUNTER(data[15], stats, rx_crc);\n\tSLIC_GET_STATS_COUNTER(data[16], stats, rx_oflow802);\n\tSLIC_GET_STATS_COUNTER(data[17], stats, rx_uflow802);\n\tSLIC_GET_STATS_COUNTER(data[18], stats, tx_packets);\n\tSLIC_GET_STATS_COUNTER(data[19], stats, tx_bytes);\n\tSLIC_GET_STATS_COUNTER(data[20], stats, tx_carrier);\n\tSLIC_GET_STATS_COUNTER(data[21], stats, tx_dropped);\n\tSLIC_GET_STATS_COUNTER(data[22], stats, irq_errs);\n}\n\nstatic void slic_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\tmemcpy(data, slic_stats_strings, sizeof(slic_stats_strings));\n}\n\nstatic void slic_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct slic_device *sdev = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(sdev->pdev), sizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops slic_ethtool_ops = {\n\t.get_drvinfo\t\t= slic_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= slic_get_strings,\n\t.get_ethtool_stats\t= slic_get_ethtool_stats,\n\t.get_sset_count\t\t= slic_get_sset_count,\n};\n\nstatic const struct net_device_ops slic_netdev_ops = {\n\t.ndo_open\t\t= slic_open,\n\t.ndo_stop\t\t= slic_close,\n\t.ndo_start_xmit\t\t= slic_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_get_stats64\t= slic_get_stats,\n\t.ndo_set_rx_mode\t= slic_set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic u16 slic_eeprom_csum(unsigned char *eeprom, unsigned int len)\n{\n\tunsigned char *ptr = eeprom;\n\tu32 csum = 0;\n\t__le16 data;\n\n\twhile (len > 1) {\n\t\tmemcpy(&data, ptr, sizeof(data));\n\t\tcsum += le16_to_cpu(data);\n\t\tptr += 2;\n\t\tlen -= 2;\n\t}\n\tif (len > 0)\n\t\tcsum += *(u8 *)ptr;\n\twhile (csum >> 16)\n\t\tcsum = (csum & 0xFFFF) + ((csum >> 16) & 0xFFFF);\n\treturn ~csum;\n}\n\n \nstatic bool slic_eeprom_valid(unsigned char *eeprom, unsigned int size)\n{\n\tconst unsigned int MAX_SIZE = 128;\n\tconst unsigned int MIN_SIZE = 98;\n\t__le16 magic;\n\t__le16 csum;\n\n\tif (size < MIN_SIZE || size > MAX_SIZE)\n\t\treturn false;\n\tmemcpy(&magic, eeprom, sizeof(magic));\n\tif (le16_to_cpu(magic) != SLIC_EEPROM_MAGIC)\n\t\treturn false;\n\t \n\tsize -= 2;\n\tmemcpy(&csum, eeprom + size, sizeof(csum));\n\n\treturn (le16_to_cpu(csum) == slic_eeprom_csum(eeprom, size));\n}\n\nstatic int slic_read_eeprom(struct slic_device *sdev)\n{\n\tunsigned int devfn = PCI_FUNC(sdev->pdev->devfn);\n\tstruct slic_shmem *sm = &sdev->shmem;\n\tstruct slic_shmem_data *sm_data = sm->shmem_data;\n\tconst unsigned int MAX_LOOPS = 5000;\n\tunsigned int codesize;\n\tunsigned char *eeprom;\n\tstruct slic_upr *upr;\n\tunsigned int i = 0;\n\tdma_addr_t paddr;\n\tint err = 0;\n\tu8 *mac[2];\n\n\teeprom = dma_alloc_coherent(&sdev->pdev->dev, SLIC_EEPROM_SIZE,\n\t\t\t\t    &paddr, GFP_KERNEL);\n\tif (!eeprom)\n\t\treturn -ENOMEM;\n\n\tslic_write(sdev, SLIC_REG_ICR, SLIC_ICR_INT_OFF);\n\t \n\tslic_write(sdev, SLIC_REG_ISP, lower_32_bits(sm->isr_paddr));\n\n\terr = slic_new_upr(sdev, SLIC_UPR_CONFIG, paddr);\n\tif (!err) {\n\t\tfor (i = 0; i < MAX_LOOPS; i++) {\n\t\t\tif (le32_to_cpu(sm_data->isr) & SLIC_ISR_UPC)\n\t\t\t\tbreak;\n\t\t\tmdelay(1);\n\t\t}\n\t\tif (i == MAX_LOOPS) {\n\t\t\tdev_err(&sdev->pdev->dev,\n\t\t\t\t\"timed out while waiting for eeprom data\\n\");\n\t\t\terr = -ETIMEDOUT;\n\t\t}\n\t\tupr = slic_dequeue_upr(sdev);\n\t\tkfree(upr);\n\t}\n\n\tslic_write(sdev, SLIC_REG_ISP, 0);\n\tslic_write(sdev, SLIC_REG_ISR, 0);\n\tslic_flush_write(sdev);\n\n\tif (err)\n\t\tgoto free_eeprom;\n\n\tif (sdev->model == SLIC_MODEL_OASIS) {\n\t\tstruct slic_oasis_eeprom *oee;\n\n\t\toee = (struct slic_oasis_eeprom *)eeprom;\n\t\tmac[0] = oee->mac;\n\t\tmac[1] = oee->mac2;\n\t\tcodesize = le16_to_cpu(oee->eeprom_code_size);\n\t} else {\n\t\tstruct slic_mojave_eeprom *mee;\n\n\t\tmee = (struct slic_mojave_eeprom *)eeprom;\n\t\tmac[0] = mee->mac;\n\t\tmac[1] = mee->mac2;\n\t\tcodesize = le16_to_cpu(mee->eeprom_code_size);\n\t}\n\n\tif (!slic_eeprom_valid(eeprom, codesize)) {\n\t\tdev_err(&sdev->pdev->dev, \"invalid checksum in eeprom\\n\");\n\t\terr = -EINVAL;\n\t\tgoto free_eeprom;\n\t}\n\t \n\teth_hw_addr_set(sdev->netdev, mac[devfn]);\nfree_eeprom:\n\tdma_free_coherent(&sdev->pdev->dev, SLIC_EEPROM_SIZE, eeprom, paddr);\n\n\treturn err;\n}\n\nstatic int slic_init(struct slic_device *sdev)\n{\n\tint err;\n\n\tspin_lock_init(&sdev->upper_lock);\n\tspin_lock_init(&sdev->link_lock);\n\tINIT_LIST_HEAD(&sdev->upr_list.list);\n\tspin_lock_init(&sdev->upr_list.lock);\n\tu64_stats_init(&sdev->stats.syncp);\n\n\tslic_card_reset(sdev);\n\n\terr = slic_load_firmware(sdev);\n\tif (err) {\n\t\tdev_err(&sdev->pdev->dev, \"failed to load firmware\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = slic_init_shmem(sdev);\n\tif (err) {\n\t\tdev_err(&sdev->pdev->dev, \"failed to init shared memory\\n\");\n\t\treturn err;\n\t}\n\n\terr = slic_read_eeprom(sdev);\n\tif (err) {\n\t\tdev_err(&sdev->pdev->dev, \"failed to read eeprom\\n\");\n\t\tgoto free_sm;\n\t}\n\n\tslic_card_reset(sdev);\n\tslic_free_shmem(sdev);\n\n\treturn 0;\nfree_sm:\n\tslic_free_shmem(sdev);\n\n\treturn err;\n}\n\nstatic bool slic_is_fiber(unsigned short subdev)\n{\n\tswitch (subdev) {\n\t \n\tcase PCI_SUBDEVICE_ID_ALACRITECH_1000X1F:\n\tcase PCI_SUBDEVICE_ID_ALACRITECH_SES1001F: fallthrough;\n\t \n\tcase PCI_SUBDEVICE_ID_ALACRITECH_SEN2002XF:\n\tcase PCI_SUBDEVICE_ID_ALACRITECH_SEN2001XF:\n\tcase PCI_SUBDEVICE_ID_ALACRITECH_SEN2104EF:\n\tcase PCI_SUBDEVICE_ID_ALACRITECH_SEN2102EF:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void slic_configure_pci(struct pci_dev *pdev)\n{\n\tu16 old;\n\tu16 cmd;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &old);\n\n\tcmd = old | PCI_COMMAND_PARITY | PCI_COMMAND_SERR;\n\tif (old != cmd)\n\t\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n}\n\nstatic int slic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct slic_device *sdev;\n\tstruct net_device *dev;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable PCI device\\n\");\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tslic_configure_pci(pdev);\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to setup DMA\\n\");\n\t\tgoto disable;\n\t}\n\n\tdma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to obtain PCI regions\\n\");\n\t\tgoto disable;\n\t}\n\n\tdev = alloc_etherdev(sizeof(*sdev));\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"failed to alloc ethernet device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_regions;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tpci_set_drvdata(pdev, dev);\n\tdev->irq = pdev->irq;\n\tdev->netdev_ops = &slic_netdev_ops;\n\tdev->hw_features = NETIF_F_RXCSUM;\n\tdev->features |= dev->hw_features;\n\n\tdev->ethtool_ops = &slic_ethtool_ops;\n\n\tsdev = netdev_priv(dev);\n\tsdev->model = (pdev->device == PCI_DEVICE_ID_ALACRITECH_OASIS) ?\n\t\t      SLIC_MODEL_OASIS : SLIC_MODEL_MOJAVE;\n\tsdev->is_fiber = slic_is_fiber(pdev->subsystem_device);\n\tsdev->pdev = pdev;\n\tsdev->netdev = dev;\n\tsdev->regs = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t     pci_resource_len(pdev, 0));\n\tif (!sdev->regs) {\n\t\tdev_err(&pdev->dev, \"failed to map registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_netdev;\n\t}\n\n\terr = slic_init(sdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to initialize driver\\n\");\n\t\tgoto unmap;\n\t}\n\n\tnetif_napi_add(dev, &sdev->napi, slic_poll);\n\tnetif_carrier_off(dev);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register net device: %i\\n\", err);\n\t\tgoto unmap;\n\t}\n\n\treturn 0;\n\nunmap:\n\tiounmap(sdev->regs);\nfree_netdev:\n\tfree_netdev(dev);\nfree_regions:\n\tpci_release_regions(pdev);\ndisable:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void slic_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct slic_device *sdev = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tiounmap(sdev->regs);\n\tfree_netdev(dev);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver slic_driver = {\n\t.name = DRV_NAME,\n\t.id_table = slic_id_tbl,\n\t.probe = slic_probe,\n\t.remove = slic_remove,\n};\n\nmodule_pci_driver(slic_driver);\n\nMODULE_DESCRIPTION(\"Alacritech non-accelerated SLIC driver\");\nMODULE_AUTHOR(\"Lino Sanfilippo <LinoSanfilippo@gmx.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}