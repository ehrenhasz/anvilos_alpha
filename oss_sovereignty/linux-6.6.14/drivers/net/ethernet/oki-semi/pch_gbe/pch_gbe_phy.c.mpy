{
  "module_name": "pch_gbe_phy.c",
  "hash_id": "141d3254dadacea9c7f856e8d9628e7e45d5898042eb40573d4d606650d386f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_phy.c",
  "human_readable_source": "\n \n\n#include \"pch_gbe.h\"\n#include \"pch_gbe_phy.h\"\n\n#define PHY_MAX_REG_ADDRESS   0x1F\t \n\n \n \n#define PHY_CONTROL           0x00   \n#define PHY_STATUS            0x01   \n#define PHY_ID1               0x02   \n#define PHY_ID2               0x03   \n#define PHY_AUTONEG_ADV       0x04   \n#define PHY_LP_ABILITY        0x05   \n#define PHY_AUTONEG_EXP       0x06   \n#define PHY_NEXT_PAGE_TX      0x07   \n#define PHY_LP_NEXT_PAGE      0x08   \n#define PHY_1000T_CTRL        0x09   \n#define PHY_1000T_STATUS      0x0A   \n#define PHY_EXT_STATUS        0x0F   \n#define PHY_PHYSP_CONTROL     0x10   \n#define PHY_EXT_PHYSP_CONTROL 0x14   \n#define PHY_LED_CONTROL       0x18   \n#define PHY_EXT_PHYSP_STATUS  0x1B   \n\n \n#define MII_CR_SPEED_SELECT_MSB 0x0040\t \n#define MII_CR_COLL_TEST_ENABLE 0x0080\t \n#define MII_CR_FULL_DUPLEX      0x0100\t \n#define MII_CR_RESTART_AUTO_NEG 0x0200\t \n#define MII_CR_ISOLATE          0x0400\t \n#define MII_CR_POWER_DOWN       0x0800\t \n#define MII_CR_AUTO_NEG_EN      0x1000\t \n#define MII_CR_SPEED_SELECT_LSB 0x2000\t \n#define MII_CR_LOOPBACK         0x4000\t \n#define MII_CR_RESET            0x8000\t \n#define MII_CR_SPEED_1000       0x0040\n#define MII_CR_SPEED_100        0x2000\n#define MII_CR_SPEED_10         0x0000\n\n \n#define MII_SR_EXTENDED_CAPS     0x0001\t \n#define MII_SR_JABBER_DETECT     0x0002\t \n#define MII_SR_LINK_STATUS       0x0004\t \n#define MII_SR_AUTONEG_CAPS      0x0008\t \n#define MII_SR_REMOTE_FAULT      0x0010\t \n#define MII_SR_AUTONEG_COMPLETE  0x0020\t \n#define MII_SR_PREAMBLE_SUPPRESS 0x0040\t \n#define MII_SR_EXTENDED_STATUS   0x0100\t \n#define MII_SR_100T2_HD_CAPS     0x0200\t \n#define MII_SR_100T2_FD_CAPS     0x0400\t \n#define MII_SR_10T_HD_CAPS       0x0800\t \n#define MII_SR_10T_FD_CAPS       0x1000\t \n#define MII_SR_100X_HD_CAPS      0x2000\t \n#define MII_SR_100X_FD_CAPS      0x4000\t \n#define MII_SR_100T4_CAPS        0x8000\t \n\n \n#define PHY_AR803X_ID           0x00001374\n#define PHY_AR8031_DBG_OFF      0x1D\n#define PHY_AR8031_DBG_DAT      0x1E\n#define PHY_AR8031_SERDES       0x05\n#define PHY_AR8031_HIBERNATE    0x0B\n#define PHY_AR8031_SERDES_TX_CLK_DLY   0x0100  \n#define PHY_AR8031_PS_HIB_EN           0x8000  \n\n \n#define PHY_REVISION_MASK        0x000F\n\n \n#define PHYSP_CTRL_ASSERT_CRS_TX  0x0800\n\n\n \n#define PHY_CONTROL_DEFAULT         0x1140  \n#define PHY_AUTONEG_ADV_DEFAULT     0x01e0  \n#define PHY_NEXT_PAGE_TX_DEFAULT    0x2001  \n#define PHY_1000T_CTRL_DEFAULT      0x0300  \n#define PHY_PHYSP_CONTROL_DEFAULT   0x01EE  \n\n \ns32 pch_gbe_phy_get_id(struct pch_gbe_hw *hw)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tstruct pch_gbe_phy_info *phy = &hw->phy;\n\ts32 ret;\n\tu16 phy_id1;\n\tu16 phy_id2;\n\n\tret = pch_gbe_phy_read_reg_miic(hw, PHY_ID1, &phy_id1);\n\tif (ret)\n\t\treturn ret;\n\tret = pch_gbe_phy_read_reg_miic(hw, PHY_ID2, &phy_id2);\n\tif (ret)\n\t\treturn ret;\n\t \n\tphy->id = (u32)phy_id1;\n\tphy->id = ((phy->id << 6) | ((phy_id2 & 0xFC00) >> 10));\n\tphy->revision = (u32) (phy_id2 & 0x000F);\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"phy->id : 0x%08x  phy->revision : 0x%08x\\n\",\n\t\t   phy->id, phy->revision);\n\treturn 0;\n}\n\n \ns32 pch_gbe_phy_read_reg_miic(struct pch_gbe_hw *hw, u32 offset, u16 *data)\n{\n\tstruct pch_gbe_phy_info *phy = &hw->phy;\n\n\tif (offset > PHY_MAX_REG_ADDRESS) {\n\t\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\n\t\tnetdev_err(adapter->netdev, \"PHY Address %d is out of range\\n\",\n\t\t\t   offset);\n\t\treturn -EINVAL;\n\t}\n\t*data = pch_gbe_mac_ctrl_miim(hw, phy->addr, PCH_GBE_HAL_MIIM_READ,\n\t\t\t\t      offset, (u16)0);\n\treturn 0;\n}\n\n \ns32 pch_gbe_phy_write_reg_miic(struct pch_gbe_hw *hw, u32 offset, u16 data)\n{\n\tstruct pch_gbe_phy_info *phy = &hw->phy;\n\n\tif (offset > PHY_MAX_REG_ADDRESS) {\n\t\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\n\t\tnetdev_err(adapter->netdev, \"PHY Address %d is out of range\\n\",\n\t\t\t   offset);\n\t\treturn -EINVAL;\n\t}\n\tpch_gbe_mac_ctrl_miim(hw, phy->addr, PCH_GBE_HAL_MIIM_WRITE,\n\t\t\t\t offset, data);\n\treturn 0;\n}\n\n \nstatic void pch_gbe_phy_sw_reset(struct pch_gbe_hw *hw)\n{\n\tu16 phy_ctrl;\n\n\tpch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &phy_ctrl);\n\tphy_ctrl |= MII_CR_RESET;\n\tpch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, phy_ctrl);\n\tudelay(1);\n}\n\n \nvoid pch_gbe_phy_hw_reset(struct pch_gbe_hw *hw)\n{\n\tpch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, PHY_CONTROL_DEFAULT);\n\tpch_gbe_phy_write_reg_miic(hw, PHY_AUTONEG_ADV,\n\t\t\t\t\tPHY_AUTONEG_ADV_DEFAULT);\n\tpch_gbe_phy_write_reg_miic(hw, PHY_NEXT_PAGE_TX,\n\t\t\t\t\tPHY_NEXT_PAGE_TX_DEFAULT);\n\tpch_gbe_phy_write_reg_miic(hw, PHY_1000T_CTRL, PHY_1000T_CTRL_DEFAULT);\n\tpch_gbe_phy_write_reg_miic(hw, PHY_PHYSP_CONTROL,\n\t\t\t\t\tPHY_PHYSP_CONTROL_DEFAULT);\n}\n\n \nvoid pch_gbe_phy_power_up(struct pch_gbe_hw *hw)\n{\n\tu16 mii_reg;\n\n\tmii_reg = 0;\n\t \n\t \n\tpch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &mii_reg);\n\tmii_reg &= ~MII_CR_POWER_DOWN;\n\tpch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, mii_reg);\n}\n\n \nvoid pch_gbe_phy_power_down(struct pch_gbe_hw *hw)\n{\n\tu16 mii_reg;\n\n\tmii_reg = 0;\n\t \n\tpch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &mii_reg);\n\tmii_reg |= MII_CR_POWER_DOWN;\n\tpch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, mii_reg);\n\tmdelay(1);\n}\n\n \nvoid pch_gbe_phy_set_rgmii(struct pch_gbe_hw *hw)\n{\n\tpch_gbe_phy_sw_reset(hw);\n}\n\n \nstatic int pch_gbe_phy_tx_clk_delay(struct pch_gbe_hw *hw)\n{\n\t \n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tu16 mii_reg;\n\tint ret = 0;\n\n\tswitch (hw->phy.id) {\n\tcase PHY_AR803X_ID:\n\t\tnetdev_dbg(adapter->netdev,\n\t\t\t   \"Configuring AR803X PHY for 2ns TX clock delay\\n\");\n\t\tpch_gbe_phy_read_reg_miic(hw, PHY_AR8031_DBG_OFF, &mii_reg);\n\t\tret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_OFF,\n\t\t\t\t\t\t PHY_AR8031_SERDES);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpch_gbe_phy_read_reg_miic(hw, PHY_AR8031_DBG_DAT, &mii_reg);\n\t\tmii_reg |= PHY_AR8031_SERDES_TX_CLK_DLY;\n\t\tret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_DAT,\n\t\t\t\t\t\t mii_reg);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Unknown PHY (%x), could not set TX clock delay\\n\",\n\t\t\t   hw->phy.id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Could not configure tx clock delay for PHY\\n\");\n\treturn ret;\n}\n\n \nvoid pch_gbe_phy_init_setting(struct pch_gbe_hw *hw)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tstruct ethtool_cmd     cmd = { .cmd = ETHTOOL_GSET };\n\tint ret;\n\tu16 mii_reg;\n\n\tmii_ethtool_gset(&adapter->mii, &cmd);\n\n\tethtool_cmd_speed_set(&cmd, hw->mac.link_speed);\n\tcmd.duplex = hw->mac.link_duplex;\n\tcmd.advertising = hw->phy.autoneg_advertised;\n\tcmd.autoneg = hw->mac.autoneg;\n\tpch_gbe_phy_write_reg_miic(hw, MII_BMCR, BMCR_RESET);\n\tret = mii_ethtool_sset(&adapter->mii, &cmd);\n\tif (ret)\n\t\tnetdev_err(adapter->netdev, \"Error: mii_ethtool_sset\\n\");\n\n\tpch_gbe_phy_sw_reset(hw);\n\n\tpch_gbe_phy_read_reg_miic(hw, PHY_PHYSP_CONTROL, &mii_reg);\n\tmii_reg |= PHYSP_CTRL_ASSERT_CRS_TX;\n\tpch_gbe_phy_write_reg_miic(hw, PHY_PHYSP_CONTROL, mii_reg);\n\n\t \n\tif (adapter->pdata && adapter->pdata->phy_tx_clk_delay)\n\t\tpch_gbe_phy_tx_clk_delay(hw);\n}\n\n \nint pch_gbe_phy_disable_hibernate(struct pch_gbe_hw *hw)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tu16 mii_reg;\n\tint ret = 0;\n\n\tswitch (hw->phy.id) {\n\tcase PHY_AR803X_ID:\n\t\tnetdev_dbg(adapter->netdev,\n\t\t\t   \"Disabling hibernation for AR803X PHY\\n\");\n\t\tret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_OFF,\n\t\t\t\t\t\t PHY_AR8031_HIBERNATE);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpch_gbe_phy_read_reg_miic(hw, PHY_AR8031_DBG_DAT, &mii_reg);\n\t\tmii_reg &= ~PHY_AR8031_PS_HIB_EN;\n\t\tret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_DAT,\n\t\t\t\t\t\t mii_reg);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Unknown PHY (%x), could not disable hibernation\\n\",\n\t\t\t   hw->phy.id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Could not disable PHY hibernation\\n\");\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}