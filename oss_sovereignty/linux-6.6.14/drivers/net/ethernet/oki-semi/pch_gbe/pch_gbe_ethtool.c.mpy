{
  "module_name": "pch_gbe_ethtool.c",
  "hash_id": "ca9727d3a8522931455edb8205feb78b6b8cc5b9332e279318ceb71bc0caaa62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c",
  "human_readable_source": "\n \n#include \"pch_gbe.h\"\n#include \"pch_gbe_phy.h\"\n\nstatic const char pch_driver_version[] = \"1.01\";\n\n \nstruct pch_gbe_stats {\n\tchar string[ETH_GSTRING_LEN];\n\tsize_t size;\n\tsize_t offset;\n};\n\n#define PCH_GBE_STAT(m)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.string = #m,\t\t\t\t\t\t\\\n\t.size = sizeof_field(struct pch_gbe_hw_stats, m),\t\\\n\t.offset = offsetof(struct pch_gbe_hw_stats, m),\t\t\\\n}\n\n \nstatic const struct pch_gbe_stats pch_gbe_gstrings_stats[] = {\n\tPCH_GBE_STAT(rx_packets),\n\tPCH_GBE_STAT(tx_packets),\n\tPCH_GBE_STAT(rx_bytes),\n\tPCH_GBE_STAT(tx_bytes),\n\tPCH_GBE_STAT(rx_errors),\n\tPCH_GBE_STAT(tx_errors),\n\tPCH_GBE_STAT(rx_dropped),\n\tPCH_GBE_STAT(tx_dropped),\n\tPCH_GBE_STAT(multicast),\n\tPCH_GBE_STAT(collisions),\n\tPCH_GBE_STAT(rx_crc_errors),\n\tPCH_GBE_STAT(rx_frame_errors),\n\tPCH_GBE_STAT(rx_alloc_buff_failed),\n\tPCH_GBE_STAT(tx_length_errors),\n\tPCH_GBE_STAT(tx_aborted_errors),\n\tPCH_GBE_STAT(tx_carrier_errors),\n\tPCH_GBE_STAT(tx_timeout_count),\n\tPCH_GBE_STAT(tx_restart_count),\n\tPCH_GBE_STAT(intr_rx_dsc_empty_count),\n\tPCH_GBE_STAT(intr_rx_frame_err_count),\n\tPCH_GBE_STAT(intr_rx_fifo_err_count),\n\tPCH_GBE_STAT(intr_rx_dma_err_count),\n\tPCH_GBE_STAT(intr_tx_fifo_err_count),\n\tPCH_GBE_STAT(intr_tx_dma_err_count),\n\tPCH_GBE_STAT(intr_tcpip_err_count)\n};\n\n#define PCH_GBE_QUEUE_STATS_LEN 0\n#define PCH_GBE_GLOBAL_STATS_LEN\tARRAY_SIZE(pch_gbe_gstrings_stats)\n#define PCH_GBE_STATS_LEN (PCH_GBE_GLOBAL_STATS_LEN + PCH_GBE_QUEUE_STATS_LEN)\n\n#define PCH_GBE_MAC_REGS_LEN    (sizeof(struct pch_gbe_regs) / 4)\n#define PCH_GBE_REGS_LEN        (PCH_GBE_MAC_REGS_LEN + PCH_GBE_PHY_REGS_LEN)\n \nstatic int pch_gbe_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t      struct ethtool_link_ksettings *ecmd)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tu32 supported, advertising;\n\n\tmii_ethtool_get_link_ksettings(&adapter->mii, ecmd);\n\n\tethtool_convert_link_mode_to_legacy_u32(&supported,\n\t\t\t\t\t\tecmd->link_modes.supported);\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tecmd->link_modes.advertising);\n\n\tsupported &= ~(SUPPORTED_TP | SUPPORTED_1000baseT_Half);\n\tadvertising &= ~(ADVERTISED_TP | ADVERTISED_1000baseT_Half);\n\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\tif (!netif_carrier_ok(adapter->netdev))\n\t\tecmd->base.speed = SPEED_UNKNOWN;\n\n\treturn 0;\n}\n\n \nstatic int pch_gbe_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t      const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct ethtool_link_ksettings copy_ecmd;\n\tu32 speed = ecmd->base.speed;\n\tu32 advertising;\n\tint ret;\n\n\tpch_gbe_phy_write_reg_miic(hw, MII_BMCR, BMCR_RESET);\n\n\tmemcpy(&copy_ecmd, ecmd, sizeof(*ecmd));\n\n\t \n\tif (speed == UINT_MAX) {\n\t\tspeed = SPEED_1000;\n\t\tcopy_ecmd.base.speed = speed;\n\t\tcopy_ecmd.base.duplex = DUPLEX_FULL;\n\t}\n\tret = mii_ethtool_set_link_ksettings(&adapter->mii, &copy_ecmd);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"Error: mii_ethtool_set_link_ksettings\\n\");\n\t\treturn ret;\n\t}\n\thw->mac.link_speed = speed;\n\thw->mac.link_duplex = copy_ecmd.base.duplex;\n\tethtool_convert_link_mode_to_legacy_u32(\n\t\t&advertising, copy_ecmd.link_modes.advertising);\n\thw->phy.autoneg_advertised = advertising;\n\thw->mac.autoneg = copy_ecmd.base.autoneg;\n\n\t \n\tif (netif_running(adapter->netdev)) {\n\t\tpch_gbe_down(adapter);\n\t\tret = pch_gbe_up(adapter);\n\t} else {\n\t\tpch_gbe_reset(adapter);\n\t}\n\treturn ret;\n}\n\n \nstatic int pch_gbe_get_regs_len(struct net_device *netdev)\n{\n\treturn PCH_GBE_REGS_LEN * (int)sizeof(u32);\n}\n\n \nstatic void pch_gbe_get_drvinfo(struct net_device *netdev,\n\t\t\t\t struct ethtool_drvinfo *drvinfo)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, pch_driver_version, sizeof(drvinfo->version));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\n \nstatic void pch_gbe_get_regs(struct net_device *netdev,\n\t\t\t\tstruct ethtool_regs *regs, void *p)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tu32 *regs_buff = p;\n\tu16 i, tmp;\n\n\tregs->version = 0x1000000 | (__u32)pdev->revision << 16 | pdev->device;\n\tfor (i = 0; i < PCH_GBE_MAC_REGS_LEN; i++)\n\t\t*regs_buff++ = ioread32(&hw->reg->INT_ST + i);\n\t \n\tfor (i = 0; i < PCH_GBE_PHY_REGS_LEN; i++) {\n\t\tpch_gbe_phy_read_reg_miic(&adapter->hw, i, &tmp);\n\t\t*regs_buff++ = tmp;\n\t}\n}\n\n \nstatic void pch_gbe_get_wol(struct net_device *netdev,\n\t\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST | WAKE_BCAST | WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\tif ((adapter->wake_up_evt & PCH_GBE_WLC_IND))\n\t\twol->wolopts |= WAKE_UCAST;\n\tif ((adapter->wake_up_evt & PCH_GBE_WLC_MLT))\n\t\twol->wolopts |= WAKE_MCAST;\n\tif ((adapter->wake_up_evt & PCH_GBE_WLC_BR))\n\t\twol->wolopts |= WAKE_BCAST;\n\tif ((adapter->wake_up_evt & PCH_GBE_WLC_MP))\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\n \nstatic int pch_gbe_set_wol(struct net_device *netdev,\n\t\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tif ((wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE)))\n\t\treturn -EOPNOTSUPP;\n\t \n\tadapter->wake_up_evt = 0;\n\n\tif ((wol->wolopts & WAKE_UCAST))\n\t\tadapter->wake_up_evt |= PCH_GBE_WLC_IND;\n\tif ((wol->wolopts & WAKE_MCAST))\n\t\tadapter->wake_up_evt |= PCH_GBE_WLC_MLT;\n\tif ((wol->wolopts & WAKE_BCAST))\n\t\tadapter->wake_up_evt |= PCH_GBE_WLC_BR;\n\tif ((wol->wolopts & WAKE_MAGIC))\n\t\tadapter->wake_up_evt |= PCH_GBE_WLC_MP;\n\treturn 0;\n}\n\n \nstatic int pch_gbe_nway_reset(struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\treturn mii_nway_restart(&adapter->mii);\n}\n\n \nstatic void pch_gbe_get_ringparam(struct net_device *netdev,\n\t\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_tx_ring *txdr = adapter->tx_ring;\n\tstruct pch_gbe_rx_ring *rxdr = adapter->rx_ring;\n\n\tring->rx_max_pending = PCH_GBE_MAX_RXD;\n\tring->tx_max_pending = PCH_GBE_MAX_TXD;\n\tring->rx_pending = rxdr->count;\n\tring->tx_pending = txdr->count;\n}\n\n \nstatic int pch_gbe_set_ringparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_tx_ring *txdr, *tx_old;\n\tstruct pch_gbe_rx_ring *rxdr, *rx_old;\n\tint tx_ring_size, rx_ring_size;\n\tint err = 0;\n\n\tif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\ttx_ring_size = (int)sizeof(struct pch_gbe_tx_ring);\n\trx_ring_size = (int)sizeof(struct pch_gbe_rx_ring);\n\n\tif ((netif_running(adapter->netdev)))\n\t\tpch_gbe_down(adapter);\n\ttx_old = adapter->tx_ring;\n\trx_old = adapter->rx_ring;\n\n\ttxdr = kzalloc(tx_ring_size, GFP_KERNEL);\n\tif (!txdr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_tx;\n\t}\n\trxdr = kzalloc(rx_ring_size, GFP_KERNEL);\n\tif (!rxdr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_rx;\n\t}\n\tadapter->tx_ring = txdr;\n\tadapter->rx_ring = rxdr;\n\n\trxdr->count =\n\t\tclamp_val(ring->rx_pending, PCH_GBE_MIN_RXD, PCH_GBE_MAX_RXD);\n\trxdr->count = roundup(rxdr->count, PCH_GBE_RX_DESC_MULTIPLE);\n\n\ttxdr->count =\n\t\tclamp_val(ring->tx_pending, PCH_GBE_MIN_RXD, PCH_GBE_MAX_RXD);\n\ttxdr->count = roundup(txdr->count, PCH_GBE_TX_DESC_MULTIPLE);\n\n\tif ((netif_running(adapter->netdev))) {\n\t\t \n\t\terr = pch_gbe_setup_rx_resources(adapter, adapter->rx_ring);\n\t\tif (err)\n\t\t\tgoto err_setup_rx;\n\t\terr = pch_gbe_setup_tx_resources(adapter, adapter->tx_ring);\n\t\tif (err)\n\t\t\tgoto err_setup_tx;\n\t\tpch_gbe_free_rx_resources(adapter, rx_old);\n\t\tpch_gbe_free_tx_resources(adapter, tx_old);\n\t\tkfree(tx_old);\n\t\tkfree(rx_old);\n\t\tadapter->rx_ring = rxdr;\n\t\tadapter->tx_ring = txdr;\n\t\terr = pch_gbe_up(adapter);\n\t}\n\treturn err;\n\nerr_setup_tx:\n\tpch_gbe_free_rx_resources(adapter, adapter->rx_ring);\nerr_setup_rx:\n\tadapter->rx_ring = rx_old;\n\tadapter->tx_ring = tx_old;\n\tkfree(rxdr);\nerr_alloc_rx:\n\tkfree(txdr);\nerr_alloc_tx:\n\tif (netif_running(adapter->netdev))\n\t\tpch_gbe_up(adapter);\n\treturn err;\n}\n\n \nstatic void pch_gbe_get_pauseparam(struct net_device *netdev,\n\t\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tpause->autoneg =\n\t    ((hw->mac.fc_autoneg) ? AUTONEG_ENABLE : AUTONEG_DISABLE);\n\n\tif (hw->mac.fc == PCH_GBE_FC_RX_PAUSE) {\n\t\tpause->rx_pause = 1;\n\t} else if (hw->mac.fc == PCH_GBE_FC_TX_PAUSE) {\n\t\tpause->tx_pause = 1;\n\t} else if (hw->mac.fc == PCH_GBE_FC_FULL) {\n\t\tpause->rx_pause = 1;\n\t\tpause->tx_pause = 1;\n\t}\n}\n\n \nstatic int pch_gbe_set_pauseparam(struct net_device *netdev,\n\t\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tint ret = 0;\n\n\thw->mac.fc_autoneg = pause->autoneg;\n\tif ((pause->rx_pause) && (pause->tx_pause))\n\t\thw->mac.fc = PCH_GBE_FC_FULL;\n\telse if ((pause->rx_pause) && (!pause->tx_pause))\n\t\thw->mac.fc = PCH_GBE_FC_RX_PAUSE;\n\telse if ((!pause->rx_pause) && (pause->tx_pause))\n\t\thw->mac.fc = PCH_GBE_FC_TX_PAUSE;\n\telse if ((!pause->rx_pause) && (!pause->tx_pause))\n\t\thw->mac.fc = PCH_GBE_FC_NONE;\n\n\tif (hw->mac.fc_autoneg == AUTONEG_ENABLE) {\n\t\tif ((netif_running(adapter->netdev))) {\n\t\t\tpch_gbe_down(adapter);\n\t\t\tret = pch_gbe_up(adapter);\n\t\t} else {\n\t\t\tpch_gbe_reset(adapter);\n\t\t}\n\t} else {\n\t\tret = pch_gbe_mac_force_mac_fc(hw);\n\t}\n\treturn ret;\n}\n\n \nstatic void pch_gbe_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t\t\tu8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase (u32) ETH_SS_STATS:\n\t\tfor (i = 0; i < PCH_GBE_GLOBAL_STATS_LEN; i++) {\n\t\t\tmemcpy(p, pch_gbe_gstrings_stats[i].string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void pch_gbe_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\tconst struct pch_gbe_stats *gstats = pch_gbe_gstrings_stats;\n\tchar *hw_stats = (char *)&adapter->stats;\n\n\tpch_gbe_update_stats(adapter);\n\tfor (i = 0; i < PCH_GBE_GLOBAL_STATS_LEN; i++) {\n\t\tchar *p = hw_stats + gstats->offset;\n\t\tdata[i] = gstats->size == sizeof(u64) ? *(u64 *)p:(*(u32 *)p);\n\t\tgstats++;\n\t}\n}\n\nstatic int pch_gbe_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn PCH_GBE_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct ethtool_ops pch_gbe_ethtool_ops = {\n\t.get_drvinfo = pch_gbe_get_drvinfo,\n\t.get_regs_len = pch_gbe_get_regs_len,\n\t.get_regs = pch_gbe_get_regs,\n\t.get_wol = pch_gbe_get_wol,\n\t.set_wol = pch_gbe_set_wol,\n\t.nway_reset = pch_gbe_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_ringparam = pch_gbe_get_ringparam,\n\t.set_ringparam = pch_gbe_set_ringparam,\n\t.get_pauseparam = pch_gbe_get_pauseparam,\n\t.set_pauseparam = pch_gbe_set_pauseparam,\n\t.get_strings = pch_gbe_get_strings,\n\t.get_ethtool_stats = pch_gbe_get_ethtool_stats,\n\t.get_sset_count = pch_gbe_get_sset_count,\n\t.get_link_ksettings = pch_gbe_get_link_ksettings,\n\t.set_link_ksettings = pch_gbe_set_link_ksettings,\n};\n\nvoid pch_gbe_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &pch_gbe_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}