{
  "module_name": "pch_gbe_main.c",
  "hash_id": "a9acac80d2cc1ae0375933ca2ef6d6a07cdc9d8a19c697cfc333cdc5cdf68946",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c",
  "human_readable_source": "\n \n\n#include \"pch_gbe.h\"\n#include \"pch_gbe_phy.h\"\n\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_pch.h>\n#include <linux/gpio.h>\n\n#define PCH_GBE_MAR_ENTRIES\t\t16\n#define PCH_GBE_SHORT_PKT\t\t64\n#define DSC_INIT16\t\t\t0xC000\n#define PCH_GBE_DMA_ALIGN\t\t0\n#define PCH_GBE_DMA_PADDING\t\t2\n#define PCH_GBE_WATCHDOG_PERIOD\t\t(5 * HZ)\t \n#define PCH_GBE_PCI_BAR\t\t\t1\n#define PCH_GBE_RESERVE_MEMORY\t\t0x200000\t \n\n#define PCI_DEVICE_ID_INTEL_IOH1_GBE\t\t0x8802\n\n#define PCI_DEVICE_ID_ROHM_ML7223_GBE\t\t0x8013\n#define PCI_DEVICE_ID_ROHM_ML7831_GBE\t\t0x8802\n\n#define PCH_GBE_RX_BUFFER_WRITE   16\n\n \n#define PCH_GBE_WL_INIT_SETTING    (PCH_GBE_WLC_MP)\n\n#define PCH_GBE_MAC_RGMII_CTRL_SETTING ( \\\n\tPCH_GBE_CHIP_TYPE_INTERNAL | \\\n\tPCH_GBE_RGMII_MODE_RGMII     \\\n\t)\n\n \n#define PCH_GBE_MAX_RX_BUFFER_SIZE      0x2880\n#define PCH_GBE_MAX_JUMBO_FRAME_SIZE    10318\n#define PCH_GBE_FRAME_SIZE_2048         2048\n#define PCH_GBE_FRAME_SIZE_4096         4096\n#define PCH_GBE_FRAME_SIZE_8192         8192\n\n#define PCH_GBE_GET_DESC(R, i, type)    (&(((struct type *)((R).desc))[i]))\n#define PCH_GBE_RX_DESC(R, i)           PCH_GBE_GET_DESC(R, i, pch_gbe_rx_desc)\n#define PCH_GBE_TX_DESC(R, i)           PCH_GBE_GET_DESC(R, i, pch_gbe_tx_desc)\n#define PCH_GBE_DESC_UNUSED(R) \\\n\t((((R)->next_to_clean > (R)->next_to_use) ? 0 : (R)->count) + \\\n\t(R)->next_to_clean - (R)->next_to_use - 1)\n\n \n#define\tPCH_GBE_PAUSE_PKT1_VALUE    0x00C28001\n#define\tPCH_GBE_PAUSE_PKT2_VALUE    0x00000100\n#define\tPCH_GBE_PAUSE_PKT4_VALUE    0x01000888\n#define\tPCH_GBE_PAUSE_PKT5_VALUE    0x0000FFFF\n\n\n \n#define PCH_GBE_INT_ENABLE_MASK ( \\\n\tPCH_GBE_INT_RX_DMA_CMPLT |    \\\n\tPCH_GBE_INT_RX_DSC_EMP   |    \\\n\tPCH_GBE_INT_RX_FIFO_ERR  |    \\\n\tPCH_GBE_INT_WOL_DET      |    \\\n\tPCH_GBE_INT_TX_CMPLT          \\\n\t)\n\n#define PCH_GBE_INT_DISABLE_ALL\t\t0\n\n \n \n#define MASTER_MODE   (1<<0)\n#define SLAVE_MODE    (0)\n#define V2_MODE       (1<<31)\n#define CAP_MODE0     (0)\n#define CAP_MODE2     (1<<17)\n\n \n#define TX_SNAPSHOT_LOCKED (1<<0)\n#define RX_SNAPSHOT_LOCKED (1<<1)\n\n#define PTP_L4_MULTICAST_SA \"01:00:5e:00:01:81\"\n#define PTP_L2_MULTICAST_SA \"01:1b:19:00:00:00\"\n\nstatic int pch_gbe_mdio_read(struct net_device *netdev, int addr, int reg);\nstatic void pch_gbe_mdio_write(struct net_device *netdev, int addr, int reg,\n\t\t\t       int data);\nstatic void pch_gbe_set_multi(struct net_device *netdev);\n\nstatic int pch_ptp_match(struct sk_buff *skb, u16 uid_hi, u32 uid_lo, u16 seqid)\n{\n\tu8 *data = skb->data;\n\tunsigned int offset;\n\tu16 hi, id;\n\tu32 lo;\n\n\tif (ptp_classify_raw(skb) == PTP_CLASS_NONE)\n\t\treturn 0;\n\n\toffset = ETH_HLEN + IPV4_HLEN(data) + UDP_HLEN;\n\n\tif (skb->len < offset + OFF_PTP_SEQUENCE_ID + sizeof(seqid))\n\t\treturn 0;\n\n\thi = get_unaligned_be16(data + offset + OFF_PTP_SOURCE_UUID + 0);\n\tlo = get_unaligned_be32(data + offset + OFF_PTP_SOURCE_UUID + 2);\n\tid = get_unaligned_be16(data + offset + OFF_PTP_SEQUENCE_ID);\n\n\treturn (uid_hi == hi && uid_lo == lo && seqid == id);\n}\n\nstatic void\npch_rx_timestamp(struct pch_gbe_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct pci_dev *pdev;\n\tu64 ns;\n\tu32 hi, lo, val;\n\n\tif (!adapter->hwts_rx_en)\n\t\treturn;\n\n\t \n\tpdev = adapter->ptp_pdev;\n\n\tval = pch_ch_event_read(pdev);\n\n\tif (!(val & RX_SNAPSHOT_LOCKED))\n\t\treturn;\n\n\tlo = pch_src_uuid_lo_read(pdev);\n\thi = pch_src_uuid_hi_read(pdev);\n\n\tif (!pch_ptp_match(skb, hi, lo, hi >> 16))\n\t\tgoto out;\n\n\tns = pch_rx_snap_read(pdev);\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\tshhwtstamps->hwtstamp = ns_to_ktime(ns);\nout:\n\tpch_ch_event_write(pdev, RX_SNAPSHOT_LOCKED);\n}\n\nstatic void\npch_tx_timestamp(struct pch_gbe_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct pci_dev *pdev;\n\tstruct skb_shared_info *shtx;\n\tu64 ns;\n\tu32 cnt, val;\n\n\tshtx = skb_shinfo(skb);\n\tif (likely(!(shtx->tx_flags & SKBTX_HW_TSTAMP && adapter->hwts_tx_en)))\n\t\treturn;\n\n\tshtx->tx_flags |= SKBTX_IN_PROGRESS;\n\n\t \n\tpdev = adapter->ptp_pdev;\n\n\t \n\tfor (cnt = 0; cnt < 100; cnt++) {\n\t\tval = pch_ch_event_read(pdev);\n\t\tif (val & TX_SNAPSHOT_LOCKED)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (!(val & TX_SNAPSHOT_LOCKED)) {\n\t\tshtx->tx_flags &= ~SKBTX_IN_PROGRESS;\n\t\treturn;\n\t}\n\n\tns = pch_tx_snap_read(pdev);\n\n\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\tskb_tstamp_tx(skb, &shhwtstamps);\n\n\tpch_ch_event_write(pdev, TX_SNAPSHOT_LOCKED);\n}\n\nstatic int hwtstamp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct hwtstamp_config cfg;\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev;\n\tu8 station[20];\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\t \n\tpdev = adapter->ptp_pdev;\n\n\tif (cfg.tx_type != HWTSTAMP_TX_OFF && cfg.tx_type != HWTSTAMP_TX_ON)\n\t\treturn -ERANGE;\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tadapter->hwts_rx_en = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\tadapter->hwts_rx_en = 0;\n\t\tpch_ch_control_write(pdev, SLAVE_MODE | CAP_MODE0);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tadapter->hwts_rx_en = 1;\n\t\tpch_ch_control_write(pdev, MASTER_MODE | CAP_MODE0);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\tadapter->hwts_rx_en = 1;\n\t\tpch_ch_control_write(pdev, V2_MODE | CAP_MODE2);\n\t\tstrcpy(station, PTP_L4_MULTICAST_SA);\n\t\tpch_set_station_address(station, pdev);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\tadapter->hwts_rx_en = 1;\n\t\tpch_ch_control_write(pdev, V2_MODE | CAP_MODE2);\n\t\tstrcpy(station, PTP_L2_MULTICAST_SA);\n\t\tpch_set_station_address(station, pdev);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tadapter->hwts_tx_en = cfg.tx_type == HWTSTAMP_TX_ON;\n\n\t \n\tpch_ch_event_write(pdev, TX_SNAPSHOT_LOCKED | RX_SNAPSHOT_LOCKED);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic inline void pch_gbe_mac_load_mac_addr(struct pch_gbe_hw *hw)\n{\n\tiowrite32(0x01, &hw->reg->MAC_ADDR_LOAD);\n}\n\n \nstatic s32 pch_gbe_mac_read_mac_addr(struct pch_gbe_hw *hw)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tu32  adr1a, adr1b;\n\n\tadr1a = ioread32(&hw->reg->mac_adr[0].high);\n\tadr1b = ioread32(&hw->reg->mac_adr[0].low);\n\n\thw->mac.addr[0] = (u8)(adr1a & 0xFF);\n\thw->mac.addr[1] = (u8)((adr1a >> 8) & 0xFF);\n\thw->mac.addr[2] = (u8)((adr1a >> 16) & 0xFF);\n\thw->mac.addr[3] = (u8)((adr1a >> 24) & 0xFF);\n\thw->mac.addr[4] = (u8)(adr1b & 0xFF);\n\thw->mac.addr[5] = (u8)((adr1b >> 8) & 0xFF);\n\n\tnetdev_dbg(adapter->netdev, \"hw->mac.addr : %pM\\n\", hw->mac.addr);\n\treturn 0;\n}\n\n \nstatic void pch_gbe_wait_clr_bit(void __iomem *reg, u32 bit)\n{\n\tu32 tmp;\n\n\t \n\tif (readx_poll_timeout_atomic(ioread32, reg, tmp, !(tmp & bit), 0, 10))\n\t\tpr_err(\"Error: busy bit is not cleared\\n\");\n}\n\n \nstatic void pch_gbe_mac_mar_set(struct pch_gbe_hw *hw, u8 * addr, u32 index)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tu32 mar_low, mar_high, adrmask;\n\n\tnetdev_dbg(adapter->netdev, \"index : 0x%x\\n\", index);\n\n\t \n\tmar_high = ((u32) addr[0] | ((u32) addr[1] << 8) |\n\t\t   ((u32) addr[2] << 16) | ((u32) addr[3] << 24));\n\tmar_low = ((u32) addr[4] | ((u32) addr[5] << 8));\n\t \n\tadrmask = ioread32(&hw->reg->ADDR_MASK);\n\tiowrite32((adrmask | (0x0001 << index)), &hw->reg->ADDR_MASK);\n\t \n\tpch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\n\t \n\tiowrite32(mar_high, &hw->reg->mac_adr[index].high);\n\tiowrite32(mar_low, &hw->reg->mac_adr[index].low);\n\t \n\tiowrite32((adrmask & ~(0x0001 << index)), &hw->reg->ADDR_MASK);\n\t \n\tpch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\n}\n\n \nstatic void pch_gbe_mac_reset_hw(struct pch_gbe_hw *hw)\n{\n\t \n\tpch_gbe_mac_read_mac_addr(hw);\n\tiowrite32(PCH_GBE_ALL_RST, &hw->reg->RESET);\n\tiowrite32(PCH_GBE_MODE_GMII_ETHER, &hw->reg->MODE);\n\tpch_gbe_wait_clr_bit(&hw->reg->RESET, PCH_GBE_ALL_RST);\n\t \n\tpch_gbe_mac_mar_set(hw, hw->mac.addr, 0);\n\treturn;\n}\n\nstatic void pch_gbe_disable_mac_rx(struct pch_gbe_hw *hw)\n{\n\tu32 rctl;\n\t \n\trctl = ioread32(&hw->reg->MAC_RX_EN);\n\tiowrite32((rctl & ~PCH_GBE_MRE_MAC_RX_EN), &hw->reg->MAC_RX_EN);\n}\n\nstatic void pch_gbe_enable_mac_rx(struct pch_gbe_hw *hw)\n{\n\tu32 rctl;\n\t \n\trctl = ioread32(&hw->reg->MAC_RX_EN);\n\tiowrite32((rctl | PCH_GBE_MRE_MAC_RX_EN), &hw->reg->MAC_RX_EN);\n}\n\n \nstatic void pch_gbe_mac_init_rx_addrs(struct pch_gbe_hw *hw, u16 mar_count)\n{\n\tu32 i;\n\n\t \n\tpch_gbe_mac_mar_set(hw, hw->mac.addr, 0);\n\n\t \n\tfor (i = 1; i < mar_count; i++) {\n\t\tiowrite32(0, &hw->reg->mac_adr[i].high);\n\t\tiowrite32(0, &hw->reg->mac_adr[i].low);\n\t}\n\tiowrite32(0xFFFE, &hw->reg->ADDR_MASK);\n\t \n\tpch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\n}\n\n \ns32 pch_gbe_mac_force_mac_fc(struct pch_gbe_hw *hw)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tstruct pch_gbe_mac_info *mac = &hw->mac;\n\tu32 rx_fctrl;\n\n\tnetdev_dbg(adapter->netdev, \"mac->fc = %u\\n\", mac->fc);\n\n\trx_fctrl = ioread32(&hw->reg->RX_FCTRL);\n\n\tswitch (mac->fc) {\n\tcase PCH_GBE_FC_NONE:\n\t\trx_fctrl &= ~PCH_GBE_FL_CTRL_EN;\n\t\tmac->tx_fc_enable = false;\n\t\tbreak;\n\tcase PCH_GBE_FC_RX_PAUSE:\n\t\trx_fctrl |= PCH_GBE_FL_CTRL_EN;\n\t\tmac->tx_fc_enable = false;\n\t\tbreak;\n\tcase PCH_GBE_FC_TX_PAUSE:\n\t\trx_fctrl &= ~PCH_GBE_FL_CTRL_EN;\n\t\tmac->tx_fc_enable = true;\n\t\tbreak;\n\tcase PCH_GBE_FC_FULL:\n\t\trx_fctrl |= PCH_GBE_FL_CTRL_EN;\n\t\tmac->tx_fc_enable = true;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Flow control param set incorrectly\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (mac->link_duplex == DUPLEX_HALF)\n\t\trx_fctrl &= ~PCH_GBE_FL_CTRL_EN;\n\tiowrite32(rx_fctrl, &hw->reg->RX_FCTRL);\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"RX_FCTRL reg : 0x%08x  mac->tx_fc_enable : %d\\n\",\n\t\t   ioread32(&hw->reg->RX_FCTRL), mac->tx_fc_enable);\n\treturn 0;\n}\n\n \nstatic void pch_gbe_mac_set_wol_event(struct pch_gbe_hw *hw, u32 wu_evt)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tu32 addr_mask;\n\n\tnetdev_dbg(adapter->netdev, \"wu_evt : 0x%08x  ADDR_MASK reg : 0x%08x\\n\",\n\t\t   wu_evt, ioread32(&hw->reg->ADDR_MASK));\n\n\tif (wu_evt) {\n\t\t \n\t\taddr_mask = ioread32(&hw->reg->ADDR_MASK);\n\t\tiowrite32(addr_mask, &hw->reg->WOL_ADDR_MASK);\n\t\t \n\t\tpch_gbe_wait_clr_bit(&hw->reg->WOL_ADDR_MASK, PCH_GBE_WLA_BUSY);\n\t\tiowrite32(0, &hw->reg->WOL_ST);\n\t\tiowrite32((wu_evt | PCH_GBE_WLC_WOL_MODE), &hw->reg->WOL_CTRL);\n\t\tiowrite32(0x02, &hw->reg->TCPIP_ACC);\n\t\tiowrite32(PCH_GBE_INT_ENABLE_MASK, &hw->reg->INT_EN);\n\t} else {\n\t\tiowrite32(0, &hw->reg->WOL_CTRL);\n\t\tiowrite32(0, &hw->reg->WOL_ST);\n\t}\n\treturn;\n}\n\n \nu16 pch_gbe_mac_ctrl_miim(struct pch_gbe_hw *hw, u32 addr, u32 dir, u32 reg,\n\t\t\tu16 data)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tunsigned long flags;\n\tu32 data_out;\n\n\tspin_lock_irqsave(&hw->miim_lock, flags);\n\n\tif (readx_poll_timeout_atomic(ioread32, &hw->reg->MIIM, data_out,\n\t\t\t\t      data_out & PCH_GBE_MIIM_OPER_READY, 20, 2000)) {\n\t\tnetdev_err(adapter->netdev, \"pch-gbe.miim won't go Ready\\n\");\n\t\tspin_unlock_irqrestore(&hw->miim_lock, flags);\n\t\treturn 0;\t \n\t}\n\tiowrite32(((reg << PCH_GBE_MIIM_REG_ADDR_SHIFT) |\n\t\t  (addr << PCH_GBE_MIIM_PHY_ADDR_SHIFT) |\n\t\t  dir | data), &hw->reg->MIIM);\n\treadx_poll_timeout_atomic(ioread32, &hw->reg->MIIM, data_out,\n\t\t\t\t  data_out & PCH_GBE_MIIM_OPER_READY, 20, 2000);\n\tspin_unlock_irqrestore(&hw->miim_lock, flags);\n\n\tnetdev_dbg(adapter->netdev, \"PHY %s: reg=%d, data=0x%04X\\n\",\n\t\t   dir == PCH_GBE_MIIM_OPER_READ ? \"READ\" : \"WRITE\", reg,\n\t\t   dir == PCH_GBE_MIIM_OPER_READ ? data_out : data);\n\treturn (u16) data_out;\n}\n\n \nstatic void pch_gbe_mac_set_pause_packet(struct pch_gbe_hw *hw)\n{\n\tstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\n\tunsigned long tmp2, tmp3;\n\n\t \n\ttmp2 = hw->mac.addr[1];\n\ttmp2 = (tmp2 << 8) | hw->mac.addr[0];\n\ttmp2 = PCH_GBE_PAUSE_PKT2_VALUE | (tmp2 << 16);\n\n\ttmp3 = hw->mac.addr[5];\n\ttmp3 = (tmp3 << 8) | hw->mac.addr[4];\n\ttmp3 = (tmp3 << 8) | hw->mac.addr[3];\n\ttmp3 = (tmp3 << 8) | hw->mac.addr[2];\n\n\tiowrite32(PCH_GBE_PAUSE_PKT1_VALUE, &hw->reg->PAUSE_PKT1);\n\tiowrite32(tmp2, &hw->reg->PAUSE_PKT2);\n\tiowrite32(tmp3, &hw->reg->PAUSE_PKT3);\n\tiowrite32(PCH_GBE_PAUSE_PKT4_VALUE, &hw->reg->PAUSE_PKT4);\n\tiowrite32(PCH_GBE_PAUSE_PKT5_VALUE, &hw->reg->PAUSE_PKT5);\n\n\t \n\tiowrite32(PCH_GBE_PS_PKT_RQ, &hw->reg->PAUSE_REQ);\n\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"PAUSE_PKT1-5 reg : 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   ioread32(&hw->reg->PAUSE_PKT1),\n\t\t   ioread32(&hw->reg->PAUSE_PKT2),\n\t\t   ioread32(&hw->reg->PAUSE_PKT3),\n\t\t   ioread32(&hw->reg->PAUSE_PKT4),\n\t\t   ioread32(&hw->reg->PAUSE_PKT5));\n\n\treturn;\n}\n\n\n \nstatic int pch_gbe_alloc_queues(struct pch_gbe_adapter *adapter)\n{\n\tadapter->tx_ring = devm_kzalloc(&adapter->pdev->dev,\n\t\t\t\t\tsizeof(*adapter->tx_ring), GFP_KERNEL);\n\tif (!adapter->tx_ring)\n\t\treturn -ENOMEM;\n\n\tadapter->rx_ring = devm_kzalloc(&adapter->pdev->dev,\n\t\t\t\t\tsizeof(*adapter->rx_ring), GFP_KERNEL);\n\tif (!adapter->rx_ring)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic void pch_gbe_init_stats(struct pch_gbe_adapter *adapter)\n{\n\tmemset(&adapter->stats, 0, sizeof(adapter->stats));\n\treturn;\n}\n\n \nstatic int pch_gbe_init_phy(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 addr;\n\tu16 bmcr, stat;\n\n\t \n\tfor (addr = 0; addr < PCH_GBE_PHY_REGS_LEN; addr++) {\n\t\tadapter->mii.phy_id = (addr == 0) ? 1 : (addr == 1) ? 0 : addr;\n\t\tbmcr = pch_gbe_mdio_read(netdev, adapter->mii.phy_id, MII_BMCR);\n\t\tstat = pch_gbe_mdio_read(netdev, adapter->mii.phy_id, MII_BMSR);\n\t\tstat = pch_gbe_mdio_read(netdev, adapter->mii.phy_id, MII_BMSR);\n\t\tif (!((bmcr == 0xFFFF) || ((stat == 0) && (bmcr == 0))))\n\t\t\tbreak;\n\t}\n\tadapter->hw.phy.addr = adapter->mii.phy_id;\n\tnetdev_dbg(netdev, \"phy_addr = %d\\n\", adapter->mii.phy_id);\n\tif (addr == PCH_GBE_PHY_REGS_LEN)\n\t\treturn -EAGAIN;\n\t \n\tfor (addr = 0; addr < PCH_GBE_PHY_REGS_LEN; addr++) {\n\t\tif (addr != adapter->mii.phy_id) {\n\t\t\tpch_gbe_mdio_write(netdev, addr, MII_BMCR,\n\t\t\t\t\t   BMCR_ISOLATE);\n\t\t} else {\n\t\t\tbmcr = pch_gbe_mdio_read(netdev, addr, MII_BMCR);\n\t\t\tpch_gbe_mdio_write(netdev, addr, MII_BMCR,\n\t\t\t\t\t   bmcr & ~BMCR_ISOLATE);\n\t\t}\n\t}\n\n\t \n\tadapter->mii.phy_id_mask = 0x1F;\n\tadapter->mii.reg_num_mask = 0x1F;\n\tadapter->mii.dev = adapter->netdev;\n\tadapter->mii.mdio_read = pch_gbe_mdio_read;\n\tadapter->mii.mdio_write = pch_gbe_mdio_write;\n\tadapter->mii.supports_gmii = mii_check_gmii_support(&adapter->mii);\n\treturn 0;\n}\n\n \nstatic int pch_gbe_mdio_read(struct net_device *netdev, int addr, int reg)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\treturn pch_gbe_mac_ctrl_miim(hw, addr, PCH_GBE_HAL_MIIM_READ, reg,\n\t\t\t\t     (u16) 0);\n}\n\n \nstatic void pch_gbe_mdio_write(struct net_device *netdev,\n\t\t\t       int addr, int reg, int data)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tpch_gbe_mac_ctrl_miim(hw, addr, PCH_GBE_HAL_MIIM_WRITE, reg, data);\n}\n\n \nstatic void pch_gbe_reset_task(struct work_struct *work)\n{\n\tstruct pch_gbe_adapter *adapter;\n\tadapter = container_of(work, struct pch_gbe_adapter, reset_task);\n\n\trtnl_lock();\n\tpch_gbe_reinit_locked(adapter);\n\trtnl_unlock();\n}\n\n \nvoid pch_gbe_reinit_locked(struct pch_gbe_adapter *adapter)\n{\n\tpch_gbe_down(adapter);\n\tpch_gbe_up(adapter);\n}\n\n \nvoid pch_gbe_reset(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\ts32 ret_val;\n\n\tpch_gbe_mac_reset_hw(hw);\n\t \n\tpch_gbe_set_multi(netdev);\n\t \n\tpch_gbe_mac_init_rx_addrs(hw, PCH_GBE_MAR_ENTRIES);\n\n\tret_val = pch_gbe_phy_get_id(hw);\n\tif (ret_val) {\n\t\tnetdev_err(adapter->netdev, \"pch_gbe_phy_get_id error\\n\");\n\t\treturn;\n\t}\n\tpch_gbe_phy_init_setting(hw);\n\t \n\tpch_gbe_phy_set_rgmii(hw);\n}\n\n \nstatic void pch_gbe_free_irq(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tfree_irq(adapter->irq, netdev);\n\tpci_free_irq_vectors(adapter->pdev);\n}\n\n \nstatic void pch_gbe_irq_disable(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tatomic_inc(&adapter->irq_sem);\n\tiowrite32(0, &hw->reg->INT_EN);\n\tioread32(&hw->reg->INT_ST);\n\tsynchronize_irq(adapter->irq);\n\n\tnetdev_dbg(adapter->netdev, \"INT_EN reg : 0x%08x\\n\",\n\t\t   ioread32(&hw->reg->INT_EN));\n}\n\n \nstatic void pch_gbe_irq_enable(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tif (likely(atomic_dec_and_test(&adapter->irq_sem)))\n\t\tiowrite32(PCH_GBE_INT_ENABLE_MASK, &hw->reg->INT_EN);\n\tioread32(&hw->reg->INT_ST);\n\tnetdev_dbg(adapter->netdev, \"INT_EN reg : 0x%08x\\n\",\n\t\t   ioread32(&hw->reg->INT_EN));\n}\n\n\n\n \nstatic void pch_gbe_setup_tctl(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 tx_mode, tcpip;\n\n\ttx_mode = PCH_GBE_TM_LONG_PKT |\n\t\tPCH_GBE_TM_ST_AND_FD |\n\t\tPCH_GBE_TM_SHORT_PKT |\n\t\tPCH_GBE_TM_TH_TX_STRT_8 |\n\t\tPCH_GBE_TM_TH_ALM_EMP_4 | PCH_GBE_TM_TH_ALM_FULL_8;\n\n\tiowrite32(tx_mode, &hw->reg->TX_MODE);\n\n\ttcpip = ioread32(&hw->reg->TCPIP_ACC);\n\ttcpip |= PCH_GBE_TX_TCPIPACC_EN;\n\tiowrite32(tcpip, &hw->reg->TCPIP_ACC);\n\treturn;\n}\n\n \nstatic void pch_gbe_configure_tx(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 tdba, tdlen, dctrl;\n\n\tnetdev_dbg(adapter->netdev, \"dma addr = 0x%08llx  size = 0x%08x\\n\",\n\t\t   (unsigned long long)adapter->tx_ring->dma,\n\t\t   adapter->tx_ring->size);\n\n\t \n\ttdba = adapter->tx_ring->dma;\n\ttdlen = adapter->tx_ring->size - 0x10;\n\tiowrite32(tdba, &hw->reg->TX_DSC_BASE);\n\tiowrite32(tdlen, &hw->reg->TX_DSC_SIZE);\n\tiowrite32(tdba, &hw->reg->TX_DSC_SW_P);\n\n\t \n\tdctrl = ioread32(&hw->reg->DMA_CTRL);\n\tdctrl |= PCH_GBE_TX_DMA_EN;\n\tiowrite32(dctrl, &hw->reg->DMA_CTRL);\n}\n\n \nstatic void pch_gbe_setup_rctl(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 rx_mode, tcpip;\n\n\trx_mode = PCH_GBE_ADD_FIL_EN | PCH_GBE_MLT_FIL_EN |\n\tPCH_GBE_RH_ALM_EMP_4 | PCH_GBE_RH_ALM_FULL_4 | PCH_GBE_RH_RD_TRG_8;\n\n\tiowrite32(rx_mode, &hw->reg->RX_MODE);\n\n\ttcpip = ioread32(&hw->reg->TCPIP_ACC);\n\n\ttcpip |= PCH_GBE_RX_TCPIPACC_OFF;\n\ttcpip &= ~PCH_GBE_RX_TCPIPACC_EN;\n\tiowrite32(tcpip, &hw->reg->TCPIP_ACC);\n\treturn;\n}\n\n \nstatic void pch_gbe_configure_rx(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 rdba, rdlen, rxdma;\n\n\tnetdev_dbg(adapter->netdev, \"dma adr = 0x%08llx  size = 0x%08x\\n\",\n\t\t   (unsigned long long)adapter->rx_ring->dma,\n\t\t   adapter->rx_ring->size);\n\n\tpch_gbe_mac_force_mac_fc(hw);\n\n\tpch_gbe_disable_mac_rx(hw);\n\n\t \n\trxdma = ioread32(&hw->reg->DMA_CTRL);\n\trxdma &= ~PCH_GBE_RX_DMA_EN;\n\tiowrite32(rxdma, &hw->reg->DMA_CTRL);\n\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"MAC_RX_EN reg = 0x%08x  DMA_CTRL reg = 0x%08x\\n\",\n\t\t   ioread32(&hw->reg->MAC_RX_EN),\n\t\t   ioread32(&hw->reg->DMA_CTRL));\n\n\t \n\trdba = adapter->rx_ring->dma;\n\trdlen = adapter->rx_ring->size - 0x10;\n\tiowrite32(rdba, &hw->reg->RX_DSC_BASE);\n\tiowrite32(rdlen, &hw->reg->RX_DSC_SIZE);\n\tiowrite32((rdba + rdlen), &hw->reg->RX_DSC_SW_P);\n}\n\n \nstatic void pch_gbe_unmap_and_free_tx_resource(\n\tstruct pch_gbe_adapter *adapter, struct pch_gbe_buffer *buffer_info)\n{\n\tif (buffer_info->mapped) {\n\t\tdma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t buffer_info->length, DMA_TO_DEVICE);\n\t\tbuffer_info->mapped = false;\n\t}\n\tif (buffer_info->skb) {\n\t\tdev_kfree_skb_any(buffer_info->skb);\n\t\tbuffer_info->skb = NULL;\n\t}\n}\n\n \nstatic void pch_gbe_unmap_and_free_rx_resource(\n\t\t\t\t\tstruct pch_gbe_adapter *adapter,\n\t\t\t\t\tstruct pch_gbe_buffer *buffer_info)\n{\n\tif (buffer_info->mapped) {\n\t\tdma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t buffer_info->length, DMA_FROM_DEVICE);\n\t\tbuffer_info->mapped = false;\n\t}\n\tif (buffer_info->skb) {\n\t\tdev_kfree_skb_any(buffer_info->skb);\n\t\tbuffer_info->skb = NULL;\n\t}\n}\n\n \nstatic void pch_gbe_clean_tx_ring(struct pch_gbe_adapter *adapter,\n\t\t\t\t   struct pch_gbe_tx_ring *tx_ring)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct pch_gbe_buffer *buffer_info;\n\tunsigned long size;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tpch_gbe_unmap_and_free_tx_resource(adapter, buffer_info);\n\t}\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"call pch_gbe_unmap_and_free_tx_resource() %d count\\n\", i);\n\n\tsize = (unsigned long)sizeof(struct pch_gbe_buffer) * tx_ring->count;\n\tmemset(tx_ring->buffer_info, 0, size);\n\n\t \n\tmemset(tx_ring->desc, 0, tx_ring->size);\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\tiowrite32(tx_ring->dma, &hw->reg->TX_DSC_HW_P);\n\tiowrite32((tx_ring->size - 0x10), &hw->reg->TX_DSC_SIZE);\n}\n\n \nstatic void\npch_gbe_clean_rx_ring(struct pch_gbe_adapter *adapter,\n\t\t      struct pch_gbe_rx_ring *rx_ring)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct pch_gbe_buffer *buffer_info;\n\tunsigned long size;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tpch_gbe_unmap_and_free_rx_resource(adapter, buffer_info);\n\t}\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"call pch_gbe_unmap_and_free_rx_resource() %d count\\n\", i);\n\tsize = (unsigned long)sizeof(struct pch_gbe_buffer) * rx_ring->count;\n\tmemset(rx_ring->buffer_info, 0, size);\n\n\t \n\tmemset(rx_ring->desc, 0, rx_ring->size);\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\tiowrite32(rx_ring->dma, &hw->reg->RX_DSC_HW_P);\n\tiowrite32((rx_ring->size - 0x10), &hw->reg->RX_DSC_SIZE);\n}\n\nstatic void pch_gbe_set_rgmii_ctrl(struct pch_gbe_adapter *adapter, u16 speed,\n\t\t\t\t    u16 duplex)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tunsigned long rgmii = 0;\n\n\t \n\tswitch (speed) {\n\tcase SPEED_10:\n\t\trgmii = (PCH_GBE_RGMII_RATE_2_5M |\n\t\t\t PCH_GBE_MAC_RGMII_CTRL_SETTING);\n\t\tbreak;\n\tcase SPEED_100:\n\t\trgmii = (PCH_GBE_RGMII_RATE_25M |\n\t\t\t PCH_GBE_MAC_RGMII_CTRL_SETTING);\n\t\tbreak;\n\tcase SPEED_1000:\n\t\trgmii = (PCH_GBE_RGMII_RATE_125M |\n\t\t\t PCH_GBE_MAC_RGMII_CTRL_SETTING);\n\t\tbreak;\n\t}\n\tiowrite32(rgmii, &hw->reg->RGMII_CTRL);\n}\nstatic void pch_gbe_set_mode(struct pch_gbe_adapter *adapter, u16 speed,\n\t\t\t      u16 duplex)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tunsigned long mode = 0;\n\n\t \n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tmode = PCH_GBE_MODE_MII_ETHER;\n\t\tnetdev->tx_queue_len = 10;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tmode = PCH_GBE_MODE_MII_ETHER;\n\t\tnetdev->tx_queue_len = 100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tmode = PCH_GBE_MODE_GMII_ETHER;\n\t\tbreak;\n\t}\n\tif (duplex == DUPLEX_FULL)\n\t\tmode |= PCH_GBE_MODE_FULL_DUPLEX;\n\telse\n\t\tmode |= PCH_GBE_MODE_HALF_DUPLEX;\n\tiowrite32(mode, &hw->reg->MODE);\n}\n\n \nstatic void pch_gbe_watchdog(struct timer_list *t)\n{\n\tstruct pch_gbe_adapter *adapter = from_timer(adapter, t,\n\t\t\t\t\t\t     watchdog_timer);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tnetdev_dbg(netdev, \"right now = %ld\\n\", jiffies);\n\n\tpch_gbe_update_stats(adapter);\n\tif ((mii_link_ok(&adapter->mii)) && (!netif_carrier_ok(netdev))) {\n\t\tstruct ethtool_cmd cmd = { .cmd = ETHTOOL_GSET };\n\t\tnetdev->tx_queue_len = adapter->tx_queue_len;\n\t\t \n\t\tmii_ethtool_gset(&adapter->mii, &cmd);\n\t\thw->mac.link_speed = ethtool_cmd_speed(&cmd);\n\t\thw->mac.link_duplex = cmd.duplex;\n\t\t \n\t\tpch_gbe_set_rgmii_ctrl(adapter, hw->mac.link_speed,\n\t\t\t\t\t\thw->mac.link_duplex);\n\t\t \n\t\tpch_gbe_set_mode(adapter, hw->mac.link_speed,\n\t\t\t\t hw->mac.link_duplex);\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"Link is Up %d Mbps %s-Duplex\\n\",\n\t\t\t   hw->mac.link_speed,\n\t\t\t   cmd.duplex == DUPLEX_FULL ? \"Full\" : \"Half\");\n\t\tnetif_carrier_on(netdev);\n\t\tnetif_wake_queue(netdev);\n\t} else if ((!mii_link_ok(&adapter->mii)) &&\n\t\t   (netif_carrier_ok(netdev))) {\n\t\tnetdev_dbg(netdev, \"NIC Link is Down\\n\");\n\t\thw->mac.link_speed = SPEED_10;\n\t\thw->mac.link_duplex = DUPLEX_HALF;\n\t\tnetif_carrier_off(netdev);\n\t\tnetif_stop_queue(netdev);\n\t}\n\tmod_timer(&adapter->watchdog_timer,\n\t\t  round_jiffies(jiffies + PCH_GBE_WATCHDOG_PERIOD));\n}\n\n \nstatic void pch_gbe_tx_queue(struct pch_gbe_adapter *adapter,\n\t\t\t      struct pch_gbe_tx_ring *tx_ring,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct pch_gbe_tx_desc *tx_desc;\n\tstruct pch_gbe_buffer *buffer_info;\n\tstruct sk_buff *tmp_skb;\n\tunsigned int frame_ctrl;\n\tunsigned int ring_num;\n\n\t \n\tframe_ctrl = 0;\n\tif (unlikely(skb->len < PCH_GBE_SHORT_PKT))\n\t\tframe_ctrl |= PCH_GBE_TXD_CTRL_APAD;\n\tif (skb->ip_summed == CHECKSUM_NONE)\n\t\tframe_ctrl |= PCH_GBE_TXD_CTRL_TCPIP_ACC_OFF;\n\n\t \n\t \n\tif (skb->len < PCH_GBE_SHORT_PKT && skb->ip_summed != CHECKSUM_NONE) {\n\t\tframe_ctrl |= PCH_GBE_TXD_CTRL_APAD |\n\t\t\t      PCH_GBE_TXD_CTRL_TCPIP_ACC_OFF;\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\t\tunsigned int offset;\n\t\t\toffset = skb_transport_offset(skb);\n\t\t\tif (iph->protocol == IPPROTO_TCP) {\n\t\t\t\tskb->csum = 0;\n\t\t\t\ttcp_hdr(skb)->check = 0;\n\t\t\t\tskb->csum = skb_checksum(skb, offset,\n\t\t\t\t\t\t\t skb->len - offset, 0);\n\t\t\t\ttcp_hdr(skb)->check =\n\t\t\t\t\tcsum_tcpudp_magic(iph->saddr,\n\t\t\t\t\t\t\t  iph->daddr,\n\t\t\t\t\t\t\t  skb->len - offset,\n\t\t\t\t\t\t\t  IPPROTO_TCP,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t} else if (iph->protocol == IPPROTO_UDP) {\n\t\t\t\tskb->csum = 0;\n\t\t\t\tudp_hdr(skb)->check = 0;\n\t\t\t\tskb->csum =\n\t\t\t\t\tskb_checksum(skb, offset,\n\t\t\t\t\t\t     skb->len - offset, 0);\n\t\t\t\tudp_hdr(skb)->check =\n\t\t\t\t\tcsum_tcpudp_magic(iph->saddr,\n\t\t\t\t\t\t\t  iph->daddr,\n\t\t\t\t\t\t\t  skb->len - offset,\n\t\t\t\t\t\t\t  IPPROTO_UDP,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t}\n\t\t}\n\t}\n\n\tring_num = tx_ring->next_to_use;\n\tif (unlikely((ring_num + 1) == tx_ring->count))\n\t\ttx_ring->next_to_use = 0;\n\telse\n\t\ttx_ring->next_to_use = ring_num + 1;\n\n\n\tbuffer_info = &tx_ring->buffer_info[ring_num];\n\ttmp_skb = buffer_info->skb;\n\n\t \n\tmemcpy(tmp_skb->data, skb->data, ETH_HLEN);\n\ttmp_skb->data[ETH_HLEN] = 0x00;\n\ttmp_skb->data[ETH_HLEN + 1] = 0x00;\n\ttmp_skb->len = skb->len;\n\tmemcpy(&tmp_skb->data[ETH_HLEN + 2], &skb->data[ETH_HLEN],\n\t       (skb->len - ETH_HLEN));\n\t \n\tbuffer_info->length = tmp_skb->len;\n\tbuffer_info->dma = dma_map_single(&adapter->pdev->dev, tmp_skb->data,\n\t\t\t\t\t  buffer_info->length,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {\n\t\tnetdev_err(adapter->netdev, \"TX DMA map failed\\n\");\n\t\tbuffer_info->dma = 0;\n\t\tbuffer_info->time_stamp = 0;\n\t\ttx_ring->next_to_use = ring_num;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\tbuffer_info->mapped = true;\n\tbuffer_info->time_stamp = jiffies;\n\n\t \n\ttx_desc = PCH_GBE_TX_DESC(*tx_ring, ring_num);\n\ttx_desc->buffer_addr = (buffer_info->dma);\n\ttx_desc->length = (tmp_skb->len);\n\ttx_desc->tx_words_eob = ((tmp_skb->len + 3));\n\ttx_desc->tx_frame_ctrl = (frame_ctrl);\n\ttx_desc->gbec_status = (DSC_INIT16);\n\n\tif (unlikely(++ring_num == tx_ring->count))\n\t\tring_num = 0;\n\n\t \n\tiowrite32(tx_ring->dma +\n\t\t  (int)sizeof(struct pch_gbe_tx_desc) * ring_num,\n\t\t  &hw->reg->TX_DSC_SW_P);\n\n\tpch_tx_timestamp(adapter, skb);\n\n\tdev_kfree_skb_any(skb);\n}\n\n \nvoid pch_gbe_update_stats(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_hw_stats *stats = &adapter->stats;\n\tunsigned long flags;\n\n\t \n\tif ((pdev->error_state) && (pdev->error_state != pci_channel_io_normal))\n\t\treturn;\n\n\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\n\t \n\tstats->rx_errors = stats->rx_crc_errors + stats->rx_frame_errors;\n\tstats->tx_errors = stats->tx_length_errors +\n\t    stats->tx_aborted_errors +\n\t    stats->tx_carrier_errors + stats->tx_timeout_count;\n\n\t \n\tnetdev->stats.rx_packets = stats->rx_packets;\n\tnetdev->stats.rx_bytes = stats->rx_bytes;\n\tnetdev->stats.rx_dropped = stats->rx_dropped;\n\tnetdev->stats.tx_packets = stats->tx_packets;\n\tnetdev->stats.tx_bytes = stats->tx_bytes;\n\tnetdev->stats.tx_dropped = stats->tx_dropped;\n\t \n\tnetdev->stats.multicast = stats->multicast;\n\tnetdev->stats.collisions = stats->collisions;\n\t \n\tnetdev->stats.rx_errors = stats->rx_errors;\n\tnetdev->stats.rx_crc_errors = stats->rx_crc_errors;\n\tnetdev->stats.rx_frame_errors = stats->rx_frame_errors;\n\t \n\tnetdev->stats.tx_errors = stats->tx_errors;\n\tnetdev->stats.tx_aborted_errors = stats->tx_aborted_errors;\n\tnetdev->stats.tx_carrier_errors = stats->tx_carrier_errors;\n\n\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n}\n\nstatic void pch_gbe_disable_dma_rx(struct pch_gbe_hw *hw)\n{\n\tu32 rxdma;\n\n\t \n\trxdma = ioread32(&hw->reg->DMA_CTRL);\n\trxdma &= ~PCH_GBE_RX_DMA_EN;\n\tiowrite32(rxdma, &hw->reg->DMA_CTRL);\n}\n\nstatic void pch_gbe_enable_dma_rx(struct pch_gbe_hw *hw)\n{\n\tu32 rxdma;\n\n\t \n\trxdma = ioread32(&hw->reg->DMA_CTRL);\n\trxdma |= PCH_GBE_RX_DMA_EN;\n\tiowrite32(rxdma, &hw->reg->DMA_CTRL);\n}\n\n \nstatic irqreturn_t pch_gbe_intr(int irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 int_st;\n\tu32 int_en;\n\n\t \n\tint_st = ioread32(&hw->reg->INT_ST);\n\tint_st = int_st & ioread32(&hw->reg->INT_EN);\n\t \n\tif (unlikely(!int_st))\n\t\treturn IRQ_NONE;\t \n\tnetdev_dbg(netdev, \"%s occur int_st = 0x%08x\\n\", __func__, int_st);\n\tif (int_st & PCH_GBE_INT_RX_FRAME_ERR)\n\t\tadapter->stats.intr_rx_frame_err_count++;\n\tif (int_st & PCH_GBE_INT_RX_FIFO_ERR)\n\t\tif (!adapter->rx_stop_flag) {\n\t\t\tadapter->stats.intr_rx_fifo_err_count++;\n\t\t\tnetdev_dbg(netdev, \"Rx fifo over run\\n\");\n\t\t\tadapter->rx_stop_flag = true;\n\t\t\tint_en = ioread32(&hw->reg->INT_EN);\n\t\t\tiowrite32((int_en & ~PCH_GBE_INT_RX_FIFO_ERR),\n\t\t\t\t  &hw->reg->INT_EN);\n\t\t\tpch_gbe_disable_dma_rx(&adapter->hw);\n\t\t\tint_st |= ioread32(&hw->reg->INT_ST);\n\t\t\tint_st = int_st & ioread32(&hw->reg->INT_EN);\n\t\t}\n\tif (int_st & PCH_GBE_INT_RX_DMA_ERR)\n\t\tadapter->stats.intr_rx_dma_err_count++;\n\tif (int_st & PCH_GBE_INT_TX_FIFO_ERR)\n\t\tadapter->stats.intr_tx_fifo_err_count++;\n\tif (int_st & PCH_GBE_INT_TX_DMA_ERR)\n\t\tadapter->stats.intr_tx_dma_err_count++;\n\tif (int_st & PCH_GBE_INT_TCPIP_ERR)\n\t\tadapter->stats.intr_tcpip_err_count++;\n\t \n\tif ((int_st & PCH_GBE_INT_RX_DSC_EMP)) {\n\t\tadapter->stats.intr_rx_dsc_empty_count++;\n\t\tnetdev_dbg(netdev, \"Rx descriptor is empty\\n\");\n\t\tint_en = ioread32(&hw->reg->INT_EN);\n\t\tiowrite32((int_en & ~PCH_GBE_INT_RX_DSC_EMP), &hw->reg->INT_EN);\n\t\tif (hw->mac.tx_fc_enable) {\n\t\t\t \n\t\t\tpch_gbe_mac_set_pause_packet(hw);\n\t\t}\n\t}\n\n\t \n\tif ((int_st & (PCH_GBE_INT_RX_DMA_CMPLT | PCH_GBE_INT_TX_CMPLT)) ||\n\t    (adapter->rx_stop_flag)) {\n\t\tif (likely(napi_schedule_prep(&adapter->napi))) {\n\t\t\t \n\t\t\tatomic_inc(&adapter->irq_sem);\n\t\t\tint_en = ioread32(&hw->reg->INT_EN);\n\t\t\tint_en &=\n\t\t\t    ~(PCH_GBE_INT_RX_DMA_CMPLT | PCH_GBE_INT_TX_CMPLT);\n\t\t\tiowrite32(int_en, &hw->reg->INT_EN);\n\t\t\t \n\t\t\t__napi_schedule(&adapter->napi);\n\t\t}\n\t}\n\tnetdev_dbg(netdev, \"return = 0x%08x  INT_EN reg = 0x%08x\\n\",\n\t\t   IRQ_HANDLED, ioread32(&hw->reg->INT_EN));\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\npch_gbe_alloc_rx_buffers(struct pch_gbe_adapter *adapter,\n\t\t\t struct pch_gbe_rx_ring *rx_ring, int cleaned_count)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct pch_gbe_rx_desc *rx_desc;\n\tstruct pch_gbe_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz;\n\n\tbufsz = adapter->rx_buffer_len + NET_IP_ALIGN;\n\ti = rx_ring->next_to_use;\n\n\twhile ((cleaned_count--)) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tskb = netdev_alloc_skb(netdev, bufsz);\n\t\tif (unlikely(!skb)) {\n\t\t\t \n\t\t\tadapter->stats.rx_alloc_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\tbuffer_info->skb = skb;\n\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev,\n\t\t\t\t\t\t  buffer_info->rx_buffer,\n\t\t\t\t\t\t  buffer_info->length,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbuffer_info->skb = NULL;\n\t\t\tbuffer_info->dma = 0;\n\t\t\tadapter->stats.rx_alloc_buff_failed++;\n\t\t\tbreak;  \n\t\t}\n\t\tbuffer_info->mapped = true;\n\t\trx_desc = PCH_GBE_RX_DESC(*rx_ring, i);\n\t\trx_desc->buffer_addr = (buffer_info->dma);\n\t\trx_desc->gbec_status = DSC_INIT16;\n\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"i = %d  buffer_info->dma = 0x08%llx  buffer_info->length = 0x%x\\n\",\n\t\t\t   i, (unsigned long long)buffer_info->dma,\n\t\t\t   buffer_info->length);\n\n\t\tif (unlikely(++i == rx_ring->count))\n\t\t\ti = 0;\n\t}\n\tif (likely(rx_ring->next_to_use != i)) {\n\t\trx_ring->next_to_use = i;\n\t\tif (unlikely(i-- == 0))\n\t\t\ti = (rx_ring->count - 1);\n\t\tiowrite32(rx_ring->dma +\n\t\t\t  (int)sizeof(struct pch_gbe_rx_desc) * i,\n\t\t\t  &hw->reg->RX_DSC_SW_P);\n\t}\n\treturn;\n}\n\nstatic int\npch_gbe_alloc_rx_buffers_pool(struct pch_gbe_adapter *adapter,\n\t\t\t struct pch_gbe_rx_ring *rx_ring, int cleaned_count)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_buffer *buffer_info;\n\tunsigned int i;\n\tunsigned int bufsz;\n\tunsigned int size;\n\n\tbufsz = adapter->rx_buffer_len;\n\n\tsize = rx_ring->count * bufsz + PCH_GBE_RESERVE_MEMORY;\n\trx_ring->rx_buff_pool =\n\t\tdma_alloc_coherent(&pdev->dev, size,\n\t\t\t\t   &rx_ring->rx_buff_pool_logic, GFP_KERNEL);\n\tif (!rx_ring->rx_buff_pool)\n\t\treturn -ENOMEM;\n\n\trx_ring->rx_buff_pool_size = size;\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tbuffer_info->rx_buffer = rx_ring->rx_buff_pool + bufsz * i;\n\t\tbuffer_info->length = bufsz;\n\t}\n\treturn 0;\n}\n\n \nstatic void pch_gbe_alloc_tx_buffers(struct pch_gbe_adapter *adapter,\n\t\t\t\t\tstruct pch_gbe_tx_ring *tx_ring)\n{\n\tstruct pch_gbe_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz;\n\tstruct pch_gbe_tx_desc *tx_desc;\n\n\tbufsz =\n\t    adapter->hw.mac.max_frame_size + PCH_GBE_DMA_ALIGN + NET_IP_ALIGN;\n\n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tskb = netdev_alloc_skb(adapter->netdev, bufsz);\n\t\tskb_reserve(skb, PCH_GBE_DMA_ALIGN);\n\t\tbuffer_info->skb = skb;\n\t\ttx_desc = PCH_GBE_TX_DESC(*tx_ring, i);\n\t\ttx_desc->gbec_status = (DSC_INIT16);\n\t}\n\treturn;\n}\n\n \nstatic bool\npch_gbe_clean_tx(struct pch_gbe_adapter *adapter,\n\t\t struct pch_gbe_tx_ring *tx_ring)\n{\n\tstruct pch_gbe_tx_desc *tx_desc;\n\tstruct pch_gbe_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int cleaned_count = 0;\n\tbool cleaned = false;\n\tint unused, thresh;\n\n\tnetdev_dbg(adapter->netdev, \"next_to_clean : %d\\n\",\n\t\t   tx_ring->next_to_clean);\n\n\ti = tx_ring->next_to_clean;\n\ttx_desc = PCH_GBE_TX_DESC(*tx_ring, i);\n\tnetdev_dbg(adapter->netdev, \"gbec_status:0x%04x  dma_status:0x%04x\\n\",\n\t\t   tx_desc->gbec_status, tx_desc->dma_status);\n\n\tunused = PCH_GBE_DESC_UNUSED(tx_ring);\n\tthresh = tx_ring->count - NAPI_POLL_WEIGHT;\n\tif ((tx_desc->gbec_status == DSC_INIT16) && (unused < thresh))\n\t{   \n\t\tint j, k;\n\t\tif (unused < 8) {   \n\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t   \"clean_tx: transmit queue warning (%x,%x) unused=%d\\n\",\n\t\t\t\t   tx_ring->next_to_clean, tx_ring->next_to_use,\n\t\t\t\t   unused);\n\t\t}\n\n\t\t \n\t\tk = i;\n\t\tfor (j = 0; j < NAPI_POLL_WEIGHT; j++)\n\t\t{\n\t\t\ttx_desc = PCH_GBE_TX_DESC(*tx_ring, k);\n\t\t\tif (tx_desc->gbec_status != DSC_INIT16) break;  \n\t\t\tif (++k >= tx_ring->count) k = 0;   \n\t\t}\n\t\tif (j < NAPI_POLL_WEIGHT) {\n\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t   \"clean_tx: unused=%d loops=%d found tx_desc[%x,%x:%x].gbec_status=%04x\\n\",\n\t\t\t\t   unused, j, i, k, tx_ring->next_to_use,\n\t\t\t\t   tx_desc->gbec_status);\n\t\t\ti = k;   \n\t\t}\n\t}\n\n\twhile ((tx_desc->gbec_status & DSC_INIT16) == 0x0000) {\n\t\tnetdev_dbg(adapter->netdev, \"gbec_status:0x%04x\\n\",\n\t\t\t   tx_desc->gbec_status);\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tskb = buffer_info->skb;\n\t\tcleaned = true;\n\n\t\tif ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_ABT)) {\n\t\t\tadapter->stats.tx_aborted_errors++;\n\t\t\tnetdev_err(adapter->netdev, \"Transfer Abort Error\\n\");\n\t\t} else if ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_CRSER)\n\t\t\t  ) {\n\t\t\tadapter->stats.tx_carrier_errors++;\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Transfer Carrier Sense Error\\n\");\n\t\t} else if ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_EXCOL)\n\t\t\t  ) {\n\t\t\tadapter->stats.tx_aborted_errors++;\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Transfer Collision Abort Error\\n\");\n\t\t} else if ((tx_desc->gbec_status &\n\t\t\t    (PCH_GBE_TXD_GMAC_STAT_SNGCOL |\n\t\t\t     PCH_GBE_TXD_GMAC_STAT_MLTCOL))) {\n\t\t\tadapter->stats.collisions++;\n\t\t\tadapter->stats.tx_packets++;\n\t\t\tadapter->stats.tx_bytes += skb->len;\n\t\t\tnetdev_dbg(adapter->netdev, \"Transfer Collision\\n\");\n\t\t} else if ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_CMPLT)\n\t\t\t  ) {\n\t\t\tadapter->stats.tx_packets++;\n\t\t\tadapter->stats.tx_bytes += skb->len;\n\t\t}\n\t\tif (buffer_info->mapped) {\n\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t   \"unmap buffer_info->dma : %d\\n\", i);\n\t\t\tdma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t\t buffer_info->length, DMA_TO_DEVICE);\n\t\t\tbuffer_info->mapped = false;\n\t\t}\n\t\tif (buffer_info->skb) {\n\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t   \"trim buffer_info->skb : %d\\n\", i);\n\t\t\tskb_trim(buffer_info->skb, 0);\n\t\t}\n\t\ttx_desc->gbec_status = DSC_INIT16;\n\t\tif (unlikely(++i == tx_ring->count))\n\t\t\ti = 0;\n\t\ttx_desc = PCH_GBE_TX_DESC(*tx_ring, i);\n\n\t\t \n\t\tif (cleaned_count++ == NAPI_POLL_WEIGHT) {\n\t\t\tcleaned = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"called pch_gbe_unmap_and_free_tx_resource() %d count\\n\",\n\t\t   cleaned_count);\n\tif (cleaned_count > 0)  {  \n\t\t \n\t\tnetif_tx_lock(adapter->netdev);\n\t\tif (unlikely(cleaned && (netif_queue_stopped(adapter->netdev))))\n\t\t{\n\t\t\tnetif_wake_queue(adapter->netdev);\n\t\t\tadapter->stats.tx_restart_count++;\n\t\t\tnetdev_dbg(adapter->netdev, \"Tx wake queue\\n\");\n\t\t}\n\n\t\ttx_ring->next_to_clean = i;\n\n\t\tnetdev_dbg(adapter->netdev, \"next_to_clean : %d\\n\",\n\t\t\t   tx_ring->next_to_clean);\n\t\tnetif_tx_unlock(adapter->netdev);\n\t}\n\treturn cleaned;\n}\n\n \nstatic bool\npch_gbe_clean_rx(struct pch_gbe_adapter *adapter,\n\t\t struct pch_gbe_rx_ring *rx_ring,\n\t\t int *work_done, int work_to_do)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_buffer *buffer_info;\n\tstruct pch_gbe_rx_desc *rx_desc;\n\tu32 length;\n\tunsigned int i;\n\tunsigned int cleaned_count = 0;\n\tbool cleaned = false;\n\tstruct sk_buff *skb;\n\tu8 dma_status;\n\tu16 gbec_status;\n\tu32 tcp_ip_status;\n\n\ti = rx_ring->next_to_clean;\n\n\twhile (*work_done < work_to_do) {\n\t\t \n\t\trx_desc = PCH_GBE_RX_DESC(*rx_ring, i);\n\t\tif (rx_desc->gbec_status == DSC_INIT16)\n\t\t\tbreak;\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\n\t\tdma_status = rx_desc->dma_status;\n\t\tgbec_status = rx_desc->gbec_status;\n\t\ttcp_ip_status = rx_desc->tcp_ip_status;\n\t\trx_desc->gbec_status = DSC_INIT16;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\t \n\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t   buffer_info->length, DMA_FROM_DEVICE);\n\t\tbuffer_info->mapped = false;\n\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"RxDecNo = 0x%04x  Status[DMA:0x%02x GBE:0x%04x TCP:0x%08x]  BufInf = 0x%p\\n\",\n\t\t\t   i, dma_status, gbec_status, tcp_ip_status,\n\t\t\t   buffer_info);\n\t\t \n\t\tif (unlikely(gbec_status & PCH_GBE_RXD_GMAC_STAT_NOTOCTAL)) {\n\t\t\tadapter->stats.rx_frame_errors++;\n\t\t\tnetdev_err(netdev, \"Receive Not Octal Error\\n\");\n\t\t} else if (unlikely(gbec_status &\n\t\t\t\tPCH_GBE_RXD_GMAC_STAT_NBLERR)) {\n\t\t\tadapter->stats.rx_frame_errors++;\n\t\t\tnetdev_err(netdev, \"Receive Nibble Error\\n\");\n\t\t} else if (unlikely(gbec_status &\n\t\t\t\tPCH_GBE_RXD_GMAC_STAT_CRCERR)) {\n\t\t\tadapter->stats.rx_crc_errors++;\n\t\t\tnetdev_err(netdev, \"Receive CRC Error\\n\");\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tlength = (rx_desc->rx_words_eob) - 3 - ETH_FCS_LEN;\n\t\t\tif (rx_desc->rx_words_eob & 0x02)\n\t\t\t\tlength = length - 4;\n\t\t\t \n\t\t\tmemcpy(skb->data, buffer_info->rx_buffer, length);\n\n\t\t\t \n\t\t\tadapter->stats.rx_bytes += length;\n\t\t\tadapter->stats.rx_packets++;\n\t\t\tif ((gbec_status & PCH_GBE_RXD_GMAC_STAT_MARMLT))\n\t\t\t\tadapter->stats.multicast++;\n\t\t\t \n\t\t\tskb_put(skb, length);\n\n\t\t\tpch_rx_timestamp(adapter, skb);\n\n\t\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\t\tif (tcp_ip_status & PCH_GBE_RXD_ACC_STAT_TCPIPOK)\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\telse\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t\tnapi_gro_receive(&adapter->napi, skb);\n\t\t\t(*work_done)++;\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Receive skb->ip_summed: %d length: %d\\n\",\n\t\t\t\t   skb->ip_summed, length);\n\t\t}\n\t\t \n\t\tif (unlikely(cleaned_count >= PCH_GBE_RX_BUFFER_WRITE)) {\n\t\t\tpch_gbe_alloc_rx_buffers(adapter, rx_ring,\n\t\t\t\t\t\t cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\t\tif (++i == rx_ring->count)\n\t\t\ti = 0;\n\t}\n\trx_ring->next_to_clean = i;\n\tif (cleaned_count)\n\t\tpch_gbe_alloc_rx_buffers(adapter, rx_ring, cleaned_count);\n\treturn cleaned;\n}\n\n \nint pch_gbe_setup_tx_resources(struct pch_gbe_adapter *adapter,\n\t\t\t\tstruct pch_gbe_tx_ring *tx_ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_tx_desc *tx_desc;\n\tint size;\n\tint desNo;\n\n\tsize = (int)sizeof(struct pch_gbe_buffer) * tx_ring->count;\n\ttx_ring->buffer_info = vzalloc(size);\n\tif (!tx_ring->buffer_info)\n\t\treturn -ENOMEM;\n\n\ttx_ring->size = tx_ring->count * (int)sizeof(struct pch_gbe_tx_desc);\n\n\ttx_ring->desc = dma_alloc_coherent(&pdev->dev, tx_ring->size,\n\t\t\t\t\t   &tx_ring->dma, GFP_KERNEL);\n\tif (!tx_ring->desc) {\n\t\tvfree(tx_ring->buffer_info);\n\t\treturn -ENOMEM;\n\t}\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\n\tfor (desNo = 0; desNo < tx_ring->count; desNo++) {\n\t\ttx_desc = PCH_GBE_TX_DESC(*tx_ring, desNo);\n\t\ttx_desc->gbec_status = DSC_INIT16;\n\t}\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"tx_ring->desc = 0x%p  tx_ring->dma = 0x%08llx next_to_clean = 0x%08x  next_to_use = 0x%08x\\n\",\n\t\t   tx_ring->desc, (unsigned long long)tx_ring->dma,\n\t\t   tx_ring->next_to_clean, tx_ring->next_to_use);\n\treturn 0;\n}\n\n \nint pch_gbe_setup_rx_resources(struct pch_gbe_adapter *adapter,\n\t\t\t\tstruct pch_gbe_rx_ring *rx_ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_rx_desc *rx_desc;\n\tint size;\n\tint desNo;\n\n\tsize = (int)sizeof(struct pch_gbe_buffer) * rx_ring->count;\n\trx_ring->buffer_info = vzalloc(size);\n\tif (!rx_ring->buffer_info)\n\t\treturn -ENOMEM;\n\n\trx_ring->size = rx_ring->count * (int)sizeof(struct pch_gbe_rx_desc);\n\trx_ring->desc =\tdma_alloc_coherent(&pdev->dev, rx_ring->size,\n\t\t\t\t\t\t  &rx_ring->dma, GFP_KERNEL);\n\tif (!rx_ring->desc) {\n\t\tvfree(rx_ring->buffer_info);\n\t\treturn -ENOMEM;\n\t}\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\tfor (desNo = 0; desNo < rx_ring->count; desNo++) {\n\t\trx_desc = PCH_GBE_RX_DESC(*rx_ring, desNo);\n\t\trx_desc->gbec_status = DSC_INIT16;\n\t}\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"rx_ring->desc = 0x%p  rx_ring->dma = 0x%08llx next_to_clean = 0x%08x  next_to_use = 0x%08x\\n\",\n\t\t   rx_ring->desc, (unsigned long long)rx_ring->dma,\n\t\t   rx_ring->next_to_clean, rx_ring->next_to_use);\n\treturn 0;\n}\n\n \nvoid pch_gbe_free_tx_resources(struct pch_gbe_adapter *adapter,\n\t\t\t\tstruct pch_gbe_tx_ring *tx_ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tpch_gbe_clean_tx_ring(adapter, tx_ring);\n\tvfree(tx_ring->buffer_info);\n\ttx_ring->buffer_info = NULL;\n\tdma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,\n\t\t\t  tx_ring->dma);\n\ttx_ring->desc = NULL;\n}\n\n \nvoid pch_gbe_free_rx_resources(struct pch_gbe_adapter *adapter,\n\t\t\t\tstruct pch_gbe_rx_ring *rx_ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tpch_gbe_clean_rx_ring(adapter, rx_ring);\n\tvfree(rx_ring->buffer_info);\n\trx_ring->buffer_info = NULL;\n\tdma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\n\t\t\t  rx_ring->dma);\n\trx_ring->desc = NULL;\n}\n\n \nstatic int pch_gbe_request_irq(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\terr = pci_alloc_irq_vectors(adapter->pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (err < 0)\n\t\treturn err;\n\n\tadapter->irq = pci_irq_vector(adapter->pdev, 0);\n\n\terr = request_irq(adapter->irq, &pch_gbe_intr, IRQF_SHARED,\n\t\t\t  netdev->name, netdev);\n\tif (err)\n\t\tnetdev_err(netdev, \"Unable to allocate interrupt Error: %d\\n\",\n\t\t\t   err);\n\tnetdev_dbg(netdev, \"have_msi : %d  return : 0x%04x\\n\",\n\t\t   pci_dev_msi_enabled(adapter->pdev), err);\n\treturn err;\n}\n\n \nint pch_gbe_up(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pch_gbe_tx_ring *tx_ring = adapter->tx_ring;\n\tstruct pch_gbe_rx_ring *rx_ring = adapter->rx_ring;\n\tint err = -EINVAL;\n\n\t \n\tif (!is_valid_ether_addr(adapter->hw.mac.addr)) {\n\t\tnetdev_err(netdev, \"Error: Invalid MAC address\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tpch_gbe_set_multi(netdev);\n\n\tpch_gbe_setup_tctl(adapter);\n\tpch_gbe_configure_tx(adapter);\n\tpch_gbe_setup_rctl(adapter);\n\tpch_gbe_configure_rx(adapter);\n\n\terr = pch_gbe_request_irq(adapter);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Error: can't bring device up - irq request failed\\n\");\n\t\tgoto out;\n\t}\n\terr = pch_gbe_alloc_rx_buffers_pool(adapter, rx_ring, rx_ring->count);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Error: can't bring device up - alloc rx buffers pool failed\\n\");\n\t\tgoto freeirq;\n\t}\n\tpch_gbe_alloc_tx_buffers(adapter, tx_ring);\n\tpch_gbe_alloc_rx_buffers(adapter, rx_ring, rx_ring->count);\n\tadapter->tx_queue_len = netdev->tx_queue_len;\n\tpch_gbe_enable_dma_rx(&adapter->hw);\n\tpch_gbe_enable_mac_rx(&adapter->hw);\n\n\tmod_timer(&adapter->watchdog_timer, jiffies);\n\n\tnapi_enable(&adapter->napi);\n\tpch_gbe_irq_enable(adapter);\n\tnetif_start_queue(adapter->netdev);\n\n\treturn 0;\n\nfreeirq:\n\tpch_gbe_free_irq(adapter);\nout:\n\treturn err;\n}\n\n \nvoid pch_gbe_down(struct pch_gbe_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct pch_gbe_rx_ring *rx_ring = adapter->rx_ring;\n\n\t \n\tnapi_disable(&adapter->napi);\n\tatomic_set(&adapter->irq_sem, 0);\n\n\tpch_gbe_irq_disable(adapter);\n\tpch_gbe_free_irq(adapter);\n\n\tdel_timer_sync(&adapter->watchdog_timer);\n\n\tnetdev->tx_queue_len = adapter->tx_queue_len;\n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\tif ((pdev->error_state) && (pdev->error_state != pci_channel_io_normal))\n\t\tpch_gbe_reset(adapter);\n\tpch_gbe_clean_tx_ring(adapter, adapter->tx_ring);\n\tpch_gbe_clean_rx_ring(adapter, adapter->rx_ring);\n\n\tdma_free_coherent(&adapter->pdev->dev, rx_ring->rx_buff_pool_size,\n\t\t\t  rx_ring->rx_buff_pool, rx_ring->rx_buff_pool_logic);\n\trx_ring->rx_buff_pool_logic = 0;\n\trx_ring->rx_buff_pool_size = 0;\n\trx_ring->rx_buff_pool = NULL;\n}\n\n \nstatic int pch_gbe_sw_init(struct pch_gbe_adapter *adapter)\n{\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\n\tadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_2048;\n\thw->mac.max_frame_size = netdev->mtu + ETH_HLEN + ETH_FCS_LEN;\n\thw->mac.min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\n\thw->phy.reset_delay_us = PCH_GBE_PHY_RESET_DELAY_US;\n\n\tif (pch_gbe_alloc_queues(adapter)) {\n\t\tnetdev_err(netdev, \"Unable to allocate memory for queues\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_init(&adapter->hw.miim_lock);\n\tspin_lock_init(&adapter->stats_lock);\n\tspin_lock_init(&adapter->ethtool_lock);\n\tatomic_set(&adapter->irq_sem, 0);\n\tpch_gbe_irq_disable(adapter);\n\n\tpch_gbe_init_stats(adapter);\n\n\tnetdev_dbg(netdev,\n\t\t   \"rx_buffer_len : %d  mac.min_frame_size : %d  mac.max_frame_size : %d\\n\",\n\t\t   (u32) adapter->rx_buffer_len,\n\t\t   hw->mac.min_frame_size, hw->mac.max_frame_size);\n\treturn 0;\n}\n\n \nstatic int pch_gbe_open(struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tint err;\n\n\t \n\terr = pch_gbe_setup_tx_resources(adapter, adapter->tx_ring);\n\tif (err)\n\t\tgoto err_setup_tx;\n\t \n\terr = pch_gbe_setup_rx_resources(adapter, adapter->rx_ring);\n\tif (err)\n\t\tgoto err_setup_rx;\n\tpch_gbe_phy_power_up(hw);\n\terr = pch_gbe_up(adapter);\n\tif (err)\n\t\tgoto err_up;\n\tnetdev_dbg(netdev, \"Success End\\n\");\n\treturn 0;\n\nerr_up:\n\tif (!adapter->wake_up_evt)\n\t\tpch_gbe_phy_power_down(hw);\n\tpch_gbe_free_rx_resources(adapter, adapter->rx_ring);\nerr_setup_rx:\n\tpch_gbe_free_tx_resources(adapter, adapter->tx_ring);\nerr_setup_tx:\n\tpch_gbe_reset(adapter);\n\tnetdev_err(netdev, \"Error End\\n\");\n\treturn err;\n}\n\n \nstatic int pch_gbe_stop(struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tpch_gbe_down(adapter);\n\tif (!adapter->wake_up_evt)\n\t\tpch_gbe_phy_power_down(hw);\n\tpch_gbe_free_tx_resources(adapter, adapter->tx_ring);\n\tpch_gbe_free_rx_resources(adapter, adapter->rx_ring);\n\treturn 0;\n}\n\n \nstatic netdev_tx_t pch_gbe_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_tx_ring *tx_ring = adapter->tx_ring;\n\n\tif (unlikely(!PCH_GBE_DESC_UNUSED(tx_ring))) {\n\t\tnetif_stop_queue(netdev);\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"Return : BUSY  next_to use : 0x%08x  next_to clean : 0x%08x\\n\",\n\t\t\t   tx_ring->next_to_use, tx_ring->next_to_clean);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tpch_gbe_tx_queue(adapter, tx_ring, skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void pch_gbe_set_multi(struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu32 rctl, adrmask;\n\tint mc_count, i;\n\n\tnetdev_dbg(netdev, \"netdev->flags : 0x%08x\\n\", netdev->flags);\n\n\t \n\trctl = ioread32(&hw->reg->RX_MODE);\n\trctl |= PCH_GBE_ADD_FIL_EN | PCH_GBE_MLT_FIL_EN;\n\n\t \n\tif (netdev->flags & IFF_PROMISC)\n\t\trctl &= ~(PCH_GBE_ADD_FIL_EN | PCH_GBE_MLT_FIL_EN);\n\n\t \n\tmc_count = netdev_mc_count(netdev);\n\tif ((netdev->flags & IFF_ALLMULTI) || mc_count >= PCH_GBE_MAR_ENTRIES)\n\t\trctl &= ~PCH_GBE_MLT_FIL_EN;\n\n\tiowrite32(rctl, &hw->reg->RX_MODE);\n\n\t \n\tif (!(rctl & PCH_GBE_MLT_FIL_EN))\n\t\treturn;\n\n\t \n\ti = 1;\n\tnetdev_for_each_mc_addr(ha, netdev)\n\t\tpch_gbe_mac_mar_set(hw, ha->addr, i++);\n\n\t \n\tfor (; i < PCH_GBE_MAR_ENTRIES; i++) {\n\t\t \n\t\tadrmask = ioread32(&hw->reg->ADDR_MASK);\n\t\tiowrite32(adrmask | BIT(i), &hw->reg->ADDR_MASK);\n\t\t \n\t\tpch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\n\t\t \n\t\tiowrite32(0, &hw->reg->mac_adr[i].high);\n\t\tiowrite32(0, &hw->reg->mac_adr[i].low);\n\t}\n\n\tnetdev_dbg(netdev,\n\t\t \"RX_MODE reg(check bit31,30 ADD,MLT) : 0x%08x  netdev->mc_count : 0x%08x\\n\",\n\t\t ioread32(&hw->reg->RX_MODE), mc_count);\n}\n\n \nstatic int pch_gbe_set_mac(struct net_device *netdev, void *addr)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *skaddr = addr;\n\tint ret_val;\n\n\tif (!is_valid_ether_addr(skaddr->sa_data)) {\n\t\tret_val = -EADDRNOTAVAIL;\n\t} else {\n\t\teth_hw_addr_set(netdev, skaddr->sa_data);\n\t\tmemcpy(adapter->hw.mac.addr, skaddr->sa_data, netdev->addr_len);\n\t\tpch_gbe_mac_mar_set(&adapter->hw, adapter->hw.mac.addr, 0);\n\t\tret_val = 0;\n\t}\n\tnetdev_dbg(netdev, \"ret_val : 0x%08x\\n\", ret_val);\n\tnetdev_dbg(netdev, \"dev_addr : %pM\\n\", netdev->dev_addr);\n\tnetdev_dbg(netdev, \"mac_addr : %pM\\n\", adapter->hw.mac.addr);\n\tnetdev_dbg(netdev, \"MAC_ADR1AB reg : 0x%08x 0x%08x\\n\",\n\t\t   ioread32(&adapter->hw.reg->mac_adr[0].high),\n\t\t   ioread32(&adapter->hw.reg->mac_adr[0].low));\n\treturn ret_val;\n}\n\n \nstatic int pch_gbe_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tint max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;\n\tunsigned long old_rx_buffer_len = adapter->rx_buffer_len;\n\tint err;\n\n\tif (max_frame <= PCH_GBE_FRAME_SIZE_2048)\n\t\tadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_2048;\n\telse if (max_frame <= PCH_GBE_FRAME_SIZE_4096)\n\t\tadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_4096;\n\telse if (max_frame <= PCH_GBE_FRAME_SIZE_8192)\n\t\tadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_8192;\n\telse\n\t\tadapter->rx_buffer_len = PCH_GBE_MAX_RX_BUFFER_SIZE;\n\n\tif (netif_running(netdev)) {\n\t\tpch_gbe_down(adapter);\n\t\terr = pch_gbe_up(adapter);\n\t\tif (err) {\n\t\t\tadapter->rx_buffer_len = old_rx_buffer_len;\n\t\t\tpch_gbe_up(adapter);\n\t\t\treturn err;\n\t\t} else {\n\t\t\tnetdev->mtu = new_mtu;\n\t\t\tadapter->hw.mac.max_frame_size = max_frame;\n\t\t}\n\t} else {\n\t\tpch_gbe_reset(adapter);\n\t\tnetdev->mtu = new_mtu;\n\t\tadapter->hw.mac.max_frame_size = max_frame;\n\t}\n\n\tnetdev_dbg(netdev,\n\t\t   \"max_frame : %d  rx_buffer_len : %d  mtu : %d  max_frame_size : %d\\n\",\n\t\t   max_frame, (u32) adapter->rx_buffer_len, netdev->mtu,\n\t\t   adapter->hw.mac.max_frame_size);\n\treturn 0;\n}\n\n \nstatic int pch_gbe_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tnetdev_features_t changed = features ^ netdev->features;\n\n\tif (!(changed & NETIF_F_RXCSUM))\n\t\treturn 0;\n\n\tif (netif_running(netdev))\n\t\tpch_gbe_reinit_locked(adapter);\n\telse\n\t\tpch_gbe_reset(adapter);\n\n\treturn 0;\n}\n\n \nstatic int pch_gbe_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tnetdev_dbg(netdev, \"cmd : 0x%04x\\n\", cmd);\n\n\tif (cmd == SIOCSHWTSTAMP)\n\t\treturn hwtstamp_ioctl(netdev, ifr, cmd);\n\n\treturn generic_mii_ioctl(&adapter->mii, if_mii(ifr), cmd, NULL);\n}\n\n \nstatic void pch_gbe_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tadapter->stats.tx_timeout_count++;\n\tschedule_work(&adapter->reset_task);\n}\n\n \nstatic int pch_gbe_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct pch_gbe_adapter *adapter =\n\t    container_of(napi, struct pch_gbe_adapter, napi);\n\tint work_done = 0;\n\tbool poll_end_flag = false;\n\tbool cleaned = false;\n\n\tnetdev_dbg(adapter->netdev, \"budget : %d\\n\", budget);\n\n\tpch_gbe_clean_rx(adapter, adapter->rx_ring, &work_done, budget);\n\tcleaned = pch_gbe_clean_tx(adapter, adapter->tx_ring);\n\n\tif (cleaned)\n\t\twork_done = budget;\n\t \n\tif (work_done < budget)\n\t\tpoll_end_flag = true;\n\n\tif (poll_end_flag) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tpch_gbe_irq_enable(adapter);\n\t}\n\n\tif (adapter->rx_stop_flag) {\n\t\tadapter->rx_stop_flag = false;\n\t\tpch_gbe_enable_dma_rx(&adapter->hw);\n\t}\n\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"poll_end_flag : %d  work_done : %d  budget : %d\\n\",\n\t\t   poll_end_flag, work_done, budget);\n\n\treturn work_done;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void pch_gbe_netpoll(struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tdisable_irq(adapter->irq);\n\tpch_gbe_intr(adapter->irq, netdev);\n\tenable_irq(adapter->irq);\n}\n#endif\n\nstatic const struct net_device_ops pch_gbe_netdev_ops = {\n\t.ndo_open = pch_gbe_open,\n\t.ndo_stop = pch_gbe_stop,\n\t.ndo_start_xmit = pch_gbe_xmit_frame,\n\t.ndo_set_mac_address = pch_gbe_set_mac,\n\t.ndo_tx_timeout = pch_gbe_tx_timeout,\n\t.ndo_change_mtu = pch_gbe_change_mtu,\n\t.ndo_set_features = pch_gbe_set_features,\n\t.ndo_eth_ioctl = pch_gbe_ioctl,\n\t.ndo_set_rx_mode = pch_gbe_set_multi,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = pch_gbe_netpoll,\n#endif\n};\n\nstatic pci_ers_result_t pch_gbe_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tnetif_device_detach(netdev);\n\tif (netif_running(netdev))\n\t\tpch_gbe_down(adapter);\n\tpci_disable_device(pdev);\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t pch_gbe_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\tif (pci_enable_device(pdev)) {\n\t\tnetdev_err(netdev, \"Cannot re-enable PCI device after reset\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\tpci_set_master(pdev);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpch_gbe_phy_power_up(hw);\n\tpch_gbe_reset(adapter);\n\t \n\tpch_gbe_mac_set_wol_event(hw, 0);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void pch_gbe_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tif (netif_running(netdev)) {\n\t\tif (pch_gbe_up(adapter)) {\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"can't bring device back up after reset\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tnetif_device_attach(netdev);\n}\n\nstatic int __pch_gbe_suspend(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 wufc = adapter->wake_up_evt;\n\n\tnetif_device_detach(netdev);\n\tif (netif_running(netdev))\n\t\tpch_gbe_down(adapter);\n\tif (wufc) {\n\t\tpch_gbe_set_multi(netdev);\n\t\tpch_gbe_setup_rctl(adapter);\n\t\tpch_gbe_configure_rx(adapter);\n\t\tpch_gbe_set_rgmii_ctrl(adapter, hw->mac.link_speed,\n\t\t\t\t\thw->mac.link_duplex);\n\t\tpch_gbe_set_mode(adapter, hw->mac.link_speed,\n\t\t\t\t\thw->mac.link_duplex);\n\t\tpch_gbe_mac_set_wol_event(hw, wufc);\n\t\tpci_disable_device(pdev);\n\t} else {\n\t\tpch_gbe_phy_power_down(hw);\n\t\tpch_gbe_mac_set_wol_event(hw, wufc);\n\t\tpci_disable_device(pdev);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int pch_gbe_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\n\treturn __pch_gbe_suspend(pdev);\n}\n\nstatic int pch_gbe_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\tu32 err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Cannot enable PCI device from suspend\\n\");\n\t\treturn err;\n\t}\n\tpci_set_master(pdev);\n\tpch_gbe_phy_power_up(hw);\n\tpch_gbe_reset(adapter);\n\t \n\tpch_gbe_mac_set_wol_event(hw, 0);\n\n\tif (netif_running(netdev))\n\t\tpch_gbe_up(adapter);\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n}\n#endif  \n\nstatic void pch_gbe_shutdown(struct pci_dev *pdev)\n{\n\t__pch_gbe_suspend(pdev);\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, true);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\nstatic void pch_gbe_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\n\tcancel_work_sync(&adapter->reset_task);\n\tunregister_netdev(netdev);\n\n\tpch_gbe_phy_hw_reset(&adapter->hw);\n\tpci_dev_put(adapter->ptp_pdev);\n\n\tfree_netdev(netdev);\n}\n\nstatic int pch_gbe_probe(struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstruct net_device *netdev;\n\tstruct pch_gbe_adapter *adapter;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"ERR: No usable DMA configuration, aborting\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = pcim_iomap_regions(pdev, 1 << PCH_GBE_PCI_BAR, pci_name(pdev));\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"ERR: Can't reserve PCI I/O and memory resources\\n\");\n\t\treturn ret;\n\t}\n\tpci_set_master(pdev);\n\n\tnetdev = alloc_etherdev((int)sizeof(struct pch_gbe_adapter));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->hw.back = adapter;\n\tadapter->hw.reg = pcim_iomap_table(pdev)[PCH_GBE_PCI_BAR];\n\n\tadapter->pdata = (struct pch_gbe_privdata *)pci_id->driver_data;\n\tif (adapter->pdata && adapter->pdata->platform_init) {\n\t\tret = adapter->pdata->platform_init(pdev);\n\t\tif (ret)\n\t\t\tgoto err_free_netdev;\n\t}\n\n\tadapter->ptp_pdev =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(adapter->pdev->bus),\n\t\t\t\t\t    adapter->pdev->bus->number,\n\t\t\t\t\t    PCI_DEVFN(12, 4));\n\n\tnetdev->netdev_ops = &pch_gbe_netdev_ops;\n\tnetdev->watchdog_timeo = PCH_GBE_WATCHDOG_PERIOD;\n\tnetif_napi_add(netdev, &adapter->napi, pch_gbe_napi_poll);\n\tnetdev->hw_features = NETIF_F_RXCSUM |\n\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\tnetdev->features = netdev->hw_features;\n\tpch_gbe_set_ethtool_ops(netdev);\n\n\t \n\tnetdev->min_mtu = ETH_ZLEN - ETH_HLEN;\n\tnetdev->max_mtu = PCH_GBE_MAX_JUMBO_FRAME_SIZE -\n\t\t\t  (ETH_HLEN + ETH_FCS_LEN);\n\n\tpch_gbe_mac_load_mac_addr(&adapter->hw);\n\tpch_gbe_mac_reset_hw(&adapter->hw);\n\n\t \n\tret = pch_gbe_sw_init(adapter);\n\tif (ret)\n\t\tgoto err_put_dev;\n\n\t \n\tret = pch_gbe_init_phy(adapter);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"PHY initialize error\\n\");\n\t\tgoto err_free_adapter;\n\t}\n\n\t \n\tret = pch_gbe_mac_read_mac_addr(&adapter->hw);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MAC address Read Error\\n\");\n\t\tgoto err_free_adapter;\n\t}\n\n\teth_hw_addr_set(netdev, adapter->hw.mac.addr);\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\t \n\t\tdev_err(&pdev->dev, \"Invalid MAC address, \"\n\t\t                    \"interface disabled.\\n\");\n\t}\n\ttimer_setup(&adapter->watchdog_timer, pch_gbe_watchdog, 0);\n\n\tINIT_WORK(&adapter->reset_task, pch_gbe_reset_task);\n\n\tpch_gbe_check_options(adapter);\n\n\t \n\tadapter->wake_up_evt = PCH_GBE_WL_INIT_SETTING;\n\tdev_info(&pdev->dev, \"MAC address : %pM\\n\", netdev->dev_addr);\n\n\t \n\tpch_gbe_reset(adapter);\n\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto err_free_adapter;\n\t \n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\tdev_dbg(&pdev->dev, \"PCH Network Connection\\n\");\n\n\t \n\tif (adapter->pdata && adapter->pdata->phy_disable_hibernate)\n\t\tpch_gbe_phy_disable_hibernate(&adapter->hw);\n\n\tdevice_set_wakeup_enable(&pdev->dev, 1);\n\treturn 0;\n\nerr_free_adapter:\n\tpch_gbe_phy_hw_reset(&adapter->hw);\nerr_put_dev:\n\tpci_dev_put(adapter->ptp_pdev);\nerr_free_netdev:\n\tfree_netdev(netdev);\n\treturn ret;\n}\n\nstatic void pch_gbe_gpio_remove_table(void *table)\n{\n\tgpiod_remove_lookup_table(table);\n}\n\nstatic int pch_gbe_gpio_add_table(struct device *dev, void *table)\n{\n\tgpiod_add_lookup_table(table);\n\treturn devm_add_action_or_reset(dev, pch_gbe_gpio_remove_table, table);\n}\n\nstatic struct gpiod_lookup_table pch_gbe_minnow_gpio_table = {\n\t.dev_id\t\t= \"0000:02:00.1\",\n\t.table\t\t= {\n\t\tGPIO_LOOKUP(\"sch_gpio.33158\", 13, NULL, GPIO_ACTIVE_LOW),\n\t\t{}\n\t},\n};\n\n \nstatic int pch_gbe_minnow_platform_init(struct pci_dev *pdev)\n{\n\tstruct gpio_desc *gpiod;\n\tint ret;\n\n\tret = pch_gbe_gpio_add_table(&pdev->dev, &pch_gbe_minnow_gpio_table);\n\tif (ret)\n\t\treturn ret;\n\n\tgpiod = devm_gpiod_get(&pdev->dev, NULL, GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpiod))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(gpiod),\n\t\t\t\t     \"Can't request PHY reset GPIO line\\n\");\n\n\tgpiod_set_value(gpiod, 1);\n\tusleep_range(1250, 1500);\n\tgpiod_set_value(gpiod, 0);\n\tusleep_range(1250, 1500);\n\n\treturn ret;\n}\n\nstatic struct pch_gbe_privdata pch_gbe_minnow_privdata = {\n\t.phy_tx_clk_delay = true,\n\t.phy_disable_hibernate = true,\n\t.platform_init = pch_gbe_minnow_platform_init,\n};\n\nstatic const struct pci_device_id pch_gbe_pcidev_id[] = {\n\t{.vendor = PCI_VENDOR_ID_INTEL,\n\t .device = PCI_DEVICE_ID_INTEL_IOH1_GBE,\n\t .subvendor = PCI_VENDOR_ID_CIRCUITCO,\n\t .subdevice = PCI_SUBSYSTEM_ID_CIRCUITCO_MINNOWBOARD,\n\t .class = (PCI_CLASS_NETWORK_ETHERNET << 8),\n\t .class_mask = (0xFFFF00),\n\t .driver_data = (kernel_ulong_t)&pch_gbe_minnow_privdata\n\t },\n\t{.vendor = PCI_VENDOR_ID_INTEL,\n\t .device = PCI_DEVICE_ID_INTEL_IOH1_GBE,\n\t .subvendor = PCI_ANY_ID,\n\t .subdevice = PCI_ANY_ID,\n\t .class = (PCI_CLASS_NETWORK_ETHERNET << 8),\n\t .class_mask = (0xFFFF00)\n\t },\n\t{.vendor = PCI_VENDOR_ID_ROHM,\n\t .device = PCI_DEVICE_ID_ROHM_ML7223_GBE,\n\t .subvendor = PCI_ANY_ID,\n\t .subdevice = PCI_ANY_ID,\n\t .class = (PCI_CLASS_NETWORK_ETHERNET << 8),\n\t .class_mask = (0xFFFF00)\n\t },\n\t{.vendor = PCI_VENDOR_ID_ROHM,\n\t .device = PCI_DEVICE_ID_ROHM_ML7831_GBE,\n\t .subvendor = PCI_ANY_ID,\n\t .subdevice = PCI_ANY_ID,\n\t .class = (PCI_CLASS_NETWORK_ETHERNET << 8),\n\t .class_mask = (0xFFFF00)\n\t },\n\t \n\t{0}\n};\n\n#ifdef CONFIG_PM\nstatic const struct dev_pm_ops pch_gbe_pm_ops = {\n\t.suspend = pch_gbe_suspend,\n\t.resume = pch_gbe_resume,\n\t.freeze = pch_gbe_suspend,\n\t.thaw = pch_gbe_resume,\n\t.poweroff = pch_gbe_suspend,\n\t.restore = pch_gbe_resume,\n};\n#endif\n\nstatic const struct pci_error_handlers pch_gbe_err_handler = {\n\t.error_detected = pch_gbe_io_error_detected,\n\t.slot_reset = pch_gbe_io_slot_reset,\n\t.resume = pch_gbe_io_resume\n};\n\nstatic struct pci_driver pch_gbe_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = pch_gbe_pcidev_id,\n\t.probe = pch_gbe_probe,\n\t.remove = pch_gbe_remove,\n#ifdef CONFIG_PM\n\t.driver.pm = &pch_gbe_pm_ops,\n#endif\n\t.shutdown = pch_gbe_shutdown,\n\t.err_handler = &pch_gbe_err_handler\n};\nmodule_pci_driver(pch_gbe_driver);\n\nMODULE_DESCRIPTION(\"EG20T PCH Gigabit ethernet Driver\");\nMODULE_AUTHOR(\"LAPIS SEMICONDUCTOR, <tshimizu818@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, pch_gbe_pcidev_id);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}