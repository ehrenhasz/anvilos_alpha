{
  "module_name": "sunvnet_common.h",
  "hash_id": "70472021aa5ce061862763273e599614bc89c066880caf702b77909946b47540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/sunvnet_common.h",
  "human_readable_source": " \n#ifndef _SUNVNETCOMMON_H\n#define _SUNVNETCOMMON_H\n\n#include <linux/interrupt.h>\n\n \n#define\tVNET_CLEAN_TIMEOUT\t\t((HZ / 100) + 1)\n\n#define VNET_MAXPACKET\t\t\t(65535ULL + ETH_HLEN + VLAN_HLEN)\n#define VNET_TX_RING_SIZE\t\t512\n#define VNET_TX_WAKEUP_THRESH(dr)\t((dr)->pending / 4)\n\n#define\tVNET_MINTSO\t 2048\t \n#define\tVNET_MAXTSO\t65535\t \n\n#define VNET_MAX_MTU\t65535\n\n \n#define VNET_PACKET_SKIP\t\t6\n\n#define\tVNET_MAXCOOKIES\t\t\t(VNET_MAXPACKET / PAGE_SIZE + 1)\n\n#define\tVNET_MAX_TXQS\t\t16\n\nstruct vnet_tx_entry {\n\tstruct sk_buff\t\t*skb;\n\tunsigned int\t\tncookies;\n\tstruct ldc_trans_cookie\tcookies[VNET_MAXCOOKIES];\n};\n\nstruct vnet;\n\nstruct vnet_port_stats {\n\t \n\tu32 rx_bytes;\n\tu32 tx_bytes;\n\tu32 rx_packets;\n\tu32 tx_packets;\n\tu32 event_up;\n\tu32 event_reset;\n\tu32 q_placeholder;\n};\n\n#define NUM_VNET_PORT_STATS  (sizeof(struct vnet_port_stats) / sizeof(u32))\n\n \nstruct vnet_port {\n\tstruct vio_driver_state\tvio;\n\n\tstruct vnet_port_stats stats;\n\n\tstruct hlist_node\thash;\n\tu8\t\t\traddr[ETH_ALEN];\n\tunsigned\t\tswitch_port:1;\n\tunsigned\t\ttso:1;\n\tunsigned\t\tvsw:1;\n\tunsigned\t\t__pad:13;\n\n\tstruct vnet\t\t*vp;\n\tstruct net_device\t*dev;\n\n\tstruct vnet_tx_entry\ttx_bufs[VNET_TX_RING_SIZE];\n\n\tstruct list_head\tlist;\n\n\tu32\t\t\tstop_rx_idx;\n\tbool\t\t\tstop_rx;\n\tbool\t\t\tstart_cons;\n\n\tstruct timer_list\tclean_timer;\n\n\tu64\t\t\trmtu;\n\tu16\t\t\ttsolen;\n\n\tstruct napi_struct\tnapi;\n\tu32\t\t\tnapi_stop_idx;\n\tbool\t\t\tnapi_resume;\n\tint\t\t\trx_event;\n\tu16\t\t\tq_index;\n};\n\nstatic inline struct vnet_port *to_vnet_port(struct vio_driver_state *vio)\n{\n\treturn container_of(vio, struct vnet_port, vio);\n}\n\n#define VNET_PORT_HASH_SIZE\t16\n#define VNET_PORT_HASH_MASK\t(VNET_PORT_HASH_SIZE - 1)\n\nstatic inline unsigned int vnet_hashfn(u8 *mac)\n{\n\tunsigned int val = mac[4] ^ mac[5];\n\n\treturn val & (VNET_PORT_HASH_MASK);\n}\n\nstruct vnet_mcast_entry {\n\tu8\t\t\taddr[ETH_ALEN];\n\tu8\t\t\tsent;\n\tu8\t\t\thit;\n\tstruct vnet_mcast_entry\t*next;\n};\n\nstruct vnet {\n\tspinlock_t\t\tlock;  \n\tstruct net_device\t*dev;\n\tu32\t\t\tmsg_enable;\n\tu8\t\t\tq_used[VNET_MAX_TXQS];\n\tstruct list_head\tport_list;\n\tstruct hlist_head\tport_hash[VNET_PORT_HASH_SIZE];\n\tstruct vnet_mcast_entry\t*mcast_list;\n\tstruct list_head\tlist;\n\tu64\t\t\tlocal_mac;\n\tint\t\t\tnports;\n};\n\n \n#define VNET_PORT_TO_NET_DEVICE(__port) \\\n\t((__port)->vsw ? (__port)->dev : (__port)->vp->dev)\n\n \nvoid sunvnet_clean_timer_expire_common(struct timer_list *t);\nint sunvnet_open_common(struct net_device *dev);\nint sunvnet_close_common(struct net_device *dev);\nvoid sunvnet_set_rx_mode_common(struct net_device *dev, struct vnet *vp);\nint sunvnet_set_mac_addr_common(struct net_device *dev, void *p);\nvoid sunvnet_tx_timeout_common(struct net_device *dev, unsigned int txqueue);\nnetdev_tx_t\nsunvnet_start_xmit_common(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  struct vnet_port *(*vnet_tx_port)\n\t\t\t  (struct sk_buff *, struct net_device *));\n#ifdef CONFIG_NET_POLL_CONTROLLER\nvoid sunvnet_poll_controller_common(struct net_device *dev, struct vnet *vp);\n#endif\nvoid sunvnet_event_common(void *arg, int event);\nint sunvnet_send_attr_common(struct vio_driver_state *vio);\nint sunvnet_handle_attr_common(struct vio_driver_state *vio, void *arg);\nvoid sunvnet_handshake_complete_common(struct vio_driver_state *vio);\nint sunvnet_poll_common(struct napi_struct *napi, int budget);\nvoid sunvnet_port_free_tx_bufs_common(struct vnet_port *port);\nvoid vnet_port_reset(struct vnet_port *port);\nbool sunvnet_port_is_up_common(struct vnet_port *vnet);\nvoid sunvnet_port_add_txq_common(struct vnet_port *port);\nvoid sunvnet_port_rm_txq_common(struct vnet_port *port);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}