{
  "module_name": "ldmvsw.c",
  "hash_id": "685a76c1a061068d237da345c3d44551e14412dabf7648e068296ac41e02ab0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/ldmvsw.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/highmem.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#if defined(CONFIG_IPV6)\n#include <linux/icmpv6.h>\n#endif\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n\n#include <asm/vio.h>\n#include <asm/ldc.h>\n\n \n#include \"sunvnet_common.h\"\n\n \n#define VSW_TX_TIMEOUT\t\t\t(10 * HZ)\n\n \nstatic u8 vsw_port_hwaddr[ETH_ALEN] = {0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\n#define DRV_MODULE_NAME\t\t\"ldmvsw\"\n#define DRV_MODULE_VERSION\t\"1.2\"\n#define DRV_MODULE_RELDATE\t\"March 4, 2017\"\n\nstatic char version[] =\n\tDRV_MODULE_NAME \" \" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\";\nMODULE_AUTHOR(\"Oracle\");\nMODULE_DESCRIPTION(\"Sun4v LDOM Virtual Switch Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n \nstatic struct vio_version vsw_versions[] = {\n\t{ .major = 1, .minor = 8 },\n\t{ .major = 1, .minor = 7 },\n\t{ .major = 1, .minor = 6 },\n\t{ .major = 1, .minor = 0 },\n};\n\nstatic void vsw_get_drvinfo(struct net_device *dev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\n}\n\nstatic u32 vsw_get_msglevel(struct net_device *dev)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\n\treturn port->vp->msg_enable;\n}\n\nstatic void vsw_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\n\tport->vp->msg_enable = value;\n}\n\nstatic const struct ethtool_ops vsw_ethtool_ops = {\n\t.get_drvinfo\t\t= vsw_get_drvinfo,\n\t.get_msglevel\t\t= vsw_get_msglevel,\n\t.set_msglevel\t\t= vsw_set_msglevel,\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic LIST_HEAD(vnet_list);\nstatic DEFINE_MUTEX(vnet_list_mutex);\n\n \nstatic struct vnet_port *vsw_tx_port_find(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\n\treturn port;\n}\n\nstatic u16 vsw_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    struct net_device *sb_dev)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\n\tif (!port)\n\t\treturn 0;\n\n\treturn port->q_index;\n}\n\n \nstatic netdev_tx_t vsw_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\treturn sunvnet_start_xmit_common(skb, dev, vsw_tx_port_find);\n}\n\nstatic void vsw_set_rx_mode(struct net_device *dev)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\n\treturn sunvnet_set_rx_mode_common(dev, port->vp);\n}\n\nstatic int ldmvsw_open(struct net_device *dev)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\tstruct vio_driver_state *vio = &port->vio;\n\n\t \n\tvio_link_state_change(vio, LDC_EVENT_RESET);\n\tvnet_port_reset(port);\n\tvio_port_up(vio);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void vsw_poll_controller(struct net_device *dev)\n{\n\tstruct vnet_port *port = netdev_priv(dev);\n\n\treturn sunvnet_poll_controller_common(dev, port->vp);\n}\n#endif\n\nstatic const struct net_device_ops vsw_ops = {\n\t.ndo_open\t\t= ldmvsw_open,\n\t.ndo_stop\t\t= sunvnet_close_common,\n\t.ndo_set_rx_mode\t= vsw_set_rx_mode,\n\t.ndo_set_mac_address\t= sunvnet_set_mac_addr_common,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= sunvnet_tx_timeout_common,\n\t.ndo_start_xmit\t\t= vsw_start_xmit,\n\t.ndo_select_queue\t= vsw_select_queue,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller    = vsw_poll_controller,\n#endif\n};\n\nstatic const char *local_mac_prop = \"local-mac-address\";\nstatic const char *cfg_handle_prop = \"cfg-handle\";\n\nstatic struct vnet *vsw_get_vnet(struct mdesc_handle *hp,\n\t\t\t\t u64 port_node,\n\t\t\t\t u64 *handle)\n{\n\tstruct vnet *vp;\n\tstruct vnet *iter;\n\tconst u64 *local_mac = NULL;\n\tconst u64 *cfghandle = NULL;\n\tu64 a;\n\n\t \n\tmdesc_for_each_arc(a, hp, port_node, MDESC_ARC_TYPE_BACK) {\n\t\tu64 target = mdesc_arc_target(hp, a);\n\t\tconst char *name;\n\n\t\tname = mdesc_get_property(hp, target, \"name\", NULL);\n\t\tif (!name || strcmp(name, \"virtual-network-switch\"))\n\t\t\tcontinue;\n\n\t\tlocal_mac = mdesc_get_property(hp, target,\n\t\t\t\t\t       local_mac_prop, NULL);\n\t\tcfghandle = mdesc_get_property(hp, target,\n\t\t\t\t\t       cfg_handle_prop, NULL);\n\t\tbreak;\n\t}\n\tif (!local_mac || !cfghandle)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tvp = NULL;\n\tmutex_lock(&vnet_list_mutex);\n\tlist_for_each_entry(iter, &vnet_list, list) {\n\t\tif (iter->local_mac == *local_mac) {\n\t\t\tvp = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vp) {\n\t\tvp = kzalloc(sizeof(*vp), GFP_KERNEL);\n\t\tif (unlikely(!vp)) {\n\t\t\tmutex_unlock(&vnet_list_mutex);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tspin_lock_init(&vp->lock);\n\t\tINIT_LIST_HEAD(&vp->port_list);\n\t\tINIT_LIST_HEAD(&vp->list);\n\t\tvp->local_mac = *local_mac;\n\t\tlist_add(&vp->list, &vnet_list);\n\t}\n\n\tmutex_unlock(&vnet_list_mutex);\n\n\t*handle = (u64)*cfghandle;\n\n\treturn vp;\n}\n\nstatic struct net_device *vsw_alloc_netdev(u8 hwaddr[],\n\t\t\t\t\t   struct vio_dev *vdev,\n\t\t\t\t\t   u64 handle,\n\t\t\t\t\t   u64 port_id)\n{\n\tstruct net_device *dev;\n\tstruct vnet_port *port;\n\n\tdev = alloc_etherdev_mqs(sizeof(*port), VNET_MAX_TXQS, 1);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdev->needed_headroom = VNET_PACKET_SKIP + 8;\n\tdev->needed_tailroom = 8;\n\n\teth_hw_addr_set(dev, hwaddr);\n\tether_addr_copy(dev->perm_addr, dev->dev_addr);\n\n\tsprintf(dev->name, \"vif%d.%d\", (int)handle, (int)port_id);\n\n\tdev->netdev_ops = &vsw_ops;\n\tdev->ethtool_ops = &vsw_ethtool_ops;\n\tdev->watchdog_timeo = VSW_TX_TIMEOUT;\n\n\tdev->hw_features = NETIF_F_HW_CSUM | NETIF_F_SG;\n\tdev->features = dev->hw_features;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = VNET_MAX_MTU;\n\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\treturn dev;\n}\n\nstatic struct ldc_channel_config vsw_ldc_cfg = {\n\t.event\t\t= sunvnet_event_common,\n\t.mtu\t\t= 64,\n\t.mode\t\t= LDC_MODE_UNRELIABLE,\n};\n\nstatic struct vio_driver_ops vsw_vio_ops = {\n\t.send_attr\t\t= sunvnet_send_attr_common,\n\t.handle_attr\t\t= sunvnet_handle_attr_common,\n\t.handshake_complete\t= sunvnet_handshake_complete_common,\n};\n\nstatic const char *remote_macaddr_prop = \"remote-mac-address\";\nstatic const char *id_prop = \"id\";\n\nstatic int vsw_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\n{\n\tstruct mdesc_handle *hp;\n\tstruct vnet_port *port;\n\tunsigned long flags;\n\tstruct vnet *vp;\n\tstruct net_device *dev;\n\tconst u64 *rmac;\n\tint len, i, err;\n\tconst u64 *port_id;\n\tu64 handle;\n\n\thp = mdesc_grab();\n\n\tif (!hp)\n\t\treturn -ENODEV;\n\n\trmac = mdesc_get_property(hp, vdev->mp, remote_macaddr_prop, &len);\n\terr = -ENODEV;\n\tif (!rmac) {\n\t\tpr_err(\"Port lacks %s property\\n\", remote_macaddr_prop);\n\t\tmdesc_release(hp);\n\t\treturn err;\n\t}\n\n\tport_id = mdesc_get_property(hp, vdev->mp, id_prop, NULL);\n\terr = -ENODEV;\n\tif (!port_id) {\n\t\tpr_err(\"Port lacks %s property\\n\", id_prop);\n\t\tmdesc_release(hp);\n\t\treturn err;\n\t}\n\n\t \n\tvp = vsw_get_vnet(hp, vdev->mp, &handle);\n\tif (IS_ERR(vp)) {\n\t\terr = PTR_ERR(vp);\n\t\tpr_err(\"Failed to get vnet for vsw-port\\n\");\n\t\tmdesc_release(hp);\n\t\treturn err;\n\t}\n\n\tmdesc_release(hp);\n\n\tdev = vsw_alloc_netdev(vsw_port_hwaddr, vdev, handle, *port_id);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tpr_err(\"Failed to alloc netdev for vsw-port\\n\");\n\t\treturn err;\n\t}\n\n\tport = netdev_priv(dev);\n\n\tINIT_LIST_HEAD(&port->list);\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tport->raddr[i] = (*rmac >> (5 - i) * 8) & 0xff;\n\n\tport->vp = vp;\n\tport->dev = dev;\n\tport->switch_port = 1;\n\tport->tso = false;  \n\tport->tsolen = 0;\n\n\t \n\tport->vsw = 1;\n\n\terr = vio_driver_init(&port->vio, vdev, VDEV_NETWORK,\n\t\t\t      vsw_versions, ARRAY_SIZE(vsw_versions),\n\t\t\t      &vsw_vio_ops, dev->name);\n\tif (err)\n\t\tgoto err_out_free_dev;\n\n\terr = vio_ldc_alloc(&port->vio, &vsw_ldc_cfg, port);\n\tif (err)\n\t\tgoto err_out_free_dev;\n\n\tdev_set_drvdata(&vdev->dev, port);\n\n\tnetif_napi_add(dev, &port->napi, sunvnet_poll_common);\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\tlist_add_rcu(&port->list, &vp->port_list);\n\tspin_unlock_irqrestore(&vp->lock, flags);\n\n\ttimer_setup(&port->clean_timer, sunvnet_clean_timer_expire_common, 0);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tpr_err(\"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_del_timer;\n\t}\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\tsunvnet_port_add_txq_common(port);\n\tspin_unlock_irqrestore(&vp->lock, flags);\n\n\tnapi_enable(&port->napi);\n\tvio_port_up(&port->vio);\n\n\t \n\tnetif_carrier_off(dev);\n\n\tnetdev_info(dev, \"LDOM vsw-port %pM\\n\", dev->dev_addr);\n\n\tpr_info(\"%s: PORT ( remote-mac %pM%s )\\n\", dev->name,\n\t\tport->raddr, \" switch-port\");\n\n\treturn 0;\n\nerr_out_del_timer:\n\tdel_timer_sync(&port->clean_timer);\n\tlist_del_rcu(&port->list);\n\tsynchronize_rcu();\n\tnetif_napi_del(&port->napi);\n\tdev_set_drvdata(&vdev->dev, NULL);\n\tvio_ldc_free(&port->vio);\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic void vsw_port_remove(struct vio_dev *vdev)\n{\n\tstruct vnet_port *port = dev_get_drvdata(&vdev->dev);\n\tunsigned long flags;\n\n\tif (port) {\n\t\tdel_timer_sync(&port->vio.timer);\n\t\tdel_timer_sync(&port->clean_timer);\n\n\t\tnapi_disable(&port->napi);\n\t\tunregister_netdev(port->dev);\n\n\t\tlist_del_rcu(&port->list);\n\n\t\tsynchronize_rcu();\n\t\tspin_lock_irqsave(&port->vp->lock, flags);\n\t\tsunvnet_port_rm_txq_common(port);\n\t\tspin_unlock_irqrestore(&port->vp->lock, flags);\n\t\tnetif_napi_del(&port->napi);\n\t\tsunvnet_port_free_tx_bufs_common(port);\n\t\tvio_ldc_free(&port->vio);\n\n\t\tdev_set_drvdata(&vdev->dev, NULL);\n\n\t\tfree_netdev(port->dev);\n\t}\n}\n\nstatic void vsw_cleanup(void)\n{\n\tstruct vnet *vp;\n\n\t \n\tmutex_lock(&vnet_list_mutex);\n\twhile (!list_empty(&vnet_list)) {\n\t\tvp = list_first_entry(&vnet_list, struct vnet, list);\n\t\tlist_del(&vp->list);\n\t\t \n\t\tif (!list_empty(&vp->port_list))\n\t\t\tpr_err(\"Ports not removed by VIO subsystem!\\n\");\n\t\tkfree(vp);\n\t}\n\tmutex_unlock(&vnet_list_mutex);\n}\n\nstatic const struct vio_device_id vsw_port_match[] = {\n\t{\n\t\t.type = \"vsw-port\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(vio, vsw_port_match);\n\nstatic struct vio_driver vsw_port_driver = {\n\t.id_table\t= vsw_port_match,\n\t.probe\t\t= vsw_port_probe,\n\t.remove\t\t= vsw_port_remove,\n\t.name\t\t= \"vsw_port\",\n};\n\nstatic int __init vsw_init(void)\n{\n\tpr_info(\"%s\\n\", version);\n\treturn vio_register_driver(&vsw_port_driver);\n}\n\nstatic void __exit vsw_exit(void)\n{\n\tvio_unregister_driver(&vsw_port_driver);\n\tvsw_cleanup();\n}\n\nmodule_init(vsw_init);\nmodule_exit(vsw_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}