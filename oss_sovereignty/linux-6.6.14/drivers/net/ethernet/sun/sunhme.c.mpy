{
  "module_name": "sunhme.c",
  "hash_id": "0ff5d57041dacc177d051da03f897c48ccf608e23ce0462832cbaa701539725c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/sunhme.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/random.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include <asm/byteorder.h>\n#include <asm/dma.h>\n#include <asm/irq.h>\n\n#ifdef CONFIG_SPARC\n#include <asm/auxio.h>\n#include <asm/idprom.h>\n#include <asm/openprom.h>\n#include <asm/oplib.h>\n#include <asm/prom.h>\n#endif\n\n#include \"sunhme.h\"\n\n#define DRV_NAME\t\"sunhme\"\n\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"Sun HappyMealEthernet(HME) 10/100baseT ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int macaddr[6];\n\n \nmodule_param_array(macaddr, int, NULL, 0);\nMODULE_PARM_DESC(macaddr, \"Happy Meal MAC address to set\");\n\n#ifdef CONFIG_SBUS\nstatic struct quattro *qfe_sbus_list;\n#endif\n\n#ifdef CONFIG_PCI\nstatic struct quattro *qfe_pci_list;\n#endif\n\n#define hme_debug(fmt, ...) pr_debug(\"%s: \" fmt, __func__, ##__VA_ARGS__)\n#define HMD hme_debug\n\n \n#if 1\n#define ASD hme_debug\n#else\n#define ASD(...)\n#endif\n\n#if 0\nstruct hme_tx_logent {\n\tunsigned int tstamp;\n\tint tx_new, tx_old;\n\tunsigned int action;\n#define TXLOG_ACTION_IRQ\t0x01\n#define TXLOG_ACTION_TXMIT\t0x02\n#define TXLOG_ACTION_TBUSY\t0x04\n#define TXLOG_ACTION_NBUFS\t0x08\n\tunsigned int status;\n};\n#define TX_LOG_LEN\t128\nstatic struct hme_tx_logent tx_log[TX_LOG_LEN];\nstatic int txlog_cur_entry;\nstatic __inline__ void tx_add_log(struct happy_meal *hp, unsigned int a, unsigned int s)\n{\n\tstruct hme_tx_logent *tlp;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttlp = &tx_log[txlog_cur_entry];\n\ttlp->tstamp = (unsigned int)jiffies;\n\ttlp->tx_new = hp->tx_new;\n\ttlp->tx_old = hp->tx_old;\n\ttlp->action = a;\n\ttlp->status = s;\n\ttxlog_cur_entry = (txlog_cur_entry + 1) & (TX_LOG_LEN - 1);\n\tlocal_irq_restore(flags);\n}\nstatic __inline__ void tx_dump_log(void)\n{\n\tint i, this;\n\n\tthis = txlog_cur_entry;\n\tfor (i = 0; i < TX_LOG_LEN; i++) {\n\t\tpr_err(\"TXLOG[%d]: j[%08x] tx[N(%d)O(%d)] action[%08x] stat[%08x]\\n\", i,\n\t\t       tx_log[this].tstamp,\n\t\t       tx_log[this].tx_new, tx_log[this].tx_old,\n\t\t       tx_log[this].action, tx_log[this].status);\n\t\tthis = (this + 1) & (TX_LOG_LEN - 1);\n\t}\n}\n#else\n#define tx_add_log(hp, a, s)\n#define tx_dump_log()\n#endif\n\n#define DEFAULT_IPG0      16  \n#define DEFAULT_IPG1       8  \n#define DEFAULT_IPG2       4  \n#define DEFAULT_JAMSIZE    4  \n\n \n\n#if defined(CONFIG_SBUS) && defined(CONFIG_PCI)\nstatic void sbus_hme_write32(void __iomem *reg, u32 val)\n{\n\tsbus_writel(val, reg);\n}\n\nstatic u32 sbus_hme_read32(void __iomem *reg)\n{\n\treturn sbus_readl(reg);\n}\n\nstatic void sbus_hme_write_rxd(struct happy_meal_rxd *rxd, u32 flags, u32 addr)\n{\n\trxd->rx_addr = (__force hme32)addr;\n\tdma_wmb();\n\trxd->rx_flags = (__force hme32)flags;\n}\n\nstatic void sbus_hme_write_txd(struct happy_meal_txd *txd, u32 flags, u32 addr)\n{\n\ttxd->tx_addr = (__force hme32)addr;\n\tdma_wmb();\n\ttxd->tx_flags = (__force hme32)flags;\n}\n\nstatic u32 sbus_hme_read_desc32(hme32 *p)\n{\n\treturn (__force u32)*p;\n}\n\nstatic void pci_hme_write32(void __iomem *reg, u32 val)\n{\n\twritel(val, reg);\n}\n\nstatic u32 pci_hme_read32(void __iomem *reg)\n{\n\treturn readl(reg);\n}\n\nstatic void pci_hme_write_rxd(struct happy_meal_rxd *rxd, u32 flags, u32 addr)\n{\n\trxd->rx_addr = (__force hme32)cpu_to_le32(addr);\n\tdma_wmb();\n\trxd->rx_flags = (__force hme32)cpu_to_le32(flags);\n}\n\nstatic void pci_hme_write_txd(struct happy_meal_txd *txd, u32 flags, u32 addr)\n{\n\ttxd->tx_addr = (__force hme32)cpu_to_le32(addr);\n\tdma_wmb();\n\ttxd->tx_flags = (__force hme32)cpu_to_le32(flags);\n}\n\nstatic u32 pci_hme_read_desc32(hme32 *p)\n{\n\treturn le32_to_cpup((__le32 *)p);\n}\n\n#define hme_write32(__hp, __reg, __val) \\\n\t((__hp)->write32((__reg), (__val)))\n#define hme_read32(__hp, __reg) \\\n\t((__hp)->read32(__reg))\n#define hme_write_rxd(__hp, __rxd, __flags, __addr) \\\n\t((__hp)->write_rxd((__rxd), (__flags), (__addr)))\n#define hme_write_txd(__hp, __txd, __flags, __addr) \\\n\t((__hp)->write_txd((__txd), (__flags), (__addr)))\n#define hme_read_desc32(__hp, __p) \\\n\t((__hp)->read_desc32(__p))\n#else\n#ifdef CONFIG_SBUS\n \n#define hme_write32(__hp, __reg, __val) \\\n\tsbus_writel((__val), (__reg))\n#define hme_read32(__hp, __reg) \\\n\tsbus_readl(__reg)\n#define hme_write_rxd(__hp, __rxd, __flags, __addr) \\\ndo {\t(__rxd)->rx_addr = (__force hme32)(u32)(__addr); \\\n\tdma_wmb(); \\\n\t(__rxd)->rx_flags = (__force hme32)(u32)(__flags); \\\n} while(0)\n#define hme_write_txd(__hp, __txd, __flags, __addr) \\\ndo {\t(__txd)->tx_addr = (__force hme32)(u32)(__addr); \\\n\tdma_wmb(); \\\n\t(__txd)->tx_flags = (__force hme32)(u32)(__flags); \\\n} while(0)\n#define hme_read_desc32(__hp, __p)\t((__force u32)(hme32)*(__p))\n#else\n \n#define hme_write32(__hp, __reg, __val) \\\n\twritel((__val), (__reg))\n#define hme_read32(__hp, __reg) \\\n\treadl(__reg)\n#define hme_write_rxd(__hp, __rxd, __flags, __addr) \\\ndo {\t(__rxd)->rx_addr = (__force hme32)cpu_to_le32(__addr); \\\n\tdma_wmb(); \\\n\t(__rxd)->rx_flags = (__force hme32)cpu_to_le32(__flags); \\\n} while(0)\n#define hme_write_txd(__hp, __txd, __flags, __addr) \\\ndo {\t(__txd)->tx_addr = (__force hme32)cpu_to_le32(__addr); \\\n\tdma_wmb(); \\\n\t(__txd)->tx_flags = (__force hme32)cpu_to_le32(__flags); \\\n} while(0)\nstatic inline u32 hme_read_desc32(struct happy_meal *hp, hme32 *p)\n{\n\treturn le32_to_cpup((__le32 *)p);\n}\n#endif\n#endif\n\n\n \nstatic void BB_PUT_BIT(struct happy_meal *hp, void __iomem *tregs, int bit)\n{\n\thme_write32(hp, tregs + TCVR_BBDATA, bit);\n\thme_write32(hp, tregs + TCVR_BBCLOCK, 0);\n\thme_write32(hp, tregs + TCVR_BBCLOCK, 1);\n}\n\n#if 0\nstatic u32 BB_GET_BIT(struct happy_meal *hp, void __iomem *tregs, int internal)\n{\n\tu32 ret;\n\n\thme_write32(hp, tregs + TCVR_BBCLOCK, 0);\n\thme_write32(hp, tregs + TCVR_BBCLOCK, 1);\n\tret = hme_read32(hp, tregs + TCVR_CFG);\n\tif (internal)\n\t\tret &= TCV_CFG_MDIO0;\n\telse\n\t\tret &= TCV_CFG_MDIO1;\n\n\treturn ret;\n}\n#endif\n\nstatic u32 BB_GET_BIT2(struct happy_meal *hp, void __iomem *tregs, int internal)\n{\n\tu32 retval;\n\n\thme_write32(hp, tregs + TCVR_BBCLOCK, 0);\n\tudelay(1);\n\tretval = hme_read32(hp, tregs + TCVR_CFG);\n\tif (internal)\n\t\tretval &= TCV_CFG_MDIO0;\n\telse\n\t\tretval &= TCV_CFG_MDIO1;\n\thme_write32(hp, tregs + TCVR_BBCLOCK, 1);\n\n\treturn retval;\n}\n\n#define TCVR_FAILURE      0x80000000      \n\nstatic int happy_meal_bb_read(struct happy_meal *hp,\n\t\t\t      void __iomem *tregs, int reg)\n{\n\tu32 tmp;\n\tint retval = 0;\n\tint i;\n\n\t \n\thme_write32(hp, tregs + TCVR_BBOENAB, 1);\n\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tBB_PUT_BIT(hp, tregs, 1);\n\n\t \n\tBB_PUT_BIT(hp, tregs, 0);\n\tBB_PUT_BIT(hp, tregs, 1);\n\tBB_PUT_BIT(hp, tregs, 1);\n\tBB_PUT_BIT(hp, tregs, 0);\n\n\t \n\ttmp = hp->paddr & 0xff;\n\tfor (i = 4; i >= 0; i--)\n\t\tBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\n\n\t \n\ttmp = (reg & 0xff);\n\tfor (i = 4; i >= 0; i--)\n\t\tBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\n\n\t \n\thme_write32(hp, tregs + TCVR_BBOENAB, 0);\n\n\t \n\t(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\n\tfor (i = 15; i >= 0; i--)\n\t\tretval |= BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\n\t(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\n\t(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\n\t(void) BB_GET_BIT2(hp, tregs, (hp->tcvr_type == internal));\n\tASD(\"reg=%d value=%x\\n\", reg, retval);\n\treturn retval;\n}\n\nstatic void happy_meal_bb_write(struct happy_meal *hp,\n\t\t\t\tvoid __iomem *tregs, int reg,\n\t\t\t\tunsigned short value)\n{\n\tu32 tmp;\n\tint i;\n\n\tASD(\"reg=%d value=%x\\n\", reg, value);\n\n\t \n\thme_write32(hp, tregs + TCVR_BBOENAB, 1);\n\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tBB_PUT_BIT(hp, tregs, 1);\n\n\t \n\tBB_PUT_BIT(hp, tregs, 0);\n\tBB_PUT_BIT(hp, tregs, 1);\n\tBB_PUT_BIT(hp, tregs, 0);\n\tBB_PUT_BIT(hp, tregs, 1);\n\n\t \n\ttmp = (hp->paddr & 0xff);\n\tfor (i = 4; i >= 0; i--)\n\t\tBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\n\n\t \n\ttmp = (reg & 0xff);\n\tfor (i = 4; i >= 0; i--)\n\t\tBB_PUT_BIT(hp, tregs, ((tmp >> i) & 1));\n\n\t \n\tBB_PUT_BIT(hp, tregs, 1);\n\tBB_PUT_BIT(hp, tregs, 0);\n\n\tfor (i = 15; i >= 0; i--)\n\t\tBB_PUT_BIT(hp, tregs, ((value >> i) & 1));\n\n\t \n\thme_write32(hp, tregs + TCVR_BBOENAB, 0);\n}\n\n#define TCVR_READ_TRIES   16\n\nstatic int happy_meal_tcvr_read(struct happy_meal *hp,\n\t\t\t\tvoid __iomem *tregs, int reg)\n{\n\tint tries = TCVR_READ_TRIES;\n\tint retval;\n\n\tif (hp->tcvr_type == none) {\n\t\tASD(\"no transceiver, value=TCVR_FAILURE\\n\");\n\t\treturn TCVR_FAILURE;\n\t}\n\n\tif (!(hp->happy_flags & HFLAG_FENABLE)) {\n\t\tASD(\"doing bit bang\\n\");\n\t\treturn happy_meal_bb_read(hp, tregs, reg);\n\t}\n\n\thme_write32(hp, tregs + TCVR_FRAME,\n\t\t    (FRAME_READ | (hp->paddr << 23) | ((reg & 0xff) << 18)));\n\twhile (!(hme_read32(hp, tregs + TCVR_FRAME) & 0x10000) && --tries)\n\t\tudelay(20);\n\tif (!tries) {\n\t\tnetdev_err(hp->dev, \"Aieee, transceiver MIF read bolixed\\n\");\n\t\treturn TCVR_FAILURE;\n\t}\n\tretval = hme_read32(hp, tregs + TCVR_FRAME) & 0xffff;\n\tASD(\"reg=0x%02x value=%04x\\n\", reg, retval);\n\treturn retval;\n}\n\n#define TCVR_WRITE_TRIES  16\n\nstatic void happy_meal_tcvr_write(struct happy_meal *hp,\n\t\t\t\t  void __iomem *tregs, int reg,\n\t\t\t\t  unsigned short value)\n{\n\tint tries = TCVR_WRITE_TRIES;\n\n\tASD(\"reg=0x%02x value=%04x\\n\", reg, value);\n\n\t \n\tif (!(hp->happy_flags & HFLAG_FENABLE)) {\n\t\thappy_meal_bb_write(hp, tregs, reg, value);\n\t\treturn;\n\t}\n\n\t \n\thme_write32(hp, tregs + TCVR_FRAME,\n\t\t    (FRAME_WRITE | (hp->paddr << 23) |\n\t\t     ((reg & 0xff) << 18) | (value & 0xffff)));\n\twhile (!(hme_read32(hp, tregs + TCVR_FRAME) & 0x10000) && --tries)\n\t\tudelay(20);\n\n\t \n\tif (!tries)\n\t\tnetdev_err(hp->dev, \"Aieee, transceiver MIF write bolixed\\n\");\n\n\t \n}\n\n \nstatic int try_next_permutation(struct happy_meal *hp, void __iomem *tregs)\n{\n\thp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\n\t \n\tif (hp->sw_bmcr & BMCR_FULLDPLX) {\n\t\thp->sw_bmcr &= ~(BMCR_FULLDPLX);\n\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\t\treturn 0;\n\t}\n\n\t \n\tif (hp->sw_bmcr & BMCR_SPEED100) {\n\t\thp->sw_bmcr &= ~(BMCR_SPEED100);\n\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\nstatic void display_link_mode(struct happy_meal *hp, void __iomem *tregs)\n{\n\thp->sw_lpa = happy_meal_tcvr_read(hp, tregs, MII_LPA);\n\n\tnetdev_info(hp->dev,\n\t\t    \"Link is up using %s transceiver at %dMb/s, %s Duplex.\\n\",\n\t\t    hp->tcvr_type == external ? \"external\" : \"internal\",\n\t\t    hp->sw_lpa & (LPA_100HALF | LPA_100FULL) ? 100 : 10,\n\t\t    hp->sw_lpa & (LPA_100FULL | LPA_10FULL) ? \"Full\" : \"Half\");\n}\n\nstatic void display_forced_link_mode(struct happy_meal *hp, void __iomem *tregs)\n{\n\thp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\n\tnetdev_info(hp->dev,\n\t\t    \"Link has been forced up using %s transceiver at %dMb/s, %s Duplex.\\n\",\n\t\t    hp->tcvr_type == external ? \"external\" : \"internal\",\n\t\t    hp->sw_bmcr & BMCR_SPEED100 ? 100 : 10,\n\t\t    hp->sw_bmcr & BMCR_FULLDPLX ? \"Full\" : \"Half\");\n}\n\nstatic int set_happy_link_modes(struct happy_meal *hp, void __iomem *tregs)\n{\n\tint full;\n\n\t \n\tif (hp->timer_state == arbwait) {\n\t\thp->sw_lpa = happy_meal_tcvr_read(hp, tregs, MII_LPA);\n\t\tif (!(hp->sw_lpa & (LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL)))\n\t\t\tgoto no_response;\n\t\tif (hp->sw_lpa & LPA_100FULL)\n\t\t\tfull = 1;\n\t\telse if (hp->sw_lpa & LPA_100HALF)\n\t\t\tfull = 0;\n\t\telse if (hp->sw_lpa & LPA_10FULL)\n\t\t\tfull = 1;\n\t\telse\n\t\t\tfull = 0;\n\t} else {\n\t\t \n\t\thp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\tif (hp->sw_bmcr & BMCR_FULLDPLX)\n\t\t\tfull = 1;\n\t\telse\n\t\t\tfull = 0;\n\t}\n\n\t \n\thme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\n\t\t    hme_read32(hp, hp->bigmacregs + BMAC_TXCFG) &\n\t\t    ~(BIGMAC_TXCFG_ENABLE));\n\twhile (hme_read32(hp, hp->bigmacregs + BMAC_TXCFG) & BIGMAC_TXCFG_ENABLE)\n\t\tbarrier();\n\tif (full) {\n\t\thp->happy_flags |= HFLAG_FULL;\n\t\thme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\n\t\t\t    hme_read32(hp, hp->bigmacregs + BMAC_TXCFG) |\n\t\t\t    BIGMAC_TXCFG_FULLDPLX);\n\t} else {\n\t\thp->happy_flags &= ~(HFLAG_FULL);\n\t\thme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\n\t\t\t    hme_read32(hp, hp->bigmacregs + BMAC_TXCFG) &\n\t\t\t    ~(BIGMAC_TXCFG_FULLDPLX));\n\t}\n\thme_write32(hp, hp->bigmacregs + BMAC_TXCFG,\n\t\t    hme_read32(hp, hp->bigmacregs + BMAC_TXCFG) |\n\t\t    BIGMAC_TXCFG_ENABLE);\n\treturn 0;\nno_response:\n\treturn 1;\n}\n\nstatic int is_lucent_phy(struct happy_meal *hp)\n{\n\tvoid __iomem *tregs = hp->tcvregs;\n\tunsigned short mr2, mr3;\n\tint ret = 0;\n\n\tmr2 = happy_meal_tcvr_read(hp, tregs, 2);\n\tmr3 = happy_meal_tcvr_read(hp, tregs, 3);\n\tif ((mr2 & 0xffff) == 0x0180 &&\n\t    ((mr3 & 0xffff) >> 10) == 0x1d)\n\t\tret = 1;\n\n\treturn ret;\n}\n\n \nstatic void\nhappy_meal_begin_auto_negotiation(struct happy_meal *hp,\n\t\t\t\t  void __iomem *tregs,\n\t\t\t\t  const struct ethtool_link_ksettings *ep)\n{\n\tint timeout;\n\n\t \n\thp->sw_bmsr      = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\n\thp->sw_bmcr      = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\thp->sw_physid1   = happy_meal_tcvr_read(hp, tregs, MII_PHYSID1);\n\thp->sw_physid2   = happy_meal_tcvr_read(hp, tregs, MII_PHYSID2);\n\n\t \n\n\thp->sw_advertise = happy_meal_tcvr_read(hp, tregs, MII_ADVERTISE);\n\tif (!ep || ep->base.autoneg == AUTONEG_ENABLE) {\n\t\t \n\t\tif (hp->sw_bmsr & BMSR_10HALF)\n\t\t\thp->sw_advertise |= (ADVERTISE_10HALF);\n\t\telse\n\t\t\thp->sw_advertise &= ~(ADVERTISE_10HALF);\n\n\t\tif (hp->sw_bmsr & BMSR_10FULL)\n\t\t\thp->sw_advertise |= (ADVERTISE_10FULL);\n\t\telse\n\t\t\thp->sw_advertise &= ~(ADVERTISE_10FULL);\n\t\tif (hp->sw_bmsr & BMSR_100HALF)\n\t\t\thp->sw_advertise |= (ADVERTISE_100HALF);\n\t\telse\n\t\t\thp->sw_advertise &= ~(ADVERTISE_100HALF);\n\t\tif (hp->sw_bmsr & BMSR_100FULL)\n\t\t\thp->sw_advertise |= (ADVERTISE_100FULL);\n\t\telse\n\t\t\thp->sw_advertise &= ~(ADVERTISE_100FULL);\n\t\thappy_meal_tcvr_write(hp, tregs, MII_ADVERTISE, hp->sw_advertise);\n\n\t\t \n\n\t\tASD(\"Advertising [ %s%s%s%s]\\n\",\n\t\t    hp->sw_advertise & ADVERTISE_10HALF ? \"10H \" : \"\",\n\t\t    hp->sw_advertise & ADVERTISE_10FULL ? \"10F \" : \"\",\n\t\t    hp->sw_advertise & ADVERTISE_100HALF ? \"100H \" : \"\",\n\t\t    hp->sw_advertise & ADVERTISE_100FULL ? \"100F \" : \"\");\n\n\t\t \n\t\thp->sw_bmcr |= BMCR_ANENABLE;\n\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\n\t\t \n\t\thp->sw_bmcr |= BMCR_ANRESTART;\n\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\n\t\t \n\n\t\ttimeout = 64;   \n\t\twhile (--timeout) {\n\t\t\thp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\t\tif (!(hp->sw_bmcr & BMCR_ANRESTART))\n\t\t\t\tbreak;  \n\t\t\tudelay(10);\n\t\t}\n\t\tif (!timeout) {\n\t\t\tnetdev_err(hp->dev,\n\t\t\t\t   \"Happy Meal would not start auto negotiation BMCR=0x%04x\\n\",\n\t\t\t\t   hp->sw_bmcr);\n\t\t\tnetdev_notice(hp->dev,\n\t\t\t\t      \"Performing force link detection.\\n\");\n\t\t\tgoto force_link;\n\t\t} else {\n\t\t\thp->timer_state = arbwait;\n\t\t}\n\t} else {\nforce_link:\n\t\t \n\n\t\t \n\t\tif (!ep || ep->base.autoneg == AUTONEG_ENABLE) {\n\t\t\thp->sw_bmcr = BMCR_SPEED100;\n\t\t} else {\n\t\t\tif (ep->base.speed == SPEED_100)\n\t\t\t\thp->sw_bmcr = BMCR_SPEED100;\n\t\t\telse\n\t\t\t\thp->sw_bmcr = 0;\n\t\t\tif (ep->base.duplex == DUPLEX_FULL)\n\t\t\t\thp->sw_bmcr |= BMCR_FULLDPLX;\n\t\t}\n\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\n\t\tif (!is_lucent_phy(hp)) {\n\t\t\t \n\t\t\thp->sw_csconfig = happy_meal_tcvr_read(hp, tregs,\n\t\t\t\t\t\t\t       DP83840_CSCONFIG);\n\t\t\thp->sw_csconfig &= ~(CSCONFIG_TCVDISAB);\n\t\t\thappy_meal_tcvr_write(hp, tregs, DP83840_CSCONFIG,\n\t\t\t\t\t      hp->sw_csconfig);\n\t\t}\n\t\thp->timer_state = ltrywait;\n\t}\n\n\thp->timer_ticks = 0;\n\thp->happy_timer.expires = jiffies + (12 * HZ)/10;   \n\tadd_timer(&hp->happy_timer);\n}\n\nstatic void happy_meal_timer(struct timer_list *t)\n{\n\tstruct happy_meal *hp = from_timer(hp, t, happy_timer);\n\tvoid __iomem *tregs = hp->tcvregs;\n\tint restart_timer = 0;\n\n\tspin_lock_irq(&hp->happy_lock);\n\n\thp->timer_ticks++;\n\tswitch(hp->timer_state) {\n\tcase arbwait:\n\t\t \n\t\tif (hp->timer_ticks >= 10) {\n\t\t\t \n\tdo_force_mode:\n\t\t\thp->sw_bmcr = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\t\tnetdev_notice(hp->dev,\n\t\t\t\t      \"Auto-Negotiation unsuccessful, trying force link mode\\n\");\n\t\t\thp->sw_bmcr = BMCR_SPEED100;\n\t\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\n\t\t\tif (!is_lucent_phy(hp)) {\n\t\t\t\t \n\t\t\t\thp->sw_csconfig = happy_meal_tcvr_read(hp, tregs, DP83840_CSCONFIG);\n\t\t\t\thp->sw_csconfig &= ~(CSCONFIG_TCVDISAB);\n\t\t\t\thappy_meal_tcvr_write(hp, tregs, DP83840_CSCONFIG, hp->sw_csconfig);\n\t\t\t}\n\t\t\thp->timer_state = ltrywait;\n\t\t\thp->timer_ticks = 0;\n\t\t\trestart_timer = 1;\n\t\t} else {\n\t\t\t \n\t\t\thp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\n\t\t\tif (hp->sw_bmsr & BMSR_ANEGCOMPLETE) {\n\t\t\t\tint ret;\n\n\t\t\t\t \n\t\t\t\tret = set_happy_link_modes(hp, tregs);\n\t\t\t\tif (ret) {\n\t\t\t\t\t \n\t\t\t\t\tgoto do_force_mode;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\thp->timer_state = lupwait;\n\t\t\t\trestart_timer = 1;\n\t\t\t} else {\n\t\t\t\trestart_timer = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase lupwait:\n\t\t \n\t\thp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\n\t\tif (hp->sw_bmsr & BMSR_LSTATUS) {\n\t\t\t \n\t\t\tdisplay_link_mode(hp, tregs);\n\t\t\thp->timer_state = asleep;\n\t\t\trestart_timer = 0;\n\t\t} else {\n\t\t\tif (hp->timer_ticks >= 10) {\n\t\t\t\tnetdev_notice(hp->dev,\n\t\t\t\t\t      \"Auto negotiation successful, link still not completely up.\\n\");\n\t\t\t\thp->timer_ticks = 0;\n\t\t\t\trestart_timer = 1;\n\t\t\t} else {\n\t\t\t\trestart_timer = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ltrywait:\n\t\t \n\t\thp->sw_bmsr = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\n\t\thp->sw_csconfig = happy_meal_tcvr_read(hp, tregs, DP83840_CSCONFIG);\n\t\tif (hp->timer_ticks == 1) {\n\t\t\tif (!is_lucent_phy(hp)) {\n\t\t\t\t \n\t\t\t\thp->sw_csconfig |= CSCONFIG_TCVDISAB;\n\t\t\t\thappy_meal_tcvr_write(hp, tregs,\n\t\t\t\t\t\t      DP83840_CSCONFIG, hp->sw_csconfig);\n\t\t\t}\n\t\t\trestart_timer = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (hp->timer_ticks == 2) {\n\t\t\tif (!is_lucent_phy(hp)) {\n\t\t\t\thp->sw_csconfig &= ~(CSCONFIG_TCVDISAB);\n\t\t\t\thappy_meal_tcvr_write(hp, tregs,\n\t\t\t\t\t\t      DP83840_CSCONFIG, hp->sw_csconfig);\n\t\t\t}\n\t\t\trestart_timer = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (hp->sw_bmsr & BMSR_LSTATUS) {\n\t\t\t \n\t\t\tdisplay_forced_link_mode(hp, tregs);\n\t\t\tset_happy_link_modes(hp, tregs);  \n\t\t\thp->timer_state = asleep;\n\t\t\trestart_timer = 0;\n\t\t} else {\n\t\t\tif (hp->timer_ticks >= 4) {  \n\t\t\t\tint ret;\n\n\t\t\t\tret = try_next_permutation(hp, tregs);\n\t\t\t\tif (ret == -1) {\n\t\t\t\t\t \n\n\t\t\t\t\t \n\t\t\t\t\tnetdev_notice(hp->dev,\n\t\t\t\t\t\t      \"Link down, cable problem?\\n\");\n\n\t\t\t\t\thappy_meal_begin_auto_negotiation(hp, tregs, NULL);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!is_lucent_phy(hp)) {\n\t\t\t\t\thp->sw_csconfig = happy_meal_tcvr_read(hp, tregs,\n\t\t\t\t\t\t\t\t\t       DP83840_CSCONFIG);\n\t\t\t\t\thp->sw_csconfig |= CSCONFIG_TCVDISAB;\n\t\t\t\t\thappy_meal_tcvr_write(hp, tregs,\n\t\t\t\t\t\t\t      DP83840_CSCONFIG, hp->sw_csconfig);\n\t\t\t\t}\n\t\t\t\thp->timer_ticks = 0;\n\t\t\t\trestart_timer = 1;\n\t\t\t} else {\n\t\t\t\trestart_timer = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase asleep:\n\tdefault:\n\t\t \n\t\tnetdev_err(hp->dev,\n\t\t\t   \"Aieee, link timer is asleep but we got one anyways!\\n\");\n\t\trestart_timer = 0;\n\t\thp->timer_ticks = 0;\n\t\thp->timer_state = asleep;  \n\t\tbreak;\n\t}\n\n\tif (restart_timer) {\n\t\thp->happy_timer.expires = jiffies + ((12 * HZ)/10);  \n\t\tadd_timer(&hp->happy_timer);\n\t}\n\nout:\n\tspin_unlock_irq(&hp->happy_lock);\n}\n\n#define TX_RESET_TRIES     32\n#define RX_RESET_TRIES     32\n\n \nstatic void happy_meal_tx_reset(struct happy_meal *hp, void __iomem *bregs)\n{\n\tint tries = TX_RESET_TRIES;\n\n\tHMD(\"reset...\\n\");\n\n\t \n\thme_write32(hp, bregs + BMAC_TXSWRESET, 0);\n\twhile ((hme_read32(hp, bregs + BMAC_TXSWRESET) & 1) && --tries)\n\t\tudelay(20);\n\n\t \n\tif (!tries)\n\t\tnetdev_err(hp->dev, \"Transceiver BigMac ATTACK!\");\n\n\t \n\tHMD(\"done\\n\");\n}\n\n \nstatic void happy_meal_rx_reset(struct happy_meal *hp, void __iomem *bregs)\n{\n\tint tries = RX_RESET_TRIES;\n\n\tHMD(\"reset...\\n\");\n\n\t \n\thme_write32(hp, bregs + BMAC_RXSWRESET, 0);\n\twhile ((hme_read32(hp, bregs + BMAC_RXSWRESET) & 1) && --tries)\n\t\tudelay(20);\n\n\t \n\tif (!tries)\n\t\tnetdev_err(hp->dev, \"Receiver BigMac ATTACK!\\n\");\n\n\t \n\tHMD(\"done\\n\");\n}\n\n#define STOP_TRIES         16\n\n \nstatic void happy_meal_stop(struct happy_meal *hp, void __iomem *gregs)\n{\n\tint tries = STOP_TRIES;\n\n\tHMD(\"reset...\\n\");\n\n\t \n\thme_write32(hp, gregs + GREG_SWRESET, GREG_RESET_ALL);\n\twhile (hme_read32(hp, gregs + GREG_SWRESET) && --tries)\n\t\tudelay(20);\n\n\t \n\tif (!tries)\n\t\tnetdev_err(hp->dev, \"Fry guys.\\n\");\n\n\t \n\tHMD(\"done\\n\");\n}\n\n \nstatic void happy_meal_get_counters(struct happy_meal *hp, void __iomem *bregs)\n{\n\tstruct net_device_stats *stats = &hp->dev->stats;\n\n\tstats->rx_crc_errors += hme_read32(hp, bregs + BMAC_RCRCECTR);\n\thme_write32(hp, bregs + BMAC_RCRCECTR, 0);\n\n\tstats->rx_frame_errors += hme_read32(hp, bregs + BMAC_UNALECTR);\n\thme_write32(hp, bregs + BMAC_UNALECTR, 0);\n\n\tstats->rx_length_errors += hme_read32(hp, bregs + BMAC_GLECTR);\n\thme_write32(hp, bregs + BMAC_GLECTR, 0);\n\n\tstats->tx_aborted_errors += hme_read32(hp, bregs + BMAC_EXCTR);\n\n\tstats->collisions +=\n\t\t(hme_read32(hp, bregs + BMAC_EXCTR) +\n\t\t hme_read32(hp, bregs + BMAC_LTCTR));\n\thme_write32(hp, bregs + BMAC_EXCTR, 0);\n\thme_write32(hp, bregs + BMAC_LTCTR, 0);\n}\n\n \n#define TCVR_RESET_TRIES       16  \n#define TCVR_UNISOLATE_TRIES   32  \n\n \nstatic int happy_meal_tcvr_reset(struct happy_meal *hp, void __iomem *tregs)\n{\n\tu32 tconfig;\n\tint result, tries = TCVR_RESET_TRIES;\n\n\ttconfig = hme_read32(hp, tregs + TCVR_CFG);\n\tASD(\"tcfg=%08x\\n\", tconfig);\n\tif (hp->tcvr_type == external) {\n\t\thme_write32(hp, tregs + TCVR_CFG, tconfig & ~(TCV_CFG_PSELECT));\n\t\thp->tcvr_type = internal;\n\t\thp->paddr = TCV_PADDR_ITX;\n\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR,\n\t\t\t\t      (BMCR_LOOPBACK|BMCR_PDOWN|BMCR_ISOLATE));\n\t\tresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\tif (result == TCVR_FAILURE) {\n\t\t\tASD(\"phyread_fail\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tASD(\"external: ISOLATE, phyread_ok, PSELECT\\n\");\n\t\thme_write32(hp, tregs + TCVR_CFG, tconfig | TCV_CFG_PSELECT);\n\t\thp->tcvr_type = external;\n\t\thp->paddr = TCV_PADDR_ETX;\n\t} else {\n\t\tif (tconfig & TCV_CFG_MDIO1) {\n\t\t\thme_write32(hp, tregs + TCVR_CFG, (tconfig | TCV_CFG_PSELECT));\n\t\t\thappy_meal_tcvr_write(hp, tregs, MII_BMCR,\n\t\t\t\t\t      (BMCR_LOOPBACK|BMCR_PDOWN|BMCR_ISOLATE));\n\t\t\tresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\t\tif (result == TCVR_FAILURE) {\n\t\t\t\tASD(\"phyread_fail>\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tASD(\"internal: PSELECT, ISOLATE, phyread_ok, ~PSELECT\\n\");\n\t\t\thme_write32(hp, tregs + TCVR_CFG, (tconfig & ~(TCV_CFG_PSELECT)));\n\t\t\thp->tcvr_type = internal;\n\t\t\thp->paddr = TCV_PADDR_ITX;\n\t\t}\n\t}\n\n\tASD(\"BMCR_RESET...\\n\");\n\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, BMCR_RESET);\n\n\twhile (--tries) {\n\t\tresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\tif (result == TCVR_FAILURE)\n\t\t\treturn -1;\n\t\thp->sw_bmcr = result;\n\t\tif (!(result & BMCR_RESET))\n\t\t\tbreak;\n\t\tudelay(20);\n\t}\n\tif (!tries) {\n\t\tASD(\"BMCR RESET FAILED!\\n\");\n\t\treturn -1;\n\t}\n\tASD(\"RESET_OK\\n\");\n\n\t \n\thp->sw_bmsr      = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\n\thp->sw_physid1   = happy_meal_tcvr_read(hp, tregs, MII_PHYSID1);\n\thp->sw_physid2   = happy_meal_tcvr_read(hp, tregs, MII_PHYSID2);\n\thp->sw_advertise = happy_meal_tcvr_read(hp, tregs, MII_ADVERTISE);\n\n\tASD(\"UNISOLATE...\\n\");\n\thp->sw_bmcr &= ~(BMCR_ISOLATE);\n\thappy_meal_tcvr_write(hp, tregs, MII_BMCR, hp->sw_bmcr);\n\n\ttries = TCVR_UNISOLATE_TRIES;\n\twhile (--tries) {\n\t\tresult = happy_meal_tcvr_read(hp, tregs, MII_BMCR);\n\t\tif (result == TCVR_FAILURE)\n\t\t\treturn -1;\n\t\tif (!(result & BMCR_ISOLATE))\n\t\t\tbreak;\n\t\tudelay(20);\n\t}\n\tif (!tries) {\n\t\tASD(\"UNISOLATE FAILED!\\n\");\n\t\treturn -1;\n\t}\n\tASD(\"SUCCESS and CSCONFIG_DFBYPASS\\n\");\n\tif (!is_lucent_phy(hp)) {\n\t\tresult = happy_meal_tcvr_read(hp, tregs,\n\t\t\t\t\t      DP83840_CSCONFIG);\n\t\thappy_meal_tcvr_write(hp, tregs,\n\t\t\t\t      DP83840_CSCONFIG, (result | CSCONFIG_DFBYPASS));\n\t}\n\treturn 0;\n}\n\n \nstatic void happy_meal_transceiver_check(struct happy_meal *hp, void __iomem *tregs)\n{\n\tunsigned long tconfig = hme_read32(hp, tregs + TCVR_CFG);\n\tu32 reread = hme_read32(hp, tregs + TCVR_CFG);\n\n\tASD(\"tcfg=%08lx\\n\", tconfig);\n\tif (reread & TCV_CFG_MDIO1) {\n\t\thme_write32(hp, tregs + TCVR_CFG, tconfig | TCV_CFG_PSELECT);\n\t\thp->paddr = TCV_PADDR_ETX;\n\t\thp->tcvr_type = external;\n\t\tASD(\"not polling, external\\n\");\n\t} else {\n\t\tif (reread & TCV_CFG_MDIO0) {\n\t\t\thme_write32(hp, tregs + TCVR_CFG,\n\t\t\t\t    tconfig & ~(TCV_CFG_PSELECT));\n\t\t\thp->paddr = TCV_PADDR_ITX;\n\t\t\thp->tcvr_type = internal;\n\t\t\tASD(\"not polling, internal\\n\");\n\t\t} else {\n\t\t\tnetdev_err(hp->dev,\n\t\t\t\t   \"Transceiver and a coke please.\");\n\t\t\thp->tcvr_type = none;  \n\t\t\tASD(\"not polling, none\\n\");\n\t\t}\n\t}\n}\n\n \nstatic void happy_meal_clean_rings(struct happy_meal *hp)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (hp->rx_skbs[i] != NULL) {\n\t\t\tstruct sk_buff *skb = hp->rx_skbs[i];\n\t\t\tstruct happy_meal_rxd *rxd;\n\t\t\tu32 dma_addr;\n\n\t\t\trxd = &hp->happy_block->happy_meal_rxd[i];\n\t\t\tdma_addr = hme_read_desc32(hp, &rxd->rx_addr);\n\t\t\tdma_unmap_single(hp->dma_dev, dma_addr,\n\t\t\t\t\t RX_BUF_ALLOC_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\thp->rx_skbs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tif (hp->tx_skbs[i] != NULL) {\n\t\t\tstruct sk_buff *skb = hp->tx_skbs[i];\n\t\t\tstruct happy_meal_txd *txd;\n\t\t\tu32 dma_addr;\n\t\t\tint frag;\n\n\t\t\thp->tx_skbs[i] = NULL;\n\n\t\t\tfor (frag = 0; frag <= skb_shinfo(skb)->nr_frags; frag++) {\n\t\t\t\ttxd = &hp->happy_block->happy_meal_txd[i];\n\t\t\t\tdma_addr = hme_read_desc32(hp, &txd->tx_addr);\n\t\t\t\tif (!frag)\n\t\t\t\t\tdma_unmap_single(hp->dma_dev, dma_addr,\n\t\t\t\t\t\t\t (hme_read_desc32(hp, &txd->tx_flags)\n\t\t\t\t\t\t\t  & TXFLAG_SIZE),\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\telse\n\t\t\t\t\tdma_unmap_page(hp->dma_dev, dma_addr,\n\t\t\t\t\t\t\t (hme_read_desc32(hp, &txd->tx_flags)\n\t\t\t\t\t\t\t  & TXFLAG_SIZE),\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\t\tif (frag != skb_shinfo(skb)->nr_frags)\n\t\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t}\n}\n\n \nstatic void happy_meal_init_rings(struct happy_meal *hp)\n{\n\tstruct hmeal_init_block *hb = hp->happy_block;\n\tint i;\n\n\tHMD(\"counters to zero\\n\");\n\thp->rx_new = hp->rx_old = hp->tx_new = hp->tx_old = 0;\n\n\t \n\thappy_meal_clean_rings(hp);\n\n\t \n\tHMD(\"init rxring\\n\");\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb;\n\t\tu32 mapping;\n\n\t\tskb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\thme_write_rxd(hp, &hb->happy_meal_rxd[i], 0, 0);\n\t\t\tcontinue;\n\t\t}\n\t\thp->rx_skbs[i] = skb;\n\n\t\t \n\t\tskb_put(skb, (ETH_FRAME_LEN + RX_OFFSET + 4));\n\t\tmapping = dma_map_single(hp->dma_dev, skb->data, RX_BUF_ALLOC_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(hp->dma_dev, mapping)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\thme_write_rxd(hp, &hb->happy_meal_rxd[i], 0, 0);\n\t\t\tcontinue;\n\t\t}\n\t\thme_write_rxd(hp, &hb->happy_meal_rxd[i],\n\t\t\t      (RXFLAG_OWN | ((RX_BUF_ALLOC_SIZE - RX_OFFSET) << 16)),\n\t\t\t      mapping);\n\t\tskb_reserve(skb, RX_OFFSET);\n\t}\n\n\tHMD(\"init txring\\n\");\n\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\thme_write_txd(hp, &hb->happy_meal_txd[i], 0, 0);\n\n\tHMD(\"done\\n\");\n}\n\n \nstatic int happy_meal_init(struct happy_meal *hp)\n{\n\tconst unsigned char *e = &hp->dev->dev_addr[0];\n\tvoid __iomem *gregs        = hp->gregs;\n\tvoid __iomem *etxregs      = hp->etxregs;\n\tvoid __iomem *erxregs      = hp->erxregs;\n\tvoid __iomem *bregs        = hp->bigmacregs;\n\tvoid __iomem *tregs        = hp->tcvregs;\n\tconst char *bursts = \"64\";\n\tu32 regtmp, rxcfg;\n\n\t \n\tdel_timer(&hp->happy_timer);\n\n\tHMD(\"happy_flags[%08x]\\n\", hp->happy_flags);\n\tif (!(hp->happy_flags & HFLAG_INIT)) {\n\t\tHMD(\"set HFLAG_INIT\\n\");\n\t\thp->happy_flags |= HFLAG_INIT;\n\t\thappy_meal_get_counters(hp, bregs);\n\t}\n\n\t \n\tHMD(\"to happy_meal_stop\\n\");\n\thappy_meal_stop(hp, gregs);\n\n\t \n\tHMD(\"to happy_meal_init_rings\\n\");\n\thappy_meal_init_rings(hp);\n\n\t \n\tif (hp->happy_flags & HFLAG_FENABLE) {\n\t\tHMD(\"use frame old[%08x]\\n\",\n\t\t    hme_read32(hp, tregs + TCVR_CFG));\n\t\thme_write32(hp, tregs + TCVR_CFG,\n\t\t\t    hme_read32(hp, tregs + TCVR_CFG) & ~(TCV_CFG_BENABLE));\n\t} else {\n\t\tHMD(\"use bitbang old[%08x]\\n\",\n\t\t    hme_read32(hp, tregs + TCVR_CFG));\n\t\thme_write32(hp, tregs + TCVR_CFG,\n\t\t\t    hme_read32(hp, tregs + TCVR_CFG) | TCV_CFG_BENABLE);\n\t}\n\n\t \n\tHMD(\"to happy_meal_transceiver_check\\n\");\n\thappy_meal_transceiver_check(hp, tregs);\n\n\t \n\tswitch(hp->tcvr_type) {\n\tcase none:\n\t\t \n\t\tHMD(\"AAIEEE no transceiver type, EAGAIN\\n\");\n\t\treturn -EAGAIN;\n\n\tcase internal:\n\t\t \n\t\tHMD(\"internal, using MII\\n\");\n\t\thme_write32(hp, bregs + BMAC_XIFCFG, 0);\n\t\tbreak;\n\n\tcase external:\n\t\t \n\t\tHMD(\"external, disable MII\\n\");\n\t\thme_write32(hp, bregs + BMAC_XIFCFG, BIGMAC_XCFG_MIIDISAB);\n\t\tbreak;\n\t}\n\n\tif (happy_meal_tcvr_reset(hp, tregs))\n\t\treturn -EAGAIN;\n\n\t \n\tHMD(\"tx/rx reset\\n\");\n\thappy_meal_tx_reset(hp, bregs);\n\thappy_meal_rx_reset(hp, bregs);\n\n\t \n\thme_write32(hp, bregs + BMAC_JSIZE, DEFAULT_JAMSIZE);\n\thme_write32(hp, bregs + BMAC_IGAP1, DEFAULT_IPG1);\n\thme_write32(hp, bregs + BMAC_IGAP2, DEFAULT_IPG2);\n\n\t \n\n\t \n\thme_write32(hp, bregs + BMAC_RSEED, ((e[5] | e[4]<<8)&0x3ff));\n\n\thme_write32(hp, bregs + BMAC_MACADDR2, ((e[4] << 8) | e[5]));\n\thme_write32(hp, bregs + BMAC_MACADDR1, ((e[2] << 8) | e[3]));\n\thme_write32(hp, bregs + BMAC_MACADDR0, ((e[0] << 8) | e[1]));\n\n\tif ((hp->dev->flags & IFF_ALLMULTI) ||\n\t    (netdev_mc_count(hp->dev) > 64)) {\n\t\thme_write32(hp, bregs + BMAC_HTABLE0, 0xffff);\n\t\thme_write32(hp, bregs + BMAC_HTABLE1, 0xffff);\n\t\thme_write32(hp, bregs + BMAC_HTABLE2, 0xffff);\n\t\thme_write32(hp, bregs + BMAC_HTABLE3, 0xffff);\n\t} else if ((hp->dev->flags & IFF_PROMISC) == 0) {\n\t\tu16 hash_table[4];\n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 crc;\n\n\t\tmemset(hash_table, 0, sizeof(hash_table));\n\t\tnetdev_for_each_mc_addr(ha, hp->dev) {\n\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t\thme_write32(hp, bregs + BMAC_HTABLE0, hash_table[0]);\n\t\thme_write32(hp, bregs + BMAC_HTABLE1, hash_table[1]);\n\t\thme_write32(hp, bregs + BMAC_HTABLE2, hash_table[2]);\n\t\thme_write32(hp, bregs + BMAC_HTABLE3, hash_table[3]);\n\t} else {\n\t\thme_write32(hp, bregs + BMAC_HTABLE3, 0);\n\t\thme_write32(hp, bregs + BMAC_HTABLE2, 0);\n\t\thme_write32(hp, bregs + BMAC_HTABLE1, 0);\n\t\thme_write32(hp, bregs + BMAC_HTABLE0, 0);\n\t}\n\n\t \n\tHMD(\"ring ptrs rxr[%08x] txr[%08x]\\n\",\n\t    ((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0)),\n\t    ((__u32)hp->hblock_dvma + hblock_offset(happy_meal_txd, 0)));\n\thme_write32(hp, erxregs + ERX_RING,\n\t\t    ((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0)));\n\thme_write32(hp, etxregs + ETX_RING,\n\t\t    ((__u32)hp->hblock_dvma + hblock_offset(happy_meal_txd, 0)));\n\n\t \n\tif (hme_read32(hp, erxregs + ERX_RING) !=\n\t    ((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0)))\n\t\thme_write32(hp, erxregs + ERX_RING,\n\t\t\t    ((__u32)hp->hblock_dvma + hblock_offset(happy_meal_rxd, 0))\n\t\t\t    | 0x4);\n\n\t \n#ifndef CONFIG_SPARC\n\t \n\thme_write32(hp, gregs + GREG_CFG, GREG_CFG_BURST64);\n#else\n\tif ((hp->happy_bursts & DMA_BURST64) &&\n\t    ((hp->happy_flags & HFLAG_PCI) != 0\n#ifdef CONFIG_SBUS\n\t     || sbus_can_burst64()\n#endif\n\t     || 0)) {\n\t\tu32 gcfg = GREG_CFG_BURST64;\n\n\t\t \n#ifdef CONFIG_SBUS\n\t\tif ((hp->happy_flags & HFLAG_PCI) == 0) {\n\t\t\tstruct platform_device *op = hp->happy_dev;\n\t\t\tif (sbus_can_dma_64bit()) {\n\t\t\t\tsbus_set_sbus64(&op->dev,\n\t\t\t\t\t\thp->happy_bursts);\n\t\t\t\tgcfg |= GREG_CFG_64BIT;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tbursts = \"64\";\n\t\thme_write32(hp, gregs + GREG_CFG, gcfg);\n\t} else if (hp->happy_bursts & DMA_BURST32) {\n\t\tbursts = \"32\";\n\t\thme_write32(hp, gregs + GREG_CFG, GREG_CFG_BURST32);\n\t} else if (hp->happy_bursts & DMA_BURST16) {\n\t\tbursts = \"16\";\n\t\thme_write32(hp, gregs + GREG_CFG, GREG_CFG_BURST16);\n\t} else {\n\t\tbursts = \"XXX\";\n\t\thme_write32(hp, gregs + GREG_CFG, 0);\n\t}\n#endif  \n\n\tHMD(\"old[%08x] bursts<%s>\\n\",\n\t    hme_read32(hp, gregs + GREG_CFG), bursts);\n\n\t \n\thme_write32(hp, gregs + GREG_IMASK,\n\t\t    (GREG_IMASK_GOTFRAME | GREG_IMASK_RCNTEXP |\n\t\t     GREG_IMASK_SENTFRAME | GREG_IMASK_TXPERR));\n\n\t \n\tHMD(\"tx rsize=%d oreg[%08x]\\n\", (int)TX_RING_SIZE,\n\t    hme_read32(hp, etxregs + ETX_RSIZE));\n\thme_write32(hp, etxregs + ETX_RSIZE, (TX_RING_SIZE >> ETX_RSIZE_SHIFT) - 1);\n\n\t \n\tHMD(\"tx dma enable old[%08x]\\n\", hme_read32(hp, etxregs + ETX_CFG));\n\thme_write32(hp, etxregs + ETX_CFG,\n\t\t    hme_read32(hp, etxregs + ETX_CFG) | ETX_CFG_DMAENABLE);\n\n\t \n\tHMD(\"erx regs bug old[%08x]\\n\",\n\t    hme_read32(hp, erxregs + ERX_CFG));\n\thme_write32(hp, erxregs + ERX_CFG, ERX_CFG_DEFAULT(RX_OFFSET));\n\tregtmp = hme_read32(hp, erxregs + ERX_CFG);\n\thme_write32(hp, erxregs + ERX_CFG, ERX_CFG_DEFAULT(RX_OFFSET));\n\tif (hme_read32(hp, erxregs + ERX_CFG) != ERX_CFG_DEFAULT(RX_OFFSET)) {\n\t\tnetdev_err(hp->dev,\n\t\t\t   \"Eieee, rx config register gets greasy fries.\\n\");\n\t\tnetdev_err(hp->dev,\n\t\t\t   \"Trying to set %08x, reread gives %08x\\n\",\n\t\t\t   ERX_CFG_DEFAULT(RX_OFFSET), regtmp);\n\t\t \n\t}\n\n\t \n\tHMD(\"enable hash rx_cfg_old[%08x]\\n\",\n\t    hme_read32(hp, bregs + BMAC_RXCFG));\n\trxcfg = BIGMAC_RXCFG_HENABLE | BIGMAC_RXCFG_REJME;\n\tif (hp->dev->flags & IFF_PROMISC)\n\t\trxcfg |= BIGMAC_RXCFG_PMISC;\n\thme_write32(hp, bregs + BMAC_RXCFG, rxcfg);\n\n\t \n\tudelay(10);\n\n\t \n\tHMD(\"BIGMAC init\\n\");\n\tregtmp = 0;\n\tif (hp->happy_flags & HFLAG_FULL)\n\t\tregtmp |= BIGMAC_TXCFG_FULLDPLX;\n\n\t \n\thme_write32(hp, bregs + BMAC_TXCFG, regtmp  );\n\n\t \n\thme_write32(hp, bregs + BMAC_ALIMIT, 16);\n\n\t \n\tregtmp = BIGMAC_XCFG_ODENABLE;\n\n\t \n\tif (hp->happy_flags & HFLAG_LANCE)\n\t\tregtmp |= (DEFAULT_IPG0 << 5) | BIGMAC_XCFG_LANCE;\n\n\t \n\tif (hp->tcvr_type == external)\n\t\tregtmp |= BIGMAC_XCFG_MIIDISAB;\n\n\tHMD(\"XIF config old[%08x]\\n\", hme_read32(hp, bregs + BMAC_XIFCFG));\n\thme_write32(hp, bregs + BMAC_XIFCFG, regtmp);\n\n\t \n\tHMD(\"tx old[%08x] and rx [%08x] ON!\\n\",\n\t    hme_read32(hp, bregs + BMAC_TXCFG),\n\t    hme_read32(hp, bregs + BMAC_RXCFG));\n\n\t \n\thme_write32(hp, bregs + BMAC_TXMAX, ETH_FRAME_LEN + 8);\n\thme_write32(hp, bregs + BMAC_RXMAX, ETH_FRAME_LEN + 8);\n\n\thme_write32(hp, bregs + BMAC_TXCFG,\n\t\t    hme_read32(hp, bregs + BMAC_TXCFG) | BIGMAC_TXCFG_ENABLE);\n\thme_write32(hp, bregs + BMAC_RXCFG,\n\t\t    hme_read32(hp, bregs + BMAC_RXCFG) | BIGMAC_RXCFG_ENABLE);\n\n\t \n\thappy_meal_begin_auto_negotiation(hp, tregs, NULL);\n\n\t \n\treturn 0;\n}\n\n \nstatic void happy_meal_set_initial_advertisement(struct happy_meal *hp)\n{\n\tvoid __iomem *tregs\t= hp->tcvregs;\n\tvoid __iomem *bregs\t= hp->bigmacregs;\n\tvoid __iomem *gregs\t= hp->gregs;\n\n\thappy_meal_stop(hp, gregs);\n\tif (hp->happy_flags & HFLAG_FENABLE)\n\t\thme_write32(hp, tregs + TCVR_CFG,\n\t\t\t    hme_read32(hp, tregs + TCVR_CFG) & ~(TCV_CFG_BENABLE));\n\telse\n\t\thme_write32(hp, tregs + TCVR_CFG,\n\t\t\t    hme_read32(hp, tregs + TCVR_CFG) | TCV_CFG_BENABLE);\n\thappy_meal_transceiver_check(hp, tregs);\n\tswitch(hp->tcvr_type) {\n\tcase none:\n\t\treturn;\n\tcase internal:\n\t\thme_write32(hp, bregs + BMAC_XIFCFG, 0);\n\t\tbreak;\n\tcase external:\n\t\thme_write32(hp, bregs + BMAC_XIFCFG, BIGMAC_XCFG_MIIDISAB);\n\t\tbreak;\n\t}\n\tif (happy_meal_tcvr_reset(hp, tregs))\n\t\treturn;\n\n\t \n\thp->sw_bmsr      = happy_meal_tcvr_read(hp, tregs, MII_BMSR);\n\thp->sw_advertise = happy_meal_tcvr_read(hp, tregs, MII_ADVERTISE);\n\n\t \n\tif (hp->sw_bmsr & BMSR_10HALF)\n\t\thp->sw_advertise |= (ADVERTISE_10HALF);\n\telse\n\t\thp->sw_advertise &= ~(ADVERTISE_10HALF);\n\n\tif (hp->sw_bmsr & BMSR_10FULL)\n\t\thp->sw_advertise |= (ADVERTISE_10FULL);\n\telse\n\t\thp->sw_advertise &= ~(ADVERTISE_10FULL);\n\tif (hp->sw_bmsr & BMSR_100HALF)\n\t\thp->sw_advertise |= (ADVERTISE_100HALF);\n\telse\n\t\thp->sw_advertise &= ~(ADVERTISE_100HALF);\n\tif (hp->sw_bmsr & BMSR_100FULL)\n\t\thp->sw_advertise |= (ADVERTISE_100FULL);\n\telse\n\t\thp->sw_advertise &= ~(ADVERTISE_100FULL);\n\n\t \n\thappy_meal_tcvr_write(hp, tregs, MII_ADVERTISE, hp->sw_advertise);\n}\n\n \nstatic int happy_meal_is_not_so_happy(struct happy_meal *hp, u32 status)\n{\n\tint reset = 0;\n\n\t \n\tif (status & (GREG_STAT_STSTERR | GREG_STAT_TFIFO_UND |\n\t\t      GREG_STAT_MAXPKTERR | GREG_STAT_RXERR |\n\t\t      GREG_STAT_RXPERR | GREG_STAT_RXTERR | GREG_STAT_EOPERR |\n\t\t      GREG_STAT_MIFIRQ | GREG_STAT_TXEACK | GREG_STAT_TXLERR |\n\t\t      GREG_STAT_TXPERR | GREG_STAT_TXTERR | GREG_STAT_SLVERR |\n\t\t      GREG_STAT_SLVPERR))\n\t\tnetdev_err(hp->dev,\n\t\t\t   \"Error interrupt for happy meal, status = %08x\\n\",\n\t\t\t   status);\n\n\tif (status & GREG_STAT_RFIFOVF) {\n\t\t \n\t\tnetdev_dbg(hp->dev, \"Happy Meal receive FIFO overflow.\\n\");\n\t}\n\n\tif (status & GREG_STAT_STSTERR) {\n\t\t \n\t\tnetdev_err(hp->dev, \"Happy Meal BigMAC SQE test failed.\\n\");\n\t\treset = 1;\n\t}\n\n\tif (status & GREG_STAT_TFIFO_UND) {\n\t\t \n\t\tnetdev_err(hp->dev,\n\t\t\t   \"Happy Meal transmitter FIFO underrun, DMA error.\\n\");\n\t\treset = 1;\n\t}\n\n\tif (status & GREG_STAT_MAXPKTERR) {\n\t\t \n\t\tnetdev_err(hp->dev, \"Happy Meal MAX Packet size error.\\n\");\n\t\treset = 1;\n\t}\n\n\tif (status & GREG_STAT_NORXD) {\n\t\t \n\t\tnetdev_info(hp->dev,\n\t\t\t    \"Happy Meal out of receive descriptors, packet dropped.\\n\");\n\t}\n\n\tif (status & (GREG_STAT_RXERR|GREG_STAT_RXPERR|GREG_STAT_RXTERR)) {\n\t\t \n\t\tnetdev_err(hp->dev, \"Happy Meal rx DMA errors [ %s%s%s]\\n\",\n\t\t\t   status & GREG_STAT_RXERR ? \"GenericError \" : \"\",\n\t\t\t   status & GREG_STAT_RXPERR ? \"ParityError \" : \"\",\n\t\t\t   status & GREG_STAT_RXTERR ? \"RxTagBotch \" : \"\");\n\t\treset = 1;\n\t}\n\n\tif (status & GREG_STAT_EOPERR) {\n\t\t \n\t\tnetdev_err(hp->dev,\n\t\t\t   \"EOP not set in happy meal transmit descriptor!\\n\");\n\t\treset = 1;\n\t}\n\n\tif (status & GREG_STAT_MIFIRQ) {\n\t\t \n\t\tnetdev_err(hp->dev, \"Happy Meal MIF interrupt.\\n\");\n\t}\n\n\tif (status &\n\t    (GREG_STAT_TXEACK|GREG_STAT_TXLERR|GREG_STAT_TXPERR|GREG_STAT_TXTERR)) {\n\t\t \n\t\tnetdev_err(hp->dev, \"Happy Meal tx DMA errors [ %s%s%s%s]\\n\",\n\t\t\t   status & GREG_STAT_TXEACK ? \"GenericError \" : \"\",\n\t\t\t   status & GREG_STAT_TXLERR ? \"LateError \" : \"\",\n\t\t\t   status & GREG_STAT_TXPERR ? \"ParityError \" : \"\",\n\t\t\t   status & GREG_STAT_TXTERR ? \"TagBotch \" : \"\");\n\t\treset = 1;\n\t}\n\n\tif (status & (GREG_STAT_SLVERR|GREG_STAT_SLVPERR)) {\n\t\t \n\t\tnetdev_err(hp->dev,\n\t\t\t   \"Happy Meal register access SBUS slave (%s) error.\\n\",\n\t\t\t   (status & GREG_STAT_SLVPERR) ? \"parity\" : \"generic\");\n\t\treset = 1;\n\t}\n\n\tif (reset) {\n\t\tnetdev_notice(hp->dev, \"Resetting...\\n\");\n\t\thappy_meal_init(hp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void happy_meal_tx(struct happy_meal *hp)\n{\n\tstruct happy_meal_txd *txbase = &hp->happy_block->happy_meal_txd[0];\n\tstruct happy_meal_txd *this;\n\tstruct net_device *dev = hp->dev;\n\tint elem;\n\n\telem = hp->tx_old;\n\twhile (elem != hp->tx_new) {\n\t\tstruct sk_buff *skb;\n\t\tu32 flags, dma_addr, dma_len;\n\t\tint frag;\n\n\t\tnetdev_vdbg(hp->dev, \"TX[%d]\\n\", elem);\n\t\tthis = &txbase[elem];\n\t\tflags = hme_read_desc32(hp, &this->tx_flags);\n\t\tif (flags & TXFLAG_OWN)\n\t\t\tbreak;\n\t\tskb = hp->tx_skbs[elem];\n\t\tif (skb_shinfo(skb)->nr_frags) {\n\t\t\tint last;\n\n\t\t\tlast = elem + skb_shinfo(skb)->nr_frags;\n\t\t\tlast &= (TX_RING_SIZE - 1);\n\t\t\tflags = hme_read_desc32(hp, &txbase[last].tx_flags);\n\t\t\tif (flags & TXFLAG_OWN)\n\t\t\t\tbreak;\n\t\t}\n\t\thp->tx_skbs[elem] = NULL;\n\t\tdev->stats.tx_bytes += skb->len;\n\n\t\tfor (frag = 0; frag <= skb_shinfo(skb)->nr_frags; frag++) {\n\t\t\tdma_addr = hme_read_desc32(hp, &this->tx_addr);\n\t\t\tdma_len = hme_read_desc32(hp, &this->tx_flags);\n\n\t\t\tdma_len &= TXFLAG_SIZE;\n\t\t\tif (!frag)\n\t\t\t\tdma_unmap_single(hp->dma_dev, dma_addr, dma_len, DMA_TO_DEVICE);\n\t\t\telse\n\t\t\t\tdma_unmap_page(hp->dma_dev, dma_addr, dma_len, DMA_TO_DEVICE);\n\n\t\t\telem = NEXT_TX(elem);\n\t\t\tthis = &txbase[elem];\n\t\t}\n\n\t\tdev_consume_skb_irq(skb);\n\t\tdev->stats.tx_packets++;\n\t}\n\thp->tx_old = elem;\n\n\tif (netif_queue_stopped(dev) &&\n\t    TX_BUFFS_AVAIL(hp) > (MAX_SKB_FRAGS + 1))\n\t\tnetif_wake_queue(dev);\n}\n\n \nstatic void happy_meal_rx(struct happy_meal *hp, struct net_device *dev)\n{\n\tstruct happy_meal_rxd *rxbase = &hp->happy_block->happy_meal_rxd[0];\n\tstruct happy_meal_rxd *this;\n\tint elem = hp->rx_new, drops = 0;\n\tu32 flags;\n\n\tthis = &rxbase[elem];\n\twhile (!((flags = hme_read_desc32(hp, &this->rx_flags)) & RXFLAG_OWN)) {\n\t\tstruct sk_buff *skb;\n\t\tint len = flags >> 16;\n\t\tu16 csum = flags & RXFLAG_CSUM;\n\t\tu32 dma_addr = hme_read_desc32(hp, &this->rx_addr);\n\n\t\t \n\t\tif ((len < ETH_ZLEN) || (flags & RXFLAG_OVERFLOW)) {\n\t\t\tnetdev_vdbg(dev, \"RX[%d ERR(%08x)]\", elem, flags);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (len < ETH_ZLEN)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (len & (RXFLAG_OVERFLOW >> 16)) {\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t}\n\n\t\t\t \n\tdrop_it:\n\t\t\tdev->stats.rx_dropped++;\n\t\t\thme_write_rxd(hp, this,\n\t\t\t\t      (RXFLAG_OWN|((RX_BUF_ALLOC_SIZE-RX_OFFSET)<<16)),\n\t\t\t\t      dma_addr);\n\t\t\tgoto next;\n\t\t}\n\t\tskb = hp->rx_skbs[elem];\n\t\tif (len > RX_COPY_THRESHOLD) {\n\t\t\tstruct sk_buff *new_skb;\n\t\t\tu32 mapping;\n\n\t\t\t \n\t\t\tnew_skb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\n\t\t\tif (new_skb == NULL) {\n\t\t\t\tdrops++;\n\t\t\t\tgoto drop_it;\n\t\t\t}\n\t\t\tskb_put(new_skb, (ETH_FRAME_LEN + RX_OFFSET + 4));\n\t\t\tmapping = dma_map_single(hp->dma_dev, new_skb->data,\n\t\t\t\t\t\t RX_BUF_ALLOC_SIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(hp->dma_dev, mapping))) {\n\t\t\t\tdev_kfree_skb_any(new_skb);\n\t\t\t\tdrops++;\n\t\t\t\tgoto drop_it;\n\t\t\t}\n\n\t\t\tdma_unmap_single(hp->dma_dev, dma_addr, RX_BUF_ALLOC_SIZE, DMA_FROM_DEVICE);\n\t\t\thp->rx_skbs[elem] = new_skb;\n\t\t\thme_write_rxd(hp, this,\n\t\t\t\t      (RXFLAG_OWN|((RX_BUF_ALLOC_SIZE-RX_OFFSET)<<16)),\n\t\t\t\t      mapping);\n\t\t\tskb_reserve(new_skb, RX_OFFSET);\n\n\t\t\t \n\t\t\tskb_trim(skb, len);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = netdev_alloc_skb(dev, len + 2);\n\n\t\t\tif (copy_skb == NULL) {\n\t\t\t\tdrops++;\n\t\t\t\tgoto drop_it;\n\t\t\t}\n\n\t\t\tskb_reserve(copy_skb, 2);\n\t\t\tskb_put(copy_skb, len);\n\t\t\tdma_sync_single_for_cpu(hp->dma_dev, dma_addr, len + 2, DMA_FROM_DEVICE);\n\t\t\tskb_copy_from_linear_data(skb, copy_skb->data, len);\n\t\t\tdma_sync_single_for_device(hp->dma_dev, dma_addr, len + 2, DMA_FROM_DEVICE);\n\t\t\t \n\t\t\thme_write_rxd(hp, this,\n\t\t\t\t      (RXFLAG_OWN|((RX_BUF_ALLOC_SIZE-RX_OFFSET)<<16)),\n\t\t\t\t      dma_addr);\n\n\t\t\tskb = copy_skb;\n\t\t}\n\n\t\t \n\t\tskb->csum = csum_unfold(~(__force __sum16)htons(csum));\n\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\n\t\tnetdev_vdbg(dev, \"RX[%d len=%d csum=%4x]\", elem, len, csum);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += len;\n\tnext:\n\t\telem = NEXT_RX(elem);\n\t\tthis = &rxbase[elem];\n\t}\n\thp->rx_new = elem;\n\tif (drops)\n\t\tnetdev_info(hp->dev, \"Memory squeeze, deferring packet.\\n\");\n}\n\nstatic irqreturn_t happy_meal_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct happy_meal *hp  = netdev_priv(dev);\n\tu32 happy_status       = hme_read32(hp, hp->gregs + GREG_STAT);\n\n\tHMD(\"status=%08x\\n\", happy_status);\n\tif (!happy_status)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&hp->happy_lock);\n\n\tif (happy_status & GREG_STAT_ERRORS) {\n\t\tif (happy_meal_is_not_so_happy(hp,   happy_status))\n\t\t\tgoto out;\n\t}\n\n\tif (happy_status & GREG_STAT_TXALL)\n\t\thappy_meal_tx(hp);\n\n\tif (happy_status & GREG_STAT_RXTOHOST)\n\t\thappy_meal_rx(hp, dev);\n\n\tHMD(\"done\\n\");\nout:\n\tspin_unlock(&hp->happy_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int happy_meal_open(struct net_device *dev)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\tint res;\n\n\tres = request_irq(hp->irq, happy_meal_interrupt, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (res) {\n\t\tnetdev_err(dev, \"Can't order irq %d to go.\\n\", hp->irq);\n\t\treturn res;\n\t}\n\n\tHMD(\"to happy_meal_init\\n\");\n\n\tspin_lock_irq(&hp->happy_lock);\n\tres = happy_meal_init(hp);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\tif (res)\n\t\tfree_irq(hp->irq, dev);\n\treturn res;\n}\n\nstatic int happy_meal_close(struct net_device *dev)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\n\tspin_lock_irq(&hp->happy_lock);\n\thappy_meal_stop(hp, hp->gregs);\n\thappy_meal_clean_rings(hp);\n\n\t \n\tdel_timer(&hp->happy_timer);\n\n\tspin_unlock_irq(&hp->happy_lock);\n\n\tfree_irq(hp->irq, dev);\n\n\treturn 0;\n}\n\nstatic void happy_meal_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\n\tnetdev_err(dev, \"transmit timed out, resetting\\n\");\n\ttx_dump_log();\n\tnetdev_err(dev, \"Happy Status %08x TX[%08x:%08x]\\n\",\n\t\t   hme_read32(hp, hp->gregs + GREG_STAT),\n\t\t   hme_read32(hp, hp->etxregs + ETX_CFG),\n\t\t   hme_read32(hp, hp->bigmacregs + BMAC_TXCFG));\n\n\tspin_lock_irq(&hp->happy_lock);\n\thappy_meal_init(hp);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\tnetif_wake_queue(dev);\n}\n\nstatic void unmap_partial_tx_skb(struct happy_meal *hp, u32 first_mapping,\n\t\t\t\t u32 first_len, u32 first_entry, u32 entry)\n{\n\tstruct happy_meal_txd *txbase = &hp->happy_block->happy_meal_txd[0];\n\n\tdma_unmap_single(hp->dma_dev, first_mapping, first_len, DMA_TO_DEVICE);\n\n\tfirst_entry = NEXT_TX(first_entry);\n\twhile (first_entry != entry) {\n\t\tstruct happy_meal_txd *this = &txbase[first_entry];\n\t\tu32 addr, len;\n\n\t\taddr = hme_read_desc32(hp, &this->tx_addr);\n\t\tlen = hme_read_desc32(hp, &this->tx_flags);\n\t\tlen &= TXFLAG_SIZE;\n\t\tdma_unmap_page(hp->dma_dev, addr, len, DMA_TO_DEVICE);\n\t}\n}\n\nstatic netdev_tx_t happy_meal_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\tint entry;\n\tu32 tx_flags;\n\n\ttx_flags = TXFLAG_OWN;\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tconst u32 csum_start_off = skb_checksum_start_offset(skb);\n\t\tconst u32 csum_stuff_off = csum_start_off + skb->csum_offset;\n\n\t\ttx_flags = (TXFLAG_OWN | TXFLAG_CSENABLE |\n\t\t\t    ((csum_start_off << 14) & TXFLAG_CSBUFBEGIN) |\n\t\t\t    ((csum_stuff_off << 20) & TXFLAG_CSLOCATION));\n\t}\n\n\tspin_lock_irq(&hp->happy_lock);\n\n\tif (TX_BUFFS_AVAIL(hp) <= (skb_shinfo(skb)->nr_frags + 1)) {\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irq(&hp->happy_lock);\n\t\tnetdev_err(dev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tentry = hp->tx_new;\n\tnetdev_vdbg(dev, \"SX<l[%d]e[%d]>\\n\", skb->len, entry);\n\thp->tx_skbs[entry] = skb;\n\n\tif (skb_shinfo(skb)->nr_frags == 0) {\n\t\tu32 mapping, len;\n\n\t\tlen = skb->len;\n\t\tmapping = dma_map_single(hp->dma_dev, skb->data, len, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(hp->dma_dev, mapping)))\n\t\t\tgoto out_dma_error;\n\t\ttx_flags |= (TXFLAG_SOP | TXFLAG_EOP);\n\t\thme_write_txd(hp, &hp->happy_block->happy_meal_txd[entry],\n\t\t\t      (tx_flags | (len & TXFLAG_SIZE)),\n\t\t\t      mapping);\n\t\tentry = NEXT_TX(entry);\n\t} else {\n\t\tu32 first_len, first_mapping;\n\t\tint frag, first_entry = entry;\n\n\t\t \n\t\tfirst_len = skb_headlen(skb);\n\t\tfirst_mapping = dma_map_single(hp->dma_dev, skb->data, first_len,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(hp->dma_dev, first_mapping)))\n\t\t\tgoto out_dma_error;\n\t\tentry = NEXT_TX(entry);\n\n\t\tfor (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {\n\t\t\tconst skb_frag_t *this_frag = &skb_shinfo(skb)->frags[frag];\n\t\t\tu32 len, mapping, this_txflags;\n\n\t\t\tlen = skb_frag_size(this_frag);\n\t\t\tmapping = skb_frag_dma_map(hp->dma_dev, this_frag,\n\t\t\t\t\t\t   0, len, DMA_TO_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(hp->dma_dev, mapping))) {\n\t\t\t\tunmap_partial_tx_skb(hp, first_mapping, first_len,\n\t\t\t\t\t\t     first_entry, entry);\n\t\t\t\tgoto out_dma_error;\n\t\t\t}\n\t\t\tthis_txflags = tx_flags;\n\t\t\tif (frag == skb_shinfo(skb)->nr_frags - 1)\n\t\t\t\tthis_txflags |= TXFLAG_EOP;\n\t\t\thme_write_txd(hp, &hp->happy_block->happy_meal_txd[entry],\n\t\t\t\t      (this_txflags | (len & TXFLAG_SIZE)),\n\t\t\t\t      mapping);\n\t\t\tentry = NEXT_TX(entry);\n\t\t}\n\t\thme_write_txd(hp, &hp->happy_block->happy_meal_txd[first_entry],\n\t\t\t      (tx_flags | TXFLAG_SOP | (first_len & TXFLAG_SIZE)),\n\t\t\t      first_mapping);\n\t}\n\n\thp->tx_new = entry;\n\n\tif (TX_BUFFS_AVAIL(hp) <= (MAX_SKB_FRAGS + 1))\n\t\tnetif_stop_queue(dev);\n\n\t \n\thme_write32(hp, hp->etxregs + ETX_PENDING, ETX_TP_DMAWAKEUP);\n\n\tspin_unlock_irq(&hp->happy_lock);\n\n\ttx_add_log(hp, TXLOG_ACTION_TXMIT, 0);\n\treturn NETDEV_TX_OK;\n\nout_dma_error:\n\thp->tx_skbs[hp->tx_new] = NULL;\n\tspin_unlock_irq(&hp->happy_lock);\n\n\tdev_kfree_skb_any(skb);\n\tdev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct net_device_stats *happy_meal_get_stats(struct net_device *dev)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\n\tspin_lock_irq(&hp->happy_lock);\n\thappy_meal_get_counters(hp, hp->bigmacregs);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\treturn &dev->stats;\n}\n\nstatic void happy_meal_set_multicast(struct net_device *dev)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\tvoid __iomem *bregs = hp->bigmacregs;\n\tstruct netdev_hw_addr *ha;\n\tu32 crc;\n\n\tspin_lock_irq(&hp->happy_lock);\n\n\tif ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\n\t\thme_write32(hp, bregs + BMAC_HTABLE0, 0xffff);\n\t\thme_write32(hp, bregs + BMAC_HTABLE1, 0xffff);\n\t\thme_write32(hp, bregs + BMAC_HTABLE2, 0xffff);\n\t\thme_write32(hp, bregs + BMAC_HTABLE3, 0xffff);\n\t} else if (dev->flags & IFF_PROMISC) {\n\t\thme_write32(hp, bregs + BMAC_RXCFG,\n\t\t\t    hme_read32(hp, bregs + BMAC_RXCFG) | BIGMAC_RXCFG_PMISC);\n\t} else {\n\t\tu16 hash_table[4];\n\n\t\tmemset(hash_table, 0, sizeof(hash_table));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t\thme_write32(hp, bregs + BMAC_HTABLE0, hash_table[0]);\n\t\thme_write32(hp, bregs + BMAC_HTABLE1, hash_table[1]);\n\t\thme_write32(hp, bregs + BMAC_HTABLE2, hash_table[2]);\n\t\thme_write32(hp, bregs + BMAC_HTABLE3, hash_table[3]);\n\t}\n\n\tspin_unlock_irq(&hp->happy_lock);\n}\n\n \nstatic int hme_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\tu32 speed;\n\tu32 supported;\n\n\tsupported =\n\t\t(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\n\t\t SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\n\t\t SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII);\n\n\t \n\tcmd->base.port = PORT_TP;  \n\tcmd->base.phy_address = 0;  \n\n\t \n\tspin_lock_irq(&hp->happy_lock);\n\thp->sw_bmcr = happy_meal_tcvr_read(hp, hp->tcvregs, MII_BMCR);\n\thp->sw_lpa = happy_meal_tcvr_read(hp, hp->tcvregs, MII_LPA);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\tif (hp->sw_bmcr & BMCR_ANENABLE) {\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t\tspeed = ((hp->sw_lpa & (LPA_100HALF | LPA_100FULL)) ?\n\t\t\t SPEED_100 : SPEED_10);\n\t\tif (speed == SPEED_100)\n\t\t\tcmd->base.duplex =\n\t\t\t\t(hp->sw_lpa & (LPA_100FULL)) ?\n\t\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\t\telse\n\t\t\tcmd->base.duplex =\n\t\t\t\t(hp->sw_lpa & (LPA_10FULL)) ?\n\t\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\tspeed = (hp->sw_bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10;\n\t\tcmd->base.duplex =\n\t\t\t(hp->sw_bmcr & BMCR_FULLDPLX) ?\n\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\t}\n\tcmd->base.speed = speed;\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\n\treturn 0;\n}\n\nstatic int hme_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\n\t \n\tif (cmd->base.autoneg != AUTONEG_ENABLE &&\n\t    cmd->base.autoneg != AUTONEG_DISABLE)\n\t\treturn -EINVAL;\n\tif (cmd->base.autoneg == AUTONEG_DISABLE &&\n\t    ((cmd->base.speed != SPEED_100 &&\n\t      cmd->base.speed != SPEED_10) ||\n\t     (cmd->base.duplex != DUPLEX_HALF &&\n\t      cmd->base.duplex != DUPLEX_FULL)))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irq(&hp->happy_lock);\n\tdel_timer(&hp->happy_timer);\n\thappy_meal_begin_auto_negotiation(hp, hp->tcvregs, cmd);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\treturn 0;\n}\n\nstatic void hme_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tif (hp->happy_flags & HFLAG_PCI) {\n\t\tstruct pci_dev *pdev = hp->happy_dev;\n\t\tstrscpy(info->bus_info, pci_name(pdev), sizeof(info->bus_info));\n\t}\n#ifdef CONFIG_SBUS\n\telse {\n\t\tconst struct linux_prom_registers *regs;\n\t\tstruct platform_device *op = hp->happy_dev;\n\t\tregs = of_get_property(op->dev.of_node, \"regs\", NULL);\n\t\tif (regs)\n\t\t\tsnprintf(info->bus_info, sizeof(info->bus_info),\n\t\t\t\t\"SBUS:%d\",\n\t\t\t\tregs->which_io);\n\t}\n#endif\n}\n\nstatic u32 hme_get_link(struct net_device *dev)\n{\n\tstruct happy_meal *hp = netdev_priv(dev);\n\n\tspin_lock_irq(&hp->happy_lock);\n\thp->sw_bmcr = happy_meal_tcvr_read(hp, hp->tcvregs, MII_BMCR);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\treturn hp->sw_bmsr & BMSR_LSTATUS;\n}\n\nstatic const struct ethtool_ops hme_ethtool_ops = {\n\t.get_drvinfo\t\t= hme_get_drvinfo,\n\t.get_link\t\t= hme_get_link,\n\t.get_link_ksettings\t= hme_get_link_ksettings,\n\t.set_link_ksettings\t= hme_set_link_ksettings,\n};\n\n#ifdef CONFIG_SBUS\n \nstatic struct quattro *quattro_sbus_find(struct platform_device *child)\n{\n\tstruct device *parent = child->dev.parent;\n\tstruct platform_device *op;\n\tstruct quattro *qp;\n\n\top = to_platform_device(parent);\n\tqp = platform_get_drvdata(op);\n\tif (qp)\n\t\treturn qp;\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn NULL;\n\n\tqp->quattro_dev = child;\n\tqp->next = qfe_sbus_list;\n\tqfe_sbus_list = qp;\n\n\tplatform_set_drvdata(op, qp);\n\treturn qp;\n}\n#endif  \n\n#ifdef CONFIG_PCI\nstatic struct quattro *quattro_pci_find(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct pci_dev *bdev = pdev->bus->self;\n\tstruct quattro *qp;\n\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tfor (qp = qfe_pci_list; qp != NULL; qp = qp->next) {\n\t\tstruct pci_dev *qpdev = qp->quattro_dev;\n\n\t\tif (qpdev == bdev)\n\t\t\treturn qp;\n\t}\n\n\tqp = kmalloc(sizeof(struct quattro), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < 4; i++)\n\t\tqp->happy_meals[i] = NULL;\n\n\tqp->quattro_dev = bdev;\n\tqp->next = qfe_pci_list;\n\tqfe_pci_list = qp;\n\n\t \n\tqp->nranges = 0;\n\treturn qp;\n}\n#endif  \n\nstatic const struct net_device_ops hme_netdev_ops = {\n\t.ndo_open\t\t= happy_meal_open,\n\t.ndo_stop\t\t= happy_meal_close,\n\t.ndo_start_xmit\t\t= happy_meal_start_xmit,\n\t.ndo_tx_timeout\t\t= happy_meal_tx_timeout,\n\t.ndo_get_stats\t\t= happy_meal_get_stats,\n\t.ndo_set_rx_mode\t= happy_meal_set_multicast,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n#ifdef CONFIG_PCI\nstatic int is_quattro_p(struct pci_dev *pdev)\n{\n\tstruct pci_dev *busdev = pdev->bus->self;\n\tstruct pci_dev *this_pdev;\n\tint n_hmes;\n\n\tif (!busdev || busdev->vendor != PCI_VENDOR_ID_DEC ||\n\t    busdev->device != PCI_DEVICE_ID_DEC_21153)\n\t\treturn 0;\n\n\tn_hmes = 0;\n\tlist_for_each_entry(this_pdev, &pdev->bus->devices, bus_list) {\n\t\tif (this_pdev->vendor == PCI_VENDOR_ID_SUN &&\n\t\t    this_pdev->device == PCI_DEVICE_ID_SUN_HAPPYMEAL)\n\t\t\tn_hmes++;\n\t}\n\n\tif (n_hmes != 4)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int find_eth_addr_in_vpd(void __iomem *rom_base, int len, int index, unsigned char *dev_addr)\n{\n\tint this_offset;\n\n\tfor (this_offset = 0x20; this_offset < len; this_offset++) {\n\t\tvoid __iomem *p = rom_base + this_offset;\n\n\t\tif (readb(p + 0) != 0x90 ||\n\t\t    readb(p + 1) != 0x00 ||\n\t\t    readb(p + 2) != 0x09 ||\n\t\t    readb(p + 3) != 0x4e ||\n\t\t    readb(p + 4) != 0x41 ||\n\t\t    readb(p + 5) != 0x06)\n\t\t\tcontinue;\n\n\t\tthis_offset += 6;\n\t\tp += 6;\n\n\t\tif (index == 0) {\n\t\t\tfor (int i = 0; i < 6; i++)\n\t\t\t\tdev_addr[i] = readb(p + i);\n\t\t\treturn 1;\n\t\t}\n\t\tindex--;\n\t}\n\treturn 0;\n}\n\nstatic void __maybe_unused get_hme_mac_nonsparc(struct pci_dev *pdev,\n\t\t\t\t\t\tunsigned char *dev_addr)\n{\n\tvoid __iomem *p;\n\tsize_t size;\n\n\tp = pci_map_rom(pdev, &size);\n\tif (p) {\n\t\tint index = 0;\n\t\tint found;\n\n\t\tif (is_quattro_p(pdev))\n\t\t\tindex = PCI_SLOT(pdev->devfn);\n\n\t\tfound = readb(p) == 0x55 &&\n\t\t\treadb(p + 1) == 0xaa &&\n\t\t\tfind_eth_addr_in_vpd(p, (64 * 1024), index, dev_addr);\n\t\tpci_unmap_rom(pdev, p);\n\t\tif (found)\n\t\t\treturn;\n\t}\n\n\t \n\tdev_addr[0] = 0x08;\n\tdev_addr[1] = 0x00;\n\tdev_addr[2] = 0x20;\n\tget_random_bytes(&dev_addr[3], 3);\n}\n#endif\n\nstatic void happy_meal_addr_init(struct happy_meal *hp,\n\t\t\t\t struct device_node *dp, int qfe_slot)\n{\n\tint i;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (macaddr[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tif (i < 6) {  \n\t\tu8 addr[ETH_ALEN];\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = macaddr[i];\n\t\teth_hw_addr_set(hp->dev, addr);\n\t\tmacaddr[5]++;\n\t} else {\n#ifdef CONFIG_SPARC\n\t\tconst unsigned char *addr;\n\t\tint len;\n\n\t\t \n\t\tif (qfe_slot != -1) {\n\t\t\taddr = of_get_property(dp, \"local-mac-address\", &len);\n\t\t\tif (addr && len == 6) {\n\t\t\t\teth_hw_addr_set(hp->dev, addr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\teth_hw_addr_set(hp->dev, idprom->id_ethaddr);\n#else\n\t\tu8 addr[ETH_ALEN];\n\n\t\tget_hme_mac_nonsparc(hp->happy_dev, addr);\n\t\teth_hw_addr_set(hp->dev, addr);\n#endif\n\t}\n}\n\nstatic int happy_meal_common_probe(struct happy_meal *hp,\n\t\t\t\t   struct device_node *dp)\n{\n\tstruct net_device *dev = hp->dev;\n\tint err;\n\n#ifdef CONFIG_SPARC\n\thp->hm_revision = of_getintprop_default(dp, \"hm-rev\", hp->hm_revision);\n#endif\n\n\t \n\tif (hp->hm_revision == 0x20 || hp->hm_revision == 0x21)\n\t\thp->happy_flags |= HFLAG_20_21;\n\telse if (hp->hm_revision != 0xa0)\n\t\thp->happy_flags |= HFLAG_NOT_A0;\n\n\thp->happy_block = dmam_alloc_coherent(hp->dma_dev, PAGE_SIZE,\n\t\t\t\t\t      &hp->hblock_dvma, GFP_KERNEL);\n\tif (!hp->happy_block)\n\t\treturn -ENOMEM;\n\n\t \n\thp->linkcheck = 0;\n\n\t \n\thp->timer_state = asleep;\n\thp->timer_ticks = 0;\n\n\ttimer_setup(&hp->happy_timer, happy_meal_timer, 0);\n\n\tdev->netdev_ops = &hme_netdev_ops;\n\tdev->watchdog_timeo = 5 * HZ;\n\tdev->ethtool_ops = &hme_ethtool_ops;\n\n\t \n\tdev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;\n\tdev->features |= dev->hw_features | NETIF_F_RXCSUM;\n\n\n\t \n\tspin_lock_irq(&hp->happy_lock);\n\thappy_meal_set_initial_advertisement(hp);\n\tspin_unlock_irq(&hp->happy_lock);\n\n\terr = devm_register_netdev(hp->dma_dev, dev);\n\tif (err)\n\t\tdev_err(hp->dma_dev, \"Cannot register net device, aborting.\\n\");\n\treturn err;\n}\n\n#ifdef CONFIG_SBUS\nstatic int happy_meal_sbus_probe_one(struct platform_device *op, int is_qfe)\n{\n\tstruct device_node *dp = op->dev.of_node, *sbus_dp;\n\tstruct quattro *qp = NULL;\n\tstruct happy_meal *hp;\n\tstruct net_device *dev;\n\tint qfe_slot = -1;\n\tint err;\n\n\tsbus_dp = op->dev.parent->of_node;\n\n\t \n\tif (!of_node_name_eq(sbus_dp, \"sbus\") && !of_node_name_eq(sbus_dp, \"sbi\"))\n\t\treturn -ENODEV;\n\n\tif (is_qfe) {\n\t\tqp = quattro_sbus_find(op);\n\t\tif (qp == NULL)\n\t\t\treturn -ENODEV;\n\t\tfor (qfe_slot = 0; qfe_slot < 4; qfe_slot++)\n\t\t\tif (qp->happy_meals[qfe_slot] == NULL)\n\t\t\t\tbreak;\n\t\tif (qfe_slot == 4)\n\t\t\treturn -ENODEV;\n\t}\n\n\tdev = devm_alloc_etherdev(&op->dev, sizeof(struct happy_meal));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &op->dev);\n\n\thp = netdev_priv(dev);\n\thp->dev = dev;\n\thp->happy_dev = op;\n\thp->dma_dev = &op->dev;\n\thappy_meal_addr_init(hp, dp, qfe_slot);\n\n\tspin_lock_init(&hp->happy_lock);\n\n\tif (qp != NULL) {\n\t\thp->qfe_parent = qp;\n\t\thp->qfe_ent = qfe_slot;\n\t\tqp->happy_meals[qfe_slot] = dev;\n\t}\n\n\thp->gregs = devm_platform_ioremap_resource(op, 0);\n\tif (IS_ERR(hp->gregs)) {\n\t\tdev_err(&op->dev, \"Cannot map global registers.\\n\");\n\t\terr = PTR_ERR(hp->gregs);\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thp->etxregs = devm_platform_ioremap_resource(op, 1);\n\tif (IS_ERR(hp->etxregs)) {\n\t\tdev_err(&op->dev, \"Cannot map MAC TX registers.\\n\");\n\t\terr = PTR_ERR(hp->etxregs);\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thp->erxregs = devm_platform_ioremap_resource(op, 2);\n\tif (IS_ERR(hp->erxregs)) {\n\t\tdev_err(&op->dev, \"Cannot map MAC RX registers.\\n\");\n\t\terr = PTR_ERR(hp->erxregs);\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thp->bigmacregs = devm_platform_ioremap_resource(op, 3);\n\tif (IS_ERR(hp->bigmacregs)) {\n\t\tdev_err(&op->dev, \"Cannot map BIGMAC registers.\\n\");\n\t\terr = PTR_ERR(hp->bigmacregs);\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thp->tcvregs = devm_platform_ioremap_resource(op, 4);\n\tif (IS_ERR(hp->tcvregs)) {\n\t\tdev_err(&op->dev, \"Cannot map TCVR registers.\\n\");\n\t\terr = PTR_ERR(hp->tcvregs);\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thp->hm_revision = 0xa0;\n\n\tif (qp != NULL)\n\t\thp->happy_flags |= HFLAG_QUATTRO;\n\n\thp->irq = op->archdata.irqs[0];\n\n\t \n\thp->happy_bursts = of_getintprop_default(sbus_dp,\n\t\t\t\t\t\t \"burst-sizes\", 0x00);\n\n#ifdef CONFIG_PCI\n\t \n\thp->read_desc32 = sbus_hme_read_desc32;\n\thp->write_txd = sbus_hme_write_txd;\n\thp->write_rxd = sbus_hme_write_rxd;\n\thp->read32 = sbus_hme_read32;\n\thp->write32 = sbus_hme_write32;\n#endif\n\n\terr = happy_meal_common_probe(hp, dp);\n\tif (err)\n\t\tgoto err_out_clear_quattro;\n\n\tplatform_set_drvdata(op, hp);\n\n\tif (qfe_slot != -1)\n\t\tnetdev_info(dev,\n\t\t\t    \"Quattro HME slot %d (SBUS) 10/100baseT Ethernet %pM\\n\",\n\t\t\t    qfe_slot, dev->dev_addr);\n\telse\n\t\tnetdev_info(dev, \"HAPPY MEAL (SBUS) 10/100baseT Ethernet %pM\\n\",\n\t\t\t    dev->dev_addr);\n\n\treturn 0;\n\nerr_out_clear_quattro:\n\tif (qp)\n\t\tqp->happy_meals[qfe_slot] = NULL;\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_PCI\nstatic int happy_meal_pci_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct device_node *dp = NULL;\n\tstruct quattro *qp = NULL;\n\tstruct happy_meal *hp;\n\tstruct net_device *dev;\n\tvoid __iomem *hpreg_base;\n\tstruct resource *hpreg_res;\n\tchar prom_name[64];\n\tint qfe_slot = -1;\n\tint err = -ENODEV;\n\n\t \n#ifdef CONFIG_SPARC\n\tdp = pci_device_to_OF_node(pdev);\n\tsnprintf(prom_name, sizeof(prom_name), \"%pOFn\", dp);\n#else\n\tif (is_quattro_p(pdev))\n\t\tstrcpy(prom_name, \"SUNW,qfe\");\n\telse\n\t\tstrcpy(prom_name, \"SUNW,hme\");\n#endif\n\n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\tpci_set_master(pdev);\n\n\tif (!strcmp(prom_name, \"SUNW,qfe\") || !strcmp(prom_name, \"qfe\")) {\n\t\tqp = quattro_pci_find(pdev);\n\t\tif (IS_ERR(qp))\n\t\t\treturn PTR_ERR(qp);\n\n\t\tfor (qfe_slot = 0; qfe_slot < 4; qfe_slot++)\n\t\t\tif (!qp->happy_meals[qfe_slot])\n\t\t\t\tbreak;\n\n\t\tif (qfe_slot == 4)\n\t\t\treturn -ENODEV;\n\t}\n\n\tdev = devm_alloc_etherdev(&pdev->dev, sizeof(struct happy_meal));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\thp = netdev_priv(dev);\n\thp->dev = dev;\n\thp->happy_dev = pdev;\n\thp->dma_dev = &pdev->dev;\n\n\tspin_lock_init(&hp->happy_lock);\n\n\tif (qp != NULL) {\n\t\thp->qfe_parent = qp;\n\t\thp->qfe_ent = qfe_slot;\n\t\tqp->happy_meals[qfe_slot] = dev;\n\t}\n\n\terr = -EINVAL;\n\tif ((pci_resource_flags(pdev, 0) & IORESOURCE_IO) != 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot find proper PCI device base address.\\n\");\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thpreg_res = devm_request_mem_region(&pdev->dev,\n\t\t\t\t\t    pci_resource_start(pdev, 0),\n\t\t\t\t\t    pci_resource_len(pdev, 0),\n\t\t\t\t\t    DRV_NAME);\n\tif (!hpreg_res) {\n\t\terr = -EBUSY;\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, aborting.\\n\");\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thpreg_base = pcim_iomap(pdev, 0, 0x8000);\n\tif (!hpreg_base) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Unable to remap card memory.\\n\");\n\t\tgoto err_out_clear_quattro;\n\t}\n\n\thappy_meal_addr_init(hp, dp, qfe_slot);\n\n\t \n\thp->gregs      = (hpreg_base + 0x0000UL);\n\thp->etxregs    = (hpreg_base + 0x2000UL);\n\thp->erxregs    = (hpreg_base + 0x4000UL);\n\thp->bigmacregs = (hpreg_base + 0x6000UL);\n\thp->tcvregs    = (hpreg_base + 0x7000UL);\n\n\tif (IS_ENABLED(CONFIG_SPARC))\n\t\thp->hm_revision = 0xc0 | (pdev->revision & 0x0f);\n\telse\n\t\thp->hm_revision = 0x20;\n\n\tif (qp != NULL)\n\t\thp->happy_flags |= HFLAG_QUATTRO;\n\n\t \n\thp->happy_flags |= HFLAG_PCI;\n\n#ifdef CONFIG_SPARC\n\t \n\thp->happy_bursts = DMA_BURSTBITS;\n#endif\n\thp->irq = pdev->irq;\n\n#ifdef CONFIG_SBUS\n\t \n\thp->read_desc32 = pci_hme_read_desc32;\n\thp->write_txd = pci_hme_write_txd;\n\thp->write_rxd = pci_hme_write_rxd;\n\thp->read32 = pci_hme_read32;\n\thp->write32 = pci_hme_write32;\n#endif\n\n\terr = happy_meal_common_probe(hp, dp);\n\tif (err)\n\t\tgoto err_out_clear_quattro;\n\n\tpci_set_drvdata(pdev, hp);\n\n\tif (!qfe_slot) {\n\t\tstruct pci_dev *qpdev = qp->quattro_dev;\n\n\t\tprom_name[0] = 0;\n\t\tif (!strncmp(dev->name, \"eth\", 3)) {\n\t\t\tint i = simple_strtoul(dev->name + 3, NULL, 10);\n\t\t\tsprintf(prom_name, \"-%d\", i + 3);\n\t\t}\n\t\tnetdev_info(dev,\n\t\t\t    \"%s: Quattro HME (PCI/CheerIO) 10/100baseT Ethernet bridge %04x.%04x\\n\",\n\t\t\t    prom_name, qpdev->vendor, qpdev->device);\n\t}\n\n\tif (qfe_slot != -1)\n\t\tnetdev_info(dev,\n\t\t\t    \"Quattro HME slot %d (PCI/CheerIO) 10/100baseT Ethernet %pM\\n\",\n\t\t\t    qfe_slot, dev->dev_addr);\n\telse\n\t\tnetdev_info(dev,\n\t\t\t    \"HAPPY MEAL (PCI/CheerIO) 10/100BaseT Ethernet %pM\\n\",\n\t\t\t    dev->dev_addr);\n\n\treturn 0;\n\nerr_out_clear_quattro:\n\tif (qp != NULL)\n\t\tqp->happy_meals[qfe_slot] = NULL;\n\treturn err;\n}\n\nstatic const struct pci_device_id happymeal_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_HAPPYMEAL) },\n\t{ }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, happymeal_pci_ids);\n\nstatic struct pci_driver hme_pci_driver = {\n\t.name\t\t= \"hme\",\n\t.id_table\t= happymeal_pci_ids,\n\t.probe\t\t= happy_meal_pci_probe,\n};\n\nstatic int __init happy_meal_pci_init(void)\n{\n\treturn pci_register_driver(&hme_pci_driver);\n}\n\nstatic void happy_meal_pci_exit(void)\n{\n\tpci_unregister_driver(&hme_pci_driver);\n\n\twhile (qfe_pci_list) {\n\t\tstruct quattro *qfe = qfe_pci_list;\n\t\tstruct quattro *next = qfe->next;\n\n\t\tkfree(qfe);\n\n\t\tqfe_pci_list = next;\n\t}\n}\n\n#endif\n\n#ifdef CONFIG_SBUS\nstatic const struct of_device_id hme_sbus_match[];\nstatic int hme_sbus_probe(struct platform_device *op)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *dp = op->dev.of_node;\n\tconst char *model = of_get_property(dp, \"model\", NULL);\n\tint is_qfe;\n\n\tmatch = of_match_device(hme_sbus_match, &op->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\tis_qfe = (match->data != NULL);\n\n\tif (!is_qfe && model && !strcmp(model, \"SUNW,sbus-qfe\"))\n\t\tis_qfe = 1;\n\n\treturn happy_meal_sbus_probe_one(op, is_qfe);\n}\n\nstatic const struct of_device_id hme_sbus_match[] = {\n\t{\n\t\t.name = \"SUNW,hme\",\n\t},\n\t{\n\t\t.name = \"SUNW,qfe\",\n\t\t.data = (void *) 1,\n\t},\n\t{\n\t\t.name = \"qfe\",\n\t\t.data = (void *) 1,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, hme_sbus_match);\n\nstatic struct platform_driver hme_sbus_driver = {\n\t.driver = {\n\t\t.name = \"hme\",\n\t\t.of_match_table = hme_sbus_match,\n\t},\n\t.probe\t\t= hme_sbus_probe,\n};\n\nstatic int __init happy_meal_sbus_init(void)\n{\n\treturn platform_driver_register(&hme_sbus_driver);\n}\n\nstatic void happy_meal_sbus_exit(void)\n{\n\tplatform_driver_unregister(&hme_sbus_driver);\n\n\twhile (qfe_sbus_list) {\n\t\tstruct quattro *qfe = qfe_sbus_list;\n\t\tstruct quattro *next = qfe->next;\n\n\t\tkfree(qfe);\n\n\t\tqfe_sbus_list = next;\n\t}\n}\n#endif\n\nstatic int __init happy_meal_probe(void)\n{\n\tint err = 0;\n\n#ifdef CONFIG_SBUS\n\terr = happy_meal_sbus_init();\n#endif\n#ifdef CONFIG_PCI\n\tif (!err) {\n\t\terr = happy_meal_pci_init();\n#ifdef CONFIG_SBUS\n\t\tif (err)\n\t\t\thappy_meal_sbus_exit();\n#endif\n\t}\n#endif\n\n\treturn err;\n}\n\n\nstatic void __exit happy_meal_exit(void)\n{\n#ifdef CONFIG_SBUS\n\thappy_meal_sbus_exit();\n#endif\n#ifdef CONFIG_PCI\n\thappy_meal_pci_exit();\n#endif\n}\n\nmodule_init(happy_meal_probe);\nmodule_exit(happy_meal_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}