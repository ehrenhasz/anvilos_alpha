{
  "module_name": "sunbmac.c",
  "hash_id": "ed1051b023d4535a7c90deb2b2438019bc7cebb38d1d051a0624e7abe531ac81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/sunbmac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pgtable.h>\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n\n#include <asm/auxio.h>\n#include <asm/byteorder.h>\n#include <asm/dma.h>\n#include <asm/idprom.h>\n#include <asm/io.h>\n#include <asm/openprom.h>\n#include <asm/oplib.h>\n\n#include \"sunbmac.h\"\n\n#define DRV_NAME\t\"sunbmac\"\n#define DRV_VERSION\t\"2.1\"\n#define DRV_RELDATE\t\"August 26, 2008\"\n#define DRV_AUTHOR\t\"David S. Miller (davem@davemloft.net)\"\n\nstatic char version[] =\n\tDRV_NAME \".c:v\" DRV_VERSION \" \" DRV_RELDATE \" \" DRV_AUTHOR \"\\n\";\n\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(\"Sun BigMAC 100baseT ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#undef DEBUG_PROBE\n#undef DEBUG_TX\n#undef DEBUG_IRQ\n\n#ifdef DEBUG_PROBE\n#define DP(x)  printk x\n#else\n#define DP(x)\n#endif\n\n#ifdef DEBUG_TX\n#define DTX(x)  printk x\n#else\n#define DTX(x)\n#endif\n\n#ifdef DEBUG_IRQ\n#define DIRQ(x)  printk x\n#else\n#define DIRQ(x)\n#endif\n\n#define DEFAULT_JAMSIZE    4  \n\n#define QEC_RESET_TRIES 200\n\nstatic int qec_global_reset(void __iomem *gregs)\n{\n\tint tries = QEC_RESET_TRIES;\n\n\tsbus_writel(GLOB_CTRL_RESET, gregs + GLOB_CTRL);\n\twhile (--tries) {\n\t\tif (sbus_readl(gregs + GLOB_CTRL) & GLOB_CTRL_RESET) {\n\t\t\tudelay(20);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (tries)\n\t\treturn 0;\n\tprintk(KERN_ERR \"BigMAC: Cannot reset the QEC.\\n\");\n\treturn -1;\n}\n\nstatic void qec_init(struct bigmac *bp)\n{\n\tstruct platform_device *qec_op = bp->qec_op;\n\tvoid __iomem *gregs = bp->gregs;\n\tu8 bsizes = bp->bigmac_bursts;\n\tu32 regval;\n\n\t \n\tif (bsizes & DMA_BURST32)\n\t\tregval = GLOB_CTRL_B32;\n\telse\n\t\tregval = GLOB_CTRL_B16;\n\tsbus_writel(regval | GLOB_CTRL_BMODE, gregs + GLOB_CTRL);\n\tsbus_writel(GLOB_PSIZE_2048, gregs + GLOB_PSIZE);\n\n\t \n\tsbus_writel(resource_size(&qec_op->resource[1]),\n\t\t    gregs + GLOB_MSIZE);\n\n\t \n\tsbus_writel(resource_size(&qec_op->resource[1]) >> 1,\n\t\t    gregs + GLOB_TSIZE);\n\tsbus_writel(resource_size(&qec_op->resource[1]) >> 1,\n\t\t    gregs + GLOB_RSIZE);\n}\n\n#define TX_RESET_TRIES     32\n#define RX_RESET_TRIES     32\n\nstatic void bigmac_tx_reset(void __iomem *bregs)\n{\n\tint tries = TX_RESET_TRIES;\n\n\tsbus_writel(0, bregs + BMAC_TXCFG);\n\n\t \n\twhile ((sbus_readl(bregs + BMAC_TXCFG) & ~(BIGMAC_TXCFG_FIFO)) != 0 &&\n\t       --tries != 0)\n\t\tudelay(20);\n\n\tif (!tries) {\n\t\tprintk(KERN_ERR \"BIGMAC: Transmitter will not reset.\\n\");\n\t\tprintk(KERN_ERR \"BIGMAC: tx_cfg is %08x\\n\",\n\t\t       sbus_readl(bregs + BMAC_TXCFG));\n\t}\n}\n\nstatic void bigmac_rx_reset(void __iomem *bregs)\n{\n\tint tries = RX_RESET_TRIES;\n\n\tsbus_writel(0, bregs + BMAC_RXCFG);\n\twhile (sbus_readl(bregs + BMAC_RXCFG) && --tries)\n\t\tudelay(20);\n\n\tif (!tries) {\n\t\tprintk(KERN_ERR \"BIGMAC: Receiver will not reset.\\n\");\n\t\tprintk(KERN_ERR \"BIGMAC: rx_cfg is %08x\\n\",\n\t\t       sbus_readl(bregs + BMAC_RXCFG));\n\t}\n}\n\n \nstatic void bigmac_stop(struct bigmac *bp)\n{\n\tbigmac_tx_reset(bp->bregs);\n\tbigmac_rx_reset(bp->bregs);\n}\n\nstatic void bigmac_get_counters(struct bigmac *bp, void __iomem *bregs)\n{\n\tstruct net_device_stats *stats = &bp->dev->stats;\n\n\tstats->rx_crc_errors += sbus_readl(bregs + BMAC_RCRCECTR);\n\tsbus_writel(0, bregs + BMAC_RCRCECTR);\n\n\tstats->rx_frame_errors += sbus_readl(bregs + BMAC_UNALECTR);\n\tsbus_writel(0, bregs + BMAC_UNALECTR);\n\n\tstats->rx_length_errors += sbus_readl(bregs + BMAC_GLECTR);\n\tsbus_writel(0, bregs + BMAC_GLECTR);\n\n\tstats->tx_aborted_errors += sbus_readl(bregs + BMAC_EXCTR);\n\n\tstats->collisions +=\n\t\t(sbus_readl(bregs + BMAC_EXCTR) +\n\t\t sbus_readl(bregs + BMAC_LTCTR));\n\tsbus_writel(0, bregs + BMAC_EXCTR);\n\tsbus_writel(0, bregs + BMAC_LTCTR);\n}\n\nstatic void bigmac_clean_rings(struct bigmac *bp)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tif (bp->rx_skbs[i] != NULL) {\n\t\t\tdev_kfree_skb_any(bp->rx_skbs[i]);\n\t\t\tbp->rx_skbs[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tif (bp->tx_skbs[i] != NULL) {\n\t\t\tdev_kfree_skb_any(bp->tx_skbs[i]);\n\t\t\tbp->tx_skbs[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic void bigmac_init_rings(struct bigmac *bp, bool non_blocking)\n{\n\tstruct bmac_init_block *bb = bp->bmac_block;\n\tint i;\n\tgfp_t gfp_flags = GFP_KERNEL;\n\n\tif (non_blocking)\n\t\tgfp_flags = GFP_ATOMIC;\n\n\tbp->rx_new = bp->rx_old = bp->tx_new = bp->tx_old = 0;\n\n\t \n\tbigmac_clean_rings(bp);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = big_mac_alloc_skb(RX_BUF_ALLOC_SIZE, gfp_flags);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tbp->rx_skbs[i] = skb;\n\n\t\t \n\t\tskb_put(skb, ETH_FRAME_LEN);\n\t\tskb_reserve(skb, 34);\n\n\t\tbb->be_rxd[i].rx_addr =\n\t\t\tdma_map_single(&bp->bigmac_op->dev,\n\t\t\t\t       skb->data,\n\t\t\t\t       RX_BUF_ALLOC_SIZE - 34,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tbb->be_rxd[i].rx_flags =\n\t\t\t(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\n\t}\n\n\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\tbb->be_txd[i].tx_flags = bb->be_txd[i].tx_addr = 0;\n}\n\n#define MGMT_CLKON  (MGMT_PAL_INT_MDIO|MGMT_PAL_EXT_MDIO|MGMT_PAL_OENAB|MGMT_PAL_DCLOCK)\n#define MGMT_CLKOFF (MGMT_PAL_INT_MDIO|MGMT_PAL_EXT_MDIO|MGMT_PAL_OENAB)\n\nstatic void idle_transceiver(void __iomem *tregs)\n{\n\tint i = 20;\n\n\twhile (i--) {\n\t\tsbus_writel(MGMT_CLKOFF, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tsbus_writel(MGMT_CLKON, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t}\n}\n\nstatic void write_tcvr_bit(struct bigmac *bp, void __iomem *tregs, int bit)\n{\n\tif (bp->tcvr_type == internal) {\n\t\tbit = (bit & 1) << 3;\n\t\tsbus_writel(bit | (MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO),\n\t\t\t    tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tsbus_writel(bit | MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK,\n\t\t\t    tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t} else if (bp->tcvr_type == external) {\n\t\tbit = (bit & 1) << 2;\n\t\tsbus_writel(bit | MGMT_PAL_INT_MDIO | MGMT_PAL_OENAB,\n\t\t\t    tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tsbus_writel(bit | MGMT_PAL_INT_MDIO | MGMT_PAL_OENAB | MGMT_PAL_DCLOCK,\n\t\t\t    tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t} else {\n\t\tprintk(KERN_ERR \"write_tcvr_bit: No transceiver type known!\\n\");\n\t}\n}\n\nstatic int read_tcvr_bit(struct bigmac *bp, void __iomem *tregs)\n{\n\tint retval = 0;\n\n\tif (bp->tcvr_type == internal) {\n\t\tsbus_writel(MGMT_PAL_EXT_MDIO, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tsbus_writel(MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK,\n\t\t\t    tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_INT_MDIO) >> 3;\n\t} else if (bp->tcvr_type == external) {\n\t\tsbus_writel(MGMT_PAL_INT_MDIO, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_EXT_MDIO) >> 2;\n\t} else {\n\t\tprintk(KERN_ERR \"read_tcvr_bit: No transceiver type known!\\n\");\n\t}\n\treturn retval;\n}\n\nstatic int read_tcvr_bit2(struct bigmac *bp, void __iomem *tregs)\n{\n\tint retval = 0;\n\n\tif (bp->tcvr_type == internal) {\n\t\tsbus_writel(MGMT_PAL_EXT_MDIO, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_INT_MDIO) >> 3;\n\t\tsbus_writel(MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t} else if (bp->tcvr_type == external) {\n\t\tsbus_writel(MGMT_PAL_INT_MDIO, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t\tretval = (sbus_readl(tregs + TCVR_MPAL) & MGMT_PAL_EXT_MDIO) >> 2;\n\t\tsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK, tregs + TCVR_MPAL);\n\t\tsbus_readl(tregs + TCVR_MPAL);\n\t} else {\n\t\tprintk(KERN_ERR \"read_tcvr_bit2: No transceiver type known!\\n\");\n\t}\n\treturn retval;\n}\n\nstatic void put_tcvr_byte(struct bigmac *bp,\n\t\t\t  void __iomem *tregs,\n\t\t\t  unsigned int byte)\n{\n\tint shift = 4;\n\n\tdo {\n\t\twrite_tcvr_bit(bp, tregs, ((byte >> shift) & 1));\n\t\tshift -= 1;\n\t} while (shift >= 0);\n}\n\nstatic void bigmac_tcvr_write(struct bigmac *bp, void __iomem *tregs,\n\t\t\t      int reg, unsigned short val)\n{\n\tint shift;\n\n\treg &= 0xff;\n\tval &= 0xffff;\n\tswitch(bp->tcvr_type) {\n\tcase internal:\n\tcase external:\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"bigmac_tcvr_read: Whoops, no known transceiver type.\\n\");\n\t\treturn;\n\t}\n\n\tidle_transceiver(tregs);\n\twrite_tcvr_bit(bp, tregs, 0);\n\twrite_tcvr_bit(bp, tregs, 1);\n\twrite_tcvr_bit(bp, tregs, 0);\n\twrite_tcvr_bit(bp, tregs, 1);\n\n\tput_tcvr_byte(bp, tregs,\n\t\t      ((bp->tcvr_type == internal) ?\n\t\t       BIGMAC_PHY_INTERNAL : BIGMAC_PHY_EXTERNAL));\n\n\tput_tcvr_byte(bp, tregs, reg);\n\n\twrite_tcvr_bit(bp, tregs, 1);\n\twrite_tcvr_bit(bp, tregs, 0);\n\n\tshift = 15;\n\tdo {\n\t\twrite_tcvr_bit(bp, tregs, (val >> shift) & 1);\n\t\tshift -= 1;\n\t} while (shift >= 0);\n}\n\nstatic unsigned short bigmac_tcvr_read(struct bigmac *bp,\n\t\t\t\t       void __iomem *tregs,\n\t\t\t\t       int reg)\n{\n\tunsigned short retval = 0;\n\n\treg &= 0xff;\n\tswitch(bp->tcvr_type) {\n\tcase internal:\n\tcase external:\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"bigmac_tcvr_read: Whoops, no known transceiver type.\\n\");\n\t\treturn 0xffff;\n\t}\n\n\tidle_transceiver(tregs);\n\twrite_tcvr_bit(bp, tregs, 0);\n\twrite_tcvr_bit(bp, tregs, 1);\n\twrite_tcvr_bit(bp, tregs, 1);\n\twrite_tcvr_bit(bp, tregs, 0);\n\n\tput_tcvr_byte(bp, tregs,\n\t\t      ((bp->tcvr_type == internal) ?\n\t\t       BIGMAC_PHY_INTERNAL : BIGMAC_PHY_EXTERNAL));\n\n\tput_tcvr_byte(bp, tregs, reg);\n\n\tif (bp->tcvr_type == external) {\n\t\tint shift = 15;\n\n\t\t(void) read_tcvr_bit2(bp, tregs);\n\t\t(void) read_tcvr_bit2(bp, tregs);\n\n\t\tdo {\n\t\t\tint tmp;\n\n\t\t\ttmp = read_tcvr_bit2(bp, tregs);\n\t\t\tretval |= ((tmp & 1) << shift);\n\t\t\tshift -= 1;\n\t\t} while (shift >= 0);\n\n\t\t(void) read_tcvr_bit2(bp, tregs);\n\t\t(void) read_tcvr_bit2(bp, tregs);\n\t\t(void) read_tcvr_bit2(bp, tregs);\n\t} else {\n\t\tint shift = 15;\n\n\t\t(void) read_tcvr_bit(bp, tregs);\n\t\t(void) read_tcvr_bit(bp, tregs);\n\n\t\tdo {\n\t\t\tint tmp;\n\n\t\t\ttmp = read_tcvr_bit(bp, tregs);\n\t\t\tretval |= ((tmp & 1) << shift);\n\t\t\tshift -= 1;\n\t\t} while (shift >= 0);\n\n\t\t(void) read_tcvr_bit(bp, tregs);\n\t\t(void) read_tcvr_bit(bp, tregs);\n\t\t(void) read_tcvr_bit(bp, tregs);\n\t}\n\treturn retval;\n}\n\nstatic void bigmac_tcvr_init(struct bigmac *bp)\n{\n\tvoid __iomem *tregs = bp->tregs;\n\tu32 mpal;\n\n\tidle_transceiver(tregs);\n\tsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK,\n\t\t    tregs + TCVR_MPAL);\n\tsbus_readl(tregs + TCVR_MPAL);\n\n\t \n\tsbus_writel(MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO, tregs + TCVR_MPAL);\n\tsbus_readl(tregs + TCVR_MPAL);\n\tudelay(20);\n\n\tmpal = sbus_readl(tregs + TCVR_MPAL);\n\tif (mpal & MGMT_PAL_EXT_MDIO) {\n\t\tbp->tcvr_type = external;\n\t\tsbus_writel(~(TCVR_PAL_EXTLBACK | TCVR_PAL_MSENSE | TCVR_PAL_LTENABLE),\n\t\t\t    tregs + TCVR_TPAL);\n\t\tsbus_readl(tregs + TCVR_TPAL);\n\t} else if (mpal & MGMT_PAL_INT_MDIO) {\n\t\tbp->tcvr_type = internal;\n\t\tsbus_writel(~(TCVR_PAL_SERIAL | TCVR_PAL_EXTLBACK |\n\t\t\t      TCVR_PAL_MSENSE | TCVR_PAL_LTENABLE),\n\t\t\t    tregs + TCVR_TPAL);\n\t\tsbus_readl(tregs + TCVR_TPAL);\n\t} else {\n\t\tprintk(KERN_ERR \"BIGMAC: AIEEE, neither internal nor \"\n\t\t       \"external MDIO available!\\n\");\n\t\tprintk(KERN_ERR \"BIGMAC: mgmt_pal[%08x] tcvr_pal[%08x]\\n\",\n\t\t       sbus_readl(tregs + TCVR_MPAL),\n\t\t       sbus_readl(tregs + TCVR_TPAL));\n\t}\n}\n\nstatic int bigmac_init_hw(struct bigmac *, bool);\n\nstatic int try_next_permutation(struct bigmac *bp, void __iomem *tregs)\n{\n\tif (bp->sw_bmcr & BMCR_SPEED100) {\n\t\tint timeout;\n\n\t\t \n\t\tbp->sw_bmcr\t= (BMCR_ISOLATE | BMCR_PDOWN | BMCR_LOOPBACK);\n\t\tbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\n\t\tbp->sw_bmcr\t= (BMCR_RESET);\n\t\tbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\n\n\t\ttimeout = 64;\n\t\twhile (--timeout) {\n\t\t\tbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\n\t\t\tif ((bp->sw_bmcr & BMCR_RESET) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(20);\n\t\t}\n\t\tif (timeout == 0)\n\t\t\tprintk(KERN_ERR \"%s: PHY reset failed.\\n\", bp->dev->name);\n\n\t\tbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\n\n\t\t \n\t\tbp->sw_bmcr &= ~(BMCR_SPEED100);\n\t\tbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\n\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\nstatic void bigmac_timer(struct timer_list *t)\n{\n\tstruct bigmac *bp = from_timer(bp, t, bigmac_timer);\n\tvoid __iomem *tregs = bp->tregs;\n\tint restart_timer = 0;\n\n\tbp->timer_ticks++;\n\tif (bp->timer_state == ltrywait) {\n\t\tbp->sw_bmsr = bigmac_tcvr_read(bp, tregs, MII_BMSR);\n\t\tbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\n\t\tif (bp->sw_bmsr & BMSR_LSTATUS) {\n\t\t\tprintk(KERN_INFO \"%s: Link is now up at %s.\\n\",\n\t\t\t       bp->dev->name,\n\t\t\t       (bp->sw_bmcr & BMCR_SPEED100) ?\n\t\t\t       \"100baseT\" : \"10baseT\");\n\t\t\tbp->timer_state = asleep;\n\t\t\trestart_timer = 0;\n\t\t} else {\n\t\t\tif (bp->timer_ticks >= 4) {\n\t\t\t\tint ret;\n\n\t\t\t\tret = try_next_permutation(bp, tregs);\n\t\t\t\tif (ret == -1) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: Link down, cable problem?\\n\",\n\t\t\t\t\t       bp->dev->name);\n\t\t\t\t\tret = bigmac_init_hw(bp, true);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tprintk(KERN_ERR \"%s: Error, cannot re-init the \"\n\t\t\t\t\t\t       \"BigMAC.\\n\", bp->dev->name);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbp->timer_ticks = 0;\n\t\t\t\trestart_timer = 1;\n\t\t\t} else {\n\t\t\t\trestart_timer = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tprintk(KERN_ERR \"%s: Aieee, link timer is asleep but we got one anyways!\\n\",\n\t\t       bp->dev->name);\n\t\trestart_timer = 0;\n\t\tbp->timer_ticks = 0;\n\t\tbp->timer_state = asleep;  \n\t}\n\n\tif (restart_timer != 0) {\n\t\tbp->bigmac_timer.expires = jiffies + ((12 * HZ)/10);  \n\t\tadd_timer(&bp->bigmac_timer);\n\t}\n}\n\n \nstatic void bigmac_begin_auto_negotiation(struct bigmac *bp)\n{\n\tvoid __iomem *tregs = bp->tregs;\n\tint timeout;\n\n\t \n\tbp->sw_bmsr\t= bigmac_tcvr_read(bp, tregs, MII_BMSR);\n\tbp->sw_bmcr\t= bigmac_tcvr_read(bp, tregs, MII_BMCR);\n\n\t \n\tbp->sw_bmcr\t= (BMCR_ISOLATE | BMCR_PDOWN | BMCR_LOOPBACK);\n\tbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\n\tbp->sw_bmcr\t= (BMCR_RESET);\n\tbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\n\n\ttimeout = 64;\n\twhile (--timeout) {\n\t\tbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\n\t\tif ((bp->sw_bmcr & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tudelay(20);\n\t}\n\tif (timeout == 0)\n\t\tprintk(KERN_ERR \"%s: PHY reset failed.\\n\", bp->dev->name);\n\n\tbp->sw_bmcr = bigmac_tcvr_read(bp, tregs, MII_BMCR);\n\n\t \n\tbp->sw_bmcr |= BMCR_SPEED100;\n\tbigmac_tcvr_write(bp, tregs, MII_BMCR, bp->sw_bmcr);\n\n\tbp->timer_state = ltrywait;\n\tbp->timer_ticks = 0;\n\tbp->bigmac_timer.expires = jiffies + (12 * HZ) / 10;\n\tadd_timer(&bp->bigmac_timer);\n}\n\nstatic int bigmac_init_hw(struct bigmac *bp, bool non_blocking)\n{\n\tvoid __iomem *gregs        = bp->gregs;\n\tvoid __iomem *cregs        = bp->creg;\n\tvoid __iomem *bregs        = bp->bregs;\n\t__u32 bblk_dvma = (__u32)bp->bblock_dvma;\n\tconst unsigned char *e = &bp->dev->dev_addr[0];\n\n\t \n\tbigmac_get_counters(bp, bregs);\n\n\t \n\tqec_global_reset(gregs);\n\n\t \n\tqec_init(bp);\n\n\t \n\tbigmac_init_rings(bp, non_blocking);\n\n\t \n\tbigmac_tcvr_init(bp);\n\n\t \n\tbigmac_stop(bp);\n\n\t \n\tsbus_writel(((e[4] << 8) | e[5]), bregs + BMAC_MACADDR2);\n\tsbus_writel(((e[2] << 8) | e[3]), bregs + BMAC_MACADDR1);\n\tsbus_writel(((e[0] << 8) | e[1]), bregs + BMAC_MACADDR0);\n\n\t \n\tsbus_writel(0, bregs + BMAC_HTABLE3);\n\tsbus_writel(0, bregs + BMAC_HTABLE2);\n\tsbus_writel(0, bregs + BMAC_HTABLE1);\n\tsbus_writel(0, bregs + BMAC_HTABLE0);\n\n\t \n\tsbus_writel(BIGMAC_RXCFG_HENABLE | BIGMAC_RXCFG_FIFO,\n\t\t    bregs + BMAC_RXCFG);\n\tudelay(20);\n\n\t \n\tsbus_writel(BIGMAC_TXCFG_FIFO, bregs + BMAC_TXCFG);\n\n\t \n\tsbus_writel(((e[5] | e[4] << 8) & 0x3ff),\n\t\t    bregs + BMAC_RSEED);\n\n\t \n\tsbus_writel(BIGMAC_XCFG_ODENABLE | BIGMAC_XCFG_RESV,\n\t\t    bregs + BMAC_XIFCFG);\n\n\t \n\tsbus_writel(bblk_dvma + bib_offset(be_rxd, 0),\n\t\t    cregs + CREG_RXDS);\n\tsbus_writel(bblk_dvma + bib_offset(be_txd, 0),\n\t\t    cregs + CREG_TXDS);\n\n\t \n\tsbus_writel(0, cregs + CREG_RXRBUFPTR);\n\tsbus_writel(0, cregs + CREG_RXWBUFPTR);\n\tsbus_writel(sbus_readl(gregs + GLOB_RSIZE),\n\t\t    cregs + CREG_TXRBUFPTR);\n\tsbus_writel(sbus_readl(gregs + GLOB_RSIZE),\n\t\t    cregs + CREG_TXWBUFPTR);\n\n\t \n\tsbus_writel(BIGMAC_IMASK_GOTFRAME | BIGMAC_IMASK_SENTFRAME,\n\t\t    bregs + BMAC_IMASK);\n\n\t \n\tsbus_writel(0, cregs + CREG_RIMASK);\n\tsbus_writel(0, cregs + CREG_TIMASK);\n\tsbus_writel(0, cregs + CREG_QMASK);\n\tsbus_writel(0, cregs + CREG_BMASK);\n\n\t \n\tsbus_writel(DEFAULT_JAMSIZE, bregs + BMAC_JSIZE);\n\n\t \n\tsbus_writel(0, cregs + CREG_CCNT);\n\n\t \n\tsbus_writel(sbus_readl(bregs + BMAC_TXCFG) | BIGMAC_TXCFG_ENABLE,\n\t\t    bregs + BMAC_TXCFG);\n\tsbus_writel(sbus_readl(bregs + BMAC_RXCFG) | BIGMAC_RXCFG_ENABLE,\n\t\t    bregs + BMAC_RXCFG);\n\n\t \n\tbigmac_begin_auto_negotiation(bp);\n\n\t \n\treturn 0;\n}\n\n \nstatic void bigmac_is_medium_rare(struct bigmac *bp, u32 qec_status, u32 bmac_status)\n{\n\tprintk(KERN_ERR \"bigmac_is_medium_rare: \");\n\tif (qec_status & (GLOB_STAT_ER | GLOB_STAT_BM)) {\n\t\tif (qec_status & GLOB_STAT_ER)\n\t\t\tprintk(\"QEC_ERROR, \");\n\t\tif (qec_status & GLOB_STAT_BM)\n\t\t\tprintk(\"QEC_BMAC_ERROR, \");\n\t}\n\tif (bmac_status & CREG_STAT_ERRORS) {\n\t\tif (bmac_status & CREG_STAT_BERROR)\n\t\t\tprintk(\"BMAC_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_TXDERROR)\n\t\t\tprintk(\"TXD_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_TXLERR)\n\t\t\tprintk(\"TX_LATE_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_TXPERR)\n\t\t\tprintk(\"TX_PARITY_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_TXSERR)\n\t\t\tprintk(\"TX_SBUS_ERROR, \");\n\n\t\tif (bmac_status & CREG_STAT_RXDROP)\n\t\t\tprintk(\"RX_DROP_ERROR, \");\n\n\t\tif (bmac_status & CREG_STAT_RXSMALL)\n\t\t\tprintk(\"RX_SMALL_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_RXLERR)\n\t\t\tprintk(\"RX_LATE_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_RXPERR)\n\t\t\tprintk(\"RX_PARITY_ERROR, \");\n\t\tif (bmac_status & CREG_STAT_RXSERR)\n\t\t\tprintk(\"RX_SBUS_ERROR, \");\n\t}\n\n\tprintk(\" RESET\\n\");\n\tbigmac_init_hw(bp, true);\n}\n\n \nstatic void bigmac_tx(struct bigmac *bp)\n{\n\tstruct be_txd *txbase = &bp->bmac_block->be_txd[0];\n\tstruct net_device *dev = bp->dev;\n\tint elem;\n\n\tspin_lock(&bp->lock);\n\n\telem = bp->tx_old;\n\tDTX((\"bigmac_tx: tx_old[%d] \", elem));\n\twhile (elem != bp->tx_new) {\n\t\tstruct sk_buff *skb;\n\t\tstruct be_txd *this = &txbase[elem];\n\n\t\tDTX((\"this(%p) [flags(%08x)addr(%08x)]\",\n\t\t     this, this->tx_flags, this->tx_addr));\n\n\t\tif (this->tx_flags & TXD_OWN)\n\t\t\tbreak;\n\t\tskb = bp->tx_skbs[elem];\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += skb->len;\n\t\tdma_unmap_single(&bp->bigmac_op->dev,\n\t\t\t\t this->tx_addr, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\tDTX((\"skb(%p) \", skb));\n\t\tbp->tx_skbs[elem] = NULL;\n\t\tdev_consume_skb_irq(skb);\n\n\t\telem = NEXT_TX(elem);\n\t}\n\tDTX((\" DONE, tx_old=%d\\n\", elem));\n\tbp->tx_old = elem;\n\n\tif (netif_queue_stopped(dev) &&\n\t    TX_BUFFS_AVAIL(bp) > 0)\n\t\tnetif_wake_queue(bp->dev);\n\n\tspin_unlock(&bp->lock);\n}\n\n \nstatic void bigmac_rx(struct bigmac *bp)\n{\n\tstruct be_rxd *rxbase = &bp->bmac_block->be_rxd[0];\n\tstruct be_rxd *this;\n\tint elem = bp->rx_new, drops = 0;\n\tu32 flags;\n\n\tthis = &rxbase[elem];\n\twhile (!((flags = this->rx_flags) & RXD_OWN)) {\n\t\tstruct sk_buff *skb;\n\t\tint len = (flags & RXD_LENGTH);  \n\n\t\t \n\t\tif (len < ETH_ZLEN) {\n\t\t\tbp->dev->stats.rx_errors++;\n\t\t\tbp->dev->stats.rx_length_errors++;\n\n\tdrop_it:\n\t\t\t \n\t\t\tbp->dev->stats.rx_dropped++;\n\t\t\tthis->rx_flags =\n\t\t\t\t(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\n\t\t\tgoto next;\n\t\t}\n\t\tskb = bp->rx_skbs[elem];\n\t\tif (len > RX_COPY_THRESHOLD) {\n\t\t\tstruct sk_buff *new_skb;\n\n\t\t\t \n\t\t\tnew_skb = big_mac_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\n\t\t\tif (new_skb == NULL) {\n\t\t\t\tdrops++;\n\t\t\t\tgoto drop_it;\n\t\t\t}\n\t\t\tdma_unmap_single(&bp->bigmac_op->dev,\n\t\t\t\t\t this->rx_addr,\n\t\t\t\t\t RX_BUF_ALLOC_SIZE - 34,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tbp->rx_skbs[elem] = new_skb;\n\t\t\tskb_put(new_skb, ETH_FRAME_LEN);\n\t\t\tskb_reserve(new_skb, 34);\n\t\t\tthis->rx_addr =\n\t\t\t\tdma_map_single(&bp->bigmac_op->dev,\n\t\t\t\t\t       new_skb->data,\n\t\t\t\t\t       RX_BUF_ALLOC_SIZE - 34,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tthis->rx_flags =\n\t\t\t\t(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\n\n\t\t\t \n\t\t\tskb_trim(skb, len);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = netdev_alloc_skb(bp->dev, len + 2);\n\n\t\t\tif (copy_skb == NULL) {\n\t\t\t\tdrops++;\n\t\t\t\tgoto drop_it;\n\t\t\t}\n\t\t\tskb_reserve(copy_skb, 2);\n\t\t\tskb_put(copy_skb, len);\n\t\t\tdma_sync_single_for_cpu(&bp->bigmac_op->dev,\n\t\t\t\t\t\tthis->rx_addr, len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tskb_copy_to_linear_data(copy_skb, (unsigned char *)skb->data, len);\n\t\t\tdma_sync_single_for_device(&bp->bigmac_op->dev,\n\t\t\t\t\t\t   this->rx_addr, len,\n\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tthis->rx_flags =\n\t\t\t\t(RXD_OWN | ((RX_BUF_ALLOC_SIZE - 34) & RXD_LENGTH));\n\n\t\t\tskb = copy_skb;\n\t\t}\n\n\t\t \n\t\tskb->protocol = eth_type_trans(skb, bp->dev);\n\t\tnetif_rx(skb);\n\t\tbp->dev->stats.rx_packets++;\n\t\tbp->dev->stats.rx_bytes += len;\n\tnext:\n\t\telem = NEXT_RX(elem);\n\t\tthis = &rxbase[elem];\n\t}\n\tbp->rx_new = elem;\n\tif (drops)\n\t\tprintk(KERN_NOTICE \"%s: Memory squeeze, deferring packet.\\n\", bp->dev->name);\n}\n\nstatic irqreturn_t bigmac_interrupt(int irq, void *dev_id)\n{\n\tstruct bigmac *bp = (struct bigmac *) dev_id;\n\tu32 qec_status, bmac_status;\n\n\tDIRQ((\"bigmac_interrupt: \"));\n\n\t \n\tbmac_status = sbus_readl(bp->creg + CREG_STAT);\n\tqec_status = sbus_readl(bp->gregs + GLOB_STAT);\n\n\tDIRQ((\"qec_status=%08x bmac_status=%08x\\n\", qec_status, bmac_status));\n\tif ((qec_status & (GLOB_STAT_ER | GLOB_STAT_BM)) ||\n\t   (bmac_status & CREG_STAT_ERRORS))\n\t\tbigmac_is_medium_rare(bp, qec_status, bmac_status);\n\n\tif (bmac_status & CREG_STAT_TXIRQ)\n\t\tbigmac_tx(bp);\n\n\tif (bmac_status & CREG_STAT_RXIRQ)\n\t\tbigmac_rx(bp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bigmac_open(struct net_device *dev)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\tint ret;\n\n\tret = request_irq(dev->irq, bigmac_interrupt, IRQF_SHARED, dev->name, bp);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BIGMAC: Can't order irq %d to go.\\n\", dev->irq);\n\t\treturn ret;\n\t}\n\ttimer_setup(&bp->bigmac_timer, bigmac_timer, 0);\n\tret = bigmac_init_hw(bp, false);\n\tif (ret)\n\t\tfree_irq(dev->irq, bp);\n\treturn ret;\n}\n\nstatic int bigmac_close(struct net_device *dev)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\n\tdel_timer(&bp->bigmac_timer);\n\tbp->timer_state = asleep;\n\tbp->timer_ticks = 0;\n\n\tbigmac_stop(bp);\n\tbigmac_clean_rings(bp);\n\tfree_irq(dev->irq, bp);\n\treturn 0;\n}\n\nstatic void bigmac_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\n\tbigmac_init_hw(bp, true);\n\tnetif_wake_queue(dev);\n}\n\n \nstatic netdev_tx_t\nbigmac_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\tint len, entry;\n\tu32 mapping;\n\n\tlen = skb->len;\n\tmapping = dma_map_single(&bp->bigmac_op->dev, skb->data,\n\t\t\t\t len, DMA_TO_DEVICE);\n\n\t \n\tspin_lock_irq(&bp->lock);\n\tentry = bp->tx_new;\n\tDTX((\"bigmac_start_xmit: len(%d) entry(%d)\\n\", len, entry));\n\tbp->bmac_block->be_txd[entry].tx_flags = TXD_UPDATE;\n\tbp->tx_skbs[entry] = skb;\n\tbp->bmac_block->be_txd[entry].tx_addr = mapping;\n\tbp->bmac_block->be_txd[entry].tx_flags =\n\t\t(TXD_OWN | TXD_SOP | TXD_EOP | (len & TXD_LENGTH));\n\tbp->tx_new = NEXT_TX(entry);\n\tif (TX_BUFFS_AVAIL(bp) <= 0)\n\t\tnetif_stop_queue(dev);\n\tspin_unlock_irq(&bp->lock);\n\n\t \n\tsbus_writel(CREG_CTRL_TWAKEUP, bp->creg + CREG_CTRL);\n\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct net_device_stats *bigmac_get_stats(struct net_device *dev)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\n\tbigmac_get_counters(bp, bp->bregs);\n\treturn &dev->stats;\n}\n\nstatic void bigmac_set_multicast(struct net_device *dev)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\tvoid __iomem *bregs = bp->bregs;\n\tstruct netdev_hw_addr *ha;\n\tu32 tmp, crc;\n\n\t \n\ttmp = sbus_readl(bregs + BMAC_RXCFG);\n\ttmp &= ~(BIGMAC_RXCFG_ENABLE);\n\tsbus_writel(tmp, bregs + BMAC_RXCFG);\n\twhile ((sbus_readl(bregs + BMAC_RXCFG) & BIGMAC_RXCFG_ENABLE) != 0)\n\t\tudelay(20);\n\n\tif ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\n\t\tsbus_writel(0xffff, bregs + BMAC_HTABLE0);\n\t\tsbus_writel(0xffff, bregs + BMAC_HTABLE1);\n\t\tsbus_writel(0xffff, bregs + BMAC_HTABLE2);\n\t\tsbus_writel(0xffff, bregs + BMAC_HTABLE3);\n\t} else if (dev->flags & IFF_PROMISC) {\n\t\ttmp = sbus_readl(bregs + BMAC_RXCFG);\n\t\ttmp |= BIGMAC_RXCFG_PMISC;\n\t\tsbus_writel(tmp, bregs + BMAC_RXCFG);\n\t} else {\n\t\tu16 hash_table[4] = { 0 };\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t\tsbus_writel(hash_table[0], bregs + BMAC_HTABLE0);\n\t\tsbus_writel(hash_table[1], bregs + BMAC_HTABLE1);\n\t\tsbus_writel(hash_table[2], bregs + BMAC_HTABLE2);\n\t\tsbus_writel(hash_table[3], bregs + BMAC_HTABLE3);\n\t}\n\n\t \n\ttmp = sbus_readl(bregs + BMAC_RXCFG);\n\ttmp |= BIGMAC_RXCFG_ENABLE;\n\tsbus_writel(tmp, bregs + BMAC_RXCFG);\n}\n\n \nstatic void bigmac_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"sunbmac\", sizeof(info->driver));\n\tstrscpy(info->version, \"2.0\", sizeof(info->version));\n}\n\nstatic u32 bigmac_get_link(struct net_device *dev)\n{\n\tstruct bigmac *bp = netdev_priv(dev);\n\n\tspin_lock_irq(&bp->lock);\n\tbp->sw_bmsr = bigmac_tcvr_read(bp, bp->tregs, MII_BMSR);\n\tspin_unlock_irq(&bp->lock);\n\n\treturn (bp->sw_bmsr & BMSR_LSTATUS);\n}\n\nstatic const struct ethtool_ops bigmac_ethtool_ops = {\n\t.get_drvinfo\t\t= bigmac_get_drvinfo,\n\t.get_link\t\t= bigmac_get_link,\n};\n\nstatic const struct net_device_ops bigmac_ops = {\n\t.ndo_open\t\t= bigmac_open,\n\t.ndo_stop\t\t= bigmac_close,\n\t.ndo_start_xmit\t\t= bigmac_start_xmit,\n\t.ndo_get_stats\t\t= bigmac_get_stats,\n\t.ndo_set_rx_mode\t= bigmac_set_multicast,\n\t.ndo_tx_timeout\t\t= bigmac_tx_timeout,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int bigmac_ether_init(struct platform_device *op,\n\t\t\t     struct platform_device *qec_op)\n{\n\tstatic int version_printed;\n\tstruct net_device *dev;\n\tu8 bsizes, bsizes_more;\n\tstruct bigmac *bp;\n\n\t \n\tdev = alloc_etherdev(sizeof(struct bigmac));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tif (version_printed++ == 0)\n\t\tprintk(KERN_INFO \"%s\", version);\n\n\teth_hw_addr_set(dev, idprom->id_ethaddr);\n\n\t \n\tbp = netdev_priv(dev);\n\tbp->qec_op = qec_op;\n\tbp->bigmac_op = op;\n\n\tSET_NETDEV_DEV(dev, &op->dev);\n\n\tspin_lock_init(&bp->lock);\n\n\t \n\tbp->gregs = of_ioremap(&qec_op->resource[0], 0,\n\t\t\t       GLOB_REG_SIZE, \"BigMAC QEC GLobal Regs\");\n\tif (!bp->gregs) {\n\t\tprintk(KERN_ERR \"BIGMAC: Cannot map QEC global registers.\\n\");\n\t\tgoto fail_and_cleanup;\n\t}\n\n\t \n\tif ((sbus_readl(bp->gregs + GLOB_CTRL) & 0xf0000000) != GLOB_CTRL_BMODE) {\n\t\tprintk(KERN_ERR \"BigMAC: AIEEE, QEC is not in BigMAC mode!\\n\");\n\t\tgoto fail_and_cleanup;\n\t}\n\n\t \n\tif (qec_global_reset(bp->gregs))\n\t\tgoto fail_and_cleanup;\n\n\t \n\tbsizes = of_getintprop_default(qec_op->dev.of_node, \"burst-sizes\", 0xff);\n\tbsizes_more = of_getintprop_default(qec_op->dev.of_node, \"burst-sizes\", 0xff);\n\n\tbsizes &= 0xff;\n\tif (bsizes_more != 0xff)\n\t\tbsizes &= bsizes_more;\n\tif (bsizes == 0xff || (bsizes & DMA_BURST16) == 0 ||\n\t    (bsizes & DMA_BURST32) == 0)\n\t\tbsizes = (DMA_BURST32 - 1);\n\tbp->bigmac_bursts = bsizes;\n\n\t \n\tqec_init(bp);\n\n\t \n\tbp->creg = of_ioremap(&op->resource[0], 0,\n\t\t\t      CREG_REG_SIZE, \"BigMAC QEC Channel Regs\");\n\tif (!bp->creg) {\n\t\tprintk(KERN_ERR \"BIGMAC: Cannot map QEC channel registers.\\n\");\n\t\tgoto fail_and_cleanup;\n\t}\n\n\t \n\tbp->bregs = of_ioremap(&op->resource[1], 0,\n\t\t\t       BMAC_REG_SIZE, \"BigMAC Primary Regs\");\n\tif (!bp->bregs) {\n\t\tprintk(KERN_ERR \"BIGMAC: Cannot map BigMAC primary registers.\\n\");\n\t\tgoto fail_and_cleanup;\n\t}\n\n\t \n\tbp->tregs = of_ioremap(&op->resource[2], 0,\n\t\t\t       TCVR_REG_SIZE, \"BigMAC Transceiver Regs\");\n\tif (!bp->tregs) {\n\t\tprintk(KERN_ERR \"BIGMAC: Cannot map BigMAC transceiver registers.\\n\");\n\t\tgoto fail_and_cleanup;\n\t}\n\n\t \n\tbigmac_stop(bp);\n\n\t \n\tbp->bmac_block = dma_alloc_coherent(&bp->bigmac_op->dev,\n\t\t\t\t\t    PAGE_SIZE,\n\t\t\t\t\t    &bp->bblock_dvma, GFP_ATOMIC);\n\tif (bp->bmac_block == NULL || bp->bblock_dvma == 0)\n\t\tgoto fail_and_cleanup;\n\n\t \n\tbp->board_rev = of_getintprop_default(bp->bigmac_op->dev.of_node,\n\t\t\t\t\t      \"board-version\", 1);\n\n\t \n\ttimer_setup(&bp->bigmac_timer, bigmac_timer, 0);\n\tbp->timer_state = asleep;\n\tbp->timer_ticks = 0;\n\n\t \n\tbp->dev = dev;\n\n\t \n\tdev->ethtool_ops = &bigmac_ethtool_ops;\n\tdev->netdev_ops = &bigmac_ops;\n\tdev->watchdog_timeo = 5*HZ;\n\n\t \n\tdev->irq = bp->bigmac_op->archdata.irqs[0];\n\tdev->dma = 0;\n\n\tif (register_netdev(dev)) {\n\t\tprintk(KERN_ERR \"BIGMAC: Cannot register device.\\n\");\n\t\tgoto fail_and_cleanup;\n\t}\n\n\tdev_set_drvdata(&bp->bigmac_op->dev, bp);\n\n\tprintk(KERN_INFO \"%s: BigMAC 100baseT Ethernet %pM\\n\",\n\t       dev->name, dev->dev_addr);\n\n\treturn 0;\n\nfail_and_cleanup:\n\t \n\t \n\tif (bp->gregs)\n\t\tof_iounmap(&qec_op->resource[0], bp->gregs, GLOB_REG_SIZE);\n\tif (bp->creg)\n\t\tof_iounmap(&op->resource[0], bp->creg, CREG_REG_SIZE);\n\tif (bp->bregs)\n\t\tof_iounmap(&op->resource[1], bp->bregs, BMAC_REG_SIZE);\n\tif (bp->tregs)\n\t\tof_iounmap(&op->resource[2], bp->tregs, TCVR_REG_SIZE);\n\n\tif (bp->bmac_block)\n\t\tdma_free_coherent(&bp->bigmac_op->dev,\n\t\t\t\t  PAGE_SIZE,\n\t\t\t\t  bp->bmac_block,\n\t\t\t\t  bp->bblock_dvma);\n\n\t \n\tfree_netdev(dev);\n\treturn -ENODEV;\n}\n\n \nstatic int bigmac_sbus_probe(struct platform_device *op)\n{\n\tstruct device *parent = op->dev.parent;\n\tstruct platform_device *qec_op;\n\n\tqec_op = to_platform_device(parent);\n\n\treturn bigmac_ether_init(op, qec_op);\n}\n\nstatic int bigmac_sbus_remove(struct platform_device *op)\n{\n\tstruct bigmac *bp = platform_get_drvdata(op);\n\tstruct device *parent = op->dev.parent;\n\tstruct net_device *net_dev = bp->dev;\n\tstruct platform_device *qec_op;\n\n\tqec_op = to_platform_device(parent);\n\n\tunregister_netdev(net_dev);\n\n\tof_iounmap(&qec_op->resource[0], bp->gregs, GLOB_REG_SIZE);\n\tof_iounmap(&op->resource[0], bp->creg, CREG_REG_SIZE);\n\tof_iounmap(&op->resource[1], bp->bregs, BMAC_REG_SIZE);\n\tof_iounmap(&op->resource[2], bp->tregs, TCVR_REG_SIZE);\n\tdma_free_coherent(&op->dev,\n\t\t\t  PAGE_SIZE,\n\t\t\t  bp->bmac_block,\n\t\t\t  bp->bblock_dvma);\n\n\tfree_netdev(net_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bigmac_sbus_match[] = {\n\t{\n\t\t.name = \"be\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, bigmac_sbus_match);\n\nstatic struct platform_driver bigmac_sbus_driver = {\n\t.driver = {\n\t\t.name = \"sunbmac\",\n\t\t.of_match_table = bigmac_sbus_match,\n\t},\n\t.probe\t\t= bigmac_sbus_probe,\n\t.remove\t\t= bigmac_sbus_remove,\n};\n\nmodule_platform_driver(bigmac_sbus_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}