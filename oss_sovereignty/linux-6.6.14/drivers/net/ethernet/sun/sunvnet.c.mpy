{
  "module_name": "sunvnet.c",
  "hash_id": "de7a60efd85b07bb46264fe7df448f72adee62f7a9a50784ffae615696086170",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sun/sunvnet.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/if_vlan.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/icmpv6.h>\n#endif\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n\n#include <asm/vio.h>\n#include <asm/ldc.h>\n\n#include \"sunvnet_common.h\"\n\n \n#define VNET_TX_TIMEOUT\t\t\t(5 * HZ)\n\n#define DRV_MODULE_NAME\t\t\"sunvnet\"\n#define DRV_MODULE_VERSION\t\"2.0\"\n#define DRV_MODULE_RELDATE\t\"February 3, 2017\"\n\nstatic char version[] =\n\tDRV_MODULE_NAME \" \" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\";\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"Sun LDOM virtual network driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n \nstatic struct vio_version vnet_versions[] = {\n\t{ .major = 1, .minor = 8 },\n\t{ .major = 1, .minor = 7 },\n\t{ .major = 1, .minor = 6 },\n\t{ .major = 1, .minor = 0 },\n};\n\nstatic void vnet_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\n}\n\nstatic u32 vnet_get_msglevel(struct net_device *dev)\n{\n\tstruct vnet *vp = netdev_priv(dev);\n\n\treturn vp->msg_enable;\n}\n\nstatic void vnet_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct vnet *vp = netdev_priv(dev);\n\n\tvp->msg_enable = value;\n}\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"rx_packets\" },\n\t{ \"tx_packets\" },\n\t{ \"rx_bytes\" },\n\t{ \"tx_bytes\" },\n\t{ \"rx_errors\" },\n\t{ \"tx_errors\" },\n\t{ \"rx_dropped\" },\n\t{ \"tx_dropped\" },\n\t{ \"multicast\" },\n\t{ \"rx_length_errors\" },\n\t{ \"rx_frame_errors\" },\n\t{ \"rx_missed_errors\" },\n\t{ \"tx_carrier_errors\" },\n\t{ \"nports\" },\n};\n\nstatic int vnet_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct vnet *vp = (struct vnet *)netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ethtool_stats_keys)\n\t\t\t+ (NUM_VNET_PORT_STATS * vp->nports);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void vnet_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tstruct vnet *vp = (struct vnet *)netdev_priv(dev);\n\tstruct vnet_port *port;\n\tchar *p = (char *)buf;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\n\t\tp += sizeof(ethtool_stats_keys);\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(port, &vp->port_list, list) {\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.%s-%pM\",\n\t\t\t\t port->q_index, port->switch_port ? \"s\" : \"q\",\n\t\t\t\t port->raddr);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.rx_packets\",\n\t\t\t\t port->q_index);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.tx_packets\",\n\t\t\t\t port->q_index);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.rx_bytes\",\n\t\t\t\t port->q_index);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.tx_bytes\",\n\t\t\t\t port->q_index);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.event_up\",\n\t\t\t\t port->q_index);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsnprintf(p, ETH_GSTRING_LEN, \"p%u.event_reset\",\n\t\t\t\t port->q_index);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\trcu_read_unlock();\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic void vnet_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *estats, u64 *data)\n{\n\tstruct vnet *vp = (struct vnet *)netdev_priv(dev);\n\tstruct vnet_port *port;\n\tint i = 0;\n\n\tdata[i++] = dev->stats.rx_packets;\n\tdata[i++] = dev->stats.tx_packets;\n\tdata[i++] = dev->stats.rx_bytes;\n\tdata[i++] = dev->stats.tx_bytes;\n\tdata[i++] = dev->stats.rx_errors;\n\tdata[i++] = dev->stats.tx_errors;\n\tdata[i++] = dev->stats.rx_dropped;\n\tdata[i++] = dev->stats.tx_dropped;\n\tdata[i++] = dev->stats.multicast;\n\tdata[i++] = dev->stats.rx_length_errors;\n\tdata[i++] = dev->stats.rx_frame_errors;\n\tdata[i++] = dev->stats.rx_missed_errors;\n\tdata[i++] = dev->stats.tx_carrier_errors;\n\tdata[i++] = vp->nports;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(port, &vp->port_list, list) {\n\t\tdata[i++] = port->q_index;\n\t\tdata[i++] = port->stats.rx_packets;\n\t\tdata[i++] = port->stats.tx_packets;\n\t\tdata[i++] = port->stats.rx_bytes;\n\t\tdata[i++] = port->stats.tx_bytes;\n\t\tdata[i++] = port->stats.event_up;\n\t\tdata[i++] = port->stats.event_reset;\n\t}\n\trcu_read_unlock();\n}\n\nstatic const struct ethtool_ops vnet_ethtool_ops = {\n\t.get_drvinfo\t\t= vnet_get_drvinfo,\n\t.get_msglevel\t\t= vnet_get_msglevel,\n\t.set_msglevel\t\t= vnet_set_msglevel,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_sset_count\t\t= vnet_get_sset_count,\n\t.get_strings\t\t= vnet_get_strings,\n\t.get_ethtool_stats\t= vnet_get_ethtool_stats,\n};\n\nstatic LIST_HEAD(vnet_list);\nstatic DEFINE_MUTEX(vnet_list_mutex);\n\nstatic struct vnet_port *__tx_port_find(struct vnet *vp, struct sk_buff *skb)\n{\n\tunsigned int hash = vnet_hashfn(skb->data);\n\tstruct hlist_head *hp = &vp->port_hash[hash];\n\tstruct vnet_port *port;\n\n\thlist_for_each_entry_rcu(port, hp, hash) {\n\t\tif (!sunvnet_port_is_up_common(port))\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(port->raddr, skb->data))\n\t\t\treturn port;\n\t}\n\tlist_for_each_entry_rcu(port, &vp->port_list, list) {\n\t\tif (!port->switch_port)\n\t\t\tcontinue;\n\t\tif (!sunvnet_port_is_up_common(port))\n\t\t\tcontinue;\n\t\treturn port;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct vnet_port *vnet_tx_port_find(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct vnet *vp = netdev_priv(dev);\n\n\treturn __tx_port_find(vp, skb);\n}\n\nstatic u16 vnet_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t     struct net_device *sb_dev)\n{\n\tstruct vnet *vp = netdev_priv(dev);\n\tstruct vnet_port *port = __tx_port_find(vp, skb);\n\n\tif (!port)\n\t\treturn 0;\n\n\treturn port->q_index;\n}\n\n \nstatic netdev_tx_t vnet_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\treturn sunvnet_start_xmit_common(skb, dev, vnet_tx_port_find);\n}\n\nstatic void vnet_set_rx_mode(struct net_device *dev)\n{\n\tstruct vnet *vp = netdev_priv(dev);\n\n\treturn sunvnet_set_rx_mode_common(dev, vp);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void vnet_poll_controller(struct net_device *dev)\n{\n\tstruct vnet *vp = netdev_priv(dev);\n\n\treturn sunvnet_poll_controller_common(dev, vp);\n}\n#endif\n\nstatic const struct net_device_ops vnet_ops = {\n\t.ndo_open\t\t= sunvnet_open_common,\n\t.ndo_stop\t\t= sunvnet_close_common,\n\t.ndo_set_rx_mode\t= vnet_set_rx_mode,\n\t.ndo_set_mac_address\t= sunvnet_set_mac_addr_common,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= sunvnet_tx_timeout_common,\n\t.ndo_start_xmit\t\t= vnet_start_xmit,\n\t.ndo_select_queue\t= vnet_select_queue,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= vnet_poll_controller,\n#endif\n};\n\nstatic struct vnet *vnet_new(const u64 *local_mac,\n\t\t\t     struct vio_dev *vdev)\n{\n\tstruct net_device *dev;\n\tu8 addr[ETH_ALEN];\n\tstruct vnet *vp;\n\tint err, i;\n\n\tdev = alloc_etherdev_mqs(sizeof(*vp), VNET_MAX_TXQS, 1);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdev->needed_headroom = VNET_PACKET_SKIP + 8;\n\tdev->needed_tailroom = 8;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\taddr[i] = (*local_mac >> (5 - i) * 8) & 0xff;\n\teth_hw_addr_set(dev, addr);\n\n\tvp = netdev_priv(dev);\n\n\tspin_lock_init(&vp->lock);\n\tvp->dev = dev;\n\n\tINIT_LIST_HEAD(&vp->port_list);\n\tfor (i = 0; i < VNET_PORT_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&vp->port_hash[i]);\n\tINIT_LIST_HEAD(&vp->list);\n\tvp->local_mac = *local_mac;\n\n\tdev->netdev_ops = &vnet_ops;\n\tdev->ethtool_ops = &vnet_ethtool_ops;\n\tdev->watchdog_timeo = VNET_TX_TIMEOUT;\n\n\tdev->hw_features = NETIF_F_TSO | NETIF_F_GSO | NETIF_F_ALL_TSO |\n\t\t\t   NETIF_F_HW_CSUM | NETIF_F_SG;\n\tdev->features = dev->hw_features;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = VNET_MAX_MTU;\n\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tpr_err(\"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_free_dev;\n\t}\n\n\tnetdev_info(dev, \"Sun LDOM vnet %pM\\n\", dev->dev_addr);\n\n\tlist_add(&vp->list, &vnet_list);\n\n\treturn vp;\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\n\treturn ERR_PTR(err);\n}\n\nstatic struct vnet *vnet_find_or_create(const u64 *local_mac,\n\t\t\t\t\tstruct vio_dev *vdev)\n{\n\tstruct vnet *iter, *vp;\n\n\tmutex_lock(&vnet_list_mutex);\n\tvp = NULL;\n\tlist_for_each_entry(iter, &vnet_list, list) {\n\t\tif (iter->local_mac == *local_mac) {\n\t\t\tvp = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!vp)\n\t\tvp = vnet_new(local_mac, vdev);\n\tmutex_unlock(&vnet_list_mutex);\n\n\treturn vp;\n}\n\nstatic void vnet_cleanup(void)\n{\n\tstruct vnet *vp;\n\tstruct net_device *dev;\n\n\tmutex_lock(&vnet_list_mutex);\n\twhile (!list_empty(&vnet_list)) {\n\t\tvp = list_first_entry(&vnet_list, struct vnet, list);\n\t\tlist_del(&vp->list);\n\t\tdev = vp->dev;\n\t\t \n\t\tBUG_ON(!list_empty(&vp->port_list));\n\t\tunregister_netdev(dev);\n\t\tfree_netdev(dev);\n\t}\n\tmutex_unlock(&vnet_list_mutex);\n}\n\nstatic const char *local_mac_prop = \"local-mac-address\";\n\nstatic struct vnet *vnet_find_parent(struct mdesc_handle *hp,\n\t\t\t\t     u64 port_node,\n\t\t\t\t     struct vio_dev *vdev)\n{\n\tconst u64 *local_mac = NULL;\n\tu64 a;\n\n\tmdesc_for_each_arc(a, hp, port_node, MDESC_ARC_TYPE_BACK) {\n\t\tu64 target = mdesc_arc_target(hp, a);\n\t\tconst char *name;\n\n\t\tname = mdesc_get_property(hp, target, \"name\", NULL);\n\t\tif (!name || strcmp(name, \"network\"))\n\t\t\tcontinue;\n\n\t\tlocal_mac = mdesc_get_property(hp, target,\n\t\t\t\t\t       local_mac_prop, NULL);\n\t\tif (local_mac)\n\t\t\tbreak;\n\t}\n\tif (!local_mac)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn vnet_find_or_create(local_mac, vdev);\n}\n\nstatic struct ldc_channel_config vnet_ldc_cfg = {\n\t.event\t\t= sunvnet_event_common,\n\t.mtu\t\t= 64,\n\t.mode\t\t= LDC_MODE_UNRELIABLE,\n};\n\nstatic struct vio_driver_ops vnet_vio_ops = {\n\t.send_attr\t\t= sunvnet_send_attr_common,\n\t.handle_attr\t\t= sunvnet_handle_attr_common,\n\t.handshake_complete\t= sunvnet_handshake_complete_common,\n};\n\nconst char *remote_macaddr_prop = \"remote-mac-address\";\n\nstatic int vnet_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\n{\n\tstruct mdesc_handle *hp;\n\tstruct vnet_port *port;\n\tunsigned long flags;\n\tstruct vnet *vp;\n\tconst u64 *rmac;\n\tint len, i, err, switch_port;\n\n\thp = mdesc_grab();\n\n\tif (!hp)\n\t\treturn -ENODEV;\n\n\tvp = vnet_find_parent(hp, vdev->mp, vdev);\n\tif (IS_ERR(vp)) {\n\t\tpr_err(\"Cannot find port parent vnet\\n\");\n\t\terr = PTR_ERR(vp);\n\t\tgoto err_out_put_mdesc;\n\t}\n\n\trmac = mdesc_get_property(hp, vdev->mp, remote_macaddr_prop, &len);\n\terr = -ENODEV;\n\tif (!rmac) {\n\t\tpr_err(\"Port lacks %s property\\n\", remote_macaddr_prop);\n\t\tgoto err_out_put_mdesc;\n\t}\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!port)\n\t\tgoto err_out_put_mdesc;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tport->raddr[i] = (*rmac >> (5 - i) * 8) & 0xff;\n\n\tport->vp = vp;\n\n\terr = vio_driver_init(&port->vio, vdev, VDEV_NETWORK,\n\t\t\t      vnet_versions, ARRAY_SIZE(vnet_versions),\n\t\t\t      &vnet_vio_ops, vp->dev->name);\n\tif (err)\n\t\tgoto err_out_free_port;\n\n\terr = vio_ldc_alloc(&port->vio, &vnet_ldc_cfg, port);\n\tif (err)\n\t\tgoto err_out_free_port;\n\n\tnetif_napi_add(port->vp->dev, &port->napi, sunvnet_poll_common);\n\n\tINIT_HLIST_NODE(&port->hash);\n\tINIT_LIST_HEAD(&port->list);\n\n\tswitch_port = 0;\n\tif (mdesc_get_property(hp, vdev->mp, \"switch-port\", NULL))\n\t\tswitch_port = 1;\n\tport->switch_port = switch_port;\n\tport->tso = true;\n\tport->tsolen = 0;\n\n\tspin_lock_irqsave(&vp->lock, flags);\n\tif (switch_port)\n\t\tlist_add_rcu(&port->list, &vp->port_list);\n\telse\n\t\tlist_add_tail_rcu(&port->list, &vp->port_list);\n\thlist_add_head_rcu(&port->hash,\n\t\t\t   &vp->port_hash[vnet_hashfn(port->raddr)]);\n\tsunvnet_port_add_txq_common(port);\n\tspin_unlock_irqrestore(&vp->lock, flags);\n\n\tdev_set_drvdata(&vdev->dev, port);\n\n\tpr_info(\"%s: PORT ( remote-mac %pM%s )\\n\",\n\t\tvp->dev->name, port->raddr, switch_port ? \" switch-port\" : \"\");\n\n\ttimer_setup(&port->clean_timer, sunvnet_clean_timer_expire_common, 0);\n\n\tnapi_enable(&port->napi);\n\tvio_port_up(&port->vio);\n\n\tmdesc_release(hp);\n\n\treturn 0;\n\nerr_out_free_port:\n\tkfree(port);\n\nerr_out_put_mdesc:\n\tmdesc_release(hp);\n\treturn err;\n}\n\nstatic void vnet_port_remove(struct vio_dev *vdev)\n{\n\tstruct vnet_port *port = dev_get_drvdata(&vdev->dev);\n\n\tif (port) {\n\t\tdel_timer_sync(&port->vio.timer);\n\n\t\tnapi_disable(&port->napi);\n\n\t\tlist_del_rcu(&port->list);\n\t\thlist_del_rcu(&port->hash);\n\n\t\tsynchronize_rcu();\n\t\ttimer_shutdown_sync(&port->clean_timer);\n\t\tsunvnet_port_rm_txq_common(port);\n\t\tnetif_napi_del(&port->napi);\n\t\tsunvnet_port_free_tx_bufs_common(port);\n\t\tvio_ldc_free(&port->vio);\n\n\t\tdev_set_drvdata(&vdev->dev, NULL);\n\n\t\tkfree(port);\n\t}\n}\n\nstatic const struct vio_device_id vnet_port_match[] = {\n\t{\n\t\t.type = \"vnet-port\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(vio, vnet_port_match);\n\nstatic struct vio_driver vnet_port_driver = {\n\t.id_table\t= vnet_port_match,\n\t.probe\t\t= vnet_port_probe,\n\t.remove\t\t= vnet_port_remove,\n\t.name\t\t= \"vnet_port\",\n};\n\nstatic int __init vnet_init(void)\n{\n\tpr_info(\"%s\\n\", version);\n\treturn vio_register_driver(&vnet_port_driver);\n}\n\nstatic void __exit vnet_exit(void)\n{\n\tvio_unregister_driver(&vnet_port_driver);\n\tvnet_cleanup();\n}\n\nmodule_init(vnet_init);\nmodule_exit(vnet_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}